{
  "module_name": "cx23885-video.c",
  "hash_id": "2ad64418c86f16d4ea4c32c8cce6bc3b307c13b1ac419ed3b3d9b4dff55d0318",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-video.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n#include \"cx23885-video.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <asm/div64.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include \"cx23885-ioctl.h\"\n#include \"xc2028.h\"\n\n#include <media/drv-intf/cx25840.h>\n\nMODULE_DESCRIPTION(\"v4l2 driver module for cx23885 based TV cards\");\nMODULE_AUTHOR(\"Steven Toth <stoth@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic unsigned int video_nr[] = {[0 ... (CX23885_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int vbi_nr[]   = {[0 ... (CX23885_MAXBOARDS - 1)] = UNSET };\n\nmodule_param_array(video_nr, int, NULL, 0444);\nmodule_param_array(vbi_nr,   int, NULL, 0444);\n\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\nMODULE_PARM_DESC(vbi_nr, \"vbi device numbers\");\n\nstatic unsigned int video_debug;\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug, \"enable debug messages [video]\");\n\nstatic unsigned int irq_debug;\nmodule_param(irq_debug, int, 0644);\nMODULE_PARM_DESC(irq_debug, \"enable debug messages [IRQ handler]\");\n\nstatic unsigned int vid_limit = 16;\nmodule_param(vid_limit, int, 0644);\nMODULE_PARM_DESC(vid_limit, \"capture memory limit in megabytes\");\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (video_debug >= level)\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: video:\" fmt), \\\n\t\t\t__func__, ##arg); \\\n\t} while (0)\n\n \n \n\n#define FORMAT_FLAGS_PACKED       0x01\nstatic struct cx23885_fmt formats[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_YUYV,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}\n};\n\nstatic struct cx23885_fmt *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats+i;\n\treturn NULL;\n}\n\n \n\nvoid cx23885_video_wakeup(struct cx23885_dev *dev,\n\tstruct cx23885_dmaqueue *q, u32 count)\n{\n\tstruct cx23885_buffer *buf;\n\n\tif (list_empty(&q->active))\n\t\treturn;\n\tbuf = list_entry(q->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\tbuf->vb.sequence = q->count++;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tdprintk(2, \"[%p/%d] wakeup reg=%d buf=%d\\n\", buf,\n\t\t\tbuf->vb.vb2_buf.index, count, q->count);\n\tlist_del(&buf->queue);\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nint cx23885_set_tvnorm(struct cx23885_dev *dev, v4l2_std_id norm)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format.code = MEDIA_BUS_FMT_FIXED,\n\t};\n\n\tdprintk(1, \"%s(norm = 0x%08x) name: [%s]\\n\",\n\t\t__func__,\n\t\t(unsigned int)norm,\n\t\tv4l2_norm_to_name(norm));\n\n\tif (dev->tvnorm == norm)\n\t\treturn 0;\n\n\tif (dev->tvnorm != norm) {\n\t\tif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq) ||\n\t\t    vb2_is_busy(&dev->vb2_mpegq))\n\t\t\treturn -EBUSY;\n\t}\n\n\tdev->tvnorm = norm;\n\tdev->width = 720;\n\tdev->height = norm_maxh(norm);\n\tdev->field = V4L2_FIELD_INTERLACED;\n\n\tcall_all(dev, video, s_std, norm);\n\n\tformat.format.width = dev->width;\n\tformat.format.height = dev->height;\n\tformat.format.field = dev->field;\n\tcall_all(dev, pad, set_fmt, NULL, &format);\n\n\treturn 0;\n}\n\nstatic struct video_device *cx23885_vdev_init(struct cx23885_dev *dev,\n\t\t\t\t    struct pci_dev *pci,\n\t\t\t\t    struct video_device *template,\n\t\t\t\t    char *type)\n{\n\tstruct video_device *vfd;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tvfd = video_device_alloc();\n\tif (NULL == vfd)\n\t\treturn NULL;\n\t*vfd = *template;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->release = video_device_release;\n\tvfd->lock = &dev->lock;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s (%s)\",\n\t\t cx23885_boards[dev->board].name, type);\n\tvideo_set_drvdata(vfd, dev);\n\treturn vfd;\n}\n\nint cx23885_flatiron_write(struct cx23885_dev *dev, u8 reg, u8 data)\n{\n\t \n\tu8 buf[] = { reg, data };\n\n\tstruct i2c_msg msg = { .addr = 0x98 >> 1,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\n\treturn i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);\n}\n\nu8 cx23885_flatiron_read(struct cx23885_dev *dev, u8 reg)\n{\n\t \n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = 0x98 >> 1, .flags = 0, .buf = b0, .len = 1 },\n\t\t{ .addr = 0x98 >> 1, .flags = I2C_M_RD, .buf = b1, .len = 1 }\n\t};\n\n\tret = i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg[0], 2);\n\tif (ret != 2)\n\t\tpr_err(\"%s() error\\n\", __func__);\n\n\treturn b1[0];\n}\n\nstatic void cx23885_flatiron_dump(struct cx23885_dev *dev)\n{\n\tint i;\n\tdprintk(1, \"Flatiron dump\\n\");\n\tfor (i = 0; i < 0x24; i++) {\n\t\tdprintk(1, \"FI[%02x] = %02x\\n\", i,\n\t\t\tcx23885_flatiron_read(dev, i));\n\t}\n}\n\nstatic int cx23885_flatiron_mux(struct cx23885_dev *dev, int input)\n{\n\tu8 val;\n\tdprintk(1, \"%s(input = %d)\\n\", __func__, input);\n\n\tif (input == 1)\n\t\tval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) & ~FLD_CH_SEL;\n\telse if (input == 2)\n\t\tval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) | FLD_CH_SEL;\n\telse\n\t\treturn -EINVAL;\n\n\tval |= 0x20;  \n\n\tcx23885_flatiron_write(dev, CH_PWR_CTRL1, val);\n\n\t \n\tcx23885_flatiron_write(dev, CH_PWR_CTRL2, 0);\n\n\tif (video_debug)\n\t\tcx23885_flatiron_dump(dev);\n\n\treturn 0;\n}\n\nstatic int cx23885_video_mux(struct cx23885_dev *dev, unsigned int input)\n{\n\tdprintk(1, \"%s() video_mux: %d [vmux=%d, gpio=0x%x,0x%x,0x%x,0x%x]\\n\",\n\t\t__func__,\n\t\tinput, INPUT(input)->vmux,\n\t\tINPUT(input)->gpio0, INPUT(input)->gpio1,\n\t\tINPUT(input)->gpio2, INPUT(input)->gpio3);\n\tdev->input = input;\n\n\tif (dev->board == CX23885_BOARD_MYGICA_X8506 ||\n\t\tdev->board == CX23885_BOARD_MAGICPRO_PROHDTVE2 ||\n\t\tdev->board == CX23885_BOARD_MYGICA_X8507) {\n\t\t \n\t\tif (INPUT(input)->type == CX23885_VMUX_TELEVISION)\n\t\t\tcx23885_gpio_clear(dev, GPIO_0);\n\t}\n\n\t \n\tv4l2_subdev_call(dev->sd_cx25840, video, s_routing,\n\t\t\tINPUT(input)->vmux, 0, 0);\n\n\tif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1800) ||\n\t\t(dev->board == CX23885_BOARD_MPX885) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1250) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_IMPACTVCBE) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1265_K4) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\n\t\t(dev->board == CX23885_BOARD_HAUPPAUGE_HVR5525) ||\n\t\t(dev->board == CX23885_BOARD_MYGICA_X8507) ||\n\t\t(dev->board == CX23885_BOARD_AVERMEDIA_HC81R) ||\n\t\t(dev->board == CX23885_BOARD_VIEWCAST_260E) ||\n\t\t(dev->board == CX23885_BOARD_VIEWCAST_460E) ||\n\t\t(dev->board == CX23885_BOARD_AVERMEDIA_CE310B)) {\n\t\t \n\t\tv4l2_subdev_call(dev->sd_cx25840, audio, s_routing,\n\t\t\tINPUT(input)->amux, 0, 0);\n\n\t\tif (INPUT(input)->amux == CX25840_AUDIO7)\n\t\t\tcx23885_flatiron_mux(dev, 1);\n\t\telse if (INPUT(input)->amux == CX25840_AUDIO6)\n\t\t\tcx23885_flatiron_mux(dev, 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx23885_audio_mux(struct cx23885_dev *dev, unsigned int input)\n{\n\tdprintk(1, \"%s(input=%d)\\n\", __func__, input);\n\n\t \n\tif (INPUT(input)->amux == CX25840_AUDIO7)\n\t\tcx23885_flatiron_mux(dev, 1);\n\telse if (INPUT(input)->amux == CX25840_AUDIO6)\n\t\tcx23885_flatiron_mux(dev, 2);\n\telse {\n\t\t \n\t\tcx23885_flatiron_mux(dev, 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cx23885_start_video_dma(struct cx23885_dev *dev,\n\t\t\t   struct cx23885_dmaqueue *q,\n\t\t\t   struct cx23885_buffer *buf)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tcx_clear(VID_A_DMA_CTL, 0x11);\n\n\t \n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],\n\t\t\t\tbuf->bpl, buf->risc.dma);\n\n\t \n\tcx_write(VID_A_GPCNT_CTL, 3);\n\tq->count = 0;\n\n\t \n\tcx23885_irq_add_enable(dev, 0x01);\n\tcx_set(VID_A_INT_MSK, 0x000011);\n\n\t \n\tcx_set(DEV_CNTRL2, (1<<5));\n\tcx_set(VID_A_DMA_CTL, 0x11);  \n\n\treturn 0;\n}\n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\n\t*num_planes = 1;\n\tsizes[0] = (dev->fmt->depth * dev->width * dev->height) >> 3;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tint ret;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx23885_buffer, vb);\n\tu32 line0_offset, line1_offset;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tint field_tff;\n\n\tbuf->bpl = (dev->width * dev->fmt->depth) >> 3;\n\n\tif (vb2_plane_size(vb, 0) < dev->height * buf->bpl)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, dev->height * buf->bpl);\n\n\tswitch (dev->field) {\n\tcase V4L2_FIELD_TOP:\n\t\tret = cx23885_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, 0, UNSET,\n\t\t\t\tbuf->bpl, 0, dev->height);\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tret = cx23885_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, UNSET, 0,\n\t\t\t\tbuf->bpl, 0, dev->height);\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\t\tif (dev->tvnorm & V4L2_STD_525_60)\n\t\t\t \n\t\t\tfield_tff = 1;\n\t\telse\n\t\t\tfield_tff = 0;\n\n\t\tif (cx23885_boards[dev->board].force_bff)\n\t\t\t \n\t\t\tfield_tff = 0;\n\n\t\tif (field_tff) {\n\t\t\t \n\t\t\tdprintk(1, \"%s() Creating TFF/NTSC risc\\n\",\n\t\t\t\t\t__func__);\n\t\t\tline0_offset = buf->bpl;\n\t\t\tline1_offset = 0;\n\t\t} else {\n\t\t\t \n\t\t\tdprintk(1, \"%s() Creating BFF/PAL/SECAM risc\\n\",\n\t\t\t\t\t__func__);\n\t\t\tline0_offset = 0;\n\t\t\tline1_offset = buf->bpl;\n\t\t}\n\t\tret = cx23885_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, line0_offset,\n\t\t\t\tline1_offset,\n\t\t\t\tbuf->bpl, buf->bpl,\n\t\t\t\tdev->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tret = cx23885_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl,\n\t\t\t\t0, buf->bpl * (dev->height >> 1),\n\t\t\t\tbuf->bpl, 0,\n\t\t\t\tdev->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tret = cx23885_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl,\n\t\t\t\tbuf->bpl * (dev->height >> 1), 0,\n\t\t\t\tbuf->bpl, 0,\n\t\t\t\tdev->height >> 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;  \n\t}\n\tdprintk(2, \"[%p/%d] buffer_init - %dx%d %dbpp 0x%08x - dma=0x%08lx\\n\",\n\t\tbuf, buf->vb.vb2_buf.index,\n\t\tdev->width, dev->height, dev->fmt->depth, dev->fmt->fourcc,\n\t\t(unsigned long)buf->risc.dma);\n\treturn ret;\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_buffer *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\n\tcx23885_free_buffer(vb->vb2_queue->drv_priv, buf);\n}\n\n \nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer   *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\tstruct cx23885_buffer   *prev;\n\tstruct cx23885_dmaqueue *q    = &dev->vidq;\n\tunsigned long flags;\n\n\t \n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[2] = cpu_to_le32(0);  \n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (list_empty(&q->active)) {\n\t\tlist_add_tail(&buf->queue, &q->active);\n\t\tdprintk(2, \"[%p/%d] buffer_queue - first active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tprev = list_entry(q->active.prev, struct cx23885_buffer,\n\t\t\tqueue);\n\t\tlist_add_tail(&buf->queue, &q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t\tdprintk(2, \"[%p/%d] buffer_queue - append to active\\n\",\n\t\t\t\tbuf, buf->vb.vb2_buf.index);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\tstruct cx23885_dmaqueue *dmaq = &dev->vidq;\n\tstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\tcx23885_start_video_dma(dev, dmaq, buf);\n\treturn 0;\n}\n\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\tstruct cx23885_dmaqueue *dmaq = &dev->vidq;\n\tunsigned long flags;\n\n\tcx_clear(VID_A_DMA_CTL, 0x11);\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic const struct vb2_ops cx23885_video_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = cx23885_start_streaming,\n\t.stop_streaming = cx23885_stop_streaming,\n};\n\n \n \n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.width        = dev->width;\n\tf->fmt.pix.height       = dev->height;\n\tf->fmt.pix.field        = dev->field;\n\tf->fmt.pix.pixelformat  = dev->fmt->fourcc;\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * dev->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tstruct cx23885_fmt *fmt;\n\tenum v4l2_field   field;\n\tunsigned int      maxw, maxh;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\tmaxw  = 720;\n\tmaxh  = norm_maxh(dev->tvnorm);\n\n\tif (V4L2_FIELD_ANY == field) {\n\t\tfield = (f->fmt.pix.height > maxh/2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t}\n\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\t\tmaxh = maxh / 2;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tbreak;\n\tdefault:\n\t\tfield = V4L2_FIELD_INTERLACED;\n\t\tbreak;\n\t}\n\n\tf->fmt.pix.field = field;\n\tv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\n\t\t\t      &f->fmt.pix.height, 32, maxh, 0, 0);\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint err;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\terr = vidioc_try_fmt_vid_cap(file, priv, f);\n\n\tif (0 != err)\n\t\treturn err;\n\n\tif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq) ||\n\t    vb2_is_busy(&dev->vb2_mpegq))\n\t\treturn -EBUSY;\n\n\tdev->fmt        = format_by_fourcc(f->fmt.pix.pixelformat);\n\tdev->width      = f->fmt.pix.width;\n\tdev->height     = f->fmt.pix.height;\n\tdev->field\t= f->fmt.pix.field;\n\tdprintk(2, \"%s() width=%d height=%d field=%d\\n\", __func__,\n\t\tdev->width, dev->height, dev->field);\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\n\tcall_all(dev, pad, set_fmt, NULL, &format);\n\tv4l2_fill_pix_format(&f->fmt.pix, &format.format);\n\t \n\tf->fmt.pix.field = dev->field;\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\tstruct v4l2_capability *cap)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"cx23885\", sizeof(cap->driver));\n\tstrscpy(cap->card, cx23885_boards[dev->board].name,\n\t\tsizeof(cap->card));\n\tsprintf(cap->bus_info, \"PCIe:%s\", pci_name(dev->pci));\n\tcap->capabilities = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_AUDIO | V4L2_CAP_VBI_CAPTURE |\n\t\t\t    V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\tstruct v4l2_fmtdesc *f)\n{\n\tif (unlikely(f->index >= ARRAY_SIZE(formats)))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tbool is_50hz = dev->tvnorm & V4L2_STD_625_50;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf->numerator = is_50hz ? 54 : 11;\n\tf->denominator = is_50hz ? 59 : 10;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = 720;\n\t\tsel->r.height = norm_maxh(dev->tvnorm);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t*id = dev->tvnorm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id tvnorms)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\treturn cx23885_set_tvnorm(dev, tvnorms);\n}\n\nint cx23885_enum_input(struct cx23885_dev *dev, struct v4l2_input *i)\n{\n\tstatic const char *iname[] = {\n\t\t[CX23885_VMUX_COMPOSITE1] = \"Composite1\",\n\t\t[CX23885_VMUX_COMPOSITE2] = \"Composite2\",\n\t\t[CX23885_VMUX_COMPOSITE3] = \"Composite3\",\n\t\t[CX23885_VMUX_COMPOSITE4] = \"Composite4\",\n\t\t[CX23885_VMUX_SVIDEO]     = \"S-Video\",\n\t\t[CX23885_VMUX_COMPONENT]  = \"Component\",\n\t\t[CX23885_VMUX_TELEVISION] = \"Television\",\n\t\t[CX23885_VMUX_CABLE]      = \"Cable TV\",\n\t\t[CX23885_VMUX_DVB]        = \"DVB\",\n\t\t[CX23885_VMUX_DEBUG]      = \"for debug only\",\n\t};\n\tunsigned int n;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tn = i->index;\n\tif (n >= MAX_CX23885_INPUT)\n\t\treturn -EINVAL;\n\n\tif (0 == INPUT(n)->type)\n\t\treturn -EINVAL;\n\n\ti->index = n;\n\ti->type  = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(i->name, iname[INPUT(n)->type], sizeof(i->name));\n\ti->std = CX23885_NORMS;\n\tif ((CX23885_VMUX_TELEVISION == INPUT(n)->type) ||\n\t\t(CX23885_VMUX_CABLE == INPUT(n)->type)) {\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\t\ti->audioset = 4;\n\t} else {\n\t\t \n\t\ti->audioset = 3;\n\t}\n\n\tif (dev->input == n) {\n\t\t \n\t\tcall_all(dev, video, g_input_status, &i->status);\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tdprintk(1, \"%s()\\n\", __func__);\n\treturn cx23885_enum_input(dev, i);\n}\n\nint cx23885_get_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\t*i = dev->input;\n\tdprintk(1, \"%s() returns %d\\n\", __func__, *i);\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\treturn cx23885_get_input(file, priv, i);\n}\n\nint cx23885_set_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s(%d)\\n\", __func__, i);\n\n\tif (i >= MAX_CX23885_INPUT) {\n\t\tdprintk(1, \"%s() -EINVAL\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (INPUT(i)->type == 0)\n\t\treturn -EINVAL;\n\n\tcx23885_video_mux(dev, i);\n\n\t \n\t \n\tcx23885_audio_mux(dev, i);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn cx23885_set_input(file, priv, i);\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tcall_all(dev, core, log_status);\n\treturn 0;\n}\n\nstatic int cx23885_query_audinput(struct file *file, void *priv,\n\tstruct v4l2_audio *i)\n{\n\tstatic const char *iname[] = {\n\t\t[0] = \"Baseband L/R 1\",\n\t\t[1] = \"Baseband L/R 2\",\n\t\t[2] = \"TV\",\n\t};\n\tunsigned int n;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tn = i->index;\n\tif (n >= 3)\n\t\treturn -EINVAL;\n\n\tmemset(i, 0, sizeof(*i));\n\ti->index = n;\n\tstrscpy(i->name, iname[n], sizeof(i->name));\n\ti->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n\n}\n\nstatic int vidioc_enum_audinput(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_audio *i)\n{\n\treturn cx23885_query_audinput(file, priv, i);\n}\n\nstatic int vidioc_g_audinput(struct file *file, void *priv,\n\tstruct v4l2_audio *i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif ((CX23885_VMUX_TELEVISION == INPUT(dev->input)->type) ||\n\t\t(CX23885_VMUX_CABLE == INPUT(dev->input)->type))\n\t\ti->index = 2;\n\telse\n\t\ti->index = dev->audinput;\n\tdprintk(1, \"%s(input=%d)\\n\", __func__, i->index);\n\n\treturn cx23885_query_audinput(file, priv, i);\n}\n\nstatic int vidioc_s_audinput(struct file *file, void *priv,\n\tconst struct v4l2_audio *i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif ((CX23885_VMUX_TELEVISION == INPUT(dev->input)->type) ||\n\t\t(CX23885_VMUX_CABLE == INPUT(dev->input)->type)) {\n\t\treturn i->index != 2 ? -EINVAL : 0;\n\t}\n\tif (i->index > 1)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s(%d)\\n\", __func__, i->index);\n\n\tdev->audinput = i->index;\n\n\t \n\tcx23885_flatiron_mux(dev, dev->audinput + 1);\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type == TUNER_ABSENT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\n\tcall_all(dev, tuner, g_tuner, t);\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type == TUNER_ABSENT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\t \n\tcall_all(dev, tuner, s_tuner, t);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type == TUNER_ABSENT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tf->type = V4L2_TUNER_ANALOG_TV;\n\tf->frequency = dev->freq;\n\n\tcall_all(dev, tuner, g_frequency, f);\n\n\treturn 0;\n}\n\nstatic int cx23885_set_freq(struct cx23885_dev *dev, const struct v4l2_frequency *f)\n{\n\tstruct v4l2_ctrl *mute;\n\tint old_mute_val = 1;\n\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type == TUNER_ABSENT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (unlikely(f->tuner != 0))\n\t\treturn -EINVAL;\n\n\tdev->freq = f->frequency;\n\n\t \n\tmute = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_AUDIO_MUTE);\n\tif (mute) {\n\t\told_mute_val = v4l2_ctrl_g_ctrl(mute);\n\t\tif (!old_mute_val)\n\t\t\tv4l2_ctrl_s_ctrl(mute, 1);\n\t}\n\n\tcall_all(dev, tuner, s_frequency, f);\n\n\t \n\tmsleep(100);\n\n\t \n\tif (old_mute_val == 0)\n\t\tv4l2_ctrl_s_ctrl(mute, old_mute_val);\n\n\treturn 0;\n}\n\nstatic int cx23885_set_freq_via_ops(struct cx23885_dev *dev,\n\tconst struct v4l2_frequency *f)\n{\n\tstruct v4l2_ctrl *mute;\n\tint old_mute_val = 1;\n\tstruct vb2_dvb_frontend *vfe;\n\tstruct dvb_frontend *fe;\n\n\tstruct analog_parameters params = {\n\t\t.mode      = V4L2_TUNER_ANALOG_TV,\n\t\t.audmode   = V4L2_TUNER_MODE_STEREO,\n\t\t.std       = dev->tvnorm,\n\t\t.frequency = f->frequency\n\t};\n\n\tdev->freq = f->frequency;\n\n\t \n\tmute = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_AUDIO_MUTE);\n\tif (mute) {\n\t\told_mute_val = v4l2_ctrl_g_ctrl(mute);\n\t\tif (!old_mute_val)\n\t\t\tv4l2_ctrl_s_ctrl(mute, 1);\n\t}\n\n\t \n\tdprintk(1, \"%s() frequency=%d tuner=%d std=0x%llx\\n\", __func__,\n\t\tparams.frequency, f->tuner, params.std);\n\n\tvfe = vb2_dvb_get_frontend(&dev->ts2.frontends, 1);\n\tif (!vfe) {\n\t\treturn -EINVAL;\n\t}\n\n\tfe = vfe->dvb.frontend;\n\n\tif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1265_K4) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_HVR5525) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB) ||\n\t    (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC))\n\t\tfe = &dev->ts1.analog_fe;\n\n\tif (fe && fe->ops.tuner_ops.set_analog_params) {\n\t\tcall_all(dev, video, s_std, dev->tvnorm);\n\t\tfe->ops.tuner_ops.set_analog_params(fe, &params);\n\t}\n\telse\n\t\tpr_err(\"%s() No analog tuner, aborting\\n\", __func__);\n\n\t \n\tmsleep(100);\n\n\t \n\tif (old_mute_val == 0)\n\t\tv4l2_ctrl_s_ctrl(mute, old_mute_val);\n\n\treturn 0;\n}\n\nint cx23885_set_frequency(struct file *file, void *priv,\n\tconst struct v4l2_frequency *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tswitch (dev->board) {\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1255:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1255_22111:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1850:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tret = cx23885_set_freq_via_ops(dev, f);\n\t\tbreak;\n\tdefault:\n\t\tret = cx23885_set_freq(dev, f);\n\t}\n\n\treturn ret;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\tconst struct v4l2_frequency *f)\n{\n\treturn cx23885_set_frequency(file, priv, f);\n}\n\n \n\nint cx23885_video_irq(struct cx23885_dev *dev, u32 status)\n{\n\tu32 mask, count;\n\tint handled = 0;\n\n\tmask   = cx_read(VID_A_INT_MSK);\n\tif (0 == (status & mask))\n\t\treturn handled;\n\n\tcx_write(VID_A_INT_STAT, status);\n\n\t \n\tif ((status & VID_BC_MSK_OPC_ERR) ||\n\t\t(status & VID_BC_MSK_SYNC) ||\n\t\t(status & VID_BC_MSK_OF)) {\n\n\t\tif (status & VID_BC_MSK_OPC_ERR) {\n\t\t\tdprintk(7, \" (VID_BC_MSK_OPC_ERR 0x%08x)\\n\",\n\t\t\t\tVID_BC_MSK_OPC_ERR);\n\t\t\tpr_warn(\"%s: video risc op code error\\n\",\n\t\t\t\tdev->name);\n\t\t\tcx23885_sram_channel_dump(dev,\n\t\t\t\t&dev->sram_channels[SRAM_CH01]);\n\t\t}\n\n\t\tif (status & VID_BC_MSK_SYNC)\n\t\t\tdprintk(7, \" (VID_BC_MSK_SYNC 0x%08x) video lines miss-match\\n\",\n\t\t\t\tVID_BC_MSK_SYNC);\n\n\t\tif (status & VID_BC_MSK_OF)\n\t\t\tdprintk(7, \" (VID_BC_MSK_OF 0x%08x) fifo overflow\\n\",\n\t\t\t\tVID_BC_MSK_OF);\n\n\t}\n\n\t \n\tif (status & VID_BC_MSK_RISCI1) {\n\t\tspin_lock(&dev->slock);\n\t\tcount = cx_read(VID_A_GPCNT);\n\t\tcx23885_video_wakeup(dev, &dev->vidq, count);\n\t\tspin_unlock(&dev->slock);\n\t\thandled++;\n\t}\n\n\t \n\thandled += cx23885_vbi_irq(dev, status);\n\n\treturn handled;\n}\n\n \n \n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner\t       = THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = vb2_fop_release,\n\t.read           = vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap     = cx23885_vbi_fmt,\n\t.vidioc_try_fmt_vbi_cap   = cx23885_vbi_fmt,\n\t.vidioc_s_fmt_vbi_cap     = cx23885_vbi_fmt,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_prepare_buf   = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_g_pixelaspect = vidioc_g_pixelaspect,\n\t.vidioc_g_selection   = vidioc_g_selection,\n\t.vidioc_s_std         = vidioc_s_std,\n\t.vidioc_g_std         = vidioc_g_std,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_log_status    = vidioc_log_status,\n\t.vidioc_g_tuner       = vidioc_g_tuner,\n\t.vidioc_s_tuner       = vidioc_s_tuner,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info   = cx23885_g_chip_info,\n\t.vidioc_g_register    = cx23885_g_register,\n\t.vidioc_s_register    = cx23885_s_register,\n#endif\n\t.vidioc_enumaudio     = vidioc_enum_audinput,\n\t.vidioc_g_audio       = vidioc_g_audinput,\n\t.vidioc_s_audio       = vidioc_s_audinput,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device cx23885_vbi_template;\nstatic struct video_device cx23885_video_template = {\n\t.name                 = \"cx23885-video\",\n\t.fops                 = &video_fops,\n\t.ioctl_ops\t      = &video_ioctl_ops,\n\t.tvnorms              = CX23885_NORMS,\n};\n\nvoid cx23885_video_unregister(struct cx23885_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\tcx23885_irq_remove(dev, 0x01);\n\n\tif (dev->vbi_dev) {\n\t\tif (video_is_registered(dev->vbi_dev))\n\t\t\tvideo_unregister_device(dev->vbi_dev);\n\t\telse\n\t\t\tvideo_device_release(dev->vbi_dev);\n\t\tdev->vbi_dev = NULL;\n\t}\n\tif (dev->video_dev) {\n\t\tif (video_is_registered(dev->video_dev))\n\t\t\tvideo_unregister_device(dev->video_dev);\n\t\telse\n\t\t\tvideo_device_release(dev->video_dev);\n\t\tdev->video_dev = NULL;\n\t}\n\n\tif (dev->audio_dev)\n\t\tcx23885_audio_unregister(dev);\n}\n\nint cx23885_video_register(struct cx23885_dev *dev)\n{\n\tstruct vb2_queue *q;\n\tint err;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tcx23885_vbi_template = cx23885_video_template;\n\tstrscpy(cx23885_vbi_template.name, \"cx23885-vbi\",\n\t\tsizeof(cx23885_vbi_template.name));\n\n\tdev->tvnorm = V4L2_STD_NTSC_M;\n\tdev->fmt = format_by_fourcc(V4L2_PIX_FMT_YUYV);\n\tdev->field = V4L2_FIELD_INTERLACED;\n\tdev->width = 720;\n\tdev->height = norm_maxh(dev->tvnorm);\n\n\t \n\tINIT_LIST_HEAD(&dev->vidq.active);\n\n\t \n\tINIT_LIST_HEAD(&dev->vbiq.active);\n\n\tcx23885_irq_add_enable(dev, 0x01);\n\n\tif ((TUNER_ABSENT != dev->tuner_type) &&\n\t\t\t((dev->tuner_bus == 0) || (dev->tuner_bus == 1))) {\n\t\tstruct v4l2_subdev *sd = NULL;\n\n\t\tif (dev->tuner_addr)\n\t\t\tsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\n\t\t\t\t&dev->i2c_bus[dev->tuner_bus].i2c_adap,\n\t\t\t\t\"tuner\", dev->tuner_addr, NULL);\n\t\telse\n\t\t\tsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\n\t\t\t\t&dev->i2c_bus[dev->tuner_bus].i2c_adap,\n\t\t\t\t\"tuner\", 0, v4l2_i2c_tuner_addrs(ADDRS_TV));\n\t\tif (sd) {\n\t\t\tstruct tuner_setup tun_setup;\n\n\t\t\tmemset(&tun_setup, 0, sizeof(tun_setup));\n\t\t\ttun_setup.mode_mask = T_ANALOG_TV;\n\t\t\ttun_setup.type = dev->tuner_type;\n\t\t\ttun_setup.addr = v4l2_i2c_subdev_addr(sd);\n\t\t\ttun_setup.tuner_callback = cx23885_tuner_callback;\n\n\t\t\tv4l2_subdev_call(sd, tuner, s_type_addr, &tun_setup);\n\n\t\t\tif ((dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXTV1200) ||\n\t\t\t    (dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200)) {\n\t\t\t\tstruct xc2028_ctrl ctrl = {\n\t\t\t\t\t.fname = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t\t.max_len = 64\n\t\t\t\t};\n\t\t\t\tstruct v4l2_priv_tun_config cfg = {\n\t\t\t\t\t.tuner = dev->tuner_type,\n\t\t\t\t\t.priv = &ctrl\n\t\t\t\t};\n\t\t\t\tv4l2_subdev_call(sd, tuner, s_config, &cfg);\n\t\t\t}\n\n\t\t\tif (dev->board == CX23885_BOARD_AVERMEDIA_HC81R) {\n\t\t\t\tstruct xc2028_ctrl ctrl = {\n\t\t\t\t\t.fname = \"xc3028L-v36.fw\",\n\t\t\t\t\t.max_len = 64\n\t\t\t\t};\n\t\t\t\tstruct v4l2_priv_tun_config cfg = {\n\t\t\t\t\t.tuner = dev->tuner_type,\n\t\t\t\t\t.priv = &ctrl\n\t\t\t\t};\n\t\t\t\tv4l2_subdev_call(sd, tuner, s_config, &cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&dev->lock);\n\tcx23885_set_tvnorm(dev, dev->tvnorm);\n\tcx23885_video_mux(dev, 0);\n\tcx23885_audio_mux(dev, 0);\n\tmutex_unlock(&dev->lock);\n\n\tq = &dev->vb2_vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx23885_buffer);\n\tq->ops = &cx23885_video_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\tgoto fail_unreg;\n\n\tq = &dev->vb2_vbiq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx23885_buffer);\n\tq->ops = &cx23885_vbi_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\tgoto fail_unreg;\n\n\t \n\tdev->video_dev = cx23885_vdev_init(dev, dev->pci,\n\t\t&cx23885_video_template, \"video\");\n\tdev->video_dev->queue = &dev->vb2_vidq;\n\tdev->video_dev->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t      V4L2_CAP_AUDIO | V4L2_CAP_VIDEO_CAPTURE;\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tdev->video_dev->device_caps |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tdev->video_dev->device_caps |= V4L2_CAP_TUNER;\n\t}\n\n\terr = video_register_device(dev->video_dev, VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[dev->nr]);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register video device\\n\",\n\t\t\tdev->name);\n\t\tgoto fail_unreg;\n\t}\n\tpr_info(\"%s: registered device %s [v4l2]\\n\",\n\t       dev->name, video_device_node_name(dev->video_dev));\n\n\t \n\tdev->vbi_dev = cx23885_vdev_init(dev, dev->pci,\n\t\t&cx23885_vbi_template, \"vbi\");\n\tdev->vbi_dev->queue = &dev->vb2_vbiq;\n\tdev->vbi_dev->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t    V4L2_CAP_AUDIO | V4L2_CAP_VBI_CAPTURE;\n\tswitch (dev->board) {  \n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\t\tdev->vbi_dev->device_caps |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tdev->vbi_dev->device_caps |= V4L2_CAP_TUNER;\n\t}\n\terr = video_register_device(dev->vbi_dev, VFL_TYPE_VBI,\n\t\t\t\t    vbi_nr[dev->nr]);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register vbi device\\n\",\n\t\t\tdev->name);\n\t\tgoto fail_unreg;\n\t}\n\tpr_info(\"%s: registered device %s\\n\",\n\t       dev->name, video_device_node_name(dev->vbi_dev));\n\n\t \n\tdev->audio_dev = cx23885_audio_register(dev);\n\n\treturn 0;\n\nfail_unreg:\n\tcx23885_video_unregister(dev);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}