{
  "module_name": "cx23885-i2c.c",
  "hash_id": "b1740b15f5aee497c5da91f3dbda681836c73d30724f9f80af59c78e5d3c9250",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-i2c.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include <media/v4l2-common.h>\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"enable debug messages [i2c]\");\n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (i2c_debug >= level)\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: i2c:\" fmt), \\\n\t\t\t__func__, ##arg); \\\n\t} while (0)\n\n#define I2C_WAIT_DELAY 32\n#define I2C_WAIT_RETRY 64\n\n#define I2C_EXTEND  (1 << 3)\n#define I2C_NOSTOP  (1 << 4)\n\nstatic inline int i2c_slave_did_ack(struct i2c_adapter *i2c_adap)\n{\n\tstruct cx23885_i2c *bus = i2c_adap->algo_data;\n\tstruct cx23885_dev *dev = bus->dev;\n\treturn cx_read(bus->reg_stat) & 0x01;\n}\n\nstatic inline int i2c_is_busy(struct i2c_adapter *i2c_adap)\n{\n\tstruct cx23885_i2c *bus = i2c_adap->algo_data;\n\tstruct cx23885_dev *dev = bus->dev;\n\treturn cx_read(bus->reg_stat) & 0x02 ? 1 : 0;\n}\n\nstatic int i2c_wait_done(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (!i2c_is_busy(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int i2c_sendbytes(struct i2c_adapter *i2c_adap,\n\t\t\t const struct i2c_msg *msg, int joined_rlen)\n{\n\tstruct cx23885_i2c *bus = i2c_adap->algo_data;\n\tstruct cx23885_dev *dev = bus->dev;\n\tu32 wdata, addr, ctrl;\n\tint retval, cnt;\n\n\tif (joined_rlen)\n\t\tdprintk(1, \"%s(msg->wlen=%d, nextmsg->rlen=%d)\\n\", __func__,\n\t\t\tmsg->len, joined_rlen);\n\telse\n\t\tdprintk(1, \"%s(msg->len=%d)\\n\", __func__, msg->len);\n\n\t \n\tif (msg->len == 0) {\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\treturn -EIO;\n\t\tif (!i2c_slave_did_ack(i2c_adap))\n\t\t\treturn -ENXIO;\n\n\t\tdprintk(1, \"%s() returns 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\n\t \n\taddr = (msg->addr << 25) | msg->buf[0];\n\twdata = msg->buf[0];\n\tctrl = bus->i2c_period | (1 << 12) | (1 << 2);\n\n\tif (msg->len > 1)\n\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\telse if (joined_rlen)\n\t\tctrl |= I2C_NOSTOP;\n\n\tcx_write(bus->reg_addr, addr);\n\tcx_write(bus->reg_wdata, wdata);\n\tcx_write(bus->reg_ctrl, ctrl);\n\n\tif (!i2c_wait_done(i2c_adap))\n\t\tgoto eio;\n\tif (i2c_debug) {\n\t\tprintk(KERN_DEBUG \" <W %02x %02x\", msg->addr << 1, msg->buf[0]);\n\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\tpr_cont(\" >\\n\");\n\t}\n\n\tfor (cnt = 1; cnt < msg->len; cnt++) {\n\t\t \n\t\twdata = msg->buf[cnt];\n\t\tctrl = bus->i2c_period | (1 << 12) | (1 << 2);\n\n\t\tif (cnt < msg->len - 1)\n\t\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\t\telse if (joined_rlen)\n\t\t\tctrl |= I2C_NOSTOP;\n\n\t\tcx_write(bus->reg_addr, addr);\n\t\tcx_write(bus->reg_wdata, wdata);\n\t\tcx_write(bus->reg_ctrl, ctrl);\n\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\tgoto eio;\n\t\tif (i2c_debug) {\n\t\t\tpr_cont(\" %02x\", msg->buf[cnt]);\n\t\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\t\tpr_cont(\" >\\n\");\n\t\t}\n\t}\n\treturn msg->len;\n\n eio:\n\tretval = -EIO;\n\tif (i2c_debug)\n\t\tpr_err(\" ERR: %d\\n\", retval);\n\treturn retval;\n}\n\nstatic int i2c_readbytes(struct i2c_adapter *i2c_adap,\n\t\t\t const struct i2c_msg *msg, int joined)\n{\n\tstruct cx23885_i2c *bus = i2c_adap->algo_data;\n\tstruct cx23885_dev *dev = bus->dev;\n\tu32 ctrl, cnt;\n\tint retval;\n\n\n\tif (i2c_debug && !joined)\n\t\tdprintk(1, \"%s(msg->len=%d)\\n\", __func__, msg->len);\n\n\t \n\tif (msg->len == 0) {\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\treturn -EIO;\n\t\tif (!i2c_slave_did_ack(i2c_adap))\n\t\t\treturn -ENXIO;\n\n\n\t\tdprintk(1, \"%s() returns 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (i2c_debug) {\n\t\tif (joined)\n\t\t\tdprintk(1, \" R\");\n\t\telse\n\t\t\tdprintk(1, \" <R %02x\", (msg->addr << 1) + 1);\n\t}\n\n\tfor (cnt = 0; cnt < msg->len; cnt++) {\n\n\t\tctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;\n\n\t\tif (cnt < msg->len - 1)\n\t\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, ctrl);\n\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\tgoto eio;\n\t\tmsg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;\n\t\tif (i2c_debug) {\n\t\t\tdprintk(1, \" %02x\", msg->buf[cnt]);\n\t\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\t\tdprintk(1, \" >\\n\");\n\t\t}\n\t}\n\treturn msg->len;\n\n eio:\n\tretval = -EIO;\n\tif (i2c_debug)\n\t\tpr_err(\" ERR: %d\\n\", retval);\n\treturn retval;\n}\n\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t    struct i2c_msg *msgs, int num)\n{\n\tint i, retval = 0;\n\n\tdprintk(1, \"%s(num = %d)\\n\", __func__, num);\n\n\tfor (i = 0 ; i < num; i++) {\n\t\tdprintk(1, \"%s(num = %d) addr = 0x%02x  len = 0x%x\\n\",\n\t\t\t__func__, num, msgs[i].addr, msgs[i].len);\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 0);\n\t\t} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr) {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i],\n\t\t\t\t\t       msgs[i + 1].len);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t\ti++;\n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 1);\n\t\t} else {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i], 0);\n\t\t}\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t}\n\treturn num;\n\n err:\n\treturn retval;\n}\n\nstatic u32 cx23885_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm cx23885_i2c_algo_template = {\n\t.master_xfer\t= i2c_xfer,\n\t.functionality\t= cx23885_functionality,\n};\n\n \n\nstatic const struct i2c_adapter cx23885_i2c_adap_template = {\n\t.name              = \"cx23885\",\n\t.owner             = THIS_MODULE,\n\t.algo              = &cx23885_i2c_algo_template,\n};\n\nstatic const struct i2c_client cx23885_i2c_client_template = {\n\t.name\t= \"cx23885 internal\",\n};\n\nstatic char *i2c_devs[128] = {\n\t[0x10 >> 1] = \"tda10048\",\n\t[0x12 >> 1] = \"dib7000pc\",\n\t[0x1c >> 1] = \"lgdt3303\",\n\t[0x80 >> 1] = \"cs3308\",\n\t[0x82 >> 1] = \"cs3308\",\n\t[0x86 >> 1] = \"tda9887\",\n\t[0x32 >> 1] = \"cx24227\",\n\t[0x88 >> 1] = \"cx25837\",\n\t[0x84 >> 1] = \"tda8295\",\n\t[0x98 >> 1] = \"flatiron\",\n\t[0xa0 >> 1] = \"eeprom\",\n\t[0xc0 >> 1] = \"tuner/mt2131/tda8275\",\n\t[0xc2 >> 1] = \"tuner/mt2131/tda8275/xc5000/xc3028\",\n\t[0xc8 >> 1] = \"tuner/xc3028L\",\n};\n\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\n{\n\tunsigned char buf;\n\tint i, rc;\n\n\tfor (i = 0; i < 128; i++) {\n\t\tc->addr = i;\n\t\trc = i2c_master_recv(c, &buf, 0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tpr_info(\"%s: i2c scan: found device @ 0x%04x  [%s]\\n\",\n\t\t       name, i, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n}\n\n \nint cx23885_i2c_register(struct cx23885_i2c *bus)\n{\n\tstruct cx23885_dev *dev = bus->dev;\n\n\tdprintk(1, \"%s(bus = %d)\\n\", __func__, bus->nr);\n\n\tbus->i2c_adap = cx23885_i2c_adap_template;\n\tbus->i2c_client = cx23885_i2c_client_template;\n\tbus->i2c_adap.dev.parent = &dev->pci->dev;\n\n\tstrscpy(bus->i2c_adap.name, bus->dev->name,\n\t\tsizeof(bus->i2c_adap.name));\n\n\tbus->i2c_adap.algo_data = bus;\n\ti2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);\n\ti2c_add_adapter(&bus->i2c_adap);\n\n\tbus->i2c_client.adapter = &bus->i2c_adap;\n\n\tif (0 == bus->i2c_rc) {\n\t\tdprintk(1, \"%s: i2c bus %d registered\\n\", dev->name, bus->nr);\n\t\tif (i2c_scan) {\n\t\t\tpr_info(\"%s: scan bus %d:\\n\",\n\t\t\t\t\tdev->name, bus->nr);\n\t\t\tdo_i2c_scan(dev->name, &bus->i2c_client);\n\t\t}\n\t} else\n\t\tpr_warn(\"%s: i2c bus %d register FAILED\\n\",\n\t\t\tdev->name, bus->nr);\n\n\t \n\tif (0 == bus->i2c_rc) {\n\t\tstruct i2c_board_info info;\n\t\tstatic const unsigned short addr_list[] = {\n\t\t\t0x6b, I2C_CLIENT_END\n\t\t};\n\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\t\t \n\t\ti2c_new_scanned_device(&bus->i2c_adap, &info, addr_list,\n\t\t\t\t       i2c_probe_func_quick_read);\n\t}\n\n\treturn bus->i2c_rc;\n}\n\nint cx23885_i2c_unregister(struct cx23885_i2c *bus)\n{\n\ti2c_del_adapter(&bus->i2c_adap);\n\treturn 0;\n}\n\nvoid cx23885_av_clk(struct cx23885_dev *dev, int enable)\n{\n\t \n\tchar buffer[3];\n\tstruct i2c_msg msg;\n\tdprintk(1, \"%s(enabled = %d)\\n\", __func__, enable);\n\n\t \n\tbuffer[0] = 0x01;\n\tbuffer[1] = 0x44;\n\tif (enable == 1)\n\t\tbuffer[2] = 0x05;\n\telse\n\t\tbuffer[2] = 0x00;\n\n\tmsg.addr = 0x44;\n\tmsg.flags = I2C_M_TEN;\n\tmsg.len = 3;\n\tmsg.buf = buffer;\n\n\ti2c_xfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}