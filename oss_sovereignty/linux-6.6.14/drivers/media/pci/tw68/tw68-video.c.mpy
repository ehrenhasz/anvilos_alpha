{
  "module_name": "tw68-video.c",
  "hash_id": "bf1d70ba132841cc8c4f097861812cb01cae08dadfa92483d2c554893aaa7962",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw68/tw68-video.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-sg.h>\n\n#include \"tw68.h\"\n#include \"tw68-reg.h\"\n\n \n \n \nstatic const struct tw68_format formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB555,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatRGB15,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB555X,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatRGB15 | ColorFormatBSWAP,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatRGB16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatRGB16 | ColorFormatBSWAP,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR24,\n\t\t.depth\t\t= 24,\n\t\t.twformat\t= ColorFormatRGB24,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB24,\n\t\t.depth\t\t= 24,\n\t\t.twformat\t= ColorFormatRGB24 | ColorFormatBSWAP,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR32,\n\t\t.depth\t\t= 32,\n\t\t.twformat\t= ColorFormatRGB32,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB32,\n\t\t.depth\t\t= 32,\n\t\t.twformat\t= ColorFormatRGB32 | ColorFormatBSWAP |\n\t\t\t\t  ColorFormatWSWAP,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatYUY2,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.depth\t\t= 16,\n\t\t.twformat\t= ColorFormatYUY2 | ColorFormatBSWAP,\n\t}\n};\n#define FORMATS ARRAY_SIZE(formats)\n\n#define NORM_625_50\t\t\t\\\n\t\t.h_delay\t= 3,\t\\\n\t\t.h_delay0\t= 133,\t\\\n\t\t.h_start\t= 0,\t\\\n\t\t.h_stop\t\t= 719,\t\\\n\t\t.v_delay\t= 24,\t\\\n\t\t.vbi_v_start_0\t= 7,\t\\\n\t\t.vbi_v_stop_0\t= 22,\t\\\n\t\t.video_v_start\t= 24,\t\\\n\t\t.video_v_stop\t= 311,\t\\\n\t\t.vbi_v_start_1\t= 319\n\n#define NORM_525_60\t\t\t\\\n\t\t.h_delay\t= 8,\t\\\n\t\t.h_delay0\t= 138,\t\\\n\t\t.h_start\t= 0,\t\\\n\t\t.h_stop\t\t= 719,\t\\\n\t\t.v_delay\t= 22,\t\\\n\t\t.vbi_v_start_0\t= 10,\t\\\n\t\t.vbi_v_stop_0\t= 21,\t\\\n\t\t.video_v_start\t= 22,\t\\\n\t\t.video_v_stop\t= 262,\t\\\n\t\t.vbi_v_start_1\t= 273\n\n \nstatic const struct tw68_tvnorm tvnorms[] = {\n\t{\n\t\t.name\t\t= \"PAL\",  \n\t\t.id\t\t= V4L2_STD_PAL,\n\t\tNORM_625_50,\n\n\t\t.sync_control\t= 0x18,\n\t\t.luma_control\t= 0x40,\n\t\t.chroma_ctrl1\t= 0x81,\n\t\t.chroma_gain\t= 0x2a,\n\t\t.chroma_ctrl2\t= 0x06,\n\t\t.vgate_misc\t= 0x1c,\n\t\t.format\t\t= VideoFormatPALBDGHI,\n\t}, {\n\t\t.name\t\t= \"NTSC\",\n\t\t.id\t\t= V4L2_STD_NTSC,\n\t\tNORM_525_60,\n\n\t\t.sync_control\t= 0x59,\n\t\t.luma_control\t= 0x40,\n\t\t.chroma_ctrl1\t= 0x89,\n\t\t.chroma_gain\t= 0x2a,\n\t\t.chroma_ctrl2\t= 0x0e,\n\t\t.vgate_misc\t= 0x18,\n\t\t.format\t\t= VideoFormatNTSC,\n\t}, {\n\t\t.name\t\t= \"SECAM\",\n\t\t.id\t\t= V4L2_STD_SECAM,\n\t\tNORM_625_50,\n\n\t\t.sync_control\t= 0x18,\n\t\t.luma_control\t= 0x1b,\n\t\t.chroma_ctrl1\t= 0xd1,\n\t\t.chroma_gain\t= 0x80,\n\t\t.chroma_ctrl2\t= 0x00,\n\t\t.vgate_misc\t= 0x1c,\n\t\t.format\t\t= VideoFormatSECAM,\n\t}, {\n\t\t.name\t\t= \"PAL-M\",\n\t\t.id\t\t= V4L2_STD_PAL_M,\n\t\tNORM_525_60,\n\n\t\t.sync_control\t= 0x59,\n\t\t.luma_control\t= 0x40,\n\t\t.chroma_ctrl1\t= 0xb9,\n\t\t.chroma_gain\t= 0x2a,\n\t\t.chroma_ctrl2\t= 0x0e,\n\t\t.vgate_misc\t= 0x18,\n\t\t.format\t\t= VideoFormatPALM,\n\t}, {\n\t\t.name\t\t= \"PAL-Nc\",\n\t\t.id\t\t= V4L2_STD_PAL_Nc,\n\t\tNORM_625_50,\n\n\t\t.sync_control\t= 0x18,\n\t\t.luma_control\t= 0x40,\n\t\t.chroma_ctrl1\t= 0xa1,\n\t\t.chroma_gain\t= 0x2a,\n\t\t.chroma_ctrl2\t= 0x06,\n\t\t.vgate_misc\t= 0x1c,\n\t\t.format\t\t= VideoFormatPALNC,\n\t}, {\n\t\t.name\t\t= \"PAL-60\",\n\t\t.id\t\t= V4L2_STD_PAL_60,\n\t\t.h_delay\t= 186,\n\t\t.h_start\t= 0,\n\t\t.h_stop\t\t= 719,\n\t\t.v_delay\t= 26,\n\t\t.video_v_start\t= 23,\n\t\t.video_v_stop\t= 262,\n\t\t.vbi_v_start_0\t= 10,\n\t\t.vbi_v_stop_0\t= 21,\n\t\t.vbi_v_start_1\t= 273,\n\n\t\t.sync_control\t= 0x18,\n\t\t.luma_control\t= 0x40,\n\t\t.chroma_ctrl1\t= 0x81,\n\t\t.chroma_gain\t= 0x2a,\n\t\t.chroma_ctrl2\t= 0x06,\n\t\t.vgate_misc\t= 0x1c,\n\t\t.format\t\t= VideoFormatPAL60,\n\t}\n};\n#define TVNORMS ARRAY_SIZE(tvnorms)\n\nstatic const struct tw68_format *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats+i;\n\treturn NULL;\n}\n\n\n \n \nstatic void set_tvnorm(struct tw68_dev *dev, const struct tw68_tvnorm *norm)\n{\n\tif (norm != dev->tvnorm) {\n\t\tdev->width = 720;\n\t\tdev->height = (norm->id & V4L2_STD_525_60) ? 480 : 576;\n\t\tdev->tvnorm = norm;\n\t\ttw68_set_tvnorm_hw(dev);\n\t}\n}\n\n \nstatic int tw68_set_scale(struct tw68_dev *dev, unsigned int width,\n\t\t\t  unsigned int height, enum v4l2_field field)\n{\n\tconst struct tw68_tvnorm *norm = dev->tvnorm;\n\t \n\tint hactive, hdelay, hscale;\n\tint vactive, vdelay, vscale;\n\tint comb;\n\n\tif (V4L2_FIELD_HAS_BOTH(field))\t \n\t\theight /= 2;\t\t \n\n\tpr_debug(\"%s: width=%d, height=%d, both=%d\\n\"\n\t\t \"  tvnorm h_delay=%d, h_start=%d, h_stop=%d, v_delay=%d, v_start=%d, v_stop=%d\\n\",\n\t\t__func__, width, height, V4L2_FIELD_HAS_BOTH(field),\n\t\tnorm->h_delay, norm->h_start, norm->h_stop,\n\t\tnorm->v_delay, norm->video_v_start,\n\t\tnorm->video_v_stop);\n\n\tswitch (dev->vdecoder) {\n\tcase TW6800:\n\t\thdelay = norm->h_delay0;\n\t\tbreak;\n\tdefault:\n\t\thdelay = norm->h_delay;\n\t\tbreak;\n\t}\n\n\thdelay += norm->h_start;\n\thactive = norm->h_stop - norm->h_start + 1;\n\n\thscale = (hactive * 256) / (width);\n\n\tvdelay = norm->v_delay;\n\tvactive = ((norm->id & V4L2_STD_525_60) ? 524 : 624) / 2 - norm->video_v_start;\n\tvscale = (vactive * 256) / height;\n\n\tpr_debug(\"%s: %dx%d [%s%s,%s]\\n\", __func__,\n\t\twidth, height,\n\t\tV4L2_FIELD_HAS_TOP(field)    ? \"T\" : \"\",\n\t\tV4L2_FIELD_HAS_BOTTOM(field) ? \"B\" : \"\",\n\t\tv4l2_norm_to_name(dev->tvnorm->id));\n\tpr_debug(\"%s: hactive=%d, hdelay=%d, hscale=%d; vactive=%d, vdelay=%d, vscale=%d\\n\",\n\t\t __func__,\n\t\thactive, hdelay, hscale, vactive, vdelay, vscale);\n\n\tcomb =\t((vdelay & 0x300)  >> 2) |\n\t\t((vactive & 0x300) >> 4) |\n\t\t((hdelay & 0x300)  >> 6) |\n\t\t((hactive & 0x300) >> 8);\n\tpr_debug(\"%s: setting CROP_HI=%02x, VDELAY_LO=%02x, VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\\n\",\n\t\t__func__, comb, vdelay, vactive, hdelay, hactive);\n\ttw_writeb(TW68_CROP_HI, comb);\n\ttw_writeb(TW68_VDELAY_LO, vdelay & 0xff);\n\ttw_writeb(TW68_VACTIVE_LO, vactive & 0xff);\n\ttw_writeb(TW68_HDELAY_LO, hdelay & 0xff);\n\ttw_writeb(TW68_HACTIVE_LO, hactive & 0xff);\n\n\tcomb = ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8);\n\tpr_debug(\"%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, HSCALE_LO=%02x\\n\",\n\t\t __func__, comb, vscale, hscale);\n\ttw_writeb(TW68_SCALE_HI, comb);\n\ttw_writeb(TW68_VSCALE_LO, vscale);\n\ttw_writeb(TW68_HSCALE_LO, hscale);\n\n\treturn 0;\n}\n\n \n\nint tw68_video_start_dma(struct tw68_dev *dev, struct tw68_buf *buf)\n{\n\t \n\ttw68_set_scale(dev, dev->width, dev->height, dev->field);\n\t \n\ttw_clearl(TW68_DMAC, TW68_DMAP_EN);\n\ttw_writel(TW68_DMAP_SA, buf->dma);\n\t \n\ttw_writel(TW68_INTSTAT, dev->board_virqmask);\n\t \n\ttw_andorl(TW68_DMAC, 0xff, dev->fmt->twformat |\n\t\tColorFormatGamma | TW68_DMAP_EN | TW68_FIFO_EN);\n\tdev->pci_irqmask |= dev->board_virqmask;\n\ttw_setl(TW68_INTMASK, dev->pci_irqmask);\n\treturn 0;\n}\n\n \n\n \nstatic int tw68_buffer_count(unsigned int size, unsigned int count)\n{\n\tunsigned int maxcount;\n\n\tmaxcount = (4 * 1024 * 1024) / roundup(size, PAGE_SIZE);\n\tif (count > maxcount)\n\t\tcount = maxcount;\n\treturn count;\n}\n\n \n \n\nstatic int tw68_queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct tw68_dev *dev = vb2_get_drv_priv(q);\n\tunsigned tot_bufs = q->num_buffers + *num_buffers;\n\tunsigned size = (dev->fmt->depth * dev->width * dev->height) >> 3;\n\n\tif (tot_bufs < 2)\n\t\ttot_bufs = 2;\n\ttot_bufs = tw68_buffer_count(size, tot_bufs);\n\t*num_buffers = tot_bufs - q->num_buffers;\n\t \n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\n \nstatic void tw68_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tw68_dev *dev = vb2_get_drv_priv(vq);\n\tstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\n\tstruct tw68_buf *prev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\t \n\tbuf->jmp[0] = cpu_to_le32(RISC_JUMP);\n\tbuf->jmp[1] = cpu_to_le32(buf->dma + 8);\n\n\tif (!list_empty(&dev->active)) {\n\t\tprev = list_entry(dev->active.prev, struct tw68_buf, list);\n\t\tbuf->cpu[0] |= cpu_to_le32(RISC_INT_BIT);\n\t\tprev->jmp[1] = cpu_to_le32(buf->dma);\n\t}\n\tlist_add_tail(&buf->list, &dev->active);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\n \nstatic int tw68_buf_prepare(struct vb2_buffer *vb)\n{\n\tint ret;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tw68_dev *dev = vb2_get_drv_priv(vq);\n\tstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\n\tstruct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);\n\tunsigned size, bpl;\n\n\tsize = (dev->width * dev->height * dev->fmt->depth) >> 3;\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\n\tbpl = (dev->width * dev->fmt->depth) >> 3;\n\tswitch (dev->field) {\n\tcase V4L2_FIELD_TOP:\n\t\tret = tw68_risc_buffer(dev->pci, buf, dma->sgl,\n\t\t\t\t 0, UNSET, bpl, 0, dev->height);\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tret = tw68_risc_buffer(dev->pci, buf, dma->sgl,\n\t\t\t\t UNSET, 0, bpl, 0, dev->height);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tret = tw68_risc_buffer(dev->pci, buf, dma->sgl,\n\t\t\t\t 0, bpl * (dev->height >> 1),\n\t\t\t\t bpl, 0, dev->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tret = tw68_risc_buffer(dev->pci, buf, dma->sgl,\n\t\t\t\t bpl * (dev->height >> 1), 0,\n\t\t\t\t bpl, 0, dev->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\tdefault:\n\t\tret = tw68_risc_buffer(dev->pci, buf, dma->sgl,\n\t\t\t\t 0, bpl, bpl, bpl, dev->height >> 1);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void tw68_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tw68_dev *dev = vb2_get_drv_priv(vq);\n\tstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\n\n\tif (buf->cpu)\n\t\tdma_free_coherent(&dev->pci->dev, buf->size, buf->cpu, buf->dma);\n}\n\nstatic int tw68_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct tw68_dev *dev = vb2_get_drv_priv(q);\n\tstruct tw68_buf *buf =\n\t\tcontainer_of(dev->active.next, struct tw68_buf, list);\n\n\tdev->seqnr = 0;\n\ttw68_video_start_dma(dev, buf);\n\treturn 0;\n}\n\nstatic void tw68_stop_streaming(struct vb2_queue *q)\n{\n\tstruct tw68_dev *dev = vb2_get_drv_priv(q);\n\n\t \n\ttw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\n\twhile (!list_empty(&dev->active)) {\n\t\tstruct tw68_buf *buf =\n\t\t\tcontainer_of(dev->active.next, struct tw68_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops tw68_video_qops = {\n\t.queue_setup\t= tw68_queue_setup,\n\t.buf_queue\t= tw68_buf_queue,\n\t.buf_prepare\t= tw68_buf_prepare,\n\t.buf_finish\t= tw68_buf_finish,\n\t.start_streaming = tw68_start_streaming,\n\t.stop_streaming = tw68_stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic int tw68_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct tw68_dev *dev =\n\t\tcontainer_of(ctrl->handler, struct tw68_dev, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\ttw_writeb(TW68_BRIGHT, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\ttw_writeb(TW68_HUE, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\ttw_writeb(TW68_CONTRAST, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\ttw_writeb(TW68_SAT_U, ctrl->val);\n\t\ttw_writeb(TW68_SAT_V, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_COLOR_KILLER:\n\t\tif (ctrl->val)\n\t\t\ttw_andorb(TW68_MISC2, 0xe0, 0xe0);\n\t\telse\n\t\t\ttw_andorb(TW68_MISC2, 0xe0, 0x00);\n\t\tbreak;\n\tcase V4L2_CID_CHROMA_AGC:\n\t\tif (ctrl->val)\n\t\t\ttw_andorb(TW68_LOOP, 0x30, 0x20);\n\t\telse\n\t\t\ttw_andorb(TW68_LOOP, 0x30, 0x00);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic int tw68_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.width        = dev->width;\n\tf->fmt.pix.height       = dev->height;\n\tf->fmt.pix.field        = dev->field;\n\tf->fmt.pix.pixelformat  = dev->fmt->fourcc;\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * (dev->fmt->depth)) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace\t= V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int tw68_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\tconst struct tw68_format *fmt;\n\tenum v4l2_field field;\n\tunsigned int maxh;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\tmaxh  = (dev->tvnorm->id & V4L2_STD_525_60) ? 480 : 576;\n\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tmaxh = maxh * 2;\n\t\tbreak;\n\tdefault:\n\t\tfield = (f->fmt.pix.height > maxh / 2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\t}\n\n\tf->fmt.pix.field = field;\n\tif (f->fmt.pix.width  < 48)\n\t\tf->fmt.pix.width  = 48;\n\tif (f->fmt.pix.height < 32)\n\t\tf->fmt.pix.height = 32;\n\tif (f->fmt.pix.width > 720)\n\t\tf->fmt.pix.width = 720;\n\tif (f->fmt.pix.height > maxh)\n\t\tf->fmt.pix.height = maxh;\n\tf->fmt.pix.width &= ~0x03;\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * (fmt->depth)) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\n \nstatic int tw68_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\tint err;\n\n\terr = tw68_try_fmt_vid_cap(file, priv, f);\n\tif (0 != err)\n\t\treturn err;\n\n\tdev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tdev->width = f->fmt.pix.width;\n\tdev->height = f->fmt.pix.height;\n\tdev->field = f->fmt.pix.field;\n\treturn 0;\n}\n\nstatic int tw68_enum_input(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_input *i)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\tunsigned int n;\n\n\tn = i->index;\n\tif (n >= TW68_INPUT_MAX)\n\t\treturn -EINVAL;\n\ti->index = n;\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tsnprintf(i->name, sizeof(i->name), \"Composite %d\", n);\n\n\t \n\tif (n == dev->input) {\n\t\tint v1 = tw_readb(TW68_STATUS1);\n\t\tint v2 = tw_readb(TW68_MVSN);\n\n\t\tif (0 != (v1 & (1 << 7)))\n\t\t\ti->status |= V4L2_IN_ST_NO_SYNC;\n\t\tif (0 != (v1 & (1 << 6)))\n\t\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\t\tif (0 != (v1 & (1 << 2)))\n\t\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\t\tif (0 != (v1 & 1 << 1))\n\t\t\ti->status |= V4L2_IN_ST_NO_COLOR;\n\t\tif (0 != (v2 & (1 << 2)))\n\t\t\ti->status |= V4L2_IN_ST_MACROVISION;\n\t}\n\ti->std = video_devdata(file)->tvnorms;\n\treturn 0;\n}\n\nstatic int tw68_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\t*i = dev->input;\n\treturn 0;\n}\n\nstatic int tw68_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\tif (i >= TW68_INPUT_MAX)\n\t\treturn -EINVAL;\n\tdev->input = i;\n\ttw_andorb(TW68_INFORM, 0x03 << 2, dev->input << 2);\n\treturn 0;\n}\n\nstatic int tw68_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"tw68\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Techwell Capture Card\",\n\t\tsizeof(cap->card));\n\treturn 0;\n}\n\nstatic int tw68_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\tunsigned int i;\n\n\tif (vb2_is_busy(&dev->vidq))\n\t\treturn -EBUSY;\n\n\t \n\tfor (i = 0; i < TVNORMS; i++) {\n\t\tif (id == tvnorms[i].id)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == TVNORMS) {\n\t\tfor (i = 0; i < TVNORMS; i++)\n\t\t\tif (id & tvnorms[i].id)\n\t\t\t\tbreak;\n\t}\n\t \n\tif (i == TVNORMS)\n\t\treturn -EINVAL;\n\n\tset_tvnorm(dev, &tvnorms[i]);\t \n\treturn 0;\n}\n\nstatic int tw68_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\t*id = dev->tvnorm->id;\n\treturn 0;\n}\n\nstatic int tw68_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= FORMATS)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\n \nstatic void tw68_dump_regs(struct tw68_dev *dev)\n{\n\tunsigned char line[80];\n\tint i, j, k;\n\tunsigned char *cptr;\n\n\tpr_info(\"Full dump of TW68 registers:\\n\");\n\t \n\tfor (i = 0; i < 0x100; i += 32) {\n\t\tcptr = line;\n\t\tcptr += sprintf(cptr, \"%03x  \", i);\n\t\t \n\t\tfor (j = i; j < i + 16; j += 4)\n\t\t\tcptr += sprintf(cptr, \"%08x \", tw_readl(j));\n\t\t*cptr++ = ' ';\n\t\tfor (; j < i + 32; j += 4)\n\t\t\tcptr += sprintf(cptr, \"%08x \", tw_readl(j));\n\t\t*cptr++ = '\\n';\n\t\t*cptr = 0;\n\t\tpr_info(\"%s\", line);\n\t}\n\t \n\twhile (i < 0x400) {\n\t\tcptr = line;\n\t\tcptr += sprintf(cptr, \"%03x \", i);\n\t\t \n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tcptr += sprintf(cptr, \"%02x \",\n\t\t\t\t\ttw_readb(i));\n\t\t\t\ti += 4;\n\t\t\t}\n\t\t\t*cptr++ = ' ';\n\t\t}\n\t\t*cptr++ = '\\n';\n\t\t*cptr = 0;\n\t\tpr_info(\"%s\", line);\n\t}\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\ttw68_dump_regs(dev);\n\treturn v4l2_ctrl_log_status(file, priv);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register(struct file *file, void *priv,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\tif (reg->size == 1)\n\t\treg->val = tw_readb(reg->reg);\n\telse\n\t\treg->val = tw_readl(reg->reg);\n\treturn 0;\n}\n\nstatic int vidioc_s_register(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct tw68_dev *dev = video_drvdata(file);\n\n\tif (reg->size == 1)\n\t\ttw_writeb(reg->reg, reg->val);\n\telse\n\t\ttw_writel(reg->reg & 0xffff, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ctrl_ops tw68_ctrl_ops = {\n\t.s_ctrl = tw68_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= v4l2_fh_open,\n\t.release\t\t= vb2_fop_release,\n\t.read\t\t\t= vb2_fop_read,\n\t.poll\t\t\t= vb2_fop_poll,\n\t.mmap\t\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap\t\t= tw68_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= tw68_enum_fmt_vid_cap,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_s_std\t\t\t= tw68_s_std,\n\t.vidioc_g_std\t\t\t= tw68_g_std,\n\t.vidioc_enum_input\t\t= tw68_enum_input,\n\t.vidioc_g_input\t\t\t= tw68_g_input,\n\t.vidioc_s_input\t\t\t= tw68_s_input,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_g_fmt_vid_cap\t\t= tw68_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= tw68_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= tw68_s_fmt_vid_cap,\n\t.vidioc_log_status\t\t= vidioc_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register              = vidioc_g_register,\n\t.vidioc_s_register              = vidioc_s_register,\n#endif\n};\n\nstatic const struct video_device tw68_video_template = {\n\t.name\t\t\t= \"tw68_video\",\n\t.fops\t\t\t= &video_fops,\n\t.ioctl_ops\t\t= &video_ioctl_ops,\n\t.release\t\t= video_device_release_empty,\n\t.tvnorms\t\t= TW68_NORMS,\n\t.device_caps\t\t= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t\t  V4L2_CAP_STREAMING,\n};\n\n \n \nvoid tw68_set_tvnorm_hw(struct tw68_dev *dev)\n{\n\ttw_andorb(TW68_SDT, 0x07, dev->tvnorm->format);\n}\n\nint tw68_video_init1(struct tw68_dev *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->hdl;\n\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 20);\n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 100);\n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\t \n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\n\t\t\tV4L2_CID_CHROMA_AGC, 0, 1, 1, 1);\n\tif (hdl->error) {\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn hdl->error;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\treturn 0;\n}\n\nint tw68_video_init2(struct tw68_dev *dev, int video_nr)\n{\n\tint ret;\n\n\tset_tvnorm(dev, &tvnorms[0]);\n\n\tdev->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);\n\tdev->width    = 720;\n\tdev->height   = 576;\n\tdev->field    = V4L2_FIELD_INTERLACED;\n\n\tINIT_LIST_HEAD(&dev->active);\n\tdev->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdev->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tdev->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ | VB2_DMABUF;\n\tdev->vidq.ops = &tw68_video_qops;\n\tdev->vidq.mem_ops = &vb2_dma_sg_memops;\n\tdev->vidq.drv_priv = dev;\n\tdev->vidq.gfp_flags = __GFP_DMA32 | __GFP_KSWAPD_RECLAIM;\n\tdev->vidq.buf_struct_size = sizeof(struct tw68_buf);\n\tdev->vidq.lock = &dev->lock;\n\tdev->vidq.min_buffers_needed = 2;\n\tdev->vidq.dev = &dev->pci->dev;\n\tret = vb2_queue_init(&dev->vidq);\n\tif (ret)\n\t\treturn ret;\n\tdev->vdev = tw68_video_template;\n\tdev->vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vdev.lock = &dev->lock;\n\tdev->vdev.queue = &dev->vidq;\n\tvideo_set_drvdata(&dev->vdev, dev);\n\treturn video_register_device(&dev->vdev, VFL_TYPE_VIDEO, video_nr);\n}\n\n \nvoid tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)\n{\n\t__u32 reg;\n\n\t \n\ttw_writel(TW68_INTSTAT, status);\n\t \n\tif (status & TW68_DMAPI) {\n\t\tstruct tw68_buf *buf;\n\n\t\tspin_lock(&dev->slock);\n\t\tbuf = list_entry(dev->active.next, struct tw68_buf, list);\n\t\tlist_del(&buf->list);\n\t\tspin_unlock(&dev->slock);\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tbuf->vb.field = dev->field;\n\t\tbuf->vb.sequence = dev->seqnr++;\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tstatus &= ~(TW68_DMAPI);\n\t\tif (0 == status)\n\t\t\treturn;\n\t}\n\tif (status & (TW68_VLOCK | TW68_HLOCK))\n\t\tdev_dbg(&dev->pci->dev, \"Lost sync\\n\");\n\tif (status & TW68_PABORT)\n\t\tdev_err(&dev->pci->dev, \"PABORT interrupt\\n\");\n\tif (status & TW68_DMAPERR)\n\t\tdev_err(&dev->pci->dev, \"DMAPERR interrupt\\n\");\n\t \n\tif (status & TW68_FDMIS)\n\t\tdev_dbg(&dev->pci->dev, \"FDMIS interrupt\\n\");\n\tif (status & TW68_FFOF) {\n\t\t \n\t\treg = tw_readl(TW68_DMAC) & TW68_FIFO_EN;\n\t\ttw_clearl(TW68_DMAC, TW68_FIFO_EN);\n\t\tdev_dbg(&dev->pci->dev, \"FFOF interrupt\\n\");\n\t\ttw_setl(TW68_DMAC, reg);\n\t}\n\tif (status & TW68_FFERR)\n\t\tdev_dbg(&dev->pci->dev, \"FFERR interrupt\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}