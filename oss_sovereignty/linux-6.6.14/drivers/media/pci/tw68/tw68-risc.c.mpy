{
  "module_name": "tw68-risc.c",
  "hash_id": "598de9fed32600a25d575b4de95f337da6f07edadfcde5378666f1870b250eac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw68/tw68-risc.c",
  "human_readable_source": "\n \n\n#include \"tw68.h\"\n\n \nstatic __le32 *tw68_risc_field(__le32 *rp, struct scatterlist *sglist,\n\t\t\t    unsigned int offset, u32 sync_line,\n\t\t\t    unsigned int bpl, unsigned int padding,\n\t\t\t    unsigned int lines, bool jump)\n{\n\tstruct scatterlist *sg;\n\tunsigned int line, todo, done;\n\n\tif (jump) {\n\t\t*(rp++) = cpu_to_le32(RISC_JUMP);\n\t\t*(rp++) = 0;\n\t}\n\n\t \n\tif (sync_line == 1)\n\t\t*(rp++) = cpu_to_le32(RISC_SYNCO);\n\telse\n\t\t*(rp++) = cpu_to_le32(RISC_SYNCE);\n\t*(rp++) = 0;\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < lines; line++) {\n\t\t \n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t\tif (bpl <= sg_dma_len(sg) - offset) {\n\t\t\t \n\t\t\t*(rp++) = cpu_to_le32(RISC_LINESTART |\n\t\t\t\t\t         bpl);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\toffset += bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\t \n\t\t\t \n\t\t\tdone = (sg_dma_len(sg) - offset);\n\t\t\t*(rp++) = cpu_to_le32(RISC_LINESTART |\n\t\t\t\t\t\t(7 << 24) |\n\t\t\t\t\t\tdone);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\ttodo -= done;\n\t\t\tsg = sg_next(sg);\n\t\t\t \n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++) = cpu_to_le32(RISC_INLINE |\n\t\t\t\t\t\t(done << 12) |\n\t\t\t\t\t\tsg_dma_len(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t\tdone += sg_dma_len(sg);\n\t\t\t}\n\t\t\tif (todo) {\n\t\t\t\t \n\t\t\t\t*(rp++) = cpu_to_le32(RISC_INLINE |\n\t\t\t\t\t\t\t(done << 12) |\n\t\t\t\t\t\t\ttodo);\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t}\n\t\t\toffset = todo;\n\t\t}\n\t\toffset += padding;\n\t}\n\n\treturn rp;\n}\n\n \nint tw68_risc_buffer(struct pci_dev *pci,\n\t\t\tstruct tw68_buf *buf,\n\t\t\tstruct scatterlist *sglist,\n\t\t\tunsigned int top_offset,\n\t\t\tunsigned int bottom_offset,\n\t\t\tunsigned int bpl,\n\t\t\tunsigned int padding,\n\t\t\tunsigned int lines)\n{\n\tu32 instructions, fields;\n\t__le32 *rp;\n\n\tfields = 0;\n\tif (UNSET != top_offset)\n\t\tfields++;\n\tif (UNSET != bottom_offset)\n\t\tfields++;\n\t \n\tinstructions  = fields * (1 + (((bpl + padding) * lines) /\n\t\t\t PAGE_SIZE) + lines) + 4;\n\tbuf->size = instructions * 8;\n\tbuf->cpu = dma_alloc_coherent(&pci->dev, buf->size, &buf->dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (buf->cpu == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\trp = buf->cpu;\n\tif (UNSET != top_offset)\t \n\t\trp = tw68_risc_field(rp, sglist, top_offset, 1,\n\t\t\t\t     bpl, padding, lines, true);\n\tif (UNSET != bottom_offset)\t \n\t\trp = tw68_risc_field(rp, sglist, bottom_offset, 2,\n\t\t\t\t     bpl, padding, lines, top_offset == UNSET);\n\n\t \n\tbuf->jmp = rp;\n\tbuf->cpu[1] = cpu_to_le32(buf->dma + 8);\n\t \n\tBUG_ON((buf->jmp - buf->cpu + 2) * sizeof(buf->cpu[0]) > buf->size);\n\treturn 0;\n}\n\n#if 0\n \n \n\nstatic void tw68_risc_decode(u32 risc, u32 addr)\n{\n#define\tRISC_OP(reg)\t(((reg) >> 28) & 7)\n\tstatic struct instr_details {\n\t\tchar *name;\n\t\tu8 has_data_type;\n\t\tu8 has_byte_info;\n\t\tu8 has_addr;\n\t} instr[8] = {\n\t\t[RISC_OP(RISC_SYNCO)]\t  = {\"syncOdd\", 0, 0, 0},\n\t\t[RISC_OP(RISC_SYNCE)]\t  = {\"syncEven\", 0, 0, 0},\n\t\t[RISC_OP(RISC_JUMP)]\t  = {\"jump\", 0, 0, 1},\n\t\t[RISC_OP(RISC_LINESTART)] = {\"lineStart\", 1, 1, 1},\n\t\t[RISC_OP(RISC_INLINE)]\t  = {\"inline\", 1, 1, 1},\n\t};\n\tu32 p;\n\n\tp = RISC_OP(risc);\n\tif (!(risc & 0x80000000) || !instr[p].name) {\n\t\tpr_debug(\"0x%08x [ INVALID ]\\n\", risc);\n\t\treturn;\n\t}\n\tpr_debug(\"0x%08x %-9s IRQ=%d\",\n\t\trisc, instr[p].name, (risc >> 27) & 1);\n\tif (instr[p].has_data_type)\n\t\tpr_debug(\" Type=%d\", (risc >> 24) & 7);\n\tif (instr[p].has_byte_info)\n\t\tpr_debug(\" Start=0x%03x Count=%03u\",\n\t\t\t(risc >> 12) & 0xfff, risc & 0xfff);\n\tif (instr[p].has_addr)\n\t\tpr_debug(\" StartAddr=0x%08x\", addr);\n\tpr_debug(\"\\n\");\n}\n\nvoid tw68_risc_program_dump(struct tw68_core *core, struct tw68_buf *buf)\n{\n\tconst __le32 *addr;\n\n\tpr_debug(\"%s: risc_program_dump: risc=%p, buf->cpu=0x%p, buf->jmp=0x%p\\n\",\n\t\t  core->name, buf, buf->cpu, buf->jmp);\n\tfor (addr = buf->cpu; addr <= buf->jmp; addr += 2)\n\t\ttw68_risc_decode(*addr, *(addr+1));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}