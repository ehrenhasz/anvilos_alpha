{
  "module_name": "tw68-core.c",
  "hash_id": "f50a1add6f0cf2c28d49450e3d2f414ab87ff0b7a9cc0f96251a31fc16df94c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw68/tw68-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/sound.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci_ids.h>\n#include <linux/pm.h>\n\n#include <media/v4l2-dev.h>\n#include \"tw68.h\"\n#include \"tw68-reg.h\"\n\nMODULE_DESCRIPTION(\"v4l2 driver module for tw6800 based video capture cards\");\nMODULE_AUTHOR(\"William M. Brack\");\nMODULE_AUTHOR(\"Hans Verkuil <hverkuil@xs4all.nl>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int latency = UNSET;\nmodule_param(latency, int, 0444);\nMODULE_PARM_DESC(latency, \"pci latency timer\");\n\nstatic unsigned int video_nr[] = {[0 ... (TW68_MAXBOARDS - 1)] = UNSET };\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr, \"video device number\");\n\nstatic unsigned int card[] = {[0 ... (TW68_MAXBOARDS - 1)] = UNSET };\nmodule_param_array(card, int, NULL, 0444);\nMODULE_PARM_DESC(card, \"card type\");\n\nstatic atomic_t tw68_instance = ATOMIC_INIT(0);\n\n \n\n \nstatic const struct pci_device_id tw68_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6800)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6801)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6804)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6816_1)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6816_2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6816_3)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_6816_4)},\n\t{0,}\n};\n\n \n\n\n \nstatic int tw68_hw_init1(struct tw68_dev *dev)\n{\n\t \n\ttw_writel(TW68_INTMASK, 0);\t\t \n\t \n\ttw_writel(TW68_INTSTAT, 0xffffffff);\t \n\t \n\ttw_writel(TW68_DMAC, 0x1600);\n\n\ttw_writeb(TW68_ACNTL, 0x80);\t \n\tmsleep(100);\n\n\ttw_writeb(TW68_INFORM, 0x40);\t \n\ttw_writeb(TW68_OPFORM, 0x04);\t \n\ttw_writeb(TW68_HSYNC, 0);\t \n\ttw_writeb(TW68_ACNTL, 0x42);\t \n\n\ttw_writeb(TW68_CROP_HI, 0x02);\t \n\ttw_writeb(TW68_VDELAY_LO, 0x12); \n\ttw_writeb(TW68_VACTIVE_LO, 0xf0);\n\ttw_writeb(TW68_HDELAY_LO, 0x0f);\n\ttw_writeb(TW68_HACTIVE_LO, 0xd0);\n\n\ttw_writeb(TW68_CNTRL1, 0xcd);\t \n\n\ttw_writeb(TW68_VSCALE_LO, 0);\t \n\ttw_writeb(TW68_SCALE_HI, 0x11);\t \n\ttw_writeb(TW68_HSCALE_LO, 0);\t \n\ttw_writeb(TW68_BRIGHT, 0);\t \n\ttw_writeb(TW68_CONTRAST, 0x5c);\t \n\ttw_writeb(TW68_SHARPNESS, 0x51); \n\ttw_writeb(TW68_SAT_U, 0x80);\t \n\ttw_writeb(TW68_SAT_V, 0x80);\t \n\ttw_writeb(TW68_HUE, 0x00);\t \n\n\t \n\ttw_writeb(TW68_SHARP2, 0x53);\t \n\ttw_writeb(TW68_VSHARP, 0x80);\t \n\ttw_writeb(TW68_CORING, 0x44);\t \n\ttw_writeb(TW68_CNTRL2, 0x00);\t \n\ttw_writeb(TW68_SDT, 0x07);\t \n\ttw_writeb(TW68_SDTR, 0x7f);\t \n\ttw_writeb(TW68_CLMPG, 0x50);\t \n\ttw_writeb(TW68_IAGC, 0x22);\t \n\ttw_writeb(TW68_AGCGAIN, 0xf0);\t \n\ttw_writeb(TW68_PEAKWT, 0xd8);\t \n\ttw_writeb(TW68_CLMPL, 0x3c);\t \n \t \n\ttw_writeb(TW68_SYNCT, 0x30);\t \n\ttw_writeb(TW68_MISSCNT, 0x44);\t \n\ttw_writeb(TW68_PCLAMP, 0x28);\t \n\t \n\ttw_writeb(TW68_VCNTL1, 0x04);\t \n\ttw_writeb(TW68_VCNTL2, 0);\t \n\ttw_writeb(TW68_CKILL, 0x68);\t \n\ttw_writeb(TW68_COMB, 0x44);\t \n\ttw_writeb(TW68_LDLY, 0x30);\t \n\ttw_writeb(TW68_MISC1, 0x14);\t \n\ttw_writeb(TW68_LOOP, 0xa5);\t \n\ttw_writeb(TW68_MISC2, 0xe0);\t \n\ttw_writeb(TW68_MVSN, 0);\t \n\ttw_writeb(TW68_CLMD, 0x05);\t \n\ttw_writeb(TW68_IDCNTL, 0);\t \n\ttw_writeb(TW68_CLCNTL1, 0);\t \n\ttw_writel(TW68_VBIC, 0x03);\t \n\ttw_writel(TW68_CAP_CTL, 0x03);\t \n\ttw_writel(TW68_DMAC, 0x2000);\t \n\ttw_writel(TW68_TESTREG, 0);\t \n\n\t \n\ttw_writel(TW68_GPIOC, 0);\t \n\ttw_writel(TW68_GPOE, 0x0f);\t \n\ttw_writel(TW68_GPDATA, 0);\t \n\n\t \n\tmutex_init(&dev->lock);\n\tspin_lock_init(&dev->slock);\n\n\t \n\ttw68_video_init1(dev);\n\treturn 0;\n}\n\nstatic irqreturn_t tw68_irq(int irq, void *dev_id)\n{\n\tstruct tw68_dev *dev = dev_id;\n\tu32 status, orig;\n\tint loop;\n\n\tstatus = orig = tw_readl(TW68_INTSTAT) & dev->pci_irqmask;\n\t \n\tif (0 == status)\n\t\treturn IRQ_NONE;\t \n\tfor (loop = 0; loop < 10; loop++) {\n\t\tif (status & dev->board_virqmask)\t \n\t\t\ttw68_irq_video_done(dev, status);\n\t\tstatus = tw_readl(TW68_INTSTAT) & dev->pci_irqmask;\n\t\tif (0 == status)\n\t\t\treturn IRQ_HANDLED;\n\t}\n\tdev_dbg(&dev->pci->dev, \"%s: **** INTERRUPT NOT HANDLED - clearing mask (orig 0x%08x, cur 0x%08x)\",\n\t\t\tdev->name, orig, tw_readl(TW68_INTSTAT));\n\tdev_dbg(&dev->pci->dev, \"%s: pci_irqmask 0x%08x; board_virqmask 0x%08x ****\\n\",\n\t\t\tdev->name, dev->pci_irqmask, dev->board_virqmask);\n\ttw_clearl(TW68_INTMASK, dev->pci_irqmask);\n\treturn IRQ_HANDLED;\n}\n\nstatic int tw68_initdev(struct pci_dev *pci_dev,\n\t\t\t\t     const struct pci_device_id *pci_id)\n{\n\tstruct tw68_dev *dev;\n\tint vidnr = -1;\n\tint err;\n\n\tdev = devm_kzalloc(&pci_dev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (NULL == dev)\n\t\treturn -ENOMEM;\n\n\tdev->instance = v4l2_device_set_name(&dev->v4l2_dev, \"tw68\",\n\t\t\t\t\t\t&tw68_instance);\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto fail1;\n\t}\n\n\tdev->name = dev->v4l2_dev.name;\n\n\tif (UNSET != latency) {\n\t\tpr_info(\"%s: setting pci latency timer to %d\\n\",\n\t\t       dev->name, latency);\n\t\tpci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\n\t}\n\n\t \n\tpci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tpr_info(\"%s: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tdev->name, pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t\tdev->pci_lat, (u64)pci_resource_start(pci_dev, 0));\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tpr_info(\"%s: Oops: no 32bit PCI DMA ???\\n\", dev->name);\n\t\tgoto fail1;\n\t}\n\n\tswitch (pci_id->device) {\n\tcase PCI_DEVICE_ID_TECHWELL_6800:\t \n\t\tdev->vdecoder = TW6800;\n\t\tdev->board_virqmask = TW68_VID_INTS;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TECHWELL_6801:\t \n\t\tdev->vdecoder = TW6801;\n\t\tdev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TECHWELL_6804:\t \n\t\tdev->vdecoder = TW6804;\n\t\tdev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\n\t\tbreak;\n\tdefault:\n\t\tdev->vdecoder = TWXXXX;\t \n\t\tdev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\n\t\tbreak;\n\t}\n\n\t \n\tif (!request_mem_region(pci_resource_start(pci_dev, 0),\n\t\t\t\tpci_resource_len(pci_dev, 0),\n\t\t\t\tdev->name)) {\n\t\terr = -EBUSY;\n\t\tpr_err(\"%s: can't get MMIO memory @ 0x%llx\\n\",\n\t\t\tdev->name,\n\t\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\t\tgoto fail1;\n\t}\n\tdev->lmmio = ioremap(pci_resource_start(pci_dev, 0),\n\t\t\t     pci_resource_len(pci_dev, 0));\n\tdev->bmmio = (__u8 __iomem *)dev->lmmio;\n\tif (NULL == dev->lmmio) {\n\t\terr = -EIO;\n\t\tpr_err(\"%s: can't ioremap() MMIO memory\\n\",\n\t\t       dev->name);\n\t\tgoto fail2;\n\t}\n\t \n\t \n\ttw68_hw_init1(dev);\n\n\t \n\terr = devm_request_irq(&pci_dev->dev, pci_dev->irq, tw68_irq,\n\t\t\t  IRQF_SHARED, dev->name, dev);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't get IRQ %d\\n\",\n\t\t       dev->name, pci_dev->irq);\n\t\tgoto fail3;\n\t}\n\n\t \n\tif (dev->instance < TW68_MAXBOARDS)\n\t\tvidnr = video_nr[dev->instance];\n\t \n\terr = tw68_video_init2(dev, vidnr);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't register video device\\n\",\n\t\t       dev->name);\n\t\tgoto fail4;\n\t}\n\ttw_setl(TW68_INTMASK, dev->pci_irqmask);\n\n\tpr_info(\"%s: registered device %s\\n\",\n\t       dev->name, video_device_node_name(&dev->vdev));\n\n\treturn 0;\n\nfail4:\n\tvideo_unregister_device(&dev->vdev);\nfail3:\n\tiounmap(dev->lmmio);\nfail2:\n\trelease_mem_region(pci_resource_start(pci_dev, 0),\n\t\t\t   pci_resource_len(pci_dev, 0));\nfail1:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\treturn err;\n}\n\nstatic void tw68_finidev(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct tw68_dev *dev =\n\t\tcontainer_of(v4l2_dev, struct tw68_dev, v4l2_dev);\n\n\t \n\ttw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\n\ttw_writel(TW68_INTMASK, 0);\n\n\t \n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\n\t \n\tiounmap(dev->lmmio);\n\trelease_mem_region(pci_resource_start(pci_dev, 0),\n\t\t\t   pci_resource_len(pci_dev, 0));\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n}\n\nstatic int __maybe_unused tw68_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev_d);\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct tw68_dev *dev = container_of(v4l2_dev,\n\t\t\t\tstruct tw68_dev, v4l2_dev);\n\n\ttw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\n\tdev->pci_irqmask &= ~TW68_VID_INTS;\n\ttw_writel(TW68_INTMASK, 0);\n\n\tsynchronize_irq(pci_dev->irq);\n\n\tvb2_discard_done(&dev->vidq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tw68_resume(struct device *dev_d)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev_d);\n\tstruct tw68_dev *dev = container_of(v4l2_dev,\n\t\t\t\t\t    struct tw68_dev, v4l2_dev);\n\tstruct tw68_buf *buf;\n\tunsigned long flags;\n\n\t \n\n\tmsleep(100);\n\n\ttw68_set_tvnorm_hw(dev);\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tbuf = container_of(dev->active.next, struct tw68_buf, list);\n\n\ttw68_video_start_dma(dev, buf);\n\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic SIMPLE_DEV_PM_OPS(tw68_pm_ops, tw68_suspend, tw68_resume);\n\nstatic struct pci_driver tw68_pci_driver = {\n\t.name\t   = \"tw68\",\n\t.id_table  = tw68_pci_tbl,\n\t.probe\t   = tw68_initdev,\n\t.remove\t   = tw68_finidev,\n\t.driver.pm = &tw68_pm_ops,\n};\n\nmodule_pci_driver(tw68_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}