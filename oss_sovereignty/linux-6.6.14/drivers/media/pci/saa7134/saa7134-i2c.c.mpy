{
  "module_name": "saa7134-i2c.c",
  "hash_id": "6e3ada26a383c04635dcba41ece8e4fa6cdb2bf990089b5500c4ab5926d1a988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-i2c.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n#include <media/v4l2-common.h>\n\n \n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug,\"enable debug messages [i2c]\");\n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan,\"scan i2c bus at insmod time\");\n\n#define i2c_dbg(level, fmt, arg...) do { \\\n\tif (i2c_debug == level) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"i2c: \" fmt), ## arg); \\\n\t} while (0)\n\n#define i2c_cont(level, fmt, arg...) do { \\\n\tif (i2c_debug == level) \\\n\t\tpr_cont(fmt, ## arg); \\\n\t} while (0)\n\n#define I2C_WAIT_DELAY  32\n#define I2C_WAIT_RETRY  16\n\n \n\nstatic char *str_i2c_status[] = {\n\t\"IDLE\", \"DONE_STOP\", \"BUSY\", \"TO_SCL\", \"TO_ARB\", \"DONE_WRITE\",\n\t\"DONE_READ\", \"DONE_WRITE_TO\", \"DONE_READ_TO\", \"NO_DEVICE\",\n\t\"NO_ACKN\", \"BUS_ERR\", \"ARB_LOST\", \"SEQ_ERR\", \"ST_ERR\", \"SW_ERR\"\n};\n\nenum i2c_status {\n\tIDLE          = 0,  \n\tDONE_STOP     = 1,  \n\tBUSY          = 2,  \n\tTO_SCL        = 3,  \n\tTO_ARB        = 4,  \n\tDONE_WRITE    = 5,  \n\tDONE_READ     = 6,  \n\tDONE_WRITE_TO = 7,  \n\tDONE_READ_TO  = 8,  \n\tNO_DEVICE     = 9,  \n\tNO_ACKN       = 10, \n\tBUS_ERR       = 11, \n\tARB_LOST      = 12, \n\tSEQ_ERR       = 13, \n\tST_ERR        = 14, \n\tSW_ERR        = 15  \n};\n\nstatic char *str_i2c_attr[] = {\n\t\"NOP\", \"STOP\", \"CONTINUE\", \"START\"\n};\n\nenum i2c_attr {\n\tNOP           = 0,  \n\tSTOP          = 1,  \n\tCONTINUE      = 2,  \n\tSTART         = 3   \n};\n\nstatic inline enum i2c_status i2c_get_status(struct saa7134_dev *dev)\n{\n\tenum i2c_status status;\n\n\tstatus = saa_readb(SAA7134_I2C_ATTR_STATUS) & 0x0f;\n\ti2c_dbg(2, \"i2c stat <= %s\\n\", str_i2c_status[status]);\n\treturn status;\n}\n\nstatic inline void i2c_set_status(struct saa7134_dev *dev,\n\t\t\t\t  enum i2c_status status)\n{\n\ti2c_dbg(2, \"i2c stat => %s\\n\", str_i2c_status[status]);\n\tsaa_andorb(SAA7134_I2C_ATTR_STATUS,0x0f,status);\n}\n\nstatic inline void i2c_set_attr(struct saa7134_dev *dev, enum i2c_attr attr)\n{\n\ti2c_dbg(2, \"i2c attr => %s\\n\", str_i2c_attr[attr]);\n\tsaa_andorb(SAA7134_I2C_ATTR_STATUS,0xc0,attr << 6);\n}\n\nstatic inline int i2c_is_error(enum i2c_status status)\n{\n\tswitch (status) {\n\tcase NO_DEVICE:\n\tcase NO_ACKN:\n\tcase BUS_ERR:\n\tcase ARB_LOST:\n\tcase SEQ_ERR:\n\tcase ST_ERR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int i2c_is_idle(enum i2c_status status)\n{\n\tswitch (status) {\n\tcase IDLE:\n\tcase DONE_STOP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int i2c_is_busy(enum i2c_status status)\n{\n\tswitch (status) {\n\tcase BUSY:\n\tcase TO_SCL:\n\tcase TO_ARB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int i2c_is_busy_wait(struct saa7134_dev *dev)\n{\n\tenum i2c_status status;\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tstatus = i2c_get_status(dev);\n\t\tif (!i2c_is_busy(status))\n\t\t\tbreak;\n\t\tsaa_wait(I2C_WAIT_DELAY);\n\t}\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int i2c_reset(struct saa7134_dev *dev)\n{\n\tenum i2c_status status;\n\tint count;\n\n\ti2c_dbg(2, \"i2c reset\\n\");\n\tstatus = i2c_get_status(dev);\n\tif (!i2c_is_error(status))\n\t\treturn true;\n\ti2c_set_status(dev,status);\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tstatus = i2c_get_status(dev);\n\t\tif (!i2c_is_error(status))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn false;\n\n\tif (!i2c_is_idle(status))\n\t\treturn false;\n\n\ti2c_set_attr(dev,NOP);\n\treturn true;\n}\n\nstatic inline int i2c_send_byte(struct saa7134_dev *dev,\n\t\t\t\tenum i2c_attr attr,\n\t\t\t\tunsigned char data)\n{\n\tenum i2c_status status;\n\t__u32 dword;\n\n\t \n\tdword  = saa_readl(SAA7134_I2C_ATTR_STATUS >> 2);\n\tdword &= 0x0f;\n\tdword |= (attr << 6);\n\tdword |= ((__u32)data << 8);\n\tdword |= 0x00 << 16;   \n\n\tdword |= 0xf0 << 24;\n\tsaa_writel(SAA7134_I2C_ATTR_STATUS >> 2, dword);\n\ti2c_dbg(2, \"i2c data => 0x%x\\n\", data);\n\n\tif (!i2c_is_busy_wait(dev))\n\t\treturn -EIO;\n\tstatus = i2c_get_status(dev);\n\tif (i2c_is_error(status))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic inline int i2c_recv_byte(struct saa7134_dev *dev)\n{\n\tenum i2c_status status;\n\tunsigned char data;\n\n\ti2c_set_attr(dev,CONTINUE);\n\tif (!i2c_is_busy_wait(dev))\n\t\treturn -EIO;\n\tstatus = i2c_get_status(dev);\n\tif (i2c_is_error(status))\n\t\treturn -EIO;\n\tdata = saa_readb(SAA7134_I2C_DATA);\n\ti2c_dbg(2, \"i2c data <= 0x%x\\n\", data);\n\treturn data;\n}\n\nstatic int saa7134_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct saa7134_dev *dev = i2c_adap->algo_data;\n\tenum i2c_status status;\n\tunsigned char data;\n\tint addr,rc,i,byte;\n\n\tstatus = i2c_get_status(dev);\n\tif (!i2c_is_idle(status))\n\t\tif (!i2c_reset(dev))\n\t\t\treturn -EIO;\n\n\ti2c_dbg(2, \"start xfer\\n\");\n\ti2c_dbg(1, \"i2c xfer:\");\n\tfor (i = 0; i < num; i++) {\n\t\tif (!(msgs[i].flags & I2C_M_NOSTART) || 0 == i) {\n\t\t\t \n\t\t\ti2c_dbg(2, \"send address\\n\");\n\t\t\taddr  = msgs[i].addr << 1;\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\taddr |= 1;\n\t\t\tif (i > 0 && msgs[i].flags &\n\t\t\t    I2C_M_RD && msgs[i].addr != 0x40 &&\n\t\t\t    msgs[i].addr != 0x41 &&\n\t\t\t    msgs[i].addr != 0x19) {\n\t\t\t\t \n\t\t\t\tint quirk = 0xfe;\n\t\t\t\ti2c_cont(1, \" [%02x quirk]\", quirk);\n\t\t\t\ti2c_send_byte(dev,START,quirk);\n\t\t\t\ti2c_recv_byte(dev);\n\t\t\t}\n\t\t\ti2c_cont(1, \" < %02x\", addr);\n\t\t\trc = i2c_send_byte(dev,START,addr);\n\t\t\tif (rc < 0)\n\t\t\t\t goto err;\n\t\t}\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\ti2c_dbg(2, \"read bytes\\n\");\n\t\t\tfor (byte = 0; byte < msgs[i].len; byte++) {\n\t\t\t\ti2c_cont(1, \" =\");\n\t\t\t\trc = i2c_recv_byte(dev);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto err;\n\t\t\t\ti2c_cont(1, \"%02x\", rc);\n\t\t\t\tmsgs[i].buf[byte] = rc;\n\t\t\t}\n\t\t\t \n\t\t\tif (0x19 == msgs[i].addr) {\n\t\t\t\ti2c_cont(1, \" ?\");\n\t\t\t\trc = i2c_recv_byte(dev);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto err;\n\t\t\t\ti2c_cont(1, \"%02x\", rc);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ti2c_dbg(2, \"write bytes\\n\");\n\t\t\tfor (byte = 0; byte < msgs[i].len; byte++) {\n\t\t\t\tdata = msgs[i].buf[byte];\n\t\t\t\ti2c_cont(1, \" %02x\", data);\n\t\t\t\trc = i2c_send_byte(dev,CONTINUE,data);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\ti2c_dbg(2, \"xfer done\\n\");\n\ti2c_cont(1, \" >\");\n\ti2c_set_attr(dev,STOP);\n\trc = -EIO;\n\tif (!i2c_is_busy_wait(dev))\n\t\tgoto err;\n\tstatus = i2c_get_status(dev);\n\tif (i2c_is_error(status))\n\t\tgoto err;\n\t \n\tmsleep(1);\n\n\ti2c_cont(1, \"\\n\");\n\treturn num;\n err:\n\tif (1 == i2c_debug) {\n\t\tstatus = i2c_get_status(dev);\n\t\ti2c_cont(1, \" ERROR: %s\\n\", str_i2c_status[status]);\n\t}\n\treturn rc;\n}\n\n \n\nstatic u32 functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm saa7134_algo = {\n\t.master_xfer   = saa7134_i2c_xfer,\n\t.functionality = functionality,\n};\n\nstatic const struct i2c_adapter saa7134_adap_template = {\n\t.owner         = THIS_MODULE,\n\t.name          = \"saa7134\",\n\t.algo          = &saa7134_algo,\n};\n\nstatic const struct i2c_client saa7134_client_template = {\n\t.name\t= \"saa7134 internal\",\n};\n\n \n\n \nstatic void saa7134_i2c_eeprom_md7134_gate(struct saa7134_dev *dev)\n{\n\tu8 subaddr = 0x7, dmdregval;\n\tu8 data[2];\n\tint ret;\n\tstruct i2c_msg i2cgatemsg_r[] = { {.addr = 0x08, .flags = 0,\n\t\t\t\t\t   .buf = &subaddr, .len = 1},\n\t\t\t\t\t  {.addr = 0x08,\n\t\t\t\t\t   .flags = I2C_M_RD,\n\t\t\t\t\t   .buf = &dmdregval, .len = 1}\n\t\t\t\t\t};\n\tstruct i2c_msg i2cgatemsg_w[] = { {.addr = 0x08, .flags = 0,\n\t\t\t\t\t   .buf = data, .len = 2} };\n\n\tret = i2c_transfer(&dev->i2c_adap, i2cgatemsg_r, 2);\n\tif ((ret == 2) && (dmdregval & 0x2)) {\n\t\tpr_debug(\"%s: DVB-T demod i2c gate was left open\\n\",\n\t\t\t dev->name);\n\n\t\tdata[0] = subaddr;\n\t\tdata[1] = (dmdregval & ~0x2);\n\t\tif (i2c_transfer(&dev->i2c_adap, i2cgatemsg_w, 1) != 1)\n\t\t\tpr_err(\"%s: EEPROM i2c gate close failure\\n\",\n\t\t\t       dev->name);\n\t}\n}\n\nstatic int\nsaa7134_i2c_eeprom(struct saa7134_dev *dev, unsigned char *eedata, int len)\n{\n\tunsigned char buf;\n\tint i,err;\n\n\tif (dev->board == SAA7134_BOARD_MD7134)\n\t\tsaa7134_i2c_eeprom_md7134_gate(dev);\n\n\tdev->i2c_client.addr = 0xa0 >> 1;\n\tbuf = 0;\n\tif (1 != (err = i2c_master_send(&dev->i2c_client,&buf,1))) {\n\t\tpr_info(\"%s: Huh, no eeprom present (err=%d)?\\n\",\n\t\t       dev->name,err);\n\t\treturn -1;\n\t}\n\tif (len != (err = i2c_master_recv(&dev->i2c_client,eedata,len))) {\n\t\tpr_warn(\"%s: i2c eeprom read error (err=%d)\\n\",\n\t\t       dev->name,err);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tint size = (len - i) > 16 ? 16 : len - i;\n\n\t\tpr_info(\"i2c eeprom %02x: %*ph\\n\", i, size, &eedata[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic char *i2c_devs[128] = {\n\t[ 0x20      ] = \"mpeg encoder (saa6752hs)\",\n\t[ 0xa0 >> 1 ] = \"eeprom\",\n\t[ 0xc0 >> 1 ] = \"tuner (analog)\",\n\t[ 0x86 >> 1 ] = \"tda9887\",\n\t[ 0x5a >> 1 ] = \"remote control\",\n};\n\nstatic void do_i2c_scan(struct i2c_client *c)\n{\n\tunsigned char buf;\n\tint i,rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\n\t\tc->addr = i;\n\t\trc = i2c_master_recv(c,&buf,0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tpr_info(\"i2c scan: found device @ 0x%x  [%s]\\n\",\n\t\t\t i << 1, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n}\n\nint saa7134_i2c_register(struct saa7134_dev *dev)\n{\n\tdev->i2c_adap = saa7134_adap_template;\n\tdev->i2c_adap.dev.parent = &dev->pci->dev;\n\tstrscpy(dev->i2c_adap.name, dev->name, sizeof(dev->i2c_adap.name));\n\tdev->i2c_adap.algo_data = dev;\n\ti2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\n\ti2c_add_adapter(&dev->i2c_adap);\n\n\tdev->i2c_client = saa7134_client_template;\n\tdev->i2c_client.adapter = &dev->i2c_adap;\n\n\tsaa7134_i2c_eeprom(dev,dev->eedata,sizeof(dev->eedata));\n\tif (i2c_scan)\n\t\tdo_i2c_scan(&dev->i2c_client);\n\n\t \n\tsaa7134_probe_i2c_ir(dev);\n\treturn 0;\n}\n\nint saa7134_i2c_unregister(struct saa7134_dev *dev)\n{\n\ti2c_del_adapter(&dev->i2c_adap);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}