{
  "module_name": "saa7134-vbi.c",
  "hash_id": "1af773b8dca36686e08f2d677eed45bf429f2182b86f1867fd72e93d460a655d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-vbi.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n \n\nstatic unsigned int vbi_debug;\nmodule_param(vbi_debug, int, 0644);\nMODULE_PARM_DESC(vbi_debug,\"enable debug messages [vbi]\");\n\nstatic unsigned int vbibufs = 4;\nmodule_param(vbibufs, int, 0444);\nMODULE_PARM_DESC(vbibufs,\"number of vbi buffers, range 2-32\");\n\n#define vbi_dbg(fmt, arg...) do { \\\n\tif (vbi_debug) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"vbi: \" fmt), ## arg); \\\n\t} while (0)\n\n \n\n#define VBI_LINE_COUNT     17\n#define VBI_LINE_LENGTH  2048\n#define VBI_SCALE       0x200\n\nstatic void task_init(struct saa7134_dev *dev, struct saa7134_buf *buf,\n\t\t      int task)\n{\n\tstruct saa7134_tvnorm *norm = dev->tvnorm;\n\n\t \n\tsaa_writeb(SAA7134_VBI_H_START1(task), norm->h_start     &  0xff);\n\tsaa_writeb(SAA7134_VBI_H_START2(task), norm->h_start     >> 8);\n\tsaa_writeb(SAA7134_VBI_H_STOP1(task),  norm->h_stop      &  0xff);\n\tsaa_writeb(SAA7134_VBI_H_STOP2(task),  norm->h_stop      >> 8);\n\tsaa_writeb(SAA7134_VBI_V_START1(task), norm->vbi_v_start_0 &  0xff);\n\tsaa_writeb(SAA7134_VBI_V_START2(task), norm->vbi_v_start_0 >> 8);\n\tsaa_writeb(SAA7134_VBI_V_STOP1(task),  norm->vbi_v_stop_0  &  0xff);\n\tsaa_writeb(SAA7134_VBI_V_STOP2(task),  norm->vbi_v_stop_0  >> 8);\n\n\tsaa_writeb(SAA7134_VBI_H_SCALE_INC1(task),        VBI_SCALE & 0xff);\n\tsaa_writeb(SAA7134_VBI_H_SCALE_INC2(task),        VBI_SCALE >> 8);\n\tsaa_writeb(SAA7134_VBI_PHASE_OFFSET_LUMA(task),   0x00);\n\tsaa_writeb(SAA7134_VBI_PHASE_OFFSET_CHROMA(task), 0x00);\n\n\tsaa_writeb(SAA7134_VBI_H_LEN1(task), dev->vbi_hlen & 0xff);\n\tsaa_writeb(SAA7134_VBI_H_LEN2(task), dev->vbi_hlen >> 8);\n\tsaa_writeb(SAA7134_VBI_V_LEN1(task), dev->vbi_vlen & 0xff);\n\tsaa_writeb(SAA7134_VBI_V_LEN2(task), dev->vbi_vlen >> 8);\n\n\tsaa_andorb(SAA7134_DATA_PATH(task), 0xc0, 0x00);\n}\n\n \n\nstatic int buffer_activate(struct saa7134_dev *dev,\n\t\t\t   struct saa7134_buf *buf,\n\t\t\t   struct saa7134_buf *next)\n{\n\tstruct saa7134_dmaqueue *dmaq = buf->vb2.vb2_buf.vb2_queue->drv_priv;\n\tunsigned long control, base;\n\n\tvbi_dbg(\"buffer_activate [%p]\\n\", buf);\n\tbuf->top_seen = 0;\n\n\ttask_init(dev, buf, TASK_A);\n\ttask_init(dev, buf, TASK_B);\n\tsaa_writeb(SAA7134_OFMT_DATA_A, 0x06);\n\tsaa_writeb(SAA7134_OFMT_DATA_B, 0x06);\n\n\t \n\tbase    = saa7134_buffer_base(buf);\n\tcontrol = SAA7134_RS_CONTROL_BURST_16 |\n\t\tSAA7134_RS_CONTROL_ME |\n\t\t(dmaq->pt.dma >> 12);\n\tsaa_writel(SAA7134_RS_BA1(2), base);\n\tsaa_writel(SAA7134_RS_BA2(2), base + dev->vbi_hlen * dev->vbi_vlen);\n\tsaa_writel(SAA7134_RS_PITCH(2), dev->vbi_hlen);\n\tsaa_writel(SAA7134_RS_CONTROL(2), control);\n\tsaa_writel(SAA7134_RS_BA1(3), base);\n\tsaa_writel(SAA7134_RS_BA2(3), base + dev->vbi_hlen * dev->vbi_vlen);\n\tsaa_writel(SAA7134_RS_PITCH(3), dev->vbi_hlen);\n\tsaa_writel(SAA7134_RS_CONTROL(3), control);\n\n\t \n\tsaa7134_set_dmabits(dev);\n\tmod_timer(&dmaq->timeout, jiffies + BUFFER_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb2)\n{\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\tstruct sg_table *dma = vb2_dma_sg_plane_desc(vb2, 0);\n\tunsigned int size;\n\n\tif (dma->sgl->offset) {\n\t\tpr_err(\"The buffer is not page-aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsize = dev->vbi_hlen * dev->vbi_vlen * 2;\n\tif (vb2_plane_size(vb2, 0) < size)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb2, 0, size);\n\n\treturn saa7134_pgtable_build(dev->pci, &dmaq->pt, dma->sgl, dma->nents,\n\t\t\t\t    saa7134_buffer_startpage(buf));\n}\n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct saa7134_dmaqueue *dmaq = q->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tunsigned int size;\n\n\tdev->vbi_vlen = dev->tvnorm->vbi_v_stop_0 - dev->tvnorm->vbi_v_start_0 + 1;\n\tif (dev->vbi_vlen > VBI_LINE_COUNT)\n\t\tdev->vbi_vlen = VBI_LINE_COUNT;\n\tdev->vbi_hlen = VBI_LINE_LENGTH;\n\tsize = dev->vbi_hlen * dev->vbi_vlen * 2;\n\n\t*nbuffers = saa7134_buffer_count(size, *nbuffers);\n\t*nplanes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int buffer_init(struct vb2_buffer *vb2)\n{\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\n\tdmaq->curr = NULL;\n\tbuf->activate = buffer_activate;\n\treturn 0;\n}\n\nconst struct vb2_ops saa7134_vbi_qops = {\n\t.queue_setup\t= queue_setup,\n\t.buf_init\t= buffer_init,\n\t.buf_prepare\t= buffer_prepare,\n\t.buf_queue\t= saa7134_vb2_buffer_queue,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.start_streaming = saa7134_vb2_start_streaming,\n\t.stop_streaming = saa7134_vb2_stop_streaming,\n};\n\n \n\nint saa7134_vbi_init1(struct saa7134_dev *dev)\n{\n\tINIT_LIST_HEAD(&dev->vbi_q.queue);\n\ttimer_setup(&dev->vbi_q.timeout, saa7134_buffer_timeout, 0);\n\tdev->vbi_q.dev              = dev;\n\n\tif (vbibufs < 2)\n\t\tvbibufs = 2;\n\tif (vbibufs > VIDEO_MAX_FRAME)\n\t\tvbibufs = VIDEO_MAX_FRAME;\n\treturn 0;\n}\n\nint saa7134_vbi_fini(struct saa7134_dev *dev)\n{\n\t \n\tdel_timer_sync(&dev->vbi_q.timeout);\n\treturn 0;\n}\n\nvoid saa7134_irq_vbi_done(struct saa7134_dev *dev, unsigned long status)\n{\n\tspin_lock(&dev->slock);\n\tif (dev->vbi_q.curr) {\n\t\t \n\t\tif ((status & 0x10) == 0x00) {\n\t\t\tdev->vbi_q.curr->top_seen = 1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (!dev->vbi_q.curr->top_seen)\n\t\t\tgoto done;\n\n\t\tsaa7134_buffer_finish(dev, &dev->vbi_q, VB2_BUF_STATE_DONE);\n\t}\n\tsaa7134_buffer_next(dev, &dev->vbi_q);\n\n done:\n\tspin_unlock(&dev->slock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}