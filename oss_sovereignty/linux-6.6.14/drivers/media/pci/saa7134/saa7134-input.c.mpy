{
  "module_name": "saa7134-input.c",
  "hash_id": "455f242d55a64dc360598f7d6b8a6bf5b0aecfe9eb6cd32b48468689a62469de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-input.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#define MODULE_NAME \"saa7134\"\n\nstatic unsigned int disable_ir;\nmodule_param(disable_ir, int, 0444);\nMODULE_PARM_DESC(disable_ir,\"disable infrared remote support\");\n\nstatic unsigned int ir_debug;\nmodule_param(ir_debug, int, 0644);\nMODULE_PARM_DESC(ir_debug,\"enable debug messages [IR]\");\n\nstatic int pinnacle_remote;\nmodule_param(pinnacle_remote, int, 0644);     \nMODULE_PARM_DESC(pinnacle_remote, \"Specify Pinnacle PCTV remote: 0=coloured, 1=grey (defaults to 0)\");\n\n#define input_dbg(fmt, arg...) do { \\\n\tif (ir_debug) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"input: \" fmt), ## arg); \\\n\t} while (0)\n#define ir_dbg(ir, fmt, arg...) do { \\\n\tif (ir_debug) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"ir %s: \" fmt), ir->rc->device_name, \\\n\t\t       ## arg); \\\n\t} while (0)\n\n \nstatic int saa7134_raw_decode_irq(struct saa7134_dev *dev);\n\n \n\nstatic int build_key(struct saa7134_dev *dev)\n{\n\tstruct saa7134_card_ir *ir = dev->remote;\n\tu32 gpio, data;\n\n\t \n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_GOTVIEW_7135:\n\t\tsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x80);\n\t\tsaa_clearb(SAA7134_GPIO_GPSTATUS1, 0x80);\n\t\tbreak;\n\t}\n\t \n\tsaa_clearb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN);\n\n\tgpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\n\tif (ir->polling) {\n\t\tif (ir->last_gpio == gpio)\n\t\t\treturn 0;\n\t\tir->last_gpio = gpio;\n\t}\n\n\tdata = ir_extract_bits(gpio, ir->mask_keycode);\n\tinput_dbg(\"build_key gpio=0x%x mask=0x%x data=%d\\n\",\n\t\tgpio, ir->mask_keycode, data);\n\n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_KWORLD_PLUS_TV_ANALOG:\n\t\tif (data == ir->mask_keycode)\n\t\t\trc_keyup(ir->dev);\n\t\telse\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t\treturn 0;\n\t}\n\n\tif (ir->polling) {\n\t\tif ((ir->mask_keydown  &&  (0 != (gpio & ir->mask_keydown))) ||\n\t\t    (ir->mask_keyup    &&  (0 == (gpio & ir->mask_keyup)))) {\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t\t} else {\n\t\t\trc_keyup(ir->dev);\n\t\t}\n\t}\n\telse {\t \n\t\tif ((ir->mask_keydown  &&  (0 != (gpio & ir->mask_keydown))) ||\n\t\t    (ir->mask_keyup    &&  (0 == (gpio & ir->mask_keyup)))) {\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t\t\trc_keyup(ir->dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int get_key_flydvb_trio(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t       u32 *scancode, u8 *toggle)\n{\n\tint gpio, rc;\n\tint attempt = 0;\n\tunsigned char b;\n\n\t \n\tstruct saa7134_dev *dev = ir->c->adapter->algo_data;\n\n\tif (dev == NULL) {\n\t\tir_dbg(ir, \"get_key_flydvb_trio: ir->c->adapter->algo_data is NULL!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\n\tgpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\n\n\tif (0x40000 & ~gpio)\n\t\treturn 0;  \n\n\t \n\t \n\tb = 0;\n\n\twhile (1 != i2c_master_send(ir->c, &b, 1)) {\n\t\tif ((attempt++) < 10) {\n\t\t\t \n\t\t\tmsleep(10);\n\t\t\tcontinue;\n\t\t}\n\t\tir_dbg(ir, \"send wake up byte to pic16C505 (IR chip)failed %dx\\n\",\n\t\t       attempt);\n\t\treturn -EIO;\n\t}\n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_msi_tvanywhere_plus(struct IR_i2c *ir,\n\t\t\t\t       enum rc_proto *protocol,\n\t\t\t\t       u32 *scancode, u8 *toggle)\n{\n\tunsigned char b;\n\tint gpio, rc;\n\n\t \n\tstruct saa7134_dev *dev = ir->c->adapter->algo_data;\n\tif (dev == NULL) {\n\t\tir_dbg(ir, \"get_key_msi_tvanywhere_plus: ir->c->adapter->algo_data is NULL!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\n\tgpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\n\n\t \n\n\tif (gpio & 0x40)\n\t\treturn 0;        \n\n\t \n\n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tif (b == 0xff)\n\t\treturn 0;\n\n\t \n\n\tinput_dbg(\"get_key_msi_tvanywhere_plus: Key = 0x%02X\\n\", b);\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\n \nstatic int get_key_kworld_pc150u(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t\t u32 *scancode, u8 *toggle)\n{\n\tunsigned char b;\n\tunsigned int gpio;\n\tint rc;\n\n\t \n\tstruct saa7134_dev *dev = ir->c->adapter->algo_data;\n\tif (dev == NULL) {\n\t\tir_dbg(ir, \"get_key_kworld_pc150u: ir->c->adapter->algo_data is NULL!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\n\tgpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\n\n\t \n\n\tif (gpio & 0x100)\n\t\treturn 0;        \n\n\t \n\n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tif (b == 0xff)\n\t\treturn 0;\n\n\t \n\n\tinput_dbg(\"get_key_kworld_pc150u: Key = 0x%02X\\n\", b);\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_purpletv(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t    u32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char b;\n\n\t \n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (b==0)\n\t\treturn 0;\n\n\t \n\tif (b & 0x80)\n\t\treturn 1;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_beholdm6xx(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t      u32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char data[12];\n\tu32 gpio;\n\n\tstruct saa7134_dev *dev = ir->c->adapter->algo_data;\n\n\t \n\tsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\n\tgpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\n\n\tif (0x400000 & ~gpio)\n\t\treturn 0;  \n\n\tir->c->addr = 0x5a >> 1;\n\n\trc = i2c_master_recv(ir->c, data, 12);\n\tif (rc != 12) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\tif (data[9] != (unsigned char)(~data[8]))\n\t\treturn 0;\n\n\t*protocol = RC_PROTO_NECX;\n\t*scancode = RC_SCANCODE_NECX(data[11] << 8 | data[10], data[9]);\n\t*toggle = 0;\n\treturn 1;\n}\n\n \nstatic int get_key_pinnacle(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t    u32 *scancode, u8 *toggle, int parity_offset,\n\t\t\t    int marker, int code_modulo)\n{\n\tint rc;\n\tunsigned char b[4];\n\tunsigned int start = 0,parity = 0,code = 0;\n\n\t \n\trc = i2c_master_recv(ir->c, b, 4);\n\tif (rc != 4) {\n\t\tir_dbg(ir, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\tfor (start = 0; start < ARRAY_SIZE(b); start++) {\n\t\tif (b[start] == marker) {\n\t\t\tcode=b[(start+parity_offset + 1) % 4];\n\t\t\tparity=b[(start+parity_offset) % 4];\n\t\t}\n\t}\n\n\t \n\tif (parity == 0)\n\t\treturn 0;\n\n\t \n\tif (ir->old == parity)\n\t\treturn 0;\n\n\tir->old = parity;\n\n\t \n\tif (marker == 0xfe && (code & 0x40))\n\t\treturn 0;\n\n\tcode %= code_modulo;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = code;\n\t*toggle = 0;\n\n\tir_dbg(ir, \"Pinnacle PCTV key %02x\\n\", code);\n\treturn 1;\n}\n\n \nstatic int get_key_pinnacle_grey(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t\t u32 *scancode, u8 *toggle)\n{\n\n\treturn get_key_pinnacle(ir, protocol, scancode, toggle, 1, 0xfe, 0xff);\n}\n\n\n \nstatic int get_key_pinnacle_color(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t\t  u32 *scancode, u8 *toggle)\n{\n\t \n\n\treturn get_key_pinnacle(ir, protocol, scancode, toggle, 2, 0x80, 0x88);\n}\n\nvoid saa7134_input_irq(struct saa7134_dev *dev)\n{\n\tstruct saa7134_card_ir *ir;\n\n\tif (!dev || !dev->remote)\n\t\treturn;\n\n\tir = dev->remote;\n\tif (!ir->running)\n\t\treturn;\n\n\tif (!ir->polling && !ir->raw_decode) {\n\t\tbuild_key(dev);\n\t} else if (ir->raw_decode) {\n\t\tsaa7134_raw_decode_irq(dev);\n\t}\n}\n\nstatic void saa7134_input_timer(struct timer_list *t)\n{\n\tstruct saa7134_card_ir *ir = from_timer(ir, t, timer);\n\tstruct saa7134_dev *dev = ir->dev->priv;\n\n\tbuild_key(dev);\n\tmod_timer(&ir->timer, jiffies + msecs_to_jiffies(ir->polling));\n}\n\nint saa7134_ir_open(struct rc_dev *rc)\n{\n\tstruct saa7134_dev *dev = rc->priv;\n\tstruct saa7134_card_ir *ir = dev->remote;\n\n\t \n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_MD2819:\n\tcase SAA7134_BOARD_KWORLD_VSTREAM_XPERT:\n\tcase SAA7134_BOARD_AVERMEDIA_305:\n\tcase SAA7134_BOARD_AVERMEDIA_307:\n\tcase SAA7134_BOARD_AVERMEDIA_505:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_305:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_505:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_307:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_507:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_507UA:\n\tcase SAA7134_BOARD_AVERMEDIA_GO_007_FM:\n\tcase SAA7134_BOARD_AVERMEDIA_M102:\n\tcase SAA7134_BOARD_AVERMEDIA_GO_007_FM_PLUS:\n\t\t \n\t\tsaa_setb(SAA7134_GPIO_GPMODE0, 0x4);\n\t\tsaa_setb(SAA7134_GPIO_GPSTATUS0, 0x4);\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_777:\n\tcase SAA7134_BOARD_AVERMEDIA_A16AR:\n\t\t \n\t\tsaa_setb(SAA7134_GPIO_GPMODE1, 0x1);\n\t\tsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x1);\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_A16D:\n\t\t \n\t\tsaa_setb(SAA7134_GPIO_GPMODE1, 0x1);\n\t\tsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x1);\n\t\tbreak;\n\tcase SAA7134_BOARD_GOTVIEW_7135:\n\t\tsaa_setb(SAA7134_GPIO_GPMODE1, 0x80);\n\t\tbreak;\n\t}\n\n\tir->running = true;\n\n\tif (ir->polling) {\n\t\ttimer_setup(&ir->timer, saa7134_input_timer, 0);\n\t\tir->timer.expires = jiffies + HZ;\n\t\tadd_timer(&ir->timer);\n\t}\n\n\treturn 0;\n}\n\nvoid saa7134_ir_close(struct rc_dev *rc)\n{\n\tstruct saa7134_dev *dev = rc->priv;\n\tstruct saa7134_card_ir *ir = dev->remote;\n\n\tif (ir->polling)\n\t\tdel_timer_sync(&ir->timer);\n\n\tir->running = false;\n}\n\nint saa7134_input_init1(struct saa7134_dev *dev)\n{\n\tstruct saa7134_card_ir *ir;\n\tstruct rc_dev *rc;\n\tchar *ir_codes = NULL;\n\tu32 mask_keycode = 0;\n\tu32 mask_keydown = 0;\n\tu32 mask_keyup   = 0;\n\tunsigned polling = 0;\n\tbool raw_decode  = false;\n\tint err;\n\n\tif (dev->has_remote != SAA7134_REMOTE_GPIO)\n\t\treturn -ENODEV;\n\tif (disable_ir)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_FLYVIDEO2000:\n\tcase SAA7134_BOARD_FLYVIDEO3000:\n\tcase SAA7134_BOARD_FLYTVPLATINUM_FM:\n\tcase SAA7134_BOARD_FLYTVPLATINUM_MINI2:\n\tcase SAA7134_BOARD_ROVERMEDIA_LINK_PRO_FM:\n\t\tir_codes     = RC_MAP_FLYVIDEO;\n\t\tmask_keycode = 0xEC00000;\n\t\tmask_keydown = 0x0040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_CINERGY400:\n\tcase SAA7134_BOARD_CINERGY600:\n\tcase SAA7134_BOARD_CINERGY600_MK3:\n\t\tir_codes     = RC_MAP_CINERGY;\n\t\tmask_keycode = 0x00003f;\n\t\tmask_keyup   = 0x040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_ECS_TVP3XP:\n\tcase SAA7134_BOARD_ECS_TVP3XP_4CB5:\n\t\tir_codes     = RC_MAP_EZTV;\n\t\tmask_keycode = 0x00017c;\n\t\tmask_keyup   = 0x000002;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_KWORLD_XPERT:\n\tcase SAA7134_BOARD_AVACSSMARTTV:\n\t\tir_codes     = RC_MAP_PIXELVIEW;\n\t\tmask_keycode = 0x00001F;\n\t\tmask_keyup   = 0x000020;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_MD2819:\n\tcase SAA7134_BOARD_KWORLD_VSTREAM_XPERT:\n\tcase SAA7134_BOARD_AVERMEDIA_305:\n\tcase SAA7134_BOARD_AVERMEDIA_307:\n\tcase SAA7134_BOARD_AVERMEDIA_505:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_305:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_505:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_307:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_507:\n\tcase SAA7134_BOARD_AVERMEDIA_STUDIO_507UA:\n\tcase SAA7134_BOARD_AVERMEDIA_GO_007_FM:\n\tcase SAA7134_BOARD_AVERMEDIA_M102:\n\tcase SAA7134_BOARD_AVERMEDIA_GO_007_FM_PLUS:\n\t\tir_codes     = RC_MAP_AVERMEDIA;\n\t\tmask_keycode = 0x0007C8;\n\t\tmask_keydown = 0x000010;\n\t\tpolling      = 50; \n\t\t \n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_M135A:\n\t\tir_codes     = RC_MAP_AVERMEDIA_M135A;\n\t\tmask_keydown = 0x0040000;\t \n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_M733A:\n\t\tir_codes     = RC_MAP_AVERMEDIA_M733A_RM_K6;\n\t\tmask_keydown = 0x0040000;\n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_777:\n\tcase SAA7134_BOARD_AVERMEDIA_A16AR:\n\t\tir_codes     = RC_MAP_AVERMEDIA;\n\t\tmask_keycode = 0x02F200;\n\t\tmask_keydown = 0x000400;\n\t\tpolling      = 50; \n\t\t \n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_A16D:\n\t\tir_codes     = RC_MAP_AVERMEDIA_A16D;\n\t\tmask_keycode = 0x02F200;\n\t\tmask_keydown = 0x000400;\n\t\tpolling      = 50;  \n\t\t \n\t\tbreak;\n\tcase SAA7134_BOARD_KWORLD_TERMINATOR:\n\t\tir_codes     = RC_MAP_PIXELVIEW;\n\t\tmask_keycode = 0x00001f;\n\t\tmask_keyup   = 0x000060;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_MANLI_MTV001:\n\tcase SAA7134_BOARD_MANLI_MTV002:\n\t\tir_codes     = RC_MAP_MANLI;\n\t\tmask_keycode = 0x001f00;\n\t\tmask_keyup   = 0x004000;\n\t\tpolling      = 50;  \n\t\tbreak;\n\tcase SAA7134_BOARD_BEHOLD_409FM:\n\tcase SAA7134_BOARD_BEHOLD_401:\n\tcase SAA7134_BOARD_BEHOLD_403:\n\tcase SAA7134_BOARD_BEHOLD_403FM:\n\tcase SAA7134_BOARD_BEHOLD_405:\n\tcase SAA7134_BOARD_BEHOLD_405FM:\n\tcase SAA7134_BOARD_BEHOLD_407:\n\tcase SAA7134_BOARD_BEHOLD_407FM:\n\tcase SAA7134_BOARD_BEHOLD_409:\n\tcase SAA7134_BOARD_BEHOLD_505FM:\n\tcase SAA7134_BOARD_BEHOLD_505RDS_MK5:\n\tcase SAA7134_BOARD_BEHOLD_505RDS_MK3:\n\tcase SAA7134_BOARD_BEHOLD_507_9FM:\n\tcase SAA7134_BOARD_BEHOLD_507RDS_MK3:\n\tcase SAA7134_BOARD_BEHOLD_507RDS_MK5:\n\t\tir_codes     = RC_MAP_MANLI;\n\t\tmask_keycode = 0x003f00;\n\t\tmask_keyup   = 0x004000;\n\t\tpolling      = 50;  \n\t\tbreak;\n\tcase SAA7134_BOARD_BEHOLD_COLUMBUS_TVFM:\n\t\tir_codes     = RC_MAP_BEHOLD_COLUMBUS;\n\t\tmask_keycode = 0x003f00;\n\t\tmask_keyup   = 0x004000;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_SEDNA_PC_TV_CARDBUS:\n\t\tir_codes     = RC_MAP_PCTV_SEDNA;\n\t\tmask_keycode = 0x001f00;\n\t\tmask_keyup   = 0x004000;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_GOTVIEW_7135:\n\t\tir_codes     = RC_MAP_GOTVIEW7135;\n\t\tmask_keycode = 0x0003CC;\n\t\tmask_keydown = 0x000010;\n\t\tpolling\t     = 5;  \n\t\t \n\t\tbreak;\n\tcase SAA7134_BOARD_VIDEOMATE_TV_PVR:\n\tcase SAA7134_BOARD_VIDEOMATE_GOLD_PLUS:\n\tcase SAA7134_BOARD_VIDEOMATE_TV_GOLD_PLUSII:\n\t\tir_codes     = RC_MAP_VIDEOMATE_TV_PVR;\n\t\tmask_keycode = 0x00003F;\n\t\tmask_keyup   = 0x400000;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_PROTEUS_2309:\n\t\tir_codes     = RC_MAP_PROTEUS_2309;\n\t\tmask_keycode = 0x00007F;\n\t\tmask_keyup   = 0x000080;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_VIDEOMATE_DVBT_300:\n\tcase SAA7134_BOARD_VIDEOMATE_DVBT_200:\n\t\tir_codes     = RC_MAP_VIDEOMATE_TV_PVR;\n\t\tmask_keycode = 0x003F00;\n\t\tmask_keyup   = 0x040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_FLYDVBS_LR300:\n\tcase SAA7134_BOARD_FLYDVBT_LR301:\n\tcase SAA7134_BOARD_FLYDVBTDUO:\n\t\tir_codes     = RC_MAP_FLYDVB;\n\t\tmask_keycode = 0x0001F00;\n\t\tmask_keydown = 0x0040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_ASUSTeK_P7131_DUAL:\n\tcase SAA7134_BOARD_ASUSTeK_P7131_HYBRID_LNA:\n\tcase SAA7134_BOARD_ASUSTeK_P7131_ANALOG:\n\t\tir_codes     = RC_MAP_ASUS_PC39;\n\t\tmask_keydown = 0x0040000;\t \n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_ASUSTeK_PS3_100:\n\t\tir_codes     = RC_MAP_ASUS_PS3_100;\n\t\tmask_keydown = 0x0040000;\n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_ENCORE_ENLTV:\n\tcase SAA7134_BOARD_ENCORE_ENLTV_FM:\n\t\tir_codes     = RC_MAP_ENCORE_ENLTV;\n\t\tmask_keycode = 0x00007f;\n\t\tmask_keyup   = 0x040000;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_ENCORE_ENLTV_FM53:\n\tcase SAA7134_BOARD_ENCORE_ENLTV_FM3:\n\t\tir_codes     = RC_MAP_ENCORE_ENLTV_FM53;\n\t\tmask_keydown = 0x0040000;\t \n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_10MOONSTVMASTER3:\n\t\tir_codes     = RC_MAP_ENCORE_ENLTV;\n\t\tmask_keycode = 0x5f80000;\n\t\tmask_keyup   = 0x8000000;\n\t\tpolling      = 50; \n\t\tbreak;\n\tcase SAA7134_BOARD_GENIUS_TVGO_A11MCE:\n\t\tir_codes     = RC_MAP_GENIUS_TVGO_A11MCE;\n\t\tmask_keycode = 0xff;\n\t\tmask_keydown = 0xf00000;\n\t\tpolling = 50;  \n\t\tbreak;\n\tcase SAA7134_BOARD_REAL_ANGEL_220:\n\t\tir_codes     = RC_MAP_REAL_AUDIO_220_32_KEYS;\n\t\tmask_keycode = 0x3f00;\n\t\tmask_keyup   = 0x4000;\n\t\tpolling = 50;  \n\t\tbreak;\n\tcase SAA7134_BOARD_KWORLD_PLUS_TV_ANALOG:\n\t\tir_codes     = RC_MAP_KWORLD_PLUS_TV_ANALOG;\n\t\tmask_keycode = 0x7f;\n\t\tpolling = 40;  \n\t\tbreak;\n\tcase SAA7134_BOARD_VIDEOMATE_S350:\n\t\tir_codes     = RC_MAP_VIDEOMATE_S350;\n\t\tmask_keycode = 0x003f00;\n\t\tmask_keydown = 0x040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_LEADTEK_WINFAST_DTV1000S:\n\t\tir_codes     = RC_MAP_WINFAST;\n\t\tmask_keycode = 0x5f00;\n\t\tmask_keyup   = 0x020000;\n\t\tpolling      = 50;  \n\t\tbreak;\n\tcase SAA7134_BOARD_VIDEOMATE_M1F:\n\t\tir_codes     = RC_MAP_VIDEOMATE_K100;\n\t\tmask_keycode = 0x0ff00;\n\t\tmask_keyup   = 0x040000;\n\t\tbreak;\n\tcase SAA7134_BOARD_HAUPPAUGE_HVR1150:\n\tcase SAA7134_BOARD_HAUPPAUGE_HVR1120:\n\t\tir_codes     = RC_MAP_HAUPPAUGE;\n\t\tmask_keydown = 0x0040000;\t \n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\tcase SAA7134_BOARD_LEADTEK_WINFAST_TV2100_FM:\n\t\tir_codes     = RC_MAP_LEADTEK_Y04G0051;\n\t\tmask_keydown = 0x0040000;\t \n\t\tmask_keyup   = 0x0040000;\n\t\tmask_keycode = 0xffff;\n\t\traw_decode   = true;\n\t\tbreak;\n\t}\n\tif (NULL == ir_codes) {\n\t\tpr_err(\"Oops: IR config error [card=%d]\\n\", dev->board);\n\t\treturn -ENODEV;\n\t}\n\n\tir = kzalloc(sizeof(*ir), GFP_KERNEL);\n\trc = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!ir || !rc) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\n\tir->dev = rc;\n\tdev->remote = ir;\n\n\t \n\tir->mask_keycode = mask_keycode;\n\tir->mask_keydown = mask_keydown;\n\tir->mask_keyup   = mask_keyup;\n\tir->polling      = polling;\n\tir->raw_decode\t = raw_decode;\n\n\t \n\tsnprintf(ir->phys, sizeof(ir->phys), \"pci-%s/ir0\",\n\t\t pci_name(dev->pci));\n\n\trc->priv = dev;\n\trc->open = saa7134_ir_open;\n\trc->close = saa7134_ir_close;\n\tif (raw_decode) {\n\t\trc->driver_type = RC_DRIVER_IR_RAW;\n\t\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\t}\n\n\trc->device_name = saa7134_boards[dev->board].name;\n\trc->input_phys = ir->phys;\n\trc->input_id.bustype = BUS_PCI;\n\trc->input_id.version = 1;\n\tif (dev->pci->subsystem_vendor) {\n\t\trc->input_id.vendor  = dev->pci->subsystem_vendor;\n\t\trc->input_id.product = dev->pci->subsystem_device;\n\t} else {\n\t\trc->input_id.vendor  = dev->pci->vendor;\n\t\trc->input_id.product = dev->pci->device;\n\t}\n\trc->dev.parent = &dev->pci->dev;\n\trc->map_name = ir_codes;\n\trc->driver_name = MODULE_NAME;\n\trc->min_timeout = 1;\n\trc->timeout = IR_DEFAULT_TIMEOUT;\n\trc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto err_out_free;\n\n\treturn 0;\n\nerr_out_free:\n\trc_free_device(rc);\n\tdev->remote = NULL;\n\tkfree(ir);\n\treturn err;\n}\n\nvoid saa7134_input_fini(struct saa7134_dev *dev)\n{\n\tif (NULL == dev->remote)\n\t\treturn;\n\n\trc_unregister_device(dev->remote->dev);\n\tkfree(dev->remote);\n\tdev->remote = NULL;\n}\n\nvoid saa7134_probe_i2c_ir(struct saa7134_dev *dev)\n{\n\tstruct i2c_board_info info;\n\tstruct i2c_msg msg_msi = {\n\t\t.addr = 0x50,\n\t\t.flags = I2C_M_RD,\n\t\t.len = 0,\n\t\t.buf = NULL,\n\t};\n\tint rc;\n\n\tif (disable_ir) {\n\t\tinput_dbg(\"IR has been disabled, not probing for i2c remote\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tmemset(&dev->init_data, 0, sizeof(dev->init_data));\n\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_PINNACLE_PCTV_110i:\n\tcase SAA7134_BOARD_PINNACLE_PCTV_310i:\n\t\tdev->init_data.name = \"Pinnacle PCTV\";\n\t\tif (pinnacle_remote == 0) {\n\t\t\tdev->init_data.get_key = get_key_pinnacle_color;\n\t\t\tdev->init_data.ir_codes = RC_MAP_PINNACLE_COLOR;\n\t\t\tinfo.addr = 0x47;\n\t\t} else {\n\t\t\tdev->init_data.get_key = get_key_pinnacle_grey;\n\t\t\tdev->init_data.ir_codes = RC_MAP_PINNACLE_GREY;\n\t\t\tinfo.addr = 0x47;\n\t\t}\n\t\tbreak;\n\tcase SAA7134_BOARD_UPMOST_PURPLE_TV:\n\t\tdev->init_data.name = \"Purple TV\";\n\t\tdev->init_data.get_key = get_key_purpletv;\n\t\tdev->init_data.ir_codes = RC_MAP_PURPLETV;\n\t\tinfo.addr = 0x7a;\n\t\tbreak;\n\tcase SAA7134_BOARD_MSI_TVATANYWHERE_PLUS:\n\t\tdev->init_data.name = \"MSI TV@nywhere Plus\";\n\t\tdev->init_data.get_key = get_key_msi_tvanywhere_plus;\n\t\tdev->init_data.ir_codes = RC_MAP_MSI_TVANYWHERE_PLUS;\n\t\t \n\t\tdev->init_data.polling_interval = 50;\n\t\tinfo.addr = 0x30;\n\t\t \n\t\trc = i2c_transfer(&dev->i2c_adap, &msg_msi, 1);\n\t\tinput_dbg(\"probe 0x%02x @ %s: %s\\n\",\n\t\t\tmsg_msi.addr, dev->i2c_adap.name,\n\t\t\t(1 == rc) ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase SAA7134_BOARD_SNAZIO_TVPVR_PRO:\n\t\tdev->init_data.name = \"SnaZio* TVPVR PRO\";\n\t\tdev->init_data.get_key = get_key_msi_tvanywhere_plus;\n\t\tdev->init_data.ir_codes = RC_MAP_MSI_TVANYWHERE_PLUS;\n\t\t \n\t\tdev->init_data.polling_interval = 50;\n\t\tinfo.addr = 0x30;\n\t\t \n\t\trc = i2c_transfer(&dev->i2c_adap, &msg_msi, 1);\n\t\tinput_dbg(\"probe 0x%02x @ %s: %s\\n\",\n\t\t\tmsg_msi.addr, dev->i2c_adap.name,\n\t\t\t(rc == 1) ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase SAA7134_BOARD_KWORLD_PC150U:\n\t\t \n\t\tdev->init_data.name = \"Kworld PC150-U\";\n\t\tdev->init_data.get_key = get_key_kworld_pc150u;\n\t\tdev->init_data.ir_codes = RC_MAP_KWORLD_PC150U;\n\t\tinfo.addr = 0x30;\n\t\t \n\t\trc = i2c_transfer(&dev->i2c_adap, &msg_msi, 1);\n\t\tinput_dbg(\"probe 0x%02x @ %s: %s\\n\",\n\t\t\tmsg_msi.addr, dev->i2c_adap.name,\n\t\t\t(1 == rc) ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase SAA7134_BOARD_HAUPPAUGE_HVR1110:\n\t\tdev->init_data.name = saa7134_boards[dev->board].name;\n\t\tdev->init_data.ir_codes = RC_MAP_HAUPPAUGE;\n\t\tdev->init_data.type = RC_PROTO_BIT_RC5 |\n\t\t\t\tRC_PROTO_BIT_RC6_MCE | RC_PROTO_BIT_RC6_6A_32;\n\t\tdev->init_data.internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\t\tinfo.addr = 0x71;\n\t\tbreak;\n\tcase SAA7134_BOARD_BEHOLD_607FM_MK3:\n\tcase SAA7134_BOARD_BEHOLD_607FM_MK5:\n\tcase SAA7134_BOARD_BEHOLD_609FM_MK3:\n\tcase SAA7134_BOARD_BEHOLD_609FM_MK5:\n\tcase SAA7134_BOARD_BEHOLD_607RDS_MK3:\n\tcase SAA7134_BOARD_BEHOLD_607RDS_MK5:\n\tcase SAA7134_BOARD_BEHOLD_609RDS_MK3:\n\tcase SAA7134_BOARD_BEHOLD_609RDS_MK5:\n\tcase SAA7134_BOARD_BEHOLD_M6:\n\tcase SAA7134_BOARD_BEHOLD_M63:\n\tcase SAA7134_BOARD_BEHOLD_M6_EXTRA:\n\tcase SAA7134_BOARD_BEHOLD_H6:\n\tcase SAA7134_BOARD_BEHOLD_X7:\n\tcase SAA7134_BOARD_BEHOLD_H7:\n\tcase SAA7134_BOARD_BEHOLD_A7:\n\t\tdev->init_data.name = \"BeholdTV\";\n\t\tdev->init_data.get_key = get_key_beholdm6xx;\n\t\tdev->init_data.ir_codes = RC_MAP_BEHOLD;\n\t\tdev->init_data.type = RC_PROTO_BIT_NECX;\n\t\tinfo.addr = 0x2d;\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_CARDBUS_501:\n\tcase SAA7134_BOARD_AVERMEDIA_CARDBUS_506:\n\t\tinfo.addr = 0x40;\n\t\tbreak;\n\tcase SAA7134_BOARD_AVERMEDIA_A706:\n\t\tinfo.addr = 0x41;\n\t\tbreak;\n\tcase SAA7134_BOARD_FLYDVB_TRIO:\n\t\tdev->init_data.name = \"FlyDVB Trio\";\n\t\tdev->init_data.get_key = get_key_flydvb_trio;\n\t\tdev->init_data.ir_codes = RC_MAP_FLYDVB;\n\t\tinfo.addr = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\tinput_dbg(\"No I2C IR support for board %x\\n\", dev->board);\n\t\treturn;\n\t}\n\n\tif (dev->init_data.name)\n\t\tinfo.platform_data = &dev->init_data;\n\ti2c_new_client_device(&dev->i2c_adap, &info);\n}\n\nstatic int saa7134_raw_decode_irq(struct saa7134_dev *dev)\n{\n\tstruct saa7134_card_ir *ir = dev->remote;\n\tint space;\n\n\t \n\tsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\n\tspace = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2) & ir->mask_keydown;\n\tir_raw_event_store_edge(dev->remote->dev, !space);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}