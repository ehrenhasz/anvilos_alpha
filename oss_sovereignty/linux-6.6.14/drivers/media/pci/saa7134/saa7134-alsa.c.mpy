{
  "module_name": "saa7134-alsa.c",
  "hash_id": "0c6b484fbbd44d4484d1a3ca5fcf7cca8d91ffb9dd968f66d7d476531f2a48c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-alsa.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n\n \n\n \n#define MIXER_ADDR_UNSELECTED\t-1\n#define MIXER_ADDR_TVTUNER\t0\n#define MIXER_ADDR_LINE1\t1\n#define MIXER_ADDR_LINE2\t2\n#define MIXER_ADDR_LAST\t\t2\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 1};\n\nmodule_param_array(index, int, NULL, 0444);\nmodule_param_array(enable, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for SAA7134 capture interface(s).\");\nMODULE_PARM_DESC(enable, \"Enable (or not) the SAA7134 capture interface(s).\");\n\n \n\ntypedef struct snd_card_saa7134 {\n\tstruct snd_card *card;\n\tspinlock_t mixer_lock;\n\tint mixer_volume[MIXER_ADDR_LAST+1][2];\n\tint capture_source_addr;\n\tint capture_source[2];\n\tstruct snd_kcontrol *capture_ctl[MIXER_ADDR_LAST+1];\n\tstruct pci_dev *pci;\n\tstruct saa7134_dev *dev;\n\n\tunsigned long iobase;\n\ts16 irq;\n\tu16 mute_was_on;\n\n\tspinlock_t lock;\n} snd_card_saa7134_t;\n\n\n \n\ntypedef struct snd_card_saa7134_pcm {\n\tstruct saa7134_dev *dev;\n\n\tspinlock_t lock;\n\n\tstruct snd_pcm_substream *substream;\n} snd_card_saa7134_pcm_t;\n\nstatic struct snd_card *snd_saa7134_cards[SNDRV_CARDS];\n\n\n \n\nstatic void saa7134_dma_stop(struct saa7134_dev *dev)\n{\n\tdev->dmasound.dma_blk     = -1;\n\tdev->dmasound.dma_running = 0;\n\tsaa7134_set_dmabits(dev);\n}\n\n \n\nstatic void saa7134_dma_start(struct saa7134_dev *dev)\n{\n\tdev->dmasound.dma_blk     = 0;\n\tdev->dmasound.dma_running = 1;\n\tsaa7134_set_dmabits(dev);\n}\n\n \n\nstatic void saa7134_irq_alsa_done(struct saa7134_dev *dev,\n\t\t\t\t  unsigned long status)\n{\n\tint next_blk, reg = 0;\n\n\tspin_lock(&dev->slock);\n\tif (UNSET == dev->dmasound.dma_blk) {\n\t\tpr_debug(\"irq: recording stopped\\n\");\n\t\tgoto done;\n\t}\n\tif (0 != (status & 0x0f000000))\n\t\tpr_debug(\"irq: lost %ld\\n\", (status >> 24) & 0x0f);\n\tif (0 == (status & 0x10000000)) {\n\t\t \n\t\tif (0 == (dev->dmasound.dma_blk & 0x01))\n\t\t\treg = SAA7134_RS_BA1(6);\n\t} else {\n\t\t \n\t\tif (1 == (dev->dmasound.dma_blk & 0x01))\n\t\t\treg = SAA7134_RS_BA2(6);\n\t}\n\tif (0 == reg) {\n\t\tpr_debug(\"irq: field oops [%s]\\n\",\n\t\t\t(status & 0x10000000) ? \"even\" : \"odd\");\n\t\tgoto done;\n\t}\n\n\tif (dev->dmasound.read_count >= dev->dmasound.blksize * (dev->dmasound.blocks-2)) {\n\t\tpr_debug(\"irq: overrun [full=%d/%d] - Blocks in %d\\n\",\n\t\t\tdev->dmasound.read_count,\n\t\t\tdev->dmasound.bufsize, dev->dmasound.blocks);\n\t\tspin_unlock(&dev->slock);\n\t\tsnd_pcm_stop_xrun(dev->dmasound.substream);\n\t\treturn;\n\t}\n\n\t \n\tnext_blk = (dev->dmasound.dma_blk + 2) % dev->dmasound.blocks;\n\tsaa_writel(reg,next_blk * dev->dmasound.blksize);\n\tpr_debug(\"irq: ok, %s, next_blk=%d, addr=%x, blocks=%u, size=%u, read=%u\\n\",\n\t\t(status & 0x10000000) ? \"even\" : \"odd \", next_blk,\n\t\t next_blk * dev->dmasound.blksize, dev->dmasound.blocks,\n\t\t dev->dmasound.blksize, dev->dmasound.read_count);\n\n\t \n\tdev->dmasound.dma_blk = (dev->dmasound.dma_blk + 1) % dev->dmasound.blocks;\n\tdev->dmasound.read_count += dev->dmasound.blksize;\n\n\tdev->dmasound.recording_on = reg;\n\n\tif (dev->dmasound.read_count >= snd_pcm_lib_period_bytes(dev->dmasound.substream)) {\n\t\tspin_unlock(&dev->slock);\n\t\tsnd_pcm_period_elapsed(dev->dmasound.substream);\n\t\tspin_lock(&dev->slock);\n\t}\n\n done:\n\tspin_unlock(&dev->slock);\n\n}\n\n \n\nstatic irqreturn_t saa7134_alsa_irq(int irq, void *dev_id)\n{\n\tstruct saa7134_dmasound *dmasound = dev_id;\n\tstruct saa7134_dev *dev = dmasound->priv_data;\n\n\tunsigned long report, status;\n\tint loop, handled = 0;\n\n\tfor (loop = 0; loop < 10; loop++) {\n\t\treport = saa_readl(SAA7134_IRQ_REPORT);\n\t\tstatus = saa_readl(SAA7134_IRQ_STATUS);\n\n\t\tif (report & SAA7134_IRQ_REPORT_DONE_RA3) {\n\t\t\thandled = 1;\n\t\t\tsaa_writel(SAA7134_IRQ_REPORT,\n\t\t\t\t   SAA7134_IRQ_REPORT_DONE_RA3);\n\t\t\tsaa7134_irq_alsa_done(dev, status);\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (loop == 10) {\n\t\tpr_debug(\"error! looping IRQ!\");\n\t}\n\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic int snd_card_saa7134_capture_trigger(struct snd_pcm_substream * substream,\n\t\t\t\t\t  int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\n\tstruct saa7134_dev *dev=pcm->dev;\n\tint err = 0;\n\n\tspin_lock(&dev->slock);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t \n\t\tsaa7134_dma_start(dev);\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\t \n\t\tsaa7134_dma_stop(dev);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&dev->slock);\n\n\treturn err;\n}\n\nstatic int saa7134_alsa_dma_init(struct saa7134_dev *dev,\n\t\t\t\t unsigned long nr_pages)\n{\n\tstruct saa7134_dmasound *dma = &dev->dmasound;\n\tstruct page *pg;\n\tint i;\n\n\tdma->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\n\tif (NULL == dma->vaddr) {\n\t\tpr_debug(\"vmalloc_32(%lu pages) failed\\n\", nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"vmalloc is at addr %p, size=%lu\\n\",\n\t\t dma->vaddr, nr_pages << PAGE_SHIFT);\n\n\tmemset(dma->vaddr, 0, nr_pages << PAGE_SHIFT);\n\tdma->nr_pages = nr_pages;\n\n\tdma->sglist = vzalloc(array_size(sizeof(*dma->sglist), dma->nr_pages));\n\tif (NULL == dma->sglist)\n\t\tgoto vzalloc_err;\n\n\tsg_init_table(dma->sglist, dma->nr_pages);\n\tfor (i = 0; i < dma->nr_pages; i++) {\n\t\tpg = vmalloc_to_page(dma->vaddr + i * PAGE_SIZE);\n\t\tif (NULL == pg)\n\t\t\tgoto vmalloc_to_page_err;\n\t\tsg_set_page(&dma->sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn 0;\n\nvmalloc_to_page_err:\n\tvfree(dma->sglist);\n\tdma->sglist = NULL;\nvzalloc_err:\n\tvfree(dma->vaddr);\n\tdma->vaddr = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int saa7134_alsa_dma_map(struct saa7134_dev *dev)\n{\n\tstruct saa7134_dmasound *dma = &dev->dmasound;\n\n\tdma->sglen = dma_map_sg(&dev->pci->dev, dma->sglist,\n\t\t\tdma->nr_pages, DMA_FROM_DEVICE);\n\n\tif (0 == dma->sglen) {\n\t\tpr_warn(\"%s: saa7134_alsa_map_sg failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int saa7134_alsa_dma_unmap(struct saa7134_dev *dev)\n{\n\tstruct saa7134_dmasound *dma = &dev->dmasound;\n\n\tif (!dma->sglen)\n\t\treturn 0;\n\n\tdma_unmap_sg(&dev->pci->dev, dma->sglist, dma->nr_pages, DMA_FROM_DEVICE);\n\tdma->sglen = 0;\n\treturn 0;\n}\n\nstatic int saa7134_alsa_dma_free(struct saa7134_dmasound *dma)\n{\n\tvfree(dma->sglist);\n\tdma->sglist = NULL;\n\tvfree(dma->vaddr);\n\tdma->vaddr = NULL;\n\treturn 0;\n}\n\n \n\nstatic int dsp_buffer_init(struct saa7134_dev *dev)\n{\n\tint err;\n\n\tBUG_ON(!dev->dmasound.bufsize);\n\n\terr = saa7134_alsa_dma_init(dev,\n\t\t\t       (dev->dmasound.bufsize + PAGE_SIZE) >> PAGE_SHIFT);\n\tif (0 != err)\n\t\treturn err;\n\treturn 0;\n}\n\n \n\nstatic int dsp_buffer_free(struct saa7134_dev *dev)\n{\n\tBUG_ON(!dev->dmasound.blksize);\n\n\tsaa7134_alsa_dma_free(&dev->dmasound);\n\n\tdev->dmasound.blocks  = 0;\n\tdev->dmasound.blksize = 0;\n\tdev->dmasound.bufsize = 0;\n\n\treturn 0;\n}\n\n \nstatic int snd_saa7134_capsrc_set(struct snd_kcontrol *kcontrol,\n\t\t\t\t  int left, int right, bool force_notify)\n{\n\tsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\n\tint change = 0, addr = kcontrol->private_value;\n\tint active, old_addr;\n\tu32 anabar, xbarin;\n\tint analog_io, rate;\n\tstruct saa7134_dev *dev;\n\n\tdev = chip->dev;\n\n\tspin_lock_irq(&chip->mixer_lock);\n\n\tactive = left != 0 || right != 0;\n\told_addr = chip->capture_source_addr;\n\n\t \n\tif (active) {\n\t\tchange = old_addr != addr ||\n\t\t\t chip->capture_source[0] != left ||\n\t\t\t chip->capture_source[1] != right;\n\n\t\tchip->capture_source[0] = left;\n\t\tchip->capture_source[1] = right;\n\t\tchip->capture_source_addr = addr;\n\t\tdev->dmasound.input = addr;\n\t}\n\tspin_unlock_irq(&chip->mixer_lock);\n\n\tif (change) {\n\t\tswitch (dev->pci->device) {\n\n\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7134:\n\t\t\tswitch (addr) {\n\t\t\tcase MIXER_ADDR_TVTUNER:\n\t\t\t\tsaa_andorb(SAA7134_AUDIO_FORMAT_CTRL,\n\t\t\t\t\t   0xc0, 0xc0);\n\t\t\t\tsaa_andorb(SAA7134_SIF_SAMPLE_FREQ,\n\t\t\t\t\t   0x03, 0x00);\n\t\t\t\tbreak;\n\t\t\tcase MIXER_ADDR_LINE1:\n\t\t\tcase MIXER_ADDR_LINE2:\n\t\t\t\tanalog_io = (MIXER_ADDR_LINE1 == addr) ?\n\t\t\t\t\t     0x00 : 0x08;\n\t\t\t\trate = (32000 == dev->dmasound.rate) ?\n\t\t\t\t\t0x01 : 0x03;\n\t\t\t\tsaa_andorb(SAA7134_ANALOG_IO_SELECT,\n\t\t\t\t\t   0x08, analog_io);\n\t\t\t\tsaa_andorb(SAA7134_AUDIO_FORMAT_CTRL,\n\t\t\t\t\t   0xc0, 0x80);\n\t\t\t\tsaa_andorb(SAA7134_SIF_SAMPLE_FREQ,\n\t\t\t\t\t   0x03, rate);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7133:\n\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7135:\n\t\t\txbarin = 0x03;  \n\t\t\tanabar = 0;\n\t\t\tswitch (addr) {\n\t\t\tcase MIXER_ADDR_TVTUNER:\n\t\t\t\txbarin = 0;  \n\t\t\t\tanabar = 2;  \n\t\t\t\tbreak;\n\t\t\tcase MIXER_ADDR_LINE1:\n\t\t\t\tanabar = 0;   \n\t\t\t\tbreak;\n\t\t\tcase MIXER_ADDR_LINE2:\n\t\t\t\tanabar = 9;   \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tsaa_dsp_writel(dev, SAA7133_DIGITAL_OUTPUT_SEL1,\n\t\t\t\t       0xbbbb10);\n\n\t\t\tif (left || right) {\n\t\t\t\t \n\t\t\t\tsaa_dsp_writel(dev, SAA7133_DIGITAL_INPUT_XBAR1,\n\t\t\t\t\t       xbarin);\n\t\t\t\tsaa_writel(SAA7133_ANALOG_IO_SELECT, anabar);\n\t\t\t} else {\n\t\t\t\tsaa_dsp_writel(dev, SAA7133_DIGITAL_INPUT_XBAR1,\n\t\t\t\t\t       0);\n\t\t\t\tsaa_writel(SAA7133_ANALOG_IO_SELECT, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (change) {\n\t\tif (force_notify)\n\t\t\tsnd_ctl_notify(chip->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->capture_ctl[addr]->id);\n\n\t\tif (old_addr != MIXER_ADDR_UNSELECTED && old_addr != addr)\n\t\t\tsnd_ctl_notify(chip->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->capture_ctl[old_addr]->id);\n\t}\n\n\treturn change;\n}\n\n \n\nstatic int snd_card_saa7134_capture_prepare(struct snd_pcm_substream * substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint bswap, sign;\n\tu32 fmt, control;\n\tsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\n\tstruct saa7134_dev *dev;\n\tsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\n\n\tpcm->dev->dmasound.substream = substream;\n\n\tdev = saa7134->dev;\n\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tfmt = 0x00;\n\telse\n\t\tfmt = 0x01;\n\n\tif (snd_pcm_format_signed(runtime->format))\n\t\tsign = 1;\n\telse\n\t\tsign = 0;\n\n\tif (snd_pcm_format_big_endian(runtime->format))\n\t\tbswap = 1;\n\telse\n\t\tbswap = 0;\n\n\tswitch (dev->pci->device) {\n\t  case PCI_DEVICE_ID_PHILIPS_SAA7134:\n\t\tif (1 == runtime->channels)\n\t\t\tfmt |= (1 << 3);\n\t\tif (2 == runtime->channels)\n\t\t\tfmt |= (3 << 3);\n\t\tif (sign)\n\t\t\tfmt |= 0x04;\n\n\t\tfmt |= (MIXER_ADDR_TVTUNER == dev->dmasound.input) ? 0xc0 : 0x80;\n\t\tsaa_writeb(SAA7134_NUM_SAMPLES0, ((dev->dmasound.blksize - 1) & 0x0000ff));\n\t\tsaa_writeb(SAA7134_NUM_SAMPLES1, ((dev->dmasound.blksize - 1) & 0x00ff00) >>  8);\n\t\tsaa_writeb(SAA7134_NUM_SAMPLES2, ((dev->dmasound.blksize - 1) & 0xff0000) >> 16);\n\t\tsaa_writeb(SAA7134_AUDIO_FORMAT_CTRL, fmt);\n\n\t\tbreak;\n\t  case PCI_DEVICE_ID_PHILIPS_SAA7133:\n\t  case PCI_DEVICE_ID_PHILIPS_SAA7135:\n\t\tif (1 == runtime->channels)\n\t\t\tfmt |= (1 << 4);\n\t\tif (2 == runtime->channels)\n\t\t\tfmt |= (2 << 4);\n\t\tif (!sign)\n\t\t\tfmt |= 0x04;\n\t\tsaa_writel(SAA7133_NUM_SAMPLES, dev->dmasound.blksize -1);\n\t\tsaa_writel(SAA7133_AUDIO_CHANNEL, 0x543210 | (fmt << 24));\n\t\tbreak;\n\t}\n\n\tpr_debug(\"rec_start: afmt=%d ch=%d  =>  fmt=0x%x swap=%c\\n\",\n\t\truntime->format, runtime->channels, fmt,\n\t\tbswap ? 'b' : '-');\n\t \n\tcontrol = SAA7134_RS_CONTROL_BURST_16 |\n\t\tSAA7134_RS_CONTROL_ME |\n\t\t(dev->dmasound.pt.dma >> 12);\n\tif (bswap)\n\t\tcontrol |= SAA7134_RS_CONTROL_BSWAP;\n\n\tsaa_writel(SAA7134_RS_BA1(6),0);\n\tsaa_writel(SAA7134_RS_BA2(6),dev->dmasound.blksize);\n\tsaa_writel(SAA7134_RS_PITCH(6),0);\n\tsaa_writel(SAA7134_RS_CONTROL(6),control);\n\n\tdev->dmasound.rate = runtime->rate;\n\n\t \n\tsnd_saa7134_capsrc_set(saa7134->capture_ctl[dev->dmasound.input], 1, 1,\n\t\t\t       true);\n\n\treturn 0;\n\n}\n\n \n\nstatic snd_pcm_uframes_t\nsnd_card_saa7134_capture_pointer(struct snd_pcm_substream * substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\n\tstruct saa7134_dev *dev=pcm->dev;\n\n\tif (dev->dmasound.read_count) {\n\t\tdev->dmasound.read_count  -= snd_pcm_lib_period_bytes(substream);\n\t\tdev->dmasound.read_offset += snd_pcm_lib_period_bytes(substream);\n\t\tif (dev->dmasound.read_offset == dev->dmasound.bufsize)\n\t\t\tdev->dmasound.read_offset = 0;\n\t}\n\n\treturn bytes_to_frames(runtime, dev->dmasound.read_offset);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_card_saa7134_capture =\n{\n\t.info =                 (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_BE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S8 | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U8 | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_BE,\n\t.rates =\t\tSNDRV_PCM_RATE_32000,\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t32000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(256*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(256*1024),\n\t.periods_min =\t\t4,\n\t.periods_max =\t\t1024,\n};\n\nstatic void snd_card_saa7134_runtime_free(struct snd_pcm_runtime *runtime)\n{\n\tsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\n\n\tkfree(pcm);\n}\n\n\n \n\nstatic int snd_card_saa7134_hw_params(struct snd_pcm_substream * substream,\n\t\t\t\t      struct snd_pcm_hw_params * hw_params)\n{\n\tsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\n\tstruct saa7134_dev *dev;\n\tunsigned int period_size, periods;\n\tint err;\n\n\tperiod_size = params_period_bytes(hw_params);\n\tperiods = params_periods(hw_params);\n\n\tif (period_size < 0x100 || period_size > 0x10000)\n\t\treturn -EINVAL;\n\tif (periods < 4)\n\t\treturn -EINVAL;\n\tif (period_size * periods > 1024 * 1024)\n\t\treturn -EINVAL;\n\n\tdev = saa7134->dev;\n\n\tif (dev->dmasound.blocks == periods &&\n\t    dev->dmasound.blksize == period_size)\n\t\treturn 0;\n\n\t \n\tif (substream->runtime->dma_area) {\n\t\tsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\n\t\tsaa7134_alsa_dma_unmap(dev);\n\t\tdsp_buffer_free(dev);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\tdev->dmasound.blocks  = periods;\n\tdev->dmasound.blksize = period_size;\n\tdev->dmasound.bufsize = period_size * periods;\n\n\terr = dsp_buffer_init(dev);\n\tif (0 != err) {\n\t\tdev->dmasound.blocks  = 0;\n\t\tdev->dmasound.blksize = 0;\n\t\tdev->dmasound.bufsize = 0;\n\t\treturn err;\n\t}\n\n\terr = saa7134_alsa_dma_map(dev);\n\tif (err) {\n\t\tdsp_buffer_free(dev);\n\t\treturn err;\n\t}\n\terr = saa7134_pgtable_alloc(dev->pci, &dev->dmasound.pt);\n\tif (err) {\n\t\tsaa7134_alsa_dma_unmap(dev);\n\t\tdsp_buffer_free(dev);\n\t\treturn err;\n\t}\n\terr = saa7134_pgtable_build(dev->pci, &dev->dmasound.pt,\n\t\t\t\tdev->dmasound.sglist, dev->dmasound.sglen, 0);\n\tif (err) {\n\t\tsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\n\t\tsaa7134_alsa_dma_unmap(dev);\n\t\tdsp_buffer_free(dev);\n\t\treturn err;\n\t}\n\n\t \n\n\tsubstream->runtime->dma_area = dev->dmasound.vaddr;\n\tsubstream->runtime->dma_bytes = dev->dmasound.bufsize;\n\tsubstream->runtime->dma_addr = 0;\n\n\treturn 0;\n\n}\n\n \n\nstatic int snd_card_saa7134_hw_free(struct snd_pcm_substream * substream)\n{\n\tsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\n\tstruct saa7134_dev *dev;\n\n\tdev = saa7134->dev;\n\n\tif (substream->runtime->dma_area) {\n\t\tsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\n\t\tsaa7134_alsa_dma_unmap(dev);\n\t\tdsp_buffer_free(dev);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int snd_card_saa7134_capture_close(struct snd_pcm_substream * substream)\n{\n\tsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\n\tstruct saa7134_dev *dev = saa7134->dev;\n\n\tif (saa7134->mute_was_on) {\n\t\tdev->ctl_mute = 1;\n\t\tsaa7134_tvaudio_setmute(dev);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_card_saa7134_capture_open(struct snd_pcm_substream * substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_card_saa7134_pcm_t *pcm;\n\tsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\n\tstruct saa7134_dev *dev;\n\tint amux, err;\n\n\tif (!saa7134) {\n\t\tpr_err(\"BUG: saa7134 can't find device struct. Can't proceed with open\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev = saa7134->dev;\n\tmutex_lock(&dev->dmasound.lock);\n\n\tdev->dmasound.read_count  = 0;\n\tdev->dmasound.read_offset = 0;\n\n\tamux = dev->input->amux;\n\tif ((amux < 1) || (amux > 3))\n\t\tamux = 1;\n\tdev->dmasound.input  =  amux - 1;\n\n\tmutex_unlock(&dev->dmasound.lock);\n\n\tpcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\n\tif (pcm == NULL)\n\t\treturn -ENOMEM;\n\n\tpcm->dev=saa7134->dev;\n\n\tspin_lock_init(&pcm->lock);\n\n\tpcm->substream = substream;\n\truntime->private_data = pcm;\n\truntime->private_free = snd_card_saa7134_runtime_free;\n\truntime->hw = snd_card_saa7134_capture;\n\n\tif (dev->ctl_mute != 0) {\n\t\tsaa7134->mute_was_on = 1;\n\t\tdev->ctl_mute = 0;\n\t\tsaa7134_tvaudio_setmute(dev);\n\t}\n\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIODS, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic struct page *snd_card_saa7134_page(struct snd_pcm_substream *substream,\n\t\t\t\t\tunsigned long offset)\n{\n\tvoid *pageptr = substream->runtime->dma_area + offset;\n\treturn vmalloc_to_page(pageptr);\n}\n\n \n\nstatic const struct snd_pcm_ops snd_card_saa7134_capture_ops = {\n\t.open =\t\t\tsnd_card_saa7134_capture_open,\n\t.close =\t\tsnd_card_saa7134_capture_close,\n\t.hw_params =\t\tsnd_card_saa7134_hw_params,\n\t.hw_free =\t\tsnd_card_saa7134_hw_free,\n\t.prepare =\t\tsnd_card_saa7134_capture_prepare,\n\t.trigger =\t\tsnd_card_saa7134_capture_trigger,\n\t.pointer =\t\tsnd_card_saa7134_capture_pointer,\n\t.page =\t\t\tsnd_card_saa7134_page,\n};\n\n \n\nstatic int snd_card_saa7134_pcm(snd_card_saa7134_t *saa7134, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tif ((err = snd_pcm_new(saa7134->card, \"SAA7134 PCM\", device, 0, 1, &pcm)) < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_saa7134_capture_ops);\n\tpcm->private_data = saa7134;\n\tpcm->info_flags = 0;\n\tstrscpy(pcm->name, \"SAA7134 PCM\", sizeof(pcm->name));\n\treturn 0;\n}\n\n#define SAA713x_VOLUME(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_saa7134_volume_info, \\\n  .get = snd_saa7134_volume_get, .put = snd_saa7134_volume_put, \\\n  .private_value = addr }\n\nstatic int snd_saa7134_volume_info(struct snd_kcontrol * kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info * uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 20;\n\treturn 0;\n}\n\nstatic int snd_saa7134_volume_get(struct snd_kcontrol * kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value * ucontrol)\n{\n\tsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\n\tint addr = kcontrol->private_value;\n\n\tucontrol->value.integer.value[0] = chip->mixer_volume[addr][0];\n\tucontrol->value.integer.value[1] = chip->mixer_volume[addr][1];\n\treturn 0;\n}\n\nstatic int snd_saa7134_volume_put(struct snd_kcontrol * kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value * ucontrol)\n{\n\tsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\n\tstruct saa7134_dev *dev = chip->dev;\n\n\tint change, addr = kcontrol->private_value;\n\tint left, right;\n\n\tleft = ucontrol->value.integer.value[0];\n\tif (left < 0)\n\t\tleft = 0;\n\tif (left > 20)\n\t\tleft = 20;\n\tright = ucontrol->value.integer.value[1];\n\tif (right < 0)\n\t\tright = 0;\n\tif (right > 20)\n\t\tright = 20;\n\tspin_lock_irq(&chip->mixer_lock);\n\tchange = 0;\n\tif (chip->mixer_volume[addr][0] != left) {\n\t\tchange = 1;\n\t\tright = left;\n\t}\n\tif (chip->mixer_volume[addr][1] != right) {\n\t\tchange = 1;\n\t\tleft = right;\n\t}\n\tif (change) {\n\t\tswitch (dev->pci->device) {\n\t\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7134:\n\t\t\t\tswitch (addr) {\n\t\t\t\t\tcase MIXER_ADDR_TVTUNER:\n\t\t\t\t\t\tleft = 20;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_ADDR_LINE1:\n\t\t\t\t\t\tsaa_andorb(SAA7134_ANALOG_IO_SELECT,  0x10,\n\t\t\t\t\t\t\t   (left > 10) ? 0x00 : 0x10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_ADDR_LINE2:\n\t\t\t\t\t\tsaa_andorb(SAA7134_ANALOG_IO_SELECT,  0x20,\n\t\t\t\t\t\t\t   (left > 10) ? 0x00 : 0x20);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7133:\n\t\t\tcase PCI_DEVICE_ID_PHILIPS_SAA7135:\n\t\t\t\tswitch (addr) {\n\t\t\t\t\tcase MIXER_ADDR_TVTUNER:\n\t\t\t\t\t\tleft = 20;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_ADDR_LINE1:\n\t\t\t\t\t\tsaa_andorb(0x0594,  0x10,\n\t\t\t\t\t\t\t   (left > 10) ? 0x00 : 0x10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_ADDR_LINE2:\n\t\t\t\t\t\tsaa_andorb(0x0594,  0x20,\n\t\t\t\t\t\t\t   (left > 10) ? 0x00 : 0x20);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tchip->mixer_volume[addr][0] = left;\n\t\tchip->mixer_volume[addr][1] = right;\n\t}\n\tspin_unlock_irq(&chip->mixer_lock);\n\treturn change;\n}\n\n#define SAA713x_CAPSRC(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_saa7134_capsrc_info, \\\n  .get = snd_saa7134_capsrc_get, .put = snd_saa7134_capsrc_put, \\\n  .private_value = addr }\n\nstatic int snd_saa7134_capsrc_info(struct snd_kcontrol * kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info * uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_saa7134_capsrc_get(struct snd_kcontrol * kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value * ucontrol)\n{\n\tsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\n\tint addr = kcontrol->private_value;\n\n\tspin_lock_irq(&chip->mixer_lock);\n\tif (chip->capture_source_addr == addr) {\n\t\tucontrol->value.integer.value[0] = chip->capture_source[0];\n\t\tucontrol->value.integer.value[1] = chip->capture_source[1];\n\t} else {\n\t\tucontrol->value.integer.value[0] = 0;\n\t\tucontrol->value.integer.value[1] = 0;\n\t}\n\tspin_unlock_irq(&chip->mixer_lock);\n\n\treturn 0;\n}\n\nstatic int snd_saa7134_capsrc_put(struct snd_kcontrol * kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value * ucontrol)\n{\n\tint left, right;\n\tleft = ucontrol->value.integer.value[0] & 1;\n\tright = ucontrol->value.integer.value[1] & 1;\n\n\treturn snd_saa7134_capsrc_set(kcontrol, left, right, false);\n}\n\nstatic struct snd_kcontrol_new snd_saa7134_volume_controls[] = {\nSAA713x_VOLUME(\"Video Volume\", 0, MIXER_ADDR_TVTUNER),\nSAA713x_VOLUME(\"Line Volume\", 1, MIXER_ADDR_LINE1),\nSAA713x_VOLUME(\"Line Volume\", 2, MIXER_ADDR_LINE2),\n};\n\nstatic struct snd_kcontrol_new snd_saa7134_capture_controls[] = {\nSAA713x_CAPSRC(\"Video Capture Switch\", 0, MIXER_ADDR_TVTUNER),\nSAA713x_CAPSRC(\"Line Capture Switch\", 1, MIXER_ADDR_LINE1),\nSAA713x_CAPSRC(\"Line Capture Switch\", 2, MIXER_ADDR_LINE2),\n};\n\n \n\nstatic int snd_card_saa7134_new_mixer(snd_card_saa7134_t * chip)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_kcontrol *kcontrol;\n\tunsigned int idx;\n\tint err, addr;\n\n\tstrscpy(card->mixername, \"SAA7134 Mixer\", sizeof(card->mixername));\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_saa7134_volume_controls); idx++) {\n\t\tkcontrol = snd_ctl_new1(&snd_saa7134_volume_controls[idx],\n\t\t\t\t\tchip);\n\t\terr = snd_ctl_add(card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_saa7134_capture_controls); idx++) {\n\t\tkcontrol = snd_ctl_new1(&snd_saa7134_capture_controls[idx],\n\t\t\t\t\tchip);\n\t\taddr = snd_saa7134_capture_controls[idx].private_value;\n\t\tchip->capture_ctl[addr] = kcontrol;\n\t\terr = snd_ctl_add(card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tchip->capture_source_addr = MIXER_ADDR_UNSELECTED;\n\treturn 0;\n}\n\nstatic void snd_saa7134_free(struct snd_card * card)\n{\n\tsnd_card_saa7134_t *chip = card->private_data;\n\n\tif (chip->dev->dmasound.priv_data == NULL)\n\t\treturn;\n\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, &chip->dev->dmasound);\n\n\tchip->dev->dmasound.priv_data = NULL;\n\n}\n\n \n\nstatic int alsa_card_saa7134_create(struct saa7134_dev *dev, int devnum)\n{\n\n\tstruct snd_card *card;\n\tsnd_card_saa7134_t *chip;\n\tint err;\n\n\n\tif (devnum >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[devnum])\n\t\treturn -ENODEV;\n\n\terr = snd_card_new(&dev->pci->dev, index[devnum], id[devnum],\n\t\t\t   THIS_MODULE, sizeof(snd_card_saa7134_t), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrscpy(card->driver, \"SAA7134\", sizeof(card->driver));\n\n\t \n\n\tcard->private_free = snd_saa7134_free;\n\tchip = card->private_data;\n\n\tspin_lock_init(&chip->lock);\n\tspin_lock_init(&chip->mixer_lock);\n\n\tchip->dev = dev;\n\n\tchip->card = card;\n\n\tchip->pci = dev->pci;\n\tchip->iobase = pci_resource_start(dev->pci, 0);\n\n\n\terr = request_irq(dev->pci->irq, saa7134_alsa_irq,\n\t\t\t\tIRQF_SHARED, dev->name,\n\t\t\t\t(void*) &dev->dmasound);\n\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't get IRQ %d for ALSA\\n\",\n\t\t\tdev->name, dev->pci->irq);\n\t\tgoto __nodev;\n\t}\n\n\tchip->irq = dev->pci->irq;\n\n\tmutex_init(&dev->dmasound.lock);\n\n\tif ((err = snd_card_saa7134_new_mixer(chip)) < 0)\n\t\tgoto __nodev;\n\n\tif ((err = snd_card_saa7134_pcm(chip, 0)) < 0)\n\t\tgoto __nodev;\n\n\t \n\n\tstrscpy(card->shortname, \"SAA7134\", sizeof(card->shortname));\n\tsprintf(card->longname, \"%s at 0x%lx irq %d\",\n\t\tchip->dev->name, chip->iobase, chip->irq);\n\n\tpr_info(\"%s/alsa: %s registered as card %d\\n\",\n\t\tdev->name, card->longname, index[devnum]);\n\n\tif ((err = snd_card_register(card)) == 0) {\n\t\tsnd_saa7134_cards[devnum] = card;\n\t\treturn 0;\n\t}\n\n__nodev:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n\nstatic int alsa_device_init(struct saa7134_dev *dev)\n{\n\tdev->dmasound.priv_data = dev;\n\talsa_card_saa7134_create(dev,dev->nr);\n\treturn 1;\n}\n\nstatic int alsa_device_exit(struct saa7134_dev *dev)\n{\n\tif (!snd_saa7134_cards[dev->nr])\n\t\treturn 1;\n\n\tsnd_card_free(snd_saa7134_cards[dev->nr]);\n\tsnd_saa7134_cards[dev->nr] = NULL;\n\treturn 1;\n}\n\n \n\nstatic int saa7134_alsa_init(void)\n{\n\tstruct saa7134_dev *dev;\n\n\tsaa7134_dmasound_init = alsa_device_init;\n\tsaa7134_dmasound_exit = alsa_device_exit;\n\n\tpr_info(\"saa7134 ALSA driver for DMA sound loaded\\n\");\n\n\tlist_for_each_entry(dev, &saa7134_devlist, devlist) {\n\t\tif (dev->pci->device == PCI_DEVICE_ID_PHILIPS_SAA7130)\n\t\t\tpr_info(\"%s/alsa: %s doesn't support digital audio\\n\",\n\t\t\t\tdev->name, saa7134_boards[dev->board].name);\n\t\telse\n\t\t\talsa_device_init(dev);\n\t}\n\n\tif (list_empty(&saa7134_devlist))\n\t\tpr_info(\"saa7134 ALSA: no saa7134 cards found\\n\");\n\n\treturn 0;\n\n}\n\n \n\nstatic void saa7134_alsa_exit(void)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tif (snd_saa7134_cards[idx])\n\t\t\tsnd_card_free(snd_saa7134_cards[idx]);\n\t}\n\n\tsaa7134_dmasound_init = NULL;\n\tsaa7134_dmasound_exit = NULL;\n\tpr_info(\"saa7134 ALSA driver for DMA sound unloaded\\n\");\n\n\treturn;\n}\n\n \nlate_initcall(saa7134_alsa_init);\nmodule_exit(saa7134_alsa_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ricardo Cerqueira\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}