{
  "module_name": "saa7134-core.c",
  "hash_id": "5516199a3877b7cdb4a14e24a59f7c6e37d843680fc32c2d44cf13c5b6bc6271",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-core.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/sound.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm.h>\n\nMODULE_DESCRIPTION(\"v4l2 driver module for saa7130/34 based TV cards\");\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SAA7134_VERSION);\n\n\n \n\nstatic unsigned int irq_debug;\nmodule_param(irq_debug, int, 0644);\nMODULE_PARM_DESC(irq_debug,\"enable debug messages [IRQ handler]\");\n\nstatic unsigned int core_debug;\nmodule_param(core_debug, int, 0644);\nMODULE_PARM_DESC(core_debug,\"enable debug messages [core]\");\n\nstatic unsigned int gpio_tracking;\nmodule_param(gpio_tracking, int, 0644);\nMODULE_PARM_DESC(gpio_tracking,\"enable debug messages [gpio]\");\n\nstatic unsigned int alsa = 1;\nmodule_param(alsa, int, 0644);\nMODULE_PARM_DESC(alsa,\"enable/disable ALSA DMA sound [dmasound]\");\n\nstatic unsigned int latency = UNSET;\nmodule_param(latency, int, 0444);\nMODULE_PARM_DESC(latency,\"pci latency timer\");\n\nbool saa7134_userptr;\nmodule_param(saa7134_userptr, bool, 0644);\nMODULE_PARM_DESC(saa7134_userptr, \"enable page-aligned userptr support\");\n\nstatic unsigned int video_nr[] = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int vbi_nr[]   = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int radio_nr[] = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int tuner[]    = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int card[]     = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\n\n\nmodule_param_array(video_nr, int, NULL, 0444);\nmodule_param_array(vbi_nr,   int, NULL, 0444);\nmodule_param_array(radio_nr, int, NULL, 0444);\nmodule_param_array(tuner,    int, NULL, 0444);\nmodule_param_array(card,     int, NULL, 0444);\n\nMODULE_PARM_DESC(video_nr, \"video device number\");\nMODULE_PARM_DESC(vbi_nr,   \"vbi device number\");\nMODULE_PARM_DESC(radio_nr, \"radio device number\");\nMODULE_PARM_DESC(tuner,    \"tuner type\");\nMODULE_PARM_DESC(card,     \"card type\");\n\nDEFINE_MUTEX(saa7134_devlist_lock);\nEXPORT_SYMBOL(saa7134_devlist_lock);\nLIST_HEAD(saa7134_devlist);\nEXPORT_SYMBOL(saa7134_devlist);\nstatic LIST_HEAD(mops_list);\nstatic unsigned int saa7134_devcount;\n\nint (*saa7134_dmasound_init)(struct saa7134_dev *dev);\nint (*saa7134_dmasound_exit)(struct saa7134_dev *dev);\n\n#define core_dbg(fmt, arg...) do { \\\n\tif (core_debug) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"core: \" fmt), ## arg); \\\n\t} while (0)\n\n#define irq_dbg(level, fmt, arg...)  do {\\\n\tif (irq_debug > level) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"irq: \" fmt), ## arg); \\\n\t} while (0)\n\nvoid saa7134_track_gpio(struct saa7134_dev *dev, const char *msg)\n{\n\tunsigned long mode,status;\n\n\tif (!gpio_tracking)\n\t\treturn;\n\t \n\tsaa_andorb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN,0);\n\tsaa_andorb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN,SAA7134_GPIO_GPRESCAN);\n\tmode   = saa_readl(SAA7134_GPIO_GPMODE0   >> 2) & 0xfffffff;\n\tstatus = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2) & 0xfffffff;\n\tcore_dbg(\"%s: gpio: mode=0x%07lx in=0x%07lx out=0x%07lx [%s]\\n\",\n\t       dev->name, mode, (~mode) & status, mode & status, msg);\n}\n\nvoid saa7134_set_gpio(struct saa7134_dev *dev, int bit_no, int value)\n{\n\tu32 index, bitval;\n\n\tindex = 1 << bit_no;\n\tswitch (value) {\n\tcase 0:  \n\tcase 1:\n\t\tcore_dbg(\"setting GPIO%d to static %d\\n\", bit_no, value);\n\t\t \n\t\tif (index & 0x00c00000)\n\t\t\tsaa_andorb(SAA7134_VIDEO_PORT_CTRL6, 0x0f, 0x00);\n\t\tif (value)\n\t\t\tbitval = index;\n\t\telse\n\t\t\tbitval = 0;\n\t\tsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, index, index);\n\t\tsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, index, bitval);\n\t\tbreak;\n\tcase 3:\t \n\t\tcore_dbg(\"setting GPIO%d to tristate\\n\", bit_no);\n\t\tsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, index, 0);\n\t\tbreak;\n\t}\n}\n\n \n\n\n \n \n\n#if defined(CONFIG_MODULES) && defined(MODULE)\n\nstatic void request_module_async(struct work_struct *work){\n\tstruct saa7134_dev* dev = container_of(work, struct saa7134_dev, request_module_wk);\n\tif (card_is_empress(dev))\n\t\trequest_module(\"saa7134-empress\");\n\tif (card_is_dvb(dev))\n\t\trequest_module(\"saa7134-dvb\");\n\tif (card_is_go7007(dev))\n\t\trequest_module(\"saa7134-go7007\");\n\tif (alsa) {\n\t\tif (dev->pci->device != PCI_DEVICE_ID_PHILIPS_SAA7130)\n\t\t\trequest_module(\"saa7134-alsa\");\n\t}\n}\n\nstatic void request_submodules(struct saa7134_dev *dev)\n{\n\tINIT_WORK(&dev->request_module_wk, request_module_async);\n\tschedule_work(&dev->request_module_wk);\n}\n\nstatic void flush_request_submodules(struct saa7134_dev *dev)\n{\n\tflush_work(&dev->request_module_wk);\n}\n\n#else\n#define request_submodules(dev)\n#define flush_request_submodules(dev)\n#endif  \n\n \n\n \nstatic int saa7134_buffer_pages(int size)\n{\n\tsize  = PAGE_ALIGN(size);\n\tsize += PAGE_SIZE;  \n\tsize /= 4096;\n\treturn size;\n}\n\n \nint saa7134_buffer_count(unsigned int size, unsigned int count)\n{\n\tunsigned int maxcount;\n\n\tmaxcount = 1024 / saa7134_buffer_pages(size);\n\tif (count > maxcount)\n\t\tcount = maxcount;\n\treturn count;\n}\n\nint saa7134_buffer_startpage(struct saa7134_buf *buf)\n{\n\treturn saa7134_buffer_pages(vb2_plane_size(&buf->vb2.vb2_buf, 0))\n\t\t\t* buf->vb2.vb2_buf.index;\n}\n\nunsigned long saa7134_buffer_base(struct saa7134_buf *buf)\n{\n\tunsigned long base;\n\tstruct sg_table *dma = vb2_dma_sg_plane_desc(&buf->vb2.vb2_buf, 0);\n\n\tbase  = saa7134_buffer_startpage(buf) * 4096;\n\tbase += dma->sgl[0].offset;\n\treturn base;\n}\n\n \n\nint saa7134_pgtable_alloc(struct pci_dev *pci, struct saa7134_pgtable *pt)\n{\n\t__le32       *cpu;\n\tdma_addr_t   dma_addr = 0;\n\n\tcpu = dma_alloc_coherent(&pci->dev, SAA7134_PGTABLE_SIZE, &dma_addr,\n\t\t\t\t GFP_KERNEL);\n\tif (NULL == cpu)\n\t\treturn -ENOMEM;\n\tpt->size = SAA7134_PGTABLE_SIZE;\n\tpt->cpu  = cpu;\n\tpt->dma  = dma_addr;\n\treturn 0;\n}\n\nint saa7134_pgtable_build(struct pci_dev *pci, struct saa7134_pgtable *pt,\n\t\t\t  struct scatterlist *list, unsigned int length,\n\t\t\t  unsigned int startpage)\n{\n\t__le32        *ptr;\n\tunsigned int  i, p;\n\n\tBUG_ON(NULL == pt || NULL == pt->cpu);\n\n\tptr = pt->cpu + startpage;\n\tfor (i = 0; i < length; i++, list = sg_next(list)) {\n\t\tfor (p = 0; p * 4096 < sg_dma_len(list); p++, ptr++)\n\t\t\t*ptr = cpu_to_le32(sg_dma_address(list) +\n\t\t\t\t\t\tlist->offset + p * 4096);\n\t}\n\treturn 0;\n}\n\nvoid saa7134_pgtable_free(struct pci_dev *pci, struct saa7134_pgtable *pt)\n{\n\tif (NULL == pt->cpu)\n\t\treturn;\n\tdma_free_coherent(&pci->dev, pt->size, pt->cpu, pt->dma);\n\tpt->cpu = NULL;\n}\n\n \n\nint saa7134_buffer_queue(struct saa7134_dev *dev,\n\t\t\t struct saa7134_dmaqueue *q,\n\t\t\t struct saa7134_buf *buf)\n{\n\tstruct saa7134_buf *next = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tcore_dbg(\"buffer_queue %p\\n\", buf);\n\tif (NULL == q->curr) {\n\t\tif (!q->need_two) {\n\t\t\tq->curr = buf;\n\t\t\tbuf->activate(dev, buf, NULL);\n\t\t} else if (list_empty(&q->queue)) {\n\t\t\tlist_add_tail(&buf->entry, &q->queue);\n\t\t} else {\n\t\t\tnext = list_entry(q->queue.next, struct saa7134_buf,\n\t\t\t\t\t  entry);\n\t\t\tq->curr = buf;\n\t\t\tbuf->activate(dev, buf, next);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&buf->entry, &q->queue);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\treturn 0;\n}\n\nvoid saa7134_buffer_finish(struct saa7134_dev *dev,\n\t\t\t   struct saa7134_dmaqueue *q,\n\t\t\t   unsigned int state)\n{\n\tcore_dbg(\"buffer_finish %p\\n\", q->curr);\n\n\t \n\tq->curr->vb2.vb2_buf.timestamp = ktime_get_ns();\n\tq->curr->vb2.sequence = q->seq_nr++;\n\tvb2_buffer_done(&q->curr->vb2.vb2_buf, state);\n\tq->curr = NULL;\n}\n\nvoid saa7134_buffer_next(struct saa7134_dev *dev,\n\t\t\t struct saa7134_dmaqueue *q)\n{\n\tstruct saa7134_buf *buf,*next = NULL;\n\n\tassert_spin_locked(&dev->slock);\n\tBUG_ON(NULL != q->curr);\n\n\tif (!list_empty(&q->queue)) {\n\t\t \n\t\tbuf = list_entry(q->queue.next, struct saa7134_buf, entry);\n\t\tcore_dbg(\"buffer_next %p [prev=%p/next=%p]\\n\",\n\t\t\tbuf, q->queue.prev, q->queue.next);\n\t\tlist_del(&buf->entry);\n\t\tif (!list_empty(&q->queue))\n\t\t\tnext = list_entry(q->queue.next, struct saa7134_buf, entry);\n\t\tq->curr = buf;\n\t\tbuf->activate(dev, buf, next);\n\t\tcore_dbg(\"buffer_next #2 prev=%p/next=%p\\n\",\n\t\t\tq->queue.prev, q->queue.next);\n\t} else {\n\t\t \n\t\tcore_dbg(\"buffer_next %p\\n\", NULL);\n\t\tsaa7134_set_dmabits(dev);\n\t\tdel_timer(&q->timeout);\n\t}\n}\n\nvoid saa7134_buffer_timeout(struct timer_list *t)\n{\n\tstruct saa7134_dmaqueue *q = from_timer(q, t, timeout);\n\tstruct saa7134_dev *dev = q->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\t \n\tsaa_writeb(SAA7134_REGION_ENABLE, 0x00);\n\tsaa_writeb(SAA7134_REGION_ENABLE, 0x80);\n\tsaa_writeb(SAA7134_REGION_ENABLE, 0x00);\n\n\t \n\tif (q->curr) {\n\t\tcore_dbg(\"timeout on %p\\n\", q->curr);\n\t\tsaa7134_buffer_finish(dev, q, VB2_BUF_STATE_ERROR);\n\t}\n\tsaa7134_buffer_next(dev, q);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nvoid saa7134_stop_streaming(struct saa7134_dev *dev, struct saa7134_dmaqueue *q)\n{\n\tunsigned long flags;\n\tstruct list_head *pos, *n;\n\tstruct saa7134_buf *tmp;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tlist_for_each_safe(pos, n, &q->queue) {\n\t\ttmp = list_entry(pos, struct saa7134_buf, entry);\n\t\tvb2_buffer_done(&tmp->vb2.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tlist_del(pos);\n\t\ttmp = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\tsaa7134_buffer_timeout(&q->timeout);  \n}\nEXPORT_SYMBOL_GPL(saa7134_stop_streaming);\n\n \n\nint saa7134_set_dmabits(struct saa7134_dev *dev)\n{\n\tu32 split, task=0, ctrl=0, irq=0;\n\tenum v4l2_field cap = V4L2_FIELD_ANY;\n\tenum v4l2_field ov  = V4L2_FIELD_ANY;\n\n\tassert_spin_locked(&dev->slock);\n\n\tif (dev->insuspend)\n\t\treturn 0;\n\n\t \n\tif (dev->video_q.curr) {\n\t\ttask |= 0x01;\n\t\tctrl |= SAA7134_MAIN_CTRL_TE0;\n\t\tirq  |= SAA7134_IRQ1_INTE_RA0_1 |\n\t\t\tSAA7134_IRQ1_INTE_RA0_0;\n\t\tcap = dev->field;\n\t}\n\n\t \n\tif (dev->video_q.curr && dev->fmt->planar) {\n\t\tctrl |= SAA7134_MAIN_CTRL_TE4 |\n\t\t\tSAA7134_MAIN_CTRL_TE5;\n\t}\n\n\t \n\tif (dev->vbi_q.curr) {\n\t\ttask |= 0x22;\n\t\tctrl |= SAA7134_MAIN_CTRL_TE2 |\n\t\t\tSAA7134_MAIN_CTRL_TE3;\n\t\tirq  |= SAA7134_IRQ1_INTE_RA0_7 |\n\t\t\tSAA7134_IRQ1_INTE_RA0_6 |\n\t\t\tSAA7134_IRQ1_INTE_RA0_5 |\n\t\t\tSAA7134_IRQ1_INTE_RA0_4;\n\t}\n\n\t \n\tif (dev->dmasound.dma_running) {\n\t\tctrl |= SAA7134_MAIN_CTRL_TE6;\n\t\tirq  |= SAA7134_IRQ1_INTE_RA3_1 |\n\t\t\tSAA7134_IRQ1_INTE_RA3_0;\n\t}\n\n\t \n\tif (dev->ts_q.curr) {\n\t\tctrl |= SAA7134_MAIN_CTRL_TE5;\n\t\tirq  |= SAA7134_IRQ1_INTE_RA2_1 |\n\t\t\tSAA7134_IRQ1_INTE_RA2_0;\n\t}\n\n\t \n\tif (V4L2_FIELD_HAS_BOTH(cap) || V4L2_FIELD_HAS_BOTH(ov) || cap == ov) {\n\t\t \n\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0d);\n\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0d);\n\t\tsaa_writeb(SAA7134_FIELD_HANDLING(TASK_A),  0x02);\n\t\tsaa_writeb(SAA7134_FIELD_HANDLING(TASK_B),  0x02);\n\t\tsplit = 0;\n\t} else {\n\t\t \n\t\tif (V4L2_FIELD_TOP == cap) {\n\t\t\t \n\t\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0d);\n\t\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0e);\n\t\t} else {\n\t\t\t \n\t\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_A), 0x0e);\n\t\t\tsaa_writeb(SAA7134_TASK_CONDITIONS(TASK_B), 0x0d);\n\t\t}\n\t\tsaa_writeb(SAA7134_FIELD_HANDLING(TASK_A),  0x01);\n\t\tsaa_writeb(SAA7134_FIELD_HANDLING(TASK_B),  0x01);\n\t\tsplit = 1;\n\t}\n\n\t \n\tsaa_writeb(SAA7134_REGION_ENABLE, task);\n\tsaa_writel(SAA7134_IRQ1,          irq);\n\tsaa_andorl(SAA7134_MAIN_CTRL,\n\t\t   SAA7134_MAIN_CTRL_TE0 |\n\t\t   SAA7134_MAIN_CTRL_TE1 |\n\t\t   SAA7134_MAIN_CTRL_TE2 |\n\t\t   SAA7134_MAIN_CTRL_TE3 |\n\t\t   SAA7134_MAIN_CTRL_TE4 |\n\t\t   SAA7134_MAIN_CTRL_TE5 |\n\t\t   SAA7134_MAIN_CTRL_TE6,\n\t\t   ctrl);\n\tcore_dbg(\"dmabits: task=0x%02x ctrl=0x%02x irq=0x%x split=%s\\n\",\n\t\ttask, ctrl, irq, split ? \"no\" : \"yes\");\n\n\treturn 0;\n}\n\n \n \n\nstatic char *irqbits[] = {\n\t\"DONE_RA0\", \"DONE_RA1\", \"DONE_RA2\", \"DONE_RA3\",\n\t\"AR\", \"PE\", \"PWR_ON\", \"RDCAP\", \"INTL\", \"FIDT\", \"MMC\",\n\t\"TRIG_ERR\", \"CONF_ERR\", \"LOAD_ERR\",\n\t\"GPIO16\", \"GPIO18\", \"GPIO22\", \"GPIO23\"\n};\n#define IRQBITS ARRAY_SIZE(irqbits)\n\nstatic void print_irqstatus(struct saa7134_dev *dev, int loop,\n\t\t\t    unsigned long report, unsigned long status)\n{\n\tunsigned int i;\n\n\tirq_dbg(1, \"[%d,%ld]: r=0x%lx s=0x%02lx\",\n\t\tloop, jiffies, report, status);\n\tfor (i = 0; i < IRQBITS; i++) {\n\t\tif (!(report & (1 << i)))\n\t\t\tcontinue;\n\t\tpr_cont(\" %s\", irqbits[i]);\n\t}\n\tif (report & SAA7134_IRQ_REPORT_DONE_RA0) {\n\t\tpr_cont(\" | RA0=%s,%s,%s,%ld\",\n\t\t\t(status & 0x40) ? \"vbi\"  : \"video\",\n\t\t\t(status & 0x20) ? \"b\"    : \"a\",\n\t\t\t(status & 0x10) ? \"odd\"  : \"even\",\n\t\t\t(status & 0x0f));\n\t}\n\tpr_cont(\"\\n\");\n}\n\nstatic irqreturn_t saa7134_irq(int irq, void *dev_id)\n{\n\tstruct saa7134_dev *dev = (struct saa7134_dev*) dev_id;\n\tunsigned long report,status;\n\tint loop, handled = 0;\n\n\tif (dev->insuspend)\n\t\tgoto out;\n\n\tfor (loop = 0; loop < 10; loop++) {\n\t\treport = saa_readl(SAA7134_IRQ_REPORT);\n\t\tstatus = saa_readl(SAA7134_IRQ_STATUS);\n\n\t\t \n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA3) &&\n\t\t\t(dev->dmasound.priv_data != NULL) )\n\t\t{\n\t\t\tirq_dbg(2, \"preserving DMA sound interrupt\\n\");\n\t\t\treport &= ~SAA7134_IRQ_REPORT_DONE_RA3;\n\t\t}\n\n\t\tif (0 == report) {\n\t\t\tirq_dbg(2, \"no (more) work\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\thandled = 1;\n\t\tsaa_writel(SAA7134_IRQ_REPORT,report);\n\t\tif (irq_debug)\n\t\t\tprint_irqstatus(dev,loop,report,status);\n\n\n\t\tif ((report & SAA7134_IRQ_REPORT_RDCAP) ||\n\t\t\t(report & SAA7134_IRQ_REPORT_INTL))\n\t\t\t\tsaa7134_irq_video_signalchange(dev);\n\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\n\t\t    (status & 0x60) == 0)\n\t\t\tsaa7134_irq_video_done(dev,status);\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&\n\t\t    (status & 0x40) == 0x40)\n\t\t\tsaa7134_irq_vbi_done(dev,status);\n\n\t\tif ((report & SAA7134_IRQ_REPORT_DONE_RA2) &&\n\t\t    card_has_mpeg(dev)) {\n\t\t\tif (dev->mops->irq_ts_done != NULL)\n\t\t\t\tdev->mops->irq_ts_done(dev, status);\n\t\t\telse\n\t\t\t\tsaa7134_irq_ts_done(dev, status);\n\t\t}\n\n\t\tif (report & SAA7134_IRQ_REPORT_GPIO16) {\n\t\t\tswitch (dev->has_remote) {\n\t\t\t\tcase SAA7134_REMOTE_GPIO:\n\t\t\t\t\tif (!dev->remote)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif  (dev->remote->mask_keydown & 0x10000) {\n\t\t\t\t\t\tsaa7134_input_irq(dev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SAA7134_REMOTE_I2C:\n\t\t\t\t\tbreak;\t\t\t \n\n\t\t\t\tdefault:\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (report & SAA7134_IRQ_REPORT_GPIO18) {\n\t\t\tswitch (dev->has_remote) {\n\t\t\t\tcase SAA7134_REMOTE_GPIO:\n\t\t\t\t\tif (!dev->remote)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ((dev->remote->mask_keydown & 0x40000) ||\n\t\t\t\t\t    (dev->remote->mask_keyup & 0x40000)) {\n\t\t\t\t\t\tsaa7134_input_irq(dev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SAA7134_REMOTE_I2C:\n\t\t\t\t\tbreak;\t\t\t \n\n\t\t\t\tdefault:\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (10 == loop) {\n\t\tprint_irqstatus(dev,loop,report,status);\n\t\tif (report & SAA7134_IRQ_REPORT_PE) {\n\t\t\t \n\t\t\tpr_warn(\"%s/irq: looping -- clearing PE (parity error!) enable bit\\n\",\n\t\t\t\tdev->name);\n\t\t\tsaa_clearl(SAA7134_IRQ2,SAA7134_IRQ2_INTE_PE);\n\t\t} else if (report & SAA7134_IRQ_REPORT_GPIO16) {\n\t\t\t \n\t\t\tpr_warn(\"%s/irq: looping -- clearing GPIO16 enable bit\\n\",\n\t\t\t\tdev->name);\n\t\t\tsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO16_P);\n\t\t\tsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO16_N);\n\t\t} else if (report & SAA7134_IRQ_REPORT_GPIO18) {\n\t\t\t \n\t\t\tpr_warn(\"%s/irq: looping -- clearing GPIO18 enable bit\\n\",\n\t\t\t\tdev->name);\n\t\t\tsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO18_P);\n\t\t\tsaa_clearl(SAA7134_IRQ2, SAA7134_IRQ2_INTE_GPIO18_N);\n\t\t} else {\n\t\t\t \n\t\t\tpr_warn(\"%s/irq: looping -- clearing all enable bits\\n\",\n\t\t\t\tdev->name);\n\t\t\tsaa_writel(SAA7134_IRQ1,0);\n\t\t\tsaa_writel(SAA7134_IRQ2,0);\n\t\t}\n\t}\n\n out:\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\n \n\nstatic int saa7134_hw_enable1(struct saa7134_dev *dev)\n{\n\t \n\tsaa_writel(SAA7134_FIFO_SIZE, 0x08070503);\n\tsaa_writel(SAA7134_THRESHOULD, 0x02020202);\n\n\t \n\tsaa_writel(SAA7134_MAIN_CTRL,\n\t\t\tSAA7134_MAIN_CTRL_VPLLE |\n\t\t\tSAA7134_MAIN_CTRL_APLLE |\n\t\t\tSAA7134_MAIN_CTRL_EXOSC |\n\t\t\tSAA7134_MAIN_CTRL_EVFE1 |\n\t\t\tSAA7134_MAIN_CTRL_EVFE2 |\n\t\t\tSAA7134_MAIN_CTRL_ESFE  |\n\t\t\tSAA7134_MAIN_CTRL_EBDAC);\n\n\t \n\n\t \n\tsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\n\n\t \n\tsaa_writeb(SAA7134_SOURCE_TIMING2, 0x20);\n\n\treturn 0;\n}\n\nstatic int saa7134_hwinit1(struct saa7134_dev *dev)\n{\n\tcore_dbg(\"hwinit1\\n\");\n\n\tsaa_writel(SAA7134_IRQ1, 0);\n\tsaa_writel(SAA7134_IRQ2, 0);\n\n\t \n\tsaa_writel(SAA7134_IRQ_REPORT, saa_readl(SAA7134_IRQ_REPORT));\n\n\tmutex_init(&dev->lock);\n\tspin_lock_init(&dev->slock);\n\n\tsaa7134_track_gpio(dev,\"pre-init\");\n\tsaa7134_video_init1(dev);\n\tsaa7134_vbi_init1(dev);\n\tif (card_has_mpeg(dev))\n\t\tsaa7134_ts_init1(dev);\n\tsaa7134_input_init1(dev);\n\n\tsaa7134_hw_enable1(dev);\n\n\treturn 0;\n}\n\n \nstatic int saa7134_hw_enable2(struct saa7134_dev *dev)\n{\n\n\tunsigned int irq2_mask;\n\n\t \n\tirq2_mask =\n\t\tSAA7134_IRQ2_INTE_DEC3    |\n\t\tSAA7134_IRQ2_INTE_DEC2    |\n\t\tSAA7134_IRQ2_INTE_DEC1    |\n\t\tSAA7134_IRQ2_INTE_DEC0    |\n\t\tSAA7134_IRQ2_INTE_PE      |\n\t\tSAA7134_IRQ2_INTE_AR;\n\n\tif (dev->has_remote == SAA7134_REMOTE_GPIO && dev->remote) {\n\t\tif (dev->remote->mask_keydown & 0x10000)\n\t\t\tirq2_mask |= SAA7134_IRQ2_INTE_GPIO16_N;\n\t\telse {\t\t \n\t\t\tif (dev->remote->mask_keydown & 0x40000)\n\t\t\t\tirq2_mask |= SAA7134_IRQ2_INTE_GPIO18_P;\n\t\t\tif (dev->remote->mask_keyup & 0x40000)\n\t\t\t\tirq2_mask |= SAA7134_IRQ2_INTE_GPIO18_N;\n\t\t}\n\t}\n\n\tif (dev->has_remote == SAA7134_REMOTE_I2C) {\n\t\trequest_module(\"ir-kbd-i2c\");\n\t}\n\n\tsaa_writel(SAA7134_IRQ1, 0);\n\tsaa_writel(SAA7134_IRQ2, irq2_mask);\n\n\treturn 0;\n}\n\nstatic int saa7134_hwinit2(struct saa7134_dev *dev)\n{\n\n\tcore_dbg(\"hwinit2\\n\");\n\n\tsaa7134_video_init2(dev);\n\tsaa7134_tvaudio_init2(dev);\n\n\tsaa7134_hw_enable2(dev);\n\n\treturn 0;\n}\n\n\n \nstatic int saa7134_hwfini(struct saa7134_dev *dev)\n{\n\tcore_dbg(\"hwfini\\n\");\n\n\tif (card_has_mpeg(dev))\n\t\tsaa7134_ts_fini(dev);\n\tsaa7134_input_fini(dev);\n\tsaa7134_vbi_fini(dev);\n\tsaa7134_tvaudio_fini(dev);\n\tsaa7134_video_fini(dev);\n\treturn 0;\n}\n\nstatic void must_configure_manually(int has_eeprom)\n{\n\tunsigned int i,p;\n\n\tif (!has_eeprom)\n\t\tpr_warn(\"saa7134: <rant>\\n\"\n\t\t\t\"saa7134:  Congratulations!  Your TV card vendor saved a few\\n\"\n\t\t\t\"saa7134:  cents for a eeprom, thus your pci board has no\\n\"\n\t\t\t\"saa7134:  subsystem ID and I can't identify it automatically\\n\"\n\t\t\t\"saa7134: </rant>\\n\"\n\t\t\t\"saa7134: I feel better now.  Ok, here are the good news:\\n\"\n\t\t\t\"saa7134: You can use the card=<nr> insmod option to specify\\n\"\n\t\t\t\"saa7134: which board do you have.  The list:\\n\");\n\telse\n\t\tpr_warn(\"saa7134: Board is currently unknown. You might try to use the card=<nr>\\n\"\n\t\t\t\"saa7134: insmod option to specify which board do you have, but this is\\n\"\n\t\t\t\"saa7134: somewhat risky, as might damage your card. It is better to ask\\n\"\n\t\t\t\"saa7134: for support at linux-media@vger.kernel.org.\\n\"\n\t\t\t\"saa7134: The supported cards are:\\n\");\n\n\tfor (i = 0; i < saa7134_bcount; i++) {\n\t\tpr_warn(\"saa7134:   card=%d -> %-40.40s\",\n\t\t       i,saa7134_boards[i].name);\n\t\tfor (p = 0; saa7134_pci_tbl[p].driver_data; p++) {\n\t\t\tif (saa7134_pci_tbl[p].driver_data != i)\n\t\t\t\tcontinue;\n\t\t\tpr_cont(\" %04x:%04x\",\n\t\t\t       saa7134_pci_tbl[p].subvendor,\n\t\t\t       saa7134_pci_tbl[p].subdevice);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}\n\nstatic void saa7134_unregister_media_device(struct saa7134_dev *dev)\n{\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tif (!dev->media_dev)\n\t\treturn;\n\tmedia_device_unregister(dev->media_dev);\n\tmedia_device_cleanup(dev->media_dev);\n\tkfree(dev->media_dev);\n\tdev->media_dev = NULL;\n#endif\n}\n\nstatic void saa7134_media_release(struct saa7134_dev *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint i;\n\n\tfor (i = 0; i < SAA7134_INPUT_MAX + 1; i++)\n\t\tmedia_device_unregister_entity(&dev->input_ent[i]);\n#endif\n}\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\nstatic void saa7134_create_entities(struct saa7134_dev *dev)\n{\n\tint ret, i;\n\tstruct media_entity *entity;\n\tstruct media_entity *decoder = NULL;\n\n\t \n\tmedia_device_for_each_entity(entity, dev->media_dev) {\n\t\tif (entity->function == MEDIA_ENT_F_ATV_DECODER) {\n\t\t\tdecoder = entity;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!decoder) {\n\t\tdev->demod.name = \"saa713x\";\n\t\tdev->demod_pad[SAA7134_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\t\tdev->demod_pad[SAA7134_PAD_IF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tdev->demod_pad[SAA7134_PAD_VID_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tdev->demod_pad[SAA7134_PAD_VID_OUT].sig_type = PAD_SIGNAL_DV;\n\t\tdev->demod.function = MEDIA_ENT_F_ATV_DECODER;\n\n\t\tret = media_entity_pads_init(&dev->demod, SAA7134_NUM_PADS,\n\t\t\t\t\t     dev->demod_pad);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to initialize demod pad!\\n\");\n\n\t\tret = media_device_register_entity(dev->media_dev, &dev->demod);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to register demod entity!\\n\");\n\n\t\tdev->decoder = &dev->demod;\n\t} else {\n\t\tdev->decoder = decoder;\n\t}\n\n\t \n\tdev->video_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->video_dev->entity, 1,\n\t\t\t\t     &dev->video_pad);\n\tif (ret < 0)\n\t\tpr_err(\"failed to initialize video media entity!\\n\");\n\n\tdev->vbi_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->vbi_dev->entity, 1,\n\t\t\t\t\t&dev->vbi_pad);\n\tif (ret < 0)\n\t\tpr_err(\"failed to initialize vbi media entity!\\n\");\n\n\t \n\tfor (i = 0; i < SAA7134_INPUT_MAX; i++) {\n\t\tstruct media_entity *ent = &dev->input_ent[i];\n\t\tstruct saa7134_input *in = &card_in(dev, i);\n\n\t\tif (in->type == SAA7134_NO_INPUT)\n\t\t\tbreak;\n\n\t\t \n\t\tif (in->type == SAA7134_INPUT_COMPOSITE_OVER_SVIDEO)\n\t\t\tcontinue;\n\n\t\tent->name = saa7134_input_name[in->type];\n\t\tent->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tdev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tswitch (in->type) {\n\t\tcase SAA7134_INPUT_COMPOSITE:\n\t\tcase SAA7134_INPUT_COMPOSITE0:\n\t\tcase SAA7134_INPUT_COMPOSITE1:\n\t\tcase SAA7134_INPUT_COMPOSITE2:\n\t\tcase SAA7134_INPUT_COMPOSITE3:\n\t\tcase SAA7134_INPUT_COMPOSITE4:\n\t\t\tent->function = MEDIA_ENT_F_CONN_COMPOSITE;\n\t\t\tbreak;\n\t\tcase SAA7134_INPUT_SVIDEO:\n\t\tcase SAA7134_INPUT_SVIDEO0:\n\t\tcase SAA7134_INPUT_SVIDEO1:\n\t\t\tent->function = MEDIA_ENT_F_CONN_SVIDEO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tent->function = MEDIA_ENT_F_CONN_RF;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to initialize input pad[%d]!\\n\", i);\n\n\t\tret = media_device_register_entity(dev->media_dev, ent);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to register input entity %d!\\n\", i);\n\t}\n\n\t \n\tif (card_has_radio(dev)) {\n\t\tstruct saa7134_input *in = &saa7134_boards[dev->board].radio;\n\t\tstruct media_entity *ent = &dev->input_ent[i];\n\n\t\tent->name = saa7134_input_name[in->type];\n\t\tent->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tdev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\n\t\tent->function = MEDIA_ENT_F_CONN_RF;\n\n\t\tret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to initialize input pad[%d]!\\n\", i);\n\n\t\tret = media_device_register_entity(dev->media_dev, ent);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to register input entity %d!\\n\", i);\n\t}\n}\n#endif\n\nstatic struct video_device *vdev_init(struct saa7134_dev *dev,\n\t\t\t\t      struct video_device *template,\n\t\t\t\t      char *type)\n{\n\tstruct video_device *vfd;\n\n\tvfd = video_device_alloc();\n\tif (NULL == vfd)\n\t\treturn NULL;\n\t*vfd = *template;\n\tvfd->v4l2_dev  = &dev->v4l2_dev;\n\tvfd->release = video_device_release;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\",\n\t\t dev->name, type, saa7134_boards[dev->board].name);\n\tvideo_set_drvdata(vfd, dev);\n\treturn vfd;\n}\n\nstatic void saa7134_unregister_video(struct saa7134_dev *dev)\n{\n\tsaa7134_media_release(dev);\n\n\tif (dev->video_dev) {\n\t\tif (video_is_registered(dev->video_dev))\n\t\t\tvb2_video_unregister_device(dev->video_dev);\n\t\telse\n\t\t\tvideo_device_release(dev->video_dev);\n\t\tdev->video_dev = NULL;\n\t}\n\tif (dev->vbi_dev) {\n\t\tif (video_is_registered(dev->vbi_dev))\n\t\t\tvb2_video_unregister_device(dev->vbi_dev);\n\t\telse\n\t\t\tvideo_device_release(dev->vbi_dev);\n\t\tdev->vbi_dev = NULL;\n\t}\n\tif (dev->radio_dev) {\n\t\tif (video_is_registered(dev->radio_dev))\n\t\t\tvideo_unregister_device(dev->radio_dev);\n\t\telse\n\t\t\tvideo_device_release(dev->radio_dev);\n\t\tdev->radio_dev = NULL;\n\t}\n}\n\nstatic void mpeg_ops_attach(struct saa7134_mpeg_ops *ops,\n\t\t\t    struct saa7134_dev *dev)\n{\n\tint err;\n\n\tif (NULL != dev->mops)\n\t\treturn;\n\tif (saa7134_boards[dev->board].mpeg != ops->type)\n\t\treturn;\n\terr = ops->init(dev);\n\tif (0 != err)\n\t\treturn;\n\tdev->mops = ops;\n}\n\nstatic void mpeg_ops_detach(struct saa7134_mpeg_ops *ops,\n\t\t\t    struct saa7134_dev *dev)\n{\n\tif (NULL == dev->mops)\n\t\treturn;\n\tif (dev->mops != ops)\n\t\treturn;\n\tdev->mops->fini(dev);\n\tdev->mops = NULL;\n}\n\nstatic int saa7134_initdev(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct saa7134_dev *dev;\n\tstruct saa7134_mpeg_ops *mops;\n\tint err;\n\n\tif (saa7134_devcount == SAA7134_MAXBOARDS)\n\t\treturn -ENOMEM;\n\n\tdev = kzalloc(sizeof(*dev),GFP_KERNEL);\n\tif (NULL == dev)\n\t\treturn -ENOMEM;\n\n\tdev->nr = saa7134_devcount;\n\tsprintf(dev->name, \"saa%x[%d]\", pci_dev->device, dev->nr);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->media_dev = kzalloc(sizeof(*dev->media_dev), GFP_KERNEL);\n\tif (!dev->media_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\tmedia_device_pci_init(dev->media_dev, pci_dev, dev->name);\n\tdev->v4l2_dev.mdev = dev->media_dev;\n#endif\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto err_v4l2_unregister;\n\t}\n\n\t \n\tif (pci_pci_problems) {\n\t\tif (pci_pci_problems & PCIPCI_TRITON)\n\t\t\tpr_info(\"%s: quirk: PCIPCI_TRITON\\n\", dev->name);\n\t\tif (pci_pci_problems & PCIPCI_NATOMA)\n\t\t\tpr_info(\"%s: quirk: PCIPCI_NATOMA\\n\", dev->name);\n\t\tif (pci_pci_problems & PCIPCI_VIAETBF)\n\t\t\tpr_info(\"%s: quirk: PCIPCI_VIAETBF\\n\", dev->name);\n\t\tif (pci_pci_problems & PCIPCI_VSFX)\n\t\t\tpr_info(\"%s: quirk: PCIPCI_VSFX\\n\", dev->name);\n#ifdef PCIPCI_ALIMAGIK\n\t\tif (pci_pci_problems & PCIPCI_ALIMAGIK) {\n\t\t\tpr_info(\"%s: quirk: PCIPCI_ALIMAGIK -- latency fixup\\n\",\n\t\t\t       dev->name);\n\t\t\tlatency = 0x0A;\n\t\t}\n#endif\n\t}\n\tif (UNSET != latency) {\n\t\tpr_info(\"%s: setting pci latency timer to %d\\n\",\n\t\t       dev->name,latency);\n\t\tpci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\n\t}\n\n\t \n\tdev->pci_rev = pci_dev->revision;\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tpr_info(\"%s: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tdev->name, pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t\tdev->pci_lat,\n\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tpr_warn(\"%s: Oops: no 32bit PCI DMA ???\\n\", dev->name);\n\t\tgoto err_v4l2_unregister;\n\t}\n\n\t \n\tdev->board = pci_id->driver_data;\n\tif ((unsigned)card[dev->nr] < saa7134_bcount)\n\t\tdev->board = card[dev->nr];\n\tif (SAA7134_BOARD_UNKNOWN == dev->board)\n\t\tmust_configure_manually(0);\n\telse if (SAA7134_BOARD_NOAUTO == dev->board) {\n\t\tmust_configure_manually(1);\n\t\tdev->board = SAA7134_BOARD_UNKNOWN;\n\t}\n\tdev->autodetected = card[dev->nr] != dev->board;\n\tdev->tuner_type = saa7134_boards[dev->board].tuner_type;\n\tdev->tuner_addr = saa7134_boards[dev->board].tuner_addr;\n\tdev->radio_type = saa7134_boards[dev->board].radio_type;\n\tdev->radio_addr = saa7134_boards[dev->board].radio_addr;\n\tdev->tda9887_conf = saa7134_boards[dev->board].tda9887_conf;\n\tif (UNSET != tuner[dev->nr])\n\t\tdev->tuner_type = tuner[dev->nr];\n\tpr_info(\"%s: subsystem: %04x:%04x, board: %s [card=%d,%s]\\n\",\n\t\tdev->name,pci_dev->subsystem_vendor,\n\t\tpci_dev->subsystem_device,saa7134_boards[dev->board].name,\n\t\tdev->board, dev->autodetected ?\n\t\t\"autodetected\" : \"insmod option\");\n\n\t \n\tif (!request_mem_region(pci_resource_start(pci_dev,0),\n\t\t\t\tpci_resource_len(pci_dev,0),\n\t\t\t\tdev->name)) {\n\t\terr = -EBUSY;\n\t\tpr_err(\"%s: can't get MMIO memory @ 0x%llx\\n\",\n\t\t       dev->name,(unsigned long long)pci_resource_start(pci_dev,0));\n\t\tgoto err_v4l2_unregister;\n\t}\n\tdev->lmmio = ioremap(pci_resource_start(pci_dev, 0),\n\t\t\t     pci_resource_len(pci_dev, 0));\n\tdev->bmmio = (__u8 __iomem *)dev->lmmio;\n\tif (NULL == dev->lmmio) {\n\t\terr = -EIO;\n\t\tpr_err(\"%s: can't ioremap() MMIO memory\\n\",\n\t\t       dev->name);\n\t\tgoto err_release_mem_reg;\n\t}\n\n\t \n\tsaa7134_board_init1(dev);\n\tsaa7134_hwinit1(dev);\n\n\t \n\terr = request_irq(pci_dev->irq, saa7134_irq,\n\t\t\t  IRQF_SHARED, dev->name, dev);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't get IRQ %d\\n\",\n\t\t       dev->name,pci_dev->irq);\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tmsleep(100);\n\tsaa7134_i2c_register(dev);\n\tsaa7134_board_init2(dev);\n\n\tsaa7134_hwinit2(dev);\n\n\t \n\tif (card_is_empress(dev)) {\n\t\tdev->empress_sd =\n\t\t\tv4l2_i2c_new_subdev(&dev->v4l2_dev, &dev->i2c_adap,\n\t\t\t\t\"saa6752hs\",\n\t\t\t\tsaa7134_boards[dev->board].empress_addr, NULL);\n\n\t\tif (dev->empress_sd)\n\t\t\tdev->empress_sd->grp_id = GRP_EMPRESS;\n\t}\n\n\tif (saa7134_boards[dev->board].rds_addr) {\n\t\tstruct v4l2_subdev *sd;\n\n\t\tsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\n\t\t\t\t&dev->i2c_adap, \"saa6588\",\n\t\t\t\t0, I2C_ADDRS(saa7134_boards[dev->board].rds_addr));\n\t\tif (sd) {\n\t\t\tpr_info(\"%s: found RDS decoder\\n\", dev->name);\n\t\t\tdev->has_rds = 1;\n\t\t}\n\t}\n\n\tmutex_lock(&saa7134_devlist_lock);\n\tlist_for_each_entry(mops, &mops_list, next)\n\t\tmpeg_ops_attach(mops, dev);\n\tlist_add_tail(&dev->devlist, &saa7134_devlist);\n\tmutex_unlock(&saa7134_devlist_lock);\n\n\t \n\tsaa7134_irq_video_signalchange(dev);\n\n\tif (TUNER_ABSENT != dev->tuner_type)\n\t\tsaa_call_all(dev, core, s_power, 0);\n\n\t \n\tdev->video_dev = vdev_init(dev,&saa7134_video_template,\"video\");\n\tdev->video_dev->ctrl_handler = &dev->ctrl_handler;\n\tdev->video_dev->lock = &dev->lock;\n\tdev->video_dev->queue = &dev->video_vbq;\n\tdev->video_dev->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t      V4L2_CAP_VIDEO_CAPTURE;\n\tif (dev->tuner_type != TUNER_ABSENT && dev->tuner_type != UNSET)\n\t\tdev->video_dev->device_caps |= V4L2_CAP_TUNER;\n\n\terr = video_register_device(dev->video_dev,VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[dev->nr]);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register video device\\n\",\n\t\t       dev->name);\n\t\tgoto err_unregister_video;\n\t}\n\tpr_info(\"%s: registered device %s [v4l2]\\n\",\n\t       dev->name, video_device_node_name(dev->video_dev));\n\n\tdev->vbi_dev = vdev_init(dev, &saa7134_video_template, \"vbi\");\n\tdev->vbi_dev->ctrl_handler = &dev->ctrl_handler;\n\tdev->vbi_dev->lock = &dev->lock;\n\tdev->vbi_dev->queue = &dev->vbi_vbq;\n\tdev->vbi_dev->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t    V4L2_CAP_VBI_CAPTURE;\n\tif (dev->tuner_type != TUNER_ABSENT && dev->tuner_type != UNSET)\n\t\tdev->vbi_dev->device_caps |= V4L2_CAP_TUNER;\n\n\terr = video_register_device(dev->vbi_dev,VFL_TYPE_VBI,\n\t\t\t\t    vbi_nr[dev->nr]);\n\tif (err < 0)\n\t\tgoto err_unregister_video;\n\tpr_info(\"%s: registered device %s\\n\",\n\t       dev->name, video_device_node_name(dev->vbi_dev));\n\n\tif (card_has_radio(dev)) {\n\t\tdev->radio_dev = vdev_init(dev,&saa7134_radio_template,\"radio\");\n\t\tdev->radio_dev->ctrl_handler = &dev->radio_ctrl_handler;\n\t\tdev->radio_dev->lock = &dev->lock;\n\t\tdev->radio_dev->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\t\tif (dev->has_rds)\n\t\t\tdev->radio_dev->device_caps |= V4L2_CAP_RDS_CAPTURE;\n\t\terr = video_register_device(dev->radio_dev,VFL_TYPE_RADIO,\n\t\t\t\t\t    radio_nr[dev->nr]);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_video;\n\t\tpr_info(\"%s: registered device %s\\n\",\n\t\t       dev->name, video_device_node_name(dev->radio_dev));\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tsaa7134_create_entities(dev);\n\n\terr = v4l2_mc_create_media_graph(dev->media_dev);\n\tif (err) {\n\t\tpr_err(\"failed to create media graph\\n\");\n\t\tgoto err_unregister_video;\n\t}\n#endif\n\t \n\tsaa7134_devcount++;\n\n\tif (saa7134_dmasound_init && !dev->dmasound.priv_data)\n\t\tsaa7134_dmasound_init(dev);\n\n\trequest_submodules(dev);\n\n\t \n#ifdef CONFIG_MEDIA_CONTROLLER\n\terr = media_device_register(dev->media_dev);\n\tif (err) {\n\t\tmedia_device_cleanup(dev->media_dev);\n\t\tgoto err_unregister_video;\n\t}\n#endif\n\n\treturn 0;\n\nerr_unregister_video:\n\tsaa7134_unregister_video(dev);\n\tlist_del(&dev->devlist);\n\tsaa7134_i2c_unregister(dev);\n\tfree_irq(pci_dev->irq, dev);\nerr_iounmap:\n\tsaa7134_hwfini(dev);\n\tiounmap(dev->lmmio);\nerr_release_mem_reg:\n\trelease_mem_region(pci_resource_start(pci_dev,0),\n\t\t\t   pci_resource_len(pci_dev,0));\nerr_v4l2_unregister:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_free_dev:\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tkfree(dev->media_dev);\n#endif\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void saa7134_finidev(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\n\tstruct saa7134_mpeg_ops *mops;\n\n\tflush_request_submodules(dev);\n\n\t \n\tif (saa7134_dmasound_exit && dev->dmasound.priv_data) {\n\t\tsaa7134_dmasound_exit(dev);\n\t}\n\n\t \n\tif (irq_debug) {\n\t\tu32 report = saa_readl(SAA7134_IRQ_REPORT);\n\t\tu32 status = saa_readl(SAA7134_IRQ_STATUS);\n\t\tprint_irqstatus(dev,42,report,status);\n\t}\n\n\t \n\tsaa_writeb(SAA7134_SPECIAL_MODE,0);\n\n\t \n\tsaa_writel(SAA7134_IRQ1,0);\n\tsaa_writel(SAA7134_IRQ2,0);\n\tsaa_writel(SAA7134_MAIN_CTRL,0);\n\n\t \n\tsaa7134_hwfini(dev);\n\n\t \n\tmutex_lock(&saa7134_devlist_lock);\n\tlist_del(&dev->devlist);\n\tlist_for_each_entry(mops, &mops_list, next)\n\t\tmpeg_ops_detach(mops, dev);\n\tmutex_unlock(&saa7134_devlist_lock);\n\tsaa7134_devcount--;\n\n\tsaa7134_i2c_unregister(dev);\n\tsaa7134_unregister_video(dev);\n\n\n\t \n\tif (dev->dmasound.priv_data != NULL) {\n\t\tfree_irq(pci_dev->irq, &dev->dmasound);\n\t\tdev->dmasound.priv_data = NULL;\n\t}\n\n\n\t \n\tfree_irq(pci_dev->irq, dev);\n\tiounmap(dev->lmmio);\n\trelease_mem_region(pci_resource_start(pci_dev,0),\n\t\t\t   pci_resource_len(pci_dev,0));\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tsaa7134_unregister_media_device(dev);\n\n\t \n\tkfree(dev);\n}\n\n \nstatic int __maybe_unused saa7134_buffer_requeue(struct saa7134_dev *dev,\n\t\t\t\t\t\t struct saa7134_dmaqueue *q)\n{\n\tstruct saa7134_buf *buf, *next;\n\n\tassert_spin_locked(&dev->slock);\n\n\tbuf  = q->curr;\n\tnext = buf;\n\tcore_dbg(\"buffer_requeue\\n\");\n\n\tif (!buf)\n\t\treturn 0;\n\n\tcore_dbg(\"buffer_requeue : resending active buffer\\n\");\n\n\tif (!list_empty(&q->queue))\n\t\tnext = list_entry(q->queue.next, struct saa7134_buf,\n\t\t\t\t\t  entry);\n\tbuf->activate(dev, buf, next);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused saa7134_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev_d);\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\n\n\t \n\tsaa_writel(SAA7134_IRQ1, 0);\n\tsaa_writel(SAA7134_IRQ2, 0);\n\tsaa_writel(SAA7134_MAIN_CTRL, 0);\n\n\tdev->insuspend = 1;\n\tsynchronize_irq(pci_dev->irq);\n\n\t \n\n\tsaa_writel(SAA7134_IRQ_REPORT, saa_readl(SAA7134_IRQ_REPORT));\n\n\t \n\n\tdel_timer(&dev->video_q.timeout);\n\tdel_timer(&dev->vbi_q.timeout);\n\tdel_timer(&dev->ts_q.timeout);\n\n\tif (dev->remote && dev->remote->dev->users)\n\t\tsaa7134_ir_close(dev->remote->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused saa7134_resume(struct device *dev_d)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev_d);\n\tstruct saa7134_dev *dev = container_of(v4l2_dev, struct saa7134_dev, v4l2_dev);\n\tunsigned long flags;\n\n\t \n\n\tsaa7134_board_init1(dev);\n\n\t \n\tif (saa7134_boards[dev->board].video_out)\n\t\tsaa7134_videoport_init(dev);\n\tif (card_has_mpeg(dev))\n\t\tsaa7134_ts_init_hw(dev);\n\tif (dev->remote && dev->remote->dev->users)\n\t\tsaa7134_ir_open(dev->remote->dev);\n\tsaa7134_hw_enable1(dev);\n\n\tmsleep(100);\n\n\tsaa7134_board_init2(dev);\n\n\t \n\tsaa7134_set_tvnorm_hw(dev);\n\tsaa7134_tvaudio_setmute(dev);\n\tsaa7134_tvaudio_setvolume(dev, dev->ctl_volume);\n\tsaa7134_tvaudio_init(dev);\n\tsaa7134_enable_i2s(dev);\n\tsaa7134_hw_enable2(dev);\n\n\tsaa7134_irq_video_signalchange(dev);\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tsaa7134_buffer_requeue(dev, &dev->video_q);\n\tsaa7134_buffer_requeue(dev, &dev->vbi_q);\n\tsaa7134_buffer_requeue(dev, &dev->ts_q);\n\n\t \n\n\tdev->dmasound.dma_running = 0;\n\n\t \n\tdev->insuspend = 0;\n\tsmp_wmb();\n\tsaa7134_set_dmabits(dev);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\n \n\nint saa7134_ts_register(struct saa7134_mpeg_ops *ops)\n{\n\tstruct saa7134_dev *dev;\n\n\tmutex_lock(&saa7134_devlist_lock);\n\tlist_for_each_entry(dev, &saa7134_devlist, devlist)\n\t\tmpeg_ops_attach(ops, dev);\n\tlist_add_tail(&ops->next,&mops_list);\n\tmutex_unlock(&saa7134_devlist_lock);\n\treturn 0;\n}\n\nvoid saa7134_ts_unregister(struct saa7134_mpeg_ops *ops)\n{\n\tstruct saa7134_dev *dev;\n\n\tmutex_lock(&saa7134_devlist_lock);\n\tlist_del(&ops->next);\n\tlist_for_each_entry(dev, &saa7134_devlist, devlist)\n\t\tmpeg_ops_detach(ops, dev);\n\tmutex_unlock(&saa7134_devlist_lock);\n}\n\nEXPORT_SYMBOL(saa7134_ts_register);\nEXPORT_SYMBOL(saa7134_ts_unregister);\n\n \n\nstatic SIMPLE_DEV_PM_OPS(saa7134_pm_ops, saa7134_suspend, saa7134_resume);\n\nstatic struct pci_driver saa7134_pci_driver = {\n\t.name     = \"saa7134\",\n\t.id_table = saa7134_pci_tbl,\n\t.probe    = saa7134_initdev,\n\t.remove   = saa7134_finidev,\n\t.driver.pm = &saa7134_pm_ops,\n};\n\nstatic int __init saa7134_init(void)\n{\n\tpr_info(\"saa7130/34: v4l2 driver version %s loaded\\n\",\n\t       SAA7134_VERSION);\n\treturn pci_register_driver(&saa7134_pci_driver);\n}\n\nstatic void __exit saa7134_fini(void)\n{\n\tpci_unregister_driver(&saa7134_pci_driver);\n}\n\nmodule_init(saa7134_init);\nmodule_exit(saa7134_fini);\n\n \n\nEXPORT_SYMBOL(saa7134_set_gpio);\nEXPORT_SYMBOL(saa7134_boards);\n\n \n\nEXPORT_SYMBOL(saa7134_dmasound_init);\nEXPORT_SYMBOL(saa7134_dmasound_exit);\nEXPORT_SYMBOL(saa7134_pgtable_free);\nEXPORT_SYMBOL(saa7134_pgtable_build);\nEXPORT_SYMBOL(saa7134_pgtable_alloc);\nEXPORT_SYMBOL(saa7134_set_dmabits);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}