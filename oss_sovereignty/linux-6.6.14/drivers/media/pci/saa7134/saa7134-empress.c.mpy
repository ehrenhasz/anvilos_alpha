{
  "module_name": "saa7134-empress.c",
  "hash_id": "2ca56c0b2a6176bd906c67b46060a0052d7abe9026a6b2f613148efcf5d32f69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-empress.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n\n \n\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int empress_nr[] = {[0 ... (SAA7134_MAXBOARDS - 1)] = UNSET };\n\nmodule_param_array(empress_nr, int, NULL, 0444);\nMODULE_PARM_DESC(empress_nr,\"ts device number\");\n\n \n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tu32 leading_null_bytes = 0;\n\tint err;\n\n\terr = saa7134_ts_start_streaming(vq, count);\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch (dev->board) {\n\tcase SAA7134_BOARD_BEHOLD_M6:\n\tcase SAA7134_BOARD_BEHOLD_M63:\n\tcase SAA7134_BOARD_BEHOLD_M6_EXTRA:\n\t\tleading_null_bytes = 1;\n\t\tbreak;\n\t}\n\tsaa_call_all(dev, core, init, leading_null_bytes);\n\t \n\tsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\n\t\t\tsaa_readb(SAA7134_AUDIO_MUTE_CTRL) & ~(1 << 6));\n\tdev->empress_started = 1;\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\n\tsaa7134_ts_stop_streaming(vq);\n\tsaa_writeb(SAA7134_SPECIAL_MODE, 0x00);\n\tmsleep(20);\n\tsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\n\tmsleep(100);\n\t \n\tsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\n\t\t\tsaa_readb(SAA7134_AUDIO_MUTE_CTRL) | (1 << 6));\n\tdev->empress_started = 0;\n}\n\nstatic const struct vb2_ops saa7134_empress_qops = {\n\t.queue_setup\t= saa7134_ts_queue_setup,\n\t.buf_init\t= saa7134_ts_buffer_init,\n\t.buf_prepare\t= saa7134_ts_buffer_prepare,\n\t.buf_queue\t= saa7134_vb2_buffer_queue,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n};\n\n \n\nstatic int empress_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\treturn 0;\n}\n\nstatic int empress_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &fmt.format;\n\n\tsaa_call_all(dev, pad, get_fmt, NULL, &fmt);\n\n\tv4l2_fill_pix_format(&f->fmt.pix, mbus_fmt);\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.sizeimage    = TS_PACKET_SIZE * dev->ts.nr_packets;\n\tf->fmt.pix.bytesperline = 0;\n\n\treturn 0;\n}\n\nstatic int empress_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\n\tsaa_call_all(dev, pad, set_fmt, NULL, &format);\n\tv4l2_fill_pix_format(&f->fmt.pix, &format.format);\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.sizeimage    = TS_PACKET_SIZE * dev->ts.nr_packets;\n\tf->fmt.pix.bytesperline = 0;\n\n\treturn 0;\n}\n\nstatic int empress_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct v4l2_subdev_pad_config pad_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\n\tsaa_call_all(dev, pad, set_fmt, &pad_state, &format);\n\tv4l2_fill_pix_format(&f->fmt.pix, &format.format);\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.sizeimage    = TS_PACKET_SIZE * dev->ts.nr_packets;\n\tf->fmt.pix.bytesperline = 0;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations ts_fops =\n{\n\t.owner\t  = THIS_MODULE,\n\t.open\t  = v4l2_fh_open,\n\t.release  = vb2_fop_release,\n\t.read\t  = vb2_fop_read,\n\t.poll\t  = vb2_fop_poll,\n\t.mmap\t  = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops ts_ioctl_ops = {\n\t.vidioc_querycap\t\t= saa7134_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= empress_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= empress_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= empress_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= empress_g_fmt_vid_cap,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_g_frequency\t\t= saa7134_g_frequency,\n\t.vidioc_s_frequency\t\t= saa7134_s_frequency,\n\t.vidioc_g_tuner\t\t\t= saa7134_g_tuner,\n\t.vidioc_s_tuner\t\t\t= saa7134_s_tuner,\n\t.vidioc_enum_input\t\t= saa7134_enum_input,\n\t.vidioc_g_input\t\t\t= saa7134_g_input,\n\t.vidioc_s_input\t\t\t= saa7134_s_input,\n\t.vidioc_s_std\t\t\t= saa7134_s_std,\n\t.vidioc_g_std\t\t\t= saa7134_g_std,\n\t.vidioc_querystd\t\t= saa7134_querystd,\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic const struct video_device saa7134_empress_template = {\n\t.name          = \"saa7134-empress\",\n\t.fops          = &ts_fops,\n\t.ioctl_ops     = &ts_ioctl_ops,\n\n\t.tvnorms\t\t\t= SAA7134_NORMS,\n};\n\nstatic void empress_signal_update(struct work_struct *work)\n{\n\tstruct saa7134_dev* dev =\n\t\tcontainer_of(work, struct saa7134_dev, empress_workqueue);\n\n\tif (dev->nosignal) {\n\t\tpr_debug(\"no video signal\\n\");\n\t} else {\n\t\tpr_debug(\"video signal acquired\\n\");\n\t}\n}\n\nstatic void empress_signal_change(struct saa7134_dev *dev)\n{\n\tschedule_work(&dev->empress_workqueue);\n}\n\nstatic bool empress_ctrl_filter(const struct v4l2_ctrl *ctrl)\n{\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\tcase V4L2_CID_HUE:\n\tcase V4L2_CID_CONTRAST:\n\tcase V4L2_CID_SATURATION:\n\tcase V4L2_CID_AUDIO_MUTE:\n\tcase V4L2_CID_AUDIO_VOLUME:\n\tcase V4L2_CID_PRIVATE_INVERT:\n\tcase V4L2_CID_PRIVATE_AUTOMUTE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int empress_init(struct saa7134_dev *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->empress_ctrl_handler;\n\tstruct vb2_queue *q;\n\tint err;\n\n\tpr_debug(\"%s: %s\\n\", dev->name, __func__);\n\tdev->empress_dev = video_device_alloc();\n\tif (NULL == dev->empress_dev)\n\t\treturn -ENOMEM;\n\t*(dev->empress_dev) = saa7134_empress_template;\n\tdev->empress_dev->v4l2_dev  = &dev->v4l2_dev;\n\tdev->empress_dev->release = video_device_release;\n\tdev->empress_dev->lock = &dev->lock;\n\tsnprintf(dev->empress_dev->name, sizeof(dev->empress_dev->name),\n\t\t \"%s empress (%s)\", dev->name,\n\t\t saa7134_boards[dev->board].name);\n\tv4l2_ctrl_handler_init(hdl, 21);\n\tv4l2_ctrl_add_handler(hdl, &dev->ctrl_handler, empress_ctrl_filter, false);\n\tif (dev->empress_sd)\n\t\tv4l2_ctrl_add_handler(hdl, dev->empress_sd->ctrl_handler, NULL, true);\n\tif (hdl->error) {\n\t\tvideo_device_release(dev->empress_dev);\n\t\treturn hdl->error;\n\t}\n\tdev->empress_dev->ctrl_handler = hdl;\n\n\tINIT_WORK(&dev->empress_workqueue, empress_signal_update);\n\n\tq = &dev->empress_vbq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t \n\tq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = &dev->ts_q;\n\tq->ops = &saa7134_empress_qops;\n\tq->gfp_flags = GFP_DMA32;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->buf_struct_size = sizeof(struct saa7134_buf);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\terr = vb2_queue_init(q);\n\tif (err) {\n\t\tvideo_device_release(dev->empress_dev);\n\t\tdev->empress_dev = NULL;\n\t\treturn err;\n\t}\n\tdev->empress_dev->queue = q;\n\tdev->empress_dev->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t\tV4L2_CAP_VIDEO_CAPTURE;\n\tif (dev->tuner_type != TUNER_ABSENT && dev->tuner_type != UNSET)\n\t\tdev->empress_dev->device_caps |= V4L2_CAP_TUNER;\n\n\tvideo_set_drvdata(dev->empress_dev, dev);\n\terr = video_register_device(dev->empress_dev,VFL_TYPE_VIDEO,\n\t\t\t\t    empress_nr[dev->nr]);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register video device\\n\",\n\t\t       dev->name);\n\t\tvideo_device_release(dev->empress_dev);\n\t\tdev->empress_dev = NULL;\n\t\treturn err;\n\t}\n\tpr_info(\"%s: registered device %s [mpeg]\\n\",\n\t       dev->name, video_device_node_name(dev->empress_dev));\n\n\tempress_signal_update(&dev->empress_workqueue);\n\treturn 0;\n}\n\nstatic int empress_fini(struct saa7134_dev *dev)\n{\n\tpr_debug(\"%s: %s\\n\", dev->name, __func__);\n\n\tif (NULL == dev->empress_dev)\n\t\treturn 0;\n\tflush_work(&dev->empress_workqueue);\n\tvb2_video_unregister_device(dev->empress_dev);\n\tv4l2_ctrl_handler_free(&dev->empress_ctrl_handler);\n\tdev->empress_dev = NULL;\n\treturn 0;\n}\n\nstatic struct saa7134_mpeg_ops empress_ops = {\n\t.type          = SAA7134_MPEG_EMPRESS,\n\t.init          = empress_init,\n\t.fini          = empress_fini,\n\t.signal_change = empress_signal_change,\n};\n\nstatic int __init empress_register(void)\n{\n\treturn saa7134_ts_register(&empress_ops);\n}\n\nstatic void __exit empress_unregister(void)\n{\n\tsaa7134_ts_unregister(&empress_ops);\n}\n\nmodule_init(empress_register);\nmodule_exit(empress_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}