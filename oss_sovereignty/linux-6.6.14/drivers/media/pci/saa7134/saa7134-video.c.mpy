{
  "module_name": "saa7134-video.c",
  "hash_id": "c3cd884df4b25f397e8396e6861d59554e929a1308946f994f4dafa32ba25876",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-video.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/i2c/saa6588.h>\n\n \n\nunsigned int video_debug;\nstatic unsigned int gbuffers      = 8;\nstatic unsigned int noninterlaced;  \nstatic unsigned int gbufsize      = 720*576*4;\nstatic unsigned int gbufsize_max  = 720*576*4;\nstatic char secam[] = \"--\";\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug,\"enable debug messages [video]\");\nmodule_param(gbuffers, int, 0444);\nMODULE_PARM_DESC(gbuffers,\"number of capture buffers, range 2-32\");\nmodule_param(noninterlaced, int, 0644);\nMODULE_PARM_DESC(noninterlaced,\"capture non interlaced video\");\nmodule_param_string(secam, secam, sizeof(secam), 0644);\nMODULE_PARM_DESC(secam, \"force SECAM variant, either DK,L or Lc\");\n\n\n#define video_dbg(fmt, arg...) do { \\\n\tif (video_debug & 0x04) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"video: \" fmt), ## arg); \\\n\t} while (0)\n\n \n \n\n \n\n#define VP_T_CODE_P_NON_INVERTED\t0x00\n#define VP_T_CODE_P_INVERTED\t\t0x01\n\n \n \n\n \n\n#define VP_CLK_CTRL2_NOT_DELAYED\t0x00\n#define VP_CLK_CTRL2_DELAYED\t\t0x04\n\n \n\n#define VP_CLK_CTRL1_NON_INVERTED\t0x00\n#define VP_CLK_CTRL1_INVERTED\t\t0x02\n\n \n \n\n \n\n#define VP_VS_TYPE_MASK\t\t\t0x07\n\n#define VP_VS_TYPE_OFF\t\t\t0x00\n#define VP_VS_TYPE_V123\t\t\t0x01\n#define VP_VS_TYPE_V_ITU\t\t0x02\n#define VP_VS_TYPE_VGATE_L\t\t0x03\n#define VP_VS_TYPE_RESERVED1\t\t0x04\n#define VP_VS_TYPE_RESERVED2\t\t0x05\n#define VP_VS_TYPE_F_ITU\t\t0x06\n#define VP_VS_TYPE_SC_FID\t\t0x07\n\n \n \n\nstatic int video_out[][9] = {\n\t[CCIR656] = { 0x00, 0xb1, 0x00, 0xa1, 0x00, 0x04, 0x06, 0x00, 0x00 },\n};\n\nstatic struct saa7134_format formats[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_GREY,\n\t\t.depth    = 8,\n\t\t.pm       = 0x06,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555,\n\t\t.depth    = 16,\n\t\t.pm       = 0x13 | 0x80,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555X,\n\t\t.depth    = 16,\n\t\t.pm       = 0x13 | 0x80,\n\t\t.bswap    = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565,\n\t\t.depth    = 16,\n\t\t.pm       = 0x10 | 0x80,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565X,\n\t\t.depth    = 16,\n\t\t.pm       = 0x10 | 0x80,\n\t\t.bswap    = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_BGR24,\n\t\t.depth    = 24,\n\t\t.pm       = 0x11,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB24,\n\t\t.depth    = 24,\n\t\t.pm       = 0x11,\n\t\t.bswap    = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_BGR32,\n\t\t.depth    = 32,\n\t\t.pm       = 0x12,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB32,\n\t\t.depth    = 32,\n\t\t.pm       = 0x12,\n\t\t.bswap    = 1,\n\t\t.wswap    = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUYV,\n\t\t.depth    = 16,\n\t\t.pm       = 0x00,\n\t\t.bswap    = 1,\n\t\t.yuv      = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_UYVY,\n\t\t.depth    = 16,\n\t\t.pm       = 0x00,\n\t\t.yuv      = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV422P,\n\t\t.depth    = 16,\n\t\t.pm       = 0x09,\n\t\t.yuv      = 1,\n\t\t.planar   = 1,\n\t\t.hshift   = 1,\n\t\t.vshift   = 0,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV420,\n\t\t.depth    = 12,\n\t\t.pm       = 0x0a,\n\t\t.yuv      = 1,\n\t\t.planar   = 1,\n\t\t.hshift   = 1,\n\t\t.vshift   = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YVU420,\n\t\t.depth    = 12,\n\t\t.pm       = 0x0a,\n\t\t.yuv      = 1,\n\t\t.planar   = 1,\n\t\t.uvswap   = 1,\n\t\t.hshift   = 1,\n\t\t.vshift   = 1,\n\t}\n};\n#define FORMATS ARRAY_SIZE(formats)\n\n#define NORM_625_50\t\t\t\\\n\t\t.h_start       = 0,\t\\\n\t\t.h_stop        = 719,\t\\\n\t\t.video_v_start = 24,\t\\\n\t\t.video_v_stop  = 311,\t\\\n\t\t.vbi_v_start_0 = 7,\t\\\n\t\t.vbi_v_stop_0  = 23,\t\\\n\t\t.vbi_v_start_1 = 319,   \\\n\t\t.src_timing    = 4\n\n#define NORM_525_60\t\t\t\\\n\t\t.h_start       = 0,\t\\\n\t\t.h_stop        = 719,\t\\\n\t\t.video_v_start = 23,\t\\\n\t\t.video_v_stop  = 262,\t\\\n\t\t.vbi_v_start_0 = 10,\t\\\n\t\t.vbi_v_stop_0  = 21,\t\\\n\t\t.vbi_v_start_1 = 273,\t\\\n\t\t.src_timing    = 7\n\nstatic struct saa7134_tvnorm tvnorms[] = {\n\t{\n\t\t.name          = \"PAL\",  \n\t\t.id            = V4L2_STD_PAL,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x81,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"PAL-BG\",\n\t\t.id            = V4L2_STD_PAL_BG,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x81,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"PAL-I\",\n\t\t.id            = V4L2_STD_PAL_I,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x81,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"PAL-DK\",\n\t\t.id            = V4L2_STD_PAL_DK,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x81,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"NTSC\",\n\t\t.id            = V4L2_STD_NTSC,\n\t\tNORM_525_60,\n\n\t\t.sync_control  = 0x59,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x89,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x0e,\n\t\t.vgate_misc    = 0x18,\n\n\t},{\n\t\t.name          = \"SECAM\",\n\t\t.id            = V4L2_STD_SECAM,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x1b,\n\t\t.chroma_ctrl1  = 0xd1,\n\t\t.chroma_gain   = 0x80,\n\t\t.chroma_ctrl2  = 0x00,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"SECAM-DK\",\n\t\t.id            = V4L2_STD_SECAM_DK,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x1b,\n\t\t.chroma_ctrl1  = 0xd1,\n\t\t.chroma_gain   = 0x80,\n\t\t.chroma_ctrl2  = 0x00,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"SECAM-L\",\n\t\t.id            = V4L2_STD_SECAM_L,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x1b,\n\t\t.chroma_ctrl1  = 0xd1,\n\t\t.chroma_gain   = 0x80,\n\t\t.chroma_ctrl2  = 0x00,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"SECAM-Lc\",\n\t\t.id            = V4L2_STD_SECAM_LC,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x1b,\n\t\t.chroma_ctrl1  = 0xd1,\n\t\t.chroma_gain   = 0x80,\n\t\t.chroma_ctrl2  = 0x00,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"PAL-M\",\n\t\t.id            = V4L2_STD_PAL_M,\n\t\tNORM_525_60,\n\n\t\t.sync_control  = 0x59,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0xb9,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x0e,\n\t\t.vgate_misc    = 0x18,\n\n\t},{\n\t\t.name          = \"PAL-Nc\",\n\t\t.id            = V4L2_STD_PAL_Nc,\n\t\tNORM_625_50,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0xa1,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\n\t},{\n\t\t.name          = \"PAL-60\",\n\t\t.id            = V4L2_STD_PAL_60,\n\n\t\t.h_start       = 0,\n\t\t.h_stop        = 719,\n\t\t.video_v_start = 23,\n\t\t.video_v_stop  = 262,\n\t\t.vbi_v_start_0 = 10,\n\t\t.vbi_v_stop_0  = 21,\n\t\t.vbi_v_start_1 = 273,\n\t\t.src_timing    = 7,\n\n\t\t.sync_control  = 0x18,\n\t\t.luma_control  = 0x40,\n\t\t.chroma_ctrl1  = 0x81,\n\t\t.chroma_gain   = 0x2a,\n\t\t.chroma_ctrl2  = 0x06,\n\t\t.vgate_misc    = 0x1c,\n\t}\n};\n#define TVNORMS ARRAY_SIZE(tvnorms)\n\nstatic struct saa7134_format* format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats+i;\n\treturn NULL;\n}\n\n \n\nstatic void set_tvnorm(struct saa7134_dev *dev, struct saa7134_tvnorm *norm)\n{\n\tvideo_dbg(\"set tv norm = %s\\n\", norm->name);\n\tdev->tvnorm = norm;\n\n\t \n\tdev->crop_bounds.left    = norm->h_start;\n\tdev->crop_defrect.left   = norm->h_start;\n\tdev->crop_bounds.width   = norm->h_stop - norm->h_start +1;\n\tdev->crop_defrect.width  = norm->h_stop - norm->h_start +1;\n\n\tdev->crop_bounds.top     = (norm->vbi_v_stop_0+1)*2;\n\tdev->crop_defrect.top    = norm->video_v_start*2;\n\tdev->crop_bounds.height  = ((norm->id & V4L2_STD_525_60) ? 524 : 624)\n\t\t- dev->crop_bounds.top;\n\tdev->crop_defrect.height = (norm->video_v_stop - norm->video_v_start +1)*2;\n\n\tdev->crop_current = dev->crop_defrect;\n\n\tsaa7134_set_tvnorm_hw(dev);\n}\n\nstatic void video_mux(struct saa7134_dev *dev, int input)\n{\n\tvideo_dbg(\"video input = %d [%s]\\n\",\n\t\t  input, saa7134_input_name[card_in(dev, input).type]);\n\tdev->ctl_input = input;\n\tset_tvnorm(dev, dev->tvnorm);\n\tsaa7134_tvaudio_setinput(dev, &card_in(dev, input));\n}\n\n\nstatic void saa7134_set_decoder(struct saa7134_dev *dev)\n{\n\tint luma_control, sync_control, chroma_ctrl1, mux;\n\n\tstruct saa7134_tvnorm *norm = dev->tvnorm;\n\tmux = card_in(dev, dev->ctl_input).vmux;\n\n\tluma_control = norm->luma_control;\n\tsync_control = norm->sync_control;\n\tchroma_ctrl1 = norm->chroma_ctrl1;\n\n\tif (mux > 5)\n\t\tluma_control |= 0x80;  \n\tif (noninterlaced || dev->nosignal)\n\t\tsync_control |= 0x20;\n\n\t \n\tsync_control |= SAA7134_SYNC_CTRL_AUFD;\n\tchroma_ctrl1 |= SAA7134_CHROMA_CTRL1_AUTO0;\n\tchroma_ctrl1 &= ~SAA7134_CHROMA_CTRL1_FCTC;\n\tluma_control &= ~SAA7134_LUMA_CTRL_LDEL;\n\n\t \n\tsaa_writeb(SAA7134_INCR_DELAY,            0x08);\n\tsaa_writeb(SAA7134_ANALOG_IN_CTRL1,       0xc0 | mux);\n\tsaa_writeb(SAA7134_ANALOG_IN_CTRL2,       0x00);\n\n\tsaa_writeb(SAA7134_ANALOG_IN_CTRL3,       0x90);\n\tsaa_writeb(SAA7134_ANALOG_IN_CTRL4,       0x90);\n\tsaa_writeb(SAA7134_HSYNC_START,           0xeb);\n\tsaa_writeb(SAA7134_HSYNC_STOP,            0xe0);\n\tsaa_writeb(SAA7134_SOURCE_TIMING1,        norm->src_timing);\n\n\tsaa_writeb(SAA7134_SYNC_CTRL,             sync_control);\n\tsaa_writeb(SAA7134_LUMA_CTRL,             luma_control);\n\tsaa_writeb(SAA7134_DEC_LUMA_BRIGHT,       dev->ctl_bright);\n\n\tsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\n\t\tdev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\n\n\tsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\n\t\tdev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\n\n\tsaa_writeb(SAA7134_DEC_CHROMA_HUE,        dev->ctl_hue);\n\tsaa_writeb(SAA7134_CHROMA_CTRL1,          chroma_ctrl1);\n\tsaa_writeb(SAA7134_CHROMA_GAIN,           norm->chroma_gain);\n\n\tsaa_writeb(SAA7134_CHROMA_CTRL2,          norm->chroma_ctrl2);\n\tsaa_writeb(SAA7134_MODE_DELAY_CTRL,       0x00);\n\n\tsaa_writeb(SAA7134_ANALOG_ADC,            0x01);\n\tsaa_writeb(SAA7134_VGATE_START,           0x11);\n\tsaa_writeb(SAA7134_VGATE_STOP,            0xfe);\n\tsaa_writeb(SAA7134_MISC_VGATE_MSB,        norm->vgate_misc);\n\tsaa_writeb(SAA7134_RAW_DATA_GAIN,         0x40);\n\tsaa_writeb(SAA7134_RAW_DATA_OFFSET,       0x80);\n}\n\nvoid saa7134_set_tvnorm_hw(struct saa7134_dev *dev)\n{\n\tsaa7134_set_decoder(dev);\n\n\tsaa_call_all(dev, video, s_std, dev->tvnorm->id);\n\t \n\tsaa_call_empress(dev, video, s_std, dev->tvnorm->id);\n}\n\nstatic void set_h_prescale(struct saa7134_dev *dev, int task, int prescale)\n{\n\tstatic const struct {\n\t\tint xpsc;\n\t\tint xacl;\n\t\tint xc2_1;\n\t\tint xdcg;\n\t\tint vpfy;\n\t} vals[] = {\n\t\t \n\t\t{    1,   0,    0,    0,   0 },\n\t\t{    2,   2,    1,    2,   2 },\n\t\t{    3,   4,    1,    3,   2 },\n\t\t{    4,   8,    1,    4,   2 },\n\t\t{    5,   8,    1,    4,   2 },\n\t\t{    6,   8,    1,    4,   3 },\n\t\t{    7,   8,    1,    4,   3 },\n\t\t{    8,  15,    0,    4,   3 },\n\t\t{    9,  15,    0,    4,   3 },\n\t\t{   10,  16,    1,    5,   3 },\n\t};\n\tstatic const int count = ARRAY_SIZE(vals);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (vals[i].xpsc == prescale)\n\t\t\tbreak;\n\tif (i == count)\n\t\treturn;\n\n\tsaa_writeb(SAA7134_H_PRESCALE(task), vals[i].xpsc);\n\tsaa_writeb(SAA7134_ACC_LENGTH(task), vals[i].xacl);\n\tsaa_writeb(SAA7134_LEVEL_CTRL(task),\n\t\t   (vals[i].xc2_1 << 3) | (vals[i].xdcg));\n\tsaa_andorb(SAA7134_FIR_PREFILTER_CTRL(task), 0x0f,\n\t\t   (vals[i].vpfy << 2) | vals[i].vpfy);\n}\n\nstatic void set_v_scale(struct saa7134_dev *dev, int task, int yscale)\n{\n\tint val,mirror;\n\n\tsaa_writeb(SAA7134_V_SCALE_RATIO1(task), yscale &  0xff);\n\tsaa_writeb(SAA7134_V_SCALE_RATIO2(task), yscale >> 8);\n\n\tmirror = (dev->ctl_mirror) ? 0x02 : 0x00;\n\tif (yscale < 2048) {\n\t\t \n\t\tvideo_dbg(\"yscale LPI yscale=%d\\n\", yscale);\n\t\tsaa_writeb(SAA7134_V_FILTER(task), 0x00 | mirror);\n\t\tsaa_writeb(SAA7134_LUMA_CONTRAST(task), 0x40);\n\t\tsaa_writeb(SAA7134_CHROMA_SATURATION(task), 0x40);\n\t} else {\n\t\t \n\t\tval = 0x40 * 1024 / yscale;\n\t\tvideo_dbg(\"yscale ACM yscale=%d val=0x%x\\n\", yscale, val);\n\t\tsaa_writeb(SAA7134_V_FILTER(task), 0x01 | mirror);\n\t\tsaa_writeb(SAA7134_LUMA_CONTRAST(task), val);\n\t\tsaa_writeb(SAA7134_CHROMA_SATURATION(task), val);\n\t}\n\tsaa_writeb(SAA7134_LUMA_BRIGHT(task),       0x80);\n}\n\nstatic void set_size(struct saa7134_dev *dev, int task,\n\t\t     int width, int height, int interlace)\n{\n\tint prescale,xscale,yscale,y_even,y_odd;\n\tint h_start, h_stop, v_start, v_stop;\n\tint div = interlace ? 2 : 1;\n\n\t \n\th_start = dev->crop_current.left;\n\tv_start = dev->crop_current.top/2;\n\th_stop  = (dev->crop_current.left + dev->crop_current.width -1);\n\tv_stop  = (dev->crop_current.top + dev->crop_current.height -1)/2;\n\n\tsaa_writeb(SAA7134_VIDEO_H_START1(task), h_start &  0xff);\n\tsaa_writeb(SAA7134_VIDEO_H_START2(task), h_start >> 8);\n\tsaa_writeb(SAA7134_VIDEO_H_STOP1(task),  h_stop  &  0xff);\n\tsaa_writeb(SAA7134_VIDEO_H_STOP2(task),  h_stop  >> 8);\n\tsaa_writeb(SAA7134_VIDEO_V_START1(task), v_start &  0xff);\n\tsaa_writeb(SAA7134_VIDEO_V_START2(task), v_start >> 8);\n\tsaa_writeb(SAA7134_VIDEO_V_STOP1(task),  v_stop  &  0xff);\n\tsaa_writeb(SAA7134_VIDEO_V_STOP2(task),  v_stop  >> 8);\n\n\tprescale = dev->crop_current.width / width;\n\tif (0 == prescale)\n\t\tprescale = 1;\n\txscale = 1024 * dev->crop_current.width / prescale / width;\n\tyscale = 512 * div * dev->crop_current.height / height;\n\tvideo_dbg(\"prescale=%d xscale=%d yscale=%d\\n\",\n\t\t  prescale, xscale, yscale);\n\tset_h_prescale(dev,task,prescale);\n\tsaa_writeb(SAA7134_H_SCALE_INC1(task),      xscale &  0xff);\n\tsaa_writeb(SAA7134_H_SCALE_INC2(task),      xscale >> 8);\n\tset_v_scale(dev,task,yscale);\n\n\tsaa_writeb(SAA7134_VIDEO_PIXELS1(task),     width  & 0xff);\n\tsaa_writeb(SAA7134_VIDEO_PIXELS2(task),     width  >> 8);\n\tsaa_writeb(SAA7134_VIDEO_LINES1(task),      height/div & 0xff);\n\tsaa_writeb(SAA7134_VIDEO_LINES2(task),      height/div >> 8);\n\n\t \n\ty_odd  = dev->ctl_y_odd;\n\ty_even = dev->ctl_y_even;\n\tsaa_writeb(SAA7134_V_PHASE_OFFSET0(task), y_odd);\n\tsaa_writeb(SAA7134_V_PHASE_OFFSET1(task), y_even);\n\tsaa_writeb(SAA7134_V_PHASE_OFFSET2(task), y_odd);\n\tsaa_writeb(SAA7134_V_PHASE_OFFSET3(task), y_even);\n}\n\n \n\n \n\nstatic int saa7134_enable_analog_tuner(struct saa7134_dev *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev = dev->media_dev;\n\tstruct media_entity *source;\n\tstruct media_link *link, *found_link = NULL;\n\tint ret, active_links = 0;\n\n\tif (!mdev || !dev->decoder)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(link, &dev->decoder->links, list) {\n\t\tif (link->sink->entity == dev->decoder) {\n\t\t\tfound_link = link;\n\t\t\tif (link->flags & MEDIA_LNK_FL_ENABLED)\n\t\t\t\tactive_links++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (active_links == 1 || !found_link)\n\t\treturn 0;\n\n\tsource = found_link->source->entity;\n\tlist_for_each_entry(link, &source->links, list) {\n\t\tstruct media_entity *sink;\n\t\tint flags = 0;\n\n\t\tsink = link->sink->entity;\n\n\t\tif (sink == dev->decoder)\n\t\t\tflags = MEDIA_LNK_FL_ENABLED;\n\n\t\tret = media_entity_setup_link(link, flags);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't change link %s->%s to %s. Error %d\\n\",\n\t\t\t       source->name, sink->name,\n\t\t\t       flags ? \"enabled\" : \"disabled\",\n\t\t\t       ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n \n\nstatic int buffer_activate(struct saa7134_dev *dev,\n\t\t\t   struct saa7134_buf *buf,\n\t\t\t   struct saa7134_buf *next)\n{\n\tstruct saa7134_dmaqueue *dmaq = buf->vb2.vb2_buf.vb2_queue->drv_priv;\n\tunsigned long base,control,bpl;\n\tunsigned long bpl_uv, lines_uv, base2, base3;  \n\n\tvideo_dbg(\"buffer_activate buf=%p\\n\", buf);\n\tbuf->top_seen = 0;\n\n\tset_size(dev, TASK_A, dev->width, dev->height,\n\t\t V4L2_FIELD_HAS_BOTH(dev->field));\n\tif (dev->fmt->yuv)\n\t\tsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x03);\n\telse\n\t\tsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x01);\n\tsaa_writeb(SAA7134_OFMT_VIDEO_A, dev->fmt->pm);\n\n\t \n\tbase  = saa7134_buffer_base(buf);\n\tif (dev->fmt->planar)\n\t\tbpl = dev->width;\n\telse\n\t\tbpl = (dev->width * dev->fmt->depth) / 8;\n\tcontrol = SAA7134_RS_CONTROL_BURST_16 |\n\t\tSAA7134_RS_CONTROL_ME |\n\t\t(dmaq->pt.dma >> 12);\n\tif (dev->fmt->bswap)\n\t\tcontrol |= SAA7134_RS_CONTROL_BSWAP;\n\tif (dev->fmt->wswap)\n\t\tcontrol |= SAA7134_RS_CONTROL_WSWAP;\n\tif (V4L2_FIELD_HAS_BOTH(dev->field)) {\n\t\t \n\t\tsaa_writel(SAA7134_RS_BA1(0),base);\n\t\tsaa_writel(SAA7134_RS_BA2(0),base+bpl);\n\t\tsaa_writel(SAA7134_RS_PITCH(0),bpl*2);\n\t} else {\n\t\t \n\t\tsaa_writel(SAA7134_RS_BA1(0),base);\n\t\tsaa_writel(SAA7134_RS_BA2(0),base);\n\t\tsaa_writel(SAA7134_RS_PITCH(0),bpl);\n\t}\n\tsaa_writel(SAA7134_RS_CONTROL(0),control);\n\n\tif (dev->fmt->planar) {\n\t\t \n\t\tbpl_uv   = bpl >> dev->fmt->hshift;\n\t\tlines_uv = dev->height >> dev->fmt->vshift;\n\t\tbase2    = base + bpl * dev->height;\n\t\tbase3    = base2 + bpl_uv * lines_uv;\n\t\tif (dev->fmt->uvswap)\n\t\t\tswap(base2, base3);\n\t\tvideo_dbg(\"uv: bpl=%ld lines=%ld base2/3=%ld/%ld\\n\",\n\t\t\tbpl_uv,lines_uv,base2,base3);\n\t\tif (V4L2_FIELD_HAS_BOTH(dev->field)) {\n\t\t\t \n\t\t\tsaa_writel(SAA7134_RS_BA1(4),base2);\n\t\t\tsaa_writel(SAA7134_RS_BA2(4),base2+bpl_uv);\n\t\t\tsaa_writel(SAA7134_RS_PITCH(4),bpl_uv*2);\n\t\t\tsaa_writel(SAA7134_RS_BA1(5),base3);\n\t\t\tsaa_writel(SAA7134_RS_BA2(5),base3+bpl_uv);\n\t\t\tsaa_writel(SAA7134_RS_PITCH(5),bpl_uv*2);\n\t\t} else {\n\t\t\t \n\t\t\tsaa_writel(SAA7134_RS_BA1(4),base2);\n\t\t\tsaa_writel(SAA7134_RS_BA2(4),base2);\n\t\t\tsaa_writel(SAA7134_RS_PITCH(4),bpl_uv);\n\t\t\tsaa_writel(SAA7134_RS_BA1(5),base3);\n\t\t\tsaa_writel(SAA7134_RS_BA2(5),base3);\n\t\t\tsaa_writel(SAA7134_RS_PITCH(5),bpl_uv);\n\t\t}\n\t\tsaa_writel(SAA7134_RS_CONTROL(4),control);\n\t\tsaa_writel(SAA7134_RS_CONTROL(5),control);\n\t}\n\n\t \n\tsaa7134_set_dmabits(dev);\n\tmod_timer(&dmaq->timeout, jiffies + BUFFER_TIMEOUT);\n\treturn 0;\n}\n\nstatic int buffer_init(struct vb2_buffer *vb2)\n{\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\n\tdmaq->curr = NULL;\n\tbuf->activate = buffer_activate;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb2)\n{\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\tstruct sg_table *dma = vb2_dma_sg_plane_desc(vb2, 0);\n\tunsigned int size;\n\n\tif (dma->sgl->offset) {\n\t\tpr_err(\"The buffer is not page-aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsize = (dev->width * dev->height * dev->fmt->depth) >> 3;\n\tif (vb2_plane_size(vb2, 0) < size)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb2, 0, size);\n\tvbuf->field = dev->field;\n\n\treturn saa7134_pgtable_build(dev->pci, &dmaq->pt, dma->sgl, dma->nents,\n\t\t\t\t    saa7134_buffer_startpage(buf));\n}\n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct saa7134_dmaqueue *dmaq = q->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tint size = dev->fmt->depth * dev->width * dev->height >> 3;\n\n\tif (dev->width    < 48 ||\n\t    dev->height   < 32 ||\n\t    dev->width/4  > dev->crop_current.width  ||\n\t    dev->height/4 > dev->crop_current.height ||\n\t    dev->width    > dev->crop_bounds.width  ||\n\t    dev->height   > dev->crop_bounds.height)\n\t\treturn -EINVAL;\n\n\t*nbuffers = saa7134_buffer_count(size, *nbuffers);\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tsaa7134_enable_analog_tuner(dev);\n\n\treturn 0;\n}\n\n \nvoid saa7134_vb2_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct saa7134_dmaqueue *dmaq = vb->vb2_queue->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\n\tsaa7134_buffer_queue(dev, dmaq, buf);\n}\nEXPORT_SYMBOL_GPL(saa7134_vb2_buffer_queue);\n\nint saa7134_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\n\t \n\tif (card_is_empress(dev) && vb2_is_busy(&dev->empress_vbq) &&\n\t    dmaq == &dev->video_q && dev->fmt->planar) {\n\t\tstruct saa7134_buf *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dmaq->queue, entry) {\n\t\t\tlist_del(&buf->entry);\n\t\t\tvb2_buffer_done(&buf->vb2.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t\tif (dmaq->curr) {\n\t\t\tvb2_buffer_done(&dmaq->curr->vb2.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t\tdmaq->curr = NULL;\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||\n\t    (dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))\n\t\tcpu_latency_qos_add_request(&dev->qos_request, 20);\n\tdmaq->seq_nr = 0;\n\n\treturn 0;\n}\n\nvoid saa7134_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\n\tsaa7134_stop_streaming(dev, dmaq);\n\n\tif ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||\n\t    (dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))\n\t\tcpu_latency_qos_remove_request(&dev->qos_request);\n}\n\nstatic const struct vb2_ops vb2_qops = {\n\t.queue_setup\t= queue_setup,\n\t.buf_init\t= buffer_init,\n\t.buf_prepare\t= buffer_prepare,\n\t.buf_queue\t= saa7134_vb2_buffer_queue,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.start_streaming = saa7134_vb2_start_streaming,\n\t.stop_streaming = saa7134_vb2_stop_streaming,\n};\n\n \n\nstatic int saa7134_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa7134_dev *dev = container_of(ctrl->handler, struct saa7134_dev, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tdev->ctl_bright = ctrl->val;\n\t\tsaa_writeb(SAA7134_DEC_LUMA_BRIGHT, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tdev->ctl_hue = ctrl->val;\n\t\tsaa_writeb(SAA7134_DEC_CHROMA_HUE, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tdev->ctl_contrast = ctrl->val;\n\t\tsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\n\t\t\t   dev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tdev->ctl_saturation = ctrl->val;\n\t\tsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\n\t\t\t   dev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tdev->ctl_mute = ctrl->val;\n\t\tsaa7134_tvaudio_setmute(dev);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tdev->ctl_volume = ctrl->val;\n\t\tsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_INVERT:\n\t\tdev->ctl_invert = ctrl->val;\n\t\tsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\n\t\t\t   dev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\n\t\tsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\n\t\t\t   dev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tdev->ctl_mirror = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_Y_EVEN:\n\t\tdev->ctl_y_even = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_Y_ODD:\n\t\tdev->ctl_y_odd = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_AUTOMUTE:\n\t{\n\t\tstruct v4l2_priv_tun_config tda9887_cfg;\n\n\t\ttda9887_cfg.tuner = TUNER_TDA9887;\n\t\ttda9887_cfg.priv = &dev->tda9887_conf;\n\n\t\tdev->ctl_automute = ctrl->val;\n\t\tif (dev->tda9887_conf) {\n\t\t\tif (dev->ctl_automute)\n\t\t\t\tdev->tda9887_conf |= TDA9887_AUTOMUTE;\n\t\t\telse\n\t\t\t\tdev->tda9887_conf &= ~TDA9887_AUTOMUTE;\n\n\t\t\tsaa_call_all(dev, tuner, s_config, &tda9887_cfg);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int video_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tint ret = v4l2_fh_open(file);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&dev->lock);\n\tif (vdev->vfl_type == VFL_TYPE_RADIO) {\n\t\t \n\t\tsaa7134_tvaudio_setinput(dev, &card(dev).radio);\n\t\tsaa_call_all(dev, tuner, s_radio);\n\t} else {\n\t\t \n\t\tvideo_mux(dev, dev->ctl_input);\n\t}\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int video_release(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\n\tmutex_lock(&dev->lock);\n\tsaa7134_tvaudio_close(dev);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\tv4l2_fh_release(file);\n\telse\n\t\t_vb2_fop_release(file, NULL);\n\n\t \n\tsaa_andorb(SAA7134_OFMT_VIDEO_A, 0x1f, 0);\n\tsaa_andorb(SAA7134_OFMT_VIDEO_B, 0x1f, 0);\n\tsaa_andorb(SAA7134_OFMT_DATA_A, 0x1f, 0);\n\tsaa_andorb(SAA7134_OFMT_DATA_B, 0x1f, 0);\n\n\tsaa_call_all(dev, tuner, standby);\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\tsaa_call_all(dev, core, command, SAA6588_CMD_CLOSE, &cmd);\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nstatic ssize_t radio_read(struct file *file, char __user *data,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\n\tcmd.block_count = count/3;\n\tcmd.nonblocking = file->f_flags & O_NONBLOCK;\n\tcmd.buffer = data;\n\tcmd.instance = file;\n\tcmd.result = -ENODEV;\n\n\tmutex_lock(&dev->lock);\n\tsaa_call_all(dev, core, command, SAA6588_CMD_READ, &cmd);\n\tmutex_unlock(&dev->lock);\n\n\treturn cmd.result;\n}\n\nstatic __poll_t radio_poll(struct file *file, poll_table *wait)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\t__poll_t rc = v4l2_ctrl_poll(file, wait);\n\n\tcmd.instance = file;\n\tcmd.event_list = wait;\n\tcmd.poll_mask = 0;\n\tmutex_lock(&dev->lock);\n\tsaa_call_all(dev, core, command, SAA6588_CMD_POLL, &cmd);\n\tmutex_unlock(&dev->lock);\n\n\treturn rc | cmd.poll_mask;\n}\n\n \n\nstatic int saa7134_try_get_set_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct saa7134_tvnorm *norm = dev->tvnorm;\n\n\tmemset(&f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\n\tf->fmt.vbi.sampling_rate = 6750000 * 4;\n\tf->fmt.vbi.samples_per_line = 2048  ;\n\tf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tf->fmt.vbi.offset = 64 * 4;\n\tf->fmt.vbi.start[0] = norm->vbi_v_start_0;\n\tf->fmt.vbi.count[0] = norm->vbi_v_stop_0 - norm->vbi_v_start_0 +1;\n\tf->fmt.vbi.start[1] = norm->vbi_v_start_1;\n\tf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\n\tf->fmt.vbi.flags = 0;  \n\n\treturn 0;\n}\n\nstatic int saa7134_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.width        = dev->width;\n\tf->fmt.pix.height       = dev->height;\n\tf->fmt.pix.field        = dev->field;\n\tf->fmt.pix.pixelformat  = dev->fmt->fourcc;\n\tif (dev->fmt->planar)\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width;\n\telse\n\t\tf->fmt.pix.bytesperline =\n\t\t\t(f->fmt.pix.width * dev->fmt->depth) / 8;\n\tf->fmt.pix.sizeimage =\n\t\t(f->fmt.pix.height * f->fmt.pix.width * dev->fmt->depth) / 8;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int saa7134_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct saa7134_format *fmt;\n\tenum v4l2_field field;\n\tunsigned int maxw, maxh;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\tmaxw  = min(dev->crop_current.width*4,  dev->crop_bounds.width);\n\tmaxh  = min(dev->crop_current.height*4, dev->crop_bounds.height);\n\n\tif (V4L2_FIELD_ANY == field) {\n\t\tfield = (f->fmt.pix.height > maxh/2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t}\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\t\tmaxh = maxh / 2;\n\t\tbreak;\n\tdefault:\n\t\tfield = V4L2_FIELD_INTERLACED;\n\t\tbreak;\n\t}\n\n\tf->fmt.pix.field = field;\n\tif (f->fmt.pix.width  < 48)\n\t\tf->fmt.pix.width  = 48;\n\tif (f->fmt.pix.height < 32)\n\t\tf->fmt.pix.height = 32;\n\tif (f->fmt.pix.width > maxw)\n\t\tf->fmt.pix.width = maxw;\n\tif (f->fmt.pix.height > maxh)\n\t\tf->fmt.pix.height = maxh;\n\tf->fmt.pix.width &= ~0x03;\n\tif (fmt->planar)\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width;\n\telse\n\t\tf->fmt.pix.bytesperline =\n\t\t\t(f->fmt.pix.width * fmt->depth) / 8;\n\tf->fmt.pix.sizeimage =\n\t\t(f->fmt.pix.height * f->fmt.pix.width * fmt->depth) / 8;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int saa7134_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tint err;\n\n\terr = saa7134_try_fmt_vid_cap(file, priv, f);\n\tif (0 != err)\n\t\treturn err;\n\n\tdev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tdev->width = f->fmt.pix.width;\n\tdev->height = f->fmt.pix.height;\n\tdev->field = f->fmt.pix.field;\n\treturn 0;\n}\n\nint saa7134_enum_input(struct file *file, void *priv, struct v4l2_input *i)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tunsigned int n;\n\n\tn = i->index;\n\tif (n >= SAA7134_INPUT_MAX)\n\t\treturn -EINVAL;\n\tif (card_in(dev, i->index).type == SAA7134_NO_INPUT)\n\t\treturn -EINVAL;\n\ti->index = n;\n\tstrscpy(i->name, saa7134_input_name[card_in(dev, n).type],\n\t\tsizeof(i->name));\n\tswitch (card_in(dev, n).type) {\n\tcase SAA7134_INPUT_TV:\n\tcase SAA7134_INPUT_TV_MONO:\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\t\tbreak;\n\tdefault:\n\t\ti->type  = V4L2_INPUT_TYPE_CAMERA;\n\t\tbreak;\n\t}\n\tif (n == dev->ctl_input) {\n\t\tint v1 = saa_readb(SAA7134_STATUS_VIDEO1);\n\t\tint v2 = saa_readb(SAA7134_STATUS_VIDEO2);\n\n\t\tif (0 != (v1 & 0x40))\n\t\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\t\tif (0 != (v2 & 0x40))\n\t\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\t\tif (0 != (v2 & 0x0e))\n\t\t\ti->status |= V4L2_IN_ST_MACROVISION;\n\t}\n\ti->std = SAA7134_NORMS;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_enum_input);\n\nint saa7134_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\t*i = dev->ctl_input;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_g_input);\n\nint saa7134_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (i >= SAA7134_INPUT_MAX)\n\t\treturn -EINVAL;\n\tif (card_in(dev, i).type == SAA7134_NO_INPUT)\n\t\treturn -EINVAL;\n\tvideo_mux(dev, i);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_s_input);\n\nint saa7134_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"saa7134\", sizeof(cap->driver));\n\tstrscpy(cap->card, saa7134_boards[dev->board].name,\n\t\tsizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_RADIO | V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_VBI_CAPTURE | V4L2_CAP_DEVICE_CAPS;\n\tif (dev->tuner_type != TUNER_ABSENT && dev->tuner_type != UNSET)\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\tif (dev->has_rds)\n\t\tcap->capabilities |= V4L2_CAP_RDS_CAPTURE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_querycap);\n\nint saa7134_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tunsigned int i;\n\tv4l2_std_id fixup;\n\n\tfor (i = 0; i < TVNORMS; i++)\n\t\tif (id == tvnorms[i].id)\n\t\t\tbreak;\n\n\tif (i == TVNORMS)\n\t\tfor (i = 0; i < TVNORMS; i++)\n\t\t\tif (id & tvnorms[i].id)\n\t\t\t\tbreak;\n\tif (i == TVNORMS)\n\t\treturn -EINVAL;\n\n\tif ((id & V4L2_STD_SECAM) && (secam[0] != '-')) {\n\t\tif (secam[0] == 'L' || secam[0] == 'l') {\n\t\t\tif (secam[1] == 'C' || secam[1] == 'c')\n\t\t\t\tfixup = V4L2_STD_SECAM_LC;\n\t\t\telse\n\t\t\t\tfixup = V4L2_STD_SECAM_L;\n\t\t} else {\n\t\t\tif (secam[0] == 'D' || secam[0] == 'd')\n\t\t\t\tfixup = V4L2_STD_SECAM_DK;\n\t\t\telse\n\t\t\t\tfixup = V4L2_STD_SECAM;\n\t\t}\n\t\tfor (i = 0; i < TVNORMS; i++) {\n\t\t\tif (fixup == tvnorms[i].id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == TVNORMS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tset_tvnorm(dev, &tvnorms[i]);\n\n\tsaa7134_tvaudio_do_scan(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_s_std);\n\nint saa7134_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\t*id = dev->tvnorm->id;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_g_std);\n\nstatic v4l2_std_id saa7134_read_std(struct saa7134_dev *dev)\n{\n\tstatic v4l2_std_id stds[] = {\n\t\tV4L2_STD_UNKNOWN,\n\t\tV4L2_STD_NTSC,\n\t\tV4L2_STD_PAL,\n\t\tV4L2_STD_SECAM };\n\n\tv4l2_std_id result = 0;\n\n\tu8 st1 = saa_readb(SAA7134_STATUS_VIDEO1);\n\tu8 st2 = saa_readb(SAA7134_STATUS_VIDEO2);\n\n\tif (!(st2 & 0x1))  \n\t\tresult = V4L2_STD_UNKNOWN;\n\telse\n\t\tresult = stds[st1 & 0x03];\n\n\treturn result;\n}\n\nint saa7134_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\t*std &= saa7134_read_std(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_querystd);\n\nstatic int saa7134_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\t int type, struct v4l2_fract *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (dev->tvnorm->id & V4L2_STD_525_60) {\n\t\tf->numerator   = 11;\n\t\tf->denominator = 10;\n\t}\n\tif (dev->tvnorm->id & V4L2_STD_625_50) {\n\t\tf->numerator   = 54;\n\t\tf->denominator = 59;\n\t}\n\treturn 0;\n}\n\nstatic int saa7134_g_selection(struct file *file, void *f, struct v4l2_selection *sel)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = dev->crop_current;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r = dev->crop_defrect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r  = dev->crop_bounds;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int saa7134_s_selection(struct file *file, void *f, struct v4l2_selection *sel)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tstruct v4l2_rect *b = &dev->crop_bounds;\n\tstruct v4l2_rect *c = &dev->crop_current;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_streaming(&dev->video_vbq))\n\t\treturn -EBUSY;\n\n\t*c = sel->r;\n\tif (c->top < b->top)\n\t\tc->top = b->top;\n\tif (c->top > b->top + b->height)\n\t\tc->top = b->top + b->height;\n\tif (c->height > b->top - c->top + b->height)\n\t\tc->height = b->top - c->top + b->height;\n\n\tif (c->left < b->left)\n\t\tc->left = b->left;\n\tif (c->left > b->left + b->width)\n\t\tc->left = b->left + b->width;\n\tif (c->width > b->left - c->left + b->width)\n\t\tc->width = b->left - c->left + b->width;\n\tsel->r = *c;\n\treturn 0;\n}\n\nint saa7134_g_tuner(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tint n;\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\tmemset(t, 0, sizeof(*t));\n\tfor (n = 0; n < SAA7134_INPUT_MAX; n++) {\n\t\tif (card_in(dev, n).type == SAA7134_INPUT_TV ||\n\t\t    card_in(dev, n).type == SAA7134_INPUT_TV_MONO)\n\t\t\tbreak;\n\t}\n\tif (n == SAA7134_INPUT_MAX)\n\t\treturn -EINVAL;\n\tif (card_in(dev, n).type != SAA7134_NO_INPUT) {\n\t\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\t\tt->type = V4L2_TUNER_ANALOG_TV;\n\t\tsaa_call_all(dev, tuner, g_tuner, t);\n\t\tt->capability = V4L2_TUNER_CAP_NORM |\n\t\t\tV4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_LANG1 |\n\t\t\tV4L2_TUNER_CAP_LANG2;\n\t\tt->rxsubchans = saa7134_tvaudio_getstereo(dev);\n\t\tt->audmode = saa7134_tvaudio_rx2mode(t->rxsubchans);\n\t}\n\tif (0 != (saa_readb(SAA7134_STATUS_VIDEO1) & 0x03))\n\t\tt->signal = 0xffff;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_g_tuner);\n\nint saa7134_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\tint rx, mode;\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tmode = dev->thread.mode;\n\tif (UNSET == mode) {\n\t\trx   = saa7134_tvaudio_getstereo(dev);\n\t\tmode = saa7134_tvaudio_rx2mode(rx);\n\t}\n\tif (mode != t->audmode)\n\t\tdev->thread.mode = t->audmode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_s_tuner);\n\nint saa7134_g_frequency(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (0 != f->tuner)\n\t\treturn -EINVAL;\n\n\tsaa_call_all(dev, tuner, g_frequency, f);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_g_frequency);\n\nint saa7134_s_frequency(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (0 != f->tuner)\n\t\treturn -EINVAL;\n\n\tsaa_call_all(dev, tuner, s_frequency, f);\n\n\tsaa7134_tvaudio_do_scan(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_s_frequency);\n\nstatic int saa7134_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= FORMATS)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register (struct file *file, void *priv,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\treg->val = saa_readb(reg->reg & 0xffffff);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int vidioc_s_register (struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tsaa_writeb(reg->reg & 0xffffff, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic int radio_g_tuner(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Radio\", sizeof(t->name));\n\n\tsaa_call_all(dev, tuner, g_tuner, t);\n\tt->audmode &= V4L2_TUNER_MODE_MONO | V4L2_TUNER_MODE_STEREO;\n\tif (dev->input->amux == TV) {\n\t\tt->signal = 0xf800 - ((saa_readb(0x581) & 0x1f) << 11);\n\t\tt->rxsubchans = (saa_readb(0x529) & 0x08) ?\n\t\t\t\tV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\n\t}\n\treturn 0;\n}\nstatic int radio_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct saa7134_dev *dev = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tsaa_call_all(dev, tuner, s_tuner, t);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations video_fops =\n{\n\t.owner\t  = THIS_MODULE,\n\t.open\t  = video_open,\n\t.release  = video_release,\n\t.read\t  = vb2_fop_read,\n\t.poll     = vb2_fop_poll,\n\t.mmap\t  = vb2_fop_mmap,\n\t.unlocked_ioctl\t  = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap\t\t= saa7134_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= saa7134_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= saa7134_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= saa7134_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= saa7134_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap\t\t= saa7134_try_get_set_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap\t\t= saa7134_try_get_set_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap\t\t= saa7134_try_get_set_fmt_vbi_cap,\n\t.vidioc_g_pixelaspect\t\t= saa7134_g_pixelaspect,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_s_std\t\t\t= saa7134_s_std,\n\t.vidioc_g_std\t\t\t= saa7134_g_std,\n\t.vidioc_querystd\t\t= saa7134_querystd,\n\t.vidioc_enum_input\t\t= saa7134_enum_input,\n\t.vidioc_g_input\t\t\t= saa7134_g_input,\n\t.vidioc_s_input\t\t\t= saa7134_s_input,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_g_tuner\t\t\t= saa7134_g_tuner,\n\t.vidioc_s_tuner\t\t\t= saa7134_s_tuner,\n\t.vidioc_g_selection\t\t= saa7134_g_selection,\n\t.vidioc_s_selection\t\t= saa7134_s_selection,\n\t.vidioc_g_frequency\t\t= saa7134_g_frequency,\n\t.vidioc_s_frequency\t\t= saa7134_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register              = vidioc_g_register,\n\t.vidioc_s_register              = vidioc_s_register,\n#endif\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations radio_fops = {\n\t.owner\t  = THIS_MODULE,\n\t.open\t  = video_open,\n\t.read     = radio_read,\n\t.release  = video_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll     = radio_poll,\n};\n\nstatic const struct v4l2_ioctl_ops radio_ioctl_ops = {\n\t.vidioc_querycap\t= saa7134_querycap,\n\t.vidioc_g_tuner\t\t= radio_g_tuner,\n\t.vidioc_s_tuner\t\t= radio_s_tuner,\n\t.vidioc_g_frequency\t= saa7134_g_frequency,\n\t.vidioc_s_frequency\t= saa7134_s_frequency,\n\t.vidioc_subscribe_event\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n \n\nstruct video_device saa7134_video_template = {\n\t.name\t\t\t\t= \"saa7134-video\",\n\t.fops\t\t\t\t= &video_fops,\n\t.ioctl_ops\t\t\t= &video_ioctl_ops,\n\t.tvnorms\t\t\t= SAA7134_NORMS,\n};\n\nstruct video_device saa7134_radio_template = {\n\t.name\t\t\t= \"saa7134-radio\",\n\t.fops\t\t\t= &radio_fops,\n\t.ioctl_ops\t\t= &radio_ioctl_ops,\n};\n\nstatic const struct v4l2_ctrl_ops saa7134_ctrl_ops = {\n\t.s_ctrl = saa7134_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config saa7134_ctrl_invert = {\n\t.ops = &saa7134_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_INVERT,\n\t.name = \"Invert\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config saa7134_ctrl_y_odd = {\n\t.ops = &saa7134_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_Y_ODD,\n\t.name = \"Y Offset Odd Field\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 128,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config saa7134_ctrl_y_even = {\n\t.ops = &saa7134_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_Y_EVEN,\n\t.name = \"Y Offset Even Field\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 128,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config saa7134_ctrl_automute = {\n\t.ops = &saa7134_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_AUTOMUTE,\n\t.name = \"Automute\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nint saa7134_video_init1(struct saa7134_dev *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\n\tstruct vb2_queue *q;\n\tint ret;\n\n\t \n\tif (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)\n\t\tgbuffers = 2;\n\tif (gbufsize > gbufsize_max)\n\t\tgbufsize = gbufsize_max;\n\tgbufsize = (gbufsize + PAGE_SIZE - 1) & PAGE_MASK;\n\n\tv4l2_ctrl_handler_init(hdl, 11);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 127, 1, 68);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, -15, 15, 1, 0);\n\tv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_invert, NULL);\n\tv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_y_odd, NULL);\n\tv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_y_even, NULL);\n\tv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_automute, NULL);\n\tif (hdl->error)\n\t\treturn hdl->error;\n\tif (card_has_radio(dev)) {\n\t\thdl = &dev->radio_ctrl_handler;\n\t\tv4l2_ctrl_handler_init(hdl, 2);\n\t\tv4l2_ctrl_add_handler(hdl, &dev->ctrl_handler,\n\t\t\t\tv4l2_ctrl_radio_filter, false);\n\t\tif (hdl->error)\n\t\t\treturn hdl->error;\n\t}\n\tdev->ctl_mute       = 1;\n\n\tif (dev->tda9887_conf && saa7134_ctrl_automute.def)\n\t\tdev->tda9887_conf |= TDA9887_AUTOMUTE;\n\tdev->automute       = 0;\n\n\tINIT_LIST_HEAD(&dev->video_q.queue);\n\ttimer_setup(&dev->video_q.timeout, saa7134_buffer_timeout, 0);\n\tdev->video_q.dev              = dev;\n\tdev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\n\tdev->width    = 720;\n\tdev->height   = 576;\n\tdev->field = V4L2_FIELD_INTERLACED;\n\n\tif (saa7134_boards[dev->board].video_out)\n\t\tsaa7134_videoport_init(dev);\n\n\tq = &dev->video_vbq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t \n\tq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tif (saa7134_userptr)\n\t\tq->io_modes |= VB2_USERPTR;\n\tq->drv_priv = &dev->video_q;\n\tq->ops = &vb2_qops;\n\tq->gfp_flags = GFP_DMA32;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->buf_struct_size = sizeof(struct saa7134_buf);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\tsaa7134_pgtable_alloc(dev->pci, &dev->video_q.pt);\n\n\tq = &dev->vbi_vbq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\t \n\tq->io_modes = VB2_MMAP | VB2_READ;\n\tif (saa7134_userptr)\n\t\tq->io_modes |= VB2_USERPTR;\n\tq->drv_priv = &dev->vbi_q;\n\tq->ops = &saa7134_vbi_qops;\n\tq->gfp_flags = GFP_DMA32;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->buf_struct_size = sizeof(struct saa7134_buf);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\tsaa7134_pgtable_alloc(dev->pci, &dev->vbi_q.pt);\n\n\treturn 0;\n}\n\nvoid saa7134_video_fini(struct saa7134_dev *dev)\n{\n\tdel_timer_sync(&dev->video_q.timeout);\n\t \n\tsaa7134_pgtable_free(dev->pci, &dev->video_q.pt);\n\tsaa7134_pgtable_free(dev->pci, &dev->vbi_q.pt);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tif (card_has_radio(dev))\n\t\tv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\n}\n\nint saa7134_videoport_init(struct saa7134_dev *dev)\n{\n\t \n\tint vo = saa7134_boards[dev->board].video_out;\n\tint video_reg;\n\tunsigned int vid_port_opts = saa7134_boards[dev->board].vid_port_opts;\n\n\t \n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL0, video_out[vo][0]);\n\tvideo_reg = video_out[vo][1];\n\tif (vid_port_opts & SET_T_CODE_POLARITY_NON_INVERTED)\n\t\tvideo_reg &= ~VP_T_CODE_P_INVERTED;\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL1, video_reg);\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL2, video_out[vo][2]);\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL4, video_out[vo][4]);\n\tvideo_reg = video_out[vo][5];\n\tif (vid_port_opts & SET_CLOCK_NOT_DELAYED)\n\t\tvideo_reg &= ~VP_CLK_CTRL2_DELAYED;\n\tif (vid_port_opts & SET_CLOCK_INVERTED)\n\t\tvideo_reg |= VP_CLK_CTRL1_INVERTED;\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL5, video_reg);\n\tvideo_reg = video_out[vo][6];\n\tif (vid_port_opts & SET_VSYNC_OFF) {\n\t\tvideo_reg &= ~VP_VS_TYPE_MASK;\n\t\tvideo_reg |= VP_VS_TYPE_OFF;\n\t}\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL6, video_reg);\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL7, video_out[vo][7]);\n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL8, video_out[vo][8]);\n\n\t \n\tsaa_writeb(SAA7134_VIDEO_PORT_CTRL3, video_out[vo][3]);\n\n\treturn 0;\n}\n\nint saa7134_video_init2(struct saa7134_dev *dev)\n{\n\t \n\tset_tvnorm(dev,&tvnorms[0]);\n\tvideo_mux(dev,0);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_handler);\n\tsaa7134_tvaudio_setmute(dev);\n\tsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\n\treturn 0;\n}\n\nvoid saa7134_irq_video_signalchange(struct saa7134_dev *dev)\n{\n\tstatic const char *st[] = {\n\t\t\"(no signal)\", \"NTSC\", \"PAL\", \"SECAM\" };\n\tu32 st1,st2;\n\n\tst1 = saa_readb(SAA7134_STATUS_VIDEO1);\n\tst2 = saa_readb(SAA7134_STATUS_VIDEO2);\n\tvideo_dbg(\"DCSDT: pll: %s, sync: %s, norm: %s\\n\",\n\t\t(st1 & 0x40) ? \"not locked\" : \"locked\",\n\t\t(st2 & 0x40) ? \"no\"         : \"yes\",\n\t\tst[st1 & 0x03]);\n\tdev->nosignal = (st1 & 0x40) || (st2 & 0x40)  || !(st2 & 0x1);\n\n\tif (dev->nosignal) {\n\t\t \n\t\tif (dev->ctl_automute)\n\t\t\tdev->automute = 1;\n\t\tsaa7134_tvaudio_setmute(dev);\n\t} else {\n\t\t \n\t\tsaa7134_tvaudio_do_scan(dev);\n\t}\n\n\tif ((st2 & 0x80) && !noninterlaced && !dev->nosignal)\n\t\tsaa_clearb(SAA7134_SYNC_CTRL, 0x20);\n\telse\n\t\tsaa_setb(SAA7134_SYNC_CTRL, 0x20);\n\n\tif (dev->mops && dev->mops->signal_change)\n\t\tdev->mops->signal_change(dev);\n}\n\n\nvoid saa7134_irq_video_done(struct saa7134_dev *dev, unsigned long status)\n{\n\tenum v4l2_field field;\n\n\tspin_lock(&dev->slock);\n\tif (dev->video_q.curr) {\n\t\tfield = dev->field;\n\t\tif (V4L2_FIELD_HAS_BOTH(field)) {\n\t\t\t \n\t\t\tif ((status & 0x10) == 0x00) {\n\t\t\t\tdev->video_q.curr->top_seen = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!dev->video_q.curr->top_seen)\n\t\t\t\tgoto done;\n\t\t} else if (field == V4L2_FIELD_TOP) {\n\t\t\tif ((status & 0x10) != 0x10)\n\t\t\t\tgoto done;\n\t\t} else if (field == V4L2_FIELD_BOTTOM) {\n\t\t\tif ((status & 0x10) != 0x00)\n\t\t\t\tgoto done;\n\t\t}\n\t\tsaa7134_buffer_finish(dev, &dev->video_q, VB2_BUF_STATE_DONE);\n\t}\n\tsaa7134_buffer_next(dev, &dev->video_q);\n\n done:\n\tspin_unlock(&dev->slock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}