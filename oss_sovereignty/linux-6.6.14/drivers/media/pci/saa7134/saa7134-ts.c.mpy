{
  "module_name": "saa7134-ts.c",
  "hash_id": "3de1b8740d88b479068f4251777506627d9bb7686b8749f526cf72703c095afe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7134/saa7134-ts.c",
  "human_readable_source": "\n \n\n#include \"saa7134.h\"\n#include \"saa7134-reg.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n \n\nstatic unsigned int ts_debug;\nmodule_param(ts_debug, int, 0644);\nMODULE_PARM_DESC(ts_debug,\"enable debug messages [ts]\");\n\n#define ts_dbg(fmt, arg...) do { \\\n\tif (ts_debug) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"ts: \" fmt), ## arg); \\\n\t} while (0)\n\n \nstatic int buffer_activate(struct saa7134_dev *dev,\n\t\t\t   struct saa7134_buf *buf,\n\t\t\t   struct saa7134_buf *next)\n{\n\n\tts_dbg(\"buffer_activate [%p]\", buf);\n\tbuf->top_seen = 0;\n\n\tif (!dev->ts_started)\n\t\tdev->ts_field = V4L2_FIELD_TOP;\n\n\tif (NULL == next)\n\t\tnext = buf;\n\tif (V4L2_FIELD_TOP == dev->ts_field) {\n\t\tts_dbg(\"- [top]     buf=%p next=%p\\n\", buf, next);\n\t\tsaa_writel(SAA7134_RS_BA1(5),saa7134_buffer_base(buf));\n\t\tsaa_writel(SAA7134_RS_BA2(5),saa7134_buffer_base(next));\n\t\tdev->ts_field = V4L2_FIELD_BOTTOM;\n\t} else {\n\t\tts_dbg(\"- [bottom]  buf=%p next=%p\\n\", buf, next);\n\t\tsaa_writel(SAA7134_RS_BA1(5),saa7134_buffer_base(next));\n\t\tsaa_writel(SAA7134_RS_BA2(5),saa7134_buffer_base(buf));\n\t\tdev->ts_field = V4L2_FIELD_TOP;\n\t}\n\n\t \n\tsaa7134_set_dmabits(dev);\n\n\tmod_timer(&dev->ts_q.timeout, jiffies+TS_BUFFER_TIMEOUT);\n\n\tif (!dev->ts_started)\n\t\tsaa7134_ts_start(dev);\n\n\treturn 0;\n}\n\nint saa7134_ts_buffer_init(struct vb2_buffer *vb2)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\n\tdmaq->curr = NULL;\n\tbuf->activate = buffer_activate;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_ts_buffer_init);\n\nint saa7134_ts_buffer_prepare(struct vb2_buffer *vb2)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tstruct saa7134_buf *buf = container_of(vbuf, struct saa7134_buf, vb2);\n\tstruct sg_table *dma = vb2_dma_sg_plane_desc(vb2, 0);\n\tunsigned int lines, llength, size;\n\n\tts_dbg(\"buffer_prepare [%p]\\n\", buf);\n\n\tllength = TS_PACKET_SIZE;\n\tlines = dev->ts.nr_packets;\n\n\tsize = lines * llength;\n\tif (vb2_plane_size(vb2, 0) < size)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb2, 0, size);\n\tvbuf->field = dev->field;\n\n\treturn saa7134_pgtable_build(dev->pci, &dmaq->pt, dma->sgl, dma->nents,\n\t\t\t\t    saa7134_buffer_startpage(buf));\n}\nEXPORT_SYMBOL_GPL(saa7134_ts_buffer_prepare);\n\nint saa7134_ts_queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct saa7134_dmaqueue *dmaq = q->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\tint size = TS_PACKET_SIZE * dev->ts.nr_packets;\n\n\tif (0 == *nbuffers)\n\t\t*nbuffers = dev->ts.nr_bufs;\n\t*nbuffers = saa7134_buffer_count(size, *nbuffers);\n\tif (*nbuffers < 3)\n\t\t*nbuffers = 3;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_ts_queue_setup);\n\nint saa7134_ts_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\n\t \n\tif (vb2_is_busy(&dev->video_vbq) && dev->fmt->planar) {\n\t\tstruct saa7134_buf *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dmaq->queue, entry) {\n\t\t\tlist_del(&buf->entry);\n\t\t\tvb2_buffer_done(&buf->vb2.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t\tif (dmaq->curr) {\n\t\t\tvb2_buffer_done(&dmaq->curr->vb2.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t\tdmaq->curr = NULL;\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\tdmaq->seq_nr = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7134_ts_start_streaming);\n\nvoid saa7134_ts_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\n\tstruct saa7134_dev *dev = dmaq->dev;\n\n\tsaa7134_ts_stop(dev);\n\tsaa7134_stop_streaming(dev, dmaq);\n}\nEXPORT_SYMBOL_GPL(saa7134_ts_stop_streaming);\n\nstruct vb2_ops saa7134_ts_qops = {\n\t.queue_setup\t= saa7134_ts_queue_setup,\n\t.buf_init\t= saa7134_ts_buffer_init,\n\t.buf_prepare\t= saa7134_ts_buffer_prepare,\n\t.buf_queue\t= saa7134_vb2_buffer_queue,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.stop_streaming = saa7134_ts_stop_streaming,\n};\nEXPORT_SYMBOL_GPL(saa7134_ts_qops);\n\n \n \n\nstatic unsigned int tsbufs = 8;\nmodule_param(tsbufs, int, 0444);\nMODULE_PARM_DESC(tsbufs, \"number of ts buffers for read/write IO, range 2-32\");\n\nstatic unsigned int ts_nr_packets = 64;\nmodule_param(ts_nr_packets, int, 0444);\nMODULE_PARM_DESC(ts_nr_packets,\"size of a ts buffers (in ts packets)\");\n\nint saa7134_ts_init_hw(struct saa7134_dev *dev)\n{\n\t \n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x00);\n\t \n\tsaa_writeb(SAA7134_TS_PARALLEL, 0x6c);\n\tsaa_writeb(SAA7134_TS_PARALLEL_SERIAL, (TS_PACKET_SIZE-1));\n\tsaa_writeb(SAA7134_TS_DMA0, ((dev->ts.nr_packets-1)&0xff));\n\tsaa_writeb(SAA7134_TS_DMA1, (((dev->ts.nr_packets-1)>>8)&0xff));\n\t \n\tsaa_writeb(SAA7134_TS_DMA2,\n\t\t((((dev->ts.nr_packets-1)>>16)&0x3f) | 0x00));\n\n\treturn 0;\n}\n\nint saa7134_ts_init1(struct saa7134_dev *dev)\n{\n\t \n\tif (tsbufs < 2)\n\t\ttsbufs = 2;\n\tif (tsbufs > VIDEO_MAX_FRAME)\n\t\ttsbufs = VIDEO_MAX_FRAME;\n\tif (ts_nr_packets < 4)\n\t\tts_nr_packets = 4;\n\tif (ts_nr_packets > 312)\n\t\tts_nr_packets = 312;\n\tdev->ts.nr_bufs    = tsbufs;\n\tdev->ts.nr_packets = ts_nr_packets;\n\n\tINIT_LIST_HEAD(&dev->ts_q.queue);\n\ttimer_setup(&dev->ts_q.timeout, saa7134_buffer_timeout, 0);\n\tdev->ts_q.dev              = dev;\n\tdev->ts_q.need_two         = 1;\n\tdev->ts_started            = 0;\n\tsaa7134_pgtable_alloc(dev->pci, &dev->ts_q.pt);\n\n\t \n\tsaa7134_ts_init_hw(dev);\n\n\treturn 0;\n}\n\n \nint saa7134_ts_stop(struct saa7134_dev *dev)\n{\n\tts_dbg(\"TS stop\\n\");\n\n\tif (!dev->ts_started)\n\t\treturn 0;\n\n\t \n\tswitch (saa7134_boards[dev->board].ts_type) {\n\tcase SAA7134_MPEG_TS_PARALLEL:\n\t\tsaa_writeb(SAA7134_TS_PARALLEL, 0x6c);\n\t\tdev->ts_started = 0;\n\t\tbreak;\n\tcase SAA7134_MPEG_TS_SERIAL:\n\t\tsaa_writeb(SAA7134_TS_SERIAL0, 0x40);\n\t\tdev->ts_started = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint saa7134_ts_start(struct saa7134_dev *dev)\n{\n\tts_dbg(\"TS start\\n\");\n\n\tif (WARN_ON(dev->ts_started))\n\t\treturn 0;\n\n\t \n\tsaa_writeb(SAA7134_TS_DMA0, (dev->ts.nr_packets - 1) & 0xff);\n\tsaa_writeb(SAA7134_TS_DMA1,\n\t\t((dev->ts.nr_packets - 1) >> 8) & 0xff);\n\t \n\tsaa_writeb(SAA7134_TS_DMA2,\n\t\t(((dev->ts.nr_packets - 1) >> 16) & 0x3f) | 0x00);\n\tsaa_writel(SAA7134_RS_PITCH(5), TS_PACKET_SIZE);\n\tsaa_writel(SAA7134_RS_CONTROL(5), SAA7134_RS_CONTROL_BURST_16 |\n\t\t\t\t\t  SAA7134_RS_CONTROL_ME |\n\t\t\t\t\t  (dev->ts_q.pt.dma >> 12));\n\n\t \n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x00);\n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x03);\n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x00);\n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x01);\n\n\t \n\tsaa_writeb(SAA7134_TS_SERIAL1, 0x00);\n\n\t \n\tswitch (saa7134_boards[dev->board].ts_type) {\n\tcase SAA7134_MPEG_TS_PARALLEL:\n\t\tsaa_writeb(SAA7134_TS_SERIAL0, 0x40);\n\t\tsaa_writeb(SAA7134_TS_PARALLEL, 0xec |\n\t\t\t(saa7134_boards[dev->board].ts_force_val << 4));\n\t\tbreak;\n\tcase SAA7134_MPEG_TS_SERIAL:\n\t\tsaa_writeb(SAA7134_TS_SERIAL0, 0xd8);\n\t\tsaa_writeb(SAA7134_TS_PARALLEL, 0x6c |\n\t\t\t(saa7134_boards[dev->board].ts_force_val << 4));\n\t\tsaa_writeb(SAA7134_TS_PARALLEL_SERIAL, 0xbc);\n\t\tsaa_writeb(SAA7134_TS_SERIAL1, 0x02);\n\t\tbreak;\n\t}\n\n\tdev->ts_started = 1;\n\n\treturn 0;\n}\n\nint saa7134_ts_fini(struct saa7134_dev *dev)\n{\n\tdel_timer_sync(&dev->ts_q.timeout);\n\tsaa7134_pgtable_free(dev->pci, &dev->ts_q.pt);\n\treturn 0;\n}\n\nvoid saa7134_irq_ts_done(struct saa7134_dev *dev, unsigned long status)\n{\n\tenum v4l2_field field;\n\n\tspin_lock(&dev->slock);\n\tif (dev->ts_q.curr) {\n\t\tfield = dev->ts_field;\n\t\tif (field != V4L2_FIELD_TOP) {\n\t\t\tif ((status & 0x100000) != 0x000000)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tif ((status & 0x100000) != 0x100000)\n\t\t\t\tgoto done;\n\t\t}\n\t\tsaa7134_buffer_finish(dev, &dev->ts_q, VB2_BUF_STATE_DONE);\n\t}\n\tsaa7134_buffer_next(dev,&dev->ts_q);\n\n done:\n\tspin_unlock(&dev->slock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}