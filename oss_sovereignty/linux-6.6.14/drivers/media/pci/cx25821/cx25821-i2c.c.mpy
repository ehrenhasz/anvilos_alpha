{
  "module_name": "cx25821-i2c.c",
  "hash_id": "2cb5e797ea6227e754b444ac50f63b35c7244428ef65ed50b379a20aa1e70daa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx25821/cx25821-i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include \"cx25821.h\"\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"enable debug messages [i2c]\");\n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (i2c_debug >= level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s/0: \" fmt, dev->name, ##arg);\t\\\n} while (0)\n\n#define I2C_WAIT_DELAY 32\n#define I2C_WAIT_RETRY 64\n\n#define I2C_EXTEND  (1 << 3)\n#define I2C_NOSTOP  (1 << 4)\n\nstatic inline int i2c_slave_did_ack(struct i2c_adapter *i2c_adap)\n{\n\tstruct cx25821_i2c *bus = i2c_adap->algo_data;\n\tstruct cx25821_dev *dev = bus->dev;\n\treturn cx_read(bus->reg_stat) & 0x01;\n}\n\nstatic inline int i2c_is_busy(struct i2c_adapter *i2c_adap)\n{\n\tstruct cx25821_i2c *bus = i2c_adap->algo_data;\n\tstruct cx25821_dev *dev = bus->dev;\n\treturn cx_read(bus->reg_stat) & 0x02 ? 1 : 0;\n}\n\nstatic int i2c_wait_done(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (!i2c_is_busy(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int i2c_sendbytes(struct i2c_adapter *i2c_adap,\n\t\t\t const struct i2c_msg *msg, int joined_rlen)\n{\n\tstruct cx25821_i2c *bus = i2c_adap->algo_data;\n\tstruct cx25821_dev *dev = bus->dev;\n\tu32 wdata, addr, ctrl;\n\tint retval, cnt;\n\n\tif (joined_rlen)\n\t\tdprintk(1, \"%s(msg->wlen=%d, nextmsg->rlen=%d)\\n\", __func__,\n\t\t\tmsg->len, joined_rlen);\n\telse\n\t\tdprintk(1, \"%s(msg->len=%d)\\n\", __func__, msg->len);\n\n\t \n\tif (msg->len == 0) {\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));\n\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\tif (!i2c_slave_did_ack(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\tdprintk(1, \"%s(): returns 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\taddr = (msg->addr << 25) | msg->buf[0];\n\twdata = msg->buf[0];\n\n\tctrl = bus->i2c_period | (1 << 12) | (1 << 2);\n\n\tif (msg->len > 1)\n\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\telse if (joined_rlen)\n\t\tctrl |= I2C_NOSTOP;\n\n\tcx_write(bus->reg_addr, addr);\n\tcx_write(bus->reg_wdata, wdata);\n\tcx_write(bus->reg_ctrl, ctrl);\n\n\tretval = i2c_wait_done(i2c_adap);\n\tif (retval < 0)\n\t\tgoto err;\n\n\tif (retval == 0)\n\t\tgoto eio;\n\n\tif (i2c_debug) {\n\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\tprintk(\" >\\n\");\n\t}\n\n\tfor (cnt = 1; cnt < msg->len; cnt++) {\n\t\t \n\t\twdata = msg->buf[cnt];\n\t\tctrl = bus->i2c_period | (1 << 12) | (1 << 2);\n\n\t\tif (cnt < msg->len - 1)\n\t\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\t\telse if (joined_rlen)\n\t\t\tctrl |= I2C_NOSTOP;\n\n\t\tcx_write(bus->reg_addr, addr);\n\t\tcx_write(bus->reg_wdata, wdata);\n\t\tcx_write(bus->reg_ctrl, ctrl);\n\n\t\tretval = i2c_wait_done(i2c_adap);\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\n\t\tif (retval == 0)\n\t\t\tgoto eio;\n\n\t\tif (i2c_debug) {\n\t\t\tdprintk(1, \" %02x\", msg->buf[cnt]);\n\t\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\t\tdprintk(1, \" >\\n\");\n\t\t}\n\t}\n\n\treturn msg->len;\n\neio:\n\tretval = -EIO;\nerr:\n\tif (i2c_debug)\n\t\tpr_err(\" ERR: %d\\n\", retval);\n\treturn retval;\n}\n\nstatic int i2c_readbytes(struct i2c_adapter *i2c_adap,\n\t\t\t const struct i2c_msg *msg, int joined)\n{\n\tstruct cx25821_i2c *bus = i2c_adap->algo_data;\n\tstruct cx25821_dev *dev = bus->dev;\n\tu32 ctrl, cnt;\n\tint retval;\n\n\tif (i2c_debug && !joined)\n\t\tdprintk(1, \"6-%s(msg->len=%d)\\n\", __func__, msg->len);\n\n\t \n\tif (msg->len == 0) {\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\treturn -EIO;\n\t\tif (!i2c_slave_did_ack(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\tdprintk(1, \"%s(): returns 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (i2c_debug) {\n\t\tif (joined)\n\t\t\tdprintk(1, \" R\");\n\t\telse\n\t\t\tdprintk(1, \" <R %02x\", (msg->addr << 1) + 1);\n\t}\n\n\tfor (cnt = 0; cnt < msg->len; cnt++) {\n\n\t\tctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;\n\n\t\tif (cnt < msg->len - 1)\n\t\t\tctrl |= I2C_NOSTOP | I2C_EXTEND;\n\n\t\tcx_write(bus->reg_addr, msg->addr << 25);\n\t\tcx_write(bus->reg_ctrl, ctrl);\n\n\t\tretval = i2c_wait_done(i2c_adap);\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t\tif (retval == 0)\n\t\t\tgoto eio;\n\t\tmsg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;\n\n\t\tif (i2c_debug) {\n\t\t\tdprintk(1, \" %02x\", msg->buf[cnt]);\n\t\t\tif (!(ctrl & I2C_NOSTOP))\n\t\t\t\tdprintk(1, \" >\\n\");\n\t\t}\n\t}\n\n\treturn msg->len;\neio:\n\tretval = -EIO;\nerr:\n\tif (i2c_debug)\n\t\tpr_err(\" ERR: %d\\n\", retval);\n\treturn retval;\n}\n\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\n{\n\tstruct cx25821_i2c *bus = i2c_adap->algo_data;\n\tstruct cx25821_dev *dev = bus->dev;\n\tint i, retval = 0;\n\n\tdprintk(1, \"%s(num = %d)\\n\", __func__, num);\n\n\tfor (i = 0; i < num; i++) {\n\t\tdprintk(1, \"%s(num = %d) addr = 0x%02x  len = 0x%x\\n\",\n\t\t\t__func__, num, msgs[i].addr, msgs[i].len);\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 0);\n\t\t} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr) {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i],\n\t\t\t\t\tmsgs[i + 1].len);\n\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t\ti++;\n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 1);\n\t\t} else {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i], 0);\n\t\t}\n\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t}\n\treturn num;\n\nerr:\n\treturn retval;\n}\n\n\nstatic u32 cx25821_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C | I2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_READ_WORD_DATA | I2C_FUNC_SMBUS_WRITE_WORD_DATA;\n}\n\nstatic const struct i2c_algorithm cx25821_i2c_algo_template = {\n\t.master_xfer = i2c_xfer,\n\t.functionality = cx25821_functionality,\n#ifdef NEED_ALGO_CONTROL\n\t.algo_control = dummy_algo_control,\n#endif\n};\n\nstatic const struct i2c_adapter cx25821_i2c_adap_template = {\n\t.name = \"cx25821\",\n\t.owner = THIS_MODULE,\n\t.algo = &cx25821_i2c_algo_template,\n};\n\nstatic const struct i2c_client cx25821_i2c_client_template = {\n\t.name = \"cx25821 internal\",\n};\n\n \nint cx25821_i2c_register(struct cx25821_i2c *bus)\n{\n\tstruct cx25821_dev *dev = bus->dev;\n\n\tdprintk(1, \"%s(bus = %d)\\n\", __func__, bus->nr);\n\n\tbus->i2c_adap = cx25821_i2c_adap_template;\n\tbus->i2c_client = cx25821_i2c_client_template;\n\tbus->i2c_adap.dev.parent = &dev->pci->dev;\n\n\tstrscpy(bus->i2c_adap.name, bus->dev->name, sizeof(bus->i2c_adap.name));\n\n\tbus->i2c_adap.algo_data = bus;\n\ti2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);\n\ti2c_add_adapter(&bus->i2c_adap);\n\n\tbus->i2c_client.adapter = &bus->i2c_adap;\n\n\t \n\tbus->i2c_client.addr = (0x88 >> 1);\n\n\treturn bus->i2c_rc;\n}\n\nint cx25821_i2c_unregister(struct cx25821_i2c *bus)\n{\n\ti2c_del_adapter(&bus->i2c_adap);\n\treturn 0;\n}\n\n#if 0  \nstatic void cx25821_av_clk(struct cx25821_dev *dev, int enable)\n{\n\t \n\tchar buffer[3];\n\tstruct i2c_msg msg;\n\tdprintk(1, \"%s(enabled = %d)\\n\", __func__, enable);\n\n\t \n\tbuffer[0] = 0x01;\n\tbuffer[1] = 0x44;\n\tif (enable == 1)\n\t\tbuffer[2] = 0x05;\n\telse\n\t\tbuffer[2] = 0x00;\n\n\tmsg.addr = 0x44;\n\tmsg.flags = I2C_M_TEN;\n\tmsg.len = 3;\n\tmsg.buf = buffer;\n\n\ti2c_xfer(&dev->i2c_bus[0].i2c_adap, &msg, 1);\n}\n#endif\n\nint cx25821_i2c_read(struct cx25821_i2c *bus, u16 reg_addr, int *value)\n{\n\tstruct i2c_client *client = &bus->i2c_client;\n\tint v = 0;\n\tu8 addr[2] = { 0, 0 };\n\tu8 buf[4] = { 0, 0, 0, 0 };\n\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = addr,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 4,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\taddr[0] = (reg_addr >> 8);\n\taddr[1] = (reg_addr & 0xff);\n\tmsgs[0].addr = 0x44;\n\tmsgs[1].addr = 0x44;\n\n\ti2c_xfer(client->adapter, msgs, 2);\n\n\tv = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\n\t*value = v;\n\n\treturn v;\n}\n\nint cx25821_i2c_write(struct cx25821_i2c *bus, u16 reg_addr, int value)\n{\n\tstruct i2c_client *client = &bus->i2c_client;\n\tint retval = 0;\n\tu8 buf[6] = { 0, 0, 0, 0, 0, 0 };\n\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 6,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tbuf[0] = reg_addr >> 8;\n\tbuf[1] = reg_addr & 0xff;\n\tbuf[5] = (value >> 24) & 0xff;\n\tbuf[4] = (value >> 16) & 0xff;\n\tbuf[3] = (value >> 8) & 0xff;\n\tbuf[2] = value & 0xff;\n\tclient->flags = 0;\n\tmsgs[0].addr = 0x44;\n\n\tretval = i2c_xfer(client->adapter, msgs, 1);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}