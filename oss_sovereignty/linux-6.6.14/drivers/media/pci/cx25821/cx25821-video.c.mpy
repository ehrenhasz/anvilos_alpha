{
  "module_name": "cx25821-video.c",
  "hash_id": "cff5b2e9bd3c42e288a022120faca88eac3b355c317c2825fd28bc9a2d58ea27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx25821/cx25821-video.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"cx25821-video.h\"\n\nMODULE_DESCRIPTION(\"v4l2 driver module for cx25821 based TV cards\");\nMODULE_AUTHOR(\"Hiep Huynh <hiep.huynh@conexant.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int video_nr[] = {[0 ... (CX25821_MAXBOARDS - 1)] = UNSET };\n\nmodule_param_array(video_nr, int, NULL, 0444);\n\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\n\nstatic unsigned int video_debug = VIDEO_DEBUG;\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug, \"enable debug messages [video]\");\n\nstatic unsigned int irq_debug;\nmodule_param(irq_debug, int, 0644);\nMODULE_PARM_DESC(irq_debug, \"enable debug messages [IRQ handler]\");\n\n#define FORMAT_FLAGS_PACKED       0x01\n\nstatic const struct cx25821_fmt formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_Y41P,\n\t\t.depth = 12,\n\t\t.flags = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.depth = 16,\n\t\t.flags = FORMAT_FLAGS_PACKED,\n\t},\n};\n\nstatic const struct cx25821_fmt *cx25821_format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\treturn NULL;\n}\n\nint cx25821_start_video_dma(struct cx25821_dev *dev,\n\t\t\t    struct cx25821_dmaqueue *q,\n\t\t\t    struct cx25821_buffer *buf,\n\t\t\t    const struct sram_channel *channel)\n{\n\tint tmp = 0;\n\n\t \n\tcx25821_sram_channel_setup(dev, channel, buf->bpl, buf->risc.dma);\n\n\t \n\tcx_write(channel->gpcnt_ctl, 3);\n\n\t \n\tcx_set(PCI_INT_MSK, cx_read(PCI_INT_MSK) | (1 << channel->i));\n\tcx_set(channel->int_msk, 0x11);\n\n\t \n\tcx_write(channel->dma_ctl, 0x11);\t \n\n\t \n\ttmp = cx_read(VID_CH_MODE_SEL);\n\tcx_write(VID_CH_MODE_SEL, tmp & 0xFFFFFE00);\n\n\treturn 0;\n}\n\nint cx25821_video_irq(struct cx25821_dev *dev, int chan_num, u32 status)\n{\n\tint handled = 0;\n\tu32 mask;\n\tconst struct sram_channel *channel = dev->channels[chan_num].sram_channels;\n\n\tmask = cx_read(channel->int_msk);\n\tif (0 == (status & mask))\n\t\treturn handled;\n\n\tcx_write(channel->int_stat, status);\n\n\t \n\tif (status & (1 << 16)) {\n\t\tpr_warn(\"%s, %s: video risc op code error\\n\",\n\t\t\tdev->name, channel->name);\n\t\tcx_clear(channel->dma_ctl, 0x11);\n\t\tcx25821_sram_channel_dump(dev, channel);\n\t}\n\n\t \n\tif (status & FLD_VID_DST_RISC1) {\n\t\tstruct cx25821_dmaqueue *dmaq =\n\t\t\t&dev->channels[channel->i].dma_vidq;\n\t\tstruct cx25821_buffer *buf;\n\n\t\tspin_lock(&dev->slock);\n\t\tif (!list_empty(&dmaq->active)) {\n\t\t\tbuf = list_entry(dmaq->active.next,\n\t\t\t\t\t struct cx25821_buffer, queue);\n\n\t\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\tbuf->vb.sequence = dmaq->count++;\n\t\t\tlist_del(&buf->queue);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\t}\n\t\tspin_unlock(&dev->slock);\n\t\thandled++;\n\t}\n\treturn handled;\n}\n\nstatic int cx25821_queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx25821_channel *chan = q->drv_priv;\n\tunsigned size = (chan->fmt->depth * chan->width * chan->height) >> 3;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int cx25821_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx25821_channel *chan = vb->vb2_queue->drv_priv;\n\tstruct cx25821_dev *dev = chan->dev;\n\tstruct cx25821_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx25821_buffer, vb);\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tu32 line0_offset;\n\tint bpl_local = LINE_SIZE_D1;\n\tint ret;\n\n\tif (chan->pixel_formats == PIXEL_FRMT_411)\n\t\tbuf->bpl = (chan->fmt->depth * chan->width) >> 3;\n\telse\n\t\tbuf->bpl = (chan->fmt->depth >> 3) * chan->width;\n\n\tif (vb2_plane_size(vb, 0) < chan->height * buf->bpl)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, chan->height * buf->bpl);\n\tbuf->vb.field = chan->field;\n\n\tif (chan->pixel_formats == PIXEL_FRMT_411) {\n\t\tbpl_local = buf->bpl;\n\t} else {\n\t\tbpl_local = buf->bpl;    \n\n\t\tif (chan->use_cif_resolution) {\n\t\t\tif (dev->tvnorm & V4L2_STD_625_50)\n\t\t\t\tbpl_local = 352 << 1;\n\t\t\telse\n\t\t\t\tbpl_local = chan->cif_width << 1;\n\t\t}\n\t}\n\n\tswitch (chan->field) {\n\tcase V4L2_FIELD_TOP:\n\t\tret = cx25821_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, 0, UNSET,\n\t\t\t\tbuf->bpl, 0, chan->height);\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tret = cx25821_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, UNSET, 0,\n\t\t\t\tbuf->bpl, 0, chan->height);\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\t\t \n\t\tline0_offset = 0;\n\t\tdprintk(1, \"top field first\\n\");\n\n\t\tret = cx25821_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl, line0_offset,\n\t\t\t\tbpl_local, bpl_local, bpl_local,\n\t\t\t\tchan->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tret = cx25821_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl,\n\t\t\t\t0, buf->bpl * (chan->height >> 1),\n\t\t\t\tbuf->bpl, 0, chan->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tret = cx25821_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl,\n\t\t\t\tbuf->bpl * (chan->height >> 1), 0,\n\t\t\t\tbuf->bpl, 0, chan->height >> 1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tdprintk(2, \"[%p/%d] buffer_prep - %dx%d %dbpp 0x%08x - dma=0x%08lx\\n\",\n\t\tbuf, buf->vb.vb2_buf.index, chan->width, chan->height,\n\t\tchan->fmt->depth, chan->fmt->fourcc,\n\t\t(unsigned long)buf->risc.dma);\n\n\treturn ret;\n}\n\nstatic void cx25821_buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx25821_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx25821_buffer, vb);\n\tstruct cx25821_channel *chan = vb->vb2_queue->drv_priv;\n\tstruct cx25821_dev *dev = chan->dev;\n\n\tcx25821_free_buffer(dev, buf);\n}\n\nstatic void cx25821_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx25821_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx25821_buffer, vb);\n\tstruct cx25821_channel *chan = vb->vb2_queue->drv_priv;\n\tstruct cx25821_dev *dev = chan->dev;\n\tstruct cx25821_buffer *prev;\n\tstruct cx25821_dmaqueue *q = &dev->channels[chan->id].dma_vidq;\n\n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[2] = cpu_to_le32(0);  \n\n\tif (list_empty(&q->active)) {\n\t\tlist_add_tail(&buf->queue, &q->active);\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tprev = list_entry(q->active.prev, struct cx25821_buffer,\n\t\t\t\tqueue);\n\t\tlist_add_tail(&buf->queue, &q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t}\n}\n\nstatic int cx25821_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx25821_channel *chan = q->drv_priv;\n\tstruct cx25821_dev *dev = chan->dev;\n\tstruct cx25821_dmaqueue *dmaq = &dev->channels[chan->id].dma_vidq;\n\tstruct cx25821_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx25821_buffer, queue);\n\n\tdmaq->count = 0;\n\tcx25821_start_video_dma(dev, dmaq, buf, chan->sram_channels);\n\treturn 0;\n}\n\nstatic void cx25821_stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx25821_channel *chan = q->drv_priv;\n\tstruct cx25821_dev *dev = chan->dev;\n\tstruct cx25821_dmaqueue *dmaq = &dev->channels[chan->id].dma_vidq;\n\tunsigned long flags;\n\n\tcx_write(chan->sram_channels->dma_ctl, 0);  \n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx25821_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx25821_buffer, queue);\n\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic const struct vb2_ops cx25821_video_qops = {\n\t.queue_setup    = cx25821_queue_setup,\n\t.buf_prepare  = cx25821_buffer_prepare,\n\t.buf_finish = cx25821_buffer_finish,\n\t.buf_queue    = cx25821_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = cx25821_start_streaming,\n\t.stop_streaming = cx25821_stop_streaming,\n};\n\n \n\nstatic int cx25821_vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tif (unlikely(f->index >= ARRAY_SIZE(formats)))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\n\tf->fmt.pix.width = chan->width;\n\tf->fmt.pix.height = chan->height;\n\tf->fmt.pix.field = chan->field;\n\tf->fmt.pix.pixelformat = chan->fmt->fourcc;\n\tf->fmt.pix.bytesperline = (chan->width * chan->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = chan->height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\tconst struct cx25821_fmt *fmt;\n\tenum v4l2_field field = f->fmt.pix.field;\n\tunsigned int maxh;\n\tunsigned w;\n\n\tfmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\tmaxh = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\n\n\tw = f->fmt.pix.width;\n\tif (field != V4L2_FIELD_BOTTOM)\n\t\tfield = V4L2_FIELD_TOP;\n\tif (w < 352) {\n\t\tw = 176;\n\t\tf->fmt.pix.height = maxh / 4;\n\t} else if (w < 720) {\n\t\tw = 352;\n\t\tf->fmt.pix.height = maxh / 2;\n\t} else {\n\t\tw = 720;\n\t\tf->fmt.pix.height = maxh;\n\t\tfield = V4L2_FIELD_INTERLACED;\n\t}\n\tf->fmt.pix.field = field;\n\tf->fmt.pix.width = w;\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\tint pix_format = PIXEL_FRMT_422;\n\tint err;\n\n\terr = cx25821_vidioc_try_fmt_vid_cap(file, priv, f);\n\n\tif (0 != err)\n\t\treturn err;\n\n\tchan->fmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\n\tchan->field = f->fmt.pix.field;\n\tchan->width = f->fmt.pix.width;\n\tchan->height = f->fmt.pix.height;\n\n\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_Y41P)\n\t\tpix_format = PIXEL_FRMT_411;\n\telse\n\t\tpix_format = PIXEL_FRMT_422;\n\n\tcx25821_set_pixel_format(dev, SRAM_CH00, pix_format);\n\n\t \n\tif (chan->width == 320 || chan->width == 352)\n\t\tchan->use_cif_resolution = 1;\n\telse\n\t\tchan->use_cif_resolution = 0;\n\n\tchan->cif_width = chan->width;\n\tmedusa_set_resolution(dev, chan->width, SRAM_CH00);\n\treturn 0;\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\tconst struct sram_channel *sram_ch = chan->sram_channels;\n\tu32 tmp = 0;\n\n\ttmp = cx_read(sram_ch->dma_ctl);\n\tpr_info(\"Video input 0 is %s\\n\",\n\t\t(tmp & 0x11) ? \"streaming\" : \"stopped\");\n\treturn 0;\n}\n\n\nstatic int cx25821_vidioc_querycap(struct file *file, void *priv,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\n\tstrscpy(cap->driver, \"cx25821\", sizeof(cap->driver));\n\tstrscpy(cap->card, cx25821_boards[dev->board].name, sizeof(cap->card));\n\tsprintf(cap->bus_info, \"PCIe:%s\", pci_name(dev->pci));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorms)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\n\t*tvnorms = chan->dev->tvnorm;\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_s_std(struct file *file, void *priv,\n\t\t\t\tv4l2_std_id tvnorms)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\n\tif (dev->tvnorm == tvnorms)\n\t\treturn 0;\n\n\tdev->tvnorm = tvnorms;\n\tchan->width = 720;\n\tchan->height = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\n\n\tmedusa_set_videostandard(dev);\n\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t      struct v4l2_input *i)\n{\n\tif (i->index)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\ti->std = CX25821_NORMS;\n\tstrscpy(i->name, \"Composite\", sizeof(i->name));\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn i ? -EINVAL : 0;\n}\n\nstatic int cx25821_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct cx25821_channel *chan =\n\t\tcontainer_of(ctrl->handler, struct cx25821_channel, hdl);\n\tstruct cx25821_dev *dev = chan->dev;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tmedusa_set_brightness(dev, ctrl->val, chan->id);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tmedusa_set_hue(dev, ctrl->val, chan->id);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tmedusa_set_contrast(dev, ctrl->val, chan->id);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tmedusa_set_saturation(dev, ctrl->val, chan->id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_enum_output(struct file *file, void *priv,\n\t\t\t      struct v4l2_output *o)\n{\n\tif (o->index)\n\t\treturn -EINVAL;\n\n\to->type = V4L2_INPUT_TYPE_CAMERA;\n\to->std = CX25821_NORMS;\n\tstrscpy(o->name, \"Composite\", sizeof(o->name));\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_g_output(struct file *file, void *priv, unsigned int *o)\n{\n\t*o = 0;\n\treturn 0;\n}\n\nstatic int cx25821_vidioc_s_output(struct file *file, void *priv, unsigned int o)\n{\n\treturn o ? -EINVAL : 0;\n}\n\nstatic int cx25821_vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tstruct cx25821_dev *dev = chan->dev;\n\tconst struct cx25821_fmt *fmt;\n\n\tfmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\tf->fmt.pix.width = 720;\n\tf->fmt.pix.height = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx25821_channel *chan = video_drvdata(file);\n\tint err;\n\n\terr = cx25821_vidioc_try_fmt_vid_out(file, priv, f);\n\n\tif (0 != err)\n\t\treturn err;\n\n\tchan->fmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\n\tchan->field = f->fmt.pix.field;\n\tchan->width = f->fmt.pix.width;\n\tchan->height = f->fmt.pix.height;\n\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_Y41P)\n\t\tchan->pixel_formats = PIXEL_FRMT_411;\n\telse\n\t\tchan->pixel_formats = PIXEL_FRMT_422;\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops cx25821_ctrl_ops = {\n\t.s_ctrl = cx25821_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release        = vb2_fop_release,\n\t.read           = vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap = cx25821_vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = cx25821_vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = cx25821_vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = cx25821_vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_prepare_buf   = vb2_ioctl_prepare_buf,\n\t.vidioc_create_bufs   = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_g_std = cx25821_vidioc_g_std,\n\t.vidioc_s_std = cx25821_vidioc_s_std,\n\t.vidioc_enum_input = cx25821_vidioc_enum_input,\n\t.vidioc_g_input = cx25821_vidioc_g_input,\n\t.vidioc_s_input = cx25821_vidioc_s_input,\n\t.vidioc_log_status = vidioc_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device cx25821_video_device = {\n\t.name = \"cx25821-video\",\n\t.fops = &video_fops,\n\t.release = video_device_release_empty,\n\t.minor = -1,\n\t.ioctl_ops = &video_ioctl_ops,\n\t.tvnorms = CX25821_NORMS,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t       V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_file_operations video_out_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release        = vb2_fop_release,\n\t.write          = vb2_fop_write,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops video_out_ioctl_ops = {\n\t.vidioc_querycap = cx25821_vidioc_querycap,\n\t.vidioc_enum_fmt_vid_out = cx25821_vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_out = cx25821_vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_out = cx25821_vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out = vidioc_s_fmt_vid_out,\n\t.vidioc_g_std = cx25821_vidioc_g_std,\n\t.vidioc_s_std = cx25821_vidioc_s_std,\n\t.vidioc_enum_output = cx25821_vidioc_enum_output,\n\t.vidioc_g_output = cx25821_vidioc_g_output,\n\t.vidioc_s_output = cx25821_vidioc_s_output,\n\t.vidioc_log_status = vidioc_log_status,\n};\n\nstatic const struct video_device cx25821_video_out_device = {\n\t.name = \"cx25821-video\",\n\t.fops = &video_out_fops,\n\t.release = video_device_release_empty,\n\t.minor = -1,\n\t.ioctl_ops = &video_out_ioctl_ops,\n\t.tvnorms = CX25821_NORMS,\n\t.device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE,\n};\n\nvoid cx25821_video_unregister(struct cx25821_dev *dev, int chan_num)\n{\n\tcx_clear(PCI_INT_MSK, 1);\n\n\tif (video_is_registered(&dev->channels[chan_num].vdev)) {\n\t\tvideo_unregister_device(&dev->channels[chan_num].vdev);\n\t\tv4l2_ctrl_handler_free(&dev->channels[chan_num].hdl);\n\t}\n}\n\nint cx25821_video_register(struct cx25821_dev *dev)\n{\n\tint err;\n\tint i;\n\n\t \n\tdev->tvnorm = V4L2_STD_NTSC_M;\n\n\tspin_lock_init(&dev->slock);\n\n\tfor (i = 0; i < MAX_VID_CAP_CHANNEL_NUM - 1; ++i) {\n\t\tstruct cx25821_channel *chan = &dev->channels[i];\n\t\tstruct video_device *vdev = &chan->vdev;\n\t\tstruct v4l2_ctrl_handler *hdl = &chan->hdl;\n\t\tstruct vb2_queue *q;\n\t\tbool is_output = i > SRAM_CH08;\n\n\t\tif (i == SRAM_CH08)  \n\t\t\tcontinue;\n\n\t\tif (!is_output) {\n\t\t\tv4l2_ctrl_handler_init(hdl, 4);\n\t\t\tv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BRIGHTNESS, 0, 10000, 1, 6200);\n\t\t\tv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\n\t\t\t\t\tV4L2_CID_CONTRAST, 0, 10000, 1, 5000);\n\t\t\tv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\n\t\t\t\t\tV4L2_CID_SATURATION, 0, 10000, 1, 5000);\n\t\t\tv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\n\t\t\t\t\tV4L2_CID_HUE, 0, 10000, 1, 5000);\n\t\t\tif (hdl->error) {\n\t\t\t\terr = hdl->error;\n\t\t\t\tgoto fail_unreg;\n\t\t\t}\n\t\t\terr = v4l2_ctrl_handler_setup(hdl);\n\t\t\tif (err)\n\t\t\t\tgoto fail_unreg;\n\t\t} else {\n\t\t\tchan->out = &dev->vid_out_data[i - SRAM_CH09];\n\t\t\tchan->out->chan = chan;\n\t\t}\n\n\t\tchan->sram_channels = &cx25821_sram_channels[i];\n\t\tchan->width = 720;\n\t\tchan->field = V4L2_FIELD_INTERLACED;\n\t\tif (dev->tvnorm & V4L2_STD_625_50)\n\t\t\tchan->height = 576;\n\t\telse\n\t\t\tchan->height = 480;\n\n\t\tif (chan->pixel_formats == PIXEL_FRMT_411)\n\t\t\tchan->fmt = cx25821_format_by_fourcc(V4L2_PIX_FMT_Y41P);\n\t\telse\n\t\t\tchan->fmt = cx25821_format_by_fourcc(V4L2_PIX_FMT_YUYV);\n\n\t\tcx_write(chan->sram_channels->int_stat, 0xffffffff);\n\n\t\tINIT_LIST_HEAD(&chan->dma_vidq.active);\n\n\t\tq = &chan->vidq;\n\n\t\tq->type = is_output ? V4L2_BUF_TYPE_VIDEO_OUTPUT :\n\t\t\t\t      V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\t\tq->io_modes |= is_output ? VB2_WRITE : VB2_READ;\n\t\tq->gfp_flags = GFP_DMA32;\n\t\tq->min_buffers_needed = 2;\n\t\tq->drv_priv = chan;\n\t\tq->buf_struct_size = sizeof(struct cx25821_buffer);\n\t\tq->ops = &cx25821_video_qops;\n\t\tq->mem_ops = &vb2_dma_sg_memops;\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tq->lock = &dev->lock;\n\t\tq->dev = &dev->pci->dev;\n\n\t\tif (!is_output) {\n\t\t\terr = vb2_queue_init(q);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail_unreg;\n\t\t}\n\n\t\t \n\t\t*vdev = is_output ? cx25821_video_out_device : cx25821_video_device;\n\t\tvdev->v4l2_dev = &dev->v4l2_dev;\n\t\tif (!is_output)\n\t\t\tvdev->ctrl_handler = hdl;\n\t\telse\n\t\t\tvdev->vfl_dir = VFL_DIR_TX;\n\t\tvdev->lock = &dev->lock;\n\t\tvdev->queue = q;\n\t\tsnprintf(vdev->name, sizeof(vdev->name), \"%s #%d\", dev->name, i);\n\t\tvideo_set_drvdata(vdev, chan);\n\n\t\terr = video_register_device(vdev, VFL_TYPE_VIDEO,\n\t\t\t\t\t    video_nr[dev->nr]);\n\n\t\tif (err < 0)\n\t\t\tgoto fail_unreg;\n\t}\n\n\t \n\tcx_set(PCI_INT_MSK, 0xff);\n\n\treturn 0;\n\nfail_unreg:\n\twhile (i >= 0)\n\t\tcx25821_video_unregister(dev, i--);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}