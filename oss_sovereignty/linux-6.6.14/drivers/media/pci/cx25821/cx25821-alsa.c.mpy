{
  "module_name": "cx25821-alsa.c",
  "hash_id": "e76f378d1bbda4150f8e161743b13242b5217df93dc152e83b9dce0ebdd49126",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx25821/cx25821-alsa.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"cx25821.h\"\n#include \"cx25821-reg.h\"\n\n#define AUDIO_SRAM_CHANNEL\tSRAM_CH08\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (debug >= level)\t\t\t\t\t\\\n\t\tpr_info(\"%s/1: \" fmt, chip->dev->name, ##arg);\t\\\n} while (0)\n#define dprintk_core(level, fmt, arg...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (debug >= level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s/1: \" fmt, chip->dev->name, ##arg); \\\n} while (0)\n\n \n\nstatic int devno;\n\nstruct cx25821_audio_buffer {\n\tunsigned int bpl;\n\tstruct cx25821_riscmem risc;\n\tvoid\t\t\t*vaddr;\n\tstruct scatterlist\t*sglist;\n\tint\t\t\tsglen;\n\tunsigned long\t\tnr_pages;\n};\n\nstruct cx25821_audio_dev {\n\tstruct cx25821_dev *dev;\n\tstruct cx25821_dmaqueue q;\n\n\t \n\tstruct pci_dev *pci;\n\n\t \n\tint irq;\n\n\tstruct snd_card *card;\n\n\tunsigned long iobase;\n\tspinlock_t reg_lock;\n\tatomic_t count;\n\n\tunsigned int dma_size;\n\tunsigned int period_size;\n\tunsigned int num_periods;\n\n\tstruct cx25821_audio_buffer *buf;\n\n\tstruct snd_pcm_substream *substream;\n};\n\n\n \n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable cx25821 soundcard. default enabled.\");\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for cx25821 capture interface(s).\");\n\n \n\nMODULE_DESCRIPTION(\"ALSA driver module for cx25821 based capture cards\");\nMODULE_AUTHOR(\"Hiep Huynh\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\n \n \n#define AUD_INT_DN_RISCI1       (1 <<  0)\n#define AUD_INT_UP_RISCI1       (1 <<  1)\n#define AUD_INT_RDS_DN_RISCI1   (1 <<  2)\n#define AUD_INT_DN_RISCI2       (1 <<  4)\t \n#define AUD_INT_UP_RISCI2       (1 <<  5)\n#define AUD_INT_RDS_DN_RISCI2   (1 <<  6)\n#define AUD_INT_DN_SYNC         (1 << 12)\n#define AUD_INT_UP_SYNC         (1 << 13)\n#define AUD_INT_RDS_DN_SYNC     (1 << 14)\n#define AUD_INT_OPC_ERR         (1 << 16)\n#define AUD_INT_BER_IRQ         (1 << 20)\n#define AUD_INT_MCHG_IRQ        (1 << 21)\n#define GP_COUNT_CONTROL_RESET\t0x3\n\n#define PCI_MSK_AUD_EXT   (1 <<  4)\n#define PCI_MSK_AUD_INT   (1 <<  3)\n\nstatic int cx25821_alsa_dma_init(struct cx25821_audio_dev *chip,\n\t\t\t\t unsigned long nr_pages)\n{\n\tstruct cx25821_audio_buffer *buf = chip->buf;\n\tstruct page *pg;\n\tint i;\n\n\tbuf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\n\tif (NULL == buf->vaddr) {\n\t\tdprintk(1, \"vmalloc_32(%lu pages) failed\\n\", nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1, \"vmalloc is at addr 0x%p, size=%lu\\n\",\n\t\t\t\tbuf->vaddr,\n\t\t\t\tnr_pages << PAGE_SHIFT);\n\n\tmemset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);\n\tbuf->nr_pages = nr_pages;\n\n\tbuf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));\n\tif (NULL == buf->sglist)\n\t\tgoto vzalloc_err;\n\n\tsg_init_table(buf->sglist, buf->nr_pages);\n\tfor (i = 0; i < buf->nr_pages; i++) {\n\t\tpg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);\n\t\tif (NULL == pg)\n\t\t\tgoto vmalloc_to_page_err;\n\t\tsg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn 0;\n\nvmalloc_to_page_err:\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\nvzalloc_err:\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int cx25821_alsa_dma_map(struct cx25821_audio_dev *dev)\n{\n\tstruct cx25821_audio_buffer *buf = dev->buf;\n\n\tbuf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,\n\t\t\tbuf->nr_pages, DMA_FROM_DEVICE);\n\n\tif (0 == buf->sglen) {\n\t\tpr_warn(\"%s: cx25821_alsa_map_sg failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int cx25821_alsa_dma_unmap(struct cx25821_audio_dev *dev)\n{\n\tstruct cx25821_audio_buffer *buf = dev->buf;\n\n\tif (!buf->sglen)\n\t\treturn 0;\n\n\tdma_unmap_sg(&dev->pci->dev, buf->sglist, buf->nr_pages, DMA_FROM_DEVICE);\n\tbuf->sglen = 0;\n\treturn 0;\n}\n\nstatic int cx25821_alsa_dma_free(struct cx25821_audio_buffer *buf)\n{\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn 0;\n}\n\n \n\nstatic int _cx25821_start_audio_dma(struct cx25821_audio_dev *chip)\n{\n\tstruct cx25821_audio_buffer *buf = chip->buf;\n\tstruct cx25821_dev *dev = chip->dev;\n\tconst struct sram_channel *audio_ch =\n\t    &cx25821_sram_channels[AUDIO_SRAM_CHANNEL];\n\tu32 tmp = 0;\n\n\t \n\tcx25821_set_gpiopin_direction(chip->dev, 0, 0);\n\n\t \n\tcx_clear(AUD_INT_DMA_CTL,\n\t\t FLD_AUD_DST_A_RISC_EN | FLD_AUD_DST_A_FIFO_EN);\n\n\t \n\tcx25821_sram_channel_setup_audio(chip->dev, audio_ch, buf->bpl,\n\t\t\t\t\t buf->risc.dma);\n\n\t \n\tcx_write(AUD_A_LNGTH, buf->bpl);\n\n\t \n\t \n\tcx_write(AUD_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);\n\tatomic_set(&chip->count, 0);\n\n\t \n\ttmp = cx_read(AUD_A_CFG);\n\tcx_write(AUD_A_CFG, tmp | FLD_AUD_DST_PK_MODE | FLD_AUD_DST_ENABLE |\n\t\t FLD_AUD_CLK_ENABLE);\n\n\t \n\n\t \n\tcx_write(AUD_A_INT_MSK, FLD_AUD_DST_RISCI1 | FLD_AUD_DST_OF |\n\t\t FLD_AUD_DST_SYNC | FLD_AUD_DST_OPC_ERR);\n\n\t \n\tcx_write(AUD_A_INT_STAT, ~0);\n\n\t \n\tcx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);\n\n\t \n\ttmp = cx_read(AUD_INT_DMA_CTL);\n\tcx_set(AUD_INT_DMA_CTL, tmp |\n\t       (FLD_AUD_DST_A_RISC_EN | FLD_AUD_DST_A_FIFO_EN));\n\n\tmdelay(100);\n\treturn 0;\n}\n\n \nstatic int _cx25821_stop_audio_dma(struct cx25821_audio_dev *chip)\n{\n\tstruct cx25821_dev *dev = chip->dev;\n\n\t \n\tcx_clear(AUD_INT_DMA_CTL,\n\t\t FLD_AUD_DST_A_RISC_EN | FLD_AUD_DST_A_FIFO_EN);\n\n\t \n\tcx_clear(PCI_INT_MSK, PCI_MSK_AUD_INT);\n\tcx_clear(AUD_A_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\n\t\t AUD_INT_DN_RISCI2 | AUD_INT_DN_RISCI1);\n\n\treturn 0;\n}\n\n#define MAX_IRQ_LOOP 50\n\n \nstatic char *cx25821_aud_irqs[32] = {\n\t\"dn_risci1\", \"up_risci1\", \"rds_dn_risc1\",\t \n\tNULL,\t\t\t\t\t\t \n\t\"dn_risci2\", \"up_risci2\", \"rds_dn_risc2\",\t \n\tNULL,\t\t\t\t\t\t \n\t\"dnf_of\", \"upf_uf\", \"rds_dnf_uf\",\t\t \n\tNULL,\t\t\t\t\t\t \n\t\"dn_sync\", \"up_sync\", \"rds_dn_sync\",\t\t \n\tNULL,\t\t\t\t\t\t \n\t\"opc_err\", \"par_err\", \"rip_err\",\t\t \n\t\"pci_abort\", \"ber_irq\", \"mchg_irq\"\t\t \n};\n\n \nstatic void cx25821_aud_irq(struct cx25821_audio_dev *chip, u32 status,\n\t\t\t    u32 mask)\n{\n\tstruct cx25821_dev *dev = chip->dev;\n\n\tif (0 == (status & mask))\n\t\treturn;\n\n\tcx_write(AUD_A_INT_STAT, status);\n\tif (debug > 1 || (status & mask & ~0xff))\n\t\tcx25821_print_irqbits(dev->name, \"irq aud\", cx25821_aud_irqs,\n\t\t\t\tARRAY_SIZE(cx25821_aud_irqs), status, mask);\n\n\t \n\tif (status & AUD_INT_OPC_ERR) {\n\t\tpr_warn(\"WARNING %s/1: Audio risc op code error\\n\", dev->name);\n\n\t\tcx_clear(AUD_INT_DMA_CTL,\n\t\t\t FLD_AUD_DST_A_RISC_EN | FLD_AUD_DST_A_FIFO_EN);\n\t\tcx25821_sram_channel_dump_audio(dev,\n\t\t\t\t&cx25821_sram_channels[AUDIO_SRAM_CHANNEL]);\n\t}\n\tif (status & AUD_INT_DN_SYNC) {\n\t\tpr_warn(\"WARNING %s: Downstream sync error!\\n\", dev->name);\n\t\tcx_write(AUD_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);\n\t\treturn;\n\t}\n\n\t \n\tif (status & AUD_INT_DN_RISCI1) {\n\t\tatomic_set(&chip->count, cx_read(AUD_A_GPCNT));\n\t\tsnd_pcm_period_elapsed(chip->substream);\n\t}\n}\n\n \nstatic irqreturn_t cx25821_irq(int irq, void *dev_id)\n{\n\tstruct cx25821_audio_dev *chip = dev_id;\n\tstruct cx25821_dev *dev = chip->dev;\n\tu32 status, pci_status;\n\tu32 audint_status, audint_mask;\n\tint loop, handled = 0;\n\n\taudint_status = cx_read(AUD_A_INT_STAT);\n\taudint_mask = cx_read(AUD_A_INT_MSK);\n\tstatus = cx_read(PCI_INT_STAT);\n\n\tfor (loop = 0; loop < 1; loop++) {\n\t\tstatus = cx_read(PCI_INT_STAT);\n\t\tif (0 == status) {\n\t\t\tstatus = cx_read(PCI_INT_STAT);\n\t\t\taudint_status = cx_read(AUD_A_INT_STAT);\n\t\t\taudint_mask = cx_read(AUD_A_INT_MSK);\n\n\t\t\tif (status) {\n\t\t\t\thandled = 1;\n\t\t\t\tcx_write(PCI_INT_STAT, status);\n\n\t\t\t\tcx25821_aud_irq(chip, audint_status,\n\t\t\t\t\t\taudint_mask);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\thandled = 1;\n\t\tcx_write(PCI_INT_STAT, status);\n\n\t\tcx25821_aud_irq(chip, audint_status, audint_mask);\n\t}\n\n\tpci_status = cx_read(PCI_INT_STAT);\n\n\tif (handled)\n\t\tcx_write(PCI_INT_STAT, pci_status);\n\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int dsp_buffer_free(struct cx25821_audio_dev *chip)\n{\n\tstruct cx25821_riscmem *risc = &chip->buf->risc;\n\n\tBUG_ON(!chip->dma_size);\n\n\tdprintk(2, \"Freeing buffer\\n\");\n\tcx25821_alsa_dma_unmap(chip);\n\tcx25821_alsa_dma_free(chip->buf);\n\tdma_free_coherent(&chip->pci->dev, risc->size, risc->cpu, risc->dma);\n\tkfree(chip->buf);\n\n\tchip->buf = NULL;\n\tchip->dma_size = 0;\n\n\treturn 0;\n}\n\n \n\n \n#define DEFAULT_FIFO_SIZE\t384\nstatic const struct snd_pcm_hardware snd_cx25821_digital_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.period_bytes_min = DEFAULT_FIFO_SIZE / 3,\n\t.period_bytes_max = DEFAULT_FIFO_SIZE / 3,\n\t.periods_min = 1,\n\t.periods_max = AUDIO_LINE_SIZE,\n\t \n\t.buffer_bytes_max = (AUDIO_LINE_SIZE * AUDIO_LINE_SIZE),\n};\n\n \nstatic int snd_cx25821_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct cx25821_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tunsigned int bpl = 0;\n\n\tif (!chip) {\n\t\tpr_err(\"DEBUG: cx25821 can't find device struct. Can't proceed with open\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tchip->substream = substream;\n\n\truntime->hw = snd_cx25821_digital_hw;\n\n\tif (cx25821_sram_channels[AUDIO_SRAM_CHANNEL].fifo_size !=\n\t    DEFAULT_FIFO_SIZE) {\n\t\t \n\t\tbpl = cx25821_sram_channels[AUDIO_SRAM_CHANNEL].fifo_size / 3;\n\t\tbpl &= ~7;\t \n\n\t\tif (bpl > AUDIO_LINE_SIZE)\n\t\t\tbpl = AUDIO_LINE_SIZE;\n\n\t\truntime->hw.period_bytes_min = bpl;\n\t\truntime->hw.period_bytes_max = bpl;\n\t}\n\n\treturn 0;\n_error:\n\tdprintk(1, \"Error opening PCM!\\n\");\n\treturn err;\n}\n\n \nstatic int snd_cx25821_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_cx25821_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cx25821_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct cx25821_audio_buffer *buf;\n\tint ret;\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\tchip->period_size = params_period_bytes(hw_params);\n\tchip->num_periods = params_periods(hw_params);\n\tchip->dma_size = chip->period_size * params_periods(hw_params);\n\n\tBUG_ON(!chip->dma_size);\n\tBUG_ON(chip->num_periods & (chip->num_periods - 1));\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (NULL == buf)\n\t\treturn -ENOMEM;\n\n\tif (chip->period_size > AUDIO_LINE_SIZE)\n\t\tchip->period_size = AUDIO_LINE_SIZE;\n\n\tbuf->bpl = chip->period_size;\n\tchip->buf = buf;\n\n\tret = cx25821_alsa_dma_init(chip,\n\t\t\t(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx25821_alsa_dma_map(chip);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx25821_risc_databuffer_audio(chip->pci, &buf->risc, buf->sglist,\n\t\t\tchip->period_size, chip->num_periods, 1);\n\tif (ret < 0) {\n\t\tpr_info(\"DEBUG: ERROR after cx25821_risc_databuffer_audio()\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\tbuf->risc.jmp[2] = cpu_to_le32(0);\t \n\n\tsubstream->runtime->dma_area = chip->buf->vaddr;\n\tsubstream->runtime->dma_bytes = chip->dma_size;\n\tsubstream->runtime->dma_addr = 0;\n\n\treturn 0;\n\nerror:\n\tchip->buf = NULL;\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int snd_cx25821_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct cx25821_audio_dev *chip = snd_pcm_substream_chip(substream);\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_cx25821_prepare(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_cx25821_card_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct cx25821_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tint err = 0;\n\n\t \n\tspin_lock(&chip->reg_lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\terr = _cx25821_start_audio_dma(chip);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\terr = _cx25821_stop_audio_dma(chip);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&chip->reg_lock);\n\n\treturn err;\n}\n\n \nstatic snd_pcm_uframes_t snd_cx25821_pointer(struct snd_pcm_substream\n\t\t\t\t\t     *substream)\n{\n\tstruct cx25821_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu16 count;\n\n\tcount = atomic_read(&chip->count);\n\n\treturn runtime->period_size * (count & (runtime->periods - 1));\n}\n\n \nstatic struct page *snd_cx25821_page(struct snd_pcm_substream *substream,\n\t\t\t\t     unsigned long offset)\n{\n\tvoid *pageptr = substream->runtime->dma_area + offset;\n\n\treturn vmalloc_to_page(pageptr);\n}\n\n \nstatic const struct snd_pcm_ops snd_cx25821_pcm_ops = {\n\t.open = snd_cx25821_pcm_open,\n\t.close = snd_cx25821_close,\n\t.hw_params = snd_cx25821_hw_params,\n\t.hw_free = snd_cx25821_hw_free,\n\t.prepare = snd_cx25821_prepare,\n\t.trigger = snd_cx25821_card_trigger,\n\t.pointer = snd_cx25821_pointer,\n\t.page = snd_cx25821_page,\n};\n\n \nstatic int snd_cx25821_pcm(struct cx25821_audio_dev *chip, int device,\n\t\t\t   char *name)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\n\tif (err < 0) {\n\t\tpr_info(\"ERROR: FAILED snd_pcm_new() in %s\\n\", __func__);\n\t\treturn err;\n\t}\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrscpy(pcm->name, name, sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx25821_pcm_ops);\n\n\treturn 0;\n}\n\n \n\n \n\nstatic const struct pci_device_id __maybe_unused cx25821_audio_pci_tbl[] = {\n\t{0x14f1, 0x0920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, cx25821_audio_pci_tbl);\n\n \nstatic int cx25821_audio_initdev(struct cx25821_dev *dev)\n{\n\tstruct snd_card *card;\n\tstruct cx25821_audio_dev *chip;\n\tint err;\n\n\tif (devno >= SNDRV_CARDS) {\n\t\tpr_info(\"DEBUG ERROR: devno >= SNDRV_CARDS %s\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!enable[devno]) {\n\t\t++devno;\n\t\tpr_info(\"DEBUG ERROR: !enable[devno] %s\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&dev->pci->dev, index[devno], id[devno],\n\t\t\t   THIS_MODULE,\n\t\t\t   sizeof(struct cx25821_audio_dev), &card);\n\tif (err < 0) {\n\t\tpr_info(\"DEBUG ERROR: cannot create snd_card_new in %s\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\tstrscpy(card->driver, \"cx25821\", sizeof(card->driver));\n\n\t \n\tchip = card->private_data;\n\tspin_lock_init(&chip->reg_lock);\n\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->pci = dev->pci;\n\tchip->iobase = pci_resource_start(dev->pci, 0);\n\n\tchip->irq = dev->pci->irq;\n\n\terr = devm_request_irq(&dev->pci->dev, dev->pci->irq, cx25821_irq,\n\t\t\t       IRQF_SHARED, chip->dev->name, chip);\n\n\tif (err < 0) {\n\t\tpr_err(\"ERROR %s: can't get IRQ %d for ALSA\\n\", chip->dev->name,\n\t\t\tdev->pci->irq);\n\t\tgoto error;\n\t}\n\n\terr = snd_cx25821_pcm(chip, 0, \"cx25821 Digital\");\n\tif (err < 0) {\n\t\tpr_info(\"DEBUG ERROR: cannot create snd_cx25821_pcm %s\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\tstrscpy(card->shortname, \"cx25821\", sizeof(card->shortname));\n\tsprintf(card->longname, \"%s at 0x%lx irq %d\", chip->dev->name,\n\t\tchip->iobase, chip->irq);\n\tstrscpy(card->mixername, \"CX25821\", sizeof(card->mixername));\n\n\tpr_info(\"%s/%i: ALSA support for cx25821 boards\\n\", card->driver,\n\t\tdevno);\n\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tpr_info(\"DEBUG ERROR: cannot register sound card %s\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\tdev->card = card;\n\tdevno++;\n\treturn 0;\n\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n \n\nstatic int cx25821_alsa_exit_callback(struct device *dev, void *data)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct cx25821_dev *cxdev = get_cx25821(v4l2_dev);\n\n\tsnd_card_free(cxdev->card);\n\treturn 0;\n}\n\nstatic void cx25821_audio_fini(void)\n{\n\tstruct device_driver *drv = driver_find(\"cx25821\", &pci_bus_type);\n\tint ret;\n\n\tret = driver_for_each_device(drv, NULL, NULL, cx25821_alsa_exit_callback);\n\tif (ret)\n\t\tpr_err(\"%s failed to find a cx25821 driver.\\n\", __func__);\n}\n\nstatic int cx25821_alsa_init_callback(struct device *dev, void *data)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct cx25821_dev *cxdev = get_cx25821(v4l2_dev);\n\n\tcx25821_audio_initdev(cxdev);\n\treturn 0;\n}\n\n \nstatic int cx25821_alsa_init(void)\n{\n\tstruct device_driver *drv = driver_find(\"cx25821\", &pci_bus_type);\n\n\treturn driver_for_each_device(drv, NULL, NULL, cx25821_alsa_init_callback);\n\n}\n\nlate_initcall(cx25821_alsa_init);\nmodule_exit(cx25821_audio_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}