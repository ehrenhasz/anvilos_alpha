{
  "module_name": "cx25821-core.c",
  "hash_id": "4d843f68c73e1443d4b0b7dcc3a07e3976cc43a740e4b6eb439f556cb2966d23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx25821/cx25821-core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include \"cx25821.h\"\n#include \"cx25821-sram.h\"\n#include \"cx25821-video.h\"\n\nMODULE_DESCRIPTION(\"Driver for Athena cards\");\nMODULE_AUTHOR(\"Shu Lin - Hiep Huynh\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\nstatic unsigned int card[] = {[0 ... (CX25821_MAXBOARDS - 1)] = UNSET };\nmodule_param_array(card, int, NULL, 0444);\nMODULE_PARM_DESC(card, \"card type\");\n\nconst struct sram_channel cx25821_sram_channels[] = {\n\t[SRAM_CH00] = {\n\t\t.i = SRAM_CH00,\n\t\t.name = \"VID A\",\n\t\t.cmds_start = VID_A_DOWN_CMDS,\n\t\t.ctrl_start = VID_A_IQ,\n\t\t.cdt = VID_A_CDT,\n\t\t.fifo_start = VID_A_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA1_PTR1,\n\t\t.ptr2_reg = DMA1_PTR2,\n\t\t.cnt1_reg = DMA1_CNT1,\n\t\t.cnt2_reg = DMA1_CNT2,\n\t\t.int_msk = VID_A_INT_MSK,\n\t\t.int_stat = VID_A_INT_STAT,\n\t\t.int_mstat = VID_A_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_A_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_A_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_A_GPCNT,\n\t\t.vip_ctl = VID_DST_A_VIP_CTL,\n\t\t.pix_frmt = VID_DST_A_PIX_FRMT,\n\t},\n\n\t[SRAM_CH01] = {\n\t\t.i = SRAM_CH01,\n\t\t.name = \"VID B\",\n\t\t.cmds_start = VID_B_DOWN_CMDS,\n\t\t.ctrl_start = VID_B_IQ,\n\t\t.cdt = VID_B_CDT,\n\t\t.fifo_start = VID_B_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA2_PTR1,\n\t\t.ptr2_reg = DMA2_PTR2,\n\t\t.cnt1_reg = DMA2_CNT1,\n\t\t.cnt2_reg = DMA2_CNT2,\n\t\t.int_msk = VID_B_INT_MSK,\n\t\t.int_stat = VID_B_INT_STAT,\n\t\t.int_mstat = VID_B_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_B_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_B_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_B_GPCNT,\n\t\t.vip_ctl = VID_DST_B_VIP_CTL,\n\t\t.pix_frmt = VID_DST_B_PIX_FRMT,\n\t},\n\n\t[SRAM_CH02] = {\n\t\t.i = SRAM_CH02,\n\t\t.name = \"VID C\",\n\t\t.cmds_start = VID_C_DOWN_CMDS,\n\t\t.ctrl_start = VID_C_IQ,\n\t\t.cdt = VID_C_CDT,\n\t\t.fifo_start = VID_C_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA3_PTR1,\n\t\t.ptr2_reg = DMA3_PTR2,\n\t\t.cnt1_reg = DMA3_CNT1,\n\t\t.cnt2_reg = DMA3_CNT2,\n\t\t.int_msk = VID_C_INT_MSK,\n\t\t.int_stat = VID_C_INT_STAT,\n\t\t.int_mstat = VID_C_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_C_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_C_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_C_GPCNT,\n\t\t.vip_ctl = VID_DST_C_VIP_CTL,\n\t\t.pix_frmt = VID_DST_C_PIX_FRMT,\n\t},\n\n\t[SRAM_CH03] = {\n\t\t.i = SRAM_CH03,\n\t\t.name = \"VID D\",\n\t\t.cmds_start = VID_D_DOWN_CMDS,\n\t\t.ctrl_start = VID_D_IQ,\n\t\t.cdt = VID_D_CDT,\n\t\t.fifo_start = VID_D_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA4_PTR1,\n\t\t.ptr2_reg = DMA4_PTR2,\n\t\t.cnt1_reg = DMA4_CNT1,\n\t\t.cnt2_reg = DMA4_CNT2,\n\t\t.int_msk = VID_D_INT_MSK,\n\t\t.int_stat = VID_D_INT_STAT,\n\t\t.int_mstat = VID_D_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_D_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_D_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_D_GPCNT,\n\t\t.vip_ctl = VID_DST_D_VIP_CTL,\n\t\t.pix_frmt = VID_DST_D_PIX_FRMT,\n\t},\n\n\t[SRAM_CH04] = {\n\t\t.i = SRAM_CH04,\n\t\t.name = \"VID E\",\n\t\t.cmds_start = VID_E_DOWN_CMDS,\n\t\t.ctrl_start = VID_E_IQ,\n\t\t.cdt = VID_E_CDT,\n\t\t.fifo_start = VID_E_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA5_PTR1,\n\t\t.ptr2_reg = DMA5_PTR2,\n\t\t.cnt1_reg = DMA5_CNT1,\n\t\t.cnt2_reg = DMA5_CNT2,\n\t\t.int_msk = VID_E_INT_MSK,\n\t\t.int_stat = VID_E_INT_STAT,\n\t\t.int_mstat = VID_E_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_E_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_E_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_E_GPCNT,\n\t\t.vip_ctl = VID_DST_E_VIP_CTL,\n\t\t.pix_frmt = VID_DST_E_PIX_FRMT,\n\t},\n\n\t[SRAM_CH05] = {\n\t\t.i = SRAM_CH05,\n\t\t.name = \"VID F\",\n\t\t.cmds_start = VID_F_DOWN_CMDS,\n\t\t.ctrl_start = VID_F_IQ,\n\t\t.cdt = VID_F_CDT,\n\t\t.fifo_start = VID_F_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA6_PTR1,\n\t\t.ptr2_reg = DMA6_PTR2,\n\t\t.cnt1_reg = DMA6_CNT1,\n\t\t.cnt2_reg = DMA6_CNT2,\n\t\t.int_msk = VID_F_INT_MSK,\n\t\t.int_stat = VID_F_INT_STAT,\n\t\t.int_mstat = VID_F_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_F_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_F_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_F_GPCNT,\n\t\t.vip_ctl = VID_DST_F_VIP_CTL,\n\t\t.pix_frmt = VID_DST_F_PIX_FRMT,\n\t},\n\n\t[SRAM_CH06] = {\n\t\t.i = SRAM_CH06,\n\t\t.name = \"VID G\",\n\t\t.cmds_start = VID_G_DOWN_CMDS,\n\t\t.ctrl_start = VID_G_IQ,\n\t\t.cdt = VID_G_CDT,\n\t\t.fifo_start = VID_G_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA7_PTR1,\n\t\t.ptr2_reg = DMA7_PTR2,\n\t\t.cnt1_reg = DMA7_CNT1,\n\t\t.cnt2_reg = DMA7_CNT2,\n\t\t.int_msk = VID_G_INT_MSK,\n\t\t.int_stat = VID_G_INT_STAT,\n\t\t.int_mstat = VID_G_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_G_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_G_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_G_GPCNT,\n\t\t.vip_ctl = VID_DST_G_VIP_CTL,\n\t\t.pix_frmt = VID_DST_G_PIX_FRMT,\n\t},\n\n\t[SRAM_CH07] = {\n\t\t.i = SRAM_CH07,\n\t\t.name = \"VID H\",\n\t\t.cmds_start = VID_H_DOWN_CMDS,\n\t\t.ctrl_start = VID_H_IQ,\n\t\t.cdt = VID_H_CDT,\n\t\t.fifo_start = VID_H_DOWN_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA8_PTR1,\n\t\t.ptr2_reg = DMA8_PTR2,\n\t\t.cnt1_reg = DMA8_CNT1,\n\t\t.cnt2_reg = DMA8_CNT2,\n\t\t.int_msk = VID_H_INT_MSK,\n\t\t.int_stat = VID_H_INT_STAT,\n\t\t.int_mstat = VID_H_INT_MSTAT,\n\t\t.dma_ctl = VID_DST_H_DMA_CTL,\n\t\t.gpcnt_ctl = VID_DST_H_GPCNT_CTL,\n\t\t.gpcnt = VID_DST_H_GPCNT,\n\t\t.vip_ctl = VID_DST_H_VIP_CTL,\n\t\t.pix_frmt = VID_DST_H_PIX_FRMT,\n\t},\n\n\t[SRAM_CH08] = {\n\t\t.name = \"audio from\",\n\t\t.cmds_start = AUD_A_DOWN_CMDS,\n\t\t.ctrl_start = AUD_A_IQ,\n\t\t.cdt = AUD_A_CDT,\n\t\t.fifo_start = AUD_A_DOWN_CLUSTER_1,\n\t\t.fifo_size = AUDIO_CLUSTER_SIZE * 3,\n\t\t.ptr1_reg = DMA17_PTR1,\n\t\t.ptr2_reg = DMA17_PTR2,\n\t\t.cnt1_reg = DMA17_CNT1,\n\t\t.cnt2_reg = DMA17_CNT2,\n\t},\n\n\t[SRAM_CH09] = {\n\t\t.i = SRAM_CH09,\n\t\t.name = \"VID Upstream I\",\n\t\t.cmds_start = VID_I_UP_CMDS,\n\t\t.ctrl_start = VID_I_IQ,\n\t\t.cdt = VID_I_CDT,\n\t\t.fifo_start = VID_I_UP_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA15_PTR1,\n\t\t.ptr2_reg = DMA15_PTR2,\n\t\t.cnt1_reg = DMA15_CNT1,\n\t\t.cnt2_reg = DMA15_CNT2,\n\t\t.int_msk = VID_I_INT_MSK,\n\t\t.int_stat = VID_I_INT_STAT,\n\t\t.int_mstat = VID_I_INT_MSTAT,\n\t\t.dma_ctl = VID_SRC_I_DMA_CTL,\n\t\t.gpcnt_ctl = VID_SRC_I_GPCNT_CTL,\n\t\t.gpcnt = VID_SRC_I_GPCNT,\n\n\t\t.vid_fmt_ctl = VID_SRC_I_FMT_CTL,\n\t\t.vid_active_ctl1 = VID_SRC_I_ACTIVE_CTL1,\n\t\t.vid_active_ctl2 = VID_SRC_I_ACTIVE_CTL2,\n\t\t.vid_cdt_size = VID_SRC_I_CDT_SZ,\n\t\t.irq_bit = 8,\n\t},\n\n\t[SRAM_CH10] = {\n\t\t.i = SRAM_CH10,\n\t\t.name = \"VID Upstream J\",\n\t\t.cmds_start = VID_J_UP_CMDS,\n\t\t.ctrl_start = VID_J_IQ,\n\t\t.cdt = VID_J_CDT,\n\t\t.fifo_start = VID_J_UP_CLUSTER_1,\n\t\t.fifo_size = (VID_CLUSTER_SIZE << 2),\n\t\t.ptr1_reg = DMA16_PTR1,\n\t\t.ptr2_reg = DMA16_PTR2,\n\t\t.cnt1_reg = DMA16_CNT1,\n\t\t.cnt2_reg = DMA16_CNT2,\n\t\t.int_msk = VID_J_INT_MSK,\n\t\t.int_stat = VID_J_INT_STAT,\n\t\t.int_mstat = VID_J_INT_MSTAT,\n\t\t.dma_ctl = VID_SRC_J_DMA_CTL,\n\t\t.gpcnt_ctl = VID_SRC_J_GPCNT_CTL,\n\t\t.gpcnt = VID_SRC_J_GPCNT,\n\n\t\t.vid_fmt_ctl = VID_SRC_J_FMT_CTL,\n\t\t.vid_active_ctl1 = VID_SRC_J_ACTIVE_CTL1,\n\t\t.vid_active_ctl2 = VID_SRC_J_ACTIVE_CTL2,\n\t\t.vid_cdt_size = VID_SRC_J_CDT_SZ,\n\t\t.irq_bit = 9,\n\t},\n\n\t[SRAM_CH11] = {\n\t\t.i = SRAM_CH11,\n\t\t.name = \"Audio Upstream Channel B\",\n\t\t.cmds_start = AUD_B_UP_CMDS,\n\t\t.ctrl_start = AUD_B_IQ,\n\t\t.cdt = AUD_B_CDT,\n\t\t.fifo_start = AUD_B_UP_CLUSTER_1,\n\t\t.fifo_size = (AUDIO_CLUSTER_SIZE * 3),\n\t\t.ptr1_reg = DMA22_PTR1,\n\t\t.ptr2_reg = DMA22_PTR2,\n\t\t.cnt1_reg = DMA22_CNT1,\n\t\t.cnt2_reg = DMA22_CNT2,\n\t\t.int_msk = AUD_B_INT_MSK,\n\t\t.int_stat = AUD_B_INT_STAT,\n\t\t.int_mstat = AUD_B_INT_MSTAT,\n\t\t.dma_ctl = AUD_INT_DMA_CTL,\n\t\t.gpcnt_ctl = AUD_B_GPCNT_CTL,\n\t\t.gpcnt = AUD_B_GPCNT,\n\t\t.aud_length = AUD_B_LNGTH,\n\t\t.aud_cfg = AUD_B_CFG,\n\t\t.fld_aud_fifo_en = FLD_AUD_SRC_B_FIFO_EN,\n\t\t.fld_aud_risc_en = FLD_AUD_SRC_B_RISC_EN,\n\t\t.irq_bit = 11,\n\t},\n};\nEXPORT_SYMBOL(cx25821_sram_channels);\n\nstatic int cx25821_risc_decode(u32 risc)\n{\n\tstatic const char * const instr[16] = {\n\t\t[RISC_SYNC >> 28] = \"sync\",\n\t\t[RISC_WRITE >> 28] = \"write\",\n\t\t[RISC_WRITEC >> 28] = \"writec\",\n\t\t[RISC_READ >> 28] = \"read\",\n\t\t[RISC_READC >> 28] = \"readc\",\n\t\t[RISC_JUMP >> 28] = \"jump\",\n\t\t[RISC_SKIP >> 28] = \"skip\",\n\t\t[RISC_WRITERM >> 28] = \"writerm\",\n\t\t[RISC_WRITECM >> 28] = \"writecm\",\n\t\t[RISC_WRITECR >> 28] = \"writecr\",\n\t};\n\tstatic const int incr[16] = {\n\t\t[RISC_WRITE >> 28] = 3,\n\t\t[RISC_JUMP >> 28] = 3,\n\t\t[RISC_SKIP >> 28] = 1,\n\t\t[RISC_SYNC >> 28] = 1,\n\t\t[RISC_WRITERM >> 28] = 3,\n\t\t[RISC_WRITECM >> 28] = 3,\n\t\t[RISC_WRITECR >> 28] = 4,\n\t};\n\tstatic const char * const bits[] = {\n\t\t\"12\", \"13\", \"14\", \"resync\",\n\t\t\"cnt0\", \"cnt1\", \"18\", \"19\",\n\t\t\"20\", \"21\", \"22\", \"23\",\n\t\t\"irq1\", \"irq2\", \"eol\", \"sol\",\n\t};\n\tint i;\n\n\tpr_cont(\"0x%08x [ %s\",\n\t\trisc, instr[risc >> 28] ? instr[risc >> 28] : \"INVALID\");\n\tfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--) {\n\t\tif (risc & (1 << (i + 12)))\n\t\t\tpr_cont(\" %s\", bits[i]);\n\t}\n\tpr_cont(\" count=%d ]\\n\", risc & 0xfff);\n\treturn incr[risc >> 28] ? incr[risc >> 28] : 1;\n}\n\nstatic void cx25821_registers_init(struct cx25821_dev *dev)\n{\n\tu32 tmp;\n\n\t \n\tcx_write(DEV_CNTRL2, 0x20);\n\n\t \n\tcx_write(PCI_INT_MSK, 0x2001FFFF);\n\n\ttmp = cx_read(RDR_TLCTL0);\n\ttmp &= ~FLD_CFG_RCB_CK_EN;\t \n\tcx_write(RDR_TLCTL0, tmp);\n\n\t \n\tcx_write(PLL_A_INT_FRAC, 0x9807A58B);\n\n\t \n\tcx_write(PLL_A_POST_STAT_BIST, 0x8000019C);\n\n\t \n\ttmp = cx_read(PLL_A_INT_FRAC);\n\tcx_write(PLL_A_INT_FRAC, tmp & 0x7FFFFFFF);\n\n\t \n\tcx_write(PLL_B_INT_FRAC, 0x9883A86F);\n\n\t \n\tcx_write(PLL_B_POST_STAT_BIST, 0x8000018D);\n\n\t \n\ttmp = cx_read(PLL_B_INT_FRAC);\n\tcx_write(PLL_B_INT_FRAC, tmp & 0x7FFFFFFF);\n\n\t \n\tcx_write(PLL_C_INT_FRAC, 0x96A0EA3F);\n\n\t \n\tcx_write(PLL_C_POST_STAT_BIST, 0x80000103);\n\n\t \n\ttmp = cx_read(PLL_C_INT_FRAC);\n\tcx_write(PLL_C_INT_FRAC, tmp & 0x7FFFFFFF);\n\n\t \n\tcx_write(PLL_D_INT_FRAC, 0x98757F5B);\n\n\t \n\tcx_write(PLL_D_POST_STAT_BIST, 0x80000113);\n\n\t \n\ttmp = cx_read(PLL_D_INT_FRAC);\n\tcx_write(PLL_D_INT_FRAC, tmp & 0x7FFFFFFF);\n\n\t \n\ttmp = cx_read(VID_CH_CLK_SEL);\n\tcx_write(VID_CH_CLK_SEL, (tmp & 0x00FFFFFF) | 0x24000000);\n\n\t \n\ttmp = cx_read(VID_CH_MODE_SEL);\n\t \n\tcx_write(VID_CH_MODE_SEL, tmp & 0xFFFFFE00);\n\n\t \n\ttmp = cx_read(CLK_RST);\n\t \n\ttmp |= FLD_USE_ALT_PLL_REF;\n\tcx_write(CLK_RST, tmp & ~(FLD_VID_I_CLK_NOE | FLD_VID_J_CLK_NOE));\n\n\tmsleep(100);\n}\n\nint cx25821_sram_channel_setup(struct cx25821_dev *dev,\n\t\t\t       const struct sram_channel *ch,\n\t\t\t       unsigned int bpl, u32 risc)\n{\n\tunsigned int i, lines;\n\tu32 cdt;\n\n\tif (ch->cmds_start == 0) {\n\t\tcx_write(ch->ptr1_reg, 0);\n\t\tcx_write(ch->ptr2_reg, 0);\n\t\tcx_write(ch->cnt2_reg, 0);\n\t\tcx_write(ch->cnt1_reg, 0);\n\t\treturn 0;\n\t}\n\n\tbpl = (bpl + 7) & ~7;\t \n\tcdt = ch->cdt;\n\tlines = ch->fifo_size / bpl;\n\n\tif (lines > 4)\n\t\tlines = 4;\n\n\tBUG_ON(lines < 2);\n\n\tcx_write(8 + 0, RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\n\tcx_write(8 + 4, 8);\n\tcx_write(8 + 8, 0);\n\n\t \n\tfor (i = 0; i < lines; i++) {\n\t\tcx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\n\t\tcx_write(cdt + 16 * i + 4, 0);\n\t\tcx_write(cdt + 16 * i + 8, 0);\n\t\tcx_write(cdt + 16 * i + 12, 0);\n\t}\n\n\t \n\tfor (i = 0; i < 128; i++)\n\t\tcx_write(ch->fifo_start + 4 * i, i);\n\n\t \n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 0, 8);\n\telse\n\t\tcx_write(ch->cmds_start + 0, risc);\n\n\tcx_write(ch->cmds_start + 4, 0);\t \n\tcx_write(ch->cmds_start + 8, cdt);\n\tcx_write(ch->cmds_start + 12, (lines * 16) >> 3);\n\tcx_write(ch->cmds_start + 16, ch->ctrl_start);\n\n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\n\telse\n\t\tcx_write(ch->cmds_start + 20, 64 >> 2);\n\n\tfor (i = 24; i < 80; i += 4)\n\t\tcx_write(ch->cmds_start + i, 0);\n\n\t \n\tcx_write(ch->ptr1_reg, ch->fifo_start);\n\tcx_write(ch->ptr2_reg, cdt);\n\tcx_write(ch->cnt2_reg, (lines * 16) >> 3);\n\tcx_write(ch->cnt1_reg, (bpl >> 3) - 1);\n\n\treturn 0;\n}\n\nint cx25821_sram_channel_setup_audio(struct cx25821_dev *dev,\n\t\t\t\t     const struct sram_channel *ch,\n\t\t\t\t     unsigned int bpl, u32 risc)\n{\n\tunsigned int i, lines;\n\tu32 cdt;\n\n\tif (ch->cmds_start == 0) {\n\t\tcx_write(ch->ptr1_reg, 0);\n\t\tcx_write(ch->ptr2_reg, 0);\n\t\tcx_write(ch->cnt2_reg, 0);\n\t\tcx_write(ch->cnt1_reg, 0);\n\t\treturn 0;\n\t}\n\n\tbpl = (bpl + 7) & ~7;\t \n\tcdt = ch->cdt;\n\tlines = ch->fifo_size / bpl;\n\n\tif (lines > 3)\n\t\tlines = 3;\t \n\n\tBUG_ON(lines < 2);\n\n\tcx_write(8 + 0, RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\n\tcx_write(8 + 4, 8);\n\tcx_write(8 + 8, 0);\n\n\t \n\tfor (i = 0; i < lines; i++) {\n\t\tcx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\n\t\tcx_write(cdt + 16 * i + 4, 0);\n\t\tcx_write(cdt + 16 * i + 8, 0);\n\t\tcx_write(cdt + 16 * i + 12, 0);\n\t}\n\n\t \n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 0, 8);\n\telse\n\t\tcx_write(ch->cmds_start + 0, risc);\n\n\tcx_write(ch->cmds_start + 4, 0);\t \n\tcx_write(ch->cmds_start + 8, cdt);\n\tcx_write(ch->cmds_start + 12, (lines * 16) >> 3);\n\tcx_write(ch->cmds_start + 16, ch->ctrl_start);\n\n\t \n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\n\telse\n\t\tcx_write(ch->cmds_start + 20, 64 >> 2);\n\n\t \n\tfor (i = 24; i < 80; i += 4)\n\t\tcx_write(ch->cmds_start + i, 0);\n\n\t \n\tcx_write(ch->ptr1_reg, ch->fifo_start);\n\tcx_write(ch->ptr2_reg, cdt);\n\tcx_write(ch->cnt2_reg, (lines * 16) >> 3);\n\tcx_write(ch->cnt1_reg, (bpl >> 3) - 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx25821_sram_channel_setup_audio);\n\nvoid cx25821_sram_channel_dump(struct cx25821_dev *dev, const struct sram_channel *ch)\n{\n\tstatic char *name[] = {\n\t\t\"init risc lo\",\n\t\t\"init risc hi\",\n\t\t\"cdt base\",\n\t\t\"cdt size\",\n\t\t\"iq base\",\n\t\t\"iq size\",\n\t\t\"risc pc lo\",\n\t\t\"risc pc hi\",\n\t\t\"iq wr ptr\",\n\t\t\"iq rd ptr\",\n\t\t\"cdt current\",\n\t\t\"pci target lo\",\n\t\t\"pci target hi\",\n\t\t\"line / byte\",\n\t};\n\tu32 risc;\n\tunsigned int i, j, n;\n\n\tpr_warn(\"%s: %s - dma channel status dump\\n\", dev->name, ch->name);\n\tfor (i = 0; i < ARRAY_SIZE(name); i++)\n\t\tpr_warn(\"cmds + 0x%2x:   %-15s: 0x%08x\\n\",\n\t\t\ti * 4, name[i], cx_read(ch->cmds_start + 4 * i));\n\n\tj = i * 4;\n\tfor (i = 0; i < 4;) {\n\t\trisc = cx_read(ch->cmds_start + 4 * (i + 14));\n\t\tpr_warn(\"cmds + 0x%2x:   risc%d: \", j + i * 4, i);\n\t\ti += cx25821_risc_decode(risc);\n\t}\n\n\tfor (i = 0; i < (64 >> 2); i += n) {\n\t\trisc = cx_read(ch->ctrl_start + 4 * i);\n\t\t \n\n\t\tpr_warn(\"ctrl + 0x%2x (0x%08x): iq %x: \",\n\t\t\ti * 4, ch->ctrl_start + 4 * i, i);\n\t\tn = cx25821_risc_decode(risc);\n\t\tfor (j = 1; j < n; j++) {\n\t\t\trisc = cx_read(ch->ctrl_start + 4 * (i + j));\n\t\t\tpr_warn(\"ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\t4 * (i + j), i + j, risc, j);\n\t\t}\n\t}\n\n\tpr_warn(\"        :   fifo: 0x%08x -> 0x%x\\n\",\n\t\tch->fifo_start, ch->fifo_start + ch->fifo_size);\n\tpr_warn(\"        :   ctrl: 0x%08x -> 0x%x\\n\",\n\t\tch->ctrl_start, ch->ctrl_start + 6 * 16);\n\tpr_warn(\"        :   ptr1_reg: 0x%08x\\n\",\n\t\tcx_read(ch->ptr1_reg));\n\tpr_warn(\"        :   ptr2_reg: 0x%08x\\n\",\n\t\tcx_read(ch->ptr2_reg));\n\tpr_warn(\"        :   cnt1_reg: 0x%08x\\n\",\n\t\tcx_read(ch->cnt1_reg));\n\tpr_warn(\"        :   cnt2_reg: 0x%08x\\n\",\n\t\tcx_read(ch->cnt2_reg));\n}\n\nvoid cx25821_sram_channel_dump_audio(struct cx25821_dev *dev,\n\t\t\t\t     const struct sram_channel *ch)\n{\n\tstatic const char * const name[] = {\n\t\t\"init risc lo\",\n\t\t\"init risc hi\",\n\t\t\"cdt base\",\n\t\t\"cdt size\",\n\t\t\"iq base\",\n\t\t\"iq size\",\n\t\t\"risc pc lo\",\n\t\t\"risc pc hi\",\n\t\t\"iq wr ptr\",\n\t\t\"iq rd ptr\",\n\t\t\"cdt current\",\n\t\t\"pci target lo\",\n\t\t\"pci target hi\",\n\t\t\"line / byte\",\n\t};\n\n\tu32 risc, value, tmp;\n\tunsigned int i, j, n;\n\n\tpr_info(\"\\n%s: %s - dma Audio channel status dump\\n\",\n\t\tdev->name, ch->name);\n\n\tfor (i = 0; i < ARRAY_SIZE(name); i++)\n\t\tpr_info(\"%s: cmds + 0x%2x:   %-15s: 0x%08x\\n\",\n\t\t\tdev->name, i * 4, name[i],\n\t\t\tcx_read(ch->cmds_start + 4 * i));\n\n\tj = i * 4;\n\tfor (i = 0; i < 4;) {\n\t\trisc = cx_read(ch->cmds_start + 4 * (i + 14));\n\t\tpr_warn(\"cmds + 0x%2x:   risc%d: \", j + i * 4, i);\n\t\ti += cx25821_risc_decode(risc);\n\t}\n\n\tfor (i = 0; i < (64 >> 2); i += n) {\n\t\trisc = cx_read(ch->ctrl_start + 4 * i);\n\t\t \n\n\t\tpr_warn(\"ctrl + 0x%2x (0x%08x): iq %x: \",\n\t\t\ti * 4, ch->ctrl_start + 4 * i, i);\n\t\tn = cx25821_risc_decode(risc);\n\n\t\tfor (j = 1; j < n; j++) {\n\t\t\trisc = cx_read(ch->ctrl_start + 4 * (i + j));\n\t\t\tpr_warn(\"ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\t4 * (i + j), i + j, risc, j);\n\t\t}\n\t}\n\n\tpr_warn(\"        :   fifo: 0x%08x -> 0x%x\\n\",\n\t\tch->fifo_start, ch->fifo_start + ch->fifo_size);\n\tpr_warn(\"        :   ctrl: 0x%08x -> 0x%x\\n\",\n\t\tch->ctrl_start, ch->ctrl_start + 6 * 16);\n\tpr_warn(\"        :   ptr1_reg: 0x%08x\\n\",\n\t\tcx_read(ch->ptr1_reg));\n\tpr_warn(\"        :   ptr2_reg: 0x%08x\\n\",\n\t\tcx_read(ch->ptr2_reg));\n\tpr_warn(\"        :   cnt1_reg: 0x%08x\\n\",\n\t\tcx_read(ch->cnt1_reg));\n\tpr_warn(\"        :   cnt2_reg: 0x%08x\\n\",\n\t\tcx_read(ch->cnt2_reg));\n\n\tfor (i = 0; i < 4; i++) {\n\t\trisc = cx_read(ch->cmds_start + 56 + (i * 4));\n\t\tpr_warn(\"instruction %d = 0x%x\\n\", i, risc);\n\t}\n\n\t \n\trisc = cx_read(AUD_A_CDT);\n\tpr_warn(\"\\nread cdt loc=0x%x\\n\", risc);\n\tfor (i = 0; i < 8; i++) {\n\t\tn = cx_read(risc + i * 4);\n\t\tpr_cont(\"0x%x \", n);\n\t}\n\tpr_cont(\"\\n\\n\");\n\n\tvalue = cx_read(CLK_RST);\n\tCX25821_INFO(\" CLK_RST = 0x%x\\n\\n\", value);\n\n\tvalue = cx_read(PLL_A_POST_STAT_BIST);\n\tCX25821_INFO(\" PLL_A_POST_STAT_BIST = 0x%x\\n\\n\", value);\n\tvalue = cx_read(PLL_A_INT_FRAC);\n\tCX25821_INFO(\" PLL_A_INT_FRAC = 0x%x\\n\\n\", value);\n\n\tvalue = cx_read(PLL_B_POST_STAT_BIST);\n\tCX25821_INFO(\" PLL_B_POST_STAT_BIST = 0x%x\\n\\n\", value);\n\tvalue = cx_read(PLL_B_INT_FRAC);\n\tCX25821_INFO(\" PLL_B_INT_FRAC = 0x%x\\n\\n\", value);\n\n\tvalue = cx_read(PLL_C_POST_STAT_BIST);\n\tCX25821_INFO(\" PLL_C_POST_STAT_BIST = 0x%x\\n\\n\", value);\n\tvalue = cx_read(PLL_C_INT_FRAC);\n\tCX25821_INFO(\" PLL_C_INT_FRAC = 0x%x\\n\\n\", value);\n\n\tvalue = cx_read(PLL_D_POST_STAT_BIST);\n\tCX25821_INFO(\" PLL_D_POST_STAT_BIST = 0x%x\\n\\n\", value);\n\tvalue = cx_read(PLL_D_INT_FRAC);\n\tCX25821_INFO(\" PLL_D_INT_FRAC = 0x%x\\n\\n\", value);\n\n\tvalue = cx25821_i2c_read(&dev->i2c_bus[0], AFE_AB_DIAG_CTRL, &tmp);\n\tCX25821_INFO(\" AFE_AB_DIAG_CTRL (0x10900090) = 0x%x\\n\\n\", value);\n}\nEXPORT_SYMBOL(cx25821_sram_channel_dump_audio);\n\nstatic void cx25821_shutdown(struct cx25821_dev *dev)\n{\n\tint i;\n\n\t \n\tcx_write(DEV_CNTRL2, 0);\n\n\t \n\tfor (i = 0; i < VID_CHANNEL_NUM; i++) {\n\t\tcx_write(dev->channels[i].sram_channels->dma_ctl, 0);\n\t\tcx_write(dev->channels[i].sram_channels->int_msk, 0);\n\t}\n\n\tfor (i = VID_UPSTREAM_SRAM_CHANNEL_I;\n\t\ti <= VID_UPSTREAM_SRAM_CHANNEL_J; i++) {\n\t\tcx_write(dev->channels[i].sram_channels->dma_ctl, 0);\n\t\tcx_write(dev->channels[i].sram_channels->int_msk, 0);\n\t}\n\n\t \n\tcx_write(AUD_INT_DMA_CTL, 0);\n\n\t \n\tcx_write(UART_CTL, 0);\n\n\t \n\tcx_write(PCI_INT_MSK, 0);\n\tcx_write(AUD_A_INT_MSK, 0);\n}\n\nvoid cx25821_set_pixel_format(struct cx25821_dev *dev, int channel_select,\n\t\t\t      u32 format)\n{\n\tif (channel_select <= 7 && channel_select >= 0) {\n\t\tcx_write(dev->channels[channel_select].sram_channels->pix_frmt,\n\t\t\t\tformat);\n\t}\n\tdev->channels[channel_select].pixel_formats = format;\n}\n\nstatic void cx25821_set_vip_mode(struct cx25821_dev *dev,\n\t\t\t\t const struct sram_channel *ch)\n{\n\tcx_write(ch->pix_frmt, PIXEL_FRMT_422);\n\tcx_write(ch->vip_ctl, PIXEL_ENGINE_VIP1);\n}\n\nstatic void cx25821_initialize(struct cx25821_dev *dev)\n{\n\tint i;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tcx25821_shutdown(dev);\n\tcx_write(PCI_INT_STAT, 0xffffffff);\n\n\tfor (i = 0; i < VID_CHANNEL_NUM; i++)\n\t\tcx_write(dev->channels[i].sram_channels->int_stat, 0xffffffff);\n\n\tcx_write(AUD_A_INT_STAT, 0xffffffff);\n\tcx_write(AUD_B_INT_STAT, 0xffffffff);\n\tcx_write(AUD_C_INT_STAT, 0xffffffff);\n\tcx_write(AUD_D_INT_STAT, 0xffffffff);\n\tcx_write(AUD_E_INT_STAT, 0xffffffff);\n\n\tcx_write(CLK_DELAY, cx_read(CLK_DELAY) & 0x80000000);\n\tcx_write(PAD_CTRL, 0x12);\t \n\tcx25821_registers_init(dev);\t \n\tmsleep(100);\n\n\tfor (i = 0; i < VID_CHANNEL_NUM; i++) {\n\t\tcx25821_set_vip_mode(dev, dev->channels[i].sram_channels);\n\t\tcx25821_sram_channel_setup(dev, dev->channels[i].sram_channels,\n\t\t\t\t\t\t1440, 0);\n\t\tdev->channels[i].pixel_formats = PIXEL_FRMT_422;\n\t\tdev->channels[i].use_cif_resolution = 0;\n\t}\n\n\t \n\tfor (i = VID_UPSTREAM_SRAM_CHANNEL_I;\n\t\ti <= VID_UPSTREAM_SRAM_CHANNEL_J; i++) {\n\t\tdev->channels[i].pixel_formats = PIXEL_FRMT_422;\n\t\tcx25821_set_vip_mode(dev, dev->channels[i].sram_channels);\n\t}\n\n\tcx25821_sram_channel_setup_audio(dev,\n\t\t\tdev->channels[SRAM_CH08].sram_channels, 128, 0);\n\n\tcx25821_gpio_init(dev);\n}\n\nstatic int cx25821_get_resources(struct cx25821_dev *dev)\n{\n\tif (request_mem_region(pci_resource_start(dev->pci, 0),\n\t\t\t\tpci_resource_len(dev->pci, 0), dev->name))\n\t\treturn 0;\n\n\tpr_err(\"%s: can't get MMIO memory @ 0x%llx\\n\",\n\t\tdev->name, (unsigned long long)pci_resource_start(dev->pci, 0));\n\n\treturn -EBUSY;\n}\n\nstatic void cx25821_dev_checkrevision(struct cx25821_dev *dev)\n{\n\tdev->hwrevision = cx_read(RDR_CFG2) & 0xff;\n\n\tpr_info(\"Hardware revision = 0x%02x\\n\", dev->hwrevision);\n}\n\nstatic void cx25821_iounmap(struct cx25821_dev *dev)\n{\n\tif (dev == NULL)\n\t\treturn;\n\n\t \n\tif (dev->lmmio != NULL) {\n\t\tiounmap(dev->lmmio);\n\t\tdev->lmmio = NULL;\n\t}\n}\n\nstatic int cx25821_dev_setup(struct cx25821_dev *dev)\n{\n\tstatic unsigned int cx25821_devcount;\n\tint i;\n\n\tmutex_init(&dev->lock);\n\n\tdev->nr = ++cx25821_devcount;\n\tsprintf(dev->name, \"cx25821[%d]\", dev->nr);\n\n\tif (dev->nr >= ARRAY_SIZE(card)) {\n\t\tCX25821_INFO(\"dev->nr >= %zd\", ARRAY_SIZE(card));\n\t\treturn -ENODEV;\n\t}\n\tif (dev->pci->device != 0x8210) {\n\t\tpr_info(\"%s(): Exiting. Incorrect Hardware device = 0x%02x\\n\",\n\t\t\t__func__, dev->pci->device);\n\t\treturn -ENODEV;\n\t}\n\tpr_info(\"Athena Hardware device = 0x%02x\\n\", dev->pci->device);\n\n\t \n\tdev->clk_freq = 28000000;\n\tfor (i = 0; i < MAX_VID_CHANNEL_NUM; i++) {\n\t\tdev->channels[i].dev = dev;\n\t\tdev->channels[i].id = i;\n\t\tdev->channels[i].sram_channels = &cx25821_sram_channels[i];\n\t}\n\n\t \n\tdev->board = 1;\t\t \n\tdev->_max_num_decoders = MAX_DECODERS;\n\n\tdev->pci_bus = dev->pci->bus->number;\n\tdev->pci_slot = PCI_SLOT(dev->pci->devfn);\n\tdev->pci_irqmask = 0x001f00;\n\n\t \n\tdev->i2c_bus[0].nr = 0;\n\tdev->i2c_bus[0].dev = dev;\n\tdev->i2c_bus[0].reg_stat = I2C1_STAT;\n\tdev->i2c_bus[0].reg_ctrl = I2C1_CTRL;\n\tdev->i2c_bus[0].reg_addr = I2C1_ADDR;\n\tdev->i2c_bus[0].reg_rdata = I2C1_RDATA;\n\tdev->i2c_bus[0].reg_wdata = I2C1_WDATA;\n\tdev->i2c_bus[0].i2c_period = (0x07 << 24);\t \n\n\tif (cx25821_get_resources(dev) < 0) {\n\t\tpr_err(\"%s: No more PCIe resources for subsystem: %04x:%04x\\n\",\n\t\t       dev->name, dev->pci->subsystem_vendor,\n\t\t       dev->pci->subsystem_device);\n\n\t\tcx25821_devcount--;\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdev->base_io_addr = pci_resource_start(dev->pci, 0);\n\n\tif (!dev->base_io_addr) {\n\t\tCX25821_ERR(\"No PCI Memory resources, exiting!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev->lmmio = ioremap(dev->base_io_addr, pci_resource_len(dev->pci, 0));\n\n\tif (!dev->lmmio) {\n\t\tCX25821_ERR(\"ioremap failed, maybe increasing __VMALLOC_RESERVE in page.h\\n\");\n\t\tcx25821_iounmap(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->bmmio = (u8 __iomem *) dev->lmmio;\n\n\tpr_info(\"%s: subsystem: %04x:%04x, board: %s [card=%d,%s]\\n\",\n\t\tdev->name, dev->pci->subsystem_vendor,\n\t\tdev->pci->subsystem_device, cx25821_boards[dev->board].name,\n\t\tdev->board, card[dev->nr] == dev->board ?\n\t\t\"insmod option\" : \"autodetected\");\n\n\t \n\tcx25821_initialize(dev);\n\n\tcx25821_i2c_register(&dev->i2c_bus[0]);\n \n\n\tif (medusa_video_init(dev) < 0)\n\t\tCX25821_ERR(\"%s(): Failed to initialize medusa!\\n\", __func__);\n\n\tcx25821_video_register(dev);\n\n\tcx25821_dev_checkrevision(dev);\n\treturn 0;\n}\n\nvoid cx25821_dev_unregister(struct cx25821_dev *dev)\n{\n\tint i;\n\n\tif (!dev->base_io_addr)\n\t\treturn;\n\n\trelease_mem_region(dev->base_io_addr, pci_resource_len(dev->pci, 0));\n\n\tfor (i = 0; i < MAX_VID_CAP_CHANNEL_NUM - 1; i++) {\n\t\tif (i == SRAM_CH08)  \n\t\t\tcontinue;\n\t\t \n\t\tcx25821_video_unregister(dev, i);\n\t}\n\n\tcx25821_i2c_unregister(&dev->i2c_bus[0]);\n\tcx25821_iounmap(dev);\n}\nEXPORT_SYMBOL(cx25821_dev_unregister);\n\nint cx25821_riscmem_alloc(struct pci_dev *pci,\n\t\t       struct cx25821_riscmem *risc,\n\t\t       unsigned int size)\n{\n\t__le32 *cpu;\n\tdma_addr_t dma = 0;\n\n\tif (risc->cpu && risc->size < size) {\n\t\tdma_free_coherent(&pci->dev, risc->size, risc->cpu, risc->dma);\n\t\trisc->cpu = NULL;\n\t}\n\tif (NULL == risc->cpu) {\n\t\tcpu = dma_alloc_coherent(&pci->dev, size, &dma, GFP_KERNEL);\n\t\tif (NULL == cpu)\n\t\t\treturn -ENOMEM;\n\t\trisc->cpu  = cpu;\n\t\trisc->dma  = dma;\n\t\trisc->size = size;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(cx25821_riscmem_alloc);\n\nstatic __le32 *cx25821_risc_field(__le32 * rp, struct scatterlist *sglist,\n\t\t\t\t  unsigned int offset, u32 sync_line,\n\t\t\t\t  unsigned int bpl, unsigned int padding,\n\t\t\t\t  unsigned int lines, bool jump)\n{\n\tstruct scatterlist *sg;\n\tunsigned int line, todo;\n\n\tif (jump) {\n\t\t*(rp++) = cpu_to_le32(RISC_JUMP);\n\t\t*(rp++) = cpu_to_le32(0);\n\t\t*(rp++) = cpu_to_le32(0);  \n\t}\n\n\t \n\tif (sync_line != NO_SYNC_LINE)\n\t\t*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < lines; line++) {\n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t\tif (bpl <= sg_dma_len(sg) - offset) {\n\t\t\t \n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | RISC_SOL | RISC_EOL |\n\t\t\t\t\tbpl);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\toffset += bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | RISC_SOL |\n\t\t\t\t\t(sg_dma_len(sg) - offset));\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\ttodo -= (sg_dma_len(sg) - offset);\n\t\t\toffset = 0;\n\t\t\tsg = sg_next(sg);\n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE |\n\t\t\t\t\t\tsg_dma_len(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t}\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\toffset += todo;\n\t\t}\n\n\t\toffset += padding;\n\t}\n\n\treturn rp;\n}\n\nint cx25821_risc_buffer(struct pci_dev *pci, struct cx25821_riscmem *risc,\n\t\t\tstruct scatterlist *sglist, unsigned int top_offset,\n\t\t\tunsigned int bottom_offset, unsigned int bpl,\n\t\t\tunsigned int padding, unsigned int lines)\n{\n\tu32 instructions;\n\tu32 fields;\n\t__le32 *rp;\n\tint rc;\n\n\tfields = 0;\n\tif (UNSET != top_offset)\n\t\tfields++;\n\tif (UNSET != bottom_offset)\n\t\tfields++;\n\n\t \n\t \n\tinstructions = fields * (1 + ((bpl + padding) * lines) / PAGE_SIZE +\n\t\t\tlines);\n\tinstructions += 5;\n\trc = cx25821_riscmem_alloc(pci, risc, instructions * 12);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trp = risc->cpu;\n\n\tif (UNSET != top_offset) {\n\t\trp = cx25821_risc_field(rp, sglist, top_offset, 0, bpl, padding,\n\t\t\t\t\tlines, true);\n\t}\n\n\tif (UNSET != bottom_offset) {\n\t\trp = cx25821_risc_field(rp, sglist, bottom_offset, 0x200, bpl,\n\t\t\t\t\tpadding, lines, UNSET == top_offset);\n\t}\n\n\t \n\trisc->jmp = rp;\n\tBUG_ON((risc->jmp - risc->cpu + 3) * sizeof(*risc->cpu) > risc->size);\n\n\treturn 0;\n}\n\nstatic __le32 *cx25821_risc_field_audio(__le32 * rp, struct scatterlist *sglist,\n\t\t\t\t\tunsigned int offset, u32 sync_line,\n\t\t\t\t\tunsigned int bpl, unsigned int padding,\n\t\t\t\t\tunsigned int lines, unsigned int lpi)\n{\n\tstruct scatterlist *sg;\n\tunsigned int line, todo, sol;\n\n\t \n\tif (sync_line != NO_SYNC_LINE)\n\t\t*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < lines; line++) {\n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t\tif (lpi && line > 0 && !(line % lpi))\n\t\t\tsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\n\t\telse\n\t\t\tsol = RISC_SOL;\n\n\t\tif (bpl <= sg_dma_len(sg) - offset) {\n\t\t\t \n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | sol | RISC_EOL |\n\t\t\t\t\tbpl);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\toffset += bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | sol |\n\t\t\t\t\t(sg_dma_len(sg) - offset));\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\ttodo -= (sg_dma_len(sg) - offset);\n\t\t\toffset = 0;\n\t\t\tsg = sg_next(sg);\n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE |\n\t\t\t\t\t\tsg_dma_len(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t}\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t*(rp++) = cpu_to_le32(0);\t \n\t\t\toffset += todo;\n\t\t}\n\t\toffset += padding;\n\t}\n\n\treturn rp;\n}\n\nint cx25821_risc_databuffer_audio(struct pci_dev *pci,\n\t\t\t\t  struct cx25821_riscmem *risc,\n\t\t\t\t  struct scatterlist *sglist,\n\t\t\t\t  unsigned int bpl,\n\t\t\t\t  unsigned int lines, unsigned int lpi)\n{\n\tu32 instructions;\n\t__le32 *rp;\n\tint rc;\n\n\t \n\t \n\tinstructions = 1 + (bpl * lines) / PAGE_SIZE + lines;\n\tinstructions += 1;\n\n\trc = cx25821_riscmem_alloc(pci, risc, instructions * 12);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trp = risc->cpu;\n\trp = cx25821_risc_field_audio(rp, sglist, 0, NO_SYNC_LINE, bpl, 0,\n\t\t\t\t      lines, lpi);\n\n\t \n\trisc->jmp = rp;\n\tBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx25821_risc_databuffer_audio);\n\nvoid cx25821_free_buffer(struct cx25821_dev *dev, struct cx25821_buffer *buf)\n{\n\tif (WARN_ON(buf->risc.size == 0))\n\t\treturn;\n\tdma_free_coherent(&dev->pci->dev, buf->risc.size, buf->risc.cpu,\n\t\t\t  buf->risc.dma);\n\tmemset(&buf->risc, 0, sizeof(buf->risc));\n}\n\nstatic irqreturn_t cx25821_irq(int irq, void *dev_id)\n{\n\tstruct cx25821_dev *dev = dev_id;\n\tu32 pci_status;\n\tu32 vid_status;\n\tint i, handled = 0;\n\tu32 mask[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };\n\n\tpci_status = cx_read(PCI_INT_STAT);\n\n\tif (pci_status == 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < VID_CHANNEL_NUM; i++) {\n\t\tif (pci_status & mask[i]) {\n\t\t\tvid_status = cx_read(dev->channels[i].\n\t\t\t\tsram_channels->int_stat);\n\n\t\t\tif (vid_status)\n\t\t\t\thandled += cx25821_video_irq(dev, i,\n\t\t\t\t\t\tvid_status);\n\n\t\t\tcx_write(PCI_INT_STAT, mask[i]);\n\t\t}\n\t}\n\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\nvoid cx25821_print_irqbits(char *name, char *tag, char **strings,\n\t\t\t   int len, u32 bits, u32 mask)\n{\n\tunsigned int i;\n\n\tprintk(KERN_DEBUG pr_fmt(\"%s: %s [0x%x]\"), name, tag, bits);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!(bits & (1 << i)))\n\t\t\tcontinue;\n\t\tif (strings[i])\n\t\t\tpr_cont(\" %s\", strings[i]);\n\t\telse\n\t\t\tpr_cont(\" %d\", i);\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\t\tpr_cont(\"*\");\n\t}\n\tpr_cont(\"\\n\");\n}\nEXPORT_SYMBOL(cx25821_print_irqbits);\n\nstruct cx25821_dev *cx25821_dev_get(struct pci_dev *pci)\n{\n\tstruct cx25821_dev *dev = pci_get_drvdata(pci);\n\treturn dev;\n}\nEXPORT_SYMBOL(cx25821_dev_get);\n\nstatic int cx25821_initdev(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct cx25821_dev *dev;\n\tint err = 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (NULL == dev)\n\t\treturn -ENOMEM;\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err < 0)\n\t\tgoto fail_free;\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\n\t\tpr_info(\"pci enable failed!\\n\");\n\n\t\tgoto fail_unregister_device;\n\t}\n\n\terr = cx25821_dev_setup(dev);\n\tif (err)\n\t\tgoto fail_unregister_pci;\n\n\t \n\tpci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\n\tpr_info(\"%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tdev->name, pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t\tdev->pci_lat, (unsigned long long)dev->base_io_addr);\n\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, 0xffffffff);\n\tif (err) {\n\t\tpr_err(\"%s/0: Oops: no 32bit PCI DMA ???\\n\", dev->name);\n\t\terr = -EIO;\n\t\tgoto fail_irq;\n\t}\n\n\terr = request_irq(pci_dev->irq, cx25821_irq,\n\t\t\tIRQF_SHARED, dev->name, dev);\n\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't get IRQ %d\\n\", dev->name, pci_dev->irq);\n\t\tgoto fail_irq;\n\t}\n\n\treturn 0;\n\nfail_irq:\n\tpr_info(\"cx25821_initdev() can't get IRQ !\\n\");\n\tcx25821_dev_unregister(dev);\n\nfail_unregister_pci:\n\tpci_disable_device(pci_dev);\nfail_unregister_device:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\nfail_free:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void cx25821_finidev(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct cx25821_dev *dev = get_cx25821(v4l2_dev);\n\n\tcx25821_shutdown(dev);\n\n\t \n\tif (pci_dev->irq)\n\t\tfree_irq(pci_dev->irq, dev);\n\tpci_disable_device(pci_dev);\n\n\tcx25821_dev_unregister(dev);\n\tv4l2_device_unregister(v4l2_dev);\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id cx25821_pci_tbl[] = {\n\t{\n\t\t \n\t\t.vendor = 0x14f1,\n\t\t.device = 0x8210,\n\t\t.subvendor = 0x14f1,\n\t\t.subdevice = 0x0920,\n\t}, {\n\t\t \n\t\t.vendor = 0x14f1,\n\t\t.device = 0x8210,\n\t\t.subvendor = 0x0000,\n\t\t.subdevice = 0x0000,\n\t}, {\n\t\t \n\t}\n};\n\nMODULE_DEVICE_TABLE(pci, cx25821_pci_tbl);\n\nstatic struct pci_driver cx25821_pci_driver = {\n\t.name = \"cx25821\",\n\t.id_table = cx25821_pci_tbl,\n\t.probe = cx25821_initdev,\n\t.remove = cx25821_finidev,\n};\n\nstatic int __init cx25821_init(void)\n{\n\tpr_info(\"driver loaded\\n\");\n\treturn pci_register_driver(&cx25821_pci_driver);\n}\n\nstatic void __exit cx25821_fini(void)\n{\n\tpci_unregister_driver(&cx25821_pci_driver);\n}\n\nmodule_init(cx25821_init);\nmodule_exit(cx25821_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}