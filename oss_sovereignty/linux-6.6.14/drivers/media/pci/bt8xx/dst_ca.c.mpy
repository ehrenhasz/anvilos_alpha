{
  "module_name": "dst_ca.c",
  "hash_id": "086c2604d5ebcd13e9f840735eb3257e41d3c5902d625d0760556add89a191c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/dst_ca.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/dvb/ca.h>\n#include <media/dvbdev.h>\n#include <media/dvb_frontend.h>\n#include \"dst_ca.h\"\n#include \"dst_common.h\"\n\n#define DST_CA_ERROR\t\t0\n#define DST_CA_NOTICE\t\t1\n#define DST_CA_INFO\t\t2\n#define DST_CA_DEBUG\t\t3\n\n#define dprintk(x, y, z, format, arg...) do {\t\t\t\t\t\t\\\n\tif (z) {\t\t\t\t\t\t\t\t\t\\\n\t\tif\t((x > DST_CA_ERROR) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t\telse if\t((x > DST_CA_NOTICE) && (x > y))\t\t\t\t\\\n\t\t\tprintk(KERN_NOTICE \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t\telse if ((x > DST_CA_INFO) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_INFO \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t\telse if ((x > DST_CA_DEBUG) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\\\n\t\tif (x > y)\t\t\t\t\t\t\t\t\\\n\t\t\tprintk(format, ## arg);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while(0)\n\n\nstatic DEFINE_MUTEX(dst_ca_mutex);\nstatic unsigned int verbose = 5;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"verbose startup messages, default is 1 (yes)\");\n\nstatic void put_command_and_length(u8 *data, int command, int length)\n{\n\tdata[0] = (command >> 16) & 0xff;\n\tdata[1] = (command >> 8) & 0xff;\n\tdata[2] = command & 0xff;\n\tdata[3] = length;\n}\n\nstatic void put_checksum(u8 *check_string, int length)\n{\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Computing string checksum.\");\n\tdprintk(verbose, DST_CA_DEBUG, 1, \"  -> string length : 0x%02x\", length);\n\tcheck_string[length] = dst_check_sum (check_string, length);\n\tdprintk(verbose, DST_CA_DEBUG, 1, \"  -> checksum      : 0x%02x\", check_string[length]);\n}\n\nstatic int dst_ci_command(struct dst_state* state, u8 * data, u8 *ca_string, u8 len, int read)\n{\n\tu8 reply;\n\n\tmutex_lock(&state->dst_mutex);\n\tdst_comm_init(state);\n\tmsleep(65);\n\n\tif (write_dst(state, data, len)) {\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Write not successful, trying to recover\");\n\t\tdst_error_recovery(state);\n\t\tgoto error;\n\t}\n\tif ((dst_pio_disable(state)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" DST PIO disable failed.\");\n\t\tgoto error;\n\t}\n\tif (read_dst(state, &reply, GET_ACK) < 0) {\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Read not successful, trying to recover\");\n\t\tdst_error_recovery(state);\n\t\tgoto error;\n\t}\n\tif (read) {\n\t\tif (! dst_wait_dst_ready(state, LONG_DELAY)) {\n\t\t\tdprintk(verbose, DST_CA_NOTICE, 1, \" 8820 not ready\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (read_dst(state, ca_string, 128) < 0) {\t \n\t\t\tdprintk(verbose, DST_CA_INFO, 1, \" Read not successful, trying to recover\");\n\t\t\tdst_error_recovery(state);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmutex_unlock(&state->dst_mutex);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&state->dst_mutex);\n\treturn -EIO;\n}\n\n\nstatic int dst_put_ci(struct dst_state *state, u8 *data, int len, u8 *ca_string, int read)\n{\n\tu8 dst_ca_comm_err = 0;\n\n\twhile (dst_ca_comm_err < RETRIES) {\n\t\tdprintk(verbose, DST_CA_NOTICE, 1, \" Put Command\");\n\t\tif (dst_ci_command(state, data, ca_string, len, read)) {\t\n\t\t\tdst_error_recovery(state);\n\t\t\tdst_ca_comm_err++; \n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dst_ca_comm_err == RETRIES)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n\nstatic int ca_get_app_info(struct dst_state *state)\n{\n\tint length, str_length;\n\tstatic u8 command[8] = {0x07, 0x40, 0x01, 0x00, 0x01, 0x00, 0x00, 0xff};\n\n\tput_checksum(&command[0], command[0]);\n\tif ((dst_put_ci(state, command, sizeof(command), state->messages, GET_REPLY)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->dst_put_ci FAILED !\");\n\t\treturn -EIO;\n\t}\n\tdprintk(verbose, DST_CA_INFO, 1, \" -->dst_put_ci SUCCESS !\");\n\tdprintk(verbose, DST_CA_INFO, 1, \" ================================ CI Module Application Info ======================================\");\n\tdprintk(verbose, DST_CA_INFO, 1, \" Application Type=[%d], Application Vendor=[%d], Vendor Code=[%d]\\n%s: Application info=[%s]\",\n\t\tstate->messages[7], (state->messages[8] << 8) | state->messages[9],\n\t\t(state->messages[10] << 8) | state->messages[11], __func__, (char *)(&state->messages[12]));\n\tdprintk(verbose, DST_CA_INFO, 1, \" ==================================================================================================\");\n\n\t\n\tlength = state->messages[5];\n\tstr_length = length - 6;\n\tif (str_length < 0) {\n\t\tstr_length = 0;\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \"Invalid string length returned in ca_get_app_info(). Recovering.\");\n\t}\n\n\t\n\tput_command_and_length(&state->messages[0], CA_APP_INFO, length);\n\n\t\n\tmemmove(&state->messages[4], &state->messages[7], 5);\n\n\t\n\tstate->messages[9] = str_length;\n\tmemmove(&state->messages[10], &state->messages[12], str_length);\n\n\treturn 0;\n}\n\nstatic int ca_get_ca_info(struct dst_state *state)\n{\n\tint srcPtr, dstPtr, i, num_ids;\n\tstatic u8 slot_command[8] = {0x07, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff};\n\tconst int in_system_id_pos = 8, out_system_id_pos = 4, in_num_ids_pos = 7;\n\n\tput_checksum(&slot_command[0], slot_command[0]);\n\tif ((dst_put_ci(state, slot_command, sizeof (slot_command), state->messages, GET_REPLY)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->dst_put_ci FAILED !\");\n\t\treturn -EIO;\n\t}\n\tdprintk(verbose, DST_CA_INFO, 1, \" -->dst_put_ci SUCCESS !\");\n\n\t\n\tdprintk(verbose, DST_CA_INFO, 0, \" DST data = [\");\n\tfor (i = 0; i < state->messages[0] + 1; i++) {\n\t\tdprintk(verbose, DST_CA_INFO, 0, \" 0x%02x\", state->messages[i]);\n\t}\n\tdprintk(verbose, DST_CA_INFO, 0, \"]\\n\");\n\n\t\n\tnum_ids = state->messages[in_num_ids_pos];\n\tif (num_ids >= 100) {\n\t\tnum_ids = 100;\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \"Invalid number of ids (>100). Recovering.\");\n\t}\n\tput_command_and_length(&state->messages[0], CA_INFO, num_ids * 2);\n\n\tdprintk(verbose, DST_CA_INFO, 0, \" CA_INFO = [\");\n\tsrcPtr = in_system_id_pos;\n\tdstPtr = out_system_id_pos;\n\tfor(i = 0; i < num_ids; i++) {\n\t\tdprintk(verbose, DST_CA_INFO, 0, \" 0x%02x%02x\", state->messages[srcPtr + 0], state->messages[srcPtr + 1]);\n\t\t\n\t\tstate->messages[dstPtr + 0] = state->messages[srcPtr + 0];\n\t\tstate->messages[dstPtr + 1] = state->messages[srcPtr + 1];\n\t\tsrcPtr += 2;\n\t\tdstPtr += 2;\n\t}\n\tdprintk(verbose, DST_CA_INFO, 0, \"]\\n\");\n\n\treturn 0;\n}\n\nstatic int ca_get_slot_caps(struct dst_state *state, struct ca_caps *p_ca_caps, void __user *arg)\n{\n\tint i;\n\tu8 slot_cap[256];\n\tstatic u8 slot_command[8] = {0x07, 0x40, 0x02, 0x00, 0x02, 0x00, 0x00, 0xff};\n\n\tput_checksum(&slot_command[0], slot_command[0]);\n\tif ((dst_put_ci(state, slot_command, sizeof (slot_command), slot_cap, GET_REPLY)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->dst_put_ci FAILED !\");\n\t\treturn -EIO;\n\t}\n\tdprintk(verbose, DST_CA_NOTICE, 1, \" -->dst_put_ci SUCCESS !\");\n\n\t \n\n\tdprintk(verbose, DST_CA_INFO, 1, \" Slot cap = [%d]\", slot_cap[7]);\n\tdprintk(verbose, DST_CA_INFO, 0, \"===================================\\n\");\n\tfor (i = 0; i < slot_cap[0] + 1; i++)\n\t\tdprintk(verbose, DST_CA_INFO, 0, \" %d\", slot_cap[i]);\n\tdprintk(verbose, DST_CA_INFO, 0, \"\\n\");\n\n\tp_ca_caps->slot_num = 1;\n\tp_ca_caps->slot_type = 1;\n\tp_ca_caps->descr_num = slot_cap[7];\n\tp_ca_caps->descr_type = 1;\n\n\tif (copy_to_user(arg, p_ca_caps, sizeof (struct ca_caps)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ca_get_slot_descr(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\n\nstatic int ca_get_slot_info(struct dst_state *state, struct ca_slot_info *p_ca_slot_info, void __user *arg)\n{\n\tint i;\n\tstatic u8 slot_command[8] = {0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff};\n\n\tu8 *slot_info = state->messages;\n\n\tput_checksum(&slot_command[0], 7);\n\tif ((dst_put_ci(state, slot_command, sizeof (slot_command), slot_info, GET_REPLY)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->dst_put_ci FAILED !\");\n\t\treturn -EIO;\n\t}\n\tdprintk(verbose, DST_CA_INFO, 1, \" -->dst_put_ci SUCCESS !\");\n\n\t \n\n\tdprintk(verbose, DST_CA_INFO, 1, \" Slot info = [%d]\", slot_info[3]);\n\tdprintk(verbose, DST_CA_INFO, 0, \"===================================\\n\");\n\tfor (i = 0; i < 8; i++)\n\t\tdprintk(verbose, DST_CA_INFO, 0, \" %d\", slot_info[i]);\n\tdprintk(verbose, DST_CA_INFO, 0, \"\\n\");\n\n\tif (slot_info[4] & 0x80) {\n\t\tp_ca_slot_info->flags = CA_CI_MODULE_PRESENT;\n\t\tp_ca_slot_info->num = 1;\n\t\tp_ca_slot_info->type = CA_CI;\n\t} else if (slot_info[4] & 0x40) {\n\t\tp_ca_slot_info->flags = CA_CI_MODULE_READY;\n\t\tp_ca_slot_info->num = 1;\n\t\tp_ca_slot_info->type = CA_CI;\n\t} else\n\t\tp_ca_slot_info->flags = 0;\n\n\tif (copy_to_user(arg, p_ca_slot_info, sizeof (struct ca_slot_info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n\nstatic int ca_get_message(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\n{\n\tu8 i = 0;\n\tu32 command = 0;\n\n\tif (copy_from_user(p_ca_message, arg, sizeof (struct ca_msg)))\n\t\treturn -EFAULT;\n\n\tdprintk(verbose, DST_CA_NOTICE, 1, \" Message = [%*ph]\",\n\t\t3, p_ca_message->msg);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcommand = command | p_ca_message->msg[i];\n\t\tif (i < 2)\n\t\t\tcommand = command << 8;\n\t}\n\tdprintk(verbose, DST_CA_NOTICE, 1, \" Command=[0x%x]\", command);\n\n\tswitch (command) {\n\tcase CA_APP_INFO:\n\t\tmemcpy(p_ca_message->msg, state->messages, 128);\n\t\tif (copy_to_user(arg, p_ca_message, sizeof (struct ca_msg)) )\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase CA_INFO:\n\t\tmemcpy(p_ca_message->msg, state->messages, 128);\n\t\tif (copy_to_user(arg, p_ca_message, sizeof (struct ca_msg)) )\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_dst_tag(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer, u32 length)\n{\n\tif (state->dst_hw_cap & DST_TYPE_HAS_SESSION) {\n\t\thw_buffer->msg[2] = p_ca_message->msg[1];\t \n\t\thw_buffer->msg[3] = p_ca_message->msg[2];\t \n\t} else {\n\t\tif (length > 247) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" Message too long ! *** Bailing Out *** !\");\n\t\t\treturn -EIO;\n\t\t}\n\t\thw_buffer->msg[0] = (length & 0xff) + 7;\n\t\thw_buffer->msg[1] = 0x40;\n\t\thw_buffer->msg[2] = 0x03;\n\t\thw_buffer->msg[3] = 0x00;\n\t\thw_buffer->msg[4] = 0x03;\n\t\thw_buffer->msg[5] = length & 0xff;\n\t\thw_buffer->msg[6] = 0x00;\n\n\t\t \n\t\tmemcpy(&hw_buffer->msg[7], &p_ca_message->msg[4], length);\n\t}\n\n\treturn 0;\n}\n\nstatic int write_to_8820(struct dst_state *state, struct ca_msg *hw_buffer, u8 length, u8 reply)\n{\n\tif ((dst_put_ci(state, hw_buffer->msg, length, hw_buffer->msg, reply)) < 0) {\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" DST-CI Command failed.\");\n\t\tdprintk(verbose, DST_CA_NOTICE, 1, \" Resetting DST.\");\n\t\trdc_reset_state(state);\n\t\treturn -EIO;\n\t}\n\tdprintk(verbose, DST_CA_NOTICE, 1, \" DST-CI Command success.\");\n\n\treturn 0;\n}\n\nstatic u32 asn_1_decode(u8 *asn_1_array)\n{\n\tu8 length_field = 0, word_count = 0, count = 0;\n\tu32 length = 0;\n\n\tlength_field = asn_1_array[0];\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Length field=[%02x]\", length_field);\n\tif (length_field < 0x80) {\n\t\tlength = length_field & 0x7f;\n\t\tdprintk(verbose, DST_CA_DEBUG, 1, \" Length=[%02x]\\n\", length);\n\t} else {\n\t\tword_count = length_field & 0x7f;\n\t\tfor (count = 0; count < word_count; count++) {\n\t\t\tlength = length  << 8;\n\t\t\tlength += asn_1_array[count + 1];\n\t\t\tdprintk(verbose, DST_CA_DEBUG, 1, \" Length=[%04x]\", length);\n\t\t}\n\t}\n\treturn length;\n}\n\nstatic int debug_string(u8 *msg, u32 length, u32 offset)\n{\n\tu32 i;\n\n\tdprintk(verbose, DST_CA_DEBUG, 0, \" String=[ \");\n\tfor (i = offset; i < length; i++)\n\t\tdprintk(verbose, DST_CA_DEBUG, 0, \"%02x \", msg[i]);\n\tdprintk(verbose, DST_CA_DEBUG, 0, \"]\\n\");\n\n\treturn 0;\n}\n\n\nstatic int ca_set_pmt(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer, u8 reply, u8 query)\n{\n\tu32 length = 0;\n\tu8 tag_length = 8;\n\n\tlength = asn_1_decode(&p_ca_message->msg[3]);\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" CA Message length=[%d]\", length);\n\tdebug_string(&p_ca_message->msg[4], length, 0);  \n\n\tmemset(hw_buffer->msg, '\\0', length);\n\thandle_dst_tag(state, p_ca_message, hw_buffer, length);\n\tput_checksum(hw_buffer->msg, hw_buffer->msg[0]);\n\n\tdebug_string(hw_buffer->msg, (length + tag_length), 0);  \n\twrite_to_8820(state, hw_buffer, (length + tag_length), reply);\n\n\treturn 0;\n}\n\n\n \nstatic int dst_check_ca_pmt(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer)\n{\n\tint ca_pmt_reply_test = 0;\n\n\t \n\t \n\n\t \n\tif (ca_pmt_reply_test) {\n\t\tif ((ca_set_pmt(state, p_ca_message, hw_buffer, 1, GET_REPLY)) < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" ca_set_pmt.. failed !\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t \n\t \n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" Not there yet\");\n\t}\n\t \n\tif (!ca_pmt_reply_test) {\n\t\tif ((ca_set_pmt(state, p_ca_message, hw_buffer, 0, NO_REPLY)) < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" ca_set_pmt.. failed !\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tdprintk(verbose, DST_CA_NOTICE, 1, \" ca_set_pmt.. success !\");\n\t \n\n\t}\n\treturn 0;\n}\n\nstatic int ca_send_message(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\n{\n\tint i;\n\tu32 command;\n\tstruct ca_msg *hw_buffer;\n\tint result = 0;\n\n\thw_buffer = kmalloc(sizeof(*hw_buffer), GFP_KERNEL);\n\tif (!hw_buffer)\n\t\treturn -ENOMEM;\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" \");\n\n\tif (copy_from_user(p_ca_message, arg, sizeof (struct ca_msg))) {\n\t\tresult = -EFAULT;\n\t\tgoto free_mem_and_exit;\n\t}\n\n\t \n\tcommand = 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcommand = command | p_ca_message->msg[i];\n\t\tif (i < 2)\n\t\t\tcommand = command << 8;\n\t}\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Command=[0x%x]\\n\", command);\n\n\tswitch (command) {\n\tcase CA_PMT:\n\t\tdprintk(verbose, DST_CA_DEBUG, 1, \"Command = SEND_CA_PMT\");\n\t\tif ((ca_set_pmt(state, p_ca_message, hw_buffer, 0, 0)) < 0) {\t\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_PMT Failed !\");\n\t\t\tresult = -1;\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_PMT Success !\");\n\t\tbreak;\n\tcase CA_PMT_REPLY:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \"Command = CA_PMT_REPLY\");\n\t\t \n\t\tif ((dst_check_ca_pmt(state, p_ca_message, hw_buffer)) < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_PMT_REPLY Failed !\");\n\t\t\tresult = -1;\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_PMT_REPLY Success !\");\n\t\tbreak;\n\tcase CA_APP_INFO_ENQUIRY:\t\t\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting Cam Application information\");\n\n\t\tif ((ca_get_app_info(state)) < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_APP_INFO_ENQUIRY Failed !\");\n\t\t\tresult = -1;\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_APP_INFO_ENQUIRY Success !\");\n\t\tbreak;\n\tcase CA_INFO_ENQUIRY:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting CA Information\");\n\n\t\tif ((ca_get_ca_info(state)) < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_INFO_ENQUIRY Failed !\");\n\t\t\tresult = -1;\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_INFO_ENQUIRY Success !\");\n\t\tbreak;\n\t}\n\nfree_mem_and_exit:\n\tkfree (hw_buffer);\n\n\treturn result;\n}\n\nstatic long dst_ca_ioctl(struct file *file, unsigned int cmd, unsigned long ioctl_arg)\n{\n\tstruct dvb_device *dvbdev;\n\tstruct dst_state *state;\n\tstruct ca_slot_info *p_ca_slot_info;\n\tstruct ca_caps *p_ca_caps;\n\tstruct ca_msg *p_ca_message;\n\tvoid __user *arg = (void __user *)ioctl_arg;\n\tint result = 0;\n\n\tmutex_lock(&dst_ca_mutex);\n\tdvbdev = file->private_data;\n\tstate = dvbdev->priv;\n\tp_ca_message = kmalloc(sizeof (struct ca_msg), GFP_KERNEL);\n\tp_ca_slot_info = kmalloc(sizeof (struct ca_slot_info), GFP_KERNEL);\n\tp_ca_caps = kmalloc(sizeof (struct ca_caps), GFP_KERNEL);\n\tif (!p_ca_message || !p_ca_slot_info || !p_ca_caps) {\n\t\tresult = -ENOMEM;\n\t\tgoto free_mem_and_exit;\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase CA_SEND_MSG:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Sending message\");\n\t\tresult = ca_send_message(state, p_ca_message, arg);\n\n\t\tif (result < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_SEND_MSG Failed !\");\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tbreak;\n\tcase CA_GET_MSG:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting message\");\n\t\tresult = ca_get_message(state, p_ca_message, arg);\n\t\tif (result < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_GET_MSG Failed !\");\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_GET_MSG Success !\");\n\t\tbreak;\n\tcase CA_RESET:\n\t\tdprintk(verbose, DST_CA_ERROR, 1, \" Resetting DST\");\n\t\tdst_error_bailout(state);\n\t\tmsleep(4000);\n\t\tbreak;\n\tcase CA_GET_SLOT_INFO:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting Slot info\");\n\t\tresult = ca_get_slot_info(state, p_ca_slot_info, arg);\n\t\tif (result < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_GET_SLOT_INFO Failed !\");\n\t\t\tresult = -1;\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_GET_SLOT_INFO Success !\");\n\t\tbreak;\n\tcase CA_GET_CAP:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting Slot capabilities\");\n\t\tresult = ca_get_slot_caps(state, p_ca_caps, arg);\n\t\tif (result < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_GET_CAP Failed !\");\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_GET_CAP Success !\");\n\t\tbreak;\n\tcase CA_GET_DESCR_INFO:\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" Getting descrambler description\");\n\t\tresult = ca_get_slot_descr(state, p_ca_message, arg);\n\t\tif (result < 0) {\n\t\t\tdprintk(verbose, DST_CA_ERROR, 1, \" -->CA_GET_DESCR_INFO Failed !\");\n\t\t\tgoto free_mem_and_exit;\n\t\t}\n\t\tdprintk(verbose, DST_CA_INFO, 1, \" -->CA_GET_DESCR_INFO Success !\");\n\t\tbreak;\n\tdefault:\n\t\tresult = -EOPNOTSUPP;\n\t}\n free_mem_and_exit:\n\tkfree (p_ca_message);\n\tkfree (p_ca_slot_info);\n\tkfree (p_ca_caps);\n\n\tmutex_unlock(&dst_ca_mutex);\n\treturn result;\n}\n\nstatic int dst_ca_open(struct inode *inode, struct file *file)\n{\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Device opened [%p] \", file);\n\n\treturn 0;\n}\n\nstatic int dst_ca_release(struct inode *inode, struct file *file)\n{\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Device closed.\");\n\n\treturn 0;\n}\n\nstatic ssize_t dst_ca_read(struct file *file, char __user *buffer, size_t length, loff_t *offset)\n{\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Device read.\");\n\n\treturn 0;\n}\n\nstatic ssize_t dst_ca_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset)\n{\n\tdprintk(verbose, DST_CA_DEBUG, 1, \" Device write.\");\n\n\treturn 0;\n}\n\nstatic const struct file_operations dst_ca_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = dst_ca_ioctl,\n\t.open = dst_ca_open,\n\t.release = dst_ca_release,\n\t.read = dst_ca_read,\n\t.write = dst_ca_write,\n\t.llseek = noop_llseek,\n};\n\nstatic struct dvb_device dvbdev_ca = {\n\t.priv = NULL,\n\t.users = 1,\n\t.readers = 1,\n\t.writers = 1,\n\t.fops = &dst_ca_fops\n};\n\nstruct dvb_device *dst_ca_attach(struct dst_state *dst, struct dvb_adapter *dvb_adapter)\n{\n\tstruct dvb_device *dvbdev;\n\n\tdprintk(verbose, DST_CA_ERROR, 1, \"registering DST-CA device\");\n\tif (dvb_register_device(dvb_adapter, &dvbdev, &dvbdev_ca, dst,\n\t\t\t\tDVB_DEVICE_CA, 0) == 0) {\n\t\tdst->dst_ca = dvbdev;\n\t\treturn dst->dst_ca;\n\t}\n\n\treturn NULL;\n}\n\nEXPORT_SYMBOL_GPL(dst_ca_attach);\n\nMODULE_DESCRIPTION(\"DST DVB-S/T/C Combo CA driver\");\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}