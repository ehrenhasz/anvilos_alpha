{
  "module_name": "bttv-gpio.c",
  "hash_id": "69c582e1a32b2d7fb47652dbd6912f1960767f58cff0dc2a6832a7c2e1aa2352",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-gpio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n\n#include \"bttvp.h\"\n\n \n \n\nstatic int bttv_sub_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct bttv_sub_driver *sub = to_bttv_sub_drv(drv);\n\tint len = strlen(sub->wanted);\n\n\tif (0 == strncmp(dev_name(dev), sub->wanted, len))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int bttv_sub_probe(struct device *dev)\n{\n\tstruct bttv_sub_device *sdev = to_bttv_sub_dev(dev);\n\tstruct bttv_sub_driver *sub = to_bttv_sub_drv(dev->driver);\n\n\treturn sub->probe ? sub->probe(sdev) : -ENODEV;\n}\n\nstatic void bttv_sub_remove(struct device *dev)\n{\n\tstruct bttv_sub_device *sdev = to_bttv_sub_dev(dev);\n\tstruct bttv_sub_driver *sub = to_bttv_sub_drv(dev->driver);\n\n\tif (sub->remove)\n\t\tsub->remove(sdev);\n}\n\nstruct bus_type bttv_sub_bus_type = {\n\t.name   = \"bttv-sub\",\n\t.match  = &bttv_sub_bus_match,\n\t.probe  = bttv_sub_probe,\n\t.remove = bttv_sub_remove,\n};\n\nstatic void release_sub_device(struct device *dev)\n{\n\tstruct bttv_sub_device *sub = to_bttv_sub_dev(dev);\n\tkfree(sub);\n}\n\nint bttv_sub_add_device(struct bttv_core *core, char *name)\n{\n\tstruct bttv_sub_device *sub;\n\tint err;\n\n\tsub = kzalloc(sizeof(*sub),GFP_KERNEL);\n\tif (NULL == sub)\n\t\treturn -ENOMEM;\n\n\tsub->core        = core;\n\tsub->dev.parent  = &core->pci->dev;\n\tsub->dev.bus     = &bttv_sub_bus_type;\n\tsub->dev.release = release_sub_device;\n\tdev_set_name(&sub->dev, \"%s%d\", name, core->nr);\n\n\terr = device_register(&sub->dev);\n\tif (0 != err) {\n\t\tput_device(&sub->dev);\n\t\treturn err;\n\t}\n\tpr_info(\"%d: add subdevice \\\"%s\\\"\\n\", core->nr, dev_name(&sub->dev));\n\tlist_add_tail(&sub->list,&core->subs);\n\treturn 0;\n}\n\nint bttv_sub_del_devices(struct bttv_core *core)\n{\n\tstruct bttv_sub_device *sub, *save;\n\n\tlist_for_each_entry_safe(sub, save, &core->subs, list) {\n\t\tlist_del(&sub->list);\n\t\tdevice_unregister(&sub->dev);\n\t}\n\treturn 0;\n}\n\n \n \n\nint bttv_sub_register(struct bttv_sub_driver *sub, char *wanted)\n{\n\tsub->drv.bus = &bttv_sub_bus_type;\n\tsnprintf(sub->wanted,sizeof(sub->wanted),\"%s\",wanted);\n\treturn driver_register(&sub->drv);\n}\nEXPORT_SYMBOL(bttv_sub_register);\n\nint bttv_sub_unregister(struct bttv_sub_driver *sub)\n{\n\tdriver_unregister(&sub->drv);\n\treturn 0;\n}\nEXPORT_SYMBOL(bttv_sub_unregister);\n\n \n \n\nvoid bttv_gpio_inout(struct bttv_core *core, u32 mask, u32 outbits)\n{\n\tstruct bttv *btv = container_of(core, struct bttv, c);\n\tunsigned long flags;\n\tu32 data;\n\n\tspin_lock_irqsave(&btv->gpio_lock,flags);\n\tdata = btread(BT848_GPIO_OUT_EN);\n\tdata = data & ~mask;\n\tdata = data | (mask & outbits);\n\tbtwrite(data,BT848_GPIO_OUT_EN);\n\tspin_unlock_irqrestore(&btv->gpio_lock,flags);\n}\n\nu32 bttv_gpio_read(struct bttv_core *core)\n{\n\tstruct bttv *btv = container_of(core, struct bttv, c);\n\tu32 value;\n\n\tvalue = btread(BT848_GPIO_DATA);\n\treturn value;\n}\n\nvoid bttv_gpio_write(struct bttv_core *core, u32 value)\n{\n\tstruct bttv *btv = container_of(core, struct bttv, c);\n\n\tbtwrite(value,BT848_GPIO_DATA);\n}\n\nvoid bttv_gpio_bits(struct bttv_core *core, u32 mask, u32 bits)\n{\n\tstruct bttv *btv = container_of(core, struct bttv, c);\n\tunsigned long flags;\n\tu32 data;\n\n\tspin_lock_irqsave(&btv->gpio_lock,flags);\n\tdata = btread(BT848_GPIO_DATA);\n\tdata = data & ~mask;\n\tdata = data | (mask & bits);\n\tbtwrite(data,BT848_GPIO_DATA);\n\tspin_unlock_irqrestore(&btv->gpio_lock,flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}