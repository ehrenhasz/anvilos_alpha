{
  "module_name": "bttv-risc.c",
  "hash_id": "18fdece3f6e11a2cf5d53fd5d2b650e773e839966f6790d3ddd55a61af62fdea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-risc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/pgtable.h>\n#include <asm/page.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"bttvp.h\"\n\n#define VCR_HACK_LINES 4\n\n \n \n\nint\nbttv_risc_packed(struct bttv *btv, struct btcx_riscmem *risc,\n\t\t struct scatterlist *sglist,\n\t\t unsigned int offset, unsigned int bpl,\n\t\t unsigned int padding, unsigned int skip_lines,\n\t\t unsigned int store_lines)\n{\n\tu32 instructions,line,todo;\n\tstruct scatterlist *sg;\n\t__le32 *rp;\n\tint rc;\n\n\t \n\tinstructions  = skip_lines * 4;\n\tinstructions += (1 + ((bpl + padding) * store_lines)\n\t\t\t / PAGE_SIZE + store_lines) * 8;\n\tinstructions += 2 * 8;\n\tif ((rc = btcx_riscmem_alloc(btv->c.pci,risc,instructions)) < 0)\n\t\treturn rc;\n\n\t \n\trp = risc->cpu;\n\t*(rp++) = cpu_to_le32(BT848_RISC_SYNC|BT848_FIFO_STATUS_FM1);\n\t*(rp++) = cpu_to_le32(0);\n\n\twhile (skip_lines-- > 0) {\n\t\t*(rp++) = cpu_to_le32(BT848_RISC_SKIP | BT848_RISC_SOL |\n\t\t\t\t      BT848_RISC_EOL | bpl);\n\t}\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < store_lines; line++) {\n\t\tif ((line >= (store_lines - VCR_HACK_LINES)) &&\n\t\t    btv->opt_vcr_hack)\n\t\t\tcontinue;\n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t\tif (bpl <= sg_dma_len(sg)-offset) {\n\t\t\t \n\t\t\t*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_SOL|\n\t\t\t\t\t    BT848_RISC_EOL|bpl);\n\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);\n\t\t\toffset+=bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\n\t\t\t*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_SOL|\n\t\t\t\t\t    (sg_dma_len(sg)-offset));\n\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);\n\t\t\ttodo -= (sg_dma_len(sg)-offset);\n\t\t\toffset = 0;\n\t\t\tsg = sg_next(sg);\n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++)=cpu_to_le32(BT848_RISC_WRITE|\n\t\t\t\t\t\t    sg_dma_len(sg));\n\t\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(sg));\n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t}\n\t\t\t*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_EOL|\n\t\t\t\t\t    todo);\n\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(sg));\n\t\t\toffset += todo;\n\t\t}\n\t\toffset += padding;\n\t}\n\n\t \n\trisc->jmp = rp;\n\tWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\n\nstatic int\nbttv_risc_planar(struct bttv *btv, struct btcx_riscmem *risc,\n\t\t struct scatterlist *sglist,\n\t\t unsigned int yoffset,  unsigned int ybpl,\n\t\t unsigned int ypadding, unsigned int ylines,\n\t\t unsigned int uoffset,  unsigned int voffset,\n\t\t unsigned int hshift,   unsigned int vshift,\n\t\t unsigned int cpadding)\n{\n\tunsigned int instructions,line,todo,ylen,chroma;\n\t__le32 *rp;\n\tu32 ri;\n\tstruct scatterlist *ysg;\n\tstruct scatterlist *usg;\n\tstruct scatterlist *vsg;\n\tint topfield = (0 == yoffset);\n\tint rc;\n\n\t \n\tinstructions  = ((3 + (ybpl + ypadding) * ylines * 2)\n\t\t\t / PAGE_SIZE) + ylines;\n\tinstructions += 2;\n\tif ((rc = btcx_riscmem_alloc(btv->c.pci,risc,instructions*4*5)) < 0)\n\t\treturn rc;\n\n\t \n\trp = risc->cpu;\n\t*(rp++) = cpu_to_le32(BT848_RISC_SYNC|BT848_FIFO_STATUS_FM3);\n\t*(rp++) = cpu_to_le32(0);\n\n\t \n\tysg = sglist;\n\tusg = sglist;\n\tvsg = sglist;\n\tfor (line = 0; line < ylines; line++) {\n\t\tif ((btv->opt_vcr_hack) &&\n\t\t    (line >= (ylines - VCR_HACK_LINES)))\n\t\t\tcontinue;\n\t\tswitch (vshift) {\n\t\tcase 0:\n\t\t\tchroma = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (topfield)\n\t\t\t\tchroma = ((line & 1) == 0);\n\t\t\telse\n\t\t\t\tchroma = ((line & 1) == 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (topfield)\n\t\t\t\tchroma = ((line & 3) == 0);\n\t\t\telse\n\t\t\t\tchroma = ((line & 3) == 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchroma = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (todo = ybpl; todo > 0; todo -= ylen) {\n\t\t\t \n\t\t\twhile (yoffset && yoffset >= sg_dma_len(ysg)) {\n\t\t\t\tyoffset -= sg_dma_len(ysg);\n\t\t\t\tysg = sg_next(ysg);\n\t\t\t}\n\n\t\t\t \n\t\t\tylen = todo;\n\t\t\tif (yoffset + ylen > sg_dma_len(ysg))\n\t\t\t\tylen = sg_dma_len(ysg) - yoffset;\n\t\t\tif (chroma) {\n\t\t\t\twhile (uoffset && uoffset >= sg_dma_len(usg)) {\n\t\t\t\t\tuoffset -= sg_dma_len(usg);\n\t\t\t\t\tusg = sg_next(usg);\n\t\t\t\t}\n\t\t\t\twhile (voffset && voffset >= sg_dma_len(vsg)) {\n\t\t\t\t\tvoffset -= sg_dma_len(vsg);\n\t\t\t\t\tvsg = sg_next(vsg);\n\t\t\t\t}\n\n\t\t\t\tif (uoffset + (ylen>>hshift) > sg_dma_len(usg))\n\t\t\t\t\tylen = (sg_dma_len(usg) - uoffset) << hshift;\n\t\t\t\tif (voffset + (ylen>>hshift) > sg_dma_len(vsg))\n\t\t\t\t\tylen = (sg_dma_len(vsg) - voffset) << hshift;\n\t\t\t\tri = BT848_RISC_WRITE123;\n\t\t\t} else {\n\t\t\t\tri = BT848_RISC_WRITE1S23;\n\t\t\t}\n\t\t\tif (ybpl == todo)\n\t\t\t\tri |= BT848_RISC_SOL;\n\t\t\tif (ylen == todo)\n\t\t\t\tri |= BT848_RISC_EOL;\n\n\t\t\t \n\t\t\t*(rp++)=cpu_to_le32(ri | ylen);\n\t\t\t*(rp++)=cpu_to_le32(((ylen >> hshift) << 16) |\n\t\t\t\t\t    (ylen >> hshift));\n\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(ysg)+yoffset);\n\t\t\tyoffset += ylen;\n\t\t\tif (chroma) {\n\t\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(usg)+uoffset);\n\t\t\t\tuoffset += ylen >> hshift;\n\t\t\t\t*(rp++)=cpu_to_le32(sg_dma_address(vsg)+voffset);\n\t\t\t\tvoffset += ylen >> hshift;\n\t\t\t}\n\t\t}\n\t\tyoffset += ypadding;\n\t\tif (chroma) {\n\t\t\tuoffset += cpadding;\n\t\t\tvoffset += cpadding;\n\t\t}\n\t}\n\n\t \n\trisc->jmp = rp;\n\tWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\n\n \n\nstatic void\nbttv_calc_geo_old(struct bttv *btv, struct bttv_geometry *geo,\n\t\t  int width, int height, int interleaved,\n\t\t  const struct bttv_tvnorm *tvnorm)\n{\n\tu32 xsf, sr;\n\tint vdelay;\n\n\tint swidth       = tvnorm->swidth;\n\tint totalwidth   = tvnorm->totalwidth;\n\tint scaledtwidth = tvnorm->scaledtwidth;\n\n\tif (btv->input == btv->dig) {\n\t\tswidth       = 720;\n\t\ttotalwidth   = 858;\n\t\tscaledtwidth = 858;\n\t}\n\n\tvdelay = tvnorm->vdelay;\n\n\txsf = (width*scaledtwidth)/swidth;\n\tgeo->hscale =  ((totalwidth*4096UL)/xsf-4096);\n\tgeo->hdelay =  tvnorm->hdelayx1;\n\tgeo->hdelay =  (geo->hdelay*width)/swidth;\n\tgeo->hdelay &= 0x3fe;\n\tsr = ((tvnorm->sheight >> (interleaved?0:1))*512)/height - 512;\n\tgeo->vscale =  (0x10000UL-sr) & 0x1fff;\n\tgeo->crop   =  ((width>>8)&0x03) | ((geo->hdelay>>6)&0x0c) |\n\t\t((tvnorm->sheight>>4)&0x30) | ((vdelay>>2)&0xc0);\n\tgeo->vscale |= interleaved ? (BT848_VSCALE_INT<<8) : 0;\n\tgeo->vdelay  =  vdelay;\n\tgeo->width   =  width;\n\tgeo->sheight =  tvnorm->sheight;\n\tgeo->vtotal  =  tvnorm->vtotal;\n\n\tif (btv->opt_combfilter) {\n\t\tgeo->vtc  = (width < 193) ? 2 : ((width < 385) ? 1 : 0);\n\t\tgeo->comb = (width < 769) ? 1 : 0;\n\t} else {\n\t\tgeo->vtc  = 0;\n\t\tgeo->comb = 0;\n\t}\n}\n\nstatic void\nbttv_calc_geo\t\t(struct bttv *                  btv,\n\t\t\t struct bttv_geometry *         geo,\n\t\t\t unsigned int                   width,\n\t\t\t unsigned int                   height,\n\t\t\t int                            both_fields,\n\t\t\t const struct bttv_tvnorm *     tvnorm,\n\t\t\t const struct v4l2_rect *       crop)\n{\n\tunsigned int c_width;\n\tunsigned int c_height;\n\tu32 sr;\n\n\tif ((crop->left == tvnorm->cropcap.defrect.left\n\t     && crop->top == tvnorm->cropcap.defrect.top\n\t     && crop->width == tvnorm->cropcap.defrect.width\n\t     && crop->height == tvnorm->cropcap.defrect.height\n\t     && width <= tvnorm->swidth  )\n\t    || btv->input == btv->dig) {\n\t\tbttv_calc_geo_old(btv, geo, width, height,\n\t\t\t\t  both_fields, tvnorm);\n\t\treturn;\n\t}\n\n\t \n\tc_width = min((unsigned int) crop->width, width * 16);\n\tc_height = min((unsigned int) crop->height, height * 16);\n\n\tgeo->width = width;\n\tgeo->hscale = (c_width * 4096U + (width >> 1)) / width - 4096;\n\t \n\tgeo->hdelay = ((crop->left * width + c_width) / c_width) & ~1;\n\n\tgeo->sheight = c_height;\n\tgeo->vdelay = crop->top - tvnorm->cropcap.bounds.top + MIN_VDELAY;\n\tsr = c_height >> !both_fields;\n\tsr = (sr * 512U + (height >> 1)) / height - 512;\n\tgeo->vscale = (0x10000UL - sr) & 0x1fff;\n\tgeo->vscale |= both_fields ? (BT848_VSCALE_INT << 8) : 0;\n\tgeo->vtotal = tvnorm->vtotal;\n\n\tgeo->crop = (((geo->width   >> 8) & 0x03) |\n\t\t     ((geo->hdelay  >> 6) & 0x0c) |\n\t\t     ((geo->sheight >> 4) & 0x30) |\n\t\t     ((geo->vdelay  >> 2) & 0xc0));\n\n\tif (btv->opt_combfilter) {\n\t\tgeo->vtc  = (width < 193) ? 2 : ((width < 385) ? 1 : 0);\n\t\tgeo->comb = (width < 769) ? 1 : 0;\n\t} else {\n\t\tgeo->vtc  = 0;\n\t\tgeo->comb = 0;\n\t}\n}\n\nstatic void\nbttv_apply_geo(struct bttv *btv, struct bttv_geometry *geo, int odd)\n{\n\tint off = odd ? 0x80 : 0x00;\n\n\tif (geo->comb)\n\t\tbtor(BT848_VSCALE_COMB, BT848_E_VSCALE_HI+off);\n\telse\n\t\tbtand(~BT848_VSCALE_COMB, BT848_E_VSCALE_HI+off);\n\n\tbtwrite(geo->vtc,             BT848_E_VTC+off);\n\tbtwrite(geo->hscale >> 8,     BT848_E_HSCALE_HI+off);\n\tbtwrite(geo->hscale & 0xff,   BT848_E_HSCALE_LO+off);\n\tbtaor((geo->vscale>>8), 0xe0, BT848_E_VSCALE_HI+off);\n\tbtwrite(geo->vscale & 0xff,   BT848_E_VSCALE_LO+off);\n\tbtwrite(geo->width & 0xff,    BT848_E_HACTIVE_LO+off);\n\tbtwrite(geo->hdelay & 0xff,   BT848_E_HDELAY_LO+off);\n\tbtwrite(geo->sheight & 0xff,  BT848_E_VACTIVE_LO+off);\n\tbtwrite(geo->vdelay & 0xff,   BT848_E_VDELAY_LO+off);\n\tbtwrite(geo->crop,            BT848_E_CROP+off);\n\tbtwrite(geo->vtotal>>8,       BT848_VTOTAL_HI);\n\tbtwrite(geo->vtotal & 0xff,   BT848_VTOTAL_LO);\n}\n\n \n \n\nstatic void bttv_set_risc_status(struct bttv *btv)\n{\n\tunsigned long cmd = BT848_RISC_JUMP;\n\tif (btv->loop_irq) {\n\t\tcmd |= BT848_RISC_IRQ;\n\t\tcmd |= (btv->loop_irq  & 0x0f) << 16;\n\t\tcmd |= (~btv->loop_irq & 0x0f) << 20;\n\t}\n\tbtv->main.cpu[RISC_SLOT_LOOP] = cpu_to_le32(cmd);\n}\n\nstatic void bttv_set_irq_timer(struct bttv *btv)\n{\n\tif (btv->curr.frame_irq || btv->loop_irq || btv->cvbi)\n\t\tmod_timer(&btv->timeout, jiffies + BTTV_TIMEOUT);\n\telse\n\t\tdel_timer(&btv->timeout);\n}\n\nstatic int bttv_set_capture_control(struct bttv *btv, int start_capture)\n{\n\tint capctl = 0;\n\n\tif (btv->curr.top || btv->curr.bottom)\n\t\tcapctl = BT848_CAP_CTL_CAPTURE_ODD |\n\t\t\t BT848_CAP_CTL_CAPTURE_EVEN;\n\n\tif (btv->cvbi)\n\t\tcapctl |= BT848_CAP_CTL_CAPTURE_VBI_ODD |\n\t\t\t  BT848_CAP_CTL_CAPTURE_VBI_EVEN;\n\n\tcapctl |= start_capture;\n\n\tbtaor(capctl, ~0x0f, BT848_CAP_CTL);\n\n\treturn capctl;\n}\n\nstatic void bttv_start_dma(struct bttv *btv)\n{\n\tif (btv->dma_on)\n\t\treturn;\n\tbtwrite(btv->main.dma, BT848_RISC_STRT_ADD);\n\tbtor(BT848_GPIO_DMA_CTL_RISC_ENABLE | BT848_GPIO_DMA_CTL_FIFO_ENABLE,\n\t     BT848_GPIO_DMA_CTL);\n\tbtv->dma_on = 1;\n}\n\nstatic void bttv_stop_dma(struct bttv *btv)\n{\n\tif (!btv->dma_on)\n\t\treturn;\n\tbtand(~(BT848_GPIO_DMA_CTL_RISC_ENABLE |\n\t\tBT848_GPIO_DMA_CTL_FIFO_ENABLE), BT848_GPIO_DMA_CTL);\n\tbtv->dma_on = 0;\n}\n\nvoid bttv_set_dma(struct bttv *btv, int start_capture)\n{\n\tint capctl = 0;\n\n\tbttv_set_risc_status(btv);\n\tbttv_set_irq_timer(btv);\n\tcapctl = bttv_set_capture_control(btv, start_capture);\n\n\tif (capctl)\n\t\tbttv_start_dma(btv);\n\telse\n\t\tbttv_stop_dma(btv);\n\n\td2printk(\"%d: capctl=%x lirq=%d top=%08llx/%08llx even=%08llx/%08llx\\n\",\n\t\t btv->c.nr,capctl,btv->loop_irq,\n\t\t btv->cvbi         ? (unsigned long long)btv->cvbi->top.dma            : 0,\n\t\t btv->curr.top     ? (unsigned long long)btv->curr.top->top.dma        : 0,\n\t\t btv->cvbi         ? (unsigned long long)btv->cvbi->bottom.dma         : 0,\n\t\t btv->curr.bottom  ? (unsigned long long)btv->curr.bottom->bottom.dma  : 0);\n}\n\nint\nbttv_risc_init_main(struct bttv *btv)\n{\n\tint rc;\n\n\tif ((rc = btcx_riscmem_alloc(btv->c.pci,&btv->main,PAGE_SIZE)) < 0)\n\t\treturn rc;\n\tdprintk(\"%d: risc main @ %08llx\\n\",\n\t\tbtv->c.nr, (unsigned long long)btv->main.dma);\n\n\tbtv->main.cpu[0] = cpu_to_le32(BT848_RISC_SYNC | BT848_RISC_RESYNC |\n\t\t\t\t       BT848_FIFO_STATUS_VRE);\n\tbtv->main.cpu[1] = cpu_to_le32(0);\n\tbtv->main.cpu[2] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[3] = cpu_to_le32(btv->main.dma + (4<<2));\n\n\t \n\tbtv->main.cpu[4] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[5] = cpu_to_le32(btv->main.dma + (6<<2));\n\tbtv->main.cpu[6] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[7] = cpu_to_le32(btv->main.dma + (8<<2));\n\n\tbtv->main.cpu[8] = cpu_to_le32(BT848_RISC_SYNC | BT848_RISC_RESYNC |\n\t\t\t\t       BT848_FIFO_STATUS_VRO);\n\tbtv->main.cpu[9] = cpu_to_le32(0);\n\n\t \n\tbtv->main.cpu[10] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[11] = cpu_to_le32(btv->main.dma + (12<<2));\n\tbtv->main.cpu[12] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[13] = cpu_to_le32(btv->main.dma + (14<<2));\n\n\t \n\tbtv->main.cpu[14] = cpu_to_le32(BT848_RISC_JUMP);\n\tbtv->main.cpu[15] = cpu_to_le32(btv->main.dma + (0<<2));\n\n\treturn 0;\n}\n\nint\nbttv_risc_hook(struct bttv *btv, int slot, struct btcx_riscmem *risc,\n\t       int irqflags)\n{\n\tunsigned long cmd;\n\tunsigned long next = btv->main.dma + ((slot+2) << 2);\n\n\tif (NULL == risc) {\n\t\td2printk(\"%d: risc=%p slot[%d]=NULL\\n\", btv->c.nr, risc, slot);\n\t\tbtv->main.cpu[slot+1] = cpu_to_le32(next);\n\t} else {\n\t\td2printk(\"%d: risc=%p slot[%d]=%08llx irq=%d\\n\",\n\t\t\t btv->c.nr, risc, slot,\n\t\t\t (unsigned long long)risc->dma, irqflags);\n\t\tcmd = BT848_RISC_JUMP;\n\t\tif (irqflags) {\n\t\t\tcmd |= BT848_RISC_IRQ;\n\t\t\tcmd |= (irqflags  & 0x0f) << 16;\n\t\t\tcmd |= (~irqflags & 0x0f) << 20;\n\t\t}\n\t\trisc->jmp[0] = cpu_to_le32(cmd);\n\t\trisc->jmp[1] = cpu_to_le32(next);\n\t\tbtv->main.cpu[slot+1] = cpu_to_le32(risc->dma);\n\t}\n\treturn 0;\n}\n\nint bttv_buffer_risc_vbi(struct bttv *btv, struct bttv_buffer *buf)\n{\n\tint r = 0;\n\tunsigned int offset;\n\tunsigned int bpl = 2044;  \n\tunsigned int padding = VBI_BPL - bpl;\n\tunsigned int skip_lines0 = 0;\n\tunsigned int skip_lines1 = 0;\n\tunsigned int min_vdelay = MIN_VDELAY;\n\n\tconst struct bttv_tvnorm *tvnorm = btv->vbi_fmt.tvnorm;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vbuf.vb2_buf, 0);\n\tstruct scatterlist *list = sgt->sgl;\n\n\tif (btv->vbi_fmt.fmt.count[0] > 0)\n\t\tskip_lines0 = max(0, (btv->vbi_fmt.fmt.start[0] -\n\t\t\t\t\ttvnorm->vbistart[0]));\n\tif (btv->vbi_fmt.fmt.count[1] > 0)\n\t\tskip_lines1 = max(0, (btv->vbi_fmt.fmt.start[1] -\n\t\t\t\t\ttvnorm->vbistart[1]));\n\n\tif (btv->vbi_fmt.fmt.count[0] > 0) {\n\t\tr = bttv_risc_packed(btv, &buf->top, list, 0, bpl, padding,\n\t\t\t\t     skip_lines0, btv->vbi_fmt.fmt.count[0]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (btv->vbi_fmt.fmt.count[1] > 0) {\n\t\toffset = btv->vbi_fmt.fmt.count[0] * VBI_BPL;\n\t\tr = bttv_risc_packed(btv, &buf->bottom, list, offset, bpl,\n\t\t\t\t     padding, skip_lines1,\n\t\t\t\t     btv->vbi_fmt.fmt.count[1]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (btv->vbi_fmt.end >= tvnorm->cropcap.bounds.top)\n\t\tmin_vdelay += btv->vbi_fmt.end - tvnorm->cropcap.bounds.top;\n\n\t \n\tbuf->geo.vdelay = min_vdelay;\n\n\treturn r;\n}\n\nint\nbttv_buffer_activate_vbi(struct bttv *btv,\n\t\t\t struct bttv_buffer *vbi)\n{\n\tstruct btcx_riscmem *top;\n\tstruct btcx_riscmem *bottom;\n\tint top_irq_flags;\n\tint bottom_irq_flags;\n\n\ttop = NULL;\n\tbottom = NULL;\n\ttop_irq_flags = 0;\n\tbottom_irq_flags = 0;\n\n\tif (vbi) {\n\t\tunsigned int crop, vdelay;\n\n\t\tlist_del(&vbi->list);\n\n\t\t \n\t\tcrop = btread(BT848_E_CROP);\n\t\tvdelay = btread(BT848_E_VDELAY_LO) + ((crop & 0xc0) << 2);\n\n\t\tif (vbi->geo.vdelay > vdelay) {\n\t\t\tvdelay = vbi->geo.vdelay & 0xfe;\n\t\t\tcrop = (crop & 0x3f) | ((vbi->geo.vdelay >> 2) & 0xc0);\n\n\t\t\tbtwrite(vdelay, BT848_E_VDELAY_LO);\n\t\t\tbtwrite(crop,\tBT848_E_CROP);\n\t\t\tbtwrite(vdelay, BT848_O_VDELAY_LO);\n\t\t\tbtwrite(crop,\tBT848_O_CROP);\n\t\t}\n\n\t\tif (btv->vbi_count[0] > 0) {\n\t\t\ttop = &vbi->top;\n\t\t\ttop_irq_flags = 4;\n\t\t}\n\n\t\tif (btv->vbi_count[1] > 0) {\n\t\t\ttop_irq_flags = 0;\n\t\t\tbottom = &vbi->bottom;\n\t\t\tbottom_irq_flags = 4;\n\t\t}\n\t}\n\n\tbttv_risc_hook(btv, RISC_SLOT_O_VBI, top, top_irq_flags);\n\tbttv_risc_hook(btv, RISC_SLOT_E_VBI, bottom, bottom_irq_flags);\n\n\treturn 0;\n}\n\nint\nbttv_buffer_activate_video(struct bttv *btv,\n\t\t\t   struct bttv_buffer_set *set)\n{\n\t \n\tif (NULL != set->top  &&  NULL != set->bottom) {\n\t\tif (set->top == set->bottom) {\n\t\t\tif (set->top->list.next)\n\t\t\t\tlist_del(&set->top->list);\n\t\t} else {\n\t\t\tif (set->top->list.next)\n\t\t\t\tlist_del(&set->top->list);\n\t\t\tif (set->bottom->list.next)\n\t\t\t\tlist_del(&set->bottom->list);\n\t\t}\n\t\tbttv_apply_geo(btv, &set->top->geo, 1);\n\t\tbttv_apply_geo(btv, &set->bottom->geo,0);\n\t\tbttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,\n\t\t\t       set->top_irq);\n\t\tbttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,\n\t\t\t       set->frame_irq);\n\t\tbtaor((set->top->btformat & 0xf0) | (set->bottom->btformat & 0x0f),\n\t\t      ~0xff, BT848_COLOR_FMT);\n\t\tbtaor((set->top->btswap & 0x0a) | (set->bottom->btswap & 0x05),\n\t\t      ~0x0f, BT848_COLOR_CTL);\n\t} else if (NULL != set->top) {\n\t\tif (set->top->list.next)\n\t\t\tlist_del(&set->top->list);\n\t\tbttv_apply_geo(btv, &set->top->geo,1);\n\t\tbttv_apply_geo(btv, &set->top->geo,0);\n\t\tbttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,\n\t\t\t       set->frame_irq);\n\t\tbttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL,           0);\n\t\tbtaor(set->top->btformat & 0xff, ~0xff, BT848_COLOR_FMT);\n\t\tbtaor(set->top->btswap & 0x0f,   ~0x0f, BT848_COLOR_CTL);\n\t} else if (NULL != set->bottom) {\n\t\tif (set->bottom->list.next)\n\t\t\tlist_del(&set->bottom->list);\n\t\tbttv_apply_geo(btv, &set->bottom->geo,1);\n\t\tbttv_apply_geo(btv, &set->bottom->geo,0);\n\t\tbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\n\t\tbttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,\n\t\t\t       set->frame_irq);\n\t\tbtaor(set->bottom->btformat & 0xff, ~0xff, BT848_COLOR_FMT);\n\t\tbtaor(set->bottom->btswap & 0x0f,   ~0x0f, BT848_COLOR_CTL);\n\t} else {\n\t\tbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\n\t\tbttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL, 0);\n\t}\n\treturn 0;\n}\n\n \n\n \nint\nbttv_buffer_risc(struct bttv *btv, struct bttv_buffer *buf)\n{\n\tint r = 0;\n\tconst struct bttv_tvnorm *tvnorm = bttv_tvnorms + btv->tvnorm;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vbuf.vb2_buf, 0);\n\tstruct scatterlist *list = sgt->sgl;\n\tunsigned long size = (btv->fmt->depth * btv->width * btv->height) >> 3;\n\n\t \n\tif (btv->fmt->flags & FORMAT_FLAGS_PACKED) {\n\t\tint bpl = (btv->fmt->depth >> 3) * btv->width;\n\t\tint bpf = bpl * (btv->height >> 1);\n\n\t\tbttv_calc_geo(btv, &buf->geo, btv->width, btv->height,\n\t\t\t      V4L2_FIELD_HAS_BOTH(buf->vbuf.field), tvnorm,\n\t\t\t      &btv->crop[!!btv->do_crop].rect);\n\t\tswitch (buf->vbuf.field) {\n\t\tcase V4L2_FIELD_TOP:\n\t\t\tr = bttv_risc_packed(btv, &buf->top, list, 0, bpl, 0,\n\t\t\t\t\t     0, btv->height);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_BOTTOM:\n\t\t\tr = bttv_risc_packed(btv, &buf->bottom, list, 0, bpl,\n\t\t\t\t\t     0, 0, btv->height);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\t\tr = bttv_risc_packed(btv, &buf->top, list, 0, bpl,\n\t\t\t\t\t     bpl, 0, btv->height >> 1);\n\t\t\tr = bttv_risc_packed(btv, &buf->bottom, list, bpl,\n\t\t\t\t\t     bpl, bpl, 0, btv->height >> 1);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\t\tr = bttv_risc_packed(btv, &buf->top, list, 0, bpl, 0,\n\t\t\t\t\t     0, btv->height >> 1);\n\t\t\tr = bttv_risc_packed(btv, &buf->bottom, list, bpf,\n\t\t\t\t\t     bpl, 0, 0, btv->height >> 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tif (btv->fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\tint uoffset, voffset;\n\t\tint ypadding, cpadding, lines;\n\n\t\t \n\t\tuoffset = btv->width * btv->height;\n\t\tvoffset = btv->width * btv->height;\n\t\tif (btv->fmt->flags & FORMAT_FLAGS_CrCb) {\n\t\t\t \n\t\t\tuoffset >>= btv->fmt->hshift;\n\t\t\tuoffset >>= btv->fmt->vshift;\n\t\t\tuoffset  += voffset;\n\t\t} else {\n\t\t\t \n\t\t\tvoffset >>= btv->fmt->hshift;\n\t\t\tvoffset >>= btv->fmt->vshift;\n\t\t\tvoffset  += uoffset;\n\t\t}\n\t\tswitch (buf->vbuf.field) {\n\t\tcase V4L2_FIELD_TOP:\n\t\t\tbttv_calc_geo(btv, &buf->geo, btv->width, btv->height,\n\t\t\t\t      0, tvnorm,\n\t\t\t\t      &btv->crop[!!btv->do_crop].rect);\n\t\t\tr = bttv_risc_planar(btv, &buf->top, list, 0,\n\t\t\t\t\t     btv->width, 0, btv->height,\n\t\t\t\t\t     uoffset, voffset,\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, 0);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_BOTTOM:\n\t\t\tbttv_calc_geo(btv, &buf->geo, btv->width, btv->height,\n\t\t\t\t      0, tvnorm,\n\t\t\t\t      &btv->crop[!!btv->do_crop].rect);\n\t\t\tr = bttv_risc_planar(btv, &buf->bottom, list, 0,\n\t\t\t\t\t     btv->width, 0, btv->height,\n\t\t\t\t\t     uoffset, voffset,\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, 0);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\t\tbttv_calc_geo(btv, &buf->geo, btv->width, btv->height,\n\t\t\t\t      1, tvnorm,\n\t\t\t\t      &btv->crop[!!btv->do_crop].rect);\n\t\t\tlines = btv->height >> 1;\n\t\t\typadding = btv->width;\n\t\t\tcpadding = btv->width >> btv->fmt->hshift;\n\t\t\tr = bttv_risc_planar(btv, &buf->top, list, 0,\n\t\t\t\t\t     btv->width, ypadding, lines,\n\t\t\t\t\t     uoffset, voffset,\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, cpadding);\n\n\t\t\tr = bttv_risc_planar(btv, &buf->bottom, list,\n\t\t\t\t\t     ypadding, btv->width, ypadding,\n\t\t\t\t\t     lines,  uoffset + cpadding,\n\t\t\t\t\t     voffset + cpadding,\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, cpadding);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\t\tbttv_calc_geo(btv, &buf->geo, btv->width, btv->height,\n\t\t\t\t      1, tvnorm,\n\t\t\t\t      &btv->crop[!!btv->do_crop].rect);\n\t\t\tlines = btv->height >> 1;\n\t\t\typadding = btv->width;\n\t\t\tcpadding = btv->width >> btv->fmt->hshift;\n\t\t\tr = bttv_risc_planar(btv, &buf->top, list, 0,\n\t\t\t\t\t     btv->width, 0, lines,\n\t\t\t\t\t     uoffset >> 1, voffset >> 1,\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, 0);\n\t\t\tr = bttv_risc_planar(btv, &buf->bottom, list,\n\t\t\t\t\t     lines * ypadding,\n\t\t\t\t\t     btv->width, 0, lines,\n\t\t\t\t\t     lines * ypadding + (uoffset >> 1),\n\t\t\t\t\t     lines * ypadding + (voffset >> 1),\n\t\t\t\t\t     btv->fmt->hshift,\n\t\t\t\t\t     btv->fmt->vshift, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tif (btv->fmt->flags & FORMAT_FLAGS_RAW) {\n\t\t \n\t\tbuf->vbuf.field = V4L2_FIELD_SEQ_TB;\n\t\tbttv_calc_geo(btv, &buf->geo, tvnorm->swidth, tvnorm->sheight,\n\t\t\t      1, tvnorm, &btv->crop[!!btv->do_crop].rect);\n\t\tr = bttv_risc_packed(btv, &buf->top, list, 0, RAW_BPL, 0, 0,\n\t\t\t\t     RAW_LINES);\n\t\tr = bttv_risc_packed(btv, &buf->bottom, list, size / 2,\n\t\t\t\t     RAW_BPL, 0, 0, RAW_LINES);\n\t}\n\n\t \n\tbuf->btformat = btv->fmt->btformat;\n\tbuf->btswap   = btv->fmt->btswap;\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}