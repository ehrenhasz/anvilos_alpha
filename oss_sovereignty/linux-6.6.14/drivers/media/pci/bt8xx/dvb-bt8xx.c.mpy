{
  "module_name": "dvb-bt8xx.c",
  "hash_id": "c27ea099131cff52a1aa92f634648a0f4eb07355ad36233bf432e61b9fd45297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/dvb-bt8xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include \"dvb-bt8xx.h\"\n#include \"bt878.h\"\n\nstatic int debug;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\\\n\t\t       __func__, ##arg);\t\t\t\\\n} while (0)\n\n\n#define IF_FREQUENCYx6 217     \n\nstatic void dvb_bt8xx_task(struct tasklet_struct *t)\n{\n\tstruct bt878 *bt = from_tasklet(bt, t, tasklet);\n\tstruct dvb_bt8xx_card *card = dev_get_drvdata(&bt->adapter->dev);\n\n\tdprintk(\"%d\\n\", card->bt->finished_block);\n\n\twhile (card->bt->last_block != card->bt->finished_block) {\n\t\t(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)\n\t\t\t(&card->demux,\n\t\t\t &card->bt->buf_cpu[card->bt->last_block *\n\t\t\t\t\t    card->bt->block_bytes],\n\t\t\t card->bt->block_bytes);\n\t\tcard->bt->last_block = (card->bt->last_block + 1) %\n\t\t\t\t\tcard->bt->block_count;\n\t}\n}\n\nstatic int dvb_bt8xx_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux*dvbdmx = dvbdmxfeed->demux;\n\tstruct dvb_bt8xx_card *card = dvbdmx->priv;\n\tint rc;\n\n\tdprintk(\"dvb_bt8xx: start_feed\\n\");\n\n\tif (!dvbdmx->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->lock);\n\tcard->nfeeds++;\n\trc = card->nfeeds;\n\tif (card->nfeeds == 1)\n\t\tbt878_start(card->bt, card->gpio_mode,\n\t\t\t    card->op_sync_orin, card->irq_err_ignore);\n\tmutex_unlock(&card->lock);\n\treturn rc;\n}\n\nstatic int dvb_bt8xx_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct dvb_bt8xx_card *card = dvbdmx->priv;\n\n\tdprintk(\"dvb_bt8xx: stop_feed\\n\");\n\n\tif (!dvbdmx->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->lock);\n\tcard->nfeeds--;\n\tif (card->nfeeds == 0)\n\t\tbt878_stop(card->bt);\n\tmutex_unlock(&card->lock);\n\n\treturn 0;\n}\n\nstatic int is_pci_slot_eq(struct pci_dev* adev, struct pci_dev* bdev)\n{\n\tif ((adev->subsystem_vendor == bdev->subsystem_vendor) &&\n\t\t(adev->subsystem_device == bdev->subsystem_device) &&\n\t\t(adev->bus->number == bdev->bus->number) &&\n\t\t(PCI_SLOT(adev->devfn) == PCI_SLOT(bdev->devfn)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct bt878 *dvb_bt8xx_878_match(unsigned int bttv_nr,\n\t\t\t\t\t struct pci_dev* bttv_pci_dev)\n{\n\tunsigned int card_nr;\n\n\t \n\tfor (card_nr = 0; card_nr < bt878_num; card_nr++)\n\t\tif (is_pci_slot_eq(bt878[card_nr].dev, bttv_pci_dev))\n\t\t\treturn &bt878[card_nr];\n\treturn NULL;\n}\n\nstatic int thomson_dtt7579_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x38 };\n\tstatic u8 mt352_reset [] = { 0x50, 0x80 };\n\tstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\n\tstatic u8 mt352_agc_cfg [] = { 0x67, 0x28, 0x20 };\n\tstatic u8 mt352_gpp_ctl_cfg [] = { 0x8C, 0x33 };\n\tstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\n\n\tmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\n\tudelay(2000);\n\tmt352_write(fe, mt352_reset, sizeof(mt352_reset));\n\tmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\n\n\tmt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));\n\tmt352_write(fe, mt352_gpp_ctl_cfg, sizeof(mt352_gpp_ctl_cfg));\n\tmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\n\n\treturn 0;\n}\n\nstatic int thomson_dtt7579_tuner_calc_regs(struct dvb_frontend *fe, u8* pllbuf, int buf_len)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 div;\n\tunsigned char bs = 0;\n\tunsigned char cp = 0;\n\n\tif (buf_len < 5)\n\t\treturn -EINVAL;\n\n\tdiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\n\n\tif (c->frequency < 542000000)\n\t\tcp = 0xb4;\n\telse if (c->frequency < 771000000)\n\t\tcp = 0xbc;\n\telse\n\t\tcp = 0xf4;\n\n\tif (c->frequency == 0)\n\t\tbs = 0x03;\n\telse if (c->frequency < 443250000)\n\t\tbs = 0x02;\n\telse\n\t\tbs = 0x08;\n\n\tpllbuf[0] = 0x60;\n\tpllbuf[1] = div >> 8;\n\tpllbuf[2] = div & 0xff;\n\tpllbuf[3] = cp;\n\tpllbuf[4] = bs;\n\n\treturn 5;\n}\n\nstatic struct mt352_config thomson_dtt7579_config = {\n\t.demod_address = 0x0f,\n\t.demod_init = thomson_dtt7579_demod_init,\n};\n\nstatic struct zl10353_config thomson_dtt7579_zl10353_config = {\n\t.demod_address = 0x0f,\n};\n\nstatic int cx24108_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 freq = c->frequency;\n\tint i, a, n, pump;\n\tu32 band, pll;\n\tu32 osci[]={950000,1019000,1075000,1178000,1296000,1432000,\n\t\t1576000,1718000,1856000,2036000,2150000};\n\tu32 bandsel[]={0,0x00020000,0x00040000,0x00100800,0x00101000,\n\t\t0x00102000,0x00104000,0x00108000,0x00110000,\n\t\t0x00120000,0x00140000};\n\n\t#define XTAL 1011100  \n\tdprintk(\"cx24108 debug: entering SetTunerFreq, freq=%d\\n\", freq);\n\n\t \n\n\tif (freq<950000)\n\t\tfreq = 950000;  \n\telse if (freq>2150000)\n\t\tfreq = 2150000;  \n\n\t \n\tfor(i = 1; (i < ARRAY_SIZE(osci) - 1) && (osci[i] < freq); i++);\n\tdprintk(\"cx24108 debug: select vco #%d (f=%d)\\n\", i, freq);\n\tband=bandsel[i];\n\t \n\t \n\tn=((i<=2?2:1)*freq*10L)/(XTAL/100);\n\ta=n%32; n/=32; if(a==0) n--;\n\tpump=(freq<(osci[i-1]+osci[i])/2);\n\tpll=0xf8000000|\n\t    ((pump?1:2)<<(14+11))|\n\t    ((n&0x1ff)<<(5+11))|\n\t    ((a&0x1f)<<11);\n\t \n\tdprintk(\"cx24108 debug: pump=%d, n=%d, a=%d\\n\", pump, n, a);\n\tcx24110_pll_write(fe,band);\n\t \n\tcx24110_pll_write(fe,0x500c0000);\n\tcx24110_pll_write(fe,0x83f1f800);\n\tcx24110_pll_write(fe,pll);\n\t\n\n\treturn 0;\n}\n\nstatic int pinnsat_tuner_init(struct dvb_frontend* fe)\n{\n\tstruct dvb_bt8xx_card *card = fe->dvb->priv;\n\n\tbttv_gpio_enable(card->bttv_nr, 1, 1);   \n\tbttv_write_gpio(card->bttv_nr, 1, 1);    \n\n\treturn 0;\n}\n\nstatic int pinnsat_tuner_sleep(struct dvb_frontend* fe)\n{\n\tstruct dvb_bt8xx_card *card = fe->dvb->priv;\n\n\tbttv_write_gpio(card->bttv_nr, 1, 0);    \n\n\treturn 0;\n}\n\nstatic struct cx24110_config pctvsat_config = {\n\t.demod_address = 0x55,\n};\n\nstatic int microtune_mt7202dtf_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *) fe->dvb->priv;\n\tu8 cfg, cpump, band_select;\n\tu8 data[4];\n\tu32 div;\n\tstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (36000000 + c->frequency + 83333) / 166666;\n\tcfg = 0x88;\n\n\tif (c->frequency < 175000000)\n\t\tcpump = 2;\n\telse if (c->frequency < 390000000)\n\t\tcpump = 1;\n\telse if (c->frequency < 470000000)\n\t\tcpump = 2;\n\telse if (c->frequency < 750000000)\n\t\tcpump = 2;\n\telse\n\t\tcpump = 3;\n\n\tif (c->frequency < 175000000)\n\t\tband_select = 0x0e;\n\telse if (c->frequency < 470000000)\n\t\tband_select = 0x05;\n\telse\n\t\tband_select = 0x03;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = ((div >> 10) & 0x60) | cfg;\n\tdata[3] = (cpump << 6) | band_select;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\ti2c_transfer(card->i2c_adapter, &msg, 1);\n\treturn (div * 166666 - 36000000);\n}\n\nstatic int microtune_mt7202dtf_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\n{\n\tstruct dvb_bt8xx_card* bt = (struct dvb_bt8xx_card*) fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &bt->bt->dev->dev);\n}\n\nstatic const struct sp887x_config microtune_mt7202dtf_config = {\n\t.demod_address = 0x70,\n\t.request_firmware = microtune_mt7202dtf_request_firmware,\n};\n\nstatic int advbt771_samsung_tdtc9251dh0_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x2d };\n\tstatic u8 mt352_reset [] = { 0x50, 0x80 };\n\tstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\n\tstatic u8 mt352_agc_cfg [] = { 0x67, 0x10, 0x23, 0x00, 0xFF, 0xFF,\n\t\t\t\t       0x00, 0xFF, 0x00, 0x40, 0x40 };\n\tstatic u8 mt352_av771_extra[] = { 0xB5, 0x7A };\n\tstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\n\n\tmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\n\tudelay(2000);\n\tmt352_write(fe, mt352_reset, sizeof(mt352_reset));\n\tmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\n\n\tmt352_write(fe, mt352_agc_cfg,sizeof(mt352_agc_cfg));\n\tudelay(2000);\n\tmt352_write(fe, mt352_av771_extra,sizeof(mt352_av771_extra));\n\tmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\n\n\treturn 0;\n}\n\nstatic int advbt771_samsung_tdtc9251dh0_tuner_calc_regs(struct dvb_frontend *fe, u8 *pllbuf, int buf_len)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 div;\n\tunsigned char bs = 0;\n\tunsigned char cp = 0;\n\n\tif (buf_len < 5) return -EINVAL;\n\n\tdiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\n\n\tif (c->frequency < 150000000)\n\t\tcp = 0xB4;\n\telse if (c->frequency < 173000000)\n\t\tcp = 0xBC;\n\telse if (c->frequency < 250000000)\n\t\tcp = 0xB4;\n\telse if (c->frequency < 400000000)\n\t\tcp = 0xBC;\n\telse if (c->frequency < 420000000)\n\t\tcp = 0xF4;\n\telse if (c->frequency < 470000000)\n\t\tcp = 0xFC;\n\telse if (c->frequency < 600000000)\n\t\tcp = 0xBC;\n\telse if (c->frequency < 730000000)\n\t\tcp = 0xF4;\n\telse\n\t\tcp = 0xFC;\n\n\tif (c->frequency < 150000000)\n\t\tbs = 0x01;\n\telse if (c->frequency < 173000000)\n\t\tbs = 0x01;\n\telse if (c->frequency < 250000000)\n\t\tbs = 0x02;\n\telse if (c->frequency < 400000000)\n\t\tbs = 0x02;\n\telse if (c->frequency < 420000000)\n\t\tbs = 0x02;\n\telse if (c->frequency < 470000000)\n\t\tbs = 0x02;\n\telse\n\t\tbs = 0x08;\n\n\tpllbuf[0] = 0x61;\n\tpllbuf[1] = div >> 8;\n\tpllbuf[2] = div & 0xff;\n\tpllbuf[3] = cp;\n\tpllbuf[4] = bs;\n\n\treturn 5;\n}\n\nstatic struct mt352_config advbt771_samsung_tdtc9251dh0_config = {\n\t.demod_address = 0x0f,\n\t.demod_init = advbt771_samsung_tdtc9251dh0_demod_init,\n};\n\nstatic const struct dst_config dst_config = {\n\t.demod_address = 0x55,\n};\n\nstatic int or51211_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\n{\n\tstruct dvb_bt8xx_card* bt = (struct dvb_bt8xx_card*) fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &bt->bt->dev->dev);\n}\n\nstatic void or51211_setmode(struct dvb_frontend * fe, int mode)\n{\n\tstruct dvb_bt8xx_card *bt = fe->dvb->priv;\n\tbttv_write_gpio(bt->bttv_nr, 0x0002, mode);    \n\tmsleep(20);\n}\n\nstatic void or51211_reset(struct dvb_frontend * fe)\n{\n\tstruct dvb_bt8xx_card *bt = fe->dvb->priv;\n\n\t \n\t \n\tint ret = bttv_gpio_enable(bt->bttv_nr, 0x001F, 0x001F);\n\tif (ret != 0)\n\t\tpr_warn(\"or51211: Init Error - Can't Reset DVR (%i)\\n\", ret);\n\tbttv_write_gpio(bt->bttv_nr, 0x001F, 0x0000);    \n\tmsleep(20);\n\t \n\tbttv_write_gpio(bt->bttv_nr, 0x0001F, 0x0001);\n\t \n\tmsleep(500);\n}\n\nstatic void or51211_sleep(struct dvb_frontend * fe)\n{\n\tstruct dvb_bt8xx_card *bt = fe->dvb->priv;\n\tbttv_write_gpio(bt->bttv_nr, 0x0001, 0x0000);\n}\n\nstatic const struct or51211_config or51211_config = {\n\t.demod_address = 0x15,\n\t.request_firmware = or51211_request_firmware,\n\t.setmode = or51211_setmode,\n\t.reset = or51211_reset,\n\t.sleep = or51211_sleep,\n};\n\nstatic int vp3021_alps_tded4_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *) fe->dvb->priv;\n\tu8 buf[4];\n\tu32 div;\n\tstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = buf, .len = sizeof(buf) };\n\n\tdiv = (c->frequency + 36166667) / 166667;\n\n\tbuf[0] = (div >> 8) & 0x7F;\n\tbuf[1] = div & 0xFF;\n\tbuf[2] = 0x85;\n\tif ((c->frequency >= 47000000) && (c->frequency < 153000000))\n\t\tbuf[3] = 0x01;\n\telse if ((c->frequency >= 153000000) && (c->frequency < 430000000))\n\t\tbuf[3] = 0x02;\n\telse if ((c->frequency >= 430000000) && (c->frequency < 824000000))\n\t\tbuf[3] = 0x0C;\n\telse if ((c->frequency >= 824000000) && (c->frequency < 863000000))\n\t\tbuf[3] = 0x8C;\n\telse\n\t\treturn -EINVAL;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\ti2c_transfer(card->i2c_adapter, &msg, 1);\n\treturn 0;\n}\n\nstatic struct nxt6000_config vp3021_alps_tded4_config = {\n\t.demod_address = 0x0a,\n\t.clock_inversion = 1,\n};\n\nstatic int digitv_alps_tded4_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 mt352_clock_config [] = { 0x89, 0x38, 0x2d };\n\tstatic u8 mt352_reset [] = { 0x50, 0x80 };\n\tstatic u8 mt352_adc_ctl_1_cfg [] = { 0x8E, 0x40 };\n\tstatic u8 mt352_agc_cfg [] = { 0x67, 0x20, 0xa0 };\n\tstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\n\n\tmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\n\tudelay(2000);\n\tmt352_write(fe, mt352_reset, sizeof(mt352_reset));\n\tmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\n\tmt352_write(fe, mt352_agc_cfg,sizeof(mt352_agc_cfg));\n\tmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\n\n\treturn 0;\n}\n\nstatic int digitv_alps_tded4_tuner_calc_regs(struct dvb_frontend *fe,  u8 *pllbuf, int buf_len)\n{\n\tu32 div;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (buf_len < 5)\n\t\treturn -EINVAL;\n\n\tdiv = (((c->frequency + 83333) * 3) / 500000) + IF_FREQUENCYx6;\n\n\tpllbuf[0] = 0x61;\n\tpllbuf[1] = (div >> 8) & 0x7F;\n\tpllbuf[2] = div & 0xFF;\n\tpllbuf[3] = 0x85;\n\n\tdprintk(\"frequency %u, div %u\\n\", c->frequency, div);\n\n\tif (c->frequency < 470000000)\n\t\tpllbuf[4] = 0x02;\n\telse if (c->frequency > 823000000)\n\t\tpllbuf[4] = 0x88;\n\telse\n\t\tpllbuf[4] = 0x08;\n\n\tif (c->bandwidth_hz == 8000000)\n\t\tpllbuf[4] |= 0x04;\n\n\treturn 5;\n}\n\nstatic void digitv_alps_tded4_reset(struct dvb_bt8xx_card *bt)\n{\n\t \n\n\tint ret = bttv_gpio_enable(bt->bttv_nr, 0x08, 0x08);\n\tif (ret != 0)\n\t\tpr_warn(\"digitv_alps_tded4: Init Error - Can't Reset DVR (%i)\\n\",\n\t\t\tret);\n\n\t \n\tbttv_write_gpio(bt->bttv_nr, 0x08, 0x08);  \n\tbttv_write_gpio(bt->bttv_nr, 0x08, 0x00);  \n\tmsleep(100);\n\n\tbttv_write_gpio(bt->bttv_nr, 0x08, 0x08);  \n}\n\nstatic struct mt352_config digitv_alps_tded4_config = {\n\t.demod_address = 0x0a,\n\t.demod_init = digitv_alps_tded4_demod_init,\n};\n\nstatic struct lgdt330x_config tdvs_tua6034_config = {\n\t.demod_chip       = LGDT3303,\n\t.serial_mpeg      = 0x40,  \n};\n\nstatic void lgdt330x_reset(struct dvb_bt8xx_card *bt)\n{\n\t \n\n\t \n\tbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000001);  \n\tbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000000);  \n\tmsleep(100);\n\n\tbttv_write_gpio(bt->bttv_nr, 0x00e00007, 0x00000001);  \n\tmsleep(100);\n}\n\nstatic void frontend_init(struct dvb_bt8xx_card *card, u32 type)\n{\n\tstruct dst_state* state = NULL;\n\n\tswitch(type) {\n\tcase BTTV_BOARD_DVICO_DVBT_LITE:\n\t\tcard->fe = dvb_attach(mt352_attach, &thomson_dtt7579_config, card->i2c_adapter);\n\n\t\tif (card->fe == NULL)\n\t\t\tcard->fe = dvb_attach(zl10353_attach, &thomson_dtt7579_zl10353_config,\n\t\t\t\t\t\t  card->i2c_adapter);\n\n\t\tif (card->fe != NULL) {\n\t\t\tcard->fe->ops.tuner_ops.calc_regs = thomson_dtt7579_tuner_calc_regs;\n\t\t\tcard->fe->ops.info.frequency_min_hz = 174 * MHz;\n\t\t\tcard->fe->ops.info.frequency_max_hz = 862 * MHz;\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_DVICO_FUSIONHDTV_5_LITE:\n\t\tlgdt330x_reset(card);\n\t\tcard->fe = dvb_attach(lgdt330x_attach, &tdvs_tua6034_config,\n\t\t\t\t      0x0e, card->i2c_adapter);\n\t\tif (card->fe != NULL) {\n\t\t\tdvb_attach(simple_tuner_attach, card->fe,\n\t\t\t\t   card->i2c_adapter, 0x61,\n\t\t\t\t   TUNER_LG_TDVS_H06XF);\n\t\t\tdprintk(\"dvb_bt8xx: lgdt330x detected\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_NEBULA_DIGITV:\n\t\t \n\n\t\t \n\t\tdigitv_alps_tded4_reset(card);\n\t\tcard->fe = dvb_attach(nxt6000_attach, &vp3021_alps_tded4_config, card->i2c_adapter);\n\t\tif (card->fe != NULL) {\n\t\t\tcard->fe->ops.tuner_ops.set_params = vp3021_alps_tded4_tuner_set_params;\n\t\t\tdprintk(\"dvb_bt8xx: an nxt6000 was detected on your digitv card\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdigitv_alps_tded4_reset(card);\n\t\tcard->fe = dvb_attach(mt352_attach, &digitv_alps_tded4_config, card->i2c_adapter);\n\n\t\tif (card->fe != NULL) {\n\t\t\tcard->fe->ops.tuner_ops.calc_regs = digitv_alps_tded4_tuner_calc_regs;\n\t\t\tdprintk(\"dvb_bt8xx: an mt352 was detected on your digitv card\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_AVDVBT_761:\n\t\tcard->fe = dvb_attach(sp887x_attach, &microtune_mt7202dtf_config, card->i2c_adapter);\n\t\tif (card->fe) {\n\t\t\tcard->fe->ops.tuner_ops.set_params = microtune_mt7202dtf_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_AVDVBT_771:\n\t\tcard->fe = dvb_attach(mt352_attach, &advbt771_samsung_tdtc9251dh0_config, card->i2c_adapter);\n\t\tif (card->fe != NULL) {\n\t\t\tcard->fe->ops.tuner_ops.calc_regs = advbt771_samsung_tdtc9251dh0_tuner_calc_regs;\n\t\t\tcard->fe->ops.info.frequency_min_hz = 174 * MHz;\n\t\t\tcard->fe->ops.info.frequency_max_hz = 862 * MHz;\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_TWINHAN_DST:\n\t\t \n\t\tstate = kmalloc(sizeof (struct dst_state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\tpr_err(\"No memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tstate->config = &dst_config;\n\t\tstate->i2c = card->i2c_adapter;\n\t\tstate->bt = card->bt;\n\t\tstate->dst_ca = NULL;\n\t\t \n\t\tif (dvb_attach(dst_attach, state, &card->dvb_adapter) == NULL) {\n\t\t\tpr_err(\"%s: Could not find a Twinhan DST\\n\", __func__);\n\t\t\tkfree(state);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\t \n\t\tcard->fe = &state->frontend;\n\t\tif (state->dst_hw_cap & DST_TYPE_HAS_CA)\n\t\t\tdvb_attach(dst_ca_attach, state, &card->dvb_adapter);\n\t\tbreak;\n\n\tcase BTTV_BOARD_PINNACLESAT:\n\t\tcard->fe = dvb_attach(cx24110_attach, &pctvsat_config, card->i2c_adapter);\n\t\tif (card->fe) {\n\t\t\tcard->fe->ops.tuner_ops.init = pinnsat_tuner_init;\n\t\t\tcard->fe->ops.tuner_ops.sleep = pinnsat_tuner_sleep;\n\t\t\tcard->fe->ops.tuner_ops.set_params = cx24108_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase BTTV_BOARD_PC_HDTV:\n\t\tcard->fe = dvb_attach(or51211_attach, &or51211_config, card->i2c_adapter);\n\t\tif (card->fe != NULL)\n\t\t\tdvb_attach(simple_tuner_attach, card->fe,\n\t\t\t\t   card->i2c_adapter, 0x61,\n\t\t\t\t   TUNER_PHILIPS_FCV1236D);\n\t\tbreak;\n\t}\n\n\tif (card->fe == NULL)\n\t\tpr_err(\"A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\\n\",\n\t\t       card->bt->dev->vendor,\n\t\t       card->bt->dev->device,\n\t\t       card->bt->dev->subsystem_vendor,\n\t\t       card->bt->dev->subsystem_device);\n\telse\n\t\tif (dvb_register_frontend(&card->dvb_adapter, card->fe)) {\n\t\t\tpr_err(\"Frontend registration failed!\\n\");\n\t\t\tdvb_frontend_detach(card->fe);\n\t\t\tcard->fe = NULL;\n\t\t}\n}\n\nstatic int dvb_bt8xx_load_card(struct dvb_bt8xx_card *card, u32 type)\n{\n\tint result;\n\n\tresult = dvb_register_adapter(&card->dvb_adapter, card->card_name,\n\t\t\t\t      THIS_MODULE, &card->bt->dev->dev,\n\t\t\t\t      adapter_nr);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_register_adapter failed (errno = %d)\\n\", result);\n\t\treturn result;\n\t}\n\tcard->dvb_adapter.priv = card;\n\n\tcard->bt->adapter = card->i2c_adapter;\n\n\tmemset(&card->demux, 0, sizeof(struct dvb_demux));\n\n\tcard->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING;\n\n\tcard->demux.priv = card;\n\tcard->demux.filternum = 256;\n\tcard->demux.feednum = 256;\n\tcard->demux.start_feed = dvb_bt8xx_start_feed;\n\tcard->demux.stop_feed = dvb_bt8xx_stop_feed;\n\tcard->demux.write_to_decoder = NULL;\n\n\tresult = dvb_dmx_init(&card->demux);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tgoto err_unregister_adaptor;\n\t}\n\n\tcard->dmxdev.filternum = 256;\n\tcard->dmxdev.demux = &card->demux.dmx;\n\tcard->dmxdev.capabilities = 0;\n\n\tresult = dvb_dmxdev_init(&card->dmxdev, &card->dvb_adapter);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmxdev_init failed (errno = %d)\\n\", result);\n\t\tgoto err_dmx_release;\n\t}\n\n\tcard->fe_hw.source = DMX_FRONTEND_0;\n\n\tresult = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_hw);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tgoto err_dmxdev_release;\n\t}\n\n\tcard->fe_mem.source = DMX_MEMORY_FE;\n\n\tresult = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_mem);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tgoto err_remove_hw_frontend;\n\t}\n\n\tresult = card->demux.dmx.connect_frontend(&card->demux.dmx, &card->fe_hw);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tgoto err_remove_mem_frontend;\n\t}\n\n\tresult = dvb_net_init(&card->dvb_adapter, &card->dvbnet, &card->demux.dmx);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_net_init failed (errno = %d)\\n\", result);\n\t\tgoto err_disconnect_frontend;\n\t}\n\n\ttasklet_setup(&card->bt->tasklet, dvb_bt8xx_task);\n\n\tfrontend_init(card, type);\n\n\treturn 0;\n\nerr_disconnect_frontend:\n\tcard->demux.dmx.disconnect_frontend(&card->demux.dmx);\nerr_remove_mem_frontend:\n\tcard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);\nerr_remove_hw_frontend:\n\tcard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);\nerr_dmxdev_release:\n\tdvb_dmxdev_release(&card->dmxdev);\nerr_dmx_release:\n\tdvb_dmx_release(&card->demux);\nerr_unregister_adaptor:\n\tdvb_unregister_adapter(&card->dvb_adapter);\n\treturn result;\n}\n\nstatic int dvb_bt8xx_probe(struct bttv_sub_device *sub)\n{\n\tstruct dvb_bt8xx_card *card;\n\tstruct pci_dev* bttv_pci_dev;\n\tint ret;\n\n\tif (!(card = kzalloc(sizeof(struct dvb_bt8xx_card), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tmutex_init(&card->lock);\n\tcard->bttv_nr = sub->core->nr;\n\tstrscpy(card->card_name, sub->core->v4l2_dev.name,\n\t\tsizeof(card->card_name));\n\tcard->i2c_adapter = &sub->core->i2c_adap;\n\n\tswitch(sub->core->type) {\n\tcase BTTV_BOARD_PINNACLESAT:\n\t\tcard->gpio_mode = 0x0400c060;\n\t\t \n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\tbreak;\n\n\tcase BTTV_BOARD_DVICO_DVBT_LITE:\n\t\tcard->gpio_mode = 0x0400C060;\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\t \n\t\tbreak;\n\n\tcase BTTV_BOARD_DVICO_FUSIONHDTV_5_LITE:\n\t\tcard->gpio_mode = 0x0400c060;\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\tbreak;\n\n\tcase BTTV_BOARD_NEBULA_DIGITV:\n\tcase BTTV_BOARD_AVDVBT_761:\n\t\tcard->gpio_mode = (1 << 26) | (1 << 14) | (1 << 5);\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\t \n\t\tbreak;\n\n\tcase BTTV_BOARD_AVDVBT_771: \n\t\tcard->gpio_mode = 0x0400402B;\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\t \n\t\tbreak;\n\n\tcase BTTV_BOARD_TWINHAN_DST:\n\t\tcard->gpio_mode = 0x2204f2c;\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_APABORT | BT878_ARIPERR |\n\t\t\t\t       BT878_APPERR | BT878_AFBUS;\n\t\t \n\t\tbreak;\n\n\tcase BTTV_BOARD_PC_HDTV:\n\t\tcard->gpio_mode = 0x0100EC7B;\n\t\tcard->op_sync_orin = BT878_RISC_SYNC_MASK;\n\t\tcard->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unknown bttv card type: %d\\n\", sub->core->type);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\n\tdprintk(\"dvb_bt8xx: identified card%d as %s\\n\", card->bttv_nr, card->card_name);\n\n\tif (!(bttv_pci_dev = bttv_get_pcidev(card->bttv_nr))) {\n\t\tpr_err(\"no pci device for card %d\\n\", card->bttv_nr);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {\n\t\tpr_err(\"unable to determine DMA core of card %d,\\n\", card->bttv_nr);\n\t\tpr_err(\"if you have the ALSA bt87x audio driver installed, try removing it.\\n\");\n\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&card->bt->gpio_lock);\n\tcard->bt->bttv_nr = sub->core->nr;\n\n\tif ( (ret = dvb_bt8xx_load_card(card, sub->core->type)) ) {\n\t\tkfree(card);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&sub->dev, card);\n\treturn 0;\n}\n\nstatic void dvb_bt8xx_remove(struct bttv_sub_device *sub)\n{\n\tstruct dvb_bt8xx_card *card = dev_get_drvdata(&sub->dev);\n\n\tdprintk(\"dvb_bt8xx: unloading card%d\\n\", card->bttv_nr);\n\n\tbt878_stop(card->bt);\n\ttasklet_kill(&card->bt->tasklet);\n\tdvb_net_release(&card->dvbnet);\n\tcard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);\n\tcard->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);\n\tdvb_dmxdev_release(&card->dmxdev);\n\tdvb_dmx_release(&card->demux);\n\tif (card->fe) {\n\t\tdvb_unregister_frontend(card->fe);\n\t\tdvb_frontend_detach(card->fe);\n\t}\n\tdvb_unregister_adapter(&card->dvb_adapter);\n\n\tkfree(card);\n}\n\nstatic struct bttv_sub_driver driver = {\n\t.drv = {\n\t\t.name\t\t= \"dvb-bt8xx\",\n\t},\n\t.probe\t\t= dvb_bt8xx_probe,\n\t.remove\t\t= dvb_bt8xx_remove,\n\t \n};\n\nstatic int __init dvb_bt8xx_init(void)\n{\n\treturn bttv_sub_register(&driver, \"dvb\");\n}\n\nstatic void __exit dvb_bt8xx_exit(void)\n{\n\tbttv_sub_unregister(&driver);\n}\n\nmodule_init(dvb_bt8xx_init);\nmodule_exit(dvb_bt8xx_exit);\n\nMODULE_DESCRIPTION(\"Bt8xx based DVB adapter driver\");\nMODULE_AUTHOR(\"Florian Schirmer <jolt@tuxbox.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}