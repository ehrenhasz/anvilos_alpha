{
  "module_name": "bttv-input.c",
  "hash_id": "08ecd55d70e0e0f29bc546341335feb161337006a76faee103c53543c90250f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-input.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n\n#include \"bttv.h\"\n#include \"bttvp.h\"\n\n\nstatic int ir_debug;\nmodule_param(ir_debug, int, 0644);\n\nstatic int ir_rc5_remote_gap = 885;\nmodule_param(ir_rc5_remote_gap, int, 0644);\n\n#undef dprintk\n#define dprintk(fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (ir_debug >= 1)\t\t\t\\\n\t\tpr_info(fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define DEVNAME \"bttv-input\"\n\n#define MODULE_NAME \"bttv\"\n\n \n\nstatic void ir_handle_key(struct bttv *btv)\n{\n\tstruct bttv_ir *ir = btv->remote;\n\tu32 gpio,data;\n\n\t \n\tgpio = bttv_gpio_read(&btv->c);\n\tif (ir->polling) {\n\t\tif (ir->last_gpio == gpio)\n\t\t\treturn;\n\t\tir->last_gpio = gpio;\n\t}\n\n\t \n\tdata = ir_extract_bits(gpio, ir->mask_keycode);\n\tdprintk(\"irq gpio=0x%x code=%d | %s%s%s\\n\",\n\t\tgpio, data,\n\t\tir->polling               ? \"poll\"  : \"irq\",\n\t\t(gpio & ir->mask_keydown) ? \" down\" : \"\",\n\t\t(gpio & ir->mask_keyup)   ? \" up\"   : \"\");\n\n\tif ((ir->mask_keydown && (gpio & ir->mask_keydown)) ||\n\t    (ir->mask_keyup   && !(gpio & ir->mask_keyup))) {\n\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data, 0);\n\t} else {\n\t\t \n\t\tif (btv->c.type == BTTV_BOARD_WINFAST2000)\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\n\t\trc_keyup(ir->dev);\n\t}\n}\n\nstatic void ir_enltv_handle_key(struct bttv *btv)\n{\n\tstruct bttv_ir *ir = btv->remote;\n\tu32 gpio, data, keyup;\n\n\t \n\tgpio = bttv_gpio_read(&btv->c);\n\n\t \n\tdata = ir_extract_bits(gpio, ir->mask_keycode);\n\n\t \n\tkeyup = (gpio & ir->mask_keyup) ? 1UL << 31 : 0;\n\n\tif ((ir->last_gpio & 0x7f) != data) {\n\t\tdprintk(\"gpio=0x%x code=%d | %s\\n\",\n\t\t\tgpio, data,\n\t\t\t(gpio & ir->mask_keyup) ? \" up\" : \"up/down\");\n\n\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data, 0);\n\t\tif (keyup)\n\t\t\trc_keyup(ir->dev);\n\t} else {\n\t\tif ((ir->last_gpio & 1UL << 31) == keyup)\n\t\t\treturn;\n\n\t\tdprintk(\"(cnt) gpio=0x%x code=%d | %s\\n\",\n\t\t\tgpio, data,\n\t\t\t(gpio & ir->mask_keyup) ? \" up\" : \"down\");\n\n\t\tif (keyup)\n\t\t\trc_keyup(ir->dev);\n\t\telse\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t}\n\n\tir->last_gpio = data | keyup;\n}\n\nstatic int bttv_rc5_irq(struct bttv *btv);\n\nvoid bttv_input_irq(struct bttv *btv)\n{\n\tstruct bttv_ir *ir = btv->remote;\n\n\tif (ir->rc5_gpio)\n\t\tbttv_rc5_irq(btv);\n\telse if (!ir->polling)\n\t\tir_handle_key(btv);\n}\n\nstatic void bttv_input_timer(struct timer_list *t)\n{\n\tstruct bttv_ir *ir = from_timer(ir, t, timer);\n\tstruct bttv *btv = ir->btv;\n\n\tif (btv->c.type == BTTV_BOARD_ENLTV_FM_2)\n\t\tir_enltv_handle_key(btv);\n\telse\n\t\tir_handle_key(btv);\n\tmod_timer(&ir->timer, jiffies + msecs_to_jiffies(ir->polling));\n}\n\n \n\n#define RC5_START(x)\t(((x) >> 12) & 0x03)\n#define RC5_TOGGLE(x)\t(((x) >> 11) & 0x01)\n#define RC5_ADDR(x)\t(((x) >> 6)  & 0x1f)\n#define RC5_INSTR(x)\t(((x) >> 0)  & 0x3f)\n\n \nstatic u32 bttv_rc5_decode(unsigned int code)\n{\n\tunsigned int org_code = code;\n\tunsigned int pair;\n\tunsigned int rc5 = 0;\n\tint i;\n\n\tfor (i = 0; i < 14; ++i) {\n\t\tpair = code & 0x3;\n\t\tcode >>= 2;\n\n\t\trc5 <<= 1;\n\t\tswitch (pair) {\n\t\tcase 0:\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc5 |= 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdprintk(\"rc5_decode(%x) bad code\\n\",\n\t\t\t\torg_code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdprintk(\"code=%x, rc5=%x, start=%x, toggle=%x, address=%x, instr=%x\\n\",\n\t\trc5, org_code, RC5_START(rc5),\n\t\tRC5_TOGGLE(rc5), RC5_ADDR(rc5), RC5_INSTR(rc5));\n\treturn rc5;\n}\n\nstatic void bttv_rc5_timer_end(struct timer_list *t)\n{\n\tstruct bttv_ir *ir = from_timer(ir, t, timer);\n\tktime_t tv;\n\tu32 gap, rc5, scancode;\n\tu8 toggle, command, system;\n\n\t \n\ttv = ktime_get();\n\n\tgap = ktime_to_us(ktime_sub(tv, ir->base_time));\n\t \n\tif (gap > USEC_PER_SEC) {\n\t\tgap = 200000;\n\t}\n\t \n\tir->active = false;\n\n\t \n\tif (gap < 28000) {\n\t\tdprintk(\"spurious timer_end\\n\");\n\t\treturn;\n\t}\n\n\tif (ir->last_bit < 20) {\n\t\t \n\t\tdprintk(\"short code: %x\\n\", ir->code);\n\t\treturn;\n\t}\n\n\tir->code = (ir->code << ir->shift_by) | 1;\n\trc5 = bttv_rc5_decode(ir->code);\n\n\ttoggle = RC5_TOGGLE(rc5);\n\tsystem = RC5_ADDR(rc5);\n\tcommand = RC5_INSTR(rc5);\n\n\tswitch (RC5_START(rc5)) {\n\tcase 0x3:\n\t\tbreak;\n\tcase 0x2:\n\t\tcommand += 0x40;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tscancode = RC_SCANCODE_RC5(system, command);\n\trc_keydown(ir->dev, RC_PROTO_RC5, scancode, toggle);\n\tdprintk(\"scancode %x, toggle %x\\n\", scancode, toggle);\n}\n\nstatic int bttv_rc5_irq(struct bttv *btv)\n{\n\tstruct bttv_ir *ir = btv->remote;\n\tktime_t tv;\n\tu32 gpio;\n\tu32 gap;\n\tunsigned long current_jiffies;\n\n\t \n\tgpio = bttv_gpio_read(&btv->c);\n\n\t \n\tcurrent_jiffies = jiffies;\n\ttv = ktime_get();\n\n\tgap = ktime_to_us(ktime_sub(tv, ir->base_time));\n\t \n\tif (gap > USEC_PER_SEC) {\n\t\tgap = 200000;\n\t}\n\n\tdprintk(\"RC5 IRQ: gap %d us for %s\\n\",\n\t\tgap, (gpio & 0x20) ? \"mark\" : \"space\");\n\n\t \n\tif (!(gpio & 0x20))\n\t\treturn 0;\n\n\t \n\tif (ir->active) {\n\t\t \n\t\tif (ir->last_bit < 28) {\n\t\t\tir->last_bit = (gap - ir_rc5_remote_gap / 2) /\n\t\t\t    ir_rc5_remote_gap;\n\t\t\tir->code |= 1 << ir->last_bit;\n\t\t}\n\t\t \n\t} else {\n\t\tir->active = true;\n\t\tir->code = 0;\n\t\tir->base_time = tv;\n\t\tir->last_bit = 0;\n\n\t\tmod_timer(&ir->timer, current_jiffies + msecs_to_jiffies(30));\n\t}\n\n\t \n\tbttv_gpio_write(&btv->c, gpio & ~(1 << 4));\n\tbttv_gpio_write(&btv->c, gpio | (1 << 4));\n\treturn 1;\n}\n\n \n\nstatic void bttv_ir_start(struct bttv_ir *ir)\n{\n\tif (ir->polling) {\n\t\ttimer_setup(&ir->timer, bttv_input_timer, 0);\n\t\tir->timer.expires  = jiffies + msecs_to_jiffies(1000);\n\t\tadd_timer(&ir->timer);\n\t} else if (ir->rc5_gpio) {\n\t\t \n\t\ttimer_setup(&ir->timer, bttv_rc5_timer_end, 0);\n\t\tir->shift_by = 1;\n\t\tir->rc5_remote_gap = ir_rc5_remote_gap;\n\t}\n}\n\nstatic void bttv_ir_stop(struct bttv *btv)\n{\n\tif (btv->remote->polling)\n\t\tdel_timer_sync(&btv->remote->timer);\n\n\tif (btv->remote->rc5_gpio) {\n\t\tu32 gpio;\n\n\t\tdel_timer_sync(&btv->remote->timer);\n\n\t\tgpio = bttv_gpio_read(&btv->c);\n\t\tbttv_gpio_write(&btv->c, gpio & ~(1 << 4));\n\t}\n}\n\n \n\nstatic int get_key_pv951(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t u32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char b;\n\n\t \n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tdprintk(\"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (b==0xaa)\n\t\treturn 0;\n\tdprintk(\"key %02x\\n\", b);\n\n\t \n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\n \nvoid init_bttv_i2c_ir(struct bttv *btv)\n{\n\tstatic const unsigned short addr_list[] = {\n\t\t0x1a, 0x18, 0x64, 0x30, 0x71,\n\t\tI2C_CLIENT_END\n\t};\n\tstruct i2c_board_info info;\n\tstruct i2c_client *i2c_dev;\n\n\tif (0 != btv->i2c_rc)\n\t\treturn;\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tmemset(&btv->init_data, 0, sizeof(btv->init_data));\n\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\n\tswitch (btv->c.type) {\n\tcase BTTV_BOARD_PV951:\n\t\tbtv->init_data.name = \"PV951\";\n\t\tbtv->init_data.get_key = get_key_pv951;\n\t\tbtv->init_data.ir_codes = RC_MAP_PV951;\n\t\tinfo.addr = 0x4b;\n\t\tbreak;\n\t}\n\n\tif (btv->init_data.name) {\n\t\tinfo.platform_data = &btv->init_data;\n\t\ti2c_dev = i2c_new_client_device(&btv->c.i2c_adap, &info);\n\t} else {\n\t\t \n\t\ti2c_dev = i2c_new_scanned_device(&btv->c.i2c_adap, &info, addr_list, NULL);\n\t}\n\tif (IS_ERR(i2c_dev))\n\t\treturn;\n\n#if defined(CONFIG_MODULES) && defined(MODULE)\n\trequest_module(\"ir-kbd-i2c\");\n#endif\n}\n\nint bttv_input_init(struct bttv *btv)\n{\n\tstruct bttv_ir *ir;\n\tchar *ir_codes = NULL;\n\tstruct rc_dev *rc;\n\tint err = -ENOMEM;\n\n\tif (!btv->has_remote)\n\t\treturn -ENODEV;\n\n\tir = kzalloc(sizeof(*ir),GFP_KERNEL);\n\trc = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!ir || !rc)\n\t\tgoto err_out_free;\n\n\t \n\tswitch (btv->c.type) {\n\tcase BTTV_BOARD_AVERMEDIA:\n\tcase BTTV_BOARD_AVPHONE98:\n\tcase BTTV_BOARD_AVERMEDIA98:\n\t\tir_codes         = RC_MAP_AVERMEDIA;\n\t\tir->mask_keycode = 0xf88000;\n\t\tir->mask_keydown = 0x010000;\n\t\tir->polling      = 50; \n\t\tbreak;\n\n\tcase BTTV_BOARD_AVDVBT_761:\n\tcase BTTV_BOARD_AVDVBT_771:\n\t\tir_codes         = RC_MAP_AVERMEDIA_DVBT;\n\t\tir->mask_keycode = 0x0f00c0;\n\t\tir->mask_keydown = 0x000020;\n\t\tir->polling      = 50; \n\t\tbreak;\n\n\tcase BTTV_BOARD_PXELVWPLTVPAK:\n\t\tir_codes         = RC_MAP_PIXELVIEW;\n\t\tir->mask_keycode = 0x003e00;\n\t\tir->mask_keyup   = 0x010000;\n\t\tir->polling      = 50; \n\t\tbreak;\n\tcase BTTV_BOARD_PV_M4900:\n\tcase BTTV_BOARD_PV_BT878P_9B:\n\tcase BTTV_BOARD_PV_BT878P_PLUS:\n\t\tir_codes         = RC_MAP_PIXELVIEW;\n\t\tir->mask_keycode = 0x001f00;\n\t\tir->mask_keyup   = 0x008000;\n\t\tir->polling      = 50; \n\t\tbreak;\n\n\tcase BTTV_BOARD_WINFAST2000:\n\t\tir_codes         = RC_MAP_WINFAST;\n\t\tir->mask_keycode = 0x1f8;\n\t\tbreak;\n\tcase BTTV_BOARD_MAGICTVIEW061:\n\tcase BTTV_BOARD_MAGICTVIEW063:\n\t\tir_codes         = RC_MAP_WINFAST;\n\t\tir->mask_keycode = 0x0008e000;\n\t\tir->mask_keydown = 0x00200000;\n\t\tbreak;\n\tcase BTTV_BOARD_APAC_VIEWCOMP:\n\t\tir_codes         = RC_MAP_APAC_VIEWCOMP;\n\t\tir->mask_keycode = 0x001f00;\n\t\tir->mask_keyup   = 0x008000;\n\t\tir->polling      = 50; \n\t\tbreak;\n\tcase BTTV_BOARD_ASKEY_CPH03X:\n\tcase BTTV_BOARD_CONCEPTRONIC_CTVFMI2:\n\tcase BTTV_BOARD_CONTVFMI:\n\tcase BTTV_BOARD_KWORLD_VSTREAM_XPERT:\n\t\tir_codes         = RC_MAP_PIXELVIEW;\n\t\tir->mask_keycode = 0x001F00;\n\t\tir->mask_keyup   = 0x006000;\n\t\tir->polling      = 50; \n\t\tbreak;\n\tcase BTTV_BOARD_NEBULA_DIGITV:\n\t\tir_codes         = RC_MAP_NEBULA;\n\t\tir->rc5_gpio     = true;\n\t\tbreak;\n\tcase BTTV_BOARD_MACHTV_MAGICTV:\n\t\tir_codes         = RC_MAP_APAC_VIEWCOMP;\n\t\tir->mask_keycode = 0x001F00;\n\t\tir->mask_keyup   = 0x004000;\n\t\tir->polling      = 50;  \n\t\tbreak;\n\tcase BTTV_BOARD_KOZUMI_KTV_01C:\n\t\tir_codes         = RC_MAP_PCTV_SEDNA;\n\t\tir->mask_keycode = 0x001f00;\n\t\tir->mask_keyup   = 0x006000;\n\t\tir->polling      = 50;  \n\t\tbreak;\n\tcase BTTV_BOARD_ENLTV_FM_2:\n\t\tir_codes         = RC_MAP_ENCORE_ENLTV2;\n\t\tir->mask_keycode = 0x00fd00;\n\t\tir->mask_keyup   = 0x000080;\n\t\tir->polling      = 1;  \n\t\tir->last_gpio    = ir_extract_bits(bttv_gpio_read(&btv->c),\n\t\t\t\t\t\t   ir->mask_keycode);\n\t\tbreak;\n\t}\n\n\tif (!ir_codes) {\n\t\tdprintk(\"Ooops: IR config error [card=%d]\\n\", btv->c.type);\n\t\terr = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\tif (ir->rc5_gpio) {\n\t\tu32 gpio;\n\t\t \n\t\tbttv_gpio_inout(&btv->c, (1 << 4), 1 << 4);\n\t\tgpio = bttv_gpio_read(&btv->c);\n\t\tbttv_gpio_write(&btv->c, gpio & ~(1 << 4));\n\t\tbttv_gpio_write(&btv->c, gpio | (1 << 4));\n\t} else {\n\t\t \n\t\tbttv_gpio_inout(&btv->c, ir->mask_keycode | ir->mask_keydown, 0);\n\t}\n\n\t \n\tir->dev = rc;\n\tir->btv = btv;\n\n\tsnprintf(ir->name, sizeof(ir->name), \"bttv IR (card=%d)\",\n\t\t btv->c.type);\n\tsnprintf(ir->phys, sizeof(ir->phys), \"pci-%s/ir0\",\n\t\t pci_name(btv->c.pci));\n\n\trc->device_name = ir->name;\n\trc->input_phys = ir->phys;\n\trc->input_id.bustype = BUS_PCI;\n\trc->input_id.version = 1;\n\tif (btv->c.pci->subsystem_vendor) {\n\t\trc->input_id.vendor  = btv->c.pci->subsystem_vendor;\n\t\trc->input_id.product = btv->c.pci->subsystem_device;\n\t} else {\n\t\trc->input_id.vendor  = btv->c.pci->vendor;\n\t\trc->input_id.product = btv->c.pci->device;\n\t}\n\trc->dev.parent = &btv->c.pci->dev;\n\trc->map_name = ir_codes;\n\trc->driver_name = MODULE_NAME;\n\n\tbtv->remote = ir;\n\tbttv_ir_start(ir);\n\n\t \n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto err_out_stop;\n\n\treturn 0;\n\n err_out_stop:\n\tbttv_ir_stop(btv);\n\tbtv->remote = NULL;\n err_out_free:\n\trc_free_device(rc);\n\tkfree(ir);\n\treturn err;\n}\n\nvoid bttv_input_fini(struct bttv *btv)\n{\n\tif (btv->remote == NULL)\n\t\treturn;\n\n\tbttv_ir_stop(btv);\n\trc_unregister_device(btv->remote->dev);\n\tkfree(btv->remote);\n\tbtv->remote = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}