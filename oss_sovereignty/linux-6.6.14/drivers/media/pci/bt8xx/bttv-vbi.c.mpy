{
  "module_name": "bttv-vbi.c",
  "hash_id": "12b5bb61284adf3ca83426848f6a37fb564a87e3eb7024ad4b36257690e27a8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-vbi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/kdev_t.h>\n#include <media/v4l2-ioctl.h>\n#include <asm/io.h>\n#include \"bttvp.h\"\n\n \n#define VBI_OFFSET 244\n\nstatic unsigned int vbibufs = 4;\nstatic unsigned int vbi_debug;\n\nmodule_param(vbibufs,   int, 0444);\nmodule_param(vbi_debug, int, 0644);\nMODULE_PARM_DESC(vbibufs,\"number of vbi buffers, range 2-32, default 4\");\nMODULE_PARM_DESC(vbi_debug,\"vbi code debug messages, default is 0 (no)\");\n\n#ifdef dprintk\n# undef dprintk\n#endif\n#define dprintk(fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (vbi_debug)\t\t\t\t\t\t\t\\\n\t\tpr_debug(\"%d: \" fmt, btv->c.nr, ##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define IMAGE_SIZE(fmt) \\\n\t(((fmt)->count[0] + (fmt)->count[1]) * (fmt)->samples_per_line)\n\n \n \n\nstatic int queue_setup_vbi(struct vb2_queue *q, unsigned int *num_buffers,\n\t\t\t   unsigned int *num_planes, unsigned int sizes[],\n\t\t\t   struct device *alloc_devs[])\n{\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\tunsigned int size = IMAGE_SIZE(&btv->vbi_fmt.fmt);\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void buf_queue_vbi(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&btv->s_lock, flags);\n\tif (list_empty(&btv->vcapture)) {\n\t\tbtv->loop_irq = BT848_RISC_VBI;\n\t\tif (vb2_is_streaming(&btv->capq))\n\t\t\tbtv->loop_irq |= BT848_RISC_VIDEO;\n\t\tbttv_set_dma(btv, BT848_CAP_CTL_CAPTURE_VBI_ODD |\n\t\t\t     BT848_CAP_CTL_CAPTURE_VBI_EVEN);\n\t}\n\tlist_add_tail(&buf->list, &btv->vcapture);\n\tspin_unlock_irqrestore(&btv->s_lock, flags);\n}\n\nstatic int buf_prepare_vbi(struct vb2_buffer *vb)\n{\n\tint ret = 0;\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\tunsigned int size = IMAGE_SIZE(&btv->vbi_fmt.fmt);\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\tbuf->vbuf.field = V4L2_FIELD_NONE;\n\tret = bttv_buffer_risc_vbi(btv, buf);\n\n\treturn ret;\n}\n\nstatic void buf_cleanup_vbi(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\n\tbtcx_riscmem_free(btv->c.pci, &buf->top);\n\tbtcx_riscmem_free(btv->c.pci, &buf->bottom);\n}\n\nstatic int start_streaming_vbi(struct vb2_queue *q, unsigned int count)\n{\n\tint seqnr = 0;\n\tstruct bttv_buffer *buf;\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\n\tbtv->framedrop = 0;\n\tif (!check_alloc_btres_lock(btv, RESOURCE_VBI)) {\n\t\tif (btv->field_count)\n\t\t\tseqnr++;\n\t\twhile (!list_empty(&btv->vcapture)) {\n\t\t\tbuf = list_entry(btv->vcapture.next,\n\t\t\t\t\t struct bttv_buffer, list);\n\t\t\tlist_del(&buf->list);\n\t\t\tbuf->vbuf.sequence = (btv->field_count >> 1) + seqnr++;\n\t\t\tvb2_buffer_done(&buf->vbuf.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\tif (!vb2_is_streaming(&btv->capq)) {\n\t\tinit_irqreg(btv);\n\t\tbtv->field_count = 0;\n\t}\n\treturn 0;\n}\n\nstatic void stop_streaming_vbi(struct vb2_queue *q)\n{\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\tunsigned long flags;\n\n\tvb2_wait_for_all_buffers(q);\n\tspin_lock_irqsave(&btv->s_lock, flags);\n\tfree_btres_lock(btv, RESOURCE_VBI);\n\tif (!vb2_is_streaming(&btv->capq)) {\n\t\t \n\t\tbtand(~BT848_INT_VSYNC, BT848_INT_MASK);\n\t}\n\tspin_unlock_irqrestore(&btv->s_lock, flags);\n}\n\nconst struct vb2_ops bttv_vbi_qops = {\n\t.queue_setup    = queue_setup_vbi,\n\t.buf_queue      = buf_queue_vbi,\n\t.buf_prepare    = buf_prepare_vbi,\n\t.buf_cleanup\t= buf_cleanup_vbi,\n\t.start_streaming = start_streaming_vbi,\n\t.stop_streaming = stop_streaming_vbi,\n\t.wait_prepare   = vb2_ops_wait_prepare,\n\t.wait_finish    = vb2_ops_wait_finish,\n};\n\n \n\nstatic int try_fmt(struct v4l2_vbi_format *f, const struct bttv_tvnorm *tvnorm,\n\t\t\t__s32 crop_start)\n{\n\t__s32 min_start, max_start, max_end, f2_offset;\n\tunsigned int i;\n\n\t \n\tmin_start = tvnorm->vbistart[0];\n\tmax_start = (crop_start >> 1) - 1;\n\tmax_end = (tvnorm->cropcap.bounds.top\n\t\t   + tvnorm->cropcap.bounds.height) >> 1;\n\n\tif (min_start > max_start)\n\t\treturn -EBUSY;\n\n\tWARN_ON(max_start >= max_end);\n\n\tf->sampling_rate    = tvnorm->Fsc;\n\tf->samples_per_line = VBI_BPL;\n\tf->sample_format    = V4L2_PIX_FMT_GREY;\n\tf->offset           = VBI_OFFSET;\n\n\tf2_offset = tvnorm->vbistart[1] - tvnorm->vbistart[0];\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tif (0 == f->count[i]) {\n\t\t\t \n\t\t} else {\n\t\t\ts64 start, count;\n\n\t\t\tstart = clamp(f->start[i], min_start, max_start);\n\t\t\t \n\t\t\tcount = (s64) f->start[i] + f->count[i] - start;\n\t\t\tf->start[i] = start;\n\t\t\tf->count[i] = clamp(count, (s64) 1,\n\t\t\t\t\t    max_end - start);\n\t\t}\n\n\t\tmin_start += f2_offset;\n\t\tmax_start += f2_offset;\n\t\tmax_end += f2_offset;\n\t}\n\n\tif (0 == (f->count[0] | f->count[1])) {\n\t\t \n\t\tf->start[0] = tvnorm->vbistart[0];\n\t\tf->start[1] = tvnorm->vbistart[1];\n\t\tf->count[0] = 1;\n\t\tf->count[1] = 1;\n\t}\n\n\tf->flags = 0;\n\n\tf->reserved[0] = 0;\n\tf->reserved[1] = 0;\n\n\treturn 0;\n}\n\nint bttv_try_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tconst struct bttv_tvnorm *tvnorm;\n\t__s32 crop_start;\n\n\tmutex_lock(&btv->lock);\n\n\ttvnorm = &bttv_tvnorms[btv->tvnorm];\n\tcrop_start = btv->crop_start;\n\n\tmutex_unlock(&btv->lock);\n\n\treturn try_fmt(&frt->fmt.vbi, tvnorm, crop_start);\n}\n\n\nint bttv_s_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tconst struct bttv_tvnorm *tvnorm;\n\t__s32 start1, end;\n\tint rc;\n\n\tmutex_lock(&btv->lock);\n\n\trc = -EBUSY;\n\tif (btv->resources & RESOURCE_VBI)\n\t\tgoto fail;\n\n\ttvnorm = &bttv_tvnorms[btv->tvnorm];\n\n\trc = try_fmt(&frt->fmt.vbi, tvnorm, btv->crop_start);\n\tif (0 != rc)\n\t\tgoto fail;\n\n\tstart1 = frt->fmt.vbi.start[1] - tvnorm->vbistart[1] +\n\t\ttvnorm->vbistart[0];\n\n\t \n\tend = max(frt->fmt.vbi.start[0], start1) * 2 + 2;\n\n\tbtv->vbi_fmt.fmt = frt->fmt.vbi;\n\tbtv->vbi_fmt.tvnorm = tvnorm;\n\tbtv->vbi_fmt.end = end;\n\n\trc = 0;\n\n fail:\n\tmutex_unlock(&btv->lock);\n\n\treturn rc;\n}\n\n\nint bttv_g_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\n{\n\tconst struct bttv_tvnorm *tvnorm;\n\tstruct bttv *btv = video_drvdata(file);\n\n\tfrt->fmt.vbi = btv->vbi_fmt.fmt;\n\n\ttvnorm = &bttv_tvnorms[btv->tvnorm];\n\n\tif (tvnorm != btv->vbi_fmt.tvnorm) {\n\t\t__s32 max_end;\n\t\tunsigned int i;\n\n\t\t \n\n\t\tmax_end = (tvnorm->cropcap.bounds.top\n\t\t\t   + tvnorm->cropcap.bounds.height) >> 1;\n\n\t\tfrt->fmt.vbi.sampling_rate = tvnorm->Fsc;\n\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\t__s32 new_start;\n\n\t\t\tnew_start = frt->fmt.vbi.start[i] + tvnorm->vbistart[i]\n\t\t\t\t- btv->vbi_fmt.tvnorm->vbistart[i];\n\n\t\t\tfrt->fmt.vbi.start[i] = min(new_start, max_end - 1);\n\t\t\tfrt->fmt.vbi.count[i] =\n\t\t\t\tmin((__s32) frt->fmt.vbi.count[i],\n\t\t\t\t\t  max_end - frt->fmt.vbi.start[i]);\n\n\t\t\tmax_end += tvnorm->vbistart[1]\n\t\t\t\t- tvnorm->vbistart[0];\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid bttv_vbi_fmt_reset(struct bttv_vbi_fmt *f, unsigned int norm)\n{\n\tconst struct bttv_tvnorm *tvnorm;\n\tunsigned int real_samples_per_line;\n\tunsigned int real_count;\n\n\ttvnorm = &bttv_tvnorms[norm];\n\n\tf->fmt.sampling_rate    = tvnorm->Fsc;\n\tf->fmt.samples_per_line = VBI_BPL;\n\tf->fmt.sample_format    = V4L2_PIX_FMT_GREY;\n\tf->fmt.offset           = VBI_OFFSET;\n\tf->fmt.start[0]\t\t= tvnorm->vbistart[0];\n\tf->fmt.start[1]\t\t= tvnorm->vbistart[1];\n\tf->fmt.count[0]\t\t= VBI_DEFLINES;\n\tf->fmt.count[1]\t\t= VBI_DEFLINES;\n\tf->fmt.flags            = 0;\n\tf->fmt.reserved[0]      = 0;\n\tf->fmt.reserved[1]      = 0;\n\n\t \n\treal_samples_per_line   = 1024 + tvnorm->vbipack * 4;\n\treal_count              = ((tvnorm->cropcap.defrect.top >> 1)\n\t\t\t\t   - tvnorm->vbistart[0]);\n\n\tWARN_ON(real_samples_per_line > VBI_BPL);\n\tWARN_ON(real_count > VBI_DEFLINES);\n\n\tf->tvnorm               = tvnorm;\n\n\t \n\tf->end                  = tvnorm->vbistart[0] * 2 + 2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}