{
  "module_name": "dst.c",
  "hash_id": "5b1efaf856b4dfb5aad0f8bcd66de50f66c8c752a29658ebb151535e0c029e2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/dst.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <asm/div64.h>\n#include <media/dvb_frontend.h>\n#include \"dst_priv.h\"\n#include \"dst_common.h\"\n\nstatic unsigned int verbose;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"verbosity level (0 to 3)\");\n\nstatic unsigned int dst_addons;\nmodule_param(dst_addons, int, 0644);\nMODULE_PARM_DESC(dst_addons, \"CA daughterboard, default is 0 (No addons)\");\n\nstatic unsigned int dst_algo;\nmodule_param(dst_algo, int, 0644);\nMODULE_PARM_DESC(dst_algo, \"tuning algo: default is 0=(SW), 1=(HW)\");\n\n#define HAS_LOCK\t\t1\n#define ATTEMPT_TUNE\t\t2\n#define HAS_POWER\t\t4\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (level >= verbose)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while(0)\n\nstatic int dst_command(struct dst_state *state, u8 *data, u8 len);\n\nstatic void dst_packsize(struct dst_state *state, int psize)\n{\n\tunion dst_gpio_packet bits;\n\n\tbits.psize = psize;\n\tbt878_device_control(state->bt, DST_IG_TS, &bits);\n}\n\nstatic int dst_gpio_outb(struct dst_state *state, u32 mask, u32 enbb,\n\t\t\t u32 outhigh, int delay)\n{\n\tunion dst_gpio_packet enb;\n\tunion dst_gpio_packet bits;\n\tint err;\n\n\tenb.enb.mask = mask;\n\tenb.enb.enable = enbb;\n\n\tdprintk(2, \"mask=[%04x], enbb=[%04x], outhigh=[%04x]\\n\",\n\t\tmask, enbb, outhigh);\n\tif ((err = bt878_device_control(state->bt, DST_IG_ENABLE, &enb)) < 0) {\n\t\tdprintk(2, \"dst_gpio_enb error (err == %i, mask == %02x, enb == %02x)\\n\",\n\t\t\terr, mask, enbb);\n\t\treturn -EREMOTEIO;\n\t}\n\tudelay(1000);\n\t \n\tif (enbb == 0)\n\t\treturn 0;\n\tif (delay)\n\t\tmsleep(10);\n\tbits.outp.mask = enbb;\n\tbits.outp.highvals = outhigh;\n\tif ((err = bt878_device_control(state->bt, DST_IG_WRITE, &bits)) < 0) {\n\t\tdprintk(2, \"dst_gpio_outb error (err == %i, enbb == %02x, outhigh == %02x)\\n\",\n\t\t\terr, enbb, outhigh);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_gpio_inb(struct dst_state *state, u8 *result)\n{\n\tunion dst_gpio_packet rd_packet;\n\tint err;\n\n\t*result = 0;\n\tif ((err = bt878_device_control(state->bt, DST_IG_READ, &rd_packet)) < 0) {\n\t\tpr_err(\"dst_gpio_inb error (err == %i)\\n\", err);\n\t\treturn -EREMOTEIO;\n\t}\n\t*result = (u8) rd_packet.rd.value;\n\n\treturn 0;\n}\n\nint rdc_reset_state(struct dst_state *state)\n{\n\tdprintk(2, \"Resetting state machine\\n\");\n\tif (dst_gpio_outb(state, RDC_8820_INT, RDC_8820_INT, 0, NO_DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(10);\n\tif (dst_gpio_outb(state, RDC_8820_INT, RDC_8820_INT, RDC_8820_INT, NO_DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\tmsleep(10);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rdc_reset_state);\n\nstatic int rdc_8820_reset(struct dst_state *state)\n{\n\tdprintk(3, \"Resetting DST\\n\");\n\tif (dst_gpio_outb(state, RDC_8820_RESET, RDC_8820_RESET, 0, NO_DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\treturn -1;\n\t}\n\tudelay(1000);\n\tif (dst_gpio_outb(state, RDC_8820_RESET, RDC_8820_RESET, RDC_8820_RESET, DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_pio_enable(struct dst_state *state)\n{\n\tif (dst_gpio_outb(state, ~0, RDC_8820_PIO_0_ENABLE, 0, NO_DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\treturn -1;\n\t}\n\tudelay(1000);\n\n\treturn 0;\n}\n\nint dst_pio_disable(struct dst_state *state)\n{\n\tif (dst_gpio_outb(state, ~0, RDC_8820_PIO_0_DISABLE, RDC_8820_PIO_0_DISABLE, NO_DELAY) < 0) {\n\t\tpr_err(\"dst_gpio_outb ERROR !\\n\");\n\t\treturn -1;\n\t}\n\tif (state->type_flags & DST_TYPE_HAS_FW_1)\n\t\tudelay(1000);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_pio_disable);\n\nint dst_wait_dst_ready(struct dst_state *state, u8 delay_mode)\n{\n\tu8 reply;\n\tint i;\n\n\tfor (i = 0; i < 200; i++) {\n\t\tif (dst_gpio_inb(state, &reply) < 0) {\n\t\t\tpr_err(\"dst_gpio_inb ERROR !\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ((reply & RDC_8820_PIO_0_ENABLE) == 0) {\n\t\t\tdprintk(2, \"dst wait ready after %d\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tmsleep(10);\n\t}\n\tdprintk(1, \"dst wait NOT ready after %d\\n\", i);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_wait_dst_ready);\n\nint dst_error_recovery(struct dst_state *state)\n{\n\tdprintk(1, \"Trying to return from previous errors.\\n\");\n\tdst_pio_disable(state);\n\tmsleep(10);\n\tdst_pio_enable(state);\n\tmsleep(10);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_error_recovery);\n\nint dst_error_bailout(struct dst_state *state)\n{\n\tdprintk(2, \"Trying to bailout from previous error.\\n\");\n\trdc_8820_reset(state);\n\tdst_pio_disable(state);\n\tmsleep(10);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_error_bailout);\n\nint dst_comm_init(struct dst_state *state)\n{\n\tdprintk(2, \"Initializing DST.\\n\");\n\tif ((dst_pio_enable(state)) < 0) {\n\t\tpr_err(\"PIO Enable Failed\\n\");\n\t\treturn -1;\n\t}\n\tif ((rdc_reset_state(state)) < 0) {\n\t\tpr_err(\"RDC 8820 State RESET Failed.\\n\");\n\t\treturn -1;\n\t}\n\tif (state->type_flags & DST_TYPE_HAS_FW_1)\n\t\tmsleep(100);\n\telse\n\t\tmsleep(5);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dst_comm_init);\n\nint write_dst(struct dst_state *state, u8 *data, u8 len)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address,\n\t\t.flags = 0,\n\t\t.buf = data,\n\t\t.len = len\n\t};\n\n\tint err;\n\tu8 cnt;\n\n\tdprintk(1, \"writing [ %*ph ]\\n\", len, data);\n\n\tfor (cnt = 0; cnt < 2; cnt++) {\n\t\tif ((err = i2c_transfer(state->i2c, &msg, 1)) < 0) {\n\t\t\tdprintk(2, \"_write_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\\n\",\n\t\t\t\terr, len, data[0]);\n\t\t\tdst_error_recovery(state);\n\t\t\tcontinue;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (cnt >= 2) {\n\t\tdprintk(2, \"RDC 8820 RESET\\n\");\n\t\tdst_error_bailout(state);\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(write_dst);\n\nint read_dst(struct dst_state *state, u8 *ret, u8 len)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = ret,\n\t\t.len = len\n\t};\n\n\tint err;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < 2; cnt++) {\n\t\tif ((err = i2c_transfer(state->i2c, &msg, 1)) < 0) {\n\t\t\tdprintk(2, \"read_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\\n\",\n\t\t\t\terr, len, ret[0]);\n\t\t\tdst_error_recovery(state);\n\t\t\tcontinue;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (cnt >= 2) {\n\t\tdprintk(2, \"RDC 8820 RESET\\n\");\n\t\tdst_error_bailout(state);\n\n\t\treturn -1;\n\t}\n\tdprintk(3, \"reply is %*ph\\n\", len, ret);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(read_dst);\n\nstatic int dst_set_polarization(struct dst_state *state)\n{\n\tswitch (state->voltage) {\n\tcase SEC_VOLTAGE_13:\t \n\t\tdprintk(2, \"Polarization=[Vertical]\\n\");\n\t\tstate->tx_tuna[8] &= ~0x40;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\t \n\t\tdprintk(2, \"Polarization=[Horizontal]\\n\");\n\t\tstate->tx_tuna[8] |= 0x40;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_set_freq(struct dst_state *state, u32 freq)\n{\n\tstate->frequency = freq;\n\tdprintk(2, \"set Frequency %u\\n\", freq);\n\n\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\tfreq = freq / 1000;\n\t\tif (freq < 950 || freq > 2150)\n\t\t\treturn -EINVAL;\n\t\tstate->tx_tuna[2] = (freq >> 8);\n\t\tstate->tx_tuna[3] = (u8) freq;\n\t\tstate->tx_tuna[4] = 0x01;\n\t\tstate->tx_tuna[8] &= ~0x04;\n\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS) {\n\t\t\tif (freq < 1531)\n\t\t\t\tstate->tx_tuna[8] |= 0x04;\n\t\t}\n\t} else if (state->dst_type == DST_TYPE_IS_TERR) {\n\t\tfreq = freq / 1000;\n\t\tif (freq < 137000 || freq > 858000)\n\t\t\treturn -EINVAL;\n\t\tstate->tx_tuna[2] = (freq >> 16) & 0xff;\n\t\tstate->tx_tuna[3] = (freq >> 8) & 0xff;\n\t\tstate->tx_tuna[4] = (u8) freq;\n\t} else if (state->dst_type == DST_TYPE_IS_CABLE) {\n\t\tfreq = freq / 1000;\n\t\tstate->tx_tuna[2] = (freq >> 16) & 0xff;\n\t\tstate->tx_tuna[3] = (freq >> 8) & 0xff;\n\t\tstate->tx_tuna[4] = (u8) freq;\n\t} else if (state->dst_type == DST_TYPE_IS_ATSC) {\n\t\tfreq = freq / 1000;\n\t\tif (freq < 51000 || freq > 858000)\n\t\t\treturn -EINVAL;\n\t\tstate->tx_tuna[2] = (freq >> 16) & 0xff;\n\t\tstate->tx_tuna[3] = (freq >>  8) & 0xff;\n\t\tstate->tx_tuna[4] = (u8) freq;\n\t\tstate->tx_tuna[5] = 0x00;\t\t \n\t\tstate->tx_tuna[6] = 0x00;\n\t\tif (state->dst_hw_cap & DST_TYPE_HAS_ANALOG)\n\t\t\tstate->tx_tuna[7] = 0x00;\t \n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dst_set_bandwidth(struct dst_state *state, u32 bandwidth)\n{\n\tstate->bandwidth = bandwidth;\n\n\tif (state->dst_type != DST_TYPE_IS_TERR)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\tif (state->dst_hw_cap & DST_TYPE_HAS_CA)\n\t\t\tstate->tx_tuna[7] = 0x06;\n\t\telse {\n\t\t\tstate->tx_tuna[6] = 0x06;\n\t\t\tstate->tx_tuna[7] = 0x00;\n\t\t}\n\t\tbreak;\n\tcase 7000000:\n\t\tif (state->dst_hw_cap & DST_TYPE_HAS_CA)\n\t\t\tstate->tx_tuna[7] = 0x07;\n\t\telse {\n\t\t\tstate->tx_tuna[6] = 0x07;\n\t\t\tstate->tx_tuna[7] = 0x00;\n\t\t}\n\t\tbreak;\n\tcase 8000000:\n\t\tif (state->dst_hw_cap & DST_TYPE_HAS_CA)\n\t\t\tstate->tx_tuna[7] = 0x08;\n\t\telse {\n\t\t\tstate->tx_tuna[6] = 0x08;\n\t\t\tstate->tx_tuna[7] = 0x00;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_set_inversion(struct dst_state *state,\n\t\t\t     enum fe_spectral_inversion inversion)\n{\n\tstate->inversion = inversion;\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\t \n\t\tstate->tx_tuna[8] &= ~0x80;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->tx_tuna[8] |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_set_fec(struct dst_state *state, enum fe_code_rate fec)\n{\n\tstate->fec = fec;\n\treturn 0;\n}\n\nstatic enum fe_code_rate dst_get_fec(struct dst_state *state)\n{\n\treturn state->fec;\n}\n\nstatic int dst_set_symbolrate(struct dst_state *state, u32 srate)\n{\n\tu32 symcalc;\n\tu64 sval;\n\n\tstate->symbol_rate = srate;\n\tif (state->dst_type == DST_TYPE_IS_TERR) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\tdprintk(2, \"set symrate %u\\n\", srate);\n\tsrate /= 1000;\n\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\tif (state->type_flags & DST_TYPE_HAS_SYMDIV) {\n\t\t\tsval = srate;\n\t\t\tsval <<= 20;\n\t\t\tdo_div(sval, 88000);\n\t\t\tsymcalc = (u32) sval;\n\t\t\tdprintk(2, \"set symcalc %u\\n\", symcalc);\n\t\t\tstate->tx_tuna[5] = (u8) (symcalc >> 12);\n\t\t\tstate->tx_tuna[6] = (u8) (symcalc >> 4);\n\t\t\tstate->tx_tuna[7] = (u8) (symcalc << 4);\n\t\t} else {\n\t\t\tstate->tx_tuna[5] = (u8) (srate >> 16) & 0x7f;\n\t\t\tstate->tx_tuna[6] = (u8) (srate >> 8);\n\t\t\tstate->tx_tuna[7] = (u8) srate;\n\t\t}\n\t\tstate->tx_tuna[8] &= ~0x20;\n\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS) {\n\t\t\tif (srate > 8000)\n\t\t\t\tstate->tx_tuna[8] |= 0x20;\n\t\t}\n\t} else if (state->dst_type == DST_TYPE_IS_CABLE) {\n\t\tdprintk(3, \"%s\\n\", state->fw_name);\n\t\tif (!strncmp(state->fw_name, \"DCTNEW\", 6)) {\n\t\t\tstate->tx_tuna[5] = (u8) (srate >> 8);\n\t\t\tstate->tx_tuna[6] = (u8) srate;\n\t\t\tstate->tx_tuna[7] = 0x00;\n\t\t} else if (!strncmp(state->fw_name, \"DCT-CI\", 6)) {\n\t\t\tstate->tx_tuna[5] = 0x00;\n\t\t\tstate->tx_tuna[6] = (u8) (srate >> 8);\n\t\t\tstate->tx_tuna[7] = (u8) srate;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dst_set_modulation(struct dst_state *state,\n\t\t\t      enum fe_modulation modulation)\n{\n\tif (state->dst_type != DST_TYPE_IS_CABLE)\n\t\treturn -EOPNOTSUPP;\n\n\tstate->modulation = modulation;\n\tswitch (modulation) {\n\tcase QAM_16:\n\t\tstate->tx_tuna[8] = 0x10;\n\t\tbreak;\n\tcase QAM_32:\n\t\tstate->tx_tuna[8] = 0x20;\n\t\tbreak;\n\tcase QAM_64:\n\t\tstate->tx_tuna[8] = 0x40;\n\t\tbreak;\n\tcase QAM_128:\n\t\tstate->tx_tuna[8] = 0x80;\n\t\tbreak;\n\tcase QAM_256:\n\t\tif (!strncmp(state->fw_name, \"DCTNEW\", 6))\n\t\t\tstate->tx_tuna[8] = 0xff;\n\t\telse if (!strncmp(state->fw_name, \"DCT-CI\", 6))\n\t\t\tstate->tx_tuna[8] = 0x00;\n\t\tbreak;\n\tcase QPSK:\n\tcase QAM_AUTO:\n\tcase VSB_8:\n\tcase VSB_16:\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\nstatic enum fe_modulation dst_get_modulation(struct dst_state *state)\n{\n\treturn state->modulation;\n}\n\n\nu8 dst_check_sum(u8 *buf, u32 len)\n{\n\tu32 i;\n\tu8 val = 0;\n\tif (!len)\n\t\treturn 0;\n\tfor (i = 0; i < len; i++) {\n\t\tval += buf[i];\n\t}\n\treturn ((~val) + 1);\n}\nEXPORT_SYMBOL(dst_check_sum);\n\nstatic void dst_type_flags_print(struct dst_state *state)\n{\n\tu32 type_flags = state->type_flags;\n\n\tpr_err(\"DST type flags :\\n\");\n\tif (type_flags & DST_TYPE_HAS_TS188)\n\t\tpr_err(\" 0x%x newtuner\\n\", DST_TYPE_HAS_TS188);\n\tif (type_flags & DST_TYPE_HAS_NEWTUNE_2)\n\t\tpr_err(\" 0x%x newtuner 2\\n\", DST_TYPE_HAS_NEWTUNE_2);\n\tif (type_flags & DST_TYPE_HAS_TS204)\n\t\tpr_err(\" 0x%x ts204\\n\", DST_TYPE_HAS_TS204);\n\tif (type_flags & DST_TYPE_HAS_VLF)\n\t\tpr_err(\" 0x%x VLF\\n\", DST_TYPE_HAS_VLF);\n\tif (type_flags & DST_TYPE_HAS_SYMDIV)\n\t\tpr_err(\" 0x%x symdiv\\n\", DST_TYPE_HAS_SYMDIV);\n\tif (type_flags & DST_TYPE_HAS_FW_1)\n\t\tpr_err(\" 0x%x firmware version = 1\\n\", DST_TYPE_HAS_FW_1);\n\tif (type_flags & DST_TYPE_HAS_FW_2)\n\t\tpr_err(\" 0x%x firmware version = 2\\n\", DST_TYPE_HAS_FW_2);\n\tif (type_flags & DST_TYPE_HAS_FW_3)\n\t\tpr_err(\" 0x%x firmware version = 3\\n\", DST_TYPE_HAS_FW_3);\n\tpr_err(\"\\n\");\n}\n\n\nstatic int dst_type_print(struct dst_state *state, u8 type)\n{\n\tchar *otype;\n\tswitch (type) {\n\tcase DST_TYPE_IS_SAT:\n\t\totype = \"satellite\";\n\t\tbreak;\n\n\tcase DST_TYPE_IS_TERR:\n\t\totype = \"terrestrial\";\n\t\tbreak;\n\n\tcase DST_TYPE_IS_CABLE:\n\t\totype = \"cable\";\n\t\tbreak;\n\n\tcase DST_TYPE_IS_ATSC:\n\t\totype = \"atsc\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(2, \"invalid dst type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\tdprintk(2, \"DST type: %s\\n\", otype);\n\n\treturn 0;\n}\n\nstatic struct tuner_types tuner_list[] = {\n\t{\n\t\t.tuner_type = TUNER_TYPE_L64724,\n\t\t.tuner_name = \"L 64724\",\n\t\t.board_name = \"UNKNOWN\",\n\t\t.fw_name    = \"UNKNOWN\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_STV0299,\n\t\t.tuner_name = \"STV 0299\",\n\t\t.board_name = \"VP1020\",\n\t\t.fw_name    = \"DST-MOT\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_STV0299,\n\t\t.tuner_name = \"STV 0299\",\n\t\t.board_name = \"VP1020\",\n\t\t.fw_name    = \"DST-03T\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_MB86A15,\n\t\t.tuner_name = \"MB 86A15\",\n\t\t.board_name = \"VP1022\",\n\t\t.fw_name    = \"DST-03T\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_MB86A15,\n\t\t.tuner_name = \"MB 86A15\",\n\t\t.board_name = \"VP1025\",\n\t\t.fw_name    = \"DST-03T\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_STV0299,\n\t\t.tuner_name = \"STV 0299\",\n\t\t.board_name = \"VP1030\",\n\t\t.fw_name    = \"DST-CI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_STV0299,\n\t\t.tuner_name = \"STV 0299\",\n\t\t.board_name = \"VP1030\",\n\t\t.fw_name    = \"DSTMCI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP2021\",\n\t\t.fw_name    = \"DCTNEW\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP2030\",\n\t\t.fw_name    = \"DCT-CI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP2031\",\n\t\t.fw_name    = \"DCT-CI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP2040\",\n\t\t.fw_name    = \"DCT-CI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP3020\",\n\t\t.fw_name    = \"DTTFTA\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP3021\",\n\t\t.fw_name    = \"DTTFTA\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_TDA10046,\n\t\t.tuner_name = \"TDA10046\",\n\t\t.board_name = \"VP3040\",\n\t\t.fw_name    = \"DTT-CI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_UNKNOWN,\n\t\t.tuner_name = \"UNKNOWN\",\n\t\t.board_name = \"VP3051\",\n\t\t.fw_name    = \"DTTNXT\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_NXT200x,\n\t\t.tuner_name = \"NXT200x\",\n\t\t.board_name = \"VP3220\",\n\t\t.fw_name    = \"ATSCDI\"\n\t},\n\n\t{\n\t\t.tuner_type = TUNER_TYPE_NXT200x,\n\t\t.tuner_name = \"NXT200x\",\n\t\t.board_name = \"VP3250\",\n\t\t.fw_name    = \"ATSCAD\"\n\t},\n};\n\n \n\nstatic struct dst_types dst_tlist[] = {\n\t{\n\t\t.device_id = \"200103A\",\n\t\t.offset = 0,\n\t\t.dst_type =  DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_SYMDIV | DST_TYPE_HAS_FW_1 | DST_TYPE_HAS_OBS_REGS,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DST-020\",\n\t\t.offset = 0,\n\t\t.dst_type =  DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_SYMDIV | DST_TYPE_HAS_FW_1,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DST-030\",\n\t\t.offset =  0,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_TS204 | DST_TYPE_HAS_TS188 | DST_TYPE_HAS_FW_1,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DST-03T\",\n\t\t.offset = 0,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_SYMDIV | DST_TYPE_HAS_TS204 | DST_TYPE_HAS_FW_2,\n\t\t.dst_feature = DST_TYPE_HAS_DISEQC3 | DST_TYPE_HAS_DISEQC4 | DST_TYPE_HAS_DISEQC5\n\t\t\t\t\t\t\t | DST_TYPE_HAS_MAC | DST_TYPE_HAS_MOTO,\n\t\t.tuner_type = TUNER_TYPE_MULTI\n\t },\n\n\t{\n\t\t.device_id = \"DST-MOT\",\n\t\t.offset =  0,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_SYMDIV | DST_TYPE_HAS_FW_1,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DST-CI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_TS204 | DST_TYPE_HAS_FW_1,\n\t\t.dst_feature = DST_TYPE_HAS_CA,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DSTMCI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_TS188 | DST_TYPE_HAS_FW_2 | DST_TYPE_HAS_FW_BUILD | DST_TYPE_HAS_INC_COUNT | DST_TYPE_HAS_VLF,\n\t\t.dst_feature = DST_TYPE_HAS_CA | DST_TYPE_HAS_DISEQC3 | DST_TYPE_HAS_DISEQC4\n\t\t\t\t\t\t\t| DST_TYPE_HAS_MOTO | DST_TYPE_HAS_MAC,\n\t\t.tuner_type = TUNER_TYPE_MULTI\n\t},\n\n\t{\n\t\t.device_id = \"DSTFCI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_SAT,\n\t\t.type_flags = DST_TYPE_HAS_TS188 | DST_TYPE_HAS_FW_1,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\t \n\n\t{\n\t\t.device_id = \"DCT-CI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_CABLE,\n\t\t.type_flags = DST_TYPE_HAS_MULTI_FE | DST_TYPE_HAS_FW_1\t| DST_TYPE_HAS_FW_2 | DST_TYPE_HAS_VLF,\n\t\t.dst_feature = DST_TYPE_HAS_CA,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"DCTNEW\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_CABLE,\n\t\t.type_flags = DST_TYPE_HAS_TS188 | DST_TYPE_HAS_FW_3 | DST_TYPE_HAS_FW_BUILD | DST_TYPE_HAS_MULTI_FE,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"DTT-CI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_TERR,\n\t\t.type_flags = DST_TYPE_HAS_FW_2 | DST_TYPE_HAS_MULTI_FE | DST_TYPE_HAS_VLF,\n\t\t.dst_feature = DST_TYPE_HAS_CA,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"DTTDIG\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_TERR,\n\t\t.type_flags = DST_TYPE_HAS_FW_2,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"DTTNXT\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_TERR,\n\t\t.type_flags = DST_TYPE_HAS_FW_2,\n\t\t.dst_feature = DST_TYPE_HAS_ANALOG,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"ATSCDI\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_ATSC,\n\t\t.type_flags = DST_TYPE_HAS_FW_2,\n\t\t.dst_feature = 0,\n\t\t.tuner_type = 0\n\t},\n\n\t{\n\t\t.device_id = \"ATSCAD\",\n\t\t.offset = 1,\n\t\t.dst_type = DST_TYPE_IS_ATSC,\n\t\t.type_flags = DST_TYPE_HAS_MULTI_FE | DST_TYPE_HAS_FW_2 | DST_TYPE_HAS_FW_BUILD,\n\t\t.dst_feature = DST_TYPE_HAS_MAC | DST_TYPE_HAS_ANALOG,\n\t\t.tuner_type = 0\n\t},\n\n\t{ }\n\n};\n\nstatic int dst_get_mac(struct dst_state *state)\n{\n\tu8 get_mac[] = { 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tget_mac[7] = dst_check_sum(get_mac, 7);\n\tif (dst_command(state, get_mac, 8) < 0) {\n\t\tdprintk(2, \"Unsupported Command\\n\");\n\t\treturn -1;\n\t}\n\tmemset(&state->mac_address, '\\0', 8);\n\tmemcpy(&state->mac_address, &state->rxbuffer, 6);\n\tpr_err(\"MAC Address=[%pM]\\n\", state->mac_address);\n\n\treturn 0;\n}\n\nstatic int dst_fw_ver(struct dst_state *state)\n{\n\tu8 get_ver[] = { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tget_ver[7] = dst_check_sum(get_ver, 7);\n\tif (dst_command(state, get_ver, 8) < 0) {\n\t\tdprintk(2, \"Unsupported Command\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(&state->fw_version, &state->rxbuffer, 8);\n\tpr_err(\"Firmware Ver = %x.%x Build = %02x, on %x:%x, %x-%x-20%02x\\n\",\n\t\tstate->fw_version[0] >> 4, state->fw_version[0] & 0x0f,\n\t\tstate->fw_version[1],\n\t\tstate->fw_version[5], state->fw_version[6],\n\t\tstate->fw_version[4], state->fw_version[3], state->fw_version[2]);\n\n\treturn 0;\n}\n\nstatic int dst_card_type(struct dst_state *state)\n{\n\tint j;\n\tstruct tuner_types *p_tuner_list = NULL;\n\n\tu8 get_type[] = { 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tget_type[7] = dst_check_sum(get_type, 7);\n\tif (dst_command(state, get_type, 8) < 0) {\n\t\tdprintk(2, \"Unsupported Command\\n\");\n\t\treturn -1;\n\t}\n\tmemset(&state->card_info, '\\0', 8);\n\tmemcpy(&state->card_info, &state->rxbuffer, 7);\n\tpr_err(\"Device Model=[%s]\\n\", &state->card_info[0]);\n\n\tfor (j = 0, p_tuner_list = tuner_list; j < ARRAY_SIZE(tuner_list); j++, p_tuner_list++) {\n\t\tif (!strcmp(&state->card_info[0], p_tuner_list->board_name)) {\n\t\t\tstate->tuner_type = p_tuner_list->tuner_type;\n\t\t\tpr_err(\"DST has [%s] tuner, tuner type=[%d]\\n\",\n\t\t\t\tp_tuner_list->tuner_name, p_tuner_list->tuner_type);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_get_vendor(struct dst_state *state)\n{\n\tu8 get_vendor[] = { 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tget_vendor[7] = dst_check_sum(get_vendor, 7);\n\tif (dst_command(state, get_vendor, 8) < 0) {\n\t\tdprintk(2, \"Unsupported Command\\n\");\n\t\treturn -1;\n\t}\n\tmemset(&state->vendor, '\\0', 8);\n\tmemcpy(&state->vendor, &state->rxbuffer, 7);\n\tpr_err(\"Vendor=[%s]\\n\", &state->vendor[0]);\n\n\treturn 0;\n}\n\nstatic void debug_dst_buffer(struct dst_state *state)\n{\n\tdprintk(3, \"%s: [ %*ph ]\\n\", __func__, 8, state->rxbuffer);\n}\n\nstatic int dst_check_stv0299(struct dst_state *state)\n{\n\tu8 check_stv0299[] = { 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tcheck_stv0299[7] = dst_check_sum(check_stv0299, 7);\n\tif (dst_command(state, check_stv0299, 8) < 0) {\n\t\tpr_err(\"Cmd=[0x04] failed\\n\");\n\t\treturn -1;\n\t}\n\tdebug_dst_buffer(state);\n\n\tif (memcmp(&check_stv0299, &state->rxbuffer, 8)) {\n\t\tpr_err(\"Found a STV0299 NIM\\n\");\n\t\tstate->tuner_type = TUNER_TYPE_STV0299;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int dst_check_mb86a15(struct dst_state *state)\n{\n\tu8 check_mb86a15[] = { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tcheck_mb86a15[7] = dst_check_sum(check_mb86a15, 7);\n\tif (dst_command(state, check_mb86a15, 8) < 0) {\n\t\tpr_err(\"Cmd=[0x10], failed\\n\");\n\t\treturn -1;\n\t}\n\tdebug_dst_buffer(state);\n\n\tif (memcmp(&check_mb86a15, &state->rxbuffer, 8) < 0) {\n\t\tpr_err(\"Found a MB86A15 NIM\\n\");\n\t\tstate->tuner_type = TUNER_TYPE_MB86A15;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int dst_get_tuner_info(struct dst_state *state)\n{\n\tu8 get_tuner_1[] = { 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tu8 get_tuner_2[] = { 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tget_tuner_1[7] = dst_check_sum(get_tuner_1, 7);\n\tget_tuner_2[7] = dst_check_sum(get_tuner_2, 7);\n\tpr_err(\"DST TYpe = MULTI FE\\n\");\n\tif (state->type_flags & DST_TYPE_HAS_MULTI_FE) {\n\t\tif (dst_command(state, get_tuner_1, 8) < 0) {\n\t\t\tdprintk(2, \"Cmd=[0x13], Unsupported\\n\");\n\t\t\tgoto force;\n\t\t}\n\t} else {\n\t\tif (dst_command(state, get_tuner_2, 8) < 0) {\n\t\t\tdprintk(2, \"Cmd=[0xb], Unsupported\\n\");\n\t\t\tgoto force;\n\t\t}\n\t}\n\tmemcpy(&state->board_info, &state->rxbuffer, 8);\n\tif (state->type_flags & DST_TYPE_HAS_MULTI_FE) {\n\t\tpr_err(\"DST type has TS=188\\n\");\n\t}\n\tif (state->board_info[0] == 0xbc) {\n\t\tif (state->dst_type != DST_TYPE_IS_ATSC)\n\t\t\tstate->type_flags |= DST_TYPE_HAS_TS188;\n\t\telse\n\t\t\tstate->type_flags |= DST_TYPE_HAS_NEWTUNE_2;\n\n\t\tif (state->board_info[1] == 0x01) {\n\t\t\tstate->dst_hw_cap |= DST_TYPE_HAS_DBOARD;\n\t\t\tpr_err(\"DST has Daughterboard\\n\");\n\t\t}\n\t}\n\n\treturn 0;\nforce:\n\tif (!strncmp(state->fw_name, \"DCT-CI\", 6)) {\n\t\tstate->type_flags |= DST_TYPE_HAS_TS204;\n\t\tpr_err(\"Forcing [%s] to TS188\\n\", state->fw_name);\n\t}\n\n\treturn -1;\n}\n\nstatic int dst_get_device_id(struct dst_state *state)\n{\n\tu8 reply;\n\n\tint i, j;\n\tstruct dst_types *p_dst_type = NULL;\n\tstruct tuner_types *p_tuner_list = NULL;\n\n\tu8 use_dst_type = 0;\n\tu32 use_type_flags = 0;\n\n\tstatic u8 device_type[8] = {0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff};\n\n\tstate->tuner_type = 0;\n\tdevice_type[7] = dst_check_sum(device_type, 7);\n\n\tif (write_dst(state, device_type, FIXED_COMM))\n\t\treturn -1;\t\t \n\tif ((dst_pio_disable(state)) < 0)\n\t\treturn -1;\n\tif (read_dst(state, &reply, GET_ACK))\n\t\treturn -1;\t\t \n\tif (reply != ACK) {\n\t\tdprintk(2, \"Write not Acknowledged! [Reply=0x%02x]\\n\", reply);\n\t\treturn -1;\t\t \n\t}\n\tif (!dst_wait_dst_ready(state, DEVICE_INIT))\n\t\treturn -1;\t\t \n\tif (read_dst(state, state->rxbuffer, FIXED_COMM))\n\t\treturn -1;\n\n\tdst_pio_disable(state);\n\tif (state->rxbuffer[7] != dst_check_sum(state->rxbuffer, 7)) {\n\t\tdprintk(2, \"Checksum failure!\\n\");\n\t\treturn -1;\t\t \n\t}\n\tstate->rxbuffer[7] = '\\0';\n\n\tfor (i = 0, p_dst_type = dst_tlist; i < ARRAY_SIZE(dst_tlist); i++, p_dst_type++) {\n\t\tif (!strncmp (&state->rxbuffer[p_dst_type->offset], p_dst_type->device_id, strlen (p_dst_type->device_id))) {\n\t\t\tuse_type_flags = p_dst_type->type_flags;\n\t\t\tuse_dst_type = p_dst_type->dst_type;\n\n\t\t\t \n\t\t\tstate->dst_hw_cap = p_dst_type->dst_feature;\n\t\t\tpr_err(\"Recognise [%s]\\n\", p_dst_type->device_id);\n\t\t\tstrscpy(state->fw_name, p_dst_type->device_id,\n\t\t\t        sizeof(state->fw_name));\n\t\t\t \n\t\t\tif (p_dst_type->tuner_type & TUNER_TYPE_MULTI) {\n\t\t\t\tswitch (use_dst_type) {\n\t\t\t\tcase DST_TYPE_IS_SAT:\n\t\t\t\t\t \n\t\t\t\t\tif (dst_check_stv0299(state) < 0) {\n\t\t\t\t\t\tpr_err(\"Unsupported\\n\");\n\t\t\t\t\t\tstate->tuner_type = TUNER_TYPE_MB86A15;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dst_check_mb86a15(state) < 0)\n\t\t\t\t\tpr_err(\"Unsupported\\n\");\n\t\t\t \n\t\t\t} else {\n\t\t\t\tstate->tuner_type = p_dst_type->tuner_type;\n\t\t\t}\n\t\t\tfor (j = 0, p_tuner_list = tuner_list; j < ARRAY_SIZE(tuner_list); j++, p_tuner_list++) {\n\t\t\t\tif (!(strncmp(p_dst_type->device_id, p_tuner_list->fw_name, 7)) &&\n\t\t\t\t\tp_tuner_list->tuner_type == state->tuner_type) {\n\t\t\t\t\tpr_err(\"[%s] has a [%s]\\n\",\n\t\t\t\t\t\tp_dst_type->device_id, p_tuner_list->tuner_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(dst_tlist)) {\n\t\tpr_err(\"Unable to recognize %s or %s\\n\", &state->rxbuffer[0], &state->rxbuffer[1]);\n\t\tpr_err(\"please email linux-dvb@linuxtv.org with this type in\");\n\t\tuse_dst_type = DST_TYPE_IS_SAT;\n\t\tuse_type_flags = DST_TYPE_HAS_SYMDIV;\n\t}\n\tdst_type_print(state, use_dst_type);\n\tstate->type_flags = use_type_flags;\n\tstate->dst_type = use_dst_type;\n\tdst_type_flags_print(state);\n\n\treturn 0;\n}\n\nstatic int dst_probe(struct dst_state *state)\n{\n\tmutex_init(&state->dst_mutex);\n\tif (dst_addons & DST_TYPE_HAS_CA) {\n\t\tif ((rdc_8820_reset(state)) < 0) {\n\t\t\tpr_err(\"RDC 8820 RESET Failed.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(4000);\n\t} else {\n\t\tmsleep(100);\n\t}\n\tif ((dst_comm_init(state)) < 0) {\n\t\tpr_err(\"DST Initialization Failed.\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(100);\n\tif (dst_get_device_id(state) < 0) {\n\t\tpr_err(\"unknown device.\\n\");\n\t\treturn -1;\n\t}\n\tif (dst_get_mac(state) < 0) {\n\t\tdprintk(2, \"MAC: Unsupported command\\n\");\n\t}\n\tif ((state->type_flags & DST_TYPE_HAS_MULTI_FE) || (state->type_flags & DST_TYPE_HAS_FW_BUILD)) {\n\t\tif (dst_get_tuner_info(state) < 0)\n\t\t\tdprintk(2, \"Tuner: Unsupported command\\n\");\n\t}\n\tif (state->type_flags & DST_TYPE_HAS_TS204) {\n\t\tdst_packsize(state, 204);\n\t}\n\tif (state->type_flags & DST_TYPE_HAS_FW_BUILD) {\n\t\tif (dst_fw_ver(state) < 0) {\n\t\t\tdprintk(2, \"FW: Unsupported command\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (dst_card_type(state) < 0) {\n\t\t\tdprintk(2, \"Card: Unsupported command\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (dst_get_vendor(state) < 0) {\n\t\t\tdprintk(2, \"Vendor: Unsupported command\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_command(struct dst_state *state, u8 *data, u8 len)\n{\n\tu8 reply;\n\n\tmutex_lock(&state->dst_mutex);\n\tif ((dst_comm_init(state)) < 0) {\n\t\tdprintk(1, \"DST Communication Initialization Failed.\\n\");\n\t\tgoto error;\n\t}\n\tif (write_dst(state, data, len)) {\n\t\tdprintk(2, \"Trying to recover..\\n\");\n\t\tif ((dst_error_recovery(state)) < 0) {\n\t\t\tpr_err(\"Recovery Failed.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tgoto error;\n\t}\n\tif ((dst_pio_disable(state)) < 0) {\n\t\tpr_err(\"PIO Disable Failed.\\n\");\n\t\tgoto error;\n\t}\n\tif (state->type_flags & DST_TYPE_HAS_FW_1)\n\t\tmdelay(3);\n\tif (read_dst(state, &reply, GET_ACK)) {\n\t\tdprintk(3, \"Trying to recover..\\n\");\n\t\tif ((dst_error_recovery(state)) < 0) {\n\t\t\tdprintk(2, \"Recovery Failed.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tgoto error;\n\t}\n\tif (reply != ACK) {\n\t\tdprintk(2, \"write not acknowledged 0x%02x\\n\", reply);\n\t\tgoto error;\n\t}\n\tif (len >= 2 && data[0] == 0 && (data[1] == 1 || data[1] == 3))\n\t\tgoto error;\n\tif (state->type_flags & DST_TYPE_HAS_FW_1)\n\t\tmdelay(3);\n\telse\n\t\tudelay(2000);\n\tif (!dst_wait_dst_ready(state, NO_DELAY))\n\t\tgoto error;\n\tif (read_dst(state, state->rxbuffer, FIXED_COMM)) {\n\t\tdprintk(3, \"Trying to recover..\\n\");\n\t\tif ((dst_error_recovery(state)) < 0) {\n\t\t\tdprintk(2, \"Recovery failed.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tgoto error;\n\t}\n\tif (state->rxbuffer[7] != dst_check_sum(state->rxbuffer, 7)) {\n\t\tdprintk(2, \"checksum failure\\n\");\n\t\tgoto error;\n\t}\n\tmutex_unlock(&state->dst_mutex);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&state->dst_mutex);\n\treturn -EIO;\n\n}\n\nstatic int dst_get_signal(struct dst_state *state)\n{\n\tint retval;\n\tu8 get_signal[] = { 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb };\n\t \n\tif ((state->diseq_flags & ATTEMPT_TUNE) == 0) {\n\t\tstate->decode_lock = state->decode_strength = state->decode_snr = 0;\n\t\treturn 0;\n\t}\n\tif (0 == (state->diseq_flags & HAS_LOCK)) {\n\t\tstate->decode_lock = state->decode_strength = state->decode_snr = 0;\n\t\treturn 0;\n\t}\n\tif (time_after_eq(jiffies, state->cur_jiff + (HZ / 5))) {\n\t\tretval = dst_command(state, get_signal, 8);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\t\tstate->decode_lock = ((state->rxbuffer[6] & 0x10) == 0) ? 1 : 0;\n\t\t\tstate->decode_strength = state->rxbuffer[5] << 8;\n\t\t\tstate->decode_snr = state->rxbuffer[2] << 8 | state->rxbuffer[3];\n\t\t} else if ((state->dst_type == DST_TYPE_IS_TERR) || (state->dst_type == DST_TYPE_IS_CABLE)) {\n\t\t\tstate->decode_lock = (state->rxbuffer[1]) ? 1 : 0;\n\t\t\tstate->decode_strength = state->rxbuffer[4] << 8;\n\t\t\tstate->decode_snr = state->rxbuffer[3] << 8;\n\t\t} else if (state->dst_type == DST_TYPE_IS_ATSC) {\n\t\t\tstate->decode_lock = (state->rxbuffer[6] == 0x00) ? 1 : 0;\n\t\t\tstate->decode_strength = state->rxbuffer[4] << 8;\n\t\t\tstate->decode_snr = state->rxbuffer[2] << 8 | state->rxbuffer[3];\n\t\t}\n\t\tstate->cur_jiff = jiffies;\n\t}\n\treturn 0;\n}\n\nstatic int dst_tone_power_cmd(struct dst_state *state)\n{\n\tu8 packet[8] = { 0x00, 0x09, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00 };\n\n\tif (state->dst_type != DST_TYPE_IS_SAT)\n\t\treturn -EOPNOTSUPP;\n\tpacket[4] = state->tx_tuna[4];\n\tpacket[2] = state->tx_tuna[2];\n\tpacket[3] = state->tx_tuna[3];\n\tpacket[7] = dst_check_sum (packet, 7);\n\treturn dst_command(state, packet, 8);\n}\n\nstatic int dst_get_tuna(struct dst_state *state)\n{\n\tint retval;\n\n\tif ((state->diseq_flags & ATTEMPT_TUNE) == 0)\n\t\treturn 0;\n\tstate->diseq_flags &= ~(HAS_LOCK);\n\tif (!dst_wait_dst_ready(state, NO_DELAY))\n\t\treturn -EIO;\n\tif ((state->type_flags & DST_TYPE_HAS_VLF) &&\n\t\t!(state->dst_type == DST_TYPE_IS_ATSC))\n\n\t\tretval = read_dst(state, state->rx_tuna, 10);\n\telse\n\t\tretval = read_dst(state, &state->rx_tuna[2], FIXED_COMM);\n\tif (retval < 0) {\n\t\tdprintk(3, \"read not successful\\n\");\n\t\treturn retval;\n\t}\n\tif ((state->type_flags & DST_TYPE_HAS_VLF) &&\n\t   !(state->dst_type == DST_TYPE_IS_ATSC)) {\n\n\t\tif (state->rx_tuna[9] != dst_check_sum(&state->rx_tuna[0], 9)) {\n\t\t\tdprintk(2, \"checksum failure ?\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tif (state->rx_tuna[9] != dst_check_sum(&state->rx_tuna[2], 7)) {\n\t\t\tdprintk(2, \"checksum failure?\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tif (state->rx_tuna[2] == 0 && state->rx_tuna[3] == 0)\n\t\treturn 0;\n\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\tstate->decode_freq = ((state->rx_tuna[2] & 0x7f) << 8) + state->rx_tuna[3];\n\t} else {\n\t\tstate->decode_freq = ((state->rx_tuna[2] & 0x7f) << 16) + (state->rx_tuna[3] << 8) + state->rx_tuna[4];\n\t}\n\tstate->decode_freq = state->decode_freq * 1000;\n\tstate->decode_lock = 1;\n\tstate->diseq_flags |= HAS_LOCK;\n\n\treturn 1;\n}\n\nstatic int dst_set_voltage(struct dvb_frontend *fe,\n\t\t\t   enum fe_sec_voltage voltage);\n\nstatic int dst_write_tuna(struct dvb_frontend *fe)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\tint retval;\n\tu8 reply;\n\n\tdprintk(2, \"type_flags 0x%x\\n\", state->type_flags);\n\tstate->decode_freq = 0;\n\tstate->decode_lock = state->decode_strength = state->decode_snr = 0;\n\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\tif (!(state->diseq_flags & HAS_POWER))\n\t\t\tdst_set_voltage(fe, SEC_VOLTAGE_13);\n\t}\n\tstate->diseq_flags &= ~(HAS_LOCK | ATTEMPT_TUNE);\n\tmutex_lock(&state->dst_mutex);\n\tif ((dst_comm_init(state)) < 0) {\n\t\tdprintk(3, \"DST Communication initialization failed.\\n\");\n\t\tgoto error;\n\t}\n \n\tif ((state->type_flags & DST_TYPE_HAS_VLF) &&\n\t\t(!(state->dst_type == DST_TYPE_IS_ATSC))) {\n\n\t\tstate->tx_tuna[9] = dst_check_sum(&state->tx_tuna[0], 9);\n\t\tretval = write_dst(state, &state->tx_tuna[0], 10);\n\t} else {\n\t\tstate->tx_tuna[9] = dst_check_sum(&state->tx_tuna[2], 7);\n\t\tretval = write_dst(state, &state->tx_tuna[2], FIXED_COMM);\n\t}\n\tif (retval < 0) {\n\t\tdst_pio_disable(state);\n\t\tdprintk(3, \"write not successful\\n\");\n\t\tgoto werr;\n\t}\n\tif ((dst_pio_disable(state)) < 0) {\n\t\tdprintk(3, \"DST PIO disable failed !\\n\");\n\t\tgoto error;\n\t}\n\tif ((read_dst(state, &reply, GET_ACK) < 0)) {\n\t\tdprintk(3, \"read verify not successful.\\n\");\n\t\tgoto error;\n\t}\n\tif (reply != ACK) {\n\t\tdprintk(3, \"write not acknowledged 0x%02x\\n\", reply);\n\t\tgoto error;\n\t}\n\tstate->diseq_flags |= ATTEMPT_TUNE;\n\tretval = dst_get_tuna(state);\nwerr:\n\tmutex_unlock(&state->dst_mutex);\n\treturn retval;\n\nerror:\n\tmutex_unlock(&state->dst_mutex);\n\treturn -EIO;\n}\n\n \n\nstatic int dst_set_diseqc(struct dvb_frontend *fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\tu8 packet[8] = { 0x00, 0x08, 0x04, 0xe0, 0x10, 0x38, 0xf0, 0xec };\n\n\tif (state->dst_type != DST_TYPE_IS_SAT)\n\t\treturn -EOPNOTSUPP;\n\tif (cmd->msg_len > 0 && cmd->msg_len < 5)\n\t\tmemcpy(&packet[3], cmd->msg, cmd->msg_len);\n\telse if (cmd->msg_len == 5 && state->dst_hw_cap & DST_TYPE_HAS_DISEQC5)\n\t\tmemcpy(&packet[2], cmd->msg, cmd->msg_len);\n\telse\n\t\treturn -EINVAL;\n\tpacket[7] = dst_check_sum(&packet[0], 7);\n\treturn dst_command(state, packet, 8);\n}\n\nstatic int dst_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage voltage)\n{\n\tint need_cmd, retval = 0;\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tstate->voltage = voltage;\n\tif (state->dst_type != DST_TYPE_IS_SAT)\n\t\treturn -EOPNOTSUPP;\n\n\tneed_cmd = 0;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\tcase SEC_VOLTAGE_18:\n\t\tif ((state->diseq_flags & HAS_POWER) == 0)\n\t\t\tneed_cmd = 1;\n\t\tstate->diseq_flags |= HAS_POWER;\n\t\tstate->tx_tuna[4] = 0x01;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tneed_cmd = 1;\n\t\tstate->diseq_flags &= ~(HAS_POWER | HAS_LOCK | ATTEMPT_TUNE);\n\t\tstate->tx_tuna[4] = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (need_cmd)\n\t\tretval = dst_tone_power_cmd(state);\n\n\treturn retval;\n}\n\nstatic int dst_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tstate->tone = tone;\n\tif (state->dst_type != DST_TYPE_IS_SAT)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (tone) {\n\tcase SEC_TONE_OFF:\n\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\n\t\t    state->tx_tuna[2] = 0x00;\n\t\telse\n\t\t    state->tx_tuna[2] = 0xff;\n\t\tbreak;\n\n\tcase SEC_TONE_ON:\n\t\tstate->tx_tuna[2] = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn dst_tone_power_cmd(state);\n}\n\nstatic int dst_send_burst(struct dvb_frontend *fe, enum fe_sec_mini_cmd minicmd)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tif (state->dst_type != DST_TYPE_IS_SAT)\n\t\treturn -EOPNOTSUPP;\n\tstate->minicmd = minicmd;\n\tswitch (minicmd) {\n\tcase SEC_MINI_A:\n\t\tstate->tx_tuna[3] = 0x02;\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\tstate->tx_tuna[3] = 0xff;\n\t\tbreak;\n\t}\n\treturn dst_tone_power_cmd(state);\n}\n\n\nstatic int bt8xx_dst_init(struct dvb_frontend *fe)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tstatic u8 sat_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x00, 0x73, 0x21, 0x00, 0x00 };\n\tstatic u8 sat_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x55, 0xbd, 0x50, 0x00, 0x00 };\n\tstatic u8 ter_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\n\tstatic u8 ter_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\n\tstatic u8 cab_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\n\tstatic u8 cab_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\n\tstatic u8 atsc_tuner[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\n\n\tstate->inversion = INVERSION_OFF;\n\tstate->voltage = SEC_VOLTAGE_13;\n\tstate->tone = SEC_TONE_OFF;\n\tstate->diseq_flags = 0;\n\tstate->k22 = 0x02;\n\tstate->bandwidth = 7000000;\n\tstate->cur_jiff = jiffies;\n\tif (state->dst_type == DST_TYPE_IS_SAT)\n\t\tmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? sat_tuna_188 : sat_tuna_204), sizeof (sat_tuna_204));\n\telse if (state->dst_type == DST_TYPE_IS_TERR)\n\t\tmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? ter_tuna_188 : ter_tuna_204), sizeof (ter_tuna_204));\n\telse if (state->dst_type == DST_TYPE_IS_CABLE)\n\t\tmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? cab_tuna_188 : cab_tuna_204), sizeof (cab_tuna_204));\n\telse if (state->dst_type == DST_TYPE_IS_ATSC)\n\t\tmemcpy(state->tx_tuna, atsc_tuner, sizeof (atsc_tuner));\n\n\treturn 0;\n}\n\nstatic int dst_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\t*status = 0;\n\tif (state->diseq_flags & HAS_LOCK) {\n \n\t\tif (state->decode_lock)\n\t\t\t*status |= FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC | FE_HAS_VITERBI;\n\t}\n\n\treturn 0;\n}\n\nstatic int dst_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tint retval = dst_get_signal(state);\n\t*strength = state->decode_strength;\n\n\treturn retval;\n}\n\nstatic int dst_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tint retval = dst_get_signal(state);\n\t*snr = state->decode_snr;\n\n\treturn retval;\n}\n\nstatic int dst_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tint retval = -EINVAL;\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tif (p != NULL) {\n\t\tretval = dst_set_freq(state, p->frequency);\n\t\tif(retval != 0)\n\t\t\treturn retval;\n\t\tdprintk(3, \"Set Frequency=[%d]\\n\", p->frequency);\n\n\t\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\n\t\t\t\tdst_set_inversion(state, p->inversion);\n\t\t\tdst_set_fec(state, p->fec_inner);\n\t\t\tdst_set_symbolrate(state, p->symbol_rate);\n\t\t\tdst_set_polarization(state);\n\t\t\tdprintk(3, \"Set Symbolrate=[%d]\\n\", p->symbol_rate);\n\n\t\t} else if (state->dst_type == DST_TYPE_IS_TERR)\n\t\t\tdst_set_bandwidth(state, p->bandwidth_hz);\n\t\telse if (state->dst_type == DST_TYPE_IS_CABLE) {\n\t\t\tdst_set_fec(state, p->fec_inner);\n\t\t\tdst_set_symbolrate(state, p->symbol_rate);\n\t\t\tdst_set_modulation(state, p->modulation);\n\t\t}\n\t\tretval = dst_write_tuna(fe);\n\t}\n\n\treturn retval;\n}\n\nstatic int dst_tune_frontend(struct dvb_frontend* fe,\n\t\t\t    bool re_tune,\n\t\t\t    unsigned int mode_flags,\n\t\t\t    unsigned int *delay,\n\t\t\t    enum fe_status *status)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tif (re_tune) {\n\t\tdst_set_freq(state, p->frequency);\n\t\tdprintk(3, \"Set Frequency=[%d]\\n\", p->frequency);\n\n\t\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\n\t\t\t\tdst_set_inversion(state, p->inversion);\n\t\t\tdst_set_fec(state, p->fec_inner);\n\t\t\tdst_set_symbolrate(state, p->symbol_rate);\n\t\t\tdst_set_polarization(state);\n\t\t\tdprintk(3, \"Set Symbolrate=[%d]\\n\", p->symbol_rate);\n\n\t\t} else if (state->dst_type == DST_TYPE_IS_TERR)\n\t\t\tdst_set_bandwidth(state, p->bandwidth_hz);\n\t\telse if (state->dst_type == DST_TYPE_IS_CABLE) {\n\t\t\tdst_set_fec(state, p->fec_inner);\n\t\t\tdst_set_symbolrate(state, p->symbol_rate);\n\t\t\tdst_set_modulation(state, p->modulation);\n\t\t}\n\t\tdst_write_tuna(fe);\n\t}\n\n\tif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\n\t\tdst_read_status(fe, status);\n\n\t*delay = HZ/10;\n\treturn 0;\n}\n\nstatic enum dvbfe_algo dst_get_tuning_algo(struct dvb_frontend *fe)\n{\n\treturn dst_algo ? DVBFE_ALGO_HW : DVBFE_ALGO_SW;\n}\n\nstatic int dst_get_frontend(struct dvb_frontend *fe,\n\t\t\t    struct dtv_frontend_properties *p)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\n\tp->frequency = state->decode_freq;\n\tif (state->dst_type == DST_TYPE_IS_SAT) {\n\t\tif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\n\t\t\tp->inversion = state->inversion;\n\t\tp->symbol_rate = state->symbol_rate;\n\t\tp->fec_inner = dst_get_fec(state);\n\t} else if (state->dst_type == DST_TYPE_IS_TERR) {\n\t\tp->bandwidth_hz = state->bandwidth;\n\t} else if (state->dst_type == DST_TYPE_IS_CABLE) {\n\t\tp->symbol_rate = state->symbol_rate;\n\t\tp->fec_inner = dst_get_fec(state);\n\t\tp->modulation = dst_get_modulation(state);\n\t}\n\n\treturn 0;\n}\n\nstatic void bt8xx_dst_release(struct dvb_frontend *fe)\n{\n\tstruct dst_state *state = fe->demodulator_priv;\n\tif (state->dst_ca) {\n\t\tdvb_unregister_device(state->dst_ca);\n#ifdef CONFIG_MEDIA_ATTACH\n\t\tsymbol_put(dst_ca_attach);\n#endif\n\t}\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops dst_dvbt_ops;\nstatic const struct dvb_frontend_ops dst_dvbs_ops;\nstatic const struct dvb_frontend_ops dst_dvbc_ops;\nstatic const struct dvb_frontend_ops dst_atsc_ops;\n\nstruct dst_state *dst_attach(struct dst_state *state, struct dvb_adapter *dvb_adapter)\n{\n\t \n\tif (dst_probe(state) < 0) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\t \n\t \n\tswitch (state->dst_type) {\n\tcase DST_TYPE_IS_TERR:\n\t\tmemcpy(&state->frontend.ops, &dst_dvbt_ops, sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase DST_TYPE_IS_CABLE:\n\t\tmemcpy(&state->frontend.ops, &dst_dvbc_ops, sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase DST_TYPE_IS_SAT:\n\t\tmemcpy(&state->frontend.ops, &dst_dvbs_ops, sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase DST_TYPE_IS_ATSC:\n\t\tmemcpy(&state->frontend.ops, &dst_atsc_ops, sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown DST type. please report to the LinuxTV.org DVB mailinglist.\\n\");\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\tstate->frontend.demodulator_priv = state;\n\n\treturn state;\t\t\t\t \n}\n\nEXPORT_SYMBOL_GPL(dst_attach);\n\nstatic const struct dvb_frontend_ops dst_dvbt_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"DST DVB-T\",\n\t\t.frequency_min_hz = 137 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 166667,\n\t\t.caps = FE_CAN_FEC_AUTO\t\t\t|\n\t\t\tFE_CAN_QAM_AUTO\t\t\t|\n\t\t\tFE_CAN_QAM_16\t\t\t|\n\t\t\tFE_CAN_QAM_32\t\t\t|\n\t\t\tFE_CAN_QAM_64\t\t\t|\n\t\t\tFE_CAN_QAM_128\t\t\t|\n\t\t\tFE_CAN_QAM_256\t\t\t|\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO\t|\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO\n\t},\n\n\t.release = bt8xx_dst_release,\n\t.init = bt8xx_dst_init,\n\t.tune = dst_tune_frontend,\n\t.set_frontend = dst_set_frontend,\n\t.get_frontend = dst_get_frontend,\n\t.get_frontend_algo = dst_get_tuning_algo,\n\t.read_status = dst_read_status,\n\t.read_signal_strength = dst_read_signal_strength,\n\t.read_snr = dst_read_snr,\n};\n\nstatic const struct dvb_frontend_ops dst_dvbs_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name = \"DST DVB-S\",\n\t\t.frequency_min_hz   =  950 * MHz,\n\t\t.frequency_max_hz   = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1 * MHz,\n\t\t.frequency_tolerance_hz = 29500 * kHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t \n\t\t.caps = FE_CAN_FEC_AUTO | FE_CAN_QPSK\n\t},\n\n\t.release = bt8xx_dst_release,\n\t.init = bt8xx_dst_init,\n\t.tune = dst_tune_frontend,\n\t.set_frontend = dst_set_frontend,\n\t.get_frontend = dst_get_frontend,\n\t.get_frontend_algo = dst_get_tuning_algo,\n\t.read_status = dst_read_status,\n\t.read_signal_strength = dst_read_signal_strength,\n\t.read_snr = dst_read_snr,\n\t.diseqc_send_burst = dst_send_burst,\n\t.diseqc_send_master_cmd = dst_set_diseqc,\n\t.set_voltage = dst_set_voltage,\n\t.set_tone = dst_set_tone,\n};\n\nstatic const struct dvb_frontend_ops dst_dvbc_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t.name = \"DST DVB-C\",\n\t\t.frequency_min_hz =  51 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_QAM_16\t|\n\t\t\tFE_CAN_QAM_32\t|\n\t\t\tFE_CAN_QAM_64\t|\n\t\t\tFE_CAN_QAM_128\t|\n\t\t\tFE_CAN_QAM_256\n\t},\n\n\t.release = bt8xx_dst_release,\n\t.init = bt8xx_dst_init,\n\t.tune = dst_tune_frontend,\n\t.set_frontend = dst_set_frontend,\n\t.get_frontend = dst_get_frontend,\n\t.get_frontend_algo = dst_get_tuning_algo,\n\t.read_status = dst_read_status,\n\t.read_signal_strength = dst_read_signal_strength,\n\t.read_snr = dst_read_snr,\n};\n\nstatic const struct dvb_frontend_ops dst_atsc_ops = {\n\t.delsys = { SYS_ATSC },\n\t.info = {\n\t\t.name = \"DST ATSC\",\n\t\t.frequency_min_hz = 510 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_FEC_AUTO | FE_CAN_QAM_AUTO | FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\n\t.release = bt8xx_dst_release,\n\t.init = bt8xx_dst_init,\n\t.tune = dst_tune_frontend,\n\t.set_frontend = dst_set_frontend,\n\t.get_frontend = dst_get_frontend,\n\t.get_frontend_algo = dst_get_tuning_algo,\n\t.read_status = dst_read_status,\n\t.read_signal_strength = dst_read_signal_strength,\n\t.read_snr = dst_read_snr,\n};\n\nMODULE_DESCRIPTION(\"DST DVB-S/T/C/ATSC Combo Frontend driver\");\nMODULE_AUTHOR(\"Jamie Honan, Manu Abraham\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}