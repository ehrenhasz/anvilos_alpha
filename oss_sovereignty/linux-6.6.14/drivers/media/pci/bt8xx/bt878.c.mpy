{
  "module_name": "bt878.c",
  "hash_id": "16aa27e812907ea72ccbc3e768de4cc3c207ebe88a8eaedb6bf083864629f113",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bt878.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pgtable.h>\n#include <asm/io.h>\n#include <linux/ioport.h>\n#include <asm/page.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/kmod.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include \"bt878.h\"\n#include \"dst_priv.h\"\n\n\n \n \n \n\nstatic unsigned int bt878_verbose = 1;\nstatic unsigned int bt878_debug;\n\nmodule_param_named(verbose, bt878_verbose, int, 0444);\nMODULE_PARM_DESC(verbose,\n\t\t \"verbose startup messages, default is 1 (yes)\");\nmodule_param_named(debug, bt878_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging, default is 0 (off).\");\n\nint bt878_num;\nstruct bt878 bt878[BT878_MAX];\n\nEXPORT_SYMBOL(bt878_num);\nEXPORT_SYMBOL(bt878);\n\n#define btwrite(dat,adr)    bmtwrite((dat), (bt->bt878_mem+(adr)))\n#define btread(adr)         bmtread(bt->bt878_mem+(adr))\n\n#define btand(dat,adr)      btwrite((dat) & btread(adr), adr)\n#define btor(dat,adr)       btwrite((dat) | btread(adr), adr)\n#define btaor(dat,mask,adr) btwrite((dat) | ((mask) & btread(adr)), adr)\n\n#if defined(dprintk)\n#undef dprintk\n#endif\n#define dprintk(fmt, arg...) \\\n\tdo { \\\n\t\tif (bt878_debug) \\\n\t\t\tprintk(KERN_DEBUG fmt, ##arg); \\\n\t} while (0)\n\nstatic void bt878_mem_free(struct bt878 *bt)\n{\n\tif (bt->buf_cpu) {\n\t\tdma_free_coherent(&bt->dev->dev, bt->buf_size, bt->buf_cpu,\n\t\t\t\t  bt->buf_dma);\n\t\tbt->buf_cpu = NULL;\n\t}\n\n\tif (bt->risc_cpu) {\n\t\tdma_free_coherent(&bt->dev->dev, bt->risc_size, bt->risc_cpu,\n\t\t\t\t  bt->risc_dma);\n\t\tbt->risc_cpu = NULL;\n\t}\n}\n\nstatic int bt878_mem_alloc(struct bt878 *bt)\n{\n\tif (!bt->buf_cpu) {\n\t\tbt->buf_size = 128 * 1024;\n\n\t\tbt->buf_cpu = dma_alloc_coherent(&bt->dev->dev, bt->buf_size,\n\t\t\t\t\t\t &bt->buf_dma, GFP_KERNEL);\n\t\tif (!bt->buf_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bt->risc_cpu) {\n\t\tbt->risc_size = PAGE_SIZE;\n\t\tbt->risc_cpu = dma_alloc_coherent(&bt->dev->dev, bt->risc_size,\n\t\t\t\t\t\t  &bt->risc_dma, GFP_KERNEL);\n\t\tif (!bt->risc_cpu) {\n\t\t\tbt878_mem_free(bt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define RISC_WRITE\t\t(0x01 << 28)\n#define RISC_JUMP\t\t(0x07 << 28)\n#define RISC_SYNC\t\t(0x08 << 28)\n\n \n#define RISC_WR_SOL\t\t(1 << 27)\n#define RISC_WR_EOL\t\t(1 << 26)\n#define RISC_IRQ\t\t(1 << 24)\n#define RISC_STATUS(status)\t((((~status) & 0x0F) << 20) | ((status & 0x0F) << 16))\n#define RISC_SYNC_RESYNC\t(1 << 15)\n#define RISC_SYNC_FM1\t\t0x06\n#define RISC_SYNC_VRO\t\t0x0C\n\n#define RISC_FLUSH()\t\tbt->risc_pos = 0\n#define RISC_INSTR(instr)\tbt->risc_cpu[bt->risc_pos++] = cpu_to_le32(instr)\n\nstatic int bt878_make_risc(struct bt878 *bt)\n{\n\tbt->block_bytes = bt->buf_size >> 4;\n\tbt->block_count = 1 << 4;\n\tbt->line_bytes = bt->block_bytes;\n\tbt->line_count = bt->block_count;\n\n\twhile (bt->line_bytes > 4095) {\n\t\tbt->line_bytes >>= 1;\n\t\tbt->line_count <<= 1;\n\t}\n\n\tif (bt->line_count > 255) {\n\t\tprintk(KERN_ERR \"bt878: buffer size error!\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic void bt878_risc_program(struct bt878 *bt, u32 op_sync_orin)\n{\n\tu32 buf_pos = 0;\n\tu32 line;\n\n\tRISC_FLUSH();\n\tRISC_INSTR(RISC_SYNC | RISC_SYNC_FM1 | op_sync_orin);\n\tRISC_INSTR(0);\n\n\tdprintk(\"bt878: risc len lines %u, bytes per line %u\\n\",\n\t\t\tbt->line_count, bt->line_bytes);\n\tfor (line = 0; line < bt->line_count; line++) {\n\t\t\n\t\tif (!(buf_pos % bt->block_bytes))\n\t\t\tRISC_INSTR(RISC_WRITE | RISC_WR_SOL | RISC_WR_EOL |\n\t\t\t\t   RISC_IRQ |\n\t\t\t\t   RISC_STATUS(((buf_pos /\n\t\t\t\t\t\t bt->block_bytes) +\n\t\t\t\t\t\t(bt->block_count -\n\t\t\t\t\t\t 1)) %\n\t\t\t\t\t       bt->block_count) | bt->\n\t\t\t\t   line_bytes);\n\t\telse\n\t\t\tRISC_INSTR(RISC_WRITE | RISC_WR_SOL | RISC_WR_EOL |\n\t\t\t\t   bt->line_bytes);\n\t\tRISC_INSTR(bt->buf_dma + buf_pos);\n\t\tbuf_pos += bt->line_bytes;\n\t}\n\n\tRISC_INSTR(RISC_SYNC | op_sync_orin | RISC_SYNC_VRO);\n\tRISC_INSTR(0);\n\n\tRISC_INSTR(RISC_JUMP);\n\tRISC_INSTR(bt->risc_dma);\n\n\tbtwrite((bt->line_count << 16) | bt->line_bytes, BT878_APACK_LEN);\n}\n\n \n \n \n\nvoid bt878_start(struct bt878 *bt, u32 controlreg, u32 op_sync_orin,\n\t\tu32 irq_err_ignore)\n{\n\tu32 int_mask;\n\n\tdprintk(\"bt878 debug: bt878_start (ctl=%8.8x)\\n\", controlreg);\n\t \n\tbt878_risc_program(bt, op_sync_orin);\n\tcontrolreg &= ~0x1f;\n\tcontrolreg |= 0x1b;\n\n\tbtwrite(bt->risc_dma, BT878_ARISC_START);\n\n\t \n\tint_mask = BT878_ASCERR | BT878_AOCERR | BT878_APABORT |\n\t\tBT878_ARIPERR | BT878_APPERR | BT878_AFDSR | BT878_AFTRGT |\n\t\tBT878_AFBUS | BT878_ARISCI;\n\n\n\t \n\tint_mask &= ~irq_err_ignore;\n\n\tbtwrite(int_mask, BT878_AINT_MASK);\n\tbtwrite(controlreg, BT878_AGPIO_DMA_CTL);\n}\n\nvoid bt878_stop(struct bt878 *bt)\n{\n\tu32 stat;\n\tint i = 0;\n\n\tdprintk(\"bt878 debug: bt878_stop\\n\");\n\n\tbtwrite(0, BT878_AINT_MASK);\n\tbtand(~0x13, BT878_AGPIO_DMA_CTL);\n\n\tdo {\n\t\tstat = btread(BT878_AINT_STAT);\n\t\tif (!(stat & BT878_ARISC_EN))\n\t\t\tbreak;\n\t\ti++;\n\t} while (i < 500);\n\n\tdprintk(\"bt878(%d) debug: bt878_stop, i=%d, stat=0x%8.8x\\n\",\n\t\tbt->nr, i, stat);\n}\n\nEXPORT_SYMBOL(bt878_start);\nEXPORT_SYMBOL(bt878_stop);\n\n \n \n \n\nstatic irqreturn_t bt878_irq(int irq, void *dev_id)\n{\n\tu32 stat, astat, mask;\n\tint count;\n\tstruct bt878 *bt;\n\n\tbt = (struct bt878 *) dev_id;\n\n\tcount = 0;\n\twhile (1) {\n\t\tstat = btread(BT878_AINT_STAT);\n\t\tmask = btread(BT878_AINT_MASK);\n\t\tif (!(astat = (stat & mask)))\n\t\t\treturn IRQ_NONE;\t \n \n\t\tbtwrite(astat, BT878_AINT_STAT);\t \n\n\n\t\tif (astat & (BT878_ASCERR | BT878_AOCERR)) {\n\t\t\tif (bt878_verbose) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"bt878(%d): irq%s%s risc_pc=%08x\\n\",\n\t\t\t\t       bt->nr,\n\t\t\t\t       (astat & BT878_ASCERR) ? \" SCERR\" :\n\t\t\t\t       \"\",\n\t\t\t\t       (astat & BT878_AOCERR) ? \" OCERR\" :\n\t\t\t\t       \"\", btread(BT878_ARISC_PC));\n\t\t\t}\n\t\t}\n\t\tif (astat & (BT878_APABORT | BT878_ARIPERR | BT878_APPERR)) {\n\t\t\tif (bt878_verbose) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t     \"bt878(%d): irq%s%s%s risc_pc=%08x\\n\",\n\t\t\t\t     bt->nr,\n\t\t\t\t     (astat & BT878_APABORT) ? \" PABORT\" :\n\t\t\t\t     \"\",\n\t\t\t\t     (astat & BT878_ARIPERR) ? \" RIPERR\" :\n\t\t\t\t     \"\",\n\t\t\t\t     (astat & BT878_APPERR) ? \" PPERR\" :\n\t\t\t\t     \"\", btread(BT878_ARISC_PC));\n\t\t\t}\n\t\t}\n\t\tif (astat & (BT878_AFDSR | BT878_AFTRGT | BT878_AFBUS)) {\n\t\t\tif (bt878_verbose) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t     \"bt878(%d): irq%s%s%s risc_pc=%08x\\n\",\n\t\t\t\t     bt->nr,\n\t\t\t\t     (astat & BT878_AFDSR) ? \" FDSR\" : \"\",\n\t\t\t\t     (astat & BT878_AFTRGT) ? \" FTRGT\" :\n\t\t\t\t     \"\",\n\t\t\t\t     (astat & BT878_AFBUS) ? \" FBUS\" : \"\",\n\t\t\t\t     btread(BT878_ARISC_PC));\n\t\t\t}\n\t\t}\n\t\tif (astat & BT878_ARISCI) {\n\t\t\tbt->finished_block = (stat & BT878_ARISCS) >> 28;\n\t\t\tif (bt->tasklet.callback)\n\t\t\t\ttasklet_schedule(&bt->tasklet);\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tif (count > 20) {\n\t\t\tbtwrite(0, BT878_AINT_MASK);\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"bt878(%d): IRQ lockup, cleared int mask\\n\",\n\t\t\t       bt->nr);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nint\nbt878_device_control(struct bt878 *bt, unsigned int cmd, union dst_gpio_packet *mp)\n{\n\tint retval;\n\n\tretval = 0;\n\tif (mutex_lock_interruptible(&bt->gpio_lock))\n\t\treturn -ERESTARTSYS;\n\t \n\tswitch (cmd) {\n\t    case DST_IG_ENABLE:\n\t\t\n\t\tretval = bttv_gpio_enable(bt->bttv_nr,\n\t\t\t\tmp->enb.mask,\n\t\t\t\tmp->enb.enable);\n\t\tbreak;\n\t    case DST_IG_WRITE:\n\t\t\n\t\tretval = bttv_write_gpio(bt->bttv_nr,\n\t\t\t\tmp->outp.mask,\n\t\t\t\tmp->outp.highvals);\n\n\t\tbreak;\n\t    case DST_IG_READ:\n\t\t \n\t\tretval =  bttv_read_gpio(bt->bttv_nr, &mp->rd.value);\n\t\t\n\t\tbreak;\n\t    case DST_IG_TS:\n\t\t \n\t\tbt->TS_Size = mp->psize;\n\t\tbreak;\n\n\t    default:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&bt->gpio_lock);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(bt878_device_control);\n\n#define BROOKTREE_878_DEVICE(vend, dev, name) \\\n\t{ \\\n\t\t.vendor = PCI_VENDOR_ID_BROOKTREE, \\\n\t\t.device = PCI_DEVICE_ID_BROOKTREE_878, \\\n\t\t.subvendor = (vend), .subdevice = (dev), \\\n\t\t.driver_data = (unsigned long) name \\\n\t}\n\nstatic const struct pci_device_id bt878_pci_tbl[] = {\n\tBROOKTREE_878_DEVICE(0x0071, 0x0101, \"Nebula Electronics DigiTV\"),\n\tBROOKTREE_878_DEVICE(0x1461, 0x0761, \"AverMedia AverTV DVB-T 761\"),\n\tBROOKTREE_878_DEVICE(0x11bd, 0x001c, \"Pinnacle PCTV Sat\"),\n\tBROOKTREE_878_DEVICE(0x11bd, 0x0026, \"Pinnacle PCTV SAT CI\"),\n\tBROOKTREE_878_DEVICE(0x1822, 0x0001, \"Twinhan VisionPlus DVB\"),\n\tBROOKTREE_878_DEVICE(0x270f, 0xfc00,\n\t\t\t\t\"ChainTech digitop DST-1000 DVB-S\"),\n\tBROOKTREE_878_DEVICE(0x1461, 0x0771, \"AVermedia AverTV DVB-T 771\"),\n\tBROOKTREE_878_DEVICE(0x18ac, 0xdb10, \"DViCO FusionHDTV DVB-T Lite\"),\n\tBROOKTREE_878_DEVICE(0x18ac, 0xdb11, \"Ultraview DVB-T Lite\"),\n\tBROOKTREE_878_DEVICE(0x18ac, 0xd500, \"DViCO FusionHDTV 5 Lite\"),\n\tBROOKTREE_878_DEVICE(0x7063, 0x2000, \"pcHDTV HD-2000 TV\"),\n\tBROOKTREE_878_DEVICE(0x1822, 0x0026, \"DNTV Live! Mini\"),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, bt878_pci_tbl);\n\nstatic const char * card_name(const struct pci_device_id *id)\n{\n\treturn id->driver_data ? (const char *)id->driver_data : \"Unknown\";\n}\n\n \n \n \n\nstatic int bt878_probe(struct pci_dev *dev, const struct pci_device_id *pci_id)\n{\n\tint result = 0;\n\tunsigned char lat;\n\tstruct bt878 *bt;\n\tunsigned int cardid;\n\n\tprintk(KERN_INFO \"bt878: Bt878 AUDIO function found (%d).\\n\",\n\t       bt878_num);\n\tif (bt878_num >= BT878_MAX) {\n\t\tprintk(KERN_ERR \"bt878: Too many devices inserted\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (pci_enable_device(dev))\n\t\treturn -EIO;\n\n\tcardid = dev->subsystem_device << 16;\n\tcardid |= dev->subsystem_vendor;\n\n\tprintk(KERN_INFO \"%s: card id=[0x%x],[ %s ] has DVB functions.\\n\",\n\t\t\t\t__func__, cardid, card_name(pci_id));\n\n\tbt = &bt878[bt878_num];\n\tbt->dev = dev;\n\tbt->nr = bt878_num;\n\tbt->shutdown = 0;\n\n\tbt->id = dev->device;\n\tbt->irq = dev->irq;\n\tbt->bt878_adr = pci_resource_start(dev, 0);\n\tif (!request_mem_region(pci_resource_start(dev, 0),\n\t\t\t\tpci_resource_len(dev, 0), \"bt878\")) {\n\t\tresult = -EBUSY;\n\t\tgoto fail0;\n\t}\n\n\tbt->revision = dev->revision;\n\tpci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\n\n\n\tprintk(KERN_INFO \"bt878(%d): Bt%x (rev %d) at %02x:%02x.%x, \",\n\t       bt878_num, bt->id, bt->revision, dev->bus->number,\n\t       PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));\n\tprintk(\"irq: %d, latency: %d, memory: 0x%lx\\n\",\n\t       bt->irq, lat, bt->bt878_adr);\n\n#ifdef __sparc__\n\tbt->bt878_mem = (unsigned char *) bt->bt878_adr;\n#else\n\tbt->bt878_mem = ioremap(bt->bt878_adr, 0x1000);\n#endif\n\n\t \n\tbtwrite(0, BT848_INT_MASK);\n\n\tresult = request_irq(bt->irq, bt878_irq,\n\t\t\t     IRQF_SHARED, \"bt878\", (void *) bt);\n\tif (result == -EINVAL) {\n\t\tprintk(KERN_ERR \"bt878(%d): Bad irq number or handler\\n\",\n\t\t       bt878_num);\n\t\tgoto fail1;\n\t}\n\tif (result == -EBUSY) {\n\t\tprintk(KERN_ERR\n\t\t       \"bt878(%d): IRQ %d busy, change your PnP config in BIOS\\n\",\n\t\t       bt878_num, bt->irq);\n\t\tgoto fail1;\n\t}\n\tif (result < 0)\n\t\tgoto fail1;\n\n\tpci_set_master(dev);\n\tpci_set_drvdata(dev, bt);\n\n\tif ((result = bt878_mem_alloc(bt))) {\n\t\tprintk(KERN_ERR \"bt878: failed to allocate memory!\\n\");\n\t\tgoto fail2;\n\t}\n\n\tbt878_make_risc(bt);\n\tbtwrite(0, BT878_AINT_MASK);\n\tbt878_num++;\n\n\tif (!bt->tasklet.func)\n\t\ttasklet_disable(&bt->tasklet);\n\n\treturn 0;\n\n      fail2:\n\tfree_irq(bt->irq, bt);\n      fail1:\n\trelease_mem_region(pci_resource_start(bt->dev, 0),\n\t\t\t   pci_resource_len(bt->dev, 0));\n      fail0:\n\tpci_disable_device(dev);\n\treturn result;\n}\n\nstatic void bt878_remove(struct pci_dev *pci_dev)\n{\n\tu8 command;\n\tstruct bt878 *bt = pci_get_drvdata(pci_dev);\n\n\tif (bt878_verbose)\n\t\tprintk(KERN_INFO \"bt878(%d): unloading\\n\", bt->nr);\n\n\t \n\tbtand(~0x13, BT878_AGPIO_DMA_CTL);\n\n\t \n\tbtwrite(0, BT878_AINT_MASK);\n\tbtwrite(~0U, BT878_AINT_STAT);\n\n\t \n\tpci_read_config_byte(bt->dev, PCI_COMMAND, &command);\n\t \n\tcommand &= ~PCI_COMMAND_MASTER;\n\tpci_write_config_byte(bt->dev, PCI_COMMAND, command);\n\n\tfree_irq(bt->irq, bt);\n\tprintk(KERN_DEBUG \"bt878_mem: 0x%p.\\n\", bt->bt878_mem);\n\tif (bt->bt878_mem)\n\t\tiounmap(bt->bt878_mem);\n\n\trelease_mem_region(pci_resource_start(bt->dev, 0),\n\t\t\t   pci_resource_len(bt->dev, 0));\n\t \n\tbt->shutdown = 1;\n\tbt878_mem_free(bt);\n\n\tpci_disable_device(pci_dev);\n\treturn;\n}\n\nstatic struct pci_driver bt878_pci_driver = {\n      .name\t= \"bt878\",\n      .id_table = bt878_pci_tbl,\n      .probe\t= bt878_probe,\n      .remove\t= bt878_remove,\n};\n\n \n \n \n\nstatic int __init bt878_init_module(void)\n{\n\tbt878_num = 0;\n\n\tprintk(KERN_INFO \"bt878: AUDIO driver version %d.%d.%d loaded\\n\",\n\t       (BT878_VERSION_CODE >> 16) & 0xff,\n\t       (BT878_VERSION_CODE >> 8) & 0xff,\n\t       BT878_VERSION_CODE & 0xff);\n\n\treturn pci_register_driver(&bt878_pci_driver);\n}\n\nstatic void __exit bt878_cleanup_module(void)\n{\n\tpci_unregister_driver(&bt878_pci_driver);\n}\n\nmodule_init(bt878_init_module);\nmodule_exit(bt878_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}