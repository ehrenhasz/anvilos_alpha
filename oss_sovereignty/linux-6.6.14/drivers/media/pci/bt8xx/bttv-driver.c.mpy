{
  "module_name": "bttv-driver.c",
  "hash_id": "9eb8a58a4d4112fef4acff3d7b7c3dbcb3e6a0cd0709e0404f67daba982d3e08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-driver.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/kdev_t.h>\n#include \"bttvp.h\"\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/i2c/tvaudio.h>\n#include <media/drv-intf/msp3400.h>\n\n#include <linux/dma-mapping.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <media/i2c/saa6588.h>\n\n#define BTTV_VERSION \"0.9.19\"\n\nunsigned int bttv_num;\t\t\t \nstruct bttv *bttvs[BTTV_MAX];\n\nunsigned int bttv_debug;\nunsigned int bttv_verbose = 1;\nunsigned int bttv_gpio;\n\n \n#ifdef __BIG_ENDIAN\nstatic unsigned int bigendian=1;\n#else\nstatic unsigned int bigendian;\n#endif\nstatic unsigned int radio[BTTV_MAX];\nstatic unsigned int irq_debug;\nstatic unsigned int gbuffers = 8;\nstatic unsigned int gbufsize = 0x208000;\nstatic unsigned int reset_crop = 1;\n\nstatic int video_nr[BTTV_MAX] = { [0 ... (BTTV_MAX-1)] = -1 };\nstatic int radio_nr[BTTV_MAX] = { [0 ... (BTTV_MAX-1)] = -1 };\nstatic int vbi_nr[BTTV_MAX] = { [0 ... (BTTV_MAX-1)] = -1 };\nstatic int debug_latency;\nstatic int disable_ir;\n\nstatic unsigned int fdsr;\n\n \nstatic unsigned int combfilter;\nstatic unsigned int lumafilter;\nstatic unsigned int automute    = 1;\nstatic unsigned int chroma_agc;\nstatic unsigned int agc_crush   = 1;\nstatic unsigned int whitecrush_upper = 0xCF;\nstatic unsigned int whitecrush_lower = 0x7F;\nstatic unsigned int vcr_hack;\nstatic unsigned int irq_iswitch;\nstatic unsigned int uv_ratio    = 50;\nstatic unsigned int full_luma_range;\nstatic unsigned int coring;\n\n \nstatic unsigned int v4l2        = 1;\n\n \nmodule_param(bttv_verbose,      int, 0644);\nmodule_param(bttv_gpio,         int, 0644);\nmodule_param(bttv_debug,        int, 0644);\nmodule_param(irq_debug,         int, 0644);\nmodule_param(debug_latency,     int, 0644);\nmodule_param(disable_ir,        int, 0444);\n\nmodule_param(fdsr,              int, 0444);\nmodule_param(gbuffers,          int, 0444);\nmodule_param(gbufsize,          int, 0444);\nmodule_param(reset_crop,        int, 0444);\n\nmodule_param(v4l2,              int, 0644);\nmodule_param(bigendian,         int, 0644);\nmodule_param(irq_iswitch,       int, 0644);\nmodule_param(combfilter,        int, 0444);\nmodule_param(lumafilter,        int, 0444);\nmodule_param(automute,          int, 0444);\nmodule_param(chroma_agc,        int, 0444);\nmodule_param(agc_crush,         int, 0444);\nmodule_param(whitecrush_upper,  int, 0444);\nmodule_param(whitecrush_lower,  int, 0444);\nmodule_param(vcr_hack,          int, 0444);\nmodule_param(uv_ratio,          int, 0444);\nmodule_param(full_luma_range,   int, 0444);\nmodule_param(coring,            int, 0444);\n\nmodule_param_array(radio,       int, NULL, 0444);\nmodule_param_array(video_nr,    int, NULL, 0444);\nmodule_param_array(radio_nr,    int, NULL, 0444);\nmodule_param_array(vbi_nr,      int, NULL, 0444);\n\nMODULE_PARM_DESC(radio, \"The TV card supports radio, default is 0 (no)\");\nMODULE_PARM_DESC(bigendian, \"byte order of the framebuffer, default is native endian\");\nMODULE_PARM_DESC(bttv_verbose, \"verbose startup messages, default is 1 (yes)\");\nMODULE_PARM_DESC(bttv_gpio, \"log gpio changes, default is 0 (no)\");\nMODULE_PARM_DESC(bttv_debug, \"debug messages, default is 0 (no)\");\nMODULE_PARM_DESC(irq_debug, \"irq handler debug messages, default is 0 (no)\");\nMODULE_PARM_DESC(disable_ir, \"disable infrared remote support\");\nMODULE_PARM_DESC(gbuffers, \"number of capture buffers. range 2-32, default 8\");\nMODULE_PARM_DESC(gbufsize, \"size of the capture buffers, default is 0x208000\");\nMODULE_PARM_DESC(reset_crop, \"reset cropping parameters at open(), default is 1 (yes) for compatibility with older applications\");\nMODULE_PARM_DESC(automute, \"mute audio on bad/missing video signal, default is 1 (yes)\");\nMODULE_PARM_DESC(chroma_agc, \"enables the AGC of chroma signal, default is 0 (no)\");\nMODULE_PARM_DESC(agc_crush, \"enables the luminance AGC crush, default is 1 (yes)\");\nMODULE_PARM_DESC(whitecrush_upper, \"sets the white crush upper value, default is 207\");\nMODULE_PARM_DESC(whitecrush_lower, \"sets the white crush lower value, default is 127\");\nMODULE_PARM_DESC(vcr_hack, \"enables the VCR hack (improves synch on poor VCR tapes), default is 0 (no)\");\nMODULE_PARM_DESC(irq_iswitch, \"switch inputs in irq handler\");\nMODULE_PARM_DESC(uv_ratio, \"ratio between u and v gains, default is 50\");\nMODULE_PARM_DESC(full_luma_range, \"use the full luma range, default is 0 (no)\");\nMODULE_PARM_DESC(coring, \"set the luma coring level, default is 0 (no)\");\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\nMODULE_PARM_DESC(vbi_nr, \"vbi device numbers\");\nMODULE_PARM_DESC(radio_nr, \"radio device numbers\");\n\nMODULE_DESCRIPTION(\"bttv - v4l/v4l2 driver module for bt848/878 based cards\");\nMODULE_AUTHOR(\"Ralph Metzler & Marcus Metzler & Gerd Knorr\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(BTTV_VERSION);\n\n#define V4L2_CID_PRIVATE_COMBFILTER\t\t(V4L2_CID_USER_BTTV_BASE + 0)\n#define V4L2_CID_PRIVATE_AUTOMUTE\t\t(V4L2_CID_USER_BTTV_BASE + 1)\n#define V4L2_CID_PRIVATE_LUMAFILTER\t\t(V4L2_CID_USER_BTTV_BASE + 2)\n#define V4L2_CID_PRIVATE_AGC_CRUSH\t\t(V4L2_CID_USER_BTTV_BASE + 3)\n#define V4L2_CID_PRIVATE_VCR_HACK\t\t(V4L2_CID_USER_BTTV_BASE + 4)\n#define V4L2_CID_PRIVATE_WHITECRUSH_LOWER\t(V4L2_CID_USER_BTTV_BASE + 5)\n#define V4L2_CID_PRIVATE_WHITECRUSH_UPPER\t(V4L2_CID_USER_BTTV_BASE + 6)\n#define V4L2_CID_PRIVATE_UV_RATIO\t\t(V4L2_CID_USER_BTTV_BASE + 7)\n#define V4L2_CID_PRIVATE_FULL_LUMA_RANGE\t(V4L2_CID_USER_BTTV_BASE + 8)\n#define V4L2_CID_PRIVATE_CORING\t\t\t(V4L2_CID_USER_BTTV_BASE + 9)\n\n \n \n\nstatic ssize_t card_show(struct device *cd,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct video_device *vfd = to_video_device(cd);\n\tstruct bttv *btv = video_get_drvdata(vfd);\n\treturn sprintf(buf, \"%d\\n\", btv ? btv->c.type : UNSET);\n}\nstatic DEVICE_ATTR_RO(card);\n\n \n \n#if defined(CONFIG_MODULES) && defined(MODULE)\nstatic void request_module_async(struct work_struct *work)\n{\n\trequest_module(\"dvb-bt8xx\");\n}\n\nstatic void request_modules(struct bttv *dev)\n{\n\tINIT_WORK(&dev->request_module_wk, request_module_async);\n\tschedule_work(&dev->request_module_wk);\n}\n\nstatic void flush_request_modules(struct bttv *dev)\n{\n\tflush_work(&dev->request_module_wk);\n}\n#else\n#define request_modules(dev)\n#define flush_request_modules(dev) do {} while(0)\n#endif  \n\n\n \n \n\n \nstatic u8 SRAM_Table[][60] =\n{\n\t \n\t{\n\t\t45, \n\t\t0x36,0x11,0x01,0x00,0x90,0x02,0x05,0x10,0x04,0x16,\n\t\t0x12,0x05,0x11,0x00,0x04,0x12,0xC0,0x00,0x31,0x00,\n\t\t0x06,0x51,0x08,0x03,0x89,0x08,0x07,0xC0,0x44,0x00,\n\t\t0x81,0x01,0x01,0xA9,0x0D,0x02,0x02,0x50,0x03,0x37,\n\t\t0x37,0x00,0xAF,0x21,0x00\n\t},\n\t \n\t{\n\t\t51, \n\t\t0x0C,0xC0,0x00,0x00,0x90,0x02,0x03,0x10,0x03,0x06,\n\t\t0x10,0x04,0x12,0x12,0x05,0x02,0x13,0x04,0x19,0x00,\n\t\t0x04,0x39,0x00,0x06,0x59,0x08,0x03,0x83,0x08,0x07,\n\t\t0x03,0x50,0x00,0xC0,0x40,0x00,0x86,0x01,0x01,0xA6,\n\t\t0x0D,0x02,0x03,0x11,0x01,0x05,0x37,0x00,0xAC,0x21,\n\t\t0x00,\n\t},\n\t\n\t\n\t{\n\t\t0x2A, \n\t\t0x06, 0x08, 0x04, 0x0a, 0xc0, 0x00, 0x18, 0x08, 0x03, 0x24,\n\t\t0x08, 0x07, 0x02, 0x90, 0x02, 0x08, 0x10, 0x04, 0x0c, 0x10,\n\t\t0x05, 0x2c, 0x11, 0x04, 0x55, 0x48, 0x00, 0x05, 0x50, 0x00,\n\t\t0xbf, 0x0c, 0x02, 0x2f, 0x3d, 0x00, 0x2f, 0x3f, 0x00, 0xc3,\n\t\t0x20, 0x00\n\t}\n};\n\n \n#define CROPCAP(minhdelayx1, hdelayx1, swidth, totalwidth, sqwidth,\t \\\n\t\tvdelay, sheight, extraheight, videostart0)\t\t \\\n\t.cropcap.bounds.left = minhdelayx1,\t\t\t\t \\\n\t \t \\\n\t \t\t \\\n\t.cropcap.bounds.top = (videostart0) * 2 - (vdelay) + MIN_VDELAY, \\\n\t \t\t \\\n\t.cropcap.bounds.width = (totalwidth) - (minhdelayx1) - 4,\t \\\n\t.cropcap.bounds.height = (sheight) + (extraheight) + (vdelay) -\t \\\n\t\t\t\t MIN_VDELAY,\t\t\t\t \\\n\t.cropcap.defrect.left = hdelayx1,\t\t\t\t \\\n\t.cropcap.defrect.top = (videostart0) * 2,\t\t\t \\\n\t.cropcap.defrect.width = swidth,\t\t\t\t \\\n\t.cropcap.defrect.height = sheight,\t\t\t\t \\\n\t.cropcap.pixelaspect.numerator = totalwidth,\t\t\t \\\n\t.cropcap.pixelaspect.denominator = sqwidth,\n\nconst struct bttv_tvnorm bttv_tvnorms[] = {\n\t \n\t \n\t \n\t{\n\t\t.v4l2_id        = V4L2_STD_PAL,\n\t\t.name           = \"PAL\",\n\t\t.Fsc            = 35468950,\n\t\t.swidth         = 924,\n\t\t.sheight        = 576,\n\t\t.totalwidth     = 1135,\n\t\t.adelay         = 0x7f,\n\t\t.bdelay         = 0x72,\n\t\t.iform          = (BT848_IFORM_PAL_BDGHI|BT848_IFORM_XT1),\n\t\t.scaledtwidth   = 1135,\n\t\t.hdelayx1       = 186,\n\t\t.hactivex1      = 924,\n\t\t.vdelay         = 0x20,\n\t\t.vbipack        = 255,  \n\t\t.sram           = 0,\n\t\t \n\t\t.vbistart       = { 7, 320 },\n\t\tCROPCAP(  68,\n\t\t\t  186,\n\t\t\t \n\t\t\t  924,\n\t\t\t  1135,\n\t\t\t  944,\n\t\t\t  0x20,\n\t\t\t  576,\n\t\t\t \n\t\t\t  2,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_NTSC_M | V4L2_STD_NTSC_M_KR,\n\t\t.name           = \"NTSC\",\n\t\t.Fsc            = 28636363,\n\t\t.swidth         = 768,\n\t\t.sheight        = 480,\n\t\t.totalwidth     = 910,\n\t\t.adelay         = 0x68,\n\t\t.bdelay         = 0x5d,\n\t\t.iform          = (BT848_IFORM_NTSC|BT848_IFORM_XT0),\n\t\t.scaledtwidth   = 910,\n\t\t.hdelayx1       = 128,\n\t\t.hactivex1      = 910,\n\t\t.vdelay         = 0x1a,\n\t\t.vbipack        = 144,  \n\t\t.sram           = 1,\n\t\t.vbistart\t= { 10, 273 },\n\t\tCROPCAP(  68,\n\t\t\t  128,\n\t\t\t \n\t\t\t  768,\n\t\t\t  910,\n\t\t\t  780,\n\t\t\t  0x1a,\n\t\t\t  480,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_SECAM,\n\t\t.name           = \"SECAM\",\n\t\t.Fsc            = 35468950,\n\t\t.swidth         = 924,\n\t\t.sheight        = 576,\n\t\t.totalwidth     = 1135,\n\t\t.adelay         = 0x7f,\n\t\t.bdelay         = 0xb0,\n\t\t.iform          = (BT848_IFORM_SECAM|BT848_IFORM_XT1),\n\t\t.scaledtwidth   = 1135,\n\t\t.hdelayx1       = 186,\n\t\t.hactivex1      = 922,\n\t\t.vdelay         = 0x20,\n\t\t.vbipack        = 255,\n\t\t.sram           = 0,  \n\t\t.vbistart\t= { 7, 320 },\n\t\tCROPCAP(  68,\n\t\t\t  186,\n\t\t\t  924,\n\t\t\t  1135,\n\t\t\t  944,\n\t\t\t  0x20,\n\t\t\t  576,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_PAL_Nc,\n\t\t.name           = \"PAL-Nc\",\n\t\t.Fsc            = 28636363,\n\t\t.swidth         = 640,\n\t\t.sheight        = 576,\n\t\t.totalwidth     = 910,\n\t\t.adelay         = 0x68,\n\t\t.bdelay         = 0x5d,\n\t\t.iform          = (BT848_IFORM_PAL_NC|BT848_IFORM_XT0),\n\t\t.scaledtwidth   = 780,\n\t\t.hdelayx1       = 130,\n\t\t.hactivex1      = 734,\n\t\t.vdelay         = 0x1a,\n\t\t.vbipack        = 144,\n\t\t.sram           = -1,\n\t\t.vbistart\t= { 7, 320 },\n\t\tCROPCAP(  68,\n\t\t\t  130,\n\t\t\t  (640 * 910 + 780 / 2) / 780,\n\t\t\t  910,\n\t\t\t  780,\n\t\t\t  0x1a,\n\t\t\t  576,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_PAL_M,\n\t\t.name           = \"PAL-M\",\n\t\t.Fsc            = 28636363,\n\t\t.swidth         = 640,\n\t\t.sheight        = 480,\n\t\t.totalwidth     = 910,\n\t\t.adelay         = 0x68,\n\t\t.bdelay         = 0x5d,\n\t\t.iform          = (BT848_IFORM_PAL_M|BT848_IFORM_XT0),\n\t\t.scaledtwidth   = 780,\n\t\t.hdelayx1       = 135,\n\t\t.hactivex1      = 754,\n\t\t.vdelay         = 0x1a,\n\t\t.vbipack        = 144,\n\t\t.sram           = -1,\n\t\t.vbistart\t= { 10, 273 },\n\t\tCROPCAP(  68,\n\t\t\t  135,\n\t\t\t  (640 * 910 + 780 / 2) / 780,\n\t\t\t  910,\n\t\t\t  780,\n\t\t\t  0x1a,\n\t\t\t  480,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_PAL_N,\n\t\t.name           = \"PAL-N\",\n\t\t.Fsc            = 35468950,\n\t\t.swidth         = 768,\n\t\t.sheight        = 576,\n\t\t.totalwidth     = 1135,\n\t\t.adelay         = 0x7f,\n\t\t.bdelay         = 0x72,\n\t\t.iform          = (BT848_IFORM_PAL_N|BT848_IFORM_XT1),\n\t\t.scaledtwidth   = 944,\n\t\t.hdelayx1       = 186,\n\t\t.hactivex1      = 922,\n\t\t.vdelay         = 0x20,\n\t\t.vbipack        = 144,\n\t\t.sram           = -1,\n\t\t.vbistart       = { 7, 320 },\n\t\tCROPCAP(  68,\n\t\t\t  186,\n\t\t\t  (768 * 1135 + 944 / 2) / 944,\n\t\t\t  1135,\n\t\t\t  944,\n\t\t\t  0x20,\n\t\t\t  576,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t.v4l2_id        = V4L2_STD_NTSC_M_JP,\n\t\t.name           = \"NTSC-JP\",\n\t\t.Fsc            = 28636363,\n\t\t.swidth         = 640,\n\t\t.sheight        = 480,\n\t\t.totalwidth     = 910,\n\t\t.adelay         = 0x68,\n\t\t.bdelay         = 0x5d,\n\t\t.iform          = (BT848_IFORM_NTSC_J|BT848_IFORM_XT0),\n\t\t.scaledtwidth   = 780,\n\t\t.hdelayx1       = 135,\n\t\t.hactivex1      = 754,\n\t\t.vdelay         = 0x16,\n\t\t.vbipack        = 144,\n\t\t.sram           = -1,\n\t\t.vbistart       = { 10, 273 },\n\t\tCROPCAP(  68,\n\t\t\t  135,\n\t\t\t  (640 * 910 + 780 / 2) / 780,\n\t\t\t  910,\n\t\t\t  780,\n\t\t\t  0x16,\n\t\t\t  480,\n\t\t\t  0,\n\t\t\t  23)\n\t},{\n\t\t \n\t\t.v4l2_id        = V4L2_STD_PAL_60,\n\t\t.name           = \"PAL-60\",\n\t\t.Fsc            = 35468950,\n\t\t.swidth         = 924,\n\t\t.sheight        = 480,\n\t\t.totalwidth     = 1135,\n\t\t.adelay         = 0x7f,\n\t\t.bdelay         = 0x72,\n\t\t.iform          = (BT848_IFORM_PAL_BDGHI|BT848_IFORM_XT1),\n\t\t.scaledtwidth   = 1135,\n\t\t.hdelayx1       = 186,\n\t\t.hactivex1      = 924,\n\t\t.vdelay         = 0x1a,\n\t\t.vbipack        = 255,\n\t\t.vtotal         = 524,\n\t\t.sram           = -1,\n\t\t.vbistart\t= { 10, 273 },\n\t\tCROPCAP(  68,\n\t\t\t  186,\n\t\t\t  924,\n\t\t\t  1135,\n\t\t\t  944,\n\t\t\t  0x1a,\n\t\t\t  480,\n\t\t\t  0,\n\t\t\t  23)\n\t}\n};\nstatic const unsigned int BTTV_TVNORMS = ARRAY_SIZE(bttv_tvnorms);\n\n \n \nstatic const struct bttv_format formats[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_GREY,\n\t\t.btformat = BT848_COLOR_FMT_Y8,\n\t\t.depth    = 8,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_HI240,\n\t\t.btformat = BT848_COLOR_FMT_RGB8,\n\t\t.depth    = 8,\n\t\t.flags    = FORMAT_FLAGS_PACKED | FORMAT_FLAGS_DITHER,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555,\n\t\t.btformat = BT848_COLOR_FMT_RGB15,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555X,\n\t\t.btformat = BT848_COLOR_FMT_RGB15,\n\t\t.btswap   = 0x03,  \n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565,\n\t\t.btformat = BT848_COLOR_FMT_RGB16,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565X,\n\t\t.btformat = BT848_COLOR_FMT_RGB16,\n\t\t.btswap   = 0x03,  \n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_BGR24,\n\t\t.btformat = BT848_COLOR_FMT_RGB24,\n\t\t.depth    = 24,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_BGR32,\n\t\t.btformat = BT848_COLOR_FMT_RGB32,\n\t\t.depth    = 32,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_RGB32,\n\t\t.btformat = BT848_COLOR_FMT_RGB32,\n\t\t.btswap   = 0x0f,  \n\t\t.depth    = 32,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUYV,\n\t\t.btformat = BT848_COLOR_FMT_YUY2,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_UYVY,\n\t\t.btformat = BT848_COLOR_FMT_YUY2,\n\t\t.btswap   = 0x03,  \n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV422P,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb422,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PLANAR,\n\t\t.hshift   = 1,\n\t\t.vshift   = 0,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV420,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb422,\n\t\t.depth    = 12,\n\t\t.flags    = FORMAT_FLAGS_PLANAR,\n\t\t.hshift   = 1,\n\t\t.vshift   = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YVU420,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb422,\n\t\t.depth    = 12,\n\t\t.flags    = FORMAT_FLAGS_PLANAR | FORMAT_FLAGS_CrCb,\n\t\t.hshift   = 1,\n\t\t.vshift   = 1,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV411P,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb411,\n\t\t.depth    = 12,\n\t\t.flags    = FORMAT_FLAGS_PLANAR,\n\t\t.hshift   = 2,\n\t\t.vshift   = 0,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YUV410,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb411,\n\t\t.depth    = 9,\n\t\t.flags    = FORMAT_FLAGS_PLANAR,\n\t\t.hshift   = 2,\n\t\t.vshift   = 2,\n\t},{\n\t\t.fourcc   = V4L2_PIX_FMT_YVU410,\n\t\t.btformat = BT848_COLOR_FMT_YCrCb411,\n\t\t.depth    = 9,\n\t\t.flags    = FORMAT_FLAGS_PLANAR | FORMAT_FLAGS_CrCb,\n\t\t.hshift   = 2,\n\t\t.vshift   = 2,\n\t},{\n\t\t.fourcc   = -1,\n\t\t.btformat = BT848_COLOR_FMT_RAW,\n\t\t.depth    = 8,\n\t\t.flags    = FORMAT_FLAGS_RAW,\n\t}\n};\nstatic const unsigned int FORMATS = ARRAY_SIZE(formats);\n\n \n \n\n \n\n#define VBI_RESOURCES (RESOURCE_VBI)\n#define VIDEO_RESOURCES (RESOURCE_VIDEO_READ | \\\n\t\t\t RESOURCE_VIDEO_STREAM)\n\nint check_alloc_btres_lock(struct bttv *btv, int bit)\n{\n\tint xbits;  \n\n\txbits = bit;\n\tif (bit & (RESOURCE_VIDEO_READ | RESOURCE_VIDEO_STREAM))\n\t\txbits |= RESOURCE_VIDEO_READ | RESOURCE_VIDEO_STREAM;\n\n\t \n\tif (btv->resources & xbits) {\n\t\t \n\t\tgoto fail;\n\t}\n\n\tif ((bit & VIDEO_RESOURCES)\n\t    && 0 == (btv->resources & VIDEO_RESOURCES)) {\n\t\t \n\t\t__s32 top = btv->crop[!!btv->do_crop].rect.top;\n\n\t\tif (btv->vbi_end > top)\n\t\t\tgoto fail;\n\n\t\t \n\t\tbtv->crop_start = top;\n\t} else if (bit & VBI_RESOURCES) {\n\t\t__s32 end = btv->vbi_fmt.end;\n\n\t\tif (end > btv->crop_start)\n\t\t\tgoto fail;\n\n\t\t \n\t\tbtv->vbi_end = end;\n\t}\n\n\t \n\tbtv->resources |= bit;\n\treturn 1;\n\n fail:\n\treturn 0;\n}\n\nstatic\nint check_btres(struct bttv *btv, int bit)\n{\n\treturn (btv->resources & bit);\n}\n\nstatic\nint locked_btres(struct bttv *btv, int bit)\n{\n\treturn (btv->resources & bit);\n}\n\n \nstatic void\ndisclaim_vbi_lines(struct bttv *btv)\n{\n\tbtv->vbi_end = 0;\n}\n\n \nstatic void\ndisclaim_video_lines(struct bttv *btv)\n{\n\tconst struct bttv_tvnorm *tvnorm;\n\tu8 crop;\n\n\ttvnorm = &bttv_tvnorms[btv->tvnorm];\n\tbtv->crop_start = tvnorm->cropcap.bounds.top\n\t\t+ tvnorm->cropcap.bounds.height;\n\n\t \n\tcrop = btread(BT848_E_CROP) | 0xc0;\n\tbtwrite(crop, BT848_E_CROP);\n\tbtwrite(0xfe, BT848_E_VDELAY_LO);\n\tbtwrite(crop, BT848_O_CROP);\n\tbtwrite(0xfe, BT848_O_VDELAY_LO);\n}\n\nvoid free_btres_lock(struct bttv *btv, int bits)\n{\n\tif ((btv->resources & bits) != bits) {\n\t\t \n\t\tpr_err(\"BUG! (btres)\\n\");\n\t}\n\tbtv->resources &= ~bits;\n\n\tbits = btv->resources;\n\n\tif (0 == (bits & VIDEO_RESOURCES))\n\t\tdisclaim_video_lines(btv);\n\n\tif (0 == (bits & VBI_RESOURCES))\n\t\tdisclaim_vbi_lines(btv);\n}\n\n \n \n\n \n\nstatic void set_pll_freq(struct bttv *btv, unsigned int fin, unsigned int fout)\n{\n\tunsigned char fl, fh, fi;\n\n\t \n\tfin/=4;\n\tfout/=4;\n\n\tfout*=12;\n\tfi=fout/fin;\n\n\tfout=(fout%fin)*256;\n\tfh=fout/fin;\n\n\tfout=(fout%fin)*256;\n\tfl=fout/fin;\n\n\tbtwrite(fl, BT848_PLL_F_LO);\n\tbtwrite(fh, BT848_PLL_F_HI);\n\tbtwrite(fi|BT848_PLL_X, BT848_PLL_XCI);\n}\n\nstatic void set_pll(struct bttv *btv)\n{\n\tint i;\n\n\tif (!btv->pll.pll_crystal)\n\t\treturn;\n\n\tif (btv->pll.pll_ofreq == btv->pll.pll_current) {\n\t\tdprintk(\"%d: PLL: no change required\\n\", btv->c.nr);\n\t\treturn;\n\t}\n\n\tif (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {\n\t\t \n\t\tif (btv->pll.pll_current == 0)\n\t\t\treturn;\n\t\tif (bttv_verbose)\n\t\t\tpr_info(\"%d: PLL can sleep, using XTAL (%d)\\n\",\n\t\t\t\tbtv->c.nr, btv->pll.pll_ifreq);\n\t\tbtwrite(0x00,BT848_TGCTRL);\n\t\tbtwrite(0x00,BT848_PLL_XCI);\n\t\tbtv->pll.pll_current = 0;\n\t\treturn;\n\t}\n\n\tif (bttv_verbose)\n\t\tpr_info(\"%d: Setting PLL: %d => %d (needs up to 100ms)\\n\",\n\t\t\tbtv->c.nr,\n\t\t\tbtv->pll.pll_ifreq, btv->pll.pll_ofreq);\n\tset_pll_freq(btv, btv->pll.pll_ifreq, btv->pll.pll_ofreq);\n\n\tfor (i=0; i<10; i++) {\n\t\t \n\t\tmsleep(10);\n\n\t\tif (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {\n\t\t\tbtwrite(0,BT848_DSTATUS);\n\t\t} else {\n\t\t\tbtwrite(0x08,BT848_TGCTRL);\n\t\t\tbtv->pll.pll_current = btv->pll.pll_ofreq;\n\t\t\tif (bttv_verbose)\n\t\t\t\tpr_info(\"PLL set ok\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tbtv->pll.pll_current = -1;\n\tif (bttv_verbose)\n\t\tpr_info(\"Setting PLL failed\\n\");\n\treturn;\n}\n\n \nstatic void bt848A_set_timing(struct bttv *btv)\n{\n\tint i, len;\n\tint table_idx = bttv_tvnorms[btv->tvnorm].sram;\n\tint fsc       = bttv_tvnorms[btv->tvnorm].Fsc;\n\n\tif (btv->input == btv->dig) {\n\t\tdprintk(\"%d: load digital timing table (table_idx=%d)\\n\",\n\t\t\tbtv->c.nr,table_idx);\n\n\t\t \n\t\tbtwrite(0x00, BT848_TGCTRL);\n\t\tbtwrite(0x02, BT848_TGCTRL);\n\t\tbtwrite(0x00, BT848_TGCTRL);\n\n\t\tlen=SRAM_Table[table_idx][0];\n\t\tfor(i = 1; i <= len; i++)\n\t\t\tbtwrite(SRAM_Table[table_idx][i],BT848_TGLB);\n\t\tbtv->pll.pll_ofreq = 27000000;\n\n\t\tset_pll(btv);\n\t\tbtwrite(0x11, BT848_TGCTRL);\n\t\tbtwrite(0x41, BT848_DVSIF);\n\t} else {\n\t\tbtv->pll.pll_ofreq = fsc;\n\t\tset_pll(btv);\n\t\tbtwrite(0x0, BT848_DVSIF);\n\t}\n}\n\n \n\nstatic void bt848_bright(struct bttv *btv, int bright)\n{\n\tint value;\n\n\t\n\tbtv->bright = bright;\n\n\t \n\tvalue = (bright >> 8) - 128;\n\tbtwrite(value & 0xff, BT848_BRIGHT);\n}\n\nstatic void bt848_hue(struct bttv *btv, int hue)\n{\n\tint value;\n\n\tbtv->hue = hue;\n\n\t \n\tvalue = (hue >> 8) - 128;\n\tbtwrite(value & 0xff, BT848_HUE);\n}\n\nstatic void bt848_contrast(struct bttv *btv, int cont)\n{\n\tint value,hibit;\n\n\tbtv->contrast = cont;\n\n\t \n\tvalue = (cont  >> 7);\n\thibit = (value >> 6) & 4;\n\tbtwrite(value & 0xff, BT848_CONTRAST_LO);\n\tbtaor(hibit, ~4, BT848_E_CONTROL);\n\tbtaor(hibit, ~4, BT848_O_CONTROL);\n}\n\nstatic void bt848_sat(struct bttv *btv, int color)\n{\n\tint val_u,val_v,hibits;\n\n\tbtv->saturation = color;\n\n\t \n\tval_u   = ((color * btv->opt_uv_ratio) / 50) >> 7;\n\tval_v   = (((color * (100 - btv->opt_uv_ratio) / 50) >>7)*180L)/254;\n\thibits  = (val_u >> 7) & 2;\n\thibits |= (val_v >> 8) & 1;\n\tbtwrite(val_u & 0xff, BT848_SAT_U_LO);\n\tbtwrite(val_v & 0xff, BT848_SAT_V_LO);\n\tbtaor(hibits, ~3, BT848_E_CONTROL);\n\tbtaor(hibits, ~3, BT848_O_CONTROL);\n}\n\n \n\nstatic int\nvideo_mux(struct bttv *btv, unsigned int input)\n{\n\tint mux,mask2;\n\n\tif (input >= bttv_tvcards[btv->c.type].video_inputs)\n\t\treturn -EINVAL;\n\n\t \n\tmask2 = bttv_tvcards[btv->c.type].gpiomask2;\n\tif (mask2)\n\t\tgpio_inout(mask2,mask2);\n\n\tif (input == btv->svhs)  {\n\t\tbtor(BT848_CONTROL_COMP, BT848_E_CONTROL);\n\t\tbtor(BT848_CONTROL_COMP, BT848_O_CONTROL);\n\t} else {\n\t\tbtand(~BT848_CONTROL_COMP, BT848_E_CONTROL);\n\t\tbtand(~BT848_CONTROL_COMP, BT848_O_CONTROL);\n\t}\n\tmux = bttv_muxsel(btv, input);\n\tbtaor(mux<<5, ~(3<<5), BT848_IFORM);\n\tdprintk(\"%d: video mux: input=%d mux=%d\\n\", btv->c.nr, input, mux);\n\n\t \n\tif(bttv_tvcards[btv->c.type].muxsel_hook)\n\t\tbttv_tvcards[btv->c.type].muxsel_hook (btv, input);\n\treturn 0;\n}\n\nstatic char *audio_modes[] = {\n\t\"audio: tuner\", \"audio: radio\", \"audio: extern\",\n\t\"audio: intern\", \"audio: mute\"\n};\n\nstatic void\naudio_mux_gpio(struct bttv *btv, int input, int mute)\n{\n\tint gpio_val, signal, mute_gpio;\n\n\tgpio_inout(bttv_tvcards[btv->c.type].gpiomask,\n\t\t   bttv_tvcards[btv->c.type].gpiomask);\n\tsignal = btread(BT848_DSTATUS) & BT848_DSTATUS_HLOC;\n\n\t \n\tmute_gpio = mute || (btv->opt_automute && (!signal || !btv->users)\n\t\t\t\t&& !btv->has_radio_tuner);\n\n\tif (mute_gpio)\n\t\tgpio_val = bttv_tvcards[btv->c.type].gpiomute;\n\telse\n\t\tgpio_val = bttv_tvcards[btv->c.type].gpiomux[input];\n\n\tswitch (btv->c.type) {\n\tcase BTTV_BOARD_VOODOOTV_FM:\n\tcase BTTV_BOARD_VOODOOTV_200:\n\t\tgpio_val = bttv_tda9880_setnorm(btv, gpio_val);\n\t\tbreak;\n\n\tdefault:\n\t\tgpio_bits(bttv_tvcards[btv->c.type].gpiomask, gpio_val);\n\t}\n\n\tif (bttv_gpio)\n\t\tbttv_gpio_tracking(btv, audio_modes[mute_gpio ? 4 : input]);\n}\n\nstatic int\naudio_mute(struct bttv *btv, int mute)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\taudio_mux_gpio(btv, btv->audio_input, mute);\n\n\tif (btv->sd_msp34xx) {\n\t\tctrl = v4l2_ctrl_find(btv->sd_msp34xx->ctrl_handler, V4L2_CID_AUDIO_MUTE);\n\t\tif (ctrl)\n\t\t\tv4l2_ctrl_s_ctrl(ctrl, mute);\n\t}\n\tif (btv->sd_tvaudio) {\n\t\tctrl = v4l2_ctrl_find(btv->sd_tvaudio->ctrl_handler, V4L2_CID_AUDIO_MUTE);\n\t\tif (ctrl)\n\t\t\tv4l2_ctrl_s_ctrl(ctrl, mute);\n\t}\n\tif (btv->sd_tda7432) {\n\t\tctrl = v4l2_ctrl_find(btv->sd_tda7432->ctrl_handler, V4L2_CID_AUDIO_MUTE);\n\t\tif (ctrl)\n\t\t\tv4l2_ctrl_s_ctrl(ctrl, mute);\n\t}\n\treturn 0;\n}\n\nstatic int\naudio_input(struct bttv *btv, int input)\n{\n\taudio_mux_gpio(btv, input, btv->mute);\n\n\tif (btv->sd_msp34xx) {\n\t\tu32 in;\n\n\t\t \n\t\tswitch (input) {\n\t\tcase TVAUDIO_INPUT_RADIO:\n\t\t\t \n\t\t\tif (btv->radio_uses_msp_demodulator) {\n\t\t\t\tin = MSP_INPUT_DEFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tin = MSP_INPUT(MSP_IN_SCART2, MSP_IN_TUNER1,\n\t\t\t\t    MSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\n\t\t\tbreak;\n\t\tcase TVAUDIO_INPUT_EXTERN:\n\t\t\tin = MSP_INPUT(MSP_IN_SCART1, MSP_IN_TUNER1,\n\t\t\t\t    MSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\n\t\t\tbreak;\n\t\tcase TVAUDIO_INPUT_INTERN:\n\t\t\t \n\t\t\tin = MSP_INPUT(MSP_IN_SCART2, MSP_IN_TUNER1,\n\t\t\t\t    MSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\n\t\t\tbreak;\n\t\tcase TVAUDIO_INPUT_TUNER:\n\t\tdefault:\n\t\t\t \n\t\t\tif (btv->c.type == BTTV_BOARD_VOODOOTV_200)\n\t\t\t\tin = MSP_INPUT(MSP_IN_SCART1, MSP_IN_TUNER2, \\\n\t\t\t\t\tMSP_DSP_IN_TUNER, MSP_DSP_IN_TUNER);\n\t\t\telse\n\t\t\t\tin = MSP_INPUT_DEFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_subdev_call(btv->sd_msp34xx, audio, s_routing,\n\t\t\t       in, MSP_OUTPUT_DEFAULT, 0);\n\t}\n\tif (btv->sd_tvaudio) {\n\t\tv4l2_subdev_call(btv->sd_tvaudio, audio, s_routing,\n\t\t\t\t input, 0, 0);\n\t}\n\treturn 0;\n}\n\nstatic void\nbttv_crop_calc_limits(struct bttv_crop *c)\n{\n\t \n\n\tif (1) {\n\t\t \n\t\tc->min_scaled_width = 48;\n\t\tc->min_scaled_height = 32;\n\t} else {\n\t\tc->min_scaled_width =\n\t\t\t(max_t(unsigned int, 48, c->rect.width >> 4) + 3) & ~3;\n\t\tc->min_scaled_height =\n\t\t\tmax_t(unsigned int, 32, c->rect.height >> 4);\n\t}\n\n\tc->max_scaled_width  = c->rect.width & ~3;\n\tc->max_scaled_height = c->rect.height;\n}\n\nstatic void\nbttv_crop_reset(struct bttv_crop *c, unsigned int norm)\n{\n\tc->rect = bttv_tvnorms[norm].cropcap.defrect;\n\tbttv_crop_calc_limits(c);\n}\n\n \nstatic int\nset_tvnorm(struct bttv *btv, unsigned int norm)\n{\n\tconst struct bttv_tvnorm *tvnorm;\n\tv4l2_std_id id;\n\n\tWARN_ON(norm >= BTTV_TVNORMS);\n\tWARN_ON(btv->tvnorm >= BTTV_TVNORMS);\n\n\ttvnorm = &bttv_tvnorms[norm];\n\n\tif (memcmp(&bttv_tvnorms[btv->tvnorm].cropcap, &tvnorm->cropcap,\n\t\t    sizeof (tvnorm->cropcap))) {\n\t\tbttv_crop_reset(&btv->crop[0], norm);\n\t\tbtv->crop[1] = btv->crop[0];  \n\n\t\tif (0 == (btv->resources & VIDEO_RESOURCES)) {\n\t\t\tbtv->crop_start = tvnorm->cropcap.bounds.top\n\t\t\t\t+ tvnorm->cropcap.bounds.height;\n\t\t}\n\t}\n\n\tbtv->tvnorm = norm;\n\n\tbtwrite(tvnorm->adelay, BT848_ADELAY);\n\tbtwrite(tvnorm->bdelay, BT848_BDELAY);\n\tbtaor(tvnorm->iform,~(BT848_IFORM_NORM|BT848_IFORM_XTBOTH),\n\t      BT848_IFORM);\n\tbtwrite(tvnorm->vbipack, BT848_VBI_PACK_SIZE);\n\tbtwrite(1, BT848_VBI_PACK_DEL);\n\tbt848A_set_timing(btv);\n\n\tswitch (btv->c.type) {\n\tcase BTTV_BOARD_VOODOOTV_FM:\n\tcase BTTV_BOARD_VOODOOTV_200:\n\t\tbttv_tda9880_setnorm(btv, gpio_read());\n\t\tbreak;\n\t}\n\tid = tvnorm->v4l2_id;\n\tbttv_call_all(btv, video, s_std, id);\n\n\treturn 0;\n}\n\n \nstatic void\nset_input(struct bttv *btv, unsigned int input, unsigned int norm)\n{\n\tunsigned long flags;\n\n\tbtv->input = input;\n\tif (irq_iswitch) {\n\t\tspin_lock_irqsave(&btv->s_lock,flags);\n\t\tif (btv->curr.frame_irq) {\n\t\t\t \n\t\t\tbtv->new_input = input;\n\t\t} else {\n\t\t\tvideo_mux(btv,input);\n\t\t}\n\t\tspin_unlock_irqrestore(&btv->s_lock,flags);\n\t} else {\n\t\tvideo_mux(btv,input);\n\t}\n\tbtv->audio_input = (btv->tuner_type != TUNER_ABSENT && input == 0) ?\n\t\t\t\tTVAUDIO_INPUT_TUNER : TVAUDIO_INPUT_EXTERN;\n\taudio_input(btv, btv->audio_input);\n\tset_tvnorm(btv, norm);\n}\n\nvoid init_irqreg(struct bttv *btv)\n{\n\t \n\tbtwrite(0xfffffUL, BT848_INT_STAT);\n\n\tif (bttv_tvcards[btv->c.type].no_video) {\n\t\t \n\t\tbtwrite(BT848_INT_I2CDONE,\n\t\t\tBT848_INT_MASK);\n\t} else {\n\t\t \n\t\tbtwrite((btv->triton1)  |\n\t\t\t(btv->gpioirq ? BT848_INT_GPINT : 0) |\n\t\t\tBT848_INT_SCERR |\n\t\t\t(fdsr ? BT848_INT_FDSR : 0) |\n\t\t\tBT848_INT_RISCI | BT848_INT_OCERR |\n\t\t\tBT848_INT_FMTCHG|BT848_INT_HLOCK|\n\t\t\tBT848_INT_I2CDONE,\n\t\t\tBT848_INT_MASK);\n\t}\n}\n\nstatic void init_bt848(struct bttv *btv)\n{\n\tif (bttv_tvcards[btv->c.type].no_video) {\n\t\t \n\t\tinit_irqreg(btv);\n\t\treturn;\n\t}\n\n\tbtwrite(0x00, BT848_CAP_CTL);\n\tbtwrite(BT848_COLOR_CTL_GAMMA, BT848_COLOR_CTL);\n\tbtwrite(BT848_IFORM_XTAUTO | BT848_IFORM_AUTO, BT848_IFORM);\n\n\t \n\t \n\tbtwrite(BT848_GPIO_DMA_CTL_PKTP_32|\n\t\tBT848_GPIO_DMA_CTL_PLTP1_16|\n\t\tBT848_GPIO_DMA_CTL_PLTP23_16|\n\t\tBT848_GPIO_DMA_CTL_GPINTC|\n\t\tBT848_GPIO_DMA_CTL_GPINTI,\n\t\tBT848_GPIO_DMA_CTL);\n\n\tbtwrite(0x20, BT848_E_VSCALE_HI);\n\tbtwrite(0x20, BT848_O_VSCALE_HI);\n\n\tv4l2_ctrl_handler_setup(&btv->ctrl_handler);\n\n\t \n\tinit_irqreg(btv);\n}\n\nstatic void bttv_reinit_bt848(struct bttv *btv)\n{\n\tunsigned long flags;\n\n\tif (bttv_verbose)\n\t\tpr_info(\"%d: reset, reinitialize\\n\", btv->c.nr);\n\tspin_lock_irqsave(&btv->s_lock,flags);\n\tbtv->errors=0;\n\tbttv_set_dma(btv,0);\n\tspin_unlock_irqrestore(&btv->s_lock,flags);\n\n\tinit_bt848(btv);\n\tbtv->pll.pll_current = -1;\n\tset_input(btv, btv->input, btv->tvnorm);\n}\n\nstatic int bttv_s_ctrl(struct v4l2_ctrl *c)\n{\n\tstruct bttv *btv = container_of(c->handler, struct bttv, ctrl_handler);\n\tint val;\n\n\tswitch (c->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tbt848_bright(btv, c->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tbt848_hue(btv, c->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tbt848_contrast(btv, c->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tbt848_sat(btv, c->val);\n\t\tbreak;\n\tcase V4L2_CID_COLOR_KILLER:\n\t\tif (c->val) {\n\t\t\tbtor(BT848_SCLOOP_CKILL, BT848_E_SCLOOP);\n\t\t\tbtor(BT848_SCLOOP_CKILL, BT848_O_SCLOOP);\n\t\t} else {\n\t\t\tbtand(~BT848_SCLOOP_CKILL, BT848_E_SCLOOP);\n\t\t\tbtand(~BT848_SCLOOP_CKILL, BT848_O_SCLOOP);\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\taudio_mute(btv, c->val);\n\t\tbtv->mute = c->val;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tbtv->volume_gpio(btv, c->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CHROMA_AGC:\n\t\tval = c->val ? BT848_SCLOOP_CAGC : 0;\n\t\tbtwrite(val, BT848_E_SCLOOP);\n\t\tbtwrite(val, BT848_O_SCLOOP);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_COMBFILTER:\n\t\tbtv->opt_combfilter = c->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_LUMAFILTER:\n\t\tif (c->val) {\n\t\t\tbtand(~BT848_CONTROL_LDEC, BT848_E_CONTROL);\n\t\t\tbtand(~BT848_CONTROL_LDEC, BT848_O_CONTROL);\n\t\t} else {\n\t\t\tbtor(BT848_CONTROL_LDEC, BT848_E_CONTROL);\n\t\t\tbtor(BT848_CONTROL_LDEC, BT848_O_CONTROL);\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_AUTOMUTE:\n\t\tbtv->opt_automute = c->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_AGC_CRUSH:\n\t\tbtwrite(BT848_ADC_RESERVED |\n\t\t\t\t(c->val ? BT848_ADC_CRUSH : 0),\n\t\t\t\tBT848_ADC);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_VCR_HACK:\n\t\tbtv->opt_vcr_hack = c->val;\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_WHITECRUSH_UPPER:\n\t\tbtwrite(c->val, BT848_WC_UP);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_WHITECRUSH_LOWER:\n\t\tbtwrite(c->val, BT848_WC_DOWN);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_UV_RATIO:\n\t\tbtv->opt_uv_ratio = c->val;\n\t\tbt848_sat(btv, btv->saturation);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_FULL_LUMA_RANGE:\n\t\tbtaor((c->val << 7), ~BT848_OFORM_RANGE, BT848_OFORM);\n\t\tbreak;\n\tcase V4L2_CID_PRIVATE_CORING:\n\t\tbtaor((c->val << 5), ~BT848_OFORM_CORE32, BT848_OFORM);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops bttv_ctrl_ops = {\n\t.s_ctrl = bttv_s_ctrl,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_combfilter = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_COMBFILTER,\n\t.name = \"Comb Filter\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_automute = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_AUTOMUTE,\n\t.name = \"Auto Mute\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_lumafilter = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_LUMAFILTER,\n\t.name = \"Luma Decimation Filter\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_agc_crush = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_AGC_CRUSH,\n\t.name = \"AGC Crush\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_vcr_hack = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_VCR_HACK,\n\t.name = \"VCR Hack\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_whitecrush_lower = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_WHITECRUSH_LOWER,\n\t.name = \"Whitecrush Lower\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 255,\n\t.step = 1,\n\t.def = 0x7f,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_whitecrush_upper = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_WHITECRUSH_UPPER,\n\t.name = \"Whitecrush Upper\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 255,\n\t.step = 1,\n\t.def = 0xcf,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_uv_ratio = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_UV_RATIO,\n\t.name = \"UV Ratio\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 100,\n\t.step = 1,\n\t.def = 50,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_full_luma = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_FULL_LUMA_RANGE,\n\t.name = \"Full Luma Range\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic struct v4l2_ctrl_config bttv_ctrl_coring = {\n\t.ops = &bttv_ctrl_ops,\n\t.id = V4L2_CID_PRIVATE_CORING,\n\t.name = \"Coring\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 3,\n\t.step = 1,\n};\n\n\n \n\nvoid bttv_gpio_tracking(struct bttv *btv, char *comment)\n{\n\tunsigned int outbits, data;\n\toutbits = btread(BT848_GPIO_OUT_EN);\n\tdata    = btread(BT848_GPIO_DATA);\n\tpr_debug(\"%d: gpio: en=%08x, out=%08x in=%08x [%s]\\n\",\n\t\t btv->c.nr, outbits, data & outbits, data & ~outbits, comment);\n}\n\nstatic const struct bttv_format*\nformat_by_fourcc(int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++) {\n\t\tif (-1 == formats[i].fourcc)\n\t\t\tcontinue;\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats+i;\n\t}\n\treturn NULL;\n}\n\n \n \n\nstatic int queue_setup(struct vb2_queue *q, unsigned int *num_buffers,\n\t\t       unsigned int *num_planes, unsigned int sizes[],\n\t\t       struct device *alloc_devs[])\n{\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\tunsigned int size = btv->fmt->depth * btv->width * btv->height >> 3;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&btv->s_lock, flags);\n\tif (list_empty(&btv->capture)) {\n\t\tbtv->loop_irq = BT848_RISC_VIDEO;\n\t\tif (vb2_is_streaming(&btv->vbiq))\n\t\t\tbtv->loop_irq |= BT848_RISC_VBI;\n\t\tbttv_set_dma(btv, BT848_CAP_CTL_CAPTURE_ODD |\n\t\t\t     BT848_CAP_CTL_CAPTURE_EVEN);\n\t}\n\tlist_add_tail(&buf->list, &btv->capture);\n\tspin_unlock_irqrestore(&btv->s_lock, flags);\n}\n\nstatic int buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\tunsigned int size = (btv->fmt->depth * btv->width * btv->height) >> 3;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\n\tif (btv->field != V4L2_FIELD_ALTERNATE) {\n\t\tbuf->vbuf.field = btv->field;\n\t} else if (btv->field_last == V4L2_FIELD_TOP) {\n\t\tbuf->vbuf.field = V4L2_FIELD_BOTTOM;\n\t\tbtv->field_last = V4L2_FIELD_BOTTOM;\n\t} else {\n\t\tbuf->vbuf.field = V4L2_FIELD_TOP;\n\t\tbtv->field_last = V4L2_FIELD_TOP;\n\t}\n\n\t \n\treturn bttv_buffer_risc(btv, buf);\n}\n\nstatic void buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct bttv *btv = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct bttv_buffer *buf = container_of(vbuf, struct bttv_buffer, vbuf);\n\n\tbtcx_riscmem_free(btv->c.pci, &buf->top);\n\tbtcx_riscmem_free(btv->c.pci, &buf->bottom);\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tint seqnr = 0;\n\tstruct bttv_buffer *buf;\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\n\tif (!check_alloc_btres_lock(btv, RESOURCE_VIDEO_STREAM)) {\n\t\tif (btv->field_count)\n\t\t\tseqnr++;\n\t\twhile (!list_empty(&btv->capture)) {\n\t\t\tbuf = list_entry(btv->capture.next,\n\t\t\t\t\t struct bttv_buffer, list);\n\t\t\tlist_del(&buf->list);\n\t\t\tbuf->vbuf.sequence = (btv->field_count >> 1) + seqnr++;\n\t\t\tvb2_buffer_done(&buf->vbuf.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\tif (!vb2_is_streaming(&btv->vbiq)) {\n\t\tinit_irqreg(btv);\n\t\tbtv->field_count = 0;\n\t}\n\tbtv->framedrop = 0;\n\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tunsigned long flags;\n\tstruct bttv *btv = vb2_get_drv_priv(q);\n\n\tvb2_wait_for_all_buffers(q);\n\tspin_lock_irqsave(&btv->s_lock, flags);\n\tfree_btres_lock(btv, RESOURCE_VIDEO_STREAM);\n\tif (!vb2_is_streaming(&btv->vbiq)) {\n\t\t \n\t\tbtand(~BT848_INT_VSYNC, BT848_INT_MASK);\n\t}\n\tspin_unlock_irqrestore(&btv->s_lock, flags);\n}\n\nstatic const struct vb2_ops bttv_video_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_queue      = buf_queue,\n\t.buf_prepare    = buf_prepare,\n\t.buf_cleanup    = buf_cleanup,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n\t.wait_prepare   = vb2_ops_wait_prepare,\n\t.wait_finish    = vb2_ops_wait_finish,\n};\n\nstatic void radio_enable(struct bttv *btv)\n{\n\t \n\tif (!btv->has_radio_tuner) {\n\t\tbtv->has_radio_tuner = 1;\n\t\tbttv_call_all(btv, tuner, s_radio);\n\t\tbtv->audio_input = TVAUDIO_INPUT_RADIO;\n\t\taudio_input(btv, btv->audio_input);\n\t}\n}\n\nstatic int bttv_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tunsigned int i;\n\n\tfor (i = 0; i < BTTV_TVNORMS; i++)\n\t\tif (id & bttv_tvnorms[i].v4l2_id)\n\t\t\tbreak;\n\tif (i == BTTV_TVNORMS)\n\t\treturn -EINVAL;\n\tbtv->std = id;\n\tset_tvnorm(btv, i);\n\treturn 0;\n}\n\nstatic int bttv_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\t*id = btv->std;\n\treturn 0;\n}\n\nstatic int bttv_querystd(struct file *file, void *f, v4l2_std_id *id)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (btread(BT848_DSTATUS) & BT848_DSTATUS_NUML)\n\t\t*id &= V4L2_STD_625_50;\n\telse\n\t\t*id &= V4L2_STD_525_60;\n\treturn 0;\n}\n\nstatic int bttv_enum_input(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_input *i)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (i->index >= bttv_tvcards[btv->c.type].video_inputs)\n\t\treturn -EINVAL;\n\n\ti->type     = V4L2_INPUT_TYPE_CAMERA;\n\ti->audioset = 0;\n\n\tif (btv->tuner_type != TUNER_ABSENT && i->index == 0) {\n\t\tsprintf(i->name, \"Television\");\n\t\ti->type  = V4L2_INPUT_TYPE_TUNER;\n\t\ti->tuner = 0;\n\t} else if (i->index == btv->svhs) {\n\t\tsprintf(i->name, \"S-Video\");\n\t} else {\n\t\tsprintf(i->name, \"Composite%d\", i->index);\n\t}\n\n\tif (i->index == btv->input) {\n\t\t__u32 dstatus = btread(BT848_DSTATUS);\n\t\tif (0 == (dstatus & BT848_DSTATUS_PRES))\n\t\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\t\tif (0 == (dstatus & BT848_DSTATUS_HLOC))\n\t\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\t}\n\n\ti->std = BTTV_NORMS;\n\treturn 0;\n}\n\nstatic int bttv_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\t*i = btv->input;\n\n\treturn 0;\n}\n\nstatic int bttv_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (i >= bttv_tvcards[btv->c.type].video_inputs)\n\t\treturn -EINVAL;\n\n\tset_input(btv, i, btv->tvnorm);\n\treturn 0;\n}\n\nstatic int bttv_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (t->index)\n\t\treturn -EINVAL;\n\n\tbttv_call_all(btv, tuner, s_tuner, t);\n\n\tif (btv->audio_mode_gpio) {\n\t\tstruct v4l2_tuner copy = *t;\n\n\t\tbtv->audio_mode_gpio(btv, &copy, 1);\n\t}\n\treturn 0;\n}\n\nstatic int bttv_g_frequency(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_TUNER_RADIO)\n\t\tradio_enable(btv);\n\tf->frequency = f->type == V4L2_TUNER_RADIO ?\n\t\t\t\tbtv->radio_freq : btv->tv_freq;\n\n\treturn 0;\n}\n\nstatic void bttv_set_frequency(struct bttv *btv, const struct v4l2_frequency *f)\n{\n\tstruct v4l2_frequency new_freq = *f;\n\n\tbttv_call_all(btv, tuner, s_frequency, f);\n\t \n\tbttv_call_all(btv, tuner, g_frequency, &new_freq);\n\tif (new_freq.type == V4L2_TUNER_RADIO) {\n\t\tradio_enable(btv);\n\t\tbtv->radio_freq = new_freq.frequency;\n\t\tif (btv->has_tea575x) {\n\t\t\tbtv->tea.freq = btv->radio_freq;\n\t\t\tsnd_tea575x_set_freq(&btv->tea);\n\t\t}\n\t} else {\n\t\tbtv->tv_freq = new_freq.frequency;\n\t}\n}\n\nstatic int bttv_s_frequency(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tbttv_set_frequency(btv, f);\n\treturn 0;\n}\n\nstatic int bttv_log_status(struct file *file, void *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct bttv *btv = video_drvdata(file);\n\n\tv4l2_ctrl_handler_log_status(vdev->ctrl_handler, btv->c.v4l2_dev.name);\n\tbttv_call_all(btv, core, log_status);\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int bttv_g_register(struct file *file, void *f,\n\t\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\t \n\treg->reg &= 0xfff;\n\treg->val = btread(reg->reg);\n\treg->size = 1;\n\n\treturn 0;\n}\n\nstatic int bttv_s_register(struct file *file, void *f,\n\t\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\t \n\tbtwrite(reg->val, reg->reg & 0xfff);\n\n\treturn 0;\n}\n#endif\n\n \nstatic void\nbttv_crop_adjust\t(struct bttv_crop *             c,\n\t\t\t const struct v4l2_rect *\tb,\n\t\t\t __s32                          width,\n\t\t\t __s32                          height,\n\t\t\t enum v4l2_field                field)\n{\n\t__s32 frame_height = height << !V4L2_FIELD_HAS_BOTH(field);\n\t__s32 max_left;\n\t__s32 max_top;\n\n\tif (width < c->min_scaled_width) {\n\t\t \n\t\tc->rect.width = width * 16;\n\t} else if (width > c->max_scaled_width) {\n\t\t \n\t\tc->rect.width = width;\n\n\t\tmax_left = b->left + b->width - width;\n\t\tmax_left = min(max_left, (__s32) MAX_HDELAY);\n\t\tif (c->rect.left > max_left)\n\t\t\tc->rect.left = max_left;\n\t}\n\n\tif (height < c->min_scaled_height) {\n\t\t \n\t\tc->rect.height = height * 16;\n\t} else if (frame_height > c->max_scaled_height) {\n\t\t \n\t\tc->rect.height = (frame_height + 1) & ~1;\n\n\t\tmax_top = b->top + b->height - c->rect.height;\n\t\tif (c->rect.top > max_top)\n\t\t\tc->rect.top = max_top;\n\t}\n\n\tbttv_crop_calc_limits(c);\n}\n\n \nstatic int\nlimit_scaled_size_lock(struct bttv *btv, __s32 *width, __s32 *height,\n\t\t       enum v4l2_field field, unsigned int width_mask,\n\t\t       unsigned int width_bias, int adjust_size,\n\t\t       int adjust_crop)\n{\n\tconst struct v4l2_rect *b;\n\tstruct bttv_crop *c;\n\t__s32 min_width;\n\t__s32 min_height;\n\t__s32 max_width;\n\t__s32 max_height;\n\tint rc;\n\n\tWARN_ON((int)width_mask >= 0 ||\n\t\twidth_bias >= (unsigned int)(-width_mask));\n\n\t \n\n\tb = &bttv_tvnorms[btv->tvnorm].cropcap.bounds;\n\n\t \n\tc = &btv->crop[!!btv->do_crop];\n\n\tif (btv->do_crop\n\t    && adjust_size\n\t    && adjust_crop\n\t    && !locked_btres(btv, VIDEO_RESOURCES)) {\n\t\tmin_width = 48;\n\t\tmin_height = 32;\n\n\t\t \n\t\tmax_width = min_t(unsigned int, b->width, MAX_HACTIVE);\n\t\tmax_height = b->height;\n\n\t\t \n\t\tif (btv->vbi_end > b->top) {\n\t\t\tmax_height -= btv->vbi_end - b->top;\n\t\t\trc = -EBUSY;\n\t\t\tif (min_height > max_height)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\trc = -EBUSY;\n\t\tif (btv->vbi_end > c->rect.top)\n\t\t\tgoto fail;\n\n\t\tmin_width  = c->min_scaled_width;\n\t\tmin_height = c->min_scaled_height;\n\t\tmax_width  = c->max_scaled_width;\n\t\tmax_height = c->max_scaled_height;\n\n\t\tadjust_crop = 0;\n\t}\n\n\tmin_width = (min_width - width_mask - 1) & width_mask;\n\tmax_width = max_width & width_mask;\n\n\t \n\t \n\tmax_height >>= !V4L2_FIELD_HAS_BOTH(field);\n\n\tif (adjust_size) {\n\t\t*width = clamp(*width, min_width, max_width);\n\t\t*height = clamp(*height, min_height, max_height);\n\n\t\t \n\t\t*width = (*width + width_bias) & width_mask;\n\n\t\tif (adjust_crop) {\n\t\t\tbttv_crop_adjust(c, b, *width, *height, field);\n\n\t\t\tif (btv->vbi_end > c->rect.top) {\n\t\t\t\t \n\t\t\t\tc->rect.top = btv->vbi_end;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (*width  < min_width ||\n\t\t    *height < min_height ||\n\t\t    *width  > max_width ||\n\t\t    *height > max_height ||\n\t\t    0 != (*width & ~width_mask))\n\t\t\tgoto fail;\n\t}\n\n\trc = 0;  \n\n fail:\n\n\treturn rc;\n}\n\nstatic int bttv_switch_type(struct bttv *btv, enum v4l2_buf_type type)\n{\n\tint res;\n\tstruct vb2_queue *q;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tq = &btv->capq;\n\t\tres = RESOURCE_VIDEO_STREAM;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tq = &btv->vbiq;\n\t\tres = RESOURCE_VBI;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (check_btres(btv, res))\n\t\treturn -EBUSY;\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\tbtv->type = type;\n\n\treturn 0;\n}\n\nstatic void\npix_format_set_size     (struct v4l2_pix_format *       f,\n\t\t\t const struct bttv_format *     fmt,\n\t\t\t unsigned int                   width,\n\t\t\t unsigned int                   height)\n{\n\tf->width = width;\n\tf->height = height;\n\n\tif (fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\tf->bytesperline = width;  \n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else {\n\t\tf->bytesperline = (width * fmt->depth) >> 3;\n\t\tf->sizeimage = height * f->bytesperline;\n\t}\n}\n\nstatic int bttv_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tpix_format_set_size(&f->fmt.pix, btv->fmt, btv->width, btv->height);\n\tf->fmt.pix.field = btv->field;\n\tf->fmt.pix.pixelformat  = btv->fmt->fourcc;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic void bttv_get_width_mask_vid_cap(const struct bttv_format *fmt,\n\t\t\t\t\tunsigned int *width_mask,\n\t\t\t\t\tunsigned int *width_bias)\n{\n\tif (fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\t*width_mask = ~15;  \n\t\t*width_bias = 8;    \n\t} else {\n\t\t*width_mask = ~3;  \n\t\t*width_bias = 2;   \n\t}\n}\n\nstatic int bttv_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\t\tstruct v4l2_format *f)\n{\n\tconst struct bttv_format *fmt;\n\tstruct bttv *btv = video_drvdata(file);\n\tenum v4l2_field field;\n\t__s32 width, height;\n\t__s32 height2;\n\tunsigned int width_mask, width_bias;\n\tint rc;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_ALTERNATE:\n\tcase V4L2_FIELD_INTERLACED:\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tif (!(fmt->flags & FORMAT_FLAGS_PLANAR)) {\n\t\t\tfield = V4L2_FIELD_SEQ_TB;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:  \n\t\theight2 = btv->crop[!!btv->do_crop].rect.height >> 1;\n\t\tfield = (f->fmt.pix.height > height2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\t}\n\n\twidth = f->fmt.pix.width;\n\theight = f->fmt.pix.height;\n\n\tbttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);\n\trc = limit_scaled_size_lock(btv, &width, &height, field, width_mask,\n\t\t\t\t    width_bias, 1, 0);\n\tif (0 != rc)\n\t\treturn rc;\n\n\t \n\tf->fmt.pix.field = field;\n\tpix_format_set_size(&f->fmt.pix, fmt, width, height);\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int bttv_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tint retval;\n\tconst struct bttv_format *fmt;\n\tstruct bttv *btv = video_drvdata(file);\n\t__s32 width, height;\n\tunsigned int width_mask, width_bias;\n\tenum v4l2_field field;\n\n\tretval = bttv_switch_type(btv, f->type);\n\tif (0 != retval)\n\t\treturn retval;\n\n\tretval = bttv_try_fmt_vid_cap(file, priv, f);\n\tif (0 != retval)\n\t\treturn retval;\n\n\twidth = f->fmt.pix.width;\n\theight = f->fmt.pix.height;\n\tfield = f->fmt.pix.field;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tbttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);\n\tretval = limit_scaled_size_lock(btv, &width, &height, f->fmt.pix.field,\n\t\t\t\t\twidth_mask, width_bias, 1, 1);\n\tif (0 != retval)\n\t\treturn retval;\n\n\tf->fmt.pix.field = field;\n\n\t \n\tbtv->fmt = fmt;\n\tbtv->width = f->fmt.pix.width;\n\tbtv->height = f->fmt.pix.height;\n\tbtv->field = f->fmt.pix.field;\n\t \n\tbtv->field_last = V4L2_FIELD_BOTTOM;\n\n\treturn 0;\n}\n\nstatic int bttv_querycap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (0 == v4l2)\n\t\treturn -EINVAL;\n\n\tstrscpy(cap->driver, \"bttv\", sizeof(cap->driver));\n\tstrscpy(cap->card, btv->video_dev.name, sizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\n\tif (video_is_registered(&btv->vbi_dev))\n\t\tcap->capabilities |= V4L2_CAP_VBI_CAPTURE;\n\tif (video_is_registered(&btv->radio_dev)) {\n\t\tcap->capabilities |= V4L2_CAP_RADIO;\n\t\tif (btv->has_tea575x)\n\t\t\tcap->capabilities |= V4L2_CAP_HW_FREQ_SEEK;\n\t}\n\n\t \n\tif (btv->has_saa6588)\n\t\tcap->capabilities |= V4L2_CAP_RDS_CAPTURE;\n\tif (btv->tuner_type != TUNER_ABSENT)\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\treturn 0;\n}\n\nstatic int bttv_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tint index = -1, i;\n\n\tfor (i = 0; i < FORMATS; i++) {\n\t\tif (formats[i].fourcc != -1)\n\t\t\tindex++;\n\t\tif ((unsigned int)index == f->index)\n\t\t\tbreak;\n\t}\n\tif (FORMATS == i)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int bttv_g_parm(struct file *file, void *f,\n\t\t\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tparm->parm.capture.readbuffers = gbuffers;\n\tv4l2_video_std_frame_period(bttv_tvnorms[btv->tvnorm].v4l2_id,\n\t\t\t\t    &parm->parm.capture.timeperframe);\n\n\treturn 0;\n}\n\nstatic int bttv_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tt->rxsubchans = V4L2_TUNER_SUB_MONO;\n\tt->capability = V4L2_TUNER_CAP_NORM;\n\tbttv_call_all(btv, tuner, g_tuner, t);\n\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\tt->type       = V4L2_TUNER_ANALOG_TV;\n\tif (btread(BT848_DSTATUS)&BT848_DSTATUS_HLOC)\n\t\tt->signal = 0xffff;\n\n\tif (btv->audio_mode_gpio)\n\t\tbtv->audio_mode_gpio(btv, t, 0);\n\n\treturn 0;\n}\n\nstatic int bttv_g_pixelaspect(struct file *file, void *priv,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\t \n\t*f = bttv_tvnorms[btv->tvnorm].cropcap.pixelaspect;\n\treturn 0;\n}\n\nstatic int bttv_g_selection(struct file *file, void *f, struct v4l2_selection *sel)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = btv->crop[!!btv->do_crop].rect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r = bttv_tvnorms[btv->tvnorm].cropcap.defrect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r = bttv_tvnorms[btv->tvnorm].cropcap.bounds;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bttv_s_selection(struct file *file, void *f, struct v4l2_selection *sel)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tconst struct v4l2_rect *b;\n\tint retval;\n\tstruct bttv_crop c;\n\t__s32 b_left;\n\t__s32 b_top;\n\t__s32 b_right;\n\t__s32 b_bottom;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\tretval = -EBUSY;\n\n\tif (locked_btres(btv, VIDEO_RESOURCES))\n\t\treturn retval;\n\n\tb = &bttv_tvnorms[btv->tvnorm].cropcap.bounds;\n\n\tb_left = b->left;\n\tb_right = b_left + b->width;\n\tb_bottom = b->top + b->height;\n\n\tb_top = max(b->top, btv->vbi_end);\n\tif (b_top + 32 >= b_bottom) {\n\t\treturn retval;\n\t}\n\n\t \n\tc.rect.left = clamp_t(s32, sel->r.left, b_left, b_right - 48);\n\tc.rect.left = min(c.rect.left, (__s32) MAX_HDELAY);\n\n\tc.rect.width = clamp_t(s32, sel->r.width,\n\t\t\t     48, b_right - c.rect.left);\n\n\tc.rect.top = clamp_t(s32, sel->r.top, b_top, b_bottom - 32);\n\t \n\tc.rect.top = (c.rect.top + 1) & ~1;\n\n\tc.rect.height = clamp_t(s32, sel->r.height,\n\t\t\t      32, b_bottom - c.rect.top);\n\tc.rect.height = (c.rect.height + 1) & ~1;\n\n\tbttv_crop_calc_limits(&c);\n\n\tsel->r = c.rect;\n\n\tbtv->crop[1] = c;\n\n\tbtv->do_crop = 1;\n\n\tif (btv->width < c.min_scaled_width)\n\t\tbtv->width = c.min_scaled_width;\n\telse if (btv->width > c.max_scaled_width)\n\t\tbtv->width = c.max_scaled_width;\n\n\tif (btv->height < c.min_scaled_height)\n\t\tbtv->height = c.min_scaled_height;\n\telse if (btv->height > c.max_scaled_height)\n\t\tbtv->height = c.max_scaled_height;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations bttv_fops =\n{\n\t.owner\t\t  = THIS_MODULE,\n\t.open\t\t  = v4l2_fh_open,\n\t.release\t  = vb2_fop_release,\n\t.unlocked_ioctl\t  = video_ioctl2,\n\t.read\t\t  = vb2_fop_read,\n\t.mmap\t\t  = vb2_fop_mmap,\n\t.poll\t\t  = vb2_fop_poll,\n};\n\nstatic const struct v4l2_ioctl_ops bttv_ioctl_ops = {\n\t.vidioc_querycap                = bttv_querycap,\n\t.vidioc_enum_fmt_vid_cap        = bttv_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap           = bttv_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap         = bttv_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap           = bttv_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap           = bttv_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap         = bttv_try_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap           = bttv_s_fmt_vbi_cap,\n\t.vidioc_g_pixelaspect           = bttv_g_pixelaspect,\n\t.vidioc_reqbufs                 = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs             = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf                = vb2_ioctl_querybuf,\n\t.vidioc_qbuf                    = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf                   = vb2_ioctl_dqbuf,\n\t.vidioc_streamon                = vb2_ioctl_streamon,\n\t.vidioc_streamoff               = vb2_ioctl_streamoff,\n\t.vidioc_s_std                   = bttv_s_std,\n\t.vidioc_g_std                   = bttv_g_std,\n\t.vidioc_enum_input              = bttv_enum_input,\n\t.vidioc_g_input                 = bttv_g_input,\n\t.vidioc_s_input                 = bttv_s_input,\n\t.vidioc_g_tuner                 = bttv_g_tuner,\n\t.vidioc_s_tuner                 = bttv_s_tuner,\n\t.vidioc_g_selection             = bttv_g_selection,\n\t.vidioc_s_selection             = bttv_s_selection,\n\t.vidioc_g_parm                  = bttv_g_parm,\n\t.vidioc_g_frequency             = bttv_g_frequency,\n\t.vidioc_s_frequency             = bttv_s_frequency,\n\t.vidioc_log_status\t\t= bttv_log_status,\n\t.vidioc_querystd\t\t= bttv_querystd,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t\t= bttv_g_register,\n\t.vidioc_s_register\t\t= bttv_s_register,\n#endif\n};\n\nstatic struct video_device bttv_video_template = {\n\t.fops         = &bttv_fops,\n\t.ioctl_ops    = &bttv_ioctl_ops,\n\t.tvnorms      = BTTV_NORMS,\n};\n\n \n \n\nstatic int radio_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct bttv *btv = video_drvdata(file);\n\tint ret = v4l2_fh_open(file);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdprintk(\"open dev=%s\\n\", video_device_node_name(vdev));\n\tdprintk(\"%d: open called (radio)\\n\", btv->c.nr);\n\n\tbtv->radio_user++;\n\taudio_mute(btv, btv->mute);\n\n\treturn 0;\n}\n\nstatic int radio_release(struct file *file)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\n\tbtv->radio_user--;\n\n\tbttv_call_all(btv, core, command, SAA6588_CMD_CLOSE, &cmd);\n\n\tif (btv->radio_user == 0)\n\t\tbtv->has_radio_tuner = 0;\n\n\tv4l2_fh_release(file);\n\n\treturn 0;\n}\n\nstatic int radio_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\tstrscpy(t->name, \"Radio\", sizeof(t->name));\n\tt->type = V4L2_TUNER_RADIO;\n\tradio_enable(btv);\n\n\tbttv_call_all(btv, tuner, g_tuner, t);\n\n\tif (btv->audio_mode_gpio)\n\t\tbtv->audio_mode_gpio(btv, t, 0);\n\n\tif (btv->has_tea575x)\n\t\treturn snd_tea575x_g_tuner(&btv->tea, t);\n\n\treturn 0;\n}\n\nstatic int radio_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tradio_enable(btv);\n\tbttv_call_all(btv, tuner, s_tuner, t);\n\treturn 0;\n}\n\nstatic int radio_s_hw_freq_seek(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_hw_freq_seek *a)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (btv->has_tea575x)\n\t\treturn snd_tea575x_s_hw_freq_seek(file, &btv->tea, a);\n\n\treturn -ENOTTY;\n}\n\nstatic int radio_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_frequency_band *band)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\n\tif (btv->has_tea575x)\n\t\treturn snd_tea575x_enum_freq_bands(&btv->tea, band);\n\n\treturn -ENOTTY;\n}\n\nstatic ssize_t radio_read(struct file *file, char __user *data,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\n\tcmd.block_count = count / 3;\n\tcmd.nonblocking = file->f_flags & O_NONBLOCK;\n\tcmd.buffer = data;\n\tcmd.instance = file;\n\tcmd.result = -ENODEV;\n\tradio_enable(btv);\n\n\tbttv_call_all(btv, core, command, SAA6588_CMD_READ, &cmd);\n\n\treturn cmd.result;\n}\n\nstatic __poll_t radio_poll(struct file *file, poll_table *wait)\n{\n\tstruct bttv *btv = video_drvdata(file);\n\tstruct saa6588_command cmd;\n\t__poll_t rc = v4l2_ctrl_poll(file, wait);\n\n\tradio_enable(btv);\n\tcmd.instance = file;\n\tcmd.event_list = wait;\n\tcmd.poll_mask = 0;\n\tbttv_call_all(btv, core, command, SAA6588_CMD_POLL, &cmd);\n\n\treturn rc | cmd.poll_mask;\n}\n\nstatic const struct v4l2_file_operations radio_fops =\n{\n\t.owner\t  = THIS_MODULE,\n\t.open\t  = radio_open,\n\t.read     = radio_read,\n\t.release  = radio_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll     = radio_poll,\n};\n\nstatic const struct v4l2_ioctl_ops radio_ioctl_ops = {\n\t.vidioc_querycap        = bttv_querycap,\n\t.vidioc_log_status\t= bttv_log_status,\n\t.vidioc_g_tuner         = radio_g_tuner,\n\t.vidioc_s_tuner         = radio_s_tuner,\n\t.vidioc_g_frequency     = bttv_g_frequency,\n\t.vidioc_s_frequency     = bttv_s_frequency,\n\t.vidioc_s_hw_freq_seek\t= radio_s_hw_freq_seek,\n\t.vidioc_enum_freq_bands\t= radio_enum_freq_bands,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device radio_template = {\n\t.fops      = &radio_fops,\n\t.ioctl_ops = &radio_ioctl_ops,\n};\n\n \n \n\nstatic int bttv_risc_decode(u32 risc)\n{\n\tstatic char *instr[16] = {\n\t\t[ BT848_RISC_WRITE     >> 28 ] = \"write\",\n\t\t[ BT848_RISC_SKIP      >> 28 ] = \"skip\",\n\t\t[ BT848_RISC_WRITEC    >> 28 ] = \"writec\",\n\t\t[ BT848_RISC_JUMP      >> 28 ] = \"jump\",\n\t\t[ BT848_RISC_SYNC      >> 28 ] = \"sync\",\n\t\t[ BT848_RISC_WRITE123  >> 28 ] = \"write123\",\n\t\t[ BT848_RISC_SKIP123   >> 28 ] = \"skip123\",\n\t\t[ BT848_RISC_WRITE1S23 >> 28 ] = \"write1s23\",\n\t};\n\tstatic int incr[16] = {\n\t\t[ BT848_RISC_WRITE     >> 28 ] = 2,\n\t\t[ BT848_RISC_JUMP      >> 28 ] = 2,\n\t\t[ BT848_RISC_SYNC      >> 28 ] = 2,\n\t\t[ BT848_RISC_WRITE123  >> 28 ] = 5,\n\t\t[ BT848_RISC_SKIP123   >> 28 ] = 2,\n\t\t[ BT848_RISC_WRITE1S23 >> 28 ] = 3,\n\t};\n\tstatic char *bits[] = {\n\t\t\"be0\",  \"be1\",  \"be2\",  \"be3/resync\",\n\t\t\"set0\", \"set1\", \"set2\", \"set3\",\n\t\t\"clr0\", \"clr1\", \"clr2\", \"clr3\",\n\t\t\"irq\",  \"res\",  \"eol\",  \"sol\",\n\t};\n\tint i;\n\n\tpr_cont(\"0x%08x [ %s\", risc,\n\t       instr[risc >> 28] ? instr[risc >> 28] : \"INVALID\");\n\tfor (i = ARRAY_SIZE(bits)-1; i >= 0; i--)\n\t\tif (risc & (1 << (i + 12)))\n\t\t\tpr_cont(\" %s\", bits[i]);\n\tpr_cont(\" count=%d ]\\n\", risc & 0xfff);\n\treturn incr[risc >> 28] ? incr[risc >> 28] : 1;\n}\n\nstatic void bttv_risc_disasm(struct bttv *btv,\n\t\t\t     struct btcx_riscmem *risc)\n{\n\tunsigned int i,j,n;\n\n\tpr_info(\"%s: risc disasm: %p [dma=0x%08lx]\\n\",\n\t\tbtv->c.v4l2_dev.name, risc->cpu, (unsigned long)risc->dma);\n\tfor (i = 0; i < (risc->size >> 2); i += n) {\n\t\tpr_info(\"%s:   0x%lx: \",\n\t\t\tbtv->c.v4l2_dev.name,\n\t\t\t(unsigned long)(risc->dma + (i<<2)));\n\t\tn = bttv_risc_decode(le32_to_cpu(risc->cpu[i]));\n\t\tfor (j = 1; j < n; j++)\n\t\t\tpr_info(\"%s:   0x%lx: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\tbtv->c.v4l2_dev.name,\n\t\t\t\t(unsigned long)(risc->dma + ((i+j)<<2)),\n\t\t\t\trisc->cpu[i+j], j);\n\t\tif (0 == risc->cpu[i])\n\t\t\tbreak;\n\t}\n}\n\nstatic void bttv_print_riscaddr(struct bttv *btv)\n{\n\tpr_info(\"  main: %08llx\\n\", (unsigned long long)btv->main.dma);\n\tpr_info(\"  vbi : o=%08llx e=%08llx\\n\",\n\t\tbtv->cvbi ? (unsigned long long)btv->cvbi->top.dma : 0,\n\t\tbtv->cvbi ? (unsigned long long)btv->cvbi->bottom.dma : 0);\n\tpr_info(\"  cap : o=%08llx e=%08llx\\n\",\n\t\tbtv->curr.top\n\t\t? (unsigned long long)btv->curr.top->top.dma : 0,\n\t\tbtv->curr.bottom\n\t\t? (unsigned long long)btv->curr.bottom->bottom.dma : 0);\n\tbttv_risc_disasm(btv, &btv->main);\n}\n\n \n \n\nstatic char *irq_name[] = {\n\t\"FMTCHG\",   \n\t\"VSYNC\",    \n\t\"HSYNC\",    \n\t\"OFLOW\",    \n\t\"HLOCK\",    \n\t\"VPRES\",    \n\t\"6\", \"7\",\n\t\"I2CDONE\",  \n\t\"GPINT\",    \n\t\"10\",\n\t\"RISCI\",    \n\t\"FBUS\",     \n\t\"FTRGT\",    \n\t\"FDSR\",     \n\t\"PPERR\",    \n\t\"RIPERR\",   \n\t\"PABORT\",   \n\t\"OCERR\",    \n\t\"SCERR\",    \n};\n\nstatic void bttv_print_irqbits(u32 print, u32 mark)\n{\n\tunsigned int i;\n\n\tpr_cont(\"bits:\");\n\tfor (i = 0; i < ARRAY_SIZE(irq_name); i++) {\n\t\tif (print & (1 << i))\n\t\t\tpr_cont(\" %s\", irq_name[i]);\n\t\tif (mark & (1 << i))\n\t\t\tpr_cont(\"*\");\n\t}\n}\n\nstatic void bttv_irq_debug_low_latency(struct bttv *btv, u32 rc)\n{\n\tpr_warn(\"%d: irq: skipped frame [main=%lx,o_vbi=%lx,o_field=%lx,rc=%lx]\\n\",\n\t\tbtv->c.nr,\n\t\t(unsigned long)btv->main.dma,\n\t\t(unsigned long)le32_to_cpu(btv->main.cpu[RISC_SLOT_O_VBI+1]),\n\t\t(unsigned long)le32_to_cpu(btv->main.cpu[RISC_SLOT_O_FIELD+1]),\n\t\t(unsigned long)rc);\n\n\tif (0 == (btread(BT848_DSTATUS) & BT848_DSTATUS_HLOC)) {\n\t\tpr_notice(\"%d: Oh, there (temporarily?) is no input signal. Ok, then this is harmless, don't worry ;)\\n\",\n\t\t\t  btv->c.nr);\n\t\treturn;\n\t}\n\tpr_notice(\"%d: Uhm. Looks like we have unusual high IRQ latencies\\n\",\n\t\t  btv->c.nr);\n\tpr_notice(\"%d: Lets try to catch the culprit red-handed ...\\n\",\n\t\t  btv->c.nr);\n\tdump_stack();\n}\n\nstatic int\nbttv_irq_next_video(struct bttv *btv, struct bttv_buffer_set *set)\n{\n\tstruct bttv_buffer *item;\n\n\tmemset(set,0,sizeof(*set));\n\n\t \n\tif (!list_empty(&btv->capture)) {\n\t\tset->frame_irq = BT848_RISC_VIDEO;\n\t\titem = list_entry(btv->capture.next, struct bttv_buffer, list);\n\n\t\tif (V4L2_FIELD_HAS_TOP(item->vbuf.field))\n\t\t\tset->top    = item;\n\t\tif (V4L2_FIELD_HAS_BOTTOM(item->vbuf.field))\n\t\t\tset->bottom = item;\n\n\t\t \n\t\tif (!V4L2_FIELD_HAS_BOTH(item->vbuf.field) &&\n\t\t    item->list.next != &btv->capture) {\n\t\t\titem = list_entry(item->list.next,\n\t\t\t\t\t  struct bttv_buffer, list);\n\t\t\t \n\t\t\tif (!V4L2_FIELD_HAS_BOTH(item->vbuf.field)) {\n\t\t\t\tif (!set->bottom &&\n\t\t\t\t    item->vbuf.field == V4L2_FIELD_BOTTOM)\n\t\t\t\t\tset->bottom = item;\n\t\t\t\tif (set->top && set->bottom) {\n\t\t\t\t\t \n\t\t\t\t\tset->top_irq = BT848_RISC_TOP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdprintk(\"%d: next set: top=%p bottom=%p [irq=%d,%d]\\n\",\n\t\tbtv->c.nr, set->top, set->bottom,\n\t\tset->frame_irq, set->top_irq);\n\treturn 0;\n}\n\nstatic void\nbttv_irq_wakeup_video(struct bttv *btv, struct bttv_buffer_set *wakeup,\n\t\t      struct bttv_buffer_set *curr, unsigned int state)\n{\n\tu64 ts = ktime_get_ns();\n\n\tif (wakeup->top == wakeup->bottom) {\n\t\tif (NULL != wakeup->top && curr->top != wakeup->top) {\n\t\t\tif (irq_debug > 1)\n\t\t\t\tpr_debug(\"%d: wakeup: both=%p\\n\",\n\t\t\t\t\t btv->c.nr, wakeup->top);\n\t\t\twakeup->top->vbuf.vb2_buf.timestamp = ts;\n\t\t\twakeup->top->vbuf.sequence = btv->field_count >> 1;\n\t\t\tvb2_buffer_done(&wakeup->top->vbuf.vb2_buf, state);\n\t\t\tif (btv->field_count == 0)\n\t\t\t\tbtor(BT848_INT_VSYNC, BT848_INT_MASK);\n\t\t}\n\t} else {\n\t\tif (NULL != wakeup->top && curr->top != wakeup->top) {\n\t\t\tif (irq_debug > 1)\n\t\t\t\tpr_debug(\"%d: wakeup: top=%p\\n\",\n\t\t\t\t\t btv->c.nr, wakeup->top);\n\t\t\twakeup->top->vbuf.vb2_buf.timestamp = ts;\n\t\t\twakeup->top->vbuf.sequence = btv->field_count >> 1;\n\t\t\tvb2_buffer_done(&wakeup->top->vbuf.vb2_buf, state);\n\t\t\tif (btv->field_count == 0)\n\t\t\t\tbtor(BT848_INT_VSYNC, BT848_INT_MASK);\n\t\t}\n\t\tif (NULL != wakeup->bottom && curr->bottom != wakeup->bottom) {\n\t\t\tif (irq_debug > 1)\n\t\t\t\tpr_debug(\"%d: wakeup: bottom=%p\\n\",\n\t\t\t\t\t btv->c.nr, wakeup->bottom);\n\t\t\twakeup->bottom->vbuf.vb2_buf.timestamp = ts;\n\t\t\twakeup->bottom->vbuf.sequence = btv->field_count >> 1;\n\t\t\tvb2_buffer_done(&wakeup->bottom->vbuf.vb2_buf, state);\n\t\t\tif (btv->field_count == 0)\n\t\t\t\tbtor(BT848_INT_VSYNC, BT848_INT_MASK);\n\t\t}\n\t}\n}\n\nstatic void\nbttv_irq_wakeup_vbi(struct bttv *btv, struct bttv_buffer *wakeup,\n\t\t\t\tunsigned int state)\n{\n\tif (NULL == wakeup)\n\t\treturn;\n\twakeup->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\twakeup->vbuf.sequence = btv->field_count >> 1;\n\n\t \n\tif (vb2_fileio_is_active(wakeup->vbuf.vb2_buf.vb2_queue)) {\n\t\tu32 *vaddr = vb2_plane_vaddr(&wakeup->vbuf.vb2_buf, 0);\n\t\tunsigned long size =\n\t\t\tvb2_get_plane_payload(&wakeup->vbuf.vb2_buf, 0) / 4;\n\n\t\tif (vaddr && size) {\n\t\t\tvaddr += size - 1;\n\t\t\t*vaddr = wakeup->vbuf.sequence;\n\t\t}\n\t}\n\n\tvb2_buffer_done(&wakeup->vbuf.vb2_buf, state);\n\tif (btv->field_count == 0)\n\t\tbtor(BT848_INT_VSYNC, BT848_INT_MASK);\n}\n\nstatic void bttv_irq_timeout(struct timer_list *t)\n{\n\tstruct bttv *btv = from_timer(btv, t, timeout);\n\tstruct bttv_buffer_set old,new;\n\tstruct bttv_buffer *ovbi;\n\tstruct bttv_buffer *item;\n\tunsigned long flags;\n\tint seqnr = 0;\n\n\tif (bttv_verbose) {\n\t\tpr_info(\"%d: timeout: drop=%d irq=%d/%d, risc=%08x, \",\n\t\t\tbtv->c.nr, btv->framedrop, btv->irq_me, btv->irq_total,\n\t\t\tbtread(BT848_RISC_COUNT));\n\t\tbttv_print_irqbits(btread(BT848_INT_STAT),0);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tspin_lock_irqsave(&btv->s_lock,flags);\n\n\t \n\tmemset(&new,0,sizeof(new));\n\told  = btv->curr;\n\tovbi = btv->cvbi;\n\tbtv->curr = new;\n\tbtv->cvbi = NULL;\n\tbtv->loop_irq = 0;\n\tbttv_buffer_activate_video(btv, &new);\n\tbttv_buffer_activate_vbi(btv,   NULL);\n\tbttv_set_dma(btv, 0);\n\n\t \n\tbttv_irq_wakeup_video(btv, &old, &new, VB2_BUF_STATE_DONE);\n\tbttv_irq_wakeup_vbi(btv, ovbi, VB2_BUF_STATE_DONE);\n\n\t \n\tif (btv->field_count)\n\t\tseqnr++;\n\twhile (!list_empty(&btv->capture)) {\n\t\titem = list_entry(btv->capture.next, struct bttv_buffer, list);\n\t\tlist_del(&item->list);\n\t\titem->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\t\titem->vbuf.sequence = (btv->field_count >> 1) + seqnr++;\n\t\tvb2_buffer_done(&item->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\twhile (!list_empty(&btv->vcapture)) {\n\t\titem = list_entry(btv->vcapture.next, struct bttv_buffer, list);\n\t\tlist_del(&item->list);\n\t\titem->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\t\titem->vbuf.sequence = (btv->field_count >> 1) + seqnr++;\n\t\tvb2_buffer_done(&item->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tbtv->errors++;\n\tspin_unlock_irqrestore(&btv->s_lock,flags);\n}\n\nstatic void\nbttv_irq_wakeup_top(struct bttv *btv)\n{\n\tstruct bttv_buffer *wakeup = btv->curr.top;\n\n\tif (NULL == wakeup)\n\t\treturn;\n\n\tspin_lock(&btv->s_lock);\n\tbtv->curr.top_irq = 0;\n\tbtv->curr.top = NULL;\n\tbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\n\twakeup->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\twakeup->vbuf.sequence = btv->field_count >> 1;\n\tvb2_buffer_done(&wakeup->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\n\tif (btv->field_count == 0)\n\t\tbtor(BT848_INT_VSYNC, BT848_INT_MASK);\n\tspin_unlock(&btv->s_lock);\n}\n\nstatic inline int is_active(struct btcx_riscmem *risc, u32 rc)\n{\n\tif (rc < risc->dma)\n\t\treturn 0;\n\tif (rc > risc->dma + risc->size)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nbttv_irq_switch_video(struct bttv *btv)\n{\n\tstruct bttv_buffer_set new;\n\tstruct bttv_buffer_set old;\n\tdma_addr_t rc;\n\n\tspin_lock(&btv->s_lock);\n\n\t \n\tbttv_irq_next_video(btv, &new);\n\trc = btread(BT848_RISC_COUNT);\n\tif ((btv->curr.top    && is_active(&btv->curr.top->top,       rc)) ||\n\t    (btv->curr.bottom && is_active(&btv->curr.bottom->bottom, rc))) {\n\t\tbtv->framedrop++;\n\t\tif (debug_latency)\n\t\t\tbttv_irq_debug_low_latency(btv, rc);\n\t\tspin_unlock(&btv->s_lock);\n\t\treturn;\n\t}\n\n\t \n\told = btv->curr;\n\tbtv->curr = new;\n\tbtv->loop_irq &= ~BT848_RISC_VIDEO;\n\tbttv_buffer_activate_video(btv, &new);\n\tbttv_set_dma(btv, 0);\n\n\t \n\tif (UNSET != btv->new_input) {\n\t\tvideo_mux(btv,btv->new_input);\n\t\tbtv->new_input = UNSET;\n\t}\n\n\t \n\tbttv_irq_wakeup_video(btv, &old, &new, VB2_BUF_STATE_DONE);\n\tspin_unlock(&btv->s_lock);\n}\n\nstatic void\nbttv_irq_switch_vbi(struct bttv *btv)\n{\n\tstruct bttv_buffer *new = NULL;\n\tstruct bttv_buffer *old;\n\tu32 rc;\n\n\tspin_lock(&btv->s_lock);\n\n\tif (!list_empty(&btv->vcapture))\n\t\tnew = list_entry(btv->vcapture.next, struct bttv_buffer, list);\n\told = btv->cvbi;\n\n\trc = btread(BT848_RISC_COUNT);\n\tif (NULL != old && (is_active(&old->top,    rc) ||\n\t\t\t    is_active(&old->bottom, rc))) {\n\t\tbtv->framedrop++;\n\t\tif (debug_latency)\n\t\t\tbttv_irq_debug_low_latency(btv, rc);\n\t\tspin_unlock(&btv->s_lock);\n\t\treturn;\n\t}\n\n\t \n\tbtv->cvbi = new;\n\tbtv->loop_irq &= ~BT848_RISC_VBI;\n\tbttv_buffer_activate_vbi(btv, new);\n\tbttv_set_dma(btv, 0);\n\n\tbttv_irq_wakeup_vbi(btv, old, VB2_BUF_STATE_DONE);\n\tspin_unlock(&btv->s_lock);\n}\n\nstatic irqreturn_t bttv_irq(int irq, void *dev_id)\n{\n\tu32 stat,astat;\n\tu32 dstat;\n\tint count;\n\tstruct bttv *btv;\n\tint handled = 0;\n\n\tbtv=(struct bttv *)dev_id;\n\n\tcount=0;\n\twhile (1) {\n\t\t \n\t\tstat=btread(BT848_INT_STAT);\n\t\tastat=stat&btread(BT848_INT_MASK);\n\t\tif (!astat)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\tbtwrite(stat,BT848_INT_STAT);\n\n\t\t \n\t\tdstat=btread(BT848_DSTATUS);\n\n\t\tif (irq_debug) {\n\t\t\tpr_debug(\"%d: irq loop=%d fc=%d riscs=%x, riscc=%08x, \",\n\t\t\t\t btv->c.nr, count, btv->field_count,\n\t\t\t\t stat>>28, btread(BT848_RISC_COUNT));\n\t\t\tbttv_print_irqbits(stat,astat);\n\t\t\tif (stat & BT848_INT_HLOCK)\n\t\t\t\tpr_cont(\"   HLOC => %s\",\n\t\t\t\t\tdstat & BT848_DSTATUS_HLOC\n\t\t\t\t\t? \"yes\" : \"no\");\n\t\t\tif (stat & BT848_INT_VPRES)\n\t\t\t\tpr_cont(\"   PRES => %s\",\n\t\t\t\t\tdstat & BT848_DSTATUS_PRES\n\t\t\t\t\t? \"yes\" : \"no\");\n\t\t\tif (stat & BT848_INT_FMTCHG)\n\t\t\t\tpr_cont(\"   NUML => %s\",\n\t\t\t\t\tdstat & BT848_DSTATUS_NUML\n\t\t\t\t\t? \"625\" : \"525\");\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\n\t\tif (astat&BT848_INT_VSYNC)\n\t\t\tbtv->field_count++;\n\n\t\tif ((astat & BT848_INT_GPINT) && btv->remote) {\n\t\t\tbttv_input_irq(btv);\n\t\t}\n\n\t\tif (astat & BT848_INT_I2CDONE) {\n\t\t\tbtv->i2c_done = stat;\n\t\t\twake_up(&btv->i2c_queue);\n\t\t}\n\n\t\tif ((astat & BT848_INT_RISCI) && (stat & BT848_INT_RISCS_VBI))\n\t\t\tbttv_irq_switch_vbi(btv);\n\n\t\tif ((astat & BT848_INT_RISCI) && (stat & BT848_INT_RISCS_TOP))\n\t\t\tbttv_irq_wakeup_top(btv);\n\n\t\tif ((astat & BT848_INT_RISCI) && (stat & BT848_INT_RISCS_VIDEO))\n\t\t\tbttv_irq_switch_video(btv);\n\n\t\tif ((astat & BT848_INT_HLOCK)  &&  btv->opt_automute)\n\t\t\t \n\t\t\taudio_mux_gpio(btv, btv->audio_input, btv->mute);\n\n\t\tif (astat & (BT848_INT_SCERR|BT848_INT_OCERR)) {\n\t\t\tpr_info(\"%d: %s%s @ %08x,\",\n\t\t\t\tbtv->c.nr,\n\t\t\t\t(astat & BT848_INT_SCERR) ? \"SCERR\" : \"\",\n\t\t\t\t(astat & BT848_INT_OCERR) ? \"OCERR\" : \"\",\n\t\t\t\tbtread(BT848_RISC_COUNT));\n\t\t\tbttv_print_irqbits(stat,astat);\n\t\t\tpr_cont(\"\\n\");\n\t\t\tif (bttv_debug)\n\t\t\t\tbttv_print_riscaddr(btv);\n\t\t}\n\t\tif (fdsr && astat & BT848_INT_FDSR) {\n\t\t\tpr_info(\"%d: FDSR @ %08x\\n\",\n\t\t\t\tbtv->c.nr, btread(BT848_RISC_COUNT));\n\t\t\tif (bttv_debug)\n\t\t\t\tbttv_print_riscaddr(btv);\n\t\t}\n\n\t\tcount++;\n\t\tif (count > 4) {\n\n\t\t\tif (count > 8 || !(astat & BT848_INT_GPINT)) {\n\t\t\t\tbtwrite(0, BT848_INT_MASK);\n\n\t\t\t\tpr_err(\"%d: IRQ lockup, cleared int mask [\",\n\t\t\t\t       btv->c.nr);\n\t\t\t} else {\n\t\t\t\tpr_err(\"%d: IRQ lockup, clearing GPINT from int mask [\",\n\t\t\t\t       btv->c.nr);\n\n\t\t\t\tbtwrite(btread(BT848_INT_MASK) & (-1 ^ BT848_INT_GPINT),\n\t\t\t\t\t\tBT848_INT_MASK);\n\t\t\t}\n\n\t\t\tbttv_print_irqbits(stat,astat);\n\n\t\t\tpr_cont(\"]\\n\");\n\t\t}\n\t}\n\tbtv->irq_total++;\n\tif (handled)\n\t\tbtv->irq_me++;\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \n \n\nstatic int vdev_init(struct bttv *btv, struct video_device *vfd,\n\t\t     const struct video_device *template,\n\t\t     const char *type_name)\n{\n\tint err;\n\tstruct vb2_queue *q;\n\t*vfd = *template;\n\tvfd->v4l2_dev = &btv->c.v4l2_dev;\n\tvfd->release = video_device_release_empty;\n\tvideo_set_drvdata(vfd, btv);\n\tsnprintf(vfd->name, sizeof(vfd->name), \"BT%d%s %s (%s)\",\n\t\t btv->id, (btv->id==848 && btv->revision==0x12) ? \"A\" : \"\",\n\t\t type_name, bttv_tvcards[btv->c.type].name);\n\tif (btv->tuner_type == TUNER_ABSENT) {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\n\t}\n\n\tif (strcmp(type_name, \"radio\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(type_name, \"video\") == 0) {\n\t\tq = &btv->capq;\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->ops = &bttv_video_qops;\n\t} else if (strcmp(type_name, \"vbi\") == 0) {\n\t\tq = &btv->vbiq;\n\t\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\t\tq->ops = &bttv_vbi_qops;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ | VB2_DMABUF;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->drv_priv = btv;\n\tq->gfp_flags = __GFP_DMA32;\n\tq->buf_struct_size = sizeof(struct bttv_buffer);\n\tq->lock = &btv->lock;\n\tq->min_buffers_needed = 2;\n\tq->dev = &btv->c.pci->dev;\n\terr = vb2_queue_init(q);\n\tif (err)\n\t\treturn err;\n\tvfd->queue = q;\n\n\treturn 0;\n}\n\nstatic void bttv_unregister_video(struct bttv *btv)\n{\n\tvideo_unregister_device(&btv->video_dev);\n\tvideo_unregister_device(&btv->vbi_dev);\n\tvideo_unregister_device(&btv->radio_dev);\n}\n\n \nstatic int bttv_register_video(struct bttv *btv)\n{\n\t \n\tvdev_init(btv, &btv->video_dev, &bttv_video_template, \"video\");\n\tbtv->video_dev.device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t     V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n\tif (btv->tuner_type != TUNER_ABSENT)\n\t\tbtv->video_dev.device_caps |= V4L2_CAP_TUNER;\n\n\tif (video_register_device(&btv->video_dev, VFL_TYPE_VIDEO,\n\t\t\t\t  video_nr[btv->c.nr]) < 0)\n\t\tgoto err;\n\tpr_info(\"%d: registered device %s\\n\",\n\t\tbtv->c.nr, video_device_node_name(&btv->video_dev));\n\tif (device_create_file(&btv->video_dev.dev,\n\t\t\t\t     &dev_attr_card)<0) {\n\t\tpr_err(\"%d: device_create_file 'card' failed\\n\", btv->c.nr);\n\t\tgoto err;\n\t}\n\n\t \n\tvdev_init(btv, &btv->vbi_dev, &bttv_video_template, \"vbi\");\n\tbtv->vbi_dev.device_caps = V4L2_CAP_VBI_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t\t   V4L2_CAP_STREAMING;\n\tif (btv->tuner_type != TUNER_ABSENT)\n\t\tbtv->vbi_dev.device_caps |= V4L2_CAP_TUNER;\n\n\tif (video_register_device(&btv->vbi_dev, VFL_TYPE_VBI,\n\t\t\t\t  vbi_nr[btv->c.nr]) < 0)\n\t\tgoto err;\n\tpr_info(\"%d: registered device %s\\n\",\n\t\tbtv->c.nr, video_device_node_name(&btv->vbi_dev));\n\n\tif (!btv->has_radio)\n\t\treturn 0;\n\t \n\tvdev_init(btv, &btv->radio_dev, &radio_template, \"radio\");\n\tbtv->radio_dev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\tif (btv->has_saa6588)\n\t\tbtv->radio_dev.device_caps |= V4L2_CAP_READWRITE |\n\t\t\t\t\t      V4L2_CAP_RDS_CAPTURE;\n\tif (btv->has_tea575x)\n\t\tbtv->radio_dev.device_caps |= V4L2_CAP_HW_FREQ_SEEK;\n\tbtv->radio_dev.ctrl_handler = &btv->radio_ctrl_handler;\n\tif (video_register_device(&btv->radio_dev, VFL_TYPE_RADIO,\n\t\t\t\t  radio_nr[btv->c.nr]) < 0)\n\t\tgoto err;\n\tpr_info(\"%d: registered device %s\\n\",\n\t\tbtv->c.nr, video_device_node_name(&btv->radio_dev));\n\n\t \n\treturn 0;\n\n err:\n\tbttv_unregister_video(btv);\n\treturn -1;\n}\n\n\n \n \nstatic void pci_set_command(struct pci_dev *dev)\n{\n#if defined(__powerpc__)\n\tunsigned int cmd;\n\n\tpci_read_config_dword(dev, PCI_COMMAND, &cmd);\n\tcmd = (cmd | PCI_COMMAND_MEMORY );\n\tpci_write_config_dword(dev, PCI_COMMAND, cmd);\n#endif\n}\n\nstatic int bttv_probe(struct pci_dev *dev, const struct pci_device_id *pci_id)\n{\n\tstruct v4l2_frequency init_freq = {\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ANALOG_TV,\n\t\t.frequency = 980,\n\t};\n\tint result;\n\tunsigned char lat;\n\tstruct bttv *btv;\n\tstruct v4l2_ctrl_handler *hdl;\n\n\tif (bttv_num == BTTV_MAX)\n\t\treturn -ENOMEM;\n\tpr_info(\"Bt8xx card found (%d)\\n\", bttv_num);\n\tbttvs[bttv_num] = btv = kzalloc(sizeof(*btv), GFP_KERNEL);\n\tif (btv == NULL) {\n\t\tpr_err(\"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbtv->c.nr  = bttv_num;\n\tsnprintf(btv->c.v4l2_dev.name, sizeof(btv->c.v4l2_dev.name),\n\t\t\t\"bttv%d\", btv->c.nr);\n\n\t \n\tmutex_init(&btv->lock);\n\tspin_lock_init(&btv->s_lock);\n\tspin_lock_init(&btv->gpio_lock);\n\tinit_waitqueue_head(&btv->i2c_queue);\n\tINIT_LIST_HEAD(&btv->c.subs);\n\tINIT_LIST_HEAD(&btv->capture);\n\tINIT_LIST_HEAD(&btv->vcapture);\n\n\ttimer_setup(&btv->timeout, bttv_irq_timeout, 0);\n\n\tbtv->i2c_rc = -1;\n\tbtv->tuner_type  = UNSET;\n\tbtv->new_input   = UNSET;\n\tbtv->has_radio=radio[btv->c.nr];\n\n\t \n\tbtv->c.pci = dev;\n\tbtv->id  = dev->device;\n\tif (pci_enable_device(dev)) {\n\t\tpr_warn(\"%d: Can't enable device\\n\", btv->c.nr);\n\t\tresult = -EIO;\n\t\tgoto free_mem;\n\t}\n\tif (dma_set_mask(&dev->dev, DMA_BIT_MASK(32))) {\n\t\tpr_warn(\"%d: No suitable DMA available\\n\", btv->c.nr);\n\t\tresult = -EIO;\n\t\tgoto free_mem;\n\t}\n\tif (!request_mem_region(pci_resource_start(dev,0),\n\t\t\t\tpci_resource_len(dev,0),\n\t\t\t\tbtv->c.v4l2_dev.name)) {\n\t\tpr_warn(\"%d: can't request iomem (0x%llx)\\n\",\n\t\t\tbtv->c.nr,\n\t\t\t(unsigned long long)pci_resource_start(dev, 0));\n\t\tresult = -EBUSY;\n\t\tgoto free_mem;\n\t}\n\tpci_set_master(dev);\n\tpci_set_command(dev);\n\n\tresult = v4l2_device_register(&dev->dev, &btv->c.v4l2_dev);\n\tif (result < 0) {\n\t\tpr_warn(\"%d: v4l2_device_register() failed\\n\", btv->c.nr);\n\t\tgoto fail0;\n\t}\n\thdl = &btv->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 20);\n\tbtv->c.v4l2_dev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(&btv->radio_ctrl_handler, 6);\n\n\tbtv->revision = dev->revision;\n\tpci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\n\tpr_info(\"%d: Bt%d (rev %d) at %s, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tbttv_num, btv->id, btv->revision, pci_name(dev),\n\t\tbtv->c.pci->irq, lat,\n\t\t(unsigned long long)pci_resource_start(dev, 0));\n\tschedule();\n\n\tbtv->bt848_mmio = ioremap(pci_resource_start(dev, 0), 0x1000);\n\tif (NULL == btv->bt848_mmio) {\n\t\tpr_err(\"%d: ioremap() failed\\n\", btv->c.nr);\n\t\tresult = -EIO;\n\t\tgoto fail1;\n\t}\n\n\t \n\tbttv_idcard(btv);\n\n\t \n\tbtwrite(0, BT848_INT_MASK);\n\tresult = request_irq(btv->c.pci->irq, bttv_irq,\n\t    IRQF_SHARED, btv->c.v4l2_dev.name, (void *)btv);\n\tif (result < 0) {\n\t\tpr_err(\"%d: can't get IRQ %d\\n\",\n\t\t       bttv_num, btv->c.pci->irq);\n\t\tgoto fail1;\n\t}\n\n\tif (0 != bttv_handle_chipset(btv)) {\n\t\tresult = -EIO;\n\t\tgoto fail2;\n\t}\n\n\t \n\tbtv->opt_combfilter = combfilter;\n\tbttv_ctrl_combfilter.def = combfilter;\n\tbttv_ctrl_lumafilter.def = lumafilter;\n\tbtv->opt_automute   = automute;\n\tbttv_ctrl_automute.def = automute;\n\tbttv_ctrl_agc_crush.def = agc_crush;\n\tbtv->opt_vcr_hack   = vcr_hack;\n\tbttv_ctrl_vcr_hack.def = vcr_hack;\n\tbttv_ctrl_whitecrush_upper.def = whitecrush_upper;\n\tbttv_ctrl_whitecrush_lower.def = whitecrush_lower;\n\tbtv->opt_uv_ratio   = uv_ratio;\n\tbttv_ctrl_uv_ratio.def = uv_ratio;\n\tbttv_ctrl_full_luma.def = full_luma_range;\n\tbttv_ctrl_coring.def = coring;\n\n\t \n\tbtv->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\n\tbtv->width = 320;\n\tbtv->height = 240;\n\tbtv->field = V4L2_FIELD_INTERLACED;\n\tbtv->input = 0;\n\tbtv->tvnorm = 0;  \n\tbttv_vbi_fmt_reset(&btv->vbi_fmt, btv->tvnorm);\n\tbtv->vbi_count[0] = VBI_DEFLINES;\n\tbtv->vbi_count[1] = VBI_DEFLINES;\n\tbtv->do_crop = 0;\n\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 0xff00, 0x100, 32768);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 0xff80, 0x80, 0x6c00);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 0xff80, 0x80, 32768);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, 0xff00, 0x100, 32768);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_CHROMA_AGC, 0, 1, 1, !!chroma_agc);\n\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tif (btv->volume_gpio)\n\t\tv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, 0xff00, 0x100, 0xff00);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_combfilter, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_automute, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_lumafilter, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_agc_crush, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_vcr_hack, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_whitecrush_lower, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_whitecrush_upper, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_uv_ratio, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_full_luma, NULL);\n\tv4l2_ctrl_new_custom(hdl, &bttv_ctrl_coring, NULL);\n\n\t \n\tif (bttv_gpio)\n\t\tbttv_gpio_tracking(btv,\"pre-init\");\n\n\tbttv_risc_init_main(btv);\n\tinit_bt848(btv);\n\n\t \n\tbtwrite(0x00, BT848_GPIO_REG_INP);\n\tbtwrite(0x00, BT848_GPIO_OUT_EN);\n\tif (bttv_verbose)\n\t\tbttv_gpio_tracking(btv,\"init\");\n\n\t \n\tbttv_init_card1(btv);\n\n\t \n\tinit_bttv_i2c(btv);\n\n\t \n\tbttv_init_card2(btv);\n\tbttv_init_tuner(btv);\n\tif (btv->tuner_type != TUNER_ABSENT) {\n\t\tbttv_set_frequency(btv, &init_freq);\n\t\tbtv->radio_freq = 90500 * 16;  \n\t}\n\tbtv->std = V4L2_STD_PAL;\n\tinit_irqreg(btv);\n\tif (!bttv_tvcards[btv->c.type].no_video)\n\t\tv4l2_ctrl_handler_setup(hdl);\n\tif (hdl->error) {\n\t\tresult = hdl->error;\n\t\tgoto fail2;\n\t}\n\t \n\taudio_mute(btv, 1);\n\n\t \n\tif (!bttv_tvcards[btv->c.type].no_video) {\n\t\tv4l2_ctrl_add_handler(&btv->radio_ctrl_handler, hdl,\n\t\t\t\tv4l2_ctrl_radio_filter, false);\n\t\tif (btv->radio_ctrl_handler.error) {\n\t\t\tresult = btv->radio_ctrl_handler.error;\n\t\t\tgoto fail2;\n\t\t}\n\t\tset_input(btv, btv->input, btv->tvnorm);\n\t\tbttv_crop_reset(&btv->crop[0], btv->tvnorm);\n\t\tbtv->crop[1] = btv->crop[0];  \n\t\tdisclaim_vbi_lines(btv);\n\t\tdisclaim_video_lines(btv);\n\t\tbttv_register_video(btv);\n\t}\n\n\t \n\tif (bttv_tvcards[btv->c.type].has_dvb) {\n\t\tbttv_sub_add_device(&btv->c, \"dvb\");\n\t\trequest_modules(btv);\n\t}\n\n\tif (!disable_ir) {\n\t\tinit_bttv_i2c_ir(btv);\n\t\tbttv_input_init(btv);\n\t}\n\n\t \n\tbttv_num++;\n\treturn 0;\n\nfail2:\n\tfree_irq(btv->c.pci->irq,btv);\n\nfail1:\n\tv4l2_ctrl_handler_free(&btv->ctrl_handler);\n\tv4l2_ctrl_handler_free(&btv->radio_ctrl_handler);\n\tv4l2_device_unregister(&btv->c.v4l2_dev);\n\nfail0:\n\tif (btv->bt848_mmio)\n\t\tiounmap(btv->bt848_mmio);\n\trelease_mem_region(pci_resource_start(btv->c.pci,0),\n\t\t\t   pci_resource_len(btv->c.pci,0));\n\tpci_disable_device(btv->c.pci);\n\nfree_mem:\n\tbttvs[btv->c.nr] = NULL;\n\tkfree(btv);\n\treturn result;\n}\n\nstatic void bttv_remove(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct bttv *btv = to_bttv(v4l2_dev);\n\n\tif (bttv_verbose)\n\t\tpr_info(\"%d: unloading\\n\", btv->c.nr);\n\n\tif (bttv_tvcards[btv->c.type].has_dvb)\n\t\tflush_request_modules(btv);\n\n\t \n\tbtand(~15, BT848_GPIO_DMA_CTL);\n\tbtwrite(0, BT848_INT_MASK);\n\tbtwrite(~0x0, BT848_INT_STAT);\n\tbtwrite(0x0, BT848_GPIO_OUT_EN);\n\tif (bttv_gpio)\n\t\tbttv_gpio_tracking(btv,\"cleanup\");\n\n\t \n\tbtv->shutdown=1;\n\tbttv_input_fini(btv);\n\tbttv_sub_del_devices(&btv->c);\n\n\t \n\tfini_bttv_i2c(btv);\n\n\t \n\tbttv_unregister_video(btv);\n\n\t \n\tv4l2_ctrl_handler_free(&btv->ctrl_handler);\n\tv4l2_ctrl_handler_free(&btv->radio_ctrl_handler);\n\tbtcx_riscmem_free(btv->c.pci,&btv->main);\n\n\t \n\tfree_irq(btv->c.pci->irq,btv);\n\tdel_timer_sync(&btv->timeout);\n\tiounmap(btv->bt848_mmio);\n\trelease_mem_region(pci_resource_start(btv->c.pci,0),\n\t\t\t   pci_resource_len(btv->c.pci,0));\n\tpci_disable_device(btv->c.pci);\n\n\tv4l2_device_unregister(&btv->c.v4l2_dev);\n\tbttvs[btv->c.nr] = NULL;\n\tkfree(btv);\n\n\treturn;\n}\n\nstatic int __maybe_unused bttv_suspend(struct device *dev)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct bttv *btv = to_bttv(v4l2_dev);\n\tstruct bttv_buffer_set idle;\n\tunsigned long flags;\n\n\tdprintk(\"%d: suspend\\n\", btv->c.nr);\n\n\t \n\tspin_lock_irqsave(&btv->s_lock,flags);\n\tmemset(&idle, 0, sizeof(idle));\n\tbtv->state.video = btv->curr;\n\tbtv->state.vbi   = btv->cvbi;\n\tbtv->state.loop_irq = btv->loop_irq;\n\tbtv->curr = idle;\n\tbtv->loop_irq = 0;\n\tbttv_buffer_activate_video(btv, &idle);\n\tbttv_buffer_activate_vbi(btv, NULL);\n\tbttv_set_dma(btv, 0);\n\tbtwrite(0, BT848_INT_MASK);\n\tspin_unlock_irqrestore(&btv->s_lock,flags);\n\n\t \n\tbtv->state.gpio_enable = btread(BT848_GPIO_OUT_EN);\n\tbtv->state.gpio_data   = gpio_read();\n\n\tbtv->state.disabled = 1;\n\treturn 0;\n}\n\nstatic int __maybe_unused bttv_resume(struct device *dev)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct bttv *btv = to_bttv(v4l2_dev);\n\tunsigned long flags;\n\n\tdprintk(\"%d: resume\\n\", btv->c.nr);\n\n\tbtv->state.disabled = 0;\n\n\t \n\tbttv_reinit_bt848(btv);\n\tgpio_inout(0xffffff, btv->state.gpio_enable);\n\tgpio_write(btv->state.gpio_data);\n\n\t \n\tspin_lock_irqsave(&btv->s_lock,flags);\n\tbtv->curr = btv->state.video;\n\tbtv->cvbi = btv->state.vbi;\n\tbtv->loop_irq = btv->state.loop_irq;\n\tbttv_buffer_activate_video(btv, &btv->curr);\n\tbttv_buffer_activate_vbi(btv, btv->cvbi);\n\tbttv_set_dma(btv, 0);\n\tspin_unlock_irqrestore(&btv->s_lock,flags);\n\treturn 0;\n}\n\nstatic const struct pci_device_id bttv_pci_tbl[] = {\n\t{PCI_VDEVICE(BROOKTREE, PCI_DEVICE_ID_BT848), 0},\n\t{PCI_VDEVICE(BROOKTREE, PCI_DEVICE_ID_BT849), 0},\n\t{PCI_VDEVICE(BROOKTREE, PCI_DEVICE_ID_BT878), 0},\n\t{PCI_VDEVICE(BROOKTREE, PCI_DEVICE_ID_BT879), 0},\n\t{PCI_VDEVICE(BROOKTREE, PCI_DEVICE_ID_FUSION879), 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, bttv_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(bttv_pm_ops,\n\t\t\t bttv_suspend,\n\t\t\t bttv_resume);\n\nstatic struct pci_driver bttv_pci_driver = {\n\t.name      = \"bttv\",\n\t.id_table  = bttv_pci_tbl,\n\t.probe     = bttv_probe,\n\t.remove    = bttv_remove,\n\t.driver.pm = &bttv_pm_ops,\n};\n\nstatic int __init bttv_init_module(void)\n{\n\tint ret;\n\n\tbttv_num = 0;\n\n\tpr_info(\"driver version %s loaded\\n\", BTTV_VERSION);\n\tif (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)\n\t\tgbuffers = 2;\n\tif (gbufsize > BTTV_MAX_FBUF)\n\t\tgbufsize = BTTV_MAX_FBUF;\n\tgbufsize = (gbufsize + PAGE_SIZE - 1) & PAGE_MASK;\n\tif (bttv_verbose)\n\t\tpr_info(\"using %d buffers with %dk (%d pages) each for capture\\n\",\n\t\t\tgbuffers, gbufsize >> 10, gbufsize >> PAGE_SHIFT);\n\n\tbttv_check_chipset();\n\n\tret = bus_register(&bttv_sub_bus_type);\n\tif (ret < 0) {\n\t\tpr_warn(\"bus_register error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = pci_register_driver(&bttv_pci_driver);\n\tif (ret < 0)\n\t\tbus_unregister(&bttv_sub_bus_type);\n\n\treturn ret;\n}\n\nstatic void __exit bttv_cleanup_module(void)\n{\n\tpci_unregister_driver(&bttv_pci_driver);\n\tbus_unregister(&bttv_sub_bus_type);\n}\n\nmodule_init(bttv_init_module);\nmodule_exit(bttv_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}