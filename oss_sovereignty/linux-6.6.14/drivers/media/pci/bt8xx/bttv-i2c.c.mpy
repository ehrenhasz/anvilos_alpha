{
  "module_name": "bttv-i2c.c",
  "hash_id": "e48d88a9d897d314d0c57aea108d3038cd41e6a1f2495afa0b3a8c17742549de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/bt8xx/bttv-i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"bttvp.h\"\n#include <media/v4l2-common.h>\n#include <linux/jiffies.h>\n#include <asm/io.h>\n\nstatic int i2c_debug;\nstatic int i2c_hw;\nstatic int i2c_scan;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"configure i2c debug level\");\nmodule_param(i2c_hw,    int, 0444);\nMODULE_PARM_DESC(i2c_hw, \"force use of hardware i2c support, instead of software bitbang\");\nmodule_param(i2c_scan,  int, 0444);\nMODULE_PARM_DESC(i2c_scan,\"scan i2c bus at insmod time\");\n\nstatic unsigned int i2c_udelay = 5;\nmodule_param(i2c_udelay, int, 0444);\nMODULE_PARM_DESC(i2c_udelay, \"soft i2c delay at insmod time, in usecs (should be 5 or higher). Lower value means higher bus speed.\");\n\n \n \n\nstatic void bttv_bit_setscl(void *data, int state)\n{\n\tstruct bttv *btv = (struct bttv*)data;\n\n\tif (state)\n\t\tbtv->i2c_state |= 0x02;\n\telse\n\t\tbtv->i2c_state &= ~0x02;\n\tbtwrite(btv->i2c_state, BT848_I2C);\n\tbtread(BT848_I2C);\n}\n\nstatic void bttv_bit_setsda(void *data, int state)\n{\n\tstruct bttv *btv = (struct bttv*)data;\n\n\tif (state)\n\t\tbtv->i2c_state |= 0x01;\n\telse\n\t\tbtv->i2c_state &= ~0x01;\n\tbtwrite(btv->i2c_state, BT848_I2C);\n\tbtread(BT848_I2C);\n}\n\nstatic int bttv_bit_getscl(void *data)\n{\n\tstruct bttv *btv = (struct bttv*)data;\n\tint state;\n\n\tstate = btread(BT848_I2C) & 0x02 ? 1 : 0;\n\treturn state;\n}\n\nstatic int bttv_bit_getsda(void *data)\n{\n\tstruct bttv *btv = (struct bttv*)data;\n\tint state;\n\n\tstate = btread(BT848_I2C) & 0x01;\n\treturn state;\n}\n\nstatic const struct i2c_algo_bit_data bttv_i2c_algo_bit_template = {\n\t.setsda  = bttv_bit_setsda,\n\t.setscl  = bttv_bit_setscl,\n\t.getsda  = bttv_bit_getsda,\n\t.getscl  = bttv_bit_getscl,\n\t.udelay  = 16,\n\t.timeout = 200,\n};\n\n \n \n\nstatic u32 functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic int\nbttv_i2c_wait_done(struct bttv *btv)\n{\n\tint rc = 0;\n\n\t \n\tif (wait_event_interruptible_timeout(btv->i2c_queue,\n\t    btv->i2c_done, msecs_to_jiffies(85)) == -ERESTARTSYS)\n\t\trc = -EIO;\n\n\tif (btv->i2c_done & BT848_INT_RACK)\n\t\trc = 1;\n\tbtv->i2c_done = 0;\n\treturn rc;\n}\n\n#define I2C_HW (BT878_I2C_MODE  | BT848_I2C_SYNC |\\\n\t\tBT848_I2C_SCL | BT848_I2C_SDA)\n\nstatic int\nbttv_i2c_sendbytes(struct bttv *btv, const struct i2c_msg *msg, int last)\n{\n\tu32 xmit;\n\tint retval,cnt;\n\n\t \n\tif (0 == msg->len)\n\t\treturn -EINVAL;\n\n\t \n\txmit = (msg->addr << 25) | (msg->buf[0] << 16) | I2C_HW;\n\tif (msg->len > 1 || !last)\n\t\txmit |= BT878_I2C_NOSTOP;\n\tbtwrite(xmit, BT848_I2C);\n\tretval = bttv_i2c_wait_done(btv);\n\tif (retval < 0)\n\t\tgoto err;\n\tif (retval == 0)\n\t\tgoto eio;\n\tif (i2c_debug) {\n\t\tpr_cont(\" <W %02x %02x\", msg->addr << 1, msg->buf[0]);\n\t}\n\n\tfor (cnt = 1; cnt < msg->len; cnt++ ) {\n\t\t \n\t\txmit = (msg->buf[cnt] << 24) | I2C_HW | BT878_I2C_NOSTART;\n\t\tif (cnt < msg->len-1 || !last)\n\t\t\txmit |= BT878_I2C_NOSTOP;\n\t\tbtwrite(xmit, BT848_I2C);\n\t\tretval = bttv_i2c_wait_done(btv);\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t\tif (retval == 0)\n\t\t\tgoto eio;\n\t\tif (i2c_debug)\n\t\t\tpr_cont(\" %02x\", msg->buf[cnt]);\n\t}\n\tif (i2c_debug && !(xmit & BT878_I2C_NOSTOP))\n\t\tpr_cont(\">\\n\");\n\treturn msg->len;\n\n eio:\n\tretval = -EIO;\n err:\n\tif (i2c_debug)\n\t\tpr_cont(\" ERR: %d\\n\",retval);\n\treturn retval;\n}\n\nstatic int\nbttv_i2c_readbytes(struct bttv *btv, const struct i2c_msg *msg, int last)\n{\n\tu32 xmit;\n\tu32 cnt;\n\tint retval;\n\n\tfor (cnt = 0; cnt < msg->len; cnt++) {\n\t\txmit = (msg->addr << 25) | (1 << 24) | I2C_HW;\n\t\tif (cnt < msg->len-1)\n\t\t\txmit |= BT848_I2C_W3B;\n\t\tif (cnt < msg->len-1 || !last)\n\t\t\txmit |= BT878_I2C_NOSTOP;\n\t\tif (cnt)\n\t\t\txmit |= BT878_I2C_NOSTART;\n\n\t\tif (i2c_debug) {\n\t\t\tif (!(xmit & BT878_I2C_NOSTART))\n\t\t\t\tpr_cont(\" <R %02x\", (msg->addr << 1) +1);\n\t\t}\n\n\t\tbtwrite(xmit, BT848_I2C);\n\t\tretval = bttv_i2c_wait_done(btv);\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t\tif (retval == 0)\n\t\t\tgoto eio;\n\t\tmsg->buf[cnt] = ((u32)btread(BT848_I2C) >> 8) & 0xff;\n\t\tif (i2c_debug) {\n\t\t\tpr_cont(\" =%02x\", msg->buf[cnt]);\n\t\t}\n\t\tif (i2c_debug && !(xmit & BT878_I2C_NOSTOP))\n\t\t\tpr_cont(\" >\\n\");\n\t}\n\n\n\treturn msg->len;\n\n eio:\n\tretval = -EIO;\n err:\n\tif (i2c_debug)\n\t\tpr_cont(\" ERR: %d\\n\",retval);\n\treturn retval;\n}\n\nstatic int bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\n{\n\tstruct v4l2_device *v4l2_dev = i2c_get_adapdata(i2c_adap);\n\tstruct bttv *btv = to_bttv(v4l2_dev);\n\tint retval = 0;\n\tint i;\n\n\tif (i2c_debug)\n\t\tpr_debug(\"bt-i2c:\");\n\n\tbtwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);\n\tfor (i = 0 ; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tretval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t \n\t\t\tretval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn num;\n\n err:\n\treturn retval;\n}\n\nstatic const struct i2c_algorithm bttv_algo = {\n\t.master_xfer   = bttv_i2c_xfer,\n\t.functionality = functionality,\n};\n\n \n \n\n \nint bttv_I2CRead(struct bttv *btv, unsigned char addr, char *probe_for)\n{\n\tunsigned char buffer = 0;\n\n\tif (0 != btv->i2c_rc)\n\t\treturn -1;\n\tif (bttv_verbose && NULL != probe_for)\n\t\tpr_info(\"%d: i2c: checking for %s @ 0x%02x... \",\n\t\t\tbtv->c.nr, probe_for, addr);\n\tbtv->i2c_client.addr = addr >> 1;\n\tif (1 != i2c_master_recv(&btv->i2c_client, &buffer, 1)) {\n\t\tif (NULL != probe_for) {\n\t\t\tif (bttv_verbose)\n\t\t\t\tpr_cont(\"not found\\n\");\n\t\t} else\n\t\t\tpr_warn(\"%d: i2c read 0x%x: error\\n\",\n\t\t\t\tbtv->c.nr, addr);\n\t\treturn -1;\n\t}\n\tif (bttv_verbose && NULL != probe_for)\n\t\tpr_cont(\"found\\n\");\n\treturn buffer;\n}\n\n \nint bttv_I2CWrite(struct bttv *btv, unsigned char addr, unsigned char b1,\n\t\t    unsigned char b2, int both)\n{\n\tunsigned char buffer[2];\n\tint bytes = both ? 2 : 1;\n\n\tif (0 != btv->i2c_rc)\n\t\treturn -1;\n\tbtv->i2c_client.addr = addr >> 1;\n\tbuffer[0] = b1;\n\tbuffer[1] = b2;\n\tif (bytes != i2c_master_send(&btv->i2c_client, buffer, bytes))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nvoid bttv_readee(struct bttv *btv, unsigned char *eedata, int addr)\n{\n\tmemset(eedata, 0, 256);\n\tif (0 != btv->i2c_rc)\n\t\treturn;\n\tbtv->i2c_client.addr = addr >> 1;\n\ttveeprom_read(&btv->i2c_client, eedata, 256);\n}\n\nstatic char *i2c_devs[128] = {\n\t[ 0x1c >> 1 ] = \"lgdt330x\",\n\t[ 0x30 >> 1 ] = \"IR (hauppauge)\",\n\t[ 0x80 >> 1 ] = \"msp34xx\",\n\t[ 0x86 >> 1 ] = \"tda9887\",\n\t[ 0xa0 >> 1 ] = \"eeprom\",\n\t[ 0xc0 >> 1 ] = \"tuner (analog)\",\n\t[ 0xc2 >> 1 ] = \"tuner (analog)\",\n};\n\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\n{\n\tunsigned char buf;\n\tint i,rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\n\t\tc->addr = i;\n\t\trc = i2c_master_recv(c,&buf,0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tpr_info(\"%s: i2c scan: found device @ 0x%x  [%s]\\n\",\n\t\t\tname, i << 1, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n}\n\n \nint init_bttv_i2c(struct bttv *btv)\n{\n\tstrscpy(btv->i2c_client.name, \"bttv internal\", I2C_NAME_SIZE);\n\n\tif (i2c_hw)\n\t\tbtv->use_i2c_hw = 1;\n\tif (btv->use_i2c_hw) {\n\t\t \n\t\tstrscpy(btv->c.i2c_adap.name, \"bt878\",\n\t\t\tsizeof(btv->c.i2c_adap.name));\n\t\tbtv->c.i2c_adap.algo = &bttv_algo;\n\t} else {\n\t\t \n\t \n\t\tif (i2c_udelay<5)\n\t\t\ti2c_udelay=5;\n\n\t\tstrscpy(btv->c.i2c_adap.name, \"bttv\",\n\t\t\tsizeof(btv->c.i2c_adap.name));\n\t\tbtv->i2c_algo = bttv_i2c_algo_bit_template;\n\t\tbtv->i2c_algo.udelay = i2c_udelay;\n\t\tbtv->i2c_algo.data = btv;\n\t\tbtv->c.i2c_adap.algo_data = &btv->i2c_algo;\n\t}\n\tbtv->c.i2c_adap.owner = THIS_MODULE;\n\n\tbtv->c.i2c_adap.dev.parent = &btv->c.pci->dev;\n\tsnprintf(btv->c.i2c_adap.name, sizeof(btv->c.i2c_adap.name),\n\t\t \"bt%d #%d [%s]\", btv->id, btv->c.nr,\n\t\t btv->use_i2c_hw ? \"hw\" : \"sw\");\n\n\ti2c_set_adapdata(&btv->c.i2c_adap, &btv->c.v4l2_dev);\n\tbtv->i2c_client.adapter = &btv->c.i2c_adap;\n\n\n\tif (btv->use_i2c_hw) {\n\t\tbtv->i2c_rc = i2c_add_adapter(&btv->c.i2c_adap);\n\t} else {\n\t\tbttv_bit_setscl(btv,1);\n\t\tbttv_bit_setsda(btv,1);\n\t\tbtv->i2c_rc = i2c_bit_add_bus(&btv->c.i2c_adap);\n\t}\n\tif (0 == btv->i2c_rc && i2c_scan)\n\t\tdo_i2c_scan(btv->c.v4l2_dev.name, &btv->i2c_client);\n\n\treturn btv->i2c_rc;\n}\n\nint fini_bttv_i2c(struct bttv *btv)\n{\n\tif (btv->i2c_rc == 0)\n\t\ti2c_del_adapter(&btv->c.i2c_adap);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}