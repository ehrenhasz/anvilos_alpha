{
  "module_name": "tw5864-core.c",
  "hash_id": "930f1207c20bdab5d9ecd3b72ca689d047e1cb973a33d5e6b5415645dc80d3ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw5864/tw5864-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/sound.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm.h>\n#include <linux/pci_ids.h>\n#include <linux/jiffies.h>\n#include <asm/dma.h>\n#include <media/v4l2-dev.h>\n\n#include \"tw5864.h\"\n#include \"tw5864-reg.h\"\n\nMODULE_DESCRIPTION(\"V4L2 driver module for tw5864-based multimedia capture & encoding devices\");\nMODULE_AUTHOR(\"Bluecherry Maintainers <maintainers@bluecherrydvr.com>\");\nMODULE_AUTHOR(\"Andrey Utkin <andrey.utkin@corp.bluecherry.net>\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \nstatic unsigned int video_nr[] = {[0 ... (TW5864_INPUTS - 1)] = -1 };\n\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr, \"video devices numbers array\");\n\n \nstatic const struct pci_device_id tw5864_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_TECHWELL, PCI_DEVICE_ID_TECHWELL_5864)},\n\t{0,}\n};\n\nvoid tw5864_irqmask_apply(struct tw5864_dev *dev)\n{\n\ttw_writel(TW5864_INTR_ENABLE_L, dev->irqmask & 0xffff);\n\ttw_writel(TW5864_INTR_ENABLE_H, (dev->irqmask >> 16));\n}\n\nstatic void tw5864_interrupts_disable(struct tw5864_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tdev->irqmask = 0;\n\ttw5864_irqmask_apply(dev);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic void tw5864_timer_isr(struct tw5864_dev *dev);\nstatic void tw5864_h264_isr(struct tw5864_dev *dev);\n\nstatic irqreturn_t tw5864_isr(int irq, void *dev_id)\n{\n\tstruct tw5864_dev *dev = dev_id;\n\tu32 status;\n\n\tstatus = tw_readl(TW5864_INTR_STATUS_L) |\n\t\ttw_readl(TW5864_INTR_STATUS_H) << 16;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\ttw_writel(TW5864_INTR_CLR_L, 0xffff);\n\ttw_writel(TW5864_INTR_CLR_H, 0xffff);\n\n\tif (status & TW5864_INTR_VLC_DONE)\n\t\ttw5864_h264_isr(dev);\n\n\tif (status & TW5864_INTR_TIMER)\n\t\ttw5864_timer_isr(dev);\n\n\tif (!(status & (TW5864_INTR_TIMER | TW5864_INTR_VLC_DONE))) {\n\t\tdev_dbg(&dev->pci->dev, \"Unknown interrupt, status 0x%08X\\n\",\n\t\t\tstatus);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tw5864_h264_isr(struct tw5864_dev *dev)\n{\n\tint channel = tw_readl(TW5864_DSP) & TW5864_DSP_ENC_CHN;\n\tstruct tw5864_input *input = &dev->inputs[channel];\n\tint cur_frame_index, next_frame_index;\n\tstruct tw5864_h264_frame *cur_frame, *next_frame;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\tcur_frame_index = dev->h264_buf_w_index;\n\tnext_frame_index = (cur_frame_index + 1) % H264_BUF_CNT;\n\tcur_frame = &dev->h264_buf[cur_frame_index];\n\tnext_frame = &dev->h264_buf[next_frame_index];\n\n\tif (next_frame_index != dev->h264_buf_r_index) {\n\t\tcur_frame->vlc_len = tw_readl(TW5864_VLC_LENGTH) << 2;\n\t\tcur_frame->checksum = tw_readl(TW5864_VLC_CRC_REG);\n\t\tcur_frame->input = input;\n\t\tcur_frame->timestamp = ktime_get_ns();\n\t\tcur_frame->seqno = input->frame_seqno;\n\t\tcur_frame->gop_seqno = input->frame_gop_seqno;\n\n\t\tdev->h264_buf_w_index = next_frame_index;\n\t\ttasklet_schedule(&dev->tasklet);\n\n\t\tcur_frame = next_frame;\n\n\t\tspin_lock(&input->slock);\n\t\tinput->frame_seqno++;\n\t\tinput->frame_gop_seqno++;\n\t\tif (input->frame_gop_seqno >= input->gop)\n\t\t\tinput->frame_gop_seqno = 0;\n\t\tspin_unlock(&input->slock);\n\t} else {\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Skipped frame on input %d because all buffers busy\\n\",\n\t\t\tchannel);\n\t}\n\n\tdev->encoder_busy = 0;\n\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\ttw_writel(TW5864_VLC_STREAM_BASE_ADDR, cur_frame->vlc.dma_addr);\n\ttw_writel(TW5864_MV_STREAM_BASE_ADDR, cur_frame->mv.dma_addr);\n\n\t \n\ttw_writel(TW5864_VLC_DSP_INTR, 0x00000001);\n\ttw_writel(TW5864_PCI_INTR_STATUS, TW5864_VLC_DONE_INTR);\n}\n\nstatic void tw5864_input_deadline_update(struct tw5864_input *input)\n{\n\tinput->new_frame_deadline = jiffies + msecs_to_jiffies(1000);\n}\n\nstatic void tw5864_timer_isr(struct tw5864_dev *dev)\n{\n\tunsigned long flags;\n\tint i;\n\tint encoder_busy;\n\n\t \n\ttw_writel(TW5864_PCI_INTR_STATUS, TW5864_TIMER_INTR);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tencoder_busy = dev->encoder_busy;\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\tif (encoder_busy)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < TW5864_INPUTS; i++) {\n\t\tint next_input = (i + dev->next_input) % TW5864_INPUTS;\n\t\tstruct tw5864_input *input = &dev->inputs[next_input];\n\t\tint raw_buf_id;  \n\n\t\tspin_lock_irqsave(&input->slock, flags);\n\t\tif (!input->enabled)\n\t\t\tgoto next;\n\n\t\t \n\t\traw_buf_id = tw_mask_shift_readl(TW5864_SENIF_ORG_FRM_PTR1, 0x3,\n\t\t\t\t\t\t 2 * input->nr);\n\n\t\tif (input->buf_id != raw_buf_id) {\n\t\t\tinput->buf_id = raw_buf_id;\n\t\t\ttw5864_input_deadline_update(input);\n\t\t\tspin_unlock_irqrestore(&input->slock, flags);\n\n\t\t\tspin_lock_irqsave(&dev->slock, flags);\n\t\t\tdev->encoder_busy = 1;\n\t\t\tdev->next_input = (next_input + 1) % TW5864_INPUTS;\n\t\t\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\t\t\ttw5864_request_encoded_frame(input);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (time_is_after_jiffies(input->new_frame_deadline)) {\n\t\t\t \n\t\t\ttw_mask_shift_writel(TW5864_ENC_BUF_PTR_REC1, 0x3,\n\t\t\t\t\t     2 * input->nr, input->buf_id + 3);\n\t\t\ttw5864_input_deadline_update(input);\n\t\t}\nnext:\n\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t}\n}\n\nstatic int tw5864_initdev(struct pci_dev *pci_dev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct tw5864_dev *dev;\n\tint err;\n\n\tdev = devm_kzalloc(&pci_dev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(dev->name, sizeof(dev->name), \"tw5864:%s\", pci_name(pci_dev));\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdev->pci = pci_dev;\n\terr = pcim_enable_device(pci_dev);\n\tif (err) {\n\t\tdev_err(&dev->pci->dev, \"pcim_enable_device() failed\\n\");\n\t\tgoto unreg_v4l2;\n\t}\n\n\tpci_set_master(pci_dev);\n\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&dev->pci->dev, \"32 bit PCI DMA is not supported\\n\");\n\t\tgoto unreg_v4l2;\n\t}\n\n\t \n\terr = pcim_iomap_regions(pci_dev, BIT(0), dev->name);\n\tif (err) {\n\t\tdev_err(&dev->pci->dev, \"Cannot request regions for MMIO\\n\");\n\t\tgoto unreg_v4l2;\n\t}\n\tdev->mmio = pcim_iomap_table(pci_dev)[0];\n\n\tspin_lock_init(&dev->slock);\n\n\tdev_info(&pci_dev->dev, \"TW5864 hardware version: %04x\\n\",\n\t\t tw_readl(TW5864_HW_VERSION));\n\tdev_info(&pci_dev->dev, \"TW5864 H.264 core version: %04x:%04x\\n\",\n\t\t tw_readl(TW5864_H264REV),\n\t\t tw_readl(TW5864_UNDECLARED_H264REV_PART2));\n\n\terr = tw5864_video_init(dev, video_nr);\n\tif (err)\n\t\tgoto unreg_v4l2;\n\n\t \n\terr = devm_request_irq(&pci_dev->dev, pci_dev->irq, tw5864_isr,\n\t\t\t       IRQF_SHARED, \"tw5864\", dev);\n\tif (err < 0) {\n\t\tdev_err(&dev->pci->dev, \"can't get IRQ %d\\n\", pci_dev->irq);\n\t\tgoto fini_video;\n\t}\n\n\tdev_info(&pci_dev->dev, \"Note: there are known video quality issues. For details\\n\");\n\tdev_info(&pci_dev->dev, \"see the comment in drivers/media/pci/tw5864/tw5864-core.c.\\n\");\n\n\treturn 0;\n\nfini_video:\n\ttw5864_video_fini(dev);\nunreg_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\treturn err;\n}\n\nstatic void tw5864_finidev(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct tw5864_dev *dev =\n\t\tcontainer_of(v4l2_dev, struct tw5864_dev, v4l2_dev);\n\n\t \n\ttw5864_interrupts_disable(dev);\n\n\t \n\ttw5864_video_fini(dev);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n}\n\nstatic struct pci_driver tw5864_pci_driver = {\n\t.name = \"tw5864\",\n\t.id_table = tw5864_pci_tbl,\n\t.probe = tw5864_initdev,\n\t.remove = tw5864_finidev,\n};\n\nmodule_pci_driver(tw5864_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}