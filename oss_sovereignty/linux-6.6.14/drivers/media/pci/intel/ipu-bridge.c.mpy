{
  "module_name": "ipu-bridge.c",
  "hash_id": "37b024f524b4039127259619ca165a4a11ceb8d69577ee98993d5126ae66f262",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/intel/ipu-bridge.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n\n#include <media/ipu-bridge.h>\n#include <media/v4l2-fwnode.h>\n\n \n#define MEI_CSI_UUID\t\t\t\t\t\t\t\\\n\tUUID_LE(0x92335FCF, 0x3203, 0x4472,\t\t\t\t\\\n\t\t0xAF, 0x93, 0x7B, 0x44, 0x53, 0xAC, 0x29, 0xDA)\n\n \n#define IVSC_DEV_NAME \"intel_vsc\"\n\n \nstatic const struct ipu_sensor_config ipu_supported_sensors[] = {\n\t \n\tIPU_SENSOR_CONFIG(\"INT33BE\", 1, 419200000),\n\t \n\tIPU_SENSOR_CONFIG(\"INT347A\", 1, 360000000),\n\t \n\tIPU_SENSOR_CONFIG(\"INT347E\", 1, 319200000),\n\t \n\tIPU_SENSOR_CONFIG(\"OVTI2680\", 1, 331200000),\n\t \n\tIPU_SENSOR_CONFIG(\"OVTI8856\", 3, 180000000, 360000000, 720000000),\n\t \n\tIPU_SENSOR_CONFIG(\"INT3474\", 1, 360000000),\n\t \n\tIPU_SENSOR_CONFIG(\"INT3537\", 1, 437000000),\n\t \n\tIPU_SENSOR_CONFIG(\"OVTIDB10\", 1, 560000000),\n\t \n\tIPU_SENSOR_CONFIG(\"INT0310\", 0),\n};\n\nstatic const struct ipu_property_names prop_names = {\n\t.clock_frequency = \"clock-frequency\",\n\t.rotation = \"rotation\",\n\t.orientation = \"orientation\",\n\t.bus_type = \"bus-type\",\n\t.data_lanes = \"data-lanes\",\n\t.remote_endpoint = \"remote-endpoint\",\n\t.link_frequencies = \"link-frequencies\",\n};\n\nstatic const char * const ipu_vcm_types[] = {\n\t\"ad5823\",\n\t\"dw9714\",\n\t\"ad5816\",\n\t\"dw9719\",\n\t\"dw9718\",\n\t\"dw9806b\",\n\t\"wv517s\",\n\t\"lc898122xa\",\n\t\"lc898212axb\",\n};\n\n \nstatic const struct acpi_device_id ivsc_acpi_ids[] = {\n\t{ \"INTC1059\" },\n\t{ \"INTC1095\" },\n\t{ \"INTC100A\" },\n\t{ \"INTC10CF\" },\n};\n\nstatic struct acpi_device *ipu_bridge_get_ivsc_acpi_dev(struct acpi_device *adev)\n{\n\tacpi_handle handle = acpi_device_handle(adev);\n\tstruct acpi_device *consumer, *ivsc_adev;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ivsc_acpi_ids); i++) {\n\t\tconst struct acpi_device_id *acpi_id = &ivsc_acpi_ids[i];\n\n\t\tfor_each_acpi_dev_match(ivsc_adev, acpi_id->id, NULL, -1)\n\t\t\t \n\t\t\tfor_each_acpi_consumer_dev(ivsc_adev, consumer)\n\t\t\t\tif (consumer->handle == handle) {\n\t\t\t\t\tacpi_dev_put(consumer);\n\t\t\t\t\treturn ivsc_adev;\n\t\t\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int ipu_bridge_match_ivsc_dev(struct device *dev, const void *adev)\n{\n\tif (ACPI_COMPANION(dev) != adev)\n\t\treturn 0;\n\n\tif (!sysfs_streq(dev_name(dev), IVSC_DEV_NAME))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct device *ipu_bridge_get_ivsc_csi_dev(struct acpi_device *adev)\n{\n\tstruct device *dev, *csi_dev;\n\tuuid_le uuid = MEI_CSI_UUID;\n\tchar name[64];\n\n\t \n\tdev = bus_find_device(&platform_bus_type, NULL, adev,\n\t\t\t      ipu_bridge_match_ivsc_dev);\n\tif (dev) {\n\t\tsnprintf(name, sizeof(name), \"%s-%pUl\", dev_name(dev), &uuid);\n\n\t\tcsi_dev = device_find_child_by_name(dev, name);\n\n\t\tput_device(dev);\n\n\t\treturn csi_dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ipu_bridge_check_ivsc_dev(struct ipu_sensor *sensor,\n\t\t\t\t     struct acpi_device *sensor_adev)\n{\n\tstruct acpi_device *adev;\n\tstruct device *csi_dev;\n\n\tadev = ipu_bridge_get_ivsc_acpi_dev(sensor_adev);\n\tif (adev) {\n\t\tcsi_dev = ipu_bridge_get_ivsc_csi_dev(adev);\n\t\tif (!csi_dev) {\n\t\t\tacpi_dev_put(adev);\n\t\t\tdev_err(&adev->dev, \"Failed to find MEI CSI dev\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsensor->csi_dev = csi_dev;\n\t\tsensor->ivsc_adev = adev;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipu_bridge_read_acpi_buffer(struct acpi_device *adev, char *id,\n\t\t\t\t       void *data, u32 size)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint ret = 0;\n\n\tstatus = acpi_evaluate_object(adev->handle, id, NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tobj = buffer.pointer;\n\tif (!obj) {\n\t\tdev_err(&adev->dev, \"Couldn't locate ACPI buffer\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tdev_err(&adev->dev, \"Not an ACPI buffer\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_buff;\n\t}\n\n\tif (obj->buffer.length > size) {\n\t\tdev_err(&adev->dev, \"Given buffer is too small\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_buff;\n\t}\n\n\tmemcpy(data, obj->buffer.pointer, obj->buffer.length);\n\nout_free_buff:\n\tkfree(buffer.pointer);\n\treturn ret;\n}\n\nstatic u32 ipu_bridge_parse_rotation(struct acpi_device *adev,\n\t\t\t\t     struct ipu_sensor_ssdb *ssdb)\n{\n\tswitch (ssdb->degree) {\n\tcase IPU_SENSOR_ROTATION_NORMAL:\n\t\treturn 0;\n\tcase IPU_SENSOR_ROTATION_INVERTED:\n\t\treturn 180;\n\tdefault:\n\t\tdev_warn(&adev->dev,\n\t\t\t \"Unknown rotation %d. Assume 0 degree rotation\\n\",\n\t\t\t ssdb->degree);\n\t\treturn 0;\n\t}\n}\n\nstatic enum v4l2_fwnode_orientation ipu_bridge_parse_orientation(struct acpi_device *adev)\n{\n\tenum v4l2_fwnode_orientation orientation;\n\tstruct acpi_pld_info *pld;\n\tacpi_status status;\n\n\tstatus = acpi_get_physical_device_location(adev->handle, &pld);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(&adev->dev, \"_PLD call failed, using default orientation\\n\");\n\t\treturn V4L2_FWNODE_ORIENTATION_EXTERNAL;\n\t}\n\n\tswitch (pld->panel) {\n\tcase ACPI_PLD_PANEL_FRONT:\n\t\torientation = V4L2_FWNODE_ORIENTATION_FRONT;\n\t\tbreak;\n\tcase ACPI_PLD_PANEL_BACK:\n\t\torientation = V4L2_FWNODE_ORIENTATION_BACK;\n\t\tbreak;\n\tcase ACPI_PLD_PANEL_TOP:\n\tcase ACPI_PLD_PANEL_LEFT:\n\tcase ACPI_PLD_PANEL_RIGHT:\n\tcase ACPI_PLD_PANEL_UNKNOWN:\n\t\torientation = V4L2_FWNODE_ORIENTATION_EXTERNAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adev->dev, \"Unknown _PLD panel val %d\\n\", pld->panel);\n\t\torientation = V4L2_FWNODE_ORIENTATION_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tACPI_FREE(pld);\n\treturn orientation;\n}\n\nint ipu_bridge_parse_ssdb(struct acpi_device *adev, struct ipu_sensor *sensor)\n{\n\tstruct ipu_sensor_ssdb ssdb = {};\n\tint ret;\n\n\tret = ipu_bridge_read_acpi_buffer(adev, \"SSDB\", &ssdb, sizeof(ssdb));\n\tif (ret)\n\t\treturn ret;\n\n\tif (ssdb.vcmtype > ARRAY_SIZE(ipu_vcm_types)) {\n\t\tdev_warn(&adev->dev, \"Unknown VCM type %d\\n\", ssdb.vcmtype);\n\t\tssdb.vcmtype = 0;\n\t}\n\n\tif (ssdb.lanes > IPU_MAX_LANES) {\n\t\tdev_err(&adev->dev, \"Number of lanes in SSDB is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->link = ssdb.link;\n\tsensor->lanes = ssdb.lanes;\n\tsensor->mclkspeed = ssdb.mclkspeed;\n\tsensor->rotation = ipu_bridge_parse_rotation(adev, &ssdb);\n\tsensor->orientation = ipu_bridge_parse_orientation(adev);\n\n\tif (ssdb.vcmtype)\n\t\tsensor->vcm_type = ipu_vcm_types[ssdb.vcmtype - 1];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ipu_bridge_parse_ssdb, INTEL_IPU_BRIDGE);\n\nstatic void ipu_bridge_create_fwnode_properties(\n\tstruct ipu_sensor *sensor,\n\tstruct ipu_bridge *bridge,\n\tconst struct ipu_sensor_config *cfg)\n{\n\tstruct ipu_property_names *names = &sensor->prop_names;\n\tstruct software_node *nodes = sensor->swnodes;\n\n\tsensor->prop_names = prop_names;\n\n\tif (sensor->csi_dev) {\n\t\tsensor->local_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_IVSC_SENSOR_ENDPOINT]);\n\t\tsensor->remote_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_IVSC_IPU_ENDPOINT]);\n\t\tsensor->ivsc_sensor_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_SENSOR_ENDPOINT]);\n\t\tsensor->ivsc_ipu_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_IPU_ENDPOINT]);\n\n\t\tsensor->ivsc_sensor_ep_properties[0] =\n\t\t\tPROPERTY_ENTRY_U32(names->bus_type,\n\t\t\t\t\t   V4L2_FWNODE_BUS_TYPE_CSI2_DPHY);\n\t\tsensor->ivsc_sensor_ep_properties[1] =\n\t\t\tPROPERTY_ENTRY_U32_ARRAY_LEN(names->data_lanes,\n\t\t\t\t\t\t     bridge->data_lanes,\n\t\t\t\t\t\t     sensor->lanes);\n\t\tsensor->ivsc_sensor_ep_properties[2] =\n\t\t\tPROPERTY_ENTRY_REF_ARRAY(names->remote_endpoint,\n\t\t\t\t\t\t sensor->ivsc_sensor_ref);\n\n\t\tsensor->ivsc_ipu_ep_properties[0] =\n\t\t\tPROPERTY_ENTRY_U32(names->bus_type,\n\t\t\t\t\t   V4L2_FWNODE_BUS_TYPE_CSI2_DPHY);\n\t\tsensor->ivsc_ipu_ep_properties[1] =\n\t\t\tPROPERTY_ENTRY_U32_ARRAY_LEN(names->data_lanes,\n\t\t\t\t\t\t     bridge->data_lanes,\n\t\t\t\t\t\t     sensor->lanes);\n\t\tsensor->ivsc_ipu_ep_properties[2] =\n\t\t\tPROPERTY_ENTRY_REF_ARRAY(names->remote_endpoint,\n\t\t\t\t\t\t sensor->ivsc_ipu_ref);\n\t} else {\n\t\tsensor->local_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_IPU_ENDPOINT]);\n\t\tsensor->remote_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&nodes[SWNODE_SENSOR_ENDPOINT]);\n\t}\n\n\tsensor->dev_properties[0] = PROPERTY_ENTRY_U32(\n\t\t\t\t\tsensor->prop_names.clock_frequency,\n\t\t\t\t\tsensor->mclkspeed);\n\tsensor->dev_properties[1] = PROPERTY_ENTRY_U32(\n\t\t\t\t\tsensor->prop_names.rotation,\n\t\t\t\t\tsensor->rotation);\n\tsensor->dev_properties[2] = PROPERTY_ENTRY_U32(\n\t\t\t\t\tsensor->prop_names.orientation,\n\t\t\t\t\tsensor->orientation);\n\tif (sensor->vcm_type) {\n\t\tsensor->vcm_ref[0] =\n\t\t\tSOFTWARE_NODE_REFERENCE(&sensor->swnodes[SWNODE_VCM]);\n\t\tsensor->dev_properties[3] =\n\t\t\tPROPERTY_ENTRY_REF_ARRAY(\"lens-focus\", sensor->vcm_ref);\n\t}\n\n\tsensor->ep_properties[0] = PROPERTY_ENTRY_U32(\n\t\t\t\t\tsensor->prop_names.bus_type,\n\t\t\t\t\tV4L2_FWNODE_BUS_TYPE_CSI2_DPHY);\n\tsensor->ep_properties[1] = PROPERTY_ENTRY_U32_ARRAY_LEN(\n\t\t\t\t\tsensor->prop_names.data_lanes,\n\t\t\t\t\tbridge->data_lanes, sensor->lanes);\n\tsensor->ep_properties[2] = PROPERTY_ENTRY_REF_ARRAY(\n\t\t\t\t\tsensor->prop_names.remote_endpoint,\n\t\t\t\t\tsensor->local_ref);\n\n\tif (cfg->nr_link_freqs > 0)\n\t\tsensor->ep_properties[3] = PROPERTY_ENTRY_U64_ARRAY_LEN(\n\t\t\tsensor->prop_names.link_frequencies,\n\t\t\tcfg->link_freqs,\n\t\t\tcfg->nr_link_freqs);\n\n\tsensor->ipu_properties[0] = PROPERTY_ENTRY_U32_ARRAY_LEN(\n\t\t\t\t\tsensor->prop_names.data_lanes,\n\t\t\t\t\tbridge->data_lanes, sensor->lanes);\n\tsensor->ipu_properties[1] = PROPERTY_ENTRY_REF_ARRAY(\n\t\t\t\t\tsensor->prop_names.remote_endpoint,\n\t\t\t\t\tsensor->remote_ref);\n}\n\nstatic void ipu_bridge_init_swnode_names(struct ipu_sensor *sensor)\n{\n\tsnprintf(sensor->node_names.remote_port,\n\t\t sizeof(sensor->node_names.remote_port),\n\t\t SWNODE_GRAPH_PORT_NAME_FMT, sensor->link);\n\tsnprintf(sensor->node_names.port,\n\t\t sizeof(sensor->node_names.port),\n\t\t SWNODE_GRAPH_PORT_NAME_FMT, 0);  \n\tsnprintf(sensor->node_names.endpoint,\n\t\t sizeof(sensor->node_names.endpoint),\n\t\t SWNODE_GRAPH_ENDPOINT_NAME_FMT, 0);  \n\tif (sensor->vcm_type) {\n\t\t \n\t\tsnprintf(sensor->node_names.vcm, sizeof(sensor->node_names.vcm),\n\t\t\t \"%s-%u\", sensor->vcm_type, sensor->link);\n\t}\n\n\tif (sensor->csi_dev) {\n\t\tsnprintf(sensor->node_names.ivsc_sensor_port,\n\t\t\t sizeof(sensor->node_names.ivsc_sensor_port),\n\t\t\t SWNODE_GRAPH_PORT_NAME_FMT, 0);\n\t\tsnprintf(sensor->node_names.ivsc_ipu_port,\n\t\t\t sizeof(sensor->node_names.ivsc_ipu_port),\n\t\t\t SWNODE_GRAPH_PORT_NAME_FMT, 1);\n\t}\n}\n\nstatic void ipu_bridge_init_swnode_group(struct ipu_sensor *sensor)\n{\n\tstruct software_node *nodes = sensor->swnodes;\n\n\tsensor->group[SWNODE_SENSOR_HID] = &nodes[SWNODE_SENSOR_HID];\n\tsensor->group[SWNODE_SENSOR_PORT] = &nodes[SWNODE_SENSOR_PORT];\n\tsensor->group[SWNODE_SENSOR_ENDPOINT] = &nodes[SWNODE_SENSOR_ENDPOINT];\n\tsensor->group[SWNODE_IPU_PORT] = &nodes[SWNODE_IPU_PORT];\n\tsensor->group[SWNODE_IPU_ENDPOINT] = &nodes[SWNODE_IPU_ENDPOINT];\n\tif (sensor->vcm_type)\n\t\tsensor->group[SWNODE_VCM] =  &nodes[SWNODE_VCM];\n\n\tif (sensor->csi_dev) {\n\t\tsensor->group[SWNODE_IVSC_HID] =\n\t\t\t\t\t&nodes[SWNODE_IVSC_HID];\n\t\tsensor->group[SWNODE_IVSC_SENSOR_PORT] =\n\t\t\t\t\t&nodes[SWNODE_IVSC_SENSOR_PORT];\n\t\tsensor->group[SWNODE_IVSC_SENSOR_ENDPOINT] =\n\t\t\t\t\t&nodes[SWNODE_IVSC_SENSOR_ENDPOINT];\n\t\tsensor->group[SWNODE_IVSC_IPU_PORT] =\n\t\t\t\t\t&nodes[SWNODE_IVSC_IPU_PORT];\n\t\tsensor->group[SWNODE_IVSC_IPU_ENDPOINT] =\n\t\t\t\t\t&nodes[SWNODE_IVSC_IPU_ENDPOINT];\n\n\t\tif (sensor->vcm_type)\n\t\t\tsensor->group[SWNODE_VCM] = &nodes[SWNODE_VCM];\n\t} else {\n\t\tif (sensor->vcm_type)\n\t\t\tsensor->group[SWNODE_IVSC_HID] = &nodes[SWNODE_VCM];\n\t}\n}\n\nstatic void ipu_bridge_create_connection_swnodes(struct ipu_bridge *bridge,\n\t\t\t\t\t\t struct ipu_sensor *sensor)\n{\n\tstruct ipu_node_names *names = &sensor->node_names;\n\tstruct software_node *nodes = sensor->swnodes;\n\n\tipu_bridge_init_swnode_names(sensor);\n\n\tnodes[SWNODE_SENSOR_HID] = NODE_SENSOR(sensor->name,\n\t\t\t\t\t       sensor->dev_properties);\n\tnodes[SWNODE_SENSOR_PORT] = NODE_PORT(sensor->node_names.port,\n\t\t\t\t\t      &nodes[SWNODE_SENSOR_HID]);\n\tnodes[SWNODE_SENSOR_ENDPOINT] = NODE_ENDPOINT(\n\t\t\t\t\t\tsensor->node_names.endpoint,\n\t\t\t\t\t\t&nodes[SWNODE_SENSOR_PORT],\n\t\t\t\t\t\tsensor->ep_properties);\n\tnodes[SWNODE_IPU_PORT] = NODE_PORT(sensor->node_names.remote_port,\n\t\t\t\t\t   &bridge->ipu_hid_node);\n\tnodes[SWNODE_IPU_ENDPOINT] = NODE_ENDPOINT(\n\t\t\t\t\t\tsensor->node_names.endpoint,\n\t\t\t\t\t\t&nodes[SWNODE_IPU_PORT],\n\t\t\t\t\t\tsensor->ipu_properties);\n\n\tif (sensor->csi_dev) {\n\t\tsnprintf(sensor->ivsc_name, sizeof(sensor->ivsc_name), \"%s-%u\",\n\t\t\t acpi_device_hid(sensor->ivsc_adev), sensor->link);\n\n\t\tnodes[SWNODE_IVSC_HID] = NODE_SENSOR(sensor->ivsc_name,\n\t\t\t\t\t\t     sensor->ivsc_properties);\n\t\tnodes[SWNODE_IVSC_SENSOR_PORT] =\n\t\t\t\tNODE_PORT(names->ivsc_sensor_port,\n\t\t\t\t\t  &nodes[SWNODE_IVSC_HID]);\n\t\tnodes[SWNODE_IVSC_SENSOR_ENDPOINT] =\n\t\t\t\tNODE_ENDPOINT(names->endpoint,\n\t\t\t\t\t      &nodes[SWNODE_IVSC_SENSOR_PORT],\n\t\t\t\t\t      sensor->ivsc_sensor_ep_properties);\n\t\tnodes[SWNODE_IVSC_IPU_PORT] =\n\t\t\t\tNODE_PORT(names->ivsc_ipu_port,\n\t\t\t\t\t  &nodes[SWNODE_IVSC_HID]);\n\t\tnodes[SWNODE_IVSC_IPU_ENDPOINT] =\n\t\t\t\tNODE_ENDPOINT(names->endpoint,\n\t\t\t\t\t      &nodes[SWNODE_IVSC_IPU_PORT],\n\t\t\t\t\t      sensor->ivsc_ipu_ep_properties);\n\t}\n\n\tnodes[SWNODE_VCM] = NODE_VCM(sensor->node_names.vcm);\n\n\tipu_bridge_init_swnode_group(sensor);\n}\n\n \nstruct ipu_bridge_instantiate_vcm_work_data {\n\tstruct work_struct work;\n\tstruct device *sensor;\n\tchar name[16];\n\tstruct i2c_board_info board_info;\n};\n\nstatic void ipu_bridge_instantiate_vcm_work(struct work_struct *work)\n{\n\tstruct ipu_bridge_instantiate_vcm_work_data *data =\n\t\tcontainer_of(work, struct ipu_bridge_instantiate_vcm_work_data,\n\t\t\t     work);\n\tstruct acpi_device *adev = ACPI_COMPANION(data->sensor);\n\tstruct i2c_client *vcm_client;\n\tbool put_fwnode = true;\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(data->sensor);\n\tif (ret < 0) {\n\t\tdev_err(data->sensor, \"Error %d runtime-resuming sensor, cannot instantiate VCM\\n\",\n\t\t\tret);\n\t\tgoto out_pm_put;\n\t}\n\n\t \n\tvcm_client = i2c_acpi_new_device_by_fwnode(acpi_fwnode_handle(adev),\n\t\t\t\t\t\t   1, &data->board_info);\n\tif (IS_ERR(vcm_client)) {\n\t\tdev_err(data->sensor, \"Error instantiating VCM client: %ld\\n\",\n\t\t\tPTR_ERR(vcm_client));\n\t\tgoto out_pm_put;\n\t}\n\n\tdevice_link_add(&vcm_client->dev, data->sensor, DL_FLAG_PM_RUNTIME);\n\n\tdev_info(data->sensor, \"Instantiated %s VCM\\n\", data->board_info.type);\n\tput_fwnode = false;  \n\nout_pm_put:\n\tpm_runtime_put(data->sensor);\n\tput_device(data->sensor);\n\tif (put_fwnode)\n\t\tfwnode_handle_put(data->board_info.fwnode);\n\tkfree(data);\n}\n\nint ipu_bridge_instantiate_vcm(struct device *sensor)\n{\n\tstruct ipu_bridge_instantiate_vcm_work_data *data;\n\tstruct fwnode_handle *vcm_fwnode;\n\tstruct i2c_client *vcm_client;\n\tstruct acpi_device *adev;\n\tchar *sep;\n\n\tadev = ACPI_COMPANION(sensor);\n\tif (!adev)\n\t\treturn 0;\n\n\tvcm_fwnode = fwnode_find_reference(dev_fwnode(sensor), \"lens-focus\", 0);\n\tif (IS_ERR(vcm_fwnode))\n\t\treturn 0;\n\n\t \n\tvcm_client = i2c_find_device_by_fwnode(vcm_fwnode);\n\tif (vcm_client) {\n\t\tfwnode_handle_put(vcm_fwnode);\n\t\tput_device(&vcm_client->dev);\n\t\treturn 0;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tfwnode_handle_put(vcm_fwnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&data->work, ipu_bridge_instantiate_vcm_work);\n\tdata->sensor = get_device(sensor);\n\tsnprintf(data->name, sizeof(data->name), \"%s-VCM\",\n\t\t acpi_dev_name(adev));\n\tdata->board_info.dev_name = data->name;\n\tdata->board_info.fwnode = vcm_fwnode;\n\tsnprintf(data->board_info.type, sizeof(data->board_info.type),\n\t\t \"%pfwP\", vcm_fwnode);\n\t \n\tsep = strchrnul(data->board_info.type, '-');\n\t*sep = 0;\n\n\tqueue_work(system_long_wq, &data->work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ipu_bridge_instantiate_vcm, INTEL_IPU_BRIDGE);\n\nstatic int ipu_bridge_instantiate_ivsc(struct ipu_sensor *sensor)\n{\n\tstruct fwnode_handle *fwnode;\n\n\tif (!sensor->csi_dev)\n\t\treturn 0;\n\n\tfwnode = software_node_fwnode(&sensor->swnodes[SWNODE_IVSC_HID]);\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\tset_secondary_fwnode(sensor->csi_dev, fwnode);\n\n\treturn 0;\n}\n\nstatic void ipu_bridge_unregister_sensors(struct ipu_bridge *bridge)\n{\n\tstruct ipu_sensor *sensor;\n\tunsigned int i;\n\n\tfor (i = 0; i < bridge->n_sensors; i++) {\n\t\tsensor = &bridge->sensors[i];\n\t\tsoftware_node_unregister_node_group(sensor->group);\n\t\tacpi_dev_put(sensor->adev);\n\t\tput_device(sensor->csi_dev);\n\t\tacpi_dev_put(sensor->ivsc_adev);\n\t}\n}\n\nstatic int ipu_bridge_connect_sensor(const struct ipu_sensor_config *cfg,\n\t\t\t\t     struct ipu_bridge *bridge)\n{\n\tstruct fwnode_handle *fwnode, *primary;\n\tstruct ipu_sensor *sensor;\n\tstruct acpi_device *adev;\n\tint ret;\n\n\tfor_each_acpi_dev_match(adev, cfg->hid, NULL, -1) {\n\t\tif (!adev->status.enabled)\n\t\t\tcontinue;\n\n\t\tif (bridge->n_sensors >= IPU_MAX_PORTS) {\n\t\t\tacpi_dev_put(adev);\n\t\t\tdev_err(bridge->dev, \"Exceeded available IPU ports\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsensor = &bridge->sensors[bridge->n_sensors];\n\n\t\tret = bridge->parse_sensor_fwnode(adev, sensor);\n\t\tif (ret)\n\t\t\tgoto err_put_adev;\n\n\t\tsnprintf(sensor->name, sizeof(sensor->name), \"%s-%u\",\n\t\t\t cfg->hid, sensor->link);\n\n\t\tret = ipu_bridge_check_ivsc_dev(sensor, adev);\n\t\tif (ret)\n\t\t\tgoto err_put_adev;\n\n\t\tipu_bridge_create_fwnode_properties(sensor, bridge, cfg);\n\t\tipu_bridge_create_connection_swnodes(bridge, sensor);\n\n\t\tret = software_node_register_node_group(sensor->group);\n\t\tif (ret)\n\t\t\tgoto err_put_ivsc;\n\n\t\tfwnode = software_node_fwnode(&sensor->swnodes[\n\t\t\t\t\t\t      SWNODE_SENSOR_HID]);\n\t\tif (!fwnode) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_swnodes;\n\t\t}\n\n\t\tsensor->adev = acpi_dev_get(adev);\n\n\t\tprimary = acpi_fwnode_handle(adev);\n\t\tprimary->secondary = fwnode;\n\n\t\tret = ipu_bridge_instantiate_ivsc(sensor);\n\t\tif (ret)\n\t\t\tgoto err_free_swnodes;\n\n\t\tdev_info(bridge->dev, \"Found supported sensor %s\\n\",\n\t\t\t acpi_dev_name(adev));\n\n\t\tbridge->n_sensors++;\n\t}\n\n\treturn 0;\n\nerr_free_swnodes:\n\tsoftware_node_unregister_node_group(sensor->group);\nerr_put_ivsc:\n\tput_device(sensor->csi_dev);\n\tacpi_dev_put(sensor->ivsc_adev);\nerr_put_adev:\n\tacpi_dev_put(adev);\n\treturn ret;\n}\n\nstatic int ipu_bridge_connect_sensors(struct ipu_bridge *bridge)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ipu_supported_sensors); i++) {\n\t\tconst struct ipu_sensor_config *cfg =\n\t\t\t&ipu_supported_sensors[i];\n\n\t\tret = ipu_bridge_connect_sensor(cfg, bridge);\n\t\tif (ret)\n\t\t\tgoto err_unregister_sensors;\n\t}\n\n\treturn 0;\n\nerr_unregister_sensors:\n\tipu_bridge_unregister_sensors(bridge);\n\treturn ret;\n}\n\nstatic int ipu_bridge_ivsc_is_ready(void)\n{\n\tstruct acpi_device *sensor_adev, *adev;\n\tstruct device *csi_dev;\n\tbool ready = true;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ipu_supported_sensors); i++) {\n\t\tconst struct ipu_sensor_config *cfg =\n\t\t\t&ipu_supported_sensors[i];\n\n\t\tfor_each_acpi_dev_match(sensor_adev, cfg->hid, NULL, -1) {\n\t\t\tif (!sensor_adev->status.enabled)\n\t\t\t\tcontinue;\n\n\t\t\tadev = ipu_bridge_get_ivsc_acpi_dev(sensor_adev);\n\t\t\tif (!adev)\n\t\t\t\tcontinue;\n\n\t\t\tcsi_dev = ipu_bridge_get_ivsc_csi_dev(adev);\n\t\t\tif (!csi_dev)\n\t\t\t\tready = false;\n\n\t\t\tput_device(csi_dev);\n\t\t\tacpi_dev_put(adev);\n\t\t}\n\t}\n\n\treturn ready;\n}\n\nint ipu_bridge_init(struct device *dev,\n\t\t    ipu_parse_sensor_fwnode_t parse_sensor_fwnode)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct ipu_bridge *bridge;\n\tunsigned int i;\n\tint ret;\n\n\tif (!ipu_bridge_ivsc_is_ready())\n\t\treturn -EPROBE_DEFER;\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tstrscpy(bridge->ipu_node_name, IPU_HID,\n\t\tsizeof(bridge->ipu_node_name));\n\tbridge->ipu_hid_node.name = bridge->ipu_node_name;\n\tbridge->dev = dev;\n\tbridge->parse_sensor_fwnode = parse_sensor_fwnode;\n\n\tret = software_node_register(&bridge->ipu_hid_node);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register the IPU HID node\\n\");\n\t\tgoto err_free_bridge;\n\t}\n\n\t \n\tfor (i = 0; i < IPU_MAX_LANES; i++)\n\t\tbridge->data_lanes[i] = i + 1;\n\n\tret = ipu_bridge_connect_sensors(bridge);\n\tif (ret || bridge->n_sensors == 0)\n\t\tgoto err_unregister_ipu;\n\n\tdev_info(dev, \"Connected %d cameras\\n\", bridge->n_sensors);\n\n\tfwnode = software_node_fwnode(&bridge->ipu_hid_node);\n\tif (!fwnode) {\n\t\tdev_err(dev, \"Error getting fwnode from ipu software_node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_unregister_sensors;\n\t}\n\n\tset_secondary_fwnode(dev, fwnode);\n\n\treturn 0;\n\nerr_unregister_sensors:\n\tipu_bridge_unregister_sensors(bridge);\nerr_unregister_ipu:\n\tsoftware_node_unregister(&bridge->ipu_hid_node);\nerr_free_bridge:\n\tkfree(bridge);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ipu_bridge_init, INTEL_IPU_BRIDGE);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel IPU Sensors Bridge driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}