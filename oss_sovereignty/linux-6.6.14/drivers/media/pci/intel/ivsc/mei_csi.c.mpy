{
  "module_name": "mei_csi.c",
  "hash_id": "ee6f4d32e21fc8dde790d3747d0abc1808836a7a6b092a47bdb2480ba944b1d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/intel/ivsc/mei_csi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n#include <linux/uuid.h>\n#include <linux/workqueue.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define MEI_CSI_DRIVER_NAME \"ivsc_csi\"\n#define MEI_CSI_ENTITY_NAME \"Intel IVSC CSI\"\n\n#define MEI_CSI_LINK_FREQ_400MHZ 400000000ULL\n\n \n#define CSI_CMD_TIMEOUT (5 * HZ)\n \n#define CSI_FW_READY_DELAY_MS 100\n \n#define CSI_LINK_FREQ(x) ((u32)(div_u64(x, 100 * HZ_PER_KHZ)))\n\n \nenum csi_cmd_id {\n\t \n\tCSI_SET_OWNER = 0,\n\n\t \n\tCSI_SET_CONF = 2,\n\n\t \n\tCSI_PRIVACY_NOTIF = 6,\n};\n\n \nenum csi_link_owner {\n\tCSI_LINK_IVSC,\n\tCSI_LINK_HOST,\n};\n\n \nenum ivsc_privacy_status {\n\tCSI_PRIVACY_OFF,\n\tCSI_PRIVACY_ON,\n\tCSI_PRIVACY_MAX,\n};\n\nenum csi_pads {\n\tCSI_PAD_SOURCE,\n\tCSI_PAD_SINK,\n\tCSI_NUM_PADS\n};\n\n \nstruct csi_link_cfg {\n\t \n\tu32 nr_of_lanes;\n\n\t \n\tu32 link_freq;\n\n\t \n\tu32 rsvd[2];\n} __packed;\n\n \nstruct csi_cmd {\n\tu32 cmd_id;\n\tunion _cmd_param {\n\t\tu32 param;\n\t\tstruct csi_link_cfg conf;\n\t} param;\n} __packed;\n\n \nstruct csi_notif {\n\tu32 cmd_id;\n\tint status;\n\tunion _resp_cont {\n\t\tu32 cont;\n\t\tstruct csi_link_cfg conf;\n\t} cont;\n} __packed;\n\nstruct mei_csi {\n\tstruct mei_cl_device *cldev;\n\n\t \n\tstruct csi_notif cmd_response;\n\t \n\tstruct completion cmd_completion;\n\t \n\tstruct mutex lock;\n\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_subdev *remote;\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *freq_ctrl;\n\tstruct v4l2_ctrl *privacy_ctrl;\n\tunsigned int remote_pad;\n\t \n\tint streaming;\n\n\tstruct media_pad pads[CSI_NUM_PADS];\n\tstruct v4l2_mbus_framefmt format_mbus[CSI_NUM_PADS];\n\n\t \n\tu32 nr_of_lanes;\n\t \n\tu64 link_freq;\n\n\t \n\tenum ivsc_privacy_status status;\n};\n\nstatic const struct v4l2_mbus_framefmt mei_csi_format_mbus_default = {\n\t.width = 1,\n\t.height = 1,\n\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t.field = V4L2_FIELD_NONE,\n};\n\nstatic s64 link_freq_menu_items[] = {\n\tMEI_CSI_LINK_FREQ_400MHZ\n};\n\nstatic inline struct mei_csi *notifier_to_csi(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct mei_csi, notifier);\n}\n\nstatic inline struct mei_csi *sd_to_csi(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mei_csi, subdev);\n}\n\nstatic inline struct mei_csi *ctrl_to_csi(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mei_csi, ctrl_handler);\n}\n\n \nstatic int mei_csi_send(struct mei_csi *csi, u8 *buf, size_t len)\n{\n\tstruct csi_cmd *cmd = (struct csi_cmd *)buf;\n\tint ret;\n\n\treinit_completion(&csi->cmd_completion);\n\n\tret = mei_cldev_send(csi->cldev, buf, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wait_for_completion_killable_timeout(&csi->cmd_completion,\n\t\t\t\t\t\t   CSI_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tret = csi->cmd_response.status;\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (csi->cmd_response.cmd_id != cmd->cmd_id)\n\t\tret = -EINVAL;\n\nout:\n\treturn ret;\n}\n\n \nstatic int csi_set_link_owner(struct mei_csi *csi, enum csi_link_owner owner)\n{\n\tstruct csi_cmd cmd = { 0 };\n\tsize_t cmd_size;\n\tint ret;\n\n\tcmd.cmd_id = CSI_SET_OWNER;\n\tcmd.param.param = owner;\n\tcmd_size = sizeof(cmd.cmd_id) + sizeof(cmd.param.param);\n\n\tmutex_lock(&csi->lock);\n\n\tret = mei_csi_send(csi, (u8 *)&cmd, cmd_size);\n\n\tmutex_unlock(&csi->lock);\n\n\treturn ret;\n}\n\n \nstatic int csi_set_link_cfg(struct mei_csi *csi)\n{\n\tstruct csi_cmd cmd = { 0 };\n\tsize_t cmd_size;\n\tint ret;\n\n\tcmd.cmd_id = CSI_SET_CONF;\n\tcmd.param.conf.nr_of_lanes = csi->nr_of_lanes;\n\tcmd.param.conf.link_freq = CSI_LINK_FREQ(csi->link_freq);\n\tcmd_size = sizeof(cmd.cmd_id) + sizeof(cmd.param.conf);\n\n\tmutex_lock(&csi->lock);\n\n\tret = mei_csi_send(csi, (u8 *)&cmd, cmd_size);\n\t \n\tif (!ret)\n\t\tmsleep(CSI_FW_READY_DELAY_MS);\n\n\tmutex_unlock(&csi->lock);\n\n\treturn ret;\n}\n\n \nstatic void mei_csi_rx(struct mei_cl_device *cldev)\n{\n\tstruct mei_csi *csi = mei_cldev_get_drvdata(cldev);\n\tstruct csi_notif notif = { 0 };\n\tint ret;\n\n\tret = mei_cldev_recv(cldev, (u8 *)&notif, sizeof(notif));\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"recv error: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tswitch (notif.cmd_id) {\n\tcase CSI_PRIVACY_NOTIF:\n\t\tif (notif.cont.cont < CSI_PRIVACY_MAX) {\n\t\t\tcsi->status = notif.cont.cont;\n\t\t\tv4l2_ctrl_s_ctrl(csi->privacy_ctrl, csi->status);\n\t\t}\n\t\tbreak;\n\tcase CSI_SET_OWNER:\n\tcase CSI_SET_CONF:\n\t\tmemcpy(&csi->cmd_response, &notif, ret);\n\n\t\tcomplete(&csi->cmd_completion);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mei_csi_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct mei_csi *csi = sd_to_csi(sd);\n\ts64 freq;\n\tint ret;\n\n\tif (enable && csi->streaming == 0) {\n\t\tfreq = v4l2_get_link_freq(csi->remote->ctrl_handler, 0, 0);\n\t\tif (freq < 0) {\n\t\t\tdev_err(&csi->cldev->dev,\n\t\t\t\t\"error %lld, invalid link_freq\\n\", freq);\n\t\t\tret = freq;\n\t\t\tgoto err;\n\t\t}\n\t\tcsi->link_freq = freq;\n\n\t\t \n\t\tret = csi_set_link_owner(csi, CSI_LINK_HOST);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = csi_set_link_cfg(csi);\n\t\tif (ret < 0)\n\t\t\tgoto err_switch;\n\n\t\tret = v4l2_subdev_call(csi->remote, video, s_stream, 1);\n\t\tif (ret)\n\t\t\tgoto err_switch;\n\t} else if (!enable && csi->streaming == 1) {\n\t\tv4l2_subdev_call(csi->remote, video, s_stream, 0);\n\n\t\t \n\t\tret = csi_set_link_owner(csi, CSI_LINK_IVSC);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&csi->cldev->dev,\n\t\t\t\t \"failed to switch CSI2 link: %d\\n\", ret);\n\t}\n\n\tcsi->streaming = enable;\n\n\treturn 0;\n\nerr_switch:\n\tcsi_set_link_owner(csi, CSI_LINK_IVSC);\n\nerr:\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\nmei_csi_get_pad_format(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tstruct mei_csi *csi = sd_to_csi(sd);\n\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &csi->format_mbus[pad];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int mei_csi_init_cfg(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\tstruct mei_csi *csi = sd_to_csi(sd);\n\tunsigned int i;\n\n\tmutex_lock(&csi->lock);\n\n\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\tmbusformat = v4l2_subdev_get_try_format(sd, sd_state, i);\n\t\t*mbusformat = mei_csi_format_mbus_default;\n\t}\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\nstatic int mei_csi_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\tstruct mei_csi *csi = sd_to_csi(sd);\n\n\tmutex_lock(&csi->lock);\n\n\tmbusformat = mei_csi_get_pad_format(sd, sd_state, format->pad,\n\t\t\t\t\t    format->which);\n\tif (mbusformat)\n\t\tformat->format = *mbusformat;\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\nstatic int mei_csi_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *source_mbusformat;\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\tstruct mei_csi *csi = sd_to_csi(sd);\n\tstruct media_pad *pad;\n\n\tmbusformat = mei_csi_get_pad_format(sd, sd_state, format->pad,\n\t\t\t\t\t    format->which);\n\tif (!mbusformat)\n\t\treturn -EINVAL;\n\n\tsource_mbusformat = mei_csi_get_pad_format(sd, sd_state, CSI_PAD_SOURCE,\n\t\t\t\t\t\t   format->which);\n\tif (!source_mbusformat)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&format->format.width, 1, 65536, 0,\n\t\t\t      &format->format.height, 1, 65536, 0, 0);\n\n\tswitch (format->format.code) {\n\tcase MEDIA_BUS_FMT_RGB444_1X12:\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_BGR565_2X8_BE:\n\tcase MEDIA_BUS_FMT_BGR565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RBG888_1X24:\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\tcase MEDIA_BUS_FMT_GBR888_1X24:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB888_2X12_BE:\n\tcase MEDIA_BUS_FMT_RGB888_2X12_LE:\n\tcase MEDIA_BUS_FMT_ARGB8888_1X32:\n\tcase MEDIA_BUS_FMT_RGB888_1X32_PADHI:\n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\tcase MEDIA_BUS_FMT_UV8_1X8:\n\tcase MEDIA_BUS_FMT_UYVY8_1_5X8:\n\tcase MEDIA_BUS_FMT_VYUY8_1_5X8:\n\tcase MEDIA_BUS_FMT_YUYV8_1_5X8:\n\tcase MEDIA_BUS_FMT_YVYU8_1_5X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_Y10_1X10:\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\tcase MEDIA_BUS_FMT_VYUY10_2X10:\n\tcase MEDIA_BUS_FMT_YUYV10_2X10:\n\tcase MEDIA_BUS_FMT_YVYU10_2X10:\n\tcase MEDIA_BUS_FMT_Y12_1X12:\n\tcase MEDIA_BUS_FMT_UYVY12_2X12:\n\tcase MEDIA_BUS_FMT_VYUY12_2X12:\n\tcase MEDIA_BUS_FMT_YUYV12_2X12:\n\tcase MEDIA_BUS_FMT_YVYU12_2X12:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_VYUY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\tcase MEDIA_BUS_FMT_YDYUYDYV8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\tcase MEDIA_BUS_FMT_VYUY10_1X20:\n\tcase MEDIA_BUS_FMT_YUYV10_1X20:\n\tcase MEDIA_BUS_FMT_YVYU10_1X20:\n\tcase MEDIA_BUS_FMT_VUY8_1X24:\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\tcase MEDIA_BUS_FMT_VYUY12_1X24:\n\tcase MEDIA_BUS_FMT_YUYV12_1X24:\n\tcase MEDIA_BUS_FMT_YVYU12_1X24:\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\tcase MEDIA_BUS_FMT_AYUV8_1X32:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\tcase MEDIA_BUS_FMT_JPEG_1X8:\n\tcase MEDIA_BUS_FMT_AHSV8888_1X32:\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\tcase MEDIA_BUS_FMT_SBGGR14_1X14:\n\tcase MEDIA_BUS_FMT_SGBRG14_1X14:\n\tcase MEDIA_BUS_FMT_SGRBG14_1X14:\n\tcase MEDIA_BUS_FMT_SRGGB14_1X14:\n\tcase MEDIA_BUS_FMT_SBGGR16_1X16:\n\tcase MEDIA_BUS_FMT_SGBRG16_1X16:\n\tcase MEDIA_BUS_FMT_SGRBG16_1X16:\n\tcase MEDIA_BUS_FMT_SRGGB16_1X16:\n\t\tbreak;\n\tdefault:\n\t\tformat->format.code = MEDIA_BUS_FMT_Y8_1X8;\n\t\tbreak;\n\t}\n\n\tif (format->format.field == V4L2_FIELD_ANY)\n\t\tformat->format.field = V4L2_FIELD_NONE;\n\n\tmutex_lock(&csi->lock);\n\n\tpad = &csi->pads[format->pad];\n\tif (pad->flags & MEDIA_PAD_FL_SOURCE)\n\t\tformat->format = csi->format_mbus[CSI_PAD_SINK];\n\n\t*mbusformat = format->format;\n\n\tif (pad->flags & MEDIA_PAD_FL_SINK)\n\t\t*source_mbusformat = format->format;\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\nstatic int mei_csi_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mei_csi *csi = ctrl_to_csi(ctrl);\n\ts64 freq;\n\n\tif (ctrl->id == V4L2_CID_LINK_FREQ) {\n\t\tif (!csi->remote)\n\t\t\treturn -EINVAL;\n\n\t\tfreq = v4l2_get_link_freq(csi->remote->ctrl_handler, 0, 0);\n\t\tif (freq < 0) {\n\t\t\tdev_err(&csi->cldev->dev,\n\t\t\t\t\"error %lld, invalid link_freq\\n\", freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlink_freq_menu_items[0] = freq;\n\t\tctrl->val = 0;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops mei_csi_ctrl_ops = {\n\t.g_volatile_ctrl = mei_csi_g_volatile_ctrl,\n};\n\nstatic const struct v4l2_subdev_video_ops mei_csi_video_ops = {\n\t.s_stream = mei_csi_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mei_csi_pad_ops = {\n\t.init_cfg = mei_csi_init_cfg,\n\t.get_fmt = mei_csi_get_fmt,\n\t.set_fmt = mei_csi_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops mei_csi_subdev_ops = {\n\t.video = &mei_csi_video_ops,\n\t.pad = &mei_csi_pad_ops,\n};\n\nstatic const struct media_entity_operations mei_csi_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int mei_csi_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct mei_csi *csi = notifier_to_csi(notifier);\n\tint pad;\n\n\tpad = media_entity_get_fwnode_pad(&subdev->entity, asd->match.fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0)\n\t\treturn pad;\n\n\tcsi->remote = subdev;\n\tcsi->remote_pad = pad;\n\n\treturn media_create_pad_link(&subdev->entity, pad,\n\t\t\t\t     &csi->subdev.entity, 1,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic void mei_csi_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct mei_csi *csi = notifier_to_csi(notifier);\n\n\tcsi->remote = NULL;\n}\n\nstatic const struct v4l2_async_notifier_operations mei_csi_notify_ops = {\n\t.bound = mei_csi_notify_bound,\n\t.unbind = mei_csi_notify_unbind,\n};\n\nstatic int mei_csi_init_controls(struct mei_csi *csi)\n{\n\tu32 max;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(&csi->ctrl_handler, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tcsi->ctrl_handler.lock = &csi->lock;\n\n\tmax = ARRAY_SIZE(link_freq_menu_items) - 1;\n\tcsi->freq_ctrl = v4l2_ctrl_new_int_menu(&csi->ctrl_handler,\n\t\t\t\t\t\t&mei_csi_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_LINK_FREQ,\n\t\t\t\t\t\tmax,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tlink_freq_menu_items);\n\tif (csi->freq_ctrl)\n\t\tcsi->freq_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY |\n\t\t\t\t\t V4L2_CTRL_FLAG_VOLATILE;\n\n\tcsi->privacy_ctrl = v4l2_ctrl_new_std(&csi->ctrl_handler, NULL,\n\t\t\t\t\t      V4L2_CID_PRIVACY, 0, 1, 1, 0);\n\tif (csi->privacy_ctrl)\n\t\tcsi->privacy_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tif (csi->ctrl_handler.error)\n\t\treturn csi->ctrl_handler.error;\n\n\tcsi->subdev.ctrl_handler = &csi->ctrl_handler;\n\n\treturn 0;\n}\n\nstatic int mei_csi_parse_firmware(struct mei_csi *csi)\n{\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct device *dev = &csi->cldev->dev;\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), 0, 0, 0);\n\tif (!ep) {\n\t\tdev_err(dev, \"not connected to subdevice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &v4l2_ep);\n\tif (ret) {\n\t\tdev_err(dev, \"could not parse v4l2 endpoint\\n\");\n\t\tfwnode_handle_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tfwnode_handle_put(ep);\n\n\tv4l2_async_subdev_nf_init(&csi->notifier, &csi->subdev);\n\tcsi->notifier.ops = &mei_csi_notify_ops;\n\n\tasd = v4l2_async_nf_add_fwnode(&csi->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tfwnode_handle_put(fwnode);\n\t\treturn PTR_ERR(asd);\n\t}\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(fwnode, &v4l2_ep);\n\tfwnode_handle_put(fwnode);\n\tif (ret)\n\t\treturn ret;\n\tcsi->nr_of_lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;\n\n\tret = v4l2_async_nf_register(&csi->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&csi->notifier);\n\n\tv4l2_fwnode_endpoint_free(&v4l2_ep);\n\n\treturn ret;\n}\n\nstatic int mei_csi_probe(struct mei_cl_device *cldev,\n\t\t\t const struct mei_cl_device_id *id)\n{\n\tstruct device *dev = &cldev->dev;\n\tstruct mei_csi *csi;\n\tint ret;\n\n\tif (!dev_fwnode(dev))\n\t\treturn -EPROBE_DEFER;\n\n\tcsi = devm_kzalloc(dev, sizeof(struct mei_csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\n\tcsi->cldev = cldev;\n\tmutex_init(&csi->lock);\n\tinit_completion(&csi->cmd_completion);\n\n\tmei_cldev_set_drvdata(cldev, csi);\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mei_cldev_enable failed: %d\\n\", ret);\n\t\tgoto destroy_mutex;\n\t}\n\n\tret = mei_cldev_register_rx_cb(cldev, mei_csi_rx);\n\tif (ret) {\n\t\tdev_err(dev, \"event cb registration failed: %d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tret = mei_csi_parse_firmware(csi);\n\tif (ret)\n\t\tgoto err_disable;\n\n\tcsi->subdev.dev = &cldev->dev;\n\tv4l2_subdev_init(&csi->subdev, &mei_csi_subdev_ops);\n\tv4l2_set_subdevdata(&csi->subdev, csi);\n\tcsi->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t    V4L2_SUBDEV_FL_HAS_EVENTS;\n\tcsi->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi->subdev.entity.ops = &mei_csi_entity_ops;\n\n\tsnprintf(csi->subdev.name, sizeof(csi->subdev.name),\n\t\t MEI_CSI_ENTITY_NAME);\n\n\tret = mei_csi_init_controls(csi);\n\tif (ret)\n\t\tgoto err_ctrl_handler;\n\n\tcsi->format_mbus[CSI_PAD_SOURCE] = mei_csi_format_mbus_default;\n\tcsi->format_mbus[CSI_PAD_SINK] = mei_csi_format_mbus_default;\n\n\tcsi->pads[CSI_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tcsi->pads[CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&csi->subdev.entity, CSI_NUM_PADS,\n\t\t\t\t     csi->pads);\n\tif (ret)\n\t\tgoto err_ctrl_handler;\n\n\tret = v4l2_subdev_init_finalize(&csi->subdev);\n\tif (ret < 0)\n\t\tgoto err_entity;\n\n\tret = v4l2_async_register_subdev(&csi->subdev);\n\tif (ret < 0)\n\t\tgoto err_subdev;\n\n\tpm_runtime_enable(&cldev->dev);\n\n\treturn 0;\n\nerr_subdev:\n\tv4l2_subdev_cleanup(&csi->subdev);\n\nerr_entity:\n\tmedia_entity_cleanup(&csi->subdev.entity);\n\nerr_ctrl_handler:\n\tv4l2_ctrl_handler_free(&csi->ctrl_handler);\n\tv4l2_async_nf_unregister(&csi->notifier);\n\tv4l2_async_nf_cleanup(&csi->notifier);\n\nerr_disable:\n\tmei_cldev_disable(cldev);\n\ndestroy_mutex:\n\tmutex_destroy(&csi->lock);\n\n\treturn ret;\n}\n\nstatic void mei_csi_remove(struct mei_cl_device *cldev)\n{\n\tstruct mei_csi *csi = mei_cldev_get_drvdata(cldev);\n\n\tv4l2_async_nf_unregister(&csi->notifier);\n\tv4l2_async_nf_cleanup(&csi->notifier);\n\tv4l2_ctrl_handler_free(&csi->ctrl_handler);\n\tv4l2_async_unregister_subdev(&csi->subdev);\n\tv4l2_subdev_cleanup(&csi->subdev);\n\tmedia_entity_cleanup(&csi->subdev.entity);\n\n\tpm_runtime_disable(&cldev->dev);\n\n\tmutex_destroy(&csi->lock);\n}\n\n#define MEI_CSI_UUID UUID_LE(0x92335FCF, 0x3203, 0x4472, \\\n\t\t\t     0xAF, 0x93, 0x7b, 0x44, 0x53, 0xAC, 0x29, 0xDA)\n\nstatic const struct mei_cl_device_id mei_csi_tbl[] = {\n\t{ MEI_CSI_DRIVER_NAME, MEI_CSI_UUID, MEI_CL_VERSION_ANY },\n\t{   }\n};\nMODULE_DEVICE_TABLE(mei, mei_csi_tbl);\n\nstatic struct mei_cl_driver mei_csi_driver = {\n\t.id_table = mei_csi_tbl,\n\t.name = MEI_CSI_DRIVER_NAME,\n\n\t.probe = mei_csi_probe,\n\t.remove = mei_csi_remove,\n};\n\nmodule_mei_cl_driver(mei_csi_driver);\n\nMODULE_AUTHOR(\"Wentong Wu <wentong.wu@intel.com>\");\nMODULE_AUTHOR(\"Zhifeng Wang <zhifeng.wang@intel.com>\");\nMODULE_DESCRIPTION(\"Device driver for IVSC CSI\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}