{
  "module_name": "mei_ace.c",
  "hash_id": "9702cc1e14578e919138ad932d3009788a34dd4ba247ed058457f4ec55fe5a23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/intel/ivsc/mei_ace.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/workqueue.h>\n\n#define\tMEI_ACE_DRIVER_NAME\t\"ivsc_ace\"\n\n \n#define\tACE_DRV_MSG\t\t1\n \n#define\tACE_CMD_SET\t\t4\n \n#define\tACE_CMD_TIMEOUT\t\t(5 * HZ)\n \n#define\tACE_CMD_INIT_BLOCK\t1\n \n#define\tACE_CMD_FINAL_BLOCK\t1\n \n#define\tACE_CAMERA_STATUS_SIZE\t5\n\n \n#define ACE_GET_FW_ID_UUID UUID_LE(0x6167DCFB, 0x72F1, 0x4584, 0xBF, \\\n\t\t\t\t   0xE3, 0x84, 0x17, 0x71, 0xAA, 0x79, 0x0B)\n\n \n#define MEI_CSI_UUID UUID_LE(0x92335FCF, 0x3203, 0x4472, \\\n\t\t\t     0xAF, 0x93, 0x7b, 0x44, 0x53, 0xAC, 0x29, 0xDA)\n\n \nenum ace_event_type {\n\t \n\tACE_FW_READY = 0x8,\n\n\t \n\tACE_CMD_RESPONSE = 0x10,\n};\n\n \nenum ace_camera_owner {\n\tACE_CAMERA_IVSC,\n\tACE_CAMERA_HOST,\n};\n\n \nenum ace_cmd_id {\n\t \n\tACE_SWITCH_CAMERA_TO_HOST = 0x13,\n\n\t \n\tACE_SWITCH_CAMERA_TO_IVSC = 0x14,\n\n\t \n\tACE_GET_FW_ID = 0x1A,\n};\n\n \nstruct ace_cmd_hdr {\n\tu32 firmware_id : 16;\n\tu32 instance_id : 8;\n\tu32 type : 5;\n\tu32 rsp : 1;\n\tu32 msg_tgt : 1;\n\tu32 _hw_rsvd_1 : 1;\n\tu32 param_size : 20;\n\tu32 cmd_id : 8;\n\tu32 final_block : 1;\n\tu32 init_block : 1;\n\tu32 _hw_rsvd_2 : 2;\n} __packed;\n\n \nunion ace_cmd_param {\n\tuuid_le uuid;\n\tu32 param;\n};\n\n \nstruct ace_cmd {\n\tstruct ace_cmd_hdr hdr;\n\tunion ace_cmd_param param;\n} __packed;\n\n \nunion ace_notif_hdr {\n\tstruct _confirm {\n\t\tu32 status : 24;\n\t\tu32 type : 5;\n\t\tu32 rsp : 1;\n\t\tu32 msg_tgt : 1;\n\t\tu32 _hw_rsvd_1 : 1;\n\t\tu32 param_size : 20;\n\t\tu32 cmd_id : 8;\n\t\tu32 final_block : 1;\n\t\tu32 init_block : 1;\n\t\tu32 _hw_rsvd_2 : 2;\n\t} __packed ack;\n\n\tstruct _event {\n\t\tu32 rsvd1 : 16;\n\t\tu32 event_type : 8;\n\t\tu32 type : 5;\n\t\tu32 ack : 1;\n\t\tu32 msg_tgt : 1;\n\t\tu32 _hw_rsvd_1 : 1;\n\t\tu32 rsvd2 : 30;\n\t\tu32 _hw_rsvd_2 : 2;\n\t} __packed event;\n\n\tstruct _response {\n\t\tu32 event_id : 16;\n\t\tu32 notif_type : 8;\n\t\tu32 type : 5;\n\t\tu32 rsp : 1;\n\t\tu32 msg_tgt : 1;\n\t\tu32 _hw_rsvd_1 : 1;\n\t\tu32 event_data_size : 16;\n\t\tu32 request_target : 1;\n\t\tu32 request_type : 5;\n\t\tu32 cmd_id : 8;\n\t\tu32 _hw_rsvd_2 : 2;\n\t} __packed response;\n};\n\n \nunion ace_notif_cont {\n\tu16 firmware_id;\n\tu8 state_notif;\n\tu8 camera_status[ACE_CAMERA_STATUS_SIZE];\n};\n\n \nstruct ace_notif {\n\tunion ace_notif_hdr hdr;\n\tunion ace_notif_cont cont;\n} __packed;\n\nstruct mei_ace {\n\tstruct mei_cl_device *cldev;\n\n\t \n\tstruct ace_notif cmd_ack;\n\t \n\tstruct ace_notif cmd_response;\n\t \n\tstruct completion cmd_completion;\n\t \n\tstruct mutex lock;\n\n\t \n\tu16 firmware_id;\n\n\tstruct device *csi_dev;\n\n\t \n\tstruct device_link *csi_link;\n\n\tstruct work_struct work;\n};\n\nstatic inline void init_cmd_hdr(struct ace_cmd_hdr *hdr)\n{\n\tmemset(hdr, 0, sizeof(struct ace_cmd_hdr));\n\n\thdr->type = ACE_CMD_SET;\n\thdr->msg_tgt = ACE_DRV_MSG;\n\thdr->init_block = ACE_CMD_INIT_BLOCK;\n\thdr->final_block = ACE_CMD_FINAL_BLOCK;\n}\n\nstatic int construct_command(struct mei_ace *ace, struct ace_cmd *cmd,\n\t\t\t     enum ace_cmd_id cmd_id)\n{\n\tunion ace_cmd_param *param = &cmd->param;\n\tstruct ace_cmd_hdr *hdr = &cmd->hdr;\n\n\tinit_cmd_hdr(hdr);\n\n\thdr->cmd_id = cmd_id;\n\tswitch (cmd_id) {\n\tcase ACE_GET_FW_ID:\n\t\tparam->uuid = ACE_GET_FW_ID_UUID;\n\t\thdr->param_size = sizeof(param->uuid);\n\t\tbreak;\n\tcase ACE_SWITCH_CAMERA_TO_IVSC:\n\t\tparam->param = 0;\n\t\thdr->firmware_id = ace->firmware_id;\n\t\thdr->param_size = sizeof(param->param);\n\t\tbreak;\n\tcase ACE_SWITCH_CAMERA_TO_HOST:\n\t\thdr->firmware_id = ace->firmware_id;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn hdr->param_size + sizeof(cmd->hdr);\n}\n\n \nstatic int mei_ace_send(struct mei_ace *ace, struct ace_cmd *cmd,\n\t\t\tsize_t len, bool only_ack)\n{\n\tunion ace_notif_hdr *resp_hdr = &ace->cmd_response.hdr;\n\tunion ace_notif_hdr *ack_hdr = &ace->cmd_ack.hdr;\n\tstruct ace_cmd_hdr *cmd_hdr = &cmd->hdr;\n\tint ret;\n\n\tmutex_lock(&ace->lock);\n\n\treinit_completion(&ace->cmd_completion);\n\n\tret = mei_cldev_send(ace->cldev, (u8 *)cmd, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wait_for_completion_killable_timeout(&ace->cmd_completion,\n\t\t\t\t\t\t   ACE_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (ack_hdr->ack.cmd_id != cmd_hdr->cmd_id) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = ack_hdr->ack.status;\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (only_ack)\n\t\tgoto out;\n\n\tret = wait_for_completion_killable_timeout(&ace->cmd_completion,\n\t\t\t\t\t\t   ACE_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (resp_hdr->response.cmd_id != cmd_hdr->cmd_id)\n\t\tret = -EINVAL;\n\nout:\n\tmutex_unlock(&ace->lock);\n\n\treturn ret;\n}\n\nstatic int ace_set_camera_owner(struct mei_ace *ace,\n\t\t\t\tenum ace_camera_owner owner)\n{\n\tenum ace_cmd_id cmd_id;\n\tstruct ace_cmd cmd;\n\tint cmd_size;\n\tint ret;\n\n\tif (owner == ACE_CAMERA_IVSC)\n\t\tcmd_id = ACE_SWITCH_CAMERA_TO_IVSC;\n\telse\n\t\tcmd_id = ACE_SWITCH_CAMERA_TO_HOST;\n\n\tcmd_size = construct_command(ace, &cmd, cmd_id);\n\tif (cmd_size >= 0)\n\t\tret = mei_ace_send(ace, &cmd, cmd_size, false);\n\telse\n\t\tret = cmd_size;\n\n\treturn ret;\n}\n\n \nstatic inline int ace_get_firmware_id(struct mei_ace *ace)\n{\n\tstruct ace_cmd cmd;\n\tint cmd_size;\n\tint ret;\n\n\tcmd_size = construct_command(ace, &cmd, ACE_GET_FW_ID);\n\tif (cmd_size >= 0)\n\t\tret = mei_ace_send(ace, &cmd, cmd_size, true);\n\telse\n\t\tret = cmd_size;\n\n\treturn ret;\n}\n\nstatic void handle_command_response(struct mei_ace *ace,\n\t\t\t\t    struct ace_notif *resp, int len)\n{\n\tunion ace_notif_hdr *hdr = &resp->hdr;\n\n\tswitch (hdr->response.cmd_id) {\n\tcase ACE_SWITCH_CAMERA_TO_IVSC:\n\tcase ACE_SWITCH_CAMERA_TO_HOST:\n\t\tmemcpy(&ace->cmd_response, resp, len);\n\t\tcomplete(&ace->cmd_completion);\n\t\tbreak;\n\tcase ACE_GET_FW_ID:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void handle_command_ack(struct mei_ace *ace,\n\t\t\t       struct ace_notif *ack, int len)\n{\n\tunion ace_notif_hdr *hdr = &ack->hdr;\n\n\tswitch (hdr->ack.cmd_id) {\n\tcase ACE_GET_FW_ID:\n\t\tace->firmware_id = ack->cont.firmware_id;\n\t\tfallthrough;\n\tcase ACE_SWITCH_CAMERA_TO_IVSC:\n\tcase ACE_SWITCH_CAMERA_TO_HOST:\n\t\tmemcpy(&ace->cmd_ack, ack, len);\n\t\tcomplete(&ace->cmd_completion);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void mei_ace_rx(struct mei_cl_device *cldev)\n{\n\tstruct mei_ace *ace = mei_cldev_get_drvdata(cldev);\n\tstruct ace_notif event;\n\tunion ace_notif_hdr *hdr = &event.hdr;\n\tint ret;\n\n\tret = mei_cldev_recv(cldev, (u8 *)&event, sizeof(event));\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"recv error: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (hdr->event.ack) {\n\t\thandle_command_ack(ace, &event, ret);\n\t\treturn;\n\t}\n\n\tswitch (hdr->event.event_type) {\n\tcase ACE_CMD_RESPONSE:\n\t\thandle_command_response(ace, &event, ret);\n\t\tbreak;\n\tcase ACE_FW_READY:\n\t\t \n\t\tdev_dbg(&cldev->dev, \"firmware ready\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mei_ace_setup_dev_link(struct mei_ace *ace)\n{\n\tstruct device *dev = &ace->cldev->dev;\n\tuuid_le uuid = MEI_CSI_UUID;\n\tstruct device *csi_dev;\n\tchar name[64];\n\tint ret;\n\n\tsnprintf(name, sizeof(name), \"%s-%pUl\", dev_name(dev->parent), &uuid);\n\n\tcsi_dev = device_find_child_by_name(dev->parent, name);\n\tif (!csi_dev) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err;\n\t}\n\n\t \n\tace->csi_link = device_link_add(csi_dev, dev, DL_FLAG_PM_RUNTIME |\n\t\t\t\t\tDL_FLAG_RPM_ACTIVE | DL_FLAG_STATELESS);\n\tif (!ace->csi_link) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"failed to link to %s\\n\", dev_name(csi_dev));\n\t\tgoto err_put;\n\t}\n\n\tace->csi_dev = csi_dev;\n\n\treturn 0;\n\nerr_put:\n\tput_device(csi_dev);\n\nerr:\n\treturn ret;\n}\n\n \nstatic void mei_ace_post_probe_work(struct work_struct *work)\n{\n\tstruct acpi_device *adev;\n\tstruct mei_ace *ace;\n\tstruct device *dev;\n\tint ret;\n\n\tace = container_of(work, struct mei_ace, work);\n\tdev = &ace->cldev->dev;\n\n\tret = ace_set_camera_owner(ace, ACE_CAMERA_HOST);\n\tif (ret) {\n\t\tdev_err(dev, \"switch camera to host failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tadev = ACPI_COMPANION(dev->parent);\n\tif (!adev)\n\t\treturn;\n\n\tacpi_dev_clear_dependencies(adev);\n}\n\nstatic int mei_ace_probe(struct mei_cl_device *cldev,\n\t\t\t const struct mei_cl_device_id *id)\n{\n\tstruct device *dev = &cldev->dev;\n\tstruct mei_ace *ace;\n\tint ret;\n\n\tace = devm_kzalloc(dev, sizeof(struct mei_ace), GFP_KERNEL);\n\tif (!ace)\n\t\treturn -ENOMEM;\n\n\tace->cldev = cldev;\n\tmutex_init(&ace->lock);\n\tinit_completion(&ace->cmd_completion);\n\tINIT_WORK(&ace->work, mei_ace_post_probe_work);\n\n\tmei_cldev_set_drvdata(cldev, ace);\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mei_cldev_enable failed: %d\\n\", ret);\n\t\tgoto destroy_mutex;\n\t}\n\n\tret = mei_cldev_register_rx_cb(cldev, mei_ace_rx);\n\tif (ret) {\n\t\tdev_err(dev, \"event cb registration failed: %d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tret = ace_get_firmware_id(ace);\n\tif (ret) {\n\t\tdev_err(dev, \"get firmware id failed: %d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tret = mei_ace_setup_dev_link(ace);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\tschedule_work(&ace->work);\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\nerr_disable:\n\tmei_cldev_disable(cldev);\n\ndestroy_mutex:\n\tmutex_destroy(&ace->lock);\n\n\treturn ret;\n}\n\nstatic void mei_ace_remove(struct mei_cl_device *cldev)\n{\n\tstruct mei_ace *ace = mei_cldev_get_drvdata(cldev);\n\n\tcancel_work_sync(&ace->work);\n\n\tdevice_link_del(ace->csi_link);\n\tput_device(ace->csi_dev);\n\n\tpm_runtime_disable(&cldev->dev);\n\tpm_runtime_set_suspended(&cldev->dev);\n\n\tace_set_camera_owner(ace, ACE_CAMERA_IVSC);\n\n\tmutex_destroy(&ace->lock);\n}\n\nstatic int __maybe_unused mei_ace_runtime_suspend(struct device *dev)\n{\n\tstruct mei_ace *ace = dev_get_drvdata(dev);\n\n\treturn ace_set_camera_owner(ace, ACE_CAMERA_IVSC);\n}\n\nstatic int __maybe_unused mei_ace_runtime_resume(struct device *dev)\n{\n\tstruct mei_ace *ace = dev_get_drvdata(dev);\n\n\treturn ace_set_camera_owner(ace, ACE_CAMERA_HOST);\n}\n\nstatic const struct dev_pm_ops mei_ace_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mei_ace_runtime_suspend,\n\t\t\t   mei_ace_runtime_resume, NULL)\n};\n\n#define MEI_ACE_UUID UUID_LE(0x5DB76CF6, 0x0A68, 0x4ED6, \\\n\t\t\t     0x9B, 0x78, 0x03, 0x61, 0x63, 0x5E, 0x24, 0x47)\n\nstatic const struct mei_cl_device_id mei_ace_tbl[] = {\n\t{ MEI_ACE_DRIVER_NAME, MEI_ACE_UUID, MEI_CL_VERSION_ANY },\n\t{   }\n};\nMODULE_DEVICE_TABLE(mei, mei_ace_tbl);\n\nstatic struct mei_cl_driver mei_ace_driver = {\n\t.id_table = mei_ace_tbl,\n\t.name = MEI_ACE_DRIVER_NAME,\n\n\t.probe = mei_ace_probe,\n\t.remove = mei_ace_remove,\n\n\t.driver = {\n\t\t.pm = &mei_ace_pm_ops,\n\t},\n};\n\nmodule_mei_cl_driver(mei_ace_driver);\n\nMODULE_AUTHOR(\"Wentong Wu <wentong.wu@intel.com>\");\nMODULE_AUTHOR(\"Zhifeng Wang <zhifeng.wang@intel.com>\");\nMODULE_DESCRIPTION(\"Device driver for IVSC ACE\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}