{
  "module_name": "saa7164-core.c",
  "hash_id": "03f527210a6fd922853bff3b0cfd7c17d8361464eb159138f111a1624d9259db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <asm/div64.h>\n\n#include \"saa7164.h\"\n\nMODULE_DESCRIPTION(\"Driver for NXP SAA7164 based TV cards\");\nMODULE_AUTHOR(\"Steven Toth <stoth@kernellabs.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nunsigned int saa_debug;\nmodule_param_named(debug, saa_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\nstatic unsigned int fw_debug;\nmodule_param(fw_debug, int, 0644);\nMODULE_PARM_DESC(fw_debug, \"Firmware debug level def:2\");\n\nunsigned int encoder_buffers = SAA7164_MAX_ENCODER_BUFFERS;\nmodule_param(encoder_buffers, int, 0644);\nMODULE_PARM_DESC(encoder_buffers, \"Total buffers in read queue 16-512 def:64\");\n\nunsigned int vbi_buffers = SAA7164_MAX_VBI_BUFFERS;\nmodule_param(vbi_buffers, int, 0644);\nMODULE_PARM_DESC(vbi_buffers, \"Total buffers in read queue 16-512 def:64\");\n\nunsigned int waitsecs = 10;\nmodule_param(waitsecs, int, 0644);\nMODULE_PARM_DESC(waitsecs, \"timeout on firmware messages\");\n\nstatic unsigned int card[]  = {[0 ... (SAA7164_MAXBOARDS - 1)] = UNSET };\nmodule_param_array(card,  int, NULL, 0444);\nMODULE_PARM_DESC(card, \"card type\");\n\nstatic unsigned int print_histogram = 64;\nmodule_param(print_histogram, int, 0644);\nMODULE_PARM_DESC(print_histogram, \"print histogram values once\");\n\nunsigned int crc_checking = 1;\nmodule_param(crc_checking, int, 0644);\nMODULE_PARM_DESC(crc_checking, \"enable crc sanity checking on buffers\");\n\nstatic unsigned int guard_checking = 1;\nmodule_param(guard_checking, int, 0644);\nMODULE_PARM_DESC(guard_checking,\n\t\"enable dma sanity checking for buffer overruns\");\n\nstatic bool enable_msi = true;\nmodule_param(enable_msi, bool, 0444);\nMODULE_PARM_DESC(enable_msi,\n\t\t\"enable the use of an msi interrupt if available\");\n\nstatic unsigned int saa7164_devcount;\n\nstatic DEFINE_MUTEX(devlist);\nLIST_HEAD(saa7164_devlist);\n\n#define INT_SIZE 16\n\nstatic void saa7164_pack_verifier(struct saa7164_buffer *buf)\n{\n\tu8 *p = (u8 *)buf->cpu;\n\tint i;\n\n\tfor (i = 0; i < buf->actual_size; i += 2048) {\n\n\t\tif ((*(p + i + 0) != 0x00) || (*(p + i + 1) != 0x00) ||\n\t\t\t(*(p + i + 2) != 0x01) || (*(p + i + 3) != 0xBA)) {\n\t\t\tprintk(KERN_ERR \"No pack at 0x%x\\n\", i);\n#if 0\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       p + 1, 32, false);\n#endif\n\t\t}\n\t}\n}\n\n#define FIXED_VIDEO_PID 0xf1\n#define FIXED_AUDIO_PID 0xf2\n\nstatic void saa7164_ts_verifier(struct saa7164_buffer *buf)\n{\n\tstruct saa7164_port *port = buf->port;\n\tu32 i;\n\tu8 cc, a;\n\tu16 pid;\n\tu8 *bufcpu = (u8 *)buf->cpu;\n\n\tport->sync_errors = 0;\n\tport->v_cc_errors = 0;\n\tport->a_cc_errors = 0;\n\n\tfor (i = 0; i < buf->actual_size; i += 188) {\n\t\tif (*(bufcpu + i) != 0x47)\n\t\t\tport->sync_errors++;\n\n\t\t \n\t\tpid = ((*(bufcpu + i + 1) & 0x1f) << 8) | *(bufcpu + i + 2);\n\t\tcc = *(bufcpu + i + 3) & 0x0f;\n\n\t\tif (pid == FIXED_VIDEO_PID) {\n\t\t\ta = ((port->last_v_cc + 1) & 0x0f);\n\t\t\tif (a != cc) {\n\t\t\t\tprintk(KERN_ERR \"video cc last = %x current = %x i = %d\\n\",\n\t\t\t\t\tport->last_v_cc, cc, i);\n\t\t\t\tport->v_cc_errors++;\n\t\t\t}\n\n\t\t\tport->last_v_cc = cc;\n\t\t} else\n\t\tif (pid == FIXED_AUDIO_PID) {\n\t\t\ta = ((port->last_a_cc + 1) & 0x0f);\n\t\t\tif (a != cc) {\n\t\t\t\tprintk(KERN_ERR \"audio cc last = %x current = %x i = %d\\n\",\n\t\t\t\t\tport->last_a_cc, cc, i);\n\t\t\t\tport->a_cc_errors++;\n\t\t\t}\n\n\t\t\tport->last_a_cc = cc;\n\t\t}\n\n\t}\n\n\t \n\tif (port->v_cc_errors && (port->done_first_interrupt > 1))\n\t\tprintk(KERN_ERR \"video pid cc, %d errors\\n\", port->v_cc_errors);\n\n\tif (port->a_cc_errors && (port->done_first_interrupt > 1))\n\t\tprintk(KERN_ERR \"audio pid cc, %d errors\\n\", port->a_cc_errors);\n\n\tif (port->sync_errors && (port->done_first_interrupt > 1))\n\t\tprintk(KERN_ERR \"sync_errors = %d\\n\", port->sync_errors);\n\n\tif (port->done_first_interrupt == 1)\n\t\tport->done_first_interrupt++;\n}\n\nstatic void saa7164_histogram_reset(struct saa7164_histogram *hg, char *name)\n{\n\tint i;\n\n\tmemset(hg, 0, sizeof(struct saa7164_histogram));\n\tstrscpy(hg->name, name, sizeof(hg->name));\n\n\t \n\tfor (i = 0; i < 30; i++)\n\t\thg->counter1[0 + i].val = i;\n\n\t \n\tfor (i = 0; i < 18; i++)\n\t\thg->counter1[30 + i].val = 30 + (i * 10);\n\n\t \n\tfor (i = 0; i < 15; i++)\n\t\thg->counter1[48 + i].val = 200 + (i * 200);\n\n\t \n\thg->counter1[55].val = 2000;\n\n\t \n\thg->counter1[56].val = 4000;\n\n\t \n\thg->counter1[57].val = 8000;\n\n\t \n\thg->counter1[58].val = 15000;\n\n\t \n\thg->counter1[59].val = 30000;\n\n\t \n\thg->counter1[60].val = 60000;\n\n\t \n\thg->counter1[61].val = 300000;\n\n\t \n\thg->counter1[62].val = 900000;\n\n\t \n\thg->counter1[63].val = 3600000;\n}\n\nvoid saa7164_histogram_update(struct saa7164_histogram *hg, u32 val)\n{\n\tint i;\n\tfor (i = 0; i < 64; i++) {\n\t\tif (val <= hg->counter1[i].val) {\n\t\t\thg->counter1[i].count++;\n\t\t\thg->counter1[i].update_time = jiffies;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void saa7164_histogram_print(struct saa7164_port *port,\n\tstruct saa7164_histogram *hg)\n{\n\tu32 entries = 0;\n\tint i;\n\n\tprintk(KERN_ERR \"Histogram named %s (ms, count, last_update_jiffy)\\n\", hg->name);\n\tfor (i = 0; i < 64; i++) {\n\t\tif (hg->counter1[i].count == 0)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_ERR \" %4d %12d %Ld\\n\",\n\t\t\thg->counter1[i].val,\n\t\t\thg->counter1[i].count,\n\t\t\thg->counter1[i].update_time);\n\n\t\tentries++;\n\t}\n\tprintk(KERN_ERR \"Total: %d\\n\", entries);\n}\n\nstatic void saa7164_work_enchandler_helper(struct saa7164_port *port, int bufnr)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf = NULL;\n\tstruct saa7164_user_buffer *ubuf = NULL;\n\tstruct list_head *c, *n;\n\tint i = 0;\n\tu8 *p;\n\n\tmutex_lock(&port->dmaqueue_lock);\n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\n\t\tbuf = list_entry(c, struct saa7164_buffer, list);\n\t\tif (i++ > port->hwcfg.buffercount) {\n\t\t\tprintk(KERN_ERR \"%s() illegal i count %d\\n\",\n\t\t\t\t__func__, i);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf->idx == bufnr) {\n\n\t\t\t \n\t\t\tdprintk(DBGLVL_IRQ, \"%s() bufnr: %d\\n\", __func__, bufnr);\n\n\t\t\tif (crc_checking) {\n\t\t\t\t \n\t\t\t\tbuf->crc = crc32(0, buf->cpu, buf->actual_size);\n\t\t\t}\n\n\t\t\tif (guard_checking) {\n\t\t\t\tp = (u8 *)buf->cpu;\n\t\t\t\tif ((*(p + buf->actual_size + 0) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 1) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 2) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 3) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 0x10) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 0x11) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 0x12) != 0xff) ||\n\t\t\t\t\t(*(p + buf->actual_size + 0x13) != 0xff)) {\n\t\t\t\t\t\tprintk(KERN_ERR \"%s() buf %p guard buffer breach\\n\",\n\t\t\t\t\t\t\t__func__, buf);\n#if 0\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       p + buf->actual_size - 32, 64, false);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((port->nr != SAA7164_PORT_VBI1) && (port->nr != SAA7164_PORT_VBI2)) {\n\t\t\t\t \n\t\t\t\tif (port->encoder_params.stream_type == V4L2_MPEG_STREAM_TYPE_MPEG2_TS)\n\t\t\t\t\tsaa7164_ts_verifier(buf);\n\t\t\t\telse if (port->encoder_params.stream_type == V4L2_MPEG_STREAM_TYPE_MPEG2_PS)\n\t\t\t\t\tsaa7164_pack_verifier(buf);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!list_empty(&port->list_buf_free.list)) {\n\n\t\t\t\t \n\t\t\t\tubuf = list_first_entry(&port->list_buf_free.list,\n\t\t\t\t\tstruct saa7164_user_buffer, list);\n\n\t\t\t\tif (buf->actual_size <= ubuf->actual_size) {\n\n\t\t\t\t\tmemcpy(ubuf->data, buf->cpu, ubuf->actual_size);\n\n\t\t\t\t\tif (crc_checking) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tubuf->crc = crc32(0, ubuf->data, ubuf->actual_size);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tubuf->pos = 0;\n\n\t\t\t\t\tlist_move_tail(&ubuf->list,\n\t\t\t\t\t\t&port->list_buf_used.list);\n\n\t\t\t\t\t \n\t\t\t\t\twake_up_interruptible(&port->wait_read);\n\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_ERR \"buf %p bufsize fails match\\n\", buf);\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\tprintk(KERN_ERR \"encirq no free buffers, increase param encoder_buffers\\n\");\n\n\t\t\t \n\t\t\tsaa7164_buffer_zero_offsets(port, bufnr);\n\t\t\tmemset(buf->cpu, 0xff, buf->pci_size);\n\t\t\tif (crc_checking) {\n\t\t\t\t \n\t\t\t\tbuf->crc = crc32(0, buf->cpu, buf->actual_size);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&port->dmaqueue_lock);\n}\n\nstatic void saa7164_work_enchandler(struct work_struct *w)\n{\n\tstruct saa7164_port *port =\n\t\tcontainer_of(w, struct saa7164_port, workenc);\n\tstruct saa7164_dev *dev = port->dev;\n\n\tu32 wp, mcb, rp;\n\n\tport->last_svc_msecs_diff = port->last_svc_msecs;\n\tport->last_svc_msecs = jiffies_to_msecs(jiffies);\n\n\tport->last_svc_msecs_diff = port->last_svc_msecs -\n\t\tport->last_svc_msecs_diff;\n\n\tsaa7164_histogram_update(&port->svc_interval,\n\t\tport->last_svc_msecs_diff);\n\n\tport->last_irq_svc_msecs_diff = port->last_svc_msecs -\n\t\tport->last_irq_msecs;\n\n\tsaa7164_histogram_update(&port->irq_svc_interval,\n\t\tport->last_irq_svc_msecs_diff);\n\n\tdprintk(DBGLVL_IRQ,\n\t\t\"%s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\\n\",\n\t\t__func__,\n\t\tport->last_svc_msecs_diff,\n\t\tport->last_irq_svc_msecs_diff,\n\t\tport->last_svc_wp,\n\t\tport->last_svc_rp\n\t\t);\n\n\t \n\twp = saa7164_readl(port->bufcounter);\n\tif (wp > (port->hwcfg.buffercount - 1)) {\n\t\tprintk(KERN_ERR \"%s() illegal buf count %d\\n\", __func__, wp);\n\t\treturn;\n\t}\n\n\t \n\tif (wp == 0)\n\t\tmcb = (port->hwcfg.buffercount - 1);\n\telse\n\t\tmcb = wp - 1;\n\n\twhile (1) {\n\t\tif (port->done_first_interrupt == 0) {\n\t\t\tport->done_first_interrupt++;\n\t\t\trp = mcb;\n\t\t} else\n\t\t\trp = (port->last_svc_rp + 1) % 8;\n\n\t\tif (rp > (port->hwcfg.buffercount - 1)) {\n\t\t\tprintk(KERN_ERR \"%s() illegal rp count %d\\n\", __func__, rp);\n\t\t\tbreak;\n\t\t}\n\n\t\tsaa7164_work_enchandler_helper(port, rp);\n\t\tport->last_svc_rp = rp;\n\n\t\tif (rp == mcb)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (print_histogram == port->nr) {\n\t\tsaa7164_histogram_print(port, &port->irq_interval);\n\t\tsaa7164_histogram_print(port, &port->svc_interval);\n\t\tsaa7164_histogram_print(port, &port->irq_svc_interval);\n\t\tsaa7164_histogram_print(port, &port->read_interval);\n\t\tsaa7164_histogram_print(port, &port->poll_interval);\n\t\t \n\t\tprint_histogram = 64 + port->nr;\n\t}\n}\n\nstatic void saa7164_work_vbihandler(struct work_struct *w)\n{\n\tstruct saa7164_port *port =\n\t\tcontainer_of(w, struct saa7164_port, workenc);\n\tstruct saa7164_dev *dev = port->dev;\n\n\tu32 wp, mcb, rp;\n\n\tport->last_svc_msecs_diff = port->last_svc_msecs;\n\tport->last_svc_msecs = jiffies_to_msecs(jiffies);\n\tport->last_svc_msecs_diff = port->last_svc_msecs -\n\t\tport->last_svc_msecs_diff;\n\n\tsaa7164_histogram_update(&port->svc_interval,\n\t\tport->last_svc_msecs_diff);\n\n\tport->last_irq_svc_msecs_diff = port->last_svc_msecs -\n\t\tport->last_irq_msecs;\n\n\tsaa7164_histogram_update(&port->irq_svc_interval,\n\t\tport->last_irq_svc_msecs_diff);\n\n\tdprintk(DBGLVL_IRQ,\n\t\t\"%s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\\n\",\n\t\t__func__,\n\t\tport->last_svc_msecs_diff,\n\t\tport->last_irq_svc_msecs_diff,\n\t\tport->last_svc_wp,\n\t\tport->last_svc_rp\n\t\t);\n\n\t \n\twp = saa7164_readl(port->bufcounter);\n\tif (wp > (port->hwcfg.buffercount - 1)) {\n\t\tprintk(KERN_ERR \"%s() illegal buf count %d\\n\", __func__, wp);\n\t\treturn;\n\t}\n\n\t \n\tif (wp == 0)\n\t\tmcb = (port->hwcfg.buffercount - 1);\n\telse\n\t\tmcb = wp - 1;\n\n\twhile (1) {\n\t\tif (port->done_first_interrupt == 0) {\n\t\t\tport->done_first_interrupt++;\n\t\t\trp = mcb;\n\t\t} else\n\t\t\trp = (port->last_svc_rp + 1) % 8;\n\n\t\tif (rp > (port->hwcfg.buffercount - 1)) {\n\t\t\tprintk(KERN_ERR \"%s() illegal rp count %d\\n\", __func__, rp);\n\t\t\tbreak;\n\t\t}\n\n\t\tsaa7164_work_enchandler_helper(port, rp);\n\t\tport->last_svc_rp = rp;\n\n\t\tif (rp == mcb)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (print_histogram == port->nr) {\n\t\tsaa7164_histogram_print(port, &port->irq_interval);\n\t\tsaa7164_histogram_print(port, &port->svc_interval);\n\t\tsaa7164_histogram_print(port, &port->irq_svc_interval);\n\t\tsaa7164_histogram_print(port, &port->read_interval);\n\t\tsaa7164_histogram_print(port, &port->poll_interval);\n\t\t \n\t\tprint_histogram = 64 + port->nr;\n\t}\n}\n\nstatic void saa7164_work_cmdhandler(struct work_struct *w)\n{\n\tstruct saa7164_dev *dev = container_of(w, struct saa7164_dev, workcmd);\n\n\t \n\tsaa7164_irq_dequeue(dev);\n}\n\nstatic void saa7164_buffer_deliver(struct saa7164_buffer *buf)\n{\n\tstruct saa7164_port *port = buf->port;\n\n\t \n\tdvb_dmx_swfilter_packets(&port->dvb.demux, (u8 *)buf->cpu,\n\t\tSAA7164_TS_NUMBER_OF_LINES);\n\n}\n\nstatic irqreturn_t saa7164_irq_vbi(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\t \n\tport->last_irq_msecs_diff = port->last_irq_msecs;\n\n\t \n\tport->last_irq_msecs = jiffies_to_msecs(jiffies);\n\n\t \n\tport->last_irq_msecs_diff = port->last_irq_msecs -\n\t\tport->last_irq_msecs_diff;\n\n\tsaa7164_histogram_update(&port->irq_interval,\n\t\tport->last_irq_msecs_diff);\n\n\tdprintk(DBGLVL_IRQ, \"%s() %Ldms elapsed\\n\", __func__,\n\t\tport->last_irq_msecs_diff);\n\n\t \n\tschedule_work(&port->workenc);\n\treturn 0;\n}\n\nstatic irqreturn_t saa7164_irq_encoder(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\t \n\tport->last_irq_msecs_diff = port->last_irq_msecs;\n\n\t \n\tport->last_irq_msecs = jiffies_to_msecs(jiffies);\n\n\t \n\tport->last_irq_msecs_diff = port->last_irq_msecs -\n\t\tport->last_irq_msecs_diff;\n\n\tsaa7164_histogram_update(&port->irq_interval,\n\t\tport->last_irq_msecs_diff);\n\n\tdprintk(DBGLVL_IRQ, \"%s() %Ldms elapsed\\n\", __func__,\n\t\tport->last_irq_msecs_diff);\n\n\tschedule_work(&port->workenc);\n\treturn 0;\n}\n\nstatic irqreturn_t saa7164_irq_ts(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct list_head *c, *n;\n\tint wp, i = 0, rp;\n\n\t \n\twp = saa7164_readl(port->bufcounter);\n\n\tBUG_ON(wp > (port->hwcfg.buffercount - 1));\n\n\t \n\tif (wp == 0)\n\t\trp = (port->hwcfg.buffercount - 1);\n\telse\n\t\trp = wp - 1;\n\n\t \n\t \n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\t\tbuf = list_entry(c, struct saa7164_buffer, list);\n\t\tBUG_ON(i > port->hwcfg.buffercount);\n\t\ti++;\n\n\t\tif (buf->idx == rp) {\n\t\t\t \n\t\t\tdprintk(DBGLVL_IRQ, \"%s() wp: %d processing: %d\\n\",\n\t\t\t\t__func__, wp, rp);\n\t\t\tsaa7164_buffer_deliver(buf);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n \nstatic irqreturn_t saa7164_irq(int irq, void *dev_id)\n{\n\tstruct saa7164_dev *dev = dev_id;\n\tstruct saa7164_port *porta, *portb, *portc, *portd, *porte, *portf;\n\n\tu32 intid, intstat[INT_SIZE/4];\n\tint i, handled = 0, bit;\n\n\tif (dev == NULL) {\n\t\tprintk(KERN_ERR \"%s() No device specified\\n\", __func__);\n\t\thandled = 0;\n\t\tgoto out;\n\t}\n\n\tporta = &dev->ports[SAA7164_PORT_TS1];\n\tportb = &dev->ports[SAA7164_PORT_TS2];\n\tportc = &dev->ports[SAA7164_PORT_ENC1];\n\tportd = &dev->ports[SAA7164_PORT_ENC2];\n\tporte = &dev->ports[SAA7164_PORT_VBI1];\n\tportf = &dev->ports[SAA7164_PORT_VBI2];\n\n\t \n\tfor (i = 0; i < INT_SIZE/4; i++) {\n\n\t\t \n\t\t \n\t\tintstat[i] = saa7164_readl(dev->int_status + (i * 4));\n\n\t\tif (intstat[i])\n\t\t\thandled = 1;\n\t}\n\tif (handled == 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < INT_SIZE/4; i++) {\n\n\t\tif (intstat[i]) {\n\t\t\t \n\t\t\tfor (bit = 0; bit < 32; bit++) {\n\n\t\t\t\tif (((intstat[i] >> bit) & 0x00000001) == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\n\t\t\t\tintid = (i * 32) + bit;\n\t\t\t\tif (intid == dev->intfdesc.bInterruptId) {\n\t\t\t\t\t \n\t\t\t\t\tschedule_work(&dev->workcmd);\n\t\t\t\t} else if (intid == porta->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_ts(porta);\n\n\t\t\t\t} else if (intid == portb->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_ts(portb);\n\n\t\t\t\t} else if (intid == portc->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_encoder(portc);\n\n\t\t\t\t} else if (intid == portd->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_encoder(portd);\n\n\t\t\t\t} else if (intid == porte->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_vbi(porte);\n\n\t\t\t\t} else if (intid == portf->hwcfg.interruptid) {\n\n\t\t\t\t\t \n\t\t\t\t\tsaa7164_irq_vbi(portf);\n\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdprintk(DBGLVL_IRQ,\n\t\t\t\t\t\t\"%s() unhandled interrupt reg 0x%x bit 0x%x intid = 0x%x\\n\",\n\t\t\t\t\t\t__func__, i, bit, intid);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tsaa7164_writel(dev->int_ack + (i * 4), intstat[i]);\n\n\t\t}\n\t}\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\nvoid saa7164_getfirmwarestatus(struct saa7164_dev *dev)\n{\n\tstruct saa7164_fw_status *s = &dev->fw_status;\n\n\tdev->fw_status.status = saa7164_readl(SAA_DEVICE_SYSINIT_STATUS);\n\tdev->fw_status.mode = saa7164_readl(SAA_DEVICE_SYSINIT_MODE);\n\tdev->fw_status.spec = saa7164_readl(SAA_DEVICE_SYSINIT_SPEC);\n\tdev->fw_status.inst = saa7164_readl(SAA_DEVICE_SYSINIT_INST);\n\tdev->fw_status.cpuload = saa7164_readl(SAA_DEVICE_SYSINIT_CPULOAD);\n\tdev->fw_status.remainheap =\n\t\tsaa7164_readl(SAA_DEVICE_SYSINIT_REMAINHEAP);\n\n\tdprintk(1, \"Firmware status:\\n\");\n\tdprintk(1, \" .status     = 0x%08x\\n\", s->status);\n\tdprintk(1, \" .mode       = 0x%08x\\n\", s->mode);\n\tdprintk(1, \" .spec       = 0x%08x\\n\", s->spec);\n\tdprintk(1, \" .inst       = 0x%08x\\n\", s->inst);\n\tdprintk(1, \" .cpuload    = 0x%08x\\n\", s->cpuload);\n\tdprintk(1, \" .remainheap = 0x%08x\\n\", s->remainheap);\n}\n\nu32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev)\n{\n\tu32 reg;\n\n\treg = saa7164_readl(SAA_DEVICE_VERSION);\n\tdprintk(1, \"Device running firmware version %d.%d.%d.%d (0x%x)\\n\",\n\t\t(reg & 0x0000fc00) >> 10,\n\t\t(reg & 0x000003e0) >> 5,\n\t\t(reg & 0x0000001f),\n\t\t(reg & 0xffff0000) >> 16,\n\t\treg);\n\n\treturn reg;\n}\n\n \nvoid saa7164_dumpregs(struct saa7164_dev *dev, u32 addr)\n{\n\tint i;\n\n\tdprintk(1, \"--------------------> 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\\n\");\n\n\tfor (i = 0; i < 0x100; i += 16)\n\t\tdprintk(1, \"region0[0x%08x] = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\\n\",\n\t\t\ti,\n\t\t\t(u8)saa7164_readb(addr + i + 0),\n\t\t\t(u8)saa7164_readb(addr + i + 1),\n\t\t\t(u8)saa7164_readb(addr + i + 2),\n\t\t\t(u8)saa7164_readb(addr + i + 3),\n\t\t\t(u8)saa7164_readb(addr + i + 4),\n\t\t\t(u8)saa7164_readb(addr + i + 5),\n\t\t\t(u8)saa7164_readb(addr + i + 6),\n\t\t\t(u8)saa7164_readb(addr + i + 7),\n\t\t\t(u8)saa7164_readb(addr + i + 8),\n\t\t\t(u8)saa7164_readb(addr + i + 9),\n\t\t\t(u8)saa7164_readb(addr + i + 10),\n\t\t\t(u8)saa7164_readb(addr + i + 11),\n\t\t\t(u8)saa7164_readb(addr + i + 12),\n\t\t\t(u8)saa7164_readb(addr + i + 13),\n\t\t\t(u8)saa7164_readb(addr + i + 14),\n\t\t\t(u8)saa7164_readb(addr + i + 15)\n\t\t\t);\n}\n\nstatic void saa7164_dump_hwdesc(struct saa7164_dev *dev)\n{\n\tdprintk(1, \"@0x%p hwdesc sizeof(struct tmComResHWDescr) = %d bytes\\n\",\n\t\t&dev->hwdesc, (u32)sizeof(struct tmComResHWDescr));\n\n\tdprintk(1, \" .bLength = 0x%x\\n\", dev->hwdesc.bLength);\n\tdprintk(1, \" .bDescriptorType = 0x%x\\n\", dev->hwdesc.bDescriptorType);\n\tdprintk(1, \" .bDescriptorSubtype = 0x%x\\n\",\n\t\tdev->hwdesc.bDescriptorSubtype);\n\n\tdprintk(1, \" .bcdSpecVersion = 0x%x\\n\", dev->hwdesc.bcdSpecVersion);\n\tdprintk(1, \" .dwClockFrequency = 0x%x\\n\", dev->hwdesc.dwClockFrequency);\n\tdprintk(1, \" .dwClockUpdateRes = 0x%x\\n\", dev->hwdesc.dwClockUpdateRes);\n\tdprintk(1, \" .bCapabilities = 0x%x\\n\", dev->hwdesc.bCapabilities);\n\tdprintk(1, \" .dwDeviceRegistersLocation = 0x%x\\n\",\n\t\tdev->hwdesc.dwDeviceRegistersLocation);\n\n\tdprintk(1, \" .dwHostMemoryRegion = 0x%x\\n\",\n\t\tdev->hwdesc.dwHostMemoryRegion);\n\n\tdprintk(1, \" .dwHostMemoryRegionSize = 0x%x\\n\",\n\t\tdev->hwdesc.dwHostMemoryRegionSize);\n\n\tdprintk(1, \" .dwHostHibernatMemRegion = 0x%x\\n\",\n\t\tdev->hwdesc.dwHostHibernatMemRegion);\n\n\tdprintk(1, \" .dwHostHibernatMemRegionSize = 0x%x\\n\",\n\t\tdev->hwdesc.dwHostHibernatMemRegionSize);\n}\n\nstatic void saa7164_dump_intfdesc(struct saa7164_dev *dev)\n{\n\tdprintk(1, \"@0x%p intfdesc sizeof(struct tmComResInterfaceDescr) = %d bytes\\n\",\n\t\t&dev->intfdesc, (u32)sizeof(struct tmComResInterfaceDescr));\n\n\tdprintk(1, \" .bLength = 0x%x\\n\", dev->intfdesc.bLength);\n\tdprintk(1, \" .bDescriptorType = 0x%x\\n\", dev->intfdesc.bDescriptorType);\n\tdprintk(1, \" .bDescriptorSubtype = 0x%x\\n\",\n\t\tdev->intfdesc.bDescriptorSubtype);\n\n\tdprintk(1, \" .bFlags = 0x%x\\n\", dev->intfdesc.bFlags);\n\tdprintk(1, \" .bInterfaceType = 0x%x\\n\", dev->intfdesc.bInterfaceType);\n\tdprintk(1, \" .bInterfaceId = 0x%x\\n\", dev->intfdesc.bInterfaceId);\n\tdprintk(1, \" .bBaseInterface = 0x%x\\n\", dev->intfdesc.bBaseInterface);\n\tdprintk(1, \" .bInterruptId = 0x%x\\n\", dev->intfdesc.bInterruptId);\n\tdprintk(1, \" .bDebugInterruptId = 0x%x\\n\",\n\t\tdev->intfdesc.bDebugInterruptId);\n\n\tdprintk(1, \" .BARLocation = 0x%x\\n\", dev->intfdesc.BARLocation);\n}\n\nstatic void saa7164_dump_busdesc(struct saa7164_dev *dev)\n{\n\tdprintk(1, \"@0x%p busdesc sizeof(struct tmComResBusDescr) = %d bytes\\n\",\n\t\t&dev->busdesc, (u32)sizeof(struct tmComResBusDescr));\n\n\tdprintk(1, \" .CommandRing   = 0x%016Lx\\n\", dev->busdesc.CommandRing);\n\tdprintk(1, \" .ResponseRing  = 0x%016Lx\\n\", dev->busdesc.ResponseRing);\n\tdprintk(1, \" .CommandWrite  = 0x%x\\n\", dev->busdesc.CommandWrite);\n\tdprintk(1, \" .CommandRead   = 0x%x\\n\", dev->busdesc.CommandRead);\n\tdprintk(1, \" .ResponseWrite = 0x%x\\n\", dev->busdesc.ResponseWrite);\n\tdprintk(1, \" .ResponseRead  = 0x%x\\n\", dev->busdesc.ResponseRead);\n}\n\n \nstatic void saa7164_get_descriptors(struct saa7164_dev *dev)\n{\n\tmemcpy_fromio(&dev->hwdesc, dev->bmmio, sizeof(struct tmComResHWDescr));\n\tmemcpy_fromio(&dev->intfdesc, dev->bmmio + sizeof(struct tmComResHWDescr),\n\t\tsizeof(struct tmComResInterfaceDescr));\n\tmemcpy_fromio(&dev->busdesc, dev->bmmio + dev->intfdesc.BARLocation,\n\t\tsizeof(struct tmComResBusDescr));\n\n\tif (dev->hwdesc.bLength != sizeof(struct tmComResHWDescr)) {\n\t\tprintk(KERN_ERR \"Structure struct tmComResHWDescr is mangled\\n\");\n\t\tprintk(KERN_ERR \"Need %x got %d\\n\", dev->hwdesc.bLength,\n\t\t\t(u32)sizeof(struct tmComResHWDescr));\n\t} else\n\t\tsaa7164_dump_hwdesc(dev);\n\n\tif (dev->intfdesc.bLength != sizeof(struct tmComResInterfaceDescr)) {\n\t\tprintk(KERN_ERR \"struct struct tmComResInterfaceDescr is mangled\\n\");\n\t\tprintk(KERN_ERR \"Need %x got %d\\n\", dev->intfdesc.bLength,\n\t\t\t(u32)sizeof(struct tmComResInterfaceDescr));\n\t} else\n\t\tsaa7164_dump_intfdesc(dev);\n\n\tsaa7164_dump_busdesc(dev);\n}\n\nstatic int saa7164_pci_quirks(struct saa7164_dev *dev)\n{\n\treturn 0;\n}\n\nstatic int get_resources(struct saa7164_dev *dev)\n{\n\tif (request_mem_region(pci_resource_start(dev->pci, 0),\n\t\tpci_resource_len(dev->pci, 0), dev->name)) {\n\n\t\tif (request_mem_region(pci_resource_start(dev->pci, 2),\n\t\t\tpci_resource_len(dev->pci, 2), dev->name))\n\t\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"%s: can't get MMIO memory @ 0x%llx or 0x%llx\\n\",\n\t\tdev->name,\n\t\t(u64)pci_resource_start(dev->pci, 0),\n\t\t(u64)pci_resource_start(dev->pci, 2));\n\n\treturn -EBUSY;\n}\n\nstatic int saa7164_port_init(struct saa7164_dev *dev, int portnr)\n{\n\tstruct saa7164_port *port = NULL;\n\n\tBUG_ON((portnr < 0) || (portnr >= SAA7164_MAX_PORTS));\n\n\tport = &dev->ports[portnr];\n\n\tport->dev = dev;\n\tport->nr = portnr;\n\n\tif ((portnr == SAA7164_PORT_TS1) || (portnr == SAA7164_PORT_TS2))\n\t\tport->type = SAA7164_MPEG_DVB;\n\telse\n\tif ((portnr == SAA7164_PORT_ENC1) || (portnr == SAA7164_PORT_ENC2)) {\n\t\tport->type = SAA7164_MPEG_ENCODER;\n\n\t\t \n\t\tINIT_WORK(&port->workenc, saa7164_work_enchandler);\n\t} else if ((portnr == SAA7164_PORT_VBI1) || (portnr == SAA7164_PORT_VBI2)) {\n\t\tport->type = SAA7164_MPEG_VBI;\n\n\t\t \n\t\tINIT_WORK(&port->workenc, saa7164_work_vbihandler);\n\t} else\n\t\tBUG();\n\n\t \n\tmutex_init(&port->dvb.lock);\n\tINIT_LIST_HEAD(&port->dmaqueue.list);\n\tmutex_init(&port->dmaqueue_lock);\n\n\tINIT_LIST_HEAD(&port->list_buf_used.list);\n\tINIT_LIST_HEAD(&port->list_buf_free.list);\n\tinit_waitqueue_head(&port->wait_read);\n\n\n\tsaa7164_histogram_reset(&port->irq_interval, \"irq intervals\");\n\tsaa7164_histogram_reset(&port->svc_interval, \"deferred intervals\");\n\tsaa7164_histogram_reset(&port->irq_svc_interval,\n\t\t\"irq to deferred intervals\");\n\tsaa7164_histogram_reset(&port->read_interval,\n\t\t\"encoder/vbi read() intervals\");\n\tsaa7164_histogram_reset(&port->poll_interval,\n\t\t\"encoder/vbi poll() intervals\");\n\n\treturn 0;\n}\n\nstatic int saa7164_dev_setup(struct saa7164_dev *dev)\n{\n\tint i;\n\n\tmutex_init(&dev->lock);\n\tatomic_inc(&dev->refcount);\n\tdev->nr = saa7164_devcount++;\n\n\tsnprintf(dev->name, sizeof(dev->name), \"saa7164[%d]\", dev->nr);\n\n\tmutex_lock(&devlist);\n\tlist_add_tail(&dev->devlist, &saa7164_devlist);\n\tmutex_unlock(&devlist);\n\n\t \n\tdev->board = UNSET;\n\tif (card[dev->nr] < saa7164_bcount)\n\t\tdev->board = card[dev->nr];\n\n\tfor (i = 0; UNSET == dev->board  &&  i < saa7164_idcount; i++)\n\t\tif (dev->pci->subsystem_vendor == saa7164_subids[i].subvendor &&\n\t\t\tdev->pci->subsystem_device ==\n\t\t\t\tsaa7164_subids[i].subdevice)\n\t\t\t\tdev->board = saa7164_subids[i].card;\n\n\tif (UNSET == dev->board) {\n\t\tdev->board = SAA7164_BOARD_UNKNOWN;\n\t\tsaa7164_card_list(dev);\n\t}\n\n\tdev->pci_bus  = dev->pci->bus->number;\n\tdev->pci_slot = PCI_SLOT(dev->pci->devfn);\n\n\t \n\tdev->i2c_bus[0].dev = dev;\n\tdev->i2c_bus[0].nr = 0;\n\tdev->i2c_bus[1].dev = dev;\n\tdev->i2c_bus[1].nr = 1;\n\tdev->i2c_bus[2].dev = dev;\n\tdev->i2c_bus[2].nr = 2;\n\n\t \n\tsaa7164_port_init(dev, SAA7164_PORT_TS1);\n\tsaa7164_port_init(dev, SAA7164_PORT_TS2);\n\tsaa7164_port_init(dev, SAA7164_PORT_ENC1);\n\tsaa7164_port_init(dev, SAA7164_PORT_ENC2);\n\tsaa7164_port_init(dev, SAA7164_PORT_VBI1);\n\tsaa7164_port_init(dev, SAA7164_PORT_VBI2);\n\n\tif (get_resources(dev) < 0) {\n\t\tprintk(KERN_ERR \"CORE %s No more PCIe resources for subsystem: %04x:%04x\\n\",\n\t\t       dev->name, dev->pci->subsystem_vendor,\n\t\t       dev->pci->subsystem_device);\n\n\t\tsaa7164_devcount--;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->lmmio = ioremap(pci_resource_start(dev->pci, 0),\n\t\t\t     pci_resource_len(dev->pci, 0));\n\n\tdev->lmmio2 = ioremap(pci_resource_start(dev->pci, 2),\n\t\t\t     pci_resource_len(dev->pci, 2));\n\n\tdev->bmmio = (u8 __iomem *)dev->lmmio;\n\tdev->bmmio2 = (u8 __iomem *)dev->lmmio2;\n\n\t \n\tdev->int_status = 0x183000 + 0xf80;\n\tdev->int_ack = 0x183000 + 0xf90;\n\n\tprintk(KERN_INFO\n\t\t\"CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\\n\",\n\t       dev->name, dev->pci->subsystem_vendor,\n\t       dev->pci->subsystem_device, saa7164_boards[dev->board].name,\n\t       dev->board, card[dev->nr] == dev->board ?\n\t       \"insmod option\" : \"autodetected\");\n\n\tsaa7164_pci_quirks(dev);\n\n\treturn 0;\n}\n\nstatic void saa7164_dev_unregister(struct saa7164_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\trelease_mem_region(pci_resource_start(dev->pci, 0),\n\t\tpci_resource_len(dev->pci, 0));\n\n\trelease_mem_region(pci_resource_start(dev->pci, 2),\n\t\tpci_resource_len(dev->pci, 2));\n\n\tif (!atomic_dec_and_test(&dev->refcount))\n\t\treturn;\n\n\tiounmap(dev->lmmio);\n\tiounmap(dev->lmmio2);\n\n\treturn;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void *saa7164_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct saa7164_dev *dev;\n\tloff_t index = *pos;\n\n\tmutex_lock(&devlist);\n\tlist_for_each_entry(dev, &saa7164_devlist, devlist) {\n\t\tif (index-- == 0) {\n\t\t\tmutex_unlock(&devlist);\n\t\t\treturn dev;\n\t\t}\n\t}\n\tmutex_unlock(&devlist);\n\n\treturn NULL;\n}\n\nstatic void *saa7164_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct saa7164_dev *dev = v;\n\tvoid *ret;\n\n\tmutex_lock(&devlist);\n\tif (list_is_last(&dev->devlist, &saa7164_devlist))\n\t\tret = NULL;\n\telse\n\t\tret = list_next_entry(dev, devlist);\n\tmutex_unlock(&devlist);\n\n\t++*pos;\n\n\treturn ret;\n}\n\nstatic void saa7164_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int saa7164_seq_show(struct seq_file *m, void *v)\n{\n\tstruct saa7164_dev *dev = v;\n\tstruct tmComResBusInfo *b;\n\tint i, c;\n\n\tseq_printf(m, \"%s = %p\\n\", dev->name, dev);\n\n\t \n\tb = &dev->bus;\n\tmutex_lock(&b->lock);\n\n\tseq_printf(m, \" .m_pdwSetWritePos = 0x%x (0x%08x)\\n\",\n\t\t   b->m_dwSetReadPos, saa7164_readl(b->m_dwSetReadPos));\n\n\tseq_printf(m, \" .m_pdwSetReadPos  = 0x%x (0x%08x)\\n\",\n\t\t   b->m_dwSetWritePos, saa7164_readl(b->m_dwSetWritePos));\n\n\tseq_printf(m, \" .m_pdwGetWritePos = 0x%x (0x%08x)\\n\",\n\t\t   b->m_dwGetReadPos, saa7164_readl(b->m_dwGetReadPos));\n\n\tseq_printf(m, \" .m_pdwGetReadPos  = 0x%x (0x%08x)\\n\",\n\t\t   b->m_dwGetWritePos, saa7164_readl(b->m_dwGetWritePos));\n\tc = 0;\n\tseq_puts(m, \"\\n  Set Ring:\\n\");\n\tseq_puts(m, \"\\n addr  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\\n\");\n\tfor (i = 0; i < b->m_dwSizeSetRing; i++) {\n\t\tif (c == 0)\n\t\t\tseq_printf(m, \" %04x:\", i);\n\n\t\tseq_printf(m, \" %02x\", readb(b->m_pdwSetRing + i));\n\n\t\tif (++c == 16) {\n\t\t\tseq_puts(m, \"\\n\");\n\t\t\tc = 0;\n\t\t}\n\t}\n\n\tc = 0;\n\tseq_puts(m, \"\\n  Get Ring:\\n\");\n\tseq_puts(m, \"\\n addr  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\\n\");\n\tfor (i = 0; i < b->m_dwSizeGetRing; i++) {\n\t\tif (c == 0)\n\t\t\tseq_printf(m, \" %04x:\", i);\n\n\t\tseq_printf(m, \" %02x\", readb(b->m_pdwGetRing + i));\n\n\t\tif (++c == 16) {\n\t\t\tseq_puts(m, \"\\n\");\n\t\t\tc = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&b->lock);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations saa7164_sops = {\n\t.start = saa7164_seq_start,\n\t.next = saa7164_seq_next,\n\t.stop = saa7164_seq_stop,\n\t.show = saa7164_seq_show,\n};\n\nDEFINE_SEQ_ATTRIBUTE(saa7164);\n\nstatic struct dentry *saa7614_dentry;\n\nstatic void __init saa7164_debugfs_create(void)\n{\n\tsaa7614_dentry = debugfs_create_file(\"saa7164\", 0444, NULL, NULL,\n\t\t\t\t\t     &saa7164_fops);\n}\n\nstatic void __exit saa7164_debugfs_remove(void)\n{\n\tdebugfs_remove(saa7614_dentry);\n}\n#else\nstatic void saa7164_debugfs_create(void) { }\nstatic void saa7164_debugfs_remove(void) { }\n#endif\n\nstatic int saa7164_thread_function(void *data)\n{\n\tstruct saa7164_dev *dev = data;\n\tstruct tmFwInfoStruct fwinfo;\n\tu64 last_poll_time = 0;\n\n\tdprintk(DBGLVL_THR, \"thread started\\n\");\n\n\tset_freezable();\n\n\twhile (1) {\n\t\tmsleep_interruptible(100);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\ttry_to_freeze();\n\n\t\tdprintk(DBGLVL_THR, \"thread running\\n\");\n\n\t\t \n\t\t \n\t\t \n\t\tsaa7164_api_collect_debug(dev);\n\n\t\t \n\t\tif ((last_poll_time + 1000  ) < jiffies_to_msecs(jiffies)) {\n\t\t\tsaa7164_api_get_load_info(dev, &fwinfo);\n\t\t\tlast_poll_time = jiffies_to_msecs(jiffies);\n\t\t}\n\n\t}\n\n\tdprintk(DBGLVL_THR, \"thread exiting\\n\");\n\treturn 0;\n}\n\nstatic bool saa7164_enable_msi(struct pci_dev *pci_dev, struct saa7164_dev *dev)\n{\n\tint err;\n\n\tif (!enable_msi) {\n\t\tprintk(KERN_WARNING \"%s() MSI disabled by module parameter 'enable_msi'\"\n\t\t       , __func__);\n\t\treturn false;\n\t}\n\n\terr = pci_enable_msi(pci_dev);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s() Failed to enable MSI interrupt. Falling back to a shared IRQ\\n\",\n\t\t       __func__);\n\t\treturn false;\n\t}\n\n\t \n\terr = request_irq(pci_dev->irq, saa7164_irq, 0,\n\t\t\t\t\t\tdev->name, dev);\n\n\tif (err) {\n\t\t \n\t\tprintk(KERN_ERR \"%s() Failed to get an MSI interrupt. Falling back to a shared IRQ\\n\",\n\t\t       __func__);\n\t\tpci_disable_msi(pci_dev);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int saa7164_initdev(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct saa7164_dev *dev;\n\tint err, i;\n\tu32 version;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (NULL == dev)\n\t\treturn -ENOMEM;\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev, \"v4l2_device_register failed\\n\");\n\t\tgoto fail_free;\n\t}\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto fail_free;\n\t}\n\n\tif (saa7164_dev_setup(dev) < 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail_dev;\n\t}\n\n\t \n\tdev->pci_rev = pci_dev->revision;\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tprintk(KERN_INFO \"%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t       dev->name,\n\t       pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t       dev->pci_lat,\n\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\n\tpci_set_master(pci_dev);\n\t \n\terr = dma_set_mask(&pci_dev->dev, 0xffffffff);\n\tif (err) {\n\t\tprintk(\"%s/0: Oops: no 32bit PCI DMA ???\\n\", dev->name);\n\t\tgoto fail_irq;\n\t}\n\n\t \n\tif (saa7164_enable_msi(pci_dev, dev)) {\n\t\tdev->msi = true;\n\t} else {\n\t\t \n\n\t\terr = request_irq(pci_dev->irq, saa7164_irq,\n\t\t\t\tIRQF_SHARED, dev->name, dev);\n\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"%s: can't get IRQ %d\\n\", dev->name,\n\t\t\t       pci_dev->irq);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_irq;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pci_dev, dev);\n\n\t \n\tfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\n\t\tdev->cmds[i].seqno = i;\n\t\tdev->cmds[i].inuse = 0;\n\t\tmutex_init(&dev->cmds[i].lock);\n\t\tinit_waitqueue_head(&dev->cmds[i].wait);\n\t}\n\n\t \n\tINIT_WORK(&dev->workcmd, saa7164_work_cmdhandler);\n\n\t \n\tif (dev->board != SAA7164_BOARD_UNKNOWN) {\n\n\t\terr = saa7164_downloadfirmware(dev);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"Failed to boot firmware, no features registered\\n\");\n\t\t\tgoto fail_fw;\n\t\t}\n\n\t\tsaa7164_get_descriptors(dev);\n\t\tsaa7164_dumpregs(dev, 0);\n\t\tsaa7164_getcurrentfirmwareversion(dev);\n\t\tsaa7164_getfirmwarestatus(dev);\n\t\terr = saa7164_bus_setup(dev);\n\t\tif (err < 0)\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"Failed to setup the bus, will continue\\n\");\n\t\tsaa7164_bus_dump(dev);\n\n\t\t \n\t\tversion = 0;\n\t\tif (saa7164_api_get_fw_version(dev, &version) == SAA_OK)\n\t\t\tdprintk(1, \"Bus is operating correctly using version %d.%d.%d.%d (0x%x)\\n\",\n\t\t\t\t(version & 0x0000fc00) >> 10,\n\t\t\t\t(version & 0x000003e0) >> 5,\n\t\t\t\t(version & 0x0000001f),\n\t\t\t\t(version & 0xffff0000) >> 16,\n\t\t\t\tversion);\n\t\telse\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"Failed to communicate with the firmware\\n\");\n\n\t\t \n\t\tsaa7164_i2c_register(&dev->i2c_bus[0]);\n\t\tsaa7164_i2c_register(&dev->i2c_bus[1]);\n\t\tsaa7164_i2c_register(&dev->i2c_bus[2]);\n\t\tsaa7164_gpio_setup(dev);\n\t\tsaa7164_card_setup(dev);\n\n\t\t \n\t\tsaa7164_api_enum_subdevs(dev);\n\n\t\t \n\t\tif (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB) {\n\t\t\tif (saa7164_dvb_register(&dev->ports[SAA7164_PORT_TS1]) < 0) {\n\t\t\t\tprintk(KERN_ERR \"%s() Failed to register dvb adapters on porta\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\n\t\tif (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB) {\n\t\t\tif (saa7164_dvb_register(&dev->ports[SAA7164_PORT_TS2]) < 0) {\n\t\t\t\tprintk(KERN_ERR\"%s() Failed to register dvb adapters on portb\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\n\t\tif (saa7164_boards[dev->board].portc == SAA7164_MPEG_ENCODER) {\n\t\t\tif (saa7164_encoder_register(&dev->ports[SAA7164_PORT_ENC1]) < 0) {\n\t\t\t\tprintk(KERN_ERR\"%s() Failed to register mpeg encoder\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t}\n\n\t\tif (saa7164_boards[dev->board].portd == SAA7164_MPEG_ENCODER) {\n\t\t\tif (saa7164_encoder_register(&dev->ports[SAA7164_PORT_ENC2]) < 0) {\n\t\t\t\tprintk(KERN_ERR\"%s() Failed to register mpeg encoder\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t}\n\n\t\tif (saa7164_boards[dev->board].porte == SAA7164_MPEG_VBI) {\n\t\t\tif (saa7164_vbi_register(&dev->ports[SAA7164_PORT_VBI1]) < 0) {\n\t\t\t\tprintk(KERN_ERR\"%s() Failed to register vbi device\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t}\n\n\t\tif (saa7164_boards[dev->board].portf == SAA7164_MPEG_VBI) {\n\t\t\tif (saa7164_vbi_register(&dev->ports[SAA7164_PORT_VBI2]) < 0) {\n\t\t\t\tprintk(KERN_ERR\"%s() Failed to register vbi device\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t}\n\t\tsaa7164_api_set_debug(dev, fw_debug);\n\n\t\tif (fw_debug) {\n\t\t\tdev->kthread = kthread_run(saa7164_thread_function, dev,\n\t\t\t\t\"saa7164 debug\");\n\t\t\tif (IS_ERR(dev->kthread)) {\n\t\t\t\tdev->kthread = NULL;\n\t\t\t\tprintk(KERN_ERR \"%s() Failed to create debug kernel thread\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t}\n\n\t}  \n\telse\n\t\tprintk(KERN_ERR \"%s() Unsupported board detected, registering without firmware\\n\",\n\t\t       __func__);\n\n\tdprintk(1, \"%s() parameter debug = %d\\n\", __func__, saa_debug);\n\tdprintk(1, \"%s() parameter waitsecs = %d\\n\", __func__, waitsecs);\n\nfail_fw:\n\treturn 0;\n\nfail_irq:\n\tsaa7164_dev_unregister(dev);\nfail_dev:\n\tpci_disable_device(pci_dev);\nfail_free:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void saa7164_shutdown(struct saa7164_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n}\n\nstatic void saa7164_finidev(struct pci_dev *pci_dev)\n{\n\tstruct saa7164_dev *dev = pci_get_drvdata(pci_dev);\n\n\tif (dev->board != SAA7164_BOARD_UNKNOWN) {\n\t\tif (fw_debug && dev->kthread) {\n\t\t\tkthread_stop(dev->kthread);\n\t\t\tdev->kthread = NULL;\n\t\t}\n\t\tif (dev->firmwareloaded)\n\t\t\tsaa7164_api_set_debug(dev, 0x00);\n\t}\n\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\n\t\t&dev->ports[SAA7164_PORT_ENC1].irq_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\n\t\t&dev->ports[SAA7164_PORT_ENC1].svc_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\n\t\t&dev->ports[SAA7164_PORT_ENC1].irq_svc_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\n\t\t&dev->ports[SAA7164_PORT_ENC1].read_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\n\t\t&dev->ports[SAA7164_PORT_ENC1].poll_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_VBI1],\n\t\t&dev->ports[SAA7164_PORT_VBI1].read_interval);\n\tsaa7164_histogram_print(&dev->ports[SAA7164_PORT_VBI2],\n\t\t&dev->ports[SAA7164_PORT_VBI2].poll_interval);\n\n\tsaa7164_shutdown(dev);\n\n\tif (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB)\n\t\tsaa7164_dvb_unregister(&dev->ports[SAA7164_PORT_TS1]);\n\n\tif (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB)\n\t\tsaa7164_dvb_unregister(&dev->ports[SAA7164_PORT_TS2]);\n\n\tif (saa7164_boards[dev->board].portc == SAA7164_MPEG_ENCODER)\n\t\tsaa7164_encoder_unregister(&dev->ports[SAA7164_PORT_ENC1]);\n\n\tif (saa7164_boards[dev->board].portd == SAA7164_MPEG_ENCODER)\n\t\tsaa7164_encoder_unregister(&dev->ports[SAA7164_PORT_ENC2]);\n\n\tif (saa7164_boards[dev->board].porte == SAA7164_MPEG_VBI)\n\t\tsaa7164_vbi_unregister(&dev->ports[SAA7164_PORT_VBI1]);\n\n\tif (saa7164_boards[dev->board].portf == SAA7164_MPEG_VBI)\n\t\tsaa7164_vbi_unregister(&dev->ports[SAA7164_PORT_VBI2]);\n\n\tsaa7164_i2c_unregister(&dev->i2c_bus[0]);\n\tsaa7164_i2c_unregister(&dev->i2c_bus[1]);\n\tsaa7164_i2c_unregister(&dev->i2c_bus[2]);\n\n\t \n\tfree_irq(pci_dev->irq, dev);\n\n\tif (dev->msi) {\n\t\tpci_disable_msi(pci_dev);\n\t\tdev->msi = false;\n\t}\n\n\tpci_disable_device(pci_dev);\n\n\tmutex_lock(&devlist);\n\tlist_del(&dev->devlist);\n\tmutex_unlock(&devlist);\n\n\tsaa7164_dev_unregister(dev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id saa7164_pci_tbl[] = {\n\t{\n\t\t \n\t\t.vendor       = 0x1131,\n\t\t.device       = 0x7164,\n\t\t.subvendor    = PCI_ANY_ID,\n\t\t.subdevice    = PCI_ANY_ID,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(pci, saa7164_pci_tbl);\n\nstatic struct pci_driver saa7164_pci_driver = {\n\t.name     = \"saa7164\",\n\t.id_table = saa7164_pci_tbl,\n\t.probe    = saa7164_initdev,\n\t.remove   = saa7164_finidev,\n};\n\nstatic int __init saa7164_init(void)\n{\n\tint ret = pci_register_driver(&saa7164_pci_driver);\n\n\tif (ret)\n\t\treturn ret;\n\n\tsaa7164_debugfs_create();\n\n\tpr_info(\"saa7164 driver loaded\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit saa7164_fini(void)\n{\n\tsaa7164_debugfs_remove();\n\tpci_unregister_driver(&saa7164_pci_driver);\n}\n\nmodule_init(saa7164_init);\nmodule_exit(saa7164_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}