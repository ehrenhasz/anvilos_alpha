{
  "module_name": "saa7164-buffer.c",
  "hash_id": "88b55250aa80ec29da02abe92acc2e0ff70e25c8335548f09a2f60411feb916a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-buffer.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"saa7164.h\"\n\n \n\nvoid saa7164_buffer_display(struct saa7164_buffer *buf)\n{\n\tstruct saa7164_dev *dev = buf->port->dev;\n\tint i;\n\n\tdprintk(DBGLVL_BUF, \"%s()   buffer @ 0x%p nr=%d\\n\",\n\t\t__func__, buf, buf->idx);\n\tdprintk(DBGLVL_BUF, \"  pci_cpu @ 0x%p    dma @ 0x%08llx len = 0x%x\\n\",\n\t\tbuf->cpu, (long long)buf->dma, buf->pci_size);\n\tdprintk(DBGLVL_BUF, \"   pt_cpu @ 0x%p pt_dma @ 0x%08llx len = 0x%x\\n\",\n\t\tbuf->pt_cpu, (long long)buf->pt_dma, buf->pt_size);\n\n\t \n\tfor (i = 0 ; i < SAA7164_PT_ENTRIES; i++) {\n\n\t\tdprintk(DBGLVL_BUF, \"    pt[%02d] = 0x%p -> 0x%llx\\n\",\n\t\t\ti, buf->pt_cpu, (u64)*(buf->pt_cpu));\n\n\t}\n}\n \nstruct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_port *port,\n\tu32 len)\n{\n\tstruct tmHWStreamParameters *params = &port->hw_streamingparams;\n\tstruct saa7164_buffer *buf = NULL;\n\tstruct saa7164_dev *dev = port->dev;\n\tint i;\n\n\tif ((len == 0) || (len >= 65536) || (len % sizeof(u64))) {\n\t\tlog_warn(\"%s() SAA_ERR_BAD_PARAMETER\\n\", __func__);\n\t\tgoto ret;\n\t}\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\tgoto ret;\n\n\tbuf->idx = -1;\n\tbuf->port = port;\n\tbuf->flags = SAA7164_BUFFER_FREE;\n\tbuf->pos = 0;\n\tbuf->actual_size = params->pitch * params->numberoflines;\n\tbuf->crc = 0;\n\t \n\tbuf->pci_size = SAA7164_PT_ENTRIES * 0x1000;\n\tbuf->pt_size = (SAA7164_PT_ENTRIES * sizeof(u64)) + 0x1000;\n\n\t \n\tbuf->cpu = dma_alloc_coherent(&port->dev->pci->dev, buf->pci_size,\n\t\t\t\t      &buf->dma, GFP_KERNEL);\n\tif (!buf->cpu)\n\t\tgoto fail1;\n\n\tbuf->pt_cpu = dma_alloc_coherent(&port->dev->pci->dev, buf->pt_size,\n\t\t\t\t\t &buf->pt_dma, GFP_KERNEL);\n\tif (!buf->pt_cpu)\n\t\tgoto fail2;\n\n\t \n\tmemset(buf->cpu, 0xff, buf->pci_size);\n\tbuf->crc = crc32(0, buf->cpu, buf->actual_size);\n\tmemset(buf->pt_cpu, 0xff, buf->pt_size);\n\n\tdprintk(DBGLVL_BUF, \"%s()   allocated buffer @ 0x%p (%d pageptrs)\\n\",\n\t\t__func__, buf, params->numpagetables);\n\tdprintk(DBGLVL_BUF, \"  pci_cpu @ 0x%p    dma @ 0x%08lx len = 0x%x\\n\",\n\t\tbuf->cpu, (long)buf->dma, buf->pci_size);\n\tdprintk(DBGLVL_BUF, \"   pt_cpu @ 0x%p pt_dma @ 0x%08lx len = 0x%x\\n\",\n\t\tbuf->pt_cpu, (long)buf->pt_dma, buf->pt_size);\n\n\t \n\tfor (i = 0 ; i < params->numpagetables; i++) {\n\n\t\t*(buf->pt_cpu + i) = buf->dma + (i * 0x1000);  \n\t\tdprintk(DBGLVL_BUF, \"    pt[%02d] = 0x%p -> 0x%llx\\n\",\n\t\t\ti, buf->pt_cpu, (u64)*(buf->pt_cpu));\n\n\t}\n\n\tgoto ret;\n\nfail2:\n\tdma_free_coherent(&port->dev->pci->dev, buf->pci_size, buf->cpu,\n\t\t\t  buf->dma);\nfail1:\n\tkfree(buf);\n\n\tbuf = NULL;\nret:\n\treturn buf;\n}\n\nint saa7164_buffer_dealloc(struct saa7164_buffer *buf)\n{\n\tstruct saa7164_dev *dev;\n\n\tif (!buf || !buf->port)\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\tdev = buf->port->dev;\n\n\tdprintk(DBGLVL_BUF, \"%s() deallocating buffer @ 0x%p\\n\",\n\t\t__func__, buf);\n\n\tif (buf->flags != SAA7164_BUFFER_FREE)\n\t\tlog_warn(\" freeing a non-free buffer\\n\");\n\n\tdma_free_coherent(&dev->pci->dev, buf->pci_size, buf->cpu, buf->dma);\n\tdma_free_coherent(&dev->pci->dev, buf->pt_size, buf->pt_cpu,\n\t\t\t  buf->pt_dma);\n\n\tkfree(buf);\n\n\treturn SAA_OK;\n}\n\nint saa7164_buffer_zero_offsets(struct saa7164_port *port, int i)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\tif ((i < 0) || (i >= port->hwcfg.buffercount))\n\t\treturn -EINVAL;\n\n\tdprintk(DBGLVL_BUF, \"%s(idx = %d)\\n\", __func__, i);\n\n\tsaa7164_writel(port->bufoffset + (sizeof(u32) * i), 0);\n\n\treturn 0;\n}\n\n \nint saa7164_buffer_activate(struct saa7164_buffer *buf, int i)\n{\n\tstruct saa7164_port *port = buf->port;\n\tstruct saa7164_dev *dev = port->dev;\n\n\tif ((i < 0) || (i >= port->hwcfg.buffercount))\n\t\treturn -EINVAL;\n\n\tdprintk(DBGLVL_BUF, \"%s(idx = %d)\\n\", __func__, i);\n\n\tbuf->idx = i;  \n\tbuf->flags = SAA7164_BUFFER_BUSY;\n\tbuf->pos = 0;\n\n\t \n\tsaa7164_writel(port->bufoffset + (sizeof(u32) * i), 0);\n\tsaa7164_writel(port->bufptr32h + ((sizeof(u32) * 2) * i), buf->pt_dma);\n\tsaa7164_writel(port->bufptr32l + ((sizeof(u32) * 2) * i), 0);\n\n\tdprintk(DBGLVL_BUF, \"\tbuf[%d] offset 0x%llx (0x%x) buf 0x%llx/%llx (0x%x/%x) nr=%d\\n\",\n\t\tbuf->idx,\n\t\t(u64)port->bufoffset + (i * sizeof(u32)),\n\t\tsaa7164_readl(port->bufoffset + (sizeof(u32) * i)),\n\t\t(u64)port->bufptr32h + ((sizeof(u32) * 2) * i),\n\t\t(u64)port->bufptr32l + ((sizeof(u32) * 2) * i),\n\t\tsaa7164_readl(port->bufptr32h + ((sizeof(u32) * i) * 2)),\n\t\tsaa7164_readl(port->bufptr32l + ((sizeof(u32) * i) * 2)),\n\t\tbuf->idx);\n\n\treturn 0;\n}\n\nint saa7164_buffer_cfg_port(struct saa7164_port *port)\n{\n\tstruct tmHWStreamParameters *params = &port->hw_streamingparams;\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct list_head *c, *n;\n\tint i = 0;\n\n\tdprintk(DBGLVL_BUF, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tsaa7164_writel(port->bufcounter, 0);\n\tsaa7164_writel(port->pitch, params->pitch);\n\tsaa7164_writel(port->bufsize, params->pitch * params->numberoflines);\n\n\tdprintk(DBGLVL_BUF, \" configured:\\n\");\n\tdprintk(DBGLVL_BUF, \"   lmmio       0x%p\\n\", dev->lmmio);\n\tdprintk(DBGLVL_BUF, \"   bufcounter  0x%x = 0x%x\\n\", port->bufcounter,\n\t\tsaa7164_readl(port->bufcounter));\n\n\tdprintk(DBGLVL_BUF, \"   pitch       0x%x = %d\\n\", port->pitch,\n\t\tsaa7164_readl(port->pitch));\n\n\tdprintk(DBGLVL_BUF, \"   bufsize     0x%x = %d\\n\", port->bufsize,\n\t\tsaa7164_readl(port->bufsize));\n\n\tdprintk(DBGLVL_BUF, \"   buffercount = %d\\n\", port->hwcfg.buffercount);\n\tdprintk(DBGLVL_BUF, \"   bufoffset = 0x%x\\n\", port->bufoffset);\n\tdprintk(DBGLVL_BUF, \"   bufptr32h = 0x%x\\n\", port->bufptr32h);\n\tdprintk(DBGLVL_BUF, \"   bufptr32l = 0x%x\\n\", port->bufptr32l);\n\n\t \n\tmutex_lock(&port->dmaqueue_lock);\n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\t\tbuf = list_entry(c, struct saa7164_buffer, list);\n\n\t\tBUG_ON(buf->flags != SAA7164_BUFFER_FREE);\n\n\t\t \n\t\tsaa7164_buffer_activate(buf, i);\n\n\t\t \n\t\tBUG_ON(i > port->hwcfg.buffercount);\n\t\ti++;\n\n\t}\n\tmutex_unlock(&port->dmaqueue_lock);\n\n\treturn 0;\n}\n\nstruct saa7164_user_buffer *saa7164_buffer_alloc_user(struct saa7164_dev *dev,\n\tu32 len)\n{\n\tstruct saa7164_user_buffer *buf;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->data = kzalloc(len, GFP_KERNEL);\n\n\tif (!buf->data) {\n\t\tkfree(buf);\n\t\treturn NULL;\n\t}\n\n\tbuf->actual_size = len;\n\tbuf->pos = 0;\n\tbuf->crc = 0;\n\n\tdprintk(DBGLVL_BUF, \"%s()   allocated user buffer @ 0x%p\\n\",\n\t\t__func__, buf);\n\n\treturn buf;\n}\n\nvoid saa7164_buffer_dealloc_user(struct saa7164_user_buffer *buf)\n{\n\tif (!buf)\n\t\treturn;\n\n\tkfree(buf->data);\n\tbuf->data = NULL;\n\n\tkfree(buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}