{
  "module_name": "saa7164-dvb.c",
  "hash_id": "faf1025a7c2bf4c0c2828504b052c50eba926aa776845bb55f8a42d934f063d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-dvb.c",
  "human_readable_source": "\n \n\n#include \"saa7164.h\"\n\n#include \"tda10048.h\"\n#include \"tda18271.h\"\n#include \"s5h1411.h\"\n#include \"si2157.h\"\n#include \"si2168.h\"\n#include \"lgdt3306a.h\"\n\n#define DRIVER_NAME \"saa7164\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n \nstatic struct tda10048_config hauppauge_hvr2200_1_config = {\n\t.demod_address    = 0x10 >> 1,\n\t.output_mode      = TDA10048_SERIAL_OUTPUT,\n\t.fwbulkwritelen   = TDA10048_BULKWRITE_200,\n\t.inversion        = TDA10048_INVERSION_ON,\n\t.dtv6_if_freq_khz = TDA10048_IF_3300,\n\t.dtv7_if_freq_khz = TDA10048_IF_3500,\n\t.dtv8_if_freq_khz = TDA10048_IF_4000,\n\t.clk_freq_khz     = TDA10048_CLK_16000,\n};\nstatic struct tda10048_config hauppauge_hvr2200_2_config = {\n\t.demod_address    = 0x12 >> 1,\n\t.output_mode      = TDA10048_SERIAL_OUTPUT,\n\t.fwbulkwritelen   = TDA10048_BULKWRITE_200,\n\t.inversion        = TDA10048_INVERSION_ON,\n\t.dtv6_if_freq_khz = TDA10048_IF_3300,\n\t.dtv7_if_freq_khz = TDA10048_IF_3500,\n\t.dtv8_if_freq_khz = TDA10048_IF_4000,\n\t.clk_freq_khz     = TDA10048_CLK_16000,\n};\n\nstatic struct tda18271_std_map hauppauge_tda18271_std_map = {\n\t.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 3,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 0,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n};\n\nstatic struct tda18271_config hauppauge_hvr22x0_tuner_config = {\n\t.std_map\t= &hauppauge_tda18271_std_map,\n\t.gate\t\t= TDA18271_GATE_ANALOG,\n\t.role\t\t= TDA18271_MASTER,\n};\n\nstatic struct tda18271_config hauppauge_hvr22x0s_tuner_config = {\n\t.std_map\t= &hauppauge_tda18271_std_map,\n\t.gate\t\t= TDA18271_GATE_ANALOG,\n\t.role\t\t= TDA18271_SLAVE,\n\t.output_opt     = TDA18271_OUTPUT_LT_OFF,\n\t.rf_cal_on_startup = 1\n};\n\nstatic struct s5h1411_config hauppauge_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_ON,\n\t.qam_if        = S5H1411_IF_4000,\n\t.vsb_if        = S5H1411_IF_3250,\n\t.inversion     = S5H1411_INVERSION_ON,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct lgdt3306a_config hauppauge_hvr2255a_config = {\n\t.i2c_addr               = 0xb2 >> 1,\n\t.qam_if_khz             = 4000,\n\t.vsb_if_khz             = 3250,\n\t.deny_i2c_rptr          = 1,  \n\t.spectral_inversion     = 0,  \n\t.mpeg_mode              = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz                = 25,  \n};\n\nstatic struct lgdt3306a_config hauppauge_hvr2255b_config = {\n\t.i2c_addr               = 0x1c >> 1,\n\t.qam_if_khz             = 4000,\n\t.vsb_if_khz             = 3250,\n\t.deny_i2c_rptr          = 1,  \n\t.spectral_inversion     = 0,  \n\t.mpeg_mode              = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz                = 25,  \n};\n\nstatic struct si2157_config hauppauge_hvr2255_tuner_config = {\n\t.inversion = 1,\n\t.if_port = 1,\n};\n\nstatic int si2157_attach(struct saa7164_port *port, struct i2c_adapter *adapter,\n\tstruct dvb_frontend *fe, u8 addr8bit, struct si2157_config *cfg)\n{\n\tstruct i2c_board_info bi;\n\tstruct i2c_client *tuner;\n\n\tcfg->fe = fe;\n\n\tmemset(&bi, 0, sizeof(bi));\n\n\tstrscpy(bi.type, \"si2157\", I2C_NAME_SIZE);\n\tbi.platform_data = cfg;\n\tbi.addr = addr8bit >> 1;\n\n\trequest_module(bi.type);\n\n\ttuner = i2c_new_client_device(adapter, &bi);\n\tif (!i2c_client_has_driver(tuner))\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(tuner->dev.driver->owner)) {\n\t\ti2c_unregister_device(tuner);\n\t\treturn -ENODEV;\n\t}\n\n\tport->i2c_client_tuner = tuner;\n\n\treturn 0;\n}\n\nstatic int saa7164_dvb_stop_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() stop transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_DVB, \"%s()    Stopped\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int saa7164_dvb_acquire_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() acquire transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_DVB, \"%s() Acquired\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int saa7164_dvb_pause_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() pause transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_DVB, \"%s()   Paused\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int saa7164_dvb_stop_streaming(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct list_head *p, *q;\n\tint ret;\n\n\tdprintk(DBGLVL_DVB, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tret = saa7164_dvb_pause_port(port);\n\tret = saa7164_dvb_acquire_port(port);\n\tret = saa7164_dvb_stop_port(port);\n\n\t \n\tmutex_lock(&port->dmaqueue_lock);\n\tlist_for_each_safe(p, q, &port->dmaqueue.list) {\n\t\tbuf = list_entry(p, struct saa7164_buffer, list);\n\t\tbuf->flags = SAA7164_BUFFER_FREE;\n\t}\n\tmutex_unlock(&port->dmaqueue_lock);\n\n\treturn ret;\n}\n\nstatic int saa7164_dvb_start_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret = 0, result;\n\n\tdprintk(DBGLVL_DVB, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tsaa7164_buffer_cfg_port(port);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() acquire transition failed, res = 0x%x\\n\",\n\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() acquire/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\t\tret = -EIO;\n\t\tgoto out;\n\t} else\n\t\tdprintk(DBGLVL_DVB, \"%s()   Acquired\\n\", __func__);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() pause transition failed, res = 0x%x\\n\",\n\t\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() pause/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\n\t\tret = -EIO;\n\t\tgoto out;\n\t} else\n\t\tdprintk(DBGLVL_DVB, \"%s()   Paused\\n\", __func__);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_RUN);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() run transition failed, result = 0x%x\\n\",\n\t\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() run/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\n\t\tret = -EIO;\n\t} else\n\t\tdprintk(DBGLVL_DVB, \"%s()   Running\\n\", __func__);\n\nout:\n\treturn ret;\n}\n\nstatic int saa7164_dvb_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct saa7164_port *port = demux->priv;\n\tstruct saa7164_dvb *dvb = &port->dvb;\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret = 0;\n\n\tdprintk(DBGLVL_DVB, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tif (dvb) {\n\t\tmutex_lock(&dvb->lock);\n\t\tif (dvb->feeding++ == 0) {\n\t\t\t \n\t\t\tret = saa7164_dvb_start_port(port);\n\t\t}\n\t\tmutex_unlock(&dvb->lock);\n\t\tdprintk(DBGLVL_DVB, \"%s(port=%d) now feeding = %d\\n\",\n\t\t\t__func__, port->nr, dvb->feeding);\n\t}\n\n\treturn ret;\n}\n\nstatic int saa7164_dvb_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct saa7164_port *port = demux->priv;\n\tstruct saa7164_dvb *dvb = &port->dvb;\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret = 0;\n\n\tdprintk(DBGLVL_DVB, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tif (dvb) {\n\t\tmutex_lock(&dvb->lock);\n\t\tif (--dvb->feeding == 0) {\n\t\t\t \n\t\t\tret = saa7164_dvb_stop_streaming(port);\n\t\t}\n\t\tmutex_unlock(&dvb->lock);\n\t\tdprintk(DBGLVL_DVB, \"%s(port=%d) now feeding = %d\\n\",\n\t\t\t__func__, port->nr, dvb->feeding);\n\t}\n\n\treturn ret;\n}\n\nstatic int dvb_register(struct saa7164_port *port)\n{\n\tstruct saa7164_dvb *dvb = &port->dvb;\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tint result, i;\n\n\tdprintk(DBGLVL_DVB, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tBUG_ON(port->type != SAA7164_MPEG_DVB);\n\n\t \n\tif (port->hwcfg.BARLocation == 0) {\n\t\tresult = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: dvb_register_adapter failed (errno = %d), NO PCI configuration\\n\",\n\t\t\tDRIVER_NAME, result);\n\t\tgoto fail_adapter;\n\t}\n\n\t \n\tport->hw_streamingparams.bitspersample = 8;\n\tport->hw_streamingparams.samplesperline = 188;\n\tport->hw_streamingparams.numberoflines =\n\t\t(SAA7164_TS_NUMBER_OF_LINES * 188) / 188;\n\n\tport->hw_streamingparams.pitch = 188;\n\tport->hw_streamingparams.linethreshold = 0;\n\tport->hw_streamingparams.pagetablelistvirt = NULL;\n\tport->hw_streamingparams.pagetablelistphys = NULL;\n\tport->hw_streamingparams.numpagetables = 2 +\n\t\t((SAA7164_TS_NUMBER_OF_LINES * 188) / PAGE_SIZE);\n\n\tport->hw_streamingparams.numpagetableentries = port->hwcfg.buffercount;\n\n\t \n\tfor (i = 0; i < port->hwcfg.buffercount; i++) {\n\t\tbuf = saa7164_buffer_alloc(port,\n\t\t\tport->hw_streamingparams.numberoflines *\n\t\t\tport->hw_streamingparams.pitch);\n\n\t\tif (!buf) {\n\t\t\tresult = -ENOMEM;\n\t\t\tprintk(KERN_ERR \"%s: dvb_register_adapter failed (errno = %d), unable to allocate buffers\\n\",\n\t\t\t\tDRIVER_NAME, result);\n\t\t\tgoto fail_adapter;\n\t\t}\n\n\t\tmutex_lock(&port->dmaqueue_lock);\n\t\tlist_add_tail(&buf->list, &port->dmaqueue.list);\n\t\tmutex_unlock(&port->dmaqueue_lock);\n\t}\n\n\t \n\tresult = dvb_register_adapter(&dvb->adapter, DRIVER_NAME, THIS_MODULE,\n\t\t\t&dev->pci->dev, adapter_nr);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: dvb_register_adapter failed (errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_adapter;\n\t}\n\tdvb->adapter.priv = port;\n\n\t \n\tresult = dvb_register_frontend(&dvb->adapter, dvb->frontend);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: dvb_register_frontend failed (errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_frontend;\n\t}\n\n\t \n\tdvb->demux.dmx.capabilities =\n\t\tDMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\tDMX_MEMORY_BASED_FILTERING;\n\tdvb->demux.priv       = port;\n\tdvb->demux.filternum  = 256;\n\tdvb->demux.feednum    = 256;\n\tdvb->demux.start_feed = saa7164_dvb_start_feed;\n\tdvb->demux.stop_feed  = saa7164_dvb_stop_feed;\n\tresult = dvb_dmx_init(&dvb->demux);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: dvb_dmx_init failed (errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb->dmxdev.filternum    = 256;\n\tdvb->dmxdev.demux        = &dvb->demux.dmx;\n\tdvb->dmxdev.capabilities = 0;\n\tresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb->fe_hw.source = DMX_FRONTEND_0;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_fe_hw;\n\t}\n\n\tdvb->fe_mem.source = DMX_MEMORY_FE;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_fe_mem;\n\t}\n\n\tresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"%s: connect_frontend failed (errno = %d)\\n\",\n\t\t       DRIVER_NAME, result);\n\t\tgoto fail_fe_conn;\n\t}\n\n\t \n\tdvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\n\treturn 0;\n\nfail_fe_conn:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\nfail_fe_mem:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\nfail_fe_hw:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\n\tdvb_unregister_frontend(dvb->frontend);\nfail_frontend:\n\tdvb_frontend_detach(dvb->frontend);\n\tdvb_unregister_adapter(&dvb->adapter);\nfail_adapter:\n\treturn result;\n}\n\nint saa7164_dvb_unregister(struct saa7164_port *port)\n{\n\tstruct saa7164_dvb *dvb = &port->dvb;\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *b;\n\tstruct list_head *c, *n;\n\tstruct i2c_client *client;\n\n\tdprintk(DBGLVL_DVB, \"%s()\\n\", __func__);\n\n\tBUG_ON(port->type != SAA7164_MPEG_DVB);\n\n\t \n\tmutex_lock(&port->dmaqueue_lock);\n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\t\tb = list_entry(c, struct saa7164_buffer, list);\n\t\tlist_del(c);\n\t\tsaa7164_buffer_dealloc(b);\n\t}\n\tmutex_unlock(&port->dmaqueue_lock);\n\n\tif (dvb->frontend == NULL)\n\t\treturn 0;\n\n\t \n\tclient = port->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = port->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_net_release(&dvb->net);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tdvb_dmxdev_release(&dvb->dmxdev);\n\tdvb_dmx_release(&dvb->demux);\n\tdvb_unregister_frontend(dvb->frontend);\n\tdvb_frontend_detach(dvb->frontend);\n\tdvb_unregister_adapter(&dvb->adapter);\n\treturn 0;\n}\n\n \nint saa7164_dvb_register(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_dvb *dvb = &port->dvb;\n\tstruct saa7164_i2c *i2c_bus = NULL;\n\tstruct si2168_config si2168_config;\n\tstruct si2157_config si2157_config;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_board_info info;\n\tstruct i2c_client *client_demod;\n\tstruct i2c_client *client_tuner;\n\tint ret;\n\n\tdprintk(DBGLVL_DVB, \"%s()\\n\", __func__);\n\n\t \n\tswitch (dev->board) {\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2200:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2200_2:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2200_3:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2200_4:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2200_5:\n\t\ti2c_bus = &dev->i2c_bus[port->nr + 1];\n\t\tswitch (port->nr) {\n\t\tcase 0:\n\t\t\tport->dvb.frontend = dvb_attach(tda10048_attach,\n\t\t\t\t&hauppauge_hvr2200_1_config,\n\t\t\t\t&i2c_bus->i2c_adap);\n\n\t\t\tif (port->dvb.frontend != NULL) {\n\t\t\t\t \n\t\t\t\tdvb_attach(tda18271_attach, port->dvb.frontend,\n\t\t\t\t\t0xc0 >> 1, &i2c_bus->i2c_adap,\n\t\t\t\t\t&hauppauge_hvr22x0_tuner_config);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tport->dvb.frontend = dvb_attach(tda10048_attach,\n\t\t\t\t&hauppauge_hvr2200_2_config,\n\t\t\t\t&i2c_bus->i2c_adap);\n\n\t\t\tif (port->dvb.frontend != NULL) {\n\t\t\t\t \n\t\t\t\tdvb_attach(tda18271_attach, port->dvb.frontend,\n\t\t\t\t\t0xc0 >> 1, &i2c_bus->i2c_adap,\n\t\t\t\t\t&hauppauge_hvr22x0s_tuner_config);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2250:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2250_2:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2250_3:\n\t\ti2c_bus = &dev->i2c_bus[port->nr + 1];\n\n\t\tport->dvb.frontend = dvb_attach(s5h1411_attach,\n\t\t\t&hauppauge_s5h1411_config,\n\t\t\t&i2c_bus->i2c_adap);\n\n\t\tif (port->dvb.frontend != NULL) {\n\t\t\tif (port->nr == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tdvb_attach(tda18271_attach, port->dvb.frontend,\n\t\t\t\t\t0xc0 >> 1, &i2c_bus->i2c_adap,\n\t\t\t\t\t&hauppauge_hvr22x0_tuner_config);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdvb_attach(tda18271_attach, port->dvb.frontend,\n\t\t\t\t\t0xc0 >> 1, &i2c_bus->i2c_adap,\n\t\t\t\t\t&hauppauge_hvr22x0s_tuner_config);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2255proto:\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2255:\n\t\ti2c_bus = &dev->i2c_bus[2];\n\n\t\tif (port->nr == 0) {\n\t\t\tport->dvb.frontend = dvb_attach(lgdt3306a_attach,\n\t\t\t\t&hauppauge_hvr2255a_config, &i2c_bus->i2c_adap);\n\t\t} else {\n\t\t\tport->dvb.frontend = dvb_attach(lgdt3306a_attach,\n\t\t\t\t&hauppauge_hvr2255b_config, &i2c_bus->i2c_adap);\n\t\t}\n\n\t\tif (port->dvb.frontend != NULL) {\n\n\t\t\tif (port->nr == 0) {\n\t\t\t\tsi2157_attach(port, &dev->i2c_bus[0].i2c_adap,\n\t\t\t\t\t      port->dvb.frontend, 0xc0,\n\t\t\t\t\t      &hauppauge_hvr2255_tuner_config);\n\t\t\t} else {\n\t\t\t\tsi2157_attach(port, &dev->i2c_bus[1].i2c_adap,\n\t\t\t\t\t      port->dvb.frontend, 0xc0,\n\t\t\t\t\t      &hauppauge_hvr2255_tuner_config);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SAA7164_BOARD_HAUPPAUGE_HVR2205:\n\n\t\tif (port->nr == 0) {\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &port->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0xc8 >> 1;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_demod = i2c_new_client_device(&dev->i2c_bus[2].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tsi2157_config.fe = port->dvb.frontend;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0xc0 >> 1;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[0].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\t\t} else {\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &port->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0xcc >> 1;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_demod = i2c_new_client_device(&dev->i2c_bus[2].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = port->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0xc0 >> 1;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: The frontend isn't supported\\n\",\n\t\t       dev->name);\n\t\tbreak;\n\t}\n\tif (NULL == dvb->frontend) {\n\t\tprintk(KERN_ERR \"%s() Frontend initialization failed\\n\",\n\t\t       __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tret = dvb_register(port);\n\tif (ret < 0) {\n\t\tif (dvb->frontend->ops.release)\n\t\t\tdvb->frontend->ops.release(dvb->frontend);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nfrontend_detach:\n\tprintk(KERN_ERR \"%s() Frontend/I2C initialization failed\\n\", __func__);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}