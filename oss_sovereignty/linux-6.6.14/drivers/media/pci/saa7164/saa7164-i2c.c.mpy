{
  "module_name": "saa7164-i2c.c",
  "hash_id": "3d50d93d928037fd52d5a0067a79fe4e01251a19b97f1856e8398877780d1dce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include \"saa7164.h\"\n\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\n{\n\tstruct saa7164_i2c *bus = i2c_adap->algo_data;\n\tstruct saa7164_dev *dev = bus->dev;\n\tint i, retval = 0;\n\n\tdprintk(DBGLVL_I2C, \"%s(num = %d)\\n\", __func__, num);\n\n\tfor (i = 0 ; i < num; i++) {\n\t\tdprintk(DBGLVL_I2C, \"%s(num = %d) addr = 0x%02x  len = 0x%x\\n\",\n\t\t\t__func__, num, msgs[i].addr, msgs[i].len);\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tretval = saa7164_api_i2c_read(bus,\n\t\t\t\tmsgs[i].addr,\n\t\t\t\t0  ,\n\t\t\t\tNULL  , msgs[i].len, msgs[i].buf);\n\t\t} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr) {\n\t\t\t \n\n\t\t\tretval = saa7164_api_i2c_read(bus, msgs[i].addr,\n\t\t\t\tmsgs[i].len, msgs[i].buf,\n\t\t\t\tmsgs[i+1].len, msgs[i+1].buf\n\t\t\t\t);\n\n\t\t\ti++;\n\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t \n\t\t\tretval = saa7164_api_i2c_write(bus, msgs[i].addr,\n\t\t\t\tmsgs[i].len, msgs[i].buf);\n\t\t}\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t}\n\treturn num;\n\nerr:\n\treturn retval;\n}\n\nstatic u32 saa7164_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm saa7164_i2c_algo_template = {\n\t.master_xfer\t= i2c_xfer,\n\t.functionality\t= saa7164_functionality,\n};\n\n \n\nstatic const struct i2c_adapter saa7164_i2c_adap_template = {\n\t.name              = \"saa7164\",\n\t.owner             = THIS_MODULE,\n\t.algo              = &saa7164_i2c_algo_template,\n};\n\nstatic const struct i2c_client saa7164_i2c_client_template = {\n\t.name\t= \"saa7164 internal\",\n};\n\nint saa7164_i2c_register(struct saa7164_i2c *bus)\n{\n\tstruct saa7164_dev *dev = bus->dev;\n\n\tdprintk(DBGLVL_I2C, \"%s(bus = %d)\\n\", __func__, bus->nr);\n\n\tbus->i2c_adap = saa7164_i2c_adap_template;\n\tbus->i2c_client = saa7164_i2c_client_template;\n\n\tbus->i2c_adap.dev.parent = &dev->pci->dev;\n\n\tstrscpy(bus->i2c_adap.name, bus->dev->name,\n\t\tsizeof(bus->i2c_adap.name));\n\n\tbus->i2c_adap.algo_data = bus;\n\ti2c_set_adapdata(&bus->i2c_adap, bus);\n\ti2c_add_adapter(&bus->i2c_adap);\n\n\tbus->i2c_client.adapter = &bus->i2c_adap;\n\n\tif (0 != bus->i2c_rc)\n\t\tprintk(KERN_ERR \"%s: i2c bus %d register FAILED\\n\",\n\t\t\tdev->name, bus->nr);\n\n\treturn bus->i2c_rc;\n}\n\nint saa7164_i2c_unregister(struct saa7164_i2c *bus)\n{\n\ti2c_del_adapter(&bus->i2c_adap);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}