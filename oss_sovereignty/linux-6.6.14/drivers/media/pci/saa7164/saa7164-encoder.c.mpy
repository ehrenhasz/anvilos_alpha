{
  "module_name": "saa7164-encoder.c",
  "hash_id": "62108d28220c7c2ba652f8876cc2f1a93b7036cf6091d6a56b6b4309ba997ee7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-encoder.c",
  "human_readable_source": "\n \n\n#include \"saa7164.h\"\n\n#define ENCODER_MAX_BITRATE 6500000\n#define ENCODER_MIN_BITRATE 1000000\n#define ENCODER_DEF_BITRATE 5000000\n\n \n#define SAA7164_SIZEIMAGE (0x10000)\n\nstatic struct saa7164_tvnorm saa7164_tvnorms[] = {\n\t{\n\t\t.name      = \"NTSC-M\",\n\t\t.id        = V4L2_STD_NTSC_M,\n\t}, {\n\t\t.name      = \"NTSC-JP\",\n\t\t.id        = V4L2_STD_NTSC_M_JP,\n\t}\n};\n\n \nstatic void saa7164_encoder_configure(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\tport->encoder_params.width = port->width;\n\tport->encoder_params.height = port->height;\n\tport->encoder_params.is_50hz =\n\t\t(port->encodernorm.id & V4L2_STD_625_50) != 0;\n\n\t \n\tsaa7164_api_initialize_dif(port);\n\n\t \n\tsaa7164_api_configure_dif(port, port->encodernorm.id);\n\n\t \n\tsaa7164_api_set_audio_std(port);\n}\n\nstatic int saa7164_encoder_buffers_dealloc(struct saa7164_port *port)\n{\n\tstruct list_head *c, *n, *p, *q, *l, *v;\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct saa7164_user_buffer *ubuf;\n\n\t \n\tmutex_lock(&port->dmaqueue_lock);\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) dmaqueue\\n\", __func__, port->nr);\n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\t\tbuf = list_entry(c, struct saa7164_buffer, list);\n\t\tlist_del(c);\n\t\tsaa7164_buffer_dealloc(buf);\n\t}\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) used\\n\", __func__, port->nr);\n\tlist_for_each_safe(p, q, &port->list_buf_used.list) {\n\t\tubuf = list_entry(p, struct saa7164_user_buffer, list);\n\t\tlist_del(p);\n\t\tsaa7164_buffer_dealloc_user(ubuf);\n\t}\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) free\\n\", __func__, port->nr);\n\tlist_for_each_safe(l, v, &port->list_buf_free.list) {\n\t\tubuf = list_entry(l, struct saa7164_user_buffer, list);\n\t\tlist_del(l);\n\t\tsaa7164_buffer_dealloc_user(ubuf);\n\t}\n\n\tmutex_unlock(&port->dmaqueue_lock);\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) done\\n\", __func__, port->nr);\n\n\treturn 0;\n}\n\n \nstatic int saa7164_encoder_buffers_alloc(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct saa7164_user_buffer *ubuf;\n\tstruct tmHWStreamParameters *params = &port->hw_streamingparams;\n\tint result = -ENODEV, i;\n\tint len = 0;\n\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\tif (port->encoder_params.stream_type ==\n\t\tV4L2_MPEG_STREAM_TYPE_MPEG2_PS) {\n\t\tdprintk(DBGLVL_ENC,\n\t\t\t\"%s() type=V4L2_MPEG_STREAM_TYPE_MPEG2_PS\\n\",\n\t\t\t__func__);\n\t\tparams->samplesperline = 128;\n\t\tparams->numberoflines = 256;\n\t\tparams->pitch = 128;\n\t\tparams->numpagetables = 2 +\n\t\t\t((SAA7164_PS_NUMBER_OF_LINES * 128) / PAGE_SIZE);\n\t} else\n\tif (port->encoder_params.stream_type ==\n\t\tV4L2_MPEG_STREAM_TYPE_MPEG2_TS) {\n\t\tdprintk(DBGLVL_ENC,\n\t\t\t\"%s() type=V4L2_MPEG_STREAM_TYPE_MPEG2_TS\\n\",\n\t\t\t__func__);\n\t\tparams->samplesperline = 188;\n\t\tparams->numberoflines = 312;\n\t\tparams->pitch = 188;\n\t\tparams->numpagetables = 2 +\n\t\t\t((SAA7164_TS_NUMBER_OF_LINES * 188) / PAGE_SIZE);\n\t} else\n\t\tBUG();\n\n\t \n\tparams->bitspersample = 8;\n\tparams->linethreshold = 0;\n\tparams->pagetablelistvirt = NULL;\n\tparams->pagetablelistphys = NULL;\n\tparams->numpagetableentries = port->hwcfg.buffercount;\n\n\t \n\tfor (i = 0; i < port->hwcfg.buffercount; i++) {\n\t\tbuf = saa7164_buffer_alloc(port,\n\t\t\tparams->numberoflines *\n\t\t\tparams->pitch);\n\n\t\tif (!buf) {\n\t\t\tprintk(KERN_ERR \"%s() failed (errno = %d), unable to allocate buffer\\n\",\n\t\t\t\t__func__, result);\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto failed;\n\t\t} else {\n\n\t\t\tmutex_lock(&port->dmaqueue_lock);\n\t\t\tlist_add_tail(&buf->list, &port->dmaqueue.list);\n\t\t\tmutex_unlock(&port->dmaqueue_lock);\n\n\t\t}\n\t}\n\n\t \n\tlen = params->numberoflines * params->pitch;\n\n\tif (encoder_buffers < 16)\n\t\tencoder_buffers = 16;\n\tif (encoder_buffers > 512)\n\t\tencoder_buffers = 512;\n\n\tfor (i = 0; i < encoder_buffers; i++) {\n\n\t\tubuf = saa7164_buffer_alloc_user(dev, len);\n\t\tif (ubuf) {\n\t\t\tmutex_lock(&port->dmaqueue_lock);\n\t\t\tlist_add_tail(&ubuf->list, &port->list_buf_free.list);\n\t\t\tmutex_unlock(&port->dmaqueue_lock);\n\t\t}\n\n\t}\n\n\tresult = 0;\n\nfailed:\n\treturn result;\n}\n\nstatic int saa7164_encoder_initialize(struct saa7164_port *port)\n{\n\tsaa7164_encoder_configure(port);\n\treturn 0;\n}\n\n \nint saa7164_s_std(struct saa7164_port *port, v4l2_std_id id)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tunsigned int i;\n\n\tdprintk(DBGLVL_ENC, \"%s(id=0x%x)\\n\", __func__, (u32)id);\n\n\tfor (i = 0; i < ARRAY_SIZE(saa7164_tvnorms); i++) {\n\t\tif (id & saa7164_tvnorms[i].id)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(saa7164_tvnorms))\n\t\treturn -EINVAL;\n\n\tport->encodernorm = saa7164_tvnorms[i];\n\tport->std = id;\n\n\t \n\tsaa7164_api_set_audio_std(port);\n\n\tdprintk(DBGLVL_ENC, \"%s(id=0x%x) OK\\n\", __func__, (u32)id);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_s_std(fh->port, id);\n}\n\nint saa7164_g_std(struct saa7164_port *port, v4l2_std_id *id)\n{\n\t*id = port->std;\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_g_std(fh->port, id);\n}\n\nint saa7164_enum_input(struct file *file, void *priv, struct v4l2_input *i)\n{\n\tstatic const char * const inputs[] = {\n\t\t\"tuner\", \"composite\", \"svideo\", \"aux\",\n\t\t\"composite 2\", \"svideo 2\", \"aux 2\"\n\t};\n\tint n;\n\n\tif (i->index >= 7)\n\t\treturn -EINVAL;\n\n\tstrscpy(i->name, inputs[i->index], sizeof(i->name));\n\n\tif (i->index == 0)\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\telse\n\t\ti->type  = V4L2_INPUT_TYPE_CAMERA;\n\n\tfor (n = 0; n < ARRAY_SIZE(saa7164_tvnorms); n++)\n\t\ti->std |= saa7164_tvnorms[n].id;\n\n\treturn 0;\n}\n\nint saa7164_g_input(struct saa7164_port *port, unsigned int *i)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\tif (saa7164_api_get_videomux(port) != SAA_OK)\n\t\treturn -EIO;\n\n\t*i = (port->mux_input - 1);\n\n\tdprintk(DBGLVL_ENC, \"%s() input=%d\\n\", __func__, *i);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_g_input(fh->port, i);\n}\n\nint saa7164_s_input(struct saa7164_port *port, unsigned int i)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\tdprintk(DBGLVL_ENC, \"%s() input=%d\\n\", __func__, i);\n\n\tif (i >= 7)\n\t\treturn -EINVAL;\n\n\tport->mux_input = i + 1;\n\n\tif (saa7164_api_set_videomux(port) != SAA_OK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_s_input(fh->port, i);\n}\n\nint saa7164_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\tstruct saa7164_dev *dev = port->dev;\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"tuner\", sizeof(t->name));\n\tt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO;\n\tt->rangelow = SAA7164_TV_MIN_FREQ;\n\tt->rangehigh = SAA7164_TV_MAX_FREQ;\n\n\tdprintk(DBGLVL_ENC, \"VIDIOC_G_TUNER: tuner type %d\\n\", t->type);\n\n\treturn 0;\n}\n\nint saa7164_s_tuner(struct file *file, void *priv,\n\t\t\t   const struct v4l2_tuner *t)\n{\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\t \n\treturn 0;\n}\n\nint saa7164_g_frequency(struct saa7164_port *port, struct v4l2_frequency *f)\n{\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tf->frequency = port->freq;\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\tstruct v4l2_frequency *f)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_g_frequency(fh->port, f);\n}\n\nint saa7164_s_frequency(struct saa7164_port *port,\n\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_port *tsport;\n\tstruct dvb_frontend *fe;\n\n\t \n\tstruct analog_parameters params = {\n\t\t.mode      = V4L2_TUNER_ANALOG_TV,\n\t\t.audmode   = V4L2_TUNER_MODE_STEREO,\n\t\t.std       = port->encodernorm.id,\n\t\t.frequency = f->frequency\n\t};\n\n\t \n\tdprintk(DBGLVL_ENC, \"%s() frequency=%d tuner=%d\\n\", __func__,\n\t\tf->frequency, f->tuner);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\n\tport->freq = clamp(f->frequency,\n\t\t\t   SAA7164_TV_MIN_FREQ, SAA7164_TV_MAX_FREQ);\n\n\t \n\tif (port->nr == SAA7164_PORT_ENC1)\n\t\ttsport = &dev->ports[SAA7164_PORT_TS1];\n\telse if (port->nr == SAA7164_PORT_ENC2)\n\t\ttsport = &dev->ports[SAA7164_PORT_TS2];\n\telse\n\t\treturn -EINVAL;  \n\n\tfe = tsport->dvb.frontend;\n\n\tif (fe && fe->ops.tuner_ops.set_analog_params)\n\t\tfe->ops.tuner_ops.set_analog_params(fe, &params);\n\telse\n\t\tprintk(KERN_ERR \"%s() No analog tuner, aborting\\n\", __func__);\n\n\tsaa7164_encoder_initialize(port);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\n\treturn saa7164_s_frequency(fh->port, f);\n}\n\nstatic int saa7164_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa7164_port *port =\n\t\tcontainer_of(ctrl->handler, struct saa7164_port, ctrl_handler);\n\tstruct saa7164_encoder_params *params = &port->encoder_params;\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tport->ctl_brightness = ctrl->val;\n\t\tsaa7164_api_set_usercontrol(port, PU_BRIGHTNESS_CONTROL);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tport->ctl_contrast = ctrl->val;\n\t\tsaa7164_api_set_usercontrol(port, PU_CONTRAST_CONTROL);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tport->ctl_saturation = ctrl->val;\n\t\tsaa7164_api_set_usercontrol(port, PU_SATURATION_CONTROL);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tport->ctl_hue = ctrl->val;\n\t\tsaa7164_api_set_usercontrol(port, PU_HUE_CONTROL);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tport->ctl_sharpness = ctrl->val;\n\t\tsaa7164_api_set_usercontrol(port, PU_SHARPNESS_CONTROL);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tport->ctl_volume = ctrl->val;\n\t\tsaa7164_api_set_audio_volume(port, port->ctl_volume);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tparams->bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_STREAM_TYPE:\n\t\tparams->stream_type = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_AUDIO_MUTE:\n\t\tparams->ctl_mute = ctrl->val;\n\t\tret = saa7164_api_audio_mute(port, params->ctl_mute);\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"%s() error, ret = 0x%x\\n\", __func__,\n\t\t\t\tret);\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_ASPECT:\n\t\tparams->ctl_aspect = ctrl->val;\n\t\tret = saa7164_api_set_aspect_ratio(port);\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"%s() error, ret = 0x%x\\n\", __func__,\n\t\t\t\tret);\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tparams->bitrate_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_B_FRAMES:\n\t\tparams->refdist = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\n\t\tparams->bitrate_peak = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tparams->gop_size = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\tstruct v4l2_capability *cap)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\tstruct saa7164_dev *dev = port->dev;\n\n\tstrscpy(cap->driver, dev->name, sizeof(cap->driver));\n\tstrscpy(cap->card, saa7164_boards[dev->board].name,\n\t\tsizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_TUNER | V4L2_CAP_VBI_CAPTURE |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\n\treturn 0;\n}\n\nstatic int vidioc_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    = SAA7164_SIZEIMAGE;\n\tf->fmt.pix.field        = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.width        = port->width;\n\tf->fmt.pix.height       = port->height;\n\treturn 0;\n}\n\nstatic int saa7164_encoder_stop_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() stop transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_ENC, \"%s()    Stopped\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int saa7164_encoder_acquire_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() acquire transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_ENC, \"%s() Acquired\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int saa7164_encoder_pause_port(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret;\n\n\tret = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\n\tif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() pause transition failed, ret = 0x%x\\n\",\n\t\t\t__func__, ret);\n\t\tret = -EIO;\n\t} else {\n\t\tdprintk(DBGLVL_ENC, \"%s()   Paused\\n\", __func__);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int saa7164_encoder_stop_streaming(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct saa7164_buffer *buf;\n\tstruct saa7164_user_buffer *ubuf;\n\tstruct list_head *c, *n;\n\tint ret;\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tret = saa7164_encoder_pause_port(port);\n\tret = saa7164_encoder_acquire_port(port);\n\tret = saa7164_encoder_stop_port(port);\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) Hardware stopped\\n\", __func__,\n\t\tport->nr);\n\n\t \n\tmutex_lock(&port->dmaqueue_lock);\n\n\t \n\tlist_for_each_safe(c, n, &port->dmaqueue.list) {\n\t\tbuf = list_entry(c, struct saa7164_buffer, list);\n\t\tbuf->flags = SAA7164_BUFFER_FREE;\n\t\tbuf->pos = 0;\n\t}\n\n\tlist_for_each_safe(c, n, &port->list_buf_used.list) {\n\t\tubuf = list_entry(c, struct saa7164_user_buffer, list);\n\t\tubuf->pos = 0;\n\t\tlist_move_tail(&ubuf->list, &port->list_buf_free.list);\n\t}\n\n\tmutex_unlock(&port->dmaqueue_lock);\n\n\t \n\tsaa7164_encoder_buffers_dealloc(port);\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) Released\\n\", __func__, port->nr);\n\n\treturn ret;\n}\n\nstatic int saa7164_encoder_start_streaming(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tint result, ret = 0;\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tport->done_first_interrupt = 0;\n\n\t \n\tsaa7164_encoder_buffers_alloc(port);\n\n\t \n\tsaa7164_api_set_encoder(port);\n\tsaa7164_api_get_encoder(port);\n\n\t \n\tsaa7164_buffer_cfg_port(port);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() acquire transition failed, res = 0x%x\\n\",\n\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() acquire/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\t\tret = -EIO;\n\t\tgoto out;\n\t} else\n\t\tdprintk(DBGLVL_ENC, \"%s()   Acquired\\n\", __func__);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() pause transition failed, res = 0x%x\\n\",\n\t\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() pause/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\n\t\tret = -EIO;\n\t\tgoto out;\n\t} else\n\t\tdprintk(DBGLVL_ENC, \"%s()   Paused\\n\", __func__);\n\n\t \n\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_RUN);\n\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\tprintk(KERN_ERR \"%s() run transition failed, result = 0x%x\\n\",\n\t\t\t\t__func__, result);\n\n\t\t \n\t\tresult = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\n\t\tif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\n\t\t\tprintk(KERN_ERR \"%s() run/forced stop transition failed, res = 0x%x\\n\",\n\t\t\t       __func__, result);\n\t\t}\n\n\t\tret = -EIO;\n\t} else\n\t\tdprintk(DBGLVL_ENC, \"%s()   Running\\n\", __func__);\n\nout:\n\treturn ret;\n}\n\nstatic int fops_open(struct file *file)\n{\n\tstruct saa7164_dev *dev;\n\tstruct saa7164_port *port;\n\tstruct saa7164_encoder_fh *fh;\n\n\tport = (struct saa7164_port *)video_get_drvdata(video_devdata(file));\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tdev = port->dev;\n\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\t \n\tfh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\tif (NULL == fh)\n\t\treturn -ENOMEM;\n\n\tfh->port = port;\n\tv4l2_fh_init(&fh->fh, video_devdata(file));\n\tv4l2_fh_add(&fh->fh);\n\tfile->private_data = fh;\n\n\treturn 0;\n}\n\nstatic int fops_release(struct file *file)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\tstruct saa7164_dev *dev = port->dev;\n\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\t \n\tif (atomic_cmpxchg(&fh->v4l_reading, 1, 0) == 1) {\n\t\tif (atomic_dec_return(&port->v4l_reader_count) == 0) {\n\t\t\t \n\t\t\tsaa7164_encoder_stop_streaming(port);\n\t\t}\n\t}\n\n\tv4l2_fh_del(&fh->fh);\n\tv4l2_fh_exit(&fh->fh);\n\tkfree(fh);\n\n\treturn 0;\n}\n\nstatic struct\nsaa7164_user_buffer *saa7164_enc_next_buf(struct saa7164_port *port)\n{\n\tstruct saa7164_user_buffer *ubuf = NULL;\n\tstruct saa7164_dev *dev = port->dev;\n\tu32 crc;\n\n\tmutex_lock(&port->dmaqueue_lock);\n\tif (!list_empty(&port->list_buf_used.list)) {\n\t\tubuf = list_first_entry(&port->list_buf_used.list,\n\t\t\tstruct saa7164_user_buffer, list);\n\n\t\tif (crc_checking) {\n\t\t\tcrc = crc32(0, ubuf->data, ubuf->actual_size);\n\t\t\tif (crc != ubuf->crc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\"%s() ubuf %p crc became invalid, was 0x%x became 0x%x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tubuf, ubuf->crc, crc);\n\t\t\t}\n\t\t}\n\n\t}\n\tmutex_unlock(&port->dmaqueue_lock);\n\n\tdprintk(DBGLVL_ENC, \"%s() returns %p\\n\", __func__, ubuf);\n\n\treturn ubuf;\n}\n\nstatic ssize_t fops_read(struct file *file, char __user *buffer,\n\tsize_t count, loff_t *pos)\n{\n\tstruct saa7164_encoder_fh *fh = file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\tstruct saa7164_user_buffer *ubuf = NULL;\n\tstruct saa7164_dev *dev = port->dev;\n\tint ret = 0;\n\tint rem, cnt;\n\tu8 *p;\n\n\tport->last_read_msecs_diff = port->last_read_msecs;\n\tport->last_read_msecs = jiffies_to_msecs(jiffies);\n\tport->last_read_msecs_diff = port->last_read_msecs -\n\t\tport->last_read_msecs_diff;\n\n\tsaa7164_histogram_update(&port->read_interval,\n\t\tport->last_read_msecs_diff);\n\n\tif (*pos) {\n\t\tprintk(KERN_ERR \"%s() ESPIPE\\n\", __func__);\n\t\treturn -ESPIPE;\n\t}\n\n\tif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\n\t\tif (atomic_inc_return(&port->v4l_reader_count) == 1) {\n\n\t\t\tif (saa7164_encoder_initialize(port) < 0) {\n\t\t\t\tprintk(KERN_ERR \"%s() EINVAL\\n\", __func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsaa7164_encoder_start_streaming(port);\n\t\t\tmsleep(200);\n\t\t}\n\t}\n\n\t \n\tif ((file->f_flags & O_NONBLOCK) == 0) {\n\t\tif (wait_event_interruptible(port->wait_read,\n\t\t\tsaa7164_enc_next_buf(port))) {\n\t\t\t\tprintk(KERN_ERR \"%s() ERESTARTSYS\\n\", __func__);\n\t\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\n\t \n\tubuf = saa7164_enc_next_buf(port);\n\n\twhile ((count > 0) && ubuf) {\n\n\t\t \n\t\trem = ubuf->actual_size - ubuf->pos;\n\t\tcnt = rem > count ? count : rem;\n\n\t\tp = ubuf->data + ubuf->pos;\n\n\t\tdprintk(DBGLVL_ENC,\n\t\t\t\"%s() count=%d cnt=%d rem=%d buf=%p buf->pos=%d\\n\",\n\t\t\t__func__, (int)count, cnt, rem, ubuf, ubuf->pos);\n\n\t\tif (copy_to_user(buffer, p, cnt)) {\n\t\t\tprintk(KERN_ERR \"%s() copy_to_user failed\\n\", __func__);\n\t\t\tif (!ret) {\n\t\t\t\tprintk(KERN_ERR \"%s() EFAULT\\n\", __func__);\n\t\t\t\tret = -EFAULT;\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\n\t\tubuf->pos += cnt;\n\t\tcount -= cnt;\n\t\tbuffer += cnt;\n\t\tret += cnt;\n\n\t\tif (ubuf->pos > ubuf->actual_size)\n\t\t\tprintk(KERN_ERR \"read() pos > actual, huh?\\n\");\n\n\t\tif (ubuf->pos == ubuf->actual_size) {\n\n\t\t\t \n\n\t\t\t \n\t\t\tubuf->pos = 0;\n\n\t\t\tmutex_lock(&port->dmaqueue_lock);\n\t\t\tlist_move_tail(&ubuf->list, &port->list_buf_free.list);\n\t\t\tmutex_unlock(&port->dmaqueue_lock);\n\n\t\t\t \n\t\t\tif ((file->f_flags & O_NONBLOCK) == 0) {\n\t\t\t\tif (wait_event_interruptible(port->wait_read,\n\t\t\t\t\tsaa7164_enc_next_buf(port))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tubuf = saa7164_enc_next_buf(port);\n\t\t}\n\t}\nerr:\n\tif (!ret && !ubuf)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}\n\nstatic __poll_t fops_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct saa7164_encoder_fh *fh =\n\t\t(struct saa7164_encoder_fh *)file->private_data;\n\tstruct saa7164_port *port = fh->port;\n\t__poll_t mask = v4l2_ctrl_poll(file, wait);\n\n\tport->last_poll_msecs_diff = port->last_poll_msecs;\n\tport->last_poll_msecs = jiffies_to_msecs(jiffies);\n\tport->last_poll_msecs_diff = port->last_poll_msecs -\n\t\tport->last_poll_msecs_diff;\n\n\tsaa7164_histogram_update(&port->poll_interval,\n\t\tport->last_poll_msecs_diff);\n\n\tif (!(req_events & (EPOLLIN | EPOLLRDNORM)))\n\t\treturn mask;\n\n\tif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\n\t\tif (atomic_inc_return(&port->v4l_reader_count) == 1) {\n\t\t\tif (saa7164_encoder_initialize(port) < 0)\n\t\t\t\treturn mask | EPOLLERR;\n\t\t\tsaa7164_encoder_start_streaming(port);\n\t\t\tmsleep(200);\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&port->list_buf_used.list))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct v4l2_ctrl_ops saa7164_ctrl_ops = {\n\t.s_ctrl = saa7164_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations mpeg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fops_open,\n\t.release\t= fops_release,\n\t.read\t\t= fops_read,\n\t.poll\t\t= fops_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops mpeg_ioctl_ops = {\n\t.vidioc_s_std\t\t = vidioc_s_std,\n\t.vidioc_g_std\t\t = vidioc_g_std,\n\t.vidioc_enum_input\t = saa7164_enum_input,\n\t.vidioc_g_input\t\t = vidioc_g_input,\n\t.vidioc_s_input\t\t = vidioc_s_input,\n\t.vidioc_g_tuner\t\t = saa7164_g_tuner,\n\t.vidioc_s_tuner\t\t = saa7164_s_tuner,\n\t.vidioc_g_frequency\t = vidioc_g_frequency,\n\t.vidioc_s_frequency\t = vidioc_s_frequency,\n\t.vidioc_querycap\t = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t = vidioc_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t = vidioc_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t = vidioc_fmt_vid_cap,\n\t.vidioc_log_status\t = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event  = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device saa7164_mpeg_template = {\n\t.name          = \"saa7164\",\n\t.fops          = &mpeg_fops,\n\t.ioctl_ops     = &mpeg_ioctl_ops,\n\t.minor         = -1,\n\t.tvnorms       = SAA7164_NORMS,\n\t.device_caps   = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t V4L2_CAP_TUNER,\n};\n\nstatic struct video_device *saa7164_encoder_alloc(\n\tstruct saa7164_port *port,\n\tstruct pci_dev *pci,\n\tstruct video_device *template,\n\tchar *type)\n{\n\tstruct video_device *vfd;\n\tstruct saa7164_dev *dev = port->dev;\n\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\tvfd = video_device_alloc();\n\tif (NULL == vfd)\n\t\treturn NULL;\n\n\t*vfd = *template;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", dev->name,\n\t\ttype, saa7164_boards[dev->board].name);\n\n\tvfd->v4l2_dev  = &dev->v4l2_dev;\n\tvfd->release = video_device_release;\n\treturn vfd;\n}\n\nint saa7164_encoder_register(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\tstruct v4l2_ctrl_handler *hdl = &port->ctrl_handler;\n\tint result = -ENODEV;\n\n\tdprintk(DBGLVL_ENC, \"%s()\\n\", __func__);\n\n\tBUG_ON(port->type != SAA7164_MPEG_ENCODER);\n\n\t \n\tif (port->hwcfg.BARLocation == 0) {\n\t\tprintk(KERN_ERR \"%s() failed (errno = %d), NO PCI configuration\\n\",\n\t\t\t__func__, result);\n\t\tresult = -ENOMEM;\n\t\tgoto fail_pci;\n\t}\n\n\t \n\t \n\tport->encodernorm = saa7164_tvnorms[0];\n\tport->width = 720;\n\tport->mux_input = 1;  \n\tport->video_format = EU_VIDEO_FORMAT_MPEG_2;\n\tport->audio_format = 0;\n\tport->video_resolution = 0;\n\tport->freq = SAA7164_TV_MIN_FREQ;\n\n\tv4l2_ctrl_handler_init(hdl, 14);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 66);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 62);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_SHARPNESS, 0x0, 0x0f, 1, 8);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_AUDIO_MUTE, 0x0, 0x01, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_AUDIO_VOLUME, -83, 24, 1, 20);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t  ENCODER_MIN_BITRATE, ENCODER_MAX_BITRATE,\n\t\t\t  100000, ENCODER_DEF_BITRATE);\n\tv4l2_ctrl_new_std_menu(hdl, &saa7164_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_STREAM_TYPE,\n\t\t\t       V4L2_MPEG_STREAM_TYPE_MPEG2_TS, 0,\n\t\t\t       V4L2_MPEG_STREAM_TYPE_MPEG2_PS);\n\tv4l2_ctrl_new_std_menu(hdl, &saa7164_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_ASPECT,\n\t\t\t       V4L2_MPEG_VIDEO_ASPECT_221x100, 0,\n\t\t\t       V4L2_MPEG_VIDEO_ASPECT_4x3);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 255, 1, 15);\n\tv4l2_ctrl_new_std_menu(hdl, &saa7164_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_B_FRAMES, 1, 3, 1, 1);\n\tv4l2_ctrl_new_std(hdl, &saa7164_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t\t\t  ENCODER_MIN_BITRATE, ENCODER_MAX_BITRATE,\n\t\t\t  100000, ENCODER_DEF_BITRATE);\n\tif (hdl->error) {\n\t\tresult = hdl->error;\n\t\tgoto fail_hdl;\n\t}\n\n\tport->std = V4L2_STD_NTSC_M;\n\n\tif (port->encodernorm.id & V4L2_STD_525_60)\n\t\tport->height = 480;\n\telse\n\t\tport->height = 576;\n\n\t \n\tport->v4l_device = saa7164_encoder_alloc(port,\n\t\tdev->pci, &saa7164_mpeg_template, \"mpeg\");\n\n\tif (!port->v4l_device) {\n\t\tprintk(KERN_INFO \"%s: can't allocate mpeg device\\n\",\n\t\t\tdev->name);\n\t\tresult = -ENOMEM;\n\t\tgoto fail_hdl;\n\t}\n\n\tport->v4l_device->ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\tvideo_set_drvdata(port->v4l_device, port);\n\tresult = video_register_device(port->v4l_device,\n\t\tVFL_TYPE_VIDEO, -1);\n\tif (result < 0) {\n\t\tprintk(KERN_INFO \"%s: can't register mpeg device\\n\",\n\t\t\tdev->name);\n\t\tgoto fail_reg;\n\t}\n\n\tprintk(KERN_INFO \"%s: registered device video%d [mpeg]\\n\",\n\t\tdev->name, port->v4l_device->num);\n\n\t \n\tsaa7164_api_set_videomux(port);\n\tsaa7164_api_set_usercontrol(port, PU_BRIGHTNESS_CONTROL);\n\tsaa7164_api_set_usercontrol(port, PU_CONTRAST_CONTROL);\n\tsaa7164_api_set_usercontrol(port, PU_HUE_CONTROL);\n\tsaa7164_api_set_usercontrol(port, PU_SATURATION_CONTROL);\n\tsaa7164_api_set_usercontrol(port, PU_SHARPNESS_CONTROL);\n\tsaa7164_api_audio_mute(port, 0);\n\tsaa7164_api_set_audio_volume(port, 20);\n\tsaa7164_api_set_aspect_ratio(port);\n\n\t \n\tsaa7164_api_set_audio_detection(port, 0);\n\n\tsaa7164_api_set_encoder(port);\n\tsaa7164_api_get_encoder(port);\n\treturn 0;\n\nfail_reg:\n\tvideo_device_release(port->v4l_device);\n\tport->v4l_device = NULL;\nfail_hdl:\n\tv4l2_ctrl_handler_free(hdl);\nfail_pci:\n\treturn result;\n}\n\nvoid saa7164_encoder_unregister(struct saa7164_port *port)\n{\n\tstruct saa7164_dev *dev = port->dev;\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d)\\n\", __func__, port->nr);\n\n\tBUG_ON(port->type != SAA7164_MPEG_ENCODER);\n\n\tif (port->v4l_device) {\n\t\tif (port->v4l_device->minor != -1)\n\t\t\tvideo_unregister_device(port->v4l_device);\n\t\telse\n\t\t\tvideo_device_release(port->v4l_device);\n\n\t\tport->v4l_device = NULL;\n\t}\n\tv4l2_ctrl_handler_free(&port->ctrl_handler);\n\n\tdprintk(DBGLVL_ENC, \"%s(port=%d) done\\n\", __func__, port->nr);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}