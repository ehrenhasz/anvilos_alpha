{
  "module_name": "saa7164-cmd.c",
  "hash_id": "d371785226aa011a4e056673d3afbd550eb789f9c69347e478043634c1d88952",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7164/saa7164-cmd.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n\n#include \"saa7164.h\"\n\nstatic int saa7164_cmd_alloc_seqno(struct saa7164_dev *dev)\n{\n\tint i, ret = -1;\n\n\tmutex_lock(&dev->lock);\n\tfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\n\t\tif (dev->cmds[i].inuse == 0) {\n\t\t\tdev->cmds[i].inuse = 1;\n\t\t\tdev->cmds[i].signalled = 0;\n\t\t\tdev->cmds[i].timeout = 0;\n\t\t\tret = dev->cmds[i].seqno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\nstatic void saa7164_cmd_free_seqno(struct saa7164_dev *dev, u8 seqno)\n{\n\tmutex_lock(&dev->lock);\n\tif ((dev->cmds[seqno].inuse == 1) &&\n\t\t(dev->cmds[seqno].seqno == seqno)) {\n\t\tdev->cmds[seqno].inuse = 0;\n\t\tdev->cmds[seqno].signalled = 0;\n\t\tdev->cmds[seqno].timeout = 0;\n\t}\n\tmutex_unlock(&dev->lock);\n}\n\nstatic void saa7164_cmd_timeout_seqno(struct saa7164_dev *dev, u8 seqno)\n{\n\tmutex_lock(&dev->lock);\n\tif ((dev->cmds[seqno].inuse == 1) &&\n\t\t(dev->cmds[seqno].seqno == seqno)) {\n\t\tdev->cmds[seqno].timeout = 1;\n\t}\n\tmutex_unlock(&dev->lock);\n}\n\nstatic u32 saa7164_cmd_timeout_get(struct saa7164_dev *dev, u8 seqno)\n{\n\tint ret = 0;\n\n\tmutex_lock(&dev->lock);\n\tif ((dev->cmds[seqno].inuse == 1) &&\n\t\t(dev->cmds[seqno].seqno == seqno)) {\n\t\tret = dev->cmds[seqno].timeout;\n\t}\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\n \nint saa7164_irq_dequeue(struct saa7164_dev *dev)\n{\n\tint ret = SAA_OK, i = 0;\n\tu32 timeout;\n\twait_queue_head_t *q = NULL;\n\tu8 tmp[512];\n\tdprintk(DBGLVL_CMD, \"%s()\\n\", __func__);\n\n\t \n\tdo {\n\n\t\t \n\t\tstruct tmComResInfo tRsp = { 0, 0, 0, 0, 0, 0 };\n\t\tret = saa7164_bus_get(dev, &tRsp, NULL, 1);\n\t\tif (ret != SAA_OK)\n\t\t\tbreak;\n\n\t\tq = &dev->cmds[tRsp.seqno].wait;\n\t\ttimeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);\n\t\tdprintk(DBGLVL_CMD, \"%s() timeout = %d\\n\", __func__, timeout);\n\t\tif (!timeout) {\n\t\t\tdprintk(DBGLVL_CMD,\n\t\t\t\t\"%s() signalled seqno(%d) (for dequeue)\\n\",\n\t\t\t\t__func__, tRsp.seqno);\n\t\t\tdev->cmds[tRsp.seqno].signalled = 1;\n\t\t\twake_up(q);\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s() found timed out command on the bus\\n\",\n\t\t\t\t\t__func__);\n\n\t\t\t \n\t\t\tret = saa7164_bus_get(dev, &tRsp, &tmp, 0);\n\t\t\tprintk(KERN_ERR \"%s() ret = %x\\n\", __func__, ret);\n\t\t\tif (ret == SAA_ERR_EMPTY)\n\t\t\t\t \n\t\t\t\treturn SAA_OK;\n\n\t\t\tif (ret != SAA_OK)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t} while (i++ < 32);\n\n\treturn ret;\n}\n\n \nstatic int saa7164_cmd_dequeue(struct saa7164_dev *dev)\n{\n\tint ret;\n\tu32 timeout;\n\twait_queue_head_t *q = NULL;\n\tu8 tmp[512];\n\tdprintk(DBGLVL_CMD, \"%s()\\n\", __func__);\n\n\twhile (true) {\n\n\t\tstruct tmComResInfo tRsp = { 0, 0, 0, 0, 0, 0 };\n\t\tret = saa7164_bus_get(dev, &tRsp, NULL, 1);\n\t\tif (ret == SAA_ERR_EMPTY)\n\t\t\treturn SAA_OK;\n\n\t\tif (ret != SAA_OK)\n\t\t\treturn ret;\n\n\t\tq = &dev->cmds[tRsp.seqno].wait;\n\t\ttimeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);\n\t\tdprintk(DBGLVL_CMD, \"%s() timeout = %d\\n\", __func__, timeout);\n\t\tif (timeout) {\n\t\t\tprintk(KERN_ERR \"found timed out command on the bus\\n\");\n\n\t\t\t \n\t\t\tret = saa7164_bus_get(dev, &tRsp, &tmp, 0);\n\t\t\tprintk(KERN_ERR \"ret = %x\\n\", ret);\n\t\t\tif (ret == SAA_ERR_EMPTY)\n\t\t\t\t \n\t\t\t\treturn SAA_OK;\n\n\t\t\tif (ret != SAA_OK)\n\t\t\t\treturn ret;\n\n\t\t\tif (tRsp.flags & PVC_CMDFLAG_CONTINUE)\n\t\t\t\tprintk(KERN_ERR \"split response\\n\");\n\t\t\telse\n\t\t\t\tsaa7164_cmd_free_seqno(dev, tRsp.seqno);\n\n\t\t\tprintk(KERN_ERR \" timeout continue\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdprintk(DBGLVL_CMD, \"%s() signalled seqno(%d) (for dequeue)\\n\",\n\t\t\t__func__, tRsp.seqno);\n\t\tdev->cmds[tRsp.seqno].signalled = 1;\n\t\twake_up(q);\n\t\treturn SAA_OK;\n\t}\n}\n\nstatic int saa7164_cmd_set(struct saa7164_dev *dev, struct tmComResInfo *msg,\n\t\t\t   void *buf)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu8 cmd_sent;\n\tu16 size, idx;\n\tu32 cmds;\n\tvoid *tmp;\n\tint ret = -1;\n\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s() !msg\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\tmutex_lock(&dev->cmds[msg->id].lock);\n\n\tsize = msg->size;\n\tcmds = size / bus->m_wMaxReqSize;\n\tif (size % bus->m_wMaxReqSize == 0)\n\t\tcmds -= 1;\n\n\tcmd_sent = 0;\n\n\t \n\tfor (idx = 0; idx < cmds; idx++) {\n\n\t\tmsg->flags |= SAA_CMDFLAG_CONTINUE;\n\t\tmsg->size = bus->m_wMaxReqSize;\n\t\ttmp = buf + idx * bus->m_wMaxReqSize;\n\n\t\tret = saa7164_bus_set(dev, msg, tmp);\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"%s() set failed %d\\n\", __func__, ret);\n\n\t\t\tif (cmd_sent) {\n\t\t\t\tret = SAA_ERR_BUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = SAA_ERR_OVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\t\tcmd_sent = 1;\n\t}\n\n\t \n\tif (idx != 0)\n\t\tmsg->flags &= ~SAA_CMDFLAG_CONTINUE;\n\n\tmsg->size = size - idx * bus->m_wMaxReqSize;\n\n\tret = saa7164_bus_set(dev, msg, buf + idx * bus->m_wMaxReqSize);\n\tif (ret != SAA_OK) {\n\t\tprintk(KERN_ERR \"%s() set last failed %d\\n\", __func__, ret);\n\n\t\tif (cmd_sent) {\n\t\t\tret = SAA_ERR_BUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tret = SAA_ERR_OVERFLOW;\n\t\tgoto out;\n\t}\n\tret = SAA_OK;\n\nout:\n\tmutex_unlock(&dev->cmds[msg->id].lock);\n\treturn ret;\n}\n\n \nstatic int saa7164_cmd_wait(struct saa7164_dev *dev, u8 seqno)\n{\n\twait_queue_head_t *q = NULL;\n\tint ret = SAA_BUS_TIMEOUT;\n\tunsigned long stamp;\n\tint r;\n\n\tif (saa_debug >= 4)\n\t\tsaa7164_bus_dump(dev);\n\n\tdprintk(DBGLVL_CMD, \"%s(seqno=%d)\\n\", __func__, seqno);\n\n\tmutex_lock(&dev->lock);\n\tif ((dev->cmds[seqno].inuse == 1) &&\n\t\t(dev->cmds[seqno].seqno == seqno)) {\n\t\tq = &dev->cmds[seqno].wait;\n\t}\n\tmutex_unlock(&dev->lock);\n\n\tif (q) {\n\t\t \n\t\tif (dev->cmds[seqno].signalled == 0) {\n\t\t\tstamp = jiffies;\n\t\t\tdprintk(DBGLVL_CMD,\n\t\t\t\t\"%s(seqno=%d) Waiting (signalled=%d)\\n\",\n\t\t\t\t__func__, seqno, dev->cmds[seqno].signalled);\n\n\t\t\t \n\t\t\t \n\t\t\twait_event_timeout(*q, dev->cmds[seqno].signalled,\n\t\t\t\t(HZ * waitsecs));\n\t\t\tr = time_before(jiffies, stamp + (HZ * waitsecs));\n\t\t\tif (r)\n\t\t\t\tret = SAA_OK;\n\t\t\telse\n\t\t\t\tsaa7164_cmd_timeout_seqno(dev, seqno);\n\n\t\t\tdprintk(DBGLVL_CMD, \"%s(seqno=%d) Waiting res = %d (signalled=%d)\\n\",\n\t\t\t\t__func__, seqno, r,\n\t\t\t\tdev->cmds[seqno].signalled);\n\t\t} else\n\t\t\tret = SAA_OK;\n\t} else\n\t\tprintk(KERN_ERR \"%s(seqno=%d) seqno is invalid\\n\",\n\t\t\t__func__, seqno);\n\n\treturn ret;\n}\n\nvoid saa7164_cmd_signal(struct saa7164_dev *dev, u8 seqno)\n{\n\tint i;\n\tdprintk(DBGLVL_CMD, \"%s()\\n\", __func__);\n\n\tmutex_lock(&dev->lock);\n\tfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\n\t\tif (dev->cmds[i].inuse == 1) {\n\t\t\tdprintk(DBGLVL_CMD,\n\t\t\t\t\"seqno %d inuse, sig = %d, t/out = %d\\n\",\n\t\t\t\tdev->cmds[i].seqno,\n\t\t\t\tdev->cmds[i].signalled,\n\t\t\t\tdev->cmds[i].timeout);\n\t\t}\n\t}\n\n\tfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\n\t\tif ((dev->cmds[i].inuse == 1) && ((i == 0) ||\n\t\t\t(dev->cmds[i].signalled) || (dev->cmds[i].timeout))) {\n\t\t\tdprintk(DBGLVL_CMD, \"%s(seqno=%d) calling wake_up\\n\",\n\t\t\t\t__func__, i);\n\t\t\tdev->cmds[i].signalled = 1;\n\t\t\twake_up(&dev->cmds[i].wait);\n\t\t}\n\t}\n\tmutex_unlock(&dev->lock);\n}\n\nint saa7164_cmd_send(struct saa7164_dev *dev, u8 id, enum tmComResCmd command,\n\tu16 controlselector, u16 size, void *buf)\n{\n\tstruct tmComResInfo command_t, *pcommand_t;\n\tstruct tmComResInfo response_t, *presponse_t;\n\tu8 errdata[256];\n\tu16 resp_dsize;\n\tu16 data_recd;\n\tu32 loop;\n\tint ret;\n\tint safety = 0;\n\n\tdprintk(DBGLVL_CMD, \"%s(unitid = %s (%d) , command = 0x%x, sel = 0x%x)\\n\",\n\t\t__func__, saa7164_unitid_name(dev, id), id,\n\t\tcommand, controlselector);\n\n\tif ((size == 0) || (buf == NULL)) {\n\t\tprintk(KERN_ERR \"%s() Invalid param\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\t \n\tmemset(&command_t, 0, sizeof(command_t));\n\tmemset(&response_t, 0, sizeof(response_t));\n\tpcommand_t = &command_t;\n\tpresponse_t = &response_t;\n\tcommand_t.id = id;\n\tcommand_t.command = command;\n\tcommand_t.controlselector = controlselector;\n\tcommand_t.size = size;\n\n\t \n\tret = saa7164_cmd_alloc_seqno(dev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s() No free sequences\\n\", __func__);\n\t\tret = SAA_ERR_NO_RESOURCES;\n\t\tgoto out;\n\t}\n\n\tcommand_t.seqno = (u8)ret;\n\n\t \n\tresp_dsize = size;\n\tpcommand_t->size = size;\n\n\tdprintk(DBGLVL_CMD, \"%s() pcommand_t.seqno = %d\\n\",\n\t\t__func__, pcommand_t->seqno);\n\n\tdprintk(DBGLVL_CMD, \"%s() pcommand_t.size = %d\\n\",\n\t\t__func__, pcommand_t->size);\n\n\tret = saa7164_cmd_set(dev, pcommand_t, buf);\n\tif (ret != SAA_OK) {\n\t\tprintk(KERN_ERR \"%s() set command failed %d\\n\", __func__, ret);\n\n\t\tif (ret != SAA_ERR_BUSY)\n\t\t\tsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\n\t\telse\n\t\t\t \n\t\t\tsaa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);\n\n\t\tgoto out;\n\t}\n\n\t \n\tdata_recd = 0;\n\tloop = 1;\n\twhile (loop) {\n\t\tdprintk(DBGLVL_CMD, \"%s() loop\\n\", __func__);\n\n\t\tret = saa7164_cmd_wait(dev, pcommand_t->seqno);\n\t\tdprintk(DBGLVL_CMD, \"%s() loop ret = %d\\n\", __func__, ret);\n\n\t\t \n\n\t\tif (ret == SAA_BUS_TIMEOUT) {\n\t\t\tprintk(KERN_ERR \"Event timed out\\n\");\n\t\t\tsaa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"spurious error\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = saa7164_bus_get(dev, presponse_t, NULL, 1);\n\t\tif (ret == SAA_ERR_EMPTY) {\n\t\t\tdprintk(4, \"%s() SAA_ERR_EMPTY\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"peek failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdprintk(DBGLVL_CMD, \"%s() presponse_t->seqno = %d\\n\",\n\t\t\t__func__, presponse_t->seqno);\n\n\t\tdprintk(DBGLVL_CMD, \"%s() presponse_t->flags = 0x%x\\n\",\n\t\t\t__func__, presponse_t->flags);\n\n\t\tdprintk(DBGLVL_CMD, \"%s() presponse_t->size = %d\\n\",\n\t\t\t__func__, presponse_t->size);\n\n\t\t \n\t\tif (presponse_t->seqno != pcommand_t->seqno) {\n\n\t\t\tdprintk(DBGLVL_CMD,\n\t\t\t\t\"wrong event: seqno = %d, expected seqno = %d, will dequeue regardless\\n\",\n\t\t\t\tpresponse_t->seqno, pcommand_t->seqno);\n\n\t\t\tret = saa7164_cmd_dequeue(dev);\n\t\t\tif (ret != SAA_OK) {\n\t\t\t\tprintk(KERN_ERR \"dequeue failed, ret = %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tif (safety++ > 16) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\"dequeue exceeded, safety exit\\n\");\n\t\t\t\t\treturn SAA_ERR_BUSY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((presponse_t->flags & PVC_RESPONSEFLAG_ERROR) != 0) {\n\n\t\t\tmemset(&errdata[0], 0, sizeof(errdata));\n\n\t\t\tret = saa7164_bus_get(dev, presponse_t, &errdata[0], 0);\n\t\t\tif (ret != SAA_OK) {\n\t\t\t\tprintk(KERN_ERR \"get error(2)\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\n\n\t\t\tdprintk(DBGLVL_CMD, \"%s() errdata %02x%02x%02x%02x\\n\",\n\t\t\t\t__func__, errdata[0], errdata[1], errdata[2],\n\t\t\t\terrdata[3]);\n\n\t\t\t \n\t\t\tdprintk(DBGLVL_CMD, \"%s() cmd, error code  = 0x%x\\n\",\n\t\t\t\t__func__, errdata[0]);\n\n\t\t\tswitch (errdata[0]) {\n\t\t\tcase PVC_ERRORCODE_INVALID_COMMAND:\n\t\t\t\tdprintk(DBGLVL_CMD, \"%s() INVALID_COMMAND\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\t\t\tbreak;\n\t\t\tcase PVC_ERRORCODE_INVALID_DATA:\n\t\t\t\tdprintk(DBGLVL_CMD, \"%s() INVALID_DATA\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = SAA_ERR_BAD_PARAMETER;\n\t\t\t\tbreak;\n\t\t\tcase PVC_ERRORCODE_TIMEOUT:\n\t\t\t\tdprintk(DBGLVL_CMD, \"%s() TIMEOUT\\n\", __func__);\n\t\t\t\tret = SAA_ERR_TIMEOUT;\n\t\t\t\tbreak;\n\t\t\tcase PVC_ERRORCODE_NAK:\n\t\t\t\tdprintk(DBGLVL_CMD, \"%s() NAK\\n\", __func__);\n\t\t\t\tret = SAA_ERR_NULL_PACKET;\n\t\t\t\tbreak;\n\t\t\tcase PVC_ERRORCODE_UNKNOWN:\n\t\t\tcase PVC_ERRORCODE_INVALID_CONTROL:\n\t\t\t\tdprintk(DBGLVL_CMD,\n\t\t\t\t\t\"%s() UNKNOWN OR INVALID CONTROL\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tret = SAA_ERR_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdprintk(DBGLVL_CMD, \"%s() UNKNOWN\\n\", __func__);\n\t\t\t\tret = SAA_ERR_NOT_SUPPORTED;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (saa7164_cmd_dequeue(dev) != SAA_OK)\n\t\t\t\tprintk(KERN_ERR \"dequeue(2) failed\\n\");\n\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif ((presponse_t->id != pcommand_t->id) ||\n\t\t\t(presponse_t->command != pcommand_t->command) ||\n\t\t\t(presponse_t->controlselector !=\n\t\t\t\tpcommand_t->controlselector) ||\n\t\t\t(((resp_dsize - data_recd) != presponse_t->size) &&\n\t\t\t\t!(presponse_t->flags & PVC_CMDFLAG_CONTINUE)) ||\n\t\t\t((resp_dsize - data_recd) < presponse_t->size)) {\n\n\t\t\t \n\t\t\tdprintk(DBGLVL_CMD, \"%s() Invalid\\n\", __func__);\n\t\t\tret = saa7164_bus_get(dev, presponse_t, NULL, 0);\n\t\t\tif (ret != SAA_OK) {\n\t\t\t\tprintk(KERN_ERR \"get failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (saa7164_cmd_dequeue(dev) != SAA_OK)\n\t\t\t\tprintk(KERN_ERR \"dequeue(3) failed\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = saa7164_bus_get(dev, presponse_t, buf + data_recd, 0);\n\t\tif (ret != SAA_OK) {\n\t\t\tprintk(KERN_ERR \"get failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata_recd = presponse_t->size + data_recd;\n\t\tif (resp_dsize == data_recd) {\n\t\t\tdprintk(DBGLVL_CMD, \"%s() Resp recd\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (saa7164_cmd_dequeue(dev) != SAA_OK)\n\t\t\tprintk(KERN_ERR \"dequeue(3) failed\\n\");\n\t}  \n\n\t \n\tsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\n\n\t \n\n\tdprintk(DBGLVL_CMD, \"%s() Calling dequeue then exit\\n\", __func__);\n\n\t \n\tif (saa7164_cmd_dequeue(dev) != SAA_OK)\n\t\tprintk(KERN_ERR \"dequeue(4) failed\\n\");\n\n\tret = SAA_OK;\nout:\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}