{
  "module_name": "sta2x11_vip.c",
  "hash_id": "a4b5e204f34afd08603b8a601dc8a59089dafc2d0389f1048b1caad773f77ab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/sta2x11/sta2x11_vip.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/videodev2.h>\n#include <linux/kmod.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"sta2x11_vip.h\"\n\n#define DRV_VERSION \"1.3\"\n\n#ifndef PCI_DEVICE_ID_STMICRO_VIP\n#define PCI_DEVICE_ID_STMICRO_VIP 0xCC0D\n#endif\n\n#define MAX_FRAMES 4\n\n \n#define DVP_CTL\t\t0x00\n#define DVP_TFO\t\t0x04\n#define DVP_TFS\t\t0x08\n#define DVP_BFO\t\t0x0C\n#define DVP_BFS\t\t0x10\n#define DVP_VTP\t\t0x14\n#define DVP_VBP\t\t0x18\n#define DVP_VMP\t\t0x1C\n#define DVP_ITM\t\t0x98\n#define DVP_ITS\t\t0x9C\n#define DVP_STA\t\t0xA0\n#define DVP_HLFLN\t0xA8\n#define DVP_RGB\t\t0xC0\n#define DVP_PKZ\t\t0xF0\n\n \n#define DVP_CTL_ENA\t0x00000001\n#define DVP_CTL_RST\t0x80000000\n#define DVP_CTL_DIS\t(~0x00040001)\n\n#define DVP_IT_VSB\t0x00000008\n#define DVP_IT_VST\t0x00000010\n#define DVP_IT_FIFO\t0x00000020\n\n#define DVP_HLFLN_SD\t0x00000001\n\n#define SAVE_COUNT 8\n#define AUX_COUNT 3\n#define IRQ_COUNT 1\n\n\nstruct vip_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head\tlist;\n\tdma_addr_t\t\tdma;\n};\nstatic inline struct vip_buffer *to_vip_buffer(struct vb2_v4l2_buffer *vb2)\n{\n\treturn container_of(vb2, struct vip_buffer, vb);\n}\n\n \nstruct sta2x11_vip {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device video_dev;\n\tstruct pci_dev *pdev;\n\tstruct i2c_adapter *adapter;\n\tunsigned int register_save_area[IRQ_COUNT + SAVE_COUNT + AUX_COUNT];\n\tstruct v4l2_subdev *decoder;\n\tstruct v4l2_ctrl_handler ctrl_hdl;\n\n\n\tstruct v4l2_pix_format format;\n\tv4l2_std_id std;\n\tunsigned int input;\n\tint disabled;\n\tspinlock_t slock;\n\n\tstruct vb2_queue vb_vidq;\n\tstruct list_head buffer_list;\n\tunsigned int sequence;\n\tstruct vip_buffer *active;  \n\tspinlock_t lock;  \n\tstruct mutex v4l_lock;\n\n\t \n\tint tcount, bcount;\n\tint overflow;\n\n\tvoid __iomem *iomem;\t \n\tstruct vip_config *config;\n};\n\nstatic const unsigned int registers_to_save[AUX_COUNT] = {\n\tDVP_HLFLN, DVP_RGB, DVP_PKZ\n};\n\nstatic struct v4l2_pix_format formats_50[] = {\n\t{\t\t\t \n\t .width = 720,\n\t .height = 576,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_INTERLACED,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 576,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n\t{\t\t\t \n\t .width = 720,\n\t .height = 288,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_TOP,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 288,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n\t{\t\t\t \n\t .width = 720,\n\t .height = 288,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_BOTTOM,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 288,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n\n};\n\nstatic struct v4l2_pix_format formats_60[] = {\n\t{\t\t\t \n\t .width = 720,\n\t .height = 480,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_INTERLACED,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 480,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n\t{\t\t\t \n\t .width = 720,\n\t .height = 240,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_TOP,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 240,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n\t{\t\t\t \n\t .width = 720,\n\t .height = 240,\n\t .pixelformat = V4L2_PIX_FMT_UYVY,\n\t .field = V4L2_FIELD_BOTTOM,\n\t .bytesperline = 720 * 2,\n\t .sizeimage = 720 * 2 * 240,\n\t .colorspace = V4L2_COLORSPACE_SMPTE170M},\n};\n\n \nstatic inline void reg_write(struct sta2x11_vip *vip, unsigned int reg, u32 val)\n{\n\tiowrite32((val), (vip->iomem)+(reg));\n}\n \nstatic inline u32 reg_read(struct sta2x11_vip *vip, unsigned int reg)\n{\n\treturn  ioread32((vip->iomem)+(reg));\n}\n \nstatic void start_dma(struct sta2x11_vip *vip, struct vip_buffer *vip_buf)\n{\n\tunsigned long offset = 0;\n\n\tif (vip->format.field == V4L2_FIELD_INTERLACED)\n\t\toffset = vip->format.width * 2;\n\n\tspin_lock_irq(&vip->slock);\n\t \n\treg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) | DVP_CTL_ENA);\n\t \n\treg_write(vip, DVP_VTP, (u32)vip_buf->dma);\n\treg_write(vip, DVP_VBP, (u32)vip_buf->dma + offset);\n\tspin_unlock_irq(&vip->slock);\n}\n\n \nstatic void vip_active_buf_next(struct sta2x11_vip *vip)\n{\n\t \n\tspin_lock(&vip->lock);\n\tif (list_empty(&vip->buffer_list)) { \n\t\tspin_unlock(&vip->lock);\n\t\treturn;\n\t}\n\tvip->active = list_first_entry(&vip->buffer_list,\n\t\t\t\t       struct vip_buffer,\n\t\t\t\t       list);\n\t \n\tvip->tcount = 0;\n\tvip->bcount = 0;\n\tspin_unlock(&vip->lock);\n\tif (vb2_is_streaming(&vip->vb_vidq)) {\t \n\t\tstart_dma(vip, vip->active);\t \n\t}\n}\n\n\n \nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\n\n\tif (!(*nbuffers) || *nbuffers < MAX_FRAMES)\n\t\t*nbuffers = MAX_FRAMES;\n\n\t*nplanes = 1;\n\tsizes[0] = vip->format.sizeimage;\n\n\tvip->sequence = 0;\n\tvip->active = NULL;\n\tvip->tcount = 0;\n\tvip->bcount = 0;\n\n\treturn 0;\n};\nstatic int buffer_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vip_buffer *vip_buf = to_vip_buffer(vbuf);\n\n\tvip_buf->dma = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tINIT_LIST_HEAD(&vip_buf->list);\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vip_buffer *vip_buf = to_vip_buffer(vbuf);\n\tunsigned long size;\n\n\tsize = vip->format.sizeimage;\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tv4l2_err(&vip->v4l2_dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(&vip_buf->vb.vb2_buf, 0, size);\n\n\treturn 0;\n}\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vip_buffer *vip_buf = to_vip_buffer(vbuf);\n\n\tspin_lock(&vip->lock);\n\tlist_add_tail(&vip_buf->list, &vip->buffer_list);\n\tif (!vip->active) {\t \n\t\tvip->active = list_first_entry(&vip->buffer_list,\n\t\t\t\t\t       struct vip_buffer,\n\t\t\t\t\t       list);\n\t\tif (vb2_is_streaming(&vip->vb_vidq))\t \n\t\t\tstart_dma(vip, vip_buf);\t \n\t}\n\tspin_unlock(&vip->lock);\n}\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vip_buffer *vip_buf = to_vip_buffer(vbuf);\n\n\t \n\tspin_lock(&vip->lock);\n\tlist_del_init(&vip_buf->list);\n\tspin_unlock(&vip->lock);\n\n\tif (vb2_is_streaming(vb->vb2_queue))\n\t\tvip_active_buf_next(vip);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\n\n\tspin_lock_irq(&vip->slock);\n\t \n\treg_write(vip, DVP_ITM, DVP_IT_VSB | DVP_IT_VST);\n\tspin_unlock_irq(&vip->slock);\n\n\tif (count)\n\t\tstart_dma(vip, vip->active);\n\n\treturn 0;\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\n\tstruct vip_buffer *vip_buf, *node;\n\n\t \n\treg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) & ~DVP_CTL_ENA);\n\t \n\treg_write(vip, DVP_ITM, 0);\n\n\t \n\tspin_lock(&vip->lock);\n\tlist_for_each_entry_safe(vip_buf, node, &vip->buffer_list, list) {\n\t\tvb2_buffer_done(&vip_buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&vip_buf->list);\n\t}\n\tspin_unlock(&vip->lock);\n}\n\nstatic const struct vb2_ops vip_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_init\t\t= buffer_init,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_finish\t\t= buffer_finish,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n\n \nstatic const struct v4l2_file_operations vip_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll\n};\n\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));\n\treturn 0;\n}\n\n \nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\n\t \n\tif (std == V4L2_STD_ALL) {\n\t\tv4l2_subdev_call(vip->decoder, video, querystd, &std);\n\t\tif (std == V4L2_STD_UNKNOWN)\n\t\t\treturn -EIO;\n\t}\n\n\tif (vip->std != std) {\n\t\tvip->std = std;\n\t\tif (V4L2_STD_525_60 & std)\n\t\t\tvip->format = formats_60[0];\n\t\telse\n\t\t\tvip->format = formats_50[0];\n\t}\n\n\treturn v4l2_subdev_call(vip->decoder, video, s_std, std);\n}\n\n \nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\n\t*std = vip->std;\n\treturn 0;\n}\n\n \nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\n\treturn v4l2_subdev_call(vip->decoder, video, querystd, std);\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *inp)\n{\n\tif (inp->index > 1)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->std = V4L2_STD_ALL;\n\tsprintf(inp->name, \"Camera %u\", inp->index);\n\n\treturn 0;\n}\n\n \nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\tint ret;\n\n\tif (i > 1)\n\t\treturn -EINVAL;\n\tret = v4l2_subdev_call(vip->decoder, video, s_routing, i, 0, 0);\n\n\tif (!ret)\n\t\tvip->input = i;\n\n\treturn 0;\n}\n\n \nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\n\t*i = vip->input;\n\treturn 0;\n}\n\n \nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_UYVY;\n\treturn 0;\n}\n\n \nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\tint interlace_lim;\n\n\tif (V4L2_PIX_FMT_UYVY != f->fmt.pix.pixelformat) {\n\t\tv4l2_warn(&vip->v4l2_dev, \"Invalid format, only UYVY supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (V4L2_STD_525_60 & vip->std)\n\t\tinterlace_lim = 240;\n\telse\n\t\tinterlace_lim = 288;\n\n\tswitch (f->fmt.pix.field) {\n\tdefault:\n\tcase V4L2_FIELD_ANY:\n\t\tif (interlace_lim < f->fmt.pix.height)\n\t\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\t\telse\n\t\t\tf->fmt.pix.field = V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\t\tif (interlace_lim < f->fmt.pix.height)\n\t\t\tf->fmt.pix.height = interlace_lim;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\t\tbreak;\n\t}\n\n\t \n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\n\tf->fmt.pix.height &= ~1;\n\tif (2 * interlace_lim < f->fmt.pix.height)\n\t\tf->fmt.pix.height = 2 * interlace_lim;\n\tif (200 > f->fmt.pix.height)\n\t\tf->fmt.pix.height = 200;\n\tf->fmt.pix.width = 720;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\tf->fmt.pix.sizeimage = f->fmt.pix.width * 2 * f->fmt.pix.height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\n \nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\tunsigned int t_stop, b_stop, pitch;\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vb2_is_busy(&vip->vb_vidq)) {\n\t\t \n\t\tv4l2_err(&vip->v4l2_dev, \"device busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\tvip->format = f->fmt.pix;\n\tswitch (vip->format.field) {\n\tcase V4L2_FIELD_INTERLACED:\n\t\tt_stop = ((vip->format.height / 2 - 1) << 16) |\n\t\t\t (2 * vip->format.width - 1);\n\t\tb_stop = t_stop;\n\t\tpitch = 4 * vip->format.width;\n\t\tbreak;\n\tcase V4L2_FIELD_TOP:\n\t\tt_stop = ((vip->format.height - 1) << 16) |\n\t\t\t (2 * vip->format.width - 1);\n\t\tb_stop = (0 << 16) | (2 * vip->format.width - 1);\n\t\tpitch = 2 * vip->format.width;\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tt_stop = (0 << 16) | (2 * vip->format.width - 1);\n\t\tb_stop = (vip->format.height << 16) |\n\t\t\t (2 * vip->format.width - 1);\n\t\tpitch = 2 * vip->format.width;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&vip->v4l2_dev, \"unknown field format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&vip->slock);\n\t \n\treg_write(vip, DVP_TFO, 0);\n\t \n\treg_write(vip, DVP_BFO, 0);\n\t \n\treg_write(vip, DVP_TFS, t_stop);\n\t \n\treg_write(vip, DVP_BFS, b_stop);\n\t \n\treg_write(vip, DVP_VMP, pitch);\n\tspin_unlock_irq(&vip->slock);\n\n\treturn 0;\n}\n\n \nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct sta2x11_vip *vip = video_drvdata(file);\n\n\tf->fmt.pix = vip->format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops vip_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\t \n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap,\n\t \n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t \n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t \n\t.vidioc_g_std = vidioc_g_std,\n\t.vidioc_s_std = vidioc_s_std,\n\t.vidioc_querystd = vidioc_querystd,\n\t \n\t.vidioc_enum_input = vidioc_enum_input,\n\t.vidioc_g_input = vidioc_g_input,\n\t.vidioc_s_input = vidioc_s_input,\n\t \n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t \n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device video_dev_template = {\n\t.name = KBUILD_MODNAME,\n\t.release = video_device_release_empty,\n\t.fops = &vip_fops,\n\t.ioctl_ops = &vip_ioctl_ops,\n\t.tvnorms = V4L2_STD_ALL,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t       V4L2_CAP_STREAMING,\n};\n\n \nstatic irqreturn_t vip_irq(int irq, struct sta2x11_vip *vip)\n{\n\tunsigned int status;\n\n\tstatus = reg_read(vip, DVP_ITS);\n\n\tif (!status)\t\t \n\t\treturn IRQ_NONE;\n\n\tif (status & DVP_IT_FIFO)\n\t\tif (vip->overflow++ > 5)\n\t\t\tpr_info(\"VIP: fifo overflow\\n\");\n\n\tif ((status & DVP_IT_VST) && (status & DVP_IT_VSB)) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (status & DVP_IT_VST)\n\t\tif ((++vip->tcount) < 2)\n\t\t\treturn IRQ_HANDLED;\n\tif (status & DVP_IT_VSB) {\n\t\tvip->bcount++;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (vip->active) {  \n\t\t \n\t\treg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) & ~DVP_CTL_ENA);\n\t\t \n\t\tvip->active->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tvip->active->vb.sequence = vip->sequence++;\n\t\tvb2_buffer_done(&vip->active->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sta2x11_vip_init_register(struct sta2x11_vip *vip)\n{\n\t \n\tspin_lock_irq(&vip->slock);\n\t \n\treg_read(vip, DVP_ITS);\n\t \n\treg_write(vip, DVP_HLFLN, DVP_HLFLN_SD);\n\t \n\treg_write(vip, DVP_CTL, DVP_CTL_RST);\n\t \n\treg_write(vip, DVP_CTL, 0);\n\tspin_unlock_irq(&vip->slock);\n}\nstatic void sta2x11_vip_clear_register(struct sta2x11_vip *vip)\n{\n\tspin_lock_irq(&vip->slock);\n\t \n\treg_write(vip, DVP_ITM, 0);\n\t \n\treg_write(vip, DVP_CTL, DVP_CTL_RST);\n\t \n\treg_write(vip, DVP_CTL, 0);\n\t \n\treg_read(vip, DVP_ITS);\n\tspin_unlock_irq(&vip->slock);\n}\nstatic int sta2x11_vip_init_buffer(struct sta2x11_vip *vip)\n{\n\tint err;\n\n\terr = dma_set_coherent_mask(&vip->pdev->dev, DMA_BIT_MASK(29));\n\tif (err) {\n\t\tv4l2_err(&vip->v4l2_dev, \"Cannot configure coherent mask\");\n\t\treturn err;\n\t}\n\tmemset(&vip->vb_vidq, 0, sizeof(struct vb2_queue));\n\tvip->vb_vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvip->vb_vidq.io_modes = VB2_MMAP | VB2_READ;\n\tvip->vb_vidq.drv_priv = vip;\n\tvip->vb_vidq.buf_struct_size = sizeof(struct vip_buffer);\n\tvip->vb_vidq.ops = &vip_video_qops;\n\tvip->vb_vidq.mem_ops = &vb2_dma_contig_memops;\n\tvip->vb_vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvip->vb_vidq.dev = &vip->pdev->dev;\n\tvip->vb_vidq.lock = &vip->v4l_lock;\n\terr = vb2_queue_init(&vip->vb_vidq);\n\tif (err)\n\t\treturn err;\n\tINIT_LIST_HEAD(&vip->buffer_list);\n\tspin_lock_init(&vip->lock);\n\treturn 0;\n}\n\nstatic int sta2x11_vip_init_controls(struct sta2x11_vip *vip)\n{\n\t \n\tv4l2_ctrl_handler_init(&vip->ctrl_hdl, 0);\n\n\tvip->v4l2_dev.ctrl_handler = &vip->ctrl_hdl;\n\tif (vip->ctrl_hdl.error) {\n\t\tint err = vip->ctrl_hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&vip->ctrl_hdl);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vip_gpio_reserve(struct device *dev, int pin, int dir,\n\t\t\t    const char *name)\n{\n\tstruct gpio_desc *desc = gpio_to_desc(pin);\n\tint ret = -ENODEV;\n\n\tif (!gpio_is_valid(pin))\n\t\treturn ret;\n\n\tret = gpio_request(pin, name);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate pin %d (%s)\\n\", pin, name);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_direction_output(desc, dir);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set direction for pin %d (%s)\\n\",\n\t\t\tpin, name);\n\t\tgpio_free(pin);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_export(desc, false);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to export pin %d (%s)\\n\", pin, name);\n\t\tgpio_free(pin);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vip_gpio_release(struct device *dev, int pin, const char *name)\n{\n\tif (gpio_is_valid(pin)) {\n\t\tstruct gpio_desc *desc = gpio_to_desc(pin);\n\n\t\tdev_dbg(dev, \"releasing pin %d (%s)\\n\",\tpin, name);\n\t\tgpiod_unexport(desc);\n\t\tgpio_free(pin);\n\t}\n}\n\n \nstatic int sta2x11_vip_init_one(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tint ret;\n\tstruct sta2x11_vip *vip;\n\tstruct vip_config *config;\n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(26))) {\n\t\tdev_err(&pdev->dev, \"26-bit DMA addressing not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tconfig = dev_get_platdata(&pdev->dev);\n\tif (!config) {\n\t\tdev_info(&pdev->dev, \"VIP slot disabled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto disable;\n\t}\n\n\t \n\tret = vip_gpio_reserve(&pdev->dev, config->pwr_pin, 0,\n\t\t\t       config->pwr_name);\n\tif (ret)\n\t\tgoto disable;\n\n\tret = vip_gpio_reserve(&pdev->dev, config->reset_pin, 0,\n\t\t\t       config->reset_name);\n\tif (ret) {\n\t\tvip_gpio_release(&pdev->dev, config->pwr_pin,\n\t\t\t\t config->pwr_name);\n\t\tgoto disable;\n\t}\n\n\tif (gpio_is_valid(config->pwr_pin)) {\n\t\t \n\t\tusleep_range(5000, 25000);\n\t\tgpio_direction_output(config->pwr_pin, 1);\n\t}\n\n\tif (gpio_is_valid(config->reset_pin)) {\n\t\t \n\t\tusleep_range(5000, 25000);\n\t\tgpio_direction_output(config->reset_pin, 1);\n\t}\n\tusleep_range(5000, 25000);\n\n\t \n\tvip = kzalloc(sizeof(struct sta2x11_vip), GFP_KERNEL);\n\tif (!vip) {\n\t\tret = -ENOMEM;\n\t\tgoto release_gpios;\n\t}\n\tvip->pdev = pdev;\n\tvip->std = V4L2_STD_PAL;\n\tvip->format = formats_50[0];\n\tvip->config = config;\n\tmutex_init(&vip->v4l_lock);\n\n\tret = sta2x11_vip_init_controls(vip);\n\tif (ret)\n\t\tgoto free_mem;\n\tret = v4l2_device_register(&pdev->dev, &vip->v4l2_dev);\n\tif (ret)\n\t\tgoto free_mem;\n\n\tdev_dbg(&pdev->dev, \"BAR #0 at 0x%lx 0x%lx irq %d\\n\",\n\t\t(unsigned long)pci_resource_start(pdev, 0),\n\t\t(unsigned long)pci_resource_len(pdev, 0), pdev->irq);\n\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret)\n\t\tgoto unreg;\n\n\tvip->iomem = pci_iomap(pdev, 0, 0x100);\n\tif (!vip->iomem) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tpci_enable_msi(pdev);\n\n\t \n\tret = sta2x11_vip_init_buffer(vip);\n\tif (ret)\n\t\tgoto unmap;\n\n\tspin_lock_init(&vip->slock);\n\n\tret = request_irq(pdev->irq,\n\t\t\t  (irq_handler_t) vip_irq,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, vip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto release_buf;\n\t}\n\n\t \n\tvip->video_dev = video_dev_template;\n\tvip->video_dev.v4l2_dev = &vip->v4l2_dev;\n\tvip->video_dev.queue = &vip->vb_vidq;\n\tvip->video_dev.lock = &vip->v4l_lock;\n\tvideo_set_drvdata(&vip->video_dev, vip);\n\n\tret = video_register_device(&vip->video_dev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto vrelease;\n\n\t \n\tvip->adapter = i2c_get_adapter(vip->config->i2c_id);\n\tif (!vip->adapter) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev, \"no I2C adapter found\\n\");\n\t\tgoto vunreg;\n\t}\n\n\tvip->decoder = v4l2_i2c_new_subdev(&vip->v4l2_dev, vip->adapter,\n\t\t\t\t\t   \"adv7180\", vip->config->i2c_addr,\n\t\t\t\t\t   NULL);\n\tif (!vip->decoder) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev, \"no decoder found\\n\");\n\t\tgoto vunreg;\n\t}\n\n\ti2c_put_adapter(vip->adapter);\n\tv4l2_subdev_call(vip->decoder, core, init, 0);\n\n\tsta2x11_vip_init_register(vip);\n\n\tdev_info(&pdev->dev, \"STA2X11 Video Input Port (VIP) loaded\\n\");\n\treturn 0;\n\nvunreg:\n\tvideo_set_drvdata(&vip->video_dev, NULL);\nvrelease:\n\tvb2_video_unregister_device(&vip->video_dev);\n\tfree_irq(pdev->irq, vip);\nrelease_buf:\n\tpci_disable_msi(pdev);\nunmap:\n\tpci_iounmap(pdev, vip->iomem);\nrelease:\n\tpci_release_regions(pdev);\nunreg:\n\tv4l2_device_unregister(&vip->v4l2_dev);\nfree_mem:\n\tkfree(vip);\nrelease_gpios:\n\tvip_gpio_release(&pdev->dev, config->reset_pin, config->reset_name);\n\tvip_gpio_release(&pdev->dev, config->pwr_pin, config->pwr_name);\ndisable:\n\t \n\treturn ret;\n}\n\n \nstatic void sta2x11_vip_remove_one(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct sta2x11_vip *vip =\n\t    container_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\n\n\tsta2x11_vip_clear_register(vip);\n\n\tvideo_set_drvdata(&vip->video_dev, NULL);\n\tvb2_video_unregister_device(&vip->video_dev);\n\tfree_irq(pdev->irq, vip);\n\tpci_disable_msi(pdev);\n\tpci_iounmap(pdev, vip->iomem);\n\tpci_release_regions(pdev);\n\n\tv4l2_device_unregister(&vip->v4l2_dev);\n\n\tvip_gpio_release(&pdev->dev, vip->config->pwr_pin,\n\t\t\t vip->config->pwr_name);\n\tvip_gpio_release(&pdev->dev, vip->config->reset_pin,\n\t\t\t vip->config->reset_name);\n\n\tkfree(vip);\n\t \n}\n\n \nstatic int __maybe_unused sta2x11_vip_suspend(struct device *dev_d)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev_d);\n\tstruct sta2x11_vip *vip =\n\t    container_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&vip->slock, flags);\n\tvip->register_save_area[0] = reg_read(vip, DVP_CTL);\n\treg_write(vip, DVP_CTL, vip->register_save_area[0] & DVP_CTL_DIS);\n\tvip->register_save_area[SAVE_COUNT] = reg_read(vip, DVP_ITM);\n\treg_write(vip, DVP_ITM, 0);\n\tfor (i = 1; i < SAVE_COUNT; i++)\n\t\tvip->register_save_area[i] = reg_read(vip, 4 * i);\n\tfor (i = 0; i < AUX_COUNT; i++)\n\t\tvip->register_save_area[SAVE_COUNT + IRQ_COUNT + i] =\n\t\t    reg_read(vip, registers_to_save[i]);\n\tspin_unlock_irqrestore(&vip->slock, flags);\n\n\tvip->disabled = 1;\n\n\tpr_info(\"VIP: suspend\\n\");\n\treturn 0;\n}\n\n \nstatic int __maybe_unused sta2x11_vip_resume(struct device *dev_d)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev_d);\n\tstruct sta2x11_vip *vip =\n\t    container_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\n\tunsigned long flags;\n\tint i;\n\n\tpr_info(\"VIP: resume\\n\");\n\n\tvip->disabled = 0;\n\n\tspin_lock_irqsave(&vip->slock, flags);\n\tfor (i = 1; i < SAVE_COUNT; i++)\n\t\treg_write(vip, 4 * i, vip->register_save_area[i]);\n\tfor (i = 0; i < AUX_COUNT; i++)\n\t\treg_write(vip, registers_to_save[i],\n\t\t\t  vip->register_save_area[SAVE_COUNT + IRQ_COUNT + i]);\n\treg_write(vip, DVP_CTL, vip->register_save_area[0]);\n\treg_write(vip, DVP_ITM, vip->register_save_area[SAVE_COUNT]);\n\tspin_unlock_irqrestore(&vip->slock, flags);\n\treturn 0;\n}\n\nstatic const struct pci_device_id sta2x11_vip_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_VIP)},\n\t{0,}\n};\n\nstatic SIMPLE_DEV_PM_OPS(sta2x11_vip_pm_ops,\n\t\t\t sta2x11_vip_suspend,\n\t\t\t sta2x11_vip_resume);\n\nstatic struct pci_driver sta2x11_vip_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = sta2x11_vip_init_one,\n\t.remove = sta2x11_vip_remove_one,\n\t.id_table = sta2x11_vip_pci_tbl,\n\t.driver.pm = &sta2x11_vip_pm_ops,\n};\n\nstatic int __init sta2x11_vip_init_module(void)\n{\n\treturn pci_register_driver(&sta2x11_vip_driver);\n}\n\nstatic void __exit sta2x11_vip_exit_module(void)\n{\n\tpci_unregister_driver(&sta2x11_vip_driver);\n}\n\n#ifdef MODULE\nmodule_init(sta2x11_vip_init_module);\nmodule_exit(sta2x11_vip_exit_module);\n#else\nlate_initcall_sync(sta2x11_vip_init_module);\n#endif\n\nMODULE_DESCRIPTION(\"STA2X11 Video Input Port driver\");\nMODULE_AUTHOR(\"Wind River\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, sta2x11_vip_pci_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}