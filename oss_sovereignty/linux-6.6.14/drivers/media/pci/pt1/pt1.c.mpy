{
  "module_name": "pt1.c",
  "hash_id": "1aab205847ffbabc1cb5b54b0a7893086baf68caa225ba137d27d674ef0ee667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/pt1/pt1.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/hrtimer.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/pci.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/i2c.h>\n\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dmxdev.h>\n#include <media/dvb_net.h>\n#include <media/dvb_frontend.h>\n\n#include \"tc90522.h\"\n#include \"qm1d1b0004.h\"\n#include \"dvb-pll.h\"\n\n#define DRIVER_NAME \"earth-pt1\"\n\n#define PT1_PAGE_SHIFT 12\n#define PT1_PAGE_SIZE (1 << PT1_PAGE_SHIFT)\n#define PT1_NR_UPACKETS 1024\n#define PT1_NR_BUFS 511\n\nstruct pt1_buffer_page {\n\t__le32 upackets[PT1_NR_UPACKETS];\n};\n\nstruct pt1_table_page {\n\t__le32 next_pfn;\n\t__le32 buf_pfns[PT1_NR_BUFS];\n};\n\nstruct pt1_buffer {\n\tstruct pt1_buffer_page *page;\n\tdma_addr_t addr;\n};\n\nstruct pt1_table {\n\tstruct pt1_table_page *page;\n\tdma_addr_t addr;\n\tstruct pt1_buffer bufs[PT1_NR_BUFS];\n};\n\nenum pt1_fe_clk {\n\tPT1_FE_CLK_20MHZ,\t \n\tPT1_FE_CLK_25MHZ,\t \n};\n\n#define PT1_NR_ADAPS 4\n\nstruct pt1_adapter;\n\nstruct pt1 {\n\tstruct pci_dev *pdev;\n\tvoid __iomem *regs;\n\tstruct i2c_adapter i2c_adap;\n\tint i2c_running;\n\tstruct pt1_adapter *adaps[PT1_NR_ADAPS];\n\tstruct pt1_table *tables;\n\tstruct task_struct *kthread;\n\tint table_index;\n\tint buf_index;\n\n\tstruct mutex lock;\n\tint power;\n\tint reset;\n\n\tenum pt1_fe_clk fe_clk;\n};\n\nstruct pt1_adapter {\n\tstruct pt1 *pt1;\n\tint index;\n\n\tu8 *buf;\n\tint upacket_count;\n\tint packet_count;\n\tint st_count;\n\n\tstruct dvb_adapter adap;\n\tstruct dvb_demux demux;\n\tint users;\n\tstruct dmxdev dmxdev;\n\tstruct dvb_frontend *fe;\n\tstruct i2c_client *demod_i2c_client;\n\tstruct i2c_client *tuner_i2c_client;\n\tint (*orig_set_voltage)(struct dvb_frontend *fe,\n\t\t\t\tenum fe_sec_voltage voltage);\n\tint (*orig_sleep)(struct dvb_frontend *fe);\n\tint (*orig_init)(struct dvb_frontend *fe);\n\n\tenum fe_sec_voltage voltage;\n\tint sleep;\n};\n\nunion pt1_tuner_config {\n\tstruct qm1d1b0004_config qm1d1b0004;\n\tstruct dvb_pll_config tda6651;\n};\n\nstruct pt1_config {\n\tstruct i2c_board_info demod_info;\n\tstruct tc90522_config demod_cfg;\n\n\tstruct i2c_board_info tuner_info;\n\tunion pt1_tuner_config tuner_cfg;\n};\n\nstatic const struct pt1_config pt1_configs[PT1_NR_ADAPS] = {\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_SAT, 0x1b),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"qm1d1b0004\", 0x60),\n\t\t},\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_TER, 0x1a),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"tda665x_earthpt1\", 0x61),\n\t\t},\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_SAT, 0x19),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"qm1d1b0004\", 0x60),\n\t\t},\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_TER, 0x18),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"tda665x_earthpt1\", 0x61),\n\t\t},\n\t},\n};\n\nstatic const u8 va1j5jf8007s_20mhz_configs[][2] = {\n\t{0x04, 0x02}, {0x0d, 0x55}, {0x11, 0x40}, {0x13, 0x80}, {0x17, 0x01},\n\t{0x1c, 0x0a}, {0x1d, 0xaa}, {0x1e, 0x20}, {0x1f, 0x88}, {0x51, 0xb0},\n\t{0x52, 0x89}, {0x53, 0xb3}, {0x5a, 0x2d}, {0x5b, 0xd3}, {0x85, 0x69},\n\t{0x87, 0x04}, {0x8e, 0x02}, {0xa3, 0xf7}, {0xa5, 0xc0},\n};\n\nstatic const u8 va1j5jf8007s_25mhz_configs[][2] = {\n\t{0x04, 0x02}, {0x11, 0x40}, {0x13, 0x80}, {0x17, 0x01}, {0x1c, 0x0a},\n\t{0x1d, 0xaa}, {0x1e, 0x20}, {0x1f, 0x88}, {0x51, 0xb0}, {0x52, 0x89},\n\t{0x53, 0xb3}, {0x5a, 0x2d}, {0x5b, 0xd3}, {0x85, 0x69}, {0x87, 0x04},\n\t{0x8e, 0x26}, {0xa3, 0xf7}, {0xa5, 0xc0},\n};\n\nstatic const u8 va1j5jf8007t_20mhz_configs[][2] = {\n\t{0x03, 0x90}, {0x14, 0x8f}, {0x1c, 0x2a}, {0x1d, 0xa8}, {0x1e, 0xa2},\n\t{0x22, 0x83}, {0x31, 0x0d}, {0x32, 0xe0}, {0x39, 0xd3}, {0x3a, 0x00},\n\t{0x3b, 0x11}, {0x3c, 0x3f},\n\t{0x5c, 0x40}, {0x5f, 0x80}, {0x75, 0x02}, {0x76, 0x4e}, {0x77, 0x03},\n\t{0xef, 0x01}\n};\n\nstatic const u8 va1j5jf8007t_25mhz_configs[][2] = {\n\t{0x03, 0x90}, {0x1c, 0x2a}, {0x1d, 0xa8}, {0x1e, 0xa2}, {0x22, 0x83},\n\t{0x3a, 0x04}, {0x3b, 0x11}, {0x3c, 0x3f}, {0x5c, 0x40}, {0x5f, 0x80},\n\t{0x75, 0x0a}, {0x76, 0x4c}, {0x77, 0x03}, {0xef, 0x01}\n};\n\nstatic int config_demod(struct i2c_client *cl, enum pt1_fe_clk clk)\n{\n\tint ret;\n\tbool is_sat;\n\tconst u8 (*cfg_data)[2];\n\tint i, len;\n\n\tis_sat = !strncmp(cl->name, TC90522_I2C_DEV_SAT,\n\t\t\t  strlen(TC90522_I2C_DEV_SAT));\n\tif (is_sat) {\n\t\tstruct i2c_msg msg[2];\n\t\tu8 wbuf, rbuf;\n\n\t\twbuf = 0x07;\n\t\tmsg[0].addr = cl->addr;\n\t\tmsg[0].flags = 0;\n\t\tmsg[0].len = 1;\n\t\tmsg[0].buf = &wbuf;\n\n\t\tmsg[1].addr = cl->addr;\n\t\tmsg[1].flags = I2C_M_RD;\n\t\tmsg[1].len = 1;\n\t\tmsg[1].buf = &rbuf;\n\t\tret = i2c_transfer(cl->adapter, msg, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (rbuf != 0x41)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tif (clk == PT1_FE_CLK_20MHZ) {\n\t\tif (is_sat) {\n\t\t\tcfg_data = va1j5jf8007s_20mhz_configs;\n\t\t\tlen = ARRAY_SIZE(va1j5jf8007s_20mhz_configs);\n\t\t} else {\n\t\t\tcfg_data = va1j5jf8007t_20mhz_configs;\n\t\t\tlen = ARRAY_SIZE(va1j5jf8007t_20mhz_configs);\n\t\t}\n\t} else {\n\t\tif (is_sat) {\n\t\t\tcfg_data = va1j5jf8007s_25mhz_configs;\n\t\t\tlen = ARRAY_SIZE(va1j5jf8007s_25mhz_configs);\n\t\t} else {\n\t\t\tcfg_data = va1j5jf8007t_25mhz_configs;\n\t\t\tlen = ARRAY_SIZE(va1j5jf8007t_25mhz_configs);\n\t\t}\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = i2c_master_send(cl, cfg_data[i], 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int pt1_demod_block_init(struct pt1 *pt1)\n{\n\tstruct i2c_client *cl;\n\tu8 buf[2] = {0x01, 0x80};\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < PT1_NR_ADAPS; i++) {\n\t\tcl = pt1->adaps[i]->demod_i2c_client;\n\t\tif (strncmp(cl->name, TC90522_I2C_DEV_TER,\n\t\t\t    strlen(TC90522_I2C_DEV_TER)))\n\t\t\tcontinue;\n\n\t\tret = i2c_master_send(cl, buf, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tusleep_range(30000, 50000);\n\t}\n\n\tfor (i = 0; i < PT1_NR_ADAPS; i++) {\n\t\tcl = pt1->adaps[i]->demod_i2c_client;\n\t\tif (strncmp(cl->name, TC90522_I2C_DEV_SAT,\n\t\t\t    strlen(TC90522_I2C_DEV_SAT)))\n\t\t\tcontinue;\n\n\t\tret = i2c_master_send(cl, buf, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tusleep_range(30000, 50000);\n\t}\n\treturn 0;\n}\n\nstatic void pt1_write_reg(struct pt1 *pt1, int reg, u32 data)\n{\n\twritel(data, pt1->regs + reg * 4);\n}\n\nstatic u32 pt1_read_reg(struct pt1 *pt1, int reg)\n{\n\treturn readl(pt1->regs + reg * 4);\n}\n\nstatic unsigned int pt1_nr_tables = 8;\nmodule_param_named(nr_tables, pt1_nr_tables, uint, 0);\n\nstatic void pt1_increment_table_count(struct pt1 *pt1)\n{\n\tpt1_write_reg(pt1, 0, 0x00000020);\n}\n\nstatic void pt1_init_table_count(struct pt1 *pt1)\n{\n\tpt1_write_reg(pt1, 0, 0x00000010);\n}\n\nstatic void pt1_register_tables(struct pt1 *pt1, u32 first_pfn)\n{\n\tpt1_write_reg(pt1, 5, first_pfn);\n\tpt1_write_reg(pt1, 0, 0x0c000040);\n}\n\nstatic void pt1_unregister_tables(struct pt1 *pt1)\n{\n\tpt1_write_reg(pt1, 0, 0x08080000);\n}\n\nstatic int pt1_sync(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < 57; i++) {\n\t\tif (pt1_read_reg(pt1, 0) & 0x20000000)\n\t\t\treturn 0;\n\t\tpt1_write_reg(pt1, 0, 0x00000008);\n\t}\n\tdev_err(&pt1->pdev->dev, \"could not sync\\n\");\n\treturn -EIO;\n}\n\nstatic u64 pt1_identify(struct pt1 *pt1)\n{\n\tint i;\n\tu64 id = 0;\n\tfor (i = 0; i < 57; i++) {\n\t\tid |= (u64)(pt1_read_reg(pt1, 0) >> 30 & 1) << i;\n\t\tpt1_write_reg(pt1, 0, 0x00000008);\n\t}\n\treturn id;\n}\n\nstatic int pt1_unlock(struct pt1 *pt1)\n{\n\tint i;\n\tpt1_write_reg(pt1, 0, 0x00000008);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (pt1_read_reg(pt1, 0) & 0x80000000)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\tdev_err(&pt1->pdev->dev, \"could not unlock\\n\");\n\treturn -EIO;\n}\n\nstatic int pt1_reset_pci(struct pt1 *pt1)\n{\n\tint i;\n\tpt1_write_reg(pt1, 0, 0x01010000);\n\tpt1_write_reg(pt1, 0, 0x01000000);\n\tfor (i = 0; i < 10; i++) {\n\t\tif (pt1_read_reg(pt1, 0) & 0x00000001)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\tdev_err(&pt1->pdev->dev, \"could not reset PCI\\n\");\n\treturn -EIO;\n}\n\nstatic int pt1_reset_ram(struct pt1 *pt1)\n{\n\tint i;\n\tpt1_write_reg(pt1, 0, 0x02020000);\n\tpt1_write_reg(pt1, 0, 0x02000000);\n\tfor (i = 0; i < 10; i++) {\n\t\tif (pt1_read_reg(pt1, 0) & 0x00000002)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\tdev_err(&pt1->pdev->dev, \"could not reset RAM\\n\");\n\treturn -EIO;\n}\n\nstatic int pt1_do_enable_ram(struct pt1 *pt1)\n{\n\tint i, j;\n\tu32 status;\n\tstatus = pt1_read_reg(pt1, 0) & 0x00000004;\n\tpt1_write_reg(pt1, 0, 0x00000002);\n\tfor (i = 0; i < 10; i++) {\n\t\tfor (j = 0; j < 1024; j++) {\n\t\t\tif ((pt1_read_reg(pt1, 0) & 0x00000004) != status)\n\t\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\tdev_err(&pt1->pdev->dev, \"could not enable RAM\\n\");\n\treturn -EIO;\n}\n\nstatic int pt1_enable_ram(struct pt1 *pt1)\n{\n\tint i, ret;\n\tint phase;\n\tusleep_range(1000, 2000);\n\tphase = pt1->pdev->device == 0x211a ? 128 : 166;\n\tfor (i = 0; i < phase; i++) {\n\t\tret = pt1_do_enable_ram(pt1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void pt1_disable_ram(struct pt1 *pt1)\n{\n\tpt1_write_reg(pt1, 0, 0x0b0b0000);\n}\n\nstatic void pt1_set_stream(struct pt1 *pt1, int index, int enabled)\n{\n\tpt1_write_reg(pt1, 2, 1 << (index + 8) | enabled << index);\n}\n\nstatic void pt1_init_streams(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < PT1_NR_ADAPS; i++)\n\t\tpt1_set_stream(pt1, i, 0);\n}\n\nstatic int pt1_filter(struct pt1 *pt1, struct pt1_buffer_page *page)\n{\n\tu32 upacket;\n\tint i;\n\tint index;\n\tstruct pt1_adapter *adap;\n\tint offset;\n\tu8 *buf;\n\tint sc;\n\n\tif (!page->upackets[PT1_NR_UPACKETS - 1])\n\t\treturn 0;\n\n\tfor (i = 0; i < PT1_NR_UPACKETS; i++) {\n\t\tupacket = le32_to_cpu(page->upackets[i]);\n\t\tindex = (upacket >> 29) - 1;\n\t\tif (index < 0 || index >=  PT1_NR_ADAPS)\n\t\t\tcontinue;\n\n\t\tadap = pt1->adaps[index];\n\t\tif (upacket >> 25 & 1)\n\t\t\tadap->upacket_count = 0;\n\t\telse if (!adap->upacket_count)\n\t\t\tcontinue;\n\n\t\tif (upacket >> 24 & 1)\n\t\t\tprintk_ratelimited(KERN_INFO \"earth-pt1: device buffer overflowing. table[%d] buf[%d]\\n\",\n\t\t\t\tpt1->table_index, pt1->buf_index);\n\t\tsc = upacket >> 26 & 0x7;\n\t\tif (adap->st_count != -1 && sc != ((adap->st_count + 1) & 0x7))\n\t\t\tprintk_ratelimited(KERN_INFO \"earth-pt1: data loss in streamID(adapter)[%d]\\n\",\n\t\t\t\t\t   index);\n\t\tadap->st_count = sc;\n\n\t\tbuf = adap->buf;\n\t\toffset = adap->packet_count * 188 + adap->upacket_count * 3;\n\t\tbuf[offset] = upacket >> 16;\n\t\tbuf[offset + 1] = upacket >> 8;\n\t\tif (adap->upacket_count != 62)\n\t\t\tbuf[offset + 2] = upacket;\n\n\t\tif (++adap->upacket_count >= 63) {\n\t\t\tadap->upacket_count = 0;\n\t\t\tif (++adap->packet_count >= 21) {\n\t\t\t\tdvb_dmx_swfilter_packets(&adap->demux, buf, 21);\n\t\t\t\tadap->packet_count = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpage->upackets[PT1_NR_UPACKETS - 1] = 0;\n\treturn 1;\n}\n\nstatic int pt1_thread(void *data)\n{\n\tstruct pt1 *pt1;\n\tstruct pt1_buffer_page *page;\n\tbool was_frozen;\n\n#define PT1_FETCH_DELAY 10\n#define PT1_FETCH_DELAY_DELTA 2\n\n\tpt1 = data;\n\tset_freezable();\n\n\twhile (!kthread_freezable_should_stop(&was_frozen)) {\n\t\tif (was_frozen) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < PT1_NR_ADAPS; i++)\n\t\t\t\tpt1_set_stream(pt1, i, !!pt1->adaps[i]->users);\n\t\t}\n\n\t\tpage = pt1->tables[pt1->table_index].bufs[pt1->buf_index].page;\n\t\tif (!pt1_filter(pt1, page)) {\n\t\t\tktime_t delay;\n\n\t\t\tdelay = ktime_set(0, PT1_FETCH_DELAY * NSEC_PER_MSEC);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_hrtimeout_range(&delay,\n\t\t\t\t\tPT1_FETCH_DELAY_DELTA * NSEC_PER_MSEC,\n\t\t\t\t\tHRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++pt1->buf_index >= PT1_NR_BUFS) {\n\t\t\tpt1_increment_table_count(pt1);\n\t\t\tpt1->buf_index = 0;\n\t\t\tif (++pt1->table_index >= pt1_nr_tables)\n\t\t\t\tpt1->table_index = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pt1_free_page(struct pt1 *pt1, void *page, dma_addr_t addr)\n{\n\tdma_free_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, page, addr);\n}\n\nstatic void *pt1_alloc_page(struct pt1 *pt1, dma_addr_t *addrp, u32 *pfnp)\n{\n\tvoid *page;\n\tdma_addr_t addr;\n\n\tpage = dma_alloc_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, &addr,\n\t\t\t\t  GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn NULL;\n\n\tBUG_ON(addr & (PT1_PAGE_SIZE - 1));\n\tBUG_ON(addr >> PT1_PAGE_SHIFT >> 31 >> 1);\n\n\t*addrp = addr;\n\t*pfnp = addr >> PT1_PAGE_SHIFT;\n\treturn page;\n}\n\nstatic void pt1_cleanup_buffer(struct pt1 *pt1, struct pt1_buffer *buf)\n{\n\tpt1_free_page(pt1, buf->page, buf->addr);\n}\n\nstatic int\npt1_init_buffer(struct pt1 *pt1, struct pt1_buffer *buf,  u32 *pfnp)\n{\n\tstruct pt1_buffer_page *page;\n\tdma_addr_t addr;\n\n\tpage = pt1_alloc_page(pt1, &addr, pfnp);\n\tif (page == NULL)\n\t\treturn -ENOMEM;\n\n\tpage->upackets[PT1_NR_UPACKETS - 1] = 0;\n\n\tbuf->page = page;\n\tbuf->addr = addr;\n\treturn 0;\n}\n\nstatic void pt1_cleanup_table(struct pt1 *pt1, struct pt1_table *table)\n{\n\tint i;\n\n\tfor (i = 0; i < PT1_NR_BUFS; i++)\n\t\tpt1_cleanup_buffer(pt1, &table->bufs[i]);\n\n\tpt1_free_page(pt1, table->page, table->addr);\n}\n\nstatic int\npt1_init_table(struct pt1 *pt1, struct pt1_table *table, u32 *pfnp)\n{\n\tstruct pt1_table_page *page;\n\tdma_addr_t addr;\n\tint i, ret;\n\tu32 buf_pfn;\n\n\tpage = pt1_alloc_page(pt1, &addr, pfnp);\n\tif (page == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PT1_NR_BUFS; i++) {\n\t\tret = pt1_init_buffer(pt1, &table->bufs[i], &buf_pfn);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tpage->buf_pfns[i] = cpu_to_le32(buf_pfn);\n\t}\n\n\tpt1_increment_table_count(pt1);\n\ttable->page = page;\n\ttable->addr = addr;\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tpt1_cleanup_buffer(pt1, &table->bufs[i]);\n\n\tpt1_free_page(pt1, page, addr);\n\treturn ret;\n}\n\nstatic void pt1_cleanup_tables(struct pt1 *pt1)\n{\n\tstruct pt1_table *tables;\n\tint i;\n\n\ttables = pt1->tables;\n\tpt1_unregister_tables(pt1);\n\n\tfor (i = 0; i < pt1_nr_tables; i++)\n\t\tpt1_cleanup_table(pt1, &tables[i]);\n\n\tvfree(tables);\n}\n\nstatic int pt1_init_tables(struct pt1 *pt1)\n{\n\tstruct pt1_table *tables;\n\tint i, ret;\n\tu32 first_pfn, pfn;\n\n\tif (!pt1_nr_tables)\n\t\treturn 0;\n\n\ttables = vmalloc(array_size(pt1_nr_tables, sizeof(struct pt1_table)));\n\tif (tables == NULL)\n\t\treturn -ENOMEM;\n\n\tpt1_init_table_count(pt1);\n\n\ti = 0;\n\tret = pt1_init_table(pt1, &tables[0], &first_pfn);\n\tif (ret)\n\t\tgoto err;\n\ti++;\n\n\twhile (i < pt1_nr_tables) {\n\t\tret = pt1_init_table(pt1, &tables[i], &pfn);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\ttables[i - 1].page->next_pfn = cpu_to_le32(pfn);\n\t\ti++;\n\t}\n\n\ttables[pt1_nr_tables - 1].page->next_pfn = cpu_to_le32(first_pfn);\n\n\tpt1_register_tables(pt1, first_pfn);\n\tpt1->tables = tables;\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tpt1_cleanup_table(pt1, &tables[i]);\n\n\tvfree(tables);\n\treturn ret;\n}\n\nstatic int pt1_start_polling(struct pt1 *pt1)\n{\n\tint ret = 0;\n\n\tmutex_lock(&pt1->lock);\n\tif (!pt1->kthread) {\n\t\tpt1->kthread = kthread_run(pt1_thread, pt1, \"earth-pt1\");\n\t\tif (IS_ERR(pt1->kthread)) {\n\t\t\tret = PTR_ERR(pt1->kthread);\n\t\t\tpt1->kthread = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&pt1->lock);\n\treturn ret;\n}\n\nstatic int pt1_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct pt1_adapter *adap;\n\tadap = container_of(feed->demux, struct pt1_adapter, demux);\n\tif (!adap->users++) {\n\t\tint ret;\n\n\t\tret = pt1_start_polling(adap->pt1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpt1_set_stream(adap->pt1, adap->index, 1);\n\t}\n\treturn 0;\n}\n\nstatic void pt1_stop_polling(struct pt1 *pt1)\n{\n\tint i, count;\n\n\tmutex_lock(&pt1->lock);\n\tfor (i = 0, count = 0; i < PT1_NR_ADAPS; i++)\n\t\tcount += pt1->adaps[i]->users;\n\n\tif (count == 0 && pt1->kthread) {\n\t\tkthread_stop(pt1->kthread);\n\t\tpt1->kthread = NULL;\n\t}\n\tmutex_unlock(&pt1->lock);\n}\n\nstatic int pt1_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct pt1_adapter *adap;\n\tadap = container_of(feed->demux, struct pt1_adapter, demux);\n\tif (!--adap->users) {\n\t\tpt1_set_stream(adap->pt1, adap->index, 0);\n\t\tpt1_stop_polling(adap->pt1);\n\t}\n\treturn 0;\n}\n\nstatic void\npt1_update_power(struct pt1 *pt1)\n{\n\tint bits;\n\tint i;\n\tstruct pt1_adapter *adap;\n\tstatic const int sleep_bits[] = {\n\t\t1 << 4,\n\t\t1 << 6 | 1 << 7,\n\t\t1 << 5,\n\t\t1 << 6 | 1 << 8,\n\t};\n\n\tbits = pt1->power | !pt1->reset << 3;\n\tmutex_lock(&pt1->lock);\n\tfor (i = 0; i < PT1_NR_ADAPS; i++) {\n\t\tadap = pt1->adaps[i];\n\t\tswitch (adap->voltage) {\n\t\tcase SEC_VOLTAGE_13:  \n\t\t\tbits |= 1 << 2;\n\t\t\tbreak;\n\t\tcase SEC_VOLTAGE_18:  \n\t\t\tbits |= 1 << 1 | 1 << 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbits |= sleep_bits[i];\n\t}\n\tpt1_write_reg(pt1, 1, bits);\n\tmutex_unlock(&pt1->lock);\n}\n\nstatic int pt1_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage voltage)\n{\n\tstruct pt1_adapter *adap;\n\n\tadap = container_of(fe->dvb, struct pt1_adapter, adap);\n\tadap->voltage = voltage;\n\tpt1_update_power(adap->pt1);\n\n\tif (adap->orig_set_voltage)\n\t\treturn adap->orig_set_voltage(fe, voltage);\n\telse\n\t\treturn 0;\n}\n\nstatic int pt1_sleep(struct dvb_frontend *fe)\n{\n\tstruct pt1_adapter *adap;\n\tint ret;\n\n\tadap = container_of(fe->dvb, struct pt1_adapter, adap);\n\n\tret = 0;\n\tif (adap->orig_sleep)\n\t\tret = adap->orig_sleep(fe);\n\n\tadap->sleep = 1;\n\tpt1_update_power(adap->pt1);\n\treturn ret;\n}\n\nstatic int pt1_wakeup(struct dvb_frontend *fe)\n{\n\tstruct pt1_adapter *adap;\n\tint ret;\n\n\tadap = container_of(fe->dvb, struct pt1_adapter, adap);\n\tadap->sleep = 0;\n\tpt1_update_power(adap->pt1);\n\tusleep_range(1000, 2000);\n\n\tret = config_demod(adap->demod_i2c_client, adap->pt1->fe_clk);\n\tif (ret == 0 && adap->orig_init)\n\t\tret = adap->orig_init(fe);\n\treturn ret;\n}\n\nstatic void pt1_free_adapter(struct pt1_adapter *adap)\n{\n\tadap->demux.dmx.close(&adap->demux.dmx);\n\tdvb_dmxdev_release(&adap->dmxdev);\n\tdvb_dmx_release(&adap->demux);\n\tdvb_unregister_adapter(&adap->adap);\n\tfree_page((unsigned long)adap->buf);\n\tkfree(adap);\n}\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic struct pt1_adapter *\npt1_alloc_adapter(struct pt1 *pt1)\n{\n\tstruct pt1_adapter *adap;\n\tvoid *buf;\n\tstruct dvb_adapter *dvb_adap;\n\tstruct dvb_demux *demux;\n\tstruct dmxdev *dmxdev;\n\tint ret;\n\n\tadap = kzalloc(sizeof(struct pt1_adapter), GFP_KERNEL);\n\tif (!adap) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tadap->pt1 = pt1;\n\n\tadap->voltage = SEC_VOLTAGE_OFF;\n\tadap->sleep = 1;\n\n\tbuf = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\n\tadap->buf = buf;\n\tadap->upacket_count = 0;\n\tadap->packet_count = 0;\n\tadap->st_count = -1;\n\n\tdvb_adap = &adap->adap;\n\tdvb_adap->priv = adap;\n\tret = dvb_register_adapter(dvb_adap, DRIVER_NAME, THIS_MODULE,\n\t\t\t\t   &pt1->pdev->dev, adapter_nr);\n\tif (ret < 0)\n\t\tgoto err_free_page;\n\n\tdemux = &adap->demux;\n\tdemux->dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tdemux->priv = adap;\n\tdemux->feednum = 256;\n\tdemux->filternum = 256;\n\tdemux->start_feed = pt1_start_feed;\n\tdemux->stop_feed = pt1_stop_feed;\n\tdemux->write_to_decoder = NULL;\n\tret = dvb_dmx_init(demux);\n\tif (ret < 0)\n\t\tgoto err_unregister_adapter;\n\n\tdmxdev = &adap->dmxdev;\n\tdmxdev->filternum = 256;\n\tdmxdev->demux = &demux->dmx;\n\tdmxdev->capabilities = 0;\n\tret = dvb_dmxdev_init(dmxdev, dvb_adap);\n\tif (ret < 0)\n\t\tgoto err_dmx_release;\n\n\treturn adap;\n\nerr_dmx_release:\n\tdvb_dmx_release(demux);\nerr_unregister_adapter:\n\tdvb_unregister_adapter(dvb_adap);\nerr_free_page:\n\tfree_page((unsigned long)buf);\nerr_kfree:\n\tkfree(adap);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic void pt1_cleanup_adapters(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < PT1_NR_ADAPS; i++)\n\t\tpt1_free_adapter(pt1->adaps[i]);\n}\n\nstatic int pt1_init_adapters(struct pt1 *pt1)\n{\n\tint i;\n\tstruct pt1_adapter *adap;\n\tint ret;\n\n\tfor (i = 0; i < PT1_NR_ADAPS; i++) {\n\t\tadap = pt1_alloc_adapter(pt1);\n\t\tif (IS_ERR(adap)) {\n\t\t\tret = PTR_ERR(adap);\n\t\t\tgoto err;\n\t\t}\n\n\t\tadap->index = i;\n\t\tpt1->adaps[i] = adap;\n\t}\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tpt1_free_adapter(pt1->adaps[i]);\n\n\treturn ret;\n}\n\nstatic void pt1_cleanup_frontend(struct pt1_adapter *adap)\n{\n\tdvb_unregister_frontend(adap->fe);\n\tdvb_module_release(adap->tuner_i2c_client);\n\tdvb_module_release(adap->demod_i2c_client);\n}\n\nstatic int pt1_init_frontend(struct pt1_adapter *adap, struct dvb_frontend *fe)\n{\n\tint ret;\n\n\tadap->orig_set_voltage = fe->ops.set_voltage;\n\tadap->orig_sleep = fe->ops.sleep;\n\tadap->orig_init = fe->ops.init;\n\tfe->ops.set_voltage = pt1_set_voltage;\n\tfe->ops.sleep = pt1_sleep;\n\tfe->ops.init = pt1_wakeup;\n\n\tret = dvb_register_frontend(&adap->adap, fe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadap->fe = fe;\n\treturn 0;\n}\n\nstatic void pt1_cleanup_frontends(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < PT1_NR_ADAPS; i++)\n\t\tpt1_cleanup_frontend(pt1->adaps[i]);\n}\n\nstatic int pt1_init_frontends(struct pt1 *pt1)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(pt1_configs); i++) {\n\t\tconst struct i2c_board_info *info;\n\t\tstruct tc90522_config dcfg;\n\t\tstruct i2c_client *cl;\n\n\t\tinfo = &pt1_configs[i].demod_info;\n\t\tdcfg = pt1_configs[i].demod_cfg;\n\t\tdcfg.tuner_i2c = NULL;\n\n\t\tret = -ENODEV;\n\t\tcl = dvb_module_probe(\"tc90522\", info->type, &pt1->i2c_adap,\n\t\t\t\t      info->addr, &dcfg);\n\t\tif (!cl)\n\t\t\tgoto fe_unregister;\n\t\tpt1->adaps[i]->demod_i2c_client = cl;\n\n\t\tif (!strncmp(cl->name, TC90522_I2C_DEV_SAT,\n\t\t\t     strlen(TC90522_I2C_DEV_SAT))) {\n\t\t\tstruct qm1d1b0004_config tcfg;\n\n\t\t\tinfo = &pt1_configs[i].tuner_info;\n\t\t\ttcfg = pt1_configs[i].tuner_cfg.qm1d1b0004;\n\t\t\ttcfg.fe = dcfg.fe;\n\t\t\tcl = dvb_module_probe(\"qm1d1b0004\",\n\t\t\t\t\t      info->type, dcfg.tuner_i2c,\n\t\t\t\t\t      info->addr, &tcfg);\n\t\t} else {\n\t\t\tstruct dvb_pll_config tcfg;\n\n\t\t\tinfo = &pt1_configs[i].tuner_info;\n\t\t\ttcfg = pt1_configs[i].tuner_cfg.tda6651;\n\t\t\ttcfg.fe = dcfg.fe;\n\t\t\tcl = dvb_module_probe(\"dvb_pll\",\n\t\t\t\t\t      info->type, dcfg.tuner_i2c,\n\t\t\t\t\t      info->addr, &tcfg);\n\t\t}\n\t\tif (!cl)\n\t\t\tgoto demod_release;\n\t\tpt1->adaps[i]->tuner_i2c_client = cl;\n\n\t\tret = pt1_init_frontend(pt1->adaps[i], dcfg.fe);\n\t\tif (ret < 0)\n\t\t\tgoto tuner_release;\n\t}\n\n\tret = pt1_demod_block_init(pt1);\n\tif (ret < 0)\n\t\tgoto fe_unregister;\n\n\treturn 0;\n\ntuner_release:\n\tdvb_module_release(pt1->adaps[i]->tuner_i2c_client);\ndemod_release:\n\tdvb_module_release(pt1->adaps[i]->demod_i2c_client);\nfe_unregister:\n\tdev_warn(&pt1->pdev->dev, \"failed to init FE(%d).\\n\", i);\n\ti--;\n\tfor (; i >= 0; i--) {\n\t\tdvb_unregister_frontend(pt1->adaps[i]->fe);\n\t\tdvb_module_release(pt1->adaps[i]->tuner_i2c_client);\n\t\tdvb_module_release(pt1->adaps[i]->demod_i2c_client);\n\t}\n\treturn ret;\n}\n\nstatic void pt1_i2c_emit(struct pt1 *pt1, int addr, int busy, int read_enable,\n\t\t\t int clock, int data, int next_addr)\n{\n\tpt1_write_reg(pt1, 4, addr << 18 | busy << 13 | read_enable << 12 |\n\t\t      !clock << 11 | !data << 10 | next_addr);\n}\n\nstatic void pt1_i2c_write_bit(struct pt1 *pt1, int addr, int *addrp, int data)\n{\n\tpt1_i2c_emit(pt1, addr,     1, 0, 0, data, addr + 1);\n\tpt1_i2c_emit(pt1, addr + 1, 1, 0, 1, data, addr + 2);\n\tpt1_i2c_emit(pt1, addr + 2, 1, 0, 0, data, addr + 3);\n\t*addrp = addr + 3;\n}\n\nstatic void pt1_i2c_read_bit(struct pt1 *pt1, int addr, int *addrp)\n{\n\tpt1_i2c_emit(pt1, addr,     1, 0, 0, 1, addr + 1);\n\tpt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 1, addr + 2);\n\tpt1_i2c_emit(pt1, addr + 2, 1, 1, 1, 1, addr + 3);\n\tpt1_i2c_emit(pt1, addr + 3, 1, 0, 0, 1, addr + 4);\n\t*addrp = addr + 4;\n}\n\nstatic void pt1_i2c_write_byte(struct pt1 *pt1, int addr, int *addrp, int data)\n{\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tpt1_i2c_write_bit(pt1, addr, &addr, data >> (7 - i) & 1);\n\tpt1_i2c_write_bit(pt1, addr, &addr, 1);\n\t*addrp = addr;\n}\n\nstatic void pt1_i2c_read_byte(struct pt1 *pt1, int addr, int *addrp, int last)\n{\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tpt1_i2c_read_bit(pt1, addr, &addr);\n\tpt1_i2c_write_bit(pt1, addr, &addr, last);\n\t*addrp = addr;\n}\n\nstatic void pt1_i2c_prepare(struct pt1 *pt1, int addr, int *addrp)\n{\n\tpt1_i2c_emit(pt1, addr,     1, 0, 1, 1, addr + 1);\n\tpt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\n\tpt1_i2c_emit(pt1, addr + 2, 1, 0, 0, 0, addr + 3);\n\t*addrp = addr + 3;\n}\n\nstatic void\npt1_i2c_write_msg(struct pt1 *pt1, int addr, int *addrp, struct i2c_msg *msg)\n{\n\tint i;\n\tpt1_i2c_prepare(pt1, addr, &addr);\n\tpt1_i2c_write_byte(pt1, addr, &addr, msg->addr << 1);\n\tfor (i = 0; i < msg->len; i++)\n\t\tpt1_i2c_write_byte(pt1, addr, &addr, msg->buf[i]);\n\t*addrp = addr;\n}\n\nstatic void\npt1_i2c_read_msg(struct pt1 *pt1, int addr, int *addrp, struct i2c_msg *msg)\n{\n\tint i;\n\tpt1_i2c_prepare(pt1, addr, &addr);\n\tpt1_i2c_write_byte(pt1, addr, &addr, msg->addr << 1 | 1);\n\tfor (i = 0; i < msg->len; i++)\n\t\tpt1_i2c_read_byte(pt1, addr, &addr, i == msg->len - 1);\n\t*addrp = addr;\n}\n\nstatic int pt1_i2c_end(struct pt1 *pt1, int addr)\n{\n\tpt1_i2c_emit(pt1, addr,     1, 0, 0, 0, addr + 1);\n\tpt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\n\tpt1_i2c_emit(pt1, addr + 2, 1, 0, 1, 1, 0);\n\n\tpt1_write_reg(pt1, 0, 0x00000004);\n\tdo {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tusleep_range(1000, 2000);\n\t} while (pt1_read_reg(pt1, 0) & 0x00000080);\n\treturn 0;\n}\n\nstatic void pt1_i2c_begin(struct pt1 *pt1, int *addrp)\n{\n\tint addr = 0;\n\n\tpt1_i2c_emit(pt1, addr,     0, 0, 1, 1, addr  );\n\taddr = addr + 1;\n\n\tif (!pt1->i2c_running) {\n\t\tpt1_i2c_emit(pt1, addr,     1, 0, 1, 1, addr + 1);\n\t\tpt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\n\t\taddr = addr + 2;\n\t\tpt1->i2c_running = 1;\n\t}\n\t*addrp = addr;\n}\n\nstatic int pt1_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct pt1 *pt1;\n\tint i;\n\tstruct i2c_msg *msg, *next_msg;\n\tint addr, ret;\n\tu16 len;\n\tu32 word;\n\n\tpt1 = i2c_get_adapdata(adap);\n\n\tfor (i = 0; i < num; i++) {\n\t\tmsg = &msgs[i];\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (i + 1 < num)\n\t\t\tnext_msg = &msgs[i + 1];\n\t\telse\n\t\t\tnext_msg = NULL;\n\n\t\tif (next_msg && next_msg->flags & I2C_M_RD) {\n\t\t\ti++;\n\n\t\t\tlen = next_msg->len;\n\t\t\tif (len > 4)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tpt1_i2c_begin(pt1, &addr);\n\t\t\tpt1_i2c_write_msg(pt1, addr, &addr, msg);\n\t\t\tpt1_i2c_read_msg(pt1, addr, &addr, next_msg);\n\t\t\tret = pt1_i2c_end(pt1, addr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tword = pt1_read_reg(pt1, 2);\n\t\t\twhile (len--) {\n\t\t\t\tnext_msg->buf[len] = word;\n\t\t\t\tword >>= 8;\n\t\t\t}\n\t\t} else {\n\t\t\tpt1_i2c_begin(pt1, &addr);\n\t\t\tpt1_i2c_write_msg(pt1, addr, &addr, msg);\n\t\t\tret = pt1_i2c_end(pt1, addr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn num;\n}\n\nstatic u32 pt1_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm pt1_i2c_algo = {\n\t.master_xfer = pt1_i2c_xfer,\n\t.functionality = pt1_i2c_func,\n};\n\nstatic void pt1_i2c_wait(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < 128; i++)\n\t\tpt1_i2c_emit(pt1, 0, 0, 0, 1, 1, 0);\n}\n\nstatic void pt1_i2c_init(struct pt1 *pt1)\n{\n\tint i;\n\tfor (i = 0; i < 1024; i++)\n\t\tpt1_i2c_emit(pt1, i, 0, 0, 1, 1, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int pt1_suspend(struct device *dev)\n{\n\tstruct pt1 *pt1 = dev_get_drvdata(dev);\n\n\tpt1_init_streams(pt1);\n\tpt1_disable_ram(pt1);\n\tpt1->power = 0;\n\tpt1->reset = 1;\n\tpt1_update_power(pt1);\n\treturn 0;\n}\n\nstatic int pt1_resume(struct device *dev)\n{\n\tstruct pt1 *pt1 = dev_get_drvdata(dev);\n\tint ret;\n\tint i;\n\n\tpt1->power = 0;\n\tpt1->reset = 1;\n\tpt1_update_power(pt1);\n\n\tpt1_i2c_init(pt1);\n\tpt1_i2c_wait(pt1);\n\n\tret = pt1_sync(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tpt1_identify(pt1);\n\n\tret = pt1_unlock(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tret = pt1_reset_pci(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tret = pt1_reset_ram(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tret = pt1_enable_ram(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tpt1_init_streams(pt1);\n\n\tpt1->power = 1;\n\tpt1_update_power(pt1);\n\tmsleep(20);\n\n\tpt1->reset = 0;\n\tpt1_update_power(pt1);\n\tusleep_range(1000, 2000);\n\n\tret = pt1_demod_block_init(pt1);\n\tif (ret < 0)\n\t\tgoto resume_err;\n\n\tfor (i = 0; i < PT1_NR_ADAPS; i++)\n\t\tdvb_frontend_reinitialise(pt1->adaps[i]->fe);\n\n\tpt1_init_table_count(pt1);\n\tfor (i = 0; i < pt1_nr_tables; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < PT1_NR_BUFS; j++)\n\t\t\tpt1->tables[i].bufs[j].page->upackets[PT1_NR_UPACKETS-1]\n\t\t\t\t= 0;\n\t\tpt1_increment_table_count(pt1);\n\t}\n\tpt1_register_tables(pt1, pt1->tables[0].addr >> PT1_PAGE_SHIFT);\n\n\tpt1->table_index = 0;\n\tpt1->buf_index = 0;\n\tfor (i = 0; i < PT1_NR_ADAPS; i++) {\n\t\tpt1->adaps[i]->upacket_count = 0;\n\t\tpt1->adaps[i]->packet_count = 0;\n\t\tpt1->adaps[i]->st_count = -1;\n\t}\n\n\treturn 0;\n\nresume_err:\n\tdev_info(&pt1->pdev->dev, \"failed to resume PT1/PT2.\");\n\treturn 0;\t \n}\n\n#endif  \n\nstatic void pt1_remove(struct pci_dev *pdev)\n{\n\tstruct pt1 *pt1;\n\tvoid __iomem *regs;\n\n\tpt1 = pci_get_drvdata(pdev);\n\tregs = pt1->regs;\n\n\tif (pt1->kthread)\n\t\tkthread_stop(pt1->kthread);\n\tpt1_cleanup_tables(pt1);\n\tpt1_cleanup_frontends(pt1);\n\tpt1_disable_ram(pt1);\n\tpt1->power = 0;\n\tpt1->reset = 1;\n\tpt1_update_power(pt1);\n\tpt1_cleanup_adapters(pt1);\n\ti2c_del_adapter(&pt1->i2c_adap);\n\tkfree(pt1);\n\tpci_iounmap(pdev, regs);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic int pt1_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint ret;\n\tvoid __iomem *regs;\n\tstruct pt1 *pt1;\n\tstruct i2c_adapter *i2c_adap;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tregs = pci_iomap(pdev, 0, 0);\n\tif (!regs) {\n\t\tret = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tpt1 = kzalloc(sizeof(struct pt1), GFP_KERNEL);\n\tif (!pt1) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_iounmap;\n\t}\n\n\tmutex_init(&pt1->lock);\n\tpt1->pdev = pdev;\n\tpt1->regs = regs;\n\tpt1->fe_clk = (pdev->device == 0x211a) ?\n\t\t\t\tPT1_FE_CLK_20MHZ : PT1_FE_CLK_25MHZ;\n\tpci_set_drvdata(pdev, pt1);\n\n\tret = pt1_init_adapters(pt1);\n\tif (ret < 0)\n\t\tgoto err_kfree;\n\n\tmutex_init(&pt1->lock);\n\n\tpt1->power = 0;\n\tpt1->reset = 1;\n\tpt1_update_power(pt1);\n\n\ti2c_adap = &pt1->i2c_adap;\n\ti2c_adap->algo = &pt1_i2c_algo;\n\ti2c_adap->algo_data = NULL;\n\ti2c_adap->dev.parent = &pdev->dev;\n\tstrscpy(i2c_adap->name, DRIVER_NAME, sizeof(i2c_adap->name));\n\ti2c_set_adapdata(i2c_adap, pt1);\n\tret = i2c_add_adapter(i2c_adap);\n\tif (ret < 0)\n\t\tgoto err_pt1_cleanup_adapters;\n\n\tpt1_i2c_init(pt1);\n\tpt1_i2c_wait(pt1);\n\n\tret = pt1_sync(pt1);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tpt1_identify(pt1);\n\n\tret = pt1_unlock(pt1);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tret = pt1_reset_pci(pt1);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tret = pt1_reset_ram(pt1);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tret = pt1_enable_ram(pt1);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tpt1_init_streams(pt1);\n\n\tpt1->power = 1;\n\tpt1_update_power(pt1);\n\tmsleep(20);\n\n\tpt1->reset = 0;\n\tpt1_update_power(pt1);\n\tusleep_range(1000, 2000);\n\n\tret = pt1_init_frontends(pt1);\n\tif (ret < 0)\n\t\tgoto err_pt1_disable_ram;\n\n\tret = pt1_init_tables(pt1);\n\tif (ret < 0)\n\t\tgoto err_pt1_cleanup_frontends;\n\n\treturn 0;\n\nerr_pt1_cleanup_frontends:\n\tpt1_cleanup_frontends(pt1);\nerr_pt1_disable_ram:\n\tpt1_disable_ram(pt1);\n\tpt1->power = 0;\n\tpt1->reset = 1;\n\tpt1_update_power(pt1);\nerr_i2c_del_adapter:\n\ti2c_del_adapter(i2c_adap);\nerr_pt1_cleanup_adapters:\n\tpt1_cleanup_adapters(pt1);\nerr_kfree:\n\tkfree(pt1);\nerr_pci_iounmap:\n\tpci_iounmap(pdev, regs);\nerr_pci_release_regions:\n\tpci_release_regions(pdev);\nerr_pci_disable_device:\n\tpci_disable_device(pdev);\nerr:\n\treturn ret;\n\n}\n\nstatic const struct pci_device_id pt1_id_table[] = {\n\t{ PCI_DEVICE(0x10ee, 0x211a) },\n\t{ PCI_DEVICE(0x10ee, 0x222a) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, pt1_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(pt1_pm_ops, pt1_suspend, pt1_resume);\n\nstatic struct pci_driver pt1_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.probe\t\t= pt1_probe,\n\t.remove\t\t= pt1_remove,\n\t.id_table\t= pt1_id_table,\n\t.driver.pm\t= &pt1_pm_ops,\n};\n\nmodule_pci_driver(pt1_driver);\n\nMODULE_AUTHOR(\"Takahito HIRANO <hiranotaka@zng.info>\");\nMODULE_DESCRIPTION(\"Earthsoft PT1/PT2 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}