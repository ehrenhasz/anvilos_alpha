{
  "module_name": "cx88-vp3054-i2c.c",
  "hash_id": "1ab37e2d8cf1d76197e5b40866f4828790fde63a35231b1213a333b98aaccf77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-vp3054-i2c.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n#include \"cx88-vp3054-i2c.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/io.h>\n\nMODULE_DESCRIPTION(\"driver for cx2388x VP3054 design\");\nMODULE_AUTHOR(\"Chris Pascoe <c.pascoe@itee.uq.edu.au>\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic void vp3054_bit_setscl(void *data, int state)\n{\n\tstruct cx8802_dev *dev = data;\n\tstruct cx88_core *core = dev->core;\n\tstruct vp3054_i2c_state *vp3054_i2c = dev->vp3054;\n\n\tif (state) {\n\t\tvp3054_i2c->state |=  0x0001;\t \n\t\tvp3054_i2c->state &= ~0x0100;\t \n\t} else {\n\t\tvp3054_i2c->state &= ~0x0001;\t \n\t\tvp3054_i2c->state |=  0x0100;\t \n\t}\n\tcx_write(MO_GP0_IO, 0x010000 | vp3054_i2c->state);\n\tcx_read(MO_GP0_IO);\n}\n\nstatic void vp3054_bit_setsda(void *data, int state)\n{\n\tstruct cx8802_dev *dev = data;\n\tstruct cx88_core *core = dev->core;\n\tstruct vp3054_i2c_state *vp3054_i2c = dev->vp3054;\n\n\tif (state) {\n\t\tvp3054_i2c->state |=  0x0002;\t \n\t\tvp3054_i2c->state &= ~0x0200;\t \n\t} else {\n\t\tvp3054_i2c->state &= ~0x0002;\t \n\t\tvp3054_i2c->state |=  0x0200;\t \n\t}\n\tcx_write(MO_GP0_IO, 0x020000 | vp3054_i2c->state);\n\tcx_read(MO_GP0_IO);\n}\n\nstatic int vp3054_bit_getscl(void *data)\n{\n\tstruct cx8802_dev *dev = data;\n\tstruct cx88_core *core = dev->core;\n\tu32 state;\n\n\tstate = cx_read(MO_GP0_IO);\n\treturn (state & 0x01) ? 1 : 0;\n}\n\nstatic int vp3054_bit_getsda(void *data)\n{\n\tstruct cx8802_dev *dev = data;\n\tstruct cx88_core *core = dev->core;\n\tu32 state;\n\n\tstate = cx_read(MO_GP0_IO);\n\treturn (state & 0x02) ? 1 : 0;\n}\n\n \n\nstatic const struct i2c_algo_bit_data vp3054_i2c_algo_template = {\n\t.setsda  = vp3054_bit_setsda,\n\t.setscl  = vp3054_bit_setscl,\n\t.getsda  = vp3054_bit_getsda,\n\t.getscl  = vp3054_bit_getscl,\n\t.udelay  = 16,\n\t.timeout = 200,\n};\n\n \n\nint vp3054_i2c_probe(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\tstruct vp3054_i2c_state *vp3054_i2c;\n\tint rc;\n\n\tif (core->boardnr != CX88_BOARD_DNTV_LIVE_DVB_T_PRO)\n\t\treturn 0;\n\n\tvp3054_i2c = kzalloc(sizeof(*vp3054_i2c), GFP_KERNEL);\n\tif (!vp3054_i2c)\n\t\treturn -ENOMEM;\n\tdev->vp3054 = vp3054_i2c;\n\n\tvp3054_i2c->algo = vp3054_i2c_algo_template;\n\n\tvp3054_i2c->adap.dev.parent = &dev->pci->dev;\n\tstrscpy(vp3054_i2c->adap.name, core->name,\n\t\tsizeof(vp3054_i2c->adap.name));\n\tvp3054_i2c->adap.owner = THIS_MODULE;\n\tvp3054_i2c->algo.data = dev;\n\ti2c_set_adapdata(&vp3054_i2c->adap, dev);\n\tvp3054_i2c->adap.algo_data = &vp3054_i2c->algo;\n\n\tvp3054_bit_setscl(dev, 1);\n\tvp3054_bit_setsda(dev, 1);\n\n\trc = i2c_bit_add_bus(&vp3054_i2c->adap);\n\tif (rc != 0) {\n\t\tpr_err(\"vp3054_i2c register FAILED\\n\");\n\n\t\tkfree(dev->vp3054);\n\t\tdev->vp3054 = NULL;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(vp3054_i2c_probe);\n\nvoid vp3054_i2c_remove(struct cx8802_dev *dev)\n{\n\tstruct vp3054_i2c_state *vp3054_i2c = dev->vp3054;\n\n\tif (!vp3054_i2c ||\n\t    dev->core->boardnr != CX88_BOARD_DNTV_LIVE_DVB_T_PRO)\n\t\treturn;\n\n\ti2c_del_adapter(&vp3054_i2c->adap);\n\tkfree(vp3054_i2c);\n}\nEXPORT_SYMBOL(vp3054_i2c_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}