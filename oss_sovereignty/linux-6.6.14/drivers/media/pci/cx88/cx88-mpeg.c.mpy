{
  "module_name": "cx88-mpeg.c",
  "hash_id": "8a6321a8f76f184aa97f038c6e4e73242b1e5c6bdfcf43ceb3499cc3abaff175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-mpeg.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n \n\nMODULE_DESCRIPTION(\"mpeg driver for cx2388x based TV cards\");\nMODULE_AUTHOR(\"Jelle Foks <jelle@foks.us>\");\nMODULE_AUTHOR(\"Chris Pascoe <c.pascoe@itee.uq.edu.au>\");\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(CX88_VERSION);\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages [mpeg]\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (debug + 1 > level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: mpeg:\" fmt),\t\t\\\n\t\t\t__func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#if defined(CONFIG_MODULES) && defined(MODULE)\nstatic void request_module_async(struct work_struct *work)\n{\n\tstruct cx8802_dev *dev = container_of(work, struct cx8802_dev,\n\t\t\t\t\t      request_module_wk);\n\n\tif (dev->core->board.mpeg & CX88_MPEG_DVB)\n\t\trequest_module(\"cx88-dvb\");\n\tif (dev->core->board.mpeg & CX88_MPEG_BLACKBIRD)\n\t\trequest_module(\"cx88-blackbird\");\n}\n\nstatic void request_modules(struct cx8802_dev *dev)\n{\n\tINIT_WORK(&dev->request_module_wk, request_module_async);\n\tschedule_work(&dev->request_module_wk);\n}\n\nstatic void flush_request_modules(struct cx8802_dev *dev)\n{\n\tflush_work(&dev->request_module_wk);\n}\n#else\n#define request_modules(dev)\n#define flush_request_modules(dev)\n#endif  \n\nstatic LIST_HEAD(cx8802_devlist);\nstatic DEFINE_MUTEX(cx8802_mutex);\n \n\nint cx8802_start_dma(struct cx8802_dev    *dev,\n\t\t     struct cx88_dmaqueue *q,\n\t\t     struct cx88_buffer   *buf)\n{\n\tstruct cx88_core *core = dev->core;\n\n\tdprintk(1, \"w: %d, h: %d, f: %d\\n\",\n\t\tcore->width, core->height, core->field);\n\n\t \n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],\n\t\t\t\tdev->ts_packet_size, buf->risc.dma);\n\n\t \n\tcx_write(MO_TS_LNGTH, dev->ts_packet_size);\n\n\t \n\n\tdprintk(1, \"core->active_type_id = 0x%08x\\n\", core->active_type_id);\n\n\tif ((core->active_type_id == CX88_MPEG_DVB) &&\n\t    (core->board.mpeg & CX88_MPEG_DVB)) {\n\t\tdprintk(1, \"cx8802_start_dma doing .dvb\\n\");\n\t\t \n\t\tcx_write(TS_GEN_CNTRL, 0x0040 | dev->ts_gen_cntrl);\n\t\tudelay(100);\n\t\tcx_write(MO_PINMUX_IO, 0x00);\n\t\tcx_write(TS_HW_SOP_CNTRL, 0x47 << 16 | 188 << 4 | 0x01);\n\t\tswitch (core->boardnr) {\n\t\tcase CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_Q:\n\t\tcase CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_T:\n\t\tcase CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:\n\t\tcase CX88_BOARD_PCHDTV_HD5500:\n\t\t\tcx_write(TS_SOP_STAT, 1 << 13);\n\t\t\tbreak;\n\t\tcase CX88_BOARD_SAMSUNG_SMT_7020:\n\t\t\tcx_write(TS_SOP_STAT, 0x00);\n\t\t\tbreak;\n\t\tcase CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:\n\t\tcase CX88_BOARD_HAUPPAUGE_NOVASE2_S1:\n\t\t\t \n\t\t\tcx_write(MO_PINMUX_IO, 0x88);\n\t\t\tudelay(100);\n\t\t\tbreak;\n\t\tcase CX88_BOARD_HAUPPAUGE_HVR1300:\n\t\t\t \n\t\t\tcx_write(MO_PINMUX_IO, 0x88);\n\t\t\tcx_write(TS_SOP_STAT, 0);\n\t\t\tcx_write(TS_VALERR_CNTRL, 0);\n\t\t\tbreak;\n\t\tcase CX88_BOARD_PINNACLE_PCTV_HD_800i:\n\t\t\t \n\t\t\tcx_write(MO_PINMUX_IO, 0x88);\n\t\t\tcx_write(TS_HW_SOP_CNTRL, (0x47 << 16) | (188 << 4));\n\t\t\tdev->ts_gen_cntrl = 5;\n\t\t\tcx_write(TS_SOP_STAT, 0);\n\t\t\tcx_write(TS_VALERR_CNTRL, 0);\n\t\t\tudelay(100);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcx_write(TS_SOP_STAT, 0x00);\n\t\t\tbreak;\n\t\t}\n\t\tcx_write(TS_GEN_CNTRL, dev->ts_gen_cntrl);\n\t\tudelay(100);\n\t} else if ((core->active_type_id == CX88_MPEG_BLACKBIRD) &&\n\t\t(core->board.mpeg & CX88_MPEG_BLACKBIRD)) {\n\t\tdprintk(1, \"cx8802_start_dma doing .blackbird\\n\");\n\t\tcx_write(MO_PINMUX_IO, 0x88);  \n\n\t\t \n\t\tcx_write(TS_GEN_CNTRL, 0x46);\n\t\tudelay(100);\n\n\t\tcx_write(TS_HW_SOP_CNTRL, 0x408);  \n\t\tcx_write(TS_VALERR_CNTRL, 0x2000);\n\n\t\t \n\t\tcx_write(TS_GEN_CNTRL, 0x06);\n\t\tudelay(100);\n\t} else {\n\t\tpr_err(\"%s() Failed. Unsupported value in .mpeg (0x%08x)\\n\",\n\t\t       __func__, core->board.mpeg);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcx_write(MO_TS_GPCNTRL, GP_COUNT_CONTROL_RESET);\n\tq->count = 0;\n\n\t \n\tcx_write(MO_TS_INTSTAT,  0x1f1111);\n\n\t \n\tdprintk(1, \"setting the interrupt mask\\n\");\n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_TSINT);\n\tcx_set(MO_TS_INTMSK,  0x1f0011);\n\n\t \n\tcx_set(MO_DEV_CNTRL2, (1 << 5));\n\tcx_set(MO_TS_DMACNTRL, 0x11);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx8802_start_dma);\n\nstatic int cx8802_stop_dma(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tcx_clear(MO_TS_DMACNTRL, 0x11);\n\n\t \n\tcx_clear(MO_PCI_INTMSK, PCI_INT_TSINT);\n\tcx_clear(MO_TS_INTMSK, 0x1f0011);\n\n\t \n\tcx_write(TS_GEN_CNTRL, 0xcd);\n\treturn 0;\n}\n\nstatic int cx8802_restart_queue(struct cx8802_dev    *dev,\n\t\t\t\tstruct cx88_dmaqueue *q)\n{\n\tstruct cx88_buffer *buf;\n\n\tdprintk(1, \"\\n\");\n\tif (list_empty(&q->active))\n\t\treturn 0;\n\n\tbuf = list_entry(q->active.next, struct cx88_buffer, list);\n\tdprintk(2, \"restart_queue [%p/%d]: restart dma\\n\",\n\t\tbuf, buf->vb.vb2_buf.index);\n\tcx8802_start_dma(dev, q, buf);\n\treturn 0;\n}\n\n \n\nint cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,\n\t\t       struct cx88_buffer *buf)\n{\n\tint size = dev->ts_packet_size * dev->ts_packet_count;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\n\tstruct cx88_riscmem *risc = &buf->risc;\n\tint rc;\n\n\tif (vb2_plane_size(&buf->vb.vb2_buf, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\n\n\trc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,\n\t\t\t\t  dev->ts_packet_size, dev->ts_packet_count, 0);\n\tif (rc) {\n\t\tif (risc->cpu)\n\t\t\tdma_free_coherent(&dev->pci->dev, risc->size,\n\t\t\t\t\t  risc->cpu, risc->dma);\n\t\tmemset(risc, 0, sizeof(*risc));\n\t\treturn rc;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(cx8802_buf_prepare);\n\nvoid cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)\n{\n\tstruct cx88_buffer    *prev;\n\tstruct cx88_dmaqueue  *cx88q = &dev->mpegq;\n\n\tdprintk(1, \"\\n\");\n\t \n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);\n\n\tif (list_empty(&cx88q->active)) {\n\t\tdprintk(1, \"queue is empty - first active\\n\");\n\t\tlist_add_tail(&buf->list, &cx88q->active);\n\t\tdprintk(1, \"[%p/%d] %s - first active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index, __func__);\n\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tdprintk(1, \"queue is not empty - append to active\\n\");\n\t\tprev = list_entry(cx88q->active.prev, struct cx88_buffer, list);\n\t\tlist_add_tail(&buf->list, &cx88q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t\tdprintk(1, \"[%p/%d] %s - append to active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index, __func__);\n\t}\n}\nEXPORT_SYMBOL(cx8802_buf_queue);\n\n \n\nstatic void do_cancel_buffers(struct cx8802_dev *dev)\n{\n\tstruct cx88_dmaqueue *q = &dev->mpegq;\n\tstruct cx88_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&q->active)) {\n\t\tbuf = list_entry(q->active.next, struct cx88_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nvoid cx8802_cancel_buffers(struct cx8802_dev *dev)\n{\n\tdprintk(1, \"\\n\");\n\tcx8802_stop_dma(dev);\n\tdo_cancel_buffers(dev);\n}\nEXPORT_SYMBOL(cx8802_cancel_buffers);\n\nstatic const char *cx88_mpeg_irqs[32] = {\n\t\"ts_risci1\", NULL, NULL, NULL,\n\t\"ts_risci2\", NULL, NULL, NULL,\n\t\"ts_oflow\",  NULL, NULL, NULL,\n\t\"ts_sync\",   NULL, NULL, NULL,\n\t\"opc_err\", \"par_err\", \"rip_err\", \"pci_abort\",\n\t\"ts_err?\",\n};\n\nstatic void cx8802_mpeg_irq(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\tu32 status, mask, count;\n\n\tdprintk(1, \"\\n\");\n\tstatus = cx_read(MO_TS_INTSTAT);\n\tmask   = cx_read(MO_TS_INTMSK);\n\tif (0 == (status & mask))\n\t\treturn;\n\n\tcx_write(MO_TS_INTSTAT, status);\n\n\tif (debug || (status & mask & ~0xff))\n\t\tcx88_print_irqbits(\"irq mpeg \",\n\t\t\t\t   cx88_mpeg_irqs, ARRAY_SIZE(cx88_mpeg_irqs),\n\t\t\t\t   status, mask);\n\n\t \n\tif (status & (1 << 16)) {\n\t\tpr_warn(\"mpeg risc op code error\\n\");\n\t\tcx_clear(MO_TS_DMACNTRL, 0x11);\n\t\tcx88_sram_channel_dump(dev->core,\n\t\t\t\t       &cx88_sram_channels[SRAM_CH28]);\n\t}\n\n\t \n\tif (status & 0x01) {\n\t\tdprintk(1, \"wake up\\n\");\n\t\tspin_lock(&dev->slock);\n\t\tcount = cx_read(MO_TS_GPCNT);\n\t\tcx88_wakeup(dev->core, &dev->mpegq, count);\n\t\tspin_unlock(&dev->slock);\n\t}\n\n\t \n\tif (status & 0x1f0100) {\n\t\tdprintk(0, \"general errors: 0x%08x\\n\", status & 0x1f0100);\n\t\tspin_lock(&dev->slock);\n\t\tcx8802_stop_dma(dev);\n\t\tspin_unlock(&dev->slock);\n\t}\n}\n\n#define MAX_IRQ_LOOP 10\n\nstatic irqreturn_t cx8802_irq(int irq, void *dev_id)\n{\n\tstruct cx8802_dev *dev = dev_id;\n\tstruct cx88_core *core = dev->core;\n\tu32 status;\n\tint loop, handled = 0;\n\n\tfor (loop = 0; loop < MAX_IRQ_LOOP; loop++) {\n\t\tstatus = cx_read(MO_PCI_INTSTAT) &\n\t\t\t(core->pci_irqmask | PCI_INT_TSINT);\n\t\tif (status == 0)\n\t\t\tgoto out;\n\t\tdprintk(1, \"cx8802_irq\\n\");\n\t\tdprintk(1, \"    loop: %d/%d\\n\", loop, MAX_IRQ_LOOP);\n\t\tdprintk(1, \"    status: %d\\n\", status);\n\t\thandled = 1;\n\t\tcx_write(MO_PCI_INTSTAT, status);\n\n\t\tif (status & core->pci_irqmask)\n\t\t\tcx88_core_irq(core, status);\n\t\tif (status & PCI_INT_TSINT)\n\t\t\tcx8802_mpeg_irq(dev);\n\t}\n\tif (loop == MAX_IRQ_LOOP) {\n\t\tdprintk(0, \"clearing mask\\n\");\n\t\tpr_warn(\"irq loop -- clearing mask\\n\");\n\t\tcx_write(MO_PCI_INTMSK, 0);\n\t}\n\n out:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int cx8802_init_common(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\tint err;\n\n\t \n\tif (pci_enable_device(dev->pci))\n\t\treturn -EIO;\n\tpci_set_master(dev->pci);\n\terr = dma_set_mask(&dev->pci->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tpr_err(\"Oops: no 32bit PCI DMA ???\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev->pci_rev = dev->pci->revision;\n\tpci_read_config_byte(dev->pci, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tpr_info(\"found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tpci_name(dev->pci), dev->pci_rev, dev->pci->irq,\n\t\tdev->pci_lat,\n\t\t(unsigned long long)pci_resource_start(dev->pci, 0));\n\n\t \n\tspin_lock_init(&dev->slock);\n\n\t \n\tINIT_LIST_HEAD(&dev->mpegq.active);\n\n\t \n\terr = request_irq(dev->pci->irq, cx8802_irq,\n\t\t\t  IRQF_SHARED, dev->core->name, dev);\n\tif (err < 0) {\n\t\tpr_err(\"can't get IRQ %d\\n\", dev->pci->irq);\n\t\treturn err;\n\t}\n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask);\n\n\t \n\tpci_set_drvdata(dev->pci, dev);\n\treturn 0;\n}\n\nstatic void cx8802_fini_common(struct cx8802_dev *dev)\n{\n\tdprintk(2, \"\\n\");\n\tcx8802_stop_dma(dev);\n\tpci_disable_device(dev->pci);\n\n\t \n\tfree_irq(dev->pci->irq, dev);\n}\n\n \n\nstatic int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)\n{\n\tstruct cx8802_dev *dev = pci_get_drvdata(pci_dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (!list_empty(&dev->mpegq.active)) {\n\t\tdprintk(2, \"suspend\\n\");\n\t\tpr_info(\"suspend mpeg\\n\");\n\t\tcx8802_stop_dma(dev);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\t \n\tcx88_shutdown(dev->core);\n\n\tpci_save_state(pci_dev);\n\tif (pci_set_power_state(pci_dev,\n\t\t\t\tpci_choose_state(pci_dev, state)) != 0) {\n\t\tpci_disable_device(pci_dev);\n\t\tdev->state.disabled = 1;\n\t}\n\treturn 0;\n}\n\nstatic int cx8802_resume_common(struct pci_dev *pci_dev)\n{\n\tstruct cx8802_dev *dev = pci_get_drvdata(pci_dev);\n\tunsigned long flags;\n\tint err;\n\n\tif (dev->state.disabled) {\n\t\terr = pci_enable_device(pci_dev);\n\t\tif (err) {\n\t\t\tpr_err(\"can't enable device\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdev->state.disabled = 0;\n\t}\n\terr = pci_set_power_state(pci_dev, PCI_D0);\n\tif (err) {\n\t\tpr_err(\"can't enable device\\n\");\n\t\tpci_disable_device(pci_dev);\n\t\tdev->state.disabled = 1;\n\n\t\treturn err;\n\t}\n\tpci_restore_state(pci_dev);\n\n\t \n\tcx88_reset(dev->core);\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (!list_empty(&dev->mpegq.active)) {\n\t\tpr_info(\"resume mpeg\\n\");\n\t\tcx8802_restart_queue(dev, &dev->mpegq);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\nstruct cx8802_driver *cx8802_get_driver(struct cx8802_dev *dev,\n\t\t\t\t\tenum cx88_board_type btype)\n{\n\tstruct cx8802_driver *d;\n\n\tlist_for_each_entry(d, &dev->drvlist, drvlist)\n\t\tif (d->type_id == btype)\n\t\t\treturn d;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(cx8802_get_driver);\n\n \nstatic int cx8802_request_acquire(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tunsigned int\ti;\n\n\t \n\tif (core->active_type_id != CX88_BOARD_NONE &&\n\t    core->active_type_id != drv->type_id)\n\t\treturn -EBUSY;\n\n\tif (drv->type_id == CX88_MPEG_DVB) {\n\t\t \n\t\tcore->last_analog_input = core->input;\n\t\tcore->input = 0;\n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(core->board.input);\n\t\t     i++) {\n\t\t\tif (core->board.input[i].type == CX88_VMUX_DVB) {\n\t\t\t\tcore->input = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (drv->advise_acquire) {\n\t\tcore->active_ref++;\n\t\tif (core->active_type_id == CX88_BOARD_NONE) {\n\t\t\tcore->active_type_id = drv->type_id;\n\t\t\tdrv->advise_acquire(drv);\n\t\t}\n\n\t\tdprintk(1, \"Post acquire GPIO=%x\\n\", cx_read(MO_GP0_IO));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cx8802_request_release(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\n\tif (drv->advise_release && --core->active_ref == 0) {\n\t\tif (drv->type_id == CX88_MPEG_DVB) {\n\t\t\t \n\t\t\tcore->input = core->last_analog_input;\n\t\t}\n\n\t\tdrv->advise_release(drv);\n\t\tcore->active_type_id = CX88_BOARD_NONE;\n\t\tdprintk(1, \"Post release GPIO=%x\\n\", cx_read(MO_GP0_IO));\n\t}\n\n\treturn 0;\n}\n\nstatic int cx8802_check_driver(struct cx8802_driver *drv)\n{\n\tif (!drv)\n\t\treturn -ENODEV;\n\n\tif ((drv->type_id != CX88_MPEG_DVB) &&\n\t    (drv->type_id != CX88_MPEG_BLACKBIRD))\n\t\treturn -EINVAL;\n\n\tif ((drv->hw_access != CX8802_DRVCTL_SHARED) &&\n\t    (drv->hw_access != CX8802_DRVCTL_EXCLUSIVE))\n\t\treturn -EINVAL;\n\n\tif ((!drv->probe) ||\n\t    (!drv->remove) ||\n\t    (!drv->advise_acquire) ||\n\t    (!drv->advise_release))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint cx8802_register_driver(struct cx8802_driver *drv)\n{\n\tstruct cx8802_dev *dev;\n\tstruct cx8802_driver *driver;\n\tint err, i = 0;\n\n\tpr_info(\"registering cx8802 driver, type: %s access: %s\\n\",\n\t\tdrv->type_id == CX88_MPEG_DVB ? \"dvb\" : \"blackbird\",\n\t\tdrv->hw_access == CX8802_DRVCTL_SHARED ?\n\t\t\t\t  \"shared\" : \"exclusive\");\n\n\terr = cx8802_check_driver(drv);\n\tif (err) {\n\t\tpr_err(\"cx8802_driver is invalid\\n\");\n\t\treturn err;\n\t}\n\n\tmutex_lock(&cx8802_mutex);\n\n\tlist_for_each_entry(dev, &cx8802_devlist, devlist) {\n\t\tpr_info(\"subsystem: %04x:%04x, board: %s [card=%d]\\n\",\n\t\t\tdev->pci->subsystem_vendor,\n\t\t\tdev->pci->subsystem_device, dev->core->board.name,\n\t\t\tdev->core->boardnr);\n\n\t\t \n\t\tdriver = kzalloc(sizeof(*drv), GFP_KERNEL);\n\t\tif (!driver) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdrv->core = dev->core;\n\t\tdrv->suspend = cx8802_suspend_common;\n\t\tdrv->resume = cx8802_resume_common;\n\t\tdrv->request_acquire = cx8802_request_acquire;\n\t\tdrv->request_release = cx8802_request_release;\n\t\tmemcpy(driver, drv, sizeof(*driver));\n\n\t\tmutex_lock(&drv->core->lock);\n\t\terr = drv->probe(driver);\n\t\tif (err == 0) {\n\t\t\ti++;\n\t\t\tlist_add_tail(&driver->drvlist, &dev->drvlist);\n\t\t} else {\n\t\t\tpr_err(\"cx8802 probe failed, err = %d\\n\", err);\n\t\t}\n\t\tmutex_unlock(&drv->core->lock);\n\t}\n\n\terr = i ? 0 : -ENODEV;\nout:\n\tmutex_unlock(&cx8802_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL(cx8802_register_driver);\n\nint cx8802_unregister_driver(struct cx8802_driver *drv)\n{\n\tstruct cx8802_dev *dev;\n\tstruct cx8802_driver *d, *dtmp;\n\tint err = 0;\n\n\tpr_info(\"unregistering cx8802 driver, type: %s access: %s\\n\",\n\t\tdrv->type_id == CX88_MPEG_DVB ? \"dvb\" : \"blackbird\",\n\t\tdrv->hw_access == CX8802_DRVCTL_SHARED ?\n\t\t\t\t  \"shared\" : \"exclusive\");\n\n\tmutex_lock(&cx8802_mutex);\n\n\tlist_for_each_entry(dev, &cx8802_devlist, devlist) {\n\t\tpr_info(\"subsystem: %04x:%04x, board: %s [card=%d]\\n\",\n\t\t\tdev->pci->subsystem_vendor,\n\t\t\tdev->pci->subsystem_device, dev->core->board.name,\n\t\t\tdev->core->boardnr);\n\n\t\tmutex_lock(&dev->core->lock);\n\n\t\tlist_for_each_entry_safe(d, dtmp, &dev->drvlist, drvlist) {\n\t\t\t \n\t\t\tif (d->type_id != drv->type_id)\n\t\t\t\tcontinue;\n\n\t\t\terr = d->remove(d);\n\t\t\tif (err == 0) {\n\t\t\t\tlist_del(&d->drvlist);\n\t\t\t\tkfree(d);\n\t\t\t} else\n\t\t\t\tpr_err(\"cx8802 driver remove failed (%d)\\n\",\n\t\t\t\t       err);\n\t\t}\n\n\t\tmutex_unlock(&dev->core->lock);\n\t}\n\n\tmutex_unlock(&cx8802_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cx8802_unregister_driver);\n\n \nstatic int cx8802_probe(struct pci_dev *pci_dev,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct cx8802_dev *dev;\n\tstruct cx88_core  *core;\n\tint err;\n\n\t \n\tcore = cx88_core_get(pci_dev);\n\tif (!core)\n\t\treturn -EINVAL;\n\n\tpr_info(\"cx2388x 8802 Driver Manager\\n\");\n\n\terr = -ENODEV;\n\tif (!core->board.mpeg)\n\t\tgoto fail_core;\n\n\terr = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto fail_core;\n\tdev->pci = pci_dev;\n\tdev->core = core;\n\n\t \n\tcore->dvbdev = dev;\n\n\terr = cx8802_init_common(dev);\n\tif (err != 0)\n\t\tgoto fail_dev;\n\n\tINIT_LIST_HEAD(&dev->drvlist);\n\tmutex_lock(&cx8802_mutex);\n\tlist_add_tail(&dev->devlist, &cx8802_devlist);\n\tmutex_unlock(&cx8802_mutex);\n\n\t \n\trequest_modules(dev);\n\treturn 0;\n\n fail_dev:\n\tkfree(dev);\n fail_core:\n\tcore->dvbdev = NULL;\n\tcx88_core_put(core, pci_dev);\n\treturn err;\n}\n\nstatic void cx8802_remove(struct pci_dev *pci_dev)\n{\n\tstruct cx8802_dev *dev;\n\n\tdev = pci_get_drvdata(pci_dev);\n\n\tdprintk(1, \"%s\\n\", __func__);\n\n\tflush_request_modules(dev);\n\n\tmutex_lock(&dev->core->lock);\n\n\tif (!list_empty(&dev->drvlist)) {\n\t\tstruct cx8802_driver *drv, *tmp;\n\t\tint err;\n\n\t\tpr_warn(\"Trying to remove cx8802 driver while cx8802 sub-drivers still loaded?!\\n\");\n\n\t\tlist_for_each_entry_safe(drv, tmp, &dev->drvlist, drvlist) {\n\t\t\terr = drv->remove(drv);\n\t\t\tif (err == 0) {\n\t\t\t\tlist_del(&drv->drvlist);\n\t\t\t} else\n\t\t\t\tpr_err(\"cx8802 driver remove failed (%d)\\n\",\n\t\t\t\t       err);\n\t\t\tkfree(drv);\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->core->lock);\n\n\t \n\tdev->core->dvbdev = NULL;\n\n\t \n\tcx8802_fini_common(dev);\n\tcx88_core_put(dev->core, dev->pci);\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id cx8802_pci_tbl[] = {\n\t{\n\t\t.vendor       = 0x14f1,\n\t\t.device       = 0x8802,\n\t\t.subvendor    = PCI_ANY_ID,\n\t\t.subdevice    = PCI_ANY_ID,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(pci, cx8802_pci_tbl);\n\nstatic struct pci_driver cx8802_pci_driver = {\n\t.name     = \"cx88-mpeg driver manager\",\n\t.id_table = cx8802_pci_tbl,\n\t.probe    = cx8802_probe,\n\t.remove   = cx8802_remove,\n};\n\nmodule_pci_driver(cx8802_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}