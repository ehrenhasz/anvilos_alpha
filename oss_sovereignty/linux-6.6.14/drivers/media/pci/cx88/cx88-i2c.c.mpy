{
  "module_name": "cx88-i2c.c",
  "hash_id": "6ed795b89f9413044a0a05bb1fe07a7fb60e7a6ef8ba136c99a84a81bdbc98ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-i2c.c",
  "human_readable_source": "\n\n \n\n#include \"cx88.h\"\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#include <media/v4l2-common.h>\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"enable debug messages [i2c]\");\n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\nstatic unsigned int i2c_udelay = 5;\nmodule_param(i2c_udelay, int, 0644);\nMODULE_PARM_DESC(i2c_udelay,\n\t\t \"i2c delay at insmod time, in usecs (should be 5 or higher). Lower value means higher bus speed.\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (i2c_debug >= level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: i2c:\" fmt),\t\t\\\n\t\t\t__func__, ##arg);\t\t\t\t\\\n} while (0)\n\n \n\nstatic void cx8800_bit_setscl(void *data, int state)\n{\n\tstruct cx88_core *core = data;\n\n\tif (state)\n\t\tcore->i2c_state |= 0x02;\n\telse\n\t\tcore->i2c_state &= ~0x02;\n\tcx_write(MO_I2C, core->i2c_state);\n\tcx_read(MO_I2C);\n}\n\nstatic void cx8800_bit_setsda(void *data, int state)\n{\n\tstruct cx88_core *core = data;\n\n\tif (state)\n\t\tcore->i2c_state |= 0x01;\n\telse\n\t\tcore->i2c_state &= ~0x01;\n\tcx_write(MO_I2C, core->i2c_state);\n\tcx_read(MO_I2C);\n}\n\nstatic int cx8800_bit_getscl(void *data)\n{\n\tstruct cx88_core *core = data;\n\tu32 state;\n\n\tstate = cx_read(MO_I2C);\n\treturn state & 0x02 ? 1 : 0;\n}\n\nstatic int cx8800_bit_getsda(void *data)\n{\n\tstruct cx88_core *core = data;\n\tu32 state;\n\n\tstate = cx_read(MO_I2C);\n\treturn state & 0x01;\n}\n\n \n\nstatic const struct i2c_algo_bit_data cx8800_i2c_algo_template = {\n\t.setsda  = cx8800_bit_setsda,\n\t.setscl  = cx8800_bit_setscl,\n\t.getsda  = cx8800_bit_getsda,\n\t.getscl  = cx8800_bit_getscl,\n\t.udelay  = 16,\n\t.timeout = 200,\n};\n\n \n\nstatic const char * const i2c_devs[128] = {\n\t[0x1c >> 1] = \"lgdt330x\",\n\t[0x86 >> 1] = \"tda9887/cx22702\",\n\t[0xa0 >> 1] = \"eeprom\",\n\t[0xc0 >> 1] = \"tuner (analog)\",\n\t[0xc2 >> 1] = \"tuner (analog/dvb)\",\n\t[0xc8 >> 1] = \"xc5000\",\n};\n\nstatic void do_i2c_scan(const char *name, struct i2c_client *c)\n{\n\tunsigned char buf;\n\tint i, rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\n\t\tc->addr = i;\n\t\trc = i2c_master_recv(c, &buf, 0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tpr_info(\"i2c scan: found device @ 0x%x  [%s]\\n\",\n\t\t\ti << 1, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n}\n\n \nint cx88_i2c_init(struct cx88_core *core, struct pci_dev *pci)\n{\n\t \n\tif (i2c_udelay < 5)\n\t\ti2c_udelay = 5;\n\n\tcore->i2c_algo = cx8800_i2c_algo_template;\n\n\tcore->i2c_adap.dev.parent = &pci->dev;\n\tstrscpy(core->i2c_adap.name, core->name, sizeof(core->i2c_adap.name));\n\tcore->i2c_adap.owner = THIS_MODULE;\n\tcore->i2c_algo.udelay = i2c_udelay;\n\tcore->i2c_algo.data = core;\n\ti2c_set_adapdata(&core->i2c_adap, &core->v4l2_dev);\n\tcore->i2c_adap.algo_data = &core->i2c_algo;\n\tcore->i2c_client.adapter = &core->i2c_adap;\n\tstrscpy(core->i2c_client.name, \"cx88xx internal\", I2C_NAME_SIZE);\n\n\tcx8800_bit_setscl(core, 1);\n\tcx8800_bit_setsda(core, 1);\n\n\tcore->i2c_rc = i2c_bit_add_bus(&core->i2c_adap);\n\tif (core->i2c_rc == 0) {\n\t\tstatic u8 tuner_data[] = {\n\t\t\t0x0b, 0xdc, 0x86, 0x52 };\n\t\tstatic struct i2c_msg tuner_msg = {\n\t\t\t.flags = 0,\n\t\t\t.addr = 0xc2 >> 1,\n\t\t\t.buf = tuner_data,\n\t\t\t.len = 4\n\t\t};\n\n\t\tdprintk(1, \"i2c register ok\\n\");\n\t\tswitch (core->boardnr) {\n\t\tcase CX88_BOARD_HAUPPAUGE_HVR1300:\n\t\tcase CX88_BOARD_HAUPPAUGE_HVR3000:\n\t\tcase CX88_BOARD_HAUPPAUGE_HVR4000:\n\t\t\tpr_info(\"i2c init: enabling analog demod on HVR1300/3000/4000 tuner\\n\");\n\t\t\ti2c_transfer(core->i2c_client.adapter, &tuner_msg, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (i2c_scan)\n\t\t\tdo_i2c_scan(core->name, &core->i2c_client);\n\t} else\n\t\tpr_err(\"i2c register FAILED\\n\");\n\n\treturn core->i2c_rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}