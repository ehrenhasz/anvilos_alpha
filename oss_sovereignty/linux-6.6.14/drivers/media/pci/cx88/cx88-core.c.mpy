{
  "module_name": "cx88-core.c",
  "hash_id": "0d85f390bef18e4b9421a814b508733fce08a253454c0ba67af918c9ee51c8f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-core.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/sound.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/mutex.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n\nMODULE_DESCRIPTION(\"v4l2 driver module for cx2388x based TV cards\");\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n\nunsigned int cx88_core_debug;\nmodule_param_named(core_debug, cx88_core_debug, int, 0644);\nMODULE_PARM_DESC(core_debug, \"enable debug messages [core]\");\n\nstatic unsigned int nicam;\nmodule_param(nicam, int, 0644);\nMODULE_PARM_DESC(nicam, \"tv audio is nicam\");\n\nstatic unsigned int nocomb;\nmodule_param(nocomb, int, 0644);\nMODULE_PARM_DESC(nocomb, \"disable comb filter\");\n\n#define dprintk0(fmt, arg...)\t\t\t\t\\\n\tprintk(KERN_DEBUG pr_fmt(\"%s: core:\" fmt),\t\\\n\t\t__func__, ##arg)\t\t\t\\\n\n#define dprintk(level, fmt, arg...)\tdo {\t\t\t\\\n\tif (cx88_core_debug >= level)\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: core:\" fmt),\t\\\n\t\t       __func__, ##arg);\t\t\t\\\n} while (0)\n\nstatic unsigned int cx88_devcount;\nstatic LIST_HEAD(cx88_devlist);\nstatic DEFINE_MUTEX(devlist);\n\n#define NO_SYNC_LINE (-1U)\n\n \nstatic __le32 *cx88_risc_field(__le32 *rp, struct scatterlist *sglist,\n\t\t\t       unsigned int offset, u32 sync_line,\n\t\t\t       unsigned int bpl, unsigned int padding,\n\t\t\t       unsigned int lines, unsigned int lpi, bool jump)\n{\n\tstruct scatterlist *sg;\n\tunsigned int line, todo, sol;\n\n\tif (jump) {\n\t\t(*rp++) = cpu_to_le32(RISC_JUMP);\n\t\t(*rp++) = 0;\n\t}\n\n\t \n\tif (sync_line != NO_SYNC_LINE)\n\t\t*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < lines; line++) {\n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t\tif (lpi && line > 0 && !(line % lpi))\n\t\t\tsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\n\t\telse\n\t\t\tsol = RISC_SOL;\n\t\tif (bpl <= sg_dma_len(sg) - offset) {\n\t\t\t \n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | sol |\n\t\t\t\t\t      RISC_EOL | bpl);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\toffset += bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | sol |\n\t\t\t\t\t      (sg_dma_len(sg) - offset));\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\n\t\t\ttodo -= (sg_dma_len(sg) - offset);\n\t\t\toffset = 0;\n\t\t\tsg = sg_next(sg);\n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE |\n\t\t\t\t\t\t      sg_dma_len(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t}\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\toffset += todo;\n\t\t}\n\t\toffset += padding;\n\t}\n\n\treturn rp;\n}\n\nint cx88_risc_buffer(struct pci_dev *pci, struct cx88_riscmem *risc,\n\t\t     struct scatterlist *sglist,\n\t\t     unsigned int top_offset, unsigned int bottom_offset,\n\t\t     unsigned int bpl, unsigned int padding, unsigned int lines)\n{\n\tu32 instructions, fields;\n\t__le32 *rp;\n\n\tfields = 0;\n\tif (top_offset != UNSET)\n\t\tfields++;\n\tif (bottom_offset != UNSET)\n\t\tfields++;\n\n\t \n\tinstructions  = fields * (1 + ((bpl + padding) * lines) /\n\t\t\t\t  PAGE_SIZE + lines);\n\tinstructions += 4;\n\trisc->size = instructions * 8;\n\trisc->dma = 0;\n\trisc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!risc->cpu)\n\t\treturn -ENOMEM;\n\n\t \n\trp = risc->cpu;\n\tif (top_offset != UNSET)\n\t\trp = cx88_risc_field(rp, sglist, top_offset, 0,\n\t\t\t\t     bpl, padding, lines, 0, true);\n\tif (bottom_offset != UNSET)\n\t\trp = cx88_risc_field(rp, sglist, bottom_offset, 0x200,\n\t\t\t\t     bpl, padding, lines, 0,\n\t\t\t\t     top_offset == UNSET);\n\n\t \n\trisc->jmp = rp;\n\tWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_risc_buffer);\n\nint cx88_risc_databuffer(struct pci_dev *pci, struct cx88_riscmem *risc,\n\t\t\t struct scatterlist *sglist, unsigned int bpl,\n\t\t\t unsigned int lines, unsigned int lpi)\n{\n\tu32 instructions;\n\t__le32 *rp;\n\n\t \n\tinstructions  = 1 + (bpl * lines) / PAGE_SIZE + lines;\n\tinstructions += 3;\n\trisc->size = instructions * 8;\n\trisc->dma = 0;\n\trisc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!risc->cpu)\n\t\treturn -ENOMEM;\n\n\t \n\trp = risc->cpu;\n\trp = cx88_risc_field(rp, sglist, 0, NO_SYNC_LINE, bpl, 0,\n\t\t\t     lines, lpi, !lpi);\n\n\t \n\trisc->jmp = rp;\n\tWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_risc_databuffer);\n\n \n\n \n\nconst struct sram_channel cx88_sram_channels[] = {\n\t[SRAM_CH21] = {\n\t\t.name       = \"video y / packed\",\n\t\t.cmds_start = 0x180040,\n\t\t.ctrl_start = 0x180400,\n\t\t.cdt        = 0x180400 + 64,\n\t\t.fifo_start = 0x180c00,\n\t\t.fifo_size  = 0x002800,\n\t\t.ptr1_reg   = MO_DMA21_PTR1,\n\t\t.ptr2_reg   = MO_DMA21_PTR2,\n\t\t.cnt1_reg   = MO_DMA21_CNT1,\n\t\t.cnt2_reg   = MO_DMA21_CNT2,\n\t},\n\t[SRAM_CH22] = {\n\t\t.name       = \"video u\",\n\t\t.cmds_start = 0x180080,\n\t\t.ctrl_start = 0x1804a0,\n\t\t.cdt        = 0x1804a0 + 64,\n\t\t.fifo_start = 0x183400,\n\t\t.fifo_size  = 0x000800,\n\t\t.ptr1_reg   = MO_DMA22_PTR1,\n\t\t.ptr2_reg   = MO_DMA22_PTR2,\n\t\t.cnt1_reg   = MO_DMA22_CNT1,\n\t\t.cnt2_reg   = MO_DMA22_CNT2,\n\t},\n\t[SRAM_CH23] = {\n\t\t.name       = \"video v\",\n\t\t.cmds_start = 0x1800c0,\n\t\t.ctrl_start = 0x180540,\n\t\t.cdt        = 0x180540 + 64,\n\t\t.fifo_start = 0x183c00,\n\t\t.fifo_size  = 0x000800,\n\t\t.ptr1_reg   = MO_DMA23_PTR1,\n\t\t.ptr2_reg   = MO_DMA23_PTR2,\n\t\t.cnt1_reg   = MO_DMA23_CNT1,\n\t\t.cnt2_reg   = MO_DMA23_CNT2,\n\t},\n\t[SRAM_CH24] = {\n\t\t.name       = \"vbi\",\n\t\t.cmds_start = 0x180100,\n\t\t.ctrl_start = 0x1805e0,\n\t\t.cdt        = 0x1805e0 + 64,\n\t\t.fifo_start = 0x184400,\n\t\t.fifo_size  = 0x001000,\n\t\t.ptr1_reg   = MO_DMA24_PTR1,\n\t\t.ptr2_reg   = MO_DMA24_PTR2,\n\t\t.cnt1_reg   = MO_DMA24_CNT1,\n\t\t.cnt2_reg   = MO_DMA24_CNT2,\n\t},\n\t[SRAM_CH25] = {\n\t\t.name       = \"audio from\",\n\t\t.cmds_start = 0x180140,\n\t\t.ctrl_start = 0x180680,\n\t\t.cdt        = 0x180680 + 64,\n\t\t.fifo_start = 0x185400,\n\t\t.fifo_size  = 0x001000,\n\t\t.ptr1_reg   = MO_DMA25_PTR1,\n\t\t.ptr2_reg   = MO_DMA25_PTR2,\n\t\t.cnt1_reg   = MO_DMA25_CNT1,\n\t\t.cnt2_reg   = MO_DMA25_CNT2,\n\t},\n\t[SRAM_CH26] = {\n\t\t.name       = \"audio to\",\n\t\t.cmds_start = 0x180180,\n\t\t.ctrl_start = 0x180720,\n\t\t.cdt        = 0x180680 + 64,   \n\t\t.fifo_start = 0x185400,        \n\t\t.fifo_size  = 0x001000,        \n\t\t.ptr1_reg   = MO_DMA26_PTR1,\n\t\t.ptr2_reg   = MO_DMA26_PTR2,\n\t\t.cnt1_reg   = MO_DMA26_CNT1,\n\t\t.cnt2_reg   = MO_DMA26_CNT2,\n\t},\n\t[SRAM_CH28] = {\n\t\t.name       = \"mpeg\",\n\t\t.cmds_start = 0x180200,\n\t\t.ctrl_start = 0x1807C0,\n\t\t.cdt        = 0x1807C0 + 64,\n\t\t.fifo_start = 0x186400,\n\t\t.fifo_size  = 0x001000,\n\t\t.ptr1_reg   = MO_DMA28_PTR1,\n\t\t.ptr2_reg   = MO_DMA28_PTR2,\n\t\t.cnt1_reg   = MO_DMA28_CNT1,\n\t\t.cnt2_reg   = MO_DMA28_CNT2,\n\t},\n\t[SRAM_CH27] = {\n\t\t.name       = \"audio rds\",\n\t\t.cmds_start = 0x1801C0,\n\t\t.ctrl_start = 0x180860,\n\t\t.cdt        = 0x180860 + 64,\n\t\t.fifo_start = 0x187400,\n\t\t.fifo_size  = 0x000C00,\n\t\t.ptr1_reg   = MO_DMA27_PTR1,\n\t\t.ptr2_reg   = MO_DMA27_PTR2,\n\t\t.cnt1_reg   = MO_DMA27_CNT1,\n\t\t.cnt2_reg   = MO_DMA27_CNT2,\n\t},\n};\nEXPORT_SYMBOL(cx88_sram_channels);\n\nint cx88_sram_channel_setup(struct cx88_core *core,\n\t\t\t    const struct sram_channel *ch,\n\t\t\t    unsigned int bpl, u32 risc)\n{\n\tunsigned int i, lines;\n\tu32 cdt;\n\n\tbpl   = (bpl + 7) & ~7;  \n\tcdt   = ch->cdt;\n\tlines = ch->fifo_size / bpl;\n\tif (lines > 6)\n\t\tlines = 6;\n\tWARN_ON(lines < 2);\n\n\t \n\tfor (i = 0; i < lines; i++)\n\t\tcx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\n\n\t \n\tcx_write(ch->cmds_start +  0, risc);\n\tcx_write(ch->cmds_start +  4, cdt);\n\tcx_write(ch->cmds_start +  8, (lines * 16) >> 3);\n\tcx_write(ch->cmds_start + 12, ch->ctrl_start);\n\tcx_write(ch->cmds_start + 16, 64 >> 2);\n\tfor (i = 20; i < 64; i += 4)\n\t\tcx_write(ch->cmds_start + i, 0);\n\n\t \n\tcx_write(ch->ptr1_reg, ch->fifo_start);\n\tcx_write(ch->ptr2_reg, cdt);\n\tcx_write(ch->cnt1_reg, (bpl >> 3) - 1);\n\tcx_write(ch->cnt2_reg, (lines * 16) >> 3);\n\n\tdprintk(2, \"sram setup %s: bpl=%d lines=%d\\n\", ch->name, bpl, lines);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_sram_channel_setup);\n\n \n \n\nstatic int cx88_risc_decode(u32 risc)\n{\n\tstatic const char * const instr[16] = {\n\t\t[RISC_SYNC    >> 28] = \"sync\",\n\t\t[RISC_WRITE   >> 28] = \"write\",\n\t\t[RISC_WRITEC  >> 28] = \"writec\",\n\t\t[RISC_READ    >> 28] = \"read\",\n\t\t[RISC_READC   >> 28] = \"readc\",\n\t\t[RISC_JUMP    >> 28] = \"jump\",\n\t\t[RISC_SKIP    >> 28] = \"skip\",\n\t\t[RISC_WRITERM >> 28] = \"writerm\",\n\t\t[RISC_WRITECM >> 28] = \"writecm\",\n\t\t[RISC_WRITECR >> 28] = \"writecr\",\n\t};\n\tstatic int const incr[16] = {\n\t\t[RISC_WRITE   >> 28] = 2,\n\t\t[RISC_JUMP    >> 28] = 2,\n\t\t[RISC_WRITERM >> 28] = 3,\n\t\t[RISC_WRITECM >> 28] = 3,\n\t\t[RISC_WRITECR >> 28] = 4,\n\t};\n\tstatic const char * const bits[] = {\n\t\t\"12\",   \"13\",   \"14\",   \"resync\",\n\t\t\"cnt0\", \"cnt1\", \"18\",   \"19\",\n\t\t\"20\",   \"21\",   \"22\",   \"23\",\n\t\t\"irq1\", \"irq2\", \"eol\",  \"sol\",\n\t};\n\tint i;\n\n\tdprintk0(\"0x%08x [ %s\", risc,\n\t\t instr[risc >> 28] ? instr[risc >> 28] : \"INVALID\");\n\tfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--)\n\t\tif (risc & (1 << (i + 12)))\n\t\t\tpr_cont(\" %s\", bits[i]);\n\tpr_cont(\" count=%d ]\\n\", risc & 0xfff);\n\treturn incr[risc >> 28] ? incr[risc >> 28] : 1;\n}\n\nvoid cx88_sram_channel_dump(struct cx88_core *core,\n\t\t\t    const struct sram_channel *ch)\n{\n\tstatic const char * const name[] = {\n\t\t\"initial risc\",\n\t\t\"cdt base\",\n\t\t\"cdt size\",\n\t\t\"iq base\",\n\t\t\"iq size\",\n\t\t\"risc pc\",\n\t\t\"iq wr ptr\",\n\t\t\"iq rd ptr\",\n\t\t\"cdt current\",\n\t\t\"pci target\",\n\t\t\"line / byte\",\n\t};\n\tu32 risc;\n\tunsigned int i, j, n;\n\n\tdprintk0(\"%s - dma channel status dump\\n\", ch->name);\n\tfor (i = 0; i < ARRAY_SIZE(name); i++)\n\t\tdprintk0(\"   cmds: %-12s: 0x%08x\\n\",\n\t\t\t name[i], cx_read(ch->cmds_start + 4 * i));\n\tfor (n = 1, i = 0; i < 4; i++) {\n\t\trisc = cx_read(ch->cmds_start + 4 * (i + 11));\n\t\tpr_cont(\"  risc%d: \", i);\n\t\tif (--n)\n\t\t\tpr_cont(\"0x%08x [ arg #%d ]\\n\", risc, n);\n\t\telse\n\t\t\tn = cx88_risc_decode(risc);\n\t}\n\tfor (i = 0; i < 16; i += n) {\n\t\trisc = cx_read(ch->ctrl_start + 4 * i);\n\t\tdprintk0(\"  iq %x: \", i);\n\t\tn = cx88_risc_decode(risc);\n\t\tfor (j = 1; j < n; j++) {\n\t\t\trisc = cx_read(ch->ctrl_start + 4 * (i + j));\n\t\t\tpr_cont(\"  iq %x: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\ti + j, risc, j);\n\t\t}\n\t}\n\n\tdprintk0(\"fifo: 0x%08x -> 0x%x\\n\",\n\t\t ch->fifo_start, ch->fifo_start + ch->fifo_size);\n\tdprintk0(\"ctrl: 0x%08x -> 0x%x\\n\",\n\t\t ch->ctrl_start, ch->ctrl_start + 6 * 16);\n\tdprintk0(\"  ptr1_reg: 0x%08x\\n\", cx_read(ch->ptr1_reg));\n\tdprintk0(\"  ptr2_reg: 0x%08x\\n\", cx_read(ch->ptr2_reg));\n\tdprintk0(\"  cnt1_reg: 0x%08x\\n\", cx_read(ch->cnt1_reg));\n\tdprintk0(\"  cnt2_reg: 0x%08x\\n\", cx_read(ch->cnt2_reg));\n}\nEXPORT_SYMBOL(cx88_sram_channel_dump);\n\nstatic const char *cx88_pci_irqs[32] = {\n\t\"vid\", \"aud\", \"ts\", \"vip\", \"hst\", \"5\", \"6\", \"tm1\",\n\t\"src_dma\", \"dst_dma\", \"risc_rd_err\", \"risc_wr_err\",\n\t\"brdg_err\", \"src_dma_err\", \"dst_dma_err\", \"ipb_dma_err\",\n\t\"i2c\", \"i2c_rack\", \"ir_smp\", \"gpio0\", \"gpio1\"\n};\n\nvoid cx88_print_irqbits(const char *tag, const char *strings[],\n\t\t\tint len, u32 bits, u32 mask)\n{\n\tunsigned int i;\n\n\tdprintk0(\"%s [0x%x]\", tag, bits);\n\tfor (i = 0; i < len; i++) {\n\t\tif (!(bits & (1 << i)))\n\t\t\tcontinue;\n\t\tif (strings[i])\n\t\t\tpr_cont(\" %s\", strings[i]);\n\t\telse\n\t\t\tpr_cont(\" %d\", i);\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\t\tpr_cont(\"*\");\n\t}\n\tpr_cont(\"\\n\");\n}\nEXPORT_SYMBOL(cx88_print_irqbits);\n\n \n\nint cx88_core_irq(struct cx88_core *core, u32 status)\n{\n\tint handled = 0;\n\n\tif (status & PCI_INT_IR_SMPINT) {\n\t\tcx88_ir_irq(core);\n\t\thandled++;\n\t}\n\tif (!handled)\n\t\tcx88_print_irqbits(\"irq pci\",\n\t\t\t\t   cx88_pci_irqs, ARRAY_SIZE(cx88_pci_irqs),\n\t\t\t\t   status, core->pci_irqmask);\n\treturn handled;\n}\nEXPORT_SYMBOL(cx88_core_irq);\n\nvoid cx88_wakeup(struct cx88_core *core,\n\t\t struct cx88_dmaqueue *q, u32 count)\n{\n\tstruct cx88_buffer *buf;\n\n\tbuf = list_entry(q->active.next,\n\t\t\t struct cx88_buffer, list);\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tbuf->vb.field = core->field;\n\tbuf->vb.sequence = q->count++;\n\tlist_del(&buf->list);\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\nEXPORT_SYMBOL(cx88_wakeup);\n\nvoid cx88_shutdown(struct cx88_core *core)\n{\n\t \n\tcx_write(MO_DEV_CNTRL2, 0);\n\n\t \n\tcx_write(MO_VID_DMACNTRL, 0x0);\n\tcx_write(MO_AUD_DMACNTRL, 0x0);\n\tcx_write(MO_TS_DMACNTRL, 0x0);\n\tcx_write(MO_VIP_DMACNTRL, 0x0);\n\tcx_write(MO_GPHST_DMACNTRL, 0x0);\n\n\t \n\tcx_write(MO_PCI_INTMSK, 0x0);\n\tcx_write(MO_VID_INTMSK, 0x0);\n\tcx_write(MO_AUD_INTMSK, 0x0);\n\tcx_write(MO_TS_INTMSK, 0x0);\n\tcx_write(MO_VIP_INTMSK, 0x0);\n\tcx_write(MO_GPHST_INTMSK, 0x0);\n\n\t \n\tcx_write(VID_CAPTURE_CONTROL, 0);\n}\nEXPORT_SYMBOL(cx88_shutdown);\n\nint cx88_reset(struct cx88_core *core)\n{\n\tdprintk(1, \"\");\n\tcx88_shutdown(core);\n\n\t \n\tcx_write(MO_VID_INTSTAT, 0xFFFFFFFF); \n\tcx_write(MO_PCI_INTSTAT, 0xFFFFFFFF); \n\tcx_write(MO_INT1_STAT,   0xFFFFFFFF); \n\n\t \n\tmsleep(100);\n\n\t \n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],\n\t\t\t\t720 * 4, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH22], 128, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH23], 128, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH24], 128, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH25], 128, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH26], 128, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],\n\t\t\t\t188 * 4, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH27], 128, 0);\n\n\t \n\tcx_write(MO_INPUT_FORMAT, ((1 << 13) |   \n\t\t\t\t   (1 << 12) |   \n\t\t\t\t   (1 << 11) |   \n\t\t\t\t   (0 << 10) |   \n\t\t\t\t   (0 <<  9) |   \n\t\t\t\t   (7)));\n\n\t \n\tcx_andor(MO_COLOR_CTRL, 0x4000, 0x4000);\n\n\t \n\tcx_write(MO_PDMA_STHRSH,   0x0807);\n\tcx_write(MO_PDMA_DTHRSH,   0x0807);\n\n\t \n\tcx_write(MO_AGC_SYNC_TIP1, 0x0380000F);\n\tcx_write(MO_AGC_BACK_VBI,  0x00E00555);\n\n\tcx_write(MO_VID_INTSTAT,   0xFFFFFFFF); \n\tcx_write(MO_PCI_INTSTAT,   0xFFFFFFFF); \n\tcx_write(MO_INT1_STAT,     0xFFFFFFFF); \n\n\t \n\tcx_write(MO_SRST_IO, 0);\n\tusleep_range(10000, 20000);\n\tcx_write(MO_SRST_IO, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_reset);\n\n \n\nstatic inline unsigned int norm_swidth(v4l2_std_id norm)\n{\n\tif (norm & (V4L2_STD_NTSC | V4L2_STD_PAL_M))\n\t\treturn 754;\n\n\tif (norm & V4L2_STD_PAL_Nc)\n\t\treturn 745;\n\n\treturn 922;\n}\n\nstatic inline unsigned int norm_hdelay(v4l2_std_id norm)\n{\n\tif (norm & (V4L2_STD_NTSC | V4L2_STD_PAL_M))\n\t\treturn 135;\n\n\tif (norm & V4L2_STD_PAL_Nc)\n\t\treturn 149;\n\n\treturn 186;\n}\n\nstatic inline unsigned int norm_vdelay(v4l2_std_id norm)\n{\n\treturn (norm & V4L2_STD_625_50) ? 0x24 : 0x18;\n}\n\nstatic inline unsigned int norm_fsc8(v4l2_std_id norm)\n{\n\tif (norm & V4L2_STD_PAL_M)\n\t\treturn 28604892;      \n\n\tif (norm & V4L2_STD_PAL_Nc)\n\t\treturn 28656448;      \n\n\tif (norm & V4L2_STD_NTSC) \n\t\treturn 28636360;      \n\n\t \n\n\treturn 35468950;      \n}\n\nstatic inline unsigned int norm_htotal(v4l2_std_id norm)\n{\n\tunsigned int fsc4 = norm_fsc8(norm) / 2;\n\n\t \n\treturn (norm & V4L2_STD_625_50) ?\n\t\t\t\t((fsc4 + 312) / 625 + 12) / 25 :\n\t\t\t\t((fsc4 + 262) / 525 * 1001 + 15000) / 30000;\n}\n\nstatic inline unsigned int norm_vbipack(v4l2_std_id norm)\n{\n\treturn (norm & V4L2_STD_625_50) ? 511 : 400;\n}\n\nint cx88_set_scale(struct cx88_core *core, unsigned int width,\n\t\t   unsigned int height, enum v4l2_field field)\n{\n\tunsigned int swidth  = norm_swidth(core->tvnorm);\n\tunsigned int sheight = norm_maxh(core->tvnorm);\n\tu32 value;\n\n\tdprintk(1, \"set_scale: %dx%d [%s%s,%s]\\n\", width, height,\n\t\tV4L2_FIELD_HAS_TOP(field)    ? \"T\" : \"\",\n\t\tV4L2_FIELD_HAS_BOTTOM(field) ? \"B\" : \"\",\n\t\tv4l2_norm_to_name(core->tvnorm));\n\tif (!V4L2_FIELD_HAS_BOTH(field))\n\t\theight *= 2;\n\n\t\n\tvalue = (width * norm_hdelay(core->tvnorm)) / swidth;\n\tvalue &= 0x3fe;\n\tcx_write(MO_HDELAY_EVEN,  value);\n\tcx_write(MO_HDELAY_ODD,   value);\n\tdprintk(1, \"set_scale: hdelay  0x%04x (width %d)\\n\", value, swidth);\n\n\tvalue = (swidth * 4096 / width) - 4096;\n\tcx_write(MO_HSCALE_EVEN,  value);\n\tcx_write(MO_HSCALE_ODD,   value);\n\tdprintk(1, \"set_scale: hscale  0x%04x\\n\", value);\n\n\tcx_write(MO_HACTIVE_EVEN, width);\n\tcx_write(MO_HACTIVE_ODD,  width);\n\tdprintk(1, \"set_scale: hactive 0x%04x\\n\", width);\n\n\t\n\tcx_write(MO_VDELAY_EVEN, norm_vdelay(core->tvnorm));\n\tcx_write(MO_VDELAY_ODD,  norm_vdelay(core->tvnorm));\n\tdprintk(1, \"set_scale: vdelay  0x%04x\\n\", norm_vdelay(core->tvnorm));\n\n\tvalue = (0x10000 - (sheight * 512 / height - 512)) & 0x1fff;\n\tcx_write(MO_VSCALE_EVEN,  value);\n\tcx_write(MO_VSCALE_ODD,   value);\n\tdprintk(1, \"set_scale: vscale  0x%04x\\n\", value);\n\n\tcx_write(MO_VACTIVE_EVEN, sheight);\n\tcx_write(MO_VACTIVE_ODD,  sheight);\n\tdprintk(1, \"set_scale: vactive 0x%04x\\n\", sheight);\n\n\t\n\tvalue = 0;\n\tvalue |= (1 << 19);        \n\tif (core->tvnorm & V4L2_STD_SECAM) {\n\t\tvalue |= (1 << 15);\n\t\tvalue |= (1 << 16);\n\t}\n\tif (INPUT(core->input).type == CX88_VMUX_SVIDEO)\n\t\tvalue |= (1 << 13) | (1 << 5);\n\tif (field == V4L2_FIELD_INTERLACED)\n\t\tvalue |= (1 << 3); \n\tif (width < 385)\n\t\tvalue |= (1 << 0); \n\tif (width < 193)\n\t\tvalue |= (1 << 1); \n\tif (nocomb)\n\t\tvalue |= (3 << 5); \n\n\tcx_andor(MO_FILTER_EVEN,  0x7ffc7f, value);  \n\tcx_andor(MO_FILTER_ODD,   0x7ffc7f, value);\n\tdprintk(1, \"set_scale: filter  0x%04x\\n\", value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_set_scale);\n\nstatic const u32 xtal = 28636363;\n\nstatic int set_pll(struct cx88_core *core, int prescale, u32 ofreq)\n{\n\tstatic const u32 pre[] = { 0, 0, 0, 3, 2, 1 };\n\tu64 pll;\n\tu32 reg;\n\tint i;\n\n\tif (prescale < 2)\n\t\tprescale = 2;\n\tif (prescale > 5)\n\t\tprescale = 5;\n\n\tpll = ofreq * 8 * prescale * (u64)(1 << 20);\n\tdo_div(pll, xtal);\n\treg = (pll & 0x3ffffff) | (pre[prescale] << 26);\n\tif (((reg >> 20) & 0x3f) < 14) {\n\t\tpr_err(\"pll out of range\\n\");\n\t\treturn -1;\n\t}\n\n\tdprintk(1, \"set_pll:    MO_PLL_REG       0x%08x [old=0x%08x,freq=%d]\\n\",\n\t\treg, cx_read(MO_PLL_REG), ofreq);\n\tcx_write(MO_PLL_REG, reg);\n\tfor (i = 0; i < 100; i++) {\n\t\treg = cx_read(MO_DEVICE_STATUS);\n\t\tif (reg & (1 << 2)) {\n\t\t\tdprintk(1, \"pll locked [pre=%d,ofreq=%d]\\n\",\n\t\t\t\tprescale, ofreq);\n\t\t\treturn 0;\n\t\t}\n\t\tdprintk(1, \"pll not locked yet, waiting ...\\n\");\n\t\tusleep_range(10000, 20000);\n\t}\n\tdprintk(1, \"pll NOT locked [pre=%d,ofreq=%d]\\n\", prescale, ofreq);\n\treturn -1;\n}\n\nint cx88_start_audio_dma(struct cx88_core *core)\n{\n\t \n\tint bpl = cx88_sram_channels[SRAM_CH25].fifo_size / 4;\n\n\tint rds_bpl = cx88_sram_channels[SRAM_CH27].fifo_size / AUD_RDS_LINES;\n\n\t \n\tif (cx_read(MO_AUD_DMACNTRL) & 0x10)\n\t\treturn 0;\n\n\t \n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH25], bpl, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH26], bpl, 0);\n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH27],\n\t\t\t\trds_bpl, 0);\n\n\tcx_write(MO_AUDD_LNGTH, bpl);  \n\tcx_write(MO_AUDR_LNGTH, rds_bpl);  \n\n\t \n\tcx_write(MO_AUD_DMACNTRL, 0x0007);\n\n\treturn 0;\n}\n\nint cx88_stop_audio_dma(struct cx88_core *core)\n{\n\t \n\tif (cx_read(MO_AUD_DMACNTRL) & 0x10)\n\t\treturn 0;\n\n\t \n\tcx_write(MO_AUD_DMACNTRL, 0x0000);\n\n\treturn 0;\n}\n\nstatic int set_tvaudio(struct cx88_core *core)\n{\n\tv4l2_std_id norm = core->tvnorm;\n\n\tif (INPUT(core->input).type != CX88_VMUX_TELEVISION &&\n\t    INPUT(core->input).type != CX88_VMUX_CABLE)\n\t\treturn 0;\n\n\tif (V4L2_STD_PAL_BG & norm) {\n\t\tcore->tvaudio = WW_BG;\n\n\t} else if (V4L2_STD_PAL_DK & norm) {\n\t\tcore->tvaudio = WW_DK;\n\n\t} else if (V4L2_STD_PAL_I & norm) {\n\t\tcore->tvaudio = WW_I;\n\n\t} else if (V4L2_STD_SECAM_L & norm) {\n\t\tcore->tvaudio = WW_L;\n\n\t} else if ((V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H) &\n\t\t   norm) {\n\t\tcore->tvaudio = WW_BG;\n\n\t} else if (V4L2_STD_SECAM_DK & norm) {\n\t\tcore->tvaudio = WW_DK;\n\n\t} else if ((V4L2_STD_NTSC_M | V4L2_STD_PAL_M | V4L2_STD_PAL_Nc) &\n\t\t   norm) {\n\t\tcore->tvaudio = WW_BTSC;\n\n\t} else if (V4L2_STD_NTSC_M_JP & norm) {\n\t\tcore->tvaudio = WW_EIAJ;\n\n\t} else {\n\t\tpr_info(\"tvaudio support needs work for this tv norm [%s], sorry\\n\",\n\t\t\tv4l2_norm_to_name(core->tvnorm));\n\t\tcore->tvaudio = WW_NONE;\n\t\treturn 0;\n\t}\n\n\tcx_andor(MO_AFECFG_IO, 0x1f, 0x0);\n\tcx88_set_tvaudio(core);\n\t \n\n \n\tcx88_start_audio_dma(core);\n\treturn 0;\n}\n\nint cx88_set_tvnorm(struct cx88_core *core, v4l2_std_id norm)\n{\n\tu32 fsc8;\n\tu32 adc_clock;\n\tu32 vdec_clock;\n\tu32 step_db, step_dr;\n\tu64 tmp64;\n\tu32 bdelay, agcdelay, htotal;\n\tu32 cxiformat, cxoformat;\n\n\tif (norm == core->tvnorm)\n\t\treturn 0;\n\tif (core->v4ldev && (vb2_is_busy(&core->v4ldev->vb2_vidq) ||\n\t\t\t     vb2_is_busy(&core->v4ldev->vb2_vbiq)))\n\t\treturn -EBUSY;\n\tif (core->dvbdev && vb2_is_busy(&core->dvbdev->vb2_mpegq))\n\t\treturn -EBUSY;\n\tcore->tvnorm = norm;\n\tfsc8       = norm_fsc8(norm);\n\tadc_clock  = xtal;\n\tvdec_clock = fsc8;\n\tstep_db    = fsc8;\n\tstep_dr    = fsc8;\n\n\tif (norm & V4L2_STD_NTSC_M_JP) {\n\t\tcxiformat = VideoFormatNTSCJapan;\n\t\tcxoformat = 0x181f0008;\n\t} else if (norm & V4L2_STD_NTSC_443) {\n\t\tcxiformat = VideoFormatNTSC443;\n\t\tcxoformat = 0x181f0008;\n\t} else if (norm & V4L2_STD_PAL_M) {\n\t\tcxiformat = VideoFormatPALM;\n\t\tcxoformat = 0x1c1f0008;\n\t} else if (norm & V4L2_STD_PAL_N) {\n\t\tcxiformat = VideoFormatPALN;\n\t\tcxoformat = 0x1c1f0008;\n\t} else if (norm & V4L2_STD_PAL_Nc) {\n\t\tcxiformat = VideoFormatPALNC;\n\t\tcxoformat = 0x1c1f0008;\n\t} else if (norm & V4L2_STD_PAL_60) {\n\t\tcxiformat = VideoFormatPAL60;\n\t\tcxoformat = 0x181f0008;\n\t} else if (norm & V4L2_STD_NTSC) {\n\t\tcxiformat = VideoFormatNTSC;\n\t\tcxoformat = 0x181f0008;\n\t} else if (norm & V4L2_STD_SECAM) {\n\t\tstep_db = 4250000 * 8;\n\t\tstep_dr = 4406250 * 8;\n\n\t\tcxiformat = VideoFormatSECAM;\n\t\tcxoformat = 0x181f0008;\n\t} else {  \n\t\tcxiformat = VideoFormatPAL;\n\t\tcxoformat = 0x181f0008;\n\t}\n\n\tdprintk(1, \"set_tvnorm: \\\"%s\\\" fsc8=%d adc=%d vdec=%d db/dr=%d/%d\\n\",\n\t\tv4l2_norm_to_name(core->tvnorm), fsc8, adc_clock, vdec_clock,\n\t\tstep_db, step_dr);\n\tset_pll(core, 2, vdec_clock);\n\n\tdprintk(1, \"set_tvnorm: MO_INPUT_FORMAT  0x%08x [old=0x%08x]\\n\",\n\t\tcxiformat, cx_read(MO_INPUT_FORMAT) & 0x0f);\n\t \n\tcx_andor(MO_INPUT_FORMAT, 0x40f,\n\t\t norm & V4L2_STD_SECAM ? cxiformat : cxiformat | 0x400);\n\n\t\n\tdprintk(1, \"set_tvnorm: MO_OUTPUT_FORMAT 0x%08x [old=0x%08x]\\n\",\n\t\tcxoformat, cx_read(MO_OUTPUT_FORMAT));\n\tcx_write(MO_OUTPUT_FORMAT, cxoformat);\n\n\t\n\ttmp64  = adc_clock * (u64)(1 << 17);\n\tdo_div(tmp64, vdec_clock);\n\tdprintk(1, \"set_tvnorm: MO_SCONV_REG     0x%08x [old=0x%08x]\\n\",\n\t\t(u32)tmp64, cx_read(MO_SCONV_REG));\n\tcx_write(MO_SCONV_REG, (u32)tmp64);\n\n\t\n\ttmp64  = step_db * (u64)(1 << 22);\n\tdo_div(tmp64, vdec_clock);\n\tdprintk(1, \"set_tvnorm: MO_SUB_STEP      0x%08x [old=0x%08x]\\n\",\n\t\t(u32)tmp64, cx_read(MO_SUB_STEP));\n\tcx_write(MO_SUB_STEP, (u32)tmp64);\n\n\t\n\ttmp64  = step_dr * (u64)(1 << 22);\n\tdo_div(tmp64, vdec_clock);\n\tdprintk(1, \"set_tvnorm: MO_SUB_STEP_DR   0x%08x [old=0x%08x]\\n\",\n\t\t(u32)tmp64, cx_read(MO_SUB_STEP_DR));\n\tcx_write(MO_SUB_STEP_DR, (u32)tmp64);\n\n\t\n\tbdelay   = vdec_clock * 65 / 20000000 + 21;\n\tagcdelay = vdec_clock * 68 / 20000000 + 15;\n\tdprintk(1,\n\t\t\"set_tvnorm: MO_AGC_BURST     0x%08x [old=0x%08x,bdelay=%d,agcdelay=%d]\\n\",\n\t\t(bdelay << 8) | agcdelay, cx_read(MO_AGC_BURST),\n\t\tbdelay, agcdelay);\n\tcx_write(MO_AGC_BURST, (bdelay << 8) | agcdelay);\n\n\t\n\ttmp64 = norm_htotal(norm) * (u64)vdec_clock;\n\tdo_div(tmp64, fsc8);\n\thtotal = (u32)tmp64;\n\tdprintk(1,\n\t\t\"set_tvnorm: MO_HTOTAL        0x%08x [old=0x%08x,htotal=%d]\\n\",\n\t\thtotal, cx_read(MO_HTOTAL), (u32)tmp64);\n\tcx_andor(MO_HTOTAL, 0x07ff, htotal);\n\n\t\n\t\n\tcx_write(MO_VBI_PACKET, (10 << 11) | norm_vbipack(norm));\n\n\t\n\tcx88_set_scale(core, 320, 240, V4L2_FIELD_INTERLACED);\n\n\t\n\tset_tvaudio(core);\n\n\t\n\tcall_all(core, video, s_std, norm);\n\n\t \n\tv4l2_ctrl_grab(core->chroma_agc, cxiformat == VideoFormatSECAM);\n\n\t\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_set_tvnorm);\n\n \n\nvoid cx88_vdev_init(struct cx88_core *core,\n\t\t    struct pci_dev *pci,\n\t\t    struct video_device *vfd,\n\t\t    const struct video_device *template_,\n\t\t    const char *type)\n{\n\t*vfd = *template_;\n\n\t \n\tvfd->v4l2_dev = &core->v4l2_dev;\n\tvfd->dev_parent = &pci->dev;\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &core->lock;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\",\n\t\t core->name, type, core->board.name);\n}\nEXPORT_SYMBOL(cx88_vdev_init);\n\nstruct cx88_core *cx88_core_get(struct pci_dev *pci)\n{\n\tstruct cx88_core *core;\n\n\tmutex_lock(&devlist);\n\tlist_for_each_entry(core, &cx88_devlist, devlist) {\n\t\tif (pci->bus->number != core->pci_bus)\n\t\t\tcontinue;\n\t\tif (PCI_SLOT(pci->devfn) != core->pci_slot)\n\t\t\tcontinue;\n\n\t\tif (cx88_get_resources(core, pci) != 0) {\n\t\t\tmutex_unlock(&devlist);\n\t\t\treturn NULL;\n\t\t}\n\t\trefcount_inc(&core->refcount);\n\t\tmutex_unlock(&devlist);\n\t\treturn core;\n\t}\n\n\tcore = cx88_core_create(pci, cx88_devcount);\n\tif (core) {\n\t\tcx88_devcount++;\n\t\tlist_add_tail(&core->devlist, &cx88_devlist);\n\t}\n\n\tmutex_unlock(&devlist);\n\treturn core;\n}\nEXPORT_SYMBOL(cx88_core_get);\n\nvoid cx88_core_put(struct cx88_core *core, struct pci_dev *pci)\n{\n\trelease_mem_region(pci_resource_start(pci, 0),\n\t\t\t   pci_resource_len(pci, 0));\n\n\tif (!refcount_dec_and_test(&core->refcount))\n\t\treturn;\n\n\tmutex_lock(&devlist);\n\tcx88_ir_fini(core);\n\tif (core->i2c_rc == 0) {\n\t\ti2c_unregister_device(core->i2c_rtc);\n\t\ti2c_del_adapter(&core->i2c_adap);\n\t}\n\tlist_del(&core->devlist);\n\tiounmap(core->lmmio);\n\tcx88_devcount--;\n\tmutex_unlock(&devlist);\n\tv4l2_ctrl_handler_free(&core->video_hdl);\n\tv4l2_ctrl_handler_free(&core->audio_hdl);\n\tv4l2_device_unregister(&core->v4l2_dev);\n\tkfree(core);\n}\nEXPORT_SYMBOL(cx88_core_put);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}