{
  "module_name": "cx88-input.c",
  "hash_id": "0ca52d5d8e8a6920212f638cea1a23c5e773913dd5f387b4ecffeb30595ece16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-input.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <media/rc-core.h>\n\n#define MODULE_NAME \"cx88xx\"\n\n \n\nstruct cx88_IR {\n\tstruct cx88_core *core;\n\tstruct rc_dev *dev;\n\n\tint users;\n\n\tchar name[32];\n\tchar phys[32];\n\n\t \n\tu32 sampling;\n\n\t \n\tint polling;\n\tstruct hrtimer timer;\n\tu32 gpio_addr;\n\tu32 last_gpio;\n\tu32 mask_keycode;\n\tu32 mask_keydown;\n\tu32 mask_keyup;\n};\n\nstatic unsigned int ir_samplerate = 4;\nmodule_param(ir_samplerate, uint, 0444);\nMODULE_PARM_DESC(ir_samplerate, \"IR samplerate in kHz, 1 - 20, default 4\");\n\nstatic int ir_debug;\nmodule_param(ir_debug, int, 0644);\t \nMODULE_PARM_DESC(ir_debug, \"enable debug messages [IR]\");\n\n#define ir_dprintk(fmt, arg...)\tdo {\t\t\t\t\t\\\n\tif (ir_debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s IR: \" fmt, ir->core->name, ##arg);\\\n} while (0)\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (ir_debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"cx88 IR: \" fmt, ##arg);\t\t\\\n} while (0)\n\n \n\nstatic void cx88_ir_handle_key(struct cx88_IR *ir)\n{\n\tstruct cx88_core *core = ir->core;\n\tu32 gpio, data, auxgpio;\n\n\t \n\tgpio = cx_read(ir->gpio_addr);\n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_NPGTECH_REALTV_TOP10FM:\n\t\t \n\n\t\tauxgpio = cx_read(MO_GP1_IO);\n\t\t \n\t\tgpio = (gpio & 0x7fd) + (auxgpio & 0xef);\n\t\tbreak;\n\tcase CX88_BOARD_WINFAST_DTV1000:\n\tcase CX88_BOARD_WINFAST_DTV1800H:\n\tcase CX88_BOARD_WINFAST_DTV1800H_XC4000:\n\tcase CX88_BOARD_WINFAST_DTV2000H_PLUS:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43:\n\t\tgpio = (gpio & 0x6ff) | ((cx_read(MO_GP1_IO) << 8) & 0x900);\n\t\tauxgpio = gpio;\n\t\tbreak;\n\tdefault:\n\t\tauxgpio = gpio;\n\t}\n\tif (ir->polling) {\n\t\tif (ir->last_gpio == auxgpio)\n\t\t\treturn;\n\t\tir->last_gpio = auxgpio;\n\t}\n\n\t \n\tdata = ir_extract_bits(gpio, ir->mask_keycode);\n\tir_dprintk(\"irq gpio=0x%x code=%d | %s%s%s\\n\",\n\t\t   gpio, data,\n\t\t   ir->polling ? \"poll\" : \"irq\",\n\t\t   (gpio & ir->mask_keydown) ? \" down\" : \"\",\n\t\t   (gpio & ir->mask_keyup) ? \" up\" : \"\");\n\n\tif (ir->core->boardnr == CX88_BOARD_NORWOOD_MICRO) {\n\t\tu32 gpio_key = cx_read(MO_GP0_IO);\n\n\t\tdata = (data << 4) | ((gpio_key & 0xf0) >> 4);\n\n\t\trc_keydown(ir->dev, RC_PROTO_UNKNOWN, data, 0);\n\n\t} else if (ir->core->boardnr == CX88_BOARD_PROLINK_PLAYTVPVR ||\n\t\t   ir->core->boardnr == CX88_BOARD_PIXELVIEW_PLAYTV_ULTRA_PRO) {\n\t\t \n\t\tu16 addr;\n\t\tu8 cmd;\n\t\tu32 scancode;\n\n\t\taddr = (data >> 8) & 0xffff;\n\t\tcmd  = (data >> 0) & 0x00ff;\n\t\tscancode = RC_SCANCODE_NECX(addr, cmd);\n\n\t\tif (0 == (gpio & ir->mask_keyup))\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_NECX, scancode,\n\t\t\t\t\t     0);\n\t\telse\n\t\t\trc_keyup(ir->dev);\n\n\t} else if (ir->mask_keydown) {\n\t\t \n\t\tif (gpio & ir->mask_keydown)\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t\telse\n\t\t\trc_keyup(ir->dev);\n\n\t} else if (ir->mask_keyup) {\n\t\t \n\t\tif (0 == (gpio & ir->mask_keyup))\n\t\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data,\n\t\t\t\t\t     0);\n\t\telse\n\t\t\trc_keyup(ir->dev);\n\n\t} else {\n\t\t \n\t\trc_keydown_notimeout(ir->dev, RC_PROTO_UNKNOWN, data, 0);\n\t\trc_keyup(ir->dev);\n\t}\n}\n\nstatic enum hrtimer_restart cx88_ir_work(struct hrtimer *timer)\n{\n\tu64 missed;\n\tstruct cx88_IR *ir = container_of(timer, struct cx88_IR, timer);\n\n\tcx88_ir_handle_key(ir);\n\tmissed = hrtimer_forward_now(&ir->timer,\n\t\t\t\t     ktime_set(0, ir->polling * 1000000));\n\tif (missed > 1)\n\t\tir_dprintk(\"Missed ticks %llu\\n\", missed - 1);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int __cx88_ir_start(void *priv)\n{\n\tstruct cx88_core *core = priv;\n\tstruct cx88_IR *ir;\n\n\tif (!core || !core->ir)\n\t\treturn -EINVAL;\n\n\tir = core->ir;\n\n\tif (ir->polling) {\n\t\thrtimer_init(&ir->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\tir->timer.function = cx88_ir_work;\n\t\thrtimer_start(&ir->timer,\n\t\t\t      ktime_set(0, ir->polling * 1000000),\n\t\t\t      HRTIMER_MODE_REL);\n\t}\n\tif (ir->sampling) {\n\t\tcore->pci_irqmask |= PCI_INT_IR_SMPINT;\n\t\tcx_write(MO_DDS_IO, 0x33F286 * ir_samplerate);  \n\t\tcx_write(MO_DDSCFG_IO, 0x5);  \n\t}\n\treturn 0;\n}\n\nstatic void __cx88_ir_stop(void *priv)\n{\n\tstruct cx88_core *core = priv;\n\tstruct cx88_IR *ir;\n\n\tif (!core || !core->ir)\n\t\treturn;\n\n\tir = core->ir;\n\tif (ir->sampling) {\n\t\tcx_write(MO_DDSCFG_IO, 0x0);\n\t\tcore->pci_irqmask &= ~PCI_INT_IR_SMPINT;\n\t}\n\n\tif (ir->polling)\n\t\thrtimer_cancel(&ir->timer);\n}\n\nint cx88_ir_start(struct cx88_core *core)\n{\n\tif (core->ir->users)\n\t\treturn __cx88_ir_start(core);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_ir_start);\n\nvoid cx88_ir_stop(struct cx88_core *core)\n{\n\tif (core->ir->users)\n\t\t__cx88_ir_stop(core);\n}\nEXPORT_SYMBOL(cx88_ir_stop);\n\nstatic int cx88_ir_open(struct rc_dev *rc)\n{\n\tstruct cx88_core *core = rc->priv;\n\n\tcore->ir->users++;\n\treturn __cx88_ir_start(core);\n}\n\nstatic void cx88_ir_close(struct rc_dev *rc)\n{\n\tstruct cx88_core *core = rc->priv;\n\n\tcore->ir->users--;\n\tif (!core->ir->users)\n\t\t__cx88_ir_stop(core);\n}\n\n \n\nint cx88_ir_init(struct cx88_core *core, struct pci_dev *pci)\n{\n\tstruct cx88_IR *ir;\n\tstruct rc_dev *dev;\n\tchar *ir_codes = NULL;\n\tu64 rc_proto = RC_PROTO_BIT_OTHER;\n\tint err = -ENOMEM;\n\tu32 hardware_mask = 0;\t \n\n\tir = kzalloc(sizeof(*ir), GFP_KERNEL);\n\tdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!ir || !dev)\n\t\tgoto err_out_free;\n\n\tir->dev = dev;\n\n\t \n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_DNTV_LIVE_DVB_T:\n\tcase CX88_BOARD_KWORLD_DVB_T:\n\tcase CX88_BOARD_KWORLD_DVB_T_CX22702:\n\t\tir_codes = RC_MAP_DNTV_LIVE_DVB_T;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keycode = 0x1f;\n\t\tir->mask_keyup = 0x60;\n\t\tir->polling = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_TERRATEC_CINERGY_1400_DVB_T1:\n\t\tir_codes = RC_MAP_CINERGY_1400;\n\t\tir->sampling = 0xeb04;  \n\t\tbreak;\n\tcase CX88_BOARD_HAUPPAUGE:\n\tcase CX88_BOARD_HAUPPAUGE_DVB_T1:\n\tcase CX88_BOARD_HAUPPAUGE_NOVASE2_S1:\n\tcase CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:\n\tcase CX88_BOARD_HAUPPAUGE_HVR1100:\n\tcase CX88_BOARD_HAUPPAUGE_HVR3000:\n\tcase CX88_BOARD_HAUPPAUGE_HVR4000:\n\tcase CX88_BOARD_HAUPPAUGE_HVR4000LITE:\n\tcase CX88_BOARD_PCHDTV_HD3000:\n\tcase CX88_BOARD_PCHDTV_HD5500:\n\tcase CX88_BOARD_HAUPPAUGE_IRONLY:\n\t\tir_codes = RC_MAP_HAUPPAUGE;\n\t\tir->sampling = 1;\n\t\tbreak;\n\tcase CX88_BOARD_WINFAST_DTV2000H:\n\tcase CX88_BOARD_WINFAST_DTV2000H_J:\n\tcase CX88_BOARD_WINFAST_DTV1800H:\n\tcase CX88_BOARD_WINFAST_DTV1800H_XC4000:\n\tcase CX88_BOARD_WINFAST_DTV2000H_PLUS:\n\t\tir_codes = RC_MAP_WINFAST;\n\t\tir->gpio_addr = MO_GP0_IO;\n\t\tir->mask_keycode = 0x8f8;\n\t\tir->mask_keyup = 0x100;\n\t\tir->polling = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_WINFAST2000XP_EXPERT:\n\tcase CX88_BOARD_WINFAST_DTV1000:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36:\n\tcase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43:\n\t\tir_codes = RC_MAP_WINFAST;\n\t\tir->gpio_addr = MO_GP0_IO;\n\t\tir->mask_keycode = 0x8f8;\n\t\tir->mask_keyup = 0x100;\n\t\tir->polling = 1;  \n\t\tbreak;\n\tcase CX88_BOARD_IODATA_GVBCTV7E:\n\t\tir_codes = RC_MAP_IODATA_BCTV7E;\n\t\tir->gpio_addr = MO_GP0_IO;\n\t\tir->mask_keycode = 0xfd;\n\t\tir->mask_keydown = 0x02;\n\t\tir->polling = 5;  \n\t\tbreak;\n\tcase CX88_BOARD_PROLINK_PLAYTVPVR:\n\tcase CX88_BOARD_PIXELVIEW_PLAYTV_ULTRA_PRO:\n\t\t \n\t\tir_codes = RC_MAP_PIXELVIEW_MK12;\n\t\trc_proto = RC_PROTO_BIT_NECX;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keyup = 0x80;\n\t\tir->polling = 10;  \n\t\thardware_mask = 0x3f;\t \n\t\tbreak;\n\tcase CX88_BOARD_PROLINK_PV_8000GT:\n\tcase CX88_BOARD_PROLINK_PV_GLOBAL_XTREME:\n\t\tir_codes = RC_MAP_PIXELVIEW_NEW;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keycode = 0x3f;\n\t\tir->mask_keyup = 0x80;\n\t\tir->polling = 1;  \n\t\tbreak;\n\tcase CX88_BOARD_KWORLD_LTV883:\n\t\tir_codes = RC_MAP_PIXELVIEW;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keycode = 0x1f;\n\t\tir->mask_keyup = 0x60;\n\t\tir->polling = 1;  \n\t\tbreak;\n\tcase CX88_BOARD_ADSTECH_DVB_T_PCI:\n\t\tir_codes = RC_MAP_ADSTECH_DVB_T_PCI;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keycode = 0xbf;\n\t\tir->mask_keyup = 0x40;\n\t\tir->polling = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_MSI_TVANYWHERE_MASTER:\n\t\tir_codes = RC_MAP_MSI_TVANYWHERE;\n\t\tir->gpio_addr = MO_GP1_IO;\n\t\tir->mask_keycode = 0x1f;\n\t\tir->mask_keyup = 0x40;\n\t\tir->polling = 1;  \n\t\tbreak;\n\tcase CX88_BOARD_AVERTV_303:\n\tcase CX88_BOARD_AVERTV_STUDIO_303:\n\t\tir_codes         = RC_MAP_AVERTV_303;\n\t\tir->gpio_addr    = MO_GP2_IO;\n\t\tir->mask_keycode = 0xfb;\n\t\tir->mask_keydown = 0x02;\n\t\tir->polling      = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_OMICOM_SS4_PCI:\n\tcase CX88_BOARD_SATTRADE_ST4200:\n\tcase CX88_BOARD_TBS_8920:\n\tcase CX88_BOARD_TBS_8910:\n\tcase CX88_BOARD_PROF_7300:\n\tcase CX88_BOARD_PROF_7301:\n\tcase CX88_BOARD_PROF_6200:\n\t\tir_codes = RC_MAP_TBS_NEC;\n\t\tir->sampling = 0xff00;  \n\t\tbreak;\n\tcase CX88_BOARD_TEVII_S464:\n\tcase CX88_BOARD_TEVII_S460:\n\tcase CX88_BOARD_TEVII_S420:\n\t\tir_codes = RC_MAP_TEVII_NEC;\n\t\tir->sampling = 0xff00;  \n\t\tbreak;\n\tcase CX88_BOARD_DNTV_LIVE_DVB_T_PRO:\n\t\tir_codes         = RC_MAP_DNTV_LIVE_DVBT_PRO;\n\t\tir->sampling     = 0xff00;  \n\t\tbreak;\n\tcase CX88_BOARD_NORWOOD_MICRO:\n\t\tir_codes         = RC_MAP_NORWOOD;\n\t\tir->gpio_addr    = MO_GP1_IO;\n\t\tir->mask_keycode = 0x0e;\n\t\tir->mask_keyup   = 0x80;\n\t\tir->polling      = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_NPGTECH_REALTV_TOP10FM:\n\t\tir_codes         = RC_MAP_NPGTECH;\n\t\tir->gpio_addr    = MO_GP0_IO;\n\t\tir->mask_keycode = 0xfa;\n\t\tir->polling      = 50;  \n\t\tbreak;\n\tcase CX88_BOARD_PINNACLE_PCTV_HD_800i:\n\t\tir_codes         = RC_MAP_PINNACLE_PCTV_HD;\n\t\tir->sampling     = 1;\n\t\tbreak;\n\tcase CX88_BOARD_POWERCOLOR_REAL_ANGEL:\n\t\tir_codes         = RC_MAP_POWERCOLOR_REAL_ANGEL;\n\t\tir->gpio_addr    = MO_GP2_IO;\n\t\tir->mask_keycode = 0x7e;\n\t\tir->polling      = 100;  \n\t\tbreak;\n\tcase CX88_BOARD_TWINHAN_VP1027_DVBS:\n\t\tir_codes         = RC_MAP_TWINHAN_VP1027_DVBS;\n\t\tir->sampling     = 0xff00;  \n\t\tbreak;\n\t}\n\n\tif (!ir_codes) {\n\t\terr = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\t \n\tif (hardware_mask && !ir->mask_keycode)\n\t\tir->mask_keycode = hardware_mask;\n\n\t \n\tsnprintf(ir->name, sizeof(ir->name), \"cx88 IR (%s)\", core->board.name);\n\tsnprintf(ir->phys, sizeof(ir->phys), \"pci-%s/ir0\", pci_name(pci));\n\n\tdev->device_name = ir->name;\n\tdev->input_phys = ir->phys;\n\tdev->input_id.bustype = BUS_PCI;\n\tdev->input_id.version = 1;\n\tif (pci->subsystem_vendor) {\n\t\tdev->input_id.vendor = pci->subsystem_vendor;\n\t\tdev->input_id.product = pci->subsystem_device;\n\t} else {\n\t\tdev->input_id.vendor = pci->vendor;\n\t\tdev->input_id.product = pci->device;\n\t}\n\tdev->dev.parent = &pci->dev;\n\tdev->map_name = ir_codes;\n\tdev->driver_name = MODULE_NAME;\n\tdev->priv = core;\n\tdev->open = cx88_ir_open;\n\tdev->close = cx88_ir_close;\n\tdev->scancode_mask = hardware_mask;\n\n\tif (ir->sampling) {\n\t\tdev->timeout = MS_TO_US(10);  \n\t} else {\n\t\tdev->driver_type = RC_DRIVER_SCANCODE;\n\t\tdev->allowed_protocols = rc_proto;\n\t}\n\n\tir->core = core;\n\tcore->ir = ir;\n\n\t \n\terr = rc_register_device(dev);\n\tif (err)\n\t\tgoto err_out_free;\n\n\treturn 0;\n\nerr_out_free:\n\trc_free_device(dev);\n\tcore->ir = NULL;\n\tkfree(ir);\n\treturn err;\n}\n\nint cx88_ir_fini(struct cx88_core *core)\n{\n\tstruct cx88_IR *ir = core->ir;\n\n\t \n\tif (!ir)\n\t\treturn 0;\n\n\tcx88_ir_stop(core);\n\trc_unregister_device(ir->dev);\n\tkfree(ir);\n\n\t \n\tcore->ir = NULL;\n\treturn 0;\n}\n\n \n\nvoid cx88_ir_irq(struct cx88_core *core)\n{\n\tstruct cx88_IR *ir = core->ir;\n\tu32 samples;\n\tunsigned int todo, bits;\n\tstruct ir_raw_event ev = {};\n\n\tif (!ir || !ir->sampling)\n\t\treturn;\n\n\t \n\tsamples = cx_read(MO_SAMPLE_IO);\n\n\tif (samples == 0xff && ir->dev->idle)\n\t\treturn;\n\n\tfor (todo = 32; todo > 0; todo -= bits) {\n\t\tev.pulse = samples & 0x80000000 ? false : true;\n\t\tbits = min(todo, 32U - fls(ev.pulse ? samples : ~samples));\n\t\tev.duration = (bits * (USEC_PER_SEC / 1000)) / ir_samplerate;\n\t\tir_raw_event_store_with_filter(ir->dev, &ev);\n\t\tsamples <<= bits;\n\t}\n\tir_raw_event_handle(ir->dev);\n}\n\nstatic int get_key_pvr2000(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t   u32 *scancode, u8 *toggle)\n{\n\tint flags, code;\n\n\t \n\tflags = i2c_smbus_read_byte_data(ir->c, 0x10);\n\tif (flags < 0) {\n\t\tdprintk(\"read error\\n\");\n\t\treturn 0;\n\t}\n\t \n\tif (0 == (flags & 0x80))\n\t\treturn 0;\n\n\t \n\tcode = i2c_smbus_read_byte_data(ir->c, 0x00);\n\tif (code < 0) {\n\t\tdprintk(\"read error\\n\");\n\t\treturn 0;\n\t}\n\n\tdprintk(\"IR Key/Flags: (0x%02x/0x%02x)\\n\",\n\t\tcode & 0xff, flags & 0xff);\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = code & 0xff;\n\t*toggle = 0;\n\treturn 1;\n}\n\nvoid cx88_i2c_init_ir(struct cx88_core *core)\n{\n\tstruct i2c_board_info info;\n\tstatic const unsigned short default_addr_list[] = {\n\t\t0x18, 0x33, 0x6b, 0x71,\n\t\tI2C_CLIENT_END\n\t};\n\tstatic const unsigned short pvr2000_addr_list[] = {\n\t\t0x18, 0x1a,\n\t\tI2C_CLIENT_END\n\t};\n\tconst unsigned short *addr_list = default_addr_list;\n\tconst unsigned short *addrp;\n\t \n\tif (core->i2c_rc != 0)\n\t\treturn;\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_LEADTEK_PVR2000:\n\t\taddr_list = pvr2000_addr_list;\n\t\tcore->init_data.name = \"cx88 Leadtek PVR 2000 remote\";\n\t\tcore->init_data.type = RC_PROTO_BIT_UNKNOWN;\n\t\tcore->init_data.get_key = get_key_pvr2000;\n\t\tcore->init_data.ir_codes = RC_MAP_EMPTY;\n\t\tbreak;\n\t}\n\n\t \n\tfor (addrp = addr_list; *addrp != I2C_CLIENT_END; addrp++) {\n\t\tinfo.platform_data = NULL;\n\t\tmemset(&core->init_data, 0, sizeof(core->init_data));\n\n\t\tif (*addrp == 0x71) {\n\t\t\t \n\t\t\tstrscpy(info.type, \"ir_z8f0811_haup\", I2C_NAME_SIZE);\n\t\t\tcore->init_data.name = core->board.name;\n\t\t\tcore->init_data.ir_codes = RC_MAP_HAUPPAUGE;\n\t\t\tcore->init_data.type = RC_PROTO_BIT_RC5 |\n\t\t\t\tRC_PROTO_BIT_RC6_MCE | RC_PROTO_BIT_RC6_6A_32;\n\t\t\tcore->init_data.internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\n\t\t\tinfo.platform_data = &core->init_data;\n\t\t}\n\t\tif (i2c_smbus_xfer(&core->i2c_adap, *addrp, 0,\n\t\t\t\t   I2C_SMBUS_READ, 0,\n\t\t\t\t   I2C_SMBUS_QUICK, NULL) >= 0) {\n\t\t\tinfo.addr = *addrp;\n\t\t\ti2c_new_client_device(&core->i2c_adap, &info);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\nMODULE_AUTHOR(\"Gerd Knorr, Pavel Machek, Chris Pascoe\");\nMODULE_DESCRIPTION(\"input driver for cx88 GPIO-based IR remote controls\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}