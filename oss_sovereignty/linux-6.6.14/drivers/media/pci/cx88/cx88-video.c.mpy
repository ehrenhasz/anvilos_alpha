{
  "module_name": "cx88-video.c",
  "hash_id": "6d4df8a03ab8ffee97615075b08f167372f45f7b64cf821953bf672e27a131fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-video.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <asm/div64.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/i2c/wm8775.h>\n\nMODULE_DESCRIPTION(\"v4l2 driver module for cx2388x based TV cards\");\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(CX88_VERSION);\n\n \n\nstatic unsigned int video_nr[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int vbi_nr[]   = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };\nstatic unsigned int radio_nr[] = {[0 ... (CX88_MAXBOARDS - 1)] = UNSET };\n\nmodule_param_array(video_nr, int, NULL, 0444);\nmodule_param_array(vbi_nr,   int, NULL, 0444);\nmodule_param_array(radio_nr, int, NULL, 0444);\n\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\nMODULE_PARM_DESC(vbi_nr, \"vbi device numbers\");\nMODULE_PARM_DESC(radio_nr, \"radio device numbers\");\n\nstatic unsigned int video_debug;\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug, \"enable debug messages [video]\");\n\nstatic unsigned int irq_debug;\nmodule_param(irq_debug, int, 0644);\nMODULE_PARM_DESC(irq_debug, \"enable debug messages [IRQ handler]\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\\\n\tif (video_debug >= level)\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: video:\" fmt),\t\\\n\t\t\t__func__, ##arg);\t\t\t\\\n} while (0)\n\n \n \n\nstatic const struct cx8800_fmt formats[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_GREY,\n\t\t.cxformat = ColorFormatY8,\n\t\t.depth    = 8,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555,\n\t\t.cxformat = ColorFormatRGB15,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB555X,\n\t\t.cxformat = ColorFormatRGB15 | ColorFormatBSWAP,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565,\n\t\t.cxformat = ColorFormatRGB16,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565X,\n\t\t.cxformat = ColorFormatRGB16 | ColorFormatBSWAP,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_BGR24,\n\t\t.cxformat = ColorFormatRGB24,\n\t\t.depth    = 24,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_BGR32,\n\t\t.cxformat = ColorFormatRGB32,\n\t\t.depth    = 32,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB32,\n\t\t.cxformat = ColorFormatRGB32 | ColorFormatBSWAP |\n\t\t\t    ColorFormatWSWAP,\n\t\t.depth    = 32,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_YUYV,\n\t\t.cxformat = ColorFormatYUY2,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_UYVY,\n\t\t.cxformat = ColorFormatYUY2 | ColorFormatBSWAP,\n\t\t.depth    = 16,\n\t\t.flags    = FORMAT_FLAGS_PACKED,\n\t},\n};\n\nstatic const struct cx8800_fmt *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\treturn NULL;\n}\n\n \n\nstruct cx88_ctrl {\n\t \n\tu32 id;\n\ts32 minimum;\n\ts32 maximum;\n\tu32 step;\n\ts32 default_value;\n\n\t \n\tu32 off;\n\tu32 reg;\n\tu32 sreg;\n\tu32 mask;\n\tu32 shift;\n};\n\nstatic const struct cx88_ctrl cx8800_vid_ctls[] = {\n\t \n\t{\n\t\t.id            = V4L2_CID_BRIGHTNESS,\n\t\t.minimum       = 0x00,\n\t\t.maximum       = 0xff,\n\t\t.step          = 1,\n\t\t.default_value = 0x7f,\n\t\t.off           = 128,\n\t\t.reg           = MO_CONTR_BRIGHT,\n\t\t.mask          = 0x00ff,\n\t\t.shift         = 0,\n\t}, {\n\t\t.id            = V4L2_CID_CONTRAST,\n\t\t.minimum       = 0,\n\t\t.maximum       = 0xff,\n\t\t.step          = 1,\n\t\t.default_value = 0x3f,\n\t\t.off           = 0,\n\t\t.reg           = MO_CONTR_BRIGHT,\n\t\t.mask          = 0xff00,\n\t\t.shift         = 8,\n\t}, {\n\t\t.id            = V4L2_CID_HUE,\n\t\t.minimum       = 0,\n\t\t.maximum       = 0xff,\n\t\t.step          = 1,\n\t\t.default_value = 0x7f,\n\t\t.off           = 128,\n\t\t.reg           = MO_HUE,\n\t\t.mask          = 0x00ff,\n\t\t.shift         = 0,\n\t}, {\n\t\t \n\t\t.id            = V4L2_CID_SATURATION,\n\t\t.minimum       = 0,\n\t\t.maximum       = 0xff,\n\t\t.step          = 1,\n\t\t.default_value = 0x7f,\n\t\t.off           = 0,\n\t\t.reg           = MO_UV_SATURATION,\n\t\t.mask          = 0x00ff,\n\t\t.shift         = 0,\n\t}, {\n\t\t.id            = V4L2_CID_SHARPNESS,\n\t\t.minimum       = 0,\n\t\t.maximum       = 4,\n\t\t.step          = 1,\n\t\t.default_value = 0x0,\n\t\t.off           = 0,\n\t\t \n\t\t.reg           = MO_FILTER_ODD,\n\t\t.mask          = 7 << 7,\n\t\t.shift         = 7,\n\t}, {\n\t\t.id            = V4L2_CID_CHROMA_AGC,\n\t\t.minimum       = 0,\n\t\t.maximum       = 1,\n\t\t.default_value = 0x1,\n\t\t.reg           = MO_INPUT_FORMAT,\n\t\t.mask          = 1 << 10,\n\t\t.shift         = 10,\n\t}, {\n\t\t.id            = V4L2_CID_COLOR_KILLER,\n\t\t.minimum       = 0,\n\t\t.maximum       = 1,\n\t\t.default_value = 0x1,\n\t\t.reg           = MO_INPUT_FORMAT,\n\t\t.mask          = 1 << 9,\n\t\t.shift         = 9,\n\t}, {\n\t\t.id            = V4L2_CID_BAND_STOP_FILTER,\n\t\t.minimum       = 0,\n\t\t.maximum       = 1,\n\t\t.step          = 1,\n\t\t.default_value = 0x0,\n\t\t.off           = 0,\n\t\t.reg           = MO_HTOTAL,\n\t\t.mask          = 3 << 11,\n\t\t.shift         = 11,\n\t}\n};\n\nstatic const struct cx88_ctrl cx8800_aud_ctls[] = {\n\t{\n\t\t \n\t\t.id            = V4L2_CID_AUDIO_MUTE,\n\t\t.minimum       = 0,\n\t\t.maximum       = 1,\n\t\t.default_value = 1,\n\t\t.reg           = AUD_VOL_CTL,\n\t\t.sreg          = SHADOW_AUD_VOL_CTL,\n\t\t.mask          = (1 << 6),\n\t\t.shift         = 6,\n\t}, {\n\t\t.id            = V4L2_CID_AUDIO_VOLUME,\n\t\t.minimum       = 0,\n\t\t.maximum       = 0x3f,\n\t\t.step          = 1,\n\t\t.default_value = 0x3f,\n\t\t.reg           = AUD_VOL_CTL,\n\t\t.sreg          = SHADOW_AUD_VOL_CTL,\n\t\t.mask          = 0x3f,\n\t\t.shift         = 0,\n\t}, {\n\t\t.id            = V4L2_CID_AUDIO_BALANCE,\n\t\t.minimum       = 0,\n\t\t.maximum       = 0x7f,\n\t\t.step          = 1,\n\t\t.default_value = 0x40,\n\t\t.reg           = AUD_BAL_CTL,\n\t\t.sreg          = SHADOW_AUD_BAL_CTL,\n\t\t.mask          = 0x7f,\n\t\t.shift         = 0,\n\t}\n};\n\nenum {\n\tCX8800_VID_CTLS = ARRAY_SIZE(cx8800_vid_ctls),\n\tCX8800_AUD_CTLS = ARRAY_SIZE(cx8800_aud_ctls),\n};\n\n \n\nint cx88_video_mux(struct cx88_core *core, unsigned int input)\n{\n\t \n\n\tdprintk(1, \"video_mux: %d [vmux=%d,gpio=0x%x,0x%x,0x%x,0x%x]\\n\",\n\t\tinput, INPUT(input).vmux,\n\t\tINPUT(input).gpio0, INPUT(input).gpio1,\n\t\tINPUT(input).gpio2, INPUT(input).gpio3);\n\tcore->input = input;\n\tcx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input).vmux << 14);\n\tcx_write(MO_GP3_IO, INPUT(input).gpio3);\n\tcx_write(MO_GP0_IO, INPUT(input).gpio0);\n\tcx_write(MO_GP1_IO, INPUT(input).gpio1);\n\tcx_write(MO_GP2_IO, INPUT(input).gpio2);\n\n\tswitch (INPUT(input).type) {\n\tcase CX88_VMUX_SVIDEO:\n\t\tcx_set(MO_AFECFG_IO,    0x00000001);\n\t\tcx_set(MO_INPUT_FORMAT, 0x00010010);\n\t\tcx_set(MO_FILTER_EVEN,  0x00002020);\n\t\tcx_set(MO_FILTER_ODD,   0x00002020);\n\t\tbreak;\n\tdefault:\n\t\tcx_clear(MO_AFECFG_IO,    0x00000001);\n\t\tcx_clear(MO_INPUT_FORMAT, 0x00010010);\n\t\tcx_clear(MO_FILTER_EVEN,  0x00002020);\n\t\tcx_clear(MO_FILTER_ODD,   0x00002020);\n\t\tbreak;\n\t}\n\n\t \n\tif (INPUT(input).audioroute) {\n\t\t \n\t\tif (core->sd_wm8775) {\n\t\t\tcall_all(core, audio, s_routing,\n\t\t\t\t INPUT(input).audioroute, 0, 0);\n\t\t}\n\t\t \n\t\tif (INPUT(input).type != CX88_VMUX_TELEVISION &&\n\t\t    INPUT(input).type != CX88_VMUX_CABLE) {\n\t\t\t \n\t\t\tcore->tvaudio = WW_I2SADC;\n\t\t\tcx88_set_tvaudio(core);\n\t\t} else {\n\t\t\t \n\t\t\tcx_write(AUD_I2SCNTL, 0x0);\n\t\t\tcx_clear(AUD_CTL, EN_I2SIN_ENABLE);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_video_mux);\n\n \n\nstatic int start_video_dma(struct cx8800_dev    *dev,\n\t\t\t   struct cx88_dmaqueue *q,\n\t\t\t   struct cx88_buffer   *buf)\n{\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tcx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],\n\t\t\t\tbuf->bpl, buf->risc.dma);\n\tcx88_set_scale(core, core->width, core->height, core->field);\n\tcx_write(MO_COLOR_CTRL, dev->fmt->cxformat | ColorFormatGamma);\n\n\t \n\tcx_write(MO_VIDY_GPCNTRL, GP_COUNT_CONTROL_RESET);\n\tq->count = 0;\n\n\t \n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_VIDINT);\n\n\t \n\tcx_set(MO_VID_INTMSK, 0x0f0011);\n\n\t \n\tcx_set(VID_CAPTURE_CONTROL, 0x06);\n\n\t \n\tcx_set(MO_DEV_CNTRL2, (1 << 5));\n\tcx_set(MO_VID_DMACNTRL, 0x11);  \n\n\treturn 0;\n}\n\nstatic int __maybe_unused stop_video_dma(struct cx8800_dev    *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tcx_clear(MO_VID_DMACNTRL, 0x11);\n\n\t \n\tcx_clear(VID_CAPTURE_CONTROL, 0x06);\n\n\t \n\tcx_clear(MO_PCI_INTMSK, PCI_INT_VIDINT);\n\tcx_clear(MO_VID_INTMSK, 0x0f0011);\n\treturn 0;\n}\n\nstatic int __maybe_unused restart_video_queue(struct cx8800_dev *dev,\n\t\t\t\t\t      struct cx88_dmaqueue *q)\n{\n\tstruct cx88_buffer *buf;\n\n\tif (!list_empty(&q->active)) {\n\t\tbuf = list_entry(q->active.next, struct cx88_buffer, list);\n\t\tdprintk(2, \"restart_queue [%p/%d]: restart dma\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\t\tstart_video_dma(dev, q, buf);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\tstruct cx88_core *core = dev->core;\n\n\t*num_planes = 1;\n\tsizes[0] = (dev->fmt->depth * core->width * core->height) >> 3;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tint ret;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_core *core = dev->core;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\n\tbuf->bpl = core->width * dev->fmt->depth >> 3;\n\n\tif (vb2_plane_size(vb, 0) < core->height * buf->bpl)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, core->height * buf->bpl);\n\n\tswitch (core->field) {\n\tcase V4L2_FIELD_TOP:\n\t\tret = cx88_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\t       sgt->sgl, 0, UNSET,\n\t\t\t\t       buf->bpl, 0, core->height);\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tret = cx88_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\t       sgt->sgl, UNSET, 0,\n\t\t\t\t       buf->bpl, 0, core->height);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tret = cx88_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\t       sgt->sgl,\n\t\t\t\t       0, buf->bpl * (core->height >> 1),\n\t\t\t\t       buf->bpl, 0,\n\t\t\t\t       core->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tret = cx88_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\t       sgt->sgl,\n\t\t\t\t       buf->bpl * (core->height >> 1), 0,\n\t\t\t\t       buf->bpl, 0,\n\t\t\t\t       core->height >> 1);\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\tdefault:\n\t\tret = cx88_risc_buffer(dev->pci, &buf->risc,\n\t\t\t\t       sgt->sgl, 0, buf->bpl,\n\t\t\t\t       buf->bpl, buf->bpl,\n\t\t\t\t       core->height >> 1);\n\t\tbreak;\n\t}\n\tdprintk(2,\n\t\t\"[%p/%d] %s - %dx%d %dbpp 0x%08x - dma=0x%08lx\\n\",\n\t\tbuf, buf->vb.vb2_buf.index, __func__,\n\t\tcore->width, core->height, dev->fmt->depth, dev->fmt->fourcc,\n\t\t(unsigned long)buf->risc.dma);\n\treturn ret;\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct cx88_riscmem *risc = &buf->risc;\n\n\tif (risc->cpu)\n\t\tdma_free_coherent(&dev->pci->dev, risc->size, risc->cpu,\n\t\t\t\t  risc->dma);\n\tmemset(risc, 0, sizeof(*risc));\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer    *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct cx88_buffer    *prev;\n\tstruct cx88_dmaqueue  *q    = &dev->vidq;\n\n\t \n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);\n\n\tif (list_empty(&q->active)) {\n\t\tlist_add_tail(&buf->list, &q->active);\n\t\tdprintk(2, \"[%p/%d] buffer_queue - first active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tprev = list_entry(q->active.prev, struct cx88_buffer, list);\n\t\tlist_add_tail(&buf->list, &q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t\tdprintk(2, \"[%p/%d] buffer_queue - append to active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\t}\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\tstruct cx88_dmaqueue *dmaq = &dev->vidq;\n\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\tstart_video_dma(dev, dmaq, buf);\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\tstruct cx88_core *core = dev->core;\n\tstruct cx88_dmaqueue *dmaq = &dev->vidq;\n\tunsigned long flags;\n\n\tcx_clear(MO_VID_DMACNTRL, 0x11);\n\tcx_clear(VID_CAPTURE_CONTROL, 0x06);\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic const struct vb2_ops cx8800_video_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n};\n\n \n\nstatic int radio_open(struct file *file)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tint ret = v4l2_fh_open(file);\n\n\tif (ret)\n\t\treturn ret;\n\n\tcx_write(MO_GP3_IO, core->board.radio.gpio3);\n\tcx_write(MO_GP0_IO, core->board.radio.gpio0);\n\tcx_write(MO_GP1_IO, core->board.radio.gpio1);\n\tcx_write(MO_GP2_IO, core->board.radio.gpio2);\n\tif (core->board.radio.audioroute) {\n\t\tif (core->sd_wm8775) {\n\t\t\tcall_all(core, audio, s_routing,\n\t\t\t\t core->board.radio.audioroute, 0, 0);\n\t\t}\n\t\t \n\t\tcore->tvaudio = WW_I2SADC;\n\t\tcx88_set_tvaudio(core);\n\t} else {\n\t\t \n\t\tcore->tvaudio = WW_FM;\n\t\tcx88_set_tvaudio(core);\n\t\tcx88_set_stereo(core, V4L2_TUNER_MODE_STEREO, 1);\n\t}\n\tcall_all(core, tuner, s_radio);\n\treturn 0;\n}\n\n \n \n\nstatic int cx8800_s_vid_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct cx88_core *core =\n\t\tcontainer_of(ctrl->handler, struct cx88_core, video_hdl);\n\tconst struct cx88_ctrl *cc = ctrl->priv;\n\tu32 value, mask;\n\n\tmask = cc->mask;\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_SATURATION:\n\t\t \n\n\t\tvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\n\n\t\tif (core->tvnorm & V4L2_STD_SECAM) {\n\t\t\t \n\t\t\tvalue = value << 8 | value;\n\t\t} else {\n\t\t\t \n\t\t\tvalue = (value * 0x5a) / 0x7f << 8 | value;\n\t\t}\n\t\tmask = 0xffff;\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\t \n\t\tvalue = (ctrl->val < 1 ? 0 : ((ctrl->val + 3) << 7));\n\t\t \n\t\tcx_andor(MO_FILTER_EVEN, mask, value);\n\t\tbreak;\n\tcase V4L2_CID_CHROMA_AGC:\n\t\tvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\n\t\tbreak;\n\tdefault:\n\t\tvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\n\t\tbreak;\n\t}\n\tdprintk(1,\n\t\t\"set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\\n\",\n\t\tctrl->id, ctrl->name, ctrl->val, cc->reg, value,\n\t\tmask, cc->sreg ? \" [shadowed]\" : \"\");\n\tif (cc->sreg)\n\t\tcx_sandor(cc->sreg, cc->reg, mask, value);\n\telse\n\t\tcx_andor(cc->reg, mask, value);\n\treturn 0;\n}\n\nstatic int cx8800_s_aud_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct cx88_core *core =\n\t\tcontainer_of(ctrl->handler, struct cx88_core, audio_hdl);\n\tconst struct cx88_ctrl *cc = ctrl->priv;\n\tu32 value, mask;\n\n\t \n\tif (core->sd_wm8775) {\n\t\tswitch (ctrl->id) {\n\t\tcase V4L2_CID_AUDIO_MUTE:\n\t\t\twm8775_s_ctrl(core, ctrl->id, ctrl->val);\n\t\t\tbreak;\n\t\tcase V4L2_CID_AUDIO_VOLUME:\n\t\t\twm8775_s_ctrl(core, ctrl->id, (ctrl->val) ?\n\t\t\t\t\t\t(0x90 + ctrl->val) << 8 : 0);\n\t\t\tbreak;\n\t\tcase V4L2_CID_AUDIO_BALANCE:\n\t\t\twm8775_s_ctrl(core, ctrl->id, ctrl->val << 9);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmask = cc->mask;\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t\tvalue = (ctrl->val < 0x40) ?\n\t\t\t(0x7f - ctrl->val) : (ctrl->val - 0x40);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tvalue = 0x3f - (ctrl->val & 0x3f);\n\t\tbreak;\n\tdefault:\n\t\tvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\n\t\tbreak;\n\t}\n\tdprintk(1,\n\t\t\"set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\\n\",\n\t\tctrl->id, ctrl->name, ctrl->val, cc->reg, value,\n\t\tmask, cc->sreg ? \" [shadowed]\" : \"\");\n\tif (cc->sreg)\n\t\tcx_sandor(cc->sreg, cc->reg, mask, value);\n\telse\n\t\tcx_andor(cc->reg, mask, value);\n\treturn 0;\n}\n\n \n \n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tf->fmt.pix.width        = core->width;\n\tf->fmt.pix.height       = core->height;\n\tf->fmt.pix.field        = core->field;\n\tf->fmt.pix.pixelformat  = dev->fmt->fourcc;\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * dev->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tconst struct cx8800_fmt *fmt;\n\tenum v4l2_field   field;\n\tunsigned int      maxw, maxh;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tmaxw = norm_maxw(core->tvnorm);\n\tmaxh = norm_maxh(core->tvnorm);\n\n\tfield = f->fmt.pix.field;\n\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tbreak;\n\tdefault:\n\t\tfield = (f->fmt.pix.height > maxh / 2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\t}\n\tif (V4L2_FIELD_HAS_T_OR_B(field))\n\t\tmaxh /= 2;\n\n\tv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\n\t\t\t      &f->fmt.pix.height, 32, maxh, 0, 0);\n\tf->fmt.pix.field = field;\n\tf->fmt.pix.bytesperline =\n\t\t(f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tint err = vidioc_try_fmt_vid_cap(file, priv, f);\n\n\tif (err != 0)\n\t\treturn err;\n\tif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq))\n\t\treturn -EBUSY;\n\tif (core->dvbdev && vb2_is_busy(&core->dvbdev->vb2_mpegq))\n\t\treturn -EBUSY;\n\tdev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tcore->width = f->fmt.pix.width;\n\tcore->height = f->fmt.pix.height;\n\tcore->field = f->fmt.pix.field;\n\treturn 0;\n}\n\nint cx88_querycap(struct file *file, struct cx88_core *core,\n\t\t  struct v4l2_capability *cap)\n{\n\tstrscpy(cap->card, core->board.name, sizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VBI_CAPTURE |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\tif (core->board.tuner_type != UNSET)\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\tif (core->board.radio.type == CX88_RADIO)\n\t\tcap->capabilities |= V4L2_CAP_RADIO;\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_querycap);\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tstrscpy(cap->driver, \"cx8800\", sizeof(cap->driver));\n\treturn cx88_querycap(file, core, cap);\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (unlikely(f->index >= ARRAY_SIZE(formats)))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\t*tvnorm = core->tvnorm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id tvnorms)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\treturn cx88_set_tvnorm(core, tvnorms);\n}\n\n \nint cx88_enum_input(struct cx88_core  *core, struct v4l2_input *i)\n{\n\tstatic const char * const iname[] = {\n\t\t[CX88_VMUX_COMPOSITE1] = \"Composite1\",\n\t\t[CX88_VMUX_COMPOSITE2] = \"Composite2\",\n\t\t[CX88_VMUX_COMPOSITE3] = \"Composite3\",\n\t\t[CX88_VMUX_COMPOSITE4] = \"Composite4\",\n\t\t[CX88_VMUX_SVIDEO] = \"S-Video\",\n\t\t[CX88_VMUX_TELEVISION] = \"Television\",\n\t\t[CX88_VMUX_CABLE] = \"Cable TV\",\n\t\t[CX88_VMUX_DVB] = \"DVB\",\n\t\t[CX88_VMUX_DEBUG] = \"for debug only\",\n\t};\n\tunsigned int n = i->index;\n\n\tif (n >= 4)\n\t\treturn -EINVAL;\n\tif (!INPUT(n).type)\n\t\treturn -EINVAL;\n\ti->type  = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(i->name, iname[INPUT(n).type], sizeof(i->name));\n\tif ((INPUT(n).type == CX88_VMUX_TELEVISION) ||\n\t    (INPUT(n).type == CX88_VMUX_CABLE))\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\n\ti->std = CX88_NORMS;\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_enum_input);\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\treturn cx88_enum_input(core, i);\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\t*i = core->input;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (i >= 4)\n\t\treturn -EINVAL;\n\tif (!INPUT(i).type)\n\t\treturn -EINVAL;\n\n\tcx88_newstation(core);\n\tcx88_video_mux(core, i);\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t  struct v4l2_tuner *t)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tu32 reg;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\tt->capability = V4L2_TUNER_CAP_NORM;\n\tt->rangehigh  = 0xffffffffUL;\n\tcall_all(core, tuner, g_tuner, t);\n\n\tcx88_get_stereo(core, t);\n\treg = cx_read(MO_DEVICE_STATUS);\n\tt->signal = (reg & (1 << 5)) ? 0xffff : 0x0000;\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t  const struct v4l2_tuner *t)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (core->board.tuner_type == UNSET)\n\t\treturn -EINVAL;\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tcx88_set_stereo(core, t->audmode, 1);\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t      struct v4l2_frequency *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tf->frequency = core->freq;\n\n\tcall_all(core, tuner, g_frequency, f);\n\n\treturn 0;\n}\n\nint cx88_set_freq(struct cx88_core  *core,\n\t\t  const struct v4l2_frequency *f)\n{\n\tstruct v4l2_frequency new_freq = *f;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (unlikely(f->tuner != 0))\n\t\treturn -EINVAL;\n\n\tcx88_newstation(core);\n\tcall_all(core, tuner, s_frequency, f);\n\tcall_all(core, tuner, g_frequency, &new_freq);\n\tcore->freq = new_freq.frequency;\n\n\t \n\tusleep_range(10000, 20000);\n\tcx88_set_tvaudio(core);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx88_set_freq);\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\treturn cx88_set_freq(core, f);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register(struct file *file, void *fh,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\t \n\treg->val = cx_read(reg->reg & 0xfffffc);\n\treg->size = 4;\n\treturn 0;\n}\n\nstatic int vidioc_s_register(struct file *file, void *fh,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tcx_write(reg->reg & 0xfffffc, reg->val);\n\treturn 0;\n}\n#endif\n\n \n \n \n\nstatic int radio_g_tuner(struct file *file, void *priv,\n\t\t\t struct v4l2_tuner *t)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (unlikely(t->index > 0))\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Radio\", sizeof(t->name));\n\n\tcall_all(core, tuner, g_tuner, t);\n\treturn 0;\n}\n\nstatic int radio_s_tuner(struct file *file, void *priv,\n\t\t\t const struct v4l2_tuner *t)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tcall_all(core, tuner, s_tuner, t);\n\treturn 0;\n}\n\n \n\nstatic const char *cx88_vid_irqs[32] = {\n\t\"y_risci1\", \"u_risci1\", \"v_risci1\", \"vbi_risc1\",\n\t\"y_risci2\", \"u_risci2\", \"v_risci2\", \"vbi_risc2\",\n\t\"y_oflow\",  \"u_oflow\",  \"v_oflow\",  \"vbi_oflow\",\n\t\"y_sync\",   \"u_sync\",   \"v_sync\",   \"vbi_sync\",\n\t\"opc_err\",  \"par_err\",  \"rip_err\",  \"pci_abort\",\n};\n\nstatic void cx8800_vid_irq(struct cx8800_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\tu32 status, mask, count;\n\n\tstatus = cx_read(MO_VID_INTSTAT);\n\tmask   = cx_read(MO_VID_INTMSK);\n\tif (0 == (status & mask))\n\t\treturn;\n\tcx_write(MO_VID_INTSTAT, status);\n\tif (irq_debug  ||  (status & mask & ~0xff))\n\t\tcx88_print_irqbits(\"irq vid\",\n\t\t\t\t   cx88_vid_irqs, ARRAY_SIZE(cx88_vid_irqs),\n\t\t\t\t   status, mask);\n\n\t \n\tif (status & (1 << 16)) {\n\t\tpr_warn(\"video risc op code error\\n\");\n\t\tcx_clear(MO_VID_DMACNTRL, 0x11);\n\t\tcx_clear(VID_CAPTURE_CONTROL, 0x06);\n\t\tcx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);\n\t}\n\n\t \n\tif (status & 0x01) {\n\t\tspin_lock(&dev->slock);\n\t\tcount = cx_read(MO_VIDY_GPCNT);\n\t\tcx88_wakeup(core, &dev->vidq, count);\n\t\tspin_unlock(&dev->slock);\n\t}\n\n\t \n\tif (status & 0x08) {\n\t\tspin_lock(&dev->slock);\n\t\tcount = cx_read(MO_VBI_GPCNT);\n\t\tcx88_wakeup(core, &dev->vbiq, count);\n\t\tspin_unlock(&dev->slock);\n\t}\n}\n\nstatic irqreturn_t cx8800_irq(int irq, void *dev_id)\n{\n\tstruct cx8800_dev *dev = dev_id;\n\tstruct cx88_core *core = dev->core;\n\tu32 status;\n\tint loop, handled = 0;\n\n\tfor (loop = 0; loop < 10; loop++) {\n\t\tstatus = cx_read(MO_PCI_INTSTAT) &\n\t\t\t(core->pci_irqmask | PCI_INT_VIDINT);\n\t\tif (status == 0)\n\t\t\tgoto out;\n\t\tcx_write(MO_PCI_INTSTAT, status);\n\t\thandled = 1;\n\n\t\tif (status & core->pci_irqmask)\n\t\t\tcx88_core_irq(core, status);\n\t\tif (status & PCI_INT_VIDINT)\n\t\t\tcx8800_vid_irq(dev);\n\t}\n\tif (loop == 10) {\n\t\tpr_warn(\"irq loop -- clearing mask\\n\");\n\t\tcx_write(MO_PCI_INTMSK, 0);\n\t}\n\n out:\n\treturn IRQ_RETVAL(handled);\n}\n\n \n \n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner\t       = THIS_MODULE,\n\t.open\t       = v4l2_fh_open,\n\t.release       = vb2_fop_release,\n\t.read\t       = vb2_fop_read,\n\t.poll          = vb2_fop_poll,\n\t.mmap\t       = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_g_std         = vidioc_g_std,\n\t.vidioc_s_std         = vidioc_s_std,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner       = vidioc_g_tuner,\n\t.vidioc_s_tuner       = vidioc_s_tuner,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n\t.vidioc_subscribe_event      = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event    = v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register    = vidioc_g_register,\n\t.vidioc_s_register    = vidioc_s_register,\n#endif\n};\n\nstatic const struct video_device cx8800_video_template = {\n\t.name                 = \"cx8800-video\",\n\t.fops                 = &video_fops,\n\t.ioctl_ops\t      = &video_ioctl_ops,\n\t.tvnorms              = CX88_NORMS,\n};\n\nstatic const struct v4l2_ioctl_ops vbi_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_g_fmt_vbi_cap     = cx8800_vbi_fmt,\n\t.vidioc_try_fmt_vbi_cap   = cx8800_vbi_fmt,\n\t.vidioc_s_fmt_vbi_cap     = cx8800_vbi_fmt,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_g_std         = vidioc_g_std,\n\t.vidioc_s_std         = vidioc_s_std,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner       = vidioc_g_tuner,\n\t.vidioc_s_tuner       = vidioc_s_tuner,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register    = vidioc_g_register,\n\t.vidioc_s_register    = vidioc_s_register,\n#endif\n};\n\nstatic const struct video_device cx8800_vbi_template = {\n\t.name                 = \"cx8800-vbi\",\n\t.fops                 = &video_fops,\n\t.ioctl_ops\t      = &vbi_ioctl_ops,\n\t.tvnorms              = CX88_NORMS,\n};\n\nstatic const struct v4l2_file_operations radio_fops = {\n\t.owner         = THIS_MODULE,\n\t.open          = radio_open,\n\t.poll          = v4l2_ctrl_poll,\n\t.release       = v4l2_fh_release,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops radio_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_g_tuner       = radio_g_tuner,\n\t.vidioc_s_tuner       = radio_s_tuner,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n\t.vidioc_subscribe_event      = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event    = v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register    = vidioc_g_register,\n\t.vidioc_s_register    = vidioc_s_register,\n#endif\n};\n\nstatic const struct video_device cx8800_radio_template = {\n\t.name                 = \"cx8800-radio\",\n\t.fops                 = &radio_fops,\n\t.ioctl_ops\t      = &radio_ioctl_ops,\n};\n\nstatic const struct v4l2_ctrl_ops cx8800_ctrl_vid_ops = {\n\t.s_ctrl = cx8800_s_vid_ctrl,\n};\n\nstatic const struct v4l2_ctrl_ops cx8800_ctrl_aud_ops = {\n\t.s_ctrl = cx8800_s_aud_ctrl,\n};\n\n \n\nstatic void cx8800_unregister_video(struct cx8800_dev *dev)\n{\n\tvideo_unregister_device(&dev->radio_dev);\n\tvideo_unregister_device(&dev->vbi_dev);\n\tvideo_unregister_device(&dev->video_dev);\n}\n\nstatic int cx8800_initdev(struct pci_dev *pci_dev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct cx8800_dev *dev;\n\tstruct cx88_core *core;\n\tstruct vb2_queue *q;\n\tint err;\n\tint i;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto fail_free;\n\t}\n\tcore = cx88_core_get(dev->pci);\n\tif (!core) {\n\t\terr = -EINVAL;\n\t\tgoto fail_disable;\n\t}\n\tdev->core = core;\n\n\t \n\tdev->pci_rev = pci_dev->revision;\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tpr_info(\"found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tpci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t\tdev->pci_lat,\n\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tpr_err(\"Oops: no 32bit PCI DMA ???\\n\");\n\t\tgoto fail_core;\n\t}\n\n\t \n\tspin_lock_init(&dev->slock);\n\n\t \n\tINIT_LIST_HEAD(&dev->vidq.active);\n\n\t \n\tINIT_LIST_HEAD(&dev->vbiq.active);\n\n\t \n\terr = request_irq(pci_dev->irq, cx8800_irq,\n\t\t\t  IRQF_SHARED, core->name, dev);\n\tif (err < 0) {\n\t\tpr_err(\"can't get IRQ %d\\n\", pci_dev->irq);\n\t\tgoto fail_core;\n\t}\n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask);\n\n\tfor (i = 0; i < CX8800_AUD_CTLS; i++) {\n\t\tconst struct cx88_ctrl *cc = &cx8800_aud_ctls[i];\n\t\tstruct v4l2_ctrl *vc;\n\n\t\tvc = v4l2_ctrl_new_std(&core->audio_hdl, &cx8800_ctrl_aud_ops,\n\t\t\t\t       cc->id, cc->minimum, cc->maximum,\n\t\t\t\t       cc->step, cc->default_value);\n\t\tif (!vc) {\n\t\t\terr = core->audio_hdl.error;\n\t\t\tgoto fail_irq;\n\t\t}\n\t\tvc->priv = (void *)cc;\n\t}\n\n\tfor (i = 0; i < CX8800_VID_CTLS; i++) {\n\t\tconst struct cx88_ctrl *cc = &cx8800_vid_ctls[i];\n\t\tstruct v4l2_ctrl *vc;\n\n\t\tvc = v4l2_ctrl_new_std(&core->video_hdl, &cx8800_ctrl_vid_ops,\n\t\t\t\t       cc->id, cc->minimum, cc->maximum,\n\t\t\t\t       cc->step, cc->default_value);\n\t\tif (!vc) {\n\t\t\terr = core->video_hdl.error;\n\t\t\tgoto fail_irq;\n\t\t}\n\t\tvc->priv = (void *)cc;\n\t\tif (vc->id == V4L2_CID_CHROMA_AGC)\n\t\t\tcore->chroma_agc = vc;\n\t}\n\tv4l2_ctrl_add_handler(&core->video_hdl, &core->audio_hdl, NULL, false);\n\n\t \n\n\tif (core->board.audio_chip == CX88_AUDIO_WM8775) {\n\t\tstruct i2c_board_info wm8775_info = {\n\t\t\t.type = \"wm8775\",\n\t\t\t.addr = 0x36 >> 1,\n\t\t\t.platform_data = &core->wm8775_data,\n\t\t};\n\t\tstruct v4l2_subdev *sd;\n\n\t\tif (core->boardnr == CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1)\n\t\t\tcore->wm8775_data.is_nova_s = true;\n\t\telse\n\t\t\tcore->wm8775_data.is_nova_s = false;\n\n\t\tsd = v4l2_i2c_new_subdev_board(&core->v4l2_dev, &core->i2c_adap,\n\t\t\t\t\t       &wm8775_info, NULL);\n\t\tif (sd) {\n\t\t\tcore->sd_wm8775 = sd;\n\t\t\tsd->grp_id = WM8775_GID;\n\t\t}\n\t}\n\n\tif (core->board.audio_chip == CX88_AUDIO_TVAUDIO) {\n\t\t \n\t\tv4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,\n\t\t\t\t    \"tvaudio\", 0, I2C_ADDRS(0xb0 >> 1));\n\t}\n\n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:\n\tcase CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD: {\n\t\tstatic const struct i2c_board_info rtc_info = {\n\t\t\tI2C_BOARD_INFO(\"isl1208\", 0x6f)\n\t\t};\n\n\t\trequest_module(\"rtc-isl1208\");\n\t\tcore->i2c_rtc = i2c_new_client_device(&core->i2c_adap, &rtc_info);\n\t}\n\t\tfallthrough;\n\tcase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\n\tcase CX88_BOARD_NOTONLYTV_LV3H:\n\t\trequest_module(\"ir-kbd-i2c\");\n\t}\n\n\t \n\tpci_set_drvdata(pci_dev, dev);\n\n\tdev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\n\n\t \n\tcore->v4ldev = dev;\n\n\t \n\tmutex_lock(&core->lock);\n\tcx88_set_tvnorm(core, V4L2_STD_NTSC_M);\n\tv4l2_ctrl_handler_setup(&core->video_hdl);\n\tv4l2_ctrl_handler_setup(&core->audio_hdl);\n\tcx88_video_mux(core, 0);\n\n\tq = &dev->vb2_vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx88_buffer);\n\tq->ops = &cx8800_video_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &core->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\tgoto fail_unreg;\n\n\tq = &dev->vb2_vbiq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx88_buffer);\n\tq->ops = &cx8800_vbi_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &core->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\tgoto fail_unreg;\n\n\t \n\tcx88_vdev_init(core, dev->pci, &dev->video_dev,\n\t\t       &cx8800_video_template, \"video\");\n\tvideo_set_drvdata(&dev->video_dev, dev);\n\tdev->video_dev.ctrl_handler = &core->video_hdl;\n\tdev->video_dev.queue = &dev->vb2_vidq;\n\tdev->video_dev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t     V4L2_CAP_VIDEO_CAPTURE;\n\tif (core->board.tuner_type != UNSET)\n\t\tdev->video_dev.device_caps |= V4L2_CAP_TUNER;\n\terr = video_register_device(&dev->video_dev, VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[core->nr]);\n\tif (err < 0) {\n\t\tpr_err(\"can't register video device\\n\");\n\t\tgoto fail_unreg;\n\t}\n\tpr_info(\"registered device %s [v4l2]\\n\",\n\t\tvideo_device_node_name(&dev->video_dev));\n\n\tcx88_vdev_init(core, dev->pci, &dev->vbi_dev,\n\t\t       &cx8800_vbi_template, \"vbi\");\n\tvideo_set_drvdata(&dev->vbi_dev, dev);\n\tdev->vbi_dev.queue = &dev->vb2_vbiq;\n\tdev->vbi_dev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t   V4L2_CAP_VBI_CAPTURE;\n\tif (core->board.tuner_type != UNSET)\n\t\tdev->vbi_dev.device_caps |= V4L2_CAP_TUNER;\n\terr = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI,\n\t\t\t\t    vbi_nr[core->nr]);\n\tif (err < 0) {\n\t\tpr_err(\"can't register vbi device\\n\");\n\t\tgoto fail_unreg;\n\t}\n\tpr_info(\"registered device %s\\n\",\n\t\tvideo_device_node_name(&dev->vbi_dev));\n\n\tif (core->board.radio.type == CX88_RADIO) {\n\t\tcx88_vdev_init(core, dev->pci, &dev->radio_dev,\n\t\t\t       &cx8800_radio_template, \"radio\");\n\t\tvideo_set_drvdata(&dev->radio_dev, dev);\n\t\tdev->radio_dev.ctrl_handler = &core->audio_hdl;\n\t\tdev->radio_dev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\t\terr = video_register_device(&dev->radio_dev, VFL_TYPE_RADIO,\n\t\t\t\t\t    radio_nr[core->nr]);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"can't register radio device\\n\");\n\t\t\tgoto fail_unreg;\n\t\t}\n\t\tpr_info(\"registered device %s\\n\",\n\t\t\tvideo_device_node_name(&dev->radio_dev));\n\t}\n\n\t \n\tif (core->board.tuner_type != UNSET) {\n\t\tcore->kthread = kthread_run(cx88_audio_thread,\n\t\t\t\t\t    core, \"cx88 tvaudio\");\n\t\tif (IS_ERR(core->kthread)) {\n\t\t\terr = PTR_ERR(core->kthread);\n\t\t\tpr_err(\"failed to create cx88 audio thread, err=%d\\n\",\n\t\t\t       err);\n\t\t}\n\t}\n\tmutex_unlock(&core->lock);\n\n\treturn 0;\n\nfail_unreg:\n\tcx8800_unregister_video(dev);\n\tmutex_unlock(&core->lock);\nfail_irq:\n\tfree_irq(pci_dev->irq, dev);\nfail_core:\n\tcore->v4ldev = NULL;\n\tcx88_core_put(core, dev->pci);\nfail_disable:\n\tpci_disable_device(pci_dev);\nfail_free:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void cx8800_finidev(struct pci_dev *pci_dev)\n{\n\tstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tif (core->kthread) {\n\t\tkthread_stop(core->kthread);\n\t\tcore->kthread = NULL;\n\t}\n\n\tif (core->ir)\n\t\tcx88_ir_stop(core);\n\n\tcx88_shutdown(core);  \n\n\t \n\n\tfree_irq(pci_dev->irq, dev);\n\tcx8800_unregister_video(dev);\n\tpci_disable_device(pci_dev);\n\n\tcore->v4ldev = NULL;\n\n\t \n\tcx88_core_put(core, dev->pci);\n\tkfree(dev);\n}\n\nstatic int __maybe_unused cx8800_suspend(struct device *dev_d)\n{\n\tstruct cx8800_dev *dev = dev_get_drvdata(dev_d);\n\tstruct cx88_core *core = dev->core;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (!list_empty(&dev->vidq.active)) {\n\t\tpr_info(\"suspend video\\n\");\n\t\tstop_video_dma(dev);\n\t}\n\tif (!list_empty(&dev->vbiq.active)) {\n\t\tpr_info(\"suspend vbi\\n\");\n\t\tcx8800_stop_vbi_dma(dev);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\tif (core->ir)\n\t\tcx88_ir_stop(core);\n\t \n\tcx88_shutdown(core);\n\n\tdev->state.disabled = 1;\n\treturn 0;\n}\n\nstatic int __maybe_unused cx8800_resume(struct device *dev_d)\n{\n\tstruct cx8800_dev *dev = dev_get_drvdata(dev_d);\n\tstruct cx88_core *core = dev->core;\n\tunsigned long flags;\n\n\tdev->state.disabled = 0;\n\n\t \n\tcx88_reset(core);\n\tif (core->ir)\n\t\tcx88_ir_start(core);\n\n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask);\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (!list_empty(&dev->vidq.active)) {\n\t\tpr_info(\"resume video\\n\");\n\t\trestart_video_queue(dev, &dev->vidq);\n\t}\n\tif (!list_empty(&dev->vbiq.active)) {\n\t\tpr_info(\"resume vbi\\n\");\n\t\tcx8800_restart_vbi_queue(dev, &dev->vbiq);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic const struct pci_device_id cx8800_pci_tbl[] = {\n\t{\n\t\t.vendor       = 0x14f1,\n\t\t.device       = 0x8800,\n\t\t.subvendor    = PCI_ANY_ID,\n\t\t.subdevice    = PCI_ANY_ID,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(pci, cx8800_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(cx8800_pm_ops, cx8800_suspend, cx8800_resume);\n\nstatic struct pci_driver cx8800_pci_driver = {\n\t.name      = \"cx8800\",\n\t.id_table  = cx8800_pci_tbl,\n\t.probe     = cx8800_initdev,\n\t.remove    = cx8800_finidev,\n\t.driver.pm = &cx8800_pm_ops,\n};\n\nmodule_pci_driver(cx8800_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}