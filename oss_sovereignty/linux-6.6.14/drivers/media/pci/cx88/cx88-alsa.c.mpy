{
  "module_name": "cx88-alsa.c",
  "hash_id": "c2571a0deb32d2894ab37c08c9cabe1efb81167e3c9626be9a316a2d1a408ec3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-alsa.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n#include \"cx88-reg.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <media/i2c/wm8775.h>\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (debug + 1 > level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: alsa: \" fmt),\t\t\\\n\t\t\tchip->core->name, ##arg);\t\t\t\\\n} while (0)\n\n \n\nstruct cx88_audio_buffer {\n\tunsigned int\t\tbpl;\n\tstruct cx88_riscmem\trisc;\n\tvoid\t\t\t*vaddr;\n\tstruct scatterlist\t*sglist;\n\tint                     sglen;\n\tunsigned long\t\tnr_pages;\n};\n\nstruct cx88_audio_dev {\n\tstruct cx88_core           *core;\n\tstruct cx88_dmaqueue       q;\n\n\t \n\tstruct pci_dev             *pci;\n\n\t \n\tint                        irq;\n\n\tstruct snd_card            *card;\n\n\tspinlock_t                 reg_lock;\n\tatomic_t\t\t   count;\n\n\tunsigned int               dma_size;\n\tunsigned int               period_size;\n\tunsigned int               num_periods;\n\n\tstruct cx88_audio_buffer   *buf;\n\n\tstruct snd_pcm_substream   *substream;\n};\n\n \n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic const char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable cx88x soundcard. default enabled.\");\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for cx88x capture interface(s).\");\n\n \n\nMODULE_DESCRIPTION(\"ALSA driver module for cx2388x based TV cards\");\nMODULE_AUTHOR(\"Ricardo Cerqueira\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(CX88_VERSION);\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\n \n\n \n\nstatic int _cx88_start_audio_dma(struct cx88_audio_dev *chip)\n{\n\tstruct cx88_audio_buffer *buf = chip->buf;\n\tstruct cx88_core *core = chip->core;\n\tconst struct sram_channel *audio_ch = &cx88_sram_channels[SRAM_CH25];\n\n\t \n\tcx_clear(MO_AUD_DMACNTRL, 0x11);\n\n\t \n\tcx88_sram_channel_setup(chip->core, audio_ch, buf->bpl, buf->risc.dma);\n\n\t \n\tcx_write(MO_AUDD_LNGTH, buf->bpl);\n\n\t \n\tcx_write(MO_AUDD_GPCNTRL, GP_COUNT_CONTROL_RESET);\n\tatomic_set(&chip->count, 0);\n\n\tdprintk(1,\n\t\t\"Start audio DMA, %d B/line, %d lines/FIFO, %d periods, %d byte buffer\\n\",\n\t\tbuf->bpl, cx_read(audio_ch->cmds_start + 8) >> 1,\n\t\tchip->num_periods, buf->bpl * chip->num_periods);\n\n\t \n\tcx_write(MO_AUD_INTMSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\n\t\t\t\tAUD_INT_DN_RISCI2 | AUD_INT_DN_RISCI1);\n\n\t \n\tcx_write(MO_AUD_INTSTAT, ~0);\n\n\t \n\tcx_set(MO_PCI_INTMSK, chip->core->pci_irqmask | PCI_INT_AUDINT);\n\n\t \n\n\t \n\tcx_set(MO_DEV_CNTRL2, (1 << 5));\n\t \n\tcx_set(MO_AUD_DMACNTRL, 0x11);\n\n\tif (debug)\n\t\tcx88_sram_channel_dump(chip->core, audio_ch);\n\n\treturn 0;\n}\n\n \nstatic int _cx88_stop_audio_dma(struct cx88_audio_dev *chip)\n{\n\tstruct cx88_core *core = chip->core;\n\n\tdprintk(1, \"Stopping audio DMA\\n\");\n\n\t \n\tcx_clear(MO_AUD_DMACNTRL, 0x11);\n\n\t \n\tcx_clear(MO_PCI_INTMSK, PCI_INT_AUDINT);\n\tcx_clear(MO_AUD_INTMSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\n\t\t\t\tAUD_INT_DN_RISCI2 | AUD_INT_DN_RISCI1);\n\n\tif (debug)\n\t\tcx88_sram_channel_dump(chip->core,\n\t\t\t\t       &cx88_sram_channels[SRAM_CH25]);\n\n\treturn 0;\n}\n\n#define MAX_IRQ_LOOP 50\n\n \nstatic const char *cx88_aud_irqs[32] = {\n\t\"dn_risci1\", \"up_risci1\", \"rds_dn_risc1\",  \n\tNULL,\t\t\t\t\t   \n\t\"dn_risci2\", \"up_risci2\", \"rds_dn_risc2\",  \n\tNULL,\t\t\t\t\t   \n\t\"dnf_of\", \"upf_uf\", \"rds_dnf_uf\",\t   \n\tNULL,\t\t\t\t\t   \n\t\"dn_sync\", \"up_sync\", \"rds_dn_sync\",\t   \n\tNULL,\t\t\t\t\t   \n\t\"opc_err\", \"par_err\", \"rip_err\",\t   \n\t\"pci_abort\", \"ber_irq\", \"mchg_irq\"\t   \n};\n\n \nstatic void cx8801_aud_irq(struct cx88_audio_dev *chip)\n{\n\tstruct cx88_core *core = chip->core;\n\tu32 status, mask;\n\n\tstatus = cx_read(MO_AUD_INTSTAT);\n\tmask   = cx_read(MO_AUD_INTMSK);\n\tif (0 == (status & mask))\n\t\treturn;\n\tcx_write(MO_AUD_INTSTAT, status);\n\tif (debug > 1  ||  (status & mask & ~0xff))\n\t\tcx88_print_irqbits(\"irq aud\",\n\t\t\t\t   cx88_aud_irqs, ARRAY_SIZE(cx88_aud_irqs),\n\t\t\t\t   status, mask);\n\t \n\tif (status & AUD_INT_OPC_ERR) {\n\t\tpr_warn(\"Audio risc op code error\\n\");\n\t\tcx_clear(MO_AUD_DMACNTRL, 0x11);\n\t\tcx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH25]);\n\t}\n\tif (status & AUD_INT_DN_SYNC) {\n\t\tdprintk(1, \"Downstream sync error\\n\");\n\t\tcx_write(MO_AUDD_GPCNTRL, GP_COUNT_CONTROL_RESET);\n\t\treturn;\n\t}\n\t \n\tif (status & AUD_INT_DN_RISCI1) {\n\t\tatomic_set(&chip->count, cx_read(MO_AUDD_GPCNT));\n\t\tsnd_pcm_period_elapsed(chip->substream);\n\t}\n\t \n}\n\n \nstatic irqreturn_t cx8801_irq(int irq, void *dev_id)\n{\n\tstruct cx88_audio_dev *chip = dev_id;\n\tstruct cx88_core *core = chip->core;\n\tu32 status;\n\tint loop, handled = 0;\n\n\tfor (loop = 0; loop < MAX_IRQ_LOOP; loop++) {\n\t\tstatus = cx_read(MO_PCI_INTSTAT) &\n\t\t\t(core->pci_irqmask | PCI_INT_AUDINT);\n\t\tif (status == 0)\n\t\t\tgoto out;\n\t\tdprintk(3, \"cx8801_irq loop %d/%d, status %x\\n\",\n\t\t\tloop, MAX_IRQ_LOOP, status);\n\t\thandled = 1;\n\t\tcx_write(MO_PCI_INTSTAT, status);\n\n\t\tif (status & core->pci_irqmask)\n\t\t\tcx88_core_irq(core, status);\n\t\tif (status & PCI_INT_AUDINT)\n\t\t\tcx8801_aud_irq(chip);\n\t}\n\n\tif (loop == MAX_IRQ_LOOP) {\n\t\tpr_err(\"IRQ loop detected, disabling interrupts\\n\");\n\t\tcx_clear(MO_PCI_INTMSK, PCI_INT_AUDINT);\n\t}\n\n out:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int cx88_alsa_dma_init(struct cx88_audio_dev *chip,\n\t\t\t      unsigned long nr_pages)\n{\n\tstruct cx88_audio_buffer *buf = chip->buf;\n\tstruct page *pg;\n\tint i;\n\n\tbuf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\n\tif (!buf->vaddr) {\n\t\tdprintk(1, \"vmalloc_32(%lu pages) failed\\n\", nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1, \"vmalloc is at addr %p, size=%lu\\n\",\n\t\tbuf->vaddr, nr_pages << PAGE_SHIFT);\n\n\tmemset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);\n\tbuf->nr_pages = nr_pages;\n\n\tbuf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));\n\tif (!buf->sglist)\n\t\tgoto vzalloc_err;\n\n\tsg_init_table(buf->sglist, buf->nr_pages);\n\tfor (i = 0; i < buf->nr_pages; i++) {\n\t\tpg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);\n\t\tif (!pg)\n\t\t\tgoto vmalloc_to_page_err;\n\t\tsg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn 0;\n\nvmalloc_to_page_err:\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\nvzalloc_err:\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int cx88_alsa_dma_map(struct cx88_audio_dev *dev)\n{\n\tstruct cx88_audio_buffer *buf = dev->buf;\n\n\tbuf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,\n\t\t\tbuf->nr_pages, DMA_FROM_DEVICE);\n\n\tif (buf->sglen == 0) {\n\t\tpr_warn(\"%s: cx88_alsa_map_sg failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int cx88_alsa_dma_unmap(struct cx88_audio_dev *dev)\n{\n\tstruct cx88_audio_buffer *buf = dev->buf;\n\n\tif (!buf->sglen)\n\t\treturn 0;\n\n\tdma_unmap_sg(&dev->pci->dev, buf->sglist, buf->nr_pages,\n\t\t     DMA_FROM_DEVICE);\n\tbuf->sglen = 0;\n\treturn 0;\n}\n\nstatic int cx88_alsa_dma_free(struct cx88_audio_buffer *buf)\n{\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn 0;\n}\n\nstatic int dsp_buffer_free(struct cx88_audio_dev *chip)\n{\n\tstruct cx88_riscmem *risc = &chip->buf->risc;\n\n\tWARN_ON(!chip->dma_size);\n\n\tdprintk(2, \"Freeing buffer\\n\");\n\tcx88_alsa_dma_unmap(chip);\n\tcx88_alsa_dma_free(chip->buf);\n\tif (risc->cpu)\n\t\tdma_free_coherent(&chip->pci->dev, risc->size, risc->cpu,\n\t\t\t\t  risc->dma);\n\tkfree(chip->buf);\n\n\tchip->buf = NULL;\n\n\treturn 0;\n}\n\n \n\n \n#define DEFAULT_FIFO_SIZE\t4096\nstatic const struct snd_pcm_hardware snd_cx88_digital_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.period_bytes_min = DEFAULT_FIFO_SIZE / 4,\n\t.period_bytes_max = DEFAULT_FIFO_SIZE / 4,\n\t.periods_min = 1,\n\t.periods_max = 1024,\n\t.buffer_bytes_max = (1024 * 1024),\n};\n\n \nstatic int snd_cx88_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct cx88_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tif (!chip) {\n\t\tpr_err(\"BUG: cx88 can't find device struct. Can't proceed with open\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tchip->substream = substream;\n\n\truntime->hw = snd_cx88_digital_hw;\n\n\tif (cx88_sram_channels[SRAM_CH25].fifo_size != DEFAULT_FIFO_SIZE) {\n\t\tunsigned int bpl = cx88_sram_channels[SRAM_CH25].fifo_size / 4;\n\n\t\tbpl &= ~7;  \n\t\truntime->hw.period_bytes_min = bpl;\n\t\truntime->hw.period_bytes_max = bpl;\n\t}\n\n\treturn 0;\n_error:\n\tdprintk(1, \"Error opening PCM!\\n\");\n\treturn err;\n}\n\n \nstatic int snd_cx88_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_cx88_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cx88_audio_dev *chip = snd_pcm_substream_chip(substream);\n\n\tstruct cx88_audio_buffer *buf;\n\tint ret;\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\tchip->period_size = params_period_bytes(hw_params);\n\tchip->num_periods = params_periods(hw_params);\n\tchip->dma_size = chip->period_size * params_periods(hw_params);\n\n\tWARN_ON(!chip->dma_size);\n\tWARN_ON(chip->num_periods & (chip->num_periods - 1));\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tchip->buf = buf;\n\tbuf->bpl = chip->period_size;\n\n\tret = cx88_alsa_dma_init(chip,\n\t\t\t\t (PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx88_alsa_dma_map(chip);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx88_risc_databuffer(chip->pci, &buf->risc, buf->sglist,\n\t\t\t\t   chip->period_size, chip->num_periods, 1);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\n\tsubstream->runtime->dma_area = chip->buf->vaddr;\n\tsubstream->runtime->dma_bytes = chip->dma_size;\n\tsubstream->runtime->dma_addr = 0;\n\treturn 0;\n\nerror:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int snd_cx88_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct cx88_audio_dev *chip = snd_pcm_substream_chip(substream);\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_cx88_prepare(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_cx88_card_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct cx88_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\t \n\tspin_lock(&chip->reg_lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\terr = _cx88_start_audio_dma(chip);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\terr = _cx88_stop_audio_dma(chip);\n\t\tbreak;\n\tdefault:\n\t\terr =  -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&chip->reg_lock);\n\n\treturn err;\n}\n\n \nstatic snd_pcm_uframes_t snd_cx88_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct cx88_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu16 count;\n\n\tcount = atomic_read(&chip->count);\n\n\n\n\n\treturn runtime->period_size * (count & (runtime->periods - 1));\n}\n\n \nstatic struct page *snd_cx88_page(struct snd_pcm_substream *substream,\n\t\t\t\t  unsigned long offset)\n{\n\tvoid *pageptr = substream->runtime->dma_area + offset;\n\n\treturn vmalloc_to_page(pageptr);\n}\n\n \nstatic const struct snd_pcm_ops snd_cx88_pcm_ops = {\n\t.open = snd_cx88_pcm_open,\n\t.close = snd_cx88_close,\n\t.hw_params = snd_cx88_hw_params,\n\t.hw_free = snd_cx88_hw_free,\n\t.prepare = snd_cx88_prepare,\n\t.trigger = snd_cx88_card_trigger,\n\t.pointer = snd_cx88_pointer,\n\t.page = snd_cx88_page,\n};\n\n \nstatic int snd_cx88_pcm(struct cx88_audio_dev *chip, int device,\n\t\t\tconst char *name)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\terr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tstrscpy(pcm->name, name, sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx88_pcm_ops);\n\n\treturn 0;\n}\n\n \nstatic int snd_cx88_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 0x3f;\n\n\treturn 0;\n}\n\nstatic int snd_cx88_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\tint vol = 0x3f - (cx_read(AUD_VOL_CTL) & 0x3f),\n\t    bal = cx_read(AUD_BAL_CTL);\n\n\tvalue->value.integer.value[(bal & 0x40) ? 0 : 1] = vol;\n\tvol -= (bal & 0x3f);\n\tvalue->value.integer.value[(bal & 0x40) ? 1 : 0] = vol < 0 ? 0 : vol;\n\n\treturn 0;\n}\n\nstatic void snd_cx88_wm8775_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\tu16 left = value->value.integer.value[0];\n\tu16 right = value->value.integer.value[1];\n\tint v, b;\n\n\t \n\tif (left >= right) {\n\t\tv = left << 10;\n\t\tb = left ? (0x8000 * right) / left : 0x8000;\n\t} else {\n\t\tv = right << 10;\n\t\tb = right ? 0xffff - (0x8000 * left) / right : 0x8000;\n\t}\n\twm8775_s_ctrl(core, V4L2_CID_AUDIO_VOLUME, v);\n\twm8775_s_ctrl(core, V4L2_CID_AUDIO_BALANCE, b);\n}\n\n \nstatic int snd_cx88_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\tint left, right, v, b;\n\tint changed = 0;\n\tu32 old;\n\n\tif (core->sd_wm8775)\n\t\tsnd_cx88_wm8775_volume_put(kcontrol, value);\n\n\tleft = value->value.integer.value[0] & 0x3f;\n\tright = value->value.integer.value[1] & 0x3f;\n\tb = right - left;\n\tif (b < 0) {\n\t\tv = 0x3f - left;\n\t\tb = (-b) | 0x40;\n\t} else {\n\t\tv = 0x3f - right;\n\t}\n\t \n\tspin_lock_irq(&chip->reg_lock);\n\told = cx_read(AUD_VOL_CTL);\n\tif (v != (old & 0x3f)) {\n\t\tcx_swrite(SHADOW_AUD_VOL_CTL, AUD_VOL_CTL, (old & ~0x3f) | v);\n\t\tchanged = 1;\n\t}\n\tif ((cx_read(AUD_BAL_CTL) & 0x7f) != b) {\n\t\tcx_write(AUD_BAL_CTL, b);\n\t\tchanged = 1;\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(snd_cx88_db_scale, -6300, 100, 0);\n\nstatic const struct snd_kcontrol_new snd_cx88_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"Analog-TV Volume\",\n\t.info = snd_cx88_volume_info,\n\t.get = snd_cx88_volume_get,\n\t.put = snd_cx88_volume_put,\n\t.tlv.p = snd_cx88_db_scale,\n};\n\nstatic int snd_cx88_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\tu32 bit = kcontrol->private_value;\n\n\tvalue->value.integer.value[0] = !(cx_read(AUD_VOL_CTL) & bit);\n\treturn 0;\n}\n\nstatic int snd_cx88_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\tu32 bit = kcontrol->private_value;\n\tint ret = 0;\n\tu32 vol;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tvol = cx_read(AUD_VOL_CTL);\n\tif (value->value.integer.value[0] != !(vol & bit)) {\n\t\tvol ^= bit;\n\t\tcx_swrite(SHADOW_AUD_VOL_CTL, AUD_VOL_CTL, vol);\n\t\t \n\t\tif (core->sd_wm8775 && ((1 << 6) == bit))\n\t\t\twm8775_s_ctrl(core,\n\t\t\t\t      V4L2_CID_AUDIO_MUTE, 0 != (vol & bit));\n\t\tret = 1;\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new snd_cx88_dac_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Audio-Out Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_cx88_switch_get,\n\t.put = snd_cx88_switch_put,\n\t.private_value = (1 << 8),\n};\n\nstatic const struct snd_kcontrol_new snd_cx88_source_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Analog-TV Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_cx88_switch_get,\n\t.put = snd_cx88_switch_put,\n\t.private_value = (1 << 6),\n};\n\nstatic int snd_cx88_alc_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\ts32 val;\n\n\tval = wm8775_g_ctrl(core, V4L2_CID_AUDIO_LOUDNESS);\n\tvalue->value.integer.value[0] = val ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_cx88_alc_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct cx88_audio_dev *chip = snd_kcontrol_chip(kcontrol);\n\tstruct cx88_core *core = chip->core;\n\n\twm8775_s_ctrl(core, V4L2_CID_AUDIO_LOUDNESS,\n\t\t      value->value.integer.value[0] != 0);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_cx88_alc_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line-In ALC Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_cx88_alc_get,\n\t.put = snd_cx88_alc_put,\n};\n\n \n\n \n\nstatic const struct pci_device_id cx88_audio_pci_tbl[] = {\n\t{0x14f1, 0x8801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0x14f1, 0x8811, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0, }\n};\nMODULE_DEVICE_TABLE(pci, cx88_audio_pci_tbl);\n\n \n\nstatic int snd_cx88_free(struct cx88_audio_dev *chip)\n{\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, chip);\n\n\tcx88_core_put(chip->core, chip->pci);\n\n\tpci_disable_device(chip->pci);\n\treturn 0;\n}\n\n \nstatic void snd_cx88_dev_free(struct snd_card *card)\n{\n\tstruct cx88_audio_dev *chip = card->private_data;\n\n\tsnd_cx88_free(chip);\n}\n\n \n\nstatic int devno;\nstatic int snd_cx88_create(struct snd_card *card, struct pci_dev *pci,\n\t\t\t   struct cx88_audio_dev **rchip,\n\t\t\t   struct cx88_core **core_ptr)\n{\n\tstruct cx88_audio_dev\t*chip;\n\tstruct cx88_core\t*core;\n\tint\t\t\terr;\n\tunsigned char\t\tpci_lat;\n\n\t*rchip = NULL;\n\n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_master(pci);\n\n\tchip = card->private_data;\n\n\tcore = cx88_core_get(pci);\n\tif (!core) {\n\t\terr = -EINVAL;\n\t\treturn err;\n\t}\n\n\terr = dma_set_mask(&pci->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdprintk(0, \"%s/1: Oops: no 32bit PCI DMA ???\\n\", core->name);\n\t\tcx88_core_put(core, pci);\n\t\treturn err;\n\t}\n\n\t \n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tspin_lock_init(&chip->reg_lock);\n\n\tchip->core = core;\n\n\t \n\terr = request_irq(chip->pci->irq, cx8801_irq,\n\t\t\t  IRQF_SHARED, chip->core->name, chip);\n\tif (err < 0) {\n\t\tdprintk(0, \"%s: can't get IRQ %d\\n\",\n\t\t\tchip->core->name, chip->pci->irq);\n\t\treturn err;\n\t}\n\n\t \n\tpci_read_config_byte(pci, PCI_LATENCY_TIMER, &pci_lat);\n\n\tdprintk(1,\n\t\t\"ALSA %s/%i: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t\tcore->name, devno,\n\t\tpci_name(pci), pci->revision, pci->irq,\n\t\tpci_lat, (unsigned long long)pci_resource_start(pci, 0));\n\n\tchip->irq = pci->irq;\n\tsynchronize_irq(chip->irq);\n\n\t*rchip = chip;\n\t*core_ptr = core;\n\n\treturn 0;\n}\n\nstatic int cx88_audio_initdev(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstruct snd_card\t\t*card;\n\tstruct cx88_audio_dev\t*chip;\n\tstruct cx88_core\t*core = NULL;\n\tint\t\t\terr;\n\n\tif (devno >= SNDRV_CARDS)\n\t\treturn (-ENODEV);\n\n\tif (!enable[devno]) {\n\t\t++devno;\n\t\treturn (-ENOENT);\n\t}\n\n\terr = snd_card_new(&pci->dev, index[devno], id[devno], THIS_MODULE,\n\t\t\t   sizeof(struct cx88_audio_dev), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard->private_free = snd_cx88_dev_free;\n\n\terr = snd_cx88_create(card, pci, &chip, &core);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_cx88_pcm(chip, 0, \"CX88 Digital\");\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_volume, chip));\n\tif (err < 0)\n\t\tgoto error;\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_dac_switch, chip));\n\tif (err < 0)\n\t\tgoto error;\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_source_switch, chip));\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tif (core->sd_wm8775) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_alc_switch, chip));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tstrscpy(card->driver, \"CX88x\", sizeof(card->driver));\n\tsprintf(card->shortname, \"Conexant CX%x\", pci->device);\n\tsprintf(card->longname, \"%s at %#llx\",\n\t\tcard->shortname,\n\t\t(unsigned long long)pci_resource_start(pci, 0));\n\tstrscpy(card->mixername, \"CX88\", sizeof(card->mixername));\n\n\tdprintk(0, \"%s/%i: ALSA support for cx2388x boards\\n\",\n\t\tcard->driver, devno);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\tpci_set_drvdata(pci, card);\n\n\tdevno++;\n\treturn 0;\n\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n \nstatic void cx88_audio_finidev(struct pci_dev *pci)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\n\tsnd_card_free(card);\n\n\tdevno--;\n}\n\n \n\nstatic struct pci_driver cx88_audio_pci_driver = {\n\t.name     = \"cx88_audio\",\n\t.id_table = cx88_audio_pci_tbl,\n\t.probe    = cx88_audio_initdev,\n\t.remove   = cx88_audio_finidev,\n};\n\nmodule_pci_driver(cx88_audio_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}