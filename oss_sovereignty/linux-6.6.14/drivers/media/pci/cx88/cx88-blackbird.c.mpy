{
  "module_name": "cx88-blackbird.c",
  "hash_id": "6e166892514e0ef52eff35d83c5aada60840753f2b6e5a09dbcebc72eb7246b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-blackbird.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/drv-intf/cx2341x.h>\n\nMODULE_DESCRIPTION(\"driver for cx2388x/cx23416 based mpeg encoder cards\");\nMODULE_AUTHOR(\"Jelle Foks <jelle@foks.us>, Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(CX88_VERSION);\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages [blackbird]\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (debug + 1 > level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: blackbird:\" fmt),\t\t\\\n\t\t\t__func__, ##arg);\t\t\t\t\\\n} while (0)\n\n \n\n#define BLACKBIRD_FIRM_IMAGE_SIZE 376836\n\n \n\n#define IVTV_CMD_HW_BLOCKS_RST 0xFFFFFFFF\n\n \n#define IVTV_API_STD_TIMEOUT 500\n\nenum blackbird_capture_type {\n\tBLACKBIRD_MPEG_CAPTURE,\n\tBLACKBIRD_RAW_CAPTURE,\n\tBLACKBIRD_RAW_PASSTHRU_CAPTURE\n};\n\nenum blackbird_capture_bits {\n\tBLACKBIRD_RAW_BITS_NONE             = 0x00,\n\tBLACKBIRD_RAW_BITS_YUV_CAPTURE      = 0x01,\n\tBLACKBIRD_RAW_BITS_PCM_CAPTURE      = 0x02,\n\tBLACKBIRD_RAW_BITS_VBI_CAPTURE      = 0x04,\n\tBLACKBIRD_RAW_BITS_PASSTHRU_CAPTURE = 0x08,\n\tBLACKBIRD_RAW_BITS_TO_HOST_CAPTURE  = 0x10\n};\n\nenum blackbird_capture_end {\n\tBLACKBIRD_END_AT_GOP,  \n\tBLACKBIRD_END_NOW,  \n};\n\nenum blackbird_framerate {\n\tBLACKBIRD_FRAMERATE_NTSC_30,  \n\tBLACKBIRD_FRAMERATE_PAL_25    \n};\n\nenum blackbird_stream_port {\n\tBLACKBIRD_OUTPUT_PORT_MEMORY,\n\tBLACKBIRD_OUTPUT_PORT_STREAMING,\n\tBLACKBIRD_OUTPUT_PORT_SERIAL\n};\n\nenum blackbird_data_xfer_status {\n\tBLACKBIRD_MORE_BUFFERS_FOLLOW,\n\tBLACKBIRD_LAST_BUFFER,\n};\n\nenum blackbird_picture_mask {\n\tBLACKBIRD_PICTURE_MASK_NONE,\n\tBLACKBIRD_PICTURE_MASK_I_FRAMES,\n\tBLACKBIRD_PICTURE_MASK_I_P_FRAMES = 0x3,\n\tBLACKBIRD_PICTURE_MASK_ALL_FRAMES = 0x7,\n};\n\nenum blackbird_vbi_mode_bits {\n\tBLACKBIRD_VBI_BITS_SLICED,\n\tBLACKBIRD_VBI_BITS_RAW,\n};\n\nenum blackbird_vbi_insertion_bits {\n\tBLACKBIRD_VBI_BITS_INSERT_IN_XTENSION_USR_DATA,\n\tBLACKBIRD_VBI_BITS_INSERT_IN_PRIVATE_PACKETS = 0x1 << 1,\n\tBLACKBIRD_VBI_BITS_SEPARATE_STREAM = 0x2 << 1,\n\tBLACKBIRD_VBI_BITS_SEPARATE_STREAM_USR_DATA = 0x4 << 1,\n\tBLACKBIRD_VBI_BITS_SEPARATE_STREAM_PRV_DATA = 0x5 << 1,\n};\n\nenum blackbird_dma_unit {\n\tBLACKBIRD_DMA_BYTES,\n\tBLACKBIRD_DMA_FRAMES,\n};\n\nenum blackbird_dma_transfer_status_bits {\n\tBLACKBIRD_DMA_TRANSFER_BITS_DONE = 0x01,\n\tBLACKBIRD_DMA_TRANSFER_BITS_ERROR = 0x04,\n\tBLACKBIRD_DMA_TRANSFER_BITS_LL_ERROR = 0x10,\n};\n\nenum blackbird_pause {\n\tBLACKBIRD_PAUSE_ENCODING,\n\tBLACKBIRD_RESUME_ENCODING,\n};\n\nenum blackbird_copyright {\n\tBLACKBIRD_COPYRIGHT_OFF,\n\tBLACKBIRD_COPYRIGHT_ON,\n};\n\nenum blackbird_notification_type {\n\tBLACKBIRD_NOTIFICATION_REFRESH,\n};\n\nenum blackbird_notification_status {\n\tBLACKBIRD_NOTIFICATION_OFF,\n\tBLACKBIRD_NOTIFICATION_ON,\n};\n\nenum blackbird_notification_mailbox {\n\tBLACKBIRD_NOTIFICATION_NO_MAILBOX = -1,\n};\n\nenum blackbird_field1_lines {\n\tBLACKBIRD_FIELD1_SAA7114 = 0x00EF,  \n\tBLACKBIRD_FIELD1_SAA7115 = 0x00F0,  \n\tBLACKBIRD_FIELD1_MICRONAS = 0x0105,  \n};\n\nenum blackbird_field2_lines {\n\tBLACKBIRD_FIELD2_SAA7114 = 0x00EF,  \n\tBLACKBIRD_FIELD2_SAA7115 = 0x00F0,  \n\tBLACKBIRD_FIELD2_MICRONAS = 0x0106,  \n};\n\nenum blackbird_custom_data_type {\n\tBLACKBIRD_CUSTOM_EXTENSION_USR_DATA,\n\tBLACKBIRD_CUSTOM_PRIVATE_PACKET,\n};\n\nenum blackbird_mute {\n\tBLACKBIRD_UNMUTE,\n\tBLACKBIRD_MUTE,\n};\n\nenum blackbird_mute_video_mask {\n\tBLACKBIRD_MUTE_VIDEO_V_MASK = 0x0000FF00,\n\tBLACKBIRD_MUTE_VIDEO_U_MASK = 0x00FF0000,\n\tBLACKBIRD_MUTE_VIDEO_Y_MASK = 0xFF000000,\n};\n\nenum blackbird_mute_video_shift {\n\tBLACKBIRD_MUTE_VIDEO_V_SHIFT = 8,\n\tBLACKBIRD_MUTE_VIDEO_U_SHIFT = 16,\n\tBLACKBIRD_MUTE_VIDEO_Y_SHIFT = 24,\n};\n\n \n#define IVTV_REG_ENC_SDRAM_REFRESH (0x07F8  )\n#define IVTV_REG_ENC_SDRAM_PRECHARGE (0x07FC  )\n#define IVTV_REG_SPU (0x9050  )\n#define IVTV_REG_HW_BLOCKS (0x9054  )\n#define IVTV_REG_VPU (0x9058  )\n#define IVTV_REG_APU (0xA064  )\n\n \n\nstatic void host_setup(struct cx88_core *core)\n{\n\t \n\tcx_write(MO_GPHST_SOFT_RST, 1);\n\tudelay(100);\n\tcx_write(MO_GPHST_SOFT_RST, 0);\n\tudelay(100);\n\n\t \n\tcx_write(MO_GPHST_WSC, 0x44444444U);\n\tcx_write(MO_GPHST_XFR, 0);\n\tcx_write(MO_GPHST_WDTH, 15);\n\tcx_write(MO_GPHST_HDSHK, 0);\n\tcx_write(MO_GPHST_MUX16, 0x44448888U);\n\tcx_write(MO_GPHST_MODE, 0);\n}\n\n \n\n#define P1_MDATA0 0x390000\n#define P1_MDATA1 0x390001\n#define P1_MDATA2 0x390002\n#define P1_MDATA3 0x390003\n#define P1_MADDR2 0x390004\n#define P1_MADDR1 0x390005\n#define P1_MADDR0 0x390006\n#define P1_RDATA0 0x390008\n#define P1_RDATA1 0x390009\n#define P1_RDATA2 0x39000A\n#define P1_RDATA3 0x39000B\n#define P1_RADDR0 0x39000C\n#define P1_RADDR1 0x39000D\n#define P1_RRDWR  0x39000E\n\nstatic int wait_ready_gpio0_bit1(struct cx88_core *core, u32 state)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1);\n\tu32 gpio0, need;\n\n\tneed = state ? 2 : 0;\n\tfor (;;) {\n\t\tgpio0 = cx_read(MO_GP0_IO) & 2;\n\t\tif (need == gpio0)\n\t\t\treturn 0;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -1;\n\t\tudelay(1);\n\t}\n}\n\nstatic int memory_write(struct cx88_core *core, u32 address, u32 value)\n{\n\t \n\tcx_writeb(P1_MDATA0, (unsigned int)value);\n\tcx_writeb(P1_MDATA1, (unsigned int)(value >> 8));\n\tcx_writeb(P1_MDATA2, (unsigned int)(value >> 16));\n\tcx_writeb(P1_MDATA3, (unsigned int)(value >> 24));\n\tcx_writeb(P1_MADDR2, (unsigned int)(address >> 16) | 0x40);\n\tcx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\n\tcx_writeb(P1_MADDR0, (unsigned int)address);\n\tcx_read(P1_MDATA0);\n\tcx_read(P1_MADDR0);\n\n\treturn wait_ready_gpio0_bit1(core, 1);\n}\n\nstatic int memory_read(struct cx88_core *core, u32 address, u32 *value)\n{\n\tint retval;\n\tu32 val;\n\n\t \n\tcx_writeb(P1_MADDR2, (unsigned int)(address >> 16) & ~0xC0);\n\tcx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\n\tcx_writeb(P1_MADDR0, (unsigned int)address);\n\tcx_read(P1_MADDR0);\n\n\tretval = wait_ready_gpio0_bit1(core, 1);\n\n\tcx_writeb(P1_MDATA3, 0);\n\tval     = (unsigned char)cx_read(P1_MDATA3) << 24;\n\tcx_writeb(P1_MDATA2, 0);\n\tval    |= (unsigned char)cx_read(P1_MDATA2) << 16;\n\tcx_writeb(P1_MDATA1, 0);\n\tval    |= (unsigned char)cx_read(P1_MDATA1) << 8;\n\tcx_writeb(P1_MDATA0, 0);\n\tval    |= (unsigned char)cx_read(P1_MDATA0);\n\n\t*value  = val;\n\treturn retval;\n}\n\nstatic int register_write(struct cx88_core *core, u32 address, u32 value)\n{\n\tcx_writeb(P1_RDATA0, (unsigned int)value);\n\tcx_writeb(P1_RDATA1, (unsigned int)(value >> 8));\n\tcx_writeb(P1_RDATA2, (unsigned int)(value >> 16));\n\tcx_writeb(P1_RDATA3, (unsigned int)(value >> 24));\n\tcx_writeb(P1_RADDR0, (unsigned int)address);\n\tcx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\n\tcx_writeb(P1_RRDWR, 1);\n\tcx_read(P1_RDATA0);\n\tcx_read(P1_RADDR0);\n\n\treturn wait_ready_gpio0_bit1(core, 1);\n}\n\nstatic int register_read(struct cx88_core *core, u32 address, u32 *value)\n{\n\tint retval;\n\tu32 val;\n\n\tcx_writeb(P1_RADDR0, (unsigned int)address);\n\tcx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\n\tcx_writeb(P1_RRDWR, 0);\n\tcx_read(P1_RADDR0);\n\n\tretval  = wait_ready_gpio0_bit1(core, 1);\n\tval     = (unsigned char)cx_read(P1_RDATA0);\n\tval    |= (unsigned char)cx_read(P1_RDATA1) << 8;\n\tval    |= (unsigned char)cx_read(P1_RDATA2) << 16;\n\tval    |= (unsigned char)cx_read(P1_RDATA3) << 24;\n\n\t*value  = val;\n\treturn retval;\n}\n\n \n\nstatic int blackbird_mbox_func(void *priv, u32 command, int in,\n\t\t\t       int out, u32 data[CX2341X_MBOX_MAX_DATA])\n{\n\tstruct cx8802_dev *dev = priv;\n\tunsigned long timeout;\n\tu32 value, flag, retval;\n\tint i;\n\n\tdprintk(1, \"%s: 0x%X\\n\", __func__, command);\n\n\t \n\tmemory_read(dev->core, dev->mailbox - 4, &value);\n\tif (value != 0x12345678) {\n\t\tdprintk(0,\n\t\t\t\"Firmware and/or mailbox pointer not initialized or corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemory_read(dev->core, dev->mailbox, &flag);\n\tif (flag) {\n\t\tdprintk(0, \"ERROR: Mailbox appears to be in use (%x)\\n\", flag);\n\t\treturn -EIO;\n\t}\n\n\tflag |= 1;  \n\tmemory_write(dev->core, dev->mailbox, flag);\n\n\t \n\tmemory_write(dev->core, dev->mailbox + 1, command);  \n\t \n\tmemory_write(dev->core, dev->mailbox + 3, IVTV_API_STD_TIMEOUT);\n\tfor (i = 0; i < in; i++) {\n\t\tmemory_write(dev->core, dev->mailbox + 4 + i, data[i]);\n\t\tdprintk(1, \"API Input %d = %d\\n\", i, data[i]);\n\t}\n\tfor (; i < CX2341X_MBOX_MAX_DATA; i++)\n\t\tmemory_write(dev->core, dev->mailbox + 4 + i, 0);\n\n\tflag |= 3;  \n\tmemory_write(dev->core, dev->mailbox, flag);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\tfor (;;) {\n\t\tmemory_read(dev->core, dev->mailbox, &flag);\n\t\tif (0 != (flag & 4))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdprintk(0, \"ERROR: API Mailbox timeout %x\\n\", command);\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\t \n\tfor (i = 0; i < out; i++) {\n\t\tmemory_read(dev->core, dev->mailbox + 4 + i, data + i);\n\t\tdprintk(1, \"API Output %d = %d\\n\", i, data[i]);\n\t}\n\n\tmemory_read(dev->core, dev->mailbox + 2, &retval);\n\tdprintk(1, \"API result = %d\\n\", retval);\n\n\tflag = 0;\n\tmemory_write(dev->core, dev->mailbox, flag);\n\treturn retval;\n}\n\n \n\n \nstatic int blackbird_api_cmd(struct cx8802_dev *dev, u32 command,\n\t\t\t     u32 inputcnt, u32 outputcnt, ...)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tva_list vargs;\n\tint i, err;\n\n\tva_start(vargs, outputcnt);\n\n\tfor (i = 0; i < inputcnt; i++)\n\t\tdata[i] = va_arg(vargs, int);\n\n\terr = blackbird_mbox_func(dev, command, inputcnt, outputcnt, data);\n\tfor (i = 0; i < outputcnt; i++) {\n\t\tint *vptr = va_arg(vargs, int *);\n\t\t*vptr = data[i];\n\t}\n\tva_end(vargs);\n\treturn err;\n}\n\nstatic int blackbird_find_mailbox(struct cx8802_dev *dev)\n{\n\tu32 signature[4] = {0x12345678, 0x34567812, 0x56781234, 0x78123456};\n\tint signaturecnt = 0;\n\tu32 value;\n\tint i;\n\n\tfor (i = 0; i < BLACKBIRD_FIRM_IMAGE_SIZE; i++) {\n\t\tmemory_read(dev->core, i, &value);\n\t\tif (value == signature[signaturecnt])\n\t\t\tsignaturecnt++;\n\t\telse\n\t\t\tsignaturecnt = 0;\n\t\tif (signaturecnt == 4) {\n\t\t\tdprintk(1, \"Mailbox signature found\\n\");\n\t\t\treturn i + 1;\n\t\t}\n\t}\n\tdprintk(0, \"Mailbox signature values not found!\\n\");\n\treturn -EIO;\n}\n\nstatic int blackbird_load_firmware(struct cx8802_dev *dev)\n{\n\tstatic const unsigned char magic[8] = {\n\t\t0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\n\t};\n\tconst struct firmware *firmware;\n\tint i, retval = 0;\n\tu32 value = 0;\n\tu32 checksum = 0;\n\t__le32 *dataptr;\n\n\tretval  = register_write(dev->core, IVTV_REG_VPU, 0xFFFFFFED);\n\tretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS,\n\t\t\t\t IVTV_CMD_HW_BLOCKS_RST);\n\tretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_REFRESH,\n\t\t\t\t 0x80000640);\n\tretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_PRECHARGE,\n\t\t\t\t 0x1A);\n\tusleep_range(10000, 20000);\n\tretval |= register_write(dev->core, IVTV_REG_APU, 0);\n\n\tif (retval < 0)\n\t\tdprintk(0, \"Error with register_write\\n\");\n\n\tretval = request_firmware(&firmware, CX2341X_FIRM_ENC_FILENAME,\n\t\t\t\t  &dev->pci->dev);\n\n\tif (retval != 0) {\n\t\tpr_err(\"Hotplug firmware request failed (%s).\\n\",\n\t\t       CX2341X_FIRM_ENC_FILENAME);\n\t\tpr_err(\"Please fix your hotplug setup, the board will not work without firmware loaded!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (firmware->size != BLACKBIRD_FIRM_IMAGE_SIZE) {\n\t\tpr_err(\"Firmware size mismatch (have %zd, expected %d)\\n\",\n\t\t       firmware->size, BLACKBIRD_FIRM_IMAGE_SIZE);\n\t\trelease_firmware(firmware);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(firmware->data, magic, 8) != 0) {\n\t\tpr_err(\"Firmware magic mismatch, wrong file?\\n\");\n\t\trelease_firmware(firmware);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdprintk(1, \"Loading firmware ...\\n\");\n\tdataptr = (__le32 *)firmware->data;\n\tfor (i = 0; i < (firmware->size >> 2); i++) {\n\t\tvalue = le32_to_cpu(*dataptr);\n\t\tchecksum += ~value;\n\t\tmemory_write(dev->core, i, value);\n\t\tdataptr++;\n\t}\n\n\t \n\tfor (i--; i >= 0; i--) {\n\t\tmemory_read(dev->core, i, &value);\n\t\tchecksum -= ~value;\n\t}\n\trelease_firmware(firmware);\n\tif (checksum) {\n\t\tpr_err(\"Firmware load might have failed (checksum mismatch).\\n\");\n\t\treturn -EIO;\n\t}\n\tdprintk(0, \"Firmware upload successful.\\n\");\n\n\tretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS,\n\t\t\t\t IVTV_CMD_HW_BLOCKS_RST);\n\tretval |= register_read(dev->core, IVTV_REG_SPU, &value);\n\tretval |= register_write(dev->core, IVTV_REG_SPU, value & 0xFFFFFFFE);\n\tusleep_range(10000, 20000);\n\n\tretval |= register_read(dev->core, IVTV_REG_VPU, &value);\n\tretval |= register_write(dev->core, IVTV_REG_VPU, value & 0xFFFFFFE8);\n\n\tif (retval < 0)\n\t\tdprintk(0, \"Error with register_write\\n\");\n\treturn 0;\n}\n\n \n\nstatic void blackbird_codec_settings(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\n\t\t\t  core->height, core->width);\n\n\tdev->cxhdl.width = core->width;\n\tdev->cxhdl.height = core->height;\n\tcx2341x_handler_set_50hz(&dev->cxhdl,\n\t\t\t\t dev->core->tvnorm & V4L2_STD_625_50);\n\tcx2341x_handler_setup(&dev->cxhdl);\n}\n\nstatic int blackbird_initialize_codec(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\tint version;\n\tint retval;\n\n\tdprintk(1, \"Initialize codec\\n\");\n\tretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);  \n\tif (retval < 0) {\n\t\t \n\t\tcx_write(MO_SRST_IO, 0);  \n\t\tcx_write(MO_SRST_IO, 1);  \n\t\tretval = blackbird_load_firmware(dev);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tretval = blackbird_find_mailbox(dev);\n\t\tif (retval < 0)\n\t\t\treturn -1;\n\n\t\tdev->mailbox = retval;\n\n\t\t \n\t\tretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\n\t\tif (retval < 0) {\n\t\t\tdprintk(0, \"ERROR: Firmware ping failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tretval = blackbird_api_cmd(dev, CX2341X_ENC_GET_VERSION,\n\t\t\t\t\t   0, 1, &version);\n\t\tif (retval < 0) {\n\t\t\tdprintk(0,\n\t\t\t\t\"ERROR: Firmware get encoder version failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdprintk(0, \"Firmware version is 0x%08x\\n\", version);\n\t}\n\n\tcx_write(MO_PINMUX_IO, 0x88);  \n\tcx_clear(MO_INPUT_FORMAT, 0x100);  \n\tcx_write(MO_VBOS_CONTROL, 0x84A00);  \n\tcx_clear(MO_OUTPUT_FORMAT, 0x0008);  \n\n\tblackbird_codec_settings(dev);\n\n\tblackbird_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\n\t\t\t  BLACKBIRD_FIELD1_SAA7115, BLACKBIRD_FIELD2_SAA7115);\n\n\tblackbird_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\n\t\t\t  BLACKBIRD_CUSTOM_EXTENSION_USR_DATA,\n\t\t\t  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\treturn 0;\n}\n\nstatic int blackbird_start_codec(struct cx8802_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\t \n\tu32 reg;\n\n\tint i;\n\tint lastchange = -1;\n\tint lastval = 0;\n\n\tfor (i = 0; (i < 10) && (i < (lastchange + 4)); i++) {\n\t\treg = cx_read(AUD_STATUS);\n\n\t\tdprintk(1, \"AUD_STATUS:%dL: 0x%x\\n\", i, reg);\n\t\tif ((reg & 0x0F) != lastval) {\n\t\t\tlastval = reg & 0x0F;\n\t\t\tlastchange = i;\n\t\t}\n\t\tmsleep(100);\n\t}\n\n\t \n\tcx_clear(AUD_VOL_CTL, (1 << 6));\n\n\tblackbird_api_cmd(dev, CX2341X_ENC_REFRESH_INPUT, 0, 0);\n\n\t \n\tblackbird_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\n\n\tcx2341x_handler_set_busy(&dev->cxhdl, 1);\n\n\t \n\tblackbird_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\n\t\t\t  BLACKBIRD_MPEG_CAPTURE, BLACKBIRD_RAW_BITS_NONE);\n\n\treturn 0;\n}\n\nstatic int blackbird_stop_codec(struct cx8802_dev *dev)\n{\n\tblackbird_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\n\t\t\t  BLACKBIRD_END_NOW,\n\t\t\t  BLACKBIRD_MPEG_CAPTURE,\n\t\t\t  BLACKBIRD_RAW_BITS_NONE);\n\n\tcx2341x_handler_set_busy(&dev->cxhdl, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx8802_dev *dev = q->drv_priv;\n\n\t*num_planes = 1;\n\tdev->ts_packet_size  = 188 * 4;\n\tdev->ts_packet_count  = 32;\n\tsizes[0] = dev->ts_packet_size * dev->ts_packet_count;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\n\treturn cx8802_buf_prepare(vb->vb2_queue, dev, buf);\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct cx88_riscmem *risc = &buf->risc;\n\n\tif (risc->cpu)\n\t\tdma_free_coherent(&dev->pci->dev, risc->size, risc->cpu,\n\t\t\t\t  risc->dma);\n\tmemset(risc, 0, sizeof(*risc));\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer    *buf = container_of(vbuf, struct cx88_buffer, vb);\n\n\tcx8802_buf_queue(dev, buf);\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx8802_dev *dev = q->drv_priv;\n\tstruct cx88_dmaqueue *dmaq = &dev->mpegq;\n\tstruct cx8802_driver *drv;\n\tstruct cx88_buffer *buf;\n\tunsigned long flags;\n\tint err;\n\n\t \n\tdrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\n\tif (!drv) {\n\t\tdprintk(1, \"%s: blackbird driver is not loaded\\n\", __func__);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terr = drv->request_acquire(drv);\n\tif (err != 0) {\n\t\tdprintk(1, \"%s: Unable to acquire hardware, %d\\n\", __func__,\n\t\t\terr);\n\t\tgoto fail;\n\t}\n\n\tif (blackbird_initialize_codec(dev) < 0) {\n\t\tdrv->request_release(drv);\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\terr = blackbird_start_codec(dev);\n\tif (err == 0) {\n\t\tbuf = list_entry(dmaq->active.next, struct cx88_buffer, list);\n\t\tcx8802_start_dma(dev, dmaq, buf);\n\t\treturn 0;\n\t}\n\nfail:\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\treturn err;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx8802_dev *dev = q->drv_priv;\n\tstruct cx88_dmaqueue *dmaq = &dev->mpegq;\n\tstruct cx8802_driver *drv = NULL;\n\tunsigned long flags;\n\n\tcx8802_cancel_buffers(dev);\n\tblackbird_stop_codec(dev);\n\n\t \n\tdrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\n\tWARN_ON(!drv);\n\tif (drv)\n\t\tdrv->request_release(drv);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic const struct vb2_ops blackbird_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n};\n\n \n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tstrscpy(cap->driver, \"cx88_blackbird\", sizeof(cap->driver));\n\treturn cx88_querycap(file, core, cap);\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    = dev->ts_packet_size * dev->ts_packet_count;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.width        = core->width;\n\tf->fmt.pix.height       = core->height;\n\tf->fmt.pix.field        = core->field;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tunsigned int maxw, maxh;\n\tenum v4l2_field field;\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    = dev->ts_packet_size * dev->ts_packet_count;\n\tf->fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;\n\n\tmaxw = norm_maxw(core->tvnorm);\n\tmaxh = norm_maxh(core->tvnorm);\n\n\tfield = f->fmt.pix.field;\n\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tbreak;\n\tdefault:\n\t\tfield = (f->fmt.pix.height > maxh / 2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\t}\n\tif (V4L2_FIELD_HAS_T_OR_B(field))\n\t\tmaxh /= 2;\n\n\tv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\n\t\t\t      &f->fmt.pix.height, 32, maxh, 0, 0);\n\tf->fmt.pix.field = field;\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core  *core = dev->core;\n\n\tif (vb2_is_busy(&dev->vb2_mpegq))\n\t\treturn -EBUSY;\n\tif (core->v4ldev && (vb2_is_busy(&core->v4ldev->vb2_vidq) ||\n\t\t\t     vb2_is_busy(&core->v4ldev->vb2_vbiq)))\n\t\treturn -EBUSY;\n\tvidioc_try_fmt_vid_cap(file, priv, f);\n\tcore->width = f->fmt.pix.width;\n\tcore->height = f->fmt.pix.height;\n\tcore->field = f->fmt.pix.field;\n\tcx88_set_scale(core, f->fmt.pix.width, f->fmt.pix.height,\n\t\t       f->fmt.pix.field);\n\tblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\n\t\t\t  f->fmt.pix.height, f->fmt.pix.width);\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tbool streaming;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (unlikely(f->tuner != 0))\n\t\treturn -EINVAL;\n\tstreaming = vb2_start_streaming_called(&dev->vb2_mpegq);\n\tif (streaming)\n\t\tblackbird_stop_codec(dev);\n\n\tcx88_set_freq(core, f);\n\tblackbird_initialize_codec(dev);\n\tcx88_set_scale(core, core->width, core->height, core->field);\n\tif (streaming)\n\t\tblackbird_start_codec(dev);\n\treturn 0;\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tchar name[32 + 2];\n\n\tsnprintf(name, sizeof(name), \"%s/2\", core->name);\n\tcall_all(core, core, log_status);\n\tv4l2_ctrl_handler_log_status(&dev->cxhdl.hdl, name);\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\treturn cx88_enum_input(core, i);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t      struct v4l2_frequency *f)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (unlikely(f->tuner != 0))\n\t\treturn -EINVAL;\n\n\tf->frequency = core->freq;\n\tcall_all(core, tuner, g_frequency, f);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\t*i = core->input;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (i >= 4)\n\t\treturn -EINVAL;\n\tif (!INPUT(i).type)\n\t\treturn -EINVAL;\n\n\tcx88_newstation(core);\n\tcx88_video_mux(core, i);\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t  struct v4l2_tuner *t)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\tu32 reg;\n\n\tif (unlikely(core->board.tuner_type == UNSET))\n\t\treturn -EINVAL;\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\tt->capability = V4L2_TUNER_CAP_NORM;\n\tt->rangehigh  = 0xffffffffUL;\n\tcall_all(core, tuner, g_tuner, t);\n\n\tcx88_get_stereo(core, t);\n\treg = cx_read(MO_DEVICE_STATUS);\n\tt->signal = (reg & (1 << 5)) ? 0xffff : 0x0000;\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t  const struct v4l2_tuner *t)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\tif (core->board.tuner_type == UNSET)\n\t\treturn -EINVAL;\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tcx88_set_stereo(core, t->audmode, 1);\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\t*tvnorm = core->tvnorm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct cx8802_dev *dev = video_drvdata(file);\n\tstruct cx88_core *core = dev->core;\n\n\treturn cx88_set_tvnorm(core, id);\n}\n\nstatic const struct v4l2_file_operations mpeg_fops = {\n\t.owner\t       = THIS_MODULE,\n\t.open\t       = v4l2_fh_open,\n\t.release       = vb2_fop_release,\n\t.read\t       = vb2_fop_read,\n\t.poll          = vb2_fop_poll,\n\t.mmap\t       = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops mpeg_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n\t.vidioc_log_status    = vidioc_log_status,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_g_tuner       = vidioc_g_tuner,\n\t.vidioc_s_tuner       = vidioc_s_tuner,\n\t.vidioc_g_std         = vidioc_g_std,\n\t.vidioc_s_std         = vidioc_s_std,\n\t.vidioc_subscribe_event      = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event    = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device cx8802_mpeg_template = {\n\t.name                 = \"cx8802\",\n\t.fops                 = &mpeg_fops,\n\t.ioctl_ops\t      = &mpeg_ioctl_ops,\n\t.tvnorms              = CX88_NORMS,\n};\n\n \n\n \nstatic int cx8802_blackbird_advise_acquire(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tint err = 0;\n\n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_HAUPPAUGE_HVR1300:\n\t\t \n\t\t \n\t\tcx_set(MO_GP0_IO, 0x00000080);\n\t\tudelay(1000);\n\t\tcx_clear(MO_GP0_IO, 0x00000080);\n\t\tudelay(50);\n\t\tcx_set(MO_GP0_IO, 0x00000080);\n\t\tudelay(1000);\n\t\t \n\t\tcx_set(MO_GP0_IO, 0x00000004);\n\t\tudelay(1000);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t}\n\treturn err;\n}\n\n \nstatic int cx8802_blackbird_advise_release(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tint err = 0;\n\n\tswitch (core->boardnr) {\n\tcase CX88_BOARD_HAUPPAUGE_HVR1300:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t}\n\treturn err;\n}\n\nstatic void blackbird_unregister_video(struct cx8802_dev *dev)\n{\n\tvideo_unregister_device(&dev->mpeg_dev);\n}\n\nstatic int blackbird_register_video(struct cx8802_dev *dev)\n{\n\tint err;\n\n\tcx88_vdev_init(dev->core, dev->pci, &dev->mpeg_dev,\n\t\t       &cx8802_mpeg_template, \"mpeg\");\n\tdev->mpeg_dev.ctrl_handler = &dev->cxhdl.hdl;\n\tvideo_set_drvdata(&dev->mpeg_dev, dev);\n\tdev->mpeg_dev.queue = &dev->vb2_mpegq;\n\tdev->mpeg_dev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t    V4L2_CAP_VIDEO_CAPTURE;\n\tif (dev->core->board.tuner_type != UNSET)\n\t\tdev->mpeg_dev.device_caps |= V4L2_CAP_TUNER;\n\terr = video_register_device(&dev->mpeg_dev, VFL_TYPE_VIDEO, -1);\n\tif (err < 0) {\n\t\tpr_info(\"can't register mpeg device\\n\");\n\t\treturn err;\n\t}\n\tpr_info(\"registered device %s [mpeg]\\n\",\n\t\tvideo_device_node_name(&dev->mpeg_dev));\n\treturn 0;\n}\n\n \n\nstatic int cx8802_blackbird_probe(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tstruct cx8802_dev *dev = core->dvbdev;\n\tstruct vb2_queue *q;\n\tint err;\n\n\tdprintk(1, \"%s\\n\", __func__);\n\tdprintk(1, \" ->being probed by Card=%d Name=%s, PCI %02x:%02x\\n\",\n\t\tcore->boardnr,\n\t\tcore->name,\n\t\tcore->pci_bus,\n\t\tcore->pci_slot);\n\n\terr = -ENODEV;\n\tif (!(core->board.mpeg & CX88_MPEG_BLACKBIRD))\n\t\tgoto fail_core;\n\n\tdev->cxhdl.port = CX2341X_PORT_STREAMING;\n\tdev->cxhdl.width = core->width;\n\tdev->cxhdl.height = core->height;\n\tdev->cxhdl.func = blackbird_mbox_func;\n\tdev->cxhdl.priv = dev;\n\terr = cx2341x_handler_init(&dev->cxhdl, 36);\n\tif (err)\n\t\tgoto fail_core;\n\tv4l2_ctrl_add_handler(&dev->cxhdl.hdl, &core->video_hdl, NULL, false);\n\n\t \n\tpr_info(\"cx23416 based mpeg encoder (blackbird reference design)\\n\");\n\thost_setup(dev->core);\n\n\tblackbird_initialize_codec(dev);\n\n\t \n \n\tcx88_set_tvnorm(core, core->tvnorm);\n\tcx88_video_mux(core, 0);\n\tcx2341x_handler_set_50hz(&dev->cxhdl, core->height == 576);\n\tcx2341x_handler_setup(&dev->cxhdl);\n\n\tq = &dev->vb2_mpegq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx88_buffer);\n\tq->ops = &blackbird_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &core->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\tgoto fail_core;\n\n\tblackbird_register_video(dev);\n\n\treturn 0;\n\nfail_core:\n\treturn err;\n}\n\nstatic int cx8802_blackbird_remove(struct cx8802_driver *drv)\n{\n\tstruct cx88_core *core = drv->core;\n\tstruct cx8802_dev *dev = core->dvbdev;\n\n\t \n\tblackbird_unregister_video(drv->core->dvbdev);\n\tv4l2_ctrl_handler_free(&dev->cxhdl.hdl);\n\n\treturn 0;\n}\n\nstatic struct cx8802_driver cx8802_blackbird_driver = {\n\t.type_id\t= CX88_MPEG_BLACKBIRD,\n\t.hw_access\t= CX8802_DRVCTL_SHARED,\n\t.probe\t\t= cx8802_blackbird_probe,\n\t.remove\t\t= cx8802_blackbird_remove,\n\t.advise_acquire\t= cx8802_blackbird_advise_acquire,\n\t.advise_release\t= cx8802_blackbird_advise_release,\n};\n\nstatic int __init blackbird_init(void)\n{\n\tpr_info(\"cx2388x blackbird driver version %s loaded\\n\",\n\t\tCX88_VERSION);\n\treturn cx8802_register_driver(&cx8802_blackbird_driver);\n}\n\nstatic void __exit blackbird_fini(void)\n{\n\tcx8802_unregister_driver(&cx8802_blackbird_driver);\n}\n\nmodule_init(blackbird_init);\nmodule_exit(blackbird_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}