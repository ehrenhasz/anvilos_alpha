{
  "module_name": "cx88-vbi.c",
  "hash_id": "ce539a51b7ff80c89b6378e73dc1a6993f84d9148d947b1e34cdf7cb8eaf6144",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx88/cx88-vbi.c",
  "human_readable_source": "\n \n\n#include \"cx88.h\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic unsigned int vbi_debug;\nmodule_param(vbi_debug, int, 0644);\nMODULE_PARM_DESC(vbi_debug, \"enable debug messages [vbi]\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\\\n\tif (vbi_debug >= level)\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: vbi:\" fmt),\t\\\n\t\t\t__func__, ##arg);\t\t\t\\\n} while (0)\n\n \n\nint cx8800_vbi_fmt(struct file *file, void *priv,\n\t\t   struct v4l2_format *f)\n{\n\tstruct cx8800_dev *dev = video_drvdata(file);\n\n\tf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\n\tf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tf->fmt.vbi.offset = 244;\n\n\tif (dev->core->tvnorm & V4L2_STD_525_60) {\n\t\t \n\t\tf->fmt.vbi.sampling_rate = 28636363;\n\t\tf->fmt.vbi.start[0] = 10;\n\t\tf->fmt.vbi.start[1] = 273;\n\t\tf->fmt.vbi.count[0] = VBI_LINE_NTSC_COUNT;\n\t\tf->fmt.vbi.count[1] = VBI_LINE_NTSC_COUNT;\n\n\t} else if (dev->core->tvnorm & V4L2_STD_625_50) {\n\t\t \n\t\tf->fmt.vbi.sampling_rate = 35468950;\n\t\tf->fmt.vbi.start[0] = V4L2_VBI_ITU_625_F1_START + 5;\n\t\tf->fmt.vbi.start[1] = V4L2_VBI_ITU_625_F2_START + 5;\n\t\tf->fmt.vbi.count[0] = VBI_LINE_PAL_COUNT;\n\t\tf->fmt.vbi.count[1] = VBI_LINE_PAL_COUNT;\n\t}\n\treturn 0;\n}\n\nstatic int cx8800_start_vbi_dma(struct cx8800_dev    *dev,\n\t\t\t\tstruct cx88_dmaqueue *q,\n\t\t\t\tstruct cx88_buffer   *buf)\n{\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tcx88_sram_channel_setup(dev->core, &cx88_sram_channels[SRAM_CH24],\n\t\t\t\tVBI_LINE_LENGTH, buf->risc.dma);\n\n\tcx_write(MO_VBOS_CONTROL, (1 << 18) |   \n\t\t\t\t  (1 << 15) |   \n\t\t\t\t  (1 << 11));\n\n\t \n\tcx_write(MO_VBI_GPCNTRL, GP_COUNT_CONTROL_RESET);\n\tq->count = 0;\n\n\t \n\tcx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_VIDINT);\n\tcx_set(MO_VID_INTMSK, 0x0f0088);\n\n\t \n\tcx_set(VID_CAPTURE_CONTROL, 0x18);\n\n\t \n\tcx_set(MO_DEV_CNTRL2, (1 << 5));\n\tcx_set(MO_VID_DMACNTRL, 0x88);\n\n\treturn 0;\n}\n\nvoid cx8800_stop_vbi_dma(struct cx8800_dev *dev)\n{\n\tstruct cx88_core *core = dev->core;\n\n\t \n\tcx_clear(MO_VID_DMACNTRL, 0x88);\n\n\t \n\tcx_clear(VID_CAPTURE_CONTROL, 0x18);\n\n\t \n\tcx_clear(MO_PCI_INTMSK, PCI_INT_VIDINT);\n\tcx_clear(MO_VID_INTMSK, 0x0f0088);\n}\n\nint cx8800_restart_vbi_queue(struct cx8800_dev    *dev,\n\t\t\t     struct cx88_dmaqueue *q)\n{\n\tstruct cx88_buffer *buf;\n\n\tif (list_empty(&q->active))\n\t\treturn 0;\n\n\tbuf = list_entry(q->active.next, struct cx88_buffer, list);\n\tdprintk(2, \"restart_queue [%p/%d]: restart dma\\n\",\n\t\tbuf, buf->vb.vb2_buf.index);\n\tcx8800_start_vbi_dma(dev, q, buf);\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\n\t*num_planes = 1;\n\tif (dev->core->tvnorm & V4L2_STD_525_60)\n\t\tsizes[0] = VBI_LINE_NTSC_COUNT * VBI_LINE_LENGTH * 2;\n\telse\n\t\tsizes[0] = VBI_LINE_PAL_COUNT * VBI_LINE_LENGTH * 2;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tunsigned int lines;\n\tunsigned int size;\n\n\tif (dev->core->tvnorm & V4L2_STD_525_60)\n\t\tlines = VBI_LINE_NTSC_COUNT;\n\telse\n\t\tlines = VBI_LINE_PAL_COUNT;\n\tsize = lines * VBI_LINE_LENGTH * 2;\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn cx88_risc_buffer(dev->pci, &buf->risc, sgt->sgl,\n\t\t\t\t0, VBI_LINE_LENGTH * lines,\n\t\t\t\tVBI_LINE_LENGTH, 0,\n\t\t\t\tlines);\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct cx88_riscmem *risc = &buf->risc;\n\n\tif (risc->cpu)\n\t\tdma_free_coherent(&dev->pci->dev, risc->size, risc->cpu,\n\t\t\t\t  risc->dma);\n\tmemset(risc, 0, sizeof(*risc));\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx88_buffer    *buf = container_of(vbuf, struct cx88_buffer, vb);\n\tstruct cx88_buffer    *prev;\n\tstruct cx88_dmaqueue  *q    = &dev->vbiq;\n\n\t \n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);\n\n\tif (list_empty(&q->active)) {\n\t\tlist_add_tail(&buf->list, &q->active);\n\t\tdprintk(2, \"[%p/%d] vbi_queue - first active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tprev = list_entry(q->active.prev, struct cx88_buffer, list);\n\t\tlist_add_tail(&buf->list, &q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t\tdprintk(2, \"[%p/%d] buffer_queue - append to active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\t}\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\tstruct cx88_dmaqueue *dmaq = &dev->vbiq;\n\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\tcx8800_start_vbi_dma(dev, dmaq, buf);\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx8800_dev *dev = q->drv_priv;\n\tstruct cx88_core *core = dev->core;\n\tstruct cx88_dmaqueue *dmaq = &dev->vbiq;\n\tunsigned long flags;\n\n\tcx_clear(MO_VID_DMACNTRL, 0x11);\n\tcx_clear(VID_CAPTURE_CONTROL, 0x06);\n\tcx8800_stop_vbi_dma(dev);\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx88_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx88_buffer, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nconst struct vb2_ops cx8800_vbi_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}