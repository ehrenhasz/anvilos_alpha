{
  "module_name": "dt3155.c",
  "hash_id": "b62d35ce5c9b5ce7248f560a248a9761d0cd200d22c6794727f41fd60d6d47a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/dt3155/dt3155.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/stringify.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"dt3155.h\"\n\n#define DT3155_DEVICE_ID 0x1223\n\n \nstatic int read_i2c_reg(void __iomem *addr, u8 index, u8 *data)\n{\n\tu32 tmp = index;\n\n\tiowrite32((tmp << 17) | IIC_READ, addr + IIC_CSR2);\n\tudelay(45);  \n\tif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\n\t\treturn -EIO;  \n\ttmp = ioread32(addr + IIC_CSR1);\n\tif (tmp & DIRECT_ABORT) {\n\t\t \n\t\tiowrite32(DIRECT_ABORT, addr + IIC_CSR1);\n\t\treturn -EIO;  \n\t}\n\t*data = tmp >> 24;\n\treturn 0;\n}\n\n \nstatic int write_i2c_reg(void __iomem *addr, u8 index, u8 data)\n{\n\tu32 tmp = index;\n\n\tiowrite32((tmp << 17) | IIC_WRITE | data, addr + IIC_CSR2);\n\tudelay(65);  \n\tif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\n\t\treturn -EIO;  \n\tif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\n\t\t \n\t\tiowrite32(DIRECT_ABORT, addr + IIC_CSR1);\n\t\treturn -EIO;  \n\t}\n\treturn 0;\n}\n\n \nstatic void write_i2c_reg_nowait(void __iomem *addr, u8 index, u8 data)\n{\n\tu32 tmp = index;\n\n\tiowrite32((tmp << 17) | IIC_WRITE | data, addr + IIC_CSR2);\n}\n\n \nstatic int wait_i2c_reg(void __iomem *addr)\n{\n\tif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\n\t\tudelay(65);  \n\tif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\n\t\treturn -EIO;  \n\tif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\n\t\t \n\t\tiowrite32(DIRECT_ABORT, addr + IIC_CSR1);\n\t\treturn -EIO;  \n\t}\n\treturn 0;\n}\n\nstatic int\ndt3155_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers, unsigned int *num_planes,\n\t\tunsigned int sizes[], struct device *alloc_devs[])\n\n{\n\tstruct dt3155_priv *pd = vb2_get_drv_priv(vq);\n\tunsigned size = pd->width * pd->height;\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int dt3155_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct dt3155_priv *pd = vb2_get_drv_priv(vb->vb2_queue);\n\n\tvb2_set_plane_payload(vb, 0, pd->width * pd->height);\n\treturn 0;\n}\n\nstatic int dt3155_start_streaming(struct vb2_queue *q, unsigned count)\n{\n\tstruct dt3155_priv *pd = vb2_get_drv_priv(q);\n\tstruct vb2_buffer *vb = &pd->curr_buf->vb2_buf;\n\tdma_addr_t dma_addr;\n\n\tpd->sequence = 0;\n\tdma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tiowrite32(dma_addr, pd->regs + EVEN_DMA_START);\n\tiowrite32(dma_addr + pd->width, pd->regs + ODD_DMA_START);\n\tiowrite32(pd->width, pd->regs + EVEN_DMA_STRIDE);\n\tiowrite32(pd->width, pd->regs + ODD_DMA_STRIDE);\n\t \n\tiowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\n\t\t\tFLD_END_EVEN | FLD_END_ODD, pd->regs + INT_CSR);\n\tiowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\n\t\t  FLD_DN_ODD | FLD_DN_EVEN | CAP_CONT_EVEN | CAP_CONT_ODD,\n\t\t\t\t\t\t\tpd->regs + CSR1);\n\twait_i2c_reg(pd->regs);\n\twrite_i2c_reg(pd->regs, CONFIG, pd->config);\n\twrite_i2c_reg(pd->regs, EVEN_CSR, CSR_ERROR | CSR_DONE);\n\twrite_i2c_reg(pd->regs, ODD_CSR, CSR_ERROR | CSR_DONE);\n\n\t \n\twrite_i2c_reg(pd->regs, CSR2, pd->csr2 | BUSY_EVEN | BUSY_ODD);\n\treturn 0;\n}\n\nstatic void dt3155_stop_streaming(struct vb2_queue *q)\n{\n\tstruct dt3155_priv *pd = vb2_get_drv_priv(q);\n\tstruct vb2_buffer *vb;\n\n\tspin_lock_irq(&pd->lock);\n\t \n\twrite_i2c_reg_nowait(pd->regs, CSR2, pd->csr2);\n\tiowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\n\t\t  FLD_DN_ODD | FLD_DN_EVEN, pd->regs + CSR1);\n\t \n\tiowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD, pd->regs + INT_CSR);\n\tspin_unlock_irq(&pd->lock);\n\n\t \n\tmsleep(45);\n\n\tspin_lock_irq(&pd->lock);\n\tif (pd->curr_buf) {\n\t\tvb2_buffer_done(&pd->curr_buf->vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tpd->curr_buf = NULL;\n\t}\n\n\twhile (!list_empty(&pd->dmaq)) {\n\t\tvb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);\n\t\tlist_del(&vb->done_entry);\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irq(&pd->lock);\n}\n\nstatic void dt3155_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dt3155_priv *pd = vb2_get_drv_priv(vb->vb2_queue);\n\n\t \n\tspin_lock_irq(&pd->lock);\n\tif (pd->curr_buf)\n\t\tlist_add_tail(&vb->done_entry, &pd->dmaq);\n\telse\n\t\tpd->curr_buf = vbuf;\n\tspin_unlock_irq(&pd->lock);\n}\n\nstatic const struct vb2_ops q_ops = {\n\t.queue_setup = dt3155_queue_setup,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.buf_prepare = dt3155_buf_prepare,\n\t.start_streaming = dt3155_start_streaming,\n\t.stop_streaming = dt3155_stop_streaming,\n\t.buf_queue = dt3155_buf_queue,\n};\n\nstatic irqreturn_t dt3155_irq_handler_even(int irq, void *dev_id)\n{\n\tstruct dt3155_priv *ipd = dev_id;\n\tstruct vb2_buffer *ivb;\n\tdma_addr_t dma_addr;\n\tu32 tmp;\n\n\ttmp = ioread32(ipd->regs + INT_CSR) & (FLD_START | FLD_END_ODD);\n\tif (!tmp)\n\t\treturn IRQ_NONE;   \n\tif ((tmp & FLD_START) && !(tmp & FLD_END_ODD)) {\n\t\tiowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START,\n\t\t\t\t\t\t\tipd->regs + INT_CSR);\n\t\treturn IRQ_HANDLED;  \n\t}\n\ttmp = ioread32(ipd->regs + CSR1) & (FLD_CRPT_EVEN | FLD_CRPT_ODD);\n\tif (tmp) {\n\t\tiowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\n\t\t\t\t\t\tFLD_DN_ODD | FLD_DN_EVEN |\n\t\t\t\t\t\tCAP_CONT_EVEN | CAP_CONT_ODD,\n\t\t\t\t\t\t\tipd->regs + CSR1);\n\t}\n\n\tspin_lock(&ipd->lock);\n\tif (ipd->curr_buf && !list_empty(&ipd->dmaq)) {\n\t\tipd->curr_buf->vb2_buf.timestamp = ktime_get_ns();\n\t\tipd->curr_buf->sequence = ipd->sequence++;\n\t\tipd->curr_buf->field = V4L2_FIELD_NONE;\n\t\tvb2_buffer_done(&ipd->curr_buf->vb2_buf, VB2_BUF_STATE_DONE);\n\n\t\tivb = list_first_entry(&ipd->dmaq, typeof(*ivb), done_entry);\n\t\tlist_del(&ivb->done_entry);\n\t\tipd->curr_buf = to_vb2_v4l2_buffer(ivb);\n\t\tdma_addr = vb2_dma_contig_plane_dma_addr(ivb, 0);\n\t\tiowrite32(dma_addr, ipd->regs + EVEN_DMA_START);\n\t\tiowrite32(dma_addr + ipd->width, ipd->regs + ODD_DMA_START);\n\t\tiowrite32(ipd->width, ipd->regs + EVEN_DMA_STRIDE);\n\t\tiowrite32(ipd->width, ipd->regs + ODD_DMA_STRIDE);\n\t}\n\n\t \n\tiowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\n\t\t\tFLD_END_EVEN | FLD_END_ODD, ipd->regs + INT_CSR);\n\tspin_unlock(&ipd->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct v4l2_file_operations dt3155_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll\n};\n\nstatic int dt3155_querycap(struct file *filp, void *p,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DT3155_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, DT3155_NAME \" frame grabber\", sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int dt3155_enum_fmt_vid_cap(struct file *filp,\n\t\t\t\t   void *p, struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\tf->pixelformat = V4L2_PIX_FMT_GREY;\n\treturn 0;\n}\n\nstatic int dt3155_fmt_vid_cap(struct file *filp, void *p, struct v4l2_format *f)\n{\n\tstruct dt3155_priv *pd = video_drvdata(filp);\n\n\tf->fmt.pix.width = pd->width;\n\tf->fmt.pix.height = pd->height;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_GREY;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width;\n\tf->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int dt3155_g_std(struct file *filp, void *p, v4l2_std_id *norm)\n{\n\tstruct dt3155_priv *pd = video_drvdata(filp);\n\n\t*norm = pd->std;\n\treturn 0;\n}\n\nstatic int dt3155_s_std(struct file *filp, void *p, v4l2_std_id norm)\n{\n\tstruct dt3155_priv *pd = video_drvdata(filp);\n\n\tif (pd->std == norm)\n\t\treturn 0;\n\tif (vb2_is_busy(&pd->vidq))\n\t\treturn -EBUSY;\n\tpd->std = norm;\n\tif (pd->std & V4L2_STD_525_60) {\n\t\tpd->csr2 = VT_60HZ;\n\t\tpd->width = 640;\n\t\tpd->height = 480;\n\t} else {\n\t\tpd->csr2 = VT_50HZ;\n\t\tpd->width = 768;\n\t\tpd->height = 576;\n\t}\n\treturn 0;\n}\n\nstatic int dt3155_enum_input(struct file *filp, void *p,\n\t\t\t     struct v4l2_input *input)\n{\n\tif (input->index > 3)\n\t\treturn -EINVAL;\n\tif (input->index)\n\t\tsnprintf(input->name, sizeof(input->name), \"VID%d\",\n\t\t\t input->index);\n\telse\n\t\tstrscpy(input->name, \"J2/VID0\", sizeof(input->name));\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tinput->std = V4L2_STD_ALL;\n\tinput->status = 0;\n\treturn 0;\n}\n\nstatic int dt3155_g_input(struct file *filp, void *p, unsigned int *i)\n{\n\tstruct dt3155_priv *pd = video_drvdata(filp);\n\n\t*i = pd->input;\n\treturn 0;\n}\n\nstatic int dt3155_s_input(struct file *filp, void *p, unsigned int i)\n{\n\tstruct dt3155_priv *pd = video_drvdata(filp);\n\n\tif (i > 3)\n\t\treturn -EINVAL;\n\tpd->input = i;\n\twrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\n\twrite_i2c_reg(pd->regs, AD_CMD, (i << 6) | (i << 4) | SYNC_LVL_3);\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops dt3155_ioctl_ops = {\n\t.vidioc_querycap = dt3155_querycap,\n\t.vidioc_enum_fmt_vid_cap = dt3155_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = dt3155_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = dt3155_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = dt3155_fmt_vid_cap,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_g_std = dt3155_g_std,\n\t.vidioc_s_std = dt3155_s_std,\n\t.vidioc_enum_input = dt3155_enum_input,\n\t.vidioc_g_input = dt3155_g_input,\n\t.vidioc_s_input = dt3155_s_input,\n};\n\nstatic int dt3155_init_board(struct dt3155_priv *pd)\n{\n\tstruct pci_dev *pdev = pd->pdev;\n\tint i;\n\tu8 tmp = 0;\n\n\tpci_set_master(pdev);  \n\n\t \n\tiowrite32(ADDR_ERR_ODD | ADDR_ERR_EVEN | FLD_CRPT_ODD | FLD_CRPT_EVEN |\n\t\t\tFLD_DN_ODD | FLD_DN_EVEN, pd->regs + CSR1);\n\tmsleep(20);\n\n\t \n\tiowrite32(FIFO_EN | SRST, pd->regs + CSR1);\n\tiowrite32(0xEEEEEE01, pd->regs + EVEN_PIXEL_FMT);\n\tiowrite32(0xEEEEEE01, pd->regs + ODD_PIXEL_FMT);\n\tiowrite32(0x00000020, pd->regs + FIFO_TRIGGER);\n\tiowrite32(0x00000103, pd->regs + XFER_MODE);\n\tiowrite32(0, pd->regs + RETRY_WAIT_CNT);\n\tiowrite32(0, pd->regs + INT_CSR);\n\tiowrite32(1, pd->regs + EVEN_FLD_MASK);\n\tiowrite32(1, pd->regs + ODD_FLD_MASK);\n\tiowrite32(0, pd->regs + MASK_LENGTH);\n\tiowrite32(0x0005007C, pd->regs + FIFO_FLAG_CNT);\n\tiowrite32(0x01010101, pd->regs + IIC_CLK_DUR);\n\n\t \n\tread_i2c_reg(pd->regs, DT_ID, &tmp);\n\tif (tmp != DT3155_ID)\n\t\treturn -ENODEV;\n\n\t \n\twrite_i2c_reg(pd->regs, AD_ADDR, 0);\n\tfor (i = 0; i < 256; i++)\n\t\twrite_i2c_reg(pd->regs, AD_LUT, i);\n\n\t \n\t \n\twrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\n\twrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\n\twrite_i2c_reg(pd->regs, AD_ADDR, AD_POS_REF);\n\twrite_i2c_reg(pd->regs, AD_CMD, 34);\n\twrite_i2c_reg(pd->regs, AD_ADDR, AD_NEG_REF);\n\twrite_i2c_reg(pd->regs, AD_CMD, 0);\n\n\t \n\twrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM);\n\tfor (i = 0; i < 256; i++) {\n\t\twrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\n\t\twrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\n\t}\n\twrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM | PM_LUT_SEL);\n\tfor (i = 0; i < 256; i++) {\n\t\twrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\n\t\twrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\n\t}\n\twrite_i2c_reg(pd->regs, CONFIG, pd->config);  \n\n\t \n\twrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\n\twrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\n\n\t \n\tiowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD,\n\t\t\tpd->regs + INT_CSR);\n\n\treturn 0;\n}\n\nstatic const struct video_device dt3155_vdev = {\n\t.name = DT3155_NAME,\n\t.fops = &dt3155_fops,\n\t.ioctl_ops = &dt3155_ioctl_ops,\n\t.minor = -1,\n\t.release = video_device_release_empty,\n\t.tvnorms = V4L2_STD_ALL,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t       V4L2_CAP_READWRITE,\n};\n\nstatic int dt3155_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tstruct dt3155_priv *pd;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn -ENODEV;\n\tpd = devm_kzalloc(&pdev->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\terr = v4l2_device_register(&pdev->dev, &pd->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\tpd->vdev = dt3155_vdev;\n\tpd->vdev.v4l2_dev = &pd->v4l2_dev;\n\tvideo_set_drvdata(&pd->vdev, pd);   \n\tpd->pdev = pdev;\n\tpd->std = V4L2_STD_625_50;\n\tpd->csr2 = VT_50HZ;\n\tpd->width = 768;\n\tpd->height = 576;\n\tINIT_LIST_HEAD(&pd->dmaq);\n\tmutex_init(&pd->mux);\n\tpd->vdev.lock = &pd->mux;  \n\tpd->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tpd->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tpd->vidq.io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tpd->vidq.ops = &q_ops;\n\tpd->vidq.mem_ops = &vb2_dma_contig_memops;\n\tpd->vidq.drv_priv = pd;\n\tpd->vidq.min_buffers_needed = 2;\n\tpd->vidq.gfp_flags = GFP_DMA32;\n\tpd->vidq.lock = &pd->mux;  \n\tpd->vidq.dev = &pdev->dev;\n\tpd->vdev.queue = &pd->vidq;\n\terr = vb2_queue_init(&pd->vidq);\n\tif (err < 0)\n\t\tgoto err_v4l2_dev_unreg;\n\tspin_lock_init(&pd->lock);\n\tpd->config = ACQ_MODE_EVEN;\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto err_v4l2_dev_unreg;\n\terr = pci_request_region(pdev, 0, pci_name(pdev));\n\tif (err)\n\t\tgoto err_pci_disable;\n\tpd->regs = pci_iomap(pdev, 0, pci_resource_len(pd->pdev, 0));\n\tif (!pd->regs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\terr = dt3155_init_board(pd);\n\tif (err)\n\t\tgoto err_iounmap;\n\terr = request_irq(pd->pdev->irq, dt3155_irq_handler_even,\n\t\t\t\t\tIRQF_SHARED, DT3155_NAME, pd);\n\tif (err)\n\t\tgoto err_iounmap;\n\terr = video_register_device(&pd->vdev, VFL_TYPE_VIDEO, -1);\n\tif (err)\n\t\tgoto err_free_irq;\n\tdev_info(&pdev->dev, \"/dev/video%i is ready\\n\", pd->vdev.minor);\n\treturn 0;   \n\nerr_free_irq:\n\tfree_irq(pd->pdev->irq, pd);\nerr_iounmap:\n\tpci_iounmap(pdev, pd->regs);\nerr_free_reg:\n\tpci_release_region(pdev, 0);\nerr_pci_disable:\n\tpci_disable_device(pdev);\nerr_v4l2_dev_unreg:\n\tv4l2_device_unregister(&pd->v4l2_dev);\n\treturn err;\n}\n\nstatic void dt3155_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct dt3155_priv *pd = container_of(v4l2_dev, struct dt3155_priv,\n\t\t\t\t\t      v4l2_dev);\n\n\tvb2_video_unregister_device(&pd->vdev);\n\tfree_irq(pd->pdev->irq, pd);\n\tv4l2_device_unregister(&pd->v4l2_dev);\n\tpci_iounmap(pdev, pd->regs);\n\tpci_release_region(pdev, 0);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, DT3155_DEVICE_ID) },\n\t{ 0,   },\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nstatic struct pci_driver pci_driver = {\n\t.name = DT3155_NAME,\n\t.id_table = pci_ids,\n\t.probe = dt3155_probe,\n\t.remove = dt3155_remove,\n};\n\nmodule_pci_driver(pci_driver);\n\nMODULE_DESCRIPTION(\"video4linux pci-driver for dt3155 frame grabber\");\nMODULE_AUTHOR(\"Marin Mitov <mitov@issp.bas.bg>\");\nMODULE_VERSION(DT3155_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}