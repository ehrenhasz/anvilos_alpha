{
  "module_name": "dm1105.c",
  "hash_id": "6b251392740b39ecdfa26a9744cb450c9ed91815c09fe071a402f2a47e468d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/dm1105/dm1105.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n\n#include <media/demux.h>\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n#include <media/dvbdev.h>\n#include \"dvb-pll.h\"\n\n#include \"stv0299.h\"\n#include \"stv0288.h\"\n#include \"stb6000.h\"\n#include \"si21xx.h\"\n#include \"cx24116.h\"\n#include \"z0194a.h\"\n#include \"ts2020.h\"\n#include \"ds3000.h\"\n\n#define MODULE_NAME \"dm1105\"\n\n#define UNSET (-1U)\n\n#define DM1105_BOARD_NOAUTO\t\t\tUNSET\n#define DM1105_BOARD_UNKNOWN\t\t\t0\n#define DM1105_BOARD_DVBWORLD_2002\t\t1\n#define DM1105_BOARD_DVBWORLD_2004\t\t2\n#define DM1105_BOARD_AXESS_DM05\t\t\t3\n#define DM1105_BOARD_UNBRANDED_I2C_ON_GPIO\t4\n\n \n \n#ifndef PCI_VENDOR_ID_TRIGEM\n#define PCI_VENDOR_ID_TRIGEM\t0x109f\n#endif\n#ifndef PCI_VENDOR_ID_AXESS\n#define PCI_VENDOR_ID_AXESS\t0x195d\n#endif\n#ifndef PCI_DEVICE_ID_DM1105\n#define PCI_DEVICE_ID_DM1105\t0x036f\n#endif\n#ifndef PCI_DEVICE_ID_DW2002\n#define PCI_DEVICE_ID_DW2002\t0x2002\n#endif\n#ifndef PCI_DEVICE_ID_DW2004\n#define PCI_DEVICE_ID_DW2004\t0x2004\n#endif\n#ifndef PCI_DEVICE_ID_DM05\n#define PCI_DEVICE_ID_DM05\t0x1105\n#endif\n \n \n\n \n#define DM1105_TSCTR\t\t\t\t0x00\n#define DM1105_DTALENTH\t\t\t\t0x04\n\n \n#define DM1105_GPIOVAL\t\t\t\t0x08\n#define DM1105_GPIOCTR\t\t\t\t0x0c\n\n \n#define DM1105_PIDN\t\t\t\t0x10\n\n \n#define DM1105_CWSEL\t\t\t\t0x14\n\n \n#define DM1105_HOST_CTR\t\t\t\t0x18\n#define DM1105_HOST_AD\t\t\t\t0x1c\n\n \n#define DM1105_CR\t\t\t\t0x30\n#define DM1105_RST\t\t\t\t0x34\n#define DM1105_STADR\t\t\t\t0x38\n#define DM1105_RLEN\t\t\t\t0x3c\n#define DM1105_WRP\t\t\t\t0x40\n#define DM1105_INTCNT\t\t\t\t0x44\n#define DM1105_INTMAK\t\t\t\t0x48\n#define DM1105_INTSTS\t\t\t\t0x4c\n\n \n#define DM1105_ODD\t\t\t\t0x50\n#define DM1105_EVEN\t\t\t\t0x58\n\n \n#define DM1105_PID\t\t\t\t0x60\n\n \n#define DM1105_IRCTR\t\t\t\t0x64\n#define DM1105_IRMODE\t\t\t\t0x68\n#define DM1105_SYSTEMCODE\t\t\t0x6c\n#define DM1105_IRCODE\t\t\t\t0x70\n\n \n#define DM1105_ENCRYPT\t\t\t\t0x74\n#define DM1105_VER\t\t\t\t0x7c\n\n \n#define DM1105_I2CCTR\t\t\t\t0x80\n#define DM1105_I2CSTS\t\t\t\t0x81\n#define DM1105_I2CDAT\t\t\t\t0x82\n#define DM1105_I2C_RA\t\t\t\t0x83\n \n \n\n#define INTMAK_TSIRQM\t\t\t\t0x01\n#define INTMAK_HIRQM\t\t\t\t0x04\n#define INTMAK_IRM\t\t\t\t0x08\n#define INTMAK_ALLMASK\t\t\t\t(INTMAK_TSIRQM | \\\n\t\t\t\t\t\tINTMAK_HIRQM | \\\n\t\t\t\t\t\tINTMAK_IRM)\n#define INTMAK_NONEMASK\t\t\t\t0x00\n\n \n#define INTSTS_TSIRQ\t\t\t\t0x01\n#define INTSTS_HIRQ\t\t\t\t0x04\n#define INTSTS_IR\t\t\t\t0x08\n\n \n#define DM1105_IR_EN\t\t\t\t0x01\n#define DM1105_SYS_CHK\t\t\t\t0x02\n#define DM1105_REP_FLG\t\t\t\t0x08\n\n \n#define IIC_24C01_addr\t\t\t\t0xa0\n \n#define DM1105_MAX\t\t\t\t0x04\n\n#define DRIVER_NAME\t\t\t\t\"dm1105\"\n#define DM1105_I2C_GPIO_NAME\t\t\t\"dm1105-gpio\"\n\n#define DM1105_DMA_PACKETS\t\t\t47\n#define DM1105_DMA_PACKET_LENGTH\t\t(128*4)\n#define DM1105_DMA_BYTES\t\t\t(128 * 4 * DM1105_DMA_PACKETS)\n\n \n#define GPIO08\t\t\t\t\t(1 << 8)\n#define GPIO13\t\t\t\t\t(1 << 13)\n#define GPIO14\t\t\t\t\t(1 << 14)\n#define GPIO15\t\t\t\t\t(1 << 15)\n#define GPIO16\t\t\t\t\t(1 << 16)\n#define GPIO17\t\t\t\t\t(1 << 17)\n#define GPIO_ALL\t\t\t\t0x03ffff\n\n \n#define DM1105_LNB_MASK\t\t\t\t(GPIO_ALL & ~(GPIO14 | GPIO13))\n#define DM1105_LNB_OFF\t\t\t\tGPIO17\n#define DM1105_LNB_13V\t\t\t\t(GPIO16 | GPIO08)\n#define DM1105_LNB_18V\t\t\t\tGPIO08\n\n \n#define DM05_LNB_MASK\t\t\t\t(GPIO_ALL & ~(GPIO14 | GPIO13))\n#define DM05_LNB_OFF\t\t\t\tGPIO17 \n#define DM05_LNB_13V\t\t\t\tGPIO17\n#define DM05_LNB_18V\t\t\t\t(GPIO17 | GPIO16)\n\n \n#define UNBR_LNB_MASK\t\t\t\t(GPIO17 | GPIO16)\n#define UNBR_LNB_OFF\t\t\t\t0\n#define UNBR_LNB_13V\t\t\t\tGPIO17\n#define UNBR_LNB_18V\t\t\t\t(GPIO17 | GPIO16)\n\nstatic unsigned int card[]  = {[0 ... 3] = UNSET };\nmodule_param_array(card,  int, NULL, 0444);\nMODULE_PARM_DESC(card, \"card type\");\n\nstatic int ir_debug;\nmodule_param(ir_debug, int, 0644);\nMODULE_PARM_DESC(ir_debug, \"enable debugging information for IR decoding\");\n\nstatic unsigned int dm1105_devcount;\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct dm1105_board {\n\tchar\t*name;\n\tstruct\t{\n\t\tu32\tmask, off, v13, v18;\n\t} lnb;\n\tu32\tgpio_scl, gpio_sda;\n};\n\nstruct dm1105_subid {\n\tu16     subvendor;\n\tu16     subdevice;\n\tu32     card;\n};\n\nstatic const struct dm1105_board dm1105_boards[] = {\n\t[DM1105_BOARD_UNKNOWN] = {\n\t\t.name\t\t= \"UNKNOWN/GENERIC\",\n\t\t.lnb = {\n\t\t\t.mask = DM1105_LNB_MASK,\n\t\t\t.off = DM1105_LNB_OFF,\n\t\t\t.v13 = DM1105_LNB_13V,\n\t\t\t.v18 = DM1105_LNB_18V,\n\t\t},\n\t},\n\t[DM1105_BOARD_DVBWORLD_2002] = {\n\t\t.name\t\t= \"DVBWorld PCI 2002\",\n\t\t.lnb = {\n\t\t\t.mask = DM1105_LNB_MASK,\n\t\t\t.off = DM1105_LNB_OFF,\n\t\t\t.v13 = DM1105_LNB_13V,\n\t\t\t.v18 = DM1105_LNB_18V,\n\t\t},\n\t},\n\t[DM1105_BOARD_DVBWORLD_2004] = {\n\t\t.name\t\t= \"DVBWorld PCI 2004\",\n\t\t.lnb = {\n\t\t\t.mask = DM1105_LNB_MASK,\n\t\t\t.off = DM1105_LNB_OFF,\n\t\t\t.v13 = DM1105_LNB_13V,\n\t\t\t.v18 = DM1105_LNB_18V,\n\t\t},\n\t},\n\t[DM1105_BOARD_AXESS_DM05] = {\n\t\t.name\t\t= \"Axess/EasyTv DM05\",\n\t\t.lnb = {\n\t\t\t.mask = DM05_LNB_MASK,\n\t\t\t.off = DM05_LNB_OFF,\n\t\t\t.v13 = DM05_LNB_13V,\n\t\t\t.v18 = DM05_LNB_18V,\n\t\t},\n\t},\n\t[DM1105_BOARD_UNBRANDED_I2C_ON_GPIO] = {\n\t\t.name\t\t= \"Unbranded DM1105 with i2c on GPIOs\",\n\t\t.lnb = {\n\t\t\t.mask = UNBR_LNB_MASK,\n\t\t\t.off = UNBR_LNB_OFF,\n\t\t\t.v13 = UNBR_LNB_13V,\n\t\t\t.v18 = UNBR_LNB_18V,\n\t\t},\n\t\t.gpio_scl\t= GPIO14,\n\t\t.gpio_sda\t= GPIO13,\n\t},\n};\n\nstatic const struct dm1105_subid dm1105_subids[] = {\n\t{\n\t\t.subvendor = 0x0000,\n\t\t.subdevice = 0x2002,\n\t\t.card      = DM1105_BOARD_DVBWORLD_2002,\n\t}, {\n\t\t.subvendor = 0x0001,\n\t\t.subdevice = 0x2002,\n\t\t.card      = DM1105_BOARD_DVBWORLD_2002,\n\t}, {\n\t\t.subvendor = 0x0000,\n\t\t.subdevice = 0x2004,\n\t\t.card      = DM1105_BOARD_DVBWORLD_2004,\n\t}, {\n\t\t.subvendor = 0x0001,\n\t\t.subdevice = 0x2004,\n\t\t.card      = DM1105_BOARD_DVBWORLD_2004,\n\t}, {\n\t\t.subvendor = 0x195d,\n\t\t.subdevice = 0x1105,\n\t\t.card      = DM1105_BOARD_AXESS_DM05,\n\t},\n};\n\nstatic void dm1105_card_list(struct pci_dev *pci)\n{\n\tint i;\n\n\tif (0 == pci->subsystem_vendor &&\n\t\t\t0 == pci->subsystem_device) {\n\t\tprintk(KERN_ERR\n\t\t\t\"dm1105: Your board has no valid PCI Subsystem ID\\n\"\n\t\t\t\"dm1105: and thus can't be autodetected\\n\"\n\t\t\t\"dm1105: Please pass card=<n> insmod option to\\n\"\n\t\t\t\"dm1105: workaround that.  Redirect complaints to\\n\"\n\t\t\t\"dm1105: the vendor of the TV card.  Best regards,\\n\"\n\t\t\t\"dm1105: -- tux\\n\");\n\t} else {\n\t\tprintk(KERN_ERR\n\t\t\t\"dm1105: Your board isn't known (yet) to the driver.\\n\"\n\t\t\t\"dm1105: You can try to pick one of the existing\\n\"\n\t\t\t\"dm1105: card configs via card=<n> insmod option.\\n\"\n\t\t\t\"dm1105: Updating to the latest version might help\\n\"\n\t\t\t\"dm1105: as well.\\n\");\n\t}\n\tprintk(KERN_ERR \"Here is a list of valid choices for the card=<n> insmod option:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(dm1105_boards); i++)\n\t\tprintk(KERN_ERR \"dm1105:    card=%d -> %s\\n\",\n\t\t\t\ti, dm1105_boards[i].name);\n}\n\n \nstruct infrared {\n\tstruct rc_dev\t\t*dev;\n\tchar\t\t\tinput_phys[32];\n\tstruct work_struct\twork;\n\tu32\t\t\tir_command;\n};\n\nstruct dm1105_dev {\n\t \n\tstruct pci_dev *pdev;\n\tu8 __iomem *io_mem;\n\n\t \n\tstruct infrared ir;\n\n\t \n\tstruct dmx_frontend hw_frontend;\n\tstruct dmx_frontend mem_frontend;\n\tstruct dmxdev dmxdev;\n\tstruct dvb_adapter dvb_adapter;\n\tstruct dvb_demux demux;\n\tstruct dvb_frontend *fe;\n\tstruct dvb_net dvbnet;\n\tunsigned int full_ts_users;\n\tunsigned int boardnr;\n\tint nr;\n\n\t \n\tstruct i2c_adapter i2c_adap;\n\tstruct i2c_adapter i2c_bb_adap;\n\tstruct i2c_algo_bit_data i2c_bit;\n\n\t \n\tstruct work_struct work;\n\tstruct workqueue_struct *wq;\n\tchar wqn[16];\n\n\t \n\tdma_addr_t dma_addr;\n\tunsigned char *ts_buf;\n\tu32 wrp;\n\tu32 nextwrp;\n\tu32 buffer_size;\n\tunsigned int\tPacketErrorCount;\n\tunsigned int dmarst;\n\tspinlock_t lock;\n};\n\n#define dm_io_mem(reg)\t((unsigned long)(&dev->io_mem[reg]))\n\n#define dm_readb(reg)\t\tinb(dm_io_mem(reg))\n#define dm_writeb(reg, value)\toutb((value), (dm_io_mem(reg)))\n\n#define dm_readw(reg)\t\tinw(dm_io_mem(reg))\n#define dm_writew(reg, value)\toutw((value), (dm_io_mem(reg)))\n\n#define dm_readl(reg)\t\tinl(dm_io_mem(reg))\n#define dm_writel(reg, value)\toutl((value), (dm_io_mem(reg)))\n\n#define dm_andorl(reg, mask, value) \\\n\toutl((inl(dm_io_mem(reg)) & ~(mask)) |\\\n\t\t((value) & (mask)), (dm_io_mem(reg)))\n\n#define dm_setl(reg, bit)\tdm_andorl((reg), (bit), (bit))\n#define dm_clearl(reg, bit)\tdm_andorl((reg), (bit), 0)\n\n \nstatic void dm1105_gpio_set(struct dm1105_dev *dev, u32 mask)\n{\n\tif (mask & 0xfffc0000)\n\t\tprintk(KERN_ERR \"%s: Only 18 GPIO's are allowed\\n\", __func__);\n\n\tif (mask & 0x0003ffff)\n\t\tdm_setl(DM1105_GPIOVAL, mask & 0x0003ffff);\n\n}\n\nstatic void dm1105_gpio_clear(struct dm1105_dev *dev, u32 mask)\n{\n\tif (mask & 0xfffc0000)\n\t\tprintk(KERN_ERR \"%s: Only 18 GPIO's are allowed\\n\", __func__);\n\n\tif (mask & 0x0003ffff)\n\t\tdm_clearl(DM1105_GPIOVAL, mask & 0x0003ffff);\n\n}\n\nstatic void dm1105_gpio_andor(struct dm1105_dev *dev, u32 mask, u32 val)\n{\n\tif (mask & 0xfffc0000)\n\t\tprintk(KERN_ERR \"%s: Only 18 GPIO's are allowed\\n\", __func__);\n\n\tif (mask & 0x0003ffff)\n\t\tdm_andorl(DM1105_GPIOVAL, mask & 0x0003ffff, val);\n\n}\n\nstatic u32 dm1105_gpio_get(struct dm1105_dev *dev, u32 mask)\n{\n\tif (mask & 0xfffc0000)\n\t\tprintk(KERN_ERR \"%s: Only 18 GPIO's are allowed\\n\", __func__);\n\n\tif (mask & 0x0003ffff)\n\t\treturn dm_readl(DM1105_GPIOVAL) & mask & 0x0003ffff;\n\n\treturn 0;\n}\n\nstatic void dm1105_gpio_enable(struct dm1105_dev *dev, u32 mask, int asoutput)\n{\n\tif (mask & 0xfffc0000)\n\t\tprintk(KERN_ERR \"%s: Only 18 GPIO's are allowed\\n\", __func__);\n\n\tif ((mask & 0x0003ffff) && asoutput)\n\t\tdm_clearl(DM1105_GPIOCTR, mask & 0x0003ffff);\n\telse if ((mask & 0x0003ffff) && !asoutput)\n\t\tdm_setl(DM1105_GPIOCTR, mask & 0x0003ffff);\n\n}\n\nstatic void dm1105_setline(struct dm1105_dev *dev, u32 line, int state)\n{\n\tif (state)\n\t\tdm1105_gpio_enable(dev, line, 0);\n\telse {\n\t\tdm1105_gpio_enable(dev, line, 1);\n\t\tdm1105_gpio_clear(dev, line);\n\t}\n}\n\nstatic void dm1105_setsda(void *data, int state)\n{\n\tstruct dm1105_dev *dev = data;\n\n\tdm1105_setline(dev, dm1105_boards[dev->boardnr].gpio_sda, state);\n}\n\nstatic void dm1105_setscl(void *data, int state)\n{\n\tstruct dm1105_dev *dev = data;\n\n\tdm1105_setline(dev, dm1105_boards[dev->boardnr].gpio_scl, state);\n}\n\nstatic int dm1105_getsda(void *data)\n{\n\tstruct dm1105_dev *dev = data;\n\n\treturn dm1105_gpio_get(dev, dm1105_boards[dev->boardnr].gpio_sda)\n\t\t\t\t\t\t\t\t\t? 1 : 0;\n}\n\nstatic int dm1105_getscl(void *data)\n{\n\tstruct dm1105_dev *dev = data;\n\n\treturn dm1105_gpio_get(dev, dm1105_boards[dev->boardnr].gpio_scl)\n\t\t\t\t\t\t\t\t\t? 1 : 0;\n}\n\nstatic int dm1105_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct dm1105_dev *dev ;\n\n\tint addr, rc, i, j, k, len, byte, data;\n\tu8 status;\n\n\tdev = i2c_adap->algo_data;\n\tfor (i = 0; i < num; i++) {\n\t\tdm_writeb(DM1105_I2CCTR, 0x00);\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\taddr  = msgs[i].addr << 1;\n\t\t\taddr |= 1;\n\t\t\tdm_writeb(DM1105_I2CDAT, addr);\n\t\t\tfor (byte = 0; byte < msgs[i].len; byte++)\n\t\t\t\tdm_writeb(DM1105_I2CDAT + byte + 1, 0);\n\n\t\t\tdm_writeb(DM1105_I2CCTR, 0x81 + msgs[i].len);\n\t\t\tfor (j = 0; j < 55; j++) {\n\t\t\t\tmdelay(10);\n\t\t\t\tstatus = dm_readb(DM1105_I2CSTS);\n\t\t\t\tif ((status & 0xc0) == 0x40)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j >= 55)\n\t\t\t\treturn -1;\n\n\t\t\tfor (byte = 0; byte < msgs[i].len; byte++) {\n\t\t\t\trc = dm_readb(DM1105_I2CDAT + byte + 1);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tgoto err;\n\t\t\t\tmsgs[i].buf[byte] = rc;\n\t\t\t}\n\t\t} else if ((msgs[i].buf[0] == 0xf7) && (msgs[i].addr == 0x55)) {\n\t\t\t \n\t\t\t \n\t\t\tlen = msgs[i].len - 1;\n\t\t\tk = 1;\n\t\t\tdo {\n\t\t\t\tdm_writeb(DM1105_I2CDAT, msgs[i].addr << 1);\n\t\t\t\tdm_writeb(DM1105_I2CDAT + 1, 0xf7);\n\t\t\t\tfor (byte = 0; byte < (len > 48 ? 48 : len); byte++) {\n\t\t\t\t\tdata = msgs[i].buf[k + byte];\n\t\t\t\t\tdm_writeb(DM1105_I2CDAT + byte + 2, data);\n\t\t\t\t}\n\t\t\t\tdm_writeb(DM1105_I2CCTR, 0x82 + (len > 48 ? 48 : len));\n\t\t\t\tfor (j = 0; j < 25; j++) {\n\t\t\t\t\tmdelay(10);\n\t\t\t\t\tstatus = dm_readb(DM1105_I2CSTS);\n\t\t\t\t\tif ((status & 0xc0) == 0x40)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (j >= 25)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tk += 48;\n\t\t\t\tlen -= 48;\n\t\t\t} while (len > 0);\n\t\t} else {\n\t\t\t \n\t\t\tdm_writeb(DM1105_I2CDAT, msgs[i].addr << 1);\n\t\t\tfor (byte = 0; byte < msgs[i].len; byte++) {\n\t\t\t\tdata = msgs[i].buf[byte];\n\t\t\t\tdm_writeb(DM1105_I2CDAT + byte + 1, data);\n\t\t\t}\n\t\t\tdm_writeb(DM1105_I2CCTR, 0x81 + msgs[i].len);\n\t\t\tfor (j = 0; j < 25; j++) {\n\t\t\t\tmdelay(10);\n\t\t\t\tstatus = dm_readb(DM1105_I2CSTS);\n\t\t\t\tif ((status & 0xc0) == 0x40)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j >= 25)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn num;\n err:\n\treturn rc;\n}\n\nstatic u32 functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm dm1105_algo = {\n\t.master_xfer   = dm1105_i2c_xfer,\n\t.functionality = functionality,\n};\n\nstatic inline struct dm1105_dev *feed_to_dm1105_dev(struct dvb_demux_feed *feed)\n{\n\treturn container_of(feed->demux, struct dm1105_dev, demux);\n}\n\nstatic inline struct dm1105_dev *frontend_to_dm1105_dev(struct dvb_frontend *fe)\n{\n\treturn container_of(fe->dvb, struct dm1105_dev, dvb_adapter);\n}\n\nstatic int dm1105_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct dm1105_dev *dev = frontend_to_dm1105_dev(fe);\n\n\tdm1105_gpio_enable(dev, dm1105_boards[dev->boardnr].lnb.mask, 1);\n\tif (voltage == SEC_VOLTAGE_18)\n\t\tdm1105_gpio_andor(dev,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.mask,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.v18);\n\telse if (voltage == SEC_VOLTAGE_13)\n\t\tdm1105_gpio_andor(dev,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.mask,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.v13);\n\telse\n\t\tdm1105_gpio_andor(dev,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.mask,\n\t\t\t\tdm1105_boards[dev->boardnr].lnb.off);\n\n\treturn 0;\n}\n\nstatic void dm1105_set_dma_addr(struct dm1105_dev *dev)\n{\n\tdm_writel(DM1105_STADR, (__force u32)cpu_to_le32(dev->dma_addr));\n}\n\nstatic int dm1105_dma_map(struct dm1105_dev *dev)\n{\n\tdev->ts_buf = dma_alloc_coherent(&dev->pdev->dev,\n\t\t\t\t\t 6 * DM1105_DMA_BYTES, &dev->dma_addr,\n\t\t\t\t\t GFP_KERNEL);\n\n\treturn !dev->ts_buf;\n}\n\nstatic void dm1105_dma_unmap(struct dm1105_dev *dev)\n{\n\tdma_free_coherent(&dev->pdev->dev, 6 * DM1105_DMA_BYTES, dev->ts_buf,\n\t\t\t  dev->dma_addr);\n}\n\nstatic void dm1105_enable_irqs(struct dm1105_dev *dev)\n{\n\tdm_writeb(DM1105_INTMAK, INTMAK_ALLMASK);\n\tdm_writeb(DM1105_CR, 1);\n}\n\nstatic void dm1105_disable_irqs(struct dm1105_dev *dev)\n{\n\tdm_writeb(DM1105_INTMAK, INTMAK_IRM);\n\tdm_writeb(DM1105_CR, 0);\n}\n\nstatic int dm1105_start_feed(struct dvb_demux_feed *f)\n{\n\tstruct dm1105_dev *dev = feed_to_dm1105_dev(f);\n\n\tif (dev->full_ts_users++ == 0)\n\t\tdm1105_enable_irqs(dev);\n\n\treturn 0;\n}\n\nstatic int dm1105_stop_feed(struct dvb_demux_feed *f)\n{\n\tstruct dm1105_dev *dev = feed_to_dm1105_dev(f);\n\n\tif (--dev->full_ts_users == 0)\n\t\tdm1105_disable_irqs(dev);\n\n\treturn 0;\n}\n\n \nstatic void dm1105_emit_key(struct work_struct *work)\n{\n\tstruct infrared *ir = container_of(work, struct infrared, work);\n\tu32 ircom = ir->ir_command;\n\tu8 data;\n\n\tif (ir_debug)\n\t\tprintk(KERN_INFO \"%s: received byte 0x%04x\\n\", __func__, ircom);\n\n\tdata = (ircom >> 8) & 0x7f;\n\n\t \n\trc_keydown(ir->dev, RC_PROTO_UNKNOWN, data, 0);\n}\n\n \nstatic void dm1105_dmx_buffer(struct work_struct *work)\n{\n\tstruct dm1105_dev *dev = container_of(work, struct dm1105_dev, work);\n\tunsigned int nbpackets;\n\tu32 oldwrp = dev->wrp;\n\tu32 nextwrp = dev->nextwrp;\n\n\tif (!((dev->ts_buf[oldwrp] == 0x47) &&\n\t\t\t(dev->ts_buf[oldwrp + 188] == 0x47) &&\n\t\t\t(dev->ts_buf[oldwrp + 188 * 2] == 0x47))) {\n\t\tdev->PacketErrorCount++;\n\t\t \n\t\tif ((dev->PacketErrorCount >= 2) &&\n\t\t\t\t(dev->dmarst == 0)) {\n\t\t\tdm_writeb(DM1105_RST, 1);\n\t\t\tdev->wrp = 0;\n\t\t\tdev->PacketErrorCount = 0;\n\t\t\tdev->dmarst = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (nextwrp < oldwrp) {\n\t\tmemcpy(dev->ts_buf + dev->buffer_size, dev->ts_buf, nextwrp);\n\t\tnbpackets = ((dev->buffer_size - oldwrp) + nextwrp) / 188;\n\t} else\n\t\tnbpackets = (nextwrp - oldwrp) / 188;\n\n\tdev->wrp = nextwrp;\n\tdvb_dmx_swfilter_packets(&dev->demux, &dev->ts_buf[oldwrp], nbpackets);\n}\n\nstatic irqreturn_t dm1105_irq(int irq, void *dev_id)\n{\n\tstruct dm1105_dev *dev = dev_id;\n\n\t \n\tunsigned int intsts = dm_readb(DM1105_INTSTS);\n\tdm_writeb(DM1105_INTSTS, intsts);\n\n\tswitch (intsts) {\n\tcase INTSTS_TSIRQ:\n\tcase (INTSTS_TSIRQ | INTSTS_IR):\n\t\tdev->nextwrp = dm_readl(DM1105_WRP) - dm_readl(DM1105_STADR);\n\t\tqueue_work(dev->wq, &dev->work);\n\t\tbreak;\n\tcase INTSTS_IR:\n\t\tdev->ir.ir_command = dm_readl(DM1105_IRCODE);\n\t\tschedule_work(&dev->ir.work);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dm1105_ir_init(struct dm1105_dev *dm1105)\n{\n\tstruct rc_dev *dev;\n\tint err = -ENOMEM;\n\n\tdev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(dm1105->ir.input_phys, sizeof(dm1105->ir.input_phys),\n\t\t\"pci-%s/ir0\", pci_name(dm1105->pdev));\n\n\tdev->driver_name = MODULE_NAME;\n\tdev->map_name = RC_MAP_DM1105_NEC;\n\tdev->device_name = \"DVB on-card IR receiver\";\n\tdev->input_phys = dm1105->ir.input_phys;\n\tdev->input_id.bustype = BUS_PCI;\n\tdev->input_id.version = 1;\n\tif (dm1105->pdev->subsystem_vendor) {\n\t\tdev->input_id.vendor = dm1105->pdev->subsystem_vendor;\n\t\tdev->input_id.product = dm1105->pdev->subsystem_device;\n\t} else {\n\t\tdev->input_id.vendor = dm1105->pdev->vendor;\n\t\tdev->input_id.product = dm1105->pdev->device;\n\t}\n\tdev->dev.parent = &dm1105->pdev->dev;\n\n\tINIT_WORK(&dm1105->ir.work, dm1105_emit_key);\n\n\terr = rc_register_device(dev);\n\tif (err < 0) {\n\t\trc_free_device(dev);\n\t\treturn err;\n\t}\n\n\tdm1105->ir.dev = dev;\n\treturn 0;\n}\n\nstatic void dm1105_ir_exit(struct dm1105_dev *dm1105)\n{\n\trc_unregister_device(dm1105->ir.dev);\n}\n\nstatic int dm1105_hw_init(struct dm1105_dev *dev)\n{\n\tdm1105_disable_irqs(dev);\n\n\tdm_writeb(DM1105_HOST_CTR, 0);\n\n\t \n\tdm_writeb(DM1105_DTALENTH, 188);\n\t \n\tdm_writew(DM1105_TSCTR, 0xc10a);\n\n\t \n\tdm1105_dma_map(dev);\n\tdm1105_set_dma_addr(dev);\n\t \n\tdm_writel(DM1105_RLEN, 5 * DM1105_DMA_BYTES);\n\tdm_writeb(DM1105_INTCNT, 47);\n\n\t \n\tdm_writeb(DM1105_IRCTR, (DM1105_IR_EN | DM1105_SYS_CHK));\n\tdm_writeb(DM1105_IRMODE, 0);\n\tdm_writew(DM1105_SYSTEMCODE, 0);\n\n\treturn 0;\n}\n\nstatic void dm1105_hw_exit(struct dm1105_dev *dev)\n{\n\tdm1105_disable_irqs(dev);\n\n\t \n\tdm_writeb(DM1105_IRCTR, 0);\n\tdm_writeb(DM1105_INTMAK, INTMAK_NONEMASK);\n\n\tdm1105_dma_unmap(dev);\n}\n\nstatic const struct stv0299_config sharp_z0194a_config = {\n\t.demod_address = 0x68,\n\t.inittab = sharp_z0194a_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = sharp_z0194a_set_symbol_rate,\n};\n\nstatic struct stv0288_config earda_config = {\n\t.demod_address = 0x68,\n\t.min_delay_ms = 100,\n};\n\nstatic struct si21xx_config serit_config = {\n\t.demod_address = 0x68,\n\t.min_delay_ms = 100,\n\n};\n\nstatic struct cx24116_config serit_sp2633_config = {\n\t.demod_address = 0x55,\n};\n\nstatic struct ds3000_config dvbworld_ds3000_config = {\n\t.demod_address = 0x68,\n};\n\nstatic struct ts2020_config dvbworld_ts2020_config  = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n};\n\nstatic int frontend_init(struct dm1105_dev *dev)\n{\n\tint ret;\n\n\tswitch (dev->boardnr) {\n\tcase DM1105_BOARD_UNBRANDED_I2C_ON_GPIO:\n\t\tdm1105_gpio_enable(dev, GPIO15, 1);\n\t\tdm1105_gpio_clear(dev, GPIO15);\n\t\tmsleep(100);\n\t\tdm1105_gpio_set(dev, GPIO15);\n\t\tmsleep(200);\n\t\tdev->fe = dvb_attach(\n\t\t\tstv0299_attach, &sharp_z0194a_config,\n\t\t\t&dev->i2c_bb_adap);\n\t\tif (dev->fe) {\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t\tdvb_attach(dvb_pll_attach, dev->fe, 0x60,\n\t\t\t\t\t&dev->i2c_bb_adap, DVB_PLL_OPERA1);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->fe = dvb_attach(\n\t\t\tstv0288_attach, &earda_config,\n\t\t\t&dev->i2c_bb_adap);\n\t\tif (dev->fe) {\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t\tdvb_attach(stb6000_attach, dev->fe, 0x61,\n\t\t\t\t\t&dev->i2c_bb_adap);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->fe = dvb_attach(\n\t\t\tsi21xx_attach, &serit_config,\n\t\t\t&dev->i2c_bb_adap);\n\t\tif (dev->fe)\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\tbreak;\n\tcase DM1105_BOARD_DVBWORLD_2004:\n\t\tdev->fe = dvb_attach(\n\t\t\tcx24116_attach, &serit_sp2633_config,\n\t\t\t&dev->i2c_adap);\n\t\tif (dev->fe) {\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->fe = dvb_attach(\n\t\t\tds3000_attach, &dvbworld_ds3000_config,\n\t\t\t&dev->i2c_adap);\n\t\tif (dev->fe) {\n\t\t\tdvb_attach(ts2020_attach, dev->fe,\n\t\t\t\t&dvbworld_ts2020_config, &dev->i2c_adap);\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t}\n\n\t\tbreak;\n\tcase DM1105_BOARD_DVBWORLD_2002:\n\tcase DM1105_BOARD_AXESS_DM05:\n\tdefault:\n\t\tdev->fe = dvb_attach(\n\t\t\tstv0299_attach, &sharp_z0194a_config,\n\t\t\t&dev->i2c_adap);\n\t\tif (dev->fe) {\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t\tdvb_attach(dvb_pll_attach, dev->fe, 0x60,\n\t\t\t\t\t&dev->i2c_adap, DVB_PLL_OPERA1);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->fe = dvb_attach(\n\t\t\tstv0288_attach, &earda_config,\n\t\t\t&dev->i2c_adap);\n\t\tif (dev->fe) {\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\t\t\tdvb_attach(stb6000_attach, dev->fe, 0x61,\n\t\t\t\t\t&dev->i2c_adap);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->fe = dvb_attach(\n\t\t\tsi21xx_attach, &serit_config,\n\t\t\t&dev->i2c_adap);\n\t\tif (dev->fe)\n\t\t\tdev->fe->ops.set_voltage = dm1105_set_voltage;\n\n\t}\n\n\tif (!dev->fe) {\n\t\tdev_err(&dev->pdev->dev, \"could not attach frontend\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = dvb_register_frontend(&dev->dvb_adapter, dev->fe);\n\tif (ret < 0) {\n\t\tif (dev->fe->ops.release)\n\t\t\tdev->fe->ops.release(dev->fe);\n\t\tdev->fe = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dm1105_read_mac(struct dm1105_dev *dev, u8 *mac)\n{\n\tstatic u8 command[1] = { 0x28 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = IIC_24C01_addr >> 1,\n\t\t\t.flags = 0,\n\t\t\t.buf = command,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = IIC_24C01_addr >> 1,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = mac,\n\t\t\t.len = 6\n\t\t},\n\t};\n\n\tdm1105_i2c_xfer(&dev->i2c_adap, msg , 2);\n\tdev_info(&dev->pdev->dev, \"MAC %pM\\n\", mac);\n}\n\nstatic int dm1105_probe(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *ent)\n{\n\tstruct dm1105_dev *dev;\n\tstruct dvb_adapter *dvb_adapter;\n\tstruct dvb_demux *dvbdemux;\n\tstruct dmx_demux *dmx;\n\tint ret = -ENOMEM;\n\tint i;\n\n\tif (dm1105_devcount >= ARRAY_SIZE(card))\n\t\treturn -ENODEV;\n\n\tdev = kzalloc(sizeof(struct dm1105_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->nr = dm1105_devcount;\n\tdev->boardnr = UNSET;\n\tif (card[dev->nr] < ARRAY_SIZE(dm1105_boards))\n\t\tdev->boardnr = card[dev->nr];\n\tfor (i = 0; UNSET == dev->boardnr &&\n\t\t\t\ti < ARRAY_SIZE(dm1105_subids); i++)\n\t\tif (pdev->subsystem_vendor ==\n\t\t\tdm1105_subids[i].subvendor &&\n\t\t\t\tpdev->subsystem_device ==\n\t\t\t\t\tdm1105_subids[i].subdevice)\n\t\t\tdev->boardnr = dm1105_subids[i].card;\n\n\tif (UNSET == dev->boardnr) {\n\t\tdev->boardnr = DM1105_BOARD_UNKNOWN;\n\t\tdm1105_card_list(pdev);\n\t}\n\n\tdm1105_devcount++;\n\tdev->pdev = pdev;\n\tdev->buffer_size = 5 * DM1105_DMA_BYTES;\n\tdev->PacketErrorCount = 0;\n\tdev->dmarst = 0;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\tgoto err_kfree;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tdev->io_mem = pci_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!dev->io_mem) {\n\t\tret = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tspin_lock_init(&dev->lock);\n\tpci_set_drvdata(pdev, dev);\n\n\tret = dm1105_hw_init(dev);\n\tif (ret < 0)\n\t\tgoto err_pci_iounmap;\n\n\t \n\ti2c_set_adapdata(&dev->i2c_adap, dev);\n\tstrscpy(dev->i2c_adap.name, DRIVER_NAME, sizeof(dev->i2c_adap.name));\n\tdev->i2c_adap.owner = THIS_MODULE;\n\tdev->i2c_adap.dev.parent = &pdev->dev;\n\tdev->i2c_adap.algo = &dm1105_algo;\n\tdev->i2c_adap.algo_data = dev;\n\tret = i2c_add_adapter(&dev->i2c_adap);\n\n\tif (ret < 0)\n\t\tgoto err_dm1105_hw_exit;\n\n\ti2c_set_adapdata(&dev->i2c_bb_adap, dev);\n\tstrscpy(dev->i2c_bb_adap.name, DM1105_I2C_GPIO_NAME,\n\t\tsizeof(dev->i2c_bb_adap.name));\n\tdev->i2c_bb_adap.owner = THIS_MODULE;\n\tdev->i2c_bb_adap.dev.parent = &pdev->dev;\n\tdev->i2c_bb_adap.algo_data = &dev->i2c_bit;\n\tdev->i2c_bit.data = dev;\n\tdev->i2c_bit.setsda = dm1105_setsda;\n\tdev->i2c_bit.setscl = dm1105_setscl;\n\tdev->i2c_bit.getsda = dm1105_getsda;\n\tdev->i2c_bit.getscl = dm1105_getscl;\n\tdev->i2c_bit.udelay = 10;\n\tdev->i2c_bit.timeout = 10;\n\n\t \n\tdm1105_setsda(dev, 1);\n\tdm1105_setscl(dev, 1);\n\n\tret = i2c_bit_add_bus(&dev->i2c_bb_adap);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\t \n\tret = dvb_register_adapter(&dev->dvb_adapter, DRIVER_NAME,\n\t\t\t\t\tTHIS_MODULE, &pdev->dev, adapter_nr);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapters;\n\n\tdvb_adapter = &dev->dvb_adapter;\n\n\tdm1105_read_mac(dev, dvb_adapter->proposed_mac);\n\n\tdvbdemux = &dev->demux;\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = dm1105_start_feed;\n\tdvbdemux->stop_feed = dm1105_stop_feed;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\n\t\t\tDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\n\tret = dvb_dmx_init(dvbdemux);\n\tif (ret < 0)\n\t\tgoto err_dvb_unregister_adapter;\n\n\tdmx = &dvbdemux->dmx;\n\tdev->dmxdev.filternum = 256;\n\tdev->dmxdev.demux = dmx;\n\tdev->dmxdev.capabilities = 0;\n\n\tret = dvb_dmxdev_init(&dev->dmxdev, dvb_adapter);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmx_release;\n\n\tdev->hw_frontend.source = DMX_FRONTEND_0;\n\n\tret = dmx->add_frontend(dmx, &dev->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmxdev_release;\n\n\tdev->mem_frontend.source = DMX_MEMORY_FE;\n\n\tret = dmx->add_frontend(dmx, &dev->mem_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_hw_frontend;\n\n\tret = dmx->connect_frontend(dmx, &dev->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_mem_frontend;\n\n\tret = dvb_net_init(dvb_adapter, &dev->dvbnet, dmx);\n\tif (ret < 0)\n\t\tgoto err_disconnect_frontend;\n\n\tret = frontend_init(dev);\n\tif (ret < 0)\n\t\tgoto err_dvb_net;\n\n\tdm1105_ir_init(dev);\n\n\tINIT_WORK(&dev->work, dm1105_dmx_buffer);\n\tsprintf(dev->wqn, \"%s/%d\", dvb_adapter->name, dvb_adapter->num);\n\tdev->wq = create_singlethread_workqueue(dev->wqn);\n\tif (!dev->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dvb_net;\n\t}\n\n\tret = request_irq(pdev->irq, dm1105_irq, IRQF_SHARED,\n\t\t\t\t\t\tDRIVER_NAME, dev);\n\tif (ret < 0)\n\t\tgoto err_workqueue;\n\n\treturn 0;\n\nerr_workqueue:\n\tdestroy_workqueue(dev->wq);\nerr_dvb_net:\n\tdvb_net_release(&dev->dvbnet);\nerr_disconnect_frontend:\n\tdmx->disconnect_frontend(dmx);\nerr_remove_mem_frontend:\n\tdmx->remove_frontend(dmx, &dev->mem_frontend);\nerr_remove_hw_frontend:\n\tdmx->remove_frontend(dmx, &dev->hw_frontend);\nerr_dvb_dmxdev_release:\n\tdvb_dmxdev_release(&dev->dmxdev);\nerr_dvb_dmx_release:\n\tdvb_dmx_release(dvbdemux);\nerr_dvb_unregister_adapter:\n\tdvb_unregister_adapter(dvb_adapter);\nerr_i2c_del_adapters:\n\ti2c_del_adapter(&dev->i2c_bb_adap);\nerr_i2c_del_adapter:\n\ti2c_del_adapter(&dev->i2c_adap);\nerr_dm1105_hw_exit:\n\tdm1105_hw_exit(dev);\nerr_pci_iounmap:\n\tpci_iounmap(pdev, dev->io_mem);\nerr_pci_release_regions:\n\tpci_release_regions(pdev);\nerr_pci_disable_device:\n\tpci_disable_device(pdev);\nerr_kfree:\n\tkfree(dev);\n\treturn ret;\n}\n\nstatic void dm1105_remove(struct pci_dev *pdev)\n{\n\tstruct dm1105_dev *dev = pci_get_drvdata(pdev);\n\tstruct dvb_adapter *dvb_adapter = &dev->dvb_adapter;\n\tstruct dvb_demux *dvbdemux = &dev->demux;\n\tstruct dmx_demux *dmx = &dvbdemux->dmx;\n\n\tcancel_work_sync(&dev->ir.work);\n\tdm1105_ir_exit(dev);\n\tdmx->close(dmx);\n\tdvb_net_release(&dev->dvbnet);\n\tif (dev->fe)\n\t\tdvb_unregister_frontend(dev->fe);\n\n\tdmx->disconnect_frontend(dmx);\n\tdmx->remove_frontend(dmx, &dev->mem_frontend);\n\tdmx->remove_frontend(dmx, &dev->hw_frontend);\n\tdvb_dmxdev_release(&dev->dmxdev);\n\tdvb_dmx_release(dvbdemux);\n\tdvb_unregister_adapter(dvb_adapter);\n\ti2c_del_adapter(&dev->i2c_adap);\n\n\tdm1105_hw_exit(dev);\n\tfree_irq(pdev->irq, dev);\n\tpci_iounmap(pdev, dev->io_mem);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tdm1105_devcount--;\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id dm1105_id_table[] = {\n\t{\n\t\t.vendor = PCI_VENDOR_ID_TRIGEM,\n\t\t.device = PCI_DEVICE_ID_DM1105,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t}, {\n\t\t.vendor = PCI_VENDOR_ID_AXESS,\n\t\t.device = PCI_DEVICE_ID_DM05,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t}, {\n\t\t \n\t},\n};\n\nMODULE_DEVICE_TABLE(pci, dm1105_id_table);\n\nstatic struct pci_driver dm1105_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = dm1105_id_table,\n\t.probe = dm1105_probe,\n\t.remove = dm1105_remove,\n};\n\nmodule_pci_driver(dm1105_driver);\n\nMODULE_AUTHOR(\"Igor M. Liplianin <liplianin@me.by>\");\nMODULE_DESCRIPTION(\"SDMC DM1105 DVB driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}