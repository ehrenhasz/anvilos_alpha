{
  "module_name": "cx18-fileops.c",
  "hash_id": "fb86584782b06b570ca97404eb2c54ce25bbefe48101bbb2d3ec0f4132aec918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-fileops.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-fileops.h\"\n#include \"cx18-i2c.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-vbi.h\"\n#include \"cx18-audio.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-scb.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-controls.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-cards.h\"\n#include <media/v4l2-event.h>\n\n \nint cx18_claim_stream(struct cx18_open_id *id, int type)\n{\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[type];\n\tstruct cx18_stream *s_assoc;\n\n\t \n\tif (type == CX18_ENC_STREAM_TYPE_IDX) {\n\t\tCX18_WARN(\"MPEG Index stream cannot be claimed directly, but something tried.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_and_set_bit(CX18_F_S_CLAIMED, &s->s_flags)) {\n\t\t \n\t\tif (s->id == id->open_id) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (s->id == -1 && type == CX18_ENC_STREAM_TYPE_VBI) {\n\t\t\t \n\t\t\ts->id = id->open_id;\n\t\t\tCX18_DEBUG_INFO(\"Start Read VBI\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tCX18_DEBUG_INFO(\"Stream %d is busy\\n\", type);\n\t\treturn -EBUSY;\n\t}\n\ts->id = id->open_id;\n\n\t \n\tif (type != CX18_ENC_STREAM_TYPE_MPG)\n\t\treturn 0;\n\n\ts_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\tif (cx->vbi.insert_mpeg && !cx18_raw_vbi(cx))\n\t\ts_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\n\telse if (!cx18_stream_enabled(s_assoc))\n\t\treturn 0;\n\n\tset_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\n\n\t \n\tset_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx18_claim_stream);\n\n \nvoid cx18_release_stream(struct cx18_stream *s)\n{\n\tstruct cx18 *cx = s->cx;\n\tstruct cx18_stream *s_assoc;\n\n\ts->id = -1;\n\tif (s->type == CX18_ENC_STREAM_TYPE_IDX) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (s->type == CX18_ENC_STREAM_TYPE_VBI &&\n\t\ttest_bit(CX18_F_S_INTERNAL_USE, &s->s_flags)) {\n\t\t \n\t\treturn;\n\t}\n\tif (!test_and_clear_bit(CX18_F_S_CLAIMED, &s->s_flags)) {\n\t\tCX18_DEBUG_WARN(\"Release stream %s not in use!\\n\", s->name);\n\t\treturn;\n\t}\n\n\tcx18_flush_queues(s);\n\n\t \n\tif (s->type != CX18_ENC_STREAM_TYPE_MPG)\n\t\treturn;\n\n\t \n\ts_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\tif (test_and_clear_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags)) {\n\t\tclear_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\n\t\tcx18_flush_queues(s_assoc);\n\t}\n\n\t \n\ts_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\n\tif (test_and_clear_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags)) {\n\t\tif (s_assoc->id == -1) {\n\t\t\t \n\t\t\tclear_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\n\t\t\tcx18_flush_queues(s_assoc);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(cx18_release_stream);\n\nstatic void cx18_dualwatch(struct cx18 *cx)\n{\n\tstruct v4l2_tuner vt;\n\tu32 new_stereo_mode;\n\tconst u32 dual = 0x0200;\n\n\tnew_stereo_mode = v4l2_ctrl_g_ctrl(cx->cxhdl.audio_mode);\n\tmemset(&vt, 0, sizeof(vt));\n\tcx18_call_all(cx, tuner, g_tuner, &vt);\n\tif (vt.audmode == V4L2_TUNER_MODE_LANG1_LANG2 &&\n\t\t\t(vt.rxsubchans & V4L2_TUNER_SUB_LANG2))\n\t\tnew_stereo_mode = dual;\n\n\tif (new_stereo_mode == cx->dualwatch_stereo_mode)\n\t\treturn;\n\n\tCX18_DEBUG_INFO(\"dualwatch: change stereo flag from 0x%x to 0x%x.\\n\",\n\t\t\t   cx->dualwatch_stereo_mode, new_stereo_mode);\n\tif (v4l2_ctrl_s_ctrl(cx->cxhdl.audio_mode, new_stereo_mode))\n\t\tCX18_DEBUG_INFO(\"dualwatch: changing stereo flag failed\\n\");\n}\n\n\nstatic struct cx18_mdl *cx18_get_mdl(struct cx18_stream *s, int non_block,\n\t\t\t\t     int *err)\n{\n\tstruct cx18 *cx = s->cx;\n\tstruct cx18_stream *s_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\n\tstruct cx18_mdl *mdl;\n\tDEFINE_WAIT(wait);\n\n\t*err = 0;\n\twhile (1) {\n\t\tif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\n\t\t\t \n\t\t\tif (time_after(jiffies, cx->dualwatch_jiffies + msecs_to_jiffies(1000))) {\n\t\t\t\tcx->dualwatch_jiffies = jiffies;\n\t\t\t\tcx18_dualwatch(cx);\n\t\t\t}\n\t\t\tif (test_bit(CX18_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\n\t\t\t    !test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\n\t\t\t\twhile ((mdl = cx18_dequeue(s_vbi,\n\t\t\t\t\t\t\t   &s_vbi->q_full))) {\n\t\t\t\t\t \n\t\t\t\t\tcx18_process_vbi_data(cx, mdl,\n\t\t\t\t\t\t\t      s_vbi->type);\n\t\t\t\t\tcx18_stream_put_mdl_fw(s_vbi, mdl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmdl = &cx->vbi.sliced_mpeg_mdl;\n\t\t\tif (mdl->readpos != mdl->bytesused)\n\t\t\t\treturn mdl;\n\t\t}\n\n\t\t \n\t\tmdl = cx18_dequeue(s, &s->q_full);\n\t\tif (mdl) {\n\t\t\tif (!test_and_clear_bit(CX18_F_M_NEED_SWAP,\n\t\t\t\t\t\t&mdl->m_flags))\n\t\t\t\treturn mdl;\n\t\t\tif (s->type == CX18_ENC_STREAM_TYPE_MPG)\n\t\t\t\t \n\t\t\t\tcx18_mdl_swap(mdl);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tcx18_process_vbi_data(cx, mdl, s->type);\n\t\t\t}\n\t\t\treturn mdl;\n\t\t}\n\n\t\t \n\t\tif (!test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\n\t\t\tCX18_DEBUG_INFO(\"EOS %s\\n\", s->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (non_block) {\n\t\t\t*err = -EAGAIN;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t \n\t\tif (!atomic_read(&s->q_full.depth))\n\t\t\tschedule();\n\t\tfinish_wait(&s->waitq, &wait);\n\t\tif (signal_pending(current)) {\n\t\t\t \n\t\t\tCX18_DEBUG_INFO(\"User stopped %s\\n\", s->name);\n\t\t\t*err = -EINTR;\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\nstatic void cx18_setup_sliced_vbi_mdl(struct cx18 *cx)\n{\n\tstruct cx18_mdl *mdl = &cx->vbi.sliced_mpeg_mdl;\n\tstruct cx18_buffer *buf = &cx->vbi.sliced_mpeg_buf;\n\tint idx = cx->vbi.inserted_frame % CX18_VBI_FRAMES;\n\n\tbuf->buf = cx->vbi.sliced_mpeg_data[idx];\n\tbuf->bytesused = cx->vbi.sliced_mpeg_size[idx];\n\tbuf->readpos = 0;\n\n\tmdl->curr_buf = NULL;\n\tmdl->bytesused = cx->vbi.sliced_mpeg_size[idx];\n\tmdl->readpos = 0;\n}\n\nstatic size_t cx18_copy_buf_to_user(struct cx18_stream *s,\n\tstruct cx18_buffer *buf, char __user *ubuf, size_t ucount, bool *stop)\n{\n\tstruct cx18 *cx = s->cx;\n\tsize_t len = buf->bytesused - buf->readpos;\n\n\t*stop = false;\n\tif (len > ucount)\n\t\tlen = ucount;\n\tif (cx->vbi.insert_mpeg && s->type == CX18_ENC_STREAM_TYPE_MPG &&\n\t    !cx18_raw_vbi(cx) && buf != &cx->vbi.sliced_mpeg_buf) {\n\t\t \n\t\t \n\t\tconst char *start = buf->buf + buf->readpos;\n\t\tconst char *p = start + 1;\n\t\tconst u8 *q;\n\t\tu8 ch = cx->search_pack_header ? 0xba : 0xe0;\n\t\tint stuffing, i;\n\n\t\twhile (start + len > p) {\n\t\t\t \n\t\t\tq = memchr(p, 0, start + len - p);\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tp = q + 1;\n\t\t\t \n\t\t\tif ((char *)q + 15 >= buf->buf + buf->bytesused ||\n\t\t\t    q[1] != 0 || q[2] != 1 || q[3] != ch)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!cx->search_pack_header) {\n\t\t\t\t \n\t\t\t\tif ((q[6] & 0xc0) != 0x80)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (((q[7] & 0xc0) == 0x80 &&   \n\t\t\t\t     (q[9] & 0xf0) == 0x20) ||  \n\t\t\t\t    ((q[7] & 0xc0) == 0xc0 &&   \n\t\t\t\t     (q[9] & 0xf0) == 0x30)) {  \n\t\t\t\t\t \n\t\t\t\t\tch = 0xba;  \n\t\t\t\t\tcx->search_pack_header = 1;\n\t\t\t\t\tp = q + 9;  \n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tstuffing = q[13] & 7;\n\t\t\t \n\t\t\tfor (i = 0; i < stuffing; i++)\n\t\t\t\tif (q[14 + i] != 0xff)\n\t\t\t\t\tbreak;\n\t\t\tif (i == stuffing &&  \n\t\t\t    (q[4] & 0xc4) == 0x44 &&  \n\t\t\t    (q[12] & 3) == 3 &&   \n\t\t\t    q[14 + stuffing] == 0 &&  \n\t\t\t    q[15 + stuffing] == 0 &&\n\t\t\t    q[16 + stuffing] == 1) {\n\t\t\t\t \n\t\t\t\tcx->search_pack_header = 0;  \n\t\t\t\tlen = (char *)q - start;\n\t\t\t\tcx18_setup_sliced_vbi_mdl(cx);\n\t\t\t\t*stop = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (copy_to_user(ubuf, (u8 *)buf->buf + buf->readpos, len)) {\n\t\tCX18_DEBUG_WARN(\"copy %zd bytes to user failed for %s\\n\",\n\t\t\t\tlen, s->name);\n\t\treturn -EFAULT;\n\t}\n\tbuf->readpos += len;\n\tif (s->type == CX18_ENC_STREAM_TYPE_MPG &&\n\t    buf != &cx->vbi.sliced_mpeg_buf)\n\t\tcx->mpg_data_received += len;\n\treturn len;\n}\n\nstatic size_t cx18_copy_mdl_to_user(struct cx18_stream *s,\n\t\tstruct cx18_mdl *mdl, char __user *ubuf, size_t ucount)\n{\n\tsize_t tot_written = 0;\n\tint rc;\n\tbool stop = false;\n\n\tif (mdl->curr_buf == NULL)\n\t\tmdl->curr_buf = list_first_entry(&mdl->buf_list,\n\t\t\t\t\t\t struct cx18_buffer, list);\n\n\tif (list_entry_is_past_end(mdl->curr_buf, &mdl->buf_list, list)) {\n\t\t \n\t\tmdl->readpos = mdl->bytesused;\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_from(mdl->curr_buf, &mdl->buf_list, list) {\n\n\t\tif (mdl->curr_buf->readpos >= mdl->curr_buf->bytesused)\n\t\t\tcontinue;\n\n\t\trc = cx18_copy_buf_to_user(s, mdl->curr_buf, ubuf + tot_written,\n\t\t\t\t\t   ucount - tot_written, &stop);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tmdl->readpos += rc;\n\t\ttot_written += rc;\n\n\t\tif (stop ||\t \n\t\t    tot_written >= ucount ||\t \n\t\t    mdl->curr_buf->readpos < mdl->curr_buf->bytesused ||\n\t\t    mdl->readpos >= mdl->bytesused)  \n\t\t\tbreak;\n\t}\n\treturn tot_written;\n}\n\nstatic ssize_t cx18_read(struct cx18_stream *s, char __user *ubuf,\n\t\tsize_t tot_count, int non_block)\n{\n\tstruct cx18 *cx = s->cx;\n\tsize_t tot_written = 0;\n\tint single_frame = 0;\n\n\tif (atomic_read(&cx->ana_capturing) == 0 && s->id == -1) {\n\t\t \n\t\tCX18_DEBUG_WARN(\"Stream %s not initialized before read\\n\",\n\t\t\t\ts->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (s->type == CX18_ENC_STREAM_TYPE_VBI && !cx18_raw_vbi(cx))\n\t\tsingle_frame = 1;\n\n\tfor (;;) {\n\t\tstruct cx18_mdl *mdl;\n\t\tint rc;\n\n\t\tmdl = cx18_get_mdl(s, non_block, &rc);\n\t\t \n\t\tif (mdl == NULL) {\n\t\t\t \n\t\t\tif (tot_written)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (rc == 0) {\n\t\t\t\tclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\n\t\t\t\tclear_bit(CX18_F_S_APPL_IO, &s->s_flags);\n\t\t\t\tcx18_release_stream(s);\n\t\t\t}\n\t\t\t \n\t\t\treturn rc;\n\t\t}\n\n\t\trc = cx18_copy_mdl_to_user(s, mdl, ubuf + tot_written,\n\t\t\t\ttot_count - tot_written);\n\n\t\tif (mdl != &cx->vbi.sliced_mpeg_mdl) {\n\t\t\tif (mdl->readpos == mdl->bytesused)\n\t\t\t\tcx18_stream_put_mdl_fw(s, mdl);\n\t\t\telse\n\t\t\t\tcx18_push(s, mdl, &s->q_full);\n\t\t} else if (mdl->readpos == mdl->bytesused) {\n\t\t\tint idx = cx->vbi.inserted_frame % CX18_VBI_FRAMES;\n\n\t\t\tcx->vbi.sliced_mpeg_size[idx] = 0;\n\t\t\tcx->vbi.inserted_frame++;\n\t\t\tcx->vbi_data_inserted += mdl->bytesused;\n\t\t}\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\ttot_written += rc;\n\n\t\tif (tot_written == tot_count || single_frame)\n\t\t\tbreak;\n\t}\n\treturn tot_written;\n}\n\nstatic ssize_t cx18_read_pos(struct cx18_stream *s, char __user *ubuf,\n\t\tsize_t count, loff_t *pos, int non_block)\n{\n\tssize_t rc = count ? cx18_read(s, ubuf, count, non_block) : 0;\n\tstruct cx18 *cx = s->cx;\n\n\tCX18_DEBUG_HI_FILE(\"read %zd from %s, got %zd\\n\", count, s->name, rc);\n\tif (rc > 0)\n\t\t*pos += rc;\n\treturn rc;\n}\n\nint cx18_start_capture(struct cx18_open_id *id)\n{\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tstruct cx18_stream *s_vbi;\n\tstruct cx18_stream *s_idx;\n\n\tif (s->type == CX18_ENC_STREAM_TYPE_RAD) {\n\t\t \n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (cx18_claim_stream(id, s->type))\n\t\treturn -EBUSY;\n\n\t \n\tif (test_bit(CX18_F_S_STREAMOFF, &s->s_flags) ||\n\t    test_and_set_bit(CX18_F_S_STREAMING, &s->s_flags)) {\n\t\tset_bit(CX18_F_S_APPL_IO, &s->s_flags);\n\t\treturn 0;\n\t}\n\n\t \n\ts_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\n\ts_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\tif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\n\t\t \n\t\tif (test_bit(CX18_F_S_INTERNAL_USE, &s_idx->s_flags) &&\n\t\t    !test_and_set_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\n\t\t\tif (cx18_start_v4l2_encode_stream(s_idx)) {\n\t\t\t\tCX18_DEBUG_WARN(\"IDX capture start failed\\n\");\n\t\t\t\tclear_bit(CX18_F_S_STREAMING, &s_idx->s_flags);\n\t\t\t\tgoto start_failed;\n\t\t\t}\n\t\t\tCX18_DEBUG_INFO(\"IDX capture started\\n\");\n\t\t}\n\t\tif (test_bit(CX18_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\n\t\t    !test_and_set_bit(CX18_F_S_STREAMING, &s_vbi->s_flags)) {\n\t\t\tif (cx18_start_v4l2_encode_stream(s_vbi)) {\n\t\t\t\tCX18_DEBUG_WARN(\"VBI capture start failed\\n\");\n\t\t\t\tclear_bit(CX18_F_S_STREAMING, &s_vbi->s_flags);\n\t\t\t\tgoto start_failed;\n\t\t\t}\n\t\t\tCX18_DEBUG_INFO(\"VBI insertion started\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!cx18_start_v4l2_encode_stream(s)) {\n\t\t \n\t\tset_bit(CX18_F_S_APPL_IO, &s->s_flags);\n\t\t \n\t\tif (test_and_clear_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\n\t\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_PAUSE, 1, s->handle);\n\t\treturn 0;\n\t}\n\nstart_failed:\n\tCX18_DEBUG_WARN(\"Failed to start capturing for stream %s\\n\", s->name);\n\n\t \n\tif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\n\t\t \n\t\tif (test_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\n\t\t\tcx18_stop_v4l2_encode_stream(s_idx, 0);\n\t\t\tclear_bit(CX18_F_S_STREAMING, &s_idx->s_flags);\n\t\t}\n\t\t \n\t\tif (test_bit(CX18_F_S_STREAMING, &s_vbi->s_flags) &&\n\t\t    !test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\n\t\t\tcx18_stop_v4l2_encode_stream(s_vbi, 0);\n\t\t\tclear_bit(CX18_F_S_STREAMING, &s_vbi->s_flags);\n\t\t}\n\t}\n\tclear_bit(CX18_F_S_STREAMING, &s->s_flags);\n\tcx18_release_stream(s);  \n\treturn -EIO;\n}\n\nssize_t cx18_v4l2_read(struct file *filp, char __user *buf, size_t count,\n\t\tloff_t *pos)\n{\n\tstruct cx18_open_id *id = file2id(filp);\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tint rc;\n\n\tCX18_DEBUG_HI_FILE(\"read %zd bytes from %s\\n\", count, s->name);\n\n\tmutex_lock(&cx->serialize_lock);\n\trc = cx18_start_capture(id);\n\tmutex_unlock(&cx->serialize_lock);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cx18_read_pos(s, buf, count, pos, filp->f_flags & O_NONBLOCK);\n}\n\n__poll_t cx18_v4l2_enc_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct cx18_open_id *id = file2id(filp);\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tint eof = test_bit(CX18_F_S_STREAMOFF, &s->s_flags);\n\t__poll_t res = 0;\n\n\t \n\tif (!eof && !test_bit(CX18_F_S_STREAMING, &s->s_flags) &&\n\t\t\t(req_events & (EPOLLIN | EPOLLRDNORM))) {\n\t\tint rc;\n\n\t\tmutex_lock(&cx->serialize_lock);\n\t\trc = cx18_start_capture(id);\n\t\tmutex_unlock(&cx->serialize_lock);\n\t\tif (rc) {\n\t\t\tCX18_DEBUG_INFO(\"Could not start capture for %s (%d)\\n\",\n\t\t\t\t\ts->name, rc);\n\t\t\treturn EPOLLERR;\n\t\t}\n\t\tCX18_DEBUG_FILE(\"Encoder poll started capture\\n\");\n\t}\n\n\t \n\tCX18_DEBUG_HI_FILE(\"Encoder poll\\n\");\n\tif (v4l2_event_pending(&id->fh))\n\t\tres |= EPOLLPRI;\n\telse\n\t\tpoll_wait(filp, &s->waitq, wait);\n\n\tif (atomic_read(&s->q_full.depth))\n\t\treturn res | EPOLLIN | EPOLLRDNORM;\n\tif (eof)\n\t\treturn res | EPOLLHUP;\n\treturn res;\n}\n\nvoid cx18_vb_timeout(struct timer_list *t)\n{\n\tstruct cx18_stream *s = from_timer(s, t, vb_timeout);\n\n\t \n\tcx18_clear_queue(s, VB2_BUF_STATE_ERROR);\n}\n\nvoid cx18_stop_capture(struct cx18_stream *s, int gop_end)\n{\n\tstruct cx18 *cx = s->cx;\n\tstruct cx18_stream *s_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\n\tstruct cx18_stream *s_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\n\tCX18_DEBUG_IOCTL(\"close() of %s\\n\", s->name);\n\n\t \n\n\t \n\tif (test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\n\t\tCX18_DEBUG_INFO(\"close stopping capture\\n\");\n\t\tif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\n\t\t\t \n\t\t\tif (test_bit(CX18_F_S_STREAMING, &s_vbi->s_flags) &&\n\t\t\t    !test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\n\t\t\t\tCX18_DEBUG_INFO(\"close stopping embedded VBI capture\\n\");\n\t\t\t\tcx18_stop_v4l2_encode_stream(s_vbi, 0);\n\t\t\t}\n\t\t\tif (test_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\n\t\t\t\tCX18_DEBUG_INFO(\"close stopping IDX capture\\n\");\n\t\t\t\tcx18_stop_v4l2_encode_stream(s_idx, 0);\n\t\t\t}\n\t\t}\n\t\tif (s->type == CX18_ENC_STREAM_TYPE_VBI &&\n\t\t    test_bit(CX18_F_S_INTERNAL_USE, &s->s_flags))\n\t\t\t \n\t\t\ts->id = -1;\n\t\telse\n\t\t\tcx18_stop_v4l2_encode_stream(s, gop_end);\n\t}\n\tif (!gop_end) {\n\t\tclear_bit(CX18_F_S_APPL_IO, &s->s_flags);\n\t\tclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\n\t\tcx18_release_stream(s);\n\t}\n}\n\nint cx18_v4l2_close(struct file *filp)\n{\n\tstruct v4l2_fh *fh = filp->private_data;\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tstruct video_device *vdev = &s->video_dev;\n\n\tCX18_DEBUG_IOCTL(\"close() of %s\\n\", s->name);\n\n\tmutex_lock(&cx->serialize_lock);\n\t \n\tif (id->type == CX18_ENC_STREAM_TYPE_RAD &&\n\t    v4l2_fh_is_singular_file(filp)) {\n\t\t \n\t\tcx18_mute(cx);\n\t\t \n\t\tclear_bit(CX18_F_I_RADIO_USER, &cx->i_flags);\n\t\t \n\t\tcx18_call_all(cx, video, s_std, cx->std);\n\t\t \n\t\tcx18_audio_set_io(cx);\n\t\tif (atomic_read(&cx->ana_capturing) > 0) {\n\t\t\t \n\t\t\tcx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2, s->handle,\n\t\t\t    (v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute) |\n\t\t\t    (v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute_yuv) << 8)));\n\t\t}\n\t\t \n\t\tcx18_unmute(cx);\n\t}\n\n\tif (id->type == CX18_ENC_STREAM_TYPE_YUV &&\n\t    filp->private_data == vdev->queue->owner) {\n\t\tvb2_queue_release(vdev->queue);\n\t\tvdev->queue->owner = NULL;\n\t}\n\tv4l2_fh_del(fh);\n\tv4l2_fh_exit(fh);\n\n\t \n\tif (id->type != CX18_ENC_STREAM_TYPE_YUV && s->id == id->open_id)\n\t\tcx18_stop_capture(s, 0);\n\tkfree(id);\n\tmutex_unlock(&cx->serialize_lock);\n\treturn 0;\n}\n\nstatic int cx18_serialized_open(struct cx18_stream *s, struct file *filp)\n{\n\tstruct cx18 *cx = s->cx;\n\tstruct cx18_open_id *item;\n\n\tCX18_DEBUG_FILE(\"open %s\\n\", s->name);\n\n\t \n\titem = kzalloc(sizeof(struct cx18_open_id), GFP_KERNEL);\n\tif (NULL == item) {\n\t\tCX18_DEBUG_WARN(\"nomem on v4l2 open\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tv4l2_fh_init(&item->fh, &s->video_dev);\n\n\titem->cx = cx;\n\titem->type = s->type;\n\n\titem->open_id = cx->open_id++;\n\tfilp->private_data = &item->fh;\n\tv4l2_fh_add(&item->fh);\n\n\tif (item->type == CX18_ENC_STREAM_TYPE_RAD &&\n\t\t\tv4l2_fh_is_singular_file(filp)) {\n\t\tif (!test_bit(CX18_F_I_RADIO_USER, &cx->i_flags)) {\n\t\t\tif (atomic_read(&cx->ana_capturing) > 0) {\n\t\t\t\t \n\t\t\t\tv4l2_fh_del(&item->fh);\n\t\t\t\tv4l2_fh_exit(&item->fh);\n\t\t\t\tkfree(item);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tset_bit(CX18_F_I_RADIO_USER, &cx->i_flags);\n\t\t \n\t\tcx18_mute(cx);\n\t\t \n\t\tcx18_call_all(cx, tuner, s_radio);\n\t\t \n\t\tcx18_audio_set_io(cx);\n\t\t \n\t\tcx18_unmute(cx);\n\t}\n\treturn 0;\n}\n\nint cx18_v4l2_open(struct file *filp)\n{\n\tint res;\n\tstruct video_device *video_dev = video_devdata(filp);\n\tstruct cx18_stream *s = video_get_drvdata(video_dev);\n\tstruct cx18 *cx = s->cx;\n\n\tmutex_lock(&cx->serialize_lock);\n\tif (cx18_init_on_first_open(cx)) {\n\t\tCX18_ERR(\"Failed to initialize on %s\\n\",\n\t\t\t video_device_node_name(video_dev));\n\t\tmutex_unlock(&cx->serialize_lock);\n\t\treturn -ENXIO;\n\t}\n\tres = cx18_serialized_open(s, filp);\n\tmutex_unlock(&cx->serialize_lock);\n\treturn res;\n}\n\nvoid cx18_mute(struct cx18 *cx)\n{\n\tu32 h;\n\tif (atomic_read(&cx->ana_capturing)) {\n\t\th = cx18_find_handle(cx);\n\t\tif (h != CX18_INVALID_TASK_HANDLE)\n\t\t\tcx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2, h, 1);\n\t\telse\n\t\t\tCX18_ERR(\"Can't find valid task handle for mute\\n\");\n\t}\n\tCX18_DEBUG_INFO(\"Mute\\n\");\n}\n\nvoid cx18_unmute(struct cx18 *cx)\n{\n\tu32 h;\n\tif (atomic_read(&cx->ana_capturing)) {\n\t\th = cx18_find_handle(cx);\n\t\tif (h != CX18_INVALID_TASK_HANDLE) {\n\t\t\tcx18_msleep_timeout(100, 0);\n\t\t\tcx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 2, h, 12);\n\t\t\tcx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2, h, 0);\n\t\t} else\n\t\t\tCX18_ERR(\"Can't find valid task handle for unmute\\n\");\n\t}\n\tCX18_DEBUG_INFO(\"Unmute\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}