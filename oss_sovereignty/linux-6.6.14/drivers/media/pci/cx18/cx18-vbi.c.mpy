{
  "module_name": "cx18-vbi.c",
  "hash_id": "4da650969bb47d41cee82ab0a6e62467ee0df661181e3a856f253ce7c2c7e81b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-vbi.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-vbi.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-queue.h\"\n\n \nstatic const u8 raw_vbi_sav_rp[2] = { 0x20, 0x60 };     \nstatic const u8 sliced_vbi_eav_rp[2] = { 0xb0, 0xf0 };  \n\nstatic void copy_vbi_data(struct cx18 *cx, int lines, u32 pts_stamp)\n{\n\tint line = 0;\n\tint i;\n\tu32 linemask[2] = { 0, 0 };\n\tunsigned short size;\n\tstatic const u8 mpeg_hdr_data[] = {\n\t\t \n\t\t0x00, 0x00, 0x01, 0xba,\t\t     \n\t\t0x44, 0x00, 0x0c, 0x66, 0x24, 0x01,  \n\t\t0x01, 0xd1, 0xd3,\t\t     \n\t\t0xfa, 0xff, 0xff,\t\t     \n\t\t \n\t\t0x00, 0x00, 0x01, 0xbd,\t\t     \n\t\t0x00, 0x1a,\t\t\t     \n\t\t0x84, 0x80, 0x07,\t\t     \n\t\t0x21, 0x00, 0x5d, 0x63, 0xa7,\t     \n\t\t0xff, 0xff\t\t\t     \n\t};\n\tconst int sd = sizeof(mpeg_hdr_data);\t \n\tint idx = cx->vbi.frame % CX18_VBI_FRAMES;\n\tu8 *dst = &cx->vbi.sliced_mpeg_data[idx][0];\n\n\tfor (i = 0; i < lines; i++) {\n\t\tstruct v4l2_sliced_vbi_data *sdata = cx->vbi.sliced_data + i;\n\t\tint f, l;\n\n\t\tif (sdata->id == 0)\n\t\t\tcontinue;\n\n\t\tl = sdata->line - 6;\n\t\tf = sdata->field;\n\t\tif (f)\n\t\t\tl += 18;\n\t\tif (l < 32)\n\t\t\tlinemask[0] |= (1 << l);\n\t\telse\n\t\t\tlinemask[1] |= (1 << (l - 32));\n\t\tdst[sd + 12 + line * 43] = cx18_service2vbi(sdata->id);\n\t\tmemcpy(dst + sd + 12 + line * 43 + 1, sdata->data, 42);\n\t\tline++;\n\t}\n\tmemcpy(dst, mpeg_hdr_data, sizeof(mpeg_hdr_data));\n\tif (line == 36) {\n\t\t \n\t\tmemcpy(dst + sd, \"ITV0\", 4);\n\t\tmemmove(dst + sd + 4, dst + sd + 12, line * 43);\n\t\tsize = 4 + ((43 * line + 3) & ~3);\n\t} else {\n\t\tmemcpy(dst + sd, \"itv0\", 4);\n\t\tcpu_to_le32s(&linemask[0]);\n\t\tcpu_to_le32s(&linemask[1]);\n\t\tmemcpy(dst + sd + 4, &linemask[0], 8);\n\t\tsize = 12 + ((43 * line + 3) & ~3);\n\t}\n\tdst[4+16] = (size + 10) >> 8;\n\tdst[5+16] = (size + 10) & 0xff;\n\tdst[9+16] = 0x21 | ((pts_stamp >> 29) & 0x6);\n\tdst[10+16] = (pts_stamp >> 22) & 0xff;\n\tdst[11+16] = 1 | ((pts_stamp >> 14) & 0xff);\n\tdst[12+16] = (pts_stamp >> 7) & 0xff;\n\tdst[13+16] = 1 | ((pts_stamp & 0x7f) << 1);\n\tcx->vbi.sliced_mpeg_size[idx] = sd + size;\n}\n\n \n \nstatic u32 compress_raw_buf(struct cx18 *cx, u8 *buf, u32 size, u32 hdr_size)\n{\n\tu32 line_size = VBI_ACTIVE_SAMPLES;\n\tu32 lines = cx->vbi.count * 2;\n\tu8 *q = buf;\n\tu8 *p;\n\tint i;\n\n\t \n\tbuf += hdr_size;\n\n\tfor (i = 0; i < lines; i++) {\n\t\tp = buf + i * line_size;\n\n\t\t \n\t\tif (p[0] != 0xff || p[1] || p[2] ||\n\t\t    (p[3] != raw_vbi_sav_rp[0] &&\n\t\t     p[3] != raw_vbi_sav_rp[1]))\n\t\t\tbreak;\n\t\tif (i == lines - 1) {\n\t\t\t \n\t\t\tmemcpy(q, p + 4, line_size - 4 - hdr_size);\n\t\t\tq += line_size - 4 - hdr_size;\n\t\t\tp += line_size - hdr_size - 1;\n\t\t\tmemset(q, (int) *p, hdr_size);\n\t\t} else {\n\t\t\tmemcpy(q, p + 4, line_size - 4);\n\t\t\tq += line_size - 4;\n\t\t}\n\t}\n\treturn lines * (line_size - 4);\n}\n\nstatic u32 compress_sliced_buf(struct cx18 *cx, u8 *buf, u32 size,\n\t\t\t       const u32 hdr_size)\n{\n\tstruct v4l2_decode_vbi_line vbi;\n\tint i;\n\tu32 line = 0;\n\tu32 line_size = cx->is_60hz ? VBI_HBLANK_SAMPLES_60HZ\n\t\t\t\t    : VBI_HBLANK_SAMPLES_50HZ;\n\n\t \n\tfor (i = hdr_size, buf += hdr_size; i < size; i++, buf++) {\n\t\tif (buf[0] == 0xff && !buf[1] && !buf[2] &&\n\t\t    (buf[3] == sliced_vbi_eav_rp[0] ||\n\t\t     buf[3] == sliced_vbi_eav_rp[1]))\n\t\t\tbreak;\n\t}\n\n\t \n\tsize -= (i - hdr_size);\n\tif (size < line_size)\n\t\treturn line;\n\n\tfor (i = 0; i < size / line_size; i++) {\n\t\tu8 *p = buf + i * line_size;\n\n\t\t \n\t\tif (p[0] != 0xff || p[1] || p[2] ||\n\t\t    (p[3] != sliced_vbi_eav_rp[0] &&\n\t\t     p[3] != sliced_vbi_eav_rp[1]))\n\t\t\tcontinue;\n\t\tvbi.p = p + 4;\n\t\tv4l2_subdev_call(cx->sd_av, vbi, decode_vbi_line, &vbi);\n\t\tif (vbi.type) {\n\t\t\tcx->vbi.sliced_data[line].id = vbi.type;\n\t\t\tcx->vbi.sliced_data[line].field = vbi.is_second_field;\n\t\t\tcx->vbi.sliced_data[line].line = vbi.line;\n\t\t\tmemcpy(cx->vbi.sliced_data[line].data, vbi.p, 42);\n\t\t\tline++;\n\t\t}\n\t}\n\treturn line;\n}\n\nstatic void _cx18_process_vbi_data(struct cx18 *cx, struct cx18_buffer *buf)\n{\n\t \n\tstruct vbi_data_hdr {\n\t\t__be32 magic;\n\t\t__be32 unknown;\n\t\t__be32 pts;\n\t} *hdr = (struct vbi_data_hdr *) buf->buf;\n\n\tu8 *p = (u8 *) buf->buf;\n\tu32 size = buf->bytesused;\n\tu32 pts;\n\tint lines;\n\n\t \n\tcx18_buf_swap(buf);\n\n\t \n\tif (cx18_raw_vbi(cx)) {\n\n\t\tsize = buf->bytesused =\n\t\t     compress_raw_buf(cx, p, size, sizeof(struct vbi_data_hdr));\n\n\t\t \n\t\tp += size - 4;\n\t\tmemcpy(p, &cx->vbi.frame, 4);\n\t\tcx->vbi.frame++;\n\t\treturn;\n\t}\n\n\t \n\n\tpts = (be32_to_cpu(hdr->magic) == 0x3fffffff) ? be32_to_cpu(hdr->pts)\n\t\t\t\t\t\t      : 0;\n\n\tlines = compress_sliced_buf(cx, p, size, sizeof(struct vbi_data_hdr));\n\n\t \n\tif (lines == 0) {\n\t\tcx->vbi.sliced_data[0].id = 0;\n\t\tcx->vbi.sliced_data[0].line = 0;\n\t\tcx->vbi.sliced_data[0].field = 0;\n\t\tlines = 1;\n\t}\n\tbuf->bytesused = size = lines * sizeof(cx->vbi.sliced_data[0]);\n\tmemcpy(p, &cx->vbi.sliced_data[0], size);\n\n\tif (cx->vbi.insert_mpeg)\n\t\tcopy_vbi_data(cx, lines, pts);\n\tcx->vbi.frame++;\n}\n\nvoid cx18_process_vbi_data(struct cx18 *cx, struct cx18_mdl *mdl,\n\t\t\t   int streamtype)\n{\n\tstruct cx18_buffer *buf;\n\tu32 orig_used;\n\n\tif (streamtype != CX18_ENC_STREAM_TYPE_VBI)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(buf, &mdl->buf_list, list) {\n\t\torig_used = buf->bytesused;\n\t\tif (orig_used == 0)\n\t\t\tbreak;\n\t\t_cx18_process_vbi_data(cx, buf);\n\t\tmdl->bytesused -= (orig_used - buf->bytesused);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}