{
  "module_name": "cx18-av-audio.c",
  "hash_id": "856976169eec7add57937fc67b204bdfcaa153da6850f231c666c23b535792d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-av-audio.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n\nstatic int set_audclk_freq(struct cx18 *cx, u32 freq)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\n\tif (freq != 32000 && freq != 44100 && freq != 48000)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (state->aud_input > CX18_AV_AUDIO_SERIAL2) {\n\t\tswitch (freq) {\n\t\tcase 32000:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x200d040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x0176740c);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x0801f77f);\n\t\t\tcx18_av_write4(cx, 0x904, 0x0801f77f);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x0801f77f);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x60);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x11202fff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa00d2ef8);\n\t\t\tbreak;\n\n\t\tcase 44100:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x180e040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x0062a1f2);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x08016d59);\n\t\t\tcx18_av_write4(cx, 0x904, 0x08016d59);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x08016d59);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x58);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x112092ff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa01d4bf8);\n\t\t\tbreak;\n\n\t\tcase 48000:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x160e040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x005227ad);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x08014faa);\n\t\t\tcx18_av_write4(cx, 0x904, 0x08014faa);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x08014faa);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x56);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x11205fff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa01193f8);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (freq) {\n\t\tcase 32000:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x300d040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x0176740c);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x8f8, 0x08010000);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x08020000);\n\t\t\tcx18_av_write4(cx, 0x904, 0x08020000);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x08020000);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x70);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x11201fff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa00d2ef8);\n\t\t\tbreak;\n\n\t\tcase 44100:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x240e040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x0062a1f2);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x8f8, 0x080160cd);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x08017385);\n\t\t\tcx18_av_write4(cx, 0x904, 0x08017385);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x08017385);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x64);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x112061ff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa01d4bf8);\n\t\t\tbreak;\n\n\t\tcase 48000:\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x108, 0x200d040f);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x10c, 0x002be2fe);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x110, 0x0176740c);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x8f8, 0x08018000);\n\n\t\t\t \n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x900, 0x08015555);\n\t\t\tcx18_av_write4(cx, 0x904, 0x08015555);\n\t\t\tcx18_av_write4(cx, 0x90c, 0x08015555);\n\n\t\t\t \n\t\t\tcx18_av_write(cx, 0x127, 0x60);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x12c, 0x11203fff);\n\n\t\t\t \n\t\t\tcx18_av_write4(cx, 0x128, 0xa01193f8);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstate->audclk_freq = freq;\n\n\treturn 0;\n}\n\nvoid cx18_av_audio_set_path(struct cx18 *cx)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tu8 v;\n\n\t \n\tv = cx18_av_read(cx, 0x803) & ~0x10;\n\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\n\t \n\tv = cx18_av_read(cx, 0x810) | 0x01;\n\tcx18_av_write_expect(cx, 0x810, v, v, 0x0f);\n\n\t \n\tcx18_av_write(cx, 0x8d3, 0x1f);\n\n\tif (state->aud_input <= CX18_AV_AUDIO_SERIAL2) {\n\t\t \n\t\tcx18_av_write4(cx, 0x8d0, 0x01011012);\n\n\t\t \n\t} else {\n\t\t \n\t\tcx18_av_write4(cx, 0x8d0, 0x1f063870);\n\t}\n\n\tset_audclk_freq(cx, state->audclk_freq);\n\n\t \n\tv = cx18_av_read(cx, 0x810) & ~0x01;\n\tcx18_av_write_expect(cx, 0x810, v, v, 0x0f);\n\n\tif (state->aud_input > CX18_AV_AUDIO_SERIAL2) {\n\t\t \n\t\tv = cx18_av_read(cx, 0x803) | 0x10;\n\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t}\n}\n\nstatic void set_volume(struct cx18 *cx, int volume)\n{\n\t \n\tint vol = volume >> 9;\n\t \n\tif (vol <= 23)\n\t\tvol = 0;\n\telse\n\t\tvol -= 23;\n\n\t \n\tcx18_av_write(cx, 0x8d4, 228 - (vol * 2));\n}\n\nstatic void set_bass(struct cx18 *cx, int bass)\n{\n\t \n\tcx18_av_and_or(cx, 0x8d9, ~0x3f, 48 - (bass * 48 / 0xffff));\n}\n\nstatic void set_treble(struct cx18 *cx, int treble)\n{\n\t \n\tcx18_av_and_or(cx, 0x8db, ~0x3f, 48 - (treble * 48 / 0xffff));\n}\n\nstatic void set_balance(struct cx18 *cx, int balance)\n{\n\tint bal = balance >> 8;\n\tif (bal > 0x80) {\n\t\t \n\t\tcx18_av_and_or(cx, 0x8d5, 0x7f, 0x80);\n\t\t \n\t\tcx18_av_and_or(cx, 0x8d5, ~0x7f, bal & 0x7f);\n\t} else {\n\t\t \n\t\tcx18_av_and_or(cx, 0x8d5, 0x7f, 0x00);\n\t\t \n\t\tcx18_av_and_or(cx, 0x8d5, ~0x7f, 0x80 - bal);\n\t}\n}\n\nstatic void set_mute(struct cx18 *cx, int mute)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tu8 v;\n\n\tif (state->aud_input > CX18_AV_AUDIO_SERIAL2) {\n\t\t \n\t\tv = cx18_av_read(cx, 0x803);\n\t\tif (mute) {\n\t\t\t \n\t\t\tv &= ~0x10;\n\t\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t\t\tcx18_av_write(cx, 0x8d3, 0x1f);\n\t\t} else {\n\t\t\t \n\t\t\tv |= 0x10;\n\t\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t\t}\n\t} else {\n\t\t \n\t\tcx18_av_and_or(cx, 0x8d3, ~0x2, mute ? 0x02 : 0x00);\n\t}\n}\n\nint cx18_av_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tstruct cx18_av_state *state = &cx->av_state;\n\tint retval;\n\tu8 v;\n\n\tif (state->aud_input > CX18_AV_AUDIO_SERIAL2) {\n\t\tv = cx18_av_read(cx, 0x803) & ~0x10;\n\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t\tcx18_av_write(cx, 0x8d3, 0x1f);\n\t}\n\tv = cx18_av_read(cx, 0x810) | 0x1;\n\tcx18_av_write_expect(cx, 0x810, v, v, 0x0f);\n\n\tretval = set_audclk_freq(cx, freq);\n\n\tv = cx18_av_read(cx, 0x810) & ~0x1;\n\tcx18_av_write_expect(cx, 0x810, v, v, 0x0f);\n\tif (state->aud_input > CX18_AV_AUDIO_SERIAL2) {\n\t\tv = cx18_av_read(cx, 0x803) | 0x10;\n\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t}\n\treturn retval;\n}\n\nstatic int cx18_av_audio_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tset_volume(cx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tset_bass(cx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tset_treble(cx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t\tset_balance(cx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tset_mute(cx, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nconst struct v4l2_ctrl_ops cx18_av_audio_ctrl_ops = {\n\t.s_ctrl = cx18_av_audio_s_ctrl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}