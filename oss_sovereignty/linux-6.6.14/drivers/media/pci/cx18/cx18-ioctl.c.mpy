{
  "module_name": "cx18-ioctl.c",
  "hash_id": "53bccdfe5ae3a64b9918383627a3fc370983094b7dd0e86825d2b8fc56f1bfe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-ioctl.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-version.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-i2c.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-fileops.h\"\n#include \"cx18-vbi.h\"\n#include \"cx18-audio.h\"\n#include \"cx18-video.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-gpio.h\"\n#include \"cx18-controls.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-av-core.h\"\n#include <media/tveeprom.h>\n#include <media/v4l2-event.h>\n\nstatic const struct v4l2_fmtdesc cx18_formats_yuv[] = {\n\t{\n\t\t.index = 0,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.pixelformat = V4L2_PIX_FMT_NV12_16L16,\n\t},\n\t{\n\t\t.index = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.pixelformat = V4L2_PIX_FMT_UYVY,\n\t},\n};\n\nstatic const struct v4l2_fmtdesc cx18_formats_mpeg[] = {\n\t{\n\t\t.index = 0,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.pixelformat = V4L2_PIX_FMT_MPEG,\n\t},\n};\n\nstatic int cx18_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\n\tpixfmt->width = cx->cxhdl.width;\n\tpixfmt->height = cx->cxhdl.height;\n\tpixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpixfmt->field = V4L2_FIELD_INTERLACED;\n\tif (id->type == CX18_ENC_STREAM_TYPE_YUV) {\n\t\tpixfmt->pixelformat = s->pixelformat;\n\t\tpixfmt->sizeimage = s->vb_bytes_per_frame;\n\t\tpixfmt->bytesperline = s->vb_bytes_per_line;\n\t} else {\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\n\t\tpixfmt->sizeimage = 128 * 1024;\n\t\tpixfmt->bytesperline = 0;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\tint w = pixfmt->width;\n\tint h = pixfmt->height;\n\n\tw = min(w, 720);\n\tw = max(w, 720 / 16);\n\n\th = min(h, cx->is_50hz ? 576 : 480);\n\th = max(h, (cx->is_50hz ? 576 : 480) / 8);\n\n\tif (id->type == CX18_ENC_STREAM_TYPE_YUV) {\n\t\tif (pixfmt->pixelformat != V4L2_PIX_FMT_NV12_16L16 &&\n\t\t    pixfmt->pixelformat != V4L2_PIX_FMT_UYVY)\n\t\t\tpixfmt->pixelformat = V4L2_PIX_FMT_UYVY;\n\t\t \n\t\th = round_up(h, 32);\n\t\t \n\t\tif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12_16L16) {\n\t\t\tpixfmt->sizeimage = h * 720 * 3 / 2;\n\t\t\tpixfmt->bytesperline = 720;  \n\t\t} else {\n\t\t\tpixfmt->sizeimage = h * 720 * 2;\n\t\t\tpixfmt->bytesperline = 1440;  \n\t\t}\n\t} else {\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\n\t\tpixfmt->sizeimage = 128 * 1024;\n\t\tpixfmt->bytesperline = 0;\n\t}\n\n\tpixfmt->width = w;\n\tpixfmt->height = h;\n\tpixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpixfmt->field = V4L2_FIELD_INTERLACED;\n\treturn 0;\n}\n\nstatic int cx18_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct cx18_stream *s = &cx->streams[id->type];\n\tint ret;\n\tint w, h;\n\n\tret = cx18_try_fmt_vid_cap(file, fh, fmt);\n\tif (ret)\n\t\treturn ret;\n\tw = fmt->fmt.pix.width;\n\th = fmt->fmt.pix.height;\n\n\tif (cx->cxhdl.width == w && cx->cxhdl.height == h &&\n\t    s->pixelformat == fmt->fmt.pix.pixelformat)\n\t\treturn 0;\n\n\tif (atomic_read(&cx->ana_capturing) > 0)\n\t\treturn -EBUSY;\n\n\ts->pixelformat = fmt->fmt.pix.pixelformat;\n\ts->vb_bytes_per_frame = fmt->fmt.pix.sizeimage;\n\ts->vb_bytes_per_line = fmt->fmt.pix.bytesperline;\n\n\tformat.format.width = cx->cxhdl.width = w;\n\tformat.format.height = cx->cxhdl.height = h;\n\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\tv4l2_subdev_call(cx->sd_av, pad, set_fmt, NULL, &format);\n\treturn cx18_g_fmt_vid_cap(file, fh, fmt);\n}\n\nu16 cx18_service2vbi(int type)\n{\n\tswitch (type) {\n\tcase V4L2_SLICED_TELETEXT_B:\n\t\treturn CX18_SLICED_TYPE_TELETEXT_B;\n\tcase V4L2_SLICED_CAPTION_525:\n\t\treturn CX18_SLICED_TYPE_CAPTION_525;\n\tcase V4L2_SLICED_WSS_625:\n\t\treturn CX18_SLICED_TYPE_WSS_625;\n\tcase V4L2_SLICED_VPS:\n\t\treturn CX18_SLICED_TYPE_VPS;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int valid_service_line(int field, int line, int is_pal)\n{\n\treturn (is_pal && line >= 6 &&\n\t\t((field == 0 && line <= 23) || (field == 1 && line <= 22))) ||\n\t       (!is_pal && line >= 10 && line < 22);\n}\n\n \nstatic u16 select_service_from_set(int field, int line, u16 set, int is_pal)\n{\n\tu16 valid_set = (is_pal ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525);\n\tint i;\n\n\tset = set & valid_set;\n\tif (set == 0 || !valid_service_line(field, line, is_pal))\n\t\treturn 0;\n\tif (!is_pal) {\n\t\tif (line == 21 && (set & V4L2_SLICED_CAPTION_525))\n\t\t\treturn V4L2_SLICED_CAPTION_525;\n\t} else {\n\t\tif (line == 16 && field == 0 && (set & V4L2_SLICED_VPS))\n\t\t\treturn V4L2_SLICED_VPS;\n\t\tif (line == 23 && field == 0 && (set & V4L2_SLICED_WSS_625))\n\t\t\treturn V4L2_SLICED_WSS_625;\n\t\tif (line == 23)\n\t\t\treturn 0;\n\t}\n\tfor (i = 0; i < 32; i++) {\n\t\tif (BIT(i) & set)\n\t\t\treturn 1 << i;\n\t}\n\treturn 0;\n}\n\n \nvoid cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\n{\n\tu16 set = fmt->service_set;\n\tint f, l;\n\n\tfmt->service_set = 0;\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++)\n\t\t\tfmt->service_lines[f][l] = select_service_from_set(f, l, set, is_pal);\n\t}\n}\n\n \nstatic int check_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\n{\n\tint f, l;\n\tu16 set = 0;\n\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++) {\n\t\t\tfmt->service_lines[f][l] = select_service_from_set(f, l, fmt->service_lines[f][l], is_pal);\n\t\t\tset |= fmt->service_lines[f][l];\n\t\t}\n\t}\n\treturn set != 0;\n}\n\n \nu16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt)\n{\n\tint f, l;\n\tu16 set = 0;\n\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++)\n\t\t\tset |= fmt->service_lines[f][l];\n\t}\n\treturn set;\n}\n\nstatic int cx18_g_fmt_vbi_cap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tstruct v4l2_vbi_format *vbifmt = &fmt->fmt.vbi;\n\n\tvbifmt->sampling_rate = 27000000;\n\tvbifmt->offset = 248;  \n\tvbifmt->samples_per_line = VBI_ACTIVE_SAMPLES - 4;\n\tvbifmt->sample_format = V4L2_PIX_FMT_GREY;\n\tvbifmt->start[0] = cx->vbi.start[0];\n\tvbifmt->start[1] = cx->vbi.start[1];\n\tvbifmt->count[0] = vbifmt->count[1] = cx->vbi.count;\n\tvbifmt->flags = 0;\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\treturn 0;\n}\n\nstatic int cx18_g_fmt_sliced_vbi_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\n\t \n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\tvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\tmemset(vbifmt->service_lines, 0, sizeof(vbifmt->service_lines));\n\tvbifmt->service_set = 0;\n\n\t \n\tif (v4l2_subdev_call(cx->sd_av, vbi, g_sliced_fmt, &fmt->fmt.sliced))\n\t\treturn -EINVAL;\n\n\tvbifmt->service_set = cx18_get_service_set(vbifmt);\n\treturn 0;\n}\n\nstatic int cx18_try_fmt_vbi_cap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn cx18_g_fmt_vbi_cap(file, fh, fmt);\n}\n\nstatic int cx18_try_fmt_sliced_vbi_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\n\tvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\n\t \n\tif (vbifmt->service_set)\n\t\tcx18_expand_service_set(vbifmt, cx->is_50hz);\n\t \n\tif (check_service_set(vbifmt, cx->is_50hz))\n\t\tvbifmt->service_set = cx18_get_service_set(vbifmt);\n\treturn 0;\n}\n\nstatic int cx18_s_fmt_vbi_cap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tint ret;\n\n\t \n\tif (!cx18_raw_vbi(cx) && atomic_read(&cx->ana_capturing) > 0)\n\t\treturn -EBUSY;\n\n\t \n\tret = v4l2_subdev_call(cx->sd_av, vbi, s_raw_fmt, &fmt->fmt.vbi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcx->vbi.sliced_in->service_set = 0;\n\tcx->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\n\treturn cx18_g_fmt_vbi_cap(file, fh, fmt);\n}\n\nstatic int cx18_s_fmt_sliced_vbi_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tint ret;\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\n\tcx18_try_fmt_sliced_vbi_cap(file, fh, fmt);\n\n\t \n\tif (cx18_raw_vbi(cx) && atomic_read(&cx->ana_capturing) > 0)\n\t\treturn -EBUSY;\n\n\t \n\tret = v4l2_subdev_call(cx->sd_av, vbi, s_sliced_fmt, &fmt->fmt.sliced);\n\tif (ret)\n\t\treturn ret;\n\t \n\tcx->vbi.in.type =  V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\n\tmemcpy(cx->vbi.sliced_in, vbifmt, sizeof(*cx->vbi.sliced_in));\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int cx18_g_register(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (reg->reg & 0x3)\n\t\treturn -EINVAL;\n\tif (reg->reg >= CX18_MEM_OFFSET + CX18_MEM_SIZE)\n\t\treturn -EINVAL;\n\treg->size = 4;\n\treg->val = cx18_read_enc(cx, reg->reg);\n\treturn 0;\n}\n\nstatic int cx18_s_register(struct file *file, void *fh,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (reg->reg & 0x3)\n\t\treturn -EINVAL;\n\tif (reg->reg >= CX18_MEM_OFFSET + CX18_MEM_SIZE)\n\t\treturn -EINVAL;\n\tcx18_write_enc(cx, reg->val, reg->reg);\n\treturn 0;\n}\n#endif\n\nstatic int cx18_querycap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_capability *vcap)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\n\tstrscpy(vcap->driver, CX18_DRIVER_NAME, sizeof(vcap->driver));\n\tstrscpy(vcap->card, cx->card_name, sizeof(vcap->card));\n\tvcap->capabilities = cx->v4l2_cap | V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int cx18_enumaudio(struct file *file, void *fh, struct v4l2_audio *vin)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\treturn cx18_get_audio_input(cx, vin->index, vin);\n}\n\nstatic int cx18_g_audio(struct file *file, void *fh, struct v4l2_audio *vin)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tvin->index = cx->audio_input;\n\treturn cx18_get_audio_input(cx, vin->index, vin);\n}\n\nstatic int cx18_s_audio(struct file *file, void *fh, const struct v4l2_audio *vout)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (vout->index >= cx->nof_audio_inputs)\n\t\treturn -EINVAL;\n\tcx->audio_input = vout->index;\n\tcx18_audio_set_io(cx);\n\treturn 0;\n}\n\nstatic int cx18_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\t \n\treturn cx18_get_input(cx, vin->index, vin);\n}\n\nstatic int cx18_g_pixelaspect(struct file *file, void *fh,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf->numerator = cx->is_50hz ? 54 : 11;\n\tf->denominator = cx->is_50hz ? 59 : 10;\n\treturn 0;\n}\n\nstatic int cx18_g_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *sel)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = sel->r.left = 0;\n\t\tsel->r.width = 720;\n\t\tsel->r.height = cx->is_50hz ? 576 : 480;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\n\tif (id->type == CX18_ENC_STREAM_TYPE_YUV) {\n\t\tif (fmt->index >= ARRAY_SIZE(cx18_formats_yuv))\n\t\t\treturn -EINVAL;\n\t\t*fmt = cx18_formats_yuv[fmt->index];\n\t\treturn 0;\n\t}\n\tif (fmt->index)\n\t\treturn -EINVAL;\n\t*fmt = cx18_formats_mpeg[0];\n\treturn 0;\n}\n\nstatic int cx18_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\t*i = cx->active_input;\n\treturn 0;\n}\n\nint cx18_s_input(struct file *file, void *fh, unsigned int inp)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tv4l2_std_id std = V4L2_STD_ALL;\n\tconst struct cx18_card_video_input *card_input =\n\t\t\t\tcx->card->video_inputs + inp;\n\n\tif (inp >= cx->nof_inputs)\n\t\treturn -EINVAL;\n\n\tif (inp == cx->active_input) {\n\t\tCX18_DEBUG_INFO(\"Input unchanged\\n\");\n\t\treturn 0;\n\t}\n\n\tCX18_DEBUG_INFO(\"Changing input from %d to %d\\n\",\n\t\t\tcx->active_input, inp);\n\n\tcx->active_input = inp;\n\t \n\tcx->audio_input = cx->card->video_inputs[inp].audio_index;\n\tif (card_input->video_type == V4L2_INPUT_TYPE_TUNER)\n\t\tstd = cx->tuner_std;\n\tcx->streams[CX18_ENC_STREAM_TYPE_MPG].video_dev.tvnorms = std;\n\tcx->streams[CX18_ENC_STREAM_TYPE_YUV].video_dev.tvnorms = std;\n\tcx->streams[CX18_ENC_STREAM_TYPE_VBI].video_dev.tvnorms = std;\n\n\t \n\tcx18_mute(cx);\n\tcx18_video_set_io(cx);\n\tcx18_audio_set_io(cx);\n\tcx18_unmute(cx);\n\treturn 0;\n}\n\nstatic int cx18_g_frequency(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frequency *vf)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\tcx18_call_all(cx, tuner, g_frequency, vf);\n\treturn 0;\n}\n\nint cx18_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\tcx18_mute(cx);\n\tCX18_DEBUG_INFO(\"v4l2 ioctl: set frequency %d\\n\", vf->frequency);\n\tcx18_call_all(cx, tuner, s_frequency, vf);\n\tcx18_unmute(cx);\n\treturn 0;\n}\n\nstatic int cx18_g_std(struct file *file, void *fh, v4l2_std_id *std)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\t*std = cx->std;\n\treturn 0;\n}\n\nint cx18_s_std(struct file *file, void *fh, v4l2_std_id std)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\n\tif ((std & V4L2_STD_ALL) == 0)\n\t\treturn -EINVAL;\n\n\tif (std == cx->std)\n\t\treturn 0;\n\n\tif (test_bit(CX18_F_I_RADIO_USER, &cx->i_flags) ||\n\t    atomic_read(&cx->ana_capturing) > 0) {\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\tcx->std = std;\n\tcx->is_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\n\tcx->is_50hz = !cx->is_60hz;\n\tcx2341x_handler_set_50hz(&cx->cxhdl, cx->is_50hz);\n\tcx->cxhdl.width = 720;\n\tcx->cxhdl.height = cx->is_50hz ? 576 : 480;\n\t \n\tif (cx->streams[CX18_ENC_STREAM_TYPE_YUV].pixelformat == V4L2_PIX_FMT_NV12_16L16) {\n\t\tcx->streams[CX18_ENC_STREAM_TYPE_YUV].vb_bytes_per_frame =\n\t\t\tcx->cxhdl.height * 720 * 3 / 2;\n\t\tcx->streams[CX18_ENC_STREAM_TYPE_YUV].vb_bytes_per_line = 720;\n\t} else {\n\t\tcx->streams[CX18_ENC_STREAM_TYPE_YUV].vb_bytes_per_frame =\n\t\t\tcx->cxhdl.height * 720 * 2;\n\t\tcx->streams[CX18_ENC_STREAM_TYPE_YUV].vb_bytes_per_line = 1440;\n\t}\n\tcx->vbi.count = cx->is_50hz ? 18 : 12;\n\tcx->vbi.start[0] = cx->is_50hz ? 6 : 10;\n\tcx->vbi.start[1] = cx->is_50hz ? 318 : 273;\n\tCX18_DEBUG_INFO(\"Switching standard to %llx.\\n\",\n\t\t\t(unsigned long long) cx->std);\n\n\t \n\tcx18_call_all(cx, video, s_std, cx->std);\n\treturn 0;\n}\n\nstatic int cx18_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;\n\n\tcx18_call_all(cx, tuner, s_tuner, vt);\n\treturn 0;\n}\n\nstatic int cx18_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;\n\n\tcx18_call_all(cx, tuner, g_tuner, vt);\n\n\tif (vt->type == V4L2_TUNER_RADIO)\n\t\tstrscpy(vt->name, \"cx18 Radio Tuner\", sizeof(vt->name));\n\telse\n\t\tstrscpy(vt->name, \"cx18 TV Tuner\", sizeof(vt->name));\n\treturn 0;\n}\n\nstatic int cx18_g_sliced_vbi_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_sliced_vbi_cap *cap)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tint set = cx->is_50hz ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525;\n\tint f, l;\n\n\tif (cap->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)\n\t\treturn -EINVAL;\n\n\tcap->service_set = 0;\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++) {\n\t\t\tif (valid_service_line(f, l, cx->is_50hz)) {\n\t\t\t\t \n\t\t\t\tcap->service_lines[f][l] = set;\n\t\t\t\tcap->service_set |= set;\n\t\t\t} else\n\t\t\t\tcap->service_lines[f][l] = 0;\n\t\t}\n\t}\n\tfor (f = 0; f < 3; f++)\n\t\tcap->reserved[f] = 0;\n\treturn 0;\n}\n\nstatic int _cx18_process_idx_data(struct cx18_buffer *buf,\n\t\t\t\t  struct v4l2_enc_idx *idx)\n{\n\tint consumed, remaining;\n\tstruct v4l2_enc_idx_entry *e_idx;\n\tstruct cx18_enc_idx_entry *e_buf;\n\n\t \n\tstatic const int mapping[8] = {\n\t\t-1, V4L2_ENC_IDX_FRAME_I, V4L2_ENC_IDX_FRAME_P,\n\t\t-1, V4L2_ENC_IDX_FRAME_B, -1, -1, -1\n\t};\n\n\t \n\tremaining = buf->bytesused - buf->readpos;\n\tconsumed = 0;\n\te_idx = &idx->entry[idx->entries];\n\te_buf = (struct cx18_enc_idx_entry *) &buf->buf[buf->readpos];\n\n\twhile (remaining >= sizeof(struct cx18_enc_idx_entry) &&\n\t       idx->entries < V4L2_ENC_IDX_ENTRIES) {\n\n\t\te_idx->offset = (((u64) le32_to_cpu(e_buf->offset_high)) << 32)\n\t\t\t\t| le32_to_cpu(e_buf->offset_low);\n\n\t\te_idx->pts = (((u64) (le32_to_cpu(e_buf->pts_high) & 1)) << 32)\n\t\t\t     | le32_to_cpu(e_buf->pts_low);\n\n\t\te_idx->length = le32_to_cpu(e_buf->length);\n\n\t\te_idx->flags = mapping[le32_to_cpu(e_buf->flags) & 0x7];\n\n\t\te_idx->reserved[0] = 0;\n\t\te_idx->reserved[1] = 0;\n\n\t\tidx->entries++;\n\t\te_idx = &idx->entry[idx->entries];\n\t\te_buf++;\n\n\t\tremaining -= sizeof(struct cx18_enc_idx_entry);\n\t\tconsumed += sizeof(struct cx18_enc_idx_entry);\n\t}\n\n\t \n\tif (remaining > 0 && remaining < sizeof(struct cx18_enc_idx_entry))\n\t\tconsumed += remaining;\n\n\tbuf->readpos += consumed;\n\treturn consumed;\n}\n\nstatic int cx18_process_idx_data(struct cx18_stream *s, struct cx18_mdl *mdl,\n\t\t\t\t struct v4l2_enc_idx *idx)\n{\n\tif (s->type != CX18_ENC_STREAM_TYPE_IDX)\n\t\treturn -EINVAL;\n\n\tif (mdl->curr_buf == NULL)\n\t\tmdl->curr_buf = list_first_entry(&mdl->buf_list,\n\t\t\t\t\t\t struct cx18_buffer, list);\n\n\tif (list_entry_is_past_end(mdl->curr_buf, &mdl->buf_list, list)) {\n\t\t \n\t\tmdl->readpos = mdl->bytesused;\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_from(mdl->curr_buf, &mdl->buf_list, list) {\n\n\t\t \n\t\tif (mdl->curr_buf->readpos >= mdl->curr_buf->bytesused)\n\t\t\tcontinue;\n\n\t\tmdl->readpos += _cx18_process_idx_data(mdl->curr_buf, idx);\n\n\t\t \n\t\tif (idx->entries >= V4L2_ENC_IDX_ENTRIES ||\n\t\t    mdl->curr_buf->readpos < mdl->curr_buf->bytesused ||\n\t\t    mdl->readpos >= mdl->bytesused)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_g_enc_index(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_enc_idx *idx)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tstruct cx18_stream *s = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\ts32 tmp;\n\tstruct cx18_mdl *mdl;\n\n\tif (!cx18_stream_enabled(s))  \n\t\treturn -EINVAL;\n\n\t \n\ttmp = s->buffers -\n\t\t\t  s->bufs_per_mdl * CX18_ENC_STREAM_TYPE_IDX_FW_MDL_MIN;\n\tif (tmp <= 0)\n\t\ttmp = 1;\n\ttmp = tmp * s->buf_size / sizeof(struct cx18_enc_idx_entry);\n\n\t \n\tidx->entries = 0;\n\tidx->entries_cap = tmp;\n\tmemset(idx->reserved, 0, sizeof(idx->reserved));\n\n\t \n\tdo {\n\t\tmdl = cx18_dequeue(s, &s->q_full);\n\t\tif (mdl == NULL)  \n\t\t\tbreak;\n\n\t\t \n\t\tcx18_process_idx_data(s, mdl, idx);\n\t\tif (mdl->readpos < mdl->bytesused) {\n\t\t\t \n\t\t\tcx18_push(s, mdl, &s->q_full);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcx18_enqueue(s, mdl, &s->q_free);\n\n\t} while (idx->entries < V4L2_ENC_IDX_ENTRIES);\n\n\t \n\tcx18_stream_load_fw_queue(s);\n\treturn 0;\n}\n\nstatic int cx18_encoder_cmd(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_encoder_cmd *enc)\n{\n\tstruct cx18_open_id *id = fh2id(fh);\n\tstruct cx18 *cx = id->cx;\n\tu32 h;\n\n\tswitch (enc->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_START\\n\");\n\t\tenc->flags = 0;\n\t\treturn cx18_start_capture(id);\n\n\tcase V4L2_ENC_CMD_STOP:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_STOP\\n\");\n\t\tenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\n\t\tcx18_stop_capture(&cx->streams[id->type],\n\t\t\t\t  enc->flags & V4L2_ENC_CMD_STOP_AT_GOP_END);\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_PAUSE:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_PAUSE\\n\");\n\t\tenc->flags = 0;\n\t\tif (!atomic_read(&cx->ana_capturing))\n\t\t\treturn -EPERM;\n\t\tif (test_and_set_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\n\t\t\treturn 0;\n\t\th = cx18_find_handle(cx);\n\t\tif (h == CX18_INVALID_TASK_HANDLE) {\n\t\t\tCX18_ERR(\"Can't find valid task handle for V4L2_ENC_CMD_PAUSE\\n\");\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tcx18_mute(cx);\n\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_PAUSE, 1, h);\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_RESUME:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_RESUME\\n\");\n\t\tenc->flags = 0;\n\t\tif (!atomic_read(&cx->ana_capturing))\n\t\t\treturn -EPERM;\n\t\tif (!test_and_clear_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\n\t\t\treturn 0;\n\t\th = cx18_find_handle(cx);\n\t\tif (h == CX18_INVALID_TASK_HANDLE) {\n\t\t\tCX18_ERR(\"Can't find valid task handle for V4L2_ENC_CMD_RESUME\\n\");\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_RESUME, 1, h);\n\t\tcx18_unmute(cx);\n\t\tbreak;\n\n\tdefault:\n\t\tCX18_DEBUG_IOCTL(\"Unknown cmd %d\\n\", enc->cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_try_encoder_cmd(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_encoder_cmd *enc)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tswitch (enc->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_START\\n\");\n\t\tenc->flags = 0;\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_STOP:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_STOP\\n\");\n\t\tenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_PAUSE:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_PAUSE\\n\");\n\t\tenc->flags = 0;\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_RESUME:\n\t\tCX18_DEBUG_IOCTL(\"V4L2_ENC_CMD_RESUME\\n\");\n\t\tenc->flags = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tCX18_DEBUG_IOCTL(\"Unknown cmd %d\\n\", enc->cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_log_status(struct file *file, void *fh)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\tstruct v4l2_input vidin;\n\tstruct v4l2_audio audin;\n\tint i;\n\n\tCX18_INFO(\"Version: %s  Card: %s\\n\", CX18_VERSION, cx->card_name);\n\tif (cx->hw_flags & CX18_HW_TVEEPROM) {\n\t\tstruct tveeprom tv;\n\n\t\tcx18_read_eeprom(cx, &tv);\n\t}\n\tcx18_call_all(cx, core, log_status);\n\tcx18_get_input(cx, cx->active_input, &vidin);\n\tcx18_get_audio_input(cx, cx->audio_input, &audin);\n\tCX18_INFO(\"Video Input: %s\\n\", vidin.name);\n\tCX18_INFO(\"Audio Input: %s\\n\", audin.name);\n\tmutex_lock(&cx->gpio_lock);\n\tCX18_INFO(\"GPIO:  direction 0x%08x, value 0x%08x\\n\",\n\t\tcx->gpio_dir, cx->gpio_val);\n\tmutex_unlock(&cx->gpio_lock);\n\tCX18_INFO(\"Tuner: %s\\n\",\n\t\ttest_bit(CX18_F_I_RADIO_USER, &cx->i_flags) ?  \"Radio\" : \"TV\");\n\tv4l2_ctrl_handler_log_status(&cx->cxhdl.hdl, cx->v4l2_dev.name);\n\tCX18_INFO(\"Status flags: 0x%08lx\\n\", cx->i_flags);\n\tfor (i = 0; i < CX18_MAX_STREAMS; i++) {\n\t\tstruct cx18_stream *s = &cx->streams[i];\n\n\t\tif (s->video_dev.v4l2_dev == NULL || s->buffers == 0)\n\t\t\tcontinue;\n\t\tCX18_INFO(\"Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\\n\",\n\t\t\t  s->name, s->s_flags,\n\t\t\t  atomic_read(&s->q_full.depth) * s->bufs_per_mdl * 100\n\t\t\t   / s->buffers,\n\t\t\t  (s->buffers * s->buf_size) / 1024, s->buffers);\n\t}\n\tCX18_INFO(\"Read MPEG/VBI: %lld/%lld bytes\\n\",\n\t\t\t(long long)cx->mpg_data_received,\n\t\t\t(long long)cx->vbi_data_inserted);\n\treturn 0;\n}\n\nstatic long cx18_default(struct file *file, void *fh, bool valid_prio,\n\t\t\t unsigned int cmd, void *arg)\n{\n\tstruct cx18 *cx = fh2id(fh)->cx;\n\n\tswitch (cmd) {\n\tcase VIDIOC_INT_RESET: {\n\t\tu32 val = *(u32 *)arg;\n\n\t\tif ((val == 0) || (val & 0x01))\n\t\t\tcx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL, core, reset,\n\t\t\t\t     (u32) CX18_GPIO_RESET_Z8F0811);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops cx18_ioctl_ops = {\n\t.vidioc_querycap                = cx18_querycap,\n\t.vidioc_s_audio                 = cx18_s_audio,\n\t.vidioc_g_audio                 = cx18_g_audio,\n\t.vidioc_enumaudio               = cx18_enumaudio,\n\t.vidioc_enum_input              = cx18_enum_input,\n\t.vidioc_g_pixelaspect           = cx18_g_pixelaspect,\n\t.vidioc_g_selection             = cx18_g_selection,\n\t.vidioc_g_input                 = cx18_g_input,\n\t.vidioc_s_input                 = cx18_s_input,\n\t.vidioc_g_frequency             = cx18_g_frequency,\n\t.vidioc_s_frequency             = cx18_s_frequency,\n\t.vidioc_s_tuner                 = cx18_s_tuner,\n\t.vidioc_g_tuner                 = cx18_g_tuner,\n\t.vidioc_g_enc_index             = cx18_g_enc_index,\n\t.vidioc_g_std                   = cx18_g_std,\n\t.vidioc_s_std                   = cx18_s_std,\n\t.vidioc_log_status              = cx18_log_status,\n\t.vidioc_enum_fmt_vid_cap        = cx18_enum_fmt_vid_cap,\n\t.vidioc_encoder_cmd             = cx18_encoder_cmd,\n\t.vidioc_try_encoder_cmd         = cx18_try_encoder_cmd,\n\t.vidioc_g_fmt_vid_cap           = cx18_g_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap           = cx18_g_fmt_vbi_cap,\n\t.vidioc_g_fmt_sliced_vbi_cap    = cx18_g_fmt_sliced_vbi_cap,\n\t.vidioc_s_fmt_vid_cap           = cx18_s_fmt_vid_cap,\n\t.vidioc_s_fmt_vbi_cap           = cx18_s_fmt_vbi_cap,\n\t.vidioc_s_fmt_sliced_vbi_cap    = cx18_s_fmt_sliced_vbi_cap,\n\t.vidioc_try_fmt_vid_cap         = cx18_try_fmt_vid_cap,\n\t.vidioc_try_fmt_vbi_cap         = cx18_try_fmt_vbi_cap,\n\t.vidioc_try_fmt_sliced_vbi_cap  = cx18_try_fmt_sliced_vbi_cap,\n\t.vidioc_g_sliced_vbi_cap        = cx18_g_sliced_vbi_cap,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register              = cx18_g_register,\n\t.vidioc_s_register              = cx18_s_register,\n#endif\n\t.vidioc_default                 = cx18_default,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nvoid cx18_set_funcs(struct video_device *vdev)\n{\n\tvdev->ioctl_ops = &cx18_ioctl_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}