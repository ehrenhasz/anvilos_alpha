{
  "module_name": "cx18-av-firmware.c",
  "hash_id": "eaa1f0714b72c2418ec38bdbf0b23957c0b70c2abc409fa0171618e104896b42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-av-firmware.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include <linux/firmware.h>\n\n#define CX18_AUDIO_ENABLE    0xc72014\n#define CX18_AI1_MUX_MASK    0x30\n#define CX18_AI1_MUX_I2S1    0x00\n#define CX18_AI1_MUX_I2S2    0x10\n#define CX18_AI1_MUX_843_I2S 0x20\n#define CX18_AI1_MUX_INVALID 0x30\n\n#define FWFILE \"v4l-cx23418-dig.fw\"\n\nstatic int cx18_av_verifyfw(struct cx18 *cx, const struct firmware *fw)\n{\n\tstruct v4l2_subdev *sd = &cx->av_state.sd;\n\tint ret = 0;\n\tconst u8 *data;\n\tu32 size;\n\tint addr;\n\tu32 expected, dl_control;\n\n\t \n\tdl_control = cx18_av_read4(cx, CXADEC_DL_CTL);\n\tdo {\n\t\tdl_control &= 0x00ffffff;\n\t\tdl_control |= 0x0f000000;\n\t\tcx18_av_write4_noretry(cx, CXADEC_DL_CTL, dl_control);\n\t\tdl_control = cx18_av_read4(cx, CXADEC_DL_CTL);\n\t} while ((dl_control & 0xff000000) != 0x0f000000);\n\n\t \n\twhile (dl_control & 0x3fff)\n\t\tdl_control = cx18_av_read4(cx, CXADEC_DL_CTL);\n\n\tdata = fw->data;\n\tsize = fw->size;\n\tfor (addr = 0; addr < size; addr++) {\n\t\tdl_control &= 0xffff3fff;  \n\t\texpected = 0x0f000000 | ((u32)data[addr] << 16) | addr;\n\t\tif (expected != dl_control) {\n\t\t\tCX18_ERR_DEV(sd, \"verification of %s firmware load failed: expected %#010x got %#010x\\n\",\n\t\t\t\t     FWFILE, expected, dl_control);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tdl_control = cx18_av_read4(cx, CXADEC_DL_CTL);\n\t}\n\tif (ret == 0)\n\t\tCX18_INFO_DEV(sd, \"verified load of %s firmware (%d bytes)\\n\",\n\t\t\t      FWFILE, size);\n\treturn ret;\n}\n\nint cx18_av_loadfw(struct cx18 *cx)\n{\n\tstruct v4l2_subdev *sd = &cx->av_state.sd;\n\tconst struct firmware *fw = NULL;\n\tu32 size;\n\tu32 u, v;\n\tconst u8 *ptr;\n\tint i;\n\tint retries1 = 0;\n\n\tif (request_firmware(&fw, FWFILE, &cx->pci_dev->dev) != 0) {\n\t\tCX18_ERR_DEV(sd, \"unable to open firmware %s\\n\", FWFILE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile (retries1 < 5) {\n\t\tcx18_av_write4_expect(cx, CXADEC_CHIP_CTRL, 0x00010000,\n\t\t\t\t\t  0x00008430, 0xffffffff);  \n\t\tcx18_av_write_expect(cx, CXADEC_STD_DET_CTL, 0xf6, 0xf6, 0xff);\n\n\t\t \n\t\tcx18_av_write4_expect(cx, 0x8100, 0x00010000,\n\t\t\t\t\t  0x00008430, 0xffffffff);  \n\n\t\t \n\t\tcx18_av_write4_noretry(cx, CXADEC_DL_CTL, 0x0F000000);\n\n\t\tptr = fw->data;\n\t\tsize = fw->size;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu32 dl_control = 0x0F000000 | i | ((u32)ptr[i] << 16);\n\t\t\tu32 value = 0;\n\t\t\tint retries2;\n\t\t\tint unrec_err = 0;\n\n\t\t\tfor (retries2 = 0; retries2 < CX18_MAX_MMIO_WR_RETRIES;\n\t\t\t     retries2++) {\n\t\t\t\tcx18_av_write4_noretry(cx, CXADEC_DL_CTL,\n\t\t\t\t\t\t       dl_control);\n\t\t\t\tudelay(10);\n\t\t\t\tvalue = cx18_av_read4(cx, CXADEC_DL_CTL);\n\t\t\t\tif (value == dl_control)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif ((value & 0x3F00) != (dl_control & 0x3F00)) {\n\t\t\t\t\tunrec_err = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (unrec_err || retries2 >= CX18_MAX_MMIO_WR_RETRIES)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == size)\n\t\t\tbreak;\n\t\tretries1++;\n\t}\n\tif (retries1 >= 5) {\n\t\tCX18_ERR_DEV(sd, \"unable to load firmware %s\\n\", FWFILE);\n\t\trelease_firmware(fw);\n\t\treturn -EIO;\n\t}\n\n\tcx18_av_write4_expect(cx, CXADEC_DL_CTL,\n\t\t\t\t0x03000000 | fw->size, 0x03000000, 0x13000000);\n\n\tCX18_INFO_DEV(sd, \"loaded %s firmware (%d bytes)\\n\", FWFILE, size);\n\n\tif (cx18_av_verifyfw(cx, fw) == 0)\n\t\tcx18_av_write4_expect(cx, CXADEC_DL_CTL,\n\t\t\t\t0x13000000 | fw->size, 0x13000000, 0x13000000);\n\n\t \n\tcx18_av_and_or4(cx, CXADEC_PIN_CTRL1, ~0, 0x78000);\n\n\t \n\t \n\t \n\t \n\tcx18_av_write4(cx, CXADEC_I2S_IN_CTL, 0x000000A0);\n\n\t \n\t \n\t \n\t \n\t \n\tcx18_av_write4(cx, CXADEC_I2S_OUT_CTL, 0x000001A0);\n\n\t \n\tcx18_av_write4(cx, CXADEC_PIN_CFG3, 0x5600B687);\n\n\tcx18_av_write4_expect(cx, CXADEC_STD_DET_CTL, 0x000000F6, 0x000000F6,\n\t\t\t\t\t\t\t\t  0x3F00FFFF);\n\t \n\n\t \n\t \n\tcx18_av_write4(cx, 0x09CC, 1);\n\n\tv = cx18_read_reg(cx, CX18_AUDIO_ENABLE);\n\t \n\tif (v & 0x800)\n\t\tcx18_write_reg_expect(cx, v & 0xFFFFFBFF, CX18_AUDIO_ENABLE,\n\t\t\t\t      0, 0x400);\n\n\t \n\tv = cx18_read_reg(cx, CX18_AUDIO_ENABLE);\n\tu = v & CX18_AI1_MUX_MASK;\n\tv &= ~CX18_AI1_MUX_MASK;\n\tif (u == CX18_AI1_MUX_843_I2S || u == CX18_AI1_MUX_INVALID) {\n\t\t \n\t\tv |= CX18_AI1_MUX_I2S1;\n\t\tcx18_write_reg_expect(cx, v | 0xb00, CX18_AUDIO_ENABLE,\n\t\t\t\t      v, CX18_AI1_MUX_MASK);\n\t\t \n\t\tv = (v & ~CX18_AI1_MUX_MASK) | CX18_AI1_MUX_843_I2S;\n\t} else {\n\t\t \n\t\tv |= CX18_AI1_MUX_843_I2S;\n\t\tcx18_write_reg_expect(cx, v | 0xb00, CX18_AUDIO_ENABLE,\n\t\t\t\t      v, CX18_AI1_MUX_MASK);\n\t\t \n\t\tv = (v & ~CX18_AI1_MUX_MASK) | u;\n\t}\n\tcx18_write_reg_expect(cx, v | 0xb00, CX18_AUDIO_ENABLE,\n\t\t\t      v, CX18_AI1_MUX_MASK);\n\n\t \n\tv = cx18_av_read4(cx, CXADEC_STD_DET_CTL);\n\tv |= 0xFF;    \n\tv |= 0x400;   \n\tv |= 0x14000000;\n\tcx18_av_write4_expect(cx, CXADEC_STD_DET_CTL, v, v, 0x3F00FFFF);\n\n\trelease_firmware(fw);\n\treturn 0;\n}\n\nMODULE_FIRMWARE(FWFILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}