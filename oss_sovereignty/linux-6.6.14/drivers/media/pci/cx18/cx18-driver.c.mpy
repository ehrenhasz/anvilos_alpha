{
  "module_name": "cx18-driver.c",
  "hash_id": "4692024184e644df873bdb9cfd24a036b7bacd7426e3649bc8667937bb5cc0d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-driver.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-version.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-i2c.h\"\n#include \"cx18-irq.h\"\n#include \"cx18-gpio.h\"\n#include \"cx18-firmware.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-av-core.h\"\n#include \"cx18-scb.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-controls.h\"\n#include \"xc2028.h\"\n#include <linux/dma-mapping.h>\n#include <media/tveeprom.h>\n\n \nint cx18_first_minor;\n\n \nint (*cx18_ext_init)(struct cx18 *);\nEXPORT_SYMBOL(cx18_ext_init);\n\n \nstatic const struct pci_device_id cx18_pci_tbl[] = {\n\t{PCI_VENDOR_ID_CX, PCI_DEVICE_ID_CX23418,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, cx18_pci_tbl);\n\nstatic atomic_t cx18_instance = ATOMIC_INIT(0);\n\n \nstatic int cardtype[CX18_MAX_CARDS];\nstatic int tuner[CX18_MAX_CARDS] = { -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int radio[CX18_MAX_CARDS] = { -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1 };\nstatic unsigned cardtype_c = 1;\nstatic unsigned tuner_c = 1;\nstatic unsigned radio_c = 1;\nstatic char pal[] = \"--\";\nstatic char secam[] = \"--\";\nstatic char ntsc[] = \"-\";\n\n \nstatic int enc_ts_buffers = CX18_DEFAULT_ENC_TS_BUFFERS;\nstatic int enc_mpg_buffers = CX18_DEFAULT_ENC_MPG_BUFFERS;\nstatic int enc_idx_buffers = CX18_DEFAULT_ENC_IDX_BUFFERS;\nstatic int enc_yuv_buffers = CX18_DEFAULT_ENC_YUV_BUFFERS;\nstatic int enc_vbi_buffers = CX18_DEFAULT_ENC_VBI_BUFFERS;\nstatic int enc_pcm_buffers = CX18_DEFAULT_ENC_PCM_BUFFERS;\n\nstatic int enc_ts_bufsize = CX18_DEFAULT_ENC_TS_BUFSIZE;\nstatic int enc_mpg_bufsize = CX18_DEFAULT_ENC_MPG_BUFSIZE;\nstatic int enc_idx_bufsize = CX18_DEFAULT_ENC_IDX_BUFSIZE;\nstatic int enc_yuv_bufsize = CX18_DEFAULT_ENC_YUV_BUFSIZE;\nstatic int enc_pcm_bufsize = CX18_DEFAULT_ENC_PCM_BUFSIZE;\n\nstatic int enc_ts_bufs = -1;\nstatic int enc_mpg_bufs = -1;\nstatic int enc_idx_bufs = CX18_MAX_FW_MDLS_PER_STREAM;\nstatic int enc_yuv_bufs = -1;\nstatic int enc_vbi_bufs = -1;\nstatic int enc_pcm_bufs = -1;\n\n\nstatic int cx18_pci_latency = 1;\n\nstatic int mmio_ndelay;\nstatic int retry_mmio = 1;\n\nint cx18_debug;\n\nmodule_param_array(tuner, int, &tuner_c, 0644);\nmodule_param_array(radio, int, &radio_c, 0644);\nmodule_param_array(cardtype, int, &cardtype_c, 0644);\nmodule_param_string(pal, pal, sizeof(pal), 0644);\nmodule_param_string(secam, secam, sizeof(secam), 0644);\nmodule_param_string(ntsc, ntsc, sizeof(ntsc), 0644);\nmodule_param_named(debug, cx18_debug, int, 0644);\nmodule_param(mmio_ndelay, int, 0644);\nmodule_param(retry_mmio, int, 0644);\nmodule_param(cx18_pci_latency, int, 0644);\nmodule_param(cx18_first_minor, int, 0644);\n\nmodule_param(enc_ts_buffers, int, 0644);\nmodule_param(enc_mpg_buffers, int, 0644);\nmodule_param(enc_idx_buffers, int, 0644);\nmodule_param(enc_yuv_buffers, int, 0644);\nmodule_param(enc_vbi_buffers, int, 0644);\nmodule_param(enc_pcm_buffers, int, 0644);\n\nmodule_param(enc_ts_bufsize, int, 0644);\nmodule_param(enc_mpg_bufsize, int, 0644);\nmodule_param(enc_idx_bufsize, int, 0644);\nmodule_param(enc_yuv_bufsize, int, 0644);\nmodule_param(enc_pcm_bufsize, int, 0644);\n\nmodule_param(enc_ts_bufs, int, 0644);\nmodule_param(enc_mpg_bufs, int, 0644);\nmodule_param(enc_idx_bufs, int, 0644);\nmodule_param(enc_yuv_bufs, int, 0644);\nmodule_param(enc_vbi_bufs, int, 0644);\nmodule_param(enc_pcm_bufs, int, 0644);\n\nMODULE_PARM_DESC(tuner, \"Tuner type selection,\\n\"\n\t\t\t\"\\t\\t\\tsee tuner.h for values\");\nMODULE_PARM_DESC(radio,\n\t\t \"Enable or disable the radio. Use only if autodetection\\n\"\n\t\t \"\\t\\t\\tfails. 0 = disable, 1 = enable\");\nMODULE_PARM_DESC(cardtype,\n\t\t \"Only use this option if your card is not detected properly.\\n\"\n\t\t \"\\t\\tSpecify card type:\\n\"\n\t\t \"\\t\\t\\t 1 = Hauppauge HVR 1600 (ESMT memory)\\n\"\n\t\t \"\\t\\t\\t 2 = Hauppauge HVR 1600 (Samsung memory)\\n\"\n\t\t \"\\t\\t\\t 3 = Compro VideoMate H900\\n\"\n\t\t \"\\t\\t\\t 4 = Yuan MPC718\\n\"\n\t\t \"\\t\\t\\t 5 = Conexant Raptor PAL/SECAM\\n\"\n\t\t \"\\t\\t\\t 6 = Toshiba Qosmio DVB-T/Analog\\n\"\n\t\t \"\\t\\t\\t 7 = Leadtek WinFast PVR2100\\n\"\n\t\t \"\\t\\t\\t 8 = Leadtek WinFast DVR3100 H\\n\"\n\t\t \"\\t\\t\\t 9 = GoTView PCI DVD3 Hybrid\\n\"\n\t\t \"\\t\\t\\t 10 = Hauppauge HVR 1600 (S5H1411)\\n\"\n\t\t \"\\t\\t\\t 0 = Autodetect (default)\\n\"\n\t\t \"\\t\\t\\t-1 = Ignore this card\\n\\t\\t\");\nMODULE_PARM_DESC(pal, \"Set PAL standard: B, G, H, D, K, I, M, N, Nc, 60\");\nMODULE_PARM_DESC(secam, \"Set SECAM standard: B, G, H, D, K, L, LC\");\nMODULE_PARM_DESC(ntsc, \"Set NTSC standard: M, J, K\");\nMODULE_PARM_DESC(debug,\n\t\t \"Debug level (bitmask). Default: 0\\n\"\n\t\t \"\\t\\t\\t  1/0x0001: warning\\n\"\n\t\t \"\\t\\t\\t  2/0x0002: info\\n\"\n\t\t \"\\t\\t\\t  4/0x0004: mailbox\\n\"\n\t\t \"\\t\\t\\t  8/0x0008: dma\\n\"\n\t\t \"\\t\\t\\t 16/0x0010: ioctl\\n\"\n\t\t \"\\t\\t\\t 32/0x0020: file\\n\"\n\t\t \"\\t\\t\\t 64/0x0040: i2c\\n\"\n\t\t \"\\t\\t\\t128/0x0080: irq\\n\"\n\t\t \"\\t\\t\\t256/0x0100: high volume\\n\");\nMODULE_PARM_DESC(cx18_pci_latency,\n\t\t \"Change the PCI latency to 64 if lower: 0 = No, 1 = Yes,\\n\"\n\t\t \"\\t\\t\\tDefault: Yes\");\nMODULE_PARM_DESC(retry_mmio,\n\t\t \"(Deprecated) MMIO writes are now always checked and retried\\n\"\n\t\t \"\\t\\t\\tEffectively: 1 [Yes]\");\nMODULE_PARM_DESC(mmio_ndelay,\n\t\t \"(Deprecated) MMIO accesses are now never purposely delayed\\n\"\n\t\t \"\\t\\t\\tEffectively: 0 ns\");\nMODULE_PARM_DESC(enc_ts_buffers,\n\t\t \"Encoder TS buffer memory (MB). (enc_ts_bufs can override)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_TS_BUFFERS));\nMODULE_PARM_DESC(enc_ts_bufsize,\n\t\t \"Size of an encoder TS buffer (kB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_TS_BUFSIZE));\nMODULE_PARM_DESC(enc_ts_bufs,\n\t\t \"Number of encoder TS buffers\\n\"\n\t\t \"\\t\\t\\tDefault is computed from other enc_ts_* parameters\");\nMODULE_PARM_DESC(enc_mpg_buffers,\n\t\t \"Encoder MPG buffer memory (MB). (enc_mpg_bufs can override)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_MPG_BUFFERS));\nMODULE_PARM_DESC(enc_mpg_bufsize,\n\t\t \"Size of an encoder MPG buffer (kB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_MPG_BUFSIZE));\nMODULE_PARM_DESC(enc_mpg_bufs,\n\t\t \"Number of encoder MPG buffers\\n\"\n\t\t \"\\t\\t\\tDefault is computed from other enc_mpg_* parameters\");\nMODULE_PARM_DESC(enc_idx_buffers,\n\t\t \"(Deprecated) Encoder IDX buffer memory (MB)\\n\"\n\t\t \"\\t\\t\\tIgnored, except 0 disables IDX buffer allocations\\n\"\n\t\t \"\\t\\t\\tDefault: 1 [Enabled]\");\nMODULE_PARM_DESC(enc_idx_bufsize,\n\t\t \"Size of an encoder IDX buffer (kB)\\n\"\n\t\t \"\\t\\t\\tAllowed values are multiples of 1.5 kB rounded up\\n\"\n\t\t \"\\t\\t\\t(multiples of size required for 64 index entries)\\n\"\n\t\t \"\\t\\t\\tDefault: 2\");\nMODULE_PARM_DESC(enc_idx_bufs,\n\t\t \"Number of encoder IDX buffers\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_MAX_FW_MDLS_PER_STREAM));\nMODULE_PARM_DESC(enc_yuv_buffers,\n\t\t \"Encoder YUV buffer memory (MB). (enc_yuv_bufs can override)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_YUV_BUFFERS));\nMODULE_PARM_DESC(enc_yuv_bufsize,\n\t\t \"Size of an encoder YUV buffer (kB)\\n\"\n\t\t \"\\t\\t\\tAllowed values are multiples of 33.75 kB rounded up\\n\"\n\t\t \"\\t\\t\\t(multiples of size required for 32 screen lines)\\n\"\n\t\t \"\\t\\t\\tDefault: 102\");\nMODULE_PARM_DESC(enc_yuv_bufs,\n\t\t \"Number of encoder YUV buffers\\n\"\n\t\t \"\\t\\t\\tDefault is computed from other enc_yuv_* parameters\");\nMODULE_PARM_DESC(enc_vbi_buffers,\n\t\t \"Encoder VBI buffer memory (MB). (enc_vbi_bufs can override)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_VBI_BUFFERS));\nMODULE_PARM_DESC(enc_vbi_bufs,\n\t\t \"Number of encoder VBI buffers\\n\"\n\t\t \"\\t\\t\\tDefault is computed from enc_vbi_buffers\");\nMODULE_PARM_DESC(enc_pcm_buffers,\n\t\t \"Encoder PCM buffer memory (MB). (enc_pcm_bufs can override)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_PCM_BUFFERS));\nMODULE_PARM_DESC(enc_pcm_bufsize,\n\t\t \"Size of an encoder PCM buffer (kB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(CX18_DEFAULT_ENC_PCM_BUFSIZE));\nMODULE_PARM_DESC(enc_pcm_bufs,\n\t\t \"Number of encoder PCM buffers\\n\"\n\t\t \"\\t\\t\\tDefault is computed from other enc_pcm_* parameters\");\n\nMODULE_PARM_DESC(cx18_first_minor,\n\t\t \"Set device node number assigned to first card\");\n\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_DESCRIPTION(\"CX23418 driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_VERSION(CX18_VERSION);\n\n#if defined(CONFIG_MODULES) && defined(MODULE)\nstatic void request_module_async(struct work_struct *work)\n{\n\tstruct cx18 *dev = container_of(work, struct cx18, request_module_wk);\n\n\t \n\trequest_module(\"cx18-alsa\");\n\n\t \n\tif (cx18_ext_init)\n\t\tcx18_ext_init(dev);\n}\n\nstatic void request_modules(struct cx18 *dev)\n{\n\tINIT_WORK(&dev->request_module_wk, request_module_async);\n\tschedule_work(&dev->request_module_wk);\n}\n\nstatic void flush_request_modules(struct cx18 *dev)\n{\n\tflush_work(&dev->request_module_wk);\n}\n#else\n#define request_modules(dev)\n#define flush_request_modules(dev)\n#endif  \n\n \nint cx18_msleep_timeout(unsigned int msecs, int intr)\n{\n\tlong int timeout = msecs_to_jiffies(msecs);\n\tint sig;\n\n\tdo {\n\t\tset_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tsig = intr ? signal_pending(current) : 0;\n\t} while (!sig && timeout);\n\treturn sig;\n}\n\n \nstatic void cx18_iounmap(struct cx18 *cx)\n{\n\tif (!cx)\n\t\treturn;\n\n\t \n\tif (cx->enc_mem) {\n\t\tCX18_DEBUG_INFO(\"releasing enc_mem\\n\");\n\t\tiounmap(cx->enc_mem);\n\t\tcx->enc_mem = NULL;\n\t}\n}\n\nstatic void cx18_eeprom_dump(struct cx18 *cx, unsigned char *eedata, int len)\n{\n\tint i;\n\n\tCX18_INFO(\"eeprom dump:\\n\");\n\tfor (i = 0; i < len; i++) {\n\t\tif (0 == (i % 16))\n\t\t\tCX18_INFO(\"eeprom %02x:\", i);\n\t\tprintk(KERN_CONT \" %02x\", eedata[i]);\n\t\tif (15 == (i % 16))\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t}\n}\n\n \nvoid cx18_read_eeprom(struct cx18 *cx, struct tveeprom *tv)\n{\n\tstruct i2c_client *c;\n\tu8 eedata[256];\n\n\tmemset(tv, 0, sizeof(*tv));\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn;\n\n\tstrscpy(c->name, \"cx18 tveeprom tmp\", sizeof(c->name));\n\tc->adapter = &cx->i2c_adap[0];\n\tc->addr = 0xa0 >> 1;\n\n\tif (tveeprom_read(c, eedata, sizeof(eedata)))\n\t\tgoto ret;\n\n\tswitch (cx->card->type) {\n\tcase CX18_CARD_HVR_1600_ESMT:\n\tcase CX18_CARD_HVR_1600_SAMSUNG:\n\tcase CX18_CARD_HVR_1600_S5H1411:\n\t\ttveeprom_hauppauge_analog(tv, eedata);\n\t\tbreak;\n\tcase CX18_CARD_YUAN_MPC718:\n\tcase CX18_CARD_GOTVIEW_PCI_DVD3:\n\t\ttv->model = 0x718;\n\t\tcx18_eeprom_dump(cx, eedata, sizeof(eedata));\n\t\tCX18_INFO(\"eeprom PCI ID: %02x%02x:%02x%02x\\n\",\n\t\t\t  eedata[2], eedata[1], eedata[4], eedata[3]);\n\t\tbreak;\n\tdefault:\n\t\ttv->model = 0xffffffff;\n\t\tcx18_eeprom_dump(cx, eedata, sizeof(eedata));\n\t\tbreak;\n\t}\n\nret:\n\tkfree(c);\n}\n\nstatic void cx18_process_eeprom(struct cx18 *cx)\n{\n\tstruct tveeprom tv;\n\n\tcx18_read_eeprom(cx, &tv);\n\n\t \n\t \n\tswitch (tv.model) {\n\tcase 74301:  \n\tcase 74321:\n\tcase 74351:  \n\tcase 74361:\n\t\t \n\t\tcx->card = cx18_get_card(CX18_CARD_HVR_1600_S5H1411);\n\t\tbreak;\n\tcase 74021:  \n\tcase 74031:\n\tcase 74041:\n\tcase 74141:\n\tcase 74541:  \n\tcase 74551:\n\tcase 74591:\n\tcase 74651:\n\tcase 74691:\n\tcase 74751:\n\tcase 74891:\n\t\t \n\t\tcx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\n\t\tbreak;\n\tcase 0x718:\n\t\treturn;\n\tcase 0xffffffff:\n\t\tCX18_INFO(\"Unknown EEPROM encoding\\n\");\n\t\treturn;\n\tcase 0:\n\t\tCX18_ERR(\"Invalid EEPROM\\n\");\n\t\treturn;\n\tdefault:\n\t\tCX18_ERR(\"Unknown model %d, defaulting to original HVR-1600 (cardtype=1)\\n\",\n\t\t\t tv.model);\n\t\tcx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\n\t\tbreak;\n\t}\n\n\tcx->v4l2_cap = cx->card->v4l2_capabilities;\n\tcx->card_name = cx->card->name;\n\tcx->card_i2c = cx->card->i2c;\n\n\tCX18_INFO(\"Autodetected %s\\n\", cx->card_name);\n\n\tif (tv.tuner_type == TUNER_ABSENT)\n\t\tCX18_ERR(\"tveeprom cannot autodetect tuner!\\n\");\n\n\tif (cx->options.tuner == -1)\n\t\tcx->options.tuner = tv.tuner_type;\n\tif (cx->options.radio == -1)\n\t\tcx->options.radio = (tv.has_radio != 0);\n\n\tif (cx->std != 0)\n\t\t \n\t\treturn;\n\n\t \n#define TVEEPROM_TUNER_FORMAT_ALL (V4L2_STD_B  | V4L2_STD_GH | \\\n\t\t\t\t   V4L2_STD_MN | \\\n\t\t\t\t   V4L2_STD_PAL_I | \\\n\t\t\t\t   V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC | \\\n\t\t\t\t   V4L2_STD_DK)\n\tif ((tv.tuner_formats & TVEEPROM_TUNER_FORMAT_ALL)\n\t\t\t\t\t== TVEEPROM_TUNER_FORMAT_ALL) {\n\t\tCX18_DEBUG_INFO(\"Worldwide tuner detected\\n\");\n\t\tcx->std = V4L2_STD_ALL;\n\t} else if (tv.tuner_formats & V4L2_STD_PAL) {\n\t\tCX18_DEBUG_INFO(\"PAL tuner detected\\n\");\n\t\tcx->std |= V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\n\t} else if (tv.tuner_formats & V4L2_STD_NTSC) {\n\t\tCX18_DEBUG_INFO(\"NTSC tuner detected\\n\");\n\t\tcx->std |= V4L2_STD_NTSC_M;\n\t} else if (tv.tuner_formats & V4L2_STD_SECAM) {\n\t\tCX18_DEBUG_INFO(\"SECAM tuner detected\\n\");\n\t\tcx->std |= V4L2_STD_SECAM_L;\n\t} else {\n\t\tCX18_INFO(\"No tuner detected, default to NTSC-M\\n\");\n\t\tcx->std |= V4L2_STD_NTSC_M;\n\t}\n}\n\nstatic v4l2_std_id cx18_parse_std(struct cx18 *cx)\n{\n\tswitch (pal[0]) {\n\tcase '6':\n\t\treturn V4L2_STD_PAL_60;\n\tcase 'b':\n\tcase 'B':\n\tcase 'g':\n\tcase 'G':\n\t\treturn V4L2_STD_PAL_BG;\n\tcase 'h':\n\tcase 'H':\n\t\treturn V4L2_STD_PAL_H;\n\tcase 'n':\n\tcase 'N':\n\t\tif (pal[1] == 'c' || pal[1] == 'C')\n\t\t\treturn V4L2_STD_PAL_Nc;\n\t\treturn V4L2_STD_PAL_N;\n\tcase 'i':\n\tcase 'I':\n\t\treturn V4L2_STD_PAL_I;\n\tcase 'd':\n\tcase 'D':\n\tcase 'k':\n\tcase 'K':\n\t\treturn V4L2_STD_PAL_DK;\n\tcase 'M':\n\tcase 'm':\n\t\treturn V4L2_STD_PAL_M;\n\tcase '-':\n\t\tbreak;\n\tdefault:\n\t\tCX18_WARN(\"pal= argument not recognised\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (secam[0]) {\n\tcase 'b':\n\tcase 'B':\n\tcase 'g':\n\tcase 'G':\n\tcase 'h':\n\tcase 'H':\n\t\treturn V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H;\n\tcase 'd':\n\tcase 'D':\n\tcase 'k':\n\tcase 'K':\n\t\treturn V4L2_STD_SECAM_DK;\n\tcase 'l':\n\tcase 'L':\n\t\tif (secam[1] == 'C' || secam[1] == 'c')\n\t\t\treturn V4L2_STD_SECAM_LC;\n\t\treturn V4L2_STD_SECAM_L;\n\tcase '-':\n\t\tbreak;\n\tdefault:\n\t\tCX18_WARN(\"secam= argument not recognised\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (ntsc[0]) {\n\tcase 'm':\n\tcase 'M':\n\t\treturn V4L2_STD_NTSC_M;\n\tcase 'j':\n\tcase 'J':\n\t\treturn V4L2_STD_NTSC_M_JP;\n\tcase 'k':\n\tcase 'K':\n\t\treturn V4L2_STD_NTSC_M_KR;\n\tcase '-':\n\t\tbreak;\n\tdefault:\n\t\tCX18_WARN(\"ntsc= argument not recognised\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void cx18_process_options(struct cx18 *cx)\n{\n\tint i, j;\n\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_TS] = enc_ts_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_VBI] = enc_vbi_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_buffers;\n\tcx->options.megabytes[CX18_ENC_STREAM_TYPE_RAD] = 0;  \n\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_TS] = enc_ts_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_VBI] = enc_vbi_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_bufs;\n\tcx->stream_buffers[CX18_ENC_STREAM_TYPE_RAD] = 0;  \n\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_TS] = enc_ts_bufsize;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_bufsize;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_bufsize;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_bufsize;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_VBI] = VBI_ACTIVE_SAMPLES * 36;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_bufsize;\n\tcx->stream_buf_size[CX18_ENC_STREAM_TYPE_RAD] = 0;  \n\n\t \n\tfor (i = 0; i < CX18_MAX_STREAMS; i++) {\n\t\tif (cx->stream_buffers[i] == 0 ||      \n\t\t    cx->options.megabytes[i] <= 0 ||   \n\t\t    cx->stream_buf_size[i] <= 0) {     \n\t\t\tcx->options.megabytes[i] = 0;\n\t\t\tcx->stream_buffers[i] = 0;\n\t\t\tcx->stream_buf_size[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (i == CX18_ENC_STREAM_TYPE_YUV) {\n\t\t\tcx->stream_buf_size[i] *= 1024;\n\t\t\tcx->stream_buf_size[i] -=\n\t\t\t   (cx->stream_buf_size[i] % CX18_UNIT_ENC_YUV_BUFSIZE);\n\n\t\t\tif (cx->stream_buf_size[i] < CX18_UNIT_ENC_YUV_BUFSIZE)\n\t\t\t\tcx->stream_buf_size[i] =\n\t\t\t\t\t\tCX18_UNIT_ENC_YUV_BUFSIZE;\n\t\t} else if (i == CX18_ENC_STREAM_TYPE_IDX) {\n\t\t\tcx->stream_buf_size[i] *= 1024;\n\t\t\tcx->stream_buf_size[i] -=\n\t\t\t   (cx->stream_buf_size[i] % CX18_UNIT_ENC_IDX_BUFSIZE);\n\n\t\t\tif (cx->stream_buf_size[i] < CX18_UNIT_ENC_IDX_BUFSIZE)\n\t\t\t\tcx->stream_buf_size[i] =\n\t\t\t\t\t\tCX18_UNIT_ENC_IDX_BUFSIZE;\n\t\t}\n\t\t \n\t\tif (i == CX18_ENC_STREAM_TYPE_VBI ||\n\t\t    i == CX18_ENC_STREAM_TYPE_YUV ||\n\t\t    i == CX18_ENC_STREAM_TYPE_IDX) {\n\t\t\tif (cx->stream_buffers[i] < 0) {\n\t\t\t\tcx->stream_buffers[i] =\n\t\t\t\t\tcx->options.megabytes[i] * 1024 * 1024\n\t\t\t\t\t/ cx->stream_buf_size[i];\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcx->options.megabytes[i] =\n\t\t\t\t\tcx->stream_buffers[i]\n\t\t\t\t\t* cx->stream_buf_size[i]/(1024 * 1024);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (cx->stream_buffers[i] < 0) {\n\t\t\t\tcx->stream_buffers[i] =\n\t\t\t\t\t\tcx->options.megabytes[i] * 1024\n\t\t\t\t\t\t/ cx->stream_buf_size[i];\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcx->options.megabytes[i] =\n\t\t\t\t\t\tcx->stream_buffers[i]\n\t\t\t\t\t\t* cx->stream_buf_size[i] / 1024;\n\t\t\t}\n\t\t\t \n\t\t\tcx->stream_buf_size[i] *= 1024;\n\t\t}\n\t\tCX18_DEBUG_INFO(\"Stream type %d options: %d MB, %d buffers, %d bytes\\n\",\n\t\t\t\ti, cx->options.megabytes[i],\n\t\t\t\tcx->stream_buffers[i], cx->stream_buf_size[i]);\n\t}\n\n\tcx->options.cardtype = cardtype[cx->instance];\n\tcx->options.tuner = tuner[cx->instance];\n\tcx->options.radio = radio[cx->instance];\n\n\tcx->std = cx18_parse_std(cx);\n\tif (cx->options.cardtype == -1) {\n\t\tCX18_INFO(\"Ignore card\\n\");\n\t\treturn;\n\t}\n\tcx->card = cx18_get_card(cx->options.cardtype - 1);\n\tif (cx->card)\n\t\tCX18_INFO(\"User specified %s card\\n\", cx->card->name);\n\telse if (cx->options.cardtype != 0)\n\t\tCX18_ERR(\"Unknown user specified type, trying to autodetect card\\n\");\n\tif (!cx->card) {\n\t\tif (cx->pci_dev->subsystem_vendor == CX18_PCI_ID_HAUPPAUGE) {\n\t\t\tcx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\n\t\t\tCX18_INFO(\"Autodetected Hauppauge card\\n\");\n\t\t}\n\t}\n\tif (!cx->card) {\n\t\tfor (i = 0; (cx->card = cx18_get_card(i)); i++) {\n\t\t\tif (!cx->card->pci_list)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; cx->card->pci_list[j].device; j++) {\n\t\t\t\tif (cx->pci_dev->device !=\n\t\t\t\t    cx->card->pci_list[j].device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cx->pci_dev->subsystem_vendor !=\n\t\t\t\t    cx->card->pci_list[j].subsystem_vendor)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cx->pci_dev->subsystem_device !=\n\t\t\t\t    cx->card->pci_list[j].subsystem_device)\n\t\t\t\t\tcontinue;\n\t\t\t\tCX18_INFO(\"Autodetected %s card\\n\", cx->card->name);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\n\tif (!cx->card) {\n\t\tcx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\n\t\tCX18_ERR(\"Unknown card: vendor/device: [%04x:%04x]\\n\",\n\t\t\t cx->pci_dev->vendor, cx->pci_dev->device);\n\t\tCX18_ERR(\"              subsystem vendor/device: [%04x:%04x]\\n\",\n\t\t\t cx->pci_dev->subsystem_vendor,\n\t\t\t cx->pci_dev->subsystem_device);\n\t\tCX18_ERR(\"Defaulting to %s card\\n\", cx->card->name);\n\t\tCX18_ERR(\"Please mail the vendor/device and subsystem vendor/device IDs and what kind of\\n\");\n\t\tCX18_ERR(\"card you have to the linux-media mailinglist (www.linuxtv.org)\\n\");\n\t\tCX18_ERR(\"Prefix your subject line with [UNKNOWN CX18 CARD].\\n\");\n\t}\n\tcx->v4l2_cap = cx->card->v4l2_capabilities;\n\tcx->card_name = cx->card->name;\n\tcx->card_i2c = cx->card->i2c;\n}\n\nstatic int cx18_create_in_workq(struct cx18 *cx)\n{\n\tsnprintf(cx->in_workq_name, sizeof(cx->in_workq_name), \"%s-in\",\n\t\t cx->v4l2_dev.name);\n\tcx->in_work_queue = alloc_ordered_workqueue(\"%s\", 0, cx->in_workq_name);\n\tif (!cx->in_work_queue) {\n\t\tCX18_ERR(\"Unable to create incoming mailbox handler thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void cx18_init_in_work_orders(struct cx18 *cx)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++) {\n\t\tcx->in_work_order[i].cx = cx;\n\t\tcx->in_work_order[i].str = cx->epu_debug_str;\n\t\tINIT_WORK(&cx->in_work_order[i].work, cx18_in_work_handler);\n\t}\n}\n\n \nstatic int cx18_init_struct1(struct cx18 *cx)\n{\n\tint ret;\n\n\tcx->base_addr = pci_resource_start(cx->pci_dev, 0);\n\n\tmutex_init(&cx->serialize_lock);\n\tmutex_init(&cx->gpio_lock);\n\tmutex_init(&cx->epu2apu_mb_lock);\n\tmutex_init(&cx->epu2cpu_mb_lock);\n\n\tret = cx18_create_in_workq(cx);\n\tif (ret)\n\t\treturn ret;\n\n\tcx18_init_in_work_orders(cx);\n\n\t \n\tcx->open_id = 1;\n\n\t \n\tcx->cxhdl.port = CX2341X_PORT_MEMORY;\n\tcx->cxhdl.capabilities = CX2341X_CAP_HAS_TS | CX2341X_CAP_HAS_SLICED_VBI;\n\tcx->cxhdl.ops = &cx18_cxhdl_ops;\n\tcx->cxhdl.func = cx18_api_func;\n\tcx->cxhdl.priv = &cx->streams[CX18_ENC_STREAM_TYPE_MPG];\n\tret = cx2341x_handler_init(&cx->cxhdl, 50);\n\tif (ret)\n\t\treturn ret;\n\tcx->v4l2_dev.ctrl_handler = &cx->cxhdl.hdl;\n\n\tcx->temporal_strength = cx->cxhdl.video_temporal_filter->cur.val;\n\tcx->spatial_strength = cx->cxhdl.video_spatial_filter->cur.val;\n\tcx->filter_mode = cx->cxhdl.video_spatial_filter_mode->cur.val |\n\t\t(cx->cxhdl.video_temporal_filter_mode->cur.val << 1) |\n\t\t(cx->cxhdl.video_median_filter_type->cur.val << 2);\n\n\tinit_waitqueue_head(&cx->cap_w);\n\tinit_waitqueue_head(&cx->mb_apu_waitq);\n\tinit_waitqueue_head(&cx->mb_cpu_waitq);\n\tinit_waitqueue_head(&cx->dma_waitq);\n\n\t \n\tcx->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tcx->vbi.sliced_in = &cx->vbi.in.fmt.sliced;\n\n\t \n\tINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_buf.list);\n\tINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_mdl.list);\n\tINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_mdl.buf_list);\n\tlist_add(&cx->vbi.sliced_mpeg_buf.list,\n\t\t &cx->vbi.sliced_mpeg_mdl.buf_list);\n\treturn 0;\n}\n\n \nstatic void cx18_init_struct2(struct cx18 *cx)\n{\n\tint i;\n\n\tfor (i = 0; i < CX18_CARD_MAX_VIDEO_INPUTS; i++)\n\t\tif (cx->card->video_inputs[i].video_type == 0)\n\t\t\tbreak;\n\tcx->nof_inputs = i;\n\tfor (i = 0; i < CX18_CARD_MAX_AUDIO_INPUTS; i++)\n\t\tif (cx->card->audio_inputs[i].audio_type == 0)\n\t\t\tbreak;\n\tcx->nof_audio_inputs = i;\n\n\t \n\tfor (i = 0; i < cx->nof_inputs; i++) {\n\t\tif (cx->card->video_inputs[i].video_type ==\n\t\t\t\tCX18_CARD_INPUT_VID_TUNER)\n\t\t\tbreak;\n\t}\n\tif (i == cx->nof_inputs)\n\t\ti = 0;\n\tcx->active_input = i;\n\tcx->audio_input = cx->card->video_inputs[i].audio_index;\n}\n\nstatic int cx18_setup_pci(struct cx18 *cx, struct pci_dev *pci_dev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tu16 cmd;\n\tunsigned char pci_latency;\n\n\tCX18_DEBUG_INFO(\"Enabling pci device\\n\");\n\n\tif (pci_enable_device(pci_dev)) {\n\t\tCX18_ERR(\"Can't enable device %d!\\n\", cx->instance);\n\t\treturn -EIO;\n\t}\n\tif (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {\n\t\tCX18_ERR(\"No suitable DMA available, card %d\\n\", cx->instance);\n\t\treturn -EIO;\n\t}\n\tif (!request_mem_region(cx->base_addr, CX18_MEM_SIZE, \"cx18 encoder\")) {\n\t\tCX18_ERR(\"Cannot request encoder memory region, card %d\\n\",\n\t\t\t cx->instance);\n\t\treturn -EIO;\n\t}\n\n\t \n\tpci_read_config_word(pci_dev, PCI_COMMAND, &cmd);\n\tcmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\n\tpci_write_config_word(pci_dev, PCI_COMMAND, cmd);\n\n\tcx->card_rev = pci_dev->revision;\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &pci_latency);\n\n\tif (pci_latency < 64 && cx18_pci_latency) {\n\t\tCX18_INFO(\"Unreasonably low latency timer, setting to 64 (was %d)\\n\",\n\t\t\t  pci_latency);\n\t\tpci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, 64);\n\t\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &pci_latency);\n\t}\n\n\tCX18_DEBUG_INFO(\"cx%d (rev %d) at %02x:%02x.%x, irq: %d, latency: %d, memory: 0x%llx\\n\",\n\t\t   cx->pci_dev->device, cx->card_rev, pci_dev->bus->number,\n\t\t   PCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn),\n\t\t   cx->pci_dev->irq, pci_latency, (u64)cx->base_addr);\n\n\treturn 0;\n}\n\nstatic void cx18_init_subdevs(struct cx18 *cx)\n{\n\tu32 hw = cx->card->hw_all;\n\tu32 device;\n\tint i;\n\n\tfor (i = 0, device = 1; i < 32; i++, device <<= 1) {\n\n\t\tif (!(device & hw))\n\t\t\tcontinue;\n\n\t\tswitch (device) {\n\t\tcase CX18_HW_DVB:\n\t\tcase CX18_HW_TVEEPROM:\n\t\t\t \n\t\t\tcx->hw_flags |= device;\n\t\t\tbreak;\n\t\tcase CX18_HW_418_AV:\n\t\t\t \n\t\t\t \n\t\t\tcx->hw_flags |= device;\n\t\t\tbreak;\n\t\tcase CX18_HW_GPIO_RESET_CTRL:\n\t\t\t \n\t\t\tbreak;\n\t\tcase CX18_HW_GPIO_MUX:\n\t\t\tif (cx18_gpio_register(cx, device) == 0)\n\t\t\t\tcx->hw_flags |= device;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cx18_i2c_register(cx, i) == 0)\n\t\t\t\tcx->hw_flags |= device;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cx->hw_flags & CX18_HW_418_AV)\n\t\tcx->sd_av = cx18_find_hw(cx, CX18_HW_418_AV);\n\n\tif (cx->card->hw_muxer != 0)\n\t\tcx->sd_extmux = cx18_find_hw(cx, cx->card->hw_muxer);\n}\n\nstatic int cx18_probe(struct pci_dev *pci_dev,\n\t\t      const struct pci_device_id *pci_id)\n{\n\tint retval = 0;\n\tint i;\n\tu32 devtype;\n\tstruct cx18 *cx;\n\n\t \n\ti = atomic_inc_return(&cx18_instance) - 1;\n\tif (i >= CX18_MAX_CARDS) {\n\t\tprintk(KERN_ERR \"cx18: cannot manage card %d, driver has a limit of 0 - %d\\n\",\n\t\t       i, CX18_MAX_CARDS - 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tcx = kzalloc(sizeof(*cx), GFP_KERNEL);\n\tif (!cx)\n\t\treturn -ENOMEM;\n\n\tcx->pci_dev = pci_dev;\n\tcx->instance = i;\n\n\tretval = v4l2_device_register(&pci_dev->dev, &cx->v4l2_dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"cx18: v4l2_device_register of card %d failed\\n\",\n\t\t       cx->instance);\n\t\tkfree(cx);\n\t\treturn retval;\n\t}\n\tsnprintf(cx->v4l2_dev.name, sizeof(cx->v4l2_dev.name), \"cx18-%d\",\n\t\t cx->instance);\n\tCX18_INFO(\"Initializing card %d\\n\", cx->instance);\n\n\tcx18_process_options(cx);\n\tif (cx->options.cardtype == -1) {\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tretval = cx18_init_struct1(cx);\n\tif (retval)\n\t\tgoto err;\n\n\tCX18_DEBUG_INFO(\"base addr: 0x%llx\\n\", (u64)cx->base_addr);\n\n\t \n\tretval = cx18_setup_pci(cx, pci_dev, pci_id);\n\tif (retval != 0)\n\t\tgoto free_workqueues;\n\n\t \n\tCX18_DEBUG_INFO(\"attempting ioremap at 0x%llx len 0x%08x\\n\",\n\t\t   (u64)cx->base_addr + CX18_MEM_OFFSET, CX18_MEM_SIZE);\n\tcx->enc_mem = ioremap(cx->base_addr + CX18_MEM_OFFSET,\n\t\t\t\t       CX18_MEM_SIZE);\n\tif (!cx->enc_mem) {\n\t\tCX18_ERR(\"ioremap failed. Can't get a window into CX23418 memory and register space\\n\");\n\t\tCX18_ERR(\"Each capture card with a CX23418 needs 64 MB of vmalloc address space for the window\\n\");\n\t\tCX18_ERR(\"Check the output of 'grep Vmalloc /proc/meminfo'\\n\");\n\t\tCX18_ERR(\"Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\tcx->reg_mem = cx->enc_mem + CX18_REG_OFFSET;\n\tdevtype = cx18_read_reg(cx, 0xC72028);\n\tswitch (devtype & 0xff000000) {\n\tcase 0xff000000:\n\t\tCX18_INFO(\"cx23418 revision %08x (A)\\n\", devtype);\n\t\tbreak;\n\tcase 0x01000000:\n\t\tCX18_INFO(\"cx23418 revision %08x (B)\\n\", devtype);\n\t\tbreak;\n\tdefault:\n\t\tCX18_INFO(\"cx23418 revision %08x (Unknown)\\n\", devtype);\n\t\tbreak;\n\t}\n\n\tcx18_init_power(cx, 1);\n\tcx18_init_memory(cx);\n\n\tcx->scb = (struct cx18_scb __iomem *)(cx->enc_mem + SCB_OFFSET);\n\tcx18_init_scb(cx);\n\n\tcx18_gpio_init(cx);\n\n\t \n\tretval = cx18_av_probe(cx);\n\tif (retval) {\n\t\tCX18_ERR(\"Could not register A/V decoder subdevice\\n\");\n\t\tgoto free_map;\n\t}\n\n\t \n\tif (cx->card->hw_all & CX18_HW_GPIO_RESET_CTRL) {\n\t\tif (cx18_gpio_register(cx, CX18_HW_GPIO_RESET_CTRL) != 0)\n\t\t\tCX18_WARN(\"Could not register GPIO reset controllersubdevice; proceeding anyway.\\n\");\n\t\telse\n\t\t\tcx->hw_flags |= CX18_HW_GPIO_RESET_CTRL;\n\t}\n\n\t \n\tCX18_DEBUG_INFO(\"activating i2c...\\n\");\n\tretval = init_cx18_i2c(cx);\n\tif (retval) {\n\t\tCX18_ERR(\"Could not initialize i2c\\n\");\n\t\tgoto free_map;\n\t}\n\n\tif (cx->card->hw_all & CX18_HW_TVEEPROM) {\n\t\t \n\t\tconst struct cx18_card *orig_card = cx->card;\n\t\tcx18_process_eeprom(cx);\n\n\t\tif (cx->card != orig_card) {\n\t\t\t \n\t\t\tcx18_gpio_init(cx);\n\t\t\tcx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL,\n\t\t\t\t\tcore, reset, (u32) CX18_GPIO_RESET_I2C);\n\t\t}\n\t}\n\tif (cx->card->comment)\n\t\tCX18_INFO(\"%s\", cx->card->comment);\n\tif (cx->card->v4l2_capabilities == 0) {\n\t\tretval = -ENODEV;\n\t\tgoto free_i2c;\n\t}\n\tcx18_init_memory(cx);\n\tcx18_init_scb(cx);\n\n\t \n\tretval = request_irq(cx->pci_dev->irq, cx18_irq_handler,\n\t\t\t     IRQF_SHARED, cx->v4l2_dev.name, (void *)cx);\n\tif (retval) {\n\t\tCX18_ERR(\"Failed to register irq %d\\n\", retval);\n\t\tgoto free_i2c;\n\t}\n\n\tif (cx->std == 0)\n\t\tcx->std = V4L2_STD_NTSC_M;\n\n\tif (cx->options.tuner == -1) {\n\t\tfor (i = 0; i < CX18_CARD_MAX_TUNERS; i++) {\n\t\t\tif ((cx->std & cx->card->tuners[i].std) == 0)\n\t\t\t\tcontinue;\n\t\t\tcx->options.tuner = cx->card->tuners[i].tuner;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (cx->options.tuner == -1 && cx->card->tuners[0].std) {\n\t\tcx->std = cx->card->tuners[0].std;\n\t\tif (cx->std & V4L2_STD_PAL)\n\t\t\tcx->std = V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\n\t\telse if (cx->std & V4L2_STD_NTSC)\n\t\t\tcx->std = V4L2_STD_NTSC_M;\n\t\telse if (cx->std & V4L2_STD_SECAM)\n\t\t\tcx->std = V4L2_STD_SECAM_L;\n\t\tcx->options.tuner = cx->card->tuners[0].tuner;\n\t}\n\tif (cx->options.radio == -1)\n\t\tcx->options.radio = (cx->card->radio_input.audio_type != 0);\n\n\t \n\tcx18_init_struct2(cx);\n\n\tcx18_init_subdevs(cx);\n\n\tif (cx->std & V4L2_STD_525_60)\n\t\tcx->is_60hz = 1;\n\telse\n\t\tcx->is_50hz = 1;\n\n\tcx2341x_handler_set_50hz(&cx->cxhdl, !cx->is_60hz);\n\n\tif (cx->options.radio > 0)\n\t\tcx->v4l2_cap |= V4L2_CAP_RADIO;\n\n\tif (cx->options.tuner > -1) {\n\t\tstruct tuner_setup setup;\n\n\t\tsetup.addr = ADDR_UNSET;\n\t\tsetup.type = cx->options.tuner;\n\t\tsetup.mode_mask = T_ANALOG_TV;   \n\t\tsetup.config = NULL;\n\t\tif (cx->options.radio > 0)\n\t\t\tsetup.mode_mask |= T_RADIO;\n\t\tsetup.tuner_callback = (setup.type == TUNER_XC2028) ?\n\t\t\tcx18_reset_tuner_gpio : NULL;\n\t\tcx18_call_all(cx, tuner, s_type_addr, &setup);\n\t\tif (setup.type == TUNER_XC2028) {\n\t\t\tstatic struct xc2028_ctrl ctrl = {\n\t\t\t\t.fname = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t};\n\t\t\tstruct v4l2_priv_tun_config cfg = {\n\t\t\t\t.tuner = cx->options.tuner,\n\t\t\t\t.priv = &ctrl,\n\t\t\t};\n\t\t\tcx18_call_all(cx, tuner, s_config, &cfg);\n\t\t}\n\t}\n\n\t \n\tcx->tuner_std = cx->std;\n\tif (cx->std == V4L2_STD_ALL)\n\t\tcx->std = V4L2_STD_NTSC_M;\n\n\tretval = cx18_streams_setup(cx);\n\tif (retval) {\n\t\tCX18_ERR(\"Error %d setting up streams\\n\", retval);\n\t\tgoto free_irq;\n\t}\n\tretval = cx18_streams_register(cx);\n\tif (retval) {\n\t\tCX18_ERR(\"Error %d registering devices\\n\", retval);\n\t\tgoto free_streams;\n\t}\n\n\tCX18_INFO(\"Initialized card: %s\\n\", cx->card_name);\n\n\t \n\trequest_modules(cx);\n\treturn 0;\n\nfree_streams:\n\tcx18_streams_cleanup(cx, 1);\nfree_irq:\n\tfree_irq(cx->pci_dev->irq, (void *)cx);\nfree_i2c:\n\texit_cx18_i2c(cx);\nfree_map:\n\tcx18_iounmap(cx);\nfree_mem:\n\trelease_mem_region(cx->base_addr, CX18_MEM_SIZE);\nfree_workqueues:\n\tdestroy_workqueue(cx->in_work_queue);\nerr:\n\tCX18_ERR(\"Error %d on initialization\\n\", retval);\n\n\tv4l2_device_unregister(&cx->v4l2_dev);\n\tkfree(cx);\n\treturn retval;\n}\n\nint cx18_init_on_first_open(struct cx18 *cx)\n{\n\tint video_input;\n\tint fw_retry_count = 3;\n\tstruct v4l2_frequency vf;\n\tstruct cx18_open_id fh;\n\tv4l2_std_id std;\n\n\tfh.cx = cx;\n\n\tif (test_bit(CX18_F_I_FAILED, &cx->i_flags))\n\t\treturn -ENXIO;\n\n\tif (test_and_set_bit(CX18_F_I_INITED, &cx->i_flags))\n\t\treturn 0;\n\n\twhile (--fw_retry_count > 0) {\n\t\t \n\t\tif (cx18_firmware_init(cx) == 0)\n\t\t\tbreak;\n\t\tif (fw_retry_count > 1)\n\t\t\tCX18_WARN(\"Retry loading firmware\\n\");\n\t}\n\n\tif (fw_retry_count == 0) {\n\t\tset_bit(CX18_F_I_FAILED, &cx->i_flags);\n\t\treturn -ENXIO;\n\t}\n\tset_bit(CX18_F_I_LOADED_FW, &cx->i_flags);\n\n\t \n\n\t \n\tcx18_vapi(cx, CX18_APU_START, 2, CX18_APU_ENCODING_METHOD_MPEG|0xb9, 0);\n\tcx18_vapi(cx, CX18_APU_RESETAI, 0);\n\tcx18_vapi(cx, CX18_APU_STOP, 1, CX18_APU_ENCODING_METHOD_MPEG);\n\n\tfw_retry_count = 3;\n\twhile (--fw_retry_count > 0) {\n\t\t \n\t\tif (cx18_firmware_init(cx) == 0)\n\t\t\tbreak;\n\t\tif (fw_retry_count > 1)\n\t\t\tCX18_WARN(\"Retry loading firmware\\n\");\n\t}\n\n\tif (fw_retry_count == 0) {\n\t\tset_bit(CX18_F_I_FAILED, &cx->i_flags);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\n\t \n\tcx18_vapi(cx, CX18_APU_START, 2, CX18_APU_ENCODING_METHOD_MPEG|0xb9, 0);\n\tcx18_vapi(cx, CX18_APU_RESETAI, 0);\n\tcx18_vapi(cx, CX18_APU_STOP, 1, CX18_APU_ENCODING_METHOD_MPEG);\n\n\t \n\tv4l2_subdev_call(cx->sd_av, core, load_fw);\n\n\tvf.tuner = 0;\n\tvf.type = V4L2_TUNER_ANALOG_TV;\n\tvf.frequency = 6400;  \n\n\t \n\tif (cx->std == V4L2_STD_NTSC_M_JP)\n\t\tvf.frequency = 1460;\t \n\telse if (cx->std & V4L2_STD_NTSC_M)\n\t\tvf.frequency = 1076;\t \n\n\tvideo_input = cx->active_input;\n\tcx->active_input++;\t \n\tcx18_s_input(NULL, &fh, video_input);\n\n\t \n\tcx->std++;\t\t \n\tstd = (cx->tuner_std == V4L2_STD_ALL) ? V4L2_STD_NTSC_M : cx->tuner_std;\n\tcx18_s_std(NULL, &fh, std);\n\tcx18_s_frequency(NULL, &fh, &vf);\n\treturn 0;\n}\n\nstatic void cx18_cancel_in_work_orders(struct cx18 *cx)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++)\n\t\tcancel_work_sync(&cx->in_work_order[i].work);\n}\n\nstatic void cx18_cancel_out_work_orders(struct cx18 *cx)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_STREAMS; i++)\n\t\tif (cx->streams[i].video_dev.v4l2_dev)\n\t\t\tcancel_work_sync(&cx->streams[i].out_work_order);\n}\n\nstatic void cx18_remove(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct cx18 *cx = to_cx18(v4l2_dev);\n\tint i;\n\n\tCX18_DEBUG_INFO(\"Removing Card\\n\");\n\n\tflush_request_modules(cx);\n\n\t \n\tCX18_DEBUG_INFO(\"Stopping all streams\\n\");\n\tif (atomic_read(&cx->tot_capturing) > 0)\n\t\tcx18_stop_all_captures(cx);\n\n\t \n\tcx18_sw1_irq_disable(cx, IRQ_CPU_TO_EPU | IRQ_APU_TO_EPU);\n\n\t \n\tcx18_cancel_in_work_orders(cx);\n\tcx18_cancel_out_work_orders(cx);\n\n\t \n\tcx18_sw2_irq_disable(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\n\n\tcx18_halt_firmware(cx);\n\n\tdestroy_workqueue(cx->in_work_queue);\n\n\tcx18_streams_cleanup(cx, 1);\n\n\texit_cx18_i2c(cx);\n\n\tfree_irq(cx->pci_dev->irq, (void *)cx);\n\n\tcx18_iounmap(cx);\n\n\trelease_mem_region(cx->base_addr, CX18_MEM_SIZE);\n\n\tpci_disable_device(cx->pci_dev);\n\n\tif (cx->vbi.sliced_mpeg_data[0])\n\t\tfor (i = 0; i < CX18_VBI_FRAMES; i++)\n\t\t\tkfree(cx->vbi.sliced_mpeg_data[i]);\n\n\tv4l2_ctrl_handler_free(&cx->av_state.hdl);\n\n\tCX18_INFO(\"Removed %s\\n\", cx->card_name);\n\n\tv4l2_device_unregister(v4l2_dev);\n\tkfree(cx);\n}\n\n\n \nstatic struct pci_driver cx18_pci_driver = {\n      .name =     \"cx18\",\n      .id_table = cx18_pci_tbl,\n      .probe =    cx18_probe,\n      .remove =   cx18_remove,\n};\n\nstatic int __init module_start(void)\n{\n\tprintk(KERN_INFO \"cx18:  Start initialization, version %s\\n\",\n\t       CX18_VERSION);\n\n\t \n\tif (cx18_first_minor < 0 || cx18_first_minor >= CX18_MAX_CARDS) {\n\t\tprintk(KERN_ERR \"cx18:  Exiting, cx18_first_minor must be between 0 and %d\\n\",\n\t\t     CX18_MAX_CARDS - 1);\n\t\treturn -1;\n\t}\n\n\tif (cx18_debug < 0 || cx18_debug > 511) {\n\t\tcx18_debug = 0;\n\t\tprintk(KERN_INFO \"cx18:   Debug value must be >= 0 and <= 511!\\n\");\n\t}\n\n\tif (pci_register_driver(&cx18_pci_driver)) {\n\t\tprintk(KERN_ERR \"cx18:   Error detecting PCI card\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprintk(KERN_INFO \"cx18:  End initialization\\n\");\n\treturn 0;\n}\n\nstatic void __exit module_cleanup(void)\n{\n\tpci_unregister_driver(&cx18_pci_driver);\n}\n\nmodule_init(module_start);\nmodule_exit(module_cleanup);\nMODULE_FIRMWARE(XC2028_DEFAULT_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}