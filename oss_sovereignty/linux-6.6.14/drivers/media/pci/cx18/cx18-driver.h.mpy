{
  "module_name": "cx18-driver.h",
  "hash_id": "fc81d02f5936e94348bc8553462f1d271217eee68929cd3899a86acc1a9b249a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-driver.h",
  "human_readable_source": " \n \n\n#ifndef CX18_DRIVER_H\n#define CX18_DRIVER_H\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/list.h>\n#include <linux/unistd.h>\n#include <linux/pagemap.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fh.h>\n#include <media/tuner.h>\n#include <media/i2c/ir-kbd-i2c.h>\n#include \"cx18-mailbox.h\"\n#include \"cx18-av-core.h\"\n#include \"cx23418.h\"\n\n \n#include <media/demux.h>\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n#include <media/dvbdev.h>\n\n \n#include <media/videobuf2-vmalloc.h>\n\n#ifndef CONFIG_PCI\n#  error \"This driver requires kernel PCI support.\"\n#endif\n\n#define CX18_MEM_OFFSET\t0x00000000\n#define CX18_MEM_SIZE\t0x04000000\n#define CX18_REG_OFFSET\t0x02000000\n\n \n#define CX18_MAX_CARDS 32\n\n \n#define CX18_CARD_HVR_1600_ESMT\t      0\t \n#define CX18_CARD_HVR_1600_SAMSUNG    1\t \n#define CX18_CARD_COMPRO_H900\t      2\t \n#define CX18_CARD_YUAN_MPC718\t      3\t \n#define CX18_CARD_CNXT_RAPTOR_PAL     4\t \n#define CX18_CARD_TOSHIBA_QOSMIO_DVBT 5  \n#define CX18_CARD_LEADTEK_PVR2100     6  \n#define CX18_CARD_LEADTEK_DVR3100H    7  \n#define CX18_CARD_GOTVIEW_PCI_DVD3    8  \n#define CX18_CARD_HVR_1600_S5H1411    9  \n#define CX18_CARD_LAST\t\t      9\n\n#define CX18_ENC_STREAM_TYPE_MPG  0\n#define CX18_ENC_STREAM_TYPE_TS   1\n#define CX18_ENC_STREAM_TYPE_YUV  2\n#define CX18_ENC_STREAM_TYPE_VBI  3\n#define CX18_ENC_STREAM_TYPE_PCM  4\n#define CX18_ENC_STREAM_TYPE_IDX  5\n#define CX18_ENC_STREAM_TYPE_RAD  6\n#define CX18_MAX_STREAMS\t  7\n\n \n#define PCI_VENDOR_ID_CX      0x14f1\n#define PCI_DEVICE_ID_CX23418 0x5b7a\n\n \n#define CX18_PCI_ID_HAUPPAUGE\t\t0x0070\n#define CX18_PCI_ID_COMPRO\t\t0x185b\n#define CX18_PCI_ID_YUAN\t\t0x12ab\n#define CX18_PCI_ID_CONEXANT\t\t0x14f1\n#define CX18_PCI_ID_TOSHIBA\t\t0x1179\n#define CX18_PCI_ID_LEADTEK\t\t0x107D\n#define CX18_PCI_ID_GOTVIEW\t\t0x5854\n\n \n \n \n\n \n#define CX18_DEFAULT_ENC_TS_BUFFERS  1\n#define CX18_DEFAULT_ENC_MPG_BUFFERS 2\n#define CX18_DEFAULT_ENC_IDX_BUFFERS 1\n#define CX18_DEFAULT_ENC_YUV_BUFFERS 2\n#define CX18_DEFAULT_ENC_VBI_BUFFERS 1\n#define CX18_DEFAULT_ENC_PCM_BUFFERS 1\n\n \n#define CX18_MAX_FW_MDLS_PER_STREAM 63\n\n \n#define CX18_UNIT_ENC_YUV_BUFSIZE\t(720 *  32 * 3 / 2)  \n#define CX18_625_LINE_ENC_YUV_BUFSIZE\t(CX18_UNIT_ENC_YUV_BUFSIZE * 576/32)\n#define CX18_525_LINE_ENC_YUV_BUFSIZE\t(CX18_UNIT_ENC_YUV_BUFSIZE * 480/32)\n\n \nstruct cx18_enc_idx_entry {\n\t__le32 length;\n\t__le32 offset_low;\n\t__le32 offset_high;\n\t__le32 flags;\n\t__le32 pts_low;\n\t__le32 pts_high;\n} __attribute__ ((packed));\n#define CX18_UNIT_ENC_IDX_BUFSIZE \\\n\t(sizeof(struct cx18_enc_idx_entry) * V4L2_ENC_IDX_ENTRIES)\n\n \n#define CX18_DEFAULT_ENC_TS_BUFSIZE   32\n#define CX18_DEFAULT_ENC_MPG_BUFSIZE  32\n#define CX18_DEFAULT_ENC_IDX_BUFSIZE  (CX18_UNIT_ENC_IDX_BUFSIZE * 1 / 1024 + 1)\n#define CX18_DEFAULT_ENC_YUV_BUFSIZE  (CX18_UNIT_ENC_YUV_BUFSIZE * 3 / 1024 + 1)\n#define CX18_DEFAULT_ENC_PCM_BUFSIZE   4\n\n \n#define I2C_CLIENTS_MAX 16\n\n \n\n \n#define CX18_DBGFLG_WARN  (1 << 0)\n#define CX18_DBGFLG_INFO  (1 << 1)\n#define CX18_DBGFLG_API   (1 << 2)\n#define CX18_DBGFLG_DMA   (1 << 3)\n#define CX18_DBGFLG_IOCTL (1 << 4)\n#define CX18_DBGFLG_FILE  (1 << 5)\n#define CX18_DBGFLG_I2C   (1 << 6)\n#define CX18_DBGFLG_IRQ   (1 << 7)\n \n#define CX18_DBGFLG_HIGHVOL (1 << 8)\n\n \n#define CX18_DEBUG(x, type, fmt, args...) \\\n\tdo { \\\n\t\tif ((x) & cx18_debug) \\\n\t\t\tv4l2_info(&cx->v4l2_dev, \" \" type \": \" fmt , ## args); \\\n\t} while (0)\n#define CX18_DEBUG_WARN(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_WARN, \"warning\", fmt , ## args)\n#define CX18_DEBUG_INFO(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_INFO, \"info\", fmt , ## args)\n#define CX18_DEBUG_API(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_API, \"api\", fmt , ## args)\n#define CX18_DEBUG_DMA(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_DMA, \"dma\", fmt , ## args)\n#define CX18_DEBUG_IOCTL(fmt, args...) CX18_DEBUG(CX18_DBGFLG_IOCTL, \"ioctl\", fmt , ## args)\n#define CX18_DEBUG_FILE(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_FILE, \"file\", fmt , ## args)\n#define CX18_DEBUG_I2C(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_I2C, \"i2c\", fmt , ## args)\n#define CX18_DEBUG_IRQ(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_IRQ, \"irq\", fmt , ## args)\n\n#define CX18_DEBUG_HIGH_VOL(x, type, fmt, args...) \\\n\tdo { \\\n\t\tif (((x) & cx18_debug) && (cx18_debug & CX18_DBGFLG_HIGHVOL)) \\\n\t\t\tv4l2_info(&cx->v4l2_dev, \" \" type \": \" fmt , ## args); \\\n\t} while (0)\n#define CX18_DEBUG_HI_WARN(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_WARN, \"warning\", fmt , ## args)\n#define CX18_DEBUG_HI_INFO(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_INFO, \"info\", fmt , ## args)\n#define CX18_DEBUG_HI_API(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_API, \"api\", fmt , ## args)\n#define CX18_DEBUG_HI_DMA(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_DMA, \"dma\", fmt , ## args)\n#define CX18_DEBUG_HI_IOCTL(fmt, args...) CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_IOCTL, \"ioctl\", fmt , ## args)\n#define CX18_DEBUG_HI_FILE(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_FILE, \"file\", fmt , ## args)\n#define CX18_DEBUG_HI_I2C(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_I2C, \"i2c\", fmt , ## args)\n#define CX18_DEBUG_HI_IRQ(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_IRQ, \"irq\", fmt , ## args)\n\n \n#define CX18_ERR(fmt, args...)      v4l2_err(&cx->v4l2_dev, fmt , ## args)\n#define CX18_WARN(fmt, args...)     v4l2_warn(&cx->v4l2_dev, fmt , ## args)\n#define CX18_INFO(fmt, args...)     v4l2_info(&cx->v4l2_dev, fmt , ## args)\n\n \n#define CX18_DEBUG_DEV(x, dev, type, fmt, args...) \\\n\tdo { \\\n\t\tif ((x) & cx18_debug) \\\n\t\t\tv4l2_info(dev, \" \" type \": \" fmt , ## args); \\\n\t} while (0)\n#define CX18_DEBUG_WARN_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_WARN, dev, \"warning\", fmt , ## args)\n#define CX18_DEBUG_INFO_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_INFO, dev, \"info\", fmt , ## args)\n#define CX18_DEBUG_API_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_API, dev, \"api\", fmt , ## args)\n#define CX18_DEBUG_DMA_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_DMA, dev, \"dma\", fmt , ## args)\n#define CX18_DEBUG_IOCTL_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_IOCTL, dev, \"ioctl\", fmt , ## args)\n#define CX18_DEBUG_FILE_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_FILE, dev, \"file\", fmt , ## args)\n#define CX18_DEBUG_I2C_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_I2C, dev, \"i2c\", fmt , ## args)\n#define CX18_DEBUG_IRQ_DEV(dev, fmt, args...) \\\n\t\tCX18_DEBUG_DEV(CX18_DBGFLG_IRQ, dev, \"irq\", fmt , ## args)\n\n#define CX18_DEBUG_HIGH_VOL_DEV(x, dev, type, fmt, args...) \\\n\tdo { \\\n\t\tif (((x) & cx18_debug) && (cx18_debug & CX18_DBGFLG_HIGHVOL)) \\\n\t\t\tv4l2_info(dev, \" \" type \": \" fmt , ## args); \\\n\t} while (0)\n#define CX18_DEBUG_HI_WARN_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_WARN, dev, \"warning\", fmt , ## args)\n#define CX18_DEBUG_HI_INFO_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_INFO, dev, \"info\", fmt , ## args)\n#define CX18_DEBUG_HI_API_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_API, dev, \"api\", fmt , ## args)\n#define CX18_DEBUG_HI_DMA_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_DMA, dev, \"dma\", fmt , ## args)\n#define CX18_DEBUG_HI_IOCTL_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_IOCTL, dev, \"ioctl\", fmt , ## args)\n#define CX18_DEBUG_HI_FILE_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_FILE, dev, \"file\", fmt , ## args)\n#define CX18_DEBUG_HI_I2C_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_I2C, dev, \"i2c\", fmt , ## args)\n#define CX18_DEBUG_HI_IRQ_DEV(dev, fmt, args...) \\\n\tCX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_IRQ, dev, \"irq\", fmt , ## args)\n\n#define CX18_ERR_DEV(dev, fmt, args...)      v4l2_err(dev, fmt , ## args)\n#define CX18_WARN_DEV(dev, fmt, args...)     v4l2_warn(dev, fmt , ## args)\n#define CX18_INFO_DEV(dev, fmt, args...)     v4l2_info(dev, fmt , ## args)\n\nextern int cx18_debug;\n\nstruct cx18_options {\n\tint megabytes[CX18_MAX_STREAMS];  \n\tint cardtype;\t\t \n\tint tuner;\t\t \n\tint radio;\t\t \n};\n\n \n#define CX18_F_M_NEED_SWAP  0\t \n\n \n#define CX18_F_S_CLAIMED\t3\t \n#define CX18_F_S_STREAMING      4\t \n#define CX18_F_S_INTERNAL_USE\t5\t \n#define CX18_F_S_STREAMOFF\t7\t \n#define CX18_F_S_APPL_IO        8\t \n#define CX18_F_S_STOPPING\t9\t \n\n \n#define CX18_F_I_LOADED_FW\t\t0\t \n#define CX18_F_I_EOS\t\t\t4\t \n#define CX18_F_I_RADIO_USER\t\t5\t \n#define CX18_F_I_ENC_PAUSED\t\t13\t \n#define CX18_F_I_INITED\t\t\t21\t \n#define CX18_F_I_FAILED\t\t\t22\t \n\n \n#define CX18_SLICED_TYPE_TELETEXT_B     (1)\n#define CX18_SLICED_TYPE_CAPTION_525    (4)\n#define CX18_SLICED_TYPE_WSS_625        (5)\n#define CX18_SLICED_TYPE_VPS            (7)\n\n \n#define list_entry_is_past_end(pos, head, member) \\\n\t(&pos->member == (head))\n\nstruct cx18_vb2_buffer {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n\tv4l2_std_id tvnorm;  \n\tu32 bytes_used;\n};\n\nstruct cx18_buffer {\n\tstruct list_head list;\n\tdma_addr_t dma_handle;\n\tchar *buf;\n\n\tu32 bytesused;\n\tu32 readpos;\n};\n\nstruct cx18_mdl {\n\tstruct list_head list;\n\tu32 id;\t\t \n\n\tunsigned int skipped;\n\tunsigned long m_flags;\n\n\tstruct list_head buf_list;\n\tstruct cx18_buffer *curr_buf;  \n\n\tu32 bytesused;\n\tu32 readpos;\n};\n\nstruct cx18_queue {\n\tstruct list_head list;\n\tatomic_t depth;\n\tu32 bytesused;\n\tspinlock_t lock;\n};\n\nstruct cx18_stream;  \n\nstruct cx18_dvb {\n\tstruct cx18_stream *stream;\n\tstruct dmx_frontend hw_frontend;\n\tstruct dmx_frontend mem_frontend;\n\tstruct dmxdev dmxdev;\n\tstruct dvb_adapter dvb_adapter;\n\tstruct dvb_demux demux;\n\tstruct dvb_frontend *fe;\n\tstruct dvb_net dvbnet;\n\tint enabled;\n\tint feeding;\n\tstruct mutex feedlock;\n};\n\nstruct cx18;\t  \nstruct cx18_scb;  \n\n\n#define CX18_MAX_MDL_ACKS 2\n#define CX18_MAX_IN_WORK_ORDERS (CX18_MAX_FW_MDLS_PER_STREAM + 7)\n \n\n#define CX18_F_EWO_MB_STALE_UPON_RECEIPT 0x1\n#define CX18_F_EWO_MB_STALE_WHILE_PROC   0x2\n#define CX18_F_EWO_MB_STALE \\\n\t     (CX18_F_EWO_MB_STALE_UPON_RECEIPT | CX18_F_EWO_MB_STALE_WHILE_PROC)\n\nstruct cx18_in_work_order {\n\tstruct work_struct work;\n\tatomic_t pending;\n\tstruct cx18 *cx;\n\tunsigned long flags;\n\tint rpu;\n\tstruct cx18_mailbox mb;\n\tstruct cx18_mdl_ack mdl_ack[CX18_MAX_MDL_ACKS];\n\tchar *str;\n};\n\n#define CX18_INVALID_TASK_HANDLE 0xffffffff\n\nstruct cx18_stream {\n\t \n\tstruct video_device video_dev;\t \n\tstruct cx18_dvb *dvb;\t\t \n\tstruct cx18 *cx;\t\t \n\tconst char *name;\t\t \n\tint type;\t\t\t \n\tu32 handle;\t\t\t \n\tu32 v4l2_dev_caps;\t\t \n\tunsigned int mdl_base_idx;\n\n\tu32 id;\n\tunsigned long s_flags;\t \n\tint dma;\t\t \n\twait_queue_head_t waitq;\n\n\t \n\tstruct list_head buf_pool;\t \n\tu32 buffers;\t\t\t \n\tu32 buf_size;\t\t\t \n\n\t \n\tu32 bufs_per_mdl;\n\tu32 mdl_size;\t\t \n\n\t \n\tstruct cx18_queue q_free;\t \n\tstruct cx18_queue q_busy;\t \n\tstruct cx18_queue q_full;\t \n\tstruct cx18_queue q_idle;\t \n\n\tstruct work_struct out_work_order;\n\n\t \n\tu32 pixelformat;\n\tu32 vb_bytes_per_frame;\n\tu32 vb_bytes_per_line;\n\tstruct list_head vb_capture;     \n\tspinlock_t vb_lock;\n\tstruct timer_list vb_timeout;\n\tu32 sequence;\n\n\tstruct vb2_queue vidq;\n\tenum v4l2_buf_type vb_type;\n};\n\nstruct cx18_open_id {\n\tstruct v4l2_fh fh;\n\tu32 open_id;\n\tint type;\n\tstruct cx18 *cx;\n};\n\nstatic inline struct cx18_open_id *fh2id(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct cx18_open_id, fh);\n}\n\nstatic inline struct cx18_open_id *file2id(struct file *file)\n{\n\treturn fh2id(file->private_data);\n}\n\n \nstruct cx18_card;\n\n \n\n \n#define VBI_ACTIVE_SAMPLES\t1444  \n#define VBI_HBLANK_SAMPLES_60HZ\t272  \n#define VBI_HBLANK_SAMPLES_50HZ\t284  \n\n#define CX18_VBI_FRAMES 32\n\nstruct vbi_info {\n\t \n\tstruct v4l2_format in;\n\tstruct v4l2_sliced_vbi_format *sliced_in;  \n\tu32 count;     \n\tu32 start[2];  \n\n\tu32 frame;  \n\n\t \n\n\t \n\tint insert_mpeg;\n\n\t \n\tstruct v4l2_sliced_vbi_data sliced_data[36];\n\n\t \n#define CX18_SLICED_MPEG_DATA_MAXSZ\t1584\n\t \n#define CX18_SLICED_MPEG_DATA_BUFSZ\t(CX18_SLICED_MPEG_DATA_MAXSZ+8)\n\tu8 *sliced_mpeg_data[CX18_VBI_FRAMES];\n\tu32 sliced_mpeg_size[CX18_VBI_FRAMES];\n\n\t \n\tu32 inserted_frame;\n\n\t \n\tstruct cx18_mdl sliced_mpeg_mdl;\n\tstruct cx18_buffer sliced_mpeg_buf;\n};\n\n \nstruct cx18_i2c_algo_callback_data {\n\tstruct cx18 *cx;\n\tint bus_index;    \n};\n\n#define CX18_MAX_MMIO_WR_RETRIES 10\n\n \nstruct cx18 {\n\tint instance;\n\tstruct pci_dev *pci_dev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_subdev *sd_av;      \n\tstruct v4l2_subdev *sd_extmux;  \n\n\tconst struct cx18_card *card;\t \n\tconst char *card_name;   \n\tconst struct cx18_card_tuner_i2c *card_i2c;  \n\tu8 is_50hz;\n\tu8 is_60hz;\n\tu8 nof_inputs;\t\t \n\tu8 nof_audio_inputs;\t \n\tu32 v4l2_cap;\t\t \n\tu32 hw_flags;\t\t \n\tunsigned int free_mdl_idx;\n\tstruct cx18_scb __iomem *scb;  \n\tstruct mutex epu2apu_mb_lock;  \n\tstruct mutex epu2cpu_mb_lock;  \n\n\tstruct cx18_av_state av_state;\n\n\t \n\tstruct cx2341x_handler cxhdl;\n\tu32 filter_mode;\n\tu32 temporal_strength;\n\tu32 spatial_strength;\n\n\t \n\tunsigned long dualwatch_jiffies;\n\tu32 dualwatch_stereo_mode;\n\n\tstruct mutex serialize_lock;     \n\tstruct cx18_options options;\t \n\tint stream_buffers[CX18_MAX_STREAMS];  \n\tint stream_buf_size[CX18_MAX_STREAMS];  \n\tstruct cx18_stream streams[CX18_MAX_STREAMS];\t \n\tstruct snd_cx18_card *alsa;  \n\tvoid (*pcm_announce_callback)(struct snd_cx18_card *card, u8 *pcm_data,\n\t\t\t\t      size_t num_bytes);\n\n\tunsigned long i_flags;   \n\tatomic_t ana_capturing;\t \n\tatomic_t tot_capturing;\t \n\tint search_pack_header;\n\n\tint open_id;\t\t \n\n\tresource_size_t base_addr;\n\n\tu8 card_rev;\n\tvoid __iomem *enc_mem, *reg_mem;\n\n\tstruct vbi_info vbi;\n\n\tu64 mpg_data_received;\n\tu64 vbi_data_inserted;\n\n\twait_queue_head_t mb_apu_waitq;\n\twait_queue_head_t mb_cpu_waitq;\n\twait_queue_head_t cap_w;\n\t \n\twait_queue_head_t dma_waitq;\n\n\tu32 sw1_irq_mask;\n\tu32 sw2_irq_mask;\n\tu32 hw2_irq_mask;\n\n\tstruct workqueue_struct *in_work_queue;\n\tchar in_workq_name[11];  \n\tstruct cx18_in_work_order in_work_order[CX18_MAX_IN_WORK_ORDERS];\n\tchar epu_debug_str[256];  \n\n\t \n\tstruct i2c_adapter i2c_adap[2];\n\tstruct i2c_algo_bit_data i2c_algo[2];\n\tstruct cx18_i2c_algo_callback_data i2c_algo_cb_data[2];\n\n\tstruct IR_i2c_init_data ir_i2c_init_data;\n\n\t \n\tu32 gpio_dir;\n\tu32 gpio_val;\n\tstruct mutex gpio_lock;\n\tstruct v4l2_subdev sd_gpiomux;\n\tstruct v4l2_subdev sd_resetctrl;\n\n\t \n\n\t \n\tu32 audio_input;\n\tu32 active_input;\n\tv4l2_std_id std;\n\tv4l2_std_id tuner_std;\t \n\n\t \n\tstruct work_struct request_module_wk;\n};\n\nstatic inline struct cx18 *to_cx18(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct cx18, v4l2_dev);\n}\n\n \nextern int (*cx18_ext_init)(struct cx18 *);\n\n \nextern int cx18_first_minor;\n\n \n\n \nint cx18_msleep_timeout(unsigned int msecs, int intr);\n\n \nstruct tveeprom;  \nvoid cx18_read_eeprom(struct cx18 *cx, struct tveeprom *tv);\n\n \nint cx18_init_on_first_open(struct cx18 *cx);\n\n \nstatic inline int cx18_raw_vbi(const struct cx18 *cx)\n{\n\treturn cx->vbi.in.type == V4L2_BUF_TYPE_VBI_CAPTURE;\n}\n\n \n#define cx18_call_hw(cx, hw, o, f, args...)\t\t\t\t\\\n\tv4l2_device_mask_call_all(&(cx)->v4l2_dev, hw, o, f, ##args)\n\n#define cx18_call_all(cx, o, f, args...) cx18_call_hw(cx, 0, o, f , ##args)\n\n \n#define cx18_call_hw_err(cx, hw, o, f, args...)\t\t\t\t\\\n\tv4l2_device_mask_call_until_err(&(cx)->v4l2_dev, hw, o, f, ##args)\n\n#define cx18_call_all_err(cx, o, f, args...) \\\n\tcx18_call_hw_err(cx, 0, o, f , ##args)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}