{
  "module_name": "cx18-av-core.c",
  "hash_id": "a82398a4f0c56de935c86425809a2ccd24a7bba9183f8461d0346063c7759e74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-av-core.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-cards.h\"\n\nint cx18_av_write(struct cx18 *cx, u16 addr, u8 value)\n{\n\tu32 reg = 0xc40000 + (addr & ~3);\n\tu32 mask = 0xff;\n\tint shift = (addr & 3) * 8;\n\tu32 x = cx18_read_reg(cx, reg);\n\n\tx = (x & ~(mask << shift)) | ((u32)value << shift);\n\tcx18_write_reg(cx, x, reg);\n\treturn 0;\n}\n\nint cx18_av_write_expect(struct cx18 *cx, u16 addr, u8 value, u8 eval, u8 mask)\n{\n\tu32 reg = 0xc40000 + (addr & ~3);\n\tint shift = (addr & 3) * 8;\n\tu32 x = cx18_read_reg(cx, reg);\n\n\tx = (x & ~((u32)0xff << shift)) | ((u32)value << shift);\n\tcx18_write_reg_expect(cx, x, reg,\n\t\t\t\t((u32)eval << shift), ((u32)mask << shift));\n\treturn 0;\n}\n\nint cx18_av_write4(struct cx18 *cx, u16 addr, u32 value)\n{\n\tcx18_write_reg(cx, value, 0xc40000 + addr);\n\treturn 0;\n}\n\nint\ncx18_av_write4_expect(struct cx18 *cx, u16 addr, u32 value, u32 eval, u32 mask)\n{\n\tcx18_write_reg_expect(cx, value, 0xc40000 + addr, eval, mask);\n\treturn 0;\n}\n\nint cx18_av_write4_noretry(struct cx18 *cx, u16 addr, u32 value)\n{\n\tcx18_write_reg_noretry(cx, value, 0xc40000 + addr);\n\treturn 0;\n}\n\nu8 cx18_av_read(struct cx18 *cx, u16 addr)\n{\n\tu32 x = cx18_read_reg(cx, 0xc40000 + (addr & ~3));\n\tint shift = (addr & 3) * 8;\n\n\treturn (x >> shift) & 0xff;\n}\n\nu32 cx18_av_read4(struct cx18 *cx, u16 addr)\n{\n\treturn cx18_read_reg(cx, 0xc40000 + addr);\n}\n\nint cx18_av_and_or(struct cx18 *cx, u16 addr, unsigned and_mask,\n\t\t   u8 or_value)\n{\n\treturn cx18_av_write(cx, addr,\n\t\t\t     (cx18_av_read(cx, addr) & and_mask) |\n\t\t\t     or_value);\n}\n\nint cx18_av_and_or4(struct cx18 *cx, u16 addr, u32 and_mask,\n\t\t   u32 or_value)\n{\n\treturn cx18_av_write4(cx, addr,\n\t\t\t     (cx18_av_read4(cx, addr) & and_mask) |\n\t\t\t     or_value);\n}\n\nstatic void cx18_av_init(struct cx18 *cx)\n{\n\t \n\n\t \n\tcx18_av_write4(cx, CXADEC_PLL_CTRL1, 0x160e040f);\n\n\t \n\t \n\tcx18_av_write4(cx, CXADEC_VID_PLL_FRAC, 0x002be2fe);\n\n\t \n\t \n\tcx18_av_write4(cx, CXADEC_AUX_PLL_FRAC, 0x005227ad);\n\n\t \n\tcx18_av_write(cx, CXADEC_I2S_MCLK, 0x56);\n}\n\nstatic void cx18_av_initialize(struct v4l2_subdev *sd)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tint default_volume;\n\tu32 v;\n\n\tcx18_av_loadfw(cx);\n\t \n\tcx18_av_write4_expect(cx, CXADEC_DL_CTL, 0x03000000,\n\t\t\t\t\t\t 0x03000000, 0x13000000);\n\n\t \n\tv = cx18_av_read4(cx, CXADEC_HOST_REG1);\n\t \n\tcx18_av_write4_expect(cx, CXADEC_HOST_REG1, v | 1, v, 0xfffe);\n\t \n\tcx18_av_write4_expect(cx, CXADEC_HOST_REG1, v & 0xfffe,\n\t\t\t\t\t\t    v & 0xfffe, 0xffff);\n\n\t \n\tv = cx18_av_read4(cx, CXADEC_DLL1_DIAG_CTRL) & 0xE1FFFEFF;\n\t \n\tcx18_av_write4(cx, CXADEC_DLL1_DIAG_CTRL, v);\n\t \n\tcx18_av_write4(cx, CXADEC_DLL1_DIAG_CTRL, v | 0x10000100);\n\n\tv = cx18_av_read4(cx, CXADEC_DLL2_DIAG_CTRL) & 0xE1FFFEFF;\n\t \n\tcx18_av_write4(cx, CXADEC_DLL2_DIAG_CTRL, v);\n\t \n\tcx18_av_write4(cx, CXADEC_DLL2_DIAG_CTRL, v | 0x06000100);\n\n\t \n\tcx18_av_write4(cx, CXADEC_AFE_DIAG_CTRL1, 0x000A1802);\n\n\tv = cx18_av_read4(cx, CXADEC_AFE_DIAG_CTRL3) | 1;\n\t \n\tcx18_av_write4_expect(cx, CXADEC_AFE_DIAG_CTRL3, v, v, 0x03009F0F);\n\t \n\tcx18_av_write4_expect(cx, CXADEC_AFE_DIAG_CTRL3,\n\t\t\t      v & 0xFFFFFFFE, v & 0xFFFFFFFE, 0x03009F0F);\n\n\t \n\tcx18_av_and_or4(cx, CXADEC_PIN_CTRL1, ~0, 0x040C00);\n\n\t \n\tcx18_av_and_or4(cx, CXADEC_PIN_CTRL2, ~0, 0x2);\n\n\t \n\tcx18_av_write4(cx, CXADEC_SOFT_RST_CTRL, 0x8000);\n\tcx18_av_write4(cx, CXADEC_SOFT_RST_CTRL, 0);\n\n\t \n\tcx18_av_and_or4(cx, CXADEC_CHIP_CTRL, 0xFFFBFFFF, 0x00120000);\n\n\t \n\tcx18_av_init(cx);\n\n\t \n\t \n\t \n\tcx18_av_and_or4(cx, CXADEC_MODE_CTRL, 0xFFF7E7F0, 0x02040800);\n\n\t \n\t \n\tcx18_av_and_or4(cx, CXADEC_CRUSH_CTRL, ~0, 0x00500000);\n\n\t \n\tcx18_av_and_or4(cx, CXADEC_DFE_CTRL2, 0xFFFF00FF, 0x00002000);\n\n\t \n\tcx18_av_write4(cx, CXADEC_OUT_CTRL1, 0x4013252e);\n\n\t \n\t \n\t \n\n\t \n\tcx18_av_and_or4(cx, CXADEC_AFE_CTRL, 0xFF000000, 0x00005D00);\n\n \n \n \n \n \n\tcx18_av_write4(cx, CXADEC_SRC_COMB_CFG, 0x6628021F);\n\tdefault_volume = cx18_av_read(cx, 0x8d4);\n\t \n\tif (default_volume > 228) {\n\t\t \n\t\tdefault_volume = 228;\n\t\tcx18_av_write(cx, 0x8d4, 228);\n\t} else if (default_volume < 20) {\n\t\t \n\t\tdefault_volume = 20;\n\t\tcx18_av_write(cx, 0x8d4, 20);\n\t}\n\tdefault_volume = (((228 - default_volume) >> 1) + 23) << 9;\n\tstate->volume->cur.val = state->volume->default_value = default_volume;\n\tv4l2_ctrl_handler_setup(&state->hdl);\n}\n\nstatic int cx18_av_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tcx18_av_initialize(sd);\n\treturn 0;\n}\n\nstatic int cx18_av_load_fw(struct v4l2_subdev *sd)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\n\tif (!state->is_initialized) {\n\t\t \n\t\tstate->is_initialized = 1;\n\t\tcx18_av_initialize(sd);\n\t}\n\treturn 0;\n}\n\nvoid cx18_av_std_setup(struct cx18 *cx)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tv4l2_std_id std = state->std;\n\n\t \n\tconst int src_decimation = 0x21f;\n\n\tint hblank, hactive, burst, vblank, vactive, sc;\n\tint vblank656;\n\tint luma_lpf, uv_lpf, comb;\n\tu32 pll_int, pll_frac, pll_post;\n\n\t \n\tif (std & ~V4L2_STD_NTSC)\n\t\tcx18_av_write(cx, 0x49f, 0x11);\n\telse\n\t\tcx18_av_write(cx, 0x49f, 0x14);\n\n\t \n\tif (std & V4L2_STD_625_50) {\n\t\t \n\t\tvblank656 = 48;  \n\t\tvblank = 38;     \n\t\tvactive = 579;   \n\n\t\t \n\t\thblank = 132;\n\t\thactive = 720;\n\n\t\t \n\t\tburst = 93;\n\t\tluma_lpf = 2;\n\t\tif (std & V4L2_STD_PAL) {\n\t\t\tuv_lpf = 1;\n\t\t\tcomb = 0x20;\n\t\t\t \n\t\t\tsc = 688700;\n\t\t} else if (std == V4L2_STD_PAL_Nc) {\n\t\t\tuv_lpf = 1;\n\t\t\tcomb = 0x20;\n\t\t\t \n\t\t\tsc = 556422;\n\t\t} else {  \n\t\t\tuv_lpf = 0;\n\t\t\tcomb = 0;\n\t\t\t \n\t\t\t \n\t\t\tsc = 672314;\n\t\t}\n\t} else {\n\t\t \n\t\tvblank656 = 38;  \n\t\tvblank = 26;\t \n\t\tvactive = 481;   \n\n\t\t \n\t\thactive = 720;\n\t\thblank = 122;\n\t\tluma_lpf = 1;\n\t\tuv_lpf = 1;\n\n\t\t \n\t\tif (std == V4L2_STD_PAL_60) {\n\t\t\tburst = 90;\n\t\t\tluma_lpf = 2;\n\t\t\tcomb = 0x20;\n\t\t\t \n\t\t\tsc = 688700;\n\t\t} else if (std == V4L2_STD_PAL_M) {\n\t\t\t \n\t\t\tburst = 97;\n\t\t\tcomb = 0x20;\n\t\t\t \n\t\t\tsc = 555421;\n\t\t} else {\n\t\t\tburst = 90;\n\t\t\tcomb = 0x66;\n\t\t\t \n\t\t\tsc = 556032;\n\t\t}\n\t}\n\n\t \n\tpll_int = cx18_av_read(cx, 0x108);\n\tpll_frac = cx18_av_read4(cx, 0x10c) & 0x1ffffff;\n\tpll_post = cx18_av_read(cx, 0x109);\n\tCX18_DEBUG_INFO_DEV(sd, \"PLL regs = int: %u, frac: %u, post: %u\\n\",\n\t\t\t    pll_int, pll_frac, pll_post);\n\n\tif (pll_post) {\n\t\tint fsc, pll;\n\t\tu64 tmp;\n\n\t\tpll = (28636360L * ((((u64)pll_int) << 25) + pll_frac)) >> 25;\n\t\tpll /= pll_post;\n\t\tCX18_DEBUG_INFO_DEV(sd, \"Video PLL = %d.%06d MHz\\n\",\n\t\t\t\t    pll / 1000000, pll % 1000000);\n\t\tCX18_DEBUG_INFO_DEV(sd, \"Pixel rate = %d.%06d Mpixel/sec\\n\",\n\t\t\t\t    pll / 8000000, (pll / 8) % 1000000);\n\n\t\tCX18_DEBUG_INFO_DEV(sd, \"ADC XTAL/pixel clock decimation ratio = %d.%03d\\n\",\n\t\t\t\t    src_decimation / 256,\n\t\t\t\t    ((src_decimation % 256) * 1000) / 256);\n\n\t\ttmp = 28636360 * (u64) sc;\n\t\tdo_div(tmp, src_decimation);\n\t\tfsc = tmp >> 13;\n\t\tCX18_DEBUG_INFO_DEV(sd,\n\t\t\t\t    \"Chroma sub-carrier initial freq = %d.%06d MHz\\n\",\n\t\t\t\t    fsc / 1000000, fsc % 1000000);\n\n\t\tCX18_DEBUG_INFO_DEV(sd,\n\t\t\t\t    \"hblank %i, hactive %i, vblank %i, vactive %i, vblank656 %i, src_dec %i, burst 0x%02x, luma_lpf %i, uv_lpf %i, comb 0x%02x, sc 0x%06x\\n\",\n\t\t\t\t    hblank, hactive, vblank, vactive, vblank656,\n\t\t\t\t    src_decimation, burst, luma_lpf, uv_lpf,\n\t\t\t\t    comb, sc);\n\t}\n\n\t \n\tcx18_av_write(cx, 0x470, hblank);\n\tcx18_av_write(cx, 0x471,\n\t\t      (((hblank >> 8) & 0x3) | (hactive << 4)) & 0xff);\n\tcx18_av_write(cx, 0x472, hactive >> 4);\n\n\t \n\tcx18_av_write(cx, 0x473, burst);\n\n\t \n\tcx18_av_write(cx, 0x474, vblank);\n\tcx18_av_write(cx, 0x475,\n\t\t      (((vblank >> 8) & 0x3) | (vactive << 4)) & 0xff);\n\tcx18_av_write(cx, 0x476, vactive >> 4);\n\tcx18_av_write(cx, 0x477, vblank656);\n\n\t \n\tcx18_av_write(cx, 0x478, src_decimation & 0xff);\n\tcx18_av_write(cx, 0x479, (src_decimation >> 8) & 0xff);\n\n\t \n\tcx18_av_write(cx, 0x47a, luma_lpf << 6 | ((uv_lpf << 4) & 0x30));\n\n\t \n\tcx18_av_write(cx, 0x47b, comb);\n\n\t \n\tcx18_av_write(cx, 0x47c, sc);\n\tcx18_av_write(cx, 0x47d, (sc >> 8) & 0xff);\n\tcx18_av_write(cx, 0x47e, (sc >> 16) & 0xff);\n\n\tif (std & V4L2_STD_625_50) {\n\t\tstate->slicer_line_delay = 1;\n\t\tstate->slicer_line_offset = (6 + state->slicer_line_delay - 2);\n\t} else {\n\t\tstate->slicer_line_delay = 0;\n\t\tstate->slicer_line_offset = (10 + state->slicer_line_delay - 2);\n\t}\n\tcx18_av_write(cx, 0x47f, state->slicer_line_delay);\n}\n\nstatic void input_change(struct cx18 *cx)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tv4l2_std_id std = state->std;\n\tu8 v;\n\n\t \n\tcx18_av_write(cx, 0x49f, (std & V4L2_STD_NTSC) ? 0x14 : 0x11);\n\tcx18_av_and_or(cx, 0x401, ~0x60, 0);\n\tcx18_av_and_or(cx, 0x401, ~0x60, 0x60);\n\n\tif (std & V4L2_STD_525_60) {\n\t\tif (std == V4L2_STD_NTSC_M_JP) {\n\t\t\t \n\t\t\tcx18_av_write_expect(cx, 0x808, 0xf7, 0xf7, 0xff);\n\t\t\tcx18_av_write_expect(cx, 0x80b, 0x02, 0x02, 0x3f);\n\t\t} else if (std == V4L2_STD_NTSC_M_KR) {\n\t\t\t \n\t\t\tcx18_av_write_expect(cx, 0x808, 0xf8, 0xf8, 0xff);\n\t\t\tcx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\n\t\t} else {\n\t\t\t \n\t\t\tcx18_av_write_expect(cx, 0x808, 0xf6, 0xf6, 0xff);\n\t\t\tcx18_av_write_expect(cx, 0x80b, 0x01, 0x01, 0x3f);\n\t\t}\n\t} else if (std & V4L2_STD_PAL) {\n\t\t \n\t\tcx18_av_write_expect(cx, 0x808, 0xff, 0xff, 0xff);\n\t\tcx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\n\t} else if (std & V4L2_STD_SECAM) {\n\t\t \n\t\tcx18_av_write_expect(cx, 0x808, 0xff, 0xff, 0xff);\n\t\tcx18_av_write_expect(cx, 0x80b, 0x03, 0x03, 0x3f);\n\t}\n\n\tv = cx18_av_read(cx, 0x803);\n\tif (v & 0x10) {\n\t\t \n\t\tv &= ~0x10;\n\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t\tv |= 0x10;\n\t\tcx18_av_write_expect(cx, 0x803, v, v, 0x1f);\n\t}\n}\n\nstatic int cx18_av_s_frequency(struct v4l2_subdev *sd,\n\t\t\t       const struct v4l2_frequency *freq)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tinput_change(cx);\n\treturn 0;\n}\n\nstatic int set_input(struct cx18 *cx, enum cx18_av_video_input vid_input,\n\t\t\t\t\tenum cx18_av_audio_input aud_input)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tenum analog_signal_type {\n\t\tNONE, CVBS, Y, C, SIF, Pb, Pr\n\t} ch[3] = {NONE, NONE, NONE};\n\n\tu8 afe_mux_cfg;\n\tu8 adc2_cfg;\n\tu8 input_mode;\n\tu32 afe_cfg;\n\tint i;\n\n\tCX18_DEBUG_INFO_DEV(sd, \"decoder set video input %d, audio input %d\\n\",\n\t\t\t    vid_input, aud_input);\n\n\tif (vid_input >= CX18_AV_COMPOSITE1 &&\n\t    vid_input <= CX18_AV_COMPOSITE8) {\n\t\tafe_mux_cfg = 0xf0 + (vid_input - CX18_AV_COMPOSITE1);\n\t\tch[0] = CVBS;\n\t\tinput_mode = 0x0;\n\t} else if (vid_input >= CX18_AV_COMPONENT_LUMA1) {\n\t\tint luma = vid_input & 0xf000;\n\t\tint r_chroma = vid_input & 0xf0000;\n\t\tint b_chroma = vid_input & 0xf00000;\n\n\t\tif ((vid_input & ~0xfff000) ||\n\t\t    luma < CX18_AV_COMPONENT_LUMA1 ||\n\t\t    luma > CX18_AV_COMPONENT_LUMA8 ||\n\t\t    r_chroma < CX18_AV_COMPONENT_R_CHROMA4 ||\n\t\t    r_chroma > CX18_AV_COMPONENT_R_CHROMA6 ||\n\t\t    b_chroma < CX18_AV_COMPONENT_B_CHROMA7 ||\n\t\t    b_chroma > CX18_AV_COMPONENT_B_CHROMA8) {\n\t\t\tCX18_ERR_DEV(sd, \"0x%06x is not a valid video input!\\n\",\n\t\t\t\t     vid_input);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tafe_mux_cfg = (luma - CX18_AV_COMPONENT_LUMA1) >> 12;\n\t\tch[0] = Y;\n\t\tafe_mux_cfg |= (r_chroma - CX18_AV_COMPONENT_R_CHROMA4) >> 12;\n\t\tch[1] = Pr;\n\t\tafe_mux_cfg |= (b_chroma - CX18_AV_COMPONENT_B_CHROMA7) >> 14;\n\t\tch[2] = Pb;\n\t\tinput_mode = 0x6;\n\t} else {\n\t\tint luma = vid_input & 0xf0;\n\t\tint chroma = vid_input & 0xf00;\n\n\t\tif ((vid_input & ~0xff0) ||\n\t\t    luma < CX18_AV_SVIDEO_LUMA1 ||\n\t\t    luma > CX18_AV_SVIDEO_LUMA8 ||\n\t\t    chroma < CX18_AV_SVIDEO_CHROMA4 ||\n\t\t    chroma > CX18_AV_SVIDEO_CHROMA8) {\n\t\t\tCX18_ERR_DEV(sd, \"0x%06x is not a valid video input!\\n\",\n\t\t\t\t     vid_input);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tafe_mux_cfg = 0xf0 + ((luma - CX18_AV_SVIDEO_LUMA1) >> 4);\n\t\tch[0] = Y;\n\t\tif (chroma >= CX18_AV_SVIDEO_CHROMA7) {\n\t\t\tafe_mux_cfg &= 0x3f;\n\t\t\tafe_mux_cfg |= (chroma - CX18_AV_SVIDEO_CHROMA7) >> 2;\n\t\t\tch[2] = C;\n\t\t} else {\n\t\t\tafe_mux_cfg &= 0xcf;\n\t\t\tafe_mux_cfg |= (chroma - CX18_AV_SVIDEO_CHROMA4) >> 4;\n\t\t\tch[1] = C;\n\t\t}\n\t\tinput_mode = 0x2;\n\t}\n\n\tswitch (aud_input) {\n\tcase CX18_AV_AUDIO_SERIAL1:\n\tcase CX18_AV_AUDIO_SERIAL2:\n\t\t \n\t\tbreak;\n\tcase CX18_AV_AUDIO4:\n\t\tafe_mux_cfg &= ~0x30;\n\t\tch[1] = SIF;\n\t\tbreak;\n\tcase CX18_AV_AUDIO5:\n\t\tafe_mux_cfg = (afe_mux_cfg & ~0x30) | 0x10;\n\t\tch[1] = SIF;\n\t\tbreak;\n\tcase CX18_AV_AUDIO6:\n\t\tafe_mux_cfg = (afe_mux_cfg & ~0x30) | 0x20;\n\t\tch[1] = SIF;\n\t\tbreak;\n\tcase CX18_AV_AUDIO7:\n\t\tafe_mux_cfg &= ~0xc0;\n\t\tch[2] = SIF;\n\t\tbreak;\n\tcase CX18_AV_AUDIO8:\n\t\tafe_mux_cfg = (afe_mux_cfg & ~0xc0) | 0x40;\n\t\tch[2] = SIF;\n\t\tbreak;\n\n\tdefault:\n\t\tCX18_ERR_DEV(sd, \"0x%04x is not a valid audio input!\\n\",\n\t\t\t     aud_input);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcx18_av_write_expect(cx, 0x103, afe_mux_cfg, afe_mux_cfg, 0xf7);\n\t \n\tcx18_av_and_or(cx, 0x401, ~0x6, input_mode);\n\n\t \n\tadc2_cfg = cx18_av_read(cx, 0x102);\n\tif (ch[2] == NONE)\n\t\tadc2_cfg &= ~0x2;  \n\telse\n\t\tadc2_cfg |= 0x2;   \n\n\t \n\tif (ch[1] != NONE && ch[2] != NONE)\n\t\tadc2_cfg |= 0x4;  \n\telse\n\t\tadc2_cfg &= ~0x4;  \n\tcx18_av_write_expect(cx, 0x102, adc2_cfg, adc2_cfg, 0x17);\n\n\t \n\tafe_cfg = cx18_av_read4(cx, CXADEC_AFE_CTRL);\n\tafe_cfg &= 0xff000000;\n\tafe_cfg |= 0x00005000;  \n\tif (ch[1] != NONE && ch[2] != NONE)\n\t\tafe_cfg |= 0x00000030;  \n\n\tfor (i = 0; i < 3; i++) {\n\t\tswitch (ch[i]) {\n\t\tdefault:\n\t\tcase NONE:\n\t\t\t \n\t\t\tafe_cfg |= (0x00000200 << i);\n\t\t\tbreak;\n\t\tcase CVBS:\n\t\tcase Y:\n\t\t\tif (i > 0)\n\t\t\t\tafe_cfg |= 0x00002000;  \n\t\t\tbreak;\n\t\tcase C:\n\t\tcase Pb:\n\t\tcase Pr:\n\t\t\t \n\t\t\tafe_cfg |= (0x00000200 << i);\n\t\t\tif (i == 0 && ch[i] == C)\n\t\t\t\tafe_cfg &= ~0x00001000;  \n\t\t\tbreak;\n\t\tcase SIF:\n\t\t\t \n\t\t\tafe_cfg |= (0x00000240 << i);\n\t\t\tif (i == 0)\n\t\t\t\tafe_cfg &= ~0x00004000;  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcx18_av_write4(cx, CXADEC_AFE_CTRL, afe_cfg);\n\n\tstate->vid_input = vid_input;\n\tstate->aud_input = aud_input;\n\tcx18_av_audio_set_path(cx);\n\tinput_change(cx);\n\treturn 0;\n}\n\nstatic int cx18_av_s_video_routing(struct v4l2_subdev *sd,\n\t\t\t\t   u32 input, u32 output, u32 config)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\treturn set_input(cx, input, state->aud_input);\n}\n\nstatic int cx18_av_s_audio_routing(struct v4l2_subdev *sd,\n\t\t\t\t   u32 input, u32 output, u32 config)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\treturn set_input(cx, state->vid_input, input);\n}\n\nstatic int cx18_av_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tu8 vpres;\n\tu8 mode;\n\tint val = 0;\n\n\tif (state->radio)\n\t\treturn 0;\n\n\tvpres = cx18_av_read(cx, 0x40e) & 0x20;\n\tvt->signal = vpres ? 0xffff : 0x0;\n\n\tvt->capability |=\n\t\t    V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\n\t\t    V4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\n\n\tmode = cx18_av_read(cx, 0x804);\n\n\t \n\tif ((mode & 0xf) == 1)\n\t\tval |= V4L2_TUNER_SUB_STEREO;\n\telse\n\t\tval |= V4L2_TUNER_SUB_MONO;\n\n\tif (mode == 2 || mode == 4)\n\t\tval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\n\tif (mode & 0x10)\n\t\tval |= V4L2_TUNER_SUB_SAP;\n\n\tvt->rxsubchans = val;\n\tvt->audmode = state->audmode;\n\treturn 0;\n}\n\nstatic int cx18_av_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tu8 v;\n\n\tif (state->radio)\n\t\treturn 0;\n\n\tv = cx18_av_read(cx, 0x809);\n\tv &= ~0xf;\n\n\tswitch (vt->audmode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\t \n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\t \n\t\tv |= 0x4;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t \n\t\tv |= 0x7;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\t \n\t\tv |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tcx18_av_write_expect(cx, 0x809, v, v, 0xff);\n\tstate->audmode = vt->audmode;\n\treturn 0;\n}\n\nstatic int cx18_av_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tu8 fmt = 0;\t \n\tu8 pal_m = 0;\n\n\tif (state->radio == 0 && state->std == norm)\n\t\treturn 0;\n\n\tstate->radio = 0;\n\tstate->std = norm;\n\n\t \n\tif (state->std == V4L2_STD_NTSC_M_JP) {\n\t\tfmt = 0x2;\n\t} else if (state->std == V4L2_STD_NTSC_443) {\n\t\tfmt = 0x3;\n\t} else if (state->std == V4L2_STD_PAL_M) {\n\t\tpal_m = 1;\n\t\tfmt = 0x5;\n\t} else if (state->std == V4L2_STD_PAL_N) {\n\t\tfmt = 0x6;\n\t} else if (state->std == V4L2_STD_PAL_Nc) {\n\t\tfmt = 0x7;\n\t} else if (state->std == V4L2_STD_PAL_60) {\n\t\tfmt = 0x8;\n\t} else {\n\t\t \n\t\tif (state->std & V4L2_STD_NTSC)\n\t\t\tfmt = 0x1;\n\t\telse if (state->std & V4L2_STD_PAL)\n\t\t\tfmt = 0x4;\n\t\telse if (state->std & V4L2_STD_SECAM)\n\t\t\tfmt = 0xc;\n\t}\n\n\tCX18_DEBUG_INFO_DEV(sd, \"changing video std to fmt %i\\n\", fmt);\n\n\t \n\tif (fmt >= 4 && fmt < 8) {\n\t\t \n\t\tcx18_av_and_or(cx, 0x400, ~0xf, 1);\n\t\t \n\t\tcx18_av_and_or(cx, 0x47b, ~6, 0);\n\t}\n\tcx18_av_and_or(cx, 0x400, ~0x2f, fmt | 0x20);\n\tcx18_av_and_or(cx, 0x403, ~0x3, pal_m);\n\tcx18_av_std_setup(cx);\n\tinput_change(cx);\n\treturn 0;\n}\n\nstatic int cx18_av_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstate->radio = 1;\n\treturn 0;\n}\n\nstatic int cx18_av_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tcx18_av_write(cx, 0x414, ctrl->val - 128);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\tcx18_av_write(cx, 0x415, ctrl->val << 1);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tcx18_av_write(cx, 0x420, ctrl->val << 1);\n\t\tcx18_av_write(cx, 0x421, ctrl->val << 1);\n\t\tbreak;\n\n\tcase V4L2_CID_HUE:\n\t\tcx18_av_write(cx, 0x422, ctrl->val);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cx18_av_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct cx18_av_state *state = to_cx18_av_state(sd);\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tint HSC, VSC, Vsrc, Hsrc, filter, Vlines;\n\tint is_50Hz = !(state->std & V4L2_STD_525_60);\n\n\tif (format->pad || fmt->code != MEDIA_BUS_FMT_FIXED)\n\t\treturn -EINVAL;\n\n\tfmt->field = V4L2_FIELD_INTERLACED;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tVsrc = (cx18_av_read(cx, 0x476) & 0x3f) << 4;\n\tVsrc |= (cx18_av_read(cx, 0x475) & 0xf0) >> 4;\n\n\tHsrc = (cx18_av_read(cx, 0x472) & 0x3f) << 4;\n\tHsrc |= (cx18_av_read(cx, 0x471) & 0xf0) >> 4;\n\n\t \n\tVlines = fmt->height + (is_50Hz ? 3 : 1);\n\n\t \n\tif ((fmt->width * 16 < Hsrc) || (Hsrc < fmt->width) ||\n\t    (Vlines * 8 < Vsrc) || (Vsrc < Vlines)) {\n\t\tCX18_ERR_DEV(sd, \"%dx%d is not a valid size!\\n\",\n\t\t\t     fmt->width, fmt->height);\n\t\treturn -ERANGE;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\tHSC = (Hsrc * (1 << 20)) / fmt->width - (1 << 20);\n\tVSC = (1 << 16) - (Vsrc * (1 << 9) / Vlines - (1 << 9));\n\tVSC &= 0x1fff;\n\n\tif (fmt->width >= 385)\n\t\tfilter = 0;\n\telse if (fmt->width > 192)\n\t\tfilter = 1;\n\telse if (fmt->width > 96)\n\t\tfilter = 2;\n\telse\n\t\tfilter = 3;\n\n\tCX18_DEBUG_INFO_DEV(sd,\n\t\t\t    \"decoder set size %dx%d -> scale  %ux%u\\n\",\n\t\t\t    fmt->width, fmt->height, HSC, VSC);\n\n\t \n\tcx18_av_write(cx, 0x418, HSC & 0xff);\n\tcx18_av_write(cx, 0x419, (HSC >> 8) & 0xff);\n\tcx18_av_write(cx, 0x41a, HSC >> 16);\n\t \n\tcx18_av_write(cx, 0x41c, VSC & 0xff);\n\tcx18_av_write(cx, 0x41d, VSC >> 8);\n\t \n\tcx18_av_write(cx, 0x41e, 0x8 | filter);\n\treturn 0;\n}\n\nstatic int cx18_av_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tCX18_DEBUG_INFO_DEV(sd, \"%s output\\n\", enable ? \"enable\" : \"disable\");\n\tif (enable) {\n\t\tcx18_av_write(cx, 0x115, 0x8c);\n\t\tcx18_av_write(cx, 0x116, 0x07);\n\t} else {\n\t\tcx18_av_write(cx, 0x115, 0x00);\n\t\tcx18_av_write(cx, 0x116, 0x00);\n\t}\n\treturn 0;\n}\n\nstatic void log_video_status(struct cx18 *cx)\n{\n\tstatic const char *const fmt_strs[] = {\n\t\t\"0x0\",\n\t\t\"NTSC-M\", \"NTSC-J\", \"NTSC-4.43\",\n\t\t\"PAL-BDGHI\", \"PAL-M\", \"PAL-N\", \"PAL-Nc\", \"PAL-60\",\n\t\t\"0x9\", \"0xA\", \"0xB\",\n\t\t\"SECAM\",\n\t\t\"0xD\", \"0xE\", \"0xF\"\n\t};\n\n\tstruct cx18_av_state *state = &cx->av_state;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 vidfmt_sel = cx18_av_read(cx, 0x400) & 0xf;\n\tu8 gen_stat1 = cx18_av_read(cx, 0x40d);\n\tu8 gen_stat2 = cx18_av_read(cx, 0x40e);\n\tint vid_input = state->vid_input;\n\n\tCX18_INFO_DEV(sd, \"Video signal:              %spresent\\n\",\n\t\t      (gen_stat2 & 0x20) ? \"\" : \"not \");\n\tCX18_INFO_DEV(sd, \"Detected format:           %s\\n\",\n\t\t      fmt_strs[gen_stat1 & 0xf]);\n\n\tCX18_INFO_DEV(sd, \"Specified standard:        %s\\n\",\n\t\t      vidfmt_sel ? fmt_strs[vidfmt_sel]\n\t\t\t\t : \"automatic detection\");\n\n\tif (vid_input >= CX18_AV_COMPOSITE1 &&\n\t    vid_input <= CX18_AV_COMPOSITE8) {\n\t\tCX18_INFO_DEV(sd, \"Specified video input:     Composite %d\\n\",\n\t\t\t      vid_input - CX18_AV_COMPOSITE1 + 1);\n\t} else {\n\t\tCX18_INFO_DEV(sd, \"Specified video input:     S-Video (Luma In%d, Chroma In%d)\\n\",\n\t\t\t      (vid_input & 0xf0) >> 4,\n\t\t\t      (vid_input & 0xf00) >> 8);\n\t}\n\n\tCX18_INFO_DEV(sd, \"Specified audioclock freq: %d Hz\\n\",\n\t\t      state->audclk_freq);\n}\n\nstatic void log_audio_status(struct cx18 *cx)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 download_ctl = cx18_av_read(cx, 0x803);\n\tu8 mod_det_stat0 = cx18_av_read(cx, 0x804);\n\tu8 mod_det_stat1 = cx18_av_read(cx, 0x805);\n\tu8 audio_config = cx18_av_read(cx, 0x808);\n\tu8 pref_mode = cx18_av_read(cx, 0x809);\n\tu8 afc0 = cx18_av_read(cx, 0x80b);\n\tu8 mute_ctl = cx18_av_read(cx, 0x8d3);\n\tint aud_input = state->aud_input;\n\tchar *p;\n\n\tswitch (mod_det_stat0) {\n\tcase 0x00: p = \"mono\"; break;\n\tcase 0x01: p = \"stereo\"; break;\n\tcase 0x02: p = \"dual\"; break;\n\tcase 0x04: p = \"tri\"; break;\n\tcase 0x10: p = \"mono with SAP\"; break;\n\tcase 0x11: p = \"stereo with SAP\"; break;\n\tcase 0x12: p = \"dual with SAP\"; break;\n\tcase 0x14: p = \"tri with SAP\"; break;\n\tcase 0xfe: p = \"forced mode\"; break;\n\tdefault: p = \"not defined\"; break;\n\t}\n\tCX18_INFO_DEV(sd, \"Detected audio mode:       %s\\n\", p);\n\n\tswitch (mod_det_stat1) {\n\tcase 0x00: p = \"not defined\"; break;\n\tcase 0x01: p = \"EIAJ\"; break;\n\tcase 0x02: p = \"A2-M\"; break;\n\tcase 0x03: p = \"A2-BG\"; break;\n\tcase 0x04: p = \"A2-DK1\"; break;\n\tcase 0x05: p = \"A2-DK2\"; break;\n\tcase 0x06: p = \"A2-DK3\"; break;\n\tcase 0x07: p = \"A1 (6.0 MHz FM Mono)\"; break;\n\tcase 0x08: p = \"AM-L\"; break;\n\tcase 0x09: p = \"NICAM-BG\"; break;\n\tcase 0x0a: p = \"NICAM-DK\"; break;\n\tcase 0x0b: p = \"NICAM-I\"; break;\n\tcase 0x0c: p = \"NICAM-L\"; break;\n\tcase 0x0d: p = \"BTSC/EIAJ/A2-M Mono (4.5 MHz FMMono)\"; break;\n\tcase 0x0e: p = \"IF FM Radio\"; break;\n\tcase 0x0f: p = \"BTSC\"; break;\n\tcase 0x10: p = \"detected chrominance\"; break;\n\tcase 0xfd: p = \"unknown audio standard\"; break;\n\tcase 0xfe: p = \"forced audio standard\"; break;\n\tcase 0xff: p = \"no detected audio standard\"; break;\n\tdefault: p = \"not defined\"; break;\n\t}\n\tCX18_INFO_DEV(sd, \"Detected audio standard:   %s\\n\", p);\n\tCX18_INFO_DEV(sd, \"Audio muted:               %s\\n\",\n\t\t      (mute_ctl & 0x2) ? \"yes\" : \"no\");\n\tCX18_INFO_DEV(sd, \"Audio microcontroller:     %s\\n\",\n\t\t      (download_ctl & 0x10) ? \"running\" : \"stopped\");\n\n\tswitch (audio_config >> 4) {\n\tcase 0x00: p = \"undefined\"; break;\n\tcase 0x01: p = \"BTSC\"; break;\n\tcase 0x02: p = \"EIAJ\"; break;\n\tcase 0x03: p = \"A2-M\"; break;\n\tcase 0x04: p = \"A2-BG\"; break;\n\tcase 0x05: p = \"A2-DK1\"; break;\n\tcase 0x06: p = \"A2-DK2\"; break;\n\tcase 0x07: p = \"A2-DK3\"; break;\n\tcase 0x08: p = \"A1 (6.0 MHz FM Mono)\"; break;\n\tcase 0x09: p = \"AM-L\"; break;\n\tcase 0x0a: p = \"NICAM-BG\"; break;\n\tcase 0x0b: p = \"NICAM-DK\"; break;\n\tcase 0x0c: p = \"NICAM-I\"; break;\n\tcase 0x0d: p = \"NICAM-L\"; break;\n\tcase 0x0e: p = \"FM radio\"; break;\n\tcase 0x0f: p = \"automatic detection\"; break;\n\tdefault: p = \"undefined\"; break;\n\t}\n\tCX18_INFO_DEV(sd, \"Configured audio standard: %s\\n\", p);\n\n\tif ((audio_config >> 4) < 0xF) {\n\t\tswitch (audio_config & 0xF) {\n\t\tcase 0x00: p = \"MONO1 (LANGUAGE A/Mono L+R channel for BTSC, EIAJ, A2)\"; break;\n\t\tcase 0x01: p = \"MONO2 (LANGUAGE B)\"; break;\n\t\tcase 0x02: p = \"MONO3 (STEREO forced MONO)\"; break;\n\t\tcase 0x03: p = \"MONO4 (NICAM ANALOG-Language C/Analog Fallback)\"; break;\n\t\tcase 0x04: p = \"STEREO\"; break;\n\t\tcase 0x05: p = \"DUAL1 (AC)\"; break;\n\t\tcase 0x06: p = \"DUAL2 (BC)\"; break;\n\t\tcase 0x07: p = \"DUAL3 (AB)\"; break;\n\t\tdefault: p = \"undefined\";\n\t\t}\n\t\tCX18_INFO_DEV(sd, \"Configured audio mode:     %s\\n\", p);\n\t} else {\n\t\tswitch (audio_config & 0xF) {\n\t\tcase 0x00: p = \"BG\"; break;\n\t\tcase 0x01: p = \"DK1\"; break;\n\t\tcase 0x02: p = \"DK2\"; break;\n\t\tcase 0x03: p = \"DK3\"; break;\n\t\tcase 0x04: p = \"I\"; break;\n\t\tcase 0x05: p = \"L\"; break;\n\t\tcase 0x06: p = \"BTSC\"; break;\n\t\tcase 0x07: p = \"EIAJ\"; break;\n\t\tcase 0x08: p = \"A2-M\"; break;\n\t\tcase 0x09: p = \"FM Radio (4.5 MHz)\"; break;\n\t\tcase 0x0a: p = \"FM Radio (5.5 MHz)\"; break;\n\t\tcase 0x0b: p = \"S-Video\"; break;\n\t\tcase 0x0f: p = \"automatic standard and mode detection\"; break;\n\t\tdefault: p = \"undefined\"; break;\n\t\t}\n\t\tCX18_INFO_DEV(sd, \"Configured audio system:   %s\\n\", p);\n\t}\n\n\tif (aud_input)\n\t\tCX18_INFO_DEV(sd, \"Specified audio input:     Tuner (In%d)\\n\",\n\t\t\t      aud_input);\n\telse\n\t\tCX18_INFO_DEV(sd, \"Specified audio input:     External\\n\");\n\n\tswitch (pref_mode & 0xf) {\n\tcase 0: p = \"mono/language A\"; break;\n\tcase 1: p = \"language B\"; break;\n\tcase 2: p = \"language C\"; break;\n\tcase 3: p = \"analog fallback\"; break;\n\tcase 4: p = \"stereo\"; break;\n\tcase 5: p = \"language AC\"; break;\n\tcase 6: p = \"language BC\"; break;\n\tcase 7: p = \"language AB\"; break;\n\tdefault: p = \"undefined\"; break;\n\t}\n\tCX18_INFO_DEV(sd, \"Preferred audio mode:      %s\\n\", p);\n\n\tif ((audio_config & 0xf) == 0xf) {\n\t\tswitch ((afc0 >> 3) & 0x1) {\n\t\tcase 0: p = \"system DK\"; break;\n\t\tcase 1: p = \"system L\"; break;\n\t\t}\n\t\tCX18_INFO_DEV(sd, \"Selected 65 MHz format:    %s\\n\", p);\n\n\t\tswitch (afc0 & 0x7) {\n\t\tcase 0: p = \"Chroma\"; break;\n\t\tcase 1: p = \"BTSC\"; break;\n\t\tcase 2: p = \"EIAJ\"; break;\n\t\tcase 3: p = \"A2-M\"; break;\n\t\tcase 4: p = \"autodetect\"; break;\n\t\tdefault: p = \"undefined\"; break;\n\t\t}\n\t\tCX18_INFO_DEV(sd, \"Selected 45 MHz format:    %s\\n\", p);\n\t}\n}\n\nstatic int cx18_av_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tlog_video_status(cx);\n\tlog_audio_status(cx);\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int cx18_av_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tif ((reg->reg & 0x3) != 0)\n\t\treturn -EINVAL;\n\treg->size = 4;\n\treg->val = cx18_av_read4(cx, reg->reg & 0x00000ffc);\n\treturn 0;\n}\n\nstatic int cx18_av_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tif ((reg->reg & 0x3) != 0)\n\t\treturn -EINVAL;\n\tcx18_av_write4(cx, reg->reg & 0x00000ffc, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ctrl_ops cx18_av_ctrl_ops = {\n\t.s_ctrl = cx18_av_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops cx18_av_general_ops = {\n\t.log_status = cx18_av_log_status,\n\t.load_fw = cx18_av_load_fw,\n\t.reset = cx18_av_reset,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = cx18_av_g_register,\n\t.s_register = cx18_av_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_tuner_ops cx18_av_tuner_ops = {\n\t.s_radio = cx18_av_s_radio,\n\t.s_frequency = cx18_av_s_frequency,\n\t.g_tuner = cx18_av_g_tuner,\n\t.s_tuner = cx18_av_s_tuner,\n};\n\nstatic const struct v4l2_subdev_audio_ops cx18_av_audio_ops = {\n\t.s_clock_freq = cx18_av_s_clock_freq,\n\t.s_routing = cx18_av_s_audio_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops cx18_av_video_ops = {\n\t.s_std = cx18_av_s_std,\n\t.s_routing = cx18_av_s_video_routing,\n\t.s_stream = cx18_av_s_stream,\n};\n\nstatic const struct v4l2_subdev_vbi_ops cx18_av_vbi_ops = {\n\t.decode_vbi_line = cx18_av_decode_vbi_line,\n\t.g_sliced_fmt = cx18_av_g_sliced_fmt,\n\t.s_sliced_fmt = cx18_av_s_sliced_fmt,\n\t.s_raw_fmt = cx18_av_s_raw_fmt,\n};\n\nstatic const struct v4l2_subdev_pad_ops cx18_av_pad_ops = {\n\t.set_fmt = cx18_av_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops cx18_av_ops = {\n\t.core = &cx18_av_general_ops,\n\t.tuner = &cx18_av_tuner_ops,\n\t.audio = &cx18_av_audio_ops,\n\t.video = &cx18_av_video_ops,\n\t.vbi = &cx18_av_vbi_ops,\n\t.pad = &cx18_av_pad_ops,\n};\n\nint cx18_av_probe(struct cx18 *cx)\n{\n\tstruct cx18_av_state *state = &cx->av_state;\n\tstruct v4l2_subdev *sd;\n\tint err;\n\n\tstate->rev = cx18_av_read4(cx, CXADEC_CHIP_CTRL) & 0xffff;\n\n\tstate->vid_input = CX18_AV_COMPOSITE7;\n\tstate->aud_input = CX18_AV_AUDIO8;\n\tstate->audclk_freq = 48000;\n\tstate->audmode = V4L2_TUNER_MODE_LANG1;\n\tstate->slicer_line_delay = 0;\n\tstate->slicer_line_offset = (10 + state->slicer_line_delay - 2);\n\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx18_av_ops);\n\tv4l2_set_subdevdata(sd, cx);\n\tsnprintf(sd->name, sizeof(sd->name),\n\t\t \"%s %03x\", cx->v4l2_dev.name, (state->rev >> 4));\n\tsd->grp_id = CX18_HW_418_AV;\n\tv4l2_ctrl_handler_init(&state->hdl, 9);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\n\tstate->volume = v4l2_ctrl_new_std(&state->hdl,\n\t\t\t&cx18_av_audio_ctrl_ops, V4L2_CID_AUDIO_VOLUME,\n\t\t\t0, 65535, 65535 / 100, 0);\n\tv4l2_ctrl_new_std(&state->hdl,\n\t\t\t&cx18_av_audio_ctrl_ops, V4L2_CID_AUDIO_MUTE,\n\t\t\t0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BALANCE,\n\t\t\t0, 65535, 65535 / 100, 32768);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BASS,\n\t\t\t0, 65535, 65535 / 100, 32768);\n\tv4l2_ctrl_new_std(&state->hdl, &cx18_av_audio_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_TREBLE,\n\t\t\t0, 65535, 65535 / 100, 32768);\n\tsd->ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\tint err = state->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\t\treturn err;\n\t}\n\terr = v4l2_device_register_subdev(&cx->v4l2_dev, sd);\n\tif (err)\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\telse\n\t\tcx18_av_init(cx);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}