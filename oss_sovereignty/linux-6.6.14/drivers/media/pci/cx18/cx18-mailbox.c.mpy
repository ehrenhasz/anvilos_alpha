{
  "module_name": "cx18-mailbox.c",
  "hash_id": "800c321865db44a6543e2201d7fa3f596d2d82f5afd59f6996a69e62c39cf94f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-scb.h\"\n#include \"cx18-irq.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-alsa-pcm.h\"  \n\nstatic const char *rpu_str[] = { \"APU\", \"CPU\", \"EPU\", \"HPU\" };\n\n#define API_FAST (1 << 2)  \n#define API_SLOW (1 << 3)  \n\nstruct cx18_api_info {\n\tu32 cmd;\n\tu8 flags;\t\t \n\tu8 rpu;\t\t\t \n\tconst char *name;\t \n};\n\n#define API_ENTRY(rpu, x, f) { (x), (f), (rpu), #x }\n\nstatic const struct cx18_api_info api_info[] = {\n\t \n\tAPI_ENTRY(CPU, CX18_CPU_SET_CHANNEL_TYPE,\t\t0),\n\tAPI_ENTRY(CPU, CX18_EPU_DEBUG,\t\t\t\t0),\n\tAPI_ENTRY(CPU, CX18_CREATE_TASK,\t\t\t0),\n\tAPI_ENTRY(CPU, CX18_DESTROY_TASK,\t\t\t0),\n\tAPI_ENTRY(CPU, CX18_CPU_CAPTURE_START,                  API_SLOW),\n\tAPI_ENTRY(CPU, CX18_CPU_CAPTURE_STOP,                   API_SLOW),\n\tAPI_ENTRY(CPU, CX18_CPU_CAPTURE_PAUSE,                  0),\n\tAPI_ENTRY(CPU, CX18_CPU_CAPTURE_RESUME,                 0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_CHANNEL_TYPE,               0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_STREAM_OUTPUT_TYPE,         0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VIDEO_IN,                   0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VIDEO_RATE,                 0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VIDEO_RESOLUTION,           0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_FILTER_PARAM,               0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_SPATIAL_FILTER_TYPE,        0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_MEDIAN_CORING,              0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_INDEXTABLE,                 0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_AUDIO_PARAMETERS,           0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VIDEO_MUTE,                 0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_AUDIO_MUTE,                 0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_MISC_PARAMETERS,            0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_RAW_VBI_PARAM,              API_SLOW),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_CAPTURE_LINE_NO,            0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_COPYRIGHT,                  0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_AUDIO_PID,                  0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VIDEO_PID,                  0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VER_CROP_LINE,              0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_GOP_STRUCTURE,              0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_SCENE_CHANGE_DETECTION,     0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_ASPECT_RATIO,               0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_SKIP_INPUT_FRAME,           0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_SLICED_VBI_PARAM,           0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_USERDATA_PLACE_HOLDER,      0),\n\tAPI_ENTRY(CPU, CX18_CPU_GET_ENC_PTS,                    0),\n\tAPI_ENTRY(CPU, CX18_CPU_SET_VFC_PARAM,                  0),\n\tAPI_ENTRY(CPU, CX18_CPU_DE_SET_MDL_ACK,\t\t\t0),\n\tAPI_ENTRY(CPU, CX18_CPU_DE_SET_MDL,\t\t\tAPI_FAST),\n\tAPI_ENTRY(CPU, CX18_CPU_DE_RELEASE_MDL,\t\t\tAPI_SLOW),\n\tAPI_ENTRY(APU, CX18_APU_START,\t\t\t\t0),\n\tAPI_ENTRY(APU, CX18_APU_STOP,\t\t\t\t0),\n\tAPI_ENTRY(APU, CX18_APU_RESETAI,\t\t\t0),\n\tAPI_ENTRY(CPU, CX18_CPU_DEBUG_PEEK32,\t\t\t0),\n\tAPI_ENTRY(0, 0,\t\t\t\t\t\t0),\n};\n\nstatic const struct cx18_api_info *find_api_info(u32 cmd)\n{\n\tint i;\n\n\tfor (i = 0; api_info[i].cmd; i++)\n\t\tif (api_info[i].cmd == cmd)\n\t\t\treturn &api_info[i];\n\treturn NULL;\n}\n\n \nstatic char *u32arr2hex(u32 data[], int n, char *buf)\n{\n\tchar *p;\n\tint i;\n\n\tfor (i = 0, p = buf; i < n; i++, p += 11) {\n\t\t \n\t\tsnprintf(p, 12, \" %#010x\", data[i]);\n\t}\n\t*p = '\\0';\n\treturn buf;\n}\n\nstatic void dump_mb(struct cx18 *cx, struct cx18_mailbox *mb, char *name)\n{\n\tchar argstr[MAX_MB_ARGUMENTS*11+1];\n\n\tif (!(cx18_debug & CX18_DBGFLG_API))\n\t\treturn;\n\n\tCX18_DEBUG_API(\"%s: req %#010x ack %#010x cmd %#010x err %#010x args%s\\n\",\n\t\t       name, mb->request, mb->ack, mb->cmd, mb->error,\n\t\t       u32arr2hex(mb->args, MAX_MB_ARGUMENTS, argstr));\n}\n\n\n \n\nstatic void cx18_mdl_send_to_dvb(struct cx18_stream *s, struct cx18_mdl *mdl)\n{\n\tstruct cx18_buffer *buf;\n\n\tif (s->dvb == NULL || !s->dvb->enabled || mdl->bytesused == 0)\n\t\treturn;\n\n\t \n\n\t \n\tif (list_is_singular(&mdl->buf_list)) {\n\t\tbuf = list_first_entry(&mdl->buf_list, struct cx18_buffer,\n\t\t\t\t       list);\n\t\tif (buf->bytesused)\n\t\t\tdvb_dmx_swfilter(&s->dvb->demux,\n\t\t\t\t\t buf->buf, buf->bytesused);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(buf, &mdl->buf_list, list) {\n\t\tif (buf->bytesused == 0)\n\t\t\tbreak;\n\t\tdvb_dmx_swfilter(&s->dvb->demux, buf->buf, buf->bytesused);\n\t}\n}\n\nstatic void cx18_mdl_send_to_vb2(struct cx18_stream *s, struct cx18_mdl *mdl)\n{\n\tstruct cx18_vb2_buffer *vb_buf;\n\tstruct cx18_buffer *buf;\n\tu8 *p;\n\tu32 offset = 0;\n\tint dispatch = 0;\n\tunsigned long bsize;\n\n\tif (mdl->bytesused == 0)\n\t\treturn;\n\n\t \n\tspin_lock(&s->vb_lock);\n\tif (list_empty(&s->vb_capture))\n\t\tgoto out;\n\n\tvb_buf = list_first_entry(&s->vb_capture, struct cx18_vb2_buffer,\n\t\t\t\t  list);\n\n\tp = vb2_plane_vaddr(&vb_buf->vb.vb2_buf, 0);\n\tif (!p)\n\t\tgoto out;\n\n\tbsize = vb2_get_plane_payload(&vb_buf->vb.vb2_buf, 0);\n\toffset = vb_buf->bytes_used;\n\tlist_for_each_entry(buf, &mdl->buf_list, list) {\n\t\tif (buf->bytesused == 0)\n\t\t\tbreak;\n\n\t\tif ((offset + buf->bytesused) <= bsize) {\n\t\t\tmemcpy(p + offset, buf->buf, buf->bytesused);\n\t\t\toffset += buf->bytesused;\n\t\t\tvb_buf->bytes_used += buf->bytesused;\n\t\t}\n\t}\n\n\t \n\tif (vb_buf->bytes_used >= s->vb_bytes_per_frame) {\n\t\tdispatch = 1;\n\t\tvb_buf->bytes_used = 0;\n\t}\n\n\tif (dispatch) {\n\t\tvb_buf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tvb_buf->vb.sequence = s->sequence++;\n\t\tlist_del(&vb_buf->list);\n\t\tvb2_buffer_done(&vb_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tmod_timer(&s->vb_timeout, msecs_to_jiffies(2000) + jiffies);\n\nout:\n\tspin_unlock(&s->vb_lock);\n}\n\nstatic void cx18_mdl_send_to_alsa(struct cx18 *cx, struct cx18_stream *s,\n\t\t\t\t  struct cx18_mdl *mdl)\n{\n\tstruct cx18_buffer *buf;\n\n\tif (mdl->bytesused == 0)\n\t\treturn;\n\n\t \n\n\t \n\tif (list_is_singular(&mdl->buf_list)) {\n\t\tbuf = list_first_entry(&mdl->buf_list, struct cx18_buffer,\n\t\t\t\t       list);\n\t\tif (buf->bytesused)\n\t\t\tcx->pcm_announce_callback(cx->alsa, buf->buf,\n\t\t\t\t\t\t  buf->bytesused);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(buf, &mdl->buf_list, list) {\n\t\tif (buf->bytesused == 0)\n\t\t\tbreak;\n\t\tcx->pcm_announce_callback(cx->alsa, buf->buf, buf->bytesused);\n\t}\n}\n\nstatic void epu_dma_done(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tu32 handle, mdl_ack_count, id;\n\tstruct cx18_mailbox *mb;\n\tstruct cx18_mdl_ack *mdl_ack;\n\tstruct cx18_stream *s;\n\tstruct cx18_mdl *mdl;\n\tint i;\n\n\tmb = &order->mb;\n\thandle = mb->args[0];\n\ts = cx18_handle_to_stream(cx, handle);\n\n\tif (s == NULL) {\n\t\tCX18_WARN(\"Got DMA done notification for unknown/inactive handle %d, %s mailbox seq no %d\\n\",\n\t\t\t  handle,\n\t\t\t  (order->flags & CX18_F_EWO_MB_STALE_UPON_RECEIPT) ?\n\t\t\t  \"stale\" : \"good\", mb->request);\n\t\treturn;\n\t}\n\n\tmdl_ack_count = mb->args[2];\n\tmdl_ack = order->mdl_ack;\n\tfor (i = 0; i < mdl_ack_count; i++, mdl_ack++) {\n\t\tid = mdl_ack->id;\n\t\t \n\t\tif ((order->flags & CX18_F_EWO_MB_STALE_UPON_RECEIPT) &&\n\t\t    !(id >= s->mdl_base_idx &&\n\t\t      id < (s->mdl_base_idx + s->buffers))) {\n\t\t\tCX18_WARN(\"Fell behind! Ignoring stale mailbox with  inconsistent data. Lost MDL for mailbox seq no %d\\n\",\n\t\t\t\t  mb->request);\n\t\t\tbreak;\n\t\t}\n\t\tmdl = cx18_queue_get_mdl(s, id, mdl_ack->data_used);\n\n\t\tCX18_DEBUG_HI_DMA(\"DMA DONE for %s (MDL %d)\\n\", s->name, id);\n\t\tif (mdl == NULL) {\n\t\t\tCX18_WARN(\"Could not find MDL %d for stream %s\\n\",\n\t\t\t\t  id, s->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tCX18_DEBUG_HI_DMA(\"%s recv bytesused = %d\\n\",\n\t\t\t\t  s->name, mdl->bytesused);\n\n\t\tif (s->type == CX18_ENC_STREAM_TYPE_TS) {\n\t\t\tcx18_mdl_send_to_dvb(s, mdl);\n\t\t\tcx18_enqueue(s, mdl, &s->q_free);\n\t\t} else if (s->type == CX18_ENC_STREAM_TYPE_PCM) {\n\t\t\t \n\t\t\tif (cx->pcm_announce_callback != NULL) {\n\t\t\t\tcx18_mdl_send_to_alsa(cx, s, mdl);\n\t\t\t\tcx18_enqueue(s, mdl, &s->q_free);\n\t\t\t} else {\n\t\t\t\tcx18_enqueue(s, mdl, &s->q_full);\n\t\t\t}\n\t\t} else if (s->type == CX18_ENC_STREAM_TYPE_YUV) {\n\t\t\tcx18_mdl_send_to_vb2(s, mdl);\n\t\t\tcx18_enqueue(s, mdl, &s->q_free);\n\t\t} else {\n\t\t\tcx18_enqueue(s, mdl, &s->q_full);\n\t\t\tif (s->type == CX18_ENC_STREAM_TYPE_IDX)\n\t\t\t\tcx18_stream_rotate_idx_mdls(cx);\n\t\t}\n\t}\n\t \n\tcx18_stream_load_fw_queue(s);\n\n\twake_up(&cx->dma_waitq);\n\tif (s->id != -1)\n\t\twake_up(&s->waitq);\n}\n\nstatic void epu_debug(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tchar *p;\n\tchar *str = order->str;\n\n\tCX18_DEBUG_INFO(\"%x %s\\n\", order->mb.args[0], str);\n\tp = strchr(str, '.');\n\tif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags) && p && p > str)\n\t\tCX18_INFO(\"FW version: %s\\n\", p - 1);\n}\n\nstatic void epu_cmd(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tswitch (order->rpu) {\n\tcase CPU:\n\t{\n\t\tswitch (order->mb.cmd) {\n\t\tcase CX18_EPU_DMA_DONE:\n\t\t\tepu_dma_done(cx, order);\n\t\t\tbreak;\n\t\tcase CX18_EPU_DEBUG:\n\t\t\tepu_debug(cx, order);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCX18_WARN(\"Unknown CPU to EPU mailbox command %#0x\\n\",\n\t\t\t\t  order->mb.cmd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase APU:\n\t\tCX18_WARN(\"Unknown APU to EPU mailbox command %#0x\\n\",\n\t\t\t  order->mb.cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid free_in_work_order(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tatomic_set(&order->pending, 0);\n}\n\nvoid cx18_in_work_handler(struct work_struct *work)\n{\n\tstruct cx18_in_work_order *order =\n\t\t\tcontainer_of(work, struct cx18_in_work_order, work);\n\tstruct cx18 *cx = order->cx;\n\tepu_cmd(cx, order);\n\tfree_in_work_order(cx, order);\n}\n\n\n \n\nstatic void mb_ack_irq(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tstruct cx18_mailbox __iomem *ack_mb;\n\tu32 ack_irq, req;\n\n\tswitch (order->rpu) {\n\tcase APU:\n\t\tack_irq = IRQ_EPU_TO_APU_ACK;\n\t\tack_mb = &cx->scb->apu2epu_mb;\n\t\tbreak;\n\tcase CPU:\n\t\tack_irq = IRQ_EPU_TO_CPU_ACK;\n\t\tack_mb = &cx->scb->cpu2epu_mb;\n\t\tbreak;\n\tdefault:\n\t\tCX18_WARN(\"Unhandled RPU (%d) for command %x ack\\n\",\n\t\t\t  order->rpu, order->mb.cmd);\n\t\treturn;\n\t}\n\n\treq = order->mb.request;\n\t \n\tif (req != cx18_readl(cx, &ack_mb->request) ||\n\t    req == cx18_readl(cx, &ack_mb->ack)) {\n\t\tCX18_DEBUG_WARN(\"Possibly falling behind: %s self-ack'ed our incoming %s to EPU mailbox (sequence no. %u) while processing\\n\",\n\t\t\t\trpu_str[order->rpu], rpu_str[order->rpu], req);\n\t\torder->flags |= CX18_F_EWO_MB_STALE_WHILE_PROC;\n\t\treturn;\n\t}\n\tcx18_writel(cx, req, &ack_mb->ack);\n\tcx18_write_reg_expect(cx, ack_irq, SW2_INT_SET, ack_irq, ack_irq);\n\treturn;\n}\n\nstatic int epu_dma_done_irq(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tu32 handle, mdl_ack_offset, mdl_ack_count;\n\tstruct cx18_mailbox *mb;\n\tint i;\n\n\tmb = &order->mb;\n\thandle = mb->args[0];\n\tmdl_ack_offset = mb->args[1];\n\tmdl_ack_count = mb->args[2];\n\n\tif (handle == CX18_INVALID_TASK_HANDLE ||\n\t    mdl_ack_count == 0 || mdl_ack_count > CX18_MAX_MDL_ACKS) {\n\t\tif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\n\t\t\tmb_ack_irq(cx, order);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(struct cx18_mdl_ack) * mdl_ack_count; i += sizeof(u32))\n\t\t((u32 *)order->mdl_ack)[i / sizeof(u32)] =\n\t\t\tcx18_readl(cx, cx->enc_mem + mdl_ack_offset + i);\n\n\tif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\n\t\tmb_ack_irq(cx, order);\n\treturn 1;\n}\n\nstatic\nint epu_debug_irq(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tu32 str_offset;\n\tchar *str = order->str;\n\n\tstr[0] = '\\0';\n\tstr_offset = order->mb.args[1];\n\tif (str_offset) {\n\t\tcx18_setup_page(cx, str_offset);\n\t\tcx18_memcpy_fromio(cx, str, cx->enc_mem + str_offset, 252);\n\t\tstr[252] = '\\0';\n\t\tcx18_setup_page(cx, SCB_OFFSET);\n\t}\n\n\tif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\n\t\tmb_ack_irq(cx, order);\n\n\treturn str_offset ? 1 : 0;\n}\n\nstatic inline\nint epu_cmd_irq(struct cx18 *cx, struct cx18_in_work_order *order)\n{\n\tint ret = -1;\n\n\tswitch (order->rpu) {\n\tcase CPU:\n\t{\n\t\tswitch (order->mb.cmd) {\n\t\tcase CX18_EPU_DMA_DONE:\n\t\t\tret = epu_dma_done_irq(cx, order);\n\t\t\tbreak;\n\t\tcase CX18_EPU_DEBUG:\n\t\t\tret = epu_debug_irq(cx, order);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCX18_WARN(\"Unknown CPU to EPU mailbox command %#0x\\n\",\n\t\t\t\t  order->mb.cmd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase APU:\n\t\tCX18_WARN(\"Unknown APU to EPU mailbox command %#0x\\n\",\n\t\t\t  order->mb.cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic inline\nstruct cx18_in_work_order *alloc_in_work_order_irq(struct cx18 *cx)\n{\n\tint i;\n\tstruct cx18_in_work_order *order = NULL;\n\n\tfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++) {\n\t\t \n\t\tif (atomic_read(&cx->in_work_order[i].pending) == 0) {\n\t\t\torder = &cx->in_work_order[i];\n\t\t\tatomic_set(&order->pending, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn order;\n}\n\nvoid cx18_api_epu_cmd_irq(struct cx18 *cx, int rpu)\n{\n\tstruct cx18_mailbox __iomem *mb;\n\tstruct cx18_mailbox *order_mb;\n\tstruct cx18_in_work_order *order;\n\tint submit;\n\tint i;\n\n\tswitch (rpu) {\n\tcase CPU:\n\t\tmb = &cx->scb->cpu2epu_mb;\n\t\tbreak;\n\tcase APU:\n\t\tmb = &cx->scb->apu2epu_mb;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\torder = alloc_in_work_order_irq(cx);\n\tif (order == NULL) {\n\t\tCX18_WARN(\"Unable to find blank work order form to schedule incoming mailbox command processing\\n\");\n\t\treturn;\n\t}\n\n\torder->flags = 0;\n\torder->rpu = rpu;\n\torder_mb = &order->mb;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\t(&order_mb->cmd)[i] = cx18_readl(cx, &mb->cmd + i);\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\t(&order_mb->request)[i] = cx18_readl(cx, &mb->request + i);\n\n\tif (order_mb->request == order_mb->ack) {\n\t\tCX18_DEBUG_WARN(\"Possibly falling behind: %s self-ack'ed our incoming %s to EPU mailbox (sequence no. %u)\\n\",\n\t\t\t\trpu_str[rpu], rpu_str[rpu], order_mb->request);\n\t\tif (cx18_debug & CX18_DBGFLG_WARN)\n\t\t\tdump_mb(cx, order_mb, \"incoming\");\n\t\torder->flags = CX18_F_EWO_MB_STALE_UPON_RECEIPT;\n\t}\n\n\t \n\tsubmit = epu_cmd_irq(cx, order);\n\tif (submit > 0) {\n\t\tqueue_work(cx->in_work_queue, &order->work);\n\t}\n}\n\n\n \n\nstatic int cx18_api_call(struct cx18 *cx, u32 cmd, int args, u32 data[])\n{\n\tconst struct cx18_api_info *info = find_api_info(cmd);\n\tu32 irq, req, ack, err;\n\tstruct cx18_mailbox __iomem *mb;\n\twait_queue_head_t *waitq;\n\tstruct mutex *mb_lock;\n\tunsigned long int t0, timeout, ret;\n\tint i;\n\tchar argstr[MAX_MB_ARGUMENTS*11+1];\n\tDEFINE_WAIT(w);\n\n\tif (info == NULL) {\n\t\tCX18_WARN(\"unknown cmd %x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cx18_debug & CX18_DBGFLG_API) {  \n\t\tif (cmd == CX18_CPU_DE_SET_MDL) {\n\t\t\tif (cx18_debug & CX18_DBGFLG_HIGHVOL)\n\t\t\t\tCX18_DEBUG_HI_API(\"%s\\tcmd %#010x args%s\\n\",\n\t\t\t\t\t\tinfo->name, cmd,\n\t\t\t\t\t\tu32arr2hex(data, args, argstr));\n\t\t} else\n\t\t\tCX18_DEBUG_API(\"%s\\tcmd %#010x args%s\\n\",\n\t\t\t\t       info->name, cmd,\n\t\t\t\t       u32arr2hex(data, args, argstr));\n\t}\n\n\tswitch (info->rpu) {\n\tcase APU:\n\t\twaitq = &cx->mb_apu_waitq;\n\t\tmb_lock = &cx->epu2apu_mb_lock;\n\t\tirq = IRQ_EPU_TO_APU;\n\t\tmb = &cx->scb->epu2apu_mb;\n\t\tbreak;\n\tcase CPU:\n\t\twaitq = &cx->mb_cpu_waitq;\n\t\tmb_lock = &cx->epu2cpu_mb_lock;\n\t\tirq = IRQ_EPU_TO_CPU;\n\t\tmb = &cx->scb->epu2cpu_mb;\n\t\tbreak;\n\tdefault:\n\t\tCX18_WARN(\"Unknown RPU (%d) for API call\\n\", info->rpu);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(mb_lock);\n\t \n\treq = cx18_readl(cx, &mb->request);\n\ttimeout = msecs_to_jiffies(10);\n\tret = wait_event_timeout(*waitq,\n\t\t\t\t (ack = cx18_readl(cx, &mb->ack)) == req,\n\t\t\t\t timeout);\n\tif (req != ack) {\n\t\t \n\t\tcx18_writel(cx, req, &mb->ack);\n\t\tCX18_ERR(\"mbox was found stuck busy when setting up for %s; clearing busy and trying to proceed\\n\",\n\t\t\t info->name);\n\t} else if (ret != timeout)\n\t\tCX18_DEBUG_API(\"waited %u msecs for busy mbox to be acked\\n\",\n\t\t\t       jiffies_to_msecs(timeout-ret));\n\n\t \n\treq = ((req & 0xfffffffe) == 0xfffffffe) ? 1 : req + 1;\n\n\tcx18_writel(cx, cmd, &mb->cmd);\n\tfor (i = 0; i < args; i++)\n\t\tcx18_writel(cx, data[i], &mb->args[i]);\n\tcx18_writel(cx, 0, &mb->error);\n\tcx18_writel(cx, req, &mb->request);\n\tcx18_writel(cx, req - 1, &mb->ack);  \n\n\t \n\ttimeout = msecs_to_jiffies((info->flags & API_FAST) ? 10 : 20);\n\n\tCX18_DEBUG_HI_IRQ(\"sending interrupt SW1: %x to send %s\\n\",\n\t\t\t  irq, info->name);\n\n\t \n\tprepare_to_wait(waitq, &w, TASK_UNINTERRUPTIBLE);\n\tcx18_write_reg_expect(cx, irq, SW1_INT_SET, irq, irq);\n\n\tt0 = jiffies;\n\tack = cx18_readl(cx, &mb->ack);\n\tif (ack != req) {\n\t\tschedule_timeout(timeout);\n\t\tret = jiffies - t0;\n\t\tack = cx18_readl(cx, &mb->ack);\n\t} else {\n\t\tret = jiffies - t0;\n\t}\n\n\tfinish_wait(waitq, &w);\n\n\tif (req != ack) {\n\t\tmutex_unlock(mb_lock);\n\t\tif (ret >= timeout) {\n\t\t\t \n\t\t\tCX18_DEBUG_WARN(\"sending %s timed out waiting %d msecs for RPU acknowledgment\\n\",\n\t\t\t\t\tinfo->name, jiffies_to_msecs(ret));\n\t\t} else {\n\t\t\tCX18_DEBUG_WARN(\"woken up before mailbox ack was ready after submitting %s to RPU.  only waited %d msecs on req %u but awakened with unmatched ack %u\\n\",\n\t\t\t\t\tinfo->name,\n\t\t\t\t\tjiffies_to_msecs(ret),\n\t\t\t\t\treq, ack);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret >= timeout)\n\t\tCX18_DEBUG_WARN(\"failed to be awakened upon RPU acknowledgment sending %s; timed out waiting %d msecs\\n\",\n\t\t\t\tinfo->name, jiffies_to_msecs(ret));\n\telse\n\t\tCX18_DEBUG_HI_API(\"waited %u msecs for %s to be acked\\n\",\n\t\t\t\t  jiffies_to_msecs(ret), info->name);\n\n\t \n\tfor (i = 0; i < MAX_MB_ARGUMENTS; i++)\n\t\tdata[i] = cx18_readl(cx, &mb->args[i]);\n\terr = cx18_readl(cx, &mb->error);\n\tmutex_unlock(mb_lock);\n\n\t \n\tif (info->flags & API_SLOW)\n\t\tcx18_msleep_timeout(300, 0);\n\n\tif (err)\n\t\tCX18_DEBUG_API(\"mailbox error %08x for command %s\\n\", err,\n\t\t\t\tinfo->name);\n\treturn err ? -EIO : 0;\n}\n\nint cx18_api(struct cx18 *cx, u32 cmd, int args, u32 data[])\n{\n\treturn cx18_api_call(cx, cmd, args, data);\n}\n\nstatic int cx18_set_filter_param(struct cx18_stream *s)\n{\n\tstruct cx18 *cx = s->cx;\n\tu32 mode;\n\tint ret;\n\n\tmode = (cx->filter_mode & 1) ? 2 : (cx->spatial_strength ? 1 : 0);\n\tret = cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\n\t\t\ts->handle, 1, mode, cx->spatial_strength);\n\tmode = (cx->filter_mode & 2) ? 2 : (cx->temporal_strength ? 1 : 0);\n\tret = ret ? ret : cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\n\t\t\ts->handle, 0, mode, cx->temporal_strength);\n\tret = ret ? ret : cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\n\t\t\ts->handle, 2, cx->filter_mode >> 2, 0);\n\treturn ret;\n}\n\nint cx18_api_func(void *priv, u32 cmd, int in, int out,\n\t\tu32 data[CX2341X_MBOX_MAX_DATA])\n{\n\tstruct cx18_stream *s = priv;\n\tstruct cx18 *cx = s->cx;\n\n\tswitch (cmd) {\n\tcase CX2341X_ENC_SET_OUTPUT_PORT:\n\t\treturn 0;\n\tcase CX2341X_ENC_SET_FRAME_RATE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_IN, 6,\n\t\t\t\ts->handle, 0, 0, 0, 0, data[0]);\n\tcase CX2341X_ENC_SET_FRAME_SIZE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_RESOLUTION, 3,\n\t\t\t\ts->handle, data[1], data[0]);\n\tcase CX2341X_ENC_SET_STREAM_TYPE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_STREAM_OUTPUT_TYPE, 2,\n\t\t\t\ts->handle, data[0]);\n\tcase CX2341X_ENC_SET_ASPECT_RATIO:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_ASPECT_RATIO, 2,\n\t\t\t\ts->handle, data[0]);\n\n\tcase CX2341X_ENC_SET_GOP_PROPERTIES:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_GOP_STRUCTURE, 3,\n\t\t\t\ts->handle, data[0], data[1]);\n\tcase CX2341X_ENC_SET_GOP_CLOSURE:\n\t\treturn 0;\n\tcase CX2341X_ENC_SET_AUDIO_PROPERTIES:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_AUDIO_PARAMETERS, 2,\n\t\t\t\ts->handle, data[0]);\n\tcase CX2341X_ENC_MUTE_AUDIO:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2,\n\t\t\t\ts->handle, data[0]);\n\tcase CX2341X_ENC_SET_BIT_RATE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_RATE, 5,\n\t\t\t\ts->handle, data[0], data[1], data[2], data[3]);\n\tcase CX2341X_ENC_MUTE_VIDEO:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2,\n\t\t\t\ts->handle, data[0]);\n\tcase CX2341X_ENC_SET_FRAME_DROP_RATE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_SKIP_INPUT_FRAME, 2,\n\t\t\t\ts->handle, data[0]);\n\tcase CX2341X_ENC_MISC:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 4,\n\t\t\t\ts->handle, data[0], data[1], data[2]);\n\tcase CX2341X_ENC_SET_DNR_FILTER_MODE:\n\t\tcx->filter_mode = (data[0] & 3) | (data[1] << 2);\n\t\treturn cx18_set_filter_param(s);\n\tcase CX2341X_ENC_SET_DNR_FILTER_PROPS:\n\t\tcx->spatial_strength = data[0];\n\t\tcx->temporal_strength = data[1];\n\t\treturn cx18_set_filter_param(s);\n\tcase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_SPATIAL_FILTER_TYPE, 3,\n\t\t\t\ts->handle, data[0], data[1]);\n\tcase CX2341X_ENC_SET_CORING_LEVELS:\n\t\treturn cx18_vapi(cx, CX18_CPU_SET_MEDIAN_CORING, 5,\n\t\t\t\ts->handle, data[0], data[1], data[2], data[3]);\n\t}\n\tCX18_WARN(\"Unknown cmd %x\\n\", cmd);\n\treturn 0;\n}\n\nint cx18_vapi_result(struct cx18 *cx, u32 data[MAX_MB_ARGUMENTS],\n\t\tu32 cmd, int args, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, args);\n\tfor (i = 0; i < args; i++)\n\t\tdata[i] = va_arg(ap, u32);\n\tva_end(ap);\n\treturn cx18_api(cx, cmd, args, data);\n}\n\nint cx18_vapi(struct cx18 *cx, u32 cmd, int args, ...)\n{\n\tu32 data[MAX_MB_ARGUMENTS];\n\tva_list ap;\n\tint i;\n\n\tif (cx == NULL) {\n\t\tCX18_ERR(\"cx == NULL (cmd=%x)\\n\", cmd);\n\t\treturn 0;\n\t}\n\tif (args > MAX_MB_ARGUMENTS) {\n\t\tCX18_ERR(\"args too big (cmd=%x)\\n\", cmd);\n\t\targs = MAX_MB_ARGUMENTS;\n\t}\n\tva_start(ap, args);\n\tfor (i = 0; i < args; i++)\n\t\tdata[i] = va_arg(ap, u32);\n\tva_end(ap);\n\treturn cx18_api(cx, cmd, args, data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}