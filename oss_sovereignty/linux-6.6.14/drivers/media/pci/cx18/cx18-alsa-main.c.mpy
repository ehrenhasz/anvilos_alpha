{
  "module_name": "cx18-alsa-main.c",
  "hash_id": "05af621a51250c386c450ae2d07548558863cd14816e092ec6a6a7f751477a50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-alsa-main.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n\n#include <media/v4l2-device.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n\n#include \"cx18-driver.h\"\n#include \"cx18-version.h\"\n#include \"cx18-alsa.h\"\n#include \"cx18-alsa-pcm.h\"\n\nint cx18_alsa_debug;\n\n#define CX18_DEBUG_ALSA_INFO(fmt, arg...) \\\n\tdo { \\\n\t\tif (cx18_alsa_debug & 2) \\\n\t\t\tprintk(KERN_INFO \"%s: \" fmt, \"cx18-alsa\", ## arg); \\\n\t} while (0);\n\nmodule_param_named(debug, cx18_alsa_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"Debug level (bitmask). Default: 0\\n\"\n\t\t \"\\t\\t\\t  1/0x0001: warning\\n\"\n\t\t \"\\t\\t\\t  2/0x0002: info\\n\");\n\nMODULE_AUTHOR(\"Andy Walls\");\nMODULE_DESCRIPTION(\"CX23418 ALSA Interface\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_VERSION(CX18_VERSION);\n\nstatic inline\nstruct snd_cx18_card *to_snd_cx18_card(struct v4l2_device *v4l2_dev)\n{\n\treturn to_cx18(v4l2_dev)->alsa;\n}\n\nstatic void snd_cx18_card_free(struct snd_cx18_card *cxsc)\n{\n\tif (cxsc == NULL)\n\t\treturn;\n\n\tif (cxsc->v4l2_dev != NULL)\n\t\tto_cx18(cxsc->v4l2_dev)->alsa = NULL;\n\n\t \n\n\tkfree(cxsc);\n}\n\nstatic void snd_cx18_card_private_free(struct snd_card *sc)\n{\n\tif (sc == NULL)\n\t\treturn;\n\tsnd_cx18_card_free(sc->private_data);\n\tsc->private_data = NULL;\n\tsc->private_free = NULL;\n}\n\nstatic int snd_cx18_card_create(struct v4l2_device *v4l2_dev,\n\t\t\t\t       struct snd_card *sc,\n\t\t\t\t       struct snd_cx18_card **cxsc)\n{\n\t*cxsc = kzalloc(sizeof(struct snd_cx18_card), GFP_KERNEL);\n\tif (*cxsc == NULL)\n\t\treturn -ENOMEM;\n\n\t(*cxsc)->v4l2_dev = v4l2_dev;\n\t(*cxsc)->sc = sc;\n\n\tsc->private_data = *cxsc;\n\tsc->private_free = snd_cx18_card_private_free;\n\n\treturn 0;\n}\n\nstatic int snd_cx18_card_set_names(struct snd_cx18_card *cxsc)\n{\n\tstruct cx18 *cx = to_cx18(cxsc->v4l2_dev);\n\tstruct snd_card *sc = cxsc->sc;\n\n\t \n\tstrscpy(sc->driver, \"CX23418\", sizeof(sc->driver));\n\n\t \n\tsnprintf(sc->shortname,  sizeof(sc->shortname), \"CX18-%d\",\n\t\t cx->instance);\n\n\t \n\tsnprintf(sc->longname, sizeof(sc->longname),\n\t\t \"CX23418 #%d %s TV/FM Radio/Line-In Capture\",\n\t\t cx->instance, cx->card_name);\n\n\treturn 0;\n}\n\nstatic int snd_cx18_init(struct v4l2_device *v4l2_dev)\n{\n\tstruct cx18 *cx = to_cx18(v4l2_dev);\n\tstruct snd_card *sc = NULL;\n\tstruct snd_cx18_card *cxsc;\n\tint ret;\n\n\t \n\n\t \n\t \n\n\t \n\tret = snd_card_new(&cx->pci_dev->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1,  \n\t\t\t   SNDRV_DEFAULT_STR1,  \n\t\t\t   THIS_MODULE, 0, &sc);\n\tif (ret) {\n\t\tCX18_ALSA_ERR(\"%s: snd_card_new() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit;\n\t}\n\n\t \n\tret = snd_cx18_card_create(v4l2_dev, sc, &cxsc);\n\tif (ret) {\n\t\tCX18_ALSA_ERR(\"%s: snd_cx18_card_create() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit_free;\n\t}\n\n\t \n\tsnd_cx18_card_set_names(cxsc);\n\n\n\tret = snd_cx18_pcm_create(cxsc);\n\tif (ret) {\n\t\tCX18_ALSA_ERR(\"%s: snd_cx18_pcm_create() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit_free;\n\t}\n\t \n\n\t \n\t \n\tcx->alsa = cxsc;\n\n\t \n\tret = snd_card_register(sc);\n\tif (ret) {\n\t\tcx->alsa = NULL;\n\t\tCX18_ALSA_ERR(\"%s: snd_card_register() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit_free;\n\t}\n\n\treturn 0;\n\nerr_exit_free:\n\tif (sc != NULL)\n\t\tsnd_card_free(sc);\n\tkfree(cxsc);\nerr_exit:\n\treturn ret;\n}\n\nstatic int cx18_alsa_load(struct cx18 *cx)\n{\n\tstruct v4l2_device *v4l2_dev = &cx->v4l2_dev;\n\tstruct cx18_stream *s;\n\n\tif (v4l2_dev == NULL) {\n\t\tprintk(KERN_ERR \"cx18-alsa: %s: struct v4l2_device * is NULL\\n\",\n\t\t       __func__);\n\t\treturn 0;\n\t}\n\n\tcx = to_cx18(v4l2_dev);\n\tif (cx == NULL) {\n\t\tprintk(KERN_ERR \"cx18-alsa cx is NULL\\n\");\n\t\treturn 0;\n\t}\n\n\ts = &cx->streams[CX18_ENC_STREAM_TYPE_PCM];\n\tif (s->video_dev.v4l2_dev == NULL) {\n\t\tCX18_DEBUG_ALSA_INFO(\"%s: PCM stream for card is disabled - skipping\\n\",\n\t\t\t\t     __func__);\n\t\treturn 0;\n\t}\n\n\tif (cx->alsa != NULL) {\n\t\tCX18_ALSA_ERR(\"%s: struct snd_cx18_card * already exists\\n\",\n\t\t\t      __func__);\n\t\treturn 0;\n\t}\n\n\tif (snd_cx18_init(v4l2_dev)) {\n\t\tCX18_ALSA_ERR(\"%s: failed to create struct snd_cx18_card\\n\",\n\t\t\t      __func__);\n\t} else {\n\t\tCX18_DEBUG_ALSA_INFO(\"%s: created cx18 ALSA interface instance\\n\",\n\t\t\t\t     __func__);\n\t}\n\treturn 0;\n}\n\nstatic int __init cx18_alsa_init(void)\n{\n\tprintk(KERN_INFO \"cx18-alsa: module loading...\\n\");\n\tcx18_ext_init = &cx18_alsa_load;\n\treturn 0;\n}\n\nstatic void __exit snd_cx18_exit(struct snd_cx18_card *cxsc)\n{\n\tstruct cx18 *cx = to_cx18(cxsc->v4l2_dev);\n\n\t \n\n\tsnd_card_free(cxsc->sc);\n\tcx->alsa = NULL;\n}\n\nstatic int __exit cx18_alsa_exit_callback(struct device *dev, void *data)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct snd_cx18_card *cxsc;\n\n\tif (v4l2_dev == NULL) {\n\t\tprintk(KERN_ERR \"cx18-alsa: %s: struct v4l2_device * is NULL\\n\",\n\t\t       __func__);\n\t\treturn 0;\n\t}\n\n\tcxsc = to_snd_cx18_card(v4l2_dev);\n\tif (cxsc == NULL) {\n\t\tCX18_ALSA_WARN(\"%s: struct snd_cx18_card * is NULL\\n\",\n\t\t\t       __func__);\n\t\treturn 0;\n\t}\n\n\tsnd_cx18_exit(cxsc);\n\treturn 0;\n}\n\nstatic void __exit cx18_alsa_exit(void)\n{\n\tstruct device_driver *drv;\n\tint ret;\n\n\tprintk(KERN_INFO \"cx18-alsa: module unloading...\\n\");\n\n\tdrv = driver_find(\"cx18\", &pci_bus_type);\n\tret = driver_for_each_device(drv, NULL, NULL, cx18_alsa_exit_callback);\n\t(void)ret;\t \n\n\tcx18_ext_init = NULL;\n\tprintk(KERN_INFO \"cx18-alsa: module unload complete\\n\");\n}\n\nmodule_init(cx18_alsa_init);\nmodule_exit(cx18_alsa_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}