{
  "module_name": "cx18-io.h",
  "hash_id": "75b447a7abed86bf04390bc95c7f59e70165931776b3647f7dbd007b4280eff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-io.h",
  "human_readable_source": " \n \n\n#ifndef CX18_IO_H\n#define CX18_IO_H\n\n#include \"cx18-driver.h\"\n\n \n\n \nstatic inline u32 cx18_raw_readl(struct cx18 *cx, const void __iomem *addr)\n{\n\treturn __raw_readl(addr);\n}\n\nstatic inline\nvoid cx18_raw_writel_noretry(struct cx18 *cx, u32 val, void __iomem *addr)\n{\n\t__raw_writel(val, addr);\n}\n\nstatic inline void cx18_raw_writel(struct cx18 *cx, u32 val, void __iomem *addr)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_MMIO_WR_RETRIES; i++) {\n\t\tcx18_raw_writel_noretry(cx, val, addr);\n\t\tif (val == cx18_raw_readl(cx, addr))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic inline u32 cx18_readl(struct cx18 *cx, const void __iomem *addr)\n{\n\treturn readl(addr);\n}\n\nstatic inline\nvoid cx18_writel_noretry(struct cx18 *cx, u32 val, void __iomem *addr)\n{\n\twritel(val, addr);\n}\n\nstatic inline void cx18_writel(struct cx18 *cx, u32 val, void __iomem *addr)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_MMIO_WR_RETRIES; i++) {\n\t\tcx18_writel_noretry(cx, val, addr);\n\t\tif (val == cx18_readl(cx, addr))\n\t\t\tbreak;\n\t}\n}\n\nstatic inline\nvoid cx18_writel_expect(struct cx18 *cx, u32 val, void __iomem *addr,\n\t\t\tu32 eval, u32 mask)\n{\n\tint i;\n\tu32 r;\n\teval &= mask;\n\tfor (i = 0; i < CX18_MAX_MMIO_WR_RETRIES; i++) {\n\t\tcx18_writel_noretry(cx, val, addr);\n\t\tr = cx18_readl(cx, addr);\n\t\tif (r == 0xffffffff && eval != 0xffffffff)\n\t\t\tcontinue;\n\t\tif (eval == (r & mask))\n\t\t\tbreak;\n\t}\n}\n\nstatic inline u16 cx18_readw(struct cx18 *cx, const void __iomem *addr)\n{\n\treturn readw(addr);\n}\n\nstatic inline\nvoid cx18_writew_noretry(struct cx18 *cx, u16 val, void __iomem *addr)\n{\n\twritew(val, addr);\n}\n\nstatic inline void cx18_writew(struct cx18 *cx, u16 val, void __iomem *addr)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_MMIO_WR_RETRIES; i++) {\n\t\tcx18_writew_noretry(cx, val, addr);\n\t\tif (val == cx18_readw(cx, addr))\n\t\t\tbreak;\n\t}\n}\n\nstatic inline u8 cx18_readb(struct cx18 *cx, const void __iomem *addr)\n{\n\treturn readb(addr);\n}\n\nstatic inline\nvoid cx18_writeb_noretry(struct cx18 *cx, u8 val, void __iomem *addr)\n{\n\twriteb(val, addr);\n}\n\nstatic inline void cx18_writeb(struct cx18 *cx, u8 val, void __iomem *addr)\n{\n\tint i;\n\tfor (i = 0; i < CX18_MAX_MMIO_WR_RETRIES; i++) {\n\t\tcx18_writeb_noretry(cx, val, addr);\n\t\tif (val == cx18_readb(cx, addr))\n\t\t\tbreak;\n\t}\n}\n\nstatic inline\nvoid cx18_memcpy_fromio(struct cx18 *cx, void *to,\n\t\t\tconst void __iomem *from, unsigned int len)\n{\n\tmemcpy_fromio(to, from, len);\n}\n\nvoid cx18_memset_io(struct cx18 *cx, void __iomem *addr, int val, size_t count);\n\n\n \nstatic inline void cx18_write_reg_noretry(struct cx18 *cx, u32 val, u32 reg)\n{\n\tcx18_writel_noretry(cx, val, cx->reg_mem + reg);\n}\n\nstatic inline void cx18_write_reg(struct cx18 *cx, u32 val, u32 reg)\n{\n\tcx18_writel(cx, val, cx->reg_mem + reg);\n}\n\nstatic inline void cx18_write_reg_expect(struct cx18 *cx, u32 val, u32 reg,\n\t\t\t\t\t u32 eval, u32 mask)\n{\n\tcx18_writel_expect(cx, val, cx->reg_mem + reg, eval, mask);\n}\n\nstatic inline u32 cx18_read_reg(struct cx18 *cx, u32 reg)\n{\n\treturn cx18_readl(cx, cx->reg_mem + reg);\n}\n\n\n \nstatic inline void cx18_write_enc(struct cx18 *cx, u32 val, u32 addr)\n{\n\tcx18_writel(cx, val, cx->enc_mem + addr);\n}\n\nstatic inline u32 cx18_read_enc(struct cx18 *cx, u32 addr)\n{\n\treturn cx18_readl(cx, cx->enc_mem + addr);\n}\n\nvoid cx18_sw1_irq_enable(struct cx18 *cx, u32 val);\nvoid cx18_sw1_irq_disable(struct cx18 *cx, u32 val);\nvoid cx18_sw2_irq_enable(struct cx18 *cx, u32 val);\nvoid cx18_sw2_irq_disable(struct cx18 *cx, u32 val);\nvoid cx18_sw2_irq_disable_cpu(struct cx18 *cx, u32 val);\nvoid cx18_setup_page(struct cx18 *cx, u32 addr);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}