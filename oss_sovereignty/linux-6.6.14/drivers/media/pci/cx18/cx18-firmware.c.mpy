{
  "module_name": "cx18-firmware.c",
  "hash_id": "d9a052ffe16bfbde275fde6c6e43d8f84c45495bffeef700e4bb609712a08891",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-firmware.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-scb.h\"\n#include \"cx18-irq.h\"\n#include \"cx18-firmware.h\"\n#include \"cx18-cards.h\"\n#include <linux/firmware.h>\n\n#define CX18_PROC_SOFT_RESET\t\t0xc70010\n#define CX18_DDR_SOFT_RESET\t\t0xc70014\n#define CX18_CLOCK_SELECT1\t\t0xc71000\n#define CX18_CLOCK_SELECT2\t\t0xc71004\n#define CX18_HALF_CLOCK_SELECT1\t\t0xc71008\n#define CX18_HALF_CLOCK_SELECT2\t\t0xc7100C\n#define CX18_CLOCK_POLARITY1\t\t0xc71010\n#define CX18_CLOCK_POLARITY2\t\t0xc71014\n#define CX18_ADD_DELAY_ENABLE1\t\t0xc71018\n#define CX18_ADD_DELAY_ENABLE2\t\t0xc7101C\n#define CX18_CLOCK_ENABLE1\t\t0xc71020\n#define CX18_CLOCK_ENABLE2\t\t0xc71024\n\n#define CX18_REG_BUS_TIMEOUT_EN\t\t0xc72024\n\n#define CX18_FAST_CLOCK_PLL_INT\t\t0xc78000\n#define CX18_FAST_CLOCK_PLL_FRAC\t0xc78004\n#define CX18_FAST_CLOCK_PLL_POST\t0xc78008\n#define CX18_FAST_CLOCK_PLL_PRESCALE\t0xc7800C\n#define CX18_FAST_CLOCK_PLL_ADJUST_BANDWIDTH 0xc78010\n\n#define CX18_SLOW_CLOCK_PLL_INT\t\t0xc78014\n#define CX18_SLOW_CLOCK_PLL_FRAC\t0xc78018\n#define CX18_SLOW_CLOCK_PLL_POST\t0xc7801C\n#define CX18_MPEG_CLOCK_PLL_INT\t\t0xc78040\n#define CX18_MPEG_CLOCK_PLL_FRAC\t0xc78044\n#define CX18_MPEG_CLOCK_PLL_POST\t0xc78048\n#define CX18_PLL_POWER_DOWN\t\t0xc78088\n#define CX18_SW1_INT_STATUS             0xc73104\n#define CX18_SW1_INT_ENABLE_PCI         0xc7311C\n#define CX18_SW2_INT_SET                0xc73140\n#define CX18_SW2_INT_STATUS             0xc73144\n#define CX18_ADEC_CONTROL\t\t0xc78120\n\n#define CX18_DDR_REQUEST_ENABLE\t\t0xc80000\n#define CX18_DDR_CHIP_CONFIG\t\t0xc80004\n#define CX18_DDR_REFRESH\t\t0xc80008\n#define CX18_DDR_TIMING1\t\t0xc8000C\n#define CX18_DDR_TIMING2\t\t0xc80010\n#define CX18_DDR_POWER_REG\t\t0xc8001C\n\n#define CX18_DDR_TUNE_LANE\t\t0xc80048\n#define CX18_DDR_INITIAL_EMRS\t\t0xc80054\n#define CX18_DDR_MB_PER_ROW_7\t\t0xc8009C\n#define CX18_DDR_BASE_63_ADDR\t\t0xc804FC\n\n#define CX18_WMB_CLIENT02\t\t0xc90108\n#define CX18_WMB_CLIENT05\t\t0xc90114\n#define CX18_WMB_CLIENT06\t\t0xc90118\n#define CX18_WMB_CLIENT07\t\t0xc9011C\n#define CX18_WMB_CLIENT08\t\t0xc90120\n#define CX18_WMB_CLIENT09\t\t0xc90124\n#define CX18_WMB_CLIENT10\t\t0xc90128\n#define CX18_WMB_CLIENT11\t\t0xc9012C\n#define CX18_WMB_CLIENT12\t\t0xc90130\n#define CX18_WMB_CLIENT13\t\t0xc90134\n#define CX18_WMB_CLIENT14\t\t0xc90138\n\n#define CX18_DSP0_INTERRUPT_MASK\t0xd0004C\n\n#define APU_ROM_SYNC1 0x6D676553  \n#define APU_ROM_SYNC2 0x72646548  \n\nstruct cx18_apu_rom_seghdr {\n\tu32 sync1;\n\tu32 sync2;\n\tu32 addr;\n\tu32 size;\n};\n\nstatic int load_cpu_fw_direct(const char *fn, u8 __iomem *mem, struct cx18 *cx)\n{\n\tconst struct firmware *fw = NULL;\n\tint i, j;\n\tunsigned size;\n\tu32 __iomem *dst = (u32 __iomem *)mem;\n\tconst u32 *src;\n\n\tif (request_firmware(&fw, fn, &cx->pci_dev->dev)) {\n\t\tCX18_ERR(\"Unable to open firmware %s\\n\", fn);\n\t\tCX18_ERR(\"Did you put the firmware in the hotplug firmware directory?\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsrc = (const u32 *)fw->data;\n\n\tfor (i = 0; i < fw->size; i += 4096) {\n\t\tcx18_setup_page(cx, i);\n\t\tfor (j = i; j < fw->size && j < i + 4096; j += 4) {\n\t\t\t \n\t\t\tcx18_raw_writel(cx, *src, dst);\n\t\t\tif (cx18_raw_readl(cx, dst) != *src) {\n\t\t\t\tCX18_ERR(\"Mismatch at offset %x\\n\", i);\n\t\t\t\trelease_firmware(fw);\n\t\t\t\tcx18_setup_page(cx, 0);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tdst++;\n\t\t\tsrc++;\n\t\t}\n\t}\n\tif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags))\n\t\tCX18_INFO(\"loaded %s firmware (%zu bytes)\\n\", fn, fw->size);\n\tsize = fw->size;\n\trelease_firmware(fw);\n\tcx18_setup_page(cx, SCB_OFFSET);\n\treturn size;\n}\n\nstatic int load_apu_fw_direct(const char *fn, u8 __iomem *dst, struct cx18 *cx,\n\t\t\t\tu32 *entry_addr)\n{\n\tconst struct firmware *fw = NULL;\n\tint i, j;\n\tunsigned size;\n\tconst u32 *src;\n\tstruct cx18_apu_rom_seghdr seghdr;\n\tconst u8 *vers;\n\tu32 offset = 0;\n\tu32 apu_version = 0;\n\tint sz;\n\n\tif (request_firmware(&fw, fn, &cx->pci_dev->dev)) {\n\t\tCX18_ERR(\"unable to open firmware %s\\n\", fn);\n\t\tCX18_ERR(\"did you put the firmware in the hotplug firmware directory?\\n\");\n\t\tcx18_setup_page(cx, 0);\n\t\treturn -ENOMEM;\n\t}\n\n\t*entry_addr = 0;\n\tsrc = (const u32 *)fw->data;\n\tvers = fw->data + sizeof(seghdr);\n\tsz = fw->size;\n\n\tapu_version = (vers[0] << 24) | (vers[4] << 16) | vers[32];\n\twhile (offset + sizeof(seghdr) < fw->size) {\n\t\tconst __le32 *shptr = (__force __le32 *)src + offset / 4;\n\n\t\tseghdr.sync1 = le32_to_cpu(shptr[0]);\n\t\tseghdr.sync2 = le32_to_cpu(shptr[1]);\n\t\tseghdr.addr = le32_to_cpu(shptr[2]);\n\t\tseghdr.size = le32_to_cpu(shptr[3]);\n\n\t\toffset += sizeof(seghdr);\n\t\tif (seghdr.sync1 != APU_ROM_SYNC1 ||\n\t\t    seghdr.sync2 != APU_ROM_SYNC2) {\n\t\t\toffset += seghdr.size;\n\t\t\tcontinue;\n\t\t}\n\t\tCX18_DEBUG_INFO(\"load segment %x-%x\\n\", seghdr.addr,\n\t\t\t\tseghdr.addr + seghdr.size - 1);\n\t\tif (*entry_addr == 0)\n\t\t\t*entry_addr = seghdr.addr;\n\t\tif (offset + seghdr.size > sz)\n\t\t\tbreak;\n\t\tfor (i = 0; i < seghdr.size; i += 4096) {\n\t\t\tcx18_setup_page(cx, seghdr.addr + i);\n\t\t\tfor (j = i; j < seghdr.size && j < i + 4096; j += 4) {\n\t\t\t\t \n\t\t\t\tcx18_raw_writel(cx, src[(offset + j) / 4],\n\t\t\t\t\t\tdst + seghdr.addr + j);\n\t\t\t\tif (cx18_raw_readl(cx, dst + seghdr.addr + j)\n\t\t\t\t    != src[(offset + j) / 4]) {\n\t\t\t\t\tCX18_ERR(\"Mismatch at offset %x\\n\",\n\t\t\t\t\t\t offset + j);\n\t\t\t\t\trelease_firmware(fw);\n\t\t\t\t\tcx18_setup_page(cx, 0);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toffset += seghdr.size;\n\t}\n\tif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags))\n\t\tCX18_INFO(\"loaded %s firmware V%08x (%zu bytes)\\n\",\n\t\t\t\tfn, apu_version, fw->size);\n\tsize = fw->size;\n\trelease_firmware(fw);\n\tcx18_setup_page(cx, 0);\n\treturn size;\n}\n\nvoid cx18_halt_firmware(struct cx18 *cx)\n{\n\tCX18_DEBUG_INFO(\"Preparing for firmware halt.\\n\");\n\tcx18_write_reg_expect(cx, 0x000F000F, CX18_PROC_SOFT_RESET,\n\t\t\t\t  0x0000000F, 0x000F000F);\n\tcx18_write_reg_expect(cx, 0x00020002, CX18_ADEC_CONTROL,\n\t\t\t\t  0x00000002, 0x00020002);\n}\n\nvoid cx18_init_power(struct cx18 *cx, int lowpwr)\n{\n\t \n\t \n\tcx18_write_reg(cx, 0x00000008, CX18_PLL_POWER_DOWN);\n\n\t \n\tcx18_write_reg_expect(cx, 0x00020000, CX18_ADEC_CONTROL,\n\t\t\t\t  0x00000000, 0x00020002);\n\n\t \n\n\t \n\t \n\t \n\tcx18_write_reg(cx, lowpwr ? 0xD : 0x11, CX18_FAST_CLOCK_PLL_INT);\n\tcx18_write_reg(cx, lowpwr ? 0x1EFBF37 : 0x038E3D7,\n\t\t\t\t\t\tCX18_FAST_CLOCK_PLL_FRAC);\n\n\tcx18_write_reg(cx, 2, CX18_FAST_CLOCK_PLL_POST);\n\tcx18_write_reg(cx, 1, CX18_FAST_CLOCK_PLL_PRESCALE);\n\tcx18_write_reg(cx, 4, CX18_FAST_CLOCK_PLL_ADJUST_BANDWIDTH);\n\n\t \n\t \n\t \n\tcx18_write_reg(cx, lowpwr ? 0xD : 0xC, CX18_SLOW_CLOCK_PLL_INT);\n\tcx18_write_reg(cx, lowpwr ? 0x30C344 : 0x124927F,\n\t\t\t\t\t\tCX18_SLOW_CLOCK_PLL_FRAC);\n\tcx18_write_reg(cx, 3, CX18_SLOW_CLOCK_PLL_POST);\n\n\t \n\t \n\tcx18_write_reg(cx, 0xF, CX18_MPEG_CLOCK_PLL_INT);\n\tcx18_write_reg(cx, 0x2BE2FE, CX18_MPEG_CLOCK_PLL_FRAC);\n\tcx18_write_reg(cx, 8, CX18_MPEG_CLOCK_PLL_POST);\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\tif (lowpwr) {\n\t\tcx18_write_reg_expect(cx, 0xFFFF0020, CX18_CLOCK_SELECT1,\n\t\t\t\t\t  0x00000020, 0xFFFFFFFF);\n\t\tcx18_write_reg_expect(cx, 0xFFFF0004, CX18_CLOCK_SELECT2,\n\t\t\t\t\t  0x00000004, 0xFFFFFFFF);\n\t} else {\n\t\t \n\t\tcx18_write_reg_expect(cx, 0x00060004, CX18_CLOCK_SELECT1,\n\t\t\t\t\t  0x00000004, 0x00060006);\n\t\tcx18_write_reg_expect(cx, 0x00060006, CX18_CLOCK_SELECT2,\n\t\t\t\t\t  0x00000006, 0x00060006);\n\t}\n\n\tcx18_write_reg_expect(cx, 0xFFFF0002, CX18_HALF_CLOCK_SELECT1,\n\t\t\t\t  0x00000002, 0xFFFFFFFF);\n\tcx18_write_reg_expect(cx, 0xFFFF0104, CX18_HALF_CLOCK_SELECT2,\n\t\t\t\t  0x00000104, 0xFFFFFFFF);\n\tcx18_write_reg_expect(cx, 0xFFFF9026, CX18_CLOCK_ENABLE1,\n\t\t\t\t  0x00009026, 0xFFFFFFFF);\n\tcx18_write_reg_expect(cx, 0xFFFF3105, CX18_CLOCK_ENABLE2,\n\t\t\t\t  0x00003105, 0xFFFFFFFF);\n}\n\nvoid cx18_init_memory(struct cx18 *cx)\n{\n\tcx18_msleep_timeout(10, 0);\n\tcx18_write_reg_expect(cx, 0x00010000, CX18_DDR_SOFT_RESET,\n\t\t\t\t  0x00000000, 0x00010001);\n\tcx18_msleep_timeout(10, 0);\n\n\tcx18_write_reg(cx, cx->card->ddr.chip_config, CX18_DDR_CHIP_CONFIG);\n\n\tcx18_msleep_timeout(10, 0);\n\n\tcx18_write_reg(cx, cx->card->ddr.refresh, CX18_DDR_REFRESH);\n\tcx18_write_reg(cx, cx->card->ddr.timing1, CX18_DDR_TIMING1);\n\tcx18_write_reg(cx, cx->card->ddr.timing2, CX18_DDR_TIMING2);\n\n\tcx18_msleep_timeout(10, 0);\n\n\t \n\tcx18_write_reg(cx, cx->card->ddr.tune_lane, CX18_DDR_TUNE_LANE);\n\tcx18_write_reg(cx, cx->card->ddr.initial_emrs, CX18_DDR_INITIAL_EMRS);\n\n\tcx18_msleep_timeout(10, 0);\n\n\tcx18_write_reg_expect(cx, 0x00020000, CX18_DDR_SOFT_RESET,\n\t\t\t\t  0x00000000, 0x00020002);\n\tcx18_msleep_timeout(10, 0);\n\n\t \n\tcx18_write_reg(cx, 0x00000010, CX18_DDR_POWER_REG);\n\n\tcx18_write_reg_expect(cx, 0x00010001, CX18_REG_BUS_TIMEOUT_EN,\n\t\t\t\t  0x00000001, 0x00010001);\n\n\tcx18_write_reg(cx, 0x48, CX18_DDR_MB_PER_ROW_7);\n\tcx18_write_reg(cx, 0xE0000, CX18_DDR_BASE_63_ADDR);\n\n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT02);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT09);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT05);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT06);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT07);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT10);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT12);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT13);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT11);   \n\tcx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT14);   \n}\n\n#define CX18_CPU_FIRMWARE \"v4l-cx23418-cpu.fw\"\n#define CX18_APU_FIRMWARE \"v4l-cx23418-apu.fw\"\n\nint cx18_firmware_init(struct cx18 *cx)\n{\n\tu32 fw_entry_addr;\n\tint sz, retries;\n\tu32 api_args[MAX_MB_ARGUMENTS];\n\n\t \n\tcx18_write_reg(cx, 0x5, CX18_DSP0_INTERRUPT_MASK);\n\n\t \n\tcx18_write_reg_expect(cx, 0x000F000F, CX18_PROC_SOFT_RESET,\n\t\t\t\t  0x0000000F, 0x000F000F);\n\n\tcx18_msleep_timeout(1, 0);\n\n\t \n\tif ((cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 8) == 0) {\n\t\tCX18_ERR(\"%s: couldn't stop CPU to load firmware\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tcx18_sw1_irq_enable(cx, IRQ_CPU_TO_EPU | IRQ_APU_TO_EPU);\n\tcx18_sw2_irq_enable(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\n\n\tsz = load_cpu_fw_direct(CX18_CPU_FIRMWARE, cx->enc_mem, cx);\n\tif (sz <= 0)\n\t\treturn sz;\n\n\t \n\tcx18_init_scb(cx);\n\n\tfw_entry_addr = 0;\n\tsz = load_apu_fw_direct(CX18_APU_FIRMWARE, cx->enc_mem, cx,\n\t\t\t\t&fw_entry_addr);\n\tif (sz <= 0)\n\t\treturn sz;\n\n\t \n\tcx18_write_reg_expect(cx, 0x00080000, CX18_PROC_SOFT_RESET,\n\t\t\t\t  0x00000000, 0x00080008);\n\n\t \n\tfor (retries = 0;\n\t     retries < 50 && (cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 1) == 1;\n\t     retries++)\n\t\tcx18_msleep_timeout(10, 0);\n\n\tcx18_msleep_timeout(200, 0);\n\n\tif (retries == 50 &&\n\t    (cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 1) == 1) {\n\t\tCX18_ERR(\"Could not start the CPU\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tcx18_sw2_irq_disable_cpu(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\n\n\t \n\tsz = cx18_vapi_result(cx, api_args, CX18_CPU_DEBUG_PEEK32, 1, 0);\n\tif (sz < 0)\n\t\treturn sz;\n\n\t \n\tcx18_write_reg_expect(cx, 0x14001400, 0xc78110, 0x00001400, 0x14001400);\n\treturn 0;\n}\n\nMODULE_FIRMWARE(CX18_CPU_FIRMWARE);\nMODULE_FIRMWARE(CX18_APU_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}