{
  "module_name": "cx18-alsa-pcm.c",
  "hash_id": "56b92db112313462694e8d067493205d1233d292426587f3175e1a6fd23d05f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-alsa-pcm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#include <media/v4l2-device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"cx18-driver.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-fileops.h\"\n#include \"cx18-alsa.h\"\n#include \"cx18-alsa-pcm.h\"\n\nstatic unsigned int pcm_debug;\nmodule_param(pcm_debug, int, 0644);\nMODULE_PARM_DESC(pcm_debug, \"enable debug messages for pcm\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\t    if (pcm_debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_INFO \"cx18-alsa-pcm %s: \" fmt,\t\t\\\n\t\t\t\t  __func__, ##arg);\t\t\t\\\n\t} while (0)\n\nstatic const struct snd_pcm_hardware snd_cx18_hw_capture = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP           |\n\t\tSNDRV_PCM_INFO_INTERLEAVED    |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 62720 * 8,\t \n\t.period_bytes_min = 64,\t\t \n\t.period_bytes_max = 12544,\n\t.periods_min = 2,\n\t.periods_max = 98,\t\t \n};\n\nvoid cx18_alsa_announce_pcm_data(struct snd_cx18_card *cxsc, u8 *pcm_data,\n\t\t\t\t size_t num_bytes)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int oldptr;\n\tunsigned int stride;\n\tint period_elapsed = 0;\n\tint length;\n\n\tdprintk(\"cx18 alsa announce ptr=%p data=%p num_bytes=%zu\\n\", cxsc,\n\t\tpcm_data, num_bytes);\n\n\tsubstream = cxsc->capture_pcm_substream;\n\tif (substream == NULL) {\n\t\tdprintk(\"substream was NULL\\n\");\n\t\treturn;\n\t}\n\n\truntime = substream->runtime;\n\tif (runtime == NULL) {\n\t\tdprintk(\"runtime was NULL\\n\");\n\t\treturn;\n\t}\n\n\tstride = runtime->frame_bits >> 3;\n\tif (stride == 0) {\n\t\tdprintk(\"stride is zero\\n\");\n\t\treturn;\n\t}\n\n\tlength = num_bytes / stride;\n\tif (length == 0) {\n\t\tdprintk(\"%s: length was zero\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (runtime->dma_area == NULL) {\n\t\tdprintk(\"dma area was NULL - ignoring\\n\");\n\t\treturn;\n\t}\n\n\toldptr = cxsc->hwptr_done_capture;\n\tif (oldptr + length >= runtime->buffer_size) {\n\t\tunsigned int cnt =\n\t\t\truntime->buffer_size - oldptr;\n\t\tmemcpy(runtime->dma_area + oldptr * stride, pcm_data,\n\t\t       cnt * stride);\n\t\tmemcpy(runtime->dma_area, pcm_data + cnt * stride,\n\t\t       length * stride - cnt * stride);\n\t} else {\n\t\tmemcpy(runtime->dma_area + oldptr * stride, pcm_data,\n\t\t       length * stride);\n\t}\n\tsnd_pcm_stream_lock(substream);\n\n\tcxsc->hwptr_done_capture += length;\n\tif (cxsc->hwptr_done_capture >=\n\t    runtime->buffer_size)\n\t\tcxsc->hwptr_done_capture -=\n\t\t\truntime->buffer_size;\n\n\tcxsc->capture_transfer_done += length;\n\tif (cxsc->capture_transfer_done >=\n\t    runtime->period_size) {\n\t\tcxsc->capture_transfer_done -=\n\t\t\truntime->period_size;\n\t\tperiod_elapsed = 1;\n\t}\n\n\tsnd_pcm_stream_unlock(substream);\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int snd_cx18_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cx18_card *cxsc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct v4l2_device *v4l2_dev = cxsc->v4l2_dev;\n\tstruct cx18 *cx = to_cx18(v4l2_dev);\n\tstruct cx18_stream *s;\n\tstruct cx18_open_id item;\n\tint ret;\n\n\t \n\tsnd_cx18_lock(cxsc);\n\ts = &cx->streams[CX18_ENC_STREAM_TYPE_PCM];\n\n\titem.cx = cx;\n\titem.type = s->type;\n\titem.open_id = cx->open_id++;\n\n\t \n\tif (cx18_claim_stream(&item, item.type)) {\n\t\t \n\t\tsnd_cx18_unlock(cxsc);\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(CX18_F_S_STREAMOFF, &s->s_flags) ||\n\t    test_and_set_bit(CX18_F_S_STREAMING, &s->s_flags)) {\n\t\t \n\t\tsnd_cx18_unlock(cxsc);\n\t\treturn 0;\n\t}\n\n\n\truntime->hw = snd_cx18_hw_capture;\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tcxsc->capture_pcm_substream = substream;\n\truntime->private_data = cx;\n\n\tcx->pcm_announce_callback = cx18_alsa_announce_pcm_data;\n\n\t \n\tset_bit(CX18_F_S_STREAMING, &s->s_flags);\n\tret = cx18_start_v4l2_encode_stream(s);\n\tsnd_cx18_unlock(cxsc);\n\n\treturn ret;\n}\n\nstatic int snd_cx18_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cx18_card *cxsc = snd_pcm_substream_chip(substream);\n\tstruct v4l2_device *v4l2_dev = cxsc->v4l2_dev;\n\tstruct cx18 *cx = to_cx18(v4l2_dev);\n\tstruct cx18_stream *s;\n\n\t \n\tsnd_cx18_lock(cxsc);\n\ts = &cx->streams[CX18_ENC_STREAM_TYPE_PCM];\n\tcx18_stop_v4l2_encode_stream(s, 0);\n\tclear_bit(CX18_F_S_STREAMING, &s->s_flags);\n\n\tcx18_release_stream(s);\n\n\tcx->pcm_announce_callback = NULL;\n\tsnd_cx18_unlock(cxsc);\n\n\treturn 0;\n}\n\nstatic int snd_cx18_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cx18_card *cxsc = snd_pcm_substream_chip(substream);\n\n\tcxsc->hwptr_done_capture = 0;\n\tcxsc->capture_transfer_done = 0;\n\n\treturn 0;\n}\n\nstatic int snd_cx18_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\treturn 0;\n}\n\nstatic\nsnd_pcm_uframes_t snd_cx18_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_pcm_uframes_t hwptr_done;\n\tstruct snd_cx18_card *cxsc = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irqsave(&cxsc->slock, flags);\n\thwptr_done = cxsc->hwptr_done_capture;\n\tspin_unlock_irqrestore(&cxsc->slock, flags);\n\n\treturn hwptr_done;\n}\n\nstatic const struct snd_pcm_ops snd_cx18_pcm_capture_ops = {\n\t.open\t\t= snd_cx18_pcm_capture_open,\n\t.close\t\t= snd_cx18_pcm_capture_close,\n\t.prepare\t= snd_cx18_pcm_prepare,\n\t.trigger\t= snd_cx18_pcm_trigger,\n\t.pointer\t= snd_cx18_pcm_pointer,\n};\n\nint snd_cx18_pcm_create(struct snd_cx18_card *cxsc)\n{\n\tstruct snd_pcm *sp;\n\tstruct snd_card *sc = cxsc->sc;\n\tstruct v4l2_device *v4l2_dev = cxsc->v4l2_dev;\n\tstruct cx18 *cx = to_cx18(v4l2_dev);\n\tint ret;\n\n\tret = snd_pcm_new(sc, \"CX23418 PCM\",\n\t\t\t  0,  \n\t\t\t  0,  \n\t\t\t  1,  \n\t\t\t  &sp);\n\tif (ret) {\n\t\tCX18_ALSA_ERR(\"%s: snd_cx18_pcm_create() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit;\n\t}\n\n\tspin_lock_init(&cxsc->slock);\n\n\tsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_cx18_pcm_capture_ops);\n\tsnd_pcm_set_managed_buffer_all(sp, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\tsp->info_flags = 0;\n\tsp->private_data = cxsc;\n\tstrscpy(sp->name, cx->card_name, sizeof(sp->name));\n\n\treturn 0;\n\nerr_exit:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}