{
  "module_name": "cx18-i2c.c",
  "hash_id": "12b3dee642cb67954a404da3e3d7e614b66640d786a8bcbc0ad12e65c83e569e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-i2c.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-gpio.h\"\n#include \"cx18-i2c.h\"\n#include \"cx18-irq.h\"\n\n#define CX18_REG_I2C_1_WR   0xf15000\n#define CX18_REG_I2C_1_RD   0xf15008\n#define CX18_REG_I2C_2_WR   0xf25100\n#define CX18_REG_I2C_2_RD   0xf25108\n\n#define SETSCL_BIT      0x0001\n#define SETSDL_BIT      0x0002\n#define GETSCL_BIT      0x0004\n#define GETSDL_BIT      0x0008\n\n#define CX18_CS5345_I2C_ADDR\t\t0x4c\n#define CX18_Z8F0811_IR_TX_I2C_ADDR\t0x70\n#define CX18_Z8F0811_IR_RX_I2C_ADDR\t0x71\n\n \nstatic const u8 hw_addrs[] = {\n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\tCX18_CS5345_I2C_ADDR,\t\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\tCX18_Z8F0811_IR_RX_I2C_ADDR,\t \n};\n\n \n \nstatic const u8 hw_bus[] = {\n\t1,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n};\n\n \nstatic const char * const hw_devicenames[] = {\n\t\"tuner\",\n\t\"tveeprom\",\n\t\"cs5345\",\n\t\"cx23418_DTV\",\n\t\"cx23418_AV\",\n\t\"gpio_mux\",\n\t\"gpio_reset_ctrl\",\n\t\"ir_z8f0811_haup\",\n};\n\nstatic int cx18_i2c_new_ir(struct cx18 *cx, struct i2c_adapter *adap, u32 hw,\n\t\t\t   const char *type, u8 addr)\n{\n\tstruct i2c_board_info info;\n\tstruct IR_i2c_init_data *init_data = &cx->ir_i2c_init_data;\n\tunsigned short addr_list[2] = { addr, I2C_CLIENT_END };\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(info.type, type, I2C_NAME_SIZE);\n\n\t \n\tswitch (hw) {\n\tcase CX18_HW_Z8F0811_IR_HAUP:\n\t\tinit_data->ir_codes = RC_MAP_HAUPPAUGE;\n\t\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\t\tinit_data->type = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t\t\tRC_PROTO_BIT_RC6_6A_32;\n\t\tinit_data->name = cx->card_name;\n\t\tinfo.platform_data = init_data;\n\t\tbreak;\n\t}\n\n\treturn IS_ERR(i2c_new_scanned_device(adap, &info, addr_list, NULL)) ?\n\t       -1 : 0;\n}\n\nint cx18_i2c_register(struct cx18 *cx, unsigned idx)\n{\n\tstruct v4l2_subdev *sd;\n\tint bus = hw_bus[idx];\n\tstruct i2c_adapter *adap = &cx->i2c_adap[bus];\n\tconst char *type = hw_devicenames[idx];\n\tu32 hw = 1 << idx;\n\n\tif (hw == CX18_HW_TUNER) {\n\t\t \n\t\tsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\n\t\t\t\tadap, type, 0, cx->card_i2c->radio);\n\t\tif (sd != NULL)\n\t\t\tsd->grp_id = hw;\n\t\tsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\n\t\t\t\tadap, type, 0, cx->card_i2c->demod);\n\t\tif (sd != NULL)\n\t\t\tsd->grp_id = hw;\n\t\tsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\n\t\t\t\tadap, type, 0, cx->card_i2c->tv);\n\t\tif (sd != NULL)\n\t\t\tsd->grp_id = hw;\n\t\treturn sd != NULL ? 0 : -1;\n\t}\n\n\tif (hw == CX18_HW_Z8F0811_IR_HAUP)\n\t\treturn cx18_i2c_new_ir(cx, adap, hw, type, hw_addrs[idx]);\n\n\t \n\tif (!hw_addrs[idx])\n\t\treturn -1;\n\n\t \n\tsd = v4l2_i2c_new_subdev(&cx->v4l2_dev, adap, type, hw_addrs[idx],\n\t\t\t\t NULL);\n\tif (sd != NULL)\n\t\tsd->grp_id = hw;\n\treturn sd != NULL ? 0 : -1;\n}\n\n \nstruct v4l2_subdev *cx18_find_hw(struct cx18 *cx, u32 hw)\n{\n\tstruct v4l2_subdev *result = NULL;\n\tstruct v4l2_subdev *sd;\n\n\tspin_lock(&cx->v4l2_dev.lock);\n\tv4l2_device_for_each_subdev(sd, &cx->v4l2_dev) {\n\t\tif (sd->grp_id == hw) {\n\t\t\tresult = sd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cx->v4l2_dev.lock);\n\treturn result;\n}\n\nstatic void cx18_setscl(void *data, int state)\n{\n\tstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\n\tint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\n\tu32 addr = bus_index ? CX18_REG_I2C_2_WR : CX18_REG_I2C_1_WR;\n\tu32 r = cx18_read_reg(cx, addr);\n\n\tif (state)\n\t\tcx18_write_reg(cx, r | SETSCL_BIT, addr);\n\telse\n\t\tcx18_write_reg(cx, r & ~SETSCL_BIT, addr);\n}\n\nstatic void cx18_setsda(void *data, int state)\n{\n\tstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\n\tint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\n\tu32 addr = bus_index ? CX18_REG_I2C_2_WR : CX18_REG_I2C_1_WR;\n\tu32 r = cx18_read_reg(cx, addr);\n\n\tif (state)\n\t\tcx18_write_reg(cx, r | SETSDL_BIT, addr);\n\telse\n\t\tcx18_write_reg(cx, r & ~SETSDL_BIT, addr);\n}\n\nstatic int cx18_getscl(void *data)\n{\n\tstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\n\tint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\n\tu32 addr = bus_index ? CX18_REG_I2C_2_RD : CX18_REG_I2C_1_RD;\n\n\treturn cx18_read_reg(cx, addr) & GETSCL_BIT;\n}\n\nstatic int cx18_getsda(void *data)\n{\n\tstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\n\tint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\n\tu32 addr = bus_index ? CX18_REG_I2C_2_RD : CX18_REG_I2C_1_RD;\n\n\treturn cx18_read_reg(cx, addr) & GETSDL_BIT;\n}\n\n \nstatic const struct i2c_adapter cx18_i2c_adap_template = {\n\t.name = \"cx18 i2c driver\",\n\t.algo = NULL,                    \n\t.algo_data = NULL,               \n\t.owner = THIS_MODULE,\n};\n\n#define CX18_SCL_PERIOD (10)  \n#define CX18_ALGO_BIT_TIMEOUT (2)  \n\nstatic const struct i2c_algo_bit_data cx18_i2c_algo_template = {\n\t.setsda\t\t= cx18_setsda,\n\t.setscl\t\t= cx18_setscl,\n\t.getsda\t\t= cx18_getsda,\n\t.getscl\t\t= cx18_getscl,\n\t.udelay\t\t= CX18_SCL_PERIOD/2,        \n\t.timeout\t= CX18_ALGO_BIT_TIMEOUT*HZ  \n};\n\n \nint init_cx18_i2c(struct cx18 *cx)\n{\n\tint i, err;\n\tCX18_DEBUG_I2C(\"i2c init\\n\");\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tcx->i2c_algo[i] = cx18_i2c_algo_template;\n\t\tcx->i2c_algo_cb_data[i].cx = cx;\n\t\tcx->i2c_algo_cb_data[i].bus_index = i;\n\t\tcx->i2c_algo[i].data = &cx->i2c_algo_cb_data[i];\n\n\t\t \n\t\tcx->i2c_adap[i] = cx18_i2c_adap_template;\n\t\tcx->i2c_adap[i].algo_data = &cx->i2c_algo[i];\n\t\tsprintf(cx->i2c_adap[i].name + strlen(cx->i2c_adap[i].name),\n\t\t\t\t\" #%d-%d\", cx->instance, i);\n\t\ti2c_set_adapdata(&cx->i2c_adap[i], &cx->v4l2_dev);\n\t\tcx->i2c_adap[i].dev.parent = &cx->pci_dev->dev;\n\t}\n\n\tif (cx18_read_reg(cx, CX18_REG_I2C_2_WR) != 0x0003c02f) {\n\t\t \n\t\t \n\t\tcx18_write_reg_expect(cx, 0x10000000, 0xc71004,\n\t\t\t\t\t  0x00000000, 0x10001000);\n\t\t \n\t\tcx18_write_reg_expect(cx, 0x10001000, 0xc71024,\n\t\t\t\t\t  0x00001000, 0x10001000);\n\t}\n\t \n\tcx18_write_reg_expect(cx, 0x00c00000, 0xc7001c, 0x00000000, 0x00c000c0);\n\tmdelay(10);\n\tcx18_write_reg_expect(cx, 0x00c000c0, 0xc7001c, 0x000000c0, 0x00c000c0);\n\tmdelay(10);\n\tcx18_write_reg_expect(cx, 0x00c00000, 0xc7001c, 0x00000000, 0x00c000c0);\n\tmdelay(10);\n\n\t \n\tcx18_write_reg(cx, 0x00c00000, 0xc730c8);\n\t \n\tcx18_write_reg_expect(cx, HW2_I2C1_INT|HW2_I2C2_INT, HW2_INT_CLR_STATUS,\n\t\t       ~(HW2_I2C1_INT|HW2_I2C2_INT), HW2_I2C1_INT|HW2_I2C2_INT);\n\n\t \n\tcx18_write_reg(cx, 0x00021c0f & ~4, CX18_REG_I2C_1_WR);\n\tcx18_setscl(&cx->i2c_algo_cb_data[0], 1);\n\tcx18_setsda(&cx->i2c_algo_cb_data[0], 1);\n\n\t \n\tcx18_write_reg(cx, 0x00021c0f & ~4, CX18_REG_I2C_2_WR);\n\tcx18_setscl(&cx->i2c_algo_cb_data[1], 1);\n\tcx18_setsda(&cx->i2c_algo_cb_data[1], 1);\n\n\tcx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL,\n\t\t     core, reset, (u32) CX18_GPIO_RESET_I2C);\n\n\terr = i2c_bit_add_bus(&cx->i2c_adap[0]);\n\tif (err)\n\t\tgoto err;\n\terr = i2c_bit_add_bus(&cx->i2c_adap[1]);\n\tif (err)\n\t\tgoto err_del_bus_0;\n\treturn 0;\n\n err_del_bus_0:\n\ti2c_del_adapter(&cx->i2c_adap[0]);\n err:\n\treturn err;\n}\n\nvoid exit_cx18_i2c(struct cx18 *cx)\n{\n\tint i;\n\tCX18_DEBUG_I2C(\"i2c exit\\n\");\n\tcx18_write_reg(cx, cx18_read_reg(cx, CX18_REG_I2C_1_WR) | 4,\n\t\t\t\t\t\t\tCX18_REG_I2C_1_WR);\n\tcx18_write_reg(cx, cx18_read_reg(cx, CX18_REG_I2C_2_WR) | 4,\n\t\t\t\t\t\t\tCX18_REG_I2C_2_WR);\n\n\tfor (i = 0; i < 2; i++) {\n\t\ti2c_del_adapter(&cx->i2c_adap[i]);\n\t}\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}