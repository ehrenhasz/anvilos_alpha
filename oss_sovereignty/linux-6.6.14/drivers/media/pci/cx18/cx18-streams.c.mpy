{
  "module_name": "cx18-streams.c",
  "hash_id": "52d21c3216824365da455bed06017a39823185ffc99d36494a3a5e6ddb8781ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-streams.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-fileops.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-i2c.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-scb.h\"\n#include \"cx18-dvb.h\"\n\n#define CX18_DSP0_INTERRUPT_MASK\t0xd0004C\n\nstatic const struct v4l2_file_operations cx18_v4l2_enc_fops = {\n\t.owner = THIS_MODULE,\n\t.read = cx18_v4l2_read,\n\t.open = cx18_v4l2_open,\n\t.unlocked_ioctl = video_ioctl2,\n\t.release = cx18_v4l2_close,\n\t.poll = cx18_v4l2_enc_poll,\n};\n\nstatic const struct v4l2_file_operations cx18_v4l2_enc_yuv_fops = {\n\t.owner = THIS_MODULE,\n\t.open = cx18_v4l2_open,\n\t.unlocked_ioctl = video_ioctl2,\n\t.release = cx18_v4l2_close,\n\t.poll = vb2_fop_poll,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n};\n\n \n#define CX18_V4L2_ENC_TS_OFFSET   16\n \n#define CX18_V4L2_ENC_PCM_OFFSET  24\n \n#define CX18_V4L2_ENC_YUV_OFFSET  32\n\nstatic struct {\n\tconst char *name;\n\tint vfl_type;\n\tint num_offset;\n\tint dma;\n\tu32 caps;\n} cx18_stream_info[] = {\n\t{\t \n\t\t\"encoder MPEG\",\n\t\tVFL_TYPE_VIDEO, 0,\n\t\tDMA_FROM_DEVICE,\n\t\tV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_AUDIO | V4L2_CAP_TUNER\n\t},\n\t{\t \n\t\t\"TS\",\n\t\tVFL_TYPE_VIDEO, -1,\n\t\tDMA_FROM_DEVICE,\n\t},\n\t{\t \n\t\t\"encoder YUV\",\n\t\tVFL_TYPE_VIDEO, CX18_V4L2_ENC_YUV_OFFSET,\n\t\tDMA_FROM_DEVICE,\n\t\tV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_STREAMING | V4L2_CAP_AUDIO | V4L2_CAP_TUNER\n\t},\n\t{\t \n\t\t\"encoder VBI\",\n\t\tVFL_TYPE_VBI, 0,\n\t\tDMA_FROM_DEVICE,\n\t\tV4L2_CAP_VBI_CAPTURE | V4L2_CAP_SLICED_VBI_CAPTURE |\n\t\tV4L2_CAP_READWRITE | V4L2_CAP_AUDIO | V4L2_CAP_TUNER\n\t},\n\t{\t \n\t\t\"encoder PCM audio\",\n\t\tVFL_TYPE_VIDEO, CX18_V4L2_ENC_PCM_OFFSET,\n\t\tDMA_FROM_DEVICE,\n\t\tV4L2_CAP_TUNER | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t},\n\t{\t \n\t\t\"encoder IDX\",\n\t\tVFL_TYPE_VIDEO, -1,\n\t\tDMA_FROM_DEVICE,\n\t},\n\t{\t \n\t\t\"encoder radio\",\n\t\tVFL_TYPE_RADIO, 0,\n\t\tDMA_NONE,\n\t\tV4L2_CAP_RADIO | V4L2_CAP_TUNER\n\t},\n};\n\nstatic int cx18_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx18_stream *s = vb2_get_drv_priv(vq);\n\tstruct cx18 *cx = s->cx;\n\tunsigned int szimage;\n\n\t \n\tif (s->pixelformat == V4L2_PIX_FMT_NV12_16L16)\n\t\tszimage = cx->cxhdl.height * 720 * 3 / 2;\n\telse\n\t\tszimage = cx->cxhdl.height * 720 * 2;\n\n\t \n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != 1 || sizes[0] < szimage)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tsizes[0] = szimage;\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic void cx18_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct cx18_stream *s = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx18_vb2_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx18_vb2_buffer, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->vb_lock, flags);\n\tlist_add_tail(&buf->list, &s->vb_capture);\n\tspin_unlock_irqrestore(&s->vb_lock, flags);\n}\n\nstatic int cx18_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx18_stream *s = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cx18 *cx = s->cx;\n\tunsigned int size;\n\n\t \n\tif (s->pixelformat == V4L2_PIX_FMT_NV12_16L16)\n\t\tsize = cx->cxhdl.height * 720 * 3 / 2;\n\telse\n\t\tsize = cx->cxhdl.height * 720 * 2;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\tvbuf->field = V4L2_FIELD_INTERLACED;\n\treturn 0;\n}\n\nvoid cx18_clear_queue(struct cx18_stream *s, enum vb2_buffer_state state)\n{\n\twhile (!list_empty(&s->vb_capture)) {\n\t\tstruct cx18_vb2_buffer *buf;\n\n\t\tbuf = list_first_entry(&s->vb_capture,\n\t\t\t\t       struct cx18_vb2_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n}\n\nstatic int cx18_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct v4l2_fh *owner = vq->owner;\n\tstruct cx18_stream *s = vb2_get_drv_priv(vq);\n\tunsigned long flags;\n\tint rc;\n\n\tif (WARN_ON(!owner)) {\n\t\trc = -EIO;\n\t\tgoto clear_queue;\n\t}\n\n\ts->sequence = 0;\n\trc = cx18_start_capture(fh2id(owner));\n\tif (!rc) {\n\t\t \n\t\tmod_timer(&s->vb_timeout, msecs_to_jiffies(2000) + jiffies);\n\t\treturn 0;\n\t}\n\nclear_queue:\n\tspin_lock_irqsave(&s->vb_lock, flags);\n\tcx18_clear_queue(s, VB2_BUF_STATE_QUEUED);\n\tspin_unlock_irqrestore(&s->vb_lock, flags);\n\treturn rc;\n}\n\nstatic void cx18_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct cx18_stream *s = vb2_get_drv_priv(vq);\n\tunsigned long flags;\n\n\tcx18_stop_capture(s, 0);\n\ttimer_delete_sync(&s->vb_timeout);\n\tspin_lock_irqsave(&s->vb_lock, flags);\n\tcx18_clear_queue(s, VB2_BUF_STATE_ERROR);\n\tspin_unlock_irqrestore(&s->vb_lock, flags);\n}\n\nstatic const struct vb2_ops cx18_vb2_qops = {\n\t.queue_setup\t\t= cx18_queue_setup,\n\t.buf_queue\t\t= cx18_buf_queue,\n\t.buf_prepare\t\t= cx18_buf_prepare,\n\t.start_streaming\t= cx18_start_streaming,\n\t.stop_streaming\t\t= cx18_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int cx18_stream_init(struct cx18 *cx, int type)\n{\n\tstruct cx18_stream *s = &cx->streams[type];\n\tint err = 0;\n\n\tmemset(s, 0, sizeof(*s));\n\n\t \n\ts->dvb = NULL;\n\ts->cx = cx;\n\ts->type = type;\n\ts->name = cx18_stream_info[type].name;\n\ts->handle = CX18_INVALID_TASK_HANDLE;\n\n\ts->dma = cx18_stream_info[type].dma;\n\ts->v4l2_dev_caps = cx18_stream_info[type].caps;\n\ts->buffers = cx->stream_buffers[type];\n\ts->buf_size = cx->stream_buf_size[type];\n\tINIT_LIST_HEAD(&s->buf_pool);\n\ts->bufs_per_mdl = 1;\n\ts->mdl_size = s->buf_size * s->bufs_per_mdl;\n\n\tinit_waitqueue_head(&s->waitq);\n\ts->id = -1;\n\tspin_lock_init(&s->q_free.lock);\n\tcx18_queue_init(&s->q_free);\n\tspin_lock_init(&s->q_busy.lock);\n\tcx18_queue_init(&s->q_busy);\n\tspin_lock_init(&s->q_full.lock);\n\tcx18_queue_init(&s->q_full);\n\tspin_lock_init(&s->q_idle.lock);\n\tcx18_queue_init(&s->q_idle);\n\n\tINIT_WORK(&s->out_work_order, cx18_out_work_handler);\n\n\tINIT_LIST_HEAD(&s->vb_capture);\n\ttimer_setup(&s->vb_timeout, cx18_vb_timeout, 0);\n\tspin_lock_init(&s->vb_lock);\n\n\tif (type == CX18_ENC_STREAM_TYPE_YUV) {\n\t\ts->vb_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t\t \n\t\ts->pixelformat = V4L2_PIX_FMT_NV12_16L16;\n\t\ts->vb_bytes_per_frame = cx->cxhdl.height * 720 * 3 / 2;\n\t\ts->vb_bytes_per_line = 720;\n\n\t\ts->vidq.io_modes = VB2_READ | VB2_MMAP | VB2_DMABUF;\n\t\ts->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\ts->vidq.drv_priv = s;\n\t\ts->vidq.buf_struct_size = sizeof(struct cx18_vb2_buffer);\n\t\ts->vidq.ops = &cx18_vb2_qops;\n\t\ts->vidq.mem_ops = &vb2_vmalloc_memops;\n\t\ts->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\ts->vidq.min_buffers_needed = 2;\n\t\ts->vidq.gfp_flags = GFP_DMA32;\n\t\ts->vidq.dev = &cx->pci_dev->dev;\n\t\ts->vidq.lock = &cx->serialize_lock;\n\n\t\terr = vb2_queue_init(&s->vidq);\n\t\tif (err)\n\t\t\tv4l2_err(&cx->v4l2_dev, \"cannot init vb2 queue\\n\");\n\t\ts->video_dev.queue = &s->vidq;\n\t}\n\treturn err;\n}\n\nstatic int cx18_prep_dev(struct cx18 *cx, int type)\n{\n\tstruct cx18_stream *s = &cx->streams[type];\n\tu32 cap = cx->v4l2_cap;\n\tint num_offset = cx18_stream_info[type].num_offset;\n\tint num = cx->instance + cx18_first_minor + num_offset;\n\tint err;\n\n\t \n\ts->video_dev.v4l2_dev = NULL;\n\ts->dvb = NULL;\n\ts->cx = cx;\n\ts->type = type;\n\ts->name = cx18_stream_info[type].name;\n\n\t \n\tif (type == CX18_ENC_STREAM_TYPE_RAD && !(cap & V4L2_CAP_RADIO))\n\t\treturn 0;\n\n\t \n\tif (type == CX18_ENC_STREAM_TYPE_VBI &&\n\t    !(cap & (V4L2_CAP_VBI_CAPTURE | V4L2_CAP_SLICED_VBI_CAPTURE)))\n\t\treturn 0;\n\n\t \n\tif (cx18_stream_info[type].dma != DMA_NONE &&\n\t    cx->stream_buffers[type] == 0) {\n\t\tCX18_INFO(\"Disabled %s device\\n\", cx18_stream_info[type].name);\n\t\treturn 0;\n\t}\n\n\terr = cx18_stream_init(cx, type);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (type == CX18_ENC_STREAM_TYPE_TS) {\n\t\tif (cx->card->hw_all & CX18_HW_DVB) {\n\t\t\ts->dvb = kzalloc(sizeof(struct cx18_dvb), GFP_KERNEL);\n\t\t\tif (s->dvb == NULL) {\n\t\t\t\tCX18_ERR(\"Couldn't allocate cx18_dvb structure for %s\\n\",\n\t\t\t\t\t s->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ts->buffers = 0;\n\t\t}\n\t}\n\n\tif (num_offset == -1)\n\t\treturn 0;\n\n\t \n\tsnprintf(s->video_dev.name, sizeof(s->video_dev.name), \"%s %s\",\n\t\t cx->v4l2_dev.name, s->name);\n\n\ts->video_dev.num = num;\n\ts->video_dev.v4l2_dev = &cx->v4l2_dev;\n\tif (type == CX18_ENC_STREAM_TYPE_YUV)\n\t\ts->video_dev.fops = &cx18_v4l2_enc_yuv_fops;\n\telse\n\t\ts->video_dev.fops = &cx18_v4l2_enc_fops;\n\ts->video_dev.release = video_device_release_empty;\n\tif (cx->card->video_inputs->video_type == CX18_CARD_INPUT_VID_TUNER)\n\t\ts->video_dev.tvnorms = cx->tuner_std;\n\telse\n\t\ts->video_dev.tvnorms = V4L2_STD_ALL;\n\ts->video_dev.lock = &cx->serialize_lock;\n\tcx18_set_funcs(&s->video_dev);\n\treturn 0;\n}\n\n \nint cx18_streams_setup(struct cx18 *cx)\n{\n\tint type, ret;\n\n\t \n\tfor (type = 0; type < CX18_MAX_STREAMS; type++) {\n\t\t \n\t\tret = cx18_prep_dev(cx, type);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tret = cx18_stream_alloc(&cx->streams[type]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tif (type == CX18_MAX_STREAMS)\n\t\treturn 0;\n\n\t \n\tcx18_streams_cleanup(cx, 0);\n\treturn ret;\n}\n\nstatic int cx18_reg_dev(struct cx18 *cx, int type)\n{\n\tstruct cx18_stream *s = &cx->streams[type];\n\tint vfl_type = cx18_stream_info[type].vfl_type;\n\tconst char *name;\n\tint num, ret;\n\n\tif (type == CX18_ENC_STREAM_TYPE_TS && s->dvb != NULL) {\n\t\tret = cx18_dvb_register(s);\n\t\tif (ret < 0) {\n\t\t\tCX18_ERR(\"DVB failed to register\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (s->video_dev.v4l2_dev == NULL)\n\t\treturn 0;\n\n\tnum = s->video_dev.num;\n\ts->video_dev.device_caps = s->v4l2_dev_caps;\t \n\t \n\tif (type != CX18_ENC_STREAM_TYPE_MPG) {\n\t\tstruct cx18_stream *s_mpg = &cx->streams[CX18_ENC_STREAM_TYPE_MPG];\n\n\t\tif (s_mpg->video_dev.v4l2_dev)\n\t\t\tnum = s_mpg->video_dev.num\n\t\t\t    + cx18_stream_info[type].num_offset;\n\t}\n\tvideo_set_drvdata(&s->video_dev, s);\n\n\t \n\tret = video_register_device_no_warn(&s->video_dev, vfl_type, num);\n\tif (ret < 0) {\n\t\tCX18_ERR(\"Couldn't register v4l2 device for %s (device node number %d)\\n\",\n\t\t\ts->name, num);\n\t\ts->video_dev.v4l2_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tname = video_device_node_name(&s->video_dev);\n\n\tswitch (vfl_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tCX18_INFO(\"Registered device %s for %s (%d x %d.%02d kB)\\n\",\n\t\t\t  name, s->name, cx->stream_buffers[type],\n\t\t\t  cx->stream_buf_size[type] / 1024,\n\t\t\t  (cx->stream_buf_size[type] * 100 / 1024) % 100);\n\t\tbreak;\n\n\tcase VFL_TYPE_RADIO:\n\t\tCX18_INFO(\"Registered device %s for %s\\n\", name, s->name);\n\t\tbreak;\n\n\tcase VFL_TYPE_VBI:\n\t\tif (cx->stream_buffers[type])\n\t\t\tCX18_INFO(\"Registered device %s for %s (%d x %d bytes)\\n\",\n\t\t\t\t  name, s->name, cx->stream_buffers[type],\n\t\t\t\t  cx->stream_buf_size[type]);\n\t\telse\n\t\t\tCX18_INFO(\"Registered device %s for %s\\n\",\n\t\t\t\tname, s->name);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint cx18_streams_register(struct cx18 *cx)\n{\n\tint type;\n\tint err;\n\tint ret = 0;\n\n\t \n\tfor (type = 0; type < CX18_MAX_STREAMS; type++) {\n\t\terr = cx18_reg_dev(cx, type);\n\t\tif (err && ret == 0)\n\t\t\tret = err;\n\t}\n\n\tif (ret == 0)\n\t\treturn 0;\n\n\t \n\tcx18_streams_cleanup(cx, 1);\n\treturn ret;\n}\n\n \nvoid cx18_streams_cleanup(struct cx18 *cx, int unregister)\n{\n\tstruct video_device *vdev;\n\tint type;\n\n\t \n\tfor (type = 0; type < CX18_MAX_STREAMS; type++) {\n\n\t\t \n\t\tif (type == CX18_ENC_STREAM_TYPE_TS) {\n\t\t\tif (cx->streams[type].dvb != NULL) {\n\t\t\t\tif (unregister)\n\t\t\t\t\tcx18_dvb_unregister(&cx->streams[type]);\n\t\t\t\tkfree(cx->streams[type].dvb);\n\t\t\t\tcx->streams[type].dvb = NULL;\n\t\t\t\tcx18_stream_free(&cx->streams[type]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (type == CX18_ENC_STREAM_TYPE_IDX) {\n\t\t\t \n\t\t\tif (cx->stream_buffers[type] != 0) {\n\t\t\t\tcx->stream_buffers[type] = 0;\n\t\t\t\t \n\t\t\t\tif (cx->streams[type].buffers != 0)\n\t\t\t\t\tcx18_stream_free(&cx->streams[type]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tvdev = &cx->streams[type].video_dev;\n\n\t\tif (vdev->v4l2_dev == NULL)\n\t\t\tcontinue;\n\n\t\tcx18_stream_free(&cx->streams[type]);\n\n\t\tif (type == CX18_ENC_STREAM_TYPE_YUV)\n\t\t\tvb2_video_unregister_device(vdev);\n\t\telse\n\t\t\tvideo_unregister_device(vdev);\n\t}\n}\n\nstatic void cx18_vbi_setup(struct cx18_stream *s)\n{\n\tstruct cx18 *cx = s->cx;\n\tint raw = cx18_raw_vbi(cx);\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tint lines;\n\n\tif (cx->is_60hz) {\n\t\tcx->vbi.count = 12;\n\t\tcx->vbi.start[0] = 10;\n\t\tcx->vbi.start[1] = 273;\n\t} else {         \n\t\tcx->vbi.count = 18;\n\t\tcx->vbi.start[0] = 6;\n\t\tcx->vbi.start[1] = 318;\n\t}\n\n\t \n\tif (raw)\n\t\tv4l2_subdev_call(cx->sd_av, vbi, s_raw_fmt, &cx->vbi.in.fmt.vbi);\n\telse\n\t\tv4l2_subdev_call(cx->sd_av, vbi, s_sliced_fmt, &cx->vbi.in.fmt.sliced);\n\n\t \n\tif (raw) {\n\t\tlines = cx->vbi.count * 2;\n\t} else {\n\t\t \n\t\tlines = cx->is_60hz ? (21 - 4 + 1) * 2 : (23 - 2 + 1) * 2;\n\t}\n\n\tdata[0] = s->handle;\n\t \n\tdata[1] = (lines / 2) | ((lines / 2) << 16);\n\t \n\tdata[2] = (raw ? VBI_ACTIVE_SAMPLES\n\t\t       : (cx->is_60hz ? VBI_HBLANK_SAMPLES_60HZ\n\t\t\t\t      : VBI_HBLANK_SAMPLES_50HZ));\n\t \n\tdata[3] = 1;\n\t \n\tif (raw) {\n\t\t \n\t\tdata[4] = 0x20602060;\n\t\t \n\t\tdata[5] = 0x307090d0;\n\t} else {\n\t\t \n\t\tdata[4] = 0xB0F0B0F0;\n\t\t \n\t\tdata[5] = 0xA0E0A0E0;\n\t}\n\n\tCX18_DEBUG_INFO(\"Setup VBI h: %d lines %x bpl %d fr %d %x %x\\n\",\n\t\t\tdata[0], data[1], data[2], data[3], data[4], data[5]);\n\n\tcx18_api(cx, CX18_CPU_SET_RAW_VBI_PARAM, 6, data);\n}\n\nvoid cx18_stream_rotate_idx_mdls(struct cx18 *cx)\n{\n\tstruct cx18_stream *s = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\tstruct cx18_mdl *mdl;\n\n\tif (!cx18_stream_enabled(s))\n\t\treturn;\n\n\t \n\tif ((atomic_read(&s->q_free.depth) + atomic_read(&s->q_busy.depth)) >=\n\t\t\t\t\t    CX18_ENC_STREAM_TYPE_IDX_FW_MDL_MIN)\n\t\treturn;\n\n\t \n\tif (atomic_read(&s->q_full.depth) < 2)\n\t\treturn;\n\n\t \n\tmdl = cx18_dequeue(s, &s->q_full);\n\tif (mdl != NULL)\n\t\tcx18_enqueue(s, mdl, &s->q_free);\n}\n\nstatic\nstruct cx18_queue *_cx18_stream_put_mdl_fw(struct cx18_stream *s,\n\t\t\t\t\t   struct cx18_mdl *mdl)\n{\n\tstruct cx18 *cx = s->cx;\n\tstruct cx18_queue *q;\n\n\t \n\tif (s->handle == CX18_INVALID_TASK_HANDLE ||\n\t    test_bit(CX18_F_S_STOPPING, &s->s_flags) ||\n\t    !test_bit(CX18_F_S_STREAMING, &s->s_flags))\n\t\treturn cx18_enqueue(s, mdl, &s->q_free);\n\n\tq = cx18_enqueue(s, mdl, &s->q_busy);\n\tif (q != &s->q_busy)\n\t\treturn q;  \n\n\tcx18_mdl_sync_for_device(s, mdl);\n\tcx18_vapi(cx, CX18_CPU_DE_SET_MDL, 5, s->handle,\n\t\t  (void __iomem *) &cx->scb->cpu_mdl[mdl->id] - cx->enc_mem,\n\t\t  s->bufs_per_mdl, mdl->id, s->mdl_size);\n\treturn q;\n}\n\nstatic\nvoid _cx18_stream_load_fw_queue(struct cx18_stream *s)\n{\n\tstruct cx18_queue *q;\n\tstruct cx18_mdl *mdl;\n\n\tif (atomic_read(&s->q_free.depth) == 0 ||\n\t    atomic_read(&s->q_busy.depth) >= CX18_MAX_FW_MDLS_PER_STREAM)\n\t\treturn;\n\n\t \n\tdo {\n\t\tmdl = cx18_dequeue(s, &s->q_free);\n\t\tif (mdl == NULL)\n\t\t\tbreak;\n\t\tq = _cx18_stream_put_mdl_fw(s, mdl);\n\t} while (atomic_read(&s->q_busy.depth) < CX18_MAX_FW_MDLS_PER_STREAM\n\t\t && q == &s->q_busy);\n}\n\nvoid cx18_out_work_handler(struct work_struct *work)\n{\n\tstruct cx18_stream *s =\n\t\t\t container_of(work, struct cx18_stream, out_work_order);\n\n\t_cx18_stream_load_fw_queue(s);\n}\n\nstatic void cx18_stream_configure_mdls(struct cx18_stream *s)\n{\n\tcx18_unload_queues(s);\n\n\tswitch (s->type) {\n\tcase CX18_ENC_STREAM_TYPE_YUV:\n\t\t \n\t\tif (s->pixelformat == V4L2_PIX_FMT_NV12_16L16)\n\t\t\ts->mdl_size = 720 * s->cx->cxhdl.height * 3 / 2;\n\t\telse\n\t\t\ts->mdl_size = 720 * s->cx->cxhdl.height * 2;\n\t\ts->bufs_per_mdl = s->mdl_size / s->buf_size;\n\t\tif (s->mdl_size % s->buf_size)\n\t\t\ts->bufs_per_mdl++;\n\t\tbreak;\n\tcase CX18_ENC_STREAM_TYPE_VBI:\n\t\ts->bufs_per_mdl = 1;\n\t\tif  (cx18_raw_vbi(s->cx)) {\n\t\t\ts->mdl_size = (s->cx->is_60hz ? 12 : 18)\n\t\t\t\t\t\t       * 2 * VBI_ACTIVE_SAMPLES;\n\t\t} else {\n\t\t\t \n\t\t\ts->mdl_size = s->cx->is_60hz\n\t\t\t\t   ? (21 - 4 + 1) * 2 * VBI_HBLANK_SAMPLES_60HZ\n\t\t\t\t   : (23 - 2 + 1) * 2 * VBI_HBLANK_SAMPLES_50HZ;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ts->bufs_per_mdl = 1;\n\t\ts->mdl_size = s->buf_size * s->bufs_per_mdl;\n\t\tbreak;\n\t}\n\n\tcx18_load_queues(s);\n}\n\nint cx18_start_v4l2_encode_stream(struct cx18_stream *s)\n{\n\tu32 data[MAX_MB_ARGUMENTS];\n\tstruct cx18 *cx = s->cx;\n\tint captype = 0;\n\tstruct cx18_stream *s_idx;\n\n\tif (!cx18_stream_enabled(s))\n\t\treturn -EINVAL;\n\n\tCX18_DEBUG_INFO(\"Start encoder stream %s\\n\", s->name);\n\n\tswitch (s->type) {\n\tcase CX18_ENC_STREAM_TYPE_MPG:\n\t\tcaptype = CAPTURE_CHANNEL_TYPE_MPEG;\n\t\tcx->mpg_data_received = cx->vbi_data_inserted = 0;\n\t\tcx->dualwatch_jiffies = jiffies;\n\t\tcx->dualwatch_stereo_mode = v4l2_ctrl_g_ctrl(cx->cxhdl.audio_mode);\n\t\tcx->search_pack_header = 0;\n\t\tbreak;\n\n\tcase CX18_ENC_STREAM_TYPE_IDX:\n\t\tcaptype = CAPTURE_CHANNEL_TYPE_INDEX;\n\t\tbreak;\n\tcase CX18_ENC_STREAM_TYPE_TS:\n\t\tcaptype = CAPTURE_CHANNEL_TYPE_TS;\n\t\tbreak;\n\tcase CX18_ENC_STREAM_TYPE_YUV:\n\t\tcaptype = CAPTURE_CHANNEL_TYPE_YUV;\n\t\tbreak;\n\tcase CX18_ENC_STREAM_TYPE_PCM:\n\t\tcaptype = CAPTURE_CHANNEL_TYPE_PCM;\n\t\tbreak;\n\tcase CX18_ENC_STREAM_TYPE_VBI:\n#ifdef CX18_ENCODER_PARSES_SLICED\n\t\tcaptype = cx18_raw_vbi(cx) ?\n\t\t     CAPTURE_CHANNEL_TYPE_VBI : CAPTURE_CHANNEL_TYPE_SLICED_VBI;\n#else\n\t\t \n\t\tcaptype = CAPTURE_CHANNEL_TYPE_VBI;\n#endif\n\t\tcx->vbi.frame = 0;\n\t\tcx->vbi.inserted_frame = 0;\n\t\tmemset(cx->vbi.sliced_mpeg_size,\n\t\t\t0, sizeof(cx->vbi.sliced_mpeg_size));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\n\n\tcx18_vapi_result(cx, data, CX18_CREATE_TASK, 1, CPU_CMD_MASK_CAPTURE);\n\ts->handle = data[0];\n\tcx18_vapi(cx, CX18_CPU_SET_CHANNEL_TYPE, 2, s->handle, captype);\n\n\t \n\tif (captype != CAPTURE_CHANNEL_TYPE_TS) {\n\t\tcx18_vapi(cx, CX18_CPU_SET_VER_CROP_LINE, 2, s->handle, 0);\n\t\tcx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 3, 1);\n\t\tcx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 8, 0);\n\t\tcx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 3, s->handle, 4, 1);\n\n\t\t \n\t\tif (atomic_read(&cx->ana_capturing) == 0)\n\t\t\tcx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 2,\n\t\t\t\t  s->handle, 12);\n\n\t\t \n\t\tcx18_vapi(cx, CX18_CPU_SET_CAPTURE_LINE_NO, 3,\n\t\t\t  s->handle, 312, 313);\n\n\t\tif (cx->v4l2_cap & V4L2_CAP_VBI_CAPTURE)\n\t\t\tcx18_vbi_setup(s);\n\n\t\t \n\t\ts_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\n\t\tcx18_vapi_result(cx, data, CX18_CPU_SET_INDEXTABLE, 2,\n\t\t\t\t s->handle, cx18_stream_enabled(s_idx) ? 7 : 0);\n\n\t\t \n\t\tcx->cxhdl.priv = s;\n\t\tcx2341x_handler_setup(&cx->cxhdl);\n\n\t\t \n\t\tif (!cx->cxhdl.video_mute &&\n\t\t    test_bit(CX18_F_I_RADIO_USER, &cx->i_flags))\n\t\t\tcx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2, s->handle,\n\t\t\t  (v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute_yuv) << 8) | 1);\n\n\t\t \n\t\tif (captype == CAPTURE_CHANNEL_TYPE_YUV) {\n\t\t\tif (s->pixelformat == V4L2_PIX_FMT_UYVY)\n\t\t\t\tcx18_vapi(cx, CX18_CPU_SET_VFC_PARAM, 2,\n\t\t\t\t\ts->handle, 1);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tcx18_vapi(cx, CX18_CPU_SET_VFC_PARAM, 2,\n\t\t\t\t\ts->handle, 0);\n\t\t}\n\t}\n\n\tif (atomic_read(&cx->tot_capturing) == 0) {\n\t\tcx2341x_handler_set_busy(&cx->cxhdl, 1);\n\t\tclear_bit(CX18_F_I_EOS, &cx->i_flags);\n\t\tcx18_write_reg(cx, 7, CX18_DSP0_INTERRUPT_MASK);\n\t}\n\n\tcx18_vapi(cx, CX18_CPU_DE_SET_MDL_ACK, 3, s->handle,\n\t\t(void __iomem *)&cx->scb->cpu_mdl_ack[s->type][0] - cx->enc_mem,\n\t\t(void __iomem *)&cx->scb->cpu_mdl_ack[s->type][1] - cx->enc_mem);\n\n\t \n\tcx18_stream_configure_mdls(s);\n\t_cx18_stream_load_fw_queue(s);\n\n\t \n\tif (cx18_vapi(cx, CX18_CPU_CAPTURE_START, 1, s->handle)) {\n\t\tCX18_DEBUG_WARN(\"Error starting capture!\\n\");\n\t\t \n\t\tset_bit(CX18_F_S_STOPPING, &s->s_flags);\n\t\tif (s->type == CX18_ENC_STREAM_TYPE_MPG)\n\t\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 2, s->handle, 1);\n\t\telse\n\t\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 1, s->handle);\n\t\tclear_bit(CX18_F_S_STREAMING, &s->s_flags);\n\t\t \n\t\tcx18_vapi(cx, CX18_CPU_DE_RELEASE_MDL, 1, s->handle);\n\t\tcx18_vapi(cx, CX18_DESTROY_TASK, 1, s->handle);\n\t\ts->handle = CX18_INVALID_TASK_HANDLE;\n\t\tclear_bit(CX18_F_S_STOPPING, &s->s_flags);\n\t\tif (atomic_read(&cx->tot_capturing) == 0) {\n\t\t\tset_bit(CX18_F_I_EOS, &cx->i_flags);\n\t\t\tcx18_write_reg(cx, 5, CX18_DSP0_INTERRUPT_MASK);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (captype != CAPTURE_CHANNEL_TYPE_TS)\n\t\tatomic_inc(&cx->ana_capturing);\n\tatomic_inc(&cx->tot_capturing);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx18_start_v4l2_encode_stream);\n\nvoid cx18_stop_all_captures(struct cx18 *cx)\n{\n\tint i;\n\n\tfor (i = CX18_MAX_STREAMS - 1; i >= 0; i--) {\n\t\tstruct cx18_stream *s = &cx->streams[i];\n\n\t\tif (!cx18_stream_enabled(s))\n\t\t\tcontinue;\n\t\tif (test_bit(CX18_F_S_STREAMING, &s->s_flags))\n\t\t\tcx18_stop_v4l2_encode_stream(s, 0);\n\t}\n}\n\nint cx18_stop_v4l2_encode_stream(struct cx18_stream *s, int gop_end)\n{\n\tstruct cx18 *cx = s->cx;\n\n\tif (!cx18_stream_enabled(s))\n\t\treturn -EINVAL;\n\n\t \n\n\tCX18_DEBUG_INFO(\"Stop Capture\\n\");\n\n\tif (atomic_read(&cx->tot_capturing) == 0)\n\t\treturn 0;\n\n\tset_bit(CX18_F_S_STOPPING, &s->s_flags);\n\tif (s->type == CX18_ENC_STREAM_TYPE_MPG)\n\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 2, s->handle, !gop_end);\n\telse\n\t\tcx18_vapi(cx, CX18_CPU_CAPTURE_STOP, 1, s->handle);\n\n\tif (s->type == CX18_ENC_STREAM_TYPE_MPG && gop_end) {\n\t\tCX18_INFO(\"ignoring gop_end: not (yet?) supported by the firmware\\n\");\n\t}\n\n\tif (s->type != CX18_ENC_STREAM_TYPE_TS)\n\t\tatomic_dec(&cx->ana_capturing);\n\tatomic_dec(&cx->tot_capturing);\n\n\t \n\tclear_bit(CX18_F_S_STREAMING, &s->s_flags);\n\n\t \n\tcx18_vapi(cx, CX18_CPU_DE_RELEASE_MDL, 1, s->handle);\n\n\tcx18_vapi(cx, CX18_DESTROY_TASK, 1, s->handle);\n\ts->handle = CX18_INVALID_TASK_HANDLE;\n\tclear_bit(CX18_F_S_STOPPING, &s->s_flags);\n\n\tif (atomic_read(&cx->tot_capturing) > 0)\n\t\treturn 0;\n\n\tcx2341x_handler_set_busy(&cx->cxhdl, 0);\n\tcx18_write_reg(cx, 5, CX18_DSP0_INTERRUPT_MASK);\n\twake_up(&s->waitq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cx18_stop_v4l2_encode_stream);\n\nu32 cx18_find_handle(struct cx18 *cx)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < CX18_MAX_STREAMS; i++) {\n\t\tstruct cx18_stream *s = &cx->streams[i];\n\n\t\tif (s->video_dev.v4l2_dev && (s->handle != CX18_INVALID_TASK_HANDLE))\n\t\t\treturn s->handle;\n\t}\n\treturn CX18_INVALID_TASK_HANDLE;\n}\n\nstruct cx18_stream *cx18_handle_to_stream(struct cx18 *cx, u32 handle)\n{\n\tint i;\n\tstruct cx18_stream *s;\n\n\tif (handle == CX18_INVALID_TASK_HANDLE)\n\t\treturn NULL;\n\n\tfor (i = 0; i < CX18_MAX_STREAMS; i++) {\n\t\ts = &cx->streams[i];\n\t\tif (s->handle != handle)\n\t\t\tcontinue;\n\t\tif (cx18_stream_enabled(s))\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}