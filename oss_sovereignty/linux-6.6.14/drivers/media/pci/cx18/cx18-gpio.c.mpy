{
  "module_name": "cx18-gpio.c",
  "hash_id": "62d2afd968bf44c3583dcf3869707362253900129dcdfba6eb458558c286d5ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-gpio.c",
  "human_readable_source": "\n \n\n#include \"cx18-driver.h\"\n#include \"cx18-io.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-gpio.h\"\n#include \"xc2028.h\"\n\n \n\n \n#define CX18_REG_GPIO_IN     0xc72010\n#define CX18_REG_GPIO_OUT1   0xc78100\n#define CX18_REG_GPIO_DIR1   0xc78108\n#define CX18_REG_GPIO_OUT2   0xc78104\n#define CX18_REG_GPIO_DIR2   0xc7810c\n\n \n\n \nstatic void gpio_write(struct cx18 *cx)\n{\n\tu32 dir_lo = cx->gpio_dir & 0xffff;\n\tu32 val_lo = cx->gpio_val & 0xffff;\n\tu32 dir_hi = cx->gpio_dir >> 16;\n\tu32 val_hi = cx->gpio_val >> 16;\n\n\tcx18_write_reg_expect(cx, dir_lo << 16,\n\t\t\t\t\tCX18_REG_GPIO_DIR1, ~dir_lo, dir_lo);\n\tcx18_write_reg_expect(cx, (dir_lo << 16) | val_lo,\n\t\t\t\t\tCX18_REG_GPIO_OUT1, val_lo, dir_lo);\n\tcx18_write_reg_expect(cx, dir_hi << 16,\n\t\t\t\t\tCX18_REG_GPIO_DIR2, ~dir_hi, dir_hi);\n\tcx18_write_reg_expect(cx, (dir_hi << 16) | val_hi,\n\t\t\t\t\tCX18_REG_GPIO_OUT2, val_hi, dir_hi);\n}\n\nstatic void gpio_update(struct cx18 *cx, u32 mask, u32 data)\n{\n\tif (mask == 0)\n\t\treturn;\n\n\tmutex_lock(&cx->gpio_lock);\n\tcx->gpio_val = (cx->gpio_val & ~mask) | (data & mask);\n\tgpio_write(cx);\n\tmutex_unlock(&cx->gpio_lock);\n}\n\nstatic void gpio_reset_seq(struct cx18 *cx, u32 active_lo, u32 active_hi,\n\t\t\t   unsigned int assert_msecs,\n\t\t\t   unsigned int recovery_msecs)\n{\n\tu32 mask;\n\n\tmask = active_lo | active_hi;\n\tif (mask == 0)\n\t\treturn;\n\n\t \n\n\t \n\tgpio_update(cx, mask, ~active_lo);\n\tschedule_timeout_uninterruptible(msecs_to_jiffies(assert_msecs));\n\n\t \n\tgpio_update(cx, mask, ~active_hi);\n\tschedule_timeout_uninterruptible(msecs_to_jiffies(recovery_msecs));\n}\n\n \nstatic int gpiomux_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tmutex_lock(&cx->gpio_lock);\n\tCX18_INFO_DEV(sd, \"GPIO:  direction 0x%08x, value 0x%08x\\n\",\n\t\t      cx->gpio_dir, cx->gpio_val);\n\tmutex_unlock(&cx->gpio_lock);\n\treturn 0;\n}\n\nstatic int gpiomux_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\t \n\tgpio_update(cx, cx->card->gpio_audio_input.mask,\n\t\t\tcx->card->gpio_audio_input.radio);\n\treturn 0;\n}\n\nstatic int gpiomux_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tu32 data;\n\n\tswitch (cx->card->audio_inputs[cx->audio_input].muxer_input) {\n\tcase 1:\n\t\tdata = cx->card->gpio_audio_input.linein;\n\t\tbreak;\n\tcase 0:\n\t\tdata = cx->card->gpio_audio_input.tuner;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdata = cx->card->gpio_audio_input.tuner;\n\t\tbreak;\n\t}\n\tgpio_update(cx, cx->card->gpio_audio_input.mask, data);\n\treturn 0;\n}\n\nstatic int gpiomux_s_audio_routing(struct v4l2_subdev *sd,\n\t\t\t\t   u32 input, u32 output, u32 config)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tu32 data;\n\n\tswitch (input) {\n\tcase 0:\n\t\tdata = cx->card->gpio_audio_input.tuner;\n\t\tbreak;\n\tcase 1:\n\t\tdata = cx->card->gpio_audio_input.linein;\n\t\tbreak;\n\tcase 2:\n\t\tdata = cx->card->gpio_audio_input.radio;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tgpio_update(cx, cx->card->gpio_audio_input.mask, data);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops gpiomux_core_ops = {\n\t.log_status = gpiomux_log_status,\n};\n\nstatic const struct v4l2_subdev_tuner_ops gpiomux_tuner_ops = {\n\t.s_radio = gpiomux_s_radio,\n};\n\nstatic const struct v4l2_subdev_audio_ops gpiomux_audio_ops = {\n\t.s_routing = gpiomux_s_audio_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops gpiomux_video_ops = {\n\t.s_std = gpiomux_s_std,\n};\n\nstatic const struct v4l2_subdev_ops gpiomux_ops = {\n\t.core = &gpiomux_core_ops,\n\t.tuner = &gpiomux_tuner_ops,\n\t.audio = &gpiomux_audio_ops,\n\t.video = &gpiomux_video_ops,\n};\n\n \nstatic int resetctrl_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\n\tmutex_lock(&cx->gpio_lock);\n\tCX18_INFO_DEV(sd, \"GPIO:  direction 0x%08x, value 0x%08x\\n\",\n\t\t      cx->gpio_dir, cx->gpio_val);\n\tmutex_unlock(&cx->gpio_lock);\n\treturn 0;\n}\n\nstatic int resetctrl_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct cx18 *cx = v4l2_get_subdevdata(sd);\n\tconst struct cx18_gpio_i2c_slave_reset *p;\n\n\tp = &cx->card->gpio_i2c_slave_reset;\n\tswitch (val) {\n\tcase CX18_GPIO_RESET_I2C:\n\t\tgpio_reset_seq(cx, p->active_lo_mask, p->active_hi_mask,\n\t\t\t       p->msecs_asserted, p->msecs_recovery);\n\t\tbreak;\n\tcase CX18_GPIO_RESET_Z8F0811:\n\t\t \n\t\tgpio_reset_seq(cx, p->ir_reset_mask, 0,\n\t\t\t       p->msecs_asserted, p->msecs_recovery);\n\t\tbreak;\n\tcase CX18_GPIO_RESET_XC2028:\n\t\tif (cx->card->tuners[0].tuner == TUNER_XC2028)\n\t\t\tgpio_reset_seq(cx, (1 << cx->card->xceive_pin), 0,\n\t\t\t\t       1, 1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops resetctrl_core_ops = {\n\t.log_status = resetctrl_log_status,\n\t.reset = resetctrl_reset,\n};\n\nstatic const struct v4l2_subdev_ops resetctrl_ops = {\n\t.core = &resetctrl_core_ops,\n};\n\n \nvoid cx18_gpio_init(struct cx18 *cx)\n{\n\tmutex_lock(&cx->gpio_lock);\n\tcx->gpio_dir = cx->card->gpio_init.direction;\n\tcx->gpio_val = cx->card->gpio_init.initial_value;\n\n\tif (cx->card->tuners[0].tuner == TUNER_XC2028) {\n\t\tcx->gpio_dir |= 1 << cx->card->xceive_pin;\n\t\tcx->gpio_val |= 1 << cx->card->xceive_pin;\n\t}\n\n\tif (cx->gpio_dir == 0) {\n\t\tmutex_unlock(&cx->gpio_lock);\n\t\treturn;\n\t}\n\n\tCX18_DEBUG_INFO(\"GPIO initial dir: %08x/%08x out: %08x/%08x\\n\",\n\t\t\tcx18_read_reg(cx, CX18_REG_GPIO_DIR1),\n\t\t\tcx18_read_reg(cx, CX18_REG_GPIO_DIR2),\n\t\t\tcx18_read_reg(cx, CX18_REG_GPIO_OUT1),\n\t\t\tcx18_read_reg(cx, CX18_REG_GPIO_OUT2));\n\n\tgpio_write(cx);\n\tmutex_unlock(&cx->gpio_lock);\n}\n\nint cx18_gpio_register(struct cx18 *cx, u32 hw)\n{\n\tstruct v4l2_subdev *sd;\n\tconst struct v4l2_subdev_ops *ops;\n\tchar *str;\n\n\tswitch (hw) {\n\tcase CX18_HW_GPIO_MUX:\n\t\tsd = &cx->sd_gpiomux;\n\t\tops = &gpiomux_ops;\n\t\tstr = \"gpio-mux\";\n\t\tbreak;\n\tcase CX18_HW_GPIO_RESET_CTRL:\n\t\tsd = &cx->sd_resetctrl;\n\t\tops = &resetctrl_ops;\n\t\tstr = \"gpio-reset-ctrl\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_subdev_init(sd, ops);\n\tv4l2_set_subdevdata(sd, cx);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s %s\", cx->v4l2_dev.name, str);\n\tsd->grp_id = hw;\n\treturn v4l2_device_register_subdev(&cx->v4l2_dev, sd);\n}\n\nvoid cx18_reset_ir_gpio(void *data)\n{\n\tstruct cx18 *cx = to_cx18(data);\n\n\tif (cx->card->gpio_i2c_slave_reset.ir_reset_mask == 0)\n\t\treturn;\n\n\tCX18_DEBUG_INFO(\"Resetting IR microcontroller\\n\");\n\n\tv4l2_subdev_call(&cx->sd_resetctrl,\n\t\t\t core, reset, CX18_GPIO_RESET_Z8F0811);\n}\nEXPORT_SYMBOL(cx18_reset_ir_gpio);\n \n\n \nint cx18_reset_tuner_gpio(void *dev, int component, int cmd, int value)\n{\n\tstruct i2c_algo_bit_data *algo = dev;\n\tstruct cx18_i2c_algo_callback_data *cb_data = algo->data;\n\tstruct cx18 *cx = cb_data->cx;\n\n\tif (cmd != XC2028_TUNER_RESET ||\n\t    cx->card->tuners[0].tuner != TUNER_XC2028)\n\t\treturn 0;\n\n\tCX18_DEBUG_INFO(\"Resetting XCeive tuner\\n\");\n\treturn v4l2_subdev_call(&cx->sd_resetctrl,\n\t\t\t\tcore, reset, CX18_GPIO_RESET_XC2028);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}