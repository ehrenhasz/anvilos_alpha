{
  "module_name": "cx18-controls.c",
  "hash_id": "0acb52af9034e7e3217334172806ea200687bdb3b11863f55e72fe6c25141ad6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-controls.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"cx18-driver.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-ioctl.h\"\n#include \"cx18-audio.h\"\n#include \"cx18-mailbox.h\"\n#include \"cx18-controls.h\"\n\nstatic int cx18_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl, u32 fmt)\n{\n\tstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\n\tint type = cxhdl->stream_type->val;\n\n\tif (atomic_read(&cx->ana_capturing) > 0)\n\t\treturn -EBUSY;\n\n\tif (fmt != V4L2_MPEG_STREAM_VBI_FMT_IVTV ||\n\t    !(type == V4L2_MPEG_STREAM_TYPE_MPEG2_PS ||\n\t      type == V4L2_MPEG_STREAM_TYPE_MPEG2_DVD ||\n\t      type == V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD)) {\n\t\t \n\t\tcx->vbi.insert_mpeg = V4L2_MPEG_STREAM_VBI_FMT_NONE;\n\t\tCX18_DEBUG_INFO(\"disabled insertion of sliced VBI data into the MPEG stream\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (cx->vbi.sliced_mpeg_data[0] == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < CX18_VBI_FRAMES; i++) {\n\t\t\tcx->vbi.sliced_mpeg_data[i] =\n\t\t\t       kmalloc(CX18_SLICED_MPEG_DATA_BUFSZ, GFP_KERNEL);\n\t\t\tif (cx->vbi.sliced_mpeg_data[i] == NULL) {\n\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\tkfree(cx->vbi.sliced_mpeg_data[i]);\n\t\t\t\t\tcx->vbi.sliced_mpeg_data[i] = NULL;\n\t\t\t\t}\n\t\t\t\tcx->vbi.insert_mpeg =\n\t\t\t\t\t\t  V4L2_MPEG_STREAM_VBI_FMT_NONE;\n\t\t\t\tCX18_WARN(\"Unable to allocate buffers for sliced VBI data insertion\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tcx->vbi.insert_mpeg = fmt;\n\tCX18_DEBUG_INFO(\"enabled insertion of sliced VBI data into the MPEG PS,when sliced VBI is enabled\\n\");\n\n\t \n\tif (cx18_get_service_set(cx->vbi.sliced_in) == 0) {\n\t\tif (cx->is_60hz)\n\t\t\tcx->vbi.sliced_in->service_set =\n\t\t\t\t\t\t\tV4L2_SLICED_CAPTION_525;\n\t\telse\n\t\t\tcx->vbi.sliced_in->service_set = V4L2_SLICED_WSS_625;\n\t\tcx18_expand_service_set(cx->vbi.sliced_in, cx->is_50hz);\n\t}\n\treturn 0;\n}\n\nstatic int cx18_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\n{\n\tstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\n\tint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_mbus_framefmt *fmt = &format.format;\n\n\t \n\tfmt->width = cxhdl->width / (is_mpeg1 ? 2 : 1);\n\tfmt->height = cxhdl->height;\n\tfmt->code = MEDIA_BUS_FMT_FIXED;\n\tv4l2_subdev_call(cx->sd_av, pad, set_fmt, NULL, &format);\n\treturn 0;\n}\n\nstatic int cx18_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\n{\n\tstatic const u32 freqs[3] = { 44100, 48000, 32000 };\n\tstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\n\n\t \n\tif (idx < ARRAY_SIZE(freqs))\n\t\tcx18_call_all(cx, audio, s_clock_freq, freqs[idx]);\n\treturn 0;\n}\n\nstatic int cx18_s_audio_mode(struct cx2341x_handler *cxhdl, u32 val)\n{\n\tstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\n\n\tcx->dualwatch_stereo_mode = val;\n\treturn 0;\n}\n\nconst struct cx2341x_handler_ops cx18_cxhdl_ops = {\n\t.s_audio_mode = cx18_s_audio_mode,\n\t.s_audio_sampling_freq = cx18_s_audio_sampling_freq,\n\t.s_video_encoding = cx18_s_video_encoding,\n\t.s_stream_vbi_fmt = cx18_s_stream_vbi_fmt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}