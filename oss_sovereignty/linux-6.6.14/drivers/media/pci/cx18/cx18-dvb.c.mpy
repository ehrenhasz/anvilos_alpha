{
  "module_name": "cx18-dvb.c",
  "hash_id": "845033bf107aa956257ee1b87bdf479ea54935ac1bc59a50c9c67bfe92d8c66b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx18/cx18-dvb.c",
  "human_readable_source": "\n \n\n#include \"cx18-version.h\"\n#include \"cx18-dvb.h\"\n#include \"cx18-io.h\"\n#include \"cx18-queue.h\"\n#include \"cx18-streams.h\"\n#include \"cx18-cards.h\"\n#include \"cx18-gpio.h\"\n#include \"s5h1409.h\"\n#include \"mxl5005s.h\"\n#include \"s5h1411.h\"\n#include \"tda18271.h\"\n#include \"zl10353.h\"\n\n#include <linux/firmware.h>\n#include \"mt352.h\"\n#include \"mt352_priv.h\"\n#include \"xc2028.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define FWFILE \"dvb-cx18-mpc718-mt352.fw\"\n\n#define CX18_REG_DMUX_NUM_PORT_0_CONTROL 0xd5a000\n#define CX18_CLOCK_ENABLE2\t\t 0xc71024\n#define CX18_DMUX_CLK_MASK\t\t 0x0080\n\n \n\nstatic struct mxl5005s_config hauppauge_hvr1600_tuner = {\n\t.i2c_address     = 0xC6 >> 1,\n\t.if_freq         = IF_FREQ_5380000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C_H,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.qam_gain        = 0x02,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic struct s5h1409_config hauppauge_hvr1600_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_ON,\n\t.qam_if        = 44000,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n\t.hvr1600_opt   = S5H1409_HVR1600_OPTIMIZE\n};\n\n \nstatic struct s5h1411_config hcw_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_OFF,\n\t.vsb_if        = S5H1411_IF_44000,\n\t.qam_if        = S5H1411_IF_4000,\n\t.inversion     = S5H1411_INVERSION_ON,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct tda18271_std_map hauppauge_tda18271_std_map = {\n\t.atsc_6   = { .if_freq = 5380, .agc_mode = 3, .std = 3,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 0,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n};\n\nstatic struct tda18271_config hauppauge_tda18271_config = {\n\t.std_map = &hauppauge_tda18271_std_map,\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\n \n \nstatic struct zl10353_config leadtek_dvr3100h_demod = {\n\t.demod_address         = 0x1e >> 1,  \n\t.if2                   = 45600,      \n\t.parallel_ts           = 1,          \n\t.no_tuner              = 1,          \n\t.disable_i2c_gate_ctrl = 1,          \n};\n\n \n \nstatic int yuan_mpc718_mt352_reqfw(struct cx18_stream *stream,\n\t\t\t\t   const struct firmware **fw)\n{\n\tstruct cx18 *cx = stream->cx;\n\tconst char *fn = FWFILE;\n\tint ret;\n\n\tret = request_firmware(fw, fn, &cx->pci_dev->dev);\n\tif (ret)\n\t\tCX18_ERR(\"Unable to open firmware file %s\\n\", fn);\n\telse {\n\t\tsize_t sz = (*fw)->size;\n\t\tif (sz < 2 || sz > 64 || (sz % 2) != 0) {\n\t\t\tCX18_ERR(\"Firmware %s has a bad size: %lu bytes\\n\",\n\t\t\t\t fn, (unsigned long) sz);\n\t\t\tret = -EILSEQ;\n\t\t\trelease_firmware(*fw);\n\t\t\t*fw = NULL;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tCX18_ERR(\"The MPC718 board variant with the MT352 DVB-T demodulator will not work without it\\n\");\n\t\tCX18_ERR(\"Run 'linux/scripts/get_dvb_firmware mpc718' if you need the firmware\\n\");\n\t}\n\treturn ret;\n}\n\nstatic int yuan_mpc718_mt352_init(struct dvb_frontend *fe)\n{\n\tstruct cx18_dvb *dvb = container_of(fe->dvb,\n\t\t\t\t\t    struct cx18_dvb, dvb_adapter);\n\tstruct cx18_stream *stream = dvb->stream;\n\tconst struct firmware *fw = NULL;\n\tint ret;\n\tint i;\n\tu8 buf[3];\n\n\tret = yuan_mpc718_mt352_reqfw(stream, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < fw->size; i += 2) {\n\t\tbuf[0] = fw->data[i];\n\t\t \n\t\tswitch (buf[0]) {\n\t\tcase TRL_NOMINAL_RATE_0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase TRL_NOMINAL_RATE_1:\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tbuf[1] = 0x72;\n\t\t\tbuf[2] = 0x49;\n\t\t\tmt352_write(fe, buf, 3);\n\t\t\tbreak;\n\t\tcase INPUT_FREQ_0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase INPUT_FREQ_1:\n\t\t\t \n\t\t\tbuf[1] = 0x31;\n\t\t\tbuf[2] = 0xc0;\n\t\t\tmt352_write(fe, buf, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbuf[1] = fw->data[i+1];\n\t\t\tmt352_write(fe, buf, 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbuf[0] = (u8) TUNER_GO;\n\tbuf[1] = 0x01;  \n\tmt352_write(fe, buf, 2);\n\trelease_firmware(fw);\n\treturn 0;\n}\n\nstatic struct mt352_config yuan_mpc718_mt352_demod = {\n\t.demod_address = 0x1e >> 1,\n\t.adc_clock     = 20480,      \n\t.if2           =  4560,      \n\t.no_tuner      = 1,          \n\t.demod_init    = yuan_mpc718_mt352_init,\n};\n\nstatic struct zl10353_config yuan_mpc718_zl10353_demod = {\n\t.demod_address         = 0x1e >> 1,  \n\t.if2                   = 45600,      \n\t.parallel_ts           = 1,          \n\t.no_tuner              = 1,          \n\t.disable_i2c_gate_ctrl = 1,          \n};\n\nstatic struct zl10353_config gotview_dvd3_zl10353_demod = {\n\t.demod_address         = 0x1e >> 1,  \n\t.if2                   = 45600,      \n\t.parallel_ts           = 1,          \n\t.no_tuner              = 1,          \n\t.disable_i2c_gate_ctrl = 1,          \n};\n\nstatic int dvb_register(struct cx18_stream *stream);\n\n \nstatic int cx18_dvb_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct cx18_stream *stream = demux->priv;\n\tstruct cx18 *cx;\n\tint ret;\n\tu32 v;\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tcx = stream->cx;\n\tCX18_DEBUG_INFO(\"Start feed: pid = 0x%x index = %d\\n\",\n\t\t\tfeed->pid, feed->index);\n\n\tmutex_lock(&cx->serialize_lock);\n\tret = cx18_init_on_first_open(cx);\n\tmutex_unlock(&cx->serialize_lock);\n\tif (ret) {\n\t\tCX18_ERR(\"Failed to initialize firmware starting DVB feed\\n\");\n\t\treturn ret;\n\t}\n\tret = -EINVAL;\n\n\tswitch (cx->card->type) {\n\tcase CX18_CARD_HVR_1600_ESMT:\n\tcase CX18_CARD_HVR_1600_SAMSUNG:\n\tcase CX18_CARD_HVR_1600_S5H1411:\n\t\tv = cx18_read_reg(cx, CX18_REG_DMUX_NUM_PORT_0_CONTROL);\n\t\tv |= 0x00400000;  \n\t\tv |= 0x00002000;  \n\t\tv |= 0x00010000;  \n\t\tv |= 0x00020000;  \n\t\tv |= 0x000c0000;  \n\t\tcx18_write_reg(cx, v, CX18_REG_DMUX_NUM_PORT_0_CONTROL);\n\t\tbreak;\n\n\tcase CX18_CARD_LEADTEK_DVR3100H:\n\tcase CX18_CARD_YUAN_MPC718:\n\tcase CX18_CARD_GOTVIEW_PCI_DVD3:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&stream->dvb->feedlock);\n\tif (stream->dvb->feeding++ == 0) {\n\t\tCX18_DEBUG_INFO(\"Starting Transport DMA\\n\");\n\t\tmutex_lock(&cx->serialize_lock);\n\t\tset_bit(CX18_F_S_STREAMING, &stream->s_flags);\n\t\tret = cx18_start_v4l2_encode_stream(stream);\n\t\tif (ret < 0) {\n\t\t\tCX18_DEBUG_INFO(\"Failed to start Transport DMA\\n\");\n\t\t\tstream->dvb->feeding--;\n\t\t\tif (stream->dvb->feeding == 0)\n\t\t\t\tclear_bit(CX18_F_S_STREAMING, &stream->s_flags);\n\t\t}\n\t\tmutex_unlock(&cx->serialize_lock);\n\t} else\n\t\tret = 0;\n\tmutex_unlock(&stream->dvb->feedlock);\n\n\treturn ret;\n}\n\n \nstatic int cx18_dvb_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct cx18_stream *stream = demux->priv;\n\tstruct cx18 *cx;\n\tint ret = -EINVAL;\n\n\tif (stream) {\n\t\tcx = stream->cx;\n\t\tCX18_DEBUG_INFO(\"Stop feed: pid = 0x%x index = %d\\n\",\n\t\t\t\tfeed->pid, feed->index);\n\n\t\tmutex_lock(&stream->dvb->feedlock);\n\t\tif (--stream->dvb->feeding == 0) {\n\t\t\tCX18_DEBUG_INFO(\"Stopping Transport DMA\\n\");\n\t\t\tmutex_lock(&cx->serialize_lock);\n\t\t\tret = cx18_stop_v4l2_encode_stream(stream, 0);\n\t\t\tmutex_unlock(&cx->serialize_lock);\n\t\t} else\n\t\t\tret = 0;\n\t\tmutex_unlock(&stream->dvb->feedlock);\n\t}\n\n\treturn ret;\n}\n\nint cx18_dvb_register(struct cx18_stream *stream)\n{\n\tstruct cx18 *cx = stream->cx;\n\tstruct cx18_dvb *dvb = stream->dvb;\n\tstruct dvb_adapter *dvb_adapter;\n\tstruct dvb_demux *dvbdemux;\n\tstruct dmx_demux *dmx;\n\tint ret;\n\n\tif (!dvb)\n\t\treturn -EINVAL;\n\n\tdvb->enabled = 0;\n\tdvb->stream = stream;\n\n\tret = dvb_register_adapter(&dvb->dvb_adapter,\n\t\t\tCX18_DRIVER_NAME,\n\t\t\tTHIS_MODULE, &cx->pci_dev->dev, adapter_nr);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tdvb_adapter = &dvb->dvb_adapter;\n\n\tdvbdemux = &dvb->demux;\n\n\tdvbdemux->priv = (void *)stream;\n\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = cx18_dvb_start_feed;\n\tdvbdemux->stop_feed = cx18_dvb_stop_feed;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\n\t\tDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\n\tret = dvb_dmx_init(dvbdemux);\n\tif (ret < 0)\n\t\tgoto err_dvb_unregister_adapter;\n\n\tdmx = &dvbdemux->dmx;\n\n\tdvb->hw_frontend.source = DMX_FRONTEND_0;\n\tdvb->mem_frontend.source = DMX_MEMORY_FE;\n\tdvb->dmxdev.filternum = 256;\n\tdvb->dmxdev.demux = dmx;\n\n\tret = dvb_dmxdev_init(&dvb->dmxdev, dvb_adapter);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmx_release;\n\n\tret = dmx->add_frontend(dmx, &dvb->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmxdev_release;\n\n\tret = dmx->add_frontend(dmx, &dvb->mem_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_hw_frontend;\n\n\tret = dmx->connect_frontend(dmx, &dvb->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_mem_frontend;\n\n\tret = dvb_register(stream);\n\tif (ret < 0)\n\t\tgoto err_disconnect_frontend;\n\n\tdvb_net_init(dvb_adapter, &dvb->dvbnet, dmx);\n\n\tCX18_INFO(\"DVB Frontend registered\\n\");\n\tCX18_INFO(\"Registered DVB adapter%d for %s (%d x %d.%02d kB)\\n\",\n\t\t  stream->dvb->dvb_adapter.num, stream->name,\n\t\t  stream->buffers, stream->buf_size/1024,\n\t\t  (stream->buf_size * 100 / 1024) % 100);\n\n\tmutex_init(&dvb->feedlock);\n\tdvb->enabled = 1;\n\treturn ret;\n\nerr_disconnect_frontend:\n\tdmx->disconnect_frontend(dmx);\nerr_remove_mem_frontend:\n\tdmx->remove_frontend(dmx, &dvb->mem_frontend);\nerr_remove_hw_frontend:\n\tdmx->remove_frontend(dmx, &dvb->hw_frontend);\nerr_dvb_dmxdev_release:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nerr_dvb_dmx_release:\n\tdvb_dmx_release(dvbdemux);\nerr_dvb_unregister_adapter:\n\tdvb_unregister_adapter(dvb_adapter);\nerr_out:\n\treturn ret;\n}\n\nvoid cx18_dvb_unregister(struct cx18_stream *stream)\n{\n\tstruct cx18 *cx = stream->cx;\n\tstruct cx18_dvb *dvb = stream->dvb;\n\tstruct dvb_adapter *dvb_adapter;\n\tstruct dvb_demux *dvbdemux;\n\tstruct dmx_demux *dmx;\n\n\tCX18_INFO(\"unregister DVB\\n\");\n\n\tif (dvb == NULL || !dvb->enabled)\n\t\treturn;\n\n\tdvb_adapter = &dvb->dvb_adapter;\n\tdvbdemux = &dvb->demux;\n\tdmx = &dvbdemux->dmx;\n\n\tdmx->close(dmx);\n\tdvb_net_release(&dvb->dvbnet);\n\tdmx->remove_frontend(dmx, &dvb->mem_frontend);\n\tdmx->remove_frontend(dmx, &dvb->hw_frontend);\n\tdvb_dmxdev_release(&dvb->dmxdev);\n\tdvb_dmx_release(dvbdemux);\n\tdvb_unregister_frontend(dvb->fe);\n\tdvb_frontend_detach(dvb->fe);\n\tdvb_unregister_adapter(dvb_adapter);\n}\n\n \nstatic int dvb_register(struct cx18_stream *stream)\n{\n\tstruct cx18_dvb *dvb = stream->dvb;\n\tstruct cx18 *cx = stream->cx;\n\tint ret = 0;\n\n\tswitch (cx->card->type) {\n\tcase CX18_CARD_HVR_1600_ESMT:\n\tcase CX18_CARD_HVR_1600_SAMSUNG:\n\t\tdvb->fe = dvb_attach(s5h1409_attach,\n\t\t\t&hauppauge_hvr1600_config,\n\t\t\t&cx->i2c_adap[0]);\n\t\tif (dvb->fe != NULL) {\n\t\t\tdvb_attach(mxl5005s_attach, dvb->fe,\n\t\t\t\t&cx->i2c_adap[0],\n\t\t\t\t&hauppauge_hvr1600_tuner);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase CX18_CARD_HVR_1600_S5H1411:\n\t\tdvb->fe = dvb_attach(s5h1411_attach,\n\t\t\t\t     &hcw_s5h1411_config,\n\t\t\t\t     &cx->i2c_adap[0]);\n\t\tif (dvb->fe != NULL)\n\t\t\tdvb_attach(tda18271_attach, dvb->fe,\n\t\t\t\t   0x60, &cx->i2c_adap[0],\n\t\t\t\t   &hauppauge_tda18271_config);\n\t\tbreak;\n\tcase CX18_CARD_LEADTEK_DVR3100H:\n\t\tdvb->fe = dvb_attach(zl10353_attach,\n\t\t\t\t     &leadtek_dvr3100h_demod,\n\t\t\t\t     &cx->i2c_adap[1]);\n\t\tif (dvb->fe != NULL) {\n\t\t\tstruct dvb_frontend *fe;\n\t\t\tstruct xc2028_config cfg = {\n\t\t\t\t.i2c_adap = &cx->i2c_adap[1],\n\t\t\t\t.i2c_addr = 0xc2 >> 1,\n\t\t\t\t.ctrl = NULL,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctrl = {\n\t\t\t\t.fname   = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t\t.demod   = XC3028_FE_ZARLINK456,\n\t\t\t\t.type    = XC2028_AUTO,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctrl);\n\t\t}\n\t\tbreak;\n\tcase CX18_CARD_YUAN_MPC718:\n\t\t \n\t\tdvb->fe = dvb_attach(mt352_attach,\n\t\t\t\t     &yuan_mpc718_mt352_demod,\n\t\t\t\t     &cx->i2c_adap[1]);\n\t\tif (dvb->fe == NULL)\n\t\t\tdvb->fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t     &yuan_mpc718_zl10353_demod,\n\t\t\t\t\t     &cx->i2c_adap[1]);\n\t\tif (dvb->fe != NULL) {\n\t\t\tstruct dvb_frontend *fe;\n\t\t\tstruct xc2028_config cfg = {\n\t\t\t\t.i2c_adap = &cx->i2c_adap[1],\n\t\t\t\t.i2c_addr = 0xc2 >> 1,\n\t\t\t\t.ctrl = NULL,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctrl = {\n\t\t\t\t.fname   = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t\t.demod   = XC3028_FE_ZARLINK456,\n\t\t\t\t.type    = XC2028_AUTO,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctrl);\n\t\t}\n\t\tbreak;\n\tcase CX18_CARD_GOTVIEW_PCI_DVD3:\n\t\t\tdvb->fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t     &gotview_dvd3_zl10353_demod,\n\t\t\t\t\t     &cx->i2c_adap[1]);\n\t\tif (dvb->fe != NULL) {\n\t\t\tstruct dvb_frontend *fe;\n\t\t\tstruct xc2028_config cfg = {\n\t\t\t\t.i2c_adap = &cx->i2c_adap[1],\n\t\t\t\t.i2c_addr = 0xc2 >> 1,\n\t\t\t\t.ctrl = NULL,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctrl = {\n\t\t\t\t.fname   = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t\t.demod   = XC3028_FE_ZARLINK456,\n\t\t\t\t.type    = XC2028_AUTO,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctrl);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (dvb->fe == NULL) {\n\t\tCX18_ERR(\"frontend initialization failed\\n\");\n\t\treturn -1;\n\t}\n\n\tdvb->fe->callback = cx18_reset_tuner_gpio;\n\n\tret = dvb_register_frontend(&dvb->dvb_adapter, dvb->fe);\n\tif (ret < 0) {\n\t\tif (dvb->fe->ops.release)\n\t\t\tdvb->fe->ops.release(dvb->fe);\n\t\treturn ret;\n\t}\n\n\t \n\tcx18_write_reg_expect(cx,\n\t\t\t      (CX18_DMUX_CLK_MASK << 16) | CX18_DMUX_CLK_MASK,\n\t\t\t      CX18_CLOCK_ENABLE2,\n\t\t\t      CX18_DMUX_CLK_MASK,\n\t\t\t      (CX18_DMUX_CLK_MASK << 16) | CX18_DMUX_CLK_MASK);\n\n\treturn ret;\n}\n\nMODULE_FIRMWARE(FWFILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}