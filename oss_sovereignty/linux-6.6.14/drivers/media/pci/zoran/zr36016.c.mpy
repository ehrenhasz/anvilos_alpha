{
  "module_name": "zr36016.c",
  "hash_id": "adaff03b093194ff0469469064266f745df39ee9dc852ca31e794cb3ec6022b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/zoran/zr36016.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n \n#include \"zr36016.h\"\n\n \n#include \"videocodec.h\"\n\n \n#define MAX_CODECS 20\n\n \nstatic int zr36016_codecs;\n\n \n\n \nstatic u8 zr36016_read(struct zr36016 *ptr, u16 reg)\n{\n\tu8 value = 0;\n\tstruct zoran *zr = videocodec_to_zoran(ptr->codec);\n\n\t \n\tif (ptr->codec->master_data->readreg)\n\t\tvalue = (ptr->codec->master_data->readreg(ptr->codec, reg)) & 0xFF;\n\telse\n\t\tzrdev_err(zr, \"%s: invalid I/O setup, nothing read!\\n\", ptr->name);\n\n\tzrdev_dbg(zr, \"%s: reading from 0x%04x: %02x\\n\", ptr->name, reg, value);\n\n\treturn value;\n}\n\nstatic void zr36016_write(struct zr36016 *ptr, u16 reg, u8 value)\n{\n\tstruct zoran *zr = videocodec_to_zoran(ptr->codec);\n\n\tzrdev_dbg(zr, \"%s: writing 0x%02x to 0x%04x\\n\", ptr->name, value, reg);\n\n\t \n\tif (ptr->codec->master_data->writereg)\n\t\tptr->codec->master_data->writereg(ptr->codec, reg, value);\n\telse\n\t\tzrdev_err(zr, \"%s: invalid I/O setup, nothing written!\\n\", ptr->name);\n}\n\n \nstatic u8 zr36016_readi(struct zr36016 *ptr, u16 reg)\n{\n\tu8 value = 0;\n\tstruct zoran *zr = videocodec_to_zoran(ptr->codec);\n\n\t \n\tif ((ptr->codec->master_data->writereg) && (ptr->codec->master_data->readreg)) {\n\t\tptr->codec->master_data->writereg(ptr->codec, ZR016_IADDR, reg & 0x0F);\n\t\tvalue = (ptr->codec->master_data->readreg(ptr->codec, ZR016_IDATA)) & 0xFF;\n\t} else {\n\t\tzrdev_err(zr, \"%s: invalid I/O setup, nothing read (i)!\\n\", ptr->name);\n\t}\n\n\tzrdev_dbg(zr, \"%s: reading indirect from 0x%04x: %02x\\n\",\n\t\t  ptr->name, reg, value);\n\treturn value;\n}\n\nstatic void zr36016_writei(struct zr36016 *ptr, u16 reg, u8 value)\n{\n\tstruct zoran *zr = videocodec_to_zoran(ptr->codec);\n\n\tzrdev_dbg(zr, \"%s: writing indirect 0x%02x to 0x%04x\\n\", ptr->name,\n\t\t  value, reg);\n\n\t \n\tif (ptr->codec->master_data->writereg) {\n\t\tptr->codec->master_data->writereg(ptr->codec, ZR016_IADDR, reg & 0x0F);\n\t\tptr->codec->master_data->writereg(ptr->codec, ZR016_IDATA, value & 0x0FF);\n\t} else {\n\t\tzrdev_err(zr, \"%s: invalid I/O setup, nothing written (i)!\\n\", ptr->name);\n\t}\n}\n\n \n\n \nstatic u8 zr36016_read_version(struct zr36016 *ptr)\n{\n\tptr->version = zr36016_read(ptr, 0) >> 4;\n\treturn ptr->version;\n}\n\n \n\nstatic int zr36016_basic_test(struct zr36016 *ptr)\n{\n\tstruct zoran *zr = videocodec_to_zoran(ptr->codec);\n\n\tif (*KERN_INFO <= CONSOLE_LOGLEVEL_DEFAULT) {\n\t\tint i;\n\n\t\tzr36016_writei(ptr, ZR016I_PAX_LO, 0x55);\n\t\tzrdev_dbg(zr, \"%s: registers: \", ptr->name);\n\t\tfor (i = 0; i <= 0x0b; i++)\n\t\t\tzrdev_dbg(zr, \"%02x \", zr36016_readi(ptr, i));\n\t\tzrdev_dbg(zr, \"\\n\");\n\t}\n\t \n\t \n\tzr36016_writei(ptr, ZR016I_PAX_LO, 0x00);\n\tif (zr36016_readi(ptr, ZR016I_PAX_LO) != 0x0) {\n\t\tzrdev_err(zr, \"%s: attach failed, can't connect to vfe processor!\\n\", ptr->name);\n\t\treturn -ENXIO;\n\t}\n\tzr36016_writei(ptr, ZR016I_PAX_LO, 0x0d0);\n\tif (zr36016_readi(ptr, ZR016I_PAX_LO) != 0x0d0) {\n\t\tzrdev_err(zr, \"%s: attach failed, can't connect to vfe processor!\\n\", ptr->name);\n\t\treturn -ENXIO;\n\t}\n\t \n\tzr36016_read_version(ptr);\n\tif (ptr->version & 0x0c) {\n\t\tzrdev_err(zr, \"%s: attach failed, suspicious version %d found...\\n\", ptr->name,\n\t\t\t  ptr->version);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\t\t \n}\n\n \n\nstatic void zr36016_init(struct zr36016 *ptr)\n{\n\t \n\tzr36016_write(ptr, ZR016_GOSTOP, 0);\n\n\t \n\tzr36016_write(ptr, ZR016_MODE,\n\t\t      ZR016_YUV422 | ZR016_YUV422_YUV422 |\n\t\t      (ptr->mode == CODEC_DO_COMPRESSION ?\n\t\t       ZR016_COMPRESSION : ZR016_EXPANSION));\n\n\t \n\tzr36016_writei(ptr, ZR016I_SETUP1,\n\t\t       (ptr->xdec ? (ZR016_HRFL | ZR016_HORZ) : 0) |\n\t\t       (ptr->ydec ? ZR016_VERT : 0) | ZR016_CNTI);\n\tzr36016_writei(ptr, ZR016I_SETUP2, ZR016_CCIR);\n\n\t \n\t \n\tzr36016_writei(ptr, ZR016I_PAX_HI, ptr->width >> 8);\n\tzr36016_writei(ptr, ZR016I_PAX_LO, ptr->width & 0xFF);\n\tzr36016_writei(ptr, ZR016I_PAY_HI, ptr->height >> 8);\n\tzr36016_writei(ptr, ZR016I_PAY_LO, ptr->height & 0xFF);\n\tzr36016_writei(ptr, ZR016I_NAX_HI, ptr->xoff >> 8);\n\tzr36016_writei(ptr, ZR016I_NAX_LO, ptr->xoff & 0xFF);\n\tzr36016_writei(ptr, ZR016I_NAY_HI, ptr->yoff >> 8);\n\tzr36016_writei(ptr, ZR016I_NAY_LO, ptr->yoff & 0xFF);\n\n\t \n\tzr36016_write(ptr, ZR016_GOSTOP, 1);\n}\n\n \n\n \nstatic int zr36016_set_mode(struct videocodec *codec, int mode)\n{\n\tstruct zr36016 *ptr = (struct zr36016 *)codec->data;\n\tstruct zoran *zr = videocodec_to_zoran(codec);\n\n\tzrdev_dbg(zr, \"%s: set_mode %d call\\n\", ptr->name, mode);\n\n\tif ((mode != CODEC_DO_EXPANSION) && (mode != CODEC_DO_COMPRESSION))\n\t\treturn -EINVAL;\n\n\tptr->mode = mode;\n\tzr36016_init(ptr);\n\n\treturn 0;\n}\n\n \nstatic int zr36016_set_video(struct videocodec *codec, const struct tvnorm *norm,\n\t\t\t     struct vfe_settings *cap, struct vfe_polarity *pol)\n{\n\tstruct zr36016 *ptr = (struct zr36016 *)codec->data;\n\tstruct zoran *zr = videocodec_to_zoran(codec);\n\n\tzrdev_dbg(zr, \"%s: set_video %d.%d, %d/%d-%dx%d (0x%x) call\\n\",\n\t\t  ptr->name, norm->h_start, norm->v_start,\n\t\t  cap->x, cap->y, cap->width, cap->height,\n\t\t  cap->decimation);\n\n\t \n\tptr->width = cap->width;\n\tptr->height = cap->height;\n\t \n\tptr->xoff = (norm->h_start ? norm->h_start : 1) + cap->x;\n\t \n\tptr->yoff = norm->v_start + cap->y;\n\t \n\tptr->xdec = ((cap->decimation & 0xff) == 1) ? 0 : 1;\n\tptr->ydec = (((cap->decimation >> 8) & 0xff) == 1) ? 0 : 1;\n\n\treturn 0;\n}\n\n \nstatic int zr36016_control(struct videocodec *codec, int type, int size, void *data)\n{\n\tstruct zr36016 *ptr = (struct zr36016 *)codec->data;\n\tstruct zoran *zr = videocodec_to_zoran(codec);\n\tint *ival = (int *)data;\n\n\tzrdev_dbg(zr, \"%s: control %d call with %d byte\\n\",\n\t\t  ptr->name, type, size);\n\n\tswitch (type) {\n\tcase CODEC_G_STATUS:\t \n\t\tif (size != sizeof(int))\n\t\t\treturn -EFAULT;\n\t\t*ival = 0;\n\t\tbreak;\n\n\tcase CODEC_G_CODEC_MODE:\n\t\tif (size != sizeof(int))\n\t\t\treturn -EFAULT;\n\t\t*ival = 0;\n\t\tbreak;\n\n\tcase CODEC_S_CODEC_MODE:\n\t\tif (size != sizeof(int))\n\t\t\treturn -EFAULT;\n\t\tif (*ival != 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\treturn 0;\n\n\tcase CODEC_G_VFE:\n\tcase CODEC_S_VFE:\n\t\treturn 0;\n\n\tcase CODEC_S_MMAP:\n\t\t \n\t\treturn -ENXIO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}\n\n \n\nstatic int zr36016_unset(struct videocodec *codec)\n{\n\tstruct zr36016 *ptr = codec->data;\n\tstruct zoran *zr = videocodec_to_zoran(codec);\n\n\tif (ptr) {\n\t\t \n\n\t\tzrdev_dbg(zr, \"%s: finished codec #%d\\n\", ptr->name, ptr->num);\n\t\tkfree(ptr);\n\t\tcodec->data = NULL;\n\n\t\tzr36016_codecs--;\n\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}\n\n \n\nstatic int zr36016_setup(struct videocodec *codec)\n{\n\tstruct zr36016 *ptr;\n\tstruct zoran *zr = videocodec_to_zoran(codec);\n\tint res;\n\n\tzrdev_dbg(zr, \"zr36016: initializing VFE subsystem #%d.\\n\", zr36016_codecs);\n\n\tif (zr36016_codecs == MAX_CODECS) {\n\t\tzrdev_err(zr, \"zr36016: Can't attach more codecs!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\t \n\tptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\tcodec->data = ptr;\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tsnprintf(ptr->name, sizeof(ptr->name), \"zr36016[%d]\", zr36016_codecs);\n\tptr->num = zr36016_codecs++;\n\tptr->codec = codec;\n\n\t \n\tres = zr36016_basic_test(ptr);\n\tif (res < 0) {\n\t\tzr36016_unset(codec);\n\t\treturn res;\n\t}\n\t \n\tptr->mode = CODEC_DO_COMPRESSION;\n\tptr->width = 768;\n\tptr->height = 288;\n\tptr->xdec = 1;\n\tptr->ydec = 0;\n\tzr36016_init(ptr);\n\n\tzrdev_dbg(zr, \"%s: codec v%d attached and running\\n\",\n\t\t  ptr->name, ptr->version);\n\n\treturn 0;\n}\n\nstatic const struct videocodec zr36016_codec = {\n\t.name = \"zr36016\",\n\t.magic = 0L,\t\t \n\t.flags =\n\t    CODEC_FLAG_HARDWARE | CODEC_FLAG_VFE | CODEC_FLAG_ENCODER |\n\t    CODEC_FLAG_DECODER,\n\t.type = CODEC_TYPE_ZR36016,\n\t.setup = zr36016_setup,\t \n\t.unset = zr36016_unset,\n\t.set_mode = zr36016_set_mode,\n\t.set_video = zr36016_set_video,\n\t.control = zr36016_control,\n\t \n};\n\n \n\nint zr36016_init_module(void)\n{\n\tzr36016_codecs = 0;\n\treturn videocodec_register(&zr36016_codec);\n}\n\nvoid zr36016_cleanup_module(void)\n{\n\tif (zr36016_codecs) {\n\t\tpr_debug(\"zr36016: something's wrong - %d codecs left somehow.\\n\",\n\t\t\t zr36016_codecs);\n\t}\n\tvideocodec_unregister(&zr36016_codec);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}