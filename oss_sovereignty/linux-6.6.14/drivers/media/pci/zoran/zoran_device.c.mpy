{
  "module_name": "zoran_device.c",
  "hash_id": "87635c172f06566c0b0fd17f24edbb159b9a2f8da5dbeb995e95c45fc3d9c602",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/zoran/zoran_device.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <linux/spinlock.h>\n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/dma-mapping.h>\n\n#include <linux/io.h>\n\n#include \"videocodec.h\"\n#include \"zoran.h\"\n#include \"zoran_device.h\"\n#include \"zoran_card.h\"\n\n#define IRQ_MASK (ZR36057_ISR_GIRQ0 | \\\n\t\t  ZR36057_ISR_GIRQ1 | \\\n\t\t  ZR36057_ISR_JPEG_REP_IRQ)\n\nstatic bool lml33dpath;\t\t \n\nmodule_param(lml33dpath, bool, 0644);\nMODULE_PARM_DESC(lml33dpath, \"Use digital path capture mode (on LML33 cards)\");\n\n \nstatic void zr36057_init_vfe(struct zoran *zr)\n{\n\tu32 reg;\n\n\treg = btread(ZR36057_VFESPFR);\n\treg |= ZR36057_VFESPFR_LITTLE_ENDIAN;\n\treg &= ~ZR36057_VFESPFR_VCLK_POL;\n\treg |= ZR36057_VFESPFR_EXT_FL;\n\treg |= ZR36057_VFESPFR_TOP_FIELD;\n\tbtwrite(reg, ZR36057_VFESPFR);\n\treg = btread(ZR36057_VDCR);\n\tif (pci_pci_problems & PCIPCI_TRITON)\n\t\t\n\t\treg &= ~ZR36057_VDCR_TRITON;\n\telse\n\t\treg |= ZR36057_VDCR_TRITON;\n\tbtwrite(reg, ZR36057_VDCR);\n}\n\n \n\n \n\nvoid GPIO(struct zoran *zr, int bit, unsigned int value)\n{\n\tu32 reg;\n\tu32 mask;\n\n\t \n\tmask = (1 << (24 + bit)) & 0xff000000;\n\treg = btread(ZR36057_GPPGCR1) & ~mask;\n\tif (value)\n\t\treg |= mask;\n\n\tbtwrite(reg, ZR36057_GPPGCR1);\n\tudelay(1);\n}\n\n \n\nint post_office_wait(struct zoran *zr)\n{\n\tu32 por;\n\n\twhile ((por = btread(ZR36057_POR)) & ZR36057_POR_PO_PEN) {\n\t\t \n\t\t \n\t}\n\tif ((por & ZR36057_POR_PO_TIME) && !zr->card.gws_not_connected) {\n\t\t \n\t\tpci_info(zr->pci_dev, \"pop timeout %08x\\n\", por);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint post_office_write(struct zoran *zr, unsigned int guest,\n\t\t      unsigned int reg, unsigned int value)\n{\n\tu32 por;\n\n\tpor =\n\t    ZR36057_POR_PO_DIR | ZR36057_POR_PO_TIME | ((guest & 7) << 20) |\n\t    ((reg & 7) << 16) | (value & 0xFF);\n\tbtwrite(por, ZR36057_POR);\n\n\treturn post_office_wait(zr);\n}\n\nint post_office_read(struct zoran *zr, unsigned int guest, unsigned int reg)\n{\n\tu32 por;\n\n\tpor = ZR36057_POR_PO_TIME | ((guest & 7) << 20) | ((reg & 7) << 16);\n\tbtwrite(por, ZR36057_POR);\n\tif (post_office_wait(zr) < 0)\n\t\treturn -1;\n\n\treturn btread(ZR36057_POR) & 0xFF;\n}\n\n \n\nvoid jpeg_codec_sleep(struct zoran *zr, int sleep)\n{\n\tGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_SLEEP], !sleep);\n\tif (!sleep) {\n\t\tpci_dbg(zr->pci_dev, \"%s() - wake GPIO=0x%08x\\n\",\n\t\t\t__func__, btread(ZR36057_GPPGCR1));\n\t\tusleep_range(500, 1000);\n\t} else {\n\t\tpci_dbg(zr->pci_dev, \"%s() - sleep GPIO=0x%08x\\n\",\n\t\t\t__func__, btread(ZR36057_GPPGCR1));\n\t\tudelay(2);\n\t}\n}\n\nint jpeg_codec_reset(struct zoran *zr)\n{\n\t \n\tjpeg_codec_sleep(zr, 0);\n\n\tif (zr->card.gpcs[GPCS_JPEG_RESET] != 0xff) {\n\t\tpost_office_write(zr, zr->card.gpcs[GPCS_JPEG_RESET], 0,\n\t\t\t\t  0);\n\t\tudelay(2);\n\t} else {\n\t\tGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_RESET], 0);\n\t\tudelay(2);\n\t\tGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_RESET], 1);\n\t\tudelay(2);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void zr36057_adjust_vfe(struct zoran *zr, enum zoran_codec_mode mode)\n{\n\tu32 reg;\n\n\tswitch (mode) {\n\tcase BUZ_MODE_MOTION_DECOMPRESS:\n\t\tbtand(~ZR36057_VFESPFR_EXT_FL, ZR36057_VFESPFR);\n\t\treg = btread(ZR36057_VFEHCR);\n\t\tif ((reg & (1 << 10)) && zr->card.type != LML33R10)\n\t\t\treg += ((1 << 10) | 1);\n\n\t\tbtwrite(reg, ZR36057_VFEHCR);\n\t\tbreak;\n\tcase BUZ_MODE_MOTION_COMPRESS:\n\tcase BUZ_MODE_IDLE:\n\tdefault:\n\t\tif ((zr->norm & V4L2_STD_NTSC) ||\n\t\t    (zr->card.type == LML33R10 &&\n\t\t     (zr->norm & V4L2_STD_PAL)))\n\t\t\tbtand(~ZR36057_VFESPFR_EXT_FL, ZR36057_VFESPFR);\n\t\telse\n\t\t\tbtor(ZR36057_VFESPFR_EXT_FL, ZR36057_VFESPFR);\n\t\treg = btread(ZR36057_VFEHCR);\n\t\tif (!(reg & (1 << 10)) && zr->card.type != LML33R10)\n\t\t\treg -= ((1 << 10) | 1);\n\n\t\tbtwrite(reg, ZR36057_VFEHCR);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void zr36057_set_vfe(struct zoran *zr, int video_width, int video_height,\n\t\t\t    const struct zoran_format *format)\n{\n\tconst struct tvnorm *tvn;\n\tunsigned int h_start, h_end, v_start, v_end;\n\tunsigned int disp_mode;\n\tunsigned int vid_win_wid, vid_win_ht;\n\tunsigned int hcrop1, hcrop2, vcrop1, vcrop2;\n\tunsigned int wa, we, ha, he;\n\tunsigned int X, Y, hor_dcm, ver_dcm;\n\tu32 reg;\n\n\ttvn = zr->timing;\n\n\twa = tvn->wa;\n\tha = tvn->ha;\n\n\tpci_dbg(zr->pci_dev, \"set_vfe() - width = %d, height = %d\\n\", video_width, video_height);\n\n\tif (video_width < BUZ_MIN_WIDTH ||\n\t    video_height < BUZ_MIN_HEIGHT ||\n\t    video_width > wa || video_height > ha) {\n\t\tpci_err(zr->pci_dev, \"set_vfe: w=%d h=%d not valid\\n\", video_width, video_height);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tvid_win_wid = video_width;\n\tX = DIV_ROUND_UP(vid_win_wid * 64, tvn->wa);\n\twe = (vid_win_wid * 64) / X;\n\thor_dcm = 64 - X;\n\thcrop1 = 2 * ((tvn->wa - we) / 4);\n\thcrop2 = tvn->wa - we - hcrop1;\n\th_start = tvn->h_start ? tvn->h_start : 1;\n\t \n\th_end = h_start + tvn->wa - 1;\n\th_start += hcrop1;\n\th_end -= hcrop2;\n\treg = ((h_start & ZR36057_VFEHCR_HMASK) << ZR36057_VFEHCR_H_START)\n\t    | ((h_end & ZR36057_VFEHCR_HMASK) << ZR36057_VFEHCR_H_END);\n\tif (zr->card.vfe_pol.hsync_pol)\n\t\treg |= ZR36057_VFEHCR_HS_POL;\n\tbtwrite(reg, ZR36057_VFEHCR);\n\n\t \n\tdisp_mode = !(video_height > BUZ_MAX_HEIGHT / 2);\n\tvid_win_ht = disp_mode ? video_height : video_height / 2;\n\tY = DIV_ROUND_UP(vid_win_ht * 64 * 2, tvn->ha);\n\the = (vid_win_ht * 64) / Y;\n\tver_dcm = 64 - Y;\n\tvcrop1 = (tvn->ha / 2 - he) / 2;\n\tvcrop2 = tvn->ha / 2 - he - vcrop1;\n\tv_start = tvn->v_start;\n\t \n\tv_end = v_start + tvn->ha / 2;\t \n\tv_start += vcrop1;\n\tv_end -= vcrop2;\n\treg = ((v_start & ZR36057_VFEVCR_VMASK) << ZR36057_VFEVCR_V_START)\n\t    | ((v_end & ZR36057_VFEVCR_VMASK) << ZR36057_VFEVCR_V_END);\n\tif (zr->card.vfe_pol.vsync_pol)\n\t\treg |= ZR36057_VFEVCR_VS_POL;\n\tbtwrite(reg, ZR36057_VFEVCR);\n\n\t \n\treg = 0;\n\treg |= (hor_dcm << ZR36057_VFESPFR_HOR_DCM);\n\treg |= (ver_dcm << ZR36057_VFESPFR_VER_DCM);\n\treg |= (disp_mode << ZR36057_VFESPFR_DISP_MODE);\n\t \n\t \n\t \n\tif (!(zr->norm & V4L2_STD_NTSC))\n\t\treg |= ZR36057_VFESPFR_EXT_FL;\t \n\treg |= ZR36057_VFESPFR_TOP_FIELD;\n\tif (hor_dcm >= 48)\n\t\treg |= 3 << ZR36057_VFESPFR_H_FILTER;\t \n\telse if (hor_dcm >= 32)\n\t\treg |= 2 << ZR36057_VFESPFR_H_FILTER;\t \n\telse if (hor_dcm >= 16)\n\t\treg |= 1 << ZR36057_VFESPFR_H_FILTER;\t \n\n\treg |= format->vfespfr;\n\tbtwrite(reg, ZR36057_VFESPFR);\n\n\t \n\treg = (16 << ZR36057_VDCR_MIN_PIX)\n\t    | (vid_win_ht << ZR36057_VDCR_VID_WIN_HT)\n\t    | (vid_win_wid << ZR36057_VDCR_VID_WIN_WID);\n\tif (pci_pci_problems & PCIPCI_TRITON)\n\t\t \n\t\treg &= ~ZR36057_VDCR_TRITON;\n\telse\n\t\treg |= ZR36057_VDCR_TRITON;\n\tbtwrite(reg, ZR36057_VDCR);\n\n\tzr36057_adjust_vfe(zr, zr->codec_mode);\n}\n\n \nvoid zr36057_set_memgrab(struct zoran *zr, int mode)\n{\n\tif (mode) {\n\t\t \n\t\tif (btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_SNAP_SHOT)\n\t\t\tpci_warn(zr->pci_dev, \"%s(1) with SnapShot on!?\\n\", __func__);\n\n\t\t \n\t\tbtwrite(IRQ_MASK, ZR36057_ISR);\t \n\t\tbtor(zr->card.vsync_int, ZR36057_ICR);\t \n\n\t\t \n\t\tbtor(ZR36057_VSSFGR_SNAP_SHOT, ZR36057_VSSFGR);\n\n\t\t \n\t\tzr36057_set_vfe(zr, zr->v4l_settings.width,\n\t\t\t\tzr->v4l_settings.height,\n\t\t\t\tzr->v4l_settings.format);\n\t} else {\n\t\t \n\t\tbtand(~zr->card.vsync_int, ZR36057_ICR);\t \n\n\t\t \n\t\tbtand(~ZR36057_VDCR_VID_EN, ZR36057_VDCR);\n\t\tbtand(~ZR36057_VSSFGR_SNAP_SHOT, ZR36057_VSSFGR);\n\t}\n}\n\n \n\nstatic inline void set_frame(struct zoran *zr, int val)\n{\n\tGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_FRAME], val);\n}\n\nstatic void set_videobus_dir(struct zoran *zr, int val)\n{\n\tswitch (zr->card.type) {\n\tcase LML33:\n\tcase LML33R10:\n\t\tif (!lml33dpath)\n\t\t\tGPIO(zr, 5, val);\n\t\telse\n\t\t\tGPIO(zr, 5, 1);\n\t\tbreak;\n\tdefault:\n\t\tGPIO(zr, zr->card.gpio[ZR_GPIO_VID_DIR],\n\t\t     zr->card.gpio_pol[ZR_GPIO_VID_DIR] ? !val : val);\n\t\tbreak;\n\t}\n}\n\nstatic void init_jpeg_queue(struct zoran *zr)\n{\n\tint i;\n\n\t \n\tzr->jpg_que_head = 0;\n\tzr->jpg_dma_head = 0;\n\tzr->jpg_dma_tail = 0;\n\tzr->jpg_que_tail = 0;\n\tzr->jpg_seq_num = 0;\n\tzr->jpeg_error = 0;\n\tzr->num_errors = 0;\n\tzr->jpg_err_seq = 0;\n\tzr->jpg_err_shift = 0;\n\tzr->jpg_queued_num = 0;\n\tfor (i = 0; i < BUZ_NUM_STAT_COM; i++)\n\t\tzr->stat_com[i] = cpu_to_le32(1);\t \n}\n\nstatic void zr36057_set_jpg(struct zoran *zr, enum zoran_codec_mode mode)\n{\n\tconst struct tvnorm *tvn;\n\tu32 reg;\n\n\ttvn = zr->timing;\n\n\t \n\tbtwrite(0, ZR36057_JPC);\n\n\t \n\tswitch (mode) {\n\tcase BUZ_MODE_MOTION_COMPRESS:\n\tdefault:\n\t\treg = ZR36057_JMC_MJPG_CMP_MODE;\n\t\tbreak;\n\n\tcase BUZ_MODE_MOTION_DECOMPRESS:\n\t\treg = ZR36057_JMC_MJPG_EXP_MODE;\n\t\treg |= ZR36057_JMC_SYNC_MSTR;\n\t\t \n\t\t \n\t\tbreak;\n\n\tcase BUZ_MODE_STILL_COMPRESS:\n\t\treg = ZR36057_JMC_JPG_CMP_MODE;\n\t\tbreak;\n\n\tcase BUZ_MODE_STILL_DECOMPRESS:\n\t\treg = ZR36057_JMC_JPG_EXP_MODE;\n\t\tbreak;\n\t}\n\treg |= ZR36057_JMC_JPG;\n\tif (zr->jpg_settings.field_per_buff == 1)\n\t\treg |= ZR36057_JMC_FLD_PER_BUFF;\n\tbtwrite(reg, ZR36057_JMC);\n\n\t \n\tbtor(ZR36057_VFEVCR_VS_POL, ZR36057_VFEVCR);\n\treg = (6 << ZR36057_VSP_VSYNC_SIZE) |\n\t      (tvn->ht << ZR36057_VSP_FRM_TOT);\n\tbtwrite(reg, ZR36057_VSP);\n\treg = ((zr->jpg_settings.img_y + tvn->v_start) << ZR36057_FVAP_NAY) |\n\t      (zr->jpg_settings.img_height << ZR36057_FVAP_PAY);\n\tbtwrite(reg, ZR36057_FVAP);\n\n\t \n\tif (zr->card.vfe_pol.hsync_pol)\n\t\tbtor(ZR36057_VFEHCR_HS_POL, ZR36057_VFEHCR);\n\telse\n\t\tbtand(~ZR36057_VFEHCR_HS_POL, ZR36057_VFEHCR);\n\treg = ((tvn->h_sync_start) << ZR36057_HSP_HSYNC_START) |\n\t      (tvn->wt << ZR36057_HSP_LINE_TOT);\n\tbtwrite(reg, ZR36057_HSP);\n\treg = ((zr->jpg_settings.img_x +\n\t\ttvn->h_start + 4) << ZR36057_FHAP_NAX) |\n\t      (zr->jpg_settings.img_width << ZR36057_FHAP_PAX);\n\tbtwrite(reg, ZR36057_FHAP);\n\n\t \n\tif (zr->jpg_settings.odd_even)\n\t\treg = ZR36057_FPP_ODD_EVEN;\n\telse\n\t\treg = 0;\n\n\tbtwrite(reg, ZR36057_FPP);\n\n\t \n\t \n\n\t \n\tbtwrite(zr->p_sc, ZR36057_JCBA);\n\n\t \n\t \n\tswitch (mode) {\n\tcase BUZ_MODE_STILL_COMPRESS:\n\tcase BUZ_MODE_MOTION_COMPRESS:\n\t\tif (zr->card.type != BUZ)\n\t\t\treg = 140;\n\t\telse\n\t\t\treg = 60;\n\t\tbreak;\n\n\tcase BUZ_MODE_STILL_DECOMPRESS:\n\tcase BUZ_MODE_MOTION_DECOMPRESS:\n\t\treg = 20;\n\t\tbreak;\n\n\tdefault:\n\t\treg = 80;\n\t\tbreak;\n\t}\n\tbtwrite(reg, ZR36057_JCFT);\n\tzr36057_adjust_vfe(zr, mode);\n}\n\nvoid clear_interrupt_counters(struct zoran *zr)\n{\n\tzr->intr_counter_GIRQ1 = 0;\n\tzr->intr_counter_GIRQ0 = 0;\n\tzr->intr_counter_cod_rep_irq = 0;\n\tzr->intr_counter_jpeg_rep_irq = 0;\n\tzr->field_counter = 0;\n\tzr->irq1_in = 0;\n\tzr->irq1_out = 0;\n\tzr->jpeg_in = 0;\n\tzr->jpeg_out = 0;\n\tzr->JPEG_0 = 0;\n\tzr->JPEG_1 = 0;\n\tzr->end_event_missed = 0;\n\tzr->jpeg_missed = 0;\n\tzr->jpeg_max_missed = 0;\n\tzr->jpeg_min_missed = 0x7fffffff;\n}\n\nstatic u32 count_reset_interrupt(struct zoran *zr)\n{\n\tu32 isr;\n\n\tisr = btread(ZR36057_ISR) & 0x78000000;\n\tif (isr) {\n\t\tif (isr & ZR36057_ISR_GIRQ1) {\n\t\t\tbtwrite(ZR36057_ISR_GIRQ1, ZR36057_ISR);\n\t\t\tzr->intr_counter_GIRQ1++;\n\t\t}\n\t\tif (isr & ZR36057_ISR_GIRQ0) {\n\t\t\tbtwrite(ZR36057_ISR_GIRQ0, ZR36057_ISR);\n\t\t\tzr->intr_counter_GIRQ0++;\n\t\t}\n\t\tif (isr & ZR36057_ISR_COD_REP_IRQ) {\n\t\t\tbtwrite(ZR36057_ISR_COD_REP_IRQ, ZR36057_ISR);\n\t\t\tzr->intr_counter_cod_rep_irq++;\n\t\t}\n\t\tif (isr & ZR36057_ISR_JPEG_REP_IRQ) {\n\t\t\tbtwrite(ZR36057_ISR_JPEG_REP_IRQ, ZR36057_ISR);\n\t\t\tzr->intr_counter_jpeg_rep_irq++;\n\t\t}\n\t}\n\treturn isr;\n}\n\nvoid jpeg_start(struct zoran *zr)\n{\n\tint reg;\n\n\tzr->frame_num = 0;\n\n\t \n\tbtwrite(ZR36057_JPC_P_RESET, ZR36057_JPC);\n\t \n\tbtand(~ZR36057_MCTCR_C_FLUSH, ZR36057_MCTCR);\n\t \n\tbtor(ZR36057_JPC_COD_TRNS_EN, ZR36057_JPC);\n\n\t \n\tbtwrite(IRQ_MASK, ZR36057_ISR);\n\t \n\tbtwrite(zr->card.jpeg_int | ZR36057_ICR_JPEG_REP_IRQ | ZR36057_ICR_INT_PIN_EN,\n\t\tZR36057_ICR);\n\n\tset_frame(zr, 0);\t \n\n\t \n\treg = (zr->card.gpcs[1] << ZR36057_JCGI_JPE_GUEST_ID) |\n\t       (0 << ZR36057_JCGI_JPE_GUEST_REG);\n\tbtwrite(reg, ZR36057_JCGI);\n\n\tif (zr->card.video_vfe == CODEC_TYPE_ZR36016 &&\n\t    zr->card.video_codec == CODEC_TYPE_ZR36050) {\n\t\t \n\t\tif (zr->vfe)\n\t\t\tzr36016_write(zr->vfe, 0, 1);\n\n\t\t \n\t\tpost_office_write(zr, 0, 0, 0);\n\t}\n\n\t \n\tbtor(ZR36057_JPC_ACTIVE, ZR36057_JPC);\n\n\t \n\tbtor(ZR36057_JMC_GO_EN, ZR36057_JMC);\n\tusleep_range(30, 100);\n\n\tset_frame(zr, 1);\t \n}\n\nvoid zr36057_enable_jpg(struct zoran *zr, enum zoran_codec_mode mode)\n{\n\tstruct vfe_settings cap;\n\tint field_size = zr->buffer_size / zr->jpg_settings.field_per_buff;\n\n\tzr->codec_mode = mode;\n\n\tcap.x = zr->jpg_settings.img_x;\n\tcap.y = zr->jpg_settings.img_y;\n\tcap.width = zr->jpg_settings.img_width;\n\tcap.height = zr->jpg_settings.img_height;\n\tcap.decimation =\n\t    zr->jpg_settings.hor_dcm | (zr->jpg_settings.ver_dcm << 8);\n\tcap.quality = zr->jpg_settings.jpg_comp.quality;\n\n\tswitch (mode) {\n\tcase BUZ_MODE_MOTION_COMPRESS: {\n\t\tstruct jpeg_app_marker app;\n\t\tstruct jpeg_com_marker com;\n\n\t\t \n\t\tset_videobus_dir(zr, 0);\n\t\tdecoder_call(zr, video, s_stream, 1);\n\t\tencoder_call(zr, video, s_routing, 0, 0, 0);\n\n\t\t \n\t\tjpeg_codec_sleep(zr, 0);\n\n\t\t \n\t\tapp.appn = zr->jpg_settings.jpg_comp.APPn;\n\t\tapp.len = zr->jpg_settings.jpg_comp.APP_len;\n\t\tmemcpy(app.data, zr->jpg_settings.jpg_comp.APP_data, 60);\n\t\tzr->codec->control(zr->codec, CODEC_S_JPEG_APP_DATA,\n\t\t\t\t   sizeof(struct jpeg_app_marker), &app);\n\n\t\tcom.len = zr->jpg_settings.jpg_comp.COM_len;\n\t\tmemcpy(com.data, zr->jpg_settings.jpg_comp.COM_data, 60);\n\t\tzr->codec->control(zr->codec, CODEC_S_JPEG_COM_DATA,\n\t\t\t\t   sizeof(struct jpeg_com_marker), &com);\n\n\t\t \n\t\tzr->codec->control(zr->codec, CODEC_S_JPEG_TDS_BYTE,\n\t\t\t\t   sizeof(int), &field_size);\n\t\tzr->codec->set_video(zr->codec, zr->timing, &cap,\n\t\t\t\t     &zr->card.vfe_pol);\n\t\tzr->codec->set_mode(zr->codec, CODEC_DO_COMPRESSION);\n\n\t\t \n\t\tif (zr->vfe) {\n\t\t\tzr->vfe->control(zr->vfe, CODEC_S_JPEG_TDS_BYTE,\n\t\t\t\t\t sizeof(int), &field_size);\n\t\t\tzr->vfe->set_video(zr->vfe, zr->timing, &cap,\n\t\t\t\t\t   &zr->card.vfe_pol);\n\t\t\tzr->vfe->set_mode(zr->vfe, CODEC_DO_COMPRESSION);\n\t\t}\n\n\t\tinit_jpeg_queue(zr);\n\t\tzr36057_set_jpg(zr, mode);\t \n\n\t\tclear_interrupt_counters(zr);\n\t\tpci_dbg(zr->pci_dev, \"enable_jpg(MOTION_COMPRESS)\\n\");\n\t\tbreak;\n\t}\n\n\tcase BUZ_MODE_MOTION_DECOMPRESS:\n\t\t \n\t\tdecoder_call(zr, video, s_stream, 0);\n\t\tset_videobus_dir(zr, 1);\n\t\tencoder_call(zr, video, s_routing, 1, 0, 0);\n\n\t\t \n\t\tjpeg_codec_sleep(zr, 0);\n\t\t \n\t\tif (zr->vfe) {\n\t\t\tzr->vfe->set_video(zr->vfe, zr->timing, &cap,\n\t\t\t\t\t   &zr->card.vfe_pol);\n\t\t\tzr->vfe->set_mode(zr->vfe, CODEC_DO_EXPANSION);\n\t\t}\n\t\t \n\t\tzr->codec->set_video(zr->codec, zr->timing, &cap,\n\t\t\t\t     &zr->card.vfe_pol);\n\t\tzr->codec->set_mode(zr->codec, CODEC_DO_EXPANSION);\n\n\t\tinit_jpeg_queue(zr);\n\t\tzr36057_set_jpg(zr, mode);\t \n\n\t\tclear_interrupt_counters(zr);\n\t\tpci_dbg(zr->pci_dev, \"enable_jpg(MOTION_DECOMPRESS)\\n\");\n\t\tbreak;\n\n\tcase BUZ_MODE_IDLE:\n\tdefault:\n\t\t \n\t\tbtand(~(zr->card.jpeg_int | ZR36057_ICR_JPEG_REP_IRQ),\n\t\t      ZR36057_ICR);\n\t\tbtwrite(zr->card.jpeg_int | ZR36057_ICR_JPEG_REP_IRQ,\n\t\t\tZR36057_ISR);\n\t\tbtand(~ZR36057_JMC_GO_EN, ZR36057_JMC);\t \n\n\t\tmsleep(50);\n\n\t\tset_videobus_dir(zr, 0);\n\t\tset_frame(zr, 1);\t \n\t\tbtor(ZR36057_MCTCR_C_FLUSH, ZR36057_MCTCR);\t \n\t\tbtwrite(0, ZR36057_JPC);\t \n\t\tbtand(~ZR36057_JMC_VFIFO_FB, ZR36057_JMC);\n\t\tbtand(~ZR36057_JMC_SYNC_MSTR, ZR36057_JMC);\n\t\tjpeg_codec_reset(zr);\n\t\tjpeg_codec_sleep(zr, 1);\n\t\tzr36057_adjust_vfe(zr, mode);\n\n\t\tdecoder_call(zr, video, s_stream, 1);\n\t\tencoder_call(zr, video, s_routing, 0, 0, 0);\n\n\t\tpci_dbg(zr->pci_dev, \"enable_jpg(IDLE)\\n\");\n\t\tbreak;\n\t}\n}\n\n \nvoid zoran_feed_stat_com(struct zoran *zr)\n{\n\t \n\n\tint i, max_stat_com;\n\tstruct zr_buffer *buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tdma_addr_t phys_addr = 0;\n\tunsigned long flags;\n\tunsigned long payload;\n\n\tmax_stat_com =\n\t    (zr->jpg_settings.tmp_dcm ==\n\t     1) ? BUZ_NUM_STAT_COM : (BUZ_NUM_STAT_COM >> 1);\n\n\tspin_lock_irqsave(&zr->queued_bufs_lock, flags);\n\twhile ((zr->jpg_dma_head - zr->jpg_dma_tail) < max_stat_com) {\n\t\tbuf = list_first_entry_or_null(&zr->queued_bufs, struct zr_buffer, queue);\n\t\tif (!buf) {\n\t\t\tpci_err(zr->pci_dev, \"No buffer available to queue\\n\");\n\t\t\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tlist_del(&buf->queue);\n\t\tzr->buf_in_reserve--;\n\t\tvbuf = &buf->vbuf;\n\t\tvbuf->vb2_buf.state = VB2_BUF_STATE_ACTIVE;\n\t\tphys_addr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\t\tpayload = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\n\t\tif (payload == 0)\n\t\t\tpayload = zr->buffer_size;\n\t\tif (zr->jpg_settings.tmp_dcm == 1) {\n\t\t\t \n\t\t\ti = (zr->jpg_dma_head -\n\t\t\t     zr->jpg_err_shift) & BUZ_MASK_STAT_COM;\n\t\t\tif (!(zr->stat_com[i] & cpu_to_le32(1)))\n\t\t\t\tbreak;\n\t\t\tzr->stat_comb[i * 2] = cpu_to_le32(phys_addr);\n\t\t\tzr->stat_comb[i * 2 + 1] = cpu_to_le32((payload >> 1) | 1);\n\t\t\tzr->inuse[i] = buf;\n\t\t\tzr->stat_com[i] = cpu_to_le32(zr->p_scb + i * 2 * 4);\n\t\t} else {\n\t\t\t \n\t\t\ti = ((zr->jpg_dma_head -\n\t\t\t      zr->jpg_err_shift) & 1) * 2;\n\t\t\tif (!(zr->stat_com[i] & cpu_to_le32(1)))\n\t\t\t\tbreak;\n\t\t\tzr->stat_com[i] = cpu_to_le32(zr->p_scb + i * 2 * 4);\n\t\t\tzr->stat_com[i + 1] = cpu_to_le32(zr->p_scb + i * 2 * 4);\n\n\t\t\tzr->stat_comb[i * 2] = cpu_to_le32(phys_addr);\n\t\t\tzr->stat_comb[i * 2 + 1] = cpu_to_le32((payload >> 1) | 1);\n\n\t\t\tzr->inuse[i] = buf;\n\t\t\tzr->inuse[i + 1] = NULL;\n\t\t}\n\t\tzr->jpg_dma_head++;\n\t}\n\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\tif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS)\n\t\tzr->jpg_queued_num++;\n}\n\n \nstatic void zoran_reap_stat_com(struct zoran *zr)\n{\n\t \n\n\tint i;\n\tu32 stat_com;\n\tunsigned int seq;\n\tunsigned int dif;\n\tunsigned long flags;\n\tstruct zr_buffer *buf;\n\tunsigned int size = 0;\n\tu32 fcnt;\n\n\t \n\n\tif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS)\n\t\tzr->jpg_seq_num++;\n\n\tspin_lock_irqsave(&zr->queued_bufs_lock, flags);\n\twhile (zr->jpg_dma_tail < zr->jpg_dma_head) {\n\t\tif (zr->jpg_settings.tmp_dcm == 1)\n\t\t\ti = (zr->jpg_dma_tail - zr->jpg_err_shift) & BUZ_MASK_STAT_COM;\n\t\telse\n\t\t\ti = ((zr->jpg_dma_tail - zr->jpg_err_shift) & 1) * 2;\n\n\t\tstat_com = le32_to_cpu(zr->stat_com[i]);\n\t\tif ((stat_com & 1) == 0) {\n\t\t\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tfcnt = (stat_com & GENMASK(31, 24)) >> 24;\n\t\tsize = (stat_com & GENMASK(22, 1)) >> 1;\n\n\t\tbuf = zr->inuse[i];\n\t\tif (!buf) {\n\t\t\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\t\t\tpci_err(zr->pci_dev, \"No buffer at slot %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\t\tbuf->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\n\t\tif (zr->codec_mode == BUZ_MODE_MOTION_COMPRESS) {\n\t\t\tvb2_set_plane_payload(&buf->vbuf.vb2_buf, 0, size);\n\n\t\t\t \n\t\t\tseq = (fcnt + zr->jpg_err_seq) & 0xff;\n\t\t\tdif = (seq - zr->jpg_seq_num) & 0xff;\n\t\t\tzr->jpg_seq_num += dif;\n\t\t}\n\t\tbuf->vbuf.sequence = zr->jpg_settings.tmp_dcm ==\n\t\t    2 ? (zr->jpg_seq_num >> 1) : zr->jpg_seq_num;\n\t\tzr->inuse[i] = NULL;\n\t\tif (zr->jpg_settings.tmp_dcm != 1)\n\t\t\tbuf->vbuf.field = zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\n\t\telse\n\t\t\tbuf->vbuf.field = zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT;\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\n\n\t\tzr->jpg_dma_tail++;\n\t}\n\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n}\n\nirqreturn_t zoran_irq(int irq, void *dev_id)\n{\n\tstruct zoran *zr = dev_id;\n\tu32 stat, astat;\n\n\tstat = count_reset_interrupt(zr);\n\tastat = stat & IRQ_MASK;\n\tif (astat & zr->card.vsync_int) {\n\t\tif (zr->running == ZORAN_MAP_MODE_RAW) {\n\t\t\tif ((btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_SNAP_SHOT) == 0)\n\t\t\t\tpci_warn(zr->pci_dev, \"BuzIRQ with SnapShot off ???\\n\");\n\t\t\tif ((btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_FRAME_GRAB) == 0)\n\t\t\t\tzr_set_buf(zr);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tif (astat & ZR36057_ISR_JPEG_REP_IRQ) {\n\t\t\tif (zr->codec_mode != BUZ_MODE_MOTION_DECOMPRESS &&\n\t\t\t    zr->codec_mode != BUZ_MODE_MOTION_COMPRESS) {\n\t\t\t\tpci_err(zr->pci_dev, \"JPG IRQ when not in good mode\\n\");\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t\tzr->frame_num++;\n\t\t\tzoran_reap_stat_com(zr);\n\t\t\tzoran_feed_stat_com(zr);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\t \n\t}\n\tzr->ghost_int++;\n\treturn IRQ_HANDLED;\n}\n\nvoid zoran_set_pci_master(struct zoran *zr, int set_master)\n{\n\tif (set_master) {\n\t\tpci_set_master(zr->pci_dev);\n\t} else {\n\t\tu16 command;\n\n\t\tpci_read_config_word(zr->pci_dev, PCI_COMMAND, &command);\n\t\tcommand &= ~PCI_COMMAND_MASTER;\n\t\tpci_write_config_word(zr->pci_dev, PCI_COMMAND, command);\n\t}\n}\n\nvoid zoran_init_hardware(struct zoran *zr)\n{\n\t \n\tzoran_set_pci_master(zr, 1);\n\n\t \n\tif (zr->card.init)\n\t\tzr->card.init(zr);\n\n\tdecoder_call(zr, core, init, 0);\n\tdecoder_call(zr, video, s_std, zr->norm);\n\tdecoder_call(zr, video, s_routing,\n\t\t     zr->card.input[zr->input].muxsel, 0, 0);\n\n\tencoder_call(zr, core, init, 0);\n\tencoder_call(zr, video, s_std_output, zr->norm);\n\tencoder_call(zr, video, s_routing, 0, 0, 0);\n\n\t \n\tjpeg_codec_sleep(zr, 1);\n\tjpeg_codec_sleep(zr, 0);\n\n\t \n\tzr36057_init_vfe(zr);\n\n\tzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\n\n\tbtwrite(IRQ_MASK, ZR36057_ISR);\t\n}\n\nvoid zr36057_restart(struct zoran *zr)\n{\n\tbtwrite(0, ZR36057_SPGPPCR);\n\tusleep_range(1000, 2000);\n\tbtor(ZR36057_SPGPPCR_SOFT_RESET, ZR36057_SPGPPCR);\n\tusleep_range(1000, 2000);\n\n\t \n\tbtwrite(0, ZR36057_JPC);\n\t \n\tbtwrite(ZR36057_SPGPPCR_SOFT_RESET | 0, ZR36057_SPGPPCR);\n\n\t \n\tbtwrite((0x81 << 24) | 0x8888, ZR36057_GPPGCR1);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}