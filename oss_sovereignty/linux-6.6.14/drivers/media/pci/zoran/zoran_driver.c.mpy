{
  "module_name": "zoran_driver.c",
  "hash_id": "ca28cf94ff431770fd1501c079b9c68f6eee0367989ff9cdc59e10a7a151706a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/zoran/zoran_driver.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\n#include <linux/spinlock.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include \"videocodec.h\"\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <linux/mutex.h>\n#include \"zoran.h\"\n#include \"zoran_device.h\"\n#include \"zoran_card.h\"\n\nconst struct zoran_format zoran_formats[] = {\n\t{\n\t\t.name = \"15-bit RGB LE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB555,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 15,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB555 | ZR36057_VFESPFR_ERR_DIF |\n\t\t\t   ZR36057_VFESPFR_LITTLE_ENDIAN,\n\t}, {\n\t\t.name = \"15-bit RGB BE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB555X,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 15,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB555 | ZR36057_VFESPFR_ERR_DIF,\n\t}, {\n\t\t.name = \"16-bit RGB LE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 16,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB565 | ZR36057_VFESPFR_ERR_DIF |\n\t\t\t   ZR36057_VFESPFR_LITTLE_ENDIAN,\n\t}, {\n\t\t.name = \"16-bit RGB BE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB565X,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 16,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB565 | ZR36057_VFESPFR_ERR_DIF,\n\t}, {\n\t\t.name = \"24-bit RGB\",\n\t\t.fourcc = V4L2_PIX_FMT_BGR24,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 24,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB888 | ZR36057_VFESPFR_PACK24,\n\t}, {\n\t\t.name = \"32-bit RGB LE\",\n\t\t.fourcc = V4L2_PIX_FMT_BGR32,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 32,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB888 | ZR36057_VFESPFR_LITTLE_ENDIAN,\n\t}, {\n\t\t.name = \"32-bit RGB BE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB32,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.depth = 32,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_RGB888,\n\t}, {\n\t\t.name = \"4:2:2, packed, YUYV\",\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.colorspace = V4L2_COLORSPACE_SMPTE170M,\n\t\t.depth = 16,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_YUV422,\n\t}, {\n\t\t.name = \"4:2:2, packed, UYVY\",\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.colorspace = V4L2_COLORSPACE_SMPTE170M,\n\t\t.depth = 16,\n\t\t.flags = ZORAN_FORMAT_CAPTURE,\n\t\t.vfespfr = ZR36057_VFESPFR_YUV422 | ZR36057_VFESPFR_LITTLE_ENDIAN,\n\t}, {\n\t\t.name = \"Hardware-encoded Motion-JPEG\",\n\t\t.fourcc = V4L2_PIX_FMT_MJPEG,\n\t\t.colorspace = V4L2_COLORSPACE_SMPTE170M,\n\t\t.depth = 0,\n\t\t.flags = ZORAN_FORMAT_CAPTURE |\n\t\t\t ZORAN_FORMAT_PLAYBACK |\n\t\t\t ZORAN_FORMAT_COMPRESSED,\n\t}\n};\n\n#define NUM_FORMATS ARRAY_SIZE(zoran_formats)\n\n\t \nstatic __u32 zoran_v4l2_calc_bufsize(struct zoran_jpg_settings *settings)\n{\n\t__u8 div = settings->ver_dcm * settings->hor_dcm * settings->tmp_dcm;\n\t__u32 num = (1024 * 512) / (div);\n\t__u32 result = 2;\n\n\tnum--;\n\twhile (num) {\n\t\tnum >>= 1;\n\t\tresult <<= 1;\n\t}\n\n\tif (result < 8192)\n\t\treturn 8192;\n\n\treturn result;\n}\n\n \nstatic int zoran_v4l_set_format(struct zoran *zr, int width, int height,\n\t\t\t\tconst struct zoran_format *format)\n{\n\tint bpp;\n\n\t \n\n\tif (height < BUZ_MIN_HEIGHT || width < BUZ_MIN_WIDTH ||\n\t    height > BUZ_MAX_HEIGHT || width > BUZ_MAX_WIDTH) {\n\t\tpci_dbg(zr->pci_dev, \"%s - wrong frame size (%dx%d)\\n\", __func__, width, height);\n\t\treturn -EINVAL;\n\t}\n\n\tbpp = (format->depth + 7) / 8;\n\n\tzr->buffer_size = height * width * bpp;\n\n\t \n\tif (height * width * bpp > zr->buffer_size) {\n\t\tpci_dbg(zr->pci_dev, \"%s - video buffer size (%d kB) is too small\\n\",\n\t\t\t__func__, zr->buffer_size >> 10);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif ((bpp == 2 && (width & 1)) || (bpp == 3 && (width & 3))) {\n\t\tpci_dbg(zr->pci_dev, \"%s - wrong frame alignment\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tzr->v4l_settings.width = width;\n\tzr->v4l_settings.height = height;\n\tzr->v4l_settings.format = format;\n\tzr->v4l_settings.bytesperline = bpp * zr->v4l_settings.width;\n\n\treturn 0;\n}\n\nstatic int zoran_set_norm(struct zoran *zr, v4l2_std_id norm)\n{\n\tif (!(norm & zr->card.norms)) {\n\t\tpci_dbg(zr->pci_dev, \"%s - unsupported norm %llx\\n\", __func__, norm);\n\t\treturn -EINVAL;\n\t}\n\n\tif (norm & V4L2_STD_SECAM)\n\t\tzr->timing = zr->card.tvn[ZR_NORM_SECAM];\n\telse if (norm & V4L2_STD_NTSC)\n\t\tzr->timing = zr->card.tvn[ZR_NORM_NTSC];\n\telse\n\t\tzr->timing = zr->card.tvn[ZR_NORM_PAL];\n\n\tdecoder_call(zr, video, s_std, norm);\n\tencoder_call(zr, video, s_std_output, norm);\n\n\t \n\tzr->norm = norm;\n\n\treturn 0;\n}\n\nstatic int zoran_set_input(struct zoran *zr, int input)\n{\n\tif (input == zr->input)\n\t\treturn 0;\n\n\tif (input < 0 || input >= zr->card.inputs) {\n\t\tpci_dbg(zr->pci_dev, \"%s - unsupported input %d\\n\", __func__, input);\n\t\treturn -EINVAL;\n\t}\n\n\tzr->input = input;\n\n\tdecoder_call(zr, video, s_routing, zr->card.input[input].muxsel, 0, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int zoran_querycap(struct file *file, void *__fh, struct v4l2_capability *cap)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\tstrscpy(cap->card, ZR_DEVNAME(zr), sizeof(cap->card));\n\tstrscpy(cap->driver, \"zoran\", sizeof(cap->driver));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"PCI:%s\", pci_name(zr->pci_dev));\n\treturn 0;\n}\n\nstatic int zoran_enum_fmt(struct zoran *zr, struct v4l2_fmtdesc *fmt, int flag)\n{\n\tunsigned int num, i;\n\n\tif (fmt->index >= ARRAY_SIZE(zoran_formats))\n\t\treturn -EINVAL;\n\tif (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tfor (num = i = 0; i < NUM_FORMATS; i++) {\n\t\tif (zoran_formats[i].flags & flag && num++ == fmt->index) {\n\t\t\tstrscpy(fmt->description, zoran_formats[i].name,\n\t\t\t\tsizeof(fmt->description));\n\t\t\t \n\t\t\tfmt->pixelformat = zoran_formats[i].fourcc;\n\t\t\tif (zoran_formats[i].flags & ZORAN_FORMAT_COMPRESSED)\n\t\t\t\tfmt->flags |= V4L2_FMT_FLAG_COMPRESSED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int zoran_enum_fmt_vid_cap(struct file *file, void *__fh,\n\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\treturn zoran_enum_fmt(zr, f, ZORAN_FORMAT_CAPTURE);\n}\n\nstatic int zoran_g_fmt_vid_out(struct file *file, void *__fh,\n\t\t\t       struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\tfmt->fmt.pix.width = zr->jpg_settings.img_width / zr->jpg_settings.hor_dcm;\n\tfmt->fmt.pix.height = zr->jpg_settings.img_height * 2 /\n\t\t(zr->jpg_settings.ver_dcm * zr->jpg_settings.tmp_dcm);\n\tfmt->fmt.pix.sizeimage = zr->buffer_size;\n\tfmt->fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;\n\tif (zr->jpg_settings.tmp_dcm == 1)\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\n\telse\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\n\tfmt->fmt.pix.bytesperline = 0;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int zoran_g_fmt_vid_cap(struct file *file, void *__fh,\n\t\t\t       struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\tif (zr->map_mode != ZORAN_MAP_MODE_RAW)\n\t\treturn zoran_g_fmt_vid_out(file, __fh, fmt);\n\tfmt->fmt.pix.width = zr->v4l_settings.width;\n\tfmt->fmt.pix.height = zr->v4l_settings.height;\n\tfmt->fmt.pix.sizeimage = zr->buffer_size;\n\tfmt->fmt.pix.pixelformat = zr->v4l_settings.format->fourcc;\n\tfmt->fmt.pix.colorspace = zr->v4l_settings.format->colorspace;\n\tfmt->fmt.pix.bytesperline = zr->v4l_settings.bytesperline;\n\tif (BUZ_MAX_HEIGHT < (zr->v4l_settings.height * 2))\n\t\tfmt->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\telse\n\t\tfmt->fmt.pix.field = V4L2_FIELD_TOP;\n\treturn 0;\n}\n\nstatic int zoran_try_fmt_vid_out(struct file *file, void *__fh,\n\t\t\t\t struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tstruct zoran_jpg_settings settings;\n\tint res = 0;\n\n\tif (fmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\n\t\treturn -EINVAL;\n\n\tsettings = zr->jpg_settings;\n\n\t \n\tif ((fmt->fmt.pix.height * 2) > BUZ_MAX_HEIGHT)\n\t\tsettings.tmp_dcm = 1;\n\telse\n\t\tsettings.tmp_dcm = 2;\n\tsettings.decimation = 0;\n\tif (fmt->fmt.pix.height <= zr->jpg_settings.img_height / 2)\n\t\tsettings.ver_dcm = 2;\n\telse\n\t\tsettings.ver_dcm = 1;\n\tif (fmt->fmt.pix.width <= zr->jpg_settings.img_width / 4)\n\t\tsettings.hor_dcm = 4;\n\telse if (fmt->fmt.pix.width <= zr->jpg_settings.img_width / 2)\n\t\tsettings.hor_dcm = 2;\n\telse\n\t\tsettings.hor_dcm = 1;\n\tif (settings.tmp_dcm == 1)\n\t\tsettings.field_per_buff = 2;\n\telse\n\t\tsettings.field_per_buff = 1;\n\n\tif (settings.hor_dcm > 1) {\n\t\tsettings.img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\n\t\tsettings.img_width = (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\n\t} else {\n\t\tsettings.img_x = 0;\n\t\tsettings.img_width = BUZ_MAX_WIDTH;\n\t}\n\n\t \n\tres = zoran_check_jpg_settings(zr, &settings, 1);\n\tif (res)\n\t\treturn res;\n\n\t \n\tfmt->fmt.pix.width = settings.img_width / settings.hor_dcm;\n\tfmt->fmt.pix.height = settings.img_height * 2 /\n\t\t(settings.tmp_dcm * settings.ver_dcm);\n\tif (settings.tmp_dcm == 1)\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\n\telse\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\n\n\tfmt->fmt.pix.sizeimage = zoran_v4l2_calc_bufsize(&settings);\n\tfmt->fmt.pix.bytesperline = 0;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn res;\n}\n\nstatic int zoran_try_fmt_vid_cap(struct file *file, void *__fh,\n\t\t\t\t struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tint bpp;\n\tint i;\n\n\tif (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_MJPEG)\n\t\treturn zoran_try_fmt_vid_out(file, __fh, fmt);\n\n\tfor (i = 0; i < NUM_FORMATS; i++)\n\t\tif (zoran_formats[i].fourcc == fmt->fmt.pix.pixelformat)\n\t\t\tbreak;\n\n\tif (i == NUM_FORMATS) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tfmt->fmt.pix.pixelformat = zoran_formats[i].fourcc;\n\tfmt->fmt.pix.colorspace = zoran_formats[i].colorspace;\n\tif (BUZ_MAX_HEIGHT < (fmt->fmt.pix.height * 2))\n\t\tfmt->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\telse\n\t\tfmt->fmt.pix.field = V4L2_FIELD_TOP;\n\n\tbpp = DIV_ROUND_UP(zoran_formats[i].depth, 8);\n\tv4l_bound_align_image(&fmt->fmt.pix.width, BUZ_MIN_WIDTH, BUZ_MAX_WIDTH,\n\t\t\t      bpp == 2 ? 1 : 2,\n\t\t\t      &fmt->fmt.pix.height, BUZ_MIN_HEIGHT, BUZ_MAX_HEIGHT,\n\t\t\t      0, 0);\n\tfmt->fmt.pix.bytesperline = fmt->fmt.pix.width * bpp;\n\tfmt->fmt.pix.sizeimage = fmt->fmt.pix.bytesperline * fmt->fmt.pix.height;\n\treturn 0;\n}\n\nstatic int zoran_s_fmt_vid_out(struct file *file, void *__fh,\n\t\t\t       struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\t__le32 printformat = __cpu_to_le32(fmt->fmt.pix.pixelformat);\n\tstruct zoran_jpg_settings settings;\n\tint res = 0;\n\n\tpci_dbg(zr->pci_dev, \"size=%dx%d, fmt=0x%x (%4.4s)\\n\",\n\t\tfmt->fmt.pix.width, fmt->fmt.pix.height,\n\t\t\tfmt->fmt.pix.pixelformat,\n\t\t\t(char *)&printformat);\n\tif (fmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\n\t\treturn -EINVAL;\n\n\tif (!fmt->fmt.pix.height || !fmt->fmt.pix.width)\n\t\treturn -EINVAL;\n\n\tsettings = zr->jpg_settings;\n\n\t \n\tif (fmt->fmt.pix.height * 2 > BUZ_MAX_HEIGHT)\n\t\tsettings.tmp_dcm = 1;\n\telse\n\t\tsettings.tmp_dcm = 2;\n\tsettings.decimation = 0;\n\tif (fmt->fmt.pix.height <= zr->jpg_settings.img_height / 2)\n\t\tsettings.ver_dcm = 2;\n\telse\n\t\tsettings.ver_dcm = 1;\n\tif (fmt->fmt.pix.width <= zr->jpg_settings.img_width / 4)\n\t\tsettings.hor_dcm = 4;\n\telse if (fmt->fmt.pix.width <= zr->jpg_settings.img_width / 2)\n\t\tsettings.hor_dcm = 2;\n\telse\n\t\tsettings.hor_dcm = 1;\n\tif (settings.tmp_dcm == 1)\n\t\tsettings.field_per_buff = 2;\n\telse\n\t\tsettings.field_per_buff = 1;\n\n\tif (settings.hor_dcm > 1) {\n\t\tsettings.img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\n\t\tsettings.img_width = (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\n\t} else {\n\t\tsettings.img_x = 0;\n\t\tsettings.img_width = BUZ_MAX_WIDTH;\n\t}\n\n\t \n\tres = zoran_check_jpg_settings(zr, &settings, 0);\n\tif (res)\n\t\treturn res;\n\n\t \n\tzr->jpg_settings = settings;\n\n\tif (fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tzr->map_mode = ZORAN_MAP_MODE_JPG_REC;\n\telse\n\t\tzr->map_mode = ZORAN_MAP_MODE_JPG_PLAY;\n\n\tzr->buffer_size = zoran_v4l2_calc_bufsize(&zr->jpg_settings);\n\n\t \n\tfmt->fmt.pix.width = settings.img_width / settings.hor_dcm;\n\tfmt->fmt.pix.height = settings.img_height * 2 /\n\t\t(settings.tmp_dcm * settings.ver_dcm);\n\tif (settings.tmp_dcm == 1)\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\n\telse\n\t\tfmt->fmt.pix.field = (zr->jpg_settings.odd_even ?\n\t\t\t\tV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\n\tfmt->fmt.pix.bytesperline = 0;\n\tfmt->fmt.pix.sizeimage = zr->buffer_size;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn res;\n}\n\nstatic int zoran_s_fmt_vid_cap(struct file *file, void *__fh,\n\t\t\t       struct v4l2_format *fmt)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tstruct zoran_fh *fh = __fh;\n\tint i;\n\tint res = 0;\n\n\tif (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_MJPEG)\n\t\treturn zoran_s_fmt_vid_out(file, fh, fmt);\n\n\tfor (i = 0; i < NUM_FORMATS; i++)\n\t\tif (fmt->fmt.pix.pixelformat == zoran_formats[i].fourcc)\n\t\t\tbreak;\n\tif (i == NUM_FORMATS) {\n\t\tpci_dbg(zr->pci_dev, \"VIDIOC_S_FMT - unknown/unsupported format 0x%x\\n\",\n\t\t\tfmt->fmt.pix.pixelformat);\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tfmt->fmt.pix.pixelformat = zoran_formats[i].fourcc;\n\tif (fmt->fmt.pix.height > BUZ_MAX_HEIGHT)\n\t\tfmt->fmt.pix.height = BUZ_MAX_HEIGHT;\n\tif (fmt->fmt.pix.width > BUZ_MAX_WIDTH)\n\t\tfmt->fmt.pix.width = BUZ_MAX_WIDTH;\n\tif (fmt->fmt.pix.height < BUZ_MIN_HEIGHT)\n\t\tfmt->fmt.pix.height = BUZ_MIN_HEIGHT;\n\tif (fmt->fmt.pix.width < BUZ_MIN_WIDTH)\n\t\tfmt->fmt.pix.width = BUZ_MIN_WIDTH;\n\n\tzr->map_mode = ZORAN_MAP_MODE_RAW;\n\n\tres = zoran_v4l_set_format(zr, fmt->fmt.pix.width, fmt->fmt.pix.height,\n\t\t\t\t   &zoran_formats[i]);\n\tif (res)\n\t\treturn res;\n\n\t \n\tfmt->fmt.pix.bytesperline = zr->v4l_settings.bytesperline;\n\tfmt->fmt.pix.sizeimage = zr->buffer_size;\n\tfmt->fmt.pix.colorspace = zr->v4l_settings.format->colorspace;\n\tif (BUZ_MAX_HEIGHT < (zr->v4l_settings.height * 2))\n\t\tfmt->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\telse\n\t\tfmt->fmt.pix.field = V4L2_FIELD_TOP;\n\treturn res;\n}\n\nstatic int zoran_g_std(struct file *file, void *__fh, v4l2_std_id *std)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\t*std = zr->norm;\n\treturn 0;\n}\n\nstatic int zoran_s_std(struct file *file, void *__fh, v4l2_std_id std)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tint res = 0;\n\n\tif (zr->norm == std)\n\t\treturn 0;\n\n\tif (zr->running != ZORAN_MAP_MODE_NONE)\n\t\treturn -EBUSY;\n\n\tres = zoran_set_norm(zr, std);\n\treturn res;\n}\n\nstatic int zoran_enum_input(struct file *file, void *__fh,\n\t\t\t    struct v4l2_input *inp)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\tif (inp->index >= zr->card.inputs)\n\t\treturn -EINVAL;\n\n\tstrscpy(inp->name, zr->card.input[inp->index].name, sizeof(inp->name));\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->std = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\n\n\t \n\tdecoder_call(zr, video, g_input_status, &inp->status);\n\treturn 0;\n}\n\nstatic int zoran_g_input(struct file *file, void *__fh, unsigned int *input)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\t*input = zr->input;\n\n\treturn 0;\n}\n\nstatic int zoran_s_input(struct file *file, void *__fh, unsigned int input)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tint res;\n\n\tif (zr->running != ZORAN_MAP_MODE_NONE)\n\t\treturn -EBUSY;\n\n\tres = zoran_set_input(zr, input);\n\treturn res;\n}\n\n \nstatic int zoran_g_selection(struct file *file, void *__fh, struct v4l2_selection *sel)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tpci_dbg(zr->pci_dev, \"%s invalid selection type combination\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.top = zr->jpg_settings.img_y;\n\t\tsel->r.left = zr->jpg_settings.img_x;\n\t\tsel->r.width = zr->jpg_settings.img_width;\n\t\tsel->r.height = zr->jpg_settings.img_height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = BUZ_MIN_WIDTH;\n\t\tsel->r.height = BUZ_MIN_HEIGHT;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = BUZ_MAX_WIDTH;\n\t\tsel->r.height = BUZ_MAX_HEIGHT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int zoran_s_selection(struct file *file, void *__fh, struct v4l2_selection *sel)\n{\n\tstruct zoran *zr = video_drvdata(file);\n\tstruct zoran_jpg_settings settings;\n\tint res;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (!sel->r.width || !sel->r.height)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (zr->map_mode == ZORAN_MAP_MODE_RAW) {\n\t\tpci_dbg(zr->pci_dev, \"VIDIOC_S_SELECTION - subcapture only supported for compressed capture\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsettings = zr->jpg_settings;\n\n\t \n\tsettings.img_x = sel->r.left;\n\tsettings.img_y = sel->r.top;\n\tsettings.img_width = sel->r.width;\n\tsettings.img_height = sel->r.height;\n\n\t \n\tres = zoran_check_jpg_settings(zr, &settings, 0);\n\tif (res)\n\t\treturn res;\n\n\t \n\tzr->jpg_settings = settings;\n\treturn res;\n}\n\n \nstatic const struct v4l2_ioctl_ops zoran_ioctl_ops = {\n\t.vidioc_querycap\t\t    = zoran_querycap,\n\t.vidioc_s_selection\t\t    = zoran_s_selection,\n\t.vidioc_g_selection\t\t    = zoran_g_selection,\n\t.vidioc_enum_input\t\t    = zoran_enum_input,\n\t.vidioc_g_input\t\t\t    = zoran_g_input,\n\t.vidioc_s_input\t\t\t    = zoran_s_input,\n\t.vidioc_g_std\t\t\t    = zoran_g_std,\n\t.vidioc_s_std\t\t\t    = zoran_s_std,\n\t.vidioc_create_bufs\t\t    = vb2_ioctl_create_bufs,\n\t.vidioc_reqbufs\t\t\t    = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t    = vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t    = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t    = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf                      = vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t    = vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t    = vb2_ioctl_streamoff,\n\t.vidioc_enum_fmt_vid_cap\t    = zoran_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t    = zoran_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t    = zoran_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t    = zoran_try_fmt_vid_cap,\n\t.vidioc_subscribe_event             = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event           = v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations zoran_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll,\n};\n\nconst struct video_device zoran_template = {\n\t.name = ZORAN_NAME,\n\t.fops = &zoran_fops,\n\t.ioctl_ops = &zoran_ioctl_ops,\n\t.release = &zoran_vdev_release,\n\t.tvnorms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n};\n\nstatic int zr_vb2_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t      unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct zoran *zr = vb2_get_drv_priv(vq);\n\tunsigned int size = zr->buffer_size;\n\n\tpci_dbg(zr->pci_dev, \"%s nbuf=%u nplanes=%u\", __func__, *nbuffers, *nplanes);\n\n\tzr->buf_in_reserve = 0;\n\n\tif (*nbuffers < vq->min_buffers_needed)\n\t\t*nbuffers = vq->min_buffers_needed;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void zr_vb2_queue(struct vb2_buffer *vb)\n{\n\tstruct zoran *zr = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct zr_buffer *buf = vb2_to_zr_buffer(vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&zr->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->queue, &zr->queued_bufs);\n\tzr->buf_in_reserve++;\n\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\tif (zr->running == ZORAN_MAP_MODE_JPG_REC)\n\t\tzoran_feed_stat_com(zr);\n\tzr->queued++;\n}\n\nstatic int zr_vb2_prepare(struct vb2_buffer *vb)\n{\n\tstruct zoran *zr = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (vb2_plane_size(vb, 0) < zr->buffer_size)\n\t\treturn -EINVAL;\n\tzr->prepared++;\n\n\treturn 0;\n}\n\nint zr_set_buf(struct zoran *zr)\n{\n\tstruct zr_buffer *buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tdma_addr_t phys_addr;\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (zr->running == ZORAN_MAP_MODE_NONE)\n\t\treturn 0;\n\n\tif (zr->inuse[0]) {\n\t\tbuf = zr->inuse[0];\n\t\tbuf->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\t\tbuf->vbuf.sequence = zr->vbseq++;\n\t\tvbuf = &buf->vbuf;\n\n\t\tbuf->vbuf.field = V4L2_FIELD_INTERLACED;\n\t\tif (BUZ_MAX_HEIGHT < (zr->v4l_settings.height * 2))\n\t\t\tbuf->vbuf.field = V4L2_FIELD_INTERLACED;\n\t\telse\n\t\t\tbuf->vbuf.field = V4L2_FIELD_TOP;\n\t\tvb2_set_plane_payload(&buf->vbuf.vb2_buf, 0, zr->buffer_size);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tzr->inuse[0] = NULL;\n\t}\n\n\tspin_lock_irqsave(&zr->queued_bufs_lock, flags);\n\tif (list_empty(&zr->queued_bufs)) {\n\t\tbtand(~ZR36057_ICR_INT_PIN_EN, ZR36057_ICR);\n\t\tvb2_queue_error(zr->video_dev->queue);\n\t\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tbuf = list_first_entry_or_null(&zr->queued_bufs, struct zr_buffer, queue);\n\tif (!buf) {\n\t\tbtand(~ZR36057_ICR_INT_PIN_EN, ZR36057_ICR);\n\t\tvb2_queue_error(zr->video_dev->queue);\n\t\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tlist_del(&buf->queue);\n\tzr->buf_in_reserve--;\n\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\n\tvbuf = &buf->vbuf;\n\tvbuf->vb2_buf.state = VB2_BUF_STATE_ACTIVE;\n\tphys_addr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\n\tif (!phys_addr)\n\t\treturn -EINVAL;\n\n\tzr->inuse[0] = buf;\n\n\treg = phys_addr;\n\tbtwrite(reg, ZR36057_VDTR);\n\tif (zr->v4l_settings.height > BUZ_MAX_HEIGHT / 2)\n\t\treg += zr->v4l_settings.bytesperline;\n\tbtwrite(reg, ZR36057_VDBR);\n\n\treg = 0;\n\tif (zr->v4l_settings.height > BUZ_MAX_HEIGHT / 2)\n\t\treg += zr->v4l_settings.bytesperline;\n\treg = (reg << ZR36057_VSSFGR_DISP_STRIDE);\n\treg |= ZR36057_VSSFGR_VID_OVF;\n\treg |= ZR36057_VSSFGR_SNAP_SHOT;\n\treg |= ZR36057_VSSFGR_FRAME_GRAB;\n\tbtwrite(reg, ZR36057_VSSFGR);\n\n\tbtor(ZR36057_VDCR_VID_EN, ZR36057_VDCR);\n\treturn 0;\n}\n\nstatic int zr_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct zoran *zr = vq->drv_priv;\n\tint j;\n\n\tfor (j = 0; j < BUZ_NUM_STAT_COM; j++) {\n\t\tzr->stat_com[j] = cpu_to_le32(1);\n\t\tzr->inuse[j] = NULL;\n\t}\n\tzr->vbseq = 0;\n\n\tif (zr->map_mode != ZORAN_MAP_MODE_RAW) {\n\t\tpci_dbg(zr->pci_dev, \"START JPG\\n\");\n\t\tzr36057_restart(zr);\n\t\tzoran_init_hardware(zr);\n\t\tif (zr->map_mode == ZORAN_MAP_MODE_JPG_REC)\n\t\t\tzr36057_enable_jpg(zr, BUZ_MODE_MOTION_DECOMPRESS);\n\t\telse\n\t\t\tzr36057_enable_jpg(zr, BUZ_MODE_MOTION_COMPRESS);\n\t\tzoran_feed_stat_com(zr);\n\t\tjpeg_start(zr);\n\t\tzr->running = zr->map_mode;\n\t\tbtor(ZR36057_ICR_INT_PIN_EN, ZR36057_ICR);\n\t\treturn 0;\n\t}\n\n\tpci_dbg(zr->pci_dev, \"START RAW\\n\");\n\tzr36057_restart(zr);\n\tzoran_init_hardware(zr);\n\n\tzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\n\tzr36057_set_memgrab(zr, 1);\n\tzr->running = zr->map_mode;\n\tbtor(ZR36057_ICR_INT_PIN_EN, ZR36057_ICR);\n\treturn 0;\n}\n\nstatic void zr_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct zoran *zr = vq->drv_priv;\n\tstruct zr_buffer *buf;\n\tunsigned long flags;\n\tint j;\n\n\tbtand(~ZR36057_ICR_INT_PIN_EN, ZR36057_ICR);\n\tif (zr->map_mode != ZORAN_MAP_MODE_RAW)\n\t\tzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\n\tzr36057_set_memgrab(zr, 0);\n\tzr->running = ZORAN_MAP_MODE_NONE;\n\n\tzoran_set_pci_master(zr, 0);\n\n\tif (!pass_through) {\t \n\t\tdecoder_call(zr, video, s_stream, 0);\n\t\tencoder_call(zr, video, s_routing, 2, 0, 0);\n\t}\n\n\tfor (j = 0; j < BUZ_NUM_STAT_COM; j++) {\n\t\tzr->stat_com[j] = cpu_to_le32(1);\n\t\tif (!zr->inuse[j])\n\t\t\tcontinue;\n\t\tbuf = zr->inuse[j];\n\t\tpci_dbg(zr->pci_dev, \"%s clean buf %d\\n\", __func__, j);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tzr->inuse[j] = NULL;\n\t}\n\n\tspin_lock_irqsave(&zr->queued_bufs_lock, flags);\n\twhile (!list_empty(&zr->queued_bufs)) {\n\t\tbuf = list_entry(zr->queued_bufs.next, struct zr_buffer, queue);\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tzr->buf_in_reserve--;\n\t}\n\tspin_unlock_irqrestore(&zr->queued_bufs_lock, flags);\n\tif (zr->buf_in_reserve)\n\t\tpci_dbg(zr->pci_dev, \"Buffer remaining %d\\n\", zr->buf_in_reserve);\n\tzr->map_mode = ZORAN_MAP_MODE_RAW;\n}\n\nstatic const struct vb2_ops zr_video_qops = {\n\t.queue_setup            = zr_vb2_queue_setup,\n\t.buf_queue              = zr_vb2_queue,\n\t.buf_prepare            = zr_vb2_prepare,\n\t.start_streaming        = zr_vb2_start_streaming,\n\t.stop_streaming         = zr_vb2_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nint zoran_queue_init(struct zoran *zr, struct vb2_queue *vq, int dir)\n{\n\tint err;\n\n\tspin_lock_init(&zr->queued_bufs_lock);\n\tINIT_LIST_HEAD(&zr->queued_bufs);\n\n\tvq->dev = &zr->pci_dev->dev;\n\tvq->type = dir;\n\n\tvq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tvq->drv_priv = zr;\n\tvq->buf_struct_size = sizeof(struct zr_buffer);\n\tvq->ops = &zr_video_qops;\n\tvq->mem_ops = &vb2_dma_contig_memops;\n\tvq->gfp_flags = GFP_DMA32;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->min_buffers_needed = 9;\n\tvq->lock = &zr->lock;\n\terr = vb2_queue_init(vq);\n\tif (err)\n\t\treturn err;\n\tzr->video_dev->queue = vq;\n\treturn 0;\n}\n\nvoid zoran_queue_exit(struct zoran *zr)\n{\n\tvb2_queue_release(zr->video_dev->queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}