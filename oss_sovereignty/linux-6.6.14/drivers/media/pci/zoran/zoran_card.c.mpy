{
  "module_name": "zoran_card.c",
  "hash_id": "708524792f6689485831dd8ffc03874f9b2837251ffe3ff77bf31cb3a7ce2bb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/zoran/zoran_card.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/videodev2.h>\n#include <linux/spinlock.h>\n\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <media/v4l2-common.h>\n#include <media/i2c/bt819.h>\n\n#include \"videocodec.h\"\n#include \"zoran.h\"\n#include \"zoran_card.h\"\n#include \"zoran_device.h\"\n#include \"zr36016.h\"\n#include \"zr36050.h\"\n#include \"zr36060.h\"\n\nextern const struct zoran_format zoran_formats[];\n\nstatic int card[BUZ_MAX] = { [0 ... (BUZ_MAX - 1)] = -1 };\nmodule_param_array(card, int, NULL, 0444);\nMODULE_PARM_DESC(card, \"Card type\");\n\n \n\nstatic unsigned int default_input;\t \nmodule_param(default_input, uint, 0444);\nMODULE_PARM_DESC(default_input,\n\t\t \"Default input (0=Composite, 1=S-Video, 2=Internal)\");\n\nstatic int default_mux = 1;\t \nmodule_param(default_mux, int, 0644);\nMODULE_PARM_DESC(default_mux,\n\t\t \"Default 6 Eyes mux setting (Input selection)\");\n\nstatic int default_norm;\t \nmodule_param(default_norm, int, 0444);\nMODULE_PARM_DESC(default_norm, \"Default norm (0=PAL, 1=NTSC, 2=SECAM)\");\n\n \nstatic int video_nr[BUZ_MAX] = { [0 ... (BUZ_MAX - 1)] = -1 };\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr, \"Video device number (-1=Auto)\");\n\n \n \nint pass_through;\nmodule_param(pass_through, int, 0644);\nMODULE_PARM_DESC(pass_through,\n\t\t \"Pass TV signal through to TV-out when idling\");\n\nint zr36067_debug = 1;\nmodule_param_named(debug, zr36067_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-5)\");\n\n#define ZORAN_VERSION \"0.10.1\"\n\nMODULE_DESCRIPTION(\"Zoran-36057/36067 JPEG codec driver\");\nMODULE_AUTHOR(\"Serguei Miridonov\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ZORAN_VERSION);\n\n#define ZR_DEVICE(subven, subdev, data)\t{ \\\n\t.vendor = PCI_VENDOR_ID_ZORAN, .device = PCI_DEVICE_ID_ZORAN_36057, \\\n\t.subvendor = (subven), .subdevice = (subdev), .driver_data = (data) }\n\nstatic const struct pci_device_id zr36067_pci_tbl[] = {\n\tZR_DEVICE(PCI_VENDOR_ID_MIRO, PCI_DEVICE_ID_MIRO_DC10PLUS, DC10_PLUS),\n\tZR_DEVICE(PCI_VENDOR_ID_MIRO, PCI_DEVICE_ID_MIRO_DC30PLUS, DC30_PLUS),\n\tZR_DEVICE(PCI_VENDOR_ID_ELECTRONICDESIGNGMBH, PCI_DEVICE_ID_LML_33R10, LML33R10),\n\tZR_DEVICE(PCI_VENDOR_ID_IOMEGA, PCI_DEVICE_ID_IOMEGA_BUZ, BUZ),\n\tZR_DEVICE(PCI_ANY_ID, PCI_ANY_ID, NUM_CARDS),\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, zr36067_pci_tbl);\n\nstatic unsigned int zoran_num;\t\t \n\n \nstatic u32 zr36060_read(struct videocodec *codec, u16 reg)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\t__u32 data;\n\n\tif (post_office_wait(zr) || post_office_write(zr, 0, 1, reg >> 8) ||\n\t    post_office_write(zr, 0, 2, reg & 0xff))\n\t\treturn -1;\n\n\tdata = post_office_read(zr, 0, 3) & 0xff;\n\treturn data;\n}\n\nstatic void zr36060_write(struct videocodec *codec, u16 reg, u32 val)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\n\tif (post_office_wait(zr) || post_office_write(zr, 0, 1, reg >> 8) ||\n\t    post_office_write(zr, 0, 2, reg & 0xff))\n\t\treturn;\n\n\tpost_office_write(zr, 0, 3, val & 0xff);\n}\n\n \nstatic u32 zr36050_read(struct videocodec *codec, u16 reg)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\t__u32 data;\n\n\tif (post_office_wait(zr) || post_office_write(zr, 1, 0, reg >> 2))\t\n\t\treturn -1;\n\n\tdata = post_office_read(zr, 0, reg & 0x03) & 0xff;\t\n\treturn data;\n}\n\nstatic void zr36050_write(struct videocodec *codec, u16 reg, u32 val)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\n\tif (post_office_wait(zr) || post_office_write(zr, 1, 0, reg >> 2))\t\n\t\treturn;\n\n\tpost_office_write(zr, 0, reg & 0x03, val & 0xff);\t\n}\n\n \nstatic u32 zr36016_read(struct videocodec *codec, u16 reg)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\t__u32 data;\n\n\tif (post_office_wait(zr))\n\t\treturn -1;\n\n\tdata = post_office_read(zr, 2, reg & 0x03) & 0xff;\t\n\treturn data;\n}\n\n \nvoid zr36016_write(struct videocodec *codec, u16 reg, u32 val)\n{\n\tstruct zoran *zr = (struct zoran *)codec->master_data->data;\n\n\tif (post_office_wait(zr))\n\t\treturn;\n\n\tpost_office_write(zr, 2, reg & 0x03, val & 0x0ff);\t\n}\n\n \n\nstatic void dc10_init(struct zoran *zr)\n{\n\t \n\tGPIO(zr, 4, 0);\n\tGPIO(zr, 5, 1);\n\t \n\tGPIO(zr, 7, 0);\n}\n\nstatic void dc10plus_init(struct zoran *zr)\n{\n}\n\nstatic void buz_init(struct zoran *zr)\n{\n\t \n\tpci_write_config_dword(zr->pci_dev, 0xfc, 0x90680f15);\n\tpci_write_config_dword(zr->pci_dev, 0x0c, 0x00012020);\n\tpci_write_config_dword(zr->pci_dev, 0xe8, 0xc0200000);\n}\n\nstatic void lml33_init(struct zoran *zr)\n{\n\tGPIO(zr, 2, 1);\t\t\n}\n\nstatic void avs6eyes_init(struct zoran *zr)\n{\n\t\n\n\t\n\t\n\n\tint mux = default_mux;  \n\n\tGPIO(zr, 4, 1);  \n\tudelay(2);\n\n\tGPIO(zr, 0, 1);  \n\tGPIO(zr, 1, 0);  \n\tGPIO(zr, 2, mux & 1);    \n\tGPIO(zr, 3, 0);  \n\tGPIO(zr, 4, 0);  \n\tGPIO(zr, 5, mux & 2);    \n\tGPIO(zr, 6, 0);  \n\tGPIO(zr, 7, mux & 4);    \n}\n\nstatic const char *codecid_to_modulename(u16 codecid)\n{\n\tconst char *name = NULL;\n\n\tswitch (codecid) {\n\tcase CODEC_TYPE_ZR36060:\n\t\tname = \"zr36060\";\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36050:\n\t\tname = \"zr36050\";\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36016:\n\t\tname = \"zr36016\";\n\t\tbreak;\n\t}\n\n\treturn name;\n}\n\nstatic int codec_init(struct zoran *zr, u16 codecid)\n{\n\tswitch (codecid) {\n\tcase CODEC_TYPE_ZR36060:\n#ifdef CONFIG_VIDEO_ZORAN_ZR36060\n\t\treturn zr36060_init_module();\n#else\n\t\tpci_err(zr->pci_dev, \"ZR36060 support is not enabled\\n\");\n\t\treturn -EINVAL;\n#endif\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36050:\n#ifdef CONFIG_VIDEO_ZORAN_DC30\n\t\treturn zr36050_init_module();\n#else\n\t\tpci_err(zr->pci_dev, \"ZR36050 support is not enabled\\n\");\n\t\treturn -EINVAL;\n#endif\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36016:\n#ifdef CONFIG_VIDEO_ZORAN_DC30\n\t\treturn zr36016_init_module();\n#else\n\t\tpci_err(zr->pci_dev, \"ZR36016 support is not enabled\\n\");\n\t\treturn -EINVAL;\n#endif\n\t\tbreak;\n\t}\n\n\tpci_err(zr->pci_dev, \"unknown codec id %x\\n\", codecid);\n\treturn -EINVAL;\n}\n\nstatic void codec_exit(struct zoran *zr, u16 codecid)\n{\n\tswitch (codecid) {\n\tcase CODEC_TYPE_ZR36060:\n#ifdef CONFIG_VIDEO_ZORAN_ZR36060\n\t\tzr36060_cleanup_module();\n#endif\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36050:\n#ifdef CONFIG_VIDEO_ZORAN_DC30\n\t\tzr36050_cleanup_module();\n#endif\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36016:\n#ifdef CONFIG_VIDEO_ZORAN_DC30\n\t\tzr36016_cleanup_module();\n#endif\n\t\tbreak;\n\t}\n}\n\nstatic int videocodec_init(struct zoran *zr)\n{\n\tconst char *codec_name, *vfe_name;\n\tint result;\n\n\tcodec_name = codecid_to_modulename(zr->card.video_codec);\n\tif (codec_name) {\n\t\tresult = codec_init(zr, zr->card.video_codec);\n\t\tif (result < 0) {\n\t\t\tpci_err(zr->pci_dev, \"failed to load video codec %s: %d\\n\",\n\t\t\t\tcodec_name, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\tvfe_name = codecid_to_modulename(zr->card.video_vfe);\n\tif (vfe_name) {\n\t\tresult = codec_init(zr, zr->card.video_vfe);\n\t\tif (result < 0) {\n\t\t\tpci_err(zr->pci_dev, \"failed to load video vfe %s: %d\\n\",\n\t\t\t\tvfe_name, result);\n\t\t\tif (codec_name)\n\t\t\t\tcodec_exit(zr, zr->card.video_codec);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void videocodec_exit(struct zoran *zr)\n{\n\tif (zr->card.video_codec != CODEC_TYPE_NONE)\n\t\tcodec_exit(zr, zr->card.video_codec);\n\tif (zr->card.video_vfe != CODEC_TYPE_NONE)\n\t\tcodec_exit(zr, zr->card.video_vfe);\n}\n\nstatic const struct tvnorm f50sqpixel = { 944, 768, 83, 880, 625, 576, 16 };\nstatic const struct tvnorm f60sqpixel = { 780, 640, 51, 716, 525, 480, 12 };\nstatic const struct tvnorm f50ccir601 = { 864, 720, 75, 804, 625, 576, 18 };\nstatic const struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 16 };\n\nstatic const struct tvnorm f50ccir601_lml33 = { 864, 720, 75 + 34, 804, 625, 576, 18 };\nstatic const struct tvnorm f60ccir601_lml33 = { 858, 720, 57 + 34, 788, 525, 480, 16 };\n\n \nstatic const struct tvnorm f50sqpixel_dc10 = { 944, 768, 0, 880, 625, 576, 0 };\nstatic const struct tvnorm f60sqpixel_dc10 = { 780, 640, 0, 716, 525, 480, 12 };\n\n \nstatic const struct tvnorm f50ccir601_lm33r10 = { 864, 720, 74 + 54, 804, 625, 576, 18 };\nstatic const struct tvnorm f60ccir601_lm33r10 = { 858, 720, 56 + 54, 788, 525, 480, 16 };\n\n \nstatic const struct tvnorm f50ccir601_avs6eyes = { 864, 720, 74, 804, 625, 576, 18 };\nstatic const struct tvnorm f60ccir601_avs6eyes = { 858, 720, 56, 788, 525, 480, 16 };\n\nstatic const unsigned short vpx3220_addrs[] = { 0x43, 0x47, I2C_CLIENT_END };\nstatic const unsigned short saa7110_addrs[] = { 0x4e, 0x4f, I2C_CLIENT_END };\nstatic const unsigned short saa7111_addrs[] = { 0x25, 0x24, I2C_CLIENT_END };\nstatic const unsigned short saa7114_addrs[] = { 0x21, 0x20, I2C_CLIENT_END };\nstatic const unsigned short adv717x_addrs[] = { 0x6a, 0x6b, 0x2a, 0x2b, I2C_CLIENT_END };\nstatic const unsigned short ks0127_addrs[] = { 0x6c, 0x6d, I2C_CLIENT_END };\nstatic const unsigned short saa7185_addrs[] = { 0x44, I2C_CLIENT_END };\nstatic const unsigned short bt819_addrs[] = { 0x45, I2C_CLIENT_END };\nstatic const unsigned short bt856_addrs[] = { 0x44, I2C_CLIENT_END };\nstatic const unsigned short bt866_addrs[] = { 0x44, I2C_CLIENT_END };\n\nstatic struct card_info zoran_cards[NUM_CARDS] = {\n\t{\n\t\t.type = DC10_OLD,\n\t\t.name = \"DC10(old)\",\n\t\t.i2c_decoder = \"vpx3220a\",\n\t\t.addrs_decoder = vpx3220_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36050,\n\t\t.video_vfe = CODEC_TYPE_ZR36016,\n\n\t\t.inputs = 3,\n\t\t.input = {\n\t\t\t{ 1, \"Composite\" },\n\t\t\t{ 2, \"S-Video\" },\n\t\t\t{ 0, \"Internal/comp\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t&f50sqpixel_dc10,\n\t\t\t&f60sqpixel_dc10,\n\t\t\t&f50sqpixel_dc10\n\t\t},\n\t\t.jpeg_int = 0,\n\t\t.vsync_int = ZR36057_ISR_GIRQ1,\n\t\t.gpio = { 2, 1, -1, 3, 7, 0, 4, 5 },\n\t\t.gpio_pol = { 0, 0, 0, 1, 0, 0, 0, 0 },\n\t\t.gpcs = { -1, 0 },\n\t\t.vfe_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gws_not_connected = 0,\n\t\t.input_mux = 0,\n\t\t.init = &dc10_init,\n\t}, {\n\t\t.type = DC10_NEW,\n\t\t.name = \"DC10(new)\",\n\t\t.i2c_decoder = \"saa7110\",\n\t\t.addrs_decoder = saa7110_addrs,\n\t\t.i2c_encoder = \"adv7175\",\n\t\t.addrs_encoder = adv717x_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 3,\n\t\t.input = {\n\t\t\t\t{ 0, \"Composite\" },\n\t\t\t\t{ 7, \"S-Video\" },\n\t\t\t\t{ 5, \"Internal/comp\" }\n\t\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t\t&f50sqpixel,\n\t\t\t\t&f60sqpixel,\n\t\t\t\t&f50sqpixel},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ0,\n\t\t.vsync_int = ZR36057_ISR_GIRQ1,\n\t\t.gpio = { 3, 0, 6, 1, 2, -1, 4, 5 },\n\t\t.gpio_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gpcs = { -1, 1},\n\t\t.vfe_pol = { 1, 1, 1, 1, 0, 0, 0, 0 },\n\t\t.gws_not_connected = 0,\n\t\t.input_mux = 0,\n\t\t.init = &dc10plus_init,\n\t}, {\n\t\t.type = DC10_PLUS,\n\t\t.name = \"DC10_PLUS\",\n\t\t.i2c_decoder = \"saa7110\",\n\t\t.addrs_decoder = saa7110_addrs,\n\t\t.i2c_encoder = \"adv7175\",\n\t\t.addrs_encoder = adv717x_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 3,\n\t\t.input = {\n\t\t\t{ 0, \"Composite\" },\n\t\t\t{ 7, \"S-Video\" },\n\t\t\t{ 5, \"Internal/comp\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t&f50sqpixel,\n\t\t\t&f60sqpixel,\n\t\t\t&f50sqpixel\n\t\t},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ0,\n\t\t.vsync_int = ZR36057_ISR_GIRQ1,\n\t\t.gpio = { 3, 0, 6, 1, 2, -1, 4, 5 },\n\t\t.gpio_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gpcs = { -1, 1 },\n\t\t.vfe_pol = { 1, 1, 1, 1, 0, 0, 0, 0 },\n\t\t.gws_not_connected = 0,\n\t\t.input_mux = 0,\n\t\t.init = &dc10plus_init,\n\t}, {\n\t\t.type = DC30,\n\t\t.name = \"DC30\",\n\t\t.i2c_decoder = \"vpx3220a\",\n\t\t.addrs_decoder = vpx3220_addrs,\n\t\t.i2c_encoder = \"adv7175\",\n\t\t.addrs_encoder = adv717x_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36050,\n\t\t.video_vfe = CODEC_TYPE_ZR36016,\n\n\t\t.inputs = 3,\n\t\t.input = {\n\t\t\t{ 1, \"Composite\" },\n\t\t\t{ 2, \"S-Video\" },\n\t\t\t{ 0, \"Internal/comp\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t&f50sqpixel_dc10,\n\t\t\t&f60sqpixel_dc10,\n\t\t\t&f50sqpixel_dc10\n\t\t},\n\t\t.jpeg_int = 0,\n\t\t.vsync_int = ZR36057_ISR_GIRQ1,\n\t\t.gpio = { 2, 1, -1, 3, 7, 0, 4, 5 },\n\t\t.gpio_pol = { 0, 0, 0, 1, 0, 0, 0, 0 },\n\t\t.gpcs = { -1, 0 },\n\t\t.vfe_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gws_not_connected = 0,\n\t\t.input_mux = 0,\n\t\t.init = &dc10_init,\n\t}, {\n\t\t.type = DC30_PLUS,\n\t\t.name = \"DC30_PLUS\",\n\t\t.i2c_decoder = \"vpx3220a\",\n\t\t.addrs_decoder = vpx3220_addrs,\n\t\t.i2c_encoder = \"adv7175\",\n\t\t.addrs_encoder = adv717x_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36050,\n\t\t.video_vfe = CODEC_TYPE_ZR36016,\n\n\t\t.inputs = 3,\n\t\t.input = {\n\t\t\t{ 1, \"Composite\" },\n\t\t\t{ 2, \"S-Video\" },\n\t\t\t{ 0, \"Internal/comp\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t&f50sqpixel_dc10,\n\t\t\t&f60sqpixel_dc10,\n\t\t\t&f50sqpixel_dc10\n\t\t},\n\t\t.jpeg_int = 0,\n\t\t.vsync_int = ZR36057_ISR_GIRQ1,\n\t\t.gpio = { 2, 1, -1, 3, 7, 0, 4, 5 },\n\t\t.gpio_pol = { 0, 0, 0, 1, 0, 0, 0, 0 },\n\t\t.gpcs = { -1, 0 },\n\t\t.vfe_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gws_not_connected = 0,\n\t\t.input_mux = 0,\n\t\t.init = &dc10_init,\n\t}, {\n\t\t.type = LML33,\n\t\t.name = \"LML33\",\n\t\t.i2c_decoder = \"bt819a\",\n\t\t.addrs_decoder = bt819_addrs,\n\t\t.i2c_encoder = \"bt856\",\n\t\t.addrs_encoder = bt856_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 2,\n\t\t.input = {\n\t\t\t{ 0, \"Composite\" },\n\t\t\t{ 7, \"S-Video\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL,\n\t\t.tvn = {\n\t\t\t&f50ccir601_lml33,\n\t\t\t&f60ccir601_lml33,\n\t\t\tNULL\n\t\t},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ1,\n\t\t.vsync_int = ZR36057_ISR_GIRQ0,\n\t\t.gpio = { 1, -1, 3, 5, 7, -1, -1, -1 },\n\t\t.gpio_pol = { 0, 0, 0, 0, 1, 0, 0, 0 },\n\t\t.gpcs = { 3, 1 },\n\t\t.vfe_pol = { 1, 1, 0, 0, 0, 1, 0, 0 },\n\t\t.gws_not_connected = 1,\n\t\t.input_mux = 0,\n\t\t.init = &lml33_init,\n\t}, {\n\t\t.type = LML33R10,\n\t\t.name = \"LML33R10\",\n\t\t.i2c_decoder = \"saa7114\",\n\t\t.addrs_decoder = saa7114_addrs,\n\t\t.i2c_encoder = \"adv7170\",\n\t\t.addrs_encoder = adv717x_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 2,\n\t\t.input = {\n\t\t\t{ 0, \"Composite\" },\n\t\t\t{ 7, \"S-Video\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL,\n\t\t.tvn = {\n\t\t\t&f50ccir601_lm33r10,\n\t\t\t&f60ccir601_lm33r10,\n\t\t\tNULL\n\t\t},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ1,\n\t\t.vsync_int = ZR36057_ISR_GIRQ0,\n\t\t.gpio = { 1, -1, 3, 5, 7, -1, -1, -1 },\n\t\t.gpio_pol = { 0, 0, 0, 0, 1, 0, 0, 0 },\n\t\t.gpcs = { 3, 1 },\n\t\t.vfe_pol = { 1, 1, 0, 0, 0, 1, 0, 0 },\n\t\t.gws_not_connected = 1,\n\t\t.input_mux = 0,\n\t\t.init = &lml33_init,\n\t}, {\n\t\t.type = BUZ,\n\t\t.name = \"Buz\",\n\t\t.i2c_decoder = \"saa7111\",\n\t\t.addrs_decoder = saa7111_addrs,\n\t\t.i2c_encoder = \"saa7185\",\n\t\t.addrs_encoder = saa7185_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 2,\n\t\t.input = {\n\t\t\t{ 3, \"Composite\" },\n\t\t\t{ 7, \"S-Video\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,\n\t\t.tvn = {\n\t\t\t&f50ccir601,\n\t\t\t&f60ccir601,\n\t\t\t&f50ccir601\n\t\t},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ1,\n\t\t.vsync_int = ZR36057_ISR_GIRQ0,\n\t\t.gpio = { 1, -1, 3, -1, -1, -1, -1, -1 },\n\t\t.gpio_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },\n\t\t.gpcs = { 3, 1 },\n\t\t.vfe_pol = { 1, 1, 0, 0, 0, 1, 0, 0 },\n\t\t.gws_not_connected = 1,\n\t\t.input_mux = 0,\n\t\t.init = &buz_init,\n\t}, {\n\t\t.type = AVS6EYES,\n\t\t.name = \"6-Eyes\",\n\t\t \n\t\t.i2c_decoder = \"ks0127\",\n\t\t.addrs_decoder = ks0127_addrs,\n\t\t.i2c_encoder = \"bt866\",\n\t\t.addrs_encoder = bt866_addrs,\n\t\t.video_codec = CODEC_TYPE_ZR36060,\n\n\t\t.inputs = 10,\n\t\t.input = {\n\t\t\t{ 0, \"Composite 1\" },\n\t\t\t{ 1, \"Composite 2\" },\n\t\t\t{ 2, \"Composite 3\" },\n\t\t\t{ 4, \"Composite 4\" },\n\t\t\t{ 5, \"Composite 5\" },\n\t\t\t{ 6, \"Composite 6\" },\n\t\t\t{ 8, \"S-Video 1\" },\n\t\t\t{ 9, \"S-Video 2\" },\n\t\t\t{10, \"S-Video 3\" },\n\t\t\t{15, \"YCbCr\" }\n\t\t},\n\t\t.norms = V4L2_STD_NTSC | V4L2_STD_PAL,\n\t\t.tvn = {\n\t\t\t&f50ccir601_avs6eyes,\n\t\t\t&f60ccir601_avs6eyes,\n\t\t\tNULL\n\t\t},\n\t\t.jpeg_int = ZR36057_ISR_GIRQ1,\n\t\t.vsync_int = ZR36057_ISR_GIRQ0,\n\t\t.gpio = { 1, 0, 3, -1, -1, -1, -1, -1 }, \n\t\t.gpio_pol = { 0, 0, 0, 0, 0, 0, 0, 0 },  \n\t\t.gpcs = { 3, 1 },\t\t\t \n\t\t.vfe_pol = { 1, 0, 0, 0, 0, 1, 0, 0 },   \n\t\t.gws_not_connected = 1,\n\t\t.input_mux = 1,\n\t\t.init = &avs6eyes_init,\n\t}\n\n};\n\n \n \nstatic int zoran_i2c_getsda(void *data)\n{\n\tstruct zoran *zr = (struct zoran *)data;\n\n\treturn (btread(ZR36057_I2CBR) >> 1) & 1;\n}\n\nstatic int zoran_i2c_getscl(void *data)\n{\n\tstruct zoran *zr = (struct zoran *)data;\n\n\treturn btread(ZR36057_I2CBR) & 1;\n}\n\nstatic void zoran_i2c_setsda(void *data, int state)\n{\n\tstruct zoran *zr = (struct zoran *)data;\n\n\tif (state)\n\t\tzr->i2cbr |= 2;\n\telse\n\t\tzr->i2cbr &= ~2;\n\tbtwrite(zr->i2cbr, ZR36057_I2CBR);\n}\n\nstatic void zoran_i2c_setscl(void *data, int state)\n{\n\tstruct zoran *zr = (struct zoran *)data;\n\n\tif (state)\n\t\tzr->i2cbr |= 1;\n\telse\n\t\tzr->i2cbr &= ~1;\n\tbtwrite(zr->i2cbr, ZR36057_I2CBR);\n}\n\nstatic const struct i2c_algo_bit_data zoran_i2c_bit_data_template = {\n\t.setsda = zoran_i2c_setsda,\n\t.setscl = zoran_i2c_setscl,\n\t.getsda = zoran_i2c_getsda,\n\t.getscl = zoran_i2c_getscl,\n\t.udelay = 10,\n\t.timeout = 100,\n};\n\nstatic int zoran_register_i2c(struct zoran *zr)\n{\n\tzr->i2c_algo = zoran_i2c_bit_data_template;\n\tzr->i2c_algo.data = zr;\n\tstrscpy(zr->i2c_adapter.name, ZR_DEVNAME(zr),\n\t\tsizeof(zr->i2c_adapter.name));\n\ti2c_set_adapdata(&zr->i2c_adapter, &zr->v4l2_dev);\n\tzr->i2c_adapter.algo_data = &zr->i2c_algo;\n\tzr->i2c_adapter.dev.parent = &zr->pci_dev->dev;\n\treturn i2c_bit_add_bus(&zr->i2c_adapter);\n}\n\nstatic void zoran_unregister_i2c(struct zoran *zr)\n{\n\ti2c_del_adapter(&zr->i2c_adapter);\n}\n\n \nint zoran_check_jpg_settings(struct zoran *zr,\n\t\t\t     struct zoran_jpg_settings *settings, int try)\n{\n\tint err = 0, err0 = 0;\n\n\tpci_dbg(zr->pci_dev, \"%s - dec: %d, Hdcm: %d, Vdcm: %d, Tdcm: %d\\n\",\n\t\t__func__, settings->decimation, settings->hor_dcm,\n\t\tsettings->ver_dcm, settings->tmp_dcm);\n\tpci_dbg(zr->pci_dev, \"%s - x: %d, y: %d, w: %d, y: %d\\n\", __func__,\n\t\tsettings->img_x, settings->img_y,\n\t\tsettings->img_width, settings->img_height);\n\t \n\tswitch (settings->decimation) {\n\tcase 1:\n\n\t\tsettings->hor_dcm = 1;\n\t\tsettings->ver_dcm = 1;\n\t\tsettings->tmp_dcm = 1;\n\t\tsettings->field_per_buff = 2;\n\t\tsettings->img_x = 0;\n\t\tsettings->img_y = 0;\n\t\tsettings->img_width = BUZ_MAX_WIDTH;\n\t\tsettings->img_height = BUZ_MAX_HEIGHT / 2;\n\t\tbreak;\n\tcase 2:\n\n\t\tsettings->hor_dcm = 2;\n\t\tsettings->ver_dcm = 1;\n\t\tsettings->tmp_dcm = 2;\n\t\tsettings->field_per_buff = 1;\n\t\tsettings->img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\n\t\tsettings->img_y = 0;\n\t\tsettings->img_width =\n\t\t    (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\n\t\tsettings->img_height = BUZ_MAX_HEIGHT / 2;\n\t\tbreak;\n\tcase 4:\n\n\t\tif (zr->card.type == DC10_NEW) {\n\t\t\tpci_dbg(zr->pci_dev,\n\t\t\t\t\"%s - HDec by 4 is not supported on the DC10\\n\",\n\t\t\t\t__func__);\n\t\t\terr0++;\n\t\t\tbreak;\n\t\t}\n\n\t\tsettings->hor_dcm = 4;\n\t\tsettings->ver_dcm = 2;\n\t\tsettings->tmp_dcm = 2;\n\t\tsettings->field_per_buff = 1;\n\t\tsettings->img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\n\t\tsettings->img_y = 0;\n\t\tsettings->img_width =\n\t\t    (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\n\t\tsettings->img_height = BUZ_MAX_HEIGHT / 2;\n\t\tbreak;\n\tcase 0:\n\n\t\t \n\n\t\tif (settings->hor_dcm != 1 && settings->hor_dcm != 2 &&\n\t\t    (zr->card.type == DC10_NEW || settings->hor_dcm != 4)) {\n\t\t\tsettings->hor_dcm = clamp(settings->hor_dcm, 1, 2);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->ver_dcm != 1 && settings->ver_dcm != 2) {\n\t\t\tsettings->ver_dcm = clamp(settings->ver_dcm, 1, 2);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->tmp_dcm != 1 && settings->tmp_dcm != 2) {\n\t\t\tsettings->tmp_dcm = clamp(settings->tmp_dcm, 1, 2);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->field_per_buff != 1 &&\n\t\t    settings->field_per_buff != 2) {\n\t\t\tsettings->field_per_buff = clamp(settings->field_per_buff, 1, 2);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_x < 0) {\n\t\t\tsettings->img_x = 0;\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_y < 0) {\n\t\t\tsettings->img_y = 0;\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_width < 0 || settings->img_width > BUZ_MAX_WIDTH) {\n\t\t\tsettings->img_width = clamp(settings->img_width, 0, (int)BUZ_MAX_WIDTH);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_height < 0 || settings->img_height > BUZ_MAX_HEIGHT / 2) {\n\t\t\tsettings->img_height = clamp(settings->img_height, 0, BUZ_MAX_HEIGHT / 2);\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_x + settings->img_width > BUZ_MAX_WIDTH) {\n\t\t\tsettings->img_x = BUZ_MAX_WIDTH - settings->img_width;\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_y + settings->img_height > BUZ_MAX_HEIGHT / 2) {\n\t\t\tsettings->img_y = BUZ_MAX_HEIGHT / 2 - settings->img_height;\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_width % (16 * settings->hor_dcm) != 0) {\n\t\t\tsettings->img_width -= settings->img_width % (16 * settings->hor_dcm);\n\t\t\tif (settings->img_width == 0)\n\t\t\t\tsettings->img_width = 16 * settings->hor_dcm;\n\t\t\terr0++;\n\t\t}\n\t\tif (settings->img_height % (8 * settings->ver_dcm) != 0) {\n\t\t\tsettings->img_height -= settings->img_height % (8 * settings->ver_dcm);\n\t\t\tif (settings->img_height == 0)\n\t\t\t\tsettings->img_height = 8 * settings->ver_dcm;\n\t\t\terr0++;\n\t\t}\n\n\t\tif (!try && err0) {\n\t\t\tpci_err(zr->pci_dev, \"%s - error in params for decimation = 0\\n\", __func__);\n\t\t\terr++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpci_err(zr->pci_dev, \"%s - decimation = %d, must be 0, 1, 2 or 4\\n\",\n\t\t\t__func__, settings->decimation);\n\t\terr++;\n\t\tbreak;\n\t}\n\n\tif (settings->jpg_comp.quality > 100)\n\t\tsettings->jpg_comp.quality = 100;\n\tif (settings->jpg_comp.quality < 5)\n\t\tsettings->jpg_comp.quality = 5;\n\tif (settings->jpg_comp.APPn < 0)\n\t\tsettings->jpg_comp.APPn = 0;\n\tif (settings->jpg_comp.APPn > 15)\n\t\tsettings->jpg_comp.APPn = 15;\n\tif (settings->jpg_comp.APP_len < 0)\n\t\tsettings->jpg_comp.APP_len = 0;\n\tif (settings->jpg_comp.APP_len > 60)\n\t\tsettings->jpg_comp.APP_len = 60;\n\tif (settings->jpg_comp.COM_len < 0)\n\t\tsettings->jpg_comp.COM_len = 0;\n\tif (settings->jpg_comp.COM_len > 60)\n\t\tsettings->jpg_comp.COM_len = 60;\n\tif (err)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int zoran_init_video_device(struct zoran *zr, struct video_device *video_dev, int dir)\n{\n\tint err;\n\n\t \n\t*video_dev = zoran_template;\n\tvideo_dev->v4l2_dev = &zr->v4l2_dev;\n\tvideo_dev->lock = &zr->lock;\n\tvideo_dev->device_caps = V4L2_CAP_STREAMING | dir;\n\n\tstrscpy(video_dev->name, ZR_DEVNAME(zr), sizeof(video_dev->name));\n\tvideo_dev->vfl_dir = VFL_DIR_RX;\n\tzoran_queue_init(zr, &zr->vq, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\terr = video_register_device(video_dev, VFL_TYPE_VIDEO, video_nr[zr->id]);\n\tif (err < 0)\n\t\treturn err;\n\tvideo_set_drvdata(video_dev, zr);\n\treturn 0;\n}\n\nstatic void zoran_exit_video_devices(struct zoran *zr)\n{\n\tvideo_unregister_device(zr->video_dev);\n\tkfree(zr->video_dev);\n}\n\nstatic int zoran_init_video_devices(struct zoran *zr)\n{\n\tint err;\n\n\tzr->video_dev = video_device_alloc();\n\tif (!zr->video_dev)\n\t\treturn -ENOMEM;\n\n\terr = zoran_init_video_device(zr, zr->video_dev, V4L2_CAP_VIDEO_CAPTURE);\n\tif (err)\n\t\tkfree(zr->video_dev);\n\treturn err;\n}\n\n \nstatic int zoran_i2c_init(struct zoran *zr)\n{\n\tint err;\n\n\tpci_info(zr->pci_dev, \"Initializing i2c bus...\\n\");\n\n\terr = zoran_register_i2c(zr);\n\tif (err) {\n\t\tpci_err(zr->pci_dev, \"%s - cannot initialize i2c bus\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tzr->decoder = v4l2_i2c_new_subdev(&zr->v4l2_dev, &zr->i2c_adapter,\n\t\t\t\t\t  zr->card.i2c_decoder, 0,\n\t\t\t\t\t  zr->card.addrs_decoder);\n\tif (!zr->decoder) {\n\t\tpci_err(zr->pci_dev, \"Fail to get decoder %s\\n\", zr->card.i2c_decoder);\n\t\terr = -EINVAL;\n\t\tgoto error_decoder;\n\t}\n\n\tif (zr->card.i2c_encoder) {\n\t\tzr->encoder = v4l2_i2c_new_subdev(&zr->v4l2_dev, &zr->i2c_adapter,\n\t\t\t\t\t\t  zr->card.i2c_encoder, 0,\n\t\t\t\t\t\t  zr->card.addrs_encoder);\n\t\tif (!zr->encoder) {\n\t\t\tpci_err(zr->pci_dev, \"Fail to get encoder %s\\n\", zr->card.i2c_encoder);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error_decoder;\n\t\t}\n\t}\n\treturn 0;\n\nerror_decoder:\n\tzoran_unregister_i2c(zr);\n\treturn err;\n}\n\nstatic void zoran_i2c_exit(struct zoran *zr)\n{\n\tzoran_unregister_i2c(zr);\n}\n\nvoid zoran_open_init_params(struct zoran *zr)\n{\n\tint i;\n\n\tzr->v4l_settings.width = 192;\n\tzr->v4l_settings.height = 144;\n\tzr->v4l_settings.format = &zoran_formats[7];\t \n\tzr->v4l_settings.bytesperline = zr->v4l_settings.width *\n\t\t((zr->v4l_settings.format->depth + 7) / 8);\n\n\t \n\tzr->jpg_settings.decimation = 1;\n\tzr->jpg_settings.jpg_comp.quality = 50;\t \n\tif (zr->card.type != BUZ)\n\t\tzr->jpg_settings.odd_even = 1;\n\telse\n\t\tzr->jpg_settings.odd_even = 0;\n\tzr->jpg_settings.jpg_comp.APPn = 0;\n\tzr->jpg_settings.jpg_comp.APP_len = 0;\t \n\tmemset(zr->jpg_settings.jpg_comp.APP_data, 0,\n\t       sizeof(zr->jpg_settings.jpg_comp.APP_data));\n\tzr->jpg_settings.jpg_comp.COM_len = 0;\t \n\tmemset(zr->jpg_settings.jpg_comp.COM_data, 0,\n\t       sizeof(zr->jpg_settings.jpg_comp.COM_data));\n\tzr->jpg_settings.jpg_comp.jpeg_markers =\n\t    V4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT;\n\ti = zoran_check_jpg_settings(zr, &zr->jpg_settings, 0);\n\tif (i)\n\t\tpci_err(zr->pci_dev, \"%s internal error\\n\", __func__);\n\n\tzr->buffer_size = zr->v4l_settings.bytesperline * zr->v4l_settings.height;\n\n\tclear_interrupt_counters(zr);\n}\n\nstatic int zr36057_init(struct zoran *zr)\n{\n\tint j, err;\n\n\tpci_info(zr->pci_dev, \"initializing card[%d]\\n\", zr->id);\n\n\t \n\tif (default_norm < 0 || default_norm > 2)\n\t\tdefault_norm = 0;\n\tif (default_norm == 0) {\n\t\tzr->norm = V4L2_STD_PAL;\n\t\tzr->timing = zr->card.tvn[ZR_NORM_PAL];\n\t} else if (default_norm == 1) {\n\t\tzr->norm = V4L2_STD_NTSC;\n\t\tzr->timing = zr->card.tvn[ZR_NORM_NTSC];\n\t} else {\n\t\tzr->norm = V4L2_STD_SECAM;\n\t\tzr->timing = zr->card.tvn[ZR_NORM_SECAM];\n\t}\n\tif (!zr->timing) {\n\t\tpci_warn(zr->pci_dev,\n\t\t\t \"%s - default TV standard not supported by hardware. PAL will be used.\\n\",\n\t\t\t __func__);\n\t\tzr->norm = V4L2_STD_PAL;\n\t\tzr->timing = zr->card.tvn[ZR_NORM_PAL];\n\t}\n\n\tif (default_input > zr->card.inputs - 1) {\n\t\tpci_warn(zr->pci_dev, \"default_input value %d out of range (0-%d)\\n\",\n\t\t\t default_input, zr->card.inputs - 1);\n\t\tdefault_input = 0;\n\t}\n\tzr->input = default_input;\n\n\t \n\tzoran_open_init_params(zr);\n\n\t \n\tzr->stat_com = dma_alloc_coherent(&zr->pci_dev->dev,\n\t\t\t\t\t  BUZ_NUM_STAT_COM * sizeof(u32),\n\t\t\t\t\t  &zr->p_sc, GFP_KERNEL);\n\tif (!zr->stat_com)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < BUZ_NUM_STAT_COM; j++)\n\t\tzr->stat_com[j] = cpu_to_le32(1);  \n\n\tzr->stat_comb = dma_alloc_coherent(&zr->pci_dev->dev,\n\t\t\t\t\t   BUZ_NUM_STAT_COM * sizeof(u32) * 2,\n\t\t\t\t\t   &zr->p_scb, GFP_KERNEL);\n\tif (!zr->stat_comb) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_statcom;\n\t}\n\n\terr = zoran_init_video_devices(zr);\n\tif (err)\n\t\tgoto exit_statcomb;\n\n\tzoran_init_hardware(zr);\n\tif (!pass_through) {\n\t\tdecoder_call(zr, video, s_stream, 0);\n\t\tencoder_call(zr, video, s_routing, 2, 0, 0);\n\t}\n\n\tzr->initialized = 1;\n\treturn 0;\n\nexit_statcomb:\n\tdma_free_coherent(&zr->pci_dev->dev, BUZ_NUM_STAT_COM * sizeof(u32) * 2,\n\t\t\t  zr->stat_comb, zr->p_scb);\nexit_statcom:\n\tdma_free_coherent(&zr->pci_dev->dev, BUZ_NUM_STAT_COM * sizeof(u32),\n\t\t\t  zr->stat_com, zr->p_sc);\n\treturn err;\n}\n\nstatic void zoran_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\n\tstruct zoran *zr = to_zoran(v4l2_dev);\n\n\tif (!zr->initialized)\n\t\tgoto exit_free;\n\n\tdebugfs_remove_recursive(zr->dbgfs_dir);\n\n\tzoran_queue_exit(zr);\n\n\t \n\tif (zr->codec)\n\t\tvideocodec_detach(zr->codec);\n\tif (zr->vfe)\n\t\tvideocodec_detach(zr->vfe);\n\tvideocodec_exit(zr);\n\n\t \n\tzoran_i2c_exit(zr);\n\t \n\tzoran_set_pci_master(zr, 0);\n\t \n\tbtwrite(0, ZR36057_SPGPPCR);\n\tpci_free_irq(zr->pci_dev, 0, zr);\n\t \n\tdma_free_coherent(&zr->pci_dev->dev, BUZ_NUM_STAT_COM * sizeof(u32),\n\t\t\t  zr->stat_com, zr->p_sc);\n\tdma_free_coherent(&zr->pci_dev->dev, BUZ_NUM_STAT_COM * sizeof(u32) * 2,\n\t\t\t  zr->stat_comb, zr->p_scb);\n\tpci_release_regions(pdev);\n\tpci_disable_device(zr->pci_dev);\n\tzoran_exit_video_devices(zr);\nexit_free:\n\tv4l2_ctrl_handler_free(&zr->hdl);\n\tv4l2_device_unregister(&zr->v4l2_dev);\n}\n\nvoid zoran_vdev_release(struct video_device *vdev)\n{\n\tkfree(vdev);\n}\n\nstatic struct videocodec_master *zoran_setup_videocodec(struct zoran *zr,\n\t\t\t\t\t\t\tint type)\n{\n\tstruct videocodec_master *m = NULL;\n\n\tm = devm_kmalloc(&zr->pci_dev->dev, sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn m;\n\n\t \n\tm->magic = 0L;\n\tm->type = 0;\n\n\tm->flags = CODEC_FLAG_ENCODER | CODEC_FLAG_DECODER;\n\tstrscpy(m->name, ZR_DEVNAME(zr), sizeof(m->name));\n\tm->data = zr;\n\n\tswitch (type) {\n\tcase CODEC_TYPE_ZR36060:\n\t\tm->readreg = zr36060_read;\n\t\tm->writereg = zr36060_write;\n\t\tm->flags |= CODEC_FLAG_JPEG | CODEC_FLAG_VFE;\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36050:\n\t\tm->readreg = zr36050_read;\n\t\tm->writereg = zr36050_write;\n\t\tm->flags |= CODEC_FLAG_JPEG;\n\t\tbreak;\n\tcase CODEC_TYPE_ZR36016:\n\t\tm->readreg = zr36016_read;\n\t\tm->writereg = zr36016_write;\n\t\tm->flags |= CODEC_FLAG_VFE;\n\t\tbreak;\n\t}\n\n\treturn m;\n}\n\nstatic void zoran_subdev_notify(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct zoran *zr = to_zoran(sd->v4l2_dev);\n\n\t \n\tif (cmd == BT819_FIFO_RESET_LOW)\n\t\tGPIO(zr, 7, 0);\n\telse if (cmd == BT819_FIFO_RESET_HIGH)\n\t\tGPIO(zr, 7, 1);\n}\n\nstatic int zoran_video_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct zoran *zr = container_of(ctrl->handler, struct zoran, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tzr->jpg_settings.jpg_comp.quality = ctrl->val;\n\t\treturn zoran_check_jpg_settings(zr, &zr->jpg_settings, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops zoran_video_ctrl_ops = {\n\t.s_ctrl = zoran_video_set_ctrl,\n};\n\nstatic int zoran_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct zoran *zr = seq->private;\n\n\tseq_printf(seq, \"Running mode %x\\n\", zr->running);\n\tseq_printf(seq, \"Codec mode %x\\n\", zr->codec_mode);\n\tseq_printf(seq, \"Norm %llx\\n\", zr->norm);\n\tseq_printf(seq, \"Input %d\\n\", zr->input);\n\tseq_printf(seq, \"Buffersize %d\\n\", zr->buffer_size);\n\n\tseq_printf(seq, \"V4L width %dx%d\\n\", zr->v4l_settings.width, zr->v4l_settings.height);\n\tseq_printf(seq, \"V4L bytesperline %d\\n\", zr->v4l_settings.bytesperline);\n\n\tseq_printf(seq, \"JPG decimation %u\\n\", zr->jpg_settings.decimation);\n\tseq_printf(seq, \"JPG hor_dcm %u\\n\", zr->jpg_settings.hor_dcm);\n\tseq_printf(seq, \"JPG ver_dcm %u\\n\", zr->jpg_settings.ver_dcm);\n\tseq_printf(seq, \"JPG tmp_dcm %u\\n\", zr->jpg_settings.tmp_dcm);\n\tseq_printf(seq, \"JPG odd_even %u\\n\", zr->jpg_settings.odd_even);\n\tseq_printf(seq, \"JPG crop %dx%d %d %d\\n\",\n\t\t   zr->jpg_settings.img_x,\n\t\t   zr->jpg_settings.img_y,\n\t\t   zr->jpg_settings.img_width,\n\t\t   zr->jpg_settings.img_height);\n\n\tseq_printf(seq, \"Prepared %u\\n\", zr->prepared);\n\tseq_printf(seq, \"Queued %u\\n\", zr->queued);\n\n\tvideocodec_debugfs_show(seq);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(zoran_debugfs);\n\n \nstatic int zoran_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned char latency, need_latency;\n\tstruct zoran *zr;\n\tint result;\n\tstruct videocodec_master *master_vfe = NULL;\n\tstruct videocodec_master *master_codec = NULL;\n\tint card_num;\n\tunsigned int nr;\n\tint err;\n\n\tpci_info(pdev, \"Zoran MJPEG board driver version %s\\n\", ZORAN_VERSION);\n\n\t \n\tif (pci_pci_problems & (PCIPCI_FAIL | PCIAGP_FAIL | PCIPCI_ALIMAGIK))\n\t\tpci_warn(pdev, \"%s: chipset does not support reliable PCI-PCI DMA\\n\",\n\t\t\t ZORAN_NAME);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\terr = vb2_dma_contig_set_max_seg_size(&pdev->dev, U32_MAX);\n\tif (err)\n\t\treturn err;\n\n\tnr = zoran_num++;\n\tif (nr >= BUZ_MAX) {\n\t\tpci_err(pdev, \"driver limited to %d card(s) maximum\\n\", BUZ_MAX);\n\t\treturn -ENOENT;\n\t}\n\n\tzr = devm_kzalloc(&pdev->dev, sizeof(*zr), GFP_KERNEL);\n\tif (!zr)\n\t\treturn -ENOMEM;\n\n\tzr->v4l2_dev.notify = zoran_subdev_notify;\n\tif (v4l2_device_register(&pdev->dev, &zr->v4l2_dev))\n\t\tgoto zr_free_mem;\n\tzr->pci_dev = pdev;\n\tzr->id = nr;\n\tsnprintf(ZR_DEVNAME(zr), sizeof(ZR_DEVNAME(zr)), \"MJPEG[%u]\", zr->id);\n\tif (v4l2_ctrl_handler_init(&zr->hdl, 10))\n\t\tgoto zr_unreg;\n\tzr->v4l2_dev.ctrl_handler = &zr->hdl;\n\tv4l2_ctrl_new_std(&zr->hdl, &zoran_video_ctrl_ops,\n\t\t\t  V4L2_CID_JPEG_COMPRESSION_QUALITY, 0,\n\t\t\t  100, 1, 50);\n\tspin_lock_init(&zr->spinlock);\n\tmutex_init(&zr->lock);\n\tif (pci_enable_device(pdev))\n\t\tgoto zr_unreg;\n\tzr->revision = zr->pci_dev->revision;\n\n\tpci_info(zr->pci_dev, \"Zoran ZR360%c7 (rev %d), irq: %d, memory: 0x%08llx\\n\",\n\t\t zr->revision < 2 ? '5' : '6', zr->revision,\n\t\t zr->pci_dev->irq, (uint64_t)pci_resource_start(zr->pci_dev, 0));\n\tif (zr->revision >= 2)\n\t\tpci_info(zr->pci_dev, \"Subsystem vendor=0x%04x id=0x%04x\\n\",\n\t\t\t zr->pci_dev->subsystem_vendor, zr->pci_dev->subsystem_device);\n\n\t \n\tif (card[nr] == -1) {\n\t\tif (zr->revision < 2) {\n\t\t\tpci_err(pdev, \"No card type specified, please use the card=X module parameter\\n\");\n\t\t\tpci_err(pdev, \"It is not possible to auto-detect ZR36057 based cards\\n\");\n\t\t\tgoto zr_unreg;\n\t\t}\n\n\t\tcard_num = ent->driver_data;\n\t\tif (card_num >= NUM_CARDS) {\n\t\t\tpci_err(pdev, \"Unknown card, try specifying card=X module parameter\\n\");\n\t\t\tgoto zr_unreg;\n\t\t}\n\t\tpci_info(zr->pci_dev, \"%s() - card %s detected\\n\", __func__,\n\t\t\t zoran_cards[card_num].name);\n\t} else {\n\t\tcard_num = card[nr];\n\t\tif (card_num >= NUM_CARDS || card_num < 0) {\n\t\t\tpci_err(pdev, \"User specified card type %d out of range (0 .. %d)\\n\",\n\t\t\t\tcard_num, NUM_CARDS - 1);\n\t\t\tgoto zr_unreg;\n\t\t}\n\t}\n\n\t \n\tzr->card = zoran_cards[card_num];\n\tsnprintf(ZR_DEVNAME(zr), sizeof(ZR_DEVNAME(zr)), \"%s[%u]\",\n\t\t zr->card.name, zr->id);\n\n\terr = pci_request_regions(pdev, ZR_DEVNAME(zr));\n\tif (err)\n\t\tgoto zr_unreg;\n\n\tzr->zr36057_mem = devm_ioremap(&pdev->dev, pci_resource_start(pdev, 0),\n\t\t\t\t       pci_resource_len(pdev, 0));\n\tif (!zr->zr36057_mem) {\n\t\tpci_err(pdev, \"%s() - ioremap failed\\n\", __func__);\n\t\tgoto zr_pci_release;\n\t}\n\n\tresult = pci_request_irq(pdev, 0, zoran_irq, NULL, zr, ZR_DEVNAME(zr));\n\tif (result < 0) {\n\t\tif (result == -EINVAL) {\n\t\t\tpci_err(pdev, \"%s - bad IRQ number or handler\\n\", __func__);\n\t\t} else if (result == -EBUSY) {\n\t\t\tpci_err(pdev, \"%s - IRQ %d busy, change your PnP config in BIOS\\n\",\n\t\t\t\t__func__, zr->pci_dev->irq);\n\t\t} else {\n\t\t\tpci_err(pdev, \"%s - cannot assign IRQ, error code %d\\n\", __func__, result);\n\t\t}\n\t\tgoto zr_pci_release;\n\t}\n\n\t \n\tpci_read_config_byte(zr->pci_dev, PCI_LATENCY_TIMER,\n\t\t\t     &latency);\n\tneed_latency = zr->revision > 1 ? 32 : 48;\n\tif (latency != need_latency) {\n\t\tpci_info(zr->pci_dev, \"Changing PCI latency from %d to %d\\n\",\n\t\t\t latency, need_latency);\n\t\tpci_write_config_byte(zr->pci_dev, PCI_LATENCY_TIMER, need_latency);\n\t}\n\n\tzr36057_restart(zr);\n\n\terr = zoran_i2c_init(zr);\n\tif (err)\n\t\tgoto zr_free_irq;\n\n\tpci_info(zr->pci_dev, \"Initializing videocodec bus...\\n\");\n\terr = videocodec_init(zr);\n\tif (err)\n\t\tgoto zr_unreg_i2c;\n\n\t \n\tjpeg_codec_sleep(zr, 1);\n\tjpeg_codec_reset(zr);\n\t \n\t \n\tif (zr->card.video_codec != 0) {\n\t\tmaster_codec = zoran_setup_videocodec(zr, zr->card.video_codec);\n\t\tif (!master_codec)\n\t\t\tgoto zr_unreg_videocodec;\n\t\tzr->codec = videocodec_attach(master_codec);\n\t\tif (!zr->codec) {\n\t\t\tpci_err(pdev, \"%s - no codec found\\n\", __func__);\n\t\t\tgoto zr_unreg_videocodec;\n\t\t}\n\t\tif (zr->codec->type != zr->card.video_codec) {\n\t\t\tpci_err(pdev, \"%s - wrong codec\\n\", __func__);\n\t\t\tgoto zr_unreg_videocodec;\n\t\t}\n\t}\n\tif (zr->card.video_vfe != 0) {\n\t\tmaster_vfe = zoran_setup_videocodec(zr, zr->card.video_vfe);\n\t\tif (!master_vfe)\n\t\t\tgoto zr_detach_codec;\n\t\tzr->vfe = videocodec_attach(master_vfe);\n\t\tif (!zr->vfe) {\n\t\t\tpci_err(pdev, \"%s - no VFE found\\n\", __func__);\n\t\t\tgoto zr_detach_codec;\n\t\t}\n\t\tif (zr->vfe->type != zr->card.video_vfe) {\n\t\t\tpci_err(pdev, \"%s = wrong VFE\\n\", __func__);\n\t\t\tgoto zr_detach_vfe;\n\t\t}\n\t}\n\n\t \n\tif ((pci_pci_problems & PCIPCI_NATOMA) && zr->revision <= 1)\n\t\tpci_info(zr->pci_dev, \"ZR36057/Natoma bug, max. buffer size is 128K\\n\");\n\n\tif (zr36057_init(zr) < 0)\n\t\tgoto zr_detach_vfe;\n\n\tzr->map_mode = ZORAN_MAP_MODE_RAW;\n\n\tzr->dbgfs_dir = debugfs_create_dir(ZR_DEVNAME(zr), NULL);\n\tdebugfs_create_file(\"debug\", 0444, zr->dbgfs_dir, zr,\n\t\t\t    &zoran_debugfs_fops);\n\treturn 0;\n\nzr_detach_vfe:\n\tvideocodec_detach(zr->vfe);\nzr_detach_codec:\n\tvideocodec_detach(zr->codec);\nzr_unreg_videocodec:\n\tvideocodec_exit(zr);\nzr_unreg_i2c:\n\tzoran_i2c_exit(zr);\nzr_free_irq:\n\tbtwrite(0, ZR36057_SPGPPCR);\n\tpci_free_irq(zr->pci_dev, 0, zr);\nzr_pci_release:\n\tpci_release_regions(pdev);\nzr_unreg:\n\tv4l2_ctrl_handler_free(&zr->hdl);\n\tv4l2_device_unregister(&zr->v4l2_dev);\nzr_free_mem:\n\n\treturn -ENODEV;\n}\n\nstatic struct pci_driver zoran_driver = {\n\t.name = \"zr36067\",\n\t.id_table = zr36067_pci_tbl,\n\t.probe = zoran_probe,\n\t.remove = zoran_remove,\n};\n\nmodule_pci_driver(zoran_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}