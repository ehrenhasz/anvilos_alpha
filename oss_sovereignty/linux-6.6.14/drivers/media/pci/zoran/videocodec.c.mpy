{
  "module_name": "videocodec.c",
  "hash_id": "5fc2ede4a4f9b0f486911f8d48752fde998853dd77b643bbf27bbfa0c6c065d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/zoran/videocodec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#include \"videocodec.h\"\n\nstruct attached_list {\n\tstruct videocodec *codec;\n\tstruct attached_list *next;\n};\n\nstruct codec_list {\n\tconst struct videocodec *codec;\n\tint attached;\n\tstruct attached_list *list;\n\tstruct codec_list *next;\n};\n\nstatic struct codec_list *codeclist_top;\n\n \n \n \n\nstruct videocodec *videocodec_attach(struct videocodec_master *master)\n{\n\tstruct codec_list *h = codeclist_top;\n\tstruct zoran *zr;\n\tstruct attached_list *a, *ptr;\n\tstruct videocodec *codec;\n\tint res;\n\n\tif (!master) {\n\t\tpr_err(\"%s: no data\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tzr = videocodec_master_to_zoran(master);\n\n\tzrdev_dbg(zr, \"%s: '%s', flags %lx, magic %lx\\n\", __func__,\n\t\t  master->name, master->flags, master->magic);\n\n\tif (!h) {\n\t\tzrdev_err(zr, \"%s: no device available\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\twhile (h) {\n\t\t \n\t\t \n\t\tif ((master->flags & h->codec->flags) == master->flags) {\n\t\t\tzrdev_dbg(zr, \"%s: try '%s'\\n\", __func__, h->codec->name);\n\n\t\t\tcodec = kmemdup(h->codec, sizeof(struct videocodec), GFP_KERNEL);\n\t\t\tif (!codec)\n\t\t\t\tgoto out_kfree;\n\n\t\t\tres = strlen(codec->name);\n\t\t\tsnprintf(codec->name + res, sizeof(codec->name) - res, \"[%d]\", h->attached);\n\t\t\tcodec->master_data = master;\n\t\t\tres = codec->setup(codec);\n\t\t\tif (res == 0) {\n\t\t\t\tzrdev_dbg(zr, \"%s: '%s'\\n\", __func__, codec->name);\n\t\t\t\tptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\t\t\t\tif (!ptr)\n\t\t\t\t\tgoto out_kfree;\n\t\t\t\tptr->codec = codec;\n\n\t\t\t\ta = h->list;\n\t\t\t\tif (!a) {\n\t\t\t\t\th->list = ptr;\n\t\t\t\t\tzrdev_dbg(zr, \"videocodec: first element\\n\");\n\t\t\t\t} else {\n\t\t\t\t\twhile (a->next)\n\t\t\t\t\t\ta = a->next;\t \n\t\t\t\t\ta->next = ptr;\n\t\t\t\t\tzrdev_dbg(zr, \"videocodec: in after '%s'\\n\",\n\t\t\t\t\t\t  h->codec->name);\n\t\t\t\t}\n\n\t\t\t\th->attached += 1;\n\t\t\t\treturn codec;\n\t\t\t}\n\t\t\tkfree(codec);\n\t\t}\n\t\th = h->next;\n\t}\n\n\tzrdev_err(zr, \"%s: no codec found!\\n\", __func__);\n\treturn NULL;\n\n out_kfree:\n\tkfree(codec);\n\treturn NULL;\n}\n\nint videocodec_detach(struct videocodec *codec)\n{\n\tstruct codec_list *h = codeclist_top;\n\tstruct zoran *zr;\n\tstruct attached_list *a, *prev;\n\tint res;\n\n\tif (!codec) {\n\t\tpr_err(\"%s: no data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tzr = videocodec_to_zoran(codec);\n\n\tzrdev_dbg(zr, \"%s: '%s', type: %x, flags %lx, magic %lx\\n\", __func__,\n\t\t  codec->name, codec->type, codec->flags, codec->magic);\n\n\tif (!h) {\n\t\tzrdev_err(zr, \"%s: no device left...\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\twhile (h) {\n\t\ta = h->list;\n\t\tprev = NULL;\n\t\twhile (a) {\n\t\t\tif (codec == a->codec) {\n\t\t\t\tres = a->codec->unset(a->codec);\n\t\t\t\tif (res >= 0) {\n\t\t\t\t\tzrdev_dbg(zr, \"%s: '%s'\\n\", __func__,\n\t\t\t\t\t\t  a->codec->name);\n\t\t\t\t\ta->codec->master_data = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tzrdev_err(zr, \"%s: '%s'\\n\", __func__, a->codec->name);\n\t\t\t\t\ta->codec->master_data = NULL;\n\t\t\t\t}\n\t\t\t\tif (!prev) {\n\t\t\t\t\th->list = a->next;\n\t\t\t\t\tzrdev_dbg(zr, \"videocodec: delete first\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprev->next = a->next;\n\t\t\t\t\tzrdev_dbg(zr, \"videocodec: delete middle\\n\");\n\t\t\t\t}\n\t\t\t\tkfree(a->codec);\n\t\t\t\tkfree(a);\n\t\t\t\th->attached -= 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprev = a;\n\t\t\ta = a->next;\n\t\t}\n\t\th = h->next;\n\t}\n\n\tzrdev_err(zr, \"%s: given codec not found!\\n\", __func__);\n\treturn -EINVAL;\n}\n\nint videocodec_register(const struct videocodec *codec)\n{\n\tstruct codec_list *ptr, *h = codeclist_top;\n\tstruct zoran *zr;\n\n\tif (!codec) {\n\t\tpr_err(\"%s: no data!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tzr = videocodec_to_zoran((struct videocodec *)codec);\n\n\tzrdev_dbg(zr,\n\t\t  \"videocodec: register '%s', type: %x, flags %lx, magic %lx\\n\",\n\t\t  codec->name, codec->type, codec->flags, codec->magic);\n\n\tptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tptr->codec = codec;\n\n\tif (!h) {\n\t\tcodeclist_top = ptr;\n\t\tzrdev_dbg(zr, \"videocodec: hooked in as first element\\n\");\n\t} else {\n\t\twhile (h->next)\n\t\t\th = h->next;\t \n\t\th->next = ptr;\n\t\tzrdev_dbg(zr, \"videocodec: hooked in after '%s'\\n\",\n\t\t\t  h->codec->name);\n\t}\n\n\treturn 0;\n}\n\nint videocodec_unregister(const struct videocodec *codec)\n{\n\tstruct codec_list *prev = NULL, *h = codeclist_top;\n\tstruct zoran *zr;\n\n\tif (!codec) {\n\t\tpr_err(\"%s: no data!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tzr = videocodec_to_zoran((struct videocodec *)codec);\n\n\tzrdev_dbg(zr,\n\t\t  \"videocodec: unregister '%s', type: %x, flags %lx, magic %lx\\n\",\n\t\t  codec->name, codec->type, codec->flags, codec->magic);\n\n\tif (!h) {\n\t\tzrdev_err(zr, \"%s: no device left...\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\twhile (h) {\n\t\tif (codec == h->codec) {\n\t\t\tif (h->attached) {\n\t\t\t\tzrdev_err(zr, \"videocodec: '%s' is used\\n\",\n\t\t\t\t\t  h->codec->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tzrdev_dbg(zr, \"videocodec: unregister '%s' is ok.\\n\",\n\t\t\t\t  h->codec->name);\n\t\t\tif (!prev) {\n\t\t\t\tcodeclist_top = h->next;\n\t\t\t\tzrdev_dbg(zr,\n\t\t\t\t\t  \"videocodec: delete first element\\n\");\n\t\t\t} else {\n\t\t\t\tprev->next = h->next;\n\t\t\t\tzrdev_dbg(zr,\n\t\t\t\t\t  \"videocodec: delete middle element\\n\");\n\t\t\t}\n\t\t\tkfree(h);\n\t\t\treturn 0;\n\t\t}\n\t\tprev = h;\n\t\th = h->next;\n\t}\n\n\tzrdev_err(zr, \"%s: given codec not found!\\n\", __func__);\n\treturn -EINVAL;\n}\n\nint videocodec_debugfs_show(struct seq_file *m)\n{\n\tstruct codec_list *h = codeclist_top;\n\tstruct attached_list *a;\n\n\tseq_puts(m, \"<S>lave or attached <M>aster name  type flags    magic    \");\n\tseq_puts(m, \"(connected as)\\n\");\n\n\twhile (h) {\n\t\tseq_printf(m, \"S %32s %04x %08lx %08lx (TEMPLATE)\\n\",\n\t\t\t   h->codec->name, h->codec->type,\n\t\t\t      h->codec->flags, h->codec->magic);\n\t\ta = h->list;\n\t\twhile (a) {\n\t\t\tseq_printf(m, \"M %32s %04x %08lx %08lx (%s)\\n\",\n\t\t\t\t   a->codec->master_data->name,\n\t\t\t\t      a->codec->master_data->type,\n\t\t\t\t      a->codec->master_data->flags,\n\t\t\t\t      a->codec->master_data->magic,\n\t\t\t\t      a->codec->name);\n\t\t\ta = a->next;\n\t\t}\n\t\th = h->next;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}