{
  "module_name": "tw686x-video.c",
  "hash_id": "61a2bd33fe7c3cb454b62f2720a11f6f5589f3b998e7aa7e05703ce5248e2552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw686x/tw686x-video.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-dma-sg.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"tw686x.h\"\n#include \"tw686x-regs.h\"\n\n#define TW686X_INPUTS_PER_CH\t\t4\n#define TW686X_VIDEO_WIDTH\t\t720\n#define TW686X_VIDEO_HEIGHT(id)\t\t((id & V4L2_STD_525_60) ? 480 : 576)\n#define TW686X_MAX_FPS(id)\t\t((id & V4L2_STD_525_60) ? 30 : 25)\n\n#define TW686X_MAX_SG_ENTRY_SIZE\t4096\n#define TW686X_MAX_SG_DESC_COUNT\t256  \n#define TW686X_SG_TABLE_SIZE\t\t(TW686X_MAX_SG_DESC_COUNT * sizeof(struct tw686x_sg_desc))\n\nstatic const struct tw686x_format formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.mode = 0,\n\t\t.depth = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mode = 5,\n\t\t.depth = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mode = 6,\n\t\t.depth = 16,\n\t}\n};\n\nstatic void tw686x_buf_done(struct tw686x_video_channel *vc,\n\t\t\t    unsigned int pb)\n{\n\tstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct vb2_v4l2_buffer *vb;\n\tstruct vb2_buffer *vb2_buf;\n\n\tif (vc->curr_bufs[pb]) {\n\t\tvb = &vc->curr_bufs[pb]->vb;\n\n\t\tvb->field = dev->dma_ops->field;\n\t\tvb->sequence = vc->sequence++;\n\t\tvb2_buf = &vb->vb2_buf;\n\n\t\tif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY)\n\t\t\tmemcpy(vb2_plane_vaddr(vb2_buf, 0), desc->virt,\n\t\t\t       desc->size);\n\t\tvb2_buf->timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tvc->pb = !pb;\n}\n\n \nstatic void tw686x_memcpy_dma_free(struct tw686x_video_channel *vc,\n\t\t\t\t   unsigned int pb)\n{\n\tstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tpci_dev = dev->pci_dev;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (!pci_dev) {\n\t\tWARN(1, \"trying to deallocate on missing device\\n\");\n\t\treturn;\n\t}\n\n\tif (desc->virt) {\n\t\tdma_free_coherent(&dev->pci_dev->dev, desc->size, desc->virt,\n\t\t\t\t  desc->phys);\n\t\tdesc->virt = NULL;\n\t}\n}\n\nstatic int tw686x_memcpy_dma_alloc(struct tw686x_video_channel *vc,\n\t\t\t\t   unsigned int pb)\n{\n\tstruct tw686x_dev *dev = vc->dev;\n\tu32 reg = pb ? VDMA_B_ADDR[vc->ch] : VDMA_P_ADDR[vc->ch];\n\tunsigned int len;\n\tvoid *virt;\n\n\tWARN(vc->dma_descs[pb].virt,\n\t     \"Allocating buffer but previous still here\\n\");\n\n\tlen = (vc->width * vc->height * vc->format->depth) >> 3;\n\tvirt = dma_alloc_coherent(&dev->pci_dev->dev, len,\n\t\t\t\t  &vc->dma_descs[pb].phys, GFP_KERNEL);\n\tif (!virt) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"dma%d: unable to allocate %s-buffer\\n\",\n\t\t\t vc->ch, pb ? \"B\" : \"P\");\n\t\treturn -ENOMEM;\n\t}\n\tvc->dma_descs[pb].size = len;\n\tvc->dma_descs[pb].virt = virt;\n\treg_write(dev, reg, vc->dma_descs[pb].phys);\n\n\treturn 0;\n}\n\nstatic void tw686x_memcpy_buf_refill(struct tw686x_video_channel *vc,\n\t\t\t\t     unsigned int pb)\n{\n\tstruct tw686x_v4l2_buf *buf;\n\n\twhile (!list_empty(&vc->vidq_queued)) {\n\n\t\tbuf = list_first_entry(&vc->vidq_queued,\n\t\t\tstruct tw686x_v4l2_buf, list);\n\t\tlist_del(&buf->list);\n\n\t\tvc->curr_bufs[pb] = buf;\n\t\treturn;\n\t}\n\tvc->curr_bufs[pb] = NULL;\n}\n\nstatic const struct tw686x_dma_ops memcpy_dma_ops = {\n\t.alloc\t\t= tw686x_memcpy_dma_alloc,\n\t.free\t\t= tw686x_memcpy_dma_free,\n\t.buf_refill\t= tw686x_memcpy_buf_refill,\n\t.mem_ops\t= &vb2_vmalloc_memops,\n\t.hw_dma_mode\t= TW686X_FRAME_MODE,\n\t.field\t\t= V4L2_FIELD_INTERLACED,\n};\n\nstatic void tw686x_contig_buf_refill(struct tw686x_video_channel *vc,\n\t\t\t\t     unsigned int pb)\n{\n\tstruct tw686x_v4l2_buf *buf;\n\n\twhile (!list_empty(&vc->vidq_queued)) {\n\t\tu32 reg = pb ? VDMA_B_ADDR[vc->ch] : VDMA_P_ADDR[vc->ch];\n\t\tdma_addr_t phys;\n\n\t\tbuf = list_first_entry(&vc->vidq_queued,\n\t\t\tstruct tw686x_v4l2_buf, list);\n\t\tlist_del(&buf->list);\n\n\t\tphys = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\n\t\treg_write(vc->dev, reg, phys);\n\n\t\tbuf->vb.vb2_buf.state = VB2_BUF_STATE_ACTIVE;\n\t\tvc->curr_bufs[pb] = buf;\n\t\treturn;\n\t}\n\tvc->curr_bufs[pb] = NULL;\n}\n\nstatic const struct tw686x_dma_ops contig_dma_ops = {\n\t.buf_refill\t= tw686x_contig_buf_refill,\n\t.mem_ops\t= &vb2_dma_contig_memops,\n\t.hw_dma_mode\t= TW686X_FRAME_MODE,\n\t.field\t\t= V4L2_FIELD_INTERLACED,\n};\n\nstatic int tw686x_sg_desc_fill(struct tw686x_sg_desc *descs,\n\t\t\t       struct tw686x_v4l2_buf *buf,\n\t\t\t       unsigned int buf_len)\n{\n\tstruct sg_table *vbuf = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\n\tunsigned int len, entry_len;\n\tstruct scatterlist *sg;\n\tint i, count;\n\n\t \n\tmemset(descs, 0, TW686X_SG_TABLE_SIZE);\n\n\tcount = 0;\n\tfor_each_sg(vbuf->sgl, sg, vbuf->nents, i) {\n\t\tdma_addr_t phys = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\n\t\twhile (len && buf_len) {\n\n\t\t\tif (count == TW686X_MAX_SG_DESC_COUNT)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tentry_len = min_t(unsigned int, len,\n\t\t\t\t\t  TW686X_MAX_SG_ENTRY_SIZE);\n\t\t\tentry_len = min_t(unsigned int, entry_len, buf_len);\n\t\t\tdescs[count].phys = cpu_to_le32(phys);\n\t\t\tdescs[count++].flags_length =\n\t\t\t\t\tcpu_to_le32(BIT(30) | entry_len);\n\t\t\tphys += entry_len;\n\t\t\tlen -= entry_len;\n\t\t\tbuf_len -= entry_len;\n\t\t}\n\n\t\tif (!buf_len)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic void tw686x_sg_buf_refill(struct tw686x_video_channel *vc,\n\t\t\t\t unsigned int pb)\n{\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct tw686x_v4l2_buf *buf;\n\n\twhile (!list_empty(&vc->vidq_queued)) {\n\t\tunsigned int buf_len;\n\n\t\tbuf = list_first_entry(&vc->vidq_queued,\n\t\t\tstruct tw686x_v4l2_buf, list);\n\t\tlist_del(&buf->list);\n\n\t\tbuf_len = (vc->width * vc->height * vc->format->depth) >> 3;\n\t\tif (tw686x_sg_desc_fill(vc->sg_descs[pb], buf, buf_len)) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"dma%d: unable to fill %s-buffer\\n\",\n\t\t\t\t vc->ch, pb ? \"B\" : \"P\");\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf->vb.vb2_buf.state = VB2_BUF_STATE_ACTIVE;\n\t\tvc->curr_bufs[pb] = buf;\n\t\treturn;\n\t}\n\n\tvc->curr_bufs[pb] = NULL;\n}\n\nstatic void tw686x_sg_dma_free(struct tw686x_video_channel *vc,\n\t\t\t       unsigned int pb)\n{\n\tstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\n\tstruct tw686x_dev *dev = vc->dev;\n\n\tif (desc->size) {\n\t\tdma_free_coherent(&dev->pci_dev->dev, desc->size, desc->virt,\n\t\t\t\t  desc->phys);\n\t\tdesc->virt = NULL;\n\t}\n\n\tvc->sg_descs[pb] = NULL;\n}\n\nstatic int tw686x_sg_dma_alloc(struct tw686x_video_channel *vc,\n\t\t\t       unsigned int pb)\n{\n\tstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\n\tstruct tw686x_dev *dev = vc->dev;\n\tu32 reg = pb ? DMA_PAGE_TABLE1_ADDR[vc->ch] :\n\t\t       DMA_PAGE_TABLE0_ADDR[vc->ch];\n\tvoid *virt;\n\n\tif (desc->size) {\n\t\tvirt = dma_alloc_coherent(&dev->pci_dev->dev, desc->size,\n\t\t\t\t\t  &desc->phys, GFP_KERNEL);\n\t\tif (!virt) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"dma%d: unable to allocate %s-buffer\\n\",\n\t\t\t\t vc->ch, pb ? \"B\" : \"P\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdesc->virt = virt;\n\t\treg_write(dev, reg, desc->phys);\n\t} else {\n\t\tvirt = dev->video_channels[0].dma_descs[pb].virt +\n\t\t       vc->ch * TW686X_SG_TABLE_SIZE;\n\t}\n\n\tvc->sg_descs[pb] = virt;\n\treturn 0;\n}\n\nstatic int tw686x_sg_setup(struct tw686x_dev *dev)\n{\n\tunsigned int sg_table_size, pb, ch, channels;\n\n\tif (is_second_gen(dev)) {\n\t\t \n\t\tchannels = max_channels(dev);\n\t\tsg_table_size = TW686X_SG_TABLE_SIZE;\n\t} else {\n\t\t \n\t\tchannels = 1;\n\t\tsg_table_size = max_channels(dev) * TW686X_SG_TABLE_SIZE;\n\t}\n\n\tfor (ch = 0; ch < channels; ch++) {\n\t\tstruct tw686x_video_channel *vc = &dev->video_channels[ch];\n\n\t\tfor (pb = 0; pb < 2; pb++)\n\t\t\tvc->dma_descs[pb].size = sg_table_size;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tw686x_dma_ops sg_dma_ops = {\n\t.setup\t\t= tw686x_sg_setup,\n\t.alloc\t\t= tw686x_sg_dma_alloc,\n\t.free\t\t= tw686x_sg_dma_free,\n\t.buf_refill\t= tw686x_sg_buf_refill,\n\t.mem_ops\t= &vb2_dma_sg_memops,\n\t.hw_dma_mode\t= TW686X_SG_MODE,\n\t.field\t\t= V4L2_FIELD_SEQ_TB,\n};\n\nstatic const unsigned int fps_map[15] = {\n\t \n\t0x00000000,  \n\t0x80000006,  \n\t0x80018006,  \n\t0x80618006,  \n\t0x81818186,  \n\t0x86186186,  \n\t0x86619866,  \n\t0x86666666,  \n\t0x9999999e,  \n\t0x99e6799e,  \n\t0x9e79e79e,  \n\t0x9e7e7e7e,  \n\t0x9fe7f9fe,  \n\t0x9ffe7ffe,  \n\t0x9ffffffe,  \n};\n\nstatic unsigned int tw686x_real_fps(unsigned int index, unsigned int max_fps)\n{\n\tunsigned long mask;\n\n\tif (!index || index >= ARRAY_SIZE(fps_map))\n\t\treturn max_fps;\n\n\tmask = GENMASK(max_fps - 1, 0);\n\treturn hweight_long(fps_map[index] & mask);\n}\n\nstatic unsigned int tw686x_fps_idx(unsigned int fps, unsigned int max_fps)\n{\n\tunsigned int idx, real_fps;\n\tint delta;\n\n\t \n\tidx = (12 + 15 * fps) / max_fps;\n\n\t \n\tif (!idx)\n\t\treturn 1;\n\n\t \n\treal_fps = tw686x_real_fps(idx, max_fps);\n\tdelta = real_fps - fps;\n\tif (delta < -1)\n\t\tidx++;\n\telse if (delta > 1)\n\t\tidx--;\n\n\t \n\tif (idx >= 15)\n\t\treturn 0;\n\n\treturn idx;\n}\n\nstatic void tw686x_set_framerate(struct tw686x_video_channel *vc,\n\t\t\t\t unsigned int fps)\n{\n\tunsigned int i;\n\n\ti = tw686x_fps_idx(fps, TW686X_MAX_FPS(vc->video_standard));\n\treg_write(vc->dev, VIDEO_FIELD_CTRL[vc->ch], fps_map[i]);\n\tvc->fps = tw686x_real_fps(i, TW686X_MAX_FPS(vc->video_standard));\n}\n\nstatic const struct tw686x_format *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int cnt;\n\n\tfor (cnt = 0; cnt < ARRAY_SIZE(formats); cnt++)\n\t\tif (formats[cnt].fourcc == fourcc)\n\t\t\treturn &formats[cnt];\n\treturn NULL;\n}\n\nstatic int tw686x_queue_setup(struct vb2_queue *vq,\n\t\t\t      unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t      unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\n\tunsigned int szimage =\n\t\t(vc->width * vc->height * vc->format->depth) >> 3;\n\n\t \n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != 1 || sizes[0] < szimage)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tsizes[0] = szimage;\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic void tw686x_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct tw686x_video_channel *vc = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long flags;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct tw686x_v4l2_buf *buf =\n\t\tcontainer_of(vbuf, struct tw686x_v4l2_buf, vb);\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tpci_dev = dev->pci_dev;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (!pci_dev) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&vc->qlock, flags);\n\tlist_add_tail(&buf->list, &vc->vidq_queued);\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n}\n\nstatic void tw686x_clear_queue(struct tw686x_video_channel *vc,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tunsigned int pb;\n\n\twhile (!list_empty(&vc->vidq_queued)) {\n\t\tstruct tw686x_v4l2_buf *buf;\n\n\t\tbuf = list_first_entry(&vc->vidq_queued,\n\t\t\tstruct tw686x_v4l2_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\n\tfor (pb = 0; pb < 2; pb++) {\n\t\tif (vc->curr_bufs[pb])\n\t\t\tvb2_buffer_done(&vc->curr_bufs[pb]->vb.vb2_buf, state);\n\t\tvc->curr_bufs[pb] = NULL;\n\t}\n}\n\nstatic int tw686x_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long flags;\n\tint pb, err;\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tpci_dev = dev->pci_dev;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (!pci_dev) {\n\t\terr = -ENODEV;\n\t\tgoto err_clear_queue;\n\t}\n\n\tspin_lock_irqsave(&vc->qlock, flags);\n\n\t \n\tif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY &&\n\t    (!vc->dma_descs[0].virt || !vc->dma_descs[1].virt)) {\n\t\tspin_unlock_irqrestore(&vc->qlock, flags);\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"video%d: refusing to start without DMA buffers\\n\",\n\t\t\t vc->num);\n\t\terr = -ENOMEM;\n\t\tgoto err_clear_queue;\n\t}\n\n\tfor (pb = 0; pb < 2; pb++)\n\t\tdev->dma_ops->buf_refill(vc, pb);\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n\n\tvc->sequence = 0;\n\tvc->pb = 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttw686x_enable_channel(dev, vc->ch);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tmod_timer(&dev->dma_delay_timer, jiffies + msecs_to_jiffies(100));\n\n\treturn 0;\n\nerr_clear_queue:\n\tspin_lock_irqsave(&vc->qlock, flags);\n\ttw686x_clear_queue(vc, VB2_BUF_STATE_QUEUED);\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n\treturn err;\n}\n\nstatic void tw686x_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\n\tstruct tw686x_dev *dev = vc->dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tpci_dev = dev->pci_dev;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (pci_dev)\n\t\ttw686x_disable_channel(dev, vc->ch);\n\n\tspin_lock_irqsave(&vc->qlock, flags);\n\ttw686x_clear_queue(vc, VB2_BUF_STATE_ERROR);\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n}\n\nstatic int tw686x_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct tw686x_video_channel *vc = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int size =\n\t\t(vc->width * vc->height * vc->format->depth) >> 3;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\nstatic const struct vb2_ops tw686x_video_qops = {\n\t.queue_setup\t\t= tw686x_queue_setup,\n\t.buf_queue\t\t= tw686x_buf_queue,\n\t.buf_prepare\t\t= tw686x_buf_prepare,\n\t.start_streaming\t= tw686x_start_streaming,\n\t.stop_streaming\t\t= tw686x_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int tw686x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct tw686x_video_channel *vc;\n\tstruct tw686x_dev *dev;\n\tunsigned int ch;\n\n\tvc = container_of(ctrl->handler, struct tw686x_video_channel,\n\t\t\t  ctrl_handler);\n\tdev = vc->dev;\n\tch = vc->ch;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\treg_write(dev, BRIGHT[ch], ctrl->val & 0xff);\n\t\treturn 0;\n\n\tcase V4L2_CID_CONTRAST:\n\t\treg_write(dev, CONTRAST[ch], ctrl->val);\n\t\treturn 0;\n\n\tcase V4L2_CID_SATURATION:\n\t\treg_write(dev, SAT_U[ch], ctrl->val);\n\t\treg_write(dev, SAT_V[ch], ctrl->val);\n\t\treturn 0;\n\n\tcase V4L2_CID_HUE:\n\t\treg_write(dev, HUE[ch], ctrl->val & 0xff);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = tw686x_s_ctrl,\n};\n\nstatic int tw686x_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct tw686x_dev *dev = vc->dev;\n\n\tf->fmt.pix.width = vc->width;\n\tf->fmt.pix.height = vc->height;\n\tf->fmt.pix.field = dev->dma_ops->field;\n\tf->fmt.pix.pixelformat = vc->format->fourcc;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * vc->format->depth) / 8;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\treturn 0;\n}\n\nstatic int tw686x_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct tw686x_dev *dev = vc->dev;\n\tunsigned int video_height = TW686X_VIDEO_HEIGHT(vc->video_standard);\n\tconst struct tw686x_format *format;\n\n\tformat = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (!format) {\n\t\tformat = &formats[0];\n\t\tf->fmt.pix.pixelformat = format->fourcc;\n\t}\n\n\tif (f->fmt.pix.width <= TW686X_VIDEO_WIDTH / 2)\n\t\tf->fmt.pix.width = TW686X_VIDEO_WIDTH / 2;\n\telse\n\t\tf->fmt.pix.width = TW686X_VIDEO_WIDTH;\n\n\tif (f->fmt.pix.height <= video_height / 2)\n\t\tf->fmt.pix.height = video_height / 2;\n\telse\n\t\tf->fmt.pix.height = video_height;\n\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * format->depth) / 8;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.field = dev->dma_ops->field;\n\n\treturn 0;\n}\n\nstatic int tw686x_set_format(struct tw686x_video_channel *vc,\n\t\t\t     unsigned int pixelformat, unsigned int width,\n\t\t\t     unsigned int height, bool realloc)\n{\n\tstruct tw686x_dev *dev = vc->dev;\n\tu32 val, dma_width, dma_height, dma_line_width;\n\tint err, pb;\n\n\tvc->format = format_by_fourcc(pixelformat);\n\tvc->width = width;\n\tvc->height = height;\n\n\t \n\tif (dev->dma_ops->alloc && realloc) {\n\t\tfor (pb = 0; pb < 2; pb++)\n\t\t\tdev->dma_ops->free(vc, pb);\n\n\t\tfor (pb = 0; pb < 2; pb++) {\n\t\t\terr = dev->dma_ops->alloc(vc, pb);\n\t\t\tif (err) {\n\t\t\t\tif (pb > 0)\n\t\t\t\t\tdev->dma_ops->free(vc, 0);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tval = reg_read(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch]);\n\n\tif (vc->width <= TW686X_VIDEO_WIDTH / 2)\n\t\tval |= BIT(23);\n\telse\n\t\tval &= ~BIT(23);\n\n\tif (vc->height <= TW686X_VIDEO_HEIGHT(vc->video_standard) / 2)\n\t\tval |= BIT(24);\n\telse\n\t\tval &= ~BIT(24);\n\n\tval &= ~0x7ffff;\n\n\t \n\tif (dev->dma_mode == TW686X_DMA_MODE_SG) {\n\t\tu32 start_idx, end_idx;\n\n\t\tstart_idx = is_second_gen(dev) ?\n\t\t\t\t0 : vc->ch * TW686X_MAX_SG_DESC_COUNT;\n\t\tend_idx = start_idx + TW686X_MAX_SG_DESC_COUNT - 1;\n\n\t\tval |= (end_idx << 10) | start_idx;\n\t}\n\n\tval &= ~(0x7 << 20);\n\tval |= vc->format->mode << 20;\n\treg_write(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch], val);\n\n\t \n\tdma_width = (vc->width * 2) & 0x7ff;\n\tdma_height = vc->height / 2;\n\tdma_line_width = (vc->width * 2) & 0x7ff;\n\tval = (dma_height << 22) | (dma_line_width << 11)  | dma_width;\n\treg_write(vc->dev, VDMA_WHP[vc->ch], val);\n\treturn 0;\n}\n\nstatic int tw686x_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tunsigned long area;\n\tbool realloc;\n\tint err;\n\n\tif (vb2_is_busy(&vc->vidq))\n\t\treturn -EBUSY;\n\n\tarea = vc->width * vc->height;\n\terr = tw686x_try_fmt_vid_cap(file, priv, f);\n\tif (err)\n\t\treturn err;\n\n\trealloc = area != (f->fmt.pix.width * f->fmt.pix.height);\n\treturn tw686x_set_format(vc, f->fmt.pix.pixelformat,\n\t\t\t\t f->fmt.pix.width, f->fmt.pix.height,\n\t\t\t\t realloc);\n}\n\nstatic int tw686x_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct tw686x_dev *dev = vc->dev;\n\n\tstrscpy(cap->driver, \"tw686x\", sizeof(cap->driver));\n\tstrscpy(cap->card, dev->name, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int tw686x_set_standard(struct tw686x_video_channel *vc, v4l2_std_id id)\n{\n\tu32 val;\n\n\tif (id & V4L2_STD_NTSC)\n\t\tval = 0;\n\telse if (id & V4L2_STD_PAL)\n\t\tval = 1;\n\telse if (id & V4L2_STD_SECAM)\n\t\tval = 2;\n\telse if (id & V4L2_STD_NTSC_443)\n\t\tval = 3;\n\telse if (id & V4L2_STD_PAL_M)\n\t\tval = 4;\n\telse if (id & V4L2_STD_PAL_Nc)\n\t\tval = 5;\n\telse if (id & V4L2_STD_PAL_60)\n\t\tval = 6;\n\telse\n\t\treturn -EINVAL;\n\n\tvc->video_standard = id;\n\treg_write(vc->dev, SDT[vc->ch], val);\n\n\tval = reg_read(vc->dev, VIDEO_CONTROL1);\n\tif (id & V4L2_STD_525_60)\n\t\tval &= ~(1 << (SYS_MODE_DMA_SHIFT + vc->ch));\n\telse\n\t\tval |= (1 << (SYS_MODE_DMA_SHIFT + vc->ch));\n\treg_write(vc->dev, VIDEO_CONTROL1, val);\n\n\treturn 0;\n}\n\nstatic int tw686x_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct v4l2_format f;\n\tint ret;\n\n\tif (vc->video_standard == id)\n\t\treturn 0;\n\n\tif (vb2_is_busy(&vc->vidq))\n\t\treturn -EBUSY;\n\n\tret = tw686x_set_standard(vc, id);\n\tif (ret)\n\t\treturn ret;\n\t \n\ttw686x_g_fmt_vid_cap(file, priv, &f);\n\ttw686x_s_fmt_vid_cap(file, priv, &f);\n\n\t \n\ttw686x_set_framerate(vc, vc->fps);\n\treturn 0;\n}\n\nstatic int tw686x_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct tw686x_dev *dev = vc->dev;\n\tunsigned int old_std, detected_std = 0;\n\tunsigned long end;\n\n\tif (vb2_is_streaming(&vc->vidq))\n\t\treturn -EBUSY;\n\n\t \n\told_std = reg_read(dev, SDT[vc->ch]);\n\treg_write(dev, SDT[vc->ch], 0x7);\n\treg_write(dev, SDT_EN[vc->ch], 0xff);\n\n\tend = jiffies + msecs_to_jiffies(500);\n\twhile (time_is_after_jiffies(end)) {\n\n\t\tdetected_std = reg_read(dev, SDT[vc->ch]);\n\t\tif (!(detected_std & BIT(7)))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\treg_write(dev, SDT[vc->ch], old_std);\n\n\t \n\tif (detected_std & BIT(7))\n\t\treturn 0;\n\n\tdetected_std = (detected_std >> 4) & 0x7;\n\tswitch (detected_std) {\n\tcase TW686X_STD_NTSC_M:\n\t\t*std &= V4L2_STD_NTSC;\n\t\tbreak;\n\tcase TW686X_STD_NTSC_443:\n\t\t*std &= V4L2_STD_NTSC_443;\n\t\tbreak;\n\tcase TW686X_STD_PAL_M:\n\t\t*std &= V4L2_STD_PAL_M;\n\t\tbreak;\n\tcase TW686X_STD_PAL_60:\n\t\t*std &= V4L2_STD_PAL_60;\n\t\tbreak;\n\tcase TW686X_STD_PAL:\n\t\t*std &= V4L2_STD_PAL;\n\t\tbreak;\n\tcase TW686X_STD_PAL_CN:\n\t\t*std &= V4L2_STD_PAL_Nc;\n\t\tbreak;\n\tcase TW686X_STD_SECAM:\n\t\t*std &= V4L2_STD_SECAM;\n\t\tbreak;\n\tdefault:\n\t\t*std = 0;\n\t}\n\treturn 0;\n}\n\nstatic int tw686x_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\n\t*id = vc->video_standard;\n\treturn 0;\n}\n\nstatic int tw686x_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.max_width = TW686X_VIDEO_WIDTH;\n\tfsize->stepwise.min_width = fsize->stepwise.max_width / 2;\n\tfsize->stepwise.step_width = fsize->stepwise.min_width;\n\tfsize->stepwise.max_height = TW686X_VIDEO_HEIGHT(vc->video_standard);\n\tfsize->stepwise.min_height = fsize->stepwise.max_height / 2;\n\tfsize->stepwise.step_height = fsize->stepwise.min_height;\n\treturn 0;\n}\n\nstatic int tw686x_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *ival)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tint max_fps = TW686X_MAX_FPS(vc->video_standard);\n\tint max_rates = DIV_ROUND_UP(max_fps, 2);\n\n\tif (ival->index >= max_rates)\n\t\treturn -EINVAL;\n\n\tival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tival->discrete.numerator = 1;\n\tif (ival->index < (max_rates - 1))\n\t\tival->discrete.denominator = (ival->index + 1) * 2;\n\telse\n\t\tival->discrete.denominator = max_fps;\n\treturn 0;\n}\n\nstatic int tw686x_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct v4l2_captureparm *cp = &sp->parm.capture;\n\n\tif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tsp->parm.capture.readbuffers = 3;\n\n\tcp->capability = V4L2_CAP_TIMEPERFRAME;\n\tcp->timeperframe.numerator = 1;\n\tcp->timeperframe.denominator = vc->fps;\n\treturn 0;\n}\n\nstatic int tw686x_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tstruct v4l2_captureparm *cp = &sp->parm.capture;\n\tunsigned int denominator = cp->timeperframe.denominator;\n\tunsigned int numerator = cp->timeperframe.numerator;\n\tunsigned int fps;\n\n\tif (vb2_is_busy(&vc->vidq))\n\t\treturn -EBUSY;\n\n\tfps = (!numerator || !denominator) ? 0 : denominator / numerator;\n\tif (vc->fps != fps)\n\t\ttw686x_set_framerate(vc, fps);\n\treturn tw686x_g_parm(file, priv, sp);\n}\n\nstatic int tw686x_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[f->index].fourcc;\n\treturn 0;\n}\n\nstatic void tw686x_set_input(struct tw686x_video_channel *vc, unsigned int i)\n{\n\tu32 val;\n\n\tvc->input = i;\n\n\tval = reg_read(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch]);\n\tval &= ~(0x3 << 30);\n\tval |= i << 30;\n\treg_write(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch], val);\n}\n\nstatic int tw686x_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\n\tif (i >= TW686X_INPUTS_PER_CH)\n\t\treturn -EINVAL;\n\tif (i == vc->input)\n\t\treturn 0;\n\t \n\tif (vb2_is_busy(&vc->vidq))\n\t\treturn -EBUSY;\n\n\ttw686x_set_input(vc, i);\n\treturn 0;\n}\n\nstatic int tw686x_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\n\t*i = vc->input;\n\treturn 0;\n}\n\nstatic int tw686x_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct tw686x_video_channel *vc = video_drvdata(file);\n\tunsigned int vidstat;\n\n\tif (i->index >= TW686X_INPUTS_PER_CH)\n\t\treturn -EINVAL;\n\n\tsnprintf(i->name, sizeof(i->name), \"Composite%d\", i->index);\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\ti->std = vc->device->tvnorms;\n\ti->capabilities = V4L2_IN_CAP_STD;\n\n\tvidstat = reg_read(vc->dev, VIDSTAT[vc->ch]);\n\ti->status = 0;\n\tif (vidstat & TW686X_VIDSTAT_VDLOSS)\n\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\tif (!(vidstat & TW686X_VIDSTAT_HLOCK))\n\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations tw686x_video_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.release\t= vb2_fop_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.read\t\t= vb2_fop_read,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops tw686x_video_ioctl_ops = {\n\t.vidioc_querycap\t\t= tw686x_querycap,\n\t.vidioc_g_fmt_vid_cap\t\t= tw686x_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= tw686x_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= tw686x_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= tw686x_try_fmt_vid_cap,\n\n\t.vidioc_querystd\t\t= tw686x_querystd,\n\t.vidioc_g_std\t\t\t= tw686x_g_std,\n\t.vidioc_s_std\t\t\t= tw686x_s_std,\n\n\t.vidioc_g_parm\t\t\t= tw686x_g_parm,\n\t.vidioc_s_parm\t\t\t= tw686x_s_parm,\n\t.vidioc_enum_framesizes\t\t= tw686x_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= tw686x_enum_frameintervals,\n\n\t.vidioc_enum_input\t\t= tw686x_enum_input,\n\t.vidioc_g_input\t\t\t= tw686x_g_input,\n\t.vidioc_s_input\t\t\t= tw686x_s_input,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nvoid tw686x_video_irq(struct tw686x_dev *dev, unsigned long requests,\n\t\t      unsigned int pb_status, unsigned int fifo_status,\n\t\t      unsigned int *reset_ch)\n{\n\tstruct tw686x_video_channel *vc;\n\tunsigned long flags;\n\tunsigned int ch, pb;\n\n\tfor_each_set_bit(ch, &requests, max_channels(dev)) {\n\t\tvc = &dev->video_channels[ch];\n\n\t\t \n\t\tif (vc->no_signal && !(fifo_status & BIT(ch))) {\n\t\t\tv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\n\t\t\t\t    \"video%d: signal recovered\\n\", vc->num);\n\t\t\tvc->no_signal = false;\n\t\t\t*reset_ch |= BIT(ch);\n\t\t\tvc->pb = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tvc->no_signal = !!(fifo_status & BIT(ch));\n\n\t\t \n\t\tif (!vc->no_signal) {\n\t\t\tu32 fifo_ov, fifo_bad;\n\n\t\t\tfifo_ov = (fifo_status >> 24) & BIT(ch);\n\t\t\tfifo_bad = (fifo_status >> 16) & BIT(ch);\n\t\t\tif (fifo_ov || fifo_bad) {\n\t\t\t\t \n\t\t\t\tv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\n\t\t\t\t\t    \"video%d: FIFO error\\n\", vc->num);\n\t\t\t\t*reset_ch |= BIT(ch);\n\t\t\t\tvc->pb = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpb = !!(pb_status & BIT(ch));\n\t\tif (vc->pb != pb) {\n\t\t\t \n\t\t\tv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\n\t\t\t\t    \"video%d: unexpected p-b buffer!\\n\",\n\t\t\t\t    vc->num);\n\t\t\t*reset_ch |= BIT(ch);\n\t\t\tvc->pb = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_irqsave(&vc->qlock, flags);\n\t\ttw686x_buf_done(vc, pb);\n\t\tdev->dma_ops->buf_refill(vc, pb);\n\t\tspin_unlock_irqrestore(&vc->qlock, flags);\n\t}\n}\n\nvoid tw686x_video_free(struct tw686x_dev *dev)\n{\n\tunsigned int ch, pb;\n\n\tfor (ch = 0; ch < max_channels(dev); ch++) {\n\t\tstruct tw686x_video_channel *vc = &dev->video_channels[ch];\n\n\t\tvideo_unregister_device(vc->device);\n\n\t\tif (dev->dma_ops->free)\n\t\t\tfor (pb = 0; pb < 2; pb++)\n\t\t\t\tdev->dma_ops->free(vc, pb);\n\t}\n}\n\nint tw686x_video_init(struct tw686x_dev *dev)\n{\n\tunsigned int ch, val;\n\tint err;\n\n\tif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY)\n\t\tdev->dma_ops = &memcpy_dma_ops;\n\telse if (dev->dma_mode == TW686X_DMA_MODE_CONTIG)\n\t\tdev->dma_ops = &contig_dma_ops;\n\telse if (dev->dma_mode == TW686X_DMA_MODE_SG)\n\t\tdev->dma_ops = &sg_dma_ops;\n\telse\n\t\treturn -EINVAL;\n\n\terr = v4l2_device_register(&dev->pci_dev->dev, &dev->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->dma_ops->setup) {\n\t\terr = dev->dma_ops->setup(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (ch = 0; ch < max_channels(dev); ch++) {\n\t\tstruct tw686x_video_channel *vc = &dev->video_channels[ch];\n\n\t\tvc->dev = dev;\n\t\tvc->ch = ch;\n\t}\n\n\tfor (ch = 0; ch < max_channels(dev); ch++) {\n\t\tstruct tw686x_video_channel *vc = &dev->video_channels[ch];\n\t\tstruct video_device *vdev;\n\n\t\tmutex_init(&vc->vb_mutex);\n\t\tspin_lock_init(&vc->qlock);\n\t\tINIT_LIST_HEAD(&vc->vidq_queued);\n\n\t\t \n\t\terr = tw686x_set_standard(vc, V4L2_STD_NTSC);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\terr = tw686x_set_format(vc, formats[0].fourcc,\n\t\t\t\tTW686X_VIDEO_WIDTH,\n\t\t\t\tTW686X_VIDEO_HEIGHT(vc->video_standard),\n\t\t\t\ttrue);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ttw686x_set_input(vc, 0);\n\t\ttw686x_set_framerate(vc, 30);\n\t\treg_write(dev, VDELAY_LO[ch], 0x14);\n\t\treg_write(dev, HACTIVE_LO[ch], 0xd0);\n\t\treg_write(dev, VIDEO_SIZE[ch], 0);\n\n\t\tvc->vidq.io_modes = VB2_READ | VB2_MMAP | VB2_DMABUF;\n\t\tvc->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tvc->vidq.drv_priv = vc;\n\t\tvc->vidq.buf_struct_size = sizeof(struct tw686x_v4l2_buf);\n\t\tvc->vidq.ops = &tw686x_video_qops;\n\t\tvc->vidq.mem_ops = dev->dma_ops->mem_ops;\n\t\tvc->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tvc->vidq.min_buffers_needed = 2;\n\t\tvc->vidq.lock = &vc->vb_mutex;\n\t\tvc->vidq.gfp_flags = dev->dma_mode != TW686X_DMA_MODE_MEMCPY ?\n\t\t\t\t     GFP_DMA32 : 0;\n\t\tvc->vidq.dev = &dev->pci_dev->dev;\n\n\t\terr = vb2_queue_init(&vc->vidq);\n\t\tif (err) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"dma%d: cannot init vb2 queue\\n\", ch);\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = v4l2_ctrl_handler_init(&vc->ctrl_handler, 4);\n\t\tif (err) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"dma%d: cannot init ctrl handler\\n\", ch);\n\t\t\tgoto error;\n\t\t}\n\t\tv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\n\t\t\t\t  V4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\t\tv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\n\t\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 100);\n\t\tv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\n\t\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 128);\n\t\tv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\n\t\t\t\t  V4L2_CID_HUE, -128, 127, 1, 0);\n\t\terr = vc->ctrl_handler.error;\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\terr = v4l2_ctrl_handler_setup(&vc->ctrl_handler);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tvdev = video_device_alloc();\n\t\tif (!vdev) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"dma%d: unable to allocate device\\n\", ch);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tsnprintf(vdev->name, sizeof(vdev->name), \"%s video\", dev->name);\n\t\tvdev->fops = &tw686x_video_fops;\n\t\tvdev->ioctl_ops = &tw686x_video_ioctl_ops;\n\t\tvdev->release = video_device_release;\n\t\tvdev->v4l2_dev = &dev->v4l2_dev;\n\t\tvdev->queue = &vc->vidq;\n\t\tvdev->tvnorms = V4L2_STD_525_60 | V4L2_STD_625_50;\n\t\tvdev->minor = -1;\n\t\tvdev->lock = &vc->vb_mutex;\n\t\tvdev->ctrl_handler = &vc->ctrl_handler;\n\t\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t    V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tvc->device = vdev;\n\t\tvideo_set_drvdata(vdev, vc);\n\n\t\terr = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\t\tif (err < 0) {\n\t\t\tvideo_device_release(vdev);\n\t\t\tgoto error;\n\t\t}\n\t\tvc->num = vdev->num;\n\t}\n\n\tval = TW686X_DEF_PHASE_REF;\n\tfor (ch = 0; ch < max_channels(dev); ch++)\n\t\tval |= dev->dma_ops->hw_dma_mode << (16 + ch * 2);\n\treg_write(dev, PHASE_REF, val);\n\n\treg_write(dev, MISC2[0], 0xe7);\n\treg_write(dev, VCTRL1[0], 0xcc);\n\treg_write(dev, LOOP[0], 0xa5);\n\tif (max_channels(dev) > 4) {\n\t\treg_write(dev, VCTRL1[1], 0xcc);\n\t\treg_write(dev, LOOP[1], 0xa5);\n\t\treg_write(dev, MISC2[1], 0xe7);\n\t}\n\treturn 0;\n\nerror:\n\ttw686x_video_free(dev);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}