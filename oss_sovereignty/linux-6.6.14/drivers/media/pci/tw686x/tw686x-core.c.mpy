{
  "module_name": "tw686x-core.c",
  "hash_id": "92e0c9edbdfab68c88d5d200e573f86c410a2eafd4587482bf752e938ac2a824",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw686x/tw686x-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n#include \"tw686x.h\"\n#include \"tw686x-regs.h\"\n\n \nstatic u32 dma_interval = 0x00098968;\nmodule_param(dma_interval, int, 0444);\nMODULE_PARM_DESC(dma_interval, \"Minimum time span for DMA interrupting host\");\n\nstatic unsigned int dma_mode = TW686X_DMA_MODE_MEMCPY;\nstatic const char *dma_mode_name(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase TW686X_DMA_MODE_MEMCPY:\n\t\treturn \"memcpy\";\n\tcase TW686X_DMA_MODE_CONTIG:\n\t\treturn \"contig\";\n\tcase TW686X_DMA_MODE_SG:\n\t\treturn \"sg\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int tw686x_dma_mode_get(char *buffer, const struct kernel_param *kp)\n{\n\treturn sprintf(buffer, \"%s\", dma_mode_name(dma_mode));\n}\n\nstatic int tw686x_dma_mode_set(const char *val, const struct kernel_param *kp)\n{\n\tif (!strcasecmp(val, dma_mode_name(TW686X_DMA_MODE_MEMCPY)))\n\t\tdma_mode = TW686X_DMA_MODE_MEMCPY;\n\telse if (!strcasecmp(val, dma_mode_name(TW686X_DMA_MODE_CONTIG)))\n\t\tdma_mode = TW686X_DMA_MODE_CONTIG;\n\telse if (!strcasecmp(val, dma_mode_name(TW686X_DMA_MODE_SG)))\n\t\tdma_mode = TW686X_DMA_MODE_SG;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\nmodule_param_call(dma_mode, tw686x_dma_mode_set, tw686x_dma_mode_get,\n\t\t  &dma_mode, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(dma_mode, \"DMA operation mode (memcpy/contig/sg, default=memcpy)\");\n\nvoid tw686x_disable_channel(struct tw686x_dev *dev, unsigned int channel)\n{\n\tu32 dma_en = reg_read(dev, DMA_CHANNEL_ENABLE);\n\tu32 dma_cmd = reg_read(dev, DMA_CMD);\n\n\tdma_en &= ~BIT(channel);\n\tdma_cmd &= ~BIT(channel);\n\n\t \n\tdev->pending_dma_en &= ~BIT(channel);\n\tdev->pending_dma_cmd &= ~BIT(channel);\n\n\t \n\tif (!dma_en)\n\t\tdma_cmd = 0;\n\treg_write(dev, DMA_CHANNEL_ENABLE, dma_en);\n\treg_write(dev, DMA_CMD, dma_cmd);\n}\n\nvoid tw686x_enable_channel(struct tw686x_dev *dev, unsigned int channel)\n{\n\tu32 dma_en = reg_read(dev, DMA_CHANNEL_ENABLE);\n\tu32 dma_cmd = reg_read(dev, DMA_CMD);\n\n\tdev->pending_dma_en |= dma_en | BIT(channel);\n\tdev->pending_dma_cmd |= dma_cmd | DMA_CMD_ENABLE | BIT(channel);\n}\n\n \nstatic void tw686x_dma_delay(struct timer_list *t)\n{\n\tstruct tw686x_dev *dev = from_timer(dev, t, dma_delay_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\treg_write(dev, DMA_CHANNEL_ENABLE, dev->pending_dma_en);\n\treg_write(dev, DMA_CMD, dev->pending_dma_cmd);\n\tdev->pending_dma_en = 0;\n\tdev->pending_dma_cmd = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic void tw686x_reset_channels(struct tw686x_dev *dev, unsigned int ch_mask)\n{\n\tu32 dma_en, dma_cmd;\n\n\tdma_en = reg_read(dev, DMA_CHANNEL_ENABLE);\n\tdma_cmd = reg_read(dev, DMA_CMD);\n\n\t \n\tdev->pending_dma_en |= dma_en;\n\tdev->pending_dma_cmd |= dma_cmd;\n\n\t \n\treg_write(dev, DMA_CHANNEL_ENABLE, dma_en & ~ch_mask);\n\n\tif ((dma_en & ~ch_mask) == 0) {\n\t\tdev_dbg(&dev->pci_dev->dev, \"reset: stopping DMA\\n\");\n\t\tdma_cmd &= ~DMA_CMD_ENABLE;\n\t}\n\treg_write(dev, DMA_CMD, dma_cmd & ~ch_mask);\n}\n\nstatic irqreturn_t tw686x_irq(int irq, void *dev_id)\n{\n\tstruct tw686x_dev *dev = (struct tw686x_dev *)dev_id;\n\tunsigned int video_requests, audio_requests, reset_ch;\n\tu32 fifo_status, fifo_signal, fifo_ov, fifo_bad, fifo_errors;\n\tu32 int_status, dma_en, video_en, pb_status;\n\tunsigned long flags;\n\n\tint_status = reg_read(dev, INT_STATUS);  \n\tfifo_status = reg_read(dev, VIDEO_FIFO_STATUS);\n\n\t \n\tif (!int_status && !TW686X_FIFO_ERROR(fifo_status))\n\t\treturn IRQ_NONE;\n\n\tif (int_status & INT_STATUS_DMA_TOUT) {\n\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\"DMA timeout. Resetting DMA for all channels\\n\");\n\t\treset_ch = ~0;\n\t\tgoto reset_channels;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdma_en = reg_read(dev, DMA_CHANNEL_ENABLE);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tvideo_en = dma_en & 0xff;\n\tfifo_signal = ~(fifo_status & 0xff) & video_en;\n\tfifo_ov = fifo_status >> 24;\n\tfifo_bad = fifo_status >> 16;\n\n\t \n\tfifo_errors = fifo_signal & (fifo_ov | fifo_bad);\n\n\treset_ch = 0;\n\tpb_status = reg_read(dev, PB_STATUS);\n\n\t \n\tvideo_requests = (int_status & video_en) | fifo_errors;\n\taudio_requests = (int_status & dma_en) >> 8;\n\n\tif (video_requests)\n\t\ttw686x_video_irq(dev, video_requests, pb_status,\n\t\t\t\t fifo_status, &reset_ch);\n\tif (audio_requests)\n\t\ttw686x_audio_irq(dev, audio_requests, pb_status);\n\nreset_channels:\n\tif (reset_ch) {\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\ttw686x_reset_channels(dev, reset_ch);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tmod_timer(&dev->dma_delay_timer,\n\t\t\t  jiffies + msecs_to_jiffies(100));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tw686x_dev_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct tw686x_dev *dev = container_of(v4l2_dev, struct tw686x_dev,\n\t\t\t\t\t      v4l2_dev);\n\tunsigned int ch;\n\n\tfor (ch = 0; ch < max_channels(dev); ch++)\n\t\tv4l2_ctrl_handler_free(&dev->video_channels[ch].ctrl_handler);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tkfree(dev->audio_channels);\n\tkfree(dev->video_channels);\n\tkfree(dev);\n}\n\nstatic int tw686x_probe(struct pci_dev *pci_dev,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct tw686x_dev *dev;\n\tint err;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->type = pci_id->driver_data;\n\tdev->dma_mode = dma_mode;\n\tsprintf(dev->name, \"tw%04X\", pci_dev->device);\n\n\tdev->video_channels = kcalloc(max_channels(dev),\n\t\tsizeof(*dev->video_channels), GFP_KERNEL);\n\tif (!dev->video_channels) {\n\t\terr = -ENOMEM;\n\t\tgoto free_dev;\n\t}\n\n\tdev->audio_channels = kcalloc(max_channels(dev),\n\t\tsizeof(*dev->audio_channels), GFP_KERNEL);\n\tif (!dev->audio_channels) {\n\t\terr = -ENOMEM;\n\t\tgoto free_video;\n\t}\n\n\tpr_info(\"%s: PCI %s, IRQ %d, MMIO 0x%lx (%s mode)\\n\", dev->name,\n\t\tpci_name(pci_dev), pci_dev->irq,\n\t\t(unsigned long)pci_resource_start(pci_dev, 0),\n\t\tdma_mode_name(dma_mode));\n\n\tdev->pci_dev = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto free_audio;\n\t}\n\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pci_dev->dev, \"32-bit PCI DMA not supported\\n\");\n\t\terr = -EIO;\n\t\tgoto disable_pci;\n\t}\n\n\terr = pci_request_regions(pci_dev, dev->name);\n\tif (err) {\n\t\tdev_err(&pci_dev->dev, \"unable to request PCI region\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tdev->mmio = pci_ioremap_bar(pci_dev, 0);\n\tif (!dev->mmio) {\n\t\tdev_err(&pci_dev->dev, \"unable to remap PCI region\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_region;\n\t}\n\n\t \n\treg_write(dev, SYS_SOFT_RST, 0x0f);\n\tmdelay(1);\n\n\treg_write(dev, SRST[0], 0x3f);\n\tif (max_channels(dev) > 4)\n\t\treg_write(dev, SRST[1], 0x3f);\n\n\t \n\treg_write(dev, DMA_CMD, 0);\n\treg_write(dev, DMA_CHANNEL_ENABLE, 0);\n\n\t \n\treg_write(dev, DMA_CONFIG, 0xffffff04);\n\treg_write(dev, DMA_CHANNEL_TIMEOUT, 0x140c8584);\n\treg_write(dev, DMA_TIMER_INTERVAL, dma_interval);\n\n\tspin_lock_init(&dev->lock);\n\n\ttimer_setup(&dev->dma_delay_timer, tw686x_dma_delay, 0);\n\n\t \n\tdev->v4l2_dev.release = tw686x_dev_release;\n\terr = tw686x_video_init(dev);\n\tif (err) {\n\t\tdev_err(&pci_dev->dev, \"can't register video\\n\");\n\t\tgoto iounmap;\n\t}\n\n\terr = tw686x_audio_init(dev);\n\tif (err)\n\t\tdev_warn(&pci_dev->dev, \"can't register audio\\n\");\n\n\terr = request_irq(pci_dev->irq, tw686x_irq, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev, \"unable to request interrupt\\n\");\n\t\tgoto tw686x_free;\n\t}\n\n\tpci_set_drvdata(pci_dev, dev);\n\treturn 0;\n\ntw686x_free:\n\ttw686x_video_free(dev);\n\ttw686x_audio_free(dev);\niounmap:\n\tpci_iounmap(pci_dev, dev->mmio);\nfree_region:\n\tpci_release_regions(pci_dev);\ndisable_pci:\n\tpci_disable_device(pci_dev);\nfree_audio:\n\tkfree(dev->audio_channels);\nfree_video:\n\tkfree(dev->video_channels);\nfree_dev:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void tw686x_remove(struct pci_dev *pci_dev)\n{\n\tstruct tw686x_dev *dev = pci_get_drvdata(pci_dev);\n\tunsigned long flags;\n\n\t \n\tfree_irq(pci_dev->irq, dev);\n\n\ttw686x_video_free(dev);\n\ttw686x_audio_free(dev);\n\tdel_timer_sync(&dev->dma_delay_timer);\n\n\tpci_iounmap(pci_dev, dev->mmio);\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->pci_dev = NULL;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\tv4l2_device_put(&dev->v4l2_dev);\n}\n\n \n\n \nstatic const struct pci_device_id tw686x_pci_tbl[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TECHWELL, 0x6864),\n\t\t.driver_data = 4\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TECHWELL, 0x6865),  \n\t\t.driver_data = 4 | TYPE_SECOND_GEN\n\t},\n\t \n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TECHWELL, 0x6868),  \n\t\t.driver_data = 4\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TECHWELL, 0x6869),\n\t\t.driver_data = 8 | TYPE_SECOND_GEN},\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, tw686x_pci_tbl);\n\nstatic struct pci_driver tw686x_pci_driver = {\n\t.name = \"tw686x\",\n\t.id_table = tw686x_pci_tbl,\n\t.probe = tw686x_probe,\n\t.remove = tw686x_remove,\n};\nmodule_pci_driver(tw686x_pci_driver);\n\nMODULE_DESCRIPTION(\"Driver for video frame grabber cards based on Intersil/Techwell TW686[4589]\");\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>\");\nMODULE_AUTHOR(\"Krzysztof Ha?asa <khalasa@piap.pl>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}