{
  "module_name": "tw686x-audio.c",
  "hash_id": "98d35a515020268b07ea4e001ad7f3342781058296f78df08e6316f7c3b2f7f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/tw686x/tw686x-audio.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include \"tw686x.h\"\n#include \"tw686x-regs.h\"\n\n#define AUDIO_CHANNEL_OFFSET 8\n\nvoid tw686x_audio_irq(struct tw686x_dev *dev, unsigned long requests,\n\t\t      unsigned int pb_status)\n{\n\tunsigned long flags;\n\tunsigned int ch, pb;\n\n\tfor_each_set_bit(ch, &requests, max_channels(dev)) {\n\t\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ch];\n\t\tstruct tw686x_audio_buf *done = NULL;\n\t\tstruct tw686x_audio_buf *next = NULL;\n\t\tstruct tw686x_dma_desc *desc;\n\n\t\tpb = !!(pb_status & BIT(AUDIO_CHANNEL_OFFSET + ch));\n\n\t\tspin_lock_irqsave(&ac->lock, flags);\n\n\t\t \n\t\tif (!ac->ss || !ac->curr_bufs[0] || !ac->curr_bufs[1]) {\n\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&ac->buf_list)) {\n\t\t\tnext = list_first_entry(&ac->buf_list,\n\t\t\t\t\tstruct tw686x_audio_buf, list);\n\t\t\tlist_move_tail(&next->list, &ac->buf_list);\n\t\t\tdone = ac->curr_bufs[!pb];\n\t\t\tac->curr_bufs[pb] = next;\n\t\t}\n\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\n\t\tif (!done)\n\t\t\tcontinue;\n\t\t \n\t\tdesc = &ac->dma_descs[pb];\n\t\tif (desc->virt) {\n\t\t\tmemcpy(done->virt, desc->virt,\n\t\t\t       dev->period_size);\n\t\t} else {\n\t\t\tu32 reg = pb ? ADMA_B_ADDR[ch] : ADMA_P_ADDR[ch];\n\t\t\treg_write(dev, reg, next->dma);\n\t\t}\n\t\tac->ptr = done->dma - ac->buf[0].dma;\n\t\tsnd_pcm_period_elapsed(ac->ss);\n\t}\n}\n\n \nstatic const struct snd_pcm_hardware tw686x_capture_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates\t\t\t= SNDRV_PCM_RATE_8000_48000,\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= TW686X_AUDIO_PAGE_MAX * AUDIO_DMA_SIZE_MAX,\n\t.period_bytes_min\t= AUDIO_DMA_SIZE_MIN,\n\t.period_bytes_max\t= AUDIO_DMA_SIZE_MAX,\n\t.periods_min\t\t= TW686X_AUDIO_PERIODS_MIN,\n\t.periods_max\t\t= TW686X_AUDIO_PERIODS_MAX,\n};\n\nstatic int tw686x_pcm_open(struct snd_pcm_substream *ss)\n{\n\tstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\n\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tint err;\n\n\tac->ss = ss;\n\trt->hw = tw686x_capture_hw;\n\n\terr = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tw686x_pcm_close(struct snd_pcm_substream *ss)\n{\n\tstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\n\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\n\n\tac->ss = NULL;\n\treturn 0;\n}\n\nstatic int tw686x_pcm_prepare(struct snd_pcm_substream *ss)\n{\n\tstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\n\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tunsigned int period_size = snd_pcm_lib_period_bytes(ss);\n\tstruct tw686x_audio_buf *p_buf, *b_buf;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\t \n\tif (((dev->audio_rate != rt->rate) ||\n\t     (dev->period_size != period_size)) && dev->audio_enabled)\n\t\tgoto err_audio_busy;\n\n\ttw686x_disable_channel(dev, AUDIO_CHANNEL_OFFSET + ac->ch);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (dev->audio_rate != rt->rate) {\n\t\tu32 reg;\n\n\t\tdev->audio_rate = rt->rate;\n\t\treg = ((125000000 / rt->rate) << 16) +\n\t\t       ((125000000 % rt->rate) << 16) / rt->rate;\n\n\t\treg_write(dev, AUDIO_CONTROL2, reg);\n\t}\n\n\tif (dev->period_size != period_size) {\n\t\tu32 reg;\n\n\t\tdev->period_size = period_size;\n\t\treg = reg_read(dev, AUDIO_CONTROL1);\n\t\treg &= ~(AUDIO_DMA_SIZE_MASK << AUDIO_DMA_SIZE_SHIFT);\n\t\treg |= period_size << AUDIO_DMA_SIZE_SHIFT;\n\n\t\treg_write(dev, AUDIO_CONTROL1, reg);\n\t}\n\n\tif (rt->periods < TW686X_AUDIO_PERIODS_MIN ||\n\t    rt->periods > TW686X_AUDIO_PERIODS_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tINIT_LIST_HEAD(&ac->buf_list);\n\n\tfor (i = 0; i < rt->periods; i++) {\n\t\tac->buf[i].dma = rt->dma_addr + period_size * i;\n\t\tac->buf[i].virt = rt->dma_area + period_size * i;\n\t\tINIT_LIST_HEAD(&ac->buf[i].list);\n\t\tlist_add_tail(&ac->buf[i].list, &ac->buf_list);\n\t}\n\n\tp_buf =\tlist_first_entry(&ac->buf_list, struct tw686x_audio_buf, list);\n\tlist_move_tail(&p_buf->list, &ac->buf_list);\n\n\tb_buf =\tlist_first_entry(&ac->buf_list, struct tw686x_audio_buf, list);\n\tlist_move_tail(&b_buf->list, &ac->buf_list);\n\n\tac->curr_bufs[0] = p_buf;\n\tac->curr_bufs[1] = b_buf;\n\tac->ptr = 0;\n\n\tif (dev->dma_mode != TW686X_DMA_MODE_MEMCPY) {\n\t\treg_write(dev, ADMA_P_ADDR[ac->ch], p_buf->dma);\n\t\treg_write(dev, ADMA_B_ADDR[ac->ch], b_buf->dma);\n\t}\n\n\tspin_unlock_irqrestore(&ac->lock, flags);\n\n\treturn 0;\n\nerr_audio_busy:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn -EBUSY;\n}\n\nstatic int tw686x_pcm_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n\tstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\n\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\n\tunsigned long flags;\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (ac->curr_bufs[0] && ac->curr_bufs[1]) {\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tdev->audio_enabled = 1;\n\t\t\ttw686x_enable_channel(dev,\n\t\t\t\tAUDIO_CHANNEL_OFFSET + ac->ch);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t\tmod_timer(&dev->dma_delay_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(100));\n\t\t} else {\n\t\t\terr = -EIO;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->audio_enabled = 0;\n\t\ttw686x_disable_channel(dev, AUDIO_CHANNEL_OFFSET + ac->ch);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tspin_lock_irqsave(&ac->lock, flags);\n\t\tac->curr_bufs[0] = NULL;\n\t\tac->curr_bufs[1] = NULL;\n\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic snd_pcm_uframes_t tw686x_pcm_pointer(struct snd_pcm_substream *ss)\n{\n\tstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\n\tstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\n\n\treturn bytes_to_frames(ss->runtime, ac->ptr);\n}\n\nstatic const struct snd_pcm_ops tw686x_pcm_ops = {\n\t.open = tw686x_pcm_open,\n\t.close = tw686x_pcm_close,\n\t.prepare = tw686x_pcm_prepare,\n\t.trigger = tw686x_pcm_trigger,\n\t.pointer = tw686x_pcm_pointer,\n};\n\nstatic int tw686x_snd_pcm_init(struct tw686x_dev *dev)\n{\n\tstruct snd_card *card = dev->snd_card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *ss;\n\tunsigned int i;\n\tint err;\n\n\terr = snd_pcm_new(card, card->driver, 0, 0, max_channels(dev), &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &tw686x_pcm_ops);\n\tsnd_pcm_chip(pcm) = dev;\n\tpcm->info_flags = 0;\n\tstrscpy(pcm->name, \"tw686x PCM\", sizeof(pcm->name));\n\n\tfor (i = 0, ss = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\t     ss; ss = ss->next, i++)\n\t\tsnprintf(ss->name, sizeof(ss->name), \"vch%u audio\", i);\n\n\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\t\tSNDRV_DMA_TYPE_DEV,\n\t\t\t\t&dev->pci_dev->dev,\n\t\t\t\tTW686X_AUDIO_PAGE_MAX * AUDIO_DMA_SIZE_MAX,\n\t\t\t\tTW686X_AUDIO_PAGE_MAX * AUDIO_DMA_SIZE_MAX);\n\treturn 0;\n}\n\nstatic void tw686x_audio_dma_free(struct tw686x_dev *dev,\n\t\t\t\t  struct tw686x_audio_channel *ac)\n{\n\tint pb;\n\n\tfor (pb = 0; pb < 2; pb++) {\n\t\tif (!ac->dma_descs[pb].virt)\n\t\t\tcontinue;\n\t\tdma_free_coherent(&dev->pci_dev->dev, ac->dma_descs[pb].size,\n\t\t\t\t  ac->dma_descs[pb].virt,\n\t\t\t\t  ac->dma_descs[pb].phys);\n\t\tac->dma_descs[pb].virt = NULL;\n\t}\n}\n\nstatic int tw686x_audio_dma_alloc(struct tw686x_dev *dev,\n\t\t\t\t  struct tw686x_audio_channel *ac)\n{\n\tint pb;\n\n\t \n\tif (dev->dma_mode != TW686X_DMA_MODE_MEMCPY)\n\t\treturn 0;\n\n\tfor (pb = 0; pb < 2; pb++) {\n\t\tu32 reg = pb ? ADMA_B_ADDR[ac->ch] : ADMA_P_ADDR[ac->ch];\n\t\tvoid *virt;\n\n\t\tvirt = dma_alloc_coherent(&dev->pci_dev->dev,\n\t\t\t\t\t  AUDIO_DMA_SIZE_MAX,\n\t\t\t\t\t  &ac->dma_descs[pb].phys, GFP_KERNEL);\n\t\tif (!virt) {\n\t\t\tdev_err(&dev->pci_dev->dev,\n\t\t\t\t\"dma%d: unable to allocate audio DMA %s-buffer\\n\",\n\t\t\t\tac->ch, pb ? \"B\" : \"P\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tac->dma_descs[pb].virt = virt;\n\t\tac->dma_descs[pb].size = AUDIO_DMA_SIZE_MAX;\n\t\treg_write(dev, reg, ac->dma_descs[pb].phys);\n\t}\n\treturn 0;\n}\n\nvoid tw686x_audio_free(struct tw686x_dev *dev)\n{\n\tunsigned long flags;\n\tu32 dma_ch_mask;\n\tu32 dma_cmd;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdma_cmd = reg_read(dev, DMA_CMD);\n\tdma_ch_mask = reg_read(dev, DMA_CHANNEL_ENABLE);\n\treg_write(dev, DMA_CMD, dma_cmd & ~0xff00);\n\treg_write(dev, DMA_CHANNEL_ENABLE, dma_ch_mask & ~0xff00);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (!dev->snd_card)\n\t\treturn;\n\tsnd_card_free(dev->snd_card);\n\tdev->snd_card = NULL;\n}\n\nint tw686x_audio_init(struct tw686x_dev *dev)\n{\n\tstruct pci_dev *pci_dev = dev->pci_dev;\n\tstruct snd_card *card;\n\tint err, ch;\n\n\t \n\treg_write(dev, AUDIO_CONTROL1, BIT(0));\n\n\terr = snd_card_new(&pci_dev->dev, SNDRV_DEFAULT_IDX1,\n\t\t\t   SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev->snd_card = card;\n\tstrscpy(card->driver, \"tw686x\", sizeof(card->driver));\n\tstrscpy(card->shortname, \"tw686x\", sizeof(card->shortname));\n\tstrscpy(card->longname, pci_name(pci_dev), sizeof(card->longname));\n\tsnd_card_set_dev(card, &pci_dev->dev);\n\n\tfor (ch = 0; ch < max_channels(dev); ch++) {\n\t\tstruct tw686x_audio_channel *ac;\n\n\t\tac = &dev->audio_channels[ch];\n\t\tspin_lock_init(&ac->lock);\n\t\tac->dev = dev;\n\t\tac->ch = ch;\n\n\t\terr = tw686x_audio_dma_alloc(dev, ac);\n\t\tif (err < 0)\n\t\t\tgoto err_cleanup;\n\t}\n\n\terr = tw686x_snd_pcm_init(dev);\n\tif (err < 0)\n\t\tgoto err_cleanup;\n\n\terr = snd_card_register(card);\n\tif (!err)\n\t\treturn 0;\n\nerr_cleanup:\n\tfor (ch = 0; ch < max_channels(dev); ch++) {\n\t\tif (!dev->audio_channels[ch].dev)\n\t\t\tcontinue;\n\t\ttw686x_audio_dma_free(dev, &dev->audio_channels[ch]);\n\t}\n\tsnd_card_free(card);\n\tdev->snd_card = NULL;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}