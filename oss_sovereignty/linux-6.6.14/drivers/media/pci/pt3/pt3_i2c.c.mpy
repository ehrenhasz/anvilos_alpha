{
  "module_name": "pt3_i2c.c",
  "hash_id": "4324b6375321315c0f1c3330b437eb411e9b05cb6bc604a2a9d434cab44585b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/pt3/pt3_i2c.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n\n#include \"pt3.h\"\n\n#define PT3_I2C_BASE  2048\n#define PT3_CMD_ADDR_NORMAL 0\n#define PT3_CMD_ADDR_INIT_DEMOD  4096\n#define PT3_CMD_ADDR_INIT_TUNER  (4096 + 2042)\n\n \n#define STAT_SEQ_RUNNING 0x1\n#define STAT_SEQ_ERROR   0x6\n#define STAT_NO_SEQ      0x8\n\n#define PT3_I2C_RUN   (1 << 16)\n#define PT3_I2C_RESET (1 << 17)\n\nenum ctl_cmd {\n\tI_END,\n\tI_ADDRESS,\n\tI_CLOCK_L,\n\tI_CLOCK_H,\n\tI_DATA_L,\n\tI_DATA_H,\n\tI_RESET,\n\tI_SLEEP,\n\tI_DATA_L_NOP  = 0x08,\n\tI_DATA_H_NOP  = 0x0c,\n\tI_DATA_H_READ = 0x0d,\n\tI_DATA_H_ACK0 = 0x0e,\n\tI_DATA_H_ACK1 = 0x0f,\n};\n\n\nstatic void cmdbuf_add(struct pt3_i2cbuf *cbuf, enum ctl_cmd cmd)\n{\n\tint buf_idx;\n\n\tif ((cbuf->num_cmds % 2) == 0)\n\t\tcbuf->tmp = cmd;\n\telse {\n\t\tcbuf->tmp |= cmd << 4;\n\t\tbuf_idx = cbuf->num_cmds / 2;\n\t\tif (buf_idx < ARRAY_SIZE(cbuf->data))\n\t\t\tcbuf->data[buf_idx] = cbuf->tmp;\n\t}\n\tcbuf->num_cmds++;\n}\n\nstatic void put_end(struct pt3_i2cbuf *cbuf)\n{\n\tcmdbuf_add(cbuf, I_END);\n\tif (cbuf->num_cmds % 2)\n\t\tcmdbuf_add(cbuf, I_END);\n}\n\nstatic void put_start(struct pt3_i2cbuf *cbuf)\n{\n\tcmdbuf_add(cbuf, I_DATA_H);\n\tcmdbuf_add(cbuf, I_CLOCK_H);\n\tcmdbuf_add(cbuf, I_DATA_L);\n\tcmdbuf_add(cbuf, I_CLOCK_L);\n}\n\nstatic void put_byte_write(struct pt3_i2cbuf *cbuf, u8 val)\n{\n\tu8 mask;\n\n\tfor (mask = 0x80; mask > 0; mask >>= 1)\n\t\tcmdbuf_add(cbuf, (val & mask) ? I_DATA_H_NOP : I_DATA_L_NOP);\n\tcmdbuf_add(cbuf, I_DATA_H_ACK0);\n}\n\nstatic void put_byte_read(struct pt3_i2cbuf *cbuf, u32 size)\n{\n\tint i, j;\n\n\tfor (i = 0; i < size; i++) {\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tcmdbuf_add(cbuf, I_DATA_H_READ);\n\t\tcmdbuf_add(cbuf, (i == size - 1) ? I_DATA_H_NOP : I_DATA_L_NOP);\n\t}\n}\n\nstatic void put_stop(struct pt3_i2cbuf *cbuf)\n{\n\tcmdbuf_add(cbuf, I_DATA_L);\n\tcmdbuf_add(cbuf, I_CLOCK_H);\n\tcmdbuf_add(cbuf, I_DATA_H);\n}\n\n\n \nstatic void translate(struct pt3_i2cbuf *cbuf, struct i2c_msg *msgs, int num)\n{\n\tint i, j;\n\tbool rd;\n\n\tcbuf->num_cmds = 0;\n\tfor (i = 0; i < num; i++) {\n\t\trd = !!(msgs[i].flags & I2C_M_RD);\n\t\tput_start(cbuf);\n\t\tput_byte_write(cbuf, msgs[i].addr << 1 | rd);\n\t\tif (rd)\n\t\t\tput_byte_read(cbuf, msgs[i].len);\n\t\telse\n\t\t\tfor (j = 0; j < msgs[i].len; j++)\n\t\t\t\tput_byte_write(cbuf, msgs[i].buf[j]);\n\t}\n\tif (num > 0) {\n\t\tput_stop(cbuf);\n\t\tput_end(cbuf);\n\t}\n}\n\nstatic int wait_i2c_result(struct pt3_board *pt3, u32 *result, int max_wait)\n{\n\tint i;\n\tu32 v;\n\n\tfor (i = 0; i < max_wait; i++) {\n\t\tv = ioread32(pt3->regs[0] + REG_I2C_R);\n\t\tif (!(v & STAT_SEQ_RUNNING))\n\t\t\tbreak;\n\t\tusleep_range(500, 750);\n\t}\n\tif (i >= max_wait)\n\t\treturn -EIO;\n\tif (result)\n\t\t*result = v;\n\treturn 0;\n}\n\n \nstatic int send_i2c_cmd(struct pt3_board *pt3, u32 addr)\n{\n\tu32 ret;\n\n\t \n\tif (wait_i2c_result(pt3, NULL, 50)) {\n\t\tdev_warn(&pt3->pdev->dev, \"(%s) prev. transaction stalled\\n\",\n\t\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tiowrite32(PT3_I2C_RUN | addr, pt3->regs[0] + REG_I2C_W);\n\tusleep_range(200, 300);\n\t \n\tif (wait_i2c_result(pt3, &ret, 500) || (ret & STAT_SEQ_ERROR)) {\n\t\tdev_warn(&pt3->pdev->dev, \"(%s) failed.\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n \nint  pt3_init_all_demods(struct pt3_board *pt3)\n{\n\tioread32(pt3->regs[0] + REG_I2C_R);\n\treturn send_i2c_cmd(pt3, PT3_CMD_ADDR_INIT_DEMOD);\n}\n\n \nint  pt3_init_all_mxl301rf(struct pt3_board *pt3)\n{\n\tusleep_range(1000, 2000);\n\treturn send_i2c_cmd(pt3, PT3_CMD_ADDR_INIT_TUNER);\n}\n\nvoid pt3_i2c_reset(struct pt3_board *pt3)\n{\n\tiowrite32(PT3_I2C_RESET, pt3->regs[0] + REG_I2C_W);\n}\n\n \nint\npt3_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct pt3_board *pt3;\n\tstruct pt3_i2cbuf *cbuf;\n\tint i;\n\tvoid __iomem *p;\n\n\tpt3 = i2c_get_adapdata(adap);\n\tcbuf = pt3->i2c_buf;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (msgs[i].flags & I2C_M_RECV_LEN) {\n\t\t\tdev_warn(&pt3->pdev->dev,\n\t\t\t\t\"(%s) I2C_M_RECV_LEN not supported.\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\ttranslate(cbuf, msgs, num);\n\tmemcpy_toio(pt3->regs[1] + PT3_I2C_BASE + PT3_CMD_ADDR_NORMAL / 2,\n\t\t\tcbuf->data, cbuf->num_cmds);\n\n\tif (send_i2c_cmd(pt3, PT3_CMD_ADDR_NORMAL) < 0)\n\t\treturn -EIO;\n\n\tp = pt3->regs[1] + PT3_I2C_BASE;\n\tfor (i = 0; i < num; i++)\n\t\tif ((msgs[i].flags & I2C_M_RD) && msgs[i].len > 0) {\n\t\t\tmemcpy_fromio(msgs[i].buf, p, msgs[i].len);\n\t\t\tp += msgs[i].len;\n\t\t}\n\n\treturn num;\n}\n\nu32 pt3_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}