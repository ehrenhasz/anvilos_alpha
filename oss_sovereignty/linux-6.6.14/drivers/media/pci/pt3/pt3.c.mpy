{
  "module_name": "pt3.c",
  "hash_id": "9ecf00783d7e7bd6b95b19732c00b9d2fa785961846071d27b23e773c59adcc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/pt3/pt3.c",
  "human_readable_source": "\n \n\n#include <linux/freezer.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/sched/signal.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n\n#include \"pt3.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic bool one_adapter;\nmodule_param(one_adapter, bool, 0444);\nMODULE_PARM_DESC(one_adapter, \"Place FE's together under one adapter.\");\n\nstatic int num_bufs = 4;\nmodule_param(num_bufs, int, 0444);\nMODULE_PARM_DESC(num_bufs, \"Number of DMA buffer (188KiB) per FE.\");\n\n\nstatic const struct i2c_algorithm pt3_i2c_algo = {\n\t.master_xfer   = &pt3_i2c_master_xfer,\n\t.functionality = &pt3_i2c_functionality,\n};\n\nstatic const struct pt3_adap_config adap_conf[PT3_NUM_FE] = {\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_SAT, 0x11),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"qm1d1c0042\", 0x63),\n\t\t},\n\t\t.tuner_cfg.qm1d1c0042 = {\n\t\t\t.lpf = 1,\n\t\t},\n\t\t.init_freq = 1049480 - 300,\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_TER, 0x10),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"mxl301rf\", 0x62),\n\t\t},\n\t\t.init_freq = 515142857,\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_SAT, 0x13),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"qm1d1c0042\", 0x60),\n\t\t},\n\t\t.tuner_cfg.qm1d1c0042 = {\n\t\t\t.lpf = 1,\n\t\t},\n\t\t.init_freq = 1049480 + 300,\n\t},\n\t{\n\t\t.demod_info = {\n\t\t\tI2C_BOARD_INFO(TC90522_I2C_DEV_TER, 0x12),\n\t\t},\n\t\t.tuner_info = {\n\t\t\tI2C_BOARD_INFO(\"mxl301rf\", 0x61),\n\t\t},\n\t\t.init_freq = 521142857,\n\t},\n};\n\n\nstruct reg_val {\n\tu8 reg;\n\tu8 val;\n};\n\nstatic int\npt3_demod_write(struct pt3_adapter *adap, const struct reg_val *data, int num)\n{\n\tstruct i2c_msg msg;\n\tint i, ret;\n\n\tret = 0;\n\tmsg.addr = adap->i2c_demod->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tfor (i = 0; i < num; i++) {\n\t\tmsg.buf = (u8 *)&data[i];\n\t\tret = i2c_transfer(adap->i2c_demod->adapter, &msg, 1);\n\t\tif (ret == 0)\n\t\t\tret = -EREMOTE;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic inline void pt3_lnb_ctrl(struct pt3_board *pt3, bool on)\n{\n\tiowrite32((on ? 0x0f : 0x0c), pt3->regs[0] + REG_SYSTEM_W);\n}\n\nstatic inline struct pt3_adapter *pt3_find_adapter(struct dvb_frontend *fe)\n{\n\tstruct pt3_board *pt3;\n\tint i;\n\n\tif (one_adapter) {\n\t\tpt3 = fe->dvb->priv;\n\t\tfor (i = 0; i < PT3_NUM_FE; i++)\n\t\t\tif (pt3->adaps[i]->fe == fe)\n\t\t\t\treturn pt3->adaps[i];\n\t}\n\treturn container_of(fe->dvb, struct pt3_adapter, dvb_adap);\n}\n\n \nstatic int\npt3_set_tuner_power(struct pt3_board *pt3, bool tuner_on, bool amp_on)\n{\n\tstruct reg_val rv = { 0x1e, 0x99 };\n\n\tif (tuner_on)\n\t\trv.val |= 0x40;\n\tif (amp_on)\n\t\trv.val |= 0x04;\n\treturn pt3_demod_write(pt3->adaps[PT3_NUM_FE - 1], &rv, 1);\n}\n\nstatic int pt3_set_lna(struct dvb_frontend *fe)\n{\n\tstruct pt3_adapter *adap;\n\tstruct pt3_board *pt3;\n\tu32 val;\n\tint ret;\n\n\t \n\n\tadap = pt3_find_adapter(fe);\n\tval = fe->dtv_property_cache.lna;\n\tif (val == LNA_AUTO || val == adap->cur_lna)\n\t\treturn 0;\n\n\tpt3 = adap->dvb_adap.priv;\n\tif (mutex_lock_interruptible(&pt3->lock))\n\t\treturn -ERESTARTSYS;\n\tif (val)\n\t\tpt3->lna_on_cnt++;\n\telse\n\t\tpt3->lna_on_cnt--;\n\n\tif (val && pt3->lna_on_cnt <= 1) {\n\t\tpt3->lna_on_cnt = 1;\n\t\tret = pt3_set_tuner_power(pt3, true, true);\n\t} else if (!val && pt3->lna_on_cnt <= 0) {\n\t\tpt3->lna_on_cnt = 0;\n\t\tret = pt3_set_tuner_power(pt3, true, false);\n\t} else\n\t\tret = 0;\n\tmutex_unlock(&pt3->lock);\n\tadap->cur_lna = (val != 0);\n\treturn ret;\n}\n\nstatic int pt3_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage volt)\n{\n\tstruct pt3_adapter *adap;\n\tstruct pt3_board *pt3;\n\tbool on;\n\n\t \n\n\tadap = pt3_find_adapter(fe);\n\ton = (volt != SEC_VOLTAGE_OFF);\n\tif (on == adap->cur_lnb)\n\t\treturn 0;\n\tadap->cur_lnb = on;\n\tpt3 = adap->dvb_adap.priv;\n\tif (mutex_lock_interruptible(&pt3->lock))\n\t\treturn -ERESTARTSYS;\n\tif (on)\n\t\tpt3->lnb_on_cnt++;\n\telse\n\t\tpt3->lnb_on_cnt--;\n\n\tif (on && pt3->lnb_on_cnt <= 1) {\n\t\tpt3->lnb_on_cnt = 1;\n\t\tpt3_lnb_ctrl(pt3, true);\n\t} else if (!on && pt3->lnb_on_cnt <= 0) {\n\t\tpt3->lnb_on_cnt = 0;\n\t\tpt3_lnb_ctrl(pt3, false);\n\t}\n\tmutex_unlock(&pt3->lock);\n\treturn 0;\n}\n\n \n\nstatic const struct reg_val init0_sat[] = {\n\t{ 0x03, 0x01 },\n\t{ 0x1e, 0x10 },\n};\nstatic const struct reg_val init0_ter[] = {\n\t{ 0x01, 0x40 },\n\t{ 0x1c, 0x10 },\n};\nstatic const struct reg_val cfg_sat[] = {\n\t{ 0x1c, 0x15 },\n\t{ 0x1f, 0x04 },\n};\nstatic const struct reg_val cfg_ter[] = {\n\t{ 0x1d, 0x01 },\n};\n\n \nstatic int pt3_fe_init(struct pt3_board *pt3)\n{\n\tint i, ret;\n\tstruct dvb_frontend *fe;\n\n\tpt3_i2c_reset(pt3);\n\tret = pt3_init_all_demods(pt3);\n\tif (ret < 0) {\n\t\tdev_warn(&pt3->pdev->dev, \"Failed to init demod chips\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tfe = pt3->adaps[i]->fe;\n\n\t\tif (fe->ops.delsys[0] == SYS_ISDBS)\n\t\t\tret = pt3_demod_write(pt3->adaps[i],\n\t\t\t\t\t      init0_sat, ARRAY_SIZE(init0_sat));\n\t\telse\n\t\t\tret = pt3_demod_write(pt3->adaps[i],\n\t\t\t\t\t      init0_ter, ARRAY_SIZE(init0_ter));\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&pt3->pdev->dev,\n\t\t\t\t \"demod[%d] failed in init sequence0\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t\tret = fe->ops.init(fe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tusleep_range(2000, 4000);\n\tret = pt3_set_tuner_power(pt3, true, false);\n\tif (ret < 0) {\n\t\tdev_warn(&pt3->pdev->dev, \"Failed to control tuner module\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tfe = pt3->adaps[i]->fe;\n\t\tif (fe->ops.delsys[0] == SYS_ISDBS)\n\t\t\tret = pt3_demod_write(pt3->adaps[i],\n\t\t\t\t\t\tcfg_sat, ARRAY_SIZE(cfg_sat));\n\t\telse\n\t\t\tret = pt3_demod_write(pt3->adaps[i],\n\t\t\t\t\t\tcfg_ter, ARRAY_SIZE(cfg_ter));\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&pt3->pdev->dev,\n\t\t\t\t \"demod[%d] failed in init sequence1\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tusleep_range(4000, 6000);\n\n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tfe = pt3->adaps[i]->fe;\n\t\tif (fe->ops.delsys[0] != SYS_ISDBS)\n\t\t\tcontinue;\n\t\t \n\t\tret = fe->ops.tuner_ops.init(fe);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&pt3->pdev->dev,\n\t\t\t\t \"Failed to init SAT-tuner[%d]\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = pt3_init_all_mxl301rf(pt3);\n\tif (ret < 0) {\n\t\tdev_warn(&pt3->pdev->dev, \"Failed to init TERR-tuners\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pt3_set_tuner_power(pt3, true, true);\n\tif (ret < 0) {\n\t\tdev_warn(&pt3->pdev->dev, \"Failed to control tuner module\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tfe = pt3->adaps[i]->fe;\n\t\tret = 0;\n\t\tif (fe->ops.delsys[0] == SYS_ISDBT)\n\t\t\tret = fe->ops.tuner_ops.init(fe);\n\t\t \n\t\tif (ret == 0 && fe->dtv_property_cache.frequency == 0) {\n\t\t\tfe->dtv_property_cache.frequency =\n\t\t\t\t\t\tadap_conf[i].init_freq;\n\t\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&pt3->pdev->dev,\n\t\t\t\t \"Failed in initial tuning of tuner[%d]\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tfe = pt3->adaps[i]->fe;\n\t\tif (fe->ops.tuner_ops.sleep)\n\t\t\tret = fe->ops.tuner_ops.sleep(fe);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (fe->ops.sleep)\n\t\t\tret = fe->ops.sleep(fe);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (fe->ops.delsys[0] == SYS_ISDBS)\n\t\t\tfe->ops.set_voltage = &pt3_set_voltage;\n\t\telse\n\t\t\tfe->ops.set_lna = &pt3_set_lna;\n\t}\n\tif (i < PT3_NUM_FE) {\n\t\tdev_warn(&pt3->pdev->dev, \"FE[%d] failed to standby\\n\", i);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n\nstatic int pt3_attach_fe(struct pt3_board *pt3, int i)\n{\n\tconst struct i2c_board_info *info;\n\tstruct tc90522_config cfg;\n\tstruct i2c_client *cl;\n\tstruct dvb_adapter *dvb_adap;\n\tint ret;\n\n\tinfo = &adap_conf[i].demod_info;\n\tcfg = adap_conf[i].demod_cfg;\n\tcfg.tuner_i2c = NULL;\n\n\tret = -ENODEV;\n\tcl = dvb_module_probe(\"tc90522\", info->type, &pt3->i2c_adap,\n\t\t\t      info->addr, &cfg);\n\tif (!cl)\n\t\treturn -ENODEV;\n\tpt3->adaps[i]->i2c_demod = cl;\n\n\tif (!strncmp(cl->name, TC90522_I2C_DEV_SAT,\n\t\t     strlen(TC90522_I2C_DEV_SAT))) {\n\t\tstruct qm1d1c0042_config tcfg;\n\n\t\ttcfg = adap_conf[i].tuner_cfg.qm1d1c0042;\n\t\ttcfg.fe = cfg.fe;\n\t\tinfo = &adap_conf[i].tuner_info;\n\t\tcl = dvb_module_probe(\"qm1d1c0042\", info->type, cfg.tuner_i2c,\n\t\t\t\t      info->addr, &tcfg);\n\t} else {\n\t\tstruct mxl301rf_config tcfg;\n\n\t\ttcfg = adap_conf[i].tuner_cfg.mxl301rf;\n\t\ttcfg.fe = cfg.fe;\n\t\tinfo = &adap_conf[i].tuner_info;\n\t\tcl = dvb_module_probe(\"mxl301rf\", info->type, cfg.tuner_i2c,\n\t\t\t\t      info->addr, &tcfg);\n\t}\n\tif (!cl)\n\t\tgoto err_demod_module_release;\n\tpt3->adaps[i]->i2c_tuner = cl;\n\n\tdvb_adap = &pt3->adaps[one_adapter ? 0 : i]->dvb_adap;\n\tret = dvb_register_frontend(dvb_adap, cfg.fe);\n\tif (ret < 0)\n\t\tgoto err_tuner_module_release;\n\tpt3->adaps[i]->fe = cfg.fe;\n\treturn 0;\n\nerr_tuner_module_release:\n\tdvb_module_release(pt3->adaps[i]->i2c_tuner);\nerr_demod_module_release:\n\tdvb_module_release(pt3->adaps[i]->i2c_demod);\n\n\treturn ret;\n}\n\n\nstatic int pt3_fetch_thread(void *data)\n{\n\tstruct pt3_adapter *adap = data;\n\tktime_t delay;\n\tbool was_frozen;\n\n#define PT3_INITIAL_BUF_DROPS 4\n#define PT3_FETCH_DELAY 10\n#define PT3_FETCH_DELAY_DELTA 2\n\n\tpt3_init_dmabuf(adap);\n\tadap->num_discard = PT3_INITIAL_BUF_DROPS;\n\n\tdev_dbg(adap->dvb_adap.device, \"PT3: [%s] started\\n\",\n\t\tadap->thread->comm);\n\tset_freezable();\n\twhile (!kthread_freezable_should_stop(&was_frozen)) {\n\t\tif (was_frozen)\n\t\t\tadap->num_discard = PT3_INITIAL_BUF_DROPS;\n\n\t\tpt3_proc_dma(adap);\n\n\t\tdelay = ktime_set(0, PT3_FETCH_DELAY * NSEC_PER_MSEC);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE|TASK_FREEZABLE);\n\t\tschedule_hrtimeout_range(&delay,\n\t\t\t\t\tPT3_FETCH_DELAY_DELTA * NSEC_PER_MSEC,\n\t\t\t\t\tHRTIMER_MODE_REL);\n\t}\n\tdev_dbg(adap->dvb_adap.device, \"PT3: [%s] exited\\n\",\n\t\tadap->thread->comm);\n\treturn 0;\n}\n\nstatic int pt3_start_streaming(struct pt3_adapter *adap)\n{\n\tstruct task_struct *thread;\n\n\t \n\tthread = kthread_run(pt3_fetch_thread, adap, \"pt3-ad%i-dmx%i\",\n\t\t\t\tadap->dvb_adap.num, adap->dmxdev.dvbdev->id);\n\tif (IS_ERR(thread)) {\n\t\tint ret = PTR_ERR(thread);\n\n\t\tadap->thread = NULL;\n\t\tdev_warn(adap->dvb_adap.device,\n\t\t\t \"PT3 (adap:%d, dmx:%d): failed to start kthread\\n\",\n\t\t\t adap->dvb_adap.num, adap->dmxdev.dvbdev->id);\n\t\treturn ret;\n\t}\n\tadap->thread = thread;\n\n\treturn pt3_start_dma(adap);\n}\n\nstatic int pt3_stop_streaming(struct pt3_adapter *adap)\n{\n\tint ret;\n\n\tret = pt3_stop_dma(adap);\n\tif (ret)\n\t\tdev_warn(adap->dvb_adap.device,\n\t\t\t \"PT3: failed to stop streaming of adap:%d/FE:%d\\n\",\n\t\t\t adap->dvb_adap.num, adap->fe->id);\n\n\t \n\tret = kthread_stop(adap->thread);\n\tadap->thread = NULL;\n\treturn ret;\n}\n\nstatic int pt3_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct pt3_adapter *adap;\n\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\n\tadap = container_of(feed->demux, struct pt3_adapter, demux);\n\tadap->num_feeds++;\n\tif (adap->num_feeds > 1)\n\t\treturn 0;\n\n\treturn pt3_start_streaming(adap);\n\n}\n\nstatic int pt3_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct pt3_adapter *adap;\n\n\tadap = container_of(feed->demux, struct pt3_adapter, demux);\n\n\tadap->num_feeds--;\n\tif (adap->num_feeds > 0 || !adap->thread)\n\t\treturn 0;\n\tadap->num_feeds = 0;\n\n\treturn pt3_stop_streaming(adap);\n}\n\n\nstatic int pt3_alloc_adapter(struct pt3_board *pt3, int index)\n{\n\tint ret;\n\tstruct pt3_adapter *adap;\n\tstruct dvb_adapter *da;\n\n\tadap = kzalloc(sizeof(*adap), GFP_KERNEL);\n\tif (!adap)\n\t\treturn -ENOMEM;\n\n\tpt3->adaps[index] = adap;\n\tadap->adap_idx = index;\n\n\tif (index == 0 || !one_adapter) {\n\t\tret = dvb_register_adapter(&adap->dvb_adap, \"PT3 DVB\",\n\t\t\t\tTHIS_MODULE, &pt3->pdev->dev, adapter_nr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pt3->pdev->dev,\n\t\t\t\t\"failed to register adapter dev\\n\");\n\t\t\tgoto err_mem;\n\t\t}\n\t\tda = &adap->dvb_adap;\n\t} else\n\t\tda = &pt3->adaps[0]->dvb_adap;\n\n\tadap->dvb_adap.priv = pt3;\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tadap->demux.priv = adap;\n\tadap->demux.feednum = 256;\n\tadap->demux.filternum = 256;\n\tadap->demux.start_feed = pt3_start_feed;\n\tadap->demux.stop_feed = pt3_stop_feed;\n\tret = dvb_dmx_init(&adap->demux);\n\tif (ret < 0) {\n\t\tdev_err(&pt3->pdev->dev, \"failed to init dmx dev\\n\");\n\t\tgoto err_adap;\n\t}\n\n\tadap->dmxdev.filternum = 256;\n\tadap->dmxdev.demux = &adap->demux.dmx;\n\tret = dvb_dmxdev_init(&adap->dmxdev, da);\n\tif (ret < 0) {\n\t\tdev_err(&pt3->pdev->dev, \"failed to init dmxdev\\n\");\n\t\tgoto err_demux;\n\t}\n\n\tret = pt3_alloc_dmabuf(adap);\n\tif (ret) {\n\t\tdev_err(&pt3->pdev->dev, \"failed to alloc DMA buffers\\n\");\n\t\tgoto err_dmabuf;\n\t}\n\n\treturn 0;\n\nerr_dmabuf:\n\tpt3_free_dmabuf(adap);\n\tdvb_dmxdev_release(&adap->dmxdev);\nerr_demux:\n\tdvb_dmx_release(&adap->demux);\nerr_adap:\n\tif (index == 0 || !one_adapter)\n\t\tdvb_unregister_adapter(da);\nerr_mem:\n\tkfree(adap);\n\tpt3->adaps[index] = NULL;\n\treturn ret;\n}\n\nstatic void pt3_cleanup_adapter(struct pt3_board *pt3, int index)\n{\n\tstruct pt3_adapter *adap;\n\tstruct dmx_demux *dmx;\n\n\tadap = pt3->adaps[index];\n\tif (adap == NULL)\n\t\treturn;\n\n\t \n\tif (adap->thread)\n\t\tpt3_stop_streaming(adap);\n\n\tdmx = &adap->demux.dmx;\n\tdmx->close(dmx);\n\tif (adap->fe) {\n\t\tadap->fe->callback = NULL;\n\t\tif (adap->fe->frontend_priv)\n\t\t\tdvb_unregister_frontend(adap->fe);\n\t\tdvb_module_release(adap->i2c_tuner);\n\t\tdvb_module_release(adap->i2c_demod);\n\t}\n\tpt3_free_dmabuf(adap);\n\tdvb_dmxdev_release(&adap->dmxdev);\n\tdvb_dmx_release(&adap->demux);\n\tif (index == 0 || !one_adapter)\n\t\tdvb_unregister_adapter(&adap->dvb_adap);\n\tkfree(adap);\n\tpt3->adaps[index] = NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int pt3_suspend(struct device *dev)\n{\n\tstruct pt3_board *pt3 = dev_get_drvdata(dev);\n\tint i;\n\tstruct pt3_adapter *adap;\n\n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tadap = pt3->adaps[i];\n\t\tif (adap->num_feeds > 0)\n\t\t\tpt3_stop_dma(adap);\n\t\tdvb_frontend_suspend(adap->fe);\n\t\tpt3_free_dmabuf(adap);\n\t}\n\n\tpt3_lnb_ctrl(pt3, false);\n\tpt3_set_tuner_power(pt3, false, false);\n\treturn 0;\n}\n\nstatic int pt3_resume(struct device *dev)\n{\n\tstruct pt3_board *pt3 = dev_get_drvdata(dev);\n\tint i, ret;\n\tstruct pt3_adapter *adap;\n\n\tret = pt3_fe_init(pt3);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pt3->lna_on_cnt > 0)\n\t\tpt3_set_tuner_power(pt3, true, true);\n\tif (pt3->lnb_on_cnt > 0)\n\t\tpt3_lnb_ctrl(pt3, true);\n\n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tadap = pt3->adaps[i];\n\t\tdvb_frontend_resume(adap->fe);\n\t\tret = pt3_alloc_dmabuf(adap);\n\t\tif (ret) {\n\t\t\tdev_err(&pt3->pdev->dev, \"failed to alloc DMA bufs\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (adap->num_feeds > 0)\n\t\t\tpt3_start_dma(adap);\n\t}\n\n\treturn 0;\n}\n\n#endif  \n\n\nstatic void pt3_remove(struct pci_dev *pdev)\n{\n\tstruct pt3_board *pt3;\n\tint i;\n\n\tpt3 = pci_get_drvdata(pdev);\n\tfor (i = PT3_NUM_FE - 1; i >= 0; i--)\n\t\tpt3_cleanup_adapter(pt3, i);\n\ti2c_del_adapter(&pt3->i2c_adap);\n}\n\nstatic int pt3_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 rev;\n\tu32 ver;\n\tint i, ret;\n\tstruct pt3_board *pt3;\n\tstruct i2c_adapter *i2c;\n\n\tif (pci_read_config_byte(pdev, PCI_REVISION_ID, &rev) || rev != 1)\n\t\treturn -ENODEV;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\tpci_set_master(pdev);\n\n\tret = pcim_iomap_regions(pdev, BIT(0) | BIT(2), DRV_NAME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\tpt3 = devm_kzalloc(&pdev->dev, sizeof(*pt3), GFP_KERNEL);\n\tif (!pt3)\n\t\treturn -ENOMEM;\n\tpci_set_drvdata(pdev, pt3);\n\tpt3->pdev = pdev;\n\tmutex_init(&pt3->lock);\n\tpt3->regs[0] = pcim_iomap_table(pdev)[0];\n\tpt3->regs[1] = pcim_iomap_table(pdev)[2];\n\n\tver = ioread32(pt3->regs[0] + REG_VERSION);\n\tif ((ver >> 16) != 0x0301) {\n\t\tdev_warn(&pdev->dev, \"PT%d, I/F-ver.:%d not supported\\n\",\n\t\t\t ver >> 24, (ver & 0x00ff0000) >> 16);\n\t\treturn -ENODEV;\n\t}\n\n\tpt3->num_bufs = clamp_val(num_bufs, MIN_DATA_BUFS, MAX_DATA_BUFS);\n\n\tpt3->i2c_buf = devm_kmalloc(&pdev->dev, sizeof(*pt3->i2c_buf), GFP_KERNEL);\n\tif (!pt3->i2c_buf)\n\t\treturn -ENOMEM;\n\ti2c = &pt3->i2c_adap;\n\ti2c->owner = THIS_MODULE;\n\ti2c->algo = &pt3_i2c_algo;\n\ti2c->algo_data = NULL;\n\ti2c->dev.parent = &pdev->dev;\n\tstrscpy(i2c->name, DRV_NAME, sizeof(i2c->name));\n\ti2c_set_adapdata(i2c, pt3);\n\tret = i2c_add_adapter(i2c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < PT3_NUM_FE; i++) {\n\t\tret = pt3_alloc_adapter(pt3, i);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = pt3_attach_fe(pt3, i);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tif (i < PT3_NUM_FE) {\n\t\tdev_err(&pdev->dev, \"Failed to create FE%d\\n\", i);\n\t\tgoto err_cleanup_adapters;\n\t}\n\n\tret = pt3_fe_init(pt3);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to init frontends\\n\");\n\t\ti = PT3_NUM_FE - 1;\n\t\tgoto err_cleanup_adapters;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t \"successfully init'ed PT%d (fw:0x%02x, I/F:0x%02x)\\n\",\n\t\t ver >> 24, (ver >> 8) & 0xff, (ver >> 16) & 0xff);\n\treturn 0;\n\nerr_cleanup_adapters:\n\twhile (i >= 0)\n\t\tpt3_cleanup_adapter(pt3, i--);\n\ti2c_del_adapter(i2c);\n\treturn ret;\n}\n\nstatic const struct pci_device_id pt3_id_table[] = {\n\t{ PCI_DEVICE_SUB(0x1172, 0x4c15, 0xee8d, 0x0368) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, pt3_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(pt3_pm_ops, pt3_suspend, pt3_resume);\n\nstatic struct pci_driver pt3_driver = {\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= pt3_probe,\n\t.remove\t\t= pt3_remove,\n\t.id_table\t= pt3_id_table,\n\n\t.driver.pm\t= &pt3_pm_ops,\n};\n\nmodule_pci_driver(pt3_driver);\n\nMODULE_DESCRIPTION(\"Earthsoft PT3 Driver\");\nMODULE_AUTHOR(\"Akihiro TSUKADA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}