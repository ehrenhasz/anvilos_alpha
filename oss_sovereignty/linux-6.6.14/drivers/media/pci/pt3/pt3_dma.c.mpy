{
  "module_name": "pt3_dma.c",
  "hash_id": "04a2671b18c7281b8ad9a3abdef71e3bb37cb1da3c053a5c9a6d445af60a5069",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/pt3/pt3_dma.c",
  "human_readable_source": "\n \n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n\n#include \"pt3.h\"\n\n#define PT3_ACCESS_UNIT (TS_PACKET_SZ * 128)\n#define PT3_BUF_CANARY  (0x74)\n\nstatic u32 get_dma_base(int idx)\n{\n\tint i;\n\n\ti = (idx == 1 || idx == 2) ? 3 - idx : idx;\n\treturn REG_DMA_BASE + 0x18 * i;\n}\n\nint pt3_stop_dma(struct pt3_adapter *adap)\n{\n\tstruct pt3_board *pt3 = adap->dvb_adap.priv;\n\tu32 base;\n\tu32 stat;\n\tint retry;\n\n\tbase = get_dma_base(adap->adap_idx);\n\tstat = ioread32(pt3->regs[0] + base + OFST_STATUS);\n\tif (!(stat & 0x01))\n\t\treturn 0;\n\n\tiowrite32(0x02, pt3->regs[0] + base + OFST_DMA_CTL);\n\tfor (retry = 0; retry < 5; retry++) {\n\t\tstat = ioread32(pt3->regs[0] + base + OFST_STATUS);\n\t\tif (!(stat & 0x01))\n\t\t\treturn 0;\n\t\tmsleep(50);\n\t}\n\treturn -EIO;\n}\n\nint pt3_start_dma(struct pt3_adapter *adap)\n{\n\tstruct pt3_board *pt3 = adap->dvb_adap.priv;\n\tu32 base = get_dma_base(adap->adap_idx);\n\n\tiowrite32(0x02, pt3->regs[0] + base + OFST_DMA_CTL);\n\tiowrite32(lower_32_bits(adap->desc_buf[0].b_addr),\n\t\t\tpt3->regs[0] + base + OFST_DMA_DESC_L);\n\tiowrite32(upper_32_bits(adap->desc_buf[0].b_addr),\n\t\t\tpt3->regs[0] + base + OFST_DMA_DESC_H);\n\tiowrite32(0x01, pt3->regs[0] + base + OFST_DMA_CTL);\n\treturn 0;\n}\n\n\nstatic u8 *next_unit(struct pt3_adapter *adap, int *idx, int *ofs)\n{\n\t*ofs += PT3_ACCESS_UNIT;\n\tif (*ofs >= DATA_BUF_SZ) {\n\t\t*ofs -= DATA_BUF_SZ;\n\t\t(*idx)++;\n\t\tif (*idx == adap->num_bufs)\n\t\t\t*idx = 0;\n\t}\n\treturn &adap->buffer[*idx].data[*ofs];\n}\n\nint pt3_proc_dma(struct pt3_adapter *adap)\n{\n\tint idx, ofs;\n\n\tidx = adap->buf_idx;\n\tofs = adap->buf_ofs;\n\n\tif (adap->buffer[idx].data[ofs] == PT3_BUF_CANARY)\n\t\treturn 0;\n\n\twhile (*next_unit(adap, &idx, &ofs) != PT3_BUF_CANARY) {\n\t\tu8 *p;\n\n\t\tp = &adap->buffer[adap->buf_idx].data[adap->buf_ofs];\n\t\tif (adap->num_discard > 0)\n\t\t\tadap->num_discard--;\n\t\telse if (adap->buf_ofs + PT3_ACCESS_UNIT > DATA_BUF_SZ) {\n\t\t\tdvb_dmx_swfilter_packets(&adap->demux, p,\n\t\t\t\t(DATA_BUF_SZ - adap->buf_ofs) / TS_PACKET_SZ);\n\t\t\tdvb_dmx_swfilter_packets(&adap->demux,\n\t\t\t\tadap->buffer[idx].data, ofs / TS_PACKET_SZ);\n\t\t} else\n\t\t\tdvb_dmx_swfilter_packets(&adap->demux, p,\n\t\t\t\tPT3_ACCESS_UNIT / TS_PACKET_SZ);\n\n\t\t*p = PT3_BUF_CANARY;\n\t\tadap->buf_idx = idx;\n\t\tadap->buf_ofs = ofs;\n\t}\n\treturn 0;\n}\n\nvoid pt3_init_dmabuf(struct pt3_adapter *adap)\n{\n\tint idx, ofs;\n\tu8 *p;\n\n\tidx = 0;\n\tofs = 0;\n\tp = adap->buffer[0].data;\n\t \n\twhile (idx < adap->num_bufs) {\n\t\tp[ofs] = PT3_BUF_CANARY;\n\t\tofs += PT3_ACCESS_UNIT;\n\t\tif (ofs >= DATA_BUF_SZ) {\n\t\t\tofs -= DATA_BUF_SZ;\n\t\t\tidx++;\n\t\t\tp = adap->buffer[idx].data;\n\t\t}\n\t}\n\tadap->buf_idx = 0;\n\tadap->buf_ofs = 0;\n}\n\nvoid pt3_free_dmabuf(struct pt3_adapter *adap)\n{\n\tstruct pt3_board *pt3;\n\tint i;\n\n\tpt3 = adap->dvb_adap.priv;\n\tfor (i = 0; i < adap->num_bufs; i++)\n\t\tdma_free_coherent(&pt3->pdev->dev, DATA_BUF_SZ,\n\t\t\tadap->buffer[i].data, adap->buffer[i].b_addr);\n\tadap->num_bufs = 0;\n\n\tfor (i = 0; i < adap->num_desc_bufs; i++)\n\t\tdma_free_coherent(&pt3->pdev->dev, PAGE_SIZE,\n\t\t\tadap->desc_buf[i].descs, adap->desc_buf[i].b_addr);\n\tadap->num_desc_bufs = 0;\n}\n\n\nint pt3_alloc_dmabuf(struct pt3_adapter *adap)\n{\n\tstruct pt3_board *pt3;\n\tvoid *p;\n\tint i, j;\n\tint idx, ofs;\n\tint num_desc_bufs;\n\tdma_addr_t data_addr, desc_addr;\n\tstruct xfer_desc *d;\n\n\tpt3 = adap->dvb_adap.priv;\n\tadap->num_bufs = 0;\n\tadap->num_desc_bufs = 0;\n\tfor (i = 0; i < pt3->num_bufs; i++) {\n\t\tp = dma_alloc_coherent(&pt3->pdev->dev, DATA_BUF_SZ,\n\t\t\t\t\t&adap->buffer[i].b_addr, GFP_KERNEL);\n\t\tif (p == NULL)\n\t\t\tgoto failed;\n\t\tadap->buffer[i].data = p;\n\t\tadap->num_bufs++;\n\t}\n\tpt3_init_dmabuf(adap);\n\n\t \n\tidx = 0;\n\tofs = 0;\n\tnum_desc_bufs =\n\t\tDIV_ROUND_UP(adap->num_bufs * DATA_BUF_XFERS, DESCS_IN_PAGE);\n\tfor (i = 0; i < num_desc_bufs; i++) {\n\t\tp = dma_alloc_coherent(&pt3->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t&desc_addr, GFP_KERNEL);\n\t\tif (p == NULL)\n\t\t\tgoto failed;\n\t\tadap->num_desc_bufs++;\n\t\tadap->desc_buf[i].descs = p;\n\t\tadap->desc_buf[i].b_addr = desc_addr;\n\n\t\tif (i > 0) {\n\t\t\td = &adap->desc_buf[i - 1].descs[DESCS_IN_PAGE - 1];\n\t\t\td->next_l = lower_32_bits(desc_addr);\n\t\t\td->next_h = upper_32_bits(desc_addr);\n\t\t}\n\t\tfor (j = 0; j < DESCS_IN_PAGE; j++) {\n\t\t\tdata_addr = adap->buffer[idx].b_addr + ofs;\n\t\t\td = &adap->desc_buf[i].descs[j];\n\t\t\td->addr_l = lower_32_bits(data_addr);\n\t\t\td->addr_h = upper_32_bits(data_addr);\n\t\t\td->size = DATA_XFER_SZ;\n\n\t\t\tdesc_addr += sizeof(struct xfer_desc);\n\t\t\td->next_l = lower_32_bits(desc_addr);\n\t\t\td->next_h = upper_32_bits(desc_addr);\n\n\t\t\tofs += DATA_XFER_SZ;\n\t\t\tif (ofs >= DATA_BUF_SZ) {\n\t\t\t\tofs -= DATA_BUF_SZ;\n\t\t\t\tidx++;\n\t\t\t\tif (idx >= adap->num_bufs) {\n\t\t\t\t\tdesc_addr = adap->desc_buf[0].b_addr;\n\t\t\t\t\td->next_l = lower_32_bits(desc_addr);\n\t\t\t\t\td->next_h = upper_32_bits(desc_addr);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\nfailed:\n\tpt3_free_dmabuf(adap);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}