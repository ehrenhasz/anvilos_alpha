{
  "module_name": "ivtv-i2c.c",
  "hash_id": "a071c73b9a4f27c4230427df3ea08b60737c32eb7406f0281000bee2ab167237",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-i2c.c",
  "human_readable_source": "\n \n\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-gpio.h\"\n#include \"ivtv-i2c.h\"\n#include <media/drv-intf/cx25840.h>\n\n \n \n#define IVTV_REG_I2C_SETSCL_OFFSET 0x7000\n#define IVTV_REG_I2C_SETSDA_OFFSET 0x7004\n#define IVTV_REG_I2C_GETSCL_OFFSET 0x7008\n#define IVTV_REG_I2C_GETSDA_OFFSET 0x700c\n\n#define IVTV_CS53L32A_I2C_ADDR\t\t0x11\n#define IVTV_M52790_I2C_ADDR\t\t0x48\n#define IVTV_CX25840_I2C_ADDR\t\t0x44\n#define IVTV_SAA7115_I2C_ADDR\t\t0x21\n#define IVTV_SAA7127_I2C_ADDR\t\t0x44\n#define IVTV_SAA717x_I2C_ADDR\t\t0x21\n#define IVTV_MSP3400_I2C_ADDR\t\t0x40\n#define IVTV_HAUPPAUGE_I2C_ADDR\t\t0x50\n#define IVTV_WM8739_I2C_ADDR\t\t0x1a\n#define IVTV_WM8775_I2C_ADDR\t\t0x1b\n#define IVTV_TEA5767_I2C_ADDR\t\t0x60\n#define IVTV_UPD64031A_I2C_ADDR\t\t0x12\n#define IVTV_UPD64083_I2C_ADDR\t\t0x5c\n#define IVTV_VP27SMPX_I2C_ADDR\t\t0x5b\n#define IVTV_M52790_I2C_ADDR\t\t0x48\n#define IVTV_AVERMEDIA_IR_RX_I2C_ADDR\t0x40\n#define IVTV_HAUP_EXT_IR_RX_I2C_ADDR\t0x1a\n#define IVTV_HAUP_INT_IR_RX_I2C_ADDR\t0x18\n#define IVTV_Z8F0811_IR_TX_I2C_ADDR\t0x70\n#define IVTV_Z8F0811_IR_RX_I2C_ADDR\t0x71\n#define IVTV_ADAPTEC_IR_ADDR\t\t0x6b\n\n \nstatic const u8 hw_addrs[IVTV_HW_MAX_BITS] = {\n\tIVTV_CX25840_I2C_ADDR,\n\tIVTV_SAA7115_I2C_ADDR,\n\tIVTV_SAA7127_I2C_ADDR,\n\tIVTV_MSP3400_I2C_ADDR,\n\t0,\n\tIVTV_WM8775_I2C_ADDR,\n\tIVTV_CS53L32A_I2C_ADDR,\n\t0,\n\tIVTV_SAA7115_I2C_ADDR,\n\tIVTV_UPD64031A_I2C_ADDR,\n\tIVTV_UPD64083_I2C_ADDR,\n\tIVTV_SAA717x_I2C_ADDR,\n\tIVTV_WM8739_I2C_ADDR,\n\tIVTV_VP27SMPX_I2C_ADDR,\n\tIVTV_M52790_I2C_ADDR,\n\t0,\t\t\t\t \n\tIVTV_AVERMEDIA_IR_RX_I2C_ADDR,\t \n\tIVTV_HAUP_EXT_IR_RX_I2C_ADDR,\t \n\tIVTV_HAUP_INT_IR_RX_I2C_ADDR,\t \n\tIVTV_Z8F0811_IR_RX_I2C_ADDR,\t \n\tIVTV_ADAPTEC_IR_ADDR,\t\t \n};\n\n \nstatic const char * const hw_devicenames[IVTV_HW_MAX_BITS] = {\n\t\"cx25840\",\n\t\"saa7115\",\n\t\"saa7127_auto\",\t \n\t\"msp3400\",\n\t\"tuner\",\n\t\"wm8775\",\n\t\"cs53l32a\",\n\t\"tveeprom\",\n\t\"saa7114\",\n\t\"upd64031a\",\n\t\"upd64083\",\n\t\"saa717x\",\n\t\"wm8739\",\n\t\"vp27smpx\",\n\t\"m52790\",\n\t\"gpio\",\n\t\"ir_video\",\t\t \n\t\"ir_video\",\t\t \n\t\"ir_video\",\t\t \n\t\"ir_z8f0811_haup\",\t \n\t\"ir_video\",\t\t \n};\n\nstatic int get_key_adaptec(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t   u32 *scancode, u8 *toggle)\n{\n\tunsigned char keybuf[4];\n\n\tkeybuf[0] = 0x00;\n\ti2c_master_send(ir->c, keybuf, 1);\n\t \n\tif (i2c_master_recv(ir->c, keybuf, sizeof(keybuf)) != sizeof(keybuf)) {\n\t\treturn 0;\n\t}\n\n\t \n\tif (keybuf[2] == 0xff)\n\t\treturn 0;\n\n\t \n\tkeybuf[2] &= 0x7f;\n\tkeybuf[3] |= 0x80;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = keybuf[3] | keybuf[2] << 8 | keybuf[1] << 16 |keybuf[0] << 24;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int ivtv_i2c_new_ir(struct ivtv *itv, u32 hw, const char *type, u8 addr)\n{\n\tstruct i2c_board_info info;\n\tstruct i2c_adapter *adap = &itv->i2c_adap;\n\tstruct IR_i2c_init_data *init_data = &itv->ir_i2c_init_data;\n\tunsigned short addr_list[2] = { addr, I2C_CLIENT_END };\n\n\t \n\tif (itv->hw_flags & IVTV_HW_IR_ANY)\n\t\treturn -1;\n\n\t \n\tswitch (hw) {\n\tcase IVTV_HW_I2C_IR_RX_AVER:\n\t\tinit_data->ir_codes = RC_MAP_AVERMEDIA_CARDBUS;\n\t\tinit_data->internal_get_key_func =\n\t\t\t\t\tIR_KBD_GET_KEY_AVERMEDIA_CARDBUS;\n\t\tinit_data->type = RC_PROTO_BIT_OTHER;\n\t\tinit_data->name = \"AVerMedia AVerTV card\";\n\t\tbreak;\n\tcase IVTV_HW_I2C_IR_RX_HAUP_EXT:\n\tcase IVTV_HW_I2C_IR_RX_HAUP_INT:\n\t\tinit_data->ir_codes = RC_MAP_HAUPPAUGE;\n\t\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP;\n\t\tinit_data->type = RC_PROTO_BIT_RC5;\n\t\tinit_data->name = itv->card_name;\n\t\tbreak;\n\tcase IVTV_HW_Z8F0811_IR_HAUP:\n\t\t \n\t\tinit_data->ir_codes = RC_MAP_HAUPPAUGE;\n\t\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\t\tinit_data->type = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t\t\tRC_PROTO_BIT_RC6_6A_32;\n\t\tinit_data->name = itv->card_name;\n\t\tbreak;\n\tcase IVTV_HW_I2C_IR_RX_ADAPTEC:\n\t\tinit_data->get_key = get_key_adaptec;\n\t\tinit_data->name = itv->card_name;\n\t\t \n\t\tinit_data->ir_codes = RC_MAP_EMPTY;\n\t\tinit_data->type = RC_PROTO_BIT_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tinfo.platform_data = init_data;\n\tstrscpy(info.type, type, I2C_NAME_SIZE);\n\n\treturn IS_ERR(i2c_new_scanned_device(adap, &info, addr_list, NULL)) ?\n\t       -1 : 0;\n}\n\n \nvoid ivtv_i2c_new_ir_legacy(struct ivtv *itv)\n{\n\tstruct i2c_board_info info;\n\t \n\tstatic const unsigned short addr_list[] = {\n\t\t0x1a,\t \n\t\t0x18,\t \n\t\tI2C_CLIENT_END\n\t};\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\ti2c_new_scanned_device(&itv->i2c_adap, &info, addr_list, NULL);\n}\n\nint ivtv_i2c_register(struct ivtv *itv, unsigned idx)\n{\n\tstruct i2c_adapter *adap = &itv->i2c_adap;\n\tstruct v4l2_subdev *sd;\n\tconst char *type;\n\tu32 hw;\n\n\tif (idx >= IVTV_HW_MAX_BITS)\n\t\treturn -ENODEV;\n\n\ttype = hw_devicenames[idx];\n\thw = 1 << idx;\n\n\tif (hw == IVTV_HW_TUNER) {\n\t\t \n\t\tsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\n\t\t\t\titv->card_i2c->radio);\n\t\tif (sd)\n\t\t\tsd->grp_id = 1 << idx;\n\t\tsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\n\t\t\t\titv->card_i2c->demod);\n\t\tif (sd)\n\t\t\tsd->grp_id = 1 << idx;\n\t\tsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\n\t\t\t\titv->card_i2c->tv);\n\t\tif (sd)\n\t\t\tsd->grp_id = 1 << idx;\n\t\treturn sd ? 0 : -1;\n\t}\n\n\tif (hw & IVTV_HW_IR_ANY)\n\t\treturn ivtv_i2c_new_ir(itv, hw, type, hw_addrs[idx]);\n\n\t \n\tif (!hw_addrs[idx])\n\t\treturn -1;\n\n\t \n\tif (hw == IVTV_HW_UPD64031A || hw == IVTV_HW_UPD6408X) {\n\t\tsd = v4l2_i2c_new_subdev(&itv->v4l2_dev,\n\t\t\t\tadap, type, 0, I2C_ADDRS(hw_addrs[idx]));\n\t} else if (hw == IVTV_HW_CX25840) {\n\t\tstruct cx25840_platform_data pdata;\n\t\tstruct i2c_board_info cx25840_info = {\n\t\t\t.type = \"cx25840\",\n\t\t\t.addr = hw_addrs[idx],\n\t\t\t.platform_data = &pdata,\n\t\t};\n\n\t\tmemset(&pdata, 0, sizeof(pdata));\n\t\tpdata.pvr150_workaround = itv->pvr150_workaround;\n\t\tsd = v4l2_i2c_new_subdev_board(&itv->v4l2_dev, adap,\n\t\t\t\t&cx25840_info, NULL);\n\t} else {\n\t\tsd = v4l2_i2c_new_subdev(&itv->v4l2_dev,\n\t\t\t\tadap, type, hw_addrs[idx], NULL);\n\t}\n\tif (sd)\n\t\tsd->grp_id = 1 << idx;\n\treturn sd ? 0 : -1;\n}\n\nstruct v4l2_subdev *ivtv_find_hw(struct ivtv *itv, u32 hw)\n{\n\tstruct v4l2_subdev *result = NULL;\n\tstruct v4l2_subdev *sd;\n\n\tspin_lock(&itv->v4l2_dev.lock);\n\tv4l2_device_for_each_subdev(sd, &itv->v4l2_dev) {\n\t\tif (sd->grp_id == hw) {\n\t\t\tresult = sd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&itv->v4l2_dev.lock);\n\treturn result;\n}\n\n \nstatic void ivtv_setscl(struct ivtv *itv, int state)\n{\n\t \n\t \n\twrite_reg(~state, IVTV_REG_I2C_SETSCL_OFFSET);\n}\n\n \nstatic void ivtv_setsda(struct ivtv *itv, int state)\n{\n\t \n\t \n\twrite_reg(~state & 1, IVTV_REG_I2C_SETSDA_OFFSET);\n}\n\n \nstatic int ivtv_getscl(struct ivtv *itv)\n{\n\treturn read_reg(IVTV_REG_I2C_GETSCL_OFFSET) & 1;\n}\n\n \nstatic int ivtv_getsda(struct ivtv *itv)\n{\n\treturn read_reg(IVTV_REG_I2C_GETSDA_OFFSET) & 1;\n}\n\n \nstatic void ivtv_scldelay(struct ivtv *itv)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; ++i)\n\t\tivtv_getscl(itv);\n}\n\n \nstatic int ivtv_waitscl(struct ivtv *itv, int val)\n{\n\tint i;\n\n\tivtv_scldelay(itv);\n\tfor (i = 0; i < 1000; ++i) {\n\t\tif (ivtv_getscl(itv) == val)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int ivtv_waitsda(struct ivtv *itv, int val)\n{\n\tint i;\n\n\tivtv_scldelay(itv);\n\tfor (i = 0; i < 1000; ++i) {\n\t\tif (ivtv_getsda(itv) == val)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int ivtv_ack(struct ivtv *itv)\n{\n\tint ret = 0;\n\n\tif (ivtv_getscl(itv) == 1) {\n\t\tIVTV_DEBUG_HI_I2C(\"SCL was high starting an ack\\n\");\n\t\tivtv_setscl(itv, 0);\n\t\tif (!ivtv_waitscl(itv, 0)) {\n\t\t\tIVTV_DEBUG_I2C(\"Could not set SCL low starting an ack\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tivtv_setsda(itv, 1);\n\tivtv_scldelay(itv);\n\tivtv_setscl(itv, 1);\n\tif (!ivtv_waitsda(itv, 0)) {\n\t\tIVTV_DEBUG_I2C(\"Slave did not ack\\n\");\n\t\tret = -EREMOTEIO;\n\t}\n\tivtv_setscl(itv, 0);\n\tif (!ivtv_waitscl(itv, 0)) {\n\t\tIVTV_DEBUG_I2C(\"Failed to set SCL low after ACK\\n\");\n\t\tret = -EREMOTEIO;\n\t}\n\treturn ret;\n}\n\n \nstatic int ivtv_sendbyte(struct ivtv *itv, unsigned char byte)\n{\n\tint i, bit;\n\n\tIVTV_DEBUG_HI_I2C(\"write %x\\n\",byte);\n\tfor (i = 0; i < 8; ++i, byte<<=1) {\n\t\tivtv_setscl(itv, 0);\n\t\tif (!ivtv_waitscl(itv, 0)) {\n\t\t\tIVTV_DEBUG_I2C(\"Error setting SCL low\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tbit = (byte>>7)&1;\n\t\tivtv_setsda(itv, bit);\n\t\tif (!ivtv_waitsda(itv, bit)) {\n\t\t\tIVTV_DEBUG_I2C(\"Error setting SDA\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tivtv_setscl(itv, 1);\n\t\tif (!ivtv_waitscl(itv, 1)) {\n\t\t\tIVTV_DEBUG_I2C(\"Slave not ready for bit\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tivtv_setscl(itv, 0);\n\tif (!ivtv_waitscl(itv, 0)) {\n\t\tIVTV_DEBUG_I2C(\"Error setting SCL low\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn ivtv_ack(itv);\n}\n\n \nstatic int ivtv_readbyte(struct ivtv *itv, unsigned char *byte, int nack)\n{\n\tint i;\n\n\t*byte = 0;\n\n\tivtv_setsda(itv, 1);\n\tivtv_scldelay(itv);\n\tfor (i = 0; i < 8; ++i) {\n\t\tivtv_setscl(itv, 0);\n\t\tivtv_scldelay(itv);\n\t\tivtv_setscl(itv, 1);\n\t\tif (!ivtv_waitscl(itv, 1)) {\n\t\t\tIVTV_DEBUG_I2C(\"Error setting SCL high\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\t*byte = ((*byte)<<1)|ivtv_getsda(itv);\n\t}\n\tivtv_setscl(itv, 0);\n\tivtv_scldelay(itv);\n\tivtv_setsda(itv, nack);\n\tivtv_scldelay(itv);\n\tivtv_setscl(itv, 1);\n\tivtv_scldelay(itv);\n\tivtv_setscl(itv, 0);\n\tivtv_scldelay(itv);\n\tIVTV_DEBUG_HI_I2C(\"read %x\\n\",*byte);\n\treturn 0;\n}\n\n \nstatic int ivtv_start(struct ivtv *itv)\n{\n\tint sda;\n\n\tsda = ivtv_getsda(itv);\n\tif (sda != 1) {\n\t\tIVTV_DEBUG_HI_I2C(\"SDA was low at start\\n\");\n\t\tivtv_setsda(itv, 1);\n\t\tif (!ivtv_waitsda(itv, 1)) {\n\t\t\tIVTV_DEBUG_I2C(\"SDA stuck low\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tif (ivtv_getscl(itv) != 1) {\n\t\tivtv_setscl(itv, 1);\n\t\tif (!ivtv_waitscl(itv, 1)) {\n\t\t\tIVTV_DEBUG_I2C(\"SCL stuck low at start\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tivtv_setsda(itv, 0);\n\tivtv_scldelay(itv);\n\treturn 0;\n}\n\n \nstatic int ivtv_stop(struct ivtv *itv)\n{\n\tint i;\n\n\tif (ivtv_getscl(itv) != 0) {\n\t\tIVTV_DEBUG_HI_I2C(\"SCL not low when stopping\\n\");\n\t\tivtv_setscl(itv, 0);\n\t\tif (!ivtv_waitscl(itv, 0)) {\n\t\t\tIVTV_DEBUG_I2C(\"SCL could not be set low\\n\");\n\t\t}\n\t}\n\tivtv_setsda(itv, 0);\n\tivtv_scldelay(itv);\n\tivtv_setscl(itv, 1);\n\tif (!ivtv_waitscl(itv, 1)) {\n\t\tIVTV_DEBUG_I2C(\"SCL could not be set high\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\tivtv_scldelay(itv);\n\tivtv_setsda(itv, 1);\n\tif (!ivtv_waitsda(itv, 1)) {\n\t\tIVTV_DEBUG_I2C(\"resetting I2C\\n\");\n\t\tfor (i = 0; i < 16; ++i) {\n\t\t\tivtv_setscl(itv, 0);\n\t\t\tivtv_scldelay(itv);\n\t\t\tivtv_setscl(itv, 1);\n\t\t\tivtv_scldelay(itv);\n\t\t\tivtv_setsda(itv, 1);\n\t\t}\n\t\tivtv_waitsda(itv, 1);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int ivtv_write(struct ivtv *itv, unsigned char addr, unsigned char *data, u32 len, int do_stop)\n{\n\tint retry, ret = -EREMOTEIO;\n\tu32 i;\n\n\tfor (retry = 0; ret != 0 && retry < 8; ++retry) {\n\t\tret = ivtv_start(itv);\n\n\t\tif (ret == 0) {\n\t\t\tret = ivtv_sendbyte(itv, addr<<1);\n\t\t\tfor (i = 0; ret == 0 && i < len; ++i)\n\t\t\t\tret = ivtv_sendbyte(itv, data[i]);\n\t\t}\n\t\tif (ret != 0 || do_stop) {\n\t\t\tivtv_stop(itv);\n\t\t}\n\t}\n\tif (ret)\n\t\tIVTV_DEBUG_I2C(\"i2c write to %x failed\\n\", addr);\n\treturn ret;\n}\n\n \nstatic int ivtv_read(struct ivtv *itv, unsigned char addr, unsigned char *data, u32 len)\n{\n\tint retry, ret = -EREMOTEIO;\n\tu32 i;\n\n\tfor (retry = 0; ret != 0 && retry < 8; ++retry) {\n\t\tret = ivtv_start(itv);\n\t\tif (ret == 0)\n\t\t\tret = ivtv_sendbyte(itv, (addr << 1) | 1);\n\t\tfor (i = 0; ret == 0 && i < len; ++i) {\n\t\t\tret = ivtv_readbyte(itv, &data[i], i == len - 1);\n\t\t}\n\t\tivtv_stop(itv);\n\t}\n\tif (ret)\n\t\tIVTV_DEBUG_I2C(\"i2c read from %x failed\\n\", addr);\n\treturn ret;\n}\n\n \nstatic int ivtv_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\n{\n\tstruct v4l2_device *v4l2_dev = i2c_get_adapdata(i2c_adap);\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tint retval;\n\tint i;\n\n\tmutex_lock(&itv->i2c_bus_lock);\n\tfor (i = retval = 0; retval == 0 && i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tretval = ivtv_read(itv, msgs[i].addr, msgs[i].buf, msgs[i].len);\n\t\telse {\n\t\t\t \n\t\t\tint stop = !(i + 1 < num && msgs[i + 1].flags == I2C_M_RD);\n\n\t\t\tretval = ivtv_write(itv, msgs[i].addr, msgs[i].buf, msgs[i].len, stop);\n\t\t}\n\t}\n\tmutex_unlock(&itv->i2c_bus_lock);\n\treturn retval ? retval : num;\n}\n\n \nstatic u32 ivtv_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm ivtv_algo = {\n\t.master_xfer   = ivtv_xfer,\n\t.functionality = ivtv_functionality,\n};\n\n \nstatic const struct i2c_adapter ivtv_i2c_adap_hw_template = {\n\t.name = \"ivtv i2c driver\",\n\t.algo = &ivtv_algo,\n\t.algo_data = NULL,\t\t\t \n\t.owner = THIS_MODULE,\n};\n\nstatic void ivtv_setscl_old(void *data, int state)\n{\n\tstruct ivtv *itv = (struct ivtv *)data;\n\n\tif (state)\n\t\titv->i2c_state |= 0x01;\n\telse\n\t\titv->i2c_state &= ~0x01;\n\n\t \n\t \n\twrite_reg(~itv->i2c_state, IVTV_REG_I2C_SETSCL_OFFSET);\n}\n\nstatic void ivtv_setsda_old(void *data, int state)\n{\n\tstruct ivtv *itv = (struct ivtv *)data;\n\n\tif (state)\n\t\titv->i2c_state |= 0x01;\n\telse\n\t\titv->i2c_state &= ~0x01;\n\n\t \n\t \n\twrite_reg(~itv->i2c_state, IVTV_REG_I2C_SETSDA_OFFSET);\n}\n\nstatic int ivtv_getscl_old(void *data)\n{\n\tstruct ivtv *itv = (struct ivtv *)data;\n\n\treturn read_reg(IVTV_REG_I2C_GETSCL_OFFSET) & 1;\n}\n\nstatic int ivtv_getsda_old(void *data)\n{\n\tstruct ivtv *itv = (struct ivtv *)data;\n\n\treturn read_reg(IVTV_REG_I2C_GETSDA_OFFSET) & 1;\n}\n\n \nstatic const struct i2c_adapter ivtv_i2c_adap_template = {\n\t.name = \"ivtv i2c driver\",\n\t.algo = NULL,                    \n\t.algo_data = NULL,               \n\t.owner = THIS_MODULE,\n};\n\n#define IVTV_ALGO_BIT_TIMEOUT\t(2)\t \n\nstatic const struct i2c_algo_bit_data ivtv_i2c_algo_template = {\n\t.setsda\t\t= ivtv_setsda_old,\n\t.setscl\t\t= ivtv_setscl_old,\n\t.getsda\t\t= ivtv_getsda_old,\n\t.getscl\t\t= ivtv_getscl_old,\n\t.udelay\t\t= IVTV_DEFAULT_I2C_CLOCK_PERIOD / 2,   \n\t.timeout\t= IVTV_ALGO_BIT_TIMEOUT * HZ,          \n};\n\nstatic const struct i2c_client ivtv_i2c_client_template = {\n\t.name = \"ivtv internal\",\n};\n\n \nint init_ivtv_i2c(struct ivtv *itv)\n{\n\tint retval;\n\n\tIVTV_DEBUG_I2C(\"i2c init\\n\");\n\n\t \n\tif (ARRAY_SIZE(hw_devicenames) != ARRAY_SIZE(hw_addrs)) {\n\t\tIVTV_ERR(\"Mismatched I2C hardware arrays\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (itv->options.newi2c > 0) {\n\t\titv->i2c_adap = ivtv_i2c_adap_hw_template;\n\t} else {\n\t\titv->i2c_adap = ivtv_i2c_adap_template;\n\t\titv->i2c_algo = ivtv_i2c_algo_template;\n\t}\n\titv->i2c_algo.udelay = itv->options.i2c_clock_period / 2;\n\titv->i2c_algo.data = itv;\n\titv->i2c_adap.algo_data = &itv->i2c_algo;\n\n\tsprintf(itv->i2c_adap.name + strlen(itv->i2c_adap.name), \" #%d\",\n\t\titv->instance);\n\ti2c_set_adapdata(&itv->i2c_adap, &itv->v4l2_dev);\n\n\titv->i2c_client = ivtv_i2c_client_template;\n\titv->i2c_client.adapter = &itv->i2c_adap;\n\titv->i2c_adap.dev.parent = &itv->pdev->dev;\n\n\tIVTV_DEBUG_I2C(\"setting scl and sda to 1\\n\");\n\tivtv_setscl(itv, 1);\n\tivtv_setsda(itv, 1);\n\n\tif (itv->options.newi2c > 0)\n\t\tretval = i2c_add_adapter(&itv->i2c_adap);\n\telse\n\t\tretval = i2c_bit_add_bus(&itv->i2c_adap);\n\n\treturn retval;\n}\n\nvoid exit_ivtv_i2c(struct ivtv *itv)\n{\n\tIVTV_DEBUG_I2C(\"i2c exit\\n\");\n\n\ti2c_del_adapter(&itv->i2c_adap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}