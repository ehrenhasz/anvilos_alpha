{
  "module_name": "ivtv-alsa-pcm.c",
  "hash_id": "1a08a7f781716f3ef9e4c2eceef0b2c66f86f468c56ea1fbbf8bc916cc0494a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-alsa-pcm.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-streams.h\"\n#include \"ivtv-fileops.h\"\n#include \"ivtv-alsa.h\"\n#include \"ivtv-alsa-pcm.h\"\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n\nstatic unsigned int pcm_debug;\nmodule_param(pcm_debug, int, 0644);\nMODULE_PARM_DESC(pcm_debug, \"enable debug messages for pcm\");\n\n#define dprintk(fmt, arg...) \\\n\tdo { \\\n\t\tif (pcm_debug) \\\n\t\t\tpr_info(\"ivtv-alsa-pcm %s: \" fmt, __func__, ##arg); \\\n\t} while (0)\n\nstatic const struct snd_pcm_hardware snd_ivtv_hw_capture = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP           |\n\t\tSNDRV_PCM_INFO_INTERLEAVED    |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 62720 * 8,\t \n\t.period_bytes_min = 64,\t\t \n\t.period_bytes_max = 12544,\n\t.periods_min = 2,\n\t.periods_max = 98,\t\t \n};\n\nstatic void ivtv_alsa_announce_pcm_data(struct snd_ivtv_card *itvsc,\n\t\t\t\t\tu8 *pcm_data,\n\t\t\t\t\tsize_t num_bytes)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int oldptr;\n\tunsigned int stride;\n\tint period_elapsed = 0;\n\tint length;\n\n\tdprintk(\"ivtv alsa announce ptr=%p data=%p num_bytes=%zu\\n\", itvsc,\n\t\tpcm_data, num_bytes);\n\n\tsubstream = itvsc->capture_pcm_substream;\n\tif (substream == NULL) {\n\t\tdprintk(\"substream was NULL\\n\");\n\t\treturn;\n\t}\n\n\truntime = substream->runtime;\n\tif (runtime == NULL) {\n\t\tdprintk(\"runtime was NULL\\n\");\n\t\treturn;\n\t}\n\n\tstride = runtime->frame_bits >> 3;\n\tif (stride == 0) {\n\t\tdprintk(\"stride is zero\\n\");\n\t\treturn;\n\t}\n\n\tlength = num_bytes / stride;\n\tif (length == 0) {\n\t\tdprintk(\"%s: length was zero\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (runtime->dma_area == NULL) {\n\t\tdprintk(\"dma area was NULL - ignoring\\n\");\n\t\treturn;\n\t}\n\n\toldptr = itvsc->hwptr_done_capture;\n\tif (oldptr + length >= runtime->buffer_size) {\n\t\tunsigned int cnt =\n\t\t\truntime->buffer_size - oldptr;\n\t\tmemcpy(runtime->dma_area + oldptr * stride, pcm_data,\n\t\t       cnt * stride);\n\t\tmemcpy(runtime->dma_area, pcm_data + cnt * stride,\n\t\t       length * stride - cnt * stride);\n\t} else {\n\t\tmemcpy(runtime->dma_area + oldptr * stride, pcm_data,\n\t\t       length * stride);\n\t}\n\tsnd_pcm_stream_lock(substream);\n\n\titvsc->hwptr_done_capture += length;\n\tif (itvsc->hwptr_done_capture >=\n\t    runtime->buffer_size)\n\t\titvsc->hwptr_done_capture -=\n\t\t\truntime->buffer_size;\n\n\titvsc->capture_transfer_done += length;\n\tif (itvsc->capture_transfer_done >=\n\t    runtime->period_size) {\n\t\titvsc->capture_transfer_done -=\n\t\t\truntime->period_size;\n\t\tperiod_elapsed = 1;\n\t}\n\n\tsnd_pcm_stream_unlock(substream);\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int snd_ivtv_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ivtv_card *itvsc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct v4l2_device *v4l2_dev = itvsc->v4l2_dev;\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tstruct ivtv_stream *s;\n\tstruct ivtv_open_id item;\n\tint ret;\n\n\t \n\tsnd_ivtv_lock(itvsc);\n\n\tif (ivtv_init_on_first_open(itv)) {\n\t\tsnd_ivtv_unlock(itvsc);\n\t\treturn -ENXIO;\n\t}\n\n\ts = &itv->streams[IVTV_ENC_STREAM_TYPE_PCM];\n\n\tv4l2_fh_init(&item.fh, &s->vdev);\n\titem.itv = itv;\n\titem.type = s->type;\n\n\t \n\tif (ivtv_claim_stream(&item, item.type)) {\n\t\t \n\t\tv4l2_fh_exit(&item.fh);\n\t\tsnd_ivtv_unlock(itvsc);\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(IVTV_F_S_STREAMOFF, &s->s_flags) ||\n\t    test_and_set_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\t \n\t\tsnd_ivtv_unlock(itvsc);\n\t\treturn 0;\n\t}\n\n\n\truntime->hw = snd_ivtv_hw_capture;\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\titvsc->capture_pcm_substream = substream;\n\truntime->private_data = itv;\n\n\titv->pcm_announce_callback = ivtv_alsa_announce_pcm_data;\n\n\t \n\tset_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\tret = ivtv_start_v4l2_encode_stream(s);\n\tsnd_ivtv_unlock(itvsc);\n\n\treturn ret;\n}\n\nstatic int snd_ivtv_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ivtv_card *itvsc = snd_pcm_substream_chip(substream);\n\tstruct v4l2_device *v4l2_dev = itvsc->v4l2_dev;\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tstruct ivtv_stream *s;\n\n\t \n\tsnd_ivtv_lock(itvsc);\n\ts = &itv->streams[IVTV_ENC_STREAM_TYPE_PCM];\n\tivtv_stop_v4l2_encode_stream(s, 0);\n\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\n\tivtv_release_stream(s);\n\n\titv->pcm_announce_callback = NULL;\n\tsnd_ivtv_unlock(itvsc);\n\n\treturn 0;\n}\n\nstatic int snd_ivtv_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ivtv_card *itvsc = snd_pcm_substream_chip(substream);\n\n\titvsc->hwptr_done_capture = 0;\n\titvsc->capture_transfer_done = 0;\n\n\treturn 0;\n}\n\nstatic int snd_ivtv_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\treturn 0;\n}\n\nstatic\nsnd_pcm_uframes_t snd_ivtv_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_pcm_uframes_t hwptr_done;\n\tstruct snd_ivtv_card *itvsc = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irqsave(&itvsc->slock, flags);\n\thwptr_done = itvsc->hwptr_done_capture;\n\tspin_unlock_irqrestore(&itvsc->slock, flags);\n\n\treturn hwptr_done;\n}\n\nstatic const struct snd_pcm_ops snd_ivtv_pcm_capture_ops = {\n\t.open\t\t= snd_ivtv_pcm_capture_open,\n\t.close\t\t= snd_ivtv_pcm_capture_close,\n\t.prepare\t= snd_ivtv_pcm_prepare,\n\t.trigger\t= snd_ivtv_pcm_trigger,\n\t.pointer\t= snd_ivtv_pcm_pointer,\n};\n\nint snd_ivtv_pcm_create(struct snd_ivtv_card *itvsc)\n{\n\tstruct snd_pcm *sp;\n\tstruct snd_card *sc = itvsc->sc;\n\tstruct v4l2_device *v4l2_dev = itvsc->v4l2_dev;\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tint ret;\n\n\tret = snd_pcm_new(sc, \"CX2341[56] PCM\",\n\t\t\t  0,  \n\t\t\t  0,  \n\t\t\t  1,  \n\t\t\t  &sp);\n\tif (ret) {\n\t\tIVTV_ALSA_ERR(\"%s: snd_ivtv_pcm_create() failed with err %d\\n\",\n\t\t\t      __func__, ret);\n\t\tgoto err_exit;\n\t}\n\n\tspin_lock_init(&itvsc->slock);\n\n\tsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_ivtv_pcm_capture_ops);\n\tsnd_pcm_set_managed_buffer_all(sp, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\tsp->info_flags = 0;\n\tsp->private_data = itvsc;\n\tstrscpy(sp->name, itv->card_name, sizeof(sp->name));\n\n\treturn 0;\n\nerr_exit:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}