{
  "module_name": "ivtv-gpio.c",
  "hash_id": "6a80fad59f426fe0013dbfbe9ba85dab40c89252fd82cbd6117852ed29dc6210",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-gpio.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-gpio.h\"\n#include \"xc2028.h\"\n#include <media/tuner.h>\n#include <media/v4l2-ctrls.h>\n\n \n\n \n\n \n#define IVTV_REG_GPIO_IN    0x9008\n#define IVTV_REG_GPIO_OUT   0x900c\n#define IVTV_REG_GPIO_DIR   0x9020\n\nvoid ivtv_reset_ir_gpio(struct ivtv *itv)\n{\n\tint curdir, curout;\n\n\tif (itv->card->type != IVTV_CARD_PVR_150)\n\t\treturn;\n\tIVTV_DEBUG_INFO(\"Resetting PVR150 IR\\n\");\n\tcurout = read_reg(IVTV_REG_GPIO_OUT);\n\tcurdir = read_reg(IVTV_REG_GPIO_DIR);\n\tcurdir |= 0x80;\n\twrite_reg(curdir, IVTV_REG_GPIO_DIR);\n\tcurout = (curout & ~0xF) | 1;\n\twrite_reg(curout, IVTV_REG_GPIO_OUT);\n\t \n\tschedule_timeout_interruptible(msecs_to_jiffies(1));\n\tcurout |= 2;\n\twrite_reg(curout, IVTV_REG_GPIO_OUT);\n\tcurdir &= ~0x80;\n\twrite_reg(curdir, IVTV_REG_GPIO_DIR);\n}\n\n \nint ivtv_reset_tuner_gpio(void *dev, int component, int cmd, int value)\n{\n\tstruct i2c_algo_bit_data *algo = dev;\n\tstruct ivtv *itv = algo->data;\n\tu32 curout;\n\n\tif (cmd != XC2028_TUNER_RESET)\n\t\treturn 0;\n\tIVTV_DEBUG_INFO(\"Resetting tuner\\n\");\n\tcurout = read_reg(IVTV_REG_GPIO_OUT);\n\tcurout &= ~(1 << itv->card->xceive_pin);\n\twrite_reg(curout, IVTV_REG_GPIO_OUT);\n\tschedule_timeout_interruptible(msecs_to_jiffies(1));\n\n\tcurout |= 1 << itv->card->xceive_pin;\n\twrite_reg(curout, IVTV_REG_GPIO_OUT);\n\tschedule_timeout_interruptible(msecs_to_jiffies(1));\n\treturn 0;\n}\n\nstatic inline struct ivtv *sd_to_ivtv(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ivtv, sd_gpio);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ivtv, hdl_gpio)->sd_gpio;\n}\n\nstatic int subdev_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tmask = itv->card->gpio_audio_freq.mask;\n\tswitch (freq) {\n\tcase 32000:\n\t\tdata = itv->card->gpio_audio_freq.f32000;\n\t\tbreak;\n\tcase 44100:\n\t\tdata = itv->card->gpio_audio_freq.f44100;\n\t\tbreak;\n\tcase 48000:\n\tdefault:\n\t\tdata = itv->card->gpio_audio_freq.f48000;\n\t\tbreak;\n\t}\n\tif (mask)\n\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) | (data & mask), IVTV_REG_GPIO_OUT);\n\treturn 0;\n}\n\nstatic int subdev_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask;\n\n\tmask = itv->card->gpio_audio_detect.mask;\n\tif (mask == 0 || (read_reg(IVTV_REG_GPIO_IN) & mask))\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_STEREO |\n\t\t\tV4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\telse\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_MONO;\n\treturn 0;\n}\n\nstatic int subdev_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tmask = itv->card->gpio_audio_mode.mask;\n\tswitch (vt->audmode) {\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tdata = itv->card->gpio_audio_mode.lang1;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\tdata = itv->card->gpio_audio_mode.lang2;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tdata = itv->card->gpio_audio_mode.mono;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\tdefault:\n\t\tdata = itv->card->gpio_audio_mode.stereo;\n\t\tbreak;\n\t}\n\tif (mask)\n\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) | (data & mask), IVTV_REG_GPIO_OUT);\n\treturn 0;\n}\n\nstatic int subdev_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tmask = itv->card->gpio_audio_input.mask;\n\tdata = itv->card->gpio_audio_input.radio;\n\tif (mask)\n\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) | (data & mask), IVTV_REG_GPIO_OUT);\n\treturn 0;\n}\n\nstatic int subdev_s_audio_routing(struct v4l2_subdev *sd,\n\t\t\t\t  u32 input, u32 output, u32 config)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tif (input > 2)\n\t\treturn -EINVAL;\n\tmask = itv->card->gpio_audio_input.mask;\n\tswitch (input) {\n\tcase 0:\n\t\tdata = itv->card->gpio_audio_input.tuner;\n\t\tbreak;\n\tcase 1:\n\t\tdata = itv->card->gpio_audio_input.linein;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tdata = itv->card->gpio_audio_input.radio;\n\t\tbreak;\n\t}\n\tif (mask)\n\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) | (data & mask), IVTV_REG_GPIO_OUT);\n\treturn 0;\n}\n\nstatic int subdev_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tmask = itv->card->gpio_audio_mute.mask;\n\t\tdata = ctrl->val ? itv->card->gpio_audio_mute.mute : 0;\n\t\tif (mask)\n\t\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) |\n\t\t\t\t\t(data & mask), IVTV_REG_GPIO_OUT);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic int subdev_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\n\tIVTV_INFO(\"GPIO status: DIR=0x%04x OUT=0x%04x IN=0x%04x\\n\",\n\t\t\tread_reg(IVTV_REG_GPIO_DIR), read_reg(IVTV_REG_GPIO_OUT),\n\t\t\tread_reg(IVTV_REG_GPIO_IN));\n\tv4l2_ctrl_handler_log_status(&itv->hdl_gpio, sd->name);\n\treturn 0;\n}\n\nstatic int subdev_s_video_routing(struct v4l2_subdev *sd,\n\t\t\t\t  u32 input, u32 output, u32 config)\n{\n\tstruct ivtv *itv = sd_to_ivtv(sd);\n\tu16 mask, data;\n\n\tif (input > 2)  \n\t\treturn -EINVAL;\n\tmask = itv->card->gpio_video_input.mask;\n\tif (input == 0)\n\t\tdata = itv->card->gpio_video_input.tuner;\n\telse if (input == 1)\n\t\tdata = itv->card->gpio_video_input.composite;\n\telse\n\t\tdata = itv->card->gpio_video_input.svideo;\n\tif (mask)\n\t\twrite_reg((read_reg(IVTV_REG_GPIO_OUT) & ~mask) | (data & mask), IVTV_REG_GPIO_OUT);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops gpio_ctrl_ops = {\n\t.s_ctrl = subdev_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops subdev_core_ops = {\n\t.log_status = subdev_log_status,\n};\n\nstatic const struct v4l2_subdev_tuner_ops subdev_tuner_ops = {\n\t.s_radio = subdev_s_radio,\n\t.g_tuner = subdev_g_tuner,\n\t.s_tuner = subdev_s_tuner,\n};\n\nstatic const struct v4l2_subdev_audio_ops subdev_audio_ops = {\n\t.s_clock_freq = subdev_s_clock_freq,\n\t.s_routing = subdev_s_audio_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops subdev_video_ops = {\n\t.s_routing = subdev_s_video_routing,\n};\n\nstatic const struct v4l2_subdev_ops subdev_ops = {\n\t.core = &subdev_core_ops,\n\t.tuner = &subdev_tuner_ops,\n\t.audio = &subdev_audio_ops,\n\t.video = &subdev_video_ops,\n};\n\nint ivtv_gpio_init(struct ivtv *itv)\n{\n\tu16 pin = 0;\n\n\tif (itv->card->xceive_pin)\n\t\tpin = 1 << itv->card->xceive_pin;\n\n\tif ((itv->card->gpio_init.direction | pin) == 0)\n\t\treturn 0;\n\n\tIVTV_DEBUG_INFO(\"GPIO initial dir: %08x out: %08x\\n\",\n\t\t   read_reg(IVTV_REG_GPIO_DIR), read_reg(IVTV_REG_GPIO_OUT));\n\n\t \n\twrite_reg(itv->card->gpio_init.initial_value | pin, IVTV_REG_GPIO_OUT);\n\twrite_reg(itv->card->gpio_init.direction | pin, IVTV_REG_GPIO_DIR);\n\tv4l2_subdev_init(&itv->sd_gpio, &subdev_ops);\n\tsnprintf(itv->sd_gpio.name, sizeof(itv->sd_gpio.name), \"%s-gpio\", itv->v4l2_dev.name);\n\titv->sd_gpio.grp_id = IVTV_HW_GPIO;\n\tv4l2_ctrl_handler_init(&itv->hdl_gpio, 1);\n\tv4l2_ctrl_new_std(&itv->hdl_gpio, &gpio_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tif (itv->hdl_gpio.error)\n\t\treturn itv->hdl_gpio.error;\n\titv->sd_gpio.ctrl_handler = &itv->hdl_gpio;\n\tv4l2_ctrl_handler_setup(&itv->hdl_gpio);\n\treturn v4l2_device_register_subdev(&itv->v4l2_dev, &itv->sd_gpio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}