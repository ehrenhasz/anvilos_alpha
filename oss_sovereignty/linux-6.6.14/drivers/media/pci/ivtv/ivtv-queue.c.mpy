{
  "module_name": "ivtv-queue.c",
  "hash_id": "1f07551f27e5ec4981c81151b98dd29b12735ee9851b5faec83011b72db28f30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-queue.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-queue.h\"\n\nint ivtv_buf_copy_from_user(struct ivtv_stream *s, struct ivtv_buffer *buf, const char __user *src, int copybytes)\n{\n\tif (s->buf_size - buf->bytesused < copybytes)\n\t\tcopybytes = s->buf_size - buf->bytesused;\n\tif (copy_from_user(buf->buf + buf->bytesused, src, copybytes)) {\n\t\treturn -EFAULT;\n\t}\n\tbuf->bytesused += copybytes;\n\treturn copybytes;\n}\n\nvoid ivtv_buf_swap(struct ivtv_buffer *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->bytesused; i += 4)\n\t\tswab32s((u32 *)(buf->buf + i));\n}\n\nvoid ivtv_queue_init(struct ivtv_queue *q)\n{\n\tINIT_LIST_HEAD(&q->list);\n\tq->buffers = 0;\n\tq->length = 0;\n\tq->bytesused = 0;\n}\n\nvoid ivtv_enqueue(struct ivtv_stream *s, struct ivtv_buffer *buf, struct ivtv_queue *q)\n{\n\tunsigned long flags;\n\n\t \n\tif (q == &s->q_free) {\n\t\tbuf->bytesused = 0;\n\t\tbuf->readpos = 0;\n\t\tbuf->b_flags = 0;\n\t\tbuf->dma_xfer_cnt = 0;\n\t}\n\tspin_lock_irqsave(&s->qlock, flags);\n\tlist_add_tail(&buf->list, &q->list);\n\tq->buffers++;\n\tq->length += s->buf_size;\n\tq->bytesused += buf->bytesused - buf->readpos;\n\tspin_unlock_irqrestore(&s->qlock, flags);\n}\n\nstruct ivtv_buffer *ivtv_dequeue(struct ivtv_stream *s, struct ivtv_queue *q)\n{\n\tstruct ivtv_buffer *buf = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->qlock, flags);\n\tif (!list_empty(&q->list)) {\n\t\tbuf = list_entry(q->list.next, struct ivtv_buffer, list);\n\t\tlist_del_init(q->list.next);\n\t\tq->buffers--;\n\t\tq->length -= s->buf_size;\n\t\tq->bytesused -= buf->bytesused - buf->readpos;\n\t}\n\tspin_unlock_irqrestore(&s->qlock, flags);\n\treturn buf;\n}\n\nstatic void ivtv_queue_move_buf(struct ivtv_stream *s, struct ivtv_queue *from,\n\t\tstruct ivtv_queue *to, int clear)\n{\n\tstruct ivtv_buffer *buf = list_entry(from->list.next, struct ivtv_buffer, list);\n\n\tlist_move_tail(from->list.next, &to->list);\n\tfrom->buffers--;\n\tfrom->length -= s->buf_size;\n\tfrom->bytesused -= buf->bytesused - buf->readpos;\n\t \n\tif (clear)\n\t\tbuf->bytesused = buf->readpos = buf->b_flags = buf->dma_xfer_cnt = 0;\n\tto->buffers++;\n\tto->length += s->buf_size;\n\tto->bytesused += buf->bytesused - buf->readpos;\n}\n\n \nint ivtv_queue_move(struct ivtv_stream *s, struct ivtv_queue *from, struct ivtv_queue *steal,\n\t\t    struct ivtv_queue *to, int needed_bytes)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\tint from_free = from == &s->q_free;\n\tint to_free = to == &s->q_free;\n\tint bytes_available, bytes_steal;\n\n\tspin_lock_irqsave(&s->qlock, flags);\n\tif (needed_bytes == 0) {\n\t\tfrom_free = 1;\n\t\tneeded_bytes = from->length;\n\t}\n\n\tbytes_available = from_free ? from->length : from->bytesused;\n\tbytes_steal = (from_free && steal) ? steal->length : 0;\n\n\tif (bytes_available + bytes_steal < needed_bytes) {\n\t\tspin_unlock_irqrestore(&s->qlock, flags);\n\t\treturn -ENOMEM;\n\t}\n\twhile (steal && bytes_available < needed_bytes) {\n\t\tstruct ivtv_buffer *buf = list_entry(steal->list.prev, struct ivtv_buffer, list);\n\t\tu16 dma_xfer_cnt = buf->dma_xfer_cnt;\n\n\t\t \n\t\twhile (dma_xfer_cnt == buf->dma_xfer_cnt) {\n\t\t\tlist_move_tail(steal->list.prev, &from->list);\n\t\t\trc++;\n\t\t\tsteal->buffers--;\n\t\t\tsteal->length -= s->buf_size;\n\t\t\tsteal->bytesused -= buf->bytesused - buf->readpos;\n\t\t\tbuf->bytesused = buf->readpos = buf->b_flags = buf->dma_xfer_cnt = 0;\n\t\t\tfrom->buffers++;\n\t\t\tfrom->length += s->buf_size;\n\t\t\tbytes_available += s->buf_size;\n\t\t\tif (list_empty(&steal->list))\n\t\t\t\tbreak;\n\t\t\tbuf = list_entry(steal->list.prev, struct ivtv_buffer, list);\n\t\t}\n\t}\n\tif (from_free) {\n\t\tu32 old_length = to->length;\n\n\t\twhile (to->length - old_length < needed_bytes) {\n\t\t\tivtv_queue_move_buf(s, from, to, 1);\n\t\t}\n\t}\n\telse {\n\t\tu32 old_bytesused = to->bytesused;\n\n\t\twhile (to->bytesused - old_bytesused < needed_bytes) {\n\t\t\tivtv_queue_move_buf(s, from, to, to_free);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&s->qlock, flags);\n\treturn rc;\n}\n\nvoid ivtv_flush_queues(struct ivtv_stream *s)\n{\n\tivtv_queue_move(s, &s->q_io, NULL, &s->q_free, 0);\n\tivtv_queue_move(s, &s->q_full, NULL, &s->q_free, 0);\n\tivtv_queue_move(s, &s->q_dma, NULL, &s->q_free, 0);\n\tivtv_queue_move(s, &s->q_predma, NULL, &s->q_free, 0);\n}\n\nint ivtv_stream_alloc(struct ivtv_stream *s)\n{\n\tstruct ivtv *itv = s->itv;\n\tint SGsize = sizeof(struct ivtv_sg_host_element) * s->buffers;\n\tint i;\n\n\tif (s->buffers == 0)\n\t\treturn 0;\n\n\tIVTV_DEBUG_INFO(\"Allocate %s%s stream: %d x %d buffers (%dkB total)\\n\",\n\t\ts->dma != DMA_NONE ? \"DMA \" : \"\",\n\t\ts->name, s->buffers, s->buf_size, s->buffers * s->buf_size / 1024);\n\n\ts->sg_pending = kzalloc(SGsize, GFP_KERNEL|__GFP_NOWARN);\n\tif (s->sg_pending == NULL) {\n\t\tIVTV_ERR(\"Could not allocate sg_pending for %s stream\\n\", s->name);\n\t\treturn -ENOMEM;\n\t}\n\ts->sg_pending_size = 0;\n\n\ts->sg_processing = kzalloc(SGsize, GFP_KERNEL|__GFP_NOWARN);\n\tif (s->sg_processing == NULL) {\n\t\tIVTV_ERR(\"Could not allocate sg_processing for %s stream\\n\", s->name);\n\t\tkfree(s->sg_pending);\n\t\ts->sg_pending = NULL;\n\t\treturn -ENOMEM;\n\t}\n\ts->sg_processing_size = 0;\n\n\ts->sg_dma = kzalloc(sizeof(struct ivtv_sg_element),\n\t\t\t\t\tGFP_KERNEL|__GFP_NOWARN);\n\tif (s->sg_dma == NULL) {\n\t\tIVTV_ERR(\"Could not allocate sg_dma for %s stream\\n\", s->name);\n\t\tkfree(s->sg_pending);\n\t\ts->sg_pending = NULL;\n\t\tkfree(s->sg_processing);\n\t\ts->sg_processing = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tif (ivtv_might_use_dma(s)) {\n\t\ts->sg_handle = dma_map_single(&itv->pdev->dev, s->sg_dma,\n\t\t\t\t\t      sizeof(struct ivtv_sg_element),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tivtv_stream_sync_for_cpu(s);\n\t}\n\n\t \n\tfor (i = 0; i < s->buffers; i++) {\n\t\tstruct ivtv_buffer *buf = kzalloc(sizeof(struct ivtv_buffer),\n\t\t\t\t\t\tGFP_KERNEL|__GFP_NOWARN);\n\n\t\tif (buf == NULL)\n\t\t\tbreak;\n\t\tbuf->buf = kmalloc(s->buf_size + 256, GFP_KERNEL|__GFP_NOWARN);\n\t\tif (buf->buf == NULL) {\n\t\t\tkfree(buf);\n\t\t\tbreak;\n\t\t}\n\t\tINIT_LIST_HEAD(&buf->list);\n\t\tif (ivtv_might_use_dma(s)) {\n\t\t\tbuf->dma_handle = dma_map_single(&s->itv->pdev->dev,\n\t\t\t\tbuf->buf, s->buf_size + 256, s->dma);\n\t\t\tivtv_buf_sync_for_cpu(s, buf);\n\t\t}\n\t\tivtv_enqueue(s, buf, &s->q_free);\n\t}\n\tif (i == s->buffers)\n\t\treturn 0;\n\tIVTV_ERR(\"Couldn't allocate buffers for %s stream\\n\", s->name);\n\tivtv_stream_free(s);\n\treturn -ENOMEM;\n}\n\nvoid ivtv_stream_free(struct ivtv_stream *s)\n{\n\tstruct ivtv_buffer *buf;\n\n\t \n\tivtv_flush_queues(s);\n\n\t \n\twhile ((buf = ivtv_dequeue(s, &s->q_free))) {\n\t\tif (ivtv_might_use_dma(s))\n\t\t\tdma_unmap_single(&s->itv->pdev->dev, buf->dma_handle,\n\t\t\t\t\t s->buf_size + 256, s->dma);\n\t\tkfree(buf->buf);\n\t\tkfree(buf);\n\t}\n\n\t \n\tif (s->sg_dma != NULL) {\n\t\tif (s->sg_handle != IVTV_DMA_UNMAPPED) {\n\t\t\tdma_unmap_single(&s->itv->pdev->dev, s->sg_handle,\n\t\t\t\t\t sizeof(struct ivtv_sg_element),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\ts->sg_handle = IVTV_DMA_UNMAPPED;\n\t\t}\n\t\tkfree(s->sg_pending);\n\t\tkfree(s->sg_processing);\n\t\tkfree(s->sg_dma);\n\t\ts->sg_pending = NULL;\n\t\ts->sg_processing = NULL;\n\t\ts->sg_dma = NULL;\n\t\ts->sg_pending_size = 0;\n\t\ts->sg_processing_size = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}