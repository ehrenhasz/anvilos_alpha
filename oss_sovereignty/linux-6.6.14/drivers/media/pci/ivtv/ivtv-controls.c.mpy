{
  "module_name": "ivtv-controls.c",
  "hash_id": "9976a48009b34d95f33ff22aae96d7646e5713616e130ffe4737cca8d892eda1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-controls.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-controls.h\"\n#include \"ivtv-mailbox.h\"\n\nstatic int ivtv_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl, u32 fmt)\n{\n\tstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\n\n\t \n\tif (fmt && itv->vbi.sliced_mpeg_data[0] == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < IVTV_VBI_FRAMES; i++) {\n\t\t\t \n\t\t\titv->vbi.sliced_mpeg_data[i] = kmalloc(2049, GFP_KERNEL);\n\t\t\tif (itv->vbi.sliced_mpeg_data[i] == NULL) {\n\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\tkfree(itv->vbi.sliced_mpeg_data[i]);\n\t\t\t\t\titv->vbi.sliced_mpeg_data[i] = NULL;\n\t\t\t\t}\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\titv->vbi.insert_mpeg = fmt;\n\n\tif (itv->vbi.insert_mpeg == 0) {\n\t\treturn 0;\n\t}\n\t \n\tif (ivtv_get_service_set(itv->vbi.sliced_in) == 0) {\n\t\tif (itv->is_60hz)\n\t\t\titv->vbi.sliced_in->service_set = V4L2_SLICED_CAPTION_525;\n\t\telse\n\t\t\titv->vbi.sliced_in->service_set = V4L2_SLICED_WSS_625;\n\t\tivtv_expand_service_set(itv->vbi.sliced_in, itv->is_50hz);\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\n{\n\tstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\n\tint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tformat.format.width = cxhdl->width / (is_mpeg1 ? 2 : 1);\n\tformat.format.height = cxhdl->height;\n\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\tv4l2_subdev_call(itv->sd_video, pad, set_fmt, NULL, &format);\n\treturn 0;\n}\n\nstatic int ivtv_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\n{\n\tstatic const u32 freqs[3] = { 44100, 48000, 32000 };\n\tstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\n\n\t \n\tif (idx < ARRAY_SIZE(freqs))\n\t\tivtv_call_all(itv, audio, s_clock_freq, freqs[idx]);\n\treturn 0;\n}\n\nstatic int ivtv_s_audio_mode(struct cx2341x_handler *cxhdl, u32 val)\n{\n\tstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\n\n\titv->dualwatch_stereo_mode = val;\n\treturn 0;\n}\n\nconst struct cx2341x_handler_ops ivtv_cxhdl_ops = {\n\t.s_audio_mode = ivtv_s_audio_mode,\n\t.s_audio_sampling_freq = ivtv_s_audio_sampling_freq,\n\t.s_video_encoding = ivtv_s_video_encoding,\n\t.s_stream_vbi_fmt = ivtv_s_stream_vbi_fmt,\n};\n\nint ivtv_g_pts_frame(struct ivtv *itv, s64 *pts, s64 *frame)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\n\tif (test_bit(IVTV_F_I_VALID_DEC_TIMINGS, &itv->i_flags)) {\n\t\t*pts = (s64)((u64)itv->last_dec_timing[2] << 32) |\n\t\t\t(u64)itv->last_dec_timing[1];\n\t\t*frame = itv->last_dec_timing[0];\n\t\treturn 0;\n\t}\n\t*pts = 0;\n\t*frame = 0;\n\tif (atomic_read(&itv->decoding)) {\n\t\tif (ivtv_api(itv, CX2341X_DEC_GET_TIMING_INFO, 5, data)) {\n\t\t\tIVTV_DEBUG_WARN(\"GET_TIMING: couldn't read clock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmemcpy(itv->last_dec_timing, data, sizeof(itv->last_dec_timing));\n\t\tset_bit(IVTV_F_I_VALID_DEC_TIMINGS, &itv->i_flags);\n\t\t*pts = (s64)((u64) data[2] << 32) | (u64) data[1];\n\t\t*frame = data[0];\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int ivtv_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ivtv *itv = container_of(ctrl->handler, struct ivtv, cxhdl.hdl);\n\n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_MPEG_VIDEO_DEC_PTS:\n\t\treturn ivtv_g_pts_frame(itv, itv->ctrl_pts->p_new.p_s64,\n\t\t\t\t\t     itv->ctrl_frame->p_new.p_s64);\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ivtv *itv = container_of(ctrl->handler, struct ivtv, cxhdl.hdl);\n\n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\n\t\titv->audio_stereo_mode = itv->ctrl_audio_playback->val - 1;\n\t\titv->audio_bilingual_mode = itv->ctrl_audio_multilingual_playback->val - 1;\n\t\tivtv_vapi(itv, CX2341X_DEC_SET_AUDIO_MODE, 2, itv->audio_bilingual_mode, itv->audio_stereo_mode);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nconst struct v4l2_ctrl_ops ivtv_hdl_out_ops = {\n\t.s_ctrl = ivtv_s_ctrl,\n\t.g_volatile_ctrl = ivtv_g_volatile_ctrl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}