{
  "module_name": "ivtvfb.c",
  "hash_id": "9c0b67f72bbc895e32316990d15c0945fba83d6e65054e632500e6462ffbd809",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtvfb.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-i2c.h\"\n#include \"ivtv-udma.h\"\n#include \"ivtv-mailbox.h\"\n#include \"ivtv-firmware.h\"\n\n#include <linux/fb.h>\n#include <linux/ivtvfb.h>\n\n#if defined(CONFIG_X86_64) && !defined(CONFIG_UML)\n#include <asm/memtype.h>\n#endif\n\n \nstatic int ivtvfb_card_id = -1;\nstatic int ivtvfb_debug;\nstatic bool ivtvfb_force_pat = IS_ENABLED(CONFIG_VIDEO_FB_IVTV_FORCE_PAT);\nstatic bool osd_laced;\nstatic int osd_depth;\nstatic int osd_upper;\nstatic int osd_left;\nstatic unsigned int osd_yres;\nstatic unsigned int osd_xres;\n\nmodule_param(ivtvfb_card_id, int, 0444);\nmodule_param_named(debug,ivtvfb_debug, int, 0644);\nmodule_param_named(force_pat, ivtvfb_force_pat, bool, 0644);\nmodule_param(osd_laced, bool, 0444);\nmodule_param(osd_depth, int, 0444);\nmodule_param(osd_upper, int, 0444);\nmodule_param(osd_left, int, 0444);\nmodule_param(osd_yres, uint, 0444);\nmodule_param(osd_xres, uint, 0444);\n\nMODULE_PARM_DESC(ivtvfb_card_id,\n\t\t \"Only use framebuffer of the specified ivtv card (0-31)\\n\"\n\t\t \"\\t\\t\\tdefault -1: initialize all available framebuffers\");\n\nMODULE_PARM_DESC(debug,\n\t\t \"Debug level (bitmask). Default: errors only\\n\"\n\t\t \"\\t\\t\\t(debug = 3 gives full debugging)\");\n\nMODULE_PARM_DESC(force_pat,\n\t\t \"Force initialization on x86 PAT-enabled systems (bool).\\n\");\n\n \n\nMODULE_PARM_DESC(osd_laced,\n\t\t \"Interlaced mode\\n\"\n\t\t \"\\t\\t\\t0=off\\n\"\n\t\t \"\\t\\t\\t1=on\\n\"\n\t\t \"\\t\\t\\tdefault off\");\n\nMODULE_PARM_DESC(osd_depth,\n\t\t \"Bits per pixel - 8, 16, 32\\n\"\n\t\t \"\\t\\t\\tdefault 8\");\n\nMODULE_PARM_DESC(osd_upper,\n\t\t \"Vertical start position\\n\"\n\t\t \"\\t\\t\\tdefault 0 (Centered)\");\n\nMODULE_PARM_DESC(osd_left,\n\t\t \"Horizontal start position\\n\"\n\t\t \"\\t\\t\\tdefault 0 (Centered)\");\n\nMODULE_PARM_DESC(osd_yres,\n\t\t \"Display height\\n\"\n\t\t \"\\t\\t\\tdefault 480 (PAL)\\n\"\n\t\t \"\\t\\t\\t        400 (NTSC)\");\n\nMODULE_PARM_DESC(osd_xres,\n\t\t \"Display width\\n\"\n\t\t \"\\t\\t\\tdefault 640\");\n\nMODULE_AUTHOR(\"Kevin Thayer, Chris Kennedy, Hans Verkuil, John Harvey, Ian Armstrong\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define IVTVFB_DBGFLG_WARN  (1 << 0)\n#define IVTVFB_DBGFLG_INFO  (1 << 1)\n\n#define IVTVFB_DEBUG(x, type, fmt, args...) \\\n\tdo { \\\n\t\tif ((x) & ivtvfb_debug) \\\n\t\t\tprintk(KERN_INFO \"ivtvfb%d \" type \": \" fmt, itv->instance , ## args); \\\n\t} while (0)\n#define IVTVFB_DEBUG_WARN(fmt, args...)  IVTVFB_DEBUG(IVTVFB_DBGFLG_WARN, \"warning\", fmt , ## args)\n#define IVTVFB_DEBUG_INFO(fmt, args...)  IVTVFB_DEBUG(IVTVFB_DBGFLG_INFO, \"info\", fmt , ## args)\n\n \n#define IVTVFB_ERR(fmt, args...)   printk(KERN_ERR  \"ivtvfb%d: \" fmt, itv->instance , ## args)\n#define IVTVFB_WARN(fmt, args...)  printk(KERN_WARNING  \"ivtvfb%d: \" fmt, itv->instance , ## args)\n#define IVTVFB_INFO(fmt, args...)  printk(KERN_INFO \"ivtvfb%d: \" fmt, itv->instance , ## args)\n\n \n\n#define IVTV_OSD_MAX_WIDTH  720\n#define IVTV_OSD_MAX_HEIGHT 576\n\n#define IVTV_OSD_BPP_8      0x00\n#define IVTV_OSD_BPP_16_444 0x03\n#define IVTV_OSD_BPP_16_555 0x02\n#define IVTV_OSD_BPP_16_565 0x01\n#define IVTV_OSD_BPP_32     0x04\n\nstruct osd_info {\n\t \n\tunsigned long video_pbase;\n\t \n\tu32 video_rbase;\n\t \n\tvolatile char __iomem *video_vbase;\n\t \n\tu32 video_buffer_size;\n\n\t \n\tunsigned long fb_start_aligned_physaddr;\n\t \n\tunsigned long fb_end_aligned_physaddr;\n\tint wc_cookie;\n\n\t \n\tint set_osd_coords_x;\n\tint set_osd_coords_y;\n\n\t \n\tint display_width;\n\tint display_height;\n\tint display_byte_stride;\n\n\t \n\tint bits_per_pixel;\n\tint bytes_per_pixel;\n\n\t \n\tstruct fb_info ivtvfb_info;\n\tstruct fb_var_screeninfo ivtvfb_defined;\n\tstruct fb_fix_screeninfo ivtvfb_fix;\n\n\t \n\tstruct fb_var_screeninfo fbvar_cur;\n\tint blank_cur;\n\tu32 palette_cur[256];\n\tu32 pan_cur;\n};\n\nstruct ivtv_osd_coords {\n\tunsigned long offset;\n\tunsigned long max_offset;\n\tint pixel_stride;\n\tint lines;\n\tint x;\n\tint y;\n};\n\n \n\n \n\nstatic int ivtvfb_get_framebuffer(struct ivtv *itv, u32 *fbbase,\n\t\t\t\t       u32 *fblength)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tint rc;\n\n\tivtv_firmware_check(itv, \"ivtvfb_get_framebuffer\");\n\trc = ivtv_vapi_result(itv, data, CX2341X_OSD_GET_FRAMEBUFFER, 0);\n\t*fbbase = data[0];\n\t*fblength = data[1];\n\treturn rc;\n}\n\nstatic int ivtvfb_get_osd_coords(struct ivtv *itv,\n\t\t\t\t      struct ivtv_osd_coords *osd)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\n\tivtv_vapi_result(itv, data, CX2341X_OSD_GET_OSD_COORDS, 0);\n\n\tosd->offset = data[0] - oi->video_rbase;\n\tosd->max_offset = oi->display_width * oi->display_height * 4;\n\tosd->pixel_stride = data[1];\n\tosd->lines = data[2];\n\tosd->x = data[3];\n\tosd->y = data[4];\n\treturn 0;\n}\n\nstatic int ivtvfb_set_osd_coords(struct ivtv *itv, const struct ivtv_osd_coords *osd)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\n\toi->display_width = osd->pixel_stride;\n\toi->display_byte_stride = osd->pixel_stride * oi->bytes_per_pixel;\n\toi->set_osd_coords_x += osd->x;\n\toi->set_osd_coords_y = osd->y;\n\n\treturn ivtv_vapi(itv, CX2341X_OSD_SET_OSD_COORDS, 5,\n\t\t\tosd->offset + oi->video_rbase,\n\t\t\tosd->pixel_stride,\n\t\t\tosd->lines, osd->x, osd->y);\n}\n\nstatic int ivtvfb_set_display_window(struct ivtv *itv, struct v4l2_rect *ivtv_window)\n{\n\tint osd_height_limit = itv->is_out_50hz ? 576 : 480;\n\n\t \n\tif ((ivtv_window->height > osd_height_limit) || (ivtv_window->width > IVTV_OSD_MAX_WIDTH))\n\t\treturn -EINVAL;\n\n\t \n\tif (ivtv_window->top + ivtv_window->height > osd_height_limit) {\n\t\tIVTVFB_DEBUG_WARN(\"ivtv_ioctl_fb_set_display_window - Invalid height setting (%d, %d)\\n\",\n\t\t\tivtv_window->top, ivtv_window->height);\n\t\tivtv_window->top = osd_height_limit - ivtv_window->height;\n\t}\n\n\tif (ivtv_window->left + ivtv_window->width > IVTV_OSD_MAX_WIDTH) {\n\t\tIVTVFB_DEBUG_WARN(\"ivtv_ioctl_fb_set_display_window - Invalid width setting (%d, %d)\\n\",\n\t\t\tivtv_window->left, ivtv_window->width);\n\t\tivtv_window->left = IVTV_OSD_MAX_WIDTH - ivtv_window->width;\n\t}\n\n\t \n\twrite_reg((ivtv_window->top << 16) | ivtv_window->left, 0x02a04);\n\n\t \n\twrite_reg(((ivtv_window->top+ivtv_window->height) << 16) | (ivtv_window->left+ivtv_window->width), 0x02a08);\n\n\t \n\titv->yuv_info.osd_vis_w = ivtv_window->width;\n\titv->yuv_info.osd_vis_h = ivtv_window->height;\n\titv->yuv_info.osd_x_offset = ivtv_window->left;\n\titv->yuv_info.osd_y_offset = ivtv_window->top;\n\n\treturn 0;\n}\n\nstatic int ivtvfb_prep_dec_dma_to_device(struct ivtv *itv,\n\t\t\t\t  unsigned long ivtv_dest_addr, void __user *userbuf,\n\t\t\t\t  int size_in_bytes)\n{\n\tDEFINE_WAIT(wait);\n\tint got_sig = 0;\n\n\tmutex_lock(&itv->udma.lock);\n\t \n\tif (ivtv_udma_setup(itv, ivtv_dest_addr, userbuf, size_in_bytes) <= 0) {\n\t\tmutex_unlock(&itv->udma.lock);\n\t\tIVTVFB_WARN(\"ivtvfb_prep_dec_dma_to_device, Error with pin_user_pages: %d bytes, %d pages returned\\n\",\n\t\t\t       size_in_bytes, itv->udma.page_count);\n\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_prep_dec_dma_to_device, %d bytes, %d pages\\n\",\n\t\t       size_in_bytes, itv->udma.page_count);\n\n\tivtv_udma_prepare(itv);\n\tprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\n\t \n\twhile (test_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags) ||\n\t       test_bit(IVTV_F_I_UDMA, &itv->i_flags)) {\n\t\t \n\t\tgot_sig = signal_pending(current);\n\t\tif (got_sig && test_and_clear_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags))\n\t\t\tbreak;\n\t\tgot_sig = 0;\n\t\tschedule();\n\t}\n\tfinish_wait(&itv->dma_waitq, &wait);\n\n\t \n\tivtv_udma_unmap(itv);\n\tmutex_unlock(&itv->udma.lock);\n\tif (got_sig) {\n\t\tIVTV_DEBUG_INFO(\"User stopped OSD\\n\");\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}\n\nstatic int ivtvfb_prep_frame(struct ivtv *itv, int cmd, void __user *source,\n\t\t\t      unsigned long dest_offset, int count)\n{\n\tDEFINE_WAIT(wait);\n\tstruct osd_info *oi = itv->osd_info;\n\n\t \n\tif (count == 0) {\n\t\tIVTVFB_DEBUG_WARN(\"ivtvfb_prep_frame: Nothing to do. count = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((dest_offset + count) > oi->video_buffer_size) {\n\t\tIVTVFB_WARN(\"ivtvfb_prep_frame: Overflowing the framebuffer %ld, only %d available\\n\",\n\t\t\tdest_offset + count, oi->video_buffer_size);\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tif ((unsigned long)source & 3)\n\t\tIVTVFB_WARN(\"ivtvfb_prep_frame: Source address not 32 bit aligned (%p)\\n\",\n\t\t\t    source);\n\n\tif (dest_offset & 3)\n\t\tIVTVFB_WARN(\"ivtvfb_prep_frame: Dest offset not 32 bit aligned (%ld)\\n\", dest_offset);\n\n\tif (count & 3)\n\t\tIVTVFB_WARN(\"ivtvfb_prep_frame: Count not a multiple of 4 (%d)\\n\", count);\n\n\t \n\tif (!access_ok(source + dest_offset, count)) {\n\t\tIVTVFB_WARN(\"Invalid userspace pointer %p\\n\", source);\n\n\t\tIVTVFB_DEBUG_WARN(\"access_ok() failed for offset 0x%08lx source %p count %d\\n\",\n\t\t\t\t  dest_offset, source, count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdest_offset += IVTV_DECODER_OFFSET + oi->video_rbase;\n\n\t \n\treturn ivtvfb_prep_dec_dma_to_device(itv, dest_offset, source, count);\n}\n\nstatic ssize_t ivtvfb_write(struct fb_info *info, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tvoid *dst;\n\tint err = 0;\n\tint dma_err;\n\tunsigned long total_size;\n\tstruct ivtv *itv = (struct ivtv *) info->par;\n\tunsigned long dma_offset =\n\t\t\tIVTV_DECODER_OFFSET + itv->osd_info->video_rbase;\n\tunsigned long dma_size;\n\tu16 lead = 0, tail = 0;\n\n\tif (!info->screen_base)\n\t\treturn -ENODEV;\n\n\ttotal_size = info->screen_size;\n\n\tif (total_size == 0)\n\t\ttotal_size = info->fix.smem_len;\n\n\tif (p > total_size)\n\t\treturn -EFBIG;\n\n\tif (count > total_size) {\n\t\terr = -EFBIG;\n\t\tcount = total_size;\n\t}\n\n\tif (count + p > total_size) {\n\t\tif (!err)\n\t\t\terr = -ENOSPC;\n\t\tcount = total_size - p;\n\t}\n\n\tdst = (void __force *) (info->screen_base + p);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\t \n\tif (count >= 4096 &&\n\t    ((unsigned long)buf & 3) == ((unsigned long)dst & 3)) {\n\t\t \n\t\tif ((unsigned long)dst & 3) {\n\t\t\tlead = 4 - ((unsigned long)dst & 3);\n\t\t\tif (copy_from_user(dst, buf, lead))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += lead;\n\t\t\tdst += lead;\n\t\t}\n\t\t \n\t\tif ((count - lead) & 3)\n\t\t\ttail = (count - lead) & 3;\n\t\t \n\t\tdma_size = count - lead - tail;\n\t\tdma_err = ivtvfb_prep_dec_dma_to_device(itv,\n\t\t       p + lead + dma_offset, (void __user *)buf, dma_size);\n\t\tif (dma_err)\n\t\t\treturn dma_err;\n\t\tdst += dma_size;\n\t\tbuf += dma_size;\n\t\t \n\t\tif (tail && copy_from_user(dst, buf, tail))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(dst, buf, count)) {\n\t\treturn -EFAULT;\n\t}\n\n\tif  (!err)\n\t\t*ppos += count;\n\n\treturn (err) ? err : count;\n}\n\nstatic int ivtvfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tDEFINE_WAIT(wait);\n\tstruct ivtv *itv = (struct ivtv *)info->par;\n\tint rc = 0;\n\n\tswitch (cmd) {\n\t\tcase FBIOGET_VBLANK: {\n\t\t\tstruct fb_vblank vblank;\n\t\t\tu32 trace;\n\n\t\t\tmemset(&vblank, 0, sizeof(struct fb_vblank));\n\n\t\t\tvblank.flags = FB_VBLANK_HAVE_COUNT |FB_VBLANK_HAVE_VCOUNT |\n\t\t\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\t\ttrace = read_reg(IVTV_REG_DEC_LINE_FIELD) >> 16;\n\t\t\tif (itv->is_out_50hz && trace > 312)\n\t\t\t\ttrace -= 312;\n\t\t\telse if (itv->is_out_60hz && trace > 262)\n\t\t\t\ttrace -= 262;\n\t\t\tif (trace == 1)\n\t\t\t\tvblank.flags |= FB_VBLANK_VSYNCING;\n\t\t\tvblank.count = itv->last_vsync_field;\n\t\t\tvblank.vcount = trace;\n\t\t\tvblank.hcount = 0;\n\t\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase FBIO_WAITFORVSYNC:\n\t\t\tprepare_to_wait(&itv->vsync_waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\tif (!schedule_timeout(msecs_to_jiffies(50)))\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\tfinish_wait(&itv->vsync_waitq, &wait);\n\t\t\treturn rc;\n\n\t\tcase IVTVFB_IOC_DMA_FRAME: {\n\t\t\tstruct ivtvfb_dma_frame args;\n\n\t\t\tIVTVFB_DEBUG_INFO(\"IVTVFB_IOC_DMA_FRAME\\n\");\n\t\t\tif (copy_from_user(&args, (void __user *)arg, sizeof(args)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn ivtvfb_prep_frame(itv, cmd, args.source, args.dest_offset, args.count);\n\t\t}\n\n\t\tdefault:\n\t\t\tIVTVFB_DEBUG_INFO(\"Unknown ioctl %08x\\n\", cmd);\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int ivtvfb_set_var(struct ivtv *itv, struct fb_var_screeninfo *var)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tstruct ivtv_osd_coords ivtv_osd;\n\tstruct v4l2_rect ivtv_window;\n\tint osd_mode = -1;\n\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_set_var\\n\");\n\n\t \n\tif (var->nonstd)  \n\t\twrite_reg(read_reg(0x02a00) | 0x0002000, 0x02a00);\n\telse  \n\t\twrite_reg(read_reg(0x02a00) & ~0x0002000, 0x02a00);\n\n\t \n\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\tosd_mode = IVTV_OSD_BPP_8;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tosd_mode = IVTV_OSD_BPP_32;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tswitch (var->green.length) {\n\t\t\tcase 4:\n\t\t\t\tosd_mode = IVTV_OSD_BPP_16_444;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tosd_mode = IVTV_OSD_BPP_16_555;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tosd_mode = IVTV_OSD_BPP_16_565;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tIVTVFB_DEBUG_WARN(\"ivtvfb_set_var - Invalid bpp\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIVTVFB_DEBUG_WARN(\"ivtvfb_set_var - Invalid bpp\\n\");\n\t}\n\n\t \n\tif (osd_mode != -1) {\n\t\tivtv_vapi(itv, CX2341X_OSD_SET_PIXEL_FORMAT, 1, 0);\n\t\tivtv_vapi(itv, CX2341X_OSD_SET_PIXEL_FORMAT, 1, osd_mode);\n\t}\n\n\toi->bits_per_pixel = var->bits_per_pixel;\n\toi->bytes_per_pixel = var->bits_per_pixel / 8;\n\n\t \n\tswitch (var->vmode & FB_VMODE_MASK) {\n\t\tcase FB_VMODE_NONINTERLACED:  \n\t\t\tivtv_vapi(itv, CX2341X_OSD_SET_FLICKER_STATE, 1, 1);\n\t\t\tbreak;\n\t\tcase FB_VMODE_INTERLACED:  \n\t\t\tivtv_vapi(itv, CX2341X_OSD_SET_FLICKER_STATE, 1, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIVTVFB_DEBUG_WARN(\"ivtvfb_set_var - Invalid video mode\\n\");\n\t}\n\n\t \n\tivtvfb_get_osd_coords(itv, &ivtv_osd);\n\n\t \n\tivtv_osd.pixel_stride = var->xres_virtual;\n\tivtv_osd.lines = var->yres_virtual;\n\tivtv_osd.x = 0;\n\tivtv_osd.y = 0;\n\tivtvfb_set_osd_coords(itv, &ivtv_osd);\n\n\t \n\tivtv_window.width = var->xres;\n\tivtv_window.height = var->yres;\n\n\t \n\tif (!var->upper_margin)\n\t\tvar->upper_margin++;\n\tif (!var->left_margin)\n\t\tvar->left_margin++;\n\tivtv_window.top = var->upper_margin - 1;\n\tivtv_window.left = var->left_margin - 1;\n\n\tivtvfb_set_display_window(itv, &ivtv_window);\n\n\t \n\titv->yuv_info.osd_full_w = ivtv_osd.pixel_stride;\n\titv->yuv_info.osd_full_h = ivtv_osd.lines;\n\n\t \n\titv->yuv_info.yuv_forced_update = 1;\n\n\t \n\tmemcpy(&oi->fbvar_cur, var, sizeof(oi->fbvar_cur));\n\n\tIVTVFB_DEBUG_INFO(\"Display size: %dx%d (virtual %dx%d) @ %dbpp\\n\",\n\t\t      var->xres, var->yres,\n\t\t      var->xres_virtual, var->yres_virtual,\n\t\t      var->bits_per_pixel);\n\n\tIVTVFB_DEBUG_INFO(\"Display position: %d, %d\\n\",\n\t\t      var->left_margin, var->upper_margin);\n\n\tIVTVFB_DEBUG_INFO(\"Display filter: %s\\n\",\n\t\t\t(var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED ? \"on\" : \"off\");\n\tIVTVFB_DEBUG_INFO(\"Color space: %s\\n\", var->nonstd ? \"YUV\" : \"RGB\");\n\n\treturn 0;\n}\n\nstatic int ivtvfb_get_fix(struct ivtv *itv, struct fb_fix_screeninfo *fix)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_get_fix\\n\");\n\tmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\n\tstrscpy(fix->id, \"cx23415 TV out\", sizeof(fix->id));\n\tfix->smem_start = oi->video_pbase;\n\tfix->smem_len = oi->video_buffer_size;\n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->visual = (oi->bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tfix->xpanstep = 1;\n\tfix->ypanstep = 1;\n\tfix->ywrapstep = 0;\n\tfix->line_length = oi->display_byte_stride;\n\tfix->accel = FB_ACCEL_NONE;\n\treturn 0;\n}\n\n \n\nstatic int _ivtvfb_check_var(struct fb_var_screeninfo *var, struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tint osd_height_limit;\n\tu32 pixclock, hlimit, vlimit;\n\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_check_var\\n\");\n\n\t \n\tif (itv->is_out_50hz) {\n\t\tpixclock = 84316;\n\t\thlimit = 776;\n\t\tvlimit = 591;\n\t\tosd_height_limit = 576;\n\t}\n\telse {\n\t\tpixclock = 83926;\n\t\thlimit = 776;\n\t\tvlimit = 495;\n\t\tosd_height_limit = 480;\n\t}\n\n\tif (var->bits_per_pixel == 8 || var->bits_per_pixel == 32) {\n\t\tvar->transp.offset = 24;\n\t\tvar->transp.length = 8;\n\t\tvar->red.offset = 16;\n\t\tvar->red.length = 8;\n\t\tvar->green.offset = 8;\n\t\tvar->green.length = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 8;\n\t}\n\telse if (var->bits_per_pixel == 16) {\n\t\t \n\t\tswitch (var->green.length) {\n\t\t\tcase 4:\n\t\t\t\tvar->red.offset = 8;\n\t\t\t\tvar->red.length = 4;\n\t\t\t\tvar->green.offset = 4;\n\t\t\t\tvar->green.length = 4;\n\t\t\t\tvar->blue.offset = 0;\n\t\t\t\tvar->blue.length = 4;\n\t\t\t\tvar->transp.offset = 12;\n\t\t\t\tvar->transp.length = 1;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tvar->red.offset = 10;\n\t\t\t\tvar->red.length = 5;\n\t\t\t\tvar->green.offset = 5;\n\t\t\t\tvar->green.length = 5;\n\t\t\t\tvar->blue.offset = 0;\n\t\t\t\tvar->blue.length = 5;\n\t\t\t\tvar->transp.offset = 15;\n\t\t\t\tvar->transp.length = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvar->red.offset = 11;\n\t\t\t\tvar->red.length = 5;\n\t\t\t\tvar->green.offset = 5;\n\t\t\t\tvar->green.length = 6;\n\t\t\t\tvar->blue.offset = 0;\n\t\t\t\tvar->blue.length = 5;\n\t\t\t\tvar->transp.offset = 0;\n\t\t\t\tvar->transp.length = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid colour mode: %d\\n\", var->bits_per_pixel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xres > IVTV_OSD_MAX_WIDTH || var->yres > osd_height_limit) {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid resolution: %dx%d\\n\",\n\t\t\t\tvar->xres, var->yres);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->xres_virtual > 4095 / (var->bits_per_pixel / 8) ||\n\t    var->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8) > oi->video_buffer_size ||\n\t    var->xres_virtual < var->xres ||\n\t    var->yres_virtual < var->yres) {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid virtual resolution: %dx%d\\n\",\n\t\t\tvar->xres_virtual, var->yres_virtual);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->bits_per_pixel == 8) {\n\t\t \n\t\tif (var->xres & 3) {\n\t\t\tIVTVFB_DEBUG_WARN(\"Invalid resolution for 8bpp: %d\\n\", var->xres);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (var->xres_virtual & 3) {\n\t\t\tIVTVFB_DEBUG_WARN(\"Invalid virtual resolution for 8bpp: %d)\\n\", var->xres_virtual);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\telse if (var->bits_per_pixel == 16) {\n\t\t \n\t\tif (var->xres & 1) {\n\t\t\tIVTVFB_DEBUG_WARN(\"Invalid resolution for 16bpp: %d\\n\", var->xres);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (var->xres_virtual & 1) {\n\t\t\tIVTVFB_DEBUG_WARN(\"Invalid virtual resolution for 16bpp: %d)\\n\", var->xres_virtual);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (var->xoffset >= var->xres_virtual || var->yoffset >= var->yres_virtual) {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid offset: %d (%d) %d (%d)\\n\",\n\t\t\tvar->xoffset, var->xres_virtual, var->yoffset, var->yres_virtual);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (var->nonstd > 1) {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid nonstd % d\\n\", var->nonstd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED) &&\n\t\t((var->vmode & FB_VMODE_MASK) != FB_VMODE_INTERLACED)) {\n\t\tIVTVFB_DEBUG_WARN(\"Invalid video mode: %d\\n\", var->vmode & FB_VMODE_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif (var->left_margin + var->xres > IVTV_OSD_MAX_WIDTH + 1)\n\t\tvar->left_margin = 1 + ((IVTV_OSD_MAX_WIDTH - var->xres) / 2);\n\n\tif (var->upper_margin + var->yres > (itv->is_out_50hz ? 577 : 481))\n\t\tvar->upper_margin = 1 + (((itv->is_out_50hz ? 576 : 480) -\n\t\t\tvar->yres) / 2);\n\n\t \n\tvar->right_margin = hlimit - var->left_margin - var->xres;\n\tvar->lower_margin = vlimit - var->upper_margin - var->yres;\n\n\t \n\tvar->hsync_len = 24;\n\tvar->vsync_len = 2;\n\n\t \n\tif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED)\n\t\tvar->pixclock = pixclock / 2;\n\telse\n\t\tvar->pixclock = pixclock;\n\n\titv->osd_rect.width = var->xres;\n\titv->osd_rect.height = var->yres;\n\n\tIVTVFB_DEBUG_INFO(\"Display size: %dx%d (virtual %dx%d) @ %dbpp\\n\",\n\t\t      var->xres, var->yres,\n\t\t      var->xres_virtual, var->yres_virtual,\n\t\t      var->bits_per_pixel);\n\n\tIVTVFB_DEBUG_INFO(\"Display position: %d, %d\\n\",\n\t\t      var->left_margin, var->upper_margin);\n\n\tIVTVFB_DEBUG_INFO(\"Display filter: %s\\n\",\n\t\t\t(var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED ? \"on\" : \"off\");\n\tIVTVFB_DEBUG_INFO(\"Color space: %s\\n\", var->nonstd ? \"YUV\" : \"RGB\");\n\treturn 0;\n}\n\nstatic int ivtvfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tstruct ivtv *itv = (struct ivtv *) info->par;\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_check_var\\n\");\n\treturn _ivtvfb_check_var(var, itv);\n}\n\nstatic int ivtvfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tu32 osd_pan_index;\n\tstruct ivtv *itv = (struct ivtv *) info->par;\n\n\tif (var->yoffset + info->var.yres > info->var.yres_virtual ||\n\t    var->xoffset + info->var.xres > info->var.xres_virtual)\n\t\treturn -EINVAL;\n\n\tosd_pan_index = var->yoffset * info->fix.line_length\n\t\t      + var->xoffset * info->var.bits_per_pixel / 8;\n\twrite_reg(osd_pan_index, 0x02A0C);\n\n\t \n\titv->yuv_info.osd_x_pan = var->xoffset;\n\titv->yuv_info.osd_y_pan = var->yoffset;\n\t \n\titv->yuv_info.yuv_forced_update = 1;\n\t \n\titv->osd_info->pan_cur = osd_pan_index;\n\treturn 0;\n}\n\nstatic int ivtvfb_set_par(struct fb_info *info)\n{\n\tint rc = 0;\n\tstruct ivtv *itv = (struct ivtv *) info->par;\n\n\tIVTVFB_DEBUG_INFO(\"ivtvfb_set_par\\n\");\n\n\trc = ivtvfb_set_var(itv, &info->var);\n\tivtvfb_pan_display(&info->var, info);\n\tivtvfb_get_fix(itv, &info->fix);\n\tivtv_firmware_check(itv, \"ivtvfb_set_par\");\n\treturn rc;\n}\n\nstatic int ivtvfb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\t\t\tunsigned blue, unsigned transp,\n\t\t\t\tstruct fb_info *info)\n{\n\tu32 color, *palette;\n\tstruct ivtv *itv = (struct ivtv *)info->par;\n\n\tif (regno >= info->cmap.len)\n\t\treturn -EINVAL;\n\n\tcolor = ((transp & 0xFF00) << 16) |((red & 0xFF00) << 8) | (green & 0xFF00) | ((blue & 0xFF00) >> 8);\n\tif (info->var.bits_per_pixel <= 8) {\n\t\twrite_reg(regno, 0x02a30);\n\t\twrite_reg(color, 0x02a34);\n\t\titv->osd_info->palette_cur[regno] = color;\n\t\treturn 0;\n\t}\n\tif (regno >= 16)\n\t\treturn -EINVAL;\n\n\tpalette = info->pseudo_palette;\n\tif (info->var.bits_per_pixel == 16) {\n\t\tswitch (info->var.green.length) {\n\t\t\tcase 4:\n\t\t\t\tcolor = ((red & 0xf000) >> 4) |\n\t\t\t\t\t((green & 0xf000) >> 8) |\n\t\t\t\t\t((blue & 0xf000) >> 12);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = ((red & 0xf800) >> 1) |\n\t\t\t\t\t((green & 0xf800) >> 6) |\n\t\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tcolor = (red & 0xf800 ) |\n\t\t\t\t\t((green & 0xfc00) >> 5) |\n\t\t\t\t\t((blue & 0xf800) >> 11);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpalette[regno] = color;\n\treturn 0;\n}\n\n \nstatic int ivtvfb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct ivtv *itv = (struct ivtv *)info->par;\n\n\tIVTVFB_DEBUG_INFO(\"Set blanking mode : %d\\n\", blank_mode);\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 1);\n\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 0);\n\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\n\t\tivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 0);\n\t\tbreak;\n\t}\n\titv->osd_info->blank_cur = blank_mode;\n\treturn 0;\n}\n\nstatic const struct fb_ops ivtvfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_write       = ivtvfb_write,\n\t.fb_check_var   = ivtvfb_check_var,\n\t.fb_set_par     = ivtvfb_set_par,\n\t.fb_setcolreg   = ivtvfb_setcolreg,\n\t.fb_fillrect    = cfb_fillrect,\n\t.fb_copyarea    = cfb_copyarea,\n\t.fb_imageblit   = cfb_imageblit,\n\t.fb_cursor      = NULL,\n\t.fb_ioctl       = ivtvfb_ioctl,\n\t.fb_pan_display = ivtvfb_pan_display,\n\t.fb_blank       = ivtvfb_blank,\n};\n\n \nstatic void ivtvfb_restore(struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tint i;\n\n\tivtvfb_set_var(itv, &oi->fbvar_cur);\n\tivtvfb_blank(oi->blank_cur, &oi->ivtvfb_info);\n\tfor (i = 0; i < 256; i++) {\n\t\twrite_reg(i, 0x02a30);\n\t\twrite_reg(oi->palette_cur[i], 0x02a34);\n\t}\n\twrite_reg(oi->pan_cur, 0x02a0c);\n}\n\n \n\n\n \nstatic int ivtvfb_init_vidmode(struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tstruct v4l2_rect start_window;\n\tint max_height;\n\n\t \n\n\tif (osd_depth != 8 && osd_depth != 16 && osd_depth != 32)\n\t\tosd_depth = 8;\n\toi->bits_per_pixel = osd_depth;\n\toi->bytes_per_pixel = oi->bits_per_pixel / 8;\n\n\t \n\n\tif (osd_xres > 720)\n\t\tosd_xres = 720;\n\n\t \n\tif (osd_depth == 8)\n\t\tosd_xres &= ~3;\n\telse if (osd_depth == 16)\n\t\tosd_xres &= ~1;\n\n\tstart_window.width = osd_xres ? osd_xres : 640;\n\n\t \n\tif (osd_left && osd_left + start_window.width > 721) {\n\t\tIVTVFB_ERR(\"Invalid osd_left - assuming default\\n\");\n\t\tosd_left = 0;\n\t}\n\n\t \n\tosd_left--;\n\n\tstart_window.left = osd_left >= 0 ?\n\t\t osd_left : ((IVTV_OSD_MAX_WIDTH - start_window.width) / 2);\n\n\toi->display_byte_stride =\n\t\t\tstart_window.width * oi->bytes_per_pixel;\n\n\t \n\n\tmax_height = itv->is_out_50hz ? 576 : 480;\n\n\tif (osd_yres > max_height)\n\t\tosd_yres = max_height;\n\n\tstart_window.height = osd_yres ?\n\t\tosd_yres : itv->is_out_50hz ? 480 : 400;\n\n\t \n\tif (osd_upper + start_window.height > max_height + 1) {\n\t\tIVTVFB_ERR(\"Invalid osd_upper - assuming default\\n\");\n\t\tosd_upper = 0;\n\t}\n\n\t \n\tosd_upper--;\n\n\tstart_window.top = osd_upper >= 0 ? osd_upper : ((max_height - start_window.height) / 2);\n\n\toi->display_width = start_window.width;\n\toi->display_height = start_window.height;\n\n\t \n\n\toi->ivtvfb_defined.xres = oi->display_width;\n\toi->ivtvfb_defined.yres = oi->display_height;\n\toi->ivtvfb_defined.xres_virtual = oi->display_width;\n\toi->ivtvfb_defined.yres_virtual = oi->display_height;\n\toi->ivtvfb_defined.bits_per_pixel = oi->bits_per_pixel;\n\toi->ivtvfb_defined.vmode = (osd_laced ? FB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED);\n\toi->ivtvfb_defined.left_margin = start_window.left + 1;\n\toi->ivtvfb_defined.upper_margin = start_window.top + 1;\n\toi->ivtvfb_defined.accel_flags = FB_ACCEL_NONE;\n\toi->ivtvfb_defined.nonstd = 0;\n\n\t \n\t_ivtvfb_check_var(&oi->ivtvfb_defined, itv);\n\n\t \n\n\tivtvfb_get_fix(itv, &oi->ivtvfb_fix);\n\n\t \n\n\toi->ivtvfb_info.node = -1;\n\toi->ivtvfb_info.par = itv;\n\toi->ivtvfb_info.var = oi->ivtvfb_defined;\n\toi->ivtvfb_info.fix = oi->ivtvfb_fix;\n\toi->ivtvfb_info.screen_base = (u8 __iomem *)oi->video_vbase;\n\toi->ivtvfb_info.fbops = &ivtvfb_ops;\n\n\t \n\toi->ivtvfb_info.monspecs.hfmin = 8000;\n\toi->ivtvfb_info.monspecs.hfmax = 70000;\n\toi->ivtvfb_info.monspecs.vfmin = 10;\n\toi->ivtvfb_info.monspecs.vfmax = 100;\n\n\t \n\tif (fb_alloc_cmap(&oi->ivtvfb_info.cmap, 256, 1)) {\n\t\tIVTVFB_ERR(\"abort, unable to alloc cmap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\toi->ivtvfb_info.pseudo_palette =\n\t\tkmalloc_array(16, sizeof(u32), GFP_KERNEL|__GFP_NOWARN);\n\n\tif (!oi->ivtvfb_info.pseudo_palette) {\n\t\tIVTVFB_ERR(\"abort, unable to alloc pseudo palette\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int ivtvfb_init_io(struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\t \n\tint size_shift = 31;\n\n\tmutex_lock(&itv->serialize_lock);\n\tif (ivtv_init_on_first_open(itv)) {\n\t\tmutex_unlock(&itv->serialize_lock);\n\t\tIVTVFB_ERR(\"Failed to initialize ivtv\\n\");\n\t\treturn -ENXIO;\n\t}\n\tmutex_unlock(&itv->serialize_lock);\n\n\tif (ivtvfb_get_framebuffer(itv, &oi->video_rbase,\n\t\t\t\t\t&oi->video_buffer_size) < 0) {\n\t\tIVTVFB_ERR(\"Firmware failed to respond\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\toi->video_buffer_size = 1704960;\n\n\toi->video_pbase = itv->base_addr + IVTV_DECODER_OFFSET + oi->video_rbase;\n\toi->video_vbase = itv->dec_mem + oi->video_rbase;\n\n\tif (!oi->video_vbase) {\n\t\tIVTVFB_ERR(\"abort, video memory 0x%x @ 0x%lx isn't mapped!\\n\",\n\t\t     oi->video_buffer_size, oi->video_pbase);\n\t\treturn -EIO;\n\t}\n\n\tIVTVFB_INFO(\"Framebuffer at 0x%lx, mapped to 0x%p, size %dk\\n\",\n\t\t\toi->video_pbase, oi->video_vbase,\n\t\t\toi->video_buffer_size / 1024);\n\n\twhile (!(oi->video_buffer_size & (1 << size_shift)))\n\t\tsize_shift--;\n\tsize_shift++;\n\toi->fb_start_aligned_physaddr = oi->video_pbase & ~((1 << size_shift) - 1);\n\toi->fb_end_aligned_physaddr = oi->video_pbase + oi->video_buffer_size;\n\toi->fb_end_aligned_physaddr += (1 << size_shift) - 1;\n\toi->fb_end_aligned_physaddr &= ~((1 << size_shift) - 1);\n\toi->wc_cookie = arch_phys_wc_add(oi->fb_start_aligned_physaddr,\n\t\t\t\t\t oi->fb_end_aligned_physaddr -\n\t\t\t\t\t oi->fb_start_aligned_physaddr);\n\t \n\tmemset_io(oi->video_vbase, 0, oi->video_buffer_size);\n\n\treturn 0;\n}\n\n \nstatic void ivtvfb_release_buffers (struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\n\t \n\tif (oi->ivtvfb_info.cmap.len)\n\t\tfb_dealloc_cmap(&oi->ivtvfb_info.cmap);\n\n\t \n\tkfree(oi->ivtvfb_info.pseudo_palette);\n\tarch_phys_wc_del(oi->wc_cookie);\n\tkfree(oi);\n\titv->osd_info = NULL;\n}\n\n \n\nstatic int ivtvfb_init_card(struct ivtv *itv)\n{\n\tint rc;\n\n#if defined(CONFIG_X86_64) && !defined(CONFIG_UML)\n\tif (pat_enabled()) {\n\t\tif (ivtvfb_force_pat) {\n\t\t\tpr_info(\"PAT is enabled. Write-combined framebuffer caching will be disabled.\\n\");\n\t\t\tpr_info(\"To enable caching, boot with nopat kernel parameter\\n\");\n\t\t} else {\n\t\t\tpr_warn(\"ivtvfb needs PAT disabled for write-combined framebuffer caching.\\n\");\n\t\t\tpr_warn(\"Boot with nopat kernel parameter to use caching, or use the\\n\");\n\t\t\tpr_warn(\"force_pat module parameter to run with caching disabled\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\tif (itv->osd_info) {\n\t\tIVTVFB_ERR(\"Card %d already initialised\\n\", ivtvfb_card_id);\n\t\treturn -EBUSY;\n\t}\n\n\titv->osd_info = kzalloc(sizeof(struct osd_info),\n\t\t\t\t\tGFP_KERNEL|__GFP_NOWARN);\n\tif (itv->osd_info == NULL) {\n\t\tIVTVFB_ERR(\"Failed to allocate memory for osd_info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trc = ivtvfb_init_io(itv);\n\tif (rc) {\n\t\tivtvfb_release_buffers(itv);\n\t\treturn rc;\n\t}\n\n\t \n\tif ((rc = ivtvfb_init_vidmode(itv))) {\n\t\tivtvfb_release_buffers(itv);\n\t\treturn rc;\n\t}\n\n\t \n\tif (register_framebuffer(&itv->osd_info->ivtvfb_info) < 0) {\n\t\tivtvfb_release_buffers(itv);\n\t\treturn -EINVAL;\n\t}\n\n\titv->osd_video_pbase = itv->osd_info->video_pbase;\n\n\t \n\tivtvfb_set_par(&itv->osd_info->ivtvfb_info);\n\n\t \n\twrite_reg(0, 0x02a30);\n\twrite_reg(0, 0x02a34);\n\n\t \n\tivtvfb_blank(FB_BLANK_UNBLANK, &itv->osd_info->ivtvfb_info);\n\n\t \n\titv->ivtvfb_restore = ivtvfb_restore;\n\n\t \n\tivtv_udma_alloc(itv);\n\titv->streams[IVTV_DEC_STREAM_TYPE_YUV].vdev.device_caps |=\n\t\tV4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\titv->streams[IVTV_DEC_STREAM_TYPE_MPG].vdev.device_caps |=\n\t\tV4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\titv->v4l2_cap |= V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\treturn 0;\n\n}\n\nstatic int __init ivtvfb_callback_init(struct device *dev, void *p)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct ivtv *itv = container_of(v4l2_dev, struct ivtv, v4l2_dev);\n\n\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\n\t\tif (ivtvfb_init_card(itv) == 0) {\n\t\t\tIVTVFB_INFO(\"Framebuffer registered on %s\\n\",\n\t\t\t\t\titv->v4l2_dev.name);\n\t\t\t(*(int *)p)++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ivtvfb_callback_cleanup(struct device *dev, void *p)\n{\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct ivtv *itv = container_of(v4l2_dev, struct ivtv, v4l2_dev);\n\tstruct osd_info *oi = itv->osd_info;\n\n\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\n\t\titv->streams[IVTV_DEC_STREAM_TYPE_YUV].vdev.device_caps &=\n\t\t\t~V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t\titv->streams[IVTV_DEC_STREAM_TYPE_MPG].vdev.device_caps &=\n\t\t\t~V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t\titv->v4l2_cap &= ~V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t\tunregister_framebuffer(&itv->osd_info->ivtvfb_info);\n\t\tIVTVFB_INFO(\"Unregister framebuffer %d\\n\", itv->instance);\n\t\titv->ivtvfb_restore = NULL;\n\t\tivtvfb_blank(FB_BLANK_VSYNC_SUSPEND, &oi->ivtvfb_info);\n\t\tivtvfb_release_buffers(itv);\n\t\titv->osd_video_pbase = 0;\n\t}\n\treturn 0;\n}\n\nstatic int __init ivtvfb_init(void)\n{\n\tstruct device_driver *drv;\n\tint registered = 0;\n\tint err;\n\n\n\tif (ivtvfb_card_id < -1 || ivtvfb_card_id >= IVTV_MAX_CARDS) {\n\t\tpr_err(\"ivtvfb_card_id parameter is out of range (valid range: -1 - %d)\\n\",\n\t\t     IVTV_MAX_CARDS - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tdrv = driver_find(\"ivtv\", &pci_bus_type);\n\terr = driver_for_each_device(drv, NULL, &registered, ivtvfb_callback_init);\n\t(void)err;\t \n\tif (!registered) {\n\t\tpr_err(\"no cards found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void ivtvfb_cleanup(void)\n{\n\tstruct device_driver *drv;\n\tint err;\n\n\tpr_info(\"Unloading framebuffer module\\n\");\n\n\tdrv = driver_find(\"ivtv\", &pci_bus_type);\n\terr = driver_for_each_device(drv, NULL, NULL, ivtvfb_callback_cleanup);\n\t(void)err;\t \n}\n\nmodule_init(ivtvfb_init);\nmodule_exit(ivtvfb_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}