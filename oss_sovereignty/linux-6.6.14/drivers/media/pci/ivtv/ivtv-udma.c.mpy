{
  "module_name": "ivtv-udma.c",
  "hash_id": "aecb7c351491e7bca7fc9ca9218bb34ff08fcbafb8162f33143ee70947d0f118",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-udma.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-udma.h\"\n\nvoid ivtv_udma_get_page_info(struct ivtv_dma_page_info *dma_page, unsigned long first, unsigned long size)\n{\n\tdma_page->uaddr = first & PAGE_MASK;\n\tdma_page->offset = first & ~PAGE_MASK;\n\tdma_page->tail = 1 + ((first+size-1) & ~PAGE_MASK);\n\tdma_page->first = (first & PAGE_MASK) >> PAGE_SHIFT;\n\tdma_page->last = ((first+size-1) & PAGE_MASK) >> PAGE_SHIFT;\n\tdma_page->page_count = dma_page->last - dma_page->first + 1;\n\tif (dma_page->page_count == 1) dma_page->tail -= dma_page->offset;\n}\n\nint ivtv_udma_fill_sg_list (struct ivtv_user_dma *dma, struct ivtv_dma_page_info *dma_page, int map_offset)\n{\n\tint i, offset;\n\tunsigned long flags;\n\n\tif (map_offset < 0)\n\t\treturn map_offset;\n\n\toffset = dma_page->offset;\n\n\t \n\tfor (i = 0; i < dma_page->page_count; i++) {\n\t\tunsigned int len = (i == dma_page->page_count - 1) ?\n\t\t\tdma_page->tail : PAGE_SIZE - offset;\n\n\t\tif (PageHighMem(dma->map[map_offset])) {\n\t\t\tvoid *src;\n\n\t\t\tif (dma->bouncemap[map_offset] == NULL)\n\t\t\t\tdma->bouncemap[map_offset] = alloc_page(GFP_KERNEL);\n\t\t\tif (dma->bouncemap[map_offset] == NULL)\n\t\t\t\treturn -1;\n\t\t\tlocal_irq_save(flags);\n\t\t\tsrc = kmap_atomic(dma->map[map_offset]) + offset;\n\t\t\tmemcpy(page_address(dma->bouncemap[map_offset]) + offset, src, len);\n\t\t\tkunmap_atomic(src);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tsg_set_page(&dma->SGlist[map_offset], dma->bouncemap[map_offset], len, offset);\n\t\t}\n\t\telse {\n\t\t\tsg_set_page(&dma->SGlist[map_offset], dma->map[map_offset], len, offset);\n\t\t}\n\t\toffset = 0;\n\t\tmap_offset++;\n\t}\n\treturn map_offset;\n}\n\nvoid ivtv_udma_fill_sg_array (struct ivtv_user_dma *dma, u32 buffer_offset, u32 buffer_offset_2, u32 split) {\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(dma->SGlist, sg, dma->SG_length, i) {\n\t\tdma->SGarray[i].size = cpu_to_le32(sg_dma_len(sg));\n\t\tdma->SGarray[i].src = cpu_to_le32(sg_dma_address(sg));\n\t\tdma->SGarray[i].dst = cpu_to_le32(buffer_offset);\n\t\tbuffer_offset += sg_dma_len(sg);\n\n\t\tsplit -= sg_dma_len(sg);\n\t\tif (split == 0)\n\t\t\tbuffer_offset = buffer_offset_2;\n\t}\n}\n\n \nvoid ivtv_udma_alloc(struct ivtv *itv)\n{\n\tif (itv->udma.SG_handle == 0) {\n\t\t \n\t\titv->udma.SG_handle = dma_map_single(&itv->pdev->dev,\n\t\t\t\t\t\t     itv->udma.SGarray,\n\t\t\t\t\t\t     sizeof(itv->udma.SGarray),\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t\tivtv_udma_sync_for_cpu(itv);\n\t}\n}\n\nint ivtv_udma_setup(struct ivtv *itv, unsigned long ivtv_dest_addr,\n\t\t       void __user *userbuf, int size_in_bytes)\n{\n\tstruct ivtv_dma_page_info user_dma;\n\tstruct ivtv_user_dma *dma = &itv->udma;\n\tint err;\n\n\tIVTV_DEBUG_DMA(\"ivtv_udma_setup, dst: 0x%08x\\n\", (unsigned int)ivtv_dest_addr);\n\n\t \n\tif (dma->SG_length || dma->page_count) {\n\t\tIVTV_DEBUG_WARN(\"ivtv_udma_setup: SG_length %d page_count %d still full?\\n\",\n\t\t\t   dma->SG_length, dma->page_count);\n\t\treturn -EBUSY;\n\t}\n\n\tivtv_udma_get_page_info(&user_dma, (unsigned long)userbuf, size_in_bytes);\n\n\tif (user_dma.page_count <= 0) {\n\t\tIVTV_DEBUG_WARN(\"ivtv_udma_setup: Error %d page_count from %d bytes %d offset\\n\",\n\t\t\t   user_dma.page_count, size_in_bytes, user_dma.offset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = pin_user_pages_unlocked(user_dma.uaddr, user_dma.page_count,\n\t\t\tdma->map, 0);\n\n\tif (user_dma.page_count != err) {\n\t\tIVTV_DEBUG_WARN(\"failed to map user pages, returned %d instead of %d\\n\",\n\t\t\t   err, user_dma.page_count);\n\t\tif (err >= 0) {\n\t\t\tunpin_user_pages(dma->map, err);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn err;\n\t}\n\n\tdma->page_count = user_dma.page_count;\n\n\t \n\tif (ivtv_udma_fill_sg_list(dma, &user_dma, 0) < 0) {\n\t\tunpin_user_pages(dma->map, dma->page_count);\n\t\tdma->page_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdma->SG_length = dma_map_sg(&itv->pdev->dev, dma->SGlist,\n\t\t\t\t    dma->page_count, DMA_TO_DEVICE);\n\n\t \n\tivtv_udma_fill_sg_array (dma, ivtv_dest_addr, 0, -1);\n\n\t \n\tdma->SGarray[dma->SG_length - 1].size |= cpu_to_le32(0x80000000);\n\n\tivtv_udma_sync_for_device(itv);\n\treturn dma->page_count;\n}\n\nvoid ivtv_udma_unmap(struct ivtv *itv)\n{\n\tstruct ivtv_user_dma *dma = &itv->udma;\n\n\tIVTV_DEBUG_INFO(\"ivtv_unmap_user_dma\\n\");\n\n\t \n\tif (dma->page_count == 0)\n\t\treturn;\n\n\t \n\tif (dma->SG_length) {\n\t\tdma_unmap_sg(&itv->pdev->dev, dma->SGlist, dma->page_count,\n\t\t\t     DMA_TO_DEVICE);\n\t\tdma->SG_length = 0;\n\t}\n\t \n\tivtv_udma_sync_for_cpu(itv);\n\n\tunpin_user_pages(dma->map, dma->page_count);\n\tdma->page_count = 0;\n}\n\nvoid ivtv_udma_free(struct ivtv *itv)\n{\n\tint i;\n\n\t \n\tif (itv->udma.SG_handle) {\n\t\tdma_unmap_single(&itv->pdev->dev, itv->udma.SG_handle,\n\t\t\t\t sizeof(itv->udma.SGarray), DMA_TO_DEVICE);\n\t}\n\n\t \n\tif (itv->udma.SG_length) {\n\t\tdma_unmap_sg(&itv->pdev->dev, itv->udma.SGlist,\n\t\t\t     itv->udma.page_count, DMA_TO_DEVICE);\n\t}\n\n\tfor (i = 0; i < IVTV_DMA_SG_OSD_ENT; i++) {\n\t\tif (itv->udma.bouncemap[i])\n\t\t\t__free_page(itv->udma.bouncemap[i]);\n\t}\n}\n\nvoid ivtv_udma_start(struct ivtv *itv)\n{\n\tIVTV_DEBUG_DMA(\"start UDMA\\n\");\n\twrite_reg(itv->udma.SG_handle, IVTV_REG_DECDMAADDR);\n\twrite_reg_sync(read_reg(IVTV_REG_DMAXFER) | 0x01, IVTV_REG_DMAXFER);\n\tset_bit(IVTV_F_I_DMA, &itv->i_flags);\n\tset_bit(IVTV_F_I_UDMA, &itv->i_flags);\n\tclear_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags);\n}\n\nvoid ivtv_udma_prepare(struct ivtv *itv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&itv->dma_reg_lock, flags);\n\tif (!test_bit(IVTV_F_I_DMA, &itv->i_flags))\n\t\tivtv_udma_start(itv);\n\telse\n\t\tset_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags);\n\tspin_unlock_irqrestore(&itv->dma_reg_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}