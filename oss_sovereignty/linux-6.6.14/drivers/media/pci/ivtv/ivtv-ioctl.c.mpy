{
  "module_name": "ivtv-ioctl.c",
  "hash_id": "feeb6bbc22b2798135881363e1ca429ab6a02dcec4eea799e9856db80ba9b1fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-ioctl.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-version.h\"\n#include \"ivtv-mailbox.h\"\n#include \"ivtv-i2c.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-fileops.h\"\n#include \"ivtv-vbi.h\"\n#include \"ivtv-routing.h\"\n#include \"ivtv-streams.h\"\n#include \"ivtv-yuv.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-gpio.h\"\n#include \"ivtv-controls.h\"\n#include \"ivtv-cards.h\"\n#include <media/i2c/saa7127.h>\n#include <media/tveeprom.h>\n#include <media/v4l2-event.h>\n\nu16 ivtv_service2vbi(int type)\n{\n\tswitch (type) {\n\t\tcase V4L2_SLICED_TELETEXT_B:\n\t\t\treturn IVTV_SLICED_TYPE_TELETEXT_B;\n\t\tcase V4L2_SLICED_CAPTION_525:\n\t\t\treturn IVTV_SLICED_TYPE_CAPTION_525;\n\t\tcase V4L2_SLICED_WSS_625:\n\t\t\treturn IVTV_SLICED_TYPE_WSS_625;\n\t\tcase V4L2_SLICED_VPS:\n\t\t\treturn IVTV_SLICED_TYPE_VPS;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nstatic int valid_service_line(int field, int line, int is_pal)\n{\n\treturn (is_pal && line >= 6 && (line != 23 || field == 0)) ||\n\t       (!is_pal && line >= 10 && line < 22);\n}\n\nstatic u16 select_service_from_set(int field, int line, u16 set, int is_pal)\n{\n\tu16 valid_set = (is_pal ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525);\n\tint i;\n\n\tset = set & valid_set;\n\tif (set == 0 || !valid_service_line(field, line, is_pal)) {\n\t\treturn 0;\n\t}\n\tif (!is_pal) {\n\t\tif (line == 21 && (set & V4L2_SLICED_CAPTION_525))\n\t\t\treturn V4L2_SLICED_CAPTION_525;\n\t}\n\telse {\n\t\tif (line == 16 && field == 0 && (set & V4L2_SLICED_VPS))\n\t\t\treturn V4L2_SLICED_VPS;\n\t\tif (line == 23 && field == 0 && (set & V4L2_SLICED_WSS_625))\n\t\t\treturn V4L2_SLICED_WSS_625;\n\t\tif (line == 23)\n\t\t\treturn 0;\n\t}\n\tfor (i = 0; i < 32; i++) {\n\t\tif (BIT(i) & set)\n\t\t\treturn BIT(i);\n\t}\n\treturn 0;\n}\n\nvoid ivtv_expand_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\n{\n\tu16 set = fmt->service_set;\n\tint f, l;\n\n\tfmt->service_set = 0;\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++) {\n\t\t\tfmt->service_lines[f][l] = select_service_from_set(f, l, set, is_pal);\n\t\t}\n\t}\n}\n\nstatic void check_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\n{\n\tint f, l;\n\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++) {\n\t\t\tfmt->service_lines[f][l] = select_service_from_set(f, l, fmt->service_lines[f][l], is_pal);\n\t\t}\n\t}\n}\n\nu16 ivtv_get_service_set(struct v4l2_sliced_vbi_format *fmt)\n{\n\tint f, l;\n\tu16 set = 0;\n\n\tfor (f = 0; f < 2; f++) {\n\t\tfor (l = 0; l < 24; l++) {\n\t\t\tset |= fmt->service_lines[f][l];\n\t\t}\n\t}\n\treturn set;\n}\n\nvoid ivtv_set_osd_alpha(struct ivtv *itv)\n{\n\tivtv_vapi(itv, CX2341X_OSD_SET_GLOBAL_ALPHA, 3,\n\t\titv->osd_global_alpha_state, itv->osd_global_alpha, !itv->osd_local_alpha_state);\n\tivtv_vapi(itv, CX2341X_OSD_SET_CHROMA_KEY, 2, itv->osd_chroma_key_state, itv->osd_chroma_key);\n}\n\nint ivtv_set_speed(struct ivtv *itv, int speed)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tint single_step = (speed == 1 || speed == -1);\n\tDEFINE_WAIT(wait);\n\n\tif (speed == 0) speed = 1000;\n\n\t \n\tif (speed == itv->speed && !single_step)\n\t\treturn 0;\n\n\tif (single_step && (speed < 0) == (itv->speed < 0)) {\n\t\t \n\t\tivtv_vapi(itv, CX2341X_DEC_STEP_VIDEO, 1, 0);\n\t\titv->speed = speed;\n\t\treturn 0;\n\t}\n\tif (single_step)\n\t\t \n\t\tspeed = speed < 0 ? -1000 : 1000;\n\n\tdata[0] = (speed > 1000 || speed < -1000) ? 0x80000000 : 0;\n\tdata[0] |= (speed > 1000 || speed < -1500) ? 0x40000000 : 0;\n\tdata[1] = (speed < 0);\n\tdata[2] = speed < 0 ? 3 : 7;\n\tdata[3] = v4l2_ctrl_g_ctrl(itv->cxhdl.video_b_frames);\n\tdata[4] = (speed == 1500 || speed == 500) ? itv->speed_mute_audio : 0;\n\tdata[5] = 0;\n\tdata[6] = 0;\n\n\tif (speed == 1500 || speed == -1500) data[0] |= 1;\n\telse if (speed == 2000 || speed == -2000) data[0] |= 2;\n\telse if (speed > -1000 && speed < 0) data[0] |= (-1000 / speed);\n\telse if (speed < 1000 && speed > 0) data[0] |= (1000 / speed);\n\n\t \n\tif (atomic_read(&itv->decoding) > 0) {\n\t\tint got_sig = 0;\n\n\t\t \n\t\tivtv_vapi(itv, CX2341X_DEC_PAUSE_PLAYBACK, 1, 0);\n\n\t\t \n\t\tmutex_unlock(&itv->serialize_lock);\n\t\tprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\n\t\twhile (test_bit(IVTV_F_I_DMA, &itv->i_flags)) {\n\t\t\tgot_sig = signal_pending(current);\n\t\t\tif (got_sig)\n\t\t\t\tbreak;\n\t\t\tgot_sig = 0;\n\t\t\tschedule();\n\t\t}\n\t\tfinish_wait(&itv->dma_waitq, &wait);\n\t\tmutex_lock(&itv->serialize_lock);\n\t\tif (got_sig)\n\t\t\treturn -EINTR;\n\n\t\t \n\t\tivtv_api(itv, CX2341X_DEC_SET_PLAYBACK_SPEED, 7, data);\n\t\tIVTV_DEBUG_INFO(\"Setting Speed to 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\tdata[0], data[1], data[2], data[3], data[4], data[5], data[6]);\n\t}\n\tif (single_step) {\n\t\tspeed = (speed < 0) ? -1 : 1;\n\t\tivtv_vapi(itv, CX2341X_DEC_STEP_VIDEO, 1, 0);\n\t}\n\titv->speed = speed;\n\treturn 0;\n}\n\nstatic int ivtv_validate_speed(int cur_speed, int new_speed)\n{\n\tint fact = new_speed < 0 ? -1 : 1;\n\tint s;\n\n\tif (cur_speed == 0)\n\t\tcur_speed = 1000;\n\tif (new_speed < 0)\n\t\tnew_speed = -new_speed;\n\tif (cur_speed < 0)\n\t\tcur_speed = -cur_speed;\n\n\tif (cur_speed <= new_speed) {\n\t\tif (new_speed > 1500)\n\t\t\treturn fact * 2000;\n\t\tif (new_speed > 1000)\n\t\t\treturn fact * 1500;\n\t}\n\telse {\n\t\tif (new_speed >= 2000)\n\t\t\treturn fact * 2000;\n\t\tif (new_speed >= 1500)\n\t\t\treturn fact * 1500;\n\t\tif (new_speed >= 1000)\n\t\t\treturn fact * 1000;\n\t}\n\tif (new_speed == 0)\n\t\treturn 1000;\n\tif (new_speed == 1 || new_speed == 1000)\n\t\treturn fact * new_speed;\n\n\ts = new_speed;\n\tnew_speed = 1000 / new_speed;\n\tif (1000 / cur_speed == new_speed)\n\t\tnew_speed += (cur_speed < s) ? -1 : 1;\n\tif (new_speed > 60) return 1000 / (fact * 60);\n\treturn 1000 / (fact * new_speed);\n}\n\nstatic int ivtv_video_command(struct ivtv *itv, struct ivtv_open_id *id,\n\t\tstruct v4l2_decoder_cmd *dc, int try)\n{\n\tstruct ivtv_stream *s = &itv->streams[IVTV_DEC_STREAM_TYPE_MPG];\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tswitch (dc->cmd) {\n\tcase V4L2_DEC_CMD_START: {\n\t\tdc->flags &= V4L2_DEC_CMD_START_MUTE_AUDIO;\n\t\tdc->start.speed = ivtv_validate_speed(itv->speed, dc->start.speed);\n\t\tif (dc->start.speed < 0)\n\t\t\tdc->start.format = V4L2_DEC_START_FMT_GOP;\n\t\telse\n\t\t\tdc->start.format = V4L2_DEC_START_FMT_NONE;\n\t\tif (dc->start.speed != 500 && dc->start.speed != 1500)\n\t\t\tdc->flags = dc->start.speed == 1000 ? 0 :\n\t\t\t\t\tV4L2_DEC_CMD_START_MUTE_AUDIO;\n\t\tif (try) break;\n\n\t\titv->speed_mute_audio = dc->flags & V4L2_DEC_CMD_START_MUTE_AUDIO;\n\t\tif (ivtv_set_output_mode(itv, OUT_MPG) != OUT_MPG)\n\t\t\treturn -EBUSY;\n\t\tif (test_and_clear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags)) {\n\t\t\t \n\t\t\titv->speed = 0;\n\t\t}\n\t\treturn ivtv_start_decoding(id, dc->start.speed);\n\t}\n\n\tcase V4L2_DEC_CMD_STOP:\n\t\tdc->flags &= V4L2_DEC_CMD_STOP_IMMEDIATELY | V4L2_DEC_CMD_STOP_TO_BLACK;\n\t\tif (dc->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY)\n\t\t\tdc->stop.pts = 0;\n\t\tif (try) break;\n\t\tif (atomic_read(&itv->decoding) == 0)\n\t\t\treturn 0;\n\t\tif (itv->output_mode != OUT_MPG)\n\t\t\treturn -EBUSY;\n\n\t\titv->output_mode = OUT_NONE;\n\t\treturn ivtv_stop_v4l2_decode_stream(s, dc->flags, dc->stop.pts);\n\n\tcase V4L2_DEC_CMD_PAUSE:\n\t\tdc->flags &= V4L2_DEC_CMD_PAUSE_TO_BLACK;\n\t\tif (try) break;\n\t\tif (!atomic_read(&itv->decoding))\n\t\t\treturn -EPERM;\n\t\tif (itv->output_mode != OUT_MPG)\n\t\t\treturn -EBUSY;\n\t\tif (atomic_read(&itv->decoding) > 0) {\n\t\t\tivtv_vapi(itv, CX2341X_DEC_PAUSE_PLAYBACK, 1,\n\t\t\t\t(dc->flags & V4L2_DEC_CMD_PAUSE_TO_BLACK) ? 1 : 0);\n\t\t\tset_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags);\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_DEC_CMD_RESUME:\n\t\tdc->flags = 0;\n\t\tif (try) break;\n\t\tif (!atomic_read(&itv->decoding))\n\t\t\treturn -EPERM;\n\t\tif (itv->output_mode != OUT_MPG)\n\t\t\treturn -EBUSY;\n\t\tif (test_and_clear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags)) {\n\t\t\tint speed = itv->speed;\n\t\t\titv->speed = 0;\n\t\t\treturn ivtv_start_decoding(id, speed);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\tif (!(itv->v4l2_cap & V4L2_CAP_SLICED_VBI_OUTPUT))\n\t\treturn -EINVAL;\n\tvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\tmemset(vbifmt->service_lines, 0, sizeof(vbifmt->service_lines));\n\tif (itv->is_60hz) {\n\t\tvbifmt->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\t\tvbifmt->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\t} else {\n\t\tvbifmt->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t\tvbifmt->service_lines[0][16] = V4L2_SLICED_VPS;\n\t}\n\tvbifmt->service_set = ivtv_get_service_set(vbifmt);\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\n\tpixfmt->width = itv->cxhdl.width;\n\tpixfmt->height = itv->cxhdl.height;\n\tpixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpixfmt->field = V4L2_FIELD_INTERLACED;\n\tif (id->type == IVTV_ENC_STREAM_TYPE_YUV) {\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_NV12_16L16;\n\t\t \n\t\tpixfmt->sizeimage = pixfmt->height * 720 * 3 / 2;\n\t\tpixfmt->bytesperline = 720;\n\t} else {\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\n\t\tpixfmt->sizeimage = 128 * 1024;\n\t\tpixfmt->bytesperline = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct v4l2_vbi_format *vbifmt = &fmt->fmt.vbi;\n\n\tvbifmt->sampling_rate = 27000000;\n\tvbifmt->offset = 248;\n\tvbifmt->samples_per_line = itv->vbi.raw_decoder_line_size - 4;\n\tvbifmt->sample_format = V4L2_PIX_FMT_GREY;\n\tvbifmt->start[0] = itv->vbi.start[0];\n\tvbifmt->start[1] = itv->vbi.start[1];\n\tvbifmt->count[0] = vbifmt->count[1] = itv->vbi.count;\n\tvbifmt->flags = 0;\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\tvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\n\tif (id->type == IVTV_DEC_STREAM_TYPE_VBI) {\n\t\tvbifmt->service_set = itv->is_50hz ? V4L2_SLICED_VBI_625 :\n\t\t\tV4L2_SLICED_VBI_525;\n\t\tivtv_expand_service_set(vbifmt, itv->is_50hz);\n\t\tvbifmt->service_set = ivtv_get_service_set(vbifmt);\n\t\treturn 0;\n\t}\n\n\tv4l2_subdev_call(itv->sd_video, vbi, g_sliced_fmt, vbifmt);\n\tvbifmt->service_set = ivtv_get_service_set(vbifmt);\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\tpixfmt->width = itv->main_rect.width;\n\tpixfmt->height = itv->main_rect.height;\n\tpixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpixfmt->field = V4L2_FIELD_INTERLACED;\n\tif (id->type == IVTV_DEC_STREAM_TYPE_YUV) {\n\t\tswitch (itv->yuv_info.lace_mode & IVTV_YUV_MODE_MASK) {\n\t\tcase IVTV_YUV_MODE_INTERLACED:\n\t\t\tpixfmt->field = (itv->yuv_info.lace_mode & IVTV_YUV_SYNC_MASK) ?\n\t\t\t\tV4L2_FIELD_INTERLACED_BT : V4L2_FIELD_INTERLACED_TB;\n\t\t\tbreak;\n\t\tcase IVTV_YUV_MODE_PROGRESSIVE:\n\t\t\tpixfmt->field = V4L2_FIELD_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpixfmt->field = V4L2_FIELD_ANY;\n\t\t\tbreak;\n\t\t}\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_NV12_16L16;\n\t\tpixfmt->bytesperline = 720;\n\t\tpixfmt->width = itv->yuv_info.v4l2_src_w;\n\t\tpixfmt->height = itv->yuv_info.v4l2_src_h;\n\t\t \n\t\tpixfmt->sizeimage =\n\t\t\t1080 * ((pixfmt->height + 31) & ~31);\n\t} else {\n\t\tpixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\n\t\tpixfmt->sizeimage = 128 * 1024;\n\t\tpixfmt->bytesperline = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_g_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\tstruct v4l2_window *winfmt = &fmt->fmt.win;\n\n\tif (!(s->vdev.device_caps & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\n\t\treturn -EINVAL;\n\tif (!itv->osd_video_pbase)\n\t\treturn -EINVAL;\n\twinfmt->chromakey = itv->osd_chroma_key;\n\twinfmt->global_alpha = itv->osd_global_alpha;\n\twinfmt->field = V4L2_FIELD_INTERLACED;\n\twinfmt->clips = NULL;\n\twinfmt->clipcount = 0;\n\twinfmt->bitmap = NULL;\n\twinfmt->w.top = winfmt->w.left = 0;\n\twinfmt->w.width = itv->osd_rect.width;\n\twinfmt->w.height = itv->osd_rect.height;\n\treturn 0;\n}\n\nstatic int ivtv_try_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\treturn ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);\n}\n\nstatic int ivtv_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tint w = fmt->fmt.pix.width;\n\tint h = fmt->fmt.pix.height;\n\tint min_h = 2;\n\n\tw = min(w, 720);\n\tw = max(w, 2);\n\tif (id->type == IVTV_ENC_STREAM_TYPE_YUV) {\n\t\t \n\t\th &= ~0x1f;\n\t\tmin_h = 32;\n\t}\n\th = min(h, itv->is_50hz ? 576 : 480);\n\th = max(h, min_h);\n\tivtv_g_fmt_vid_cap(file, fh, fmt);\n\tfmt->fmt.pix.width = w;\n\tfmt->fmt.pix.height = h;\n\treturn 0;\n}\n\nstatic int ivtv_try_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\treturn ivtv_g_fmt_vbi_cap(file, fh, fmt);\n}\n\nstatic int ivtv_try_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\n\tif (id->type == IVTV_DEC_STREAM_TYPE_VBI)\n\t\treturn ivtv_g_fmt_sliced_vbi_cap(file, fh, fmt);\n\n\t \n\tvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\tvbifmt->reserved[0] = 0;\n\tvbifmt->reserved[1] = 0;\n\n\tif (vbifmt->service_set)\n\t\tivtv_expand_service_set(vbifmt, itv->is_50hz);\n\tcheck_service_set(vbifmt, itv->is_50hz);\n\tvbifmt->service_set = ivtv_get_service_set(vbifmt);\n\treturn 0;\n}\n\nstatic int ivtv_try_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\ts32 w = fmt->fmt.pix.width;\n\ts32 h = fmt->fmt.pix.height;\n\tint field = fmt->fmt.pix.field;\n\tint ret = ivtv_g_fmt_vid_out(file, fh, fmt);\n\n\tw = min(w, 720);\n\tw = max(w, 2);\n\t \n\th = min(h, 576);\n\th = max(h, 2);\n\tif (id->type == IVTV_DEC_STREAM_TYPE_YUV)\n\t\tfmt->fmt.pix.field = field;\n\tfmt->fmt.pix.width = w;\n\tfmt->fmt.pix.height = h;\n\treturn ret;\n}\n\nstatic int ivtv_try_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\tu32 chromakey = fmt->fmt.win.chromakey;\n\tu8 global_alpha = fmt->fmt.win.global_alpha;\n\n\tif (!(s->vdev.device_caps & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\n\t\treturn -EINVAL;\n\tif (!itv->osd_video_pbase)\n\t\treturn -EINVAL;\n\tivtv_g_fmt_vid_out_overlay(file, fh, fmt);\n\tfmt->fmt.win.chromakey = chromakey;\n\tfmt->fmt.win.global_alpha = global_alpha;\n\treturn 0;\n}\n\nstatic int ivtv_s_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\treturn ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);\n}\n\nstatic int ivtv_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret = ivtv_try_fmt_vid_cap(file, fh, fmt);\n\tint w = fmt->fmt.pix.width;\n\tint h = fmt->fmt.pix.height;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (itv->cxhdl.width == w && itv->cxhdl.height == h)\n\t\treturn 0;\n\n\tif (atomic_read(&itv->capturing) > 0)\n\t\treturn -EBUSY;\n\n\titv->cxhdl.width = w;\n\titv->cxhdl.height = h;\n\tif (v4l2_ctrl_g_ctrl(itv->cxhdl.video_encoding) == V4L2_MPEG_VIDEO_ENCODING_MPEG_1)\n\t\tfmt->fmt.pix.width /= 2;\n\tformat.format.width = fmt->fmt.pix.width;\n\tformat.format.height = h;\n\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\tv4l2_subdev_call(itv->sd_video, pad, set_fmt, NULL, &format);\n\treturn ivtv_g_fmt_vid_cap(file, fh, fmt);\n}\n\nstatic int ivtv_s_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (!ivtv_raw_vbi(itv) && atomic_read(&itv->capturing) > 0)\n\t\treturn -EBUSY;\n\titv->vbi.sliced_in->service_set = 0;\n\titv->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tv4l2_subdev_call(itv->sd_video, vbi, s_raw_fmt, &fmt->fmt.vbi);\n\treturn ivtv_g_fmt_vbi_cap(file, fh, fmt);\n}\n\nstatic int ivtv_s_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tint ret = ivtv_try_fmt_sliced_vbi_cap(file, fh, fmt);\n\n\tif (ret || id->type == IVTV_DEC_STREAM_TYPE_VBI)\n\t\treturn ret;\n\n\tcheck_service_set(vbifmt, itv->is_50hz);\n\tif (ivtv_raw_vbi(itv) && atomic_read(&itv->capturing) > 0)\n\t\treturn -EBUSY;\n\titv->vbi.in.type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\n\tv4l2_subdev_call(itv->sd_video, vbi, s_sliced_fmt, vbifmt);\n\tmemcpy(itv->vbi.sliced_in, vbifmt, sizeof(*itv->vbi.sliced_in));\n\treturn 0;\n}\n\nstatic int ivtv_s_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\tint ret = ivtv_try_fmt_vid_out(file, fh, fmt);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (id->type != IVTV_DEC_STREAM_TYPE_YUV)\n\t\treturn 0;\n\n\t \n\tif (yi->stream_size)\n\t\treturn -EBUSY;\n\n\tyi->v4l2_src_w = fmt->fmt.pix.width;\n\tyi->v4l2_src_h = fmt->fmt.pix.height;\n\n\tswitch (fmt->fmt.pix.field) {\n\tcase V4L2_FIELD_NONE:\n\t\tyi->lace_mode = IVTV_YUV_MODE_PROGRESSIVE;\n\t\tbreak;\n\tcase V4L2_FIELD_ANY:\n\t\tyi->lace_mode = IVTV_YUV_MODE_AUTO;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tyi->lace_mode =\n\t\t\tIVTV_YUV_MODE_INTERLACED|IVTV_YUV_SYNC_ODD;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tdefault:\n\t\tyi->lace_mode = IVTV_YUV_MODE_INTERLACED;\n\t\tbreak;\n\t}\n\tyi->lace_sync_field = (yi->lace_mode & IVTV_YUV_SYNC_MASK) == IVTV_YUV_SYNC_EVEN ? 0 : 1;\n\n\tif (test_bit(IVTV_F_I_DEC_YUV, &itv->i_flags))\n\t\titv->dma_data_req_size =\n\t\t\t1080 * ((yi->v4l2_src_h + 31) & ~31);\n\n\treturn 0;\n}\n\nstatic int ivtv_s_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tint ret = ivtv_try_fmt_vid_out_overlay(file, fh, fmt);\n\n\tif (ret == 0) {\n\t\titv->osd_chroma_key = fmt->fmt.win.chromakey;\n\t\titv->osd_global_alpha = fmt->fmt.win.global_alpha;\n\t\tivtv_set_osd_alpha(itv);\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ivtv_itvc(struct ivtv *itv, bool get, u64 reg, u64 *val)\n{\n\tvolatile u8 __iomem *reg_start;\n\n\tif (reg & 0x3)\n\t\treturn -EINVAL;\n\tif (reg >= IVTV_REG_OFFSET && reg < IVTV_REG_OFFSET + IVTV_REG_SIZE)\n\t\treg_start = itv->reg_mem - IVTV_REG_OFFSET;\n\telse if (itv->has_cx23415 && reg >= IVTV_DECODER_OFFSET &&\n\t\t\treg < IVTV_DECODER_OFFSET + IVTV_DECODER_SIZE)\n\t\treg_start = itv->dec_mem - IVTV_DECODER_OFFSET;\n\telse if (reg < IVTV_ENCODER_SIZE)\n\t\treg_start = itv->enc_mem;\n\telse\n\t\treturn -EINVAL;\n\n\tif (get)\n\t\t*val = readl(reg + reg_start);\n\telse\n\t\twritel(*val, reg + reg_start);\n\treturn 0;\n}\n\nstatic int ivtv_g_register(struct file *file, void *fh, struct v4l2_dbg_register *reg)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\treg->size = 4;\n\treturn ivtv_itvc(itv, true, reg->reg, &reg->val);\n}\n\nstatic int ivtv_s_register(struct file *file, void *fh, const struct v4l2_dbg_register *reg)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tu64 val = reg->val;\n\n\treturn ivtv_itvc(itv, false, reg->reg, &val);\n}\n#endif\n\nstatic int ivtv_querycap(struct file *file, void *fh, struct v4l2_capability *vcap)\n{\n\tstruct ivtv_open_id *id = fh2id(file->private_data);\n\tstruct ivtv *itv = id->itv;\n\n\tstrscpy(vcap->driver, IVTV_DRIVER_NAME, sizeof(vcap->driver));\n\tstrscpy(vcap->card, itv->card_name, sizeof(vcap->card));\n\tvcap->capabilities = itv->v4l2_cap | V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int ivtv_enumaudio(struct file *file, void *fh, struct v4l2_audio *vin)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\treturn ivtv_get_audio_input(itv, vin->index, vin);\n}\n\nstatic int ivtv_g_audio(struct file *file, void *fh, struct v4l2_audio *vin)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tvin->index = itv->audio_input;\n\treturn ivtv_get_audio_input(itv, vin->index, vin);\n}\n\nstatic int ivtv_s_audio(struct file *file, void *fh, const struct v4l2_audio *vout)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (vout->index >= itv->nof_audio_inputs)\n\t\treturn -EINVAL;\n\n\titv->audio_input = vout->index;\n\tivtv_audio_set_io(itv);\n\n\treturn 0;\n}\n\nstatic int ivtv_enumaudout(struct file *file, void *fh, struct v4l2_audioout *vin)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\t \n\treturn ivtv_get_audio_output(itv, vin->index, vin);\n}\n\nstatic int ivtv_g_audout(struct file *file, void *fh, struct v4l2_audioout *vin)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tvin->index = 0;\n\treturn ivtv_get_audio_output(itv, vin->index, vin);\n}\n\nstatic int ivtv_s_audout(struct file *file, void *fh, const struct v4l2_audioout *vout)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (itv->card->video_outputs == NULL || vout->index != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int ivtv_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\t \n\treturn ivtv_get_input(itv, vin->index, vin);\n}\n\nstatic int ivtv_enum_output(struct file *file, void *fh, struct v4l2_output *vout)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\treturn ivtv_get_output(itv, vout->index, vout);\n}\n\nstatic int ivtv_g_pixelaspect(struct file *file, void *fh,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tf->numerator = itv->is_50hz ? 54 : 11;\n\t\tf->denominator = itv->is_50hz ? 59 : 10;\n\t} else if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tf->numerator = itv->is_out_50hz ? 54 : 11;\n\t\tf->denominator = itv->is_out_50hz ? 59 : 10;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ivtv_s_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *sel)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\tstruct v4l2_rect r = { 0, 0, 720, 0 };\n\tint streamtype = id->type;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    !(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_COMPOSE)\n\t\treturn -EINVAL;\n\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    !(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tr.height = itv->is_out_50hz ? 576 : 480;\n\tif (streamtype == IVTV_DEC_STREAM_TYPE_YUV && yi->track_osd) {\n\t\tr.width = yi->osd_full_w;\n\t\tr.height = yi->osd_full_h;\n\t}\n\tsel->r.width = clamp(sel->r.width, 16U, r.width);\n\tsel->r.height = clamp(sel->r.height, 16U, r.height);\n\tsel->r.left = clamp_t(unsigned, sel->r.left, 0, r.width - sel->r.width);\n\tsel->r.top = clamp_t(unsigned, sel->r.top, 0, r.height - sel->r.height);\n\n\tif (streamtype == IVTV_DEC_STREAM_TYPE_YUV) {\n\t\tyi->main_rect = sel->r;\n\t\treturn 0;\n\t}\n\tif (!ivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,\n\t\t\tsel->r.width, sel->r.height, sel->r.left, sel->r.top)) {\n\t\titv->main_rect = sel->r;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ivtv_g_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *sel)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\tstruct v4l2_rect r = { 0, 0, 720, 0 };\n\tint streamtype = id->type;\n\n\tif (sel->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tswitch (sel->target) {\n\t\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\t\tsel->r.top = sel->r.left = 0;\n\t\t\tsel->r.width = 720;\n\t\t\tsel->r.height = itv->is_50hz ? 576 : 480;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    !(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (streamtype == IVTV_DEC_STREAM_TYPE_YUV)\n\t\t\tsel->r = yi->main_rect;\n\t\telse\n\t\t\tsel->r = itv->main_rect;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tr.height = itv->is_out_50hz ? 576 : 480;\n\t\tif (streamtype == IVTV_DEC_STREAM_TYPE_YUV && yi->track_osd) {\n\t\t\tr.width = yi->osd_full_w;\n\t\t\tr.height = yi->osd_full_h;\n\t\t}\n\t\tsel->r = r;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ivtv_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\n{\n\tstatic const struct v4l2_fmtdesc hm12 = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.description = \"HM12 (YUV 4:2:0)\",\n\t\t.pixelformat = V4L2_PIX_FMT_NV12_16L16,\n\t};\n\tstatic const struct v4l2_fmtdesc mpeg = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.description = \"MPEG\",\n\t\t.pixelformat = V4L2_PIX_FMT_MPEG,\n\t};\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\n\tif (fmt->index)\n\t\treturn -EINVAL;\n\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG)\n\t\t*fmt = mpeg;\n\telse if (s->type == IVTV_ENC_STREAM_TYPE_YUV)\n\t\t*fmt = hm12;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int ivtv_enum_fmt_vid_out(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\n{\n\tstatic const struct v4l2_fmtdesc hm12 = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,\n\t\t.description = \"HM12 (YUV 4:2:0)\",\n\t\t.pixelformat = V4L2_PIX_FMT_NV12_16L16,\n\t};\n\tstatic const struct v4l2_fmtdesc mpeg = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.description = \"MPEG\",\n\t\t.pixelformat = V4L2_PIX_FMT_MPEG,\n\t};\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\n\tif (fmt->index)\n\t\treturn -EINVAL;\n\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\n\t\t*fmt = mpeg;\n\telse if (s->type == IVTV_DEC_STREAM_TYPE_YUV)\n\t\t*fmt = hm12;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int ivtv_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\t*i = itv->active_input;\n\n\treturn 0;\n}\n\nint ivtv_s_input(struct file *file, void *fh, unsigned int inp)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tv4l2_std_id std;\n\tint i;\n\n\tif (inp >= itv->nof_inputs)\n\t\treturn -EINVAL;\n\n\tif (inp == itv->active_input) {\n\t\tIVTV_DEBUG_INFO(\"Input unchanged\\n\");\n\t\treturn 0;\n\t}\n\n\tif (atomic_read(&itv->capturing) > 0) {\n\t\treturn -EBUSY;\n\t}\n\n\tIVTV_DEBUG_INFO(\"Changing input from %d to %d\\n\",\n\t\t\titv->active_input, inp);\n\n\titv->active_input = inp;\n\t \n\titv->audio_input = itv->card->video_inputs[inp].audio_index;\n\n\tif (itv->card->video_inputs[inp].video_type == IVTV_CARD_INPUT_VID_TUNER)\n\t\tstd = itv->tuner_std;\n\telse\n\t\tstd = V4L2_STD_ALL;\n\tfor (i = 0; i <= IVTV_ENC_STREAM_TYPE_VBI; i++)\n\t\titv->streams[i].vdev.tvnorms = std;\n\n\t \n\tivtv_mute(itv);\n\tivtv_video_set_io(itv);\n\tivtv_audio_set_io(itv);\n\tivtv_unmute(itv);\n\n\treturn 0;\n}\n\nstatic int ivtv_g_output(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\t*i = itv->active_output;\n\n\treturn 0;\n}\n\nstatic int ivtv_s_output(struct file *file, void *fh, unsigned int outp)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (outp >= itv->card->nof_outputs)\n\t\treturn -EINVAL;\n\n\tif (outp == itv->active_output) {\n\t\tIVTV_DEBUG_INFO(\"Output unchanged\\n\");\n\t\treturn 0;\n\t}\n\tIVTV_DEBUG_INFO(\"Changing output from %d to %d\\n\",\n\t\t   itv->active_output, outp);\n\n\titv->active_output = outp;\n\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_routing,\n\t\t\tSAA7127_INPUT_TYPE_NORMAL,\n\t\t\titv->card->video_outputs[outp].video_output, 0);\n\n\treturn 0;\n}\n\nstatic int ivtv_g_frequency(struct file *file, void *fh, struct v4l2_frequency *vf)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\n\tif (s->vdev.vfl_dir)\n\t\treturn -ENOTTY;\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\tivtv_call_all(itv, tuner, g_frequency, vf);\n\treturn 0;\n}\n\nint ivtv_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\n\tif (s->vdev.vfl_dir)\n\t\treturn -ENOTTY;\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\tivtv_mute(itv);\n\tIVTV_DEBUG_INFO(\"v4l2 ioctl: set frequency %d\\n\", vf->frequency);\n\tivtv_call_all(itv, tuner, s_frequency, vf);\n\tivtv_unmute(itv);\n\treturn 0;\n}\n\nstatic int ivtv_g_std(struct file *file, void *fh, v4l2_std_id *std)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\t*std = itv->std;\n\treturn 0;\n}\n\nvoid ivtv_s_std_enc(struct ivtv *itv, v4l2_std_id std)\n{\n\titv->std = std;\n\titv->is_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\n\titv->is_50hz = !itv->is_60hz;\n\tcx2341x_handler_set_50hz(&itv->cxhdl, itv->is_50hz);\n\titv->cxhdl.width = 720;\n\titv->cxhdl.height = itv->is_50hz ? 576 : 480;\n\titv->vbi.count = itv->is_50hz ? 18 : 12;\n\titv->vbi.start[0] = itv->is_50hz ? 6 : 10;\n\titv->vbi.start[1] = itv->is_50hz ? 318 : 273;\n\n\tif (itv->hw_flags & IVTV_HW_CX25840)\n\t\titv->vbi.sliced_decoder_line_size = itv->is_60hz ? 272 : 284;\n\n\t \n\tivtv_call_all(itv, video, s_std, itv->std);\n}\n\nvoid ivtv_s_std_dec(struct ivtv *itv, v4l2_std_id std)\n{\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\tDEFINE_WAIT(wait);\n\tint f;\n\n\t \n\titv->std_out = std;\n\titv->is_out_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\n\titv->is_out_50hz = !itv->is_out_60hz;\n\tivtv_call_all(itv, video, s_std_output, itv->std_out);\n\n\t \n\tmutex_unlock(&itv->serialize_lock);\n\tfor (f = 0; f < 4; f++) {\n\t\tprepare_to_wait(&itv->vsync_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif ((read_reg(IVTV_REG_DEC_LINE_FIELD) >> 16) < 100)\n\t\t\tbreak;\n\t\tschedule_timeout(msecs_to_jiffies(25));\n\t}\n\tfinish_wait(&itv->vsync_waitq, &wait);\n\tmutex_lock(&itv->serialize_lock);\n\n\tif (f == 4)\n\t\tIVTV_WARN(\"Mode change failed to sync to decoder\\n\");\n\n\tivtv_vapi(itv, CX2341X_DEC_SET_STANDARD, 1, itv->is_out_50hz);\n\titv->main_rect.left = 0;\n\titv->main_rect.top = 0;\n\titv->main_rect.width = 720;\n\titv->main_rect.height = itv->is_out_50hz ? 576 : 480;\n\tivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,\n\t\t720, itv->main_rect.height, 0, 0);\n\tyi->main_rect = itv->main_rect;\n\tif (!itv->osd_info) {\n\t\tyi->osd_full_w = 720;\n\t\tyi->osd_full_h = itv->is_out_50hz ? 576 : 480;\n\t}\n}\n\nstatic int ivtv_s_std(struct file *file, void *fh, v4l2_std_id std)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif ((std & V4L2_STD_ALL) == 0)\n\t\treturn -EINVAL;\n\n\tif (std == itv->std)\n\t\treturn 0;\n\n\tif (test_bit(IVTV_F_I_RADIO_USER, &itv->i_flags) ||\n\t    atomic_read(&itv->capturing) > 0 ||\n\t    atomic_read(&itv->decoding) > 0) {\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\tIVTV_DEBUG_INFO(\"Switching standard to %llx.\\n\",\n\t\t(unsigned long long)itv->std);\n\n\tivtv_s_std_enc(itv, std);\n\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)\n\t\tivtv_s_std_dec(itv, std);\n\n\treturn 0;\n}\n\nstatic int ivtv_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;\n\n\tivtv_call_all(itv, tuner, s_tuner, vt);\n\n\treturn 0;\n}\n\nstatic int ivtv_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;\n\n\tivtv_call_all(itv, tuner, g_tuner, vt);\n\n\tif (vt->type == V4L2_TUNER_RADIO)\n\t\tstrscpy(vt->name, \"ivtv Radio Tuner\", sizeof(vt->name));\n\telse\n\t\tstrscpy(vt->name, \"ivtv TV Tuner\", sizeof(vt->name));\n\treturn 0;\n}\n\nstatic int ivtv_g_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_sliced_vbi_cap *cap)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tint set = itv->is_50hz ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525;\n\tint f, l;\n\n\tif (cap->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE) {\n\t\tfor (f = 0; f < 2; f++) {\n\t\t\tfor (l = 0; l < 24; l++) {\n\t\t\t\tif (valid_service_line(f, l, itv->is_50hz))\n\t\t\t\t\tcap->service_lines[f][l] = set;\n\t\t\t}\n\t\t}\n\t} else if (cap->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {\n\t\tif (!(itv->v4l2_cap & V4L2_CAP_SLICED_VBI_OUTPUT))\n\t\t\treturn -EINVAL;\n\t\tif (itv->is_60hz) {\n\t\t\tcap->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\t\t\tcap->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\t\t} else {\n\t\t\tcap->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t\t\tcap->service_lines[0][16] = V4L2_SLICED_VPS;\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (f = 0; f < 2; f++)\n\t\tfor (l = 0; l < 24; l++)\n\t\t\tset |= cap->service_lines[f][l];\n\tcap->service_set = set;\n\treturn 0;\n}\n\nstatic int ivtv_g_enc_index(struct file *file, void *fh, struct v4l2_enc_idx *idx)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct v4l2_enc_idx_entry *e = idx->entry;\n\tint entries;\n\tint i;\n\n\tentries = (itv->pgm_info_write_idx + IVTV_MAX_PGM_INDEX - itv->pgm_info_read_idx) %\n\t\t\t\tIVTV_MAX_PGM_INDEX;\n\tif (entries > V4L2_ENC_IDX_ENTRIES)\n\t\tentries = V4L2_ENC_IDX_ENTRIES;\n\tidx->entries = 0;\n\tidx->entries_cap = IVTV_MAX_PGM_INDEX;\n\tif (!atomic_read(&itv->capturing))\n\t\treturn 0;\n\tfor (i = 0; i < entries; i++) {\n\t\t*e = itv->pgm_info[(itv->pgm_info_read_idx + i) % IVTV_MAX_PGM_INDEX];\n\t\tif ((e->flags & V4L2_ENC_IDX_FRAME_MASK) <= V4L2_ENC_IDX_FRAME_B) {\n\t\t\tidx->entries++;\n\t\t\te++;\n\t\t}\n\t}\n\titv->pgm_info_read_idx = (itv->pgm_info_read_idx + idx->entries) % IVTV_MAX_PGM_INDEX;\n\treturn 0;\n}\n\nstatic int ivtv_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *enc)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\n\n\tswitch (enc->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_START\\n\");\n\t\tenc->flags = 0;\n\t\treturn ivtv_start_capture(id);\n\n\tcase V4L2_ENC_CMD_STOP:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_STOP\\n\");\n\t\tenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\n\t\tivtv_stop_capture(id, enc->flags & V4L2_ENC_CMD_STOP_AT_GOP_END);\n\t\treturn 0;\n\n\tcase V4L2_ENC_CMD_PAUSE:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_PAUSE\\n\");\n\t\tenc->flags = 0;\n\n\t\tif (!atomic_read(&itv->capturing))\n\t\t\treturn -EPERM;\n\t\tif (test_and_set_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\n\t\t\treturn 0;\n\n\t\tivtv_mute(itv);\n\t\tivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 0);\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_RESUME:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_RESUME\\n\");\n\t\tenc->flags = 0;\n\n\t\tif (!atomic_read(&itv->capturing))\n\t\t\treturn -EPERM;\n\n\t\tif (!test_and_clear_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\n\t\t\treturn 0;\n\n\t\tivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 1);\n\t\tivtv_unmute(itv);\n\t\tbreak;\n\tdefault:\n\t\tIVTV_DEBUG_IOCTL(\"Unknown cmd %d\\n\", enc->cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ivtv_try_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *enc)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tswitch (enc->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_START\\n\");\n\t\tenc->flags = 0;\n\t\treturn 0;\n\n\tcase V4L2_ENC_CMD_STOP:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_STOP\\n\");\n\t\tenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\n\t\treturn 0;\n\n\tcase V4L2_ENC_CMD_PAUSE:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_PAUSE\\n\");\n\t\tenc->flags = 0;\n\t\treturn 0;\n\n\tcase V4L2_ENC_CMD_RESUME:\n\t\tIVTV_DEBUG_IOCTL(\"V4L2_ENC_CMD_RESUME\\n\");\n\t\tenc->flags = 0;\n\t\treturn 0;\n\tdefault:\n\t\tIVTV_DEBUG_IOCTL(\"Unknown cmd %d\\n\", enc->cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ivtv_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\n\tint pixfmt;\n\tstatic u32 pixel_format[16] = {\n\t\tV4L2_PIX_FMT_PAL8,  \n\t\tV4L2_PIX_FMT_RGB565,\n\t\tV4L2_PIX_FMT_RGB555,\n\t\tV4L2_PIX_FMT_RGB444,\n\t\tV4L2_PIX_FMT_RGB32,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\tV4L2_PIX_FMT_PAL8,  \n\t\tV4L2_PIX_FMT_YUV565,\n\t\tV4L2_PIX_FMT_YUV555,\n\t\tV4L2_PIX_FMT_YUV444,\n\t\tV4L2_PIX_FMT_YUV32,\n\t\t0,\n\t\t0,\n\t\t0,\n\t};\n\n\tif (!(s->vdev.device_caps & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\n\t\treturn -ENOTTY;\n\tif (!itv->osd_video_pbase)\n\t\treturn -ENOTTY;\n\n\tfb->capability = V4L2_FBUF_CAP_EXTERNOVERLAY | V4L2_FBUF_CAP_CHROMAKEY |\n\t\tV4L2_FBUF_CAP_GLOBAL_ALPHA;\n\n\tivtv_vapi_result(itv, data, CX2341X_OSD_GET_STATE, 0);\n\tdata[0] |= (read_reg(0x2a00) >> 7) & 0x40;\n\tpixfmt = (data[0] >> 3) & 0xf;\n\n\tfb->fmt.pixelformat = pixel_format[pixfmt];\n\tfb->fmt.width = itv->osd_rect.width;\n\tfb->fmt.height = itv->osd_rect.height;\n\tfb->fmt.field = V4L2_FIELD_INTERLACED;\n\tfb->fmt.bytesperline = fb->fmt.width;\n\tfb->fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tfb->fmt.field = V4L2_FIELD_INTERLACED;\n\tif (fb->fmt.pixelformat != V4L2_PIX_FMT_PAL8)\n\t\tfb->fmt.bytesperline *= 2;\n\tif (fb->fmt.pixelformat == V4L2_PIX_FMT_RGB32 ||\n\t    fb->fmt.pixelformat == V4L2_PIX_FMT_YUV32)\n\t\tfb->fmt.bytesperline *= 2;\n\tfb->fmt.sizeimage = fb->fmt.bytesperline * fb->fmt.height;\n\tfb->base = (void *)itv->osd_video_pbase;\n\tfb->flags = 0;\n\n\tif (itv->osd_chroma_key_state)\n\t\tfb->flags |= V4L2_FBUF_FLAG_CHROMAKEY;\n\n\tif (itv->osd_global_alpha_state)\n\t\tfb->flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;\n\n\tif (yi->track_osd)\n\t\tfb->flags |= V4L2_FBUF_FLAG_OVERLAY;\n\n\tpixfmt &= 7;\n\n\t \n\tif (pixfmt == 1 || pixfmt > 4)\n\t\treturn 0;\n\n\t \n\tif (pixfmt == 2 || pixfmt == 3)\n\t\tfb->capability |= V4L2_FBUF_CAP_LOCAL_INV_ALPHA;\n\telse\n\t\tfb->capability |= V4L2_FBUF_CAP_LOCAL_ALPHA;\n\n\tif (itv->osd_local_alpha_state) {\n\t\t \n\t\tif (pixfmt == 2 || pixfmt == 3)\n\t\t\tfb->flags |= V4L2_FBUF_FLAG_LOCAL_INV_ALPHA;\n\t\telse\n\t\t\tfb->flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\n\t}\n\n\treturn 0;\n}\n\nstatic int ivtv_s_fbuf(struct file *file, void *fh, const struct v4l2_framebuffer *fb)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\n\tif (!(s->vdev.device_caps & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\n\t\treturn -ENOTTY;\n\tif (!itv->osd_video_pbase)\n\t\treturn -ENOTTY;\n\n\titv->osd_global_alpha_state = (fb->flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) != 0;\n\titv->osd_local_alpha_state =\n\t\t(fb->flags & (V4L2_FBUF_FLAG_LOCAL_ALPHA|V4L2_FBUF_FLAG_LOCAL_INV_ALPHA)) != 0;\n\titv->osd_chroma_key_state = (fb->flags & V4L2_FBUF_FLAG_CHROMAKEY) != 0;\n\tivtv_set_osd_alpha(itv);\n\tyi->track_osd = (fb->flags & V4L2_FBUF_FLAG_OVERLAY) != 0;\n\treturn 0;\n}\n\nstatic int ivtv_overlay(struct file *file, void *fh, unsigned int on)\n{\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\n\n\tif (!(s->vdev.device_caps & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\n\t\treturn -ENOTTY;\n\tif (!itv->osd_video_pbase)\n\t\treturn -ENOTTY;\n\n\tivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, on != 0);\n\n\treturn 0;\n}\n\nstatic int ivtv_subscribe_event(struct v4l2_fh *fh, const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_VSYNC:\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic int ivtv_log_status(struct file *file, void *fh)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\n\tint has_output = itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT;\n\tstruct v4l2_input vidin;\n\tstruct v4l2_audio audin;\n\tint i;\n\n\tIVTV_INFO(\"Version: %s Card: %s\\n\", IVTV_VERSION, itv->card_name);\n\tif (itv->hw_flags & IVTV_HW_TVEEPROM) {\n\t\tstruct tveeprom tv;\n\n\t\tivtv_read_eeprom(itv, &tv);\n\t}\n\tivtv_call_all(itv, core, log_status);\n\tivtv_get_input(itv, itv->active_input, &vidin);\n\tivtv_get_audio_input(itv, itv->audio_input, &audin);\n\tIVTV_INFO(\"Video Input:  %s\\n\", vidin.name);\n\tIVTV_INFO(\"Audio Input:  %s%s\\n\", audin.name,\n\t\titv->dualwatch_stereo_mode == V4L2_MPEG_AUDIO_MODE_DUAL ?\n\t\t\t\" (Bilingual)\" : \"\");\n\tif (has_output) {\n\t\tstruct v4l2_output vidout;\n\t\tstruct v4l2_audioout audout;\n\t\tint mode = itv->output_mode;\n\t\tstatic const char * const output_modes[5] = {\n\t\t\t\"None\",\n\t\t\t\"MPEG Streaming\",\n\t\t\t\"YUV Streaming\",\n\t\t\t\"YUV Frames\",\n\t\t\t\"Passthrough\",\n\t\t};\n\t\tstatic const char * const alpha_mode[4] = {\n\t\t\t\"None\",\n\t\t\t\"Global\",\n\t\t\t\"Local\",\n\t\t\t\"Global and Local\"\n\t\t};\n\t\tstatic const char * const pixel_format[16] = {\n\t\t\t\"ARGB Indexed\",\n\t\t\t\"RGB 5:6:5\",\n\t\t\t\"ARGB 1:5:5:5\",\n\t\t\t\"ARGB 1:4:4:4\",\n\t\t\t\"ARGB 8:8:8:8\",\n\t\t\t\"5\",\n\t\t\t\"6\",\n\t\t\t\"7\",\n\t\t\t\"AYUV Indexed\",\n\t\t\t\"YUV 5:6:5\",\n\t\t\t\"AYUV 1:5:5:5\",\n\t\t\t\"AYUV 1:4:4:4\",\n\t\t\t\"AYUV 8:8:8:8\",\n\t\t\t\"13\",\n\t\t\t\"14\",\n\t\t\t\"15\",\n\t\t};\n\n\t\tivtv_get_output(itv, itv->active_output, &vidout);\n\t\tivtv_get_audio_output(itv, 0, &audout);\n\t\tIVTV_INFO(\"Video Output: %s\\n\", vidout.name);\n\t\tif (mode < 0 || mode > OUT_PASSTHROUGH)\n\t\t\tmode = OUT_NONE;\n\t\tIVTV_INFO(\"Output Mode:  %s\\n\", output_modes[mode]);\n\t\tivtv_vapi_result(itv, data, CX2341X_OSD_GET_STATE, 0);\n\t\tdata[0] |= (read_reg(0x2a00) >> 7) & 0x40;\n\t\tIVTV_INFO(\"Overlay:      %s, Alpha: %s, Pixel Format: %s\\n\",\n\t\t\tdata[0] & 1 ? \"On\" : \"Off\",\n\t\t\talpha_mode[(data[0] >> 1) & 0x3],\n\t\t\tpixel_format[(data[0] >> 3) & 0xf]);\n\t}\n\tIVTV_INFO(\"Tuner:  %s\\n\",\n\t\ttest_bit(IVTV_F_I_RADIO_USER, &itv->i_flags) ? \"Radio\" : \"TV\");\n\tv4l2_ctrl_handler_log_status(&itv->cxhdl.hdl, itv->v4l2_dev.name);\n\tIVTV_INFO(\"Status flags:    0x%08lx\\n\", itv->i_flags);\n\tfor (i = 0; i < IVTV_MAX_STREAMS; i++) {\n\t\tstruct ivtv_stream *s = &itv->streams[i];\n\n\t\tif (s->vdev.v4l2_dev == NULL || s->buffers == 0)\n\t\t\tcontinue;\n\t\tIVTV_INFO(\"Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\\n\", s->name, s->s_flags,\n\t\t\t\t(s->buffers - s->q_free.buffers) * 100 / s->buffers,\n\t\t\t\t(s->buffers * s->buf_size) / 1024, s->buffers);\n\t}\n\n\tIVTV_INFO(\"Read MPG/VBI: %lld/%lld bytes\\n\",\n\t\t\t(long long)itv->mpg_data_received,\n\t\t\t(long long)itv->vbi_data_inserted);\n\treturn 0;\n}\n\nstatic int ivtv_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *dec)\n{\n\tstruct ivtv_open_id *id = fh2id(file->private_data);\n\tstruct ivtv *itv = id->itv;\n\n\tIVTV_DEBUG_IOCTL(\"VIDIOC_DECODER_CMD %d\\n\", dec->cmd);\n\treturn ivtv_video_command(itv, id, dec, false);\n}\n\nstatic int ivtv_try_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *dec)\n{\n\tstruct ivtv_open_id *id = fh2id(file->private_data);\n\tstruct ivtv *itv = id->itv;\n\n\tIVTV_DEBUG_IOCTL(\"VIDIOC_TRY_DECODER_CMD %d\\n\", dec->cmd);\n\treturn ivtv_video_command(itv, id, dec, true);\n}\n\nstatic int ivtv_decoder_ioctls(struct file *filp, unsigned int cmd, void *arg)\n{\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\n\tswitch (cmd) {\n\tcase IVTV_IOC_DMA_FRAME: {\n\t\tstruct ivtv_dma_frame *args = arg;\n\n\t\tIVTV_DEBUG_IOCTL(\"IVTV_IOC_DMA_FRAME\\n\");\n\t\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\t\treturn -EINVAL;\n\t\tif (args->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tif (itv->output_mode == OUT_UDMA_YUV && args->y_source == NULL)\n\t\t\treturn 0;\n\t\tif (ivtv_start_decoding(id, id->type)) {\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (ivtv_set_output_mode(itv, OUT_UDMA_YUV) != OUT_UDMA_YUV) {\n\t\t\tivtv_release_stream(s);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tid->yuv_frames = 1;\n\t\tif (args->y_source == NULL)\n\t\t\treturn 0;\n\t\treturn ivtv_yuv_prep_frame(itv, args);\n\t}\n\n\tcase IVTV_IOC_PASSTHROUGH_MODE:\n\t\tIVTV_DEBUG_IOCTL(\"IVTV_IOC_PASSTHROUGH_MODE\\n\");\n\t\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\t\treturn -EINVAL;\n\t\treturn ivtv_passthrough_mode(itv, *(int *)arg != 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic long ivtv_default(struct file *file, void *fh, bool valid_prio,\n\t\t\t unsigned int cmd, void *arg)\n{\n\tstruct ivtv *itv = fh2id(fh)->itv;\n\n\tif (!valid_prio) {\n\t\tswitch (cmd) {\n\t\tcase IVTV_IOC_PASSTHROUGH_MODE:\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase VIDIOC_INT_RESET: {\n\t\tu32 val = *(u32 *)arg;\n\n\t\tif ((val == 0 && itv->options.newi2c) || (val & 0x01))\n\t\t\tivtv_reset_ir_gpio(itv);\n\t\tif (val & 0x02)\n\t\t\tv4l2_subdev_call(itv->sd_video, core, reset, 0);\n\t\tbreak;\n\t}\n\n\tcase IVTV_IOC_DMA_FRAME:\n\tcase IVTV_IOC_PASSTHROUGH_MODE:\n\t\treturn ivtv_decoder_ioctls(file, cmd, (void *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops ivtv_ioctl_ops = {\n\t.vidioc_querycap\t\t    = ivtv_querycap,\n\t.vidioc_s_audio\t\t\t    = ivtv_s_audio,\n\t.vidioc_g_audio\t\t\t    = ivtv_g_audio,\n\t.vidioc_enumaudio\t\t    = ivtv_enumaudio,\n\t.vidioc_s_audout\t\t    = ivtv_s_audout,\n\t.vidioc_g_audout\t\t    = ivtv_g_audout,\n\t.vidioc_enum_input\t\t    = ivtv_enum_input,\n\t.vidioc_enum_output\t\t    = ivtv_enum_output,\n\t.vidioc_enumaudout\t\t    = ivtv_enumaudout,\n\t.vidioc_g_pixelaspect\t\t    = ivtv_g_pixelaspect,\n\t.vidioc_s_selection\t\t    = ivtv_s_selection,\n\t.vidioc_g_selection\t\t    = ivtv_g_selection,\n\t.vidioc_g_input\t\t\t    = ivtv_g_input,\n\t.vidioc_s_input\t\t\t    = ivtv_s_input,\n\t.vidioc_g_output\t\t    = ivtv_g_output,\n\t.vidioc_s_output\t\t    = ivtv_s_output,\n\t.vidioc_g_frequency\t\t    = ivtv_g_frequency,\n\t.vidioc_s_frequency\t\t    = ivtv_s_frequency,\n\t.vidioc_s_tuner\t\t\t    = ivtv_s_tuner,\n\t.vidioc_g_tuner\t\t\t    = ivtv_g_tuner,\n\t.vidioc_g_enc_index\t\t    = ivtv_g_enc_index,\n\t.vidioc_g_fbuf\t\t\t    = ivtv_g_fbuf,\n\t.vidioc_s_fbuf\t\t\t    = ivtv_s_fbuf,\n\t.vidioc_g_std\t\t\t    = ivtv_g_std,\n\t.vidioc_s_std\t\t\t    = ivtv_s_std,\n\t.vidioc_overlay\t\t\t    = ivtv_overlay,\n\t.vidioc_log_status\t\t    = ivtv_log_status,\n\t.vidioc_enum_fmt_vid_cap\t    = ivtv_enum_fmt_vid_cap,\n\t.vidioc_encoder_cmd\t\t    = ivtv_encoder_cmd,\n\t.vidioc_try_encoder_cmd\t\t    = ivtv_try_encoder_cmd,\n\t.vidioc_decoder_cmd\t\t    = ivtv_decoder_cmd,\n\t.vidioc_try_decoder_cmd\t\t    = ivtv_try_decoder_cmd,\n\t.vidioc_enum_fmt_vid_out\t    = ivtv_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap\t\t    = ivtv_g_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap\t\t    = ivtv_g_fmt_vbi_cap,\n\t.vidioc_g_fmt_sliced_vbi_cap        = ivtv_g_fmt_sliced_vbi_cap,\n\t.vidioc_g_fmt_vid_out               = ivtv_g_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out_overlay       = ivtv_g_fmt_vid_out_overlay,\n\t.vidioc_g_fmt_sliced_vbi_out        = ivtv_g_fmt_sliced_vbi_out,\n\t.vidioc_s_fmt_vid_cap\t\t    = ivtv_s_fmt_vid_cap,\n\t.vidioc_s_fmt_vbi_cap\t\t    = ivtv_s_fmt_vbi_cap,\n\t.vidioc_s_fmt_sliced_vbi_cap        = ivtv_s_fmt_sliced_vbi_cap,\n\t.vidioc_s_fmt_vid_out               = ivtv_s_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out_overlay       = ivtv_s_fmt_vid_out_overlay,\n\t.vidioc_s_fmt_sliced_vbi_out        = ivtv_s_fmt_sliced_vbi_out,\n\t.vidioc_try_fmt_vid_cap\t\t    = ivtv_try_fmt_vid_cap,\n\t.vidioc_try_fmt_vbi_cap\t\t    = ivtv_try_fmt_vbi_cap,\n\t.vidioc_try_fmt_sliced_vbi_cap      = ivtv_try_fmt_sliced_vbi_cap,\n\t.vidioc_try_fmt_vid_out\t\t    = ivtv_try_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out_overlay     = ivtv_try_fmt_vid_out_overlay,\n\t.vidioc_try_fmt_sliced_vbi_out\t    = ivtv_try_fmt_sliced_vbi_out,\n\t.vidioc_g_sliced_vbi_cap\t    = ivtv_g_sliced_vbi_cap,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t\t    = ivtv_g_register,\n\t.vidioc_s_register\t\t    = ivtv_s_register,\n#endif\n\t.vidioc_default\t\t\t    = ivtv_default,\n\t.vidioc_subscribe_event\t\t    = ivtv_subscribe_event,\n\t.vidioc_unsubscribe_event\t    = v4l2_event_unsubscribe,\n};\n\nvoid ivtv_set_funcs(struct video_device *vdev)\n{\n\tvdev->ioctl_ops = &ivtv_ioctl_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}