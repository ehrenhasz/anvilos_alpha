{
  "module_name": "ivtv-vbi.c",
  "hash_id": "582b1c230e7d0b5b918b6a1bf0097c90a315b6a434c6c548ce7b6a9f827c2264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-vbi.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-i2c.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-vbi.h\"\n\nstatic void ivtv_set_vps(struct ivtv *itv, int enabled)\n{\n\tstruct v4l2_sliced_vbi_data data;\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn;\n\tdata.id = V4L2_SLICED_VPS;\n\tdata.field = 0;\n\tdata.line = enabled ? 16 : 0;\n\tdata.data[2] = itv->vbi.vps_payload.data[0];\n\tdata.data[8] = itv->vbi.vps_payload.data[1];\n\tdata.data[9] = itv->vbi.vps_payload.data[2];\n\tdata.data[10] = itv->vbi.vps_payload.data[3];\n\tdata.data[11] = itv->vbi.vps_payload.data[4];\n\tivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\n}\n\nstatic void ivtv_set_cc(struct ivtv *itv, int mode, const struct vbi_cc *cc)\n{\n\tstruct v4l2_sliced_vbi_data data;\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn;\n\tdata.id = V4L2_SLICED_CAPTION_525;\n\tdata.field = 0;\n\tdata.line = (mode & 1) ? 21 : 0;\n\tdata.data[0] = cc->odd[0];\n\tdata.data[1] = cc->odd[1];\n\tivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\n\tdata.field = 1;\n\tdata.line = (mode & 2) ? 21 : 0;\n\tdata.data[0] = cc->even[0];\n\tdata.data[1] = cc->even[1];\n\tivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\n}\n\nstatic void ivtv_set_wss(struct ivtv *itv, int enabled, int mode)\n{\n\tstruct v4l2_sliced_vbi_data data;\n\n\tif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn;\n\t \n\tif ((itv->std_out & V4L2_STD_625_50) && !enabled) {\n\t\tenabled = 1;\n\t\tmode = 0x08;   \n\t}\n\tdata.id = V4L2_SLICED_WSS_625;\n\tdata.field = 0;\n\tdata.line = enabled ? 23 : 0;\n\tdata.data[0] = mode & 0xff;\n\tdata.data[1] = (mode >> 8) & 0xff;\n\tivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\n}\n\nstatic int odd_parity(u8 c)\n{\n\tc ^= (c >> 4);\n\tc ^= (c >> 2);\n\tc ^= (c >> 1);\n\n\treturn c & 1;\n}\n\nstatic void ivtv_write_vbi_line(struct ivtv *itv,\n\t\t\t\tconst struct v4l2_sliced_vbi_data *d,\n\t\t\t\tstruct vbi_cc *cc, int *found_cc)\n{\n\tstruct vbi_info *vi = &itv->vbi;\n\n\tif (d->id == V4L2_SLICED_CAPTION_525 && d->line == 21) {\n\t\tif (d->field) {\n\t\t\tcc->even[0] = d->data[0];\n\t\t\tcc->even[1] = d->data[1];\n\t\t} else {\n\t\t\tcc->odd[0] = d->data[0];\n\t\t\tcc->odd[1] = d->data[1];\n\t\t}\n\t\t*found_cc = 1;\n\t} else if (d->id == V4L2_SLICED_VPS && d->line == 16 && d->field == 0) {\n\t\tstruct vbi_vps vps;\n\n\t\tvps.data[0] = d->data[2];\n\t\tvps.data[1] = d->data[8];\n\t\tvps.data[2] = d->data[9];\n\t\tvps.data[3] = d->data[10];\n\t\tvps.data[4] = d->data[11];\n\t\tif (memcmp(&vps, &vi->vps_payload, sizeof(vps))) {\n\t\t\tvi->vps_payload = vps;\n\t\t\tset_bit(IVTV_F_I_UPDATE_VPS, &itv->i_flags);\n\t\t}\n\t} else if (d->id == V4L2_SLICED_WSS_625 &&\n\t\t   d->line == 23 && d->field == 0) {\n\t\tint wss = d->data[0] | d->data[1] << 8;\n\n\t\tif (vi->wss_payload != wss) {\n\t\t\tvi->wss_payload = wss;\n\t\t\tset_bit(IVTV_F_I_UPDATE_WSS, &itv->i_flags);\n\t\t}\n\t}\n}\n\nstatic void ivtv_write_vbi_cc_lines(struct ivtv *itv, const struct vbi_cc *cc)\n{\n\tstruct vbi_info *vi = &itv->vbi;\n\n\tif (vi->cc_payload_idx < ARRAY_SIZE(vi->cc_payload)) {\n\t\tmemcpy(&vi->cc_payload[vi->cc_payload_idx], cc,\n\t\t       sizeof(struct vbi_cc));\n\t\tvi->cc_payload_idx++;\n\t\tset_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\n\t}\n}\n\nstatic void ivtv_write_vbi(struct ivtv *itv,\n\t\t\t   const struct v4l2_sliced_vbi_data *sliced,\n\t\t\t   size_t cnt)\n{\n\tstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\n\tint found_cc = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tivtv_write_vbi_line(itv, sliced + i, &cc, &found_cc);\n\n\tif (found_cc)\n\t\tivtv_write_vbi_cc_lines(itv, &cc);\n}\n\nssize_t\nivtv_write_vbi_from_user(struct ivtv *itv,\n\t\t\t const struct v4l2_sliced_vbi_data __user *sliced,\n\t\t\t size_t cnt)\n{\n\tstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\n\tint found_cc = 0;\n\tsize_t i;\n\tstruct v4l2_sliced_vbi_data d;\n\tssize_t ret = cnt * sizeof(struct v4l2_sliced_vbi_data);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (copy_from_user(&d, sliced + i,\n\t\t\t\t   sizeof(struct v4l2_sliced_vbi_data))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tivtv_write_vbi_line(itv, &d, &cc, &found_cc);\n\t}\n\n\tif (found_cc)\n\t\tivtv_write_vbi_cc_lines(itv, &cc);\n\n\treturn ret;\n}\n\nstatic void copy_vbi_data(struct ivtv *itv, int lines, u32 pts_stamp)\n{\n\tint line = 0;\n\tint i;\n\tu32 linemask[2] = { 0, 0 };\n\tunsigned short size;\n\tstatic const u8 mpeg_hdr_data[] = {\n\t\t0x00, 0x00, 0x01, 0xba, 0x44, 0x00, 0x0c, 0x66,\n\t\t0x24, 0x01, 0x01, 0xd1, 0xd3, 0xfa, 0xff, 0xff,\n\t\t0x00, 0x00, 0x01, 0xbd, 0x00, 0x1a, 0x84, 0x80,\n\t\t0x07, 0x21, 0x00, 0x5d, 0x63, 0xa7, 0xff, 0xff\n\t};\n\tconst int sd = sizeof(mpeg_hdr_data);\t \n\tint idx = itv->vbi.frame % IVTV_VBI_FRAMES;\n\tu8 *dst = &itv->vbi.sliced_mpeg_data[idx][0];\n\n\tfor (i = 0; i < lines; i++) {\n\t\tint f, l;\n\n\t\tif (itv->vbi.sliced_data[i].id == 0)\n\t\t\tcontinue;\n\n\t\tl = itv->vbi.sliced_data[i].line - 6;\n\t\tf = itv->vbi.sliced_data[i].field;\n\t\tif (f)\n\t\t\tl += 18;\n\t\tif (l < 32)\n\t\t\tlinemask[0] |= (1 << l);\n\t\telse\n\t\t\tlinemask[1] |= (1 << (l - 32));\n\t\tdst[sd + 12 + line * 43] =\n\t\t\tivtv_service2vbi(itv->vbi.sliced_data[i].id);\n\t\tmemcpy(dst + sd + 12 + line * 43 + 1, itv->vbi.sliced_data[i].data, 42);\n\t\tline++;\n\t}\n\tmemcpy(dst, mpeg_hdr_data, sizeof(mpeg_hdr_data));\n\tif (line == 36) {\n\t\t \n\t\tmemcpy(dst + sd, \"ITV0\", 4);\n\t\tmemmove(dst + sd + 4, dst + sd + 12, line * 43);\n\t\tsize = 4 + ((43 * line + 3) & ~3);\n\t} else {\n\t\tmemcpy(dst + sd, \"itv0\", 4);\n\t\tcpu_to_le32s(&linemask[0]);\n\t\tcpu_to_le32s(&linemask[1]);\n\t\tmemcpy(dst + sd + 4, &linemask[0], 8);\n\t\tsize = 12 + ((43 * line + 3) & ~3);\n\t}\n\tdst[4+16] = (size + 10) >> 8;\n\tdst[5+16] = (size + 10) & 0xff;\n\tdst[9+16] = 0x21 | ((pts_stamp >> 29) & 0x6);\n\tdst[10+16] = (pts_stamp >> 22) & 0xff;\n\tdst[11+16] = 1 | ((pts_stamp >> 14) & 0xff);\n\tdst[12+16] = (pts_stamp >> 7) & 0xff;\n\tdst[13+16] = 1 | ((pts_stamp & 0x7f) << 1);\n\titv->vbi.sliced_mpeg_size[idx] = sd + size;\n}\n\nstatic int ivtv_convert_ivtv_vbi(struct ivtv *itv, u8 *p)\n{\n\tu32 linemask[2];\n\tint i, l, id2;\n\tint line = 0;\n\n\tif (!memcmp(p, \"itv0\", 4)) {\n\t\tmemcpy(linemask, p + 4, 8);\n\t\tp += 12;\n\t} else if (!memcmp(p, \"ITV0\", 4)) {\n\t\tlinemask[0] = 0xffffffff;\n\t\tlinemask[1] = 0xf;\n\t\tp += 4;\n\t} else {\n\t\t \n\t\tlinemask[0] = linemask[1] = 0;\n\t}\n\tfor (i = 0; i < 36; i++) {\n\t\tint err = 0;\n\n\t\tif (i < 32 && !(linemask[0] & (1 << i)))\n\t\t\tcontinue;\n\t\tif (i >= 32 && !(linemask[1] & (1 << (i - 32))))\n\t\t\tcontinue;\n\t\tid2 = *p & 0xf;\n\t\tswitch (id2) {\n\t\tcase IVTV_SLICED_TYPE_TELETEXT_B:\n\t\t\tid2 = V4L2_SLICED_TELETEXT_B;\n\t\t\tbreak;\n\t\tcase IVTV_SLICED_TYPE_CAPTION_525:\n\t\t\tid2 = V4L2_SLICED_CAPTION_525;\n\t\t\terr = !odd_parity(p[1]) || !odd_parity(p[2]);\n\t\t\tbreak;\n\t\tcase IVTV_SLICED_TYPE_VPS:\n\t\t\tid2 = V4L2_SLICED_VPS;\n\t\t\tbreak;\n\t\tcase IVTV_SLICED_TYPE_WSS_625:\n\t\t\tid2 = V4L2_SLICED_WSS_625;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid2 = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (err == 0) {\n\t\t\tl = (i < 18) ? i + 6 : i - 18 + 6;\n\t\t\titv->vbi.sliced_dec_data[line].line = l;\n\t\t\titv->vbi.sliced_dec_data[line].field = i >= 18;\n\t\t\titv->vbi.sliced_dec_data[line].id = id2;\n\t\t\tmemcpy(itv->vbi.sliced_dec_data[line].data, p + 1, 42);\n\t\t\tline++;\n\t\t}\n\t\tp += 43;\n\t}\n\twhile (line < 36) {\n\t\titv->vbi.sliced_dec_data[line].id = 0;\n\t\titv->vbi.sliced_dec_data[line].line = 0;\n\t\titv->vbi.sliced_dec_data[line].field = 0;\n\t\tline++;\n\t}\n\treturn line * sizeof(itv->vbi.sliced_dec_data[0]);\n}\n\n \nstatic u32 compress_raw_buf(struct ivtv *itv, u8 *buf, u32 size)\n{\n\tu32 line_size = itv->vbi.raw_decoder_line_size;\n\tu32 lines = itv->vbi.count;\n\tu8 sav1 = itv->vbi.raw_decoder_sav_odd_field;\n\tu8 sav2 = itv->vbi.raw_decoder_sav_even_field;\n\tu8 *q = buf;\n\tu8 *p;\n\tint i;\n\n\tfor (i = 0; i < lines; i++) {\n\t\tp = buf + i * line_size;\n\n\t\t \n\t\tif (p[0] != 0xff || p[1] || p[2] || (p[3] != sav1 && p[3] != sav2)) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(q, p + 4, line_size - 4);\n\t\tq += line_size - 4;\n\t}\n\treturn lines * (line_size - 4);\n}\n\n\n \nstatic u32 compress_sliced_buf(struct ivtv *itv, u32 line, u8 *buf, u32 size, u8 sav)\n{\n\tu32 line_size = itv->vbi.sliced_decoder_line_size;\n\tstruct v4l2_decode_vbi_line vbi = {};\n\tint i;\n\tunsigned lines = 0;\n\n\t \n\tfor (i = 0; i < size; i++, buf++) {\n\t\tif (buf[0] == 0xff && !buf[1] && !buf[2] && buf[3] == sav)\n\t\t\tbreak;\n\t}\n\n\tsize -= i;\n\tif (size < line_size) {\n\t\treturn line;\n\t}\n\tfor (i = 0; i < size / line_size; i++) {\n\t\tu8 *p = buf + i * line_size;\n\n\t\t \n\t\tif (p[0] != 0xff || p[1] || p[2] || p[3] != sav) {\n\t\t\tcontinue;\n\t\t}\n\t\tvbi.p = p + 4;\n\t\tv4l2_subdev_call(itv->sd_video, vbi, decode_vbi_line, &vbi);\n\t\tif (vbi.type && !(lines & (1 << vbi.line))) {\n\t\t\tlines |= 1 << vbi.line;\n\t\t\titv->vbi.sliced_data[line].id = vbi.type;\n\t\t\titv->vbi.sliced_data[line].field = vbi.is_second_field;\n\t\t\titv->vbi.sliced_data[line].line = vbi.line;\n\t\t\tmemcpy(itv->vbi.sliced_data[line].data, vbi.p, 42);\n\t\t\tline++;\n\t\t}\n\t}\n\treturn line;\n}\n\nvoid ivtv_process_vbi_data(struct ivtv *itv, struct ivtv_buffer *buf,\n\t\t\t   u64 pts_stamp, int streamtype)\n{\n\tu8 *p = (u8 *) buf->buf;\n\tu32 size = buf->bytesused;\n\tint y;\n\n\t \n\tif (streamtype == IVTV_ENC_STREAM_TYPE_VBI && ivtv_raw_vbi(itv)) {\n\t\tu8 type;\n\n\t\tivtv_buf_swap(buf);\n\n\t\ttype = p[3];\n\n\t\tsize = buf->bytesused = compress_raw_buf(itv, p, size);\n\n\t\t \n\t\tif (type == itv->vbi.raw_decoder_sav_even_field) {\n\t\t\t \n\t\t\tp += size - 4;\n\t\t\tmemcpy(p, &itv->vbi.frame, 4);\n\t\t\titv->vbi.frame++;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (streamtype == IVTV_ENC_STREAM_TYPE_VBI) {\n\t\tint lines;\n\n\t\tivtv_buf_swap(buf);\n\n\t\t \n\t\tlines = compress_sliced_buf(itv, 0, p, size / 2,\n\t\t\titv->vbi.sliced_decoder_sav_odd_field);\n\t\t \n\t\t \n\t\tlines = compress_sliced_buf(itv, lines, p + size / 2 - 32, size / 2 + 32,\n\t\t\titv->vbi.sliced_decoder_sav_even_field);\n\t\t \n\t\tif (lines == 0) {\n\t\t\titv->vbi.sliced_data[0].id = 0;\n\t\t\titv->vbi.sliced_data[0].line = 0;\n\t\t\titv->vbi.sliced_data[0].field = 0;\n\t\t\tlines = 1;\n\t\t}\n\t\tbuf->bytesused = size = lines * sizeof(itv->vbi.sliced_data[0]);\n\t\tmemcpy(p, &itv->vbi.sliced_data[0], size);\n\n\t\tif (itv->vbi.insert_mpeg) {\n\t\t\tcopy_vbi_data(itv, lines, pts_stamp);\n\t\t}\n\t\titv->vbi.frame++;\n\t\treturn;\n\t}\n\n\t \n\tif (streamtype == IVTV_DEC_STREAM_TYPE_VBI) {\n\t\t \n\t\tint offset = size & 3;\n\t\tint cnt;\n\n\t\tif (offset) {\n\t\t\tp += 4 - offset;\n\t\t}\n\t\t \n\t\tfor (y = 0; y < size; y += 4) {\n\t\t       swab32s((u32 *)(p + y));\n\t\t}\n\n\t\tcnt = ivtv_convert_ivtv_vbi(itv, p + offset);\n\t\tmemcpy(buf->buf, itv->vbi.sliced_dec_data, cnt);\n\t\tbuf->bytesused = cnt;\n\n\t\tivtv_write_vbi(itv, itv->vbi.sliced_dec_data,\n\t\t\t       cnt / sizeof(itv->vbi.sliced_dec_data[0]));\n\t\treturn;\n\t}\n}\n\nvoid ivtv_disable_cc(struct ivtv *itv)\n{\n\tstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\n\n\tclear_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\n\tivtv_set_cc(itv, 0, &cc);\n\titv->vbi.cc_payload_idx = 0;\n}\n\n\nvoid ivtv_vbi_work_handler(struct ivtv *itv)\n{\n\tstruct vbi_info *vi = &itv->vbi;\n\tstruct v4l2_sliced_vbi_data data;\n\tstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\n\n\t \n\tif (itv->output_mode == OUT_PASSTHROUGH) {\n\t\tif (itv->is_50hz) {\n\t\t\tdata.id = V4L2_SLICED_WSS_625;\n\t\t\tdata.field = 0;\n\n\t\t\tif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\n\t\t\t\tivtv_set_wss(itv, 1, data.data[0] & 0xf);\n\t\t\t\tvi->wss_missing_cnt = 0;\n\t\t\t} else if (vi->wss_missing_cnt == 4) {\n\t\t\t\tivtv_set_wss(itv, 1, 0x8);   \n\t\t\t} else {\n\t\t\t\tvi->wss_missing_cnt++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint mode = 0;\n\n\t\t\tdata.id = V4L2_SLICED_CAPTION_525;\n\t\t\tdata.field = 0;\n\t\t\tif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\n\t\t\t\tmode |= 1;\n\t\t\t\tcc.odd[0] = data.data[0];\n\t\t\t\tcc.odd[1] = data.data[1];\n\t\t\t}\n\t\t\tdata.field = 1;\n\t\t\tif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\n\t\t\t\tmode |= 2;\n\t\t\t\tcc.even[0] = data.data[0];\n\t\t\t\tcc.even[1] = data.data[1];\n\t\t\t}\n\t\t\tif (mode) {\n\t\t\t\tvi->cc_missing_cnt = 0;\n\t\t\t\tivtv_set_cc(itv, mode, &cc);\n\t\t\t} else if (vi->cc_missing_cnt == 4) {\n\t\t\t\tivtv_set_cc(itv, 0, &cc);\n\t\t\t} else {\n\t\t\t\tvi->cc_missing_cnt++;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(IVTV_F_I_UPDATE_WSS, &itv->i_flags)) {\n\t\tivtv_set_wss(itv, 1, vi->wss_payload & 0xf);\n\t}\n\n\tif (test_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags)) {\n\t\tif (vi->cc_payload_idx == 0) {\n\t\t\tclear_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\n\t\t\tivtv_set_cc(itv, 3, &cc);\n\t\t}\n\t\twhile (vi->cc_payload_idx) {\n\t\t\tcc = vi->cc_payload[0];\n\n\t\t\tmemmove(vi->cc_payload, vi->cc_payload + 1,\n\t\t\t\t\tsizeof(vi->cc_payload) - sizeof(vi->cc_payload[0]));\n\t\t\tvi->cc_payload_idx--;\n\t\t\tif (vi->cc_payload_idx && cc.odd[0] == 0x80 && cc.odd[1] == 0x80)\n\t\t\t\tcontinue;\n\n\t\t\tivtv_set_cc(itv, 3, &cc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(IVTV_F_I_UPDATE_VPS, &itv->i_flags)) {\n\t\tivtv_set_vps(itv, 1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}