{
  "module_name": "ivtv-streams.c",
  "hash_id": "1172c3264483a44f902edee0040c497ae2a2515adaadbaa5579f17330ff7c2f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-streams.c",
  "human_readable_source": " \n\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-fileops.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-mailbox.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-irq.h\"\n#include \"ivtv-yuv.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-streams.h\"\n#include \"ivtv-firmware.h\"\n#include <media/v4l2-event.h>\n\nstatic const struct v4l2_file_operations ivtv_v4l2_enc_fops = {\n\t.owner = THIS_MODULE,\n\t.read = ivtv_v4l2_read,\n\t.write = ivtv_v4l2_write,\n\t.open = ivtv_v4l2_open,\n\t.unlocked_ioctl = video_ioctl2,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl32 = video_ioctl2,  \n#endif\n\t.release = ivtv_v4l2_close,\n\t.poll = ivtv_v4l2_enc_poll,\n};\n\nstatic const struct v4l2_file_operations ivtv_v4l2_dec_fops = {\n\t.owner = THIS_MODULE,\n\t.read = ivtv_v4l2_read,\n\t.write = ivtv_v4l2_write,\n\t.open = ivtv_v4l2_open,\n\t.unlocked_ioctl = video_ioctl2,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl32 = video_ioctl2,  \n#endif\n\t.release = ivtv_v4l2_close,\n\t.poll = ivtv_v4l2_dec_poll,\n};\n\nstatic const struct v4l2_file_operations ivtv_v4l2_radio_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ivtv_v4l2_open,\n\t.unlocked_ioctl = video_ioctl2,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl32 = video_ioctl2,  \n#endif\n\t.release = ivtv_v4l2_close,\n\t.poll = ivtv_v4l2_enc_poll,\n};\n\n#define IVTV_V4L2_DEC_MPG_OFFSET  16\t \n#define IVTV_V4L2_ENC_PCM_OFFSET  24\t \n#define IVTV_V4L2_ENC_YUV_OFFSET  32\t \n#define IVTV_V4L2_DEC_YUV_OFFSET  48\t \n#define IVTV_V4L2_DEC_VBI_OFFSET   8\t \n#define IVTV_V4L2_DEC_VOUT_OFFSET 16\t \n\nstatic struct {\n\tconst char *name;\n\tint vfl_type;\n\tint num_offset;\n\tint dma, pio;\n\tu32 v4l2_caps;\n\tconst struct v4l2_file_operations *fops;\n} ivtv_stream_info[] = {\n\t{\t \n\t\t\"encoder MPG\",\n\t\tVFL_TYPE_VIDEO, 0,\n\t\tDMA_FROM_DEVICE, 0,\n\t\tV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\n\t\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_enc_fops\n\t},\n\t{\t \n\t\t\"encoder YUV\",\n\t\tVFL_TYPE_VIDEO, IVTV_V4L2_ENC_YUV_OFFSET,\n\t\tDMA_FROM_DEVICE, 0,\n\t\tV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\n\t\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_enc_fops\n\t},\n\t{\t \n\t\t\"encoder VBI\",\n\t\tVFL_TYPE_VBI, 0,\n\t\tDMA_FROM_DEVICE, 0,\n\t\tV4L2_CAP_VBI_CAPTURE | V4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_TUNER |\n\t\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_enc_fops\n\t},\n\t{\t \n\t\t\"encoder PCM\",\n\t\tVFL_TYPE_VIDEO, IVTV_V4L2_ENC_PCM_OFFSET,\n\t\tDMA_FROM_DEVICE, 0,\n\t\tV4L2_CAP_TUNER | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_enc_fops\n\t},\n\t{\t \n\t\t\"encoder radio\",\n\t\tVFL_TYPE_RADIO, 0,\n\t\tDMA_NONE, 1,\n\t\tV4L2_CAP_RADIO | V4L2_CAP_TUNER,\n\t\t&ivtv_v4l2_radio_fops\n\t},\n\t{\t \n\t\t\"decoder MPG\",\n\t\tVFL_TYPE_VIDEO, IVTV_V4L2_DEC_MPG_OFFSET,\n\t\tDMA_TO_DEVICE, 0,\n\t\tV4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_dec_fops\n\t},\n\t{\t \n\t\t\"decoder VBI\",\n\t\tVFL_TYPE_VBI, IVTV_V4L2_DEC_VBI_OFFSET,\n\t\tDMA_NONE, 1,\n\t\tV4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_enc_fops\n\t},\n\t{\t \n\t\t\"decoder VOUT\",\n\t\tVFL_TYPE_VBI, IVTV_V4L2_DEC_VOUT_OFFSET,\n\t\tDMA_NONE, 1,\n\t\tV4L2_CAP_SLICED_VBI_OUTPUT | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_dec_fops\n\t},\n\t{\t \n\t\t\"decoder YUV\",\n\t\tVFL_TYPE_VIDEO, IVTV_V4L2_DEC_YUV_OFFSET,\n\t\tDMA_TO_DEVICE, 0,\n\t\tV4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,\n\t\t&ivtv_v4l2_dec_fops\n\t}\n};\n\nstatic void ivtv_stream_init(struct ivtv *itv, int type)\n{\n\tstruct ivtv_stream *s = &itv->streams[type];\n\n\t \n\tmemset(s, 0, sizeof(*s));\n\n\t \n\ts->itv = itv;\n\ts->type = type;\n\ts->name = ivtv_stream_info[type].name;\n\ts->vdev.device_caps = ivtv_stream_info[type].v4l2_caps;\n\n\tif (ivtv_stream_info[type].pio)\n\t\ts->dma = DMA_NONE;\n\telse\n\t\ts->dma = ivtv_stream_info[type].dma;\n\ts->buf_size = itv->stream_buf_size[type];\n\tif (s->buf_size)\n\t\ts->buffers = (itv->options.kilobytes[type] * 1024 + s->buf_size - 1) / s->buf_size;\n\tspin_lock_init(&s->qlock);\n\tinit_waitqueue_head(&s->waitq);\n\ts->sg_handle = IVTV_DMA_UNMAPPED;\n\tivtv_queue_init(&s->q_free);\n\tivtv_queue_init(&s->q_full);\n\tivtv_queue_init(&s->q_dma);\n\tivtv_queue_init(&s->q_predma);\n\tivtv_queue_init(&s->q_io);\n}\n\nstatic int ivtv_prep_dev(struct ivtv *itv, int type)\n{\n\tstruct ivtv_stream *s = &itv->streams[type];\n\tint num_offset = ivtv_stream_info[type].num_offset;\n\tint num = itv->instance + ivtv_first_minor + num_offset;\n\n\t \n\ts->vdev.v4l2_dev = NULL;\n\ts->itv = itv;\n\ts->type = type;\n\ts->name = ivtv_stream_info[type].name;\n\n\t \n\tif (type == IVTV_ENC_STREAM_TYPE_RAD && !(itv->v4l2_cap & V4L2_CAP_RADIO))\n\t\treturn 0;\n\tif (type >= IVTV_DEC_STREAM_TYPE_MPG && !(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\n\t\treturn 0;\n\n\t \n\tif (ivtv_stream_info[type].dma != DMA_NONE &&\n\t    itv->options.kilobytes[type] == 0) {\n\t\tIVTV_INFO(\"Disabled %s device\\n\", ivtv_stream_info[type].name);\n\t\treturn 0;\n\t}\n\n\tivtv_stream_init(itv, type);\n\n\tsnprintf(s->vdev.name, sizeof(s->vdev.name), \"%s %s\",\n\t\t\titv->v4l2_dev.name, s->name);\n\n\ts->vdev.num = num;\n\ts->vdev.v4l2_dev = &itv->v4l2_dev;\n\tif (ivtv_stream_info[type].v4l2_caps &\n\t\t\t(V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_SLICED_VBI_OUTPUT))\n\t\ts->vdev.vfl_dir = VFL_DIR_TX;\n\ts->vdev.fops = ivtv_stream_info[type].fops;\n\ts->vdev.ctrl_handler = itv->v4l2_dev.ctrl_handler;\n\ts->vdev.release = video_device_release_empty;\n\ts->vdev.tvnorms = V4L2_STD_ALL;\n\ts->vdev.lock = &itv->serialize_lock;\n\tif (s->type == IVTV_DEC_STREAM_TYPE_VBI) {\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_S_AUDIO);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_ENUMAUDIO);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_ENUMINPUT);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_S_INPUT);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_G_INPUT);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(&s->vdev, VIDIOC_S_STD);\n\t}\n\tivtv_set_funcs(&s->vdev);\n\treturn 0;\n}\n\n \nint ivtv_streams_setup(struct ivtv *itv)\n{\n\tint type;\n\n\t \n\tfor (type = 0; type < IVTV_MAX_STREAMS; type++) {\n\t\t \n\t\tif (ivtv_prep_dev(itv, type))\n\t\t\tbreak;\n\n\t\tif (itv->streams[type].vdev.v4l2_dev == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ivtv_stream_alloc(&itv->streams[type]))\n\t\t\tbreak;\n\t}\n\tif (type == IVTV_MAX_STREAMS)\n\t\treturn 0;\n\n\t \n\tivtv_streams_cleanup(itv);\n\treturn -ENOMEM;\n}\n\nstatic int ivtv_reg_dev(struct ivtv *itv, int type)\n{\n\tstruct ivtv_stream *s = &itv->streams[type];\n\tint vfl_type = ivtv_stream_info[type].vfl_type;\n\tconst char *name;\n\tint num;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn 0;\n\n\tnum = s->vdev.num;\n\t \n\tif (type != IVTV_ENC_STREAM_TYPE_MPG) {\n\t\tstruct ivtv_stream *s_mpg = &itv->streams[IVTV_ENC_STREAM_TYPE_MPG];\n\n\t\tif (s_mpg->vdev.v4l2_dev)\n\t\t\tnum = s_mpg->vdev.num + ivtv_stream_info[type].num_offset;\n\t}\n\tif (itv->osd_video_pbase && (type == IVTV_DEC_STREAM_TYPE_YUV ||\n\t\t\t\t     type == IVTV_DEC_STREAM_TYPE_MPG)) {\n\t\ts->vdev.device_caps |= V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t\titv->v4l2_cap |= V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t}\n\tvideo_set_drvdata(&s->vdev, s);\n\n\t \n\tif (video_register_device_no_warn(&s->vdev, vfl_type, num)) {\n\t\tIVTV_ERR(\"Couldn't register v4l2 device for %s (device node number %d)\\n\",\n\t\t\t\ts->name, num);\n\t\treturn -ENOMEM;\n\t}\n\tname = video_device_node_name(&s->vdev);\n\n\tswitch (vfl_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tIVTV_INFO(\"Registered device %s for %s (%d kB)\\n\",\n\t\t\tname, s->name, itv->options.kilobytes[type]);\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tIVTV_INFO(\"Registered device %s for %s\\n\",\n\t\t\tname, s->name);\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tif (itv->options.kilobytes[type])\n\t\t\tIVTV_INFO(\"Registered device %s for %s (%d kB)\\n\",\n\t\t\t\tname, s->name, itv->options.kilobytes[type]);\n\t\telse\n\t\t\tIVTV_INFO(\"Registered device %s for %s\\n\",\n\t\t\t\tname, s->name);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint ivtv_streams_register(struct ivtv *itv)\n{\n\tint type;\n\tint err = 0;\n\n\t \n\tfor (type = 0; type < IVTV_MAX_STREAMS; type++)\n\t\terr |= ivtv_reg_dev(itv, type);\n\n\tif (err == 0)\n\t\treturn 0;\n\n\t \n\tivtv_streams_cleanup(itv);\n\treturn -ENOMEM;\n}\n\n \nvoid ivtv_streams_cleanup(struct ivtv *itv)\n{\n\tint type;\n\n\t \n\tfor (type = 0; type < IVTV_MAX_STREAMS; type++) {\n\t\tstruct video_device *vdev = &itv->streams[type].vdev;\n\n\t\tif (vdev->v4l2_dev == NULL)\n\t\t\tcontinue;\n\n\t\tvideo_unregister_device(vdev);\n\t\tivtv_stream_free(&itv->streams[type]);\n\t\titv->streams[type].vdev.v4l2_dev = NULL;\n\t}\n}\n\nstatic void ivtv_vbi_setup(struct ivtv *itv)\n{\n\tint raw = ivtv_raw_vbi(itv);\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tint lines;\n\tint i;\n\n\t \n\tivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, 0xffff , 0, 0, 0, 0);\n\n\t \n\tif (raw)\n\t\tv4l2_subdev_call(itv->sd_video, vbi, s_raw_fmt, &itv->vbi.in.fmt.vbi);\n\telse\n\t\tv4l2_subdev_call(itv->sd_video, vbi, s_sliced_fmt, &itv->vbi.in.fmt.sliced);\n\n\t \n\tif (raw) {\n\t\tlines = itv->vbi.count * 2;\n\t} else {\n\t\tlines = itv->is_60hz ? 24 : 38;\n\t\tif (itv->is_60hz && (itv->hw_flags & IVTV_HW_CX25840))\n\t\t\tlines += 2;\n\t}\n\n\titv->vbi.enc_size = lines * (raw ? itv->vbi.raw_size : itv->vbi.sliced_size);\n\n\t \n\tdata[0] = raw | 0x02 | (0xbd << 8);\n\n\t \n\tdata[1] = 1;\n\t \n\tdata[2] = raw ? 4 : 4 * (itv->vbi.raw_size / itv->vbi.enc_size);\n\t \n\tif (itv->hw_flags & IVTV_HW_CX25840) {\n\t\t \n\t\tif (raw) {\n\t\t\tdata[3] = 0x20602060;\n\t\t\tdata[4] = 0x30703070;\n\t\t} else {\n\t\t\tdata[3] = 0xB0F0B0F0;\n\t\t\tdata[4] = 0xA0E0A0E0;\n\t\t}\n\t\t \n\t\tdata[5] = lines;\n\t\t \n\t\tdata[6] = (raw ? itv->vbi.raw_size : itv->vbi.sliced_size);\n\t} else {\n\t\t \n\t\tif (raw) {\n\t\t\tdata[3] = 0x25256262;\n\t\t\tdata[4] = 0x387F7F7F;\n\t\t} else {\n\t\t\tdata[3] = 0xABABECEC;\n\t\t\tdata[4] = 0xB6F1F1F1;\n\t\t}\n\t\t \n\t\tdata[5] = lines;\n\t\t \n\t\tdata[6] = itv->vbi.enc_size / lines;\n\t}\n\n\tIVTV_DEBUG_INFO(\n\t\t\"Setup VBI API header 0x%08x pkts %d buffs %d ln %d sz %d\\n\",\n\t\t\tdata[0], data[1], data[2], data[5], data[6]);\n\n\tivtv_api(itv, CX2341X_ENC_SET_VBI_CONFIG, 7, data);\n\n\t \n\titv->vbi.enc_start = data[2];\n\titv->vbi.fpi = data[0];\n\tif (!itv->vbi.fpi)\n\t\titv->vbi.fpi = 1;\n\n\tIVTV_DEBUG_INFO(\"Setup VBI start 0x%08x frames %d fpi %d\\n\",\n\t\titv->vbi.enc_start, data[1], itv->vbi.fpi);\n\n\t \n\tfor (i = 2; i <= 24; i++) {\n\t\tint valid;\n\n\t\tif (itv->is_60hz) {\n\t\t\tvalid = i >= 10 && i < 22;\n\t\t} else {\n\t\t\tvalid = i >= 6 && i < 24;\n\t\t}\n\t\tivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, i - 1,\n\t\t\t\tvalid, 0 , 0, 0);\n\t\tivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, (i - 1) | 0x80000000,\n\t\t\t\tvalid, 0, 0, 0);\n\t}\n\n\t \n}\n\nint ivtv_start_v4l2_encode_stream(struct ivtv_stream *s)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tstruct ivtv *itv = s->itv;\n\tint captype = 0, subtype = 0;\n\tint enable_passthrough = 0;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tIVTV_DEBUG_INFO(\"Start encoder stream %s\\n\", s->name);\n\n\tswitch (s->type) {\n\tcase IVTV_ENC_STREAM_TYPE_MPG:\n\t\tcaptype = 0;\n\t\tsubtype = 3;\n\n\t\t \n\t\tif (itv->output_mode == OUT_PASSTHROUGH) {\n\t\t\tivtv_passthrough_mode(itv, 0);\n\t\t\tenable_passthrough = 1;\n\t\t}\n\t\titv->mpg_data_received = itv->vbi_data_inserted = 0;\n\t\titv->dualwatch_jiffies = jiffies;\n\t\titv->dualwatch_stereo_mode = v4l2_ctrl_g_ctrl(itv->cxhdl.audio_mode);\n\t\titv->search_pack_header = 0;\n\t\tbreak;\n\n\tcase IVTV_ENC_STREAM_TYPE_YUV:\n\t\tif (itv->output_mode == OUT_PASSTHROUGH) {\n\t\t\tcaptype = 2;\n\t\t\tsubtype = 11;\t \n\t\t\tbreak;\n\t\t}\n\t\tcaptype = 1;\n\t\tsubtype = 1;\n\t\tbreak;\n\tcase IVTV_ENC_STREAM_TYPE_PCM:\n\t\tcaptype = 1;\n\t\tsubtype = 2;\n\t\tbreak;\n\tcase IVTV_ENC_STREAM_TYPE_VBI:\n\t\tcaptype = 1;\n\t\tsubtype = 4;\n\n\t\titv->vbi.frame = 0;\n\t\titv->vbi.inserted_frame = 0;\n\t\tmemset(itv->vbi.sliced_mpeg_size,\n\t\t\t0, sizeof(itv->vbi.sliced_mpeg_size));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\ts->subtype = subtype;\n\ts->buffers_stolen = 0;\n\n\t \n\tclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\n\tif (atomic_read(&itv->capturing) == 0) {\n\t\tint digitizer;\n\n\t\t \n\t\t \n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_SET_DMA_BLOCK_SIZE, 2, 1, 1);\n\n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_SET_VERT_CROP_LINE, 1, 0);\n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_MISC, 2, 3, !itv->has_cx23415);\n\t\tivtv_vapi(itv, CX2341X_ENC_MISC, 2, 8, 0);\n\t\tivtv_vapi(itv, CX2341X_ENC_MISC, 2, 4, 1);\n\t\tivtv_vapi(itv, CX2341X_ENC_MISC, 1, 12);\n\n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_SET_PLACEHOLDER, 12,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\t\tif (itv->card->hw_all & (IVTV_HW_SAA7115 | IVTV_HW_SAA717X))\n\t\t    digitizer = 0xF1;\n\t\telse if (itv->card->hw_all & IVTV_HW_SAA7114)\n\t\t    digitizer = 0xEF;\n\t\telse  \n\t\t    digitizer = 0x140;\n\n\t\tivtv_vapi(itv, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, digitizer, digitizer);\n\n\t\t \n\t\tif (itv->v4l2_cap & V4L2_CAP_VBI_CAPTURE) {\n\t\t\tivtv_vbi_setup(itv);\n\t\t}\n\n\t\t \n\t\tivtv_vapi_result(itv, data, CX2341X_ENC_SET_PGM_INDEX_INFO, 2, 7, 400);\n\t\titv->pgm_info_offset = data[0];\n\t\titv->pgm_info_num = data[1];\n\t\titv->pgm_info_write_idx = 0;\n\t\titv->pgm_info_read_idx = 0;\n\n\t\tIVTV_DEBUG_INFO(\"PGM Index at 0x%08x with %d elements\\n\",\n\t\t\t\titv->pgm_info_offset, itv->pgm_info_num);\n\n\t\t \n\t\tcx2341x_handler_setup(&itv->cxhdl);\n\n\t\t \n\t\tif (test_bit(IVTV_F_I_RADIO_USER, &itv->i_flags))\n\t\t\tivtv_vapi(itv, CX2341X_ENC_MUTE_VIDEO, 1,\n\t\t\t\t1 | (v4l2_ctrl_g_ctrl(itv->cxhdl.video_mute_yuv) << 8));\n\t}\n\n\t \n\tif (itv->has_cx23415 && !test_and_set_bit(IVTV_F_I_DIG_RST, &itv->i_flags)) {\n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_SET_EVENT_NOTIFICATION, 4, 0, 1, IVTV_IRQ_ENC_VIM_RST, -1);\n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_ENC_VIM_RST);\n\t}\n\n\tif (atomic_read(&itv->capturing) == 0) {\n\t\t \n\t\tivtv_set_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\n\n\t\tclear_bit(IVTV_F_I_EOS, &itv->i_flags);\n\n\t\tcx2341x_handler_set_busy(&itv->cxhdl, 1);\n\n\t\t \n\t\t \n\t\tv4l2_subdev_call(itv->sd_audio, audio, s_stream, 1);\n\t\t \n\t\tv4l2_subdev_call(itv->sd_video, video, s_stream, 0);\n\t\tivtv_msleep_timeout(300, 0);\n\t\tivtv_vapi(itv, CX2341X_ENC_INITIALIZE_INPUT, 0);\n\t\tv4l2_subdev_call(itv->sd_video, video, s_stream, 1);\n\t}\n\n\t \n\tif (ivtv_vapi(itv, CX2341X_ENC_START_CAPTURE, 2, captype, subtype))\n\t{\n\t\tIVTV_DEBUG_WARN( \"Error starting capture!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (enable_passthrough) {\n\t\tivtv_passthrough_mode(itv, 1);\n\t}\n\n\tif (s->type == IVTV_ENC_STREAM_TYPE_VBI)\n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_ENC_VBI_CAP);\n\telse\n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\n\n\t \n\tatomic_inc(&itv->capturing);\n\treturn 0;\n}\nEXPORT_SYMBOL(ivtv_start_v4l2_encode_stream);\n\nstatic int ivtv_setup_v4l2_decode_stream(struct ivtv_stream *s)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tstruct ivtv *itv = s->itv;\n\tint datatype;\n\tu16 width;\n\tu16 height;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tIVTV_DEBUG_INFO(\"Setting some initial decoder settings\\n\");\n\n\twidth = itv->cxhdl.width;\n\theight = itv->cxhdl.height;\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_AUDIO_MODE, 2, itv->audio_bilingual_mode, itv->audio_stereo_mode);\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_DISPLAY_BUFFERS, 1, 0);\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_PREBUFFERING, 1, 1);\n\n\t \n\tivtv_vapi_result(itv, data, CX2341X_DEC_EXTRACT_VBI, 1, 1);\n\titv->vbi.dec_start = data[0];\n\n\tIVTV_DEBUG_INFO(\"Decoder VBI RE-Insert start 0x%08x size 0x%08x\\n\",\n\t\titv->vbi.dec_start, data[1]);\n\n\t \n\t \n\tswitch (s->type) {\n\tcase IVTV_DEC_STREAM_TYPE_YUV:\n\t\tif (itv->output_mode == OUT_PASSTHROUGH) {\n\t\t\tdatatype = 1;\n\t\t} else {\n\t\t\t \n\t\t\tdatatype = 2;\n\t\t\twidth = 720;\n\t\t\theight = itv->is_out_50hz ? 576 : 480;\n\t\t}\n\t\tIVTV_DEBUG_INFO(\"Setup DEC YUV Stream data[0] = %d\\n\", datatype);\n\t\tbreak;\n\tcase IVTV_DEC_STREAM_TYPE_MPG:\n\tdefault:\n\t\tdatatype = 0;\n\t\tbreak;\n\t}\n\tif (ivtv_vapi(itv, CX2341X_DEC_SET_DECODER_SOURCE, 4, datatype,\n\t\t\twidth, height, itv->cxhdl.audio_properties)) {\n\t\tIVTV_DEBUG_WARN(\"Couldn't initialize decoder source\\n\");\n\t}\n\n\t \n\tivtv_msleep_timeout(10, 0);\n\n\t \n\treturn ivtv_firmware_check(itv, \"ivtv_setup_v4l2_decode_stream\");\n}\n\nint ivtv_start_v4l2_decode_stream(struct ivtv_stream *s, int gop_offset)\n{\n\tstruct ivtv *itv = s->itv;\n\tint rc;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tif (test_and_set_bit(IVTV_F_S_STREAMING, &s->s_flags))\n\t\treturn 0;\t \n\n\tIVTV_DEBUG_INFO(\"Starting decode stream %s (gop_offset %d)\\n\", s->name, gop_offset);\n\n\trc = ivtv_setup_v4l2_decode_stream(s);\n\tif (rc < 0) {\n\t\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\t\treturn rc;\n\t}\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_DMA_BLOCK_SIZE, 1, 65536);\n\n\t \n\tclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\n\t \n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[0]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[1]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[2]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[3]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[0]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[1]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[2]);\n\twritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[3]);\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_EVENT_NOTIFICATION, 4, 0, 1, IVTV_IRQ_DEC_AUD_MODE_CHG, -1);\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_START_PLAYBACK, 2, gop_offset, 0);\n\n\t \n\tivtv_msleep_timeout(10, 0);\n\n\t \n\tivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_DECODE);\n\tIVTV_DEBUG_IRQ(\"IRQ Mask is now: 0x%08x\\n\", itv->irqmask);\n\n\t \n\tatomic_inc(&itv->decoding);\n\treturn 0;\n}\n\nvoid ivtv_stop_all_captures(struct ivtv *itv)\n{\n\tint i;\n\n\tfor (i = IVTV_MAX_STREAMS - 1; i >= 0; i--) {\n\t\tstruct ivtv_stream *s = &itv->streams[i];\n\n\t\tif (s->vdev.v4l2_dev == NULL)\n\t\t\tcontinue;\n\t\tif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\t\tivtv_stop_v4l2_encode_stream(s, 0);\n\t\t}\n\t}\n}\n\nint ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s, int gop_end)\n{\n\tstruct ivtv *itv = s->itv;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint cap_type;\n\tint stopmode;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\t \n\n\tIVTV_DEBUG_INFO(\"Stop Capture\\n\");\n\n\tif (s->type == IVTV_DEC_STREAM_TYPE_VOUT)\n\t\treturn 0;\n\tif (atomic_read(&itv->capturing) == 0)\n\t\treturn 0;\n\n\tswitch (s->type) {\n\tcase IVTV_ENC_STREAM_TYPE_YUV:\n\t\tcap_type = 1;\n\t\tbreak;\n\tcase IVTV_ENC_STREAM_TYPE_PCM:\n\t\tcap_type = 1;\n\t\tbreak;\n\tcase IVTV_ENC_STREAM_TYPE_VBI:\n\t\tcap_type = 1;\n\t\tbreak;\n\tcase IVTV_ENC_STREAM_TYPE_MPG:\n\tdefault:\n\t\tcap_type = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG && gop_end) {\n\t\tstopmode = 0;\n\t} else {\n\t\tstopmode = 1;\n\t}\n\n\t \n\t \n\tivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, stopmode, cap_type, s->subtype);\n\n\tif (!test_bit(IVTV_F_S_PASSTHROUGH, &s->s_flags)) {\n\t\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG && gop_end) {\n\t\t\t \n\t\t\tunsigned long duration;\n\t\t\tunsigned long then = jiffies;\n\n\t\t\tadd_wait_queue(&itv->eos_waitq, &wait);\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\t \n\t\t\twhile (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&\n\t\t\t\ttime_before(jiffies,\n\t\t\t\t\t    then + msecs_to_jiffies(2000))) {\n\t\t\t\tschedule_timeout(msecs_to_jiffies(10));\n\t\t\t}\n\n\t\t\t \n\t\t\tduration = ((1000 + HZ / 2) / HZ) * (jiffies - then);\n\n\t\t\tif (!test_bit(IVTV_F_I_EOS, &itv->i_flags)) {\n\t\t\t\tIVTV_DEBUG_WARN(\"%s: EOS interrupt not received! stopping anyway.\\n\", s->name);\n\t\t\t\tIVTV_DEBUG_WARN(\"%s: waited %lu ms.\\n\", s->name, duration);\n\t\t\t} else {\n\t\t\t\tIVTV_DEBUG_INFO(\"%s: EOS took %lu ms to occur.\\n\", s->name, duration);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&itv->eos_waitq, &wait);\n\t\t\tset_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\t\t}\n\n\t\t \n\t\tivtv_msleep_timeout(100, 0);\n\t}\n\n\tatomic_dec(&itv->capturing);\n\n\t \n\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\n\tif (s->type == IVTV_ENC_STREAM_TYPE_VBI)\n\t\tivtv_set_irq_mask(itv, IVTV_IRQ_ENC_VBI_CAP);\n\n\tif (atomic_read(&itv->capturing) > 0) {\n\t\treturn 0;\n\t}\n\n\tcx2341x_handler_set_busy(&itv->cxhdl, 0);\n\n\t \n\tivtv_set_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\n\tdel_timer(&itv->dma_timer);\n\n\t \n\tif (test_and_clear_bit(IVTV_F_I_DIG_RST, &itv->i_flags)) {\n\t\t \n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_SET_EVENT_NOTIFICATION, 4, 0, 0, IVTV_IRQ_ENC_VIM_RST, -1);\n\t\tivtv_set_irq_mask(itv, IVTV_IRQ_ENC_VIM_RST);\n\t}\n\n\t \n\tivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, 1, 2, 7);\n\n\twake_up(&s->waitq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ivtv_stop_v4l2_encode_stream);\n\nint ivtv_stop_v4l2_decode_stream(struct ivtv_stream *s, int flags, u64 pts)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_EOS,\n\t};\n\tstruct ivtv *itv = s->itv;\n\n\tif (s->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tif (s->type != IVTV_DEC_STREAM_TYPE_YUV && s->type != IVTV_DEC_STREAM_TYPE_MPG)\n\t\treturn -EINVAL;\n\n\tif (!test_bit(IVTV_F_S_STREAMING, &s->s_flags))\n\t\treturn 0;\n\n\tIVTV_DEBUG_INFO(\"Stop Decode at %llu, flags: %x\\n\", (unsigned long long)pts, flags);\n\n\t \n\tif (!(flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) || pts) {\n\t\tu32 tmp = 0;\n\n\t\t \n\t\tif (pts) {\n\t\t\tivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3,\n\t\t\t\t0, (u32)(pts & 0xffffffff), (u32)(pts >> 32));\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 data[CX2341X_MBOX_MAX_DATA];\n\t\t\tivtv_vapi_result(itv, data, CX2341X_DEC_GET_XFER_INFO, 0);\n\t\t\tif (s->q_full.buffers + s->q_dma.buffers == 0) {\n\t\t\t\tif (tmp == data[3])\n\t\t\t\t\tbreak;\n\t\t\t\ttmp = data[3];\n\t\t\t}\n\t\t\tif (ivtv_msleep_timeout(100, 1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3, flags & V4L2_DEC_CMD_STOP_TO_BLACK, 0, 0);\n\n\t \n\tivtv_vapi(itv, CX2341X_DEC_SET_EVENT_NOTIFICATION, 4, 0, 0, IVTV_IRQ_DEC_AUD_MODE_CHG, -1);\n\n\tivtv_set_irq_mask(itv, IVTV_IRQ_MASK_DECODE);\n\tdel_timer(&itv->dma_timer);\n\n\tclear_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags);\n\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\tivtv_flush_queues(s);\n\n\t \n\tivtv_msleep_timeout(40, 0);\n\n\t \n\tatomic_dec(&itv->decoding);\n\n\tset_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags);\n\twake_up(&itv->event_waitq);\n\tv4l2_event_queue(&s->vdev, &ev);\n\n\t \n\twake_up(&s->waitq);\n\n\treturn 0;\n}\n\nint ivtv_passthrough_mode(struct ivtv *itv, int enable)\n{\n\tstruct ivtv_stream *yuv_stream = &itv->streams[IVTV_ENC_STREAM_TYPE_YUV];\n\tstruct ivtv_stream *dec_stream = &itv->streams[IVTV_DEC_STREAM_TYPE_YUV];\n\n\tif (yuv_stream->vdev.v4l2_dev == NULL || dec_stream->vdev.v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tIVTV_DEBUG_INFO(\"ivtv ioctl: Select passthrough mode\\n\");\n\n\t \n\tif (enable) {\n\t\tif (itv->output_mode == OUT_PASSTHROUGH) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (ivtv_set_output_mode(itv, OUT_PASSTHROUGH) != OUT_PASSTHROUGH)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tset_bit(IVTV_F_S_PASSTHROUGH, &dec_stream->s_flags);\n\t\tset_bit(IVTV_F_S_STREAMING, &dec_stream->s_flags);\n\n\t\t \n\t\tivtv_setup_v4l2_decode_stream(dec_stream);\n\n\t\t \n\t\tivtv_vapi(itv, CX2341X_DEC_START_PLAYBACK, 2, 0, 1);\n\t\tatomic_inc(&itv->decoding);\n\n\t\t \n\t\tif (atomic_read(&itv->capturing) == 0) {\n\t\t\tcx2341x_handler_setup(&itv->cxhdl);\n\t\t\tcx2341x_handler_set_busy(&itv->cxhdl, 1);\n\t\t}\n\n\t\t \n\t\tivtv_vapi(itv, CX2341X_ENC_START_CAPTURE, 2, 2, 11);\n\t\tatomic_inc(&itv->capturing);\n\t\treturn 0;\n\t}\n\n\tif (itv->output_mode != OUT_PASSTHROUGH)\n\t\treturn 0;\n\n\t \n\tivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, 1, 2, 11);\n\tivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3, 1, 0, 0);\n\n\tatomic_dec(&itv->capturing);\n\tatomic_dec(&itv->decoding);\n\tclear_bit(IVTV_F_S_PASSTHROUGH, &dec_stream->s_flags);\n\tclear_bit(IVTV_F_S_STREAMING, &dec_stream->s_flags);\n\titv->output_mode = OUT_NONE;\n\tif (atomic_read(&itv->capturing) == 0)\n\t\tcx2341x_handler_set_busy(&itv->cxhdl, 0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}