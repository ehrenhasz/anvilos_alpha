{
  "module_name": "ivtv-fileops.c",
  "hash_id": "876c1b592921ca09b10de2194d57617a2cd09370c918a07ed72f26094b2ddb3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-fileops.c",
  "human_readable_source": "\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-fileops.h\"\n#include \"ivtv-i2c.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-udma.h\"\n#include \"ivtv-irq.h\"\n#include \"ivtv-vbi.h\"\n#include \"ivtv-mailbox.h\"\n#include \"ivtv-routing.h\"\n#include \"ivtv-streams.h\"\n#include \"ivtv-yuv.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-firmware.h\"\n#include <media/v4l2-event.h>\n#include <media/i2c/saa7115.h>\n\n \nint ivtv_claim_stream(struct ivtv_open_id *id, int type)\n{\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[type];\n\tstruct ivtv_stream *s_vbi;\n\tint vbi_type;\n\n\tif (test_and_set_bit(IVTV_F_S_CLAIMED, &s->s_flags)) {\n\t\t \n\t\tif (s->fh == &id->fh) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (s->fh == NULL && (type == IVTV_DEC_STREAM_TYPE_VBI ||\n\t\t\t\t\t type == IVTV_ENC_STREAM_TYPE_VBI)) {\n\t\t\t \n\t\t\ts->fh = &id->fh;\n\t\t\tIVTV_DEBUG_INFO(\"Start Read VBI\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tIVTV_DEBUG_INFO(\"Stream %d is busy\\n\", type);\n\t\treturn -EBUSY;\n\t}\n\ts->fh = &id->fh;\n\tif (type == IVTV_DEC_STREAM_TYPE_VBI) {\n\t\t \n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\n\t}\n\n\t \n\tif (type == IVTV_DEC_STREAM_TYPE_MPG) {\n\t\tvbi_type = IVTV_DEC_STREAM_TYPE_VBI;\n\t} else if (type == IVTV_ENC_STREAM_TYPE_MPG &&\n\t\t   itv->vbi.insert_mpeg && !ivtv_raw_vbi(itv)) {\n\t\tvbi_type = IVTV_ENC_STREAM_TYPE_VBI;\n\t} else {\n\t\treturn 0;\n\t}\n\ts_vbi = &itv->streams[vbi_type];\n\n\tif (!test_and_set_bit(IVTV_F_S_CLAIMED, &s_vbi->s_flags)) {\n\t\t \n\t\tif (vbi_type == IVTV_DEC_STREAM_TYPE_VBI)\n\t\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\n\t}\n\t \n\tset_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(ivtv_claim_stream);\n\n \nvoid ivtv_release_stream(struct ivtv_stream *s)\n{\n\tstruct ivtv *itv = s->itv;\n\tstruct ivtv_stream *s_vbi;\n\n\ts->fh = NULL;\n\tif ((s->type == IVTV_DEC_STREAM_TYPE_VBI || s->type == IVTV_ENC_STREAM_TYPE_VBI) &&\n\t\ttest_bit(IVTV_F_S_INTERNAL_USE, &s->s_flags)) {\n\t\t \n\t\treturn;\n\t}\n\tif (!test_and_clear_bit(IVTV_F_S_CLAIMED, &s->s_flags)) {\n\t\tIVTV_DEBUG_WARN(\"Release stream %s not in use!\\n\", s->name);\n\t\treturn;\n\t}\n\n\tivtv_flush_queues(s);\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_VBI)\n\t\tivtv_set_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\n\t\ts_vbi = &itv->streams[IVTV_DEC_STREAM_TYPE_VBI];\n\telse if (s->type == IVTV_ENC_STREAM_TYPE_MPG)\n\t\ts_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\n\telse\n\t\treturn;\n\n\t \n\tif (!test_and_clear_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags)) {\n\t\t \n\t\treturn;\n\t}\n\tif (s_vbi->fh) {\n\t\t \n\t\treturn;\n\t}\n\t \n\tif (s_vbi->type == IVTV_DEC_STREAM_TYPE_VBI)\n\t\tivtv_set_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\n\tclear_bit(IVTV_F_S_CLAIMED, &s_vbi->s_flags);\n\tivtv_flush_queues(s_vbi);\n}\nEXPORT_SYMBOL(ivtv_release_stream);\n\nstatic void ivtv_dualwatch(struct ivtv *itv)\n{\n\tstruct v4l2_tuner vt;\n\tu32 new_stereo_mode;\n\tconst u32 dual = 0x02;\n\n\tnew_stereo_mode = v4l2_ctrl_g_ctrl(itv->cxhdl.audio_mode);\n\tmemset(&vt, 0, sizeof(vt));\n\tivtv_call_all(itv, tuner, g_tuner, &vt);\n\tif (vt.audmode == V4L2_TUNER_MODE_LANG1_LANG2 && (vt.rxsubchans & V4L2_TUNER_SUB_LANG2))\n\t\tnew_stereo_mode = dual;\n\n\tif (new_stereo_mode == itv->dualwatch_stereo_mode)\n\t\treturn;\n\n\tIVTV_DEBUG_INFO(\"dualwatch: change stereo flag from 0x%x to 0x%x.\\n\",\n\t\t\t   itv->dualwatch_stereo_mode, new_stereo_mode);\n\tif (v4l2_ctrl_s_ctrl(itv->cxhdl.audio_mode, new_stereo_mode))\n\t\tIVTV_DEBUG_INFO(\"dualwatch: changing stereo flag failed\\n\");\n}\n\nstatic void ivtv_update_pgm_info(struct ivtv *itv)\n{\n\tu32 wr_idx = (read_enc(itv->pgm_info_offset) - itv->pgm_info_offset - 4) / 24;\n\tint cnt;\n\tint i = 0;\n\n\tif (wr_idx >= itv->pgm_info_num) {\n\t\tIVTV_DEBUG_WARN(\"Invalid PGM index %d (>= %d)\\n\", wr_idx, itv->pgm_info_num);\n\t\treturn;\n\t}\n\tcnt = (wr_idx + itv->pgm_info_num - itv->pgm_info_write_idx) % itv->pgm_info_num;\n\twhile (i < cnt) {\n\t\tint idx = (itv->pgm_info_write_idx + i) % itv->pgm_info_num;\n\t\tstruct v4l2_enc_idx_entry *e = itv->pgm_info + idx;\n\t\tu32 addr = itv->pgm_info_offset + 4 + idx * 24;\n\t\tconst int mapping[8] = { -1, V4L2_ENC_IDX_FRAME_I, V4L2_ENC_IDX_FRAME_P, -1,\n\t\t\tV4L2_ENC_IDX_FRAME_B, -1, -1, -1 };\n\t\t\t\t\t \n\n\t\te->offset = read_enc(addr + 4) + ((u64)read_enc(addr + 8) << 32);\n\t\tif (e->offset > itv->mpg_data_received) {\n\t\t\tbreak;\n\t\t}\n\t\te->offset += itv->vbi_data_inserted;\n\t\te->length = read_enc(addr);\n\t\te->pts = read_enc(addr + 16) + ((u64)(read_enc(addr + 20) & 1) << 32);\n\t\te->flags = mapping[read_enc(addr + 12) & 7];\n\t\ti++;\n\t}\n\titv->pgm_info_write_idx = (itv->pgm_info_write_idx + i) % itv->pgm_info_num;\n}\n\nstatic struct ivtv_buffer *ivtv_get_buffer(struct ivtv_stream *s, int non_block, int *err)\n{\n\tstruct ivtv *itv = s->itv;\n\tstruct ivtv_stream *s_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\n\tstruct ivtv_buffer *buf;\n\tDEFINE_WAIT(wait);\n\n\t*err = 0;\n\twhile (1) {\n\t\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG) {\n\t\t\t \n\t\t\tivtv_update_pgm_info(itv);\n\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       itv->dualwatch_jiffies +\n\t\t\t\t       msecs_to_jiffies(1000))) {\n\t\t\t\titv->dualwatch_jiffies = jiffies;\n\t\t\t\tivtv_dualwatch(itv);\n\t\t\t}\n\n\t\t\tif (test_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\n\t\t\t    !test_bit(IVTV_F_S_APPL_IO, &s_vbi->s_flags)) {\n\t\t\t\twhile ((buf = ivtv_dequeue(s_vbi, &s_vbi->q_full))) {\n\t\t\t\t\t \n\t\t\t\t\tivtv_process_vbi_data(itv, buf, s_vbi->dma_pts, s_vbi->type);\n\t\t\t\t\tivtv_enqueue(s_vbi, buf, &s_vbi->q_free);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf = &itv->vbi.sliced_mpeg_buf;\n\t\t\tif (buf->readpos != buf->bytesused) {\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbuf = ivtv_dequeue(s, &s->q_io);\n\t\tif (buf)\n\t\t\treturn buf;\n\n\t\t \n\t\tbuf = ivtv_dequeue(s, &s->q_full);\n\t\tif (buf) {\n\t\t\tif ((buf->b_flags & IVTV_F_B_NEED_BUF_SWAP) == 0)\n\t\t\t\treturn buf;\n\t\t\tbuf->b_flags &= ~IVTV_F_B_NEED_BUF_SWAP;\n\t\t\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG)\n\t\t\t\t \n\t\t\t\tivtv_buf_swap(buf);\n\t\t\telse if (s->type != IVTV_DEC_STREAM_TYPE_VBI) {\n\t\t\t\t \n\t\t\t\tivtv_process_vbi_data(itv, buf, s->dma_pts, s->type);\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\n\t\t \n\t\tif (s->type != IVTV_DEC_STREAM_TYPE_VBI && !test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\t\tIVTV_DEBUG_INFO(\"EOS %s\\n\", s->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (non_block) {\n\t\t\t*err = -EAGAIN;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&itv->serialize_lock);\n\t\tprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t \n\t\tif (!s->q_full.buffers)\n\t\t\tschedule();\n\t\tfinish_wait(&s->waitq, &wait);\n\t\tmutex_lock(&itv->serialize_lock);\n\t\tif (signal_pending(current)) {\n\t\t\t \n\t\t\tIVTV_DEBUG_INFO(\"User stopped %s\\n\", s->name);\n\t\t\t*err = -EINTR;\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\nstatic void ivtv_setup_sliced_vbi_buf(struct ivtv *itv)\n{\n\tint idx = itv->vbi.inserted_frame % IVTV_VBI_FRAMES;\n\n\titv->vbi.sliced_mpeg_buf.buf = itv->vbi.sliced_mpeg_data[idx];\n\titv->vbi.sliced_mpeg_buf.bytesused = itv->vbi.sliced_mpeg_size[idx];\n\titv->vbi.sliced_mpeg_buf.readpos = 0;\n}\n\nstatic size_t ivtv_copy_buf_to_user(struct ivtv_stream *s, struct ivtv_buffer *buf,\n\t\tchar __user *ubuf, size_t ucount)\n{\n\tstruct ivtv *itv = s->itv;\n\tsize_t len = buf->bytesused - buf->readpos;\n\n\tif (len > ucount) len = ucount;\n\tif (itv->vbi.insert_mpeg && s->type == IVTV_ENC_STREAM_TYPE_MPG &&\n\t    !ivtv_raw_vbi(itv) && buf != &itv->vbi.sliced_mpeg_buf) {\n\t\tconst char *start = buf->buf + buf->readpos;\n\t\tconst char *p = start + 1;\n\t\tconst u8 *q;\n\t\tu8 ch = itv->search_pack_header ? 0xba : 0xe0;\n\t\tint stuffing, i;\n\n\t\twhile (start + len > p && (q = memchr(p, 0, start + len - p))) {\n\t\t\tp = q + 1;\n\t\t\tif ((char *)q + 15 >= buf->buf + buf->bytesused ||\n\t\t\t    q[1] != 0 || q[2] != 1 || q[3] != ch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!itv->search_pack_header) {\n\t\t\t\tif ((q[6] & 0xc0) != 0x80)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (((q[7] & 0xc0) == 0x80 && (q[9] & 0xf0) == 0x20) ||\n\t\t\t\t    ((q[7] & 0xc0) == 0xc0 && (q[9] & 0xf0) == 0x30)) {\n\t\t\t\t\tch = 0xba;\n\t\t\t\t\titv->search_pack_header = 1;\n\t\t\t\t\tp = q + 9;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstuffing = q[13] & 7;\n\t\t\t \n\t\t\tfor (i = 0; i < stuffing; i++)\n\t\t\t\tif (q[14 + i] != 0xff)\n\t\t\t\t\tbreak;\n\t\t\tif (i == stuffing && (q[4] & 0xc4) == 0x44 && (q[12] & 3) == 3 &&\n\t\t\t\t\tq[14 + stuffing] == 0 && q[15 + stuffing] == 0 &&\n\t\t\t\t\tq[16 + stuffing] == 1) {\n\t\t\t\titv->search_pack_header = 0;\n\t\t\t\tlen = (char *)q - start;\n\t\t\t\tivtv_setup_sliced_vbi_buf(itv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (copy_to_user(ubuf, (u8 *)buf->buf + buf->readpos, len)) {\n\t\tIVTV_DEBUG_WARN(\"copy %zd bytes to user failed for %s\\n\", len, s->name);\n\t\treturn -EFAULT;\n\t}\n\t \n\tbuf->readpos += len;\n\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG && buf != &itv->vbi.sliced_mpeg_buf)\n\t\titv->mpg_data_received += len;\n\treturn len;\n}\n\nstatic ssize_t ivtv_read(struct ivtv_stream *s, char __user *ubuf, size_t tot_count, int non_block)\n{\n\tstruct ivtv *itv = s->itv;\n\tsize_t tot_written = 0;\n\tint single_frame = 0;\n\n\tif (atomic_read(&itv->capturing) == 0 && s->fh == NULL) {\n\t\t \n\t\tIVTV_DEBUG_WARN(\"Stream %s not initialized before read\\n\", s->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_VBI ||\n\t    (s->type == IVTV_ENC_STREAM_TYPE_VBI && !ivtv_raw_vbi(itv)))\n\t\tsingle_frame = 1;\n\n\tfor (;;) {\n\t\tstruct ivtv_buffer *buf;\n\t\tint rc;\n\n\t\tbuf = ivtv_get_buffer(s, non_block, &rc);\n\t\t \n\t\tif (buf == NULL) {\n\t\t\t \n\t\t\tif (tot_written)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (rc == 0) {\n\t\t\t\tclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\t\t\t\tclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\t\t\tivtv_release_stream(s);\n\t\t\t}\n\t\t\t \n\t\t\treturn rc;\n\t\t}\n\t\trc = ivtv_copy_buf_to_user(s, buf, ubuf + tot_written, tot_count - tot_written);\n\t\tif (buf != &itv->vbi.sliced_mpeg_buf) {\n\t\t\tivtv_enqueue(s, buf, (buf->readpos == buf->bytesused) ? &s->q_free : &s->q_io);\n\t\t}\n\t\telse if (buf->readpos == buf->bytesused) {\n\t\t\tint idx = itv->vbi.inserted_frame % IVTV_VBI_FRAMES;\n\t\t\titv->vbi.sliced_mpeg_size[idx] = 0;\n\t\t\titv->vbi.inserted_frame++;\n\t\t\titv->vbi_data_inserted += buf->bytesused;\n\t\t}\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\ttot_written += rc;\n\n\t\tif (tot_written == tot_count || single_frame)\n\t\t\tbreak;\n\t}\n\treturn tot_written;\n}\n\nstatic ssize_t ivtv_read_pos(struct ivtv_stream *s, char __user *ubuf, size_t count,\n\t\t\tloff_t *pos, int non_block)\n{\n\tssize_t rc = count ? ivtv_read(s, ubuf, count, non_block) : 0;\n\tstruct ivtv *itv = s->itv;\n\n\tIVTV_DEBUG_HI_FILE(\"read %zd from %s, got %zd\\n\", count, s->name, rc);\n\tif (rc > 0)\n\t\t*pos += rc;\n\treturn rc;\n}\n\nint ivtv_start_capture(struct ivtv_open_id *id)\n{\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\tstruct ivtv_stream *s_vbi;\n\n\tif (s->type == IVTV_ENC_STREAM_TYPE_RAD ||\n\t    s->type == IVTV_DEC_STREAM_TYPE_MPG ||\n\t    s->type == IVTV_DEC_STREAM_TYPE_YUV ||\n\t    s->type == IVTV_DEC_STREAM_TYPE_VOUT) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ivtv_claim_stream(id, s->type))\n\t\treturn -EBUSY;\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_VBI) {\n\t\tset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (test_bit(IVTV_F_S_STREAMOFF, &s->s_flags) || test_and_set_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\tset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\treturn 0;\n\t}\n\n\t \n\ts_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\n\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG &&\n\t    test_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\n\t    !test_and_set_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags)) {\n\t\t \n\t\tif (ivtv_start_v4l2_encode_stream(s_vbi)) {\n\t\t\tIVTV_DEBUG_WARN(\"VBI capture start failed\\n\");\n\n\t\t\t \n\t\t\tclear_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags);\n\t\t\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\t\t\t \n\t\t\tivtv_release_stream(s);\n\t\t\treturn -EIO;\n\t\t}\n\t\tIVTV_DEBUG_INFO(\"VBI insertion started\\n\");\n\t}\n\n\t \n\tif (!ivtv_start_v4l2_encode_stream(s)) {\n\t\t \n\t\tset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\t \n\t\tif (test_and_clear_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\n\t\t\tivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 1);\n\t\treturn 0;\n\t}\n\n\t \n\tIVTV_DEBUG_WARN(\"Failed to start capturing for stream %s\\n\", s->name);\n\n\t \n\tif (s->type == IVTV_ENC_STREAM_TYPE_MPG &&\n\t    test_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags)) {\n\t\tivtv_stop_v4l2_encode_stream(s_vbi, 0);\n\t\tclear_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags);\n\t}\n\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\tivtv_release_stream(s);\n\treturn -EIO;\n}\n\nssize_t ivtv_v4l2_read(struct file * filp, char __user *buf, size_t count, loff_t * pos)\n{\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\tssize_t rc;\n\n\tIVTV_DEBUG_HI_FILE(\"read %zd bytes from %s\\n\", count, s->name);\n\n\tif (mutex_lock_interruptible(&itv->serialize_lock))\n\t\treturn -ERESTARTSYS;\n\trc = ivtv_start_capture(id);\n\tif (!rc)\n\t\trc = ivtv_read_pos(s, buf, count, pos, filp->f_flags & O_NONBLOCK);\n\tmutex_unlock(&itv->serialize_lock);\n\treturn rc;\n}\n\nint ivtv_start_decoding(struct ivtv_open_id *id, int speed)\n{\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\tint rc;\n\n\tif (atomic_read(&itv->decoding) == 0) {\n\t\tif (ivtv_claim_stream(id, s->type)) {\n\t\t\t \n\t\t\tIVTV_DEBUG_WARN(\"start decode, stream already claimed\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trc = ivtv_start_v4l2_decode_stream(s, 0);\n\t\tif (rc < 0) {\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\trc = ivtv_start_v4l2_decode_stream(s, 0);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\n\t\treturn ivtv_set_speed(itv, speed);\n\treturn 0;\n}\n\nstatic ssize_t ivtv_write(struct file *filp, const char __user *user_buf, size_t count, loff_t *pos)\n{\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\tstruct yuv_playback_info *yi = &itv->yuv_info;\n\tstruct ivtv_buffer *buf;\n\tstruct ivtv_queue q;\n\tint bytes_written = 0;\n\tint mode;\n\tint rc;\n\tDEFINE_WAIT(wait);\n\n\tIVTV_DEBUG_HI_FILE(\"write %zd bytes to %s\\n\", count, s->name);\n\n\tif (s->type != IVTV_DEC_STREAM_TYPE_MPG &&\n\t    s->type != IVTV_DEC_STREAM_TYPE_YUV &&\n\t    s->type != IVTV_DEC_STREAM_TYPE_VOUT)\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tif (ivtv_claim_stream(id, s->type))\n\t\treturn -EBUSY;\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_VOUT) {\n\t\tint elems = count / sizeof(struct v4l2_sliced_vbi_data);\n\n\t\tset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\treturn ivtv_write_vbi_from_user(itv,\n\t\t   (const struct v4l2_sliced_vbi_data __user *)user_buf, elems);\n\t}\n\n\tmode = s->type == IVTV_DEC_STREAM_TYPE_MPG ? OUT_MPG : OUT_YUV;\n\n\tif (ivtv_set_output_mode(itv, mode) != mode) {\n\t    ivtv_release_stream(s);\n\t    return -EBUSY;\n\t}\n\tivtv_queue_init(&q);\n\tset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\n\t \n\trc = ivtv_start_decoding(id, itv->speed);\n\tif (rc) {\n\t\tIVTV_DEBUG_WARN(\"Failed start decode stream %s\\n\", s->name);\n\n\t\t \n\t\tclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\n\t\tclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\treturn rc;\n\t}\n\nretry:\n\t \n\tif (mode == OUT_YUV && s->q_full.length == 0 && itv->dma_data_req_size) {\n\t\twhile (count >= itv->dma_data_req_size) {\n\t\t\trc = ivtv_yuv_udma_stream_frame(itv, (void __user *)user_buf);\n\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tbytes_written += itv->dma_data_req_size;\n\t\t\tuser_buf += itv->dma_data_req_size;\n\t\t\tcount -= itv->dma_data_req_size;\n\t\t}\n\t\tif (count == 0) {\n\t\t\tIVTV_DEBUG_HI_FILE(\"Wrote %d bytes to %s (%d)\\n\", bytes_written, s->name, s->q_full.bytesused);\n\t\t\treturn bytes_written;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t \n\t\twhile (q.length - q.bytesused < count && (buf = ivtv_dequeue(s, &s->q_io)))\n\t\t\tivtv_enqueue(s, buf, &q);\n\t\twhile (q.length - q.bytesused < count && (buf = ivtv_dequeue(s, &s->q_free))) {\n\t\t\tivtv_enqueue(s, buf, &q);\n\t\t}\n\t\tif (q.buffers)\n\t\t\tbreak;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tmutex_unlock(&itv->serialize_lock);\n\t\tprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t \n\t\tif (!s->q_free.buffers)\n\t\t\tschedule();\n\t\tfinish_wait(&s->waitq, &wait);\n\t\tmutex_lock(&itv->serialize_lock);\n\t\tif (signal_pending(current)) {\n\t\t\tIVTV_DEBUG_INFO(\"User stopped %s\\n\", s->name);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\t \n\twhile ((buf = ivtv_dequeue(s, &q))) {\n\t\t \n\t\tif (s->type == IVTV_DEC_STREAM_TYPE_YUV &&\n\t\t    yi->stream_size + count > itv->dma_data_req_size)\n\t\t\trc  = ivtv_buf_copy_from_user(s, buf, user_buf,\n\t\t\t\titv->dma_data_req_size - yi->stream_size);\n\t\telse\n\t\t\trc = ivtv_buf_copy_from_user(s, buf, user_buf, count);\n\n\t\t \n\t\tif (rc < 0) {\n\t\t\tivtv_queue_move(s, &q, NULL, &s->q_free, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tuser_buf += rc;\n\t\tcount -= rc;\n\t\tbytes_written += rc;\n\n\t\tif (s->type == IVTV_DEC_STREAM_TYPE_YUV) {\n\t\t\tyi->stream_size += rc;\n\t\t\t \n\t\t\tif (yi->stream_size == itv->dma_data_req_size) {\n\t\t\t\tivtv_enqueue(s, buf, &s->q_full);\n\t\t\t\tyi->stream_size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (buf->bytesused != s->buf_size) {\n\t\t\t \n\t\t\tivtv_enqueue(s, buf, &s->q_io);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\n\t\t\tivtv_buf_swap(buf);\n\t\tivtv_enqueue(s, buf, &s->q_full);\n\t}\n\n\tif (test_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags)) {\n\t\tif (s->q_full.length >= itv->dma_data_req_size) {\n\t\t\tint got_sig;\n\n\t\t\tif (mode == OUT_YUV)\n\t\t\t\tivtv_yuv_setup_stream_frame(itv);\n\n\t\t\tmutex_unlock(&itv->serialize_lock);\n\t\t\tprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\twhile (!(got_sig = signal_pending(current)) &&\n\t\t\t\t\ttest_bit(IVTV_F_S_DMA_PENDING, &s->s_flags)) {\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(&itv->dma_waitq, &wait);\n\t\t\tmutex_lock(&itv->serialize_lock);\n\t\t\tif (got_sig) {\n\t\t\t\tIVTV_DEBUG_INFO(\"User interrupted %s\\n\", s->name);\n\t\t\t\treturn -EINTR;\n\t\t\t}\n\n\t\t\tclear_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags);\n\t\t\tivtv_queue_move(s, &s->q_full, NULL, &s->q_predma, itv->dma_data_req_size);\n\t\t\tivtv_dma_stream_dec_prepare(s, itv->dma_data_req_offset + IVTV_DECODER_OFFSET, 1);\n\t\t}\n\t}\n\t \n\tif (count && !(filp->f_flags & O_NONBLOCK))\n\t\tgoto retry;\n\tIVTV_DEBUG_HI_FILE(\"Wrote %d bytes to %s (%d)\\n\", bytes_written, s->name, s->q_full.bytesused);\n\treturn bytes_written;\n}\n\nssize_t ivtv_v4l2_write(struct file *filp, const char __user *user_buf, size_t count, loff_t *pos)\n{\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tssize_t res;\n\n\tif (mutex_lock_interruptible(&itv->serialize_lock))\n\t\treturn -ERESTARTSYS;\n\tres = ivtv_write(filp, user_buf, count, pos);\n\tmutex_unlock(&itv->serialize_lock);\n\treturn res;\n}\n\n__poll_t ivtv_v4l2_dec_poll(struct file *filp, poll_table *wait)\n{\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\t__poll_t res = 0;\n\n\t \n\tIVTV_DEBUG_HI_FILE(\"Decoder poll\\n\");\n\n\t \n\tif (!list_empty(&id->fh.subscribed)) {\n\t\tpoll_wait(filp, &id->fh.wait, wait);\n\t\t \n\t\tclear_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);\n\t\tif (v4l2_event_pending(&id->fh))\n\t\t\tres = EPOLLPRI;\n\t} else {\n\t\t \n\t\tpoll_wait(filp, &s->waitq, wait);\n\t\tset_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);\n\t\tif (test_bit(IVTV_F_I_EV_VSYNC, &itv->i_flags) ||\n\t\t    test_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))\n\t\t\tres = EPOLLPRI;\n\t}\n\n\t \n\tif (s->q_free.buffers)\n\t\tres |= EPOLLOUT | EPOLLWRNORM;\n\treturn res;\n}\n\n__poll_t ivtv_v4l2_enc_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct ivtv_open_id *id = fh2id(filp->private_data);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\tint eof = test_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\t__poll_t res = 0;\n\n\t \n\tif (!eof && !test_bit(IVTV_F_S_STREAMING, &s->s_flags) &&\n\t\t\ts->type != IVTV_ENC_STREAM_TYPE_RAD &&\n\t\t\t(req_events & (EPOLLIN | EPOLLRDNORM))) {\n\t\tint rc;\n\n\t\tmutex_lock(&itv->serialize_lock);\n\t\trc = ivtv_start_capture(id);\n\t\tmutex_unlock(&itv->serialize_lock);\n\t\tif (rc) {\n\t\t\tIVTV_DEBUG_INFO(\"Could not start capture for %s (%d)\\n\",\n\t\t\t\t\ts->name, rc);\n\t\t\treturn EPOLLERR;\n\t\t}\n\t\tIVTV_DEBUG_FILE(\"Encoder poll started capture\\n\");\n\t}\n\n\t \n\tIVTV_DEBUG_HI_FILE(\"Encoder poll\\n\");\n\tpoll_wait(filp, &s->waitq, wait);\n\tif (v4l2_event_pending(&id->fh))\n\t\tres |= EPOLLPRI;\n\telse\n\t\tpoll_wait(filp, &id->fh.wait, wait);\n\n\tif (s->q_full.length || s->q_io.length)\n\t\treturn res | EPOLLIN | EPOLLRDNORM;\n\tif (eof)\n\t\treturn res | EPOLLHUP;\n\treturn res;\n}\n\nvoid ivtv_stop_capture(struct ivtv_open_id *id, int gop_end)\n{\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\n\tIVTV_DEBUG_FILE(\"close() of %s\\n\", s->name);\n\n\t \n\n\t \n\tif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\tstruct ivtv_stream *s_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\n\n\t\tIVTV_DEBUG_INFO(\"close stopping capture\\n\");\n\t\t \n\t\tif (id->type == IVTV_ENC_STREAM_TYPE_MPG &&\n\t\t    test_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags) &&\n\t\t    !test_bit(IVTV_F_S_APPL_IO, &s_vbi->s_flags)) {\n\t\t\tIVTV_DEBUG_INFO(\"close stopping embedded VBI capture\\n\");\n\t\t\tivtv_stop_v4l2_encode_stream(s_vbi, 0);\n\t\t}\n\t\tif ((id->type == IVTV_DEC_STREAM_TYPE_VBI ||\n\t\t     id->type == IVTV_ENC_STREAM_TYPE_VBI) &&\n\t\t    test_bit(IVTV_F_S_INTERNAL_USE, &s->s_flags)) {\n\t\t\t \n\t\t\ts->fh = NULL;\n\t\t}\n\t\telse {\n\t\t\tivtv_stop_v4l2_encode_stream(s, gop_end);\n\t\t}\n\t}\n\tif (!gop_end) {\n\t\tclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\t\tclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\t\tivtv_release_stream(s);\n\t}\n}\n\nstatic void ivtv_stop_decoding(struct ivtv_open_id *id, int flags, u64 pts)\n{\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\n\tIVTV_DEBUG_FILE(\"close() of %s\\n\", s->name);\n\n\tif (id->type == IVTV_DEC_STREAM_TYPE_YUV &&\n\t\ttest_bit(IVTV_F_I_DECODING_YUV, &itv->i_flags)) {\n\t\t \n\t\tivtv_yuv_close(itv);\n\t}\n\n\t \n\tif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\n\t\tIVTV_DEBUG_INFO(\"close stopping decode\\n\");\n\n\t\tivtv_stop_v4l2_decode_stream(s, flags, pts);\n\t\titv->output_mode = OUT_NONE;\n\t}\n\tclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\n\tclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\n\n\tif (itv->output_mode == OUT_UDMA_YUV && id->yuv_frames)\n\t\titv->output_mode = OUT_NONE;\n\n\titv->speed = 0;\n\tclear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags);\n\tivtv_release_stream(s);\n}\n\nint ivtv_v4l2_close(struct file *filp)\n{\n\tstruct v4l2_fh *fh = filp->private_data;\n\tstruct ivtv_open_id *id = fh2id(fh);\n\tstruct ivtv *itv = id->itv;\n\tstruct ivtv_stream *s = &itv->streams[id->type];\n\n\tIVTV_DEBUG_FILE(\"close %s\\n\", s->name);\n\n\tmutex_lock(&itv->serialize_lock);\n\n\t \n\tif (id->type == IVTV_ENC_STREAM_TYPE_RAD &&\n\t\t\tv4l2_fh_is_singular_file(filp)) {\n\t\t \n\t\tivtv_mute(itv);\n\t\t \n\t\tclear_bit(IVTV_F_I_RADIO_USER, &itv->i_flags);\n\t\t \n\t\tivtv_call_all(itv, video, s_std, itv->std);\n\t\t \n\t\tivtv_audio_set_io(itv);\n\t\tif (itv->hw_flags & IVTV_HW_SAA711X) {\n\t\t\tivtv_call_hw(itv, IVTV_HW_SAA711X, video, s_crystal_freq,\n\t\t\t\t\tSAA7115_FREQ_32_11_MHZ, 0);\n\t\t}\n\t\tif (atomic_read(&itv->capturing) > 0) {\n\t\t\t \n\t\t\tivtv_vapi(itv, CX2341X_ENC_MUTE_VIDEO, 1,\n\t\t\t\t\tv4l2_ctrl_g_ctrl(itv->cxhdl.video_mute) |\n\t\t\t\t\t(v4l2_ctrl_g_ctrl(itv->cxhdl.video_mute_yuv) << 8));\n\t\t}\n\t\t \n\t\tivtv_unmute(itv);\n\t}\n\n\tv4l2_fh_del(fh);\n\tv4l2_fh_exit(fh);\n\n\t \n\tif (s->fh != &id->fh)\n\t\tgoto close_done;\n\n\t \n\n\tif (s->type >= IVTV_DEC_STREAM_TYPE_MPG) {\n\t\tstruct ivtv_stream *s_vout = &itv->streams[IVTV_DEC_STREAM_TYPE_VOUT];\n\n\t\tivtv_stop_decoding(id, V4L2_DEC_CMD_STOP_TO_BLACK | V4L2_DEC_CMD_STOP_IMMEDIATELY, 0);\n\n\t\t \n\t\tif (itv->output_mode == OUT_NONE && !test_bit(IVTV_F_S_APPL_IO, &s_vout->s_flags)) {\n\t\t\t \n\t\t\tivtv_disable_cc(itv);\n\t\t}\n\t} else {\n\t\tivtv_stop_capture(id, 0);\n\t}\nclose_done:\n\tkfree(id);\n\tmutex_unlock(&itv->serialize_lock);\n\treturn 0;\n}\n\nstatic int ivtv_open(struct file *filp)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tstruct ivtv_stream *s = video_get_drvdata(vdev);\n\tstruct ivtv *itv = s->itv;\n\tstruct ivtv_open_id *item;\n\tint res = 0;\n\n\tIVTV_DEBUG_FILE(\"open %s\\n\", s->name);\n\n\tif (ivtv_init_on_first_open(itv)) {\n\t\tIVTV_ERR(\"Failed to initialize on device %s\\n\",\n\t\t\t video_device_node_name(vdev));\n\t\treturn -ENXIO;\n\t}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t \n\tif (ivtv_fw_debug) {\n\t\tIVTV_WARN(\"Opening %s with dead firmware lockout disabled\\n\",\n\t\t\t  video_device_node_name(vdev));\n\t\tIVTV_WARN(\"Selected firmware errors will be ignored\\n\");\n\t} else {\n#else\n\tif (1) {\n#endif\n\t\tres = ivtv_firmware_check(itv, \"ivtv_serialized_open\");\n\t\tif (res == -EAGAIN)\n\t\t\tres = ivtv_firmware_check(itv, \"ivtv_serialized_open\");\n\t\tif (res < 0)\n\t\t\treturn -EIO;\n\t}\n\n\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG &&\n\t\ttest_bit(IVTV_F_S_CLAIMED, &itv->streams[IVTV_DEC_STREAM_TYPE_YUV].s_flags))\n\t\treturn -EBUSY;\n\n\tif (s->type == IVTV_DEC_STREAM_TYPE_YUV &&\n\t\ttest_bit(IVTV_F_S_CLAIMED, &itv->streams[IVTV_DEC_STREAM_TYPE_MPG].s_flags))\n\t\treturn -EBUSY;\n\n\tif (s->type == IVTV_DEC_STREAM_TYPE_YUV) {\n\t\tif (read_reg(0x82c) == 0) {\n\t\t\tIVTV_ERR(\"Tried to open YUV output device but need to send data to mpeg decoder before it can be used\\n\");\n\t\t\t \n\t\t}\n\t\tivtv_udma_alloc(itv);\n\t}\n\n\t \n\titem = kzalloc(sizeof(struct ivtv_open_id), GFP_KERNEL);\n\tif (NULL == item) {\n\t\tIVTV_DEBUG_WARN(\"nomem on v4l2 open\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tv4l2_fh_init(&item->fh, &s->vdev);\n\titem->itv = itv;\n\titem->type = s->type;\n\n\tfilp->private_data = &item->fh;\n\tv4l2_fh_add(&item->fh);\n\n\tif (item->type == IVTV_ENC_STREAM_TYPE_RAD &&\n\t\t\tv4l2_fh_is_singular_file(filp)) {\n\t\tif (!test_bit(IVTV_F_I_RADIO_USER, &itv->i_flags)) {\n\t\t\tif (atomic_read(&itv->capturing) > 0) {\n\t\t\t\t \n\t\t\t\tv4l2_fh_del(&item->fh);\n\t\t\t\tv4l2_fh_exit(&item->fh);\n\t\t\t\tkfree(item);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t\t \n\t\tset_bit(IVTV_F_I_RADIO_USER, &itv->i_flags);\n\t\t \n\t\tivtv_mute(itv);\n\t\t \n\t\tivtv_call_all(itv, tuner, s_radio);\n\t\t \n\t\tivtv_audio_set_io(itv);\n\t\tif (itv->hw_flags & IVTV_HW_SAA711X) {\n\t\t\tivtv_call_hw(itv, IVTV_HW_SAA711X, video, s_crystal_freq,\n\t\t\t\tSAA7115_FREQ_32_11_MHZ, SAA7115_FREQ_FL_APLL);\n\t\t}\n\t\t \n\t\tivtv_unmute(itv);\n\t}\n\n\t \n\tif (s->type == IVTV_DEC_STREAM_TYPE_MPG) {\n\t\tclear_bit(IVTV_F_I_DEC_YUV, &itv->i_flags);\n\t} else if (s->type == IVTV_DEC_STREAM_TYPE_YUV) {\n\t\tset_bit(IVTV_F_I_DEC_YUV, &itv->i_flags);\n\t\t \n\t\titv->dma_data_req_size =\n\t\t\t\t1080 * ((itv->yuv_info.v4l2_src_h + 31) & ~31);\n\t\titv->yuv_info.stream_size = 0;\n\t}\n\treturn 0;\n}\n\nint ivtv_v4l2_open(struct file *filp)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint res;\n\n\tif (mutex_lock_interruptible(vdev->lock))\n\t\treturn -ERESTARTSYS;\n\tres = ivtv_open(filp);\n\tmutex_unlock(vdev->lock);\n\treturn res;\n}\n\nvoid ivtv_mute(struct ivtv *itv)\n{\n\tif (atomic_read(&itv->capturing))\n\t\tivtv_vapi(itv, CX2341X_ENC_MUTE_AUDIO, 1, 1);\n\tIVTV_DEBUG_INFO(\"Mute\\n\");\n}\n\nvoid ivtv_unmute(struct ivtv *itv)\n{\n\tif (atomic_read(&itv->capturing)) {\n\t\tivtv_msleep_timeout(100, 0);\n\t\tivtv_vapi(itv, CX2341X_ENC_MISC, 1, 12);\n\t\tivtv_vapi(itv, CX2341X_ENC_MUTE_AUDIO, 1, 0);\n\t}\n\tIVTV_DEBUG_INFO(\"Unmute\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}