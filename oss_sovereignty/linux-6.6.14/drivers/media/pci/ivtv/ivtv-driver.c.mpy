{
  "module_name": "ivtv-driver.c",
  "hash_id": "8843ab2c4f9c469cc14d5ba0f880f96b9dc06332741dfbbc0ab9db79bd60e5d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ivtv/ivtv-driver.c",
  "human_readable_source": " \n\n \n\n#include \"ivtv-driver.h\"\n#include \"ivtv-version.h\"\n#include \"ivtv-fileops.h\"\n#include \"ivtv-i2c.h\"\n#include \"ivtv-firmware.h\"\n#include \"ivtv-queue.h\"\n#include \"ivtv-udma.h\"\n#include \"ivtv-irq.h\"\n#include \"ivtv-mailbox.h\"\n#include \"ivtv-streams.h\"\n#include \"ivtv-ioctl.h\"\n#include \"ivtv-cards.h\"\n#include \"ivtv-vbi.h\"\n#include \"ivtv-routing.h\"\n#include \"ivtv-controls.h\"\n#include \"ivtv-gpio.h\"\n#include <linux/dma-mapping.h>\n#include <media/tveeprom.h>\n#include <media/i2c/saa7115.h>\n#include \"xc2028.h\"\n#include <uapi/linux/sched/types.h>\n\n \nint ivtv_first_minor;\n\n \nint (*ivtv_ext_init)(struct ivtv *);\nEXPORT_SYMBOL(ivtv_ext_init);\n\n \nstatic const struct pci_device_id ivtv_pci_tbl[] = {\n\t{PCI_VENDOR_ID_ICOMP, PCI_DEVICE_ID_IVTV15,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ICOMP, PCI_DEVICE_ID_IVTV16,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci,ivtv_pci_tbl);\n\n \nstatic atomic_t ivtv_instance = ATOMIC_INIT(0);\n\n \nstatic int cardtype[IVTV_MAX_CARDS];\nstatic int tuner[IVTV_MAX_CARDS] = { -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int radio[IVTV_MAX_CARDS] = { -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t     -1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int i2c_clock_period[IVTV_MAX_CARDS] = { -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t\t       -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t\t       -1, -1, -1, -1, -1, -1, -1, -1,\n\t\t\t\t\t       -1, -1, -1, -1, -1, -1, -1, -1 };\n\nstatic unsigned int cardtype_c = 1;\nstatic unsigned int tuner_c = 1;\nstatic int radio_c = 1;\nstatic unsigned int i2c_clock_period_c = 1;\nstatic char pal[] = \"---\";\nstatic char secam[] = \"--\";\nstatic char ntsc[] = \"-\";\n\n \n\n \n#define IVTV_DEFAULT_ENC_MPG_BUFFERS 4\n#define IVTV_DEFAULT_ENC_YUV_BUFFERS 2\n#define IVTV_DEFAULT_ENC_VBI_BUFFERS 1\n \n#define IVTV_DEFAULT_ENC_PCM_BUFFERS 320\n#define IVTV_DEFAULT_DEC_MPG_BUFFERS 1\n#define IVTV_DEFAULT_DEC_YUV_BUFFERS 1\n \n#define IVTV_DEFAULT_DEC_VBI_BUFFERS 64\n\nstatic int enc_mpg_buffers = IVTV_DEFAULT_ENC_MPG_BUFFERS;\nstatic int enc_yuv_buffers = IVTV_DEFAULT_ENC_YUV_BUFFERS;\nstatic int enc_vbi_buffers = IVTV_DEFAULT_ENC_VBI_BUFFERS;\nstatic int enc_pcm_buffers = IVTV_DEFAULT_ENC_PCM_BUFFERS;\nstatic int dec_mpg_buffers = IVTV_DEFAULT_DEC_MPG_BUFFERS;\nstatic int dec_yuv_buffers = IVTV_DEFAULT_DEC_YUV_BUFFERS;\nstatic int dec_vbi_buffers = IVTV_DEFAULT_DEC_VBI_BUFFERS;\n\nstatic int ivtv_yuv_mode;\nstatic int ivtv_yuv_threshold = -1;\nstatic int ivtv_pci_latency = 1;\n\nint ivtv_debug;\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nint ivtv_fw_debug;\n#endif\n\nstatic int tunertype = -1;\nstatic int newi2c = -1;\n\nmodule_param_array(tuner, int, &tuner_c, 0644);\nmodule_param_array(radio, int, &radio_c, 0644);\nmodule_param_array(cardtype, int, &cardtype_c, 0644);\nmodule_param_string(pal, pal, sizeof(pal), 0644);\nmodule_param_string(secam, secam, sizeof(secam), 0644);\nmodule_param_string(ntsc, ntsc, sizeof(ntsc), 0644);\nmodule_param_named(debug,ivtv_debug, int, 0644);\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nmodule_param_named(fw_debug, ivtv_fw_debug, int, 0644);\n#endif\nmodule_param(ivtv_pci_latency, int, 0644);\nmodule_param(ivtv_yuv_mode, int, 0644);\nmodule_param(ivtv_yuv_threshold, int, 0644);\nmodule_param(ivtv_first_minor, int, 0644);\n\nmodule_param(enc_mpg_buffers, int, 0644);\nmodule_param(enc_yuv_buffers, int, 0644);\nmodule_param(enc_vbi_buffers, int, 0644);\nmodule_param(enc_pcm_buffers, int, 0644);\nmodule_param(dec_mpg_buffers, int, 0644);\nmodule_param(dec_yuv_buffers, int, 0644);\nmodule_param(dec_vbi_buffers, int, 0644);\n\nmodule_param(tunertype, int, 0644);\nmodule_param(newi2c, int, 0644);\nmodule_param_array(i2c_clock_period, int, &i2c_clock_period_c, 0644);\n\nMODULE_PARM_DESC(tuner, \"Tuner type selection,\\n\"\n\t\t\t\"\\t\\t\\tsee tuner.h for values\");\nMODULE_PARM_DESC(radio,\n\t\t \"Enable or disable the radio. Use only if autodetection\\n\"\n\t\t \"\\t\\t\\tfails. 0 = disable, 1 = enable\");\nMODULE_PARM_DESC(cardtype,\n\t\t \"Only use this option if your card is not detected properly.\\n\"\n\t\t \"\\t\\tSpecify card type:\\n\"\n\t\t \"\\t\\t\\t 1 = WinTV PVR 250\\n\"\n\t\t \"\\t\\t\\t 2 = WinTV PVR 350\\n\"\n\t\t \"\\t\\t\\t 3 = WinTV PVR-150 or PVR-500\\n\"\n\t\t \"\\t\\t\\t 4 = AVerMedia M179\\n\"\n\t\t \"\\t\\t\\t 5 = YUAN MPG600/Kuroutoshikou iTVC16-STVLP\\n\"\n\t\t \"\\t\\t\\t 6 = YUAN MPG160/Kuroutoshikou iTVC15-STVLP\\n\"\n\t\t \"\\t\\t\\t 7 = YUAN PG600/DIAMONDMM PVR-550 (CX Falcon 2)\\n\"\n\t\t \"\\t\\t\\t 8 = Adaptec AVC-2410\\n\"\n\t\t \"\\t\\t\\t 9 = Adaptec AVC-2010\\n\"\n\t\t \"\\t\\t\\t10 = NAGASE TRANSGEAR 5000TV\\n\"\n\t\t \"\\t\\t\\t11 = AOpen VA2000MAX-STN6\\n\"\n\t\t \"\\t\\t\\t12 = YUAN MPG600GR/Kuroutoshikou CX23416GYC-STVLP\\n\"\n\t\t \"\\t\\t\\t13 = I/O Data GV-MVP/RX\\n\"\n\t\t \"\\t\\t\\t14 = I/O Data GV-MVP/RX2E\\n\"\n\t\t \"\\t\\t\\t15 = GOTVIEW PCI DVD\\n\"\n\t\t \"\\t\\t\\t16 = GOTVIEW PCI DVD2 Deluxe\\n\"\n\t\t \"\\t\\t\\t17 = Yuan MPC622\\n\"\n\t\t \"\\t\\t\\t18 = Digital Cowboy DCT-MTVP1\\n\"\n\t\t \"\\t\\t\\t19 = Yuan PG600V2/GotView PCI DVD Lite\\n\"\n\t\t \"\\t\\t\\t20 = Club3D ZAP-TV1x01\\n\"\n\t\t \"\\t\\t\\t21 = AverTV MCE 116 Plus\\n\"\n\t\t \"\\t\\t\\t22 = ASUS Falcon2\\n\"\n\t\t \"\\t\\t\\t23 = AverMedia PVR-150 Plus\\n\"\n\t\t \"\\t\\t\\t24 = AverMedia EZMaker PCI Deluxe\\n\"\n\t\t \"\\t\\t\\t25 = AverMedia M104 (not yet working)\\n\"\n\t\t \"\\t\\t\\t26 = Buffalo PC-MV5L/PCI\\n\"\n\t\t \"\\t\\t\\t27 = AVerMedia UltraTV 1500 MCE\\n\"\n\t\t \"\\t\\t\\t28 = Sony VAIO Giga Pocket (ENX Kikyou)\\n\"\n\t\t \"\\t\\t\\t 0 = Autodetect (default)\\n\"\n\t\t \"\\t\\t\\t-1 = Ignore this card\\n\\t\\t\");\nMODULE_PARM_DESC(pal, \"Set PAL standard: BGH, DK, I, M, N, Nc, 60\");\nMODULE_PARM_DESC(secam, \"Set SECAM standard: BGH, DK, L, LC\");\nMODULE_PARM_DESC(ntsc, \"Set NTSC standard: M, J (Japan), K (South Korea)\");\nMODULE_PARM_DESC(tunertype,\n\t\t\"Specify tuner type:\\n\"\n\t\t\"\\t\\t\\t 0 = tuner for PAL-B/G/H/D/K/I, SECAM-B/G/H/D/K/L/Lc\\n\"\n\t\t\"\\t\\t\\t 1 = tuner for NTSC-M/J/K, PAL-M/N/Nc\\n\"\n\t\t\"\\t\\t\\t-1 = Autodetect (default)\\n\");\nMODULE_PARM_DESC(debug,\n\t\t \"Debug level (bitmask). Default: 0\\n\"\n\t\t \"\\t\\t\\t   1/0x0001: warning\\n\"\n\t\t \"\\t\\t\\t   2/0x0002: info\\n\"\n\t\t \"\\t\\t\\t   4/0x0004: mailbox\\n\"\n\t\t \"\\t\\t\\t   8/0x0008: ioctl\\n\"\n\t\t \"\\t\\t\\t  16/0x0010: file\\n\"\n\t\t \"\\t\\t\\t  32/0x0020: dma\\n\"\n\t\t \"\\t\\t\\t  64/0x0040: irq\\n\"\n\t\t \"\\t\\t\\t 128/0x0080: decoder\\n\"\n\t\t \"\\t\\t\\t 256/0x0100: yuv\\n\"\n\t\t \"\\t\\t\\t 512/0x0200: i2c\\n\"\n\t\t \"\\t\\t\\t1024/0x0400: high volume\\n\");\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nMODULE_PARM_DESC(fw_debug,\n\t\t \"Enable code for debugging firmware problems.  Default: 0\\n\");\n#endif\nMODULE_PARM_DESC(ivtv_pci_latency,\n\t\t \"Change the PCI latency to 64 if lower: 0 = No, 1 = Yes,\\n\"\n\t\t \"\\t\\t\\tDefault: Yes\");\nMODULE_PARM_DESC(ivtv_yuv_mode,\n\t\t \"Specify the yuv playback mode:\\n\"\n\t\t \"\\t\\t\\t0 = interlaced\\n\\t\\t\\t1 = progressive\\n\\t\\t\\t2 = auto\\n\"\n\t\t \"\\t\\t\\tDefault: 0 (interlaced)\");\nMODULE_PARM_DESC(ivtv_yuv_threshold,\n\t\t \"If ivtv_yuv_mode is 2 (auto) then playback content as\\n\\t\\tprogressive if src height <= ivtv_yuvthreshold\\n\"\n\t\t \"\\t\\t\\tDefault: 480\");\nMODULE_PARM_DESC(enc_mpg_buffers,\n\t\t \"Encoder MPG Buffers (in MB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_ENC_MPG_BUFFERS));\nMODULE_PARM_DESC(enc_yuv_buffers,\n\t\t \"Encoder YUV Buffers (in MB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_ENC_YUV_BUFFERS));\nMODULE_PARM_DESC(enc_vbi_buffers,\n\t\t \"Encoder VBI Buffers (in MB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_ENC_VBI_BUFFERS));\nMODULE_PARM_DESC(enc_pcm_buffers,\n\t\t \"Encoder PCM buffers (in kB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_ENC_PCM_BUFFERS));\nMODULE_PARM_DESC(dec_mpg_buffers,\n\t\t \"Decoder MPG buffers (in MB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_DEC_MPG_BUFFERS));\nMODULE_PARM_DESC(dec_yuv_buffers,\n\t\t \"Decoder YUV buffers (in MB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_DEC_YUV_BUFFERS));\nMODULE_PARM_DESC(dec_vbi_buffers,\n\t\t \"Decoder VBI buffers (in kB)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_DEC_VBI_BUFFERS));\nMODULE_PARM_DESC(newi2c,\n\t\t \"Use new I2C implementation\\n\"\n\t\t \"\\t\\t\\t-1 is autodetect, 0 is off, 1 is on\\n\"\n\t\t \"\\t\\t\\tDefault is autodetect\");\nMODULE_PARM_DESC(i2c_clock_period,\n\t\t \"Period of SCL for the I2C bus controlled by the CX23415/6\\n\"\n\t\t \"\\t\\t\\tMin: 10 usec (100 kHz), Max: 4500 usec (222 Hz)\\n\"\n\t\t \"\\t\\t\\tDefault: \" __stringify(IVTV_DEFAULT_I2C_CLOCK_PERIOD));\n\nMODULE_PARM_DESC(ivtv_first_minor, \"Set device node number assigned to first card\");\n\nMODULE_AUTHOR(\"Kevin Thayer, Chris Kennedy, Hans Verkuil\");\nMODULE_DESCRIPTION(\"CX23415/CX23416 driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_VERSION(IVTV_VERSION);\n\n#if defined(CONFIG_MODULES) && defined(MODULE)\nstatic void request_module_async(struct work_struct *work)\n{\n\tstruct ivtv *dev = container_of(work, struct ivtv, request_module_wk);\n\n\t \n\trequest_module(\"ivtv-alsa\");\n\n\t \n\tif (ivtv_ext_init != NULL)\n\t\tivtv_ext_init(dev);\n}\n\nstatic void request_modules(struct ivtv *dev)\n{\n\tINIT_WORK(&dev->request_module_wk, request_module_async);\n\tschedule_work(&dev->request_module_wk);\n}\n\nstatic void flush_request_modules(struct ivtv *dev)\n{\n\tflush_work(&dev->request_module_wk);\n}\n#else\n#define request_modules(dev)\n#define flush_request_modules(dev)\n#endif  \n\nvoid ivtv_clear_irq_mask(struct ivtv *itv, u32 mask)\n{\n\titv->irqmask &= ~mask;\n\twrite_reg_sync(itv->irqmask, IVTV_REG_IRQMASK);\n}\n\nvoid ivtv_set_irq_mask(struct ivtv *itv, u32 mask)\n{\n\titv->irqmask |= mask;\n\twrite_reg_sync(itv->irqmask, IVTV_REG_IRQMASK);\n}\n\nint ivtv_set_output_mode(struct ivtv *itv, int mode)\n{\n    int old_mode;\n\n    spin_lock(&itv->lock);\n    old_mode = itv->output_mode;\n    if (old_mode == 0)\n\titv->output_mode = old_mode = mode;\n    spin_unlock(&itv->lock);\n    return old_mode;\n}\n\nstruct ivtv_stream *ivtv_get_output_stream(struct ivtv *itv)\n{\n\tswitch (itv->output_mode) {\n\tcase OUT_MPG:\n\t\treturn &itv->streams[IVTV_DEC_STREAM_TYPE_MPG];\n\tcase OUT_YUV:\n\t\treturn &itv->streams[IVTV_DEC_STREAM_TYPE_YUV];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nint ivtv_waitq(wait_queue_head_t *waitq)\n{\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait(waitq, &wait, TASK_INTERRUPTIBLE);\n\tschedule();\n\tfinish_wait(waitq, &wait);\n\treturn signal_pending(current) ? -EINTR : 0;\n}\n\n \nint ivtv_msleep_timeout(unsigned int msecs, int intr)\n{\n\tint timeout = msecs_to_jiffies(msecs);\n\n\tdo {\n\t\tset_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (intr) {\n\t\t\tint ret = signal_pending(current);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} while (timeout);\n\treturn 0;\n}\n\n \nstatic void ivtv_iounmap(struct ivtv *itv)\n{\n\tif (itv == NULL)\n\t\treturn;\n\n\t \n\tif (itv->reg_mem != NULL) {\n\t\tIVTV_DEBUG_INFO(\"releasing reg_mem\\n\");\n\t\tiounmap(itv->reg_mem);\n\t\titv->reg_mem = NULL;\n\t}\n\t \n\tif (itv->has_cx23415 && itv->dec_mem != NULL) {\n\t\tIVTV_DEBUG_INFO(\"releasing dec_mem\\n\");\n\t\tiounmap(itv->dec_mem);\n\t}\n\titv->dec_mem = NULL;\n\n\t \n\tif (itv->enc_mem != NULL) {\n\t\tIVTV_DEBUG_INFO(\"releasing enc_mem\\n\");\n\t\tiounmap(itv->enc_mem);\n\t\titv->enc_mem = NULL;\n\t}\n}\n\n \nvoid ivtv_read_eeprom(struct ivtv *itv, struct tveeprom *tv)\n{\n\tu8 eedata[256];\n\n\titv->i2c_client.addr = 0xA0 >> 1;\n\ttveeprom_read(&itv->i2c_client, eedata, sizeof(eedata));\n\ttveeprom_hauppauge_analog(tv, eedata);\n}\n\nstatic void ivtv_process_eeprom(struct ivtv *itv)\n{\n\tstruct tveeprom tv;\n\tint pci_slot = PCI_SLOT(itv->pdev->devfn);\n\n\tivtv_read_eeprom(itv, &tv);\n\n\t \n\tswitch (tv.model) {\n\t\t \n\t\tcase 30012 ... 30039:   \n\t\tcase 32000 ... 32999:\n\t\tcase 48000 ... 48099:   \n\t\tcase 48400 ... 48599:\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_250);\n\t\t\tbreak;\n\t\tcase 48100 ... 48399:\n\t\tcase 48600 ... 48999:\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_350);\n\t\t\tbreak;\n\t\tcase 23000 ... 23999:   \n\t\tcase 25000 ... 25999:   \n\t\tcase 26000 ... 26999:   \n\t\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_150);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tIVTV_ERR(\"Invalid EEPROM\\n\");\n\t\t\treturn;\n\t\tdefault:\n\t\t\tIVTV_ERR(\"Unknown model %d, defaulting to PVR-150\\n\", tv.model);\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_150);\n\t\t\tbreak;\n\t}\n\n\tswitch (tv.model) {\n\t\t \n\t\tcase 48254:\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_350_V1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\titv->v4l2_cap = itv->card->v4l2_capabilities;\n\titv->card_name = itv->card->name;\n\titv->card_i2c = itv->card->i2c;\n\n\t \n\tif (tv.model / 1000 == 23) {\n\t\tstatic const struct ivtv_card_tuner_i2c ivtv_i2c_radio = {\n\t\t\t.radio = { 0x60, I2C_CLIENT_END },\n\t\t\t.demod = { 0x43, I2C_CLIENT_END },\n\t\t\t.tv = { 0x61, I2C_CLIENT_END },\n\t\t};\n\n\t\titv->card_name = \"WinTV PVR 500\";\n\t\titv->card_i2c = &ivtv_i2c_radio;\n\t\tif (pci_slot == 8 || pci_slot == 9) {\n\t\t\tint is_first = (pci_slot & 1) == 0;\n\n\t\t\titv->card_name = is_first ? \"WinTV PVR 500 (unit #1)\" :\n\t\t\t\t\t\t    \"WinTV PVR 500 (unit #2)\";\n\t\t\tif (!is_first) {\n\t\t\t\tIVTV_INFO(\"Correcting tveeprom data: no radio present on second unit\\n\");\n\t\t\t\ttv.has_radio = 0;\n\t\t\t}\n\t\t}\n\t}\n\tIVTV_INFO(\"Autodetected %s\\n\", itv->card_name);\n\n\tswitch (tv.tuner_hauppauge_model) {\n\t\tcase 85:\n\t\tcase 99:\n\t\tcase 112:\n\t\t\titv->pvr150_workaround = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tif (tv.tuner_type == TUNER_ABSENT)\n\t\tIVTV_ERR(\"tveeprom cannot autodetect tuner!\\n\");\n\n\tif (itv->options.tuner == -1)\n\t\titv->options.tuner = tv.tuner_type;\n\tif (itv->options.radio == -1)\n\t\titv->options.radio = (tv.has_radio != 0);\n\t \n\tif (itv->options.newi2c == -1 && tv.has_ir) {\n\t\titv->options.newi2c = (tv.has_ir & 4) ? 1 : 0;\n\t\tif (itv->options.newi2c) {\n\t\t    IVTV_INFO(\"Reopen i2c bus for IR-blaster support\\n\");\n\t\t    exit_ivtv_i2c(itv);\n\t\t    init_ivtv_i2c(itv);\n\t\t}\n\t}\n\n\tif (itv->std != 0)\n\t\t \n\t\treturn;\n\n\t \n\tif (tv.tuner_formats & V4L2_STD_PAL) {\n\t\tIVTV_DEBUG_INFO(\"PAL tuner detected\\n\");\n\t\titv->std |= V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\n\t} else if (tv.tuner_formats & V4L2_STD_NTSC) {\n\t\tIVTV_DEBUG_INFO(\"NTSC tuner detected\\n\");\n\t\titv->std |= V4L2_STD_NTSC_M;\n\t} else if (tv.tuner_formats & V4L2_STD_SECAM) {\n\t\tIVTV_DEBUG_INFO(\"SECAM tuner detected\\n\");\n\t\titv->std |= V4L2_STD_SECAM_L;\n\t} else {\n\t\tIVTV_INFO(\"No tuner detected, default to NTSC-M\\n\");\n\t\titv->std |= V4L2_STD_NTSC_M;\n\t}\n}\n\nstatic v4l2_std_id ivtv_parse_std(struct ivtv *itv)\n{\n\tswitch (pal[0]) {\n\t\tcase '6':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_PAL_60;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\ttunertype = 1;\n\t\t\tif (pal[1] == 'c' || pal[1] == 'C')\n\t\t\t\treturn V4L2_STD_PAL_Nc;\n\t\t\treturn V4L2_STD_PAL_N;\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_PAL_I;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_PAL_DK;\n\t\tcase 'M':\n\t\tcase 'm':\n\t\t\ttunertype = 1;\n\t\t\treturn V4L2_STD_PAL_M;\n\t\tcase '-':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIVTV_WARN(\"pal= argument not recognised\\n\");\n\t\t\treturn 0;\n\t}\n\n\tswitch (secam[0]) {\n\t\tcase 'b':\n\t\tcase 'B':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\ttunertype = 0;\n\t\t\treturn V4L2_STD_SECAM_DK;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\ttunertype = 0;\n\t\t\tif (secam[1] == 'C' || secam[1] == 'c')\n\t\t\t\treturn V4L2_STD_SECAM_LC;\n\t\t\treturn V4L2_STD_SECAM_L;\n\t\tcase '-':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIVTV_WARN(\"secam= argument not recognised\\n\");\n\t\t\treturn 0;\n\t}\n\n\tswitch (ntsc[0]) {\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\ttunertype = 1;\n\t\t\treturn V4L2_STD_NTSC_M;\n\t\tcase 'j':\n\t\tcase 'J':\n\t\t\ttunertype = 1;\n\t\t\treturn V4L2_STD_NTSC_M_JP;\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\ttunertype = 1;\n\t\t\treturn V4L2_STD_NTSC_M_KR;\n\t\tcase '-':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIVTV_WARN(\"ntsc= argument not recognised\\n\");\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void ivtv_process_options(struct ivtv *itv)\n{\n\tconst char *chipname;\n\tint i, j;\n\n\titv->options.kilobytes[IVTV_ENC_STREAM_TYPE_MPG] = enc_mpg_buffers * 1024;\n\titv->options.kilobytes[IVTV_ENC_STREAM_TYPE_YUV] = enc_yuv_buffers * 1024;\n\titv->options.kilobytes[IVTV_ENC_STREAM_TYPE_VBI] = enc_vbi_buffers * 1024;\n\titv->options.kilobytes[IVTV_ENC_STREAM_TYPE_PCM] = enc_pcm_buffers;\n\titv->options.kilobytes[IVTV_DEC_STREAM_TYPE_MPG] = dec_mpg_buffers * 1024;\n\titv->options.kilobytes[IVTV_DEC_STREAM_TYPE_YUV] = dec_yuv_buffers * 1024;\n\titv->options.kilobytes[IVTV_DEC_STREAM_TYPE_VBI] = dec_vbi_buffers;\n\titv->options.cardtype = cardtype[itv->instance];\n\titv->options.tuner = tuner[itv->instance];\n\titv->options.radio = radio[itv->instance];\n\n\titv->options.i2c_clock_period = i2c_clock_period[itv->instance];\n\tif (itv->options.i2c_clock_period == -1)\n\t\titv->options.i2c_clock_period = IVTV_DEFAULT_I2C_CLOCK_PERIOD;\n\telse if (itv->options.i2c_clock_period < 10)\n\t\titv->options.i2c_clock_period = 10;\n\telse if (itv->options.i2c_clock_period > 4500)\n\t\titv->options.i2c_clock_period = 4500;\n\n\titv->options.newi2c = newi2c;\n\tif (tunertype < -1 || tunertype > 1) {\n\t\tIVTV_WARN(\"Invalid tunertype argument, will autodetect instead\\n\");\n\t\ttunertype = -1;\n\t}\n\titv->std = ivtv_parse_std(itv);\n\tif (itv->std == 0 && tunertype >= 0)\n\t\titv->std = tunertype ? V4L2_STD_MN : (V4L2_STD_ALL & ~V4L2_STD_MN);\n\titv->has_cx23415 = (itv->pdev->device == PCI_DEVICE_ID_IVTV15);\n\tchipname = itv->has_cx23415 ? \"cx23415\" : \"cx23416\";\n\tif (itv->options.cardtype == -1) {\n\t\tIVTV_INFO(\"Ignore card (detected %s based chip)\\n\", chipname);\n\t\treturn;\n\t}\n\tif ((itv->card = ivtv_get_card(itv->options.cardtype - 1))) {\n\t\tIVTV_INFO(\"User specified %s card (detected %s based chip)\\n\",\n\t\t\t\titv->card->name, chipname);\n\t} else if (itv->options.cardtype != 0) {\n\t\tIVTV_ERR(\"Unknown user specified type, trying to autodetect card\\n\");\n\t}\n\tif (itv->card == NULL) {\n\t\tif (itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE ||\n\t\t    itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT1 ||\n\t\t    itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT2) {\n\t\t\titv->card = ivtv_get_card(itv->has_cx23415 ? IVTV_CARD_PVR_350 : IVTV_CARD_PVR_150);\n\t\t\tIVTV_INFO(\"Autodetected Hauppauge card (%s based)\\n\",\n\t\t\t\t\tchipname);\n\t\t}\n\t}\n\tif (itv->card == NULL) {\n\t\tfor (i = 0; (itv->card = ivtv_get_card(i)); i++) {\n\t\t\tif (itv->card->pci_list == NULL)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; itv->card->pci_list[j].device; j++) {\n\t\t\t\tif (itv->pdev->device !=\n\t\t\t\t    itv->card->pci_list[j].device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (itv->pdev->subsystem_vendor !=\n\t\t\t\t    itv->card->pci_list[j].subsystem_vendor)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (itv->pdev->subsystem_device !=\n\t\t\t\t    itv->card->pci_list[j].subsystem_device)\n\t\t\t\t\tcontinue;\n\t\t\t\tIVTV_INFO(\"Autodetected %s card (%s based)\\n\",\n\t\t\t\t\t\titv->card->name, chipname);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\n\tif (itv->card == NULL) {\n\t\titv->card = ivtv_get_card(IVTV_CARD_PVR_150);\n\t\tIVTV_ERR(\"Unknown card: vendor/device: [%04x:%04x]\\n\",\n\t\t     itv->pdev->vendor, itv->pdev->device);\n\t\tIVTV_ERR(\"              subsystem vendor/device: [%04x:%04x]\\n\",\n\t\t     itv->pdev->subsystem_vendor, itv->pdev->subsystem_device);\n\t\tIVTV_ERR(\"              %s based\\n\", chipname);\n\t\tIVTV_ERR(\"Defaulting to %s card\\n\", itv->card->name);\n\t\tIVTV_ERR(\"Please mail the vendor/device and subsystem vendor/device IDs and what kind of\\n\");\n\t\tIVTV_ERR(\"card you have to the linux-media mailinglist (www.linuxtv.org)\\n\");\n\t\tIVTV_ERR(\"Prefix your subject line with [UNKNOWN IVTV CARD].\\n\");\n\t}\n\titv->v4l2_cap = itv->card->v4l2_capabilities;\n\titv->card_name = itv->card->name;\n\titv->card_i2c = itv->card->i2c;\n}\n\n \nstatic int ivtv_init_struct1(struct ivtv *itv)\n{\n\titv->base_addr = pci_resource_start(itv->pdev, 0);\n\titv->enc_mbox.max_mbox = 2;  \n\titv->dec_mbox.max_mbox = 1;  \n\n\tmutex_init(&itv->serialize_lock);\n\tmutex_init(&itv->i2c_bus_lock);\n\tmutex_init(&itv->udma.lock);\n\n\tspin_lock_init(&itv->lock);\n\tspin_lock_init(&itv->dma_reg_lock);\n\n\tkthread_init_worker(&itv->irq_worker);\n\titv->irq_worker_task = kthread_run(kthread_worker_fn, &itv->irq_worker,\n\t\t\t\t\t   \"%s\", itv->v4l2_dev.name);\n\tif (IS_ERR(itv->irq_worker_task)) {\n\t\tIVTV_ERR(\"Could not create ivtv task\\n\");\n\t\treturn -1;\n\t}\n\t \n\tsched_set_fifo(itv->irq_worker_task);\n\n\tkthread_init_work(&itv->irq_work, ivtv_irq_work_handler);\n\n\t \n\titv->cxhdl.port = CX2341X_PORT_MEMORY;\n\titv->cxhdl.capabilities = CX2341X_CAP_HAS_SLICED_VBI;\n\tinit_waitqueue_head(&itv->eos_waitq);\n\tinit_waitqueue_head(&itv->event_waitq);\n\tinit_waitqueue_head(&itv->vsync_waitq);\n\tinit_waitqueue_head(&itv->dma_waitq);\n\ttimer_setup(&itv->dma_timer, ivtv_unfinished_dma, 0);\n\n\titv->cur_dma_stream = -1;\n\titv->cur_pio_stream = -1;\n\n\t \n\titv->speed = 1000;\n\n\t \n\titv->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\titv->vbi.sliced_in = &itv->vbi.in.fmt.sliced;\n\n\t \n\tsg_init_table(itv->udma.SGlist, IVTV_DMA_SG_OSD_ENT);\n\n\t \n\titv->osd_global_alpha_state = 1;\n\titv->osd_global_alpha = 255;\n\n\t \n\tatomic_set(&itv->yuv_info.next_dma_frame, -1);\n\titv->yuv_info.lace_mode = ivtv_yuv_mode;\n\titv->yuv_info.lace_threshold = ivtv_yuv_threshold;\n\titv->yuv_info.max_frames_buffered = 3;\n\titv->yuv_info.track_osd = 1;\n\treturn 0;\n}\n\n \nstatic void ivtv_init_struct2(struct ivtv *itv)\n{\n\tint i;\n\n\tfor (i = 0; i < IVTV_CARD_MAX_VIDEO_INPUTS; i++)\n\t\tif (itv->card->video_inputs[i].video_type == 0)\n\t\t\tbreak;\n\titv->nof_inputs = i;\n\tfor (i = 0; i < IVTV_CARD_MAX_AUDIO_INPUTS; i++)\n\t\tif (itv->card->audio_inputs[i].audio_type == 0)\n\t\t\tbreak;\n\titv->nof_audio_inputs = i;\n\n\tif (itv->card->hw_all & IVTV_HW_CX25840) {\n\t\titv->vbi.sliced_size = 288;   \n\t} else {\n\t\titv->vbi.sliced_size = 64;    \n\t}\n\n\t \n\tfor (i = 0; i < itv->nof_inputs; i++) {\n\t\tif (itv->card->video_inputs[i].video_type ==\n\t\t\t\tIVTV_CARD_INPUT_VID_TUNER)\n\t\t\tbreak;\n\t}\n\tif (i >= itv->nof_inputs)\n\t\ti = 0;\n\titv->active_input = i;\n\titv->audio_input = itv->card->video_inputs[i].audio_index;\n}\n\nstatic int ivtv_setup_pci(struct ivtv *itv, struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tu16 cmd;\n\tunsigned char pci_latency;\n\n\tIVTV_DEBUG_INFO(\"Enabling pci device\\n\");\n\n\tif (pci_enable_device(pdev)) {\n\t\tIVTV_ERR(\"Can't enable device!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tIVTV_ERR(\"No suitable DMA available.\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!request_mem_region(itv->base_addr, IVTV_ENCODER_SIZE, \"ivtv encoder\")) {\n\t\tIVTV_ERR(\"Cannot request encoder memory region.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!request_mem_region(itv->base_addr + IVTV_REG_OFFSET,\n\t\t\t\tIVTV_REG_SIZE, \"ivtv registers\")) {\n\t\tIVTV_ERR(\"Cannot request register memory region.\\n\");\n\t\trelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\n\t\treturn -EIO;\n\t}\n\n\tif (itv->has_cx23415 &&\n\t    !request_mem_region(itv->base_addr + IVTV_DECODER_OFFSET,\n\t\t\t\tIVTV_DECODER_SIZE, \"ivtv decoder\")) {\n\t\tIVTV_ERR(\"Cannot request decoder memory region.\\n\");\n\t\trelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\n\t\trelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\t\treturn -EIO;\n\t}\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (!(cmd & PCI_COMMAND_MASTER)) {\n\t\tIVTV_DEBUG_INFO(\"Attempting to enable Bus Mastering\\n\");\n\t\tpci_set_master(pdev);\n\t\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\t\tif (!(cmd & PCI_COMMAND_MASTER)) {\n\t\t\tIVTV_ERR(\"Bus Mastering is not enabled\\n\");\n\t\t\tif (itv->has_cx23415)\n\t\t\t\trelease_mem_region(itv->base_addr + IVTV_DECODER_OFFSET,\n\t\t\t\t\t\t   IVTV_DECODER_SIZE);\n\t\t\trelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\n\t\t\trelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\tIVTV_DEBUG_INFO(\"Bus Mastering Enabled.\\n\");\n\n\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\n\n\tif (pci_latency < 64 && ivtv_pci_latency) {\n\t\tIVTV_INFO(\"Unreasonably low latency timer, setting to 64 (was %d)\\n\",\n\t\t\t  pci_latency);\n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 64);\n\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\n\t}\n\t \n\tpci_write_config_dword(pdev, 0x40, 0xffff);\n\n\tIVTV_DEBUG_INFO(\"%d (rev %d) at %02x:%02x.%x, irq: %d, latency: %d, memory: 0x%llx\\n\",\n\t\t   pdev->device, pdev->revision, pdev->bus->number,\n\t\t   PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\n\t\t   pdev->irq, pci_latency, (u64)itv->base_addr);\n\n\treturn 0;\n}\n\nstatic void ivtv_load_and_init_modules(struct ivtv *itv)\n{\n\tu32 hw = itv->card->hw_all;\n\tunsigned i;\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tu32 device = BIT(i);\n\n\t\tif (!(device & hw))\n\t\t\tcontinue;\n\t\tif (device == IVTV_HW_GPIO || device == IVTV_HW_TVEEPROM) {\n\t\t\t \n\t\t\titv->hw_flags |= device;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ivtv_i2c_register(itv, i) == 0)\n\t\t\titv->hw_flags |= device;\n\t}\n\n\t \n\tif ((itv->hw_flags & IVTV_HW_IR_ANY) == 0)\n\t\tivtv_i2c_new_ir_legacy(itv);\n\n\tif (itv->card->hw_all & IVTV_HW_CX25840)\n\t\titv->sd_video = ivtv_find_hw(itv, IVTV_HW_CX25840);\n\telse if (itv->card->hw_all & IVTV_HW_SAA717X)\n\t\titv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA717X);\n\telse if (itv->card->hw_all & IVTV_HW_SAA7114)\n\t\titv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA7114);\n\telse\n\t\titv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA7115);\n\titv->sd_audio = ivtv_find_hw(itv, itv->card->hw_audio_ctrl);\n\titv->sd_muxer = ivtv_find_hw(itv, itv->card->hw_muxer);\n\n\thw = itv->hw_flags;\n\n\tif (itv->card->type == IVTV_CARD_CX23416GYC) {\n\t\t \n\t\tif ((hw & (IVTV_HW_UPD64031A | IVTV_HW_UPD6408X)) == 0)\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_CX23416GYC_NOGRYCS);\n\t\telse if ((hw & IVTV_HW_UPD64031A) == 0)\n\t\t\titv->card = ivtv_get_card(IVTV_CARD_CX23416GYC_NOGR);\n\t}\n\telse if (itv->card->type == IVTV_CARD_GV_MVPRX ||\n\t\t itv->card->type == IVTV_CARD_GV_MVPRX2E) {\n\t\t \n\t\tv4l2_subdev_call(itv->sd_video, video, s_crystal_freq,\n\t\t\tSAA7115_FREQ_24_576_MHZ, SAA7115_FREQ_FL_UCGC);\n\t}\n\n\tif (hw & IVTV_HW_CX25840) {\n\t\titv->vbi.raw_decoder_line_size = 1444;\n\t\titv->vbi.raw_decoder_sav_odd_field = 0x20;\n\t\titv->vbi.raw_decoder_sav_even_field = 0x60;\n\t\titv->vbi.sliced_decoder_line_size = 272;\n\t\titv->vbi.sliced_decoder_sav_odd_field = 0xB0;\n\t\titv->vbi.sliced_decoder_sav_even_field = 0xF0;\n\t}\n\n\tif (hw & IVTV_HW_SAA711X) {\n\t\t \n\t\titv->hw_flags &= ~IVTV_HW_SAA711X;\n\n\t\tif (strstr(itv->sd_video->name, \"saa7114\")) {\n\t\t\titv->hw_flags |= IVTV_HW_SAA7114;\n\t\t\t \n\t\t\titv->v4l2_cap &= ~(V4L2_CAP_SLICED_VBI_CAPTURE|V4L2_CAP_VBI_CAPTURE);\n\t\t} else {\n\t\t\titv->hw_flags |= IVTV_HW_SAA7115;\n\t\t}\n\t\titv->vbi.raw_decoder_line_size = 1443;\n\t\titv->vbi.raw_decoder_sav_odd_field = 0x25;\n\t\titv->vbi.raw_decoder_sav_even_field = 0x62;\n\t\titv->vbi.sliced_decoder_line_size = 51;\n\t\titv->vbi.sliced_decoder_sav_odd_field = 0xAB;\n\t\titv->vbi.sliced_decoder_sav_even_field = 0xEC;\n\t}\n\n\tif (hw & IVTV_HW_SAA717X) {\n\t\titv->vbi.raw_decoder_line_size = 1443;\n\t\titv->vbi.raw_decoder_sav_odd_field = 0x25;\n\t\titv->vbi.raw_decoder_sav_even_field = 0x62;\n\t\titv->vbi.sliced_decoder_line_size = 51;\n\t\titv->vbi.sliced_decoder_sav_odd_field = 0xAB;\n\t\titv->vbi.sliced_decoder_sav_even_field = 0xEC;\n\t}\n}\n\nstatic int ivtv_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)\n{\n\tint retval = 0;\n\tint vbi_buf_size;\n\tstruct ivtv *itv;\n\n\titv = kzalloc(sizeof(struct ivtv), GFP_KERNEL);\n\tif (itv == NULL)\n\t\treturn -ENOMEM;\n\titv->pdev = pdev;\n\titv->instance = v4l2_device_set_name(&itv->v4l2_dev, \"ivtv\",\n\t\t\t\t\t\t&ivtv_instance);\n\n\tretval = v4l2_device_register(&pdev->dev, &itv->v4l2_dev);\n\tif (retval) {\n\t\tkfree(itv);\n\t\treturn retval;\n\t}\n\tIVTV_INFO(\"Initializing card %d\\n\", itv->instance);\n\n\tivtv_process_options(itv);\n\tif (itv->options.cardtype == -1) {\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\tif (ivtv_init_struct1(itv)) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\tretval = cx2341x_handler_init(&itv->cxhdl, 50);\n\tif (retval)\n\t\tgoto err;\n\titv->v4l2_dev.ctrl_handler = &itv->cxhdl.hdl;\n\titv->cxhdl.ops = &ivtv_cxhdl_ops;\n\titv->cxhdl.priv = itv;\n\titv->cxhdl.func = ivtv_api_func;\n\n\tIVTV_DEBUG_INFO(\"base addr: 0x%llx\\n\", (u64)itv->base_addr);\n\n\t \n\tretval = ivtv_setup_pci(itv, pdev, pci_id);\n\tif (retval == -EIO)\n\t\tgoto free_worker;\n\tif (retval == -ENXIO)\n\t\tgoto free_mem;\n\n\t \n\tIVTV_DEBUG_INFO(\"attempting ioremap at 0x%llx len 0x%08x\\n\",\n\t\t   (u64)itv->base_addr + IVTV_ENCODER_OFFSET, IVTV_ENCODER_SIZE);\n\titv->enc_mem = ioremap(itv->base_addr + IVTV_ENCODER_OFFSET,\n\t\t\t\t       IVTV_ENCODER_SIZE);\n\tif (!itv->enc_mem) {\n\t\tIVTV_ERR(\"ioremap failed. Can't get a window into CX23415/6 encoder memory\\n\");\n\t\tIVTV_ERR(\"Each capture card with a CX23415/6 needs 8 MB of vmalloc address space for this window\\n\");\n\t\tIVTV_ERR(\"Check the output of 'grep Vmalloc /proc/meminfo'\\n\");\n\t\tIVTV_ERR(\"Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\tif (itv->has_cx23415) {\n\t\tIVTV_DEBUG_INFO(\"attempting ioremap at 0x%llx len 0x%08x\\n\",\n\t\t\t\t(u64)itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\n\t\titv->dec_mem = ioremap(itv->base_addr + IVTV_DECODER_OFFSET,\n\t\t\t\tIVTV_DECODER_SIZE);\n\t\tif (!itv->dec_mem) {\n\t\t\tIVTV_ERR(\"ioremap failed. Can't get a window into CX23415 decoder memory\\n\");\n\t\t\tIVTV_ERR(\"Each capture card with a CX23415 needs 8 MB of vmalloc address space for this window\\n\");\n\t\t\tIVTV_ERR(\"Check the output of 'grep Vmalloc /proc/meminfo'\\n\");\n\t\t\tIVTV_ERR(\"Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto free_mem;\n\t\t}\n\t}\n\telse {\n\t\titv->dec_mem = itv->enc_mem;\n\t}\n\n\t \n\tIVTV_DEBUG_INFO(\"attempting ioremap at 0x%llx len 0x%08x\\n\",\n\t\t   (u64)itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\titv->reg_mem =\n\t    ioremap(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\tif (!itv->reg_mem) {\n\t\tIVTV_ERR(\"ioremap failed. Can't get a window into CX23415/6 register space\\n\");\n\t\tIVTV_ERR(\"Each capture card with a CX23415/6 needs 64 kB of vmalloc address space for this window\\n\");\n\t\tIVTV_ERR(\"Check the output of 'grep Vmalloc /proc/meminfo'\\n\");\n\t\tIVTV_ERR(\"Use the vmalloc= kernel command line option to set VmallocTotal to a larger value\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto free_io;\n\t}\n\n\tretval = ivtv_gpio_init(itv);\n\tif (retval)\n\t\tgoto free_io;\n\n\t \n\tIVTV_DEBUG_INFO(\"activating i2c...\\n\");\n\tif (init_ivtv_i2c(itv)) {\n\t\tIVTV_ERR(\"Could not initialize i2c\\n\");\n\t\tgoto free_io;\n\t}\n\n\tif (itv->card->hw_all & IVTV_HW_TVEEPROM) {\n\t\t \n\t\tivtv_process_eeprom(itv);\n\t}\n\tif (itv->card->comment)\n\t\tIVTV_INFO(\"%s\", itv->card->comment);\n\tif (itv->card->v4l2_capabilities == 0) {\n\t\t \n\t\tretval = -ENODEV;\n\t\tgoto free_i2c;\n\t}\n\n\tif (itv->std == 0) {\n\t\titv->std = V4L2_STD_NTSC_M;\n\t}\n\n\tif (itv->options.tuner == -1) {\n\t\tint i;\n\n\t\tfor (i = 0; i < IVTV_CARD_MAX_TUNERS; i++) {\n\t\t\tif ((itv->std & itv->card->tuners[i].std) == 0)\n\t\t\t\tcontinue;\n\t\t\titv->options.tuner = itv->card->tuners[i].tuner;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (itv->options.tuner == -1 && itv->card->tuners[0].std) {\n\t\titv->std = itv->card->tuners[0].std;\n\t\tif (itv->std & V4L2_STD_PAL)\n\t\t\titv->std = V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\n\t\telse if (itv->std & V4L2_STD_NTSC)\n\t\t\titv->std = V4L2_STD_NTSC_M;\n\t\telse if (itv->std & V4L2_STD_SECAM)\n\t\t\titv->std = V4L2_STD_SECAM_L;\n\t\titv->options.tuner = itv->card->tuners[0].tuner;\n\t}\n\tif (itv->options.radio == -1)\n\t\titv->options.radio = (itv->card->radio_input.audio_type != 0);\n\n\t \n\tivtv_init_struct2(itv);\n\n\tivtv_load_and_init_modules(itv);\n\n\tif (itv->std & V4L2_STD_525_60) {\n\t\titv->is_60hz = 1;\n\t\titv->is_out_60hz = 1;\n\t} else {\n\t\titv->is_50hz = 1;\n\t\titv->is_out_50hz = 1;\n\t}\n\n\titv->yuv_info.osd_full_w = 720;\n\titv->yuv_info.osd_full_h = itv->is_out_50hz ? 576 : 480;\n\titv->yuv_info.v4l2_src_w = itv->yuv_info.osd_full_w;\n\titv->yuv_info.v4l2_src_h = itv->yuv_info.osd_full_h;\n\n\tcx2341x_handler_set_50hz(&itv->cxhdl, itv->is_50hz);\n\n\titv->stream_buf_size[IVTV_ENC_STREAM_TYPE_MPG] = 0x08000;\n\titv->stream_buf_size[IVTV_ENC_STREAM_TYPE_PCM] = 0x01200;\n\titv->stream_buf_size[IVTV_DEC_STREAM_TYPE_MPG] = 0x10000;\n\titv->stream_buf_size[IVTV_DEC_STREAM_TYPE_YUV] = 0x10000;\n\titv->stream_buf_size[IVTV_ENC_STREAM_TYPE_YUV] = 0x08000;\n\n\t \n\t \n\titv->vbi.raw_size = 1456;\n\t \n\tvbi_buf_size = itv->vbi.raw_size * (itv->is_60hz ? 24 : 36) / 2;\n\titv->stream_buf_size[IVTV_ENC_STREAM_TYPE_VBI] = vbi_buf_size;\n\titv->stream_buf_size[IVTV_DEC_STREAM_TYPE_VBI] = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\n\tif (itv->options.radio > 0)\n\t\titv->v4l2_cap |= V4L2_CAP_RADIO;\n\n\tif (itv->options.tuner > -1) {\n\t\tstruct tuner_setup setup;\n\n\t\tsetup.addr = ADDR_UNSET;\n\t\tsetup.type = itv->options.tuner;\n\t\tsetup.mode_mask = T_ANALOG_TV;   \n\t\tif (itv->options.radio > 0)\n\t\t\tsetup.mode_mask |= T_RADIO;\n\t\tsetup.tuner_callback = (setup.type == TUNER_XC2028) ?\n\t\t\tivtv_reset_tuner_gpio : NULL;\n\t\tivtv_call_all(itv, tuner, s_type_addr, &setup);\n\t\tif (setup.type == TUNER_XC2028) {\n\t\t\tstatic struct xc2028_ctrl ctrl = {\n\t\t\t\t.fname = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t};\n\t\t\tstruct v4l2_priv_tun_config cfg = {\n\t\t\t\t.tuner = itv->options.tuner,\n\t\t\t\t.priv = &ctrl,\n\t\t\t};\n\t\t\tivtv_call_all(itv, tuner, s_config, &cfg);\n\t\t}\n\t}\n\n\t \n\titv->tuner_std = itv->std;\n\n\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\n\t\tstruct v4l2_ctrl_handler *hdl = itv->v4l2_dev.ctrl_handler;\n\n\t\titv->ctrl_pts = v4l2_ctrl_new_std(hdl, &ivtv_hdl_out_ops,\n\t\t\t\tV4L2_CID_MPEG_VIDEO_DEC_PTS, 0, 0, 0, 0);\n\t\titv->ctrl_frame = v4l2_ctrl_new_std(hdl, &ivtv_hdl_out_ops,\n\t\t\t\tV4L2_CID_MPEG_VIDEO_DEC_FRAME, 0, 0, 0, 0);\n\t\t \n\t\titv->ctrl_audio_playback =\n\t\t\tv4l2_ctrl_new_std_menu(hdl, &ivtv_hdl_out_ops,\n\t\t\t\tV4L2_CID_MPEG_AUDIO_DEC_PLAYBACK,\n\t\t\t\tV4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO,\n\t\t\t\t1 << V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO,\n\t\t\t\tV4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO);\n\t\titv->ctrl_audio_multilingual_playback =\n\t\t\tv4l2_ctrl_new_std_menu(hdl, &ivtv_hdl_out_ops,\n\t\t\t\tV4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK,\n\t\t\t\tV4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO,\n\t\t\t\t1 << V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO,\n\t\t\t\tV4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT);\n\t\tif (hdl->error) {\n\t\t\tretval = hdl->error;\n\t\t\tgoto free_i2c;\n\t\t}\n\t\tv4l2_ctrl_cluster(2, &itv->ctrl_pts);\n\t\tv4l2_ctrl_cluster(2, &itv->ctrl_audio_playback);\n\t\tivtv_call_all(itv, video, s_std_output, itv->std);\n\t\t \n\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\n\t}\n\n\t \n\tivtv_set_irq_mask(itv, 0xffffffff);\n\n\t \n\tretval = request_irq(itv->pdev->irq, ivtv_irq_handler,\n\t     IRQF_SHARED, itv->v4l2_dev.name, (void *)itv);\n\tif (retval) {\n\t\tIVTV_ERR(\"Failed to register irq %d\\n\", retval);\n\t\tgoto free_i2c;\n\t}\n\n\tretval = ivtv_streams_setup(itv);\n\tif (retval) {\n\t\tIVTV_ERR(\"Error %d setting up streams\\n\", retval);\n\t\tgoto free_irq;\n\t}\n\tretval = ivtv_streams_register(itv);\n\tif (retval) {\n\t\tIVTV_ERR(\"Error %d registering devices\\n\", retval);\n\t\tgoto free_streams;\n\t}\n\tIVTV_INFO(\"Initialized card: %s\\n\", itv->card_name);\n\n\t \n\trequest_modules(itv);\n\treturn 0;\n\nfree_streams:\n\tivtv_streams_cleanup(itv);\nfree_irq:\n\tfree_irq(itv->pdev->irq, (void *)itv);\nfree_i2c:\n\tv4l2_ctrl_handler_free(&itv->cxhdl.hdl);\n\texit_ivtv_i2c(itv);\nfree_io:\n\tivtv_iounmap(itv);\nfree_mem:\n\trelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\n\trelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\tif (itv->has_cx23415)\n\t\trelease_mem_region(itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\nfree_worker:\n\tkthread_stop(itv->irq_worker_task);\nerr:\n\tif (retval == 0)\n\t\tretval = -ENODEV;\n\tIVTV_ERR(\"Error %d on initialization\\n\", retval);\n\n\tv4l2_device_unregister(&itv->v4l2_dev);\n\tkfree(itv);\n\treturn retval;\n}\n\nint ivtv_init_on_first_open(struct ivtv *itv)\n{\n\tstruct v4l2_frequency vf;\n\t \n\tstruct ivtv_open_id fh;\n\tint fw_retry_count = 3;\n\tint video_input;\n\n\tfh.itv = itv;\n\tfh.type = IVTV_ENC_STREAM_TYPE_MPG;\n\n\tif (test_bit(IVTV_F_I_FAILED, &itv->i_flags))\n\t\treturn -ENXIO;\n\n\tif (test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags))\n\t\treturn 0;\n\n\twhile (--fw_retry_count > 0) {\n\t\t \n\t\tif (ivtv_firmware_init(itv) == 0)\n\t\t\tbreak;\n\t\tif (fw_retry_count > 1)\n\t\t\tIVTV_WARN(\"Retry loading firmware\\n\");\n\t}\n\n\tif (fw_retry_count == 0) {\n\t\tset_bit(IVTV_F_I_FAILED, &itv->i_flags);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tIVTV_DEBUG_INFO(\"Getting firmware version..\\n\");\n\tivtv_firmware_versions(itv);\n\n\tif (itv->card->hw_all & IVTV_HW_CX25840)\n\t\tv4l2_subdev_call(itv->sd_video, core, load_fw);\n\n\tvf.tuner = 0;\n\tvf.type = V4L2_TUNER_ANALOG_TV;\n\tvf.frequency = 6400;  \n\n\t \n\tif (itv->std == V4L2_STD_NTSC_M_JP) {\n\t\tvf.frequency = 1460;\t \n\t}\n\telse if (itv->std & V4L2_STD_NTSC_M) {\n\t\tvf.frequency = 1076;\t \n\t}\n\n\tvideo_input = itv->active_input;\n\titv->active_input++;\t \n\tivtv_s_input(NULL, &fh, video_input);\n\n\t \n\titv->std++;\t\t \n\titv->std_out = itv->std;\n\tivtv_s_frequency(NULL, &fh, &vf);\n\n\tif (itv->card->v4l2_capabilities & V4L2_CAP_VIDEO_OUTPUT) {\n\t\t \n\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\n\t\tivtv_init_mpeg_decoder(itv);\n\t}\n\n\t \n\tif (!itv->has_cx23415)\n\t\twrite_reg_sync(0x03, IVTV_REG_DMACONTROL);\n\n\tivtv_s_std_enc(itv, itv->tuner_std);\n\n\t \n\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_INIT | IVTV_IRQ_DEC_VSYNC);\n\t\tivtv_set_osd_alpha(itv);\n\t\tivtv_s_std_dec(itv, itv->tuner_std);\n\t} else {\n\t\tivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_INIT);\n\t}\n\n\t \n\tcx2341x_handler_setup(&itv->cxhdl);\n\treturn 0;\n}\n\nstatic void ivtv_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct ivtv *itv = to_ivtv(v4l2_dev);\n\tint i;\n\n\tIVTV_DEBUG_INFO(\"Removing card\\n\");\n\n\tflush_request_modules(itv);\n\n\tif (test_bit(IVTV_F_I_INITED, &itv->i_flags)) {\n\t\t \n\t\tIVTV_DEBUG_INFO(\"Stopping all streams\\n\");\n\t\tif (atomic_read(&itv->capturing) > 0)\n\t\t\tivtv_stop_all_captures(itv);\n\n\t\t \n\t\tIVTV_DEBUG_INFO(\"Stopping decoding\\n\");\n\n\t\t \n\t\tif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)\n\t\t\tivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\n\t\tif (atomic_read(&itv->decoding) > 0) {\n\t\t\tint type;\n\n\t\t\tif (test_bit(IVTV_F_I_DEC_YUV, &itv->i_flags))\n\t\t\t\ttype = IVTV_DEC_STREAM_TYPE_YUV;\n\t\t\telse\n\t\t\t\ttype = IVTV_DEC_STREAM_TYPE_MPG;\n\t\t\tivtv_stop_v4l2_decode_stream(&itv->streams[type],\n\t\t\t\tV4L2_DEC_CMD_STOP_TO_BLACK | V4L2_DEC_CMD_STOP_IMMEDIATELY, 0);\n\t\t}\n\t\tivtv_halt_firmware(itv);\n\t}\n\n\t \n\tivtv_set_irq_mask(itv, 0xffffffff);\n\ttimer_shutdown_sync(&itv->dma_timer);\n\n\t \n\tkthread_flush_worker(&itv->irq_worker);\n\tkthread_stop(itv->irq_worker_task);\n\n\tivtv_streams_cleanup(itv);\n\tivtv_udma_free(itv);\n\n\tv4l2_ctrl_handler_free(&itv->cxhdl.hdl);\n\n\texit_ivtv_i2c(itv);\n\n\tfree_irq(itv->pdev->irq, (void *)itv);\n\tivtv_iounmap(itv);\n\n\trelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\n\trelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\n\tif (itv->has_cx23415)\n\t\trelease_mem_region(itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\n\n\tpci_disable_device(itv->pdev);\n\tfor (i = 0; i < IVTV_VBI_FRAMES; i++)\n\t\tkfree(itv->vbi.sliced_mpeg_data[i]);\n\n\tpr_info(\"Removed %s\\n\", itv->card_name);\n\n\tv4l2_device_unregister(&itv->v4l2_dev);\n\tkfree(itv);\n}\n\n \nstatic struct pci_driver ivtv_pci_driver = {\n      .name =     \"ivtv\",\n      .id_table = ivtv_pci_tbl,\n      .probe =    ivtv_probe,\n      .remove =   ivtv_remove,\n};\n\nstatic int __init module_start(void)\n{\n\tpr_info(\"Start initialization, version %s\\n\", IVTV_VERSION);\n\n\t \n\tif (ivtv_first_minor < 0 || ivtv_first_minor >= IVTV_MAX_CARDS) {\n\t\tpr_err(\"Exiting, ivtv_first_minor must be between 0 and %d\\n\",\n\t\t     IVTV_MAX_CARDS - 1);\n\t\treturn -1;\n\t}\n\n\tif (ivtv_debug < 0 || ivtv_debug > 2047) {\n\t\tivtv_debug = 0;\n\t\tpr_info(\"Debug value must be >= 0 and <= 2047\\n\");\n\t}\n\n\tif (pci_register_driver(&ivtv_pci_driver)) {\n\t\tpr_err(\"Error detecting PCI card\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpr_info(\"End initialization\\n\");\n\treturn 0;\n}\n\nstatic void __exit module_cleanup(void)\n{\n\tpci_unregister_driver(&ivtv_pci_driver);\n}\n\n \nEXPORT_SYMBOL(ivtv_set_irq_mask);\nEXPORT_SYMBOL(ivtv_api);\nEXPORT_SYMBOL(ivtv_vapi);\nEXPORT_SYMBOL(ivtv_vapi_result);\nEXPORT_SYMBOL(ivtv_clear_irq_mask);\nEXPORT_SYMBOL(ivtv_debug);\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nEXPORT_SYMBOL(ivtv_fw_debug);\n#endif\nEXPORT_SYMBOL(ivtv_reset_ir_gpio);\nEXPORT_SYMBOL(ivtv_udma_setup);\nEXPORT_SYMBOL(ivtv_udma_unmap);\nEXPORT_SYMBOL(ivtv_udma_alloc);\nEXPORT_SYMBOL(ivtv_udma_prepare);\nEXPORT_SYMBOL(ivtv_init_on_first_open);\nEXPORT_SYMBOL(ivtv_firmware_check);\n\nmodule_init(module_start);\nmodule_exit(module_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}