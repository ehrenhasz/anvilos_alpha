{
  "module_name": "cobalt-omnitek.c",
  "hash_id": "24394e86f6c85628c4cc5f95c84068d3fb5fa3345cf15cf45edeb4b34b59e323",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-omnitek.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/io.h>\n#include <linux/pci_regs.h>\n#include <linux/spinlock.h>\n\n#include \"cobalt-driver.h\"\n#include \"cobalt-omnitek.h\"\n\n \n#define END_OF_CHAIN\t\t(1 << 1)\n#define INTERRUPT_ENABLE\t(1 << 2)\n#define WRITE_TO_PCI\t\t(1 << 3)\n#define READ_FROM_PCI\t\t(0 << 3)\n#define DESCRIPTOR_FLAG_MSK\t(END_OF_CHAIN | INTERRUPT_ENABLE | WRITE_TO_PCI)\n#define NEXT_ADRS_MSK\t\t0xffffffe0\n\n \n#define ENABLE                  (1 << 0)\n#define START                   (1 << 1)\n#define ABORT                   (1 << 2)\n#define DONE                    (1 << 4)\n#define SG_INTERRUPT            (1 << 5)\n#define EVENT_INTERRUPT         (1 << 6)\n#define SCATTER_GATHER_MODE     (1 << 8)\n#define DISABLE_VIDEO_RESYNC    (1 << 9)\n#define EVENT_INTERRUPT_ENABLE  (1 << 10)\n#define DIRECTIONAL_MSK         (3 << 16)\n#define INPUT_ONLY              (0 << 16)\n#define OUTPUT_ONLY             (1 << 16)\n#define BIDIRECTIONAL           (2 << 16)\n#define DMA_TYPE_MEMORY         (0 << 18)\n#define DMA_TYPE_FIFO\t\t(1 << 18)\n\n#define BASE\t\t\t(cobalt->bar0)\n#define CAPABILITY_HEADER\t(BASE)\n#define CAPABILITY_REGISTER\t(BASE + 0x04)\n#define PCI_64BIT\t\t(1 << 8)\n#define LOCAL_64BIT\t\t(1 << 9)\n#define INTERRUPT_STATUS\t(BASE + 0x08)\n#define PCI(c)\t\t\t(BASE + 0x40 + ((c) * 0x40))\n#define SIZE(c)\t\t\t(BASE + 0x58 + ((c) * 0x40))\n#define DESCRIPTOR(c)\t\t(BASE + 0x50 + ((c) * 0x40))\n#define CS_REG(c)\t\t(BASE + 0x60 + ((c) * 0x40))\n#define BYTES_TRANSFERRED(c)\t(BASE + 0x64 + ((c) * 0x40))\n\n\nstatic char *get_dma_direction(u32 status)\n{\n\tswitch (status & DIRECTIONAL_MSK) {\n\tcase INPUT_ONLY: return \"Input\";\n\tcase OUTPUT_ONLY: return \"Output\";\n\tcase BIDIRECTIONAL: return \"Bidirectional\";\n\t}\n\treturn \"\";\n}\n\nstatic void show_dma_capability(struct cobalt *cobalt)\n{\n\tu32 header = ioread32(CAPABILITY_HEADER);\n\tu32 capa = ioread32(CAPABILITY_REGISTER);\n\tu32 i;\n\n\tcobalt_info(\"Omnitek DMA capability: ID 0x%02x Version 0x%02x Next 0x%x Size 0x%x\\n\",\n\t\t    header & 0xff, (header >> 8) & 0xff,\n\t\t    (header >> 16) & 0xffff, (capa >> 24) & 0xff);\n\n\tswitch ((capa >> 8) & 0x3) {\n\tcase 0:\n\t\tcobalt_info(\"Omnitek DMA: 32 bits PCIe and Local\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tcobalt_info(\"Omnitek DMA: 64 bits PCIe, 32 bits Local\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tcobalt_info(\"Omnitek DMA: 64 bits PCIe and Local\\n\");\n\t\tbreak;\n\t}\n\n\tfor (i = 0;  i < (capa & 0xf);  i++) {\n\t\tu32 status = ioread32(CS_REG(i));\n\n\t\tcobalt_info(\"Omnitek DMA channel #%d: %s %s\\n\", i,\n\t\t\t    status & DMA_TYPE_FIFO ? \"FIFO\" : \"MEMORY\",\n\t\t\t    get_dma_direction(status));\n\t}\n}\n\nvoid omni_sg_dma_start(struct cobalt_stream *s, struct sg_dma_desc_info *desc)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\n\tiowrite32((u32)((u64)desc->bus >> 32), DESCRIPTOR(s->dma_channel) + 4);\n\tiowrite32((u32)desc->bus & NEXT_ADRS_MSK, DESCRIPTOR(s->dma_channel));\n\tiowrite32(ENABLE | SCATTER_GATHER_MODE | START, CS_REG(s->dma_channel));\n}\n\nbool is_dma_done(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\n\tif (ioread32(CS_REG(s->dma_channel)) & DONE)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid omni_sg_dma_abort_channel(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\n\tif (!is_dma_done(s))\n\t\tiowrite32(ABORT, CS_REG(s->dma_channel));\n}\n\nint omni_sg_dma_init(struct cobalt *cobalt)\n{\n\tu32 capa = ioread32(CAPABILITY_REGISTER);\n\tint i;\n\n\tcobalt->first_fifo_channel = 0;\n\tcobalt->dma_channels = capa & 0xf;\n\tif (capa & PCI_64BIT)\n\t\tcobalt->pci_32_bit = false;\n\telse\n\t\tcobalt->pci_32_bit = true;\n\n\tfor (i = 0; i < cobalt->dma_channels; i++) {\n\t\tu32 status = ioread32(CS_REG(i));\n\t\tu32 ctrl = ioread32(CS_REG(i));\n\n\t\tif (!(ctrl & DONE))\n\t\t\tiowrite32(ABORT, CS_REG(i));\n\n\t\tif (!(status & DMA_TYPE_FIFO))\n\t\t\tcobalt->first_fifo_channel++;\n\t}\n\tshow_dma_capability(cobalt);\n\treturn 0;\n}\n\nint descriptor_list_create(struct cobalt *cobalt,\n\t\tstruct scatterlist *scatter_list, bool to_pci, unsigned sglen,\n\t\tunsigned size, unsigned width, unsigned stride,\n\t\tstruct sg_dma_desc_info *desc)\n{\n\tstruct sg_dma_descriptor *d = (struct sg_dma_descriptor *)desc->virt;\n\tdma_addr_t next = desc->bus;\n\tunsigned offset = 0;\n\tunsigned copy_bytes = width;\n\tunsigned copied = 0;\n\tbool first = true;\n\n\t \n\tWARN_ON(sg_dma_address(scatter_list) & 3);\n\tWARN_ON(size & 3);\n\tWARN_ON(next & 3);\n\tWARN_ON(stride & 3);\n\tWARN_ON(stride < width);\n\tif (width >= stride)\n\t\tcopy_bytes = stride = size;\n\n\twhile (size) {\n\t\tdma_addr_t addr = sg_dma_address(scatter_list) + offset;\n\t\tunsigned bytes;\n\n\t\tif (addr == 0)\n\t\t\treturn -EFAULT;\n\t\tif (cobalt->pci_32_bit) {\n\t\t\tWARN_ON((u64)addr >> 32);\n\t\t\tif ((u64)addr >> 32)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\td->pci_l = addr & 0xffffffff;\n\t\t \n\t\td->pci_h = (u64)addr >> 32;\n\n\t\t \n\t\td->local = 0;\n\t\td->reserved0 = 0;\n\n\t\t \n\t\tbytes = min(sg_dma_len(scatter_list) - offset,\n\t\t\t\tcopy_bytes - copied);\n\n\t\tif (first) {\n\t\t\tif (to_pci)\n\t\t\t\td->local = 0x11111111;\n\t\t\tfirst = false;\n\t\t\tif (sglen == 1) {\n\t\t\t\t \n\t\t\t\td->bytes = (bytes / 2) & ~3;\n\t\t\t\td->reserved1 = 0;\n\t\t\t\tsize -= d->bytes;\n\t\t\t\tcopied += d->bytes;\n\t\t\t\toffset += d->bytes;\n\t\t\t\taddr += d->bytes;\n\t\t\t\tnext += sizeof(struct sg_dma_descriptor);\n\t\t\t\td->next_h = (u32)((u64)next >> 32);\n\t\t\t\td->next_l = (u32)next |\n\t\t\t\t\t(to_pci ? WRITE_TO_PCI : 0);\n\t\t\t\tbytes -= d->bytes;\n\t\t\t\td++;\n\t\t\t\t \n\t\t\t\td->pci_l = addr & 0xffffffff;\n\t\t\t\t \n\t\t\t\td->pci_h = (u64)addr >> 32;\n\n\t\t\t\t \n\t\t\t\td->local = 0;\n\t\t\t\td->reserved0 = 0;\n\t\t\t}\n\t\t}\n\n\t\td->bytes = bytes;\n\t\td->reserved1 = 0;\n\t\tsize -= bytes;\n\t\tcopied += bytes;\n\t\toffset += bytes;\n\n\t\tif (copied == copy_bytes) {\n\t\t\twhile (copied < stride) {\n\t\t\t\tbytes = min(sg_dma_len(scatter_list) - offset,\n\t\t\t\t\t\tstride - copied);\n\t\t\t\tcopied += bytes;\n\t\t\t\toffset += bytes;\n\t\t\t\tsize -= bytes;\n\t\t\t\tif (sg_dma_len(scatter_list) == offset) {\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tscatter_list = sg_next(scatter_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcopied = 0;\n\t\t} else {\n\t\t\toffset = 0;\n\t\t\tscatter_list = sg_next(scatter_list);\n\t\t}\n\n\t\t \n\t\tnext += sizeof(struct sg_dma_descriptor);\n\t\tif (size == 0) {\n\t\t\t \n\t\t\td->next_h = (u32)((u64)desc->bus >> 32);\n\t\t\td->next_l = (u32)desc->bus |\n\t\t\t\t(to_pci ? WRITE_TO_PCI : 0) | INTERRUPT_ENABLE;\n\t\t\tif (!to_pci)\n\t\t\t\td->local = 0x22222222;\n\t\t\tdesc->last_desc_virt = d;\n\t\t} else {\n\t\t\td->next_h = (u32)((u64)next >> 32);\n\t\t\td->next_l = (u32)next | (to_pci ? WRITE_TO_PCI : 0);\n\t\t}\n\t\td++;\n\t}\n\treturn 0;\n}\n\nvoid descriptor_list_chain(struct sg_dma_desc_info *this,\n\t\t\t   struct sg_dma_desc_info *next)\n{\n\tstruct sg_dma_descriptor *d = this->last_desc_virt;\n\tu32 direction = d->next_l & WRITE_TO_PCI;\n\n\tif (next == NULL) {\n\t\td->next_h = 0;\n\t\td->next_l = direction | INTERRUPT_ENABLE | END_OF_CHAIN;\n\t} else {\n\t\td->next_h = (u32)((u64)next->bus >> 32);\n\t\td->next_l = (u32)next->bus | direction | INTERRUPT_ENABLE;\n\t}\n}\n\nvoid *descriptor_list_allocate(struct sg_dma_desc_info *desc, size_t bytes)\n{\n\tdesc->size = bytes;\n\tdesc->virt = dma_alloc_coherent(desc->dev, bytes,\n\t\t\t\t\t&desc->bus, GFP_KERNEL);\n\treturn desc->virt;\n}\n\nvoid descriptor_list_free(struct sg_dma_desc_info *desc)\n{\n\tif (desc->virt)\n\t\tdma_free_coherent(desc->dev, desc->size,\n\t\t\t\t  desc->virt, desc->bus);\n\tdesc->virt = NULL;\n}\n\nvoid descriptor_list_interrupt_enable(struct sg_dma_desc_info *desc)\n{\n\tstruct sg_dma_descriptor *d = desc->last_desc_virt;\n\n\td->next_l |= INTERRUPT_ENABLE;\n}\n\nvoid descriptor_list_interrupt_disable(struct sg_dma_desc_info *desc)\n{\n\tstruct sg_dma_descriptor *d = desc->last_desc_virt;\n\n\td->next_l &= ~INTERRUPT_ENABLE;\n}\n\nvoid descriptor_list_loopback(struct sg_dma_desc_info *desc)\n{\n\tstruct sg_dma_descriptor *d = desc->last_desc_virt;\n\n\td->next_h = (u32)((u64)desc->bus >> 32);\n\td->next_l = (u32)desc->bus | (d->next_l & DESCRIPTOR_FLAG_MSK);\n}\n\nvoid descriptor_list_end_of_chain(struct sg_dma_desc_info *desc)\n{\n\tstruct sg_dma_descriptor *d = desc->last_desc_virt;\n\n\td->next_l |= END_OF_CHAIN;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}