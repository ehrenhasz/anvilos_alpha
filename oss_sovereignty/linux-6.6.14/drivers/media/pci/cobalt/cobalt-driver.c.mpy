{
  "module_name": "cobalt-driver.c",
  "hash_id": "350edaf44c6e5cf55e554951441569a226084fda5aa79c165c1a273a09703648",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-driver.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <media/i2c/adv7604.h>\n#include <media/i2c/adv7842.h>\n#include <media/i2c/adv7511.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"cobalt-driver.h\"\n#include \"cobalt-irq.h\"\n#include \"cobalt-i2c.h\"\n#include \"cobalt-v4l2.h\"\n#include \"cobalt-flash.h\"\n#include \"cobalt-alsa.h\"\n#include \"cobalt-omnitek.h\"\n\n \nstatic const struct pci_device_id cobalt_pci_tbl[] = {\n\t{PCI_VENDOR_ID_CISCO, PCI_DEVICE_ID_COBALT,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, cobalt_pci_tbl);\n\nstatic atomic_t cobalt_instance = ATOMIC_INIT(0);\n\nint cobalt_debug;\nmodule_param_named(debug, cobalt_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level. Default: 0\\n\");\n\nint cobalt_ignore_err;\nmodule_param_named(ignore_err, cobalt_ignore_err, int, 0644);\nMODULE_PARM_DESC(ignore_err,\n\t\"If set then ignore missing i2c adapters/receivers. Default: 0\\n\");\n\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com> & Morten Hestnes\");\nMODULE_DESCRIPTION(\"cobalt driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic u8 edid[256] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,\n\t0x50, 0x21, 0x32, 0x27, 0x00, 0x00, 0x00, 0x00,\n\t0x22, 0x1a, 0x01, 0x03, 0x80, 0x30, 0x1b, 0x78,\n\t0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,\n\t0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,\n\t0x45, 0x59, 0x61, 0x59, 0x81, 0x99, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a,\n\t0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,\n\t0x45, 0x00, 0xe0, 0x0e, 0x11, 0x00, 0x00, 0x1e,\n\t0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,\n\t0x5e, 0x11, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x63,\n\t0x6f, 0x62, 0x61, 0x6c, 0x74, 0x0a, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x9d,\n\n\t0x02, 0x03, 0x1f, 0xf1, 0x4a, 0x10, 0x1f, 0x04,\n\t0x13, 0x22, 0x21, 0x20, 0x02, 0x11, 0x01, 0x23,\n\t0x09, 0x07, 0x07, 0x68, 0x03, 0x0c, 0x00, 0x10,\n\t0x00, 0x00, 0x22, 0x0f, 0xe2, 0x00, 0xca, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,\n};\n\nstatic void cobalt_set_interrupt(struct cobalt *cobalt, bool enable)\n{\n\tif (enable) {\n\t\tunsigned irqs = COBALT_SYSSTAT_VI0_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI1_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI2_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI3_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI0_INT2_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI1_INT2_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI2_INT2_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI3_INT2_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI0_LOST_DATA_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI1_LOST_DATA_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI2_LOST_DATA_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VI3_LOST_DATA_MSK |\n\t\t\t\tCOBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK;\n\n\t\tif (cobalt->have_hsma_rx)\n\t\t\tirqs |= COBALT_SYSSTAT_VIHSMA_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VIHSMA_INT2_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VIHSMA_LOST_DATA_MSK;\n\n\t\tif (cobalt->have_hsma_tx)\n\t\t\tirqs |= COBALT_SYSSTAT_VOHSMA_INT1_MSK |\n\t\t\t\tCOBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK |\n\t\t\t\tCOBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK;\n\t\t \n\t\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_EDGE, 0xffffffff);\n\t\t \n\t\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, irqs);\n\t} else {\n\t\t \n\t\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, 0);\n\t}\n}\n\nstatic unsigned cobalt_get_sd_nr(struct v4l2_subdev *sd)\n{\n\tstruct cobalt *cobalt = to_cobalt(sd->v4l2_dev);\n\tunsigned i;\n\n\tfor (i = 0; i < COBALT_NUM_NODES; i++)\n\t\tif (sd == cobalt->streams[i].sd)\n\t\t\treturn i;\n\tcobalt_err(\"Invalid adv7604 subdev pointer!\\n\");\n\treturn 0;\n}\n\nstatic void cobalt_notify(struct v4l2_subdev *sd,\n\t\t\t  unsigned int notification, void *arg)\n{\n\tstruct cobalt *cobalt = to_cobalt(sd->v4l2_dev);\n\tunsigned sd_nr = cobalt_get_sd_nr(sd);\n\tstruct cobalt_stream *s = &cobalt->streams[sd_nr];\n\tbool hotplug = arg ? *((int *)arg) : false;\n\n\tif (s->is_output)\n\t\treturn;\n\n\tswitch (notification) {\n\tcase ADV76XX_HOTPLUG:\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\tCOBALT_SYS_CTRL_HPD_TO_CONNECTOR_BIT(sd_nr), hotplug);\n\t\tcobalt_dbg(1, \"Set hotplug for adv %d to %d\\n\", sd_nr, hotplug);\n\t\tbreak;\n\tcase V4L2_DEVICE_NOTIFY_EVENT:\n\t\tcobalt_dbg(1, \"Format changed for adv %d\\n\", sd_nr);\n\t\tv4l2_event_queue(&s->vdev, arg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int get_payload_size(u16 code)\n{\n\tswitch (code) {\n\tcase 0: return 128;\n\tcase 1: return 256;\n\tcase 2: return 512;\n\tcase 3: return 1024;\n\tcase 4: return 2048;\n\tcase 5: return 4096;\n\tdefault: return 0;\n\t}\n\treturn 0;\n}\n\nstatic const char *get_link_speed(u16 stat)\n{\n\tswitch (stat & PCI_EXP_LNKSTA_CLS) {\n\tcase 1:\treturn \"2.5 Gbit/s\";\n\tcase 2:\treturn \"5 Gbit/s\";\n\tcase 3:\treturn \"10 Gbit/s\";\n\t}\n\treturn \"Unknown speed\";\n}\n\nvoid cobalt_pcie_status_show(struct cobalt *cobalt)\n{\n\tstruct pci_dev *pci_dev = cobalt->pci_dev;\n\tstruct pci_dev *pci_bus_dev = cobalt->pci_dev->bus->self;\n\tu32 capa;\n\tu16 stat, ctrl;\n\n\tif (!pci_is_pcie(pci_dev) || !pci_is_pcie(pci_bus_dev))\n\t\treturn;\n\n\t \n\tpcie_capability_read_dword(pci_dev, PCI_EXP_DEVCAP, &capa);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_DEVCTL, &ctrl);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_DEVSTA, &stat);\n\tcobalt_info(\"PCIe device capability 0x%08x: Max payload %d\\n\",\n\t\t    capa, get_payload_size(capa & PCI_EXP_DEVCAP_PAYLOAD));\n\tcobalt_info(\"PCIe device control 0x%04x: Max payload %d. Max read request %d\\n\",\n\t\t    ctrl,\n\t\t    get_payload_size((ctrl & PCI_EXP_DEVCTL_PAYLOAD) >> 5),\n\t\t    get_payload_size((ctrl & PCI_EXP_DEVCTL_READRQ) >> 12));\n\tcobalt_info(\"PCIe device status 0x%04x\\n\", stat);\n\n\t \n\tpcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &capa);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_LNKCTL, &ctrl);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &stat);\n\tcobalt_info(\"PCIe link capability 0x%08x: %s per lane and %u lanes\\n\",\n\t\t\tcapa, get_link_speed(capa),\n\t\t\tFIELD_GET(PCI_EXP_LNKCAP_MLW, capa));\n\tcobalt_info(\"PCIe link control 0x%04x\\n\", ctrl);\n\tcobalt_info(\"PCIe link status 0x%04x: %s per lane and %u lanes\\n\",\n\t\t    stat, get_link_speed(stat),\n\t\t    FIELD_GET(PCI_EXP_LNKSTA_NLW, stat));\n\n\t \n\tpcie_capability_read_dword(pci_bus_dev, PCI_EXP_LNKCAP, &capa);\n\tcobalt_info(\"PCIe bus link capability 0x%08x: %s per lane and %u lanes\\n\",\n\t\t\tcapa, get_link_speed(capa),\n\t\t\tFIELD_GET(PCI_EXP_LNKCAP_MLW, capa));\n\n\t \n\tpcie_capability_read_dword(pci_dev, PCI_EXP_SLTCAP, &capa);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_SLTCTL, &ctrl);\n\tpcie_capability_read_word(pci_dev, PCI_EXP_SLTSTA, &stat);\n\tcobalt_info(\"PCIe slot capability 0x%08x\\n\", capa);\n\tcobalt_info(\"PCIe slot control 0x%04x\\n\", ctrl);\n\tcobalt_info(\"PCIe slot status 0x%04x\\n\", stat);\n}\n\nstatic unsigned pcie_link_get_lanes(struct cobalt *cobalt)\n{\n\tstruct pci_dev *pci_dev = cobalt->pci_dev;\n\tu16 link;\n\n\tif (!pci_is_pcie(pci_dev))\n\t\treturn 0;\n\tpcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &link);\n\treturn FIELD_GET(PCI_EXP_LNKSTA_NLW, link);\n}\n\nstatic unsigned pcie_bus_link_get_lanes(struct cobalt *cobalt)\n{\n\tstruct pci_dev *pci_dev = cobalt->pci_dev->bus->self;\n\tu32 link;\n\n\tif (!pci_is_pcie(pci_dev))\n\t\treturn 0;\n\tpcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &link);\n\treturn FIELD_GET(PCI_EXP_LNKCAP_MLW, link);\n}\n\nstatic void msi_config_show(struct cobalt *cobalt, struct pci_dev *pci_dev)\n{\n\tu16 ctrl, data;\n\tu32 adrs_l, adrs_h;\n\n\tpci_read_config_word(pci_dev, 0x52, &ctrl);\n\tcobalt_info(\"MSI %s\\n\", ctrl & 1 ? \"enable\" : \"disable\");\n\tcobalt_info(\"MSI multiple message: Capable %u. Enable %u\\n\",\n\t\t    (1 << ((ctrl >> 1) & 7)), (1 << ((ctrl >> 4) & 7)));\n\tif (ctrl & 0x80)\n\t\tcobalt_info(\"MSI: 64-bit address capable\\n\");\n\tpci_read_config_dword(pci_dev, 0x54, &adrs_l);\n\tpci_read_config_dword(pci_dev, 0x58, &adrs_h);\n\tpci_read_config_word(pci_dev, 0x5c, &data);\n\tif (ctrl & 0x80)\n\t\tcobalt_info(\"MSI: Address 0x%08x%08x. Data 0x%04x\\n\",\n\t\t\t\tadrs_h, adrs_l, data);\n\telse\n\t\tcobalt_info(\"MSI: Address 0x%08x. Data 0x%04x\\n\",\n\t\t\t\tadrs_l, data);\n}\n\nstatic void cobalt_pci_iounmap(struct cobalt *cobalt, struct pci_dev *pci_dev)\n{\n\tif (cobalt->bar0) {\n\t\tpci_iounmap(pci_dev, cobalt->bar0);\n\t\tcobalt->bar0 = NULL;\n\t}\n\tif (cobalt->bar1) {\n\t\tpci_iounmap(pci_dev, cobalt->bar1);\n\t\tcobalt->bar1 = NULL;\n\t}\n}\n\nstatic void cobalt_free_msi(struct cobalt *cobalt, struct pci_dev *pci_dev)\n{\n\tfree_irq(pci_dev->irq, (void *)cobalt);\n\tpci_free_irq_vectors(pci_dev);\n}\n\nstatic int cobalt_setup_pci(struct cobalt *cobalt, struct pci_dev *pci_dev,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tu32 ctrl;\n\tint ret;\n\n\tcobalt_dbg(1, \"enabling pci device\\n\");\n\n\tret = pci_enable_device(pci_dev);\n\tif (ret) {\n\t\tcobalt_err(\"can't enable device\\n\");\n\t\treturn ret;\n\t}\n\tpci_set_master(pci_dev);\n\tpci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &cobalt->card_rev);\n\tpci_read_config_word(pci_dev, PCI_DEVICE_ID, &cobalt->device_id);\n\n\tswitch (cobalt->device_id) {\n\tcase PCI_DEVICE_ID_COBALT:\n\t\tcobalt_info(\"PCI Express interface from Omnitek\\n\");\n\t\tbreak;\n\tdefault:\n\t\tcobalt_info(\"PCI Express interface provider is unknown!\\n\");\n\t\tbreak;\n\t}\n\n\tif (pcie_link_get_lanes(cobalt) != 8) {\n\t\tcobalt_warn(\"PCI Express link width is %d lanes.\\n\",\n\t\t\t\tpcie_link_get_lanes(cobalt));\n\t\tif (pcie_bus_link_get_lanes(cobalt) < 8)\n\t\t\tcobalt_warn(\"The current slot only supports %d lanes, for best performance 8 are needed\\n\",\n\t\t\t\t\tpcie_bus_link_get_lanes(cobalt));\n\t\tif (pcie_link_get_lanes(cobalt) != pcie_bus_link_get_lanes(cobalt)) {\n\t\t\tcobalt_err(\"The card is most likely not seated correctly in the PCIe slot\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto err_disable;\n\t\t}\n\t}\n\n\tif (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(64))) {\n\t\tret = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tcobalt_err(\"no suitable DMA available\\n\");\n\t\t\tgoto err_disable;\n\t\t}\n\t}\n\n\tret = pci_request_regions(pci_dev, \"cobalt\");\n\tif (ret) {\n\t\tcobalt_err(\"error requesting regions\\n\");\n\t\tgoto err_disable;\n\t}\n\n\tcobalt_pcie_status_show(cobalt);\n\n\tcobalt->bar0 = pci_iomap(pci_dev, 0, 0);\n\tcobalt->bar1 = pci_iomap(pci_dev, 1, 0);\n\tif (cobalt->bar1 == NULL) {\n\t\tcobalt->bar1 = pci_iomap(pci_dev, 2, 0);\n\t\tcobalt_info(\"64-bit BAR\\n\");\n\t}\n\tif (!cobalt->bar0 || !cobalt->bar1) {\n\t\tret = -EIO;\n\t\tgoto err_release;\n\t}\n\n\t \n\tctrl = cobalt_read_bar1(cobalt, COBALT_SYS_CTRL_BASE);\n\tcobalt_write_bar1(cobalt, COBALT_SYS_CTRL_BASE, ctrl & ~0xf00);\n\n\t \n\tcobalt_set_interrupt(cobalt, false);\n\n\tif (pci_alloc_irq_vectors(pci_dev, 1, 1, PCI_IRQ_MSI) < 1) {\n\t\tcobalt_err(\"Could not enable MSI\\n\");\n\t\tret = -EIO;\n\t\tgoto err_release;\n\t}\n\tmsi_config_show(cobalt, pci_dev);\n\n\t \n\tif (request_irq(pci_dev->irq, cobalt_irq_handler, IRQF_SHARED,\n\t\t\tcobalt->v4l2_dev.name, (void *)cobalt)) {\n\t\tcobalt_err(\"Failed to register irq %d\\n\", pci_dev->irq);\n\t\tret = -EIO;\n\t\tgoto err_msi;\n\t}\n\n\tomni_sg_dma_init(cobalt);\n\treturn 0;\n\nerr_msi:\n\tpci_disable_msi(pci_dev);\n\nerr_release:\n\tcobalt_pci_iounmap(cobalt, pci_dev);\n\tpci_release_regions(pci_dev);\n\nerr_disable:\n\tpci_disable_device(cobalt->pci_dev);\n\treturn ret;\n}\n\nstatic int cobalt_hdl_info_get(struct cobalt *cobalt)\n{\n\tint i;\n\n\tfor (i = 0; i < COBALT_HDL_INFO_SIZE; i++)\n\t\tcobalt->hdl_info[i] =\n\t\t\tioread8(cobalt->bar1 + COBALT_HDL_INFO_BASE + i);\n\tcobalt->hdl_info[COBALT_HDL_INFO_SIZE - 1] = '\\0';\n\tif (strstr(cobalt->hdl_info, COBALT_HDL_SEARCH_STR))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void cobalt_stream_struct_init(struct cobalt *cobalt)\n{\n\tint i;\n\n\tfor (i = 0; i < COBALT_NUM_STREAMS; i++) {\n\t\tstruct cobalt_stream *s = &cobalt->streams[i];\n\n\t\ts->cobalt = cobalt;\n\t\ts->flags = 0;\n\t\ts->is_audio = false;\n\t\ts->is_output = false;\n\t\ts->is_dummy = true;\n\n\t\t \n\t\tif (i <= COBALT_HSMA_IN_NODE) {\n\t\t\ts->dma_channel = i + cobalt->first_fifo_channel;\n\t\t\ts->video_channel = i;\n\t\t\ts->dma_fifo_mask =\n\t\t\t\tCOBALT_SYSSTAT_VI0_LOST_DATA_MSK << (4 * i);\n\t\t\ts->adv_irq_mask =\n\t\t\t\tCOBALT_SYSSTAT_VI0_INT1_MSK << (4 * i);\n\t\t} else if (i >= COBALT_AUDIO_IN_STREAM &&\n\t\t\t   i <= COBALT_AUDIO_IN_STREAM + 4) {\n\t\t\tunsigned idx = i - COBALT_AUDIO_IN_STREAM;\n\n\t\t\ts->dma_channel = 6 + idx;\n\t\t\ts->is_audio = true;\n\t\t\ts->video_channel = idx;\n\t\t\ts->dma_fifo_mask = COBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK;\n\t\t} else if (i == COBALT_HSMA_OUT_NODE) {\n\t\t\ts->dma_channel = 11;\n\t\t\ts->is_output = true;\n\t\t\ts->video_channel = 5;\n\t\t\ts->dma_fifo_mask = COBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK;\n\t\t\ts->adv_irq_mask = COBALT_SYSSTAT_VOHSMA_INT1_MSK;\n\t\t} else if (i == COBALT_AUDIO_OUT_STREAM) {\n\t\t\ts->dma_channel = 12;\n\t\t\ts->is_audio = true;\n\t\t\ts->is_output = true;\n\t\t\ts->video_channel = 5;\n\t\t\ts->dma_fifo_mask = COBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK;\n\t\t} else {\n\t\t\t \n\t\t\ts->dma_channel = i - COBALT_NUM_NODES;\n\t\t}\n\t\tcobalt_info(\"stream #%d -> dma channel #%d <- video channel %d\\n\",\n\t\t\t    i, s->dma_channel, s->video_channel);\n\t}\n}\n\nstatic int cobalt_subdevs_init(struct cobalt *cobalt)\n{\n\tstatic struct adv76xx_platform_data adv7604_pdata = {\n\t\t.disable_pwrdnb = 1,\n\t\t.ain_sel = ADV7604_AIN7_8_9_NC_SYNC_3_1,\n\t\t.bus_order = ADV7604_BUS_ORDER_BRG,\n\t\t.blank_data = 1,\n\t\t.op_format_mode_sel = ADV7604_OP_FORMAT_MODE0,\n\t\t.int1_config = ADV76XX_INT1_CONFIG_ACTIVE_HIGH,\n\t\t.dr_str_data = ADV76XX_DR_STR_HIGH,\n\t\t.dr_str_clk = ADV76XX_DR_STR_HIGH,\n\t\t.dr_str_sync = ADV76XX_DR_STR_HIGH,\n\t\t.hdmi_free_run_mode = 1,\n\t\t.inv_vs_pol = 1,\n\t\t.inv_hs_pol = 1,\n\t};\n\tstatic struct i2c_board_info adv7604_info = {\n\t\t.type = \"adv7604\",\n\t\t.addr = 0x20,\n\t\t.platform_data = &adv7604_pdata,\n\t};\n\n\tstruct cobalt_stream *s = cobalt->streams;\n\tint i;\n\n\tfor (i = 0; i < COBALT_NUM_INPUTS; i++) {\n\t\tstruct v4l2_subdev_format sd_fmt = {\n\t\t\t.pad = ADV7604_PAD_SOURCE,\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t};\n\t\tstruct v4l2_subdev_edid cobalt_edid = {\n\t\t\t.pad = ADV76XX_PAD_HDMI_PORT_A,\n\t\t\t.start_block = 0,\n\t\t\t.blocks = 2,\n\t\t\t.edid = edid,\n\t\t};\n\t\tint err;\n\n\t\ts[i].pad_source = ADV7604_PAD_SOURCE;\n\t\ts[i].i2c_adap = &cobalt->i2c_adap[i];\n\t\tif (s[i].i2c_adap->dev.parent == NULL)\n\t\t\tcontinue;\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(i), 1);\n\t\ts[i].sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\n\t\t\ts[i].i2c_adap, &adv7604_info, NULL);\n\t\tif (!s[i].sd) {\n\t\t\tif (cobalt_ignore_err)\n\t\t\t\tcontinue;\n\t\t\treturn -ENODEV;\n\t\t}\n\t\terr = v4l2_subdev_call(s[i].sd, video, s_routing,\n\t\t\t\tADV76XX_PAD_HDMI_PORT_A, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = v4l2_subdev_call(s[i].sd, pad, set_edid,\n\t\t\t\t&cobalt_edid);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = v4l2_subdev_call(s[i].sd, pad, set_fmt, NULL,\n\t\t\t\t&sd_fmt);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(i), 0);\n\t\tmdelay(2);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(i), 1);\n\t\tmdelay(1);\n\t\ts[i].is_dummy = false;\n\t\tcobalt->streams[i + COBALT_AUDIO_IN_STREAM].is_dummy = false;\n\t}\n\treturn 0;\n}\n\nstatic int cobalt_subdevs_hsma_init(struct cobalt *cobalt)\n{\n\tstatic struct adv7842_platform_data adv7842_pdata = {\n\t\t.disable_pwrdnb = 1,\n\t\t.ain_sel = ADV7842_AIN1_2_3_NC_SYNC_1_2,\n\t\t.bus_order = ADV7842_BUS_ORDER_RBG,\n\t\t.op_format_mode_sel = ADV7842_OP_FORMAT_MODE0,\n\t\t.blank_data = 1,\n\t\t.dr_str_data = 3,\n\t\t.dr_str_clk = 3,\n\t\t.dr_str_sync = 3,\n\t\t.mode = ADV7842_MODE_HDMI,\n\t\t.hdmi_free_run_enable = 1,\n\t\t.vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P,\n\t\t.i2c_sdp_io = 0x4a,\n\t\t.i2c_sdp = 0x48,\n\t\t.i2c_cp = 0x22,\n\t\t.i2c_vdp = 0x24,\n\t\t.i2c_afe = 0x26,\n\t\t.i2c_hdmi = 0x34,\n\t\t.i2c_repeater = 0x32,\n\t\t.i2c_edid = 0x36,\n\t\t.i2c_infoframe = 0x3e,\n\t\t.i2c_cec = 0x40,\n\t\t.i2c_avlink = 0x42,\n\t};\n\tstatic struct i2c_board_info adv7842_info = {\n\t\t.type = \"adv7842\",\n\t\t.addr = 0x20,\n\t\t.platform_data = &adv7842_pdata,\n\t};\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.pad = ADV7842_PAD_SOURCE,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t};\n\tstatic struct adv7511_platform_data adv7511_pdata = {\n\t\t.i2c_edid = 0x7e >> 1,\n\t\t.i2c_cec = 0x7c >> 1,\n\t\t.i2c_pktmem = 0x70 >> 1,\n\t\t.cec_clk = 12000000,\n\t};\n\tstatic struct i2c_board_info adv7511_info = {\n\t\t.type = \"adv7511-v4l2\",\n\t\t.addr = 0x39,  \n\t\t.platform_data = &adv7511_pdata,\n\t};\n\tstruct v4l2_subdev_edid cobalt_edid = {\n\t\t.pad = ADV7842_EDID_PORT_A,\n\t\t.start_block = 0,\n\t\t.blocks = 2,\n\t\t.edid = edid,\n\t};\n\tstruct cobalt_stream *s = &cobalt->streams[COBALT_HSMA_IN_NODE];\n\n\ts->i2c_adap = &cobalt->i2c_adap[COBALT_NUM_ADAPTERS - 1];\n\tif (s->i2c_adap->dev.parent == NULL)\n\t\treturn 0;\n\tcobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(4), 1);\n\n\ts->sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\n\t\t\ts->i2c_adap, &adv7842_info, NULL);\n\tif (s->sd) {\n\t\tint err = v4l2_subdev_call(s->sd, pad, set_edid, &cobalt_edid);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = v4l2_subdev_call(s->sd, pad, set_fmt, NULL,\n\t\t\t\t&sd_fmt);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcobalt->have_hsma_rx = true;\n\t\ts->pad_source = ADV7842_PAD_SOURCE;\n\t\ts->is_dummy = false;\n\t\tcobalt->streams[4 + COBALT_AUDIO_IN_STREAM].is_dummy = false;\n\t\t \n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 0);\n\t\tmdelay(2);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 1);\n\t\tmdelay(1);\n\t\treturn err;\n\t}\n\tcobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(4), 0);\n\tcobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_PWRDN0_TO_HSMA_TX_BIT, 0);\n\ts++;\n\ts->i2c_adap = &cobalt->i2c_adap[COBALT_NUM_ADAPTERS - 1];\n\ts->sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\n\t\t\ts->i2c_adap, &adv7511_info, NULL);\n\tif (s->sd) {\n\t\t \n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 1);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 0);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\t\tCOBALT_SYS_CTRL_VIDEO_TX_RESETN_BIT, 1);\n\t\tcobalt->have_hsma_tx = true;\n\t\tv4l2_subdev_call(s->sd, core, s_power, 1);\n\t\tv4l2_subdev_call(s->sd, video, s_stream, 1);\n\t\tv4l2_subdev_call(s->sd, audio, s_stream, 1);\n\t\tv4l2_ctrl_s_ctrl(v4l2_ctrl_find(s->sd->ctrl_handler,\n\t\t\t\t V4L2_CID_DV_TX_MODE), V4L2_DV_TX_MODE_HDMI);\n\t\ts->is_dummy = false;\n\t\tcobalt->streams[COBALT_AUDIO_OUT_STREAM].is_dummy = false;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int cobalt_probe(struct pci_dev *pci_dev,\n\t\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct cobalt *cobalt;\n\tint retval = 0;\n\tint i;\n\n\t \n\ti = atomic_inc_return(&cobalt_instance) - 1;\n\n\tcobalt = kzalloc(sizeof(struct cobalt), GFP_KERNEL);\n\tif (cobalt == NULL)\n\t\treturn -ENOMEM;\n\tcobalt->pci_dev = pci_dev;\n\tcobalt->instance = i;\n\tmutex_init(&cobalt->pci_lock);\n\n\tretval = v4l2_device_register(&pci_dev->dev, &cobalt->v4l2_dev);\n\tif (retval) {\n\t\tpr_err(\"cobalt: v4l2_device_register of card %d failed\\n\",\n\t\t\t\tcobalt->instance);\n\t\tkfree(cobalt);\n\t\treturn retval;\n\t}\n\tsnprintf(cobalt->v4l2_dev.name, sizeof(cobalt->v4l2_dev.name),\n\t\t \"cobalt-%d\", cobalt->instance);\n\tcobalt->v4l2_dev.notify = cobalt_notify;\n\tcobalt_info(\"Initializing card %d\\n\", cobalt->instance);\n\n\tcobalt->irq_work_queues =\n\t\tcreate_singlethread_workqueue(cobalt->v4l2_dev.name);\n\tif (cobalt->irq_work_queues == NULL) {\n\t\tcobalt_err(\"Could not create workqueue\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tINIT_WORK(&cobalt->irq_work_queue, cobalt_irq_work_handler);\n\n\t \n\tretval = cobalt_setup_pci(cobalt, pci_dev, pci_id);\n\tif (retval != 0)\n\t\tgoto err_wq;\n\n\t \n\tif (cobalt_hdl_info_get(cobalt))\n\t\tcobalt_info(\"Not able to read the HDL info\\n\");\n\telse\n\t\tcobalt_info(\"%s\", cobalt->hdl_info);\n\n\tretval = cobalt_i2c_init(cobalt);\n\tif (retval)\n\t\tgoto err_pci;\n\n\tcobalt_stream_struct_init(cobalt);\n\n\tretval = cobalt_subdevs_init(cobalt);\n\tif (retval)\n\t\tgoto err_i2c;\n\n\tif (!(cobalt_read_bar1(cobalt, COBALT_SYS_STAT_BASE) &\n\t\t\tCOBALT_SYSSTAT_HSMA_PRSNTN_MSK)) {\n\t\tretval = cobalt_subdevs_hsma_init(cobalt);\n\t\tif (retval)\n\t\t\tgoto err_i2c;\n\t}\n\n\tretval = cobalt_nodes_register(cobalt);\n\tif (retval) {\n\t\tcobalt_err(\"Error %d registering device nodes\\n\", retval);\n\t\tgoto err_i2c;\n\t}\n\tcobalt_set_interrupt(cobalt, true);\n\tv4l2_device_call_all(&cobalt->v4l2_dev, 0, core,\n\t\t\t\t\tinterrupt_service_routine, 0, NULL);\n\n\tcobalt_info(\"Initialized cobalt card\\n\");\n\n\tcobalt_flash_probe(cobalt);\n\n\treturn 0;\n\nerr_i2c:\n\tcobalt_i2c_exit(cobalt);\n\tcobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 0);\nerr_pci:\n\tcobalt_free_msi(cobalt, pci_dev);\n\tcobalt_pci_iounmap(cobalt, pci_dev);\n\tpci_release_regions(cobalt->pci_dev);\n\tpci_disable_device(cobalt->pci_dev);\nerr_wq:\n\tdestroy_workqueue(cobalt->irq_work_queues);\nerr:\n\tcobalt_err(\"error %d on initialization\\n\", retval);\n\n\tv4l2_device_unregister(&cobalt->v4l2_dev);\n\tkfree(cobalt);\n\treturn retval;\n}\n\nstatic void cobalt_remove(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct cobalt *cobalt = to_cobalt(v4l2_dev);\n\tint i;\n\n\tcobalt_flash_remove(cobalt);\n\tcobalt_set_interrupt(cobalt, false);\n\tflush_workqueue(cobalt->irq_work_queues);\n\tcobalt_nodes_unregister(cobalt);\n\tfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\n\t\tstruct v4l2_subdev *sd = cobalt->streams[i].sd;\n\t\tstruct i2c_client *client;\n\n\t\tif (sd == NULL)\n\t\t\tcontinue;\n\t\tclient = v4l2_get_subdevdata(sd);\n\t\tv4l2_device_unregister_subdev(sd);\n\t\ti2c_unregister_device(client);\n\t}\n\tcobalt_i2c_exit(cobalt);\n\tcobalt_free_msi(cobalt, pci_dev);\n\tcobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 0);\n\tcobalt_pci_iounmap(cobalt, pci_dev);\n\tpci_release_regions(cobalt->pci_dev);\n\tpci_disable_device(cobalt->pci_dev);\n\tdestroy_workqueue(cobalt->irq_work_queues);\n\n\tcobalt_info(\"removed cobalt card\\n\");\n\n\tv4l2_device_unregister(v4l2_dev);\n\tkfree(cobalt);\n}\n\n \nstatic struct pci_driver cobalt_pci_driver = {\n\t.name =     \"cobalt\",\n\t.id_table = cobalt_pci_tbl,\n\t.probe =    cobalt_probe,\n\t.remove =   cobalt_remove,\n};\n\nmodule_pci_driver(cobalt_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}