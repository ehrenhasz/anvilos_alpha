{
  "module_name": "cobalt-irq.c",
  "hash_id": "61f806a7986d921de3b97679c52d3541e1380a605f682b7a404573a440f2112a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-irq.c",
  "human_readable_source": "\n \n\n#include <media/i2c/adv7604.h>\n\n#include \"cobalt-driver.h\"\n#include \"cobalt-irq.h\"\n#include \"cobalt-omnitek.h\"\n\nstatic void cobalt_dma_stream_queue_handler(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\tint rx = s->video_channel;\n\tstruct m00473_freewheel_regmap __iomem *fw =\n\t\tCOBALT_CVI_FREEWHEEL(s->cobalt, rx);\n\tstruct m00233_video_measure_regmap __iomem *vmr =\n\t\tCOBALT_CVI_VMR(s->cobalt, rx);\n\tstruct m00389_cvi_regmap __iomem *cvi =\n\t\tCOBALT_CVI(s->cobalt, rx);\n\tstruct m00479_clk_loss_detector_regmap __iomem *clkloss =\n\t\tCOBALT_CVI_CLK_LOSS(s->cobalt, rx);\n\tstruct cobalt_buffer *cb;\n\tbool skip = false;\n\n\tspin_lock(&s->irqlock);\n\n\tif (list_empty(&s->bufs)) {\n\t\tpr_err(\"no buffers!\\n\");\n\t\tspin_unlock(&s->irqlock);\n\t\treturn;\n\t}\n\n\t \n\tcb = list_first_entry(&s->bufs, struct cobalt_buffer, list);\n\tlist_del(&cb->list);\n\tspin_unlock(&s->irqlock);\n\n\tif (s->is_audio || s->is_output)\n\t\tgoto done;\n\n\tif (s->unstable_frame) {\n\t\tuint32_t stat = ioread32(&vmr->irq_status);\n\n\t\tiowrite32(stat, &vmr->irq_status);\n\t\tif (!(ioread32(&vmr->status) &\n\t\t      M00233_STATUS_BITMAP_INIT_DONE_MSK)) {\n\t\t\tcobalt_dbg(1, \"!init_done\\n\");\n\t\t\tif (s->enable_freewheel)\n\t\t\t\tgoto restart_fw;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ioread32(&clkloss->status) &\n\t\t    M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) {\n\t\t\tiowrite32(0, &clkloss->ctrl);\n\t\t\tiowrite32(M00479_CTRL_BITMAP_ENABLE_MSK, &clkloss->ctrl);\n\t\t\tcobalt_dbg(1, \"no clock\\n\");\n\t\t\tif (s->enable_freewheel)\n\t\t\t\tgoto restart_fw;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((stat & (M00233_IRQ_STATUS_BITMAP_VACTIVE_AREA_MSK |\n\t\t\t     M00233_IRQ_STATUS_BITMAP_HACTIVE_AREA_MSK)) ||\n\t\t\t\tioread32(&vmr->vactive_area) != s->timings.bt.height ||\n\t\t\t\tioread32(&vmr->hactive_area) != s->timings.bt.width) {\n\t\t\tcobalt_dbg(1, \"unstable\\n\");\n\t\t\tif (s->enable_freewheel)\n\t\t\t\tgoto restart_fw;\n\t\t\tgoto done;\n\t\t}\n\t\tif (!s->enable_cvi) {\n\t\t\ts->enable_cvi = true;\n\t\t\tiowrite32(M00389_CONTROL_BITMAP_ENABLE_MSK, &cvi->control);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!(ioread32(&cvi->status) & M00389_STATUS_BITMAP_LOCK_MSK)) {\n\t\t\tcobalt_dbg(1, \"cvi no lock\\n\");\n\t\t\tif (s->enable_freewheel)\n\t\t\t\tgoto restart_fw;\n\t\t\tgoto done;\n\t\t}\n\t\tif (!s->enable_freewheel) {\n\t\t\tcobalt_dbg(1, \"stable\\n\");\n\t\t\ts->enable_freewheel = true;\n\t\t\tiowrite32(0, &fw->ctrl);\n\t\t\tgoto done;\n\t\t}\n\t\tcobalt_dbg(1, \"enabled fw\\n\");\n\t\tiowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK |\n\t\t\t  M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK,\n\t\t\t  &vmr->control);\n\t\tiowrite32(M00473_CTRL_BITMAP_ENABLE_MSK, &fw->ctrl);\n\t\ts->enable_freewheel = false;\n\t\ts->unstable_frame = false;\n\t\ts->skip_first_frames = 2;\n\t\tskip = true;\n\t\tgoto done;\n\t}\n\tif (ioread32(&fw->status) & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) {\nrestart_fw:\n\t\tcobalt_dbg(1, \"lost lock\\n\");\n\t\tiowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK,\n\t\t\t  &vmr->control);\n\t\tiowrite32(M00473_CTRL_BITMAP_ENABLE_MSK |\n\t\t\t  M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK,\n\t\t\t  &fw->ctrl);\n\t\tiowrite32(0, &cvi->control);\n\t\ts->unstable_frame = true;\n\t\ts->enable_freewheel = false;\n\t\ts->enable_cvi = false;\n\t}\ndone:\n\tif (s->skip_first_frames) {\n\t\tskip = true;\n\t\ts->skip_first_frames--;\n\t}\n\tcb->vb.vb2_buf.timestamp = ktime_get_ns();\n\t \n\tcb->vb.sequence = s->sequence++;\n\tvb2_buffer_done(&cb->vb.vb2_buf,\n\t\t\t(skip || s->unstable_frame) ?\n\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n}\n\nirqreturn_t cobalt_irq_handler(int irq, void *dev_id)\n{\n\tstruct cobalt *cobalt = (struct cobalt *)dev_id;\n\tu32 dma_interrupt =\n\t\tcobalt_read_bar0(cobalt, DMA_INTERRUPT_STATUS_REG) & 0xffff;\n\tu32 mask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);\n\tu32 edge = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_EDGE);\n\tint i;\n\n\t \n\tcobalt_write_bar0(cobalt, DMA_INTERRUPT_STATUS_REG, dma_interrupt);\n\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, mask & ~edge);\n\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_EDGE, edge);\n\n\tfor (i = 0; i < COBALT_NUM_STREAMS; i++) {\n\t\tstruct cobalt_stream *s = &cobalt->streams[i];\n\t\tunsigned dma_fifo_mask = s->dma_fifo_mask;\n\n\t\tif (dma_interrupt & (1 << s->dma_channel)) {\n\t\t\tcobalt->irq_dma[i]++;\n\t\t\t \n\t\t\tcobalt_dma_stream_queue_handler(s);\n\t\t\tif (!s->is_audio) {\n\t\t\t\tedge &= ~dma_fifo_mask;\n\t\t\t\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,\n\t\t\t\t\t\t  mask & ~edge);\n\t\t\t}\n\t\t}\n\t\tif (s->is_audio)\n\t\t\tcontinue;\n\t\tif (edge & s->adv_irq_mask)\n\t\t\tset_bit(COBALT_STREAM_FL_ADV_IRQ, &s->flags);\n\t\tif ((edge & mask & dma_fifo_mask) && vb2_is_streaming(&s->q)) {\n\t\t\tcobalt_info(\"full rx FIFO %d\\n\", i);\n\t\t\tcobalt->irq_full_fifo++;\n\t\t}\n\t}\n\n\tqueue_work(cobalt->irq_work_queues, &cobalt->irq_work_queue);\n\n\tif (edge & mask & (COBALT_SYSSTAT_VI0_INT1_MSK |\n\t\t\t   COBALT_SYSSTAT_VI1_INT1_MSK |\n\t\t\t   COBALT_SYSSTAT_VI2_INT1_MSK |\n\t\t\t   COBALT_SYSSTAT_VI3_INT1_MSK |\n\t\t\t   COBALT_SYSSTAT_VIHSMA_INT1_MSK |\n\t\t\t   COBALT_SYSSTAT_VOHSMA_INT1_MSK))\n\t\tcobalt->irq_adv1++;\n\tif (edge & mask & (COBALT_SYSSTAT_VI0_INT2_MSK |\n\t\t\t   COBALT_SYSSTAT_VI1_INT2_MSK |\n\t\t\t   COBALT_SYSSTAT_VI2_INT2_MSK |\n\t\t\t   COBALT_SYSSTAT_VI3_INT2_MSK |\n\t\t\t   COBALT_SYSSTAT_VIHSMA_INT2_MSK))\n\t\tcobalt->irq_adv2++;\n\tif (edge & mask & COBALT_SYSSTAT_VOHSMA_INT1_MSK)\n\t\tcobalt->irq_advout++;\n\tif (dma_interrupt)\n\t\tcobalt->irq_dma_tot++;\n\tif (!(edge & mask) && !dma_interrupt)\n\t\tcobalt->irq_none++;\n\tdma_interrupt = cobalt_read_bar0(cobalt, DMA_INTERRUPT_STATUS_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid cobalt_irq_work_handler(struct work_struct *work)\n{\n\tstruct cobalt *cobalt =\n\t\tcontainer_of(work, struct cobalt, irq_work_queue);\n\tint i;\n\n\tfor (i = 0; i < COBALT_NUM_NODES; i++) {\n\t\tstruct cobalt_stream *s = &cobalt->streams[i];\n\n\t\tif (test_and_clear_bit(COBALT_STREAM_FL_ADV_IRQ, &s->flags)) {\n\t\t\tu32 mask;\n\n\t\t\tv4l2_subdev_call(cobalt->streams[i].sd, core,\n\t\t\t\t\tinterrupt_service_routine, 0, NULL);\n\t\t\tmask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);\n\t\t\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,\n\t\t\t\tmask | s->adv_irq_mask);\n\t\t}\n\t}\n}\n\nvoid cobalt_irq_log_status(struct cobalt *cobalt)\n{\n\tu32 mask;\n\tint i;\n\n\tcobalt_info(\"irq: adv1=%u adv2=%u advout=%u none=%u full=%u\\n\",\n\t\t    cobalt->irq_adv1, cobalt->irq_adv2, cobalt->irq_advout,\n\t\t    cobalt->irq_none, cobalt->irq_full_fifo);\n\tcobalt_info(\"irq: dma_tot=%u (\", cobalt->irq_dma_tot);\n\tfor (i = 0; i < COBALT_NUM_STREAMS; i++)\n\t\tpr_cont(\"%s%u\", i ? \"/\" : \"\", cobalt->irq_dma[i]);\n\tpr_cont(\")\\n\");\n\tcobalt->irq_dma_tot = cobalt->irq_adv1 = cobalt->irq_adv2 = 0;\n\tcobalt->irq_advout = cobalt->irq_none = cobalt->irq_full_fifo = 0;\n\tmemset(cobalt->irq_dma, 0, sizeof(cobalt->irq_dma));\n\n\tmask = cobalt_read_bar1(cobalt, COBALT_SYS_STAT_MASK);\n\tcobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK,\n\t\t\tmask |\n\t\t\tCOBALT_SYSSTAT_VI0_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_VI1_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_VI2_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_VI3_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_VIHSMA_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK |\n\t\t\tCOBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}