{
  "module_name": "cobalt-i2c.c",
  "hash_id": "d0db7eedacd2b6e28bed427ddb757796e1a63995e7ef1ea30b8404f64ce6965a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-i2c.c",
  "human_readable_source": "\n \n\n#include \"cobalt-driver.h\"\n#include \"cobalt-i2c.h\"\n\nstruct cobalt_i2c_regs {\n\t \n\tu8 prerlo;\n\tu8 dummy0[3];\n\t \n\tu8 prerhi;\n\tu8 dummy1[3];\n\t \n\tu8 ctr;\n\tu8 dummy2[3];\n\t \n\tu8 txr_rxr;\n\tu8 dummy3[3];\n\t \n\tu8 cr_sr;\n\tu8 dummy4[3];\n};\n\n \n\n \n#define M00018_CTR_BITMAP_EN_MSK\t(1 << 7)\n\n \n#define M00018_CTR_BITMAP_IEN_MSK\t(1 << 6)\n\n \n\n \n#define M00018_CR_BITMAP_STA_MSK\t(1 << 7)\n\n \n#define M00018_CR_BITMAP_STO_MSK\t(1 << 6)\n\n \n#define M00018_CR_BITMAP_RD_MSK\t\t(1 << 5)\n\n \n#define M00018_CR_BITMAP_WR_MSK\t\t(1 << 4)\n\n \n#define M00018_CR_BITMAP_ACK_MSK\t(1 << 3)\n\n \n#define M00018_CR_BITMAP_IACK_MSK\t(1 << 0)\n\n \n\n \n#define M00018_SR_BITMAP_RXACK_MSK\t(1 << 7)\n\n \n#define M00018_SR_BITMAP_BUSY_MSK\t(1 << 6)\n\n \n#define M00018_SR_BITMAP_AL_MSK\t\t(1 << 5)\n\n \n#define M00018_SR_BITMAP_TIP_MSK\t(1 << 1)\n\n \n#define M00018_SR_BITMAP_IF_MSK\t\t(1 << 0)\n\n \n#define I2C_FREQUENCY\t\t\t400000\n#define ALT_CPU_FREQ\t\t\t83333333\n\nstatic struct cobalt_i2c_regs __iomem *\ncobalt_i2c_regs(struct cobalt *cobalt, unsigned idx)\n{\n\tswitch (idx) {\n\tcase 0:\n\tdefault:\n\t\treturn (struct cobalt_i2c_regs __iomem *)\n\t\t\t(cobalt->bar1 + COBALT_I2C_0_BASE);\n\tcase 1:\n\t\treturn (struct cobalt_i2c_regs __iomem *)\n\t\t\t(cobalt->bar1 + COBALT_I2C_1_BASE);\n\tcase 2:\n\t\treturn (struct cobalt_i2c_regs __iomem *)\n\t\t\t(cobalt->bar1 + COBALT_I2C_2_BASE);\n\tcase 3:\n\t\treturn (struct cobalt_i2c_regs __iomem *)\n\t\t\t(cobalt->bar1 + COBALT_I2C_3_BASE);\n\tcase 4:\n\t\treturn (struct cobalt_i2c_regs __iomem *)\n\t\t\t(cobalt->bar1 + COBALT_I2C_HSMA_BASE);\n\t}\n}\n\n \nstatic int cobalt_tx_bytes(struct cobalt_i2c_regs __iomem *regs,\n\t\tstruct i2c_adapter *adap, bool start, bool stop,\n\t\tu8 *data, u16 len)\n{\n\tunsigned long start_time;\n\tint status;\n\tint cmd;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\t \n\t\tiowrite8(data[i], &regs->txr_rxr);\n\n\t\t \n\t\tif (i == 0 && start) {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_WR_MSK |\n\t\t\t      M00018_CR_BITMAP_STA_MSK;\n\t\t} else if (i == len - 1 && stop) {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_WR_MSK |\n\t\t\t      M00018_CR_BITMAP_STO_MSK;\n\t\t} else {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_WR_MSK;\n\t\t}\n\n\t\t \n\t\tiowrite8(cmd, &regs->cr_sr);\n\n\t\t \n\t\tstart_time = jiffies;\n\t\tstatus = ioread8(&regs->cr_sr);\n\t\twhile (status & M00018_SR_BITMAP_TIP_MSK) {\n\t\t\tif (time_after(jiffies, start_time + adap->timeout))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tcond_resched();\n\t\t\tstatus = ioread8(&regs->cr_sr);\n\t\t}\n\n\t\t \n\t\tif (status & M00018_SR_BITMAP_RXACK_MSK) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (status & M00018_SR_BITMAP_AL_MSK) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int cobalt_rx_bytes(struct cobalt_i2c_regs __iomem *regs,\n\t\tstruct i2c_adapter *adap, bool start, bool stop,\n\t\tu8 *data, u16 len)\n{\n\tunsigned long start_time;\n\tint status;\n\tint cmd;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\t \n\t\tif (i == 0 && start) {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_RD_MSK |\n\t\t\t      M00018_CR_BITMAP_STA_MSK;\n\t\t} else if (i == len - 1 && stop) {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_RD_MSK |\n\t\t\t      M00018_CR_BITMAP_STO_MSK;\n\t\t} else {\n\t\t\t \n\t\t\tcmd = M00018_CR_BITMAP_RD_MSK;\n\t\t}\n\n\t\t \n\t\tif (i == len - 1)\n\t\t\tcmd |= M00018_CR_BITMAP_ACK_MSK;\n\n\t\t \n\t\tiowrite8(cmd, &regs->cr_sr);\n\n\t\t \n\t\tstart_time = jiffies;\n\t\tstatus = ioread8(&regs->cr_sr);\n\t\twhile (status & M00018_SR_BITMAP_TIP_MSK) {\n\t\t\tif (time_after(jiffies, start_time + adap->timeout))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tcond_resched();\n\t\t\tstatus = ioread8(&regs->cr_sr);\n\t\t}\n\n\t\t \n\t\tif (status & M00018_SR_BITMAP_AL_MSK) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tdata[i] = ioread8(&regs->txr_rxr);\n\t}\n\treturn 0;\n}\n\n \nstatic int cobalt_stop(struct cobalt_i2c_regs __iomem *regs,\n\t\tstruct i2c_adapter *adap)\n{\n\tu8 data = 0;\n\n\treturn cobalt_tx_bytes(regs, adap, true, true, &data, 1);\n}\n\nstatic int cobalt_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct cobalt_i2c_data *data = adap->algo_data;\n\tstruct cobalt_i2c_regs __iomem *regs = data->regs;\n\tstruct i2c_msg *pmsg;\n\tunsigned short flags;\n\tint ret = 0;\n\tint i, j;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint stop = (i == num - 1);\n\n\t\tpmsg = &msgs[i];\n\t\tflags = pmsg->flags;\n\n\t\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\t\tu8 addr = pmsg->addr << 1;\n\n\t\t\tif (flags & I2C_M_RD)\n\t\t\t\taddr |= 1;\n\t\t\tif (flags & I2C_M_REV_DIR_ADDR)\n\t\t\t\taddr ^= 1;\n\t\t\tfor (j = 0; j < adap->retries; j++) {\n\t\t\t\tret = cobalt_tx_bytes(regs, adap, true, false,\n\t\t\t\t\t\t      &addr, 1);\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\t\t\t\tcobalt_stop(regs, adap);\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = 0;\n\t\t}\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tret = cobalt_rx_bytes(regs, adap, false, stop,\n\t\t\t\t\tpmsg->buf, pmsg->len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bailout;\n\t\t} else {\n\t\t\t \n\t\t\tret = cobalt_tx_bytes(regs, adap, false, stop,\n\t\t\t\t\tpmsg->buf, pmsg->len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bailout;\n\t\t}\n\t}\n\tret = i;\n\nbailout:\n\tif (ret < 0)\n\t\tcobalt_stop(regs, adap);\n\treturn ret;\n}\n\nstatic u32 cobalt_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n \nstatic const struct i2c_adapter cobalt_i2c_adap_template = {\n\t.name = \"cobalt i2c driver\",\n\t.algo = NULL,                    \n\t.algo_data = NULL,               \n\t.owner = THIS_MODULE,\n};\n\nstatic const struct i2c_algorithm cobalt_algo = {\n\t.master_xfer\t= cobalt_xfer,\n\t.functionality\t= cobalt_func,\n};\n\n \nint cobalt_i2c_init(struct cobalt *cobalt)\n{\n\tint i, err;\n\tint status;\n\tint prescale;\n\tunsigned long start_time;\n\n\tcobalt_dbg(1, \"i2c init\\n\");\n\n\t \n\tprescale = ((ALT_CPU_FREQ) / (5 * I2C_FREQUENCY)) - 1;\n\n\tfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\n\t\tstruct cobalt_i2c_regs __iomem *regs =\n\t\t\tcobalt_i2c_regs(cobalt, i);\n\t\tstruct i2c_adapter *adap = &cobalt->i2c_adap[i];\n\n\t\t \n\t\tiowrite8(M00018_CTR_BITMAP_EN_MSK, &regs->cr_sr);\n\t\tiowrite8(0, &regs->ctr);\n\t\tiowrite8(0, &regs->cr_sr);\n\n\t\tstart_time = jiffies;\n\t\tdo {\n\t\t\tif (time_after(jiffies, start_time + HZ)) {\n\t\t\t\tif (cobalt_ignore_err) {\n\t\t\t\t\tadap->dev.parent = NULL;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tstatus = ioread8(&regs->cr_sr);\n\t\t} while (status & M00018_SR_BITMAP_TIP_MSK);\n\n\t\t \n\t\tiowrite8(0, &regs->ctr);\n\t\tiowrite8(0, &regs->cr_sr);\n\n\t\t \n\t\tiowrite8(prescale & 0xff, &regs->prerlo);\n\t\tiowrite8((prescale >> 8) & 0xff, &regs->prerhi);\n\t\t \n\t\tiowrite8(M00018_CTR_BITMAP_EN_MSK, &regs->ctr);\n\t\t \n\t\tcobalt->i2c_data[i].cobalt = cobalt;\n\t\tcobalt->i2c_data[i].regs = regs;\n\t\t*adap = cobalt_i2c_adap_template;\n\t\tadap->algo = &cobalt_algo;\n\t\tadap->algo_data = &cobalt->i2c_data[i];\n\t\tadap->retries = 3;\n\t\tsprintf(adap->name + strlen(adap->name),\n\t\t\t\t\" #%d-%d\", cobalt->instance, i);\n\t\ti2c_set_adapdata(adap, &cobalt->v4l2_dev);\n\t\tadap->dev.parent = &cobalt->pci_dev->dev;\n\t\terr = i2c_add_adapter(adap);\n\t\tif (err) {\n\t\t\tif (cobalt_ignore_err) {\n\t\t\t\tadap->dev.parent = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (i--)\n\t\t\t\ti2c_del_adapter(&cobalt->i2c_adap[i]);\n\t\t\treturn err;\n\t\t}\n\t\tcobalt_info(\"registered bus %s\\n\", adap->name);\n\t}\n\treturn 0;\n}\n\nvoid cobalt_i2c_exit(struct cobalt *cobalt)\n{\n\tint i;\n\n\tcobalt_dbg(1, \"i2c exit\\n\");\n\n\tfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\n\t\tcobalt_err(\"unregistered bus %s\\n\", cobalt->i2c_adap[i].name);\n\t\ti2c_del_adapter(&cobalt->i2c_adap[i]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}