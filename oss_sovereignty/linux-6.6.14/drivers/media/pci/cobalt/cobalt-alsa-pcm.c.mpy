{
  "module_name": "cobalt-alsa-pcm.c",
  "hash_id": "24198f7ba98da19547581ff3d02311844fe8c3f69bc97752c9c97757eba81c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-alsa-pcm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n#include <media/v4l2-device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"cobalt-driver.h\"\n#include \"cobalt-alsa.h\"\n#include \"cobalt-alsa-pcm.h\"\n\nstatic unsigned int pcm_debug;\nmodule_param(pcm_debug, int, 0644);\nMODULE_PARM_DESC(pcm_debug, \"enable debug messages for pcm\");\n\n#define dprintk(fmt, arg...) \\\n\tdo { \\\n\t\tif (pcm_debug) \\\n\t\t\tpr_info(\"cobalt-alsa-pcm %s: \" fmt, __func__, ##arg); \\\n\t} while (0)\n\nstatic const struct snd_pcm_hardware snd_cobalt_hdmi_capture = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP           |\n\t\tSNDRV_PCM_INFO_INTERLEAVED    |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 8,\n\t.buffer_bytes_max = 4 * 240 * 8 * 4,\t \n\t.period_bytes_min = 1920,\t\t \n\t.period_bytes_max = 240 * 8 * 4,\t \n\t.periods_min = 1,\n\t.periods_max = 4,\n};\n\nstatic const struct snd_pcm_hardware snd_cobalt_playback = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP           |\n\t\tSNDRV_PCM_INFO_INTERLEAVED    |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 8,\n\t.buffer_bytes_max = 4 * 240 * 8 * 4,\t \n\t.period_bytes_min = 1920,\t\t \n\t.period_bytes_max = 240 * 8 * 4,\t \n\t.periods_min = 1,\n\t.periods_max = 4,\n};\n\nstatic void sample_cpy(u8 *dst, const u8 *src, u32 len, bool is_s32)\n{\n\tstatic const unsigned map[8] = { 0, 1, 5, 4, 2, 3, 6, 7 };\n\tunsigned idx = 0;\n\n\twhile (len >= (is_s32 ? 4 : 2)) {\n\t\tunsigned offset = map[idx] * 4;\n\t\tu32 val = src[offset + 1] + (src[offset + 2] << 8) +\n\t\t\t (src[offset + 3] << 16);\n\n\t\tif (is_s32) {\n\t\t\t*dst++ = 0;\n\t\t\t*dst++ = val & 0xff;\n\t\t}\n\t\t*dst++ = (val >> 8) & 0xff;\n\t\t*dst++ = (val >> 16) & 0xff;\n\t\tlen -= is_s32 ? 4 : 2;\n\t\tidx++;\n\t}\n}\n\nstatic void cobalt_alsa_announce_pcm_data(struct snd_cobalt_card *cobsc,\n\t\t\t\t\tu8 *pcm_data,\n\t\t\t\t\tsize_t skip,\n\t\t\t\t\tsize_t samples)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tunsigned int oldptr;\n\tunsigned int stride;\n\tint length = samples;\n\tint period_elapsed = 0;\n\tbool is_s32;\n\n\tdprintk(\"cobalt alsa announce ptr=%p data=%p num_bytes=%zd\\n\", cobsc,\n\t\tpcm_data, samples);\n\n\tsubstream = cobsc->capture_pcm_substream;\n\tif (substream == NULL) {\n\t\tdprintk(\"substream was NULL\\n\");\n\t\treturn;\n\t}\n\n\truntime = substream->runtime;\n\tif (runtime == NULL) {\n\t\tdprintk(\"runtime was NULL\\n\");\n\t\treturn;\n\t}\n\tis_s32 = runtime->format == SNDRV_PCM_FORMAT_S32_LE;\n\n\tstride = runtime->frame_bits >> 3;\n\tif (stride == 0) {\n\t\tdprintk(\"stride is zero\\n\");\n\t\treturn;\n\t}\n\n\tif (length == 0) {\n\t\tdprintk(\"%s: length was zero\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (runtime->dma_area == NULL) {\n\t\tdprintk(\"dma area was NULL - ignoring\\n\");\n\t\treturn;\n\t}\n\n\toldptr = cobsc->hwptr_done_capture;\n\tif (oldptr + length >= runtime->buffer_size) {\n\t\tunsigned int cnt = runtime->buffer_size - oldptr;\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tsample_cpy(runtime->dma_area + (oldptr + i) * stride,\n\t\t\t\t\tpcm_data + i * skip,\n\t\t\t\t\tstride, is_s32);\n\t\tfor (i = cnt; i < length; i++)\n\t\t\tsample_cpy(runtime->dma_area + (i - cnt) * stride,\n\t\t\t\t\tpcm_data + i * skip, stride, is_s32);\n\t} else {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < length; i++)\n\t\t\tsample_cpy(runtime->dma_area + (oldptr + i) * stride,\n\t\t\t\t\tpcm_data + i * skip,\n\t\t\t\t\tstride, is_s32);\n\t}\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\tcobsc->hwptr_done_capture += length;\n\tif (cobsc->hwptr_done_capture >=\n\t    runtime->buffer_size)\n\t\tcobsc->hwptr_done_capture -=\n\t\t\truntime->buffer_size;\n\n\tcobsc->capture_transfer_done += length;\n\tif (cobsc->capture_transfer_done >=\n\t    runtime->period_size) {\n\t\tcobsc->capture_transfer_done -=\n\t\t\truntime->period_size;\n\t\tperiod_elapsed = 1;\n\t}\n\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int alsa_fnc(struct vb2_buffer *vb, void *priv)\n{\n\tstruct cobalt_stream *s = priv;\n\tunsigned char *p = vb2_plane_vaddr(vb, 0);\n\tint i;\n\n\tif (pcm_debug) {\n\t\tpr_info(\"alsa: \");\n\t\tfor (i = 0; i < 8 * 4; i++) {\n\t\t\tif (!(i & 3))\n\t\t\t\tpr_cont(\" \");\n\t\t\tpr_cont(\"%02x\", p[i]);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\tcobalt_alsa_announce_pcm_data(s->alsa,\n\t\t\tvb2_plane_vaddr(vb, 0),\n\t\t\t8 * 4,\n\t\t\tvb2_get_plane_payload(vb, 0) / (8 * 4));\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\tstruct cobalt_stream *s = cobsc->s;\n\n\truntime->hw = snd_cobalt_hdmi_capture;\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tcobsc->capture_pcm_substream = substream;\n\truntime->private_data = s;\n\tcobsc->alsa_record_cnt++;\n\tif (cobsc->alsa_record_cnt == 1) {\n\t\tint rc;\n\n\t\trc = vb2_thread_start(&s->q, alsa_fnc, s, s->vdev.name);\n\t\tif (rc) {\n\t\t\tcobsc->alsa_record_cnt--;\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\tstruct cobalt_stream *s = cobsc->s;\n\n\tcobsc->alsa_record_cnt--;\n\tif (cobsc->alsa_record_cnt == 0)\n\t\tvb2_thread_stop(&s->q);\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\n\tcobsc->hwptr_done_capture = 0;\n\tcobsc->capture_transfer_done = 0;\n\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic\nsnd_pcm_uframes_t snd_cobalt_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_uframes_t hwptr_done;\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\n\thwptr_done = cobsc->hwptr_done_capture;\n\n\treturn hwptr_done;\n}\n\nstatic void pb_sample_cpy(u8 *dst, const u8 *src, u32 len, bool is_s32)\n{\n\tstatic const unsigned map[8] = { 0, 1, 5, 4, 2, 3, 6, 7 };\n\tunsigned idx = 0;\n\n\twhile (len >= (is_s32 ? 4 : 2)) {\n\t\tunsigned offset = map[idx] * 4;\n\t\tu8 *out = dst + offset;\n\n\t\t*out++ = 0;\n\t\tif (is_s32) {\n\t\t\tsrc++;\n\t\t\t*out++ = *src++;\n\t\t} else {\n\t\t\t*out++ = 0;\n\t\t}\n\t\t*out++ = *src++;\n\t\t*out = *src++;\n\t\tlen -= is_s32 ? 4 : 2;\n\t\tidx++;\n\t}\n}\n\nstatic void cobalt_alsa_pb_pcm_data(struct snd_cobalt_card *cobsc,\n\t\t\t\t\tu8 *pcm_data,\n\t\t\t\t\tsize_t skip,\n\t\t\t\t\tsize_t samples)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tunsigned int pos;\n\tunsigned int stride;\n\tbool is_s32;\n\tunsigned i;\n\n\tdprintk(\"cobalt alsa pb ptr=%p data=%p samples=%zd\\n\", cobsc,\n\t\tpcm_data, samples);\n\n\tsubstream = cobsc->playback_pcm_substream;\n\tif (substream == NULL) {\n\t\tdprintk(\"substream was NULL\\n\");\n\t\treturn;\n\t}\n\n\truntime = substream->runtime;\n\tif (runtime == NULL) {\n\t\tdprintk(\"runtime was NULL\\n\");\n\t\treturn;\n\t}\n\n\tis_s32 = runtime->format == SNDRV_PCM_FORMAT_S32_LE;\n\tstride = runtime->frame_bits >> 3;\n\tif (stride == 0) {\n\t\tdprintk(\"stride is zero\\n\");\n\t\treturn;\n\t}\n\n\tif (samples == 0) {\n\t\tdprintk(\"%s: samples was zero\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (runtime->dma_area == NULL) {\n\t\tdprintk(\"dma area was NULL - ignoring\\n\");\n\t\treturn;\n\t}\n\n\tpos = cobsc->pb_pos % cobsc->pb_size;\n\tfor (i = 0; i < cobsc->pb_count / (8 * 4); i++)\n\t\tpb_sample_cpy(pcm_data + i * skip,\n\t\t\t\truntime->dma_area + pos + i * stride,\n\t\t\t\tstride, is_s32);\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\tcobsc->pb_pos += i * stride;\n\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tif (cobsc->pb_pos % cobsc->pb_count == 0)\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int alsa_pb_fnc(struct vb2_buffer *vb, void *priv)\n{\n\tstruct cobalt_stream *s = priv;\n\n\tif (s->alsa->alsa_pb_channel)\n\t\tcobalt_alsa_pb_pcm_data(s->alsa,\n\t\t\t\tvb2_plane_vaddr(vb, 0),\n\t\t\t\t8 * 4,\n\t\t\t\tvb2_get_plane_payload(vb, 0) / (8 * 4));\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cobalt_stream *s = cobsc->s;\n\n\truntime->hw = snd_cobalt_playback;\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tcobsc->playback_pcm_substream = substream;\n\truntime->private_data = s;\n\tcobsc->alsa_playback_cnt++;\n\tif (cobsc->alsa_playback_cnt == 1) {\n\t\tint rc;\n\n\t\trc = vb2_thread_start(&s->q, alsa_pb_fnc, s, s->vdev.name);\n\t\tif (rc) {\n\t\t\tcobsc->alsa_playback_cnt--;\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\tstruct cobalt_stream *s = cobsc->s;\n\n\tcobsc->alsa_playback_cnt--;\n\tif (cobsc->alsa_playback_cnt == 0)\n\t\tvb2_thread_stop(&s->q);\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_pb_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\n\tcobsc->pb_size = snd_pcm_lib_buffer_bytes(substream);\n\tcobsc->pb_count = snd_pcm_lib_period_bytes(substream);\n\tcobsc->pb_pos = 0;\n\n\treturn 0;\n}\n\nstatic int snd_cobalt_pcm_pb_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (cobsc->alsa_pb_channel)\n\t\t\treturn -EBUSY;\n\t\tcobsc->alsa_pb_channel = true;\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcobsc->alsa_pb_channel = false;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic\nsnd_pcm_uframes_t snd_cobalt_pcm_pb_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tptr = cobsc->pb_pos;\n\n\treturn bytes_to_frames(substream->runtime, ptr) %\n\t       substream->runtime->buffer_size;\n}\n\nstatic const struct snd_pcm_ops snd_cobalt_pcm_capture_ops = {\n\t.open\t\t= snd_cobalt_pcm_capture_open,\n\t.close\t\t= snd_cobalt_pcm_capture_close,\n\t.prepare\t= snd_cobalt_pcm_prepare,\n\t.trigger\t= snd_cobalt_pcm_trigger,\n\t.pointer\t= snd_cobalt_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cobalt_pcm_playback_ops = {\n\t.open\t\t= snd_cobalt_pcm_playback_open,\n\t.close\t\t= snd_cobalt_pcm_playback_close,\n\t.prepare\t= snd_cobalt_pcm_pb_prepare,\n\t.trigger\t= snd_cobalt_pcm_pb_trigger,\n\t.pointer\t= snd_cobalt_pcm_pb_pointer,\n};\n\nint snd_cobalt_pcm_create(struct snd_cobalt_card *cobsc)\n{\n\tstruct snd_pcm *sp;\n\tstruct snd_card *sc = cobsc->sc;\n\tstruct cobalt_stream *s = cobsc->s;\n\tstruct cobalt *cobalt = s->cobalt;\n\tint ret;\n\n\ts->q.gfp_flags |= __GFP_ZERO;\n\n\tif (!s->is_output) {\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\tCOBALT_SYS_CTRL_AUDIO_IPP_RESETN_BIT(s->video_channel),\n\t\t\t0);\n\t\tmdelay(2);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\tCOBALT_SYS_CTRL_AUDIO_IPP_RESETN_BIT(s->video_channel),\n\t\t\t1);\n\t\tmdelay(1);\n\n\t\tret = snd_pcm_new(sc, \"Cobalt PCM-In HDMI\",\n\t\t\t0,  \n\t\t\t0,  \n\t\t\t1,  \n\t\t\t&sp);\n\t\tif (ret) {\n\t\t\tcobalt_err(\"snd_cobalt_pcm_create() failed for input with err %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_cobalt_pcm_capture_ops);\n\t\tsnd_pcm_set_managed_buffer_all(sp, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t\t       NULL, 0, 0);\n\t\tsp->info_flags = 0;\n\t\tsp->private_data = cobsc;\n\t\tstrscpy(sp->name, \"cobalt\", sizeof(sp->name));\n\t} else {\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\tCOBALT_SYS_CTRL_AUDIO_OPP_RESETN_BIT, 0);\n\t\tmdelay(2);\n\t\tcobalt_s_bit_sysctrl(cobalt,\n\t\t\tCOBALT_SYS_CTRL_AUDIO_OPP_RESETN_BIT, 1);\n\t\tmdelay(1);\n\n\t\tret = snd_pcm_new(sc, \"Cobalt PCM-Out HDMI\",\n\t\t\t0,  \n\t\t\t1,  \n\t\t\t0,  \n\t\t\t&sp);\n\t\tif (ret) {\n\t\t\tcobalt_err(\"snd_cobalt_pcm_create() failed for output with err %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_cobalt_pcm_playback_ops);\n\t\tsnd_pcm_set_managed_buffer_all(sp, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t\t       NULL, 0, 0);\n\t\tsp->info_flags = 0;\n\t\tsp->private_data = cobsc;\n\t\tstrscpy(sp->name, \"cobalt\", sizeof(sp->name));\n\t}\n\n\treturn 0;\n\nerr_exit:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}