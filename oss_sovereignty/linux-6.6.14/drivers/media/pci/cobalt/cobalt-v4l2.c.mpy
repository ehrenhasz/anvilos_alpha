{
  "module_name": "cobalt-v4l2.c",
  "hash_id": "77d051fce8d759a11c2c6aebe099841c3a8851cd76642688468bc79ae510dd4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cobalt/cobalt-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/math64.h>\n#include <linux/pci.h>\n#include <linux/v4l2-dv-timings.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/i2c/adv7604.h>\n#include <media/i2c/adv7842.h>\n\n#include \"cobalt-alsa.h\"\n#include \"cobalt-cpld.h\"\n#include \"cobalt-driver.h\"\n#include \"cobalt-v4l2.h\"\n#include \"cobalt-irq.h\"\n#include \"cobalt-omnitek.h\"\n\nstatic const struct v4l2_dv_timings cea1080p60 = V4L2_DV_BT_CEA_1920X1080P60;\n\n \n\nstatic int cobalt_queue_setup(struct vb2_queue *q,\n\t\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cobalt_stream *s = q->drv_priv;\n\tunsigned size = s->stride * s->height;\n\n\tif (*num_buffers < 3)\n\t\t*num_buffers = 3;\n\tif (*num_buffers > NR_BUFS)\n\t\t*num_buffers = NR_BUFS;\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int cobalt_buf_init(struct vb2_buffer *vb)\n{\n\tstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\n\tstruct cobalt *cobalt = s->cobalt;\n\tconst size_t max_pages_per_line =\n\t\t(COBALT_MAX_WIDTH * COBALT_MAX_BPP) / PAGE_SIZE + 2;\n\tconst size_t bytes =\n\t\tCOBALT_MAX_HEIGHT * max_pages_per_line * 0x20;\n\tconst size_t audio_bytes = ((1920 * 4) / PAGE_SIZE + 1) * 0x20;\n\tstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\n\tstruct sg_table *sg_desc = vb2_dma_sg_plane_desc(vb, 0);\n\tunsigned size;\n\tint ret;\n\n\tsize = s->stride * s->height;\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tcobalt_info(\"data will not fit into plane (%lu < %u)\\n\",\n\t\t\t\t\tvb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->virt == NULL) {\n\t\tdesc->dev = &cobalt->pci_dev->dev;\n\t\tdescriptor_list_allocate(desc,\n\t\t\ts->is_audio ? audio_bytes : bytes);\n\t\tif (desc->virt == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\tret = descriptor_list_create(cobalt, sg_desc->sgl,\n\t\t\t!s->is_output, sg_desc->nents, size,\n\t\t\ts->width * s->bpp, s->stride, desc);\n\tif (ret)\n\t\tdescriptor_list_free(desc);\n\treturn ret;\n}\n\nstatic void cobalt_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\n\tstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\n\n\tdescriptor_list_free(desc);\n}\n\nstatic int cobalt_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\n\n\tvb2_set_plane_payload(vb, 0, s->stride * s->height);\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic void chain_all_buffers(struct cobalt_stream *s)\n{\n\tstruct sg_dma_desc_info *desc[NR_BUFS];\n\tstruct cobalt_buffer *cb;\n\tstruct list_head *p;\n\tint i = 0;\n\n\tlist_for_each(p, &s->bufs) {\n\t\tcb = list_entry(p, struct cobalt_buffer, list);\n\t\tdesc[i] = &s->dma_desc_info[cb->vb.vb2_buf.index];\n\t\tif (i > 0)\n\t\t\tdescriptor_list_chain(desc[i-1], desc[i]);\n\t\ti++;\n\t}\n}\n\nstatic void cobalt_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct cobalt_stream *s = q->drv_priv;\n\tstruct cobalt_buffer *cb = to_cobalt_buffer(vbuf);\n\tstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\n\tunsigned long flags;\n\n\t \n\tdescriptor_list_loopback(desc);\n\tdescriptor_list_interrupt_disable(desc);\n\n\tspin_lock_irqsave(&s->irqlock, flags);\n\tlist_add_tail(&cb->list, &s->bufs);\n\tchain_all_buffers(s);\n\tspin_unlock_irqrestore(&s->irqlock, flags);\n}\n\nstatic void cobalt_enable_output(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\tstruct v4l2_bt_timings *bt = &s->timings.bt;\n\tstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\n\t\tCOBALT_TX_BASE(cobalt);\n\tunsigned fmt = s->pixfmt != V4L2_PIX_FMT_BGR32 ?\n\t\t\tM00514_CONTROL_BITMAP_FORMAT_16_BPP_MSK : 0;\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tu64 clk = bt->pixelclock;\n\n\tif (bt->flags & V4L2_DV_FL_REDUCED_FPS)\n\t\tclk = div_u64(clk * 1000ULL, 1001);\n\tif (!cobalt_cpld_set_freq(cobalt, clk)) {\n\t\tcobalt_err(\"pixelclock out of range\\n\");\n\t\treturn;\n\t}\n\n\tsd_fmt.format.colorspace = s->colorspace;\n\tsd_fmt.format.xfer_func = s->xfer_func;\n\tsd_fmt.format.ycbcr_enc = s->ycbcr_enc;\n\tsd_fmt.format.quantization = s->quantization;\n\tsd_fmt.format.width = bt->width;\n\tsd_fmt.format.height = bt->height;\n\n\t \n\tswitch (s->pixfmt) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tsd_fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tsd_fmt.format.code = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\t}\n\tv4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);\n\n\tiowrite32(0, &vo->control);\n\t \n\tiowrite32(bt->hsync, &vo->sync_generator_h_sync_length);\n\tiowrite32(bt->hbackporch, &vo->sync_generator_h_backporch_length);\n\tiowrite32(bt->width, &vo->sync_generator_h_active_length);\n\tiowrite32(bt->hfrontporch, &vo->sync_generator_h_frontporch_length);\n\tiowrite32(bt->vsync, &vo->sync_generator_v_sync_length);\n\tiowrite32(bt->vbackporch, &vo->sync_generator_v_backporch_length);\n\tiowrite32(bt->height, &vo->sync_generator_v_active_length);\n\tiowrite32(bt->vfrontporch, &vo->sync_generator_v_frontporch_length);\n\tiowrite32(0x9900c1, &vo->error_color);\n\n\tiowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_LOAD_PARAM_MSK | fmt,\n\t\t  &vo->control);\n\tiowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK | fmt, &vo->control);\n\tiowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_ENABLE_MSK |\n\t\t  M00514_CONTROL_BITMAP_FLOW_CTRL_OUTPUT_ENABLE_MSK |\n\t\t  fmt, &vo->control);\n}\n\nstatic void cobalt_enable_input(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\tint ch = (int)s->video_channel;\n\tstruct m00235_fdma_packer_regmap __iomem *packer;\n\tstruct v4l2_subdev_format sd_fmt_yuyv = {\n\t\t.pad = s->pad_source,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t};\n\tstruct v4l2_subdev_format sd_fmt_rgb = {\n\t\t.pad = s->pad_source,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format.code = MEDIA_BUS_FMT_RGB888_1X24,\n\t};\n\n\tcobalt_dbg(1, \"video_channel %d (%s, %s)\\n\",\n\t\t   s->video_channel,\n\t\t   s->input == 0 ? \"hdmi\" : \"generator\",\n\t\t   \"YUYV\");\n\n\tpacker = COBALT_CVI_PACKER(cobalt, ch);\n\n\t \n\tswitch (s->pixfmt) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tiowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\n\t\t\t  (1 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\n\t\t\t  &packer->control);\n\t\tv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\n\t\t\t\t &sd_fmt_yuyv);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tiowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\n\t\t\t  (2 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\n\t\t\t  &packer->control);\n\t\tv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\n\t\t\t\t &sd_fmt_rgb);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tiowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\n\t\t\t  M00235_CONTROL_BITMAP_ENDIAN_FORMAT_MSK |\n\t\t\t  (3 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\n\t\t\t  &packer->control);\n\t\tv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\n\t\t\t\t &sd_fmt_rgb);\n\t\tbreak;\n\t}\n}\n\nstatic void cobalt_dma_start_streaming(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\tint rx = s->video_channel;\n\tstruct m00460_evcnt_regmap __iomem *evcnt =\n\t\tCOBALT_CVI_EVCNT(cobalt, rx);\n\tstruct cobalt_buffer *cb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->irqlock, flags);\n\tif (!s->is_output) {\n\t\tiowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);\n\t\tiowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);\n\t} else {\n\t\tstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\n\t\t\tCOBALT_TX_BASE(cobalt);\n\t\tu32 ctrl = ioread32(&vo->control);\n\n\t\tctrl &= ~(M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK |\n\t\t\t  M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK);\n\t\tiowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK,\n\t\t\t  &vo->control);\n\t\tiowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK,\n\t\t\t  &vo->control);\n\t}\n\tcb = list_first_entry(&s->bufs, struct cobalt_buffer, list);\n\tomni_sg_dma_start(s, &s->dma_desc_info[cb->vb.vb2_buf.index]);\n\tspin_unlock_irqrestore(&s->irqlock, flags);\n}\n\nstatic int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cobalt_stream *s = q->drv_priv;\n\tstruct cobalt *cobalt = s->cobalt;\n\tstruct m00233_video_measure_regmap __iomem *vmr;\n\tstruct m00473_freewheel_regmap __iomem *fw;\n\tstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\n\tint rx = s->video_channel;\n\tstruct m00389_cvi_regmap __iomem *cvi = COBALT_CVI(cobalt, rx);\n\tstruct m00460_evcnt_regmap __iomem *evcnt = COBALT_CVI_EVCNT(cobalt, rx);\n\tstruct v4l2_bt_timings *bt = &s->timings.bt;\n\tu64 tot_size;\n\tu32 clk_freq;\n\n\tif (s->is_audio)\n\t\tgoto done;\n\tif (s->is_output) {\n\t\ts->unstable_frame = false;\n\t\tcobalt_enable_output(s);\n\t\tgoto done;\n\t}\n\n\tcobalt_enable_input(s);\n\n\tfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\n\tvmr = COBALT_CVI_VMR(cobalt, rx);\n\tclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\n\n\tiowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);\n\tiowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);\n\tiowrite32(bt->width, &cvi->frame_width);\n\tiowrite32(bt->height, &cvi->frame_height);\n\ttot_size = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);\n\tiowrite32(div_u64((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4,\n\t\t\t  bt->pixelclock), &vmr->hsync_timeout_val);\n\tiowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\n\tclk_freq = ioread32(&fw->clk_freq);\n\tiowrite32(clk_freq / 1000000, &clkloss->ref_clk_cnt_val);\n\t \n\tiowrite32(div_u64(bt->pixelclock * 995, 1000000000),\n\t\t  &clkloss->test_clk_cnt_val);\n\t \n\tiowrite32(bt->width * bt->height, &fw->active_length);\n\tiowrite32(div_u64((u64)clk_freq * tot_size, bt->pixelclock),\n\t\t  &fw->total_length);\n\tiowrite32(M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |\n\t\t  M00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK,\n\t\t  &vmr->irq_triggers);\n\tiowrite32(0, &cvi->control);\n\tiowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\n\n\tiowrite32(0xff, &fw->output_color);\n\tiowrite32(M00479_CTRL_BITMAP_ENABLE_MSK, &clkloss->ctrl);\n\tiowrite32(M00473_CTRL_BITMAP_ENABLE_MSK |\n\t\t  M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK, &fw->ctrl);\n\ts->unstable_frame = true;\n\ts->enable_freewheel = false;\n\ts->enable_cvi = false;\n\ts->skip_first_frames = 0;\n\ndone:\n\ts->sequence = 0;\n\tcobalt_dma_start_streaming(s);\n\treturn 0;\n}\n\nstatic void cobalt_dma_stop_streaming(struct cobalt_stream *s)\n{\n\tstruct cobalt *cobalt = s->cobalt;\n\tstruct sg_dma_desc_info *desc;\n\tstruct cobalt_buffer *cb;\n\tstruct list_head *p;\n\tunsigned long flags;\n\tint timeout_msec = 100;\n\tint rx = s->video_channel;\n\tstruct m00460_evcnt_regmap __iomem *evcnt =\n\t\tCOBALT_CVI_EVCNT(cobalt, rx);\n\n\tif (!s->is_output) {\n\t\tiowrite32(0, &evcnt->control);\n\t} else if (!s->is_audio) {\n\t\tstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\n\t\t\tCOBALT_TX_BASE(cobalt);\n\n\t\tiowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK, &vo->control);\n\t\tiowrite32(0, &vo->control);\n\t}\n\n\t \n\tspin_lock_irqsave(&s->irqlock, flags);\n\tlist_for_each(p, &s->bufs) {\n\t\tcb = list_entry(p, struct cobalt_buffer, list);\n\t\tdesc = &s->dma_desc_info[cb->vb.vb2_buf.index];\n\t\t \n\t\tdescriptor_list_end_of_chain(desc);\n\t}\n\tspin_unlock_irqrestore(&s->irqlock, flags);\n\n\t \n\tif (!wait_event_timeout(s->q.done_wq, is_dma_done(s),\n\t\t\t\tmsecs_to_jiffies(timeout_msec))) {\n\t\tomni_sg_dma_abort_channel(s);\n\t\tpr_warn(\"aborted\\n\");\n\t}\n\tcobalt_write_bar0(cobalt, DMA_INTERRUPT_STATUS_REG,\n\t\t\t1 << s->dma_channel);\n}\n\nstatic void cobalt_stop_streaming(struct vb2_queue *q)\n{\n\tstruct cobalt_stream *s = q->drv_priv;\n\tstruct cobalt *cobalt = s->cobalt;\n\tint rx = s->video_channel;\n\tstruct m00233_video_measure_regmap __iomem *vmr;\n\tstruct m00473_freewheel_regmap __iomem *fw;\n\tstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\n\tstruct cobalt_buffer *cb;\n\tstruct list_head *p, *safe;\n\tunsigned long flags;\n\n\tcobalt_dma_stop_streaming(s);\n\n\t \n\tspin_lock_irqsave(&s->irqlock, flags);\n\tlist_for_each_safe(p, safe, &s->bufs) {\n\t\tcb = list_entry(p, struct cobalt_buffer, list);\n\t\tlist_del(&cb->list);\n\t\tvb2_buffer_done(&cb->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&s->irqlock, flags);\n\n\tif (s->is_audio || s->is_output)\n\t\treturn;\n\n\tfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\n\tvmr = COBALT_CVI_VMR(cobalt, rx);\n\tclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\n\tiowrite32(0, &vmr->control);\n\tiowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\n\tiowrite32(0, &fw->ctrl);\n\tiowrite32(0, &clkloss->ctrl);\n}\n\nstatic const struct vb2_ops cobalt_qops = {\n\t.queue_setup = cobalt_queue_setup,\n\t.buf_init = cobalt_buf_init,\n\t.buf_cleanup = cobalt_buf_cleanup,\n\t.buf_prepare = cobalt_buf_prepare,\n\t.buf_queue = cobalt_buf_queue,\n\t.start_streaming = cobalt_start_streaming,\n\t.stop_streaming = cobalt_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int cobalt_cobaltc(struct cobalt *cobalt, unsigned int cmd, void *arg)\n{\n\tstruct v4l2_dbg_register *regs = arg;\n\tvoid __iomem *adrs = cobalt->bar1 + regs->reg;\n\n\tcobalt_info(\"cobalt_cobaltc: adrs = %p\\n\", adrs);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tregs->size = 4;\n\tif (cmd == VIDIOC_DBG_S_REGISTER)\n\t\tiowrite32(regs->val, adrs);\n\telse\n\t\tregs->val = ioread32(adrs);\n\treturn 0;\n}\n\nstatic int cobalt_g_register(struct file *file, void *priv_fh,\n\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct cobalt *cobalt = s->cobalt;\n\n\treturn cobalt_cobaltc(cobalt, VIDIOC_DBG_G_REGISTER, reg);\n}\n\nstatic int cobalt_s_register(struct file *file, void *priv_fh,\n\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct cobalt *cobalt = s->cobalt;\n\n\treturn cobalt_cobaltc(cobalt, VIDIOC_DBG_S_REGISTER,\n\t\t\t(struct v4l2_dbg_register *)reg);\n}\n#endif\n\nstatic int cobalt_querycap(struct file *file, void *priv_fh,\n\t\t\t\tstruct v4l2_capability *vcap)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct cobalt *cobalt = s->cobalt;\n\n\tstrscpy(vcap->driver, \"cobalt\", sizeof(vcap->driver));\n\tstrscpy(vcap->card, \"cobalt\", sizeof(vcap->card));\n\tsnprintf(vcap->bus_info, sizeof(vcap->bus_info),\n\t\t \"PCIe:%s\", pci_name(cobalt->pci_dev));\n\tvcap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_DEVICE_CAPS;\n\tif (cobalt->have_hsma_tx)\n\t\tvcap->capabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\treturn 0;\n}\n\nstatic void cobalt_video_input_status_show(struct cobalt_stream *s)\n{\n\tstruct m00389_cvi_regmap __iomem *cvi;\n\tstruct m00233_video_measure_regmap __iomem *vmr;\n\tstruct m00473_freewheel_regmap __iomem *fw;\n\tstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\n\tstruct m00235_fdma_packer_regmap __iomem *packer;\n\tint rx = s->video_channel;\n\tstruct cobalt *cobalt = s->cobalt;\n\tu32 cvi_ctrl, cvi_stat;\n\tu32 vmr_ctrl, vmr_stat;\n\n\tcvi = COBALT_CVI(cobalt, rx);\n\tvmr = COBALT_CVI_VMR(cobalt, rx);\n\tfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\n\tclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\n\tpacker = COBALT_CVI_PACKER(cobalt, rx);\n\tcvi_ctrl = ioread32(&cvi->control);\n\tcvi_stat = ioread32(&cvi->status);\n\tvmr_ctrl = ioread32(&vmr->control);\n\tvmr_stat = ioread32(&vmr->status);\n\tcobalt_info(\"rx%d: cvi resolution: %dx%d\\n\", rx,\n\t\t    ioread32(&cvi->frame_width), ioread32(&cvi->frame_height));\n\tcobalt_info(\"rx%d: cvi control: %s%s%s\\n\", rx,\n\t\t(cvi_ctrl & M00389_CONTROL_BITMAP_ENABLE_MSK) ?\n\t\t\t\"enable \" : \"disable \",\n\t\t(cvi_ctrl & M00389_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?\n\t\t\t\"HSync- \" : \"HSync+ \",\n\t\t(cvi_ctrl & M00389_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?\n\t\t\t\"VSync- \" : \"VSync+ \");\n\tcobalt_info(\"rx%d: cvi status: %s%s\\n\", rx,\n\t\t(cvi_stat & M00389_STATUS_BITMAP_LOCK_MSK) ?\n\t\t\t\"lock \" : \"no-lock \",\n\t\t(cvi_stat & M00389_STATUS_BITMAP_ERROR_MSK) ?\n\t\t\t\"error \" : \"no-error \");\n\n\tcobalt_info(\"rx%d: Measurements: %s%s%s%s%s%s%s\\n\", rx,\n\t\t(vmr_ctrl & M00233_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?\n\t\t\t\"HSync- \" : \"HSync+ \",\n\t\t(vmr_ctrl & M00233_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?\n\t\t\t\"VSync- \" : \"VSync+ \",\n\t\t(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK) ?\n\t\t\t\"enabled \" : \"disabled \",\n\t\t(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK) ?\n\t\t\t\"irq-enabled \" : \"irq-disabled \",\n\t\t(vmr_ctrl & M00233_CONTROL_BITMAP_UPDATE_ON_HSYNC_MSK) ?\n\t\t\t\"update-on-hsync \" : \"\",\n\t\t(vmr_stat & M00233_STATUS_BITMAP_HSYNC_TIMEOUT_MSK) ?\n\t\t\t\"hsync-timeout \" : \"\",\n\t\t(vmr_stat & M00233_STATUS_BITMAP_INIT_DONE_MSK) ?\n\t\t\t\"init-done\" : \"\");\n\tcobalt_info(\"rx%d: irq_status: 0x%02x irq_triggers: 0x%02x\\n\", rx,\n\t\t\tioread32(&vmr->irq_status) & 0xff,\n\t\t\tioread32(&vmr->irq_triggers) & 0xff);\n\tcobalt_info(\"rx%d: vsync: %d\\n\", rx, ioread32(&vmr->vsync_time));\n\tcobalt_info(\"rx%d: vbp: %d\\n\", rx, ioread32(&vmr->vback_porch));\n\tcobalt_info(\"rx%d: vact: %d\\n\", rx, ioread32(&vmr->vactive_area));\n\tcobalt_info(\"rx%d: vfb: %d\\n\", rx, ioread32(&vmr->vfront_porch));\n\tcobalt_info(\"rx%d: hsync: %d\\n\", rx, ioread32(&vmr->hsync_time));\n\tcobalt_info(\"rx%d: hbp: %d\\n\", rx, ioread32(&vmr->hback_porch));\n\tcobalt_info(\"rx%d: hact: %d\\n\", rx, ioread32(&vmr->hactive_area));\n\tcobalt_info(\"rx%d: hfb: %d\\n\", rx, ioread32(&vmr->hfront_porch));\n\tcobalt_info(\"rx%d: Freewheeling: %s%s%s\\n\", rx,\n\t\t(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_ENABLE_MSK) ?\n\t\t\t\"enabled \" : \"disabled \",\n\t\t(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK) ?\n\t\t\t\"forced \" : \"\",\n\t\t(ioread32(&fw->status) & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) ?\n\t\t\t\"freewheeling \" : \"video-passthrough \");\n\tiowrite32(0xff, &vmr->irq_status);\n\tcobalt_info(\"rx%d: Clock Loss Detection: %s%s\\n\", rx,\n\t\t(ioread32(&clkloss->ctrl) & M00479_CTRL_BITMAP_ENABLE_MSK) ?\n\t\t\t\"enabled \" : \"disabled \",\n\t\t(ioread32(&clkloss->status) & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?\n\t\t\t\"clock-missing \" : \"found-clock \");\n\tcobalt_info(\"rx%d: Packer: %x\\n\", rx, ioread32(&packer->control));\n}\n\nstatic int cobalt_log_status(struct file *file, void *priv_fh)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct cobalt *cobalt = s->cobalt;\n\tstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\n\t\tCOBALT_TX_BASE(cobalt);\n\tu8 stat;\n\n\tcobalt_info(\"%s\", cobalt->hdl_info);\n\tcobalt_info(\"sysctrl: %08x, sysstat: %08x\\n\",\n\t\t\tcobalt_g_sysctrl(cobalt),\n\t\t\tcobalt_g_sysstat(cobalt));\n\tcobalt_info(\"dma channel: %d, video channel: %d\\n\",\n\t\t\ts->dma_channel, s->video_channel);\n\tcobalt_pcie_status_show(cobalt);\n\tcobalt_cpld_status(cobalt);\n\tcobalt_irq_log_status(cobalt);\n\tv4l2_subdev_call(s->sd, core, log_status);\n\tif (!s->is_output) {\n\t\tcobalt_video_input_status_show(s);\n\t\treturn 0;\n\t}\n\n\tstat = ioread32(&vo->rd_status);\n\n\tcobalt_info(\"tx: status: %s%s\\n\",\n\t\t(stat & M00514_RD_STATUS_BITMAP_FLOW_CTRL_NO_DATA_ERROR_MSK) ?\n\t\t\t\"no_data \" : \"\",\n\t\t(stat & M00514_RD_STATUS_BITMAP_READY_BUFFER_FULL_MSK) ?\n\t\t\t\"ready_buffer_full \" : \"\");\n\tcobalt_info(\"tx: evcnt: %d\\n\", ioread32(&vo->rd_evcnt_count));\n\treturn 0;\n}\n\nstatic int cobalt_enum_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\t    struct v4l2_enum_dv_timings *timings)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tif (s->input == 1) {\n\t\tif (timings->index)\n\t\t\treturn -EINVAL;\n\t\tmemset(timings->reserved, 0, sizeof(timings->reserved));\n\t\ttimings->timings = cea1080p60;\n\t\treturn 0;\n\t}\n\ttimings->pad = 0;\n\treturn v4l2_subdev_call(s->sd,\n\t\t\tpad, enum_dv_timings, timings);\n}\n\nstatic int cobalt_s_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tint err;\n\n\tif (s->input == 1) {\n\t\t*timings = cea1080p60;\n\t\treturn 0;\n\t}\n\n\tif (v4l2_match_dv_timings(timings, &s->timings, 0, true))\n\t\treturn 0;\n\n\tif (vb2_is_busy(&s->q))\n\t\treturn -EBUSY;\n\n\terr = v4l2_subdev_call(s->sd,\n\t\t\tvideo, s_dv_timings, timings);\n\tif (!err) {\n\t\ts->timings = *timings;\n\t\ts->width = timings->bt.width;\n\t\ts->height = timings->bt.height;\n\t\ts->stride = timings->bt.width * s->bpp;\n\t}\n\treturn err;\n}\n\nstatic int cobalt_g_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tif (s->input == 1) {\n\t\t*timings = cea1080p60;\n\t\treturn 0;\n\t}\n\treturn v4l2_subdev_call(s->sd,\n\t\t\tvideo, g_dv_timings, timings);\n}\n\nstatic int cobalt_query_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tif (s->input == 1) {\n\t\t*timings = cea1080p60;\n\t\treturn 0;\n\t}\n\treturn v4l2_subdev_call(s->sd,\n\t\t\tvideo, query_dv_timings, timings);\n}\n\nstatic int cobalt_dv_timings_cap(struct file *file, void *priv_fh,\n\t\t\t\t    struct v4l2_dv_timings_cap *cap)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tcap->pad = 0;\n\treturn v4l2_subdev_call(s->sd,\n\t\t\tpad, dv_timings_cap, cap);\n}\n\nstatic int cobalt_enum_fmt_vid_cap(struct file *file, void *priv_fh,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tswitch (f->index) {\n\tcase 0:\n\t\tf->pixelformat = V4L2_PIX_FMT_YUYV;\n\t\tbreak;\n\tcase 1:\n\t\tf->pixelformat = V4L2_PIX_FMT_RGB24;\n\t\tbreak;\n\tcase 2:\n\t\tf->pixelformat = V4L2_PIX_FMT_BGR32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cobalt_g_fmt_vid_cap(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tpix->width = s->width;\n\tpix->height = s->height;\n\tpix->bytesperline = s->stride;\n\tpix->field = V4L2_FIELD_NONE;\n\n\tif (s->input == 1) {\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t} else {\n\t\tstruct v4l2_subdev_format sd_fmt = {\n\t\t\t.pad = s->pad_source,\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tv4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);\n\t\tv4l2_fill_pix_format(pix, &sd_fmt.format);\n\t}\n\n\tpix->pixelformat = s->pixfmt;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\n\treturn 0;\n}\n\nstatic int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\t \n\tif ((pix->width < 176) || (pix->height < 144)) {\n\t\tpix->width = 176;\n\t\tpix->height = 144;\n\t}\n\n\tif ((pix->width > 1920) || (pix->height > 1080)) {\n\t\tpix->width = 1920;\n\t\tpix->height = 1080;\n\t}\n\n\t \n\tpix->width &= ~0x3;\n\n\t \n\tpix->height &= ~0x1;\n\n\tif (s->input == 1) {\n\t\t \n\t\tpix->width = 1920;\n\t\tpix->height = 1080;\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t} else {\n\t\tstruct v4l2_subdev_format sd_fmt = {\n\t\t\t.pad = s->pad_source,\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tv4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);\n\t\tv4l2_fill_pix_format(pix, &sd_fmt.format);\n\t}\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tpix->bytesperline = max(pix->bytesperline & ~0x3,\n\t\t\t\tpix->width * COBALT_BYTES_PER_PIXEL_YUYV);\n\t\tpix->pixelformat = V4L2_PIX_FMT_YUYV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tpix->bytesperline = max(pix->bytesperline & ~0x3,\n\t\t\t\tpix->width * COBALT_BYTES_PER_PIXEL_RGB24);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tpix->bytesperline = max(pix->bytesperline & ~0x3,\n\t\t\t\tpix->width * COBALT_BYTES_PER_PIXEL_RGB32);\n\t\tbreak;\n\t}\n\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int cobalt_s_fmt_vid_cap(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tif (vb2_is_busy(&s->q))\n\t\treturn -EBUSY;\n\n\tif (cobalt_try_fmt_vid_cap(file, priv_fh, f))\n\t\treturn -EINVAL;\n\n\ts->width = pix->width;\n\ts->height = pix->height;\n\ts->stride = pix->bytesperline;\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_RGB24;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\ts->pixfmt = pix->pixelformat;\n\tcobalt_enable_input(s);\n\n\treturn 0;\n}\n\nstatic int cobalt_try_fmt_vid_out(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\t \n\tif ((pix->width < 176) || (pix->height < 144)) {\n\t\tpix->width = 176;\n\t\tpix->height = 144;\n\t}\n\n\tif ((pix->width > 1920) || (pix->height > 1080)) {\n\t\tpix->width = 1920;\n\t\tpix->height = 1080;\n\t}\n\n\t \n\tpix->width &= ~0x3;\n\n\t \n\tpix->height &= ~0x1;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tpix->bytesperline = max(pix->bytesperline & ~0x3,\n\t\t\t\tpix->width * COBALT_BYTES_PER_PIXEL_YUYV);\n\t\tpix->pixelformat = V4L2_PIX_FMT_YUYV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tpix->bytesperline = max(pix->bytesperline & ~0x3,\n\t\t\t\tpix->width * COBALT_BYTES_PER_PIXEL_RGB32);\n\t\tbreak;\n\t}\n\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int cobalt_g_fmt_vid_out(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tpix->width = s->width;\n\tpix->height = s->height;\n\tpix->bytesperline = s->stride;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = s->pixfmt;\n\tpix->colorspace = s->colorspace;\n\tpix->xfer_func = s->xfer_func;\n\tpix->ycbcr_enc = s->ycbcr_enc;\n\tpix->quantization = s->quantization;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\n\treturn 0;\n}\n\nstatic int cobalt_enum_fmt_vid_out(struct file *file, void *priv_fh,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tswitch (f->index) {\n\tcase 0:\n\t\tf->pixelformat = V4L2_PIX_FMT_YUYV;\n\t\tbreak;\n\tcase 1:\n\t\tf->pixelformat = V4L2_PIX_FMT_BGR32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,\n\t\tstruct v4l2_format *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tu32 code;\n\n\tif (cobalt_try_fmt_vid_out(file, priv_fh, f))\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(&s->q) && (pix->pixelformat != s->pixfmt ||\n\t    pix->width != s->width || pix->height != s->height ||\n\t    pix->bytesperline != s->stride))\n\t\treturn -EBUSY;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\n\t\tcode = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\n\t\tcode = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\ts->width = pix->width;\n\ts->height = pix->height;\n\ts->stride = pix->bytesperline;\n\ts->pixfmt = pix->pixelformat;\n\ts->colorspace = pix->colorspace;\n\ts->xfer_func = pix->xfer_func;\n\ts->ycbcr_enc = pix->ycbcr_enc;\n\ts->quantization = pix->quantization;\n\tv4l2_fill_mbus_format(&sd_fmt.format, pix, code);\n\tv4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);\n\treturn 0;\n}\n\nstatic int cobalt_enum_input(struct file *file, void *priv_fh,\n\t\t\t\t struct v4l2_input *inp)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tif (inp->index > 1)\n\t\treturn -EINVAL;\n\tif (inp->index == 0)\n\t\tsnprintf(inp->name, sizeof(inp->name),\n\t\t\t\t\"HDMI-%d\", s->video_channel);\n\telse\n\t\tsnprintf(inp->name, sizeof(inp->name),\n\t\t\t\t\"Generator-%d\", s->video_channel);\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->capabilities = V4L2_IN_CAP_DV_TIMINGS;\n\tif (inp->index == 1)\n\t\treturn 0;\n\treturn v4l2_subdev_call(s->sd,\n\t\t\tvideo, g_input_status, &inp->status);\n}\n\nstatic int cobalt_g_input(struct file *file, void *priv_fh, unsigned int *i)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\t*i = s->input;\n\treturn 0;\n}\n\nstatic int cobalt_s_input(struct file *file, void *priv_fh, unsigned int i)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\n\tif (i >= 2)\n\t\treturn -EINVAL;\n\tif (vb2_is_busy(&s->q))\n\t\treturn -EBUSY;\n\ts->input = i;\n\n\tcobalt_enable_input(s);\n\n\tif (s->input == 1)  \n\t\treturn 0;\n\n\treturn v4l2_subdev_call(s->sd, video, s_routing,\n\t\t\tADV76XX_PAD_HDMI_PORT_A, 0, 0);\n}\n\nstatic int cobalt_enum_output(struct file *file, void *priv_fh,\n\t\t\t\t struct v4l2_output *out)\n{\n\tif (out->index)\n\t\treturn -EINVAL;\n\tsnprintf(out->name, sizeof(out->name), \"HDMI-%d\", out->index);\n\tout->type = V4L2_OUTPUT_TYPE_ANALOG;\n\tout->capabilities = V4L2_OUT_CAP_DV_TIMINGS;\n\treturn 0;\n}\n\nstatic int cobalt_g_output(struct file *file, void *priv_fh, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int cobalt_s_output(struct file *file, void *priv_fh, unsigned int i)\n{\n\treturn i ? -EINVAL : 0;\n}\n\nstatic int cobalt_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tu32 pad = edid->pad;\n\tint ret;\n\n\tif (edid->pad >= (s->is_output ? 1 : 2))\n\t\treturn -EINVAL;\n\tedid->pad = 0;\n\tret = v4l2_subdev_call(s->sd, pad, get_edid, edid);\n\tedid->pad = pad;\n\treturn ret;\n}\n\nstatic int cobalt_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tu32 pad = edid->pad;\n\tint ret;\n\n\tif (edid->pad >= 2)\n\t\treturn -EINVAL;\n\tedid->pad = 0;\n\tret = v4l2_subdev_call(s->sd, pad, set_edid, edid);\n\tedid->pad = pad;\n\treturn ret;\n}\n\nstatic int cobalt_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_event_subscribe(fh, sub, 4, NULL);\n\t}\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\n\nstatic int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_fract fps;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tfps = v4l2_calc_timeperframe(&s->timings);\n\ta->parm.capture.timeperframe.numerator = fps.numerator;\n\ta->parm.capture.timeperframe.denominator = fps.denominator;\n\ta->parm.capture.readbuffers = 3;\n\treturn 0;\n}\n\nstatic int cobalt_g_pixelaspect(struct file *file, void *fh,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_dv_timings timings;\n\tint err = 0;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (s->input == 1)\n\t\ttimings = cea1080p60;\n\telse\n\t\terr = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);\n\tif (!err)\n\t\t*f = v4l2_dv_timings_aspect_ratio(&timings);\n\treturn err;\n}\n\nstatic int cobalt_g_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct cobalt_stream *s = video_drvdata(file);\n\tstruct v4l2_dv_timings timings;\n\tint err = 0;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (s->input == 1)\n\t\ttimings = cea1080p60;\n\telse\n\t\terr = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);\n\n\tif (err)\n\t\treturn err;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = timings.bt.width;\n\t\tsel->r.height = timings.bt.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops cobalt_ioctl_ops = {\n\t.vidioc_querycap\t\t= cobalt_querycap,\n\t.vidioc_g_parm\t\t\t= cobalt_g_parm,\n\t.vidioc_log_status\t\t= cobalt_log_status,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_g_pixelaspect\t\t= cobalt_g_pixelaspect,\n\t.vidioc_g_selection\t\t= cobalt_g_selection,\n\t.vidioc_enum_input\t\t= cobalt_enum_input,\n\t.vidioc_g_input\t\t\t= cobalt_g_input,\n\t.vidioc_s_input\t\t\t= cobalt_s_input,\n\t.vidioc_enum_fmt_vid_cap\t= cobalt_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= cobalt_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= cobalt_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= cobalt_try_fmt_vid_cap,\n\t.vidioc_enum_output\t\t= cobalt_enum_output,\n\t.vidioc_g_output\t\t= cobalt_g_output,\n\t.vidioc_s_output\t\t= cobalt_s_output,\n\t.vidioc_enum_fmt_vid_out\t= cobalt_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t= cobalt_g_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= cobalt_s_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= cobalt_try_fmt_vid_out,\n\t.vidioc_s_dv_timings\t\t= cobalt_s_dv_timings,\n\t.vidioc_g_dv_timings\t\t= cobalt_g_dv_timings,\n\t.vidioc_query_dv_timings\t= cobalt_query_dv_timings,\n\t.vidioc_enum_dv_timings\t\t= cobalt_enum_dv_timings,\n\t.vidioc_dv_timings_cap\t\t= cobalt_dv_timings_cap,\n\t.vidioc_g_edid\t\t\t= cobalt_g_edid,\n\t.vidioc_s_edid\t\t\t= cobalt_s_edid,\n\t.vidioc_subscribe_event\t\t= cobalt_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register              = cobalt_g_register,\n\t.vidioc_s_register              = cobalt_s_register,\n#endif\n};\n\nstatic const struct v4l2_ioctl_ops cobalt_ioctl_empty_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register              = cobalt_g_register,\n\t.vidioc_s_register              = cobalt_s_register,\n#endif\n};\n\n \n\nstatic const struct v4l2_file_operations cobalt_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.unlocked_ioctl = video_ioctl2,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.read = vb2_fop_read,\n};\n\nstatic const struct v4l2_file_operations cobalt_out_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.unlocked_ioctl = video_ioctl2,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.write = vb2_fop_write,\n};\n\nstatic const struct v4l2_file_operations cobalt_empty_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.unlocked_ioctl = video_ioctl2,\n\t.release = v4l2_fh_release,\n};\n\nstatic int cobalt_node_register(struct cobalt *cobalt, int node)\n{\n\tstatic const struct v4l2_dv_timings dv1080p60 =\n\t\tV4L2_DV_BT_CEA_1920X1080P60;\n\tstruct cobalt_stream *s = cobalt->streams + node;\n\tstruct video_device *vdev = &s->vdev;\n\tstruct vb2_queue *q = &s->q;\n\tint ret;\n\n\tmutex_init(&s->lock);\n\tspin_lock_init(&s->irqlock);\n\n\tsnprintf(vdev->name, sizeof(vdev->name),\n\t\t\t\"%s-%d\", cobalt->v4l2_dev.name, node);\n\ts->width = 1920;\n\t \n\ts->height = s->is_audio ? 4 : 1080;\n\n\tif (s->is_audio) {\n\t\ts->bpp = 1;\n\t\ts->pixfmt = V4L2_PIX_FMT_GREY;\n\t} else if (s->is_output) {\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\n\t\ts->pixfmt = V4L2_PIX_FMT_BGR32;\n\t} else {\n\t\ts->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\n\t\ts->pixfmt = V4L2_PIX_FMT_YUYV;\n\t}\n\ts->colorspace = V4L2_COLORSPACE_SRGB;\n\ts->stride = s->width * s->bpp;\n\n\tif (!s->is_audio) {\n\t\tif (s->is_dummy)\n\t\t\tcobalt_warn(\"Setting up dummy video node %d\\n\", node);\n\t\tvdev->v4l2_dev = &cobalt->v4l2_dev;\n\t\tif (s->is_dummy)\n\t\t\tvdev->fops = &cobalt_empty_fops;\n\t\telse\n\t\t\tvdev->fops = s->is_output ? &cobalt_out_fops :\n\t\t\t\t\t\t    &cobalt_fops;\n\t\tvdev->release = video_device_release_empty;\n\t\tvdev->vfl_dir = s->is_output ? VFL_DIR_TX : VFL_DIR_RX;\n\t\tvdev->lock = &s->lock;\n\t\tif (s->sd)\n\t\t\tvdev->ctrl_handler = s->sd->ctrl_handler;\n\t\ts->timings = dv1080p60;\n\t\tv4l2_subdev_call(s->sd, video, s_dv_timings, &s->timings);\n\t\tif (!s->is_output && s->sd)\n\t\t\tcobalt_enable_input(s);\n\t\tvdev->ioctl_ops = s->is_dummy ? &cobalt_ioctl_empty_ops :\n\t\t\t\t  &cobalt_ioctl_ops;\n\t}\n\n\tINIT_LIST_HEAD(&s->bufs);\n\tq->type = s->is_output ? V4L2_BUF_TYPE_VIDEO_OUTPUT :\n\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->io_modes |= s->is_output ? VB2_WRITE : VB2_READ;\n\tq->drv_priv = s;\n\tq->buf_struct_size = sizeof(struct cobalt_buffer);\n\tq->ops = &cobalt_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->lock = &s->lock;\n\tq->dev = &cobalt->pci_dev->dev;\n\tvdev->queue = q;\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tif (s->is_output)\n\t\tvdev->device_caps |= V4L2_CAP_VIDEO_OUTPUT;\n\telse\n\t\tvdev->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\n\n\tvideo_set_drvdata(vdev, s);\n\tret = vb2_queue_init(q);\n\tif (!s->is_audio && ret == 0)\n\t\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\telse if (!s->is_dummy)\n\t\tret = cobalt_alsa_init(s);\n\n\tif (ret < 0) {\n\t\tif (!s->is_audio)\n\t\t\tcobalt_err(\"couldn't register v4l2 device node %d\\n\",\n\t\t\t\t\tnode);\n\t\treturn ret;\n\t}\n\tcobalt_info(\"registered node %d\\n\", node);\n\treturn 0;\n}\n\n \nint cobalt_nodes_register(struct cobalt *cobalt)\n{\n\tint node, ret;\n\n\t \n\tfor (node = 0; node < COBALT_NUM_STREAMS; node++) {\n\t\tret = cobalt_node_register(cobalt, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nvoid cobalt_nodes_unregister(struct cobalt *cobalt)\n{\n\tint node;\n\n\t \n\tfor (node = 0; node < COBALT_NUM_STREAMS; node++) {\n\t\tstruct cobalt_stream *s = cobalt->streams + node;\n\t\tstruct video_device *vdev = &s->vdev;\n\n\t\tif (!s->is_audio)\n\t\t\tvideo_unregister_device(vdev);\n\t\telse if (!s->is_dummy)\n\t\t\tcobalt_alsa_exit(s);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}