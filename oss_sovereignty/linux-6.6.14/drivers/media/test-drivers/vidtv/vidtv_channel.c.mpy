{
  "module_name": "vidtv_channel.c",
  "hash_id": "419c6d60d2c522398e0ae744ae7d98bff092a57fdb6b2eeee58cef6b897a82a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_channel.c",
  "human_readable_source": "\n \n\n#include <linux/dev_printk.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"vidtv_channel.h\"\n#include \"vidtv_common.h\"\n#include \"vidtv_encoder.h\"\n#include \"vidtv_mux.h\"\n#include \"vidtv_psi.h\"\n#include \"vidtv_s302m.h\"\n\nstatic void vidtv_channel_encoder_destroy(struct vidtv_encoder *e)\n{\n\tstruct vidtv_encoder *tmp = NULL;\n\tstruct vidtv_encoder *curr = e;\n\n\twhile (curr) {\n\t\t \n\t\ttmp = curr;\n\t\tcurr = curr->next;\n\t\ttmp->destroy(tmp);\n\t}\n}\n\n#define ENCODING_ISO8859_15 \"\\x0b\"\n#define TS_NIT_PID\t0x10\n\n \nstruct vidtv_channel\n*vidtv_channel_s302m_init(struct vidtv_channel *head, u16 transport_stream_id)\n{\n\tconst __be32 s302m_fid              = cpu_to_be32(VIDTV_S302M_FORMAT_IDENTIFIER);\n\tchar *event_text = ENCODING_ISO8859_15 \"Bagatelle No. 25 in A minor for solo piano, also known as F\\xfcr Elise, composed by Ludwig van Beethoven\";\n\tchar *event_name = ENCODING_ISO8859_15 \"Ludwig van Beethoven: F\\xfcr Elise\";\n\tstruct vidtv_s302m_encoder_init_args encoder_args = {};\n\tchar *iso_language_code = ENCODING_ISO8859_15 \"eng\";\n\tchar *provider = ENCODING_ISO8859_15 \"LinuxTV.org\";\n\tchar *name = ENCODING_ISO8859_15 \"Beethoven\";\n\tconst u16 s302m_es_pid              = 0x111;  \n\tconst u16 s302m_program_pid         = 0x101;  \n\tconst u16 s302m_service_id          = 0x880;\n\tconst u16 s302m_program_num         = 0x880;\n\tconst u16 s302m_beethoven_event_id  = 1;\n\tstruct vidtv_channel *s302m;\n\n\ts302m = kzalloc(sizeof(*s302m), GFP_KERNEL);\n\tif (!s302m)\n\t\treturn NULL;\n\n\ts302m->name = kstrdup(name, GFP_KERNEL);\n\tif (!s302m->name)\n\t\tgoto free_s302m;\n\n\ts302m->service = vidtv_psi_sdt_service_init(NULL, s302m_service_id, false, true);\n\tif (!s302m->service)\n\t\tgoto free_name;\n\n\ts302m->service->descriptor = (struct vidtv_psi_desc *)\n\t\t\t\t     vidtv_psi_service_desc_init(NULL,\n\t\t\t\t\t\t\t\t DIGITAL_RADIO_SOUND_SERVICE,\n\t\t\t\t\t\t\t\t name,\n\t\t\t\t\t\t\t\t provider);\n\tif (!s302m->service->descriptor)\n\t\tgoto free_service;\n\n\ts302m->transport_stream_id = transport_stream_id;\n\n\ts302m->program = vidtv_psi_pat_program_init(NULL,\n\t\t\t\t\t\t    s302m_service_id,\n\t\t\t\t\t\t    s302m_program_pid);\n\tif (!s302m->program)\n\t\tgoto free_service;\n\n\ts302m->program_num = s302m_program_num;\n\n\ts302m->streams = vidtv_psi_pmt_stream_init(NULL,\n\t\t\t\t\t\t   STREAM_PRIVATE_DATA,\n\t\t\t\t\t\t   s302m_es_pid);\n\tif (!s302m->streams)\n\t\tgoto free_program;\n\n\ts302m->streams->descriptor = (struct vidtv_psi_desc *)\n\t\t\t\t     vidtv_psi_registration_desc_init(NULL,\n\t\t\t\t\t\t\t\t      s302m_fid,\n\t\t\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t\t\t      0);\n\tif (!s302m->streams->descriptor)\n\t\tgoto free_streams;\n\n\tencoder_args.es_pid = s302m_es_pid;\n\n\ts302m->encoders = vidtv_s302m_encoder_init(encoder_args);\n\tif (!s302m->encoders)\n\t\tgoto free_streams;\n\n\ts302m->events = vidtv_psi_eit_event_init(NULL, s302m_beethoven_event_id);\n\tif (!s302m->events)\n\t\tgoto free_encoders;\n\ts302m->events->descriptor = (struct vidtv_psi_desc *)\n\t\t\t\t    vidtv_psi_short_event_desc_init(NULL,\n\t\t\t\t\t\t\t\t    iso_language_code,\n\t\t\t\t\t\t\t\t    event_name,\n\t\t\t\t\t\t\t\t    event_text);\n\tif (!s302m->events->descriptor)\n\t\tgoto free_events;\n\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = s302m;\n\t}\n\n\treturn s302m;\n\nfree_events:\n\tvidtv_psi_eit_event_destroy(s302m->events);\nfree_encoders:\n\tvidtv_s302m_encoder_destroy(s302m->encoders);\nfree_streams:\n\tvidtv_psi_pmt_stream_destroy(s302m->streams);\nfree_program:\n\tvidtv_psi_pat_program_destroy(s302m->program);\nfree_service:\n\tvidtv_psi_sdt_service_destroy(s302m->service);\nfree_name:\n\tkfree(s302m->name);\nfree_s302m:\n\tkfree(s302m);\n\n\treturn NULL;\n}\n\nstatic struct vidtv_psi_table_eit_event\n*vidtv_channel_eit_event_cat_into_new(struct vidtv_mux *m)\n{\n\t \n\tconst struct vidtv_channel *cur_chnl = m->channels;\n\tstruct vidtv_psi_table_eit_event *curr = NULL;\n\tstruct vidtv_psi_table_eit_event *head = NULL;\n\tstruct vidtv_psi_table_eit_event *tail = NULL;\n\tstruct vidtv_psi_desc *desc = NULL;\n\tu16 event_id;\n\n\tif (!cur_chnl)\n\t\treturn NULL;\n\n\twhile (cur_chnl) {\n\t\tcurr = cur_chnl->events;\n\n\t\tif (!curr)\n\t\t\tdev_warn_ratelimited(m->dev,\n\t\t\t\t\t     \"No events found for channel %s\\n\",\n\t\t\t\t\t     cur_chnl->name);\n\n\t\twhile (curr) {\n\t\t\tevent_id = be16_to_cpu(curr->event_id);\n\t\t\ttail = vidtv_psi_eit_event_init(tail, event_id);\n\t\t\tif (!tail) {\n\t\t\t\tvidtv_psi_eit_event_destroy(head);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tdesc = vidtv_psi_desc_clone(curr->descriptor);\n\t\t\tvidtv_psi_desc_assign(&tail->descriptor, desc);\n\n\t\t\tif (!head)\n\t\t\t\thead = tail;\n\n\t\t\tcurr = curr->next;\n\t\t}\n\n\t\tcur_chnl = cur_chnl->next;\n\t}\n\n\treturn head;\n}\n\nstatic struct vidtv_psi_table_sdt_service\n*vidtv_channel_sdt_serv_cat_into_new(struct vidtv_mux *m)\n{\n\t \n\tconst struct vidtv_channel *cur_chnl = m->channels;\n\n\tstruct vidtv_psi_table_sdt_service *curr = NULL;\n\tstruct vidtv_psi_table_sdt_service *head = NULL;\n\tstruct vidtv_psi_table_sdt_service *tail = NULL;\n\n\tstruct vidtv_psi_desc *desc = NULL;\n\tu16 service_id;\n\n\tif (!cur_chnl)\n\t\treturn NULL;\n\n\twhile (cur_chnl) {\n\t\tcurr = cur_chnl->service;\n\n\t\tif (!curr)\n\t\t\tdev_warn_ratelimited(m->dev,\n\t\t\t\t\t     \"No services found for channel %s\\n\",\n\t\t\t\t\t     cur_chnl->name);\n\n\t\twhile (curr) {\n\t\t\tservice_id = be16_to_cpu(curr->service_id);\n\t\t\ttail = vidtv_psi_sdt_service_init(tail,\n\t\t\t\t\t\t\t  service_id,\n\t\t\t\t\t\t\t  curr->EIT_schedule,\n\t\t\t\t\t\t\t  curr->EIT_present_following);\n\t\t\tif (!tail)\n\t\t\t\tgoto free;\n\n\t\t\tdesc = vidtv_psi_desc_clone(curr->descriptor);\n\t\t\tif (!desc)\n\t\t\t\tgoto free_tail;\n\t\t\tvidtv_psi_desc_assign(&tail->descriptor, desc);\n\n\t\t\tif (!head)\n\t\t\t\thead = tail;\n\n\t\t\tcurr = curr->next;\n\t\t}\n\n\t\tcur_chnl = cur_chnl->next;\n\t}\n\n\treturn head;\n\nfree_tail:\n\tvidtv_psi_sdt_service_destroy(tail);\nfree:\n\tvidtv_psi_sdt_service_destroy(head);\n\treturn NULL;\n}\n\nstatic struct vidtv_psi_table_pat_program*\nvidtv_channel_pat_prog_cat_into_new(struct vidtv_mux *m)\n{\n\t \n\tconst struct vidtv_channel *cur_chnl = m->channels;\n\tstruct vidtv_psi_table_pat_program *curr = NULL;\n\tstruct vidtv_psi_table_pat_program *head = NULL;\n\tstruct vidtv_psi_table_pat_program *tail = NULL;\n\tu16 serv_id;\n\tu16 pid;\n\n\tif (!cur_chnl)\n\t\treturn NULL;\n\n\twhile (cur_chnl) {\n\t\tcurr = cur_chnl->program;\n\n\t\tif (!curr)\n\t\t\tdev_warn_ratelimited(m->dev,\n\t\t\t\t\t     \"No programs found for channel %s\\n\",\n\t\t\t\t\t     cur_chnl->name);\n\n\t\twhile (curr) {\n\t\t\tserv_id = be16_to_cpu(curr->service_id);\n\t\t\tpid = vidtv_psi_get_pat_program_pid(curr);\n\t\t\ttail = vidtv_psi_pat_program_init(tail,\n\t\t\t\t\t\t\t  serv_id,\n\t\t\t\t\t\t\t  pid);\n\t\t\tif (!tail) {\n\t\t\t\tvidtv_psi_pat_program_destroy(head);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (!head)\n\t\t\t\thead = tail;\n\n\t\t\tcurr = curr->next;\n\t\t}\n\n\t\tcur_chnl = cur_chnl->next;\n\t}\n\t \n\tvidtv_psi_pat_program_init(tail, 0, TS_NIT_PID);\n\n\treturn head;\n}\n\n \nstatic void\nvidtv_channel_pmt_match_sections(struct vidtv_channel *channels,\n\t\t\t\t struct vidtv_psi_table_pmt **sections,\n\t\t\t\t u32 nsections)\n{\n\tstruct vidtv_psi_table_pmt *curr_section = NULL;\n\tstruct vidtv_psi_table_pmt_stream *head = NULL;\n\tstruct vidtv_psi_table_pmt_stream *tail = NULL;\n\tstruct vidtv_psi_table_pmt_stream *s = NULL;\n\tstruct vidtv_channel *cur_chnl = channels;\n\tstruct vidtv_psi_desc *desc = NULL;\n\tu16 e_pid;  \n\tu16 curr_id;\n\tu32 j;\n\n\twhile (cur_chnl) {\n\t\tfor (j = 0; j < nsections; ++j) {\n\t\t\tcurr_section = sections[j];\n\n\t\t\tif (!curr_section)\n\t\t\t\tcontinue;\n\n\t\t\tcurr_id = be16_to_cpu(curr_section->header.id);\n\n\t\t\t \n\t\t\tif (curr_id == cur_chnl->program_num) {\n\t\t\t\ts = cur_chnl->streams;\n\n\t\t\t\t \n\t\t\t\twhile (s) {\n\t\t\t\t\te_pid = vidtv_psi_pmt_stream_get_elem_pid(s);\n\t\t\t\t\ttail = vidtv_psi_pmt_stream_init(tail,\n\t\t\t\t\t\t\t\t\t s->type,\n\t\t\t\t\t\t\t\t\t e_pid);\n\n\t\t\t\t\tif (!head)\n\t\t\t\t\t\thead = tail;\n\n\t\t\t\t\tdesc = vidtv_psi_desc_clone(s->descriptor);\n\t\t\t\t\tvidtv_psi_desc_assign(&tail->descriptor,\n\t\t\t\t\t\t\t      desc);\n\n\t\t\t\t\ts = s->next;\n\t\t\t\t}\n\n\t\t\t\tvidtv_psi_pmt_stream_assign(curr_section, head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur_chnl = cur_chnl->next;\n\t}\n}\n\nstatic void\nvidtv_channel_destroy_service_list(struct vidtv_psi_desc_service_list_entry *e)\n{\n\tstruct vidtv_psi_desc_service_list_entry *tmp;\n\n\twhile (e) {\n\t\ttmp = e;\n\t\te = e->next;\n\t\tkfree(tmp);\n\t}\n}\n\nstatic struct vidtv_psi_desc_service_list_entry\n*vidtv_channel_build_service_list(struct vidtv_psi_table_sdt_service *s)\n{\n\tstruct vidtv_psi_desc_service_list_entry *curr_e = NULL;\n\tstruct vidtv_psi_desc_service_list_entry *head_e = NULL;\n\tstruct vidtv_psi_desc_service_list_entry *prev_e = NULL;\n\tstruct vidtv_psi_desc *desc = s->descriptor;\n\tstruct vidtv_psi_desc_service *s_desc;\n\n\twhile (s) {\n\t\twhile (desc) {\n\t\t\tif (s->descriptor->type != SERVICE_DESCRIPTOR)\n\t\t\t\tgoto next_desc;\n\n\t\t\ts_desc = (struct vidtv_psi_desc_service *)desc;\n\n\t\t\tcurr_e = kzalloc(sizeof(*curr_e), GFP_KERNEL);\n\t\t\tif (!curr_e) {\n\t\t\t\tvidtv_channel_destroy_service_list(head_e);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tcurr_e->service_id = s->service_id;\n\t\t\tcurr_e->service_type = s_desc->service_type;\n\n\t\t\tif (!head_e)\n\t\t\t\thead_e = curr_e;\n\t\t\tif (prev_e)\n\t\t\t\tprev_e->next = curr_e;\n\n\t\t\tprev_e = curr_e;\n\nnext_desc:\n\t\t\tdesc = desc->next;\n\t\t}\n\t\ts = s->next;\n\t}\n\treturn head_e;\n}\n\nint vidtv_channel_si_init(struct vidtv_mux *m)\n{\n\tstruct vidtv_psi_desc_service_list_entry *service_list = NULL;\n\tstruct vidtv_psi_table_pat_program *programs = NULL;\n\tstruct vidtv_psi_table_sdt_service *services = NULL;\n\tstruct vidtv_psi_table_eit_event *events = NULL;\n\n\tm->si.pat = vidtv_psi_pat_table_init(m->transport_stream_id);\n\tif (!m->si.pat)\n\t\treturn -ENOMEM;\n\n\tm->si.sdt = vidtv_psi_sdt_table_init(m->network_id,\n\t\t\t\t\t     m->transport_stream_id);\n\tif (!m->si.sdt)\n\t\tgoto free_pat;\n\n\tprograms = vidtv_channel_pat_prog_cat_into_new(m);\n\tif (!programs)\n\t\tgoto free_sdt;\n\tservices = vidtv_channel_sdt_serv_cat_into_new(m);\n\tif (!services)\n\t\tgoto free_programs;\n\n\tevents = vidtv_channel_eit_event_cat_into_new(m);\n\tif (!events)\n\t\tgoto free_services;\n\n\t \n\tservice_list = vidtv_channel_build_service_list(services);\n\tif (!service_list)\n\t\tgoto free_events;\n\n\t \n\tm->si.nit = vidtv_psi_nit_table_init(m->network_id,\n\t\t\t\t\t     m->transport_stream_id,\n\t\t\t\t\t     m->network_name,\n\t\t\t\t\t     service_list);\n\tif (!m->si.nit)\n\t\tgoto free_service_list;\n\n\tm->si.eit = vidtv_psi_eit_table_init(m->network_id,\n\t\t\t\t\t     m->transport_stream_id,\n\t\t\t\t\t     programs->service_id);\n\tif (!m->si.eit)\n\t\tgoto free_nit;\n\n\t \n\tvidtv_psi_pat_program_assign(m->si.pat, programs);\n\n\t \n\tvidtv_psi_sdt_service_assign(m->si.sdt, services);\n\n\t \n\tvidtv_psi_eit_event_assign(m->si.eit, events);\n\n\tm->si.pmt_secs = vidtv_psi_pmt_create_sec_for_each_pat_entry(m->si.pat,\n\t\t\t\t\t\t\t\t     m->pcr_pid);\n\tif (!m->si.pmt_secs)\n\t\tgoto free_eit;\n\n\tvidtv_channel_pmt_match_sections(m->channels,\n\t\t\t\t\t m->si.pmt_secs,\n\t\t\t\t\t m->si.pat->num_pmt);\n\n\tvidtv_channel_destroy_service_list(service_list);\n\n\treturn 0;\n\nfree_eit:\n\tvidtv_psi_eit_table_destroy(m->si.eit);\nfree_nit:\n\tvidtv_psi_nit_table_destroy(m->si.nit);\nfree_service_list:\n\tvidtv_channel_destroy_service_list(service_list);\nfree_events:\n\tvidtv_psi_eit_event_destroy(events);\nfree_services:\n\tvidtv_psi_sdt_service_destroy(services);\nfree_programs:\n\tvidtv_psi_pat_program_destroy(programs);\nfree_sdt:\n\tvidtv_psi_sdt_table_destroy(m->si.sdt);\nfree_pat:\n\tvidtv_psi_pat_table_destroy(m->si.pat);\n\treturn 0;\n}\n\nvoid vidtv_channel_si_destroy(struct vidtv_mux *m)\n{\n\tu32 i;\n\n\tfor (i = 0; i < m->si.pat->num_pmt; ++i)\n\t\tvidtv_psi_pmt_table_destroy(m->si.pmt_secs[i]);\n\n\tvidtv_psi_pat_table_destroy(m->si.pat);\n\n\tkfree(m->si.pmt_secs);\n\tvidtv_psi_sdt_table_destroy(m->si.sdt);\n\tvidtv_psi_nit_table_destroy(m->si.nit);\n\tvidtv_psi_eit_table_destroy(m->si.eit);\n}\n\nint vidtv_channels_init(struct vidtv_mux *m)\n{\n\t \n\tm->channels = vidtv_channel_s302m_init(NULL, m->transport_stream_id);\n\n\tif (!m->channels)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid vidtv_channels_destroy(struct vidtv_mux *m)\n{\n\tstruct vidtv_channel *curr = m->channels;\n\tstruct vidtv_channel *tmp = NULL;\n\n\twhile (curr) {\n\t\tkfree(curr->name);\n\t\tvidtv_psi_sdt_service_destroy(curr->service);\n\t\tvidtv_psi_pat_program_destroy(curr->program);\n\t\tvidtv_psi_pmt_stream_destroy(curr->streams);\n\t\tvidtv_channel_encoder_destroy(curr->encoders);\n\t\tvidtv_psi_eit_event_destroy(curr->events);\n\n\t\ttmp = curr;\n\t\tcurr = curr->next;\n\t\tkfree(tmp);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}