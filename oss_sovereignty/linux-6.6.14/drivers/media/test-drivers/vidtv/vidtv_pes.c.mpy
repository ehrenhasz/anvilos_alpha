{
  "module_name": "vidtv_pes.c",
  "hash_id": "7cde7f2502c0b1d9d3413a16ed0728ea4e0b13ff71f491354332374c6cb2b35c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_pes.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s, %d: \" fmt, __func__, __LINE__\n\n#include <linux/types.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n\n#include \"vidtv_pes.h\"\n#include \"vidtv_common.h\"\n#include \"vidtv_encoder.h\"\n#include \"vidtv_ts.h\"\n\n#define PRIVATE_STREAM_1_ID 0xbd  \n#define PES_HEADER_MAX_STUFFING_BYTES 32\n#define PES_TS_HEADER_MAX_STUFFING_BYTES 182\n\nstatic u32 vidtv_pes_op_get_len(bool send_pts, bool send_dts)\n{\n\tu32 len = 0;\n\n\t \n\tlen += sizeof(struct vidtv_pes_optional);\n\n\t \n\tif (send_pts && send_dts)\n\t\tlen += sizeof(struct vidtv_pes_optional_pts_dts);\n\telse if (send_pts)\n\t\tlen += sizeof(struct vidtv_pes_optional_pts);\n\n\treturn len;\n}\n\n#define SIZE_PCR (6 + sizeof(struct vidtv_mpeg_ts_adaption))\n\nstatic u32 vidtv_pes_h_get_len(bool send_pts, bool send_dts)\n{\n\tu32 len = 0;\n\n\t \n\n\tlen += sizeof(struct vidtv_mpeg_pes);\n\tlen += vidtv_pes_op_get_len(send_pts, send_dts);\n\n\treturn len;\n}\n\nstatic u32 vidtv_pes_write_header_stuffing(struct pes_header_write_args *args)\n{\n\t \n\tif (args->n_pes_h_s_bytes > PES_HEADER_MAX_STUFFING_BYTES) {\n\t\tpr_warn_ratelimited(\"More than %d stuffing bytes in PES packet header\\n\",\n\t\t\t\t    PES_HEADER_MAX_STUFFING_BYTES);\n\t\targs->n_pes_h_s_bytes = PES_HEADER_MAX_STUFFING_BYTES;\n\t}\n\n\treturn vidtv_memset(args->dest_buf,\n\t\t\t    args->dest_offset,\n\t\t\t    args->dest_buf_sz,\n\t\t\t    TS_FILL_BYTE,\n\t\t\t    args->n_pes_h_s_bytes);\n}\n\nstatic u32 vidtv_pes_write_pts_dts(struct pes_header_write_args *args)\n{\n\tu32 nbytes = 0;   \n\n\tstruct vidtv_pes_optional_pts pts = {};\n\tstruct vidtv_pes_optional_pts_dts pts_dts = {};\n\tvoid *op = NULL;\n\tsize_t op_sz = 0;\n\tu64 mask1;\n\tu64 mask2;\n\tu64 mask3;\n\n\tif (!args->send_pts && args->send_dts)\n\t\treturn 0;\n\n\tmask1 = GENMASK_ULL(32, 30);\n\tmask2 = GENMASK_ULL(29, 15);\n\tmask3 = GENMASK_ULL(14, 0);\n\n\t \n\tif (args->send_pts && args->send_dts) {\n\t\tpts_dts.pts1 = (0x3 << 4) | ((args->pts & mask1) >> 29) | 0x1;\n\t\tpts_dts.pts2 = cpu_to_be16(((args->pts & mask2) >> 14) | 0x1);\n\t\tpts_dts.pts3 = cpu_to_be16(((args->pts & mask3) << 1) | 0x1);\n\n\t\tpts_dts.dts1 = (0x1 << 4) | ((args->dts & mask1) >> 29) | 0x1;\n\t\tpts_dts.dts2 = cpu_to_be16(((args->dts & mask2) >> 14) | 0x1);\n\t\tpts_dts.dts3 = cpu_to_be16(((args->dts & mask3) << 1) | 0x1);\n\n\t\top = &pts_dts;\n\t\top_sz = sizeof(pts_dts);\n\n\t} else if (args->send_pts) {\n\t\tpts.pts1 = (0x1 << 5) | ((args->pts & mask1) >> 29) | 0x1;\n\t\tpts.pts2 = cpu_to_be16(((args->pts & mask2) >> 14) | 0x1);\n\t\tpts.pts3 = cpu_to_be16(((args->pts & mask3) << 1) | 0x1);\n\n\t\top = &pts;\n\t\top_sz = sizeof(pts);\n\t}\n\n\t \n\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t       args->dest_offset + nbytes,\n\t\t\t       args->dest_buf_sz,\n\t\t\t       op,\n\t\t\t       op_sz);\n\n\treturn nbytes;\n}\n\nstatic u32 vidtv_pes_write_h(struct pes_header_write_args *args)\n{\n\tu32 nbytes = 0;   \n\n\tstruct vidtv_mpeg_pes pes_header          = {};\n\tstruct vidtv_pes_optional pes_optional    = {};\n\tstruct pes_header_write_args pts_dts_args;\n\tu32 stream_id = (args->encoder_id == S302M) ? PRIVATE_STREAM_1_ID : args->stream_id;\n\tu16 pes_opt_bitfield = 0x01 << 15;\n\n\tpes_header.bitfield = cpu_to_be32((PES_START_CODE_PREFIX << 8) | stream_id);\n\n\tpes_header.length = cpu_to_be16(vidtv_pes_op_get_len(args->send_pts,\n\t\t\t\t\t\t\t     args->send_dts) +\n\t\t\t\t\t\t\t     args->access_unit_len);\n\n\tif (args->send_pts && args->send_dts)\n\t\tpes_opt_bitfield |= (0x3 << 6);\n\telse if (args->send_pts)\n\t\tpes_opt_bitfield |= (0x1 << 7);\n\n\tpes_optional.bitfield = cpu_to_be16(pes_opt_bitfield);\n\tpes_optional.length = vidtv_pes_op_get_len(args->send_pts, args->send_dts) +\n\t\t\t      args->n_pes_h_s_bytes -\n\t\t\t      sizeof(struct vidtv_pes_optional);\n\n\t \n\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t       args->dest_offset + nbytes,\n\t\t\t       args->dest_buf_sz,\n\t\t\t       &pes_header,\n\t\t\t       sizeof(pes_header));\n\n\t \n\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t       args->dest_offset + nbytes,\n\t\t\t       args->dest_buf_sz,\n\t\t\t       &pes_optional,\n\t\t\t       sizeof(pes_optional));\n\n\t \n\tpts_dts_args = *args;\n\tpts_dts_args.dest_offset = args->dest_offset + nbytes;\n\tnbytes += vidtv_pes_write_pts_dts(&pts_dts_args);\n\n\t \n\tnbytes += vidtv_pes_write_header_stuffing(args);\n\n\treturn nbytes;\n}\n\nstatic u32 vidtv_pes_write_pcr_bits(u8 *to, u32 to_offset, u64 pcr)\n{\n\t \n\tu64 div;\n\tu64 rem;\n\tu8 *buf = to + to_offset;\n\tu64 pcr_low;\n\tu64 pcr_high;\n\n\tdiv = div64_u64_rem(pcr, 300, &rem);\n\n\tpcr_low = rem;  \n\tpcr_high = div;  \n\n\t*buf++ = pcr_high >> 25;\n\t*buf++ = pcr_high >> 17;\n\t*buf++ = pcr_high >>  9;\n\t*buf++ = pcr_high >>  1;\n\t*buf++ = pcr_high <<  7 | pcr_low >> 8 | 0x7e;\n\t*buf++ = pcr_low;\n\n\treturn 6;\n}\n\nstatic u32 vidtv_pes_write_stuffing(struct pes_ts_header_write_args *args,\n\t\t\t\t    u32 dest_offset, bool need_pcr,\n\t\t\t\t    u64 *last_pcr)\n{\n\tstruct vidtv_mpeg_ts_adaption ts_adap = {};\n\tint stuff_nbytes;\n\tu32 nbytes = 0;\n\n\tif (!args->n_stuffing_bytes)\n\t\treturn 0;\n\n\tts_adap.random_access = 1;\n\n\t \n\tif (need_pcr) {\n\t\tts_adap.PCR = 1;\n\t\tts_adap.length = SIZE_PCR;\n\t} else {\n\t\tts_adap.length = sizeof(ts_adap);\n\t}\n\tstuff_nbytes = args->n_stuffing_bytes - ts_adap.length;\n\n\tts_adap.length -= sizeof(ts_adap.length);\n\n\tif (unlikely(stuff_nbytes < 0))\n\t\tstuff_nbytes = 0;\n\n\tts_adap.length += stuff_nbytes;\n\n\t \n\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t       dest_offset + nbytes,\n\t\t\t       args->dest_buf_sz,\n\t\t\t       &ts_adap,\n\t\t\t       sizeof(ts_adap));\n\n\t \n\tif (need_pcr) {\n\t\tnbytes += vidtv_pes_write_pcr_bits(args->dest_buf,\n\t\t\t\t\t\t   dest_offset + nbytes,\n\t\t\t\t\t\t   args->pcr);\n\n\t\t*last_pcr = args->pcr;\n\t}\n\n\t \n\tif (stuff_nbytes)\n\t\tnbytes += vidtv_memset(args->dest_buf,\n\t\t\t\t       dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       TS_FILL_BYTE,\n\t\t\t\t       stuff_nbytes);\n\n\t \n\tif (nbytes != args->n_stuffing_bytes)\n\t\tpr_warn_ratelimited(\"write size was %d, expected %d\\n\",\n\t\t\t\t    nbytes, args->n_stuffing_bytes);\n\n\treturn nbytes;\n}\n\nstatic u32 vidtv_pes_write_ts_h(struct pes_ts_header_write_args args,\n\t\t\t\tbool need_pcr, u64 *last_pcr)\n{\n\t \n\tu32 nbytes = 0;\n\tstruct vidtv_mpeg_ts ts_header = {};\n\tu16 payload_start = !args.wrote_pes_header;\n\n\tts_header.sync_byte        = TS_SYNC_BYTE;\n\tts_header.bitfield         = cpu_to_be16((payload_start << 14) | args.pid);\n\tts_header.scrambling       = 0;\n\tts_header.adaptation_field = (args.n_stuffing_bytes) > 0;\n\tts_header.payload          = (args.n_stuffing_bytes) < PES_TS_HEADER_MAX_STUFFING_BYTES;\n\n\tts_header.continuity_counter = *args.continuity_counter;\n\n\tvidtv_ts_inc_cc(args.continuity_counter);\n\n\t \n\tnbytes += vidtv_memcpy(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.dest_buf_sz,\n\t\t\t       &ts_header,\n\t\t\t       sizeof(ts_header));\n\n\t \n\tnbytes += vidtv_pes_write_stuffing(&args, args.dest_offset + nbytes,\n\t\t\t\t\t   need_pcr, last_pcr);\n\n\treturn nbytes;\n}\n\nu32 vidtv_pes_write_into(struct pes_write_args *args)\n{\n\tu32 unaligned_bytes = (args->dest_offset % TS_PACKET_LEN);\n\tstruct pes_ts_header_write_args ts_header_args = {\n\t\t.dest_buf\t\t= args->dest_buf,\n\t\t.dest_buf_sz\t\t= args->dest_buf_sz,\n\t\t.pid\t\t\t= args->pid,\n\t\t.pcr\t\t\t= args->pcr,\n\t\t.continuity_counter\t= args->continuity_counter,\n\t};\n\tstruct pes_header_write_args pes_header_args = {\n\t\t.dest_buf\t\t= args->dest_buf,\n\t\t.dest_buf_sz\t\t= args->dest_buf_sz,\n\t\t.encoder_id\t\t= args->encoder_id,\n\t\t.send_pts\t\t= args->send_pts,\n\t\t.pts\t\t\t= args->pts,\n\t\t.send_dts\t\t= args->send_dts,\n\t\t.dts\t\t\t= args->dts,\n\t\t.stream_id\t\t= args->stream_id,\n\t\t.n_pes_h_s_bytes\t= args->n_pes_h_s_bytes,\n\t\t.access_unit_len\t= args->access_unit_len,\n\t};\n\tu32 remaining_len = args->access_unit_len;\n\tbool wrote_pes_header = false;\n\tu64 last_pcr = args->pcr;\n\tbool need_pcr = true;\n\tu32 available_space;\n\tu32 payload_size;\n\tu32 stuff_bytes;\n\tu32 nbytes = 0;\n\n\tif (unaligned_bytes) {\n\t\tpr_warn_ratelimited(\"buffer is misaligned, while starting PES\\n\");\n\n\t\t \n\t\tnbytes += vidtv_memset(args->dest_buf,\n\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       TS_FILL_BYTE,\n\t\t\t\t       TS_PACKET_LEN - unaligned_bytes);\n\t}\n\n\twhile (remaining_len) {\n\t\tavailable_space = TS_PAYLOAD_LEN;\n\t\t \n\t\tif (!wrote_pes_header)\n\t\t\tavailable_space -= vidtv_pes_h_get_len(args->send_pts,\n\t\t\t\t\t\t\t       args->send_dts);\n\n\t\t \n\t\tavailable_space -= args->n_pes_h_s_bytes;\n\n\t\t \n\t\tif (need_pcr) {\n\t\t\tavailable_space -= SIZE_PCR;\n\t\t\tstuff_bytes = SIZE_PCR;\n\t\t} else {\n\t\t\tstuff_bytes = 0;\n\t\t}\n\n\t\t \n\t\tif (remaining_len >= available_space) {\n\t\t\tpayload_size = available_space;\n\t\t} else {\n\t\t\t \n\t\t\tpayload_size = remaining_len;\n\t\t\tstuff_bytes += available_space - payload_size;\n\n\t\t\t \n\t\t\tif (stuff_bytes > PES_TS_HEADER_MAX_STUFFING_BYTES) {\n\t\t\t\tu32 tmp = stuff_bytes - PES_TS_HEADER_MAX_STUFFING_BYTES;\n\n\t\t\t\tstuff_bytes = PES_TS_HEADER_MAX_STUFFING_BYTES;\n\t\t\t\tpayload_size -= tmp;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tts_header_args.dest_offset = args->dest_offset + nbytes;\n\t\tts_header_args.wrote_pes_header\t= wrote_pes_header;\n\t\tts_header_args.n_stuffing_bytes\t= stuff_bytes;\n\n\t\tnbytes += vidtv_pes_write_ts_h(ts_header_args, need_pcr,\n\t\t\t\t\t       &last_pcr);\n\n\t\tneed_pcr = false;\n\n\t\tif (!wrote_pes_header) {\n\t\t\t \n\t\t\tpes_header_args.dest_offset = args->dest_offset +\n\t\t\t\t\t\t      nbytes;\n\t\t\tnbytes += vidtv_pes_write_h(&pes_header_args);\n\t\t\twrote_pes_header = true;\n\t\t}\n\n\t\t \n\t\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       args->from,\n\t\t\t\t       payload_size);\n\n\t\targs->from += payload_size;\n\n\t\tremaining_len -= payload_size;\n\t}\n\n\treturn nbytes;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}