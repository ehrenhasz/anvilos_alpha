{
  "module_name": "vidtv_tuner.c",
  "hash_id": "bb6816113db1afc2952298e093c3a65183d5a45df6978aec644fdc83a0d49a19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_tuner.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"vidtv_tuner.h\"\n\nstruct vidtv_tuner_cnr_to_qual_s {\n\t \n\tu32 modulation;\n\tu32 fec;\n\tu32 cnr_ok;\n\tu32 cnr_good;\n};\n\nstatic const struct vidtv_tuner_cnr_to_qual_s vidtv_tuner_c_cnr_2_qual[] = {\n\t \n\t{ QAM_256, FEC_NONE,  34000, 38000},\n\t{ QAM_64,  FEC_NONE,  30000, 34000},\n};\n\nstatic const struct vidtv_tuner_cnr_to_qual_s vidtv_tuner_s_cnr_2_qual[] = {\n\t \n\t{ QPSK, FEC_1_2,  7000, 10000},\n\t{ QPSK, FEC_2_3,  9000, 12000},\n\t{ QPSK, FEC_3_4, 10000, 13000},\n\t{ QPSK, FEC_5_6, 11000, 14000},\n\t{ QPSK, FEC_7_8, 12000, 15000},\n};\n\nstatic const struct vidtv_tuner_cnr_to_qual_s vidtv_tuner_s2_cnr_2_qual[] = {\n\t \n\t{ QPSK,  FEC_1_2,   9000,  12000},\n\t{ QPSK,  FEC_2_3,  11000,  14000},\n\t{ QPSK,  FEC_3_4,  12000,  15000},\n\t{ QPSK,  FEC_5_6,  12000,  15000},\n\t{ QPSK,  FEC_8_9,  13000,  16000},\n\t{ QPSK,  FEC_9_10, 13500,  16500},\n\t{ PSK_8, FEC_2_3,  14500,  17500},\n\t{ PSK_8, FEC_3_4,  16000,  19000},\n\t{ PSK_8, FEC_5_6,  17500,  20500},\n\t{ PSK_8, FEC_8_9,  19000,  22000},\n};\n\nstatic const struct vidtv_tuner_cnr_to_qual_s vidtv_tuner_t_cnr_2_qual[] = {\n\t \n\t{   QPSK, FEC_1_2,  4100,  5900},\n\t{   QPSK, FEC_2_3,  6100,  9600},\n\t{   QPSK, FEC_3_4,  7200, 12400},\n\t{   QPSK, FEC_5_6,  8500, 15600},\n\t{   QPSK, FEC_7_8,  9200, 17500},\n\t{ QAM_16, FEC_1_2,  9800, 11800},\n\t{ QAM_16, FEC_2_3, 12100, 15300},\n\t{ QAM_16, FEC_3_4, 13400, 18100},\n\t{ QAM_16, FEC_5_6, 14800, 21300},\n\t{ QAM_16, FEC_7_8, 15700, 23600},\n\t{ QAM_64, FEC_1_2, 14000, 16000},\n\t{ QAM_64, FEC_2_3, 19900, 25400},\n\t{ QAM_64, FEC_3_4, 24900, 27900},\n\t{ QAM_64, FEC_5_6, 21300, 23300},\n\t{ QAM_64, FEC_7_8, 22000, 24000},\n};\n\n \nstruct vidtv_tuner_hardware_state {\n\tbool asleep;\n\tu32 lock_status;\n\tu32 if_frequency;\n\tu32 tuned_frequency;\n\tu32 bandwidth;\n};\n\n \nstruct vidtv_tuner_dev {\n\tstruct dvb_frontend *fe;\n\tstruct vidtv_tuner_hardware_state hw_state;\n\tstruct vidtv_tuner_config config;\n};\n\nstatic struct vidtv_tuner_dev*\nvidtv_tuner_get_dev(struct dvb_frontend *fe)\n{\n\treturn i2c_get_clientdata(fe->tuner_priv);\n}\n\nstatic int vidtv_tuner_check_frequency_shift(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct vidtv_tuner_config config  = tuner_dev->config;\n\tu32 *valid_freqs = NULL;\n\tu32 array_sz = 0;\n\tu32 i;\n\tu32 shift;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tvalid_freqs = config.vidtv_valid_dvb_t_freqs;\n\t\tarray_sz    = ARRAY_SIZE(config.vidtv_valid_dvb_t_freqs);\n\t\tbreak;\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\t\tvalid_freqs = config.vidtv_valid_dvb_s_freqs;\n\t\tarray_sz    = ARRAY_SIZE(config.vidtv_valid_dvb_s_freqs);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tvalid_freqs = config.vidtv_valid_dvb_c_freqs;\n\t\tarray_sz    = ARRAY_SIZE(config.vidtv_valid_dvb_c_freqs);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"%s: unsupported delivery system: %u\\n\",\n\t\t\t __func__,\n\t\t\t c->delivery_system);\n\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < array_sz; i++) {\n\t\tif (!valid_freqs[i])\n\t\t\tbreak;\n\t\tshift = abs(c->frequency - valid_freqs[i]);\n\n\t\tif (!shift)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (shift < config.max_frequency_shift_hz)\n\t\t\treturn shift * 100 / config.max_frequency_shift_hz;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nvidtv_tuner_get_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\tconst struct vidtv_tuner_cnr_to_qual_s *cnr2qual = NULL;\n\tstruct device *dev = fe->dvb->device;\n\tu32 array_size = 0;\n\ts32 shift;\n\tu32 i;\n\n\tshift = vidtv_tuner_check_frequency_shift(fe);\n\tif (shift < 0) {\n\t\ttuner_dev->hw_state.lock_status = 0;\n\t\t*strength = 0;\n\t\treturn 0;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tcnr2qual   = vidtv_tuner_t_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_tuner_t_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBS:\n\t\tcnr2qual   = vidtv_tuner_s_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_tuner_s_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tcnr2qual   = vidtv_tuner_s2_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_tuner_s2_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBC_ANNEX_A:\n\t\tcnr2qual   = vidtv_tuner_c_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_tuner_c_cnr_2_qual);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"%s: unsupported delivery system: %u\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     c->delivery_system);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < array_size; i++) {\n\t\tif (cnr2qual[i].modulation != c->modulation ||\n\t\t    cnr2qual[i].fec != c->fec_inner)\n\t\t\tcontinue;\n\n\t\tif (!shift) {\n\t\t\t*strength = cnr2qual[i].cnr_good;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\n\t\t*strength = cnr2qual[i].cnr_ok -\n\t\t\t    (cnr2qual[i].cnr_good - cnr2qual[i].cnr_ok);\n\t\treturn 0;\n\t}\n\n\t \n\t*strength = 34000 - 24000 * shift / 100;\n\treturn 0;\n}\n\nstatic int vidtv_tuner_init(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\tstruct vidtv_tuner_config config  = tuner_dev->config;\n\n\tmsleep_interruptible(config.mock_power_up_delay_msec);\n\n\ttuner_dev->hw_state.asleep = false;\n\ttuner_dev->hw_state.if_frequency = 5000;\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_sleep(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\ttuner_dev->hw_state.asleep = true;\n\treturn 0;\n}\n\nstatic int vidtv_tuner_suspend(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\ttuner_dev->hw_state.asleep = true;\n\treturn 0;\n}\n\nstatic int vidtv_tuner_resume(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\ttuner_dev->hw_state.asleep = false;\n\treturn 0;\n}\n\nstatic int vidtv_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\tstruct vidtv_tuner_config config  = tuner_dev->config;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\ts32 shift;\n\n\tu32 min_freq = fe->ops.tuner_ops.info.frequency_min_hz;\n\tu32 max_freq = fe->ops.tuner_ops.info.frequency_max_hz;\n\tu32 min_bw = fe->ops.tuner_ops.info.bandwidth_min;\n\tu32 max_bw = fe->ops.tuner_ops.info.bandwidth_max;\n\n\tif (c->frequency < min_freq  || c->frequency > max_freq  ||\n\t    c->bandwidth_hz < min_bw || c->bandwidth_hz > max_bw) {\n\t\ttuner_dev->hw_state.lock_status = 0;\n\t\treturn -EINVAL;\n\t}\n\n\ttuner_dev->hw_state.tuned_frequency = c->frequency;\n\ttuner_dev->hw_state.bandwidth = c->bandwidth_hz;\n\ttuner_dev->hw_state.lock_status = TUNER_STATUS_LOCKED;\n\n\tmsleep_interruptible(config.mock_tune_delay_msec);\n\n\tshift = vidtv_tuner_check_frequency_shift(fe);\n\tif (shift < 0) {\n\t\ttuner_dev->hw_state.lock_status = 0;\n\t\treturn shift;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_set_config(struct dvb_frontend *fe,\n\t\t\t\t  void *priv_cfg)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\tmemcpy(&tuner_dev->config, priv_cfg, sizeof(tuner_dev->config));\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_get_frequency(struct dvb_frontend *fe,\n\t\t\t\t     u32 *frequency)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\t*frequency = tuner_dev->hw_state.tuned_frequency;\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_get_bandwidth(struct dvb_frontend *fe,\n\t\t\t\t     u32 *bandwidth)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\t*bandwidth = tuner_dev->hw_state.bandwidth;\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_get_if_frequency(struct dvb_frontend *fe,\n\t\t\t\t\tu32 *frequency)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\t*frequency = tuner_dev->hw_state.if_frequency;\n\n\treturn 0;\n}\n\nstatic int vidtv_tuner_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = vidtv_tuner_get_dev(fe);\n\n\t*status = tuner_dev->hw_state.lock_status;\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops vidtv_tuner_ops = {\n\t.init             = vidtv_tuner_init,\n\t.sleep            = vidtv_tuner_sleep,\n\t.suspend          = vidtv_tuner_suspend,\n\t.resume           = vidtv_tuner_resume,\n\t.set_params       = vidtv_tuner_set_params,\n\t.set_config       = vidtv_tuner_set_config,\n\t.get_bandwidth    = vidtv_tuner_get_bandwidth,\n\t.get_frequency    = vidtv_tuner_get_frequency,\n\t.get_if_frequency = vidtv_tuner_get_if_frequency,\n\t.get_status       = vidtv_tuner_get_status,\n\t.get_rf_strength  = vidtv_tuner_get_signal_strength\n};\n\nstatic const struct i2c_device_id vidtv_tuner_i2c_id_table[] = {\n\t{\"dvb_vidtv_tuner\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, vidtv_tuner_i2c_id_table);\n\nstatic int vidtv_tuner_i2c_probe(struct i2c_client *client)\n{\n\tstruct vidtv_tuner_config *config = client->dev.platform_data;\n\tstruct dvb_frontend *fe           = config->fe;\n\tstruct vidtv_tuner_dev *tuner_dev = NULL;\n\n\ttuner_dev = kzalloc(sizeof(*tuner_dev), GFP_KERNEL);\n\tif (!tuner_dev)\n\t\treturn -ENOMEM;\n\n\ttuner_dev->fe = config->fe;\n\ti2c_set_clientdata(client, tuner_dev);\n\n\tmemcpy(&fe->ops.tuner_ops,\n\t       &vidtv_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tmemcpy(&tuner_dev->config, config, sizeof(tuner_dev->config));\n\tfe->tuner_priv = client;\n\n\treturn 0;\n}\n\nstatic void vidtv_tuner_i2c_remove(struct i2c_client *client)\n{\n\tstruct vidtv_tuner_dev *tuner_dev = i2c_get_clientdata(client);\n\n\tkfree(tuner_dev);\n}\n\nstatic struct i2c_driver vidtv_tuner_i2c_driver = {\n\t.driver = {\n\t\t.name                = \"dvb_vidtv_tuner\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe    = vidtv_tuner_i2c_probe,\n\t.remove   = vidtv_tuner_i2c_remove,\n\t.id_table = vidtv_tuner_i2c_id_table,\n};\nmodule_i2c_driver(vidtv_tuner_i2c_driver);\n\nMODULE_DESCRIPTION(\"Virtual DVB Tuner\");\nMODULE_AUTHOR(\"Daniel W. S. Almeida\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}