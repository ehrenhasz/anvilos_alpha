{
  "module_name": "vidtv_ts.c",
  "hash_id": "e1559327c4ef0a3b4a79bb831abc44f2e86973d8b1bad3d15b56eee1e7e72f7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_ts.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s, %d: \" fmt, __func__, __LINE__\n\n#include <linux/math64.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/types.h>\n\n#include \"vidtv_common.h\"\n#include \"vidtv_ts.h\"\n\nstatic u32 vidtv_ts_write_pcr_bits(u8 *to, u32 to_offset, u64 pcr)\n{\n\t \n\tu64 div;\n\tu64 rem;\n\tu8 *buf = to + to_offset;\n\tu64 pcr_low;\n\tu64 pcr_high;\n\n\tdiv = div64_u64_rem(pcr, 300, &rem);\n\n\tpcr_low = rem;  \n\tpcr_high = div;  \n\n\t*buf++ = pcr_high >> 25;\n\t*buf++ = pcr_high >> 17;\n\t*buf++ = pcr_high >>  9;\n\t*buf++ = pcr_high >>  1;\n\t*buf++ = pcr_high <<  7 | pcr_low >> 8 | 0x7e;\n\t*buf++ = pcr_low;\n\n\treturn 6;\n}\n\nvoid vidtv_ts_inc_cc(u8 *continuity_counter)\n{\n\t++*continuity_counter;\n\tif (*continuity_counter > TS_CC_MAX_VAL)\n\t\t*continuity_counter = 0;\n}\n\nu32 vidtv_ts_null_write_into(struct null_packet_write_args args)\n{\n\tu32 nbytes = 0;\n\tstruct vidtv_mpeg_ts ts_header = {};\n\n\tts_header.sync_byte          = TS_SYNC_BYTE;\n\tts_header.bitfield           = cpu_to_be16(TS_NULL_PACKET_PID);\n\tts_header.payload            = 1;\n\tts_header.continuity_counter = *args.continuity_counter;\n\n\t \n\tnbytes += vidtv_memcpy(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.buf_sz,\n\t\t\t       &ts_header,\n\t\t\t       sizeof(ts_header));\n\n\tvidtv_ts_inc_cc(args.continuity_counter);\n\n\t \n\tnbytes += vidtv_memset(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.buf_sz,\n\t\t\t       TS_FILL_BYTE,\n\t\t\t       TS_PACKET_LEN - nbytes);\n\n\t \n\tif (nbytes != TS_PACKET_LEN)\n\t\tpr_warn_ratelimited(\"Expected exactly %d bytes, got %d\\n\",\n\t\t\t\t    TS_PACKET_LEN,\n\t\t\t\t    nbytes);\n\n\treturn nbytes;\n}\n\nu32 vidtv_ts_pcr_write_into(struct pcr_write_args args)\n{\n\tu32 nbytes = 0;\n\tstruct vidtv_mpeg_ts ts_header = {};\n\tstruct vidtv_mpeg_ts_adaption ts_adap = {};\n\n\tts_header.sync_byte     = TS_SYNC_BYTE;\n\tts_header.bitfield      = cpu_to_be16(args.pid);\n\tts_header.scrambling    = 0;\n\t \n\tts_header.continuity_counter = *args.continuity_counter;\n\tts_header.payload            = 0;\n\tts_header.adaptation_field   = 1;\n\n\t \n\tts_adap.length = 183;\n\tts_adap.PCR    = 1;\n\n\t \n\tnbytes += vidtv_memcpy(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.buf_sz,\n\t\t\t       &ts_header,\n\t\t\t       sizeof(ts_header));\n\n\t \n\tnbytes += vidtv_memcpy(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.buf_sz,\n\t\t\t       &ts_adap,\n\t\t\t       sizeof(ts_adap));\n\n\t \n\tnbytes += vidtv_ts_write_pcr_bits(args.dest_buf,\n\t\t\t\t\t  args.dest_offset + nbytes,\n\t\t\t\t\t  args.pcr);\n\n\tnbytes += vidtv_memset(args.dest_buf,\n\t\t\t       args.dest_offset + nbytes,\n\t\t\t       args.buf_sz,\n\t\t\t       TS_FILL_BYTE,\n\t\t\t       TS_PACKET_LEN - nbytes);\n\n\t \n\tif (nbytes != TS_PACKET_LEN)\n\t\tpr_warn_ratelimited(\"Expected exactly %d bytes, got %d\\n\",\n\t\t\t\t    TS_PACKET_LEN,\n\t\t\t\t    nbytes);\n\n\treturn nbytes;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}