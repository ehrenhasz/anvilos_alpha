{
  "module_name": "vidtv_bridge.c",
  "hash_id": "13132275f6a338d97edc28ce78943a1e36ae91cfdc4fbe128989f431f39959f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_bridge.c",
  "human_readable_source": "\n \n\n#include <linux/dev_printk.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <media/dvbdev.h>\n#include <media/media-device.h>\n\n#include \"vidtv_bridge.h\"\n#include \"vidtv_common.h\"\n#include \"vidtv_demod.h\"\n#include \"vidtv_mux.h\"\n#include \"vidtv_ts.h\"\n#include \"vidtv_tuner.h\"\n\n#define MUX_BUF_MIN_SZ 90164\n#define MUX_BUF_MAX_SZ (MUX_BUF_MIN_SZ * 10)\n#define TUNER_DEFAULT_ADDR 0x68\n#define DEMOD_DEFAULT_ADDR 0x60\n#define VIDTV_DEFAULT_NETWORK_ID 0xff44\n#define VIDTV_DEFAULT_NETWORK_NAME \"LinuxTV.org\"\n#define VIDTV_DEFAULT_TS_ID 0x4081\n\n \n#define LNB_CUT_FREQUENCY\t11700000\t \n#define LNB_LOW_FREQ\t\t9750000\t\t \n#define LNB_HIGH_FREQ\t\t10600000\t \n\nstatic unsigned int drop_tslock_prob_on_low_snr;\nmodule_param(drop_tslock_prob_on_low_snr, uint, 0);\nMODULE_PARM_DESC(drop_tslock_prob_on_low_snr,\n\t\t \"Probability of losing the TS lock if the signal quality is bad\");\n\nstatic unsigned int recover_tslock_prob_on_good_snr;\nmodule_param(recover_tslock_prob_on_good_snr, uint, 0);\nMODULE_PARM_DESC(recover_tslock_prob_on_good_snr,\n\t\t \"Probability recovering the TS lock when the signal improves\");\n\nstatic unsigned int mock_power_up_delay_msec;\nmodule_param(mock_power_up_delay_msec, uint, 0);\nMODULE_PARM_DESC(mock_power_up_delay_msec, \"Simulate a power up delay\");\n\nstatic unsigned int mock_tune_delay_msec;\nmodule_param(mock_tune_delay_msec, uint, 0);\nMODULE_PARM_DESC(mock_tune_delay_msec, \"Simulate a tune delay\");\n\nstatic unsigned int vidtv_valid_dvb_t_freqs[NUM_VALID_TUNER_FREQS] = {\n\t474000000\n};\n\nmodule_param_array(vidtv_valid_dvb_t_freqs, uint, NULL, 0);\nMODULE_PARM_DESC(vidtv_valid_dvb_t_freqs,\n\t\t \"Valid DVB-T frequencies to simulate, in Hz\");\n\nstatic unsigned int vidtv_valid_dvb_c_freqs[NUM_VALID_TUNER_FREQS] = {\n\t474000000\n};\n\nmodule_param_array(vidtv_valid_dvb_c_freqs, uint, NULL, 0);\nMODULE_PARM_DESC(vidtv_valid_dvb_c_freqs,\n\t\t \"Valid DVB-C frequencies to simulate, in Hz\");\n\nstatic unsigned int vidtv_valid_dvb_s_freqs[NUM_VALID_TUNER_FREQS] = {\n\t11362000\n};\nmodule_param_array(vidtv_valid_dvb_s_freqs, uint, NULL, 0);\nMODULE_PARM_DESC(vidtv_valid_dvb_s_freqs,\n\t\t \"Valid DVB-S/S2 frequencies to simulate at Ku-Band, in kHz\");\n\nstatic unsigned int max_frequency_shift_hz;\nmodule_param(max_frequency_shift_hz, uint, 0);\nMODULE_PARM_DESC(max_frequency_shift_hz,\n\t\t \"Maximum shift in HZ allowed when tuning in a channel\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nums);\n\n \nstatic unsigned int si_period_msec = 40;\nmodule_param(si_period_msec, uint, 0);\nMODULE_PARM_DESC(si_period_msec, \"How often to send SI packets. Default: 40ms\");\n\nstatic unsigned int pcr_period_msec = 40;\nmodule_param(pcr_period_msec, uint, 0);\nMODULE_PARM_DESC(pcr_period_msec,\n\t\t \"How often to send PCR packets. Default: 40ms\");\n\nstatic unsigned int mux_rate_kbytes_sec = 4096;\nmodule_param(mux_rate_kbytes_sec, uint, 0);\nMODULE_PARM_DESC(mux_rate_kbytes_sec, \"Mux rate: will pad stream if below\");\n\nstatic unsigned int pcr_pid = 0x200;\nmodule_param(pcr_pid, uint, 0);\nMODULE_PARM_DESC(pcr_pid, \"PCR PID for all channels: defaults to 0x200\");\n\nstatic unsigned int mux_buf_sz_pkts;\nmodule_param(mux_buf_sz_pkts, uint, 0);\nMODULE_PARM_DESC(mux_buf_sz_pkts,\n\t\t \"Size for the internal mux buffer in multiples of 188 bytes\");\n\nstatic u32 vidtv_bridge_mux_buf_sz_for_mux_rate(void)\n{\n\tu32 max_elapsed_time_msecs =  VIDTV_MAX_SLEEP_USECS / USEC_PER_MSEC;\n\tu32 mux_buf_sz = mux_buf_sz_pkts * TS_PACKET_LEN;\n\tu32 nbytes_expected;\n\n\tnbytes_expected = mux_rate_kbytes_sec;\n\tnbytes_expected *= max_elapsed_time_msecs;\n\n\tmux_buf_sz = roundup(nbytes_expected, TS_PACKET_LEN);\n\tmux_buf_sz += mux_buf_sz / 10;\n\n\tif (mux_buf_sz < MUX_BUF_MIN_SZ)\n\t\tmux_buf_sz = MUX_BUF_MIN_SZ;\n\n\tif (mux_buf_sz > MUX_BUF_MAX_SZ)\n\t\tmux_buf_sz = MUX_BUF_MAX_SZ;\n\n\treturn mux_buf_sz;\n}\n\nstatic bool vidtv_bridge_check_demod_lock(struct vidtv_dvb *dvb, u32 n)\n{\n\tenum fe_status status;\n\n\tdvb->fe[n]->ops.read_status(dvb->fe[n], &status);\n\n\treturn status == (FE_HAS_SIGNAL  |\n\t\t\t  FE_HAS_CARRIER |\n\t\t\t  FE_HAS_VITERBI |\n\t\t\t  FE_HAS_SYNC    |\n\t\t\t  FE_HAS_LOCK);\n}\n\n \nstatic void vidtv_bridge_on_new_pkts_avail(void *priv, u8 *buf, u32 npkts)\n{\n\tstruct vidtv_dvb *dvb = priv;\n\n\t \n\tif (vidtv_bridge_check_demod_lock(dvb, 0))\n\t\tdvb_dmx_swfilter_packets(&dvb->demux, buf, npkts);\n}\n\nstatic int vidtv_start_streaming(struct vidtv_dvb *dvb)\n{\n\tstruct vidtv_mux_init_args mux_args = {\n\t\t.mux_rate_kbytes_sec         = mux_rate_kbytes_sec,\n\t\t.on_new_packets_available_cb = vidtv_bridge_on_new_pkts_avail,\n\t\t.pcr_period_usecs            = pcr_period_msec * USEC_PER_MSEC,\n\t\t.si_period_usecs             = si_period_msec * USEC_PER_MSEC,\n\t\t.pcr_pid                     = pcr_pid,\n\t\t.transport_stream_id         = VIDTV_DEFAULT_TS_ID,\n\t\t.network_id                  = VIDTV_DEFAULT_NETWORK_ID,\n\t\t.network_name                = VIDTV_DEFAULT_NETWORK_NAME,\n\t\t.priv                        = dvb,\n\t};\n\tstruct device *dev = &dvb->pdev->dev;\n\tu32 mux_buf_sz;\n\n\tif (dvb->streaming) {\n\t\tdev_warn_ratelimited(dev, \"Already streaming. Skipping.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mux_buf_sz_pkts)\n\t\tmux_buf_sz = mux_buf_sz_pkts;\n\telse\n\t\tmux_buf_sz = vidtv_bridge_mux_buf_sz_for_mux_rate();\n\n\tmux_args.mux_buf_sz  = mux_buf_sz;\n\n\tdvb->streaming = true;\n\tdvb->mux = vidtv_mux_init(dvb->fe[0], dev, &mux_args);\n\tif (!dvb->mux)\n\t\treturn -ENOMEM;\n\tvidtv_mux_start_thread(dvb->mux);\n\n\tdev_dbg_ratelimited(dev, \"Started streaming\\n\");\n\treturn 0;\n}\n\nstatic int vidtv_stop_streaming(struct vidtv_dvb *dvb)\n{\n\tstruct device *dev = &dvb->pdev->dev;\n\n\tdvb->streaming = false;\n\tvidtv_mux_stop_thread(dvb->mux);\n\tvidtv_mux_destroy(dvb->mux);\n\tdvb->mux = NULL;\n\n\tdev_dbg_ratelimited(dev, \"Stopped streaming\\n\");\n\treturn 0;\n}\n\nstatic int vidtv_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct vidtv_dvb *dvb   = demux->priv;\n\tint ret;\n\tint rc;\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dvb->feed_lock);\n\n\tdvb->nfeeds++;\n\trc = dvb->nfeeds;\n\n\tif (dvb->nfeeds == 1) {\n\t\tret = vidtv_start_streaming(dvb);\n\t\tif (ret < 0)\n\t\t\trc = ret;\n\t}\n\n\tmutex_unlock(&dvb->feed_lock);\n\treturn rc;\n}\n\nstatic int vidtv_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct vidtv_dvb *dvb   = demux->priv;\n\tint err = 0;\n\n\tmutex_lock(&dvb->feed_lock);\n\tdvb->nfeeds--;\n\n\tif (!dvb->nfeeds)\n\t\terr = vidtv_stop_streaming(dvb);\n\n\tmutex_unlock(&dvb->feed_lock);\n\treturn err;\n}\n\nstatic struct dvb_frontend *vidtv_get_frontend_ptr(struct i2c_client *c)\n{\n\tstruct vidtv_demod_state *state = i2c_get_clientdata(c);\n\n\t \n\treturn &state->frontend;\n}\n\nstatic int vidtv_master_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t     struct i2c_msg msgs[],\n\t\t\t     int num)\n{\n\t \n\treturn 0;\n}\n\nstatic u32 vidtv_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm vidtv_i2c_algorithm = {\n\t.master_xfer   = vidtv_master_xfer,\n\t.functionality = vidtv_i2c_func,\n};\n\nstatic int vidtv_bridge_i2c_register_adap(struct vidtv_dvb *dvb)\n{\n\tstruct i2c_adapter *i2c_adapter = &dvb->i2c_adapter;\n\n\tstrscpy(i2c_adapter->name, \"vidtv_i2c\", sizeof(i2c_adapter->name));\n\ti2c_adapter->owner      = THIS_MODULE;\n\ti2c_adapter->algo       = &vidtv_i2c_algorithm;\n\ti2c_adapter->algo_data  = NULL;\n\ti2c_adapter->timeout    = 500;\n\ti2c_adapter->retries    = 3;\n\ti2c_adapter->dev.parent = &dvb->pdev->dev;\n\n\ti2c_set_adapdata(i2c_adapter, dvb);\n\treturn i2c_add_adapter(&dvb->i2c_adapter);\n}\n\nstatic int vidtv_bridge_register_adap(struct vidtv_dvb *dvb)\n{\n\tint ret = 0;\n\n\tret = dvb_register_adapter(&dvb->adapter,\n\t\t\t\t   KBUILD_MODNAME,\n\t\t\t\t   THIS_MODULE,\n\t\t\t\t   &dvb->i2c_adapter.dev,\n\t\t\t\t   adapter_nums);\n\n\treturn ret;\n}\n\nstatic int vidtv_bridge_dmx_init(struct vidtv_dvb *dvb)\n{\n\tdvb->demux.dmx.capabilities = DMX_TS_FILTERING |\n\t\t\t\t      DMX_SECTION_FILTERING;\n\n\tdvb->demux.priv       = dvb;\n\tdvb->demux.filternum  = 256;\n\tdvb->demux.feednum    = 256;\n\tdvb->demux.start_feed = vidtv_start_feed;\n\tdvb->demux.stop_feed  = vidtv_stop_feed;\n\n\treturn dvb_dmx_init(&dvb->demux);\n}\n\nstatic int vidtv_bridge_dmxdev_init(struct vidtv_dvb *dvb)\n{\n\tdvb->dmx_dev.filternum    = 256;\n\tdvb->dmx_dev.demux        = &dvb->demux.dmx;\n\tdvb->dmx_dev.capabilities = 0;\n\n\treturn dvb_dmxdev_init(&dvb->dmx_dev, &dvb->adapter);\n}\n\nstatic int vidtv_bridge_probe_demod(struct vidtv_dvb *dvb, u32 n)\n{\n\tstruct vidtv_demod_config cfg = {\n\t\t.drop_tslock_prob_on_low_snr     = drop_tslock_prob_on_low_snr,\n\t\t.recover_tslock_prob_on_good_snr = recover_tslock_prob_on_good_snr,\n\t};\n\tdvb->i2c_client_demod[n] = dvb_module_probe(\"dvb_vidtv_demod\",\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    &dvb->i2c_adapter,\n\t\t\t\t\t\t    DEMOD_DEFAULT_ADDR,\n\t\t\t\t\t\t    &cfg);\n\n\t \n\tif (!dvb->i2c_client_demod[n])\n\t\treturn -ENODEV;\n\n\t \n\tdvb->fe[n] = vidtv_get_frontend_ptr(dvb->i2c_client_demod[n]);\n\n\treturn 0;\n}\n\nstatic int vidtv_bridge_probe_tuner(struct vidtv_dvb *dvb, u32 n)\n{\n\tstruct vidtv_tuner_config cfg = {\n\t\t.fe                       = dvb->fe[n],\n\t\t.mock_power_up_delay_msec = mock_power_up_delay_msec,\n\t\t.mock_tune_delay_msec     = mock_tune_delay_msec,\n\t};\n\tu32 freq;\n\tint i;\n\n\t \n\n\tmemcpy(cfg.vidtv_valid_dvb_t_freqs,\n\t       vidtv_valid_dvb_t_freqs,\n\t       sizeof(vidtv_valid_dvb_t_freqs));\n\n\tmemcpy(cfg.vidtv_valid_dvb_c_freqs,\n\t       vidtv_valid_dvb_c_freqs,\n\t       sizeof(vidtv_valid_dvb_c_freqs));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vidtv_valid_dvb_s_freqs); i++) {\n\t\tfreq = vidtv_valid_dvb_s_freqs[i];\n\t\tif (freq) {\n\t\t\tif (freq < LNB_CUT_FREQUENCY)\n\t\t\t\tfreq = abs(freq - LNB_LOW_FREQ);\n\t\t\telse\n\t\t\t\tfreq = abs(freq - LNB_HIGH_FREQ);\n\t\t}\n\t\tcfg.vidtv_valid_dvb_s_freqs[i] = freq;\n\t}\n\n\tcfg.max_frequency_shift_hz = max_frequency_shift_hz;\n\n\tdvb->i2c_client_tuner[n] = dvb_module_probe(\"dvb_vidtv_tuner\",\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    &dvb->i2c_adapter,\n\t\t\t\t\t\t    TUNER_DEFAULT_ADDR,\n\t\t\t\t\t\t    &cfg);\n\n\treturn (dvb->i2c_client_tuner[n]) ? 0 : -ENODEV;\n}\n\nstatic int vidtv_bridge_dvb_init(struct vidtv_dvb *dvb)\n{\n\tint ret, i, j;\n\n\tret = vidtv_bridge_i2c_register_adap(dvb);\n\tif (ret < 0)\n\t\tgoto fail_i2c;\n\n\tret = vidtv_bridge_register_adap(dvb);\n\tif (ret < 0)\n\t\tgoto fail_adapter;\n\tdvb_register_media_controller(&dvb->adapter, &dvb->mdev);\n\n\tfor (i = 0; i < NUM_FE; ++i) {\n\t\tret = vidtv_bridge_probe_demod(dvb, i);\n\t\tif (ret < 0)\n\t\t\tgoto fail_demod_probe;\n\n\t\tret = vidtv_bridge_probe_tuner(dvb, i);\n\t\tif (ret < 0)\n\t\t\tgoto fail_tuner_probe;\n\n\t\tret = dvb_register_frontend(&dvb->adapter, dvb->fe[i]);\n\t\tif (ret < 0)\n\t\t\tgoto fail_fe;\n\t}\n\n\tret = vidtv_bridge_dmx_init(dvb);\n\tif (ret < 0)\n\t\tgoto fail_dmx;\n\n\tret = vidtv_bridge_dmxdev_init(dvb);\n\tif (ret < 0)\n\t\tgoto fail_dmx_dev;\n\n\tfor (j = 0; j < NUM_FE; ++j) {\n\t\tret = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx,\n\t\t\t\t\t\t      &dvb->dmx_fe[j]);\n\t\tif (ret < 0)\n\t\t\tgoto fail_dmx_conn;\n\n\t\t \n\t\tdvb->dmx_fe[j].source = DMX_FRONTEND_0;\n\t}\n\n\treturn ret;\n\nfail_dmx_conn:\n\tfor (j = j - 1; j >= 0; --j)\n\t\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx,\n\t\t\t\t\t       &dvb->dmx_fe[j]);\n\tdvb_dmxdev_release(&dvb->dmx_dev);\nfail_dmx_dev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\nfail_demod_probe:\n\tfor (i = i - 1; i >= 0; --i) {\n\t\tdvb_unregister_frontend(dvb->fe[i]);\nfail_fe:\n\t\tdvb_module_release(dvb->i2c_client_tuner[i]);\nfail_tuner_probe:\n\t\tdvb_module_release(dvb->i2c_client_demod[i]);\n\t}\nfail_adapter:\n\tdvb_unregister_adapter(&dvb->adapter);\nfail_i2c:\n\ti2c_del_adapter(&dvb->i2c_adapter);\n\n\treturn ret;\n}\n\nstatic int vidtv_bridge_probe(struct platform_device *pdev)\n{\n\tstruct vidtv_dvb *dvb;\n\tint ret;\n\n\tdvb = kzalloc(sizeof(*dvb), GFP_KERNEL);\n\tif (!dvb)\n\t\treturn -ENOMEM;\n\n\tdvb->pdev = pdev;\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tdvb->mdev.dev = &pdev->dev;\n\n\tstrscpy(dvb->mdev.model, \"vidtv\", sizeof(dvb->mdev.model));\n\tstrscpy(dvb->mdev.bus_info, \"platform:vidtv\", sizeof(dvb->mdev.bus_info));\n\n\tmedia_device_init(&dvb->mdev);\n#endif\n\n\tret = vidtv_bridge_dvb_init(dvb);\n\tif (ret < 0)\n\t\tgoto err_dvb;\n\n\tmutex_init(&dvb->feed_lock);\n\n\tplatform_set_drvdata(pdev, dvb);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tret = media_device_register(&dvb->mdev);\n\tif (ret) {\n\t\tdev_err(dvb->mdev.dev,\n\t\t\t\"media device register failed (err=%d)\\n\", ret);\n\t\tgoto err_media_device_register;\n\t}\n#endif  \n\n\tdev_info(&pdev->dev, \"Successfully initialized vidtv!\\n\");\n\treturn ret;\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\nerr_media_device_register:\n\tmedia_device_cleanup(&dvb->mdev);\n#endif  \nerr_dvb:\n\tkfree(dvb);\n\treturn ret;\n}\n\nstatic void vidtv_bridge_remove(struct platform_device *pdev)\n{\n\tstruct vidtv_dvb *dvb;\n\tu32 i;\n\n\tdvb = platform_get_drvdata(pdev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tmedia_device_unregister(&dvb->mdev);\n\tmedia_device_cleanup(&dvb->mdev);\n#endif  \n\n\tmutex_destroy(&dvb->feed_lock);\n\n\tfor (i = 0; i < NUM_FE; ++i) {\n\t\tdvb_unregister_frontend(dvb->fe[i]);\n\t\tdvb_module_release(dvb->i2c_client_tuner[i]);\n\t\tdvb_module_release(dvb->i2c_client_demod[i]);\n\t}\n\n\tdvb_dmxdev_release(&dvb->dmx_dev);\n\tdvb_dmx_release(&dvb->demux);\n\tdvb_unregister_adapter(&dvb->adapter);\n\tdev_info(&pdev->dev, \"Successfully removed vidtv\\n\");\n}\n\nstatic void vidtv_bridge_dev_release(struct device *dev)\n{\n\tstruct vidtv_dvb *dvb;\n\n\tdvb = dev_get_drvdata(dev);\n\tkfree(dvb);\n}\n\nstatic struct platform_device vidtv_bridge_dev = {\n\t.name\t\t= VIDTV_PDEV_NAME,\n\t.dev.release\t= vidtv_bridge_dev_release,\n};\n\nstatic struct platform_driver vidtv_bridge_driver = {\n\t.driver = {\n\t\t.name = VIDTV_PDEV_NAME,\n\t},\n\t.probe    = vidtv_bridge_probe,\n\t.remove_new = vidtv_bridge_remove,\n};\n\nstatic void __exit vidtv_bridge_exit(void)\n{\n\tplatform_driver_unregister(&vidtv_bridge_driver);\n\tplatform_device_unregister(&vidtv_bridge_dev);\n}\n\nstatic int __init vidtv_bridge_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&vidtv_bridge_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&vidtv_bridge_driver);\n\tif (ret)\n\t\tplatform_device_unregister(&vidtv_bridge_dev);\n\n\treturn ret;\n}\n\nmodule_init(vidtv_bridge_init);\nmodule_exit(vidtv_bridge_exit);\n\nMODULE_DESCRIPTION(\"Virtual Digital TV Test Driver\");\nMODULE_AUTHOR(\"Daniel W. S. Almeida\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"vidtv\");\nMODULE_ALIAS(\"dvb_vidtv\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}