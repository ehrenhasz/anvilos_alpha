{
  "module_name": "vidtv_mux.c",
  "hash_id": "a06f2327ce13012d4b8218eb8c4c3b9bf1c550f4e4864612c3db25108bc3d381",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_mux.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dev_printk.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\n#include \"vidtv_channel.h\"\n#include \"vidtv_common.h\"\n#include \"vidtv_encoder.h\"\n#include \"vidtv_mux.h\"\n#include \"vidtv_pes.h\"\n#include \"vidtv_psi.h\"\n#include \"vidtv_ts.h\"\n\nstatic struct vidtv_mux_pid_ctx\n*vidtv_mux_get_pid_ctx(struct vidtv_mux *m, u16 pid)\n{\n\tstruct vidtv_mux_pid_ctx *ctx;\n\n\thash_for_each_possible(m->pid_ctx, ctx, h, pid)\n\t\tif (ctx->pid == pid)\n\t\t\treturn ctx;\n\treturn NULL;\n}\n\nstatic struct vidtv_mux_pid_ctx\n*vidtv_mux_create_pid_ctx_once(struct vidtv_mux *m, u16 pid)\n{\n\tstruct vidtv_mux_pid_ctx *ctx;\n\n\tctx = vidtv_mux_get_pid_ctx(m, pid);\n\tif (ctx)\n\t\treturn ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->pid = pid;\n\tctx->cc  = 0;\n\thash_add(m->pid_ctx, &ctx->h, pid);\n\n\treturn ctx;\n}\n\nstatic void vidtv_mux_pid_ctx_destroy(struct vidtv_mux *m)\n{\n\tstruct vidtv_mux_pid_ctx *ctx;\n\tstruct hlist_node *tmp;\n\tint bkt;\n\n\thash_for_each_safe(m->pid_ctx, bkt, tmp, ctx, h) {\n\t\thash_del(&ctx->h);\n\t\tkfree(ctx);\n\t}\n}\n\nstatic int vidtv_mux_pid_ctx_init(struct vidtv_mux *m)\n{\n\tstruct vidtv_psi_table_pat_program *p = m->si.pat->program;\n\tu16 pid;\n\n\thash_init(m->pid_ctx);\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, m->pcr_pid))\n\t\treturn -ENOMEM;\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, TS_NULL_PACKET_PID))\n\t\tgoto free;\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, VIDTV_PAT_PID))\n\t\tgoto free;\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, VIDTV_SDT_PID))\n\t\tgoto free;\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, VIDTV_NIT_PID))\n\t\tgoto free;\n\t \n\tif (!vidtv_mux_create_pid_ctx_once(m, VIDTV_EIT_PID))\n\t\tgoto free;\n\n\t \n\twhile (p) {\n\t\tpid = vidtv_psi_get_pat_program_pid(p);\n\t\tvidtv_mux_create_pid_ctx_once(m, pid);\n\t\tp = p->next;\n\t}\n\n\treturn 0;\n\nfree:\n\tvidtv_mux_pid_ctx_destroy(m);\n\treturn -ENOMEM;\n}\n\nstatic void vidtv_mux_update_clk(struct vidtv_mux *m)\n{\n\t \n\tu64 elapsed_time;\n\n\tm->timing.past_jiffies = m->timing.current_jiffies;\n\tm->timing.current_jiffies = get_jiffies_64();\n\n\telapsed_time = jiffies_to_usecs(m->timing.current_jiffies -\n\t\t\t\t\tm->timing.past_jiffies);\n\n\t \n\tm->timing.clk += (CLOCK_UNIT_27MHZ / USEC_PER_SEC) * elapsed_time;\n}\n\nstatic u32 vidtv_mux_push_si(struct vidtv_mux *m)\n{\n\tstruct vidtv_psi_pat_write_args pat_args = {\n\t\t.buf                = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.pat                = m->si.pat,\n\t};\n\tstruct vidtv_psi_pmt_write_args pmt_args = {\n\t\t.buf                = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.pcr_pid            = m->pcr_pid,\n\t};\n\tstruct vidtv_psi_sdt_write_args sdt_args = {\n\t\t.buf                = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.sdt                = m->si.sdt,\n\t};\n\tstruct vidtv_psi_nit_write_args nit_args = {\n\t\t.buf                = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.nit                = m->si.nit,\n\n\t};\n\tstruct vidtv_psi_eit_write_args eit_args = {\n\t\t.buf                = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.eit                = m->si.eit,\n\t};\n\tu32 initial_offset = m->mux_buf_offset;\n\tstruct vidtv_mux_pid_ctx *pat_ctx;\n\tstruct vidtv_mux_pid_ctx *pmt_ctx;\n\tstruct vidtv_mux_pid_ctx *sdt_ctx;\n\tstruct vidtv_mux_pid_ctx *nit_ctx;\n\tstruct vidtv_mux_pid_ctx *eit_ctx;\n\tu32 nbytes;\n\tu16 pmt_pid;\n\tu32 i;\n\n\tpat_ctx = vidtv_mux_get_pid_ctx(m, VIDTV_PAT_PID);\n\tsdt_ctx = vidtv_mux_get_pid_ctx(m, VIDTV_SDT_PID);\n\tnit_ctx = vidtv_mux_get_pid_ctx(m, VIDTV_NIT_PID);\n\teit_ctx = vidtv_mux_get_pid_ctx(m, VIDTV_EIT_PID);\n\n\tpat_args.offset             = m->mux_buf_offset;\n\tpat_args.continuity_counter = &pat_ctx->cc;\n\n\tm->mux_buf_offset += vidtv_psi_pat_write_into(&pat_args);\n\n\tfor (i = 0; i < m->si.pat->num_pmt; ++i) {\n\t\tpmt_pid = vidtv_psi_pmt_get_pid(m->si.pmt_secs[i],\n\t\t\t\t\t\tm->si.pat);\n\n\t\tif (pmt_pid > TS_LAST_VALID_PID) {\n\t\t\tdev_warn_ratelimited(m->dev,\n\t\t\t\t\t     \"PID: %d not found\\n\", pmt_pid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpmt_ctx = vidtv_mux_get_pid_ctx(m, pmt_pid);\n\n\t\tpmt_args.offset             = m->mux_buf_offset;\n\t\tpmt_args.pmt                = m->si.pmt_secs[i];\n\t\tpmt_args.pid                = pmt_pid;\n\t\tpmt_args.continuity_counter = &pmt_ctx->cc;\n\n\t\t \n\t\tm->mux_buf_offset += vidtv_psi_pmt_write_into(&pmt_args);\n\t}\n\n\tsdt_args.offset             = m->mux_buf_offset;\n\tsdt_args.continuity_counter = &sdt_ctx->cc;\n\n\tm->mux_buf_offset += vidtv_psi_sdt_write_into(&sdt_args);\n\n\tnit_args.offset             = m->mux_buf_offset;\n\tnit_args.continuity_counter = &nit_ctx->cc;\n\n\tm->mux_buf_offset += vidtv_psi_nit_write_into(&nit_args);\n\n\teit_args.offset             = m->mux_buf_offset;\n\teit_args.continuity_counter = &eit_ctx->cc;\n\n\tm->mux_buf_offset += vidtv_psi_eit_write_into(&eit_args);\n\n\tnbytes = m->mux_buf_offset - initial_offset;\n\n\tm->num_streamed_si++;\n\n\treturn nbytes;\n}\n\nstatic u32 vidtv_mux_push_pcr(struct vidtv_mux *m)\n{\n\tstruct pcr_write_args args = {};\n\tstruct vidtv_mux_pid_ctx *ctx;\n\tu32 nbytes = 0;\n\n\tctx                     = vidtv_mux_get_pid_ctx(m, m->pcr_pid);\n\targs.dest_buf           = m->mux_buf;\n\targs.pid                = m->pcr_pid;\n\targs.buf_sz             = m->mux_buf_sz;\n\targs.continuity_counter = &ctx->cc;\n\n\t \n\targs.pcr = m->timing.clk;\n\n\tnbytes += vidtv_ts_pcr_write_into(args);\n\tm->mux_buf_offset += nbytes;\n\n\tm->num_streamed_pcr++;\n\n\treturn nbytes;\n}\n\nstatic bool vidtv_mux_should_push_pcr(struct vidtv_mux *m)\n{\n\tu64 next_pcr_at;\n\n\tif (m->num_streamed_pcr == 0)\n\t\treturn true;\n\n\tnext_pcr_at = m->timing.start_jiffies +\n\t\t      usecs_to_jiffies(m->num_streamed_pcr *\n\t\t\t\t       m->timing.pcr_period_usecs);\n\n\treturn time_after64(m->timing.current_jiffies, next_pcr_at);\n}\n\nstatic bool vidtv_mux_should_push_si(struct vidtv_mux *m)\n{\n\tu64 next_si_at;\n\n\tif (m->num_streamed_si == 0)\n\t\treturn true;\n\n\tnext_si_at = m->timing.start_jiffies +\n\t\t     usecs_to_jiffies(m->num_streamed_si *\n\t\t\t\t      m->timing.si_period_usecs);\n\n\treturn time_after64(m->timing.current_jiffies, next_si_at);\n}\n\nstatic u32 vidtv_mux_packetize_access_units(struct vidtv_mux *m,\n\t\t\t\t\t    struct vidtv_encoder *e)\n{\n\tstruct pes_write_args args = {\n\t\t.dest_buf           = m->mux_buf,\n\t\t.dest_buf_sz        = m->mux_buf_sz,\n\t\t.pid                = be16_to_cpu(e->es_pid),\n\t\t.encoder_id         = e->id,\n\t\t.stream_id          = be16_to_cpu(e->stream_id),\n\t\t.send_pts           = true,   \n\t\t.send_dts           = false,  \n\t};\n\tstruct vidtv_access_unit *au = e->access_units;\n\tu32 initial_offset = m->mux_buf_offset;\n\tstruct vidtv_mux_pid_ctx *pid_ctx;\n\tu32 nbytes = 0;\n\tu8 *buf = NULL;\n\n\t \n\tif (args.encoder_id == S302M) {\n\t\targs.send_dts = false;\n\t\targs.send_pts = true;\n\t}\n\n\tpid_ctx = vidtv_mux_create_pid_ctx_once(m, be16_to_cpu(e->es_pid));\n\targs.continuity_counter = &pid_ctx->cc;\n\n\twhile (au) {\n\t\tbuf                  = e->encoder_buf + au->offset;\n\t\targs.from            = buf;\n\t\targs.access_unit_len = au->nbytes;\n\t\targs.dest_offset     = m->mux_buf_offset;\n\t\targs.pts             = au->pts;\n\t\targs.pcr\t     = m->timing.clk;\n\n\t\tm->mux_buf_offset += vidtv_pes_write_into(&args);\n\n\t\tau = au->next;\n\t}\n\n\t \n\te->clear(e);\n\n\tnbytes = m->mux_buf_offset - initial_offset;\n\treturn nbytes;\n}\n\nstatic u32 vidtv_mux_poll_encoders(struct vidtv_mux *m)\n{\n\tstruct vidtv_channel *cur_chnl = m->channels;\n\tstruct vidtv_encoder *e = NULL;\n\tu32 nbytes = 0;\n\tu32 au_nbytes;\n\n\twhile (cur_chnl) {\n\t\te = cur_chnl->encoders;\n\n\t\twhile (e) {\n\t\t\te->encode(e);\n\t\t\t \n\t\t\tau_nbytes = vidtv_mux_packetize_access_units(m, e);\n\t\t\tnbytes += au_nbytes;\n\t\t\tm->mux_buf_offset += au_nbytes;\n\t\t\t \n\t\t\te = e->next;\n\t\t}\n\n\t\t \n\t\tcur_chnl = cur_chnl->next;\n\t}\n\n\treturn nbytes;\n}\n\nstatic u32 vidtv_mux_pad_with_nulls(struct vidtv_mux *m, u32 npkts)\n{\n\tstruct null_packet_write_args args = {\n\t\t.dest_buf           = m->mux_buf,\n\t\t.buf_sz             = m->mux_buf_sz,\n\t\t.dest_offset        = m->mux_buf_offset,\n\t};\n\tu32 initial_offset = m->mux_buf_offset;\n\tstruct vidtv_mux_pid_ctx *ctx;\n\tu32 nbytes;\n\tu32 i;\n\n\tctx = vidtv_mux_get_pid_ctx(m, TS_NULL_PACKET_PID);\n\n\targs.continuity_counter = &ctx->cc;\n\n\tfor (i = 0; i < npkts; ++i) {\n\t\tm->mux_buf_offset += vidtv_ts_null_write_into(args);\n\t\targs.dest_offset  = m->mux_buf_offset;\n\t}\n\n\tnbytes = m->mux_buf_offset - initial_offset;\n\n\t \n\tif (nbytes != npkts * TS_PACKET_LEN)\n\t\tdev_err_ratelimited(m->dev, \"%d != %d\\n\",\n\t\t\t\t    nbytes, npkts * TS_PACKET_LEN);\n\n\treturn nbytes;\n}\n\nstatic void vidtv_mux_clear(struct vidtv_mux *m)\n{\n\t \n\tmemset(m->mux_buf, 0, m->mux_buf_sz * sizeof(*m->mux_buf));\n\t \n\tm->mux_buf_offset = 0;\n}\n\n#define ERR_RATE 10000000\nstatic void vidtv_mux_tick(struct work_struct *work)\n{\n\tstruct vidtv_mux *m = container_of(work,\n\t\t\t\t\t   struct vidtv_mux,\n\t\t\t\t\t   mpeg_thread);\n\tstruct dtv_frontend_properties *c = &m->fe->dtv_property_cache;\n\tu32 tot_bits = 0;\n\tu32 nbytes;\n\tu32 npkts;\n\n\twhile (m->streaming) {\n\t\tnbytes = 0;\n\n\t\tvidtv_mux_update_clk(m);\n\n\t\tif (vidtv_mux_should_push_pcr(m))\n\t\t\tnbytes += vidtv_mux_push_pcr(m);\n\n\t\tif (vidtv_mux_should_push_si(m))\n\t\t\tnbytes += vidtv_mux_push_si(m);\n\n\t\tnbytes += vidtv_mux_poll_encoders(m);\n\t\tnbytes += vidtv_mux_pad_with_nulls(m, 256);\n\n\t\tnpkts = nbytes / TS_PACKET_LEN;\n\n\t\t \n\t\tif (nbytes % TS_PACKET_LEN)\n\t\t\tdev_err_ratelimited(m->dev, \"Misaligned buffer\\n\");\n\n\t\tif (m->on_new_packets_available_cb)\n\t\t\tm->on_new_packets_available_cb(m->priv,\n\t\t\t\t\t\t       m->mux_buf,\n\t\t\t\t\t\t       npkts);\n\n\t\tvidtv_mux_clear(m);\n\n\t\t \n\t\tc->pre_bit_count.stat[0].uvalue = nbytes * 8;\n\t\tc->post_bit_count.stat[0].uvalue = nbytes * 8;\n\t\tc->block_count.stat[0].uvalue += npkts;\n\n\t\t \n\t\ttot_bits += nbytes * 8;\n\t\tif (tot_bits > ERR_RATE) {\n\t\t\tc->pre_bit_error.stat[0].uvalue++;\n\t\t\ttot_bits -= ERR_RATE;\n\t\t}\n\n\t\tusleep_range(VIDTV_SLEEP_USECS, VIDTV_MAX_SLEEP_USECS);\n\t}\n}\n\nvoid vidtv_mux_start_thread(struct vidtv_mux *m)\n{\n\tif (m->streaming) {\n\t\tdev_warn_ratelimited(m->dev, \"Already streaming. Skipping.\\n\");\n\t\treturn;\n\t}\n\n\tm->streaming = true;\n\tm->timing.start_jiffies = get_jiffies_64();\n\tschedule_work(&m->mpeg_thread);\n}\n\nvoid vidtv_mux_stop_thread(struct vidtv_mux *m)\n{\n\tif (m->streaming) {\n\t\tm->streaming = false;  \n\t\tcancel_work_sync(&m->mpeg_thread);\n\t}\n}\n\nstruct vidtv_mux *vidtv_mux_init(struct dvb_frontend *fe,\n\t\t\t\t struct device *dev,\n\t\t\t\t struct vidtv_mux_init_args *args)\n{\n\tstruct vidtv_mux *m;\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn NULL;\n\n\tm->dev = dev;\n\tm->fe = fe;\n\tm->timing.pcr_period_usecs = args->pcr_period_usecs;\n\tm->timing.si_period_usecs  = args->si_period_usecs;\n\n\tm->mux_rate_kbytes_sec = args->mux_rate_kbytes_sec;\n\n\tm->on_new_packets_available_cb = args->on_new_packets_available_cb;\n\n\tm->mux_buf = vzalloc(args->mux_buf_sz);\n\tif (!m->mux_buf)\n\t\tgoto free_mux;\n\n\tm->mux_buf_sz = args->mux_buf_sz;\n\n\tm->pcr_pid = args->pcr_pid;\n\tm->transport_stream_id = args->transport_stream_id;\n\tm->priv = args->priv;\n\tm->network_id = args->network_id;\n\tm->network_name = kstrdup(args->network_name, GFP_KERNEL);\n\tif (!m->network_name)\n\t\tgoto free_mux_buf;\n\n\tm->timing.current_jiffies = get_jiffies_64();\n\n\tif (args->channels)\n\t\tm->channels = args->channels;\n\telse\n\t\tif (vidtv_channels_init(m) < 0)\n\t\t\tgoto free_mux_network_name;\n\n\t \n\tif (vidtv_channel_si_init(m) < 0)\n\t\tgoto free_channels;\n\n\tINIT_WORK(&m->mpeg_thread, vidtv_mux_tick);\n\n\tif (vidtv_mux_pid_ctx_init(m) < 0)\n\t\tgoto free_channel_si;\n\n\treturn m;\n\nfree_channel_si:\n\tvidtv_channel_si_destroy(m);\nfree_channels:\n\tvidtv_channels_destroy(m);\nfree_mux_network_name:\n\tkfree(m->network_name);\nfree_mux_buf:\n\tvfree(m->mux_buf);\nfree_mux:\n\tkfree(m);\n\treturn NULL;\n}\n\nvoid vidtv_mux_destroy(struct vidtv_mux *m)\n{\n\tvidtv_mux_stop_thread(m);\n\tvidtv_mux_pid_ctx_destroy(m);\n\tvidtv_channel_si_destroy(m);\n\tvidtv_channels_destroy(m);\n\tkfree(m->network_name);\n\tvfree(m->mux_buf);\n\tkfree(m);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}