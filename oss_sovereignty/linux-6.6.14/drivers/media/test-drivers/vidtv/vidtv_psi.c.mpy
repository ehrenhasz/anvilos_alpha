{
  "module_name": "vidtv_psi.c",
  "hash_id": "08505964992e6750e59d10e74e54e692c391c8a40f1c46ee0344218e025650b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_psi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s, %d: \" fmt, __func__, __LINE__\n\n#include <linux/bcd.h>\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\n#include \"vidtv_common.h\"\n#include \"vidtv_psi.h\"\n#include \"vidtv_ts.h\"\n\n#define CRC_SIZE_IN_BYTES 4\n#define MAX_VERSION_NUM 32\n#define INITIAL_CRC 0xffffffff\n#define ISO_LANGUAGE_CODE_LEN 3\n\nstatic const u32 CRC_LUT[256] = {\n\t \n\t0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,\n\t0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n\t0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,\n\t0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n\t0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,\n\t0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n\t0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,\n\t0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n\t0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,\n\t0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n\t0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,\n\t0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n\t0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,\n\t0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n\t0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,\n\t0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n\t0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,\n\t0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n\t0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,\n\t0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n\t0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,\n\t0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n\t0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,\n\t0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n\t0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,\n\t0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n\t0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,\n\t0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n\t0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,\n\t0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n\t0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,\n\t0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n\t0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,\n\t0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n\t0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,\n\t0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n\t0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,\n\t0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n\t0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,\n\t0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n\t0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,\n\t0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n\t0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n};\n\nstatic u32 dvb_crc32(u32 crc, u8 *data, u32 len)\n{\n\t \n\twhile (len--)\n\t\tcrc = (crc << 8) ^ CRC_LUT[((crc >> 24) ^ *data++) & 0xff];\n\treturn crc;\n}\n\nstatic void vidtv_psi_update_version_num(struct vidtv_psi_table_header *h)\n{\n\th->version++;\n}\n\nstatic u16 vidtv_psi_get_sec_len(struct vidtv_psi_table_header *h)\n{\n\tu16 mask;\n\n\tmask = GENMASK(11, 0);\n\n\treturn be16_to_cpu(h->bitfield) & mask;\n}\n\nu16 vidtv_psi_get_pat_program_pid(struct vidtv_psi_table_pat_program *p)\n{\n\tu16 mask;\n\n\tmask = GENMASK(12, 0);\n\n\treturn be16_to_cpu(p->bitfield) & mask;\n}\n\nu16 vidtv_psi_pmt_stream_get_elem_pid(struct vidtv_psi_table_pmt_stream *s)\n{\n\tu16 mask;\n\n\tmask = GENMASK(12, 0);\n\n\treturn be16_to_cpu(s->bitfield) & mask;\n}\n\nstatic void vidtv_psi_set_desc_loop_len(__be16 *bitfield, u16 new_len,\n\t\t\t\t\tu8 desc_len_nbits)\n{\n\t__be16 new;\n\tu16 mask;\n\n\tmask = GENMASK(15, desc_len_nbits);\n\n\tnew = cpu_to_be16((be16_to_cpu(*bitfield) & mask) | new_len);\n\t*bitfield = new;\n}\n\nstatic void vidtv_psi_set_sec_len(struct vidtv_psi_table_header *h, u16 new_len)\n{\n\tu16 old_len = vidtv_psi_get_sec_len(h);\n\t__be16 new;\n\tu16 mask;\n\n\tmask = GENMASK(15, 13);\n\n\tnew = cpu_to_be16((be16_to_cpu(h->bitfield) & mask) | new_len);\n\n\tif (old_len > MAX_SECTION_LEN)\n\t\tpr_warn_ratelimited(\"section length: %d > %d, old len was %d\\n\",\n\t\t\t\t    new_len,\n\t\t\t\t    MAX_SECTION_LEN,\n\t\t\t\t    old_len);\n\n\th->bitfield = new;\n}\n\n \nstatic u32 vidtv_psi_ts_psi_write_into(struct psi_write_args *args)\n{\n\tstruct vidtv_mpeg_ts ts_header = {\n\t\t.sync_byte = TS_SYNC_BYTE,\n\t\t.bitfield = cpu_to_be16((args->new_psi_section << 14) | args->pid),\n\t\t.scrambling = 0,\n\t\t.payload = 1,\n\t\t.adaptation_field = 0,  \n\t};\n\tu32 nbytes_past_boundary = (args->dest_offset % TS_PACKET_LEN);\n\tbool aligned = (nbytes_past_boundary == 0);\n\tu32 remaining_len = args->len;\n\tu32 payload_write_len = 0;\n\tu32 payload_offset = 0;\n\tu32 nbytes = 0;\n\n\tif (!args->crc && !args->is_crc)\n\t\tpr_warn_ratelimited(\"Missing CRC for chunk\\n\");\n\n\tif (args->crc)\n\t\t*args->crc = dvb_crc32(*args->crc, args->from, args->len);\n\n\tif (args->new_psi_section && !aligned) {\n\t\tpr_warn_ratelimited(\"Cannot write a new PSI section in a misaligned buffer\\n\");\n\n\t\t \n\t\tnbytes += vidtv_memset(args->dest_buf,\n\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       TS_FILL_BYTE,\n\t\t\t\t       TS_PACKET_LEN - nbytes_past_boundary);\n\t}\n\n\twhile (remaining_len) {\n\t\tnbytes_past_boundary = (args->dest_offset + nbytes) % TS_PACKET_LEN;\n\t\taligned = (nbytes_past_boundary == 0);\n\n\t\tif (aligned) {\n\t\t\t \n\t\t\tts_header.continuity_counter = *args->continuity_counter;\n\n\t\t\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t\t       &ts_header,\n\t\t\t\t\t       sizeof(ts_header));\n\t\t\t \n\t\t\tvidtv_ts_inc_cc(args->continuity_counter);\n\t\t}\n\n\t\t \n\t\tif (args->new_psi_section)\n\t\t\tnbytes += vidtv_memset(args->dest_buf,\n\t\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t\t       0x0,\n\t\t\t\t\t       1);\n\n\t\t \n\t\tnbytes_past_boundary = (args->dest_offset + nbytes) % TS_PACKET_LEN;\n\t\tpayload_write_len = min(TS_PACKET_LEN - nbytes_past_boundary, remaining_len);\n\n\t\tnbytes += vidtv_memcpy(args->dest_buf,\n\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       args->from + payload_offset,\n\t\t\t\t       payload_write_len);\n\n\t\t \n\t\tremaining_len -= payload_write_len;\n\t\tpayload_offset += payload_write_len;\n\t}\n\n\t \n\n\tnbytes_past_boundary = (args->dest_offset + nbytes) % TS_PACKET_LEN;\n\n\tif (args->is_crc)\n\t\tnbytes += vidtv_memset(args->dest_buf,\n\t\t\t\t       args->dest_offset + nbytes,\n\t\t\t\t       args->dest_buf_sz,\n\t\t\t\t       TS_FILL_BYTE,\n\t\t\t\t       TS_PACKET_LEN - nbytes_past_boundary);\n\n\treturn nbytes;\n}\n\nstatic u32 table_section_crc32_write_into(struct crc32_write_args *args)\n{\n\tstruct psi_write_args psi_args = {\n\t\t.dest_buf           = args->dest_buf,\n\t\t.from               = &args->crc,\n\t\t.len                = CRC_SIZE_IN_BYTES,\n\t\t.dest_offset        = args->dest_offset,\n\t\t.pid                = args->pid,\n\t\t.new_psi_section    = false,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.is_crc             = true,\n\t\t.dest_buf_sz        = args->dest_buf_sz,\n\t};\n\n\t \n\n\treturn vidtv_psi_ts_psi_write_into(&psi_args);\n}\n\nstatic void vidtv_psi_desc_chain(struct vidtv_psi_desc *head, struct vidtv_psi_desc *desc)\n{\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = desc;\n\t}\n}\n\nstruct vidtv_psi_desc_service *vidtv_psi_service_desc_init(struct vidtv_psi_desc *head,\n\t\t\t\t\t\t\t   enum service_type service_type,\n\t\t\t\t\t\t\t   char *service_name,\n\t\t\t\t\t\t\t   char *provider_name)\n{\n\tstruct vidtv_psi_desc_service *desc;\n\tu32 service_name_len = service_name ? strlen(service_name) : 0;\n\tu32 provider_name_len = provider_name ? strlen(provider_name) : 0;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->type = SERVICE_DESCRIPTOR;\n\n\tdesc->length = sizeof_field(struct vidtv_psi_desc_service, service_type)\n\t\t       + sizeof_field(struct vidtv_psi_desc_service, provider_name_len)\n\t\t       + provider_name_len\n\t\t       + sizeof_field(struct vidtv_psi_desc_service, service_name_len)\n\t\t       + service_name_len;\n\n\tdesc->service_type = service_type;\n\n\tdesc->service_name_len = service_name_len;\n\n\tif (service_name && service_name_len) {\n\t\tdesc->service_name = kstrdup(service_name, GFP_KERNEL);\n\t\tif (!desc->service_name)\n\t\t\tgoto free_desc;\n\t}\n\n\tdesc->provider_name_len = provider_name_len;\n\n\tif (provider_name && provider_name_len) {\n\t\tdesc->provider_name = kstrdup(provider_name, GFP_KERNEL);\n\t\tif (!desc->provider_name)\n\t\t\tgoto free_desc_service_name;\n\t}\n\n\tvidtv_psi_desc_chain(head, (struct vidtv_psi_desc *)desc);\n\treturn desc;\n\nfree_desc_service_name:\n\tif (service_name && service_name_len)\n\t\tkfree(desc->service_name);\nfree_desc:\n\tkfree(desc);\n\treturn NULL;\n}\n\nstruct vidtv_psi_desc_registration\n*vidtv_psi_registration_desc_init(struct vidtv_psi_desc *head,\n\t\t\t\t  __be32 format_id,\n\t\t\t\t  u8 *additional_ident_info,\n\t\t\t\t  u32 additional_info_len)\n{\n\tstruct vidtv_psi_desc_registration *desc;\n\n\tdesc = kzalloc(sizeof(*desc) + sizeof(format_id) + additional_info_len, GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->type = REGISTRATION_DESCRIPTOR;\n\n\tdesc->length = sizeof_field(struct vidtv_psi_desc_registration, format_id)\n\t\t       + additional_info_len;\n\n\tdesc->format_id = format_id;\n\n\tif (additional_ident_info && additional_info_len)\n\t\tmemcpy(desc->additional_identification_info,\n\t\t       additional_ident_info,\n\t\t       additional_info_len);\n\n\tvidtv_psi_desc_chain(head, (struct vidtv_psi_desc *)desc);\n\treturn desc;\n}\n\nstruct vidtv_psi_desc_network_name\n*vidtv_psi_network_name_desc_init(struct vidtv_psi_desc *head, char *network_name)\n{\n\tu32 network_name_len = network_name ? strlen(network_name) : 0;\n\tstruct vidtv_psi_desc_network_name *desc;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->type = NETWORK_NAME_DESCRIPTOR;\n\n\tdesc->length = network_name_len;\n\n\tif (network_name && network_name_len) {\n\t\tdesc->network_name = kstrdup(network_name, GFP_KERNEL);\n\t\tif (!desc->network_name) {\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tvidtv_psi_desc_chain(head, (struct vidtv_psi_desc *)desc);\n\treturn desc;\n}\n\nstruct vidtv_psi_desc_service_list\n*vidtv_psi_service_list_desc_init(struct vidtv_psi_desc *head,\n\t\t\t\t  struct vidtv_psi_desc_service_list_entry *entry)\n{\n\tstruct vidtv_psi_desc_service_list_entry *curr_e = NULL;\n\tstruct vidtv_psi_desc_service_list_entry *head_e = NULL;\n\tstruct vidtv_psi_desc_service_list_entry *prev_e = NULL;\n\tstruct vidtv_psi_desc_service_list *desc;\n\tu16 length = 0;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->type = SERVICE_LIST_DESCRIPTOR;\n\n\twhile (entry) {\n\t\tcurr_e = kzalloc(sizeof(*curr_e), GFP_KERNEL);\n\t\tif (!curr_e) {\n\t\t\twhile (head_e) {\n\t\t\t\tcurr_e = head_e;\n\t\t\t\thead_e = head_e->next;\n\t\t\t\tkfree(curr_e);\n\t\t\t}\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcurr_e->service_id = entry->service_id;\n\t\tcurr_e->service_type = entry->service_type;\n\n\t\tlength += sizeof(struct vidtv_psi_desc_service_list_entry) -\n\t\t\t  sizeof(struct vidtv_psi_desc_service_list_entry *);\n\n\t\tif (!head_e)\n\t\t\thead_e = curr_e;\n\t\tif (prev_e)\n\t\t\tprev_e->next = curr_e;\n\n\t\tprev_e = curr_e;\n\t\tentry = entry->next;\n\t}\n\n\tdesc->length = length;\n\tdesc->service_list = head_e;\n\n\tvidtv_psi_desc_chain(head, (struct vidtv_psi_desc *)desc);\n\treturn desc;\n}\n\nstruct vidtv_psi_desc_short_event\n*vidtv_psi_short_event_desc_init(struct vidtv_psi_desc *head,\n\t\t\t\t char *iso_language_code,\n\t\t\t\t char *event_name,\n\t\t\t\t char *text)\n{\n\tu32 iso_len =  iso_language_code ? strlen(iso_language_code) : 0;\n\tu32 event_name_len = event_name ? strlen(event_name) : 0;\n\tstruct vidtv_psi_desc_short_event *desc;\n\tu32 text_len =  text ? strlen(text) : 0;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->type = SHORT_EVENT_DESCRIPTOR;\n\n\tdesc->length = ISO_LANGUAGE_CODE_LEN +\n\t\t       sizeof_field(struct vidtv_psi_desc_short_event, event_name_len) +\n\t\t       event_name_len +\n\t\t       sizeof_field(struct vidtv_psi_desc_short_event, text_len) +\n\t\t       text_len;\n\n\tdesc->event_name_len = event_name_len;\n\tdesc->text_len = text_len;\n\n\tif (iso_len != ISO_LANGUAGE_CODE_LEN)\n\t\tiso_language_code = \"eng\";\n\n\tdesc->iso_language_code = kstrdup(iso_language_code, GFP_KERNEL);\n\tif (!desc->iso_language_code)\n\t\tgoto free_desc;\n\n\tif (event_name && event_name_len) {\n\t\tdesc->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!desc->event_name)\n\t\t\tgoto free_desc_language_code;\n\t}\n\n\tif (text && text_len) {\n\t\tdesc->text = kstrdup(text, GFP_KERNEL);\n\t\tif (!desc->text)\n\t\t\tgoto free_desc_event_name;\n\t}\n\n\tvidtv_psi_desc_chain(head, (struct vidtv_psi_desc *)desc);\n\treturn desc;\n\nfree_desc_event_name:\n\tif (event_name && event_name_len)\n\t\tkfree(desc->event_name);\nfree_desc_language_code:\n\tkfree(desc->iso_language_code);\nfree_desc:\n\tkfree(desc);\n\treturn NULL;\n}\n\nstruct vidtv_psi_desc *vidtv_psi_desc_clone(struct vidtv_psi_desc *desc)\n{\n\tstruct vidtv_psi_desc_network_name *desc_network_name;\n\tstruct vidtv_psi_desc_service_list *desc_service_list;\n\tstruct vidtv_psi_desc_short_event  *desc_short_event;\n\tstruct vidtv_psi_desc_service *service;\n\tstruct vidtv_psi_desc *head = NULL;\n\tstruct vidtv_psi_desc *prev = NULL;\n\tstruct vidtv_psi_desc *curr = NULL;\n\n\twhile (desc) {\n\t\tswitch (desc->type) {\n\t\tcase SERVICE_DESCRIPTOR:\n\t\t\tservice = (struct vidtv_psi_desc_service *)desc;\n\t\t\tcurr = (struct vidtv_psi_desc *)\n\t\t\t       vidtv_psi_service_desc_init(head,\n\t\t\t\t\t\t\t   service->service_type,\n\t\t\t\t\t\t\t   service->service_name,\n\t\t\t\t\t\t\t   service->provider_name);\n\t\tbreak;\n\n\t\tcase NETWORK_NAME_DESCRIPTOR:\n\t\t\tdesc_network_name = (struct vidtv_psi_desc_network_name *)desc;\n\t\t\tcurr = (struct vidtv_psi_desc *)\n\t\t\t       vidtv_psi_network_name_desc_init(head,\n\t\t\t\t\t\t\t\tdesc_network_name->network_name);\n\t\tbreak;\n\n\t\tcase SERVICE_LIST_DESCRIPTOR:\n\t\t\tdesc_service_list = (struct vidtv_psi_desc_service_list *)desc;\n\t\t\tcurr = (struct vidtv_psi_desc *)\n\t\t\t       vidtv_psi_service_list_desc_init(head,\n\t\t\t\t\t\t\t\tdesc_service_list->service_list);\n\t\tbreak;\n\n\t\tcase SHORT_EVENT_DESCRIPTOR:\n\t\t\tdesc_short_event = (struct vidtv_psi_desc_short_event *)desc;\n\t\t\tcurr = (struct vidtv_psi_desc *)\n\t\t\t       vidtv_psi_short_event_desc_init(head,\n\t\t\t\t\t\t\t       desc_short_event->iso_language_code,\n\t\t\t\t\t\t\t       desc_short_event->event_name,\n\t\t\t\t\t\t\t       desc_short_event->text);\n\t\tbreak;\n\n\t\tcase REGISTRATION_DESCRIPTOR:\n\t\tdefault:\n\t\t\tcurr = kmemdup(desc, sizeof(*desc) + desc->length, GFP_KERNEL);\n\t\t\tif (!curr)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!curr)\n\t\t\treturn NULL;\n\n\t\tcurr->next = NULL;\n\t\tif (!head)\n\t\t\thead = curr;\n\t\tif (prev)\n\t\t\tprev->next = curr;\n\n\t\tprev = curr;\n\t\tdesc = desc->next;\n\t}\n\n\treturn head;\n}\n\nvoid vidtv_psi_desc_destroy(struct vidtv_psi_desc *desc)\n{\n\tstruct vidtv_psi_desc_service_list_entry *sl_entry_tmp = NULL;\n\tstruct vidtv_psi_desc_service_list_entry *sl_entry = NULL;\n\tstruct vidtv_psi_desc *curr = desc;\n\tstruct vidtv_psi_desc *tmp  = NULL;\n\n\twhile (curr) {\n\t\ttmp  = curr;\n\t\tcurr = curr->next;\n\n\t\tswitch (tmp->type) {\n\t\tcase SERVICE_DESCRIPTOR:\n\t\t\tkfree(((struct vidtv_psi_desc_service *)tmp)->provider_name);\n\t\t\tkfree(((struct vidtv_psi_desc_service *)tmp)->service_name);\n\n\t\t\tbreak;\n\t\tcase REGISTRATION_DESCRIPTOR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase NETWORK_NAME_DESCRIPTOR:\n\t\t\tkfree(((struct vidtv_psi_desc_network_name *)tmp)->network_name);\n\t\t\tbreak;\n\n\t\tcase SERVICE_LIST_DESCRIPTOR:\n\t\t\tsl_entry = ((struct vidtv_psi_desc_service_list *)tmp)->service_list;\n\t\t\twhile (sl_entry) {\n\t\t\t\tsl_entry_tmp = sl_entry;\n\t\t\t\tsl_entry = sl_entry->next;\n\t\t\t\tkfree(sl_entry_tmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SHORT_EVENT_DESCRIPTOR:\n\t\t\tkfree(((struct vidtv_psi_desc_short_event *)tmp)->iso_language_code);\n\t\t\tkfree(((struct vidtv_psi_desc_short_event *)tmp)->event_name);\n\t\t\tkfree(((struct vidtv_psi_desc_short_event *)tmp)->text);\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn_ratelimited(\"Possible leak: not handling descriptor type %d\\n\",\n\t\t\t\t\t    tmp->type);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(tmp);\n\t}\n}\n\nstatic u16\nvidtv_psi_desc_comp_loop_len(struct vidtv_psi_desc *desc)\n{\n\tu32 length = 0;\n\n\tif (!desc)\n\t\treturn 0;\n\n\twhile (desc) {\n\t\tlength += sizeof_field(struct vidtv_psi_desc, type);\n\t\tlength += sizeof_field(struct vidtv_psi_desc, length);\n\t\tlength += desc->length;  \n\t\tdesc    = desc->next;\n\t}\n\n\treturn length;\n}\n\nvoid vidtv_psi_desc_assign(struct vidtv_psi_desc **to,\n\t\t\t   struct vidtv_psi_desc *desc)\n{\n\tif (desc == *to)\n\t\treturn;\n\n\tif (*to)\n\t\tvidtv_psi_desc_destroy(*to);\n\n\t*to = desc;\n}\n\nvoid vidtv_pmt_desc_assign(struct vidtv_psi_table_pmt *pmt,\n\t\t\t   struct vidtv_psi_desc **to,\n\t\t\t   struct vidtv_psi_desc *desc)\n{\n\tvidtv_psi_desc_assign(to, desc);\n\tvidtv_psi_pmt_table_update_sec_len(pmt);\n\n\tif (vidtv_psi_get_sec_len(&pmt->header) > MAX_SECTION_LEN)\n\t\tvidtv_psi_desc_assign(to, NULL);\n\n\tvidtv_psi_update_version_num(&pmt->header);\n}\n\nvoid vidtv_sdt_desc_assign(struct vidtv_psi_table_sdt *sdt,\n\t\t\t   struct vidtv_psi_desc **to,\n\t\t\t   struct vidtv_psi_desc *desc)\n{\n\tvidtv_psi_desc_assign(to, desc);\n\tvidtv_psi_sdt_table_update_sec_len(sdt);\n\n\tif (vidtv_psi_get_sec_len(&sdt->header) > MAX_SECTION_LEN)\n\t\tvidtv_psi_desc_assign(to, NULL);\n\n\tvidtv_psi_update_version_num(&sdt->header);\n}\n\nstatic u32 vidtv_psi_desc_write_into(struct desc_write_args *args)\n{\n\tstruct psi_write_args psi_args = {\n\t\t.dest_buf           = args->dest_buf,\n\t\t.from               = &args->desc->type,\n\t\t.pid                = args->pid,\n\t\t.new_psi_section    = false,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->dest_buf_sz,\n\t\t.crc                = args->crc,\n\t\t.len\t\t    = sizeof_field(struct vidtv_psi_desc, type) +\n\t\t\t\t      sizeof_field(struct vidtv_psi_desc, length),\n\t};\n\tstruct vidtv_psi_desc_service_list_entry *serv_list_entry = NULL;\n\tu32 nbytes = 0;\n\n\tpsi_args.dest_offset        = args->dest_offset + nbytes;\n\n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\tswitch (args->desc->type) {\n\tcase SERVICE_DESCRIPTOR:\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = sizeof_field(struct vidtv_psi_desc_service, service_type) +\n\t\t\t       sizeof_field(struct vidtv_psi_desc_service, provider_name_len);\n\t\tpsi_args.from = &((struct vidtv_psi_desc_service *)args->desc)->service_type;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = ((struct vidtv_psi_desc_service *)args->desc)->provider_name_len;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_service *)args->desc)->provider_name;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = sizeof_field(struct vidtv_psi_desc_service, service_name_len);\n\t\tpsi_args.from = &((struct vidtv_psi_desc_service *)args->desc)->service_name_len;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = ((struct vidtv_psi_desc_service *)args->desc)->service_name_len;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_service *)args->desc)->service_name;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\t\tbreak;\n\n\tcase NETWORK_NAME_DESCRIPTOR:\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = args->desc->length;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_network_name *)args->desc)->network_name;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\t\tbreak;\n\n\tcase SERVICE_LIST_DESCRIPTOR:\n\t\tserv_list_entry = ((struct vidtv_psi_desc_service_list *)args->desc)->service_list;\n\t\twhile (serv_list_entry) {\n\t\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\t\tpsi_args.len = sizeof(struct vidtv_psi_desc_service_list_entry) -\n\t\t\t\t       sizeof(struct vidtv_psi_desc_service_list_entry *);\n\t\t\tpsi_args.from = serv_list_entry;\n\n\t\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\t\tserv_list_entry = serv_list_entry->next;\n\t\t}\n\t\tbreak;\n\n\tcase SHORT_EVENT_DESCRIPTOR:\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = ISO_LANGUAGE_CODE_LEN;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_short_event *)\n\t\t\t\t  args->desc)->iso_language_code;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = sizeof_field(struct vidtv_psi_desc_short_event, event_name_len);\n\t\tpsi_args.from = &((struct vidtv_psi_desc_short_event *)\n\t\t\t\t  args->desc)->event_name_len;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = ((struct vidtv_psi_desc_short_event *)args->desc)->event_name_len;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_short_event *)args->desc)->event_name;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = sizeof_field(struct vidtv_psi_desc_short_event, text_len);\n\t\tpsi_args.from = &((struct vidtv_psi_desc_short_event *)args->desc)->text_len;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = ((struct vidtv_psi_desc_short_event *)args->desc)->text_len;\n\t\tpsi_args.from = ((struct vidtv_psi_desc_short_event *)args->desc)->text;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tbreak;\n\n\tcase REGISTRATION_DESCRIPTOR:\n\tdefault:\n\t\tpsi_args.dest_offset = args->dest_offset + nbytes;\n\t\tpsi_args.len = args->desc->length;\n\t\tpsi_args.from = &args->desc->data;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\t\tbreak;\n\t}\n\n\treturn nbytes;\n}\n\nstatic u32\nvidtv_psi_table_header_write_into(struct header_write_args *args)\n{\n\tstruct psi_write_args psi_args = {\n\t\t.dest_buf           = args->dest_buf,\n\t\t.from               = args->h,\n\t\t.len                = sizeof(struct vidtv_psi_table_header),\n\t\t.dest_offset        = args->dest_offset,\n\t\t.pid                = args->pid,\n\t\t.new_psi_section    = true,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->dest_buf_sz,\n\t\t.crc                = args->crc,\n\t};\n\n\treturn vidtv_psi_ts_psi_write_into(&psi_args);\n}\n\nvoid\nvidtv_psi_pat_table_update_sec_len(struct vidtv_psi_table_pat *pat)\n{\n\tu16 length = 0;\n\tu32 i;\n\n\t \n\n\t \n\tlength += PAT_LEN_UNTIL_LAST_SECTION_NUMBER;\n\n\t \n\tfor (i = 0; i < pat->num_pat; ++i)\n\t\tlength += sizeof(struct vidtv_psi_table_pat_program) -\n\t\t\t  sizeof(struct vidtv_psi_table_pat_program *);\n\n\tlength += CRC_SIZE_IN_BYTES;\n\n\tvidtv_psi_set_sec_len(&pat->header, length);\n}\n\nvoid vidtv_psi_pmt_table_update_sec_len(struct vidtv_psi_table_pmt *pmt)\n{\n\tstruct vidtv_psi_table_pmt_stream *s = pmt->stream;\n\tu16 desc_loop_len;\n\tu16 length = 0;\n\n\t \n\n\t \n\tlength += PMT_LEN_UNTIL_PROGRAM_INFO_LENGTH;\n\n\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(pmt->descriptor);\n\tvidtv_psi_set_desc_loop_len(&pmt->bitfield2, desc_loop_len, 10);\n\n\tlength += desc_loop_len;\n\n\twhile (s) {\n\t\t \n\t\tlength += sizeof(struct vidtv_psi_table_pmt_stream) -\n\t\t\t  sizeof(struct vidtv_psi_desc *) -\n\t\t\t  sizeof(struct vidtv_psi_table_pmt_stream *);\n\n\t\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(s->descriptor);\n\t\tvidtv_psi_set_desc_loop_len(&s->bitfield2, desc_loop_len, 10);\n\n\t\tlength += desc_loop_len;\n\n\t\ts = s->next;\n\t}\n\n\tlength += CRC_SIZE_IN_BYTES;\n\n\tvidtv_psi_set_sec_len(&pmt->header, length);\n}\n\nvoid vidtv_psi_sdt_table_update_sec_len(struct vidtv_psi_table_sdt *sdt)\n{\n\tstruct vidtv_psi_table_sdt_service *s = sdt->service;\n\tu16 desc_loop_len;\n\tu16 length = 0;\n\n\t \n\n\t \n\tlength += SDT_LEN_UNTIL_RESERVED_FOR_FUTURE_USE;\n\n\twhile (s) {\n\t\t \n\t\tlength += sizeof(struct vidtv_psi_table_sdt_service) -\n\t\t\t  sizeof(struct vidtv_psi_desc *) -\n\t\t\t  sizeof(struct vidtv_psi_table_sdt_service *);\n\n\t\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(s->descriptor);\n\t\tvidtv_psi_set_desc_loop_len(&s->bitfield, desc_loop_len, 12);\n\n\t\tlength += desc_loop_len;\n\n\t\ts = s->next;\n\t}\n\n\tlength += CRC_SIZE_IN_BYTES;\n\tvidtv_psi_set_sec_len(&sdt->header, length);\n}\n\nstruct vidtv_psi_table_pat_program*\nvidtv_psi_pat_program_init(struct vidtv_psi_table_pat_program *head,\n\t\t\t   u16 service_id,\n\t\t\t   u16 program_map_pid)\n{\n\tstruct vidtv_psi_table_pat_program *program;\n\tconst u16 RESERVED = 0x07;\n\n\tprogram = kzalloc(sizeof(*program), GFP_KERNEL);\n\tif (!program)\n\t\treturn NULL;\n\n\tprogram->service_id = cpu_to_be16(service_id);\n\n\t \n\tprogram->bitfield = cpu_to_be16((RESERVED << 13) | program_map_pid);\n\tprogram->next = NULL;\n\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = program;\n\t}\n\n\treturn program;\n}\n\nvoid\nvidtv_psi_pat_program_destroy(struct vidtv_psi_table_pat_program *p)\n{\n\tstruct vidtv_psi_table_pat_program *tmp  = NULL;\n\tstruct vidtv_psi_table_pat_program *curr = p;\n\n\twhile (curr) {\n\t\ttmp  = curr;\n\t\tcurr = curr->next;\n\t\tkfree(tmp);\n\t}\n}\n\n \nvoid\nvidtv_psi_pat_program_assign(struct vidtv_psi_table_pat *pat,\n\t\t\t     struct vidtv_psi_table_pat_program *p)\n{\n\tstruct vidtv_psi_table_pat_program *program;\n\tu16 program_count;\n\n\tdo {\n\t\tprogram_count = 0;\n\t\tprogram = p;\n\n\t\tif (p == pat->program)\n\t\t\treturn;\n\n\t\twhile (program) {\n\t\t\t++program_count;\n\t\t\tprogram = program->next;\n\t\t}\n\n\t\tpat->num_pat = program_count;\n\t\tpat->program  = p;\n\n\t\t \n\t\tvidtv_psi_pat_table_update_sec_len(pat);\n\n\t\tp = NULL;\n\t} while (vidtv_psi_get_sec_len(&pat->header) > MAX_SECTION_LEN);\n\n\tvidtv_psi_update_version_num(&pat->header);\n}\n\nstruct vidtv_psi_table_pat *vidtv_psi_pat_table_init(u16 transport_stream_id)\n{\n\tstruct vidtv_psi_table_pat *pat;\n\tconst u16 SYNTAX = 0x1;\n\tconst u16 ZERO = 0x0;\n\tconst u16 ONES = 0x03;\n\n\tpat = kzalloc(sizeof(*pat), GFP_KERNEL);\n\tif (!pat)\n\t\treturn NULL;\n\n\tpat->header.table_id = 0x0;\n\n\tpat->header.bitfield = cpu_to_be16((SYNTAX << 15) | (ZERO << 14) | (ONES << 12));\n\tpat->header.id           = cpu_to_be16(transport_stream_id);\n\tpat->header.current_next = 0x1;\n\n\tpat->header.version = 0x1f;\n\n\tpat->header.one2         = 0x03;\n\tpat->header.section_id   = 0x0;\n\tpat->header.last_section = 0x0;\n\n\tvidtv_psi_pat_table_update_sec_len(pat);\n\n\treturn pat;\n}\n\nu32 vidtv_psi_pat_write_into(struct vidtv_psi_pat_write_args *args)\n{\n\tstruct vidtv_psi_table_pat_program *p = args->pat->program;\n\tstruct header_write_args h_args       = {\n\t\t.dest_buf           = args->buf,\n\t\t.dest_offset        = args->offset,\n\t\t.pid                = VIDTV_PAT_PID,\n\t\t.h                  = &args->pat->header,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct psi_write_args psi_args        = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_PAT_PID,\n\t\t.new_psi_section    = false,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct crc32_write_args c_args        = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_PAT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tu32 crc = INITIAL_CRC;\n\tu32 nbytes = 0;\n\n\tvidtv_psi_pat_table_update_sec_len(args->pat);\n\n\th_args.crc = &crc;\n\n\tnbytes += vidtv_psi_table_header_write_into(&h_args);\n\n\t \n\n\tpsi_args.crc = &crc;\n\n\twhile (p) {\n\t\t \n\t\tpsi_args.from = p;\n\t\t \n\t\tpsi_args.len = sizeof(*p) -\n\t\t\t       sizeof(struct vidtv_psi_table_pat_program *);\n\t\tpsi_args.dest_offset = args->offset + nbytes;\n\t\tpsi_args.continuity_counter = args->continuity_counter;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tp = p->next;\n\t}\n\n\tc_args.dest_offset        = args->offset + nbytes;\n\tc_args.continuity_counter = args->continuity_counter;\n\tc_args.crc                = cpu_to_be32(crc);\n\n\t \n\tnbytes += table_section_crc32_write_into(&c_args);\n\n\treturn nbytes;\n}\n\nvoid\nvidtv_psi_pat_table_destroy(struct vidtv_psi_table_pat *p)\n{\n\tvidtv_psi_pat_program_destroy(p->program);\n\tkfree(p);\n}\n\nstruct vidtv_psi_table_pmt_stream*\nvidtv_psi_pmt_stream_init(struct vidtv_psi_table_pmt_stream *head,\n\t\t\t  enum vidtv_psi_stream_types stream_type,\n\t\t\t  u16 es_pid)\n{\n\tstruct vidtv_psi_table_pmt_stream *stream;\n\tconst u16 RESERVED1 = 0x07;\n\tconst u16 RESERVED2 = 0x0f;\n\tconst u16 ZERO = 0x0;\n\tu16 desc_loop_len;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn NULL;\n\n\tstream->type = stream_type;\n\n\tstream->bitfield = cpu_to_be16((RESERVED1 << 13) | es_pid);\n\n\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(stream->descriptor);\n\n\tstream->bitfield2 = cpu_to_be16((RESERVED2 << 12) |\n\t\t\t\t\t(ZERO << 10)      |\n\t\t\t\t\tdesc_loop_len);\n\tstream->next = NULL;\n\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = stream;\n\t}\n\n\treturn stream;\n}\n\nvoid vidtv_psi_pmt_stream_destroy(struct vidtv_psi_table_pmt_stream *s)\n{\n\tstruct vidtv_psi_table_pmt_stream *tmp_stream  = NULL;\n\tstruct vidtv_psi_table_pmt_stream *curr_stream = s;\n\n\twhile (curr_stream) {\n\t\ttmp_stream  = curr_stream;\n\t\tcurr_stream = curr_stream->next;\n\t\tvidtv_psi_desc_destroy(tmp_stream->descriptor);\n\t\tkfree(tmp_stream);\n\t}\n}\n\nvoid vidtv_psi_pmt_stream_assign(struct vidtv_psi_table_pmt *pmt,\n\t\t\t\t struct vidtv_psi_table_pmt_stream *s)\n{\n\tdo {\n\t\t \n\t\tif (s == pmt->stream)\n\t\t\treturn;\n\n\t\tpmt->stream = s;\n\t\tvidtv_psi_pmt_table_update_sec_len(pmt);\n\n\t\ts = NULL;\n\t} while (vidtv_psi_get_sec_len(&pmt->header) > MAX_SECTION_LEN);\n\n\tvidtv_psi_update_version_num(&pmt->header);\n}\n\nu16 vidtv_psi_pmt_get_pid(struct vidtv_psi_table_pmt *section,\n\t\t\t  struct vidtv_psi_table_pat *pat)\n{\n\tstruct vidtv_psi_table_pat_program *program = pat->program;\n\n\t \n\twhile (program) {\n\t\tif (program->service_id == section->header.id)\n\t\t\treturn vidtv_psi_get_pat_program_pid(program);\n\n\t\tprogram = program->next;\n\t}\n\n\treturn TS_LAST_VALID_PID + 1;  \n}\n\nstruct vidtv_psi_table_pmt *vidtv_psi_pmt_table_init(u16 program_number,\n\t\t\t\t\t\t     u16 pcr_pid)\n{\n\tstruct vidtv_psi_table_pmt *pmt;\n\tconst u16 RESERVED1 = 0x07;\n\tconst u16 RESERVED2 = 0x0f;\n\tconst u16 SYNTAX = 0x1;\n\tconst u16 ONES = 0x03;\n\tconst u16 ZERO = 0x0;\n\tu16 desc_loop_len;\n\n\tpmt = kzalloc(sizeof(*pmt), GFP_KERNEL);\n\tif (!pmt)\n\t\treturn NULL;\n\n\tif (!pcr_pid)\n\t\tpcr_pid = 0x1fff;\n\n\tpmt->header.table_id = 0x2;\n\n\tpmt->header.bitfield = cpu_to_be16((SYNTAX << 15) | (ZERO << 14) | (ONES << 12));\n\n\tpmt->header.id = cpu_to_be16(program_number);\n\tpmt->header.current_next = 0x1;\n\n\tpmt->header.version = 0x1f;\n\n\tpmt->header.one2 = ONES;\n\tpmt->header.section_id   = 0;\n\tpmt->header.last_section = 0;\n\n\tpmt->bitfield = cpu_to_be16((RESERVED1 << 13) | pcr_pid);\n\n\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(pmt->descriptor);\n\n\tpmt->bitfield2 = cpu_to_be16((RESERVED2 << 12) |\n\t\t\t\t     (ZERO << 10)      |\n\t\t\t\t     desc_loop_len);\n\n\tvidtv_psi_pmt_table_update_sec_len(pmt);\n\n\treturn pmt;\n}\n\nu32 vidtv_psi_pmt_write_into(struct vidtv_psi_pmt_write_args *args)\n{\n\tstruct vidtv_psi_desc *table_descriptor   = args->pmt->descriptor;\n\tstruct vidtv_psi_table_pmt_stream *stream = args->pmt->stream;\n\tstruct vidtv_psi_desc *stream_descriptor;\n\tu32 crc = INITIAL_CRC;\n\tu32 nbytes = 0;\n\tstruct header_write_args h_args = {\n\t\t.dest_buf           = args->buf,\n\t\t.dest_offset        = args->offset,\n\t\t.h                  = &args->pmt->header,\n\t\t.pid                = args->pid,\n\t\t.continuity_counter = args->continuity_counter,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct psi_write_args psi_args  = {\n\t\t.dest_buf = args->buf,\n\t\t.from     = &args->pmt->bitfield,\n\t\t.len      = sizeof_field(struct vidtv_psi_table_pmt, bitfield) +\n\t\t\t    sizeof_field(struct vidtv_psi_table_pmt, bitfield2),\n\t\t.pid                = args->pid,\n\t\t.new_psi_section    = false,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t\t.crc                = &crc,\n\t};\n\tstruct desc_write_args d_args   = {\n\t\t.dest_buf           = args->buf,\n\t\t.desc               = table_descriptor,\n\t\t.pid                = args->pid,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct crc32_write_args c_args  = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = args->pid,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\n\tvidtv_psi_pmt_table_update_sec_len(args->pmt);\n\n\th_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_table_header_write_into(&h_args);\n\n\t \n\tpsi_args.dest_offset        = args->offset + nbytes;\n\tpsi_args.continuity_counter = args->continuity_counter;\n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\twhile (table_descriptor) {\n\t\t \n\t\td_args.dest_offset        = args->offset + nbytes;\n\t\td_args.continuity_counter = args->continuity_counter;\n\t\td_args.crc                = &crc;\n\n\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\ttable_descriptor = table_descriptor->next;\n\t}\n\n\tpsi_args.len += sizeof_field(struct vidtv_psi_table_pmt_stream, type);\n\twhile (stream) {\n\t\t \n\t\tpsi_args.from = stream;\n\t\tpsi_args.dest_offset = args->offset + nbytes;\n\t\tpsi_args.continuity_counter = args->continuity_counter;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tstream_descriptor = stream->descriptor;\n\n\t\twhile (stream_descriptor) {\n\t\t\t \n\t\t\td_args.dest_offset        = args->offset + nbytes;\n\t\t\td_args.desc               = stream_descriptor;\n\t\t\td_args.continuity_counter = args->continuity_counter;\n\t\t\td_args.crc                = &crc;\n\n\t\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\t\tstream_descriptor = stream_descriptor->next;\n\t\t}\n\n\t\tstream = stream->next;\n\t}\n\n\tc_args.dest_offset        = args->offset + nbytes;\n\tc_args.crc                = cpu_to_be32(crc);\n\tc_args.continuity_counter = args->continuity_counter;\n\n\t \n\tnbytes += table_section_crc32_write_into(&c_args);\n\n\treturn nbytes;\n}\n\nvoid vidtv_psi_pmt_table_destroy(struct vidtv_psi_table_pmt *pmt)\n{\n\tvidtv_psi_desc_destroy(pmt->descriptor);\n\tvidtv_psi_pmt_stream_destroy(pmt->stream);\n\tkfree(pmt);\n}\n\nstruct vidtv_psi_table_sdt *vidtv_psi_sdt_table_init(u16 network_id,\n\t\t\t\t\t\t     u16 transport_stream_id)\n{\n\tstruct vidtv_psi_table_sdt *sdt;\n\tconst u16 RESERVED = 0xff;\n\tconst u16 SYNTAX = 0x1;\n\tconst u16 ONES = 0x03;\n\tconst u16 ONE = 0x1;\n\n\tsdt  = kzalloc(sizeof(*sdt), GFP_KERNEL);\n\tif (!sdt)\n\t\treturn NULL;\n\n\tsdt->header.table_id = 0x42;\n\tsdt->header.bitfield = cpu_to_be16((SYNTAX << 15) | (ONE << 14) | (ONES << 12));\n\n\t \n\tsdt->header.id = cpu_to_be16(transport_stream_id);\n\tsdt->header.current_next = ONE;\n\n\tsdt->header.version = 0x1f;\n\n\tsdt->header.one2  = ONES;\n\tsdt->header.section_id   = 0;\n\tsdt->header.last_section = 0;\n\n\t \n\tsdt->network_id = cpu_to_be16(network_id);\n\tsdt->reserved = RESERVED;\n\n\tvidtv_psi_sdt_table_update_sec_len(sdt);\n\n\treturn sdt;\n}\n\nu32 vidtv_psi_sdt_write_into(struct vidtv_psi_sdt_write_args *args)\n{\n\tstruct header_write_args h_args = {\n\t\t.dest_buf           = args->buf,\n\t\t.dest_offset        = args->offset,\n\t\t.h                  = &args->sdt->header,\n\t\t.pid                = VIDTV_SDT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct psi_write_args psi_args  = {\n\t\t.dest_buf = args->buf,\n\t\t.len = sizeof_field(struct vidtv_psi_table_sdt, network_id) +\n\t\t       sizeof_field(struct vidtv_psi_table_sdt, reserved),\n\t\t.pid                = VIDTV_SDT_PID,\n\t\t.new_psi_section    = false,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct desc_write_args d_args   = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_SDT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct crc32_write_args c_args  = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_SDT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct vidtv_psi_table_sdt_service *service = args->sdt->service;\n\tstruct vidtv_psi_desc *service_desc;\n\tu32 nbytes  = 0;\n\tu32 crc = INITIAL_CRC;\n\n\t \n\n\tvidtv_psi_sdt_table_update_sec_len(args->sdt);\n\n\th_args.continuity_counter = args->continuity_counter;\n\th_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_table_header_write_into(&h_args);\n\n\tpsi_args.from               = &args->sdt->network_id;\n\tpsi_args.dest_offset        = args->offset + nbytes;\n\tpsi_args.continuity_counter = args->continuity_counter;\n\tpsi_args.crc                = &crc;\n\n\t \n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t \n\tpsi_args.len = sizeof(struct vidtv_psi_table_sdt_service) -\n\t\t       sizeof(struct vidtv_psi_desc *) -\n\t\t       sizeof(struct vidtv_psi_table_sdt_service *);\n\n\twhile (service) {\n\t\t \n\t\tpsi_args.from = service;\n\t\tpsi_args.dest_offset = args->offset + nbytes;\n\t\tpsi_args.continuity_counter = args->continuity_counter;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tservice_desc = service->descriptor;\n\n\t\twhile (service_desc) {\n\t\t\t \n\t\t\td_args.dest_offset        = args->offset + nbytes;\n\t\t\td_args.desc               = service_desc;\n\t\t\td_args.continuity_counter = args->continuity_counter;\n\t\t\td_args.crc                = &crc;\n\n\t\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\t\tservice_desc = service_desc->next;\n\t\t}\n\n\t\tservice = service->next;\n\t}\n\n\tc_args.dest_offset        = args->offset + nbytes;\n\tc_args.crc                = cpu_to_be32(crc);\n\tc_args.continuity_counter = args->continuity_counter;\n\n\t \n\tnbytes += table_section_crc32_write_into(&c_args);\n\n\treturn nbytes;\n}\n\nvoid vidtv_psi_sdt_table_destroy(struct vidtv_psi_table_sdt *sdt)\n{\n\tvidtv_psi_sdt_service_destroy(sdt->service);\n\tkfree(sdt);\n}\n\nstruct vidtv_psi_table_sdt_service\n*vidtv_psi_sdt_service_init(struct vidtv_psi_table_sdt_service *head,\n\t\t\t    u16 service_id,\n\t\t\t    bool eit_schedule,\n\t\t\t    bool eit_present_following)\n{\n\tstruct vidtv_psi_table_sdt_service *service;\n\n\tservice = kzalloc(sizeof(*service), GFP_KERNEL);\n\tif (!service)\n\t\treturn NULL;\n\n\t \n\tservice->service_id            = cpu_to_be16(service_id);\n\tservice->EIT_schedule          = eit_schedule;\n\tservice->EIT_present_following = eit_present_following;\n\tservice->reserved              = 0x3f;\n\n\tservice->bitfield = cpu_to_be16(RUNNING << 13);\n\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = service;\n\t}\n\n\treturn service;\n}\n\nvoid\nvidtv_psi_sdt_service_destroy(struct vidtv_psi_table_sdt_service *service)\n{\n\tstruct vidtv_psi_table_sdt_service *curr = service;\n\tstruct vidtv_psi_table_sdt_service *tmp  = NULL;\n\n\twhile (curr) {\n\t\ttmp  = curr;\n\t\tcurr = curr->next;\n\t\tvidtv_psi_desc_destroy(tmp->descriptor);\n\t\tkfree(tmp);\n\t}\n}\n\nvoid\nvidtv_psi_sdt_service_assign(struct vidtv_psi_table_sdt *sdt,\n\t\t\t     struct vidtv_psi_table_sdt_service *service)\n{\n\tdo {\n\t\tif (service == sdt->service)\n\t\t\treturn;\n\n\t\tsdt->service = service;\n\n\t\t \n\t\tvidtv_psi_sdt_table_update_sec_len(sdt);\n\n\t\tservice = NULL;\n\t} while (vidtv_psi_get_sec_len(&sdt->header) > MAX_SECTION_LEN);\n\n\tvidtv_psi_update_version_num(&sdt->header);\n}\n\n \nstruct vidtv_psi_table_pmt**\nvidtv_psi_pmt_create_sec_for_each_pat_entry(struct vidtv_psi_table_pat *pat,\n\t\t\t\t\t    u16 pcr_pid)\n\n{\n\tstruct vidtv_psi_table_pat_program *program;\n\tstruct vidtv_psi_table_pmt **pmt_secs;\n\tu32 i = 0, num_pmt = 0;\n\n\t \n\tprogram = pat->program;\n\twhile (program) {\n\t\tif (program->service_id)\n\t\t\tnum_pmt++;\n\t\tprogram = program->next;\n\t}\n\n\tpmt_secs = kcalloc(num_pmt,\n\t\t\t   sizeof(struct vidtv_psi_table_pmt *),\n\t\t\t   GFP_KERNEL);\n\tif (!pmt_secs)\n\t\treturn NULL;\n\n\tfor (program = pat->program; program; program = program->next) {\n\t\tif (!program->service_id)\n\t\t\tcontinue;\n\t\tpmt_secs[i] = vidtv_psi_pmt_table_init(be16_to_cpu(program->service_id),\n\t\t\t\t\t\t       pcr_pid);\n\n\t\tif (!pmt_secs[i]) {\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tvidtv_psi_pmt_table_destroy(pmt_secs[i]);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\ti++;\n\t}\n\tpat->num_pmt = num_pmt;\n\n\treturn pmt_secs;\n}\n\n \nstruct vidtv_psi_table_pmt\n*vidtv_psi_find_pmt_sec(struct vidtv_psi_table_pmt **pmt_sections,\n\t\t\tu16 nsections,\n\t\t\tu16 program_num)\n{\n\tstruct vidtv_psi_table_pmt *sec = NULL;\n\tu32 i;\n\n\tfor (i = 0; i < nsections; ++i) {\n\t\tsec = pmt_sections[i];\n\t\tif (be16_to_cpu(sec->header.id) == program_num)\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;  \n}\n\nstatic void vidtv_psi_nit_table_update_sec_len(struct vidtv_psi_table_nit *nit)\n{\n\tu16 length = 0;\n\tstruct vidtv_psi_table_transport *t = nit->transport;\n\tu16 desc_loop_len;\n\tu16 transport_loop_len = 0;\n\n\t \n\tlength += NIT_LEN_UNTIL_NETWORK_DESCRIPTOR_LEN;\n\n\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(nit->descriptor);\n\tvidtv_psi_set_desc_loop_len(&nit->bitfield, desc_loop_len, 12);\n\n\tlength += desc_loop_len;\n\n\tlength += sizeof_field(struct vidtv_psi_table_nit, bitfield2);\n\n\twhile (t) {\n\t\t \n\t\ttransport_loop_len += sizeof(struct vidtv_psi_table_transport) -\n\t\t\t\t      sizeof(struct vidtv_psi_desc *) -\n\t\t\t\t      sizeof(struct vidtv_psi_table_transport *);\n\n\t\tlength += transport_loop_len;\n\n\t\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(t->descriptor);\n\t\tvidtv_psi_set_desc_loop_len(&t->bitfield, desc_loop_len, 12);\n\n\t\tlength += desc_loop_len;\n\n\t\tt = t->next;\n\t}\n\n\t \n\tvidtv_psi_set_desc_loop_len(&nit->bitfield2, transport_loop_len, 12);\n\tlength += CRC_SIZE_IN_BYTES;\n\n\tvidtv_psi_set_sec_len(&nit->header, length);\n}\n\nstruct vidtv_psi_table_nit\n*vidtv_psi_nit_table_init(u16 network_id,\n\t\t\t  u16 transport_stream_id,\n\t\t\t  char *network_name,\n\t\t\t  struct vidtv_psi_desc_service_list_entry *service_list)\n{\n\tstruct vidtv_psi_table_transport *transport;\n\tstruct vidtv_psi_table_nit *nit;\n\tconst u16 SYNTAX = 0x1;\n\tconst u16 ONES = 0x03;\n\tconst u16 ONE = 0x1;\n\n\tnit = kzalloc(sizeof(*nit), GFP_KERNEL);\n\tif (!nit)\n\t\treturn NULL;\n\n\ttransport = kzalloc(sizeof(*transport), GFP_KERNEL);\n\tif (!transport)\n\t\tgoto free_nit;\n\n\tnit->header.table_id = 0x40;  \n\n\tnit->header.bitfield = cpu_to_be16((SYNTAX << 15) | (ONE << 14) | (ONES << 12));\n\n\tnit->header.id = cpu_to_be16(network_id);\n\tnit->header.current_next = ONE;\n\n\tnit->header.version = 0x1f;\n\n\tnit->header.one2  = ONES;\n\tnit->header.section_id   = 0;\n\tnit->header.last_section = 0;\n\n\tnit->bitfield = cpu_to_be16(0xf);\n\tnit->bitfield2 = cpu_to_be16(0xf);\n\n\tnit->descriptor = (struct vidtv_psi_desc *)\n\t\t\t  vidtv_psi_network_name_desc_init(NULL, network_name);\n\tif (!nit->descriptor)\n\t\tgoto free_transport;\n\n\ttransport->transport_id = cpu_to_be16(transport_stream_id);\n\ttransport->network_id = cpu_to_be16(network_id);\n\ttransport->bitfield = cpu_to_be16(0xf);\n\ttransport->descriptor = (struct vidtv_psi_desc *)\n\t\t\t\tvidtv_psi_service_list_desc_init(NULL, service_list);\n\tif (!transport->descriptor)\n\t\tgoto free_nit_desc;\n\n\tnit->transport = transport;\n\n\tvidtv_psi_nit_table_update_sec_len(nit);\n\n\treturn nit;\n\nfree_nit_desc:\n\tvidtv_psi_desc_destroy((struct vidtv_psi_desc *)nit->descriptor);\n\nfree_transport:\n\tkfree(transport);\nfree_nit:\n\tkfree(nit);\n\treturn NULL;\n}\n\nu32 vidtv_psi_nit_write_into(struct vidtv_psi_nit_write_args *args)\n{\n\tstruct header_write_args h_args = {\n\t\t.dest_buf           = args->buf,\n\t\t.dest_offset        = args->offset,\n\t\t.h                  = &args->nit->header,\n\t\t.pid                = VIDTV_NIT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct psi_write_args psi_args  = {\n\t\t.dest_buf           = args->buf,\n\t\t.from               = &args->nit->bitfield,\n\t\t.len                = sizeof_field(struct vidtv_psi_table_nit, bitfield),\n\t\t.pid                = VIDTV_NIT_PID,\n\t\t.new_psi_section    = false,\n\t\t.is_crc             = false,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct desc_write_args d_args   = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_NIT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct crc32_write_args c_args  = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_NIT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct vidtv_psi_desc *table_descriptor     = args->nit->descriptor;\n\tstruct vidtv_psi_table_transport *transport = args->nit->transport;\n\tstruct vidtv_psi_desc *transport_descriptor;\n\tu32 crc = INITIAL_CRC;\n\tu32 nbytes = 0;\n\n\tvidtv_psi_nit_table_update_sec_len(args->nit);\n\n\th_args.continuity_counter = args->continuity_counter;\n\th_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_table_header_write_into(&h_args);\n\n\t \n\n\tpsi_args.dest_offset        = args->offset + nbytes;\n\tpsi_args.continuity_counter = args->continuity_counter;\n\tpsi_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\twhile (table_descriptor) {\n\t\t \n\t\td_args.dest_offset        = args->offset + nbytes;\n\t\td_args.desc               = table_descriptor;\n\t\td_args.continuity_counter = args->continuity_counter;\n\t\td_args.crc                = &crc;\n\n\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\ttable_descriptor = table_descriptor->next;\n\t}\n\n\t \n\tpsi_args.from = &args->nit->bitfield2;\n\tpsi_args.len = sizeof_field(struct vidtv_psi_table_nit, bitfield2);\n\tpsi_args.dest_offset = args->offset + nbytes;\n\n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\tpsi_args.len  = sizeof_field(struct vidtv_psi_table_transport, transport_id) +\n\t\t\tsizeof_field(struct vidtv_psi_table_transport, network_id)   +\n\t\t\tsizeof_field(struct vidtv_psi_table_transport, bitfield);\n\twhile (transport) {\n\t\t \n\t\tpsi_args.from = transport;\n\t\tpsi_args.dest_offset = args->offset + nbytes;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\ttransport_descriptor = transport->descriptor;\n\n\t\twhile (transport_descriptor) {\n\t\t\t \n\t\t\td_args.dest_offset        = args->offset + nbytes;\n\t\t\td_args.desc               = transport_descriptor;\n\t\t\td_args.continuity_counter = args->continuity_counter;\n\t\t\td_args.crc                = &crc;\n\n\t\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\t\ttransport_descriptor = transport_descriptor->next;\n\t\t}\n\n\t\ttransport = transport->next;\n\t}\n\n\tc_args.dest_offset        = args->offset + nbytes;\n\tc_args.crc                = cpu_to_be32(crc);\n\tc_args.continuity_counter = args->continuity_counter;\n\n\t \n\tnbytes += table_section_crc32_write_into(&c_args);\n\n\treturn nbytes;\n}\n\nstatic void vidtv_psi_transport_destroy(struct vidtv_psi_table_transport *t)\n{\n\tstruct vidtv_psi_table_transport *tmp_t  = NULL;\n\tstruct vidtv_psi_table_transport *curr_t = t;\n\n\twhile (curr_t) {\n\t\ttmp_t  = curr_t;\n\t\tcurr_t = curr_t->next;\n\t\tvidtv_psi_desc_destroy(tmp_t->descriptor);\n\t\tkfree(tmp_t);\n\t}\n}\n\nvoid vidtv_psi_nit_table_destroy(struct vidtv_psi_table_nit *nit)\n{\n\tvidtv_psi_desc_destroy(nit->descriptor);\n\tvidtv_psi_transport_destroy(nit->transport);\n\tkfree(nit);\n}\n\nvoid vidtv_psi_eit_table_update_sec_len(struct vidtv_psi_table_eit *eit)\n{\n\tstruct vidtv_psi_table_eit_event *e = eit->event;\n\tu16 desc_loop_len;\n\tu16 length = 0;\n\n\t \n\tlength += EIT_LEN_UNTIL_LAST_TABLE_ID;\n\n\twhile (e) {\n\t\t \n\t\tlength += sizeof(struct vidtv_psi_table_eit_event) -\n\t\t\t  sizeof(struct vidtv_psi_desc *) -\n\t\t\t  sizeof(struct vidtv_psi_table_eit_event *);\n\n\t\tdesc_loop_len = vidtv_psi_desc_comp_loop_len(e->descriptor);\n\t\tvidtv_psi_set_desc_loop_len(&e->bitfield, desc_loop_len, 12);\n\n\t\tlength += desc_loop_len;\n\n\t\te = e->next;\n\t}\n\n\tlength += CRC_SIZE_IN_BYTES;\n\n\tvidtv_psi_set_sec_len(&eit->header, length);\n}\n\nvoid vidtv_psi_eit_event_assign(struct vidtv_psi_table_eit *eit,\n\t\t\t\tstruct vidtv_psi_table_eit_event *e)\n{\n\tdo {\n\t\tif (e == eit->event)\n\t\t\treturn;\n\n\t\teit->event = e;\n\t\tvidtv_psi_eit_table_update_sec_len(eit);\n\n\t\te = NULL;\n\t} while (vidtv_psi_get_sec_len(&eit->header) > EIT_MAX_SECTION_LEN);\n\n\tvidtv_psi_update_version_num(&eit->header);\n}\n\nstruct vidtv_psi_table_eit\n*vidtv_psi_eit_table_init(u16 network_id,\n\t\t\t  u16 transport_stream_id,\n\t\t\t  __be16 service_id)\n{\n\tstruct vidtv_psi_table_eit *eit;\n\tconst u16 SYNTAX = 0x1;\n\tconst u16 ONE = 0x1;\n\tconst u16 ONES = 0x03;\n\n\teit = kzalloc(sizeof(*eit), GFP_KERNEL);\n\tif (!eit)\n\t\treturn NULL;\n\n\teit->header.table_id = 0x4e;  \n\n\teit->header.bitfield = cpu_to_be16((SYNTAX << 15) | (ONE << 14) | (ONES << 12));\n\n\teit->header.id = service_id;\n\teit->header.current_next = ONE;\n\n\teit->header.version = 0x1f;\n\n\teit->header.one2  = ONES;\n\teit->header.section_id   = 0;\n\teit->header.last_section = 0;\n\n\teit->transport_id = cpu_to_be16(transport_stream_id);\n\teit->network_id = cpu_to_be16(network_id);\n\n\teit->last_segment = eit->header.last_section;  \n\teit->last_table_id = eit->header.table_id;  \n\n\tvidtv_psi_eit_table_update_sec_len(eit);\n\n\treturn eit;\n}\n\nu32 vidtv_psi_eit_write_into(struct vidtv_psi_eit_write_args *args)\n{\n\tstruct header_write_args h_args = {\n\t\t.dest_buf        = args->buf,\n\t\t.dest_offset     = args->offset,\n\t\t.h               = &args->eit->header,\n\t\t.pid             = VIDTV_EIT_PID,\n\t\t.dest_buf_sz     = args->buf_sz,\n\t};\n\tstruct psi_write_args psi_args  = {\n\t\t.dest_buf        = args->buf,\n\t\t.len             = sizeof_field(struct vidtv_psi_table_eit, transport_id) +\n\t\t\t\t   sizeof_field(struct vidtv_psi_table_eit, network_id)   +\n\t\t\t\t   sizeof_field(struct vidtv_psi_table_eit, last_segment) +\n\t\t\t\t   sizeof_field(struct vidtv_psi_table_eit, last_table_id),\n\t\t.pid             = VIDTV_EIT_PID,\n\t\t.new_psi_section = false,\n\t\t.is_crc          = false,\n\t\t.dest_buf_sz     = args->buf_sz,\n\t};\n\tstruct desc_write_args d_args   = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_EIT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct crc32_write_args c_args  = {\n\t\t.dest_buf           = args->buf,\n\t\t.pid                = VIDTV_EIT_PID,\n\t\t.dest_buf_sz        = args->buf_sz,\n\t};\n\tstruct vidtv_psi_table_eit_event *event = args->eit->event;\n\tstruct vidtv_psi_desc *event_descriptor;\n\tu32 crc = INITIAL_CRC;\n\tu32 nbytes  = 0;\n\n\tvidtv_psi_eit_table_update_sec_len(args->eit);\n\n\th_args.continuity_counter = args->continuity_counter;\n\th_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_table_header_write_into(&h_args);\n\n\tpsi_args.from               = &args->eit->transport_id;\n\tpsi_args.dest_offset        = args->offset + nbytes;\n\tpsi_args.continuity_counter = args->continuity_counter;\n\tpsi_args.crc                = &crc;\n\n\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t \n\tpsi_args.len = sizeof(struct vidtv_psi_table_eit_event) -\n\t\t       sizeof(struct vidtv_psi_desc *) -\n\t\t       sizeof(struct vidtv_psi_table_eit_event *);\n\twhile (event) {\n\t\t \n\t\tpsi_args.from = event;\n\t\tpsi_args.dest_offset = args->offset + nbytes;\n\n\t\tnbytes += vidtv_psi_ts_psi_write_into(&psi_args);\n\n\t\tevent_descriptor = event->descriptor;\n\n\t\twhile (event_descriptor) {\n\t\t\t \n\t\t\td_args.dest_offset        = args->offset + nbytes;\n\t\t\td_args.desc               = event_descriptor;\n\t\t\td_args.continuity_counter = args->continuity_counter;\n\t\t\td_args.crc                = &crc;\n\n\t\t\tnbytes += vidtv_psi_desc_write_into(&d_args);\n\n\t\t\tevent_descriptor = event_descriptor->next;\n\t\t}\n\n\t\tevent = event->next;\n\t}\n\n\tc_args.dest_offset        = args->offset + nbytes;\n\tc_args.crc                = cpu_to_be32(crc);\n\tc_args.continuity_counter = args->continuity_counter;\n\n\t \n\tnbytes += table_section_crc32_write_into(&c_args);\n\n\treturn nbytes;\n}\n\nstruct vidtv_psi_table_eit_event\n*vidtv_psi_eit_event_init(struct vidtv_psi_table_eit_event *head, u16 event_id)\n{\n\tstatic const u8 DURATION[] = {0x23, 0x59, 0x59};  \n\tstruct vidtv_psi_table_eit_event *e;\n\tstruct timespec64 ts;\n\tstruct tm time;\n\tint mjd, l;\n\t__be16 mjd_be;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\te->event_id = cpu_to_be16(event_id);\n\n\tts = ktime_to_timespec64(ktime_get_real());\n\ttime64_to_tm(ts.tv_sec, 0, &time);\n\n\t \n\tif (time.tm_mon < 2)\n\t\tl = 1;\n\telse\n\t\tl = 0;\n\n\tmjd = 14956 + time.tm_mday;\n\tmjd += (time.tm_year - l) * 36525 / 100;\n\tmjd += (time.tm_mon + 2 + l * 12) * 306001 / 10000;\n\tmjd_be = cpu_to_be16(mjd);\n\n\t \n\tmemcpy(e->start_time, &mjd_be, sizeof(mjd_be));\n\te->start_time[2] = bin2bcd(time.tm_hour);\n\te->start_time[3] = 0;\n\te->start_time[4] = 0;\n\n\t \n\tmemcpy(e->duration, DURATION, sizeof(e->duration));\n\n\te->bitfield = cpu_to_be16(RUNNING << 13);\n\n\tif (head) {\n\t\twhile (head->next)\n\t\t\thead = head->next;\n\n\t\thead->next = e;\n\t}\n\n\treturn e;\n}\n\nvoid vidtv_psi_eit_event_destroy(struct vidtv_psi_table_eit_event *e)\n{\n\tstruct vidtv_psi_table_eit_event *tmp_e  = NULL;\n\tstruct vidtv_psi_table_eit_event *curr_e = e;\n\n\twhile (curr_e) {\n\t\ttmp_e  = curr_e;\n\t\tcurr_e = curr_e->next;\n\t\tvidtv_psi_desc_destroy(tmp_e->descriptor);\n\t\tkfree(tmp_e);\n\t}\n}\n\nvoid vidtv_psi_eit_table_destroy(struct vidtv_psi_table_eit *eit)\n{\n\tvidtv_psi_eit_event_destroy(eit->event);\n\tkfree(eit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}