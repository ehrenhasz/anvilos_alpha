{
  "module_name": "vidtv_demod.c",
  "hash_id": "203d19096abd97f52b7843f04008fb064aee400781acf9a903f0f323ec388c4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vidtv/vidtv_demod.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"vidtv_demod.h\"\n\n#define POLL_THRD_TIME 2000  \n\nstatic const struct vidtv_demod_cnr_to_qual_s vidtv_demod_c_cnr_2_qual[] = {\n\t \n\t{ QAM_256, FEC_NONE,  34000, 38000},\n\t{ QAM_64,  FEC_NONE,  30000, 34000},\n};\n\nstatic const struct vidtv_demod_cnr_to_qual_s vidtv_demod_s_cnr_2_qual[] = {\n\t \n\t{ QPSK, FEC_1_2,  7000, 10000},\n\t{ QPSK, FEC_2_3,  9000, 12000},\n\t{ QPSK, FEC_3_4, 10000, 13000},\n\t{ QPSK, FEC_5_6, 11000, 14000},\n\t{ QPSK, FEC_7_8, 12000, 15000},\n};\n\nstatic const struct vidtv_demod_cnr_to_qual_s vidtv_demod_s2_cnr_2_qual[] = {\n\t \n\t{ QPSK,  FEC_1_2,   9000,  12000},\n\t{ QPSK,  FEC_2_3,  11000,  14000},\n\t{ QPSK,  FEC_3_4,  12000,  15000},\n\t{ QPSK,  FEC_5_6,  12000,  15000},\n\t{ QPSK,  FEC_8_9,  13000,  16000},\n\t{ QPSK,  FEC_9_10, 13500,  16500},\n\t{ PSK_8, FEC_2_3,  14500,  17500},\n\t{ PSK_8, FEC_3_4,  16000,  19000},\n\t{ PSK_8, FEC_5_6,  17500,  20500},\n\t{ PSK_8, FEC_8_9,  19000,  22000},\n};\n\nstatic const struct vidtv_demod_cnr_to_qual_s vidtv_demod_t_cnr_2_qual[] = {\n\t \n\t{   QPSK, FEC_1_2,  4100,  5900},\n\t{   QPSK, FEC_2_3,  6100,  9600},\n\t{   QPSK, FEC_3_4,  7200, 12400},\n\t{   QPSK, FEC_5_6,  8500, 15600},\n\t{   QPSK, FEC_7_8,  9200, 17500},\n\t{ QAM_16, FEC_1_2,  9800, 11800},\n\t{ QAM_16, FEC_2_3, 12100, 15300},\n\t{ QAM_16, FEC_3_4, 13400, 18100},\n\t{ QAM_16, FEC_5_6, 14800, 21300},\n\t{ QAM_16, FEC_7_8, 15700, 23600},\n\t{ QAM_64, FEC_1_2, 14000, 16000},\n\t{ QAM_64, FEC_2_3, 19900, 25400},\n\t{ QAM_64, FEC_3_4, 24900, 27900},\n\t{ QAM_64, FEC_5_6, 21300, 23300},\n\t{ QAM_64, FEC_7_8, 22000, 24000},\n};\n\nstatic const struct vidtv_demod_cnr_to_qual_s *vidtv_match_cnr_s(struct dvb_frontend *fe)\n{\n\tconst struct vidtv_demod_cnr_to_qual_s *cnr2qual = NULL;\n\tstruct device *dev = fe->dvb->device;\n\tstruct dtv_frontend_properties *c;\n\tu32 array_size = 0;\n\tu32 i;\n\n\tc = &fe->dtv_property_cache;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tcnr2qual   = vidtv_demod_t_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_demod_t_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBS:\n\t\tcnr2qual   = vidtv_demod_s_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_demod_s_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tcnr2qual   = vidtv_demod_s2_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_demod_s2_cnr_2_qual);\n\t\tbreak;\n\n\tcase SYS_DVBC_ANNEX_A:\n\t\tcnr2qual   = vidtv_demod_c_cnr_2_qual;\n\t\tarray_size = ARRAY_SIZE(vidtv_demod_c_cnr_2_qual);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"%s: unsupported delivery system: %u\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     c->delivery_system);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < array_size; i++)\n\t\tif (cnr2qual[i].modulation == c->modulation &&\n\t\t    cnr2qual[i].fec == c->fec_inner)\n\t\t\treturn &cnr2qual[i];\n\n\treturn NULL;  \n}\n\nstatic void vidtv_clean_stats(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t \n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].svalue = 0;\n\n\t \n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.stat[0].svalue = 0;\n\tc->cnr.len = 1;\n\n\t \n\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->pre_bit_error.stat[0].uvalue = 0;\n\tc->pre_bit_error.len = 1;\n\tc->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->pre_bit_count.stat[0].uvalue = 0;\n\tc->pre_bit_count.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.stat[0].uvalue = 0;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].uvalue = 0;\n\tc->post_bit_count.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.stat[0].uvalue = 0;\n\tc->block_error.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.stat[0].uvalue = 0;\n\tc->block_count.len = 1;\n}\n\nstatic void vidtv_demod_update_stats(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct vidtv_demod_state *state = fe->demodulator_priv;\n\tu32 scale;\n\n\tif (state->status & FE_HAS_LOCK) {\n\t\tscale = FE_SCALE_COUNTER;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else {\n\t\tscale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->cnr.stat[0].scale = scale;\n\t}\n\n\tc->pre_bit_error.stat[0].scale = scale;\n\tc->pre_bit_count.stat[0].scale = scale;\n\tc->post_bit_error.stat[0].scale = scale;\n\tc->post_bit_count.stat[0].scale = scale;\n\tc->block_error.stat[0].scale = scale;\n\tc->block_count.stat[0].scale = scale;\n\n\t \n\tc->strength.stat[0].svalue = state->tuner_cnr;\n\tc->strength.stat[0].svalue -= get_random_u32_below(state->tuner_cnr / 50);\n\tc->strength.stat[0].svalue -= 68000;  \n\n\tc->cnr.stat[0].svalue = state->tuner_cnr;\n\tc->cnr.stat[0].svalue -= get_random_u32_below(state->tuner_cnr / 50);\n}\n\nstatic int vidtv_demod_read_status(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_status *status)\n{\n\tstruct vidtv_demod_state *state = fe->demodulator_priv;\n\tconst struct vidtv_demod_cnr_to_qual_s *cnr2qual = NULL;\n\tstruct vidtv_demod_config *config = &state->config;\n\tu16 snr = 0;\n\n\t \n\tcnr2qual = vidtv_match_cnr_s(&state->frontend);\n\n\tif (cnr2qual && state->tuner_cnr < cnr2qual->cnr_good &&\n\t    state->frontend.ops.tuner_ops.get_rf_strength) {\n\t\tstate->frontend.ops.tuner_ops.get_rf_strength(&state->frontend,\n\t\t\t\t\t\t\t      &snr);\n\n\t\tif (snr < cnr2qual->cnr_ok) {\n\t\t\t \n\t\t\tif (get_random_u32_below(100) < config->drop_tslock_prob_on_low_snr)\n\t\t\t\tstate->status = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (get_random_u32_below(100) <\n\t\t\t    config->recover_tslock_prob_on_good_snr)\n\t\t\t\tstate->status = FE_HAS_SIGNAL  |\n\t\t\t\t\t\tFE_HAS_CARRIER |\n\t\t\t\t\t\tFE_HAS_VITERBI |\n\t\t\t\t\t\tFE_HAS_SYNC    |\n\t\t\t\t\t\tFE_HAS_LOCK;\n\t\t}\n\t}\n\n\tvidtv_demod_update_stats(&state->frontend);\n\n\t*status = state->status;\n\n\treturn 0;\n}\n\nstatic int vidtv_demod_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t    u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t*strength = c->strength.stat[0].uvalue;\n\n\treturn 0;\n}\n\n \nstatic int vidtv_demod_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t    struct dtv_frontend_properties *p)\n{\n\treturn 0;\n}\n\nstatic int vidtv_demod_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct vidtv_demod_state *state = fe->demodulator_priv;\n\tu32 tuner_status = 0;\n\tint ret;\n\n\tif (!fe->ops.tuner_ops.set_params)\n\t\treturn 0;\n\n\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tret = fe->ops.tuner_ops.get_rf_strength(fe, &state->tuner_cnr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfe->ops.tuner_ops.get_status(fe, &tuner_status);\n\tstate->status = (state->tuner_cnr > 0) ?  FE_HAS_SIGNAL  |\n\t\t\t\t\t\t    FE_HAS_CARRIER |\n\t\t\t\t\t\t    FE_HAS_VITERBI |\n\t\t\t\t\t\t    FE_HAS_SYNC    |\n\t\t\t\t\t\t    FE_HAS_LOCK\t :\n\t\t\t\t\t\t    0;\n\n\tvidtv_demod_update_stats(fe);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\n \nstatic int vidtv_demod_set_tone(struct dvb_frontend *fe,\n\t\t\t\tenum fe_sec_tone_mode tone)\n{\n\treturn 0;\n}\n\n \nstatic int vidtv_demod_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_sec_voltage voltage)\n{\n\treturn 0;\n}\n\n \nstatic int vidtv_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t struct dvb_diseqc_master_cmd *cmd)\n{\n\treturn 0;\n}\n\n \nstatic int vidtv_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_sec_mini_cmd burst)\n{\n\treturn 0;\n}\n\nstatic void vidtv_demod_release(struct dvb_frontend *fe)\n{\n\tstruct vidtv_demod_state *state = fe->demodulator_priv;\n\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops vidtv_demod_ops = {\n\t.delsys = {\n\t\tSYS_DVBT,\n\t\tSYS_DVBT2,\n\t\tSYS_DVBC_ANNEX_A,\n\t\tSYS_DVBS,\n\t\tSYS_DVBS2,\n\t},\n\n\t.info = {\n\t\t.name                   = \"Dummy demod for DVB-T/T2/C/S/S2\",\n\t\t.frequency_min_hz       = 51 * MHz,\n\t\t.frequency_max_hz       = 2150 * MHz,\n\t\t.frequency_stepsize_hz  = 62500,\n\t\t.frequency_tolerance_hz = 29500 * kHz,\n\t\t.symbol_rate_min        = 1000000,\n\t\t.symbol_rate_max        = 45000000,\n\n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_8_9 |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release = vidtv_demod_release,\n\n\t.set_frontend = vidtv_demod_set_frontend,\n\t.get_frontend = vidtv_demod_get_frontend,\n\n\t.read_status          = vidtv_demod_read_status,\n\t.read_signal_strength = vidtv_demod_read_signal_strength,\n\n\t \n\t.set_voltage\t\t= vidtv_demod_set_voltage,\n\t.set_tone\t\t= vidtv_demod_set_tone,\n\t.diseqc_send_master_cmd\t= vidtv_send_diseqc_msg,\n\t.diseqc_send_burst\t= vidtv_diseqc_send_burst,\n\n};\n\nstatic const struct i2c_device_id vidtv_demod_i2c_id_table[] = {\n\t{\"dvb_vidtv_demod\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, vidtv_demod_i2c_id_table);\n\nstatic int vidtv_demod_i2c_probe(struct i2c_client *client)\n{\n\tstruct vidtv_tuner_config *config = client->dev.platform_data;\n\tstruct vidtv_demod_state *state;\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&state->frontend.ops,\n\t       &vidtv_demod_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tmemcpy(&state->config, config, sizeof(state->config));\n\n\tstate->frontend.demodulator_priv = state;\n\ti2c_set_clientdata(client, state);\n\n\tvidtv_clean_stats(&state->frontend);\n\n\treturn 0;\n}\n\nstatic void vidtv_demod_i2c_remove(struct i2c_client *client)\n{\n\tstruct vidtv_demod_state *state = i2c_get_clientdata(client);\n\n\tkfree(state);\n}\n\nstatic struct i2c_driver vidtv_demod_i2c_driver = {\n\t.driver = {\n\t\t.name                = \"dvb_vidtv_demod\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe    = vidtv_demod_i2c_probe,\n\t.remove   = vidtv_demod_i2c_remove,\n\t.id_table = vidtv_demod_i2c_id_table,\n};\n\nmodule_i2c_driver(vidtv_demod_i2c_driver);\n\nMODULE_DESCRIPTION(\"Virtual DVB Demodulator Driver\");\nMODULE_AUTHOR(\"Daniel W. S. Almeida\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}