{
  "module_name": "vim2m.c",
  "hash_id": "2160c89f712881b1bcfd990563de7c7e5abd3f1ce1cf6756b04d77ee0754ecff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vim2m.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-vmalloc.h>\n\nMODULE_DESCRIPTION(\"Virtual device for mem2mem framework testing\");\nMODULE_AUTHOR(\"Pawel Osciak, <pawel@osciak.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2\");\nMODULE_ALIAS(\"mem2mem_testdev\");\n\nstatic unsigned int debug;\nmodule_param(debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"debug level\");\n\n \nstatic unsigned int default_transtime = 40;  \nmodule_param(default_transtime, uint, 0644);\nMODULE_PARM_DESC(default_transtime, \"default transaction time in ms\");\n\n#define MIN_W 32\n#define MIN_H 32\n#define MAX_W 640\n#define MAX_H 480\n\n \n#define WIDTH_ALIGN 2\n#define HEIGHT_ALIGN 1\n\n \n#define BAYER_WIDTH_ALIGN  2\n#define BAYER_HEIGHT_ALIGN 2\n\n \n#define MEM2MEM_CAPTURE\tBIT(0)\n#define MEM2MEM_OUTPUT\tBIT(1)\n\n#define MEM2MEM_NAME\t\t\"vim2m\"\n\n \n#define MEM2MEM_DEF_NUM_BUFS\tVIDEO_MAX_FRAME\n \n#define MEM2MEM_VID_MEM_LIMIT\t(16 * 1024 * 1024)\n\n \n#define MEM2MEM_HFLIP\tBIT(0)\n#define MEM2MEM_VFLIP\tBIT(1)\n\n#define dprintk(dev, lvl, fmt, arg...) \\\n\tv4l2_dbg(lvl, debug, &(dev)->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\nstatic void vim2m_dev_release(struct device *dev)\n{}\n\nstatic struct platform_device vim2m_pdev = {\n\t.name\t\t= MEM2MEM_NAME,\n\t.dev.release\t= vim2m_dev_release,\n};\n\nstruct vim2m_fmt {\n\tu32\tfourcc;\n\tint\tdepth;\n\t \n\tu32     types;\n};\n\nstatic struct vim2m_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565,   \n\t\t.depth\t= 16,\n\t\t.types  = MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565X,  \n\t\t.depth\t= 16,\n\t\t.types  = MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB24,\n\t\t.depth\t= 24,\n\t\t.types  = MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_BGR24,\n\t\t.depth\t= 24,\n\t\t.types  = MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t= 16,\n\t\t.types  = MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.depth\t= 8,\n\t\t.types  = MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.depth\t= 8,\n\t\t.types  = MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.depth\t= 8,\n\t\t.types  = MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.depth\t= 8,\n\t\t.types  = MEM2MEM_CAPTURE,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\n \nstruct vim2m_q_data {\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tsizeimage;\n\tunsigned int\t\tsequence;\n\tstruct vim2m_fmt\t*fmt;\n};\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\n#define V4L2_CID_TRANS_TIME_MSEC\t(V4L2_CID_USER_BASE + 0x1000)\n#define V4L2_CID_TRANS_NUM_BUFS\t\t(V4L2_CID_USER_BASE + 0x1001)\n\nstatic struct vim2m_fmt *find_format(u32 fourcc)\n{\n\tstruct vim2m_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < NUM_FORMATS; k++) {\n\t\tfmt = &formats[k];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\tbreak;\n\t}\n\n\tif (k == NUM_FORMATS)\n\t\treturn NULL;\n\n\treturn &formats[k];\n}\n\nstatic void get_alignment(u32 fourcc,\n\t\t\t  unsigned int *walign, unsigned int *halign)\n{\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\t*walign = BAYER_WIDTH_ALIGN;\n\t\t*halign = BAYER_HEIGHT_ALIGN;\n\t\treturn;\n\tdefault:\n\t\t*walign = WIDTH_ALIGN;\n\t\t*halign = HEIGHT_ALIGN;\n\t\treturn;\n\t}\n}\n\nstruct vim2m_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device\tmdev;\n#endif\n\n\tatomic_t\t\tnum_inst;\n\tstruct mutex\t\tdev_mutex;\n\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n};\n\nstruct vim2m_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct vim2m_dev\t*dev;\n\n\tstruct v4l2_ctrl_handler hdl;\n\n\t \n\tu8\t\t\tnum_processed;\n\n\t \n\tu32\t\t\ttranslen;\n\t \n\tu32\t\t\ttranstime;\n\n\tstruct mutex\t\tvb_mutex;\n\tstruct delayed_work\twork_run;\n\n\t \n\tint\t\t\taborting;\n\n\t \n\tint\t\t\tmode;\n\n\tenum v4l2_colorspace\tcolorspace;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_xfer_func\txfer_func;\n\tenum v4l2_quantization\tquant;\n\n\t \n\tstruct vim2m_q_data   q_data[2];\n};\n\nstatic inline struct vim2m_ctx *file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct vim2m_ctx, fh);\n}\n\nstatic struct vim2m_q_data *get_q_data(struct vim2m_ctx *ctx,\n\t\t\t\t       enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->q_data[V4L2_M2M_SRC];\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->q_data[V4L2_M2M_DST];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic const char *type_name(enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn \"Output\";\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn \"Capture\";\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\n#define CLIP(__color) \\\n\t(u8)(((__color) > 0xff) ? 0xff : (((__color) < 0) ? 0 : (__color)))\n\nstatic void copy_line(struct vim2m_q_data *q_data_out,\n\t\t      u8 *src, u8 *dst, bool reverse)\n{\n\tint x, depth = q_data_out->fmt->depth >> 3;\n\n\tif (!reverse) {\n\t\tmemcpy(dst, src, q_data_out->width * depth);\n\t} else {\n\t\tfor (x = 0; x < q_data_out->width >> 1; x++) {\n\t\t\tmemcpy(dst, src, depth);\n\t\t\tmemcpy(dst + depth, src - depth, depth);\n\t\t\tsrc -= depth << 1;\n\t\t\tdst += depth << 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic void copy_two_pixels(struct vim2m_q_data *q_data_in,\n\t\t\t    struct vim2m_q_data *q_data_out,\n\t\t\t    u8 *src[2], u8 **dst, int ypos, bool reverse)\n{\n\tstruct vim2m_fmt *out = q_data_out->fmt;\n\tstruct vim2m_fmt *in = q_data_in->fmt;\n\tu8 _r[2], _g[2], _b[2], *r, *g, *b;\n\tint i;\n\n\t \n\n\tr = _r;\n\tg = _g;\n\tb = _b;\n\n\tswitch (in->fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:  \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu16 pix = le16_to_cpu(*(__le16 *)(src[i]));\n\n\t\t\t*r++ = (u8)(((pix & 0xf800) >> 11) << 3) | 0x07;\n\t\t\t*g++ = (u8)((((pix & 0x07e0) >> 5)) << 2) | 0x03;\n\t\t\t*b++ = (u8)((pix & 0x1f) << 3) | 0x07;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565X:  \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu16 pix = be16_to_cpu(*(__be16 *)(src[i]));\n\n\t\t\t*r++ = (u8)(((pix & 0xf800) >> 11) << 3) | 0x07;\n\t\t\t*g++ = (u8)((((pix & 0x07e0) >> 5)) << 2) | 0x03;\n\t\t\t*b++ = (u8)((pix & 0x1f) << 3) | 0x07;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t*r++ = src[i][0];\n\t\t\t*g++ = src[i][1];\n\t\t\t*b++ = src[i][2];\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t*b++ = src[i][0];\n\t\t\t*g++ = src[i][1];\n\t\t\t*r++ = src[i][2];\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\n\tr = _r;\n\tg = _g;\n\tb = _b;\n\n\tswitch (out->fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:  \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu16 pix;\n\t\t\t__le16 *dst_pix = (__le16 *)*dst;\n\n\t\t\tpix = ((*r << 8) & 0xf800) | ((*g << 3) & 0x07e0) |\n\t\t\t      (*b >> 3);\n\n\t\t\t*dst_pix = cpu_to_le16(pix);\n\n\t\t\t*dst += 2;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_RGB565X:  \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu16 pix;\n\t\t\t__be16 *dst_pix = (__be16 *)*dst;\n\n\t\t\tpix = ((*r << 8) & 0xf800) | ((*g << 3) & 0x07e0) |\n\t\t\t      (*b >> 3);\n\n\t\t\t*dst_pix = cpu_to_be16(pix);\n\n\t\t\t*dst += 2;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t*(*dst)++ = *r++;\n\t\t\t*(*dst)++ = *g++;\n\t\t\t*(*dst)++ = *b++;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_BGR24:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t*(*dst)++ = *b++;\n\t\t\t*(*dst)++ = *g++;\n\t\t\t*(*dst)++ = *r++;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t{\n\t\tu8 y, y1, u, v;\n\n\t\ty = ((8453  * (*r) + 16594 * (*g) +  3223 * (*b)\n\t\t     + 524288) >> 15);\n\t\tu = ((-4878 * (*r) - 9578  * (*g) + 14456 * (*b)\n\t\t     + 4210688) >> 15);\n\t\tv = ((14456 * (*r++) - 12105 * (*g++) - 2351 * (*b++)\n\t\t     + 4210688) >> 15);\n\t\ty1 = ((8453 * (*r) + 16594 * (*g) +  3223 * (*b)\n\t\t     + 524288) >> 15);\n\n\t\t*(*dst)++ = y;\n\t\t*(*dst)++ = u;\n\n\t\t*(*dst)++ = y1;\n\t\t*(*dst)++ = v;\n\t\treturn;\n\t}\n\tcase V4L2_PIX_FMT_SBGGR8:\n\t\tif (!(ypos & 1)) {\n\t\t\t*(*dst)++ = *b;\n\t\t\t*(*dst)++ = *++g;\n\t\t} else {\n\t\t\t*(*dst)++ = *g;\n\t\t\t*(*dst)++ = *++r;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_SGBRG8:\n\t\tif (!(ypos & 1)) {\n\t\t\t*(*dst)++ = *g;\n\t\t\t*(*dst)++ = *++b;\n\t\t} else {\n\t\t\t*(*dst)++ = *r;\n\t\t\t*(*dst)++ = *++g;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_SGRBG8:\n\t\tif (!(ypos & 1)) {\n\t\t\t*(*dst)++ = *g;\n\t\t\t*(*dst)++ = *++r;\n\t\t} else {\n\t\t\t*(*dst)++ = *b;\n\t\t\t*(*dst)++ = *++g;\n\t\t}\n\t\treturn;\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\tif (!(ypos & 1)) {\n\t\t\t*(*dst)++ = *r;\n\t\t\t*(*dst)++ = *++g;\n\t\t} else {\n\t\t\t*(*dst)++ = *g;\n\t\t\t*(*dst)++ = *++b;\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic int device_process(struct vim2m_ctx *ctx,\n\t\t\t  struct vb2_v4l2_buffer *in_vb,\n\t\t\t  struct vb2_v4l2_buffer *out_vb)\n{\n\tstruct vim2m_dev *dev = ctx->dev;\n\tstruct vim2m_q_data *q_data_in, *q_data_out;\n\tu8 *p_in, *p_line, *p_in_x[2], *p, *p_out;\n\tunsigned int width, height, bytesperline, bytes_per_pixel;\n\tunsigned int x, y, y_in, y_out, x_int, x_fract, x_err, x_offset;\n\tint start, end, step;\n\n\tq_data_in = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (!q_data_in)\n\t\treturn 0;\n\tbytesperline = (q_data_in->width * q_data_in->fmt->depth) >> 3;\n\tbytes_per_pixel = q_data_in->fmt->depth >> 3;\n\n\tq_data_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (!q_data_out)\n\t\treturn 0;\n\n\t \n\theight = q_data_out->height;\n\twidth = q_data_out->width;\n\n\tp_in = vb2_plane_vaddr(&in_vb->vb2_buf, 0);\n\tp_out = vb2_plane_vaddr(&out_vb->vb2_buf, 0);\n\tif (!p_in || !p_out) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Acquiring kernel pointers to buffers failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tout_vb->sequence = q_data_out->sequence++;\n\tin_vb->sequence = q_data_in->sequence++;\n\tv4l2_m2m_buf_copy_metadata(in_vb, out_vb, true);\n\n\tif (ctx->mode & MEM2MEM_VFLIP) {\n\t\tstart = height - 1;\n\t\tend = -1;\n\t\tstep = -1;\n\t} else {\n\t\tstart = 0;\n\t\tend = height;\n\t\tstep = 1;\n\t}\n\ty_out = 0;\n\n\t \n\tif (q_data_in->fmt->fourcc == q_data_out->fmt->fourcc &&\n\t    q_data_in->width == q_data_out->width &&\n\t    q_data_in->height == q_data_out->height) {\n\t\tfor (y = start; y != end; y += step, y_out++) {\n\t\t\tp = p_in + (y * bytesperline);\n\t\t\tif (ctx->mode & MEM2MEM_HFLIP)\n\t\t\t\tp += bytesperline - (q_data_in->fmt->depth >> 3);\n\n\t\t\tcopy_line(q_data_out, p, p_out,\n\t\t\t\t  ctx->mode & MEM2MEM_HFLIP);\n\n\t\t\tp_out += bytesperline;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tx_int = q_data_in->width / q_data_out->width;\n\tx_fract = q_data_in->width % q_data_out->width;\n\n\tfor (y = start; y != end; y += step, y_out++) {\n\t\ty_in = (y * q_data_in->height) / q_data_out->height;\n\t\tx_offset = 0;\n\t\tx_err = 0;\n\n\t\tp_line = p_in + (y_in * bytesperline);\n\t\tif (ctx->mode & MEM2MEM_HFLIP)\n\t\t\tp_line += bytesperline - (q_data_in->fmt->depth >> 3);\n\t\tp_in_x[0] = p_line;\n\n\t\tfor (x = 0; x < width >> 1; x++) {\n\t\t\tx_offset += x_int;\n\t\t\tx_err += x_fract;\n\t\t\tif (x_err > width) {\n\t\t\t\tx_offset++;\n\t\t\t\tx_err -= width;\n\t\t\t}\n\n\t\t\tif (ctx->mode & MEM2MEM_HFLIP)\n\t\t\t\tp_in_x[1] = p_line - x_offset * bytes_per_pixel;\n\t\t\telse\n\t\t\t\tp_in_x[1] = p_line + x_offset * bytes_per_pixel;\n\n\t\t\tcopy_two_pixels(q_data_in, q_data_out,\n\t\t\t\t\tp_in_x, &p_out, y_out,\n\t\t\t\t\tctx->mode & MEM2MEM_HFLIP);\n\n\t\t\t \n\t\t\tx_offset += x_int;\n\t\t\tx_err += x_fract;\n\t\t\tif (x_err > width) {\n\t\t\t\tx_offset++;\n\t\t\t\tx_err -= width;\n\t\t\t}\n\n\t\t\tif (ctx->mode & MEM2MEM_HFLIP)\n\t\t\t\tp_in_x[0] = p_line - x_offset * bytes_per_pixel;\n\t\t\telse\n\t\t\t\tp_in_x[0] = p_line + x_offset * bytes_per_pixel;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int job_ready(void *priv)\n{\n\tstruct vim2m_ctx *ctx = priv;\n\n\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen\n\t    || v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen) {\n\t\tdprintk(ctx->dev, 1, \"Not enough buffers available\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void job_abort(void *priv)\n{\n\tstruct vim2m_ctx *ctx = priv;\n\n\t \n\tctx->aborting = 1;\n}\n\n \nstatic void device_run(void *priv)\n{\n\tstruct vim2m_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\t \n\tv4l2_ctrl_request_setup(src_buf->vb2_buf.req_obj.req,\n\t\t\t\t&ctx->hdl);\n\n\tdevice_process(ctx, src_buf, dst_buf);\n\n\t \n\tv4l2_ctrl_request_complete(src_buf->vb2_buf.req_obj.req,\n\t\t\t\t   &ctx->hdl);\n\n\t \n\tschedule_delayed_work(&ctx->work_run, msecs_to_jiffies(ctx->transtime));\n}\n\nstatic void device_work(struct work_struct *w)\n{\n\tstruct vim2m_ctx *curr_ctx;\n\tstruct vim2m_dev *vim2m_dev;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\tcurr_ctx = container_of(w, struct vim2m_ctx, work_run.work);\n\n\tvim2m_dev = curr_ctx->dev;\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tcurr_ctx->num_processed++;\n\n\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\n\n\tif (curr_ctx->num_processed == curr_ctx->translen\n\t    || curr_ctx->aborting) {\n\t\tdprintk(curr_ctx->dev, 2, \"Finishing capture buffer fill\\n\");\n\t\tcurr_ctx->num_processed = 0;\n\t\tv4l2_m2m_job_finish(vim2m_dev->m2m_dev, curr_ctx->fh.m2m_ctx);\n\t} else {\n\t\tdevice_run(curr_ctx);\n\t}\n}\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MEM2MEM_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", MEM2MEM_NAME);\n\treturn 0;\n}\n\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num;\n\tstruct vim2m_fmt *fmt;\n\n\tnum = 0;\n\n\tfor (i = 0; i < NUM_FORMATS; ++i) {\n\t\tif (formats[i].types & type) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i < NUM_FORMATS) {\n\t\t \n\t\tfmt = &formats[i];\n\t\tf->pixelformat = fmt->fourcc;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_CAPTURE);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_OUTPUT);\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tif (!find_format(fsize->pixel_format))\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = MIN_W;\n\tfsize->stepwise.min_height = MIN_H;\n\tfsize->stepwise.max_width = MAX_W;\n\tfsize->stepwise.max_height = MAX_H;\n\n\tget_alignment(fsize->pixel_format,\n\t\t      &fsize->stepwise.step_width,\n\t\t      &fsize->stepwise.step_height);\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt(struct vim2m_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct vim2m_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tf->fmt.pix.width\t= q_data->width;\n\tf->fmt.pix.height\t= q_data->height;\n\tf->fmt.pix.field\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t= q_data->fmt->fourcc;\n\tf->fmt.pix.bytesperline\t= (q_data->width * q_data->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage\t= q_data->sizeimage;\n\tf->fmt.pix.colorspace\t= ctx->colorspace;\n\tf->fmt.pix.xfer_func\t= ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc\t= ctx->ycbcr_enc;\n\tf->fmt.pix.quantization\t= ctx->quant;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct vim2m_fmt *fmt)\n{\n\tint walign, halign;\n\t \n\tif (f->fmt.pix.height < MIN_H)\n\t\tf->fmt.pix.height = MIN_H;\n\telse if (f->fmt.pix.height > MAX_H)\n\t\tf->fmt.pix.height = MAX_H;\n\n\tif (f->fmt.pix.width < MIN_W)\n\t\tf->fmt.pix.width = MIN_W;\n\telse if (f->fmt.pix.width > MAX_W)\n\t\tf->fmt.pix.width = MAX_W;\n\n\tget_alignment(f->fmt.pix.pixelformat, &walign, &halign);\n\tf->fmt.pix.width &= ~(walign - 1);\n\tf->fmt.pix.height &= ~(halign - 1);\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vim2m_fmt *fmt;\n\tstruct vim2m_ctx *ctx = file2ctx(file);\n\n\tfmt = find_format(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tfmt = find_format(f->fmt.pix.pixelformat);\n\t}\n\tif (!(fmt->types & MEM2MEM_CAPTURE)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\n\tf->fmt.pix.quantization = ctx->quant;\n\n\treturn vidioc_try_fmt(f, fmt);\n}\n\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vim2m_fmt *fmt;\n\tstruct vim2m_ctx *ctx = file2ctx(file);\n\n\tfmt = find_format(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tfmt = find_format(f->fmt.pix.pixelformat);\n\t}\n\tif (!(fmt->types & MEM2MEM_OUTPUT)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\tif (!f->fmt.pix.colorspace)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\n\treturn vidioc_try_fmt(f, fmt);\n}\n\nstatic int vidioc_s_fmt(struct vim2m_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vim2m_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fmt\t\t= find_format(f->fmt.pix.pixelformat);\n\tq_data->width\t\t= f->fmt.pix.width;\n\tq_data->height\t\t= f->fmt.pix.height;\n\tq_data->sizeimage\t= q_data->width * q_data->height\n\t\t\t\t* q_data->fmt->depth >> 3;\n\n\tdprintk(ctx->dev, 1,\n\t\t\"Format for type %s: %dx%d (%d bpp), fmt: %c%c%c%c\\n\",\n\t\ttype_name(f->type), q_data->width, q_data->height,\n\t\tq_data->fmt->depth,\n\t\t(q_data->fmt->fourcc & 0xff),\n\t\t(q_data->fmt->fourcc >>  8) & 0xff,\n\t\t(q_data->fmt->fourcc >> 16) & 0xff,\n\t\t(q_data->fmt->fourcc >> 24) & 0xff);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vidioc_s_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vim2m_ctx *ctx = file2ctx(file);\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vidioc_s_fmt(file2ctx(file), f);\n\tif (!ret) {\n\t\tctx->colorspace = f->fmt.pix.colorspace;\n\t\tctx->xfer_func = f->fmt.pix.xfer_func;\n\t\tctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\t\tctx->quant = f->fmt.pix.quantization;\n\t}\n\treturn ret;\n}\n\nstatic int vim2m_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vim2m_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct vim2m_ctx, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->mode |= MEM2MEM_HFLIP;\n\t\telse\n\t\t\tctx->mode &= ~MEM2MEM_HFLIP;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->mode |= MEM2MEM_VFLIP;\n\t\telse\n\t\t\tctx->mode &= ~MEM2MEM_VFLIP;\n\t\tbreak;\n\n\tcase V4L2_CID_TRANS_TIME_MSEC:\n\t\tctx->transtime = ctrl->val;\n\t\tif (ctx->transtime < 1)\n\t\t\tctx->transtime = 1;\n\t\tbreak;\n\n\tcase V4L2_CID_TRANS_NUM_BUFS:\n\t\tctx->translen = ctrl->val;\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"Invalid control\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vim2m_ctrl_ops = {\n\t.s_ctrl = vim2m_s_ctrl,\n};\n\nstatic const struct v4l2_ioctl_ops vim2m_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_enum_framesizes = vidioc_enum_framesizes,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= vidioc_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n\nstatic int vim2m_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nbuffers,\n\t\t\t     unsigned int *nplanes,\n\t\t\t     unsigned int sizes[],\n\t\t\t     struct device *alloc_devs[])\n{\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vim2m_q_data *q_data;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tsize = q_data->width * q_data->height * q_data->fmt->depth >> 3;\n\n\twhile (size * count > MEM2MEM_VID_MEM_LIMIT)\n\t\t(count)--;\n\t*nbuffers = count;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tdprintk(ctx->dev, 1, \"%s: get %d buffer(s) of size %d each.\\n\",\n\t\ttype_name(vq->type), count, size);\n\n\treturn 0;\n}\n\nstatic int vim2m_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\tdprintk(ctx->dev, 1, \"%s field isn't supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vim2m_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vim2m_q_data *q_data;\n\n\tdprintk(ctx->dev, 2, \"type: %s\\n\", type_name(vb->vb2_queue->type));\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\tif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\n\t\tdprintk(ctx->dev, 1,\n\t\t\t\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t(long)q_data->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->sizeimage);\n\n\treturn 0;\n}\n\nstatic void vim2m_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int vim2m_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vim2m_q_data *q_data = get_q_data(ctx, q->type);\n\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tctx->aborting = 0;\n\n\tq_data->sequence = 0;\n\treturn 0;\n}\n\nstatic void vim2m_stop_streaming(struct vb2_queue *q)\n{\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tcancel_delayed_work_sync(&ctx->work_run);\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\treturn;\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->hdl);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic void vim2m_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);\n}\n\nstatic const struct vb2_ops vim2m_qops = {\n\t.queue_setup\t = vim2m_queue_setup,\n\t.buf_out_validate\t = vim2m_buf_out_validate,\n\t.buf_prepare\t = vim2m_buf_prepare,\n\t.buf_queue\t = vim2m_buf_queue,\n\t.start_streaming = vim2m_start_streaming,\n\t.stop_streaming  = vim2m_stop_streaming,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.buf_request_complete = vim2m_buf_request_complete,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct vim2m_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &vim2m_qops;\n\tsrc_vq->mem_ops = &vb2_vmalloc_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->vb_mutex;\n\tsrc_vq->supports_requests = true;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &vim2m_qops;\n\tdst_vq->mem_ops = &vb2_vmalloc_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->vb_mutex;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic struct v4l2_ctrl_config vim2m_ctrl_trans_time_msec = {\n\t.ops = &vim2m_ctrl_ops,\n\t.id = V4L2_CID_TRANS_TIME_MSEC,\n\t.name = \"Transaction Time (msec)\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = 10001,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vim2m_ctrl_trans_num_bufs = {\n\t.ops = &vim2m_ctrl_ops,\n\t.id = V4L2_CID_TRANS_NUM_BUFS,\n\t.name = \"Buffers Per Transaction\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 1,\n\t.min = 1,\n\t.max = MEM2MEM_DEF_NUM_BUFS,\n\t.step = 1,\n};\n\n \nstatic int vim2m_open(struct file *file)\n{\n\tstruct vim2m_dev *dev = video_drvdata(file);\n\tstruct vim2m_ctx *ctx = NULL;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint rc = 0;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto open_unlock;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\thdl = &ctx->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &vim2m_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &vim2m_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tvim2m_ctrl_trans_time_msec.def = default_transtime;\n\tv4l2_ctrl_new_custom(hdl, &vim2m_ctrl_trans_time_msec, NULL);\n\tv4l2_ctrl_new_custom(hdl, &vim2m_ctrl_trans_num_bufs, NULL);\n\tif (hdl->error) {\n\t\trc = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tctx->q_data[V4L2_M2M_SRC].fmt = &formats[0];\n\tctx->q_data[V4L2_M2M_SRC].width = 640;\n\tctx->q_data[V4L2_M2M_SRC].height = 480;\n\tctx->q_data[V4L2_M2M_SRC].sizeimage =\n\t\tctx->q_data[V4L2_M2M_SRC].width *\n\t\tctx->q_data[V4L2_M2M_SRC].height *\n\t\t(ctx->q_data[V4L2_M2M_SRC].fmt->depth >> 3);\n\tctx->q_data[V4L2_M2M_DST] = ctx->q_data[V4L2_M2M_SRC];\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\n\n\tmutex_init(&ctx->vb_mutex);\n\tINIT_DELAYED_WORK(&ctx->work_run, device_work);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\trc = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_fh_exit(&ctx->fh);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\tatomic_inc(&dev->num_inst);\n\n\tdprintk(dev, 1, \"Created instance: %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\nopen_unlock:\n\tmutex_unlock(&dev->dev_mutex);\n\treturn rc;\n}\n\nstatic int vim2m_release(struct file *file)\n{\n\tstruct vim2m_dev *dev = video_drvdata(file);\n\tstruct vim2m_ctx *ctx = file2ctx(file);\n\n\tdprintk(dev, 1, \"Releasing instance %p\\n\", ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tmutex_lock(&dev->dev_mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\tkfree(ctx);\n\n\tatomic_dec(&dev->num_inst);\n\n\treturn 0;\n}\n\nstatic void vim2m_device_release(struct video_device *vdev)\n{\n\tstruct vim2m_dev *dev = container_of(vdev, struct vim2m_dev, vfd);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_m2m_release(dev->m2m_dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_cleanup(&dev->mdev);\n#endif\n\tkfree(dev);\n}\n\nstatic const struct v4l2_file_operations vim2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vim2m_open,\n\t.release\t= vim2m_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device vim2m_videodev = {\n\t.name\t\t= MEM2MEM_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &vim2m_fops,\n\t.ioctl_ops\t= &vim2m_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= vim2m_device_release,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= device_run,\n\t.job_ready\t= job_ready,\n\t.job_abort\t= job_abort,\n};\n\nstatic const struct media_device_ops m2m_media_ops = {\n\t.req_validate = vb2_request_validate,\n\t.req_queue = v4l2_m2m_request_queue,\n};\n\nstatic int vim2m_probe(struct platform_device *pdev)\n{\n\tstruct vim2m_dev *dev;\n\tstruct video_device *vfd;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto error_free;\n\n\tatomic_set(&dev->num_inst, 0);\n\tmutex_init(&dev->dev_mutex);\n\n\tdev->vfd = vim2m_videodev;\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, dev);\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tdev->m2m_dev = NULL;\n\t\tgoto error_dev;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->mdev.dev = &pdev->dev;\n\tstrscpy(dev->mdev.model, \"vim2m\", sizeof(dev->mdev.model));\n\tstrscpy(dev->mdev.bus_info, \"platform:vim2m\",\n\t\tsizeof(dev->mdev.bus_info));\n\tmedia_device_init(&dev->mdev);\n\tdev->mdev.ops = &m2m_media_ops;\n\tdev->v4l2_dev.mdev = &dev->mdev;\n#endif\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto error_m2m;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tret = v4l2_m2m_register_media_controller(dev->m2m_dev, vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem media controller\\n\");\n\t\tgoto error_v4l2;\n\t}\n\n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register mem2mem media device\\n\");\n\t\tgoto error_m2m_mc;\n\t}\n#endif\n\treturn 0;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nerror_m2m_mc:\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\n#endif\nerror_v4l2:\n\tvideo_unregister_device(&dev->vfd);\n\t \n\treturn ret;\nerror_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nerror_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerror_free:\n\tkfree(dev);\n\n\treturn ret;\n}\n\nstatic void vim2m_remove(struct platform_device *pdev)\n{\n\tstruct vim2m_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" MEM2MEM_NAME);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_unregister(&dev->mdev);\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\n#endif\n\tvideo_unregister_device(&dev->vfd);\n}\n\nstatic struct platform_driver vim2m_pdrv = {\n\t.probe\t\t= vim2m_probe,\n\t.remove_new\t= vim2m_remove,\n\t.driver\t\t= {\n\t\t.name\t= MEM2MEM_NAME,\n\t},\n};\n\nstatic void __exit vim2m_exit(void)\n{\n\tplatform_driver_unregister(&vim2m_pdrv);\n\tplatform_device_unregister(&vim2m_pdev);\n}\n\nstatic int __init vim2m_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&vim2m_pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&vim2m_pdrv);\n\tif (ret)\n\t\tplatform_device_unregister(&vim2m_pdev);\n\n\treturn ret;\n}\n\nmodule_init(vim2m_init);\nmodule_exit(vim2m_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}