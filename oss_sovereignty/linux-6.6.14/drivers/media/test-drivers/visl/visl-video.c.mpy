{
  "module_name": "visl-video.c",
  "hash_id": "54f87faf91a68b88f3458cba1ec2efe45776c386e079e51cc27766cd02dde222",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/visl/visl-video.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/font.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"visl-video.h\"\n\n#include \"visl.h\"\n#include \"visl-debugfs.h\"\n\n#define MIN_CODED_SZ (1024U * 256U)\n\nstatic void visl_set_current_codec(struct visl_ctx *ctx)\n{\n\tu32 fourcc = ctx->coded_fmt.fmt.pix_mp.pixelformat;\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_FWHT_STATELESS:\n\t\tctx->current_codec = VISL_CODEC_FWHT;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\t\tctx->current_codec = VISL_CODEC_MPEG2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\t\tctx->current_codec = VISL_CODEC_VP8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP9_FRAME:\n\t\tctx->current_codec = VISL_CODEC_VP9;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\t\tctx->current_codec = VISL_CODEC_H264;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\t\tctx->current_codec = VISL_CODEC_HEVC;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(ctx->dev, \"Warning: unsupported fourcc: %d\\n\", fourcc);\n\t\tctx->current_codec = VISL_CODEC_NONE;\n\t\tbreak;\n\t}\n}\n\nstatic void visl_print_fmt(struct visl_ctx *ctx, const struct v4l2_format *f)\n{\n\tconst struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tu32 i;\n\n\tdprintk(ctx->dev, \"width: %d\\n\", pix_mp->width);\n\tdprintk(ctx->dev, \"height: %d\\n\", pix_mp->height);\n\tdprintk(ctx->dev, \"pixelformat: %c%c%c%c\\n\",\n\t\tpix_mp->pixelformat,\n\t\t(pix_mp->pixelformat >> 8) & 0xff,\n\t\t(pix_mp->pixelformat >> 16) & 0xff,\n\t\t(pix_mp->pixelformat >> 24) & 0xff);\n\n\tdprintk(ctx->dev, \"field: %d\\n\", pix_mp->field);\n\tdprintk(ctx->dev, \"colorspace: %d\\n\", pix_mp->colorspace);\n\tdprintk(ctx->dev, \"num_planes: %d\\n\", pix_mp->num_planes);\n\tdprintk(ctx->dev, \"flags: %d\\n\", pix_mp->flags);\n\tdprintk(ctx->dev, \"quantization: %d\\n\", pix_mp->quantization);\n\tdprintk(ctx->dev, \"xfer_func: %d\\n\", pix_mp->xfer_func);\n\n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tdprintk(ctx->dev,\n\t\t\t\"plane[%d]: sizeimage: %d\\n\", i, pix_mp->plane_fmt[i].sizeimage);\n\t\tdprintk(ctx->dev,\n\t\t\t\"plane[%d]: bytesperline: %d\\n\", i, pix_mp->plane_fmt[i].bytesperline);\n\t}\n}\n\nstatic int visl_tpg_init(struct visl_ctx *ctx)\n{\n\tconst struct font_desc *font;\n\tconst char *font_name = \"VGA8x16\";\n\tint ret;\n\tu32 width = ctx->decoded_fmt.fmt.pix_mp.width;\n\tu32 height = ctx->decoded_fmt.fmt.pix_mp.height;\n\tstruct v4l2_pix_format_mplane *f = &ctx->decoded_fmt.fmt.pix_mp;\n\n\ttpg_free(&ctx->tpg);\n\n\tfont = find_font(font_name);\n\tif (font) {\n\t\ttpg_init(&ctx->tpg, width, height);\n\n\t\tret = tpg_alloc(&ctx->tpg, width);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\n\t\ttpg_set_font(font->data);\n\t\tret = tpg_s_fourcc(&ctx->tpg,\n\t\t\t\t   f->pixelformat);\n\n\t\tif (!ret)\n\t\t\tgoto err_fourcc;\n\n\t\ttpg_reset_source(&ctx->tpg, width, height, f->field);\n\n\t\ttpg_s_pattern(&ctx->tpg, TPG_PAT_75_COLORBAR);\n\n\t\ttpg_s_field(&ctx->tpg, f->field, false);\n\t\ttpg_s_colorspace(&ctx->tpg, f->colorspace);\n\t\ttpg_s_ycbcr_enc(&ctx->tpg, f->ycbcr_enc);\n\t\ttpg_s_quantization(&ctx->tpg, f->quantization);\n\t\ttpg_s_xfer_func(&ctx->tpg, f->xfer_func);\n\t} else {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Font %s not found\\n\", font_name);\n\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(ctx->dev, \"Initialized the V4L2 test pattern generator, w=%d, h=%d, max_w=%d\\n\",\n\t\twidth, height, width);\n\n\treturn 0;\nerr_alloc:\n\treturn ret;\nerr_fourcc:\n\ttpg_free(&ctx->tpg);\n\treturn ret;\n}\n\nstatic const u32 visl_decoded_fmts[] = {\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_YUV420,\n};\n\nconst struct visl_coded_format_desc visl_coded_fmts[] = {\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_FWHT_STATELESS,\n\t\t.frmsize = {\n\t\t\t.min_width = 640,\n\t\t\t.max_width = 4096,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 360,\n\t\t\t.max_height = 2160,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_fwht_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_MPEG2_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 16,\n\t\t\t.max_width = 1920,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 16,\n\t\t\t.max_height = 1152,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_mpeg2_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_VP8_FRAME,\n\t\t.frmsize = {\n\t\t\t.min_width = 64,\n\t\t\t.max_width = 16383,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 64,\n\t\t\t.max_height = 16383,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_vp8_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_VP9_FRAME,\n\t\t.frmsize = {\n\t\t\t.min_width = 64,\n\t\t\t.max_width = 8192,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 64,\n\t\t\t.max_height = 4352,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_vp9_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_H264_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 64,\n\t\t\t.max_width = 4096,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 64,\n\t\t\t.max_height = 2304,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_h264_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_HEVC_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 64,\n\t\t\t.max_width = 4096,\n\t\t\t.step_width = 1,\n\t\t\t.min_height = 64,\n\t\t\t.max_height = 2304,\n\t\t\t.step_height = 1,\n\t\t},\n\t\t.ctrls = &visl_hevc_ctrls,\n\t\t.num_decoded_fmts = ARRAY_SIZE(visl_decoded_fmts),\n\t\t.decoded_fmts = visl_decoded_fmts,\n\t},\n};\n\nconst size_t num_coded_fmts = ARRAY_SIZE(visl_coded_fmts);\n\nstatic const struct visl_coded_format_desc*\nvisl_find_coded_fmt_desc(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(visl_coded_fmts); i++) {\n\t\tif (visl_coded_fmts[i].pixelformat == fourcc)\n\t\t\treturn &visl_coded_fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void visl_init_fmt(struct v4l2_format *f, u32 fourcc)\n{\tmemset(f, 0, sizeof(*f));\n\tf->fmt.pix_mp.pixelformat = fourcc;\n\tf->fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709;\n\tf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic void visl_reset_coded_fmt(struct visl_ctx *ctx)\n{\n\tstruct v4l2_format *f = &ctx->coded_fmt;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\n\tctx->coded_format_desc = &visl_coded_fmts[0];\n\tvisl_init_fmt(f, ctx->coded_format_desc->pixelformat);\n\n\tf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tf->fmt.pix_mp.width = ctx->coded_format_desc->frmsize.min_width;\n\tf->fmt.pix_mp.height = ctx->coded_format_desc->frmsize.min_height;\n\n\tpix_mp->num_planes = 1;\n\tpix_mp->plane_fmt[0].sizeimage = pix_mp->width * pix_mp->height * 8;\n\n\tdprintk(ctx->dev, \"OUTPUT format was set to:\\n\");\n\tvisl_print_fmt(ctx, &ctx->coded_fmt);\n\n\tvisl_set_current_codec(ctx);\n}\n\nstatic int visl_reset_decoded_fmt(struct visl_ctx *ctx)\n{\n\tstruct v4l2_format *f = &ctx->decoded_fmt;\n\tu32 decoded_fmt = ctx->coded_format_desc[0].decoded_fmts[0];\n\n\tvisl_init_fmt(f, decoded_fmt);\n\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\n\tv4l2_fill_pixfmt_mp(&f->fmt.pix_mp,\n\t\t\t    ctx->coded_format_desc->decoded_fmts[0],\n\t\t\t    ctx->coded_fmt.fmt.pix_mp.width,\n\t\t\t    ctx->coded_fmt.fmt.pix_mp.height);\n\n\tdprintk(ctx->dev, \"CAPTURE format was set to:\\n\");\n\tvisl_print_fmt(ctx, &ctx->decoded_fmt);\n\n\treturn visl_tpg_init(ctx);\n}\n\nint visl_set_default_format(struct visl_ctx *ctx)\n{\n\tvisl_reset_coded_fmt(ctx);\n\treturn visl_reset_decoded_fmt(ctx);\n}\n\nstatic struct visl_q_data *get_q_data(struct visl_ctx *ctx,\n\t\t\t\t      enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn &ctx->q_data[V4L2_M2M_SRC];\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\treturn &ctx->q_data[V4L2_M2M_DST];\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int visl_querycap(struct file *file, void *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, VISL_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, VISL_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", VISL_NAME);\n\n\treturn 0;\n}\n\nstatic int visl_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\n\tif (f->index >= ctx->coded_format_desc->num_decoded_fmts)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = ctx->coded_format_desc->decoded_fmts[f->index];\n\treturn 0;\n}\n\nstatic int visl_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(visl_coded_fmts))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = visl_coded_fmts[f->index].pixelformat;\n\treturn 0;\n}\n\nstatic int visl_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\t*f = ctx->decoded_fmt;\n\n\treturn 0;\n}\n\nstatic int visl_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\n\t*f = ctx->coded_fmt;\n\treturn 0;\n}\n\nstatic int visl_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\tconst struct visl_coded_format_desc *coded_desc;\n\tunsigned int i;\n\n\tcoded_desc = ctx->coded_format_desc;\n\n\tfor (i = 0; i < coded_desc->num_decoded_fmts; i++) {\n\t\tif (coded_desc->decoded_fmts[i] == pix_mp->pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (i == coded_desc->num_decoded_fmts)\n\t\tpix_mp->pixelformat = coded_desc->decoded_fmts[0];\n\n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &coded_desc->frmsize);\n\n\tv4l2_fill_pixfmt_mp(pix_mp, pix_mp->pixelformat,\n\t\t\t    pix_mp->width, pix_mp->height);\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int visl_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tconst struct visl_coded_format_desc *coded_desc;\n\n\tcoded_desc = visl_find_coded_fmt_desc(pix_mp->pixelformat);\n\tif (!coded_desc) {\n\t\tpix_mp->pixelformat = visl_coded_fmts[0].pixelformat;\n\t\tcoded_desc = &visl_coded_fmts[0];\n\t}\n\n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &coded_desc->frmsize);\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->num_planes = 1;\n\n\tif (pix_mp->plane_fmt[0].sizeimage == 0)\n\t\tpix_mp->plane_fmt[0].sizeimage = max(MIN_CODED_SZ,\n\t\t\t\t\t\t     pix_mp->width * pix_mp->height * 3);\n\n\treturn 0;\n}\n\nstatic int visl_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tconst struct visl_coded_format_desc *desc;\n\tstruct vb2_queue *peer_vq;\n\tint ret;\n\n\tpeer_vq = v4l2_m2m_get_vq(m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(peer_vq))\n\t\treturn -EBUSY;\n\n\tdprintk(ctx->dev, \"Trying to set the OUTPUT format to:\\n\");\n\tvisl_print_fmt(ctx, f);\n\n\tret = visl_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc = visl_find_coded_fmt_desc(f->fmt.pix_mp.pixelformat);\n\tctx->coded_format_desc = desc;\n\tctx->coded_fmt = *f;\n\n\tret = visl_reset_decoded_fmt(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->decoded_fmt.fmt.pix_mp.colorspace = f->fmt.pix_mp.colorspace;\n\tctx->decoded_fmt.fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;\n\tctx->decoded_fmt.fmt.pix_mp.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\n\tctx->decoded_fmt.fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;\n\n\tdprintk(ctx->dev, \"OUTPUT format was set to:\\n\");\n\tvisl_print_fmt(ctx, &ctx->coded_fmt);\n\n\tvisl_set_current_codec(ctx);\n\treturn 0;\n}\n\nstatic int visl_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\tint ret;\n\n\tdprintk(ctx->dev, \"Trying to set the CAPTURE format to:\\n\");\n\tvisl_print_fmt(ctx, f);\n\n\tret = visl_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->decoded_fmt = *f;\n\n\tdprintk(ctx->dev, \"CAPTURE format was set to:\\n\");\n\tvisl_print_fmt(ctx, &ctx->decoded_fmt);\n\n\tvisl_tpg_init(ctx);\n\treturn 0;\n}\n\nstatic int visl_enum_framesizes(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tconst struct visl_coded_format_desc *fmt;\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfmt = visl_find_coded_fmt_desc(fsize->pixel_format);\n\tif (!fmt) {\n\t\tdprintk(ctx->dev,\n\t\t\t\"Unsupported format for the OUTPUT queue: %d\\n\",\n\t\t\tfsize->pixel_format);\n\n\t\treturn -EINVAL;\n\t}\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = fmt->frmsize;\n\treturn 0;\n}\n\nconst struct v4l2_ioctl_ops visl_ioctl_ops = {\n\t.vidioc_querycap\t\t= visl_querycap,\n\t.vidioc_enum_framesizes\t\t= visl_enum_framesizes,\n\n\t.vidioc_enum_fmt_vid_cap\t= visl_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap_mplane\t= visl_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap_mplane\t= visl_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap_mplane\t= visl_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= visl_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out_mplane\t= visl_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out_mplane\t= visl_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out_mplane\t= visl_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_decoder_cmd\t\t= v4l2_m2m_ioctl_stateless_decoder_cmd,\n\t.vidioc_try_decoder_cmd\t\t= v4l2_m2m_ioctl_stateless_try_decoder_cmd,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic int visl_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers,\n\t\t\t    unsigned int *num_planes,\n\t\t\t    unsigned int sizes[],\n\t\t\t    struct device *alloc_devs[])\n{\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_format *f;\n\tu32 i;\n\tchar *qname;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tf = &ctx->coded_fmt;\n\t\tqname = \"Output\";\n\t} else {\n\t\tf = &ctx->decoded_fmt;\n\t\tqname = \"Capture\";\n\t}\n\n\tif (*num_planes) {\n\t\tif (*num_planes != f->fmt.pix_mp.num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\n\t\t\tif (sizes[i] < f->fmt.pix_mp.plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*num_planes = f->fmt.pix_mp.num_planes;\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++)\n\t\t\tsizes[i] = f->fmt.pix_mp.plane_fmt[i].sizeimage;\n\t}\n\n\tdprintk(ctx->dev, \"%s: %d buffer(s) requested, num_planes=%d.\\n\",\n\t\tqname, *nbuffers, *num_planes);\n\n\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++)\n\t\tdprintk(ctx->dev, \"plane[%d].sizeimage=%d\\n\",\n\t\t\ti, f->fmt.pix_mp.plane_fmt[i].sizeimage);\n\n\treturn 0;\n}\n\nstatic void visl_queue_cleanup(struct vb2_queue *vq, u32 state)\n{\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdprintk(ctx->dev, \"Cleaning up queues\\n\");\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (!vbuf)\n\t\t\tbreak;\n\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->hdl);\n\t\tdprintk(ctx->dev, \"Marked request %p as complete\\n\",\n\t\t\tvbuf->vb2_buf.req_obj.req);\n\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t\tdprintk(ctx->dev,\n\t\t\t\"Marked buffer %llu as done, state is %d\\n\",\n\t\t\tvbuf->vb2_buf.timestamp,\n\t\t\tstate);\n\t}\n}\n\nstatic int visl_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic int visl_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vq);\n\tu32 plane_sz = vb2_plane_size(vb, 0);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tpix_fmt = &ctx->coded_fmt.fmt.pix;\n\t} else {\n\t\tpix_fmt = &ctx->decoded_fmt.fmt.pix;\n\t\tvb2_set_plane_payload(vb, 0, pix_fmt->sizeimage);\n\t}\n\n\tif (plane_sz < pix_fmt->sizeimage) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"plane[0] size is %d, sizeimage is %d\\n\",\n\t\t\t plane_sz, pix_fmt->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int visl_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct visl_q_data *q_data = get_q_data(ctx, vq->type);\n\tint rc = 0;\n\n\tif (!q_data) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tq_data->sequence = 0;\n\n\tif (V4L2_TYPE_IS_CAPTURE(vq->type)) {\n\t\tctx->capture_streamon_jiffies = get_jiffies_64();\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON(!ctx->coded_format_desc)) {\n\t\trc =  -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tvisl_queue_cleanup(vq, VB2_BUF_STATE_QUEUED);\n\treturn rc;\n}\n\nstatic void visl_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tdprintk(ctx->dev, \"Stop streaming\\n\");\n\tvisl_queue_cleanup(vq, VB2_BUF_STATE_ERROR);\n\n\tif (!keep_bitstream_buffers)\n\t\tvisl_debugfs_clear_bitstream(ctx->dev);\n}\n\nstatic void visl_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void visl_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct visl_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);\n}\n\nstatic const struct vb2_ops visl_qops = {\n\t.queue_setup          = visl_queue_setup,\n\t.buf_out_validate     = visl_buf_out_validate,\n\t.buf_prepare          = visl_buf_prepare,\n\t.buf_queue            = visl_buf_queue,\n\t.start_streaming      = visl_start_streaming,\n\t.stop_streaming       = visl_stop_streaming,\n\t.wait_prepare         = vb2_ops_wait_prepare,\n\t.wait_finish          = vb2_ops_wait_finish,\n\t.buf_request_complete = visl_buf_request_complete,\n};\n\nint visl_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t    struct vb2_queue *dst_vq)\n{\n\tstruct visl_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &visl_qops;\n\tsrc_vq->mem_ops = &vb2_vmalloc_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->vb_mutex;\n\tsrc_vq->supports_requests = true;\n\tsrc_vq->subsystem_flags |= VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &visl_qops;\n\tdst_vq->mem_ops = &vb2_vmalloc_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->vb_mutex;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nint visl_request_validate(struct media_request *req)\n{\n\tstruct media_request_object *obj;\n\tstruct visl_ctx *ctx = NULL;\n\tunsigned int count;\n\n\tlist_for_each_entry(obj, &req->objects, list) {\n\t\tstruct vb2_buffer *vb;\n\n\t\tif (vb2_request_object_is_buffer(obj)) {\n\t\t\tvb = container_of(obj, struct vb2_buffer, req_obj);\n\t\t\tctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx)\n\t\treturn -ENOENT;\n\n\tcount = vb2_request_buffer_cnt(req);\n\tif (!count) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"No buffer was provided with the request\\n\");\n\t\treturn -ENOENT;\n\t} else if (count > 1) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"More than one buffer was provided with the request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vb2_request_validate(req);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}