{
  "module_name": "visl-core.c",
  "hash_id": "7d667dcf6cd382a3bb7134eb6230f79541f2f8a130557700a71273217a711492",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/visl/visl-core.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"visl.h\"\n#include \"visl-dec.h\"\n#include \"visl-debugfs.h\"\n#include \"visl-video.h\"\n\nunsigned int visl_debug;\nmodule_param(visl_debug, uint, 0644);\nMODULE_PARM_DESC(visl_debug, \" activates debug info\");\n\nunsigned int visl_transtime_ms;\nmodule_param(visl_transtime_ms, uint, 0644);\nMODULE_PARM_DESC(visl_transtime_ms, \" simulated process time in milliseconds.\");\n\n \nint visl_dprintk_frame_start = -1;\nmodule_param(visl_dprintk_frame_start, int, 0);\nMODULE_PARM_DESC(visl_dprintk_frame_start,\n\t\t \" a frame number to start tracing with dprintk\");\n\nunsigned int visl_dprintk_nframes;\nmodule_param(visl_dprintk_nframes, uint, 0);\nMODULE_PARM_DESC(visl_dprintk_nframes,\n\t\t \" the number of frames to trace with dprintk\");\n\nbool keep_bitstream_buffers;\nmodule_param(keep_bitstream_buffers, bool, false);\nMODULE_PARM_DESC(keep_bitstream_buffers,\n\t\t \" keep bitstream buffers in debugfs after streaming is stopped\");\n\nint bitstream_trace_frame_start = -1;\nmodule_param(bitstream_trace_frame_start, int, 0);\nMODULE_PARM_DESC(bitstream_trace_frame_start,\n\t\t \" a frame number to start dumping the bitstream through debugfs\");\n\nunsigned int bitstream_trace_nframes;\nmodule_param(bitstream_trace_nframes, uint, 0);\nMODULE_PARM_DESC(bitstream_trace_nframes,\n\t\t \" the number of frames to dump the bitstream through debugfs\");\n\nstatic const struct visl_ctrl_desc visl_fwht_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_FWHT_PARAMS,\n\t},\n};\n\nconst struct visl_ctrls visl_fwht_ctrls = {\n\t.ctrls = visl_fwht_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_fwht_ctrl_descs)\n};\n\nstatic const struct visl_ctrl_desc visl_mpeg2_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_MPEG2_SEQUENCE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_MPEG2_PICTURE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_MPEG2_QUANTISATION,\n\t},\n};\n\nconst struct visl_ctrls visl_mpeg2_ctrls = {\n\t.ctrls = visl_mpeg2_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_mpeg2_ctrl_descs),\n};\n\nstatic const struct visl_ctrl_desc visl_vp8_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_VP8_FRAME,\n\t},\n};\n\nconst struct visl_ctrls visl_vp8_ctrls = {\n\t.ctrls = visl_vp8_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_vp8_ctrl_descs),\n};\n\nstatic const struct visl_ctrl_desc visl_vp9_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_VP9_FRAME,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,\n\t},\n};\n\nconst struct visl_ctrls visl_vp9_ctrls = {\n\t.ctrls = visl_vp9_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_vp9_ctrl_descs),\n};\n\nstatic const struct visl_ctrl_desc visl_h264_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_SPS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_PPS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_SCALING_MATRIX,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_START_CODE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_SLICE_PARAMS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_PRED_WEIGHTS,\n\t},\n};\n\nconst struct visl_ctrls visl_h264_ctrls = {\n\t.ctrls = visl_h264_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_h264_ctrl_descs),\n};\n\nstatic const struct visl_ctrl_desc visl_hevc_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_SPS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_PPS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_SLICE_PARAMS,\n\t\t \n\t\t.cfg.dims = { 600 },\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_SCALING_MATRIX,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_DECODE_PARAMS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_DECODE_MODE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_START_CODE,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_HEVC_ENTRY_POINT_OFFSETS,\n\t\t.cfg.dims = { 256 },\n\t\t.cfg.max = 0xffffffff,\n\t\t.cfg.step = 1,\n\t},\n\n};\n\nconst struct visl_ctrls visl_hevc_ctrls = {\n\t.ctrls = visl_hevc_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(visl_hevc_ctrl_descs),\n};\n\nstruct v4l2_ctrl *visl_find_control(struct visl_ctx *ctx, u32 id)\n{\n\tstruct v4l2_ctrl_handler *hdl = &ctx->hdl;\n\n\treturn v4l2_ctrl_find(hdl, id);\n}\n\nvoid *visl_find_control_data(struct visl_ctx *ctx, u32 id)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tctrl = visl_find_control(ctx, id);\n\tif (ctrl)\n\t\treturn ctrl->p_cur.p;\n\n\treturn NULL;\n}\n\nu32 visl_control_num_elems(struct visl_ctx *ctx, u32 id)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tctrl = visl_find_control(ctx, id);\n\tif (ctrl)\n\t\treturn ctrl->elems;\n\n\treturn 0;\n}\n\nstatic void visl_device_release(struct video_device *vdev)\n{\n\tstruct visl_dev *dev = container_of(vdev, struct visl_dev, vfd);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_m2m_release(dev->m2m_dev);\n\tmedia_device_cleanup(&dev->mdev);\n\tvisl_debugfs_deinit(dev);\n\tkfree(dev);\n}\n\n#define VISL_CONTROLS_COUNT\tARRAY_SIZE(visl_controls)\n\nstatic int visl_init_ctrls(struct visl_ctx *ctx)\n{\n\tstruct visl_dev *dev = ctx->dev;\n\tstruct v4l2_ctrl_handler *hdl = &ctx->hdl;\n\tunsigned int ctrl_cnt = 0;\n\tunsigned int i;\n\tunsigned int j;\n\tconst struct visl_ctrls *ctrls;\n\n\tfor (i = 0; i < num_coded_fmts; i++)\n\t\tctrl_cnt += visl_coded_fmts[i].ctrls->num_ctrls;\n\n\tv4l2_ctrl_handler_init(hdl, ctrl_cnt);\n\n\tfor (i = 0; i < num_coded_fmts; i++) {\n\t\tctrls = visl_coded_fmts[i].ctrls;\n\t\tfor (j = 0; j < ctrls->num_ctrls; j++)\n\t\t\tv4l2_ctrl_new_custom(hdl, &ctrls->ctrls[j].cfg, NULL);\n\t}\n\n\tif (hdl->error) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize control handler\\n\");\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn hdl->error;\n\t}\n\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\treturn 0;\n}\n\nstatic int visl_open(struct file *file)\n{\n\tstruct visl_dev *dev = video_drvdata(file);\n\tstruct visl_ctx *ctx = NULL;\n\tint rc = 0;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tctx->tpg_str_buf = kzalloc(TPG_STR_BUF_SZ, GFP_KERNEL);\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\n\trc = visl_init_ctrls(ctx);\n\tif (rc)\n\t\tgoto free_ctx;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &visl_queue_init);\n\n\tmutex_init(&ctx->vb_mutex);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\trc = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto free_hdl;\n\t}\n\n\trc = visl_set_default_format(ctx);\n\tif (rc)\n\t\tgoto free_m2m_ctx;\n\n\tv4l2_fh_add(&ctx->fh);\n\n\tdprintk(dev, \"Created instance: %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\treturn rc;\n\nfree_m2m_ctx:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nfree_hdl:\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tv4l2_fh_exit(&ctx->fh);\nfree_ctx:\n\tkfree(ctx->tpg_str_buf);\n\tkfree(ctx);\nunlock:\n\tmutex_unlock(&dev->dev_mutex);\n\treturn rc;\n}\n\nstatic int visl_release(struct file *file)\n{\n\tstruct visl_dev *dev = video_drvdata(file);\n\tstruct visl_ctx *ctx = visl_file_to_ctx(file);\n\n\tdprintk(dev, \"Releasing instance %p\\n\", ctx);\n\n\ttpg_free(&ctx->tpg);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tmutex_lock(&dev->dev_mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\tkfree(ctx->tpg_str_buf);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations visl_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= visl_open,\n\t.release\t= visl_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device visl_videodev = {\n\t.name\t\t= VISL_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &visl_fops,\n\t.ioctl_ops\t= &visl_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= visl_device_release,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops visl_m2m_ops = {\n\t.device_run\t= visl_device_run,\n};\n\nstatic const struct media_device_ops visl_m2m_media_ops = {\n\t.req_validate\t= visl_request_validate,\n\t.req_queue\t= v4l2_m2m_request_queue,\n};\n\nstatic int visl_probe(struct platform_device *pdev)\n{\n\tstruct visl_dev *dev;\n\tstruct video_device *vfd;\n\tint ret;\n\tint rc;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto error_visl_dev;\n\n\tmutex_init(&dev->dev_mutex);\n\n\tdev->vfd = visl_videodev;\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, dev);\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev = v4l2_m2m_init(&visl_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tdev->m2m_dev = NULL;\n\t\tgoto error_dev;\n\t}\n\n\tdev->mdev.dev = &pdev->dev;\n\tstrscpy(dev->mdev.model, \"visl\", sizeof(dev->mdev.model));\n\tstrscpy(dev->mdev.bus_info, \"platform:visl\",\n\t\tsizeof(dev->mdev.bus_info));\n\tmedia_device_init(&dev->mdev);\n\tdev->mdev.ops = &visl_m2m_media_ops;\n\tdev->v4l2_dev.mdev = &dev->mdev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto error_m2m;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tret = v4l2_m2m_register_media_controller(dev->m2m_dev, vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem media controller\\n\");\n\t\tgoto error_v4l2;\n\t}\n\n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register mem2mem media device\\n\");\n\t\tgoto error_m2m_mc;\n\t}\n\n\trc = visl_debugfs_init(dev);\n\tif (rc)\n\t\tdprintk(dev, \"visl_debugfs_init failed: %d\\n\"\n\t\t\t\"Continuing without debugfs support\\n\", rc);\n\n\treturn 0;\n\nerror_m2m_mc:\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\nerror_v4l2:\n\tvideo_unregister_device(&dev->vfd);\n\t \n\treturn ret;\nerror_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nerror_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerror_visl_dev:\n\tkfree(dev);\n\n\treturn ret;\n}\n\nstatic void visl_remove(struct platform_device *pdev)\n{\n\tstruct visl_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" VISL_NAME);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tif (media_devnode_is_registered(dev->mdev.devnode)) {\n\t\tmedia_device_unregister(&dev->mdev);\n\t\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\n\t}\n#endif\n\tvideo_unregister_device(&dev->vfd);\n}\n\nstatic struct platform_driver visl_pdrv = {\n\t.probe\t\t= visl_probe,\n\t.remove_new\t= visl_remove,\n\t.driver\t\t= {\n\t\t.name\t= VISL_NAME,\n\t},\n};\n\nstatic void visl_dev_release(struct device *dev) {}\n\nstatic struct platform_device visl_pdev = {\n\t.name\t\t= VISL_NAME,\n\t.dev.release\t= visl_dev_release,\n};\n\nstatic void __exit visl_exit(void)\n{\n\tplatform_driver_unregister(&visl_pdrv);\n\tplatform_device_unregister(&visl_pdev);\n}\n\nstatic int __init visl_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&visl_pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&visl_pdrv);\n\tif (ret)\n\t\tplatform_device_unregister(&visl_pdev);\n\n\treturn ret;\n}\n\nMODULE_DESCRIPTION(\"Virtual stateless decoder device\");\nMODULE_AUTHOR(\"Daniel Almeida <daniel.almeida@collabora.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(visl_init);\nmodule_exit(visl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}