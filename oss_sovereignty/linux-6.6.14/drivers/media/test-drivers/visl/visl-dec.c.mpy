{
  "module_name": "visl-dec.c",
  "hash_id": "7a3bb82c86047acac043eac96c124105aa8f85dbbcdaf45061a5c64b1537b82d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/visl/visl-dec.c",
  "human_readable_source": "\n \n\n#include \"visl.h\"\n#include \"visl-debugfs.h\"\n#include \"visl-dec.h\"\n#include \"visl-trace-fwht.h\"\n#include \"visl-trace-mpeg2.h\"\n#include \"visl-trace-vp8.h\"\n#include \"visl-trace-vp9.h\"\n#include \"visl-trace-h264.h\"\n#include \"visl-trace-hevc.h\"\n\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/tpg/v4l2-tpg.h>\n\nstatic void *plane_vaddr(struct tpg_data *tpg, struct vb2_buffer *buf,\n\t\t\t u32 p, u32 bpl[TPG_MAX_PLANES], u32 h)\n{\n\tu32 i;\n\tvoid *vbuf;\n\n\tif (p == 0 || tpg_g_buffers(tpg) > 1)\n\t\treturn vb2_plane_vaddr(buf, p);\n\tvbuf = vb2_plane_vaddr(buf, 0);\n\tfor (i = 0; i < p; i++)\n\t\tvbuf += bpl[i] * h / tpg->vdownsampling[i];\n\treturn vbuf;\n}\n\nstatic void visl_get_ref_frames(struct visl_ctx *ctx, u8 *buf,\n\t\t\t\t__kernel_size_t buflen, struct visl_run *run)\n{\n\tstruct vb2_queue *cap_q = &ctx->fh.m2m_ctx->cap_q_ctx.q;\n\tchar header[] = \"Reference frames:\\n\";\n\tu32 i;\n\tu32 len;\n\n\tlen = scnprintf(buf, buflen, header);\n\tbuf += len;\n\tbuflen -= len;\n\n\tswitch (ctx->current_codec) {\n\tcase VISL_CODEC_NONE:\n\t\tbreak;\n\n\tcase VISL_CODEC_FWHT: {\n\t\tstruct vb2_buffer *vb2_buf;\n\n\t\tvb2_buf = vb2_find_buffer(cap_q, run->fwht.params->backward_ref_ts);\n\n\t\tscnprintf(buf, buflen, \"backwards_ref_ts: %lld, vb2_idx: %d\",\n\t\t\t  run->fwht.params->backward_ref_ts,\n\t\t\t  vb2_buf ? vb2_buf->index : -1);\n\t\tbreak;\n\t}\n\n\tcase VISL_CODEC_MPEG2: {\n\t\tstruct vb2_buffer *b_ref;\n\t\tstruct vb2_buffer *f_ref;\n\n\t\tb_ref = vb2_find_buffer(cap_q, run->mpeg2.pic->backward_ref_ts);\n\t\tf_ref = vb2_find_buffer(cap_q, run->mpeg2.pic->forward_ref_ts);\n\n\t\tscnprintf(buf, buflen,\n\t\t\t  \"backward_ref_ts: %llu, vb2_idx: %d\\n\"\n\t\t\t  \"forward_ref_ts: %llu, vb2_idx: %d\\n\",\n\t\t\t  run->mpeg2.pic->backward_ref_ts,\n\t\t\t  b_ref ? b_ref->index : -1,\n\t\t\t  run->mpeg2.pic->forward_ref_ts,\n\t\t\t  f_ref ? f_ref->index : -1);\n\t\tbreak;\n\t}\n\n\tcase VISL_CODEC_VP8: {\n\t\tstruct vb2_buffer *last;\n\t\tstruct vb2_buffer *golden;\n\t\tstruct vb2_buffer *alt;\n\n\t\tlast = vb2_find_buffer(cap_q, run->vp8.frame->last_frame_ts);\n\t\tgolden = vb2_find_buffer(cap_q, run->vp8.frame->golden_frame_ts);\n\t\talt = vb2_find_buffer(cap_q, run->vp8.frame->alt_frame_ts);\n\n\t\tscnprintf(buf, buflen,\n\t\t\t  \"last_ref_ts: %llu, vb2_idx: %d\\n\"\n\t\t\t  \"golden_ref_ts: %llu, vb2_idx: %d\\n\"\n\t\t\t  \"alt_ref_ts: %llu, vb2_idx: %d\\n\",\n\t\t\t  run->vp8.frame->last_frame_ts,\n\t\t\t  last ? last->index : -1,\n\t\t\t  run->vp8.frame->golden_frame_ts,\n\t\t\t  golden ? golden->index : -1,\n\t\t\t  run->vp8.frame->alt_frame_ts,\n\t\t\t  alt ? alt->index : -1);\n\t\tbreak;\n\t}\n\n\tcase VISL_CODEC_VP9: {\n\t\tstruct vb2_buffer *last;\n\t\tstruct vb2_buffer *golden;\n\t\tstruct vb2_buffer *alt;\n\n\t\tlast = vb2_find_buffer(cap_q, run->vp9.frame->last_frame_ts);\n\t\tgolden = vb2_find_buffer(cap_q, run->vp9.frame->golden_frame_ts);\n\t\talt = vb2_find_buffer(cap_q, run->vp9.frame->alt_frame_ts);\n\n\t\tscnprintf(buf, buflen,\n\t\t\t  \"last_ref_ts: %llu, vb2_idx: %d\\n\"\n\t\t\t  \"golden_ref_ts: %llu, vb2_idx: %d\\n\"\n\t\t\t  \"alt_ref_ts: %llu, vb2_idx: %d\\n\",\n\t\t\t  run->vp9.frame->last_frame_ts,\n\t\t\t  last ? last->index : -1,\n\t\t\t  run->vp9.frame->golden_frame_ts,\n\t\t\t  golden ? golden->index : -1,\n\t\t\t  run->vp9.frame->alt_frame_ts,\n\t\t\t  alt ? alt->index : -1);\n\t\tbreak;\n\t}\n\n\tcase VISL_CODEC_H264: {\n\t\tchar entry[] = \"dpb[%d]:%u, vb2_index: %d\\n\";\n\t\tstruct vb2_buffer *vb2_buf;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(run->h264.dpram->dpb); i++) {\n\t\t\tvb2_buf = vb2_find_buffer(cap_q, run->h264.dpram->dpb[i].reference_ts);\n\t\t\tlen = scnprintf(buf, buflen, entry, i,\n\t\t\t\t\trun->h264.dpram->dpb[i].reference_ts,\n\t\t\t\t\tvb2_buf ? vb2_buf->index : -1);\n\t\t\tbuf += len;\n\t\t\tbuflen -= len;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase VISL_CODEC_HEVC: {\n\t\tchar entry[] = \"dpb[%d]:%u, vb2_index: %d\\n\";\n\t\tstruct vb2_buffer *vb2_buf;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(run->hevc.dpram->dpb); i++) {\n\t\t\tvb2_buf = vb2_find_buffer(cap_q, run->hevc.dpram->dpb[i].timestamp);\n\t\t\tlen = scnprintf(buf, buflen, entry, i,\n\t\t\t\t\trun->hevc.dpram->dpb[i].timestamp,\n\t\t\t\t\tvb2_buf ? vb2_buf->index : -1);\n\t\t\tbuf += len;\n\t\t\tbuflen -= len;\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic char *visl_get_vb2_state(enum vb2_buffer_state state)\n{\n\tswitch (state) {\n\tcase VB2_BUF_STATE_DEQUEUED:\n\t\treturn \"Dequeued\";\n\tcase VB2_BUF_STATE_IN_REQUEST:\n\t\treturn \"In request\";\n\tcase VB2_BUF_STATE_PREPARING:\n\t\treturn \"Preparing\";\n\tcase VB2_BUF_STATE_QUEUED:\n\t\treturn \"Queued\";\n\tcase VB2_BUF_STATE_ACTIVE:\n\t\treturn \"Active\";\n\tcase VB2_BUF_STATE_DONE:\n\t\treturn \"Done\";\n\tcase VB2_BUF_STATE_ERROR:\n\t\treturn \"Error\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic int visl_fill_bytesused(struct vb2_v4l2_buffer *v4l2_vb2_buf, char *buf, size_t bufsz)\n{\n\tint len = 0;\n\tu32 i;\n\n\tfor (i = 0; i < v4l2_vb2_buf->vb2_buf.num_planes; i++)\n\t\tlen += scnprintf(buf, bufsz,\n\t\t\t\t\"bytesused[%u]: %u length[%u]: %u data_offset[%u]: %u\",\n\t\t\t\ti, v4l2_vb2_buf->planes[i].bytesused,\n\t\t\t\ti, v4l2_vb2_buf->planes[i].length,\n\t\t\t\ti, v4l2_vb2_buf->planes[i].data_offset);\n\n\treturn len;\n}\n\nstatic void visl_tpg_fill_sequence(struct visl_ctx *ctx,\n\t\t\t\t   struct visl_run *run, char buf[], size_t bufsz)\n{\n\tu32 stream_ms;\n\n\tstream_ms = jiffies_to_msecs(get_jiffies_64() - ctx->capture_streamon_jiffies);\n\n\tscnprintf(buf, bufsz,\n\t\t  \"stream time: %02d:%02d:%02d:%03d sequence:%u timestamp:%lld field:%s\",\n\t\t  (stream_ms / (60 * 60 * 1000)) % 24,\n\t\t  (stream_ms / (60 * 1000)) % 60,\n\t\t  (stream_ms / 1000) % 60,\n\t\t  stream_ms % 1000,\n\t\t  run->dst->sequence,\n\t\t  run->dst->vb2_buf.timestamp,\n\t\t  (run->dst->field == V4L2_FIELD_ALTERNATE) ?\n\t\t  (run->dst->field == V4L2_FIELD_TOP ?\n\t\t  \" top\" : \" bottom\") : \"none\");\n}\n\nstatic void visl_tpg_fill(struct visl_ctx *ctx, struct visl_run *run)\n{\n\tu8 *basep[TPG_MAX_PLANES][2];\n\tchar *buf = ctx->tpg_str_buf;\n\tchar *tmp = buf;\n\tchar *line_str;\n\tu32 line = 1;\n\tconst u32 line_height = 16;\n\tu32 len;\n\tstruct vb2_queue *out_q = &ctx->fh.m2m_ctx->out_q_ctx.q;\n\tstruct vb2_queue *cap_q = &ctx->fh.m2m_ctx->cap_q_ctx.q;\n\tstruct v4l2_pix_format_mplane *coded_fmt = &ctx->coded_fmt.fmt.pix_mp;\n\tstruct v4l2_pix_format_mplane *decoded_fmt = &ctx->decoded_fmt.fmt.pix_mp;\n\tu32 p;\n\tu32 i;\n\n\tfor (p = 0; p < tpg_g_planes(&ctx->tpg); p++) {\n\t\tvoid *vbuf = plane_vaddr(&ctx->tpg,\n\t\t\t\t\t &run->dst->vb2_buf, p,\n\t\t\t\t\t ctx->tpg.bytesperline,\n\t\t\t\t\t ctx->tpg.buf_height);\n\n\t\ttpg_calc_text_basep(&ctx->tpg, basep, p, vbuf);\n\t\ttpg_fill_plane_buffer(&ctx->tpg, 0, p, vbuf);\n\t}\n\n\tvisl_tpg_fill_sequence(ctx, run, buf, TPG_STR_BUF_SZ);\n\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"\");\n\tline++;\n\n\tvisl_get_ref_frames(ctx, buf, TPG_STR_BUF_SZ, run);\n\n\twhile ((line_str = strsep(&tmp, \"\\n\")) && strlen(line_str)) {\n\t\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, line_str);\n\t\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", line_str);\n\t}\n\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"\");\n\tline++;\n\n\tscnprintf(buf,\n\t\t  TPG_STR_BUF_SZ,\n\t\t  \"OUTPUT pixelformat: %c%c%c%c, resolution: %dx%d, num_planes: %d\",\n\t\t  coded_fmt->pixelformat,\n\t\t  (coded_fmt->pixelformat >> 8) & 0xff,\n\t\t  (coded_fmt->pixelformat >> 16) & 0xff,\n\t\t  (coded_fmt->pixelformat >> 24) & 0xff,\n\t\t  coded_fmt->width,\n\t\t  coded_fmt->height,\n\t\t  coded_fmt->num_planes);\n\n\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\n\tfor (i = 0; i < coded_fmt->num_planes; i++) {\n\t\tscnprintf(buf,\n\t\t\t  TPG_STR_BUF_SZ,\n\t\t\t  \"plane[%d]: bytesperline: %d, sizeimage: %d\",\n\t\t\t  i,\n\t\t\t  coded_fmt->plane_fmt[i].bytesperline,\n\t\t\t  coded_fmt->plane_fmt[i].sizeimage);\n\n\t\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\t\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\t}\n\n\tline++;\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"\");\n\tscnprintf(buf, TPG_STR_BUF_SZ, \"Output queue status:\");\n\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\n\tlen = 0;\n\tfor (i = 0; i < out_q->num_buffers; i++) {\n\t\tchar entry[] = \"index: %u, state: %s, request_fd: %d, \";\n\t\tu32 old_len = len;\n\t\tchar *q_status = visl_get_vb2_state(out_q->bufs[i]->state);\n\n\t\tlen += scnprintf(&buf[len], TPG_STR_BUF_SZ - len,\n\t\t\t\t entry, i, q_status,\n\t\t\t\t to_vb2_v4l2_buffer(out_q->bufs[i])->request_fd);\n\n\t\tlen += visl_fill_bytesused(to_vb2_v4l2_buffer(out_q->bufs[i]),\n\t\t\t\t\t   &buf[len],\n\t\t\t\t\t   TPG_STR_BUF_SZ - len);\n\n\t\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, &buf[old_len]);\n\t\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\", &buf[old_len]);\n\t}\n\n\tline++;\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"\");\n\n\tscnprintf(buf,\n\t\t  TPG_STR_BUF_SZ,\n\t\t  \"CAPTURE pixelformat: %c%c%c%c, resolution: %dx%d, num_planes: %d\",\n\t\t  decoded_fmt->pixelformat,\n\t\t  (decoded_fmt->pixelformat >> 8) & 0xff,\n\t\t  (decoded_fmt->pixelformat >> 16) & 0xff,\n\t\t  (decoded_fmt->pixelformat >> 24) & 0xff,\n\t\t  decoded_fmt->width,\n\t\t  decoded_fmt->height,\n\t\t  decoded_fmt->num_planes);\n\n\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\n\tfor (i = 0; i < decoded_fmt->num_planes; i++) {\n\t\tscnprintf(buf,\n\t\t\t  TPG_STR_BUF_SZ,\n\t\t\t  \"plane[%d]: bytesperline: %d, sizeimage: %d\",\n\t\t\t  i,\n\t\t\t  decoded_fmt->plane_fmt[i].bytesperline,\n\t\t\t  decoded_fmt->plane_fmt[i].sizeimage);\n\n\t\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\t\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\t}\n\n\tline++;\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"\");\n\tscnprintf(buf, TPG_STR_BUF_SZ, \"Capture queue status:\");\n\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, buf);\n\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\\n\", buf);\n\n\tlen = 0;\n\tfor (i = 0; i < cap_q->num_buffers; i++) {\n\t\tu32 old_len = len;\n\t\tchar *q_status = visl_get_vb2_state(cap_q->bufs[i]->state);\n\n\t\tlen += scnprintf(&buf[len], TPG_STR_BUF_SZ - len,\n\t\t\t\t \"index: %u, status: %s, timestamp: %llu, is_held: %d\",\n\t\t\t\t cap_q->bufs[i]->index, q_status,\n\t\t\t\t cap_q->bufs[i]->timestamp,\n\t\t\t\t to_vb2_v4l2_buffer(cap_q->bufs[i])->is_held);\n\n\t\ttpg_gen_text(&ctx->tpg, basep, line++ * line_height, 16, &buf[old_len]);\n\t\tframe_dprintk(ctx->dev, run->dst->sequence, \"%s\", &buf[old_len]);\n\t}\n}\n\nstatic void visl_trace_ctrls(struct visl_ctx *ctx, struct visl_run *run)\n{\n\tint i;\n\n\tswitch (ctx->current_codec) {\n\tdefault:\n\tcase VISL_CODEC_NONE:\n\t\tbreak;\n\tcase VISL_CODEC_FWHT:\n\t\ttrace_v4l2_ctrl_fwht_params(run->fwht.params);\n\t\tbreak;\n\tcase VISL_CODEC_MPEG2:\n\t\ttrace_v4l2_ctrl_mpeg2_sequence(run->mpeg2.seq);\n\t\ttrace_v4l2_ctrl_mpeg2_picture(run->mpeg2.pic);\n\t\ttrace_v4l2_ctrl_mpeg2_quantisation(run->mpeg2.quant);\n\t\tbreak;\n\tcase VISL_CODEC_VP8:\n\t\ttrace_v4l2_ctrl_vp8_frame(run->vp8.frame);\n\t\ttrace_v4l2_ctrl_vp8_entropy(run->vp8.frame);\n\t\tbreak;\n\tcase VISL_CODEC_VP9:\n\t\ttrace_v4l2_ctrl_vp9_frame(run->vp9.frame);\n\t\ttrace_v4l2_ctrl_vp9_compressed_hdr(run->vp9.probs);\n\t\ttrace_v4l2_ctrl_vp9_compressed_coeff(run->vp9.probs);\n\t\ttrace_v4l2_vp9_mv_probs(&run->vp9.probs->mv);\n\t\tbreak;\n\tcase VISL_CODEC_H264:\n\t\ttrace_v4l2_ctrl_h264_sps(run->h264.sps);\n\t\ttrace_v4l2_ctrl_h264_pps(run->h264.pps);\n\t\ttrace_v4l2_ctrl_h264_scaling_matrix(run->h264.sm);\n\t\ttrace_v4l2_ctrl_h264_slice_params(run->h264.spram);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(run->h264.spram->ref_pic_list0); i++)\n\t\t\ttrace_v4l2_h264_ref_pic_list0(&run->h264.spram->ref_pic_list0[i], i);\n\t\tfor (i = 0; i < ARRAY_SIZE(run->h264.spram->ref_pic_list0); i++)\n\t\t\ttrace_v4l2_h264_ref_pic_list1(&run->h264.spram->ref_pic_list1[i], i);\n\n\t\ttrace_v4l2_ctrl_h264_decode_params(run->h264.dpram);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(run->h264.dpram->dpb); i++)\n\t\t\ttrace_v4l2_h264_dpb_entry(&run->h264.dpram->dpb[i], i);\n\n\t\ttrace_v4l2_ctrl_h264_pred_weights(run->h264.pwht);\n\t\tbreak;\n\tcase VISL_CODEC_HEVC:\n\t\ttrace_v4l2_ctrl_hevc_sps(run->hevc.sps);\n\t\ttrace_v4l2_ctrl_hevc_pps(run->hevc.pps);\n\t\ttrace_v4l2_ctrl_hevc_slice_params(run->hevc.spram);\n\t\ttrace_v4l2_ctrl_hevc_scaling_matrix(run->hevc.sm);\n\t\ttrace_v4l2_ctrl_hevc_decode_params(run->hevc.dpram);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(run->hevc.dpram->dpb); i++)\n\t\t\ttrace_v4l2_hevc_dpb_entry(&run->hevc.dpram->dpb[i]);\n\n\t\ttrace_v4l2_hevc_pred_weight_table(&run->hevc.spram->pred_weight_table);\n\tbreak;\n\t}\n}\n\nvoid visl_device_run(void *priv)\n{\n\tstruct visl_ctx *ctx = priv;\n\tstruct visl_run run = {};\n\tstruct media_request *src_req;\n\n\trun.src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\trun.dst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\t \n\tsrc_req = run.src->vb2_buf.req_obj.req;\n\n\tif (src_req)\n\t\tv4l2_ctrl_request_setup(src_req, &ctx->hdl);\n\n\tv4l2_m2m_buf_copy_metadata(run.src, run.dst, true);\n\trun.dst->sequence = ctx->q_data[V4L2_M2M_DST].sequence++;\n\trun.src->sequence = ctx->q_data[V4L2_M2M_SRC].sequence++;\n\trun.dst->field = ctx->decoded_fmt.fmt.pix.field;\n\n\tswitch (ctx->current_codec) {\n\tdefault:\n\tcase VISL_CODEC_NONE:\n\t\tbreak;\n\tcase VISL_CODEC_FWHT:\n\t\trun.fwht.params = visl_find_control_data(ctx, V4L2_CID_STATELESS_FWHT_PARAMS);\n\t\tbreak;\n\tcase VISL_CODEC_MPEG2:\n\t\trun.mpeg2.seq = visl_find_control_data(ctx, V4L2_CID_STATELESS_MPEG2_SEQUENCE);\n\t\trun.mpeg2.pic = visl_find_control_data(ctx, V4L2_CID_STATELESS_MPEG2_PICTURE);\n\t\trun.mpeg2.quant = visl_find_control_data(ctx,\n\t\t\t\t\t\t\t V4L2_CID_STATELESS_MPEG2_QUANTISATION);\n\t\tbreak;\n\tcase VISL_CODEC_VP8:\n\t\trun.vp8.frame = visl_find_control_data(ctx, V4L2_CID_STATELESS_VP8_FRAME);\n\t\tbreak;\n\tcase VISL_CODEC_VP9:\n\t\trun.vp9.frame = visl_find_control_data(ctx, V4L2_CID_STATELESS_VP9_FRAME);\n\t\trun.vp9.probs = visl_find_control_data(ctx, V4L2_CID_STATELESS_VP9_COMPRESSED_HDR);\n\t\tbreak;\n\tcase VISL_CODEC_H264:\n\t\trun.h264.sps = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_SPS);\n\t\trun.h264.pps = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_PPS);\n\t\trun.h264.sm = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_SCALING_MATRIX);\n\t\trun.h264.spram = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_SLICE_PARAMS);\n\t\trun.h264.dpram = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\t\trun.h264.pwht = visl_find_control_data(ctx, V4L2_CID_STATELESS_H264_PRED_WEIGHTS);\n\t\tbreak;\n\tcase VISL_CODEC_HEVC:\n\t\trun.hevc.sps = visl_find_control_data(ctx, V4L2_CID_STATELESS_HEVC_SPS);\n\t\trun.hevc.pps = visl_find_control_data(ctx, V4L2_CID_STATELESS_HEVC_PPS);\n\t\trun.hevc.spram = visl_find_control_data(ctx, V4L2_CID_STATELESS_HEVC_SLICE_PARAMS);\n\t\trun.hevc.sm = visl_find_control_data(ctx, V4L2_CID_STATELESS_HEVC_SCALING_MATRIX);\n\t\trun.hevc.dpram = visl_find_control_data(ctx, V4L2_CID_STATELESS_HEVC_DECODE_PARAMS);\n\t\tbreak;\n\t}\n\n\tframe_dprintk(ctx->dev, run.dst->sequence,\n\t\t      \"Got OUTPUT buffer sequence %d, timestamp %llu\\n\",\n\t\t      run.src->sequence, run.src->vb2_buf.timestamp);\n\n\tframe_dprintk(ctx->dev, run.dst->sequence,\n\t\t      \"Got CAPTURE buffer sequence %d, timestamp %llu\\n\",\n\t\t      run.dst->sequence, run.dst->vb2_buf.timestamp);\n\n\tvisl_tpg_fill(ctx, &run);\n\tvisl_trace_ctrls(ctx, &run);\n\n\tif (bitstream_trace_frame_start > -1 &&\n\t    run.dst->sequence >= bitstream_trace_frame_start &&\n\t    run.dst->sequence < bitstream_trace_frame_start + bitstream_trace_nframes)\n\t\tvisl_trace_bitstream(ctx, &run);\n\n\t \n\tif (src_req)\n\t\tv4l2_ctrl_request_complete(src_req, &ctx->hdl);\n\n\tif (visl_transtime_ms)\n\t\tusleep_range(visl_transtime_ms * 1000, 2 * visl_transtime_ms * 1000);\n\n\tv4l2_m2m_buf_done_and_job_finish(ctx->dev->m2m_dev,\n\t\t\t\t\t ctx->fh.m2m_ctx, VB2_BUF_STATE_DONE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}