{
  "module_name": "vicodec-core.c",
  "hash_id": "b2ce8d6d566e862f6ff9a659618f2a4de71bdd7b02b3870b82b8f260226828c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vicodec/vicodec-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"codec-v4l2-fwht.h\"\n\nMODULE_DESCRIPTION(\"Virtual codec device\");\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic bool multiplanar;\nmodule_param(multiplanar, bool, 0444);\nMODULE_PARM_DESC(multiplanar,\n\t\t \" use multi-planar API instead of single-planar API\");\n\nstatic unsigned int debug;\nmodule_param(debug, uint, 0644);\nMODULE_PARM_DESC(debug, \" activates debug info\");\n\n#define VICODEC_NAME\t\t\"vicodec\"\n#define MAX_WIDTH\t\t4096U\n#define MIN_WIDTH\t\t640U\n#define MAX_HEIGHT\t\t2160U\n#define MIN_HEIGHT\t\t360U\n\n#define dprintk(dev, fmt, arg...) \\\n\tv4l2_dbg(1, debug, &dev->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\n\nstruct pixfmt_info {\n\tu32 id;\n\tunsigned int bytesperline_mult;\n\tunsigned int sizeimage_mult;\n\tunsigned int sizeimage_div;\n\tunsigned int luma_step;\n\tunsigned int chroma_step;\n\t \n\tunsigned int width_div;\n\tunsigned int height_div;\n};\n\nstatic const struct v4l2_fwht_pixfmt_info pixfmt_fwht = {\n\tV4L2_PIX_FMT_FWHT, 0, 3, 1, 1, 1, 1, 1, 0, 1\n};\n\nstatic const struct v4l2_fwht_pixfmt_info pixfmt_stateless_fwht = {\n\tV4L2_PIX_FMT_FWHT_STATELESS, 0, 3, 1, 1, 1, 1, 1, 0, 1\n};\n\nstatic void vicodec_dev_release(struct device *dev)\n{\n}\n\nstatic struct platform_device vicodec_pdev = {\n\t.name\t\t= VICODEC_NAME,\n\t.dev.release\t= vicodec_dev_release,\n};\n\n \nstruct vicodec_q_data {\n\tunsigned int\t\tcoded_width;\n\tunsigned int\t\tcoded_height;\n\tunsigned int\t\tvisible_width;\n\tunsigned int\t\tvisible_height;\n\tunsigned int\t\tsizeimage;\n\tunsigned int\t\tvb2_sizeimage;\n\tunsigned int\t\tsequence;\n\tconst struct v4l2_fwht_pixfmt_info *info;\n};\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nstruct vicodec_dev_instance {\n\tstruct video_device     vfd;\n\tstruct mutex            mutex;\n\tspinlock_t              lock;\n\tstruct v4l2_m2m_dev     *m2m_dev;\n};\n\nstruct vicodec_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct vicodec_dev_instance stateful_enc;\n\tstruct vicodec_dev_instance stateful_dec;\n\tstruct vicodec_dev_instance stateless_dec;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device\tmdev;\n#endif\n\n};\n\nstruct vicodec_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct vicodec_dev\t*dev;\n\tbool\t\t\tis_enc;\n\tbool\t\t\tis_stateless;\n\tspinlock_t\t\t*lock;\n\n\tstruct v4l2_ctrl_handler hdl;\n\n\t \n\tstruct vicodec_q_data   q_data[2];\n\tstruct v4l2_fwht_state\tstate;\n\n\tu32\t\t\tcur_buf_offset;\n\tu32\t\t\tcomp_max_size;\n\tu32\t\t\tcomp_size;\n\tu32\t\t\theader_size;\n\tu32\t\t\tcomp_magic_cnt;\n\tbool\t\t\tcomp_has_frame;\n\tbool\t\t\tcomp_has_next_frame;\n\tbool\t\t\tfirst_source_change_sent;\n\tbool\t\t\tsource_changed;\n};\n\nstatic const struct v4l2_event vicodec_eos_event = {\n\t.type = V4L2_EVENT_EOS\n};\n\nstatic inline struct vicodec_ctx *file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct vicodec_ctx, fh);\n}\n\nstatic struct vicodec_q_data *get_q_data(struct vicodec_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn &ctx->q_data[V4L2_M2M_SRC];\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\treturn &ctx->q_data[V4L2_M2M_DST];\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void copy_cap_to_ref(const u8 *cap, const struct v4l2_fwht_pixfmt_info *info,\n\t\tstruct v4l2_fwht_state *state)\n{\n\tint plane_idx;\n\tu8 *p_ref = state->ref_frame.buf;\n\tunsigned int cap_stride = state->stride;\n\tunsigned int ref_stride = state->ref_stride;\n\n\tfor (plane_idx = 0; plane_idx < info->planes_num; plane_idx++) {\n\t\tint i;\n\t\tunsigned int h_div = (plane_idx == 1 || plane_idx == 2) ?\n\t\t\tinfo->height_div : 1;\n\t\tconst u8 *row_cap = cap;\n\t\tu8 *row_ref = p_ref;\n\n\t\tif (info->planes_num == 3 && plane_idx == 1) {\n\t\t\tcap_stride /= 2;\n\t\t\tref_stride /= 2;\n\t\t}\n\n\t\tif (plane_idx == 1 &&\n\t\t    (info->id == V4L2_PIX_FMT_NV24 ||\n\t\t     info->id == V4L2_PIX_FMT_NV42)) {\n\t\t\tcap_stride *= 2;\n\t\t\tref_stride *= 2;\n\t\t}\n\n\t\tfor (i = 0; i < state->visible_height / h_div; i++) {\n\t\t\tmemcpy(row_ref, row_cap, ref_stride);\n\t\t\trow_ref += ref_stride;\n\t\t\trow_cap += cap_stride;\n\t\t}\n\t\tcap += cap_stride * (state->coded_height / h_div);\n\t\tp_ref += ref_stride * (state->coded_height / h_div);\n\t}\n}\n\nstatic bool validate_by_version(unsigned int flags, unsigned int version)\n{\n\tif (!version || version > V4L2_FWHT_VERSION)\n\t\treturn false;\n\n\tif (version >= 2) {\n\t\tunsigned int components_num = 1 +\n\t\t\t((flags & V4L2_FWHT_FL_COMPONENTS_NUM_MSK) >>\n\t\t\t V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET);\n\t\tunsigned int pixenc = flags & V4L2_FWHT_FL_PIXENC_MSK;\n\n\t\tif (components_num == 0 || components_num > 4 || !pixenc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool validate_stateless_params_flags(const struct v4l2_ctrl_fwht_params *params,\n\t\t\t\t\t    const struct v4l2_fwht_pixfmt_info *cur_info)\n{\n\tunsigned int width_div =\n\t\t(params->flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH) ? 1 : 2;\n\tunsigned int height_div =\n\t\t(params->flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT) ? 1 : 2;\n\tunsigned int components_num = 3;\n\tunsigned int pixenc = 0;\n\n\tif (params->version < 3)\n\t\treturn false;\n\n\tcomponents_num = 1 + ((params->flags & V4L2_FWHT_FL_COMPONENTS_NUM_MSK) >>\n\t\t\t      V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET);\n\tpixenc = (params->flags & V4L2_FWHT_FL_PIXENC_MSK);\n\tif (v4l2_fwht_validate_fmt(cur_info, width_div, height_div,\n\t\t\t\t    components_num, pixenc))\n\t\treturn true;\n\treturn false;\n}\n\n\nstatic void update_state_from_header(struct vicodec_ctx *ctx)\n{\n\tconst struct fwht_cframe_hdr *p_hdr = &ctx->state.header;\n\n\tctx->state.visible_width = ntohl(p_hdr->width);\n\tctx->state.visible_height = ntohl(p_hdr->height);\n\tctx->state.colorspace = ntohl(p_hdr->colorspace);\n\tctx->state.xfer_func = ntohl(p_hdr->xfer_func);\n\tctx->state.ycbcr_enc = ntohl(p_hdr->ycbcr_enc);\n\tctx->state.quantization = ntohl(p_hdr->quantization);\n}\n\nstatic int device_process(struct vicodec_ctx *ctx,\n\t\t\t  struct vb2_v4l2_buffer *src_vb,\n\t\t\t  struct vb2_v4l2_buffer *dst_vb)\n{\n\tstruct vicodec_dev *dev = ctx->dev;\n\tstruct v4l2_fwht_state *state = &ctx->state;\n\tu8 *p_src, *p_dst;\n\tint ret = 0;\n\n\tif (ctx->is_enc || ctx->is_stateless)\n\t\tp_src = vb2_plane_vaddr(&src_vb->vb2_buf, 0);\n\telse\n\t\tp_src = state->compressed_frame;\n\n\tif (ctx->is_stateless) {\n\t\tstruct media_request *src_req = src_vb->vb2_buf.req_obj.req;\n\n\t\tret = v4l2_ctrl_request_setup(src_req, &ctx->hdl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tupdate_state_from_header(ctx);\n\n\t\tctx->state.header.size =\n\t\t\thtonl(vb2_get_plane_payload(&src_vb->vb2_buf, 0));\n\t\t \n\t\tif (!(ntohl(ctx->state.header.flags) & V4L2_FWHT_FL_I_FRAME)) {\n\t\t\tstruct vb2_buffer *ref_vb2_buf;\n\t\t\tstruct vb2_queue *vq_cap =\n\t\t\t\tv4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t\t\tref_vb2_buf = vb2_find_buffer(vq_cap, ctx->state.ref_frame_ts);\n\t\t\tif (!ref_vb2_buf)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ref_vb2_buf->state == VB2_BUF_STATE_ERROR)\n\t\t\t\tret = -EINVAL;\n\t\t\tctx->state.ref_frame.buf =\n\t\t\t\tvb2_plane_vaddr(ref_vb2_buf, 0);\n\t\t} else {\n\t\t\tctx->state.ref_frame.buf = NULL;\n\t\t}\n\t}\n\tp_dst = vb2_plane_vaddr(&dst_vb->vb2_buf, 0);\n\tif (!p_src || !p_dst) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Acquiring kernel pointers to buffers failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ctx->is_enc) {\n\t\tstruct vicodec_q_data *q_src;\n\t\tint comp_sz_or_errcode;\n\n\t\tq_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tstate->info = q_src->info;\n\t\tcomp_sz_or_errcode = v4l2_fwht_encode(state, p_src, p_dst);\n\t\tif (comp_sz_or_errcode < 0)\n\t\t\treturn comp_sz_or_errcode;\n\t\tvb2_set_plane_payload(&dst_vb->vb2_buf, 0, comp_sz_or_errcode);\n\t} else {\n\t\tstruct vicodec_q_data *q_dst;\n\t\tunsigned int comp_frame_size = ntohl(ctx->state.header.size);\n\n\t\tq_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tif (comp_frame_size > ctx->comp_max_size)\n\t\t\treturn -EINVAL;\n\t\tstate->info = q_dst->info;\n\t\tret = v4l2_fwht_decode(state, p_src, p_dst);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!ctx->is_stateless)\n\t\t\tcopy_cap_to_ref(p_dst, ctx->state.info, &ctx->state);\n\n\t\tvb2_set_plane_payload(&dst_vb->vb2_buf, 0, q_dst->sizeimage);\n\t\tif (ntohl(ctx->state.header.flags) & V4L2_FWHT_FL_I_FRAME)\n\t\t\tdst_vb->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\telse\n\t\t\tdst_vb->flags |= V4L2_BUF_FLAG_PFRAME;\n\t}\n\treturn ret;\n}\n\n \nstatic enum vb2_buffer_state get_next_header(struct vicodec_ctx *ctx,\n\t\t\t\t\t     u8 **pp, u32 sz)\n{\n\tstatic const u8 magic[] = {\n\t\t0x4f, 0x4f, 0x4f, 0x4f, 0xff, 0xff, 0xff, 0xff\n\t};\n\tu8 *p = *pp;\n\tu32 state;\n\tu8 *header = (u8 *)&ctx->state.header;\n\n\tstate = VB2_BUF_STATE_DONE;\n\n\tif (!ctx->header_size) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tfor (; p < *pp + sz; p++) {\n\t\t\tu32 copy;\n\n\t\t\tp = memchr(p, magic[ctx->comp_magic_cnt],\n\t\t\t\t   *pp + sz - p);\n\t\t\tif (!p) {\n\t\t\t\tctx->comp_magic_cnt = 0;\n\t\t\t\tp = *pp + sz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcopy = sizeof(magic) - ctx->comp_magic_cnt;\n\t\t\tif (*pp + sz - p < copy)\n\t\t\t\tcopy = *pp + sz - p;\n\n\t\t\tmemcpy(header + ctx->comp_magic_cnt, p, copy);\n\t\t\tctx->comp_magic_cnt += copy;\n\t\t\tif (!memcmp(header, magic, ctx->comp_magic_cnt)) {\n\t\t\t\tp += copy;\n\t\t\t\tstate = VB2_BUF_STATE_DONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx->comp_magic_cnt = 0;\n\t\t}\n\t\tif (ctx->comp_magic_cnt < sizeof(magic)) {\n\t\t\t*pp = p;\n\t\t\treturn state;\n\t\t}\n\t\tctx->header_size = sizeof(magic);\n\t}\n\n\tif (ctx->header_size < sizeof(struct fwht_cframe_hdr)) {\n\t\tu32 copy = sizeof(struct fwht_cframe_hdr) - ctx->header_size;\n\n\t\tif (*pp + sz - p < copy)\n\t\t\tcopy = *pp + sz - p;\n\n\t\tmemcpy(header + ctx->header_size, p, copy);\n\t\tp += copy;\n\t\tctx->header_size += copy;\n\t}\n\t*pp = p;\n\treturn state;\n}\n\n \nstatic void device_run(void *priv)\n{\n\tstruct vicodec_ctx *ctx = priv;\n\tstruct vicodec_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct vicodec_q_data *q_src, *q_dst;\n\tu32 state;\n\tstruct media_request *src_req;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tsrc_req = src_buf->vb2_buf.req_obj.req;\n\n\tq_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tstate = VB2_BUF_STATE_DONE;\n\tif (device_process(ctx, src_buf, dst_buf))\n\t\tstate = VB2_BUF_STATE_ERROR;\n\telse\n\t\tdst_buf->sequence = q_dst->sequence++;\n\tdst_buf->flags &= ~V4L2_BUF_FLAG_LAST;\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);\n\n\tspin_lock(ctx->lock);\n\tif (!ctx->comp_has_next_frame &&\n\t    v4l2_m2m_is_last_draining_src_buf(ctx->fh.m2m_ctx, src_buf)) {\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tv4l2_event_queue_fh(&ctx->fh, &vicodec_eos_event);\n\t\tv4l2_m2m_mark_stopped(ctx->fh.m2m_ctx);\n\t}\n\tif (ctx->is_enc || ctx->is_stateless) {\n\t\tsrc_buf->sequence = q_src->sequence++;\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_buf, state);\n\t} else if (vb2_get_plane_payload(&src_buf->vb2_buf, 0) == ctx->cur_buf_offset) {\n\t\tsrc_buf->sequence = q_src->sequence++;\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_buf, state);\n\t\tctx->cur_buf_offset = 0;\n\t\tctx->comp_has_next_frame = false;\n\t}\n\tv4l2_m2m_buf_done(dst_buf, state);\n\n\tctx->comp_size = 0;\n\tctx->header_size = 0;\n\tctx->comp_magic_cnt = 0;\n\tctx->comp_has_frame = false;\n\tspin_unlock(ctx->lock);\n\tif (ctx->is_stateless && src_req)\n\t\tv4l2_ctrl_request_complete(src_req, &ctx->hdl);\n\n\tif (ctx->is_enc)\n\t\tv4l2_m2m_job_finish(dev->stateful_enc.m2m_dev, ctx->fh.m2m_ctx);\n\telse if (ctx->is_stateless)\n\t\tv4l2_m2m_job_finish(dev->stateless_dec.m2m_dev,\n\t\t\t\t    ctx->fh.m2m_ctx);\n\telse\n\t\tv4l2_m2m_job_finish(dev->stateful_dec.m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void job_remove_src_buf(struct vicodec_ctx *ctx, u32 state)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct vicodec_q_data *q_src;\n\n\tq_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tspin_lock(ctx->lock);\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tsrc_buf->sequence = q_src->sequence++;\n\tv4l2_m2m_buf_done(src_buf, state);\n\tctx->cur_buf_offset = 0;\n\tspin_unlock(ctx->lock);\n}\n\nstatic const struct v4l2_fwht_pixfmt_info *\ninfo_from_header(const struct fwht_cframe_hdr *p_hdr)\n{\n\tunsigned int flags = ntohl(p_hdr->flags);\n\tunsigned int width_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH) ? 1 : 2;\n\tunsigned int height_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT) ? 1 : 2;\n\tunsigned int components_num = 3;\n\tunsigned int pixenc = 0;\n\tunsigned int version = ntohl(p_hdr->version);\n\n\tif (version >= 2) {\n\t\tcomponents_num = 1 + ((flags & V4L2_FWHT_FL_COMPONENTS_NUM_MSK) >>\n\t\t\t\tV4L2_FWHT_FL_COMPONENTS_NUM_OFFSET);\n\t\tpixenc = (flags & V4L2_FWHT_FL_PIXENC_MSK);\n\t}\n\treturn v4l2_fwht_find_nth_fmt(width_div, height_div,\n\t\t\t\t     components_num, pixenc, 0);\n}\n\nstatic bool is_header_valid(const struct fwht_cframe_hdr *p_hdr)\n{\n\tconst struct v4l2_fwht_pixfmt_info *info;\n\tunsigned int w = ntohl(p_hdr->width);\n\tunsigned int h = ntohl(p_hdr->height);\n\tunsigned int version = ntohl(p_hdr->version);\n\tunsigned int flags = ntohl(p_hdr->flags);\n\n\tif (w < MIN_WIDTH || w > MAX_WIDTH || h < MIN_HEIGHT || h > MAX_HEIGHT)\n\t\treturn false;\n\n\tif (!validate_by_version(flags, version))\n\t\treturn false;\n\n\tinfo = info_from_header(p_hdr);\n\tif (!info)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void update_capture_data_from_header(struct vicodec_ctx *ctx)\n{\n\tstruct vicodec_q_data *q_dst = get_q_data(ctx,\n\t\t\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tconst struct fwht_cframe_hdr *p_hdr = &ctx->state.header;\n\tconst struct v4l2_fwht_pixfmt_info *info = info_from_header(p_hdr);\n\tunsigned int flags = ntohl(p_hdr->flags);\n\tunsigned int hdr_width_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH) ? 1 : 2;\n\tunsigned int hdr_height_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT) ? 1 : 2;\n\n\t \n\tWARN_ON(ctx->is_stateless);\n\n\tq_dst->info = info;\n\tq_dst->visible_width = ntohl(p_hdr->width);\n\tq_dst->visible_height = ntohl(p_hdr->height);\n\tq_dst->coded_width = vic_round_dim(q_dst->visible_width, hdr_width_div);\n\tq_dst->coded_height = vic_round_dim(q_dst->visible_height,\n\t\t\t\t\t    hdr_height_div);\n\n\tq_dst->sizeimage = q_dst->coded_width * q_dst->coded_height *\n\t\tq_dst->info->sizeimage_mult / q_dst->info->sizeimage_div;\n\tctx->state.colorspace = ntohl(p_hdr->colorspace);\n\n\tctx->state.xfer_func = ntohl(p_hdr->xfer_func);\n\tctx->state.ycbcr_enc = ntohl(p_hdr->ycbcr_enc);\n\tctx->state.quantization = ntohl(p_hdr->quantization);\n}\n\nstatic void set_last_buffer(struct vb2_v4l2_buffer *dst_buf,\n\t\t\t    const struct vb2_v4l2_buffer *src_buf,\n\t\t\t    struct vicodec_ctx *ctx)\n{\n\tstruct vicodec_q_data *q_dst = get_q_data(ctx,\n\t\t\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\tdst_buf->sequence = q_dst->sequence++;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, !ctx->is_enc);\n\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic int job_ready(void *priv)\n{\n\tstatic const u8 magic[] = {\n\t\t0x4f, 0x4f, 0x4f, 0x4f, 0xff, 0xff, 0xff, 0xff\n\t};\n\tstruct vicodec_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src_buf;\n\tu8 *p_src;\n\tu8 *p;\n\tu32 sz;\n\tu32 state;\n\tstruct vicodec_q_data *q_dst = get_q_data(ctx,\n\t\t\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tunsigned int flags;\n\tunsigned int hdr_width_div;\n\tunsigned int hdr_height_div;\n\tunsigned int max_to_copy;\n\tunsigned int comp_frame_size;\n\n\tif (ctx->source_changed)\n\t\treturn 0;\n\tif (ctx->is_stateless || ctx->is_enc || ctx->comp_has_frame)\n\t\treturn 1;\n\nrestart:\n\tctx->comp_has_next_frame = false;\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tif (!src_buf)\n\t\treturn 0;\n\tp_src = vb2_plane_vaddr(&src_buf->vb2_buf, 0);\n\tsz = vb2_get_plane_payload(&src_buf->vb2_buf, 0);\n\tp = p_src + ctx->cur_buf_offset;\n\n\tstate = VB2_BUF_STATE_DONE;\n\n\tif (ctx->header_size < sizeof(struct fwht_cframe_hdr)) {\n\t\tstate = get_next_header(ctx, &p, p_src + sz - p);\n\t\tif (ctx->header_size < sizeof(struct fwht_cframe_hdr)) {\n\t\t\tif (v4l2_m2m_is_last_draining_src_buf(ctx->fh.m2m_ctx,\n\t\t\t\t\t\t\t      src_buf))\n\t\t\t\treturn 1;\n\t\t\tjob_remove_src_buf(ctx, state);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tcomp_frame_size = ntohl(ctx->state.header.size);\n\n\t \n\tmax_to_copy = min(comp_frame_size, ctx->comp_max_size);\n\n\tif (ctx->comp_size < max_to_copy) {\n\t\tu32 copy = max_to_copy - ctx->comp_size;\n\n\t\tif (copy > p_src + sz - p)\n\t\t\tcopy = p_src + sz - p;\n\n\t\tmemcpy(ctx->state.compressed_frame + ctx->comp_size,\n\t\t       p, copy);\n\t\tp += copy;\n\t\tctx->comp_size += copy;\n\t\tif (ctx->comp_size < max_to_copy) {\n\t\t\tif (v4l2_m2m_is_last_draining_src_buf(ctx->fh.m2m_ctx,\n\t\t\t\t\t\t\t      src_buf))\n\t\t\t\treturn 1;\n\t\t\tjob_remove_src_buf(ctx, state);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tctx->cur_buf_offset = p - p_src;\n\tif (ctx->comp_size == comp_frame_size)\n\t\tctx->comp_has_frame = true;\n\tctx->comp_has_next_frame = false;\n\tif (ctx->comp_has_frame && sz - ctx->cur_buf_offset >=\n\t\t\tsizeof(struct fwht_cframe_hdr)) {\n\t\tstruct fwht_cframe_hdr *p_hdr = (struct fwht_cframe_hdr *)p;\n\t\tu32 frame_size = ntohl(p_hdr->size);\n\t\tu32 remaining = sz - ctx->cur_buf_offset - sizeof(*p_hdr);\n\n\t\tif (!memcmp(p, magic, sizeof(magic)))\n\t\t\tctx->comp_has_next_frame = remaining >= frame_size;\n\t}\n\t \n\tif (!is_header_valid(&ctx->state.header) && ctx->comp_has_frame)\n\t\treturn 1;\n\tflags = ntohl(ctx->state.header.flags);\n\thdr_width_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH) ? 1 : 2;\n\thdr_height_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT) ? 1 : 2;\n\n\tif (ntohl(ctx->state.header.width) != q_dst->visible_width ||\n\t    ntohl(ctx->state.header.height) != q_dst->visible_height ||\n\t    !q_dst->info ||\n\t    hdr_width_div != q_dst->info->width_div ||\n\t    hdr_height_div != q_dst->info->height_div) {\n\t\tstatic const struct v4l2_event rs_event = {\n\t\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t\t};\n\n\t\tstruct vb2_v4l2_buffer *dst_buf =\n\t\t\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tupdate_capture_data_from_header(ctx);\n\t\tv4l2_event_queue_fh(&ctx->fh, &rs_event);\n\t\tset_last_buffer(dst_buf, src_buf, ctx);\n\t\tctx->source_changed = true;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \n\nstatic const struct v4l2_fwht_pixfmt_info *find_fmt(u32 fmt)\n{\n\tconst struct v4l2_fwht_pixfmt_info *info =\n\t\tv4l2_fwht_find_pixfmt(fmt);\n\n\tif (!info)\n\t\tinfo = v4l2_fwht_get_pixfmt(0);\n\treturn info;\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, VICODEC_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, VICODEC_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t\t\"platform:%s\", VICODEC_NAME);\n\treturn 0;\n}\n\nstatic int enum_fmt(struct v4l2_fmtdesc *f, struct vicodec_ctx *ctx,\n\t\t    bool is_out)\n{\n\tbool is_uncomp = (ctx->is_enc && is_out) || (!ctx->is_enc && !is_out);\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(f->type) && !multiplanar)\n\t\treturn -EINVAL;\n\tif (!V4L2_TYPE_IS_MULTIPLANAR(f->type) && multiplanar)\n\t\treturn -EINVAL;\n\n\tif (is_uncomp) {\n\t\tconst struct v4l2_fwht_pixfmt_info *info =\n\t\t\t\t\tget_q_data(ctx, f->type)->info;\n\n\t\tif (ctx->is_enc ||\n\t\t    !vb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q))\n\t\t\tinfo = v4l2_fwht_get_pixfmt(f->index);\n\t\telse\n\t\t\tinfo = v4l2_fwht_find_nth_fmt(info->width_div,\n\t\t\t\t\t\t     info->height_div,\n\t\t\t\t\t\t     info->components_num,\n\t\t\t\t\t\t     info->pixenc,\n\t\t\t\t\t\t     f->index);\n\t\tif (!info)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = info->id;\n\t} else {\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = ctx->is_stateless ?\n\t\t\tV4L2_PIX_FMT_FWHT_STATELESS : V4L2_PIX_FMT_FWHT;\n\t\tif (!ctx->is_enc && !ctx->is_stateless)\n\t\t\tf->flags = V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t   V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\n\treturn enum_fmt(f, ctx, false);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\n\treturn enum_fmt(f, ctx, true);\n}\n\nstatic int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct vicodec_q_data *q_data;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct v4l2_pix_format *pix;\n\tconst struct v4l2_fwht_pixfmt_info *info;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tinfo = q_data->info;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix = &f->fmt.pix;\n\t\tpix->width = q_data->coded_width;\n\t\tpix->height = q_data->coded_height;\n\t\tpix->field = V4L2_FIELD_NONE;\n\t\tpix->pixelformat = info->id;\n\t\tpix->bytesperline = q_data->coded_width *\n\t\t\t\t\tinfo->bytesperline_mult;\n\t\tpix->sizeimage = q_data->sizeimage;\n\t\tpix->colorspace = ctx->state.colorspace;\n\t\tpix->xfer_func = ctx->state.xfer_func;\n\t\tpix->ycbcr_enc = ctx->state.ycbcr_enc;\n\t\tpix->quantization = ctx->state.quantization;\n\t\tbreak;\n\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (!multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix_mp = &f->fmt.pix_mp;\n\t\tpix_mp->width = q_data->coded_width;\n\t\tpix_mp->height = q_data->coded_height;\n\t\tpix_mp->field = V4L2_FIELD_NONE;\n\t\tpix_mp->pixelformat = info->id;\n\t\tpix_mp->num_planes = 1;\n\t\tpix_mp->plane_fmt[0].bytesperline =\n\t\t\t\tq_data->coded_width * info->bytesperline_mult;\n\t\tpix_mp->plane_fmt[0].sizeimage = q_data->sizeimage;\n\t\tpix_mp->colorspace = ctx->state.colorspace;\n\t\tpix_mp->xfer_func = ctx->state.xfer_func;\n\t\tpix_mp->ycbcr_enc = ctx->state.ycbcr_enc;\n\t\tpix_mp->quantization = ctx->state.quantization;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct v4l2_pix_format *pix;\n\tstruct v4l2_plane_pix_format *plane;\n\tconst struct v4l2_fwht_pixfmt_info *info = ctx->is_stateless ?\n\t\t&pixfmt_stateless_fwht : &pixfmt_fwht;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tpix = &f->fmt.pix;\n\t\tif (pix->pixelformat != V4L2_PIX_FMT_FWHT &&\n\t\t    pix->pixelformat != V4L2_PIX_FMT_FWHT_STATELESS)\n\t\t\tinfo = find_fmt(pix->pixelformat);\n\n\t\tpix->width = clamp(pix->width, MIN_WIDTH, MAX_WIDTH);\n\t\tpix->width = vic_round_dim(pix->width, info->width_div);\n\n\t\tpix->height = clamp(pix->height, MIN_HEIGHT, MAX_HEIGHT);\n\t\tpix->height = vic_round_dim(pix->height, info->height_div);\n\n\t\tpix->field = V4L2_FIELD_NONE;\n\t\tpix->bytesperline =\n\t\t\tpix->width * info->bytesperline_mult;\n\t\tpix->sizeimage = pix->width * pix->height *\n\t\t\tinfo->sizeimage_mult / info->sizeimage_div;\n\t\tif (pix->pixelformat == V4L2_PIX_FMT_FWHT)\n\t\t\tpix->sizeimage += sizeof(struct fwht_cframe_hdr);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tpix_mp = &f->fmt.pix_mp;\n\t\tplane = pix_mp->plane_fmt;\n\t\tif (pix_mp->pixelformat != V4L2_PIX_FMT_FWHT &&\n\t\t    pix_mp->pixelformat != V4L2_PIX_FMT_FWHT_STATELESS)\n\t\t\tinfo = find_fmt(pix_mp->pixelformat);\n\t\tpix_mp->num_planes = 1;\n\n\t\tpix_mp->width = clamp(pix_mp->width, MIN_WIDTH, MAX_WIDTH);\n\t\tpix_mp->width = vic_round_dim(pix_mp->width, info->width_div);\n\n\t\tpix_mp->height = clamp(pix_mp->height, MIN_HEIGHT, MAX_HEIGHT);\n\t\tpix_mp->height = vic_round_dim(pix_mp->height,\n\t\t\t\t\t       info->height_div);\n\n\t\tpix_mp->field = V4L2_FIELD_NONE;\n\t\tplane->bytesperline =\n\t\t\tpix_mp->width * info->bytesperline_mult;\n\t\tplane->sizeimage = pix_mp->width * pix_mp->height *\n\t\t\tinfo->sizeimage_mult / info->sizeimage_div;\n\t\tif (pix_mp->pixelformat == V4L2_PIX_FMT_FWHT)\n\t\t\tplane->sizeimage += sizeof(struct fwht_cframe_hdr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct v4l2_pix_format *pix;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix = &f->fmt.pix;\n\t\tpix->pixelformat = ctx->is_enc ? V4L2_PIX_FMT_FWHT :\n\t\t\t\t   find_fmt(f->fmt.pix.pixelformat)->id;\n\t\tpix->colorspace = ctx->state.colorspace;\n\t\tpix->xfer_func = ctx->state.xfer_func;\n\t\tpix->ycbcr_enc = ctx->state.ycbcr_enc;\n\t\tpix->quantization = ctx->state.quantization;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (!multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix_mp = &f->fmt.pix_mp;\n\t\tpix_mp->pixelformat = ctx->is_enc ? V4L2_PIX_FMT_FWHT :\n\t\t\t\t      find_fmt(pix_mp->pixelformat)->id;\n\t\tpix_mp->colorspace = ctx->state.colorspace;\n\t\tpix_mp->xfer_func = ctx->state.xfer_func;\n\t\tpix_mp->ycbcr_enc = ctx->state.ycbcr_enc;\n\t\tpix_mp->quantization = ctx->state.quantization;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(ctx, f);\n}\n\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct v4l2_pix_format *pix;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix = &f->fmt.pix;\n\t\tif (ctx->is_enc)\n\t\t\tpix->pixelformat = find_fmt(pix->pixelformat)->id;\n\t\telse if (ctx->is_stateless)\n\t\t\tpix->pixelformat = V4L2_PIX_FMT_FWHT_STATELESS;\n\t\telse\n\t\t\tpix->pixelformat = V4L2_PIX_FMT_FWHT;\n\t\tif (!pix->colorspace)\n\t\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (!multiplanar)\n\t\t\treturn -EINVAL;\n\t\tpix_mp = &f->fmt.pix_mp;\n\t\tif (ctx->is_enc)\n\t\t\tpix_mp->pixelformat = find_fmt(pix_mp->pixelformat)->id;\n\t\telse if (ctx->is_stateless)\n\t\t\tpix_mp->pixelformat = V4L2_PIX_FMT_FWHT_STATELESS;\n\t\telse\n\t\t\tpix_mp->pixelformat = V4L2_PIX_FMT_FWHT;\n\t\tif (!pix_mp->colorspace)\n\t\t\tpix_mp->colorspace = V4L2_COLORSPACE_REC709;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(ctx, f);\n}\n\nstatic int vidioc_s_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vicodec_q_data *q_data;\n\tstruct vb2_queue *vq;\n\tbool fmt_changed = true;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct v4l2_pix_format *pix;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tpix = &f->fmt.pix;\n\t\tif (ctx->is_enc && V4L2_TYPE_IS_OUTPUT(f->type))\n\t\t\tfmt_changed =\n\t\t\t\t!q_data->info ||\n\t\t\t\tq_data->info->id != pix->pixelformat ||\n\t\t\t\tq_data->coded_width != pix->width ||\n\t\t\t\tq_data->coded_height != pix->height;\n\n\t\tif (vb2_is_busy(vq) && fmt_changed)\n\t\t\treturn -EBUSY;\n\n\t\tif (pix->pixelformat == V4L2_PIX_FMT_FWHT)\n\t\t\tq_data->info = &pixfmt_fwht;\n\t\telse if (pix->pixelformat == V4L2_PIX_FMT_FWHT_STATELESS)\n\t\t\tq_data->info = &pixfmt_stateless_fwht;\n\t\telse\n\t\t\tq_data->info = find_fmt(pix->pixelformat);\n\t\tq_data->coded_width = pix->width;\n\t\tq_data->coded_height = pix->height;\n\t\tq_data->sizeimage = pix->sizeimage;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tpix_mp = &f->fmt.pix_mp;\n\t\tif (ctx->is_enc && V4L2_TYPE_IS_OUTPUT(f->type))\n\t\t\tfmt_changed =\n\t\t\t\t!q_data->info ||\n\t\t\t\tq_data->info->id != pix_mp->pixelformat ||\n\t\t\t\tq_data->coded_width != pix_mp->width ||\n\t\t\t\tq_data->coded_height != pix_mp->height;\n\n\t\tif (vb2_is_busy(vq) && fmt_changed)\n\t\t\treturn -EBUSY;\n\n\t\tif (pix_mp->pixelformat == V4L2_PIX_FMT_FWHT)\n\t\t\tq_data->info = &pixfmt_fwht;\n\t\telse if (pix_mp->pixelformat == V4L2_PIX_FMT_FWHT_STATELESS)\n\t\t\tq_data->info = &pixfmt_stateless_fwht;\n\t\telse\n\t\t\tq_data->info = find_fmt(pix_mp->pixelformat);\n\t\tq_data->coded_width = pix_mp->width;\n\t\tq_data->coded_height = pix_mp->height;\n\t\tq_data->sizeimage = pix_mp->plane_fmt[0].sizeimage;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(ctx->dev,\n\t\t\"Setting format for type %d, coded wxh: %dx%d, fourcc: 0x%08x\\n\",\n\t\tf->type, q_data->coded_width, q_data->coded_height,\n\t\tq_data->info->id);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vidioc_s_fmt(file2ctx(file), f);\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tstruct vicodec_q_data *q_data;\n\tstruct vicodec_q_data *q_data_cap;\n\tstruct v4l2_pix_format *pix;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tu32 coded_w = 0, coded_h = 0;\n\tunsigned int size = 0;\n\tint ret;\n\n\tq_data = get_q_data(ctx, f->type);\n\tq_data_cap = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tret = vidioc_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->is_enc) {\n\t\tstruct vb2_queue *vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\t\tstruct vb2_queue *vq_cap = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\t\t   V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tconst struct v4l2_fwht_pixfmt_info *info = ctx->is_stateless ?\n\t\t\t&pixfmt_stateless_fwht : &pixfmt_fwht;\n\n\t\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t\tcoded_w = f->fmt.pix.width;\n\t\t\tcoded_h = f->fmt.pix.height;\n\t\t} else {\n\t\t\tcoded_w = f->fmt.pix_mp.width;\n\t\t\tcoded_h = f->fmt.pix_mp.height;\n\t\t}\n\t\tif (vb2_is_busy(vq) && (coded_w != q_data->coded_width ||\n\t\t\t\t\tcoded_h != q_data->coded_height))\n\t\t\treturn -EBUSY;\n\t\tsize = coded_w * coded_h *\n\t\t\tinfo->sizeimage_mult / info->sizeimage_div;\n\t\tif (!ctx->is_stateless)\n\t\t\tsize += sizeof(struct fwht_cframe_hdr);\n\n\t\tif (vb2_is_busy(vq_cap) && size > q_data_cap->sizeimage)\n\t\t\treturn -EBUSY;\n\t}\n\n\tret = vidioc_s_fmt(file2ctx(file), f);\n\tif (!ret) {\n\t\tif (ctx->is_enc) {\n\t\t\tq_data->visible_width = coded_w;\n\t\t\tq_data->visible_height = coded_h;\n\t\t\tq_data_cap->coded_width = coded_w;\n\t\t\tq_data_cap->coded_height = coded_h;\n\t\t\tq_data_cap->sizeimage = size;\n\t\t}\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tpix = &f->fmt.pix;\n\t\t\tctx->state.colorspace = pix->colorspace;\n\t\t\tctx->state.xfer_func = pix->xfer_func;\n\t\t\tctx->state.ycbcr_enc = pix->ycbcr_enc;\n\t\t\tctx->state.quantization = pix->quantization;\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tpix_mp = &f->fmt.pix_mp;\n\t\t\tctx->state.colorspace = pix_mp->colorspace;\n\t\t\tctx->state.xfer_func = pix_mp->xfer_func;\n\t\t\tctx->state.ycbcr_enc = pix_mp->ycbcr_enc;\n\t\t\tctx->state.quantization = pix_mp->quantization;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tstruct vicodec_q_data *q_data;\n\n\tq_data = get_q_data(ctx, s->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\t \n\tif (ctx->is_enc && s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tswitch (s->target) {\n\t\tcase V4L2_SEL_TGT_CROP:\n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = q_data->visible_width;\n\t\t\ts->r.height = q_data->visible_height;\n\t\t\treturn 0;\n\t\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = q_data->coded_width;\n\t\t\ts->r.height = q_data->coded_height;\n\t\t\treturn 0;\n\t\t}\n\t} else if (!ctx->is_enc && s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tswitch (s->target) {\n\t\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = q_data->visible_width;\n\t\t\ts->r.height = q_data->visible_height;\n\t\t\treturn 0;\n\t\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = q_data->coded_width;\n\t\t\ts->r.height = q_data->coded_height;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tstruct vicodec_q_data *q_data;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, s->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (!ctx->is_enc || s->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\ts->r.left = 0;\n\ts->r.top = 0;\n\tq_data->visible_width = clamp(s->r.width, MIN_WIDTH,\n\t\t\t\t      q_data->coded_width);\n\ts->r.width = q_data->visible_width;\n\tq_data->visible_height = clamp(s->r.height, MIN_HEIGHT,\n\t\t\t\t       q_data->coded_height);\n\ts->r.height = q_data->visible_height;\n\treturn 0;\n}\n\nstatic int vicodec_encoder_cmd(struct file *file, void *fh,\n\t\t\t    struct v4l2_encoder_cmd *ec)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, ec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q) ||\n\t    !vb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q))\n\t\treturn 0;\n\n\tret = v4l2_m2m_ioctl_encoder_cmd(file, fh, ec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ec->cmd == V4L2_ENC_CMD_STOP &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tv4l2_event_queue_fh(&ctx->fh, &vicodec_eos_event);\n\n\tif (ec->cmd == V4L2_ENC_CMD_START &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tvb2_clear_last_buffer_dequeued(&ctx->fh.m2m_ctx->cap_q_ctx.q);\n\n\treturn 0;\n}\n\nstatic int vicodec_decoder_cmd(struct file *file, void *fh,\n\t\t\t    struct v4l2_decoder_cmd *dc)\n{\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, dc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q) ||\n\t    !vb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q))\n\t\treturn 0;\n\n\tret = v4l2_m2m_ioctl_decoder_cmd(file, fh, dc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dc->cmd == V4L2_DEC_CMD_STOP &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tv4l2_event_queue_fh(&ctx->fh, &vicodec_eos_event);\n\n\tif (dc->cmd == V4L2_DEC_CMD_START &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tvb2_clear_last_buffer_dequeued(&ctx->fh.m2m_ctx->cap_q_ctx.q);\n\n\treturn 0;\n}\n\nstatic int vicodec_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_frmsizeenum *fsize)\n{\n\tswitch (fsize->pixel_format) {\n\tcase V4L2_PIX_FMT_FWHT_STATELESS:\n\t\tbreak;\n\tcase V4L2_PIX_FMT_FWHT:\n\t\tbreak;\n\tdefault:\n\t\tif (find_fmt(fsize->pixel_format)->id == fsize->pixel_format)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\n\tfsize->stepwise.min_width = MIN_WIDTH;\n\tfsize->stepwise.max_width = MAX_WIDTH;\n\tfsize->stepwise.step_width = 8;\n\tfsize->stepwise.min_height = MIN_HEIGHT;\n\tfsize->stepwise.max_height = MAX_HEIGHT;\n\tfsize->stepwise.step_height = 8;\n\n\treturn 0;\n}\n\nstatic int vicodec_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tstruct vicodec_ctx *ctx = container_of(fh, struct vicodec_ctx, fh);\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\tif (ctx->is_enc)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase V4L2_EVENT_EOS:\n\t\tif (ctx->is_stateless)\n\t\t\treturn -EINVAL;\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops vicodec_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_s_fmt_vid_cap,\n\n\t.vidioc_g_fmt_vid_cap_mplane\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap_mplane\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap_mplane\t= vidioc_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= vidioc_s_fmt_vid_out,\n\n\t.vidioc_g_fmt_vid_out_mplane\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out_mplane\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out_mplane\t= vidioc_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection\t= vidioc_g_selection,\n\t.vidioc_s_selection\t= vidioc_s_selection,\n\n\t.vidioc_try_encoder_cmd\t= v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd\t= vicodec_encoder_cmd,\n\t.vidioc_try_decoder_cmd\t= v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd\t= vicodec_decoder_cmd,\n\t.vidioc_enum_framesizes = vicodec_enum_framesizes,\n\n\t.vidioc_subscribe_event = vicodec_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n\n \n\nstatic int vicodec_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t       unsigned int *nplanes, unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vicodec_q_data *q_data = get_q_data(ctx, vq->type);\n\tunsigned int size = q_data->sizeimage;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\tq_data->vb2_sizeimage = size;\n\treturn 0;\n}\n\nstatic int vicodec_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic int vicodec_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vicodec_q_data *q_data;\n\n\tdprintk(ctx->dev, \"type: %d\\n\", vb->vb2_queue->type);\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdprintk(ctx->dev, \"%s field isn't supported\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (vb2_plane_size(vb, 0) < q_data->vb2_sizeimage) {\n\t\tdprintk(ctx->dev,\n\t\t\t\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t(long)q_data->vb2_sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vicodec_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int sz = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\n\tu8 *p_src = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\n\tu8 *p = p_src;\n\tstruct vb2_queue *vq_out = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\t   V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tstruct vb2_queue *vq_cap = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\t   V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tbool header_valid = false;\n\tstatic const struct v4l2_event rs_event = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tif (V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type) &&\n\t    vb2_is_streaming(vb->vb2_queue) &&\n\t    v4l2_m2m_dst_buf_is_last(ctx->fh.m2m_ctx)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < vb->num_planes; i++)\n\t\t\tvb2_set_plane_payload(vb, i, 0);\n\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvbuf->sequence =\n\t\t\tget_q_data(ctx, vb->vb2_queue->type)->sequence++;\n\n\t\tv4l2_m2m_last_buffer_done(ctx->fh.m2m_ctx, vbuf);\n\t\tv4l2_event_queue_fh(&ctx->fh, &vicodec_eos_event);\n\t\treturn;\n\t}\n\n\t \n\tif (ctx->first_source_change_sent) {\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\treturn;\n\t}\n\n\t \n\tif (vb2_is_streaming(vq_cap) && vb2_is_streaming(vq_out)) {\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\treturn;\n\t}\n\n\t \n\tif (ctx->is_stateless || ctx->is_enc ||\n\t    V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type)) {\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tenum vb2_buffer_state state =\n\t\t\tget_next_header(ctx, &p, p_src + sz - p);\n\n\t\tif (ctx->header_size < sizeof(struct fwht_cframe_hdr)) {\n\t\t\tv4l2_m2m_buf_done(vbuf, state);\n\t\t\treturn;\n\t\t}\n\t\theader_valid = is_header_valid(&ctx->state.header);\n\t\t \n\t\tif (!header_valid) {\n\t\t\tp = p - sizeof(struct fwht_cframe_hdr) + 1;\n\t\t\tif (p < p_src)\n\t\t\t\tp = p_src;\n\t\t\tctx->header_size = 0;\n\t\t\tctx->comp_magic_cnt = 0;\n\t\t}\n\n\t} while (!header_valid);\n\n\tctx->cur_buf_offset = p - p_src;\n\tupdate_capture_data_from_header(ctx);\n\tctx->first_source_change_sent = true;\n\tv4l2_event_queue_fh(&ctx->fh, &rs_event);\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void vicodec_return_bufs(struct vb2_queue *q, u32 state)\n{\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (vbuf == NULL)\n\t\t\treturn;\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->hdl);\n\t\tspin_lock(ctx->lock);\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t\tspin_unlock(ctx->lock);\n\t}\n}\n\nstatic unsigned int total_frame_size(struct vicodec_q_data *q_data)\n{\n\tunsigned int size;\n\tunsigned int chroma_div;\n\n\tif (!q_data->info) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\tsize = q_data->coded_width * q_data->coded_height;\n\tchroma_div = q_data->info->width_div * q_data->info->height_div;\n\n\tif (q_data->info->components_num == 4)\n\t\treturn 2 * size + 2 * (size / chroma_div);\n\telse if (q_data->info->components_num == 3)\n\t\treturn size + 2 * (size / chroma_div);\n\treturn size;\n}\n\nstatic int vicodec_start_streaming(struct vb2_queue *q,\n\t\t\t\t   unsigned int count)\n{\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vicodec_q_data *q_data = get_q_data(ctx, q->type);\n\tstruct v4l2_fwht_state *state = &ctx->state;\n\tconst struct v4l2_fwht_pixfmt_info *info = q_data->info;\n\tunsigned int size = q_data->coded_width * q_data->coded_height;\n\tunsigned int chroma_div;\n\tunsigned int total_planes_size;\n\tu8 *new_comp_frame = NULL;\n\n\tchroma_div = info->width_div * info->height_div;\n\tq_data->sequence = 0;\n\n\tv4l2_m2m_update_start_streaming_state(ctx->fh.m2m_ctx, q);\n\n\tstate->gop_cnt = 0;\n\n\tif ((V4L2_TYPE_IS_OUTPUT(q->type) && !ctx->is_enc) ||\n\t    (V4L2_TYPE_IS_CAPTURE(q->type) && ctx->is_enc))\n\t\treturn 0;\n\n\tif (info->id == V4L2_PIX_FMT_FWHT ||\n\t    info->id == V4L2_PIX_FMT_FWHT_STATELESS) {\n\t\tvicodec_return_bufs(q, VB2_BUF_STATE_QUEUED);\n\t\treturn -EINVAL;\n\t}\n\ttotal_planes_size = total_frame_size(q_data);\n\tctx->comp_max_size = total_planes_size;\n\n\tstate->visible_width = q_data->visible_width;\n\tstate->visible_height = q_data->visible_height;\n\tstate->coded_width = q_data->coded_width;\n\tstate->coded_height = q_data->coded_height;\n\tstate->stride = q_data->coded_width *\n\t\t\t\tinfo->bytesperline_mult;\n\n\tif (ctx->is_stateless) {\n\t\tstate->ref_stride = state->stride;\n\t\treturn 0;\n\t}\n\tstate->ref_stride = q_data->coded_width * info->luma_alpha_step;\n\n\tstate->ref_frame.buf = kvmalloc(total_planes_size, GFP_KERNEL);\n\tstate->ref_frame.luma = state->ref_frame.buf;\n\tnew_comp_frame = kvmalloc(ctx->comp_max_size, GFP_KERNEL);\n\n\tif (!state->ref_frame.luma || !new_comp_frame) {\n\t\tkvfree(state->ref_frame.luma);\n\t\tkvfree(new_comp_frame);\n\t\tvicodec_return_bufs(q, VB2_BUF_STATE_QUEUED);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tif (state->compressed_frame) {\n\t\tif (ctx->comp_size > ctx->comp_max_size)\n\t\t\tctx->comp_size = ctx->comp_max_size;\n\n\t\tmemcpy(new_comp_frame,\n\t\t       state->compressed_frame, ctx->comp_size);\n\t}\n\n\tkvfree(state->compressed_frame);\n\tstate->compressed_frame = new_comp_frame;\n\n\tif (info->components_num < 3) {\n\t\tstate->ref_frame.cb = NULL;\n\t\tstate->ref_frame.cr = NULL;\n\t\tstate->ref_frame.alpha = NULL;\n\t\treturn 0;\n\t}\n\n\tstate->ref_frame.cb = state->ref_frame.luma + size;\n\tstate->ref_frame.cr = state->ref_frame.cb + size / chroma_div;\n\n\tif (info->components_num == 4)\n\t\tstate->ref_frame.alpha =\n\t\t\tstate->ref_frame.cr + size / chroma_div;\n\telse\n\t\tstate->ref_frame.alpha = NULL;\n\n\treturn 0;\n}\n\nstatic void vicodec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(q);\n\n\tvicodec_return_bufs(q, VB2_BUF_STATE_ERROR);\n\n\tv4l2_m2m_update_stop_streaming_state(ctx->fh.m2m_ctx, q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type) &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tv4l2_event_queue_fh(&ctx->fh, &vicodec_eos_event);\n\n\tif (!ctx->is_enc && V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tctx->first_source_change_sent = false;\n\n\tif ((!V4L2_TYPE_IS_OUTPUT(q->type) && !ctx->is_enc) ||\n\t    (V4L2_TYPE_IS_OUTPUT(q->type) && ctx->is_enc)) {\n\t\tif (!ctx->is_stateless)\n\t\t\tkvfree(ctx->state.ref_frame.buf);\n\t\tctx->state.ref_frame.buf = NULL;\n\t\tctx->state.ref_frame.luma = NULL;\n\t\tctx->comp_max_size = 0;\n\t\tctx->source_changed = false;\n\t}\n\tif (V4L2_TYPE_IS_OUTPUT(q->type) && !ctx->is_enc) {\n\t\tctx->cur_buf_offset = 0;\n\t\tctx->comp_size = 0;\n\t\tctx->header_size = 0;\n\t\tctx->comp_magic_cnt = 0;\n\t\tctx->comp_has_frame = false;\n\t\tctx->comp_has_next_frame = false;\n\t}\n}\n\nstatic void vicodec_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vicodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);\n}\n\n\nstatic const struct vb2_ops vicodec_qops = {\n\t.queue_setup\t\t= vicodec_queue_setup,\n\t.buf_out_validate\t= vicodec_buf_out_validate,\n\t.buf_prepare\t\t= vicodec_buf_prepare,\n\t.buf_queue\t\t= vicodec_buf_queue,\n\t.buf_request_complete\t= vicodec_buf_request_complete,\n\t.start_streaming\t= vicodec_start_streaming,\n\t.stop_streaming\t\t= vicodec_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct vicodec_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = (multiplanar ?\n\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :\n\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &vicodec_qops;\n\tsrc_vq->mem_ops = &vb2_vmalloc_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tif (ctx->is_enc)\n\t\tsrc_vq->lock = &ctx->dev->stateful_enc.mutex;\n\telse if (ctx->is_stateless)\n\t\tsrc_vq->lock = &ctx->dev->stateless_dec.mutex;\n\telse\n\t\tsrc_vq->lock = &ctx->dev->stateful_dec.mutex;\n\tsrc_vq->supports_requests = ctx->is_stateless;\n\tsrc_vq->requires_requests = ctx->is_stateless;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = (multiplanar ?\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &vicodec_qops;\n\tdst_vq->mem_ops = &vb2_vmalloc_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = src_vq->lock;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int vicodec_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vicodec_ctx *ctx = container_of(ctrl->handler,\n\t\t\tstruct vicodec_ctx, hdl);\n\tconst struct v4l2_ctrl_fwht_params *params;\n\tstruct vicodec_q_data *q_dst = get_q_data(ctx,\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_STATELESS_FWHT_PARAMS:\n\t\tif (!q_dst->info)\n\t\t\treturn -EINVAL;\n\t\tparams = ctrl->p_new.p_fwht_params;\n\t\tif (params->width > q_dst->coded_width ||\n\t\t    params->width < MIN_WIDTH ||\n\t\t    params->height > q_dst->coded_height ||\n\t\t    params->height < MIN_HEIGHT)\n\t\t\treturn -EINVAL;\n\t\tif (!validate_by_version(params->flags, params->version))\n\t\t\treturn -EINVAL;\n\t\tif (!validate_stateless_params_flags(params, q_dst->info))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void update_header_from_stateless_params(struct vicodec_ctx *ctx,\n\t\t\t\t\t\tconst struct v4l2_ctrl_fwht_params *params)\n{\n\tstruct fwht_cframe_hdr *p_hdr = &ctx->state.header;\n\n\tp_hdr->magic1 = FWHT_MAGIC1;\n\tp_hdr->magic2 = FWHT_MAGIC2;\n\tp_hdr->version = htonl(params->version);\n\tp_hdr->width = htonl(params->width);\n\tp_hdr->height = htonl(params->height);\n\tp_hdr->flags = htonl(params->flags);\n\tp_hdr->colorspace = htonl(params->colorspace);\n\tp_hdr->xfer_func = htonl(params->xfer_func);\n\tp_hdr->ycbcr_enc = htonl(params->ycbcr_enc);\n\tp_hdr->quantization = htonl(params->quantization);\n}\n\nstatic int vicodec_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vicodec_ctx *ctx = container_of(ctrl->handler,\n\t\t\t\t\t       struct vicodec_ctx, hdl);\n\tconst struct v4l2_ctrl_fwht_params *params;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tctx->state.gop_size = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_FWHT_I_FRAME_QP:\n\t\tctx->state.i_frame_qp = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_FWHT_P_FRAME_QP:\n\t\tctx->state.p_frame_qp = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_STATELESS_FWHT_PARAMS:\n\t\tparams = ctrl->p_new.p_fwht_params;\n\t\tupdate_header_from_stateless_params(ctx, params);\n\t\tctx->state.ref_frame_ts = params->backward_ref_ts;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops vicodec_ctrl_ops = {\n\t.s_ctrl = vicodec_s_ctrl,\n\t.try_ctrl = vicodec_try_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vicodec_ctrl_stateless_state = {\n\t.ops\t\t= &vicodec_ctrl_ops,\n\t.id\t\t= V4L2_CID_STATELESS_FWHT_PARAMS,\n\t.elem_size      = sizeof(struct v4l2_ctrl_fwht_params),\n};\n\n \nstatic int vicodec_open(struct file *file)\n{\n\tconst struct v4l2_fwht_pixfmt_info *info = v4l2_fwht_get_pixfmt(0);\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct vicodec_dev *dev = video_drvdata(file);\n\tstruct vicodec_ctx *ctx = NULL;\n\tstruct v4l2_ctrl_handler *hdl;\n\tunsigned int raw_size;\n\tunsigned int comp_size;\n\tint rc = 0;\n\n\tif (mutex_lock_interruptible(vfd->lock))\n\t\treturn -ERESTARTSYS;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto open_unlock;\n\t}\n\n\tif (vfd == &dev->stateful_enc.vfd)\n\t\tctx->is_enc = true;\n\telse if (vfd == &dev->stateless_dec.vfd)\n\t\tctx->is_stateless = true;\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\thdl = &ctx->hdl;\n\tv4l2_ctrl_handler_init(hdl, 5);\n\tv4l2_ctrl_new_std(hdl, &vicodec_ctrl_ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t  1, 16, 1, 10);\n\tv4l2_ctrl_new_std(hdl, &vicodec_ctrl_ops, V4L2_CID_FWHT_I_FRAME_QP,\n\t\t\t  1, 31, 1, 20);\n\tv4l2_ctrl_new_std(hdl, &vicodec_ctrl_ops, V4L2_CID_FWHT_P_FRAME_QP,\n\t\t\t  1, 31, 1, 20);\n\tif (ctx->is_enc)\n\t\tv4l2_ctrl_new_std(hdl, &vicodec_ctrl_ops,\n\t\t\t\t  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 1, 1, 1);\n\tif (ctx->is_stateless)\n\t\tv4l2_ctrl_new_custom(hdl, &vicodec_ctrl_stateless_state, NULL);\n\tif (hdl->error) {\n\t\trc = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tif (ctx->is_enc)\n\t\tctx->q_data[V4L2_M2M_SRC].info = info;\n\telse if (ctx->is_stateless)\n\t\tctx->q_data[V4L2_M2M_SRC].info = &pixfmt_stateless_fwht;\n\telse\n\t\tctx->q_data[V4L2_M2M_SRC].info = &pixfmt_fwht;\n\tctx->q_data[V4L2_M2M_SRC].coded_width = 1280;\n\tctx->q_data[V4L2_M2M_SRC].coded_height = 720;\n\tctx->q_data[V4L2_M2M_SRC].visible_width = 1280;\n\tctx->q_data[V4L2_M2M_SRC].visible_height = 720;\n\traw_size = 1280 * 720 * info->sizeimage_mult / info->sizeimage_div;\n\tcomp_size = 1280 * 720 * pixfmt_fwht.sizeimage_mult /\n\t\t\t\t pixfmt_fwht.sizeimage_div;\n\tif (ctx->is_enc)\n\t\tctx->q_data[V4L2_M2M_SRC].sizeimage = raw_size;\n\telse if (ctx->is_stateless)\n\t\tctx->q_data[V4L2_M2M_SRC].sizeimage = comp_size;\n\telse\n\t\tctx->q_data[V4L2_M2M_SRC].sizeimage =\n\t\t\tcomp_size + sizeof(struct fwht_cframe_hdr);\n\tctx->q_data[V4L2_M2M_DST] = ctx->q_data[V4L2_M2M_SRC];\n\tif (ctx->is_enc) {\n\t\tctx->q_data[V4L2_M2M_DST].info = &pixfmt_fwht;\n\t\tctx->q_data[V4L2_M2M_DST].sizeimage =\n\t\t\tcomp_size + sizeof(struct fwht_cframe_hdr);\n\t} else {\n\t\tctx->q_data[V4L2_M2M_DST].info = info;\n\t\tctx->q_data[V4L2_M2M_DST].sizeimage = raw_size;\n\t}\n\n\tctx->state.colorspace = V4L2_COLORSPACE_REC709;\n\n\tif (ctx->is_enc) {\n\t\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->stateful_enc.m2m_dev,\n\t\t\t\t\t\t    ctx, &queue_init);\n\t\tctx->lock = &dev->stateful_enc.lock;\n\t} else if (ctx->is_stateless) {\n\t\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->stateless_dec.m2m_dev,\n\t\t\t\t\t\t    ctx, &queue_init);\n\t\tctx->lock = &dev->stateless_dec.lock;\n\t} else {\n\t\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->stateful_dec.m2m_dev,\n\t\t\t\t\t\t    ctx, &queue_init);\n\t\tctx->lock = &dev->stateful_dec.lock;\n\t}\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\trc = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_fh_exit(&ctx->fh);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\nopen_unlock:\n\tmutex_unlock(vfd->lock);\n\treturn rc;\n}\n\nstatic int vicodec_release(struct file *file)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct vicodec_ctx *ctx = file2ctx(file);\n\n\tmutex_lock(vfd->lock);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(vfd->lock);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tkvfree(ctx->state.compressed_frame);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic int vicodec_request_validate(struct media_request *req)\n{\n\tstruct media_request_object *obj;\n\tstruct v4l2_ctrl_handler *parent_hdl, *hdl;\n\tstruct vicodec_ctx *ctx = NULL;\n\tstruct v4l2_ctrl *ctrl;\n\tunsigned int count;\n\n\tlist_for_each_entry(obj, &req->objects, list) {\n\t\tstruct vb2_buffer *vb;\n\n\t\tif (vb2_request_object_is_buffer(obj)) {\n\t\t\tvb = container_of(obj, struct vb2_buffer, req_obj);\n\t\t\tctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx) {\n\t\tpr_err(\"No buffer was provided with the request\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tcount = vb2_request_buffer_cnt(req);\n\tif (!count) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev,\n\t\t\t  \"No buffer was provided with the request\\n\");\n\t\treturn -ENOENT;\n\t} else if (count > 1) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev,\n\t\t\t  \"More than one buffer was provided with the request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparent_hdl = &ctx->hdl;\n\n\thdl = v4l2_ctrl_request_hdl_find(req, parent_hdl);\n\tif (!hdl) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev, \"Missing codec control\\n\");\n\t\treturn -ENOENT;\n\t}\n\tctrl = v4l2_ctrl_request_hdl_ctrl_find(hdl,\n\t\t\t\t\t       vicodec_ctrl_stateless_state.id);\n\tv4l2_ctrl_request_hdl_put(hdl);\n\tif (!ctrl) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev,\n\t\t\t  \"Missing required codec control\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn vb2_request_validate(req);\n}\n\nstatic const struct v4l2_file_operations vicodec_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vicodec_open,\n\t.release\t= vicodec_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device vicodec_videodev = {\n\t.name\t\t= VICODEC_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &vicodec_fops,\n\t.ioctl_ops\t= &vicodec_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n};\n\nstatic const struct media_device_ops vicodec_m2m_media_ops = {\n\t.req_validate\t= vicodec_request_validate,\n\t.req_queue\t= v4l2_m2m_request_queue,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= device_run,\n\t.job_ready\t= job_ready,\n};\n\nstatic int register_instance(struct vicodec_dev *dev,\n\t\t\t     struct vicodec_dev_instance *dev_instance,\n\t\t\t     const char *name, bool is_enc)\n{\n\tstruct video_device *vfd;\n\tint ret;\n\n\tspin_lock_init(&dev_instance->lock);\n\tmutex_init(&dev_instance->mutex);\n\tdev_instance->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(dev_instance->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init vicodec enc device\\n\");\n\t\treturn PTR_ERR(dev_instance->m2m_dev);\n\t}\n\n\tdev_instance->vfd = vicodec_videodev;\n\tvfd = &dev_instance->vfd;\n\tvfd->lock = &dev_instance->mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tstrscpy(vfd->name, name, sizeof(vfd->name));\n\tvfd->device_caps = V4L2_CAP_STREAMING |\n\t\t(multiplanar ? V4L2_CAP_VIDEO_M2M_MPLANE : V4L2_CAP_VIDEO_M2M);\n\tif (is_enc) {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_DECODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_DECODER_CMD);\n\t} else {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENCODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_ENCODER_CMD);\n\t}\n\tvideo_set_drvdata(vfd, dev);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device '%s'\\n\", name);\n\t\tv4l2_m2m_release(dev_instance->m2m_dev);\n\t\treturn ret;\n\t}\n\tv4l2_info(&dev->v4l2_dev, \"Device '%s' registered as /dev/video%d\\n\",\n\t\t  name, vfd->num);\n\treturn 0;\n}\n\nstatic void vicodec_v4l2_dev_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct vicodec_dev *dev = container_of(v4l2_dev, struct vicodec_dev, v4l2_dev);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_m2m_release(dev->stateful_enc.m2m_dev);\n\tv4l2_m2m_release(dev->stateful_dec.m2m_dev);\n\tv4l2_m2m_release(dev->stateless_dec.m2m_dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_cleanup(&dev->mdev);\n#endif\n\tkfree(dev);\n}\n\nstatic int vicodec_probe(struct platform_device *pdev)\n{\n\tstruct vicodec_dev *dev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev->v4l2_dev.release = vicodec_v4l2_dev_release;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->mdev.dev = &pdev->dev;\n\tstrscpy(dev->mdev.model, \"vicodec\", sizeof(dev->mdev.model));\n\tstrscpy(dev->mdev.bus_info, \"platform:vicodec\",\n\t\tsizeof(dev->mdev.bus_info));\n\tmedia_device_init(&dev->mdev);\n\tdev->mdev.ops = &vicodec_m2m_media_ops;\n\tdev->v4l2_dev.mdev = &dev->mdev;\n#endif\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tret = register_instance(dev, &dev->stateful_enc, \"stateful-encoder\",\n\t\t\t\ttrue);\n\tif (ret)\n\t\tgoto unreg_dev;\n\n\tret = register_instance(dev, &dev->stateful_dec, \"stateful-decoder\",\n\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto unreg_sf_enc;\n\n\tret = register_instance(dev, &dev->stateless_dec, \"stateless-decoder\",\n\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto unreg_sf_dec;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tret = v4l2_m2m_register_media_controller(dev->stateful_enc.m2m_dev,\n\t\t\t\t\t\t &dev->stateful_enc.vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_ENCODER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem media controller for enc\\n\");\n\t\tgoto unreg_m2m;\n\t}\n\n\tret = v4l2_m2m_register_media_controller(dev->stateful_dec.m2m_dev,\n\t\t\t\t\t\t &dev->stateful_dec.vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem media controller for dec\\n\");\n\t\tgoto unreg_m2m_sf_enc_mc;\n\t}\n\n\tret = v4l2_m2m_register_media_controller(dev->stateless_dec.m2m_dev,\n\t\t\t\t\t\t &dev->stateless_dec.vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem media controller for stateless dec\\n\");\n\t\tgoto unreg_m2m_sf_dec_mc;\n\t}\n\n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register mem2mem media device\\n\");\n\t\tgoto unreg_m2m_sl_dec_mc;\n\t}\n#endif\n\treturn 0;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nunreg_m2m_sl_dec_mc:\n\tv4l2_m2m_unregister_media_controller(dev->stateless_dec.m2m_dev);\nunreg_m2m_sf_dec_mc:\n\tv4l2_m2m_unregister_media_controller(dev->stateful_dec.m2m_dev);\nunreg_m2m_sf_enc_mc:\n\tv4l2_m2m_unregister_media_controller(dev->stateful_enc.m2m_dev);\nunreg_m2m:\n\tvideo_unregister_device(&dev->stateless_dec.vfd);\n\tv4l2_m2m_release(dev->stateless_dec.m2m_dev);\n#endif\nunreg_sf_dec:\n\tvideo_unregister_device(&dev->stateful_dec.vfd);\n\tv4l2_m2m_release(dev->stateful_dec.m2m_dev);\nunreg_sf_enc:\n\tvideo_unregister_device(&dev->stateful_enc.vfd);\n\tv4l2_m2m_release(dev->stateful_enc.m2m_dev);\nunreg_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nfree_dev:\n\tkfree(dev);\n\n\treturn ret;\n}\n\nstatic void vicodec_remove(struct platform_device *pdev)\n{\n\tstruct vicodec_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" VICODEC_NAME);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_unregister(&dev->mdev);\n\tv4l2_m2m_unregister_media_controller(dev->stateful_enc.m2m_dev);\n\tv4l2_m2m_unregister_media_controller(dev->stateful_dec.m2m_dev);\n\tv4l2_m2m_unregister_media_controller(dev->stateless_dec.m2m_dev);\n#endif\n\n\tvideo_unregister_device(&dev->stateful_enc.vfd);\n\tvideo_unregister_device(&dev->stateful_dec.vfd);\n\tvideo_unregister_device(&dev->stateless_dec.vfd);\n\tv4l2_device_put(&dev->v4l2_dev);\n}\n\nstatic struct platform_driver vicodec_pdrv = {\n\t.probe\t\t= vicodec_probe,\n\t.remove_new\t= vicodec_remove,\n\t.driver\t\t= {\n\t\t.name\t= VICODEC_NAME,\n\t},\n};\n\nstatic void __exit vicodec_exit(void)\n{\n\tplatform_driver_unregister(&vicodec_pdrv);\n\tplatform_device_unregister(&vicodec_pdev);\n}\n\nstatic int __init vicodec_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&vicodec_pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&vicodec_pdrv);\n\tif (ret)\n\t\tplatform_device_unregister(&vicodec_pdev);\n\n\treturn ret;\n}\n\nmodule_init(vicodec_init);\nmodule_exit(vicodec_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}