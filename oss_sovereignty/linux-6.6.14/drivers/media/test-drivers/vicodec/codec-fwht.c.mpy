{
  "module_name": "codec-fwht.c",
  "hash_id": "7bba0e7d686c329693db3996edc72808e00d98374227e021d1147f9a08cfaaa7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vicodec/codec-fwht.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/videodev2.h>\n#include \"codec-fwht.h\"\n\n#define OVERFLOW_BIT BIT(14)\n\n \n#define PFRAME_BIT BIT(15)\n#define DUPS_MASK 0x1ffe\n\n#define PBLOCK 0\n#define IBLOCK 1\n\n#define ALL_ZEROS 15\n\nstatic const uint8_t zigzag[64] = {\n\t0,\n\t1,  8,\n\t2,  9, 16,\n\t3, 10, 17, 24,\n\t4, 11, 18, 25, 32,\n\t5, 12, 19, 26, 33, 40,\n\t6, 13, 20, 27, 34, 41, 48,\n\t7, 14, 21, 28, 35, 42, 49, 56,\n\t15, 22, 29, 36, 43, 50, 57,\n\t23, 30, 37, 44, 51, 58,\n\t31, 38, 45, 52, 59,\n\t39, 46, 53, 60,\n\t47, 54, 61,\n\t55, 62,\n\t63,\n};\n\n \nstatic int noinline_for_stack\nrlc(const s16 *in, __be16 *output, int blocktype)\n{\n\ts16 block[8 * 8];\n\ts16 *wp = block;\n\tint i = 0;\n\tint x, y;\n\tint ret = 0;\n\n\t \n\tint lastzero_run = 0;\n\tint to_encode;\n\n\tfor (y = 0; y < 8; y++) {\n\t\tfor (x = 0; x < 8; x++) {\n\t\t\t*wp = in[x + y * 8];\n\t\t\twp++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 63; i >= 0 && !block[zigzag[i]]; i--)\n\t\tlastzero_run++;\n\n\t*output++ = (blocktype == PBLOCK ? htons(PFRAME_BIT) : 0);\n\tret++;\n\n\tto_encode = 8 * 8 - (lastzero_run > 14 ? lastzero_run : 0);\n\n\ti = 0;\n\twhile (i < to_encode) {\n\t\tint cnt = 0;\n\t\tint tmp;\n\n\t\t \n\t\twhile ((tmp = block[zigzag[i]]) == 0 && cnt < 14) {\n\t\t\tcnt++;\n\t\t\ti++;\n\t\t\tif (i == to_encode) {\n\t\t\t\tcnt--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\t*output++ = htons((cnt | tmp << 4));\n\t\ti++;\n\t\tret++;\n\t}\n\tif (lastzero_run > 14) {\n\t\t*output = htons(ALL_ZEROS | 0);\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n \nstatic noinline_for_stack u16\nderlc(const __be16 **rlc_in, s16 *dwht_out, const __be16 *end_of_input)\n{\n\t \n\tconst __be16 *input = *rlc_in;\n\tu16 stat;\n\tint dec_count = 0;\n\ts16 block[8 * 8 + 16];\n\ts16 *wp = block;\n\tint i;\n\n\tif (input > end_of_input)\n\t\treturn OVERFLOW_BIT;\n\tstat = ntohs(*input++);\n\n\t \n\twhile (dec_count < 8 * 8) {\n\t\ts16 in;\n\t\tint length;\n\t\tint coeff;\n\n\t\tif (input > end_of_input)\n\t\t\treturn OVERFLOW_BIT;\n\t\tin = ntohs(*input++);\n\t\tlength = in & 0xf;\n\t\tcoeff = in >> 4;\n\n\t\t \n\t\tif (length == 15) {\n\t\t\tfor (i = 0; i < 64 - dec_count; i++)\n\t\t\t\t*wp++ = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t\t*wp++ = 0;\n\t\t*wp++ = coeff;\n\t\tdec_count += length + 1;\n\t}\n\n\twp = block;\n\n\tfor (i = 0; i < 64; i++) {\n\t\tint pos = zigzag[i];\n\t\tint y = pos / 8;\n\t\tint x = pos % 8;\n\n\t\tdwht_out[x + y * 8] = *wp++;\n\t}\n\t*rlc_in = input;\n\treturn stat;\n}\n\nstatic const int quant_table[] = {\n\t2, 2, 2, 2, 2, 2,  2,  2,\n\t2, 2, 2, 2, 2, 2,  2,  2,\n\t2, 2, 2, 2, 2, 2,  2,  3,\n\t2, 2, 2, 2, 2, 2,  3,  6,\n\t2, 2, 2, 2, 2, 3,  6,  6,\n\t2, 2, 2, 2, 3, 6,  6,  6,\n\t2, 2, 2, 3, 6, 6,  6,  6,\n\t2, 2, 3, 6, 6, 6,  6,  8,\n};\n\nstatic const int quant_table_p[] = {\n\t3, 3, 3, 3, 3, 3,  3,  3,\n\t3, 3, 3, 3, 3, 3,  3,  3,\n\t3, 3, 3, 3, 3, 3,  3,  3,\n\t3, 3, 3, 3, 3, 3,  3,  6,\n\t3, 3, 3, 3, 3, 3,  6,  6,\n\t3, 3, 3, 3, 3, 6,  6,  9,\n\t3, 3, 3, 3, 6, 6,  9,  9,\n\t3, 3, 3, 6, 6, 9,  9,  10,\n};\n\nstatic void quantize_intra(s16 *coeff, s16 *de_coeff, u16 qp)\n{\n\tconst int *quant = quant_table;\n\tint i, j;\n\n\tfor (j = 0; j < 8; j++) {\n\t\tfor (i = 0; i < 8; i++, quant++, coeff++, de_coeff++) {\n\t\t\t*coeff >>= *quant;\n\t\t\tif (*coeff >= -qp && *coeff <= qp)\n\t\t\t\t*coeff = *de_coeff = 0;\n\t\t\telse\n\t\t\t\t*de_coeff = *coeff << *quant;\n\t\t}\n\t}\n}\n\nstatic void dequantize_intra(s16 *coeff)\n{\n\tconst int *quant = quant_table;\n\tint i, j;\n\n\tfor (j = 0; j < 8; j++)\n\t\tfor (i = 0; i < 8; i++, quant++, coeff++)\n\t\t\t*coeff <<= *quant;\n}\n\nstatic void quantize_inter(s16 *coeff, s16 *de_coeff, u16 qp)\n{\n\tconst int *quant = quant_table_p;\n\tint i, j;\n\n\tfor (j = 0; j < 8; j++) {\n\t\tfor (i = 0; i < 8; i++, quant++, coeff++, de_coeff++) {\n\t\t\t*coeff >>= *quant;\n\t\t\tif (*coeff >= -qp && *coeff <= qp)\n\t\t\t\t*coeff = *de_coeff = 0;\n\t\t\telse\n\t\t\t\t*de_coeff = *coeff << *quant;\n\t\t}\n\t}\n}\n\nstatic void dequantize_inter(s16 *coeff)\n{\n\tconst int *quant = quant_table_p;\n\tint i, j;\n\n\tfor (j = 0; j < 8; j++)\n\t\tfor (i = 0; i < 8; i++, quant++, coeff++)\n\t\t\t*coeff <<= *quant;\n}\n\nstatic void noinline_for_stack fwht(const u8 *block, s16 *output_block,\n\t\t\t\t    unsigned int stride,\n\t\t\t\t    unsigned int input_step, bool intra)\n{\n\t \n\ts32 workspace1[8], workspace2[8];\n\tconst u8 *tmp = block;\n\ts16 *out = output_block;\n\tint add = intra ? 256 : 0;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < 8; i++, tmp += stride, out += 8) {\n\t\tswitch (input_step) {\n\t\tcase 1:\n\t\t\tworkspace1[0]  = tmp[0] + tmp[1] - add;\n\t\t\tworkspace1[1]  = tmp[0] - tmp[1];\n\n\t\t\tworkspace1[2]  = tmp[2] + tmp[3] - add;\n\t\t\tworkspace1[3]  = tmp[2] - tmp[3];\n\n\t\t\tworkspace1[4]  = tmp[4] + tmp[5] - add;\n\t\t\tworkspace1[5]  = tmp[4] - tmp[5];\n\n\t\t\tworkspace1[6]  = tmp[6] + tmp[7] - add;\n\t\t\tworkspace1[7]  = tmp[6] - tmp[7];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tworkspace1[0]  = tmp[0] + tmp[2] - add;\n\t\t\tworkspace1[1]  = tmp[0] - tmp[2];\n\n\t\t\tworkspace1[2]  = tmp[4] + tmp[6] - add;\n\t\t\tworkspace1[3]  = tmp[4] - tmp[6];\n\n\t\t\tworkspace1[4]  = tmp[8] + tmp[10] - add;\n\t\t\tworkspace1[5]  = tmp[8] - tmp[10];\n\n\t\t\tworkspace1[6]  = tmp[12] + tmp[14] - add;\n\t\t\tworkspace1[7]  = tmp[12] - tmp[14];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tworkspace1[0]  = tmp[0] + tmp[3] - add;\n\t\t\tworkspace1[1]  = tmp[0] - tmp[3];\n\n\t\t\tworkspace1[2]  = tmp[6] + tmp[9] - add;\n\t\t\tworkspace1[3]  = tmp[6] - tmp[9];\n\n\t\t\tworkspace1[4]  = tmp[12] + tmp[15] - add;\n\t\t\tworkspace1[5]  = tmp[12] - tmp[15];\n\n\t\t\tworkspace1[6]  = tmp[18] + tmp[21] - add;\n\t\t\tworkspace1[7]  = tmp[18] - tmp[21];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tworkspace1[0]  = tmp[0] + tmp[4] - add;\n\t\t\tworkspace1[1]  = tmp[0] - tmp[4];\n\n\t\t\tworkspace1[2]  = tmp[8] + tmp[12] - add;\n\t\t\tworkspace1[3]  = tmp[8] - tmp[12];\n\n\t\t\tworkspace1[4]  = tmp[16] + tmp[20] - add;\n\t\t\tworkspace1[5]  = tmp[16] - tmp[20];\n\n\t\t\tworkspace1[6]  = tmp[24] + tmp[28] - add;\n\t\t\tworkspace1[7]  = tmp[24] - tmp[28];\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\n\t\t \n\t\tout[0] = workspace2[0] + workspace2[4];\n\t\tout[1] = workspace2[0] - workspace2[4];\n\t\tout[2] = workspace2[1] - workspace2[5];\n\t\tout[3] = workspace2[1] + workspace2[5];\n\t\tout[4] = workspace2[2] + workspace2[6];\n\t\tout[5] = workspace2[2] - workspace2[6];\n\t\tout[6] = workspace2[3] - workspace2[7];\n\t\tout[7] = workspace2[3] + workspace2[7];\n\t}\n\n\tout = output_block;\n\n\tfor (i = 0; i < 8; i++, out++) {\n\t\t \n\t\tworkspace1[0]  = out[0] + out[1 * 8];\n\t\tworkspace1[1]  = out[0] - out[1 * 8];\n\n\t\tworkspace1[2]  = out[2 * 8] + out[3 * 8];\n\t\tworkspace1[3]  = out[2 * 8] - out[3 * 8];\n\n\t\tworkspace1[4]  = out[4 * 8] + out[5 * 8];\n\t\tworkspace1[5]  = out[4 * 8] - out[5 * 8];\n\n\t\tworkspace1[6]  = out[6 * 8] + out[7 * 8];\n\t\tworkspace1[7]  = out[6 * 8] - out[7 * 8];\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\t\t \n\t\tout[0 * 8] = workspace2[0] + workspace2[4];\n\t\tout[1 * 8] = workspace2[0] - workspace2[4];\n\t\tout[2 * 8] = workspace2[1] - workspace2[5];\n\t\tout[3 * 8] = workspace2[1] + workspace2[5];\n\t\tout[4 * 8] = workspace2[2] + workspace2[6];\n\t\tout[5 * 8] = workspace2[2] - workspace2[6];\n\t\tout[6 * 8] = workspace2[3] - workspace2[7];\n\t\tout[7 * 8] = workspace2[3] + workspace2[7];\n\t}\n}\n\n \nstatic void noinline_for_stack\nfwht16(const s16 *block, s16 *output_block, int stride, int intra)\n{\n\t \n\ts32 workspace1[8], workspace2[8];\n\tconst s16 *tmp = block;\n\ts16 *out = output_block;\n\tint i;\n\n\tfor (i = 0; i < 8; i++, tmp += stride, out += 8) {\n\t\t \n\t\tworkspace1[0]  = tmp[0] + tmp[1];\n\t\tworkspace1[1]  = tmp[0] - tmp[1];\n\n\t\tworkspace1[2]  = tmp[2] + tmp[3];\n\t\tworkspace1[3]  = tmp[2] - tmp[3];\n\n\t\tworkspace1[4]  = tmp[4] + tmp[5];\n\t\tworkspace1[5]  = tmp[4] - tmp[5];\n\n\t\tworkspace1[6]  = tmp[6] + tmp[7];\n\t\tworkspace1[7]  = tmp[6] - tmp[7];\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\n\t\t \n\t\tout[0] = workspace2[0] + workspace2[4];\n\t\tout[1] = workspace2[0] - workspace2[4];\n\t\tout[2] = workspace2[1] - workspace2[5];\n\t\tout[3] = workspace2[1] + workspace2[5];\n\t\tout[4] = workspace2[2] + workspace2[6];\n\t\tout[5] = workspace2[2] - workspace2[6];\n\t\tout[6] = workspace2[3] - workspace2[7];\n\t\tout[7] = workspace2[3] + workspace2[7];\n\t}\n\n\tout = output_block;\n\n\tfor (i = 0; i < 8; i++, out++) {\n\t\t \n\t\tworkspace1[0]  = out[0] + out[1*8];\n\t\tworkspace1[1]  = out[0] - out[1*8];\n\n\t\tworkspace1[2]  = out[2*8] + out[3*8];\n\t\tworkspace1[3]  = out[2*8] - out[3*8];\n\n\t\tworkspace1[4]  = out[4*8] + out[5*8];\n\t\tworkspace1[5]  = out[4*8] - out[5*8];\n\n\t\tworkspace1[6]  = out[6*8] + out[7*8];\n\t\tworkspace1[7]  = out[6*8] - out[7*8];\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\n\t\t \n\t\tout[0*8] = workspace2[0] + workspace2[4];\n\t\tout[1*8] = workspace2[0] - workspace2[4];\n\t\tout[2*8] = workspace2[1] - workspace2[5];\n\t\tout[3*8] = workspace2[1] + workspace2[5];\n\t\tout[4*8] = workspace2[2] + workspace2[6];\n\t\tout[5*8] = workspace2[2] - workspace2[6];\n\t\tout[6*8] = workspace2[3] - workspace2[7];\n\t\tout[7*8] = workspace2[3] + workspace2[7];\n\t}\n}\n\nstatic noinline_for_stack void\nifwht(const s16 *block, s16 *output_block, int intra)\n{\n\t \n\tint workspace1[8], workspace2[8];\n\tint inter = intra ? 0 : 1;\n\tconst s16 *tmp = block;\n\ts16 *out = output_block;\n\tint i;\n\n\tfor (i = 0; i < 8; i++, tmp += 8, out += 8) {\n\t\t \n\t\tworkspace1[0]  = tmp[0] + tmp[1];\n\t\tworkspace1[1]  = tmp[0] - tmp[1];\n\n\t\tworkspace1[2]  = tmp[2] + tmp[3];\n\t\tworkspace1[3]  = tmp[2] - tmp[3];\n\n\t\tworkspace1[4]  = tmp[4] + tmp[5];\n\t\tworkspace1[5]  = tmp[4] - tmp[5];\n\n\t\tworkspace1[6]  = tmp[6] + tmp[7];\n\t\tworkspace1[7]  = tmp[6] - tmp[7];\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\n\t\t \n\t\tout[0] = workspace2[0] + workspace2[4];\n\t\tout[1] = workspace2[0] - workspace2[4];\n\t\tout[2] = workspace2[1] - workspace2[5];\n\t\tout[3] = workspace2[1] + workspace2[5];\n\t\tout[4] = workspace2[2] + workspace2[6];\n\t\tout[5] = workspace2[2] - workspace2[6];\n\t\tout[6] = workspace2[3] - workspace2[7];\n\t\tout[7] = workspace2[3] + workspace2[7];\n\t}\n\n\tout = output_block;\n\n\tfor (i = 0; i < 8; i++, out++) {\n\t\t \n\t\tworkspace1[0]  = out[0] + out[1 * 8];\n\t\tworkspace1[1]  = out[0] - out[1 * 8];\n\n\t\tworkspace1[2]  = out[2 * 8] + out[3 * 8];\n\t\tworkspace1[3]  = out[2 * 8] - out[3 * 8];\n\n\t\tworkspace1[4]  = out[4 * 8] + out[5 * 8];\n\t\tworkspace1[5]  = out[4 * 8] - out[5 * 8];\n\n\t\tworkspace1[6]  = out[6 * 8] + out[7 * 8];\n\t\tworkspace1[7]  = out[6 * 8] - out[7 * 8];\n\n\t\t \n\t\tworkspace2[0] = workspace1[0] + workspace1[2];\n\t\tworkspace2[1] = workspace1[0] - workspace1[2];\n\t\tworkspace2[2] = workspace1[1] - workspace1[3];\n\t\tworkspace2[3] = workspace1[1] + workspace1[3];\n\n\t\tworkspace2[4] = workspace1[4] + workspace1[6];\n\t\tworkspace2[5] = workspace1[4] - workspace1[6];\n\t\tworkspace2[6] = workspace1[5] - workspace1[7];\n\t\tworkspace2[7] = workspace1[5] + workspace1[7];\n\n\t\t \n\t\tif (inter) {\n\t\t\tint d;\n\n\t\t\tout[0 * 8] = workspace2[0] + workspace2[4];\n\t\t\tout[1 * 8] = workspace2[0] - workspace2[4];\n\t\t\tout[2 * 8] = workspace2[1] - workspace2[5];\n\t\t\tout[3 * 8] = workspace2[1] + workspace2[5];\n\t\t\tout[4 * 8] = workspace2[2] + workspace2[6];\n\t\t\tout[5 * 8] = workspace2[2] - workspace2[6];\n\t\t\tout[6 * 8] = workspace2[3] - workspace2[7];\n\t\t\tout[7 * 8] = workspace2[3] + workspace2[7];\n\n\t\t\tfor (d = 0; d < 8; d++)\n\t\t\t\tout[8 * d] >>= 6;\n\t\t} else {\n\t\t\tint d;\n\n\t\t\tout[0 * 8] = workspace2[0] + workspace2[4];\n\t\t\tout[1 * 8] = workspace2[0] - workspace2[4];\n\t\t\tout[2 * 8] = workspace2[1] - workspace2[5];\n\t\t\tout[3 * 8] = workspace2[1] + workspace2[5];\n\t\t\tout[4 * 8] = workspace2[2] + workspace2[6];\n\t\t\tout[5 * 8] = workspace2[2] - workspace2[6];\n\t\t\tout[6 * 8] = workspace2[3] - workspace2[7];\n\t\t\tout[7 * 8] = workspace2[3] + workspace2[7];\n\n\t\t\tfor (d = 0; d < 8; d++) {\n\t\t\t\tout[8 * d] >>= 6;\n\t\t\t\tout[8 * d] += 128;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void fill_encoder_block(const u8 *input, s16 *dst,\n\t\t\t       unsigned int stride, unsigned int input_step)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < 8; j++, input += input_step)\n\t\t\t*dst++ = *input;\n\t\tinput += stride - 8 * input_step;\n\t}\n}\n\nstatic int var_intra(const s16 *input)\n{\n\tint32_t mean = 0;\n\tint32_t ret = 0;\n\tconst s16 *tmp = input;\n\tint i;\n\n\tfor (i = 0; i < 8 * 8; i++, tmp++)\n\t\tmean += *tmp;\n\tmean /= 64;\n\ttmp = input;\n\tfor (i = 0; i < 8 * 8; i++, tmp++)\n\t\tret += (*tmp - mean) < 0 ? -(*tmp - mean) : (*tmp - mean);\n\treturn ret;\n}\n\nstatic int var_inter(const s16 *old, const s16 *new)\n{\n\tint32_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < 8 * 8; i++, old++, new++)\n\t\tret += (*old - *new) < 0 ? -(*old - *new) : (*old - *new);\n\treturn ret;\n}\n\nstatic noinline_for_stack int\ndecide_blocktype(const u8 *cur, const u8 *reference, s16 *deltablock,\n\t\t unsigned int stride, unsigned int input_step)\n{\n\ts16 tmp[64];\n\ts16 old[64];\n\ts16 *work = tmp;\n\tunsigned int k, l;\n\tint vari;\n\tint vard;\n\n\tfill_encoder_block(cur, tmp, stride, input_step);\n\tfill_encoder_block(reference, old, 8, 1);\n\tvari = var_intra(tmp);\n\n\tfor (k = 0; k < 8; k++) {\n\t\tfor (l = 0; l < 8; l++) {\n\t\t\t*deltablock = *work - *reference;\n\t\t\tdeltablock++;\n\t\t\twork++;\n\t\t\treference++;\n\t\t}\n\t}\n\tdeltablock -= 64;\n\tvard = var_inter(old, tmp);\n\treturn vari <= vard ? IBLOCK : PBLOCK;\n}\n\nstatic void fill_decoder_block(u8 *dst, const s16 *input, int stride,\n\t\t\t       unsigned int dst_step)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < 8; j++, input++, dst += dst_step) {\n\t\t\tif (*input < 0)\n\t\t\t\t*dst = 0;\n\t\t\telse if (*input > 255)\n\t\t\t\t*dst = 255;\n\t\t\telse\n\t\t\t\t*dst = *input;\n\t\t}\n\t\tdst += stride - (8 * dst_step);\n\t}\n}\n\nstatic void add_deltas(s16 *deltas, const u8 *ref, int stride,\n\t\t       unsigned int ref_step)\n{\n\tint k, l;\n\n\tfor (k = 0; k < 8; k++) {\n\t\tfor (l = 0; l < 8; l++) {\n\t\t\t*deltas += *ref;\n\t\t\tref += ref_step;\n\t\t\t \n\t\t\tif (*deltas < 0)\n\t\t\t\t*deltas = 0;\n\t\t\telse if (*deltas > 255)\n\t\t\t\t*deltas = 255;\n\t\t\tdeltas++;\n\t\t}\n\t\tref += stride - (8 * ref_step);\n\t}\n}\n\nstatic u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,\n\t\t\tstruct fwht_cframe *cf, u32 height, u32 width,\n\t\t\tu32 stride, unsigned int input_step,\n\t\t\tbool is_intra, bool next_is_intra)\n{\n\tu8 *input_start = input;\n\t__be16 *rlco_start = *rlco;\n\ts16 deltablock[64];\n\t__be16 pframe_bit = htons(PFRAME_BIT);\n\tu32 encoding = 0;\n\tunsigned int last_size = 0;\n\tunsigned int i, j;\n\n\twidth = round_up(width, 8);\n\theight = round_up(height, 8);\n\n\tfor (j = 0; j < height / 8; j++) {\n\t\tinput = input_start + j * 8 * stride;\n\t\tfor (i = 0; i < width / 8; i++) {\n\t\t\t \n\t\t\tint blocktype = IBLOCK;\n\t\t\tunsigned int size;\n\n\t\t\tif (!is_intra)\n\t\t\t\tblocktype = decide_blocktype(input, refp,\n\t\t\t\t\tdeltablock, stride, input_step);\n\t\t\tif (blocktype == IBLOCK) {\n\t\t\t\tfwht(input, cf->coeffs, stride, input_step, 1);\n\t\t\t\tquantize_intra(cf->coeffs, cf->de_coeffs,\n\t\t\t\t\t       cf->i_frame_qp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tencoding |= FWHT_FRAME_PCODED;\n\t\t\t\tfwht16(deltablock, cf->coeffs, 8, 0);\n\t\t\t\tquantize_inter(cf->coeffs, cf->de_coeffs,\n\t\t\t\t\t       cf->p_frame_qp);\n\t\t\t}\n\t\t\tif (!next_is_intra) {\n\t\t\t\tifwht(cf->de_coeffs, cf->de_fwht, blocktype);\n\n\t\t\t\tif (blocktype == PBLOCK)\n\t\t\t\t\tadd_deltas(cf->de_fwht, refp, 8, 1);\n\t\t\t\tfill_decoder_block(refp, cf->de_fwht, 8, 1);\n\t\t\t}\n\n\t\t\tinput += 8 * input_step;\n\t\t\trefp += 8 * 8;\n\n\t\t\tsize = rlc(cf->coeffs, *rlco, blocktype);\n\t\t\tif (last_size == size &&\n\t\t\t    !memcmp(*rlco + 1, *rlco - size + 1, 2 * size - 2)) {\n\t\t\t\t__be16 *last_rlco = *rlco - size;\n\t\t\t\ts16 hdr = ntohs(*last_rlco);\n\n\t\t\t\tif (!((*last_rlco ^ **rlco) & pframe_bit) &&\n\t\t\t\t    (hdr & DUPS_MASK) < DUPS_MASK)\n\t\t\t\t\t*last_rlco = htons(hdr + 2);\n\t\t\t\telse\n\t\t\t\t\t*rlco += size;\n\t\t\t} else {\n\t\t\t\t*rlco += size;\n\t\t\t}\n\t\t\tif (*rlco >= rlco_max) {\n\t\t\t\tencoding |= FWHT_FRAME_UNENCODED;\n\t\t\t\tgoto exit_loop;\n\t\t\t}\n\t\t\tlast_size = size;\n\t\t}\n\t}\n\nexit_loop:\n\tif (encoding & FWHT_FRAME_UNENCODED) {\n\t\tu8 *out = (u8 *)rlco_start;\n\t\tu8 *p;\n\n\t\tinput = input_start;\n\t\t \n\t\tfor (j = 0; j < height; j++) {\n\t\t\tfor (i = 0, p = input; i < width; i++, p += input_step)\n\t\t\t\t*out++ = (*p == 0xff) ? 0xfe : *p;\n\t\t\tinput += stride;\n\t\t}\n\t\t*rlco = (__be16 *)out;\n\t\tencoding &= ~FWHT_FRAME_PCODED;\n\t}\n\treturn encoding;\n}\n\nu32 fwht_encode_frame(struct fwht_raw_frame *frm,\n\t\t      struct fwht_raw_frame *ref_frm,\n\t\t      struct fwht_cframe *cf,\n\t\t      bool is_intra, bool next_is_intra,\n\t\t      unsigned int width, unsigned int height,\n\t\t      unsigned int stride, unsigned int chroma_stride)\n{\n\tunsigned int size = height * width;\n\t__be16 *rlco = cf->rlc_data;\n\t__be16 *rlco_max;\n\tu32 encoding;\n\n\trlco_max = rlco + size / 2 - 256;\n\tencoding = encode_plane(frm->luma, ref_frm->luma, &rlco, rlco_max, cf,\n\t\t\t\theight, width, stride,\n\t\t\t\tfrm->luma_alpha_step, is_intra, next_is_intra);\n\tif (encoding & FWHT_FRAME_UNENCODED)\n\t\tencoding |= FWHT_LUMA_UNENCODED;\n\tencoding &= ~FWHT_FRAME_UNENCODED;\n\n\tif (frm->components_num >= 3) {\n\t\tu32 chroma_h = height / frm->height_div;\n\t\tu32 chroma_w = width / frm->width_div;\n\t\tunsigned int chroma_size = chroma_h * chroma_w;\n\n\t\trlco_max = rlco + chroma_size / 2 - 256;\n\t\tencoding |= encode_plane(frm->cb, ref_frm->cb, &rlco, rlco_max,\n\t\t\t\t\t cf, chroma_h, chroma_w,\n\t\t\t\t\t chroma_stride, frm->chroma_step,\n\t\t\t\t\t is_intra, next_is_intra);\n\t\tif (encoding & FWHT_FRAME_UNENCODED)\n\t\t\tencoding |= FWHT_CB_UNENCODED;\n\t\tencoding &= ~FWHT_FRAME_UNENCODED;\n\t\trlco_max = rlco + chroma_size / 2 - 256;\n\t\tencoding |= encode_plane(frm->cr, ref_frm->cr, &rlco, rlco_max,\n\t\t\t\t\t cf, chroma_h, chroma_w,\n\t\t\t\t\t chroma_stride, frm->chroma_step,\n\t\t\t\t\t is_intra, next_is_intra);\n\t\tif (encoding & FWHT_FRAME_UNENCODED)\n\t\t\tencoding |= FWHT_CR_UNENCODED;\n\t\tencoding &= ~FWHT_FRAME_UNENCODED;\n\t}\n\n\tif (frm->components_num == 4) {\n\t\trlco_max = rlco + size / 2 - 256;\n\t\tencoding |= encode_plane(frm->alpha, ref_frm->alpha, &rlco,\n\t\t\t\t\t rlco_max, cf, height, width,\n\t\t\t\t\t stride, frm->luma_alpha_step,\n\t\t\t\t\t is_intra, next_is_intra);\n\t\tif (encoding & FWHT_FRAME_UNENCODED)\n\t\t\tencoding |= FWHT_ALPHA_UNENCODED;\n\t\tencoding &= ~FWHT_FRAME_UNENCODED;\n\t}\n\n\tcf->size = (rlco - cf->rlc_data) * sizeof(*rlco);\n\treturn encoding;\n}\n\nstatic bool decode_plane(struct fwht_cframe *cf, const __be16 **rlco,\n\t\t\t u32 height, u32 width, const u8 *ref, u32 ref_stride,\n\t\t\t unsigned int ref_step, u8 *dst,\n\t\t\t unsigned int dst_stride, unsigned int dst_step,\n\t\t\t bool uncompressed, const __be16 *end_of_rlco_buf)\n{\n\tunsigned int copies = 0;\n\ts16 copy[8 * 8];\n\tu16 stat;\n\tunsigned int i, j;\n\tbool is_intra = !ref;\n\n\twidth = round_up(width, 8);\n\theight = round_up(height, 8);\n\n\tif (uncompressed) {\n\t\tint i;\n\n\t\tif (end_of_rlco_buf + 1 < *rlco + width * height / 2)\n\t\t\treturn false;\n\t\tfor (i = 0; i < height; i++) {\n\t\t\tmemcpy(dst, *rlco, width);\n\t\t\tdst += dst_stride;\n\t\t\t*rlco += width / 2;\n\t\t}\n\t\treturn true;\n\t}\n\n\t \n\tfor (j = 0; j < height / 8; j++) {\n\t\tfor (i = 0; i < width / 8; i++) {\n\t\t\tconst u8 *refp = ref + j * 8 * ref_stride +\n\t\t\t\ti * 8 * ref_step;\n\t\t\tu8 *dstp = dst + j * 8 * dst_stride + i * 8 * dst_step;\n\n\t\t\tif (copies) {\n\t\t\t\tmemcpy(cf->de_fwht, copy, sizeof(copy));\n\t\t\t\tif ((stat & PFRAME_BIT) && !is_intra)\n\t\t\t\t\tadd_deltas(cf->de_fwht, refp,\n\t\t\t\t\t\t   ref_stride, ref_step);\n\t\t\t\tfill_decoder_block(dstp, cf->de_fwht,\n\t\t\t\t\t\t   dst_stride, dst_step);\n\t\t\t\tcopies--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstat = derlc(rlco, cf->coeffs, end_of_rlco_buf);\n\t\t\tif (stat & OVERFLOW_BIT)\n\t\t\t\treturn false;\n\t\t\tif ((stat & PFRAME_BIT) && !is_intra)\n\t\t\t\tdequantize_inter(cf->coeffs);\n\t\t\telse\n\t\t\t\tdequantize_intra(cf->coeffs);\n\n\t\t\tifwht(cf->coeffs, cf->de_fwht,\n\t\t\t      ((stat & PFRAME_BIT) && !is_intra) ? 0 : 1);\n\n\t\t\tcopies = (stat & DUPS_MASK) >> 1;\n\t\t\tif (copies)\n\t\t\t\tmemcpy(copy, cf->de_fwht, sizeof(copy));\n\t\t\tif ((stat & PFRAME_BIT) && !is_intra)\n\t\t\t\tadd_deltas(cf->de_fwht, refp,\n\t\t\t\t\t   ref_stride, ref_step);\n\t\t\tfill_decoder_block(dstp, cf->de_fwht, dst_stride,\n\t\t\t\t\t   dst_step);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool fwht_decode_frame(struct fwht_cframe *cf, u32 hdr_flags,\n\t\t       unsigned int components_num, unsigned int width,\n\t\t       unsigned int height, const struct fwht_raw_frame *ref,\n\t\t       unsigned int ref_stride, unsigned int ref_chroma_stride,\n\t\t       struct fwht_raw_frame *dst, unsigned int dst_stride,\n\t\t       unsigned int dst_chroma_stride)\n{\n\tconst __be16 *rlco = cf->rlc_data;\n\tconst __be16 *end_of_rlco_buf = cf->rlc_data +\n\t\t\t(cf->size / sizeof(*rlco)) - 1;\n\n\tif (!decode_plane(cf, &rlco, height, width, ref->luma, ref_stride,\n\t\t\t  ref->luma_alpha_step, dst->luma, dst_stride,\n\t\t\t  dst->luma_alpha_step,\n\t\t\t  hdr_flags & V4L2_FWHT_FL_LUMA_IS_UNCOMPRESSED,\n\t\t\t  end_of_rlco_buf))\n\t\treturn false;\n\n\tif (components_num >= 3) {\n\t\tu32 h = height;\n\t\tu32 w = width;\n\n\t\tif (!(hdr_flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT))\n\t\t\th /= 2;\n\t\tif (!(hdr_flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH))\n\t\t\tw /= 2;\n\n\t\tif (!decode_plane(cf, &rlco, h, w, ref->cb, ref_chroma_stride,\n\t\t\t\t  ref->chroma_step, dst->cb, dst_chroma_stride,\n\t\t\t\t  dst->chroma_step,\n\t\t\t\t  hdr_flags & V4L2_FWHT_FL_CB_IS_UNCOMPRESSED,\n\t\t\t\t  end_of_rlco_buf))\n\t\t\treturn false;\n\t\tif (!decode_plane(cf, &rlco, h, w, ref->cr, ref_chroma_stride,\n\t\t\t\t  ref->chroma_step, dst->cr, dst_chroma_stride,\n\t\t\t\t  dst->chroma_step,\n\t\t\t\t  hdr_flags & V4L2_FWHT_FL_CR_IS_UNCOMPRESSED,\n\t\t\t\t  end_of_rlco_buf))\n\t\t\treturn false;\n\t}\n\n\tif (components_num == 4)\n\t\tif (!decode_plane(cf, &rlco, height, width, ref->alpha, ref_stride,\n\t\t\t\t  ref->luma_alpha_step, dst->alpha, dst_stride,\n\t\t\t\t  dst->luma_alpha_step,\n\t\t\t\t  hdr_flags & V4L2_FWHT_FL_ALPHA_IS_UNCOMPRESSED,\n\t\t\t\t  end_of_rlco_buf))\n\t\t\treturn false;\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}