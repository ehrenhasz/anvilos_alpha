{
  "module_name": "codec-v4l2-fwht.c",
  "hash_id": "a8d0802fa521422602923f2550bdad518cc1b9f33d1936a8ada64f2fc470a076",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vicodec/codec-v4l2-fwht.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n#include \"codec-v4l2-fwht.h\"\n\nstatic const struct v4l2_fwht_pixfmt_info v4l2_fwht_pixfmts[] = {\n\t{ V4L2_PIX_FMT_YUV420,  1, 3, 2, 1, 1, 2, 2, 3, 3, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_YVU420,  1, 3, 2, 1, 1, 2, 2, 3, 3, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_YUV422P, 1, 2, 1, 1, 1, 2, 1, 3, 3, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV12,    1, 3, 2, 1, 2, 2, 2, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV21,    1, 3, 2, 1, 2, 2, 2, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV16,    1, 2, 1, 1, 2, 2, 1, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV61,    1, 2, 1, 1, 2, 2, 1, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV24,    1, 3, 1, 1, 2, 1, 1, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_NV42,    1, 3, 1, 1, 2, 1, 1, 3, 2, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_YUYV,    2, 2, 1, 2, 4, 2, 1, 3, 1, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_YVYU,    2, 2, 1, 2, 4, 2, 1, 3, 1, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_UYVY,    2, 2, 1, 2, 4, 2, 1, 3, 1, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_VYUY,    2, 2, 1, 2, 4, 2, 1, 3, 1, V4L2_FWHT_FL_PIXENC_YUV},\n\t{ V4L2_PIX_FMT_BGR24,   3, 3, 1, 3, 3, 1, 1, 3, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_RGB24,   3, 3, 1, 3, 3, 1, 1, 3, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_HSV24,   3, 3, 1, 3, 3, 1, 1, 3, 1, V4L2_FWHT_FL_PIXENC_HSV},\n\t{ V4L2_PIX_FMT_BGR32,   4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_XBGR32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_ABGR32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_RGB32,   4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_XRGB32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_ARGB32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_BGRX32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_BGRA32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_RGBX32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_RGBA32,  4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_RGB},\n\t{ V4L2_PIX_FMT_HSV32,   4, 4, 1, 4, 4, 1, 1, 4, 1, V4L2_FWHT_FL_PIXENC_HSV},\n\t{ V4L2_PIX_FMT_GREY,    1, 1, 1, 1, 0, 1, 1, 1, 1, V4L2_FWHT_FL_PIXENC_RGB},\n};\n\nbool v4l2_fwht_validate_fmt(const struct v4l2_fwht_pixfmt_info *info,\n\t\t\t    u32 width_div, u32 height_div, u32 components_num,\n\t\t\t    u32 pixenc)\n{\n\tif (info->width_div == width_div &&\n\t    info->height_div == height_div &&\n\t    (!pixenc || info->pixenc == pixenc) &&\n\t    info->components_num == components_num)\n\t\treturn true;\n\treturn false;\n}\n\nconst struct v4l2_fwht_pixfmt_info *v4l2_fwht_find_nth_fmt(u32 width_div,\n\t\t\t\t\t\t\t  u32 height_div,\n\t\t\t\t\t\t\t  u32 components_num,\n\t\t\t\t\t\t\t  u32 pixenc,\n\t\t\t\t\t\t\t  unsigned int start_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(v4l2_fwht_pixfmts); i++) {\n\t\tbool is_valid = v4l2_fwht_validate_fmt(&v4l2_fwht_pixfmts[i],\n\t\t\t\t\t\t       width_div, height_div,\n\t\t\t\t\t\t       components_num, pixenc);\n\t\tif (is_valid) {\n\t\t\tif (start_idx == 0)\n\t\t\t\treturn v4l2_fwht_pixfmts + i;\n\t\t\tstart_idx--;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nconst struct v4l2_fwht_pixfmt_info *v4l2_fwht_find_pixfmt(u32 pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(v4l2_fwht_pixfmts); i++)\n\t\tif (v4l2_fwht_pixfmts[i].id == pixelformat)\n\t\t\treturn v4l2_fwht_pixfmts + i;\n\treturn NULL;\n}\n\nconst struct v4l2_fwht_pixfmt_info *v4l2_fwht_get_pixfmt(u32 idx)\n{\n\tif (idx >= ARRAY_SIZE(v4l2_fwht_pixfmts))\n\t\treturn NULL;\n\treturn v4l2_fwht_pixfmts + idx;\n}\n\nstatic int prepare_raw_frame(struct fwht_raw_frame *rf,\n\t\t\t const struct v4l2_fwht_pixfmt_info *info, u8 *buf,\n\t\t\t unsigned int size)\n{\n\trf->luma = buf;\n\trf->width_div = info->width_div;\n\trf->height_div = info->height_div;\n\trf->luma_alpha_step = info->luma_alpha_step;\n\trf->chroma_step = info->chroma_step;\n\trf->alpha = NULL;\n\trf->components_num = info->components_num;\n\n\t \n\tif (!buf) {\n\t\trf->luma = NULL;\n\t\trf->cb = NULL;\n\t\trf->cr = NULL;\n\t\trf->alpha = NULL;\n\t\treturn 0;\n\t}\n\tswitch (info->id) {\n\tcase V4L2_PIX_FMT_GREY:\n\t\trf->cb = NULL;\n\t\trf->cr = NULL;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\trf->cb = rf->luma + size;\n\t\trf->cr = rf->cb + size / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVU420:\n\t\trf->cr = rf->luma + size;\n\t\trf->cb = rf->cr + size / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\trf->cb = rf->luma + size;\n\t\trf->cr = rf->cb + size / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV24:\n\t\trf->cb = rf->luma + size;\n\t\trf->cr = rf->cb + 1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV42:\n\t\trf->cr = rf->luma + size;\n\t\trf->cb = rf->cr + 1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\trf->cb = rf->luma + 1;\n\t\trf->cr = rf->cb + 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\trf->cr = rf->luma + 1;\n\t\trf->cb = rf->cr + 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\trf->cb = rf->luma;\n\t\trf->cr = rf->cb + 2;\n\t\trf->luma++;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\trf->cr = rf->luma;\n\t\trf->cb = rf->cr + 2;\n\t\trf->luma++;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_HSV24:\n\t\trf->cr = rf->luma;\n\t\trf->cb = rf->cr + 2;\n\t\trf->luma++;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\t\trf->cb = rf->luma;\n\t\trf->cr = rf->cb + 2;\n\t\trf->luma++;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_XRGB32:\n\tcase V4L2_PIX_FMT_HSV32:\n\tcase V4L2_PIX_FMT_ARGB32:\n\t\trf->alpha = rf->luma;\n\t\trf->cr = rf->luma + 1;\n\t\trf->cb = rf->cr + 2;\n\t\trf->luma += 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_ABGR32:\n\t\trf->cb = rf->luma;\n\t\trf->cr = rf->cb + 2;\n\t\trf->luma++;\n\t\trf->alpha = rf->cr + 1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGRX32:\n\tcase V4L2_PIX_FMT_BGRA32:\n\t\trf->alpha = rf->luma;\n\t\trf->cb = rf->luma + 1;\n\t\trf->cr = rf->cb + 2;\n\t\trf->luma += 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGBX32:\n\tcase V4L2_PIX_FMT_RGBA32:\n\t\trf->alpha = rf->luma + 3;\n\t\trf->cr = rf->luma;\n\t\trf->cb = rf->cr + 2;\n\t\trf->luma++;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)\n{\n\tunsigned int size = state->stride * state->coded_height;\n\tunsigned int chroma_stride = state->stride;\n\tconst struct v4l2_fwht_pixfmt_info *info = state->info;\n\tstruct fwht_cframe_hdr *p_hdr;\n\tstruct fwht_cframe cf;\n\tstruct fwht_raw_frame rf;\n\tu32 encoding;\n\tu32 flags = 0;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tif (prepare_raw_frame(&rf, info, p_in, size))\n\t\treturn -EINVAL;\n\n\tif (info->planes_num == 3)\n\t\tchroma_stride /= 2;\n\n\tif (info->id == V4L2_PIX_FMT_NV24 ||\n\t    info->id == V4L2_PIX_FMT_NV42)\n\t\tchroma_stride *= 2;\n\n\tcf.i_frame_qp = state->i_frame_qp;\n\tcf.p_frame_qp = state->p_frame_qp;\n\tcf.rlc_data = (__be16 *)(p_out + sizeof(*p_hdr));\n\n\tencoding = fwht_encode_frame(&rf, &state->ref_frame, &cf,\n\t\t\t\t     !state->gop_cnt,\n\t\t\t\t     state->gop_cnt == state->gop_size - 1,\n\t\t\t\t     state->visible_width,\n\t\t\t\t     state->visible_height,\n\t\t\t\t     state->stride, chroma_stride);\n\tif (!(encoding & FWHT_FRAME_PCODED))\n\t\tstate->gop_cnt = 0;\n\tif (++state->gop_cnt >= state->gop_size)\n\t\tstate->gop_cnt = 0;\n\n\tp_hdr = (struct fwht_cframe_hdr *)p_out;\n\tp_hdr->magic1 = FWHT_MAGIC1;\n\tp_hdr->magic2 = FWHT_MAGIC2;\n\tp_hdr->version = htonl(V4L2_FWHT_VERSION);\n\tp_hdr->width = htonl(state->visible_width);\n\tp_hdr->height = htonl(state->visible_height);\n\tflags |= (info->components_num - 1) << V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET;\n\tflags |= info->pixenc;\n\tif (encoding & FWHT_LUMA_UNENCODED)\n\t\tflags |= V4L2_FWHT_FL_LUMA_IS_UNCOMPRESSED;\n\tif (encoding & FWHT_CB_UNENCODED)\n\t\tflags |= V4L2_FWHT_FL_CB_IS_UNCOMPRESSED;\n\tif (encoding & FWHT_CR_UNENCODED)\n\t\tflags |= V4L2_FWHT_FL_CR_IS_UNCOMPRESSED;\n\tif (encoding & FWHT_ALPHA_UNENCODED)\n\t\tflags |= V4L2_FWHT_FL_ALPHA_IS_UNCOMPRESSED;\n\tif (!(encoding & FWHT_FRAME_PCODED))\n\t\tflags |= V4L2_FWHT_FL_I_FRAME;\n\tif (rf.height_div == 1)\n\t\tflags |= V4L2_FWHT_FL_CHROMA_FULL_HEIGHT;\n\tif (rf.width_div == 1)\n\t\tflags |= V4L2_FWHT_FL_CHROMA_FULL_WIDTH;\n\tp_hdr->flags = htonl(flags);\n\tp_hdr->colorspace = htonl(state->colorspace);\n\tp_hdr->xfer_func = htonl(state->xfer_func);\n\tp_hdr->ycbcr_enc = htonl(state->ycbcr_enc);\n\tp_hdr->quantization = htonl(state->quantization);\n\tp_hdr->size = htonl(cf.size);\n\treturn cf.size + sizeof(*p_hdr);\n}\n\nint v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)\n{\n\tu32 flags;\n\tstruct fwht_cframe cf;\n\tunsigned int components_num = 3;\n\tunsigned int version;\n\tconst struct v4l2_fwht_pixfmt_info *info;\n\tunsigned int hdr_width_div, hdr_height_div;\n\tstruct fwht_raw_frame dst_rf;\n\tunsigned int dst_chroma_stride = state->stride;\n\tunsigned int ref_chroma_stride = state->ref_stride;\n\tunsigned int dst_size = state->stride * state->coded_height;\n\tunsigned int ref_size;\n\n\tif (!state->info)\n\t\treturn -EINVAL;\n\n\tinfo = state->info;\n\n\tversion = ntohl(state->header.version);\n\tif (!version || version > V4L2_FWHT_VERSION) {\n\t\tpr_err(\"version %d is not supported, current version is %d\\n\",\n\t\t       version, V4L2_FWHT_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->header.magic1 != FWHT_MAGIC1 ||\n\t    state->header.magic2 != FWHT_MAGIC2)\n\t\treturn -EINVAL;\n\n\t \n\tif (ntohl(state->header.width)  != state->visible_width ||\n\t    ntohl(state->header.height) != state->visible_height)\n\t\treturn -EINVAL;\n\n\tflags = ntohl(state->header.flags);\n\n\tif (version >= 2) {\n\t\tif ((flags & V4L2_FWHT_FL_PIXENC_MSK) != info->pixenc)\n\t\t\treturn -EINVAL;\n\t\tcomponents_num = 1 + ((flags & V4L2_FWHT_FL_COMPONENTS_NUM_MSK) >>\n\t\t\t\tV4L2_FWHT_FL_COMPONENTS_NUM_OFFSET);\n\t}\n\n\tif (components_num != info->components_num)\n\t\treturn -EINVAL;\n\n\tstate->colorspace = ntohl(state->header.colorspace);\n\tstate->xfer_func = ntohl(state->header.xfer_func);\n\tstate->ycbcr_enc = ntohl(state->header.ycbcr_enc);\n\tstate->quantization = ntohl(state->header.quantization);\n\tcf.rlc_data = (__be16 *)p_in;\n\tcf.size = ntohl(state->header.size);\n\n\thdr_width_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_WIDTH) ? 1 : 2;\n\thdr_height_div = (flags & V4L2_FWHT_FL_CHROMA_FULL_HEIGHT) ? 1 : 2;\n\tif (hdr_width_div != info->width_div ||\n\t    hdr_height_div != info->height_div)\n\t\treturn -EINVAL;\n\n\tif (prepare_raw_frame(&dst_rf, info, p_out, dst_size))\n\t\treturn -EINVAL;\n\tif (info->planes_num == 3) {\n\t\tdst_chroma_stride /= 2;\n\t\tref_chroma_stride /= 2;\n\t}\n\tif (info->id == V4L2_PIX_FMT_NV24 ||\n\t    info->id == V4L2_PIX_FMT_NV42) {\n\t\tdst_chroma_stride *= 2;\n\t\tref_chroma_stride *= 2;\n\t}\n\n\n\tref_size = state->ref_stride * state->coded_height;\n\n\tif (prepare_raw_frame(&state->ref_frame, info, state->ref_frame.buf,\n\t\t\t      ref_size))\n\t\treturn -EINVAL;\n\n\tif (!fwht_decode_frame(&cf, flags, components_num,\n\t\t\tstate->visible_width, state->visible_height,\n\t\t\t&state->ref_frame, state->ref_stride, ref_chroma_stride,\n\t\t\t&dst_rf, state->stride, dst_chroma_stride))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}