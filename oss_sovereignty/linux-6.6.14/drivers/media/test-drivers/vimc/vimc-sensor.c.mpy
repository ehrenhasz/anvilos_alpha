{
  "module_name": "vimc-sensor.c",
  "hash_id": "b949bd1d468c1bf43a86f6ab0204eb186216b8674b42b08bd15ebe1d6b9efe9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-sensor.c",
  "human_readable_source": "\n \n\n#include <linux/v4l2-mediabus.h>\n#include <linux/vmalloc.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-subdev.h>\n#include <media/tpg/v4l2-tpg.h>\n\n#include \"vimc-common.h\"\n\nenum vimc_sensor_osd_mode {\n\tVIMC_SENSOR_OSD_SHOW_ALL = 0,\n\tVIMC_SENSOR_OSD_SHOW_COUNTERS = 1,\n\tVIMC_SENSOR_OSD_SHOW_NONE = 2\n};\n\nstruct vimc_sensor_device {\n\tstruct vimc_ent_device ved;\n\tstruct v4l2_subdev sd;\n\tstruct tpg_data tpg;\n\tu8 *frame;\n\tenum vimc_sensor_osd_mode osd_value;\n\tu64 start_stream_ts;\n\t \n\tstruct v4l2_mbus_framefmt mbus_format;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct media_pad pad;\n};\n\nstatic const struct v4l2_mbus_framefmt fmt_default = {\n\t.width = 640,\n\t.height = 480,\n\t.code = MEDIA_BUS_FMT_RGB888_1X24,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n};\n\nstatic int vimc_sensor_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\tstruct v4l2_mbus_framefmt *mf;\n\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, i);\n\t\t*mf = fmt_default;\n\t}\n\n\treturn 0;\n}\n\nstatic int vimc_sensor_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tu32 mbus_code = vimc_mbus_code_by_index(code->index);\n\n\tif (!mbus_code)\n\t\treturn -EINVAL;\n\n\tcode->code = mbus_code;\n\n\treturn 0;\n}\n\nstatic int vimc_sensor_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct vimc_pix_map *vpix;\n\n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\t \n\tvpix = vimc_pix_map_by_code(fse->code);\n\tif (!vpix)\n\t\treturn -EINVAL;\n\n\tfse->min_width = VIMC_FRAME_MIN_WIDTH;\n\tfse->max_width = VIMC_FRAME_MAX_WIDTH;\n\tfse->min_height = VIMC_FRAME_MIN_HEIGHT;\n\tfse->max_height = VIMC_FRAME_MAX_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int vimc_sensor_get_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct vimc_sensor_device *vsensor =\n\t\t\t\tcontainer_of(sd, struct vimc_sensor_device, sd);\n\n\tfmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?\n\t\t      *v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) :\n\t\t      vsensor->mbus_format;\n\n\treturn 0;\n}\n\nstatic void vimc_sensor_tpg_s_format(struct vimc_sensor_device *vsensor)\n{\n\tconst struct vimc_pix_map *vpix =\n\t\t\t\tvimc_pix_map_by_code(vsensor->mbus_format.code);\n\n\ttpg_reset_source(&vsensor->tpg, vsensor->mbus_format.width,\n\t\t\t vsensor->mbus_format.height, vsensor->mbus_format.field);\n\ttpg_s_bytesperline(&vsensor->tpg, 0, vsensor->mbus_format.width * vpix->bpp);\n\ttpg_s_buf_height(&vsensor->tpg, vsensor->mbus_format.height);\n\ttpg_s_fourcc(&vsensor->tpg, vpix->pixelformat);\n\t \n\ttpg_s_field(&vsensor->tpg, vsensor->mbus_format.field, false);\n\ttpg_s_colorspace(&vsensor->tpg, vsensor->mbus_format.colorspace);\n\ttpg_s_ycbcr_enc(&vsensor->tpg, vsensor->mbus_format.ycbcr_enc);\n\ttpg_s_quantization(&vsensor->tpg, vsensor->mbus_format.quantization);\n\ttpg_s_xfer_func(&vsensor->tpg, vsensor->mbus_format.xfer_func);\n}\n\nstatic void vimc_sensor_adjust_fmt(struct v4l2_mbus_framefmt *fmt)\n{\n\tconst struct vimc_pix_map *vpix;\n\n\t \n\tvpix = vimc_pix_map_by_code(fmt->code);\n\tif (!vpix)\n\t\tfmt->code = fmt_default.code;\n\n\tfmt->width = clamp_t(u32, fmt->width, VIMC_FRAME_MIN_WIDTH,\n\t\t\t     VIMC_FRAME_MAX_WIDTH) & ~1;\n\tfmt->height = clamp_t(u32, fmt->height, VIMC_FRAME_MIN_HEIGHT,\n\t\t\t      VIMC_FRAME_MAX_HEIGHT) & ~1;\n\n\t \n\tif (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)\n\t\tfmt->field = fmt_default.field;\n\n\tvimc_colorimetry_clamp(fmt);\n}\n\nstatic int vimc_sensor_set_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct vimc_sensor_device *vsensor = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t \n\t\tif (vsensor->frame)\n\t\t\treturn -EBUSY;\n\n\t\tmf = &vsensor->mbus_format;\n\t} else {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t}\n\n\t \n\tvimc_sensor_adjust_fmt(&fmt->format);\n\n\tdev_dbg(vsensor->ved.dev, \"%s: format update: \"\n\t\t\"old:%dx%d (0x%x, %d, %d, %d, %d) \"\n\t\t\"new:%dx%d (0x%x, %d, %d, %d, %d)\\n\", vsensor->sd.name,\n\t\t \n\t\tmf->width, mf->height, mf->code,\n\t\tmf->colorspace,\tmf->quantization,\n\t\tmf->xfer_func, mf->ycbcr_enc,\n\t\t \n\t\tfmt->format.width, fmt->format.height, fmt->format.code,\n\t\tfmt->format.colorspace, fmt->format.quantization,\n\t\tfmt->format.xfer_func, fmt->format.ycbcr_enc);\n\n\t*mf = fmt->format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops vimc_sensor_pad_ops = {\n\t.init_cfg\t\t= vimc_sensor_init_cfg,\n\t.enum_mbus_code\t\t= vimc_sensor_enum_mbus_code,\n\t.enum_frame_size\t= vimc_sensor_enum_frame_size,\n\t.get_fmt\t\t= vimc_sensor_get_fmt,\n\t.set_fmt\t\t= vimc_sensor_set_fmt,\n};\n\nstatic void *vimc_sensor_process_frame(struct vimc_ent_device *ved,\n\t\t\t\t       const void *sink_frame)\n{\n\tstruct vimc_sensor_device *vsensor =\n\t\tcontainer_of(ved, struct vimc_sensor_device, ved);\n\n\tconst unsigned int line_height = 16;\n\tu8 *basep[TPG_MAX_PLANES][2];\n\tunsigned int line = 1;\n\tchar str[100];\n\n\ttpg_fill_plane_buffer(&vsensor->tpg, 0, 0, vsensor->frame);\n\ttpg_calc_text_basep(&vsensor->tpg, basep, 0, vsensor->frame);\n\tswitch (vsensor->osd_value) {\n\tcase VIMC_SENSOR_OSD_SHOW_ALL: {\n\t\tconst char *order = tpg_g_color_order(&vsensor->tpg);\n\n\t\ttpg_gen_text(&vsensor->tpg, basep, line++ * line_height,\n\t\t\t     16, order);\n\t\tsnprintf(str, sizeof(str),\n\t\t\t \"brightness %3d, contrast %3d, saturation %3d, hue %d \",\n\t\t\t vsensor->tpg.brightness,\n\t\t\t vsensor->tpg.contrast,\n\t\t\t vsensor->tpg.saturation,\n\t\t\t vsensor->tpg.hue);\n\t\ttpg_gen_text(&vsensor->tpg, basep, line++ * line_height, 16, str);\n\t\tsnprintf(str, sizeof(str), \"sensor size: %dx%d\",\n\t\t\t vsensor->mbus_format.width,\n\t\t\t vsensor->mbus_format.height);\n\t\ttpg_gen_text(&vsensor->tpg, basep, line++ * line_height, 16, str);\n\t\tfallthrough;\n\t}\n\tcase VIMC_SENSOR_OSD_SHOW_COUNTERS: {\n\t\tunsigned int ms;\n\n\t\tms = div_u64(ktime_get_ns() - vsensor->start_stream_ts, 1000000);\n\t\tsnprintf(str, sizeof(str), \"%02d:%02d:%02d:%03d\",\n\t\t\t (ms / (60 * 60 * 1000)) % 24,\n\t\t\t (ms / (60 * 1000)) % 60,\n\t\t\t (ms / 1000) % 60,\n\t\t\t ms % 1000);\n\t\ttpg_gen_text(&vsensor->tpg, basep, line++ * line_height, 16, str);\n\t\tbreak;\n\t}\n\tcase VIMC_SENSOR_OSD_SHOW_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn vsensor->frame;\n}\n\nstatic int vimc_sensor_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vimc_sensor_device *vsensor =\n\t\t\t\tcontainer_of(sd, struct vimc_sensor_device, sd);\n\n\tif (enable) {\n\t\tconst struct vimc_pix_map *vpix;\n\t\tunsigned int frame_size;\n\n\t\tvsensor->start_stream_ts = ktime_get_ns();\n\n\t\t \n\t\tvpix = vimc_pix_map_by_code(vsensor->mbus_format.code);\n\t\tframe_size = vsensor->mbus_format.width * vpix->bpp *\n\t\t\t     vsensor->mbus_format.height;\n\n\t\t \n\t\tvsensor->frame = vmalloc(frame_size);\n\t\tif (!vsensor->frame)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tvimc_sensor_tpg_s_format(vsensor);\n\n\t} else {\n\n\t\tvfree(vsensor->frame);\n\t\tvsensor->frame = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops vimc_sensor_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops vimc_sensor_video_ops = {\n\t.s_stream = vimc_sensor_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops vimc_sensor_ops = {\n\t.core = &vimc_sensor_core_ops,\n\t.pad = &vimc_sensor_pad_ops,\n\t.video = &vimc_sensor_video_ops,\n};\n\nstatic int vimc_sensor_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vimc_sensor_device *vsensor =\n\t\tcontainer_of(ctrl->handler, struct vimc_sensor_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase VIMC_CID_TEST_PATTERN:\n\t\ttpg_s_pattern(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\ttpg_s_hflip(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\ttpg_s_vflip(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BRIGHTNESS:\n\t\ttpg_s_brightness(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\ttpg_s_contrast(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\ttpg_s_hue(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\ttpg_s_saturation(&vsensor->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIMC_CID_OSD_TEXT_MODE:\n\t\tvsensor->osd_value = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vimc_sensor_ctrl_ops = {\n\t.s_ctrl = vimc_sensor_s_ctrl,\n};\n\nstatic void vimc_sensor_release(struct vimc_ent_device *ved)\n{\n\tstruct vimc_sensor_device *vsensor =\n\t\tcontainer_of(ved, struct vimc_sensor_device, ved);\n\n\tv4l2_ctrl_handler_free(&vsensor->hdl);\n\ttpg_free(&vsensor->tpg);\n\tmedia_entity_cleanup(vsensor->ved.ent);\n\tkfree(vsensor);\n}\n\n \nstatic const struct v4l2_ctrl_config vimc_sensor_ctrl_class = {\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_WRITE_ONLY,\n\t.id = VIMC_CID_VIMC_CLASS,\n\t.name = \"VIMC Controls\",\n\t.type = V4L2_CTRL_TYPE_CTRL_CLASS,\n};\n\nstatic const struct v4l2_ctrl_config vimc_sensor_ctrl_test_pattern = {\n\t.ops = &vimc_sensor_ctrl_ops,\n\t.id = VIMC_CID_TEST_PATTERN,\n\t.name = \"Test Pattern\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = TPG_PAT_NOISE,\n\t.qmenu = tpg_pattern_strings,\n};\n\nstatic const char * const vimc_ctrl_osd_mode_strings[] = {\n\t\"All\",\n\t\"Counters Only\",\n\t\"None\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vimc_sensor_ctrl_osd_mode = {\n\t.ops = &vimc_sensor_ctrl_ops,\n\t.id = VIMC_CID_OSD_TEXT_MODE,\n\t.name = \"Show Information\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vimc_ctrl_osd_mode_strings) - 2,\n\t.qmenu = vimc_ctrl_osd_mode_strings,\n};\n\nstatic struct vimc_ent_device *vimc_sensor_add(struct vimc_device *vimc,\n\t\t\t\t\t       const char *vcfg_name)\n{\n\tstruct v4l2_device *v4l2_dev = &vimc->v4l2_dev;\n\tstruct vimc_sensor_device *vsensor;\n\tint ret;\n\n\t \n\tvsensor = kzalloc(sizeof(*vsensor), GFP_KERNEL);\n\tif (!vsensor)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tv4l2_ctrl_handler_init(&vsensor->hdl, 4);\n\n\tv4l2_ctrl_new_custom(&vsensor->hdl, &vimc_sensor_ctrl_class, NULL);\n\tv4l2_ctrl_new_custom(&vsensor->hdl, &vimc_sensor_ctrl_test_pattern, NULL);\n\tv4l2_ctrl_new_custom(&vsensor->hdl, &vimc_sensor_ctrl_osd_mode, NULL);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&vsensor->hdl, &vimc_sensor_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 128);\n\tvsensor->sd.ctrl_handler = &vsensor->hdl;\n\tif (vsensor->hdl.error) {\n\t\tret = vsensor->hdl.error;\n\t\tgoto err_free_vsensor;\n\t}\n\n\t \n\ttpg_init(&vsensor->tpg, vsensor->mbus_format.width,\n\t\t vsensor->mbus_format.height);\n\tret = tpg_alloc(&vsensor->tpg, VIMC_FRAME_MAX_WIDTH);\n\tif (ret)\n\t\tgoto err_free_hdl;\n\n\t \n\tvsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = vimc_ent_sd_register(&vsensor->ved, &vsensor->sd, v4l2_dev,\n\t\t\t\t   vcfg_name,\n\t\t\t\t   MEDIA_ENT_F_CAM_SENSOR, 1, &vsensor->pad,\n\t\t\t\t   &vimc_sensor_ops);\n\tif (ret)\n\t\tgoto err_free_tpg;\n\n\tvsensor->ved.process_frame = vimc_sensor_process_frame;\n\tvsensor->ved.dev = vimc->mdev.dev;\n\n\t \n\tvsensor->mbus_format = fmt_default;\n\n\treturn &vsensor->ved;\n\nerr_free_tpg:\n\ttpg_free(&vsensor->tpg);\nerr_free_hdl:\n\tv4l2_ctrl_handler_free(&vsensor->hdl);\nerr_free_vsensor:\n\tkfree(vsensor);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct vimc_ent_type vimc_sensor_type = {\n\t.add = vimc_sensor_add,\n\t.release = vimc_sensor_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}