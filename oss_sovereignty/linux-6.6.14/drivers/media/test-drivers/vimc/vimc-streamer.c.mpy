{
  "module_name": "vimc-streamer.c",
  "hash_id": "702046afd21ef8dea0e76b3875e990c6ac61a0410db01cd1920392bc32171141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-streamer.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n#include \"vimc-streamer.h\"\n\n \nstatic struct media_entity *vimc_get_source_entity(struct media_entity *ent)\n{\n\tstruct media_pad *pad;\n\tint i;\n\n\tfor (i = 0; i < ent->num_pads; i++) {\n\t\tif (ent->pads[i].flags & MEDIA_PAD_FL_SOURCE)\n\t\t\tcontinue;\n\t\tpad = media_pad_remote_pad_first(&ent->pads[i]);\n\t\treturn pad ? pad->entity : NULL;\n\t}\n\treturn NULL;\n}\n\n \nstatic void vimc_streamer_pipeline_terminate(struct vimc_stream *stream)\n{\n\tstruct vimc_ent_device *ved;\n\tstruct v4l2_subdev *sd;\n\n\twhile (stream->pipe_size) {\n\t\tstream->pipe_size--;\n\t\tved = stream->ved_pipeline[stream->pipe_size];\n\t\tstream->ved_pipeline[stream->pipe_size] = NULL;\n\n\t\tif (!is_media_entity_v4l2_subdev(ved->ent))\n\t\t\tcontinue;\n\n\t\tsd = media_entity_to_v4l2_subdev(ved->ent);\n\t\tv4l2_subdev_call(sd, video, s_stream, 0);\n\t}\n}\n\n \nstatic int vimc_streamer_pipeline_init(struct vimc_stream *stream,\n\t\t\t\t       struct vimc_ent_device *ved)\n{\n\tstruct media_entity *entity;\n\tstruct video_device *vdev;\n\tstruct v4l2_subdev *sd;\n\tint ret = 0;\n\n\tstream->pipe_size = 0;\n\twhile (stream->pipe_size < VIMC_STREAMER_PIPELINE_MAX_SIZE) {\n\t\tif (!ved) {\n\t\t\tvimc_streamer_pipeline_terminate(stream);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstream->ved_pipeline[stream->pipe_size++] = ved;\n\n\t\tif (is_media_entity_v4l2_subdev(ved->ent)) {\n\t\t\tsd = media_entity_to_v4l2_subdev(ved->ent);\n\t\t\tret = v4l2_subdev_call(sd, video, s_stream, 1);\n\t\t\tif (ret && ret != -ENOIOCTLCMD) {\n\t\t\t\tdev_err(ved->dev, \"subdev_call error %s\\n\",\n\t\t\t\t\tved->ent->name);\n\t\t\t\tvimc_streamer_pipeline_terminate(stream);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tentity = vimc_get_source_entity(ved->ent);\n\t\t \n\t\tif (!entity) {\n\t\t\t \n\t\t\tif (!vimc_is_source(ved->ent)) {\n\t\t\t\tdev_err(ved->dev,\n\t\t\t\t\t\"first entity in the pipe '%s' is not a source\\n\",\n\t\t\t\t\tved->ent->name);\n\t\t\t\tvimc_streamer_pipeline_terminate(stream);\n\t\t\t\treturn -EPIPE;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (is_media_entity_v4l2_subdev(entity)) {\n\t\t\tsd = media_entity_to_v4l2_subdev(entity);\n\t\t\tved = v4l2_get_subdevdata(sd);\n\t\t} else {\n\t\t\tvdev = container_of(entity,\n\t\t\t\t\t    struct video_device,\n\t\t\t\t\t    entity);\n\t\t\tved = video_get_drvdata(vdev);\n\t\t}\n\t}\n\n\tvimc_streamer_pipeline_terminate(stream);\n\treturn -EINVAL;\n}\n\n \nstatic int vimc_streamer_thread(void *data)\n{\n\tstruct vimc_stream *stream = data;\n\tu8 *frame = NULL;\n\tint i;\n\n\tset_freezable();\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tfor (i = stream->pipe_size - 1; i >= 0; i--) {\n\t\t\tframe = stream->ved_pipeline[i]->process_frame(\n\t\t\t\t\tstream->ved_pipeline[i], frame);\n\t\t\tif (!frame || IS_ERR(frame))\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(HZ / 60);\n\t}\n\n\treturn 0;\n}\n\n \nint vimc_streamer_s_stream(struct vimc_stream *stream,\n\t\t\t   struct vimc_ent_device *ved,\n\t\t\t   int enable)\n{\n\tint ret;\n\n\tif (!stream || !ved)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tif (stream->kthread)\n\t\t\treturn 0;\n\n\t\tret = vimc_streamer_pipeline_init(stream, ved);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstream->kthread = kthread_run(vimc_streamer_thread, stream,\n\t\t\t\t\t      \"vimc-streamer thread\");\n\n\t\tif (IS_ERR(stream->kthread)) {\n\t\t\tret = PTR_ERR(stream->kthread);\n\t\t\tdev_err(ved->dev, \"kthread_run failed with %d\\n\", ret);\n\t\t\tvimc_streamer_pipeline_terminate(stream);\n\t\t\tstream->kthread = NULL;\n\t\t\treturn ret;\n\t\t}\n\n\t} else {\n\t\tif (!stream->kthread)\n\t\t\treturn 0;\n\n\t\tret = kthread_stop(stream->kthread);\n\t\t \n\t\tif (ret)\n\t\t\tdev_dbg(ved->dev, \"kthread_stop returned '%d'\\n\", ret);\n\n\t\tstream->kthread = NULL;\n\n\t\tvimc_streamer_pipeline_terminate(stream);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}