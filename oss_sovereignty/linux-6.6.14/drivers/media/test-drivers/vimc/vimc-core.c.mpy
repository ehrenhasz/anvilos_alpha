{
  "module_name": "vimc-core.c",
  "hash_id": "053842d366a5a9c7457e100adf2e257ffc6c3001057fe1d3404fb0066015402e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-core.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/font.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <media/media-device.h>\n#include <media/tpg/v4l2-tpg.h>\n#include <media/v4l2-device.h>\n\n#include \"vimc-common.h\"\n\nunsigned int vimc_allocator;\nmodule_param_named(allocator, vimc_allocator, uint, 0444);\nMODULE_PARM_DESC(allocator, \" memory allocator selection, default is 0.\\n\"\n\t\t\t     \"\\t\\t    0 == vmalloc\\n\"\n\t\t\t     \"\\t\\t    1 == dma-contig\");\n\n#define VIMC_MDEV_MODEL_NAME \"VIMC MDEV\"\n\n#define VIMC_DATA_LINK(src, srcpad, sink, sinkpad, link_flags) {\t\\\n\t.src_ent = src,\t\t\t\t\t\t\\\n\t.src_pad = srcpad,\t\t\t\t\t\\\n\t.sink_ent = sink,\t\t\t\t\t\\\n\t.sink_pad = sinkpad,\t\t\t\t\t\\\n\t.flags = link_flags,\t\t\t\t\t\\\n}\n\n#define VIMC_ANCILLARY_LINK(primary, ancillary) {\t\\\n\t.primary_ent = primary,\t\t\t\\\n\t.ancillary_ent = ancillary\t\t\\\n}\n\n \nstruct vimc_data_link {\n\tunsigned int src_ent;\n\tu16 src_pad;\n\tunsigned int sink_ent;\n\tu16 sink_pad;\n\tu32 flags;\n};\n\n \nenum vimc_data_link_ents {\n\tSENSOR_A,\n\tSENSOR_B,\n\tDEBAYER_A,\n\tDEBAYER_B,\n\tRAW_CAPTURE_0,\n\tRAW_CAPTURE_1,\n\tRGB_YUV_INPUT,\n\tSCALER,\n\tRGB_YUV_CAPTURE,\n\tLENS_A,\n\tLENS_B,\n};\n\n \nstruct vimc_ancillary_link {\n\tunsigned int primary_ent;\n\tunsigned int ancillary_ent;\n};\n\n \nstruct vimc_pipeline_config {\n\tconst struct vimc_ent_config *ents;\n\tsize_t num_ents;\n\tconst struct vimc_data_link *data_links;\n\tsize_t num_data_links;\n\tconst struct vimc_ancillary_link *ancillary_links;\n\tsize_t num_ancillary_links;\n};\n\n \n\nstatic struct vimc_ent_config ent_config[] = {\n\t[SENSOR_A] = {\n\t\t.name = \"Sensor A\",\n\t\t.type = &vimc_sensor_type\n\t},\n\t[SENSOR_B] = {\n\t\t.name = \"Sensor B\",\n\t\t.type = &vimc_sensor_type\n\t},\n\t[DEBAYER_A] = {\n\t\t.name = \"Debayer A\",\n\t\t.type = &vimc_debayer_type\n\t},\n\t[DEBAYER_B] = {\n\t\t.name = \"Debayer B\",\n\t\t.type = &vimc_debayer_type\n\t},\n\t[RAW_CAPTURE_0] = {\n\t\t.name = \"Raw Capture 0\",\n\t\t.type = &vimc_capture_type\n\t},\n\t[RAW_CAPTURE_1] = {\n\t\t.name = \"Raw Capture 1\",\n\t\t.type = &vimc_capture_type\n\t},\n\t[RGB_YUV_INPUT] = {\n\t\t \n\t\t.name = \"RGB/YUV Input\",\n\t\t.type = &vimc_sensor_type\n\t},\n\t[SCALER] = {\n\t\t.name = \"Scaler\",\n\t\t.type = &vimc_scaler_type\n\t},\n\t[RGB_YUV_CAPTURE] = {\n\t\t.name = \"RGB/YUV Capture\",\n\t\t.type = &vimc_capture_type\n\t},\n\t[LENS_A] = {\n\t\t.name = \"Lens A\",\n\t\t.type = &vimc_lens_type\n\t},\n\t[LENS_B] = {\n\t\t.name = \"Lens B\",\n\t\t.type = &vimc_lens_type\n\t},\n};\n\nstatic const struct vimc_data_link data_links[] = {\n\t \n\tVIMC_DATA_LINK(SENSOR_A, 0, DEBAYER_A, 0,\n\t\t       MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),\n\t \n\tVIMC_DATA_LINK(SENSOR_A, 0, RAW_CAPTURE_0, 0,\n\t\t       MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),\n\t \n\tVIMC_DATA_LINK(SENSOR_B, 0, DEBAYER_B, 0,\n\t\t       MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),\n\t \n\tVIMC_DATA_LINK(SENSOR_B, 0, RAW_CAPTURE_1, 0,\n\t\t       MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),\n\t \n\tVIMC_DATA_LINK(DEBAYER_A, 1, SCALER, 0, MEDIA_LNK_FL_ENABLED),\n\t \n\tVIMC_DATA_LINK(DEBAYER_B, 1, SCALER, 0, 0),\n\t \n\tVIMC_DATA_LINK(RGB_YUV_INPUT, 0, SCALER, 0, 0),\n\t \n\tVIMC_DATA_LINK(SCALER, 1, RGB_YUV_CAPTURE, 0,\n\t\t       MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),\n};\n\nstatic const struct vimc_ancillary_link ancillary_links[] = {\n\t \n\tVIMC_ANCILLARY_LINK(0, 9),\n\t \n\tVIMC_ANCILLARY_LINK(1, 10),\n};\n\nstatic struct vimc_pipeline_config pipe_cfg = {\n\t.ents\t\t     = ent_config,\n\t.num_ents\t     = ARRAY_SIZE(ent_config),\n\t.data_links\t     = data_links,\n\t.num_data_links\t     = ARRAY_SIZE(data_links),\n\t.ancillary_links     = ancillary_links,\n\t.num_ancillary_links = ARRAY_SIZE(ancillary_links),\n};\n\n \n\nstatic void vimc_rm_links(struct vimc_device *vimc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vimc->pipe_cfg->num_ents; i++)\n\t\tmedia_entity_remove_links(vimc->ent_devs[i]->ent);\n}\n\nstatic int vimc_create_links(struct vimc_device *vimc)\n{\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < vimc->pipe_cfg->num_data_links; i++) {\n\t\tconst struct vimc_data_link *link = &vimc->pipe_cfg->data_links[i];\n\n\t\tstruct vimc_ent_device *ved_src =\n\t\t\tvimc->ent_devs[link->src_ent];\n\t\tstruct vimc_ent_device *ved_sink =\n\t\t\tvimc->ent_devs[link->sink_ent];\n\n\t\tret = media_create_pad_link(ved_src->ent, link->src_pad,\n\t\t\t\t\t    ved_sink->ent, link->sink_pad,\n\t\t\t\t\t    link->flags);\n\t\tif (ret)\n\t\t\tgoto err_rm_links;\n\t}\n\n\tfor (i = 0; i < vimc->pipe_cfg->num_ancillary_links; i++) {\n\t\tconst struct vimc_ancillary_link *link = &vimc->pipe_cfg->ancillary_links[i];\n\n\t\tstruct vimc_ent_device *ved_primary =\n\t\t\tvimc->ent_devs[link->primary_ent];\n\t\tstruct vimc_ent_device *ved_ancillary =\n\t\t\tvimc->ent_devs[link->ancillary_ent];\n\t\tstruct media_link *ret_link =\n\t\t\tmedia_create_ancillary_link(ved_primary->ent, ved_ancillary->ent);\n\n\t\tif (IS_ERR(ret_link)) {\n\t\t\tret = PTR_ERR(ret_link);\n\t\t\tgoto err_rm_links;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_rm_links:\n\tvimc_rm_links(vimc);\n\treturn ret;\n}\n\nstatic void vimc_release_subdevs(struct vimc_device *vimc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vimc->pipe_cfg->num_ents; i++)\n\t\tif (vimc->ent_devs[i])\n\t\t\tvimc->pipe_cfg->ents[i].type->release(vimc->ent_devs[i]);\n}\n\nstatic void vimc_unregister_subdevs(struct vimc_device *vimc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vimc->pipe_cfg->num_ents; i++)\n\t\tif (vimc->ent_devs[i] && vimc->pipe_cfg->ents[i].type->unregister)\n\t\t\tvimc->pipe_cfg->ents[i].type->unregister(vimc->ent_devs[i]);\n}\n\nstatic int vimc_add_subdevs(struct vimc_device *vimc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vimc->pipe_cfg->num_ents; i++) {\n\t\tdev_dbg(vimc->mdev.dev, \"new entity for %s\\n\",\n\t\t\tvimc->pipe_cfg->ents[i].name);\n\t\tvimc->ent_devs[i] = vimc->pipe_cfg->ents[i].type->add(vimc,\n\t\t\t\t\tvimc->pipe_cfg->ents[i].name);\n\t\tif (IS_ERR(vimc->ent_devs[i])) {\n\t\t\tint err = PTR_ERR(vimc->ent_devs[i]);\n\n\t\t\tdev_err(vimc->mdev.dev, \"adding entity %s failed (%d)\\n\",\n\t\t\t\tvimc->pipe_cfg->ents[i].name, err);\n\t\t\tvimc->ent_devs[i] = NULL;\n\t\t\tvimc_unregister_subdevs(vimc);\n\t\t\tvimc_release_subdevs(vimc);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void vimc_v4l2_dev_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct vimc_device *vimc =\n\t\tcontainer_of(v4l2_dev, struct vimc_device, v4l2_dev);\n\n\tvimc_release_subdevs(vimc);\n\tmedia_device_cleanup(&vimc->mdev);\n\tkfree(vimc->ent_devs);\n\tkfree(vimc);\n}\n\nstatic int vimc_register_devices(struct vimc_device *vimc)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register(vimc->mdev.dev, &vimc->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(vimc->mdev.dev,\n\t\t\t\"v4l2 device register failed (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tvimc->ent_devs = kcalloc(vimc->pipe_cfg->num_ents,\n\t\t\t\t sizeof(*vimc->ent_devs), GFP_KERNEL);\n\tif (!vimc->ent_devs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_v4l2_unregister;\n\t}\n\n\t \n\tret = vimc_add_subdevs(vimc);\n\tif (ret)\n\t\tgoto err_free_ent_devs;\n\n\t \n\tret = vimc_create_links(vimc);\n\tif (ret)\n\t\tgoto err_rm_subdevs;\n\n\t \n\tret = media_device_register(&vimc->mdev);\n\tif (ret) {\n\t\tdev_err(vimc->mdev.dev,\n\t\t\t\"media device register failed (err=%d)\\n\", ret);\n\t\tgoto err_rm_subdevs;\n\t}\n\n\t \n\tret = v4l2_device_register_subdev_nodes(&vimc->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(vimc->mdev.dev,\n\t\t\t\"vimc subdev nodes registration failed (err=%d)\\n\",\n\t\t\tret);\n\t\tgoto err_mdev_unregister;\n\t}\n\n\treturn 0;\n\nerr_mdev_unregister:\n\tmedia_device_unregister(&vimc->mdev);\nerr_rm_subdevs:\n\tvimc_unregister_subdevs(vimc);\n\tvimc_release_subdevs(vimc);\nerr_free_ent_devs:\n\tkfree(vimc->ent_devs);\nerr_v4l2_unregister:\n\tv4l2_device_unregister(&vimc->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic int vimc_probe(struct platform_device *pdev)\n{\n\tconst struct font_desc *font = find_font(\"VGA8x16\");\n\tstruct vimc_device *vimc;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"probe\");\n\n\tif (!font) {\n\t\tdev_err(&pdev->dev, \"could not find font\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttpg_set_font(font->data);\n\n\tif (vimc_allocator == VIMC_ALLOCATOR_DMA_CONTIG)\n\t\tdma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\n\tvimc = kzalloc(sizeof(*vimc), GFP_KERNEL);\n\tif (!vimc)\n\t\treturn -ENOMEM;\n\n\tvimc->pipe_cfg = &pipe_cfg;\n\n\t \n\tvimc->v4l2_dev.mdev = &vimc->mdev;\n\n\t \n\tstrscpy(vimc->mdev.model, VIMC_MDEV_MODEL_NAME,\n\t\tsizeof(vimc->mdev.model));\n\tsnprintf(vimc->mdev.bus_info, sizeof(vimc->mdev.bus_info),\n\t\t \"platform:%s\", VIMC_PDEV_NAME);\n\tvimc->mdev.dev = &pdev->dev;\n\tmedia_device_init(&vimc->mdev);\n\n\tret = vimc_register_devices(vimc);\n\tif (ret) {\n\t\tmedia_device_cleanup(&vimc->mdev);\n\t\tkfree(vimc);\n\t\treturn ret;\n\t}\n\t \n\n\tvimc->v4l2_dev.release = vimc_v4l2_dev_release;\n\tplatform_set_drvdata(pdev, vimc);\n\treturn 0;\n}\n\nstatic void vimc_remove(struct platform_device *pdev)\n{\n\tstruct vimc_device *vimc = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"remove\");\n\n\tvimc_unregister_subdevs(vimc);\n\tmedia_device_unregister(&vimc->mdev);\n\tv4l2_device_unregister(&vimc->v4l2_dev);\n\tv4l2_device_put(&vimc->v4l2_dev);\n}\n\nstatic void vimc_dev_release(struct device *dev)\n{\n}\n\nstatic struct platform_device vimc_pdev = {\n\t.name = VIMC_PDEV_NAME,\n\t.dev.release = vimc_dev_release,\n};\n\nstatic struct platform_driver vimc_pdrv = {\n\t.probe\t\t= vimc_probe,\n\t.remove_new\t= vimc_remove,\n\t.driver\t\t= {\n\t\t.name\t= VIMC_PDEV_NAME,\n\t},\n};\n\nstatic int __init vimc_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&vimc_pdev);\n\tif (ret) {\n\t\tdev_err(&vimc_pdev.dev,\n\t\t\t\"platform device registration failed (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&vimc_pdrv);\n\tif (ret) {\n\t\tdev_err(&vimc_pdev.dev,\n\t\t\t\"platform driver registration failed (err=%d)\\n\", ret);\n\t\tplatform_device_unregister(&vimc_pdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit vimc_exit(void)\n{\n\tplatform_driver_unregister(&vimc_pdrv);\n\n\tplatform_device_unregister(&vimc_pdev);\n}\n\nmodule_init(vimc_init);\nmodule_exit(vimc_exit);\n\nMODULE_DESCRIPTION(\"Virtual Media Controller Driver (VIMC)\");\nMODULE_AUTHOR(\"Helen Fornazier <helen.fornazier@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}