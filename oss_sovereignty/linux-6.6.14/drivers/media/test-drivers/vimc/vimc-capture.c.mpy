{
  "module_name": "vimc-capture.c",
  "hash_id": "da39a6295ee48e41dfb6eed3882066c6fc64f4407b3939d30fb26cb70298c6a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-capture.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"vimc-common.h\"\n#include \"vimc-streamer.h\"\n\nstruct vimc_capture_device {\n\tstruct vimc_ent_device ved;\n\tstruct video_device vdev;\n\tstruct v4l2_pix_format format;\n\tstruct vb2_queue queue;\n\tstruct list_head buf_list;\n\t \n\tspinlock_t qlock;\n\tstruct mutex lock;\n\tu32 sequence;\n\tstruct vimc_stream stream;\n\tstruct media_pad pad;\n};\n\nstatic const struct v4l2_pix_format fmt_default = {\n\t.width = 640,\n\t.height = 480,\n\t.pixelformat = V4L2_PIX_FMT_RGB24,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n};\n\nstruct vimc_capture_buffer {\n\t \n\tstruct vb2_v4l2_buffer vb2;\n\tstruct list_head list;\n};\n\nstatic int vimc_capture_querycap(struct file *file, void *priv,\n\t\t\t     struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, VIMC_PDEV_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", VIMC_PDEV_NAME);\n\n\treturn 0;\n}\n\nstatic void vimc_capture_get_format(struct vimc_ent_device *ved,\n\t\t\t\tstruct v4l2_pix_format *fmt)\n{\n\tstruct vimc_capture_device *vcapture = container_of(ved, struct vimc_capture_device,\n\t\t\t\t\t\t    ved);\n\n\t*fmt = vcapture->format;\n}\n\nstatic int vimc_capture_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vimc_capture_device *vcapture = video_drvdata(file);\n\n\tf->fmt.pix = vcapture->format;\n\n\treturn 0;\n}\n\nstatic int vimc_capture_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format *format = &f->fmt.pix;\n\tconst struct vimc_pix_map *vpix;\n\n\tformat->width = clamp_t(u32, format->width, VIMC_FRAME_MIN_WIDTH,\n\t\t\t\tVIMC_FRAME_MAX_WIDTH) & ~1;\n\tformat->height = clamp_t(u32, format->height, VIMC_FRAME_MIN_HEIGHT,\n\t\t\t\t VIMC_FRAME_MAX_HEIGHT) & ~1;\n\n\t \n\tvpix = vimc_pix_map_by_pixelformat(format->pixelformat);\n\tif (!vpix) {\n\t\tformat->pixelformat = fmt_default.pixelformat;\n\t\tvpix = vimc_pix_map_by_pixelformat(format->pixelformat);\n\t}\n\t \n\tformat->bytesperline = format->width * vpix->bpp;\n\tformat->sizeimage = format->bytesperline * format->height;\n\n\tif (format->field == V4L2_FIELD_ANY)\n\t\tformat->field = fmt_default.field;\n\n\tvimc_colorimetry_clamp(format);\n\n\tif (format->colorspace == V4L2_COLORSPACE_DEFAULT)\n\t\tformat->colorspace = fmt_default.colorspace;\n\n\treturn 0;\n}\n\nstatic int vimc_capture_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct vimc_capture_device *vcapture = video_drvdata(file);\n\tint ret;\n\n\t \n\tif (vb2_is_busy(&vcapture->queue))\n\t\treturn -EBUSY;\n\n\tret = vimc_capture_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(vcapture->ved.dev, \"%s: format update: \"\n\t\t\"old:%dx%d (0x%x, %d, %d, %d, %d) \"\n\t\t\"new:%dx%d (0x%x, %d, %d, %d, %d)\\n\", vcapture->vdev.name,\n\t\t \n\t\tvcapture->format.width, vcapture->format.height,\n\t\tvcapture->format.pixelformat, vcapture->format.colorspace,\n\t\tvcapture->format.quantization, vcapture->format.xfer_func,\n\t\tvcapture->format.ycbcr_enc,\n\t\t \n\t\tf->fmt.pix.width, f->fmt.pix.height,\n\t\tf->fmt.pix.pixelformat,\tf->fmt.pix.colorspace,\n\t\tf->fmt.pix.quantization, f->fmt.pix.xfer_func,\n\t\tf->fmt.pix.ycbcr_enc);\n\n\tvcapture->format = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int vimc_capture_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tconst struct vimc_pix_map *vpix;\n\n\tif (f->mbus_code) {\n\t\tif (f->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tvpix = vimc_pix_map_by_code(f->mbus_code);\n\t} else {\n\t\tvpix = vimc_pix_map_by_index(f->index);\n\t}\n\n\tif (!vpix)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = vpix->pixelformat;\n\n\treturn 0;\n}\n\nstatic int vimc_capture_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct vimc_pix_map *vpix;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\t \n\tvpix = vimc_pix_map_by_code(fsize->pixel_format);\n\tif (!vpix)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = VIMC_FRAME_MIN_WIDTH;\n\tfsize->stepwise.max_width = VIMC_FRAME_MAX_WIDTH;\n\tfsize->stepwise.min_height = VIMC_FRAME_MIN_HEIGHT;\n\tfsize->stepwise.max_height = VIMC_FRAME_MAX_HEIGHT;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations vimc_capture_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.read           = vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops vimc_capture_ioctl_ops = {\n\t.vidioc_querycap = vimc_capture_querycap,\n\n\t.vidioc_g_fmt_vid_cap = vimc_capture_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = vimc_capture_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = vimc_capture_try_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap = vimc_capture_enum_fmt_vid_cap,\n\t.vidioc_enum_framesizes = vimc_capture_enum_framesizes,\n\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n};\n\nstatic void vimc_capture_return_all_buffers(struct vimc_capture_device *vcapture,\n\t\t\t\t\tenum vb2_buffer_state state)\n{\n\tstruct vimc_capture_buffer *vbuf, *node;\n\n\tspin_lock(&vcapture->qlock);\n\n\tlist_for_each_entry_safe(vbuf, node, &vcapture->buf_list, list) {\n\t\tlist_del(&vbuf->list);\n\t\tvb2_buffer_done(&vbuf->vb2.vb2_buf, state);\n\t}\n\n\tspin_unlock(&vcapture->qlock);\n}\n\nstatic int vimc_capture_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vimc_capture_device *vcapture = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tvcapture->sequence = 0;\n\n\t \n\tret = video_device_pipeline_start(&vcapture->vdev, &vcapture->stream.pipe);\n\tif (ret) {\n\t\tvimc_capture_return_all_buffers(vcapture, VB2_BUF_STATE_QUEUED);\n\t\treturn ret;\n\t}\n\n\tret = vimc_streamer_s_stream(&vcapture->stream, &vcapture->ved, 1);\n\tif (ret) {\n\t\tvideo_device_pipeline_stop(&vcapture->vdev);\n\t\tvimc_capture_return_all_buffers(vcapture, VB2_BUF_STATE_QUEUED);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vimc_capture_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vimc_capture_device *vcapture = vb2_get_drv_priv(vq);\n\n\tvimc_streamer_s_stream(&vcapture->stream, &vcapture->ved, 0);\n\n\t \n\tvideo_device_pipeline_stop(&vcapture->vdev);\n\n\t \n\tvimc_capture_return_all_buffers(vcapture, VB2_BUF_STATE_ERROR);\n}\n\nstatic void vimc_capture_buf_queue(struct vb2_buffer *vb2_buf)\n{\n\tstruct vimc_capture_device *vcapture = vb2_get_drv_priv(vb2_buf->vb2_queue);\n\tstruct vimc_capture_buffer *buf = container_of(vb2_buf,\n\t\t\t\t\t\t   struct vimc_capture_buffer,\n\t\t\t\t\t\t   vb2.vb2_buf);\n\n\tspin_lock(&vcapture->qlock);\n\tlist_add_tail(&buf->list, &vcapture->buf_list);\n\tspin_unlock(&vcapture->qlock);\n}\n\nstatic int vimc_capture_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\tunsigned int *nplanes, unsigned int sizes[],\n\t\t\t\tstruct device *alloc_devs[])\n{\n\tstruct vimc_capture_device *vcapture = vb2_get_drv_priv(vq);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < vcapture->format.sizeimage ? -EINVAL : 0;\n\t \n\t*nplanes = 1;\n\tsizes[0] = vcapture->format.sizeimage;\n\n\treturn 0;\n}\n\nstatic int vimc_capture_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vimc_capture_device *vcapture = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = vcapture->format.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(vcapture->ved.dev, \"%s: buffer too small (%lu < %lu)\\n\",\n\t\t\tvcapture->vdev.name, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct vb2_ops vimc_capture_qops = {\n\t.start_streaming\t= vimc_capture_start_streaming,\n\t.stop_streaming\t\t= vimc_capture_stop_streaming,\n\t.buf_queue\t\t= vimc_capture_buf_queue,\n\t.queue_setup\t\t= vimc_capture_queue_setup,\n\t.buf_prepare\t\t= vimc_capture_buffer_prepare,\n\t \n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic const struct media_entity_operations vimc_capture_mops = {\n\t.link_validate\t\t= vimc_vdev_link_validate,\n};\n\nstatic void vimc_capture_release(struct vimc_ent_device *ved)\n{\n\tstruct vimc_capture_device *vcapture =\n\t\tcontainer_of(ved, struct vimc_capture_device, ved);\n\n\tmedia_entity_cleanup(vcapture->ved.ent);\n\tkfree(vcapture);\n}\n\nstatic void vimc_capture_unregister(struct vimc_ent_device *ved)\n{\n\tstruct vimc_capture_device *vcapture =\n\t\tcontainer_of(ved, struct vimc_capture_device, ved);\n\n\tvb2_video_unregister_device(&vcapture->vdev);\n}\n\nstatic void *vimc_capture_process_frame(struct vimc_ent_device *ved,\n\t\t\t\t    const void *frame)\n{\n\tstruct vimc_capture_device *vcapture = container_of(ved, struct vimc_capture_device,\n\t\t\t\t\t\t    ved);\n\tstruct vimc_capture_buffer *vimc_buf;\n\tvoid *vbuf;\n\n\tspin_lock(&vcapture->qlock);\n\n\t \n\tvimc_buf = list_first_entry_or_null(&vcapture->buf_list,\n\t\t\t\t\t    typeof(*vimc_buf), list);\n\tif (!vimc_buf) {\n\t\tspin_unlock(&vcapture->qlock);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\t \n\tlist_del(&vimc_buf->list);\n\n\tspin_unlock(&vcapture->qlock);\n\n\t \n\tvimc_buf->vb2.vb2_buf.timestamp = ktime_get_ns();\n\tvimc_buf->vb2.sequence = vcapture->sequence++;\n\tvimc_buf->vb2.field = vcapture->format.field;\n\n\tvbuf = vb2_plane_vaddr(&vimc_buf->vb2.vb2_buf, 0);\n\n\tmemcpy(vbuf, frame, vcapture->format.sizeimage);\n\n\t \n\tvb2_set_plane_payload(&vimc_buf->vb2.vb2_buf, 0,\n\t\t\t      vcapture->format.sizeimage);\n\tvb2_buffer_done(&vimc_buf->vb2.vb2_buf, VB2_BUF_STATE_DONE);\n\treturn NULL;\n}\n\nstatic struct vimc_ent_device *vimc_capture_add(struct vimc_device *vimc,\n\t\t\t\t\t    const char *vcfg_name)\n{\n\tstruct v4l2_device *v4l2_dev = &vimc->v4l2_dev;\n\tconst struct vimc_pix_map *vpix;\n\tstruct vimc_capture_device *vcapture;\n\tstruct video_device *vdev;\n\tstruct vb2_queue *q;\n\tint ret;\n\n\t \n\tvcapture = kzalloc(sizeof(*vcapture), GFP_KERNEL);\n\tif (!vcapture)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tvcapture->vdev.entity.name = vcfg_name;\n\tvcapture->vdev.entity.function = MEDIA_ENT_F_IO_V4L;\n\tvcapture->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vcapture->vdev.entity,\n\t\t\t\t     1, &vcapture->pad);\n\tif (ret)\n\t\tgoto err_free_vcapture;\n\n\t \n\tmutex_init(&vcapture->lock);\n\n\t \n\tq = &vcapture->queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tif (vimc_allocator == VIMC_ALLOCATOR_VMALLOC)\n\t\tq->io_modes |= VB2_USERPTR;\n\tq->drv_priv = vcapture;\n\tq->buf_struct_size = sizeof(struct vimc_capture_buffer);\n\tq->ops = &vimc_capture_qops;\n\tq->mem_ops = vimc_allocator == VIMC_ALLOCATOR_DMA_CONTIG\n\t\t   ? &vb2_dma_contig_memops : &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->lock = &vcapture->lock;\n\tq->dev = v4l2_dev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret) {\n\t\tdev_err(vimc->mdev.dev, \"%s: vb2 queue init failed (err=%d)\\n\",\n\t\t\tvcfg_name, ret);\n\t\tgoto err_clean_m_ent;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&vcapture->buf_list);\n\tspin_lock_init(&vcapture->qlock);\n\n\t \n\tvcapture->format = fmt_default;\n\tvpix = vimc_pix_map_by_pixelformat(vcapture->format.pixelformat);\n\tvcapture->format.bytesperline = vcapture->format.width * vpix->bpp;\n\tvcapture->format.sizeimage = vcapture->format.bytesperline *\n\t\t\t\t vcapture->format.height;\n\n\t \n\tvcapture->ved.ent = &vcapture->vdev.entity;\n\tvcapture->ved.process_frame = vimc_capture_process_frame;\n\tvcapture->ved.vdev_get_format = vimc_capture_get_format;\n\tvcapture->ved.dev = vimc->mdev.dev;\n\n\t \n\tvdev = &vcapture->vdev;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING\n\t\t\t  | V4L2_CAP_IO_MC;\n\tvdev->entity.ops = &vimc_capture_mops;\n\tvdev->release = video_device_release_empty;\n\tvdev->fops = &vimc_capture_fops;\n\tvdev->ioctl_ops = &vimc_capture_ioctl_ops;\n\tvdev->lock = &vcapture->lock;\n\tvdev->queue = q;\n\tvdev->v4l2_dev = v4l2_dev;\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tstrscpy(vdev->name, vcfg_name, sizeof(vdev->name));\n\tvideo_set_drvdata(vdev, &vcapture->ved);\n\n\t \n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(vimc->mdev.dev, \"%s: video register failed (err=%d)\\n\",\n\t\t\tvcapture->vdev.name, ret);\n\t\tgoto err_clean_m_ent;\n\t}\n\n\treturn &vcapture->ved;\n\nerr_clean_m_ent:\n\tmedia_entity_cleanup(&vcapture->vdev.entity);\nerr_free_vcapture:\n\tkfree(vcapture);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct vimc_ent_type vimc_capture_type = {\n\t.add = vimc_capture_add,\n\t.unregister = vimc_capture_unregister,\n\t.release = vimc_capture_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}