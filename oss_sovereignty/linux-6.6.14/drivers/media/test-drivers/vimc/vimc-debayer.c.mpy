{
  "module_name": "vimc-debayer.c",
  "hash_id": "da151e46a92a92e91e6c52d35c9ec07b8991f6812c121a5821c50ff751a300e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-debayer.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/vmalloc.h>\n#include <linux/v4l2-mediabus.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-subdev.h>\n\n#include \"vimc-common.h\"\n\nenum vimc_debayer_rgb_colors {\n\tVIMC_DEBAYER_RED = 0,\n\tVIMC_DEBAYER_GREEN = 1,\n\tVIMC_DEBAYER_BLUE = 2,\n};\n\nstruct vimc_debayer_pix_map {\n\tu32 code;\n\tenum vimc_debayer_rgb_colors order[2][2];\n};\n\nstruct vimc_debayer_device {\n\tstruct vimc_ent_device ved;\n\tstruct v4l2_subdev sd;\n\t \n\tstruct v4l2_mbus_framefmt sink_fmt;\n\tu32 src_code;\n\tvoid (*set_rgb_src)(struct vimc_debayer_device *vdebayer,\n\t\t\t    unsigned int lin, unsigned int col,\n\t\t\t    unsigned int rgb[3]);\n\t \n\tu8 *src_frame;\n\tconst struct vimc_debayer_pix_map *sink_pix_map;\n\tunsigned int sink_bpp;\n\tunsigned int mean_win_size;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct media_pad pads[2];\n};\n\nstatic const struct v4l2_mbus_framefmt sink_fmt_default = {\n\t.width = 640,\n\t.height = 480,\n\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n};\n\nstatic const u32 vimc_debayer_src_mbus_codes[] = {\n\tMEDIA_BUS_FMT_GBR888_1X24,\n\tMEDIA_BUS_FMT_BGR888_1X24,\n\tMEDIA_BUS_FMT_BGR888_3X8,\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_RGB888_2X12_BE,\n\tMEDIA_BUS_FMT_RGB888_2X12_LE,\n\tMEDIA_BUS_FMT_RGB888_3X8,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_SPWG,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,\n\tMEDIA_BUS_FMT_RGB888_1X32_PADHI,\n};\n\nstatic const struct vimc_debayer_pix_map vimc_debayer_pix_map_list[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.order = { { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE },\n\t\t\t   { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED },\n\t\t\t   { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.order = { { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.order = { { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE },\n\t\t\t   { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED },\n\t\t\t   { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.order = { { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.order = { { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE },\n\t\t\t   { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.order = { { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_RED },\n\t\t\t   { VIMC_DEBAYER_BLUE, VIMC_DEBAYER_GREEN } }\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.order = { { VIMC_DEBAYER_RED, VIMC_DEBAYER_GREEN },\n\t\t\t   { VIMC_DEBAYER_GREEN, VIMC_DEBAYER_BLUE } }\n\t},\n};\n\nstatic const struct vimc_debayer_pix_map *vimc_debayer_pix_map_by_code(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vimc_debayer_pix_map_list); i++)\n\t\tif (vimc_debayer_pix_map_list[i].code == code)\n\t\t\treturn &vimc_debayer_pix_map_list[i];\n\n\treturn NULL;\n}\n\nstatic bool vimc_debayer_src_code_is_valid(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vimc_debayer_src_mbus_codes); i++)\n\t\tif (vimc_debayer_src_mbus_codes[i] == code)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int vimc_debayer_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state)\n{\n\tstruct vimc_debayer_device *vdebayer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\tunsigned int i;\n\n\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t*mf = sink_fmt_default;\n\n\tfor (i = 1; i < sd->entity.num_pads; i++) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, i);\n\t\t*mf = sink_fmt_default;\n\t\tmf->code = vdebayer->src_code;\n\t}\n\n\treturn 0;\n}\n\nstatic int vimc_debayer_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (VIMC_IS_SRC(code->pad)) {\n\t\tif (code->index >= ARRAY_SIZE(vimc_debayer_src_mbus_codes))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = vimc_debayer_src_mbus_codes[code->index];\n\t} else {\n\t\tif (code->index >= ARRAY_SIZE(vimc_debayer_pix_map_list))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = vimc_debayer_pix_map_list[code->index].code;\n\t}\n\n\treturn 0;\n}\n\nstatic int vimc_debayer_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\tif (VIMC_IS_SINK(fse->pad)) {\n\t\tconst struct vimc_debayer_pix_map *vpix =\n\t\t\tvimc_debayer_pix_map_by_code(fse->code);\n\n\t\tif (!vpix)\n\t\t\treturn -EINVAL;\n\t} else if (!vimc_debayer_src_code_is_valid(fse->code)) {\n\t\treturn -EINVAL;\n\t}\n\n\tfse->min_width = VIMC_FRAME_MIN_WIDTH;\n\tfse->max_width = VIMC_FRAME_MAX_WIDTH;\n\tfse->min_height = VIMC_FRAME_MIN_HEIGHT;\n\tfse->max_height = VIMC_FRAME_MAX_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int vimc_debayer_get_fmt(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct vimc_debayer_device *vdebayer = v4l2_get_subdevdata(sd);\n\n\t \n\tfmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?\n\t\t      *v4l2_subdev_get_try_format(sd, sd_state, 0) :\n\t\t      vdebayer->sink_fmt;\n\n\t \n\tif (VIMC_IS_SRC(fmt->pad))\n\t\tfmt->format.code = vdebayer->src_code;\n\n\treturn 0;\n}\n\nstatic void vimc_debayer_adjust_sink_fmt(struct v4l2_mbus_framefmt *fmt)\n{\n\tconst struct vimc_debayer_pix_map *vpix;\n\n\t \n\tvpix = vimc_debayer_pix_map_by_code(fmt->code);\n\tif (!vpix)\n\t\tfmt->code = sink_fmt_default.code;\n\n\tfmt->width = clamp_t(u32, fmt->width, VIMC_FRAME_MIN_WIDTH,\n\t\t\t     VIMC_FRAME_MAX_WIDTH) & ~1;\n\tfmt->height = clamp_t(u32, fmt->height, VIMC_FRAME_MIN_HEIGHT,\n\t\t\t      VIMC_FRAME_MAX_HEIGHT) & ~1;\n\n\tif (fmt->field == V4L2_FIELD_ANY)\n\t\tfmt->field = sink_fmt_default.field;\n\n\tvimc_colorimetry_clamp(fmt);\n}\n\nstatic int vimc_debayer_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct vimc_debayer_device *vdebayer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tu32 *src_code;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t \n\t\tif (vdebayer->src_frame)\n\t\t\treturn -EBUSY;\n\n\t\tsink_fmt = &vdebayer->sink_fmt;\n\t\tsrc_code = &vdebayer->src_code;\n\t} else {\n\t\tsink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tsrc_code = &v4l2_subdev_get_try_format(sd, sd_state, 1)->code;\n\t}\n\n\t \n\tif (VIMC_IS_SRC(fmt->pad)) {\n\t\tu32 code = fmt->format.code;\n\n\t\tfmt->format = *sink_fmt;\n\n\t\tif (vimc_debayer_src_code_is_valid(code))\n\t\t\t*src_code = code;\n\n\t\tfmt->format.code = *src_code;\n\t} else {\n\t\t \n\t\tvimc_debayer_adjust_sink_fmt(&fmt->format);\n\n\t\tdev_dbg(vdebayer->ved.dev, \"%s: sink format update: \"\n\t\t\t\"old:%dx%d (0x%x, %d, %d, %d, %d) \"\n\t\t\t\"new:%dx%d (0x%x, %d, %d, %d, %d)\\n\", vdebayer->sd.name,\n\t\t\t \n\t\t\tsink_fmt->width, sink_fmt->height, sink_fmt->code,\n\t\t\tsink_fmt->colorspace, sink_fmt->quantization,\n\t\t\tsink_fmt->xfer_func, sink_fmt->ycbcr_enc,\n\t\t\t \n\t\t\tfmt->format.width, fmt->format.height, fmt->format.code,\n\t\t\tfmt->format.colorspace,\tfmt->format.quantization,\n\t\t\tfmt->format.xfer_func, fmt->format.ycbcr_enc);\n\n\t\t*sink_fmt = fmt->format;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops vimc_debayer_pad_ops = {\n\t.init_cfg\t\t= vimc_debayer_init_cfg,\n\t.enum_mbus_code\t\t= vimc_debayer_enum_mbus_code,\n\t.enum_frame_size\t= vimc_debayer_enum_frame_size,\n\t.get_fmt\t\t= vimc_debayer_get_fmt,\n\t.set_fmt\t\t= vimc_debayer_set_fmt,\n};\n\nstatic void vimc_debayer_process_rgb_frame(struct vimc_debayer_device *vdebayer,\n\t\t\t\t\t   unsigned int lin,\n\t\t\t\t\t   unsigned int col,\n\t\t\t\t\t   unsigned int rgb[3])\n{\n\tconst struct vimc_pix_map *vpix;\n\tunsigned int i, index;\n\n\tvpix = vimc_pix_map_by_code(vdebayer->src_code);\n\tindex = VIMC_FRAME_INDEX(lin, col, vdebayer->sink_fmt.width, 3);\n\tfor (i = 0; i < 3; i++) {\n\t\tswitch (vpix->pixelformat) {\n\t\tcase V4L2_PIX_FMT_RGB24:\n\t\t\tvdebayer->src_frame[index + i] = rgb[i];\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_BGR24:\n\t\t\tvdebayer->src_frame[index + i] = rgb[2 - i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int vimc_debayer_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vimc_debayer_device *vdebayer = v4l2_get_subdevdata(sd);\n\n\tif (enable) {\n\t\tconst struct vimc_pix_map *vpix;\n\t\tunsigned int frame_size;\n\n\t\tif (vdebayer->src_frame)\n\t\t\treturn 0;\n\n\t\t \n\t\tvpix = vimc_pix_map_by_code(vdebayer->src_code);\n\t\tframe_size = vdebayer->sink_fmt.width * vdebayer->sink_fmt.height *\n\t\t\t\tvpix->bpp;\n\n\t\t \n\t\tvpix = vimc_pix_map_by_code(vdebayer->sink_fmt.code);\n\t\tvdebayer->sink_bpp = vpix->bpp;\n\n\t\t \n\t\tvdebayer->sink_pix_map =\n\t\t\tvimc_debayer_pix_map_by_code(vdebayer->sink_fmt.code);\n\n\t\t \n\t\tvdebayer->src_frame = vmalloc(frame_size);\n\t\tif (!vdebayer->src_frame)\n\t\t\treturn -ENOMEM;\n\n\t} else {\n\t\tif (!vdebayer->src_frame)\n\t\t\treturn 0;\n\n\t\tvfree(vdebayer->src_frame);\n\t\tvdebayer->src_frame = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops vimc_debayer_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops vimc_debayer_video_ops = {\n\t.s_stream = vimc_debayer_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops vimc_debayer_ops = {\n\t.core = &vimc_debayer_core_ops,\n\t.pad = &vimc_debayer_pad_ops,\n\t.video = &vimc_debayer_video_ops,\n};\n\nstatic unsigned int vimc_debayer_get_val(const u8 *bytes,\n\t\t\t\t\t const unsigned int n_bytes)\n{\n\tunsigned int i;\n\tunsigned int acc = 0;\n\n\tfor (i = 0; i < n_bytes; i++)\n\t\tacc = acc + (bytes[i] << (8 * i));\n\n\treturn acc;\n}\n\nstatic void vimc_debayer_calc_rgb_sink(struct vimc_debayer_device *vdebayer,\n\t\t\t\t       const u8 *frame,\n\t\t\t\t       const unsigned int lin,\n\t\t\t\t       const unsigned int col,\n\t\t\t\t       unsigned int rgb[3])\n{\n\tunsigned int i, seek, wlin, wcol;\n\tunsigned int n_rgb[3] = {0, 0, 0};\n\n\tfor (i = 0; i < 3; i++)\n\t\trgb[i] = 0;\n\n\t \n\tseek = vdebayer->mean_win_size / 2;\n\n\t \n\n\tdev_dbg(vdebayer->ved.dev,\n\t\t\"deb: %s: --- Calc pixel %dx%d, window mean %d, seek %d ---\\n\",\n\t\tvdebayer->sd.name, lin, col, vdebayer->sink_fmt.height, seek);\n\n\t \n\tfor (wlin = seek > lin ? 0 : lin - seek;\n\t     wlin < lin + seek + 1 && wlin < vdebayer->sink_fmt.height;\n\t     wlin++) {\n\n\t\t \n\t\tfor (wcol = seek > col ? 0 : col - seek;\n\t\t     wcol < col + seek + 1 && wcol < vdebayer->sink_fmt.width;\n\t\t     wcol++) {\n\t\t\tenum vimc_debayer_rgb_colors color;\n\t\t\tunsigned int index;\n\n\t\t\t \n\t\t\tcolor = vdebayer->sink_pix_map->order[wlin % 2][wcol % 2];\n\n\t\t\tindex = VIMC_FRAME_INDEX(wlin, wcol,\n\t\t\t\t\t\t vdebayer->sink_fmt.width,\n\t\t\t\t\t\t vdebayer->sink_bpp);\n\n\t\t\tdev_dbg(vdebayer->ved.dev,\n\t\t\t\t\"deb: %s: RGB CALC: frame index %d, win pos %dx%d, color %d\\n\",\n\t\t\t\tvdebayer->sd.name, index, wlin, wcol, color);\n\n\t\t\t \n\t\t\trgb[color] = rgb[color] +\n\t\t\t\tvimc_debayer_get_val(&frame[index],\n\t\t\t\t\t\t     vdebayer->sink_bpp);\n\n\t\t\t \n\t\t\tn_rgb[color]++;\n\n\t\t\tdev_dbg(vdebayer->ved.dev, \"deb: %s: RGB CALC: val %d, n %d\\n\",\n\t\t\t\tvdebayer->sd.name, rgb[color], n_rgb[color]);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tdev_dbg(vdebayer->ved.dev,\n\t\t\t\"deb: %s: PRE CALC: %dx%d Color %d, val %d, n %d\\n\",\n\t\t\tvdebayer->sd.name, lin, col, i, rgb[i], n_rgb[i]);\n\n\t\tif (n_rgb[i])\n\t\t\trgb[i] = rgb[i] / n_rgb[i];\n\n\t\tdev_dbg(vdebayer->ved.dev,\n\t\t\t\"deb: %s: FINAL CALC: %dx%d Color %d, val %d\\n\",\n\t\t\tvdebayer->sd.name, lin, col, i, rgb[i]);\n\t}\n}\n\nstatic void *vimc_debayer_process_frame(struct vimc_ent_device *ved,\n\t\t\t\t\tconst void *sink_frame)\n{\n\tstruct vimc_debayer_device *vdebayer =\n\t\tcontainer_of(ved, struct vimc_debayer_device, ved);\n\n\tunsigned int rgb[3];\n\tunsigned int i, j;\n\n\t \n\tif (!vdebayer->src_frame)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < vdebayer->sink_fmt.height; i++)\n\t\tfor (j = 0; j < vdebayer->sink_fmt.width; j++) {\n\t\t\tvimc_debayer_calc_rgb_sink(vdebayer, sink_frame, i, j, rgb);\n\t\t\tvdebayer->set_rgb_src(vdebayer, i, j, rgb);\n\t\t}\n\n\treturn vdebayer->src_frame;\n}\n\nstatic int vimc_debayer_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vimc_debayer_device *vdebayer =\n\t\tcontainer_of(ctrl->handler, struct vimc_debayer_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase VIMC_CID_MEAN_WIN_SIZE:\n\t\tvdebayer->mean_win_size = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vimc_debayer_ctrl_ops = {\n\t.s_ctrl = vimc_debayer_s_ctrl,\n};\n\nstatic void vimc_debayer_release(struct vimc_ent_device *ved)\n{\n\tstruct vimc_debayer_device *vdebayer =\n\t\tcontainer_of(ved, struct vimc_debayer_device, ved);\n\n\tv4l2_ctrl_handler_free(&vdebayer->hdl);\n\tmedia_entity_cleanup(vdebayer->ved.ent);\n\tkfree(vdebayer);\n}\n\nstatic const struct v4l2_ctrl_config vimc_debayer_ctrl_class = {\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_WRITE_ONLY,\n\t.id = VIMC_CID_VIMC_CLASS,\n\t.name = \"VIMC Controls\",\n\t.type = V4L2_CTRL_TYPE_CTRL_CLASS,\n};\n\nstatic const struct v4l2_ctrl_config vimc_debayer_ctrl_mean_win_size = {\n\t.ops = &vimc_debayer_ctrl_ops,\n\t.id = VIMC_CID_MEAN_WIN_SIZE,\n\t.name = \"Debayer Mean Window Size\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = 25,\n\t.step = 2,\n\t.def = 3,\n};\n\nstatic struct vimc_ent_device *vimc_debayer_add(struct vimc_device *vimc,\n\t\t\t\t\t\tconst char *vcfg_name)\n{\n\tstruct v4l2_device *v4l2_dev = &vimc->v4l2_dev;\n\tstruct vimc_debayer_device *vdebayer;\n\tint ret;\n\n\t \n\tvdebayer = kzalloc(sizeof(*vdebayer), GFP_KERNEL);\n\tif (!vdebayer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tv4l2_ctrl_handler_init(&vdebayer->hdl, 2);\n\tv4l2_ctrl_new_custom(&vdebayer->hdl, &vimc_debayer_ctrl_class, NULL);\n\tv4l2_ctrl_new_custom(&vdebayer->hdl, &vimc_debayer_ctrl_mean_win_size, NULL);\n\tvdebayer->sd.ctrl_handler = &vdebayer->hdl;\n\tif (vdebayer->hdl.error) {\n\t\tret = vdebayer->hdl.error;\n\t\tgoto err_free_vdebayer;\n\t}\n\n\t \n\tvdebayer->pads[0].flags = MEDIA_PAD_FL_SINK;\n\tvdebayer->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = vimc_ent_sd_register(&vdebayer->ved, &vdebayer->sd, v4l2_dev,\n\t\t\t\t   vcfg_name,\n\t\t\t\t   MEDIA_ENT_F_PROC_VIDEO_PIXEL_ENC_CONV, 2,\n\t\t\t\t   vdebayer->pads, &vimc_debayer_ops);\n\tif (ret)\n\t\tgoto err_free_hdl;\n\n\tvdebayer->ved.process_frame = vimc_debayer_process_frame;\n\tvdebayer->ved.dev = vimc->mdev.dev;\n\tvdebayer->mean_win_size = vimc_debayer_ctrl_mean_win_size.def;\n\n\t \n\tvdebayer->sink_fmt = sink_fmt_default;\n\t \n\tvdebayer->src_code = MEDIA_BUS_FMT_RGB888_1X24;\n\tvdebayer->set_rgb_src = vimc_debayer_process_rgb_frame;\n\n\treturn &vdebayer->ved;\n\nerr_free_hdl:\n\tv4l2_ctrl_handler_free(&vdebayer->hdl);\nerr_free_vdebayer:\n\tkfree(vdebayer);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct vimc_ent_type vimc_debayer_type = {\n\t.add = vimc_debayer_add,\n\t.release = vimc_debayer_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}