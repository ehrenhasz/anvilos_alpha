{
  "module_name": "vimc-common.c",
  "hash_id": "46e58836915a757294c73282c12d881a78cfb1a6c976b2fa1fdd2865851e18bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-common.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include \"vimc-common.h\"\n\n \nstatic const struct vimc_pix_map vimc_pix_map_list[] = {\n\t \n\n\t \n\t{\n\t\t.code = {\n\t\t\tMEDIA_BUS_FMT_BGR888_1X24,\n\t\t\tMEDIA_BUS_FMT_BGR888_3X8\n\t\t},\n\t\t.pixelformat = V4L2_PIX_FMT_BGR24,\n\t\t.bpp = 3,\n\t\t.bayer = false,\n\t},\n\t{\n\t\t.code = {\n\t\t\tMEDIA_BUS_FMT_RGB888_1X24,\n\t\t\tMEDIA_BUS_FMT_RGB888_2X12_BE,\n\t\t\tMEDIA_BUS_FMT_RGB888_2X12_LE,\n\t\t\tMEDIA_BUS_FMT_RGB888_3X8,\n\t\t\tMEDIA_BUS_FMT_RGB888_1X7X4_SPWG,\n\t\t\tMEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,\n\t\t\tMEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\t\tMEDIA_BUS_FMT_GBR888_1X24\n\t\t},\n\t\t.pixelformat = V4L2_PIX_FMT_RGB24,\n\t\t.bpp = 3,\n\t\t.bayer = false,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_ARGB8888_1X32 },\n\t\t.pixelformat = V4L2_PIX_FMT_ARGB32,\n\t\t.bpp = 4,\n\t\t.bayer = false,\n\t},\n\n\t \n\t{\n\t\t.code = { MEDIA_BUS_FMT_SBGGR8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGBRG8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGRBG8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SRGGB8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SBGGR10_1X10 },\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR10,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGBRG10_1X10 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG10,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGRBG10_1X10 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG10,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SRGGB10_1X10 },\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB10,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\n\t \n\t{\n\t\t.code = { MEDIA_BUS_FMT_SBGGR10_ALAW8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR10ALAW8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGBRG10_ALAW8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG10ALAW8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG10ALAW8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SRGGB10_ALAW8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB10ALAW8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\n\t \n\t{\n\t\t.code = { MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR10DPCM8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG10DPCM8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG10DPCM8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8 },\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB10DPCM8,\n\t\t.bpp = 1,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SBGGR12_1X12 },\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR12,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGBRG12_1X12 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG12,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SGRBG12_1X12 },\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG12,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n\t{\n\t\t.code = { MEDIA_BUS_FMT_SRGGB12_1X12 },\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB12,\n\t\t.bpp = 2,\n\t\t.bayer = true,\n\t},\n};\n\nbool vimc_is_source(struct media_entity *ent)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ent->num_pads; i++)\n\t\tif (ent->pads[i].flags & MEDIA_PAD_FL_SINK)\n\t\t\treturn false;\n\treturn true;\n}\n\nconst struct vimc_pix_map *vimc_pix_map_by_index(unsigned int i)\n{\n\tif (i >= ARRAY_SIZE(vimc_pix_map_list))\n\t\treturn NULL;\n\n\treturn &vimc_pix_map_list[i];\n}\n\nu32 vimc_mbus_code_by_index(unsigned int index)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(vimc_pix_map_list); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(vimc_pix_map_list[i].code); j++) {\n\t\t\tif (!vimc_pix_map_list[i].code[j])\n\t\t\t\tbreak;\n\n\t\t\tif (!index)\n\t\t\t\treturn vimc_pix_map_list[i].code[j];\n\t\t\tindex--;\n\t\t}\n\t}\n\treturn 0;\n}\n\nconst struct vimc_pix_map *vimc_pix_map_by_code(u32 code)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(vimc_pix_map_list); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(vimc_pix_map_list[i].code); j++) {\n\t\t\tif (vimc_pix_map_list[i].code[j] == code)\n\t\t\t\treturn &vimc_pix_map_list[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nconst struct vimc_pix_map *vimc_pix_map_by_pixelformat(u32 pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vimc_pix_map_list); i++) {\n\t\tif (vimc_pix_map_list[i].pixelformat == pixelformat)\n\t\t\treturn &vimc_pix_map_list[i];\n\t}\n\treturn NULL;\n}\n\nstatic int vimc_get_pix_format(struct media_pad *pad,\n\t\t\t       struct v4l2_pix_format *fmt)\n{\n\tif (is_media_entity_v4l2_subdev(pad->entity)) {\n\t\tstruct v4l2_subdev *sd =\n\t\t\tmedia_entity_to_v4l2_subdev(pad->entity);\n\t\tstruct v4l2_subdev_format sd_fmt = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t.pad = pad->index,\n\t\t};\n\t\tconst struct vimc_pix_map *pix_map;\n\t\tint ret;\n\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sd_fmt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tv4l2_fill_pix_format(fmt, &sd_fmt.format);\n\t\tpix_map = vimc_pix_map_by_code(sd_fmt.format.code);\n\t\tfmt->pixelformat = pix_map->pixelformat;\n\t} else if (is_media_entity_v4l2_video_device(pad->entity)) {\n\t\tstruct video_device *vdev = container_of(pad->entity,\n\t\t\t\t\t\t\t struct video_device,\n\t\t\t\t\t\t\t entity);\n\t\tstruct vimc_ent_device *ved = video_get_drvdata(vdev);\n\n\t\tif (!ved->vdev_get_format)\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tved->vdev_get_format(ved, fmt);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vimc_vdev_link_validate(struct media_link *link)\n{\n\tstruct v4l2_pix_format source_fmt, sink_fmt;\n\tint ret;\n\n\tret = vimc_get_pix_format(link->source, &source_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vimc_get_pix_format(link->sink, &sink_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"vimc link validate: \"\n\t\t\"%s:src:%dx%d (0x%x, %d, %d, %d, %d) \"\n\t\t\"%s:snk:%dx%d (0x%x, %d, %d, %d, %d)\\n\",\n\t\t \n\t\tlink->source->entity->name,\n\t\tsource_fmt.width, source_fmt.height,\n\t\tsource_fmt.pixelformat, source_fmt.colorspace,\n\t\tsource_fmt.quantization, source_fmt.xfer_func,\n\t\tsource_fmt.ycbcr_enc,\n\t\t \n\t\tlink->sink->entity->name,\n\t\tsink_fmt.width, sink_fmt.height,\n\t\tsink_fmt.pixelformat, sink_fmt.colorspace,\n\t\tsink_fmt.quantization, sink_fmt.xfer_func,\n\t\tsink_fmt.ycbcr_enc);\n\n\t \n\tif (source_fmt.width != sink_fmt.width ||\n\t    source_fmt.height != sink_fmt.height ||\n\t    source_fmt.pixelformat != sink_fmt.pixelformat)\n\t\treturn -EPIPE;\n\n\t \n\tif (source_fmt.field != sink_fmt.field &&\n\t    sink_fmt.field != V4L2_FIELD_NONE)\n\t\treturn -EPIPE;\n\n\t \n\tif (source_fmt.colorspace == V4L2_COLORSPACE_DEFAULT ||\n\t    sink_fmt.colorspace == V4L2_COLORSPACE_DEFAULT)\n\t\treturn 0;\n\n\t \n\tif (source_fmt.colorspace != sink_fmt.colorspace)\n\t\treturn -EPIPE;\n\n\t \n\tif (source_fmt.ycbcr_enc != V4L2_YCBCR_ENC_DEFAULT &&\n\t    sink_fmt.ycbcr_enc != V4L2_YCBCR_ENC_DEFAULT &&\n\t    source_fmt.ycbcr_enc != sink_fmt.ycbcr_enc)\n\t\treturn -EPIPE;\n\n\tif (source_fmt.quantization != V4L2_QUANTIZATION_DEFAULT &&\n\t    sink_fmt.quantization != V4L2_QUANTIZATION_DEFAULT &&\n\t    source_fmt.quantization != sink_fmt.quantization)\n\t\treturn -EPIPE;\n\n\tif (source_fmt.xfer_func != V4L2_XFER_FUNC_DEFAULT &&\n\t    sink_fmt.xfer_func != V4L2_XFER_FUNC_DEFAULT &&\n\t    source_fmt.xfer_func != sink_fmt.xfer_func)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations vimc_ent_sd_mops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nint vimc_ent_sd_register(struct vimc_ent_device *ved,\n\t\t\t struct v4l2_subdev *sd,\n\t\t\t struct v4l2_device *v4l2_dev,\n\t\t\t const char *const name,\n\t\t\t u32 function,\n\t\t\t u16 num_pads,\n\t\t\t struct media_pad *pads,\n\t\t\t const struct v4l2_subdev_ops *sd_ops)\n{\n\tint ret;\n\n\t \n\tved->ent = &sd->entity;\n\n\t \n\tv4l2_subdev_init(sd, sd_ops);\n\tsd->entity.function = function;\n\tsd->entity.ops = &vimc_ent_sd_mops;\n\tsd->owner = THIS_MODULE;\n\tstrscpy(sd->name, name, sizeof(sd->name));\n\tv4l2_set_subdevdata(sd, ved);\n\n\t \n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tif (sd->ctrl_handler)\n\t\tsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\t \n\tret = media_entity_pads_init(&sd->entity, num_pads, pads);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\tif (ret) {\n\t\tdev_err(v4l2_dev->dev,\n\t\t\t\"%s: subdev register failed (err=%d)\\n\",\n\t\t\tname, ret);\n\t\tgoto err_clean_m_ent;\n\t}\n\n\treturn 0;\n\nerr_clean_m_ent:\n\tmedia_entity_cleanup(&sd->entity);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}