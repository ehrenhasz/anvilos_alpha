{
  "module_name": "vimc-scaler.c",
  "hash_id": "ff33512980526fbfe56be8d6c688fb6c06813959f51df14c8c6f3b92f3dd59e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vimc/vimc-scaler.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/v4l2-mediabus.h>\n#include <media/v4l2-rect.h>\n#include <media/v4l2-subdev.h>\n\n#include \"vimc-common.h\"\n\n \nenum vic_sca_pad {\n\tVIMC_SCALER_SINK = 0,\n\tVIMC_SCALER_SRC = 1,\n};\n\n#define VIMC_SCALER_FMT_WIDTH_DEFAULT  640\n#define VIMC_SCALER_FMT_HEIGHT_DEFAULT 480\n\nstruct vimc_scaler_device {\n\tstruct vimc_ent_device ved;\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_rect crop_rect;\n\t \n\tstruct v4l2_mbus_framefmt fmt[2];\n\t \n\tu8 *src_frame;\n\tunsigned int bpp;\n\tstruct media_pad pads[2];\n};\n\nstatic const struct v4l2_mbus_framefmt fmt_default = {\n\t.width = VIMC_SCALER_FMT_WIDTH_DEFAULT,\n\t.height = VIMC_SCALER_FMT_HEIGHT_DEFAULT,\n\t.code = MEDIA_BUS_FMT_RGB888_1X24,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n};\n\nstatic const struct v4l2_rect crop_rect_default = {\n\t.width = VIMC_SCALER_FMT_WIDTH_DEFAULT,\n\t.height = VIMC_SCALER_FMT_HEIGHT_DEFAULT,\n\t.top = 0,\n\t.left = 0,\n};\n\nstatic const struct v4l2_rect crop_rect_min = {\n\t.width = VIMC_FRAME_MIN_WIDTH,\n\t.height = VIMC_FRAME_MIN_HEIGHT,\n\t.top = 0,\n\t.left = 0,\n};\n\nstatic struct v4l2_rect\nvimc_scaler_get_crop_bound_sink(const struct v4l2_mbus_framefmt *sink_fmt)\n{\n\t \n\tstruct v4l2_rect r = {\n\t\t.left = 0,\n\t\t.top = 0,\n\t\t.width = sink_fmt->width,\n\t\t.height = sink_fmt->height,\n\t};\n\treturn r;\n}\n\nstatic int vimc_scaler_init_cfg(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *mf;\n\tstruct v4l2_rect *r;\n\tunsigned int i;\n\n\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, i);\n\t\t*mf = fmt_default;\n\t}\n\n\tr = v4l2_subdev_get_try_crop(sd, sd_state, VIMC_SCALER_SINK);\n\t*r = crop_rect_default;\n\n\treturn 0;\n}\n\nstatic int vimc_scaler_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_mbus_code_enum *code)\n{\n\tu32 mbus_code = vimc_mbus_code_by_index(code->index);\n\tconst struct vimc_pix_map *vpix;\n\n\tif (!mbus_code)\n\t\treturn -EINVAL;\n\n\tvpix = vimc_pix_map_by_code(mbus_code);\n\n\t \n\tif (!vpix || vpix->bayer)\n\t\treturn -EINVAL;\n\n\tcode->code = mbus_code;\n\n\treturn 0;\n}\n\nstatic int vimc_scaler_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct vimc_pix_map *vpix;\n\n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\t \n\tvpix = vimc_pix_map_by_code(fse->code);\n\tif (!vpix || vpix->bayer)\n\t\treturn -EINVAL;\n\n\tfse->min_width = VIMC_FRAME_MIN_WIDTH;\n\tfse->min_height = VIMC_FRAME_MIN_HEIGHT;\n\n\tfse->max_width = VIMC_FRAME_MAX_WIDTH;\n\tfse->max_height = VIMC_FRAME_MAX_HEIGHT;\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\nvimc_scaler_pad_format(struct vimc_scaler_device *vscaler,\n\t\t    struct v4l2_subdev_state *sd_state, u32 pad,\n\t\t    enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&vscaler->sd, sd_state, pad);\n\telse\n\t\treturn &vscaler->fmt[pad];\n}\n\nstatic struct v4l2_rect *\nvimc_scaler_pad_crop(struct vimc_scaler_device *vscaler,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&vscaler->sd, sd_state,\n\t\t\t\t\t\tVIMC_SCALER_SINK);\n\telse\n\t\treturn &vscaler->crop_rect;\n}\n\nstatic int vimc_scaler_get_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct vimc_scaler_device *vscaler = v4l2_get_subdevdata(sd);\n\n\tformat->format = *vimc_scaler_pad_format(vscaler, sd_state, format->pad,\n\t\t\t\t\t      format->which);\n\treturn 0;\n}\n\nstatic int vimc_scaler_set_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct vimc_scaler_device *vscaler = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\t \n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE && vscaler->src_frame)\n\t\treturn -EBUSY;\n\n\tfmt = vimc_scaler_pad_format(vscaler, sd_state, format->pad, format->which);\n\n\t \n\tif (format->pad == VIMC_SCALER_SINK) {\n\t\tconst struct vimc_pix_map *vpix;\n\n\t\t \n\t\tvpix = vimc_pix_map_by_code(format->format.code);\n\t\tif (vpix && !vpix->bayer)\n\t\t\tfmt->code = format->format.code;\n\t\telse\n\t\t\tfmt->code = fmt_default.code;\n\n\t\t \n\t\tfmt->colorspace = format->format.colorspace;\n\t\tfmt->ycbcr_enc = format->format.ycbcr_enc;\n\t\tfmt->quantization = format->format.quantization;\n\t\tfmt->xfer_func = format->format.xfer_func;\n\t\tvimc_colorimetry_clamp(fmt);\n\t}\n\n\t \n\tfmt->width = clamp_t(u32, format->format.width, VIMC_FRAME_MIN_WIDTH,\n\t\t\t     VIMC_FRAME_MAX_WIDTH) & ~1;\n\tfmt->height = clamp_t(u32, format->format.height, VIMC_FRAME_MIN_HEIGHT,\n\t\t\t      VIMC_FRAME_MAX_HEIGHT) & ~1;\n\n\t \n\tif (format->pad == VIMC_SCALER_SINK) {\n\t\tstruct v4l2_mbus_framefmt *src_fmt;\n\t\tstruct v4l2_rect *crop;\n\n\t\tcrop = vimc_scaler_pad_crop(vscaler, sd_state, format->which);\n\t\tcrop->width = fmt->width;\n\t\tcrop->height = fmt->height;\n\t\tcrop->top = 0;\n\t\tcrop->left = 0;\n\n\t\tsrc_fmt = vimc_scaler_pad_format(vscaler, sd_state, VIMC_SCALER_SRC,\n\t\t\t\t\t      format->which);\n\t\t*src_fmt = *fmt;\n\t}\n\n\tformat->format = *fmt;\n\n\treturn 0;\n}\n\nstatic int vimc_scaler_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct vimc_scaler_device *vscaler = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\n\tif (VIMC_IS_SRC(sel->pad))\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *vimc_scaler_pad_crop(vscaler, sd_state, sel->which);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsink_fmt = vimc_scaler_pad_format(vscaler, sd_state, VIMC_SCALER_SINK,\n\t\t\t\t\t       sel->which);\n\t\tsel->r = vimc_scaler_get_crop_bound_sink(sink_fmt);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vimc_scaler_adjust_sink_crop(struct v4l2_rect *r,\n\t\t\t\t      const struct v4l2_mbus_framefmt *sink_fmt)\n{\n\tconst struct v4l2_rect sink_rect =\n\t\tvimc_scaler_get_crop_bound_sink(sink_fmt);\n\n\t \n\tv4l2_rect_set_min_size(r, &crop_rect_min);\n\tv4l2_rect_map_inside(r, &sink_rect);\n}\n\nstatic int vimc_scaler_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct vimc_scaler_device *vscaler = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_rect *crop_rect;\n\n\t \n\tif (VIMC_IS_SRC(sel->pad) || sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE && vscaler->src_frame)\n\t\treturn -EBUSY;\n\n\tcrop_rect = vimc_scaler_pad_crop(vscaler, sd_state, sel->which);\n\tsink_fmt = vimc_scaler_pad_format(vscaler, sd_state, VIMC_SCALER_SINK,\n\t\t\t\t       sel->which);\n\tvimc_scaler_adjust_sink_crop(&sel->r, sink_fmt);\n\t*crop_rect = sel->r;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops vimc_scaler_pad_ops = {\n\t.init_cfg\t\t= vimc_scaler_init_cfg,\n\t.enum_mbus_code\t\t= vimc_scaler_enum_mbus_code,\n\t.enum_frame_size\t= vimc_scaler_enum_frame_size,\n\t.get_fmt\t\t= vimc_scaler_get_fmt,\n\t.set_fmt\t\t= vimc_scaler_set_fmt,\n\t.get_selection\t\t= vimc_scaler_get_selection,\n\t.set_selection\t\t= vimc_scaler_set_selection,\n};\n\nstatic int vimc_scaler_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vimc_scaler_device *vscaler = v4l2_get_subdevdata(sd);\n\n\tif (enable) {\n\t\tconst struct vimc_pix_map *vpix;\n\t\tunsigned int frame_size;\n\n\t\tif (vscaler->src_frame)\n\t\t\treturn 0;\n\n\t\t \n\t\tvpix = vimc_pix_map_by_code(vscaler->fmt[VIMC_SCALER_SINK].code);\n\t\tvscaler->bpp = vpix->bpp;\n\n\t\t \n\t\tframe_size = vscaler->fmt[VIMC_SCALER_SRC].width\n\t\t\t   * vscaler->fmt[VIMC_SCALER_SRC].height * vscaler->bpp;\n\n\t\t \n\t\tvscaler->src_frame = vmalloc(frame_size);\n\t\tif (!vscaler->src_frame)\n\t\t\treturn -ENOMEM;\n\n\t} else {\n\t\tif (!vscaler->src_frame)\n\t\t\treturn 0;\n\n\t\tvfree(vscaler->src_frame);\n\t\tvscaler->src_frame = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops vimc_scaler_video_ops = {\n\t.s_stream = vimc_scaler_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops vimc_scaler_ops = {\n\t.pad = &vimc_scaler_pad_ops,\n\t.video = &vimc_scaler_video_ops,\n};\n\nstatic void vimc_scaler_fill_src_frame(const struct vimc_scaler_device *const vscaler,\n\t\t\t\t    const u8 *const sink_frame)\n{\n\tconst struct v4l2_mbus_framefmt *src_fmt = &vscaler->fmt[VIMC_SCALER_SRC];\n\tconst struct v4l2_rect *r = &vscaler->crop_rect;\n\tunsigned int snk_width = vscaler->fmt[VIMC_SCALER_SINK].width;\n\tunsigned int src_x, src_y;\n\tu8 *walker = vscaler->src_frame;\n\n\t \n\tfor (src_y = 0; src_y < src_fmt->height; src_y++) {\n\t\tunsigned int snk_y, y_offset;\n\n\t\tsnk_y = (src_y * r->height) / src_fmt->height + r->top;\n\t\ty_offset = snk_y * snk_width * vscaler->bpp;\n\n\t\tfor (src_x = 0; src_x < src_fmt->width; src_x++) {\n\t\t\tunsigned int snk_x, x_offset, index;\n\n\t\t\tsnk_x = (src_x * r->width) / src_fmt->width + r->left;\n\t\t\tx_offset = snk_x * vscaler->bpp;\n\t\t\tindex = y_offset + x_offset;\n\t\t\tmemcpy(walker, &sink_frame[index], vscaler->bpp);\n\t\t\twalker += vscaler->bpp;\n\t\t}\n\t}\n}\n\nstatic void *vimc_scaler_process_frame(struct vimc_ent_device *ved,\n\t\t\t\t    const void *sink_frame)\n{\n\tstruct vimc_scaler_device *vscaler = container_of(ved, struct vimc_scaler_device,\n\t\t\t\t\t\t    ved);\n\n\t \n\tif (!vscaler->src_frame)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tvimc_scaler_fill_src_frame(vscaler, sink_frame);\n\n\treturn vscaler->src_frame;\n};\n\nstatic void vimc_scaler_release(struct vimc_ent_device *ved)\n{\n\tstruct vimc_scaler_device *vscaler =\n\t\tcontainer_of(ved, struct vimc_scaler_device, ved);\n\n\tmedia_entity_cleanup(vscaler->ved.ent);\n\tkfree(vscaler);\n}\n\nstatic struct vimc_ent_device *vimc_scaler_add(struct vimc_device *vimc,\n\t\t\t\t\t    const char *vcfg_name)\n{\n\tstruct v4l2_device *v4l2_dev = &vimc->v4l2_dev;\n\tstruct vimc_scaler_device *vscaler;\n\tint ret;\n\n\t \n\tvscaler = kzalloc(sizeof(*vscaler), GFP_KERNEL);\n\tif (!vscaler)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tvscaler->pads[VIMC_SCALER_SINK].flags = MEDIA_PAD_FL_SINK;\n\tvscaler->pads[VIMC_SCALER_SRC].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = vimc_ent_sd_register(&vscaler->ved, &vscaler->sd, v4l2_dev,\n\t\t\t\t   vcfg_name,\n\t\t\t\t   MEDIA_ENT_F_PROC_VIDEO_SCALER, 2,\n\t\t\t\t   vscaler->pads, &vimc_scaler_ops);\n\tif (ret) {\n\t\tkfree(vscaler);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tvscaler->ved.process_frame = vimc_scaler_process_frame;\n\tvscaler->ved.dev = vimc->mdev.dev;\n\n\t \n\tvscaler->fmt[VIMC_SCALER_SINK] = fmt_default;\n\tvscaler->fmt[VIMC_SCALER_SRC] = fmt_default;\n\n\t \n\tvscaler->crop_rect = crop_rect_default;\n\n\treturn &vscaler->ved;\n}\n\nstruct vimc_ent_type vimc_scaler_type = {\n\t.add = vimc_scaler_add,\n\t.release = vimc_scaler_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}