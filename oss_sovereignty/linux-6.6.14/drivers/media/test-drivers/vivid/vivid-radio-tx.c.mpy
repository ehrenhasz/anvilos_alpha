{
  "module_name": "vivid-radio-tx.c",
  "hash_id": "4ccce50fc52a853c818ad07236126d7ceadae2d702da4d07e2a2a7cbd9421cb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-radio-tx.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-radio-common.h\"\n#include \"vivid-radio-tx.h\"\n\nssize_t vivid_radio_tx_write(struct file *file, const char __user *buf,\n\t\t\t  size_t size, loff_t *offset)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_rds_data *data = dev->rds_gen.data;\n\tktime_t timestamp;\n\tunsigned blk;\n\tint i;\n\n\tif (dev->radio_tx_rds_controls)\n\t\treturn -EINVAL;\n\n\tif (size < sizeof(*data))\n\t\treturn -EINVAL;\n\tsize = sizeof(*data) * (size / sizeof(*data));\n\n\tif (mutex_lock_interruptible(&dev->mutex))\n\t\treturn -ERESTARTSYS;\n\tif (dev->radio_tx_rds_owner &&\n\t    file->private_data != dev->radio_tx_rds_owner) {\n\t\tmutex_unlock(&dev->mutex);\n\t\treturn -EBUSY;\n\t}\n\tdev->radio_tx_rds_owner = file->private_data;\n\nretry:\n\ttimestamp = ktime_sub(ktime_get(), dev->radio_rds_init_time);\n\tblk = ktime_divns(timestamp, VIVID_RDS_NSEC_PER_BLK);\n\tif (blk - VIVID_RDS_GEN_BLOCKS >= dev->radio_tx_rds_last_block)\n\t\tdev->radio_tx_rds_last_block = blk - VIVID_RDS_GEN_BLOCKS + 1;\n\n\t \n\tif (blk == dev->radio_tx_rds_last_block ||\n\t    !(dev->radio_tx_subchans & V4L2_TUNER_SUB_RDS)) {\n\t\tmutex_unlock(&dev->mutex);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\t\tif (msleep_interruptible(20) && signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (mutex_lock_interruptible(&dev->mutex))\n\t\t\treturn -ERESTARTSYS;\n\t\tgoto retry;\n\t}\n\n\tfor (i = 0; i < size && blk > dev->radio_tx_rds_last_block;\n\t\t\tdev->radio_tx_rds_last_block++) {\n\t\tunsigned data_blk = dev->radio_tx_rds_last_block % VIVID_RDS_GEN_BLOCKS;\n\t\tstruct v4l2_rds_data rds;\n\n\t\tif (copy_from_user(&rds, buf + i, sizeof(rds))) {\n\t\t\ti = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ti += sizeof(rds);\n\t\tif (!dev->radio_rds_loop)\n\t\t\tcontinue;\n\t\tif ((rds.block & V4L2_RDS_BLOCK_MSK) == V4L2_RDS_BLOCK_INVALID ||\n\t\t    (rds.block & V4L2_RDS_BLOCK_ERROR))\n\t\t\tcontinue;\n\t\trds.block &= V4L2_RDS_BLOCK_MSK;\n\t\tdata[data_blk] = rds;\n\t}\n\tmutex_unlock(&dev->mutex);\n\treturn i;\n}\n\n__poll_t vivid_radio_tx_poll(struct file *file, struct poll_table_struct *wait)\n{\n\treturn EPOLLOUT | EPOLLWRNORM | v4l2_ctrl_poll(file, wait);\n}\n\nint vidioc_g_modulator(struct file *file, void *fh, struct v4l2_modulator *a)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (a->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(a->name, \"AM/FM/SW Transmitter\", sizeof(a->name));\n\ta->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_FREQ_BANDS | V4L2_TUNER_CAP_RDS |\n\t\t\t(dev->radio_tx_rds_controls ?\n\t\t\t\tV4L2_TUNER_CAP_RDS_CONTROLS :\n\t\t\t\tV4L2_TUNER_CAP_RDS_BLOCK_IO);\n\ta->rangelow = AM_FREQ_RANGE_LOW;\n\ta->rangehigh = FM_FREQ_RANGE_HIGH;\n\ta->txsubchans = dev->radio_tx_subchans;\n\treturn 0;\n}\n\nint vidioc_s_modulator(struct file *file, void *fh, const struct v4l2_modulator *a)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (a->index)\n\t\treturn -EINVAL;\n\tif (a->txsubchans & ~0x13)\n\t\treturn -EINVAL;\n\tdev->radio_tx_subchans = a->txsubchans;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}