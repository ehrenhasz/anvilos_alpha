{
  "module_name": "vivid-vbi-cap.c",
  "hash_id": "6e19c5f1bff1d0c8871b8771e71703030ae521ca4f4073d7ba8035ce8e36393f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-vbi-cap.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-kthread-cap.h\"\n#include \"vivid-vbi-cap.h\"\n#include \"vivid-vbi-gen.h\"\n\nstatic void vivid_sliced_vbi_cap_fill(struct vivid_dev *dev, unsigned seqnr)\n{\n\tstruct vivid_vbi_gen_data *vbi_gen = &dev->vbi_gen;\n\tbool is_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\n\tvivid_vbi_gen_sliced(vbi_gen, is_60hz, seqnr);\n\n\tif (!is_60hz) {\n\t\tif (dev->loop_video) {\n\t\t\tif (dev->vbi_out_have_wss) {\n\t\t\t\tvbi_gen->data[12].data[0] = dev->vbi_out_wss[0];\n\t\t\t\tvbi_gen->data[12].data[1] = dev->vbi_out_wss[1];\n\t\t\t} else {\n\t\t\t\tvbi_gen->data[12].id = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (tpg_g_video_aspect(&dev->tpg)) {\n\t\t\tcase TPG_VIDEO_ASPECT_14X9_CENTRE:\n\t\t\t\tvbi_gen->data[12].data[0] = 0x01;\n\t\t\t\tbreak;\n\t\t\tcase TPG_VIDEO_ASPECT_16X9_CENTRE:\n\t\t\t\tvbi_gen->data[12].data[0] = 0x0b;\n\t\t\t\tbreak;\n\t\t\tcase TPG_VIDEO_ASPECT_16X9_ANAMORPHIC:\n\t\t\t\tvbi_gen->data[12].data[0] = 0x07;\n\t\t\t\tbreak;\n\t\t\tcase TPG_VIDEO_ASPECT_4X3:\n\t\t\tdefault:\n\t\t\t\tvbi_gen->data[12].data[0] = 0x08;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (dev->loop_video && is_60hz) {\n\t\tif (dev->vbi_out_have_cc[0]) {\n\t\t\tvbi_gen->data[0].data[0] = dev->vbi_out_cc[0][0];\n\t\t\tvbi_gen->data[0].data[1] = dev->vbi_out_cc[0][1];\n\t\t} else {\n\t\t\tvbi_gen->data[0].id = 0;\n\t\t}\n\t\tif (dev->vbi_out_have_cc[1]) {\n\t\t\tvbi_gen->data[1].data[0] = dev->vbi_out_cc[1][0];\n\t\t\tvbi_gen->data[1].data[1] = dev->vbi_out_cc[1][1];\n\t\t} else {\n\t\t\tvbi_gen->data[1].id = 0;\n\t\t}\n\t}\n}\n\nstatic void vivid_g_fmt_vbi_cap(struct vivid_dev *dev, struct v4l2_vbi_format *vbi)\n{\n\tbool is_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\n\tvbi->sampling_rate = 27000000;\n\tvbi->offset = 24;\n\tvbi->samples_per_line = 1440;\n\tvbi->sample_format = V4L2_PIX_FMT_GREY;\n\tvbi->start[0] = is_60hz ? V4L2_VBI_ITU_525_F1_START + 9 : V4L2_VBI_ITU_625_F1_START + 5;\n\tvbi->start[1] = is_60hz ? V4L2_VBI_ITU_525_F2_START + 9 : V4L2_VBI_ITU_625_F2_START + 5;\n\tvbi->count[0] = vbi->count[1] = is_60hz ? 12 : 18;\n\tvbi->flags = dev->vbi_cap_interlaced ? V4L2_VBI_INTERLACED : 0;\n\tvbi->reserved[0] = 0;\n\tvbi->reserved[1] = 0;\n}\n\nvoid vivid_raw_vbi_cap_process(struct vivid_dev *dev, struct vivid_buffer *buf)\n{\n\tstruct v4l2_vbi_format vbi;\n\tu8 *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tvivid_g_fmt_vbi_cap(dev, &vbi);\n\tbuf->vb.sequence = dev->vbi_cap_seq_count;\n\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\tbuf->vb.sequence /= 2;\n\n\tvivid_sliced_vbi_cap_fill(dev, buf->vb.sequence);\n\n\tmemset(vbuf, 0x10, vb2_plane_size(&buf->vb.vb2_buf, 0));\n\n\tif (!VIVID_INVALID_SIGNAL(dev->std_signal_mode[dev->input]))\n\t\tvivid_vbi_gen_raw(&dev->vbi_gen, &vbi, vbuf);\n}\n\n\nvoid vivid_sliced_vbi_cap_process(struct vivid_dev *dev,\n\t\t\tstruct vivid_buffer *buf)\n{\n\tstruct v4l2_sliced_vbi_data *vbuf =\n\t\t\tvb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tbuf->vb.sequence = dev->vbi_cap_seq_count;\n\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\tbuf->vb.sequence /= 2;\n\n\tvivid_sliced_vbi_cap_fill(dev, buf->vb.sequence);\n\n\tmemset(vbuf, 0, vb2_plane_size(&buf->vb.vb2_buf, 0));\n\tif (!VIVID_INVALID_SIGNAL(dev->std_signal_mode[dev->input])) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < 25; i++)\n\t\t\tvbuf[i] = dev->vbi_gen.data[i];\n\t}\n}\n\nstatic int vbi_cap_queue_setup(struct vb2_queue *vq,\n\t\t       unsigned *nbuffers, unsigned *nplanes,\n\t\t       unsigned sizes[], struct device *alloc_devs[])\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tbool is_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\tunsigned size = vq->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ?\n\t\t36 * sizeof(struct v4l2_sliced_vbi_data) :\n\t\t1440 * 2 * (is_60hz ? 12 : 18);\n\n\tif (!vivid_is_sdtv_cap(dev))\n\t\treturn -EINVAL;\n\n\tsizes[0] = size;\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic int vbi_cap_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tbool is_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\tunsigned size = vb->vb2_queue->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ?\n\t\t36 * sizeof(struct v4l2_sliced_vbi_data) :\n\t\t1440 * 2 * (is_60hz ? 12 : 18);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(dev, 1, \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void vbi_cap_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->vbi_cap_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int vbi_cap_start_streaming(struct vb2_queue *vq, unsigned count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err;\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tdev->vbi_cap_seq_count = 0;\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = vivid_start_generating_vid_cap(dev, &dev->vbi_cap_streaming);\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dev->vbi_cap_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void vbi_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tvivid_stop_generating_vid_cap(dev, &dev->vbi_cap_streaming);\n}\n\nstatic void vbi_cap_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_vbi_cap);\n}\n\nconst struct vb2_ops vivid_vbi_cap_qops = {\n\t.queue_setup\t\t= vbi_cap_queue_setup,\n\t.buf_prepare\t\t= vbi_cap_buf_prepare,\n\t.buf_queue\t\t= vbi_cap_buf_queue,\n\t.start_streaming\t= vbi_cap_start_streaming,\n\t.stop_streaming\t\t= vbi_cap_stop_streaming,\n\t.buf_request_complete\t= vbi_cap_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_vbi_format *vbi = &f->fmt.vbi;\n\n\tif (!vivid_is_sdtv_cap(dev) || !dev->has_raw_vbi_cap)\n\t\treturn -EINVAL;\n\n\tvivid_g_fmt_vbi_cap(dev, vbi);\n\treturn 0;\n}\n\nint vidioc_s_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tint ret = vidioc_g_fmt_vbi_cap(file, priv, f);\n\n\tif (ret)\n\t\treturn ret;\n\tif (f->type != V4L2_BUF_TYPE_VBI_CAPTURE && vb2_is_busy(&dev->vb_vbi_cap_q))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nvoid vivid_fill_service_lines(struct v4l2_sliced_vbi_format *vbi, u32 service_set)\n{\n\tvbi->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\n\tvbi->service_set = service_set;\n\tmemset(vbi->service_lines, 0, sizeof(vbi->service_lines));\n\tmemset(vbi->reserved, 0, sizeof(vbi->reserved));\n\n\tif (vbi->service_set == 0)\n\t\treturn;\n\n\tif (vbi->service_set & V4L2_SLICED_CAPTION_525) {\n\t\tvbi->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\t\tvbi->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\t}\n\tif (vbi->service_set & V4L2_SLICED_WSS_625) {\n\t\tunsigned i;\n\n\t\tfor (i = 7; i <= 18; i++)\n\t\t\tvbi->service_lines[0][i] =\n\t\t\tvbi->service_lines[1][i] = V4L2_SLICED_TELETEXT_B;\n\t\tvbi->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t}\n}\n\nint vidioc_g_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\n\tif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap)\n\t\treturn -EINVAL;\n\n\tvivid_fill_service_lines(vbi, dev->service_set_cap);\n\treturn 0;\n}\n\nint vidioc_try_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\tbool is_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\tu32 service_set = vbi->service_set;\n\n\tif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap)\n\t\treturn -EINVAL;\n\n\tservice_set &= is_60hz ? V4L2_SLICED_CAPTION_525 :\n\t\t\t\t V4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\n\tvivid_fill_service_lines(vbi, service_set);\n\treturn 0;\n}\n\nint vidioc_s_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\tint ret = vidioc_try_fmt_sliced_vbi_cap(file, fh, fmt);\n\n\tif (ret)\n\t\treturn ret;\n\tif (fmt->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE && vb2_is_busy(&dev->vb_vbi_cap_q))\n\t\treturn -EBUSY;\n\tdev->service_set_cap = vbi->service_set;\n\treturn 0;\n}\n\nint vidioc_g_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_sliced_vbi_cap *cap)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\tbool is_60hz;\n\n\tif (vdev->vfl_dir == VFL_DIR_RX) {\n\t\tis_60hz = dev->std_cap[dev->input] & V4L2_STD_525_60;\n\t\tif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap ||\n\t\t    cap->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tis_60hz = dev->std_out & V4L2_STD_525_60;\n\t\tif (!vivid_is_svid_out(dev) || !dev->has_sliced_vbi_out ||\n\t\t    cap->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcap->service_set = is_60hz ? V4L2_SLICED_CAPTION_525 :\n\t\t\t\t     V4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\n\tif (is_60hz) {\n\t\tcap->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\t\tcap->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\t} else {\n\t\tunsigned i;\n\n\t\tfor (i = 7; i <= 18; i++)\n\t\t\tcap->service_lines[0][i] =\n\t\t\tcap->service_lines[1][i] = V4L2_SLICED_TELETEXT_B;\n\t\tcap->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}