{
  "module_name": "vivid-core.c",
  "hash_id": "46c76d8110e373d330006571686606cc9d0a669e7f0227e54583604aeedd4407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/font.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-vid-common.h\"\n#include \"vivid-vid-cap.h\"\n#include \"vivid-vid-out.h\"\n#include \"vivid-radio-common.h\"\n#include \"vivid-radio-rx.h\"\n#include \"vivid-radio-tx.h\"\n#include \"vivid-sdr-cap.h\"\n#include \"vivid-vbi-cap.h\"\n#include \"vivid-vbi-out.h\"\n#include \"vivid-osd.h\"\n#include \"vivid-cec.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-meta-cap.h\"\n#include \"vivid-meta-out.h\"\n#include \"vivid-touch-cap.h\"\n\n#define VIVID_MODULE_NAME \"vivid\"\n\n \n#define VIVID_MAX_DEVS CONFIG_VIDEO_VIVID_MAX_DEVS\n\nMODULE_DESCRIPTION(\"Virtual Video Test Driver\");\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned n_devs = 1;\nmodule_param(n_devs, uint, 0444);\nMODULE_PARM_DESC(n_devs, \" number of driver instances to create\");\n\nstatic int vid_cap_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(vid_cap_nr, int, NULL, 0444);\nMODULE_PARM_DESC(vid_cap_nr, \" videoX start number, -1 is autodetect\");\n\nstatic int vid_out_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(vid_out_nr, int, NULL, 0444);\nMODULE_PARM_DESC(vid_out_nr, \" videoX start number, -1 is autodetect\");\n\nstatic int vbi_cap_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(vbi_cap_nr, int, NULL, 0444);\nMODULE_PARM_DESC(vbi_cap_nr, \" vbiX start number, -1 is autodetect\");\n\nstatic int vbi_out_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(vbi_out_nr, int, NULL, 0444);\nMODULE_PARM_DESC(vbi_out_nr, \" vbiX start number, -1 is autodetect\");\n\nstatic int sdr_cap_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(sdr_cap_nr, int, NULL, 0444);\nMODULE_PARM_DESC(sdr_cap_nr, \" swradioX start number, -1 is autodetect\");\n\nstatic int radio_rx_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(radio_rx_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_rx_nr, \" radioX start number, -1 is autodetect\");\n\nstatic int radio_tx_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(radio_tx_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_tx_nr, \" radioX start number, -1 is autodetect\");\n\nstatic int meta_cap_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(meta_cap_nr, int, NULL, 0444);\nMODULE_PARM_DESC(meta_cap_nr, \" videoX start number, -1 is autodetect\");\n\nstatic int meta_out_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(meta_out_nr, int, NULL, 0444);\nMODULE_PARM_DESC(meta_out_nr, \" videoX start number, -1 is autodetect\");\n\nstatic int touch_cap_nr[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(touch_cap_nr, int, NULL, 0444);\nMODULE_PARM_DESC(touch_cap_nr, \" v4l-touchX start number, -1 is autodetect\");\n\nstatic int ccs_cap_mode[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(ccs_cap_mode, int, NULL, 0444);\nMODULE_PARM_DESC(ccs_cap_mode, \" capture crop/compose/scale mode:\\n\"\n\t\t\t   \"\\t\\t    bit 0=crop, 1=compose, 2=scale,\\n\"\n\t\t\t   \"\\t\\t    -1=user-controlled (default)\");\n\nstatic int ccs_out_mode[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = -1 };\nmodule_param_array(ccs_out_mode, int, NULL, 0444);\nMODULE_PARM_DESC(ccs_out_mode, \" output crop/compose/scale mode:\\n\"\n\t\t\t   \"\\t\\t    bit 0=crop, 1=compose, 2=scale,\\n\"\n\t\t\t   \"\\t\\t    -1=user-controlled (default)\");\n\nstatic unsigned multiplanar[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 1 };\nmodule_param_array(multiplanar, uint, NULL, 0444);\nMODULE_PARM_DESC(multiplanar, \" 1 (default) creates a single planar device, 2 creates a multiplanar device.\");\n\n \nstatic unsigned int node_types[VIVID_MAX_DEVS] = {\n\t[0 ... (VIVID_MAX_DEVS - 1)] = 0xe1d3d\n};\nmodule_param_array(node_types, uint, NULL, 0444);\nMODULE_PARM_DESC(node_types, \" node types, default is 0xe1d3d. Bitmask with the following meaning:\\n\"\n\t\t\t     \"\\t\\t    bit 0: Video Capture node\\n\"\n\t\t\t     \"\\t\\t    bit 2-3: VBI Capture node: 0 = none, 1 = raw vbi, 2 = sliced vbi, 3 = both\\n\"\n\t\t\t     \"\\t\\t    bit 4: Radio Receiver node\\n\"\n\t\t\t     \"\\t\\t    bit 5: Software Defined Radio Receiver node\\n\"\n\t\t\t     \"\\t\\t    bit 8: Video Output node\\n\"\n\t\t\t     \"\\t\\t    bit 10-11: VBI Output node: 0 = none, 1 = raw vbi, 2 = sliced vbi, 3 = both\\n\"\n\t\t\t     \"\\t\\t    bit 12: Radio Transmitter node\\n\"\n\t\t\t     \"\\t\\t    bit 16: Framebuffer for testing output overlays\\n\"\n\t\t\t     \"\\t\\t    bit 17: Metadata Capture node\\n\"\n\t\t\t     \"\\t\\t    bit 18: Metadata Output node\\n\"\n\t\t\t     \"\\t\\t    bit 19: Touch Capture node\\n\");\n\n \nstatic unsigned num_inputs[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 4 };\nmodule_param_array(num_inputs, uint, NULL, 0444);\nMODULE_PARM_DESC(num_inputs, \" number of inputs, default is 4\");\n\n \nstatic unsigned input_types[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 0xe4 };\nmodule_param_array(input_types, uint, NULL, 0444);\nMODULE_PARM_DESC(input_types, \" input types, default is 0xe4. Two bits per input,\\n\"\n\t\t\t      \"\\t\\t    bits 0-1 == input 0, bits 31-30 == input 15.\\n\"\n\t\t\t      \"\\t\\t    Type 0 == webcam, 1 == TV, 2 == S-Video, 3 == HDMI\");\n\n \nstatic unsigned num_outputs[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 2 };\nmodule_param_array(num_outputs, uint, NULL, 0444);\nMODULE_PARM_DESC(num_outputs, \" number of outputs, default is 2\");\n\n \nstatic unsigned output_types[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 2 };\nmodule_param_array(output_types, uint, NULL, 0444);\nMODULE_PARM_DESC(output_types, \" output types, default is 0x02. One bit per output,\\n\"\n\t\t\t      \"\\t\\t    bit 0 == output 0, bit 15 == output 15.\\n\"\n\t\t\t      \"\\t\\t    Type 0 == S-Video, 1 == HDMI\");\n\nunsigned vivid_debug;\nmodule_param(vivid_debug, uint, 0644);\nMODULE_PARM_DESC(vivid_debug, \" activates debug info\");\n\nstatic bool no_error_inj;\nmodule_param(no_error_inj, bool, 0444);\nMODULE_PARM_DESC(no_error_inj, \" if set disable the error injecting controls\");\n\nstatic unsigned int allocators[VIVID_MAX_DEVS] = { [0 ... (VIVID_MAX_DEVS - 1)] = 0 };\nmodule_param_array(allocators, uint, NULL, 0444);\nMODULE_PARM_DESC(allocators, \" memory allocator selection, default is 0.\\n\"\n\t\t\t     \"\\t\\t    0 == vmalloc\\n\"\n\t\t\t     \"\\t\\t    1 == dma-contig\");\n\nstatic unsigned int cache_hints[VIVID_MAX_DEVS] = {\n\t[0 ... (VIVID_MAX_DEVS - 1)] = 0\n};\nmodule_param_array(cache_hints, uint, NULL, 0444);\nMODULE_PARM_DESC(cache_hints, \" user-space cache hints, default is 0.\\n\"\n\t\t\t     \"\\t\\t    0 == forbid\\n\"\n\t\t\t     \"\\t\\t    1 == allow\");\n\nstatic unsigned int supports_requests[VIVID_MAX_DEVS] = {\n\t[0 ... (VIVID_MAX_DEVS - 1)] = 1\n};\nmodule_param_array(supports_requests, uint, NULL, 0444);\nMODULE_PARM_DESC(supports_requests, \" support for requests, default is 1.\\n\"\n\t\t\t     \"\\t\\t    0 == no support\\n\"\n\t\t\t     \"\\t\\t    1 == supports requests\\n\"\n\t\t\t     \"\\t\\t    2 == requires requests\");\n\nstatic struct vivid_dev *vivid_devs[VIVID_MAX_DEVS];\n\nconst struct v4l2_rect vivid_min_rect = {\n\t0, 0, MIN_WIDTH, MIN_HEIGHT\n};\n\nconst struct v4l2_rect vivid_max_rect = {\n\t0, 0, MAX_WIDTH * MAX_ZOOM, MAX_HEIGHT * MAX_ZOOM\n};\n\nstatic const u8 vivid_hdmi_edid[256] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,\n\t0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,\n\t0x22, 0x1a, 0x01, 0x03, 0x80, 0x60, 0x36, 0x78,\n\t0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,\n\t0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,\n\t0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,\n\t0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x08, 0xe8,\n\t0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,\n\t0x8a, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1e,\n\t0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,\n\t0x87, 0x3c, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x76,\n\t0x69, 0x76, 0x69, 0x64, 0x0a, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7b,\n\n\t0x02, 0x03, 0x3f, 0xf1, 0x51, 0x61, 0x60, 0x5f,\n\t0x5e, 0x5d, 0x10, 0x1f, 0x04, 0x13, 0x22, 0x21,\n\t0x20, 0x05, 0x14, 0x02, 0x11, 0x01, 0x23, 0x09,\n\t0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d, 0x03,\n\t0x0c, 0x00, 0x10, 0x00, 0x00, 0x3c, 0x21, 0x00,\n\t0x60, 0x01, 0x02, 0x03, 0x67, 0xd8, 0x5d, 0xc4,\n\t0x01, 0x78, 0x00, 0x00, 0xe2, 0x00, 0xca, 0xe3,\n\t0x05, 0x00, 0x00, 0xe3, 0x06, 0x01, 0x00, 0x4d,\n\t0xd0, 0x00, 0xa0, 0xf0, 0x70, 0x3e, 0x80, 0x30,\n\t0x20, 0x35, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00,\n\t0x1e, 0x1a, 0x36, 0x80, 0xa0, 0x70, 0x38, 0x1f,\n\t0x40, 0x30, 0x20, 0x35, 0x00, 0xc0, 0x1c, 0x32,\n\t0x00, 0x00, 0x1a, 0x1a, 0x1d, 0x00, 0x80, 0x51,\n\t0xd0, 0x1c, 0x20, 0x40, 0x80, 0x35, 0x00, 0xc0,\n\t0x1c, 0x32, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82,\n};\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"vivid\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"vivid\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t\t\"platform:%s\", dev->v4l2_dev.name);\n\n\tcap->capabilities = dev->vid_cap_caps | dev->vid_out_caps |\n\t\tdev->vbi_cap_caps | dev->vbi_out_caps |\n\t\tdev->radio_rx_caps | dev->radio_tx_caps |\n\t\tdev->sdr_cap_caps | dev->meta_cap_caps |\n\t\tdev->meta_out_caps | dev->touch_cap_caps |\n\t\tV4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *fh, const struct v4l2_hw_freq_seek *a)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_rx_s_hw_freq_seek(file, fh, a);\n\treturn -ENOTTY;\n}\n\nstatic int vidioc_enum_freq_bands(struct file *file, void *fh, struct v4l2_frequency_band *band)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_rx_enum_freq_bands(file, fh, band);\n\tif (vdev->vfl_type == VFL_TYPE_SDR)\n\t\treturn vivid_sdr_enum_freq_bands(file, fh, band);\n\treturn -ENOTTY;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_rx_g_tuner(file, fh, vt);\n\tif (vdev->vfl_type == VFL_TYPE_SDR)\n\t\treturn vivid_sdr_g_tuner(file, fh, vt);\n\treturn vivid_video_g_tuner(file, fh, vt);\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_rx_s_tuner(file, fh, vt);\n\tif (vdev->vfl_type == VFL_TYPE_SDR)\n\t\treturn vivid_sdr_s_tuner(file, fh, vt);\n\treturn vivid_video_s_tuner(file, fh, vt);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *vf)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_g_frequency(file,\n\t\t\tvdev->vfl_dir == VFL_DIR_RX ?\n\t\t\t&dev->radio_rx_freq : &dev->radio_tx_freq, vf);\n\tif (vdev->vfl_type == VFL_TYPE_SDR)\n\t\treturn vivid_sdr_g_frequency(file, fh, vf);\n\treturn vivid_video_g_frequency(file, fh, vf);\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO)\n\t\treturn vivid_radio_s_frequency(file,\n\t\t\tvdev->vfl_dir == VFL_DIR_RX ?\n\t\t\t&dev->radio_rx_freq : &dev->radio_tx_freq, vf);\n\tif (vdev->vfl_type == VFL_TYPE_SDR)\n\t\treturn vivid_sdr_s_frequency(file, fh, vf);\n\treturn vivid_video_s_frequency(file, fh, vf);\n}\n\nstatic int vidioc_overlay(struct file *file, void *fh, unsigned i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn -ENOTTY;\n\treturn vivid_vid_out_overlay(file, fh, i);\n}\n\nstatic int vidioc_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *a)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn -ENOTTY;\n\treturn vivid_vid_out_g_fbuf(file, fh, a);\n}\n\nstatic int vidioc_s_fbuf(struct file *file, void *fh, const struct v4l2_framebuffer *a)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn -ENOTTY;\n\treturn vivid_vid_out_s_fbuf(file, fh, a);\n}\n\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id id)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_s_std(file, fh, id);\n\treturn vivid_vid_out_s_std(file, fh, id);\n}\n\nstatic int vidioc_s_dv_timings(struct file *file, void *fh, struct v4l2_dv_timings *timings)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_s_dv_timings(file, fh, timings);\n\treturn vivid_vid_out_s_dv_timings(file, fh, timings);\n}\n\nstatic int vidioc_g_pixelaspect(struct file *file, void *fh,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_g_pixelaspect(file, fh, type, f);\n\treturn vivid_vid_out_g_pixelaspect(file, fh, type, f);\n}\n\nstatic int vidioc_g_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_g_selection(file, fh, sel);\n\treturn vivid_vid_out_g_selection(file, fh, sel);\n}\n\nstatic int vidioc_s_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_s_selection(file, fh, sel);\n\treturn vivid_vid_out_s_selection(file, fh, sel);\n}\n\nstatic int vidioc_g_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *parm)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_parm_tch(file, fh, parm);\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_g_parm(file, fh, parm);\n\treturn vivid_vid_out_g_parm(file, fh, parm);\n}\n\nstatic int vidioc_s_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *parm)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_vid_cap_s_parm(file, fh, parm);\n\treturn -ENOTTY;\n}\n\nstatic int vidioc_log_status(struct file *file, void *fh)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tv4l2_ctrl_log_status(file, fh);\n\tif (vdev->vfl_dir == VFL_DIR_RX && vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\ttpg_log_status(&dev->tpg);\n\treturn 0;\n}\n\nstatic ssize_t vivid_radio_read(struct file *file, char __user *buf,\n\t\t\t size_t size, loff_t *offset)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_TX)\n\t\treturn -EINVAL;\n\treturn vivid_radio_rx_read(file, buf, size, offset);\n}\n\nstatic ssize_t vivid_radio_write(struct file *file, const char __user *buf,\n\t\t\t  size_t size, loff_t *offset)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn -EINVAL;\n\treturn vivid_radio_tx_write(file, buf, size, offset);\n}\n\nstatic __poll_t vivid_radio_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\treturn vivid_radio_rx_poll(file, wait);\n\treturn vivid_radio_tx_poll(file, wait);\n}\n\nstatic int vivid_enum_input(struct file *file, void *priv,\n\t\t\t    struct v4l2_input *inp)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_enum_input_tch(file, priv, inp);\n\treturn vidioc_enum_input(file, priv, inp);\n}\n\nstatic int vivid_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_input_tch(file, priv, i);\n\treturn vidioc_g_input(file, priv, i);\n}\n\nstatic int vivid_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_s_input_tch(file, priv, i);\n\treturn vidioc_s_input(file, priv, i);\n}\n\nstatic int vivid_enum_fmt_cap(struct file *file, void  *priv,\n\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_enum_fmt_tch(file, priv, f);\n\treturn vivid_enum_fmt_vid(file, priv, f);\n}\n\nstatic int vivid_g_fmt_cap(struct file *file, void *priv,\n\t\t\t   struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch(file, priv, f);\n\treturn vidioc_g_fmt_vid_cap(file, priv, f);\n}\n\nstatic int vivid_try_fmt_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch(file, priv, f);\n\treturn vidioc_try_fmt_vid_cap(file, priv, f);\n}\n\nstatic int vivid_s_fmt_cap(struct file *file, void *priv,\n\t\t\t   struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch(file, priv, f);\n\treturn vidioc_s_fmt_vid_cap(file, priv, f);\n}\n\nstatic int vivid_g_fmt_cap_mplane(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch_mplane(file, priv, f);\n\treturn vidioc_g_fmt_vid_cap_mplane(file, priv, f);\n}\n\nstatic int vivid_try_fmt_cap_mplane(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch_mplane(file, priv, f);\n\treturn vidioc_try_fmt_vid_cap_mplane(file, priv, f);\n}\n\nstatic int vivid_s_fmt_cap_mplane(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vdev->vfl_type == VFL_TYPE_TOUCH)\n\t\treturn vivid_g_fmt_tch_mplane(file, priv, f);\n\treturn vidioc_s_fmt_vid_cap_mplane(file, priv, f);\n}\n\nstatic bool vivid_is_in_use(bool valid, struct video_device *vdev)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tif (!valid)\n\t\treturn false;\n\tspin_lock_irqsave(&vdev->fh_lock, flags);\n\tres = !list_empty(&vdev->fh_list);\n\tspin_unlock_irqrestore(&vdev->fh_lock, flags);\n\treturn res;\n}\n\nstatic bool vivid_is_last_user(struct vivid_dev *dev)\n{\n\tunsigned int uses =\n\t\tvivid_is_in_use(dev->has_vid_cap, &dev->vid_cap_dev) +\n\t\tvivid_is_in_use(dev->has_vid_out, &dev->vid_out_dev) +\n\t\tvivid_is_in_use(dev->has_vbi_cap, &dev->vbi_cap_dev) +\n\t\tvivid_is_in_use(dev->has_vbi_out, &dev->vbi_out_dev) +\n\t\tvivid_is_in_use(dev->has_radio_rx, &dev->radio_rx_dev) +\n\t\tvivid_is_in_use(dev->has_radio_tx, &dev->radio_tx_dev) +\n\t\tvivid_is_in_use(dev->has_sdr_cap, &dev->sdr_cap_dev) +\n\t\tvivid_is_in_use(dev->has_meta_cap, &dev->meta_cap_dev) +\n\t\tvivid_is_in_use(dev->has_meta_out, &dev->meta_out_dev) +\n\t\tvivid_is_in_use(dev->has_touch_cap, &dev->touch_cap_dev);\n\n\treturn uses == 1;\n}\n\nstatic void vivid_reconnect(struct vivid_dev *dev)\n{\n\tif (dev->has_vid_cap)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->vid_cap_dev.flags);\n\tif (dev->has_vid_out)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->vid_out_dev.flags);\n\tif (dev->has_vbi_cap)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->vbi_cap_dev.flags);\n\tif (dev->has_vbi_out)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->vbi_out_dev.flags);\n\tif (dev->has_radio_rx)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->radio_rx_dev.flags);\n\tif (dev->has_radio_tx)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->radio_tx_dev.flags);\n\tif (dev->has_sdr_cap)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->sdr_cap_dev.flags);\n\tif (dev->has_meta_cap)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->meta_cap_dev.flags);\n\tif (dev->has_meta_out)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->meta_out_dev.flags);\n\tif (dev->has_touch_cap)\n\t\tset_bit(V4L2_FL_REGISTERED, &dev->touch_cap_dev.flags);\n\tdev->disconnect_error = false;\n}\n\nstatic int vivid_fop_release(struct file *file)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tmutex_lock(&dev->mutex);\n\tif (!no_error_inj && v4l2_fh_is_singular_file(file) &&\n\t    dev->disconnect_error && !video_is_registered(vdev) &&\n\t    vivid_is_last_user(dev)) {\n\t\t \n\t\tv4l2_info(&dev->v4l2_dev, \"reconnect\\n\");\n\t\tvivid_reconnect(dev);\n\t}\n\tif (file->private_data == dev->radio_rx_rds_owner) {\n\t\tdev->radio_rx_rds_last_block = 0;\n\t\tdev->radio_rx_rds_owner = NULL;\n\t}\n\tif (file->private_data == dev->radio_tx_rds_owner) {\n\t\tdev->radio_tx_rds_last_block = 0;\n\t\tdev->radio_tx_rds_owner = NULL;\n\t}\n\tmutex_unlock(&dev->mutex);\n\tif (vdev->queue)\n\t\treturn vb2_fop_release(file);\n\treturn v4l2_fh_release(file);\n}\n\nstatic const struct v4l2_file_operations vivid_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = vivid_fop_release,\n\t.read           = vb2_fop_read,\n\t.write          = vb2_fop_write,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_file_operations vivid_radio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = vivid_fop_release,\n\t.read           = vivid_radio_read,\n\t.write          = vivid_radio_write,\n\t.poll\t\t= vivid_radio_poll,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic int vidioc_reqbufs(struct file *file, void *priv,\n\t\t\t  struct v4l2_requestbuffers *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tint r;\n\n\t \n\tif (p->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ||\n\t    p->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\n\t\tr = vb2_queue_change_type(vdev->queue, p->type);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn vb2_ioctl_reqbufs(file, priv, p);\n}\n\nstatic int vidioc_create_bufs(struct file *file, void *priv,\n\t\t\t      struct v4l2_create_buffers *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tint r;\n\n\t \n\tif (p->format.type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ||\n\t    p->format.type == V4L2_BUF_TYPE_VBI_CAPTURE) {\n\t\tr = vb2_queue_change_type(vdev->queue, p->format.type);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn vb2_ioctl_create_bufs(file, priv, p);\n}\n\nstatic const struct v4l2_ioctl_ops vivid_ioctl_ops = {\n\t.vidioc_querycap\t\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= vivid_enum_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= vivid_g_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= vivid_try_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= vivid_s_fmt_cap,\n\t.vidioc_g_fmt_vid_cap_mplane\t= vivid_g_fmt_cap_mplane,\n\t.vidioc_try_fmt_vid_cap_mplane\t= vivid_try_fmt_cap_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= vivid_s_fmt_cap_mplane,\n\n\t.vidioc_enum_fmt_vid_out\t= vivid_enum_fmt_vid,\n\t.vidioc_g_fmt_vid_out\t\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= vidioc_s_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out_mplane\t= vidioc_g_fmt_vid_out_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= vidioc_try_fmt_vid_out_mplane,\n\t.vidioc_s_fmt_vid_out_mplane\t= vidioc_s_fmt_vid_out_mplane,\n\n\t.vidioc_g_selection\t\t= vidioc_g_selection,\n\t.vidioc_s_selection\t\t= vidioc_s_selection,\n\t.vidioc_g_pixelaspect\t\t= vidioc_g_pixelaspect,\n\n\t.vidioc_g_fmt_vbi_cap\t\t= vidioc_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap\t\t= vidioc_g_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap\t\t= vidioc_s_fmt_vbi_cap,\n\n\t.vidioc_g_fmt_sliced_vbi_cap    = vidioc_g_fmt_sliced_vbi_cap,\n\t.vidioc_try_fmt_sliced_vbi_cap  = vidioc_try_fmt_sliced_vbi_cap,\n\t.vidioc_s_fmt_sliced_vbi_cap    = vidioc_s_fmt_sliced_vbi_cap,\n\t.vidioc_g_sliced_vbi_cap\t= vidioc_g_sliced_vbi_cap,\n\n\t.vidioc_g_fmt_vbi_out\t\t= vidioc_g_fmt_vbi_out,\n\t.vidioc_try_fmt_vbi_out\t\t= vidioc_g_fmt_vbi_out,\n\t.vidioc_s_fmt_vbi_out\t\t= vidioc_s_fmt_vbi_out,\n\n\t.vidioc_g_fmt_sliced_vbi_out    = vidioc_g_fmt_sliced_vbi_out,\n\t.vidioc_try_fmt_sliced_vbi_out  = vidioc_try_fmt_sliced_vbi_out,\n\t.vidioc_s_fmt_sliced_vbi_out    = vidioc_s_fmt_sliced_vbi_out,\n\n\t.vidioc_enum_fmt_sdr_cap\t= vidioc_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap\t\t= vidioc_g_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap\t\t= vidioc_try_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap\t\t= vidioc_s_fmt_sdr_cap,\n\n\t.vidioc_overlay\t\t\t= vidioc_overlay,\n\t.vidioc_enum_framesizes\t\t= vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= vidioc_enum_frameintervals,\n\t.vidioc_g_parm\t\t\t= vidioc_g_parm,\n\t.vidioc_s_parm\t\t\t= vidioc_s_parm,\n\n\t.vidioc_g_fmt_vid_out_overlay\t= vidioc_g_fmt_vid_out_overlay,\n\t.vidioc_try_fmt_vid_out_overlay\t= vidioc_try_fmt_vid_out_overlay,\n\t.vidioc_s_fmt_vid_out_overlay\t= vidioc_s_fmt_vid_out_overlay,\n\t.vidioc_g_fbuf\t\t\t= vidioc_g_fbuf,\n\t.vidioc_s_fbuf\t\t\t= vidioc_s_fbuf,\n\n\t.vidioc_reqbufs\t\t\t= vidioc_reqbufs,\n\t.vidioc_create_bufs\t\t= vidioc_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_enum_input\t\t= vivid_enum_input,\n\t.vidioc_g_input\t\t\t= vivid_g_input,\n\t.vidioc_s_input\t\t\t= vivid_s_input,\n\t.vidioc_s_audio\t\t\t= vidioc_s_audio,\n\t.vidioc_g_audio\t\t\t= vidioc_g_audio,\n\t.vidioc_enumaudio\t\t= vidioc_enumaudio,\n\t.vidioc_s_frequency\t\t= vidioc_s_frequency,\n\t.vidioc_g_frequency\t\t= vidioc_g_frequency,\n\t.vidioc_s_tuner\t\t\t= vidioc_s_tuner,\n\t.vidioc_g_tuner\t\t\t= vidioc_g_tuner,\n\t.vidioc_s_modulator\t\t= vidioc_s_modulator,\n\t.vidioc_g_modulator\t\t= vidioc_g_modulator,\n\t.vidioc_s_hw_freq_seek\t\t= vidioc_s_hw_freq_seek,\n\t.vidioc_enum_freq_bands\t\t= vidioc_enum_freq_bands,\n\n\t.vidioc_enum_output\t\t= vidioc_enum_output,\n\t.vidioc_g_output\t\t= vidioc_g_output,\n\t.vidioc_s_output\t\t= vidioc_s_output,\n\t.vidioc_s_audout\t\t= vidioc_s_audout,\n\t.vidioc_g_audout\t\t= vidioc_g_audout,\n\t.vidioc_enumaudout\t\t= vidioc_enumaudout,\n\n\t.vidioc_querystd\t\t= vidioc_querystd,\n\t.vidioc_g_std\t\t\t= vidioc_g_std,\n\t.vidioc_s_std\t\t\t= vidioc_s_std,\n\t.vidioc_s_dv_timings\t\t= vidioc_s_dv_timings,\n\t.vidioc_g_dv_timings\t\t= vidioc_g_dv_timings,\n\t.vidioc_query_dv_timings\t= vidioc_query_dv_timings,\n\t.vidioc_enum_dv_timings\t\t= vidioc_enum_dv_timings,\n\t.vidioc_dv_timings_cap\t\t= vidioc_dv_timings_cap,\n\t.vidioc_g_edid\t\t\t= vidioc_g_edid,\n\t.vidioc_s_edid\t\t\t= vidioc_s_edid,\n\n\t.vidioc_log_status\t\t= vidioc_log_status,\n\t.vidioc_subscribe_event\t\t= vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_enum_fmt_meta_cap\t= vidioc_enum_fmt_meta_cap,\n\t.vidioc_g_fmt_meta_cap\t\t= vidioc_g_fmt_meta_cap,\n\t.vidioc_s_fmt_meta_cap\t\t= vidioc_g_fmt_meta_cap,\n\t.vidioc_try_fmt_meta_cap\t= vidioc_g_fmt_meta_cap,\n\n\t.vidioc_enum_fmt_meta_out       = vidioc_enum_fmt_meta_out,\n\t.vidioc_g_fmt_meta_out          = vidioc_g_fmt_meta_out,\n\t.vidioc_s_fmt_meta_out          = vidioc_g_fmt_meta_out,\n\t.vidioc_try_fmt_meta_out        = vidioc_g_fmt_meta_out,\n};\n\n \n\nstatic void vivid_dev_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct vivid_dev *dev = container_of(v4l2_dev, struct vivid_dev, v4l2_dev);\n\n\tvivid_free_controls(dev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_cleanup(&dev->mdev);\n#endif\n\tvfree(dev->scaled_line);\n\tvfree(dev->blended_line);\n\tvfree(dev->edid);\n\ttpg_free(&dev->tpg);\n\tkfree(dev->query_dv_timings_qmenu);\n\tkfree(dev->query_dv_timings_qmenu_strings);\n\tkfree(dev);\n}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nstatic int vivid_req_validate(struct media_request *req)\n{\n\tstruct vivid_dev *dev = container_of(req->mdev, struct vivid_dev, mdev);\n\n\tif (dev->req_validate_error) {\n\t\tdev->req_validate_error = false;\n\t\treturn -EINVAL;\n\t}\n\treturn vb2_request_validate(req);\n}\n\nstatic const struct media_device_ops vivid_media_ops = {\n\t.req_validate = vivid_req_validate,\n\t.req_queue = vb2_request_queue,\n};\n#endif\n\nstatic int vivid_create_queue(struct vivid_dev *dev,\n\t\t\t      struct vb2_queue *q,\n\t\t\t      u32 buf_type,\n\t\t\t      unsigned int min_buffers_needed,\n\t\t\t      const struct vb2_ops *ops)\n{\n\tif (buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE && dev->multiplanar)\n\t\tbuf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\telse if (buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT && dev->multiplanar)\n\t\tbuf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\telse if (buf_type == V4L2_BUF_TYPE_VBI_CAPTURE && !dev->has_raw_vbi_cap)\n\t\tbuf_type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\n\telse if (buf_type == V4L2_BUF_TYPE_VBI_OUTPUT && !dev->has_raw_vbi_out)\n\t\tbuf_type = V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;\n\n\tq->type = buf_type;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->io_modes |= V4L2_TYPE_IS_OUTPUT(buf_type) ?  VB2_WRITE : VB2_READ;\n\tif (allocators[dev->inst] != 1)\n\t\tq->io_modes |= VB2_USERPTR;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct vivid_buffer);\n\tq->ops = ops;\n\tq->mem_ops = allocators[dev->inst] == 1 ? &vb2_dma_contig_memops :\n\t\t\t\t\t\t  &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = supports_requests[dev->inst] ? 0 : min_buffers_needed;\n\tq->lock = &dev->mutex;\n\tq->dev = dev->v4l2_dev.dev;\n\tq->supports_requests = supports_requests[dev->inst];\n\tq->requires_requests = supports_requests[dev->inst] >= 2;\n\tq->allow_cache_hints = (cache_hints[dev->inst] == 1);\n\n\treturn vb2_queue_init(q);\n}\n\nstatic int vivid_detect_feature_set(struct vivid_dev *dev, int inst,\n\t\t\t\t    unsigned node_type,\n\t\t\t\t    bool *has_tuner,\n\t\t\t\t    bool *has_modulator,\n\t\t\t\t    int *ccs_cap,\n\t\t\t\t    int *ccs_out,\n\t\t\t\t    unsigned in_type_counter[4],\n\t\t\t\t    unsigned out_type_counter[4])\n{\n\tint i;\n\n\t \n\tdev->multiplanar = multiplanar[inst] > 1;\n\tv4l2_info(&dev->v4l2_dev, \"using %splanar format API\\n\",\n\t\t\tdev->multiplanar ? \"multi\" : \"single \");\n\n\t \n\tdev->num_inputs = num_inputs[inst];\n\tif (node_type & 0x20007) {\n\t\tif (dev->num_inputs < 1)\n\t\t\tdev->num_inputs = 1;\n\t} else {\n\t\tdev->num_inputs = 0;\n\t}\n\tif (dev->num_inputs >= MAX_INPUTS)\n\t\tdev->num_inputs = MAX_INPUTS;\n\tfor (i = 0; i < dev->num_inputs; i++) {\n\t\tdev->input_type[i] = (input_types[inst] >> (i * 2)) & 0x3;\n\t\tdev->input_name_counter[i] = in_type_counter[dev->input_type[i]]++;\n\t}\n\tdev->has_audio_inputs = in_type_counter[TV] && in_type_counter[SVID];\n\tif (in_type_counter[HDMI] == 16) {\n\t\t \n\t\tin_type_counter[HDMI]--;\n\t\tdev->num_inputs--;\n\t}\n\tdev->num_hdmi_inputs = in_type_counter[HDMI];\n\n\t \n\tdev->num_outputs = num_outputs[inst];\n\tif (node_type & 0x40300) {\n\t\tif (dev->num_outputs < 1)\n\t\t\tdev->num_outputs = 1;\n\t} else {\n\t\tdev->num_outputs = 0;\n\t}\n\tif (dev->num_outputs >= MAX_OUTPUTS)\n\t\tdev->num_outputs = MAX_OUTPUTS;\n\tfor (i = 0; i < dev->num_outputs; i++) {\n\t\tdev->output_type[i] = ((output_types[inst] >> i) & 1) ? HDMI : SVID;\n\t\tdev->output_name_counter[i] = out_type_counter[dev->output_type[i]]++;\n\t\tdev->display_present[i] = true;\n\t}\n\tdev->has_audio_outputs = out_type_counter[SVID];\n\tif (out_type_counter[HDMI] == 16) {\n\t\t \n\t\tout_type_counter[HDMI]--;\n\t\tdev->num_outputs--;\n\t}\n\tdev->num_hdmi_outputs = out_type_counter[HDMI];\n\n\t \n\tdev->has_vid_cap = node_type & 0x0001;\n\n\t \n\tif (in_type_counter[TV] || in_type_counter[SVID]) {\n\t\tdev->has_raw_vbi_cap = node_type & 0x0004;\n\t\tdev->has_sliced_vbi_cap = node_type & 0x0008;\n\t\tdev->has_vbi_cap = dev->has_raw_vbi_cap | dev->has_sliced_vbi_cap;\n\t}\n\n\t \n\tdev->has_meta_cap = node_type & 0x20000;\n\n\t \n\tif ((in_type_counter[WEBCAM] || in_type_counter[HDMI]) &&\n\t    !dev->has_vid_cap && !dev->has_meta_cap) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"Webcam or HDMI input without video or metadata nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((in_type_counter[TV] || in_type_counter[SVID]) &&\n\t    !dev->has_vid_cap && !dev->has_vbi_cap && !dev->has_meta_cap) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"TV or S-Video input without video, VBI or metadata nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev->has_vid_out = node_type & 0x0100;\n\n\t \n\tif (out_type_counter[SVID]) {\n\t\tdev->has_raw_vbi_out = node_type & 0x0400;\n\t\tdev->has_sliced_vbi_out = node_type & 0x0800;\n\t\tdev->has_vbi_out = dev->has_raw_vbi_out | dev->has_sliced_vbi_out;\n\t}\n\n\t \n\tdev->has_meta_out = node_type & 0x40000;\n\n\t \n\tif (out_type_counter[SVID] &&\n\t    !dev->has_vid_out && !dev->has_vbi_out && !dev->has_meta_out) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"S-Video output without video, VBI or metadata nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (out_type_counter[HDMI] && !dev->has_vid_out && !dev->has_meta_out) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"HDMI output without video or metadata nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev->has_radio_rx = node_type & 0x0010;\n\n\t \n\tdev->has_radio_tx = node_type & 0x1000;\n\n\t \n\tdev->has_sdr_cap = node_type & 0x0020;\n\n\t \n\tdev->has_tv_tuner = in_type_counter[TV];\n\n\t \n\t*has_tuner = ((dev->has_vid_cap || dev->has_vbi_cap) && in_type_counter[TV]) ||\n\t\t      dev->has_radio_rx || dev->has_sdr_cap;\n\n\t \n\t*has_modulator = dev->has_radio_tx;\n\n\tif (dev->has_vid_cap)\n\t\t \n\t\tdev->has_fb = node_type & 0x10000;\n\n\t \n\tif (no_error_inj && *ccs_cap == -1)\n\t\t*ccs_cap = 7;\n\n\t \n\tif (*ccs_cap != -1) {\n\t\tdev->has_crop_cap = *ccs_cap & 1;\n\t\tdev->has_compose_cap = *ccs_cap & 2;\n\t\tdev->has_scaler_cap = *ccs_cap & 4;\n\t\tv4l2_info(&dev->v4l2_dev, \"Capture Crop: %c Compose: %c Scaler: %c\\n\",\n\t\t\tdev->has_crop_cap ? 'Y' : 'N',\n\t\t\tdev->has_compose_cap ? 'Y' : 'N',\n\t\t\tdev->has_scaler_cap ? 'Y' : 'N');\n\t}\n\n\t \n\tif (no_error_inj && *ccs_out == -1)\n\t\t*ccs_out = 7;\n\n\t \n\tif (*ccs_out != -1) {\n\t\tdev->has_crop_out = *ccs_out & 1;\n\t\tdev->has_compose_out = *ccs_out & 2;\n\t\tdev->has_scaler_out = *ccs_out & 4;\n\t\tv4l2_info(&dev->v4l2_dev, \"Output Crop: %c Compose: %c Scaler: %c\\n\",\n\t\t\tdev->has_crop_out ? 'Y' : 'N',\n\t\t\tdev->has_compose_out ? 'Y' : 'N',\n\t\t\tdev->has_scaler_out ? 'Y' : 'N');\n\t}\n\n\t \n\tdev->has_touch_cap = node_type & 0x80000;\n\n\treturn 0;\n}\n\nstatic void vivid_set_capabilities(struct vivid_dev *dev)\n{\n\tif (dev->has_vid_cap) {\n\t\t \n\t\tdev->vid_cap_caps = dev->multiplanar ?\n\t\t\tV4L2_CAP_VIDEO_CAPTURE_MPLANE :\n\t\t\tV4L2_CAP_VIDEO_CAPTURE;\n\t\tdev->vid_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_inputs)\n\t\t\tdev->vid_cap_caps |= V4L2_CAP_AUDIO;\n\t\tif (dev->has_tv_tuner)\n\t\t\tdev->vid_cap_caps |= V4L2_CAP_TUNER;\n\t}\n\tif (dev->has_vid_out) {\n\t\t \n\t\tdev->vid_out_caps = dev->multiplanar ?\n\t\t\tV4L2_CAP_VIDEO_OUTPUT_MPLANE :\n\t\t\tV4L2_CAP_VIDEO_OUTPUT;\n\t\tif (dev->has_fb)\n\t\t\tdev->vid_out_caps |= V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\t\tdev->vid_out_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_outputs)\n\t\t\tdev->vid_out_caps |= V4L2_CAP_AUDIO;\n\t}\n\tif (dev->has_vbi_cap) {\n\t\t \n\t\tdev->vbi_cap_caps = (dev->has_raw_vbi_cap ? V4L2_CAP_VBI_CAPTURE : 0) |\n\t\t\t\t    (dev->has_sliced_vbi_cap ? V4L2_CAP_SLICED_VBI_CAPTURE : 0);\n\t\tdev->vbi_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_inputs)\n\t\t\tdev->vbi_cap_caps |= V4L2_CAP_AUDIO;\n\t\tif (dev->has_tv_tuner)\n\t\t\tdev->vbi_cap_caps |= V4L2_CAP_TUNER;\n\t}\n\tif (dev->has_vbi_out) {\n\t\t \n\t\tdev->vbi_out_caps = (dev->has_raw_vbi_out ? V4L2_CAP_VBI_OUTPUT : 0) |\n\t\t\t\t    (dev->has_sliced_vbi_out ? V4L2_CAP_SLICED_VBI_OUTPUT : 0);\n\t\tdev->vbi_out_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_outputs)\n\t\t\tdev->vbi_out_caps |= V4L2_CAP_AUDIO;\n\t}\n\tif (dev->has_sdr_cap) {\n\t\t \n\t\tdev->sdr_cap_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER;\n\t\tdev->sdr_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t}\n\t \n\tif (dev->has_radio_rx)\n\t\tdev->radio_rx_caps = V4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE |\n\t\t\t\t     V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_TUNER |\n\t\t\t\t     V4L2_CAP_READWRITE;\n\t \n\tif (dev->has_radio_tx)\n\t\tdev->radio_tx_caps = V4L2_CAP_RDS_OUTPUT | V4L2_CAP_MODULATOR |\n\t\t\t\t     V4L2_CAP_READWRITE;\n\n\t \n\tif (dev->has_meta_cap) {\n\t\tdev->meta_cap_caps = V4L2_CAP_META_CAPTURE |\n\t\t\t\t     V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_inputs)\n\t\t\tdev->meta_cap_caps |= V4L2_CAP_AUDIO;\n\t\tif (dev->has_tv_tuner)\n\t\t\tdev->meta_cap_caps |= V4L2_CAP_TUNER;\n\t}\n\t \n\tif (dev->has_meta_out) {\n\t\tdev->meta_out_caps = V4L2_CAP_META_OUTPUT |\n\t\t\t\t     V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tif (dev->has_audio_outputs)\n\t\t\tdev->meta_out_caps |= V4L2_CAP_AUDIO;\n\t}\n\t \n\tif (dev->has_touch_cap) {\n\t\tdev->touch_cap_caps = V4L2_CAP_TOUCH | V4L2_CAP_STREAMING |\n\t\t\t\t      V4L2_CAP_READWRITE;\n\t\tdev->touch_cap_caps |= dev->multiplanar ?\n\t\t\tV4L2_CAP_VIDEO_CAPTURE_MPLANE : V4L2_CAP_VIDEO_CAPTURE;\n\t}\n}\n\nstatic void vivid_disable_unused_ioctls(struct vivid_dev *dev,\n\t\t\t\t\tbool has_tuner,\n\t\t\t\t\tbool has_modulator,\n\t\t\t\t\tunsigned in_type_counter[4],\n\t\t\t\t\tunsigned out_type_counter[4])\n{\n\t \n\tif (!dev->has_audio_inputs) {\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUMAUDIO);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_ENUMAUDIO);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_S_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_ENUMAUDIO);\n\t}\n\tif (!dev->has_audio_outputs) {\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUMAUDOUT);\n\t\tv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_S_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_G_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_ENUMAUDOUT);\n\t\tv4l2_disable_ioctl(&dev->meta_out_dev, VIDIOC_S_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->meta_out_dev, VIDIOC_G_AUDOUT);\n\t\tv4l2_disable_ioctl(&dev->meta_out_dev, VIDIOC_ENUMAUDOUT);\n\t}\n\tif (!in_type_counter[TV] && !in_type_counter[SVID]) {\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_STD);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_STD);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUMSTD);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_QUERYSTD);\n\t}\n\tif (!out_type_counter[SVID]) {\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_STD);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_STD);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUMSTD);\n\t}\n\tif (!has_tuner && !has_modulator) {\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_G_FREQUENCY);\n\t}\n\tif (!has_tuner) {\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_G_TUNER);\n\t}\n\tif (in_type_counter[HDMI] == 0) {\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_EDID);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_EDID);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_DV_TIMINGS_CAP);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_DV_TIMINGS);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_DV_TIMINGS);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUM_DV_TIMINGS);\n\t\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_QUERY_DV_TIMINGS);\n\t}\n\tif (out_type_counter[HDMI] == 0) {\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_EDID);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_DV_TIMINGS_CAP);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_DV_TIMINGS);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_DV_TIMINGS);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_DV_TIMINGS);\n\t}\n\tif (!dev->has_fb) {\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_FBUF);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_FBUF);\n\t\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_OVERLAY);\n\t}\n\tv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\n\tv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\n\tv4l2_disable_ioctl(&dev->sdr_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\n\tv4l2_disable_ioctl(&dev->meta_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\n\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_FRAMESIZES);\n\tv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_FRAMEINTERVALS);\n\tv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_S_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_G_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->meta_out_dev, VIDIOC_S_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->meta_out_dev, VIDIOC_G_FREQUENCY);\n\tv4l2_disable_ioctl(&dev->touch_cap_dev, VIDIOC_S_PARM);\n\tv4l2_disable_ioctl(&dev->touch_cap_dev, VIDIOC_ENUM_FRAMESIZES);\n\tv4l2_disable_ioctl(&dev->touch_cap_dev, VIDIOC_ENUM_FRAMEINTERVALS);\n}\n\nstatic int vivid_init_dv_timings(struct vivid_dev *dev)\n{\n\tint i;\n\n\twhile (v4l2_dv_timings_presets[dev->query_dv_timings_size].bt.width)\n\t\tdev->query_dv_timings_size++;\n\n\t \n\tdev->query_dv_timings_qmenu = kmalloc_array(dev->query_dv_timings_size,\n\t\t\t\t\t\t    sizeof(char *), GFP_KERNEL);\n\t \n\tdev->query_dv_timings_qmenu_strings =\n\t\tkmalloc_array(dev->query_dv_timings_size, 32, GFP_KERNEL);\n\n\tif (!dev->query_dv_timings_qmenu ||\n\t    !dev->query_dv_timings_qmenu_strings)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev->query_dv_timings_size; i++) {\n\t\tconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\n\t\tchar *p = dev->query_dv_timings_qmenu_strings + i * 32;\n\t\tu32 htot, vtot;\n\n\t\tdev->query_dv_timings_qmenu[i] = p;\n\n\t\thtot = V4L2_DV_BT_FRAME_WIDTH(bt);\n\t\tvtot = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\t\tsnprintf(p, 32, \"%ux%u%s%u\",\n\t\t\tbt->width, bt->height, bt->interlaced ? \"i\" : \"p\",\n\t\t\t(u32)bt->pixelclock / (htot * vtot));\n\t}\n\n\treturn 0;\n}\n\nstatic int vivid_create_queues(struct vivid_dev *dev)\n{\n\tint ret;\n\n\t \n\tif (dev->has_vid_cap) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_vid_cap_q,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE, 2,\n\t\t\t\t\t &vivid_vid_cap_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_vid_out) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_vid_out_q,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT, 2,\n\t\t\t\t\t &vivid_vid_out_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_vbi_cap) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_vbi_cap_q,\n\t\t\t\t\t V4L2_BUF_TYPE_VBI_CAPTURE, 2,\n\t\t\t\t\t &vivid_vbi_cap_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_vbi_out) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_vbi_out_q,\n\t\t\t\t\t V4L2_BUF_TYPE_VBI_OUTPUT, 2,\n\t\t\t\t\t &vivid_vbi_out_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_sdr_cap) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_sdr_cap_q,\n\t\t\t\t\t V4L2_BUF_TYPE_SDR_CAPTURE, 8,\n\t\t\t\t\t &vivid_sdr_cap_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_meta_cap) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_meta_cap_q,\n\t\t\t\t\t V4L2_BUF_TYPE_META_CAPTURE, 2,\n\t\t\t\t\t &vivid_meta_cap_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_meta_out) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_meta_out_q,\n\t\t\t\t\t V4L2_BUF_TYPE_META_OUTPUT, 1,\n\t\t\t\t\t &vivid_meta_out_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_touch_cap) {\n\t\t \n\t\tret = vivid_create_queue(dev, &dev->vb_touch_cap_q,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE, 1,\n\t\t\t\t\t &vivid_touch_cap_qops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_fb) {\n\t\t \n\t\tret = vivid_fb_init(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"Framebuffer device registered as fb%d\\n\",\n\t\t\t  dev->fb_info.node);\n\t}\n\treturn 0;\n}\n\nstatic int vivid_create_devnodes(struct platform_device *pdev,\n\t\t\t\t struct vivid_dev *dev, int inst,\n\t\t\t\t unsigned int cec_tx_bus_cnt,\n\t\t\t\t v4l2_std_id tvnorms_cap,\n\t\t\t\t v4l2_std_id tvnorms_out,\n\t\t\t\t unsigned in_type_counter[4],\n\t\t\t\t unsigned out_type_counter[4])\n{\n\tstruct video_device *vfd;\n\tint ret;\n\n\tif (dev->has_vid_cap) {\n\t\tvfd = &dev->vid_cap_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-vid-cap\", inst);\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->vid_cap_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_vid_cap_q;\n\t\tvfd->tvnorms = tvnorms_cap;\n\n\t\t \n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->vid_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&vfd->entity, 1, &dev->vid_cap_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\n#ifdef CONFIG_VIDEO_VIVID_CEC\n\t\tif (in_type_counter[HDMI]) {\n\t\t\tret = cec_register_adapter(dev->cec_rx_adap, &pdev->dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tcec_delete_adapter(dev->cec_rx_adap);\n\t\t\t\tdev->cec_rx_adap = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcec_s_phys_addr(dev->cec_rx_adap, 0, false);\n\t\t\tv4l2_info(&dev->v4l2_dev, \"CEC adapter %s registered for HDMI input 0\\n\",\n\t\t\t\t  dev_name(&dev->cec_rx_adap->devnode.dev));\n\t\t}\n#endif\n\n\t\tret = video_register_device(vfd, VFL_TYPE_VIDEO, vid_cap_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 capture device registered as %s\\n\",\n\t\t\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_vid_out) {\n#ifdef CONFIG_VIDEO_VIVID_CEC\n\t\tint i;\n#endif\n\t\tvfd = &dev->vid_out_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-vid-out\", inst);\n\t\tvfd->vfl_dir = VFL_DIR_TX;\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->vid_out_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_vid_out_q;\n\t\tvfd->tvnorms = tvnorms_out;\n\n\t\t \n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->vid_out_pad.flags = MEDIA_PAD_FL_SOURCE;\n\t\tret = media_entity_pads_init(&vfd->entity, 1, &dev->vid_out_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\n#ifdef CONFIG_VIDEO_VIVID_CEC\n\t\tfor (i = 0; i < cec_tx_bus_cnt; i++) {\n\t\t\tret = cec_register_adapter(dev->cec_tx_adap[i], &pdev->dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tfor (; i < cec_tx_bus_cnt; i++) {\n\t\t\t\t\tcec_delete_adapter(dev->cec_tx_adap[i]);\n\t\t\t\t\tdev->cec_tx_adap[i] = NULL;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tv4l2_info(&dev->v4l2_dev, \"CEC adapter %s registered for HDMI output %d\\n\",\n\t\t\t\t  dev_name(&dev->cec_tx_adap[i]->devnode.dev), i);\n\t\t\tif (i < out_type_counter[HDMI])\n\t\t\t\tcec_s_phys_addr(dev->cec_tx_adap[i], (i + 1) << 12, false);\n\t\t\telse\n\t\t\t\tcec_s_phys_addr(dev->cec_tx_adap[i], 0x1000, false);\n\t\t}\n#endif\n\n\t\tret = video_register_device(vfd, VFL_TYPE_VIDEO, vid_out_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 output device registered as %s\\n\",\n\t\t\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_vbi_cap) {\n\t\tvfd = &dev->vbi_cap_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-vbi-cap\", inst);\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->vbi_cap_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_vbi_cap_q;\n\t\tvfd->lock = &dev->mutex;\n\t\tvfd->tvnorms = tvnorms_cap;\n\t\tvideo_set_drvdata(vfd, dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->vbi_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&vfd->entity, 1, &dev->vbi_cap_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\n\t\tret = video_register_device(vfd, VFL_TYPE_VBI, vbi_cap_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 capture device registered as %s, supports %s VBI\\n\",\n\t\t\t\t\t  video_device_node_name(vfd),\n\t\t\t\t\t  (dev->has_raw_vbi_cap && dev->has_sliced_vbi_cap) ?\n\t\t\t\t\t  \"raw and sliced\" :\n\t\t\t\t\t  (dev->has_raw_vbi_cap ? \"raw\" : \"sliced\"));\n\t}\n\n\tif (dev->has_vbi_out) {\n\t\tvfd = &dev->vbi_out_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-vbi-out\", inst);\n\t\tvfd->vfl_dir = VFL_DIR_TX;\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->vbi_out_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_vbi_out_q;\n\t\tvfd->lock = &dev->mutex;\n\t\tvfd->tvnorms = tvnorms_out;\n\t\tvideo_set_drvdata(vfd, dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->vbi_out_pad.flags = MEDIA_PAD_FL_SOURCE;\n\t\tret = media_entity_pads_init(&vfd->entity, 1, &dev->vbi_out_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\n\t\tret = video_register_device(vfd, VFL_TYPE_VBI, vbi_out_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 output device registered as %s, supports %s VBI\\n\",\n\t\t\t\t\t  video_device_node_name(vfd),\n\t\t\t\t\t  (dev->has_raw_vbi_out && dev->has_sliced_vbi_out) ?\n\t\t\t\t\t  \"raw and sliced\" :\n\t\t\t\t\t  (dev->has_raw_vbi_out ? \"raw\" : \"sliced\"));\n\t}\n\n\tif (dev->has_sdr_cap) {\n\t\tvfd = &dev->sdr_cap_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-sdr-cap\", inst);\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->sdr_cap_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_sdr_cap_q;\n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->sdr_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&vfd->entity, 1, &dev->sdr_cap_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\n\t\tret = video_register_device(vfd, VFL_TYPE_SDR, sdr_cap_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 capture device registered as %s\\n\",\n\t\t\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_radio_rx) {\n\t\tvfd = &dev->radio_rx_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-rad-rx\", inst);\n\t\tvfd->fops = &vivid_radio_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->radio_rx_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n\n\t\tret = video_register_device(vfd, VFL_TYPE_RADIO, radio_rx_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 receiver device registered as %s\\n\",\n\t\t\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_radio_tx) {\n\t\tvfd = &dev->radio_tx_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-rad-tx\", inst);\n\t\tvfd->vfl_dir = VFL_DIR_TX;\n\t\tvfd->fops = &vivid_radio_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->radio_tx_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n\n\t\tret = video_register_device(vfd, VFL_TYPE_RADIO, radio_tx_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 transmitter device registered as %s\\n\",\n\t\t\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_meta_cap) {\n\t\tvfd = &dev->meta_cap_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-meta-cap\", inst);\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->meta_cap_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_meta_cap_q;\n\t\tvfd->lock = &dev->mutex;\n\t\tvfd->tvnorms = tvnorms_cap;\n\t\tvideo_set_drvdata(vfd, dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->meta_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&vfd->entity, 1,\n\t\t\t\t\t     &dev->meta_cap_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\t\tret = video_register_device(vfd, VFL_TYPE_VIDEO,\n\t\t\t\t\t    meta_cap_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev,\n\t\t\t  \"V4L2 metadata capture device registered as %s\\n\",\n\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_meta_out) {\n\t\tvfd = &dev->meta_out_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-meta-out\", inst);\n\t\tvfd->vfl_dir = VFL_DIR_TX;\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->meta_out_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_meta_out_q;\n\t\tvfd->lock = &dev->mutex;\n\t\tvfd->tvnorms = tvnorms_out;\n\t\tvideo_set_drvdata(vfd, dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->meta_out_pad.flags = MEDIA_PAD_FL_SOURCE;\n\t\tret = media_entity_pads_init(&vfd->entity, 1,\n\t\t\t\t\t     &dev->meta_out_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\t\tret = video_register_device(vfd, VFL_TYPE_VIDEO,\n\t\t\t\t\t    meta_out_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev,\n\t\t\t  \"V4L2 metadata output device registered as %s\\n\",\n\t\t\t  video_device_node_name(vfd));\n\t}\n\n\tif (dev->has_touch_cap) {\n\t\tvfd = &dev->touch_cap_dev;\n\t\tsnprintf(vfd->name, sizeof(vfd->name),\n\t\t\t \"vivid-%03d-touch-cap\", inst);\n\t\tvfd->fops = &vivid_fops;\n\t\tvfd->ioctl_ops = &vivid_ioctl_ops;\n\t\tvfd->device_caps = dev->touch_cap_caps;\n\t\tvfd->release = video_device_release_empty;\n\t\tvfd->v4l2_dev = &dev->v4l2_dev;\n\t\tvfd->queue = &dev->vb_touch_cap_q;\n\t\tvfd->tvnorms = tvnorms_cap;\n\t\tvfd->lock = &dev->mutex;\n\t\tvideo_set_drvdata(vfd, dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tdev->touch_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&vfd->entity, 1,\n\t\t\t\t\t     &dev->touch_cap_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n#endif\n\t\tret = video_register_device(vfd, VFL_TYPE_TOUCH,\n\t\t\t\t\t    touch_cap_nr[inst]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tv4l2_info(&dev->v4l2_dev,\n\t\t\t  \"V4L2 touch capture device registered as %s\\n\",\n\t\t\t  video_device_node_name(vfd));\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t \n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tdev_err(dev->mdev.dev,\n\t\t\t\"media device register failed (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int vivid_create_instance(struct platform_device *pdev, int inst)\n{\n\tstatic const struct v4l2_dv_timings def_dv_timings =\n\t\t\t\t\tV4L2_DV_BT_CEA_1280X720P60;\n\tunsigned in_type_counter[4] = { 0, 0, 0, 0 };\n\tunsigned out_type_counter[4] = { 0, 0, 0, 0 };\n\tint ccs_cap = ccs_cap_mode[inst];\n\tint ccs_out = ccs_out_mode[inst];\n\tbool has_tuner;\n\tbool has_modulator;\n\tstruct vivid_dev *dev;\n\tunsigned node_type = node_types[inst];\n\tv4l2_std_id tvnorms_cap = 0, tvnorms_out = 0;\n\tunsigned int cec_tx_bus_cnt = 0;\n\tint ret;\n\tint i;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->inst = inst;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->v4l2_dev.mdev = &dev->mdev;\n\n\t \n\tstrscpy(dev->mdev.model, VIVID_MODULE_NAME, sizeof(dev->mdev.model));\n\tsnprintf(dev->mdev.bus_info, sizeof(dev->mdev.bus_info),\n\t\t \"platform:%s-%03d\", VIVID_MODULE_NAME, inst);\n\tdev->mdev.dev = &pdev->dev;\n\tmedia_device_init(&dev->mdev);\n\tdev->mdev.ops = &vivid_media_ops;\n#endif\n\n\t \n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t\t\"%s-%03d\", VIVID_MODULE_NAME, inst);\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tdev->v4l2_dev.release = vivid_dev_release;\n\n\tret = vivid_detect_feature_set(dev, inst, node_type,\n\t\t\t\t       &has_tuner, &has_modulator,\n\t\t\t\t       &ccs_cap, &ccs_out,\n\t\t\t\t       in_type_counter, out_type_counter);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tvivid_set_capabilities(dev);\n\n\tret = -ENOMEM;\n\t \n\ttpg_init(&dev->tpg, 640, 360);\n\tif (tpg_alloc(&dev->tpg, array_size(MAX_WIDTH, MAX_ZOOM)))\n\t\tgoto free_dev;\n\tdev->scaled_line = vzalloc(array_size(MAX_WIDTH, MAX_ZOOM));\n\tif (!dev->scaled_line)\n\t\tgoto free_dev;\n\tdev->blended_line = vzalloc(array_size(MAX_WIDTH, MAX_ZOOM));\n\tif (!dev->blended_line)\n\t\tgoto free_dev;\n\n\t \n\tdev->edid = vmalloc(array_size(256, 128));\n\tif (!dev->edid)\n\t\tgoto free_dev;\n\n\tret = vivid_init_dv_timings(dev);\n\tif (ret < 0)\n\t\tgoto free_dev;\n\n\tvivid_disable_unused_ioctls(dev, has_tuner, has_modulator,\n\t\t\t\t    in_type_counter, out_type_counter);\n\n\t \n\tdev->fmt_cap = &vivid_formats[0];\n\tdev->fmt_out = &vivid_formats[0];\n\tif (!dev->multiplanar)\n\t\tvivid_formats[0].data_offset[0] = 0;\n\tdev->webcam_size_idx = 1;\n\tdev->webcam_ival_idx = 3;\n\ttpg_s_fourcc(&dev->tpg, dev->fmt_cap->fourcc);\n\tdev->std_out = V4L2_STD_PAL;\n\tif (dev->input_type[0] == TV || dev->input_type[0] == SVID)\n\t\ttvnorms_cap = V4L2_STD_ALL;\n\tif (dev->output_type[0] == SVID)\n\t\ttvnorms_out = V4L2_STD_ALL;\n\tfor (i = 0; i < MAX_INPUTS; i++) {\n\t\tdev->dv_timings_cap[i] = def_dv_timings;\n\t\tdev->std_cap[i] = V4L2_STD_PAL;\n\t}\n\tdev->dv_timings_out = def_dv_timings;\n\tdev->tv_freq = 2804  ;\n\tdev->tv_audmode = V4L2_TUNER_MODE_STEREO;\n\tdev->tv_field_cap = V4L2_FIELD_INTERLACED;\n\tdev->tv_field_out = V4L2_FIELD_INTERLACED;\n\tdev->radio_rx_freq = 95000 * 16;\n\tdev->radio_rx_audmode = V4L2_TUNER_MODE_STEREO;\n\tif (dev->has_radio_tx) {\n\t\tdev->radio_tx_freq = 95500 * 16;\n\t\tdev->radio_rds_loop = false;\n\t}\n\tdev->radio_tx_subchans = V4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_RDS;\n\tdev->sdr_adc_freq = 300000;\n\tdev->sdr_fm_freq = 50000000;\n\tdev->sdr_pixelformat = V4L2_SDR_FMT_CU8;\n\tdev->sdr_buffersize = SDR_CAP_SAMPLES_PER_BUF * 2;\n\n\tdev->edid_max_blocks = dev->edid_blocks = 2;\n\tmemcpy(dev->edid, vivid_hdmi_edid, sizeof(vivid_hdmi_edid));\n\tdev->radio_rds_init_time = ktime_get();\n\n\t \n\tret = vivid_create_controls(dev, ccs_cap == -1, ccs_out == -1, no_error_inj,\n\t\t\tin_type_counter[TV] || in_type_counter[SVID] ||\n\t\t\tout_type_counter[SVID],\n\t\t\tin_type_counter[HDMI] || out_type_counter[HDMI]);\n\tif (ret)\n\t\tgoto unreg_dev;\n\n\t \n\tif (dev->num_outputs && dev->output_type[0] != HDMI)\n\t\tv4l2_ctrl_activate(dev->ctrl_display_present, false);\n\tif (dev->num_inputs && dev->input_type[0] != HDMI) {\n\t\tv4l2_ctrl_activate(dev->ctrl_dv_timings_signal_mode, false);\n\t\tv4l2_ctrl_activate(dev->ctrl_dv_timings, false);\n\t} else if (dev->num_inputs && dev->input_type[0] == HDMI) {\n\t\tv4l2_ctrl_activate(dev->ctrl_std_signal_mode, false);\n\t\tv4l2_ctrl_activate(dev->ctrl_standard, false);\n\t}\n\n\t \n\tvivid_update_format_cap(dev, false);\n\tvivid_update_format_out(dev);\n\n\t \n\tdev->timeperframe_tch_cap.numerator = 1;\n\tdev->timeperframe_tch_cap.denominator = 10;\n\tvivid_set_touch(dev, 0);\n\n\t \n\tspin_lock_init(&dev->slock);\n\tmutex_init(&dev->mutex);\n\n\t \n\tINIT_LIST_HEAD(&dev->vid_cap_active);\n\tINIT_LIST_HEAD(&dev->vid_out_active);\n\tINIT_LIST_HEAD(&dev->vbi_cap_active);\n\tINIT_LIST_HEAD(&dev->vbi_out_active);\n\tINIT_LIST_HEAD(&dev->sdr_cap_active);\n\tINIT_LIST_HEAD(&dev->meta_cap_active);\n\tINIT_LIST_HEAD(&dev->meta_out_active);\n\tINIT_LIST_HEAD(&dev->touch_cap_active);\n\n\tspin_lock_init(&dev->cec_xfers_slock);\n\n\tif (allocators[inst] == 1)\n\t\tdma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\n\tret = vivid_create_queues(dev);\n\tif (ret)\n\t\tgoto unreg_dev;\n\n#ifdef CONFIG_VIDEO_VIVID_CEC\n\tif (dev->has_vid_cap && in_type_counter[HDMI]) {\n\t\tstruct cec_adapter *adap;\n\n\t\tadap = vivid_cec_alloc_adap(dev, 0, false);\n\t\tret = PTR_ERR_OR_ZERO(adap);\n\t\tif (ret < 0)\n\t\t\tgoto unreg_dev;\n\t\tdev->cec_rx_adap = adap;\n\t}\n\n\tif (dev->has_vid_out) {\n\t\tfor (i = 0; i < dev->num_outputs; i++) {\n\t\t\tstruct cec_adapter *adap;\n\n\t\t\tif (dev->output_type[i] != HDMI)\n\t\t\t\tcontinue;\n\n\t\t\tdev->cec_output2bus_map[i] = cec_tx_bus_cnt;\n\t\t\tadap = vivid_cec_alloc_adap(dev, cec_tx_bus_cnt, true);\n\t\t\tret = PTR_ERR_OR_ZERO(adap);\n\t\t\tif (ret < 0) {\n\t\t\t\tfor (i = 0; i < dev->num_outputs; i++)\n\t\t\t\t\tcec_delete_adapter(dev->cec_tx_adap[i]);\n\t\t\t\tgoto unreg_dev;\n\t\t\t}\n\n\t\t\tdev->cec_tx_adap[cec_tx_bus_cnt] = adap;\n\t\t\tcec_tx_bus_cnt++;\n\t\t}\n\t}\n\n\tif (dev->cec_rx_adap || cec_tx_bus_cnt) {\n\t\tinit_waitqueue_head(&dev->kthread_waitq_cec);\n\t\tdev->kthread_cec = kthread_run(vivid_cec_bus_thread, dev,\n\t\t\t\t\t       \"vivid_cec-%s\", dev->v4l2_dev.name);\n\t\tif (IS_ERR(dev->kthread_cec)) {\n\t\t\tret = PTR_ERR(dev->kthread_cec);\n\t\t\tdev->kthread_cec = NULL;\n\t\t\tv4l2_err(&dev->v4l2_dev, \"kernel_thread() failed\\n\");\n\t\t\tgoto unreg_dev;\n\t\t}\n\t}\n\n#endif\n\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vid_cap);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vid_out);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vbi_cap);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vbi_out);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_radio_rx);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_radio_tx);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_sdr_cap);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_meta_cap);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_meta_out);\n\tv4l2_ctrl_handler_setup(&dev->ctrl_hdl_touch_cap);\n\n\t \n\tret = vivid_create_devnodes(pdev, dev, inst, cec_tx_bus_cnt,\n\t\t\t\t    tvnorms_cap, tvnorms_out,\n\t\t\t\t    in_type_counter, out_type_counter);\n\tif (ret)\n\t\tgoto unreg_dev;\n\n\t \n\tvivid_devs[inst] = dev;\n\n\treturn 0;\n\nunreg_dev:\n\tvb2_video_unregister_device(&dev->touch_cap_dev);\n\tvb2_video_unregister_device(&dev->meta_out_dev);\n\tvb2_video_unregister_device(&dev->meta_cap_dev);\n\tvideo_unregister_device(&dev->radio_tx_dev);\n\tvideo_unregister_device(&dev->radio_rx_dev);\n\tvb2_video_unregister_device(&dev->sdr_cap_dev);\n\tvb2_video_unregister_device(&dev->vbi_out_dev);\n\tvb2_video_unregister_device(&dev->vbi_cap_dev);\n\tvb2_video_unregister_device(&dev->vid_out_dev);\n\tvb2_video_unregister_device(&dev->vid_cap_dev);\n\tcec_unregister_adapter(dev->cec_rx_adap);\n\tfor (i = 0; i < MAX_OUTPUTS; i++)\n\t\tcec_unregister_adapter(dev->cec_tx_adap[i]);\n\tif (dev->kthread_cec)\n\t\tkthread_stop(dev->kthread_cec);\nfree_dev:\n\tv4l2_device_put(&dev->v4l2_dev);\n\treturn ret;\n}\n\n \nstatic int vivid_probe(struct platform_device *pdev)\n{\n\tconst struct font_desc *font = find_font(\"VGA8x16\");\n\tint ret = 0, i;\n\n\tif (font == NULL) {\n\t\tpr_err(\"vivid: could not find font\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttpg_set_font(font->data);\n\n\tn_devs = clamp_t(unsigned, n_devs, 1, VIVID_MAX_DEVS);\n\n\tfor (i = 0; i < n_devs; i++) {\n\t\tret = vivid_create_instance(pdev, i);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (i)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tpr_err(\"vivid: error %d while loading driver\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tn_devs = i;\n\n\treturn ret;\n}\n\nstatic void vivid_remove(struct platform_device *pdev)\n{\n\tstruct vivid_dev *dev;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < n_devs; i++) {\n\t\tdev = vivid_devs[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tif (dev->disconnect_error)\n\t\t\tvivid_reconnect(dev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tmedia_device_unregister(&dev->mdev);\n#endif\n\n\t\tif (dev->has_vid_cap) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->vid_cap_dev));\n\t\t\tvb2_video_unregister_device(&dev->vid_cap_dev);\n\t\t}\n\t\tif (dev->has_vid_out) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->vid_out_dev));\n\t\t\tvb2_video_unregister_device(&dev->vid_out_dev);\n\t\t}\n\t\tif (dev->has_vbi_cap) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->vbi_cap_dev));\n\t\t\tvb2_video_unregister_device(&dev->vbi_cap_dev);\n\t\t}\n\t\tif (dev->has_vbi_out) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->vbi_out_dev));\n\t\t\tvb2_video_unregister_device(&dev->vbi_out_dev);\n\t\t}\n\t\tif (dev->has_sdr_cap) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->sdr_cap_dev));\n\t\t\tvb2_video_unregister_device(&dev->sdr_cap_dev);\n\t\t}\n\t\tif (dev->has_radio_rx) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->radio_rx_dev));\n\t\t\tvideo_unregister_device(&dev->radio_rx_dev);\n\t\t}\n\t\tif (dev->has_radio_tx) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\tvideo_device_node_name(&dev->radio_tx_dev));\n\t\t\tvideo_unregister_device(&dev->radio_tx_dev);\n\t\t}\n\t\tif (dev->has_fb) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering fb%d\\n\",\n\t\t\t\tdev->fb_info.node);\n\t\t\tunregister_framebuffer(&dev->fb_info);\n\t\t\tvivid_fb_release_buffers(dev);\n\t\t}\n\t\tif (dev->has_meta_cap) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\t  video_device_node_name(&dev->meta_cap_dev));\n\t\t\tvb2_video_unregister_device(&dev->meta_cap_dev);\n\t\t}\n\t\tif (dev->has_meta_out) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\t  video_device_node_name(&dev->meta_out_dev));\n\t\t\tvb2_video_unregister_device(&dev->meta_out_dev);\n\t\t}\n\t\tif (dev->has_touch_cap) {\n\t\t\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t\t\t  video_device_node_name(&dev->touch_cap_dev));\n\t\t\tvb2_video_unregister_device(&dev->touch_cap_dev);\n\t\t}\n\t\tcec_unregister_adapter(dev->cec_rx_adap);\n\t\tfor (j = 0; j < MAX_OUTPUTS; j++)\n\t\t\tcec_unregister_adapter(dev->cec_tx_adap[j]);\n\t\tif (dev->kthread_cec)\n\t\t\tkthread_stop(dev->kthread_cec);\n\t\tv4l2_device_put(&dev->v4l2_dev);\n\t\tvivid_devs[i] = NULL;\n\t}\n}\n\nstatic void vivid_pdev_release(struct device *dev)\n{\n}\n\nstatic struct platform_device vivid_pdev = {\n\t.name\t\t= \"vivid\",\n\t.dev.release\t= vivid_pdev_release,\n};\n\nstatic struct platform_driver vivid_pdrv = {\n\t.probe\t\t= vivid_probe,\n\t.remove_new\t= vivid_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vivid\",\n\t},\n};\n\nstatic int __init vivid_init(void)\n{\n\tint ret;\n\n\tret = platform_device_register(&vivid_pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&vivid_pdrv);\n\tif (ret)\n\t\tplatform_device_unregister(&vivid_pdev);\n\n\treturn ret;\n}\n\nstatic void __exit vivid_exit(void)\n{\n\tplatform_driver_unregister(&vivid_pdrv);\n\tplatform_device_unregister(&vivid_pdev);\n}\n\nmodule_init(vivid_init);\nmodule_exit(vivid_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}