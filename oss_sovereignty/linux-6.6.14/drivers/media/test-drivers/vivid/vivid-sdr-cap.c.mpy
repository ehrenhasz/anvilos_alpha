{
  "module_name": "vivid-sdr-cap.c",
  "hash_id": "74942b44a00b1dde568026a8cd1472473c393146c0b639b7417d0ccf6d8c6d62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-sdr-cap.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/math64.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n#include <linux/fixp-arith.h>\n#include <linux/jiffies.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-sdr-cap.h\"\n\n \nstruct vivid_format {\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\n \nstatic const struct vivid_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_CU8,\n\t\t.buffersize\t= SDR_CAP_SAMPLES_PER_BUF * 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_SDR_FMT_CS8,\n\t\t.buffersize\t= SDR_CAP_SAMPLES_PER_BUF * 2,\n\t},\n};\n\nstatic const struct v4l2_frequency_band bands_adc[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  300000,\n\t\t.rangehigh  =  300000,\n\t},\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  900001,\n\t\t.rangehigh  = 2800000,\n\t},\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 2,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 3200000,\n\t\t.rangehigh  = 3200000,\n\t},\n};\n\n \n#define BAND_ADC_0 ((bands_adc[0].rangehigh + bands_adc[1].rangelow) / 2)\n#define BAND_ADC_1 ((bands_adc[1].rangehigh + bands_adc[2].rangelow) / 2)\n\nstatic const struct v4l2_frequency_band bands_fm[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =    50000000,\n\t\t.rangehigh  =  2000000000,\n\t},\n};\n\nstatic void vivid_thread_sdr_cap_tick(struct vivid_dev *dev)\n{\n\tstruct vivid_buffer *sdr_cap_buf = NULL;\n\n\tdprintk(dev, 1, \"SDR Capture Thread Tick\\n\");\n\n\t \n\tif (dev->perc_dropped_buffers &&\n\t    get_random_u32_below(100) < dev->perc_dropped_buffers)\n\t\treturn;\n\n\tspin_lock(&dev->slock);\n\tif (!list_empty(&dev->sdr_cap_active)) {\n\t\tsdr_cap_buf = list_entry(dev->sdr_cap_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\t\tlist_del(&sdr_cap_buf->list);\n\t}\n\tspin_unlock(&dev->slock);\n\n\tif (sdr_cap_buf) {\n\t\tsdr_cap_buf->vb.sequence = dev->sdr_cap_with_seq_wrap_count;\n\t\tv4l2_ctrl_request_setup(sdr_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t&dev->ctrl_hdl_sdr_cap);\n\t\tv4l2_ctrl_request_complete(sdr_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_sdr_cap);\n\t\tvivid_sdr_cap_process(dev, sdr_cap_buf);\n\t\tsdr_cap_buf->vb.vb2_buf.timestamp =\n\t\t\tktime_get_ns() + dev->time_wrap_offset;\n\t\tvb2_buffer_done(&sdr_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tdev->dqbuf_error = false;\n\t}\n}\n\nstatic int vivid_thread_sdr_cap(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 samples_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\n\tdprintk(dev, 1, \"SDR Capture Thread Start\\n\");\n\n\tset_freezable();\n\n\t \n\tdev->sdr_cap_seq_offset = 0;\n\tdev->sdr_cap_seq_count = 0;\n\tdev->jiffies_sdr_cap = jiffies;\n\tdev->sdr_cap_seq_resync = false;\n\tif (dev->time_wrap)\n\t\tdev->time_wrap_offset = dev->time_wrap - ktime_get_ns();\n\telse\n\t\tdev->time_wrap_offset = 0;\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&dev->mutex)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->sdr_cap_seq_resync) {\n\t\t\tdev->jiffies_sdr_cap = cur_jiffies;\n\t\t\tdev->sdr_cap_seq_offset = dev->sdr_cap_seq_count + 1;\n\t\t\tdev->sdr_cap_seq_count = 0;\n\t\t\tdev->sdr_cap_seq_resync = false;\n\t\t}\n\t\t \n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_sdr_cap;\n\t\t \n\t\tbuffers_since_start =\n\t\t\t(u64)jiffies_since_start * dev->sdr_adc_freq +\n\t\t\t\t      (HZ * SDR_CAP_SAMPLES_PER_BUF) / 2;\n\t\tdo_div(buffers_since_start, HZ * SDR_CAP_SAMPLES_PER_BUF);\n\n\t\t \n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_sdr_cap = cur_jiffies;\n\t\t\tdev->sdr_cap_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdev->sdr_cap_seq_count =\n\t\t\tbuffers_since_start + dev->sdr_cap_seq_offset;\n\t\tdev->sdr_cap_with_seq_wrap_count = dev->sdr_cap_seq_count - dev->sdr_cap_seq_start;\n\n\t\tvivid_thread_sdr_cap_tick(dev);\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t \n\t\tsamples_since_start = buffers_since_start * SDR_CAP_SAMPLES_PER_BUF;\n\n\t\t \n\t\tjiffies_since_start = jiffies - dev->jiffies_sdr_cap;\n\n\t\t \n\t\tsamples_since_start += SDR_CAP_SAMPLES_PER_BUF;\n\t\t \n\t\tnext_jiffies_since_start = samples_since_start * HZ +\n\t\t\t\t\t   dev->sdr_adc_freq / 2;\n\t\tdo_div(next_jiffies_since_start, dev->sdr_adc_freq);\n\t\t \n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\twhile (time_is_after_jiffies(cur_jiffies + wait_jiffies) &&\n\t\t       !kthread_should_stop())\n\t\t\tschedule();\n\t}\n\tdprintk(dev, 1, \"SDR Capture Thread End\\n\");\n\treturn 0;\n}\n\nstatic int sdr_cap_queue_setup(struct vb2_queue *vq,\n\t\t       unsigned *nbuffers, unsigned *nplanes,\n\t\t       unsigned sizes[], struct device *alloc_devs[])\n{\n\t \n\tsizes[0] = SDR_CAP_SAMPLES_PER_BUF * 2;\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic int sdr_cap_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned size = SDR_CAP_SAMPLES_PER_BUF * 2;\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(dev, 1, \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void sdr_cap_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->sdr_cap_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int sdr_cap_start_streaming(struct vb2_queue *vq, unsigned count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err = 0;\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tdev->sdr_cap_seq_start = dev->seq_wrap * 128;\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else if (dev->kthread_sdr_cap == NULL) {\n\t\tdev->kthread_sdr_cap = kthread_run(vivid_thread_sdr_cap, dev,\n\t\t\t\t\"%s-sdr-cap\", dev->v4l2_dev.name);\n\n\t\tif (IS_ERR(dev->kthread_sdr_cap)) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"kernel_thread() failed\\n\");\n\t\t\terr = PTR_ERR(dev->kthread_sdr_cap);\n\t\t\tdev->kthread_sdr_cap = NULL;\n\t\t}\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dev->sdr_cap_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void sdr_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tif (dev->kthread_sdr_cap == NULL)\n\t\treturn;\n\n\twhile (!list_empty(&dev->sdr_cap_active)) {\n\t\tstruct vivid_buffer *buf;\n\n\t\tbuf = list_entry(dev->sdr_cap_active.next,\n\t\t\t\tstruct vivid_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_sdr_cap);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\t \n\tkthread_stop(dev->kthread_sdr_cap);\n\tdev->kthread_sdr_cap = NULL;\n}\n\nstatic void sdr_cap_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_sdr_cap);\n}\n\nconst struct vb2_ops vivid_sdr_cap_qops = {\n\t.queue_setup\t\t= sdr_cap_queue_setup,\n\t.buf_prepare\t\t= sdr_cap_buf_prepare,\n\t.buf_queue\t\t= sdr_cap_buf_queue,\n\t.start_streaming\t= sdr_cap_start_streaming,\n\t.stop_streaming\t\t= sdr_cap_stop_streaming,\n\t.buf_request_complete\t= sdr_cap_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint vivid_sdr_enum_freq_bands(struct file *file, void *fh,\n\t\tstruct v4l2_frequency_band *band)\n{\n\tswitch (band->tuner) {\n\tcase 0:\n\t\tif (band->index >= ARRAY_SIZE(bands_adc))\n\t\t\treturn -EINVAL;\n\t\t*band = bands_adc[band->index];\n\t\treturn 0;\n\tcase 1:\n\t\tif (band->index >= ARRAY_SIZE(bands_fm))\n\t\t\treturn -EINVAL;\n\t\t*band = bands_fm[band->index];\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vivid_sdr_g_frequency(struct file *file, void *fh,\n\t\tstruct v4l2_frequency *vf)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tswitch (vf->tuner) {\n\tcase 0:\n\t\tvf->frequency = dev->sdr_adc_freq;\n\t\tvf->type = V4L2_TUNER_ADC;\n\t\treturn 0;\n\tcase 1:\n\t\tvf->frequency = dev->sdr_fm_freq;\n\t\tvf->type = V4L2_TUNER_RF;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vivid_sdr_s_frequency(struct file *file, void *fh,\n\t\tconst struct v4l2_frequency *vf)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tunsigned freq = vf->frequency;\n\tunsigned band;\n\n\tswitch (vf->tuner) {\n\tcase 0:\n\t\tif (vf->type != V4L2_TUNER_ADC)\n\t\t\treturn -EINVAL;\n\t\tif (freq < BAND_ADC_0)\n\t\t\tband = 0;\n\t\telse if (freq < BAND_ADC_1)\n\t\t\tband = 1;\n\t\telse\n\t\t\tband = 2;\n\n\t\tfreq = clamp_t(unsigned, freq,\n\t\t\t\tbands_adc[band].rangelow,\n\t\t\t\tbands_adc[band].rangehigh);\n\n\t\tif (vb2_is_streaming(&dev->vb_sdr_cap_q) &&\n\t\t    freq != dev->sdr_adc_freq) {\n\t\t\t \n\t\t\tdev->sdr_cap_seq_resync = true;\n\t\t}\n\t\tdev->sdr_adc_freq = freq;\n\t\treturn 0;\n\tcase 1:\n\t\tif (vf->type != V4L2_TUNER_RF)\n\t\t\treturn -EINVAL;\n\t\tdev->sdr_fm_freq = clamp_t(unsigned, freq,\n\t\t\t\tbands_fm[0].rangelow,\n\t\t\t\tbands_fm[0].rangehigh);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vivid_sdr_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\n{\n\tswitch (vt->index) {\n\tcase 0:\n\t\tstrscpy(vt->name, \"ADC\", sizeof(vt->name));\n\t\tvt->type = V4L2_TUNER_ADC;\n\t\tvt->capability =\n\t\t\tV4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tvt->rangelow = bands_adc[0].rangelow;\n\t\tvt->rangehigh = bands_adc[2].rangehigh;\n\t\treturn 0;\n\tcase 1:\n\t\tstrscpy(vt->name, \"RF\", sizeof(vt->name));\n\t\tvt->type = V4L2_TUNER_RF;\n\t\tvt->capability =\n\t\t\tV4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tvt->rangelow = bands_fm[0].rangelow;\n\t\tvt->rangehigh = bands_fm[0].rangehigh;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vivid_sdr_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\n{\n\tif (vt->index > 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint vidioc_enum_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[f->index].pixelformat;\n\treturn 0;\n}\n\nint vidioc_g_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tf->fmt.sdr.pixelformat = dev->sdr_pixelformat;\n\tf->fmt.sdr.buffersize = dev->sdr_buffersize;\n\treturn 0;\n}\n\nint vidioc_s_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct vb2_queue *q = &dev->vb_sdr_cap_q;\n\tint i;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tdev->sdr_pixelformat = formats[i].pixelformat;\n\t\t\tdev->sdr_buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdev->sdr_pixelformat = formats[0].pixelformat;\n\tdev->sdr_buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\treturn 0;\n}\n\nint vidioc_try_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\treturn 0;\n}\n\n#define FIXP_N    (15)\n#define FIXP_FRAC (1 << FIXP_N)\n#define FIXP_2PI  ((int)(2 * 3.141592653589 * FIXP_FRAC))\n#define M_100000PI (3.14159 * 100000)\n\nvoid vivid_sdr_cap_process(struct vivid_dev *dev, struct vivid_buffer *buf)\n{\n\tu8 *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tunsigned long i;\n\tunsigned long plane_size = vb2_plane_size(&buf->vb.vb2_buf, 0);\n\ts64 s64tmp;\n\ts32 src_phase_step;\n\ts32 mod_phase_step;\n\ts32 fixp_i;\n\ts32 fixp_q;\n\n\t \n\t#define BEEP_FREQ 1000  \n\tsrc_phase_step = DIV_ROUND_CLOSEST(FIXP_2PI * BEEP_FREQ,\n\t\t\t\t\t   dev->sdr_adc_freq);\n\n\tfor (i = 0; i < plane_size; i += 2) {\n\t\tmod_phase_step = fixp_cos32_rad(dev->sdr_fixp_src_phase,\n\t\t\t\t\t\tFIXP_2PI) >> (31 - FIXP_N);\n\n\t\tdev->sdr_fixp_src_phase += src_phase_step;\n\t\ts64tmp = (s64) mod_phase_step * dev->sdr_fm_deviation;\n\t\tdev->sdr_fixp_mod_phase += div_s64(s64tmp, M_100000PI);\n\n\t\t \n\t\tdev->sdr_fixp_src_phase %= FIXP_2PI;\n\t\tdev->sdr_fixp_mod_phase %= FIXP_2PI;\n\n\t\tif (dev->sdr_fixp_mod_phase < 0)\n\t\t\tdev->sdr_fixp_mod_phase += FIXP_2PI;\n\n\t\tfixp_i = fixp_cos32_rad(dev->sdr_fixp_mod_phase, FIXP_2PI);\n\t\tfixp_q = fixp_sin32_rad(dev->sdr_fixp_mod_phase, FIXP_2PI);\n\n\t\t \n\t\tfixp_i >>= (31 - FIXP_N);\n\t\tfixp_q >>= (31 - FIXP_N);\n\n\t\tswitch (dev->sdr_pixelformat) {\n\t\tcase V4L2_SDR_FMT_CU8:\n\t\t\t \n\t\t\t \n\t\t\tfixp_i = fixp_i * 1275 + FIXP_FRAC * 1275;\n\t\t\tfixp_q = fixp_q * 1275 + FIXP_FRAC * 1275;\n\t\t\t*vbuf++ = DIV_ROUND_CLOSEST(fixp_i, FIXP_FRAC * 10);\n\t\t\t*vbuf++ = DIV_ROUND_CLOSEST(fixp_q, FIXP_FRAC * 10);\n\t\t\tbreak;\n\t\tcase V4L2_SDR_FMT_CS8:\n\t\t\t \n\t\t\t \n\t\t\tfixp_i = fixp_i * 1275 - FIXP_FRAC * 5;\n\t\t\tfixp_q = fixp_q * 1275 - FIXP_FRAC * 5;\n\t\t\t*vbuf++ = DIV_ROUND_CLOSEST(fixp_i, FIXP_FRAC * 10);\n\t\t\t*vbuf++ = DIV_ROUND_CLOSEST(fixp_q, FIXP_FRAC * 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}