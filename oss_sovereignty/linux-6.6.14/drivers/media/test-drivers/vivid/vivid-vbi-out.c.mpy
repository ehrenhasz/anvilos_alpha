{
  "module_name": "vivid-vbi-out.c",
  "hash_id": "ec79cec02b12a91b8390d135c80a5ab9c8bc4dafcc6a3eb9c81695fb30bb4a4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-vbi-out.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-kthread-out.h\"\n#include \"vivid-vbi-out.h\"\n#include \"vivid-vbi-cap.h\"\n\nstatic int vbi_out_queue_setup(struct vb2_queue *vq,\n\t\t       unsigned *nbuffers, unsigned *nplanes,\n\t\t       unsigned sizes[], struct device *alloc_devs[])\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tbool is_60hz = dev->std_out & V4L2_STD_525_60;\n\tunsigned size = vq->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT ?\n\t\t36 * sizeof(struct v4l2_sliced_vbi_data) :\n\t\t1440 * 2 * (is_60hz ? 12 : 18);\n\n\tif (!vivid_is_svid_out(dev))\n\t\treturn -EINVAL;\n\n\tsizes[0] = size;\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic int vbi_out_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tbool is_60hz = dev->std_out & V4L2_STD_525_60;\n\tunsigned size = vb->vb2_queue->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT ?\n\t\t36 * sizeof(struct v4l2_sliced_vbi_data) :\n\t\t1440 * 2 * (is_60hz ? 12 : 18);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(dev, 1, \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void vbi_out_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->vbi_out_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int vbi_out_start_streaming(struct vb2_queue *vq, unsigned count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err;\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tdev->vbi_out_seq_count = 0;\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = vivid_start_generating_vid_out(dev, &dev->vbi_out_streaming);\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dev->vbi_out_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void vbi_out_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tvivid_stop_generating_vid_out(dev, &dev->vbi_out_streaming);\n\tdev->vbi_out_have_wss = false;\n\tdev->vbi_out_have_cc[0] = false;\n\tdev->vbi_out_have_cc[1] = false;\n}\n\nstatic void vbi_out_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_vbi_out);\n}\n\nconst struct vb2_ops vivid_vbi_out_qops = {\n\t.queue_setup\t\t= vbi_out_queue_setup,\n\t.buf_prepare\t\t= vbi_out_buf_prepare,\n\t.buf_queue\t\t= vbi_out_buf_queue,\n\t.start_streaming\t= vbi_out_start_streaming,\n\t.stop_streaming\t\t= vbi_out_stop_streaming,\n\t.buf_request_complete\t= vbi_out_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint vidioc_g_fmt_vbi_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_vbi_format *vbi = &f->fmt.vbi;\n\tbool is_60hz = dev->std_out & V4L2_STD_525_60;\n\n\tif (!vivid_is_svid_out(dev) || !dev->has_raw_vbi_out)\n\t\treturn -EINVAL;\n\n\tvbi->sampling_rate = 25000000;\n\tvbi->offset = 24;\n\tvbi->samples_per_line = 1440;\n\tvbi->sample_format = V4L2_PIX_FMT_GREY;\n\tvbi->start[0] = is_60hz ? V4L2_VBI_ITU_525_F1_START + 9 : V4L2_VBI_ITU_625_F1_START + 5;\n\tvbi->start[1] = is_60hz ? V4L2_VBI_ITU_525_F2_START + 9 : V4L2_VBI_ITU_625_F2_START + 5;\n\tvbi->count[0] = vbi->count[1] = is_60hz ? 12 : 18;\n\tvbi->flags = dev->vbi_cap_interlaced ? V4L2_VBI_INTERLACED : 0;\n\tvbi->reserved[0] = 0;\n\tvbi->reserved[1] = 0;\n\treturn 0;\n}\n\nint vidioc_s_fmt_vbi_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tint ret = vidioc_g_fmt_vbi_out(file, priv, f);\n\n\tif (ret)\n\t\treturn ret;\n\tif (vb2_is_busy(&dev->vb_vbi_out_q))\n\t\treturn -EBUSY;\n\tdev->stream_sliced_vbi_out = false;\n\tdev->vbi_out_dev.queue->type = V4L2_BUF_TYPE_VBI_OUTPUT;\n\treturn 0;\n}\n\nint vidioc_g_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\n\tif (!vivid_is_svid_out(dev) || !dev->has_sliced_vbi_out)\n\t\treturn -EINVAL;\n\n\tvivid_fill_service_lines(vbi, dev->service_set_out);\n\treturn 0;\n}\n\nint vidioc_try_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\tbool is_60hz = dev->std_out & V4L2_STD_525_60;\n\tu32 service_set = vbi->service_set;\n\n\tif (!vivid_is_svid_out(dev) || !dev->has_sliced_vbi_out)\n\t\treturn -EINVAL;\n\n\tservice_set &= is_60hz ? V4L2_SLICED_CAPTION_525 :\n\t\t\t\t V4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\n\tvivid_fill_service_lines(vbi, service_set);\n\treturn 0;\n}\n\nint vidioc_s_fmt_sliced_vbi_out(struct file *file, void *fh,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\n\tint ret = vidioc_try_fmt_sliced_vbi_out(file, fh, fmt);\n\n\tif (ret)\n\t\treturn ret;\n\tif (vb2_is_busy(&dev->vb_vbi_out_q))\n\t\treturn -EBUSY;\n\tdev->service_set_out = vbi->service_set;\n\tdev->stream_sliced_vbi_out = true;\n\tdev->vbi_out_dev.queue->type = V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;\n\treturn 0;\n}\n\nvoid vivid_sliced_vbi_out_process(struct vivid_dev *dev,\n\t\tstruct vivid_buffer *buf)\n{\n\tstruct v4l2_sliced_vbi_data *vbi =\n\t\tvb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tunsigned elems =\n\t\tvb2_get_plane_payload(&buf->vb.vb2_buf, 0) / sizeof(*vbi);\n\n\tdev->vbi_out_have_cc[0] = false;\n\tdev->vbi_out_have_cc[1] = false;\n\tdev->vbi_out_have_wss = false;\n\twhile (elems--) {\n\t\tswitch (vbi->id) {\n\t\tcase V4L2_SLICED_CAPTION_525:\n\t\t\tif ((dev->std_out & V4L2_STD_525_60) && vbi->line == 21) {\n\t\t\t\tdev->vbi_out_have_cc[!!vbi->field] = true;\n\t\t\t\tdev->vbi_out_cc[!!vbi->field][0] = vbi->data[0];\n\t\t\t\tdev->vbi_out_cc[!!vbi->field][1] = vbi->data[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_SLICED_WSS_625:\n\t\t\tif ((dev->std_out & V4L2_STD_625_50) &&\n\t\t\t    vbi->field == 0 && vbi->line == 23) {\n\t\t\t\tdev->vbi_out_have_wss = true;\n\t\t\t\tdev->vbi_out_wss[0] = vbi->data[0];\n\t\t\t\tdev->vbi_out_wss[1] = vbi->data[1];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tvbi++;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}