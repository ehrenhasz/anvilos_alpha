{
  "module_name": "vivid-cec.c",
  "hash_id": "0ca6ccf1ae9ac4421d74970b75618b786bdeb57fff75f632933bcbc3a31eda5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-cec.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <media/cec.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-cec.h\"\n\n#define CEC_START_BIT_US\t\t4500\n#define CEC_DATA_BIT_US\t\t\t2400\n#define CEC_MARGIN_US\t\t\t350\n\nstruct xfer_on_bus {\n\tstruct cec_adapter\t*adap;\n\tu8\t\t\tstatus;\n};\n\nstatic bool find_dest_adap(struct vivid_dev *dev,\n\t\t\t   struct cec_adapter *adap, u8 dest)\n{\n\tunsigned int i;\n\n\tif (dest >= 0xf)\n\t\treturn false;\n\n\tif (adap != dev->cec_rx_adap && dev->cec_rx_adap &&\n\t    dev->cec_rx_adap->is_configured &&\n\t    cec_has_log_addr(dev->cec_rx_adap, dest))\n\t\treturn true;\n\n\tfor (i = 0; i < MAX_OUTPUTS && dev->cec_tx_adap[i]; i++) {\n\t\tif (adap == dev->cec_tx_adap[i])\n\t\t\tcontinue;\n\t\tif (!dev->cec_tx_adap[i]->is_configured)\n\t\t\tcontinue;\n\t\tif (cec_has_log_addr(dev->cec_tx_adap[i], dest))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool xfer_ready(struct vivid_dev *dev)\n{\n\tunsigned int i;\n\tbool ready = false;\n\n\tspin_lock(&dev->cec_xfers_slock);\n\tfor (i = 0; i < ARRAY_SIZE(dev->xfers); i++) {\n\t\tif (dev->xfers[i].sft &&\n\t\t    dev->xfers[i].sft <= dev->cec_sft) {\n\t\t\tready = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dev->cec_xfers_slock);\n\n\treturn ready;\n}\n\n \nstatic void adjust_sfts(struct vivid_dev *dev)\n{\n\tunsigned int i;\n\tu8 initiator;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->xfers); i++) {\n\t\tif (dev->xfers[i].sft <= CEC_SIGNAL_FREE_TIME_RETRY)\n\t\t\tcontinue;\n\t\tinitiator = dev->xfers[i].msg[0] >> 4;\n\t\tif (initiator == dev->last_initiator)\n\t\t\tdev->xfers[i].sft = CEC_SIGNAL_FREE_TIME_NEXT_XFER;\n\t\telse\n\t\t\tdev->xfers[i].sft = CEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\n\t}\n}\n\n \nint vivid_cec_bus_thread(void *_dev)\n{\n\tu32 last_sft;\n\tunsigned int i;\n\tunsigned int dest;\n\tktime_t start, end;\n\ts64 delta_us, retry_us;\n\tstruct vivid_dev *dev = _dev;\n\n\tdev->cec_sft = CEC_SIGNAL_FREE_TIME_NEXT_XFER;\n\tfor (;;) {\n\t\tbool first = true;\n\t\tint wait_xfer_us = 0;\n\t\tbool valid_dest = false;\n\t\tint wait_arb_lost_us = 0;\n\t\tunsigned int first_idx = 0;\n\t\tunsigned int first_status = 0;\n\t\tstruct cec_msg first_msg = {};\n\t\tstruct xfer_on_bus xfers_on_bus[MAX_OUTPUTS] = {};\n\n\t\twait_event_interruptible(dev->kthread_waitq_cec, xfer_ready(dev) ||\n\t\t\t\t\t kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tlast_sft = dev->cec_sft;\n\t\tdev->cec_sft = 0;\n\t\t \n\t\tspin_lock(&dev->cec_xfers_slock);\n\t\tfor (i = 0; i < ARRAY_SIZE(dev->xfers); i++) {\n\t\t\tif (!dev->xfers[i].sft || dev->xfers[i].sft > last_sft)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tfirst_idx = i;\n\t\t\t\txfers_on_bus[first_idx].adap = dev->xfers[i].adap;\n\t\t\t\tmemcpy(first_msg.msg, dev->xfers[i].msg, dev->xfers[i].len);\n\t\t\t\tfirst_msg.len = dev->xfers[i].len;\n\t\t\t} else {\n\t\t\t\txfers_on_bus[i].adap = dev->xfers[i].adap;\n\t\t\t\txfers_on_bus[i].status = CEC_TX_STATUS_ARB_LOST;\n\t\t\t\t \n\t\t\t\twait_arb_lost_us = 4 * CEC_DATA_BIT_US + CEC_START_BIT_US;\n\t\t\t}\n\t\t\tdev->xfers[i].sft = 0;\n\t\t}\n\t\tdev->last_initiator = cec_msg_initiator(&first_msg);\n\t\tadjust_sfts(dev);\n\t\tspin_unlock(&dev->cec_xfers_slock);\n\n\t\tdest = cec_msg_destination(&first_msg);\n\t\tvalid_dest = cec_msg_is_broadcast(&first_msg);\n\t\tif (!valid_dest)\n\t\t\tvalid_dest = find_dest_adap(dev, xfers_on_bus[first_idx].adap, dest);\n\t\tif (valid_dest) {\n\t\t\tfirst_status = CEC_TX_STATUS_OK;\n\t\t\t \n\t\t\twait_xfer_us = first_msg.len * 10 * CEC_DATA_BIT_US;\n\t\t} else {\n\t\t\tfirst_status = CEC_TX_STATUS_NACK;\n\t\t\t \n\t\t\twait_xfer_us = 10 * CEC_DATA_BIT_US;\n\t\t}\n\t\twait_xfer_us += CEC_START_BIT_US;\n\t\txfers_on_bus[first_idx].status = first_status;\n\n\t\t \n\t\tstart = ktime_get();\n\t\tif (wait_arb_lost_us) {\n\t\t\tusleep_range(wait_arb_lost_us - CEC_MARGIN_US, wait_arb_lost_us);\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xfers_on_bus); i++) {\n\t\t\t\tif (xfers_on_bus[i].status != CEC_TX_STATUS_ARB_LOST)\n\t\t\t\t\tcontinue;\n\t\t\t\tcec_transmit_attempt_done(xfers_on_bus[i].adap,\n\t\t\t\t\t\t\t  CEC_TX_STATUS_ARB_LOST);\n\t\t\t}\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t}\n\t\twait_xfer_us -= wait_arb_lost_us;\n\t\tusleep_range(wait_xfer_us - CEC_MARGIN_US, wait_xfer_us);\n\t\tcec_transmit_attempt_done(xfers_on_bus[first_idx].adap, first_status);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tif (first_status == CEC_TX_STATUS_OK) {\n\t\t\tif (xfers_on_bus[first_idx].adap != dev->cec_rx_adap)\n\t\t\t\tcec_received_msg(dev->cec_rx_adap, &first_msg);\n\t\t\tfor (i = 0; i < MAX_OUTPUTS && dev->cec_tx_adap[i]; i++)\n\t\t\t\tif (xfers_on_bus[first_idx].adap != dev->cec_tx_adap[i])\n\t\t\t\t\tcec_received_msg(dev->cec_tx_adap[i], &first_msg);\n\t\t}\n\t\tend = ktime_get();\n\t\t \n\t\tdelta_us = div_s64(end - start, 1000);\n\t\tdelta_us -= wait_xfer_us + wait_arb_lost_us;\n\t\tretry_us = CEC_SIGNAL_FREE_TIME_RETRY * CEC_DATA_BIT_US - delta_us;\n\t\tif (retry_us > CEC_MARGIN_US)\n\t\t\tusleep_range(retry_us - CEC_MARGIN_US, retry_us);\n\t\tdev->cec_sft = CEC_SIGNAL_FREE_TIME_RETRY;\n\t\t \n\t\twhile (dev->cec_sft >= CEC_SIGNAL_FREE_TIME_RETRY &&\n\t\t       dev->cec_sft < CEC_SIGNAL_FREE_TIME_NEXT_XFER &&\n\t\t       !xfer_ready(dev) && !kthread_should_stop()) {\n\t\t\tusleep_range(2 * CEC_DATA_BIT_US - CEC_MARGIN_US,\n\t\t\t\t     2 * CEC_DATA_BIT_US);\n\t\t\tdev->cec_sft += 2;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vivid_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tadap->cec_pin_is_high = true;\n\treturn 0;\n}\n\nstatic int vivid_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\treturn 0;\n}\n\nstatic int vivid_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t   u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct vivid_dev *dev = cec_get_drvdata(adap);\n\tu8 idx = cec_msg_initiator(msg);\n\n\tspin_lock(&dev->cec_xfers_slock);\n\tdev->xfers[idx].adap = adap;\n\tmemcpy(dev->xfers[idx].msg, msg->msg, CEC_MAX_MSG_SIZE);\n\tdev->xfers[idx].len = msg->len;\n\tdev->xfers[idx].sft = CEC_SIGNAL_FREE_TIME_RETRY;\n\tif (signal_free_time > CEC_SIGNAL_FREE_TIME_RETRY) {\n\t\tif (idx == dev->last_initiator)\n\t\t\tdev->xfers[idx].sft = CEC_SIGNAL_FREE_TIME_NEXT_XFER;\n\t\telse\n\t\t\tdev->xfers[idx].sft = CEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\n\t}\n\tspin_unlock(&dev->cec_xfers_slock);\n\twake_up_interruptible(&dev->kthread_waitq_cec);\n\n\treturn 0;\n}\n\nstatic int vivid_received(struct cec_adapter *adap, struct cec_msg *msg)\n{\n\tstruct vivid_dev *dev = cec_get_drvdata(adap);\n\tstruct cec_msg reply;\n\tu8 dest = cec_msg_destination(msg);\n\tu8 disp_ctl;\n\tchar osd[14];\n\n\tif (cec_msg_is_broadcast(msg))\n\t\tdest = adap->log_addrs.log_addr[0];\n\tcec_msg_init(&reply, dest, cec_msg_initiator(msg));\n\n\tswitch (cec_msg_opcode(msg)) {\n\tcase CEC_MSG_SET_OSD_STRING:\n\t\tif (!cec_is_sink(adap))\n\t\t\treturn -ENOMSG;\n\t\tcec_ops_set_osd_string(msg, &disp_ctl, osd);\n\t\tswitch (disp_ctl) {\n\t\tcase CEC_OP_DISP_CTL_DEFAULT:\n\t\t\tstrscpy(dev->osd, osd, sizeof(dev->osd));\n\t\t\tdev->osd_jiffies = jiffies;\n\t\t\tbreak;\n\t\tcase CEC_OP_DISP_CTL_UNTIL_CLEARED:\n\t\t\tstrscpy(dev->osd, osd, sizeof(dev->osd));\n\t\t\tdev->osd_jiffies = 0;\n\t\t\tbreak;\n\t\tcase CEC_OP_DISP_CTL_CLEAR:\n\t\t\tdev->osd[0] = 0;\n\t\t\tdev->osd_jiffies = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcec_msg_feature_abort(&reply, cec_msg_opcode(msg),\n\t\t\t\t\t      CEC_OP_ABORT_INVALID_OP);\n\t\t\tcec_transmit_msg(adap, &reply, false);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOMSG;\n\t}\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops vivid_cec_adap_ops = {\n\t.adap_enable = vivid_cec_adap_enable,\n\t.adap_log_addr = vivid_cec_adap_log_addr,\n\t.adap_transmit = vivid_cec_adap_transmit,\n\t.received = vivid_received,\n};\n\nstruct cec_adapter *vivid_cec_alloc_adap(struct vivid_dev *dev,\n\t\t\t\t\t unsigned int idx,\n\t\t\t\t\t bool is_source)\n{\n\tu32 caps = CEC_CAP_DEFAULTS | CEC_CAP_MONITOR_ALL | CEC_CAP_MONITOR_PIN;\n\tchar name[32];\n\n\tsnprintf(name, sizeof(name), \"vivid-%03d-vid-%s%d\",\n\t\t dev->inst, is_source ? \"out\" : \"cap\", idx);\n\treturn cec_allocate_adapter(&vivid_cec_adap_ops, dev,\n\t\t\t\t    name, caps, CEC_MAX_LOG_ADDRS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}