{
  "module_name": "vivid-kthread-touch.c",
  "hash_id": "4fa47e7e480dd383fc59df5243303444a97654b6804e40e9090bc9f2605a16e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-kthread-touch.c",
  "human_readable_source": "\n \n\n#include <linux/freezer.h>\n#include <linux/jiffies.h>\n#include \"vivid-core.h\"\n#include \"vivid-kthread-touch.h\"\n#include \"vivid-touch-cap.h\"\n\nstatic noinline_for_stack void vivid_thread_tch_cap_tick(struct vivid_dev *dev,\n\t\t\t\t\t\t\t int dropped_bufs)\n{\n\tstruct vivid_buffer *tch_cap_buf = NULL;\n\n\tspin_lock(&dev->slock);\n\tif (!list_empty(&dev->touch_cap_active)) {\n\t\ttch_cap_buf = list_entry(dev->touch_cap_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\t\tlist_del(&tch_cap_buf->list);\n\t}\n\n\tspin_unlock(&dev->slock);\n\n\tif (tch_cap_buf) {\n\t\tv4l2_ctrl_request_setup(tch_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t&dev->ctrl_hdl_touch_cap);\n\n\t\tvivid_fillbuff_tch(dev, tch_cap_buf);\n\t\tv4l2_ctrl_request_complete(tch_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_touch_cap);\n\t\tvb2_buffer_done(&tch_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tdprintk(dev, 2, \"touch_cap buffer %d done\\n\",\n\t\t\ttch_cap_buf->vb.vb2_buf.index);\n\n\t\ttch_cap_buf->vb.vb2_buf.timestamp = ktime_get_ns() + dev->time_wrap_offset;\n\t}\n\tdev->dqbuf_error = false;\n}\n\nstatic int vivid_thread_touch_cap(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned int wait_jiffies;\n\tunsigned int numerator;\n\tunsigned int denominator;\n\tint dropped_bufs;\n\n\tdprintk(dev, 1, \"Touch Capture Thread Start\\n\");\n\n\tset_freezable();\n\n\t \n\tdev->touch_cap_seq_offset = 0;\n\tdev->touch_cap_seq_count = 0;\n\tdev->touch_cap_seq_resync = false;\n\tdev->jiffies_touch_cap = jiffies;\n\tif (dev->time_wrap)\n\t\tdev->time_wrap_offset = dev->time_wrap - ktime_get_ns();\n\telse\n\t\tdev->time_wrap_offset = 0;\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&dev->mutex)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->touch_cap_seq_resync) {\n\t\t\tdev->jiffies_touch_cap = cur_jiffies;\n\t\t\tdev->touch_cap_seq_offset = dev->touch_cap_seq_count + 1;\n\t\t\tdev->touch_cap_seq_count = 0;\n\t\t\tdev->cap_seq_resync = false;\n\t\t}\n\t\tdenominator = dev->timeperframe_tch_cap.denominator;\n\t\tnumerator = dev->timeperframe_tch_cap.numerator;\n\n\t\t \n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_touch_cap;\n\t\t \n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t \n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_touch_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdropped_bufs = buffers_since_start + dev->touch_cap_seq_offset - dev->touch_cap_seq_count;\n\t\tdev->touch_cap_seq_count = buffers_since_start + dev->touch_cap_seq_offset;\n\t\tdev->touch_cap_with_seq_wrap_count =\n\t\t\tdev->touch_cap_seq_count - dev->touch_cap_seq_start;\n\n\t\tvivid_thread_tch_cap_tick(dev, dropped_bufs);\n\n\t\t \n\t\tnumerators_since_start = ++buffers_since_start * numerator;\n\n\t\t \n\t\tjiffies_since_start = jiffies - dev->jiffies_touch_cap;\n\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t \n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t \n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\twhile (time_is_after_jiffies(cur_jiffies + wait_jiffies) &&\n\t\t       !kthread_should_stop())\n\t\t\tschedule();\n\t}\n\tdprintk(dev, 1, \"Touch Capture Thread End\\n\");\n\treturn 0;\n}\n\nint vivid_start_generating_touch_cap(struct vivid_dev *dev)\n{\n\tif (dev->kthread_touch_cap) {\n\t\tdev->touch_cap_streaming = true;\n\t\treturn 0;\n\t}\n\n\tdev->touch_cap_seq_start = dev->seq_wrap * 128;\n\tdev->kthread_touch_cap = kthread_run(vivid_thread_touch_cap, dev,\n\t\t\t\t\t     \"%s-tch-cap\", dev->v4l2_dev.name);\n\n\tif (IS_ERR(dev->kthread_touch_cap)) {\n\t\tint err = PTR_ERR(dev->kthread_touch_cap);\n\n\t\tdev->kthread_touch_cap = NULL;\n\t\tv4l2_err(&dev->v4l2_dev, \"kernel_thread() failed\\n\");\n\t\treturn err;\n\t}\n\tdev->touch_cap_streaming = true;\n\tdprintk(dev, 1, \"returning from %s\\n\", __func__);\n\treturn 0;\n}\n\nvoid vivid_stop_generating_touch_cap(struct vivid_dev *dev)\n{\n\tif (!dev->kthread_touch_cap)\n\t\treturn;\n\n\tdev->touch_cap_streaming = false;\n\n\twhile (!list_empty(&dev->touch_cap_active)) {\n\t\tstruct vivid_buffer *buf;\n\n\t\tbuf = list_entry(dev->touch_cap_active.next,\n\t\t\t\t struct vivid_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_touch_cap);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tdprintk(dev, 2, \"touch_cap buffer %d done\\n\",\n\t\t\tbuf->vb.vb2_buf.index);\n\t}\n\n\tkthread_stop(dev->kthread_touch_cap);\n\tdev->kthread_touch_cap = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}