{
  "module_name": "vivid-vbi-gen.c",
  "hash_id": "42f9082cd7b0634fbcfcede2e089157b7ea54e35c6a8d0a23b55244e59031f1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-vbi-gen.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n\n#include \"vivid-vbi-gen.h\"\n\nstatic void wss_insert(u8 *wss, u32 val, unsigned size)\n{\n\twhile (size--)\n\t\t*wss++ = (val & (1 << size)) ? 0xc0 : 0x10;\n}\n\nstatic void vivid_vbi_gen_wss_raw(const struct v4l2_sliced_vbi_data *data,\n\t\tu8 *buf, unsigned sampling_rate)\n{\n\tconst unsigned rate = 5000000;\t \n\tu8 wss[29 + 24 + 24 + 24 + 18 + 18] = { 0 };\n\tconst unsigned zero = 0x07;\n\tconst unsigned one = 0x38;\n\tunsigned bit = 0;\n\tu16 wss_data;\n\tint i;\n\n\twss_insert(wss + bit, 0x1f1c71c7, 29); bit += 29;\n\twss_insert(wss + bit, 0x1e3c1f, 24); bit += 24;\n\n\twss_data = (data->data[1] << 8) | data->data[0];\n\tfor (i = 0; i <= 13; i++, bit += 6)\n\t\twss_insert(wss + bit, (wss_data & (1 << i)) ? one : zero, 6);\n\n\tfor (i = 0, bit = 0; bit < sizeof(wss); bit++) {\n\t\tunsigned n = ((bit + 1) * sampling_rate) / rate;\n\n\t\twhile (i < n)\n\t\t\tbuf[i++] = wss[bit];\n\t}\n}\n\nstatic void vivid_vbi_gen_teletext_raw(const struct v4l2_sliced_vbi_data *data,\n\t\tu8 *buf, unsigned sampling_rate)\n{\n\tconst unsigned rate = 6937500 / 10;\t \n\tu8 teletext[45] = { 0x55, 0x55, 0x27 };\n\tunsigned bit = 0;\n\tint i;\n\n\tmemcpy(teletext + 3, data->data, sizeof(teletext) - 3);\n\t \n\tsampling_rate /= 10;\n\n\tfor (i = 0, bit = 0; bit < sizeof(teletext) * 8; bit++) {\n\t\tunsigned n = ((bit + 1) * sampling_rate) / rate;\n\t\tu8 val = (teletext[bit / 8] & (1 << (bit & 7))) ? 0xc0 : 0x10;\n\n\t\twhile (i < n)\n\t\t\tbuf[i++] = val;\n\t}\n}\n\nstatic void cc_insert(u8 *cc, u8 ch)\n{\n\tunsigned tot = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < 7; i++) {\n\t\tcc[2 * i] = cc[2 * i + 1] = (ch & (1 << i)) ? 1 : 0;\n\t\ttot += cc[2 * i];\n\t}\n\tcc[14] = cc[15] = !(tot & 1);\n}\n\n#define CC_PREAMBLE_BITS (14 + 4 + 2)\n\nstatic void vivid_vbi_gen_cc_raw(const struct v4l2_sliced_vbi_data *data,\n\t\tu8 *buf, unsigned sampling_rate)\n{\n\tconst unsigned rate = 1000000;\t \n\n\tu8 cc[CC_PREAMBLE_BITS + 2 * 16] = {\n\t\t \n\t\t0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t\t \n\t\t0, 0, 0, 0,\n\t\t \n\t\t1, 1\n\t};\n\tunsigned bit, i;\n\n\tcc_insert(cc + CC_PREAMBLE_BITS, data->data[0]);\n\tcc_insert(cc + CC_PREAMBLE_BITS + 16, data->data[1]);\n\n\tfor (i = 0, bit = 0; bit < sizeof(cc); bit++) {\n\t\tunsigned n = ((bit + 1) * sampling_rate) / rate;\n\n\t\twhile (i < n)\n\t\t\tbuf[i++] = cc[bit] ? 0xc0 : 0x10;\n\t}\n}\n\nvoid vivid_vbi_gen_raw(const struct vivid_vbi_gen_data *vbi,\n\t\tconst struct v4l2_vbi_format *vbi_fmt, u8 *buf)\n{\n\tunsigned idx;\n\n\tfor (idx = 0; idx < 25; idx++) {\n\t\tconst struct v4l2_sliced_vbi_data *data = vbi->data + idx;\n\t\tunsigned start_2nd_field;\n\t\tunsigned line = data->line;\n\t\tu8 *linebuf = buf;\n\n\t\tstart_2nd_field = (data->id & V4L2_SLICED_VBI_525) ? 263 : 313;\n\t\tif (data->field)\n\t\t\tline += start_2nd_field;\n\t\tline -= vbi_fmt->start[data->field];\n\n\t\tif (vbi_fmt->flags & V4L2_VBI_INTERLACED)\n\t\t\tlinebuf += (line * 2 + data->field) *\n\t\t\t\tvbi_fmt->samples_per_line;\n\t\telse\n\t\t\tlinebuf += (line + data->field * vbi_fmt->count[0]) *\n\t\t\t\tvbi_fmt->samples_per_line;\n\t\tif (data->id == V4L2_SLICED_CAPTION_525)\n\t\t\tvivid_vbi_gen_cc_raw(data, linebuf, vbi_fmt->sampling_rate);\n\t\telse if (data->id == V4L2_SLICED_WSS_625)\n\t\t\tvivid_vbi_gen_wss_raw(data, linebuf, vbi_fmt->sampling_rate);\n\t\telse if (data->id == V4L2_SLICED_TELETEXT_B)\n\t\t\tvivid_vbi_gen_teletext_raw(data, linebuf, vbi_fmt->sampling_rate);\n\t}\n}\n\nstatic const u8 vivid_cc_sequence1[30] = {\n\t0x14, 0x20,\t \n\t'H',  'e',\n\t'l',  'l',\n\t'o',  ' ',\n\t'w',  'o',\n\t'r',  'l',\n\t'd',  '!',\n\t0x14, 0x2f,\t \n};\n\nstatic const u8 vivid_cc_sequence2[30] = {\n\t0x14, 0x20,\t \n\t'C',  'l',\n\t'o',  's',\n\t'e',  'd',\n\t' ',  'c',\n\t'a',  'p',\n\t't',  'i',\n\t'o',  'n',\n\t's',  ' ',\n\t't',  'e',\n\t's',  't',\n\t0x14, 0x2f,\t \n};\n\nstatic u8 calc_parity(u8 val)\n{\n\tunsigned i;\n\tunsigned tot = 0;\n\n\tfor (i = 0; i < 7; i++)\n\t\ttot += (val & (1 << i)) ? 1 : 0;\n\treturn val | ((tot & 1) ? 0 : 0x80);\n}\n\nstatic void vivid_vbi_gen_set_time_of_day(u8 *packet)\n{\n\tstruct tm tm;\n\tu8 checksum, i;\n\n\ttime64_to_tm(ktime_get_real_seconds(), 0, &tm);\n\tpacket[0] = calc_parity(0x07);\n\tpacket[1] = calc_parity(0x01);\n\tpacket[2] = calc_parity(0x40 | tm.tm_min);\n\tpacket[3] = calc_parity(0x40 | tm.tm_hour);\n\tpacket[4] = calc_parity(0x40 | tm.tm_mday);\n\tif (tm.tm_mday == 1 && tm.tm_mon == 2 &&\n\t    sys_tz.tz_minuteswest > tm.tm_min + tm.tm_hour * 60)\n\t\tpacket[4] = calc_parity(0x60 | tm.tm_mday);\n\tpacket[5] = calc_parity(0x40 | (1 + tm.tm_mon));\n\tpacket[6] = calc_parity(0x40 | (1 + tm.tm_wday));\n\tpacket[7] = calc_parity(0x40 | ((tm.tm_year - 90) & 0x3f));\n\tpacket[8] = calc_parity(0x0f);\n\tfor (checksum = i = 0; i <= 8; i++)\n\t\tchecksum += packet[i] & 0x7f;\n\tpacket[9] = calc_parity(0x100 - checksum);\n\tpacket[10] = calc_parity(0x07);\n\tpacket[11] = calc_parity(0x04);\n\tif (sys_tz.tz_minuteswest >= 0)\n\t\tpacket[12] = calc_parity(0x40 | ((sys_tz.tz_minuteswest / 60) & 0x1f));\n\telse\n\t\tpacket[12] = calc_parity(0x40 | ((24 + sys_tz.tz_minuteswest / 60) & 0x1f));\n\tpacket[13] = calc_parity(0);\n\tpacket[14] = calc_parity(0x0f);\n\tfor (checksum = 0, i = 10; i <= 14; i++)\n\t\tchecksum += packet[i] & 0x7f;\n\tpacket[15] = calc_parity(0x100 - checksum);\n}\n\nstatic const u8 hamming[16] = {\n\t0x15, 0x02, 0x49, 0x5e, 0x64, 0x73, 0x38, 0x2f,\n\t0xd0, 0xc7, 0x8c, 0x9b, 0xa1, 0xb6, 0xfd, 0xea\n};\n\nstatic void vivid_vbi_gen_teletext(u8 *packet, unsigned line, unsigned frame)\n{\n\tunsigned offset = 2;\n\tunsigned i;\n\n\tpacket[0] = hamming[1 + ((line & 1) << 3)];\n\tpacket[1] = hamming[line >> 1];\n\tmemset(packet + 2, 0x20, 40);\n\tif (line == 0) {\n\t\t \n\t\tpacket[2] = hamming[frame % 10];\n\t\tpacket[3] = hamming[frame / 10];\n\t\tpacket[4] = hamming[0];\n\t\tpacket[5] = hamming[0];\n\t\tpacket[6] = hamming[0];\n\t\tpacket[7] = hamming[0];\n\t\tpacket[8] = hamming[0];\n\t\tpacket[9] = hamming[1];\n\t\toffset = 10;\n\t}\n\tpacket += offset;\n\tmemcpy(packet, \"Page: 100 Row: 10\", 17);\n\tpacket[7] = '0' + frame / 10;\n\tpacket[8] = '0' + frame % 10;\n\tpacket[15] = '0' + line / 10;\n\tpacket[16] = '0' + line % 10;\n\tfor (i = 0; i < 42 - offset; i++)\n\t\tpacket[i] = calc_parity(packet[i]);\n}\n\nvoid vivid_vbi_gen_sliced(struct vivid_vbi_gen_data *vbi,\n\t\tbool is_60hz, unsigned seqnr)\n{\n\tstruct v4l2_sliced_vbi_data *data0 = vbi->data;\n\tstruct v4l2_sliced_vbi_data *data1 = vbi->data + 1;\n\tunsigned frame = seqnr % 60;\n\n\tmemset(vbi->data, 0, sizeof(vbi->data));\n\n\tif (!is_60hz) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i <= 11; i++) {\n\t\t\tdata0->id = V4L2_SLICED_TELETEXT_B;\n\t\t\tdata0->line = 7 + i;\n\t\t\tvivid_vbi_gen_teletext(data0->data, i, frame);\n\t\t\tdata0++;\n\t\t}\n\t\tdata0->id = V4L2_SLICED_WSS_625;\n\t\tdata0->line = 23;\n\t\t \n\t\tdata0->data[0] = 0x08;\n\t\tdata0++;\n\t\tfor (i = 0; i <= 11; i++) {\n\t\t\tdata0->id = V4L2_SLICED_TELETEXT_B;\n\t\t\tdata0->field = 1;\n\t\t\tdata0->line = 7 + i;\n\t\t\tvivid_vbi_gen_teletext(data0->data, 12 + i, frame);\n\t\t\tdata0++;\n\t\t}\n\t\treturn;\n\t}\n\n\tdata0->id = V4L2_SLICED_CAPTION_525;\n\tdata0->line = 21;\n\tdata1->id = V4L2_SLICED_CAPTION_525;\n\tdata1->field = 1;\n\tdata1->line = 21;\n\n\tif (frame < 15) {\n\t\tdata0->data[0] = calc_parity(vivid_cc_sequence1[2 * frame]);\n\t\tdata0->data[1] = calc_parity(vivid_cc_sequence1[2 * frame + 1]);\n\t} else if (frame >= 30 && frame < 45) {\n\t\tframe -= 30;\n\t\tdata0->data[0] = calc_parity(vivid_cc_sequence2[2 * frame]);\n\t\tdata0->data[1] = calc_parity(vivid_cc_sequence2[2 * frame + 1]);\n\t} else {\n\t\tdata0->data[0] = calc_parity(0);\n\t\tdata0->data[1] = calc_parity(0);\n\t}\n\n\tframe = seqnr % (30 * 60);\n\tswitch (frame) {\n\tcase 0:\n\t\tvivid_vbi_gen_set_time_of_day(vbi->time_of_day_packet);\n\t\tfallthrough;\n\tcase 1 ... 7:\n\t\tdata1->data[0] = vbi->time_of_day_packet[frame * 2];\n\t\tdata1->data[1] = vbi->time_of_day_packet[frame * 2 + 1];\n\t\tbreak;\n\tdefault:\n\t\tdata1->data[0] = calc_parity(0);\n\t\tdata1->data[1] = calc_parity(0);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}