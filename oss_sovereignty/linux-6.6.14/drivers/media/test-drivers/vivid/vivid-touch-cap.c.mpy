{
  "module_name": "vivid-touch-cap.c",
  "hash_id": "891f860b50e2668afda85160c6669a4d15eb032e8ce2b678eefe054dd093e2cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-touch-cap.c",
  "human_readable_source": "\n \n\n#include \"vivid-core.h\"\n#include \"vivid-kthread-touch.h\"\n#include \"vivid-vid-common.h\"\n#include \"vivid-touch-cap.h\"\n\nstatic int touch_cap_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\t unsigned int *nplanes, unsigned int sizes[],\n\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *f = &dev->tch_format;\n\tunsigned int size = f->sizeimage;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsizes[0] = size;\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic int touch_cap_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_pix_format *f = &dev->tch_format;\n\tunsigned int size = f->sizeimage;\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(dev, 1, \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void touch_cap_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->touch_cap_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int touch_cap_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err;\n\n\tdev->touch_cap_seq_count = 0;\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = vivid_start_generating_touch_cap(dev);\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp,\n\t\t\t\t\t &dev->touch_cap_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void touch_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tvivid_stop_generating_touch_cap(dev);\n}\n\nstatic void touch_cap_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_touch_cap);\n}\n\nconst struct vb2_ops vivid_touch_cap_qops = {\n\t.queue_setup\t\t= touch_cap_queue_setup,\n\t.buf_prepare\t\t= touch_cap_buf_prepare,\n\t.buf_queue\t\t= touch_cap_buf_queue,\n\t.start_streaming\t= touch_cap_start_streaming,\n\t.stop_streaming\t\t= touch_cap_stop_streaming,\n\t.buf_request_complete\t= touch_cap_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint vivid_enum_fmt_tch(struct file *file, void  *priv, struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_TCH_FMT_DELTA_TD16;\n\treturn 0;\n}\n\nint vivid_g_fmt_tch(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (dev->multiplanar)\n\t\treturn -ENOTTY;\n\tf->fmt.pix = dev->tch_format;\n\treturn 0;\n}\n\nint vivid_g_fmt_tch_mplane(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_format sp_fmt;\n\n\tif (!dev->multiplanar)\n\t\treturn -ENOTTY;\n\tsp_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tsp_fmt.fmt.pix = dev->tch_format;\n\tfmt_sp2mp(&sp_fmt, f);\n\treturn 0;\n}\n\nint vivid_g_parm_tch(struct file *file, void *priv,\n\t\t     struct v4l2_streamparm *parm)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (parm->type != (dev->multiplanar ?\n\t\t\t   V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :\n\t\t\t   V4L2_BUF_TYPE_VIDEO_CAPTURE))\n\t\treturn -EINVAL;\n\n\tparm->parm.capture.capability   = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.timeperframe = dev->timeperframe_tch_cap;\n\tparm->parm.capture.readbuffers  = 1;\n\treturn 0;\n}\n\nint vivid_enum_input_tch(struct file *file, void *priv, struct v4l2_input *inp)\n{\n\tif (inp->index)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_TOUCH;\n\tstrscpy(inp->name, \"Vivid Touch\", sizeof(inp->name));\n\tinp->capabilities = 0;\n\treturn 0;\n}\n\nint vivid_g_input_tch(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nint vivid_set_touch(struct vivid_dev *dev, unsigned int i)\n{\n\tstruct v4l2_pix_format *f = &dev->tch_format;\n\n\tif (i)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_TCH_FMT_DELTA_TD16;\n\tf->width =  VIVID_TCH_WIDTH;\n\tf->height = VIVID_TCH_HEIGHT;\n\tf->field = V4L2_FIELD_NONE;\n\tf->colorspace = V4L2_COLORSPACE_RAW;\n\tf->bytesperline = f->width * sizeof(s16);\n\tf->sizeimage = f->width * f->height * sizeof(s16);\n\treturn 0;\n}\n\nint vivid_s_input_tch(struct file *file, void *priv, unsigned int i)\n{\n\treturn vivid_set_touch(video_drvdata(file), i);\n}\n\nstatic void vivid_fill_buff_noise(__s16 *tch_buf, int size)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\tunsigned int rand = get_random_u32();\n\n\t\tif (rand % 10)\n\t\t\ttch_buf[i] = 0;\n\t\telse\n\t\t\ttch_buf[i] = (rand / 10) % 7 - 3;\n\t}\n}\n\nstatic inline int get_random_pressure(void)\n{\n\treturn get_random_u32_below(VIVID_PRESSURE_LIMIT);\n}\n\nstatic void vivid_tch_buf_set(struct v4l2_pix_format *f,\n\t\t\t      __s16 *tch_buf,\n\t\t\t      int index)\n{\n\tunsigned int x = index % f->width;\n\tunsigned int y = index / f->width;\n\tunsigned int offset = VIVID_MIN_PRESSURE;\n\n\ttch_buf[index] = offset + get_random_pressure();\n\toffset /= 2;\n\tif (x)\n\t\ttch_buf[index - 1] = offset + get_random_pressure();\n\tif (x < f->width - 1)\n\t\ttch_buf[index + 1] = offset + get_random_pressure();\n\tif (y)\n\t\ttch_buf[index - f->width] = offset + get_random_pressure();\n\tif (y < f->height - 1)\n\t\ttch_buf[index + f->width] = offset + get_random_pressure();\n\toffset /= 2;\n\tif (x && y)\n\t\ttch_buf[index - 1 - f->width] = offset + get_random_pressure();\n\tif (x < f->width - 1 && y)\n\t\ttch_buf[index + 1 - f->width] = offset + get_random_pressure();\n\tif (x && y < f->height - 1)\n\t\ttch_buf[index - 1 + f->width] = offset + get_random_pressure();\n\tif (x < f->width - 1 && y < f->height - 1)\n\t\ttch_buf[index + 1 + f->width] = offset + get_random_pressure();\n}\n\nvoid vivid_fillbuff_tch(struct vivid_dev *dev, struct vivid_buffer *buf)\n{\n\tstruct v4l2_pix_format *f = &dev->tch_format;\n\tint size = f->width * f->height;\n\tint x, y, xstart, ystart, offset_x, offset_y;\n\tunsigned int test_pattern, test_pat_idx, rand;\n\n\t__s16 *tch_buf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tbuf->vb.sequence = dev->touch_cap_with_seq_wrap_count;\n\ttest_pattern = (buf->vb.sequence / TCH_SEQ_COUNT) % TEST_CASE_MAX;\n\ttest_pat_idx = buf->vb.sequence % TCH_SEQ_COUNT;\n\n\tvivid_fill_buff_noise(tch_buf, size);\n\n\tif (test_pat_idx >= TCH_PATTERN_COUNT)\n\t\treturn;\n\n\tif (test_pat_idx == 0)\n\t\tdev->tch_pat_random = get_random_u32();\n\trand = dev->tch_pat_random;\n\n\tswitch (test_pattern) {\n\tcase SINGLE_TAP:\n\t\tif (test_pat_idx == 2)\n\t\t\tvivid_tch_buf_set(f, tch_buf, rand % size);\n\t\tbreak;\n\tcase DOUBLE_TAP:\n\t\tif (test_pat_idx == 2 || test_pat_idx == 4)\n\t\t\tvivid_tch_buf_set(f, tch_buf, rand % size);\n\t\tbreak;\n\tcase TRIPLE_TAP:\n\t\tif (test_pat_idx == 2 || test_pat_idx == 4 || test_pat_idx == 6)\n\t\t\tvivid_tch_buf_set(f, tch_buf, rand % size);\n\t\tbreak;\n\tcase MOVE_LEFT_TO_RIGHT:\n\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t  (rand % f->height) * f->width +\n\t\t\t\t  test_pat_idx *\n\t\t\t\t  (f->width / TCH_PATTERN_COUNT));\n\t\tbreak;\n\tcase ZOOM_IN:\n\t\tx = f->width / 2;\n\t\ty = f->height / 2;\n\t\toffset_x = ((TCH_PATTERN_COUNT - 1 - test_pat_idx) * x) /\n\t\t\t\tTCH_PATTERN_COUNT;\n\t\toffset_y = ((TCH_PATTERN_COUNT - 1 - test_pat_idx) * y) /\n\t\t\t\tTCH_PATTERN_COUNT;\n\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t  (x - offset_x) + f->width * (y - offset_y));\n\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t  (x + offset_x) + f->width * (y + offset_y));\n\t\tbreak;\n\tcase ZOOM_OUT:\n\t\tx = f->width / 2;\n\t\ty = f->height / 2;\n\t\toffset_x = (test_pat_idx * x) / TCH_PATTERN_COUNT;\n\t\toffset_y = (test_pat_idx * y) / TCH_PATTERN_COUNT;\n\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t  (x - offset_x) + f->width * (y - offset_y));\n\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t  (x + offset_x) + f->width * (y + offset_y));\n\t\tbreak;\n\tcase PALM_PRESS:\n\t\tfor (x = 0; x < f->width; x++)\n\t\t\tfor (y = f->height / 2; y < f->height; y++)\n\t\t\t\ttch_buf[x + f->width * y] = VIVID_MIN_PRESSURE +\n\t\t\t\t\t\t\tget_random_pressure();\n\t\tbreak;\n\tcase MULTIPLE_PRESS:\n\t\t \n\t\tfor (y = 0; y < 4; y++) {\n\t\t\tfor (x = 0; x < 4; x++) {\n\t\t\t\tystart = (y * f->height) / 4 + f->height / 8;\n\t\t\t\txstart = (x * f->width) / 4 + f->width / 8;\n\t\t\t\tvivid_tch_buf_set(f, tch_buf,\n\t\t\t\t\t\t  ystart * f->width + xstart);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#ifdef __BIG_ENDIAN__\n\tfor (x = 0; x < size; x++)\n\t\ttch_buf[x] = (__force s16)__cpu_to_le16((u16)tch_buf[x]);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}