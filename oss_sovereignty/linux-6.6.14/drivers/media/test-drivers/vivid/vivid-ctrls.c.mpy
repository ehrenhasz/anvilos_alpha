{
  "module_name": "vivid-ctrls.c",
  "hash_id": "2ceee5f6c3179f63b16e8952b5ad0f6e5154270e27703a9dcc2b4ae96e6d5086",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-ctrls.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-common.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-vid-cap.h\"\n#include \"vivid-vid-out.h\"\n#include \"vivid-vid-common.h\"\n#include \"vivid-radio-common.h\"\n#include \"vivid-osd.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-cec.h\"\n\n#define VIVID_CID_CUSTOM_BASE\t\t(V4L2_CID_USER_BASE | 0xf000)\n#define VIVID_CID_BUTTON\t\t(VIVID_CID_CUSTOM_BASE + 0)\n#define VIVID_CID_BOOLEAN\t\t(VIVID_CID_CUSTOM_BASE + 1)\n#define VIVID_CID_INTEGER\t\t(VIVID_CID_CUSTOM_BASE + 2)\n#define VIVID_CID_INTEGER64\t\t(VIVID_CID_CUSTOM_BASE + 3)\n#define VIVID_CID_MENU\t\t\t(VIVID_CID_CUSTOM_BASE + 4)\n#define VIVID_CID_STRING\t\t(VIVID_CID_CUSTOM_BASE + 5)\n#define VIVID_CID_BITMASK\t\t(VIVID_CID_CUSTOM_BASE + 6)\n#define VIVID_CID_INTMENU\t\t(VIVID_CID_CUSTOM_BASE + 7)\n#define VIVID_CID_U32_ARRAY\t\t(VIVID_CID_CUSTOM_BASE + 8)\n#define VIVID_CID_U16_MATRIX\t\t(VIVID_CID_CUSTOM_BASE + 9)\n#define VIVID_CID_U8_4D_ARRAY\t\t(VIVID_CID_CUSTOM_BASE + 10)\n#define VIVID_CID_AREA\t\t\t(VIVID_CID_CUSTOM_BASE + 11)\n#define VIVID_CID_RO_INTEGER\t\t(VIVID_CID_CUSTOM_BASE + 12)\n#define VIVID_CID_U32_DYN_ARRAY\t\t(VIVID_CID_CUSTOM_BASE + 13)\n#define VIVID_CID_U8_PIXEL_ARRAY\t(VIVID_CID_CUSTOM_BASE + 14)\n#define VIVID_CID_S32_ARRAY\t\t(VIVID_CID_CUSTOM_BASE + 15)\n#define VIVID_CID_S64_ARRAY\t\t(VIVID_CID_CUSTOM_BASE + 16)\n\n#define VIVID_CID_VIVID_BASE\t\t(0x00f00000 | 0xf000)\n#define VIVID_CID_VIVID_CLASS\t\t(0x00f00000 | 1)\n#define VIVID_CID_TEST_PATTERN\t\t(VIVID_CID_VIVID_BASE + 0)\n#define VIVID_CID_OSD_TEXT_MODE\t\t(VIVID_CID_VIVID_BASE + 1)\n#define VIVID_CID_HOR_MOVEMENT\t\t(VIVID_CID_VIVID_BASE + 2)\n#define VIVID_CID_VERT_MOVEMENT\t\t(VIVID_CID_VIVID_BASE + 3)\n#define VIVID_CID_SHOW_BORDER\t\t(VIVID_CID_VIVID_BASE + 4)\n#define VIVID_CID_SHOW_SQUARE\t\t(VIVID_CID_VIVID_BASE + 5)\n#define VIVID_CID_INSERT_SAV\t\t(VIVID_CID_VIVID_BASE + 6)\n#define VIVID_CID_INSERT_EAV\t\t(VIVID_CID_VIVID_BASE + 7)\n#define VIVID_CID_VBI_CAP_INTERLACED\t(VIVID_CID_VIVID_BASE + 8)\n#define VIVID_CID_INSERT_HDMI_VIDEO_GUARD_BAND (VIVID_CID_VIVID_BASE + 9)\n\n#define VIVID_CID_HFLIP\t\t\t(VIVID_CID_VIVID_BASE + 20)\n#define VIVID_CID_VFLIP\t\t\t(VIVID_CID_VIVID_BASE + 21)\n#define VIVID_CID_STD_ASPECT_RATIO\t(VIVID_CID_VIVID_BASE + 22)\n#define VIVID_CID_DV_TIMINGS_ASPECT_RATIO\t(VIVID_CID_VIVID_BASE + 23)\n#define VIVID_CID_TSTAMP_SRC\t\t(VIVID_CID_VIVID_BASE + 24)\n#define VIVID_CID_COLORSPACE\t\t(VIVID_CID_VIVID_BASE + 25)\n#define VIVID_CID_XFER_FUNC\t\t(VIVID_CID_VIVID_BASE + 26)\n#define VIVID_CID_YCBCR_ENC\t\t(VIVID_CID_VIVID_BASE + 27)\n#define VIVID_CID_QUANTIZATION\t\t(VIVID_CID_VIVID_BASE + 28)\n#define VIVID_CID_LIMITED_RGB_RANGE\t(VIVID_CID_VIVID_BASE + 29)\n#define VIVID_CID_ALPHA_MODE\t\t(VIVID_CID_VIVID_BASE + 30)\n#define VIVID_CID_HAS_CROP_CAP\t\t(VIVID_CID_VIVID_BASE + 31)\n#define VIVID_CID_HAS_COMPOSE_CAP\t(VIVID_CID_VIVID_BASE + 32)\n#define VIVID_CID_HAS_SCALER_CAP\t(VIVID_CID_VIVID_BASE + 33)\n#define VIVID_CID_HAS_CROP_OUT\t\t(VIVID_CID_VIVID_BASE + 34)\n#define VIVID_CID_HAS_COMPOSE_OUT\t(VIVID_CID_VIVID_BASE + 35)\n#define VIVID_CID_HAS_SCALER_OUT\t(VIVID_CID_VIVID_BASE + 36)\n#define VIVID_CID_LOOP_VIDEO\t\t(VIVID_CID_VIVID_BASE + 37)\n#define VIVID_CID_SEQ_WRAP\t\t(VIVID_CID_VIVID_BASE + 38)\n#define VIVID_CID_TIME_WRAP\t\t(VIVID_CID_VIVID_BASE + 39)\n#define VIVID_CID_MAX_EDID_BLOCKS\t(VIVID_CID_VIVID_BASE + 40)\n#define VIVID_CID_PERCENTAGE_FILL\t(VIVID_CID_VIVID_BASE + 41)\n#define VIVID_CID_REDUCED_FPS\t\t(VIVID_CID_VIVID_BASE + 42)\n#define VIVID_CID_HSV_ENC\t\t(VIVID_CID_VIVID_BASE + 43)\n#define VIVID_CID_DISPLAY_PRESENT\t(VIVID_CID_VIVID_BASE + 44)\n\n#define VIVID_CID_STD_SIGNAL_MODE\t(VIVID_CID_VIVID_BASE + 60)\n#define VIVID_CID_STANDARD\t\t(VIVID_CID_VIVID_BASE + 61)\n#define VIVID_CID_DV_TIMINGS_SIGNAL_MODE\t(VIVID_CID_VIVID_BASE + 62)\n#define VIVID_CID_DV_TIMINGS\t\t(VIVID_CID_VIVID_BASE + 63)\n#define VIVID_CID_PERC_DROPPED\t\t(VIVID_CID_VIVID_BASE + 64)\n#define VIVID_CID_DISCONNECT\t\t(VIVID_CID_VIVID_BASE + 65)\n#define VIVID_CID_DQBUF_ERROR\t\t(VIVID_CID_VIVID_BASE + 66)\n#define VIVID_CID_QUEUE_SETUP_ERROR\t(VIVID_CID_VIVID_BASE + 67)\n#define VIVID_CID_BUF_PREPARE_ERROR\t(VIVID_CID_VIVID_BASE + 68)\n#define VIVID_CID_START_STR_ERROR\t(VIVID_CID_VIVID_BASE + 69)\n#define VIVID_CID_QUEUE_ERROR\t\t(VIVID_CID_VIVID_BASE + 70)\n#define VIVID_CID_CLEAR_FB\t\t(VIVID_CID_VIVID_BASE + 71)\n#define VIVID_CID_REQ_VALIDATE_ERROR\t(VIVID_CID_VIVID_BASE + 72)\n\n#define VIVID_CID_RADIO_SEEK_MODE\t(VIVID_CID_VIVID_BASE + 90)\n#define VIVID_CID_RADIO_SEEK_PROG_LIM\t(VIVID_CID_VIVID_BASE + 91)\n#define VIVID_CID_RADIO_RX_RDS_RBDS\t(VIVID_CID_VIVID_BASE + 92)\n#define VIVID_CID_RADIO_RX_RDS_BLOCKIO\t(VIVID_CID_VIVID_BASE + 93)\n\n#define VIVID_CID_RADIO_TX_RDS_BLOCKIO\t(VIVID_CID_VIVID_BASE + 94)\n\n#define VIVID_CID_SDR_CAP_FM_DEVIATION\t(VIVID_CID_VIVID_BASE + 110)\n\n#define VIVID_CID_META_CAP_GENERATE_PTS\t(VIVID_CID_VIVID_BASE + 111)\n#define VIVID_CID_META_CAP_GENERATE_SCR\t(VIVID_CID_VIVID_BASE + 112)\n\n \n\nstatic void vivid_unregister_dev(bool valid, struct video_device *vdev)\n{\n\tif (!valid)\n\t\treturn;\n\tclear_bit(V4L2_FL_REGISTERED, &vdev->flags);\n\tv4l2_event_wake_all(vdev);\n}\n\nstatic int vivid_user_gen_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_user_gen);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_DISCONNECT:\n\t\tv4l2_info(&dev->v4l2_dev, \"disconnect\\n\");\n\t\tdev->disconnect_error = true;\n\t\tvivid_unregister_dev(dev->has_vid_cap, &dev->vid_cap_dev);\n\t\tvivid_unregister_dev(dev->has_vid_out, &dev->vid_out_dev);\n\t\tvivid_unregister_dev(dev->has_vbi_cap, &dev->vbi_cap_dev);\n\t\tvivid_unregister_dev(dev->has_vbi_out, &dev->vbi_out_dev);\n\t\tvivid_unregister_dev(dev->has_radio_rx, &dev->radio_rx_dev);\n\t\tvivid_unregister_dev(dev->has_radio_tx, &dev->radio_tx_dev);\n\t\tvivid_unregister_dev(dev->has_sdr_cap, &dev->sdr_cap_dev);\n\t\tvivid_unregister_dev(dev->has_meta_cap, &dev->meta_cap_dev);\n\t\tvivid_unregister_dev(dev->has_meta_out, &dev->meta_out_dev);\n\t\tvivid_unregister_dev(dev->has_touch_cap, &dev->touch_cap_dev);\n\t\tbreak;\n\tcase VIVID_CID_BUTTON:\n\t\tdev->button_pressed = 30;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_user_gen_ctrl_ops = {\n\t.s_ctrl = vivid_user_gen_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_button = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_BUTTON,\n\t.name = \"Button\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_boolean = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_BOOLEAN,\n\t.name = \"Boolean\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_int32 = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_INTEGER,\n\t.name = \"Integer 32 Bits\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0xffffffff80000000ULL,\n\t.max = 0x7fffffff,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_int64 = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_INTEGER64,\n\t.name = \"Integer 64 Bits\",\n\t.type = V4L2_CTRL_TYPE_INTEGER64,\n\t.min = 0x8000000000000000ULL,\n\t.max = 0x7fffffffffffffffLL,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_u32_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_U32_ARRAY,\n\t.name = \"U32 1 Element Array\",\n\t.type = V4L2_CTRL_TYPE_U32,\n\t.def = 0x18,\n\t.min = 0x10,\n\t.max = 0x20000,\n\t.step = 1,\n\t.dims = { 1 },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_u32_dyn_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_U32_DYN_ARRAY,\n\t.name = \"U32 Dynamic Array\",\n\t.type = V4L2_CTRL_TYPE_U32,\n\t.flags = V4L2_CTRL_FLAG_DYNAMIC_ARRAY,\n\t.def = 50,\n\t.min = 10,\n\t.max = 90,\n\t.step = 1,\n\t.dims = { 100 },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_u16_matrix = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_U16_MATRIX,\n\t.name = \"U16 8x16 Matrix\",\n\t.type = V4L2_CTRL_TYPE_U16,\n\t.def = 0x18,\n\t.min = 0x10,\n\t.max = 0x2000,\n\t.step = 1,\n\t.dims = { 8, 16 },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_u8_4d_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_U8_4D_ARRAY,\n\t.name = \"U8 2x3x4x5 Array\",\n\t.type = V4L2_CTRL_TYPE_U8,\n\t.def = 0x18,\n\t.min = 0x10,\n\t.max = 0x20,\n\t.step = 1,\n\t.dims = { 2, 3, 4, 5 },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_u8_pixel_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_U8_PIXEL_ARRAY,\n\t.name = \"U8 Pixel Array\",\n\t.type = V4L2_CTRL_TYPE_U8,\n\t.def = 0x80,\n\t.min = 0x00,\n\t.max = 0xff,\n\t.step = 1,\n\t.dims = { 640 / PIXEL_ARRAY_DIV, 360 / PIXEL_ARRAY_DIV },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_s32_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_S32_ARRAY,\n\t.name = \"S32 2 Element Array\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 2,\n\t.min = -10,\n\t.max = 10,\n\t.step = 1,\n\t.dims = { 2 },\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_s64_array = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_S64_ARRAY,\n\t.name = \"S64 5 Element Array\",\n\t.type = V4L2_CTRL_TYPE_INTEGER64,\n\t.def = 4,\n\t.min = -10,\n\t.max = 10,\n\t.step = 1,\n\t.dims = { 5 },\n};\n\nstatic const char * const vivid_ctrl_menu_strings[] = {\n\t\"Menu Item 0 (Skipped)\",\n\t\"Menu Item 1\",\n\t\"Menu Item 2 (Skipped)\",\n\t\"Menu Item 3\",\n\t\"Menu Item 4\",\n\t\"Menu Item 5 (Skipped)\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_menu = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_MENU,\n\t.name = \"Menu\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.min = 1,\n\t.max = 4,\n\t.def = 3,\n\t.menu_skip_mask = 0x04,\n\t.qmenu = vivid_ctrl_menu_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_string = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_STRING,\n\t.name = \"String\",\n\t.type = V4L2_CTRL_TYPE_STRING,\n\t.min = 2,\n\t.max = 4,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_bitmask = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_BITMASK,\n\t.name = \"Bitmask\",\n\t.type = V4L2_CTRL_TYPE_BITMASK,\n\t.def = 0x80002000,\n\t.min = 0,\n\t.max = 0x80402010,\n\t.step = 0,\n};\n\nstatic const s64 vivid_ctrl_int_menu_values[] = {\n\t1, 1, 2, 3, 5, 8, 13, 21, 42,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_int_menu = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_INTMENU,\n\t.name = \"Integer Menu\",\n\t.type = V4L2_CTRL_TYPE_INTEGER_MENU,\n\t.min = 1,\n\t.max = 8,\n\t.def = 4,\n\t.menu_skip_mask = 0x02,\n\t.qmenu_int = vivid_ctrl_int_menu_values,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_disconnect = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_DISCONNECT,\n\t.name = \"Disconnect\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_area area = {\n\t.width = 1000,\n\t.height = 2000,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_area = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_AREA,\n\t.name = \"Area\",\n\t.type = V4L2_CTRL_TYPE_AREA,\n\t.p_def.p_const = &area,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_ro_int32 = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.id = VIVID_CID_RO_INTEGER,\n\t.name = \"Read-Only Integer 32 Bits\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY,\n\t.min = 0,\n\t.max = 255,\n\t.step = 1,\n};\n\n \n\nstatic int vivid_fb_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler,\n\t\t\t\t\t     struct vivid_dev, ctrl_hdl_fb);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_CLEAR_FB:\n\t\tvivid_clear_fb(dev);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_fb_ctrl_ops = {\n\t.s_ctrl = vivid_fb_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_clear_fb = {\n\t.ops = &vivid_fb_ctrl_ops,\n\t.id = VIVID_CID_CLEAR_FB,\n\t.name = \"Clear Framebuffer\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\n\n \n\nstatic int vivid_user_vid_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_user_vid);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tdev->gain->val = (jiffies_to_msecs(jiffies) / 1000) & 0xff;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vivid_user_vid_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_user_vid);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tdev->input_brightness[dev->input] = ctrl->val - dev->input * 128;\n\t\ttpg_s_brightness(&dev->tpg, dev->input_brightness[dev->input]);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\ttpg_s_contrast(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\ttpg_s_saturation(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\ttpg_s_hue(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tdev->hflip = ctrl->val;\n\t\ttpg_s_hflip(&dev->tpg, dev->sensor_hflip ^ dev->hflip);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tdev->vflip = ctrl->val;\n\t\ttpg_s_vflip(&dev->tpg, dev->sensor_vflip ^ dev->vflip);\n\t\tbreak;\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\ttpg_s_alpha_component(&dev->tpg, ctrl->val);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_user_vid_ctrl_ops = {\n\t.g_volatile_ctrl = vivid_user_vid_g_volatile_ctrl,\n\t.s_ctrl = vivid_user_vid_s_ctrl,\n};\n\n\n \n\nstatic int vivid_vid_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstatic const u32 colorspaces[] = {\n\t\tV4L2_COLORSPACE_SMPTE170M,\n\t\tV4L2_COLORSPACE_REC709,\n\t\tV4L2_COLORSPACE_SRGB,\n\t\tV4L2_COLORSPACE_OPRGB,\n\t\tV4L2_COLORSPACE_BT2020,\n\t\tV4L2_COLORSPACE_DCI_P3,\n\t\tV4L2_COLORSPACE_SMPTE240M,\n\t\tV4L2_COLORSPACE_470_SYSTEM_M,\n\t\tV4L2_COLORSPACE_470_SYSTEM_BG,\n\t};\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_vid_cap);\n\tunsigned int i, j;\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_TEST_PATTERN:\n\t\tvivid_update_quality(dev);\n\t\ttpg_s_pattern(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_COLORSPACE:\n\t\ttpg_s_colorspace(&dev->tpg, colorspaces[ctrl->val]);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tvivid_send_source_change(dev, WEBCAM);\n\t\tbreak;\n\tcase VIVID_CID_XFER_FUNC:\n\t\ttpg_s_xfer_func(&dev->tpg, ctrl->val);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tvivid_send_source_change(dev, WEBCAM);\n\t\tbreak;\n\tcase VIVID_CID_YCBCR_ENC:\n\t\ttpg_s_ycbcr_enc(&dev->tpg, ctrl->val);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tvivid_send_source_change(dev, WEBCAM);\n\t\tbreak;\n\tcase VIVID_CID_HSV_ENC:\n\t\ttpg_s_hsv_enc(&dev->tpg, ctrl->val ? V4L2_HSV_ENC_256 :\n\t\t\t\t\t\t     V4L2_HSV_ENC_180);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tvivid_send_source_change(dev, WEBCAM);\n\t\tbreak;\n\tcase VIVID_CID_QUANTIZATION:\n\t\ttpg_s_quantization(&dev->tpg, ctrl->val);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tvivid_send_source_change(dev, WEBCAM);\n\t\tbreak;\n\tcase V4L2_CID_DV_RX_RGB_RANGE:\n\t\tif (!vivid_is_hdmi_cap(dev))\n\t\t\tbreak;\n\t\ttpg_s_rgb_range(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_LIMITED_RGB_RANGE:\n\t\ttpg_s_real_rgb_range(&dev->tpg, ctrl->val ?\n\t\t\t\tV4L2_DV_RGB_RANGE_LIMITED : V4L2_DV_RGB_RANGE_FULL);\n\t\tbreak;\n\tcase VIVID_CID_ALPHA_MODE:\n\t\ttpg_s_alpha_mode(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_HOR_MOVEMENT:\n\t\ttpg_s_mv_hor_mode(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_VERT_MOVEMENT:\n\t\ttpg_s_mv_vert_mode(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_OSD_TEXT_MODE:\n\t\tdev->osd_mode = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_PERCENTAGE_FILL:\n\t\ttpg_s_perc_fill(&dev->tpg, ctrl->val);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++)\n\t\t\tdev->must_blank[i] = ctrl->val < 100;\n\t\tbreak;\n\tcase VIVID_CID_INSERT_SAV:\n\t\ttpg_s_insert_sav(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_INSERT_EAV:\n\t\ttpg_s_insert_eav(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_INSERT_HDMI_VIDEO_GUARD_BAND:\n\t\ttpg_s_insert_hdmi_video_guard_band(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_HFLIP:\n\t\tdev->sensor_hflip = ctrl->val;\n\t\ttpg_s_hflip(&dev->tpg, dev->sensor_hflip ^ dev->hflip);\n\t\tbreak;\n\tcase VIVID_CID_VFLIP:\n\t\tdev->sensor_vflip = ctrl->val;\n\t\ttpg_s_vflip(&dev->tpg, dev->sensor_vflip ^ dev->vflip);\n\t\tbreak;\n\tcase VIVID_CID_REDUCED_FPS:\n\t\tdev->reduced_fps = ctrl->val;\n\t\tvivid_update_format_cap(dev, true);\n\t\tbreak;\n\tcase VIVID_CID_HAS_CROP_CAP:\n\t\tdev->has_crop_cap = ctrl->val;\n\t\tvivid_update_format_cap(dev, true);\n\t\tbreak;\n\tcase VIVID_CID_HAS_COMPOSE_CAP:\n\t\tdev->has_compose_cap = ctrl->val;\n\t\tvivid_update_format_cap(dev, true);\n\t\tbreak;\n\tcase VIVID_CID_HAS_SCALER_CAP:\n\t\tdev->has_scaler_cap = ctrl->val;\n\t\tvivid_update_format_cap(dev, true);\n\t\tbreak;\n\tcase VIVID_CID_SHOW_BORDER:\n\t\ttpg_s_show_border(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_SHOW_SQUARE:\n\t\ttpg_s_show_square(&dev->tpg, ctrl->val);\n\t\tbreak;\n\tcase VIVID_CID_STD_ASPECT_RATIO:\n\t\tdev->std_aspect_ratio[dev->input] = ctrl->val;\n\t\ttpg_s_video_aspect(&dev->tpg, vivid_get_video_aspect(dev));\n\t\tbreak;\n\tcase VIVID_CID_DV_TIMINGS_SIGNAL_MODE:\n\t\tdev->dv_timings_signal_mode[dev->input] =\n\t\t\tdev->ctrl_dv_timings_signal_mode->val;\n\t\tdev->query_dv_timings[dev->input] = dev->ctrl_dv_timings->val;\n\n\t\tdev->power_present = 0;\n\t\tfor (i = 0, j = 0;\n\t\t     i < ARRAY_SIZE(dev->dv_timings_signal_mode);\n\t\t     i++)\n\t\t\tif (dev->input_type[i] == HDMI) {\n\t\t\t\tif (dev->dv_timings_signal_mode[i] != NO_SIGNAL)\n\t\t\t\t\tdev->power_present |= (1 << j);\n\t\t\t\tj++;\n\t\t\t}\n\t\t__v4l2_ctrl_s_ctrl(dev->ctrl_rx_power_present,\n\t\t\t\t   dev->power_present);\n\n\t\tv4l2_ctrl_activate(dev->ctrl_dv_timings,\n\t\t\tdev->dv_timings_signal_mode[dev->input] ==\n\t\t\t\tSELECTED_DV_TIMINGS);\n\n\t\tvivid_update_quality(dev);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tbreak;\n\tcase VIVID_CID_DV_TIMINGS_ASPECT_RATIO:\n\t\tdev->dv_timings_aspect_ratio[dev->input] = ctrl->val;\n\t\ttpg_s_video_aspect(&dev->tpg, vivid_get_video_aspect(dev));\n\t\tbreak;\n\tcase VIVID_CID_TSTAMP_SRC:\n\t\tdev->tstamp_src_is_soe = ctrl->val;\n\t\tdev->vb_vid_cap_q.timestamp_flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\tif (dev->tstamp_src_is_soe)\n\t\t\tdev->vb_vid_cap_q.timestamp_flags |= V4L2_BUF_FLAG_TSTAMP_SRC_SOE;\n\t\tbreak;\n\tcase VIVID_CID_MAX_EDID_BLOCKS:\n\t\tdev->edid_max_blocks = ctrl->val;\n\t\tif (dev->edid_blocks > dev->edid_max_blocks)\n\t\t\tdev->edid_blocks = dev->edid_max_blocks;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_vid_cap_ctrl_ops = {\n\t.s_ctrl = vivid_vid_cap_s_ctrl,\n};\n\nstatic const char * const vivid_ctrl_hor_movement_strings[] = {\n\t\"Move Left Fast\",\n\t\"Move Left\",\n\t\"Move Left Slow\",\n\t\"No Movement\",\n\t\"Move Right Slow\",\n\t\"Move Right\",\n\t\"Move Right Fast\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_hor_movement = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HOR_MOVEMENT,\n\t.name = \"Horizontal Movement\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = TPG_MOVE_POS_FAST,\n\t.def = TPG_MOVE_NONE,\n\t.qmenu = vivid_ctrl_hor_movement_strings,\n};\n\nstatic const char * const vivid_ctrl_vert_movement_strings[] = {\n\t\"Move Up Fast\",\n\t\"Move Up\",\n\t\"Move Up Slow\",\n\t\"No Movement\",\n\t\"Move Down Slow\",\n\t\"Move Down\",\n\t\"Move Down Fast\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_vert_movement = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_VERT_MOVEMENT,\n\t.name = \"Vertical Movement\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = TPG_MOVE_POS_FAST,\n\t.def = TPG_MOVE_NONE,\n\t.qmenu = vivid_ctrl_vert_movement_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_show_border = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_SHOW_BORDER,\n\t.name = \"Show Border\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_show_square = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_SHOW_SQUARE,\n\t.name = \"Show Square\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const char * const vivid_ctrl_osd_mode_strings[] = {\n\t\"All\",\n\t\"Counters Only\",\n\t\"None\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_osd_mode = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_OSD_TEXT_MODE,\n\t.name = \"OSD Text Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_osd_mode_strings) - 2,\n\t.qmenu = vivid_ctrl_osd_mode_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_perc_fill = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_PERCENTAGE_FILL,\n\t.name = \"Fill Percentage of Frame\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 100,\n\t.def = 100,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_insert_sav = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_INSERT_SAV,\n\t.name = \"Insert SAV Code in Image\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_insert_eav = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_INSERT_EAV,\n\t.name = \"Insert EAV Code in Image\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_insert_hdmi_video_guard_band = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_INSERT_HDMI_VIDEO_GUARD_BAND,\n\t.name = \"Insert Video Guard Band\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_hflip = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HFLIP,\n\t.name = \"Sensor Flipped Horizontally\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_vflip = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_VFLIP,\n\t.name = \"Sensor Flipped Vertically\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_reduced_fps = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_REDUCED_FPS,\n\t.name = \"Reduced Framerate\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_crop_cap = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HAS_CROP_CAP,\n\t.name = \"Enable Capture Cropping\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_compose_cap = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HAS_COMPOSE_CAP,\n\t.name = \"Enable Capture Composing\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_scaler_cap = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HAS_SCALER_CAP,\n\t.name = \"Enable Capture Scaler\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const char * const vivid_ctrl_tstamp_src_strings[] = {\n\t\"End of Frame\",\n\t\"Start of Exposure\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_tstamp_src = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_TSTAMP_SRC,\n\t.name = \"Timestamp Source\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_tstamp_src_strings) - 2,\n\t.qmenu = vivid_ctrl_tstamp_src_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_std_aspect_ratio = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_STD_ASPECT_RATIO,\n\t.name = \"Standard Aspect Ratio\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.min = 1,\n\t.max = 4,\n\t.def = 1,\n\t.qmenu = tpg_aspect_strings,\n};\n\nstatic const char * const vivid_ctrl_dv_timings_signal_mode_strings[] = {\n\t\"Current DV Timings\",\n\t\"No Signal\",\n\t\"No Lock\",\n\t\"Out of Range\",\n\t\"Selected DV Timings\",\n\t\"Cycle Through All DV Timings\",\n\t\"Custom DV Timings\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_dv_timings_signal_mode = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_DV_TIMINGS_SIGNAL_MODE,\n\t.name = \"DV Timings Signal Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = 5,\n\t.qmenu = vivid_ctrl_dv_timings_signal_mode_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_dv_timings_aspect_ratio = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_DV_TIMINGS_ASPECT_RATIO,\n\t.name = \"DV Timings Aspect Ratio\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = 3,\n\t.qmenu = tpg_aspect_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_max_edid_blocks = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_MAX_EDID_BLOCKS,\n\t.name = \"Maximum EDID Blocks\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = 256,\n\t.def = 2,\n\t.step = 1,\n};\n\nstatic const char * const vivid_ctrl_colorspace_strings[] = {\n\t\"SMPTE 170M\",\n\t\"Rec. 709\",\n\t\"sRGB\",\n\t\"opRGB\",\n\t\"BT.2020\",\n\t\"DCI-P3\",\n\t\"SMPTE 240M\",\n\t\"470 System M\",\n\t\"470 System BG\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_colorspace = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_COLORSPACE,\n\t.name = \"Colorspace\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_colorspace_strings) - 2,\n\t.def = 2,\n\t.qmenu = vivid_ctrl_colorspace_strings,\n};\n\nstatic const char * const vivid_ctrl_xfer_func_strings[] = {\n\t\"Default\",\n\t\"Rec. 709\",\n\t\"sRGB\",\n\t\"opRGB\",\n\t\"SMPTE 240M\",\n\t\"None\",\n\t\"DCI-P3\",\n\t\"SMPTE 2084\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_xfer_func = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_XFER_FUNC,\n\t.name = \"Transfer Function\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_xfer_func_strings) - 2,\n\t.qmenu = vivid_ctrl_xfer_func_strings,\n};\n\nstatic const char * const vivid_ctrl_ycbcr_enc_strings[] = {\n\t\"Default\",\n\t\"ITU-R 601\",\n\t\"Rec. 709\",\n\t\"xvYCC 601\",\n\t\"xvYCC 709\",\n\t\"\",\n\t\"BT.2020\",\n\t\"BT.2020 Constant Luminance\",\n\t\"SMPTE 240M\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_ycbcr_enc = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_YCBCR_ENC,\n\t.name = \"Y'CbCr Encoding\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.menu_skip_mask = 1 << 5,\n\t.max = ARRAY_SIZE(vivid_ctrl_ycbcr_enc_strings) - 2,\n\t.qmenu = vivid_ctrl_ycbcr_enc_strings,\n};\n\nstatic const char * const vivid_ctrl_hsv_enc_strings[] = {\n\t\"Hue 0-179\",\n\t\"Hue 0-256\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_hsv_enc = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_HSV_ENC,\n\t.name = \"HSV Encoding\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_hsv_enc_strings) - 2,\n\t.qmenu = vivid_ctrl_hsv_enc_strings,\n};\n\nstatic const char * const vivid_ctrl_quantization_strings[] = {\n\t\"Default\",\n\t\"Full Range\",\n\t\"Limited Range\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_quantization = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_QUANTIZATION,\n\t.name = \"Quantization\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_quantization_strings) - 2,\n\t.qmenu = vivid_ctrl_quantization_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_alpha_mode = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_ALPHA_MODE,\n\t.name = \"Apply Alpha To Red Only\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_limited_rgb_range = {\n\t.ops = &vivid_vid_cap_ctrl_ops,\n\t.id = VIVID_CID_LIMITED_RGB_RANGE,\n\t.name = \"Limited RGB Range (16-235)\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\n\n \n\nstatic int vivid_loop_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_loop_cap);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_LOOP_VIDEO:\n\t\tdev->loop_video = ctrl->val;\n\t\tvivid_update_quality(dev);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_loop_cap_ctrl_ops = {\n\t.s_ctrl = vivid_loop_cap_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_loop_video = {\n\t.ops = &vivid_loop_cap_ctrl_ops,\n\t.id = VIVID_CID_LOOP_VIDEO,\n\t.name = \"Loop Video\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\n\n \n\nstatic int vivid_vbi_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_vbi_cap);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_VBI_CAP_INTERLACED:\n\t\tdev->vbi_cap_interlaced = ctrl->val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_vbi_cap_ctrl_ops = {\n\t.s_ctrl = vivid_vbi_cap_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_vbi_cap_interlaced = {\n\t.ops = &vivid_vbi_cap_ctrl_ops,\n\t.id = VIVID_CID_VBI_CAP_INTERLACED,\n\t.name = \"Interlaced VBI Format\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\n\n \n\nstatic int vivid_vid_out_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_vid_out);\n\tstruct v4l2_bt_timings *bt = &dev->dv_timings_out.bt;\n\tu32 display_present = 0;\n\tunsigned int i, j, bus_idx;\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_HAS_CROP_OUT:\n\t\tdev->has_crop_out = ctrl->val;\n\t\tvivid_update_format_out(dev);\n\t\tbreak;\n\tcase VIVID_CID_HAS_COMPOSE_OUT:\n\t\tdev->has_compose_out = ctrl->val;\n\t\tvivid_update_format_out(dev);\n\t\tbreak;\n\tcase VIVID_CID_HAS_SCALER_OUT:\n\t\tdev->has_scaler_out = ctrl->val;\n\t\tvivid_update_format_out(dev);\n\t\tbreak;\n\tcase V4L2_CID_DV_TX_MODE:\n\t\tdev->dvi_d_out = ctrl->val == V4L2_DV_TX_MODE_DVI_D;\n\t\tif (!vivid_is_hdmi_out(dev))\n\t\t\tbreak;\n\t\tif (!dev->dvi_d_out && (bt->flags & V4L2_DV_FL_IS_CE_VIDEO)) {\n\t\t\tif (bt->width == 720 && bt->height <= 576)\n\t\t\t\tdev->colorspace_out = V4L2_COLORSPACE_SMPTE170M;\n\t\t\telse\n\t\t\t\tdev->colorspace_out = V4L2_COLORSPACE_REC709;\n\t\t\tdev->quantization_out = V4L2_QUANTIZATION_DEFAULT;\n\t\t} else {\n\t\t\tdev->colorspace_out = V4L2_COLORSPACE_SRGB;\n\t\t\tdev->quantization_out = dev->dvi_d_out ?\n\t\t\t\t\tV4L2_QUANTIZATION_LIM_RANGE :\n\t\t\t\t\tV4L2_QUANTIZATION_DEFAULT;\n\t\t}\n\t\tif (dev->loop_video)\n\t\t\tvivid_send_source_change(dev, HDMI);\n\t\tbreak;\n\tcase VIVID_CID_DISPLAY_PRESENT:\n\t\tif (dev->output_type[dev->output] != HDMI)\n\t\t\tbreak;\n\n\t\tdev->display_present[dev->output] = ctrl->val;\n\t\tfor (i = 0, j = 0; i < dev->num_outputs; i++)\n\t\t\tif (dev->output_type[i] == HDMI)\n\t\t\t\tdisplay_present |=\n\t\t\t\t\tdev->display_present[i] << j++;\n\n\t\t__v4l2_ctrl_s_ctrl(dev->ctrl_tx_rxsense, display_present);\n\n\t\tif (dev->edid_blocks) {\n\t\t\t__v4l2_ctrl_s_ctrl(dev->ctrl_tx_edid_present,\n\t\t\t\t\t   display_present);\n\t\t\t__v4l2_ctrl_s_ctrl(dev->ctrl_tx_hotplug,\n\t\t\t\t\t   display_present);\n\t\t}\n\n\t\tbus_idx = dev->cec_output2bus_map[dev->output];\n\t\tif (!dev->cec_tx_adap[bus_idx])\n\t\t\tbreak;\n\n\t\tif (ctrl->val && dev->edid_blocks)\n\t\t\tcec_s_phys_addr(dev->cec_tx_adap[bus_idx],\n\t\t\t\t\tdev->cec_tx_adap[bus_idx]->phys_addr,\n\t\t\t\t\tfalse);\n\t\telse\n\t\t\tcec_phys_addr_invalidate(dev->cec_tx_adap[bus_idx]);\n\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_vid_out_ctrl_ops = {\n\t.s_ctrl = vivid_vid_out_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_crop_out = {\n\t.ops = &vivid_vid_out_ctrl_ops,\n\t.id = VIVID_CID_HAS_CROP_OUT,\n\t.name = \"Enable Output Cropping\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_compose_out = {\n\t.ops = &vivid_vid_out_ctrl_ops,\n\t.id = VIVID_CID_HAS_COMPOSE_OUT,\n\t.name = \"Enable Output Composing\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_has_scaler_out = {\n\t.ops = &vivid_vid_out_ctrl_ops,\n\t.id = VIVID_CID_HAS_SCALER_OUT,\n\t.name = \"Enable Output Scaler\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_display_present = {\n\t.ops = &vivid_vid_out_ctrl_ops,\n\t.id = VIVID_CID_DISPLAY_PRESENT,\n\t.name = \"Display Present\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\n \n\nstatic int vivid_streaming_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_streaming);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_DQBUF_ERROR:\n\t\tdev->dqbuf_error = true;\n\t\tbreak;\n\tcase VIVID_CID_PERC_DROPPED:\n\t\tdev->perc_dropped_buffers = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_QUEUE_SETUP_ERROR:\n\t\tdev->queue_setup_error = true;\n\t\tbreak;\n\tcase VIVID_CID_BUF_PREPARE_ERROR:\n\t\tdev->buf_prepare_error = true;\n\t\tbreak;\n\tcase VIVID_CID_START_STR_ERROR:\n\t\tdev->start_streaming_error = true;\n\t\tbreak;\n\tcase VIVID_CID_REQ_VALIDATE_ERROR:\n\t\tdev->req_validate_error = true;\n\t\tbreak;\n\tcase VIVID_CID_QUEUE_ERROR:\n\t\tif (vb2_start_streaming_called(&dev->vb_vid_cap_q))\n\t\t\tvb2_queue_error(&dev->vb_vid_cap_q);\n\t\tif (vb2_start_streaming_called(&dev->vb_vbi_cap_q))\n\t\t\tvb2_queue_error(&dev->vb_vbi_cap_q);\n\t\tif (vb2_start_streaming_called(&dev->vb_vid_out_q))\n\t\t\tvb2_queue_error(&dev->vb_vid_out_q);\n\t\tif (vb2_start_streaming_called(&dev->vb_vbi_out_q))\n\t\t\tvb2_queue_error(&dev->vb_vbi_out_q);\n\t\tif (vb2_start_streaming_called(&dev->vb_sdr_cap_q))\n\t\t\tvb2_queue_error(&dev->vb_sdr_cap_q);\n\t\tbreak;\n\tcase VIVID_CID_SEQ_WRAP:\n\t\tdev->seq_wrap = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_TIME_WRAP:\n\t\tdev->time_wrap = ctrl->val;\n\t\tif (dev->time_wrap == 1)\n\t\t\tdev->time_wrap = (1ULL << 63) - NSEC_PER_SEC * 16ULL;\n\t\telse if (dev->time_wrap == 2)\n\t\t\tdev->time_wrap = ((1ULL << 31) - 16) * NSEC_PER_SEC;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_streaming_ctrl_ops = {\n\t.s_ctrl = vivid_streaming_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_dqbuf_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_DQBUF_ERROR,\n\t.name = \"Inject V4L2_BUF_FLAG_ERROR\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_perc_dropped = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_PERC_DROPPED,\n\t.name = \"Percentage of Dropped Buffers\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 100,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_queue_setup_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_QUEUE_SETUP_ERROR,\n\t.name = \"Inject VIDIOC_REQBUFS Error\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_buf_prepare_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_BUF_PREPARE_ERROR,\n\t.name = \"Inject VIDIOC_QBUF Error\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_start_streaming_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_START_STR_ERROR,\n\t.name = \"Inject VIDIOC_STREAMON Error\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_queue_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_QUEUE_ERROR,\n\t.name = \"Inject Fatal Streaming Error\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nstatic const struct v4l2_ctrl_config vivid_ctrl_req_validate_error = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_REQ_VALIDATE_ERROR,\n\t.name = \"Inject req_validate() Error\",\n\t.type = V4L2_CTRL_TYPE_BUTTON,\n};\n#endif\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_seq_wrap = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_SEQ_WRAP,\n\t.name = \"Wrap Sequence Number\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const char * const vivid_ctrl_time_wrap_strings[] = {\n\t\"None\",\n\t\"64 Bit\",\n\t\"32 Bit\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_time_wrap = {\n\t.ops = &vivid_streaming_ctrl_ops,\n\t.id = VIVID_CID_TIME_WRAP,\n\t.name = \"Wrap Timestamp\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_time_wrap_strings) - 2,\n\t.qmenu = vivid_ctrl_time_wrap_strings,\n};\n\n\n \n\nstatic int vivid_sdtv_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_sdtv_cap);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_STD_SIGNAL_MODE:\n\t\tdev->std_signal_mode[dev->input] =\n\t\t\tdev->ctrl_std_signal_mode->val;\n\t\tif (dev->std_signal_mode[dev->input] == SELECTED_STD)\n\t\t\tdev->query_std[dev->input] =\n\t\t\t\tvivid_standard[dev->ctrl_standard->val];\n\t\tv4l2_ctrl_activate(dev->ctrl_standard,\n\t\t\t\t   dev->std_signal_mode[dev->input] ==\n\t\t\t\t\tSELECTED_STD);\n\t\tvivid_update_quality(dev);\n\t\tvivid_send_source_change(dev, TV);\n\t\tvivid_send_source_change(dev, SVID);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_sdtv_cap_ctrl_ops = {\n\t.s_ctrl = vivid_sdtv_cap_s_ctrl,\n};\n\nstatic const char * const vivid_ctrl_std_signal_mode_strings[] = {\n\t\"Current Standard\",\n\t\"No Signal\",\n\t\"No Lock\",\n\t\"\",\n\t\"Selected Standard\",\n\t\"Cycle Through All Standards\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_std_signal_mode = {\n\t.ops = &vivid_sdtv_cap_ctrl_ops,\n\t.id = VIVID_CID_STD_SIGNAL_MODE,\n\t.name = \"Standard Signal Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(vivid_ctrl_std_signal_mode_strings) - 2,\n\t.menu_skip_mask = 1 << 3,\n\t.qmenu = vivid_ctrl_std_signal_mode_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_standard = {\n\t.ops = &vivid_sdtv_cap_ctrl_ops,\n\t.id = VIVID_CID_STANDARD,\n\t.name = \"Standard\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = 14,\n\t.qmenu = vivid_ctrl_standard_strings,\n};\n\n\n\n \n\nstatic int vivid_radio_rx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_radio_rx);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_RADIO_SEEK_MODE:\n\t\tdev->radio_rx_hw_seek_mode = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_RADIO_SEEK_PROG_LIM:\n\t\tdev->radio_rx_hw_seek_prog_lim = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_RADIO_RX_RDS_RBDS:\n\t\tdev->rds_gen.use_rbds = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_RADIO_RX_RDS_BLOCKIO:\n\t\tdev->radio_rx_rds_controls = ctrl->val;\n\t\tdev->radio_rx_caps &= ~V4L2_CAP_READWRITE;\n\t\tdev->radio_rx_rds_use_alternates = false;\n\t\tif (!dev->radio_rx_rds_controls) {\n\t\t\tdev->radio_rx_caps |= V4L2_CAP_READWRITE;\n\t\t\t__v4l2_ctrl_s_ctrl(dev->radio_rx_rds_pty, 0);\n\t\t\t__v4l2_ctrl_s_ctrl(dev->radio_rx_rds_ta, 0);\n\t\t\t__v4l2_ctrl_s_ctrl(dev->radio_rx_rds_tp, 0);\n\t\t\t__v4l2_ctrl_s_ctrl(dev->radio_rx_rds_ms, 0);\n\t\t\t__v4l2_ctrl_s_ctrl_string(dev->radio_rx_rds_psname, \"\");\n\t\t\t__v4l2_ctrl_s_ctrl_string(dev->radio_rx_rds_radiotext, \"\");\n\t\t}\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_pty, dev->radio_rx_rds_controls);\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_psname, dev->radio_rx_rds_controls);\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_radiotext, dev->radio_rx_rds_controls);\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_ta, dev->radio_rx_rds_controls);\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_tp, dev->radio_rx_rds_controls);\n\t\tv4l2_ctrl_activate(dev->radio_rx_rds_ms, dev->radio_rx_rds_controls);\n\t\tdev->radio_rx_dev.device_caps = dev->radio_rx_caps;\n\t\tbreak;\n\tcase V4L2_CID_RDS_RECEPTION:\n\t\tdev->radio_rx_rds_enabled = ctrl->val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_radio_rx_ctrl_ops = {\n\t.s_ctrl = vivid_radio_rx_s_ctrl,\n};\n\nstatic const char * const vivid_ctrl_radio_rds_mode_strings[] = {\n\t\"Block I/O\",\n\t\"Controls\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_radio_rx_rds_blockio = {\n\t.ops = &vivid_radio_rx_ctrl_ops,\n\t.id = VIVID_CID_RADIO_RX_RDS_BLOCKIO,\n\t.name = \"RDS Rx I/O Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.qmenu = vivid_ctrl_radio_rds_mode_strings,\n\t.max = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_radio_rx_rds_rbds = {\n\t.ops = &vivid_radio_rx_ctrl_ops,\n\t.id = VIVID_CID_RADIO_RX_RDS_RBDS,\n\t.name = \"Generate RBDS Instead of RDS\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic const char * const vivid_ctrl_radio_hw_seek_mode_strings[] = {\n\t\"Bounded\",\n\t\"Wrap Around\",\n\t\"Both\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_radio_hw_seek_mode = {\n\t.ops = &vivid_radio_rx_ctrl_ops,\n\t.id = VIVID_CID_RADIO_SEEK_MODE,\n\t.name = \"Radio HW Seek Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = 2,\n\t.qmenu = vivid_ctrl_radio_hw_seek_mode_strings,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_radio_hw_seek_prog_lim = {\n\t.ops = &vivid_radio_rx_ctrl_ops,\n\t.id = VIVID_CID_RADIO_SEEK_PROG_LIM,\n\t.name = \"Radio Programmable HW Seek\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\n\n \n\nstatic int vivid_radio_tx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_radio_tx);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_RADIO_TX_RDS_BLOCKIO:\n\t\tdev->radio_tx_rds_controls = ctrl->val;\n\t\tdev->radio_tx_caps &= ~V4L2_CAP_READWRITE;\n\t\tif (!dev->radio_tx_rds_controls)\n\t\t\tdev->radio_tx_caps |= V4L2_CAP_READWRITE;\n\t\tdev->radio_tx_dev.device_caps = dev->radio_tx_caps;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_PTY:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl(dev->radio_rx_rds_pty, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_PS_NAME:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl_string(dev->radio_rx_rds_psname, ctrl->p_new.p_char);\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_RADIO_TEXT:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl_string(dev->radio_rx_rds_radiotext, ctrl->p_new.p_char);\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl(dev->radio_rx_rds_ta, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_TRAFFIC_PROGRAM:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl(dev->radio_rx_rds_tp, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_MUSIC_SPEECH:\n\t\tif (dev->radio_rx_rds_controls)\n\t\t\tv4l2_ctrl_s_ctrl(dev->radio_rx_rds_ms, ctrl->val);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_radio_tx_ctrl_ops = {\n\t.s_ctrl = vivid_radio_tx_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_radio_tx_rds_blockio = {\n\t.ops = &vivid_radio_tx_ctrl_ops,\n\t.id = VIVID_CID_RADIO_TX_RDS_BLOCKIO,\n\t.name = \"RDS Tx I/O Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.qmenu = vivid_ctrl_radio_rds_mode_strings,\n\t.max = 1,\n\t.def = 1,\n};\n\n\n \n\nstatic int vivid_sdr_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev, ctrl_hdl_sdr_cap);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_SDR_CAP_FM_DEVIATION:\n\t\tdev->sdr_fm_deviation = ctrl->val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_sdr_cap_ctrl_ops = {\n\t.s_ctrl = vivid_sdr_cap_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_sdr_cap_fm_deviation = {\n\t.ops = &vivid_sdr_cap_ctrl_ops,\n\t.id = VIVID_CID_SDR_CAP_FM_DEVIATION,\n\t.name = \"FM Deviation\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min =    100,\n\t.max = 200000,\n\t.def =  75000,\n\t.step =     1,\n};\n\n \n\nstatic int vivid_meta_cap_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vivid_dev *dev = container_of(ctrl->handler, struct vivid_dev,\n\t\t\t\t\t     ctrl_hdl_meta_cap);\n\n\tswitch (ctrl->id) {\n\tcase VIVID_CID_META_CAP_GENERATE_PTS:\n\t\tdev->meta_pts = ctrl->val;\n\t\tbreak;\n\tcase VIVID_CID_META_CAP_GENERATE_SCR:\n\t\tdev->meta_scr = ctrl->val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vivid_meta_cap_ctrl_ops = {\n\t.s_ctrl = vivid_meta_cap_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_meta_has_pts = {\n\t.ops = &vivid_meta_cap_ctrl_ops,\n\t.id = VIVID_CID_META_CAP_GENERATE_PTS,\n\t.name = \"Generate PTS\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_meta_has_src_clk = {\n\t.ops = &vivid_meta_cap_ctrl_ops,\n\t.id = VIVID_CID_META_CAP_GENERATE_SCR,\n\t.name = \"Generate SCR\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.def = 1,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config vivid_ctrl_class = {\n\t.ops = &vivid_user_gen_ctrl_ops,\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_WRITE_ONLY,\n\t.id = VIVID_CID_VIVID_CLASS,\n\t.name = \"Vivid Controls\",\n\t.type = V4L2_CTRL_TYPE_CTRL_CLASS,\n};\n\nint vivid_create_controls(struct vivid_dev *dev, bool show_ccs_cap,\n\t\tbool show_ccs_out, bool no_error_inj,\n\t\tbool has_sdtv, bool has_hdmi)\n{\n\tstruct v4l2_ctrl_handler *hdl_user_gen = &dev->ctrl_hdl_user_gen;\n\tstruct v4l2_ctrl_handler *hdl_user_vid = &dev->ctrl_hdl_user_vid;\n\tstruct v4l2_ctrl_handler *hdl_user_aud = &dev->ctrl_hdl_user_aud;\n\tstruct v4l2_ctrl_handler *hdl_streaming = &dev->ctrl_hdl_streaming;\n\tstruct v4l2_ctrl_handler *hdl_sdtv_cap = &dev->ctrl_hdl_sdtv_cap;\n\tstruct v4l2_ctrl_handler *hdl_loop_cap = &dev->ctrl_hdl_loop_cap;\n\tstruct v4l2_ctrl_handler *hdl_fb = &dev->ctrl_hdl_fb;\n\tstruct v4l2_ctrl_handler *hdl_vid_cap = &dev->ctrl_hdl_vid_cap;\n\tstruct v4l2_ctrl_handler *hdl_vid_out = &dev->ctrl_hdl_vid_out;\n\tstruct v4l2_ctrl_handler *hdl_vbi_cap = &dev->ctrl_hdl_vbi_cap;\n\tstruct v4l2_ctrl_handler *hdl_vbi_out = &dev->ctrl_hdl_vbi_out;\n\tstruct v4l2_ctrl_handler *hdl_radio_rx = &dev->ctrl_hdl_radio_rx;\n\tstruct v4l2_ctrl_handler *hdl_radio_tx = &dev->ctrl_hdl_radio_tx;\n\tstruct v4l2_ctrl_handler *hdl_sdr_cap = &dev->ctrl_hdl_sdr_cap;\n\tstruct v4l2_ctrl_handler *hdl_meta_cap = &dev->ctrl_hdl_meta_cap;\n\tstruct v4l2_ctrl_handler *hdl_meta_out = &dev->ctrl_hdl_meta_out;\n\tstruct v4l2_ctrl_handler *hdl_tch_cap = &dev->ctrl_hdl_touch_cap;\n\n\tstruct v4l2_ctrl_config vivid_ctrl_dv_timings = {\n\t\t.ops = &vivid_vid_cap_ctrl_ops,\n\t\t.id = VIVID_CID_DV_TIMINGS,\n\t\t.name = \"DV Timings\",\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t};\n\tint i;\n\n\tv4l2_ctrl_handler_init(hdl_user_gen, 10);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_user_vid, 9);\n\tv4l2_ctrl_new_custom(hdl_user_vid, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_user_aud, 2);\n\tv4l2_ctrl_new_custom(hdl_user_aud, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_streaming, 8);\n\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_sdtv_cap, 2);\n\tv4l2_ctrl_new_custom(hdl_sdtv_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_loop_cap, 1);\n\tv4l2_ctrl_new_custom(hdl_loop_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_fb, 1);\n\tv4l2_ctrl_new_custom(hdl_fb, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_vid_cap, 55);\n\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_vid_out, 26);\n\tif (!no_error_inj || dev->has_fb || dev->num_hdmi_outputs)\n\t\tv4l2_ctrl_new_custom(hdl_vid_out, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_vbi_cap, 21);\n\tv4l2_ctrl_new_custom(hdl_vbi_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_vbi_out, 19);\n\tif (!no_error_inj)\n\t\tv4l2_ctrl_new_custom(hdl_vbi_out, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_radio_rx, 17);\n\tv4l2_ctrl_new_custom(hdl_radio_rx, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_radio_tx, 17);\n\tv4l2_ctrl_new_custom(hdl_radio_tx, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_sdr_cap, 19);\n\tv4l2_ctrl_new_custom(hdl_sdr_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_meta_cap, 2);\n\tv4l2_ctrl_new_custom(hdl_meta_cap, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_meta_out, 2);\n\tv4l2_ctrl_new_custom(hdl_meta_out, &vivid_ctrl_class, NULL);\n\tv4l2_ctrl_handler_init(hdl_tch_cap, 2);\n\tv4l2_ctrl_new_custom(hdl_tch_cap, &vivid_ctrl_class, NULL);\n\n\t \n\tdev->volume = v4l2_ctrl_new_std(hdl_user_aud, NULL,\n\t\tV4L2_CID_AUDIO_VOLUME, 0, 255, 1, 200);\n\tdev->mute = v4l2_ctrl_new_std(hdl_user_aud, NULL,\n\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tif (dev->has_vid_cap) {\n\t\tdev->brightness = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\t\tfor (i = 0; i < MAX_INPUTS; i++)\n\t\t\tdev->input_brightness[i] = 128;\n\t\tdev->contrast = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 128);\n\t\tdev->saturation = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\t\tdev->hue = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 128, 1, 0);\n\t\tv4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tv4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\t\tdev->autogain = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\t\tdev->gain = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 100);\n\t\tdev->alpha = v4l2_ctrl_new_std(hdl_user_vid, &vivid_user_vid_ctrl_ops,\n\t\t\tV4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\n\t}\n\tdev->button = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_button, NULL);\n\tdev->int32 = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_int32, NULL);\n\tdev->int64 = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_int64, NULL);\n\tdev->boolean = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_boolean, NULL);\n\tdev->menu = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_menu, NULL);\n\tdev->string = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_string, NULL);\n\tdev->bitmask = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_bitmask, NULL);\n\tdev->int_menu = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_int_menu, NULL);\n\tdev->ro_int32 = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_ro_int32, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_area, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_u32_array, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_u32_dyn_array, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_u16_matrix, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_u8_4d_array, NULL);\n\tdev->pixel_array = v4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_u8_pixel_array, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_s32_array, NULL);\n\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_s64_array, NULL);\n\n\tif (dev->has_vid_cap) {\n\t\t \n\t\tstruct v4l2_ctrl_config vivid_ctrl_test_pattern = {\n\t\t\t.ops = &vivid_vid_cap_ctrl_ops,\n\t\t\t.id = VIVID_CID_TEST_PATTERN,\n\t\t\t.name = \"Test Pattern\",\n\t\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t\t.max = TPG_PAT_NOISE,\n\t\t\t.qmenu = tpg_pattern_strings,\n\t\t};\n\n\t\tdev->test_pattern = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t\t&vivid_ctrl_test_pattern, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_perc_fill, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_hor_movement, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_vert_movement, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_osd_mode, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_show_border, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_show_square, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_hflip, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_vflip, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_insert_sav, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_insert_eav, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_insert_hdmi_video_guard_band, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_reduced_fps, NULL);\n\t\tif (show_ccs_cap) {\n\t\t\tdev->ctrl_has_crop_cap = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t\t&vivid_ctrl_has_crop_cap, NULL);\n\t\t\tdev->ctrl_has_compose_cap = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t\t&vivid_ctrl_has_compose_cap, NULL);\n\t\t\tdev->ctrl_has_scaler_cap = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t\t&vivid_ctrl_has_scaler_cap, NULL);\n\t\t}\n\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_tstamp_src, NULL);\n\t\tdev->colorspace = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t&vivid_ctrl_colorspace, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_xfer_func, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_ycbcr_enc, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_hsv_enc, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_quantization, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_alpha_mode, NULL);\n\t}\n\n\tif (dev->has_vid_out && show_ccs_out) {\n\t\tdev->ctrl_has_crop_out = v4l2_ctrl_new_custom(hdl_vid_out,\n\t\t\t&vivid_ctrl_has_crop_out, NULL);\n\t\tdev->ctrl_has_compose_out = v4l2_ctrl_new_custom(hdl_vid_out,\n\t\t\t&vivid_ctrl_has_compose_out, NULL);\n\t\tdev->ctrl_has_scaler_out = v4l2_ctrl_new_custom(hdl_vid_out,\n\t\t\t&vivid_ctrl_has_scaler_out, NULL);\n\t}\n\n\t \n\tif (!no_error_inj) {\n\t\tv4l2_ctrl_new_custom(hdl_user_gen, &vivid_ctrl_disconnect, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_dqbuf_error, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_perc_dropped, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_queue_setup_error, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_buf_prepare_error, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_start_streaming_error, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_queue_error, NULL);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_req_validate_error, NULL);\n#endif\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_seq_wrap, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_streaming, &vivid_ctrl_time_wrap, NULL);\n\t}\n\n\tif (has_sdtv && (dev->has_vid_cap || dev->has_vbi_cap)) {\n\t\tif (dev->has_vid_cap)\n\t\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_std_aspect_ratio, NULL);\n\t\tdev->ctrl_std_signal_mode = v4l2_ctrl_new_custom(hdl_sdtv_cap,\n\t\t\t&vivid_ctrl_std_signal_mode, NULL);\n\t\tdev->ctrl_standard = v4l2_ctrl_new_custom(hdl_sdtv_cap,\n\t\t\t&vivid_ctrl_standard, NULL);\n\t\tif (dev->ctrl_std_signal_mode)\n\t\t\tv4l2_ctrl_cluster(2, &dev->ctrl_std_signal_mode);\n\t\tif (dev->has_raw_vbi_cap)\n\t\t\tv4l2_ctrl_new_custom(hdl_vbi_cap, &vivid_ctrl_vbi_cap_interlaced, NULL);\n\t}\n\n\tif (dev->num_hdmi_inputs) {\n\t\ts64 hdmi_input_mask = GENMASK(dev->num_hdmi_inputs - 1, 0);\n\n\t\tdev->ctrl_dv_timings_signal_mode = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t\t\t&vivid_ctrl_dv_timings_signal_mode, NULL);\n\n\t\tvivid_ctrl_dv_timings.max = dev->query_dv_timings_size - 1;\n\t\tvivid_ctrl_dv_timings.qmenu =\n\t\t\t(const char * const *)dev->query_dv_timings_qmenu;\n\t\tdev->ctrl_dv_timings = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t&vivid_ctrl_dv_timings, NULL);\n\t\tif (dev->ctrl_dv_timings_signal_mode)\n\t\t\tv4l2_ctrl_cluster(2, &dev->ctrl_dv_timings_signal_mode);\n\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_dv_timings_aspect_ratio, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_vid_cap, &vivid_ctrl_max_edid_blocks, NULL);\n\t\tdev->real_rgb_range_cap = v4l2_ctrl_new_custom(hdl_vid_cap,\n\t\t\t&vivid_ctrl_limited_rgb_range, NULL);\n\t\tdev->rgb_range_cap = v4l2_ctrl_new_std_menu(hdl_vid_cap,\n\t\t\t&vivid_vid_cap_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\n\t\t\t0, V4L2_DV_RGB_RANGE_AUTO);\n\t\tdev->ctrl_rx_power_present = v4l2_ctrl_new_std(hdl_vid_cap,\n\t\t\tNULL, V4L2_CID_DV_RX_POWER_PRESENT, 0, hdmi_input_mask,\n\t\t\t0, hdmi_input_mask);\n\n\t}\n\tif (dev->num_hdmi_outputs) {\n\t\ts64 hdmi_output_mask = GENMASK(dev->num_hdmi_outputs - 1, 0);\n\n\t\t \n\t\tdev->ctrl_tx_rgb_range = v4l2_ctrl_new_std_menu(hdl_vid_out, NULL,\n\t\t\tV4L2_CID_DV_TX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\n\t\t\t0, V4L2_DV_RGB_RANGE_AUTO);\n\t\tdev->ctrl_tx_mode = v4l2_ctrl_new_std_menu(hdl_vid_out, NULL,\n\t\t\tV4L2_CID_DV_TX_MODE, V4L2_DV_TX_MODE_HDMI,\n\t\t\t0, V4L2_DV_TX_MODE_HDMI);\n\t\tdev->ctrl_display_present = v4l2_ctrl_new_custom(hdl_vid_out,\n\t\t\t&vivid_ctrl_display_present, NULL);\n\t\tdev->ctrl_tx_hotplug = v4l2_ctrl_new_std(hdl_vid_out,\n\t\t\tNULL, V4L2_CID_DV_TX_HOTPLUG, 0, hdmi_output_mask,\n\t\t\t0, hdmi_output_mask);\n\t\tdev->ctrl_tx_rxsense = v4l2_ctrl_new_std(hdl_vid_out,\n\t\t\tNULL, V4L2_CID_DV_TX_RXSENSE, 0, hdmi_output_mask,\n\t\t\t0, hdmi_output_mask);\n\t\tdev->ctrl_tx_edid_present = v4l2_ctrl_new_std(hdl_vid_out,\n\t\t\tNULL, V4L2_CID_DV_TX_EDID_PRESENT, 0, hdmi_output_mask,\n\t\t\t0, hdmi_output_mask);\n\t}\n\tif ((dev->has_vid_cap && dev->has_vid_out) ||\n\t    (dev->has_vbi_cap && dev->has_vbi_out))\n\t\tv4l2_ctrl_new_custom(hdl_loop_cap, &vivid_ctrl_loop_video, NULL);\n\n\tif (dev->has_fb)\n\t\tv4l2_ctrl_new_custom(hdl_fb, &vivid_ctrl_clear_fb, NULL);\n\n\tif (dev->has_radio_rx) {\n\t\tv4l2_ctrl_new_custom(hdl_radio_rx, &vivid_ctrl_radio_hw_seek_mode, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_radio_rx, &vivid_ctrl_radio_hw_seek_prog_lim, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_radio_rx, &vivid_ctrl_radio_rx_rds_blockio, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_radio_rx, &vivid_ctrl_radio_rx_rds_rbds, NULL);\n\t\tv4l2_ctrl_new_std(hdl_radio_rx, &vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RECEPTION, 0, 1, 1, 1);\n\t\tdev->radio_rx_rds_pty = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_PTY, 0, 31, 1, 0);\n\t\tdev->radio_rx_rds_psname = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_PS_NAME, 0, 8, 8, 0);\n\t\tdev->radio_rx_rds_radiotext = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_RADIO_TEXT, 0, 64, 64, 0);\n\t\tdev->radio_rx_rds_ta = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT, 0, 1, 1, 0);\n\t\tdev->radio_rx_rds_tp = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_TRAFFIC_PROGRAM, 0, 1, 1, 0);\n\t\tdev->radio_rx_rds_ms = v4l2_ctrl_new_std(hdl_radio_rx,\n\t\t\t&vivid_radio_rx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_RX_MUSIC_SPEECH, 0, 1, 1, 1);\n\t}\n\tif (dev->has_radio_tx) {\n\t\tv4l2_ctrl_new_custom(hdl_radio_tx,\n\t\t\t&vivid_ctrl_radio_tx_rds_blockio, NULL);\n\t\tdev->radio_tx_rds_pi = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PI, 0, 0xffff, 1, 0x8088);\n\t\tdev->radio_tx_rds_pty = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PTY, 0, 31, 1, 3);\n\t\tdev->radio_tx_rds_psname = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PS_NAME, 0, 8, 8, 0);\n\t\tif (dev->radio_tx_rds_psname)\n\t\t\tv4l2_ctrl_s_ctrl_string(dev->radio_tx_rds_psname, \"VIVID-TX\");\n\t\tdev->radio_tx_rds_radiotext = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_RADIO_TEXT, 0, 64 * 2, 64, 0);\n\t\tif (dev->radio_tx_rds_radiotext)\n\t\t\tv4l2_ctrl_s_ctrl_string(dev->radio_tx_rds_radiotext,\n\t\t\t       \"This is a VIVID default Radio Text template text, change at will\");\n\t\tdev->radio_tx_rds_mono_stereo = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_MONO_STEREO, 0, 1, 1, 1);\n\t\tdev->radio_tx_rds_art_head = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_ARTIFICIAL_HEAD, 0, 1, 1, 0);\n\t\tdev->radio_tx_rds_compressed = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_COMPRESSED, 0, 1, 1, 0);\n\t\tdev->radio_tx_rds_dyn_pty = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_DYNAMIC_PTY, 0, 1, 1, 0);\n\t\tdev->radio_tx_rds_ta = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT, 0, 1, 1, 0);\n\t\tdev->radio_tx_rds_tp = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_TRAFFIC_PROGRAM, 0, 1, 1, 1);\n\t\tdev->radio_tx_rds_ms = v4l2_ctrl_new_std(hdl_radio_tx,\n\t\t\t&vivid_radio_tx_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_MUSIC_SPEECH, 0, 1, 1, 1);\n\t}\n\tif (dev->has_sdr_cap) {\n\t\tv4l2_ctrl_new_custom(hdl_sdr_cap,\n\t\t\t&vivid_ctrl_sdr_cap_fm_deviation, NULL);\n\t}\n\tif (dev->has_meta_cap) {\n\t\tv4l2_ctrl_new_custom(hdl_meta_cap,\n\t\t\t\t     &vivid_ctrl_meta_has_pts, NULL);\n\t\tv4l2_ctrl_new_custom(hdl_meta_cap,\n\t\t\t\t     &vivid_ctrl_meta_has_src_clk, NULL);\n\t}\n\n\tif (hdl_user_gen->error)\n\t\treturn hdl_user_gen->error;\n\tif (hdl_user_vid->error)\n\t\treturn hdl_user_vid->error;\n\tif (hdl_user_aud->error)\n\t\treturn hdl_user_aud->error;\n\tif (hdl_streaming->error)\n\t\treturn hdl_streaming->error;\n\tif (hdl_sdr_cap->error)\n\t\treturn hdl_sdr_cap->error;\n\tif (hdl_loop_cap->error)\n\t\treturn hdl_loop_cap->error;\n\n\tif (dev->autogain)\n\t\tv4l2_ctrl_auto_cluster(2, &dev->autogain, 0, true);\n\n\tif (dev->has_vid_cap) {\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_user_vid, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_user_aud, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_streaming, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_sdtv_cap, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_loop_cap, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_cap, hdl_fb, NULL, false);\n\t\tif (hdl_vid_cap->error)\n\t\t\treturn hdl_vid_cap->error;\n\t\tdev->vid_cap_dev.ctrl_handler = hdl_vid_cap;\n\t}\n\tif (dev->has_vid_out) {\n\t\tv4l2_ctrl_add_handler(hdl_vid_out, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_out, hdl_user_aud, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_out, hdl_streaming, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vid_out, hdl_fb, NULL, false);\n\t\tif (hdl_vid_out->error)\n\t\t\treturn hdl_vid_out->error;\n\t\tdev->vid_out_dev.ctrl_handler = hdl_vid_out;\n\t}\n\tif (dev->has_vbi_cap) {\n\t\tv4l2_ctrl_add_handler(hdl_vbi_cap, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vbi_cap, hdl_streaming, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vbi_cap, hdl_sdtv_cap, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vbi_cap, hdl_loop_cap, NULL, false);\n\t\tif (hdl_vbi_cap->error)\n\t\t\treturn hdl_vbi_cap->error;\n\t\tdev->vbi_cap_dev.ctrl_handler = hdl_vbi_cap;\n\t}\n\tif (dev->has_vbi_out) {\n\t\tv4l2_ctrl_add_handler(hdl_vbi_out, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_vbi_out, hdl_streaming, NULL, false);\n\t\tif (hdl_vbi_out->error)\n\t\t\treturn hdl_vbi_out->error;\n\t\tdev->vbi_out_dev.ctrl_handler = hdl_vbi_out;\n\t}\n\tif (dev->has_radio_rx) {\n\t\tv4l2_ctrl_add_handler(hdl_radio_rx, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_radio_rx, hdl_user_aud, NULL, false);\n\t\tif (hdl_radio_rx->error)\n\t\t\treturn hdl_radio_rx->error;\n\t\tdev->radio_rx_dev.ctrl_handler = hdl_radio_rx;\n\t}\n\tif (dev->has_radio_tx) {\n\t\tv4l2_ctrl_add_handler(hdl_radio_tx, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_radio_tx, hdl_user_aud, NULL, false);\n\t\tif (hdl_radio_tx->error)\n\t\t\treturn hdl_radio_tx->error;\n\t\tdev->radio_tx_dev.ctrl_handler = hdl_radio_tx;\n\t}\n\tif (dev->has_sdr_cap) {\n\t\tv4l2_ctrl_add_handler(hdl_sdr_cap, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_sdr_cap, hdl_streaming, NULL, false);\n\t\tif (hdl_sdr_cap->error)\n\t\t\treturn hdl_sdr_cap->error;\n\t\tdev->sdr_cap_dev.ctrl_handler = hdl_sdr_cap;\n\t}\n\tif (dev->has_meta_cap) {\n\t\tv4l2_ctrl_add_handler(hdl_meta_cap, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_meta_cap, hdl_streaming, NULL, false);\n\t\tif (hdl_meta_cap->error)\n\t\t\treturn hdl_meta_cap->error;\n\t\tdev->meta_cap_dev.ctrl_handler = hdl_meta_cap;\n\t}\n\tif (dev->has_meta_out) {\n\t\tv4l2_ctrl_add_handler(hdl_meta_out, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_meta_out, hdl_streaming, NULL, false);\n\t\tif (hdl_meta_out->error)\n\t\t\treturn hdl_meta_out->error;\n\t\tdev->meta_out_dev.ctrl_handler = hdl_meta_out;\n\t}\n\tif (dev->has_touch_cap) {\n\t\tv4l2_ctrl_add_handler(hdl_tch_cap, hdl_user_gen, NULL, false);\n\t\tv4l2_ctrl_add_handler(hdl_tch_cap, hdl_streaming, NULL, false);\n\t\tif (hdl_tch_cap->error)\n\t\t\treturn hdl_tch_cap->error;\n\t\tdev->touch_cap_dev.ctrl_handler = hdl_tch_cap;\n\t}\n\treturn 0;\n}\n\nvoid vivid_free_controls(struct vivid_dev *dev)\n{\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_vid_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_vid_out);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_vbi_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_vbi_out);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_radio_rx);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_radio_tx);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_sdr_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_user_gen);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_user_vid);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_user_aud);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_streaming);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_sdtv_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_loop_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_fb);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_meta_cap);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_meta_out);\n\tv4l2_ctrl_handler_free(&dev->ctrl_hdl_touch_cap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}