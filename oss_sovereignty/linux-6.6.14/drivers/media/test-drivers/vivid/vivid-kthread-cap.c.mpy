{
  "module_name": "vivid-kthread-cap.c",
  "hash_id": "a2361b5db624a85f8d77a7e2e72cdbc76165a7813fe682c6b270cd4969d09439",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-kthread-cap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/font.h>\n#include <linux/mutex.h>\n#include <linux/videodev2.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/random.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/jiffies.h>\n#include <asm/div64.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-rect.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-vid-common.h\"\n#include \"vivid-vid-cap.h\"\n#include \"vivid-vid-out.h\"\n#include \"vivid-radio-common.h\"\n#include \"vivid-radio-rx.h\"\n#include \"vivid-radio-tx.h\"\n#include \"vivid-sdr-cap.h\"\n#include \"vivid-vbi-cap.h\"\n#include \"vivid-vbi-out.h\"\n#include \"vivid-osd.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-kthread-cap.h\"\n#include \"vivid-meta-cap.h\"\n\nstatic inline v4l2_std_id vivid_get_std_cap(const struct vivid_dev *dev)\n{\n\tif (vivid_is_sdtv_cap(dev))\n\t\treturn dev->std_cap[dev->input];\n\treturn 0;\n}\n\nstatic void copy_pix(struct vivid_dev *dev, int win_y, int win_x,\n\t\t\tu16 *cap, const u16 *osd)\n{\n\tu16 out;\n\n\tout = *cap;\n\t*cap = *osd;\n\n\tif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_CHROMAKEY) &&\n\t    *osd != dev->chromakey_out)\n\t\treturn;\n\tif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY) &&\n\t    out == dev->chromakey_out)\n\t\treturn;\n\tif (dev->fmt_cap->alpha_mask) {\n\t\tif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) &&\n\t\t    dev->global_alpha_out)\n\t\t\treturn;\n\t\tif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_LOCAL_ALPHA) &&\n\t\t    *cap & dev->fmt_cap->alpha_mask)\n\t\t\treturn;\n\t\tif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_LOCAL_INV_ALPHA) &&\n\t\t    !(*cap & dev->fmt_cap->alpha_mask))\n\t\t\treturn;\n\t}\n\t*cap = out;\n}\n\nstatic void blend_line(struct vivid_dev *dev, unsigned y_offset, unsigned x_offset,\n\t\tu8 *vcapbuf, const u8 *vosdbuf,\n\t\tunsigned width, unsigned pixsize)\n{\n\tunsigned x;\n\n\tfor (x = 0; x < width; x++, vcapbuf += pixsize, vosdbuf += pixsize) {\n\t\tcopy_pix(dev, y_offset, x_offset + x,\n\t\t\t (u16 *)vcapbuf, (const u16 *)vosdbuf);\n\t}\n}\n\nstatic void scale_line(const u8 *src, u8 *dst, unsigned srcw, unsigned dstw, unsigned twopixsize)\n{\n\t \n\tunsigned int_part;\n\tunsigned fract_part;\n\tunsigned src_x = 0;\n\tunsigned error = 0;\n\tunsigned x;\n\n\t \n\tsrcw /= 2;\n\tdstw /= 2;\n\tint_part = srcw / dstw;\n\tfract_part = srcw % dstw;\n\tfor (x = 0; x < dstw; x++, dst += twopixsize) {\n\t\tmemcpy(dst, src + src_x * twopixsize, twopixsize);\n\t\tsrc_x += int_part;\n\t\terror += fract_part;\n\t\tif (error >= dstw) {\n\t\t\terror -= dstw;\n\t\t\tsrc_x++;\n\t\t}\n\t}\n}\n\n \nstatic void vivid_precalc_copy_rects(struct vivid_dev *dev)\n{\n\t \n\tstruct v4l2_rect r_fb = {\n\t\t0, 0, dev->display_width, dev->display_height\n\t};\n\t \n\tstruct v4l2_rect r_overlay = {\n\t\tdev->overlay_out_left, dev->overlay_out_top,\n\t\tdev->compose_out.width, dev->compose_out.height\n\t};\n\n\tv4l2_rect_intersect(&dev->loop_vid_copy, &dev->crop_cap, &dev->compose_out);\n\n\tdev->loop_vid_out = dev->loop_vid_copy;\n\tv4l2_rect_scale(&dev->loop_vid_out, &dev->compose_out, &dev->crop_out);\n\tdev->loop_vid_out.left += dev->crop_out.left;\n\tdev->loop_vid_out.top += dev->crop_out.top;\n\n\tdev->loop_vid_cap = dev->loop_vid_copy;\n\tv4l2_rect_scale(&dev->loop_vid_cap, &dev->crop_cap, &dev->compose_cap);\n\n\tdprintk(dev, 1,\n\t\t\"loop_vid_copy: %dx%d@%dx%d loop_vid_out: %dx%d@%dx%d loop_vid_cap: %dx%d@%dx%d\\n\",\n\t\tdev->loop_vid_copy.width, dev->loop_vid_copy.height,\n\t\tdev->loop_vid_copy.left, dev->loop_vid_copy.top,\n\t\tdev->loop_vid_out.width, dev->loop_vid_out.height,\n\t\tdev->loop_vid_out.left, dev->loop_vid_out.top,\n\t\tdev->loop_vid_cap.width, dev->loop_vid_cap.height,\n\t\tdev->loop_vid_cap.left, dev->loop_vid_cap.top);\n\n\tv4l2_rect_intersect(&r_overlay, &r_fb, &r_overlay);\n\n\t \n\tr_overlay.left += dev->compose_out.left - dev->overlay_out_left;\n\tr_overlay.top += dev->compose_out.top - dev->overlay_out_top;\n\n\tv4l2_rect_intersect(&dev->loop_vid_overlay, &r_overlay, &dev->loop_vid_copy);\n\tdev->loop_fb_copy = dev->loop_vid_overlay;\n\n\t \n\tdev->loop_fb_copy.left -= dev->compose_out.left - dev->overlay_out_left;\n\tdev->loop_fb_copy.top -= dev->compose_out.top - dev->overlay_out_top;\n\n\tdev->loop_vid_overlay_cap = dev->loop_vid_overlay;\n\tv4l2_rect_scale(&dev->loop_vid_overlay_cap, &dev->crop_cap, &dev->compose_cap);\n\n\tdprintk(dev, 1,\n\t\t\"loop_fb_copy: %dx%d@%dx%d loop_vid_overlay: %dx%d@%dx%d loop_vid_overlay_cap: %dx%d@%dx%d\\n\",\n\t\tdev->loop_fb_copy.width, dev->loop_fb_copy.height,\n\t\tdev->loop_fb_copy.left, dev->loop_fb_copy.top,\n\t\tdev->loop_vid_overlay.width, dev->loop_vid_overlay.height,\n\t\tdev->loop_vid_overlay.left, dev->loop_vid_overlay.top,\n\t\tdev->loop_vid_overlay_cap.width, dev->loop_vid_overlay_cap.height,\n\t\tdev->loop_vid_overlay_cap.left, dev->loop_vid_overlay_cap.top);\n}\n\nstatic void *plane_vaddr(struct tpg_data *tpg, struct vivid_buffer *buf,\n\t\t\t unsigned p, unsigned bpl[TPG_MAX_PLANES], unsigned h)\n{\n\tunsigned i;\n\tvoid *vbuf;\n\n\tif (p == 0 || tpg_g_buffers(tpg) > 1)\n\t\treturn vb2_plane_vaddr(&buf->vb.vb2_buf, p);\n\tvbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tfor (i = 0; i < p; i++)\n\t\tvbuf += bpl[i] * h / tpg->vdownsampling[i];\n\treturn vbuf;\n}\n\nstatic noinline_for_stack int vivid_copy_buffer(struct vivid_dev *dev, unsigned p,\n\t\tu8 *vcapbuf, struct vivid_buffer *vid_cap_buf)\n{\n\tbool blank = dev->must_blank[vid_cap_buf->vb.vb2_buf.index];\n\tstruct tpg_data *tpg = &dev->tpg;\n\tstruct vivid_buffer *vid_out_buf = NULL;\n\tunsigned vdiv = dev->fmt_out->vdownsampling[p];\n\tunsigned twopixsize = tpg_g_twopixelsize(tpg, p);\n\tunsigned img_width = tpg_hdiv(tpg, p, dev->compose_cap.width);\n\tunsigned img_height = dev->compose_cap.height;\n\tunsigned stride_cap = tpg->bytesperline[p];\n\tunsigned stride_out = dev->bytesperline_out[p];\n\tunsigned stride_osd = dev->display_byte_stride;\n\tunsigned hmax = (img_height * tpg->perc_fill) / 100;\n\tu8 *voutbuf;\n\tu8 *vosdbuf = NULL;\n\tunsigned y;\n\tbool blend = dev->fbuf_out_flags;\n\t \n\tunsigned vid_out_int_part;\n\tunsigned vid_out_fract_part;\n\tunsigned vid_out_y = 0;\n\tunsigned vid_out_error = 0;\n\tunsigned vid_overlay_int_part = 0;\n\tunsigned vid_overlay_fract_part = 0;\n\tunsigned vid_overlay_y = 0;\n\tunsigned vid_overlay_error = 0;\n\tunsigned vid_cap_left = tpg_hdiv(tpg, p, dev->loop_vid_cap.left);\n\tunsigned vid_cap_right;\n\tbool quick;\n\n\tvid_out_int_part = dev->loop_vid_out.height / dev->loop_vid_cap.height;\n\tvid_out_fract_part = dev->loop_vid_out.height % dev->loop_vid_cap.height;\n\n\tif (!list_empty(&dev->vid_out_active))\n\t\tvid_out_buf = list_entry(dev->vid_out_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\tif (vid_out_buf == NULL)\n\t\treturn -ENODATA;\n\n\tvid_cap_buf->vb.field = vid_out_buf->vb.field;\n\n\tvoutbuf = plane_vaddr(tpg, vid_out_buf, p,\n\t\t\t      dev->bytesperline_out, dev->fmt_out_rect.height);\n\tif (p < dev->fmt_out->buffers)\n\t\tvoutbuf += vid_out_buf->vb.vb2_buf.planes[p].data_offset;\n\tvoutbuf += tpg_hdiv(tpg, p, dev->loop_vid_out.left) +\n\t\t(dev->loop_vid_out.top / vdiv) * stride_out;\n\tvcapbuf += tpg_hdiv(tpg, p, dev->compose_cap.left) +\n\t\t(dev->compose_cap.top / vdiv) * stride_cap;\n\n\tif (dev->loop_vid_copy.width == 0 || dev->loop_vid_copy.height == 0) {\n\t\t \n\t\tfor (y = 0; y < hmax / vdiv; y++, vcapbuf += stride_cap)\n\t\t\tmemcpy(vcapbuf, tpg->black_line[p], img_width);\n\t\treturn 0;\n\t}\n\n\tif (dev->overlay_out_enabled &&\n\t    dev->loop_vid_overlay.width && dev->loop_vid_overlay.height) {\n\t\tvosdbuf = dev->video_vbase;\n\t\tvosdbuf += (dev->loop_fb_copy.left * twopixsize) / 2 +\n\t\t\t   dev->loop_fb_copy.top * stride_osd;\n\t\tvid_overlay_int_part = dev->loop_vid_overlay.height /\n\t\t\t\t       dev->loop_vid_overlay_cap.height;\n\t\tvid_overlay_fract_part = dev->loop_vid_overlay.height %\n\t\t\t\t\t dev->loop_vid_overlay_cap.height;\n\t}\n\n\tvid_cap_right = tpg_hdiv(tpg, p, dev->loop_vid_cap.left + dev->loop_vid_cap.width);\n\t \n\tquick = dev->loop_vid_out.width == dev->loop_vid_cap.width;\n\n\tdev->cur_scaled_line = dev->loop_vid_out.height;\n\tfor (y = 0; y < hmax; y += vdiv, vcapbuf += stride_cap) {\n\t\t \n\t\tbool osdline = vosdbuf && y >= dev->loop_vid_overlay_cap.top &&\n\t\t\t  y < dev->loop_vid_overlay_cap.top + dev->loop_vid_overlay_cap.height;\n\n\t\t \n\t\tif (y < dev->loop_vid_cap.top ||\n\t\t    y >= dev->loop_vid_cap.top + dev->loop_vid_cap.height) {\n\t\t\tmemcpy(vcapbuf, tpg->black_line[p], img_width);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dev->loop_vid_cap.left)\n\t\t\tmemcpy(vcapbuf, tpg->black_line[p], vid_cap_left);\n\n\t\t \n\t\tif (vid_cap_right < img_width)\n\t\t\tmemcpy(vcapbuf + vid_cap_right, tpg->black_line[p],\n\t\t\t\timg_width - vid_cap_right);\n\n\t\tif (quick && !osdline) {\n\t\t\tmemcpy(vcapbuf + vid_cap_left,\n\t\t\t       voutbuf + vid_out_y * stride_out,\n\t\t\t       tpg_hdiv(tpg, p, dev->loop_vid_cap.width));\n\t\t\tgoto update_vid_out_y;\n\t\t}\n\t\tif (dev->cur_scaled_line == vid_out_y) {\n\t\t\tmemcpy(vcapbuf + vid_cap_left, dev->scaled_line,\n\t\t\t       tpg_hdiv(tpg, p, dev->loop_vid_cap.width));\n\t\t\tgoto update_vid_out_y;\n\t\t}\n\t\tif (!osdline) {\n\t\t\tscale_line(voutbuf + vid_out_y * stride_out, dev->scaled_line,\n\t\t\t\ttpg_hdiv(tpg, p, dev->loop_vid_out.width),\n\t\t\t\ttpg_hdiv(tpg, p, dev->loop_vid_cap.width),\n\t\t\t\ttpg_g_twopixelsize(tpg, p));\n\t\t} else {\n\t\t\t \n\t\t\tunsigned offset =\n\t\t\t\t((dev->loop_vid_overlay.left - dev->loop_vid_copy.left) *\n\t\t\t\t twopixsize) / 2;\n\t\t\tu8 *osd = vosdbuf + vid_overlay_y * stride_osd;\n\n\t\t\tscale_line(voutbuf + vid_out_y * stride_out, dev->blended_line,\n\t\t\t\tdev->loop_vid_out.width, dev->loop_vid_copy.width,\n\t\t\t\ttpg_g_twopixelsize(tpg, p));\n\t\t\tif (blend)\n\t\t\t\tblend_line(dev, vid_overlay_y + dev->loop_vid_overlay.top,\n\t\t\t\t\t   dev->loop_vid_overlay.left,\n\t\t\t\t\t   dev->blended_line + offset, osd,\n\t\t\t\t\t   dev->loop_vid_overlay.width, twopixsize / 2);\n\t\t\telse\n\t\t\t\tmemcpy(dev->blended_line + offset,\n\t\t\t\t       osd, (dev->loop_vid_overlay.width * twopixsize) / 2);\n\t\t\tscale_line(dev->blended_line, dev->scaled_line,\n\t\t\t\t\tdev->loop_vid_copy.width, dev->loop_vid_cap.width,\n\t\t\t\t\ttpg_g_twopixelsize(tpg, p));\n\t\t}\n\t\tdev->cur_scaled_line = vid_out_y;\n\t\tmemcpy(vcapbuf + vid_cap_left, dev->scaled_line,\n\t\t       tpg_hdiv(tpg, p, dev->loop_vid_cap.width));\n\nupdate_vid_out_y:\n\t\tif (osdline) {\n\t\t\tvid_overlay_y += vid_overlay_int_part;\n\t\t\tvid_overlay_error += vid_overlay_fract_part;\n\t\t\tif (vid_overlay_error >= dev->loop_vid_overlay_cap.height) {\n\t\t\t\tvid_overlay_error -= dev->loop_vid_overlay_cap.height;\n\t\t\t\tvid_overlay_y++;\n\t\t\t}\n\t\t}\n\t\tvid_out_y += vid_out_int_part;\n\t\tvid_out_error += vid_out_fract_part;\n\t\tif (vid_out_error >= dev->loop_vid_cap.height / vdiv) {\n\t\t\tvid_out_error -= dev->loop_vid_cap.height / vdiv;\n\t\t\tvid_out_y++;\n\t\t}\n\t}\n\n\tif (!blank)\n\t\treturn 0;\n\tfor (; y < img_height; y += vdiv, vcapbuf += stride_cap)\n\t\tmemcpy(vcapbuf, tpg->contrast_line[p], img_width);\n\treturn 0;\n}\n\nstatic void vivid_fillbuff(struct vivid_dev *dev, struct vivid_buffer *buf)\n{\n\tstruct tpg_data *tpg = &dev->tpg;\n\tunsigned factor = V4L2_FIELD_HAS_T_OR_B(dev->field_cap) ? 2 : 1;\n\tunsigned line_height = 16 / factor;\n\tbool is_tv = vivid_is_sdtv_cap(dev);\n\tbool is_60hz = is_tv && (dev->std_cap[dev->input] & V4L2_STD_525_60);\n\tunsigned p;\n\tint line = 1;\n\tu8 *basep[TPG_MAX_PLANES][2];\n\tunsigned ms;\n\tchar str[100];\n\ts32 gain;\n\tbool is_loop = false;\n\n\tif (dev->loop_video && dev->can_loop_video &&\n\t\t((vivid_is_svid_cap(dev) &&\n\t\t!VIVID_INVALID_SIGNAL(dev->std_signal_mode[dev->input])) ||\n\t\t(vivid_is_hdmi_cap(dev) &&\n\t\t!VIVID_INVALID_SIGNAL(dev->dv_timings_signal_mode[dev->input]))))\n\t\tis_loop = true;\n\n\tbuf->vb.sequence = dev->vid_cap_seq_count;\n\tv4l2_ctrl_s_ctrl(dev->ro_int32, buf->vb.sequence & 0xff);\n\tif (dev->field_cap == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tbuf->vb.field = ((dev->vid_cap_seq_count & 1) ^ is_60hz) ?\n\t\t\tV4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\n\t\t \n\t\tbuf->vb.sequence /= 2;\n\t} else {\n\t\tbuf->vb.field = dev->field_cap;\n\t}\n\ttpg_s_field(tpg, buf->vb.field,\n\t\t    dev->field_cap == V4L2_FIELD_ALTERNATE);\n\ttpg_s_perc_fill_blank(tpg, dev->must_blank[buf->vb.vb2_buf.index]);\n\n\tvivid_precalc_copy_rects(dev);\n\n\tfor (p = 0; p < tpg_g_planes(tpg); p++) {\n\t\tvoid *vbuf = plane_vaddr(tpg, buf, p,\n\t\t\t\t\t tpg->bytesperline, tpg->buf_height);\n\n\t\t \n\t\tif (p < tpg_g_buffers(tpg) && dev->fmt_cap->data_offset[p]) {\n\t\t\tmemset(vbuf, dev->fmt_cap->data_offset[p] & 0xff,\n\t\t\t       dev->fmt_cap->data_offset[p]);\n\t\t\tvbuf += dev->fmt_cap->data_offset[p];\n\t\t}\n\t\ttpg_calc_text_basep(tpg, basep, p, vbuf);\n\t\tif (!is_loop || vivid_copy_buffer(dev, p, vbuf, buf))\n\t\t\ttpg_fill_plane_buffer(tpg, vivid_get_std_cap(dev),\n\t\t\t\t\tp, vbuf);\n\t}\n\tdev->must_blank[buf->vb.vb2_buf.index] = false;\n\n\t \n\tif (dev->field_cap != V4L2_FIELD_ALTERNATE ||\n\t\t\t(dev->vid_cap_seq_count & 1) == 0)\n\t\tdev->ms_vid_cap =\n\t\t\tjiffies_to_msecs(jiffies - dev->jiffies_vid_cap);\n\n\tms = dev->ms_vid_cap;\n\tif (dev->osd_mode <= 1) {\n\t\tsnprintf(str, sizeof(str), \" %02d:%02d:%02d:%03d %u%s\",\n\t\t\t\t(ms / (60 * 60 * 1000)) % 24,\n\t\t\t\t(ms / (60 * 1000)) % 60,\n\t\t\t\t(ms / 1000) % 60,\n\t\t\t\tms % 1000,\n\t\t\t\tbuf->vb.sequence,\n\t\t\t\t(dev->field_cap == V4L2_FIELD_ALTERNATE) ?\n\t\t\t\t\t(buf->vb.field == V4L2_FIELD_TOP ?\n\t\t\t\t\t \" top\" : \" bottom\") : \"\");\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t}\n\tif (dev->osd_mode == 0) {\n\t\tsnprintf(str, sizeof(str), \" %dx%d, input %d \",\n\t\t\t\tdev->src_rect.width, dev->src_rect.height, dev->input);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\n\t\tgain = v4l2_ctrl_g_ctrl(dev->gain);\n\t\tmutex_lock(dev->ctrl_hdl_user_vid.lock);\n\t\tsnprintf(str, sizeof(str),\n\t\t\t\" brightness %3d, contrast %3d, saturation %3d, hue %d \",\n\t\t\tdev->brightness->cur.val,\n\t\t\tdev->contrast->cur.val,\n\t\t\tdev->saturation->cur.val,\n\t\t\tdev->hue->cur.val);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tsnprintf(str, sizeof(str),\n\t\t\t\" autogain %d, gain %3d, alpha 0x%02x \",\n\t\t\tdev->autogain->cur.val, gain, dev->alpha->cur.val);\n\t\tmutex_unlock(dev->ctrl_hdl_user_vid.lock);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tmutex_lock(dev->ctrl_hdl_user_aud.lock);\n\t\tsnprintf(str, sizeof(str),\n\t\t\t\" volume %3d, mute %d \",\n\t\t\tdev->volume->cur.val, dev->mute->cur.val);\n\t\tmutex_unlock(dev->ctrl_hdl_user_aud.lock);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tmutex_lock(dev->ctrl_hdl_user_gen.lock);\n\t\tsnprintf(str, sizeof(str), \" int32 %d, ro_int32 %d, int64 %lld, bitmask %08x \",\n\t\t\t dev->int32->cur.val,\n\t\t\t dev->ro_int32->cur.val,\n\t\t\t *dev->int64->p_cur.p_s64,\n\t\t\t dev->bitmask->cur.val);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tsnprintf(str, sizeof(str), \" boolean %d, menu %s, string \\\"%s\\\" \",\n\t\t\tdev->boolean->cur.val,\n\t\t\tdev->menu->qmenu[dev->menu->cur.val],\n\t\t\tdev->string->p_cur.p_char);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tsnprintf(str, sizeof(str), \" integer_menu %lld, value %d \",\n\t\t\tdev->int_menu->qmenu_int[dev->int_menu->cur.val],\n\t\t\tdev->int_menu->cur.val);\n\t\tmutex_unlock(dev->ctrl_hdl_user_gen.lock);\n\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\tif (dev->button_pressed) {\n\t\t\tdev->button_pressed--;\n\t\t\tsnprintf(str, sizeof(str), \" button pressed!\");\n\t\t\ttpg_gen_text(tpg, basep, line++ * line_height, 16, str);\n\t\t}\n\t\tif (dev->osd[0]) {\n\t\t\tif (vivid_is_hdmi_cap(dev)) {\n\t\t\t\tsnprintf(str, sizeof(str),\n\t\t\t\t\t \" OSD \\\"%s\\\"\", dev->osd);\n\t\t\t\ttpg_gen_text(tpg, basep, line++ * line_height,\n\t\t\t\t\t     16, str);\n\t\t\t}\n\t\t\tif (dev->osd_jiffies &&\n\t\t\t    time_is_before_jiffies(dev->osd_jiffies + 5 * HZ)) {\n\t\t\t\tdev->osd[0] = 0;\n\t\t\t\tdev->osd_jiffies = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void vivid_cap_update_frame_period(struct vivid_dev *dev)\n{\n\tu64 f_period;\n\n\tf_period = (u64)dev->timeperframe_vid_cap.numerator * 1000000000;\n\tif (WARN_ON(dev->timeperframe_vid_cap.denominator == 0))\n\t\tdev->timeperframe_vid_cap.denominator = 1;\n\tdo_div(f_period, dev->timeperframe_vid_cap.denominator);\n\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\tf_period >>= 1;\n\t \n\tdev->cap_frame_eof_offset = f_period * 9;\n\tdo_div(dev->cap_frame_eof_offset, 10);\n\tdev->cap_frame_period = f_period;\n}\n\nstatic noinline_for_stack void vivid_thread_vid_cap_tick(struct vivid_dev *dev,\n\t\t\t\t\t\t\t int dropped_bufs)\n{\n\tstruct vivid_buffer *vid_cap_buf = NULL;\n\tstruct vivid_buffer *vbi_cap_buf = NULL;\n\tstruct vivid_buffer *meta_cap_buf = NULL;\n\tu64 f_time = 0;\n\n\tdprintk(dev, 1, \"Video Capture Thread Tick\\n\");\n\n\twhile (dropped_bufs-- > 1)\n\t\ttpg_update_mv_count(&dev->tpg,\n\t\t\t\tdev->field_cap == V4L2_FIELD_NONE ||\n\t\t\t\tdev->field_cap == V4L2_FIELD_ALTERNATE);\n\n\t \n\tif (dev->perc_dropped_buffers &&\n\t    get_random_u32_below(100) < dev->perc_dropped_buffers)\n\t\tgoto update_mv;\n\n\tspin_lock(&dev->slock);\n\tif (!list_empty(&dev->vid_cap_active)) {\n\t\tvid_cap_buf = list_entry(dev->vid_cap_active.next, struct vivid_buffer, list);\n\t\tlist_del(&vid_cap_buf->list);\n\t}\n\tif (!list_empty(&dev->vbi_cap_active)) {\n\t\tif (dev->field_cap != V4L2_FIELD_ALTERNATE ||\n\t\t    (dev->vbi_cap_seq_count & 1)) {\n\t\t\tvbi_cap_buf = list_entry(dev->vbi_cap_active.next,\n\t\t\t\t\t\t struct vivid_buffer, list);\n\t\t\tlist_del(&vbi_cap_buf->list);\n\t\t}\n\t}\n\tif (!list_empty(&dev->meta_cap_active)) {\n\t\tmeta_cap_buf = list_entry(dev->meta_cap_active.next,\n\t\t\t\t\t  struct vivid_buffer, list);\n\t\tlist_del(&meta_cap_buf->list);\n\t}\n\n\tspin_unlock(&dev->slock);\n\n\tif (!vid_cap_buf && !vbi_cap_buf && !meta_cap_buf)\n\t\tgoto update_mv;\n\n\tf_time = ktime_get_ns() + dev->time_wrap_offset;\n\n\tif (vid_cap_buf) {\n\t\tv4l2_ctrl_request_setup(vid_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t&dev->ctrl_hdl_vid_cap);\n\t\t \n\t\tvivid_fillbuff(dev, vid_cap_buf);\n\t\tdprintk(dev, 1, \"filled buffer %d\\n\",\n\t\t\tvid_cap_buf->vb.vb2_buf.index);\n\n\t\tv4l2_ctrl_request_complete(vid_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_vid_cap);\n\t\tvb2_buffer_done(&vid_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tdprintk(dev, 2, \"vid_cap buffer %d done\\n\",\n\t\t\t\tvid_cap_buf->vb.vb2_buf.index);\n\n\t\tvid_cap_buf->vb.vb2_buf.timestamp = f_time;\n\t\tif (!dev->tstamp_src_is_soe)\n\t\t\tvid_cap_buf->vb.vb2_buf.timestamp += dev->cap_frame_eof_offset;\n\t}\n\n\tif (vbi_cap_buf) {\n\t\tu64 vbi_period;\n\n\t\tv4l2_ctrl_request_setup(vbi_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t&dev->ctrl_hdl_vbi_cap);\n\t\tif (vbi_cap_buf->vb.vb2_buf.type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)\n\t\t\tvivid_sliced_vbi_cap_process(dev, vbi_cap_buf);\n\t\telse\n\t\t\tvivid_raw_vbi_cap_process(dev, vbi_cap_buf);\n\t\tv4l2_ctrl_request_complete(vbi_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_vbi_cap);\n\t\tvb2_buffer_done(&vbi_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tdprintk(dev, 2, \"vbi_cap %d done\\n\",\n\t\t\t\tvbi_cap_buf->vb.vb2_buf.index);\n\n\t\t \n\t\tvbi_period = dev->cap_frame_period * 5;\n\t\tdo_div(vbi_period, 100);\n\t\tvbi_cap_buf->vb.vb2_buf.timestamp = f_time + dev->cap_frame_eof_offset + vbi_period;\n\t}\n\n\tif (meta_cap_buf) {\n\t\tv4l2_ctrl_request_setup(meta_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t&dev->ctrl_hdl_meta_cap);\n\t\tvivid_meta_cap_fillbuff(dev, meta_cap_buf, f_time);\n\t\tv4l2_ctrl_request_complete(meta_cap_buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_meta_cap);\n\t\tvb2_buffer_done(&meta_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tdprintk(dev, 2, \"meta_cap %d done\\n\",\n\t\t\tmeta_cap_buf->vb.vb2_buf.index);\n\t\tmeta_cap_buf->vb.vb2_buf.timestamp = f_time + dev->cap_frame_eof_offset;\n\t}\n\n\tdev->dqbuf_error = false;\n\nupdate_mv:\n\t \n\ttpg_update_mv_count(&dev->tpg, dev->field_cap == V4L2_FIELD_NONE ||\n\t\t\t\t       dev->field_cap == V4L2_FIELD_ALTERNATE);\n}\n\nstatic int vivid_thread_vid_cap(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\tunsigned numerator;\n\tunsigned denominator;\n\tint dropped_bufs;\n\n\tdprintk(dev, 1, \"Video Capture Thread Start\\n\");\n\n\tset_freezable();\n\n\t \n\tdev->cap_seq_offset = 0;\n\tdev->cap_seq_count = 0;\n\tdev->cap_seq_resync = false;\n\tdev->jiffies_vid_cap = jiffies;\n\tdev->cap_stream_start = ktime_get_ns();\n\tif (dev->time_wrap)\n\t\tdev->time_wrap_offset = dev->time_wrap - dev->cap_stream_start;\n\telse\n\t\tdev->time_wrap_offset = 0;\n\tvivid_cap_update_frame_period(dev);\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&dev->mutex)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->cap_seq_resync) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = dev->cap_seq_count + 1;\n\t\t\tdev->cap_seq_count = 0;\n\t\t\tdev->cap_stream_start += dev->cap_frame_period *\n\t\t\t\t\t\t dev->cap_seq_offset;\n\t\t\tvivid_cap_update_frame_period(dev);\n\t\t\tdev->cap_seq_resync = false;\n\t\t}\n\t\tnumerator = dev->timeperframe_vid_cap.numerator;\n\t\tdenominator = dev->timeperframe_vid_cap.denominator;\n\n\t\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\t\tdenominator *= 2;\n\n\t\t \n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_vid_cap;\n\t\t \n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t \n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdropped_bufs = buffers_since_start + dev->cap_seq_offset - dev->cap_seq_count;\n\t\tdev->cap_seq_count = buffers_since_start + dev->cap_seq_offset;\n\t\tdev->vid_cap_seq_count = dev->cap_seq_count - dev->vid_cap_seq_start;\n\t\tdev->vbi_cap_seq_count = dev->cap_seq_count - dev->vbi_cap_seq_start;\n\t\tdev->meta_cap_seq_count = dev->cap_seq_count - dev->meta_cap_seq_start;\n\n\t\tvivid_thread_vid_cap_tick(dev, dropped_bufs);\n\n\t\t \n\t\tnumerators_since_start = ++buffers_since_start * numerator;\n\n\t\t \n\t\tjiffies_since_start = jiffies - dev->jiffies_vid_cap;\n\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t \n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t \n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\twhile (time_is_after_jiffies(cur_jiffies + wait_jiffies) &&\n\t\t       !kthread_should_stop())\n\t\t\tschedule();\n\t}\n\tdprintk(dev, 1, \"Video Capture Thread End\\n\");\n\treturn 0;\n}\n\nstatic void vivid_grab_controls(struct vivid_dev *dev, bool grab)\n{\n\tv4l2_ctrl_grab(dev->ctrl_has_crop_cap, grab);\n\tv4l2_ctrl_grab(dev->ctrl_has_compose_cap, grab);\n\tv4l2_ctrl_grab(dev->ctrl_has_scaler_cap, grab);\n}\n\nint vivid_start_generating_vid_cap(struct vivid_dev *dev, bool *pstreaming)\n{\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->kthread_vid_cap) {\n\t\tu32 seq_count = dev->cap_seq_count + dev->seq_wrap * 128;\n\n\t\tif (pstreaming == &dev->vid_cap_streaming)\n\t\t\tdev->vid_cap_seq_start = seq_count;\n\t\telse if (pstreaming == &dev->vbi_cap_streaming)\n\t\t\tdev->vbi_cap_seq_start = seq_count;\n\t\telse\n\t\t\tdev->meta_cap_seq_start = seq_count;\n\t\t*pstreaming = true;\n\t\treturn 0;\n\t}\n\n\t \n\ttpg_init_mv_count(&dev->tpg);\n\n\tdev->vid_cap_seq_start = dev->seq_wrap * 128;\n\tdev->vbi_cap_seq_start = dev->seq_wrap * 128;\n\tdev->meta_cap_seq_start = dev->seq_wrap * 128;\n\n\tdev->kthread_vid_cap = kthread_run(vivid_thread_vid_cap, dev,\n\t\t\t\"%s-vid-cap\", dev->v4l2_dev.name);\n\n\tif (IS_ERR(dev->kthread_vid_cap)) {\n\t\tint err = PTR_ERR(dev->kthread_vid_cap);\n\n\t\tdev->kthread_vid_cap = NULL;\n\t\tv4l2_err(&dev->v4l2_dev, \"kernel_thread() failed\\n\");\n\t\treturn err;\n\t}\n\t*pstreaming = true;\n\tvivid_grab_controls(dev, true);\n\n\tdprintk(dev, 1, \"returning from %s\\n\", __func__);\n\treturn 0;\n}\n\nvoid vivid_stop_generating_vid_cap(struct vivid_dev *dev, bool *pstreaming)\n{\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->kthread_vid_cap == NULL)\n\t\treturn;\n\n\t*pstreaming = false;\n\tif (pstreaming == &dev->vid_cap_streaming) {\n\t\t \n\t\twhile (!list_empty(&dev->vid_cap_active)) {\n\t\t\tstruct vivid_buffer *buf;\n\n\t\t\tbuf = list_entry(dev->vid_cap_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\t\t\tlist_del(&buf->list);\n\t\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t\t   &dev->ctrl_hdl_vid_cap);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t\tdprintk(dev, 2, \"vid_cap buffer %d done\\n\",\n\t\t\t\tbuf->vb.vb2_buf.index);\n\t\t}\n\t}\n\n\tif (pstreaming == &dev->vbi_cap_streaming) {\n\t\twhile (!list_empty(&dev->vbi_cap_active)) {\n\t\t\tstruct vivid_buffer *buf;\n\n\t\t\tbuf = list_entry(dev->vbi_cap_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\t\t\tlist_del(&buf->list);\n\t\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t\t   &dev->ctrl_hdl_vbi_cap);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t\tdprintk(dev, 2, \"vbi_cap buffer %d done\\n\",\n\t\t\t\tbuf->vb.vb2_buf.index);\n\t\t}\n\t}\n\n\tif (pstreaming == &dev->meta_cap_streaming) {\n\t\twhile (!list_empty(&dev->meta_cap_active)) {\n\t\t\tstruct vivid_buffer *buf;\n\n\t\t\tbuf = list_entry(dev->meta_cap_active.next,\n\t\t\t\t\t struct vivid_buffer, list);\n\t\t\tlist_del(&buf->list);\n\t\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t\t   &dev->ctrl_hdl_meta_cap);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t\tdprintk(dev, 2, \"meta_cap buffer %d done\\n\",\n\t\t\t\tbuf->vb.vb2_buf.index);\n\t\t}\n\t}\n\n\tif (dev->vid_cap_streaming || dev->vbi_cap_streaming ||\n\t    dev->meta_cap_streaming)\n\t\treturn;\n\n\t \n\tvivid_grab_controls(dev, false);\n\tkthread_stop(dev->kthread_vid_cap);\n\tdev->kthread_vid_cap = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}