{
  "module_name": "vivid-radio-rx.c",
  "hash_id": "e017baac7df7c98c6fe33f8e781cef6ea3381e46fee3ce7c67612fb92939ae63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-radio-rx.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/sched/signal.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-ctrls.h\"\n#include \"vivid-radio-common.h\"\n#include \"vivid-rds-gen.h\"\n#include \"vivid-radio-rx.h\"\n\nssize_t vivid_radio_rx_read(struct file *file, char __user *buf,\n\t\t\t size_t size, loff_t *offset)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_rds_data *data = dev->rds_gen.data;\n\tbool use_alternates;\n\tktime_t timestamp;\n\tunsigned blk;\n\tint perc;\n\tint i;\n\n\tif (dev->radio_rx_rds_controls)\n\t\treturn -EINVAL;\n\tif (size < sizeof(*data))\n\t\treturn 0;\n\tsize = sizeof(*data) * (size / sizeof(*data));\n\n\tif (mutex_lock_interruptible(&dev->mutex))\n\t\treturn -ERESTARTSYS;\n\tif (dev->radio_rx_rds_owner &&\n\t    file->private_data != dev->radio_rx_rds_owner) {\n\t\tmutex_unlock(&dev->mutex);\n\t\treturn -EBUSY;\n\t}\n\tif (dev->radio_rx_rds_owner == NULL) {\n\t\tvivid_radio_rds_init(dev);\n\t\tdev->radio_rx_rds_owner = file->private_data;\n\t}\n\nretry:\n\ttimestamp = ktime_sub(ktime_get(), dev->radio_rds_init_time);\n\tblk = ktime_divns(timestamp, VIVID_RDS_NSEC_PER_BLK);\n\tuse_alternates = (blk % VIVID_RDS_GEN_BLOCKS) & 1;\n\n\tif (dev->radio_rx_rds_last_block == 0 ||\n\t    dev->radio_rx_rds_use_alternates != use_alternates) {\n\t\tdev->radio_rx_rds_use_alternates = use_alternates;\n\t\t \n\t\tvivid_radio_rds_init(dev);\n\t}\n\tif (blk >= dev->radio_rx_rds_last_block + VIVID_RDS_GEN_BLOCKS)\n\t\tdev->radio_rx_rds_last_block = blk - VIVID_RDS_GEN_BLOCKS + 1;\n\n\t \n\tif (blk == dev->radio_rx_rds_last_block || !dev->radio_rx_rds_enabled ||\n\t    (dev->radio_rds_loop && !(dev->radio_tx_subchans & V4L2_TUNER_SUB_RDS)) ||\n\t    abs(dev->radio_rx_sig_qual) > 200) {\n\t\tmutex_unlock(&dev->mutex);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\t\tif (msleep_interruptible(20) && signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (mutex_lock_interruptible(&dev->mutex))\n\t\t\treturn -ERESTARTSYS;\n\t\tgoto retry;\n\t}\n\n\t \n\tperc = abs(dev->radio_rx_sig_qual) / 4;\n\n\tfor (i = 0; i < size && blk > dev->radio_rx_rds_last_block;\n\t\t\tdev->radio_rx_rds_last_block++) {\n\t\tunsigned data_blk = dev->radio_rx_rds_last_block % VIVID_RDS_GEN_BLOCKS;\n\t\tstruct v4l2_rds_data rds = data[data_blk];\n\n\t\tif (data_blk == 0 && dev->radio_rds_loop)\n\t\t\tvivid_radio_rds_init(dev);\n\t\tif (perc && get_random_u32_below(100) < perc) {\n\t\t\tswitch (get_random_u32_below(4)) {\n\t\t\tcase 0:\n\t\t\t\trds.block |= V4L2_RDS_BLOCK_CORRECTED;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trds.block |= V4L2_RDS_BLOCK_INVALID;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trds.block |= V4L2_RDS_BLOCK_ERROR;\n\t\t\t\trds.lsb = get_random_u8();\n\t\t\t\trds.msb = get_random_u8();\n\t\t\t\tbreak;\n\t\t\tcase 3:  \n\t\t\t\tif (i)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (copy_to_user(buf + i, &rds, sizeof(rds))) {\n\t\t\ti = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ti += sizeof(rds);\n\t}\n\tmutex_unlock(&dev->mutex);\n\treturn i;\n}\n\n__poll_t vivid_radio_rx_poll(struct file *file, struct poll_table_struct *wait)\n{\n\treturn EPOLLIN | EPOLLRDNORM | v4l2_ctrl_poll(file, wait);\n}\n\nint vivid_radio_rx_enum_freq_bands(struct file *file, void *fh, struct v4l2_frequency_band *band)\n{\n\tif (band->tuner != 0)\n\t\treturn -EINVAL;\n\n\tif (band->index >= TOT_BANDS)\n\t\treturn -EINVAL;\n\n\t*band = vivid_radio_bands[band->index];\n\treturn 0;\n}\n\nint vivid_radio_rx_s_hw_freq_seek(struct file *file, void *fh, const struct v4l2_hw_freq_seek *a)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tunsigned low, high;\n\tunsigned freq;\n\tunsigned spacing;\n\tunsigned band;\n\n\tif (a->tuner)\n\t\treturn -EINVAL;\n\tif (a->wrap_around && dev->radio_rx_hw_seek_mode == VIVID_HW_SEEK_BOUNDED)\n\t\treturn -EINVAL;\n\n\tif (!a->wrap_around && dev->radio_rx_hw_seek_mode == VIVID_HW_SEEK_WRAP)\n\t\treturn -EINVAL;\n\tif (!a->rangelow ^ !a->rangehigh)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tif (a->rangelow) {\n\t\tfor (band = 0; band < TOT_BANDS; band++)\n\t\t\tif (a->rangelow >= vivid_radio_bands[band].rangelow &&\n\t\t\t    a->rangehigh <= vivid_radio_bands[band].rangehigh)\n\t\t\t\tbreak;\n\t\tif (band == TOT_BANDS)\n\t\t\treturn -EINVAL;\n\t\tif (!dev->radio_rx_hw_seek_prog_lim &&\n\t\t    (a->rangelow != vivid_radio_bands[band].rangelow ||\n\t\t     a->rangehigh != vivid_radio_bands[band].rangehigh))\n\t\t\treturn -EINVAL;\n\t\tlow = a->rangelow;\n\t\thigh = a->rangehigh;\n\t} else {\n\t\tfor (band = 0; band < TOT_BANDS; band++)\n\t\t\tif (dev->radio_rx_freq >= vivid_radio_bands[band].rangelow &&\n\t\t\t    dev->radio_rx_freq <= vivid_radio_bands[band].rangehigh)\n\t\t\t\tbreak;\n\t\tif (band == TOT_BANDS)\n\t\t\treturn -EINVAL;\n\t\tlow = vivid_radio_bands[band].rangelow;\n\t\thigh = vivid_radio_bands[band].rangehigh;\n\t}\n\tspacing = band == BAND_AM ? 1600 : 16000;\n\tfreq = clamp(dev->radio_rx_freq, low, high);\n\n\tif (a->seek_upward) {\n\t\tfreq = spacing * (freq / spacing) + spacing;\n\t\tif (freq > high) {\n\t\t\tif (!a->wrap_around)\n\t\t\t\treturn -ENODATA;\n\t\t\tfreq = spacing * (low / spacing) + spacing;\n\t\t\tif (freq >= dev->radio_rx_freq)\n\t\t\t\treturn -ENODATA;\n\t\t}\n\t} else {\n\t\tfreq = spacing * ((freq + spacing - 1) / spacing) - spacing;\n\t\tif (freq < low) {\n\t\t\tif (!a->wrap_around)\n\t\t\t\treturn -ENODATA;\n\t\t\tfreq = spacing * ((high + spacing - 1) / spacing) - spacing;\n\t\t\tif (freq <= dev->radio_rx_freq)\n\t\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint vivid_radio_rx_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tint delta = 800;\n\tint sig_qual;\n\n\tif (vt->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(vt->name, \"AM/FM/SW Receiver\", sizeof(vt->name));\n\tvt->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t V4L2_TUNER_CAP_FREQ_BANDS | V4L2_TUNER_CAP_RDS |\n\t\t\t (dev->radio_rx_rds_controls ?\n\t\t\t\tV4L2_TUNER_CAP_RDS_CONTROLS :\n\t\t\t\tV4L2_TUNER_CAP_RDS_BLOCK_IO) |\n\t\t\t (dev->radio_rx_hw_seek_prog_lim ?\n\t\t\t\tV4L2_TUNER_CAP_HWSEEK_PROG_LIM : 0);\n\tswitch (dev->radio_rx_hw_seek_mode) {\n\tcase VIVID_HW_SEEK_BOUNDED:\n\t\tvt->capability |= V4L2_TUNER_CAP_HWSEEK_BOUNDED;\n\t\tbreak;\n\tcase VIVID_HW_SEEK_WRAP:\n\t\tvt->capability |= V4L2_TUNER_CAP_HWSEEK_WRAP;\n\t\tbreak;\n\tcase VIVID_HW_SEEK_BOTH:\n\t\tvt->capability |= V4L2_TUNER_CAP_HWSEEK_WRAP |\n\t\t\t\t  V4L2_TUNER_CAP_HWSEEK_BOUNDED;\n\t\tbreak;\n\t}\n\tvt->rangelow = AM_FREQ_RANGE_LOW;\n\tvt->rangehigh = FM_FREQ_RANGE_HIGH;\n\tsig_qual = dev->radio_rx_sig_qual;\n\tvt->signal = abs(sig_qual) > delta ? 0 :\n\t\t     0xffff - ((unsigned)abs(sig_qual) * 0xffff) / delta;\n\tvt->afc = sig_qual > delta ? 0 : sig_qual;\n\tif (abs(sig_qual) > delta)\n\t\tvt->rxsubchans = 0;\n\telse if (dev->radio_rx_freq < FM_FREQ_RANGE_LOW || vt->signal < 0x8000)\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_MONO;\n\telse if (dev->radio_rds_loop && !(dev->radio_tx_subchans & V4L2_TUNER_SUB_STEREO))\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_MONO;\n\telse\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_STEREO;\n\tif (dev->radio_rx_rds_enabled &&\n\t    (!dev->radio_rds_loop || (dev->radio_tx_subchans & V4L2_TUNER_SUB_RDS)) &&\n\t    dev->radio_rx_freq >= FM_FREQ_RANGE_LOW && vt->signal >= 0xc000)\n\t\tvt->rxsubchans |= V4L2_TUNER_SUB_RDS;\n\tif (dev->radio_rx_rds_controls)\n\t\tvivid_radio_rds_init(dev);\n\tvt->audmode = dev->radio_rx_audmode;\n\treturn 0;\n}\n\nint vivid_radio_rx_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (vt->index)\n\t\treturn -EINVAL;\n\tdev->radio_rx_audmode = vt->audmode >= V4L2_TUNER_MODE_STEREO;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}