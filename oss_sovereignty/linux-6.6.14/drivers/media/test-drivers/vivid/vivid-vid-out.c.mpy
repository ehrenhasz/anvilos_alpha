{
  "module_name": "vivid-vid-out.c",
  "hash_id": "d3f82ed2b63b296d8e6bb4ebb82199959e50194554374b5d5dcc0dcc7cf83486",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-vid-out.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-rect.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-vid-common.h\"\n#include \"vivid-kthread-out.h\"\n#include \"vivid-vid-out.h\"\n\nstatic int vid_out_queue_setup(struct vb2_queue *vq,\n\t\t       unsigned *nbuffers, unsigned *nplanes,\n\t\t       unsigned sizes[], struct device *alloc_devs[])\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tconst struct vivid_fmt *vfmt = dev->fmt_out;\n\tunsigned planes = vfmt->buffers;\n\tunsigned h = dev->fmt_out_rect.height;\n\tunsigned int size = dev->bytesperline_out[0] * h + vfmt->data_offset[0];\n\tunsigned p;\n\n\tfor (p = vfmt->buffers; p < vfmt->planes; p++)\n\t\tsize += dev->bytesperline_out[p] * h / vfmt->vdownsampling[p] +\n\t\t\tvfmt->data_offset[p];\n\n\tif (dev->field_out == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tif (vb2_fileio_is_active(vq))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (dev->queue_setup_error) {\n\t\t \n\t\tdev->queue_setup_error = false;\n\t\treturn -EINVAL;\n\t}\n\n\tif (*nplanes) {\n\t\t \n\t\tif (*nplanes != planes)\n\t\t\treturn -EINVAL;\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tfor (p = 1; p < planes; p++) {\n\t\t\tif (sizes[p] < dev->bytesperline_out[p] * h +\n\t\t\t\t       vfmt->data_offset[p])\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tfor (p = 0; p < planes; p++)\n\t\t\tsizes[p] = p ? dev->bytesperline_out[p] * h +\n\t\t\t\t       vfmt->data_offset[p] : size;\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\n\t*nplanes = planes;\n\n\tdprintk(dev, 1, \"%s: count=%d\\n\", __func__, *nbuffers);\n\tfor (p = 0; p < planes; p++)\n\t\tdprintk(dev, 1, \"%s: size[%u]=%u\\n\", __func__, p, sizes[p]);\n\treturn 0;\n}\n\nstatic int vid_out_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->field_out != V4L2_FIELD_ALTERNATE)\n\t\tvbuf->field = dev->field_out;\n\telse if (vbuf->field != V4L2_FIELD_TOP &&\n\t\t vbuf->field != V4L2_FIELD_BOTTOM)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int vid_out_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tconst struct vivid_fmt *vfmt = dev->fmt_out;\n\tunsigned int planes = vfmt->buffers;\n\tunsigned int h = dev->fmt_out_rect.height;\n\tunsigned int size = dev->bytesperline_out[0] * h;\n\tunsigned p;\n\n\tfor (p = vfmt->buffers; p < vfmt->planes; p++)\n\t\tsize += dev->bytesperline_out[p] * h / vfmt->vdownsampling[p];\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (WARN_ON(NULL == dev->fmt_out))\n\t\treturn -EINVAL;\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\n\tfor (p = 0; p < planes; p++) {\n\t\tif (p)\n\t\t\tsize = dev->bytesperline_out[p] * h;\n\t\tsize += vb->planes[p].data_offset;\n\n\t\tif (vb2_get_plane_payload(vb, p) < size) {\n\t\t\tdprintk(dev, 1, \"%s the payload is too small for plane %u (%lu < %u)\\n\",\n\t\t\t\t\t__func__, p, vb2_get_plane_payload(vb, p), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vid_out_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->vid_out_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int vid_out_start_streaming(struct vb2_queue *vq, unsigned count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err;\n\n\tif (vb2_is_streaming(&dev->vb_vid_cap_q))\n\t\tdev->can_loop_video = vivid_vid_can_loop(dev);\n\n\tdev->vid_out_seq_count = 0;\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = vivid_start_generating_vid_out(dev, &dev->vid_out_streaming);\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &dev->vid_out_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void vid_out_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tvivid_stop_generating_vid_out(dev, &dev->vid_out_streaming);\n\tdev->can_loop_video = false;\n}\n\nstatic void vid_out_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_vid_out);\n}\n\nconst struct vb2_ops vivid_vid_out_qops = {\n\t.queue_setup\t\t= vid_out_queue_setup,\n\t.buf_out_validate\t\t= vid_out_buf_out_validate,\n\t.buf_prepare\t\t= vid_out_buf_prepare,\n\t.buf_queue\t\t= vid_out_buf_queue,\n\t.start_streaming\t= vid_out_start_streaming,\n\t.stop_streaming\t\t= vid_out_stop_streaming,\n\t.buf_request_complete\t= vid_out_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \nvoid vivid_update_format_out(struct vivid_dev *dev)\n{\n\tstruct v4l2_bt_timings *bt = &dev->dv_timings_out.bt;\n\tunsigned size, p;\n\tu64 pixelclock;\n\n\tswitch (dev->output_type[dev->output]) {\n\tcase SVID:\n\tdefault:\n\t\tdev->field_out = dev->tv_field_out;\n\t\tdev->sink_rect.width = 720;\n\t\tif (dev->std_out & V4L2_STD_525_60) {\n\t\t\tdev->sink_rect.height = 480;\n\t\t\tdev->timeperframe_vid_out = (struct v4l2_fract) { 1001, 30000 };\n\t\t\tdev->service_set_out = V4L2_SLICED_CAPTION_525;\n\t\t} else {\n\t\t\tdev->sink_rect.height = 576;\n\t\t\tdev->timeperframe_vid_out = (struct v4l2_fract) { 1000, 25000 };\n\t\t\tdev->service_set_out = V4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\n\t\t}\n\t\tdev->colorspace_out = V4L2_COLORSPACE_SMPTE170M;\n\t\tbreak;\n\tcase HDMI:\n\t\tdev->sink_rect.width = bt->width;\n\t\tdev->sink_rect.height = bt->height;\n\t\tsize = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);\n\n\t\tif (can_reduce_fps(bt) && (bt->flags & V4L2_DV_FL_REDUCED_FPS))\n\t\t\tpixelclock = div_u64(bt->pixelclock * 1000, 1001);\n\t\telse\n\t\t\tpixelclock = bt->pixelclock;\n\n\t\tdev->timeperframe_vid_out = (struct v4l2_fract) {\n\t\t\tsize / 100, (u32)pixelclock / 100\n\t\t};\n\t\tif (bt->interlaced)\n\t\t\tdev->field_out = V4L2_FIELD_ALTERNATE;\n\t\telse\n\t\t\tdev->field_out = V4L2_FIELD_NONE;\n\t\tif (!dev->dvi_d_out && (bt->flags & V4L2_DV_FL_IS_CE_VIDEO)) {\n\t\t\tif (bt->width == 720 && bt->height <= 576)\n\t\t\t\tdev->colorspace_out = V4L2_COLORSPACE_SMPTE170M;\n\t\t\telse\n\t\t\t\tdev->colorspace_out = V4L2_COLORSPACE_REC709;\n\t\t} else {\n\t\t\tdev->colorspace_out = V4L2_COLORSPACE_SRGB;\n\t\t}\n\t\tbreak;\n\t}\n\tdev->xfer_func_out = V4L2_XFER_FUNC_DEFAULT;\n\tdev->ycbcr_enc_out = V4L2_YCBCR_ENC_DEFAULT;\n\tdev->hsv_enc_out = V4L2_HSV_ENC_180;\n\tdev->quantization_out = V4L2_QUANTIZATION_DEFAULT;\n\tdev->compose_out = dev->sink_rect;\n\tdev->compose_bounds_out = dev->sink_rect;\n\tdev->crop_out = dev->compose_out;\n\tif (V4L2_FIELD_HAS_T_OR_B(dev->field_out))\n\t\tdev->crop_out.height /= 2;\n\tdev->fmt_out_rect = dev->crop_out;\n\tfor (p = 0; p < dev->fmt_out->planes; p++)\n\t\tdev->bytesperline_out[p] =\n\t\t\t(dev->sink_rect.width * dev->fmt_out->bit_depth[p]) / 8;\n}\n\n \nstatic enum v4l2_field vivid_field_out(struct vivid_dev *dev, enum v4l2_field field)\n{\n\tif (vivid_is_svid_out(dev)) {\n\t\tswitch (field) {\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\tcase V4L2_FIELD_ALTERNATE:\n\t\t\treturn field;\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\tdefault:\n\t\t\treturn V4L2_FIELD_INTERLACED;\n\t\t}\n\t}\n\tif (vivid_is_hdmi_out(dev))\n\t\treturn dev->dv_timings_out.bt.interlaced ? V4L2_FIELD_ALTERNATE :\n\t\t\t\t\t\t       V4L2_FIELD_NONE;\n\treturn V4L2_FIELD_NONE;\n}\n\nstatic enum tpg_pixel_aspect vivid_get_pixel_aspect(const struct vivid_dev *dev)\n{\n\tif (vivid_is_svid_out(dev))\n\t\treturn (dev->std_out & V4L2_STD_525_60) ?\n\t\t\tTPG_PIXEL_ASPECT_NTSC : TPG_PIXEL_ASPECT_PAL;\n\n\tif (vivid_is_hdmi_out(dev) &&\n\t    dev->sink_rect.width == 720 && dev->sink_rect.height <= 576)\n\t\treturn dev->sink_rect.height == 480 ?\n\t\t\tTPG_PIXEL_ASPECT_NTSC : TPG_PIXEL_ASPECT_PAL;\n\n\treturn TPG_PIXEL_ASPECT_SQUARE;\n}\n\nint vivid_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\n\tconst struct vivid_fmt *fmt = dev->fmt_out;\n\tunsigned p;\n\n\tmp->width        = dev->fmt_out_rect.width;\n\tmp->height       = dev->fmt_out_rect.height;\n\tmp->field        = dev->field_out;\n\tmp->pixelformat  = fmt->fourcc;\n\tmp->colorspace   = dev->colorspace_out;\n\tmp->xfer_func    = dev->xfer_func_out;\n\tmp->ycbcr_enc    = dev->ycbcr_enc_out;\n\tmp->quantization = dev->quantization_out;\n\tmp->num_planes = fmt->buffers;\n\tfor (p = 0; p < mp->num_planes; p++) {\n\t\tmp->plane_fmt[p].bytesperline = dev->bytesperline_out[p];\n\t\tmp->plane_fmt[p].sizeimage =\n\t\t\tmp->plane_fmt[p].bytesperline * mp->height +\n\t\t\tfmt->data_offset[p];\n\t}\n\tfor (p = fmt->buffers; p < fmt->planes; p++) {\n\t\tunsigned stride = dev->bytesperline_out[p];\n\n\t\tmp->plane_fmt[0].sizeimage +=\n\t\t\t(stride * mp->height) / fmt->vdownsampling[p];\n\t}\n\treturn 0;\n}\n\nint vivid_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_bt_timings *bt = &dev->dv_timings_out.bt;\n\tstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *pfmt = mp->plane_fmt;\n\tconst struct vivid_fmt *fmt;\n\tunsigned bytesperline, max_bpl;\n\tunsigned factor = 1;\n\tunsigned w, h;\n\tunsigned p;\n\n\tfmt = vivid_get_format(dev, mp->pixelformat);\n\tif (!fmt) {\n\t\tdprintk(dev, 1, \"Fourcc format (0x%08x) unknown.\\n\",\n\t\t\tmp->pixelformat);\n\t\tmp->pixelformat = V4L2_PIX_FMT_YUYV;\n\t\tfmt = vivid_get_format(dev, mp->pixelformat);\n\t}\n\n\tmp->field = vivid_field_out(dev, mp->field);\n\tif (vivid_is_svid_out(dev)) {\n\t\tw = 720;\n\t\th = (dev->std_out & V4L2_STD_525_60) ? 480 : 576;\n\t} else {\n\t\tw = dev->sink_rect.width;\n\t\th = dev->sink_rect.height;\n\t}\n\tif (V4L2_FIELD_HAS_T_OR_B(mp->field))\n\t\tfactor = 2;\n\tif (!dev->has_scaler_out && !dev->has_crop_out && !dev->has_compose_out) {\n\t\tmp->width = w;\n\t\tmp->height = h / factor;\n\t} else {\n\t\tstruct v4l2_rect r = { 0, 0, mp->width, mp->height * factor };\n\n\t\tv4l2_rect_set_min_size(&r, &vivid_min_rect);\n\t\tv4l2_rect_set_max_size(&r, &vivid_max_rect);\n\t\tif (dev->has_scaler_out && !dev->has_crop_out) {\n\t\t\tstruct v4l2_rect max_r = { 0, 0, MAX_ZOOM * w, MAX_ZOOM * h };\n\n\t\t\tv4l2_rect_set_max_size(&r, &max_r);\n\t\t} else if (!dev->has_scaler_out && dev->has_compose_out && !dev->has_crop_out) {\n\t\t\tv4l2_rect_set_max_size(&r, &dev->sink_rect);\n\t\t} else if (!dev->has_scaler_out && !dev->has_compose_out) {\n\t\t\tv4l2_rect_set_min_size(&r, &dev->sink_rect);\n\t\t}\n\t\tmp->width = r.width;\n\t\tmp->height = r.height / factor;\n\t}\n\n\t \n\n\tmp->num_planes = fmt->buffers;\n\tfor (p = 0; p < fmt->buffers; p++) {\n\t\t \n\t\tbytesperline = (mp->width * fmt->bit_depth[p]) >> 3;\n\t\t \n\t\tmax_bpl = (MAX_ZOOM * MAX_WIDTH * fmt->bit_depth[p]) >> 3;\n\n\t\tif (pfmt[p].bytesperline > max_bpl)\n\t\t\tpfmt[p].bytesperline = max_bpl;\n\t\tif (pfmt[p].bytesperline < bytesperline)\n\t\t\tpfmt[p].bytesperline = bytesperline;\n\n\t\tpfmt[p].sizeimage = (pfmt[p].bytesperline * mp->height) /\n\t\t\t\tfmt->vdownsampling[p] + fmt->data_offset[p];\n\n\t\tmemset(pfmt[p].reserved, 0, sizeof(pfmt[p].reserved));\n\t}\n\tfor (p = fmt->buffers; p < fmt->planes; p++)\n\t\tpfmt[0].sizeimage += (pfmt[0].bytesperline * mp->height *\n\t\t\t(fmt->bit_depth[p] / fmt->vdownsampling[p])) /\n\t\t\t(fmt->bit_depth[0] / fmt->vdownsampling[0]);\n\n\tmp->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tmp->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tmp->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tif (vivid_is_svid_out(dev)) {\n\t\tmp->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t} else if (dev->dvi_d_out || !(bt->flags & V4L2_DV_FL_IS_CE_VIDEO)) {\n\t\tmp->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (dev->dvi_d_out)\n\t\t\tmp->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\t} else if (bt->width == 720 && bt->height <= 576) {\n\t\tmp->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t} else if (mp->colorspace != V4L2_COLORSPACE_SMPTE170M &&\n\t\t   mp->colorspace != V4L2_COLORSPACE_REC709 &&\n\t\t   mp->colorspace != V4L2_COLORSPACE_OPRGB &&\n\t\t   mp->colorspace != V4L2_COLORSPACE_BT2020 &&\n\t\t   mp->colorspace != V4L2_COLORSPACE_SRGB) {\n\t\tmp->colorspace = V4L2_COLORSPACE_REC709;\n\t}\n\tmemset(mp->reserved, 0, sizeof(mp->reserved));\n\treturn 0;\n}\n\nint vivid_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_rect *crop = &dev->crop_out;\n\tstruct v4l2_rect *compose = &dev->compose_out;\n\tstruct vb2_queue *q = &dev->vb_vid_out_q;\n\tint ret = vivid_try_fmt_vid_out(file, priv, f);\n\tunsigned factor = 1;\n\tunsigned p;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vb2_is_busy(q) &&\n\t    (vivid_is_svid_out(dev) ||\n\t     mp->width != dev->fmt_out_rect.width ||\n\t     mp->height != dev->fmt_out_rect.height ||\n\t     mp->pixelformat != dev->fmt_out->fourcc ||\n\t     mp->field != dev->field_out)) {\n\t\tdprintk(dev, 1, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (vb2_is_busy(q))\n\t\tgoto set_colorspace;\n\n\tdev->fmt_out = vivid_get_format(dev, mp->pixelformat);\n\tif (V4L2_FIELD_HAS_T_OR_B(mp->field))\n\t\tfactor = 2;\n\n\tif (dev->has_scaler_out || dev->has_crop_out || dev->has_compose_out) {\n\t\tstruct v4l2_rect r = { 0, 0, mp->width, mp->height };\n\n\t\tif (dev->has_scaler_out) {\n\t\t\tif (dev->has_crop_out)\n\t\t\t\tv4l2_rect_map_inside(crop, &r);\n\t\t\telse\n\t\t\t\t*crop = r;\n\t\t\tif (dev->has_compose_out && !dev->has_crop_out) {\n\t\t\t\tstruct v4l2_rect min_r = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\tr.width / MAX_ZOOM,\n\t\t\t\t\tfactor * r.height / MAX_ZOOM\n\t\t\t\t};\n\t\t\t\tstruct v4l2_rect max_r = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\tr.width * MAX_ZOOM,\n\t\t\t\t\tfactor * r.height * MAX_ZOOM\n\t\t\t\t};\n\n\t\t\t\tv4l2_rect_set_min_size(compose, &min_r);\n\t\t\t\tv4l2_rect_set_max_size(compose, &max_r);\n\t\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t\t} else if (dev->has_compose_out) {\n\t\t\t\tstruct v4l2_rect min_r = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\tcrop->width / MAX_ZOOM,\n\t\t\t\t\tfactor * crop->height / MAX_ZOOM\n\t\t\t\t};\n\t\t\t\tstruct v4l2_rect max_r = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\tcrop->width * MAX_ZOOM,\n\t\t\t\t\tfactor * crop->height * MAX_ZOOM\n\t\t\t\t};\n\n\t\t\t\tv4l2_rect_set_min_size(compose, &min_r);\n\t\t\t\tv4l2_rect_set_max_size(compose, &max_r);\n\t\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t\t}\n\t\t} else if (dev->has_compose_out && !dev->has_crop_out) {\n\t\t\tv4l2_rect_set_size_to(crop, &r);\n\t\t\tr.height *= factor;\n\t\t\tv4l2_rect_set_size_to(compose, &r);\n\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t} else if (!dev->has_compose_out) {\n\t\t\tv4l2_rect_map_inside(crop, &r);\n\t\t\tr.height /= factor;\n\t\t\tv4l2_rect_set_size_to(compose, &r);\n\t\t} else {\n\t\t\tr.height *= factor;\n\t\t\tv4l2_rect_set_max_size(compose, &r);\n\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t\tcrop->top *= factor;\n\t\t\tcrop->height *= factor;\n\t\t\tv4l2_rect_set_size_to(crop, compose);\n\t\t\tv4l2_rect_map_inside(crop, &r);\n\t\t\tcrop->top /= factor;\n\t\t\tcrop->height /= factor;\n\t\t}\n\t} else {\n\t\tstruct v4l2_rect r = { 0, 0, mp->width, mp->height };\n\n\t\tv4l2_rect_set_size_to(crop, &r);\n\t\tr.height /= factor;\n\t\tv4l2_rect_set_size_to(compose, &r);\n\t}\n\n\tdev->fmt_out_rect.width = mp->width;\n\tdev->fmt_out_rect.height = mp->height;\n\tfor (p = 0; p < mp->num_planes; p++)\n\t\tdev->bytesperline_out[p] = mp->plane_fmt[p].bytesperline;\n\tfor (p = dev->fmt_out->buffers; p < dev->fmt_out->planes; p++)\n\t\tdev->bytesperline_out[p] =\n\t\t\t(dev->bytesperline_out[0] * dev->fmt_out->bit_depth[p]) /\n\t\t\tdev->fmt_out->bit_depth[0];\n\tdev->field_out = mp->field;\n\tif (vivid_is_svid_out(dev))\n\t\tdev->tv_field_out = mp->field;\n\nset_colorspace:\n\tdev->colorspace_out = mp->colorspace;\n\tdev->xfer_func_out = mp->xfer_func;\n\tdev->ycbcr_enc_out = mp->ycbcr_enc;\n\tdev->quantization_out = mp->quantization;\n\tif (dev->loop_video) {\n\t\tvivid_send_source_change(dev, SVID);\n\t\tvivid_send_source_change(dev, HDMI);\n\t}\n\treturn 0;\n}\n\nint vidioc_g_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn vivid_g_fmt_vid_out(file, priv, f);\n}\n\nint vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn vivid_try_fmt_vid_out(file, priv, f);\n}\n\nint vidioc_s_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn vivid_s_fmt_vid_out(file, priv, f);\n}\n\nint vidioc_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn fmt_sp2mp_func(file, priv, f, vivid_g_fmt_vid_out);\n}\n\nint vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn fmt_sp2mp_func(file, priv, f, vivid_try_fmt_vid_out);\n}\n\nint vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (dev->multiplanar)\n\t\treturn -ENOTTY;\n\treturn fmt_sp2mp_func(file, priv, f, vivid_s_fmt_vid_out);\n}\n\nint vivid_vid_out_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!dev->has_crop_out && !dev->has_compose_out)\n\t\treturn -ENOTTY;\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tsel->r.left = sel->r.top = 0;\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (!dev->has_crop_out)\n\t\t\treturn -EINVAL;\n\t\tsel->r = dev->crop_out;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tif (!dev->has_crop_out)\n\t\t\treturn -EINVAL;\n\t\tsel->r = dev->fmt_out_rect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (!dev->has_crop_out)\n\t\t\treturn -EINVAL;\n\t\tsel->r = vivid_max_rect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (!dev->has_compose_out)\n\t\t\treturn -EINVAL;\n\t\tsel->r = dev->compose_out;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (!dev->has_compose_out)\n\t\t\treturn -EINVAL;\n\t\tsel->r = dev->sink_rect;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint vivid_vid_out_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_rect *crop = &dev->crop_out;\n\tstruct v4l2_rect *compose = &dev->compose_out;\n\tunsigned factor = V4L2_FIELD_HAS_T_OR_B(dev->field_out) ? 2 : 1;\n\tint ret;\n\n\tif (!dev->has_crop_out && !dev->has_compose_out)\n\t\treturn -ENOTTY;\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (!dev->has_crop_out)\n\t\t\treturn -EINVAL;\n\t\tret = vivid_vid_adjust_sel(s->flags, &s->r);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tv4l2_rect_set_min_size(&s->r, &vivid_min_rect);\n\t\tv4l2_rect_set_max_size(&s->r, &dev->fmt_out_rect);\n\t\tif (dev->has_scaler_out) {\n\t\t\tstruct v4l2_rect max_rect = {\n\t\t\t\t0, 0,\n\t\t\t\tdev->sink_rect.width * MAX_ZOOM,\n\t\t\t\t(dev->sink_rect.height / factor) * MAX_ZOOM\n\t\t\t};\n\n\t\t\tv4l2_rect_set_max_size(&s->r, &max_rect);\n\t\t\tif (dev->has_compose_out) {\n\t\t\t\tstruct v4l2_rect min_rect = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\ts->r.width / MAX_ZOOM,\n\t\t\t\t\t(s->r.height * factor) / MAX_ZOOM\n\t\t\t\t};\n\t\t\t\tstruct v4l2_rect max_rect = {\n\t\t\t\t\t0, 0,\n\t\t\t\t\ts->r.width * MAX_ZOOM,\n\t\t\t\t\t(s->r.height * factor) * MAX_ZOOM\n\t\t\t\t};\n\n\t\t\t\tv4l2_rect_set_min_size(compose, &min_rect);\n\t\t\t\tv4l2_rect_set_max_size(compose, &max_rect);\n\t\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t\t}\n\t\t} else if (dev->has_compose_out) {\n\t\t\ts->r.top *= factor;\n\t\t\ts->r.height *= factor;\n\t\t\tv4l2_rect_set_max_size(&s->r, &dev->sink_rect);\n\t\t\tv4l2_rect_set_size_to(compose, &s->r);\n\t\t\tv4l2_rect_map_inside(compose, &dev->compose_bounds_out);\n\t\t\ts->r.top /= factor;\n\t\t\ts->r.height /= factor;\n\t\t} else {\n\t\t\tv4l2_rect_set_size_to(&s->r, &dev->sink_rect);\n\t\t\ts->r.height /= factor;\n\t\t}\n\t\tv4l2_rect_map_inside(&s->r, &dev->fmt_out_rect);\n\t\t*crop = s->r;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (!dev->has_compose_out)\n\t\t\treturn -EINVAL;\n\t\tret = vivid_vid_adjust_sel(s->flags, &s->r);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tv4l2_rect_set_min_size(&s->r, &vivid_min_rect);\n\t\tv4l2_rect_set_max_size(&s->r, &dev->sink_rect);\n\t\tv4l2_rect_map_inside(&s->r, &dev->compose_bounds_out);\n\t\ts->r.top /= factor;\n\t\ts->r.height /= factor;\n\t\tif (dev->has_scaler_out) {\n\t\t\tstruct v4l2_rect fmt = dev->fmt_out_rect;\n\t\t\tstruct v4l2_rect max_rect = {\n\t\t\t\t0, 0,\n\t\t\t\ts->r.width * MAX_ZOOM,\n\t\t\t\ts->r.height * MAX_ZOOM\n\t\t\t};\n\t\t\tstruct v4l2_rect min_rect = {\n\t\t\t\t0, 0,\n\t\t\t\ts->r.width / MAX_ZOOM,\n\t\t\t\ts->r.height / MAX_ZOOM\n\t\t\t};\n\n\t\t\tv4l2_rect_set_min_size(&fmt, &min_rect);\n\t\t\tif (!dev->has_crop_out)\n\t\t\t\tv4l2_rect_set_max_size(&fmt, &max_rect);\n\t\t\tif (!v4l2_rect_same_size(&dev->fmt_out_rect, &fmt) &&\n\t\t\t    vb2_is_busy(&dev->vb_vid_out_q))\n\t\t\t\treturn -EBUSY;\n\t\t\tif (dev->has_crop_out) {\n\t\t\t\tv4l2_rect_set_min_size(crop, &min_rect);\n\t\t\t\tv4l2_rect_set_max_size(crop, &max_rect);\n\t\t\t}\n\t\t\tdev->fmt_out_rect = fmt;\n\t\t} else if (dev->has_crop_out) {\n\t\t\tstruct v4l2_rect fmt = dev->fmt_out_rect;\n\n\t\t\tv4l2_rect_set_min_size(&fmt, &s->r);\n\t\t\tif (!v4l2_rect_same_size(&dev->fmt_out_rect, &fmt) &&\n\t\t\t    vb2_is_busy(&dev->vb_vid_out_q))\n\t\t\t\treturn -EBUSY;\n\t\t\tdev->fmt_out_rect = fmt;\n\t\t\tv4l2_rect_set_size_to(crop, &s->r);\n\t\t\tv4l2_rect_map_inside(crop, &dev->fmt_out_rect);\n\t\t} else {\n\t\t\tif (!v4l2_rect_same_size(&s->r, &dev->fmt_out_rect) &&\n\t\t\t    vb2_is_busy(&dev->vb_vid_out_q))\n\t\t\t\treturn -EBUSY;\n\t\t\tv4l2_rect_set_size_to(&dev->fmt_out_rect, &s->r);\n\t\t\tv4l2_rect_set_size_to(crop, &s->r);\n\t\t\tcrop->height /= factor;\n\t\t\tv4l2_rect_map_inside(crop, &dev->fmt_out_rect);\n\t\t}\n\t\ts->r.top *= factor;\n\t\ts->r.height *= factor;\n\t\t*compose = s->r;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vivid_vid_out_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (vivid_get_pixel_aspect(dev)) {\n\tcase TPG_PIXEL_ASPECT_NTSC:\n\t\tf->numerator = 11;\n\t\tf->denominator = 10;\n\t\tbreak;\n\tcase TPG_PIXEL_ASPECT_PAL:\n\t\tf->numerator = 54;\n\t\tf->denominator = 59;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint vidioc_g_fmt_vid_out_overlay(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tconst struct v4l2_rect *compose = &dev->compose_out;\n\tstruct v4l2_window *win = &f->fmt.win;\n\n\tif (!dev->has_fb)\n\t\treturn -EINVAL;\n\twin->w.top = dev->overlay_out_top;\n\twin->w.left = dev->overlay_out_left;\n\twin->w.width = compose->width;\n\twin->w.height = compose->height;\n\twin->field = V4L2_FIELD_ANY;\n\twin->chromakey = dev->chromakey_out;\n\twin->global_alpha = dev->global_alpha_out;\n\treturn 0;\n}\n\nint vidioc_try_fmt_vid_out_overlay(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tconst struct v4l2_rect *compose = &dev->compose_out;\n\tstruct v4l2_window *win = &f->fmt.win;\n\n\tif (!dev->has_fb)\n\t\treturn -EINVAL;\n\twin->w.left = clamp_t(int, win->w.left,\n\t\t\t      -dev->display_width, dev->display_width);\n\twin->w.top = clamp_t(int, win->w.top,\n\t\t\t     -dev->display_height, dev->display_height);\n\twin->w.width = compose->width;\n\twin->w.height = compose->height;\n\t \n\twin->field = V4L2_FIELD_ANY;\n\treturn 0;\n}\n\nint vidioc_s_fmt_vid_out_overlay(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_window *win = &f->fmt.win;\n\tint ret = vidioc_try_fmt_vid_out_overlay(file, priv, f);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev->overlay_out_top = win->w.top;\n\tdev->overlay_out_left = win->w.left;\n\tdev->chromakey_out = win->chromakey;\n\tdev->global_alpha_out = win->global_alpha;\n\treturn ret;\n}\n\nint vivid_vid_out_overlay(struct file *file, void *fh, unsigned i)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (i && !dev->fmt_out->can_do_overlay) {\n\t\tdprintk(dev, 1, \"unsupported output format for output overlay\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev->overlay_out_enabled = i;\n\treturn 0;\n}\n\nint vivid_vid_out_g_fbuf(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_framebuffer *a)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\ta->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |\n\t\t\tV4L2_FBUF_CAP_CHROMAKEY |\n\t\t\tV4L2_FBUF_CAP_SRC_CHROMAKEY |\n\t\t\tV4L2_FBUF_CAP_GLOBAL_ALPHA |\n\t\t\tV4L2_FBUF_CAP_LOCAL_ALPHA |\n\t\t\tV4L2_FBUF_CAP_LOCAL_INV_ALPHA;\n\ta->flags = V4L2_FBUF_FLAG_OVERLAY | dev->fbuf_out_flags;\n\ta->base = (void *)dev->video_pbase;\n\ta->fmt.width = dev->display_width;\n\ta->fmt.height = dev->display_height;\n\tif (dev->fb_defined.green.length == 5)\n\t\ta->fmt.pixelformat = V4L2_PIX_FMT_ARGB555;\n\telse\n\t\ta->fmt.pixelformat = V4L2_PIX_FMT_RGB565;\n\ta->fmt.bytesperline = dev->display_byte_stride;\n\ta->fmt.sizeimage = a->fmt.height * a->fmt.bytesperline;\n\ta->fmt.field = V4L2_FIELD_NONE;\n\ta->fmt.colorspace = V4L2_COLORSPACE_SRGB;\n\ta->fmt.priv = 0;\n\treturn 0;\n}\n\nint vivid_vid_out_s_fbuf(struct file *file, void *fh,\n\t\t\t\tconst struct v4l2_framebuffer *a)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tconst unsigned chroma_flags = V4L2_FBUF_FLAG_CHROMAKEY |\n\t\t\t\t      V4L2_FBUF_FLAG_SRC_CHROMAKEY;\n\tconst unsigned alpha_flags = V4L2_FBUF_FLAG_GLOBAL_ALPHA |\n\t\t\t\t     V4L2_FBUF_FLAG_LOCAL_ALPHA |\n\t\t\t\t     V4L2_FBUF_FLAG_LOCAL_INV_ALPHA;\n\n\n\tif ((a->flags & chroma_flags) == chroma_flags)\n\t\treturn -EINVAL;\n\tswitch (a->flags & alpha_flags) {\n\tcase 0:\n\tcase V4L2_FBUF_FLAG_GLOBAL_ALPHA:\n\tcase V4L2_FBUF_FLAG_LOCAL_ALPHA:\n\tcase V4L2_FBUF_FLAG_LOCAL_INV_ALPHA:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdev->fbuf_out_flags &= ~(chroma_flags | alpha_flags);\n\tdev->fbuf_out_flags |= a->flags & (chroma_flags | alpha_flags);\n\treturn 0;\n}\n\nstatic const struct v4l2_audioout vivid_audio_outputs[] = {\n\t{ 0, \"Line-Out 1\" },\n\t{ 1, \"Line-Out 2\" },\n};\n\nint vidioc_enum_output(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_output *out)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (out->index >= dev->num_outputs)\n\t\treturn -EINVAL;\n\n\tout->type = V4L2_OUTPUT_TYPE_ANALOG;\n\tswitch (dev->output_type[out->index]) {\n\tcase SVID:\n\t\tsnprintf(out->name, sizeof(out->name), \"S-Video %u\",\n\t\t\t\tdev->output_name_counter[out->index]);\n\t\tout->std = V4L2_STD_ALL;\n\t\tif (dev->has_audio_outputs)\n\t\t\tout->audioset = (1 << ARRAY_SIZE(vivid_audio_outputs)) - 1;\n\t\tout->capabilities = V4L2_OUT_CAP_STD;\n\t\tbreak;\n\tcase HDMI:\n\t\tsnprintf(out->name, sizeof(out->name), \"HDMI %u\",\n\t\t\t\tdev->output_name_counter[out->index]);\n\t\tout->capabilities = V4L2_OUT_CAP_DV_TIMINGS;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint vidioc_g_output(struct file *file, void *priv, unsigned *o)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\t*o = dev->output;\n\treturn 0;\n}\n\nint vidioc_s_output(struct file *file, void *priv, unsigned o)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (o >= dev->num_outputs)\n\t\treturn -EINVAL;\n\n\tif (o == dev->output)\n\t\treturn 0;\n\n\tif (vb2_is_busy(&dev->vb_vid_out_q) ||\n\t    vb2_is_busy(&dev->vb_vbi_out_q) ||\n\t    vb2_is_busy(&dev->vb_meta_out_q))\n\t\treturn -EBUSY;\n\n\tdev->output = o;\n\tdev->tv_audio_output = 0;\n\tif (dev->output_type[o] == SVID)\n\t\tdev->vid_out_dev.tvnorms = V4L2_STD_ALL;\n\telse\n\t\tdev->vid_out_dev.tvnorms = 0;\n\n\tdev->vbi_out_dev.tvnorms = dev->vid_out_dev.tvnorms;\n\tdev->meta_out_dev.tvnorms = dev->vid_out_dev.tvnorms;\n\tvivid_update_format_out(dev);\n\n\tv4l2_ctrl_activate(dev->ctrl_display_present, vivid_is_hdmi_out(dev));\n\tif (vivid_is_hdmi_out(dev))\n\t\tv4l2_ctrl_s_ctrl(dev->ctrl_display_present,\n\t\t\t\t dev->display_present[dev->output]);\n\n\treturn 0;\n}\n\nint vidioc_enumaudout(struct file *file, void *fh, struct v4l2_audioout *vout)\n{\n\tif (vout->index >= ARRAY_SIZE(vivid_audio_outputs))\n\t\treturn -EINVAL;\n\t*vout = vivid_audio_outputs[vout->index];\n\treturn 0;\n}\n\nint vidioc_g_audout(struct file *file, void *fh, struct v4l2_audioout *vout)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!vivid_is_svid_out(dev))\n\t\treturn -EINVAL;\n\t*vout = vivid_audio_outputs[dev->tv_audio_output];\n\treturn 0;\n}\n\nint vidioc_s_audout(struct file *file, void *fh, const struct v4l2_audioout *vout)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!vivid_is_svid_out(dev))\n\t\treturn -EINVAL;\n\tif (vout->index >= ARRAY_SIZE(vivid_audio_outputs))\n\t\treturn -EINVAL;\n\tdev->tv_audio_output = vout->index;\n\treturn 0;\n}\n\nint vivid_vid_out_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!vivid_is_svid_out(dev))\n\t\treturn -ENODATA;\n\tif (dev->std_out == id)\n\t\treturn 0;\n\tif (vb2_is_busy(&dev->vb_vid_out_q) || vb2_is_busy(&dev->vb_vbi_out_q))\n\t\treturn -EBUSY;\n\tdev->std_out = id;\n\tvivid_update_format_out(dev);\n\treturn 0;\n}\n\nstatic bool valid_cvt_gtf_timings(struct v4l2_dv_timings *timings)\n{\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\n\tif ((bt->standards & (V4L2_DV_BT_STD_CVT | V4L2_DV_BT_STD_GTF)) &&\n\t    v4l2_valid_dv_timings(timings, &vivid_dv_timings_cap, NULL, NULL))\n\t\treturn true;\n\n\treturn false;\n}\n\nint vivid_vid_out_s_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tif (!vivid_is_hdmi_out(dev))\n\t\treturn -ENODATA;\n\tif (!v4l2_find_dv_timings_cap(timings, &vivid_dv_timings_cap,\n\t\t\t\t0, NULL, NULL) &&\n\t    !valid_cvt_gtf_timings(timings))\n\t\treturn -EINVAL;\n\tif (v4l2_match_dv_timings(timings, &dev->dv_timings_out, 0, true))\n\t\treturn 0;\n\tif (vb2_is_busy(&dev->vb_vid_out_q))\n\t\treturn -EBUSY;\n\tdev->dv_timings_out = *timings;\n\tvivid_update_format_out(dev);\n\treturn 0;\n}\n\nint vivid_vid_out_g_parm(struct file *file, void *priv,\n\t\t\t  struct v4l2_streamparm *parm)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (parm->type != (dev->multiplanar ?\n\t\t\t   V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :\n\t\t\t   V4L2_BUF_TYPE_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tparm->parm.output.capability   = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.output.timeperframe = dev->timeperframe_vid_out;\n\tparm->parm.output.writebuffers  = 1;\n\n\treturn 0;\n}\n\nint vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\tif (fh->vdev->vfl_dir == VFL_DIR_RX)\n\t\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\t\tbreak;\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}