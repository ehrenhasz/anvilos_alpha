{
  "module_name": "vivid-meta-cap.c",
  "hash_id": "c99e5d498a89bae0ab290f65c27e2ef292d914a28f6f115809a89c6733c268e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/test-drivers/vivid/vivid-meta-cap.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <linux/usb/video.h>\n\n#include \"vivid-core.h\"\n#include \"vivid-kthread-cap.h\"\n#include \"vivid-meta-cap.h\"\n\nstatic int meta_cap_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\tunsigned int *nplanes, unsigned int sizes[],\n\t\t\t\tstruct device *alloc_devs[])\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tunsigned int size =  sizeof(struct vivid_uvc_meta_buf);\n\n\tif (!vivid_is_webcam(dev))\n\t\treturn -EINVAL;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsizes[0] = size;\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\n\t*nplanes = 1;\n\treturn 0;\n}\n\nstatic int meta_cap_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int size = sizeof(struct vivid_uvc_meta_buf);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tif (dev->buf_prepare_error) {\n\t\t \n\t\tdev->buf_prepare_error = false;\n\t\treturn -EINVAL;\n\t}\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(dev, 1, \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void meta_cap_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\n\tspin_lock(&dev->slock);\n\tlist_add_tail(&buf->list, &dev->meta_cap_active);\n\tspin_unlock(&dev->slock);\n}\n\nstatic int meta_cap_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\tint err;\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tdev->meta_cap_seq_count = 0;\n\tif (dev->start_streaming_error) {\n\t\tdev->start_streaming_error = false;\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = vivid_start_generating_vid_cap(dev,\n\t\t\t\t\t\t     &dev->meta_cap_streaming);\n\t}\n\tif (err) {\n\t\tstruct vivid_buffer *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp,\n\t\t\t\t\t &dev->meta_cap_active, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void meta_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tdprintk(dev, 1, \"%s\\n\", __func__);\n\tvivid_stop_generating_vid_cap(dev, &dev->meta_cap_streaming);\n}\n\nstatic void meta_cap_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &dev->ctrl_hdl_meta_cap);\n}\n\nconst struct vb2_ops vivid_meta_cap_qops = {\n\t.queue_setup\t\t= meta_cap_queue_setup,\n\t.buf_prepare\t\t= meta_cap_buf_prepare,\n\t.buf_queue\t\t= meta_cap_buf_queue,\n\t.start_streaming\t= meta_cap_start_streaming,\n\t.stop_streaming\t\t= meta_cap_stop_streaming,\n\t.buf_request_complete\t= meta_cap_buf_request_complete,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint vidioc_enum_fmt_meta_cap(struct file *file, void  *priv,\n\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\n\tif (!vivid_is_webcam(dev))\n\t\treturn -EINVAL;\n\n\tif (f->index > 0)\n\t\treturn -EINVAL;\n\n\tf->type = V4L2_BUF_TYPE_META_CAPTURE;\n\tf->pixelformat = V4L2_META_FMT_UVC;\n\treturn 0;\n}\n\nint vidioc_g_fmt_meta_cap(struct file *file, void *priv,\n\t\t\t  struct v4l2_format *f)\n{\n\tstruct vivid_dev *dev = video_drvdata(file);\n\tstruct v4l2_meta_format *meta = &f->fmt.meta;\n\n\tif (!vivid_is_webcam(dev) || !dev->has_meta_cap)\n\t\treturn -EINVAL;\n\n\tmeta->dataformat = V4L2_META_FMT_UVC;\n\tmeta->buffersize = sizeof(struct vivid_uvc_meta_buf);\n\treturn 0;\n}\n\nvoid vivid_meta_cap_fillbuff(struct vivid_dev *dev,\n\t\t\t     struct vivid_buffer *buf, u64 soe)\n{\n\tstruct vivid_uvc_meta_buf *meta = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tint buf_off = 0;\n\n\tbuf->vb.sequence = dev->meta_cap_seq_count;\n\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\tbuf->vb.sequence /= 2;\n\tmemset(meta, 1, vb2_plane_size(&buf->vb.vb2_buf, 0));\n\n\tmeta->ns = ktime_get_ns();\n\tmeta->sof = buf->vb.sequence * 30;\n\tmeta->length = sizeof(*meta) - offsetof(struct vivid_uvc_meta_buf, length);\n\tmeta->flags = UVC_STREAM_EOH | UVC_STREAM_EOF;\n\n\tif ((buf->vb.sequence % 2) == 0)\n\t\tmeta->flags |= UVC_STREAM_FID;\n\n\tdprintk(dev, 2, \"%s ns:%llu sof:%4d len:%u flags: 0x%02x\",\n\t\t__func__, meta->ns, meta->sof, meta->length, meta->flags);\n\tif (dev->meta_pts) {\n\t\tmeta->flags |= UVC_STREAM_PTS;\n\t\tmeta->buf[0] = div_u64(soe, VIVID_META_CLOCK_UNIT);\n\t\tbuf_off = 4;\n\t\tdprintk(dev, 2, \" pts: %u\\n\", *(__u32 *)(meta->buf));\n\t}\n\n\tif (dev->meta_scr) {\n\t\tmeta->flags |= UVC_STREAM_SCR;\n\t\tmeta->buf[buf_off] = div_u64((soe + dev->cap_frame_eof_offset),\n\t\t\t\t\t     VIVID_META_CLOCK_UNIT);\n\n\t\tmeta->buf[buf_off + 4] = (buf->vb.sequence * 30) % 1000;\n\t\tdprintk(dev, 2, \" stc: %u, sof counter: %u\\n\",\n\t\t\t*(__u32 *)(meta->buf + buf_off),\n\t\t\t*(__u16 *)(meta->buf + buf_off + 4));\n\t}\n\tdprintk(dev, 2, \"\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}