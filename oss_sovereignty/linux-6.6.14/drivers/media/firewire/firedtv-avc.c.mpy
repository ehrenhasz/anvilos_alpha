{
  "module_name": "firedtv-avc.c",
  "hash_id": "77516ec5c9279934d5f8b1d9762674bdf9e79fe03ffdec7c89052550d6ee5c77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/firewire/firedtv-avc.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/stringify.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"firedtv.h\"\n\n#define FCP_COMMAND_REGISTER\t\t0xfffff0000b00ULL\n\n#define AVC_CTYPE_CONTROL\t\t0x0\n#define AVC_CTYPE_STATUS\t\t0x1\n#define AVC_CTYPE_NOTIFY\t\t0x3\n\n#define AVC_RESPONSE_ACCEPTED\t\t0x9\n#define AVC_RESPONSE_STABLE\t\t0xc\n#define AVC_RESPONSE_CHANGED\t\t0xd\n#define AVC_RESPONSE_INTERIM\t\t0xf\n\n#define AVC_SUBUNIT_TYPE_TUNER\t\t(0x05 << 3)\n#define AVC_SUBUNIT_TYPE_UNIT\t\t(0x1f << 3)\n\n#define AVC_OPCODE_VENDOR\t\t0x00\n#define AVC_OPCODE_READ_DESCRIPTOR\t0x09\n#define AVC_OPCODE_DSIT\t\t\t0xc8\n#define AVC_OPCODE_DSD\t\t\t0xcb\n\n#define DESCRIPTOR_TUNER_STATUS\t\t0x80\n#define DESCRIPTOR_SUBUNIT_IDENTIFIER\t0x00\n\n#define SFE_VENDOR_DE_COMPANYID_0\t0x00  \n#define SFE_VENDOR_DE_COMPANYID_1\t0x12\n#define SFE_VENDOR_DE_COMPANYID_2\t0x87\n\n#define SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL 0x0a\n#define SFE_VENDOR_OPCODE_LNB_CONTROL\t\t0x52\n#define SFE_VENDOR_OPCODE_TUNE_QPSK\t\t0x58  \n\n#define SFE_VENDOR_OPCODE_GET_FIRMWARE_VERSION\t0x00\n#define SFE_VENDOR_OPCODE_HOST2CA\t\t0x56\n#define SFE_VENDOR_OPCODE_CA2HOST\t\t0x57\n#define SFE_VENDOR_OPCODE_CISTATUS\t\t0x59\n#define SFE_VENDOR_OPCODE_TUNE_QPSK2\t\t0x60  \n\n#define SFE_VENDOR_TAG_CA_RESET\t\t\t0x00\n#define SFE_VENDOR_TAG_CA_APPLICATION_INFO\t0x01\n#define SFE_VENDOR_TAG_CA_PMT\t\t\t0x02\n#define SFE_VENDOR_TAG_CA_DATE_TIME\t\t0x04\n#define SFE_VENDOR_TAG_CA_MMI\t\t\t0x05\n#define SFE_VENDOR_TAG_CA_ENTER_MENU\t\t0x07\n\n#define EN50221_LIST_MANAGEMENT_ONLY\t0x03\n#define EN50221_TAG_APP_INFO\t\t0x9f8021\n#define EN50221_TAG_CA_INFO\t\t0x9f8031\n\nstruct avc_command_frame {\n\tu8 ctype;\n\tu8 subunit;\n\tu8 opcode;\n\tu8 operand[509];\n};\n\nstruct avc_response_frame {\n\tu8 response;\n\tu8 subunit;\n\tu8 opcode;\n\tu8 operand[509];\n};\n\n#define LAST_OPERAND (509 - 1)\n\nstatic inline void clear_operands(struct avc_command_frame *c, int from, int to)\n{\n\tmemset(&c->operand[from], 0, to - from + 1);\n}\n\nstatic void pad_operands(struct avc_command_frame *c, int from)\n{\n\tint to = ALIGN(from, 4);\n\n\tif (from <= to && to <= LAST_OPERAND)\n\t\tclear_operands(c, from, to);\n}\n\n#define AVC_DEBUG_READ_DESCRIPTOR              0x0001\n#define AVC_DEBUG_DSIT                         0x0002\n#define AVC_DEBUG_DSD                          0x0004\n#define AVC_DEBUG_REGISTER_REMOTE_CONTROL      0x0008\n#define AVC_DEBUG_LNB_CONTROL                  0x0010\n#define AVC_DEBUG_TUNE_QPSK                    0x0020\n#define AVC_DEBUG_TUNE_QPSK2                   0x0040\n#define AVC_DEBUG_HOST2CA                      0x0080\n#define AVC_DEBUG_CA2HOST                      0x0100\n#define AVC_DEBUG_APPLICATION_PMT              0x4000\n#define AVC_DEBUG_FCP_PAYLOADS                 0x8000\n\nstatic int avc_debug;\nmodule_param_named(debug, avc_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Verbose logging (none = 0\"\n\t\", FCP subactions\"\n\t\": READ DESCRIPTOR = \"\t\t__stringify(AVC_DEBUG_READ_DESCRIPTOR)\n\t\", DSIT = \"\t\t\t__stringify(AVC_DEBUG_DSIT)\n\t\", REGISTER_REMOTE_CONTROL = \"\t__stringify(AVC_DEBUG_REGISTER_REMOTE_CONTROL)\n\t\", LNB CONTROL = \"\t\t__stringify(AVC_DEBUG_LNB_CONTROL)\n\t\", TUNE QPSK = \"\t\t__stringify(AVC_DEBUG_TUNE_QPSK)\n\t\", TUNE QPSK2 = \"\t\t__stringify(AVC_DEBUG_TUNE_QPSK2)\n\t\", HOST2CA = \"\t\t\t__stringify(AVC_DEBUG_HOST2CA)\n\t\", CA2HOST = \"\t\t\t__stringify(AVC_DEBUG_CA2HOST)\n\t\"; Application sent PMT = \"\t__stringify(AVC_DEBUG_APPLICATION_PMT)\n\t\", FCP payloads = \"\t\t__stringify(AVC_DEBUG_FCP_PAYLOADS)\n\t\", or a combination, or all = -1)\");\n\n \nstatic unsigned int num_fake_ca_system_ids;\nstatic int fake_ca_system_ids[4] = { -1, -1, -1, -1 };\nmodule_param_array(fake_ca_system_ids, int, &num_fake_ca_system_ids, 0644);\nMODULE_PARM_DESC(fake_ca_system_ids, \"If your CAM application manufacturer \"\n\t\t \"does not have the same ca_system_id as your CAS, you can \"\n\t\t \"override what ca_system_ids are presented to the \"\n\t\t \"application by setting this field to an array of ids.\");\n\nstatic const char *debug_fcp_ctype(unsigned int ctype)\n{\n\tstatic const char *ctypes[] = {\n\t\t[0x0] = \"CONTROL\",\t\t[0x1] = \"STATUS\",\n\t\t[0x2] = \"SPECIFIC INQUIRY\",\t[0x3] = \"NOTIFY\",\n\t\t[0x4] = \"GENERAL INQUIRY\",\t[0x8] = \"NOT IMPLEMENTED\",\n\t\t[0x9] = \"ACCEPTED\",\t\t[0xa] = \"REJECTED\",\n\t\t[0xb] = \"IN TRANSITION\",\t[0xc] = \"IMPLEMENTED/STABLE\",\n\t\t[0xd] = \"CHANGED\",\t\t[0xf] = \"INTERIM\",\n\t};\n\tconst char *ret = ctype < ARRAY_SIZE(ctypes) ? ctypes[ctype] : NULL;\n\n\treturn ret ? ret : \"?\";\n}\n\nstatic const char *debug_fcp_opcode(unsigned int opcode,\n\t\t\t\t    const u8 *data, int length)\n{\n\tswitch (opcode) {\n\tcase AVC_OPCODE_VENDOR:\n\t\tbreak;\n\tcase AVC_OPCODE_READ_DESCRIPTOR:\n\t\treturn avc_debug & AVC_DEBUG_READ_DESCRIPTOR ?\n\t\t\t\t\"ReadDescriptor\" : NULL;\n\tcase AVC_OPCODE_DSIT:\n\t\treturn avc_debug & AVC_DEBUG_DSIT ?\n\t\t\t\t\"DirectSelectInfo.Type\" : NULL;\n\tcase AVC_OPCODE_DSD:\n\t\treturn avc_debug & AVC_DEBUG_DSD ? \"DirectSelectData\" : NULL;\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n\n\tif (length < 7 ||\n\t    data[3] != SFE_VENDOR_DE_COMPANYID_0 ||\n\t    data[4] != SFE_VENDOR_DE_COMPANYID_1 ||\n\t    data[5] != SFE_VENDOR_DE_COMPANYID_2)\n\t\treturn \"Vendor/Unknown\";\n\n\tswitch (data[6]) {\n\tcase SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL:\n\t\treturn avc_debug & AVC_DEBUG_REGISTER_REMOTE_CONTROL ?\n\t\t\t\t\"RegisterRC\" : NULL;\n\tcase SFE_VENDOR_OPCODE_LNB_CONTROL:\n\t\treturn avc_debug & AVC_DEBUG_LNB_CONTROL ? \"LNBControl\" : NULL;\n\tcase SFE_VENDOR_OPCODE_TUNE_QPSK:\n\t\treturn avc_debug & AVC_DEBUG_TUNE_QPSK ? \"TuneQPSK\" : NULL;\n\tcase SFE_VENDOR_OPCODE_TUNE_QPSK2:\n\t\treturn avc_debug & AVC_DEBUG_TUNE_QPSK2 ? \"TuneQPSK2\" : NULL;\n\tcase SFE_VENDOR_OPCODE_HOST2CA:\n\t\treturn avc_debug & AVC_DEBUG_HOST2CA ? \"Host2CA\" : NULL;\n\tcase SFE_VENDOR_OPCODE_CA2HOST:\n\t\treturn avc_debug & AVC_DEBUG_CA2HOST ? \"CA2Host\" : NULL;\n\t}\n\treturn \"Vendor/Unknown\";\n}\n\nstatic void debug_fcp(const u8 *data, int length)\n{\n\tunsigned int subunit_type, subunit_id, opcode;\n\tconst char *op, *prefix;\n\n\tprefix       = data[0] > 7 ? \"FCP <- \" : \"FCP -> \";\n\tsubunit_type = data[1] >> 3;\n\tsubunit_id   = data[1] & 7;\n\topcode       = subunit_type == 0x1e || subunit_id == 5 ? ~0 : data[2];\n\top           = debug_fcp_opcode(opcode, data, length);\n\n\tif (op) {\n\t\tprintk(KERN_INFO \"%ssu=%x.%x l=%d: %-8s - %s\\n\",\n\t\t       prefix, subunit_type, subunit_id, length,\n\t\t       debug_fcp_ctype(data[0]), op);\n\t\tif (avc_debug & AVC_DEBUG_FCP_PAYLOADS)\n\t\t\tprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_NONE,\n\t\t\t\t       16, 1, data, length, false);\n\t}\n}\n\nstatic void debug_pmt(char *msg, int length)\n{\n\tprintk(KERN_INFO \"APP PMT -> l=%d\\n\", length);\n\tprint_hex_dump(KERN_INFO, \"APP PMT -> \", DUMP_PREFIX_NONE,\n\t\t       16, 1, msg, length, false);\n}\n\nstatic int avc_write(struct firedtv *fdtv)\n{\n\tint err, retry;\n\n\tfdtv->avc_reply_received = false;\n\n\tfor (retry = 0; retry < 6; retry++) {\n\t\tif (unlikely(avc_debug))\n\t\t\tdebug_fcp(fdtv->avc_data, fdtv->avc_data_length);\n\n\t\terr = fdtv_write(fdtv, FCP_COMMAND_REGISTER,\n\t\t\t\t fdtv->avc_data, fdtv->avc_data_length);\n\t\tif (err) {\n\t\t\tdev_err(fdtv->device, \"FCP command write failed\\n\");\n\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (wait_event_timeout(fdtv->avc_wait,\n\t\t\t\t       fdtv->avc_reply_received,\n\t\t\t\t       msecs_to_jiffies(200)) != 0)\n\t\t\treturn 0;\n\t}\n\tdev_err(fdtv->device, \"FCP response timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic bool is_register_rc(struct avc_response_frame *r)\n{\n\treturn r->opcode     == AVC_OPCODE_VENDOR &&\n\t       r->operand[0] == SFE_VENDOR_DE_COMPANYID_0 &&\n\t       r->operand[1] == SFE_VENDOR_DE_COMPANYID_1 &&\n\t       r->operand[2] == SFE_VENDOR_DE_COMPANYID_2 &&\n\t       r->operand[3] == SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL;\n}\n\nint avc_recv(struct firedtv *fdtv, void *data, size_t length)\n{\n\tstruct avc_response_frame *r = data;\n\n\tif (unlikely(avc_debug))\n\t\tdebug_fcp(data, length);\n\n\tif (length >= 8 && is_register_rc(r)) {\n\t\tswitch (r->response) {\n\t\tcase AVC_RESPONSE_CHANGED:\n\t\t\tfdtv_handle_rc(fdtv, r->operand[4] << 8 | r->operand[5]);\n\t\t\tschedule_work(&fdtv->remote_ctrl_work);\n\t\t\tbreak;\n\t\tcase AVC_RESPONSE_INTERIM:\n\t\t\tif (is_register_rc((void *)fdtv->avc_data))\n\t\t\t\tgoto wake;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(fdtv->device,\n\t\t\t\t \"remote control result = %d\\n\", r->response);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (fdtv->avc_reply_received) {\n\t\tdev_err(fdtv->device, \"out-of-order AVC response, ignored\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(fdtv->avc_data, data, length);\n\tfdtv->avc_data_length = length;\nwake:\n\tfdtv->avc_reply_received = true;\n\twake_up(&fdtv->avc_wait);\n\n\treturn 0;\n}\n\nstatic int add_pid_filter(struct firedtv *fdtv, u8 *operand)\n{\n\tint i, n, pos = 1;\n\n\tfor (i = 0, n = 0; i < 16; i++) {\n\t\tif (test_bit(i, &fdtv->channel_active)) {\n\t\t\toperand[pos++] = 0x13;  \n\t\t\toperand[pos++] = 0x80;  \n\t\t\toperand[pos++] = (fdtv->channel_pid[i] >> 8) & 0x1f;\n\t\t\toperand[pos++] = fdtv->channel_pid[i] & 0xff;\n\t\t\toperand[pos++] = 0x00;  \n\t\t\toperand[pos++] = 0x00;  \n\t\t\tn++;\n\t\t}\n\t}\n\toperand[0] = n;\n\n\treturn pos;\n}\n\n \nstatic int avc_tuner_tuneqpsk(struct firedtv *fdtv,\n\t\t\t      struct dtv_frontend_properties *p)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\n\tc->opcode = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tif (fdtv->type == FIREDTV_DVB_S2)\n\t\tc->operand[3] = SFE_VENDOR_OPCODE_TUNE_QPSK2;\n\telse\n\t\tc->operand[3] = SFE_VENDOR_OPCODE_TUNE_QPSK;\n\n\tc->operand[4] = (p->frequency >> 24) & 0xff;\n\tc->operand[5] = (p->frequency >> 16) & 0xff;\n\tc->operand[6] = (p->frequency >> 8) & 0xff;\n\tc->operand[7] = p->frequency & 0xff;\n\n\tc->operand[8] = ((p->symbol_rate / 1000) >> 8) & 0xff;\n\tc->operand[9] = (p->symbol_rate / 1000) & 0xff;\n\n\tswitch (p->fec_inner) {\n\tcase FEC_1_2:\tc->operand[10] = 0x1; break;\n\tcase FEC_2_3:\tc->operand[10] = 0x2; break;\n\tcase FEC_3_4:\tc->operand[10] = 0x3; break;\n\tcase FEC_5_6:\tc->operand[10] = 0x4; break;\n\tcase FEC_7_8:\tc->operand[10] = 0x5; break;\n\tcase FEC_4_5:\n\tcase FEC_8_9:\n\tcase FEC_AUTO:\n\tdefault:\tc->operand[10] = 0x0;\n\t}\n\n\tif (fdtv->voltage == 0xff)\n\t\tc->operand[11] = 0xff;\n\telse if (fdtv->voltage == SEC_VOLTAGE_18)  \n\t\tc->operand[11] = 0;\n\telse\n\t\tc->operand[11] = 1;\n\n\tif (fdtv->tone == 0xff)\n\t\tc->operand[12] = 0xff;\n\telse if (fdtv->tone == SEC_TONE_ON)  \n\t\tc->operand[12] = 1;\n\telse\n\t\tc->operand[12] = 0;\n\n\tif (fdtv->type == FIREDTV_DVB_S2) {\n\t\tif (fdtv->fe.dtv_property_cache.delivery_system == SYS_DVBS2) {\n\t\t\tswitch (fdtv->fe.dtv_property_cache.modulation) {\n\t\t\tcase QAM_16:\t\tc->operand[13] = 0x1; break;\n\t\t\tcase QPSK:\t\tc->operand[13] = 0x2; break;\n\t\t\tcase PSK_8:\t\tc->operand[13] = 0x3; break;\n\t\t\tdefault:\t\tc->operand[13] = 0x2; break;\n\t\t\t}\n\t\t\tswitch (fdtv->fe.dtv_property_cache.rolloff) {\n\t\t\tcase ROLLOFF_35:\tc->operand[14] = 0x2; break;\n\t\t\tcase ROLLOFF_20:\tc->operand[14] = 0x0; break;\n\t\t\tcase ROLLOFF_25:\tc->operand[14] = 0x1; break;\n\t\t\tcase ROLLOFF_AUTO:\n\t\t\tdefault:\t\tc->operand[14] = 0x2; break;\n\t\t\t \n\t\t\t}\n\t\t\tswitch (fdtv->fe.dtv_property_cache.pilot) {\n\t\t\tcase PILOT_AUTO:\tc->operand[15] = 0x0; break;\n\t\t\tcase PILOT_OFF:\t\tc->operand[15] = 0x0; break;\n\t\t\tcase PILOT_ON:\t\tc->operand[15] = 0x1; break;\n\t\t\t}\n\t\t} else {\n\t\t\tc->operand[13] = 0x1;   \n\t\t\tc->operand[14] = 0xff;  \n\t\t\tc->operand[15] = 0xff;  \n\t\t}\n\t\treturn 16;\n\t} else {\n\t\treturn 13;\n\t}\n}\n\nstatic int avc_tuner_dsd_dvb_c(struct firedtv *fdtv,\n\t\t\t       struct dtv_frontend_properties *p)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\n\tc->opcode = AVC_OPCODE_DSD;\n\n\tc->operand[0] = 0;     \n\tc->operand[1] = 0xd2;  \n\tc->operand[2] = 0x20;  \n\tc->operand[3] = 0x00;  \n\tc->operand[4] = 0x11;  \n\n\t \n\tc->operand[5] =   0 << 7  \n\t\t\t| 0 << 6  \n\t\t\t| 0 << 5  \n\t\t\t| 1 << 4  \n\t\t\t| 1 << 3  \n\t\t\t| 0 << 2  \n\t\t\t| (p->fec_inner  != FEC_AUTO ? 1 << 1 : 0)\n\t\t\t| (p->modulation != QAM_AUTO ? 1 << 0 : 0);\n\n\t \n\tc->operand[6] =   0 << 7  \n\t\t\t| 0 << 0   ;\n\n\tc->operand[7]  = 0x00;\n\tc->operand[8]  = 0x00;\n\tc->operand[9]  = 0x00;\n\tc->operand[10] = 0x00;\n\n\tc->operand[11] = (((p->frequency / 4000) >> 16) & 0xff) | (2 << 6);\n\tc->operand[12] = ((p->frequency / 4000) >> 8) & 0xff;\n\tc->operand[13] = (p->frequency / 4000) & 0xff;\n\tc->operand[14] = ((p->symbol_rate / 1000) >> 12) & 0xff;\n\tc->operand[15] = ((p->symbol_rate / 1000) >> 4) & 0xff;\n\tc->operand[16] = ((p->symbol_rate / 1000) << 4) & 0xf0;\n\tc->operand[17] = 0x00;\n\n\tswitch (p->fec_inner) {\n\tcase FEC_1_2:\tc->operand[18] = 0x1; break;\n\tcase FEC_2_3:\tc->operand[18] = 0x2; break;\n\tcase FEC_3_4:\tc->operand[18] = 0x3; break;\n\tcase FEC_5_6:\tc->operand[18] = 0x4; break;\n\tcase FEC_7_8:\tc->operand[18] = 0x5; break;\n\tcase FEC_8_9:\tc->operand[18] = 0x6; break;\n\tcase FEC_4_5:\tc->operand[18] = 0x8; break;\n\tcase FEC_AUTO:\n\tdefault:\tc->operand[18] = 0x0;\n\t}\n\n\tswitch (p->modulation) {\n\tcase QAM_16:\tc->operand[19] = 0x08; break;\n\tcase QAM_32:\tc->operand[19] = 0x10; break;\n\tcase QAM_64:\tc->operand[19] = 0x18; break;\n\tcase QAM_128:\tc->operand[19] = 0x20; break;\n\tcase QAM_256:\tc->operand[19] = 0x28; break;\n\tcase QAM_AUTO:\n\tdefault:\tc->operand[19] = 0x00;\n\t}\n\n\tc->operand[20] = 0x00;\n\tc->operand[21] = 0x00;\n\n\treturn 22 + add_pid_filter(fdtv, &c->operand[22]);\n}\n\nstatic int avc_tuner_dsd_dvb_t(struct firedtv *fdtv,\n\t\t\t       struct dtv_frontend_properties *p)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\n\tc->opcode = AVC_OPCODE_DSD;\n\n\tc->operand[0] = 0;     \n\tc->operand[1] = 0xd2;  \n\tc->operand[2] = 0x20;  \n\tc->operand[3] = 0x00;  \n\tc->operand[4] = 0x0c;  \n\n\t \n\tc->operand[5] =\n\t      0 << 7  \n\t    | 1 << 6  \n\t    | (p->bandwidth_hz != 0        ? 1 << 5 : 0)\n\t    | (p->modulation  != QAM_AUTO              ? 1 << 4 : 0)\n\t    | (p->hierarchy != HIERARCHY_AUTO ? 1 << 3 : 0)\n\t    | (p->code_rate_HP   != FEC_AUTO              ? 1 << 2 : 0)\n\t    | (p->code_rate_LP   != FEC_AUTO              ? 1 << 1 : 0)\n\t    | (p->guard_interval != GUARD_INTERVAL_AUTO   ? 1 << 0 : 0);\n\n\t \n\tc->operand[6] =\n\t      0 << 7  \n\t    | (p->transmission_mode != TRANSMISSION_MODE_AUTO ? 1 << 6 : 0)\n\t    | 0 << 5  \n\t    | 0 << 0   ;\n\n\tc->operand[7]  = 0x0;\n\tc->operand[8]  = (p->frequency / 10) >> 24;\n\tc->operand[9]  = ((p->frequency / 10) >> 16) & 0xff;\n\tc->operand[10] = ((p->frequency / 10) >>  8) & 0xff;\n\tc->operand[11] = (p->frequency / 10) & 0xff;\n\n\tswitch (p->bandwidth_hz) {\n\tcase 7000000:\tc->operand[12] = 0x20; break;\n\tcase 8000000:\n\tcase 6000000:\t \n\tcase 0:\n\tdefault:\t\tc->operand[12] = 0x00;\n\t}\n\n\tswitch (p->modulation) {\n\tcase QAM_16:\tc->operand[13] = 1 << 6; break;\n\tcase QAM_64:\tc->operand[13] = 2 << 6; break;\n\tcase QPSK:\n\tdefault:\tc->operand[13] = 0x00;\n\t}\n\n\tswitch (p->hierarchy) {\n\tcase HIERARCHY_1:\tc->operand[13] |= 1 << 3; break;\n\tcase HIERARCHY_2:\tc->operand[13] |= 2 << 3; break;\n\tcase HIERARCHY_4:\tc->operand[13] |= 3 << 3; break;\n\tcase HIERARCHY_AUTO:\n\tcase HIERARCHY_NONE:\n\tdefault:\t\tbreak;\n\t}\n\n\tswitch (p->code_rate_HP) {\n\tcase FEC_2_3:\tc->operand[13] |= 1; break;\n\tcase FEC_3_4:\tc->operand[13] |= 2; break;\n\tcase FEC_5_6:\tc->operand[13] |= 3; break;\n\tcase FEC_7_8:\tc->operand[13] |= 4; break;\n\tcase FEC_1_2:\n\tdefault:\tbreak;\n\t}\n\n\tswitch (p->code_rate_LP) {\n\tcase FEC_2_3:\tc->operand[14] = 1 << 5; break;\n\tcase FEC_3_4:\tc->operand[14] = 2 << 5; break;\n\tcase FEC_5_6:\tc->operand[14] = 3 << 5; break;\n\tcase FEC_7_8:\tc->operand[14] = 4 << 5; break;\n\tcase FEC_1_2:\n\tdefault:\tc->operand[14] = 0x00; break;\n\t}\n\n\tswitch (p->guard_interval) {\n\tcase GUARD_INTERVAL_1_16:\tc->operand[14] |= 1 << 3; break;\n\tcase GUARD_INTERVAL_1_8:\tc->operand[14] |= 2 << 3; break;\n\tcase GUARD_INTERVAL_1_4:\tc->operand[14] |= 3 << 3; break;\n\tcase GUARD_INTERVAL_1_32:\n\tcase GUARD_INTERVAL_AUTO:\n\tdefault:\t\t\tbreak;\n\t}\n\n\tswitch (p->transmission_mode) {\n\tcase TRANSMISSION_MODE_8K:\tc->operand[14] |= 1 << 1; break;\n\tcase TRANSMISSION_MODE_2K:\n\tcase TRANSMISSION_MODE_AUTO:\n\tdefault:\t\t\tbreak;\n\t}\n\n\tc->operand[15] = 0x00;  \n\tc->operand[16] = 0x00;  \n\n\treturn 17 + add_pid_filter(fdtv, &c->operand[17]);\n}\n\nint avc_tuner_dsd(struct firedtv *fdtv,\n\t\t  struct dtv_frontend_properties *p)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint pos, ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\n\tswitch (fdtv->type) {\n\tcase FIREDTV_DVB_S:\n\tcase FIREDTV_DVB_S2: pos = avc_tuner_tuneqpsk(fdtv, p); break;\n\tcase FIREDTV_DVB_C: pos = avc_tuner_dsd_dvb_c(fdtv, p); break;\n\tcase FIREDTV_DVB_T: pos = avc_tuner_dsd_dvb_t(fdtv, p); break;\n\tdefault:\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\tpad_operands(c, pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + pos, 4);\n\tret = avc_write(fdtv);\n#if 0\n\t \n\tif (status)\n\t\t*status = r->operand[2];\n#endif\nunlock:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\tif (ret == 0)\n\t\tmsleep(500);\n\n\treturn ret;\n}\n\nint avc_tuner_set_pids(struct firedtv *fdtv, unsigned char pidc, u16 pid[])\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret, pos, k;\n\n\tif (pidc > 16 && pidc != 0xff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_DSD;\n\n\tc->operand[0] = 0;\t \n\tc->operand[1] = 0xd2;\t \n\tc->operand[2] = 0x20;\t \n\tc->operand[3] = 0x00;\t \n\tc->operand[4] = 0x00;\t \n\tc->operand[5] = pidc;\t \n\n\tpos = 6;\n\tif (pidc != 0xff)\n\t\tfor (k = 0; k < pidc; k++) {\n\t\t\tc->operand[pos++] = 0x13;  \n\t\t\tc->operand[pos++] = 0x80;  \n\t\t\tc->operand[pos++] = (pid[k] >> 8) & 0x1f;\n\t\t\tc->operand[pos++] = pid[k] & 0xff;\n\t\t\tc->operand[pos++] = 0x00;  \n\t\t\tc->operand[pos++] = 0x00;  \n\t\t}\n\tpad_operands(c, pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + pos, 4);\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\tif (ret == 0)\n\t\tmsleep(50);\n\n\treturn ret;\n}\n\nint avc_tuner_get_ts(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret, sl;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_DSIT;\n\n\tsl = fdtv->type == FIREDTV_DVB_T ? 0x0c : 0x11;\n\n\tc->operand[0] = 0;\t \n\tc->operand[1] = 0xd2;\t \n\tc->operand[2] = 0xff;\t \n\tc->operand[3] = 0x20;\t \n\tc->operand[4] = 0x00;\t \n\tc->operand[5] = 0x0;\t \n\tc->operand[6] = sl;\t \n\t \n\tclear_operands(c, 7, 24);\n\n\tfdtv->avc_data_length = fdtv->type == FIREDTV_DVB_T ? 24 : 28;\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\tif (ret == 0)\n\t\tmsleep(250);\n\n\treturn ret;\n}\n\nint avc_identify_subunit(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_READ_DESCRIPTOR;\n\n\tc->operand[0] = DESCRIPTOR_SUBUNIT_IDENTIFIER;\n\tc->operand[1] = 0xff;\n\tc->operand[2] = 0x00;\n\tc->operand[3] = 0x00;  \n\tc->operand[4] = 0x08;  \n\tc->operand[5] = 0x00;  \n\tc->operand[6] = 0x0d;  \n\tclear_operands(c, 7, 8);  \n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif ((r->response != AVC_RESPONSE_STABLE &&\n\t     r->response != AVC_RESPONSE_ACCEPTED) ||\n\t    (r->operand[3] << 8) + r->operand[4] != 8) {\n\t\tdev_err(fdtv->device, \"cannot read subunit identifier\\n\");\n\t\tret = -EINVAL;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\n#define SIZEOF_ANTENNA_INPUT_INFO 22\n\nint avc_tuner_status(struct firedtv *fdtv, struct firedtv_tuner_status *stat)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint length, ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_READ_DESCRIPTOR;\n\n\tc->operand[0] = DESCRIPTOR_TUNER_STATUS;\n\tc->operand[1] = 0xff;\t \n\t \n\tclear_operands(c, 2, 31);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_STABLE &&\n\t    r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device, \"cannot read tuner status\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlength = r->operand[9];\n\tif (r->operand[1] != 0x10 || length != SIZEOF_ANTENNA_INPUT_INFO) {\n\t\tdev_err(fdtv->device, \"got invalid tuner status\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstat->active_system\t\t= r->operand[10];\n\tstat->searching\t\t\t= r->operand[11] >> 7 & 1;\n\tstat->moving\t\t\t= r->operand[11] >> 6 & 1;\n\tstat->no_rf\t\t\t= r->operand[11] >> 5 & 1;\n\tstat->input\t\t\t= r->operand[12] >> 7 & 1;\n\tstat->selected_antenna\t\t= r->operand[12] & 0x7f;\n\tstat->ber\t\t\t= r->operand[13] << 24 |\n\t\t\t\t\t  r->operand[14] << 16 |\n\t\t\t\t\t  r->operand[15] << 8 |\n\t\t\t\t\t  r->operand[16];\n\tstat->signal_strength\t\t= r->operand[17];\n\tstat->raster_frequency\t\t= r->operand[18] >> 6 & 2;\n\tstat->rf_frequency\t\t= (r->operand[18] & 0x3f) << 16 |\n\t\t\t\t\t  r->operand[19] << 8 |\n\t\t\t\t\t  r->operand[20];\n\tstat->man_dep_info_length\t= r->operand[21];\n\tstat->front_end_error\t\t= r->operand[22] >> 4 & 1;\n\tstat->antenna_error\t\t= r->operand[22] >> 3 & 1;\n\tstat->front_end_power_status\t= r->operand[22] >> 1 & 1;\n\tstat->power_supply\t\t= r->operand[22] & 1;\n\tstat->carrier_noise_ratio\t= r->operand[23] << 8 |\n\t\t\t\t\t  r->operand[24];\n\tstat->power_supply_voltage\t= r->operand[27];\n\tstat->antenna_voltage\t\t= r->operand[28];\n\tstat->firewire_bus_voltage\t= r->operand[29];\n\tstat->ca_mmi\t\t\t= r->operand[30] & 1;\n\tstat->ca_pmt_reply\t\t= r->operand[31] >> 7 & 1;\n\tstat->ca_date_time_request\t= r->operand[31] >> 6 & 1;\n\tstat->ca_application_info\t= r->operand[31] >> 5 & 1;\n\tstat->ca_module_present_status\t= r->operand[31] >> 4 & 1;\n\tstat->ca_dvb_flag\t\t= r->operand[31] >> 3 & 1;\n\tstat->ca_error_flag\t\t= r->operand[31] >> 2 & 1;\n\tstat->ca_initialization_status\t= r->operand[31] >> 1 & 1;\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_lnb_control(struct firedtv *fdtv, char voltage, char burst,\n\t\t    char conttone, char nrdiseq,\n\t\t    struct dvb_diseqc_master_cmd *diseqcmd)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint pos, j, k, ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_LNB_CONTROL;\n\tc->operand[4] = voltage;\n\tc->operand[5] = nrdiseq;\n\n\tpos = 6;\n\tfor (j = 0; j < nrdiseq; j++) {\n\t\tc->operand[pos++] = diseqcmd[j].msg_len;\n\n\t\tfor (k = 0; k < diseqcmd[j].msg_len; k++)\n\t\t\tc->operand[pos++] = diseqcmd[j].msg[k];\n\t}\n\tc->operand[pos++] = burst;\n\tc->operand[pos++] = conttone;\n\tpad_operands(c, pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + pos, 4);\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device, \"LNB control failed\\n\");\n\t\tret = -EINVAL;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_register_remote_control(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_NOTIFY;\n\tc->subunit = AVC_SUBUNIT_TYPE_UNIT | 7;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL;\n\tc->operand[4] = 0;  \n\n\tfdtv->avc_data_length = 8;\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nvoid avc_remote_ctrl_work(struct work_struct *work)\n{\n\tstruct firedtv *fdtv =\n\t\t\tcontainer_of(work, struct firedtv, remote_ctrl_work);\n\n\t \n\tavc_register_remote_control(fdtv);\n}\n\n#if 0  \nint avc_tuner_host2ca(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_APPLICATION_INFO;  \n\tclear_operands(c, 6, 8);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n#endif\n\nstatic int get_ca_object_pos(struct avc_response_frame *r)\n{\n\tint length = 1;\n\n\t \n\tif (r->operand[7] & 0x80)\n\t\tlength = (r->operand[7] & 0x7f) + 1;\n\treturn length + 7;\n}\n\nstatic int get_ca_object_length(struct avc_response_frame *r)\n{\n#if 0  \n\tint size = 0;\n\tint i;\n\n\tif (r->operand[7] & 0x80)\n\t\tfor (i = 0; i < (r->operand[7] & 0x7f); i++) {\n\t\t\tsize <<= 8;\n\t\t\tsize += r->operand[8 + i];\n\t\t}\n#endif\n\treturn r->operand[7];\n}\n\nint avc_ca_app_info(struct firedtv *fdtv, unsigned char *app_info,\n\t\t    unsigned int *len)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint pos, ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_STATUS;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_APPLICATION_INFO;  \n\tclear_operands(c, 6, LAST_OPERAND);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tpos = get_ca_object_pos(r);\n\tapp_info[0] = (EN50221_TAG_APP_INFO >> 16) & 0xff;\n\tapp_info[1] = (EN50221_TAG_APP_INFO >>  8) & 0xff;\n\tapp_info[2] = (EN50221_TAG_APP_INFO >>  0) & 0xff;\n\tapp_info[3] = 6 + r->operand[pos + 4];\n\tapp_info[4] = 0x01;\n\tmemcpy(&app_info[5], &r->operand[pos], 5 + r->operand[pos + 4]);\n\t*len = app_info[3] + 4;\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_info(struct firedtv *fdtv, unsigned char *app_info,\n\t\tunsigned int *len)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint i, pos, ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_STATUS;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_APPLICATION_INFO;  \n\tclear_operands(c, 6, LAST_OPERAND);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tpos = get_ca_object_pos(r);\n\tapp_info[0] = (EN50221_TAG_CA_INFO >> 16) & 0xff;\n\tapp_info[1] = (EN50221_TAG_CA_INFO >>  8) & 0xff;\n\tapp_info[2] = (EN50221_TAG_CA_INFO >>  0) & 0xff;\n\tif (num_fake_ca_system_ids == 0) {\n\t\tapp_info[3] = 2;\n\t\tapp_info[4] = r->operand[pos + 0];\n\t\tapp_info[5] = r->operand[pos + 1];\n\t} else {\n\t\tapp_info[3] = num_fake_ca_system_ids * 2;\n\t\tfor (i = 0; i < num_fake_ca_system_ids; i++) {\n\t\t\tapp_info[4 + i * 2] =\n\t\t\t\t(fake_ca_system_ids[i] >> 8) & 0xff;\n\t\t\tapp_info[5 + i * 2] = fake_ca_system_ids[i] & 0xff;\n\t\t}\n\t}\n\t*len = app_info[3] + 4;\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_reset(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_RESET;  \n\tc->operand[6] = 0;  \n\tc->operand[7] = 1;  \n\tc->operand[8] = 0;  \n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint list_management;\n\tint program_info_length;\n\tint pmt_cmd_id;\n\tint read_pos;\n\tint write_pos;\n\tint es_info_length;\n\tint crc32_csum;\n\tint ret;\n\n\tif (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))\n\t\tdebug_pmt(msg, length);\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tif (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {\n\t\tdev_info(fdtv->device, \"forcing list_management to ONLY\\n\");\n\t\tmsg[0] = EN50221_LIST_MANAGEMENT_ONLY;\n\t}\n\t \n\tlist_management = msg[0];\n\tprogram_info_length = ((msg[4] & 0x0f) << 8) + msg[5];\n\tif (program_info_length > 0)\n\t\tprogram_info_length--;  \n\tpmt_cmd_id = msg[6];\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_PMT;  \n\tc->operand[6] = 0;  \n\t \n\tc->operand[10] = list_management;\n\tc->operand[11] = 0x01;  \n\n\t \n\n\tc->operand[12] = 0x02;  \n\tc->operand[13] = 0x80;  \n\n\tc->operand[15] = msg[1];  \n\tc->operand[16] = msg[2];\n\tc->operand[17] = msg[3];  \n\tc->operand[18] = 0x00;  \n\tc->operand[19] = 0x00;  \n\tc->operand[20] = 0x1f;  \n\tc->operand[21] = 0xff;\n\tc->operand[22] = (program_info_length >> 8);  \n\tc->operand[23] = (program_info_length & 0xff);\n\n\t \n\tread_pos = 6;\n\twrite_pos = 24;\n\tif (program_info_length > 0) {\n\t\tpmt_cmd_id = msg[read_pos++];\n\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\tdev_err(fdtv->device,\n\t\t\t\t\"invalid pmt_cmd_id %d\\n\", pmt_cmd_id);\n\t\tif (program_info_length > sizeof(c->operand) - 4 - write_pos) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t       program_info_length);\n\t\tread_pos += program_info_length;\n\t\twrite_pos += program_info_length;\n\t}\n\twhile (read_pos + 4 < length) {\n\t\tif (write_pos + 4 >= sizeof(c->operand) - 4) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tes_info_length =\n\t\t\t((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];\n\t\tread_pos += 2;\n\t\tif (es_info_length > 0)\n\t\t\tes_info_length--;  \n\t\tc->operand[write_pos++] = es_info_length >> 8;\n\t\tc->operand[write_pos++] = es_info_length & 0xff;\n\t\tif (es_info_length > 0) {\n\t\t\tif (read_pos >= length) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpmt_cmd_id = msg[read_pos++];\n\t\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\t\tdev_err(fdtv->device, \"invalid pmt_cmd_id %d at stream level\\n\",\n\t\t\t\t\tpmt_cmd_id);\n\n\t\t\tif (es_info_length > sizeof(c->operand) - 4 - write_pos ||\n\t\t\t    es_info_length > length - read_pos) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t\t       es_info_length);\n\t\t\tread_pos += es_info_length;\n\t\t\twrite_pos += es_info_length;\n\t\t}\n\t}\n\twrite_pos += 4;  \n\n\tc->operand[7] = 0x82;\n\tc->operand[8] = (write_pos - 10) >> 8;\n\tc->operand[9] = (write_pos - 10) & 0xff;\n\tc->operand[14] = write_pos - 15;\n\n\tcrc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);\n\tc->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;\n\tc->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;\n\tc->operand[write_pos - 2] = (crc32_csum >>  8) & 0xff;\n\tc->operand[write_pos - 1] = (crc32_csum >>  0) & 0xff;\n\tpad_operands(c, write_pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + write_pos, 4);\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device,\n\t\t\t\"CA PMT failed with response 0x%x\\n\", r->response);\n\t\tret = -EACCES;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_get_time_date(struct firedtv *fdtv, int *interval)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_STATUS;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_DATE_TIME;  \n\tclear_operands(c, 6, LAST_OPERAND);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\t*interval = r->operand[get_ca_object_pos(r)];\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_enter_menu(struct firedtv *fdtv)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_STATUS;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_ENTER_MENU;\n\tclear_operands(c, 6, 8);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\n\t \n\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\nint avc_ca_get_mmi(struct firedtv *fdtv, char *mmi_object, unsigned int *len)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint ret;\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_STATUS;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\n\tc->operand[4] = 0;  \n\tc->operand[5] = SFE_VENDOR_TAG_CA_MMI;\n\tclear_operands(c, 6, LAST_OPERAND);\n\n\tfdtv->avc_data_length = 12;\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\t*len = get_ca_object_length(r);\n\tmemcpy(mmi_object, &r->operand[get_ca_object_pos(r)], *len);\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}\n\n#define CMP_OUTPUT_PLUG_CONTROL_REG_0\t0xfffff0000904ULL\n\nstatic int cmp_read(struct firedtv *fdtv, u64 addr, __be32 *data)\n{\n\tint ret;\n\n\tret = fdtv_read(fdtv, addr, data);\n\tif (ret < 0)\n\t\tdev_err(fdtv->device, \"CMP: read I/O error\\n\");\n\n\treturn ret;\n}\n\nstatic int cmp_lock(struct firedtv *fdtv, u64 addr, __be32 data[])\n{\n\tint ret;\n\n\tret = fdtv_lock(fdtv, addr, data);\n\tif (ret < 0)\n\t\tdev_err(fdtv->device, \"CMP: lock I/O error\\n\");\n\n\treturn ret;\n}\n\nstatic inline u32 get_opcr(__be32 opcr, u32 mask, u32 shift)\n{\n\treturn (be32_to_cpu(opcr) >> shift) & mask;\n}\n\nstatic inline void set_opcr(__be32 *opcr, u32 value, u32 mask, u32 shift)\n{\n\t*opcr &= ~cpu_to_be32(mask << shift);\n\t*opcr |= cpu_to_be32((value & mask) << shift);\n}\n\n#define get_opcr_online(v)\t\tget_opcr((v), 0x1, 31)\n#define get_opcr_p2p_connections(v)\tget_opcr((v), 0x3f, 24)\n#define get_opcr_channel(v)\t\tget_opcr((v), 0x3f, 16)\n\n#define set_opcr_p2p_connections(p, v)\tset_opcr((p), (v), 0x3f, 24)\n#define set_opcr_channel(p, v)\t\tset_opcr((p), (v), 0x3f, 16)\n#define set_opcr_data_rate(p, v)\tset_opcr((p), (v), 0x3, 14)\n#define set_opcr_overhead_id(p, v)\tset_opcr((p), (v), 0xf, 10)\n\nint cmp_establish_pp_connection(struct firedtv *fdtv, int plug, int channel)\n{\n\t__be32 old_opcr, opcr[2];\n\tu64 opcr_address = CMP_OUTPUT_PLUG_CONTROL_REG_0 + (plug << 2);\n\tint attempts = 0;\n\tint ret;\n\n\tret = cmp_read(fdtv, opcr_address, opcr);\n\tif (ret < 0)\n\t\treturn ret;\n\nrepeat:\n\tif (!get_opcr_online(*opcr)) {\n\t\tdev_err(fdtv->device, \"CMP: output offline\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\told_opcr = *opcr;\n\n\tif (get_opcr_p2p_connections(*opcr)) {\n\t\tif (get_opcr_channel(*opcr) != channel) {\n\t\t\tdev_err(fdtv->device, \"CMP: cannot change channel\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tdev_info(fdtv->device, \"CMP: overlaying connection\\n\");\n\n\t\t \n\t} else {\n\t\tset_opcr_channel(opcr, channel);\n\t\tset_opcr_data_rate(opcr, 2);  \n\n\t\t \n\t\tset_opcr_overhead_id(opcr, 0);\n\n\t\t \n\t}\n\n\tset_opcr_p2p_connections(opcr, get_opcr_p2p_connections(*opcr) + 1);\n\n\topcr[1] = *opcr;\n\topcr[0] = old_opcr;\n\n\tret = cmp_lock(fdtv, opcr_address, opcr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (old_opcr != *opcr) {\n\t\t \n\n\t\tif (++attempts < 6)  \n\t\t\tgoto repeat;\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nvoid cmp_break_pp_connection(struct firedtv *fdtv, int plug, int channel)\n{\n\t__be32 old_opcr, opcr[2];\n\tu64 opcr_address = CMP_OUTPUT_PLUG_CONTROL_REG_0 + (plug << 2);\n\tint attempts = 0;\n\n\tif (cmp_read(fdtv, opcr_address, opcr) < 0)\n\t\treturn;\n\nrepeat:\n\tif (!get_opcr_online(*opcr) || !get_opcr_p2p_connections(*opcr) ||\n\t    get_opcr_channel(*opcr) != channel) {\n\t\tdev_err(fdtv->device, \"CMP: no connection to break\\n\");\n\t\treturn;\n\t}\n\n\told_opcr = *opcr;\n\tset_opcr_p2p_connections(opcr, get_opcr_p2p_connections(*opcr) - 1);\n\n\topcr[1] = *opcr;\n\topcr[0] = old_opcr;\n\n\tif (cmp_lock(fdtv, opcr_address, opcr) < 0)\n\t\treturn;\n\n\tif (old_opcr != *opcr) {\n\t\t \n\n\t\tif (++attempts < 6)  \n\t\t\tgoto repeat;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}