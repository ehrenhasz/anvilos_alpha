{
  "module_name": "firedtv-ci.c",
  "hash_id": "9215fd419d7de397a8eee07667333cb4d811aa537c70623c7acc154760f9ed92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/firewire/firedtv-ci.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dvb/ca.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#include <media/dvbdev.h>\n\n#include \"firedtv.h\"\n\n#define EN50221_TAG_APP_INFO_ENQUIRY\t0x9f8020\n#define EN50221_TAG_CA_INFO_ENQUIRY\t0x9f8030\n#define EN50221_TAG_CA_PMT\t\t0x9f8032\n#define EN50221_TAG_ENTER_MENU\t\t0x9f8022\n\nstatic int fdtv_ca_ready(struct firedtv_tuner_status *stat)\n{\n\treturn stat->ca_initialization_status\t== 1 &&\n\t       stat->ca_error_flag\t\t== 0 &&\n\t       stat->ca_dvb_flag\t\t== 1 &&\n\t       stat->ca_module_present_status\t== 1;\n}\n\nstatic int fdtv_get_ca_flags(struct firedtv_tuner_status *stat)\n{\n\tint flags = 0;\n\n\tif (stat->ca_module_present_status == 1)\n\t\tflags |= CA_CI_MODULE_PRESENT;\n\tif (stat->ca_initialization_status == 1 &&\n\t    stat->ca_error_flag            == 0 &&\n\t    stat->ca_dvb_flag              == 1)\n\t\tflags |= CA_CI_MODULE_READY;\n\treturn flags;\n}\n\nstatic int fdtv_ca_get_caps(void *arg)\n{\n\tstruct ca_caps *cap = arg;\n\n\tcap->slot_num = 1;\n\tcap->slot_type = CA_CI;\n\tcap->descr_num = 1;\n\tcap->descr_type = CA_ECD;\n\treturn 0;\n}\n\nstatic int fdtv_ca_get_slot_info(struct firedtv *fdtv, void *arg)\n{\n\tstruct firedtv_tuner_status stat;\n\tstruct ca_slot_info *slot = arg;\n\tint err;\n\n\terr = avc_tuner_status(fdtv, &stat);\n\tif (err)\n\t\treturn err;\n\n\tif (slot->num != 0)\n\t\treturn -EACCES;\n\n\tslot->type = CA_CI;\n\tslot->flags = fdtv_get_ca_flags(&stat);\n\treturn 0;\n}\n\nstatic int fdtv_ca_app_info(struct firedtv *fdtv, void *arg)\n{\n\tstruct ca_msg *reply = arg;\n\n\treturn avc_ca_app_info(fdtv, reply->msg, &reply->length);\n}\n\nstatic int fdtv_ca_info(struct firedtv *fdtv, void *arg)\n{\n\tstruct ca_msg *reply = arg;\n\n\treturn avc_ca_info(fdtv, reply->msg, &reply->length);\n}\n\nstatic int fdtv_ca_get_mmi(struct firedtv *fdtv, void *arg)\n{\n\tstruct ca_msg *reply = arg;\n\n\treturn avc_ca_get_mmi(fdtv, reply->msg, &reply->length);\n}\n\nstatic int fdtv_ca_get_msg(struct firedtv *fdtv, void *arg)\n{\n\tstruct firedtv_tuner_status stat;\n\tint err;\n\n\tswitch (fdtv->ca_last_command) {\n\tcase EN50221_TAG_APP_INFO_ENQUIRY:\n\t\terr = fdtv_ca_app_info(fdtv, arg);\n\t\tbreak;\n\tcase EN50221_TAG_CA_INFO_ENQUIRY:\n\t\terr = fdtv_ca_info(fdtv, arg);\n\t\tbreak;\n\tdefault:\n\t\terr = avc_tuner_status(fdtv, &stat);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (stat.ca_mmi == 1)\n\t\t\terr = fdtv_ca_get_mmi(fdtv, arg);\n\t\telse {\n\t\t\tdev_info(fdtv->device, \"unhandled CA message 0x%08x\\n\",\n\t\t\t\t fdtv->ca_last_command);\n\t\t\terr = -EACCES;\n\t\t}\n\t}\n\tfdtv->ca_last_command = 0;\n\treturn err;\n}\n\nstatic int fdtv_ca_pmt(struct firedtv *fdtv, void *arg)\n{\n\tstruct ca_msg *msg = arg;\n\tint data_pos;\n\tint data_length;\n\tint i;\n\n\tdata_pos = 4;\n\tif (msg->msg[3] & 0x80) {\n\t\tdata_length = 0;\n\t\tfor (i = 0; i < (msg->msg[3] & 0x7f); i++)\n\t\t\tdata_length = (data_length << 8) + msg->msg[data_pos++];\n\t} else {\n\t\tdata_length = msg->msg[3];\n\t}\n\tif (data_length > sizeof(msg->msg) - data_pos)\n\t\treturn -EINVAL;\n\n\treturn avc_ca_pmt(fdtv, &msg->msg[data_pos], data_length);\n}\n\nstatic int fdtv_ca_send_msg(struct firedtv *fdtv, void *arg)\n{\n\tstruct ca_msg *msg = arg;\n\tint err;\n\n\t \n\tfdtv->ca_last_command =\n\t\t(msg->msg[0] << 16) + (msg->msg[1] << 8) + msg->msg[2];\n\tswitch (fdtv->ca_last_command) {\n\tcase EN50221_TAG_CA_PMT:\n\t\terr = fdtv_ca_pmt(fdtv, arg);\n\t\tbreak;\n\tcase EN50221_TAG_APP_INFO_ENQUIRY:\n\t\t \n\t\terr = 0;\n\t\tbreak;\n\tcase EN50221_TAG_CA_INFO_ENQUIRY:\n\t\t \n\t\terr = 0;\n\t\tbreak;\n\tcase EN50221_TAG_ENTER_MENU:\n\t\terr = avc_ca_enter_menu(fdtv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fdtv->device, \"unhandled CA message 0x%08x\\n\",\n\t\t\tfdtv->ca_last_command);\n\t\terr = -EACCES;\n\t}\n\treturn err;\n}\n\nstatic int fdtv_ca_ioctl(struct file *file, unsigned int cmd, void *arg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct firedtv *fdtv = dvbdev->priv;\n\tstruct firedtv_tuner_status stat;\n\tint err;\n\n\tswitch (cmd) {\n\tcase CA_RESET:\n\t\terr = avc_ca_reset(fdtv);\n\t\tbreak;\n\tcase CA_GET_CAP:\n\t\terr = fdtv_ca_get_caps(arg);\n\t\tbreak;\n\tcase CA_GET_SLOT_INFO:\n\t\terr = fdtv_ca_get_slot_info(fdtv, arg);\n\t\tbreak;\n\tcase CA_GET_MSG:\n\t\terr = fdtv_ca_get_msg(fdtv, arg);\n\t\tbreak;\n\tcase CA_SEND_MSG:\n\t\terr = fdtv_ca_send_msg(fdtv, arg);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(fdtv->device, \"unhandled CA ioctl %u\\n\", cmd);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\t \n\tavc_tuner_status(fdtv, &stat);\n\n\treturn err;\n}\n\nstatic __poll_t fdtv_ca_io_poll(struct file *file, poll_table *wait)\n{\n\treturn EPOLLIN;\n}\n\nstatic const struct file_operations fdtv_ca_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= dvb_generic_ioctl,\n\t.open\t\t= dvb_generic_open,\n\t.release\t= dvb_generic_release,\n\t.poll\t\t= fdtv_ca_io_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic const struct dvb_device fdtv_ca = {\n\t.users\t\t= 1,\n\t.readers\t= 1,\n\t.writers\t= 1,\n\t.fops\t\t= &fdtv_ca_fops,\n\t.kernel_ioctl\t= fdtv_ca_ioctl,\n};\n\nint fdtv_ca_register(struct firedtv *fdtv)\n{\n\tstruct firedtv_tuner_status stat;\n\tint err;\n\n\tif (avc_tuner_status(fdtv, &stat))\n\t\treturn -EINVAL;\n\n\tif (!fdtv_ca_ready(&stat))\n\t\treturn -EFAULT;\n\n\terr = dvb_register_device(&fdtv->adapter, &fdtv->cadev,\n\t\t\t\t  &fdtv_ca, fdtv, DVB_DEVICE_CA, 0);\n\n\tif (stat.ca_application_info == 0)\n\t\tdev_err(fdtv->device, \"CaApplicationInfo is not set\\n\");\n\tif (stat.ca_date_time_request == 1)\n\t\tavc_ca_get_time_date(fdtv, &fdtv->ca_time_interval);\n\n\treturn err;\n}\n\nvoid fdtv_ca_release(struct firedtv *fdtv)\n{\n\tdvb_unregister_device(fdtv->cadev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}