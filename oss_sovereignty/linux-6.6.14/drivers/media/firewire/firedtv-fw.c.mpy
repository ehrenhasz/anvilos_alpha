{
  "module_name": "firedtv-fw.c",
  "hash_id": "c7031d9b201a565f0112bccf796f4d50207750b86aa8b2f976c0fd32036dafd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/firewire/firedtv-fw.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <asm/page.h>\n\n#include <media/dvb_demux.h>\n\n#include \"firedtv.h\"\n\nstatic LIST_HEAD(node_list);\nstatic DEFINE_SPINLOCK(node_list_lock);\n\nstatic inline struct fw_device *device_of(struct firedtv *fdtv)\n{\n\treturn fw_device(fdtv->device->parent);\n}\n\nstatic int node_req(struct firedtv *fdtv, u64 addr, void *data, size_t len,\n\t\t    int tcode)\n{\n\tstruct fw_device *device = device_of(fdtv);\n\tint rcode, generation = device->generation;\n\n\tsmp_rmb();  \n\n\trcode = fw_run_transaction(device->card, tcode, device->node_id,\n\t\t\tgeneration, device->max_speed, addr, data, len);\n\n\treturn rcode != RCODE_COMPLETE ? -EIO : 0;\n}\n\nint fdtv_lock(struct firedtv *fdtv, u64 addr, void *data)\n{\n\treturn node_req(fdtv, addr, data, 8, TCODE_LOCK_COMPARE_SWAP);\n}\n\nint fdtv_read(struct firedtv *fdtv, u64 addr, void *data)\n{\n\treturn node_req(fdtv, addr, data, 4, TCODE_READ_QUADLET_REQUEST);\n}\n\nint fdtv_write(struct firedtv *fdtv, u64 addr, void *data, size_t len)\n{\n\treturn node_req(fdtv, addr, data, len, TCODE_WRITE_BLOCK_REQUEST);\n}\n\n#define ISO_HEADER_SIZE\t\t\t4\n#define CIP_HEADER_SIZE\t\t\t8\n#define MPEG2_TS_HEADER_SIZE\t\t4\n#define MPEG2_TS_SOURCE_PACKET_SIZE\t(4 + 188)\n\n#define MAX_PACKET_SIZE\t\t1024   \n#define PACKETS_PER_PAGE\t(PAGE_SIZE / MAX_PACKET_SIZE)\n#define N_PACKETS\t\t64     \n#define N_PAGES\t\t\tDIV_ROUND_UP(N_PACKETS, PACKETS_PER_PAGE)\n#define IRQ_INTERVAL\t\t16\n\nstruct fdtv_ir_context {\n\tstruct fw_iso_context *context;\n\tstruct fw_iso_buffer buffer;\n\tint interrupt_packet;\n\tint current_packet;\n\tchar *pages[N_PAGES];\n};\n\nstatic int queue_iso(struct fdtv_ir_context *ctx, int index)\n{\n\tstruct fw_iso_packet p;\n\n\tp.payload_length = MAX_PACKET_SIZE;\n\tp.interrupt = !(++ctx->interrupt_packet & (IRQ_INTERVAL - 1));\n\tp.skip = 0;\n\tp.header_length = ISO_HEADER_SIZE;\n\n\treturn fw_iso_context_queue(ctx->context, &p, &ctx->buffer,\n\t\t\t\t    index * MAX_PACKET_SIZE);\n}\n\nstatic void handle_iso(struct fw_iso_context *context, u32 cycle,\n\t\t       size_t header_length, void *header, void *data)\n{\n\tstruct firedtv *fdtv = data;\n\tstruct fdtv_ir_context *ctx = fdtv->ir_context;\n\t__be32 *h, *h_end;\n\tint length, err, i = ctx->current_packet;\n\tchar *p, *p_end;\n\n\tfor (h = header, h_end = h + header_length / 4; h < h_end; h++) {\n\t\tlength = be32_to_cpup(h) >> 16;\n\t\tif (unlikely(length > MAX_PACKET_SIZE)) {\n\t\t\tdev_err(fdtv->device, \"length = %d\\n\", length);\n\t\t\tlength = MAX_PACKET_SIZE;\n\t\t}\n\n\t\tp = ctx->pages[i / PACKETS_PER_PAGE]\n\t\t\t\t+ (i % PACKETS_PER_PAGE) * MAX_PACKET_SIZE;\n\t\tp_end = p + length;\n\n\t\tfor (p += CIP_HEADER_SIZE + MPEG2_TS_HEADER_SIZE; p < p_end;\n\t\t     p += MPEG2_TS_SOURCE_PACKET_SIZE)\n\t\t\tdvb_dmx_swfilter_packets(&fdtv->demux, p, 1);\n\n\t\terr = queue_iso(ctx, i);\n\t\tif (unlikely(err))\n\t\t\tdev_err(fdtv->device, \"requeue failed\\n\");\n\n\t\ti = (i + 1) & (N_PACKETS - 1);\n\t}\n\tfw_iso_context_queue_flush(ctx->context);\n\tctx->current_packet = i;\n}\n\nint fdtv_start_iso(struct firedtv *fdtv)\n{\n\tstruct fdtv_ir_context *ctx;\n\tstruct fw_device *device = device_of(fdtv);\n\tint i, err;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->context = fw_iso_context_create(device->card,\n\t\t\tFW_ISO_CONTEXT_RECEIVE, fdtv->isochannel,\n\t\t\tdevice->max_speed, ISO_HEADER_SIZE, handle_iso, fdtv);\n\tif (IS_ERR(ctx->context)) {\n\t\terr = PTR_ERR(ctx->context);\n\t\tgoto fail_free;\n\t}\n\n\terr = fw_iso_buffer_init(&ctx->buffer, device->card,\n\t\t\t\t N_PAGES, DMA_FROM_DEVICE);\n\tif (err)\n\t\tgoto fail_context_destroy;\n\n\tctx->interrupt_packet = 0;\n\tctx->current_packet = 0;\n\n\tfor (i = 0; i < N_PAGES; i++)\n\t\tctx->pages[i] = page_address(ctx->buffer.pages[i]);\n\n\tfor (i = 0; i < N_PACKETS; i++) {\n\t\terr = queue_iso(ctx, i);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\terr = fw_iso_context_start(ctx->context, -1, 0,\n\t\t\t\t   FW_ISO_CONTEXT_MATCH_ALL_TAGS);\n\tif (err)\n\t\tgoto fail;\n\n\tfdtv->ir_context = ctx;\n\n\treturn 0;\nfail:\n\tfw_iso_buffer_destroy(&ctx->buffer, device->card);\nfail_context_destroy:\n\tfw_iso_context_destroy(ctx->context);\nfail_free:\n\tkfree(ctx);\n\n\treturn err;\n}\n\nvoid fdtv_stop_iso(struct firedtv *fdtv)\n{\n\tstruct fdtv_ir_context *ctx = fdtv->ir_context;\n\n\tfw_iso_context_stop(ctx->context);\n\tfw_iso_buffer_destroy(&ctx->buffer, device_of(fdtv)->card);\n\tfw_iso_context_destroy(ctx->context);\n\tkfree(ctx);\n}\n\nstatic void handle_fcp(struct fw_card *card, struct fw_request *request,\n\t\t       int tcode, int destination, int source, int generation,\n\t\t       unsigned long long offset, void *payload, size_t length,\n\t\t       void *callback_data)\n{\n\tstruct firedtv *f, *fdtv = NULL;\n\tstruct fw_device *device;\n\tunsigned long flags;\n\tint su;\n\n\tif (length < 2 || (((u8 *)payload)[0] & 0xf0) != 0)\n\t\treturn;\n\n\tsu = ((u8 *)payload)[1] & 0x7;\n\n\tspin_lock_irqsave(&node_list_lock, flags);\n\tlist_for_each_entry(f, &node_list, list) {\n\t\tdevice = device_of(f);\n\t\tif (device->generation != generation)\n\t\t\tcontinue;\n\n\t\tsmp_rmb();  \n\n\t\tif (device->card == card &&\n\t\t    device->node_id == source &&\n\t\t    (f->subunit == su || (f->subunit == 0 && su == 0x7))) {\n\t\t\tfdtv = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&node_list_lock, flags);\n\n\tif (fdtv)\n\t\tavc_recv(fdtv, payload, length);\n}\n\nstatic struct fw_address_handler fcp_handler = {\n\t.length           = CSR_FCP_END - CSR_FCP_RESPONSE,\n\t.address_callback = handle_fcp,\n};\n\nstatic const struct fw_address_region fcp_region = {\n\t.start\t= CSR_REGISTER_BASE + CSR_FCP_RESPONSE,\n\t.end\t= CSR_REGISTER_BASE + CSR_FCP_END,\n};\n\nstatic const char * const model_names[] = {\n\t[FIREDTV_UNKNOWN] = \"unknown type\",\n\t[FIREDTV_DVB_S]   = \"FireDTV S/CI\",\n\t[FIREDTV_DVB_C]   = \"FireDTV C/CI\",\n\t[FIREDTV_DVB_T]   = \"FireDTV T/CI\",\n\t[FIREDTV_DVB_S2]  = \"FireDTV S2  \",\n};\n\n \n#define MAX_MODEL_NAME_LEN sizeof(\"FireDTV ????\")\n\nstatic int node_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\n{\n\tstruct firedtv *fdtv;\n\tchar name[MAX_MODEL_NAME_LEN];\n\tint name_len, i, err;\n\n\tfdtv = kzalloc(sizeof(*fdtv), GFP_KERNEL);\n\tif (!fdtv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&unit->device, fdtv);\n\tfdtv->device\t\t= &unit->device;\n\tfdtv->isochannel\t= -1;\n\tfdtv->voltage\t\t= 0xff;\n\tfdtv->tone\t\t= 0xff;\n\n\tmutex_init(&fdtv->avc_mutex);\n\tinit_waitqueue_head(&fdtv->avc_wait);\n\tmutex_init(&fdtv->demux_mutex);\n\tINIT_WORK(&fdtv->remote_ctrl_work, avc_remote_ctrl_work);\n\n\tname_len = fw_csr_string(unit->directory, CSR_MODEL,\n\t\t\t\t name, sizeof(name));\n\tif (name_len < 0) {\n\t\terr = name_len;\n\t\tgoto fail_free;\n\t}\n\tfor (i = ARRAY_SIZE(model_names); --i; )\n\t\tif (strlen(model_names[i]) <= name_len &&\n\t\t    strncmp(name, model_names[i], name_len) == 0)\n\t\t\tbreak;\n\tfdtv->type = i;\n\n\terr = fdtv_register_rc(fdtv, &unit->device);\n\tif (err)\n\t\tgoto fail_free;\n\n\tspin_lock_irq(&node_list_lock);\n\tlist_add_tail(&fdtv->list, &node_list);\n\tspin_unlock_irq(&node_list_lock);\n\n\terr = avc_identify_subunit(fdtv);\n\tif (err)\n\t\tgoto fail;\n\n\terr = fdtv_dvb_register(fdtv, model_names[fdtv->type]);\n\tif (err)\n\t\tgoto fail;\n\n\tavc_register_remote_control(fdtv);\n\n\treturn 0;\nfail:\n\tspin_lock_irq(&node_list_lock);\n\tlist_del(&fdtv->list);\n\tspin_unlock_irq(&node_list_lock);\n\tfdtv_unregister_rc(fdtv);\nfail_free:\n\tkfree(fdtv);\n\n\treturn err;\n}\n\nstatic void node_remove(struct fw_unit *unit)\n{\n\tstruct firedtv *fdtv = dev_get_drvdata(&unit->device);\n\n\tfdtv_dvb_unregister(fdtv);\n\n\tspin_lock_irq(&node_list_lock);\n\tlist_del(&fdtv->list);\n\tspin_unlock_irq(&node_list_lock);\n\n\tfdtv_unregister_rc(fdtv);\n\n\tkfree(fdtv);\n}\n\nstatic void node_update(struct fw_unit *unit)\n{\n\tstruct firedtv *fdtv = dev_get_drvdata(&unit->device);\n\n\tif (fdtv->isochannel >= 0)\n\t\tcmp_establish_pp_connection(fdtv, fdtv->subunit,\n\t\t\t\t\t    fdtv->isochannel);\n}\n\n#define MATCH_FLAGS (IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID | \\\n\t\t     IEEE1394_MATCH_SPECIFIER_ID | IEEE1394_MATCH_VERSION)\n\n#define DIGITAL_EVERYWHERE_OUI\t0x001287\n#define AVC_UNIT_SPEC_ID_ENTRY\t0x00a02d\n#define AVC_SW_VERSION_ENTRY\t0x010001\n\nstatic const struct ieee1394_device_id fdtv_id_table[] = {\n\t{\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000024,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000025,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000026,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000034,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000035,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {\n\t\t \n\t\t.match_flags\t= MATCH_FLAGS,\n\t\t.vendor_id\t= DIGITAL_EVERYWHERE_OUI,\n\t\t.model_id\t= 0x000036,\n\t\t.specifier_id\t= AVC_UNIT_SPEC_ID_ENTRY,\n\t\t.version\t= AVC_SW_VERSION_ENTRY,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(ieee1394, fdtv_id_table);\n\nstatic struct fw_driver fdtv_driver = {\n\t.driver   = {\n\t\t.owner  = THIS_MODULE,\n\t\t.name   = \"firedtv\",\n\t\t.bus    = &fw_bus_type,\n\t},\n\t.probe    = node_probe,\n\t.update   = node_update,\n\t.remove   = node_remove,\n\t.id_table = fdtv_id_table,\n};\n\nstatic int __init fdtv_init(void)\n{\n\tint ret;\n\n\tret = fw_core_add_address_handler(&fcp_handler, &fcp_region);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = driver_register(&fdtv_driver.driver);\n\tif (ret < 0)\n\t\tfw_core_remove_address_handler(&fcp_handler);\n\n\treturn ret;\n}\n\nstatic void __exit fdtv_exit(void)\n{\n\tdriver_unregister(&fdtv_driver.driver);\n\tfw_core_remove_address_handler(&fcp_handler);\n}\n\nmodule_init(fdtv_init);\nmodule_exit(fdtv_exit);\n\nMODULE_AUTHOR(\"Andreas Monitzer <andy@monitzer.com>\");\nMODULE_AUTHOR(\"Ben Backx <ben@bbackx.com>\");\nMODULE_DESCRIPTION(\"FireDTV DVB Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}