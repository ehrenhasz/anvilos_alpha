{
  "module_name": "firedtv-dvb.c",
  "hash_id": "d8a6dc93d4ce338d5d07dcadb32908d336c097df87d5e5147bb19e675f8d2f58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/firewire/firedtv-dvb.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvbdev.h>\n#include <media/dvb_frontend.h>\n\n#include \"firedtv.h\"\n\nstatic int alloc_channel(struct firedtv *fdtv)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (!__test_and_set_bit(i, &fdtv->channel_active))\n\t\t\tbreak;\n\treturn i;\n}\n\nstatic void collect_channels(struct firedtv *fdtv, int *pidc, u16 pid[])\n{\n\tint i, n;\n\n\tfor (i = 0, n = 0; i < 16; i++)\n\t\tif (test_bit(i, &fdtv->channel_active))\n\t\t\tpid[n++] = fdtv->channel_pid[i];\n\t*pidc = n;\n}\n\nstatic inline void dealloc_channel(struct firedtv *fdtv, int i)\n{\n\t__clear_bit(i, &fdtv->channel_active);\n}\n\nint fdtv_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct firedtv *fdtv = dvbdmxfeed->demux->priv;\n\tint pidc, c, ret;\n\tu16 pids[16];\n\n\tswitch (dvbdmxfeed->type) {\n\tcase DMX_TYPE_TS:\n\tcase DMX_TYPE_SEC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fdtv->device, \"can't start dmx feed: invalid type %u\\n\",\n\t\t\tdvbdmxfeed->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mutex_lock_interruptible(&fdtv->demux_mutex))\n\t\treturn -EINTR;\n\n\tif (dvbdmxfeed->type == DMX_TYPE_TS) {\n\t\tswitch (dvbdmxfeed->pes_type) {\n\t\tcase DMX_PES_VIDEO:\n\t\tcase DMX_PES_AUDIO:\n\t\tcase DMX_PES_TELETEXT:\n\t\tcase DMX_PES_PCR:\n\t\tcase DMX_PES_OTHER:\n\t\t\tc = alloc_channel(fdtv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(fdtv->device,\n\t\t\t\t\"can't start dmx feed: invalid pes type %u\\n\",\n\t\t\t\tdvbdmxfeed->pes_type);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tc = alloc_channel(fdtv);\n\t}\n\n\tif (c > 15) {\n\t\tdev_err(fdtv->device, \"can't start dmx feed: busy\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tdvbdmxfeed->priv = (typeof(dvbdmxfeed->priv))(unsigned long)c;\n\tfdtv->channel_pid[c] = dvbdmxfeed->pid;\n\tcollect_channels(fdtv, &pidc, pids);\n\n\tif (dvbdmxfeed->pid == 8192) {\n\t\tret = avc_tuner_get_ts(fdtv);\n\t\tif (ret) {\n\t\t\tdealloc_channel(fdtv, c);\n\t\t\tdev_err(fdtv->device, \"can't get TS\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = avc_tuner_set_pids(fdtv, pidc, pids);\n\t\tif (ret) {\n\t\t\tdealloc_channel(fdtv, c);\n\t\t\tdev_err(fdtv->device, \"can't set PIDs\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&fdtv->demux_mutex);\n\n\treturn ret;\n}\n\nint fdtv_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *demux = dvbdmxfeed->demux;\n\tstruct firedtv *fdtv = demux->priv;\n\tint pidc, c, ret;\n\tu16 pids[16];\n\n\tif (dvbdmxfeed->type == DMX_TYPE_TS &&\n\t    !((dvbdmxfeed->ts_type & TS_PACKET) &&\n\t      (demux->dmx.frontend->source != DMX_MEMORY_FE))) {\n\n\t\tif (dvbdmxfeed->ts_type & TS_DECODER) {\n\t\t\tif (dvbdmxfeed->pes_type >= DMX_PES_OTHER ||\n\t\t\t    !demux->pesfilter[dvbdmxfeed->pes_type])\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdemux->pids[dvbdmxfeed->pes_type] |= 0x8000;\n\t\t\tdemux->pesfilter[dvbdmxfeed->pes_type] = NULL;\n\t\t}\n\n\t\tif (!(dvbdmxfeed->ts_type & TS_DECODER &&\n\t\t      dvbdmxfeed->pes_type < DMX_PES_OTHER))\n\t\t\treturn 0;\n\t}\n\n\tif (mutex_lock_interruptible(&fdtv->demux_mutex))\n\t\treturn -EINTR;\n\n\tc = (unsigned long)dvbdmxfeed->priv;\n\tdealloc_channel(fdtv, c);\n\tcollect_channels(fdtv, &pidc, pids);\n\n\tret = avc_tuner_set_pids(fdtv, pidc, pids);\n\n\tmutex_unlock(&fdtv->demux_mutex);\n\n\treturn ret;\n}\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nint fdtv_dvb_register(struct firedtv *fdtv, const char *name)\n{\n\tint err;\n\n\terr = dvb_register_adapter(&fdtv->adapter, name,\n\t\t\t\t   THIS_MODULE, fdtv->device, adapter_nr);\n\tif (err < 0)\n\t\tgoto fail_log;\n\n\t \n\tfdtv->demux.dmx.capabilities = 0;\n\n\tfdtv->demux.priv\t= fdtv;\n\tfdtv->demux.filternum\t= 16;\n\tfdtv->demux.feednum\t= 16;\n\tfdtv->demux.start_feed\t= fdtv_start_feed;\n\tfdtv->demux.stop_feed\t= fdtv_stop_feed;\n\tfdtv->demux.write_to_decoder = NULL;\n\n\terr = dvb_dmx_init(&fdtv->demux);\n\tif (err)\n\t\tgoto fail_unreg_adapter;\n\n\tfdtv->dmxdev.filternum    = 16;\n\tfdtv->dmxdev.demux        = &fdtv->demux.dmx;\n\tfdtv->dmxdev.capabilities = 0;\n\n\terr = dvb_dmxdev_init(&fdtv->dmxdev, &fdtv->adapter);\n\tif (err)\n\t\tgoto fail_dmx_release;\n\n\tfdtv->frontend.source = DMX_FRONTEND_0;\n\n\terr = fdtv->demux.dmx.add_frontend(&fdtv->demux.dmx, &fdtv->frontend);\n\tif (err)\n\t\tgoto fail_dmxdev_release;\n\n\terr = fdtv->demux.dmx.connect_frontend(&fdtv->demux.dmx,\n\t\t\t\t\t       &fdtv->frontend);\n\tif (err)\n\t\tgoto fail_rem_frontend;\n\n\terr = dvb_net_init(&fdtv->adapter, &fdtv->dvbnet, &fdtv->demux.dmx);\n\tif (err)\n\t\tgoto fail_disconnect_frontend;\n\n\tfdtv_frontend_init(fdtv, name);\n\terr = dvb_register_frontend(&fdtv->adapter, &fdtv->fe);\n\tif (err)\n\t\tgoto fail_net_release;\n\n\terr = fdtv_ca_register(fdtv);\n\tif (err)\n\t\tdev_info(fdtv->device,\n\t\t\t \"Conditional Access Module not enabled\\n\");\n\treturn 0;\n\nfail_net_release:\n\tdvb_net_release(&fdtv->dvbnet);\nfail_disconnect_frontend:\n\tfdtv->demux.dmx.close(&fdtv->demux.dmx);\nfail_rem_frontend:\n\tfdtv->demux.dmx.remove_frontend(&fdtv->demux.dmx, &fdtv->frontend);\nfail_dmxdev_release:\n\tdvb_dmxdev_release(&fdtv->dmxdev);\nfail_dmx_release:\n\tdvb_dmx_release(&fdtv->demux);\nfail_unreg_adapter:\n\tdvb_unregister_adapter(&fdtv->adapter);\nfail_log:\n\tdev_err(fdtv->device, \"DVB initialization failed\\n\");\n\treturn err;\n}\n\nvoid fdtv_dvb_unregister(struct firedtv *fdtv)\n{\n\tfdtv_ca_release(fdtv);\n\tdvb_unregister_frontend(&fdtv->fe);\n\tdvb_net_release(&fdtv->dvbnet);\n\tfdtv->demux.dmx.close(&fdtv->demux.dmx);\n\tfdtv->demux.dmx.remove_frontend(&fdtv->demux.dmx, &fdtv->frontend);\n\tdvb_dmxdev_release(&fdtv->dmxdev);\n\tdvb_dmx_release(&fdtv->demux);\n\tdvb_unregister_adapter(&fdtv->adapter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}