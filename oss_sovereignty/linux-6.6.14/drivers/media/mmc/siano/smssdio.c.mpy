{
  "module_name": "smssdio.c",
  "hash_id": "2a57b5232813b73c4609094d0658f9e75a00aa07377c2670e26d7dcbbc13e9a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mmc/siano/smssdio.c",
  "human_readable_source": "\n \n\n \n\n#include \"smscoreapi.h\"\n\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/module.h>\n\n#include \"sms-cards.h\"\n#include \"smsendian.h\"\n\n \n\n#define SMSSDIO_DATA\t\t0x00\n#define SMSSDIO_INT\t\t0x04\n#define SMSSDIO_BLOCK_SIZE\t128\n\nstatic const struct sdio_device_id smssdio_ids[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_STELLAR),\n\t .driver_data = SMS1XXX_BOARD_SIANO_STELLAR},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_NOVA_A0),\n\t .driver_data = SMS1XXX_BOARD_SIANO_NOVA_A},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_NOVA_B0),\n\t .driver_data = SMS1XXX_BOARD_SIANO_NOVA_B},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_VEGA_A0),\n\t .driver_data = SMS1XXX_BOARD_SIANO_VEGA},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_VENICE),\n\t .driver_data = SMS1XXX_BOARD_SIANO_VEGA},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_MING),\n\t.driver_data = SMS1XXX_BOARD_SIANO_MING},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_PELE),\n\t.driver_data = SMS1XXX_BOARD_SIANO_PELE},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_RIO),\n\t.driver_data = SMS1XXX_BOARD_SIANO_RIO},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_DENVER_2160),\n\t.driver_data = SMS1XXX_BOARD_SIANO_DENVER_2160},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_SIANO, SDIO_DEVICE_ID_SIANO_DENVER_1530),\n\t.driver_data = SMS1XXX_BOARD_SIANO_DENVER_1530},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(sdio, smssdio_ids);\n\nstruct smssdio_device {\n\tstruct sdio_func *func;\n\n\tstruct smscore_device_t *coredev;\n\n\tstruct smscore_buffer_t *split_cb;\n};\n\n \n \n \n\nstatic int smssdio_sendrequest(void *context, void *buffer, size_t size)\n{\n\tint ret = 0;\n\tstruct smssdio_device *smsdev;\n\n\tsmsdev = context;\n\n\tsdio_claim_host(smsdev->func);\n\n\tsmsendian_handle_tx_message((struct sms_msg_data *) buffer);\n\twhile (size >= smsdev->func->cur_blksize) {\n\t\tret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,\n\t\t\t\t\tbuffer, smsdev->func->cur_blksize);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbuffer += smsdev->func->cur_blksize;\n\t\tsize -= smsdev->func->cur_blksize;\n\t}\n\n\tif (size) {\n\t\tret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,\n\t\t\t\t\tbuffer, size);\n\t}\n\nout:\n\tsdio_release_host(smsdev->func);\n\n\treturn ret;\n}\n\n \n \n \n\nstatic void smssdio_interrupt(struct sdio_func *func)\n{\n\tint ret;\n\n\tstruct smssdio_device *smsdev;\n\tstruct smscore_buffer_t *cb;\n\tstruct sms_msg_hdr *hdr;\n\tsize_t size;\n\n\tsmsdev = sdio_get_drvdata(func);\n\n\t \n\t(void)sdio_readb(func, SMSSDIO_INT, &ret);\n\tif (ret) {\n\t\tpr_err(\"Unable to read interrupt register!\\n\");\n\t\treturn;\n\t}\n\n\tif (smsdev->split_cb == NULL) {\n\t\tcb = smscore_getbuffer(smsdev->coredev);\n\t\tif (!cb) {\n\t\t\tpr_err(\"Unable to allocate data buffer!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tret = sdio_memcpy_fromio(smsdev->func,\n\t\t\t\t\t cb->p,\n\t\t\t\t\t SMSSDIO_DATA,\n\t\t\t\t\t SMSSDIO_BLOCK_SIZE);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error %d reading initial block!\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = cb->p;\n\n\t\tif (hdr->msg_flags & MSG_HDR_FLAG_SPLIT_MSG) {\n\t\t\tsmsdev->split_cb = cb;\n\t\t\treturn;\n\t\t}\n\n\t\tif (hdr->msg_length > smsdev->func->cur_blksize)\n\t\t\tsize = hdr->msg_length - smsdev->func->cur_blksize;\n\t\telse\n\t\t\tsize = 0;\n\t} else {\n\t\tcb = smsdev->split_cb;\n\t\thdr = cb->p;\n\n\t\tsize = hdr->msg_length - sizeof(struct sms_msg_hdr);\n\n\t\tsmsdev->split_cb = NULL;\n\t}\n\n\tif (size) {\n\t\tvoid *buffer;\n\n\t\tbuffer = cb->p + (hdr->msg_length - size);\n\t\tsize = ALIGN(size, SMSSDIO_BLOCK_SIZE);\n\n\t\tBUG_ON(smsdev->func->cur_blksize != SMSSDIO_BLOCK_SIZE);\n\n\t\t \n\t\tret = sdio_memcpy_fromio(smsdev->func,\n\t\t\t\t\t buffer,\n\t\t\t\t\t SMSSDIO_DATA,\n\t\t\t\t\t size);\n\t\tif (ret && ret != -EINVAL) {\n\t\t\tsmscore_putbuffer(smsdev->coredev, cb);\n\t\t\tpr_err(\"Error %d reading data from card!\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ret == -EINVAL) {\n\t\t\twhile (size) {\n\t\t\t\tret = sdio_memcpy_fromio(smsdev->func,\n\t\t\t\t\t\t  buffer, SMSSDIO_DATA,\n\t\t\t\t\t\t  smsdev->func->cur_blksize);\n\t\t\t\tif (ret) {\n\t\t\t\t\tsmscore_putbuffer(smsdev->coredev, cb);\n\t\t\t\t\tpr_err(\"Error %d reading data from card!\\n\",\n\t\t\t\t\t       ret);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbuffer += smsdev->func->cur_blksize;\n\t\t\t\tif (size > smsdev->func->cur_blksize)\n\t\t\t\t\tsize -= smsdev->func->cur_blksize;\n\t\t\t\telse\n\t\t\t\t\tsize = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcb->size = hdr->msg_length;\n\tcb->offset = 0;\n\n\tsmsendian_handle_rx_message((struct sms_msg_data *) cb->p);\n\tsmscore_onresponse(smsdev->coredev, cb);\n}\n\nstatic int smssdio_probe(struct sdio_func *func,\n\t\t\t const struct sdio_device_id *id)\n{\n\tint ret;\n\n\tint board_id;\n\tstruct smssdio_device *smsdev;\n\tstruct smsdevice_params_t params;\n\n\tboard_id = id->driver_data;\n\n\tsmsdev = kzalloc(sizeof(struct smssdio_device), GFP_KERNEL);\n\tif (!smsdev)\n\t\treturn -ENOMEM;\n\n\tsmsdev->func = func;\n\n\tmemset(&params, 0, sizeof(struct smsdevice_params_t));\n\n\tparams.device = &func->dev;\n\tparams.buffer_size = 0x5000;\t \n\tparams.num_buffers = 22;\t \n\tparams.context = smsdev;\n\n\tsnprintf(params.devpath, sizeof(params.devpath),\n\t\t \"sdio\\\\%s\", sdio_func_id(func));\n\n\tparams.sendrequest_handler = smssdio_sendrequest;\n\n\tparams.device_type = sms_get_board(board_id)->type;\n\n\tif (params.device_type != SMS_STELLAR)\n\t\tparams.flags |= SMS_DEVICE_FAMILY2;\n\telse {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tret = smscore_register_device(&params, &smsdev->coredev, GFP_DMA, NULL);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tsmscore_set_board_id(smsdev->coredev, board_id);\n\n\tsdio_claim_host(func);\n\n\tret = sdio_enable_func(func);\n\tif (ret)\n\t\tgoto release;\n\n\tret = sdio_set_block_size(func, SMSSDIO_BLOCK_SIZE);\n\tif (ret)\n\t\tgoto disable;\n\n\tret = sdio_claim_irq(func, smssdio_interrupt);\n\tif (ret)\n\t\tgoto disable;\n\n\tsdio_set_drvdata(func, smsdev);\n\n\tsdio_release_host(func);\n\n\tret = smscore_start_device(smsdev->coredev);\n\tif (ret < 0)\n\t\tgoto reclaim;\n\n\treturn 0;\n\nreclaim:\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\ndisable:\n\tsdio_disable_func(func);\nrelease:\n\tsdio_release_host(func);\n\tsmscore_unregister_device(smsdev->coredev);\nfree:\n\tkfree(smsdev);\n\n\treturn ret;\n}\n\nstatic void smssdio_remove(struct sdio_func *func)\n{\n\tstruct smssdio_device *smsdev;\n\n\tsmsdev = sdio_get_drvdata(func);\n\n\t \n\tif (smsdev->split_cb)\n\t\tsmscore_putbuffer(smsdev->coredev, smsdev->split_cb);\n\n\tsmscore_unregister_device(smsdev->coredev);\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\n\tkfree(smsdev);\n}\n\nstatic struct sdio_driver smssdio_driver = {\n\t.name = \"smssdio\",\n\t.id_table = smssdio_ids,\n\t.probe = smssdio_probe,\n\t.remove = smssdio_remove,\n};\n\n \n \n \n\nstatic int __init smssdio_module_init(void)\n{\n\tint ret = 0;\n\n\tprintk(KERN_INFO \"smssdio: Siano SMS1xxx SDIO driver\\n\");\n\tprintk(KERN_INFO \"smssdio: Copyright Pierre Ossman\\n\");\n\n\tret = sdio_register_driver(&smssdio_driver);\n\n\treturn ret;\n}\n\nstatic void __exit smssdio_module_exit(void)\n{\n\tsdio_unregister_driver(&smssdio_driver);\n}\n\nmodule_init(smssdio_module_init);\nmodule_exit(smssdio_module_exit);\n\nMODULE_DESCRIPTION(\"Siano SMS1xxx SDIO driver\");\nMODULE_AUTHOR(\"Pierre Ossman\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}