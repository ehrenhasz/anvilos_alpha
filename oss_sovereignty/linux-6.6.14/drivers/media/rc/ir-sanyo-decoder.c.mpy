{
  "module_name": "ir-sanyo-decoder.c",
  "hash_id": "e9f588d988c36614bb98877e59a1342569c860878060a6d46753aa734b391f12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-sanyo-decoder.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/bitrev.h>\n#include \"rc-core-priv.h\"\n\n#define SANYO_NBITS\t\t(13+13+8+8)\n#define SANYO_UNIT\t\t563   \n#define SANYO_HEADER_PULSE\t(16  * SANYO_UNIT)\n#define SANYO_HEADER_SPACE\t(8   * SANYO_UNIT)\n#define SANYO_BIT_PULSE\t\t(1   * SANYO_UNIT)\n#define SANYO_BIT_0_SPACE\t(1   * SANYO_UNIT)\n#define SANYO_BIT_1_SPACE\t(3   * SANYO_UNIT)\n#define SANYO_REPEAT_SPACE\t(150 * SANYO_UNIT)\n#define\tSANYO_TRAILER_PULSE\t(1   * SANYO_UNIT)\n#define\tSANYO_TRAILER_SPACE\t(10  * SANYO_UNIT)\t \n\nenum sanyo_state {\n\tSTATE_INACTIVE,\n\tSTATE_HEADER_SPACE,\n\tSTATE_BIT_PULSE,\n\tSTATE_BIT_SPACE,\n\tSTATE_TRAILER_PULSE,\n\tSTATE_TRAILER_SPACE,\n};\n\n \nstatic int ir_sanyo_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct sanyo_dec *data = &dev->raw->sanyo;\n\tu32 scancode;\n\tu16 address;\n\tu8 command, not_command;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow) {\n\t\t\tdev_dbg(&dev->dev, \"SANYO event overflow received. reset to state 0\\n\");\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"SANYO decode started at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, SANYO_HEADER_PULSE, SANYO_UNIT / 2)) {\n\t\t\tdata->count = 0;\n\t\t\tdata->state = STATE_HEADER_SPACE;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\n\tcase STATE_HEADER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, SANYO_HEADER_SPACE, SANYO_UNIT / 2)) {\n\t\t\tdata->state = STATE_BIT_PULSE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase STATE_BIT_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SANYO_BIT_PULSE, SANYO_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!data->count && geq_margin(ev.duration, SANYO_REPEAT_SPACE, SANYO_UNIT / 2)) {\n\t\t\trc_repeat(dev);\n\t\t\tdev_dbg(&dev->dev, \"SANYO repeat last key\\n\");\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata->bits <<= 1;\n\t\tif (eq_margin(ev.duration, SANYO_BIT_1_SPACE, SANYO_UNIT / 2))\n\t\t\tdata->bits |= 1;\n\t\telse if (!eq_margin(ev.duration, SANYO_BIT_0_SPACE, SANYO_UNIT / 2))\n\t\t\tbreak;\n\t\tdata->count++;\n\n\t\tif (data->count == SANYO_NBITS)\n\t\t\tdata->state = STATE_TRAILER_PULSE;\n\t\telse\n\t\t\tdata->state = STATE_BIT_PULSE;\n\n\t\treturn 0;\n\n\tcase STATE_TRAILER_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SANYO_TRAILER_PULSE, SANYO_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_TRAILER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_TRAILER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, SANYO_TRAILER_SPACE, SANYO_UNIT / 2))\n\t\t\tbreak;\n\n\t\taddress     = bitrev16((data->bits >> 29) & 0x1fff) >> 3;\n\t\t \n\t\tcommand\t    = bitrev8((data->bits >>  8) & 0xff);\n\t\tnot_command = bitrev8((data->bits >>  0) & 0xff);\n\n\t\tif ((command ^ not_command) != 0xff) {\n\t\t\tdev_dbg(&dev->dev, \"SANYO checksum error: received 0x%08llx\\n\",\n\t\t\t\tdata->bits);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tscancode = address << 8 | command;\n\t\tdev_dbg(&dev->dev, \"SANYO scancode: 0x%06x\\n\", scancode);\n\t\trc_keydown(dev, RC_PROTO_SANYO, scancode, 0);\n\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"SANYO decode failed at count %d state %d (%uus %s)\\n\",\n\t\tdata->count, data->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const struct ir_raw_timings_pd ir_sanyo_timings = {\n\t.header_pulse  = SANYO_HEADER_PULSE,\n\t.header_space  = SANYO_HEADER_SPACE,\n\t.bit_pulse     = SANYO_BIT_PULSE,\n\t.bit_space[0]  = SANYO_BIT_0_SPACE,\n\t.bit_space[1]  = SANYO_BIT_1_SPACE,\n\t.trailer_pulse = SANYO_TRAILER_PULSE,\n\t.trailer_space = SANYO_TRAILER_SPACE,\n\t.msb_first     = 1,\n};\n\n \nstatic int ir_sanyo_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t   struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint ret;\n\tu64 raw;\n\n\traw = ((u64)(bitrev16(scancode >> 8) & 0xfff8) << (8 + 8 + 13 - 3)) |\n\t      ((u64)(bitrev16(~scancode >> 8) & 0xfff8) << (8 + 8 +  0 - 3)) |\n\t      ((bitrev8(scancode) & 0xff) << 8) |\n\t      (bitrev8(~scancode) & 0xff);\n\n\tret = ir_raw_gen_pd(&e, max, &ir_sanyo_timings, SANYO_NBITS, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler sanyo_handler = {\n\t.protocols\t= RC_PROTO_BIT_SANYO,\n\t.decode\t\t= ir_sanyo_decode,\n\t.encode\t\t= ir_sanyo_encode,\n\t.carrier\t= 38000,\n\t.min_timeout\t= SANYO_TRAILER_SPACE,\n};\n\nstatic int __init ir_sanyo_decode_init(void)\n{\n\tir_raw_handler_register(&sanyo_handler);\n\n\tprintk(KERN_INFO \"IR SANYO protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_sanyo_decode_exit(void)\n{\n\tir_raw_handler_unregister(&sanyo_handler);\n}\n\nmodule_init(ir_sanyo_decode_init);\nmodule_exit(ir_sanyo_decode_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Red Hat Inc. (http://www.redhat.com)\");\nMODULE_DESCRIPTION(\"SANYO IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}