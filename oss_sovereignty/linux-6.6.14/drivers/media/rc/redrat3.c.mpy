{
  "module_name": "redrat3.c",
  "hash_id": "5f812d0de758f96d946161de8bb97648bcf9361bbf85280c5b49ccd9f5121391",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/redrat3.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/device.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n \n#define DRIVER_AUTHOR \"Jarod Wilson <jarod@redhat.com>\"\n#define DRIVER_AUTHOR2 \"The Dweller, Stephen Cox\"\n#define DRIVER_DESC \"RedRat3 USB IR Transceiver Driver\"\n#define DRIVER_NAME \"redrat3\"\n\n \n#define RR3_ERROR\t\t0x01\n#define RR3_MOD_SIGNAL_IN\t0x20\n#define RR3_MOD_SIGNAL_OUT\t0x21\n\n \n#define RR3_FW_VERSION\t\t0xb1\n#define RR3_FW_VERSION_LEN\t64\n \n#define RR3_TX_SEND_SIGNAL\t0xb3\n#define RR3_SET_IR_PARAM\t0xb7\n#define RR3_GET_IR_PARAM\t0xb8\n \n#define RR3_BLINK_LED\t\t0xb9\n \n#define RR3_READ_SER_NO\t\t0xba\n#define RR3_SER_NO_LEN\t\t4\n \n#define RR3_RC_DET_ENABLE\t0xbb\n \n#define RR3_RC_DET_DISABLE\t0xbc\n \n#define RR3_MODSIG_CAPTURE     0xb2\n \n#define RR3_RC_DET_STATUS\t0xbd\n \n#define RR3_RESET\t\t0xa0\n\n \n#define RR3_IR_IO_MAX_LENGTHS\t0x01\n \n#define RR3_IR_IO_PERIODS_MF\t0x02\n \n#define RR3_IR_IO_SIG_MEM_SIZE\t0x03\n \n#define RR3_IR_IO_LENGTH_FUZZ\t0x04\n \n#define RR3_IR_IO_SIG_TIMEOUT\t0x05\n \n#define RR3_IR_IO_MIN_PAUSE\t0x06\n\n \n#define RR3_CLK\t\t\t24000000\n \n#define RR3_CLK_PER_COUNT\t12\n \n#define RR3_CLK_CONV_FACTOR\t2000000\n \n#define RR3_WIDE_IN_EP_ADDR\t0x81\n \n#define RR3_NARROW_IN_EP_ADDR\t0x82\n\n \n#define RR3_DRIVER_MAXLENS\t255\n#define RR3_MAX_SIG_SIZE\t512\n#define RR3_TIME_UNIT\t\t50\n#define RR3_END_OF_SIGNAL\t0x7f\n#define RR3_TX_TRAILER_LEN\t2\n#define RR3_RX_MIN_TIMEOUT\t5\n#define RR3_RX_MAX_TIMEOUT\t2000\n\n \n#define RR3_CPUCS_REG_ADDR\t0x7f92\n\n#define USB_RR3USB_VENDOR_ID\t0x112a\n#define USB_RR3USB_PRODUCT_ID\t0x0001\n#define USB_RR3IIUSB_PRODUCT_ID\t0x0005\n\n\n \nstatic int length_fuzz = 5;\nmodule_param(length_fuzz, uint, 0644);\nMODULE_PARM_DESC(length_fuzz, \"Length Fuzz (0-127)\");\n\n \nstatic int minimum_pause = 18;\nmodule_param(minimum_pause, uint, 0644);\nMODULE_PARM_DESC(minimum_pause, \"Minimum Pause in ms (2-30)\");\n\n \nstatic int periods_measure_carrier = 8;\nmodule_param(periods_measure_carrier, uint, 0644);\nMODULE_PARM_DESC(periods_measure_carrier, \"Number of Periods to Measure Carrier (1-255)\");\n\n\nstruct redrat3_header {\n\t__be16 length;\n\t__be16 transfer_type;\n} __packed;\n\n \nstruct redrat3_irdata {\n\tstruct redrat3_header header;\n\t__be32 pause;\n\t__be16 mod_freq_count;\n\t__be16 num_periods;\n\t__u8 max_lengths;\n\t__u8 no_lengths;\n\t__be16 max_sig_size;\n\t__be16 sig_size;\n\t__u8 no_repeats;\n\t__be16 lens[RR3_DRIVER_MAXLENS];  \n\t__u8 sigdata[RR3_MAX_SIG_SIZE];\n} __packed;\n\n \nstruct redrat3_error {\n\tstruct redrat3_header header;\n\t__be16 fw_error;\n} __packed;\n\n \nstatic const struct usb_device_id redrat3_dev_table[] = {\n\t \n\t{USB_DEVICE(USB_RR3USB_VENDOR_ID, USB_RR3USB_PRODUCT_ID)},\n\t \n\t{USB_DEVICE(USB_RR3USB_VENDOR_ID, USB_RR3IIUSB_PRODUCT_ID)},\n\t{}\t\t\t \n};\n\n \nstruct redrat3_dev {\n\t \n\tstruct rc_dev *rc;\n\tstruct device *dev;\n\n\t \n\tstruct led_classdev led;\n\tatomic_t flash;\n\tstruct usb_ctrlrequest flash_control;\n\tstruct urb *flash_urb;\n\tu8 flash_in_buf;\n\n\t \n\tbool wideband;\n\tstruct usb_ctrlrequest learn_control;\n\tstruct urb *learn_urb;\n\tu8 learn_buf;\n\n\t \n\tstruct usb_device *udev;\n\n\t \n\tstruct usb_endpoint_descriptor *ep_narrow;\n\t \n\tvoid *bulk_in_buf;\n\t \n\tstruct urb *narrow_urb;\n\tstruct urb *wide_urb;\n\n\t \n\tstruct usb_endpoint_descriptor *ep_out;\n\n\t \n\tdma_addr_t dma_in;\n\n\t \n\tbool transmitting;\n\n\t \n\tstruct redrat3_irdata irdata;\n\tu16 bytes_read;\n\n\tu32 carrier;\n\n\tchar name[64];\n\tchar phys[64];\n};\n\nstatic void redrat3_dump_fw_error(struct redrat3_dev *rr3, int code)\n{\n\tif (!rr3->transmitting && (code != 0x40))\n\t\tdev_info(rr3->dev, \"fw error code 0x%02x: \", code);\n\n\tswitch (code) {\n\tcase 0x00:\n\t\tpr_cont(\"No Error\\n\");\n\t\tbreak;\n\n\t \n\tcase 0x20:\n\t\tpr_cont(\"Initial signal pulse not long enough to measure carrier frequency\\n\");\n\t\tbreak;\n\tcase 0x21:\n\t\tpr_cont(\"Not enough length values allocated for signal\\n\");\n\t\tbreak;\n\tcase 0x22:\n\t\tpr_cont(\"Not enough memory allocated for signal data\\n\");\n\t\tbreak;\n\tcase 0x23:\n\t\tpr_cont(\"Too many signal repeats\\n\");\n\t\tbreak;\n\tcase 0x28:\n\t\tpr_cont(\"Insufficient memory available for IR signal data memory allocation\\n\");\n\t\tbreak;\n\tcase 0x29:\n\t\tpr_cont(\"Insufficient memory available for IrDa signal data memory allocation\\n\");\n\t\tbreak;\n\n\t \n\tcase 0x30:\n\t\tpr_cont(\"Insufficient memory available for bulk transfer structure\\n\");\n\t\tbreak;\n\n\t \n\tcase 0x40:\n\t\tif (!rr3->transmitting)\n\t\t\tpr_cont(\"Signal capture has been terminated\\n\");\n\t\tbreak;\n\tcase 0x41:\n\t\tpr_cont(\"Attempt to set/get and unknown signal I/O algorithm parameter\\n\");\n\t\tbreak;\n\tcase 0x42:\n\t\tpr_cont(\"Signal capture already started\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\"Unknown Error\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic u32 redrat3_val_to_mod_freq(struct redrat3_irdata *irdata)\n{\n\tu32 mod_freq = 0;\n\tu16 mod_freq_count = be16_to_cpu(irdata->mod_freq_count);\n\n\tif (mod_freq_count != 0)\n\t\tmod_freq = (RR3_CLK * be16_to_cpu(irdata->num_periods)) /\n\t\t\t(mod_freq_count * RR3_CLK_PER_COUNT);\n\n\treturn mod_freq;\n}\n\n \nstatic u32 redrat3_len_to_us(u32 length)\n{\n\tu32 biglen = length * 1000;\n\tu32 divisor = (RR3_CLK_CONV_FACTOR) / 1000;\n\tu32 result = (u32) (biglen / divisor);\n\n\t \n\treturn result ? result : 1;\n}\n\n \nstatic u32 redrat3_us_to_len(u32 microsec)\n{\n\tu32 result;\n\tu32 divisor;\n\n\tmicrosec = (microsec > IR_MAX_DURATION) ? IR_MAX_DURATION : microsec;\n\tdivisor = (RR3_CLK_CONV_FACTOR / 1000);\n\tresult = (u32)(microsec * divisor) / 1000;\n\n\t \n\treturn result ? result : 1;\n}\n\nstatic void redrat3_process_ir_data(struct redrat3_dev *rr3)\n{\n\tstruct ir_raw_event rawir = {};\n\tstruct device *dev;\n\tunsigned int i, sig_size, offset, val;\n\tu32 mod_freq;\n\n\tdev = rr3->dev;\n\n\tmod_freq = redrat3_val_to_mod_freq(&rr3->irdata);\n\tdev_dbg(dev, \"Got mod_freq of %u\\n\", mod_freq);\n\tif (mod_freq && rr3->wideband) {\n\t\tstruct ir_raw_event ev = {\n\t\t\t.carrier_report = 1,\n\t\t\t.carrier = mod_freq\n\t\t};\n\n\t\tir_raw_event_store(rr3->rc, &ev);\n\t}\n\n\t \n\tsig_size = be16_to_cpu(rr3->irdata.sig_size);\n\tfor (i = 0; i < sig_size; i++) {\n\t\toffset = rr3->irdata.sigdata[i];\n\t\tval = get_unaligned_be16(&rr3->irdata.lens[offset]);\n\n\t\t \n\t\tif (i % 2)\n\t\t\trawir.pulse = false;\n\t\telse\n\t\t\trawir.pulse = true;\n\n\t\trawir.duration = redrat3_len_to_us(val);\n\t\t \n\t\trawir.duration = (rawir.duration > IR_MAX_DURATION) ?\n\t\t\t\t IR_MAX_DURATION : rawir.duration;\n\n\t\tdev_dbg(dev, \"storing %s with duration %d (i: %d)\\n\",\n\t\t\trawir.pulse ? \"pulse\" : \"space\", rawir.duration, i);\n\t\tir_raw_event_store_with_filter(rr3->rc, &rawir);\n\t}\n\n\t \n\trawir.pulse = false;\n\trawir.timeout = true;\n\trawir.duration = rr3->rc->timeout;\n\tdev_dbg(dev, \"storing trailing timeout with duration %d\\n\",\n\t\t\t\t\t\t\trawir.duration);\n\tir_raw_event_store_with_filter(rr3->rc, &rawir);\n\n\tdev_dbg(dev, \"calling ir_raw_event_handle\\n\");\n\tir_raw_event_handle(rr3->rc);\n}\n\n \nstatic int redrat3_send_cmd(int cmd, struct redrat3_dev *rr3)\n{\n\tstruct usb_device *udev;\n\tu8 *data;\n\tint res;\n\n\tdata = kzalloc(sizeof(u8), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tudev = rr3->udev;\n\tres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), cmd,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t      0x0000, 0x0000, data, sizeof(u8), 10000);\n\n\tif (res < 0) {\n\t\tdev_err(rr3->dev, \"%s: Error sending rr3 cmd res %d, data %d\",\n\t\t\t__func__, res, *data);\n\t\tres = -EIO;\n\t} else\n\t\tres = data[0];\n\n\tkfree(data);\n\n\treturn res;\n}\n\n \nstatic int redrat3_enable_detector(struct redrat3_dev *rr3)\n{\n\tstruct device *dev = rr3->dev;\n\tu8 ret;\n\n\tret = redrat3_send_cmd(RR3_RC_DET_ENABLE, rr3);\n\tif (ret != 0)\n\t\tdev_dbg(dev, \"%s: unexpected ret of %d\\n\",\n\t\t\t__func__, ret);\n\n\tret = redrat3_send_cmd(RR3_RC_DET_STATUS, rr3);\n\tif (ret != 1) {\n\t\tdev_err(dev, \"%s: detector status: %d, should be 1\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EIO;\n\t}\n\n\tret = usb_submit_urb(rr3->narrow_urb, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(rr3->dev, \"narrow band urb failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = usb_submit_urb(rr3->wide_urb, GFP_KERNEL);\n\tif (ret)\n\t\tdev_err(rr3->dev, \"wide band urb failed: %d\", ret);\n\n\treturn ret;\n}\n\nstatic inline void redrat3_delete(struct redrat3_dev *rr3,\n\t\t\t\t  struct usb_device *udev)\n{\n\tusb_kill_urb(rr3->narrow_urb);\n\tusb_kill_urb(rr3->wide_urb);\n\tusb_kill_urb(rr3->flash_urb);\n\tusb_kill_urb(rr3->learn_urb);\n\tusb_free_urb(rr3->narrow_urb);\n\tusb_free_urb(rr3->wide_urb);\n\tusb_free_urb(rr3->flash_urb);\n\tusb_free_urb(rr3->learn_urb);\n\tusb_free_coherent(udev, le16_to_cpu(rr3->ep_narrow->wMaxPacketSize),\n\t\t\t  rr3->bulk_in_buf, rr3->dma_in);\n\n\tkfree(rr3);\n}\n\nstatic u32 redrat3_get_timeout(struct redrat3_dev *rr3)\n{\n\t__be32 *tmp;\n\tu32 timeout = MS_TO_US(150);  \n\tint len, ret, pipe;\n\n\tlen = sizeof(*tmp);\n\ttmp = kzalloc(len, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn timeout;\n\n\tpipe = usb_rcvctrlpipe(rr3->udev, 0);\n\tret = usb_control_msg(rr3->udev, pipe, RR3_GET_IR_PARAM,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t      RR3_IR_IO_SIG_TIMEOUT, 0, tmp, len, 5000);\n\tif (ret != len)\n\t\tdev_warn(rr3->dev, \"Failed to read timeout from hardware\\n\");\n\telse {\n\t\ttimeout = redrat3_len_to_us(be32_to_cpup(tmp));\n\n\t\tdev_dbg(rr3->dev, \"Got timeout of %d ms\\n\", timeout / 1000);\n\t}\n\n\tkfree(tmp);\n\n\treturn timeout;\n}\n\nstatic int redrat3_set_timeout(struct rc_dev *rc_dev, unsigned int timeoutus)\n{\n\tstruct redrat3_dev *rr3 = rc_dev->priv;\n\tstruct usb_device *udev = rr3->udev;\n\tstruct device *dev = rr3->dev;\n\t__be32 *timeout;\n\tint ret;\n\n\ttimeout = kmalloc(sizeof(*timeout), GFP_KERNEL);\n\tif (!timeout)\n\t\treturn -ENOMEM;\n\n\t*timeout = cpu_to_be32(redrat3_us_to_len(timeoutus));\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), RR3_SET_IR_PARAM,\n\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t     RR3_IR_IO_SIG_TIMEOUT, 0, timeout, sizeof(*timeout),\n\t\t     25000);\n\tdev_dbg(dev, \"set ir parm timeout %d ret 0x%02x\\n\",\n\t\t\t\t\t\tbe32_to_cpu(*timeout), ret);\n\n\tif (ret == sizeof(*timeout))\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\tkfree(timeout);\n\n\treturn ret;\n}\n\nstatic void redrat3_reset(struct redrat3_dev *rr3)\n{\n\tstruct usb_device *udev = rr3->udev;\n\tstruct device *dev = rr3->dev;\n\tint rc, rxpipe, txpipe;\n\tu8 *val;\n\tsize_t const len = sizeof(*val);\n\n\trxpipe = usb_rcvctrlpipe(udev, 0);\n\ttxpipe = usb_sndctrlpipe(udev, 0);\n\n\tval = kmalloc(len, GFP_KERNEL);\n\tif (!val)\n\t\treturn;\n\n\t*val = 0x01;\n\trc = usb_control_msg(udev, rxpipe, RR3_RESET,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t     RR3_CPUCS_REG_ADDR, 0, val, len, 25000);\n\tdev_dbg(dev, \"reset returned 0x%02x\\n\", rc);\n\n\t*val = length_fuzz;\n\trc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t     RR3_IR_IO_LENGTH_FUZZ, 0, val, len, 25000);\n\tdev_dbg(dev, \"set ir parm len fuzz %d rc 0x%02x\\n\", *val, rc);\n\n\t*val = (65536 - (minimum_pause * 2000)) / 256;\n\trc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t     RR3_IR_IO_MIN_PAUSE, 0, val, len, 25000);\n\tdev_dbg(dev, \"set ir parm min pause %d rc 0x%02x\\n\", *val, rc);\n\n\t*val = periods_measure_carrier;\n\trc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t     RR3_IR_IO_PERIODS_MF, 0, val, len, 25000);\n\tdev_dbg(dev, \"set ir parm periods measure carrier %d rc 0x%02x\", *val,\n\t\t\t\t\t\t\t\t\trc);\n\n\t*val = RR3_DRIVER_MAXLENS;\n\trc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t     RR3_IR_IO_MAX_LENGTHS, 0, val, len, 25000);\n\tdev_dbg(dev, \"set ir parm max lens %d rc 0x%02x\\n\", *val, rc);\n\n\tkfree(val);\n}\n\nstatic void redrat3_get_firmware_rev(struct redrat3_dev *rr3)\n{\n\tint rc;\n\tchar *buffer;\n\n\tbuffer = kcalloc(RR3_FW_VERSION_LEN + 1, sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn;\n\n\trc = usb_control_msg(rr3->udev, usb_rcvctrlpipe(rr3->udev, 0),\n\t\t\t     RR3_FW_VERSION,\n\t\t\t     USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t     0, 0, buffer, RR3_FW_VERSION_LEN, 5000);\n\n\tif (rc >= 0)\n\t\tdev_info(rr3->dev, \"Firmware rev: %s\", buffer);\n\telse\n\t\tdev_err(rr3->dev, \"Problem fetching firmware ID\\n\");\n\n\tkfree(buffer);\n}\n\nstatic void redrat3_read_packet_start(struct redrat3_dev *rr3, unsigned len)\n{\n\tstruct redrat3_header *header = rr3->bulk_in_buf;\n\tunsigned pktlen, pkttype;\n\n\t \n\tpktlen = be16_to_cpu(header->length);\n\tpkttype = be16_to_cpu(header->transfer_type);\n\n\tif (pktlen > sizeof(rr3->irdata)) {\n\t\tdev_warn(rr3->dev, \"packet length %u too large\\n\", pktlen);\n\t\treturn;\n\t}\n\n\tswitch (pkttype) {\n\tcase RR3_ERROR:\n\t\tif (len >= sizeof(struct redrat3_error)) {\n\t\t\tstruct redrat3_error *error = rr3->bulk_in_buf;\n\t\t\tunsigned fw_error = be16_to_cpu(error->fw_error);\n\t\t\tredrat3_dump_fw_error(rr3, fw_error);\n\t\t}\n\t\tbreak;\n\n\tcase RR3_MOD_SIGNAL_IN:\n\t\tmemcpy(&rr3->irdata, rr3->bulk_in_buf, len);\n\t\trr3->bytes_read = len;\n\t\tdev_dbg(rr3->dev, \"bytes_read %d, pktlen %d\\n\",\n\t\t\trr3->bytes_read, pktlen);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(rr3->dev, \"ignoring packet with type 0x%02x, len of %d, 0x%02x\\n\",\n\t\t\t\t\t\tpkttype, len, pktlen);\n\t\tbreak;\n\t}\n}\n\nstatic void redrat3_read_packet_continue(struct redrat3_dev *rr3, unsigned len)\n{\n\tvoid *irdata = &rr3->irdata;\n\n\tif (len + rr3->bytes_read > sizeof(rr3->irdata)) {\n\t\tdev_warn(rr3->dev, \"too much data for packet\\n\");\n\t\trr3->bytes_read = 0;\n\t\treturn;\n\t}\n\n\tmemcpy(irdata + rr3->bytes_read, rr3->bulk_in_buf, len);\n\n\trr3->bytes_read += len;\n\tdev_dbg(rr3->dev, \"bytes_read %d, pktlen %d\\n\", rr3->bytes_read,\n\t\t\t\t be16_to_cpu(rr3->irdata.header.length));\n}\n\n \nstatic int redrat3_get_ir_data(struct redrat3_dev *rr3, unsigned len)\n{\n\tstruct device *dev = rr3->dev;\n\tunsigned pkttype;\n\tint ret = 0;\n\n\tif (rr3->bytes_read == 0 && len >= sizeof(struct redrat3_header)) {\n\t\tredrat3_read_packet_start(rr3, len);\n\t} else if (rr3->bytes_read != 0) {\n\t\tredrat3_read_packet_continue(rr3, len);\n\t} else if (rr3->bytes_read == 0) {\n\t\tdev_err(dev, \"error: no packet data read\\n\");\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tif (rr3->bytes_read < be16_to_cpu(rr3->irdata.header.length) +\n\t\t\t\t\t\tsizeof(struct redrat3_header))\n\t\t \n\t\treturn 0;\n\n\t \n\tpkttype = be16_to_cpu(rr3->irdata.header.transfer_type);\n\tif (pkttype == RR3_MOD_SIGNAL_IN)\n\t\tredrat3_process_ir_data(rr3);\n\telse\n\t\tdev_dbg(dev, \"discarding non-signal data packet (type 0x%02x)\\n\",\n\t\t\t\t\t\t\t\tpkttype);\n\nout:\n\trr3->bytes_read = 0;\n\treturn ret;\n}\n\n \nstatic void redrat3_handle_async(struct urb *urb)\n{\n\tstruct redrat3_dev *rr3 = urb->context;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tret = redrat3_get_ir_data(rr3, urb->actual_length);\n\t\tif (!ret && rr3->wideband && !rr3->learn_urb->hcpriv) {\n\t\t\tret = usb_submit_urb(rr3->learn_urb, GFP_ATOMIC);\n\t\t\tif (ret)\n\t\t\t\tdev_err(rr3->dev, \"Failed to submit learning urb: %d\",\n\t\t\t\t\t\t\t\t\tret);\n\t\t}\n\n\t\tif (!ret) {\n\t\t\t \n\t\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\t\tif (ret)\n\t\t\t\tdev_err(rr3->dev, \"Failed to resubmit urb: %d\",\n\t\t\t\t\t\t\t\t\tret);\n\t\t}\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_warn(rr3->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\trr3->bytes_read = 0;\n\t\tbreak;\n\t}\n}\n\nstatic u16 mod_freq_to_val(unsigned int mod_freq)\n{\n\tint mult = 6000000;\n\n\t \n\treturn 65536 - (mult / mod_freq);\n}\n\nstatic int redrat3_set_tx_carrier(struct rc_dev *rcdev, u32 carrier)\n{\n\tstruct redrat3_dev *rr3 = rcdev->priv;\n\tstruct device *dev = rr3->dev;\n\n\tdev_dbg(dev, \"Setting modulation frequency to %u\", carrier);\n\tif (carrier == 0)\n\t\treturn -EINVAL;\n\n\trr3->carrier = carrier;\n\n\treturn 0;\n}\n\nstatic int redrat3_transmit_ir(struct rc_dev *rcdev, unsigned *txbuf,\n\t\t\t\tunsigned count)\n{\n\tstruct redrat3_dev *rr3 = rcdev->priv;\n\tstruct device *dev = rr3->dev;\n\tstruct redrat3_irdata *irdata = NULL;\n\tint ret, ret_len;\n\tint lencheck, cur_sample_len, pipe;\n\tint *sample_lens = NULL;\n\tu8 curlencheck = 0;\n\tunsigned i, sendbuf_len;\n\n\tif (rr3->transmitting) {\n\t\tdev_warn(dev, \"%s: transmitter already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (count > RR3_MAX_SIG_SIZE - RR3_TX_TRAILER_LEN)\n\t\treturn -EINVAL;\n\n\t \n\trr3->transmitting = true;\n\n\tsample_lens = kcalloc(RR3_DRIVER_MAXLENS,\n\t\t\t      sizeof(*sample_lens),\n\t\t\t      GFP_KERNEL);\n\tif (!sample_lens)\n\t\treturn -ENOMEM;\n\n\tirdata = kzalloc(sizeof(*irdata), GFP_KERNEL);\n\tif (!irdata) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tcur_sample_len = redrat3_us_to_len(txbuf[i]);\n\t\tif (cur_sample_len > 0xffff) {\n\t\t\tdev_warn(dev, \"transmit period of %uus truncated to %uus\\n\",\n\t\t\t\t\ttxbuf[i], redrat3_len_to_us(0xffff));\n\t\t\tcur_sample_len = 0xffff;\n\t\t}\n\t\tfor (lencheck = 0; lencheck < curlencheck; lencheck++) {\n\t\t\tif (sample_lens[lencheck] == cur_sample_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (lencheck == curlencheck) {\n\t\t\tdev_dbg(dev, \"txbuf[%d]=%u, pos %d, enc %u\\n\",\n\t\t\t\ti, txbuf[i], curlencheck, cur_sample_len);\n\t\t\tif (curlencheck < RR3_DRIVER_MAXLENS) {\n\t\t\t\t \n\t\t\t\tsample_lens[curlencheck] = cur_sample_len;\n\t\t\t\tput_unaligned_be16(cur_sample_len,\n\t\t\t\t\t\t&irdata->lens[curlencheck]);\n\t\t\t\tcurlencheck++;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tirdata->sigdata[i] = lencheck;\n\t}\n\n\tirdata->sigdata[count] = RR3_END_OF_SIGNAL;\n\tirdata->sigdata[count + 1] = RR3_END_OF_SIGNAL;\n\n\tsendbuf_len = offsetof(struct redrat3_irdata,\n\t\t\t\t\tsigdata[count + RR3_TX_TRAILER_LEN]);\n\t \n\tirdata->header.length = cpu_to_be16(sendbuf_len -\n\t\t\t\t\t\tsizeof(struct redrat3_header));\n\tirdata->header.transfer_type = cpu_to_be16(RR3_MOD_SIGNAL_OUT);\n\tirdata->pause = cpu_to_be32(redrat3_len_to_us(100));\n\tirdata->mod_freq_count = cpu_to_be16(mod_freq_to_val(rr3->carrier));\n\tirdata->no_lengths = curlencheck;\n\tirdata->sig_size = cpu_to_be16(count + RR3_TX_TRAILER_LEN);\n\n\tpipe = usb_sndbulkpipe(rr3->udev, rr3->ep_out->bEndpointAddress);\n\tret = usb_bulk_msg(rr3->udev, pipe, irdata,\n\t\t\t    sendbuf_len, &ret_len, 10000);\n\tdev_dbg(dev, \"sent %d bytes, (ret %d)\\n\", ret_len, ret);\n\n\t \n\tpipe = usb_rcvctrlpipe(rr3->udev, 0);\n\tret = usb_control_msg(rr3->udev, pipe, RR3_TX_SEND_SIGNAL,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t      0, 0, irdata, 2, 10000);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Error: control msg send failed, rc %d\\n\", ret);\n\telse\n\t\tret = count;\n\nout:\n\tkfree(irdata);\n\tkfree(sample_lens);\n\n\trr3->transmitting = false;\n\t \n\n\treturn ret;\n}\n\nstatic void redrat3_brightness_set(struct led_classdev *led_dev, enum\n\t\t\t\t\t\tled_brightness brightness)\n{\n\tstruct redrat3_dev *rr3 = container_of(led_dev, struct redrat3_dev,\n\t\t\t\t\t\t\t\t\tled);\n\n\tif (brightness != LED_OFF && atomic_cmpxchg(&rr3->flash, 0, 1) == 0) {\n\t\tint ret = usb_submit_urb(rr3->flash_urb, GFP_ATOMIC);\n\t\tif (ret != 0) {\n\t\t\tdev_dbg(rr3->dev, \"%s: unexpected ret of %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tatomic_set(&rr3->flash, 0);\n\t\t}\n\t}\n}\n\nstatic int redrat3_wideband_receiver(struct rc_dev *rcdev, int enable)\n{\n\tstruct redrat3_dev *rr3 = rcdev->priv;\n\tint ret = 0;\n\n\trr3->wideband = enable != 0;\n\n\tif (enable) {\n\t\tret = usb_submit_urb(rr3->learn_urb, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tdev_err(rr3->dev, \"Failed to submit learning urb: %d\",\n\t\t\t\t\t\t\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\nstatic void redrat3_learn_complete(struct urb *urb)\n{\n\tstruct redrat3_dev *rr3 = urb->context;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_err(rr3->dev, \"Error: learn urb status = %d\", urb->status);\n\t\tbreak;\n\t}\n}\n\nstatic void redrat3_led_complete(struct urb *urb)\n{\n\tstruct redrat3_dev *rr3 = urb->context;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_dbg(rr3->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\trr3->led.brightness = LED_OFF;\n\tatomic_dec(&rr3->flash);\n}\n\nstatic struct rc_dev *redrat3_init_rc_dev(struct redrat3_dev *rr3)\n{\n\tstruct device *dev = rr3->dev;\n\tstruct rc_dev *rc;\n\tint ret;\n\tu16 prod = le16_to_cpu(rr3->udev->descriptor.idProduct);\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc)\n\t\treturn NULL;\n\n\tsnprintf(rr3->name, sizeof(rr3->name),\n\t\t \"RedRat3%s Infrared Remote Transceiver\",\n\t\t prod == USB_RR3IIUSB_PRODUCT_ID ? \"-II\" : \"\");\n\n\tusb_make_path(rr3->udev, rr3->phys, sizeof(rr3->phys));\n\n\trc->device_name = rr3->name;\n\trc->input_phys = rr3->phys;\n\tusb_to_input_id(rr3->udev, &rc->input_id);\n\trc->dev.parent = dev;\n\trc->priv = rr3;\n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->min_timeout = MS_TO_US(RR3_RX_MIN_TIMEOUT);\n\trc->max_timeout = MS_TO_US(RR3_RX_MAX_TIMEOUT);\n\trc->timeout = redrat3_get_timeout(rr3);\n\trc->s_timeout = redrat3_set_timeout;\n\trc->tx_ir = redrat3_transmit_ir;\n\trc->s_tx_carrier = redrat3_set_tx_carrier;\n\trc->s_carrier_report = redrat3_wideband_receiver;\n\trc->driver_name = DRIVER_NAME;\n\trc->rx_resolution = 2;\n\trc->map_name = RC_MAP_HAUPPAUGE;\n\n\tret = rc_register_device(rc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"remote dev registration failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn rc;\n\nout:\n\trc_free_device(rc);\n\treturn NULL;\n}\n\nstatic int redrat3_dev_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct device *dev = &intf->dev;\n\tstruct usb_host_interface *uhi;\n\tstruct redrat3_dev *rr3;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_endpoint_descriptor *ep_narrow = NULL;\n\tstruct usb_endpoint_descriptor *ep_wide = NULL;\n\tstruct usb_endpoint_descriptor *ep_out = NULL;\n\tu8 addr, attrs;\n\tint pipe, i;\n\tint retval = -ENOMEM;\n\n\tuhi = intf->cur_altsetting;\n\n\t \n\tfor (i = 0; i < uhi->desc.bNumEndpoints; ++i) {\n\t\tep = &uhi->endpoint[i].desc;\n\t\taddr = ep->bEndpointAddress;\n\t\tattrs = ep->bmAttributes;\n\n\t\tif (((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) &&\n\t\t    ((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t     USB_ENDPOINT_XFER_BULK)) {\n\t\t\tdev_dbg(dev, \"found bulk-in endpoint at 0x%02x\\n\",\n\t\t\t\tep->bEndpointAddress);\n\t\t\t \n\t\t\tif (ep->bEndpointAddress == RR3_NARROW_IN_EP_ADDR)\n\t\t\t\tep_narrow = ep;\n\t\t\tif (ep->bEndpointAddress == RR3_WIDE_IN_EP_ADDR)\n\t\t\t\tep_wide = ep;\n\t\t}\n\n\t\tif ((ep_out == NULL) &&\n\t\t    ((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) &&\n\t\t    ((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t     USB_ENDPOINT_XFER_BULK)) {\n\t\t\tdev_dbg(dev, \"found bulk-out endpoint at 0x%02x\\n\",\n\t\t\t\tep->bEndpointAddress);\n\t\t\tep_out = ep;\n\t\t}\n\t}\n\n\tif (!ep_narrow || !ep_out || !ep_wide) {\n\t\tdev_err(dev, \"Couldn't find all endpoints\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto no_endpoints;\n\t}\n\n\t \n\trr3 = kzalloc(sizeof(*rr3), GFP_KERNEL);\n\tif (!rr3)\n\t\tgoto no_endpoints;\n\n\trr3->dev = &intf->dev;\n\trr3->ep_narrow = ep_narrow;\n\trr3->ep_out = ep_out;\n\trr3->udev = udev;\n\n\t \n\trr3->narrow_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rr3->narrow_urb)\n\t\tgoto redrat_free;\n\n\trr3->wide_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rr3->wide_urb)\n\t\tgoto redrat_free;\n\n\trr3->bulk_in_buf = usb_alloc_coherent(udev,\n\t\tle16_to_cpu(ep_narrow->wMaxPacketSize),\n\t\tGFP_KERNEL, &rr3->dma_in);\n\tif (!rr3->bulk_in_buf)\n\t\tgoto redrat_free;\n\n\tpipe = usb_rcvbulkpipe(udev, ep_narrow->bEndpointAddress);\n\tusb_fill_bulk_urb(rr3->narrow_urb, udev, pipe, rr3->bulk_in_buf,\n\t\tle16_to_cpu(ep_narrow->wMaxPacketSize),\n\t\tredrat3_handle_async, rr3);\n\trr3->narrow_urb->transfer_dma = rr3->dma_in;\n\trr3->narrow_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tpipe = usb_rcvbulkpipe(udev, ep_wide->bEndpointAddress);\n\tusb_fill_bulk_urb(rr3->wide_urb, udev, pipe, rr3->bulk_in_buf,\n\t\tle16_to_cpu(ep_narrow->wMaxPacketSize),\n\t\tredrat3_handle_async, rr3);\n\trr3->wide_urb->transfer_dma = rr3->dma_in;\n\trr3->wide_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tredrat3_reset(rr3);\n\tredrat3_get_firmware_rev(rr3);\n\n\t \n\trr3->carrier = 38000;\n\n\tatomic_set(&rr3->flash, 0);\n\trr3->flash_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rr3->flash_urb)\n\t\tgoto redrat_free;\n\n\t \n\trr3->learn_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rr3->learn_urb)\n\t\tgoto redrat_free;\n\n\t \n\trr3->learn_control.bRequestType = 0xc0;\n\trr3->learn_control.bRequest = RR3_MODSIG_CAPTURE;\n\trr3->learn_control.wLength = cpu_to_le16(1);\n\n\tusb_fill_control_urb(rr3->learn_urb, udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t(unsigned char *)&rr3->learn_control,\n\t\t\t&rr3->learn_buf, sizeof(rr3->learn_buf),\n\t\t\tredrat3_learn_complete, rr3);\n\n\t \n\trr3->flash_control.bRequestType = 0xc0;\n\trr3->flash_control.bRequest = RR3_BLINK_LED;\n\trr3->flash_control.wLength = cpu_to_le16(1);\n\n\tusb_fill_control_urb(rr3->flash_urb, udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t(unsigned char *)&rr3->flash_control,\n\t\t\t&rr3->flash_in_buf, sizeof(rr3->flash_in_buf),\n\t\t\tredrat3_led_complete, rr3);\n\n\t \n\trr3->led.name = \"redrat3:red:feedback\";\n\trr3->led.default_trigger = \"rc-feedback\";\n\trr3->led.brightness_set = redrat3_brightness_set;\n\tretval = led_classdev_register(&intf->dev, &rr3->led);\n\tif (retval)\n\t\tgoto redrat_free;\n\n\trr3->rc = redrat3_init_rc_dev(rr3);\n\tif (!rr3->rc) {\n\t\tretval = -ENOMEM;\n\t\tgoto led_free;\n\t}\n\n\t \n\tretval = redrat3_enable_detector(rr3);\n\tif (retval < 0)\n\t\tgoto led_free;\n\n\t \n\tusb_set_intfdata(intf, rr3);\n\n\treturn 0;\n\nled_free:\n\tled_classdev_unregister(&rr3->led);\nredrat_free:\n\tredrat3_delete(rr3, rr3->udev);\n\nno_endpoints:\n\treturn retval;\n}\n\nstatic void redrat3_dev_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\trc_unregister_device(rr3->rc);\n\tled_classdev_unregister(&rr3->led);\n\tredrat3_delete(rr3, udev);\n}\n\nstatic int redrat3_dev_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\n\n\tled_classdev_suspend(&rr3->led);\n\tusb_kill_urb(rr3->narrow_urb);\n\tusb_kill_urb(rr3->wide_urb);\n\tusb_kill_urb(rr3->flash_urb);\n\treturn 0;\n}\n\nstatic int redrat3_dev_resume(struct usb_interface *intf)\n{\n\tstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\n\n\tif (usb_submit_urb(rr3->narrow_urb, GFP_NOIO))\n\t\treturn -EIO;\n\tif (usb_submit_urb(rr3->wide_urb, GFP_NOIO))\n\t\treturn -EIO;\n\tled_classdev_resume(&rr3->led);\n\treturn 0;\n}\n\nstatic struct usb_driver redrat3_dev_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.probe\t\t= redrat3_dev_probe,\n\t.disconnect\t= redrat3_dev_disconnect,\n\t.suspend\t= redrat3_dev_suspend,\n\t.resume\t\t= redrat3_dev_resume,\n\t.reset_resume\t= redrat3_dev_resume,\n\t.id_table\t= redrat3_dev_table\n};\n\nmodule_usb_driver(redrat3_dev_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_AUTHOR(DRIVER_AUTHOR2);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, redrat3_dev_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}