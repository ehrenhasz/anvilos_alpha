{
  "module_name": "meson-ir.c",
  "hash_id": "a927b78d40250953b2ec4f662827ad3dfbae7fa700b2cc6ecffe79c9e86ffa79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/meson-ir.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\t\"meson-ir\"\n\n#define IR_DEC_LDR_ACTIVE\t0x00\n#define IR_DEC_LDR_IDLE\t\t0x04\n#define IR_DEC_LDR_REPEAT\t0x08\n#define IR_DEC_BIT_0\t\t0x0c\n#define IR_DEC_REG0\t\t0x10\n#define IR_DEC_REG0_BASE_TIME\tGENMASK(11, 0)\n#define IR_DEC_FRAME\t\t0x14\n#define IR_DEC_STATUS\t\t0x18\n#define IR_DEC_STATUS_PULSE\tBIT(8)\n#define IR_DEC_REG1\t\t0x1c\n#define IR_DEC_REG1_TIME_IV\tGENMASK(28, 16)\n#define IR_DEC_REG1_ENABLE\tBIT(15)\n#define IR_DEC_REG1_MODE\tGENMASK(8, 7)\n#define IR_DEC_REG1_IRQSEL\tGENMASK(3, 2)\n#define IR_DEC_REG1_RESET\tBIT(0)\n \n#define IR_DEC_REG2\t\t0x20\n#define IR_DEC_REG2_MODE\tGENMASK(3, 0)\n\n#define DEC_MODE_NEC\t\t0x0\n#define DEC_MODE_RAW\t\t0x2\n\n#define IRQSEL_NEC_MODE\t\t0\n#define IRQSEL_RISE_FALL\t1\n#define IRQSEL_FALL\t\t2\n#define IRQSEL_RISE\t\t3\n\n#define MESON_RAW_TRATE\t\t10\t \n#define MESON_HW_TRATE\t\t20\t \n\nstruct meson_ir {\n\tstruct regmap\t*reg;\n\tstruct rc_dev\t*rc;\n\tspinlock_t\tlock;\n};\n\nstatic const struct regmap_config meson_ir_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic irqreturn_t meson_ir_irq(int irqno, void *dev_id)\n{\n\tstruct meson_ir *ir = dev_id;\n\tu32 duration, status;\n\tstruct ir_raw_event rawir = {};\n\n\tspin_lock(&ir->lock);\n\n\tregmap_read(ir->reg, IR_DEC_REG1, &duration);\n\tduration = FIELD_GET(IR_DEC_REG1_TIME_IV, duration);\n\trawir.duration = duration * MESON_RAW_TRATE;\n\n\tregmap_read(ir->reg, IR_DEC_STATUS, &status);\n\trawir.pulse = !!(status & IR_DEC_STATUS_PULSE);\n\n\tir_raw_event_store_with_timeout(ir->rc, &rawir);\n\n\tspin_unlock(&ir->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int meson_ir_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tvoid __iomem *res_start;\n\tconst char *map_name;\n\tstruct meson_ir *ir;\n\tint irq, ret;\n\n\tir = devm_kzalloc(dev, sizeof(struct meson_ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tres_start = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(res_start))\n\t\treturn PTR_ERR(res_start);\n\n\tir->reg = devm_regmap_init_mmio(&pdev->dev, res_start,\n\t\t\t\t\t&meson_ir_regmap_config);\n\tif (IS_ERR(ir->reg))\n\t\treturn PTR_ERR(ir->reg);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tir->rc = devm_rc_allocate_device(dev, RC_DRIVER_IR_RAW);\n\tif (!ir->rc) {\n\t\tdev_err(dev, \"failed to allocate rc device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tir->rc->priv = ir;\n\tir->rc->device_name = DRIVER_NAME;\n\tir->rc->input_phys = DRIVER_NAME \"/input0\";\n\tir->rc->input_id.bustype = BUS_HOST;\n\tmap_name = of_get_property(node, \"linux,rc-map-name\", NULL);\n\tir->rc->map_name = map_name ? map_name : RC_MAP_EMPTY;\n\tir->rc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\tir->rc->rx_resolution = MESON_RAW_TRATE;\n\tir->rc->min_timeout = 1;\n\tir->rc->timeout = IR_DEFAULT_TIMEOUT;\n\tir->rc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\tir->rc->driver_name = DRIVER_NAME;\n\n\tspin_lock_init(&ir->lock);\n\tplatform_set_drvdata(pdev, ir);\n\n\tret = devm_rc_register_device(dev, ir->rc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register rc device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, irq, meson_ir_irq, 0, NULL, ir);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_RESET,\n\t\t\t   IR_DEC_REG1_RESET);\n\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_RESET, 0);\n\n\t \n\tif (of_device_is_compatible(node, \"amlogic,meson6-ir\"))\n\t\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_MODE,\n\t\t\t\t   FIELD_PREP(IR_DEC_REG1_MODE, DEC_MODE_RAW));\n\telse\n\t\tregmap_update_bits(ir->reg, IR_DEC_REG2, IR_DEC_REG2_MODE,\n\t\t\t\t   FIELD_PREP(IR_DEC_REG2_MODE, DEC_MODE_RAW));\n\n\t \n\tregmap_update_bits(ir->reg, IR_DEC_REG0, IR_DEC_REG0_BASE_TIME,\n\t\t\t   FIELD_PREP(IR_DEC_REG0_BASE_TIME,\n\t\t\t\t      MESON_RAW_TRATE - 1));\n\t \n\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_IRQSEL,\n\t\t\t   FIELD_PREP(IR_DEC_REG1_IRQSEL, IRQSEL_RISE_FALL));\n\t \n\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_ENABLE,\n\t\t\t   IR_DEC_REG1_ENABLE);\n\n\tdev_info(dev, \"receiver initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void meson_ir_remove(struct platform_device *pdev)\n{\n\tstruct meson_ir *ir = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ir->lock, flags);\n\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_ENABLE, 0);\n\tspin_unlock_irqrestore(&ir->lock, flags);\n}\n\nstatic void meson_ir_shutdown(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct meson_ir *ir = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ir->lock, flags);\n\n\t \n\tif (of_device_is_compatible(node, \"amlogic,meson6-ir\"))\n\t\tregmap_update_bits(ir->reg, IR_DEC_REG1, IR_DEC_REG1_MODE,\n\t\t\t\t   FIELD_PREP(IR_DEC_REG1_MODE, DEC_MODE_NEC));\n\telse\n\t\tregmap_update_bits(ir->reg, IR_DEC_REG2, IR_DEC_REG2_MODE,\n\t\t\t\t   FIELD_PREP(IR_DEC_REG2_MODE, DEC_MODE_NEC));\n\n\t \n\tregmap_update_bits(ir->reg, IR_DEC_REG0, IR_DEC_REG0_BASE_TIME,\n\t\t\t   FIELD_PREP(IR_DEC_REG0_BASE_TIME,\n\t\t\t\t      MESON_HW_TRATE - 1));\n\n\tspin_unlock_irqrestore(&ir->lock, flags);\n}\n\nstatic const struct of_device_id meson_ir_match[] = {\n\t{ .compatible = \"amlogic,meson6-ir\" },\n\t{ .compatible = \"amlogic,meson8b-ir\" },\n\t{ .compatible = \"amlogic,meson-gxbb-ir\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, meson_ir_match);\n\nstatic struct platform_driver meson_ir_driver = {\n\t.probe\t\t= meson_ir_probe,\n\t.remove_new\t= meson_ir_remove,\n\t.shutdown\t= meson_ir_shutdown,\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= meson_ir_match,\n\t},\n};\n\nmodule_platform_driver(meson_ir_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson IR remote receiver driver\");\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}