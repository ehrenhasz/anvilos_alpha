{
  "module_name": "bpf-lirc.c",
  "hash_id": "3bc815a0340360d143d2a09c62a9ef670b57ada1ce88a1925f60bdbddfb2919e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/bpf-lirc.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/bpf_lirc.h>\n#include \"rc-core-priv.h\"\n\n#define lirc_rcu_dereference(p)\t\t\t\t\t\t\\\n\trcu_dereference_protected(p, lockdep_is_held(&ir_raw_handler_lock))\n\n \nconst struct bpf_prog_ops lirc_mode2_prog_ops = {\n};\n\nBPF_CALL_1(bpf_rc_repeat, u32*, sample)\n{\n\tstruct ir_raw_event_ctrl *ctrl;\n\n\tctrl = container_of(sample, struct ir_raw_event_ctrl, bpf_sample);\n\n\trc_repeat(ctrl->dev);\n\n\treturn 0;\n}\n\nstatic const struct bpf_func_proto rc_repeat_proto = {\n\t.func\t   = bpf_rc_repeat,\n\t.gpl_only  = true,  \n\t.ret_type  = RET_INTEGER,\n\t.arg1_type = ARG_PTR_TO_CTX,\n};\n\nBPF_CALL_4(bpf_rc_keydown, u32*, sample, u32, protocol, u64, scancode,\n\t   u32, toggle)\n{\n\tstruct ir_raw_event_ctrl *ctrl;\n\n\tctrl = container_of(sample, struct ir_raw_event_ctrl, bpf_sample);\n\n\trc_keydown(ctrl->dev, protocol, scancode, toggle != 0);\n\n\treturn 0;\n}\n\nstatic const struct bpf_func_proto rc_keydown_proto = {\n\t.func\t   = bpf_rc_keydown,\n\t.gpl_only  = true,  \n\t.ret_type  = RET_INTEGER,\n\t.arg1_type = ARG_PTR_TO_CTX,\n\t.arg2_type = ARG_ANYTHING,\n\t.arg3_type = ARG_ANYTHING,\n\t.arg4_type = ARG_ANYTHING,\n};\n\nBPF_CALL_3(bpf_rc_pointer_rel, u32*, sample, s32, rel_x, s32, rel_y)\n{\n\tstruct ir_raw_event_ctrl *ctrl;\n\n\tctrl = container_of(sample, struct ir_raw_event_ctrl, bpf_sample);\n\n\tinput_report_rel(ctrl->dev->input_dev, REL_X, rel_x);\n\tinput_report_rel(ctrl->dev->input_dev, REL_Y, rel_y);\n\tinput_sync(ctrl->dev->input_dev);\n\n\treturn 0;\n}\n\nstatic const struct bpf_func_proto rc_pointer_rel_proto = {\n\t.func\t   = bpf_rc_pointer_rel,\n\t.gpl_only  = true,\n\t.ret_type  = RET_INTEGER,\n\t.arg1_type = ARG_PTR_TO_CTX,\n\t.arg2_type = ARG_ANYTHING,\n\t.arg3_type = ARG_ANYTHING,\n};\n\nstatic const struct bpf_func_proto *\nlirc_mode2_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_rc_repeat:\n\t\treturn &rc_repeat_proto;\n\tcase BPF_FUNC_rc_keydown:\n\t\treturn &rc_keydown_proto;\n\tcase BPF_FUNC_rc_pointer_rel:\n\t\treturn &rc_pointer_rel_proto;\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_trace_printk:\n\t\tif (perfmon_capable())\n\t\t\treturn bpf_get_trace_printk_proto();\n\t\tfallthrough;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic bool lirc_mode2_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\t \n\treturn type == BPF_READ && off == 0 && size == sizeof(u32);\n}\n\nconst struct bpf_verifier_ops lirc_mode2_verifier_ops = {\n\t.get_func_proto  = lirc_mode2_func_proto,\n\t.is_valid_access = lirc_mode2_is_valid_access\n};\n\n#define BPF_MAX_PROGS 64\n\nstatic int lirc_bpf_attach(struct rc_dev *rcdev, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *old_array;\n\tstruct bpf_prog_array *new_array;\n\tstruct ir_raw_event_ctrl *raw;\n\tint ret;\n\n\tif (rcdev->driver_type != RC_DRIVER_IR_RAW)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&ir_raw_handler_lock);\n\tif (ret)\n\t\treturn ret;\n\n\traw = rcdev->raw;\n\tif (!raw) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\told_array = lirc_rcu_dereference(raw->progs);\n\tif (old_array && bpf_prog_array_length(old_array) >= BPF_MAX_PROGS) {\n\t\tret = -E2BIG;\n\t\tgoto unlock;\n\t}\n\n\tret = bpf_prog_array_copy(old_array, NULL, prog, 0, &new_array);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\trcu_assign_pointer(raw->progs, new_array);\n\tbpf_prog_array_free(old_array);\n\nunlock:\n\tmutex_unlock(&ir_raw_handler_lock);\n\treturn ret;\n}\n\nstatic int lirc_bpf_detach(struct rc_dev *rcdev, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *old_array;\n\tstruct bpf_prog_array *new_array;\n\tstruct ir_raw_event_ctrl *raw;\n\tint ret;\n\n\tif (rcdev->driver_type != RC_DRIVER_IR_RAW)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&ir_raw_handler_lock);\n\tif (ret)\n\t\treturn ret;\n\n\traw = rcdev->raw;\n\tif (!raw) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\told_array = lirc_rcu_dereference(raw->progs);\n\tret = bpf_prog_array_copy(old_array, prog, NULL, 0, &new_array);\n\t \n\tif (ret)\n\t\tgoto unlock;\n\n\trcu_assign_pointer(raw->progs, new_array);\n\tbpf_prog_array_free(old_array);\n\tbpf_prog_put(prog);\nunlock:\n\tmutex_unlock(&ir_raw_handler_lock);\n\treturn ret;\n}\n\nvoid lirc_bpf_run(struct rc_dev *rcdev, u32 sample)\n{\n\tstruct ir_raw_event_ctrl *raw = rcdev->raw;\n\n\traw->bpf_sample = sample;\n\n\tif (raw->progs) {\n\t\trcu_read_lock();\n\t\tbpf_prog_run_array(rcu_dereference(raw->progs),\n\t\t\t\t   &raw->bpf_sample, bpf_prog_run);\n\t\trcu_read_unlock();\n\t}\n}\n\n \nvoid lirc_bpf_free(struct rc_dev *rcdev)\n{\n\tstruct bpf_prog_array_item *item;\n\tstruct bpf_prog_array *array;\n\n\tarray = lirc_rcu_dereference(rcdev->raw->progs);\n\tif (!array)\n\t\treturn;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tbpf_prog_put(item->prog);\n\n\tbpf_prog_array_free(array);\n}\n\nint lirc_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct rc_dev *rcdev;\n\tint ret;\n\n\tif (attr->attach_flags)\n\t\treturn -EINVAL;\n\n\trcdev = rc_dev_get_from_fd(attr->target_fd);\n\tif (IS_ERR(rcdev))\n\t\treturn PTR_ERR(rcdev);\n\n\tret = lirc_bpf_attach(rcdev, prog);\n\n\tput_device(&rcdev->dev);\n\n\treturn ret;\n}\n\nint lirc_prog_detach(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tstruct rc_dev *rcdev;\n\tint ret;\n\n\tif (attr->attach_flags)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd,\n\t\t\t\t BPF_PROG_TYPE_LIRC_MODE2);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcdev = rc_dev_get_from_fd(attr->target_fd);\n\tif (IS_ERR(rcdev)) {\n\t\tbpf_prog_put(prog);\n\t\treturn PTR_ERR(rcdev);\n\t}\n\n\tret = lirc_bpf_detach(rcdev, prog);\n\n\tbpf_prog_put(prog);\n\tput_device(&rcdev->dev);\n\n\treturn ret;\n}\n\nint lirc_prog_query(const union bpf_attr *attr, union bpf_attr __user *uattr)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *progs;\n\tstruct rc_dev *rcdev;\n\tu32 cnt, flags = 0;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\trcdev = rc_dev_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(rcdev))\n\t\treturn PTR_ERR(rcdev);\n\n\tif (rcdev->driver_type != RC_DRIVER_IR_RAW) {\n\t\tret = -EINVAL;\n\t\tgoto put;\n\t}\n\n\tret = mutex_lock_interruptible(&ir_raw_handler_lock);\n\tif (ret)\n\t\tgoto put;\n\n\tprogs = lirc_rcu_dereference(rcdev->raw->progs);\n\tcnt = progs ? bpf_prog_array_length(progs) : 0;\n\n\tif (copy_to_user(&uattr->query.prog_cnt, &cnt, sizeof(cnt))) {\n\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tif (attr->query.prog_cnt != 0 && prog_ids && cnt)\n\t\tret = bpf_prog_array_copy_to_user(progs, prog_ids,\n\t\t\t\t\t\t  attr->query.prog_cnt);\n\nunlock:\n\tmutex_unlock(&ir_raw_handler_lock);\nput:\n\tput_device(&rcdev->dev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}