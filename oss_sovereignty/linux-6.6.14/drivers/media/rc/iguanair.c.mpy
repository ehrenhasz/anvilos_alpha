{
  "module_name": "iguanair.c",
  "hash_id": "f5042e7bb684a30b930ba287033a7257dcfa3c3392ff6d0b51005082026260d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/iguanair.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <media/rc-core.h>\n\n#define BUF_SIZE 152\n\nstruct iguanair {\n\tstruct rc_dev *rc;\n\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\n\tuint16_t version;\n\tuint8_t bufsize;\n\tuint8_t cycle_overhead;\n\n\t \n\tbool receiver_on;\n\tdma_addr_t dma_in, dma_out;\n\tuint8_t *buf_in;\n\tstruct urb *urb_in, *urb_out;\n\tstruct completion completion;\n\n\t \n\tbool tx_overflow;\n\tuint32_t carrier;\n\tstruct send_packet *packet;\n\n\tchar name[64];\n\tchar phys[64];\n};\n\n#define CMD_NOP\t\t\t0x00\n#define CMD_GET_VERSION\t\t0x01\n#define CMD_GET_BUFSIZE\t\t0x11\n#define CMD_GET_FEATURES\t0x10\n#define CMD_SEND\t\t0x15\n#define CMD_EXECUTE\t\t0x1f\n#define CMD_RX_OVERFLOW\t\t0x31\n#define CMD_TX_OVERFLOW\t\t0x32\n#define CMD_RECEIVER_ON\t\t0x12\n#define CMD_RECEIVER_OFF\t0x14\n\n#define DIR_IN\t\t\t0xdc\n#define DIR_OUT\t\t\t0xcd\n\n#define MAX_IN_PACKET\t\t8u\n#define MAX_OUT_PACKET\t\t(sizeof(struct send_packet) + BUF_SIZE)\n#define TIMEOUT\t\t\t1000\n#define RX_RESOLUTION\t\t21\n\nstruct packet {\n\tuint16_t start;\n\tuint8_t direction;\n\tuint8_t cmd;\n};\n\nstruct send_packet {\n\tstruct packet header;\n\tuint8_t length;\n\tuint8_t channels;\n\tuint8_t busy7;\n\tuint8_t busy4;\n\tuint8_t payload[];\n};\n\nstatic void process_ir_data(struct iguanair *ir, unsigned len)\n{\n\tif (len >= 4 && ir->buf_in[0] == 0 && ir->buf_in[1] == 0) {\n\t\tswitch (ir->buf_in[3]) {\n\t\tcase CMD_GET_VERSION:\n\t\t\tif (len == 6) {\n\t\t\t\tir->version = (ir->buf_in[5] << 8) |\n\t\t\t\t\t\t\tir->buf_in[4];\n\t\t\t\tcomplete(&ir->completion);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_GET_BUFSIZE:\n\t\t\tif (len >= 5) {\n\t\t\t\tir->bufsize = ir->buf_in[4];\n\t\t\t\tcomplete(&ir->completion);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_GET_FEATURES:\n\t\t\tif (len > 5) {\n\t\t\t\tir->cycle_overhead = ir->buf_in[5];\n\t\t\t\tcomplete(&ir->completion);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TX_OVERFLOW:\n\t\t\tir->tx_overflow = true;\n\t\t\tfallthrough;\n\t\tcase CMD_RECEIVER_OFF:\n\t\tcase CMD_RECEIVER_ON:\n\t\tcase CMD_SEND:\n\t\t\tcomplete(&ir->completion);\n\t\t\tbreak;\n\t\tcase CMD_RX_OVERFLOW:\n\t\t\tdev_warn(ir->dev, \"receive overflow\\n\");\n\t\t\tir_raw_event_overflow(ir->rc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(ir->dev, \"control code %02x received\\n\",\n\t\t\t\t\t\t\tir->buf_in[3]);\n\t\t\tbreak;\n\t\t}\n\t} else if (len >= 7) {\n\t\tstruct ir_raw_event rawir = {};\n\t\tunsigned i;\n\t\tbool event = false;\n\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tif (ir->buf_in[i] == 0x80) {\n\t\t\t\trawir.pulse = false;\n\t\t\t\trawir.duration = 21845;\n\t\t\t} else {\n\t\t\t\trawir.pulse = (ir->buf_in[i] & 0x80) == 0;\n\t\t\t\trawir.duration = ((ir->buf_in[i] & 0x7f) + 1) *\n\t\t\t\t\t\t\t\t RX_RESOLUTION;\n\t\t\t}\n\n\t\t\tif (ir_raw_event_store_with_filter(ir->rc, &rawir))\n\t\t\t\tevent = true;\n\t\t}\n\n\t\tif (event)\n\t\t\tir_raw_event_handle(ir->rc);\n\t}\n}\n\nstatic void iguanair_rx(struct urb *urb)\n{\n\tstruct iguanair *ir;\n\tint rc;\n\n\tif (!urb)\n\t\treturn;\n\n\tir = urb->context;\n\tif (!ir)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tprocess_ir_data(ir, urb->actual_length);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_dbg(ir->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc && rc != -ENODEV)\n\t\tdev_warn(ir->dev, \"failed to resubmit urb: %d\\n\", rc);\n}\n\nstatic void iguanair_irq_out(struct urb *urb)\n{\n\tstruct iguanair *ir = urb->context;\n\n\tif (urb->status)\n\t\tdev_dbg(ir->dev, \"Error: out urb status = %d\\n\", urb->status);\n\n\t \n\tif (urb->status == 0 && ir->packet->header.cmd == CMD_NOP)\n\t\tcomplete(&ir->completion);\n}\n\nstatic int iguanair_send(struct iguanair *ir, unsigned size)\n{\n\tint rc;\n\n\treinit_completion(&ir->completion);\n\n\tir->urb_out->transfer_buffer_length = size;\n\trc = usb_submit_urb(ir->urb_out, GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tif (wait_for_completion_timeout(&ir->completion, TIMEOUT) == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn rc;\n}\n\nstatic int iguanair_get_features(struct iguanair *ir)\n{\n\tint rc;\n\n\t \n\tir->packet->header.start = 0;\n\tir->packet->header.direction = DIR_OUT;\n\tir->packet->header.cmd = CMD_NOP;\n\tiguanair_send(ir, sizeof(ir->packet->header));\n\n\tir->packet->header.cmd = CMD_GET_VERSION;\n\trc = iguanair_send(ir, sizeof(ir->packet->header));\n\tif (rc) {\n\t\tdev_info(ir->dev, \"failed to get version\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ir->version < 0x205) {\n\t\tdev_err(ir->dev, \"firmware 0x%04x is too old\\n\", ir->version);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tir->bufsize = 150;\n\tir->cycle_overhead = 65;\n\n\tir->packet->header.cmd = CMD_GET_BUFSIZE;\n\n\trc = iguanair_send(ir, sizeof(ir->packet->header));\n\tif (rc) {\n\t\tdev_info(ir->dev, \"failed to get buffer size\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ir->bufsize > BUF_SIZE) {\n\t\tdev_info(ir->dev, \"buffer size %u larger than expected\\n\",\n\t\t\t\t\t\t\t\tir->bufsize);\n\t\tir->bufsize = BUF_SIZE;\n\t}\n\n\tir->packet->header.cmd = CMD_GET_FEATURES;\n\n\trc = iguanair_send(ir, sizeof(ir->packet->header));\n\tif (rc)\n\t\tdev_info(ir->dev, \"failed to get features\\n\");\nout:\n\treturn rc;\n}\n\nstatic int iguanair_receiver(struct iguanair *ir, bool enable)\n{\n\tir->packet->header.start = 0;\n\tir->packet->header.direction = DIR_OUT;\n\tir->packet->header.cmd = enable ? CMD_RECEIVER_ON : CMD_RECEIVER_OFF;\n\n\treturn iguanair_send(ir, sizeof(ir->packet->header));\n}\n\n \nstatic int iguanair_set_tx_carrier(struct rc_dev *dev, uint32_t carrier)\n{\n\tstruct iguanair *ir = dev->priv;\n\n\tif (carrier < 25000 || carrier > 150000)\n\t\treturn -EINVAL;\n\n\tif (carrier != ir->carrier) {\n\t\tuint32_t cycles, fours, sevens;\n\n\t\tir->carrier = carrier;\n\n\t\tcycles = DIV_ROUND_CLOSEST(24000000, carrier * 2) -\n\t\t\t\t\t\t\tir->cycle_overhead;\n\n\t\t \n\t\tsevens = (4 - cycles) & 3;\n\t\tfours = (cycles - sevens * 7) / 4;\n\n\t\t \n\t\tir->packet->busy7 = (4 - sevens) * 2;\n\t\tir->packet->busy4 = 110 - fours;\n\t}\n\n\treturn 0;\n}\n\nstatic int iguanair_set_tx_mask(struct rc_dev *dev, uint32_t mask)\n{\n\tstruct iguanair *ir = dev->priv;\n\n\tif (mask > 15)\n\t\treturn 4;\n\n\tir->packet->channels = mask << 4;\n\n\treturn 0;\n}\n\nstatic int iguanair_tx(struct rc_dev *dev, unsigned *txbuf, unsigned count)\n{\n\tstruct iguanair *ir = dev->priv;\n\tunsigned int i, size, p, periods;\n\tint rc;\n\n\t \n\tfor (i = size = 0; i < count; i++) {\n\t\tperiods = DIV_ROUND_CLOSEST(txbuf[i] * ir->carrier, 1000000);\n\t\twhile (periods) {\n\t\t\tp = min(periods, 127u);\n\t\t\tif (size >= ir->bufsize) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tir->packet->payload[size++] = p | ((i & 1) ? 0x80 : 0);\n\t\t\tperiods -= p;\n\t\t}\n\t}\n\n\tir->packet->header.start = 0;\n\tir->packet->header.direction = DIR_OUT;\n\tir->packet->header.cmd = CMD_SEND;\n\tir->packet->length = size;\n\n\tir->tx_overflow = false;\n\n\trc = iguanair_send(ir, sizeof(*ir->packet) + size);\n\n\tif (rc == 0 && ir->tx_overflow)\n\t\trc = -EOVERFLOW;\n\nout:\n\treturn rc ? rc : count;\n}\n\nstatic int iguanair_open(struct rc_dev *rdev)\n{\n\tstruct iguanair *ir = rdev->priv;\n\tint rc;\n\n\trc = iguanair_receiver(ir, true);\n\tif (rc == 0)\n\t\tir->receiver_on = true;\n\n\treturn rc;\n}\n\nstatic void iguanair_close(struct rc_dev *rdev)\n{\n\tstruct iguanair *ir = rdev->priv;\n\tint rc;\n\n\trc = iguanair_receiver(ir, false);\n\tir->receiver_on = false;\n\tif (rc && rc != -ENODEV)\n\t\tdev_warn(ir->dev, \"failed to disable receiver: %d\\n\", rc);\n}\n\nstatic int iguanair_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct iguanair *ir;\n\tstruct rc_dev *rc;\n\tint ret, pipein, pipeout;\n\tstruct usb_host_interface *idesc;\n\n\tidesc = intf->cur_altsetting;\n\tif (idesc->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\tir = kzalloc(sizeof(*ir), GFP_KERNEL);\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!ir || !rc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tir->buf_in = usb_alloc_coherent(udev, MAX_IN_PACKET, GFP_KERNEL,\n\t\t\t\t\t\t\t\t&ir->dma_in);\n\tir->packet = usb_alloc_coherent(udev, MAX_OUT_PACKET, GFP_KERNEL,\n\t\t\t\t\t\t\t\t&ir->dma_out);\n\tir->urb_in = usb_alloc_urb(0, GFP_KERNEL);\n\tir->urb_out = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!ir->buf_in || !ir->packet || !ir->urb_in || !ir->urb_out ||\n\t    !usb_endpoint_is_int_in(&idesc->endpoint[0].desc) ||\n\t    !usb_endpoint_is_int_out(&idesc->endpoint[1].desc)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tir->rc = rc;\n\tir->dev = &intf->dev;\n\tir->udev = udev;\n\n\tinit_completion(&ir->completion);\n\tpipeout = usb_sndintpipe(udev,\n\t\t\t\tidesc->endpoint[1].desc.bEndpointAddress);\n\tusb_fill_int_urb(ir->urb_out, udev, pipeout, ir->packet, MAX_OUT_PACKET,\n\t\t\t\t\t\tiguanair_irq_out, ir, 1);\n\tir->urb_out->transfer_dma = ir->dma_out;\n\tir->urb_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tpipein = usb_rcvintpipe(udev, idesc->endpoint[0].desc.bEndpointAddress);\n\tusb_fill_int_urb(ir->urb_in, udev, pipein, ir->buf_in, MAX_IN_PACKET,\n\t\t\t\t\t\t\t iguanair_rx, ir, 1);\n\tir->urb_in->transfer_dma = ir->dma_in;\n\tir->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tret = usb_submit_urb(ir->urb_in, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_warn(&intf->dev, \"failed to submit urb: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = iguanair_get_features(ir);\n\tif (ret)\n\t\tgoto out2;\n\n\tsnprintf(ir->name, sizeof(ir->name),\n\t\t\"IguanaWorks USB IR Transceiver version 0x%04x\", ir->version);\n\n\tusb_make_path(ir->udev, ir->phys, sizeof(ir->phys));\n\n\trc->device_name = ir->name;\n\trc->input_phys = ir->phys;\n\tusb_to_input_id(ir->udev, &rc->input_id);\n\trc->dev.parent = &intf->dev;\n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->priv = ir;\n\trc->open = iguanair_open;\n\trc->close = iguanair_close;\n\trc->s_tx_mask = iguanair_set_tx_mask;\n\trc->s_tx_carrier = iguanair_set_tx_carrier;\n\trc->tx_ir = iguanair_tx;\n\trc->driver_name = KBUILD_MODNAME;\n\trc->map_name = RC_MAP_RC6_MCE;\n\trc->min_timeout = 1;\n\trc->timeout = IR_DEFAULT_TIMEOUT;\n\trc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\trc->rx_resolution = RX_RESOLUTION;\n\n\tiguanair_set_tx_carrier(rc, 38000);\n\tiguanair_set_tx_mask(rc, 0);\n\n\tret = rc_register_device(rc);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"failed to register rc device %d\", ret);\n\t\tgoto out2;\n\t}\n\n\tusb_set_intfdata(intf, ir);\n\n\treturn 0;\nout2:\n\tusb_kill_urb(ir->urb_in);\n\tusb_kill_urb(ir->urb_out);\nout:\n\tif (ir) {\n\t\tusb_free_urb(ir->urb_in);\n\t\tusb_free_urb(ir->urb_out);\n\t\tusb_free_coherent(udev, MAX_IN_PACKET, ir->buf_in, ir->dma_in);\n\t\tusb_free_coherent(udev, MAX_OUT_PACKET, ir->packet,\n\t\t\t\t\t\t\t\tir->dma_out);\n\t}\n\trc_free_device(rc);\n\tkfree(ir);\n\treturn ret;\n}\n\nstatic void iguanair_disconnect(struct usb_interface *intf)\n{\n\tstruct iguanair *ir = usb_get_intfdata(intf);\n\n\trc_unregister_device(ir->rc);\n\tusb_set_intfdata(intf, NULL);\n\tusb_kill_urb(ir->urb_in);\n\tusb_kill_urb(ir->urb_out);\n\tusb_free_urb(ir->urb_in);\n\tusb_free_urb(ir->urb_out);\n\tusb_free_coherent(ir->udev, MAX_IN_PACKET, ir->buf_in, ir->dma_in);\n\tusb_free_coherent(ir->udev, MAX_OUT_PACKET, ir->packet, ir->dma_out);\n\tkfree(ir);\n}\n\nstatic int iguanair_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct iguanair *ir = usb_get_intfdata(intf);\n\tint rc = 0;\n\n\tif (ir->receiver_on) {\n\t\trc = iguanair_receiver(ir, false);\n\t\tif (rc)\n\t\t\tdev_warn(ir->dev, \"failed to disable receiver for suspend\\n\");\n\t}\n\n\tusb_kill_urb(ir->urb_in);\n\tusb_kill_urb(ir->urb_out);\n\n\treturn rc;\n}\n\nstatic int iguanair_resume(struct usb_interface *intf)\n{\n\tstruct iguanair *ir = usb_get_intfdata(intf);\n\tint rc;\n\n\trc = usb_submit_urb(ir->urb_in, GFP_KERNEL);\n\tif (rc)\n\t\tdev_warn(&intf->dev, \"failed to submit urb: %d\\n\", rc);\n\n\tif (ir->receiver_on) {\n\t\trc = iguanair_receiver(ir, true);\n\t\tif (rc)\n\t\t\tdev_warn(ir->dev, \"failed to enable receiver after resume\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic const struct usb_device_id iguanair_table[] = {\n\t{ USB_DEVICE(0x1781, 0x0938) },\n\t{ }\n};\n\nstatic struct usb_driver iguanair_driver = {\n\t.name =\tKBUILD_MODNAME,\n\t.probe = iguanair_probe,\n\t.disconnect = iguanair_disconnect,\n\t.suspend = iguanair_suspend,\n\t.resume = iguanair_resume,\n\t.reset_resume = iguanair_resume,\n\t.id_table = iguanair_table,\n\t.soft_unbind = 1\t \n};\n\nmodule_usb_driver(iguanair_driver);\n\nMODULE_DESCRIPTION(\"IguanaWorks USB IR Transceiver\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, iguanair_table);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}