{
  "module_name": "ttusbir.c",
  "hash_id": "494b22828725cc1250c757a07af62f4cd973a550f68cf194fcc24fab3a425b57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ttusbir.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\"ttusbir\"\n#define DRIVER_DESC\t\"TechnoTrend USB IR Receiver\"\n \n#define NUM_URBS\t4\n#define US_PER_BYTE\t62\n#define US_PER_BIT\t(US_PER_BYTE / 8)\n\nstruct ttusbir {\n\tstruct rc_dev *rc;\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\n\tstruct urb *urb[NUM_URBS];\n\n\tstruct led_classdev led;\n\tstruct urb *bulk_urb;\n\tuint8_t bulk_buffer[5];\n\tint bulk_out_endp, iso_in_endp;\n\tbool led_on, is_led_on;\n\tatomic_t led_complete;\n\n\tchar phys[64];\n};\n\nstatic enum led_brightness ttusbir_brightness_get(struct led_classdev *led_dev)\n{\n\tstruct ttusbir *tt = container_of(led_dev, struct ttusbir, led);\n\n\treturn tt->led_on ? LED_FULL : LED_OFF;\n}\n\nstatic void ttusbir_set_led(struct ttusbir *tt)\n{\n\tint ret;\n\n\tsmp_mb();\n\n\tif (tt->led_on != tt->is_led_on && tt->udev &&\n\t\t\t\tatomic_add_unless(&tt->led_complete, 1, 1)) {\n\t\ttt->bulk_buffer[4] = tt->is_led_on = tt->led_on;\n\t\tret = usb_submit_urb(tt->bulk_urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_warn(tt->dev, \"failed to submit bulk urb: %d\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t\t\tatomic_dec(&tt->led_complete);\n\t\t}\n\t}\n}\n\nstatic void ttusbir_brightness_set(struct led_classdev *led_dev, enum\n\t\t\t\t\t\tled_brightness brightness)\n{\n\tstruct ttusbir *tt = container_of(led_dev, struct ttusbir, led);\n\n\ttt->led_on = brightness != LED_OFF;\n\n\tttusbir_set_led(tt);\n}\n\n \nstatic void ttusbir_bulk_complete(struct urb *urb)\n{\n\tstruct ttusbir *tt = urb->context;\n\n\tatomic_dec(&tt->led_complete);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_dbg(tt->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tttusbir_set_led(tt);\n}\n\n \nstatic void ttusbir_process_ir_data(struct ttusbir *tt, uint8_t *buf)\n{\n\tstruct ir_raw_event rawir = {};\n\tunsigned i, v, b;\n\tbool event = false;\n\n\tfor (i = 0; i < 128; i++) {\n\t\tv = buf[i] & 0xfe;\n\t\tswitch (v) {\n\t\tcase 0xfe:\n\t\t\trawir.pulse = false;\n\t\t\trawir.duration = US_PER_BYTE;\n\t\t\tif (ir_raw_event_store_with_filter(tt->rc, &rawir))\n\t\t\t\tevent = true;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\trawir.pulse = true;\n\t\t\trawir.duration = US_PER_BYTE;\n\t\t\tif (ir_raw_event_store_with_filter(tt->rc, &rawir))\n\t\t\t\tevent = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (v & 2) {\n\t\t\t\tb = ffz(v | 1);\n\t\t\t\trawir.pulse = true;\n\t\t\t} else {\n\t\t\t\tb = ffs(v) - 1;\n\t\t\t\trawir.pulse = false;\n\t\t\t}\n\n\t\t\trawir.duration = US_PER_BIT * (8 - b);\n\t\t\tif (ir_raw_event_store_with_filter(tt->rc, &rawir))\n\t\t\t\tevent = true;\n\n\t\t\trawir.pulse = !rawir.pulse;\n\t\t\trawir.duration = US_PER_BIT * b;\n\t\t\tif (ir_raw_event_store_with_filter(tt->rc, &rawir))\n\t\t\t\tevent = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (event)\n\t\tir_raw_event_handle(tt->rc);\n}\n\nstatic void ttusbir_urb_complete(struct urb *urb)\n{\n\tstruct ttusbir *tt = urb->context;\n\tint rc;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tttusbir_process_ir_data(tt, urb->transfer_buffer);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_dbg(tt->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc && rc != -ENODEV)\n\t\tdev_warn(tt->dev, \"failed to resubmit urb: %d\\n\", rc);\n}\n\nstatic int ttusbir_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct ttusbir *tt;\n\tstruct usb_interface_descriptor *idesc;\n\tstruct usb_endpoint_descriptor *desc;\n\tstruct rc_dev *rc;\n\tint i, j, ret;\n\tint altsetting = -1;\n\n\ttt = kzalloc(sizeof(*tt), GFP_KERNEL);\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!tt || !rc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < intf->num_altsetting && altsetting == -1; i++) {\n\t\tint max_packet, bulk_out_endp = -1, iso_in_endp = -1;\n\n\t\tidesc = &intf->altsetting[i].desc;\n\n\t\tfor (j = 0; j < idesc->bNumEndpoints; j++) {\n\t\t\tdesc = &intf->altsetting[i].endpoint[j].desc;\n\t\t\tmax_packet = le16_to_cpu(desc->wMaxPacketSize);\n\t\t\tif (usb_endpoint_dir_in(desc) &&\n\t\t\t\t\tusb_endpoint_xfer_isoc(desc) &&\n\t\t\t\t\tmax_packet == 0x10)\n\t\t\t\tiso_in_endp = j;\n\t\t\telse if (usb_endpoint_dir_out(desc) &&\n\t\t\t\t\tusb_endpoint_xfer_bulk(desc) &&\n\t\t\t\t\tmax_packet == 0x20)\n\t\t\t\tbulk_out_endp = j;\n\n\t\t\tif (bulk_out_endp != -1 && iso_in_endp != -1) {\n\t\t\t\ttt->bulk_out_endp = bulk_out_endp;\n\t\t\t\ttt->iso_in_endp = iso_in_endp;\n\t\t\t\taltsetting = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (altsetting == -1) {\n\t\tdev_err(&intf->dev, \"cannot find expected altsetting\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\ttt->dev = &intf->dev;\n\ttt->udev = interface_to_usbdev(intf);\n\ttt->rc = rc;\n\n\tret = usb_set_interface(tt->udev, 0, altsetting);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\tstruct urb *urb = usb_alloc_urb(8, GFP_KERNEL);\n\t\tvoid *buffer;\n\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\turb->dev = tt->udev;\n\t\turb->context = tt;\n\t\turb->pipe = usb_rcvisocpipe(tt->udev, tt->iso_in_endp);\n\t\turb->interval = 1;\n\t\tbuffer = usb_alloc_coherent(tt->udev, 128, GFP_KERNEL,\n\t\t\t\t\t\t&urb->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\turb->transfer_flags = URB_NO_TRANSFER_DMA_MAP | URB_ISO_ASAP;\n\t\turb->transfer_buffer = buffer;\n\t\turb->complete = ttusbir_urb_complete;\n\t\turb->number_of_packets = 8;\n\t\turb->transfer_buffer_length = 128;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\turb->iso_frame_desc[j].offset = j * 16;\n\t\t\turb->iso_frame_desc[j].length = 16;\n\t\t}\n\n\t\ttt->urb[i] = urb;\n\t}\n\n\ttt->bulk_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!tt->bulk_urb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttt->bulk_buffer[0] = 0xaa;\n\ttt->bulk_buffer[1] = 0x01;\n\ttt->bulk_buffer[2] = 0x05;\n\ttt->bulk_buffer[3] = 0x01;\n\n\tusb_fill_bulk_urb(tt->bulk_urb, tt->udev, usb_sndbulkpipe(tt->udev,\n\t\ttt->bulk_out_endp), tt->bulk_buffer, sizeof(tt->bulk_buffer),\n\t\t\t\t\t\tttusbir_bulk_complete, tt);\n\n\ttt->led.name = \"ttusbir:green:power\";\n\ttt->led.default_trigger = \"rc-feedback\";\n\ttt->led.brightness_set = ttusbir_brightness_set;\n\ttt->led.brightness_get = ttusbir_brightness_get;\n\ttt->is_led_on = tt->led_on = true;\n\tatomic_set(&tt->led_complete, 0);\n\tret = led_classdev_register(&intf->dev, &tt->led);\n\tif (ret)\n\t\tgoto out;\n\n\tusb_make_path(tt->udev, tt->phys, sizeof(tt->phys));\n\n\trc->device_name = DRIVER_DESC;\n\trc->input_phys = tt->phys;\n\tusb_to_input_id(tt->udev, &rc->input_id);\n\trc->dev.parent = &intf->dev;\n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->priv = tt;\n\trc->driver_name = DRIVER_NAME;\n\trc->map_name = RC_MAP_TT_1500;\n\trc->min_timeout = 1;\n\trc->timeout = IR_DEFAULT_TIMEOUT;\n\trc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\n\t \n\trc->rx_resolution = 2 * US_PER_BIT;\n\n\tret = rc_register_device(rc);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to register rc device %d\\n\", ret);\n\t\tgoto out2;\n\t}\n\n\tusb_set_intfdata(intf, tt);\n\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\tret = usb_submit_urb(tt->urb[i], GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(tt->dev, \"failed to submit urb %d\\n\", ret);\n\t\t\tgoto out3;\n\t\t}\n\t}\n\n\treturn 0;\nout3:\n\trc_unregister_device(rc);\n\trc = NULL;\nout2:\n\tled_classdev_unregister(&tt->led);\nout:\n\tif (tt) {\n\t\tfor (i = 0; i < NUM_URBS && tt->urb[i]; i++) {\n\t\t\tstruct urb *urb = tt->urb[i];\n\n\t\t\tusb_kill_urb(urb);\n\t\t\tusb_free_coherent(tt->udev, 128, urb->transfer_buffer,\n\t\t\t\t\t\t\turb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t\tusb_kill_urb(tt->bulk_urb);\n\t\tusb_free_urb(tt->bulk_urb);\n\t\tkfree(tt);\n\t}\n\trc_free_device(rc);\n\n\treturn ret;\n}\n\nstatic void ttusbir_disconnect(struct usb_interface *intf)\n{\n\tstruct ttusbir *tt = usb_get_intfdata(intf);\n\tstruct usb_device *udev = tt->udev;\n\tint i;\n\n\ttt->udev = NULL;\n\n\trc_unregister_device(tt->rc);\n\tled_classdev_unregister(&tt->led);\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\tusb_kill_urb(tt->urb[i]);\n\t\tusb_free_coherent(udev, 128, tt->urb[i]->transfer_buffer,\n\t\t\t\t\t\ttt->urb[i]->transfer_dma);\n\t\tusb_free_urb(tt->urb[i]);\n\t}\n\tusb_kill_urb(tt->bulk_urb);\n\tusb_free_urb(tt->bulk_urb);\n\tusb_set_intfdata(intf, NULL);\n\tkfree(tt);\n}\n\nstatic int ttusbir_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct ttusbir *tt = usb_get_intfdata(intf);\n\tint i;\n\n\tfor (i = 0; i < NUM_URBS; i++)\n\t\tusb_kill_urb(tt->urb[i]);\n\n\tled_classdev_suspend(&tt->led);\n\tusb_kill_urb(tt->bulk_urb);\n\n\treturn 0;\n}\n\nstatic int ttusbir_resume(struct usb_interface *intf)\n{\n\tstruct ttusbir *tt = usb_get_intfdata(intf);\n\tint i, rc;\n\n\ttt->is_led_on = true;\n\tled_classdev_resume(&tt->led);\n\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\trc = usb_submit_urb(tt->urb[i], GFP_NOIO);\n\t\tif (rc) {\n\t\t\tdev_warn(tt->dev, \"failed to submit urb: %d\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic const struct usb_device_id ttusbir_table[] = {\n\t{ USB_DEVICE(0x0b48, 0x2003) },\n\t{ }\n};\n\nstatic struct usb_driver ttusbir_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = ttusbir_table,\n\t.probe = ttusbir_probe,\n\t.suspend = ttusbir_suspend,\n\t.resume = ttusbir_resume,\n\t.reset_resume = ttusbir_resume,\n\t.disconnect = ttusbir_disconnect,\n};\n\nmodule_usb_driver(ttusbir_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, ttusbir_table);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}