{
  "module_name": "ir-sony-decoder.c",
  "hash_id": "0f8a33dd978634099f9c2b8fcea0ee5f3b3b6f14cbe64030cc7ef087b5b58462",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-sony-decoder.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define SONY_UNIT\t\t600  \n#define SONY_HEADER_PULSE\t(4 * SONY_UNIT)\n#define\tSONY_HEADER_SPACE\t(1 * SONY_UNIT)\n#define SONY_BIT_0_PULSE\t(1 * SONY_UNIT)\n#define SONY_BIT_1_PULSE\t(2 * SONY_UNIT)\n#define SONY_BIT_SPACE\t\t(1 * SONY_UNIT)\n#define SONY_TRAILER_SPACE\t(10 * SONY_UNIT)  \n\nenum sony_state {\n\tSTATE_INACTIVE,\n\tSTATE_HEADER_SPACE,\n\tSTATE_BIT_PULSE,\n\tSTATE_BIT_SPACE,\n\tSTATE_FINISHED,\n};\n\n \nstatic int ir_sony_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct sony_dec *data = &dev->raw->sony;\n\tenum rc_proto protocol;\n\tu32 scancode;\n\tu8 device, subdevice, function;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (!geq_margin(ev.duration, SONY_UNIT, SONY_UNIT / 2))\n\t\tgoto out;\n\n\tdev_dbg(&dev->dev, \"Sony decode started at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SONY_HEADER_PULSE, SONY_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->count = 0;\n\t\tdata->state = STATE_HEADER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_HEADER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SONY_HEADER_SPACE, SONY_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_PULSE;\n\t\treturn 0;\n\n\tcase STATE_BIT_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tdata->bits <<= 1;\n\t\tif (eq_margin(ev.duration, SONY_BIT_1_PULSE, SONY_UNIT / 2))\n\t\t\tdata->bits |= 1;\n\t\telse if (!eq_margin(ev.duration, SONY_BIT_0_PULSE, SONY_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->count++;\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, SONY_BIT_SPACE, SONY_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdecrease_duration(&ev, SONY_BIT_SPACE);\n\n\t\tif (!geq_margin(ev.duration, SONY_UNIT, SONY_UNIT / 2)) {\n\t\t\tdata->state = STATE_BIT_PULSE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata->state = STATE_FINISHED;\n\t\tfallthrough;\n\n\tcase STATE_FINISHED:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, SONY_TRAILER_SPACE, SONY_UNIT / 2))\n\t\t\tbreak;\n\n\t\tswitch (data->count) {\n\t\tcase 12:\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_SONY12))\n\t\t\t\tgoto finish_state_machine;\n\n\t\t\tdevice    = bitrev8((data->bits <<  3) & 0xF8);\n\t\t\tsubdevice = 0;\n\t\t\tfunction  = bitrev8((data->bits >>  4) & 0xFE);\n\t\t\tprotocol = RC_PROTO_SONY12;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_SONY15))\n\t\t\t\tgoto finish_state_machine;\n\n\t\t\tdevice    = bitrev8((data->bits >>  0) & 0xFF);\n\t\t\tsubdevice = 0;\n\t\t\tfunction  = bitrev8((data->bits >>  7) & 0xFE);\n\t\t\tprotocol = RC_PROTO_SONY15;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_SONY20))\n\t\t\t\tgoto finish_state_machine;\n\n\t\t\tdevice    = bitrev8((data->bits >>  5) & 0xF8);\n\t\t\tsubdevice = bitrev8((data->bits >>  0) & 0xFF);\n\t\t\tfunction  = bitrev8((data->bits >> 12) & 0xFE);\n\t\t\tprotocol = RC_PROTO_SONY20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"Sony invalid bitcount %u\\n\",\n\t\t\t\tdata->count);\n\t\t\tgoto out;\n\t\t}\n\n\t\tscancode = device << 16 | subdevice << 8 | function;\n\t\tdev_dbg(&dev->dev, \"Sony(%u) scancode 0x%05x\\n\", data->count,\n\t\t\tscancode);\n\t\trc_keydown(dev, protocol, scancode, 0);\n\t\tgoto finish_state_machine;\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"Sony decode failed at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n\nfinish_state_machine:\n\tdata->state = STATE_INACTIVE;\n\treturn 0;\n}\n\nstatic const struct ir_raw_timings_pl ir_sony_timings = {\n\t.header_pulse  = SONY_HEADER_PULSE,\n\t.bit_space     = SONY_BIT_SPACE,\n\t.bit_pulse[0]  = SONY_BIT_0_PULSE,\n\t.bit_pulse[1]  = SONY_BIT_1_PULSE,\n\t.trailer_space = SONY_TRAILER_SPACE + SONY_BIT_SPACE,\n\t.msb_first     = 0,\n};\n\n \nstatic int ir_sony_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t  struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tu32 raw, len;\n\tint ret;\n\n\tif (protocol == RC_PROTO_SONY12) {\n\t\traw = (scancode & 0x7f) | ((scancode & 0x1f0000) >> 9);\n\t\tlen = 12;\n\t} else if (protocol == RC_PROTO_SONY15) {\n\t\traw = (scancode & 0x7f) | ((scancode & 0xff0000) >> 9);\n\t\tlen = 15;\n\t} else {\n\t\traw = (scancode & 0x7f) | ((scancode & 0x1f0000) >> 9) |\n\t\t       ((scancode & 0xff00) << 4);\n\t\tlen = 20;\n\t}\n\n\tret = ir_raw_gen_pl(&e, max, &ir_sony_timings, len, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler sony_handler = {\n\t.protocols\t= RC_PROTO_BIT_SONY12 | RC_PROTO_BIT_SONY15 |\n\t\t\t\t\t\t\tRC_PROTO_BIT_SONY20,\n\t.decode\t\t= ir_sony_decode,\n\t.encode\t\t= ir_sony_encode,\n\t.carrier\t= 40000,\n\t.min_timeout\t= SONY_TRAILER_SPACE,\n};\n\nstatic int __init ir_sony_decode_init(void)\n{\n\tir_raw_handler_register(&sony_handler);\n\n\tprintk(KERN_INFO \"IR Sony protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_sony_decode_exit(void)\n{\n\tir_raw_handler_unregister(&sony_handler);\n}\n\nmodule_init(ir_sony_decode_init);\nmodule_exit(ir_sony_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David H\u00e4rdeman <david@hardeman.nu>\");\nMODULE_DESCRIPTION(\"Sony IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}