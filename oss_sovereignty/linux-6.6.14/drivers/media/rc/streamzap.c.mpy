{
  "module_name": "streamzap.c",
  "hash_id": "82aa94c36c0d814daf733d7eaa1d084931c690a26446af79e95c232a4d17b102",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/streamzap.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\"streamzap\"\n#define DRIVER_DESC\t\"Streamzap Remote Control driver\"\n\n#define USB_STREAMZAP_VENDOR_ID\t\t0x0e9c\n#define USB_STREAMZAP_PRODUCT_ID\t0x0000\n\n \nstatic const struct usb_device_id streamzap_table[] = {\n\t \n\t{ USB_DEVICE(USB_STREAMZAP_VENDOR_ID, USB_STREAMZAP_PRODUCT_ID) },\n\t \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, streamzap_table);\n\n#define SZ_PULSE_MASK 0xf0\n#define SZ_SPACE_MASK 0x0f\n#define SZ_TIMEOUT    0xff\n#define SZ_RESOLUTION 256\n\n \n#define SZ_BUF_LEN 128\n\nenum StreamzapDecoderState {\n\tPulseSpace,\n\tFullPulse,\n\tFullSpace,\n\tIgnorePulse\n};\n\n \nstruct streamzap_ir {\n\t \n\tstruct rc_dev *rdev;\n\n\t \n\tstruct device *dev;\n\n\t \n\tstruct urb\t\t*urb_in;\n\n\t \n\tunsigned char\t\t*buf_in;\n\tdma_addr_t\t\tdma_in;\n\tunsigned int\t\tbuf_in_len;\n\n\t \n\tenum StreamzapDecoderState decoder_state;\n\n\tchar\t\t\tphys[64];\n};\n\n\n \nstatic int streamzap_probe(struct usb_interface *interface,\n\t\t\t   const struct usb_device_id *id);\nstatic void streamzap_disconnect(struct usb_interface *interface);\nstatic void streamzap_callback(struct urb *urb);\nstatic int streamzap_suspend(struct usb_interface *intf, pm_message_t message);\nstatic int streamzap_resume(struct usb_interface *intf);\n\n \nstatic struct usb_driver streamzap_driver = {\n\t.name =\t\tDRIVER_NAME,\n\t.probe =\tstreamzap_probe,\n\t.disconnect =\tstreamzap_disconnect,\n\t.suspend =\tstreamzap_suspend,\n\t.resume =\tstreamzap_resume,\n\t.id_table =\tstreamzap_table,\n};\n\nstatic void sz_push(struct streamzap_ir *sz, struct ir_raw_event rawir)\n{\n\tdev_dbg(sz->dev, \"Storing %s with duration %u us\\n\",\n\t\t(rawir.pulse ? \"pulse\" : \"space\"), rawir.duration);\n\tir_raw_event_store_with_filter(sz->rdev, &rawir);\n}\n\nstatic void sz_push_full_pulse(struct streamzap_ir *sz,\n\t\t\t       unsigned char value)\n{\n\tstruct ir_raw_event rawir = {\n\t\t.pulse = true,\n\t\t.duration = value * SZ_RESOLUTION + SZ_RESOLUTION / 2,\n\t};\n\n\tsz_push(sz, rawir);\n}\n\nstatic void sz_push_half_pulse(struct streamzap_ir *sz,\n\t\t\t       unsigned char value)\n{\n\tsz_push_full_pulse(sz, (value & SZ_PULSE_MASK) >> 4);\n}\n\nstatic void sz_push_full_space(struct streamzap_ir *sz,\n\t\t\t       unsigned char value)\n{\n\tstruct ir_raw_event rawir = {\n\t\t.pulse = false,\n\t\t.duration = value * SZ_RESOLUTION + SZ_RESOLUTION / 2,\n\t};\n\n\tsz_push(sz, rawir);\n}\n\nstatic void sz_push_half_space(struct streamzap_ir *sz,\n\t\t\t       unsigned long value)\n{\n\tsz_push_full_space(sz, value & SZ_SPACE_MASK);\n}\n\n \nstatic void streamzap_callback(struct urb *urb)\n{\n\tstruct streamzap_ir *sz;\n\tunsigned int i;\n\tint len;\n\n\tif (!urb)\n\t\treturn;\n\n\tsz = urb->context;\n\tlen = urb->actual_length;\n\n\tswitch (urb->status) {\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_err(sz->dev, \"urb terminated, status: %d\\n\", urb->status);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(sz->dev, \"%s: received urb, len %d\\n\", __func__, len);\n\tfor (i = 0; i < len; i++) {\n\t\tdev_dbg(sz->dev, \"sz->buf_in[%d]: %x\\n\",\n\t\t\ti, (unsigned char)sz->buf_in[i]);\n\t\tswitch (sz->decoder_state) {\n\t\tcase PulseSpace:\n\t\t\tif ((sz->buf_in[i] & SZ_PULSE_MASK) ==\n\t\t\t\tSZ_PULSE_MASK) {\n\t\t\t\tsz->decoder_state = FullPulse;\n\t\t\t\tcontinue;\n\t\t\t} else if ((sz->buf_in[i] & SZ_SPACE_MASK)\n\t\t\t\t\t== SZ_SPACE_MASK) {\n\t\t\t\tsz_push_half_pulse(sz, sz->buf_in[i]);\n\t\t\t\tsz->decoder_state = FullSpace;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tsz_push_half_pulse(sz, sz->buf_in[i]);\n\t\t\t\tsz_push_half_space(sz, sz->buf_in[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FullPulse:\n\t\t\tsz_push_full_pulse(sz, sz->buf_in[i]);\n\t\t\tsz->decoder_state = IgnorePulse;\n\t\t\tbreak;\n\t\tcase FullSpace:\n\t\t\tif (sz->buf_in[i] == SZ_TIMEOUT) {\n\t\t\t\tstruct ir_raw_event rawir = {\n\t\t\t\t\t.pulse = false,\n\t\t\t\t\t.duration = sz->rdev->timeout\n\t\t\t\t};\n\t\t\t\tsz_push(sz, rawir);\n\t\t\t} else {\n\t\t\t\tsz_push_full_space(sz, sz->buf_in[i]);\n\t\t\t}\n\t\t\tsz->decoder_state = PulseSpace;\n\t\t\tbreak;\n\t\tcase IgnorePulse:\n\t\t\tif ((sz->buf_in[i] & SZ_SPACE_MASK) ==\n\t\t\t\tSZ_SPACE_MASK) {\n\t\t\t\tsz->decoder_state = FullSpace;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsz_push_half_space(sz, sz->buf_in[i]);\n\t\t\tsz->decoder_state = PulseSpace;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tir_raw_event_handle(sz->rdev);\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic struct rc_dev *streamzap_init_rc_dev(struct streamzap_ir *sz,\n\t\t\t\t\t    struct usb_device *usbdev)\n{\n\tstruct rc_dev *rdev;\n\tstruct device *dev = sz->dev;\n\tint ret;\n\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev)\n\t\tgoto out;\n\n\tusb_make_path(usbdev, sz->phys, sizeof(sz->phys));\n\tstrlcat(sz->phys, \"/input0\", sizeof(sz->phys));\n\n\trdev->device_name = \"Streamzap PC Remote Infrared Receiver\";\n\trdev->input_phys = sz->phys;\n\tusb_to_input_id(usbdev, &rdev->input_id);\n\trdev->dev.parent = dev;\n\trdev->priv = sz;\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->driver_name = DRIVER_NAME;\n\trdev->map_name = RC_MAP_STREAMZAP;\n\trdev->rx_resolution = SZ_RESOLUTION;\n\n\tret = rc_register_device(rdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"remote input device register failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn rdev;\n\nout:\n\trc_free_device(rdev);\n\treturn NULL;\n}\n\n \nstatic int streamzap_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_host_interface *iface_host;\n\tstruct streamzap_ir *sz = NULL;\n\tint retval = -ENOMEM;\n\tint pipe, maxp;\n\n\t \n\tsz = kzalloc(sizeof(struct streamzap_ir), GFP_KERNEL);\n\tif (!sz)\n\t\treturn -ENOMEM;\n\n\t \n\tiface_host = intf->cur_altsetting;\n\n\tif (iface_host->desc.bNumEndpoints != 1) {\n\t\tdev_err(&intf->dev, \"%s: Unexpected desc.bNumEndpoints (%d)\\n\",\n\t\t\t__func__, iface_host->desc.bNumEndpoints);\n\t\tretval = -ENODEV;\n\t\tgoto free_sz;\n\t}\n\n\tendpoint = &iface_host->endpoint[0].desc;\n\tif (!usb_endpoint_dir_in(endpoint)) {\n\t\tdev_err(&intf->dev, \"%s: endpoint doesn't match input device 02%02x\\n\",\n\t\t\t__func__, endpoint->bEndpointAddress);\n\t\tretval = -ENODEV;\n\t\tgoto free_sz;\n\t}\n\n\tif (!usb_endpoint_xfer_int(endpoint)) {\n\t\tdev_err(&intf->dev, \"%s: endpoint attributes don't match xfer 02%02x\\n\",\n\t\t\t__func__, endpoint->bmAttributes);\n\t\tretval = -ENODEV;\n\t\tgoto free_sz;\n\t}\n\n\tpipe = usb_rcvintpipe(usbdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(usbdev, pipe);\n\n\tif (maxp == 0) {\n\t\tdev_err(&intf->dev, \"%s: endpoint Max Packet Size is 0!?!\\n\",\n\t\t\t__func__);\n\t\tretval = -ENODEV;\n\t\tgoto free_sz;\n\t}\n\n\t \n\tsz->buf_in = usb_alloc_coherent(usbdev, maxp, GFP_ATOMIC, &sz->dma_in);\n\tif (!sz->buf_in)\n\t\tgoto free_sz;\n\n\tsz->urb_in = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!sz->urb_in)\n\t\tgoto free_buf_in;\n\n\tsz->dev = &intf->dev;\n\tsz->buf_in_len = maxp;\n\n\tsz->rdev = streamzap_init_rc_dev(sz, usbdev);\n\tif (!sz->rdev)\n\t\tgoto rc_dev_fail;\n\n\tsz->decoder_state = PulseSpace;\n\t \n\tsz->rdev->timeout = SZ_TIMEOUT * SZ_RESOLUTION;\n\t#if 0\n\t \n\t \n\tsz->min_timeout = SZ_TIMEOUT * SZ_RESOLUTION;\n\tsz->max_timeout = SZ_TIMEOUT * SZ_RESOLUTION;\n\t#endif\n\n\t \n\tusb_fill_int_urb(sz->urb_in, usbdev, pipe, sz->buf_in,\n\t\t\t maxp, streamzap_callback, sz, endpoint->bInterval);\n\tsz->urb_in->transfer_dma = sz->dma_in;\n\tsz->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tusb_set_intfdata(intf, sz);\n\n\tif (usb_submit_urb(sz->urb_in, GFP_ATOMIC))\n\t\tdev_err(sz->dev, \"urb submit failed\\n\");\n\n\treturn 0;\n\nrc_dev_fail:\n\tusb_free_urb(sz->urb_in);\nfree_buf_in:\n\tusb_free_coherent(usbdev, maxp, sz->buf_in, sz->dma_in);\nfree_sz:\n\tkfree(sz);\n\n\treturn retval;\n}\n\n \nstatic void streamzap_disconnect(struct usb_interface *interface)\n{\n\tstruct streamzap_ir *sz = usb_get_intfdata(interface);\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tif (!sz)\n\t\treturn;\n\n\trc_unregister_device(sz->rdev);\n\tusb_kill_urb(sz->urb_in);\n\tusb_free_urb(sz->urb_in);\n\tusb_free_coherent(usbdev, sz->buf_in_len, sz->buf_in, sz->dma_in);\n\n\tkfree(sz);\n}\n\nstatic int streamzap_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct streamzap_ir *sz = usb_get_intfdata(intf);\n\n\tusb_kill_urb(sz->urb_in);\n\n\treturn 0;\n}\n\nstatic int streamzap_resume(struct usb_interface *intf)\n{\n\tstruct streamzap_ir *sz = usb_get_intfdata(intf);\n\n\tif (usb_submit_urb(sz->urb_in, GFP_NOIO)) {\n\t\tdev_err(sz->dev, \"Error submitting urb\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nmodule_usb_driver(streamzap_driver);\n\nMODULE_AUTHOR(\"Jarod Wilson <jarod@wilsonet.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}