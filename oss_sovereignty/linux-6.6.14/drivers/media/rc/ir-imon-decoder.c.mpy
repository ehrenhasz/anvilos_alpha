{
  "module_name": "ir-imon-decoder.c",
  "hash_id": "4b19f4f6b031dc9dcaf328ebeaf715c960db2277515e3beebe5ef800d7bfc269",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-imon-decoder.c",
  "human_readable_source": "\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define IMON_UNIT\t\t416  \n#define IMON_BITS\t\t30\n#define IMON_CHKBITS\t\t(BIT(30) | BIT(25) | BIT(24) | BIT(22) | \\\n\t\t\t\t BIT(21) | BIT(20) | BIT(19) | BIT(18) | \\\n\t\t\t\t BIT(17) | BIT(16) | BIT(14) | BIT(13) | \\\n\t\t\t\t BIT(12) | BIT(11) | BIT(10) | BIT(9))\n\n \nenum imon_state {\n\tSTATE_INACTIVE,\n\tSTATE_BIT_CHK,\n\tSTATE_BIT_START,\n\tSTATE_FINISHED,\n\tSTATE_ERROR,\n};\n\nstatic void ir_imon_decode_scancode(struct rc_dev *dev)\n{\n\tstruct imon_dec *imon = &dev->raw->imon;\n\n\t \n\tif (imon->bits == 0x299115b7)\n\t\timon->stick_keyboard = !imon->stick_keyboard;\n\n\tif ((imon->bits & 0xfc0000ff) == 0x680000b7) {\n\t\tint rel_x, rel_y;\n\t\tu8 buf;\n\n\t\tbuf = imon->bits >> 16;\n\t\trel_x = (buf & 0x08) | (buf & 0x10) >> 2 |\n\t\t\t(buf & 0x20) >> 4 | (buf & 0x40) >> 6;\n\t\tif (imon->bits & 0x02000000)\n\t\t\trel_x |= ~0x0f;\n\t\tbuf = imon->bits >> 8;\n\t\trel_y = (buf & 0x08) | (buf & 0x10) >> 2 |\n\t\t\t(buf & 0x20) >> 4 | (buf & 0x40) >> 6;\n\t\tif (imon->bits & 0x01000000)\n\t\t\trel_y |= ~0x0f;\n\n\t\tif (rel_x && rel_y && imon->stick_keyboard) {\n\t\t\tif (abs(rel_y) > abs(rel_x))\n\t\t\t\timon->bits = rel_y > 0 ?\n\t\t\t\t\t0x289515b7 :  \n\t\t\t\t\t0x2aa515b7;   \n\t\t\telse\n\t\t\t\timon->bits = rel_x > 0 ?\n\t\t\t\t\t0x2ba515b7 :  \n\t\t\t\t\t0x29a515b7;   \n\t\t}\n\n\t\tif (!imon->stick_keyboard) {\n\t\t\tinput_report_rel(dev->input_dev, REL_X, rel_x);\n\t\t\tinput_report_rel(dev->input_dev, REL_Y, rel_y);\n\n\t\t\tinput_report_key(dev->input_dev, BTN_LEFT,\n\t\t\t\t\t (imon->bits & 0x00010000) != 0);\n\t\t\tinput_report_key(dev->input_dev, BTN_RIGHT,\n\t\t\t\t\t (imon->bits & 0x00040000) != 0);\n\t\t}\n\t}\n\n\trc_keydown(dev, RC_PROTO_IMON, imon->bits, 0);\n}\n\n \nstatic int ir_imon_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct imon_dec *data = &dev->raw->imon;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev,\n\t\t\"iMON decode started at state %d bitno %d (%uus %s)\\n\",\n\t\tdata->state, data->count, ev.duration, TO_STR(ev.pulse));\n\n\t \n\tif (data->state == STATE_ERROR) {\n\t\tif (!ev.pulse && ev.duration > MS_TO_US(10))\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tfor (;;) {\n\t\tif (!geq_margin(ev.duration, IMON_UNIT, IMON_UNIT / 2))\n\t\t\treturn 0;\n\n\t\tdecrease_duration(&ev, IMON_UNIT);\n\n\t\tswitch (data->state) {\n\t\tcase STATE_INACTIVE:\n\t\t\tif (ev.pulse) {\n\t\t\t\tdata->state = STATE_BIT_CHK;\n\t\t\t\tdata->bits = 0;\n\t\t\t\tdata->count = IMON_BITS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_BIT_CHK:\n\t\t\tif (IMON_CHKBITS & BIT(data->count))\n\t\t\t\tdata->last_chk = ev.pulse;\n\t\t\telse if (ev.pulse)\n\t\t\t\tgoto err_out;\n\t\t\tdata->state = STATE_BIT_START;\n\t\t\tbreak;\n\t\tcase STATE_BIT_START:\n\t\t\tdata->bits <<= 1;\n\t\t\tif (!ev.pulse)\n\t\t\t\tdata->bits |= 1;\n\n\t\t\tif (IMON_CHKBITS & BIT(data->count)) {\n\t\t\t\tif (data->last_chk != !(data->bits & 3))\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!data->count--)\n\t\t\t\tdata->state = STATE_FINISHED;\n\t\t\telse\n\t\t\t\tdata->state = STATE_BIT_CHK;\n\t\t\tbreak;\n\t\tcase STATE_FINISHED:\n\t\t\tif (ev.pulse)\n\t\t\t\tgoto err_out;\n\t\t\tir_imon_decode_scancode(dev);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\tbreak;\n\t\t}\n\t}\n\nerr_out:\n\tdev_dbg(&dev->dev,\n\t\t\"iMON decode failed at state %d bitno %d (%uus %s)\\n\",\n\t\tdata->state, data->count, ev.duration, TO_STR(ev.pulse));\n\n\tdata->state = STATE_ERROR;\n\n\treturn -EINVAL;\n}\n\n \nstatic int ir_imon_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t  struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint i, pulse;\n\n\tif (!max--)\n\t\treturn -ENOBUFS;\n\tinit_ir_raw_event_duration(e, 1, IMON_UNIT);\n\n\tfor (i = IMON_BITS; i >= 0; i--) {\n\t\tif (BIT(i) & IMON_CHKBITS)\n\t\t\tpulse = !(scancode & (BIT(i) | BIT(i + 1)));\n\t\telse\n\t\t\tpulse = 0;\n\n\t\tif (pulse == e->pulse) {\n\t\t\te->duration += IMON_UNIT;\n\t\t} else {\n\t\t\tif (!max--)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tinit_ir_raw_event_duration(++e, pulse, IMON_UNIT);\n\t\t}\n\n\t\tpulse = !(scancode & BIT(i));\n\n\t\tif (pulse == e->pulse) {\n\t\t\te->duration += IMON_UNIT;\n\t\t} else {\n\t\t\tif (!max--)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tinit_ir_raw_event_duration(++e, pulse, IMON_UNIT);\n\t\t}\n\t}\n\n\tif (e->pulse)\n\t\te++;\n\n\treturn e - events;\n}\n\nstatic int ir_imon_register(struct rc_dev *dev)\n{\n\tstruct imon_dec *imon = &dev->raw->imon;\n\n\timon->stick_keyboard = false;\n\n\treturn 0;\n}\n\nstatic struct ir_raw_handler imon_handler = {\n\t.protocols\t= RC_PROTO_BIT_IMON,\n\t.decode\t\t= ir_imon_decode,\n\t.encode\t\t= ir_imon_encode,\n\t.carrier\t= 38000,\n\t.raw_register\t= ir_imon_register,\n\t.min_timeout\t= IMON_UNIT * IMON_BITS * 2,\n};\n\nstatic int __init ir_imon_decode_init(void)\n{\n\tir_raw_handler_register(&imon_handler);\n\n\tpr_info(\"IR iMON protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_imon_decode_exit(void)\n{\n\tir_raw_handler_unregister(&imon_handler);\n}\n\nmodule_init(ir_imon_decode_init);\nmodule_exit(ir_imon_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_DESCRIPTION(\"iMON IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}