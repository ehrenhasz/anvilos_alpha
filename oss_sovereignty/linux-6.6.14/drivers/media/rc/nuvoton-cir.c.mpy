{
  "module_name": "nuvoton-cir.c",
  "hash_id": "34627d4d06991d37392e4179da6a67de45c88ffc04eaa9e0a2a13b589ad173e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/nuvoton-cir.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n#include <linux/pci_ids.h>\n\n#include \"nuvoton-cir.h\"\n\nstatic void nvt_clear_cir_wake_fifo(struct nvt_dev *nvt);\n\nstatic const struct nvt_chip nvt_chips[] = {\n\t{ \"w83667hg\", NVT_W83667HG },\n\t{ \"NCT6775F\", NVT_6775F },\n\t{ \"NCT6776F\", NVT_6776F },\n\t{ \"NCT6779D\", NVT_6779D },\n};\n\nstatic inline struct device *nvt_get_dev(const struct nvt_dev *nvt)\n{\n\treturn nvt->rdev->dev.parent;\n}\n\nstatic inline bool is_w83667hg(struct nvt_dev *nvt)\n{\n\treturn nvt->chip_ver == NVT_W83667HG;\n}\n\n \nstatic inline void nvt_cr_write(struct nvt_dev *nvt, u8 val, u8 reg)\n{\n\toutb(reg, nvt->cr_efir);\n\toutb(val, nvt->cr_efdr);\n}\n\n \nstatic inline u8 nvt_cr_read(struct nvt_dev *nvt, u8 reg)\n{\n\toutb(reg, nvt->cr_efir);\n\treturn inb(nvt->cr_efdr);\n}\n\n \nstatic inline void nvt_set_reg_bit(struct nvt_dev *nvt, u8 val, u8 reg)\n{\n\tu8 tmp = nvt_cr_read(nvt, reg) | val;\n\tnvt_cr_write(nvt, tmp, reg);\n}\n\n \nstatic inline int nvt_efm_enable(struct nvt_dev *nvt)\n{\n\tif (!request_muxed_region(nvt->cr_efir, 2, NVT_DRIVER_NAME))\n\t\treturn -EBUSY;\n\n\t \n\toutb(EFER_EFM_ENABLE, nvt->cr_efir);\n\toutb(EFER_EFM_ENABLE, nvt->cr_efir);\n\n\treturn 0;\n}\n\n \nstatic inline void nvt_efm_disable(struct nvt_dev *nvt)\n{\n\toutb(EFER_EFM_DISABLE, nvt->cr_efir);\n\n\trelease_region(nvt->cr_efir, 2);\n}\n\n \nstatic inline void nvt_select_logical_dev(struct nvt_dev *nvt, u8 ldev)\n{\n\tnvt_cr_write(nvt, ldev, CR_LOGICAL_DEV_SEL);\n}\n\n \nstatic inline void nvt_enable_logical_dev(struct nvt_dev *nvt, u8 ldev)\n{\n\tnvt_efm_enable(nvt);\n\tnvt_select_logical_dev(nvt, ldev);\n\tnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\n\tnvt_efm_disable(nvt);\n}\n\n \nstatic inline void nvt_disable_logical_dev(struct nvt_dev *nvt, u8 ldev)\n{\n\tnvt_efm_enable(nvt);\n\tnvt_select_logical_dev(nvt, ldev);\n\tnvt_cr_write(nvt, LOGICAL_DEV_DISABLE, CR_LOGICAL_DEV_EN);\n\tnvt_efm_disable(nvt);\n}\n\n \nstatic inline void nvt_cir_reg_write(struct nvt_dev *nvt, u8 val, u8 offset)\n{\n\toutb(val, nvt->cir_addr + offset);\n}\n\n \nstatic u8 nvt_cir_reg_read(struct nvt_dev *nvt, u8 offset)\n{\n\treturn inb(nvt->cir_addr + offset);\n}\n\n \nstatic inline void nvt_cir_wake_reg_write(struct nvt_dev *nvt,\n\t\t\t\t\t  u8 val, u8 offset)\n{\n\toutb(val, nvt->cir_wake_addr + offset);\n}\n\n \nstatic u8 nvt_cir_wake_reg_read(struct nvt_dev *nvt, u8 offset)\n{\n\treturn inb(nvt->cir_wake_addr + offset);\n}\n\n \nstatic void nvt_set_ioaddr(struct nvt_dev *nvt, unsigned long *ioaddr)\n{\n\tunsigned long old_addr;\n\n\told_addr = nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8;\n\told_addr |= nvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO);\n\n\tif (old_addr)\n\t\t*ioaddr = old_addr;\n\telse {\n\t\tnvt_cr_write(nvt, *ioaddr >> 8, CR_CIR_BASE_ADDR_HI);\n\t\tnvt_cr_write(nvt, *ioaddr & 0xff, CR_CIR_BASE_ADDR_LO);\n\t}\n}\n\nstatic void nvt_write_wakeup_codes(struct rc_dev *dev,\n\t\t\t\t   const u8 *wbuf, int count)\n{\n\tu8 tolerance, config;\n\tstruct nvt_dev *nvt = dev->priv;\n\tunsigned long flags;\n\tint i;\n\n\t \n\ttolerance = DIV_ROUND_UP(count, 10);\n\n\tspin_lock_irqsave(&nvt->lock, flags);\n\n\tnvt_clear_cir_wake_fifo(nvt);\n\tnvt_cir_wake_reg_write(nvt, count, CIR_WAKE_FIFO_CMP_DEEP);\n\tnvt_cir_wake_reg_write(nvt, tolerance, CIR_WAKE_FIFO_CMP_TOL);\n\n\tconfig = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON);\n\n\t \n\tnvt_cir_wake_reg_write(nvt, config | CIR_WAKE_IRCON_MODE1,\n\t\t\t       CIR_WAKE_IRCON);\n\n\tif (count)\n\t\tpr_info(\"Wake samples (%d) =\", count);\n\telse\n\t\tpr_info(\"Wake sample fifo cleared\");\n\n\tfor (i = 0; i < count; i++)\n\t\tnvt_cir_wake_reg_write(nvt, wbuf[i], CIR_WAKE_WR_FIFO_DATA);\n\n\tnvt_cir_wake_reg_write(nvt, config, CIR_WAKE_IRCON);\n\n\tspin_unlock_irqrestore(&nvt->lock, flags);\n}\n\nstatic ssize_t wakeup_data_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct rc_dev *rc_dev = to_rc_dev(dev);\n\tstruct nvt_dev *nvt = rc_dev->priv;\n\tint fifo_len, duration;\n\tunsigned long flags;\n\tssize_t buf_len = 0;\n\tint i;\n\n\tspin_lock_irqsave(&nvt->lock, flags);\n\n\tfifo_len = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT);\n\tfifo_len = min(fifo_len, WAKEUP_MAX_SIZE);\n\n\t \n\twhile (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX))\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);\n\n\tfor (i = 0; i < fifo_len; i++) {\n\t\tduration = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);\n\t\tduration = (duration & BUF_LEN_MASK) * SAMPLE_PERIOD;\n\t\tbuf_len += scnprintf(buf + buf_len, PAGE_SIZE - buf_len,\n\t\t\t\t    \"%d \", duration);\n\t}\n\tbuf_len += scnprintf(buf + buf_len, PAGE_SIZE - buf_len, \"\\n\");\n\n\tspin_unlock_irqrestore(&nvt->lock, flags);\n\n\treturn buf_len;\n}\n\nstatic ssize_t wakeup_data_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\tstruct rc_dev *rc_dev = to_rc_dev(dev);\n\tu8 wake_buf[WAKEUP_MAX_SIZE];\n\tchar **argv;\n\tint i, count;\n\tunsigned int val;\n\tssize_t ret;\n\n\targv = argv_split(GFP_KERNEL, buf, &count);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\tif (!count || count > WAKEUP_MAX_SIZE) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = kstrtouint(argv[i], 10, &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tval = DIV_ROUND_CLOSEST(val, SAMPLE_PERIOD);\n\t\tif (!val || val > 0x7f) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\twake_buf[i] = val;\n\t\t \n\t\tif (i % 2 == 0)\n\t\t\twake_buf[i] |= BUF_PULSE_BIT;\n\t}\n\n\tnvt_write_wakeup_codes(rc_dev, wake_buf, count);\n\n\tret = len;\nout:\n\targv_free(argv);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(wakeup_data);\n\n \nstatic void cir_dump_regs(struct nvt_dev *nvt)\n{\n\tnvt_efm_enable(nvt);\n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR);\n\n\tpr_info(\"%s: Dump CIR logical device registers:\\n\", NVT_DRIVER_NAME);\n\tpr_info(\" * CR CIR ACTIVE :   0x%x\\n\",\n\t\tnvt_cr_read(nvt, CR_LOGICAL_DEV_EN));\n\tpr_info(\" * CR CIR BASE ADDR: 0x%x\\n\",\n\t\t(nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8) |\n\t\tnvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO));\n\tpr_info(\" * CR CIR IRQ NUM:   0x%x\\n\",\n\t\tnvt_cr_read(nvt, CR_CIR_IRQ_RSRC));\n\n\tnvt_efm_disable(nvt);\n\n\tpr_info(\"%s: Dump CIR registers:\\n\", NVT_DRIVER_NAME);\n\tpr_info(\" * IRCON:     0x%x\\n\", nvt_cir_reg_read(nvt, CIR_IRCON));\n\tpr_info(\" * IRSTS:     0x%x\\n\", nvt_cir_reg_read(nvt, CIR_IRSTS));\n\tpr_info(\" * IREN:      0x%x\\n\", nvt_cir_reg_read(nvt, CIR_IREN));\n\tpr_info(\" * RXFCONT:   0x%x\\n\", nvt_cir_reg_read(nvt, CIR_RXFCONT));\n\tpr_info(\" * CP:        0x%x\\n\", nvt_cir_reg_read(nvt, CIR_CP));\n\tpr_info(\" * CC:        0x%x\\n\", nvt_cir_reg_read(nvt, CIR_CC));\n\tpr_info(\" * SLCH:      0x%x\\n\", nvt_cir_reg_read(nvt, CIR_SLCH));\n\tpr_info(\" * SLCL:      0x%x\\n\", nvt_cir_reg_read(nvt, CIR_SLCL));\n\tpr_info(\" * FIFOCON:   0x%x\\n\", nvt_cir_reg_read(nvt, CIR_FIFOCON));\n\tpr_info(\" * IRFIFOSTS: 0x%x\\n\", nvt_cir_reg_read(nvt, CIR_IRFIFOSTS));\n\tpr_info(\" * SRXFIFO:   0x%x\\n\", nvt_cir_reg_read(nvt, CIR_SRXFIFO));\n\tpr_info(\" * TXFCONT:   0x%x\\n\", nvt_cir_reg_read(nvt, CIR_TXFCONT));\n\tpr_info(\" * STXFIFO:   0x%x\\n\", nvt_cir_reg_read(nvt, CIR_STXFIFO));\n\tpr_info(\" * FCCH:      0x%x\\n\", nvt_cir_reg_read(nvt, CIR_FCCH));\n\tpr_info(\" * FCCL:      0x%x\\n\", nvt_cir_reg_read(nvt, CIR_FCCL));\n\tpr_info(\" * IRFSM:     0x%x\\n\", nvt_cir_reg_read(nvt, CIR_IRFSM));\n}\n\n \nstatic void cir_wake_dump_regs(struct nvt_dev *nvt)\n{\n\tu8 i, fifo_len;\n\n\tnvt_efm_enable(nvt);\n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\n\n\tpr_info(\"%s: Dump CIR WAKE logical device registers:\\n\",\n\t\tNVT_DRIVER_NAME);\n\tpr_info(\" * CR CIR WAKE ACTIVE :   0x%x\\n\",\n\t\tnvt_cr_read(nvt, CR_LOGICAL_DEV_EN));\n\tpr_info(\" * CR CIR WAKE BASE ADDR: 0x%x\\n\",\n\t\t(nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8) |\n\t\tnvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO));\n\tpr_info(\" * CR CIR WAKE IRQ NUM:   0x%x\\n\",\n\t\tnvt_cr_read(nvt, CR_CIR_IRQ_RSRC));\n\n\tnvt_efm_disable(nvt);\n\n\tpr_info(\"%s: Dump CIR WAKE registers\\n\", NVT_DRIVER_NAME);\n\tpr_info(\" * IRCON:          0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON));\n\tpr_info(\" * IRSTS:          0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRSTS));\n\tpr_info(\" * IREN:           0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_IREN));\n\tpr_info(\" * FIFO CMP DEEP:  0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_CMP_DEEP));\n\tpr_info(\" * FIFO CMP TOL:   0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_CMP_TOL));\n\tpr_info(\" * FIFO COUNT:     0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT));\n\tpr_info(\" * SLCH:           0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_SLCH));\n\tpr_info(\" * SLCL:           0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_SLCL));\n\tpr_info(\" * FIFOCON:        0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFOCON));\n\tpr_info(\" * SRXFSTS:        0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_SRXFSTS));\n\tpr_info(\" * SAMPLE RX FIFO: 0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_SAMPLE_RX_FIFO));\n\tpr_info(\" * WR FIFO DATA:   0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_WR_FIFO_DATA));\n\tpr_info(\" * RD FIFO ONLY:   0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY));\n\tpr_info(\" * RD FIFO ONLY IDX: 0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX));\n\tpr_info(\" * FIFO IGNORE:    0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_IGNORE));\n\tpr_info(\" * IRFSM:          0x%x\\n\",\n\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRFSM));\n\n\tfifo_len = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT);\n\tpr_info(\"%s: Dump CIR WAKE FIFO (len %d)\\n\", NVT_DRIVER_NAME, fifo_len);\n\tpr_info(\"* Contents =\");\n\tfor (i = 0; i < fifo_len; i++)\n\t\tpr_cont(\" %02x\",\n\t\t\tnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY));\n\tpr_cont(\"\\n\");\n}\n\nstatic inline const char *nvt_find_chip(struct nvt_dev *nvt, int id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nvt_chips); i++)\n\t\tif ((id & SIO_ID_MASK) == nvt_chips[i].chip_ver) {\n\t\t\tnvt->chip_ver = nvt_chips[i].chip_ver;\n\t\t\treturn nvt_chips[i].name;\n\t\t}\n\n\treturn NULL;\n}\n\n\n \nstatic int nvt_hw_detect(struct nvt_dev *nvt)\n{\n\tstruct device *dev = nvt_get_dev(nvt);\n\tconst char *chip_name;\n\tint chip_id;\n\n\tnvt_efm_enable(nvt);\n\n\t \n\tnvt->chip_major = nvt_cr_read(nvt, CR_CHIP_ID_HI);\n\tif (nvt->chip_major == 0xff) {\n\t\tnvt_efm_disable(nvt);\n\t\tnvt->cr_efir = CR_EFIR2;\n\t\tnvt->cr_efdr = CR_EFDR2;\n\t\tnvt_efm_enable(nvt);\n\t\tnvt->chip_major = nvt_cr_read(nvt, CR_CHIP_ID_HI);\n\t}\n\tnvt->chip_minor = nvt_cr_read(nvt, CR_CHIP_ID_LO);\n\n\tnvt_efm_disable(nvt);\n\n\tchip_id = nvt->chip_major << 8 | nvt->chip_minor;\n\tif (chip_id == NVT_INVALID) {\n\t\tdev_err(dev, \"No device found on either EFM port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip_name = nvt_find_chip(nvt, chip_id);\n\n\t \n\tif (!chip_name)\n\t\tdev_warn(dev,\n\t\t\t \"unknown chip, id: 0x%02x 0x%02x, it may not work...\",\n\t\t\t nvt->chip_major, nvt->chip_minor);\n\telse\n\t\tdev_info(dev, \"found %s or compatible: chip id: 0x%02x 0x%02x\",\n\t\t\t chip_name, nvt->chip_major, nvt->chip_minor);\n\n\treturn 0;\n}\n\nstatic void nvt_cir_ldev_init(struct nvt_dev *nvt)\n{\n\tu8 val, psreg, psmask, psval;\n\n\tif (is_w83667hg(nvt)) {\n\t\tpsreg = CR_MULTIFUNC_PIN_SEL;\n\t\tpsmask = MULTIFUNC_PIN_SEL_MASK;\n\t\tpsval = MULTIFUNC_ENABLE_CIR | MULTIFUNC_ENABLE_CIRWB;\n\t} else {\n\t\tpsreg = CR_OUTPUT_PIN_SEL;\n\t\tpsmask = OUTPUT_PIN_SEL_MASK;\n\t\tpsval = OUTPUT_ENABLE_CIR | OUTPUT_ENABLE_CIRWB;\n\t}\n\n\t \n\tval = nvt_cr_read(nvt, psreg);\n\tval &= psmask;\n\tval |= psval;\n\tnvt_cr_write(nvt, val, psreg);\n\n\t \n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR);\n\n\tnvt_set_ioaddr(nvt, &nvt->cir_addr);\n\n\tnvt_cr_write(nvt, nvt->cir_irq, CR_CIR_IRQ_RSRC);\n\n\tnvt_dbg(\"CIR initialized, base io port address: 0x%lx, irq: %d\",\n\t\tnvt->cir_addr, nvt->cir_irq);\n}\n\nstatic void nvt_cir_wake_ldev_init(struct nvt_dev *nvt)\n{\n\t \n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_ACPI);\n\tnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\n\n\t \n\tnvt_set_reg_bit(nvt, CIR_WAKE_ENABLE_BIT, CR_ACPI_CIR_WAKE);\n\n\t \n\tnvt_set_reg_bit(nvt, PME_INTR_CIR_PASS_BIT, CR_ACPI_IRQ_EVENTS2);\n\n\t \n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\n\n\tnvt_set_ioaddr(nvt, &nvt->cir_wake_addr);\n\n\tnvt_dbg(\"CIR Wake initialized, base io port address: 0x%lx\",\n\t\tnvt->cir_wake_addr);\n}\n\n \nstatic void nvt_clear_cir_fifo(struct nvt_dev *nvt)\n{\n\tu8 val = nvt_cir_reg_read(nvt, CIR_FIFOCON);\n\tnvt_cir_reg_write(nvt, val | CIR_FIFOCON_RXFIFOCLR, CIR_FIFOCON);\n}\n\n \nstatic void nvt_clear_cir_wake_fifo(struct nvt_dev *nvt)\n{\n\tu8 val, config;\n\n\tconfig = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON);\n\n\t \n\tnvt_cir_wake_reg_write(nvt, config & ~CIR_WAKE_IRCON_MODE0,\n\t\t\t       CIR_WAKE_IRCON);\n\n\tval = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFOCON);\n\tnvt_cir_wake_reg_write(nvt, val | CIR_WAKE_FIFOCON_RXFIFOCLR,\n\t\t\t       CIR_WAKE_FIFOCON);\n\n\tnvt_cir_wake_reg_write(nvt, config, CIR_WAKE_IRCON);\n}\n\n \nstatic void nvt_clear_tx_fifo(struct nvt_dev *nvt)\n{\n\tu8 val;\n\n\tval = nvt_cir_reg_read(nvt, CIR_FIFOCON);\n\tnvt_cir_reg_write(nvt, val | CIR_FIFOCON_TXFIFOCLR, CIR_FIFOCON);\n}\n\n \nstatic void nvt_set_cir_iren(struct nvt_dev *nvt)\n{\n\tu8 iren;\n\n\tiren = CIR_IREN_RTR | CIR_IREN_PE | CIR_IREN_RFO;\n\tnvt_cir_reg_write(nvt, iren, CIR_IREN);\n}\n\nstatic void nvt_cir_regs_init(struct nvt_dev *nvt)\n{\n\tnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR);\n\n\t \n\tnvt_cir_reg_write(nvt, CIR_RX_LIMIT_COUNT >> 8, CIR_SLCH);\n\tnvt_cir_reg_write(nvt, CIR_RX_LIMIT_COUNT & 0xff, CIR_SLCL);\n\n\t \n\tnvt_cir_reg_write(nvt, CIR_FIFOCON_TX_TRIGGER_LEV |\n\t\t\t  CIR_FIFOCON_RX_TRIGGER_LEV, CIR_FIFOCON);\n\n\t \n\tnvt_clear_cir_fifo(nvt);\n\tnvt_clear_tx_fifo(nvt);\n\n\tnvt_disable_logical_dev(nvt, LOGICAL_DEV_CIR);\n}\n\nstatic void nvt_cir_wake_regs_init(struct nvt_dev *nvt)\n{\n\tnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\n\n\t \n\tnvt_cir_wake_reg_write(nvt, CIR_WAKE_IRCON_MODE0 |\n\t\t\t       CIR_WAKE_IRCON_R | CIR_WAKE_IRCON_RXINV |\n\t\t\t       CIR_WAKE_IRCON_SAMPLE_PERIOD_SEL,\n\t\t\t       CIR_WAKE_IRCON);\n\n\t \n\tnvt_cir_wake_reg_write(nvt, 0xff, CIR_WAKE_IRSTS);\n}\n\nstatic void nvt_enable_wake(struct nvt_dev *nvt)\n{\n\tunsigned long flags;\n\n\tnvt_efm_enable(nvt);\n\n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_ACPI);\n\tnvt_set_reg_bit(nvt, CIR_WAKE_ENABLE_BIT, CR_ACPI_CIR_WAKE);\n\tnvt_set_reg_bit(nvt, PME_INTR_CIR_PASS_BIT, CR_ACPI_IRQ_EVENTS2);\n\n\tnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\n\tnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\n\n\tnvt_efm_disable(nvt);\n\n\tspin_lock_irqsave(&nvt->lock, flags);\n\n\tnvt_cir_wake_reg_write(nvt, CIR_WAKE_IRCON_MODE0 | CIR_WAKE_IRCON_RXEN |\n\t\t\t       CIR_WAKE_IRCON_R | CIR_WAKE_IRCON_RXINV |\n\t\t\t       CIR_WAKE_IRCON_SAMPLE_PERIOD_SEL,\n\t\t\t       CIR_WAKE_IRCON);\n\tnvt_cir_wake_reg_write(nvt, 0xff, CIR_WAKE_IRSTS);\n\tnvt_cir_wake_reg_write(nvt, 0, CIR_WAKE_IREN);\n\n\tspin_unlock_irqrestore(&nvt->lock, flags);\n}\n\n#if 0  \n \nstatic u32 nvt_rx_carrier_detect(struct nvt_dev *nvt)\n{\n\tu32 count, carrier, duration = 0;\n\tint i;\n\n\tcount = nvt_cir_reg_read(nvt, CIR_FCCL) |\n\t\tnvt_cir_reg_read(nvt, CIR_FCCH) << 8;\n\n\tfor (i = 0; i < nvt->pkts; i++) {\n\t\tif (nvt->buf[i] & BUF_PULSE_BIT)\n\t\t\tduration += nvt->buf[i] & BUF_LEN_MASK;\n\t}\n\n\tduration *= SAMPLE_PERIOD;\n\n\tif (!count || !duration) {\n\t\tdev_notice(nvt_get_dev(nvt),\n\t\t\t   \"Unable to determine carrier! (c:%u, d:%u)\",\n\t\t\t   count, duration);\n\t\treturn 0;\n\t}\n\n\tcarrier = MS_TO_NS(count) / duration;\n\n\tif ((carrier > MAX_CARRIER) || (carrier < MIN_CARRIER))\n\t\tnvt_dbg(\"WTF? Carrier frequency out of range!\");\n\n\tnvt_dbg(\"Carrier frequency: %u (count %u, duration %u)\",\n\t\tcarrier, count, duration);\n\n\treturn carrier;\n}\n#endif\n\nstatic int nvt_ir_raw_set_wakeup_filter(struct rc_dev *dev,\n\t\t\t\t\tstruct rc_scancode_filter *sc_filter)\n{\n\tu8 buf_val;\n\tint i, ret, count;\n\tunsigned int val;\n\tstruct ir_raw_event *raw;\n\tu8 wake_buf[WAKEUP_MAX_SIZE];\n\tbool complete;\n\n\t \n\tif (!sc_filter->mask)\n\t\treturn 0;\n\n\traw = kmalloc_array(WAKEUP_MAX_SIZE, sizeof(*raw), GFP_KERNEL);\n\tif (!raw)\n\t\treturn -ENOMEM;\n\n\tret = ir_raw_encode_scancode(dev->wakeup_protocol, sc_filter->data,\n\t\t\t\t     raw, WAKEUP_MAX_SIZE);\n\tcomplete = (ret != -ENOBUFS);\n\tif (!complete)\n\t\tret = WAKEUP_MAX_SIZE;\n\telse if (ret < 0)\n\t\tgoto out_raw;\n\n\t \n\tfor (i = 0, count = 0; i < ret && count < WAKEUP_MAX_SIZE; ++i) {\n\t\tval = raw[i].duration / SAMPLE_PERIOD;\n\n\t\t \n\t\twhile (val > 0 && count < WAKEUP_MAX_SIZE) {\n\t\t\t \n\t\t\tif (complete && i == ret - 1 && val < BUF_LEN_MASK)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tbuf_val = (val > BUF_LEN_MASK) ? BUF_LEN_MASK : val;\n\n\t\t\twake_buf[count] = buf_val;\n\t\t\tval -= buf_val;\n\t\t\tif ((raw[i]).pulse)\n\t\t\t\twake_buf[count] |= BUF_PULSE_BIT;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tnvt_write_wakeup_codes(dev, wake_buf, count);\n\tret = 0;\nout_raw:\n\tkfree(raw);\n\n\treturn ret;\n}\n\n \nstatic void nvt_dump_rx_buf(struct nvt_dev *nvt)\n{\n\tint i;\n\n\tprintk(KERN_DEBUG \"%s (len %d): \", __func__, nvt->pkts);\n\tfor (i = 0; (i < nvt->pkts) && (i < RX_BUF_LEN); i++)\n\t\tprintk(KERN_CONT \"0x%02x \", nvt->buf[i]);\n\tprintk(KERN_CONT \"\\n\");\n}\n\n \nstatic void nvt_process_rx_ir_data(struct nvt_dev *nvt)\n{\n\tstruct ir_raw_event rawir = {};\n\tu8 sample;\n\tint i;\n\n\tnvt_dbg_verbose(\"%s firing\", __func__);\n\n\tif (debug)\n\t\tnvt_dump_rx_buf(nvt);\n\n\tnvt_dbg_verbose(\"Processing buffer of len %d\", nvt->pkts);\n\n\tfor (i = 0; i < nvt->pkts; i++) {\n\t\tsample = nvt->buf[i];\n\n\t\trawir.pulse = ((sample & BUF_PULSE_BIT) != 0);\n\t\trawir.duration = (sample & BUF_LEN_MASK) * SAMPLE_PERIOD;\n\n\t\tnvt_dbg(\"Storing %s with duration %d\",\n\t\t\trawir.pulse ? \"pulse\" : \"space\", rawir.duration);\n\n\t\tir_raw_event_store_with_filter(nvt->rdev, &rawir);\n\t}\n\n\tnvt->pkts = 0;\n\n\tnvt_dbg(\"Calling ir_raw_event_handle\\n\");\n\tir_raw_event_handle(nvt->rdev);\n\n\tnvt_dbg_verbose(\"%s done\", __func__);\n}\n\nstatic void nvt_handle_rx_fifo_overrun(struct nvt_dev *nvt)\n{\n\tdev_warn(nvt_get_dev(nvt), \"RX FIFO overrun detected, flushing data!\");\n\n\tnvt->pkts = 0;\n\tnvt_clear_cir_fifo(nvt);\n\tir_raw_event_overflow(nvt->rdev);\n}\n\n \nstatic void nvt_get_rx_ir_data(struct nvt_dev *nvt)\n{\n\tu8 fifocount;\n\tint i;\n\n\t \n\tfifocount = nvt_cir_reg_read(nvt, CIR_RXFCONT);\n\n\tnvt_dbg(\"attempting to fetch %u bytes from hw rx fifo\", fifocount);\n\n\t \n\tfor (i = 0; i < fifocount; i++)\n\t\tnvt->buf[i] = nvt_cir_reg_read(nvt, CIR_SRXFIFO);\n\n\tnvt->pkts = fifocount;\n\tnvt_dbg(\"%s: pkts now %d\", __func__, nvt->pkts);\n\n\tnvt_process_rx_ir_data(nvt);\n}\n\nstatic void nvt_cir_log_irqs(u8 status, u8 iren)\n{\n\tnvt_dbg(\"IRQ 0x%02x (IREN 0x%02x) :%s%s%s%s%s%s%s%s%s\",\n\t\tstatus, iren,\n\t\tstatus & CIR_IRSTS_RDR\t? \" RDR\"\t: \"\",\n\t\tstatus & CIR_IRSTS_RTR\t? \" RTR\"\t: \"\",\n\t\tstatus & CIR_IRSTS_PE\t? \" PE\"\t\t: \"\",\n\t\tstatus & CIR_IRSTS_RFO\t? \" RFO\"\t: \"\",\n\t\tstatus & CIR_IRSTS_TE\t? \" TE\"\t\t: \"\",\n\t\tstatus & CIR_IRSTS_TTR\t? \" TTR\"\t: \"\",\n\t\tstatus & CIR_IRSTS_TFU\t? \" TFU\"\t: \"\",\n\t\tstatus & CIR_IRSTS_GH\t? \" GH\"\t\t: \"\",\n\t\tstatus & ~(CIR_IRSTS_RDR | CIR_IRSTS_RTR | CIR_IRSTS_PE |\n\t\t\t   CIR_IRSTS_RFO | CIR_IRSTS_TE | CIR_IRSTS_TTR |\n\t\t\t   CIR_IRSTS_TFU | CIR_IRSTS_GH) ? \" ?\" : \"\");\n}\n\n \nstatic irqreturn_t nvt_cir_isr(int irq, void *data)\n{\n\tstruct nvt_dev *nvt = data;\n\tu8 status, iren;\n\n\tnvt_dbg_verbose(\"%s firing\", __func__);\n\n\tspin_lock(&nvt->lock);\n\n\t \n\tstatus = nvt_cir_reg_read(nvt, CIR_IRSTS);\n\tiren = nvt_cir_reg_read(nvt, CIR_IREN);\n\n\t \n\tif (status == 0xff && iren == 0xff) {\n\t\tspin_unlock(&nvt->lock);\n\t\tnvt_dbg_verbose(\"Spurious interrupt detected\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (!(status & iren)) {\n\t\tspin_unlock(&nvt->lock);\n\t\tnvt_dbg_verbose(\"%s exiting, IRSTS 0x0\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tnvt_cir_reg_write(nvt, status, CIR_IRSTS);\n\tnvt_cir_reg_write(nvt, 0, CIR_IRSTS);\n\n\tnvt_cir_log_irqs(status, iren);\n\n\tif (status & CIR_IRSTS_RFO)\n\t\tnvt_handle_rx_fifo_overrun(nvt);\n\telse if (status & (CIR_IRSTS_RTR | CIR_IRSTS_PE))\n\t\tnvt_get_rx_ir_data(nvt);\n\n\tspin_unlock(&nvt->lock);\n\n\tnvt_dbg_verbose(\"%s done\", __func__);\n\treturn IRQ_HANDLED;\n}\n\nstatic void nvt_enable_cir(struct nvt_dev *nvt)\n{\n\tunsigned long flags;\n\n\t \n\tnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR);\n\n\tspin_lock_irqsave(&nvt->lock, flags);\n\n\t \n\tnvt_cir_reg_write(nvt, CIR_IRCON_TXEN | CIR_IRCON_RXEN |\n\t\t\t  CIR_IRCON_RXINV | CIR_IRCON_SAMPLE_PERIOD_SEL,\n\t\t\t  CIR_IRCON);\n\n\t \n\tnvt_cir_reg_write(nvt, 0xff, CIR_IRSTS);\n\n\t \n\tnvt_set_cir_iren(nvt);\n\n\tspin_unlock_irqrestore(&nvt->lock, flags);\n}\n\nstatic void nvt_disable_cir(struct nvt_dev *nvt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&nvt->lock, flags);\n\n\t \n\tnvt_cir_reg_write(nvt, 0, CIR_IREN);\n\n\t \n\tnvt_cir_reg_write(nvt, 0xff, CIR_IRSTS);\n\n\t \n\tnvt_cir_reg_write(nvt, 0, CIR_IRCON);\n\n\t \n\tnvt_clear_cir_fifo(nvt);\n\tnvt_clear_tx_fifo(nvt);\n\n\tspin_unlock_irqrestore(&nvt->lock, flags);\n\n\t \n\tnvt_disable_logical_dev(nvt, LOGICAL_DEV_CIR);\n}\n\nstatic int nvt_open(struct rc_dev *dev)\n{\n\tstruct nvt_dev *nvt = dev->priv;\n\n\tnvt_enable_cir(nvt);\n\n\treturn 0;\n}\n\nstatic void nvt_close(struct rc_dev *dev)\n{\n\tstruct nvt_dev *nvt = dev->priv;\n\n\tnvt_disable_cir(nvt);\n}\n\n \nstatic int nvt_probe(struct pnp_dev *pdev, const struct pnp_device_id *dev_id)\n{\n\tstruct nvt_dev *nvt;\n\tstruct rc_dev *rdev;\n\tint ret;\n\n\tnvt = devm_kzalloc(&pdev->dev, sizeof(struct nvt_dev), GFP_KERNEL);\n\tif (!nvt)\n\t\treturn -ENOMEM;\n\n\t \n\tnvt->rdev = devm_rc_allocate_device(&pdev->dev, RC_DRIVER_IR_RAW);\n\tif (!nvt->rdev)\n\t\treturn -ENOMEM;\n\trdev = nvt->rdev;\n\n\t \n\tret = pnp_activate_dev(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not activate PNP device!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!pnp_port_valid(pdev, 0) ||\n\t    pnp_port_len(pdev, 0) < CIR_IOREG_LENGTH) {\n\t\tdev_err(&pdev->dev, \"IR PNP Port not valid!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pnp_irq_valid(pdev, 0)) {\n\t\tdev_err(&pdev->dev, \"PNP IRQ not valid!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pnp_port_valid(pdev, 1) ||\n\t    pnp_port_len(pdev, 1) < CIR_IOREG_LENGTH) {\n\t\tdev_err(&pdev->dev, \"Wake PNP Port not valid!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnvt->cir_addr = pnp_port_start(pdev, 0);\n\tnvt->cir_irq  = pnp_irq(pdev, 0);\n\n\tnvt->cir_wake_addr = pnp_port_start(pdev, 1);\n\n\tnvt->cr_efir = CR_EFIR;\n\tnvt->cr_efdr = CR_EFDR;\n\n\tspin_lock_init(&nvt->lock);\n\n\tpnp_set_drvdata(pdev, nvt);\n\n\tret = nvt_hw_detect(nvt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnvt_efm_enable(nvt);\n\tnvt_cir_ldev_init(nvt);\n\tnvt_cir_wake_ldev_init(nvt);\n\tnvt_efm_disable(nvt);\n\n\t \n\tnvt_cir_regs_init(nvt);\n\tnvt_cir_wake_regs_init(nvt);\n\n\t \n\trdev->priv = nvt;\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->allowed_wakeup_protocols = RC_PROTO_BIT_ALL_IR_ENCODER;\n\trdev->encode_wakeup = true;\n\trdev->open = nvt_open;\n\trdev->close = nvt_close;\n\trdev->s_wakeup_filter = nvt_ir_raw_set_wakeup_filter;\n\trdev->device_name = \"Nuvoton w836x7hg Infrared Remote Transceiver\";\n\trdev->input_phys = \"nuvoton/cir0\";\n\trdev->input_id.bustype = BUS_HOST;\n\trdev->input_id.vendor = PCI_VENDOR_ID_WINBOND2;\n\trdev->input_id.product = nvt->chip_major;\n\trdev->input_id.version = nvt->chip_minor;\n\trdev->driver_name = NVT_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\trdev->timeout = MS_TO_US(100);\n\t \n\trdev->rx_resolution = CIR_SAMPLE_PERIOD;\n#if 0\n\trdev->min_timeout = XYZ;\n\trdev->max_timeout = XYZ;\n#endif\n\tret = devm_rc_register_device(&pdev->dev, rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!devm_request_region(&pdev->dev, nvt->cir_addr,\n\t\t\t    CIR_IOREG_LENGTH, NVT_DRIVER_NAME))\n\t\treturn -EBUSY;\n\n\tret = devm_request_irq(&pdev->dev, nvt->cir_irq, nvt_cir_isr,\n\t\t\t       IRQF_SHARED, NVT_DRIVER_NAME, nvt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!devm_request_region(&pdev->dev, nvt->cir_wake_addr,\n\t\t\t    CIR_IOREG_LENGTH, NVT_DRIVER_NAME \"-wake\"))\n\t\treturn -EBUSY;\n\n\tret = device_create_file(&rdev->dev, &dev_attr_wakeup_data);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\tdev_notice(&pdev->dev, \"driver has been successfully loaded\\n\");\n\tif (debug) {\n\t\tcir_dump_regs(nvt);\n\t\tcir_wake_dump_regs(nvt);\n\t}\n\n\treturn 0;\n}\n\nstatic void nvt_remove(struct pnp_dev *pdev)\n{\n\tstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\n\n\tdevice_remove_file(&nvt->rdev->dev, &dev_attr_wakeup_data);\n\n\tnvt_disable_cir(nvt);\n\n\t \n\tnvt_enable_wake(nvt);\n}\n\nstatic int nvt_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\tstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\n\n\tnvt_dbg(\"%s called\", __func__);\n\n\tmutex_lock(&nvt->rdev->lock);\n\tif (nvt->rdev->users)\n\t\tnvt_disable_cir(nvt);\n\tmutex_unlock(&nvt->rdev->lock);\n\n\t \n\tnvt_enable_wake(nvt);\n\n\treturn 0;\n}\n\nstatic int nvt_resume(struct pnp_dev *pdev)\n{\n\tstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\n\n\tnvt_dbg(\"%s called\", __func__);\n\n\tnvt_cir_regs_init(nvt);\n\tnvt_cir_wake_regs_init(nvt);\n\n\tmutex_lock(&nvt->rdev->lock);\n\tif (nvt->rdev->users)\n\t\tnvt_enable_cir(nvt);\n\tmutex_unlock(&nvt->rdev->lock);\n\n\treturn 0;\n}\n\nstatic void nvt_shutdown(struct pnp_dev *pdev)\n{\n\tstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\n\n\tnvt_enable_wake(nvt);\n}\n\nstatic const struct pnp_device_id nvt_ids[] = {\n\t{ \"WEC0530\", 0 },    \n\t{ \"NTN0530\", 0 },    \n\t{ \"\", 0 },\n};\n\nstatic struct pnp_driver nvt_driver = {\n\t.name\t\t= NVT_DRIVER_NAME,\n\t.id_table\t= nvt_ids,\n\t.flags\t\t= PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.probe\t\t= nvt_probe,\n\t.remove\t\t= nvt_remove,\n\t.suspend\t= nvt_suspend,\n\t.resume\t\t= nvt_resume,\n\t.shutdown\t= nvt_shutdown,\n};\n\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Enable debugging output\");\n\nMODULE_DEVICE_TABLE(pnp, nvt_ids);\nMODULE_DESCRIPTION(\"Nuvoton W83667HG-A & W83677HG-I CIR driver\");\n\nMODULE_AUTHOR(\"Jarod Wilson <jarod@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(nvt_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}