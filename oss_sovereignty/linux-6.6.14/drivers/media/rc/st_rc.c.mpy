{
  "module_name": "st_rc.c",
  "hash_id": "ec12913c0400abbe27083903cef1921dc5e67e17f58fa6f419d616e5808a4c64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/st_rc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <media/rc-core.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_wakeirq.h>\n\nstruct st_rc_device {\n\tstruct device\t\t\t*dev;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tirq_wake;\n\tstruct clk\t\t\t*sys_clock;\n\tvoid __iomem\t\t\t*base;\t \n\tvoid __iomem\t\t\t*rx_base; \n\tstruct rc_dev\t\t\t*rdev;\n\tbool\t\t\t\toverclocking;\n\tint\t\t\t\tsample_mult;\n\tint\t\t\t\tsample_div;\n\tbool\t\t\t\trxuhfmode;\n\tstruct\treset_control\t\t*rstc;\n};\n\n \n#define IRB_SAMPLE_RATE_COMM\t0x64\t \n#define IRB_CLOCK_SEL\t\t0x70\t \n#define IRB_CLOCK_SEL_STATUS\t0x74\t \n \n#define IRB_RX_ON               0x40\t \n#define IRB_RX_SYS              0X44\t \n#define IRB_RX_INT_EN           0x48\t \n#define IRB_RX_INT_STATUS       0x4c\t \n#define IRB_RX_EN               0x50\t \n#define IRB_MAX_SYM_PERIOD      0x54\t \n#define IRB_RX_INT_CLEAR        0x58\t \n#define IRB_RX_STATUS           0x6c\t \n#define IRB_RX_NOISE_SUPPR      0x5c\t \n#define IRB_RX_POLARITY_INV     0x68\t \n\n \n#define IRB_RX_INTS\t\t0x0f\n#define IRB_RX_OVERRUN_INT\t0x04\n  \n#define MAX_SYMB_TIME\t\t0x5000\n#define IRB_SAMPLE_FREQ\t\t10000000\n#define\tIRB_FIFO_NOT_EMPTY\t0xff00\n#define IRB_OVERFLOW\t\t0x4\n#define IRB_TIMEOUT\t\t0xffff\n#define IR_ST_NAME \"st-rc\"\n\nstatic void st_rc_send_lirc_timeout(struct rc_dev *rdev)\n{\n\tstruct ir_raw_event ev = { .timeout = true, .duration = rdev->timeout };\n\tir_raw_event_store(rdev, &ev);\n}\n\n \n\nstatic irqreturn_t st_rc_rx_interrupt(int irq, void *data)\n{\n\tunsigned long timeout;\n\tunsigned int symbol, mark = 0;\n\tstruct st_rc_device *dev = data;\n\tint last_symbol = 0;\n\tu32 status, int_status;\n\tstruct ir_raw_event ev = {};\n\n\tif (dev->irq_wake)\n\t\tpm_wakeup_event(dev->dev, 0);\n\n\t \n\ttimeout = jiffies +  msecs_to_jiffies(10);\n\tdo {\n\t\tstatus  = readl(dev->rx_base + IRB_RX_STATUS);\n\t\tif (!(status & (IRB_FIFO_NOT_EMPTY | IRB_OVERFLOW)))\n\t\t\tbreak;\n\n\t\tint_status = readl(dev->rx_base + IRB_RX_INT_STATUS);\n\t\tif (unlikely(int_status & IRB_RX_OVERRUN_INT)) {\n\t\t\t \n\t\t\tir_raw_event_overflow(dev->rdev);\n\t\t\tdev_info(dev->dev, \"IR RX overrun\\n\");\n\t\t\twritel(IRB_RX_OVERRUN_INT,\n\t\t\t\t\tdev->rx_base + IRB_RX_INT_CLEAR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsymbol = readl(dev->rx_base + IRB_RX_SYS);\n\t\tmark = readl(dev->rx_base + IRB_RX_ON);\n\n\t\tif (symbol == IRB_TIMEOUT)\n\t\t\tlast_symbol = 1;\n\n\t\t  \n\t\tif ((mark > 2) && (symbol > 1)) {\n\t\t\tsymbol -= mark;\n\t\t\tif (dev->overclocking) {  \n\t\t\t\tsymbol *= dev->sample_mult;\n\t\t\t\tsymbol /= dev->sample_div;\n\t\t\t\tmark *= dev->sample_mult;\n\t\t\t\tmark /= dev->sample_div;\n\t\t\t}\n\n\t\t\tev.duration = mark;\n\t\t\tev.pulse = true;\n\t\t\tir_raw_event_store(dev->rdev, &ev);\n\n\t\t\tif (!last_symbol) {\n\t\t\t\tev.duration = symbol;\n\t\t\t\tev.pulse = false;\n\t\t\t\tir_raw_event_store(dev->rdev, &ev);\n\t\t\t} else  {\n\t\t\t\tst_rc_send_lirc_timeout(dev->rdev);\n\t\t\t}\n\n\t\t}\n\t\tlast_symbol = 0;\n\t} while (time_is_after_jiffies(timeout));\n\n\twritel(IRB_RX_INTS, dev->rx_base + IRB_RX_INT_CLEAR);\n\n\t \n\tir_raw_event_handle(dev->rdev);\n\treturn IRQ_HANDLED;\n}\n\nstatic int st_rc_hardware_init(struct st_rc_device *dev)\n{\n\tint ret;\n\tint baseclock, freqdiff;\n\tunsigned int rx_max_symbol_per = MAX_SYMB_TIME;\n\tunsigned int rx_sampling_freq_div;\n\n\t \n\treset_control_deassert(dev->rstc);\n\n\tret = clk_prepare_enable(dev->sys_clock);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to prepare/enable system clock\\n\");\n\t\treturn ret;\n\t}\n\n\tbaseclock = clk_get_rate(dev->sys_clock);\n\n\t \n\twritel(1, dev->rx_base + IRB_RX_POLARITY_INV);\n\n\trx_sampling_freq_div = baseclock / IRB_SAMPLE_FREQ;\n\twritel(rx_sampling_freq_div, dev->base + IRB_SAMPLE_RATE_COMM);\n\n\tfreqdiff = baseclock - (rx_sampling_freq_div * IRB_SAMPLE_FREQ);\n\tif (freqdiff) {  \n\t\tdev->overclocking = true;\n\t\tdev->sample_mult = 1000;\n\t\tdev->sample_div = baseclock / (10000 * rx_sampling_freq_div);\n\t\trx_max_symbol_per = (rx_max_symbol_per * 1000)/dev->sample_div;\n\t}\n\n\twritel(rx_max_symbol_per, dev->rx_base + IRB_MAX_SYM_PERIOD);\n\n\treturn 0;\n}\n\nstatic void st_rc_remove(struct platform_device *pdev)\n{\n\tstruct st_rc_device *rc_dev = platform_get_drvdata(pdev);\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\tclk_disable_unprepare(rc_dev->sys_clock);\n\trc_unregister_device(rc_dev->rdev);\n}\n\nstatic int st_rc_open(struct rc_dev *rdev)\n{\n\tstruct st_rc_device *dev = rdev->priv;\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\t \n\twritel(IRB_RX_INTS, dev->rx_base + IRB_RX_INT_EN);\n\twritel(0x01, dev->rx_base + IRB_RX_EN);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic void st_rc_close(struct rc_dev *rdev)\n{\n\tstruct st_rc_device *dev = rdev->priv;\n\t \n\twritel(0x00, dev->rx_base + IRB_RX_EN);\n\twritel(0x00, dev->rx_base + IRB_RX_INT_EN);\n}\n\nstatic int st_rc_probe(struct platform_device *pdev)\n{\n\tint ret = -EINVAL;\n\tstruct rc_dev *rdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct st_rc_device *rc_dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst char *rx_mode;\n\n\trc_dev = devm_kzalloc(dev, sizeof(struct st_rc_device), GFP_KERNEL);\n\n\tif (!rc_dev)\n\t\treturn -ENOMEM;\n\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\n\tif (!rdev)\n\t\treturn -ENOMEM;\n\n\tif (np && !of_property_read_string(np, \"rx-mode\", &rx_mode)) {\n\n\t\tif (!strcmp(rx_mode, \"uhf\")) {\n\t\t\trc_dev->rxuhfmode = true;\n\t\t} else if (!strcmp(rx_mode, \"infrared\")) {\n\t\t\trc_dev->rxuhfmode = false;\n\t\t} else {\n\t\t\tdev_err(dev, \"Unsupported rx mode [%s]\\n\", rx_mode);\n\t\t\tgoto err;\n\t\t}\n\n\t} else {\n\t\tgoto err;\n\t}\n\n\trc_dev->sys_clock = devm_clk_get(dev, NULL);\n\tif (IS_ERR(rc_dev->sys_clock)) {\n\t\tdev_err(dev, \"System clock not found\\n\");\n\t\tret = PTR_ERR(rc_dev->sys_clock);\n\t\tgoto err;\n\t}\n\n\trc_dev->irq = platform_get_irq(pdev, 0);\n\tif (rc_dev->irq < 0) {\n\t\tret = rc_dev->irq;\n\t\tgoto err;\n\t}\n\n\trc_dev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rc_dev->base)) {\n\t\tret = PTR_ERR(rc_dev->base);\n\t\tgoto err;\n\t}\n\n\tif (rc_dev->rxuhfmode)\n\t\trc_dev->rx_base = rc_dev->base + 0x40;\n\telse\n\t\trc_dev->rx_base = rc_dev->base;\n\n\trc_dev->rstc = reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(rc_dev->rstc)) {\n\t\tret = PTR_ERR(rc_dev->rstc);\n\t\tgoto err;\n\t}\n\n\trc_dev->dev = dev;\n\tplatform_set_drvdata(pdev, rc_dev);\n\tret = st_rc_hardware_init(rc_dev);\n\tif (ret)\n\t\tgoto err;\n\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\t \n\trdev->rx_resolution = 100;\n\trdev->timeout = MAX_SYMB_TIME;\n\trdev->priv = rc_dev;\n\trdev->open = st_rc_open;\n\trdev->close = st_rc_close;\n\trdev->driver_name = IR_ST_NAME;\n\trdev->map_name = RC_MAP_EMPTY;\n\trdev->device_name = \"ST Remote Control Receiver\";\n\n\tret = rc_register_device(rdev);\n\tif (ret < 0)\n\t\tgoto clkerr;\n\n\trc_dev->rdev = rdev;\n\tif (devm_request_irq(dev, rc_dev->irq, st_rc_rx_interrupt,\n\t\t\t     0, IR_ST_NAME, rc_dev) < 0) {\n\t\tdev_err(dev, \"IRQ %d register failed\\n\", rc_dev->irq);\n\t\tret = -EINVAL;\n\t\tgoto rcerr;\n\t}\n\n\t \n\tdevice_init_wakeup(dev, true);\n\tdev_pm_set_wake_irq(dev, rc_dev->irq);\n\n\t \n\tst_rc_send_lirc_timeout(rdev);\n\n\tdev_info(dev, \"setup in %s mode\\n\", rc_dev->rxuhfmode ? \"UHF\" : \"IR\");\n\n\treturn ret;\nrcerr:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nclkerr:\n\tclk_disable_unprepare(rc_dev->sys_clock);\nerr:\n\trc_free_device(rdev);\n\tdev_err(dev, \"Unable to register device (%d)\\n\", ret);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int st_rc_suspend(struct device *dev)\n{\n\tstruct st_rc_device *rc_dev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (!enable_irq_wake(rc_dev->irq))\n\t\t\trc_dev->irq_wake = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tpinctrl_pm_select_sleep_state(dev);\n\t\twritel(0x00, rc_dev->rx_base + IRB_RX_EN);\n\t\twritel(0x00, rc_dev->rx_base + IRB_RX_INT_EN);\n\t\tclk_disable_unprepare(rc_dev->sys_clock);\n\t\treset_control_assert(rc_dev->rstc);\n\t}\n\n\treturn 0;\n}\n\nstatic int st_rc_resume(struct device *dev)\n{\n\tint ret;\n\tstruct st_rc_device *rc_dev = dev_get_drvdata(dev);\n\tstruct rc_dev\t*rdev = rc_dev->rdev;\n\n\tif (rc_dev->irq_wake) {\n\t\tdisable_irq_wake(rc_dev->irq);\n\t\trc_dev->irq_wake = 0;\n\t} else {\n\t\tpinctrl_pm_select_default_state(dev);\n\t\tret = st_rc_hardware_init(rc_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rdev->users) {\n\t\t\twritel(IRB_RX_INTS, rc_dev->rx_base + IRB_RX_INT_EN);\n\t\t\twritel(0x01, rc_dev->rx_base + IRB_RX_EN);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(st_rc_pm_ops, st_rc_suspend, st_rc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id st_rc_match[] = {\n\t{ .compatible = \"st,comms-irb\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, st_rc_match);\n#endif\n\nstatic struct platform_driver st_rc_driver = {\n\t.driver = {\n\t\t.name = IR_ST_NAME,\n\t\t.of_match_table = of_match_ptr(st_rc_match),\n\t\t.pm     = &st_rc_pm_ops,\n\t},\n\t.probe = st_rc_probe,\n\t.remove_new = st_rc_remove,\n};\n\nmodule_platform_driver(st_rc_driver);\n\nMODULE_DESCRIPTION(\"RC Transceiver driver for STMicroelectronics platforms\");\nMODULE_AUTHOR(\"STMicroelectronics (R&D) Ltd\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}