{
  "module_name": "ir-nec-decoder.c",
  "hash_id": "d087e71261cd861313719f132a63b63411ce2d5772e9d525a93a29ce3849ae68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-nec-decoder.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define NEC_NBITS\t\t32\n#define NEC_UNIT\t\t563   \n#define NEC_HEADER_PULSE\t(16 * NEC_UNIT)\n#define NECX_HEADER_PULSE\t(8  * NEC_UNIT)  \n#define NEC_HEADER_SPACE\t(8  * NEC_UNIT)\n#define NEC_REPEAT_SPACE\t(4  * NEC_UNIT)\n#define NEC_BIT_PULSE\t\t(1  * NEC_UNIT)\n#define NEC_BIT_0_SPACE\t\t(1  * NEC_UNIT)\n#define NEC_BIT_1_SPACE\t\t(3  * NEC_UNIT)\n#define\tNEC_TRAILER_PULSE\t(1  * NEC_UNIT)\n#define\tNEC_TRAILER_SPACE\t(10 * NEC_UNIT)  \n#define NECX_REPEAT_BITS\t1\n\nenum nec_state {\n\tSTATE_INACTIVE,\n\tSTATE_HEADER_SPACE,\n\tSTATE_BIT_PULSE,\n\tSTATE_BIT_SPACE,\n\tSTATE_TRAILER_PULSE,\n\tSTATE_TRAILER_SPACE,\n};\n\n \nstatic int ir_nec_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct nec_dec *data = &dev->raw->nec;\n\tu32 scancode;\n\tenum rc_proto rc_proto;\n\tu8 address, not_address, command, not_command;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"NEC decode started at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, NEC_HEADER_PULSE, NEC_UNIT * 2)) {\n\t\t\tdata->is_nec_x = false;\n\t\t\tdata->necx_repeat = false;\n\t\t} else if (eq_margin(ev.duration, NECX_HEADER_PULSE, NEC_UNIT / 2))\n\t\t\tdata->is_nec_x = true;\n\t\telse\n\t\t\tbreak;\n\n\t\tdata->count = 0;\n\t\tdata->state = STATE_HEADER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_HEADER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, NEC_HEADER_SPACE, NEC_UNIT)) {\n\t\t\tdata->state = STATE_BIT_PULSE;\n\t\t\treturn 0;\n\t\t} else if (eq_margin(ev.duration, NEC_REPEAT_SPACE, NEC_UNIT / 2)) {\n\t\t\tdata->state = STATE_TRAILER_PULSE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase STATE_BIT_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, NEC_BIT_PULSE, NEC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (data->necx_repeat && data->count == NECX_REPEAT_BITS &&\n\t\t    geq_margin(ev.duration, NEC_TRAILER_SPACE, NEC_UNIT / 2)) {\n\t\t\tdev_dbg(&dev->dev, \"Repeat last key\\n\");\n\t\t\trc_repeat(dev);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t} else if (data->count > NECX_REPEAT_BITS)\n\t\t\tdata->necx_repeat = false;\n\n\t\tdata->bits <<= 1;\n\t\tif (eq_margin(ev.duration, NEC_BIT_1_SPACE, NEC_UNIT / 2))\n\t\t\tdata->bits |= 1;\n\t\telse if (!eq_margin(ev.duration, NEC_BIT_0_SPACE, NEC_UNIT / 2))\n\t\t\tbreak;\n\t\tdata->count++;\n\n\t\tif (data->count == NEC_NBITS)\n\t\t\tdata->state = STATE_TRAILER_PULSE;\n\t\telse\n\t\t\tdata->state = STATE_BIT_PULSE;\n\n\t\treturn 0;\n\n\tcase STATE_TRAILER_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, NEC_TRAILER_PULSE, NEC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_TRAILER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_TRAILER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, NEC_TRAILER_SPACE, NEC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tif (data->count == NEC_NBITS) {\n\t\t\taddress     = bitrev8((data->bits >> 24) & 0xff);\n\t\t\tnot_address = bitrev8((data->bits >> 16) & 0xff);\n\t\t\tcommand\t    = bitrev8((data->bits >>  8) & 0xff);\n\t\t\tnot_command = bitrev8((data->bits >>  0) & 0xff);\n\n\t\t\tscancode = ir_nec_bytes_to_scancode(address,\n\t\t\t\t\t\t\t    not_address,\n\t\t\t\t\t\t\t    command,\n\t\t\t\t\t\t\t    not_command,\n\t\t\t\t\t\t\t    &rc_proto);\n\n\t\t\tif (data->is_nec_x)\n\t\t\t\tdata->necx_repeat = true;\n\n\t\t\trc_keydown(dev, rc_proto, scancode, 0);\n\t\t} else {\n\t\t\trc_repeat(dev);\n\t\t}\n\n\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"NEC decode failed at count %d state %d (%uus %s)\\n\",\n\t\tdata->count, data->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\n \nstatic u32 ir_nec_scancode_to_raw(enum rc_proto protocol, u32 scancode)\n{\n\tunsigned int addr, addr_inv, data, data_inv;\n\n\tdata = scancode & 0xff;\n\n\tif (protocol == RC_PROTO_NEC32) {\n\t\t \n\t\t \n\t\taddr_inv   = (scancode >> 24) & 0xff;\n\t\taddr       = (scancode >> 16) & 0xff;\n\t\tdata_inv   = (scancode >>  8) & 0xff;\n\t} else if (protocol == RC_PROTO_NECX) {\n\t\t \n\t\t \n\t\taddr       = (scancode >> 16) & 0xff;\n\t\taddr_inv   = (scancode >>  8) & 0xff;\n\t\tdata_inv   = data ^ 0xff;\n\t} else {\n\t\t \n\t\t \n\t\taddr       = (scancode >>  8) & 0xff;\n\t\taddr_inv   = addr ^ 0xff;\n\t\tdata_inv   = data ^ 0xff;\n\t}\n\n\t \n\treturn data_inv << 24 |\n\t       data     << 16 |\n\t       addr_inv <<  8 |\n\t       addr;\n}\n\nstatic const struct ir_raw_timings_pd ir_nec_timings = {\n\t.header_pulse\t= NEC_HEADER_PULSE,\n\t.header_space\t= NEC_HEADER_SPACE,\n\t.bit_pulse\t= NEC_BIT_PULSE,\n\t.bit_space[0]\t= NEC_BIT_0_SPACE,\n\t.bit_space[1]\t= NEC_BIT_1_SPACE,\n\t.trailer_pulse\t= NEC_TRAILER_PULSE,\n\t.trailer_space\t= NEC_TRAILER_SPACE,\n\t.msb_first\t= 0,\n};\n\n \nstatic int ir_nec_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint ret;\n\tu32 raw;\n\n\t \n\traw = ir_nec_scancode_to_raw(protocol, scancode);\n\n\t \n\tret = ir_raw_gen_pd(&e, max, &ir_nec_timings, NEC_NBITS, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler nec_handler = {\n\t.protocols\t= RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\t\t\t\tRC_PROTO_BIT_NEC32,\n\t.decode\t\t= ir_nec_decode,\n\t.encode\t\t= ir_nec_encode,\n\t.carrier\t= 38000,\n\t.min_timeout\t= NEC_TRAILER_SPACE,\n};\n\nstatic int __init ir_nec_decode_init(void)\n{\n\tir_raw_handler_register(&nec_handler);\n\n\tprintk(KERN_INFO \"IR NEC protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_nec_decode_exit(void)\n{\n\tir_raw_handler_unregister(&nec_handler);\n}\n\nmodule_init(ir_nec_decode_init);\nmodule_exit(ir_nec_decode_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Red Hat Inc. (http://www.redhat.com)\");\nMODULE_DESCRIPTION(\"NEC IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}