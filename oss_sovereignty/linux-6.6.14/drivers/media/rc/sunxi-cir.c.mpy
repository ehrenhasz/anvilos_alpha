{
  "module_name": "sunxi-cir.c",
  "hash_id": "4a2c763cdd6e2ae1a86635403e0b172c832f6d62d91b47a94e63d3efb5ae82c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/sunxi-cir.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <media/rc-core.h>\n\n#define SUNXI_IR_DEV \"sunxi-ir\"\n\n \n \n#define SUNXI_IR_CTL_REG      0x00\n \n#define REG_CTL_GEN\t\t\tBIT(0)\n \n#define REG_CTL_RXEN\t\t\tBIT(1)\n \n#define REG_CTL_MD\t\t\t(BIT(4) | BIT(5))\n\n \n#define SUNXI_IR_RXCTL_REG    0x10\n \n#define REG_RXCTL_RPPI\t\t\tBIT(2)\n\n \n#define SUNXI_IR_RXFIFO_REG   0x20\n\n \n#define SUNXI_IR_RXINT_REG    0x2C\n \n#define REG_RXINT_ROI_EN\t\tBIT(0)\n \n#define REG_RXINT_RPEI_EN\t\tBIT(1)\n \n#define REG_RXINT_RAI_EN\t\tBIT(4)\n\n \n#define REG_RXINT_RAL(val)    ((val) << 8)\n\n \n#define SUNXI_IR_RXSTA_REG    0x30\n \n#define REG_RXSTA_ROI\t\t\tREG_RXINT_ROI_EN\n \n#define REG_RXSTA_RPE\t\t\tREG_RXINT_RPEI_EN\n \n#define REG_RXSTA_RA\t\t\tREG_RXINT_RAI_EN\n \n#define REG_RXSTA_GET_AC(val) (((val) >> 8) & (ir->fifo_size * 2 - 1))\n \n#define REG_RXSTA_CLEARALL    0xff\n\n \n#define SUNXI_IR_CIR_REG      0x34\n \n#define REG_CIR_NTHR(val)    (((val) << 2) & (GENMASK(7, 2)))\n \n#define REG_CIR_ITHR(val)    (((val) << 8) & (GENMASK(15, 8)))\n\n \n#define SUNXI_IR_BASE_CLK     8000000\n \n#define SUNXI_IR_RXNOISE      1\n\n \nstruct sunxi_ir_quirks {\n\tbool\t\thas_reset;\n\tint\t\tfifo_size;\n};\n\nstruct sunxi_ir {\n\tstruct rc_dev   *rc;\n\tvoid __iomem    *base;\n\tint             irq;\n\tint\t\tfifo_size;\n\tstruct clk      *clk;\n\tstruct clk      *apb_clk;\n\tstruct reset_control *rst;\n\tconst char      *map_name;\n};\n\nstatic irqreturn_t sunxi_ir_irq(int irqno, void *dev_id)\n{\n\tunsigned long status;\n\tunsigned char dt;\n\tunsigned int cnt, rc;\n\tstruct sunxi_ir *ir = dev_id;\n\tstruct ir_raw_event rawir = {};\n\n\tstatus = readl(ir->base + SUNXI_IR_RXSTA_REG);\n\n\t \n\twritel(status | REG_RXSTA_CLEARALL, ir->base + SUNXI_IR_RXSTA_REG);\n\n\tif (status & (REG_RXSTA_RA | REG_RXSTA_RPE)) {\n\t\t \n\t\trc  = REG_RXSTA_GET_AC(status);\n\t\t \n\t\trc = rc > ir->fifo_size ? ir->fifo_size : rc;\n\t\t \n\t\tfor (cnt = 0; cnt < rc; cnt++) {\n\t\t\t \n\t\t\tdt = readb(ir->base + SUNXI_IR_RXFIFO_REG);\n\t\t\trawir.pulse = (dt & 0x80) != 0;\n\t\t\trawir.duration = ((dt & 0x7f) + 1) *\n\t\t\t\t\t ir->rc->rx_resolution;\n\t\t\tir_raw_event_store_with_filter(ir->rc, &rawir);\n\t\t}\n\t}\n\n\tif (status & REG_RXSTA_ROI) {\n\t\tir_raw_event_overflow(ir->rc);\n\t} else if (status & REG_RXSTA_RPE) {\n\t\tir_raw_event_set_idle(ir->rc, true);\n\t\tir_raw_event_handle(ir->rc);\n\t} else {\n\t\tir_raw_event_handle(ir->rc);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic unsigned int sunxi_ithr_to_usec(unsigned int base_clk, unsigned int ithr)\n{\n\treturn DIV_ROUND_CLOSEST(USEC_PER_SEC * (ithr + 1),\n\t\t\t\t base_clk / (128 * 64));\n}\n\n \nstatic unsigned int sunxi_usec_to_ithr(unsigned int base_clk, unsigned int usec)\n{\n\t \n\treturn DIV_ROUND_UP((base_clk / (128 * 64)) * usec,  USEC_PER_SEC) - 1;\n}\n\nstatic int sunxi_ir_set_timeout(struct rc_dev *rc_dev, unsigned int timeout)\n{\n\tstruct sunxi_ir *ir = rc_dev->priv;\n\tunsigned int base_clk = clk_get_rate(ir->clk);\n\n\tunsigned int ithr = sunxi_usec_to_ithr(base_clk, timeout);\n\n\tdev_dbg(rc_dev->dev.parent, \"setting idle threshold to %u\\n\", ithr);\n\n\t \n\twritel(REG_CIR_NTHR(SUNXI_IR_RXNOISE) | REG_CIR_ITHR(ithr),\n\t       ir->base + SUNXI_IR_CIR_REG);\n\n\trc_dev->timeout = sunxi_ithr_to_usec(base_clk, ithr);\n\n\treturn 0;\n}\n\nstatic int sunxi_ir_hw_init(struct device *dev)\n{\n\tstruct sunxi_ir *ir = dev_get_drvdata(dev);\n\tu32 tmp;\n\tint ret;\n\n\tret = reset_control_deassert(ir->rst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ir->apb_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable apb clk\\n\");\n\t\tgoto exit_assert_reset;\n\t}\n\n\tret = clk_prepare_enable(ir->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ir clk\\n\");\n\t\tgoto exit_disable_apb_clk;\n\t}\n\n\t \n\twritel(REG_CTL_MD, ir->base + SUNXI_IR_CTL_REG);\n\n\t \n\tsunxi_ir_set_timeout(ir->rc, ir->rc->timeout);\n\n\t \n\twritel(REG_RXCTL_RPPI, ir->base + SUNXI_IR_RXCTL_REG);\n\n\t \n\twritel(REG_RXSTA_CLEARALL, ir->base + SUNXI_IR_RXSTA_REG);\n\n\t \n\twritel(REG_RXINT_ROI_EN | REG_RXINT_RPEI_EN |\n\t       REG_RXINT_RAI_EN | REG_RXINT_RAL(ir->fifo_size / 2 - 1),\n\t       ir->base + SUNXI_IR_RXINT_REG);\n\n\t \n\ttmp = readl(ir->base + SUNXI_IR_CTL_REG);\n\twritel(tmp | REG_CTL_GEN | REG_CTL_RXEN, ir->base + SUNXI_IR_CTL_REG);\n\n\treturn 0;\n\nexit_disable_apb_clk:\n\tclk_disable_unprepare(ir->apb_clk);\nexit_assert_reset:\n\treset_control_assert(ir->rst);\n\n\treturn ret;\n}\n\nstatic void sunxi_ir_hw_exit(struct device *dev)\n{\n\tstruct sunxi_ir *ir = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ir->clk);\n\tclk_disable_unprepare(ir->apb_clk);\n\treset_control_assert(ir->rst);\n}\n\nstatic int __maybe_unused sunxi_ir_suspend(struct device *dev)\n{\n\tsunxi_ir_hw_exit(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sunxi_ir_resume(struct device *dev)\n{\n\treturn sunxi_ir_hw_init(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(sunxi_ir_pm_ops, sunxi_ir_suspend, sunxi_ir_resume);\n\nstatic int sunxi_ir_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node;\n\tconst struct sunxi_ir_quirks *quirks;\n\tstruct sunxi_ir *ir;\n\tu32 b_clk_freq = SUNXI_IR_BASE_CLK;\n\n\tir = devm_kzalloc(dev, sizeof(struct sunxi_ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tquirks = of_device_get_match_data(&pdev->dev);\n\tif (!quirks) {\n\t\tdev_err(&pdev->dev, \"Failed to determine the quirks to use\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tir->fifo_size = quirks->fifo_size;\n\n\t \n\tir->apb_clk = devm_clk_get(dev, \"apb\");\n\tif (IS_ERR(ir->apb_clk)) {\n\t\tdev_err(dev, \"failed to get a apb clock.\\n\");\n\t\treturn PTR_ERR(ir->apb_clk);\n\t}\n\tir->clk = devm_clk_get(dev, \"ir\");\n\tif (IS_ERR(ir->clk)) {\n\t\tdev_err(dev, \"failed to get a ir clock.\\n\");\n\t\treturn PTR_ERR(ir->clk);\n\t}\n\n\t \n\tof_property_read_u32(dn, \"clock-frequency\", &b_clk_freq);\n\n\t \n\tif (quirks->has_reset) {\n\t\tir->rst = devm_reset_control_get_exclusive(dev, NULL);\n\t\tif (IS_ERR(ir->rst))\n\t\t\treturn PTR_ERR(ir->rst);\n\t}\n\n\tret = clk_set_rate(ir->clk, b_clk_freq);\n\tif (ret) {\n\t\tdev_err(dev, \"set ir base clock failed!\\n\");\n\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"set base clock frequency to %d Hz.\\n\", b_clk_freq);\n\n\t \n\tir->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ir->base)) {\n\t\treturn PTR_ERR(ir->base);\n\t}\n\n\tir->rc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!ir->rc) {\n\t\tdev_err(dev, \"failed to allocate device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tir->rc->priv = ir;\n\tir->rc->device_name = SUNXI_IR_DEV;\n\tir->rc->input_phys = \"sunxi-ir/input0\";\n\tir->rc->input_id.bustype = BUS_HOST;\n\tir->rc->input_id.vendor = 0x0001;\n\tir->rc->input_id.product = 0x0001;\n\tir->rc->input_id.version = 0x0100;\n\tir->map_name = of_get_property(dn, \"linux,rc-map-name\", NULL);\n\tir->rc->map_name = ir->map_name ?: RC_MAP_EMPTY;\n\tir->rc->dev.parent = dev;\n\tir->rc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\t \n\tir->rc->rx_resolution = (USEC_PER_SEC / (b_clk_freq / 64));\n\tir->rc->timeout = IR_DEFAULT_TIMEOUT;\n\tir->rc->min_timeout = sunxi_ithr_to_usec(b_clk_freq, 0);\n\tir->rc->max_timeout = sunxi_ithr_to_usec(b_clk_freq, 255);\n\tir->rc->s_timeout = sunxi_ir_set_timeout;\n\tir->rc->driver_name = SUNXI_IR_DEV;\n\n\tret = rc_register_device(ir->rc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register rc device\\n\");\n\t\tgoto exit_free_dev;\n\t}\n\n\tplatform_set_drvdata(pdev, ir);\n\n\t \n\tir->irq = platform_get_irq(pdev, 0);\n\tif (ir->irq < 0) {\n\t\tret = ir->irq;\n\t\tgoto exit_free_dev;\n\t}\n\n\tret = devm_request_irq(dev, ir->irq, sunxi_ir_irq, 0, SUNXI_IR_DEV, ir);\n\tif (ret) {\n\t\tdev_err(dev, \"failed request irq\\n\");\n\t\tgoto exit_free_dev;\n\t}\n\n\tret = sunxi_ir_hw_init(dev);\n\tif (ret)\n\t\tgoto exit_free_dev;\n\n\tdev_info(dev, \"initialized sunXi IR driver\\n\");\n\treturn 0;\n\nexit_free_dev:\n\trc_free_device(ir->rc);\n\n\treturn ret;\n}\n\nstatic void sunxi_ir_remove(struct platform_device *pdev)\n{\n\tstruct sunxi_ir *ir = platform_get_drvdata(pdev);\n\n\trc_unregister_device(ir->rc);\n\tsunxi_ir_hw_exit(&pdev->dev);\n}\n\nstatic void sunxi_ir_shutdown(struct platform_device *pdev)\n{\n\tsunxi_ir_hw_exit(&pdev->dev);\n}\n\nstatic const struct sunxi_ir_quirks sun4i_a10_ir_quirks = {\n\t.has_reset = false,\n\t.fifo_size = 16,\n};\n\nstatic const struct sunxi_ir_quirks sun5i_a13_ir_quirks = {\n\t.has_reset = false,\n\t.fifo_size = 64,\n};\n\nstatic const struct sunxi_ir_quirks sun6i_a31_ir_quirks = {\n\t.has_reset = true,\n\t.fifo_size = 64,\n};\n\nstatic const struct of_device_id sunxi_ir_match[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-ir\",\n\t\t.data = &sun4i_a10_ir_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun5i-a13-ir\",\n\t\t.data = &sun5i_a13_ir_quirks,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun6i-a31-ir\",\n\t\t.data = &sun6i_a31_ir_quirks,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sunxi_ir_match);\n\nstatic struct platform_driver sunxi_ir_driver = {\n\t.probe          = sunxi_ir_probe,\n\t.remove_new     = sunxi_ir_remove,\n\t.shutdown       = sunxi_ir_shutdown,\n\t.driver = {\n\t\t.name = SUNXI_IR_DEV,\n\t\t.of_match_table = sunxi_ir_match,\n\t\t.pm = &sunxi_ir_pm_ops,\n\t},\n};\n\nmodule_platform_driver(sunxi_ir_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sunXi IR controller driver\");\nMODULE_AUTHOR(\"Alexsey Shestacov <wingrime@linux-sunxi.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}