{
  "module_name": "ir-mce_kbd-decoder.c",
  "hash_id": "71faef19c8fa2a86a2bb59a94a70f645a489f9a6a0f72d3902b8fa994eba5fa2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-mce_kbd-decoder.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n\n#include \"rc-core-priv.h\"\n\n \n\n#define MCIR2_UNIT\t\t333\t \n#define MCIR2_HEADER_NBITS\t5\n#define MCIR2_MOUSE_NBITS\t29\n#define MCIR2_KEYBOARD_NBITS\t32\n#define MCIR2_PREFIX_PULSE\t(8 * MCIR2_UNIT)\n#define MCIR2_PREFIX_SPACE\t(1 * MCIR2_UNIT)\n#define MCIR2_MAX_LEN\t\t(3 * MCIR2_UNIT)\n#define MCIR2_BIT_START\t\t(1 * MCIR2_UNIT)\n#define MCIR2_BIT_END\t\t(1 * MCIR2_UNIT)\n#define MCIR2_BIT_0\t\t(1 * MCIR2_UNIT)\n#define MCIR2_BIT_SET\t\t(2 * MCIR2_UNIT)\n#define MCIR2_MODE_MASK\t\t0xf\t \n#define MCIR2_KEYBOARD_HEADER\t0x4\n#define MCIR2_MOUSE_HEADER\t0x1\n#define MCIR2_MASK_KEYS_START\t0xe0\n\nenum mce_kbd_mode {\n\tMCIR2_MODE_KEYBOARD,\n\tMCIR2_MODE_MOUSE,\n\tMCIR2_MODE_UNKNOWN,\n};\n\nenum mce_kbd_state {\n\tSTATE_INACTIVE,\n\tSTATE_HEADER_BIT_START,\n\tSTATE_HEADER_BIT_END,\n\tSTATE_BODY_BIT_START,\n\tSTATE_BODY_BIT_END,\n\tSTATE_FINISHED,\n};\n\nstatic unsigned char kbd_keycodes[256] = {\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_A,\n\tKEY_B,\t\tKEY_C,\t\tKEY_D,\t\tKEY_E,\t\tKEY_F,\n\tKEY_G,\t\tKEY_H,\t\tKEY_I,\t\tKEY_J,\t\tKEY_K,\n\tKEY_L,\t\tKEY_M,\t\tKEY_N,\t\tKEY_O,\t\tKEY_P,\n\tKEY_Q,\t\tKEY_R,\t\tKEY_S,\t\tKEY_T,\t\tKEY_U,\n\tKEY_V,\t\tKEY_W,\t\tKEY_X,\t\tKEY_Y,\t\tKEY_Z,\n\tKEY_1,\t\tKEY_2,\t\tKEY_3,\t\tKEY_4,\t\tKEY_5,\n\tKEY_6,\t\tKEY_7,\t\tKEY_8,\t\tKEY_9,\t\tKEY_0,\n\tKEY_ENTER,\tKEY_ESC,\tKEY_BACKSPACE,\tKEY_TAB,\tKEY_SPACE,\n\tKEY_MINUS,\tKEY_EQUAL,\tKEY_LEFTBRACE,\tKEY_RIGHTBRACE,\tKEY_BACKSLASH,\n\tKEY_BACKSLASH,\tKEY_SEMICOLON,\tKEY_APOSTROPHE,\tKEY_GRAVE,\tKEY_COMMA,\n\tKEY_DOT,\tKEY_SLASH,\tKEY_CAPSLOCK,\tKEY_F1,\t\tKEY_F2,\n\tKEY_F3,\t\tKEY_F4,\t\tKEY_F5,\t\tKEY_F6,\t\tKEY_F7,\n\tKEY_F8,\t\tKEY_F9,\t\tKEY_F10,\tKEY_F11,\tKEY_F12,\n\tKEY_SYSRQ,\tKEY_SCROLLLOCK,\tKEY_PAUSE,\tKEY_INSERT,\tKEY_HOME,\n\tKEY_PAGEUP,\tKEY_DELETE,\tKEY_END,\tKEY_PAGEDOWN,\tKEY_RIGHT,\n\tKEY_LEFT,\tKEY_DOWN,\tKEY_UP,\t\tKEY_NUMLOCK,\tKEY_KPSLASH,\n\tKEY_KPASTERISK,\tKEY_KPMINUS,\tKEY_KPPLUS,\tKEY_KPENTER,\tKEY_KP1,\n\tKEY_KP2,\tKEY_KP3,\tKEY_KP4,\tKEY_KP5,\tKEY_KP6,\n\tKEY_KP7,\tKEY_KP8,\tKEY_KP9,\tKEY_KP0,\tKEY_KPDOT,\n\tKEY_102ND,\tKEY_COMPOSE,\tKEY_POWER,\tKEY_KPEQUAL,\tKEY_F13,\n\tKEY_F14,\tKEY_F15,\tKEY_F16,\tKEY_F17,\tKEY_F18,\n\tKEY_F19,\tKEY_F20,\tKEY_F21,\tKEY_F22,\tKEY_F23,\n\tKEY_F24,\tKEY_OPEN,\tKEY_HELP,\tKEY_PROPS,\tKEY_FRONT,\n\tKEY_STOP,\tKEY_AGAIN,\tKEY_UNDO,\tKEY_CUT,\tKEY_COPY,\n\tKEY_PASTE,\tKEY_FIND,\tKEY_MUTE,\tKEY_VOLUMEUP,\tKEY_VOLUMEDOWN,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_KPCOMMA,\tKEY_RESERVED,\n\tKEY_RO,\t\tKEY_KATAKANAHIRAGANA, KEY_YEN,\tKEY_HENKAN,\tKEY_MUHENKAN,\n\tKEY_KPJPCOMMA,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_HANGUEL,\n\tKEY_HANJA,\tKEY_KATAKANA,\tKEY_HIRAGANA,\tKEY_ZENKAKUHANKAKU, KEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_LEFTCTRL,\n\tKEY_LEFTSHIFT,\tKEY_LEFTALT,\tKEY_LEFTMETA,\tKEY_RIGHTCTRL,\tKEY_RIGHTSHIFT,\n\tKEY_RIGHTALT,\tKEY_RIGHTMETA,\tKEY_PLAYPAUSE,\tKEY_STOPCD,\tKEY_PREVIOUSSONG,\n\tKEY_NEXTSONG,\tKEY_EJECTCD,\tKEY_VOLUMEUP,\tKEY_VOLUMEDOWN,\tKEY_MUTE,\n\tKEY_WWW,\tKEY_BACK,\tKEY_FORWARD,\tKEY_STOP,\tKEY_FIND,\n\tKEY_SCROLLUP,\tKEY_SCROLLDOWN,\tKEY_EDIT,\tKEY_SLEEP,\tKEY_COFFEE,\n\tKEY_REFRESH,\tKEY_CALC,\tKEY_RESERVED,\tKEY_RESERVED,\tKEY_RESERVED,\n\tKEY_RESERVED\n};\n\nstatic void mce_kbd_rx_timeout(struct timer_list *t)\n{\n\tstruct ir_raw_event_ctrl *raw = from_timer(raw, t, mce_kbd.rx_timeout);\n\tunsigned char maskcode;\n\tunsigned long flags;\n\tint i;\n\n\tdev_dbg(&raw->dev->dev, \"timer callback clearing all keys\\n\");\n\n\tspin_lock_irqsave(&raw->mce_kbd.keylock, flags);\n\n\tif (time_is_before_eq_jiffies(raw->mce_kbd.rx_timeout.expires)) {\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tmaskcode = kbd_keycodes[MCIR2_MASK_KEYS_START + i];\n\t\t\tinput_report_key(raw->dev->input_dev, maskcode, 0);\n\t\t}\n\n\t\tfor (i = 0; i < MCIR2_MASK_KEYS_START; i++)\n\t\t\tinput_report_key(raw->dev->input_dev, kbd_keycodes[i],\n\t\t\t\t\t 0);\n\n\t\tinput_sync(raw->dev->input_dev);\n\t}\n\tspin_unlock_irqrestore(&raw->mce_kbd.keylock, flags);\n}\n\nstatic enum mce_kbd_mode mce_kbd_mode(struct mce_kbd_dec *data)\n{\n\tswitch (data->header & MCIR2_MODE_MASK) {\n\tcase MCIR2_KEYBOARD_HEADER:\n\t\treturn MCIR2_MODE_KEYBOARD;\n\tcase MCIR2_MOUSE_HEADER:\n\t\treturn MCIR2_MODE_MOUSE;\n\tdefault:\n\t\treturn MCIR2_MODE_UNKNOWN;\n\t}\n}\n\nstatic void ir_mce_kbd_process_keyboard_data(struct rc_dev *dev, u32 scancode)\n{\n\tu8 keydata1  = (scancode >> 8) & 0xff;\n\tu8 keydata2  = (scancode >> 16) & 0xff;\n\tu8 shiftmask = scancode & 0xff;\n\tunsigned char maskcode;\n\tint i, keystate;\n\n\tdev_dbg(&dev->dev, \"keyboard: keydata2 = 0x%02x, keydata1 = 0x%02x, shiftmask = 0x%02x\\n\",\n\t\tkeydata2, keydata1, shiftmask);\n\n\tfor (i = 0; i < 7; i++) {\n\t\tmaskcode = kbd_keycodes[MCIR2_MASK_KEYS_START + i];\n\t\tif (shiftmask & (1 << i))\n\t\t\tkeystate = 1;\n\t\telse\n\t\t\tkeystate = 0;\n\t\tinput_report_key(dev->input_dev, maskcode, keystate);\n\t}\n\n\tif (keydata1)\n\t\tinput_report_key(dev->input_dev, kbd_keycodes[keydata1], 1);\n\tif (keydata2)\n\t\tinput_report_key(dev->input_dev, kbd_keycodes[keydata2], 1);\n\n\tif (!keydata1 && !keydata2) {\n\t\tfor (i = 0; i < MCIR2_MASK_KEYS_START; i++)\n\t\t\tinput_report_key(dev->input_dev, kbd_keycodes[i], 0);\n\t}\n}\n\nstatic void ir_mce_kbd_process_mouse_data(struct rc_dev *dev, u32 scancode)\n{\n\t \n\tu8 xdata = (scancode >> 7) & 0x7f;\n\tu8 ydata = (scancode >> 14) & 0x7f;\n\tint x, y;\n\t \n\tbool right = scancode & 0x40;\n\tbool left  = scancode & 0x20;\n\n\tif (xdata & 0x40)\n\t\tx = -((~xdata & 0x7f) + 1);\n\telse\n\t\tx = xdata;\n\n\tif (ydata & 0x40)\n\t\ty = -((~ydata & 0x7f) + 1);\n\telse\n\t\ty = ydata;\n\n\tdev_dbg(&dev->dev, \"mouse: x = %d, y = %d, btns = %s%s\\n\",\n\t\tx, y, left ? \"L\" : \"\", right ? \"R\" : \"\");\n\n\tinput_report_rel(dev->input_dev, REL_X, x);\n\tinput_report_rel(dev->input_dev, REL_Y, y);\n\n\tinput_report_key(dev->input_dev, BTN_LEFT, left);\n\tinput_report_key(dev->input_dev, BTN_RIGHT, right);\n}\n\n \nstatic int ir_mce_kbd_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct mce_kbd_dec *data = &dev->raw->mce_kbd;\n\tu32 scancode;\n\tunsigned long delay;\n\tstruct lirc_scancode lsc = {};\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (!geq_margin(ev.duration, MCIR2_UNIT, MCIR2_UNIT / 2))\n\t\tgoto out;\n\nagain:\n\tdev_dbg(&dev->dev, \"started at state %i (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tif (!geq_margin(ev.duration, MCIR2_UNIT, MCIR2_UNIT / 2))\n\t\treturn 0;\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!eq_margin(ev.duration, MCIR2_PREFIX_PULSE, MCIR2_UNIT))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_HEADER_BIT_START;\n\t\tdata->count = 0;\n\t\tdata->header = 0;\n\t\treturn 0;\n\n\tcase STATE_HEADER_BIT_START:\n\t\tif (geq_margin(ev.duration, MCIR2_MAX_LEN, MCIR2_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->header <<= 1;\n\t\tif (ev.pulse)\n\t\t\tdata->header |= 1;\n\t\tdata->count++;\n\t\tdata->state = STATE_HEADER_BIT_END;\n\t\treturn 0;\n\n\tcase STATE_HEADER_BIT_END:\n\t\tdecrease_duration(&ev, MCIR2_BIT_END);\n\n\t\tif (data->count != MCIR2_HEADER_NBITS) {\n\t\t\tdata->state = STATE_HEADER_BIT_START;\n\t\t\tgoto again;\n\t\t}\n\n\t\tswitch (mce_kbd_mode(data)) {\n\t\tcase MCIR2_MODE_KEYBOARD:\n\t\t\tdata->wanted_bits = MCIR2_KEYBOARD_NBITS;\n\t\t\tbreak;\n\t\tcase MCIR2_MODE_MOUSE:\n\t\t\tdata->wanted_bits = MCIR2_MOUSE_NBITS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"not keyboard or mouse data\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->count = 0;\n\t\tdata->body = 0;\n\t\tdata->state = STATE_BODY_BIT_START;\n\t\tgoto again;\n\n\tcase STATE_BODY_BIT_START:\n\t\tif (geq_margin(ev.duration, MCIR2_MAX_LEN, MCIR2_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->body <<= 1;\n\t\tif (ev.pulse)\n\t\t\tdata->body |= 1;\n\t\tdata->count++;\n\t\tdata->state = STATE_BODY_BIT_END;\n\t\treturn 0;\n\n\tcase STATE_BODY_BIT_END:\n\t\tif (data->count == data->wanted_bits)\n\t\t\tdata->state = STATE_FINISHED;\n\t\telse\n\t\t\tdata->state = STATE_BODY_BIT_START;\n\n\t\tdecrease_duration(&ev, MCIR2_BIT_END);\n\t\tgoto again;\n\n\tcase STATE_FINISHED:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tswitch (data->wanted_bits) {\n\t\tcase MCIR2_KEYBOARD_NBITS:\n\t\t\tscancode = data->body & 0xffffff;\n\t\t\tdev_dbg(&dev->dev, \"keyboard data 0x%08x\\n\",\n\t\t\t\tdata->body);\n\t\t\tspin_lock(&data->keylock);\n\t\t\tif (scancode) {\n\t\t\t\tdelay = usecs_to_jiffies(dev->timeout) +\n\t\t\t\t\tmsecs_to_jiffies(100);\n\t\t\t\tmod_timer(&data->rx_timeout, jiffies + delay);\n\t\t\t} else {\n\t\t\t\tdel_timer(&data->rx_timeout);\n\t\t\t}\n\t\t\t \n\t\t\tir_mce_kbd_process_keyboard_data(dev, scancode);\n\t\t\tspin_unlock(&data->keylock);\n\t\t\tlsc.rc_proto = RC_PROTO_MCIR2_KBD;\n\t\t\tbreak;\n\t\tcase MCIR2_MOUSE_NBITS:\n\t\t\tscancode = data->body & 0x1fffff;\n\t\t\tdev_dbg(&dev->dev, \"mouse data 0x%06x\\n\", scancode);\n\t\t\t \n\t\t\tir_mce_kbd_process_mouse_data(dev, scancode);\n\t\t\tlsc.rc_proto = RC_PROTO_MCIR2_MSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"not keyboard or mouse data\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tlsc.scancode = scancode;\n\t\tlirc_scancode_event(dev, &lsc);\n\t\tdata->state = STATE_INACTIVE;\n\t\tinput_event(dev->input_dev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_sync(dev->input_dev);\n\t\treturn 0;\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"failed at state %i (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic int ir_mce_kbd_register(struct rc_dev *dev)\n{\n\tstruct mce_kbd_dec *mce_kbd = &dev->raw->mce_kbd;\n\n\ttimer_setup(&mce_kbd->rx_timeout, mce_kbd_rx_timeout, 0);\n\tspin_lock_init(&mce_kbd->keylock);\n\n\treturn 0;\n}\n\nstatic int ir_mce_kbd_unregister(struct rc_dev *dev)\n{\n\tstruct mce_kbd_dec *mce_kbd = &dev->raw->mce_kbd;\n\n\tdel_timer_sync(&mce_kbd->rx_timeout);\n\n\treturn 0;\n}\n\nstatic const struct ir_raw_timings_manchester ir_mce_kbd_timings = {\n\t.leader_pulse\t= MCIR2_PREFIX_PULSE,\n\t.invert\t\t= 1,\n\t.clock\t\t= MCIR2_UNIT,\n\t.trailer_space\t= MCIR2_UNIT * 10,\n};\n\n \nstatic int ir_mce_kbd_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t     struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint len, ret;\n\tu64 raw;\n\n\tif (protocol == RC_PROTO_MCIR2_KBD) {\n\t\traw = scancode |\n\t\t      ((u64)MCIR2_KEYBOARD_HEADER << MCIR2_KEYBOARD_NBITS);\n\t\tlen = MCIR2_KEYBOARD_NBITS + MCIR2_HEADER_NBITS;\n\t} else {\n\t\traw = scancode |\n\t\t      ((u64)MCIR2_MOUSE_HEADER << MCIR2_MOUSE_NBITS);\n\t\tlen = MCIR2_MOUSE_NBITS + MCIR2_HEADER_NBITS;\n\t}\n\n\tret = ir_raw_gen_manchester(&e, max, &ir_mce_kbd_timings, len, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler mce_kbd_handler = {\n\t.protocols\t= RC_PROTO_BIT_MCIR2_KBD | RC_PROTO_BIT_MCIR2_MSE,\n\t.decode\t\t= ir_mce_kbd_decode,\n\t.encode\t\t= ir_mce_kbd_encode,\n\t.raw_register\t= ir_mce_kbd_register,\n\t.raw_unregister\t= ir_mce_kbd_unregister,\n\t.carrier\t= 36000,\n\t.min_timeout\t= MCIR2_MAX_LEN + MCIR2_UNIT / 2,\n};\n\nstatic int __init ir_mce_kbd_decode_init(void)\n{\n\tir_raw_handler_register(&mce_kbd_handler);\n\n\tprintk(KERN_INFO \"IR MCE Keyboard/mouse protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_mce_kbd_decode_exit(void)\n{\n\tir_raw_handler_unregister(&mce_kbd_handler);\n}\n\nmodule_init(ir_mce_kbd_decode_init);\nmodule_exit(ir_mce_kbd_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jarod Wilson <jarod@redhat.com>\");\nMODULE_DESCRIPTION(\"MCE Keyboard/mouse IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}