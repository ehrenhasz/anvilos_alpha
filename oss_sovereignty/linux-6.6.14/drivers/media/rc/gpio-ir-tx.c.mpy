{
  "module_name": "gpio-ir-tx.c",
  "hash_id": "cdc38fa1b6fecc8131b7eea473d61cebf0485c229c264423b3f221403616d4da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/gpio-ir-tx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\"gpio-ir-tx\"\n#define DEVICE_NAME\t\"GPIO IR Bit Banging Transmitter\"\n\nstruct gpio_ir {\n\tstruct gpio_desc *gpio;\n\tunsigned int carrier;\n\tunsigned int duty_cycle;\n};\n\nstatic const struct of_device_id gpio_ir_tx_of_match[] = {\n\t{ .compatible = \"gpio-ir-tx\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gpio_ir_tx_of_match);\n\nstatic int gpio_ir_tx_set_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\n{\n\tstruct gpio_ir *gpio_ir = dev->priv;\n\n\tgpio_ir->duty_cycle = duty_cycle;\n\n\treturn 0;\n}\n\nstatic int gpio_ir_tx_set_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct gpio_ir *gpio_ir = dev->priv;\n\n\tif (carrier > 500000)\n\t\treturn -EINVAL;\n\n\tgpio_ir->carrier = carrier;\n\n\treturn 0;\n}\n\nstatic void delay_until(ktime_t until)\n{\n\t \n\ts32 delta;\n\n\twhile (true) {\n\t\tdelta = ktime_us_delta(until, ktime_get());\n\t\tif (delta <= 0)\n\t\t\treturn;\n\n\t\t \n\t\tif (delta >= 1000) {\n\t\t\tmdelay(delta / 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tudelay(delta);\n\t\tbreak;\n\t}\n}\n\nstatic void gpio_ir_tx_unmodulated(struct gpio_ir *gpio_ir, uint *txbuf,\n\t\t\t\t   uint count)\n{\n\tktime_t edge;\n\tint i;\n\n\tlocal_irq_disable();\n\n\tedge = ktime_get();\n\n\tfor (i = 0; i < count; i++) {\n\t\tgpiod_set_value(gpio_ir->gpio, !(i % 2));\n\n\t\tedge = ktime_add_us(edge, txbuf[i]);\n\t\tdelay_until(edge);\n\t}\n\n\tgpiod_set_value(gpio_ir->gpio, 0);\n}\n\nstatic void gpio_ir_tx_modulated(struct gpio_ir *gpio_ir, uint *txbuf,\n\t\t\t\t uint count)\n{\n\tktime_t edge;\n\t \n\ts32 delta;\n\tint i;\n\tunsigned int pulse, space;\n\n\t \n\tpulse = DIV_ROUND_CLOSEST(gpio_ir->duty_cycle * (NSEC_PER_SEC / 100),\n\t\t\t\t  gpio_ir->carrier);\n\tspace = DIV_ROUND_CLOSEST((100 - gpio_ir->duty_cycle) *\n\t\t\t\t  (NSEC_PER_SEC / 100), gpio_ir->carrier);\n\n\tlocal_irq_disable();\n\n\tedge = ktime_get();\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (i % 2) {\n\t\t\t\n\t\t\tedge = ktime_add_us(edge, txbuf[i]);\n\t\t\tdelay_until(edge);\n\t\t} else {\n\t\t\t\n\t\t\tktime_t last = ktime_add_us(edge, txbuf[i]);\n\n\t\t\twhile (ktime_before(ktime_get(), last)) {\n\t\t\t\tgpiod_set_value(gpio_ir->gpio, 1);\n\t\t\t\tedge = ktime_add_ns(edge, pulse);\n\t\t\t\tdelta = ktime_to_ns(ktime_sub(edge,\n\t\t\t\t\t\t\t      ktime_get()));\n\t\t\t\tif (delta > 0)\n\t\t\t\t\tndelay(delta);\n\t\t\t\tgpiod_set_value(gpio_ir->gpio, 0);\n\t\t\t\tedge = ktime_add_ns(edge, space);\n\t\t\t\tdelta = ktime_to_ns(ktime_sub(edge,\n\t\t\t\t\t\t\t      ktime_get()));\n\t\t\t\tif (delta > 0)\n\t\t\t\t\tndelay(delta);\n\t\t\t}\n\n\t\t\tedge = last;\n\t\t}\n\t}\n}\n\nstatic int gpio_ir_tx(struct rc_dev *dev, unsigned int *txbuf,\n\t\t      unsigned int count)\n{\n\tstruct gpio_ir *gpio_ir = dev->priv;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tif (gpio_ir->carrier)\n\t\tgpio_ir_tx_modulated(gpio_ir, txbuf, count);\n\telse\n\t\tgpio_ir_tx_unmodulated(gpio_ir, txbuf, count);\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}\n\nstatic int gpio_ir_tx_probe(struct platform_device *pdev)\n{\n\tstruct gpio_ir *gpio_ir;\n\tstruct rc_dev *rcdev;\n\tint rc;\n\n\tgpio_ir = devm_kmalloc(&pdev->dev, sizeof(*gpio_ir), GFP_KERNEL);\n\tif (!gpio_ir)\n\t\treturn -ENOMEM;\n\n\trcdev = devm_rc_allocate_device(&pdev->dev, RC_DRIVER_IR_RAW_TX);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\tgpio_ir->gpio = devm_gpiod_get(&pdev->dev, NULL, GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio_ir->gpio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(gpio_ir->gpio),\n\t\t\t\t     \"Failed to get gpio\\n\");\n\n\trcdev->priv = gpio_ir;\n\trcdev->driver_name = DRIVER_NAME;\n\trcdev->device_name = DEVICE_NAME;\n\trcdev->tx_ir = gpio_ir_tx;\n\trcdev->s_tx_duty_cycle = gpio_ir_tx_set_duty_cycle;\n\trcdev->s_tx_carrier = gpio_ir_tx_set_carrier;\n\n\tgpio_ir->carrier = 38000;\n\tgpio_ir->duty_cycle = 50;\n\n\trc = devm_rc_register_device(&pdev->dev, rcdev);\n\tif (rc < 0)\n\t\tdev_err(&pdev->dev, \"failed to register rc device\\n\");\n\n\treturn rc;\n}\n\nstatic struct platform_driver gpio_ir_tx_driver = {\n\t.probe\t= gpio_ir_tx_probe,\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = gpio_ir_tx_of_match,\n\t},\n};\nmodule_platform_driver(gpio_ir_tx_driver);\n\nMODULE_DESCRIPTION(\"GPIO IR Bit Banging Transmitter\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}