{
  "module_name": "lirc_dev.c",
  "hash_id": "8e80a0961e649e4330a0f1b4fc326d124f4ebceb3c6bbe22eb851240114f93c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/lirc_dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n\n#include \"rc-core-priv.h\"\n#include <uapi/linux/lirc.h>\n\n#define LIRCBUF_SIZE\t1024\n\nstatic dev_t lirc_base_dev;\n\n \nstatic DEFINE_IDA(lirc_ida);\n\n \nstatic struct class *lirc_class;\n\n \nvoid lirc_raw_event(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tunsigned long flags;\n\tstruct lirc_fh *fh;\n\tint sample;\n\n\t \n\tif (ev.overflow) {\n\t\t \n\t\tsample = LIRC_OVERFLOW(LIRC_VALUE_MASK);\n\t\tdev_dbg(&dev->dev, \"delivering overflow to lirc_dev\\n\");\n\n\t \n\t} else if (ev.carrier_report) {\n\t\tsample = LIRC_FREQUENCY(ev.carrier);\n\t\tdev_dbg(&dev->dev, \"carrier report (freq: %d)\\n\", sample);\n\n\t \n\t} else if (ev.timeout) {\n\t\tdev->gap_start = ktime_get();\n\n\t\tsample = LIRC_TIMEOUT(ev.duration);\n\t\tdev_dbg(&dev->dev, \"timeout report (duration: %d)\\n\", sample);\n\n\t \n\t} else {\n\t\tif (dev->gap_start) {\n\t\t\tu64 duration = ktime_us_delta(ktime_get(),\n\t\t\t\t\t\t      dev->gap_start);\n\n\t\t\t \n\t\t\tduration = min_t(u64, duration, LIRC_VALUE_MASK);\n\n\t\t\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\t\t\tlist_for_each_entry(fh, &dev->lirc_fh, list)\n\t\t\t\tkfifo_put(&fh->rawir, LIRC_SPACE(duration));\n\t\t\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n\t\t\tdev->gap_start = 0;\n\t\t}\n\n\t\tsample = ev.pulse ? LIRC_PULSE(ev.duration) :\n\t\t\t\t\tLIRC_SPACE(ev.duration);\n\t\tdev_dbg(&dev->dev, \"delivering %uus %s to lirc_dev\\n\",\n\t\t\tev.duration, TO_STR(ev.pulse));\n\t}\n\n\t \n\tlirc_bpf_run(dev, sample);\n\n\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\tlist_for_each_entry(fh, &dev->lirc_fh, list) {\n\t\tif (kfifo_put(&fh->rawir, sample))\n\t\t\twake_up_poll(&fh->wait_poll, EPOLLIN | EPOLLRDNORM);\n\t}\n\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n}\n\n \nvoid lirc_scancode_event(struct rc_dev *dev, struct lirc_scancode *lsc)\n{\n\tunsigned long flags;\n\tstruct lirc_fh *fh;\n\n\tlsc->timestamp = ktime_get_ns();\n\n\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\tlist_for_each_entry(fh, &dev->lirc_fh, list) {\n\t\tif (kfifo_put(&fh->scancodes, *lsc))\n\t\t\twake_up_poll(&fh->wait_poll, EPOLLIN | EPOLLRDNORM);\n\t}\n\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n}\nEXPORT_SYMBOL_GPL(lirc_scancode_event);\n\nstatic int lirc_open(struct inode *inode, struct file *file)\n{\n\tstruct rc_dev *dev = container_of(inode->i_cdev, struct rc_dev,\n\t\t\t\t\t  lirc_cdev);\n\tstruct lirc_fh *fh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\tunsigned long flags;\n\tint retval;\n\n\tif (!fh)\n\t\treturn -ENOMEM;\n\n\tget_device(&dev->dev);\n\n\tif (!dev->registered) {\n\t\tretval = -ENODEV;\n\t\tgoto out_fh;\n\t}\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW) {\n\t\tif (kfifo_alloc(&fh->rawir, MAX_IR_EVENT_SIZE, GFP_KERNEL)) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_fh;\n\t\t}\n\t}\n\n\tif (dev->driver_type != RC_DRIVER_IR_RAW_TX) {\n\t\tif (kfifo_alloc(&fh->scancodes, 32, GFP_KERNEL)) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_rawir;\n\t\t}\n\t}\n\n\tfh->send_mode = LIRC_MODE_PULSE;\n\tfh->rc = dev;\n\n\tif (dev->driver_type == RC_DRIVER_SCANCODE)\n\t\tfh->rec_mode = LIRC_MODE_SCANCODE;\n\telse\n\t\tfh->rec_mode = LIRC_MODE_MODE2;\n\n\tretval = rc_open(dev);\n\tif (retval)\n\t\tgoto out_kfifo;\n\n\tinit_waitqueue_head(&fh->wait_poll);\n\n\tfile->private_data = fh;\n\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\tlist_add(&fh->list, &dev->lirc_fh);\n\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n\n\tstream_open(inode, file);\n\n\treturn 0;\nout_kfifo:\n\tif (dev->driver_type != RC_DRIVER_IR_RAW_TX)\n\t\tkfifo_free(&fh->scancodes);\nout_rawir:\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\tkfifo_free(&fh->rawir);\nout_fh:\n\tkfree(fh);\n\tput_device(&dev->dev);\n\n\treturn retval;\n}\n\nstatic int lirc_close(struct inode *inode, struct file *file)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *dev = fh->rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\tlist_del(&fh->list);\n\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\tkfifo_free(&fh->rawir);\n\tif (dev->driver_type != RC_DRIVER_IR_RAW_TX)\n\t\tkfifo_free(&fh->scancodes);\n\tkfree(fh);\n\n\trc_close(dev);\n\tput_device(&dev->dev);\n\n\treturn 0;\n}\n\nstatic ssize_t lirc_transmit(struct file *file, const char __user *buf,\n\t\t\t     size_t n, loff_t *ppos)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *dev = fh->rc;\n\tunsigned int *txbuf;\n\tstruct ir_raw_event *raw = NULL;\n\tssize_t ret;\n\tsize_t count;\n\tktime_t start;\n\ts64 towait;\n\tunsigned int duration = 0;  \n\tint i;\n\n\tret = mutex_lock_interruptible(&dev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dev->registered) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!dev->tx_ir) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (fh->send_mode == LIRC_MODE_SCANCODE) {\n\t\tstruct lirc_scancode scan;\n\n\t\tif (n != sizeof(scan)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (copy_from_user(&scan, buf, sizeof(scan))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (scan.flags || scan.keycode || scan.timestamp ||\n\t\t    scan.rc_proto > RC_PROTO_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (scan.scancode > U32_MAX ||\n\t\t    !rc_validate_scancode(scan.rc_proto, scan.scancode)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\traw = kmalloc_array(LIRCBUF_SIZE, sizeof(*raw), GFP_KERNEL);\n\t\tif (!raw) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tret = ir_raw_encode_scancode(scan.rc_proto, scan.scancode,\n\t\t\t\t\t     raw, LIRCBUF_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto out_kfree_raw;\n\n\t\t \n\t\tif (!(ret % 2))\n\t\t\tcount = ret - 1;\n\t\telse\n\t\t\tcount = ret;\n\n\t\ttxbuf = kmalloc_array(count, sizeof(unsigned int), GFP_KERNEL);\n\t\tif (!txbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_kfree_raw;\n\t\t}\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\ttxbuf[i] = raw[i].duration;\n\n\t\tif (dev->s_tx_carrier) {\n\t\t\tint carrier = ir_raw_encode_carrier(scan.rc_proto);\n\n\t\t\tif (carrier > 0)\n\t\t\t\tdev->s_tx_carrier(dev, carrier);\n\t\t}\n\t} else {\n\t\tif (n < sizeof(unsigned int) || n % sizeof(unsigned int)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tcount = n / sizeof(unsigned int);\n\t\tif (count > LIRCBUF_SIZE || count % 2 == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttxbuf = memdup_user(buf, n);\n\t\tif (IS_ERR(txbuf)) {\n\t\t\tret = PTR_ERR(txbuf);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (txbuf[i] > IR_MAX_DURATION - duration || !txbuf[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_kfree;\n\t\t}\n\n\t\tduration += txbuf[i];\n\t}\n\n\tstart = ktime_get();\n\n\tret = dev->tx_ir(dev, txbuf, count);\n\tif (ret < 0)\n\t\tgoto out_kfree;\n\n\tkfree(txbuf);\n\tkfree(raw);\n\tmutex_unlock(&dev->lock);\n\n\t \n\ttowait = ktime_us_delta(ktime_add_us(start, duration),\n\t\t\t\tktime_get());\n\tif (towait > 0) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(usecs_to_jiffies(towait));\n\t}\n\n\treturn n;\nout_kfree:\n\tkfree(txbuf);\nout_kfree_raw:\n\tkfree(raw);\nout_unlock:\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic long lirc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *dev = fh->rc;\n\tu32 __user *argp = (u32 __user *)(arg);\n\tu32 val = 0;\n\tint ret;\n\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = get_user(val, argp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mutex_lock_interruptible(&dev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dev->registered) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase LIRC_GET_FEATURES:\n\t\tif (dev->driver_type == RC_DRIVER_SCANCODE)\n\t\t\tval |= LIRC_CAN_REC_SCANCODE;\n\n\t\tif (dev->driver_type == RC_DRIVER_IR_RAW) {\n\t\t\tval |= LIRC_CAN_REC_MODE2;\n\t\t\tif (dev->rx_resolution)\n\t\t\t\tval |= LIRC_CAN_GET_REC_RESOLUTION;\n\t\t}\n\n\t\tif (dev->tx_ir) {\n\t\t\tval |= LIRC_CAN_SEND_PULSE;\n\t\t\tif (dev->s_tx_mask)\n\t\t\t\tval |= LIRC_CAN_SET_TRANSMITTER_MASK;\n\t\t\tif (dev->s_tx_carrier)\n\t\t\t\tval |= LIRC_CAN_SET_SEND_CARRIER;\n\t\t\tif (dev->s_tx_duty_cycle)\n\t\t\t\tval |= LIRC_CAN_SET_SEND_DUTY_CYCLE;\n\t\t}\n\n\t\tif (dev->s_rx_carrier_range)\n\t\t\tval |= LIRC_CAN_SET_REC_CARRIER |\n\t\t\t\tLIRC_CAN_SET_REC_CARRIER_RANGE;\n\n\t\tif (dev->s_wideband_receiver)\n\t\t\tval |= LIRC_CAN_USE_WIDEBAND_RECEIVER;\n\n\t\tif (dev->s_carrier_report)\n\t\t\tval |= LIRC_CAN_MEASURE_CARRIER;\n\n\t\tif (dev->max_timeout)\n\t\t\tval |= LIRC_CAN_SET_REC_TIMEOUT;\n\n\t\tbreak;\n\n\t \n\tcase LIRC_GET_REC_MODE:\n\t\tif (dev->driver_type == RC_DRIVER_IR_RAW_TX)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = fh->rec_mode;\n\t\tbreak;\n\n\tcase LIRC_SET_REC_MODE:\n\t\tswitch (dev->driver_type) {\n\t\tcase RC_DRIVER_IR_RAW_TX:\n\t\t\tret = -ENOTTY;\n\t\t\tbreak;\n\t\tcase RC_DRIVER_SCANCODE:\n\t\t\tif (val != LIRC_MODE_SCANCODE)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\tcase RC_DRIVER_IR_RAW:\n\t\t\tif (!(val == LIRC_MODE_MODE2 ||\n\t\t\t      val == LIRC_MODE_SCANCODE))\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tfh->rec_mode = val;\n\t\tbreak;\n\n\tcase LIRC_GET_SEND_MODE:\n\t\tif (!dev->tx_ir)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = fh->send_mode;\n\t\tbreak;\n\n\tcase LIRC_SET_SEND_MODE:\n\t\tif (!dev->tx_ir)\n\t\t\tret = -ENOTTY;\n\t\telse if (!(val == LIRC_MODE_PULSE || val == LIRC_MODE_SCANCODE))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tfh->send_mode = val;\n\t\tbreak;\n\n\t \n\tcase LIRC_SET_TRANSMITTER_MASK:\n\t\tif (!dev->s_tx_mask)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tret = dev->s_tx_mask(dev, val);\n\t\tbreak;\n\n\tcase LIRC_SET_SEND_CARRIER:\n\t\tif (!dev->s_tx_carrier)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tret = dev->s_tx_carrier(dev, val);\n\t\tbreak;\n\n\tcase LIRC_SET_SEND_DUTY_CYCLE:\n\t\tif (!dev->s_tx_duty_cycle)\n\t\t\tret = -ENOTTY;\n\t\telse if (val <= 0 || val >= 100)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = dev->s_tx_duty_cycle(dev, val);\n\t\tbreak;\n\n\t \n\tcase LIRC_SET_REC_CARRIER:\n\t\tif (!dev->s_rx_carrier_range)\n\t\t\tret = -ENOTTY;\n\t\telse if (val <= 0)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = dev->s_rx_carrier_range(dev, fh->carrier_low,\n\t\t\t\t\t\t      val);\n\t\tbreak;\n\n\tcase LIRC_SET_REC_CARRIER_RANGE:\n\t\tif (!dev->s_rx_carrier_range)\n\t\t\tret = -ENOTTY;\n\t\telse if (val <= 0)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tfh->carrier_low = val;\n\t\tbreak;\n\n\tcase LIRC_GET_REC_RESOLUTION:\n\t\tif (!dev->rx_resolution)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = dev->rx_resolution;\n\t\tbreak;\n\n\tcase LIRC_SET_WIDEBAND_RECEIVER:\n\t\tif (!dev->s_wideband_receiver)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tret = dev->s_wideband_receiver(dev, !!val);\n\t\tbreak;\n\n\tcase LIRC_SET_MEASURE_CARRIER_MODE:\n\t\tif (!dev->s_carrier_report)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tret = dev->s_carrier_report(dev, !!val);\n\t\tbreak;\n\n\t \n\tcase LIRC_GET_MIN_TIMEOUT:\n\t\tif (!dev->max_timeout)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = dev->min_timeout;\n\t\tbreak;\n\n\tcase LIRC_GET_MAX_TIMEOUT:\n\t\tif (!dev->max_timeout)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = dev->max_timeout;\n\t\tbreak;\n\n\tcase LIRC_SET_REC_TIMEOUT:\n\t\tif (!dev->max_timeout) {\n\t\t\tret = -ENOTTY;\n\t\t} else {\n\t\t\tif (val < dev->min_timeout || val > dev->max_timeout)\n\t\t\t\tret = -EINVAL;\n\t\t\telse if (dev->s_timeout)\n\t\t\t\tret = dev->s_timeout(dev, val);\n\t\t\telse\n\t\t\t\tdev->timeout = val;\n\t\t}\n\t\tbreak;\n\n\tcase LIRC_GET_REC_TIMEOUT:\n\t\tif (!dev->timeout)\n\t\t\tret = -ENOTTY;\n\t\telse\n\t\t\tval = dev->timeout;\n\t\tbreak;\n\n\tcase LIRC_SET_REC_TIMEOUT_REPORTS:\n\t\tif (dev->driver_type != RC_DRIVER_IR_RAW)\n\t\t\tret = -ENOTTY;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\n\tif (!ret && _IOC_DIR(cmd) & _IOC_READ)\n\t\tret = put_user(val, argp);\n\nout:\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic __poll_t lirc_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *rcdev = fh->rc;\n\t__poll_t events = 0;\n\n\tpoll_wait(file, &fh->wait_poll, wait);\n\n\tif (!rcdev->registered) {\n\t\tevents = EPOLLHUP | EPOLLERR;\n\t} else if (rcdev->driver_type != RC_DRIVER_IR_RAW_TX) {\n\t\tif (fh->rec_mode == LIRC_MODE_SCANCODE &&\n\t\t    !kfifo_is_empty(&fh->scancodes))\n\t\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\t\tif (fh->rec_mode == LIRC_MODE_MODE2 &&\n\t\t    !kfifo_is_empty(&fh->rawir))\n\t\t\tevents = EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn events;\n}\n\nstatic ssize_t lirc_read_mode2(struct file *file, char __user *buffer,\n\t\t\t       size_t length)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *rcdev = fh->rc;\n\tunsigned int copied;\n\tint ret;\n\n\tif (length < sizeof(unsigned int) || length % sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (kfifo_is_empty(&fh->rawir)) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = wait_event_interruptible(fh->wait_poll,\n\t\t\t\t\t!kfifo_is_empty(&fh->rawir) ||\n\t\t\t\t\t!rcdev->registered);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!rcdev->registered)\n\t\t\treturn -ENODEV;\n\n\t\tret = mutex_lock_interruptible(&rcdev->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = kfifo_to_user(&fh->rawir, buffer, length, &copied);\n\t\tmutex_unlock(&rcdev->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (copied == 0);\n\n\treturn copied;\n}\n\nstatic ssize_t lirc_read_scancode(struct file *file, char __user *buffer,\n\t\t\t\t  size_t length)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *rcdev = fh->rc;\n\tunsigned int copied;\n\tint ret;\n\n\tif (length < sizeof(struct lirc_scancode) ||\n\t    length % sizeof(struct lirc_scancode))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (kfifo_is_empty(&fh->scancodes)) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = wait_event_interruptible(fh->wait_poll,\n\t\t\t\t\t!kfifo_is_empty(&fh->scancodes) ||\n\t\t\t\t\t!rcdev->registered);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!rcdev->registered)\n\t\t\treturn -ENODEV;\n\n\t\tret = mutex_lock_interruptible(&rcdev->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = kfifo_to_user(&fh->scancodes, buffer, length, &copied);\n\t\tmutex_unlock(&rcdev->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (copied == 0);\n\n\treturn copied;\n}\n\nstatic ssize_t lirc_read(struct file *file, char __user *buffer, size_t length,\n\t\t\t loff_t *ppos)\n{\n\tstruct lirc_fh *fh = file->private_data;\n\tstruct rc_dev *rcdev = fh->rc;\n\n\tif (rcdev->driver_type == RC_DRIVER_IR_RAW_TX)\n\t\treturn -EINVAL;\n\n\tif (!rcdev->registered)\n\t\treturn -ENODEV;\n\n\tif (fh->rec_mode == LIRC_MODE_MODE2)\n\t\treturn lirc_read_mode2(file, buffer, length);\n\telse  \n\t\treturn lirc_read_scancode(file, buffer, length);\n}\n\nstatic const struct file_operations lirc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= lirc_transmit,\n\t.unlocked_ioctl\t= lirc_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.read\t\t= lirc_read,\n\t.poll\t\t= lirc_poll,\n\t.open\t\t= lirc_open,\n\t.release\t= lirc_close,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic void lirc_release_device(struct device *ld)\n{\n\tstruct rc_dev *rcdev = container_of(ld, struct rc_dev, lirc_dev);\n\n\tput_device(&rcdev->dev);\n}\n\nint lirc_register(struct rc_dev *dev)\n{\n\tconst char *rx_type, *tx_type;\n\tint err, minor;\n\n\tminor = ida_alloc_max(&lirc_ida, RC_DEV_MAX - 1, GFP_KERNEL);\n\tif (minor < 0)\n\t\treturn minor;\n\n\tdevice_initialize(&dev->lirc_dev);\n\tdev->lirc_dev.class = lirc_class;\n\tdev->lirc_dev.parent = &dev->dev;\n\tdev->lirc_dev.release = lirc_release_device;\n\tdev->lirc_dev.devt = MKDEV(MAJOR(lirc_base_dev), minor);\n\tdev_set_name(&dev->lirc_dev, \"lirc%d\", minor);\n\n\tINIT_LIST_HEAD(&dev->lirc_fh);\n\tspin_lock_init(&dev->lirc_fh_lock);\n\n\tcdev_init(&dev->lirc_cdev, &lirc_fops);\n\n\terr = cdev_device_add(&dev->lirc_cdev, &dev->lirc_dev);\n\tif (err)\n\t\tgoto out_ida;\n\n\tget_device(&dev->dev);\n\n\tswitch (dev->driver_type) {\n\tcase RC_DRIVER_SCANCODE:\n\t\trx_type = \"scancode\";\n\t\tbreak;\n\tcase RC_DRIVER_IR_RAW:\n\t\trx_type = \"raw IR\";\n\t\tbreak;\n\tdefault:\n\t\trx_type = \"no\";\n\t\tbreak;\n\t}\n\n\tif (dev->tx_ir)\n\t\ttx_type = \"raw IR\";\n\telse\n\t\ttx_type = \"no\";\n\n\tdev_info(&dev->dev, \"lirc_dev: driver %s registered at minor = %d, %s receiver, %s transmitter\",\n\t\t dev->driver_name, minor, rx_type, tx_type);\n\n\treturn 0;\n\nout_ida:\n\tida_free(&lirc_ida, minor);\n\treturn err;\n}\n\nvoid lirc_unregister(struct rc_dev *dev)\n{\n\tunsigned long flags;\n\tstruct lirc_fh *fh;\n\n\tdev_dbg(&dev->dev, \"lirc_dev: driver %s unregistered from minor = %d\\n\",\n\t\tdev->driver_name, MINOR(dev->lirc_dev.devt));\n\n\tspin_lock_irqsave(&dev->lirc_fh_lock, flags);\n\tlist_for_each_entry(fh, &dev->lirc_fh, list)\n\t\twake_up_poll(&fh->wait_poll, EPOLLHUP | EPOLLERR);\n\tspin_unlock_irqrestore(&dev->lirc_fh_lock, flags);\n\n\tcdev_device_del(&dev->lirc_cdev, &dev->lirc_dev);\n\tida_free(&lirc_ida, MINOR(dev->lirc_dev.devt));\n}\n\nint __init lirc_dev_init(void)\n{\n\tint retval;\n\n\tlirc_class = class_create(\"lirc\");\n\tif (IS_ERR(lirc_class)) {\n\t\tpr_err(\"class_create failed\\n\");\n\t\treturn PTR_ERR(lirc_class);\n\t}\n\n\tretval = alloc_chrdev_region(&lirc_base_dev, 0, RC_DEV_MAX, \"lirc\");\n\tif (retval) {\n\t\tclass_destroy(lirc_class);\n\t\tpr_err(\"alloc_chrdev_region failed\\n\");\n\t\treturn retval;\n\t}\n\n\tpr_debug(\"IR Remote Control driver registered, major %d\\n\",\n\t\t MAJOR(lirc_base_dev));\n\n\treturn 0;\n}\n\nvoid __exit lirc_dev_exit(void)\n{\n\tclass_destroy(lirc_class);\n\tunregister_chrdev_region(lirc_base_dev, RC_DEV_MAX);\n}\n\nstruct rc_dev *rc_dev_get_from_fd(int fd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct lirc_fh *fh;\n\tstruct rc_dev *dev;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &lirc_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfh = f.file->private_data;\n\tdev = fh->rc;\n\n\tget_device(&dev->dev);\n\tfdput(f);\n\n\treturn dev;\n}\n\nMODULE_ALIAS(\"lirc_dev\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}