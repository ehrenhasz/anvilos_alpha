{
  "module_name": "rc-loopback.c",
  "hash_id": "ba69e8bbaf8a08f917cf681aea75ca1f5953fa754868f72b94765ff31235514d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/rc-loopback.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\t\"rc-loopback\"\n#define RXMASK_NARROWBAND\t0x1\n#define RXMASK_WIDEBAND\t\t0x2\n\nstruct loopback_dev {\n\tstruct rc_dev *dev;\n\tu32 txmask;\n\tu32 txcarrier;\n\tu32 txduty;\n\tbool idle;\n\tbool wideband;\n\tbool carrierreport;\n\tu32 rxcarriermin;\n\tu32 rxcarriermax;\n};\n\nstatic struct loopback_dev loopdev;\n\nstatic int loop_set_tx_mask(struct rc_dev *dev, u32 mask)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif ((mask & (RXMASK_NARROWBAND | RXMASK_WIDEBAND)) != mask) {\n\t\tdev_dbg(&dev->dev, \"invalid tx mask: %u\\n\", mask);\n\t\treturn 2;\n\t}\n\n\tdev_dbg(&dev->dev, \"setting tx mask: %u\\n\", mask);\n\tlodev->txmask = mask;\n\treturn 0;\n}\n\nstatic int loop_set_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tdev_dbg(&dev->dev, \"setting tx carrier: %u\\n\", carrier);\n\tlodev->txcarrier = carrier;\n\treturn 0;\n}\n\nstatic int loop_set_tx_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif (duty_cycle < 1 || duty_cycle > 99) {\n\t\tdev_dbg(&dev->dev, \"invalid duty cycle: %u\\n\", duty_cycle);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&dev->dev, \"setting duty cycle: %u\\n\", duty_cycle);\n\tlodev->txduty = duty_cycle;\n\treturn 0;\n}\n\nstatic int loop_set_rx_carrier_range(struct rc_dev *dev, u32 min, u32 max)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif (min < 1 || min > max) {\n\t\tdev_dbg(&dev->dev, \"invalid rx carrier range %u to %u\\n\", min, max);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&dev->dev, \"setting rx carrier range %u to %u\\n\", min, max);\n\tlodev->rxcarriermin = min;\n\tlodev->rxcarriermax = max;\n\treturn 0;\n}\n\nstatic int loop_tx_ir(struct rc_dev *dev, unsigned *txbuf, unsigned count)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\tu32 rxmask;\n\tunsigned i;\n\tstruct ir_raw_event rawir = {};\n\n\tif (lodev->txcarrier < lodev->rxcarriermin ||\n\t    lodev->txcarrier > lodev->rxcarriermax) {\n\t\tdev_dbg(&dev->dev, \"ignoring tx, carrier out of range\\n\");\n\t\tgoto out;\n\t}\n\n\tif (lodev->wideband)\n\t\trxmask = RXMASK_WIDEBAND;\n\telse\n\t\trxmask = RXMASK_NARROWBAND;\n\n\tif (!(rxmask & lodev->txmask)) {\n\t\tdev_dbg(&dev->dev, \"ignoring tx, rx mask mismatch\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\trawir.pulse = i % 2 ? false : true;\n\t\trawir.duration = txbuf[i];\n\n\t\t \n\t\tif (rawir.pulse && rawir.duration > MS_TO_US(50))\n\t\t\tir_raw_event_overflow(dev);\n\t\telse\n\t\t\tir_raw_event_store_with_filter(dev, &rawir);\n\t}\n\n\tif (lodev->carrierreport) {\n\t\trawir.pulse = false;\n\t\trawir.carrier_report = true;\n\t\trawir.carrier = lodev->txcarrier;\n\n\t\tir_raw_event_store(dev, &rawir);\n\t}\n\n\t \n\trawir.pulse = false;\n\trawir.duration = dev->timeout;\n\tir_raw_event_store_with_filter(dev, &rawir);\n\n\tir_raw_event_handle(dev);\n\nout:\n\treturn count;\n}\n\nstatic void loop_set_idle(struct rc_dev *dev, bool enable)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif (lodev->idle != enable) {\n\t\tdev_dbg(&dev->dev, \"%sing idle mode\\n\", enable ? \"enter\" : \"exit\");\n\t\tlodev->idle = enable;\n\t}\n}\n\nstatic int loop_set_wideband_receiver(struct rc_dev *dev, int enable)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif (lodev->wideband != enable) {\n\t\tdev_dbg(&dev->dev, \"using %sband receiver\\n\", enable ? \"wide\" : \"narrow\");\n\t\tlodev->wideband = !!enable;\n\t}\n\n\treturn 0;\n}\n\nstatic int loop_set_carrier_report(struct rc_dev *dev, int enable)\n{\n\tstruct loopback_dev *lodev = dev->priv;\n\n\tif (lodev->carrierreport != enable) {\n\t\tdev_dbg(&dev->dev, \"%sabling carrier reports\\n\", enable ? \"en\" : \"dis\");\n\t\tlodev->carrierreport = !!enable;\n\t}\n\n\treturn 0;\n}\n\nstatic int loop_set_wakeup_filter(struct rc_dev *dev,\n\t\t\t\t  struct rc_scancode_filter *sc)\n{\n\tstatic const unsigned int max = 512;\n\tstruct ir_raw_event *raw;\n\tint ret;\n\tint i;\n\n\t \n\tif (!sc->mask)\n\t\treturn 0;\n\n\t \n\traw = kmalloc_array(max, sizeof(*raw), GFP_KERNEL);\n\tif (!raw)\n\t\treturn -ENOMEM;\n\n\tret = ir_raw_encode_scancode(dev->wakeup_protocol, sc->data, raw, max);\n\t \n\tif (ret == -ENOBUFS)\n\t\tret = max;\n\tif (ret >= 0) {\n\t\t \n\t\tfor (i = 0; i < ret; ++i)\n\t\t\tir_raw_event_store(dev, &raw[i]);\n\t\tir_raw_event_handle(dev);\n\n\t\tret = 0;\n\t}\n\n\tkfree(raw);\n\n\treturn ret;\n}\n\nstatic int __init loop_init(void)\n{\n\tstruct rc_dev *rc;\n\tint ret;\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->device_name\t\t= \"rc-core loopback device\";\n\trc->input_phys\t\t= \"rc-core/virtual\";\n\trc->input_id.bustype\t= BUS_VIRTUAL;\n\trc->input_id.version\t= 1;\n\trc->driver_name\t\t= DRIVER_NAME;\n\trc->map_name\t\t= RC_MAP_EMPTY;\n\trc->priv\t\t= &loopdev;\n\trc->allowed_protocols\t= RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->allowed_wakeup_protocols = RC_PROTO_BIT_ALL_IR_ENCODER;\n\trc->encode_wakeup\t= true;\n\trc->timeout\t\t= IR_DEFAULT_TIMEOUT;\n\trc->min_timeout\t\t= 1;\n\trc->max_timeout\t\t= IR_MAX_TIMEOUT;\n\trc->rx_resolution\t= 1;\n\trc->tx_resolution\t= 1;\n\trc->s_tx_mask\t\t= loop_set_tx_mask;\n\trc->s_tx_carrier\t= loop_set_tx_carrier;\n\trc->s_tx_duty_cycle\t= loop_set_tx_duty_cycle;\n\trc->s_rx_carrier_range\t= loop_set_rx_carrier_range;\n\trc->tx_ir\t\t= loop_tx_ir;\n\trc->s_idle\t\t= loop_set_idle;\n\trc->s_wideband_receiver\t= loop_set_wideband_receiver;\n\trc->s_carrier_report\t= loop_set_carrier_report;\n\trc->s_wakeup_filter\t= loop_set_wakeup_filter;\n\n\tloopdev.txmask\t\t= RXMASK_NARROWBAND;\n\tloopdev.txcarrier\t= 36000;\n\tloopdev.txduty\t\t= 50;\n\tloopdev.rxcarriermin\t= 1;\n\tloopdev.rxcarriermax\t= ~0;\n\tloopdev.idle\t\t= true;\n\tloopdev.wideband\t= false;\n\tloopdev.carrierreport\t= false;\n\n\tret = rc_register_device(rc);\n\tif (ret < 0) {\n\t\tdev_err(&rc->dev, \"rc_dev registration failed\\n\");\n\t\trc_free_device(rc);\n\t\treturn ret;\n\t}\n\n\tloopdev.dev = rc;\n\treturn 0;\n}\n\nstatic void __exit loop_exit(void)\n{\n\trc_unregister_device(loopdev.dev);\n}\n\nmodule_init(loop_init);\nmodule_exit(loop_exit);\n\nMODULE_DESCRIPTION(\"Loopback device for rc-core debugging\");\nMODULE_AUTHOR(\"David H\u00e4rdeman <david@hardeman.nu>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}