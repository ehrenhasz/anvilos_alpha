{
  "module_name": "mceusb.c",
  "hash_id": "064c9df302338aefa13487392562e69733bc6db0b2668c00f48b9d0c77d08de9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/mceusb.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/pm_wakeup.h>\n#include <media/rc-core.h>\n\n#define DRIVER_VERSION\t\"1.95\"\n#define DRIVER_AUTHOR\t\"Jarod Wilson <jarod@redhat.com>\"\n#define DRIVER_DESC\t\"Windows Media Center Ed. eHome Infrared Transceiver \" \\\n\t\t\t\"device driver\"\n#define DRIVER_NAME\t\"mceusb\"\n\n#define USB_TX_TIMEOUT\t\t1000  \n#define USB_CTRL_MSG_SZ\t\t2   \n#define MCE_G1_INIT_MSGS\t40  \n\n \n#define MCE_IRBUF_SIZE\t\t128   \n#define MCE_TIME_UNIT\t\t50    \n#define MCE_PACKET_SIZE\t\t31    \n#define MCE_IRDATA_HEADER\t(0x80 + MCE_PACKET_SIZE - 1)\n\t\t\t\t      \n#define MCE_IRDATA_TRAILER\t0x80  \n#define MCE_MAX_CHANNELS\t2     \n#define MCE_DEFAULT_TX_MASK\t0x03  \n#define MCE_PULSE_BIT\t\t0x80  \n#define MCE_PULSE_MASK\t\t0x7f  \n#define MCE_MAX_PULSE_LENGTH\t0x7f  \n\n \n#define MCE_CMD\t\t\t0x1f\n#define MCE_PORT_IR\t\t0x4\t \n#define MCE_PORT_SYS\t\t0x7\t \n#define MCE_PORT_SER\t\t0x6\t \n#define MCE_PORT_MASK\t\t0xe0\t \n\n \n#define MCE_CMD_PORT_IR\t\t0x9f\t \n#define MCE_CMD_PORT_SYS\t0xff\t \n\n \n#define MCE_CMD_RESET\t\t0xfe\t \n#define MCE_CMD_RESUME\t\t0xaa\t \n#define MCE_CMD_SETIRCFS\t0x06\t \n#define MCE_CMD_SETIRTIMEOUT\t0x0c\t \n#define MCE_CMD_SETIRTXPORTS\t0x08\t \n#define MCE_CMD_SETIRRXPORTEN\t0x14\t \n#define MCE_CMD_FLASHLED\t0x23\t \n\n \n#define MCE_CMD_GETIRCFS\t0x07\t \n#define MCE_CMD_GETIRTIMEOUT\t0x0d\t \n#define MCE_CMD_GETIRTXPORTS\t0x13\t \n#define MCE_CMD_GETIRRXPORTEN\t0x15\t \n#define MCE_CMD_GETPORTSTATUS\t0x11\t \n#define MCE_CMD_GETIRNUMPORTS\t0x16\t \n#define MCE_CMD_GETWAKESOURCE\t0x17\t \n#define MCE_CMD_GETEMVER\t0x22\t \n#define MCE_CMD_GETDEVDETAILS\t0x21\t \n#define MCE_CMD_GETWAKESUPPORT\t0x20\t \n#define MCE_CMD_GETWAKEVERSION\t0x18\t \n\n \n#define MCE_CMD_NOP\t\t0xff\t \n\n \n#define MCE_RSP_EQIRCFS\t\t0x06\t \n#define MCE_RSP_EQIRTIMEOUT\t0x0c\t \n#define MCE_RSP_GETWAKESOURCE\t0x17\t \n#define MCE_RSP_EQIRTXPORTS\t0x08\t \n#define MCE_RSP_EQIRRXPORTEN\t0x14\t \n#define MCE_RSP_GETPORTSTATUS\t0x11\t \n#define MCE_RSP_EQIRRXCFCNT\t0x15\t \n#define MCE_RSP_EQIRNUMPORTS\t0x16\t \n#define MCE_RSP_EQWAKESUPPORT\t0x20\t \n#define MCE_RSP_EQWAKEVERSION\t0x18\t \n#define MCE_RSP_EQDEVDETAILS\t0x21\t \n#define MCE_RSP_EQEMVER\t\t0x22\t \n#define MCE_RSP_FLASHLED\t0x23\t \n\n \n#define MCE_RSP_CMD_ILLEGAL\t0xfe\t \n#define MCE_RSP_TX_TIMEOUT\t0x81\t \n\n \n#define MCE_CMD_SIG_END\t\t0x01\t \n#define MCE_CMD_PING\t\t0x03\t \n#define MCE_CMD_UNKNOWN\t\t0x04\t \n#define MCE_CMD_UNKNOWN2\t0x05\t \n#define MCE_CMD_UNKNOWN3\t0x09\t \n#define MCE_CMD_UNKNOWN4\t0x0a\t \n#define MCE_CMD_G_REVISION\t0x0b\t \n#define MCE_CMD_UNKNOWN5\t0x0e\t \n#define MCE_CMD_UNKNOWN6\t0x0f\t \n#define MCE_CMD_UNKNOWN8\t0x19\t \n#define MCE_CMD_UNKNOWN9\t0x1b\t \n#define MCE_CMD_NULL\t\t0x00\t \n\n \n#define MCE_COMMAND_IRDATA\t0x80\n#define MCE_PACKET_LENGTH_MASK\t0x1f  \n\n#define VENDOR_PHILIPS\t\t0x0471\n#define VENDOR_SMK\t\t0x0609\n#define VENDOR_TATUNG\t\t0x1460\n#define VENDOR_GATEWAY\t\t0x107b\n#define VENDOR_SHUTTLE\t\t0x1308\n#define VENDOR_SHUTTLE2\t\t0x051c\n#define VENDOR_MITSUMI\t\t0x03ee\n#define VENDOR_TOPSEED\t\t0x1784\n#define VENDOR_RICAVISION\t0x179d\n#define VENDOR_ITRON\t\t0x195d\n#define VENDOR_FIC\t\t0x1509\n#define VENDOR_LG\t\t0x043e\n#define VENDOR_MICROSOFT\t0x045e\n#define VENDOR_FORMOSA\t\t0x147a\n#define VENDOR_FINTEK\t\t0x1934\n#define VENDOR_PINNACLE\t\t0x2304\n#define VENDOR_ECS\t\t0x1019\n#define VENDOR_WISTRON\t\t0x0fb8\n#define VENDOR_COMPRO\t\t0x185b\n#define VENDOR_NORTHSTAR\t0x04eb\n#define VENDOR_REALTEK\t\t0x0bda\n#define VENDOR_TIVO\t\t0x105a\n#define VENDOR_CONEXANT\t\t0x0572\n#define VENDOR_TWISTEDMELON\t0x2596\n#define VENDOR_HAUPPAUGE\t0x2040\n#define VENDOR_PCTV\t\t0x2013\n#define VENDOR_ADAPTEC\t\t0x03f3\n\nenum mceusb_model_type {\n\tMCE_GEN2 = 0,\t\t \n\tMCE_GEN1,\n\tMCE_GEN3,\n\tMCE_GEN3_BROKEN_IRTIMEOUT,\n\tMCE_GEN2_TX_INV,\n\tMCE_GEN2_TX_INV_RX_GOOD,\n\tPOLARIS_EVK,\n\tCX_HYBRID_TV,\n\tMULTIFUNCTION,\n\tTIVO_KIT,\n\tMCE_GEN2_NO_TX,\n\tHAUPPAUGE_CX_HYBRID_TV,\n\tEVROMEDIA_FULL_HYBRID_FULLHD,\n\tASTROMETA_T2HYBRID,\n};\n\nstruct mceusb_model {\n\tu32 mce_gen1:1;\n\tu32 mce_gen2:1;\n\tu32 mce_gen3:1;\n\tu32 tx_mask_normal:1;\n\tu32 no_tx:1;\n\tu32 broken_irtimeout:1;\n\t \n\tu32 rx2;\n\n\tint ir_intfnum;\n\n\tconst char *rc_map;\t \n\tconst char *name;\t \n};\n\nstatic const struct mceusb_model mceusb_model[] = {\n\t[MCE_GEN1] = {\n\t\t.mce_gen1 = 1,\n\t\t.tx_mask_normal = 1,\n\t\t.rx2 = 2,\n\t},\n\t[MCE_GEN2] = {\n\t\t.mce_gen2 = 1,\n\t\t.rx2 = 2,\n\t},\n\t[MCE_GEN2_NO_TX] = {\n\t\t.mce_gen2 = 1,\n\t\t.no_tx = 1,\n\t},\n\t[MCE_GEN2_TX_INV] = {\n\t\t.mce_gen2 = 1,\n\t\t.tx_mask_normal = 1,\n\t\t.rx2 = 1,\n\t},\n\t[MCE_GEN2_TX_INV_RX_GOOD] = {\n\t\t.mce_gen2 = 1,\n\t\t.tx_mask_normal = 1,\n\t\t.rx2 = 2,\n\t},\n\t[MCE_GEN3] = {\n\t\t.mce_gen3 = 1,\n\t\t.tx_mask_normal = 1,\n\t\t.rx2 = 2,\n\t},\n\t[MCE_GEN3_BROKEN_IRTIMEOUT] = {\n\t\t.mce_gen3 = 1,\n\t\t.tx_mask_normal = 1,\n\t\t.rx2 = 2,\n\t\t.broken_irtimeout = 1\n\t},\n\t[POLARIS_EVK] = {\n\t\t \n\t\t.name = \"Conexant Hybrid TV (cx231xx) MCE IR\",\n\t\t.rx2 = 2,\n\t},\n\t[CX_HYBRID_TV] = {\n\t\t.no_tx = 1,  \n\t\t.name = \"Conexant Hybrid TV (cx231xx) MCE IR\",\n\t},\n\t[HAUPPAUGE_CX_HYBRID_TV] = {\n\t\t.no_tx = 1,  \n\t\t.name = \"Conexant Hybrid TV (cx231xx) MCE IR no TX\",\n\t},\n\t[MULTIFUNCTION] = {\n\t\t.mce_gen2 = 1,\n\t\t.ir_intfnum = 2,\n\t\t.rx2 = 2,\n\t},\n\t[TIVO_KIT] = {\n\t\t.mce_gen2 = 1,\n\t\t.rc_map = RC_MAP_TIVO,\n\t\t.rx2 = 2,\n\t},\n\t[EVROMEDIA_FULL_HYBRID_FULLHD] = {\n\t\t.name = \"Evromedia USB Full Hybrid Full HD\",\n\t\t.no_tx = 1,\n\t\t.rc_map = RC_MAP_MSI_DIGIVOX_III,\n\t},\n\t[ASTROMETA_T2HYBRID] = {\n\t\t.name = \"Astrometa T2Hybrid\",\n\t\t.no_tx = 1,\n\t\t.rc_map = RC_MAP_ASTROMETA_T2HYBRID,\n\t}\n};\n\nstatic const struct usb_device_id mceusb_dev_table[] = {\n\t \n\t{ USB_DEVICE(VENDOR_MICROSOFT, 0x006d),\n\t  .driver_info = MCE_GEN1 },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x0608) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x060c),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x060d) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x060f) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x0613) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x206c) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x2088) },\n\t \n\t{ USB_DEVICE(VENDOR_PHILIPS, 0x2093),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_REALTEK, 0x0161),\n\t  .driver_info = MULTIFUNCTION },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x031d),\n\t  .driver_info = MCE_GEN2_TX_INV_RX_GOOD },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x0322),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x0334),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x0338) },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x0353),\n\t  .driver_info = MCE_GEN2_NO_TX },\n\t \n\t{ USB_DEVICE(VENDOR_SMK, 0x0357),\n\t  .driver_info = MCE_GEN2_NO_TX },\n\t \n\t{ USB_DEVICE(VENDOR_TATUNG, 0x9150) },\n\t \n\t{ USB_DEVICE(VENDOR_SHUTTLE, 0xc001) },\n\t \n\t{ USB_DEVICE(VENDOR_SHUTTLE2, 0xc001) },\n\t \n\t{ USB_DEVICE(VENDOR_GATEWAY, 0x3009) },\n\t \n\t{ USB_DEVICE(VENDOR_MITSUMI, 0x2501) },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x0001),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x0006),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x0007),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x0008),\n\t  .driver_info = MCE_GEN3 },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x000a),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_TOPSEED, 0x0011),\n\t  .driver_info = MCE_GEN3_BROKEN_IRTIMEOUT },\n\t \n\t{ USB_DEVICE(VENDOR_RICAVISION, 0x0010) },\n\t \n\t{ USB_DEVICE(VENDOR_ITRON, 0x7002) },\n\t \n\t{ USB_DEVICE(VENDOR_FIC, 0x9242) },\n\t \n\t{ USB_DEVICE(VENDOR_LG, 0x9803) },\n\t \n\t{ USB_DEVICE(VENDOR_MICROSOFT, 0x00a0) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe015) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe016) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe017),\n\t  .driver_info = MCE_GEN2_NO_TX },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe018) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe03a) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe03c) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe03e) },\n\t \n\t{ USB_DEVICE(VENDOR_FORMOSA, 0xe042) },\n\t \n\t{ USB_DEVICE(VENDOR_FINTEK, 0x5168),\n\t  .driver_info = MCE_GEN2_TX_INV },\n\t \n\t{ USB_DEVICE(VENDOR_FINTEK, 0x0602) },\n\t \n\t{ USB_DEVICE(VENDOR_FINTEK, 0x0702) },\n\t \n\t{ USB_DEVICE(VENDOR_PINNACLE, 0x0225),\n\t  .driver_info = MCE_GEN3 },\n\t \n\t{ USB_DEVICE(VENDOR_ECS, 0x0f38) },\n\t \n\t{ USB_DEVICE(VENDOR_WISTRON, 0x0002) },\n\t \n\t{ USB_DEVICE(VENDOR_COMPRO, 0x3020) },\n\t \n\t{ USB_DEVICE(VENDOR_COMPRO, 0x3082) },\n\t \n\t{ USB_DEVICE(VENDOR_NORTHSTAR, 0xe004) },\n\t \n\t{ USB_DEVICE(VENDOR_TIVO, 0x2000),\n\t  .driver_info = TIVO_KIT },\n\t \n\t{ USB_DEVICE(VENDOR_CONEXANT, 0x58a1),\n\t  .driver_info = POLARIS_EVK },\n\t \n\t{ USB_DEVICE(VENDOR_CONEXANT, 0x58a5),\n\t  .driver_info = CX_HYBRID_TV },\n\t \n\t{ USB_DEVICE(VENDOR_TWISTEDMELON, 0x8008) },\n\t \n\t{ USB_DEVICE(VENDOR_TWISTEDMELON, 0x8016) },\n\t \n\t{ USB_DEVICE(VENDOR_TWISTEDMELON, 0x8042) },\n\t \n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb130),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb131),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb138),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb139),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t \n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb151),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t \n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb123),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t \n\t{ USB_DEVICE(VENDOR_HAUPPAUGE, 0xb150),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t{ USB_DEVICE(VENDOR_PCTV, 0x0259),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t{ USB_DEVICE(VENDOR_PCTV, 0x025e),\n\t  .driver_info = HAUPPAUGE_CX_HYBRID_TV },\n\t \n\t{ USB_DEVICE(VENDOR_ADAPTEC, 0x0094) },\n\t \n\t{ USB_DEVICE(0x1b80, 0xd3b2),\n\t  .driver_info = EVROMEDIA_FULL_HYBRID_FULLHD },\n\t \n\t{ USB_DEVICE(0x15f4, 0x0135),\n\t  .driver_info = ASTROMETA_T2HYBRID },\n\n\t \n\t{ }\n};\n\n \nstruct mceusb_dev {\n\t \n\tstruct rc_dev *rc;\n\n\t \n\tbool carrier_report_enabled;\n\tbool wideband_rx_enabled;\t \n\n\t \n\tstruct device *dev;\n\n\t \n\tstruct usb_device *usbdev;\n\tstruct usb_interface *usbintf;\n\tstruct urb *urb_in;\n\tunsigned int pipe_in;\n\tstruct usb_endpoint_descriptor *usb_ep_out;\n\tunsigned int pipe_out;\n\n\t \n\tunsigned char *buf_in;\n\tunsigned int len_in;\n\tdma_addr_t dma_in;\n\n\tenum {\n\t\tCMD_HEADER = 0,\n\t\tSUBCMD,\n\t\tCMD_DATA,\n\t\tPARSE_IRDATA,\n\t} parser_state;\n\n\tu8 cmd, rem;\t\t \n\n\tstruct {\n\t\tu32 connected:1;\n\t\tu32 tx_mask_normal:1;\n\t\tu32 microsoft_gen1:1;\n\t\tu32 no_tx:1;\n\t\tu32 rx2;\n\t} flags;\n\n\t \n\tu32 carrier;\n\tunsigned char tx_mask;\n\n\tchar name[128];\n\tchar phys[64];\n\tenum mceusb_model_type model;\n\n\tbool need_reset;\t \n\tu8 emver;\t\t \n\tu8 num_txports;\t\t \n\tu8 num_rxports;\t\t \n\tu8 txports_cabled;\t \n\tu8 rxports_active;\t \n\tbool learning_active;\t \n\n\t \n\tu32 pulse_tunit;\t \n\tu32 pulse_count;\t \n\n\t \n\tstruct work_struct kevent;\n\tunsigned long kevent_flags;\n#\t\tdefine EVENT_TX_HALT\t0\n#\t\tdefine EVENT_RX_HALT\t1\n#\t\tdefine EVENT_RST_PEND\t31\n};\n\n \nstatic char DEVICE_RESUME[]\t= {MCE_CMD_NULL, MCE_CMD_PORT_SYS,\n\t\t\t\t   MCE_CMD_RESUME};\nstatic char GET_REVISION[]\t= {MCE_CMD_PORT_SYS, MCE_CMD_G_REVISION};\nstatic char GET_EMVER[]\t\t= {MCE_CMD_PORT_SYS, MCE_CMD_GETEMVER};\nstatic char GET_WAKEVERSION[]\t= {MCE_CMD_PORT_SYS, MCE_CMD_GETWAKEVERSION};\nstatic char FLASH_LED[]\t\t= {MCE_CMD_PORT_SYS, MCE_CMD_FLASHLED};\nstatic char GET_UNKNOWN2[]\t= {MCE_CMD_PORT_IR, MCE_CMD_UNKNOWN2};\nstatic char GET_CARRIER_FREQ[]\t= {MCE_CMD_PORT_IR, MCE_CMD_GETIRCFS};\nstatic char GET_RX_TIMEOUT[]\t= {MCE_CMD_PORT_IR, MCE_CMD_GETIRTIMEOUT};\nstatic char GET_NUM_PORTS[]\t= {MCE_CMD_PORT_IR, MCE_CMD_GETIRNUMPORTS};\nstatic char GET_TX_BITMASK[]\t= {MCE_CMD_PORT_IR, MCE_CMD_GETIRTXPORTS};\nstatic char GET_RX_SENSOR[]\t= {MCE_CMD_PORT_IR, MCE_CMD_GETIRRXPORTEN};\n \n \n\nstatic int mceusb_cmd_datasize(u8 cmd, u8 subcmd)\n{\n\tint datasize = 0;\n\n\tswitch (cmd) {\n\tcase MCE_CMD_NULL:\n\t\tif (subcmd == MCE_CMD_PORT_SYS)\n\t\t\tdatasize = 1;\n\t\tbreak;\n\tcase MCE_CMD_PORT_SYS:\n\t\tswitch (subcmd) {\n\t\tcase MCE_RSP_GETPORTSTATUS:\n\t\t\tdatasize = 5;\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQWAKEVERSION:\n\t\t\tdatasize = 4;\n\t\t\tbreak;\n\t\tcase MCE_CMD_G_REVISION:\n\t\t\tdatasize = 4;\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQWAKESUPPORT:\n\t\tcase MCE_RSP_GETWAKESOURCE:\n\t\tcase MCE_RSP_EQDEVDETAILS:\n\t\tcase MCE_RSP_EQEMVER:\n\t\t\tdatasize = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MCE_CMD_PORT_IR:\n\t\tswitch (subcmd) {\n\t\tcase MCE_CMD_UNKNOWN:\n\t\tcase MCE_RSP_EQIRCFS:\n\t\tcase MCE_RSP_EQIRTIMEOUT:\n\t\tcase MCE_RSP_EQIRRXCFCNT:\n\t\tcase MCE_RSP_EQIRNUMPORTS:\n\t\t\tdatasize = 2;\n\t\t\tbreak;\n\t\tcase MCE_CMD_SIG_END:\n\t\tcase MCE_RSP_EQIRTXPORTS:\n\t\tcase MCE_RSP_EQIRRXPORTEN:\n\t\t\tdatasize = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn datasize;\n}\n\nstatic void mceusb_dev_printdata(struct mceusb_dev *ir, u8 *buf, int buf_len,\n\t\t\t\t int offset, int len, bool out)\n{\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\n\tchar *inout;\n\tu8 cmd, subcmd, *data;\n\tstruct device *dev = ir->dev;\n\tu32 carrier, period;\n\n\tif (offset < 0 || offset >= buf_len)\n\t\treturn;\n\n\tdev_dbg(dev, \"%cx data[%d]: %*ph (len=%d sz=%d)\",\n\t\t(out ? 't' : 'r'), offset,\n\t\tmin(len, buf_len - offset), buf + offset, len, buf_len);\n\n\tinout = out ? \"Request\" : \"Got\";\n\n\tcmd    = buf[offset];\n\tsubcmd = (offset + 1 < buf_len) ? buf[offset + 1] : 0;\n\tdata   = &buf[offset] + 2;\n\n\t \n\tif (ir->flags.microsoft_gen1 && !out && !offset) {\n\t\tdev_dbg(dev, \"MCE gen 1 header\");\n\t\treturn;\n\t}\n\n\t \n\tif (cmd != MCE_CMD_PORT_IR &&\n\t    (cmd & MCE_PORT_MASK) == MCE_COMMAND_IRDATA) {\n\t\tif (cmd == MCE_IRDATA_TRAILER)\n\t\t\tdev_dbg(dev, \"End of raw IR data\");\n\t\telse\n\t\t\tdev_dbg(dev, \"Raw IR data, %d pulse/space samples\",\n\t\t\t\tcmd & MCE_PACKET_LENGTH_MASK);\n\t\treturn;\n\t}\n\n\t \n\tif (offset + len > buf_len)\n\t\treturn;\n\n\t \n\tswitch (cmd) {\n\tcase MCE_CMD_NULL:\n\t\tif (subcmd == MCE_CMD_NULL)\n\t\t\tbreak;\n\t\tif ((subcmd == MCE_CMD_PORT_SYS) &&\n\t\t    (data[0] == MCE_CMD_RESUME))\n\t\t\tdev_dbg(dev, \"Device resume requested\");\n\t\telse\n\t\t\tdev_dbg(dev, \"Unknown command 0x%02x 0x%02x\",\n\t\t\t\t cmd, subcmd);\n\t\tbreak;\n\tcase MCE_CMD_PORT_SYS:\n\t\tswitch (subcmd) {\n\t\tcase MCE_RSP_EQEMVER:\n\t\t\tif (!out)\n\t\t\t\tdev_dbg(dev, \"Emulator interface version %x\",\n\t\t\t\t\t data[0]);\n\t\t\tbreak;\n\t\tcase MCE_CMD_G_REVISION:\n\t\t\tif (len == 2)\n\t\t\t\tdev_dbg(dev, \"Get hw/sw rev?\");\n\t\t\telse\n\t\t\t\tdev_dbg(dev, \"hw/sw rev %*ph\",\n\t\t\t\t\t4, &buf[offset + 2]);\n\t\t\tbreak;\n\t\tcase MCE_CMD_RESUME:\n\t\t\tdev_dbg(dev, \"Device resume requested\");\n\t\t\tbreak;\n\t\tcase MCE_RSP_CMD_ILLEGAL:\n\t\t\tdev_dbg(dev, \"Illegal PORT_SYS command\");\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQWAKEVERSION:\n\t\t\tif (!out)\n\t\t\t\tdev_dbg(dev, \"Wake version, proto: 0x%02x, payload: 0x%02x, address: 0x%02x, version: 0x%02x\",\n\t\t\t\t\tdata[0], data[1], data[2], data[3]);\n\t\t\tbreak;\n\t\tcase MCE_RSP_GETPORTSTATUS:\n\t\t\tif (!out)\n\t\t\t\t \n\t\t\t\tdev_dbg(dev, \"TX port %d: blaster is%s connected\",\n\t\t\t\t\t data[0] + 1, data[3] ? \" not\" : \"\");\n\t\t\tbreak;\n\t\tcase MCE_CMD_FLASHLED:\n\t\t\tdev_dbg(dev, \"Attempting to flash LED\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"Unknown command 0x%02x 0x%02x\",\n\t\t\t\t cmd, subcmd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MCE_CMD_PORT_IR:\n\t\tswitch (subcmd) {\n\t\tcase MCE_CMD_SIG_END:\n\t\t\tdev_dbg(dev, \"End of signal\");\n\t\t\tbreak;\n\t\tcase MCE_CMD_PING:\n\t\t\tdev_dbg(dev, \"Ping\");\n\t\t\tbreak;\n\t\tcase MCE_CMD_UNKNOWN:\n\t\t\tdev_dbg(dev, \"Resp to 9f 05 of 0x%02x 0x%02x\",\n\t\t\t\tdata[0], data[1]);\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQIRCFS:\n\t\t\tif (!data[0] && !data[1]) {\n\t\t\t\tdev_dbg(dev, \"%s: no carrier\", inout);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (data[0] > 8)\n\t\t\t\tbreak;\n\t\t\tperiod = DIV_ROUND_CLOSEST((1U << data[0] * 2) *\n\t\t\t\t\t\t   (data[1] + 1), 10);\n\t\t\tif (!period)\n\t\t\t\tbreak;\n\t\t\tcarrier = USEC_PER_SEC / period;\n\t\t\tdev_dbg(dev, \"%s carrier of %u Hz (period %uus)\",\n\t\t\t\t inout, carrier, period);\n\t\t\tbreak;\n\t\tcase MCE_CMD_GETIRCFS:\n\t\t\tdev_dbg(dev, \"Get carrier mode and freq\");\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQIRTXPORTS:\n\t\t\tdev_dbg(dev, \"%s transmit blaster mask of 0x%02x\",\n\t\t\t\t inout, data[0]);\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQIRTIMEOUT:\n\t\t\t \n\t\t\tperiod = ((data[0] << 8) | data[1]) *\n\t\t\t\t  MCE_TIME_UNIT / 1000;\n\t\t\tdev_dbg(dev, \"%s receive timeout of %d ms\",\n\t\t\t\t inout, period);\n\t\t\tbreak;\n\t\tcase MCE_CMD_GETIRTIMEOUT:\n\t\t\tdev_dbg(dev, \"Get receive timeout\");\n\t\t\tbreak;\n\t\tcase MCE_CMD_GETIRTXPORTS:\n\t\t\tdev_dbg(dev, \"Get transmit blaster mask\");\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQIRRXPORTEN:\n\t\t\tdev_dbg(dev, \"%s %s-range receive sensor in use\",\n\t\t\t\t inout, data[0] == 0x02 ? \"short\" : \"long\");\n\t\t\tbreak;\n\t\tcase MCE_CMD_GETIRRXPORTEN:\n\t\t \n\t\t\tif (out)\n\t\t\t\tdev_dbg(dev, \"Get receive sensor\");\n\t\t\telse\n\t\t\t\tdev_dbg(dev, \"RX carrier cycle count: %d\",\n\t\t\t\t\t((data[0] << 8) | data[1]));\n\t\t\tbreak;\n\t\tcase MCE_RSP_EQIRNUMPORTS:\n\t\t\tif (out)\n\t\t\t\tbreak;\n\t\t\tdev_dbg(dev, \"Num TX ports: %x, num RX ports: %x\",\n\t\t\t\tdata[0], data[1]);\n\t\t\tbreak;\n\t\tcase MCE_RSP_CMD_ILLEGAL:\n\t\t\tdev_dbg(dev, \"Illegal PORT_IR command\");\n\t\t\tbreak;\n\t\tcase MCE_RSP_TX_TIMEOUT:\n\t\t\tdev_dbg(dev, \"IR TX timeout (TX buffer underrun)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"Unknown command 0x%02x 0x%02x\",\n\t\t\t\t cmd, subcmd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n}\n\n \nstatic void mceusb_defer_kevent(struct mceusb_dev *ir, int kevent)\n{\n\tset_bit(kevent, &ir->kevent_flags);\n\n\tif (test_bit(EVENT_RST_PEND, &ir->kevent_flags)) {\n\t\tdev_dbg(ir->dev, \"kevent %d dropped pending USB Reset Device\",\n\t\t\tkevent);\n\t\treturn;\n\t}\n\n\tif (!schedule_work(&ir->kevent))\n\t\tdev_dbg(ir->dev, \"kevent %d already scheduled\", kevent);\n\telse\n\t\tdev_dbg(ir->dev, \"kevent %d scheduled\", kevent);\n}\n\nstatic void mce_write_callback(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\n\tcomplete(urb->context);\n}\n\n \nstatic int mce_write(struct mceusb_dev *ir, u8 *data, int size)\n{\n\tint ret;\n\tstruct urb *urb;\n\tstruct device *dev = ir->dev;\n\tunsigned char *buf_out;\n\tstruct completion tx_done;\n\tunsigned long expire;\n\tunsigned long ret_wait;\n\n\tmceusb_dev_printdata(ir, data, size, 0, size, true);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (unlikely(!urb)) {\n\t\tdev_err(dev, \"Error: mce write couldn't allocate urb\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf_out = kmalloc(size, GFP_KERNEL);\n\tif (!buf_out) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&tx_done);\n\n\t \n\tif (usb_endpoint_xfer_int(ir->usb_ep_out))\n\t\tusb_fill_int_urb(urb, ir->usbdev, ir->pipe_out,\n\t\t\t\t buf_out, size, mce_write_callback, &tx_done,\n\t\t\t\t ir->usb_ep_out->bInterval);\n\telse\n\t\tusb_fill_bulk_urb(urb, ir->usbdev, ir->pipe_out,\n\t\t\t\t  buf_out, size, mce_write_callback, &tx_done);\n\tmemcpy(buf_out, data, size);\n\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(dev, \"Error: mce write submit urb error = %d\", ret);\n\t\tkfree(buf_out);\n\t\tusb_free_urb(urb);\n\t\treturn ret;\n\t}\n\n\texpire = msecs_to_jiffies(USB_TX_TIMEOUT);\n\tret_wait = wait_for_completion_timeout(&tx_done, expire);\n\tif (!ret_wait) {\n\t\tdev_err(dev, \"Error: mce write timed out (expire = %lu (%dms))\",\n\t\t\texpire, USB_TX_TIMEOUT);\n\t\tusb_kill_urb(urb);\n\t\tret = (urb->status == -ENOENT ? -ETIMEDOUT : urb->status);\n\t} else {\n\t\tret = urb->status;\n\t}\n\tif (ret >= 0)\n\t\tret = urb->actual_length;\t \n\n\tswitch (urb->status) {\n\t \n\tcase 0:\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -EILSEQ:\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\n\tcase -EPIPE:\n\t\tdev_err(ir->dev, \"Error: mce write urb status = %d (TX HALT)\",\n\t\t\turb->status);\n\t\tmceusb_defer_kevent(ir, EVENT_TX_HALT);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(ir->dev, \"Error: mce write urb status = %d\",\n\t\t\turb->status);\n\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"tx done status = %d (wait = %lu, expire = %lu (%dms), urb->actual_length = %d, urb->status = %d)\",\n\t\tret, ret_wait, expire, USB_TX_TIMEOUT,\n\t\turb->actual_length, urb->status);\n\n\tkfree(buf_out);\n\tusb_free_urb(urb);\n\n\treturn ret;\n}\n\nstatic void mce_command_out(struct mceusb_dev *ir, u8 *data, int size)\n{\n\tint rsize = sizeof(DEVICE_RESUME);\n\n\tif (ir->need_reset) {\n\t\tir->need_reset = false;\n\t\tmce_write(ir, DEVICE_RESUME, rsize);\n\t\tmsleep(10);\n\t}\n\n\tmce_write(ir, data, size);\n\tmsleep(10);\n}\n\n \nstatic int mceusb_tx_ir(struct rc_dev *dev, unsigned *txbuf, unsigned count)\n{\n\tstruct mceusb_dev *ir = dev->priv;\n\tu8 cmdbuf[3] = { MCE_CMD_PORT_IR, MCE_CMD_SETIRTXPORTS, 0x00 };\n\tu8 irbuf[MCE_IRBUF_SIZE];\n\tint ircount = 0;\n\tunsigned int irsample;\n\tint i, length, ret;\n\n\t \n\tcmdbuf[2] = ir->tx_mask;\n\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tirsample = txbuf[i] / MCE_TIME_UNIT;\n\n\t\t \n\t\twhile (irsample > 0) {\n\t\t\t \n\t\t\tif (ircount % MCE_PACKET_SIZE == 0) {\n\t\t\t\t \n\t\t\t\tif (ircount >= MCE_IRBUF_SIZE - 1) {\n\t\t\t\t\t \n\t\t\t\t\tret = mce_write(ir, irbuf, ircount);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tircount = 0;\n\t\t\t\t}\n\t\t\t\tirbuf[ircount++] = MCE_IRDATA_HEADER;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (irsample <= MCE_MAX_PULSE_LENGTH) {\n\t\t\t\tirbuf[ircount] = irsample;\n\t\t\t\tirsample = 0;\n\t\t\t} else {\n\t\t\t\tirbuf[ircount] = MCE_MAX_PULSE_LENGTH;\n\t\t\t\tirsample -= MCE_MAX_PULSE_LENGTH;\n\t\t\t}\n\t\t\t \n\t\t\tirbuf[ircount] |= (i & 1 ? 0 : MCE_PULSE_BIT);\n\t\t\tircount++;\n\n\t\t\t \n\t\t\tif (ircount >= MCE_IRBUF_SIZE) {\n\t\t\t\t \n\t\t\t\tlength = ircount % MCE_PACKET_SIZE;\n\t\t\t\tif (length > 0)\n\t\t\t\t\tirbuf[ircount - length] -=\n\t\t\t\t\t\tMCE_PACKET_SIZE - length;\n\t\t\t\t \n\t\t\t\tret = mce_write(ir, irbuf, ircount);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tircount = 0;\n\t\t\t}\n\t\t}\n\t}  \n\n\t \n\tlength = ircount % MCE_PACKET_SIZE;\n\tif (length > 0)\n\t\tirbuf[ircount - length] -= MCE_PACKET_SIZE - length;\n\n\t \n\tirbuf[ircount++] = MCE_IRDATA_TRAILER;\n\n\t \n\tret = mce_write(ir, irbuf, ircount);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic int mceusb_set_tx_mask(struct rc_dev *dev, u32 mask)\n{\n\tstruct mceusb_dev *ir = dev->priv;\n\n\t \n\tint emitters = ir->num_txports ? ir->num_txports : 2;\n\n\tif (mask >= (1 << emitters))\n\t\treturn emitters;\n\n\tif (ir->flags.tx_mask_normal)\n\t\tir->tx_mask = mask;\n\telse\n\t\tir->tx_mask = (mask != MCE_DEFAULT_TX_MASK ?\n\t\t\t\tmask ^ MCE_DEFAULT_TX_MASK : mask) << 1;\n\n\treturn 0;\n}\n\n \nstatic int mceusb_set_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct mceusb_dev *ir = dev->priv;\n\tint clk = 10000000;\n\tint prescaler = 0, divisor = 0;\n\tunsigned char cmdbuf[4] = { MCE_CMD_PORT_IR,\n\t\t\t\t    MCE_CMD_SETIRCFS, 0x00, 0x00 };\n\n\t \n\tif (ir->carrier != carrier) {\n\n\t\tif (carrier == 0) {\n\t\t\tir->carrier = carrier;\n\t\t\tcmdbuf[2] = MCE_CMD_SIG_END;\n\t\t\tcmdbuf[3] = MCE_IRDATA_TRAILER;\n\t\t\tdev_dbg(ir->dev, \"disabling carrier modulation\");\n\t\t\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (prescaler = 0; prescaler < 4; ++prescaler) {\n\t\t\tdivisor = (clk >> (2 * prescaler)) / carrier;\n\t\t\tif (divisor <= 0xff) {\n\t\t\t\tir->carrier = carrier;\n\t\t\t\tcmdbuf[2] = prescaler;\n\t\t\t\tcmdbuf[3] = divisor;\n\t\t\t\tdev_dbg(ir->dev, \"requesting %u HZ carrier\",\n\t\t\t\t\t\t\t\tcarrier);\n\n\t\t\t\t \n\t\t\t\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int mceusb_set_timeout(struct rc_dev *dev, unsigned int timeout)\n{\n\tu8 cmdbuf[4] = { MCE_CMD_PORT_IR, MCE_CMD_SETIRTIMEOUT, 0, 0 };\n\tstruct mceusb_dev *ir = dev->priv;\n\tunsigned int units;\n\n\tunits = DIV_ROUND_UP(timeout, MCE_TIME_UNIT);\n\n\tcmdbuf[2] = units >> 8;\n\tcmdbuf[3] = units;\n\n\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\n\t \n\tmce_command_out(ir, GET_RX_TIMEOUT, sizeof(GET_RX_TIMEOUT));\n\n\treturn 0;\n}\n\n \nstatic int mceusb_set_rx_wideband(struct rc_dev *dev, int enable)\n{\n\tstruct mceusb_dev *ir = dev->priv;\n\tunsigned char cmdbuf[3] = { MCE_CMD_PORT_IR,\n\t\t\t\t    MCE_CMD_SETIRRXPORTEN, 0x00 };\n\n\tdev_dbg(ir->dev, \"select %s-range receive sensor\",\n\t\tenable ? \"short\" : \"long\");\n\tif (enable) {\n\t\tir->wideband_rx_enabled = true;\n\t\tcmdbuf[2] = 2;\t \n\t} else {\n\t\tir->wideband_rx_enabled = false;\n\t\tcmdbuf[2] = 1;\t \n\t}\n\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t \n\n\treturn 0;\n}\n\n \nstatic int mceusb_set_rx_carrier_report(struct rc_dev *dev, int enable)\n{\n\tstruct mceusb_dev *ir = dev->priv;\n\tunsigned char cmdbuf[3] = { MCE_CMD_PORT_IR,\n\t\t\t\t    MCE_CMD_SETIRRXPORTEN, 0x00 };\n\n\tdev_dbg(ir->dev, \"%s short-range receiver carrier reporting\",\n\t\tenable ? \"enable\" : \"disable\");\n\tif (enable) {\n\t\tir->carrier_report_enabled = true;\n\t\tif (!ir->learning_active) {\n\t\t\tcmdbuf[2] = 2;\t \n\t\t\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t\t}\n\t} else {\n\t\tir->carrier_report_enabled = false;\n\t\t \n\t\tif (ir->learning_active && !ir->wideband_rx_enabled) {\n\t\t\tcmdbuf[2] = 1;\t \n\t\t\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mceusb_handle_command(struct mceusb_dev *ir, u8 *buf_in)\n{\n\tu8 cmd = buf_in[0];\n\tu8 subcmd = buf_in[1];\n\tu8 *hi = &buf_in[2];\t\t \n\tu8 *lo = &buf_in[3];\t\t \n\tstruct ir_raw_event rawir = {};\n\tu32 carrier_cycles;\n\tu32 cycles_fix;\n\n\tif (cmd == MCE_CMD_PORT_SYS) {\n\t\tswitch (subcmd) {\n\t\t \n\t\tcase MCE_RSP_GETPORTSTATUS:\n\t\t\tif (buf_in[5] == 0 && *hi < 8)\n\t\t\t\tir->txports_cabled |= 1 << *hi;\n\t\t\tbreak;\n\n\t\t \n\t\tcase MCE_RSP_EQEMVER:\n\t\t\tir->emver = *hi;\n\t\t\tbreak;\n\n\t\t \n\t\tcase MCE_RSP_CMD_ILLEGAL:\n\t\t\tir->need_reset = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (cmd != MCE_CMD_PORT_IR)\n\t\treturn;\n\n\tswitch (subcmd) {\n\t \n\tcase MCE_RSP_EQIRTIMEOUT:\n\t\tir->rc->timeout = (*hi << 8 | *lo) * MCE_TIME_UNIT;\n\t\tbreak;\n\tcase MCE_RSP_EQIRNUMPORTS:\n\t\tir->num_txports = *hi;\n\t\tir->num_rxports = *lo;\n\t\tbreak;\n\tcase MCE_RSP_EQIRRXCFCNT:\n\t\t \n\t\tif (ir->carrier_report_enabled && ir->learning_active &&\n\t\t    ir->pulse_tunit > 0) {\n\t\t\tcarrier_cycles = (*hi << 8 | *lo);\n\t\t\t \n\t\t\tcycles_fix = ir->flags.rx2 == 2 ? ir->pulse_count : 0;\n\t\t\trawir.carrier_report = 1;\n\t\t\trawir.carrier = (1000000u / MCE_TIME_UNIT) *\n\t\t\t\t\t(carrier_cycles + cycles_fix) /\n\t\t\t\t\tir->pulse_tunit;\n\t\t\tdev_dbg(ir->dev, \"RX carrier frequency %u Hz (pulse count = %u, cycles = %u, duration = %u, rx2 = %u)\",\n\t\t\t\trawir.carrier, ir->pulse_count, carrier_cycles,\n\t\t\t\tir->pulse_tunit, ir->flags.rx2);\n\t\t\tir_raw_event_store(ir->rc, &rawir);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MCE_RSP_EQIRTXPORTS:\n\t\tir->tx_mask = *hi;\n\t\tbreak;\n\tcase MCE_RSP_EQIRRXPORTEN:\n\t\tir->learning_active = ((*hi & 0x02) == 0x02);\n\t\tif (ir->rxports_active != *hi) {\n\t\t\tdev_info(ir->dev, \"%s-range (0x%x) receiver active\",\n\t\t\t\t ir->learning_active ? \"short\" : \"long\", *hi);\n\t\t\tir->rxports_active = *hi;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MCE_RSP_CMD_ILLEGAL:\n\tcase MCE_RSP_TX_TIMEOUT:\n\t\tir->need_reset = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mceusb_process_ir_data(struct mceusb_dev *ir, int buf_len)\n{\n\tstruct ir_raw_event rawir = {};\n\tbool event = false;\n\tint i = 0;\n\n\t \n\tif (ir->flags.microsoft_gen1)\n\t\ti = 2;\n\n\t \n\tif (buf_len <= i)\n\t\treturn;\n\n\tfor (; i < buf_len; i++) {\n\t\tswitch (ir->parser_state) {\n\t\tcase SUBCMD:\n\t\t\tir->rem = mceusb_cmd_datasize(ir->cmd, ir->buf_in[i]);\n\t\t\tmceusb_dev_printdata(ir, ir->buf_in, buf_len, i - 1,\n\t\t\t\t\t     ir->rem + 2, false);\n\t\t\tif (i + ir->rem < buf_len)\n\t\t\t\tmceusb_handle_command(ir, &ir->buf_in[i - 1]);\n\t\t\tir->parser_state = CMD_DATA;\n\t\t\tbreak;\n\t\tcase PARSE_IRDATA:\n\t\t\tir->rem--;\n\t\t\trawir.pulse = ((ir->buf_in[i] & MCE_PULSE_BIT) != 0);\n\t\t\trawir.duration = (ir->buf_in[i] & MCE_PULSE_MASK);\n\t\t\tif (unlikely(!rawir.duration)) {\n\t\t\t\tdev_dbg(ir->dev, \"nonsensical irdata %02x with duration 0\",\n\t\t\t\t\tir->buf_in[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rawir.pulse) {\n\t\t\t\tir->pulse_tunit += rawir.duration;\n\t\t\t\tir->pulse_count++;\n\t\t\t}\n\t\t\trawir.duration *= MCE_TIME_UNIT;\n\n\t\t\tdev_dbg(ir->dev, \"Storing %s %u us (%02x)\",\n\t\t\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\t\t\trawir.duration,\tir->buf_in[i]);\n\n\t\t\tif (ir_raw_event_store_with_filter(ir->rc, &rawir))\n\t\t\t\tevent = true;\n\t\t\tbreak;\n\t\tcase CMD_DATA:\n\t\t\tir->rem--;\n\t\t\tbreak;\n\t\tcase CMD_HEADER:\n\t\t\tir->cmd = ir->buf_in[i];\n\t\t\tif ((ir->cmd == MCE_CMD_PORT_IR) ||\n\t\t\t    ((ir->cmd & MCE_PORT_MASK) !=\n\t\t\t     MCE_COMMAND_IRDATA)) {\n\t\t\t\t \n\t\t\t\tir->parser_state = SUBCMD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tir->rem = (ir->cmd & MCE_PACKET_LENGTH_MASK);\n\t\t\tmceusb_dev_printdata(ir, ir->buf_in, buf_len,\n\t\t\t\t\t     i, ir->rem + 1, false);\n\t\t\tif (ir->rem) {\n\t\t\t\tir->parser_state = PARSE_IRDATA;\n\t\t\t} else {\n\t\t\t\tstruct ir_raw_event ev = {\n\t\t\t\t\t.timeout = 1,\n\t\t\t\t\t.duration = ir->rc->timeout\n\t\t\t\t};\n\n\t\t\t\tif (ir_raw_event_store_with_filter(ir->rc,\n\t\t\t\t\t\t\t\t   &ev))\n\t\t\t\t\tevent = true;\n\t\t\t\tir->pulse_tunit = 0;\n\t\t\t\tir->pulse_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ir->parser_state != CMD_HEADER && !ir->rem)\n\t\t\tir->parser_state = CMD_HEADER;\n\t}\n\n\t \n\tif (ir->parser_state != PARSE_IRDATA || !ir->rem)\n\t\tir->parser_state = CMD_HEADER;\n\n\tif (event) {\n\t\tdev_dbg(ir->dev, \"processed IR data\");\n\t\tir_raw_event_handle(ir->rc);\n\t}\n}\n\nstatic void mceusb_dev_recv(struct urb *urb)\n{\n\tstruct mceusb_dev *ir;\n\n\tif (!urb)\n\t\treturn;\n\n\tir = urb->context;\n\tif (!ir) {\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\t}\n\n\tswitch (urb->status) {\n\t \n\tcase 0:\n\t\tmceusb_process_ir_data(ir, urb->actual_length);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -EILSEQ:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\n\tcase -EPIPE:\n\t\tdev_err(ir->dev, \"Error: urb status = %d (RX HALT)\",\n\t\t\turb->status);\n\t\tmceusb_defer_kevent(ir, EVENT_RX_HALT);\n\t\treturn;\n\n\tdefault:\n\t\tdev_err(ir->dev, \"Error: urb status = %d\", urb->status);\n\t\tbreak;\n\t}\n\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void mceusb_get_emulator_version(struct mceusb_dev *ir)\n{\n\t \n\tir->emver = 1;\n\tmce_command_out(ir, GET_EMVER, sizeof(GET_EMVER));\n}\n\nstatic void mceusb_gen1_init(struct mceusb_dev *ir)\n{\n\tint ret;\n\tstruct device *dev = ir->dev;\n\tchar data[USB_CTRL_MSG_SZ];\n\n\t \n\tret = usb_control_msg_recv(ir->usbdev, 0, USB_REQ_SET_ADDRESS,\n\t\t\t\t   USB_DIR_IN | USB_TYPE_VENDOR,\n\t\t\t\t   0, 0, data, USB_CTRL_MSG_SZ, 3000,\n\t\t\t\t   GFP_KERNEL);\n\tdev_dbg(dev, \"set address - ret = %d\", ret);\n\tdev_dbg(dev, \"set address - data[0] = %d, data[1] = %d\",\n\t\t\t\t\t\tdata[0], data[1]);\n\n\t \n\tret = usb_control_msg_send(ir->usbdev, 0,\n\t\t\t\t   USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,\n\t\t\t\t   0xc04e, 0x0000, NULL, 0, 3000, GFP_KERNEL);\n\n\tdev_dbg(dev, \"set feature - ret = %d\", ret);\n\n\t \n\tret = usb_control_msg_send(ir->usbdev, 0,\n\t\t\t\t   4, USB_TYPE_VENDOR,\n\t\t\t\t   0x0808, 0x0000, NULL, 0, 3000, GFP_KERNEL);\n\tdev_dbg(dev, \"set char length - retB = %d\", ret);\n\n\t \n\tret = usb_control_msg_send(ir->usbdev, 0,\n\t\t\t\t   2, USB_TYPE_VENDOR,\n\t\t\t\t   0x0000, 0x0100, NULL, 0, 3000, GFP_KERNEL);\n\tdev_dbg(dev, \"set handshake  - retC = %d\", ret);\n\n\t \n\tmce_command_out(ir, DEVICE_RESUME, sizeof(DEVICE_RESUME));\n\n\t \n\tmce_command_out(ir, GET_REVISION, sizeof(GET_REVISION));\n}\n\nstatic void mceusb_gen2_init(struct mceusb_dev *ir)\n{\n\t \n\tmce_command_out(ir, DEVICE_RESUME, sizeof(DEVICE_RESUME));\n\n\t \n\tmce_command_out(ir, GET_WAKEVERSION, sizeof(GET_WAKEVERSION));\n\n\t \n\tmce_command_out(ir, GET_UNKNOWN2, sizeof(GET_UNKNOWN2));\n}\n\nstatic void mceusb_get_parameters(struct mceusb_dev *ir)\n{\n\tint i;\n\tunsigned char cmdbuf[3] = { MCE_CMD_PORT_SYS,\n\t\t\t\t    MCE_CMD_GETPORTSTATUS, 0x00 };\n\n\t \n\tir->num_txports = 2;\n\tir->num_rxports = 2;\n\n\t \n\tmce_command_out(ir, GET_NUM_PORTS, sizeof(GET_NUM_PORTS));\n\n\t \n\tmce_command_out(ir, GET_CARRIER_FREQ, sizeof(GET_CARRIER_FREQ));\n\n\tif (ir->num_txports && !ir->flags.no_tx)\n\t\t \n\t\tmce_command_out(ir, GET_TX_BITMASK, sizeof(GET_TX_BITMASK));\n\n\t \n\tmce_command_out(ir, GET_RX_TIMEOUT, sizeof(GET_RX_TIMEOUT));\n\n\t \n\tmce_command_out(ir, GET_RX_SENSOR, sizeof(GET_RX_SENSOR));\n\n\tfor (i = 0; i < ir->num_txports; i++) {\n\t\tcmdbuf[2] = i;\n\t\tmce_command_out(ir, cmdbuf, sizeof(cmdbuf));\n\t}\n}\n\nstatic void mceusb_flash_led(struct mceusb_dev *ir)\n{\n\tif (ir->emver < 2)\n\t\treturn;\n\n\tmce_command_out(ir, FLASH_LED, sizeof(FLASH_LED));\n}\n\n \nstatic void mceusb_deferred_kevent(struct work_struct *work)\n{\n\tstruct mceusb_dev *ir =\n\t\tcontainer_of(work, struct mceusb_dev, kevent);\n\tint status;\n\n\tdev_err(ir->dev, \"kevent handler called (flags 0x%lx)\",\n\t\tir->kevent_flags);\n\n\tif (test_bit(EVENT_RST_PEND, &ir->kevent_flags)) {\n\t\tdev_err(ir->dev, \"kevent handler canceled pending USB Reset Device\");\n\t\treturn;\n\t}\n\n\tif (test_bit(EVENT_RX_HALT, &ir->kevent_flags)) {\n\t\tusb_unlink_urb(ir->urb_in);\n\t\tstatus = usb_clear_halt(ir->usbdev, ir->pipe_in);\n\t\tdev_err(ir->dev, \"rx clear halt status = %d\", status);\n\t\tif (status < 0) {\n\t\t\t \n\t\t\tdev_err(ir->dev,\n\t\t\t\t\"stuck RX HALT state requires USB Reset Device to clear\");\n\t\t\tusb_queue_reset_device(ir->usbintf);\n\t\t\tset_bit(EVENT_RST_PEND, &ir->kevent_flags);\n\t\t\tclear_bit(EVENT_RX_HALT, &ir->kevent_flags);\n\n\t\t\t \n\t\t\tclear_bit(EVENT_TX_HALT, &ir->kevent_flags);\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(EVENT_RX_HALT, &ir->kevent_flags);\n\t\tstatus = usb_submit_urb(ir->urb_in, GFP_KERNEL);\n\t\tif (status < 0) {\n\t\t\tdev_err(ir->dev, \"rx unhalt submit urb error = %d\",\n\t\t\t\tstatus);\n\t\t}\n\t}\n\n\tif (test_bit(EVENT_TX_HALT, &ir->kevent_flags)) {\n\t\tstatus = usb_clear_halt(ir->usbdev, ir->pipe_out);\n\t\tdev_err(ir->dev, \"tx clear halt status = %d\", status);\n\t\tif (status < 0) {\n\t\t\t \n\t\t\tdev_err(ir->dev,\n\t\t\t\t\"stuck TX HALT state requires USB Reset Device to clear\");\n\t\t\tusb_queue_reset_device(ir->usbintf);\n\t\t\tset_bit(EVENT_RST_PEND, &ir->kevent_flags);\n\t\t\tclear_bit(EVENT_TX_HALT, &ir->kevent_flags);\n\n\t\t\t \n\t\t\tclear_bit(EVENT_RX_HALT, &ir->kevent_flags);\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(EVENT_TX_HALT, &ir->kevent_flags);\n\t}\n}\n\nstatic struct rc_dev *mceusb_init_rc_dev(struct mceusb_dev *ir)\n{\n\tstruct usb_device *udev = ir->usbdev;\n\tstruct device *dev = ir->dev;\n\tstruct rc_dev *rc;\n\tint ret;\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc) {\n\t\tdev_err(dev, \"remote dev allocation failed\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(ir->name, sizeof(ir->name), \"%s (%04x:%04x)\",\n\t\t mceusb_model[ir->model].name ?\n\t\t\tmceusb_model[ir->model].name :\n\t\t\t\"Media Center Ed. eHome Infrared Remote Transceiver\",\n\t\t le16_to_cpu(ir->usbdev->descriptor.idVendor),\n\t\t le16_to_cpu(ir->usbdev->descriptor.idProduct));\n\n\tusb_make_path(ir->usbdev, ir->phys, sizeof(ir->phys));\n\n\trc->device_name = ir->name;\n\trc->input_phys = ir->phys;\n\tusb_to_input_id(ir->usbdev, &rc->input_id);\n\trc->dev.parent = dev;\n\trc->priv = ir;\n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->rx_resolution = MCE_TIME_UNIT;\n\trc->min_timeout = MCE_TIME_UNIT;\n\trc->timeout = MS_TO_US(100);\n\tif (!mceusb_model[ir->model].broken_irtimeout) {\n\t\trc->s_timeout = mceusb_set_timeout;\n\t\trc->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\t} else {\n\t\t \n\t\trc->max_timeout = rc->timeout;\n\t}\n\tif (!ir->flags.no_tx) {\n\t\trc->s_tx_mask = mceusb_set_tx_mask;\n\t\trc->s_tx_carrier = mceusb_set_tx_carrier;\n\t\trc->tx_ir = mceusb_tx_ir;\n\t}\n\tif (ir->flags.rx2 > 0) {\n\t\trc->s_wideband_receiver = mceusb_set_rx_wideband;\n\t\trc->s_carrier_report = mceusb_set_rx_carrier_report;\n\t}\n\trc->driver_name = DRIVER_NAME;\n\n\tswitch (le16_to_cpu(udev->descriptor.idVendor)) {\n\tcase VENDOR_HAUPPAUGE:\n\t\trc->map_name = RC_MAP_HAUPPAUGE;\n\t\tbreak;\n\tcase VENDOR_PCTV:\n\t\trc->map_name = RC_MAP_PINNACLE_PCTV_HD;\n\t\tbreak;\n\tdefault:\n\t\trc->map_name = RC_MAP_RC6_MCE;\n\t}\n\tif (mceusb_model[ir->model].rc_map)\n\t\trc->map_name = mceusb_model[ir->model].rc_map;\n\n\tret = rc_register_device(rc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"remote dev registration failed\");\n\t\tgoto out;\n\t}\n\n\treturn rc;\n\nout:\n\trc_free_device(rc);\n\treturn NULL;\n}\n\nstatic int mceusb_dev_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *idesc;\n\tstruct usb_endpoint_descriptor *ep = NULL;\n\tstruct usb_endpoint_descriptor *ep_in = NULL;\n\tstruct usb_endpoint_descriptor *ep_out = NULL;\n\tstruct mceusb_dev *ir = NULL;\n\tint pipe, maxp, i, res;\n\tchar buf[63], name[128] = \"\";\n\tenum mceusb_model_type model = id->driver_info;\n\tbool is_gen3;\n\tbool is_microsoft_gen1;\n\tbool tx_mask_normal;\n\tint ir_intfnum;\n\n\tdev_dbg(&intf->dev, \"%s called\", __func__);\n\n\tidesc  = intf->cur_altsetting;\n\n\tis_gen3 = mceusb_model[model].mce_gen3;\n\tis_microsoft_gen1 = mceusb_model[model].mce_gen1;\n\ttx_mask_normal = mceusb_model[model].tx_mask_normal;\n\tir_intfnum = mceusb_model[model].ir_intfnum;\n\n\t \n\tif (idesc->desc.bInterfaceNumber != ir_intfnum)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < idesc->desc.bNumEndpoints; ++i) {\n\t\tep = &idesc->endpoint[i].desc;\n\n\t\tif (ep_in == NULL) {\n\t\t\tif (usb_endpoint_is_bulk_in(ep)) {\n\t\t\t\tep_in = ep;\n\t\t\t\tdev_dbg(&intf->dev, \"acceptable bulk inbound endpoint found\\n\");\n\t\t\t} else if (usb_endpoint_is_int_in(ep)) {\n\t\t\t\tep_in = ep;\n\t\t\t\tep_in->bInterval = 1;\n\t\t\t\tdev_dbg(&intf->dev, \"acceptable interrupt inbound endpoint found\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (ep_out == NULL) {\n\t\t\tif (usb_endpoint_is_bulk_out(ep)) {\n\t\t\t\tep_out = ep;\n\t\t\t\tdev_dbg(&intf->dev, \"acceptable bulk outbound endpoint found\\n\");\n\t\t\t} else if (usb_endpoint_is_int_out(ep)) {\n\t\t\t\tep_out = ep;\n\t\t\t\tep_out->bInterval = 1;\n\t\t\t\tdev_dbg(&intf->dev, \"acceptable interrupt outbound endpoint found\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif (!ep_in || !ep_out) {\n\t\tdev_dbg(&intf->dev, \"required endpoints not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (usb_endpoint_xfer_int(ep_in))\n\t\tpipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);\n\telse\n\t\tpipe = usb_rcvbulkpipe(dev, ep_in->bEndpointAddress);\n\tmaxp = usb_maxpacket(dev, pipe);\n\n\tir = kzalloc(sizeof(struct mceusb_dev), GFP_KERNEL);\n\tif (!ir)\n\t\tgoto mem_alloc_fail;\n\n\tir->pipe_in = pipe;\n\tir->buf_in = usb_alloc_coherent(dev, maxp, GFP_KERNEL, &ir->dma_in);\n\tif (!ir->buf_in)\n\t\tgoto buf_in_alloc_fail;\n\n\tir->urb_in = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!ir->urb_in)\n\t\tgoto urb_in_alloc_fail;\n\n\tir->usbintf = intf;\n\tir->usbdev = usb_get_dev(dev);\n\tir->dev = &intf->dev;\n\tir->len_in = maxp;\n\tir->flags.microsoft_gen1 = is_microsoft_gen1;\n\tir->flags.tx_mask_normal = tx_mask_normal;\n\tir->flags.no_tx = mceusb_model[model].no_tx;\n\tir->flags.rx2 = mceusb_model[model].rx2;\n\tir->model = model;\n\n\t \n\tir->usb_ep_out = ep_out;\n\tif (usb_endpoint_xfer_int(ep_out))\n\t\tir->pipe_out = usb_sndintpipe(ir->usbdev,\n\t\t\t\t\t      ep_out->bEndpointAddress);\n\telse\n\t\tir->pipe_out = usb_sndbulkpipe(ir->usbdev,\n\t\t\t\t\t       ep_out->bEndpointAddress);\n\n\tif (dev->descriptor.iManufacturer\n\t    && usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t  buf, sizeof(buf)) > 0)\n\t\tstrscpy(name, buf, sizeof(name));\n\tif (dev->descriptor.iProduct\n\t    && usb_string(dev, dev->descriptor.iProduct,\n\t\t\t  buf, sizeof(buf)) > 0)\n\t\tsnprintf(name + strlen(name), sizeof(name) - strlen(name),\n\t\t\t \" %s\", buf);\n\n\t \n\tINIT_WORK(&ir->kevent, mceusb_deferred_kevent);\n\n\tir->rc = mceusb_init_rc_dev(ir);\n\tif (!ir->rc)\n\t\tgoto rc_dev_fail;\n\n\t \n\tif (usb_endpoint_xfer_int(ep_in))\n\t\tusb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in, maxp,\n\t\t\t\t mceusb_dev_recv, ir, ep_in->bInterval);\n\telse\n\t\tusb_fill_bulk_urb(ir->urb_in, dev, pipe, ir->buf_in, maxp,\n\t\t\t\t  mceusb_dev_recv, ir);\n\n\tir->urb_in->transfer_dma = ir->dma_in;\n\tir->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tdev_dbg(&intf->dev, \"Flushing receive buffers\");\n\tres = usb_submit_urb(ir->urb_in, GFP_KERNEL);\n\tif (res)\n\t\tdev_err(&intf->dev, \"failed to flush buffers: %d\", res);\n\n\t \n\tmceusb_get_emulator_version(ir);\n\n\t \n\tif (ir->flags.microsoft_gen1)\n\t\tmceusb_gen1_init(ir);\n\telse if (!is_gen3)\n\t\tmceusb_gen2_init(ir);\n\n\tmceusb_get_parameters(ir);\n\n\tmceusb_flash_led(ir);\n\n\tif (!ir->flags.no_tx)\n\t\tmceusb_set_tx_mask(ir->rc, MCE_DEFAULT_TX_MASK);\n\n\tusb_set_intfdata(intf, ir);\n\n\t \n\tdevice_set_wakeup_capable(ir->dev, true);\n\tdevice_set_wakeup_enable(ir->dev, true);\n\n\tdev_info(&intf->dev, \"Registered %s with mce emulator interface version %x\",\n\t\tname, ir->emver);\n\tdev_info(&intf->dev, \"%x tx ports (0x%x cabled) and %x rx sensors (0x%x active)\",\n\t\t ir->num_txports, ir->txports_cabled,\n\t\t ir->num_rxports, ir->rxports_active);\n\n\treturn 0;\n\n\t \nrc_dev_fail:\n\tcancel_work_sync(&ir->kevent);\n\tusb_put_dev(ir->usbdev);\n\tusb_kill_urb(ir->urb_in);\n\tusb_free_urb(ir->urb_in);\nurb_in_alloc_fail:\n\tusb_free_coherent(dev, maxp, ir->buf_in, ir->dma_in);\nbuf_in_alloc_fail:\n\tkfree(ir);\nmem_alloc_fail:\n\tdev_err(&intf->dev, \"%s: device setup failed!\", __func__);\n\n\treturn -ENOMEM;\n}\n\n\nstatic void mceusb_dev_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct mceusb_dev *ir = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s called\", __func__);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!ir)\n\t\treturn;\n\n\tir->usbdev = NULL;\n\tcancel_work_sync(&ir->kevent);\n\trc_unregister_device(ir->rc);\n\tusb_kill_urb(ir->urb_in);\n\tusb_free_urb(ir->urb_in);\n\tusb_free_coherent(dev, ir->len_in, ir->buf_in, ir->dma_in);\n\tusb_put_dev(dev);\n\n\tkfree(ir);\n}\n\nstatic int mceusb_dev_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct mceusb_dev *ir = usb_get_intfdata(intf);\n\tdev_info(ir->dev, \"suspend\");\n\tusb_kill_urb(ir->urb_in);\n\treturn 0;\n}\n\nstatic int mceusb_dev_resume(struct usb_interface *intf)\n{\n\tstruct mceusb_dev *ir = usb_get_intfdata(intf);\n\tdev_info(ir->dev, \"resume\");\n\tif (usb_submit_urb(ir->urb_in, GFP_ATOMIC))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct usb_driver mceusb_dev_driver = {\n\t.name =\t\tDRIVER_NAME,\n\t.probe =\tmceusb_dev_probe,\n\t.disconnect =\tmceusb_dev_disconnect,\n\t.suspend =\tmceusb_dev_suspend,\n\t.resume =\tmceusb_dev_resume,\n\t.reset_resume =\tmceusb_dev_resume,\n\t.id_table =\tmceusb_dev_table\n};\n\nmodule_usb_driver(mceusb_dev_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, mceusb_dev_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}