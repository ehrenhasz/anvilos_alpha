{
  "module_name": "igorplugusb.c",
  "hash_id": "b4b597cdd106caa4bf8f550c8a3fd654b6c628b58efe8b384d2a1391d7be9a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/igorplugusb.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n#define DRIVER_DESC\t\t\"IgorPlug-USB IR Receiver\"\n#define DRIVER_NAME\t\t\"igorplugusb\"\n\n#define HEADERLEN\t\t3\n#define BUFLEN\t\t\t36\n#define MAX_PACKET\t\t(HEADERLEN + BUFLEN)\n\n#define SET_INFRABUFFER_EMPTY\t1\n#define GET_INFRACODE\t\t2\n\n\nstruct igorplugusb {\n\tstruct rc_dev *rc;\n\tstruct device *dev;\n\n\tstruct urb *urb;\n\tstruct usb_ctrlrequest request;\n\n\tstruct timer_list timer;\n\n\tu8 *buf_in;\n\n\tchar phys[64];\n};\n\nstatic void igorplugusb_cmd(struct igorplugusb *ir, int cmd);\n\nstatic void igorplugusb_irdata(struct igorplugusb *ir, unsigned len)\n{\n\tstruct ir_raw_event rawir = {};\n\tunsigned i, start, overflow;\n\n\tdev_dbg(ir->dev, \"irdata: %*ph (len=%u)\", len, ir->buf_in, len);\n\n\t \n\toverflow = ir->buf_in[2];\n\ti = start = overflow + HEADERLEN;\n\n\tif (start >= len) {\n\t\tdev_err(ir->dev, \"receive overflow invalid: %u\", overflow);\n\t} else {\n\t\tif (overflow > 0) {\n\t\t\tdev_warn(ir->dev, \"receive overflow, at least %u lost\",\n\t\t\t\t\t\t\t\toverflow);\n\t\t\tir_raw_event_overflow(ir->rc);\n\t\t}\n\n\t\tdo {\n\t\t\trawir.duration = ir->buf_in[i] * 85;\n\t\t\trawir.pulse = i & 1;\n\n\t\t\tir_raw_event_store_with_filter(ir->rc, &rawir);\n\n\t\t\tif (++i == len)\n\t\t\t\ti = HEADERLEN;\n\t\t} while (i != start);\n\n\t\t \n\t\trawir.duration = ir->rc->timeout;\n\t\trawir.pulse = false;\n\t\tir_raw_event_store_with_filter(ir->rc, &rawir);\n\n\t\tir_raw_event_handle(ir->rc);\n\t}\n\n\tigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\n}\n\nstatic void igorplugusb_callback(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\tstruct igorplugusb *ir = urb->context;\n\n\treq = (struct usb_ctrlrequest *)urb->setup_packet;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tif (req->bRequest == GET_INFRACODE &&\n\t\t\t\t\turb->actual_length > HEADERLEN)\n\t\t\tigorplugusb_irdata(ir, urb->actual_length);\n\t\telse  \n\t\t\tmod_timer(&ir->timer, jiffies + msecs_to_jiffies(50));\n\t\tbreak;\n\tcase -EPROTO:\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tdev_warn(ir->dev, \"Error: urb status = %d\\n\", urb->status);\n\t\tigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\n\t\tbreak;\n\t}\n}\n\nstatic void igorplugusb_cmd(struct igorplugusb *ir, int cmd)\n{\n\tint ret;\n\n\tir->request.bRequest = cmd;\n\tir->urb->transfer_flags = 0;\n\tret = usb_submit_urb(ir->urb, GFP_ATOMIC);\n\tif (ret && ret != -EPERM)\n\t\tdev_err(ir->dev, \"submit urb failed: %d\", ret);\n}\n\nstatic void igorplugusb_timer(struct timer_list *t)\n{\n\tstruct igorplugusb *ir = from_timer(ir, t, timer);\n\n\tigorplugusb_cmd(ir, GET_INFRACODE);\n}\n\nstatic int igorplugusb_probe(struct usb_interface *intf,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *idesc;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct igorplugusb *ir;\n\tstruct rc_dev *rc;\n\tint ret = -ENOMEM;\n\n\tudev = interface_to_usbdev(intf);\n\tidesc = intf->cur_altsetting;\n\n\tif (idesc->desc.bNumEndpoints != 1) {\n\t\tdev_err(&intf->dev, \"incorrect number of endpoints\");\n\t\treturn -ENODEV;\n\t}\n\n\tep = &idesc->endpoint[0].desc;\n\tif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_control(ep)) {\n\t\tdev_err(&intf->dev, \"endpoint incorrect\");\n\t\treturn -ENODEV;\n\t}\n\n\tir = devm_kzalloc(&intf->dev, sizeof(*ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tir->dev = &intf->dev;\n\n\ttimer_setup(&ir->timer, igorplugusb_timer, 0);\n\n\tir->request.bRequest = GET_INFRACODE;\n\tir->request.bRequestType = USB_TYPE_VENDOR | USB_DIR_IN;\n\tir->request.wLength = cpu_to_le16(MAX_PACKET);\n\n\tir->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!ir->urb)\n\t\tgoto fail;\n\n\tir->buf_in = kmalloc(MAX_PACKET, GFP_KERNEL);\n\tif (!ir->buf_in)\n\t\tgoto fail;\n\tusb_fill_control_urb(ir->urb, udev,\n\t\tusb_rcvctrlpipe(udev, 0), (uint8_t *)&ir->request,\n\t\tir->buf_in, MAX_PACKET, igorplugusb_callback, ir);\n\n\tusb_make_path(udev, ir->phys, sizeof(ir->phys));\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc)\n\t\tgoto fail;\n\n\trc->device_name = DRIVER_DESC;\n\trc->input_phys = ir->phys;\n\tusb_to_input_id(udev, &rc->input_id);\n\trc->dev.parent = &intf->dev;\n\t \n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER &\n\t\t~(RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32 |\n\t\t  RC_PROTO_BIT_RC6_6A_20 | RC_PROTO_BIT_RC6_6A_24 |\n\t\t  RC_PROTO_BIT_RC6_6A_32 | RC_PROTO_BIT_RC6_MCE |\n\t\t  RC_PROTO_BIT_SONY20 | RC_PROTO_BIT_SANYO);\n\n\trc->priv = ir;\n\trc->driver_name = DRIVER_NAME;\n\trc->map_name = RC_MAP_HAUPPAUGE;\n\trc->timeout = MS_TO_US(100);\n\trc->rx_resolution = 85;\n\n\tir->rc = rc;\n\tret = rc_register_device(rc);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to register rc device: %d\", ret);\n\t\tgoto fail;\n\t}\n\n\tusb_set_intfdata(intf, ir);\n\n\tigorplugusb_cmd(ir, SET_INFRABUFFER_EMPTY);\n\n\treturn 0;\nfail:\n\tusb_poison_urb(ir->urb);\n\tdel_timer(&ir->timer);\n\tusb_unpoison_urb(ir->urb);\n\tusb_free_urb(ir->urb);\n\trc_free_device(ir->rc);\n\tkfree(ir->buf_in);\n\n\treturn ret;\n}\n\nstatic void igorplugusb_disconnect(struct usb_interface *intf)\n{\n\tstruct igorplugusb *ir = usb_get_intfdata(intf);\n\n\trc_unregister_device(ir->rc);\n\tusb_poison_urb(ir->urb);\n\tdel_timer_sync(&ir->timer);\n\tusb_set_intfdata(intf, NULL);\n\tusb_unpoison_urb(ir->urb);\n\tusb_free_urb(ir->urb);\n\tkfree(ir->buf_in);\n}\n\nstatic const struct usb_device_id igorplugusb_table[] = {\n\t \n\t{ USB_DEVICE(0x03eb, 0x0002) },\n\t \n\t{ USB_DEVICE(0x03eb, 0x21fe) },\n\t \n\t{ }\n};\n\nstatic struct usb_driver igorplugusb_driver = {\n\t.name =\tDRIVER_NAME,\n\t.probe = igorplugusb_probe,\n\t.disconnect = igorplugusb_disconnect,\n\t.id_table = igorplugusb_table\n};\n\nmodule_usb_driver(igorplugusb_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, igorplugusb_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}