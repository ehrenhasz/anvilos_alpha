{
  "module_name": "pwm-ir-tx.c",
  "hash_id": "4784cd162d613f5125a18e282f9f1053408489c162403bb2d186434872376121",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/pwm-ir-tx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pwm.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <media/rc-core.h>\n\n#define DRIVER_NAME\t\"pwm-ir-tx\"\n#define DEVICE_NAME\t\"PWM IR Transmitter\"\n\nstruct pwm_ir {\n\tstruct pwm_device *pwm;\n\tunsigned int carrier;\n\tunsigned int duty_cycle;\n};\n\nstatic const struct of_device_id pwm_ir_of_match[] = {\n\t{ .compatible = \"pwm-ir-tx\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pwm_ir_of_match);\n\nstatic int pwm_ir_set_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\n{\n\tstruct pwm_ir *pwm_ir = dev->priv;\n\n\tpwm_ir->duty_cycle = duty_cycle;\n\n\treturn 0;\n}\n\nstatic int pwm_ir_set_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct pwm_ir *pwm_ir = dev->priv;\n\n\tif (!carrier)\n\t\treturn -EINVAL;\n\n\tpwm_ir->carrier = carrier;\n\n\treturn 0;\n}\n\nstatic int pwm_ir_tx(struct rc_dev *dev, unsigned int *txbuf,\n\t\t     unsigned int count)\n{\n\tstruct pwm_ir *pwm_ir = dev->priv;\n\tstruct pwm_device *pwm = pwm_ir->pwm;\n\tstruct pwm_state state;\n\tint i;\n\tktime_t edge;\n\tlong delta;\n\n\tpwm_init_state(pwm, &state);\n\n\tstate.period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, pwm_ir->carrier);\n\tpwm_set_relative_duty_cycle(&state, pwm_ir->duty_cycle, 100);\n\n\tedge = ktime_get();\n\n\tfor (i = 0; i < count; i++) {\n\t\tstate.enabled = !(i % 2);\n\t\tpwm_apply_state(pwm, &state);\n\n\t\tedge = ktime_add_us(edge, txbuf[i]);\n\t\tdelta = ktime_us_delta(edge, ktime_get());\n\t\tif (delta > 0)\n\t\t\tusleep_range(delta, delta + 10);\n\t}\n\n\tstate.enabled = false;\n\tpwm_apply_state(pwm, &state);\n\n\treturn count;\n}\n\nstatic int pwm_ir_probe(struct platform_device *pdev)\n{\n\tstruct pwm_ir *pwm_ir;\n\tstruct rc_dev *rcdev;\n\tint rc;\n\n\tpwm_ir = devm_kmalloc(&pdev->dev, sizeof(*pwm_ir), GFP_KERNEL);\n\tif (!pwm_ir)\n\t\treturn -ENOMEM;\n\n\tpwm_ir->pwm = devm_pwm_get(&pdev->dev, NULL);\n\tif (IS_ERR(pwm_ir->pwm))\n\t\treturn PTR_ERR(pwm_ir->pwm);\n\n\tpwm_ir->carrier = 38000;\n\tpwm_ir->duty_cycle = 50;\n\n\trcdev = devm_rc_allocate_device(&pdev->dev, RC_DRIVER_IR_RAW_TX);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\trcdev->priv = pwm_ir;\n\trcdev->driver_name = DRIVER_NAME;\n\trcdev->device_name = DEVICE_NAME;\n\trcdev->tx_ir = pwm_ir_tx;\n\trcdev->s_tx_duty_cycle = pwm_ir_set_duty_cycle;\n\trcdev->s_tx_carrier = pwm_ir_set_carrier;\n\n\trc = devm_rc_register_device(&pdev->dev, rcdev);\n\tif (rc < 0)\n\t\tdev_err(&pdev->dev, \"failed to register rc device\\n\");\n\n\treturn rc;\n}\n\nstatic struct platform_driver pwm_ir_driver = {\n\t.probe = pwm_ir_probe,\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = pwm_ir_of_match,\n\t},\n};\nmodule_platform_driver(pwm_ir_driver);\n\nMODULE_DESCRIPTION(\"PWM IR Transmitter\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}