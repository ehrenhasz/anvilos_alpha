{
  "module_name": "gpio-ir-recv.c",
  "hash_id": "36c863def1981bf957ebf08096ac9796a26622bfe9adb1272e44810ad15bd7da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/gpio-ir-recv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/irq.h>\n#include <media/rc-core.h>\n\n#define GPIO_IR_DEVICE_NAME\t\"gpio_ir_recv\"\n\nstruct gpio_rc_dev {\n\tstruct rc_dev *rcdev;\n\tstruct gpio_desc *gpiod;\n\tint irq;\n\tstruct device *pmdev;\n\tstruct pm_qos_request qos;\n};\n\nstatic irqreturn_t gpio_ir_recv_irq(int irq, void *dev_id)\n{\n\tint val;\n\tstruct gpio_rc_dev *gpio_dev = dev_id;\n\tstruct device *pmdev = gpio_dev->pmdev;\n\n\t \n\tif (pmdev)\n\t\tpm_runtime_get(pmdev);\n\n\tval = gpiod_get_value(gpio_dev->gpiod);\n\tif (val >= 0)\n\t\tir_raw_event_store_edge(gpio_dev->rcdev, val == 1);\n\n\tif (pmdev) {\n\t\tpm_runtime_mark_last_busy(pmdev);\n\t\tpm_runtime_put_autosuspend(pmdev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpio_ir_recv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct gpio_rc_dev *gpio_dev;\n\tstruct rc_dev *rcdev;\n\tu32 period = 0;\n\tint rc;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tgpio_dev = devm_kzalloc(dev, sizeof(*gpio_dev), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tgpio_dev->gpiod = devm_gpiod_get(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(gpio_dev->gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio_dev->gpiod),\n\t\t\t\t     \"error getting gpio\\n\");\n\tgpio_dev->irq = gpiod_to_irq(gpio_dev->gpiod);\n\tif (gpio_dev->irq < 0)\n\t\treturn gpio_dev->irq;\n\n\trcdev = devm_rc_allocate_device(dev, RC_DRIVER_IR_RAW);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\trcdev->priv = gpio_dev;\n\trcdev->device_name = GPIO_IR_DEVICE_NAME;\n\trcdev->input_phys = GPIO_IR_DEVICE_NAME \"/input0\";\n\trcdev->input_id.bustype = BUS_HOST;\n\trcdev->input_id.vendor = 0x0001;\n\trcdev->input_id.product = 0x0001;\n\trcdev->input_id.version = 0x0100;\n\trcdev->dev.parent = dev;\n\trcdev->driver_name = KBUILD_MODNAME;\n\trcdev->min_timeout = 1;\n\trcdev->timeout = IR_DEFAULT_TIMEOUT;\n\trcdev->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\trcdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trcdev->map_name = of_get_property(np, \"linux,rc-map-name\", NULL);\n\tif (!rcdev->map_name)\n\t\trcdev->map_name = RC_MAP_EMPTY;\n\n\tgpio_dev->rcdev = rcdev;\n\tif (of_property_read_bool(np, \"wakeup-source\"))\n\t\tdevice_init_wakeup(dev, true);\n\n\trc = devm_rc_register_device(dev, rcdev);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"failed to register rc device (%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tof_property_read_u32(np, \"linux,autosuspend-period\", &period);\n\tif (period) {\n\t\tgpio_dev->pmdev = dev;\n\t\tpm_runtime_set_autosuspend_delay(dev, period);\n\t\tpm_runtime_use_autosuspend(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\treturn devm_request_irq(dev, gpio_dev->irq, gpio_ir_recv_irq,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\n\t\t\t\t\"gpio-ir-recv-irq\", gpio_dev);\n}\n\nstatic void gpio_ir_recv_remove(struct platform_device *pdev)\n{\n\tstruct gpio_rc_dev *gpio_dev = platform_get_drvdata(pdev);\n\tstruct device *pmdev = gpio_dev->pmdev;\n\n\tif (pmdev) {\n\t\tpm_runtime_get_sync(pmdev);\n\t\tcpu_latency_qos_remove_request(&gpio_dev->qos);\n\n\t\tpm_runtime_disable(pmdev);\n\t\tpm_runtime_put_noidle(pmdev);\n\t\tpm_runtime_set_suspended(pmdev);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int gpio_ir_recv_suspend(struct device *dev)\n{\n\tstruct gpio_rc_dev *gpio_dev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(gpio_dev->irq);\n\telse\n\t\tdisable_irq(gpio_dev->irq);\n\n\treturn 0;\n}\n\nstatic int gpio_ir_recv_resume(struct device *dev)\n{\n\tstruct gpio_rc_dev *gpio_dev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(gpio_dev->irq);\n\telse\n\t\tenable_irq(gpio_dev->irq);\n\n\treturn 0;\n}\n\nstatic int gpio_ir_recv_runtime_suspend(struct device *dev)\n{\n\tstruct gpio_rc_dev *gpio_dev = dev_get_drvdata(dev);\n\n\tcpu_latency_qos_remove_request(&gpio_dev->qos);\n\n\treturn 0;\n}\n\nstatic int gpio_ir_recv_runtime_resume(struct device *dev)\n{\n\tstruct gpio_rc_dev *gpio_dev = dev_get_drvdata(dev);\n\n\tcpu_latency_qos_add_request(&gpio_dev->qos, 0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops gpio_ir_recv_pm_ops = {\n\t.suspend        = gpio_ir_recv_suspend,\n\t.resume         = gpio_ir_recv_resume,\n\t.runtime_suspend = gpio_ir_recv_runtime_suspend,\n\t.runtime_resume  = gpio_ir_recv_runtime_resume,\n};\n#endif\n\nstatic const struct of_device_id gpio_ir_recv_of_match[] = {\n\t{ .compatible = \"gpio-ir-receiver\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gpio_ir_recv_of_match);\n\nstatic struct platform_driver gpio_ir_recv_driver = {\n\t.probe  = gpio_ir_recv_probe,\n\t.remove_new = gpio_ir_recv_remove,\n\t.driver = {\n\t\t.name   = KBUILD_MODNAME,\n\t\t.of_match_table = gpio_ir_recv_of_match,\n#ifdef CONFIG_PM\n\t\t.pm\t= &gpio_ir_recv_pm_ops,\n#endif\n\t},\n};\nmodule_platform_driver(gpio_ir_recv_driver);\n\nMODULE_DESCRIPTION(\"GPIO IR Receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}