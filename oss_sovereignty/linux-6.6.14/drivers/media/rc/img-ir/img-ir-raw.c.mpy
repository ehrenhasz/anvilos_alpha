{
  "module_name": "img-ir-raw.c",
  "hash_id": "a5ce345257348ff49b0d2911611881c2f135dd0f31a64dc17d6c86b18939c677",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/img-ir/img-ir-raw.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <media/rc-core.h>\n#include \"img-ir.h\"\n\n#define ECHO_TIMEOUT_MS 150\t \n\n \nstatic void img_ir_refresh_raw(struct img_ir_priv *priv, u32 irq_status)\n{\n\tstruct img_ir_priv_raw *raw = &priv->raw;\n\tstruct rc_dev *rc_dev = priv->raw.rdev;\n\tint multiple;\n\tu32 ir_status;\n\n\t \n\tmultiple = ((irq_status & IMG_IR_IRQ_EDGE) == IMG_IR_IRQ_EDGE);\n\t \n\tir_status = img_ir_read(priv, IMG_IR_STATUS) & IMG_IR_IRRXD;\n\tif (multiple && ir_status == raw->last_status)\n\t\treturn;\n\traw->last_status = ir_status;\n\n\t \n\tif (ir_status)  \n\t\tir_raw_event_store_edge(rc_dev, false);\n\telse  \n\t\tir_raw_event_store_edge(rc_dev, true);\n\tir_raw_event_handle(rc_dev);\n}\n\n \nvoid img_ir_isr_raw(struct img_ir_priv *priv, u32 irq_status)\n{\n\tstruct img_ir_priv_raw *raw = &priv->raw;\n\n\t \n\tif (!raw->rdev)\n\t\treturn;\n\n\timg_ir_refresh_raw(priv, irq_status);\n\n\t \n\tmod_timer(&raw->timer, jiffies + msecs_to_jiffies(ECHO_TIMEOUT_MS));\n}\n\n \nstatic void img_ir_echo_timer(struct timer_list *t)\n{\n\tstruct img_ir_priv *priv = from_timer(priv, t, raw.timer);\n\n\tspin_lock_irq(&priv->lock);\n\n\t \n\tif (priv->raw.rdev)\n\t\t \n\t\timg_ir_refresh_raw(priv, 0);\n\n\tspin_unlock_irq(&priv->lock);\n}\n\nvoid img_ir_setup_raw(struct img_ir_priv *priv)\n{\n\tu32 irq_en;\n\n\tif (!priv->raw.rdev)\n\t\treturn;\n\n\t \n\tspin_lock_irq(&priv->lock);\n\tirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\tirq_en |= IMG_IR_IRQ_EDGE;\n\timg_ir_write(priv, IMG_IR_IRQ_CLEAR, IMG_IR_IRQ_EDGE);\n\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en);\n\tspin_unlock_irq(&priv->lock);\n}\n\nint img_ir_probe_raw(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_raw *raw = &priv->raw;\n\tstruct rc_dev *rdev;\n\tint error;\n\n\t \n\ttimer_setup(&raw->timer, img_ir_echo_timer, 0);\n\n\t \n\traw->rdev = rdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev) {\n\t\tdev_err(priv->dev, \"cannot allocate raw input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trdev->priv = priv;\n\trdev->map_name = RC_MAP_EMPTY;\n\trdev->device_name = \"IMG Infrared Decoder Raw\";\n\n\t \n\terror = rc_register_device(rdev);\n\tif (error) {\n\t\tdev_err(priv->dev, \"failed to register raw IR input device\\n\");\n\t\trc_free_device(rdev);\n\t\traw->rdev = NULL;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nvoid img_ir_remove_raw(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_raw *raw = &priv->raw;\n\tstruct rc_dev *rdev = raw->rdev;\n\tu32 irq_en;\n\n\tif (!rdev)\n\t\treturn;\n\n\t \n\tspin_lock_irq(&priv->lock);\n\traw->rdev = NULL;\n\tirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\tirq_en &= ~IMG_IR_IRQ_EDGE;\n\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en);\n\timg_ir_write(priv, IMG_IR_IRQ_CLEAR, IMG_IR_IRQ_EDGE);\n\tspin_unlock_irq(&priv->lock);\n\n\trc_unregister_device(rdev);\n\n\tdel_timer_sync(&raw->timer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}