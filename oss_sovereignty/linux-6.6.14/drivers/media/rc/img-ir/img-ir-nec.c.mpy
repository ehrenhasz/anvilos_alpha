{
  "module_name": "img-ir-nec.c",
  "hash_id": "a27046bbc8b3a4ba07c883f394b3205903a7449d89496ebb1d29e72d91a3fbc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/img-ir/img-ir-nec.c",
  "human_readable_source": "\n \n\n#include \"img-ir-hw.h\"\n#include <linux/bitrev.h>\n#include <linux/log2.h>\n\n \nstatic int img_ir_nec_scancode(int len, u64 raw, u64 enabled_protocols,\n\t\t\t       struct img_ir_scancode_req *request)\n{\n\tunsigned int addr, addr_inv, data, data_inv;\n\t \n\tif (!len)\n\t\treturn IMG_IR_REPEATCODE;\n\tif (len != 32)\n\t\treturn -EINVAL;\n\t \n\taddr     = (raw >>  0) & 0xff;\n\taddr_inv = (raw >>  8) & 0xff;\n\tdata     = (raw >> 16) & 0xff;\n\tdata_inv = (raw >> 24) & 0xff;\n\tif ((data_inv ^ data) != 0xff) {\n\t\t \n\t\t \n\t\trequest->scancode = bitrev8(addr)     << 24 |\n\t\t\t\tbitrev8(addr_inv) << 16 |\n\t\t\t\tbitrev8(data)     <<  8 |\n\t\t\t\tbitrev8(data_inv);\n\t\trequest->protocol = RC_PROTO_NEC32;\n\t} else if ((addr_inv ^ addr) != 0xff) {\n\t\t \n\t\t \n\t\trequest->scancode = addr     << 16 |\n\t\t\t\taddr_inv <<  8 |\n\t\t\t\tdata;\n\t\trequest->protocol = RC_PROTO_NECX;\n\t} else {\n\t\t \n\t\t \n\t\trequest->scancode = addr << 8 |\n\t\t\t\tdata;\n\t\trequest->protocol = RC_PROTO_NEC;\n\t}\n\treturn IMG_IR_SCANCODE;\n}\n\n \nstatic int img_ir_nec_filter(const struct rc_scancode_filter *in,\n\t\t\t     struct img_ir_filter *out, u64 protocols)\n{\n\tunsigned int addr, addr_inv, data, data_inv;\n\tunsigned int addr_m, addr_inv_m, data_m, data_inv_m;\n\n\tdata       = in->data & 0xff;\n\tdata_m     = in->mask & 0xff;\n\n\tprotocols &= RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32;\n\n\t \n\tif (!is_power_of_2(protocols)) {\n\t\tif ((in->data | in->mask) & 0xff000000)\n\t\t\tprotocols = RC_PROTO_BIT_NEC32;\n\t\telse if ((in->data | in->mask) & 0x00ff0000)\n\t\t\tprotocols = RC_PROTO_BIT_NECX;\n\t\telse\n\t\t\tprotocols = RC_PROTO_BIT_NEC;\n\t}\n\n\tif (protocols == RC_PROTO_BIT_NEC32) {\n\t\t \n\t\t \n\t\taddr       = bitrev8(in->data >> 24);\n\t\taddr_m     = bitrev8(in->mask >> 24);\n\t\taddr_inv   = bitrev8(in->data >> 16);\n\t\taddr_inv_m = bitrev8(in->mask >> 16);\n\t\tdata       = bitrev8(in->data >>  8);\n\t\tdata_m     = bitrev8(in->mask >>  8);\n\t\tdata_inv   = bitrev8(in->data >>  0);\n\t\tdata_inv_m = bitrev8(in->mask >>  0);\n\t} else if (protocols == RC_PROTO_BIT_NECX) {\n\t\t \n\t\t \n\t\taddr       = (in->data >> 16) & 0xff;\n\t\taddr_m     = (in->mask >> 16) & 0xff;\n\t\taddr_inv   = (in->data >>  8) & 0xff;\n\t\taddr_inv_m = (in->mask >>  8) & 0xff;\n\t\tdata_inv   = data ^ 0xff;\n\t\tdata_inv_m = data_m;\n\t} else {\n\t\t \n\t\t \n\t\taddr       = (in->data >>  8) & 0xff;\n\t\taddr_m     = (in->mask >>  8) & 0xff;\n\t\taddr_inv   = addr ^ 0xff;\n\t\taddr_inv_m = addr_m;\n\t\tdata_inv   = data ^ 0xff;\n\t\tdata_inv_m = data_m;\n\t}\n\n\t \n\tout->data = data_inv << 24 |\n\t\t    data     << 16 |\n\t\t    addr_inv <<  8 |\n\t\t    addr;\n\tout->mask = data_inv_m << 24 |\n\t\t    data_m     << 16 |\n\t\t    addr_inv_m <<  8 |\n\t\t    addr_m;\n\treturn 0;\n}\n\n \nstruct img_ir_decoder img_ir_nec = {\n\t.type = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32,\n\t.control = {\n\t\t.decoden = 1,\n\t\t.code_type = IMG_IR_CODETYPE_PULSEDIST,\n\t},\n\t \n\t.unit = 562500,  \n\t.timings = {\n\t\t \n\t\t.ldr = {\n\t\t\t.pulse = { 16\t  },\n\t\t\t.space = { 8\t  },\n\t\t},\n\t\t \n\t\t.s00 = {\n\t\t\t.pulse = { 1\t  },\n\t\t\t.space = { 1\t  },\n\t\t},\n\t\t \n\t\t.s01 = {\n\t\t\t.pulse = { 1\t  },\n\t\t\t.space = { 3\t  },\n\t\t},\n\t\t \n\t\t.ft = {\n\t\t\t.minlen = 32,\n\t\t\t.maxlen = 32,\n\t\t\t.ft_min = 10,\t \n\t\t},\n\t},\n\t \n\t.repeat = 108,\t\t\t \n\t.rtimings = {\n\t\t \n\t\t.ldr = {\n\t\t\t.space = { 4\t  },\n\t\t},\n\t\t \n\t\t.ft = {\n\t\t\t.minlen = 0,\t \n\t\t\t.maxlen = 0,\n\t\t},\n\t},\n\t \n\t.scancode = img_ir_nec_scancode,\n\t.filter = img_ir_nec_filter,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}