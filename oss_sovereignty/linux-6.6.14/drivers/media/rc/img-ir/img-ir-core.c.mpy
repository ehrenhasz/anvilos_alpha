{
  "module_name": "img-ir-core.c",
  "hash_id": "794345f2e65f417161cfb5a0cc8af508f0a97ffaf5f954b784aae4bcbf4c69ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/img-ir/img-ir-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include \"img-ir.h\"\n\nstatic irqreturn_t img_ir_isr(int irq, void *dev_id)\n{\n\tstruct img_ir_priv *priv = dev_id;\n\tu32 irq_status;\n\n\tspin_lock(&priv->lock);\n\t \n\tirq_status = img_ir_read(priv, IMG_IR_IRQ_STATUS);\n\timg_ir_write(priv, IMG_IR_IRQ_CLEAR, irq_status);\n\n\t \n\tirq_status &= img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\n\t \n\tif (irq_status & IMG_IR_IRQ_EDGE && img_ir_raw_enabled(&priv->raw))\n\t\timg_ir_isr_raw(priv, irq_status);\n\n\t \n\tif (irq_status & (IMG_IR_IRQ_DATA_MATCH |\n\t\t\t  IMG_IR_IRQ_DATA_VALID |\n\t\t\t  IMG_IR_IRQ_DATA2_VALID) &&\n\t    img_ir_hw_enabled(&priv->hw))\n\t\timg_ir_isr_hw(priv, irq_status);\n\n\tspin_unlock(&priv->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void img_ir_setup(struct img_ir_priv *priv)\n{\n\t \n\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, 0);\n\n\timg_ir_setup_raw(priv);\n\timg_ir_setup_hw(priv);\n\n\tif (!IS_ERR(priv->clk))\n\t\tclk_prepare_enable(priv->clk);\n}\n\nstatic void img_ir_ident(struct img_ir_priv *priv)\n{\n\tu32 core_rev = img_ir_read(priv, IMG_IR_CORE_REV);\n\n\tdev_info(priv->dev,\n\t\t \"IMG IR Decoder (%d.%d.%d.%d) probed successfully\\n\",\n\t\t (core_rev & IMG_IR_DESIGNER) >> IMG_IR_DESIGNER_SHIFT,\n\t\t (core_rev & IMG_IR_MAJOR_REV) >> IMG_IR_MAJOR_REV_SHIFT,\n\t\t (core_rev & IMG_IR_MINOR_REV) >> IMG_IR_MINOR_REV_SHIFT,\n\t\t (core_rev & IMG_IR_MAINT_REV) >> IMG_IR_MAINT_REV_SHIFT);\n\tdev_info(priv->dev, \"Modes:%s%s\\n\",\n\t\t img_ir_hw_enabled(&priv->hw) ? \" hardware\" : \"\",\n\t\t img_ir_raw_enabled(&priv->raw) ? \" raw\" : \"\");\n}\n\nstatic int img_ir_probe(struct platform_device *pdev)\n{\n\tstruct img_ir_priv *priv;\n\tint irq, error, error2;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->dev = &pdev->dev;\n\tspin_lock_init(&priv->lock);\n\n\t \n\tpriv->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->reg_base))\n\t\treturn PTR_ERR(priv->reg_base);\n\n\t \n\tpriv->clk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(priv->clk))\n\t\tdev_warn(&pdev->dev, \"cannot get core clock resource\\n\");\n\n\t \n\tpriv->sys_clk = devm_clk_get(&pdev->dev, \"sys\");\n\tif (IS_ERR(priv->sys_clk))\n\t\tdev_warn(&pdev->dev, \"cannot get sys clock resource\\n\");\n\t \n\tif (!IS_ERR(priv->sys_clk)) {\n\t\terror = clk_prepare_enable(priv->sys_clk);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"cannot enable sys clock\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\terror = img_ir_probe_raw(priv);\n\terror2 = img_ir_probe_hw(priv);\n\tif (error && error2) {\n\t\tif (error == -ENODEV)\n\t\t\terror = error2;\n\t\tgoto err_probe;\n\t}\n\n\t \n\tpriv->irq = irq;\n\terror = request_irq(priv->irq, img_ir_isr, 0, \"img-ir\", priv);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"cannot register IRQ %u\\n\",\n\t\t\tpriv->irq);\n\t\terror = -EIO;\n\t\tgoto err_irq;\n\t}\n\n\timg_ir_ident(priv);\n\timg_ir_setup(priv);\n\n\treturn 0;\n\nerr_irq:\n\timg_ir_remove_hw(priv);\n\timg_ir_remove_raw(priv);\nerr_probe:\n\tif (!IS_ERR(priv->sys_clk))\n\t\tclk_disable_unprepare(priv->sys_clk);\n\treturn error;\n}\n\nstatic void img_ir_remove(struct platform_device *pdev)\n{\n\tstruct img_ir_priv *priv = platform_get_drvdata(pdev);\n\n\tfree_irq(priv->irq, priv);\n\timg_ir_remove_hw(priv);\n\timg_ir_remove_raw(priv);\n\n\tif (!IS_ERR(priv->clk))\n\t\tclk_disable_unprepare(priv->clk);\n\tif (!IS_ERR(priv->sys_clk))\n\t\tclk_disable_unprepare(priv->sys_clk);\n}\n\nstatic SIMPLE_DEV_PM_OPS(img_ir_pmops, img_ir_suspend, img_ir_resume);\n\nstatic const struct of_device_id img_ir_match[] = {\n\t{ .compatible = \"img,ir-rev1\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, img_ir_match);\n\nstatic struct platform_driver img_ir_driver = {\n\t.driver = {\n\t\t.name = \"img-ir\",\n\t\t.of_match_table\t= img_ir_match,\n\t\t.pm = &img_ir_pmops,\n\t},\n\t.probe = img_ir_probe,\n\t.remove_new = img_ir_remove,\n};\n\nmodule_platform_driver(img_ir_driver);\n\nMODULE_AUTHOR(\"Imagination Technologies Ltd.\");\nMODULE_DESCRIPTION(\"ImgTec IR\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}