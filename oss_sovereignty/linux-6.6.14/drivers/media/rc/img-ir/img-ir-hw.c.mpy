{
  "module_name": "img-ir-hw.c",
  "hash_id": "d74c68e956a69c0d5de4f72e717533f3c5b7ab3bf458ac4b0a864c8f6a8e1465",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/img-ir/img-ir-hw.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <media/rc-core.h>\n#include \"img-ir.h\"\n\n \nstatic DEFINE_SPINLOCK(img_ir_decoders_lock);\n\nstatic bool img_ir_decoders_preprocessed;\nstatic struct img_ir_decoder *img_ir_decoders[] = {\n#ifdef CONFIG_IR_IMG_NEC\n\t&img_ir_nec,\n#endif\n#ifdef CONFIG_IR_IMG_JVC\n\t&img_ir_jvc,\n#endif\n#ifdef CONFIG_IR_IMG_SONY\n\t&img_ir_sony,\n#endif\n#ifdef CONFIG_IR_IMG_SHARP\n\t&img_ir_sharp,\n#endif\n#ifdef CONFIG_IR_IMG_SANYO\n\t&img_ir_sanyo,\n#endif\n#ifdef CONFIG_IR_IMG_RC5\n\t&img_ir_rc5,\n#endif\n#ifdef CONFIG_IR_IMG_RC6\n\t&img_ir_rc6,\n#endif\n\tNULL\n};\n\n#define IMG_IR_F_FILTER\t\tBIT(RC_FILTER_NORMAL)\t \n#define IMG_IR_F_WAKE\t\tBIT(RC_FILTER_WAKEUP)\t \n\n \n\n#define IMG_IR_QUIRK_CODE_BROKEN\t0x1\t \n#define IMG_IR_QUIRK_CODE_LEN_INCR\t0x2\t \n \n#define IMG_IR_QUIRK_CODE_IRQ\t\t0x4\n\n \n\nstatic void img_ir_timing_preprocess(struct img_ir_timing_range *range,\n\t\t\t\t     unsigned int unit)\n{\n\tif (range->max < range->min)\n\t\trange->max = range->min;\n\tif (unit) {\n\t\t \n\t\trange->min = (range->min*unit)/1000;\n\t\trange->max = (range->max*unit + 999)/1000;  \n\t}\n}\n\nstatic void img_ir_symbol_timing_preprocess(struct img_ir_symbol_timing *timing,\n\t\t\t\t\t    unsigned int unit)\n{\n\timg_ir_timing_preprocess(&timing->pulse, unit);\n\timg_ir_timing_preprocess(&timing->space, unit);\n}\n\nstatic void img_ir_timings_preprocess(struct img_ir_timings *timings,\n\t\t\t\t      unsigned int unit)\n{\n\timg_ir_symbol_timing_preprocess(&timings->ldr, unit);\n\timg_ir_symbol_timing_preprocess(&timings->s00, unit);\n\timg_ir_symbol_timing_preprocess(&timings->s01, unit);\n\timg_ir_symbol_timing_preprocess(&timings->s10, unit);\n\timg_ir_symbol_timing_preprocess(&timings->s11, unit);\n\t \n\tif (unit)\n\t\t \n\t\ttimings->ft.ft_min = (timings->ft.ft_min*unit + 999)/1000;\n}\n\n \n\nstatic void img_ir_timing_defaults(struct img_ir_timing_range *range,\n\t\t\t\t   struct img_ir_timing_range *defaults)\n{\n\tif (!range->min)\n\t\trange->min = defaults->min;\n\tif (!range->max)\n\t\trange->max = defaults->max;\n}\n\nstatic void img_ir_symbol_timing_defaults(struct img_ir_symbol_timing *timing,\n\t\t\t\t\t  struct img_ir_symbol_timing *defaults)\n{\n\timg_ir_timing_defaults(&timing->pulse, &defaults->pulse);\n\timg_ir_timing_defaults(&timing->space, &defaults->space);\n}\n\nstatic void img_ir_timings_defaults(struct img_ir_timings *timings,\n\t\t\t\t    struct img_ir_timings *defaults)\n{\n\timg_ir_symbol_timing_defaults(&timings->ldr, &defaults->ldr);\n\timg_ir_symbol_timing_defaults(&timings->s00, &defaults->s00);\n\timg_ir_symbol_timing_defaults(&timings->s01, &defaults->s01);\n\timg_ir_symbol_timing_defaults(&timings->s10, &defaults->s10);\n\timg_ir_symbol_timing_defaults(&timings->s11, &defaults->s11);\n\tif (!timings->ft.ft_min)\n\t\ttimings->ft.ft_min = defaults->ft.ft_min;\n}\n\n \n\n \nstatic u32 img_ir_control(const struct img_ir_control *control)\n{\n\tu32 ctrl = control->code_type << IMG_IR_CODETYPE_SHIFT;\n\tif (control->decoden)\n\t\tctrl |= IMG_IR_DECODEN;\n\tif (control->hdrtog)\n\t\tctrl |= IMG_IR_HDRTOG;\n\tif (control->ldrdec)\n\t\tctrl |= IMG_IR_LDRDEC;\n\tif (control->decodinpol)\n\t\tctrl |= IMG_IR_DECODINPOL;\n\tif (control->bitorien)\n\t\tctrl |= IMG_IR_BITORIEN;\n\tif (control->d1validsel)\n\t\tctrl |= IMG_IR_D1VALIDSEL;\n\tif (control->bitinv)\n\t\tctrl |= IMG_IR_BITINV;\n\tif (control->decodend2)\n\t\tctrl |= IMG_IR_DECODEND2;\n\tif (control->bitoriend2)\n\t\tctrl |= IMG_IR_BITORIEND2;\n\tif (control->bitinvd2)\n\t\tctrl |= IMG_IR_BITINVD2;\n\treturn ctrl;\n}\n\n \nstatic void img_ir_timing_range_convert(struct img_ir_timing_range *out,\n\t\t\t\t\tconst struct img_ir_timing_range *in,\n\t\t\t\t\tunsigned int tolerance,\n\t\t\t\t\tunsigned long clock_hz,\n\t\t\t\t\tunsigned int shift)\n{\n\tunsigned int min = in->min;\n\tunsigned int max = in->max;\n\t \n\tmin = min - (min*tolerance >> 7);\n\tmax = max + (max*tolerance >> 7);\n\t \n\tmin = min*clock_hz / 1000000;\n\tmax = (max*clock_hz + 999999) / 1000000;  \n\t \n\tout->min = min >> shift;\n\tout->max = (max + ((1 << shift) - 1)) >> shift;  \n}\n\n \nstatic u32 img_ir_symbol_timing(const struct img_ir_symbol_timing *timing,\n\t\t\t\tunsigned int tolerance,\n\t\t\t\tunsigned long clock_hz,\n\t\t\t\tunsigned int pd_shift,\n\t\t\t\tunsigned int w_shift)\n{\n\tstruct img_ir_timing_range hw_pulse, hw_period;\n\t \n\thw_period.min = timing->pulse.min + timing->space.min;\n\thw_period.max = timing->pulse.max + timing->space.max;\n\timg_ir_timing_range_convert(&hw_period, &hw_period,\n\t\t\ttolerance, clock_hz, pd_shift);\n\timg_ir_timing_range_convert(&hw_pulse, &timing->pulse,\n\t\t\ttolerance, clock_hz, w_shift);\n\t \n\treturn\t(hw_period.max\t<< IMG_IR_PD_MAX_SHIFT)\t|\n\t\t(hw_period.min\t<< IMG_IR_PD_MIN_SHIFT)\t|\n\t\t(hw_pulse.max\t<< IMG_IR_W_MAX_SHIFT)\t|\n\t\t(hw_pulse.min\t<< IMG_IR_W_MIN_SHIFT);\n}\n\n \nstatic u32 img_ir_free_timing(const struct img_ir_free_timing *timing,\n\t\t\t      unsigned long clock_hz)\n{\n\tunsigned int minlen, maxlen, ft_min;\n\t \n\tif (timing->minlen < 30)\n\t\tminlen = timing->minlen & -2;\n\telse\n\t\tminlen = 30;\n\t \n\tif (timing->maxlen < 48)\n\t\tmaxlen = (timing->maxlen + 1) & -2;\n\telse\n\t\tmaxlen = 48;\n\t \n\tft_min = (timing->ft_min*clock_hz + 999999) / 1000000;\n\tft_min = (ft_min + 7) >> 3;\n\t \n\treturn\t(maxlen << IMG_IR_MAXLEN_SHIFT)\t|\n\t\t(minlen << IMG_IR_MINLEN_SHIFT)\t|\n\t\t(ft_min << IMG_IR_FT_MIN_SHIFT);\n}\n\n \nstatic u32 img_ir_free_timing_dynamic(u32 st_ft, struct img_ir_filter *filter)\n{\n\tunsigned int minlen, maxlen, newminlen, newmaxlen;\n\n\t \n\tnewminlen = filter->minlen & -2;\n\tnewmaxlen = (filter->maxlen + 1) & -2;\n\t \n\tminlen = (st_ft & IMG_IR_MINLEN) >> IMG_IR_MINLEN_SHIFT;\n\tmaxlen = (st_ft & IMG_IR_MAXLEN) >> IMG_IR_MAXLEN_SHIFT;\n\t \n\tif (newminlen > minlen) {\n\t\tst_ft &= ~IMG_IR_MINLEN;\n\t\tst_ft |= newminlen << IMG_IR_MINLEN_SHIFT;\n\t}\n\tif (newmaxlen < maxlen) {\n\t\tst_ft &= ~IMG_IR_MAXLEN;\n\t\tst_ft |= newmaxlen << IMG_IR_MAXLEN_SHIFT;\n\t}\n\treturn st_ft;\n}\n\n \nstatic void img_ir_timings_convert(struct img_ir_timing_regvals *regs,\n\t\t\t\t   const struct img_ir_timings *timings,\n\t\t\t\t   unsigned int tolerance,\n\t\t\t\t   unsigned int clock_hz)\n{\n\t \n\tregs->ldr = img_ir_symbol_timing(&timings->ldr, tolerance, clock_hz,\n\t\t\t4, 4);\n\t \n\tregs->s00 = img_ir_symbol_timing(&timings->s00, tolerance, clock_hz,\n\t\t\t1, 0);\n\tregs->s01 = img_ir_symbol_timing(&timings->s01, tolerance, clock_hz,\n\t\t\t1, 0);\n\tregs->s10 = img_ir_symbol_timing(&timings->s10, tolerance, clock_hz,\n\t\t\t1, 0);\n\tregs->s11 = img_ir_symbol_timing(&timings->s11, tolerance, clock_hz,\n\t\t\t1, 0);\n\tregs->ft = img_ir_free_timing(&timings->ft, clock_hz);\n}\n\n \nstatic void img_ir_decoder_preprocess(struct img_ir_decoder *decoder)\n{\n\t \n\tif (!decoder->tolerance)\n\t\tdecoder->tolerance = 10;  \n\t \n\tdecoder->tolerance = decoder->tolerance * 128 / 100;\n\n\t \n\timg_ir_timings_preprocess(&decoder->timings, decoder->unit);\n\n\t \n\tif (decoder->repeat) {\n\t\timg_ir_timings_preprocess(&decoder->rtimings, decoder->unit);\n\t\timg_ir_timings_defaults(&decoder->rtimings, &decoder->timings);\n\t}\n}\n\n \nstatic void img_ir_decoder_convert(const struct img_ir_decoder *decoder,\n\t\t\t\t   struct img_ir_reg_timings *reg_timings,\n\t\t\t\t   unsigned int clock_hz)\n{\n\t \n\treg_timings->ctrl = img_ir_control(&decoder->control);\n\n\t \n\timg_ir_timings_convert(&reg_timings->timings, &decoder->timings,\n\t\t\t       decoder->tolerance, clock_hz);\n\n\t \n\tif (decoder->repeat)\n\t\timg_ir_timings_convert(&reg_timings->rtimings,\n\t\t\t\t       &decoder->rtimings, decoder->tolerance,\n\t\t\t\t       clock_hz);\n}\n\n \nstatic void img_ir_write_timings(struct img_ir_priv *priv,\n\t\t\t\t struct img_ir_timing_regvals *regs,\n\t\t\t\t enum rc_filter_type type)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\n\t \n\tu32 ft = regs->ft;\n\tif (hw->flags & BIT(type))\n\t\tft = img_ir_free_timing_dynamic(regs->ft, &hw->filters[type]);\n\t \n\timg_ir_write(priv, IMG_IR_LEAD_SYMB_TIMING, regs->ldr);\n\timg_ir_write(priv, IMG_IR_S00_SYMB_TIMING, regs->s00);\n\timg_ir_write(priv, IMG_IR_S01_SYMB_TIMING, regs->s01);\n\timg_ir_write(priv, IMG_IR_S10_SYMB_TIMING, regs->s10);\n\timg_ir_write(priv, IMG_IR_S11_SYMB_TIMING, regs->s11);\n\timg_ir_write(priv, IMG_IR_FREE_SYMB_TIMING, ft);\n\tdev_dbg(priv->dev, \"timings: ldr=%#x, s=[%#x, %#x, %#x, %#x], ft=%#x\\n\",\n\t\tregs->ldr, regs->s00, regs->s01, regs->s10, regs->s11, ft);\n}\n\nstatic void img_ir_write_filter(struct img_ir_priv *priv,\n\t\t\t\tstruct img_ir_filter *filter)\n{\n\tif (filter) {\n\t\tdev_dbg(priv->dev, \"IR filter=%016llx & %016llx\\n\",\n\t\t\t(unsigned long long)filter->data,\n\t\t\t(unsigned long long)filter->mask);\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_DATA_LW, (u32)filter->data);\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_DATA_UP, (u32)(filter->data\n\t\t\t\t\t\t\t\t\t>> 32));\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_LW, (u32)filter->mask);\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_UP, (u32)(filter->mask\n\t\t\t\t\t\t\t\t\t>> 32));\n\t} else {\n\t\tdev_dbg(priv->dev, \"IR clearing filter\\n\");\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_LW, 0);\n\t\timg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_UP, 0);\n\t}\n}\n\n \nstatic void _img_ir_set_filter(struct img_ir_priv *priv,\n\t\t\t       struct img_ir_filter *filter)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tu32 irq_en, irq_on;\n\n\tirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\tif (filter) {\n\t\t \n\t\thw->filters[RC_FILTER_NORMAL] = *filter;\n\t\thw->flags |= IMG_IR_F_FILTER;\n\t\tirq_on = IMG_IR_IRQ_DATA_MATCH;\n\t\tirq_en &= ~(IMG_IR_IRQ_DATA_VALID | IMG_IR_IRQ_DATA2_VALID);\n\t} else {\n\t\t \n\t\thw->flags &= ~IMG_IR_F_FILTER;\n\t\tirq_en &= ~IMG_IR_IRQ_DATA_MATCH;\n\t\tirq_on = IMG_IR_IRQ_DATA_VALID | IMG_IR_IRQ_DATA2_VALID;\n\t}\n\tirq_en |= irq_on;\n\n\timg_ir_write_filter(priv, filter);\n\t \n\timg_ir_write(priv, IMG_IR_IRQ_CLEAR, irq_on);\n\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en);\n}\n\n \nstatic void _img_ir_set_wake_filter(struct img_ir_priv *priv,\n\t\t\t\t    struct img_ir_filter *filter)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tif (filter) {\n\t\t \n\t\thw->filters[RC_FILTER_WAKEUP] = *filter;\n\t\thw->flags |= IMG_IR_F_WAKE;\n\t} else {\n\t\t \n\t\thw->flags &= ~IMG_IR_F_WAKE;\n\t}\n}\n\n \nstatic int img_ir_set_filter(struct rc_dev *dev, enum rc_filter_type type,\n\t\t\t     struct rc_scancode_filter *sc_filter)\n{\n\tstruct img_ir_priv *priv = dev->priv;\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tstruct img_ir_filter filter, *filter_ptr = &filter;\n\tint ret = 0;\n\n\tdev_dbg(priv->dev, \"IR scancode %sfilter=%08x & %08x\\n\",\n\t\ttype == RC_FILTER_WAKEUP ? \"wake \" : \"\",\n\t\tsc_filter->data,\n\t\tsc_filter->mask);\n\n\tspin_lock_irq(&priv->lock);\n\n\t \n\tif (!sc_filter->mask) {\n\t\tfilter_ptr = NULL;\n\t\tgoto set_unlock;\n\t}\n\n\t \n\tif (!hw->decoder || !hw->decoder->filter) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tfilter.minlen = 0;\n\tfilter.maxlen = ~0;\n\tif (type == RC_FILTER_NORMAL) {\n\t\t \n\t\tret = hw->decoder->filter(sc_filter, &filter,\n\t\t\t\t\t  dev->enabled_protocols);\n\t} else {\n\t\t \n\t\tret = hw->decoder->filter(sc_filter, &filter,\n\t\t\t\t\t  1ULL << dev->wakeup_protocol);\n\t}\n\tif (ret)\n\t\tgoto unlock;\n\tdev_dbg(priv->dev, \"IR raw %sfilter=%016llx & %016llx\\n\",\n\t\ttype == RC_FILTER_WAKEUP ? \"wake \" : \"\",\n\t\t(unsigned long long)filter.data,\n\t\t(unsigned long long)filter.mask);\n\nset_unlock:\n\t \n\tswitch (type) {\n\tcase RC_FILTER_NORMAL:\n\t\t_img_ir_set_filter(priv, filter_ptr);\n\t\tbreak;\n\tcase RC_FILTER_WAKEUP:\n\t\t_img_ir_set_wake_filter(priv, filter_ptr);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nunlock:\n\tspin_unlock_irq(&priv->lock);\n\treturn ret;\n}\n\nstatic int img_ir_set_normal_filter(struct rc_dev *dev,\n\t\t\t\t    struct rc_scancode_filter *sc_filter)\n{\n\treturn img_ir_set_filter(dev, RC_FILTER_NORMAL, sc_filter);\n}\n\nstatic int img_ir_set_wakeup_filter(struct rc_dev *dev,\n\t\t\t\t    struct rc_scancode_filter *sc_filter)\n{\n\treturn img_ir_set_filter(dev, RC_FILTER_WAKEUP, sc_filter);\n}\n\n \nstatic void img_ir_set_decoder(struct img_ir_priv *priv,\n\t\t\t       const struct img_ir_decoder *decoder,\n\t\t\t       u64 proto)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tstruct rc_dev *rdev = hw->rdev;\n\tu32 ir_status, irq_en;\n\tspin_lock_irq(&priv->lock);\n\n\t \n\thw->stopping = true;\n\n\t \n\tspin_unlock_irq(&priv->lock);\n\tdel_timer_sync(&hw->end_timer);\n\tdel_timer_sync(&hw->suspend_timer);\n\tspin_lock_irq(&priv->lock);\n\n\thw->stopping = false;\n\n\t \n\timg_ir_write(priv, IMG_IR_CONTROL, 0);\n\tirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en & IMG_IR_IRQ_EDGE);\n\timg_ir_write(priv, IMG_IR_IRQ_CLEAR, IMG_IR_IRQ_ALL & ~IMG_IR_IRQ_EDGE);\n\n\t \n\tir_status = img_ir_read(priv, IMG_IR_STATUS);\n\tif (ir_status & (IMG_IR_RXDVAL | IMG_IR_RXDVALD2)) {\n\t\tir_status &= ~(IMG_IR_RXDVAL | IMG_IR_RXDVALD2);\n\t\timg_ir_write(priv, IMG_IR_STATUS, ir_status);\n\t}\n\n\t \n\timg_ir_read(priv, IMG_IR_DATA_LW);\n\timg_ir_read(priv, IMG_IR_DATA_UP);\n\n\t \n\thw->mode = IMG_IR_M_NORMAL;\n\n\t \n\trdev->scancode_wakeup_filter.data = 0;\n\trdev->scancode_wakeup_filter.mask = 0;\n\trdev->wakeup_protocol = RC_PROTO_UNKNOWN;\n\n\t \n\t_img_ir_set_filter(priv, NULL);\n\t_img_ir_set_wake_filter(priv, NULL);\n\n\t \n\thw->enabled_protocols = 0;\n\n\t \n\thw->decoder = decoder;\n\tif (!decoder)\n\t\tgoto unlock;\n\n\t \n\tif (!proto)\n\t\tproto = decoder->type;\n\thw->enabled_protocols = proto;\n\n\t \n\timg_ir_decoder_convert(decoder, &hw->reg_timings, hw->clk_hz);\n\timg_ir_write_timings(priv, &hw->reg_timings.timings, RC_FILTER_NORMAL);\n\n\t \n\timg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\n\n\nunlock:\n\tspin_unlock_irq(&priv->lock);\n}\n\n \nstatic bool img_ir_decoder_compatible(struct img_ir_priv *priv,\n\t\t\t\t      const struct img_ir_decoder *dec)\n{\n\tunsigned int ct;\n\n\t \n\tct = dec->control.code_type;\n\tif (priv->hw.ct_quirks[ct] & IMG_IR_QUIRK_CODE_BROKEN)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic u64 img_ir_allowed_protos(struct img_ir_priv *priv)\n{\n\tu64 protos = 0;\n\tstruct img_ir_decoder **decp;\n\n\tfor (decp = img_ir_decoders; *decp; ++decp) {\n\t\tconst struct img_ir_decoder *dec = *decp;\n\t\tif (img_ir_decoder_compatible(priv, dec))\n\t\t\tprotos |= dec->type;\n\t}\n\treturn protos;\n}\n\n \nstatic int img_ir_change_protocol(struct rc_dev *dev, u64 *ir_type)\n{\n\tstruct img_ir_priv *priv = dev->priv;\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tstruct rc_dev *rdev = hw->rdev;\n\tstruct img_ir_decoder **decp;\n\tu64 wakeup_protocols;\n\n\tif (!*ir_type) {\n\t\t \n\t\timg_ir_set_decoder(priv, NULL, 0);\n\t\tgoto success;\n\t}\n\tfor (decp = img_ir_decoders; *decp; ++decp) {\n\t\tconst struct img_ir_decoder *dec = *decp;\n\t\tif (!img_ir_decoder_compatible(priv, dec))\n\t\t\tcontinue;\n\t\tif (*ir_type & dec->type) {\n\t\t\t*ir_type &= dec->type;\n\t\t\timg_ir_set_decoder(priv, dec, *ir_type);\n\t\t\tgoto success;\n\t\t}\n\t}\n\treturn -EINVAL;\n\nsuccess:\n\t \n\twakeup_protocols = *ir_type;\n\tif (!hw->decoder || !hw->decoder->filter)\n\t\twakeup_protocols = 0;\n\trdev->allowed_wakeup_protocols = wakeup_protocols;\n\treturn 0;\n}\n\n \nstatic void img_ir_set_protocol(struct img_ir_priv *priv, u64 proto)\n{\n\tstruct rc_dev *rdev = priv->hw.rdev;\n\n\tmutex_lock(&rdev->lock);\n\trdev->enabled_protocols = proto;\n\trdev->allowed_wakeup_protocols = proto;\n\tmutex_unlock(&rdev->lock);\n}\n\n \nstatic void img_ir_init_decoders(void)\n{\n\tstruct img_ir_decoder **decp;\n\n\tspin_lock(&img_ir_decoders_lock);\n\tif (!img_ir_decoders_preprocessed) {\n\t\tfor (decp = img_ir_decoders; *decp; ++decp)\n\t\t\timg_ir_decoder_preprocess(*decp);\n\t\timg_ir_decoders_preprocessed = true;\n\t}\n\tspin_unlock(&img_ir_decoders_lock);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int img_ir_enable_wake(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tint ret = 0;\n\n\tspin_lock_irq(&priv->lock);\n\tif (hw->flags & IMG_IR_F_WAKE) {\n\t\t \n\t\thw->suspend_irqen = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\t\timg_ir_write(priv, IMG_IR_IRQ_ENABLE, IMG_IR_IRQ_DATA_MATCH);\n\t\timg_ir_write_filter(priv, &hw->filters[RC_FILTER_WAKEUP]);\n\t\timg_ir_write_timings(priv, &hw->reg_timings.timings,\n\t\t\t\t     RC_FILTER_WAKEUP);\n\t\thw->mode = IMG_IR_M_WAKE;\n\t\tret = 1;\n\t}\n\tspin_unlock_irq(&priv->lock);\n\treturn ret;\n}\n\n \nstatic int img_ir_disable_wake(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tint ret = 0;\n\n\tspin_lock_irq(&priv->lock);\n\tif (hw->flags & IMG_IR_F_WAKE) {\n\t\t \n\t\tif (hw->flags & IMG_IR_F_FILTER) {\n\t\t\timg_ir_write(priv, IMG_IR_IRQ_ENABLE,\n\t\t\t\t     (hw->suspend_irqen & IMG_IR_IRQ_EDGE) |\n\t\t\t\t     IMG_IR_IRQ_DATA_MATCH);\n\t\t\timg_ir_write_filter(priv,\n\t\t\t\t\t    &hw->filters[RC_FILTER_NORMAL]);\n\t\t} else {\n\t\t\timg_ir_write(priv, IMG_IR_IRQ_ENABLE,\n\t\t\t\t     (hw->suspend_irqen & IMG_IR_IRQ_EDGE) |\n\t\t\t\t     IMG_IR_IRQ_DATA_VALID |\n\t\t\t\t     IMG_IR_IRQ_DATA2_VALID);\n\t\t\timg_ir_write_filter(priv, NULL);\n\t\t}\n\t\timg_ir_write_timings(priv, &hw->reg_timings.timings,\n\t\t\t\t     RC_FILTER_NORMAL);\n\t\thw->mode = IMG_IR_M_NORMAL;\n\t\tret = 1;\n\t}\n\tspin_unlock_irq(&priv->lock);\n\treturn ret;\n}\n#endif  \n\n \nstatic void img_ir_begin_repeat(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tif (hw->mode == IMG_IR_M_NORMAL) {\n\t\t \n\t\timg_ir_write(priv, IMG_IR_CONTROL, 0);\n\t\thw->mode = IMG_IR_M_REPEATING;\n\t\timg_ir_write_timings(priv, &hw->reg_timings.rtimings,\n\t\t\t\t     RC_FILTER_NORMAL);\n\t\timg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\n\t}\n}\n\n \nstatic void img_ir_end_repeat(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tif (hw->mode == IMG_IR_M_REPEATING) {\n\t\t \n\t\timg_ir_write(priv, IMG_IR_CONTROL, 0);\n\t\thw->mode = IMG_IR_M_NORMAL;\n\t\timg_ir_write_timings(priv, &hw->reg_timings.timings,\n\t\t\t\t     RC_FILTER_NORMAL);\n\t\timg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\n\t}\n}\n\n \nstatic void img_ir_handle_data(struct img_ir_priv *priv, u32 len, u64 raw)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tconst struct img_ir_decoder *dec = hw->decoder;\n\tint ret = IMG_IR_SCANCODE;\n\tstruct img_ir_scancode_req request;\n\n\trequest.protocol = RC_PROTO_UNKNOWN;\n\trequest.toggle   = 0;\n\n\tif (dec->scancode)\n\t\tret = dec->scancode(len, raw, hw->enabled_protocols, &request);\n\telse if (len >= 32)\n\t\trequest.scancode = (u32)raw;\n\telse if (len < 32)\n\t\trequest.scancode = (u32)raw & ((1 << len)-1);\n\tdev_dbg(priv->dev, \"data (%u bits) = %#llx\\n\",\n\t\tlen, (unsigned long long)raw);\n\tif (ret == IMG_IR_SCANCODE) {\n\t\tdev_dbg(priv->dev, \"decoded scan code %#x, toggle %u\\n\",\n\t\t\trequest.scancode, request.toggle);\n\t\trc_keydown(hw->rdev, request.protocol, request.scancode,\n\t\t\t   request.toggle);\n\t\timg_ir_end_repeat(priv);\n\t} else if (ret == IMG_IR_REPEATCODE) {\n\t\tif (hw->mode == IMG_IR_M_REPEATING) {\n\t\t\tdev_dbg(priv->dev, \"decoded repeat code\\n\");\n\t\t\trc_repeat(hw->rdev);\n\t\t} else {\n\t\t\tdev_dbg(priv->dev, \"decoded unexpected repeat code, ignoring\\n\");\n\t\t}\n\t} else {\n\t\tdev_dbg(priv->dev, \"decode failed (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\n\t \n\tif (dec->repeat && !hw->stopping) {\n\t\tunsigned long interval;\n\n\t\timg_ir_begin_repeat(priv);\n\n\t\t \n\t\tinterval = dec->repeat + (dec->repeat >> 3);\n\t\tmod_timer(&hw->end_timer,\n\t\t\t  jiffies + msecs_to_jiffies(interval));\n\t}\n}\n\n \nstatic void img_ir_end_timer(struct timer_list *t)\n{\n\tstruct img_ir_priv *priv = from_timer(priv, t, hw.end_timer);\n\n\tspin_lock_irq(&priv->lock);\n\timg_ir_end_repeat(priv);\n\tspin_unlock_irq(&priv->lock);\n}\n\n \nstatic void img_ir_suspend_timer(struct timer_list *t)\n{\n\tstruct img_ir_priv *priv = from_timer(priv, t, hw.suspend_timer);\n\n\tspin_lock_irq(&priv->lock);\n\t \n\tif ((priv->hw.quirk_suspend_irq & IMG_IR_IRQ_EDGE) ==\n\t\t\t\timg_ir_read(priv, IMG_IR_IRQ_ENABLE))\n\t\timg_ir_write(priv, IMG_IR_IRQ_ENABLE,\n\t\t\t\t\tpriv->hw.quirk_suspend_irq);\n\t \n\timg_ir_write(priv, IMG_IR_CONTROL, priv->hw.reg_timings.ctrl);\n\tspin_unlock_irq(&priv->lock);\n}\n\n#ifdef CONFIG_COMMON_CLK\nstatic void img_ir_change_frequency(struct img_ir_priv *priv,\n\t\t\t\t    struct clk_notifier_data *change)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\n\tdev_dbg(priv->dev, \"clk changed %lu HZ -> %lu HZ\\n\",\n\t\tchange->old_rate, change->new_rate);\n\n\tspin_lock_irq(&priv->lock);\n\tif (hw->clk_hz == change->new_rate)\n\t\tgoto unlock;\n\thw->clk_hz = change->new_rate;\n\t \n\tif (hw->decoder) {\n\t\timg_ir_decoder_convert(hw->decoder, &hw->reg_timings,\n\t\t\t\t       hw->clk_hz);\n\t\tswitch (hw->mode) {\n\t\tcase IMG_IR_M_NORMAL:\n\t\t\timg_ir_write_timings(priv, &hw->reg_timings.timings,\n\t\t\t\t\t     RC_FILTER_NORMAL);\n\t\t\tbreak;\n\t\tcase IMG_IR_M_REPEATING:\n\t\t\timg_ir_write_timings(priv, &hw->reg_timings.rtimings,\n\t\t\t\t\t     RC_FILTER_NORMAL);\n\t\t\tbreak;\n#ifdef CONFIG_PM_SLEEP\n\t\tcase IMG_IR_M_WAKE:\n\t\t\timg_ir_write_timings(priv, &hw->reg_timings.timings,\n\t\t\t\t\t     RC_FILTER_WAKEUP);\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\nunlock:\n\tspin_unlock_irq(&priv->lock);\n}\n\nstatic int img_ir_clk_notify(struct notifier_block *self, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct img_ir_priv *priv = container_of(self, struct img_ir_priv,\n\t\t\t\t\t\thw.clk_nb);\n\tswitch (action) {\n\tcase POST_RATE_CHANGE:\n\t\timg_ir_change_frequency(priv, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n#endif  \n\n \nvoid img_ir_isr_hw(struct img_ir_priv *priv, u32 irq_status)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tu32 ir_status, len, lw, up;\n\tunsigned int ct;\n\n\t \n\tif (!hw->decoder)\n\t\treturn;\n\n\tct = hw->decoder->control.code_type;\n\n\tir_status = img_ir_read(priv, IMG_IR_STATUS);\n\tif (!(ir_status & (IMG_IR_RXDVAL | IMG_IR_RXDVALD2))) {\n\t\tif (!(priv->hw.ct_quirks[ct] & IMG_IR_QUIRK_CODE_IRQ) ||\n\t\t\t\thw->stopping)\n\t\t\treturn;\n\t\t \n\t\timg_ir_write(priv, IMG_IR_CONTROL, 0);\n\t\thw->quirk_suspend_irq = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\n\t\timg_ir_write(priv, IMG_IR_IRQ_ENABLE,\n\t\t\t     hw->quirk_suspend_irq & IMG_IR_IRQ_EDGE);\n\n\t\t \n\t\tmod_timer(&hw->suspend_timer,\n\t\t\t  jiffies + msecs_to_jiffies(5));\n\t\treturn;\n\t}\n\tir_status &= ~(IMG_IR_RXDVAL | IMG_IR_RXDVALD2);\n\timg_ir_write(priv, IMG_IR_STATUS, ir_status);\n\n\tlen = (ir_status & IMG_IR_RXDLEN) >> IMG_IR_RXDLEN_SHIFT;\n\t \n\tif (hw->ct_quirks[ct] & IMG_IR_QUIRK_CODE_LEN_INCR)\n\t\t++len;\n\n\tlw = img_ir_read(priv, IMG_IR_DATA_LW);\n\tup = img_ir_read(priv, IMG_IR_DATA_UP);\n\timg_ir_handle_data(priv, len, (u64)up << 32 | lw);\n}\n\nvoid img_ir_setup_hw(struct img_ir_priv *priv)\n{\n\tstruct img_ir_decoder **decp;\n\n\tif (!priv->hw.rdev)\n\t\treturn;\n\n\t \n\tfor (decp = img_ir_decoders; *decp; ++decp) {\n\t\tconst struct img_ir_decoder *dec = *decp;\n\t\tif (img_ir_decoder_compatible(priv, dec)) {\n\t\t\timg_ir_set_protocol(priv, dec->type);\n\t\t\timg_ir_set_decoder(priv, dec, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\timg_ir_set_decoder(priv, NULL, 0);\n}\n\n \nstatic void img_ir_probe_hw_caps(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\t \n\thw->ct_quirks[IMG_IR_CODETYPE_PULSELEN]\n\t\t|= IMG_IR_QUIRK_CODE_LEN_INCR;\n\thw->ct_quirks[IMG_IR_CODETYPE_BIPHASE]\n\t\t|= IMG_IR_QUIRK_CODE_IRQ;\n\thw->ct_quirks[IMG_IR_CODETYPE_2BITPULSEPOS]\n\t\t|= IMG_IR_QUIRK_CODE_BROKEN;\n}\n\nint img_ir_probe_hw(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tstruct rc_dev *rdev;\n\tint error;\n\n\t \n\timg_ir_init_decoders();\n\n\t \n\timg_ir_probe_hw_caps(priv);\n\n\t \n\ttimer_setup(&hw->end_timer, img_ir_end_timer, 0);\n\ttimer_setup(&hw->suspend_timer, img_ir_suspend_timer, 0);\n\n\t \n\tif (!IS_ERR(priv->clk)) {\n\t\thw->clk_hz = clk_get_rate(priv->clk);\n#ifdef CONFIG_COMMON_CLK\n\t\thw->clk_nb.notifier_call = img_ir_clk_notify;\n\t\terror = clk_notifier_register(priv->clk, &hw->clk_nb);\n\t\tif (error)\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"failed to register clock notifier\\n\");\n#endif\n\t} else {\n\t\thw->clk_hz = 32768;\n\t}\n\n\t \n\thw->rdev = rdev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!rdev) {\n\t\tdev_err(priv->dev, \"cannot allocate input device\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_alloc_rc;\n\t}\n\trdev->priv = priv;\n\trdev->map_name = RC_MAP_EMPTY;\n\trdev->allowed_protocols = img_ir_allowed_protos(priv);\n\trdev->device_name = \"IMG Infrared Decoder\";\n\trdev->s_filter = img_ir_set_normal_filter;\n\trdev->s_wakeup_filter = img_ir_set_wakeup_filter;\n\n\t \n\terror = rc_register_device(rdev);\n\tif (error) {\n\t\tdev_err(priv->dev, \"failed to register IR input device\\n\");\n\t\tgoto err_register_rc;\n\t}\n\n\t \n\trdev->change_protocol = img_ir_change_protocol;\n\n\tdevice_init_wakeup(priv->dev, 1);\n\n\treturn 0;\n\nerr_register_rc:\n\timg_ir_set_decoder(priv, NULL, 0);\n\thw->rdev = NULL;\n\trc_free_device(rdev);\nerr_alloc_rc:\n#ifdef CONFIG_COMMON_CLK\n\tif (!IS_ERR(priv->clk))\n\t\tclk_notifier_unregister(priv->clk, &hw->clk_nb);\n#endif\n\treturn error;\n}\n\nvoid img_ir_remove_hw(struct img_ir_priv *priv)\n{\n\tstruct img_ir_priv_hw *hw = &priv->hw;\n\tstruct rc_dev *rdev = hw->rdev;\n\tif (!rdev)\n\t\treturn;\n\timg_ir_set_decoder(priv, NULL, 0);\n\thw->rdev = NULL;\n\trc_unregister_device(rdev);\n#ifdef CONFIG_COMMON_CLK\n\tif (!IS_ERR(priv->clk))\n\t\tclk_notifier_unregister(priv->clk, &hw->clk_nb);\n#endif\n}\n\n#ifdef CONFIG_PM_SLEEP\nint img_ir_suspend(struct device *dev)\n{\n\tstruct img_ir_priv *priv = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev) && img_ir_enable_wake(priv))\n\t\tenable_irq_wake(priv->irq);\n\treturn 0;\n}\n\nint img_ir_resume(struct device *dev)\n{\n\tstruct img_ir_priv *priv = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev) && img_ir_disable_wake(priv))\n\t\tdisable_irq_wake(priv->irq);\n\treturn 0;\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}