{
  "module_name": "imon_raw.c",
  "hash_id": "5dc2445078cf42f573dc15fde4cf6cf7a7b6f5a29c63f8f9491553024c3d0e66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/imon_raw.c",
  "human_readable_source": "\n\n\n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n \n#define BIT_DURATION 250\n\nstruct imon {\n\tstruct device *dev;\n\tstruct urb *ir_urb;\n\tstruct rc_dev *rcdev;\n\t__be64 *ir_buf;\n\tchar phys[64];\n};\n\n \nstatic void imon_ir_data(struct imon *imon)\n{\n\tstruct ir_raw_event rawir = {};\n\tu64 data = be64_to_cpup(imon->ir_buf);\n\tu8 packet_no = data & 0xff;\n\tint offset = 40;\n\tint bit;\n\n\tif (packet_no == 0xff)\n\t\treturn;\n\n\tdev_dbg(imon->dev, \"data: %*ph\", 8, imon->ir_buf);\n\n\t \n\tdata >>= 24;\n\n\tdo {\n\t\t \n\t\trawir.pulse = !rawir.pulse;\n\t\tbit = fls64(data & (BIT_ULL(offset) - 1));\n\t\tif (bit < offset) {\n\t\t\tdev_dbg(imon->dev, \"%s: %d bits\",\n\t\t\t\trawir.pulse ? \"pulse\" : \"space\", offset - bit);\n\t\t\trawir.duration = (offset - bit) * BIT_DURATION;\n\t\t\tir_raw_event_store_with_filter(imon->rcdev, &rawir);\n\n\t\t\toffset = bit;\n\t\t}\n\n\t\tdata = ~data;\n\t} while (offset > 0);\n\n\tif (packet_no == 0x0a && !imon->rcdev->idle) {\n\t\tir_raw_event_set_idle(imon->rcdev, true);\n\t\tir_raw_event_handle(imon->rcdev);\n\t}\n}\n\nstatic void imon_ir_rx(struct urb *urb)\n{\n\tstruct imon *imon = urb->context;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\timon_ir_data(imon);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\tcase -EPIPE:\n\tdefault:\n\t\tdev_dbg(imon->dev, \"error: urb status = %d\", urb->status);\n\t\tbreak;\n\t}\n\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret && ret != -ENODEV)\n\t\tdev_warn(imon->dev, \"failed to resubmit urb: %d\", ret);\n}\n\nstatic int imon_probe(struct usb_interface *intf,\n\t\t      const struct usb_device_id *id)\n{\n\tstruct usb_endpoint_descriptor *ir_ep = NULL;\n\tstruct usb_host_interface *idesc;\n\tstruct usb_device *udev;\n\tstruct rc_dev *rcdev;\n\tstruct imon *imon;\n\tint i, ret;\n\n\tudev = interface_to_usbdev(intf);\n\tidesc = intf->cur_altsetting;\n\n\tfor (i = 0; i < idesc->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep = &idesc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(ep)) {\n\t\t\tir_ep = ep;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ir_ep) {\n\t\tdev_err(&intf->dev, \"IR endpoint missing\");\n\t\treturn -ENODEV;\n\t}\n\n\timon = devm_kmalloc(&intf->dev, sizeof(*imon), GFP_KERNEL);\n\tif (!imon)\n\t\treturn -ENOMEM;\n\n\timon->ir_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!imon->ir_urb)\n\t\treturn -ENOMEM;\n\n\timon->ir_buf = kmalloc(sizeof(__be64), GFP_KERNEL);\n\tif (!imon->ir_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_urb;\n\t}\n\n\timon->dev = &intf->dev;\n\tusb_fill_int_urb(imon->ir_urb, udev,\n\t\t\t usb_rcvintpipe(udev, ir_ep->bEndpointAddress),\n\t\t\t imon->ir_buf, sizeof(__be64),\n\t\t\t imon_ir_rx, imon, ir_ep->bInterval);\n\n\trcdev = devm_rc_allocate_device(&intf->dev, RC_DRIVER_IR_RAW);\n\tif (!rcdev) {\n\t\tret = -ENOMEM;\n\t\tgoto free_urb;\n\t}\n\n\tusb_make_path(udev, imon->phys, sizeof(imon->phys));\n\n\trcdev->device_name = \"iMON Station\";\n\trcdev->driver_name = KBUILD_MODNAME;\n\trcdev->input_phys = imon->phys;\n\tusb_to_input_id(udev, &rcdev->input_id);\n\trcdev->dev.parent = &intf->dev;\n\trcdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trcdev->map_name = RC_MAP_IMON_RSC;\n\trcdev->rx_resolution = BIT_DURATION;\n\trcdev->priv = imon;\n\n\tret = devm_rc_register_device(&intf->dev, rcdev);\n\tif (ret)\n\t\tgoto free_urb;\n\n\timon->rcdev = rcdev;\n\n\tret = usb_submit_urb(imon->ir_urb, GFP_KERNEL);\n\tif (ret)\n\t\tgoto free_urb;\n\n\tusb_set_intfdata(intf, imon);\n\n\treturn 0;\n\nfree_urb:\n\tusb_free_urb(imon->ir_urb);\n\tkfree(imon->ir_buf);\n\treturn ret;\n}\n\nstatic void imon_disconnect(struct usb_interface *intf)\n{\n\tstruct imon *imon = usb_get_intfdata(intf);\n\n\tusb_kill_urb(imon->ir_urb);\n\tusb_free_urb(imon->ir_urb);\n\tkfree(imon->ir_buf);\n}\n\nstatic const struct usb_device_id imon_table[] = {\n\t \n\t{ USB_DEVICE(0x04e8, 0xff30) },\n\t{}\n};\n\nstatic struct usb_driver imon_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = imon_probe,\n\t.disconnect = imon_disconnect,\n\t.id_table = imon_table\n};\n\nmodule_usb_driver(imon_driver);\n\nMODULE_DESCRIPTION(\"Early raw iMON IR devices\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, imon_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}