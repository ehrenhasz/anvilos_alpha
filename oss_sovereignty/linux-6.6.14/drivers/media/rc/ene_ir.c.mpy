{
  "module_name": "ene_ir.c",
  "hash_id": "205cc096836454c7593e8f52872aa4c5eea1e904f26556cb115917e1e2224aa7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ene_ir.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n#include \"ene_ir.h\"\n\nstatic int sample_period;\nstatic bool learning_mode_force;\nstatic int debug;\nstatic bool txsim;\n\nstatic void ene_set_reg_addr(struct ene_device *dev, u16 reg)\n{\n\toutb(reg >> 8, dev->hw_io + ENE_ADDR_HI);\n\toutb(reg & 0xFF, dev->hw_io + ENE_ADDR_LO);\n}\n\n \nstatic u8 ene_read_reg(struct ene_device *dev, u16 reg)\n{\n\tu8 retval;\n\tene_set_reg_addr(dev, reg);\n\tretval = inb(dev->hw_io + ENE_IO);\n\tdbg_regs(\"reg %04x == %02x\", reg, retval);\n\treturn retval;\n}\n\n \nstatic void ene_write_reg(struct ene_device *dev, u16 reg, u8 value)\n{\n\tdbg_regs(\"reg %04x <- %02x\", reg, value);\n\tene_set_reg_addr(dev, reg);\n\toutb(value, dev->hw_io + ENE_IO);\n}\n\n \nstatic void ene_set_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x |= %02x\", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) | mask, dev->hw_io + ENE_IO);\n}\n\n \nstatic void ene_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x &= ~%02x \", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) & ~mask, dev->hw_io + ENE_IO);\n}\n\n \nstatic void ene_set_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask,\n\t\t\t\t\t\t\t\tbool set)\n{\n\tif (set)\n\t\tene_set_reg_mask(dev, reg, mask);\n\telse\n\t\tene_clear_reg_mask(dev, reg, mask);\n}\n\n \nstatic int ene_hw_detect(struct ene_device *dev)\n{\n\tu8 chip_major, chip_minor;\n\tu8 hw_revision, old_ver;\n\tu8 fw_reg2, fw_reg1;\n\n\tene_clear_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\tchip_major = ene_read_reg(dev, ENE_ECVER_MAJOR);\n\tchip_minor = ene_read_reg(dev, ENE_ECVER_MINOR);\n\tene_set_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\n\thw_revision = ene_read_reg(dev, ENE_ECHV);\n\told_ver = ene_read_reg(dev, ENE_HW_VER_OLD);\n\n\tdev->pll_freq = (ene_read_reg(dev, ENE_PLLFRH) << 4) +\n\t\t(ene_read_reg(dev, ENE_PLLFRL) >> 4);\n\n\tif (sample_period != ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tdev->rx_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 2 : 4;\n\n\tif (hw_revision == 0xFF) {\n\t\tpr_warn(\"device seems to be disabled\\n\");\n\t\tpr_warn(\"send a mail to lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_warn(\"please attach output of acpidump and dmidecode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_notice(\"chip is 0x%02x%02x - kbver = 0x%02x, rev = 0x%02x\\n\",\n\t\t  chip_major, chip_minor, old_ver, hw_revision);\n\n\tpr_notice(\"PLL freq = %d\\n\", dev->pll_freq);\n\n\tif (chip_major == 0x33) {\n\t\tpr_warn(\"chips 0x33xx aren't supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip_major == 0x39 && chip_minor == 0x26 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_C;\n\t\tpr_notice(\"KB3926C detected\\n\");\n\t} else if (old_ver == 0x24 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_B;\n\t\tpr_notice(\"KB3926B detected\\n\");\n\t} else {\n\t\tdev->hw_revision = ENE_HW_D;\n\t\tpr_notice(\"KB3926D or higher detected\\n\");\n\t}\n\n\t \n\tif (dev->hw_revision < ENE_HW_C)\n\t\treturn 0;\n\n\tfw_reg1 = ene_read_reg(dev, ENE_FW1);\n\tfw_reg2 = ene_read_reg(dev, ENE_FW2);\n\n\tpr_notice(\"Firmware regs: %02x %02x\\n\", fw_reg1, fw_reg2);\n\n\tdev->hw_use_gpio_0a = !!(fw_reg2 & ENE_FW2_GP0A);\n\tdev->hw_learning_and_tx_capable = !!(fw_reg2 & ENE_FW2_LEARNING);\n\tdev->hw_extra_buffer = !!(fw_reg1 & ENE_FW1_HAS_EXTRA_BUF);\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->hw_fan_input = !!(fw_reg2 & ENE_FW2_FAN_INPUT);\n\n\tpr_notice(\"Hardware features:\\n\");\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tpr_notice(\"* Supports transmitting & learning mode\\n\");\n\t\tpr_notice(\"   This feature is rare and therefore,\\n\");\n\t\tpr_notice(\"   you are welcome to test it,\\n\");\n\t\tpr_notice(\"   and/or contact the author via:\\n\");\n\t\tpr_notice(\"   lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_notice(\"   or maximlevitsky@gmail.com\\n\");\n\n\t\tpr_notice(\"* Uses GPIO %s for IR raw input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"40\" : \"0A\");\n\n\t\tif (dev->hw_fan_input)\n\t\t\tpr_notice(\"* Uses unused fan feedback input as source of demodulated IR data\\n\");\n\t}\n\n\tif (!dev->hw_fan_input)\n\t\tpr_notice(\"* Uses GPIO %s for IR demodulated input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"0A\" : \"40\");\n\n\tif (dev->hw_extra_buffer)\n\t\tpr_notice(\"* Uses new style input buffer\\n\");\n\treturn 0;\n}\n\n \nstatic void ene_rx_setup_hw_buffer(struct ene_device *dev)\n{\n\tu16 tmp;\n\n\tene_rx_read_hw_pointer(dev);\n\tdev->r_pointer = dev->w_pointer;\n\n\tif (!dev->hw_extra_buffer) {\n\t\tdev->buffer_len = ENE_FW_PACKET_SIZE * 2;\n\t\treturn;\n\t}\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER+1) << 8;\n\tdev->extra_buf1_address = tmp;\n\n\tdev->extra_buf1_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 2);\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 3);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 4) << 8;\n\tdev->extra_buf2_address = tmp;\n\n\tdev->extra_buf2_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 5);\n\n\tdev->buffer_len = dev->extra_buf1_len + dev->extra_buf2_len + 8;\n\n\tpr_notice(\"Hardware uses 2 extended buffers:\\n\");\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf1_address, dev->extra_buf1_len);\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf2_address, dev->extra_buf2_len);\n\n\tpr_notice(\"Total buffer len = %d\\n\", dev->buffer_len);\n\n\tif (dev->buffer_len > 64 || dev->buffer_len < 16)\n\t\tgoto error;\n\n\tif (dev->extra_buf1_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf1_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->extra_buf2_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf2_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->r_pointer > dev->buffer_len)\n\t\tgoto error;\n\n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n\treturn;\nerror:\n\tpr_warn(\"Error validating extra buffers, device probably won't work\\n\");\n\tdev->hw_extra_buffer = false;\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n\n \nstatic void ene_rx_restore_hw_buffer(struct ene_device *dev)\n{\n\tif (!dev->hw_extra_buffer)\n\t\treturn;\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 0,\n\t\t\t\tdev->extra_buf1_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 1,\n\t\t\t\tdev->extra_buf1_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 2, dev->extra_buf1_len);\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 3,\n\t\t\t\tdev->extra_buf2_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 4,\n\t\t\t\tdev->extra_buf2_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 5,\n\t\t\t\tdev->extra_buf2_len);\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n \nstatic void ene_rx_read_hw_pointer(struct ene_device *dev)\n{\n\tif (dev->hw_extra_buffer)\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW_RX_POINTER);\n\telse\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW2)\n\t\t\t& ENE_FW2_BUF_WPTR ? 0 : ENE_FW_PACKET_SIZE;\n\n\tdbg_verbose(\"RB: HW write pointer: %02x, driver read pointer: %02x\",\n\t\tdev->w_pointer, dev->r_pointer);\n}\n\n \nstatic int ene_rx_get_sample_reg(struct ene_device *dev)\n{\n\tint r_pointer;\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: hit end, try update w_pointer\");\n\t\tene_rx_read_hw_pointer(dev);\n\t}\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: end of data at %d\", dev->r_pointer);\n\t\treturn 0;\n\t}\n\n\tdbg_verbose(\"RB: reading at offset %d\", dev->r_pointer);\n\tr_pointer = dev->r_pointer;\n\n\tdev->r_pointer++;\n\tif (dev->r_pointer == dev->buffer_len)\n\t\tdev->r_pointer = 0;\n\n\tdbg_verbose(\"RB: next read will be from offset %d\", dev->r_pointer);\n\n\tif (r_pointer < 8) {\n\t\tdbg_verbose(\"RB: read at main buffer at %d\", r_pointer);\n\t\treturn ENE_FW_SAMPLE_BUFFER + r_pointer;\n\t}\n\n\tr_pointer -= 8;\n\n\tif (r_pointer < dev->extra_buf1_len) {\n\t\tdbg_verbose(\"RB: read at 1st extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf1_address + r_pointer;\n\t}\n\n\tr_pointer -= dev->extra_buf1_len;\n\n\tif (r_pointer < dev->extra_buf2_len) {\n\t\tdbg_verbose(\"RB: read at 2nd extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf2_address + r_pointer;\n\t}\n\n\tdbg(\"attempt to read beyond ring buffer end\");\n\treturn 0;\n}\n\n \nstatic void ene_rx_sense_carrier(struct ene_device *dev)\n{\n\tint carrier, duty_cycle;\n\tint period = ene_read_reg(dev, ENE_CIRCAR_PRD);\n\tint hperiod = ene_read_reg(dev, ENE_CIRCAR_HPRD);\n\n\tif (!(period & ENE_CIRCAR_PRD_VALID))\n\t\treturn;\n\n\tperiod &= ~ENE_CIRCAR_PRD_VALID;\n\n\tif (!period)\n\t\treturn;\n\n\tdbg(\"RX: hardware carrier period = %02x\", period);\n\tdbg(\"RX: hardware carrier pulse period = %02x\", hperiod);\n\n\tcarrier = 2000000 / period;\n\tduty_cycle = (hperiod * 100) / period;\n\tdbg(\"RX: sensed carrier = %d Hz, duty cycle %d%%\",\n\t\t\t\t\t\tcarrier, duty_cycle);\n\tif (dev->carrier_detect_enabled) {\n\t\tstruct ir_raw_event ev = {\n\t\t\t.carrier_report = true,\n\t\t\t.carrier = carrier,\n\t\t\t.duty_cycle = duty_cycle\n\t\t};\n\t\tir_raw_event_store(dev->rdev, &ev);\n\t}\n}\n\n \nstatic void ene_rx_enable_cir_engine(struct ene_device *dev, bool enable)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\t\tENE_CIRCFG_RX_EN | ENE_CIRCFG_RX_IRQ, enable);\n}\n\n \nstatic void ene_rx_select_input(struct ene_device *dev, bool gpio_0a)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_GPIO0A, gpio_0a);\n}\n\n \nstatic void ene_rx_enable_fan_input(struct ene_device *dev, bool enable)\n{\n\tif (!dev->hw_fan_input)\n\t\treturn;\n\n\tif (!enable)\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, 0);\n\telse {\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, ENE_FAN_AS_IN1_EN);\n\t\tene_write_reg(dev, ENE_FAN_AS_IN2, ENE_FAN_AS_IN2_EN);\n\t}\n}\n\n \nstatic void ene_rx_setup(struct ene_device *dev)\n{\n\tbool learning_mode = dev->learning_mode_enabled ||\n\t\t\t\t\tdev->carrier_detect_enabled;\n\tint sample_period_adjust = 0;\n\n\tdbg(\"RX: setup receiver, learning mode = %d\", learning_mode);\n\n\n\t \n\tene_write_reg(dev, ENE_CIRCFG2, 0x00);\n\n\t \n\tif (sample_period == ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tsample_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 1 : 2;\n\n\tene_write_reg(dev, ENE_CIRRLC_CFG,\n\t\t\t(sample_period + sample_period_adjust) |\n\t\t\t\t\t\tENE_CIRRLC_CFG_OVERFLOW);\n\t \n\tif (dev->hw_revision < ENE_HW_C)\n\t\tgoto select_timeout;\n\n\tif (learning_mode) {\n\n\t\tWARN_ON(!dev->hw_learning_and_tx_capable);\n\n\t\t \n\t\tene_rx_select_input(dev, !dev->hw_use_gpio_0a);\n\t\tdev->rx_fan_input_inuse = false;\n\n\t\t \n\t\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\n\t\t \n\t\tene_write_reg(dev, ENE_CIRCAR_PULS, 0x63);\n\t\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT,\n\t\t\tdev->carrier_detect_enabled || debug);\n\t} else {\n\t\tif (dev->hw_fan_input)\n\t\t\tdev->rx_fan_input_inuse = true;\n\t\telse\n\t\t\tene_rx_select_input(dev, dev->hw_use_gpio_0a);\n\n\t\t \n\t\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\t\tene_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT);\n\t}\n\nselect_timeout:\n\tif (dev->rx_fan_input_inuse) {\n\t\tdev->rdev->rx_resolution = ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t \n\t\tdev->rdev->min_timeout = dev->rdev->max_timeout =\n\t\t\tENE_FW_SMPL_BUF_FAN_MSK *\n\t\t\t\tENE_FW_SAMPLE_PERIOD_FAN;\n\t} else {\n\t\tdev->rdev->rx_resolution = sample_period;\n\n\t\t \n\t\tdev->rdev->min_timeout = 127 * sample_period;\n\t\tdev->rdev->max_timeout = 200000;\n\t}\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->rdev->tx_resolution = sample_period;\n\n\tif (dev->rdev->timeout > dev->rdev->max_timeout)\n\t\tdev->rdev->timeout = dev->rdev->max_timeout;\n\tif (dev->rdev->timeout < dev->rdev->min_timeout)\n\t\tdev->rdev->timeout = dev->rdev->min_timeout;\n}\n\n \nstatic void ene_rx_enable_hw(struct ene_device *dev)\n{\n\tu8 reg_value;\n\n\t \n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tene_write_reg(dev, ENEB_IRQ, dev->irq << 1);\n\t\tene_write_reg(dev, ENEB_IRQ_UNK1, 0x01);\n\t} else {\n\t\treg_value = ene_read_reg(dev, ENE_IRQ) & 0xF0;\n\t\treg_value |= ENE_IRQ_UNK_EN;\n\t\treg_value &= ~ENE_IRQ_STATUS;\n\t\treg_value |= (dev->irq & ENE_IRQ_MASK);\n\t\tene_write_reg(dev, ENE_IRQ, reg_value);\n\t}\n\n\t \n\tene_rx_enable_fan_input(dev, dev->rx_fan_input_inuse);\n\tene_rx_enable_cir_engine(dev, !dev->rx_fan_input_inuse);\n\n\t \n\tene_irq_status(dev);\n\n\t \n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\n\t \n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n \nstatic void ene_rx_enable(struct ene_device *dev)\n{\n\tene_rx_enable_hw(dev);\n\tdev->rx_enabled = true;\n}\n\n \nstatic void ene_rx_disable_hw(struct ene_device *dev)\n{\n\t \n\tene_rx_enable_cir_engine(dev, false);\n\tene_rx_enable_fan_input(dev, false);\n\n\t \n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n \nstatic void ene_rx_disable(struct ene_device *dev)\n{\n\tene_rx_disable_hw(dev);\n\tdev->rx_enabled = false;\n}\n\n \nstatic void ene_rx_reset(struct ene_device *dev)\n{\n\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n}\n\n \nstatic void ene_tx_set_carrier(struct ene_device *dev)\n{\n\tu8 tx_puls_width;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\tENE_CIRCFG_TX_CARR, dev->tx_period > 0);\n\n\tif (!dev->tx_period)\n\t\tgoto unlock;\n\n\tBUG_ON(dev->tx_duty_cycle >= 100 || dev->tx_duty_cycle <= 0);\n\n\ttx_puls_width = dev->tx_period / (100 / dev->tx_duty_cycle);\n\n\tif (!tx_puls_width)\n\t\ttx_puls_width = 1;\n\n\tdbg(\"TX: pulse distance = %d * 500 ns\", dev->tx_period);\n\tdbg(\"TX: pulse width = %d * 500 ns\", tx_puls_width);\n\n\tene_write_reg(dev, ENE_CIRMOD_PRD, dev->tx_period | ENE_CIRMOD_PRD_POL);\n\tene_write_reg(dev, ENE_CIRMOD_HPRD, tx_puls_width);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n \nstatic void ene_tx_set_transmitters(struct ene_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS8, ENE_GPIOFS8_GPIO41,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x01));\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS1, ENE_GPIOFS1_GPIO0D,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x02));\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n \nstatic void ene_tx_enable(struct ene_device *dev)\n{\n\tu8 conf1 = ene_read_reg(dev, ENE_CIRCFG);\n\tu8 fwreg2 = ene_read_reg(dev, ENE_FW2);\n\n\tdev->saved_conf1 = conf1;\n\n\t \n\tif (fwreg2 & ENE_FW2_EMMITER1_CONN)\n\t\tdbg(\"TX: Transmitter #1 is connected\");\n\n\tif (fwreg2 & ENE_FW2_EMMITER2_CONN)\n\t\tdbg(\"TX: Transmitter #2 is connected\");\n\n\tif (!(fwreg2 & (ENE_FW2_EMMITER1_CONN | ENE_FW2_EMMITER2_CONN)))\n\t\tpr_warn(\"TX: transmitter cable isn't connected!\\n\");\n\n\t \n\tif (dev->hw_revision == ENE_HW_C)\n\t\tconf1 &= ~ENE_CIRCFG_RX_EN;\n\n\t \n\tconf1 |= ENE_CIRCFG_TX_EN | ENE_CIRCFG_TX_IRQ;\n\tene_write_reg(dev, ENE_CIRCFG, conf1);\n}\n\n \nstatic void ene_tx_disable(struct ene_device *dev)\n{\n\tene_write_reg(dev, ENE_CIRCFG, dev->saved_conf1);\n\tdev->tx_buffer = NULL;\n}\n\n\n \nstatic void ene_tx_sample(struct ene_device *dev)\n{\n\tu8 raw_tx;\n\tu32 sample;\n\tbool pulse = dev->tx_sample_pulse;\n\n\tif (!dev->tx_buffer) {\n\t\tpr_warn(\"TX: BUG: attempt to transmit NULL buffer\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!dev->tx_sample) {\n\n\t\tif (dev->tx_pos == dev->tx_len) {\n\t\t\tif (!dev->tx_done) {\n\t\t\t\tdbg(\"TX: no more data to send\");\n\t\t\t\tdev->tx_done = true;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tdbg(\"TX: last sample sent by hardware\");\n\t\t\t\tene_tx_disable(dev);\n\t\t\t\tcomplete(&dev->tx_complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsample = dev->tx_buffer[dev->tx_pos++];\n\t\tdev->tx_sample_pulse = !dev->tx_sample_pulse;\n\n\t\tdev->tx_sample = DIV_ROUND_CLOSEST(sample, sample_period);\n\n\t\tif (!dev->tx_sample)\n\t\t\tdev->tx_sample = 1;\n\t}\n\n\traw_tx = min(dev->tx_sample , (unsigned int)ENE_CIRRLC_OUT_MASK);\n\tdev->tx_sample -= raw_tx;\n\n\tdbg(\"TX: sample %8d (%s)\", raw_tx * sample_period,\n\t\t\t\t\t\tpulse ? \"pulse\" : \"space\");\n\tif (pulse)\n\t\traw_tx |= ENE_CIRRLC_OUT_PULSE;\n\n\tene_write_reg(dev,\n\t\tdev->tx_reg ? ENE_CIRRLC_OUT1 : ENE_CIRRLC_OUT0, raw_tx);\n\n\tdev->tx_reg = !dev->tx_reg;\nexit:\n\t \n\tif (txsim)\n\t\tmod_timer(&dev->tx_sim_timer, jiffies + HZ / 500);\n}\n\n \nstatic void ene_tx_irqsim(struct timer_list *t)\n{\n\tstruct ene_device *dev = from_timer(dev, t, tx_sim_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_tx_sample(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n\n \nstatic int ene_irq_status(struct ene_device *dev)\n{\n\tu8 irq_status;\n\tu8 fw_flags1, fw_flags2;\n\tint retval = 0;\n\n\tfw_flags2 = ene_read_reg(dev, ENE_FW2);\n\n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tirq_status = ene_read_reg(dev, ENEB_IRQ_STATUS);\n\n\t\tif (!(irq_status & ENEB_IRQ_STATUS_IR))\n\t\t\treturn 0;\n\n\t\tene_clear_reg_mask(dev, ENEB_IRQ_STATUS, ENEB_IRQ_STATUS_IR);\n\t\treturn ENE_IRQ_RX;\n\t}\n\n\tirq_status = ene_read_reg(dev, ENE_IRQ);\n\tif (!(irq_status & ENE_IRQ_STATUS))\n\t\treturn 0;\n\n\t \n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\n\t \n\tif (fw_flags2 & ENE_FW2_RXIRQ) {\n\t\tretval |= ENE_IRQ_RX;\n\t\tene_write_reg(dev, ENE_FW2, fw_flags2 & ~ENE_FW2_RXIRQ);\n\t}\n\n\t \n\tfw_flags1 = ene_read_reg(dev, ENE_FW1);\n\tif (fw_flags1 & ENE_FW1_TXIRQ) {\n\t\tene_write_reg(dev, ENE_FW1, fw_flags1 & ~ENE_FW1_TXIRQ);\n\t\tretval |= ENE_IRQ_TX;\n\t}\n\n\treturn retval;\n}\n\n \nstatic irqreturn_t ene_isr(int irq, void *data)\n{\n\tu16 hw_value, reg;\n\tint hw_sample, irq_status;\n\tbool pulse;\n\tunsigned long flags;\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct ene_device *dev = (struct ene_device *)data;\n\tstruct ir_raw_event ev = {};\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tdbg_verbose(\"ISR called\");\n\tene_rx_read_hw_pointer(dev);\n\tirq_status = ene_irq_status(dev);\n\n\tif (!irq_status)\n\t\tgoto unlock;\n\n\tretval = IRQ_HANDLED;\n\n\tif (irq_status & ENE_IRQ_TX) {\n\t\tdbg_verbose(\"TX interrupt\");\n\t\tif (!dev->hw_learning_and_tx_capable) {\n\t\t\tdbg(\"TX interrupt on unsupported device!\");\n\t\t\tgoto unlock;\n\t\t}\n\t\tene_tx_sample(dev);\n\t}\n\n\tif (!(irq_status & ENE_IRQ_RX))\n\t\tgoto unlock;\n\n\tdbg_verbose(\"RX interrupt\");\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tene_rx_sense_carrier(dev);\n\n\t \n\tif (!dev->hw_extra_buffer)\n\t\tdev->r_pointer = dev->w_pointer == 0 ? ENE_FW_PACKET_SIZE : 0;\n\n\twhile (1) {\n\n\t\treg = ene_rx_get_sample_reg(dev);\n\n\t\tdbg_verbose(\"next sample to read at: %04x\", reg);\n\t\tif (!reg)\n\t\t\tbreak;\n\n\t\thw_value = ene_read_reg(dev, reg);\n\n\t\tif (dev->rx_fan_input_inuse) {\n\n\t\t\tint offset = ENE_FW_SMPL_BUF_FAN - ENE_FW_SAMPLE_BUFFER;\n\n\t\t\t \n\t\t\thw_value |= ene_read_reg(dev, reg + offset) << 8;\n\t\t\tpulse = hw_value & ENE_FW_SMPL_BUF_FAN_PLS;\n\n\t\t\t \n\t\t\thw_value &= ENE_FW_SMPL_BUF_FAN_MSK;\n\t\t\thw_sample = hw_value * ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t} else {\n\t\t\tpulse = !(hw_value & ENE_FW_SAMPLE_SPACE);\n\t\t\thw_value &= ~ENE_FW_SAMPLE_SPACE;\n\t\t\thw_sample = hw_value * sample_period;\n\n\t\t\tif (dev->rx_period_adjust) {\n\t\t\t\thw_sample *= 100;\n\t\t\t\thw_sample /= (100 + dev->rx_period_adjust);\n\t\t\t}\n\t\t}\n\n\t\tif (!dev->hw_extra_buffer && !hw_sample) {\n\t\t\tdev->r_pointer = dev->w_pointer;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg(\"RX: %d (%s)\", hw_sample, pulse ? \"pulse\" : \"space\");\n\n\t\tev.duration = hw_sample;\n\t\tev.pulse = pulse;\n\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\t}\n\n\tir_raw_event_handle(dev->rdev);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn retval;\n}\n\n \nstatic void ene_setup_default_settings(struct ene_device *dev)\n{\n\tdev->tx_period = 32;\n\tdev->tx_duty_cycle = 50;  \n\tdev->transmitter_mask = 0x03;\n\tdev->learning_mode_enabled = learning_mode_force;\n\n\t \n\tdev->rdev->timeout = MS_TO_US(150);\n}\n\n \nstatic void ene_setup_hw_settings(struct ene_device *dev)\n{\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tene_tx_set_carrier(dev);\n\t\tene_tx_set_transmitters(dev);\n\t}\n\n\tene_rx_setup(dev);\n}\n\n \nstatic int ene_open(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n \nstatic void ene_close(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_rx_disable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n \nstatic int ene_set_tx_mask(struct rc_dev *rdev, u32 tx_mask)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: attempt to set transmitter mask %02x\", tx_mask);\n\n\t \n\tif (!tx_mask || tx_mask & ~0x03) {\n\t\tdbg(\"TX: invalid mask\");\n\t\t \n\t\treturn 2;\n\t}\n\n\tdev->transmitter_mask = tx_mask;\n\tene_tx_set_transmitters(dev);\n\treturn 0;\n}\n\n \nstatic int ene_set_tx_carrier(struct rc_dev *rdev, u32 carrier)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tu32 period;\n\n\tdbg(\"TX: attempt to set tx carrier to %d kHz\", carrier);\n\tif (carrier == 0)\n\t\treturn -EINVAL;\n\n\tperiod = 2000000 / carrier;\n\tif (period && (period > ENE_CIRMOD_PRD_MAX ||\n\t\t\tperiod < ENE_CIRMOD_PRD_MIN)) {\n\n\t\tdbg(\"TX: out of range %d-%d kHz carrier\",\n\t\t\t2000 / ENE_CIRMOD_PRD_MIN, 2000 / ENE_CIRMOD_PRD_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->tx_period = period;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n \nstatic int ene_set_tx_duty_cycle(struct rc_dev *rdev, u32 duty_cycle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: setting duty cycle to %d%%\", duty_cycle);\n\tdev->tx_duty_cycle = duty_cycle;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n \nstatic int ene_set_learning_mode(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tif (enable == dev->learning_mode_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->learning_mode_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\nstatic int ene_set_carrier_report(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tif (enable == dev->carrier_detect_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->carrier_detect_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n \nstatic void ene_set_idle(struct rc_dev *rdev, bool idle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\n\tif (idle) {\n\t\tene_rx_reset(dev);\n\t\tdbg(\"RX: end of data\");\n\t}\n}\n\n \nstatic int ene_transmit(struct rc_dev *rdev, unsigned *buf, unsigned n)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tdev->tx_buffer = buf;\n\tdev->tx_len = n;\n\tdev->tx_pos = 0;\n\tdev->tx_reg = 0;\n\tdev->tx_done = 0;\n\tdev->tx_sample = 0;\n\tdev->tx_sample_pulse = false;\n\n\tdbg(\"TX: %d samples\", dev->tx_len);\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_tx_enable(dev);\n\n\t \n\tene_tx_sample(dev);\n\tene_tx_sample(dev);\n\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tif (wait_for_completion_timeout(&dev->tx_complete, 2 * HZ) == 0) {\n\t\tdbg(\"TX: timeout\");\n\t\tspin_lock_irqsave(&dev->hw_lock, flags);\n\t\tene_tx_disable(dev);\n\t\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\t} else\n\t\tdbg(\"TX: done\");\n\treturn n;\n}\n\n \nstatic int ene_probe(struct pnp_dev *pnp_dev, const struct pnp_device_id *id)\n{\n\tint error = -ENOMEM;\n\tstruct rc_dev *rdev;\n\tstruct ene_device *dev;\n\n\t \n\tdev = kzalloc(sizeof(struct ene_device), GFP_KERNEL);\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!dev || !rdev)\n\t\tgoto exit_free_dev_rdev;\n\n\t \n\terror = -ENODEV;\n\n\t \n\tdev->hw_io = -1;\n\tdev->irq = -1;\n\n\tif (!pnp_port_valid(pnp_dev, 0) ||\n\t    pnp_port_len(pnp_dev, 0) < ENE_IO_SIZE)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!pnp_irq_valid(pnp_dev, 0))\n\t\tgoto exit_free_dev_rdev;\n\n\tspin_lock_init(&dev->hw_lock);\n\n\tdev->hw_io = pnp_port_start(pnp_dev, 0);\n\tdev->irq = pnp_irq(pnp_dev, 0);\n\n\n\tpnp_set_drvdata(pnp_dev, dev);\n\tdev->pnp_dev = pnp_dev;\n\n\t \n\tif (sample_period < 5 || sample_period > 0x7F)\n\t\tsample_period = ENE_DEFAULT_SAMPLE_PERIOD;\n\n\t \n\terror = ene_hw_detect(dev);\n\tif (error)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!dev->hw_learning_and_tx_capable && txsim) {\n\t\tdev->hw_learning_and_tx_capable = true;\n\t\ttimer_setup(&dev->tx_sim_timer, ene_tx_irqsim, 0);\n\t\tpr_warn(\"Simulation of TX activated\\n\");\n\t}\n\n\tif (!dev->hw_learning_and_tx_capable)\n\t\tlearning_mode_force = false;\n\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->priv = dev;\n\trdev->open = ene_open;\n\trdev->close = ene_close;\n\trdev->s_idle = ene_set_idle;\n\trdev->driver_name = ENE_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\trdev->device_name = \"ENE eHome Infrared Remote Receiver\";\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\trdev->s_wideband_receiver = ene_set_learning_mode;\n\t\tinit_completion(&dev->tx_complete);\n\t\trdev->tx_ir = ene_transmit;\n\t\trdev->s_tx_mask = ene_set_tx_mask;\n\t\trdev->s_tx_carrier = ene_set_tx_carrier;\n\t\trdev->s_tx_duty_cycle = ene_set_tx_duty_cycle;\n\t\trdev->s_carrier_report = ene_set_carrier_report;\n\t\trdev->device_name = \"ENE eHome Infrared Remote Transceiver\";\n\t}\n\n\tdev->rdev = rdev;\n\n\tene_rx_setup_hw_buffer(dev);\n\tene_setup_default_settings(dev);\n\tene_setup_hw_settings(dev);\n\n\tdevice_set_wakeup_capable(&pnp_dev->dev, true);\n\tdevice_set_wakeup_enable(&pnp_dev->dev, true);\n\n\terror = rc_register_device(rdev);\n\tif (error < 0)\n\t\tgoto exit_free_dev_rdev;\n\n\t \n\terror = -EBUSY;\n\tif (!request_region(dev->hw_io, ENE_IO_SIZE, ENE_DRIVER_NAME)) {\n\t\tgoto exit_unregister_device;\n\t}\n\n\tif (request_irq(dev->irq, ene_isr,\n\t\t\tIRQF_SHARED, ENE_DRIVER_NAME, (void *)dev)) {\n\t\tgoto exit_release_hw_io;\n\t}\n\n\tpr_notice(\"driver has been successfully loaded\\n\");\n\treturn 0;\n\nexit_release_hw_io:\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\nexit_unregister_device:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nexit_free_dev_rdev:\n\trc_free_device(rdev);\n\tkfree(dev);\n\treturn error;\n}\n\n \nstatic void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\n\trc_unregister_device(dev->rdev);\n\tdel_timer_sync(&dev->tx_sim_timer);\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\tkfree(dev);\n}\n\n \nstatic void ene_enable_wake(struct ene_device *dev, bool enable)\n{\n\tdbg(\"wake on IR %s\", enable ? \"enabled\" : \"disabled\");\n\tene_set_clear_reg_mask(dev, ENE_FW1, ENE_FW1_WAKE, enable);\n}\n\n#ifdef CONFIG_PM\nstatic int ene_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tbool wake = device_may_wakeup(&dev->pnp_dev->dev);\n\n\tif (!wake && dev->rx_enabled)\n\t\tene_rx_disable_hw(dev);\n\n\tene_enable_wake(dev, wake);\n\treturn 0;\n}\n\nstatic int ene_resume(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_setup_hw_settings(dev);\n\n\tif (dev->rx_enabled)\n\t\tene_rx_enable(dev);\n\n\tene_enable_wake(dev, false);\n\treturn 0;\n}\n#endif\n\nstatic void ene_shutdown(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_enable_wake(dev, true);\n}\n\nstatic const struct pnp_device_id ene_ids[] = {\n\t{.id = \"ENE0100\",},\n\t{.id = \"ENE0200\",},\n\t{.id = \"ENE0201\",},\n\t{.id = \"ENE0202\",},\n\t{},\n};\n\nstatic struct pnp_driver ene_driver = {\n\t.name = ENE_DRIVER_NAME,\n\t.id_table = ene_ids,\n\t.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\n\t.probe = ene_probe,\n\t.remove = ene_remove,\n#ifdef CONFIG_PM\n\t.suspend = ene_suspend,\n\t.resume = ene_resume,\n#endif\n\t.shutdown = ene_shutdown,\n};\n\nmodule_param(sample_period, int, S_IRUGO);\nMODULE_PARM_DESC(sample_period, \"Hardware sample period (50 us default)\");\n\nmodule_param(learning_mode_force, bool, S_IRUGO);\nMODULE_PARM_DESC(learning_mode_force, \"Enable learning mode by default\");\n\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level\");\n\nmodule_param(txsim, bool, S_IRUGO);\nMODULE_PARM_DESC(txsim,\n\t\"Simulate TX features on unsupported hardware (dangerous)\");\n\nMODULE_DEVICE_TABLE(pnp, ene_ids);\nMODULE_DESCRIPTION\n\t(\"Infrared input driver for KB3926B/C/D/E/F (aka ENE0100/ENE0200/ENE0201/ENE0202) CIR port\");\n\nMODULE_AUTHOR(\"Maxim Levitsky\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(ene_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}