{
  "module_name": "xbox_remote.c",
  "hash_id": "1f9b8a52532d6b98dd1777b7ab188d119486ace64a50fca268d55634dcfea79c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/xbox_remote.c",
  "human_readable_source": "\n\n\n\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n \n#define DRIVER_VERSION\t\"1.0.0\"\n#define DRIVER_AUTHOR\t\"Benjamin Valentin <benpicco@googlemail.com>\"\n#define DRIVER_DESC\t\t\"Xbox DVD USB Remote Control\"\n\n#define NAME_BUFSIZE      80     \n#define DATA_BUFSIZE      8      \n\n \n#define VENDOR_GAMESTER     0x040b\n#define VENDOR_MICROSOFT    0x045e\n\nstatic const struct usb_device_id xbox_remote_table[] = {\n\t \n\t{\n\t\tUSB_DEVICE(VENDOR_GAMESTER, 0x6521),\n\t},\n\t \n\t{\n\t\tUSB_DEVICE(VENDOR_MICROSOFT, 0x0284),\n\t},\n\t{}\t \n};\n\nMODULE_DEVICE_TABLE(usb, xbox_remote_table);\n\nstruct xbox_remote {\n\tstruct rc_dev *rdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\n\tstruct urb *irq_urb;\n\tunsigned char inbuf[DATA_BUFSIZE] __aligned(sizeof(u16));\n\n\tchar rc_name[NAME_BUFSIZE];\n\tchar rc_phys[NAME_BUFSIZE];\n};\n\nstatic int xbox_remote_rc_open(struct rc_dev *rdev)\n{\n\tstruct xbox_remote *xbox_remote = rdev->priv;\n\n\t \n\txbox_remote->irq_urb->dev = xbox_remote->udev;\n\tif (usb_submit_urb(xbox_remote->irq_urb, GFP_KERNEL)) {\n\t\tdev_err(&xbox_remote->interface->dev,\n\t\t\t\"%s: usb_submit_urb failed!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void xbox_remote_rc_close(struct rc_dev *rdev)\n{\n\tstruct xbox_remote *xbox_remote = rdev->priv;\n\n\tusb_kill_urb(xbox_remote->irq_urb);\n}\n\n \nstatic void xbox_remote_input_report(struct urb *urb)\n{\n\tstruct xbox_remote *xbox_remote = urb->context;\n\tunsigned char *data = xbox_remote->inbuf;\n\n\t \n\n\t \n\tif (urb->actual_length != 6 || urb->actual_length != data[1]) {\n\t\tdev_warn(&urb->dev->dev, \"Weird data, len=%d: %*ph\\n\",\n\t\t\t urb->actual_length, urb->actual_length, data);\n\t\treturn;\n\t}\n\n\trc_keydown(xbox_remote->rdev, RC_PROTO_XBOX_DVD,\n\t\t   le16_to_cpup((__le16 *)(data + 2)), 0);\n}\n\n \nstatic void xbox_remote_irq_in(struct urb *urb)\n{\n\tstruct xbox_remote *xbox_remote = urb->context;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\txbox_remote_input_report(urb);\n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&xbox_remote->interface->dev,\n\t\t\t\"%s: urb error status, unlink?\\n\",\n\t\t\t__func__);\n\t\treturn;\n\tdefault:\t\t \n\t\tdev_dbg(&xbox_remote->interface->dev,\n\t\t\t\"%s: Nonzero urb status %d\\n\",\n\t\t\t__func__, urb->status);\n\t}\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&xbox_remote->interface->dev,\n\t\t\t\"%s: usb_submit_urb()=%d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic void xbox_remote_rc_init(struct xbox_remote *xbox_remote)\n{\n\tstruct rc_dev *rdev = xbox_remote->rdev;\n\n\trdev->priv = xbox_remote;\n\trdev->allowed_protocols = RC_PROTO_BIT_XBOX_DVD;\n\trdev->driver_name = \"xbox_remote\";\n\n\trdev->open = xbox_remote_rc_open;\n\trdev->close = xbox_remote_rc_close;\n\n\trdev->device_name = xbox_remote->rc_name;\n\trdev->input_phys = xbox_remote->rc_phys;\n\n\trdev->timeout = MS_TO_US(10);\n\n\tusb_to_input_id(xbox_remote->udev, &rdev->input_id);\n\trdev->dev.parent = &xbox_remote->interface->dev;\n}\n\nstatic void xbox_remote_initialize(struct xbox_remote *xbox_remote,\n\t\t\t\t   struct usb_endpoint_descriptor *endpoint_in)\n{\n\tstruct usb_device *udev = xbox_remote->udev;\n\tint pipe, maxp;\n\n\t \n\tpipe = usb_rcvintpipe(udev, endpoint_in->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe);\n\tmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\n\n\tusb_fill_int_urb(xbox_remote->irq_urb, udev, pipe, xbox_remote->inbuf,\n\t\t\t maxp, xbox_remote_irq_in, xbox_remote,\n\t\t\t endpoint_in->bInterval);\n}\n\n \nstatic int xbox_remote_probe(struct usb_interface *interface,\n\t\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *iface_host = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint_in;\n\tstruct xbox_remote *xbox_remote;\n\tstruct rc_dev *rc_dev;\n\tint err = -ENOMEM;\n\n\t\n\tif (iface_host->desc.bNumEndpoints == 0)\n\t\treturn -ENODEV;\n\n\tif (iface_host->desc.bNumEndpoints != 1) {\n\t\tpr_err(\"%s: Unexpected desc.bNumEndpoints: %d\\n\",\n\t\t       __func__, iface_host->desc.bNumEndpoints);\n\t\treturn -ENODEV;\n\t}\n\n\tendpoint_in = &iface_host->endpoint[0].desc;\n\n\tif (!usb_endpoint_is_int_in(endpoint_in)) {\n\t\tpr_err(\"%s: Unexpected endpoint_in\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (le16_to_cpu(endpoint_in->wMaxPacketSize) == 0) {\n\t\tpr_err(\"%s: endpoint_in message size==0?\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\txbox_remote = kzalloc(sizeof(*xbox_remote), GFP_KERNEL);\n\trc_dev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!xbox_remote || !rc_dev)\n\t\tgoto exit_free_dev_rdev;\n\n\t \n\txbox_remote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!xbox_remote->irq_urb)\n\t\tgoto exit_free_buffers;\n\n\txbox_remote->udev = udev;\n\txbox_remote->rdev = rc_dev;\n\txbox_remote->interface = interface;\n\n\tusb_make_path(udev, xbox_remote->rc_phys, sizeof(xbox_remote->rc_phys));\n\n\tstrlcat(xbox_remote->rc_phys, \"/input0\", sizeof(xbox_remote->rc_phys));\n\n\tsnprintf(xbox_remote->rc_name, sizeof(xbox_remote->rc_name), \"%s%s%s\",\n\t\t udev->manufacturer ?: \"\",\n\t\t udev->manufacturer && udev->product ? \" \" : \"\",\n\t\t udev->product ?: \"\");\n\n\tif (!strlen(xbox_remote->rc_name))\n\t\tsnprintf(xbox_remote->rc_name, sizeof(xbox_remote->rc_name),\n\t\t\t DRIVER_DESC \"(%04x,%04x)\",\n\t\t\t le16_to_cpu(xbox_remote->udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(xbox_remote->udev->descriptor.idProduct));\n\n\trc_dev->map_name = RC_MAP_XBOX_DVD;  \n\n\txbox_remote_rc_init(xbox_remote);\n\n\t \n\txbox_remote_initialize(xbox_remote, endpoint_in);\n\n\t \n\terr = rc_register_device(xbox_remote->rdev);\n\tif (err)\n\t\tgoto exit_kill_urbs;\n\n\tusb_set_intfdata(interface, xbox_remote);\n\n\treturn 0;\n\nexit_kill_urbs:\n\tusb_kill_urb(xbox_remote->irq_urb);\nexit_free_buffers:\n\tusb_free_urb(xbox_remote->irq_urb);\nexit_free_dev_rdev:\n\trc_free_device(rc_dev);\n\tkfree(xbox_remote);\n\n\treturn err;\n}\n\n \nstatic void xbox_remote_disconnect(struct usb_interface *interface)\n{\n\tstruct xbox_remote *xbox_remote;\n\n\txbox_remote = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\tif (!xbox_remote) {\n\t\tdev_warn(&interface->dev, \"%s - null device?\\n\", __func__);\n\t\treturn;\n\t}\n\n\tusb_kill_urb(xbox_remote->irq_urb);\n\trc_unregister_device(xbox_remote->rdev);\n\tusb_free_urb(xbox_remote->irq_urb);\n\tkfree(xbox_remote);\n}\n\n \nstatic struct usb_driver xbox_remote_driver = {\n\t.name         = \"xbox_remote\",\n\t.probe        = xbox_remote_probe,\n\t.disconnect   = xbox_remote_disconnect,\n\t.id_table     = xbox_remote_table,\n};\n\nmodule_usb_driver(xbox_remote_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}