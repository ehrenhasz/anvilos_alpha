{
  "module_name": "rc-core-priv.h",
  "hash_id": "252c0aa121802970553d34ddaccdfd6cc32c3058794d76330246f197e1958064",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/rc-core-priv.h",
  "human_readable_source": " \n \n\n#ifndef _RC_CORE_PRIV\n#define _RC_CORE_PRIV\n\n#define\tRC_DEV_MAX\t\t256\n \n#define\tMAX_IR_EVENT_SIZE\t512\n\n#include <linux/slab.h>\n#include <uapi/linux/bpf.h>\n#include <media/rc-core.h>\n\n \nint rc_open(struct rc_dev *rdev);\n\n \nvoid rc_close(struct rc_dev *rdev);\n\nstruct ir_raw_handler {\n\tstruct list_head list;\n\n\tu64 protocols;  \n\tint (*decode)(struct rc_dev *dev, struct ir_raw_event event);\n\tint (*encode)(enum rc_proto protocol, u32 scancode,\n\t\t      struct ir_raw_event *events, unsigned int max);\n\tu32 carrier;\n\tu32 min_timeout;\n\n\t \n\tint (*raw_register)(struct rc_dev *dev);\n\tint (*raw_unregister)(struct rc_dev *dev);\n};\n\nstruct ir_raw_event_ctrl {\n\tstruct list_head\t\tlist;\t\t \n\tstruct task_struct\t\t*thread;\n\t \n\tDECLARE_KFIFO(kfifo, struct ir_raw_event, MAX_IR_EVENT_SIZE);\n\tktime_t\t\t\t\tlast_event;\t \n\tstruct rc_dev\t\t\t*dev;\t\t \n\t \n\tspinlock_t\t\t\tedge_spinlock;\n\tstruct timer_list\t\tedge_handle;\n\n\t \n\tstruct ir_raw_event prev_ev;\n\tstruct ir_raw_event this_ev;\n\n#ifdef CONFIG_BPF_LIRC_MODE2\n\tu32\t\t\t\tbpf_sample;\n\tstruct bpf_prog_array __rcu\t*progs;\n#endif\n#if IS_ENABLED(CONFIG_IR_NEC_DECODER)\n\tstruct nec_dec {\n\t\tint state;\n\t\tunsigned count;\n\t\tu32 bits;\n\t\tbool is_nec_x;\n\t\tbool necx_repeat;\n\t} nec;\n#endif\n#if IS_ENABLED(CONFIG_IR_RC5_DECODER)\n\tstruct rc5_dec {\n\t\tint state;\n\t\tu32 bits;\n\t\tunsigned count;\n\t\tbool is_rc5x;\n\t} rc5;\n#endif\n#if IS_ENABLED(CONFIG_IR_RC6_DECODER)\n\tstruct rc6_dec {\n\t\tint state;\n\t\tu8 header;\n\t\tu32 body;\n\t\tbool toggle;\n\t\tunsigned count;\n\t\tunsigned wanted_bits;\n\t} rc6;\n#endif\n#if IS_ENABLED(CONFIG_IR_SONY_DECODER)\n\tstruct sony_dec {\n\t\tint state;\n\t\tu32 bits;\n\t\tunsigned count;\n\t} sony;\n#endif\n#if IS_ENABLED(CONFIG_IR_JVC_DECODER)\n\tstruct jvc_dec {\n\t\tint state;\n\t\tu16 bits;\n\t\tu16 old_bits;\n\t\tunsigned count;\n\t\tbool first;\n\t\tbool toggle;\n\t} jvc;\n#endif\n#if IS_ENABLED(CONFIG_IR_SANYO_DECODER)\n\tstruct sanyo_dec {\n\t\tint state;\n\t\tunsigned count;\n\t\tu64 bits;\n\t} sanyo;\n#endif\n#if IS_ENABLED(CONFIG_IR_SHARP_DECODER)\n\tstruct sharp_dec {\n\t\tint state;\n\t\tunsigned count;\n\t\tu32 bits;\n\t\tunsigned int pulse_len;\n\t} sharp;\n#endif\n#if IS_ENABLED(CONFIG_IR_MCE_KBD_DECODER)\n\tstruct mce_kbd_dec {\n\t\t \n\t\tspinlock_t keylock;\n\t\tstruct timer_list rx_timeout;\n\t\tint state;\n\t\tu8 header;\n\t\tu32 body;\n\t\tunsigned count;\n\t\tunsigned wanted_bits;\n\t} mce_kbd;\n#endif\n#if IS_ENABLED(CONFIG_IR_XMP_DECODER)\n\tstruct xmp_dec {\n\t\tint state;\n\t\tunsigned count;\n\t\tu32 durations[16];\n\t} xmp;\n#endif\n#if IS_ENABLED(CONFIG_IR_IMON_DECODER)\n\tstruct imon_dec {\n\t\tint state;\n\t\tint count;\n\t\tint last_chk;\n\t\tunsigned int bits;\n\t\tbool stick_keyboard;\n\t} imon;\n#endif\n#if IS_ENABLED(CONFIG_IR_RCMM_DECODER)\n\tstruct rcmm_dec {\n\t\tint state;\n\t\tunsigned int count;\n\t\tu32 bits;\n\t} rcmm;\n#endif\n};\n\n \nextern struct mutex ir_raw_handler_lock;\n\n \nstatic inline bool geq_margin(unsigned d1, unsigned d2, unsigned margin)\n{\n\treturn d1 > (d2 - margin);\n}\n\nstatic inline bool eq_margin(unsigned d1, unsigned d2, unsigned margin)\n{\n\treturn ((d1 > (d2 - margin)) && (d1 < (d2 + margin)));\n}\n\nstatic inline bool is_transition(struct ir_raw_event *x, struct ir_raw_event *y)\n{\n\treturn x->pulse != y->pulse;\n}\n\nstatic inline void decrease_duration(struct ir_raw_event *ev, unsigned duration)\n{\n\tif (duration > ev->duration)\n\t\tev->duration = 0;\n\telse\n\t\tev->duration -= duration;\n}\n\n \nstatic inline bool is_timing_event(struct ir_raw_event ev)\n{\n\treturn !ev.carrier_report && !ev.overflow;\n}\n\n#define TO_STR(is_pulse)\t\t((is_pulse) ? \"pulse\" : \"space\")\n\n \nbool rc_validate_scancode(enum rc_proto proto, u32 scancode);\n\nstatic inline void init_ir_raw_event_duration(struct ir_raw_event *ev,\n\t\t\t\t\t      unsigned int pulse,\n\t\t\t\t\t      u32 duration)\n{\n\t*ev = (struct ir_raw_event) {\n\t\t.duration = duration,\n\t\t.pulse = pulse\n\t};\n}\n\n \nstruct ir_raw_timings_manchester {\n\tunsigned int leader_pulse;\n\tunsigned int leader_space;\n\tunsigned int clock;\n\tunsigned int invert:1;\n\tunsigned int trailer_space;\n};\n\nint ir_raw_gen_manchester(struct ir_raw_event **ev, unsigned int max,\n\t\t\t  const struct ir_raw_timings_manchester *timings,\n\t\t\t  unsigned int n, u64 data);\n\n \nstatic inline int ir_raw_gen_pulse_space(struct ir_raw_event **ev,\n\t\t\t\t\t unsigned int *max,\n\t\t\t\t\t unsigned int pulse_width,\n\t\t\t\t\t unsigned int space_width)\n{\n\tif (!*max)\n\t\treturn -ENOBUFS;\n\tinit_ir_raw_event_duration((*ev)++, 1, pulse_width);\n\tif (!--*max)\n\t\treturn -ENOBUFS;\n\tinit_ir_raw_event_duration((*ev)++, 0, space_width);\n\t--*max;\n\treturn 0;\n}\n\n \nstruct ir_raw_timings_pd {\n\tunsigned int header_pulse;\n\tunsigned int header_space;\n\tunsigned int bit_pulse;\n\tunsigned int bit_space[2];\n\tunsigned int trailer_pulse;\n\tunsigned int trailer_space;\n\tunsigned int msb_first:1;\n};\n\nint ir_raw_gen_pd(struct ir_raw_event **ev, unsigned int max,\n\t\t  const struct ir_raw_timings_pd *timings,\n\t\t  unsigned int n, u64 data);\n\n \nstruct ir_raw_timings_pl {\n\tunsigned int header_pulse;\n\tunsigned int bit_space;\n\tunsigned int bit_pulse[2];\n\tunsigned int trailer_space;\n\tunsigned int msb_first:1;\n};\n\nint ir_raw_gen_pl(struct ir_raw_event **ev, unsigned int max,\n\t\t  const struct ir_raw_timings_pl *timings,\n\t\t  unsigned int n, u64 data);\n\n \nu64 ir_raw_get_allowed_protocols(void);\nint ir_raw_event_prepare(struct rc_dev *dev);\nint ir_raw_event_register(struct rc_dev *dev);\nvoid ir_raw_event_free(struct rc_dev *dev);\nvoid ir_raw_event_unregister(struct rc_dev *dev);\nint ir_raw_handler_register(struct ir_raw_handler *ir_raw_handler);\nvoid ir_raw_handler_unregister(struct ir_raw_handler *ir_raw_handler);\nvoid ir_raw_load_modules(u64 *protocols);\nvoid ir_raw_init(void);\n\n \n#ifdef CONFIG_LIRC\nint lirc_dev_init(void);\nvoid lirc_dev_exit(void);\nvoid lirc_raw_event(struct rc_dev *dev, struct ir_raw_event ev);\nvoid lirc_scancode_event(struct rc_dev *dev, struct lirc_scancode *lsc);\nint lirc_register(struct rc_dev *dev);\nvoid lirc_unregister(struct rc_dev *dev);\nstruct rc_dev *rc_dev_get_from_fd(int fd);\n#else\nstatic inline int lirc_dev_init(void) { return 0; }\nstatic inline void lirc_dev_exit(void) {}\nstatic inline void lirc_raw_event(struct rc_dev *dev,\n\t\t\t\t  struct ir_raw_event ev) { }\nstatic inline void lirc_scancode_event(struct rc_dev *dev,\n\t\t\t\t       struct lirc_scancode *lsc) { }\nstatic inline int lirc_register(struct rc_dev *dev) { return 0; }\nstatic inline void lirc_unregister(struct rc_dev *dev) { }\n#endif\n\n \n#ifdef CONFIG_BPF_LIRC_MODE2\nvoid lirc_bpf_free(struct rc_dev *dev);\nvoid lirc_bpf_run(struct rc_dev *dev, u32 sample);\n#else\nstatic inline void lirc_bpf_free(struct rc_dev *dev) { }\nstatic inline void lirc_bpf_run(struct rc_dev *dev, u32 sample) { }\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}