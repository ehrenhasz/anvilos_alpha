{
  "module_name": "ir-jvc-decoder.c",
  "hash_id": "8b94e42d19f1f3b344005795079ff233a2731b9e5c43fd76645040dcfcb1296f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-jvc-decoder.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define JVC_NBITS\t\t16\t\t \n#define JVC_UNIT\t\t525\t\t \n#define JVC_HEADER_PULSE\t(16 * JVC_UNIT)  \n#define JVC_HEADER_SPACE\t(8  * JVC_UNIT)\n#define JVC_BIT_PULSE\t\t(1  * JVC_UNIT)\n#define JVC_BIT_0_SPACE\t\t(1  * JVC_UNIT)\n#define JVC_BIT_1_SPACE\t\t(3  * JVC_UNIT)\n#define JVC_TRAILER_PULSE\t(1  * JVC_UNIT)\n#define\tJVC_TRAILER_SPACE\t(35 * JVC_UNIT)\n\nenum jvc_state {\n\tSTATE_INACTIVE,\n\tSTATE_HEADER_SPACE,\n\tSTATE_BIT_PULSE,\n\tSTATE_BIT_SPACE,\n\tSTATE_TRAILER_PULSE,\n\tSTATE_TRAILER_SPACE,\n\tSTATE_CHECK_REPEAT,\n};\n\n \nstatic int ir_jvc_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct jvc_dec *data = &dev->raw->jvc;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (!geq_margin(ev.duration, JVC_UNIT, JVC_UNIT / 2))\n\t\tgoto out;\n\n\tdev_dbg(&dev->dev, \"JVC decode started at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\nagain:\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, JVC_HEADER_PULSE, JVC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->count = 0;\n\t\tdata->first = true;\n\t\tdata->toggle = !data->toggle;\n\t\tdata->state = STATE_HEADER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_HEADER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, JVC_HEADER_SPACE, JVC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_PULSE;\n\t\treturn 0;\n\n\tcase STATE_BIT_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, JVC_BIT_PULSE, JVC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tdata->bits <<= 1;\n\t\tif (eq_margin(ev.duration, JVC_BIT_1_SPACE, JVC_UNIT / 2)) {\n\t\t\tdata->bits |= 1;\n\t\t\tdecrease_duration(&ev, JVC_BIT_1_SPACE);\n\t\t} else if (eq_margin(ev.duration, JVC_BIT_0_SPACE, JVC_UNIT / 2))\n\t\t\tdecrease_duration(&ev, JVC_BIT_0_SPACE);\n\t\telse\n\t\t\tbreak;\n\t\tdata->count++;\n\n\t\tif (data->count == JVC_NBITS)\n\t\t\tdata->state = STATE_TRAILER_PULSE;\n\t\telse\n\t\t\tdata->state = STATE_BIT_PULSE;\n\t\treturn 0;\n\n\tcase STATE_TRAILER_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, JVC_TRAILER_PULSE, JVC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_TRAILER_SPACE;\n\t\treturn 0;\n\n\tcase STATE_TRAILER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, JVC_TRAILER_SPACE, JVC_UNIT / 2))\n\t\t\tbreak;\n\n\t\tif (data->first) {\n\t\t\tu32 scancode;\n\t\t\tscancode = (bitrev8((data->bits >> 8) & 0xff) << 8) |\n\t\t\t\t   (bitrev8((data->bits >> 0) & 0xff) << 0);\n\t\t\tdev_dbg(&dev->dev, \"JVC scancode 0x%04x\\n\", scancode);\n\t\t\trc_keydown(dev, RC_PROTO_JVC, scancode, data->toggle);\n\t\t\tdata->first = false;\n\t\t\tdata->old_bits = data->bits;\n\t\t} else if (data->bits == data->old_bits) {\n\t\t\tdev_dbg(&dev->dev, \"JVC repeat\\n\");\n\t\t\trc_repeat(dev);\n\t\t} else {\n\t\t\tdev_dbg(&dev->dev, \"JVC invalid repeat msg\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->count = 0;\n\t\tdata->state = STATE_CHECK_REPEAT;\n\t\treturn 0;\n\n\tcase STATE_CHECK_REPEAT:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, JVC_HEADER_PULSE, JVC_UNIT / 2))\n\t\t\tdata->state = STATE_INACTIVE;\n  else\n\t\t\tdata->state = STATE_BIT_PULSE;\n\t\tgoto again;\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"JVC decode failed at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const struct ir_raw_timings_pd ir_jvc_timings = {\n\t.header_pulse  = JVC_HEADER_PULSE,\n\t.header_space  = JVC_HEADER_SPACE,\n\t.bit_pulse     = JVC_BIT_PULSE,\n\t.bit_space[0]  = JVC_BIT_0_SPACE,\n\t.bit_space[1]  = JVC_BIT_1_SPACE,\n\t.trailer_pulse = JVC_TRAILER_PULSE,\n\t.trailer_space = JVC_TRAILER_SPACE,\n\t.msb_first     = 1,\n};\n\n \nstatic int ir_jvc_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint ret;\n\tu32 raw = (bitrev8((scancode >> 8) & 0xff) << 8) |\n\t\t  (bitrev8((scancode >> 0) & 0xff) << 0);\n\n\tret = ir_raw_gen_pd(&e, max, &ir_jvc_timings, JVC_NBITS, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler jvc_handler = {\n\t.protocols\t= RC_PROTO_BIT_JVC,\n\t.decode\t\t= ir_jvc_decode,\n\t.encode\t\t= ir_jvc_encode,\n\t.carrier\t= 38000,\n\t.min_timeout\t= JVC_TRAILER_SPACE,\n};\n\nstatic int __init ir_jvc_decode_init(void)\n{\n\tir_raw_handler_register(&jvc_handler);\n\n\tprintk(KERN_INFO \"IR JVC protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_jvc_decode_exit(void)\n{\n\tir_raw_handler_unregister(&jvc_handler);\n}\n\nmodule_init(ir_jvc_decode_init);\nmodule_exit(ir_jvc_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David H\u00e4rdeman <david@hardeman.nu>\");\nMODULE_DESCRIPTION(\"JVC IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}