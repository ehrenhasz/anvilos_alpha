{
  "module_name": "meson-ir-tx.c",
  "hash_id": "87bdf87a47e935795034e2856a7d84e391f0dc9a012ab019a9bc36a8dc80caae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/meson-ir-tx.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n\n#define DEVICE_NAME\t\"Meson IR TX\"\n#define DRIVER_NAME\t\"meson-ir-tx\"\n\n#define MIRTX_DEFAULT_CARRIER\t\t38000\n#define MIRTX_DEFAULT_DUTY_CYCLE\t50\n#define MIRTX_FIFO_THD\t\t\t32\n\n#define IRB_MOD_1US_CLK_RATE\t1000000\n\n#define IRB_FIFO_LEN\t128\n\n#define IRB_ADDR0\t0x0\n#define IRB_ADDR1\t0x4\n#define IRB_ADDR2\t0x8\n#define IRB_ADDR3\t0xc\n\n#define IRB_MAX_DELAY\t(1 << 10)\n#define IRB_DELAY_MASK\t(IRB_MAX_DELAY - 1)\n\n \n#define IRB_MOD_CLK(x)\t\t((x) << 12)\n#define IRB_MOD_SYS_CLK\t\t0\n#define IRB_MOD_XTAL3_CLK\t1\n#define IRB_MOD_1US_CLK\t\t2\n#define IRB_MOD_10US_CLK\t3\n#define IRB_INIT_HIGH\t\tBIT(2)\n#define IRB_ENABLE\t\tBIT(0)\n\n \n#define IRB_MOD_COUNT(lo, hi)\t((((lo) - 1) << 16) | ((hi) - 1))\n\n \n#define IRB_WRITE_FIFO\tBIT(16)\n#define IRB_MOD_ENABLE\tBIT(12)\n#define IRB_TB_1US\t(0x0 << 10)\n#define IRB_TB_10US\t(0x1 << 10)\n#define IRB_TB_100US\t(0x2 << 10)\n#define IRB_TB_MOD_CLK\t(0x3 << 10)\n\n \n#define IRB_FIFO_THD_PENDING\tBIT(16)\n#define IRB_FIFO_IRQ_ENABLE\tBIT(8)\n\nstruct meson_irtx {\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tu32 *buf;\n\tunsigned int buf_len;\n\tunsigned int buf_head;\n\tunsigned int carrier;\n\tunsigned int duty_cycle;\n\t \n\tspinlock_t lock;\n\tstruct completion completion;\n\tunsigned long clk_rate;\n};\n\nstatic void meson_irtx_set_mod(struct meson_irtx *ir)\n{\n\tunsigned int cnt = DIV_ROUND_CLOSEST(ir->clk_rate, ir->carrier);\n\tunsigned int pulse_cnt = DIV_ROUND_CLOSEST(cnt * ir->duty_cycle, 100);\n\tunsigned int space_cnt = cnt - pulse_cnt;\n\n\tdev_dbg(ir->dev, \"F_mod = %uHz, T_mod = %luns, duty_cycle = %u%%\\n\",\n\t\tir->carrier, NSEC_PER_SEC / ir->clk_rate * cnt,\n\t\t100 * pulse_cnt / cnt);\n\n\twritel(IRB_MOD_COUNT(pulse_cnt, space_cnt),\n\t       ir->reg_base + IRB_ADDR1);\n}\n\nstatic void meson_irtx_setup(struct meson_irtx *ir, unsigned int clk_nr)\n{\n\t \n\twritel(~IRB_ENABLE & (IRB_MOD_CLK(clk_nr) | IRB_INIT_HIGH),\n\t       ir->reg_base + IRB_ADDR0);\n\tmeson_irtx_set_mod(ir);\n\twritel(readl(ir->reg_base + IRB_ADDR0) & ~IRB_INIT_HIGH,\n\t       ir->reg_base + IRB_ADDR0);\n\twritel(IRB_FIFO_IRQ_ENABLE | MIRTX_FIFO_THD,\n\t       ir->reg_base + IRB_ADDR3);\n\twritel(readl(ir->reg_base + IRB_ADDR0) | IRB_ENABLE,\n\t       ir->reg_base + IRB_ADDR0);\n}\n\nstatic u32 meson_irtx_prepare_pulse(struct meson_irtx *ir, unsigned int time)\n{\n\tunsigned int delay;\n\tunsigned int tb = IRB_TB_MOD_CLK;\n\tunsigned int tb_us = DIV_ROUND_CLOSEST(USEC_PER_SEC, ir->carrier);\n\n\tdelay = (DIV_ROUND_CLOSEST(time, tb_us) - 1) & IRB_DELAY_MASK;\n\n\treturn ((IRB_WRITE_FIFO | IRB_MOD_ENABLE) | tb | delay);\n}\n\nstatic u32 meson_irtx_prepare_space(struct meson_irtx *ir, unsigned int time)\n{\n\tunsigned int delay;\n\tunsigned int tb = IRB_TB_100US;\n\tunsigned int tb_us = 100;\n\n\tif (time <= IRB_MAX_DELAY) {\n\t\ttb = IRB_TB_1US;\n\t\ttb_us = 1;\n\t} else if (time <= 10 * IRB_MAX_DELAY) {\n\t\ttb = IRB_TB_10US;\n\t\ttb_us = 10;\n\t} else if (time <= 100 * IRB_MAX_DELAY) {\n\t\ttb = IRB_TB_100US;\n\t\ttb_us = 100;\n\t}\n\n\tdelay = (DIV_ROUND_CLOSEST(time, tb_us) - 1) & IRB_DELAY_MASK;\n\n\treturn ((IRB_WRITE_FIFO & ~IRB_MOD_ENABLE) | tb | delay);\n}\n\nstatic void meson_irtx_send_buffer(struct meson_irtx *ir)\n{\n\tunsigned int nr = 0;\n\tunsigned int max_fifo_level = IRB_FIFO_LEN - MIRTX_FIFO_THD;\n\n\twhile (ir->buf_head < ir->buf_len && nr < max_fifo_level) {\n\t\twritel(ir->buf[ir->buf_head], ir->reg_base + IRB_ADDR2);\n\n\t\tir->buf_head++;\n\t\tnr++;\n\t}\n}\n\nstatic bool meson_irtx_check_buf(struct meson_irtx *ir,\n\t\t\t\t unsigned int *buf, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int max_tb_us;\n\t\t \n\t\tif (i % 2 == 0)\n\t\t\tmax_tb_us = USEC_PER_SEC / ir->carrier;\n\t\telse\n\t\t\tmax_tb_us = 100;\n\n\t\tif (buf[i] >= max_tb_us * IRB_MAX_DELAY)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void meson_irtx_fill_buf(struct meson_irtx *ir, u32 *dst_buf,\n\t\t\t\tunsigned int *src_buf, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (i % 2 == 0)\n\t\t\tdst_buf[i] = meson_irtx_prepare_pulse(ir, src_buf[i]);\n\t\telse\n\t\t\tdst_buf[i] = meson_irtx_prepare_space(ir, src_buf[i]);\n\t}\n}\n\nstatic irqreturn_t meson_irtx_irqhandler(int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct meson_irtx *ir = data;\n\n\twritel(readl(ir->reg_base + IRB_ADDR3) & ~IRB_FIFO_THD_PENDING,\n\t       ir->reg_base + IRB_ADDR3);\n\n\tif (completion_done(&ir->completion))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&ir->lock, flags);\n\tif (ir->buf_head < ir->buf_len)\n\t\tmeson_irtx_send_buffer(ir);\n\telse\n\t\tcomplete(&ir->completion);\n\tspin_unlock_irqrestore(&ir->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int meson_irtx_set_carrier(struct rc_dev *rc, u32 carrier)\n{\n\tstruct meson_irtx *ir = rc->priv;\n\n\tif (carrier == 0)\n\t\treturn -EINVAL;\n\n\tir->carrier = carrier;\n\tmeson_irtx_set_mod(ir);\n\n\treturn 0;\n}\n\nstatic int meson_irtx_set_duty_cycle(struct rc_dev *rc, u32 duty_cycle)\n{\n\tstruct meson_irtx *ir = rc->priv;\n\n\tir->duty_cycle = duty_cycle;\n\tmeson_irtx_set_mod(ir);\n\n\treturn 0;\n}\n\nstatic void meson_irtx_update_buf(struct meson_irtx *ir, u32 *buf,\n\t\t\t\t  unsigned int len, unsigned int head)\n{\n\tir->buf = buf;\n\tir->buf_len = len;\n\tir->buf_head = head;\n}\n\nstatic int meson_irtx_transmit(struct rc_dev *rc, unsigned int *buf,\n\t\t\t       unsigned int len)\n{\n\tunsigned long flags;\n\tstruct meson_irtx *ir = rc->priv;\n\tu32 *tx_buf;\n\tint ret = len;\n\n\tif (!meson_irtx_check_buf(ir, buf, len))\n\t\treturn -EINVAL;\n\n\ttx_buf = kmalloc_array(len, sizeof(u32), GFP_KERNEL);\n\tif (!tx_buf)\n\t\treturn -ENOMEM;\n\n\tmeson_irtx_fill_buf(ir, tx_buf, buf, len);\n\tdev_dbg(ir->dev, \"TX buffer filled, length = %u\\n\", len);\n\n\tspin_lock_irqsave(&ir->lock, flags);\n\tmeson_irtx_update_buf(ir, tx_buf, len, 0);\n\treinit_completion(&ir->completion);\n\tmeson_irtx_send_buffer(ir);\n\tspin_unlock_irqrestore(&ir->lock, flags);\n\n\tif (!wait_for_completion_timeout(&ir->completion,\n\t\t\t\t\t usecs_to_jiffies(IR_MAX_DURATION)))\n\t\tret = -ETIMEDOUT;\n\n\tspin_lock_irqsave(&ir->lock, flags);\n\tkfree(ir->buf);\n\tmeson_irtx_update_buf(ir, NULL, 0, 0);\n\tspin_unlock_irqrestore(&ir->lock, flags);\n\n\treturn ret;\n}\n\nstatic int meson_irtx_mod_clock_probe(struct meson_irtx *ir,\n\t\t\t\t      unsigned int *clk_nr)\n{\n\tstruct device_node *np = ir->dev->of_node;\n\tstruct clk *clock;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tclock = devm_clk_get(ir->dev, \"xtal\");\n\tif (IS_ERR(clock) || clk_prepare_enable(clock))\n\t\treturn -ENODEV;\n\n\t*clk_nr = IRB_MOD_XTAL3_CLK;\n\tir->clk_rate = clk_get_rate(clock) / 3;\n\n\tif (ir->clk_rate < IRB_MOD_1US_CLK_RATE) {\n\t\t*clk_nr = IRB_MOD_1US_CLK;\n\t\tir->clk_rate = IRB_MOD_1US_CLK_RATE;\n\t}\n\n\tdev_info(ir->dev, \"F_clk = %luHz\\n\", ir->clk_rate);\n\n\treturn 0;\n}\n\nstatic int __init meson_irtx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_irtx *ir;\n\tstruct rc_dev *rc;\n\tint irq;\n\tunsigned int clk_nr;\n\tint ret;\n\n\tir = devm_kzalloc(dev, sizeof(*ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tir->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ir->reg_base))\n\t\treturn PTR_ERR(ir->reg_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENODEV;\n\n\tir->dev = dev;\n\tir->carrier = MIRTX_DEFAULT_CARRIER;\n\tir->duty_cycle = MIRTX_DEFAULT_DUTY_CYCLE;\n\tinit_completion(&ir->completion);\n\tspin_lock_init(&ir->lock);\n\n\tret = meson_irtx_mod_clock_probe(ir, &clk_nr);\n\tif (ret) {\n\t\tdev_err(dev, \"modulator clock setup failed\\n\");\n\t\treturn ret;\n\t}\n\tmeson_irtx_setup(ir, clk_nr);\n\n\tret = devm_request_irq(dev, irq,\n\t\t\t       meson_irtx_irqhandler,\n\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t       DRIVER_NAME, ir);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request failed\\n\");\n\t\treturn ret;\n\t}\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW_TX);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->driver_name = DRIVER_NAME;\n\trc->device_name = DEVICE_NAME;\n\trc->priv = ir;\n\n\trc->tx_ir = meson_irtx_transmit;\n\trc->s_tx_carrier = meson_irtx_set_carrier;\n\trc->s_tx_duty_cycle = meson_irtx_set_duty_cycle;\n\n\tret = rc_register_device(rc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rc_dev registration failed\\n\");\n\t\trc_free_device(rc);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, rc);\n\n\treturn 0;\n}\n\nstatic void meson_irtx_remove(struct platform_device *pdev)\n{\n\tstruct rc_dev *rc = platform_get_drvdata(pdev);\n\n\trc_unregister_device(rc);\n}\n\nstatic const struct of_device_id meson_irtx_dt_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-ir-tx\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, meson_irtx_dt_match);\n\nstatic struct platform_driver meson_irtx_pd = {\n\t.remove_new = meson_irtx_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = meson_irtx_dt_match,\n\t},\n};\n\nmodule_platform_driver_probe(meson_irtx_pd, meson_irtx_probe);\n\nMODULE_DESCRIPTION(\"Meson IR TX driver\");\nMODULE_AUTHOR(\"Viktor Prutyanov <viktor.prutyanov@phystech.edu>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}