{
  "module_name": "fintek-cir.c",
  "hash_id": "0da650f493467b01dcb3cfdbda9fa09be9377653ee80b47c483ebc49b423a226",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/fintek-cir.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n\n#include \"fintek-cir.h\"\n\n \nstatic inline void fintek_cr_write(struct fintek_dev *fintek, u8 val, u8 reg)\n{\n\tfit_dbg(\"%s: reg 0x%02x, val 0x%02x  (ip/dp: %02x/%02x)\",\n\t\t__func__, reg, val, fintek->cr_ip, fintek->cr_dp);\n\toutb(reg, fintek->cr_ip);\n\toutb(val, fintek->cr_dp);\n}\n\n \nstatic inline u8 fintek_cr_read(struct fintek_dev *fintek, u8 reg)\n{\n\tu8 val;\n\n\toutb(reg, fintek->cr_ip);\n\tval = inb(fintek->cr_dp);\n\n\tfit_dbg(\"%s: reg 0x%02x, val 0x%02x  (ip/dp: %02x/%02x)\",\n\t\t__func__, reg, val, fintek->cr_ip, fintek->cr_dp);\n\treturn val;\n}\n\n \nstatic inline void fintek_set_reg_bit(struct fintek_dev *fintek, u8 val, u8 reg)\n{\n\tu8 tmp = fintek_cr_read(fintek, reg) | val;\n\tfintek_cr_write(fintek, tmp, reg);\n}\n\n \nstatic inline void fintek_config_mode_enable(struct fintek_dev *fintek)\n{\n\t \n\toutb(CONFIG_REG_ENABLE, fintek->cr_ip);\n\toutb(CONFIG_REG_ENABLE, fintek->cr_ip);\n}\n\n \nstatic inline void fintek_config_mode_disable(struct fintek_dev *fintek)\n{\n\toutb(CONFIG_REG_DISABLE, fintek->cr_ip);\n}\n\n \nstatic inline void fintek_select_logical_dev(struct fintek_dev *fintek, u8 ldev)\n{\n\tfintek_cr_write(fintek, ldev, GCR_LOGICAL_DEV_NO);\n}\n\n \nstatic inline void fintek_cir_reg_write(struct fintek_dev *fintek, u8 val, u8 offset)\n{\n\toutb(val, fintek->cir_addr + offset);\n}\n\n \nstatic u8 fintek_cir_reg_read(struct fintek_dev *fintek, u8 offset)\n{\n\treturn inb(fintek->cir_addr + offset);\n}\n\n \nstatic void cir_dump_regs(struct fintek_dev *fintek)\n{\n\tfintek_config_mode_enable(fintek);\n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\n\tpr_info(\"%s: Dump CIR logical device registers:\\n\", FINTEK_DRIVER_NAME);\n\tpr_info(\" * CR CIR BASE ADDR: 0x%x\\n\",\n\t\t(fintek_cr_read(fintek, CIR_CR_BASE_ADDR_HI) << 8) |\n\t\tfintek_cr_read(fintek, CIR_CR_BASE_ADDR_LO));\n\tpr_info(\" * CR CIR IRQ NUM:   0x%x\\n\",\n\t\tfintek_cr_read(fintek, CIR_CR_IRQ_SEL));\n\n\tfintek_config_mode_disable(fintek);\n\n\tpr_info(\"%s: Dump CIR registers:\\n\", FINTEK_DRIVER_NAME);\n\tpr_info(\" * STATUS:     0x%x\\n\",\n\t\tfintek_cir_reg_read(fintek, CIR_STATUS));\n\tpr_info(\" * CONTROL:    0x%x\\n\",\n\t\tfintek_cir_reg_read(fintek, CIR_CONTROL));\n\tpr_info(\" * RX_DATA:    0x%x\\n\",\n\t\tfintek_cir_reg_read(fintek, CIR_RX_DATA));\n\tpr_info(\" * TX_CONTROL: 0x%x\\n\",\n\t\tfintek_cir_reg_read(fintek, CIR_TX_CONTROL));\n\tpr_info(\" * TX_DATA:    0x%x\\n\",\n\t\tfintek_cir_reg_read(fintek, CIR_TX_DATA));\n}\n\n \nstatic int fintek_hw_detect(struct fintek_dev *fintek)\n{\n\tunsigned long flags;\n\tu8 chip_major, chip_minor;\n\tu8 vendor_major, vendor_minor;\n\tu8 portsel, ir_class;\n\tu16 vendor, chip;\n\n\tfintek_config_mode_enable(fintek);\n\n\t \n\tportsel = fintek_cr_read(fintek, GCR_CONFIG_PORT_SEL);\n\tif (portsel == 0xff) {\n\t\tfit_pr(KERN_INFO, \"first portsel read was bunk, trying alt\");\n\t\tfintek_config_mode_disable(fintek);\n\t\tfintek->cr_ip = CR_INDEX_PORT2;\n\t\tfintek->cr_dp = CR_DATA_PORT2;\n\t\tfintek_config_mode_enable(fintek);\n\t\tportsel = fintek_cr_read(fintek, GCR_CONFIG_PORT_SEL);\n\t}\n\tfit_dbg(\"portsel reg: 0x%02x\", portsel);\n\n\tir_class = fintek_cir_reg_read(fintek, CIR_CR_CLASS);\n\tfit_dbg(\"ir_class reg: 0x%02x\", ir_class);\n\n\tswitch (ir_class) {\n\tcase CLASS_RX_2TX:\n\tcase CLASS_RX_1TX:\n\t\tfintek->hw_tx_capable = true;\n\t\tbreak;\n\tcase CLASS_RX_ONLY:\n\tdefault:\n\t\tfintek->hw_tx_capable = false;\n\t\tbreak;\n\t}\n\n\tchip_major = fintek_cr_read(fintek, GCR_CHIP_ID_HI);\n\tchip_minor = fintek_cr_read(fintek, GCR_CHIP_ID_LO);\n\tchip  = chip_major << 8 | chip_minor;\n\n\tvendor_major = fintek_cr_read(fintek, GCR_VENDOR_ID_HI);\n\tvendor_minor = fintek_cr_read(fintek, GCR_VENDOR_ID_LO);\n\tvendor = vendor_major << 8 | vendor_minor;\n\n\tif (vendor != VENDOR_ID_FINTEK)\n\t\tfit_pr(KERN_WARNING, \"Unknown vendor ID: 0x%04x\", vendor);\n\telse\n\t\tfit_dbg(\"Read Fintek vendor ID from chip\");\n\n\tfintek_config_mode_disable(fintek);\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\tfintek->chip_major  = chip_major;\n\tfintek->chip_minor  = chip_minor;\n\tfintek->chip_vendor = vendor;\n\n\t \n\tif ((chip != 0x0408) && (chip != 0x0804))\n\t\tfintek->logical_dev_cir = LOGICAL_DEV_CIR_REV2;\n\telse\n\t\tfintek->logical_dev_cir = LOGICAL_DEV_CIR_REV1;\n\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n\n\treturn 0;\n}\n\nstatic void fintek_cir_ldev_init(struct fintek_dev *fintek)\n{\n\t \n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_cr_write(fintek, LOGICAL_DEV_ENABLE, CIR_CR_DEV_EN);\n\n\t \n\tfintek_cr_write(fintek, fintek->cir_addr >> 8, CIR_CR_BASE_ADDR_HI);\n\tfintek_cr_write(fintek, fintek->cir_addr & 0xff, CIR_CR_BASE_ADDR_LO);\n\n\tfintek_cr_write(fintek, fintek->cir_irq, CIR_CR_IRQ_SEL);\n\n\tfit_dbg(\"CIR initialized, base io address: 0x%lx, irq: %d (len: %d)\",\n\t\tfintek->cir_addr, fintek->cir_irq, fintek->cir_port_len);\n}\n\n \nstatic void fintek_enable_cir_irq(struct fintek_dev *fintek)\n{\n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_EN, CIR_STATUS);\n}\n\nstatic void fintek_cir_regs_init(struct fintek_dev *fintek)\n{\n\t \n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_MASK, CIR_STATUS);\n\n\t \n\tfintek_enable_cir_irq(fintek);\n}\n\nstatic void fintek_enable_wake(struct fintek_dev *fintek)\n{\n\tfintek_config_mode_enable(fintek);\n\tfintek_select_logical_dev(fintek, LOGICAL_DEV_ACPI);\n\n\t \n\tfintek_set_reg_bit(fintek, ACPI_WAKE_EN_CIR_BIT, LDEV_ACPI_WAKE_EN_REG);\n\t \n\tfintek_set_reg_bit(fintek, ACPI_PME_CIR_BIT, LDEV_ACPI_PME_EN_REG);\n\t \n\tfintek_set_reg_bit(fintek, ACPI_PME_CIR_BIT, LDEV_ACPI_PME_CLR_REG);\n\t \n\tfintek_set_reg_bit(fintek, ACPI_STATE_CIR_BIT, LDEV_ACPI_STATE_REG);\n\n\tfintek_config_mode_disable(fintek);\n}\n\nstatic int fintek_cmdsize(u8 cmd, u8 subcmd)\n{\n\tint datasize = 0;\n\n\tswitch (cmd) {\n\tcase BUF_COMMAND_NULL:\n\t\tif (subcmd == BUF_HW_CMD_HEADER)\n\t\t\tdatasize = 1;\n\t\tbreak;\n\tcase BUF_HW_CMD_HEADER:\n\t\tif (subcmd == BUF_CMD_G_REVISION)\n\t\t\tdatasize = 2;\n\t\tbreak;\n\tcase BUF_COMMAND_HEADER:\n\t\tswitch (subcmd) {\n\t\tcase BUF_CMD_S_CARRIER:\n\t\tcase BUF_CMD_S_TIMEOUT:\n\t\tcase BUF_RSP_PULSE_COUNT:\n\t\t\tdatasize = 2;\n\t\t\tbreak;\n\t\tcase BUF_CMD_SIG_END:\n\t\tcase BUF_CMD_S_TXMASK:\n\t\tcase BUF_CMD_S_RXSENSOR:\n\t\t\tdatasize = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn datasize;\n}\n\n \nstatic void fintek_process_rx_ir_data(struct fintek_dev *fintek)\n{\n\tstruct ir_raw_event rawir = {};\n\tu8 sample;\n\tbool event = false;\n\tint i;\n\n\tfor (i = 0; i < fintek->pkts; i++) {\n\t\tsample = fintek->buf[i];\n\t\tswitch (fintek->parser_state) {\n\t\tcase CMD_HEADER:\n\t\t\tfintek->cmd = sample;\n\t\t\tif ((fintek->cmd == BUF_COMMAND_HEADER) ||\n\t\t\t    ((fintek->cmd & BUF_COMMAND_MASK) !=\n\t\t\t     BUF_PULSE_BIT)) {\n\t\t\t\tfintek->parser_state = SUBCMD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfintek->rem = (fintek->cmd & BUF_LEN_MASK);\n\t\t\tfit_dbg(\"%s: rem: 0x%02x\", __func__, fintek->rem);\n\t\t\tif (fintek->rem)\n\t\t\t\tfintek->parser_state = PARSE_IRDATA;\n\t\t\telse\n\t\t\t\tir_raw_event_overflow(fintek->rdev);\n\t\t\tbreak;\n\t\tcase SUBCMD:\n\t\t\tfintek->rem = fintek_cmdsize(fintek->cmd, sample);\n\t\t\tfintek->parser_state = CMD_DATA;\n\t\t\tbreak;\n\t\tcase CMD_DATA:\n\t\t\tfintek->rem--;\n\t\t\tbreak;\n\t\tcase PARSE_IRDATA:\n\t\t\tfintek->rem--;\n\t\t\trawir.pulse = ((sample & BUF_PULSE_BIT) != 0);\n\t\t\trawir.duration = (sample & BUF_SAMPLE_MASK)\n\t\t\t\t\t  * CIR_SAMPLE_PERIOD;\n\n\t\t\tfit_dbg(\"Storing %s with duration %d\",\n\t\t\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\t\t\trawir.duration);\n\t\t\tif (ir_raw_event_store_with_filter(fintek->rdev,\n\t\t\t\t\t\t\t\t\t&rawir))\n\t\t\t\tevent = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((fintek->parser_state != CMD_HEADER) && !fintek->rem)\n\t\t\tfintek->parser_state = CMD_HEADER;\n\t}\n\n\tfintek->pkts = 0;\n\n\tif (event) {\n\t\tfit_dbg(\"Calling ir_raw_event_handle\");\n\t\tir_raw_event_handle(fintek->rdev);\n\t}\n}\n\n \nstatic void fintek_get_rx_ir_data(struct fintek_dev *fintek, u8 rx_irqs)\n{\n\tunsigned long flags;\n\tu8 sample, status;\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\n\t \n\tdo {\n\t\tsample = fintek_cir_reg_read(fintek, CIR_RX_DATA);\n\t\tfit_dbg(\"%s: sample: 0x%02x\", __func__, sample);\n\n\t\tfintek->buf[fintek->pkts] = sample;\n\t\tfintek->pkts++;\n\n\t\tstatus = fintek_cir_reg_read(fintek, CIR_STATUS);\n\t\tif (!(status & CIR_STATUS_IRQ_EN))\n\t\t\tbreak;\n\t} while (status & rx_irqs);\n\n\tfintek_process_rx_ir_data(fintek);\n\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n}\n\nstatic void fintek_cir_log_irqs(u8 status)\n{\n\tfit_pr(KERN_INFO, \"IRQ 0x%02x:%s%s%s%s%s\", status,\n\t\tstatus & CIR_STATUS_IRQ_EN\t? \" IRQEN\"\t: \"\",\n\t\tstatus & CIR_STATUS_TX_FINISH\t? \" TXF\"\t: \"\",\n\t\tstatus & CIR_STATUS_TX_UNDERRUN\t? \" TXU\"\t: \"\",\n\t\tstatus & CIR_STATUS_RX_TIMEOUT\t? \" RXTO\"\t: \"\",\n\t\tstatus & CIR_STATUS_RX_RECEIVE\t? \" RXOK\"\t: \"\");\n}\n\n \nstatic irqreturn_t fintek_cir_isr(int irq, void *data)\n{\n\tstruct fintek_dev *fintek = data;\n\tu8 status, rx_irqs;\n\n\tfit_dbg_verbose(\"%s firing\", __func__);\n\n\tfintek_config_mode_enable(fintek);\n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_config_mode_disable(fintek);\n\n\t \n\tstatus = fintek_cir_reg_read(fintek, CIR_STATUS);\n\tif (!(status & CIR_STATUS_IRQ_MASK) || status == 0xff) {\n\t\tfit_dbg_verbose(\"%s exiting, IRSTS 0x%02x\", __func__, status);\n\t\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_MASK, CIR_STATUS);\n\t\treturn IRQ_RETVAL(IRQ_NONE);\n\t}\n\n\tif (debug)\n\t\tfintek_cir_log_irqs(status);\n\n\trx_irqs = status & (CIR_STATUS_RX_RECEIVE | CIR_STATUS_RX_TIMEOUT);\n\tif (rx_irqs)\n\t\tfintek_get_rx_ir_data(fintek, rx_irqs);\n\n\t \n\tfintek_cir_reg_write(fintek, status, CIR_STATUS);\n\n\tfit_dbg_verbose(\"%s done\", __func__);\n\treturn IRQ_RETVAL(IRQ_HANDLED);\n}\n\nstatic void fintek_enable_cir(struct fintek_dev *fintek)\n{\n\t \n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_EN, CIR_STATUS);\n\n\tfintek_config_mode_enable(fintek);\n\n\t \n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_cr_write(fintek, LOGICAL_DEV_ENABLE, CIR_CR_DEV_EN);\n\n\tfintek_config_mode_disable(fintek);\n\n\t \n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_MASK, CIR_STATUS);\n\n\t \n\tfintek_enable_cir_irq(fintek);\n}\n\nstatic void fintek_disable_cir(struct fintek_dev *fintek)\n{\n\tfintek_config_mode_enable(fintek);\n\n\t \n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_cr_write(fintek, LOGICAL_DEV_DISABLE, CIR_CR_DEV_EN);\n\n\tfintek_config_mode_disable(fintek);\n}\n\nstatic int fintek_open(struct rc_dev *dev)\n{\n\tstruct fintek_dev *fintek = dev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\tfintek_enable_cir(fintek);\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n\n\treturn 0;\n}\n\nstatic void fintek_close(struct rc_dev *dev)\n{\n\tstruct fintek_dev *fintek = dev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\tfintek_disable_cir(fintek);\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n}\n\n \nstatic int fintek_probe(struct pnp_dev *pdev, const struct pnp_device_id *dev_id)\n{\n\tstruct fintek_dev *fintek;\n\tstruct rc_dev *rdev;\n\tint ret = -ENOMEM;\n\n\tfintek = kzalloc(sizeof(struct fintek_dev), GFP_KERNEL);\n\tif (!fintek)\n\t\treturn ret;\n\n\t \n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev)\n\t\tgoto exit_free_dev_rdev;\n\n\tret = -ENODEV;\n\t \n\tif (!pnp_port_valid(pdev, 0)) {\n\t\tdev_err(&pdev->dev, \"IR PNP Port not valid!\\n\");\n\t\tgoto exit_free_dev_rdev;\n\t}\n\n\tif (!pnp_irq_valid(pdev, 0)) {\n\t\tdev_err(&pdev->dev, \"IR PNP IRQ not valid!\\n\");\n\t\tgoto exit_free_dev_rdev;\n\t}\n\n\tfintek->cir_addr = pnp_port_start(pdev, 0);\n\tfintek->cir_irq  = pnp_irq(pdev, 0);\n\tfintek->cir_port_len = pnp_port_len(pdev, 0);\n\n\tfintek->cr_ip = CR_INDEX_PORT;\n\tfintek->cr_dp = CR_DATA_PORT;\n\n\tspin_lock_init(&fintek->fintek_lock);\n\n\tpnp_set_drvdata(pdev, fintek);\n\tfintek->pdev = pdev;\n\n\tret = fintek_hw_detect(fintek);\n\tif (ret)\n\t\tgoto exit_free_dev_rdev;\n\n\t \n\tfintek_config_mode_enable(fintek);\n\tfintek_cir_ldev_init(fintek);\n\tfintek_config_mode_disable(fintek);\n\n\t \n\tfintek_cir_regs_init(fintek);\n\n\t \n\trdev->priv = fintek;\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->open = fintek_open;\n\trdev->close = fintek_close;\n\trdev->device_name = FINTEK_DESCRIPTION;\n\trdev->input_phys = \"fintek/cir0\";\n\trdev->input_id.bustype = BUS_HOST;\n\trdev->input_id.vendor = VENDOR_ID_FINTEK;\n\trdev->input_id.product = fintek->chip_major;\n\trdev->input_id.version = fintek->chip_minor;\n\trdev->dev.parent = &pdev->dev;\n\trdev->driver_name = FINTEK_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\trdev->timeout = 1000;\n\t \n\trdev->rx_resolution = CIR_SAMPLE_PERIOD;\n\n\tfintek->rdev = rdev;\n\n\tret = -EBUSY;\n\t \n\tif (!request_region(fintek->cir_addr,\n\t\t\t    fintek->cir_port_len, FINTEK_DRIVER_NAME))\n\t\tgoto exit_free_dev_rdev;\n\n\tif (request_irq(fintek->cir_irq, fintek_cir_isr, IRQF_SHARED,\n\t\t\tFINTEK_DRIVER_NAME, (void *)fintek))\n\t\tgoto exit_free_cir_addr;\n\n\tret = rc_register_device(rdev);\n\tif (ret)\n\t\tgoto exit_free_irq;\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\tfit_pr(KERN_NOTICE, \"driver has been successfully loaded\\n\");\n\tif (debug)\n\t\tcir_dump_regs(fintek);\n\n\treturn 0;\n\nexit_free_irq:\n\tfree_irq(fintek->cir_irq, fintek);\nexit_free_cir_addr:\n\trelease_region(fintek->cir_addr, fintek->cir_port_len);\nexit_free_dev_rdev:\n\trc_free_device(rdev);\n\tkfree(fintek);\n\n\treturn ret;\n}\n\nstatic void fintek_remove(struct pnp_dev *pdev)\n{\n\tstruct fintek_dev *fintek = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\t \n\tfintek_disable_cir(fintek);\n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_MASK, CIR_STATUS);\n\t \n\tfintek_enable_wake(fintek);\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n\n\t \n\tfree_irq(fintek->cir_irq, fintek);\n\trelease_region(fintek->cir_addr, fintek->cir_port_len);\n\n\trc_unregister_device(fintek->rdev);\n\n\tkfree(fintek);\n}\n\nstatic int fintek_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\tstruct fintek_dev *fintek = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tfit_dbg(\"%s called\", __func__);\n\n\tspin_lock_irqsave(&fintek->fintek_lock, flags);\n\n\t \n\tfintek_cir_reg_write(fintek, CIR_STATUS_IRQ_MASK, CIR_STATUS);\n\n\tspin_unlock_irqrestore(&fintek->fintek_lock, flags);\n\n\tfintek_config_mode_enable(fintek);\n\n\t \n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_cr_write(fintek, LOGICAL_DEV_DISABLE, CIR_CR_DEV_EN);\n\n\tfintek_config_mode_disable(fintek);\n\n\t \n\tfintek_enable_wake(fintek);\n\n\treturn 0;\n}\n\nstatic int fintek_resume(struct pnp_dev *pdev)\n{\n\tstruct fintek_dev *fintek = pnp_get_drvdata(pdev);\n\n\tfit_dbg(\"%s called\", __func__);\n\n\t \n\tfintek_enable_cir_irq(fintek);\n\n\t \n\tfintek_config_mode_enable(fintek);\n\tfintek_select_logical_dev(fintek, fintek->logical_dev_cir);\n\tfintek_cr_write(fintek, LOGICAL_DEV_ENABLE, CIR_CR_DEV_EN);\n\n\tfintek_config_mode_disable(fintek);\n\n\tfintek_cir_regs_init(fintek);\n\n\treturn 0;\n}\n\nstatic void fintek_shutdown(struct pnp_dev *pdev)\n{\n\tstruct fintek_dev *fintek = pnp_get_drvdata(pdev);\n\tfintek_enable_wake(fintek);\n}\n\nstatic const struct pnp_device_id fintek_ids[] = {\n\t{ \"FIT0002\", 0 },    \n\t{ \"\", 0 },\n};\n\nstatic struct pnp_driver fintek_driver = {\n\t.name\t\t= FINTEK_DRIVER_NAME,\n\t.id_table\t= fintek_ids,\n\t.flags\t\t= PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.probe\t\t= fintek_probe,\n\t.remove\t\t= fintek_remove,\n\t.suspend\t= fintek_suspend,\n\t.resume\t\t= fintek_resume,\n\t.shutdown\t= fintek_shutdown,\n};\n\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Enable debugging output\");\n\nMODULE_DEVICE_TABLE(pnp, fintek_ids);\nMODULE_DESCRIPTION(FINTEK_DESCRIPTION \" driver\");\n\nMODULE_AUTHOR(\"Jarod Wilson <jarod@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(fintek_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}