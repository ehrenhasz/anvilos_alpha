{
  "module_name": "mtk-cir.c",
  "hash_id": "7b1052dbfa7529d5aa9b9583f25e022e41e95297005399e2234bfc4bc11c7d90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/mtk-cir.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <media/rc-core.h>\n\n#define MTK_IR_DEV KBUILD_MODNAME\n\n \n#define MTK_CONFIG_HIGH_REG       0x0c\n\n \n#define MTK_PWM_EN\t\t  BIT(13)\n\n \n#define MTK_OK_COUNT_MASK\t  (GENMASK(22, 16))\n#define MTK_OK_COUNT(x)\t\t  ((x) << 16)\n\n \n#define MTK_IR_EN\t\t  BIT(0)\n\n \n#define MTK_IRCLR\t\t  BIT(0)\n\n \n#define MTK_WIDTH_MASK\t\t  (GENMASK(7, 0))\n\n \n#define MTK_IRTHD\t\t 0x14\n#define MTK_DG_CNT_MASK\t\t (GENMASK(12, 8))\n#define MTK_DG_CNT(x)\t\t ((x) << 8)\n\n \n#define MTK_IRINT_EN\t\t  BIT(0)\n\n \n#define MTK_IRINT_CLR\t\t  BIT(0)\n\n \n#define MTK_MAX_SAMPLES\t\t  0xff\n \n#define MTK_IR_END(v, p)\t  ((v) == MTK_MAX_SAMPLES && (p) == 0)\n \n#define MTK_CHKDATA_SZ\t\t  17\n \n#define MTK_IR_SAMPLE\t\t  46\n\nenum mtk_fields {\n\t \n\tMTK_CHK_PERIOD,\n\t \n\tMTK_HW_PERIOD,\n};\n\nenum mtk_regs {\n\t \n\tMTK_IRCLR_REG,\n\t \n\tMTK_CHKDATA_REG,\n\t \n\tMTK_IRINT_EN_REG,\n\t \n\tMTK_IRINT_CLR_REG\n};\n\nstatic const u32 mt7623_regs[] = {\n\t[MTK_IRCLR_REG] =\t0x20,\n\t[MTK_CHKDATA_REG] =\t0x88,\n\t[MTK_IRINT_EN_REG] =\t0xcc,\n\t[MTK_IRINT_CLR_REG] =\t0xd0,\n};\n\nstatic const u32 mt7622_regs[] = {\n\t[MTK_IRCLR_REG] =\t0x18,\n\t[MTK_CHKDATA_REG] =\t0x30,\n\t[MTK_IRINT_EN_REG] =\t0x1c,\n\t[MTK_IRINT_CLR_REG] =\t0x20,\n};\n\nstruct mtk_field_type {\n\tu32 reg;\n\tu8 offset;\n\tu32 mask;\n};\n\n \nstruct mtk_ir_data {\n\tconst u32 *regs;\n\tconst struct mtk_field_type *fields;\n\tu8 div;\n\tu8 ok_count;\n\tu32 hw_period;\n};\n\nstatic const struct mtk_field_type mt7623_fields[] = {\n\t[MTK_CHK_PERIOD] = {0x10, 8, GENMASK(20, 8)},\n\t[MTK_HW_PERIOD] = {0x10, 0, GENMASK(7, 0)},\n};\n\nstatic const struct mtk_field_type mt7622_fields[] = {\n\t[MTK_CHK_PERIOD] = {0x24, 0, GENMASK(24, 0)},\n\t[MTK_HW_PERIOD] = {0x10, 0, GENMASK(24, 0)},\n};\n\n \nstruct mtk_ir {\n\tstruct device\t*dev;\n\tstruct rc_dev\t*rc;\n\tvoid __iomem\t*base;\n\tint\t\tirq;\n\tstruct clk\t*clk;\n\tstruct clk\t*bus;\n\tconst struct mtk_ir_data *data;\n};\n\nstatic inline u32 mtk_chkdata_reg(struct mtk_ir *ir, u32 i)\n{\n\treturn ir->data->regs[MTK_CHKDATA_REG] + 4 * i;\n}\n\nstatic inline u32 mtk_chk_period(struct mtk_ir *ir)\n{\n\tu32 val;\n\n\t \n\tval = DIV_ROUND_CLOSEST(clk_get_rate(ir->bus),\n\t\t\t\tUSEC_PER_SEC * ir->data->div / MTK_IR_SAMPLE);\n\n\tdev_dbg(ir->dev, \"@pwm clk  = \\t%lu\\n\",\n\t\tclk_get_rate(ir->bus) / ir->data->div);\n\tdev_dbg(ir->dev, \"@chkperiod = %08x\\n\", val);\n\n\treturn val;\n}\n\nstatic void mtk_w32_mask(struct mtk_ir *ir, u32 val, u32 mask, unsigned int reg)\n{\n\tu32 tmp;\n\n\ttmp = __raw_readl(ir->base + reg);\n\ttmp = (tmp & ~mask) | val;\n\t__raw_writel(tmp, ir->base + reg);\n}\n\nstatic void mtk_w32(struct mtk_ir *ir, u32 val, unsigned int reg)\n{\n\t__raw_writel(val, ir->base + reg);\n}\n\nstatic u32 mtk_r32(struct mtk_ir *ir, unsigned int reg)\n{\n\treturn __raw_readl(ir->base + reg);\n}\n\nstatic inline void mtk_irq_disable(struct mtk_ir *ir, u32 mask)\n{\n\tu32 val;\n\n\tval = mtk_r32(ir, ir->data->regs[MTK_IRINT_EN_REG]);\n\tmtk_w32(ir, val & ~mask, ir->data->regs[MTK_IRINT_EN_REG]);\n}\n\nstatic inline void mtk_irq_enable(struct mtk_ir *ir, u32 mask)\n{\n\tu32 val;\n\n\tval = mtk_r32(ir, ir->data->regs[MTK_IRINT_EN_REG]);\n\tmtk_w32(ir, val | mask, ir->data->regs[MTK_IRINT_EN_REG]);\n}\n\nstatic irqreturn_t mtk_ir_irq(int irqno, void *dev_id)\n{\n\tstruct ir_raw_event rawir = {};\n\tstruct mtk_ir *ir = dev_id;\n\tu32 i, j, val;\n\tu8 wid;\n\n\t \n\n\t \n\tfor (i = 0 ; i < MTK_CHKDATA_SZ ; i++) {\n\t\tval = mtk_r32(ir, mtk_chkdata_reg(ir, i));\n\t\tdev_dbg(ir->dev, \"@reg%d=0x%08x\\n\", i, val);\n\n\t\tfor (j = 0 ; j < 4 ; j++) {\n\t\t\twid = val & MTK_WIDTH_MASK;\n\t\t\tval >>= 8;\n\t\t\trawir.pulse = !rawir.pulse;\n\t\t\trawir.duration = wid * (MTK_IR_SAMPLE + 1);\n\t\t\tir_raw_event_store_with_filter(ir->rc, &rawir);\n\t\t}\n\t}\n\n\t \n\tif (!MTK_IR_END(wid, rawir.pulse)) {\n\t\trawir.pulse = false;\n\t\trawir.duration = MTK_MAX_SAMPLES * (MTK_IR_SAMPLE + 1);\n\t\tir_raw_event_store_with_filter(ir->rc, &rawir);\n\t}\n\n\tir_raw_event_handle(ir->rc);\n\n\t \n\tmtk_w32_mask(ir, 0x1, MTK_IRCLR, ir->data->regs[MTK_IRCLR_REG]);\n\n\t \n\tmtk_w32_mask(ir, 0x1, MTK_IRINT_CLR,\n\t\t     ir->data->regs[MTK_IRINT_CLR_REG]);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct mtk_ir_data mt7623_data = {\n\t.regs = mt7623_regs,\n\t.fields = mt7623_fields,\n\t.ok_count = 3,\n\t.hw_period = 0xff,\n\t.div\t= 4,\n};\n\nstatic const struct mtk_ir_data mt7622_data = {\n\t.regs = mt7622_regs,\n\t.fields = mt7622_fields,\n\t.ok_count = 3,\n\t.hw_period = 0xffff,\n\t.div\t= 32,\n};\n\nstatic const struct of_device_id mtk_ir_match[] = {\n\t{ .compatible = \"mediatek,mt7623-cir\", .data = &mt7623_data},\n\t{ .compatible = \"mediatek,mt7622-cir\", .data = &mt7622_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_ir_match);\n\nstatic int mtk_ir_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node;\n\tstruct mtk_ir *ir;\n\tu32 val;\n\tint ret = 0;\n\tconst char *map_name;\n\n\tir = devm_kzalloc(dev, sizeof(struct mtk_ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tir->dev = dev;\n\tir->data = of_device_get_match_data(dev);\n\n\tir->clk = devm_clk_get(dev, \"clk\");\n\tif (IS_ERR(ir->clk)) {\n\t\tdev_err(dev, \"failed to get a ir clock.\\n\");\n\t\treturn PTR_ERR(ir->clk);\n\t}\n\n\tir->bus = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(ir->bus)) {\n\t\t \n\t\tir->bus = ir->clk;\n\t}\n\n\tir->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ir->base))\n\t\treturn PTR_ERR(ir->base);\n\n\tir->rc = devm_rc_allocate_device(dev, RC_DRIVER_IR_RAW);\n\tif (!ir->rc) {\n\t\tdev_err(dev, \"failed to allocate device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tir->rc->priv = ir;\n\tir->rc->device_name = MTK_IR_DEV;\n\tir->rc->input_phys = MTK_IR_DEV \"/input0\";\n\tir->rc->input_id.bustype = BUS_HOST;\n\tir->rc->input_id.vendor = 0x0001;\n\tir->rc->input_id.product = 0x0001;\n\tir->rc->input_id.version = 0x0001;\n\tmap_name = of_get_property(dn, \"linux,rc-map-name\", NULL);\n\tir->rc->map_name = map_name ?: RC_MAP_EMPTY;\n\tir->rc->dev.parent = dev;\n\tir->rc->driver_name = MTK_IR_DEV;\n\tir->rc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\tir->rc->rx_resolution = MTK_IR_SAMPLE;\n\tir->rc->timeout = MTK_MAX_SAMPLES * (MTK_IR_SAMPLE + 1);\n\n\tret = devm_rc_register_device(dev, ir->rc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register rc device\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, ir);\n\n\tir->irq = platform_get_irq(pdev, 0);\n\tif (ir->irq < 0)\n\t\treturn -ENODEV;\n\n\tif (clk_prepare_enable(ir->clk)) {\n\t\tdev_err(dev, \"try to enable ir_clk failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_prepare_enable(ir->bus)) {\n\t\tdev_err(dev, \"try to enable ir_clk failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit_clkdisable_clk;\n\t}\n\n\t \n\tmtk_irq_disable(ir, MTK_IRINT_EN);\n\n\tret = devm_request_irq(dev, ir->irq, mtk_ir_irq, 0, MTK_IR_DEV, ir);\n\tif (ret) {\n\t\tdev_err(dev, \"failed request irq\\n\");\n\t\tgoto exit_clkdisable_bus;\n\t}\n\n\t \n\tval = (mtk_chk_period(ir) << ir->data->fields[MTK_CHK_PERIOD].offset) &\n\t       ir->data->fields[MTK_CHK_PERIOD].mask;\n\tmtk_w32_mask(ir, val, ir->data->fields[MTK_CHK_PERIOD].mask,\n\t\t     ir->data->fields[MTK_CHK_PERIOD].reg);\n\n\t \n\tval = (ir->data->hw_period << ir->data->fields[MTK_HW_PERIOD].offset) &\n\t       ir->data->fields[MTK_HW_PERIOD].mask;\n\tmtk_w32_mask(ir, val, ir->data->fields[MTK_HW_PERIOD].mask,\n\t\t     ir->data->fields[MTK_HW_PERIOD].reg);\n\n\t \n\tmtk_w32_mask(ir, MTK_DG_CNT(1), MTK_DG_CNT_MASK, MTK_IRTHD);\n\n\t \n\tval = mtk_r32(ir, MTK_CONFIG_HIGH_REG) & ~MTK_OK_COUNT_MASK;\n\tval |= MTK_OK_COUNT(ir->data->ok_count) |  MTK_PWM_EN | MTK_IR_EN;\n\tmtk_w32(ir, val, MTK_CONFIG_HIGH_REG);\n\n\tmtk_irq_enable(ir, MTK_IRINT_EN);\n\n\tdev_info(dev, \"Initialized MT7623 IR driver, sample period = %dus\\n\",\n\t\t MTK_IR_SAMPLE);\n\n\treturn 0;\n\nexit_clkdisable_bus:\n\tclk_disable_unprepare(ir->bus);\nexit_clkdisable_clk:\n\tclk_disable_unprepare(ir->clk);\n\n\treturn ret;\n}\n\nstatic void mtk_ir_remove(struct platform_device *pdev)\n{\n\tstruct mtk_ir *ir = platform_get_drvdata(pdev);\n\n\t \n\tmtk_irq_disable(ir, MTK_IRINT_EN);\n\tsynchronize_irq(ir->irq);\n\n\tclk_disable_unprepare(ir->bus);\n\tclk_disable_unprepare(ir->clk);\n}\n\nstatic struct platform_driver mtk_ir_driver = {\n\t.probe          = mtk_ir_probe,\n\t.remove_new     = mtk_ir_remove,\n\t.driver = {\n\t\t.name = MTK_IR_DEV,\n\t\t.of_match_table = mtk_ir_match,\n\t},\n};\n\nmodule_platform_driver(mtk_ir_driver);\n\nMODULE_DESCRIPTION(\"Mediatek IR Receiver Controller Driver\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}