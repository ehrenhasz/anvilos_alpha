{
  "module_name": "imon.c",
  "hash_id": "02fde2e4fd6728ad3071f5253a0c6e652dfe857393dca315d923874d6fe9dee9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/imon.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ratelimit.h>\n\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n#include <linux/timer.h>\n\n#define MOD_AUTHOR\t\"Jarod Wilson <jarod@wilsonet.com>\"\n#define MOD_DESC\t\"Driver for SoundGraph iMON MultiMedia IR/Display\"\n#define MOD_NAME\t\"imon\"\n#define MOD_VERSION\t\"0.9.4\"\n\n#define DISPLAY_MINOR_BASE\t144\n#define DEVICE_NAME\t\"lcd%d\"\n\n#define BUF_CHUNK_SIZE\t8\n#define BUF_SIZE\t128\n\n#define BIT_DURATION\t250\t \n\n#define IMON_CLOCK_ENABLE_PACKETS\t2\n\n \n\n \nstatic int imon_probe(struct usb_interface *interface,\n\t\t      const struct usb_device_id *id);\nstatic void imon_disconnect(struct usb_interface *interface);\nstatic void usb_rx_callback_intf0(struct urb *urb);\nstatic void usb_rx_callback_intf1(struct urb *urb);\nstatic void usb_tx_callback(struct urb *urb);\n\n \nstatic int imon_resume(struct usb_interface *intf);\nstatic int imon_suspend(struct usb_interface *intf, pm_message_t message);\n\n \nstatic int display_open(struct inode *inode, struct file *file);\nstatic int display_close(struct inode *inode, struct file *file);\n\n \nstatic ssize_t vfd_write(struct file *file, const char __user *buf,\n\t\t\t size_t n_bytes, loff_t *pos);\n\n \nstatic ssize_t lcd_write(struct file *file, const char __user *buf,\n\t\t\t size_t n_bytes, loff_t *pos);\n\n \n\nstruct imon_panel_key_table {\n\tu64 hw_code;\n\tu32 keycode;\n};\n\nstruct imon_usb_dev_descr {\n\t__u16 flags;\n#define IMON_NO_FLAGS 0\n#define IMON_NEED_20MS_PKT_DELAY 1\n#define IMON_SUPPRESS_REPEATED_KEYS 2\n\tstruct imon_panel_key_table key_table[];\n};\n\nstruct imon_context {\n\tstruct device *dev;\n\t \n\tstruct usb_device *usbdev_intf0;\n\tstruct usb_device *usbdev_intf1;\n\n\tbool display_supported;\t\t \n\tbool display_isopen;\t\t \n\tbool rf_device;\t\t\t \n\tbool rf_isassociating;\t\t \n\tbool dev_present_intf0;\t\t \n\tbool dev_present_intf1;\t\t \n\n\tstruct mutex lock;\t\t \n\twait_queue_head_t remove_ok;\t \n\n\tstruct usb_endpoint_descriptor *rx_endpoint_intf0;\n\tstruct usb_endpoint_descriptor *rx_endpoint_intf1;\n\tstruct usb_endpoint_descriptor *tx_endpoint;\n\tstruct urb *rx_urb_intf0;\n\tstruct urb *rx_urb_intf1;\n\tstruct urb *tx_urb;\n\tbool tx_control;\n\tunsigned char usb_rx_buf[8];\n\tunsigned char usb_tx_buf[8];\n\tunsigned int send_packet_delay;\n\n\tstruct tx_t {\n\t\tunsigned char data_buf[35];\t \n\t\tstruct completion finished;\t \n\t\tbool busy;\t\t\t \n\t\tint status;\t\t\t \n\t} tx;\n\n\tu16 vendor;\t\t\t \n\tu16 product;\t\t\t \n\n\tstruct rc_dev *rdev;\t\t \n\tstruct input_dev *idev;\t\t \n\tstruct input_dev *touch;\t \n\n\tspinlock_t kc_lock;\t\t \n\tu32 kc;\t\t\t\t \n\tu32 last_keycode;\t\t \n\tu32 rc_scancode;\t\t \n\tu8 rc_toggle;\t\t\t \n\tu64 rc_proto;\t\t\t \n\tbool release_code;\t\t \n\n\tu8 display_type;\t\t \n\tbool pad_mouse;\t\t\t \n\n\tchar name_rdev[128];\t\t \n\tchar phys_rdev[64];\t\t \n\n\tchar name_idev[128];\t\t \n\tchar phys_idev[64];\t\t \n\n\tchar name_touch[128];\t\t \n\tchar phys_touch[64];\t\t \n\tstruct timer_list ttimer;\t \n\tint touch_x;\t\t\t \n\tint touch_y;\t\t\t \n\tconst struct imon_usb_dev_descr *dev_descr;\n\t\t\t\t\t \n\t\t\t\t\t \n\t \n\trefcount_t users;\n\t \n\tbool disconnected;\n\t \n\tstruct rcu_head rcu;\n};\n\n#define TOUCH_TIMEOUT\t(HZ/30)\n\n \nstatic const struct file_operations vfd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= display_open,\n\t.write\t\t= vfd_write,\n\t.release\t= display_close,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic const struct file_operations lcd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= display_open,\n\t.write\t\t= lcd_write,\n\t.release\t= display_close,\n\t.llseek\t\t= noop_llseek,\n};\n\nenum {\n\tIMON_DISPLAY_TYPE_AUTO = 0,\n\tIMON_DISPLAY_TYPE_VFD  = 1,\n\tIMON_DISPLAY_TYPE_LCD  = 2,\n\tIMON_DISPLAY_TYPE_VGA  = 3,\n\tIMON_DISPLAY_TYPE_NONE = 4,\n};\n\nenum {\n\tIMON_KEY_IMON\t= 0,\n\tIMON_KEY_MCE\t= 1,\n\tIMON_KEY_PANEL\t= 2,\n};\n\nstatic struct usb_class_driver imon_vfd_class = {\n\t.name\t\t= DEVICE_NAME,\n\t.fops\t\t= &vfd_fops,\n\t.minor_base\t= DISPLAY_MINOR_BASE,\n};\n\nstatic struct usb_class_driver imon_lcd_class = {\n\t.name\t\t= DEVICE_NAME,\n\t.fops\t\t= &lcd_fops,\n\t.minor_base\t= DISPLAY_MINOR_BASE,\n};\n\n \nstatic const struct imon_usb_dev_descr imon_default_table = {\n\t.flags = IMON_NO_FLAGS,\n\t.key_table = {\n\t\t{ 0x000000000f00ffeell, KEY_MEDIA },  \n\t\t{ 0x000000001200ffeell, KEY_UP },\n\t\t{ 0x000000001300ffeell, KEY_DOWN },\n\t\t{ 0x000000001400ffeell, KEY_LEFT },\n\t\t{ 0x000000001500ffeell, KEY_RIGHT },\n\t\t{ 0x000000001600ffeell, KEY_ENTER },\n\t\t{ 0x000000001700ffeell, KEY_ESC },\n\t\t{ 0x000000001f00ffeell, KEY_AUDIO },\n\t\t{ 0x000000002000ffeell, KEY_VIDEO },\n\t\t{ 0x000000002100ffeell, KEY_CAMERA },\n\t\t{ 0x000000002700ffeell, KEY_DVD },\n\t\t{ 0x000000002300ffeell, KEY_TV },\n\t\t{ 0x000000002b00ffeell, KEY_EXIT },\n\t\t{ 0x000000002c00ffeell, KEY_SELECT },\n\t\t{ 0x000000002d00ffeell, KEY_MENU },\n\t\t{ 0x000000000500ffeell, KEY_PREVIOUS },\n\t\t{ 0x000000000700ffeell, KEY_REWIND },\n\t\t{ 0x000000000400ffeell, KEY_STOP },\n\t\t{ 0x000000003c00ffeell, KEY_PLAYPAUSE },\n\t\t{ 0x000000000800ffeell, KEY_FASTFORWARD },\n\t\t{ 0x000000000600ffeell, KEY_NEXT },\n\t\t{ 0x000000010000ffeell, KEY_RIGHT },\n\t\t{ 0x000001000000ffeell, KEY_LEFT },\n\t\t{ 0x000000003d00ffeell, KEY_SELECT },\n\t\t{ 0x000100000000ffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000000000ffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000000000100ffeell, KEY_MUTE },\n\t\t \n\t\t{ 0x00010000ffffffeell, KEY_VOLUMEUP },\n\t\t{ 0x01000000ffffffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x00000001ffffffeell, KEY_MUTE },\n\t\t{ 0x0000000fffffffeell, KEY_MEDIA },\n\t\t{ 0x00000012ffffffeell, KEY_UP },\n\t\t{ 0x00000013ffffffeell, KEY_DOWN },\n\t\t{ 0x00000014ffffffeell, KEY_LEFT },\n\t\t{ 0x00000015ffffffeell, KEY_RIGHT },\n\t\t{ 0x00000016ffffffeell, KEY_ENTER },\n\t\t{ 0x00000017ffffffeell, KEY_ESC },\n\t\t \n\t\t{ 0x000100ffffffffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000ffffffffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000008ffffffffeell, KEY_MUTE },\n\t\t{ 0, KEY_RESERVED },\n\t}\n};\n\nstatic const struct imon_usb_dev_descr imon_OEM_VFD = {\n\t.flags = IMON_NEED_20MS_PKT_DELAY,\n\t.key_table = {\n\t\t{ 0x000000000f00ffeell, KEY_MEDIA },  \n\t\t{ 0x000000001200ffeell, KEY_UP },\n\t\t{ 0x000000001300ffeell, KEY_DOWN },\n\t\t{ 0x000000001400ffeell, KEY_LEFT },\n\t\t{ 0x000000001500ffeell, KEY_RIGHT },\n\t\t{ 0x000000001600ffeell, KEY_ENTER },\n\t\t{ 0x000000001700ffeell, KEY_ESC },\n\t\t{ 0x000000001f00ffeell, KEY_AUDIO },\n\t\t{ 0x000000002b00ffeell, KEY_EXIT },\n\t\t{ 0x000000002c00ffeell, KEY_SELECT },\n\t\t{ 0x000000002d00ffeell, KEY_MENU },\n\t\t{ 0x000000000500ffeell, KEY_PREVIOUS },\n\t\t{ 0x000000000700ffeell, KEY_REWIND },\n\t\t{ 0x000000000400ffeell, KEY_STOP },\n\t\t{ 0x000000003c00ffeell, KEY_PLAYPAUSE },\n\t\t{ 0x000000000800ffeell, KEY_FASTFORWARD },\n\t\t{ 0x000000000600ffeell, KEY_NEXT },\n\t\t{ 0x000000010000ffeell, KEY_RIGHT },\n\t\t{ 0x000001000000ffeell, KEY_LEFT },\n\t\t{ 0x000000003d00ffeell, KEY_SELECT },\n\t\t{ 0x000100000000ffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000000000ffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000000000100ffeell, KEY_MUTE },\n\t\t \n\t\t{ 0x00010000ffffffeell, KEY_VOLUMEUP },\n\t\t{ 0x01000000ffffffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x00000001ffffffeell, KEY_MUTE },\n\t\t{ 0x0000000fffffffeell, KEY_MEDIA },\n\t\t{ 0x00000012ffffffeell, KEY_UP },\n\t\t{ 0x00000013ffffffeell, KEY_DOWN },\n\t\t{ 0x00000014ffffffeell, KEY_LEFT },\n\t\t{ 0x00000015ffffffeell, KEY_RIGHT },\n\t\t{ 0x00000016ffffffeell, KEY_ENTER },\n\t\t{ 0x00000017ffffffeell, KEY_ESC },\n\t\t \n\t\t{ 0x000100ffffffffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000ffffffffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000008ffffffffeell, KEY_MUTE },\n\t\t{ 0, KEY_RESERVED },\n\t}\n};\n\n \nstatic const struct imon_usb_dev_descr imon_DH102 = {\n\t.flags = IMON_NO_FLAGS,\n\t.key_table = {\n\t\t{ 0x000100000000ffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000000000ffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000000010000ffeell, KEY_MUTE },\n\t\t{ 0x0000000f0000ffeell, KEY_MEDIA },\n\t\t{ 0x000000120000ffeell, KEY_UP },\n\t\t{ 0x000000130000ffeell, KEY_DOWN },\n\t\t{ 0x000000140000ffeell, KEY_LEFT },\n\t\t{ 0x000000150000ffeell, KEY_RIGHT },\n\t\t{ 0x000000160000ffeell, KEY_ENTER },\n\t\t{ 0x000000170000ffeell, KEY_ESC },\n\t\t{ 0x0000002b0000ffeell, KEY_EXIT },\n\t\t{ 0x0000002c0000ffeell, KEY_SELECT },\n\t\t{ 0x0000002d0000ffeell, KEY_MENU },\n\t\t{ 0, KEY_RESERVED }\n\t}\n};\n\n \nstatic const struct imon_usb_dev_descr ultrabay_table = {\n\t.flags = IMON_SUPPRESS_REPEATED_KEYS,\n\t.key_table = {\n\t\t{ 0x0000000f0000ffeell, KEY_MEDIA },       \n\t\t{ 0x000000000100ffeell, KEY_UP },\n\t\t{ 0x000000000001ffeell, KEY_DOWN },\n\t\t{ 0x000000160000ffeell, KEY_ENTER },\n\t\t{ 0x0000001f0000ffeell, KEY_AUDIO },       \n\t\t{ 0x000000200000ffeell, KEY_VIDEO },       \n\t\t{ 0x000000210000ffeell, KEY_CAMERA },      \n\t\t{ 0x000000270000ffeell, KEY_DVD },         \n\t\t{ 0x000000230000ffeell, KEY_TV },          \n\t\t{ 0x000000050000ffeell, KEY_PREVIOUS },    \n\t\t{ 0x000000070000ffeell, KEY_REWIND },\n\t\t{ 0x000000040000ffeell, KEY_STOP },\n\t\t{ 0x000000020000ffeell, KEY_PLAYPAUSE },\n\t\t{ 0x000000080000ffeell, KEY_FASTFORWARD },\n\t\t{ 0x000000060000ffeell, KEY_NEXT },        \n\t\t{ 0x000100000000ffeell, KEY_VOLUMEUP },\n\t\t{ 0x010000000000ffeell, KEY_VOLUMEDOWN },\n\t\t{ 0x000000010000ffeell, KEY_MUTE },\n\t\t{ 0, KEY_RESERVED },\n\t}\n};\n\n \nstatic const struct usb_device_id imon_usb_id_table[] = {\n\t \n\t{ USB_DEVICE(0x15c2, 0xffdc),\n\t  .driver_info = (unsigned long)&imon_default_table },\n\n\t \n\t \n\t{ USB_DEVICE(0x15c2, 0x0034),\n\t  .driver_info = (unsigned long)&imon_DH102 },\n\t \n\t{ USB_DEVICE(0x15c2, 0x0035),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0036),\n\t  .driver_info = (unsigned long)&imon_OEM_VFD },\n\t \n\t{ USB_DEVICE(0x15c2, 0x0037),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0038),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0039),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003a),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003b),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003c),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003d),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003e),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x003f),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0040),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0041),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0042),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0043),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0044),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0045),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t \n\t{ USB_DEVICE(0x15c2, 0x0046),\n\t  .driver_info = (unsigned long)&imon_default_table},\n\t{}\n};\n\n \nstatic struct usb_driver imon_driver = {\n\t.name\t\t= MOD_NAME,\n\t.probe\t\t= imon_probe,\n\t.disconnect\t= imon_disconnect,\n\t.suspend\t= imon_suspend,\n\t.resume\t\t= imon_resume,\n\t.id_table\t= imon_usb_id_table,\n};\n\n \nMODULE_AUTHOR(MOD_AUTHOR);\nMODULE_DESCRIPTION(MOD_DESC);\nMODULE_VERSION(MOD_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, imon_usb_id_table);\n\nstatic bool debug;\nmodule_param(debug, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug messages: 0=no, 1=yes (default: no)\");\n\n \nstatic int display_type;\nmodule_param(display_type, int, S_IRUGO);\nMODULE_PARM_DESC(display_type, \"Type of attached display. 0=autodetect, 1=vfd, 2=lcd, 3=vga, 4=none (default: autodetect)\");\n\nstatic int pad_stabilize = 1;\nmodule_param(pad_stabilize, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(pad_stabilize, \"Apply stabilization algorithm to iMON PAD presses in arrow key mode. 0=disable, 1=enable (default).\");\n\n \nstatic bool nomouse;\nmodule_param(nomouse, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(nomouse, \"Disable mouse input device mode when IR device is open. 0=don't disable, 1=disable. (default: don't disable)\");\n\n \nstatic int pad_thresh;\nmodule_param(pad_thresh, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(pad_thresh, \"Threshold at which a pad push registers as an arrow key in kbd mode (default: 28)\");\n\n\nstatic void free_imon_context(struct imon_context *ictx)\n{\n\tstruct device *dev = ictx->dev;\n\n\tusb_free_urb(ictx->tx_urb);\n\tWARN_ON(ictx->dev_present_intf0);\n\tusb_free_urb(ictx->rx_urb_intf0);\n\tWARN_ON(ictx->dev_present_intf1);\n\tusb_free_urb(ictx->rx_urb_intf1);\n\tkfree_rcu(ictx, rcu);\n\n\tdev_dbg(dev, \"%s: iMON context freed\\n\", __func__);\n}\n\n \nstatic int display_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_interface *interface;\n\tstruct imon_context *ictx = NULL;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\tinterface = usb_find_interface(&imon_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"could not find interface for minor %d\\n\", subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\trcu_read_lock();\n\tictx = usb_get_intfdata(interface);\n\tif (!ictx || ictx->disconnected || !refcount_inc_not_zero(&ictx->users)) {\n\t\trcu_read_unlock();\n\t\tpr_err(\"no context found for minor %d\\n\", subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock(&ictx->lock);\n\n\tif (!ictx->display_supported) {\n\t\tpr_err(\"display not supported by device\\n\");\n\t\tretval = -ENODEV;\n\t} else if (ictx->display_isopen) {\n\t\tpr_err(\"display port is already open\\n\");\n\t\tretval = -EBUSY;\n\t} else {\n\t\tictx->display_isopen = true;\n\t\tfile->private_data = ictx;\n\t\tdev_dbg(ictx->dev, \"display port opened\\n\");\n\t}\n\n\tmutex_unlock(&ictx->lock);\n\n\tif (retval && refcount_dec_and_test(&ictx->users))\n\t\tfree_imon_context(ictx);\n\nexit:\n\treturn retval;\n}\n\n \nstatic int display_close(struct inode *inode, struct file *file)\n{\n\tstruct imon_context *ictx = file->private_data;\n\tint retval = 0;\n\n\tmutex_lock(&ictx->lock);\n\n\tif (!ictx->display_supported) {\n\t\tpr_err(\"display not supported by device\\n\");\n\t\tretval = -ENODEV;\n\t} else if (!ictx->display_isopen) {\n\t\tpr_err(\"display is not open\\n\");\n\t\tretval = -EIO;\n\t} else {\n\t\tictx->display_isopen = false;\n\t\tdev_dbg(ictx->dev, \"display port closed\\n\");\n\t}\n\n\tmutex_unlock(&ictx->lock);\n\tif (refcount_dec_and_test(&ictx->users))\n\t\tfree_imon_context(ictx);\n\treturn retval;\n}\n\n \nstatic int send_packet(struct imon_context *ictx)\n{\n\tunsigned int pipe;\n\tunsigned long timeout;\n\tint interval = 0;\n\tint retval = 0;\n\tstruct usb_ctrlrequest *control_req = NULL;\n\n\t \n\tif (!ictx->tx_control) {\n\t\tpipe = usb_sndintpipe(ictx->usbdev_intf0,\n\t\t\t\t      ictx->tx_endpoint->bEndpointAddress);\n\t\tinterval = ictx->tx_endpoint->bInterval;\n\n\t\tusb_fill_int_urb(ictx->tx_urb, ictx->usbdev_intf0, pipe,\n\t\t\t\t ictx->usb_tx_buf,\n\t\t\t\t sizeof(ictx->usb_tx_buf),\n\t\t\t\t usb_tx_callback, ictx, interval);\n\n\t\tictx->tx_urb->actual_length = 0;\n\t} else {\n\t\t \n\t\tcontrol_req = kmalloc(sizeof(*control_req), GFP_KERNEL);\n\t\tif (control_req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tcontrol_req->bRequestType = 0x21;\n\t\tcontrol_req->bRequest = 0x09;\n\t\tcontrol_req->wValue = cpu_to_le16(0x0200);\n\t\tcontrol_req->wIndex = cpu_to_le16(0x0001);\n\t\tcontrol_req->wLength = cpu_to_le16(0x0008);\n\n\t\t \n\t\tpipe = usb_sndctrlpipe(ictx->usbdev_intf0, 0);\n\n\t\t \n\t\tusb_fill_control_urb(ictx->tx_urb, ictx->usbdev_intf0,\n\t\t\t\t     pipe, (unsigned char *)control_req,\n\t\t\t\t     ictx->usb_tx_buf,\n\t\t\t\t     sizeof(ictx->usb_tx_buf),\n\t\t\t\t     usb_tx_callback, ictx);\n\t\tictx->tx_urb->actual_length = 0;\n\t}\n\n\treinit_completion(&ictx->tx.finished);\n\tictx->tx.busy = true;\n\tsmp_rmb();  \n\n\tretval = usb_submit_urb(ictx->tx_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tictx->tx.busy = false;\n\t\tsmp_rmb();  \n\t\tpr_err_ratelimited(\"error submitting urb(%d)\\n\", retval);\n\t} else {\n\t\t \n\t\tretval = wait_for_completion_interruptible(\n\t\t\t\t&ictx->tx.finished);\n\t\tif (retval) {\n\t\t\tusb_kill_urb(ictx->tx_urb);\n\t\t\tpr_err_ratelimited(\"task interrupted\\n\");\n\t\t}\n\n\t\tictx->tx.busy = false;\n\t\tretval = ictx->tx.status;\n\t\tif (retval)\n\t\t\tpr_err_ratelimited(\"packet tx failed (%d)\\n\", retval);\n\t}\n\n\tkfree(control_req);\n\n\t \n\ttimeout = msecs_to_jiffies(ictx->send_packet_delay);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tschedule_timeout(timeout);\n\n\treturn retval;\n}\n\n \nstatic int send_associate_24g(struct imon_context *ictx)\n{\n\tconst unsigned char packet[8] = { 0x01, 0x00, 0x00, 0x00,\n\t\t\t\t\t  0x00, 0x00, 0x00, 0x20 };\n\n\tif (!ictx) {\n\t\tpr_err(\"no context for device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!ictx->dev_present_intf0) {\n\t\tpr_err(\"no iMON device present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(ictx->usb_tx_buf, packet, sizeof(packet));\n\n\treturn send_packet(ictx);\n}\n\n \nstatic int send_set_imon_clock(struct imon_context *ictx,\n\t\t\t       unsigned int year, unsigned int month,\n\t\t\t       unsigned int day, unsigned int dow,\n\t\t\t       unsigned int hour, unsigned int minute,\n\t\t\t       unsigned int second)\n{\n\tunsigned char clock_enable_pkt[IMON_CLOCK_ENABLE_PACKETS][8];\n\tint retval = 0;\n\tint i;\n\n\tif (!ictx) {\n\t\tpr_err(\"no context for device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (ictx->display_type) {\n\tcase IMON_DISPLAY_TYPE_LCD:\n\t\tclock_enable_pkt[0][0] = 0x80;\n\t\tclock_enable_pkt[0][1] = year;\n\t\tclock_enable_pkt[0][2] = month-1;\n\t\tclock_enable_pkt[0][3] = day;\n\t\tclock_enable_pkt[0][4] = hour;\n\t\tclock_enable_pkt[0][5] = minute;\n\t\tclock_enable_pkt[0][6] = second;\n\n\t\tclock_enable_pkt[1][0] = 0x80;\n\t\tclock_enable_pkt[1][1] = 0;\n\t\tclock_enable_pkt[1][2] = 0;\n\t\tclock_enable_pkt[1][3] = 0;\n\t\tclock_enable_pkt[1][4] = 0;\n\t\tclock_enable_pkt[1][5] = 0;\n\t\tclock_enable_pkt[1][6] = 0;\n\n\t\tif (ictx->product == 0xffdc) {\n\t\t\tclock_enable_pkt[0][7] = 0x50;\n\t\t\tclock_enable_pkt[1][7] = 0x51;\n\t\t} else {\n\t\t\tclock_enable_pkt[0][7] = 0x88;\n\t\t\tclock_enable_pkt[1][7] = 0x8a;\n\t\t}\n\n\t\tbreak;\n\n\tcase IMON_DISPLAY_TYPE_VFD:\n\t\tclock_enable_pkt[0][0] = year;\n\t\tclock_enable_pkt[0][1] = month-1;\n\t\tclock_enable_pkt[0][2] = day;\n\t\tclock_enable_pkt[0][3] = dow;\n\t\tclock_enable_pkt[0][4] = hour;\n\t\tclock_enable_pkt[0][5] = minute;\n\t\tclock_enable_pkt[0][6] = second;\n\t\tclock_enable_pkt[0][7] = 0x40;\n\n\t\tclock_enable_pkt[1][0] = 0;\n\t\tclock_enable_pkt[1][1] = 0;\n\t\tclock_enable_pkt[1][2] = 1;\n\t\tclock_enable_pkt[1][3] = 0;\n\t\tclock_enable_pkt[1][4] = 0;\n\t\tclock_enable_pkt[1][5] = 0;\n\t\tclock_enable_pkt[1][6] = 0;\n\t\tclock_enable_pkt[1][7] = 0x42;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < IMON_CLOCK_ENABLE_PACKETS; i++) {\n\t\tmemcpy(ictx->usb_tx_buf, clock_enable_pkt[i], 8);\n\t\tretval = send_packet(ictx);\n\t\tif (retval) {\n\t\t\tpr_err(\"send_packet failed for packet %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic ssize_t associate_remote_show(struct device *d,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct imon_context *ictx = dev_get_drvdata(d);\n\n\tif (!ictx)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ictx->lock);\n\tif (ictx->rf_isassociating)\n\t\tstrscpy(buf, \"associating\\n\", PAGE_SIZE);\n\telse\n\t\tstrscpy(buf, \"closed\\n\", PAGE_SIZE);\n\n\tdev_info(d, \"Visit https://www.lirc.org/html/imon-24g.html for instructions on how to associate your iMON 2.4G DT/LT remote\\n\");\n\tmutex_unlock(&ictx->lock);\n\treturn strlen(buf);\n}\n\nstatic ssize_t associate_remote_store(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct imon_context *ictx;\n\n\tictx = dev_get_drvdata(d);\n\n\tif (!ictx)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ictx->lock);\n\tictx->rf_isassociating = true;\n\tsend_associate_24g(ictx);\n\tmutex_unlock(&ictx->lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t imon_clock_show(struct device *d,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct imon_context *ictx = dev_get_drvdata(d);\n\tsize_t len;\n\n\tif (!ictx)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ictx->lock);\n\n\tif (!ictx->display_supported) {\n\t\tlen = snprintf(buf, PAGE_SIZE, \"Not supported.\");\n\t} else {\n\t\tlen = snprintf(buf, PAGE_SIZE,\n\t\t\t\"To set the clock on your iMON display:\\n\"\n\t\t\t\"# date \\\"+%%y %%m %%d %%w %%H %%M %%S\\\" > imon_clock\\n\"\n\t\t\t\"%s\", ictx->display_isopen ?\n\t\t\t\"\\nNOTE: imon device must be closed\\n\" : \"\");\n\t}\n\n\tmutex_unlock(&ictx->lock);\n\n\treturn len;\n}\n\nstatic ssize_t imon_clock_store(struct device *d,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct imon_context *ictx = dev_get_drvdata(d);\n\tssize_t retval;\n\tunsigned int year, month, day, dow, hour, minute, second;\n\n\tif (!ictx)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ictx->lock);\n\n\tif (!ictx->display_supported) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t} else if (ictx->display_isopen) {\n\t\tretval = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (sscanf(buf, \"%u %u %u %u %u %u %u\",\t&year, &month, &day, &dow,\n\t\t   &hour, &minute, &second) != 7) {\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif ((month < 1 || month > 12) ||\n\t    (day < 1 || day > 31) || (dow > 6) ||\n\t    (hour > 23) || (minute > 59) || (second > 59)) {\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tretval = send_set_imon_clock(ictx, year, month, day, dow,\n\t\t\t\t     hour, minute, second);\n\tif (retval)\n\t\tgoto exit;\n\n\tretval = count;\nexit:\n\tmutex_unlock(&ictx->lock);\n\n\treturn retval;\n}\n\n\nstatic DEVICE_ATTR_RW(imon_clock);\nstatic DEVICE_ATTR_RW(associate_remote);\n\nstatic struct attribute *imon_display_sysfs_entries[] = {\n\t&dev_attr_imon_clock.attr,\n\tNULL\n};\n\nstatic const struct attribute_group imon_display_attr_group = {\n\t.attrs = imon_display_sysfs_entries\n};\n\nstatic struct attribute *imon_rf_sysfs_entries[] = {\n\t&dev_attr_associate_remote.attr,\n\tNULL\n};\n\nstatic const struct attribute_group imon_rf_attr_group = {\n\t.attrs = imon_rf_sysfs_entries\n};\n\n \nstatic ssize_t vfd_write(struct file *file, const char __user *buf,\n\t\t\t size_t n_bytes, loff_t *pos)\n{\n\tint i;\n\tint offset;\n\tint seq;\n\tint retval = 0;\n\tstruct imon_context *ictx = file->private_data;\n\tstatic const unsigned char vfd_packet6[] = {\n\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };\n\n\tif (ictx->disconnected)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&ictx->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (!ictx->dev_present_intf0) {\n\t\tpr_err_ratelimited(\"no iMON device present\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (n_bytes <= 0 || n_bytes > 32) {\n\t\tpr_err_ratelimited(\"invalid payload size\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (copy_from_user(ictx->tx.data_buf, buf, n_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t \n\tfor (i = n_bytes; i < 32; ++i)\n\t\tictx->tx.data_buf[i] = ' ';\n\n\tfor (i = 32; i < 35; ++i)\n\t\tictx->tx.data_buf[i] = 0xFF;\n\n\toffset = 0;\n\tseq = 0;\n\n\tdo {\n\t\tmemcpy(ictx->usb_tx_buf, ictx->tx.data_buf + offset, 7);\n\t\tictx->usb_tx_buf[7] = (unsigned char) seq;\n\n\t\tretval = send_packet(ictx);\n\t\tif (retval) {\n\t\t\tpr_err_ratelimited(\"send packet #%d failed\\n\", seq / 2);\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tseq += 2;\n\t\t\toffset += 7;\n\t\t}\n\n\t} while (offset < 35);\n\n\t \n\tmemcpy(ictx->usb_tx_buf, &vfd_packet6, sizeof(vfd_packet6));\n\tictx->usb_tx_buf[7] = (unsigned char) seq;\n\tretval = send_packet(ictx);\n\tif (retval)\n\t\tpr_err_ratelimited(\"send packet #%d failed\\n\", seq / 2);\n\nexit:\n\tmutex_unlock(&ictx->lock);\n\n\treturn (!retval) ? n_bytes : retval;\n}\n\n \nstatic ssize_t lcd_write(struct file *file, const char __user *buf,\n\t\t\t size_t n_bytes, loff_t *pos)\n{\n\tint retval = 0;\n\tstruct imon_context *ictx = file->private_data;\n\n\tif (ictx->disconnected)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ictx->lock);\n\n\tif (!ictx->display_supported) {\n\t\tpr_err_ratelimited(\"no iMON display present\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (n_bytes != 8) {\n\t\tpr_err_ratelimited(\"invalid payload size: %d (expected 8)\\n\",\n\t\t\t\t   (int)n_bytes);\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (copy_from_user(ictx->usb_tx_buf, buf, 8)) {\n\t\tretval = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tretval = send_packet(ictx);\n\tif (retval) {\n\t\tpr_err_ratelimited(\"send packet failed!\\n\");\n\t\tgoto exit;\n\t} else {\n\t\tdev_dbg(ictx->dev, \"%s: write %d bytes to LCD\\n\",\n\t\t\t__func__, (int) n_bytes);\n\t}\nexit:\n\tmutex_unlock(&ictx->lock);\n\treturn (!retval) ? n_bytes : retval;\n}\n\n \nstatic void usb_tx_callback(struct urb *urb)\n{\n\tstruct imon_context *ictx;\n\n\tif (!urb)\n\t\treturn;\n\tictx = (struct imon_context *)urb->context;\n\tif (!ictx)\n\t\treturn;\n\n\tictx->tx.status = urb->status;\n\n\t \n\tictx->tx.busy = false;\n\tsmp_rmb();  \n\tcomplete(&ictx->tx.finished);\n}\n\n \nstatic void imon_touch_display_timeout(struct timer_list *t)\n{\n\tstruct imon_context *ictx = from_timer(ictx, t, ttimer);\n\n\tif (ictx->display_type != IMON_DISPLAY_TYPE_VGA)\n\t\treturn;\n\n\tinput_report_abs(ictx->touch, ABS_X, ictx->touch_x);\n\tinput_report_abs(ictx->touch, ABS_Y, ictx->touch_y);\n\tinput_report_key(ictx->touch, BTN_TOUCH, 0x00);\n\tinput_sync(ictx->touch);\n}\n\n \nstatic int imon_ir_change_protocol(struct rc_dev *rc, u64 *rc_proto)\n{\n\tint retval;\n\tstruct imon_context *ictx = rc->priv;\n\tstruct device *dev = ictx->dev;\n\tbool unlock = false;\n\tunsigned char ir_proto_packet[] = {\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86 };\n\n\tif (*rc_proto && !(*rc_proto & rc->allowed_protocols))\n\t\tdev_warn(dev, \"Looks like you're trying to use an IR protocol this device does not support\\n\");\n\n\tif (*rc_proto & RC_PROTO_BIT_RC6_MCE) {\n\t\tdev_dbg(dev, \"Configuring IR receiver for MCE protocol\\n\");\n\t\tir_proto_packet[0] = 0x01;\n\t\t*rc_proto = RC_PROTO_BIT_RC6_MCE;\n\t} else if (*rc_proto & RC_PROTO_BIT_IMON) {\n\t\tdev_dbg(dev, \"Configuring IR receiver for iMON protocol\\n\");\n\t\tif (!pad_stabilize)\n\t\t\tdev_dbg(dev, \"PAD stabilize functionality disabled\\n\");\n\t\t \n\t\t*rc_proto = RC_PROTO_BIT_IMON;\n\t} else {\n\t\tdev_warn(dev, \"Unsupported IR protocol specified, overriding to iMON IR protocol\\n\");\n\t\tif (!pad_stabilize)\n\t\t\tdev_dbg(dev, \"PAD stabilize functionality disabled\\n\");\n\t\t \n\t\t*rc_proto = RC_PROTO_BIT_IMON;\n\t}\n\n\tmemcpy(ictx->usb_tx_buf, &ir_proto_packet, sizeof(ir_proto_packet));\n\n\tif (!mutex_is_locked(&ictx->lock)) {\n\t\tunlock = true;\n\t\tmutex_lock(&ictx->lock);\n\t}\n\n\tretval = send_packet(ictx);\n\tif (retval)\n\t\tgoto out;\n\n\tictx->rc_proto = *rc_proto;\n\tictx->pad_mouse = false;\n\nout:\n\tif (unlock)\n\t\tmutex_unlock(&ictx->lock);\n\n\treturn retval;\n}\n\n \nstatic int stabilize(int a, int b, u16 timeout, u16 threshold)\n{\n\tktime_t ct;\n\tstatic ktime_t prev_time;\n\tstatic ktime_t hit_time;\n\tstatic int x, y, prev_result, hits;\n\tint result = 0;\n\tlong msec, msec_hit;\n\n\tct = ktime_get();\n\tmsec = ktime_ms_delta(ct, prev_time);\n\tmsec_hit = ktime_ms_delta(ct, hit_time);\n\n\tif (msec > 100) {\n\t\tx = 0;\n\t\ty = 0;\n\t\thits = 0;\n\t}\n\n\tx += a;\n\ty += b;\n\n\tprev_time = ct;\n\n\tif (abs(x) > threshold || abs(y) > threshold) {\n\t\tif (abs(y) > abs(x))\n\t\t\tresult = (y > 0) ? 0x7F : 0x80;\n\t\telse\n\t\t\tresult = (x > 0) ? 0x7F00 : 0x8000;\n\n\t\tx = 0;\n\t\ty = 0;\n\n\t\tif (result == prev_result) {\n\t\t\thits++;\n\n\t\t\tif (hits > 3) {\n\t\t\t\tswitch (result) {\n\t\t\t\tcase 0x7F:\n\t\t\t\t\ty = 17 * threshold / 30;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\n\t\t\t\t\ty -= 17 * threshold / 30;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x7F00:\n\t\t\t\t\tx = 17 * threshold / 30;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x8000:\n\t\t\t\t\tx -= 17 * threshold / 30;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hits == 2 && msec_hit < timeout) {\n\t\t\t\tresult = 0;\n\t\t\t\thits = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprev_result = result;\n\t\t\thits = 1;\n\t\t\thit_time = ct;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic u32 imon_remote_key_lookup(struct imon_context *ictx, u32 scancode)\n{\n\tu32 keycode;\n\tu32 release;\n\tbool is_release_code = false;\n\n\t \n\tkeycode = rc_g_keycode_from_table(ictx->rdev, scancode);\n\tictx->rc_toggle = 0x0;\n\tictx->rc_scancode = scancode;\n\n\t \n\tif (keycode == KEY_RESERVED) {\n\t\trelease = scancode & ~0x4000;\n\t\tkeycode = rc_g_keycode_from_table(ictx->rdev, release);\n\t\tif (keycode != KEY_RESERVED)\n\t\t\tis_release_code = true;\n\t}\n\n\tictx->release_code = is_release_code;\n\n\treturn keycode;\n}\n\nstatic u32 imon_mce_key_lookup(struct imon_context *ictx, u32 scancode)\n{\n\tu32 keycode;\n\n#define MCE_KEY_MASK 0x7000\n#define MCE_TOGGLE_BIT 0x8000\n\n\t \n\tif (scancode & 0x80000000)\n\t\tscancode = scancode | MCE_KEY_MASK | MCE_TOGGLE_BIT;\n\n\tictx->rc_scancode = scancode;\n\tkeycode = rc_g_keycode_from_table(ictx->rdev, scancode);\n\n\t \n\tictx->release_code = false;\n\n\treturn keycode;\n}\n\nstatic u32 imon_panel_key_lookup(struct imon_context *ictx, u64 code)\n{\n\tconst struct imon_panel_key_table *key_table;\n\tu32 keycode = KEY_RESERVED;\n\tint i;\n\n\tkey_table = ictx->dev_descr->key_table;\n\n\tfor (i = 0; key_table[i].hw_code != 0; i++) {\n\t\tif (key_table[i].hw_code == (code | 0xffee)) {\n\t\t\tkeycode = key_table[i].keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\tictx->release_code = false;\n\treturn keycode;\n}\n\nstatic bool imon_mouse_event(struct imon_context *ictx,\n\t\t\t     unsigned char *buf, int len)\n{\n\tsigned char rel_x = 0x00, rel_y = 0x00;\n\tu8 right_shift = 1;\n\tbool mouse_input = true;\n\tint dir = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\n\t \n\tif (ictx->product != 0xffdc && (buf[0] & 0x01) && len == 5) {\n\t\trel_x = buf[2];\n\t\trel_y = buf[3];\n\t\tright_shift = 1;\n\t \n\t} else if (ictx->product == 0xffdc && (buf[0] & 0x40) &&\n\t\t\t!((buf[1] & 0x01) || ((buf[1] >> 2) & 0x01))) {\n\t\trel_x = (buf[1] & 0x08) | (buf[1] & 0x10) >> 2 |\n\t\t\t(buf[1] & 0x20) >> 4 | (buf[1] & 0x40) >> 6;\n\t\tif (buf[0] & 0x02)\n\t\t\trel_x |= ~0x0f;\n\t\trel_x = rel_x + rel_x / 2;\n\t\trel_y = (buf[2] & 0x08) | (buf[2] & 0x10) >> 2 |\n\t\t\t(buf[2] & 0x20) >> 4 | (buf[2] & 0x40) >> 6;\n\t\tif (buf[0] & 0x01)\n\t\t\trel_y |= ~0x0f;\n\t\trel_y = rel_y + rel_y / 2;\n\t\tright_shift = 2;\n\t \n\t} else if (ictx->product == 0xffdc && (buf[0] == 0x68)) {\n\t\tright_shift = 2;\n\t \n\t} else if (ictx->kc == KEY_CHANNELUP && (buf[2] & 0x40) != 0x40) {\n\t\tdir = 1;\n\t} else if (ictx->kc == KEY_CHANNELDOWN && (buf[2] & 0x40) != 0x40) {\n\t\tdir = -1;\n\t} else\n\t\tmouse_input = false;\n\n\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\n\tif (mouse_input) {\n\t\tdev_dbg(ictx->dev, \"sending mouse data via input subsystem\\n\");\n\n\t\tif (dir) {\n\t\t\tinput_report_rel(ictx->idev, REL_WHEEL, dir);\n\t\t} else if (rel_x || rel_y) {\n\t\t\tinput_report_rel(ictx->idev, REL_X, rel_x);\n\t\t\tinput_report_rel(ictx->idev, REL_Y, rel_y);\n\t\t} else {\n\t\t\tinput_report_key(ictx->idev, BTN_LEFT, buf[1] & 0x1);\n\t\t\tinput_report_key(ictx->idev, BTN_RIGHT,\n\t\t\t\t\t buf[1] >> right_shift & 0x1);\n\t\t}\n\t\tinput_sync(ictx->idev);\n\t\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\t\tictx->last_keycode = ictx->kc;\n\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t}\n\n\treturn mouse_input;\n}\n\nstatic void imon_touch_event(struct imon_context *ictx, unsigned char *buf)\n{\n\tmod_timer(&ictx->ttimer, jiffies + TOUCH_TIMEOUT);\n\tictx->touch_x = (buf[0] << 4) | (buf[1] >> 4);\n\tictx->touch_y = 0xfff - ((buf[2] << 4) | (buf[1] & 0xf));\n\tinput_report_abs(ictx->touch, ABS_X, ictx->touch_x);\n\tinput_report_abs(ictx->touch, ABS_Y, ictx->touch_y);\n\tinput_report_key(ictx->touch, BTN_TOUCH, 0x01);\n\tinput_sync(ictx->touch);\n}\n\nstatic void imon_pad_to_keys(struct imon_context *ictx, unsigned char *buf)\n{\n\tint dir = 0;\n\tsigned char rel_x = 0x00, rel_y = 0x00;\n\tu16 timeout, threshold;\n\tu32 scancode = KEY_RESERVED;\n\tunsigned long flags;\n\n\t \n\tif (ictx->product != 0xffdc) {\n\t\t \n\t\tbuf[5] = buf[6] = buf[7] = 0;\n\t\ttimeout = 500;\t \n\t\t \n\t\tthreshold = pad_thresh ? pad_thresh : 28;\n\t\trel_x = buf[2];\n\t\trel_y = buf[3];\n\n\t\tif (ictx->rc_proto == RC_PROTO_BIT_IMON && pad_stabilize) {\n\t\t\tif ((buf[1] == 0) && ((rel_x != 0) || (rel_y != 0))) {\n\t\t\t\tdir = stabilize((int)rel_x, (int)rel_y,\n\t\t\t\t\t\ttimeout, threshold);\n\t\t\t\tif (!dir) {\n\t\t\t\t\tspin_lock_irqsave(&ictx->kc_lock,\n\t\t\t\t\t\t\t  flags);\n\t\t\t\t\tictx->kc = KEY_UNKNOWN;\n\t\t\t\t\tspin_unlock_irqrestore(&ictx->kc_lock,\n\t\t\t\t\t\t\t       flags);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuf[2] = dir & 0xFF;\n\t\t\t\tbuf[3] = (dir >> 8) & 0xFF;\n\t\t\t\tscancode = be32_to_cpu(*((__be32 *)buf));\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (abs(rel_y) > abs(rel_x)) {\n\t\t\t\tbuf[2] = (rel_y > 0) ? 0x7F : 0x80;\n\t\t\t\tbuf[3] = 0;\n\t\t\t\tif (rel_y > 0)\n\t\t\t\t\tscancode = 0x01007f00;  \n\t\t\t\telse\n\t\t\t\t\tscancode = 0x01008000;  \n\t\t\t} else {\n\t\t\t\tbuf[2] = 0;\n\t\t\t\tbuf[3] = (rel_x > 0) ? 0x7F : 0x80;\n\t\t\t\tif (rel_x > 0)\n\t\t\t\t\tscancode = 0x0100007f;  \n\t\t\t\telse\n\t\t\t\t\tscancode = 0x01000080;  \n\t\t\t}\n\t\t}\n\n\t \n\t} else {\n\t\ttimeout = 10;\t \n\t\t \n\t\tthreshold = pad_thresh ? pad_thresh : 15;\n\n\t\t \n\t\trel_x = (buf[1] & 0x08) | (buf[1] & 0x10) >> 2 |\n\t\t\t(buf[1] & 0x20) >> 4 | (buf[1] & 0x40) >> 6;\n\t\tif (buf[0] & 0x02)\n\t\t\trel_x |= ~0x10+1;\n\t\t \n\t\trel_y = (buf[2] & 0x08) | (buf[2] & 0x10) >> 2 |\n\t\t\t(buf[2] & 0x20) >> 4 | (buf[2] & 0x40) >> 6;\n\t\tif (buf[0] & 0x01)\n\t\t\trel_y |= ~0x10+1;\n\n\t\tbuf[0] = 0x01;\n\t\tbuf[1] = buf[4] = buf[5] = buf[6] = buf[7] = 0;\n\n\t\tif (ictx->rc_proto == RC_PROTO_BIT_IMON && pad_stabilize) {\n\t\t\tdir = stabilize((int)rel_x, (int)rel_y,\n\t\t\t\t\ttimeout, threshold);\n\t\t\tif (!dir) {\n\t\t\t\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\t\t\t\tictx->kc = KEY_UNKNOWN;\n\t\t\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuf[2] = dir & 0xFF;\n\t\t\tbuf[3] = (dir >> 8) & 0xFF;\n\t\t\tscancode = be32_to_cpu(*((__be32 *)buf));\n\t\t} else {\n\t\t\t \n\t\t\tif (abs(rel_y) > abs(rel_x)) {\n\t\t\t\tbuf[2] = (rel_y > 0) ? 0x7F : 0x80;\n\t\t\t\tbuf[3] = 0;\n\t\t\t\tif (rel_y > 0)\n\t\t\t\t\tscancode = 0x01007f00;  \n\t\t\t\telse\n\t\t\t\t\tscancode = 0x01008000;  \n\t\t\t} else {\n\t\t\t\tbuf[2] = 0;\n\t\t\t\tbuf[3] = (rel_x > 0) ? 0x7F : 0x80;\n\t\t\t\tif (rel_x > 0)\n\t\t\t\t\tscancode = 0x0100007f;  \n\t\t\t\telse\n\t\t\t\t\tscancode = 0x01000080;  \n\t\t\t}\n\t\t}\n\t}\n\n\tif (scancode) {\n\t\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\t\tictx->kc = imon_remote_key_lookup(ictx, scancode);\n\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t}\n}\n\n \nstatic int imon_parse_press_type(struct imon_context *ictx,\n\t\t\t\t unsigned char *buf, u8 ktype)\n{\n\tint press_type = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\n\t \n\tif (ictx->kc == KEY_RESERVED && buf[0] == 0x02 && buf[3] == 0x00)\n\t\tictx->kc = ictx->last_keycode;\n\n\t \n\telse if (ictx->kc == KEY_RESERVED && buf[0] == 0x68 && buf[1] == 0x82 &&\n\t\t buf[2] == 0x81 && buf[3] == 0xb7)\n\t\tictx->kc = ictx->last_keycode;\n\n\t \n\telse if (ictx->kc == KEY_RESERVED && buf[0] == 0x01 && buf[1] == 0x00 &&\n\t\t buf[2] == 0x81 && buf[3] == 0xb7)\n\t\tictx->kc = ictx->last_keycode;\n\n\t \n\telse if (ktype == IMON_KEY_MCE) {\n\t\tictx->rc_toggle = buf[2];\n\t\tpress_type = 1;\n\n\t \n\t} else if (ictx->kc == KEY_RESERVED)\n\t\tpress_type = -EINVAL;\n\n\t \n\telse if (ictx->release_code)\n\t\tpress_type = 0;\n\n\t \n\telse\n\t\tpress_type = 1;\n\n\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\n\treturn press_type;\n}\n\n \nstatic void imon_incoming_packet(struct imon_context *ictx,\n\t\t\t\t struct urb *urb, int intf)\n{\n\tint len = urb->actual_length;\n\tunsigned char *buf = urb->transfer_buffer;\n\tstruct device *dev = ictx->dev;\n\tunsigned long flags;\n\tu32 kc;\n\tu64 scancode;\n\tint press_type = 0;\n\tktime_t t;\n\tstatic ktime_t prev_time;\n\tu8 ktype;\n\n\t \n\tif ((buf[0] == 0xff) && (buf[1] == 0xff) && (buf[2] == 0xff))\n\t\treturn;\n\n\t \n\tif (len == 8 && buf[7] == 0xee) {\n\t\tscancode = be64_to_cpu(*((__be64 *)buf));\n\t\tktype = IMON_KEY_PANEL;\n\t\tkc = imon_panel_key_lookup(ictx, scancode);\n\t\tictx->release_code = false;\n\t} else {\n\t\tscancode = be32_to_cpu(*((__be32 *)buf));\n\t\tif (ictx->rc_proto == RC_PROTO_BIT_RC6_MCE) {\n\t\t\tktype = IMON_KEY_IMON;\n\t\t\tif (buf[0] == 0x80)\n\t\t\t\tktype = IMON_KEY_MCE;\n\t\t\tkc = imon_mce_key_lookup(ictx, scancode);\n\t\t} else {\n\t\t\tktype = IMON_KEY_IMON;\n\t\t\tkc = imon_remote_key_lookup(ictx, scancode);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\t \n\tif (kc == KEY_KEYBOARD && !ictx->release_code) {\n\t\tictx->last_keycode = kc;\n\t\tif (!nomouse) {\n\t\t\tictx->pad_mouse = !ictx->pad_mouse;\n\t\t\tdev_dbg(dev, \"toggling to %s mode\\n\",\n\t\t\t\tictx->pad_mouse ? \"mouse\" : \"keyboard\");\n\t\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t\t\treturn;\n\t\t} else {\n\t\t\tictx->pad_mouse = false;\n\t\t\tdev_dbg(dev, \"mouse mode disabled, passing key value\\n\");\n\t\t}\n\t}\n\n\tictx->kc = kc;\n\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\n\t \n\tif (ictx->touch && len == 8 && buf[7] == 0x86) {\n\t\timon_touch_event(ictx, buf);\n\t\treturn;\n\n\t \n\t} else if (ictx->pad_mouse) {\n\t\tif (imon_mouse_event(ictx, buf, len))\n\t\t\treturn;\n\t}\n\n\t \n\tif (((len == 5) && (buf[0] == 0x01) && (buf[4] == 0x00)) ||\n\t    ((len == 8) && (buf[0] & 0x40) &&\n\t     !(buf[1] & 0x1 || buf[1] >> 2 & 0x1))) {\n\t\tlen = 8;\n\t\timon_pad_to_keys(ictx, buf);\n\t}\n\n\tif (debug) {\n\t\tprintk(KERN_INFO \"intf%d decoded packet: %*ph\\n\",\n\t\t       intf, len, buf);\n\t}\n\n\tpress_type = imon_parse_press_type(ictx, buf, ktype);\n\tif (press_type < 0)\n\t\tgoto not_input_data;\n\n\tif (ktype != IMON_KEY_PANEL) {\n\t\tif (press_type == 0)\n\t\t\trc_keyup(ictx->rdev);\n\t\telse {\n\t\t\tenum rc_proto proto;\n\n\t\t\tif (ictx->rc_proto == RC_PROTO_BIT_RC6_MCE)\n\t\t\t\tproto = RC_PROTO_RC6_MCE;\n\t\t\telse if (ictx->rc_proto == RC_PROTO_BIT_IMON)\n\t\t\t\tproto = RC_PROTO_IMON;\n\t\t\telse\n\t\t\t\treturn;\n\n\t\t\trc_keydown(ictx->rdev, proto, ictx->rc_scancode,\n\t\t\t\t   ictx->rc_toggle);\n\n\t\t\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\t\t\tictx->last_keycode = ictx->kc;\n\t\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\n\tt = ktime_get();\n\t \n\tif (ictx->kc == KEY_MUTE ||\n\t    ictx->dev_descr->flags & IMON_SUPPRESS_REPEATED_KEYS) {\n\t\tif (ictx->kc == ictx->last_keycode &&\n\t\t    ktime_ms_delta(t, prev_time) < ictx->idev->rep[REP_DELAY]) {\n\t\t\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprev_time = t;\n\tkc = ictx->kc;\n\n\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\n\tinput_report_key(ictx->idev, kc, press_type);\n\tinput_sync(ictx->idev);\n\n\t \n\tinput_report_key(ictx->idev, kc, 0);\n\tinput_sync(ictx->idev);\n\n\tspin_lock_irqsave(&ictx->kc_lock, flags);\n\tictx->last_keycode = kc;\n\tspin_unlock_irqrestore(&ictx->kc_lock, flags);\n\n\treturn;\n\nnot_input_data:\n\tif (len != 8) {\n\t\tdev_warn(dev, \"imon %s: invalid incoming packet size (len = %d, intf%d)\\n\",\n\t\t\t __func__, len, intf);\n\t\treturn;\n\t}\n\n\t \n\tif (buf[0] == 0x00 &&\n\t    buf[2] == 0xFF &&\t\t\t\t \n\t    buf[3] == 0xFF &&\n\t    buf[4] == 0xFF &&\n\t    buf[5] == 0xFF &&\t\t\t\t \n\t   ((buf[6] == 0x4E && buf[7] == 0xDF) ||\t \n\t    (buf[6] == 0x5E && buf[7] == 0xDF))) {\t \n\t\tdev_warn(dev, \"%s: remote associated refid=%02X\\n\",\n\t\t\t __func__, buf[1]);\n\t\tictx->rf_isassociating = false;\n\t}\n}\n\n \nstatic void usb_rx_callback_intf0(struct urb *urb)\n{\n\tstruct imon_context *ictx;\n\tint intfnum = 0;\n\n\tif (!urb)\n\t\treturn;\n\n\tictx = (struct imon_context *)urb->context;\n\tif (!ictx)\n\t\treturn;\n\n\t \n\tif (!ictx->dev_present_intf0)\n\t\tgoto out;\n\n\tswitch (urb->status) {\n\tcase -ENOENT:\t\t \n\t\treturn;\n\n\tcase -ESHUTDOWN:\t \n\t\tbreak;\n\n\tcase 0:\n\t\timon_incoming_packet(ictx, urb, intfnum);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(ictx->dev, \"imon %s: status(%d): ignored\\n\",\n\t\t\t __func__, urb->status);\n\t\tbreak;\n\t}\n\nout:\n\tusb_submit_urb(ictx->rx_urb_intf0, GFP_ATOMIC);\n}\n\nstatic void usb_rx_callback_intf1(struct urb *urb)\n{\n\tstruct imon_context *ictx;\n\tint intfnum = 1;\n\n\tif (!urb)\n\t\treturn;\n\n\tictx = (struct imon_context *)urb->context;\n\tif (!ictx)\n\t\treturn;\n\n\t \n\tif (!ictx->dev_present_intf1)\n\t\tgoto out;\n\n\tswitch (urb->status) {\n\tcase -ENOENT:\t\t \n\t\treturn;\n\n\tcase -ESHUTDOWN:\t \n\t\tbreak;\n\n\tcase 0:\n\t\timon_incoming_packet(ictx, urb, intfnum);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(ictx->dev, \"imon %s: status(%d): ignored\\n\",\n\t\t\t __func__, urb->status);\n\t\tbreak;\n\t}\n\nout:\n\tusb_submit_urb(ictx->rx_urb_intf1, GFP_ATOMIC);\n}\n\n \nstatic void imon_get_ffdc_type(struct imon_context *ictx)\n{\n\tu8 ffdc_cfg_byte = ictx->usb_rx_buf[6];\n\tu8 detected_display_type = IMON_DISPLAY_TYPE_NONE;\n\tu64 allowed_protos = RC_PROTO_BIT_IMON;\n\n\tswitch (ffdc_cfg_byte) {\n\t \n\tcase 0x21:\n\t\tdev_info(ictx->dev, \"0xffdc iMON Knob, iMON IR\");\n\t\tictx->display_supported = false;\n\t\tbreak;\n\t \n\tcase 0x4e:\n\t\tdev_info(ictx->dev, \"0xffdc iMON 2.4G LT, iMON RF\");\n\t\tictx->display_supported = false;\n\t\tictx->rf_device = true;\n\t\tbreak;\n\t \n\tcase 0x35:\n\t\tdev_info(ictx->dev, \"0xffdc iMON VFD + knob, no IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\tbreak;\n\t \n\tcase 0x24:\n\tcase 0x30:\n\tcase 0x85:\n\t\tdev_info(ictx->dev, \"0xffdc iMON VFD, iMON IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\tbreak;\n\t \n\tcase 0x46:\n\tcase 0x9e:\n\t\tdev_info(ictx->dev, \"0xffdc iMON VFD, MCE IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\tallowed_protos = RC_PROTO_BIT_RC6_MCE;\n\t\tbreak;\n\t \n\tcase 0x7e:\n\t\tdev_info(ictx->dev, \"0xffdc iMON VFD, iMON or MCE IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\tallowed_protos |= RC_PROTO_BIT_RC6_MCE;\n\t\tbreak;\n\t \n\tcase 0x9f:\n\t\tdev_info(ictx->dev, \"0xffdc iMON LCD, MCE IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_LCD;\n\t\tallowed_protos = RC_PROTO_BIT_RC6_MCE;\n\t\tbreak;\n\t \n\tcase 0x26:\n\t\tdev_info(ictx->dev, \"0xffdc iMON Inside, iMON IR\");\n\t\tictx->display_supported = false;\n\t\tbreak;\n\t \n\tcase 0x98:\n\t\tdev_info(ictx->dev, \"0xffdc iMON UltraBay, LCD + IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_LCD;\n\t\tallowed_protos = RC_PROTO_BIT_IMON | RC_PROTO_BIT_RC6_MCE;\n\t\tictx->dev_descr = &ultrabay_table;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(ictx->dev, \"Unknown 0xffdc device, defaulting to VFD and iMON IR\");\n\t\tdetected_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\t \n\t\tallowed_protos |= RC_PROTO_BIT_RC6_MCE;\n\t\tbreak;\n\t}\n\n\tprintk(KERN_CONT \" (id 0x%02x)\\n\", ffdc_cfg_byte);\n\n\tictx->display_type = detected_display_type;\n\tictx->rc_proto = allowed_protos;\n}\n\nstatic void imon_set_display_type(struct imon_context *ictx)\n{\n\tu8 configured_display_type = IMON_DISPLAY_TYPE_VFD;\n\n\t \n\n\tif (display_type == IMON_DISPLAY_TYPE_AUTO) {\n\t\tswitch (ictx->product) {\n\t\tcase 0xffdc:\n\t\t\t \n\t\t\tconfigured_display_type = ictx->display_type;\n\t\t\tbreak;\n\t\tcase 0x0034:\n\t\tcase 0x0035:\n\t\t\tconfigured_display_type = IMON_DISPLAY_TYPE_VGA;\n\t\t\tbreak;\n\t\tcase 0x0038:\n\t\tcase 0x0039:\n\t\tcase 0x0045:\n\t\t\tconfigured_display_type = IMON_DISPLAY_TYPE_LCD;\n\t\t\tbreak;\n\t\tcase 0x003c:\n\t\tcase 0x0041:\n\t\tcase 0x0042:\n\t\tcase 0x0043:\n\t\t\tconfigured_display_type = IMON_DISPLAY_TYPE_NONE;\n\t\t\tictx->display_supported = false;\n\t\t\tbreak;\n\t\tcase 0x0036:\n\t\tcase 0x0044:\n\t\tdefault:\n\t\t\tconfigured_display_type = IMON_DISPLAY_TYPE_VFD;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tconfigured_display_type = display_type;\n\t\tif (display_type == IMON_DISPLAY_TYPE_NONE)\n\t\t\tictx->display_supported = false;\n\t\telse\n\t\t\tictx->display_supported = true;\n\t\tdev_info(ictx->dev, \"%s: overriding display type to %d via modparam\\n\",\n\t\t\t __func__, display_type);\n\t}\n\n\tictx->display_type = configured_display_type;\n}\n\nstatic struct rc_dev *imon_init_rdev(struct imon_context *ictx)\n{\n\tstruct rc_dev *rdev;\n\tint ret;\n\tstatic const unsigned char fp_packet[] = {\n\t\t0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88 };\n\n\trdev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!rdev) {\n\t\tdev_err(ictx->dev, \"remote control dev allocation failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(ictx->name_rdev, sizeof(ictx->name_rdev),\n\t\t \"iMON Remote (%04x:%04x)\", ictx->vendor, ictx->product);\n\tusb_make_path(ictx->usbdev_intf0, ictx->phys_rdev,\n\t\t      sizeof(ictx->phys_rdev));\n\tstrlcat(ictx->phys_rdev, \"/input0\", sizeof(ictx->phys_rdev));\n\n\trdev->device_name = ictx->name_rdev;\n\trdev->input_phys = ictx->phys_rdev;\n\tusb_to_input_id(ictx->usbdev_intf0, &rdev->input_id);\n\trdev->dev.parent = ictx->dev;\n\n\trdev->priv = ictx;\n\t \n\trdev->allowed_protocols = RC_PROTO_BIT_IMON | RC_PROTO_BIT_RC6_MCE;\n\trdev->change_protocol = imon_ir_change_protocol;\n\trdev->driver_name = MOD_NAME;\n\n\t \n\tmemcpy(ictx->usb_tx_buf, &fp_packet, sizeof(fp_packet));\n\tret = send_packet(ictx);\n\t \n\tif (ret)\n\t\tdev_info(ictx->dev, \"panel buttons/knobs setup failed\\n\");\n\n\tif (ictx->product == 0xffdc) {\n\t\timon_get_ffdc_type(ictx);\n\t\trdev->allowed_protocols = ictx->rc_proto;\n\t}\n\n\timon_set_display_type(ictx);\n\n\tif (ictx->rc_proto == RC_PROTO_BIT_RC6_MCE)\n\t\trdev->map_name = RC_MAP_IMON_MCE;\n\telse\n\t\trdev->map_name = RC_MAP_IMON_PAD;\n\n\tret = rc_register_device(rdev);\n\tif (ret < 0) {\n\t\tdev_err(ictx->dev, \"remote input dev register failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn rdev;\n\nout:\n\trc_free_device(rdev);\n\treturn NULL;\n}\n\nstatic struct input_dev *imon_init_idev(struct imon_context *ictx)\n{\n\tconst struct imon_panel_key_table *key_table;\n\tstruct input_dev *idev;\n\tint ret, i;\n\n\tkey_table = ictx->dev_descr->key_table;\n\n\tidev = input_allocate_device();\n\tif (!idev)\n\t\tgoto out;\n\n\tsnprintf(ictx->name_idev, sizeof(ictx->name_idev),\n\t\t \"iMON Panel, Knob and Mouse(%04x:%04x)\",\n\t\t ictx->vendor, ictx->product);\n\tidev->name = ictx->name_idev;\n\n\tusb_make_path(ictx->usbdev_intf0, ictx->phys_idev,\n\t\t      sizeof(ictx->phys_idev));\n\tstrlcat(ictx->phys_idev, \"/input1\", sizeof(ictx->phys_idev));\n\tidev->phys = ictx->phys_idev;\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_REL);\n\n\tidev->keybit[BIT_WORD(BTN_MOUSE)] =\n\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\n\tidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) |\n\t\tBIT_MASK(REL_WHEEL);\n\n\t \n\tfor (i = 0; key_table[i].hw_code != 0; i++) {\n\t\tu32 kc = key_table[i].keycode;\n\t\t__set_bit(kc, idev->keybit);\n\t}\n\n\tusb_to_input_id(ictx->usbdev_intf0, &idev->id);\n\tidev->dev.parent = ictx->dev;\n\tinput_set_drvdata(idev, ictx);\n\n\tret = input_register_device(idev);\n\tif (ret < 0) {\n\t\tdev_err(ictx->dev, \"input dev register failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn idev;\n\nout:\n\tinput_free_device(idev);\n\treturn NULL;\n}\n\nstatic struct input_dev *imon_init_touch(struct imon_context *ictx)\n{\n\tstruct input_dev *touch;\n\tint ret;\n\n\ttouch = input_allocate_device();\n\tif (!touch)\n\t\tgoto touch_alloc_failed;\n\n\tsnprintf(ictx->name_touch, sizeof(ictx->name_touch),\n\t\t \"iMON USB Touchscreen (%04x:%04x)\",\n\t\t ictx->vendor, ictx->product);\n\ttouch->name = ictx->name_touch;\n\n\tusb_make_path(ictx->usbdev_intf1, ictx->phys_touch,\n\t\t      sizeof(ictx->phys_touch));\n\tstrlcat(ictx->phys_touch, \"/input2\", sizeof(ictx->phys_touch));\n\ttouch->phys = ictx->phys_touch;\n\n\ttouch->evbit[0] =\n\t\tBIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\ttouch->keybit[BIT_WORD(BTN_TOUCH)] =\n\t\tBIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(touch, ABS_X,\n\t\t\t     0x00, 0xfff, 0, 0);\n\tinput_set_abs_params(touch, ABS_Y,\n\t\t\t     0x00, 0xfff, 0, 0);\n\n\tinput_set_drvdata(touch, ictx);\n\n\tusb_to_input_id(ictx->usbdev_intf1, &touch->id);\n\ttouch->dev.parent = ictx->dev;\n\tret = input_register_device(touch);\n\tif (ret <  0) {\n\t\tdev_info(ictx->dev, \"touchscreen input dev register failed\\n\");\n\t\tgoto touch_register_failed;\n\t}\n\n\treturn touch;\n\ntouch_register_failed:\n\tinput_free_device(touch);\n\ntouch_alloc_failed:\n\treturn NULL;\n}\n\nstatic bool imon_find_endpoints(struct imon_context *ictx,\n\t\t\t\tstruct usb_host_interface *iface_desc)\n{\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_endpoint_descriptor *rx_endpoint = NULL;\n\tstruct usb_endpoint_descriptor *tx_endpoint = NULL;\n\tint ifnum = iface_desc->desc.bInterfaceNumber;\n\tint num_endpts = iface_desc->desc.bNumEndpoints;\n\tint i, ep_dir, ep_type;\n\tbool ir_ep_found = false;\n\tbool display_ep_found = false;\n\tbool tx_control = false;\n\n\t \n\tfor (i = 0; i < num_endpts && !(ir_ep_found && display_ep_found); ++i) {\n\t\tep = &iface_desc->endpoint[i].desc;\n\t\tep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\n\t\tep_type = usb_endpoint_type(ep);\n\n\t\tif (!ir_ep_found && ep_dir == USB_DIR_IN &&\n\t\t    ep_type == USB_ENDPOINT_XFER_INT) {\n\n\t\t\trx_endpoint = ep;\n\t\t\tir_ep_found = true;\n\t\t\tdev_dbg(ictx->dev, \"%s: found IR endpoint\\n\", __func__);\n\n\t\t} else if (!display_ep_found && ep_dir == USB_DIR_OUT &&\n\t\t\t   ep_type == USB_ENDPOINT_XFER_INT) {\n\t\t\ttx_endpoint = ep;\n\t\t\tdisplay_ep_found = true;\n\t\t\tdev_dbg(ictx->dev, \"%s: found display endpoint\\n\", __func__);\n\t\t}\n\t}\n\n\tif (ifnum == 0) {\n\t\tictx->rx_endpoint_intf0 = rx_endpoint;\n\t\t \n\t\tictx->tx_endpoint = tx_endpoint;\n\t} else {\n\t\tictx->rx_endpoint_intf1 = rx_endpoint;\n\t}\n\n\t \n\tif (!display_ep_found) {\n\t\ttx_control = true;\n\t\tdisplay_ep_found = true;\n\t\tdev_dbg(ictx->dev, \"%s: device uses control endpoint, not interface OUT endpoint\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tif (ictx->display_type == IMON_DISPLAY_TYPE_NONE) {\n\t\tdisplay_ep_found = false;\n\t\tdev_dbg(ictx->dev, \"%s: device has no display\\n\", __func__);\n\t}\n\n\t \n\tif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\n\t\tdisplay_ep_found = false;\n\t\tdev_dbg(ictx->dev, \"%s: iMON Touch device found\\n\", __func__);\n\t}\n\n\t \n\tif (!ir_ep_found)\n\t\tpr_err(\"no valid input (IR) endpoint found\\n\");\n\n\tictx->tx_control = tx_control;\n\n\tif (display_ep_found)\n\t\tictx->display_supported = true;\n\n\treturn ir_ep_found;\n\n}\n\nstatic struct imon_context *imon_init_intf0(struct usb_interface *intf,\n\t\t\t\t\t    const struct usb_device_id *id)\n{\n\tstruct imon_context *ictx;\n\tstruct urb *rx_urb;\n\tstruct urb *tx_urb;\n\tstruct device *dev = &intf->dev;\n\tstruct usb_host_interface *iface_desc;\n\tint ret = -ENOMEM;\n\n\tictx = kzalloc(sizeof(*ictx), GFP_KERNEL);\n\tif (!ictx)\n\t\tgoto exit;\n\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rx_urb)\n\t\tgoto rx_urb_alloc_failed;\n\ttx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!tx_urb)\n\t\tgoto tx_urb_alloc_failed;\n\n\tmutex_init(&ictx->lock);\n\tspin_lock_init(&ictx->kc_lock);\n\n\tmutex_lock(&ictx->lock);\n\n\tictx->dev = dev;\n\tictx->usbdev_intf0 = usb_get_dev(interface_to_usbdev(intf));\n\tictx->rx_urb_intf0 = rx_urb;\n\tictx->tx_urb = tx_urb;\n\tictx->rf_device = false;\n\n\tinit_completion(&ictx->tx.finished);\n\n\tictx->vendor  = le16_to_cpu(ictx->usbdev_intf0->descriptor.idVendor);\n\tictx->product = le16_to_cpu(ictx->usbdev_intf0->descriptor.idProduct);\n\n\t \n\tictx->dev_descr = (struct imon_usb_dev_descr *)id->driver_info;\n\t \n\tictx->send_packet_delay = ictx->dev_descr->flags &\n\t\t\t\t  IMON_NEED_20MS_PKT_DELAY ? 20 : 5;\n\n\tret = -ENODEV;\n\tiface_desc = intf->cur_altsetting;\n\tif (!imon_find_endpoints(ictx, iface_desc)) {\n\t\tgoto find_endpoint_failed;\n\t}\n\n\tusb_fill_int_urb(ictx->rx_urb_intf0, ictx->usbdev_intf0,\n\t\tusb_rcvintpipe(ictx->usbdev_intf0,\n\t\t\tictx->rx_endpoint_intf0->bEndpointAddress),\n\t\tictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\n\t\tusb_rx_callback_intf0, ictx,\n\t\tictx->rx_endpoint_intf0->bInterval);\n\n\tret = usb_submit_urb(ictx->rx_urb_intf0, GFP_KERNEL);\n\tif (ret) {\n\t\tpr_err(\"usb_submit_urb failed for intf0 (%d)\\n\", ret);\n\t\tgoto urb_submit_failed;\n\t}\n\n\tictx->idev = imon_init_idev(ictx);\n\tif (!ictx->idev) {\n\t\tdev_err(dev, \"%s: input device setup failed\\n\", __func__);\n\t\tgoto idev_setup_failed;\n\t}\n\n\tictx->rdev = imon_init_rdev(ictx);\n\tif (!ictx->rdev) {\n\t\tdev_err(dev, \"%s: rc device setup failed\\n\", __func__);\n\t\tgoto rdev_setup_failed;\n\t}\n\n\tictx->dev_present_intf0 = true;\n\n\tmutex_unlock(&ictx->lock);\n\treturn ictx;\n\nrdev_setup_failed:\n\tinput_unregister_device(ictx->idev);\nidev_setup_failed:\n\tusb_kill_urb(ictx->rx_urb_intf0);\nurb_submit_failed:\nfind_endpoint_failed:\n\tusb_put_dev(ictx->usbdev_intf0);\n\tmutex_unlock(&ictx->lock);\n\tusb_free_urb(tx_urb);\ntx_urb_alloc_failed:\n\tusb_free_urb(rx_urb);\nrx_urb_alloc_failed:\n\tkfree(ictx);\nexit:\n\tdev_err(dev, \"unable to initialize intf0, err %d\\n\", ret);\n\n\treturn NULL;\n}\n\nstatic struct imon_context *imon_init_intf1(struct usb_interface *intf,\n\t\t\t\t\t    struct imon_context *ictx)\n{\n\tstruct urb *rx_urb;\n\tstruct usb_host_interface *iface_desc;\n\tint ret = -ENOMEM;\n\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!rx_urb)\n\t\tgoto rx_urb_alloc_failed;\n\n\tmutex_lock(&ictx->lock);\n\n\tif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\n\t\ttimer_setup(&ictx->ttimer, imon_touch_display_timeout, 0);\n\t}\n\n\tictx->usbdev_intf1 = usb_get_dev(interface_to_usbdev(intf));\n\tictx->rx_urb_intf1 = rx_urb;\n\n\tret = -ENODEV;\n\tiface_desc = intf->cur_altsetting;\n\tif (!imon_find_endpoints(ictx, iface_desc))\n\t\tgoto find_endpoint_failed;\n\n\tif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\n\t\tictx->touch = imon_init_touch(ictx);\n\t\tif (!ictx->touch)\n\t\t\tgoto touch_setup_failed;\n\t} else\n\t\tictx->touch = NULL;\n\n\tusb_fill_int_urb(ictx->rx_urb_intf1, ictx->usbdev_intf1,\n\t\tusb_rcvintpipe(ictx->usbdev_intf1,\n\t\t\tictx->rx_endpoint_intf1->bEndpointAddress),\n\t\tictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\n\t\tusb_rx_callback_intf1, ictx,\n\t\tictx->rx_endpoint_intf1->bInterval);\n\n\tret = usb_submit_urb(ictx->rx_urb_intf1, GFP_KERNEL);\n\n\tif (ret) {\n\t\tpr_err(\"usb_submit_urb failed for intf1 (%d)\\n\", ret);\n\t\tgoto urb_submit_failed;\n\t}\n\n\tictx->dev_present_intf1 = true;\n\n\tmutex_unlock(&ictx->lock);\n\treturn ictx;\n\nurb_submit_failed:\n\tif (ictx->touch)\n\t\tinput_unregister_device(ictx->touch);\ntouch_setup_failed:\nfind_endpoint_failed:\n\tusb_put_dev(ictx->usbdev_intf1);\n\tictx->usbdev_intf1 = NULL;\n\tmutex_unlock(&ictx->lock);\n\tusb_free_urb(rx_urb);\n\tictx->rx_urb_intf1 = NULL;\nrx_urb_alloc_failed:\n\tdev_err(ictx->dev, \"unable to initialize intf1, err %d\\n\", ret);\n\n\treturn NULL;\n}\n\nstatic void imon_init_display(struct imon_context *ictx,\n\t\t\t      struct usb_interface *intf)\n{\n\tint ret;\n\n\tdev_dbg(ictx->dev, \"Registering iMON display with sysfs\\n\");\n\n\t \n\tret = sysfs_create_group(&intf->dev.kobj, &imon_display_attr_group);\n\tif (ret)\n\t\tdev_err(ictx->dev, \"Could not create display sysfs entries(%d)\",\n\t\t\tret);\n\n\tif (ictx->display_type == IMON_DISPLAY_TYPE_LCD)\n\t\tret = usb_register_dev(intf, &imon_lcd_class);\n\telse\n\t\tret = usb_register_dev(intf, &imon_vfd_class);\n\tif (ret)\n\t\t \n\t\tdev_info(ictx->dev, \"could not get a minor number for display\\n\");\n\n}\n\n \nstatic int imon_probe(struct usb_interface *interface,\n\t\t      const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = NULL;\n\tstruct usb_host_interface *iface_desc = NULL;\n\tstruct usb_interface *first_if;\n\tstruct device *dev = &interface->dev;\n\tint ifnum, sysfs_err;\n\tint ret = 0;\n\tstruct imon_context *ictx = NULL;\n\tu16 vendor, product;\n\n\tusbdev     = usb_get_dev(interface_to_usbdev(interface));\n\tiface_desc = interface->cur_altsetting;\n\tifnum      = iface_desc->desc.bInterfaceNumber;\n\tvendor     = le16_to_cpu(usbdev->descriptor.idVendor);\n\tproduct    = le16_to_cpu(usbdev->descriptor.idProduct);\n\n\tdev_dbg(dev, \"%s: found iMON device (%04x:%04x, intf%d)\\n\",\n\t\t__func__, vendor, product, ifnum);\n\n\tfirst_if = usb_ifnum_to_if(usbdev, 0);\n\tif (!first_if) {\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (first_if->dev.driver != interface->dev.driver) {\n\t\tdev_err(&interface->dev, \"inconsistent driver matching\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (ifnum == 0) {\n\t\tictx = imon_init_intf0(interface, id);\n\t\tif (!ictx) {\n\t\t\tpr_err(\"failed to initialize context!\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t\trefcount_set(&ictx->users, 1);\n\n\t} else {\n\t\t \n\t\tstruct imon_context *first_if_ctx = usb_get_intfdata(first_if);\n\n\t\t \n\t\tif (!first_if_ctx) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tictx = imon_init_intf1(interface, first_if_ctx);\n\t\tif (!ictx) {\n\t\t\tpr_err(\"failed to attach to context!\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t\trefcount_inc(&ictx->users);\n\n\t}\n\n\tusb_set_intfdata(interface, ictx);\n\n\tif (ifnum == 0) {\n\t\tif (product == 0xffdc && ictx->rf_device) {\n\t\t\tsysfs_err = sysfs_create_group(&interface->dev.kobj,\n\t\t\t\t\t\t       &imon_rf_attr_group);\n\t\t\tif (sysfs_err)\n\t\t\t\tpr_err(\"Could not create RF sysfs entries(%d)\\n\",\n\t\t\t\t       sysfs_err);\n\t\t}\n\n\t\tif (ictx->display_supported)\n\t\t\timon_init_display(ictx, interface);\n\t}\n\n\tdev_info(dev, \"iMON device (%04x:%04x, intf%d) on usb<%d:%d> initialized\\n\",\n\t\t vendor, product, ifnum,\n\t\t usbdev->bus->busnum, usbdev->devnum);\n\n\tusb_put_dev(usbdev);\n\n\treturn 0;\n\nfail:\n\tusb_put_dev(usbdev);\n\tdev_err(dev, \"unable to register, err %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic void imon_disconnect(struct usb_interface *interface)\n{\n\tstruct imon_context *ictx;\n\tstruct device *dev;\n\tint ifnum;\n\n\tictx = usb_get_intfdata(interface);\n\tictx->disconnected = true;\n\tdev = ictx->dev;\n\tifnum = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tsysfs_remove_group(&interface->dev.kobj, &imon_display_attr_group);\n\tsysfs_remove_group(&interface->dev.kobj, &imon_rf_attr_group);\n\n\tusb_set_intfdata(interface, NULL);\n\n\t \n\tif (ictx->tx.busy) {\n\t\tusb_kill_urb(ictx->tx_urb);\n\t\tcomplete(&ictx->tx.finished);\n\t}\n\n\tif (ifnum == 0) {\n\t\tictx->dev_present_intf0 = false;\n\t\tusb_kill_urb(ictx->rx_urb_intf0);\n\t\tinput_unregister_device(ictx->idev);\n\t\trc_unregister_device(ictx->rdev);\n\t\tif (ictx->display_supported) {\n\t\t\tif (ictx->display_type == IMON_DISPLAY_TYPE_LCD)\n\t\t\t\tusb_deregister_dev(interface, &imon_lcd_class);\n\t\t\telse if (ictx->display_type == IMON_DISPLAY_TYPE_VFD)\n\t\t\t\tusb_deregister_dev(interface, &imon_vfd_class);\n\t\t}\n\t\tusb_put_dev(ictx->usbdev_intf0);\n\t} else {\n\t\tictx->dev_present_intf1 = false;\n\t\tusb_kill_urb(ictx->rx_urb_intf1);\n\t\tif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\n\t\t\tdel_timer_sync(&ictx->ttimer);\n\t\t\tinput_unregister_device(ictx->touch);\n\t\t}\n\t\tusb_put_dev(ictx->usbdev_intf1);\n\t}\n\n\tif (refcount_dec_and_test(&ictx->users))\n\t\tfree_imon_context(ictx);\n\n\tdev_dbg(dev, \"%s: iMON device (intf%d) disconnected\\n\",\n\t\t__func__, ifnum);\n}\n\nstatic int imon_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct imon_context *ictx = usb_get_intfdata(intf);\n\tint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (ifnum == 0)\n\t\tusb_kill_urb(ictx->rx_urb_intf0);\n\telse\n\t\tusb_kill_urb(ictx->rx_urb_intf1);\n\n\treturn 0;\n}\n\nstatic int imon_resume(struct usb_interface *intf)\n{\n\tint rc = 0;\n\tstruct imon_context *ictx = usb_get_intfdata(intf);\n\tint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (ifnum == 0) {\n\t\tusb_fill_int_urb(ictx->rx_urb_intf0, ictx->usbdev_intf0,\n\t\t\tusb_rcvintpipe(ictx->usbdev_intf0,\n\t\t\t\tictx->rx_endpoint_intf0->bEndpointAddress),\n\t\t\tictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\n\t\t\tusb_rx_callback_intf0, ictx,\n\t\t\tictx->rx_endpoint_intf0->bInterval);\n\n\t\trc = usb_submit_urb(ictx->rx_urb_intf0, GFP_NOIO);\n\n\t} else {\n\t\tusb_fill_int_urb(ictx->rx_urb_intf1, ictx->usbdev_intf1,\n\t\t\tusb_rcvintpipe(ictx->usbdev_intf1,\n\t\t\t\tictx->rx_endpoint_intf1->bEndpointAddress),\n\t\t\tictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\n\t\t\tusb_rx_callback_intf1, ictx,\n\t\t\tictx->rx_endpoint_intf1->bInterval);\n\n\t\trc = usb_submit_urb(ictx->rx_urb_intf1, GFP_NOIO);\n\t}\n\n\treturn rc;\n}\n\nmodule_usb_driver(imon_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}