{
  "module_name": "ite-cir.c",
  "hash_id": "bfb5cc6587bd4a0af2b8cf6274bacb4ee533ebc7c23960a22805c89b0c0f77cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ite-cir.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/bitops.h>\n#include <media/rc-core.h>\n#include <linux/pci_ids.h>\n\n#include \"ite-cir.h\"\n\n \n\n \nstatic long sample_period = NSEC_PER_SEC / 115200;\nmodule_param(sample_period, long, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(sample_period, \"sample period\");\n\n \nstatic int model_number = -1;\nmodule_param(model_number, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(model_number, \"Use this model number, don't autodetect\");\n\n\n \n\n \nstatic inline bool ite_is_high_carrier_freq(unsigned int freq)\n{\n\treturn freq >= ITE_HCF_MIN_CARRIER_FREQ;\n}\n\n \nstatic u8 ite_get_carrier_freq_bits(unsigned int freq)\n{\n\tif (ite_is_high_carrier_freq(freq)) {\n\t\tif (freq < 425000)\n\t\t\treturn ITE_CFQ_400;\n\n\t\telse if (freq < 465000)\n\t\t\treturn ITE_CFQ_450;\n\n\t\telse if (freq < 490000)\n\t\t\treturn ITE_CFQ_480;\n\n\t\telse\n\t\t\treturn ITE_CFQ_500;\n\t} else {\n\t\t\t \n\t\tif (freq < ITE_LCF_MIN_CARRIER_FREQ)\n\t\t\tfreq = ITE_LCF_MIN_CARRIER_FREQ;\n\t\tif (freq > ITE_LCF_MAX_CARRIER_FREQ)\n\t\t\tfreq = ITE_LCF_MAX_CARRIER_FREQ;\n\n\t\t \n\t\tfreq = DIV_ROUND_CLOSEST(freq - ITE_LCF_MIN_CARRIER_FREQ, 1000);\n\n\t\treturn (u8) freq;\n\t}\n}\n\n \nstatic u8 ite_get_pulse_width_bits(unsigned int freq, int duty_cycle)\n{\n\tunsigned long period_ns, on_ns;\n\n\t \n\tif (freq < ITE_LCF_MIN_CARRIER_FREQ)\n\t\tfreq = ITE_LCF_MIN_CARRIER_FREQ;\n\tif (freq > ITE_HCF_MAX_CARRIER_FREQ)\n\t\tfreq = ITE_HCF_MAX_CARRIER_FREQ;\n\n\tperiod_ns = 1000000000UL / freq;\n\ton_ns = period_ns * duty_cycle / 100;\n\n\tif (ite_is_high_carrier_freq(freq)) {\n\t\tif (on_ns < 750)\n\t\t\treturn ITE_TXMPW_A;\n\n\t\telse if (on_ns < 850)\n\t\t\treturn ITE_TXMPW_B;\n\n\t\telse if (on_ns < 950)\n\t\t\treturn ITE_TXMPW_C;\n\n\t\telse if (on_ns < 1080)\n\t\t\treturn ITE_TXMPW_D;\n\n\t\telse\n\t\t\treturn ITE_TXMPW_E;\n\t} else {\n\t\tif (on_ns < 6500)\n\t\t\treturn ITE_TXMPW_A;\n\n\t\telse if (on_ns < 7850)\n\t\t\treturn ITE_TXMPW_B;\n\n\t\telse if (on_ns < 9650)\n\t\t\treturn ITE_TXMPW_C;\n\n\t\telse if (on_ns < 11950)\n\t\t\treturn ITE_TXMPW_D;\n\n\t\telse\n\t\t\treturn ITE_TXMPW_E;\n\t}\n}\n\n \nstatic void ite_decode_bytes(struct ite_dev *dev, const u8 * data, int\n\t\t\t     length)\n{\n\tunsigned long *ldata;\n\tunsigned int next_one, next_zero, size;\n\tstruct ir_raw_event ev = {};\n\n\tif (length == 0)\n\t\treturn;\n\n\tldata = (unsigned long *)data;\n\tsize = length << 3;\n\tnext_one = find_next_bit_le(ldata, size, 0);\n\tif (next_one > 0) {\n\t\tev.pulse = true;\n\t\tev.duration = ITE_BITS_TO_US(next_one, sample_period);\n\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\t}\n\n\twhile (next_one < size) {\n\t\tnext_zero = find_next_zero_bit_le(ldata, size, next_one + 1);\n\t\tev.pulse = false;\n\t\tev.duration = ITE_BITS_TO_US(next_zero - next_one, sample_period);\n\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\n\t\tif (next_zero < size) {\n\t\t\tnext_one = find_next_bit_le(ldata, size, next_zero + 1);\n\t\t\tev.pulse = true;\n\t\t\tev.duration = ITE_BITS_TO_US(next_one - next_zero,\n\t\t\t\t\t\t     sample_period);\n\t\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\t\t} else\n\t\t\tnext_one = size;\n\t}\n\n\tir_raw_event_handle(dev->rdev);\n\n\tdev_dbg(&dev->rdev->dev, \"decoded %d bytes\\n\", length);\n}\n\n \nstatic void ite_set_carrier_params(struct ite_dev *dev)\n{\n\tunsigned int freq, low_freq, high_freq;\n\tint allowance;\n\tbool use_demodulator;\n\tbool for_tx = dev->transmitting;\n\n\tif (for_tx) {\n\t\t \n\t\tfreq = dev->tx_carrier_freq;\n\t\tallowance = ITE_RXDCR_DEFAULT;\n\t\tuse_demodulator = false;\n\t} else {\n\t\tlow_freq = dev->rx_low_carrier_freq;\n\t\thigh_freq = dev->rx_high_carrier_freq;\n\n\t\tif (low_freq == 0) {\n\t\t\t \n\t\t\tfreq = ITE_DEFAULT_CARRIER_FREQ;\n\t\t\tallowance = ITE_RXDCR_DEFAULT;\n\t\t\tuse_demodulator = false;\n\t\t} else {\n\t\t\t \n\t\t\tfreq = (low_freq + high_freq) / 2;\n\n\t\t\t \n\t\t\tallowance =\n\t\t\t    DIV_ROUND_CLOSEST(10000 * (high_freq - low_freq),\n\t\t\t\t\t      ITE_RXDCR_PER_10000_STEP\n\t\t\t\t\t      * (high_freq + low_freq));\n\n\t\t\tif (allowance < 1)\n\t\t\t\tallowance = 1;\n\n\t\t\tif (allowance > ITE_RXDCR_MAX)\n\t\t\t\tallowance = ITE_RXDCR_MAX;\n\n\t\t\tuse_demodulator = true;\n\t\t}\n\t}\n\n\t \n\tdev->params->set_carrier_params(dev, ite_is_high_carrier_freq(freq),\n\t\t use_demodulator, ite_get_carrier_freq_bits(freq), allowance,\n\t\t ite_get_pulse_width_bits(freq, dev->tx_duty_cycle));\n}\n\n \nstatic irqreturn_t ite_cir_isr(int irq, void *data)\n{\n\tstruct ite_dev *dev = data;\n\tirqreturn_t ret = IRQ_RETVAL(IRQ_NONE);\n\tu8 rx_buf[ITE_RX_FIFO_LEN];\n\tint rx_bytes;\n\tint iflags;\n\n\t \n\tspin_lock(&dev->lock);\n\n\t \n\tiflags = dev->params->get_irq_causes(dev);\n\n\t \n\tif (iflags & ITE_IRQ_RX_FIFO_OVERRUN) {\n\t\tdev_warn(&dev->rdev->dev, \"receive overflow\\n\");\n\t\tir_raw_event_overflow(dev->rdev);\n\t}\n\n\t \n\tif (iflags & (ITE_IRQ_RX_FIFO | ITE_IRQ_RX_FIFO_OVERRUN)) {\n\t\t \n\t\trx_bytes = dev->params->get_rx_bytes(dev, rx_buf,\n\t\t\t\t\t\t    ITE_RX_FIFO_LEN);\n\n\t\tdev_dbg(&dev->rdev->dev, \"interrupt %d RX bytes\\n\", rx_bytes);\n\n\t\tif (rx_bytes > 0) {\n\t\t\t \n\t\t\tspin_unlock(&dev->lock);\n\n\t\t\t \n\t\t\tite_decode_bytes(dev, rx_buf, rx_bytes);\n\n\t\t\t \n\t\t\tspin_lock(&dev->lock);\n\n\t\t\t \n\t\t\tret = IRQ_RETVAL(IRQ_HANDLED);\n\t\t}\n\t} else if (iflags & ITE_IRQ_TX_FIFO) {\n\t\t \n\t\tdev_dbg(&dev->rdev->dev, \"interrupt TX FIFO\\n\");\n\n\t\t \n\t\twake_up_interruptible(&dev->tx_queue);\n\n\t\t \n\t\tret = IRQ_RETVAL(IRQ_HANDLED);\n\t}\n\n\t \n\tspin_unlock(&dev->lock);\n\n\treturn ret;\n}\n\n \nstatic int ite_set_rx_carrier_range(struct rc_dev *rcdev, u32 carrier_low, u32\n\t\t\t\t    carrier_high)\n{\n\tunsigned long flags;\n\tstruct ite_dev *dev = rcdev->priv;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->rx_low_carrier_freq = carrier_low;\n\tdev->rx_high_carrier_freq = carrier_high;\n\tite_set_carrier_params(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int ite_set_tx_carrier(struct rc_dev *rcdev, u32 carrier)\n{\n\tunsigned long flags;\n\tstruct ite_dev *dev = rcdev->priv;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->tx_carrier_freq = carrier;\n\tite_set_carrier_params(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int ite_set_tx_duty_cycle(struct rc_dev *rcdev, u32 duty_cycle)\n{\n\tunsigned long flags;\n\tstruct ite_dev *dev = rcdev->priv;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->tx_duty_cycle = duty_cycle;\n\tite_set_carrier_params(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int ite_tx_ir(struct rc_dev *rcdev, unsigned *txbuf, unsigned n)\n{\n\tunsigned long flags;\n\tstruct ite_dev *dev = rcdev->priv;\n\tbool is_pulse = false;\n\tint remaining_us, fifo_avail, fifo_remaining, last_idx = 0;\n\tint max_rle_us, next_rle_us;\n\tint ret = n;\n\tu8 last_sent[ITE_TX_FIFO_LEN];\n\tu8 val;\n\n\t \n\tmemset(last_sent, 0, sizeof(last_sent));\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->transmitting = true;\n\n\t \n\tite_set_carrier_params(dev);\n\n\t \n\tmax_rle_us =\n\t    (ITE_BAUDRATE_DIVISOR * sample_period *\n\t     ITE_TX_MAX_RLE) / 1000;\n\n\t \n\tdev->params->disable_rx(dev);\n\n\t \n\tfifo_avail = ITE_TX_FIFO_LEN - dev->params->get_tx_used_slots(dev);\n\n\twhile (n > 0) {\n\t\t \n\t\tis_pulse = !is_pulse;\n\t\tremaining_us = *(txbuf++);\n\t\tn--;\n\n\t\tdev_dbg(&dev->rdev->dev, \"%s: %d\\n\",\n\t\t\tis_pulse ? \"pulse\" : \"space\", remaining_us);\n\n\t\t \n\t\twhile (remaining_us > 0) {\n\t\t\tif (remaining_us > max_rle_us)\n\t\t\t\tnext_rle_us = max_rle_us;\n\n\t\t\telse\n\t\t\t\tnext_rle_us = remaining_us;\n\n\t\t\tremaining_us -= next_rle_us;\n\n\t\t\t \n\t\t\tval = (ITE_TX_MAX_RLE * next_rle_us) / max_rle_us;\n\n\t\t\t \n\t\t\tlast_sent[last_idx++] = val;\n\t\t\tlast_idx &= (ITE_TX_FIFO_LEN);\n\n\t\t\t \n\t\t\tval = (val - 1) & ITE_TX_RLE_MASK;\n\n\t\t\t \n\t\t\tif (is_pulse)\n\t\t\t\tval |= ITE_TX_PULSE;\n\n\t\t\telse\n\t\t\t\tval |= ITE_TX_SPACE;\n\n\t\t\t \n\t\t\tif (fifo_avail <= 0)\n\t\t\t\tfifo_avail = ITE_TX_FIFO_LEN - dev->params->get_tx_used_slots(dev);\n\n\t\t\t \n\t\t\tif (fifo_avail <= 0) {\n\t\t\t\t \n\t\t\t\tdev->params->enable_tx_interrupt(dev);\n\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t\t\t \n\t\t\t\twait_event_interruptible(dev->tx_queue,\n\t\t\t\t\t(fifo_avail = ITE_TX_FIFO_LEN - dev->params->get_tx_used_slots(dev)) >= 8);\n\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\n\t\t\t\t \n\t\t\t\tdev->params->disable_tx_interrupt(dev);\n\t\t\t}\n\n\t\t\t \n\t\t\tdev->params->put_tx_byte(dev, val);\n\t\t\tfifo_avail--;\n\t\t}\n\t}\n\n\t \n\tfifo_remaining = dev->params->get_tx_used_slots(dev);\n\tremaining_us = 0;\n\twhile (fifo_remaining > 0) {\n\t\tfifo_remaining--;\n\t\tlast_idx--;\n\t\tlast_idx &= (ITE_TX_FIFO_LEN - 1);\n\t\tremaining_us += last_sent[last_idx];\n\t}\n\tremaining_us = (remaining_us * max_rle_us) / (ITE_TX_MAX_RLE);\n\n\t \n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\tmdelay(DIV_ROUND_UP(remaining_us, 1000));\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->transmitting = false;\n\n\t \n\tite_set_carrier_params(dev);\n\n\t \n\tdev->params->enable_rx(dev);\n\n\t \n\twake_up_interruptible(&dev->tx_ended);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic void ite_s_idle(struct rc_dev *rcdev, bool enable)\n{\n\tunsigned long flags;\n\tstruct ite_dev *dev = rcdev->priv;\n\n\tif (enable) {\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->params->idle_rx(dev);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t}\n}\n\n\n \n\n \nstatic int it87_get_irq_causes(struct ite_dev *dev)\n{\n\tu8 iflags;\n\tint ret = 0;\n\n\t \n\tiflags = inb(dev->cir_addr + IT87_IIR) & IT87_II;\n\n\tswitch (iflags) {\n\tcase IT87_II_RXDS:\n\t\tret = ITE_IRQ_RX_FIFO;\n\t\tbreak;\n\tcase IT87_II_RXFO:\n\t\tret = ITE_IRQ_RX_FIFO_OVERRUN;\n\t\tbreak;\n\tcase IT87_II_TXLDL:\n\t\tret = ITE_IRQ_TX_FIFO;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void it87_set_carrier_params(struct ite_dev *dev, bool high_freq,\n\t\t\t\t    bool use_demodulator,\n\t\t\t\t    u8 carrier_freq_bits, u8 allowance_bits,\n\t\t\t\t    u8 pulse_width_bits)\n{\n\tu8 val;\n\n\t \n\tval = inb(dev->cir_addr + IT87_RCR)\n\t\t& ~(IT87_HCFS | IT87_RXEND | IT87_RXDCR);\n\n\tif (high_freq)\n\t\tval |= IT87_HCFS;\n\n\tif (use_demodulator)\n\t\tval |= IT87_RXEND;\n\n\tval |= allowance_bits;\n\n\toutb(val, dev->cir_addr + IT87_RCR);\n\n\t \n\toutb((carrier_freq_bits << IT87_CFQ_SHIFT) | pulse_width_bits,\n\t\tdev->cir_addr + IT87_TCR2);\n}\n\n \nstatic int it87_get_rx_bytes(struct ite_dev *dev, u8 * buf, int buf_size)\n{\n\tint fifo, read = 0;\n\n\t \n\tfifo = inb(dev->cir_addr + IT87_RSR) & IT87_RXFBC;\n\n\twhile (fifo > 0 && buf_size > 0) {\n\t\t*(buf++) = inb(dev->cir_addr + IT87_DR);\n\t\tfifo--;\n\t\tread++;\n\t\tbuf_size--;\n\t}\n\n\treturn read;\n}\n\n \nstatic int it87_get_tx_used_slots(struct ite_dev *dev)\n{\n\treturn inb(dev->cir_addr + IT87_TSR) & IT87_TXFBC;\n}\n\n \nstatic void it87_put_tx_byte(struct ite_dev *dev, u8 value)\n{\n\toutb(value, dev->cir_addr + IT87_DR);\n}\n\n \nstatic void it87_idle_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_RCR) | IT87_RXACT,\n\t\tdev->cir_addr + IT87_RCR);\n\n\t \n\toutb(inb(dev->cir_addr + IT87_TCR1) | IT87_FIFOCLR,\n\t\tdev->cir_addr + IT87_TCR1);\n}\n\n \nstatic void it87_disable_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) & ~(IT87_RDAIE | IT87_RFOIE),\n\t\tdev->cir_addr + IT87_IER);\n\n\t \n\toutb(inb(dev->cir_addr + IT87_RCR) & ~IT87_RXEN,\n\t\tdev->cir_addr + IT87_RCR);\n\n\t \n\tit87_idle_rx(dev);\n}\n\n \nstatic void it87_enable_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_RCR) | IT87_RXEN,\n\t\tdev->cir_addr + IT87_RCR);\n\n\t \n\tit87_idle_rx(dev);\n\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) | IT87_RDAIE | IT87_RFOIE | IT87_IEC,\n\t\tdev->cir_addr + IT87_IER);\n}\n\n \nstatic void it87_disable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) & ~IT87_TLDLIE,\n\t\tdev->cir_addr + IT87_IER);\n}\n\n \nstatic void it87_enable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) | IT87_TLDLIE | IT87_IEC,\n\t\tdev->cir_addr + IT87_IER);\n}\n\n \nstatic void it87_disable(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) &\n\t\t~(IT87_IEC | IT87_RFOIE | IT87_RDAIE | IT87_TLDLIE),\n\t\tdev->cir_addr + IT87_IER);\n\n\t \n\tit87_disable_rx(dev);\n\n\t \n\toutb(IT87_FIFOCLR | inb(dev->cir_addr + IT87_TCR1),\n\t\tdev->cir_addr + IT87_TCR1);\n}\n\n \nstatic void it87_init_hardware(struct ite_dev *dev)\n{\n\t \n\toutb((inb(dev->cir_addr + IT87_IER) &\n\t\t~(IT87_IEC | IT87_RFOIE | IT87_RDAIE | IT87_TLDLIE)) | IT87_BR,\n\t\tdev->cir_addr + IT87_IER);\n\n\t \n\toutb(ITE_BAUDRATE_DIVISOR & 0xff, dev->cir_addr + IT87_BDLR);\n\toutb((ITE_BAUDRATE_DIVISOR >> 8) & 0xff, dev->cir_addr + IT87_BDHR);\n\n\t \n\toutb(inb(dev->cir_addr + IT87_IER) & ~IT87_BR,\n\t\tdev->cir_addr + IT87_IER);\n\n\t \n\toutb(ITE_RXDCR_DEFAULT, dev->cir_addr + IT87_RCR);\n\n\t \n\toutb(IT87_TXMPM_DEFAULT | IT87_TXENDF | IT87_TXRLE\n\t\t| IT87_FIFOTL_DEFAULT | IT87_FIFOCLR,\n\t\tdev->cir_addr + IT87_TCR1);\n\n\t \n\tite_set_carrier_params(dev);\n}\n\n \n\n \nstatic int it8708_get_irq_causes(struct ite_dev *dev)\n{\n\tu8 iflags;\n\tint ret = 0;\n\n\t \n\tiflags = inb(dev->cir_addr + IT8708_C0IIR);\n\n\tif (iflags & IT85_TLDLI)\n\t\tret |= ITE_IRQ_TX_FIFO;\n\tif (iflags & IT85_RDAI)\n\t\tret |= ITE_IRQ_RX_FIFO;\n\tif (iflags & IT85_RFOI)\n\t\tret |= ITE_IRQ_RX_FIFO_OVERRUN;\n\n\treturn ret;\n}\n\n \nstatic void it8708_set_carrier_params(struct ite_dev *dev, bool high_freq,\n\t\t\t\t      bool use_demodulator,\n\t\t\t\t      u8 carrier_freq_bits, u8 allowance_bits,\n\t\t\t\t      u8 pulse_width_bits)\n{\n\tu8 val;\n\n\t \n\toutb(inb(dev->cir_addr + IT8708_BANKSEL) | IT8708_HRAE,\n\t\tdev->cir_addr + IT8708_BANKSEL);\n\n\tval = (inb(dev->cir_addr + IT8708_C0CFR)\n\t\t& ~(IT85_HCFS | IT85_CFQ)) | carrier_freq_bits;\n\n\tif (high_freq)\n\t\tval |= IT85_HCFS;\n\n\toutb(val, dev->cir_addr + IT8708_C0CFR);\n\n\toutb(inb(dev->cir_addr + IT8708_BANKSEL) & ~IT8708_HRAE,\n\t\t   dev->cir_addr + IT8708_BANKSEL);\n\n\t \n\tval = inb(dev->cir_addr + IT8708_C0RCR)\n\t\t& ~(IT85_RXEND | IT85_RXDCR);\n\n\tif (use_demodulator)\n\t\tval |= IT85_RXEND;\n\n\tval |= allowance_bits;\n\n\toutb(val, dev->cir_addr + IT8708_C0RCR);\n\n\t \n\tval = inb(dev->cir_addr + IT8708_C0TCR) & ~IT85_TXMPW;\n\tval |= pulse_width_bits;\n\toutb(val, dev->cir_addr + IT8708_C0TCR);\n}\n\n \nstatic int it8708_get_rx_bytes(struct ite_dev *dev, u8 * buf, int buf_size)\n{\n\tint fifo, read = 0;\n\n\t \n\tfifo = inb(dev->cir_addr + IT8708_C0RFSR) & IT85_RXFBC;\n\n\twhile (fifo > 0 && buf_size > 0) {\n\t\t*(buf++) = inb(dev->cir_addr + IT8708_C0DR);\n\t\tfifo--;\n\t\tread++;\n\t\tbuf_size--;\n\t}\n\n\treturn read;\n}\n\n \nstatic int it8708_get_tx_used_slots(struct ite_dev *dev)\n{\n\treturn inb(dev->cir_addr + IT8708_C0TFSR) & IT85_TXFBC;\n}\n\n \nstatic void it8708_put_tx_byte(struct ite_dev *dev, u8 value)\n{\n\toutb(value, dev->cir_addr + IT8708_C0DR);\n}\n\n \nstatic void it8708_idle_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0RCR) | IT85_RXACT,\n\t\tdev->cir_addr + IT8708_C0RCR);\n\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0MSTCR) | IT85_FIFOCLR,\n\t\tdev->cir_addr + IT8708_C0MSTCR);\n}\n\n \nstatic void it8708_disable_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER) &\n\t\t~(IT85_RDAIE | IT85_RFOIE),\n\t\tdev->cir_addr + IT8708_C0IER);\n\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0RCR) & ~IT85_RXEN,\n\t\tdev->cir_addr + IT8708_C0RCR);\n\n\t \n\tit8708_idle_rx(dev);\n}\n\n \nstatic void it8708_enable_rx(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0RCR) | IT85_RXEN,\n\t\tdev->cir_addr + IT8708_C0RCR);\n\n\t \n\tit8708_idle_rx(dev);\n\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER)\n\t\t|IT85_RDAIE | IT85_RFOIE | IT85_IEC,\n\t\tdev->cir_addr + IT8708_C0IER);\n}\n\n \nstatic void it8708_disable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER) & ~IT85_TLDLIE,\n\t\tdev->cir_addr + IT8708_C0IER);\n}\n\n \nstatic void it8708_enable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER)\n\t\t|IT85_TLDLIE | IT85_IEC,\n\t\tdev->cir_addr + IT8708_C0IER);\n}\n\n \nstatic void it8708_disable(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER) &\n\t\t~(IT85_IEC | IT85_RFOIE | IT85_RDAIE | IT85_TLDLIE),\n\t\tdev->cir_addr + IT8708_C0IER);\n\n\t \n\tit8708_disable_rx(dev);\n\n\t \n\toutb(IT85_FIFOCLR | inb(dev->cir_addr + IT8708_C0MSTCR),\n\t\tdev->cir_addr + IT8708_C0MSTCR);\n}\n\n \nstatic void it8708_init_hardware(struct ite_dev *dev)\n{\n\t \n\toutb(inb(dev->cir_addr + IT8708_C0IER) &\n\t\t~(IT85_IEC | IT85_RFOIE | IT85_RDAIE | IT85_TLDLIE),\n\t\tdev->cir_addr + IT8708_C0IER);\n\n\t \n\toutb(inb(dev->cir_addr + IT8708_BANKSEL) | IT8708_HRAE,\n\t\tdev->cir_addr + IT8708_BANKSEL);\n\n\toutb(ITE_BAUDRATE_DIVISOR & 0xff, dev->cir_addr + IT8708_C0BDLR);\n\toutb((ITE_BAUDRATE_DIVISOR >> 8) & 0xff,\n\t\t   dev->cir_addr + IT8708_C0BDHR);\n\n\toutb(inb(dev->cir_addr + IT8708_BANKSEL) & ~IT8708_HRAE,\n\t\t   dev->cir_addr + IT8708_BANKSEL);\n\n\t \n\toutb((inb(dev->cir_addr + IT8708_C0MSTCR) &\n\t\t\t~(IT85_ILSEL | IT85_ILE | IT85_FIFOTL |\n\t\t\t  IT85_FIFOCLR | IT85_RESET)) |\n\t\t       IT85_FIFOTL_DEFAULT,\n\t\t       dev->cir_addr + IT8708_C0MSTCR);\n\n\t \n\toutb((inb(dev->cir_addr + IT8708_C0RCR) &\n\t\t\t~(IT85_RXEN | IT85_RDWOS | IT85_RXEND |\n\t\t\t  IT85_RXACT | IT85_RXDCR)) |\n\t\t       ITE_RXDCR_DEFAULT,\n\t\t       dev->cir_addr + IT8708_C0RCR);\n\n\t \n\toutb((inb(dev->cir_addr + IT8708_C0TCR) &\n\t\t\t~(IT85_TXMPM | IT85_TXMPW))\n\t\t       |IT85_TXRLE | IT85_TXENDF |\n\t\t       IT85_TXMPM_DEFAULT | IT85_TXMPW_DEFAULT,\n\t\t       dev->cir_addr + IT8708_C0TCR);\n\n\t \n\tite_set_carrier_params(dev);\n}\n\n \n\n \nstatic inline u8 it8709_rm(struct ite_dev *dev, int index)\n{\n\toutb(index, dev->cir_addr + IT8709_RAM_IDX);\n\treturn inb(dev->cir_addr + IT8709_RAM_VAL);\n}\n\n \nstatic inline void it8709_wm(struct ite_dev *dev, u8 val, int index)\n{\n\toutb(index, dev->cir_addr + IT8709_RAM_IDX);\n\toutb(val, dev->cir_addr + IT8709_RAM_VAL);\n}\n\nstatic void it8709_wait(struct ite_dev *dev)\n{\n\tint i = 0;\n\t \n\tfor (i = 0; i < 15000; i++) {\n\t\tudelay(2);\n\t\tif (it8709_rm(dev, IT8709_MODE) == IT8709_IDLE)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic u8 it8709_rr(struct ite_dev *dev, int index)\n{\n\t \n\tit8709_wait(dev);\n\tit8709_wm(dev, index, IT8709_REG_IDX);\n\tit8709_wm(dev, IT8709_READ, IT8709_MODE);\n\n\t \n\tit8709_wait(dev);\n\n\t \n\treturn it8709_rm(dev, IT8709_REG_VAL);\n}\n\n \nstatic void it8709_wr(struct ite_dev *dev, u8 val, int index)\n{\n\t \n\tit8709_wait(dev);\n\tit8709_wm(dev, val, IT8709_REG_VAL);\n\tit8709_wm(dev, index, IT8709_REG_IDX);\n\tit8709_wm(dev, IT8709_WRITE, IT8709_MODE);\n}\n\n \nstatic int it8709_get_irq_causes(struct ite_dev *dev)\n{\n\tu8 iflags;\n\tint ret = 0;\n\n\t \n\tiflags = it8709_rm(dev, IT8709_IIR);\n\n\tif (iflags & IT85_TLDLI)\n\t\tret |= ITE_IRQ_TX_FIFO;\n\tif (iflags & IT85_RDAI)\n\t\tret |= ITE_IRQ_RX_FIFO;\n\tif (iflags & IT85_RFOI)\n\t\tret |= ITE_IRQ_RX_FIFO_OVERRUN;\n\n\treturn ret;\n}\n\n \nstatic void it8709_set_carrier_params(struct ite_dev *dev, bool high_freq,\n\t\t\t\t      bool use_demodulator,\n\t\t\t\t      u8 carrier_freq_bits, u8 allowance_bits,\n\t\t\t\t      u8 pulse_width_bits)\n{\n\tu8 val;\n\n\tval = (it8709_rr(dev, IT85_C0CFR)\n\t\t     &~(IT85_HCFS | IT85_CFQ)) |\n\t    carrier_freq_bits;\n\n\tif (high_freq)\n\t\tval |= IT85_HCFS;\n\n\tit8709_wr(dev, val, IT85_C0CFR);\n\n\t \n\tval = it8709_rr(dev, IT85_C0RCR)\n\t\t& ~(IT85_RXEND | IT85_RXDCR);\n\n\tif (use_demodulator)\n\t\tval |= IT85_RXEND;\n\n\tval |= allowance_bits;\n\n\tit8709_wr(dev, val, IT85_C0RCR);\n\n\t \n\tval = it8709_rr(dev, IT85_C0TCR) & ~IT85_TXMPW;\n\tval |= pulse_width_bits;\n\tit8709_wr(dev, val, IT85_C0TCR);\n}\n\n \nstatic int it8709_get_rx_bytes(struct ite_dev *dev, u8 * buf, int buf_size)\n{\n\tint fifo, read = 0;\n\n\t \n\tfifo = it8709_rm(dev, IT8709_RFSR) & IT85_RXFBC;\n\n\twhile (fifo > 0 && buf_size > 0) {\n\t\t*(buf++) = it8709_rm(dev, IT8709_FIFO + read);\n\t\tfifo--;\n\t\tread++;\n\t\tbuf_size--;\n\t}\n\n\t \n\tit8709_wm(dev, 0, IT8709_RFSR);\n\n\treturn read;\n}\n\n \nstatic int it8709_get_tx_used_slots(struct ite_dev *dev)\n{\n\treturn it8709_rr(dev, IT85_C0TFSR) & IT85_TXFBC;\n}\n\n \nstatic void it8709_put_tx_byte(struct ite_dev *dev, u8 value)\n{\n\tit8709_wr(dev, value, IT85_C0DR);\n}\n\n \nstatic void it8709_idle_rx(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0RCR) | IT85_RXACT,\n\t\t\t    IT85_C0RCR);\n\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0MSTCR) | IT85_FIFOCLR,\n\t\t\t    IT85_C0MSTCR);\n}\n\n \nstatic void it8709_disable_rx(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER) &\n\t\t\t    ~(IT85_RDAIE | IT85_RFOIE),\n\t\t\t    IT85_C0IER);\n\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0RCR) & ~IT85_RXEN,\n\t\t\t    IT85_C0RCR);\n\n\t \n\tit8709_idle_rx(dev);\n}\n\n \nstatic void it8709_enable_rx(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0RCR) | IT85_RXEN,\n\t\t\t    IT85_C0RCR);\n\n\t \n\tit8709_idle_rx(dev);\n\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER)\n\t\t\t    |IT85_RDAIE | IT85_RFOIE | IT85_IEC,\n\t\t\t    IT85_C0IER);\n}\n\n \nstatic void it8709_disable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER) & ~IT85_TLDLIE,\n\t\t\t    IT85_C0IER);\n}\n\n \nstatic void it8709_enable_tx_interrupt(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER)\n\t\t\t    |IT85_TLDLIE | IT85_IEC,\n\t\t\t    IT85_C0IER);\n}\n\n \nstatic void it8709_disable(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER) &\n\t\t\t~(IT85_IEC | IT85_RFOIE | IT85_RDAIE | IT85_TLDLIE),\n\t\t  IT85_C0IER);\n\n\t \n\tit8709_disable_rx(dev);\n\n\t \n\tit8709_wr(dev, IT85_FIFOCLR | it8709_rr(dev, IT85_C0MSTCR),\n\t\t\t    IT85_C0MSTCR);\n}\n\n \nstatic void it8709_init_hardware(struct ite_dev *dev)\n{\n\t \n\tit8709_wr(dev, it8709_rr(dev, IT85_C0IER) &\n\t\t\t~(IT85_IEC | IT85_RFOIE | IT85_RDAIE | IT85_TLDLIE),\n\t\t  IT85_C0IER);\n\n\t \n\tit8709_wr(dev, ITE_BAUDRATE_DIVISOR & 0xff, IT85_C0BDLR);\n\tit8709_wr(dev, (ITE_BAUDRATE_DIVISOR >> 8) & 0xff,\n\t\t\tIT85_C0BDHR);\n\n\t \n\tit8709_wr(dev, (it8709_rr(dev, IT85_C0MSTCR) &\n\t\t\t~(IT85_ILSEL | IT85_ILE | IT85_FIFOTL\n\t\t\t  | IT85_FIFOCLR | IT85_RESET)) | IT85_FIFOTL_DEFAULT,\n\t\t  IT85_C0MSTCR);\n\n\t \n\tit8709_wr(dev, (it8709_rr(dev, IT85_C0RCR) &\n\t\t\t~(IT85_RXEN | IT85_RDWOS | IT85_RXEND | IT85_RXACT\n\t\t\t  | IT85_RXDCR)) | ITE_RXDCR_DEFAULT,\n\t\t  IT85_C0RCR);\n\n\t \n\tit8709_wr(dev, (it8709_rr(dev, IT85_C0TCR) & ~(IT85_TXMPM | IT85_TXMPW))\n\t\t\t| IT85_TXRLE | IT85_TXENDF | IT85_TXMPM_DEFAULT\n\t\t\t| IT85_TXMPW_DEFAULT,\n\t\t  IT85_C0TCR);\n\n\t \n\tite_set_carrier_params(dev);\n}\n\n\n \n\n \nstatic int ite_open(struct rc_dev *rcdev)\n{\n\tstruct ite_dev *dev = rcdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->params->enable_rx(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void ite_close(struct rc_dev *rcdev)\n{\n\tstruct ite_dev *dev = rcdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tspin_unlock_irqrestore(&dev->lock, flags);\n\twait_event_interruptible(dev->tx_ended, !dev->transmitting);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tdev->params->disable(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\n \nstatic const struct ite_dev_params ite_dev_descs[] = {\n\t{\t \n\t       .model = \"ITE8704 CIR transceiver\",\n\t       .io_region_size = IT87_IOREG_LENGTH,\n\t       .io_rsrc_no = 0,\n\n\t\t \n\t       .get_irq_causes = it87_get_irq_causes,\n\t       .enable_rx = it87_enable_rx,\n\t       .idle_rx = it87_idle_rx,\n\t       .disable_rx = it87_idle_rx,\n\t       .get_rx_bytes = it87_get_rx_bytes,\n\t       .enable_tx_interrupt = it87_enable_tx_interrupt,\n\t       .disable_tx_interrupt = it87_disable_tx_interrupt,\n\t       .get_tx_used_slots = it87_get_tx_used_slots,\n\t       .put_tx_byte = it87_put_tx_byte,\n\t       .disable = it87_disable,\n\t       .init_hardware = it87_init_hardware,\n\t       .set_carrier_params = it87_set_carrier_params,\n\t       },\n\t{\t \n\t       .model = \"ITE8713 CIR transceiver\",\n\t       .io_region_size = IT87_IOREG_LENGTH,\n\t       .io_rsrc_no = 0,\n\n\t\t \n\t       .get_irq_causes = it87_get_irq_causes,\n\t       .enable_rx = it87_enable_rx,\n\t       .idle_rx = it87_idle_rx,\n\t       .disable_rx = it87_idle_rx,\n\t       .get_rx_bytes = it87_get_rx_bytes,\n\t       .enable_tx_interrupt = it87_enable_tx_interrupt,\n\t       .disable_tx_interrupt = it87_disable_tx_interrupt,\n\t       .get_tx_used_slots = it87_get_tx_used_slots,\n\t       .put_tx_byte = it87_put_tx_byte,\n\t       .disable = it87_disable,\n\t       .init_hardware = it87_init_hardware,\n\t       .set_carrier_params = it87_set_carrier_params,\n\t       },\n\t{\t \n\t       .model = \"ITE8708 CIR transceiver\",\n\t       .io_region_size = IT8708_IOREG_LENGTH,\n\t       .io_rsrc_no = 0,\n\n\t\t \n\t       .get_irq_causes = it8708_get_irq_causes,\n\t       .enable_rx = it8708_enable_rx,\n\t       .idle_rx = it8708_idle_rx,\n\t       .disable_rx = it8708_idle_rx,\n\t       .get_rx_bytes = it8708_get_rx_bytes,\n\t       .enable_tx_interrupt = it8708_enable_tx_interrupt,\n\t       .disable_tx_interrupt =\n\t       it8708_disable_tx_interrupt,\n\t       .get_tx_used_slots = it8708_get_tx_used_slots,\n\t       .put_tx_byte = it8708_put_tx_byte,\n\t       .disable = it8708_disable,\n\t       .init_hardware = it8708_init_hardware,\n\t       .set_carrier_params = it8708_set_carrier_params,\n\t       },\n\t{\t \n\t       .model = \"ITE8709 CIR transceiver\",\n\t       .io_region_size = IT8709_IOREG_LENGTH,\n\t       .io_rsrc_no = 2,\n\n\t\t \n\t       .get_irq_causes = it8709_get_irq_causes,\n\t       .enable_rx = it8709_enable_rx,\n\t       .idle_rx = it8709_idle_rx,\n\t       .disable_rx = it8709_idle_rx,\n\t       .get_rx_bytes = it8709_get_rx_bytes,\n\t       .enable_tx_interrupt = it8709_enable_tx_interrupt,\n\t       .disable_tx_interrupt =\n\t       it8709_disable_tx_interrupt,\n\t       .get_tx_used_slots = it8709_get_tx_used_slots,\n\t       .put_tx_byte = it8709_put_tx_byte,\n\t       .disable = it8709_disable,\n\t       .init_hardware = it8709_init_hardware,\n\t       .set_carrier_params = it8709_set_carrier_params,\n\t       },\n};\n\nstatic const struct pnp_device_id ite_ids[] = {\n\t{\"ITE8704\", 0},\t\t \n\t{\"ITE8713\", 1},\t\t \n\t{\"ITE8708\", 2},\t\t \n\t{\"ITE8709\", 3},\t\t \n\t{\"\", 0},\n};\n\n \nstatic int ite_probe(struct pnp_dev *pdev, const struct pnp_device_id\n\t\t     *dev_id)\n{\n\tconst struct ite_dev_params *dev_desc = NULL;\n\tstruct ite_dev *itdev = NULL;\n\tstruct rc_dev *rdev = NULL;\n\tint ret = -ENOMEM;\n\tint model_no;\n\tint io_rsrc_no;\n\n\titdev = kzalloc(sizeof(struct ite_dev), GFP_KERNEL);\n\tif (!itdev)\n\t\treturn ret;\n\n\t \n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev)\n\t\tgoto exit_free_dev_rdev;\n\titdev->rdev = rdev;\n\n\tret = -ENODEV;\n\n\t \n\tmodel_no = (int)dev_id->driver_data;\n\tdev_dbg(&pdev->dev, \"Auto-detected model: %s\\n\",\n\t\tite_dev_descs[model_no].model);\n\n\tif (model_number >= 0 && model_number < ARRAY_SIZE(ite_dev_descs)) {\n\t\tmodel_no = model_number;\n\t\tdev_info(&pdev->dev, \"model has been forced to: %s\",\n\t\t\t ite_dev_descs[model_no].model);\n\t}\n\n\t \n\tdev_desc = &ite_dev_descs[model_no];\n\tio_rsrc_no = dev_desc->io_rsrc_no;\n\n\t \n\tif (!pnp_port_valid(pdev, io_rsrc_no) ||\n\t    pnp_port_len(pdev, io_rsrc_no) < dev_desc->io_region_size) {\n\t\tdev_err(&pdev->dev, \"IR PNP Port not valid!\\n\");\n\t\tgoto exit_free_dev_rdev;\n\t}\n\n\tif (!pnp_irq_valid(pdev, 0)) {\n\t\tdev_err(&pdev->dev, \"PNP IRQ not valid!\\n\");\n\t\tgoto exit_free_dev_rdev;\n\t}\n\n\t \n\titdev->cir_addr = pnp_port_start(pdev, io_rsrc_no);\n\titdev->cir_irq = pnp_irq(pdev, 0);\n\n\t \n\tspin_lock_init(&itdev->lock);\n\n\t \n\tpnp_set_drvdata(pdev, itdev);\n\titdev->pdev = pdev;\n\n\t \n\tinit_waitqueue_head(&itdev->tx_queue);\n\tinit_waitqueue_head(&itdev->tx_ended);\n\n\t \n\titdev->params = dev_desc;\n\n\t \n\titdev->tx_duty_cycle = 33;\n\titdev->tx_carrier_freq = ITE_DEFAULT_CARRIER_FREQ;\n\titdev->params->init_hardware(itdev);\n\n\t \n\trdev->priv = itdev;\n\trdev->dev.parent = &pdev->dev;\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->open = ite_open;\n\trdev->close = ite_close;\n\trdev->s_idle = ite_s_idle;\n\trdev->s_rx_carrier_range = ite_set_rx_carrier_range;\n\t \n\trdev->min_timeout = 17 * 8 * ITE_BAUDRATE_DIVISOR *\n\t\t\t    sample_period / 1000;\n\trdev->timeout = IR_DEFAULT_TIMEOUT;\n\trdev->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\trdev->rx_resolution = ITE_BAUDRATE_DIVISOR * sample_period / 1000;\n\trdev->tx_resolution = ITE_BAUDRATE_DIVISOR * sample_period / 1000;\n\n\t \n\trdev->tx_ir = ite_tx_ir;\n\trdev->s_tx_carrier = ite_set_tx_carrier;\n\trdev->s_tx_duty_cycle = ite_set_tx_duty_cycle;\n\n\trdev->device_name = dev_desc->model;\n\trdev->input_id.bustype = BUS_HOST;\n\trdev->input_id.vendor = PCI_VENDOR_ID_ITE;\n\trdev->input_id.product = 0;\n\trdev->input_id.version = 0;\n\trdev->driver_name = ITE_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\n\tret = rc_register_device(rdev);\n\tif (ret)\n\t\tgoto exit_free_dev_rdev;\n\n\tret = -EBUSY;\n\t \n\tif (!request_region(itdev->cir_addr,\n\t\t\t\tdev_desc->io_region_size, ITE_DRIVER_NAME))\n\t\tgoto exit_unregister_device;\n\n\tif (request_irq(itdev->cir_irq, ite_cir_isr, IRQF_SHARED,\n\t\t\tITE_DRIVER_NAME, (void *)itdev))\n\t\tgoto exit_release_cir_addr;\n\n\treturn 0;\n\nexit_release_cir_addr:\n\trelease_region(itdev->cir_addr, itdev->params->io_region_size);\nexit_unregister_device:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nexit_free_dev_rdev:\n\trc_free_device(rdev);\n\tkfree(itdev);\n\n\treturn ret;\n}\n\nstatic void ite_remove(struct pnp_dev *pdev)\n{\n\tstruct ite_dev *dev = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->params->disable(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\tfree_irq(dev->cir_irq, dev);\n\trelease_region(dev->cir_addr, dev->params->io_region_size);\n\n\trc_unregister_device(dev->rdev);\n\n\tkfree(dev);\n}\n\nstatic int ite_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\tstruct ite_dev *dev = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\t \n\twait_event_interruptible(dev->tx_ended, !dev->transmitting);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->params->disable(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ite_resume(struct pnp_dev *pdev)\n{\n\tstruct ite_dev *dev = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->params->init_hardware(dev);\n\t \n\tdev->params->enable_rx(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ite_shutdown(struct pnp_dev *pdev)\n{\n\tstruct ite_dev *dev = pnp_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tdev->params->disable(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic struct pnp_driver ite_driver = {\n\t.name\t\t= ITE_DRIVER_NAME,\n\t.id_table\t= ite_ids,\n\t.probe\t\t= ite_probe,\n\t.remove\t\t= ite_remove,\n\t.suspend\t= ite_suspend,\n\t.resume\t\t= ite_resume,\n\t.shutdown\t= ite_shutdown,\n};\n\nMODULE_DEVICE_TABLE(pnp, ite_ids);\nMODULE_DESCRIPTION(\"ITE Tech Inc. IT8712F/ITE8512F CIR driver\");\n\nMODULE_AUTHOR(\"Juan J. Garcia de Soria <skandalfo@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(ite_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}