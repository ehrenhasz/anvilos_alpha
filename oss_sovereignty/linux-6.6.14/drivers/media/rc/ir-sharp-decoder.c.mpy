{
  "module_name": "ir-sharp-decoder.c",
  "hash_id": "1734abf15cfb139221d3948702079fe618d7aacc454c96aaa760371210181bbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-sharp-decoder.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define SHARP_NBITS\t\t15\n#define SHARP_UNIT\t\t40   \n#define SHARP_BIT_PULSE\t\t(8    * SHARP_UNIT)  \n#define SHARP_BIT_0_PERIOD\t(25   * SHARP_UNIT)  \n#define SHARP_BIT_1_PERIOD\t(50   * SHARP_UNIT)  \n#define SHARP_BIT_0_SPACE\t(17   * SHARP_UNIT)  \n#define SHARP_BIT_1_SPACE\t(42   * SHARP_UNIT)  \n#define SHARP_ECHO_SPACE\t(1000 * SHARP_UNIT)  \n#define SHARP_TRAILER_SPACE\t(125  * SHARP_UNIT)  \n\nenum sharp_state {\n\tSTATE_INACTIVE,\n\tSTATE_BIT_PULSE,\n\tSTATE_BIT_SPACE,\n\tSTATE_TRAILER_PULSE,\n\tSTATE_ECHO_SPACE,\n\tSTATE_TRAILER_SPACE,\n};\n\n \nstatic int ir_sharp_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct sharp_dec *data = &dev->raw->sharp;\n\tu32 msg, echo, address, command, scancode;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"Sharp decode started at state %d (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\n\t\t\t       SHARP_BIT_PULSE / 2))\n\t\t\tbreak;\n\n\t\tdata->count = 0;\n\t\tdata->pulse_len = ev.duration;\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\n\t\t\t       SHARP_BIT_PULSE / 2))\n\t\t\tbreak;\n\n\t\tdata->pulse_len = ev.duration;\n\t\tdata->state = STATE_BIT_SPACE;\n\t\treturn 0;\n\n\tcase STATE_BIT_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tdata->bits <<= 1;\n\t\tif (eq_margin(data->pulse_len + ev.duration, SHARP_BIT_1_PERIOD,\n\t\t\t      SHARP_BIT_PULSE * 2))\n\t\t\tdata->bits |= 1;\n\t\telse if (!eq_margin(data->pulse_len + ev.duration,\n\t\t\t\t    SHARP_BIT_0_PERIOD, SHARP_BIT_PULSE * 2))\n\t\t\tbreak;\n\t\tdata->count++;\n\n\t\tif (data->count == SHARP_NBITS ||\n\t\t    data->count == SHARP_NBITS * 2)\n\t\t\tdata->state = STATE_TRAILER_PULSE;\n\t\telse\n\t\t\tdata->state = STATE_BIT_PULSE;\n\n\t\treturn 0;\n\n\tcase STATE_TRAILER_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\n\t\t\t       SHARP_BIT_PULSE / 2))\n\t\t\tbreak;\n\n\t\tif (data->count == SHARP_NBITS) {\n\t\t\t \n\t\t\tif ((data->bits & 0x3) != 0x2 &&\n\t\t\t \n\t\t\t    (data->bits & 0x3) != 0x0)\n\t\t\t\tbreak;\n\t\t\tdata->state = STATE_ECHO_SPACE;\n\t\t} else {\n\t\t\tdata->state = STATE_TRAILER_SPACE;\n\t\t}\n\t\treturn 0;\n\n\tcase STATE_ECHO_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, SHARP_ECHO_SPACE,\n\t\t\t       SHARP_ECHO_SPACE / 4))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_PULSE;\n\n\t\treturn 0;\n\n\tcase STATE_TRAILER_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!geq_margin(ev.duration, SHARP_TRAILER_SPACE,\n\t\t\t\tSHARP_BIT_PULSE / 2))\n\t\t\tbreak;\n\n\t\t \n\t\tmsg = (data->bits >> 15) & 0x7fff;\n\t\techo = data->bits & 0x7fff;\n\t\tif ((msg ^ echo) != 0x3ff) {\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"Sharp checksum error: received 0x%04x, 0x%04x\\n\",\n\t\t\t\tmsg, echo);\n\t\t\tbreak;\n\t\t}\n\n\t\taddress = bitrev8((msg >> 7) & 0xf8);\n\t\tcommand = bitrev8((msg >> 2) & 0xff);\n\n\t\tscancode = address << 8 | command;\n\t\tdev_dbg(&dev->dev, \"Sharp scancode 0x%04x\\n\", scancode);\n\n\t\trc_keydown(dev, RC_PROTO_SHARP, scancode, 0);\n\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"Sharp decode failed at count %d state %d (%uus %s)\\n\",\n\t\tdata->count, data->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const struct ir_raw_timings_pd ir_sharp_timings = {\n\t.header_pulse  = 0,\n\t.header_space  = 0,\n\t.bit_pulse     = SHARP_BIT_PULSE,\n\t.bit_space[0]  = SHARP_BIT_0_SPACE,\n\t.bit_space[1]  = SHARP_BIT_1_SPACE,\n\t.trailer_pulse = SHARP_BIT_PULSE,\n\t.trailer_space = SHARP_ECHO_SPACE,\n\t.msb_first     = 1,\n};\n\n \nstatic int ir_sharp_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t   struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint ret;\n\tu32 raw;\n\n\traw = (((bitrev8(scancode >> 8) >> 3) << 8) & 0x1f00) |\n\t\tbitrev8(scancode);\n\tret = ir_raw_gen_pd(&e, max, &ir_sharp_timings, SHARP_NBITS,\n\t\t\t    (raw << 2) | 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmax -= ret;\n\n\traw = (((bitrev8(scancode >> 8) >> 3) << 8) & 0x1f00) |\n\t\tbitrev8(~scancode);\n\tret = ir_raw_gen_pd(&e, max, &ir_sharp_timings, SHARP_NBITS,\n\t\t\t    (raw << 2) | 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler sharp_handler = {\n\t.protocols\t= RC_PROTO_BIT_SHARP,\n\t.decode\t\t= ir_sharp_decode,\n\t.encode\t\t= ir_sharp_encode,\n\t.carrier\t= 38000,\n\t.min_timeout\t= SHARP_ECHO_SPACE + SHARP_ECHO_SPACE / 4,\n};\n\nstatic int __init ir_sharp_decode_init(void)\n{\n\tir_raw_handler_register(&sharp_handler);\n\n\tpr_info(\"IR Sharp protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_sharp_decode_exit(void)\n{\n\tir_raw_handler_unregister(&sharp_handler);\n}\n\nmodule_init(ir_sharp_decode_init);\nmodule_exit(ir_sharp_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Hogan <jhogan@kernel.org>\");\nMODULE_DESCRIPTION(\"Sharp IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}