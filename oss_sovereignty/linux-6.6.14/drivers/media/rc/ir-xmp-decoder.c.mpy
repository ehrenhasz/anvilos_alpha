{
  "module_name": "ir-xmp-decoder.c",
  "hash_id": "a45524879a1eeee5cae150641abe77c9a770fdd2be42adf13c6c95fbc38ebe28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-xmp-decoder.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n#define XMP_UNIT\t\t  136  \n#define XMP_LEADER\t\t  210  \n#define XMP_NIBBLE_PREFIX\t  760  \n#define\tXMP_HALFFRAME_SPACE\t13800  \n \n#define\tXMP_TRAILER_SPACE\t20000\n\nenum xmp_state {\n\tSTATE_INACTIVE,\n\tSTATE_LEADER_PULSE,\n\tSTATE_NIBBLE_SPACE,\n};\n\n \nstatic int ir_xmp_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct xmp_dec *data = &dev->raw->xmp;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&dev->dev, \"XMP decode started at state %d %d (%uus %s)\\n\",\n\t\tdata->state, data->count, ev.duration, TO_STR(ev.pulse));\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2)) {\n\t\t\tdata->count = 0;\n\t\t\tdata->state = STATE_NIBBLE_SPACE;\n\t\t}\n\n\t\treturn 0;\n\n\tcase STATE_LEADER_PULSE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2))\n\t\t\tdata->state = STATE_NIBBLE_SPACE;\n\n\t\treturn 0;\n\n\tcase STATE_NIBBLE_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (geq_margin(ev.duration, XMP_TRAILER_SPACE, XMP_NIBBLE_PREFIX)) {\n\t\t\tint divider, i;\n\t\t\tu8 addr, subaddr, subaddr2, toggle, oem, obc1, obc2, sum1, sum2;\n\t\t\tu32 *n;\n\t\t\tu32 scancode;\n\n\t\t\tif (data->count != 16) {\n\t\t\t\tdev_dbg(&dev->dev, \"received TRAILER period at index %d: %u\\n\",\n\t\t\t\t\tdata->count, ev.duration);\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tn = data->durations;\n\t\t\t \n\t\t\tdivider = (n[3] - XMP_NIBBLE_PREFIX) / 15 - 2000;\n\t\t\tif (divider < 50) {\n\t\t\t\tdev_dbg(&dev->dev, \"divider to small %d.\\n\",\n\t\t\t\t\tdivider);\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tn[i] = (n[i] - XMP_NIBBLE_PREFIX) / divider;\n\t\t\tsum1 = (15 + n[0] + n[1] + n[2] + n[3] +\n\t\t\t\tn[4] + n[5] + n[6] + n[7]) % 16;\n\t\t\tsum2 = (15 + n[8] + n[9] + n[10] + n[11] +\n\t\t\t\tn[12] + n[13] + n[14] + n[15]) % 16;\n\n\t\t\tif (sum1 != 15 || sum2 != 15) {\n\t\t\t\tdev_dbg(&dev->dev, \"checksum errors sum1=0x%X sum2=0x%X\\n\",\n\t\t\t\t\tsum1, sum2);\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsubaddr  = n[0] << 4 | n[2];\n\t\t\tsubaddr2 = n[8] << 4 | n[11];\n\t\t\toem      = n[4] << 4 | n[5];\n\t\t\taddr     = n[6] << 4 | n[7];\n\t\t\ttoggle   = n[10];\n\t\t\tobc1 = n[12] << 4 | n[13];\n\t\t\tobc2 = n[14] << 4 | n[15];\n\t\t\tif (subaddr != subaddr2) {\n\t\t\t\tdev_dbg(&dev->dev, \"subaddress nibbles mismatch 0x%02X != 0x%02X\\n\",\n\t\t\t\t\tsubaddr, subaddr2);\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (oem != 0x44)\n\t\t\t\tdev_dbg(&dev->dev, \"Warning: OEM nibbles 0x%02X. Expected 0x44\\n\",\n\t\t\t\t\toem);\n\n\t\t\tscancode = addr << 24 | subaddr << 16 |\n\t\t\t\t   obc1 << 8 | obc2;\n\t\t\tdev_dbg(&dev->dev, \"XMP scancode 0x%06x\\n\", scancode);\n\n\t\t\tif (toggle == 0) {\n\t\t\t\trc_keydown(dev, RC_PROTO_XMP, scancode, 0);\n\t\t\t} else {\n\t\t\t\trc_repeat(dev);\n\t\t\t\tdev_dbg(&dev->dev, \"Repeat last key\\n\");\n\t\t\t}\n\t\t\tdata->state = STATE_INACTIVE;\n\n\t\t\treturn 0;\n\n\t\t} else if (geq_margin(ev.duration, XMP_HALFFRAME_SPACE, XMP_NIBBLE_PREFIX)) {\n\t\t\t \n\t\t\tif (data->count == 16) {\n\t\t\t\tdev_dbg(&dev->dev, \"received half frame pulse at index %d. Probably a final frame key-up event: %u\\n\",\n\t\t\t\t\tdata->count, ev.duration);\n\t\t\t\t \n\t\t\t\tdata->count = 8;\n\t\t\t}\n\n\t\t\telse if (data->count != 8)\n\t\t\t\tdev_dbg(&dev->dev, \"received half frame pulse at index %d: %u\\n\",\n\t\t\t\t\tdata->count, ev.duration);\n\t\t\tdata->state = STATE_LEADER_PULSE;\n\n\t\t\treturn 0;\n\n\t\t} else if (geq_margin(ev.duration, XMP_NIBBLE_PREFIX, XMP_UNIT)) {\n\t\t\t \n\t\t\tif (data->count == 16) {\n\t\t\t\tdev_dbg(&dev->dev, \"too many pulses (%d) ignoring: %u\\n\",\n\t\t\t\t\tdata->count, ev.duration);\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdata->durations[data->count] = ev.duration;\n\t\t\tdata->count++;\n\t\t\tdata->state = STATE_LEADER_PULSE;\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdev_dbg(&dev->dev, \"XMP decode failed at count %d state %d (%uus %s)\\n\",\n\t\tdata->count, data->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic struct ir_raw_handler xmp_handler = {\n\t.protocols\t= RC_PROTO_BIT_XMP,\n\t.decode\t\t= ir_xmp_decode,\n\t.min_timeout\t= XMP_TRAILER_SPACE,\n};\n\nstatic int __init ir_xmp_decode_init(void)\n{\n\tir_raw_handler_register(&xmp_handler);\n\n\tprintk(KERN_INFO \"IR XMP protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_xmp_decode_exit(void)\n{\n\tir_raw_handler_unregister(&xmp_handler);\n}\n\nmodule_init(ir_xmp_decode_init);\nmodule_exit(ir_xmp_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marcel Mol <marcel@mesa.nl>\");\nMODULE_AUTHOR(\"MESA Consulting (http://www.mesa.nl)\");\nMODULE_DESCRIPTION(\"XMP IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}