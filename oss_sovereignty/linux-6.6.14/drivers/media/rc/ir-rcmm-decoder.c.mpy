{
  "module_name": "ir-rcmm-decoder.c",
  "hash_id": "cd15718b8152bcdd8eafe71a29936f615968d206bbff08cd1f25c59d30a1145d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-rcmm-decoder.c",
  "human_readable_source": "\n\n\n\n\n#include \"rc-core-priv.h\"\n#include <linux/module.h>\n\n#define RCMM_UNIT\t\t166   \n#define RCMM_PREFIX_PULSE\t417   \n#define RCMM_PULSE_0            278   \n#define RCMM_PULSE_1            444   \n#define RCMM_PULSE_2            611   \n#define RCMM_PULSE_3            778   \n\nenum rcmm_state {\n\tSTATE_INACTIVE,\n\tSTATE_LOW,\n\tSTATE_BUMP,\n\tSTATE_VALUE,\n\tSTATE_FINISHED,\n};\n\nstatic bool rcmm_mode(const struct rcmm_dec *data)\n{\n\treturn !((0x000c0000 & data->bits) == 0x000c0000);\n}\n\nstatic int rcmm_miscmode(struct rc_dev *dev, struct rcmm_dec *data)\n{\n\tswitch (data->count) {\n\tcase 24:\n\t\tif (dev->enabled_protocols & RC_PROTO_BIT_RCMM24) {\n\t\t\trc_keydown(dev, RC_PROTO_RCMM24, data->bits, 0);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\n\tcase 12:\n\t\tif (dev->enabled_protocols & RC_PROTO_BIT_RCMM12) {\n\t\t\trc_keydown(dev, RC_PROTO_RCMM12, data->bits, 0);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int ir_rcmm_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct rcmm_dec *data = &dev->raw->rcmm;\n\tu32 scancode;\n\tu8 toggle;\n\tint value;\n\n\tif (!(dev->enabled_protocols & (RC_PROTO_BIT_RCMM32 |\n\t\t\t\t\tRC_PROTO_BIT_RCMM24 |\n\t\t\t\t\tRC_PROTO_BIT_RCMM12)))\n\t\treturn 0;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tswitch (data->state) {\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, RCMM_PREFIX_PULSE, RCMM_UNIT))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_LOW;\n\t\tdata->count = 0;\n\t\tdata->bits  = 0;\n\t\treturn 0;\n\n\tcase STATE_LOW:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, RCMM_PULSE_0, RCMM_UNIT))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BUMP;\n\t\treturn 0;\n\n\tcase STATE_BUMP:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, RCMM_UNIT, RCMM_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_VALUE;\n\t\treturn 0;\n\n\tcase STATE_VALUE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (eq_margin(ev.duration, RCMM_PULSE_0, RCMM_UNIT / 2))\n\t\t\tvalue = 0;\n\t\telse if (eq_margin(ev.duration, RCMM_PULSE_1, RCMM_UNIT / 2))\n\t\t\tvalue = 1;\n\t\telse if (eq_margin(ev.duration, RCMM_PULSE_2, RCMM_UNIT / 2))\n\t\t\tvalue = 2;\n\t\telse if (eq_margin(ev.duration, RCMM_PULSE_3, RCMM_UNIT / 2))\n\t\t\tvalue = 3;\n\t\telse\n\t\t\tvalue = -1;\n\n\t\tif (value == -1) {\n\t\t\tif (!rcmm_miscmode(dev, data))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->bits <<= 2;\n\t\tdata->bits |= value;\n\n\t\tdata->count += 2;\n\n\t\tif (data->count < 32)\n\t\t\tdata->state = STATE_BUMP;\n\t\telse\n\t\t\tdata->state = STATE_FINISHED;\n\n\t\treturn 0;\n\n\tcase STATE_FINISHED:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, RCMM_UNIT, RCMM_UNIT / 2))\n\t\t\tbreak;\n\n\t\tif (rcmm_mode(data)) {\n\t\t\ttoggle = !!(0x8000 & data->bits);\n\t\t\tscancode = data->bits & ~0x8000;\n\t\t} else {\n\t\t\ttoggle = 0;\n\t\t\tscancode = data->bits;\n\t\t}\n\n\t\tif (dev->enabled_protocols & RC_PROTO_BIT_RCMM32) {\n\t\t\trc_keydown(dev, RC_PROTO_RCMM32, scancode, toggle);\n\t\t\tdata->state = STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdev_dbg(&dev->dev, \"RC-MM decode failed at count %d state %d (%uus %s)\\n\",\n\t\tdata->count, data->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const int rcmmspace[] = {\n\tRCMM_PULSE_0,\n\tRCMM_PULSE_1,\n\tRCMM_PULSE_2,\n\tRCMM_PULSE_3,\n};\n\nstatic int ir_rcmm_rawencoder(struct ir_raw_event **ev, unsigned int max,\n\t\t\t      unsigned int n, u32 data)\n{\n\tint i;\n\tint ret;\n\n\tret = ir_raw_gen_pulse_space(ev, &max, RCMM_PREFIX_PULSE, RCMM_PULSE_0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = n - 2; i >= 0; i -= 2) {\n\t\tconst unsigned int space = rcmmspace[(data >> i) & 3];\n\n\t\tret = ir_raw_gen_pulse_space(ev, &max, RCMM_UNIT, space);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ir_raw_gen_pulse_space(ev, &max, RCMM_UNIT, RCMM_PULSE_3 * 2);\n}\n\nstatic int ir_rcmm_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t  struct ir_raw_event *events, unsigned int max)\n{\n\tstruct ir_raw_event *e = events;\n\tint ret;\n\n\tswitch (protocol) {\n\tcase RC_PROTO_RCMM32:\n\t\tret = ir_rcmm_rawencoder(&e, max, 32, scancode);\n\t\tbreak;\n\tcase RC_PROTO_RCMM24:\n\t\tret = ir_rcmm_rawencoder(&e, max, 24, scancode);\n\t\tbreak;\n\tcase RC_PROTO_RCMM12:\n\t\tret = ir_rcmm_rawencoder(&e, max, 12, scancode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler rcmm_handler = {\n\t.protocols\t= RC_PROTO_BIT_RCMM32 |\n\t\t\t  RC_PROTO_BIT_RCMM24 |\n\t\t\t  RC_PROTO_BIT_RCMM12,\n\t.decode\t\t= ir_rcmm_decode,\n\t.encode         = ir_rcmm_encode,\n\t.carrier        = 36000,\n\t.min_timeout\t= RCMM_PULSE_3 + RCMM_UNIT,\n};\n\nstatic int __init ir_rcmm_decode_init(void)\n{\n\tir_raw_handler_register(&rcmm_handler);\n\n\tpr_info(\"IR RCMM protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_rcmm_decode_exit(void)\n{\n\tir_raw_handler_unregister(&rcmm_handler);\n}\n\nmodule_init(ir_rcmm_decode_init);\nmodule_exit(ir_rcmm_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick Lerda\");\nMODULE_DESCRIPTION(\"RCMM IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}