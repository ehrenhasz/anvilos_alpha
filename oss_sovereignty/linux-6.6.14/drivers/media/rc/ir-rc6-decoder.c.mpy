{
  "module_name": "ir-rc6-decoder.c",
  "hash_id": "ac94c46c9267999527e87e93aebfcf2881aac8d58215c5ea1675861b09ac56df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-rc6-decoder.c",
  "human_readable_source": "\n \n\n#include \"rc-core-priv.h\"\n#include <linux/module.h>\n\n \n\n#define RC6_UNIT\t\t444\t \n#define RC6_HEADER_NBITS\t4\t \n#define RC6_0_NBITS\t\t16\n#define RC6_6A_32_NBITS\t\t32\n#define RC6_6A_NBITS\t\t128\t \n#define RC6_PREFIX_PULSE\t(6 * RC6_UNIT)\n#define RC6_PREFIX_SPACE\t(2 * RC6_UNIT)\n#define RC6_BIT_START\t\t(1 * RC6_UNIT)\n#define RC6_BIT_END\t\t(1 * RC6_UNIT)\n#define RC6_TOGGLE_START\t(2 * RC6_UNIT)\n#define RC6_TOGGLE_END\t\t(2 * RC6_UNIT)\n#define RC6_SUFFIX_SPACE\t(6 * RC6_UNIT)\n#define RC6_MODE_MASK\t\t0x07\t \n#define RC6_STARTBIT_MASK\t0x08\t \n#define RC6_6A_MCE_TOGGLE_MASK\t0x8000\t \n#define RC6_6A_LCC_MASK\t\t0xffff0000  \n#define RC6_6A_MCE_CC\t\t0x800f0000  \n#define RC6_6A_ZOTAC_CC\t\t0x80340000  \n#define RC6_6A_KATHREIN_CC\t0x80460000  \n#ifndef CHAR_BIT\n#define CHAR_BIT 8\t \n#endif\n\nenum rc6_mode {\n\tRC6_MODE_0,\n\tRC6_MODE_6A,\n\tRC6_MODE_UNKNOWN,\n};\n\nenum rc6_state {\n\tSTATE_INACTIVE,\n\tSTATE_PREFIX_SPACE,\n\tSTATE_HEADER_BIT_START,\n\tSTATE_HEADER_BIT_END,\n\tSTATE_TOGGLE_START,\n\tSTATE_TOGGLE_END,\n\tSTATE_BODY_BIT_START,\n\tSTATE_BODY_BIT_END,\n\tSTATE_FINISHED,\n};\n\nstatic enum rc6_mode rc6_mode(struct rc6_dec *data)\n{\n\tswitch (data->header & RC6_MODE_MASK) {\n\tcase 0:\n\t\treturn RC6_MODE_0;\n\tcase 6:\n\t\tif (!data->toggle)\n\t\t\treturn RC6_MODE_6A;\n\t\tfallthrough;\n\tdefault:\n\t\treturn RC6_MODE_UNKNOWN;\n\t}\n}\n\n \nstatic int ir_rc6_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct rc6_dec *data = &dev->raw->rc6;\n\tu32 scancode;\n\tu8 toggle;\n\tenum rc_proto protocol;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (!geq_margin(ev.duration, RC6_UNIT, RC6_UNIT / 2))\n\t\tgoto out;\n\nagain:\n\tdev_dbg(&dev->dev, \"RC6 decode started at state %i (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tif (!geq_margin(ev.duration, RC6_UNIT, RC6_UNIT / 2))\n\t\treturn 0;\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!eq_margin(ev.duration, RC6_PREFIX_PULSE, RC6_UNIT))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_PREFIX_SPACE;\n\t\tdata->count = 0;\n\t\treturn 0;\n\n\tcase STATE_PREFIX_SPACE:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (!eq_margin(ev.duration, RC6_PREFIX_SPACE, RC6_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->state = STATE_HEADER_BIT_START;\n\t\tdata->header = 0;\n\t\treturn 0;\n\n\tcase STATE_HEADER_BIT_START:\n\t\tif (!eq_margin(ev.duration, RC6_BIT_START, RC6_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->header <<= 1;\n\t\tif (ev.pulse)\n\t\t\tdata->header |= 1;\n\t\tdata->count++;\n\t\tdata->state = STATE_HEADER_BIT_END;\n\t\treturn 0;\n\n\tcase STATE_HEADER_BIT_END:\n\t\tif (data->count == RC6_HEADER_NBITS)\n\t\t\tdata->state = STATE_TOGGLE_START;\n\t\telse\n\t\t\tdata->state = STATE_HEADER_BIT_START;\n\n\t\tdecrease_duration(&ev, RC6_BIT_END);\n\t\tgoto again;\n\n\tcase STATE_TOGGLE_START:\n\t\tif (!eq_margin(ev.duration, RC6_TOGGLE_START, RC6_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->toggle = ev.pulse;\n\t\tdata->state = STATE_TOGGLE_END;\n\t\treturn 0;\n\n\tcase STATE_TOGGLE_END:\n\t\tif (!(data->header & RC6_STARTBIT_MASK)) {\n\t\t\tdev_dbg(&dev->dev, \"RC6 invalid start bit\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->state = STATE_BODY_BIT_START;\n\t\tdecrease_duration(&ev, RC6_TOGGLE_END);\n\t\tdata->count = 0;\n\t\tdata->body = 0;\n\n\t\tswitch (rc6_mode(data)) {\n\t\tcase RC6_MODE_0:\n\t\t\tdata->wanted_bits = RC6_0_NBITS;\n\t\t\tbreak;\n\t\tcase RC6_MODE_6A:\n\t\t\tdata->wanted_bits = RC6_6A_NBITS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"RC6 unknown mode\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\n\tcase STATE_BODY_BIT_START:\n\t\tif (eq_margin(ev.duration, RC6_BIT_START, RC6_UNIT / 2)) {\n\t\t\t \n\t\t\tif (data->count++ < CHAR_BIT * sizeof data->body) {\n\t\t\t\tdata->body <<= 1;\n\t\t\t\tif (ev.pulse)\n\t\t\t\t\tdata->body |= 1;\n\t\t\t}\n\t\t\tdata->state = STATE_BODY_BIT_END;\n\t\t\treturn 0;\n\t\t} else if (RC6_MODE_6A == rc6_mode(data) && !ev.pulse &&\n\t\t\t\tgeq_margin(ev.duration, RC6_SUFFIX_SPACE, RC6_UNIT / 2)) {\n\t\t\tdata->state = STATE_FINISHED;\n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\n\tcase STATE_BODY_BIT_END:\n\t\tif (data->count == data->wanted_bits)\n\t\t\tdata->state = STATE_FINISHED;\n\t\telse\n\t\t\tdata->state = STATE_BODY_BIT_START;\n\n\t\tdecrease_duration(&ev, RC6_BIT_END);\n\t\tgoto again;\n\n\tcase STATE_FINISHED:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tswitch (rc6_mode(data)) {\n\t\tcase RC6_MODE_0:\n\t\t\tscancode = data->body;\n\t\t\ttoggle = data->toggle;\n\t\t\tprotocol = RC_PROTO_RC6_0;\n\t\t\tdev_dbg(&dev->dev, \"RC6(0) scancode 0x%04x (toggle: %u)\\n\",\n\t\t\t\tscancode, toggle);\n\t\t\tbreak;\n\n\t\tcase RC6_MODE_6A:\n\t\t\tif (data->count > CHAR_BIT * sizeof data->body) {\n\t\t\t\tdev_dbg(&dev->dev, \"RC6 too many (%u) data bits\\n\",\n\t\t\t\t\tdata->count);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tscancode = data->body;\n\t\t\tswitch (data->count) {\n\t\t\tcase 20:\n\t\t\t\tprotocol = RC_PROTO_RC6_6A_20;\n\t\t\t\ttoggle = 0;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tprotocol = RC_PROTO_RC6_6A_24;\n\t\t\t\ttoggle = 0;\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tswitch (scancode & RC6_6A_LCC_MASK) {\n\t\t\t\tcase RC6_6A_MCE_CC:\n\t\t\t\tcase RC6_6A_KATHREIN_CC:\n\t\t\t\tcase RC6_6A_ZOTAC_CC:\n\t\t\t\t\tprotocol = RC_PROTO_RC6_MCE;\n\t\t\t\t\ttoggle = !!(scancode & RC6_6A_MCE_TOGGLE_MASK);\n\t\t\t\t\tscancode &= ~RC6_6A_MCE_TOGGLE_MASK;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprotocol = RC_PROTO_RC6_6A_32;\n\t\t\t\t\ttoggle = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&dev->dev, \"RC6(6A) unsupported length\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdev_dbg(&dev->dev, \"RC6(6A) proto 0x%04x, scancode 0x%08x (toggle: %u)\\n\",\n\t\t\t\tprotocol, scancode, toggle);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"RC6 unknown mode\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc_keydown(dev, protocol, scancode, toggle);\n\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"RC6 decode failed at state %i (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const struct ir_raw_timings_manchester ir_rc6_timings[4] = {\n\t{\n\t\t.leader_pulse\t\t= RC6_PREFIX_PULSE,\n\t\t.leader_space\t\t= RC6_PREFIX_SPACE,\n\t\t.clock\t\t\t= RC6_UNIT,\n\t\t.invert\t\t\t= 1,\n\t},\n\t{\n\t\t.clock\t\t\t= RC6_UNIT * 2,\n\t\t.invert\t\t\t= 1,\n\t},\n\t{\n\t\t.clock\t\t\t= RC6_UNIT,\n\t\t.invert\t\t\t= 1,\n\t\t.trailer_space\t\t= RC6_SUFFIX_SPACE,\n\t},\n};\n\n \nstatic int ir_rc6_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t struct ir_raw_event *events, unsigned int max)\n{\n\tint ret;\n\tstruct ir_raw_event *e = events;\n\n\tif (protocol == RC_PROTO_RC6_0) {\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[0],\n\t\t\t\t\t    RC6_HEADER_NBITS, (1 << 3));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[1], 1, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[2], RC6_0_NBITS,\n\t\t\t\t\t    scancode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t} else {\n\t\tint bits;\n\n\t\tswitch (protocol) {\n\t\tcase RC_PROTO_RC6_MCE:\n\t\tcase RC_PROTO_RC6_6A_32:\n\t\t\tbits = 32;\n\t\t\tbreak;\n\t\tcase RC_PROTO_RC6_6A_24:\n\t\t\tbits = 24;\n\t\t\tbreak;\n\t\tcase RC_PROTO_RC6_6A_20:\n\t\t\tbits = 20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[0],\n\t\t\t\t\t    RC6_HEADER_NBITS, (1 << 3 | 6));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[1], 1, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc6_timings[2],\n\t\t\t\t\t    bits,\n\t\t\t\t\t    scancode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler rc6_handler = {\n\t.protocols\t= RC_PROTO_BIT_RC6_0 | RC_PROTO_BIT_RC6_6A_20 |\n\t\t\t  RC_PROTO_BIT_RC6_6A_24 | RC_PROTO_BIT_RC6_6A_32 |\n\t\t\t  RC_PROTO_BIT_RC6_MCE,\n\t.decode\t\t= ir_rc6_decode,\n\t.encode\t\t= ir_rc6_encode,\n\t.carrier\t= 36000,\n\t.min_timeout\t= RC6_SUFFIX_SPACE,\n};\n\nstatic int __init ir_rc6_decode_init(void)\n{\n\tir_raw_handler_register(&rc6_handler);\n\n\tprintk(KERN_INFO \"IR RC6 protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_rc6_decode_exit(void)\n{\n\tir_raw_handler_unregister(&rc6_handler);\n}\n\nmodule_init(ir_rc6_decode_init);\nmodule_exit(ir_rc6_decode_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David H\u00e4rdeman <david@hardeman.nu>\");\nMODULE_DESCRIPTION(\"RC6 IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}