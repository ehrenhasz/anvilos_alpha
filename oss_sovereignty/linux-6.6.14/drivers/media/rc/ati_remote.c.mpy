{
  "module_name": "ati_remote.c",
  "hash_id": "eee6c74f459ff010452911875b213b0a99f7267c67865e8e3a630049eaff88e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ati_remote.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/usb/input.h>\n#include <linux/wait.h>\n#include <linux/jiffies.h>\n#include <media/rc-core.h>\n\n \n\n#define ATI_REMOTE_VENDOR_ID\t\t0x0bc7\n#define LOLA_REMOTE_PRODUCT_ID\t\t0x0002\n#define LOLA2_REMOTE_PRODUCT_ID\t\t0x0003\n#define ATI_REMOTE_PRODUCT_ID\t\t0x0004\n#define NVIDIA_REMOTE_PRODUCT_ID\t0x0005\n#define MEDION_REMOTE_PRODUCT_ID\t0x0006\n#define FIREFLY_REMOTE_PRODUCT_ID\t0x0008\n\n#define DRIVER_VERSION\t\t\"2.2.1\"\n#define DRIVER_AUTHOR           \"Torrey Hoffman <thoffman@arnor.net>\"\n#define DRIVER_DESC             \"ATI/X10 RF USB Remote Control\"\n\n#define NAME_BUFSIZE      80     \n#define DATA_BUFSIZE      63     \n\n \n#define FILTER_TIME\t60  \n#define REPEAT_DELAY\t500  \n\nstatic unsigned long channel_mask;\nmodule_param(channel_mask, ulong, 0644);\nMODULE_PARM_DESC(channel_mask, \"Bitmask of remote control channels to ignore\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable extra debug messages and information\");\n\nstatic int repeat_filter = FILTER_TIME;\nmodule_param(repeat_filter, int, 0644);\nMODULE_PARM_DESC(repeat_filter, \"Repeat filter time, default = 60 msec\");\n\nstatic int repeat_delay = REPEAT_DELAY;\nmodule_param(repeat_delay, int, 0644);\nMODULE_PARM_DESC(repeat_delay, \"Delay before sending repeats, default = 500 msec\");\n\nstatic bool mouse = true;\nmodule_param(mouse, bool, 0444);\nMODULE_PARM_DESC(mouse, \"Enable mouse device, default = yes\");\n\n#define dbginfo(dev, format, arg...) \\\n\tdo { if (debug) dev_info(dev , format , ## arg); } while (0)\n\nstruct ati_receiver_type {\n\t \n\tconst char *default_keymap;\n\tconst char *(*get_default_keymap)(struct usb_interface *interface);\n};\n\nstatic const char *get_medion_keymap(struct usb_interface *interface)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\n\t \n\n\tif (udev->manufacturer && udev->product) {\n\t\tif (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP) {\n\n\t\t\tif (!strcmp(udev->manufacturer, \"X10 Wireless Technology Inc\")\n\t\t\t    && !strcmp(udev->product, \"USB Receiver\"))\n\t\t\t\treturn RC_MAP_MEDION_X10_DIGITAINER;\n\n\t\t\tif (!strcmp(udev->manufacturer, \"X10 WTI\")\n\t\t\t    && !strcmp(udev->product, \"RF receiver\"))\n\t\t\t\treturn RC_MAP_MEDION_X10_OR2X;\n\t\t} else {\n\n\t\t\t if (!strcmp(udev->manufacturer, \"X10 Wireless Technology Inc\")\n\t\t\t    && !strcmp(udev->product, \"USB Receiver\"))\n\t\t\t\treturn RC_MAP_MEDION_X10;\n\t\t}\n\t}\n\n\tdev_info(&interface->dev,\n\t\t \"Unknown Medion X10 receiver, using default ati_remote Medion keymap\\n\");\n\n\treturn RC_MAP_MEDION_X10;\n}\n\nstatic const struct ati_receiver_type type_ati\t\t= {\n\t.default_keymap = RC_MAP_ATI_X10\n};\nstatic const struct ati_receiver_type type_medion\t= {\n\t.get_default_keymap = get_medion_keymap\n};\nstatic const struct ati_receiver_type type_firefly\t= {\n\t.default_keymap = RC_MAP_SNAPSTREAM_FIREFLY\n};\n\nstatic const struct usb_device_id ati_remote_table[] = {\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, LOLA_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_ati\n\t},\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, LOLA2_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_ati\n\t},\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, ATI_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_ati\n\t},\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, NVIDIA_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_ati\n\t},\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, MEDION_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_medion\n\t},\n\t{\n\t\tUSB_DEVICE(ATI_REMOTE_VENDOR_ID, FIREFLY_REMOTE_PRODUCT_ID),\n\t\t.driver_info = (unsigned long)&type_firefly\n\t},\n\t{}\t \n};\n\nMODULE_DEVICE_TABLE(usb, ati_remote_table);\n\n \n#define HI(a)\t((unsigned char)((a) >> 8))\n#define LO(a)\t((unsigned char)((a) & 0xff))\n\n#define SEND_FLAG_IN_PROGRESS\t1\n#define SEND_FLAG_COMPLETE\t2\n\n \nstatic char init1[] = { 0x01, 0x00, 0x20, 0x14 };\nstatic char init2[] = { 0x01, 0x00, 0x20, 0x14, 0x20, 0x20, 0x20 };\n\nstruct ati_remote {\n\tstruct input_dev *idev;\n\tstruct rc_dev *rdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\n\tstruct urb *irq_urb;\n\tstruct urb *out_urb;\n\tstruct usb_endpoint_descriptor *endpoint_in;\n\tstruct usb_endpoint_descriptor *endpoint_out;\n\tunsigned char *inbuf;\n\tunsigned char *outbuf;\n\tdma_addr_t inbuf_dma;\n\tdma_addr_t outbuf_dma;\n\n\tunsigned char old_data;      \n\tunsigned long old_jiffies;\n\tunsigned long acc_jiffies;   \n\tunsigned long first_jiffies;\n\n\tunsigned int repeat_count;\n\n\tchar rc_name[NAME_BUFSIZE];\n\tchar rc_phys[NAME_BUFSIZE];\n\tchar mouse_name[NAME_BUFSIZE];\n\tchar mouse_phys[NAME_BUFSIZE];\n\n\twait_queue_head_t wait;\n\tint send_flags;\n\n\tint users;  \n\tstruct mutex open_mutex;\n};\n\n \n#define KIND_END        0\n#define KIND_LITERAL    1    \n#define KIND_FILTERED   2    \n#define KIND_ACCEL      3    \n\n \nstatic const struct {\n\tunsigned char kind;\n\tunsigned char data;\t \n\tunsigned short code;\t \n}  ati_remote_tbl[] = {\n\t \n\t{KIND_ACCEL,    0x70, 0xff00},\t \n\t{KIND_ACCEL,    0x71, 0x0100},\t \n\t{KIND_ACCEL,    0x72, 0x00ff},\t \n\t{KIND_ACCEL,    0x73, 0x0001},\t \n\n\t \n\t{KIND_ACCEL,    0x74, 0xffff},\t \n\t{KIND_ACCEL,    0x75, 0x01ff},\t \n\t{KIND_ACCEL,    0x77, 0xff01},\t \n\t{KIND_ACCEL,    0x76, 0x0101},\t \n\n\t \n\t{KIND_LITERAL,  0x78, BTN_LEFT},  \n\t{KIND_LITERAL,  0x79, BTN_LEFT},  \n\t{KIND_LITERAL,  0x7c, BTN_RIGHT}, \n\t{KIND_LITERAL,  0x7d, BTN_RIGHT}, \n\n\t \n\t{KIND_FILTERED, 0x7a, BTN_SIDE},  \n\t{KIND_FILTERED, 0x7e, BTN_EXTRA}, \n\n\t \n\t{KIND_END, 0x00, 0}\n};\n\n \nstatic void ati_remote_dump(struct device *dev, unsigned char *data,\n\t\t\t    unsigned int len)\n{\n\tif (len == 1) {\n\t\tif (data[0] != (unsigned char)0xff && data[0] != 0x00)\n\t\t\tdev_warn(dev, \"Weird byte 0x%02x\\n\", data[0]);\n\t} else if (len == 4)\n\t\tdev_warn(dev, \"Weird key %*ph\\n\", 4, data);\n\telse\n\t\tdev_warn(dev, \"Weird data, len=%d %*ph ...\\n\", len, 6, data);\n}\n\n \nstatic int ati_remote_open(struct ati_remote *ati_remote)\n{\n\tint err = 0;\n\n\tmutex_lock(&ati_remote->open_mutex);\n\n\tif (ati_remote->users++ != 0)\n\t\tgoto out;  \n\n\t \n\tati_remote->irq_urb->dev = ati_remote->udev;\n\tif (usb_submit_urb(ati_remote->irq_urb, GFP_KERNEL)) {\n\t\tdev_err(&ati_remote->interface->dev,\n\t\t\t\"%s: usb_submit_urb failed!\\n\", __func__);\n\t\terr = -EIO;\n\t}\n\nout:\tmutex_unlock(&ati_remote->open_mutex);\n\treturn err;\n}\n\n \nstatic void ati_remote_close(struct ati_remote *ati_remote)\n{\n\tmutex_lock(&ati_remote->open_mutex);\n\tif (--ati_remote->users == 0)\n\t\tusb_kill_urb(ati_remote->irq_urb);\n\tmutex_unlock(&ati_remote->open_mutex);\n}\n\nstatic int ati_remote_input_open(struct input_dev *inputdev)\n{\n\tstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\n\treturn ati_remote_open(ati_remote);\n}\n\nstatic void ati_remote_input_close(struct input_dev *inputdev)\n{\n\tstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\n\tati_remote_close(ati_remote);\n}\n\nstatic int ati_remote_rc_open(struct rc_dev *rdev)\n{\n\tstruct ati_remote *ati_remote = rdev->priv;\n\treturn ati_remote_open(ati_remote);\n}\n\nstatic void ati_remote_rc_close(struct rc_dev *rdev)\n{\n\tstruct ati_remote *ati_remote = rdev->priv;\n\tati_remote_close(ati_remote);\n}\n\n \nstatic void ati_remote_irq_out(struct urb *urb)\n{\n\tstruct ati_remote *ati_remote = urb->context;\n\n\tif (urb->status) {\n\t\tdev_dbg(&ati_remote->interface->dev, \"%s: status %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\t}\n\n\tati_remote->send_flags |= SEND_FLAG_COMPLETE;\n\twmb();\n\twake_up(&ati_remote->wait);\n}\n\n \nstatic int ati_remote_sendpacket(struct ati_remote *ati_remote, u16 cmd,\n\tunsigned char *data)\n{\n\tint retval = 0;\n\n\t \n\tmemcpy(ati_remote->out_urb->transfer_buffer + 1, data, LO(cmd));\n\t((char *) ati_remote->out_urb->transfer_buffer)[0] = HI(cmd);\n\n\tati_remote->out_urb->transfer_buffer_length = LO(cmd) + 1;\n\tati_remote->out_urb->dev = ati_remote->udev;\n\tati_remote->send_flags = SEND_FLAG_IN_PROGRESS;\n\n\tretval = usb_submit_urb(ati_remote->out_urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_dbg(&ati_remote->interface->dev,\n\t\t\t \"sendpacket: usb_submit_urb failed: %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\twait_event_timeout(ati_remote->wait,\n\t\t((ati_remote->out_urb->status != -EINPROGRESS) ||\n\t\t\t(ati_remote->send_flags & SEND_FLAG_COMPLETE)),\n\t\tHZ);\n\tusb_kill_urb(ati_remote->out_urb);\n\n\treturn retval;\n}\n\nstruct accel_times {\n\tconst char\tvalue;\n\tunsigned int\tmsecs;\n};\n\nstatic const struct accel_times accel[] = {\n\t{  1,  125 },\n\t{  2,  250 },\n\t{  4,  500 },\n\t{  6, 1000 },\n\t{  9, 1500 },\n\t{ 13, 2000 },\n\t{ 20,    0 },\n};\n\n \nstatic int ati_remote_compute_accel(struct ati_remote *ati_remote)\n{\n\tunsigned long now = jiffies, reset_time;\n\tint i;\n\n\treset_time = msecs_to_jiffies(250);\n\n\tif (time_after(now, ati_remote->old_jiffies + reset_time)) {\n\t\tati_remote->acc_jiffies = now;\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(accel) - 1; i++) {\n\t\tunsigned long timeout = msecs_to_jiffies(accel[i].msecs);\n\n\t\tif (time_before(now, ati_remote->acc_jiffies + timeout))\n\t\t\treturn accel[i].value;\n\t}\n\treturn accel[i].value;\n}\n\n \nstatic void ati_remote_input_report(struct urb *urb)\n{\n\tstruct ati_remote *ati_remote = urb->context;\n\tunsigned char *data= ati_remote->inbuf;\n\tstruct input_dev *dev = ati_remote->idev;\n\tint index = -1;\n\tint remote_num;\n\tunsigned char scancode;\n\tu32 wheel_keycode = KEY_RESERVED;\n\tint i;\n\n\t \n\n\t \n\tif ( urb->actual_length != 4 || data[0] != 0x14 ||\n\t     data[1] != (unsigned char)(data[2] + data[3] + 0xD5) ||\n\t     (data[3] & 0x0f) != 0x00) {\n\t\tati_remote_dump(&urb->dev->dev, data, urb->actual_length);\n\t\treturn;\n\t}\n\n\tif (data[1] != ((data[2] + data[3] + 0xd5) & 0xff)) {\n\t\tdbginfo(&ati_remote->interface->dev,\n\t\t\t\"wrong checksum in input: %*ph\\n\", 4, data);\n\t\treturn;\n\t}\n\n\t \n\t \n\tremote_num = (data[3] >> 4) & 0x0f;\n\tif (channel_mask & (1 << (remote_num + 1))) {\n\t\tdbginfo(&ati_remote->interface->dev,\n\t\t\t\"Masked input from channel 0x%02x: data %02x, mask= 0x%02lx\\n\",\n\t\t\tremote_num, data[2], channel_mask);\n\t\treturn;\n\t}\n\n\t \n\tscancode = data[2] & 0x7f;\n\n\tdbginfo(&ati_remote->interface->dev,\n\t\t\"channel 0x%02x; key data %02x, scancode %02x\\n\",\n\t\tremote_num, data[2], scancode);\n\n\tif (scancode >= 0x70) {\n\t\t \n\t\twheel_keycode = rc_g_keycode_from_table(ati_remote->rdev,\n\t\t\t\t\t\t\tscancode & 0x78);\n\n\t\tif (wheel_keycode == KEY_RESERVED) {\n\t\t\t \n\n\t\t\t \n\t\t\tfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++) {\n\t\t\t\tif (scancode == ati_remote_tbl[i].data) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (index >= 0 && ati_remote_tbl[index].kind == KIND_LITERAL) {\n\t\t \n\t\tinput_event(dev, EV_KEY, ati_remote_tbl[index].code,\n\t\t\t!(data[2] & 1));\n\n\t\tati_remote->old_jiffies = jiffies;\n\n\t} else if (index < 0 || ati_remote_tbl[index].kind == KIND_FILTERED) {\n\t\tunsigned long now = jiffies;\n\n\t\t \n\t\tif (ati_remote->old_data == data[2] &&\n\t\t    time_before(now, ati_remote->old_jiffies +\n\t\t\t\t     msecs_to_jiffies(repeat_filter))) {\n\t\t\tati_remote->repeat_count++;\n\t\t} else {\n\t\t\tati_remote->repeat_count = 0;\n\t\t\tati_remote->first_jiffies = now;\n\t\t}\n\n\t\tati_remote->old_jiffies = now;\n\n\t\t \n\t\tif (ati_remote->repeat_count > 0 &&\n\t\t    (ati_remote->repeat_count < 5 ||\n\t\t     time_before(now, ati_remote->first_jiffies +\n\t\t\t\t      msecs_to_jiffies(repeat_delay))))\n\t\t\treturn;\n\n\t\tif (index >= 0) {\n\t\t\tinput_event(dev, EV_KEY, ati_remote_tbl[index].code, 1);\n\t\t\tinput_event(dev, EV_KEY, ati_remote_tbl[index].code, 0);\n\t\t} else {\n\t\t\t \n\t\t\tint count = 1;\n\n\t\t\tif (wheel_keycode != KEY_RESERVED) {\n\t\t\t\t \n\t\t\t\tcount = (scancode & 0x07) + 1;\n\t\t\t\tscancode &= 0x78;\n\t\t\t}\n\n\t\t\twhile (count--) {\n\t\t\t\t \n\t\t\t\trc_keydown_notimeout(ati_remote->rdev,\n\t\t\t\t\t\t     RC_PROTO_OTHER,\n\t\t\t\t\t\t     scancode, data[2]);\n\t\t\t\trc_keyup(ati_remote->rdev);\n\t\t\t}\n\t\t\tgoto nosync;\n\t\t}\n\n\t} else if (ati_remote_tbl[index].kind == KIND_ACCEL) {\n\t\tsigned char dx = ati_remote_tbl[index].code >> 8;\n\t\tsigned char dy = ati_remote_tbl[index].code & 255;\n\n\t\t \n\t\tint acc = ati_remote_compute_accel(ati_remote);\n\t\tif (dx)\n\t\t\tinput_report_rel(dev, REL_X, dx * acc);\n\t\tif (dy)\n\t\t\tinput_report_rel(dev, REL_Y, dy * acc);\n\t\tati_remote->old_jiffies = jiffies;\n\n\t} else {\n\t\tdev_dbg(&ati_remote->interface->dev, \"ati_remote kind=%d\\n\",\n\t\t\tati_remote_tbl[index].kind);\n\t\treturn;\n\t}\n\tinput_sync(dev);\nnosync:\n\tati_remote->old_data = data[2];\n}\n\n \nstatic void ati_remote_irq_in(struct urb *urb)\n{\n\tstruct ati_remote *ati_remote = urb->context;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\tati_remote_input_report(urb);\n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&ati_remote->interface->dev,\n\t\t\t\"%s: urb error status, unlink?\\n\",\n\t\t\t__func__);\n\t\treturn;\n\tdefault:\t\t \n\t\tdev_dbg(&ati_remote->interface->dev,\n\t\t\t\"%s: Nonzero urb status %d\\n\",\n\t\t\t__func__, urb->status);\n\t}\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&ati_remote->interface->dev,\n\t\t\t\"%s: usb_submit_urb()=%d\\n\",\n\t\t\t__func__, retval);\n}\n\n \nstatic int ati_remote_alloc_buffers(struct usb_device *udev,\n\t\t\t\t    struct ati_remote *ati_remote)\n{\n\tati_remote->inbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\n\t\t\t\t\t       &ati_remote->inbuf_dma);\n\tif (!ati_remote->inbuf)\n\t\treturn -1;\n\n\tati_remote->outbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\n\t\t\t\t\t\t&ati_remote->outbuf_dma);\n\tif (!ati_remote->outbuf)\n\t\treturn -1;\n\n\tati_remote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!ati_remote->irq_urb)\n\t\treturn -1;\n\n\tati_remote->out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!ati_remote->out_urb)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic void ati_remote_free_buffers(struct ati_remote *ati_remote)\n{\n\tusb_free_urb(ati_remote->irq_urb);\n\tusb_free_urb(ati_remote->out_urb);\n\n\tusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\n\t\tati_remote->inbuf, ati_remote->inbuf_dma);\n\n\tusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\n\t\tati_remote->outbuf, ati_remote->outbuf_dma);\n}\n\nstatic void ati_remote_input_init(struct ati_remote *ati_remote)\n{\n\tstruct input_dev *idev = ati_remote->idev;\n\tint i;\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tidev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_SIDE) | BIT_MASK(BTN_EXTRA);\n\tidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\tfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++)\n\t\tif (ati_remote_tbl[i].kind == KIND_LITERAL ||\n\t\t    ati_remote_tbl[i].kind == KIND_FILTERED)\n\t\t\t__set_bit(ati_remote_tbl[i].code, idev->keybit);\n\n\tinput_set_drvdata(idev, ati_remote);\n\n\tidev->open = ati_remote_input_open;\n\tidev->close = ati_remote_input_close;\n\n\tidev->name = ati_remote->mouse_name;\n\tidev->phys = ati_remote->mouse_phys;\n\n\tusb_to_input_id(ati_remote->udev, &idev->id);\n\tidev->dev.parent = &ati_remote->interface->dev;\n}\n\nstatic void ati_remote_rc_init(struct ati_remote *ati_remote)\n{\n\tstruct rc_dev *rdev = ati_remote->rdev;\n\n\trdev->priv = ati_remote;\n\trdev->allowed_protocols = RC_PROTO_BIT_OTHER;\n\trdev->driver_name = \"ati_remote\";\n\n\trdev->open = ati_remote_rc_open;\n\trdev->close = ati_remote_rc_close;\n\n\trdev->device_name = ati_remote->rc_name;\n\trdev->input_phys = ati_remote->rc_phys;\n\n\tusb_to_input_id(ati_remote->udev, &rdev->input_id);\n\trdev->dev.parent = &ati_remote->interface->dev;\n}\n\nstatic int ati_remote_initialize(struct ati_remote *ati_remote)\n{\n\tstruct usb_device *udev = ati_remote->udev;\n\tint pipe, maxp;\n\n\tinit_waitqueue_head(&ati_remote->wait);\n\n\t \n\tpipe = usb_rcvintpipe(udev, ati_remote->endpoint_in->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe);\n\tmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\n\n\tusb_fill_int_urb(ati_remote->irq_urb, udev, pipe, ati_remote->inbuf,\n\t\t\t maxp, ati_remote_irq_in, ati_remote,\n\t\t\t ati_remote->endpoint_in->bInterval);\n\tati_remote->irq_urb->transfer_dma = ati_remote->inbuf_dma;\n\tati_remote->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tpipe = usb_sndintpipe(udev, ati_remote->endpoint_out->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe);\n\tmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\n\n\tusb_fill_int_urb(ati_remote->out_urb, udev, pipe, ati_remote->outbuf,\n\t\t\t maxp, ati_remote_irq_out, ati_remote,\n\t\t\t ati_remote->endpoint_out->bInterval);\n\tati_remote->out_urb->transfer_dma = ati_remote->outbuf_dma;\n\tati_remote->out_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tif ((ati_remote_sendpacket(ati_remote, 0x8004, init1)) ||\n\t    (ati_remote_sendpacket(ati_remote, 0x8007, init2))) {\n\t\tdev_err(&ati_remote->interface->dev,\n\t\t\t \"Initializing ati_remote hardware failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ati_remote_probe(struct usb_interface *interface,\n\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *iface_host = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint_in, *endpoint_out;\n\tstruct ati_receiver_type *type = (struct ati_receiver_type *)id->driver_info;\n\tstruct ati_remote *ati_remote;\n\tstruct input_dev *input_dev;\n\tstruct device *device = &interface->dev;\n\tstruct rc_dev *rc_dev;\n\tint err = -ENOMEM;\n\n\tif (iface_host->desc.bNumEndpoints != 2) {\n\t\tdev_err(device, \"%s: Unexpected desc.bNumEndpoints\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tendpoint_in = &iface_host->endpoint[0].desc;\n\tendpoint_out = &iface_host->endpoint[1].desc;\n\n\tif (!usb_endpoint_is_int_in(endpoint_in)) {\n\t\tdev_err(device, \"%s: Unexpected endpoint_in\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (le16_to_cpu(endpoint_in->wMaxPacketSize) == 0) {\n\t\tdev_err(device, \"%s: endpoint_in message size==0?\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (!usb_endpoint_is_int_out(endpoint_out)) {\n\t\tdev_err(device, \"%s: Unexpected endpoint_out\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tati_remote = kzalloc(sizeof (struct ati_remote), GFP_KERNEL);\n\trc_dev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!ati_remote || !rc_dev)\n\t\tgoto exit_free_dev_rdev;\n\n\t \n\tif (ati_remote_alloc_buffers(udev, ati_remote))\n\t\tgoto exit_free_buffers;\n\n\tati_remote->endpoint_in = endpoint_in;\n\tati_remote->endpoint_out = endpoint_out;\n\tati_remote->udev = udev;\n\tati_remote->rdev = rc_dev;\n\tati_remote->interface = interface;\n\n\tusb_make_path(udev, ati_remote->rc_phys, sizeof(ati_remote->rc_phys));\n\tstrscpy(ati_remote->mouse_phys, ati_remote->rc_phys,\n\t\tsizeof(ati_remote->mouse_phys));\n\n\tstrlcat(ati_remote->rc_phys, \"/input0\", sizeof(ati_remote->rc_phys));\n\tstrlcat(ati_remote->mouse_phys, \"/input1\", sizeof(ati_remote->mouse_phys));\n\n\tsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name), \"%s%s%s\",\n\t\tudev->manufacturer ?: \"\",\n\t\tudev->manufacturer && udev->product ? \" \" : \"\",\n\t\tudev->product ?: \"\");\n\n\tif (!strlen(ati_remote->rc_name))\n\t\tsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name),\n\t\t\tDRIVER_DESC \"(%04x,%04x)\",\n\t\t\tle16_to_cpu(ati_remote->udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(ati_remote->udev->descriptor.idProduct));\n\n\tsnprintf(ati_remote->mouse_name, sizeof(ati_remote->mouse_name),\n\t\t \"%s mouse\", ati_remote->rc_name);\n\n\trc_dev->map_name = RC_MAP_ATI_X10;  \n\n\t \n\tif (type) {\n\t\tif (type->default_keymap)\n\t\t\trc_dev->map_name = type->default_keymap;\n\t\telse if (type->get_default_keymap)\n\t\t\trc_dev->map_name = type->get_default_keymap(interface);\n\t}\n\n\tati_remote_rc_init(ati_remote);\n\tmutex_init(&ati_remote->open_mutex);\n\n\t \n\terr = ati_remote_initialize(ati_remote);\n\tif (err)\n\t\tgoto exit_kill_urbs;\n\n\t \n\terr = rc_register_device(ati_remote->rdev);\n\tif (err)\n\t\tgoto exit_kill_urbs;\n\n\t \n\tif (mouse) {\n\t\tinput_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_unregister_device;\n\t\t}\n\n\t\tati_remote->idev = input_dev;\n\t\tati_remote_input_init(ati_remote);\n\t\terr = input_register_device(input_dev);\n\n\t\tif (err)\n\t\t\tgoto exit_free_input_device;\n\t}\n\n\tusb_set_intfdata(interface, ati_remote);\n\treturn 0;\n\n exit_free_input_device:\n\tinput_free_device(input_dev);\n exit_unregister_device:\n\trc_unregister_device(rc_dev);\n\trc_dev = NULL;\n exit_kill_urbs:\n\tusb_kill_urb(ati_remote->irq_urb);\n\tusb_kill_urb(ati_remote->out_urb);\n exit_free_buffers:\n\tati_remote_free_buffers(ati_remote);\n exit_free_dev_rdev:\n\t rc_free_device(rc_dev);\n\tkfree(ati_remote);\n\treturn err;\n}\n\n \nstatic void ati_remote_disconnect(struct usb_interface *interface)\n{\n\tstruct ati_remote *ati_remote;\n\n\tati_remote = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\tif (!ati_remote) {\n\t\tdev_warn(&interface->dev, \"%s - null device?\\n\", __func__);\n\t\treturn;\n\t}\n\n\tusb_kill_urb(ati_remote->irq_urb);\n\tusb_kill_urb(ati_remote->out_urb);\n\tif (ati_remote->idev)\n\t\tinput_unregister_device(ati_remote->idev);\n\trc_unregister_device(ati_remote->rdev);\n\tati_remote_free_buffers(ati_remote);\n\tkfree(ati_remote);\n}\n\n \nstatic struct usb_driver ati_remote_driver = {\n\t.name         = \"ati_remote\",\n\t.probe        = ati_remote_probe,\n\t.disconnect   = ati_remote_disconnect,\n\t.id_table     = ati_remote_table,\n};\n\nmodule_usb_driver(ati_remote_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}