{
  "module_name": "ir-spi.c",
  "hash_id": "fe4109c8c334b1da4956fa0eddb327c1490245aeefbce2e055b7abc2f811e83e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-spi.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <media/rc-core.h>\n\n#define IR_SPI_DRIVER_NAME\t\t\"ir-spi\"\n\n#define IR_SPI_DEFAULT_FREQUENCY\t38000\n#define IR_SPI_MAX_BUFSIZE\t\t 4096\n\nstruct ir_spi_data {\n\tu32 freq;\n\tbool negated;\n\n\tu16 tx_buf[IR_SPI_MAX_BUFSIZE];\n\tu16 pulse;\n\tu16 space;\n\n\tstruct rc_dev *rc;\n\tstruct spi_device *spi;\n\tstruct regulator *regulator;\n};\n\nstatic int ir_spi_tx(struct rc_dev *dev,\n\t\t     unsigned int *buffer, unsigned int count)\n{\n\tint i;\n\tint ret;\n\tunsigned int len = 0;\n\tstruct ir_spi_data *idata = dev->priv;\n\tstruct spi_transfer xfer;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tunsigned int periods;\n\t\tint j;\n\t\tu16 val;\n\n\t\tperiods = DIV_ROUND_CLOSEST(buffer[i] * idata->freq, 1000000);\n\n\t\tif (len + periods >= IR_SPI_MAX_BUFSIZE)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tval = (i % 2) ? idata->space : idata->pulse;\n\t\tfor (j = 0; j < periods; j++)\n\t\t\tidata->tx_buf[len++] = val;\n\t}\n\n\tmemset(&xfer, 0, sizeof(xfer));\n\n\txfer.speed_hz = idata->freq * 16;\n\txfer.len = len * sizeof(*idata->tx_buf);\n\txfer.tx_buf = idata->tx_buf;\n\n\tret = regulator_enable(idata->regulator);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_sync_transfer(idata->spi, &xfer, 1);\n\tif (ret)\n\t\tdev_err(&idata->spi->dev, \"unable to deliver the signal\\n\");\n\n\tregulator_disable(idata->regulator);\n\n\treturn ret ? ret : count;\n}\n\nstatic int ir_spi_set_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct ir_spi_data *idata = dev->priv;\n\n\tif (!carrier)\n\t\treturn -EINVAL;\n\n\tidata->freq = carrier;\n\n\treturn 0;\n}\n\nstatic int ir_spi_set_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\n{\n\tstruct ir_spi_data *idata = dev->priv;\n\tint bits = (duty_cycle * 15) / 100;\n\n\tidata->pulse = GENMASK(bits, 0);\n\n\tif (idata->negated) {\n\t\tidata->pulse = ~idata->pulse;\n\t\tidata->space = 0xffff;\n\t} else {\n\t\tidata->space = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ir_spi_probe(struct spi_device *spi)\n{\n\tint ret;\n\tu8 dc;\n\tstruct ir_spi_data *idata;\n\n\tidata = devm_kzalloc(&spi->dev, sizeof(*idata), GFP_KERNEL);\n\tif (!idata)\n\t\treturn -ENOMEM;\n\n\tidata->regulator = devm_regulator_get(&spi->dev, \"irda_regulator\");\n\tif (IS_ERR(idata->regulator))\n\t\treturn PTR_ERR(idata->regulator);\n\n\tidata->rc = devm_rc_allocate_device(&spi->dev, RC_DRIVER_IR_RAW_TX);\n\tif (!idata->rc)\n\t\treturn -ENOMEM;\n\n\tidata->rc->tx_ir           = ir_spi_tx;\n\tidata->rc->s_tx_carrier    = ir_spi_set_tx_carrier;\n\tidata->rc->s_tx_duty_cycle = ir_spi_set_duty_cycle;\n\tidata->rc->device_name\t   = \"IR SPI\";\n\tidata->rc->driver_name     = IR_SPI_DRIVER_NAME;\n\tidata->rc->priv            = idata;\n\tidata->spi                 = spi;\n\n\tidata->negated = of_property_read_bool(spi->dev.of_node,\n\t\t\t\t\t\t\t\"led-active-low\");\n\tret = of_property_read_u8(spi->dev.of_node, \"duty-cycle\", &dc);\n\tif (ret)\n\t\tdc = 50;\n\n\t \n\tir_spi_set_duty_cycle(idata->rc, dc);\n\n\tidata->freq = IR_SPI_DEFAULT_FREQUENCY;\n\n\treturn devm_rc_register_device(&spi->dev, idata->rc);\n}\n\nstatic const struct of_device_id ir_spi_of_match[] = {\n\t{ .compatible = \"ir-spi-led\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ir_spi_of_match);\n\nstatic const struct spi_device_id ir_spi_ids[] = {\n\t{ \"ir-spi-led\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, ir_spi_ids);\n\nstatic struct spi_driver ir_spi_driver = {\n\t.probe = ir_spi_probe,\n\t.id_table = ir_spi_ids,\n\t.driver = {\n\t\t.name = IR_SPI_DRIVER_NAME,\n\t\t.of_match_table = ir_spi_of_match,\n\t},\n};\n\nmodule_spi_driver(ir_spi_driver);\n\nMODULE_AUTHOR(\"Andi Shyti <andi@etezian.org>\");\nMODULE_DESCRIPTION(\"SPI IR LED\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}