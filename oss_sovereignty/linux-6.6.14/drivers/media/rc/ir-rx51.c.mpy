{
  "module_name": "ir-rx51.c",
  "hash_id": "da7a6af5786e85105ae7a5ecd9a850cce5d0614623ff40c592115acff9d7a3b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-rx51.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n#include <linux/pwm.h>\n#include <linux/of.h>\n#include <linux/hrtimer.h>\n\n#include <media/rc-core.h>\n\n#define WBUF_LEN 256\n\nstruct ir_rx51 {\n\tstruct rc_dev *rcdev;\n\tstruct pwm_device *pwm;\n\tstruct pwm_state state;\n\tstruct hrtimer timer;\n\tstruct device\t     *dev;\n\twait_queue_head_t     wqueue;\n\n\tunsigned int\tfreq;\t\t \n\tunsigned int\tduty_cycle;\t \n\tint\t\twbuf[WBUF_LEN];\n\tint\t\twbuf_index;\n\tunsigned long\tdevice_is_open;\n};\n\nstatic inline void ir_rx51_on(struct ir_rx51 *ir_rx51)\n{\n\tir_rx51->state.enabled = true;\n\tpwm_apply_state(ir_rx51->pwm, &ir_rx51->state);\n}\n\nstatic inline void ir_rx51_off(struct ir_rx51 *ir_rx51)\n{\n\tir_rx51->state.enabled = false;\n\tpwm_apply_state(ir_rx51->pwm, &ir_rx51->state);\n}\n\nstatic int init_timing_params(struct ir_rx51 *ir_rx51)\n{\n\tir_rx51->state.period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, ir_rx51->freq);\n\tpwm_set_relative_duty_cycle(&ir_rx51->state, ir_rx51->duty_cycle, 100);\n\n\treturn 0;\n}\n\nstatic enum hrtimer_restart ir_rx51_timer_cb(struct hrtimer *timer)\n{\n\tstruct ir_rx51 *ir_rx51 = container_of(timer, struct ir_rx51, timer);\n\tktime_t now;\n\n\tif (ir_rx51->wbuf_index < 0) {\n\t\tdev_err_ratelimited(ir_rx51->dev,\n\t\t\t\t    \"BUG wbuf_index has value of %i\\n\",\n\t\t\t\t    ir_rx51->wbuf_index);\n\t\tgoto end;\n\t}\n\n\t \n\tdo {\n\t\tu64 ns;\n\n\t\tif (ir_rx51->wbuf_index >= WBUF_LEN)\n\t\t\tgoto end;\n\t\tif (ir_rx51->wbuf[ir_rx51->wbuf_index] == -1)\n\t\t\tgoto end;\n\n\t\tif (ir_rx51->wbuf_index % 2)\n\t\t\tir_rx51_off(ir_rx51);\n\t\telse\n\t\t\tir_rx51_on(ir_rx51);\n\n\t\tns = US_TO_NS(ir_rx51->wbuf[ir_rx51->wbuf_index]);\n\t\thrtimer_add_expires_ns(timer, ns);\n\n\t\tir_rx51->wbuf_index++;\n\n\t\tnow = timer->base->get_time();\n\n\t} while (hrtimer_get_expires_tv64(timer) < now);\n\n\treturn HRTIMER_RESTART;\nend:\n\t \n\tir_rx51_off(ir_rx51);\n\tir_rx51->wbuf_index = -1;\n\n\twake_up_interruptible(&ir_rx51->wqueue);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int ir_rx51_tx(struct rc_dev *dev, unsigned int *buffer,\n\t\t      unsigned int count)\n{\n\tstruct ir_rx51 *ir_rx51 = dev->priv;\n\n\tif (count > WBUF_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(ir_rx51->wbuf, buffer, count * sizeof(unsigned int));\n\n\t \n\twait_event_interruptible(ir_rx51->wqueue, ir_rx51->wbuf_index < 0);\n\n\tinit_timing_params(ir_rx51);\n\tif (count < WBUF_LEN)\n\t\tir_rx51->wbuf[count] = -1;  \n\n\t \n\n\tir_rx51_on(ir_rx51);\n\tir_rx51->wbuf_index = 1;\n\thrtimer_start(&ir_rx51->timer,\n\t\t      ns_to_ktime(US_TO_NS(ir_rx51->wbuf[0])),\n\t\t      HRTIMER_MODE_REL);\n\t \n\twait_event_interruptible(ir_rx51->wqueue, ir_rx51->wbuf_index < 0);\n\n\t \n\n\treturn count;\n}\n\nstatic int ir_rx51_open(struct rc_dev *dev)\n{\n\tstruct ir_rx51 *ir_rx51 = dev->priv;\n\n\tif (test_and_set_bit(1, &ir_rx51->device_is_open))\n\t\treturn -EBUSY;\n\n\tir_rx51->pwm = pwm_get(ir_rx51->dev, NULL);\n\tif (IS_ERR(ir_rx51->pwm)) {\n\t\tint res = PTR_ERR(ir_rx51->pwm);\n\n\t\tdev_err(ir_rx51->dev, \"pwm_get failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic void ir_rx51_release(struct rc_dev *dev)\n{\n\tstruct ir_rx51 *ir_rx51 = dev->priv;\n\n\thrtimer_cancel(&ir_rx51->timer);\n\tir_rx51_off(ir_rx51);\n\tpwm_put(ir_rx51->pwm);\n\n\tclear_bit(1, &ir_rx51->device_is_open);\n}\n\nstatic struct ir_rx51 ir_rx51 = {\n\t.duty_cycle\t= 50,\n\t.wbuf_index\t= -1,\n};\n\nstatic int ir_rx51_set_duty_cycle(struct rc_dev *dev, u32 duty)\n{\n\tstruct ir_rx51 *ir_rx51 = dev->priv;\n\n\tir_rx51->duty_cycle = duty;\n\n\treturn 0;\n}\n\nstatic int ir_rx51_set_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct ir_rx51 *ir_rx51 = dev->priv;\n\n\tif (carrier > 500000 || carrier < 20000)\n\t\treturn -EINVAL;\n\n\tir_rx51->freq = carrier;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int ir_rx51_suspend(struct platform_device *dev, pm_message_t state)\n{\n\t \n\tif (test_and_set_bit(1, &ir_rx51.device_is_open))\n\t\treturn -EAGAIN;\n\n\tclear_bit(1, &ir_rx51.device_is_open);\n\n\treturn 0;\n}\n\nstatic int ir_rx51_resume(struct platform_device *dev)\n{\n\treturn 0;\n}\n\n#else\n\n#define ir_rx51_suspend\tNULL\n#define ir_rx51_resume\tNULL\n\n#endif  \n\nstatic int ir_rx51_probe(struct platform_device *dev)\n{\n\tstruct pwm_device *pwm;\n\tstruct rc_dev *rcdev;\n\n\tpwm = pwm_get(&dev->dev, NULL);\n\tif (IS_ERR(pwm))\n\t\treturn dev_err_probe(&dev->dev, PTR_ERR(pwm), \"pwm_get failed\\n\");\n\n\t \n\tir_rx51.freq = DIV_ROUND_CLOSEST_ULL(pwm_get_period(pwm), NSEC_PER_SEC);\n\tpwm_init_state(pwm, &ir_rx51.state);\n\tpwm_put(pwm);\n\n\thrtimer_init(&ir_rx51.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tir_rx51.timer.function = ir_rx51_timer_cb;\n\n\tir_rx51.dev = &dev->dev;\n\n\trcdev = devm_rc_allocate_device(&dev->dev, RC_DRIVER_IR_RAW_TX);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\trcdev->priv = &ir_rx51;\n\trcdev->open = ir_rx51_open;\n\trcdev->close = ir_rx51_release;\n\trcdev->tx_ir = ir_rx51_tx;\n\trcdev->s_tx_duty_cycle = ir_rx51_set_duty_cycle;\n\trcdev->s_tx_carrier = ir_rx51_set_tx_carrier;\n\trcdev->driver_name = KBUILD_MODNAME;\n\n\tir_rx51.rcdev = rcdev;\n\n\treturn devm_rc_register_device(&dev->dev, ir_rx51.rcdev);\n}\n\nstatic const struct of_device_id ir_rx51_match[] = {\n\t{\n\t\t.compatible = \"nokia,n900-ir\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ir_rx51_match);\n\nstatic struct platform_driver ir_rx51_platform_driver = {\n\t.probe\t\t= ir_rx51_probe,\n\t.suspend\t= ir_rx51_suspend,\n\t.resume\t\t= ir_rx51_resume,\n\t.driver\t\t= {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.of_match_table = ir_rx51_match,\n\t},\n};\nmodule_platform_driver(ir_rx51_platform_driver);\n\nMODULE_DESCRIPTION(\"IR TX driver for Nokia RX51\");\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}