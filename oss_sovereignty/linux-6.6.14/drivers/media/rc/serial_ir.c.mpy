{
  "module_name": "serial_ir.c",
  "hash_id": "971bc1952320ef8a3cde454c388ddf5649b81b5fbf863a0770991c83bef8d977",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/serial_ir.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/serial_reg.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <media/rc-core.h>\n\nstruct serial_ir_hw {\n\tint signal_pin;\n\tint signal_pin_change;\n\tu8 on;\n\tu8 off;\n\tunsigned set_send_carrier:1;\n\tunsigned set_duty_cycle:1;\n\tvoid (*send_pulse)(unsigned int length, ktime_t edge);\n\tvoid (*send_space)(void);\n\tspinlock_t lock;\n};\n\n#define IR_HOMEBREW\t0\n#define IR_IRDEO\t1\n#define IR_IRDEO_REMOTE\t2\n#define IR_ANIMAX\t3\n#define IR_IGOR\t\t4\n\n \nstatic int type;\nstatic int io;\nstatic int irq;\nstatic ulong iommap;\nstatic int ioshift;\nstatic bool softcarrier = true;\nstatic bool share_irq;\nstatic int sense = -1;\t \nstatic bool txsense;\t \n\n \nstatic void send_pulse_irdeo(unsigned int length, ktime_t edge);\nstatic void send_space_irdeo(void);\n#ifdef CONFIG_IR_SERIAL_TRANSMITTER\nstatic void send_pulse_homebrew(unsigned int length, ktime_t edge);\nstatic void send_space_homebrew(void);\n#endif\n\nstatic struct serial_ir_hw hardware[] = {\n\t[IR_HOMEBREW] = {\n\t\t.lock = __SPIN_LOCK_UNLOCKED(hardware[IR_HOMEBREW].lock),\n\t\t.signal_pin\t   = UART_MSR_DCD,\n\t\t.signal_pin_change = UART_MSR_DDCD,\n\t\t.on  = (UART_MCR_RTS | UART_MCR_OUT2 | UART_MCR_DTR),\n\t\t.off = (UART_MCR_RTS | UART_MCR_OUT2),\n#ifdef CONFIG_IR_SERIAL_TRANSMITTER\n\t\t.send_pulse = send_pulse_homebrew,\n\t\t.send_space = send_space_homebrew,\n\t\t.set_send_carrier = true,\n\t\t.set_duty_cycle = true,\n#endif\n\t},\n\n\t[IR_IRDEO] = {\n\t\t.lock = __SPIN_LOCK_UNLOCKED(hardware[IR_IRDEO].lock),\n\t\t.signal_pin\t   = UART_MSR_DSR,\n\t\t.signal_pin_change = UART_MSR_DDSR,\n\t\t.on  = UART_MCR_OUT2,\n\t\t.off = (UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2),\n\t\t.send_pulse = send_pulse_irdeo,\n\t\t.send_space = send_space_irdeo,\n\t\t.set_duty_cycle = true,\n\t},\n\n\t[IR_IRDEO_REMOTE] = {\n\t\t.lock = __SPIN_LOCK_UNLOCKED(hardware[IR_IRDEO_REMOTE].lock),\n\t\t.signal_pin\t   = UART_MSR_DSR,\n\t\t.signal_pin_change = UART_MSR_DDSR,\n\t\t.on  = (UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2),\n\t\t.off = (UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2),\n\t\t.send_pulse = send_pulse_irdeo,\n\t\t.send_space = send_space_irdeo,\n\t\t.set_duty_cycle = true,\n\t},\n\n\t[IR_ANIMAX] = {\n\t\t.lock = __SPIN_LOCK_UNLOCKED(hardware[IR_ANIMAX].lock),\n\t\t.signal_pin\t   = UART_MSR_DCD,\n\t\t.signal_pin_change = UART_MSR_DDCD,\n\t\t.on  = 0,\n\t\t.off = (UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2),\n\t},\n\n\t[IR_IGOR] = {\n\t\t.lock = __SPIN_LOCK_UNLOCKED(hardware[IR_IGOR].lock),\n\t\t.signal_pin\t   = UART_MSR_DSR,\n\t\t.signal_pin_change = UART_MSR_DDSR,\n\t\t.on  = (UART_MCR_RTS | UART_MCR_OUT2 | UART_MCR_DTR),\n\t\t.off = (UART_MCR_RTS | UART_MCR_OUT2),\n#ifdef CONFIG_IR_SERIAL_TRANSMITTER\n\t\t.send_pulse = send_pulse_homebrew,\n\t\t.send_space = send_space_homebrew,\n\t\t.set_send_carrier = true,\n\t\t.set_duty_cycle = true,\n#endif\n\t},\n};\n\n#define RS_ISR_PASS_LIMIT 256\n\nstruct serial_ir {\n\tktime_t lastkt;\n\tstruct rc_dev *rcdev;\n\tstruct platform_device *pdev;\n\tstruct timer_list timeout_timer;\n\n\tunsigned int carrier;\n\tunsigned int duty_cycle;\n};\n\nstatic struct serial_ir serial_ir;\n\n \nstatic u8 sinp(int offset)\n{\n\tif (iommap)\n\t\t \n\t\toffset <<= ioshift;\n\n\treturn inb(io + offset);\n}\n\n \nstatic void soutp(int offset, u8 value)\n{\n\tif (iommap)\n\t\t \n\t\toffset <<= ioshift;\n\n\toutb(value, io + offset);\n}\n\nstatic void on(void)\n{\n\tif (txsense)\n\t\tsoutp(UART_MCR, hardware[type].off);\n\telse\n\t\tsoutp(UART_MCR, hardware[type].on);\n}\n\nstatic void off(void)\n{\n\tif (txsense)\n\t\tsoutp(UART_MCR, hardware[type].on);\n\telse\n\t\tsoutp(UART_MCR, hardware[type].off);\n}\n\nstatic void send_pulse_irdeo(unsigned int length, ktime_t target)\n{\n\tlong rawbits;\n\tint i;\n\tunsigned char output;\n\tunsigned char chunk, shifted;\n\n\t \n\trawbits = length * 1152 / 10000;\n\tif (serial_ir.duty_cycle > 50)\n\t\tchunk = 3;\n\telse\n\t\tchunk = 1;\n\tfor (i = 0, output = 0x7f; rawbits > 0; rawbits -= 3) {\n\t\tshifted = chunk << (i * 3);\n\t\tshifted >>= 1;\n\t\toutput &= (~shifted);\n\t\ti++;\n\t\tif (i == 3) {\n\t\t\tsoutp(UART_TX, output);\n\t\t\twhile (!(sinp(UART_LSR) & UART_LSR_THRE))\n\t\t\t\t;\n\t\t\toutput = 0x7f;\n\t\t\ti = 0;\n\t\t}\n\t}\n\tif (i != 0) {\n\t\tsoutp(UART_TX, output);\n\t\twhile (!(sinp(UART_LSR) & UART_LSR_TEMT))\n\t\t\t;\n\t}\n}\n\nstatic void send_space_irdeo(void)\n{\n}\n\n#ifdef CONFIG_IR_SERIAL_TRANSMITTER\nstatic void send_pulse_homebrew_softcarrier(unsigned int length, ktime_t edge)\n{\n\tktime_t now, target = ktime_add_us(edge, length);\n\t \n\ts32 delta;\n\tunsigned int pulse, space;\n\n\t \n\tpulse = DIV_ROUND_CLOSEST(serial_ir.duty_cycle * (NSEC_PER_SEC / 100),\n\t\t\t\t  serial_ir.carrier);\n\tspace = DIV_ROUND_CLOSEST((100 - serial_ir.duty_cycle) *\n\t\t\t\t  (NSEC_PER_SEC / 100), serial_ir.carrier);\n\n\tfor (;;) {\n\t\tnow = ktime_get();\n\t\tif (ktime_compare(now, target) >= 0)\n\t\t\tbreak;\n\t\ton();\n\t\tedge = ktime_add_ns(edge, pulse);\n\t\tdelta = ktime_to_ns(ktime_sub(edge, now));\n\t\tif (delta > 0)\n\t\t\tndelay(delta);\n\t\tnow = ktime_get();\n\t\toff();\n\t\tif (ktime_compare(now, target) >= 0)\n\t\t\tbreak;\n\t\tedge = ktime_add_ns(edge, space);\n\t\tdelta = ktime_to_ns(ktime_sub(edge, now));\n\t\tif (delta > 0)\n\t\t\tndelay(delta);\n\t}\n}\n\nstatic void send_pulse_homebrew(unsigned int length, ktime_t edge)\n{\n\tif (softcarrier)\n\t\tsend_pulse_homebrew_softcarrier(length, edge);\n\telse\n\t\ton();\n}\n\nstatic void send_space_homebrew(void)\n{\n\toff();\n}\n#endif\n\nstatic void frbwrite(unsigned int l, bool is_pulse)\n{\n\t \n\tstatic unsigned int ptr, pulse, space;\n\tstruct ir_raw_event ev = {};\n\n\tif (ptr > 0 && is_pulse) {\n\t\tpulse += l;\n\t\tif (pulse > 250) {\n\t\t\tev.duration = space;\n\t\t\tev.pulse = false;\n\t\t\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n\t\t\tev.duration = pulse;\n\t\t\tev.pulse = true;\n\t\t\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n\t\t\tptr = 0;\n\t\t\tpulse = 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (!is_pulse) {\n\t\tif (ptr == 0) {\n\t\t\tif (l > 20000) {\n\t\t\t\tspace = l;\n\t\t\t\tptr++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l > 20000) {\n\t\t\t\tspace += pulse;\n\t\t\t\tif (space > IR_MAX_DURATION)\n\t\t\t\t\tspace = IR_MAX_DURATION;\n\t\t\t\tspace += l;\n\t\t\t\tif (space > IR_MAX_DURATION)\n\t\t\t\t\tspace = IR_MAX_DURATION;\n\t\t\t\tpulse = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tev.duration = space;\n\t\t\tev.pulse = false;\n\t\t\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n\t\t\tev.duration = pulse;\n\t\t\tev.pulse = true;\n\t\t\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n\t\t\tptr = 0;\n\t\t\tpulse = 0;\n\t\t}\n\t}\n\n\tev.duration = l;\n\tev.pulse = is_pulse;\n\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n}\n\nstatic irqreturn_t serial_ir_irq_handler(int i, void *blah)\n{\n\tktime_t kt;\n\tint counter, dcd;\n\tu8 status;\n\tktime_t delkt;\n\tunsigned int data;\n\tstatic int last_dcd = -1;\n\n\tif ((sinp(UART_IIR) & UART_IIR_NO_INT)) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tcounter = 0;\n\tdo {\n\t\tcounter++;\n\t\tstatus = sinp(UART_MSR);\n\t\tif (counter > RS_ISR_PASS_LIMIT) {\n\t\t\tdev_err(&serial_ir.pdev->dev, \"Trapped in interrupt\");\n\t\t\tbreak;\n\t\t}\n\t\tif ((status & hardware[type].signal_pin_change) &&\n\t\t    sense != -1) {\n\t\t\t \n\t\t\tkt = ktime_get();\n\n\t\t\t \n\n\t\t\t \n\t\t\tdcd = (status & hardware[type].signal_pin) ? 1 : 0;\n\n\t\t\tif (dcd == last_dcd) {\n\t\t\t\tdev_dbg(&serial_ir.pdev->dev,\n\t\t\t\t\t\"ignoring spike: %d %d %lldns %lldns\\n\",\n\t\t\t\t\tdcd, sense, ktime_to_ns(kt),\n\t\t\t\t\tktime_to_ns(serial_ir.lastkt));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdelkt = ktime_sub(kt, serial_ir.lastkt);\n\t\t\tif (ktime_compare(delkt, ktime_set(15, 0)) > 0) {\n\t\t\t\tdata = IR_MAX_DURATION;  \n\t\t\t\tif (!(dcd ^ sense)) {\n\t\t\t\t\t \n\t\t\t\t\tdev_err(&serial_ir.pdev->dev,\n\t\t\t\t\t\t\"dcd unexpected: %d %d %lldns %lldns\\n\",\n\t\t\t\t\t\tdcd, sense, ktime_to_ns(kt),\n\t\t\t\t\t\tktime_to_ns(serial_ir.lastkt));\n\t\t\t\t\t \n\t\t\t\t\tsense = sense ? 0 : 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata = ktime_to_us(delkt);\n\t\t\t}\n\t\t\tfrbwrite(data, !(dcd ^ sense));\n\t\t\tserial_ir.lastkt = kt;\n\t\t\tlast_dcd = dcd;\n\t\t}\n\t} while (!(sinp(UART_IIR) & UART_IIR_NO_INT));  \n\n\tmod_timer(&serial_ir.timeout_timer,\n\t\t  jiffies + usecs_to_jiffies(serial_ir.rcdev->timeout));\n\n\tir_raw_event_handle(serial_ir.rcdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hardware_init_port(void)\n{\n\tu8 scratch, scratch2, scratch3;\n\n\t \n\tscratch = sinp(UART_IER);\n\tsoutp(UART_IER, 0);\n#ifdef __i386__\n\toutb(0xff, 0x080);\n#endif\n\tscratch2 = sinp(UART_IER) & 0x0f;\n\tsoutp(UART_IER, 0x0f);\n#ifdef __i386__\n\toutb(0x00, 0x080);\n#endif\n\tscratch3 = sinp(UART_IER) & 0x0f;\n\tsoutp(UART_IER, scratch);\n\tif (scratch2 != 0 || scratch3 != 0x0f) {\n\t\t \n\t\tpr_err(\"port existence test failed, cannot continue\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\n\n\t \n\tsoutp(UART_IER, sinp(UART_IER) &\n\t      (~(UART_IER_MSI | UART_IER_RLSI | UART_IER_THRI | UART_IER_RDI)));\n\n\t \n\tsinp(UART_LSR);\n\tsinp(UART_RX);\n\tsinp(UART_IIR);\n\tsinp(UART_MSR);\n\n\t \n\toff();\n\n\t \n\tsinp(UART_LSR);\n\tsinp(UART_RX);\n\tsinp(UART_IIR);\n\tsinp(UART_MSR);\n\n\tswitch (type) {\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\t\t \n\t\t \n\n\t\t \n\t\tsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\n\t\t \n\t\tsoutp(UART_DLM, 0);\n\t\tsoutp(UART_DLL, 1);\n\t\t \n\t\tsoutp(UART_LCR, UART_LCR_WLEN7);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void serial_ir_timeout(struct timer_list *unused)\n{\n\tstruct ir_raw_event ev = {\n\t\t.timeout = true,\n\t\t.duration = serial_ir.rcdev->timeout\n\t};\n\tir_raw_event_store_with_filter(serial_ir.rcdev, &ev);\n\tir_raw_event_handle(serial_ir.rcdev);\n}\n\n \nstatic int serial_ir_tx(struct rc_dev *dev, unsigned int *txbuf,\n\t\t\tunsigned int count);\nstatic int serial_ir_tx_duty_cycle(struct rc_dev *dev, u32 cycle);\nstatic int serial_ir_tx_carrier(struct rc_dev *dev, u32 carrier);\nstatic int serial_ir_open(struct rc_dev *rcdev);\nstatic void serial_ir_close(struct rc_dev *rcdev);\n\nstatic int serial_ir_probe(struct platform_device *dev)\n{\n\tstruct rc_dev *rcdev;\n\tint i, nlow, nhigh, result;\n\n\trcdev = devm_rc_allocate_device(&dev->dev, RC_DRIVER_IR_RAW);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\tif (hardware[type].send_pulse && hardware[type].send_space)\n\t\trcdev->tx_ir = serial_ir_tx;\n\tif (hardware[type].set_send_carrier)\n\t\trcdev->s_tx_carrier = serial_ir_tx_carrier;\n\tif (hardware[type].set_duty_cycle)\n\t\trcdev->s_tx_duty_cycle = serial_ir_tx_duty_cycle;\n\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\t\trcdev->device_name = \"Serial IR type home-brew\";\n\t\tbreak;\n\tcase IR_IRDEO:\n\t\trcdev->device_name = \"Serial IR type IRdeo\";\n\t\tbreak;\n\tcase IR_IRDEO_REMOTE:\n\t\trcdev->device_name = \"Serial IR type IRdeo remote\";\n\t\tbreak;\n\tcase IR_ANIMAX:\n\t\trcdev->device_name = \"Serial IR type AnimaX\";\n\t\tbreak;\n\tcase IR_IGOR:\n\t\trcdev->device_name = \"Serial IR type IgorPlug\";\n\t\tbreak;\n\t}\n\n\trcdev->input_phys = KBUILD_MODNAME \"/input0\";\n\trcdev->input_id.bustype = BUS_HOST;\n\trcdev->input_id.vendor = 0x0001;\n\trcdev->input_id.product = 0x0001;\n\trcdev->input_id.version = 0x0100;\n\trcdev->open = serial_ir_open;\n\trcdev->close = serial_ir_close;\n\trcdev->dev.parent = &serial_ir.pdev->dev;\n\trcdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trcdev->driver_name = KBUILD_MODNAME;\n\trcdev->map_name = RC_MAP_RC6_MCE;\n\trcdev->min_timeout = 1;\n\trcdev->timeout = IR_DEFAULT_TIMEOUT;\n\trcdev->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\trcdev->rx_resolution = 250;\n\n\tserial_ir.rcdev = rcdev;\n\n\ttimer_setup(&serial_ir.timeout_timer, serial_ir_timeout, 0);\n\n\tresult = devm_request_irq(&dev->dev, irq, serial_ir_irq_handler,\n\t\t\t\t  share_irq ? IRQF_SHARED : 0,\n\t\t\t\t  KBUILD_MODNAME, &hardware);\n\tif (result < 0) {\n\t\tif (result == -EBUSY)\n\t\t\tdev_err(&dev->dev, \"IRQ %d busy\\n\", irq);\n\t\telse if (result == -EINVAL)\n\t\t\tdev_err(&dev->dev, \"Bad irq number or handler\\n\");\n\t\treturn result;\n\t}\n\n\t \n\tif ((iommap &&\n\t     (devm_request_mem_region(&dev->dev, iommap, 8UL << ioshift,\n\t\t\t\t      KBUILD_MODNAME) == NULL)) ||\n\t     (!iommap && (devm_request_region(&dev->dev, io, 8,\n\t\t\t  KBUILD_MODNAME) == NULL))) {\n\t\tdev_err(&dev->dev, \"port %04x already in use\\n\", io);\n\t\tdev_warn(&dev->dev, \"use 'setserial /dev/ttySX uart none'\\n\");\n\t\tdev_warn(&dev->dev,\n\t\t\t \"or compile the serial port driver as module and\\n\");\n\t\tdev_warn(&dev->dev, \"make sure this module is loaded first\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tresult = hardware_init_port();\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tserial_ir.duty_cycle = 50;\n\tserial_ir.carrier = 38000;\n\n\t \n\tif (sense == -1) {\n\t\t \n\t\tmsleep(500);\n\n\t\t \n\t\tnlow = 0;\n\t\tnhigh = 0;\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tif (sinp(UART_MSR) & hardware[type].signal_pin)\n\t\t\t\tnlow++;\n\t\t\telse\n\t\t\t\tnhigh++;\n\t\t\tmsleep(40);\n\t\t}\n\t\tsense = nlow >= nhigh ? 1 : 0;\n\t\tdev_info(&dev->dev, \"auto-detected active %s receiver\\n\",\n\t\t\t sense ? \"low\" : \"high\");\n\t} else\n\t\tdev_info(&dev->dev, \"Manually using active %s receiver\\n\",\n\t\t\t sense ? \"low\" : \"high\");\n\n\tdev_dbg(&dev->dev, \"Interrupt %d, port %04x obtained\\n\", irq, io);\n\n\treturn devm_rc_register_device(&dev->dev, rcdev);\n}\n\nstatic int serial_ir_open(struct rc_dev *rcdev)\n{\n\tunsigned long flags;\n\n\t \n\tserial_ir.lastkt = ktime_get();\n\n\tspin_lock_irqsave(&hardware[type].lock, flags);\n\n\t \n\tsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\n\n\tsoutp(UART_IER, sinp(UART_IER) | UART_IER_MSI);\n\n\tspin_unlock_irqrestore(&hardware[type].lock, flags);\n\n\treturn 0;\n}\n\nstatic void serial_ir_close(struct rc_dev *rcdev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hardware[type].lock, flags);\n\n\t \n\tsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\n\n\t \n\tsoutp(UART_IER, sinp(UART_IER) &\n\t      (~(UART_IER_MSI | UART_IER_RLSI | UART_IER_THRI | UART_IER_RDI)));\n\tspin_unlock_irqrestore(&hardware[type].lock, flags);\n}\n\nstatic int serial_ir_tx(struct rc_dev *dev, unsigned int *txbuf,\n\t\t\tunsigned int count)\n{\n\tunsigned long flags;\n\tktime_t edge;\n\ts64 delta;\n\tint i;\n\n\tspin_lock_irqsave(&hardware[type].lock, flags);\n\tif (type == IR_IRDEO) {\n\t\t \n\t\ton();\n\t}\n\n\tedge = ktime_get();\n\tfor (i = 0; i < count; i++) {\n\t\tif (i % 2)\n\t\t\thardware[type].send_space();\n\t\telse\n\t\t\thardware[type].send_pulse(txbuf[i], edge);\n\n\t\tedge = ktime_add_us(edge, txbuf[i]);\n\t\tdelta = ktime_us_delta(edge, ktime_get());\n\t\tif (delta > 25) {\n\t\t\tspin_unlock_irqrestore(&hardware[type].lock, flags);\n\t\t\tusleep_range(delta - 25, delta + 25);\n\t\t\tspin_lock_irqsave(&hardware[type].lock, flags);\n\t\t} else if (delta > 0) {\n\t\t\tudelay(delta);\n\t\t}\n\t}\n\toff();\n\tspin_unlock_irqrestore(&hardware[type].lock, flags);\n\treturn count;\n}\n\nstatic int serial_ir_tx_duty_cycle(struct rc_dev *dev, u32 cycle)\n{\n\tserial_ir.duty_cycle = cycle;\n\treturn 0;\n}\n\nstatic int serial_ir_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tif (carrier > 500000 || carrier < 20000)\n\t\treturn -EINVAL;\n\n\tserial_ir.carrier = carrier;\n\treturn 0;\n}\n\nstatic int serial_ir_suspend(struct platform_device *dev,\n\t\t\t     pm_message_t state)\n{\n\t \n\tsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\n\n\t \n\tsoutp(UART_IER, sinp(UART_IER) &\n\t      (~(UART_IER_MSI | UART_IER_RLSI | UART_IER_THRI | UART_IER_RDI)));\n\n\t \n\tsinp(UART_LSR);\n\tsinp(UART_RX);\n\tsinp(UART_IIR);\n\tsinp(UART_MSR);\n\n\treturn 0;\n}\n\nstatic int serial_ir_resume(struct platform_device *dev)\n{\n\tunsigned long flags;\n\tint result;\n\n\tresult = hardware_init_port();\n\tif (result < 0)\n\t\treturn result;\n\n\tspin_lock_irqsave(&hardware[type].lock, flags);\n\t \n\tserial_ir.lastkt = ktime_get();\n\tsoutp(UART_IER, sinp(UART_IER) | UART_IER_MSI);\n\toff();\n\n\tspin_unlock_irqrestore(&hardware[type].lock, flags);\n\n\treturn 0;\n}\n\nstatic struct platform_driver serial_ir_driver = {\n\t.probe\t\t= serial_ir_probe,\n\t.suspend\t= serial_ir_suspend,\n\t.resume\t\t= serial_ir_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"serial_ir\",\n\t},\n};\n\nstatic int __init serial_ir_init(void)\n{\n\tint result;\n\n\tresult = platform_driver_register(&serial_ir_driver);\n\tif (result)\n\t\treturn result;\n\n\tserial_ir.pdev = platform_device_alloc(\"serial_ir\", 0);\n\tif (!serial_ir.pdev) {\n\t\tresult = -ENOMEM;\n\t\tgoto exit_driver_unregister;\n\t}\n\n\tresult = platform_device_add(serial_ir.pdev);\n\tif (result)\n\t\tgoto exit_device_put;\n\n\treturn 0;\n\nexit_device_put:\n\tplatform_device_put(serial_ir.pdev);\nexit_driver_unregister:\n\tplatform_driver_unregister(&serial_ir_driver);\n\treturn result;\n}\n\nstatic void serial_ir_exit(void)\n{\n\tplatform_device_unregister(serial_ir.pdev);\n\tplatform_driver_unregister(&serial_ir_driver);\n}\n\nstatic int __init serial_ir_init_module(void)\n{\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\tcase IR_ANIMAX:\n\tcase IR_IGOR:\n\t\t \n\t\tio = io ? io : 0x3f8;\n\t\tirq = irq ? irq : 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!softcarrier) {\n\t\tswitch (type) {\n\t\tcase IR_HOMEBREW:\n\t\tcase IR_IGOR:\n\t\t\thardware[type].set_send_carrier = false;\n\t\t\thardware[type].set_duty_cycle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (sense != -1)\n\t\tsense = !!sense;\n\n\treturn serial_ir_init();\n}\n\nstatic void __exit serial_ir_exit_module(void)\n{\n\tdel_timer_sync(&serial_ir.timeout_timer);\n\tserial_ir_exit();\n}\n\nmodule_init(serial_ir_init_module);\nmodule_exit(serial_ir_exit_module);\n\nMODULE_DESCRIPTION(\"Infra-red receiver driver for serial ports.\");\nMODULE_AUTHOR(\"Ralph Metzler, Trent Piepho, Ben Pfaff, Christoph Bartelmus, Andrei Tanas\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(type, int, 0444);\nMODULE_PARM_DESC(type, \"Hardware type (0 = home-brew, 1 = IRdeo, 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug\");\n\nmodule_param_hw(io, int, ioport, 0444);\nMODULE_PARM_DESC(io, \"I/O address base (0x3f8 or 0x2f8)\");\n\n \nmodule_param_hw(iommap, ulong, other, 0444);\nMODULE_PARM_DESC(iommap, \"physical base for memory mapped I/O (0 = no memory mapped io)\");\n\n \nmodule_param_hw(ioshift, int, other, 0444);\nMODULE_PARM_DESC(ioshift, \"shift I/O register offset (0 = no shift)\");\n\nmodule_param_hw(irq, int, irq, 0444);\nMODULE_PARM_DESC(irq, \"Interrupt (4 or 3)\");\n\nmodule_param_hw(share_irq, bool, other, 0444);\nMODULE_PARM_DESC(share_irq, \"Share interrupts (0 = off, 1 = on)\");\n\nmodule_param(sense, int, 0444);\nMODULE_PARM_DESC(sense, \"Override autodetection of IR receiver circuit (0 = active high, 1 = active low )\");\n\n#ifdef CONFIG_IR_SERIAL_TRANSMITTER\nmodule_param(txsense, bool, 0444);\nMODULE_PARM_DESC(txsense, \"Sense of transmitter circuit (0 = active high, 1 = active low )\");\n#endif\n\nmodule_param(softcarrier, bool, 0444);\nMODULE_PARM_DESC(softcarrier, \"Software carrier (0 = off, 1 = on, default on)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}