{
  "module_name": "ir-rc5-decoder.c",
  "hash_id": "e501da894136fcfefba1640602b580ee378a748c4dde3e5ec75c804e10857713",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-rc5-decoder.c",
  "human_readable_source": "\n\n\n\n\n\n \n\n#include \"rc-core-priv.h\"\n#include <linux/module.h>\n\n#define RC5_NBITS\t\t14\n#define RC5_SZ_NBITS\t\t15\n#define RC5X_NBITS\t\t20\n#define CHECK_RC5X_NBITS\t8\n#define RC5_UNIT\t\t889  \n#define RC5_BIT_START\t\t(1 * RC5_UNIT)\n#define RC5_BIT_END\t\t(1 * RC5_UNIT)\n#define RC5X_SPACE\t\t(4 * RC5_UNIT)\n#define RC5_TRAILER\t\t(6 * RC5_UNIT)  \n\nenum rc5_state {\n\tSTATE_INACTIVE,\n\tSTATE_BIT_START,\n\tSTATE_BIT_END,\n\tSTATE_CHECK_RC5X,\n\tSTATE_FINISHED,\n};\n\n \nstatic int ir_rc5_decode(struct rc_dev *dev, struct ir_raw_event ev)\n{\n\tstruct rc5_dec *data = &dev->raw->rc5;\n\tu8 toggle;\n\tu32 scancode;\n\tenum rc_proto protocol;\n\n\tif (!is_timing_event(ev)) {\n\t\tif (ev.overflow)\n\t\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (!geq_margin(ev.duration, RC5_UNIT, RC5_UNIT / 2))\n\t\tgoto out;\n\nagain:\n\tdev_dbg(&dev->dev, \"RC5(x/sz) decode started at state %i (%uus %s)\\n\",\n\t\tdata->state, ev.duration, TO_STR(ev.pulse));\n\n\tif (!geq_margin(ev.duration, RC5_UNIT, RC5_UNIT / 2))\n\t\treturn 0;\n\n\tswitch (data->state) {\n\n\tcase STATE_INACTIVE:\n\t\tif (!ev.pulse)\n\t\t\tbreak;\n\n\t\tdata->state = STATE_BIT_START;\n\t\tdata->count = 1;\n\t\tdecrease_duration(&ev, RC5_BIT_START);\n\t\tgoto again;\n\n\tcase STATE_BIT_START:\n\t\tif (!ev.pulse && geq_margin(ev.duration, RC5_TRAILER, RC5_UNIT / 2)) {\n\t\t\tdata->state = STATE_FINISHED;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (!eq_margin(ev.duration, RC5_BIT_START, RC5_UNIT / 2))\n\t\t\tbreak;\n\n\t\tdata->bits <<= 1;\n\t\tif (!ev.pulse)\n\t\t\tdata->bits |= 1;\n\t\tdata->count++;\n\t\tdata->state = STATE_BIT_END;\n\t\treturn 0;\n\n\tcase STATE_BIT_END:\n\t\tif (data->count == CHECK_RC5X_NBITS)\n\t\t\tdata->state = STATE_CHECK_RC5X;\n\t\telse\n\t\t\tdata->state = STATE_BIT_START;\n\n\t\tdecrease_duration(&ev, RC5_BIT_END);\n\t\tgoto again;\n\n\tcase STATE_CHECK_RC5X:\n\t\tif (!ev.pulse && geq_margin(ev.duration, RC5X_SPACE, RC5_UNIT / 2)) {\n\t\t\tdata->is_rc5x = true;\n\t\t\tdecrease_duration(&ev, RC5X_SPACE);\n\t\t} else\n\t\t\tdata->is_rc5x = false;\n\t\tdata->state = STATE_BIT_START;\n\t\tgoto again;\n\n\tcase STATE_FINISHED:\n\t\tif (ev.pulse)\n\t\t\tbreak;\n\n\t\tif (data->is_rc5x && data->count == RC5X_NBITS) {\n\t\t\t \n\t\t\tu8 xdata, command, system;\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_RC5X_20)) {\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txdata    = (data->bits & 0x0003F) >> 0;\n\t\t\tcommand  = (data->bits & 0x00FC0) >> 6;\n\t\t\tsystem   = (data->bits & 0x1F000) >> 12;\n\t\t\ttoggle   = (data->bits & 0x20000) ? 1 : 0;\n\t\t\tcommand += (data->bits & 0x40000) ? 0 : 0x40;\n\t\t\tscancode = system << 16 | command << 8 | xdata;\n\t\t\tprotocol = RC_PROTO_RC5X_20;\n\n\t\t} else if (!data->is_rc5x && data->count == RC5_NBITS) {\n\t\t\t \n\t\t\tu8 command, system;\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_RC5)) {\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcommand  = (data->bits & 0x0003F) >> 0;\n\t\t\tsystem   = (data->bits & 0x007C0) >> 6;\n\t\t\ttoggle   = (data->bits & 0x00800) ? 1 : 0;\n\t\t\tcommand += (data->bits & 0x01000) ? 0 : 0x40;\n\t\t\tscancode = system << 8 | command;\n\t\t\tprotocol = RC_PROTO_RC5;\n\n\t\t} else if (!data->is_rc5x && data->count == RC5_SZ_NBITS) {\n\t\t\t \n\t\t\tu8 command, system;\n\t\t\tif (!(dev->enabled_protocols & RC_PROTO_BIT_RC5_SZ)) {\n\t\t\t\tdata->state = STATE_INACTIVE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcommand  = (data->bits & 0x0003F) >> 0;\n\t\t\tsystem   = (data->bits & 0x02FC0) >> 6;\n\t\t\ttoggle   = (data->bits & 0x01000) ? 1 : 0;\n\t\t\tscancode = system << 6 | command;\n\t\t\tprotocol = RC_PROTO_RC5_SZ;\n\n\t\t} else\n\t\t\tbreak;\n\n\t\tdev_dbg(&dev->dev, \"RC5(x/sz) scancode 0x%06x (p: %u, t: %u)\\n\",\n\t\t\tscancode, protocol, toggle);\n\n\t\trc_keydown(dev, protocol, scancode, toggle);\n\t\tdata->state = STATE_INACTIVE;\n\t\treturn 0;\n\t}\n\nout:\n\tdev_dbg(&dev->dev, \"RC5(x/sz) decode failed at state %i count %d (%uus %s)\\n\",\n\t\tdata->state, data->count, ev.duration, TO_STR(ev.pulse));\n\tdata->state = STATE_INACTIVE;\n\treturn -EINVAL;\n}\n\nstatic const struct ir_raw_timings_manchester ir_rc5_timings = {\n\t.leader_pulse\t\t= RC5_UNIT,\n\t.clock\t\t\t= RC5_UNIT,\n\t.trailer_space\t\t= RC5_UNIT * 10,\n};\n\nstatic const struct ir_raw_timings_manchester ir_rc5x_timings[2] = {\n\t{\n\t\t.leader_pulse\t\t= RC5_UNIT,\n\t\t.clock\t\t\t= RC5_UNIT,\n\t\t.trailer_space\t\t= RC5X_SPACE,\n\t},\n\t{\n\t\t.clock\t\t\t= RC5_UNIT,\n\t\t.trailer_space\t\t= RC5_UNIT * 10,\n\t},\n};\n\nstatic const struct ir_raw_timings_manchester ir_rc5_sz_timings = {\n\t.leader_pulse\t\t\t= RC5_UNIT,\n\t.clock\t\t\t\t= RC5_UNIT,\n\t.trailer_space\t\t\t= RC5_UNIT * 10,\n};\n\n \nstatic int ir_rc5_encode(enum rc_proto protocol, u32 scancode,\n\t\t\t struct ir_raw_event *events, unsigned int max)\n{\n\tint ret;\n\tstruct ir_raw_event *e = events;\n\tunsigned int data, xdata, command, commandx, system, pre_space_data;\n\n\t \n\tif (protocol == RC_PROTO_RC5) {\n\t\t \n\t\tcommand  = (scancode & 0x003f) >> 0;\n\t\tcommandx = (scancode & 0x0040) >> 6;\n\t\tsystem   = (scancode & 0x1f00) >> 8;\n\t\t \n\t\tdata = !commandx << 12 | system << 6 | command;\n\n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max, &ir_rc5_timings,\n\t\t\t\t\t    RC5_NBITS - 1, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (protocol == RC_PROTO_RC5X_20) {\n\t\t \n\t\txdata    = (scancode & 0x00003f) >> 0;\n\t\tcommand  = (scancode & 0x003f00) >> 8;\n\t\tcommandx = !(scancode & 0x004000);\n\t\tsystem   = (scancode & 0x1f0000) >> 16;\n\n\t\t \n\t\tdata = commandx << 18 | system << 12 | command << 6 | xdata;\n\n\t\t \n\t\tpre_space_data = data >> (RC5X_NBITS - CHECK_RC5X_NBITS);\n\t\tret = ir_raw_gen_manchester(&e, max, &ir_rc5x_timings[0],\n\t\t\t\t\t    CHECK_RC5X_NBITS - 1,\n\t\t\t\t\t    pre_space_data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ir_raw_gen_manchester(&e, max - (e - events),\n\t\t\t\t\t    &ir_rc5x_timings[1],\n\t\t\t\t\t    RC5X_NBITS - CHECK_RC5X_NBITS,\n\t\t\t\t\t    data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (protocol == RC_PROTO_RC5_SZ) {\n\t\t \n\t\t \n\t\tret = ir_raw_gen_manchester(&e, max, &ir_rc5_sz_timings,\n\t\t\t\t\t    RC5_SZ_NBITS - 1,\n\t\t\t\t\t    scancode & 0x2fff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn e - events;\n}\n\nstatic struct ir_raw_handler rc5_handler = {\n\t.protocols\t= RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC5X_20 |\n\t\t\t\t\t\t\tRC_PROTO_BIT_RC5_SZ,\n\t.decode\t\t= ir_rc5_decode,\n\t.encode\t\t= ir_rc5_encode,\n\t.carrier\t= 36000,\n\t.min_timeout\t= RC5_TRAILER,\n};\n\nstatic int __init ir_rc5_decode_init(void)\n{\n\tir_raw_handler_register(&rc5_handler);\n\n\tprintk(KERN_INFO \"IR RC5(x/sz) protocol handler initialized\\n\");\n\treturn 0;\n}\n\nstatic void __exit ir_rc5_decode_exit(void)\n{\n\tir_raw_handler_unregister(&rc5_handler);\n}\n\nmodule_init(ir_rc5_decode_init);\nmodule_exit(ir_rc5_decode_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab and Jarod Wilson\");\nMODULE_AUTHOR(\"Red Hat Inc. (http://www.redhat.com)\");\nMODULE_DESCRIPTION(\"RC5(x/sz) IR protocol decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}