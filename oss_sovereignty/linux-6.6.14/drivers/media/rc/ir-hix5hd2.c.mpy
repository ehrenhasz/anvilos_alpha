{
  "module_name": "ir-hix5hd2.c",
  "hash_id": "7a53ae843df7e8b77f4895a1a4ef368ce9fd7d59021e4e04b1be0a732bdcbbfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir-hix5hd2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <media/rc-core.h>\n\n#define IR_ENABLE\t\t0x00\n#define IR_CONFIG\t\t0x04\n#define CNT_LEADS\t\t0x08\n#define CNT_LEADE\t\t0x0c\n#define CNT_SLEADE\t\t0x10\n#define CNT0_B\t\t\t0x14\n#define CNT1_B\t\t\t0x18\n#define IR_BUSY\t\t\t0x1c\n#define IR_DATAH\t\t0x20\n#define IR_DATAL\t\t0x24\n#define IR_INTM\t\t\t0x28\n#define IR_INTS\t\t\t0x2c\n#define IR_INTC\t\t\t0x30\n#define IR_START\t\t0x34\n\n \n#define INTMS_SYMBRCV\t\t(BIT(24) | BIT(8))\n#define INTMS_TIMEOUT\t\t(BIT(25) | BIT(9))\n#define INTMS_OVERFLOW\t\t(BIT(26) | BIT(10))\n#define INT_CLR_OVERFLOW\tBIT(18)\n#define INT_CLR_TIMEOUT\t\tBIT(17)\n#define INT_CLR_RCV\t\tBIT(16)\n#define INT_CLR_RCVTIMEOUT\t(BIT(16) | BIT(17))\n\n#define IR_CLK_ENABLE\t\tBIT(4)\n#define IR_CLK_RESET\t\tBIT(5)\n\n \n#define IR_ENABLE_EN\t\tBIT(0)\n#define IR_ENABLE_EN_EXTRA\tBIT(8)\n\n#define IR_CFG_WIDTH_MASK\t0xffff\n#define IR_CFG_WIDTH_SHIFT\t16\n#define IR_CFG_FORMAT_MASK\t0x3\n#define IR_CFG_FORMAT_SHIFT\t14\n#define IR_CFG_INT_LEVEL_MASK\t0x3f\n#define IR_CFG_INT_LEVEL_SHIFT\t8\n \n#define IR_CFG_MODE_RAW\t\tBIT(7)\n#define IR_CFG_FREQ_MASK\t0x7f\n#define IR_CFG_FREQ_SHIFT\t0\n#define IR_CFG_INT_THRESHOLD\t1\n \n#define IR_CFG_SYMBOL_FMT\t0\n#define IR_CFG_SYMBOL_MAXWIDTH\t0x3e80\n\n#define IR_HIX5HD2_NAME\t\t\"hix5hd2-ir\"\n\n \n#define HIX5HD2_FLAG_EXTRA_ENABLE\tBIT(0)\n\nstruct hix5hd2_soc_data {\n\tu32 clk_reg;\n\tu32 flags;\n};\n\nstatic const struct hix5hd2_soc_data hix5hd2_data = {\n\t.clk_reg = 0x48,\n};\n\nstatic const struct hix5hd2_soc_data hi3796cv300_data = {\n\t.clk_reg = 0x60,\n\t.flags = HIX5HD2_FLAG_EXTRA_ENABLE,\n};\n\nstruct hix5hd2_ir_priv {\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct rc_dev\t\t*rdev;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clock;\n\tunsigned long\t\trate;\n\tconst struct hix5hd2_soc_data *socdata;\n};\n\nstatic int hix5hd2_ir_clk_enable(struct hix5hd2_ir_priv *dev, bool on)\n{\n\tu32 clk_reg = dev->socdata->clk_reg;\n\tu32 val;\n\tint ret = 0;\n\n\tif (dev->regmap) {\n\t\tregmap_read(dev->regmap, clk_reg, &val);\n\t\tif (on) {\n\t\t\tval &= ~IR_CLK_RESET;\n\t\t\tval |= IR_CLK_ENABLE;\n\t\t} else {\n\t\t\tval &= ~IR_CLK_ENABLE;\n\t\t\tval |= IR_CLK_RESET;\n\t\t}\n\t\tregmap_write(dev->regmap, clk_reg, val);\n\t} else {\n\t\tif (on)\n\t\t\tret = clk_prepare_enable(dev->clock);\n\t\telse\n\t\t\tclk_disable_unprepare(dev->clock);\n\t}\n\treturn ret;\n}\n\nstatic inline void hix5hd2_ir_enable(struct hix5hd2_ir_priv *priv)\n{\n\tu32 val = IR_ENABLE_EN;\n\n\tif (priv->socdata->flags & HIX5HD2_FLAG_EXTRA_ENABLE)\n\t\tval |= IR_ENABLE_EN_EXTRA;\n\n\twritel_relaxed(val, priv->base + IR_ENABLE);\n}\n\nstatic int hix5hd2_ir_config(struct hix5hd2_ir_priv *priv)\n{\n\tint timeout = 10000;\n\tu32 val, rate;\n\n\thix5hd2_ir_enable(priv);\n\n\twhile (readl_relaxed(priv->base + IR_BUSY)) {\n\t\tif (timeout--) {\n\t\t\tudelay(1);\n\t\t} else {\n\t\t\tdev_err(priv->dev, \"IR_BUSY timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\trate = DIV_ROUND_CLOSEST(priv->rate, 1000000);\n\tval = IR_CFG_SYMBOL_MAXWIDTH & IR_CFG_WIDTH_MASK << IR_CFG_WIDTH_SHIFT;\n\tval |= IR_CFG_SYMBOL_FMT & IR_CFG_FORMAT_MASK << IR_CFG_FORMAT_SHIFT;\n\tval |= (IR_CFG_INT_THRESHOLD - 1) & IR_CFG_INT_LEVEL_MASK\n\t       << IR_CFG_INT_LEVEL_SHIFT;\n\tval |= IR_CFG_MODE_RAW;\n\tval |= (rate - 1) & IR_CFG_FREQ_MASK << IR_CFG_FREQ_SHIFT;\n\twritel_relaxed(val, priv->base + IR_CONFIG);\n\n\twritel_relaxed(0x00, priv->base + IR_INTM);\n\t \n\twritel_relaxed(0x01, priv->base + IR_START);\n\treturn 0;\n}\n\nstatic int hix5hd2_ir_open(struct rc_dev *rdev)\n{\n\tstruct hix5hd2_ir_priv *priv = rdev->priv;\n\tint ret;\n\n\tret = hix5hd2_ir_clk_enable(priv, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hix5hd2_ir_config(priv);\n\tif (ret) {\n\t\thix5hd2_ir_clk_enable(priv, false);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void hix5hd2_ir_close(struct rc_dev *rdev)\n{\n\tstruct hix5hd2_ir_priv *priv = rdev->priv;\n\n\thix5hd2_ir_clk_enable(priv, false);\n}\n\nstatic irqreturn_t hix5hd2_ir_rx_interrupt(int irq, void *data)\n{\n\tu32 symb_num, symb_val, symb_time;\n\tu32 data_l, data_h;\n\tu32 irq_sr, i;\n\tstruct hix5hd2_ir_priv *priv = data;\n\n\tirq_sr = readl_relaxed(priv->base + IR_INTS);\n\tif (irq_sr & INTMS_OVERFLOW) {\n\t\t \n\t\tir_raw_event_overflow(priv->rdev);\n\t\tsymb_num = readl_relaxed(priv->base + IR_DATAH);\n\t\tfor (i = 0; i < symb_num; i++)\n\t\t\treadl_relaxed(priv->base + IR_DATAL);\n\n\t\twritel_relaxed(INT_CLR_OVERFLOW, priv->base + IR_INTC);\n\t\tdev_info(priv->dev, \"overflow, level=%d\\n\",\n\t\t\t IR_CFG_INT_THRESHOLD);\n\t}\n\n\tif ((irq_sr & INTMS_SYMBRCV) || (irq_sr & INTMS_TIMEOUT)) {\n\t\tstruct ir_raw_event ev = {};\n\n\t\tsymb_num = readl_relaxed(priv->base + IR_DATAH);\n\t\tfor (i = 0; i < symb_num; i++) {\n\t\t\tsymb_val = readl_relaxed(priv->base + IR_DATAL);\n\t\t\tdata_l = ((symb_val & 0xffff) * 10);\n\t\t\tdata_h =  ((symb_val >> 16) & 0xffff) * 10;\n\t\t\tsymb_time = (data_l + data_h) / 10;\n\n\t\t\tev.duration = data_l;\n\t\t\tev.pulse = true;\n\t\t\tir_raw_event_store(priv->rdev, &ev);\n\n\t\t\tif (symb_time < IR_CFG_SYMBOL_MAXWIDTH) {\n\t\t\t\tev.duration = data_h;\n\t\t\t\tev.pulse = false;\n\t\t\t\tir_raw_event_store(priv->rdev, &ev);\n\t\t\t} else {\n\t\t\t\tir_raw_event_set_idle(priv->rdev, true);\n\t\t\t}\n\t\t}\n\n\t\tif (irq_sr & INTMS_SYMBRCV)\n\t\t\twritel_relaxed(INT_CLR_RCV, priv->base + IR_INTC);\n\t\tif (irq_sr & INTMS_TIMEOUT)\n\t\t\twritel_relaxed(INT_CLR_TIMEOUT, priv->base + IR_INTC);\n\t}\n\n\t \n\tir_raw_event_handle(priv->rdev);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id hix5hd2_ir_table[] = {\n\t{ .compatible = \"hisilicon,hix5hd2-ir\", &hix5hd2_data, },\n\t{ .compatible = \"hisilicon,hi3796cv300-ir\", &hi3796cv300_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hix5hd2_ir_table);\n\nstatic int hix5hd2_ir_probe(struct platform_device *pdev)\n{\n\tstruct rc_dev *rdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct hix5hd2_ir_priv *priv;\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tconst char *map_name;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(hix5hd2_ir_table, dev);\n\tif (!of_id) {\n\t\tdev_err(dev, \"Unable to initialize IR data\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv->socdata = of_id->data;\n\n\tpriv->regmap = syscon_regmap_lookup_by_phandle(node,\n\t\t\t\t\t\t       \"hisilicon,power-syscon\");\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_info(dev, \"no power-reg\\n\");\n\t\tpriv->regmap = NULL;\n\t}\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev)\n\t\treturn -ENOMEM;\n\n\tpriv->clock = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clock)) {\n\t\tdev_err(dev, \"clock not found\\n\");\n\t\tret = PTR_ERR(priv->clock);\n\t\tgoto err;\n\t}\n\tret = clk_prepare_enable(priv->clock);\n\tif (ret)\n\t\tgoto err;\n\tpriv->rate = clk_get_rate(priv->clock);\n\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->priv = priv;\n\trdev->open = hix5hd2_ir_open;\n\trdev->close = hix5hd2_ir_close;\n\trdev->driver_name = IR_HIX5HD2_NAME;\n\tmap_name = of_get_property(node, \"linux,rc-map-name\", NULL);\n\trdev->map_name = map_name ?: RC_MAP_EMPTY;\n\trdev->device_name = IR_HIX5HD2_NAME;\n\trdev->input_phys = IR_HIX5HD2_NAME \"/input0\";\n\trdev->input_id.bustype = BUS_HOST;\n\trdev->input_id.vendor = 0x0001;\n\trdev->input_id.product = 0x0001;\n\trdev->input_id.version = 0x0100;\n\trdev->rx_resolution = 10;\n\trdev->timeout = IR_CFG_SYMBOL_MAXWIDTH * 10;\n\n\tret = rc_register_device(rdev);\n\tif (ret < 0)\n\t\tgoto clkerr;\n\n\tif (devm_request_irq(dev, priv->irq, hix5hd2_ir_rx_interrupt,\n\t\t\t     0, pdev->name, priv) < 0) {\n\t\tdev_err(dev, \"IRQ %d register failed\\n\", priv->irq);\n\t\tret = -EINVAL;\n\t\tgoto regerr;\n\t}\n\n\tpriv->rdev = rdev;\n\tpriv->dev = dev;\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn ret;\n\nregerr:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nclkerr:\n\tclk_disable_unprepare(priv->clock);\nerr:\n\trc_free_device(rdev);\n\tdev_err(dev, \"Unable to register device (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic void hix5hd2_ir_remove(struct platform_device *pdev)\n{\n\tstruct hix5hd2_ir_priv *priv = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(priv->clock);\n\trc_unregister_device(priv->rdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hix5hd2_ir_suspend(struct device *dev)\n{\n\tstruct hix5hd2_ir_priv *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clock);\n\thix5hd2_ir_clk_enable(priv, false);\n\n\treturn 0;\n}\n\nstatic int hix5hd2_ir_resume(struct device *dev)\n{\n\tstruct hix5hd2_ir_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = hix5hd2_ir_clk_enable(priv, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clock);\n\tif (ret) {\n\t\thix5hd2_ir_clk_enable(priv, false);\n\t\treturn ret;\n\t}\n\n\thix5hd2_ir_enable(priv);\n\n\twritel_relaxed(0x00, priv->base + IR_INTM);\n\twritel_relaxed(0xff, priv->base + IR_INTC);\n\twritel_relaxed(0x01, priv->base + IR_START);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(hix5hd2_ir_pm_ops, hix5hd2_ir_suspend,\n\t\t\t hix5hd2_ir_resume);\n\nstatic struct platform_driver hix5hd2_ir_driver = {\n\t.driver = {\n\t\t.name = IR_HIX5HD2_NAME,\n\t\t.of_match_table = hix5hd2_ir_table,\n\t\t.pm     = &hix5hd2_ir_pm_ops,\n\t},\n\t.probe = hix5hd2_ir_probe,\n\t.remove_new = hix5hd2_ir_remove,\n};\n\nmodule_platform_driver(hix5hd2_ir_driver);\n\nMODULE_DESCRIPTION(\"IR controller driver for hix5hd2 platforms\");\nMODULE_AUTHOR(\"Guoxiong Yan <yanguoxiong@huawei.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:hix5hd2-ir\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}