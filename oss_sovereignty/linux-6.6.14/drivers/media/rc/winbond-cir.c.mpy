{
  "module_name": "winbond-cir.c",
  "hash_id": "1109878fa3db0abaa1c2eab9911fe5d671df3fd0ff8905ea8988562ac009fe04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/winbond-cir.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/leds.h>\n#include <linux/spinlock.h>\n#include <linux/pci_ids.h>\n#include <linux/io.h>\n#include <linux/bitrev.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <media/rc-core.h>\n\n#define DRVNAME \"winbond-cir\"\n\n \n#define WBCIR_REG_WCEIR_CTL\t0x03  \n#define WBCIR_REG_WCEIR_STS\t0x04  \n#define WBCIR_REG_WCEIR_EV_EN\t0x05  \n#define WBCIR_REG_WCEIR_CNTL\t0x06  \n#define WBCIR_REG_WCEIR_CNTH\t0x07  \n#define WBCIR_REG_WCEIR_INDEX\t0x08  \n#define WBCIR_REG_WCEIR_DATA\t0x09  \n#define WBCIR_REG_WCEIR_CSL\t0x0A  \n#define WBCIR_REG_WCEIR_CFG1\t0x0B  \n#define WBCIR_REG_WCEIR_CFG2\t0x0C  \n\n \n#define WBCIR_REG_ECEIR_CTS\t0x00  \n#define WBCIR_REG_ECEIR_CCTL\t0x01  \n#define WBCIR_REG_ECEIR_CNT_LO\t0x02  \n#define WBCIR_REG_ECEIR_CNT_HI\t0x03  \n#define WBCIR_REG_ECEIR_IREM\t0x04  \n\n \n#define WBCIR_REG_SP3_BSR\t0x03  \n\t\t\t\t       \n#define WBCIR_REG_SP3_RXDATA\t0x00  \n#define WBCIR_REG_SP3_TXDATA\t0x00  \n#define WBCIR_REG_SP3_IER\t0x01  \n#define WBCIR_REG_SP3_EIR\t0x02  \n#define WBCIR_REG_SP3_FCR\t0x02  \n#define WBCIR_REG_SP3_MCR\t0x04  \n#define WBCIR_REG_SP3_LSR\t0x05  \n#define WBCIR_REG_SP3_MSR\t0x06  \n#define WBCIR_REG_SP3_ASCR\t0x07  \n\t\t\t\t       \n#define WBCIR_REG_SP3_BGDL\t0x00  \n#define WBCIR_REG_SP3_BGDH\t0x01  \n#define WBCIR_REG_SP3_EXCR1\t0x02  \n#define WBCIR_REG_SP3_EXCR2\t0x04  \n#define WBCIR_REG_SP3_TXFLV\t0x06  \n#define WBCIR_REG_SP3_RXFLV\t0x07  \n\t\t\t\t       \n#define WBCIR_REG_SP3_MRID\t0x00  \n#define WBCIR_REG_SP3_SH_LCR\t0x01  \n#define WBCIR_REG_SP3_SH_FCR\t0x02  \n\t\t\t\t       \n#define WBCIR_REG_SP3_IRCR1\t0x02  \n\t\t\t\t       \n#define WBCIR_REG_SP3_IRCR2\t0x04  \n\t\t\t\t       \n#define WBCIR_REG_SP3_IRCR3\t0x00  \n#define WBCIR_REG_SP3_SIR_PW\t0x02  \n\t\t\t\t       \n#define WBCIR_REG_SP3_IRRXDC\t0x00  \n#define WBCIR_REG_SP3_IRTXMC\t0x01  \n#define WBCIR_REG_SP3_RCCFG\t0x02  \n#define WBCIR_REG_SP3_IRCFG1\t0x04  \n#define WBCIR_REG_SP3_IRCFG4\t0x07  \n\n \n\n \n#define WBCIR_IRQ_NONE\t\t0x00\n \n#define WBCIR_IRQ_RX\t\t0x01\n \n#define WBCIR_IRQ_TX_LOW\t0x02\n \n#define WBCIR_IRQ_ERR\t\t0x04\n \n#define WBCIR_IRQ_TX_EMPTY\t0x20\n \n#define WBCIR_LED_ENABLE\t0x80\n \n#define WBCIR_RX_AVAIL\t\t0x01\n \n#define WBCIR_RX_OVERRUN\t0x02\n \n#define WBCIR_TX_EOT\t\t0x04\n \n#define WBCIR_RX_DISABLE\t0x20\n \n#define WBCIR_TX_UNDERRUN\t0x40\n \n#define WBCIR_EXT_ENABLE\t0x01\n \n#define WBCIR_REGSEL_COMPARE\t0x10\n \n#define WBCIR_REGSEL_MASK\t0x20\n \n#define WBCIR_REG_ADDR0\t\t0x00\n \n#define WBCIR_CNTR_EN\t\t0x01\n \n#define WBCIR_CNTR_R\t\t0x02\n \n#define WBCIR_IRTX_INV\t\t0x04\n \n#define WBCIR_RX_T_OV\t\t0x40\n\n \nenum wbcir_bank {\n\tWBCIR_BANK_0          = 0x00,\n\tWBCIR_BANK_1          = 0x80,\n\tWBCIR_BANK_2          = 0xE0,\n\tWBCIR_BANK_3          = 0xE4,\n\tWBCIR_BANK_4          = 0xE8,\n\tWBCIR_BANK_5          = 0xEC,\n\tWBCIR_BANK_6          = 0xF0,\n\tWBCIR_BANK_7          = 0xF4,\n};\n\n \nenum wbcir_protocol {\n\tIR_PROTOCOL_RC5          = 0x0,\n\tIR_PROTOCOL_NEC          = 0x1,\n\tIR_PROTOCOL_RC6          = 0x2,\n};\n\n \nenum wbcir_rxstate {\n\tWBCIR_RXSTATE_INACTIVE = 0,\n\tWBCIR_RXSTATE_ACTIVE,\n\tWBCIR_RXSTATE_ERROR\n};\n\n \nenum wbcir_txstate {\n\tWBCIR_TXSTATE_INACTIVE = 0,\n\tWBCIR_TXSTATE_ACTIVE,\n\tWBCIR_TXSTATE_ERROR\n};\n\n \n#define WBCIR_NAME\t\"Winbond CIR\"\n#define WBCIR_ID_FAMILY          0xF1  \n#define\tWBCIR_ID_CHIP            0x04  \n#define WAKEUP_IOMEM_LEN         0x10  \n#define EHFUNC_IOMEM_LEN         0x10  \n#define SP_IOMEM_LEN             0x08  \n\n \nstruct wbcir_data {\n\tspinlock_t spinlock;\n\tstruct rc_dev *dev;\n\tstruct led_classdev led;\n\n\tunsigned long wbase;         \n\tunsigned long ebase;         \n\tunsigned long sbase;         \n\tunsigned int  irq;           \n\tu8 irqmask;\n\n\t \n\tenum wbcir_rxstate rxstate;\n\tint carrier_report_enabled;\n\tu32 pulse_duration;\n\n\t \n\tenum wbcir_txstate txstate;\n\tu32 txlen;\n\tu32 txoff;\n\tu32 *txbuf;\n\tu8 txmask;\n\tu32 txcarrier;\n};\n\nstatic bool invert;  \nmodule_param(invert, bool, 0444);\nMODULE_PARM_DESC(invert, \"Invert the signal from the IR receiver\");\n\nstatic bool txandrx;  \nmodule_param(txandrx, bool, 0444);\nMODULE_PARM_DESC(txandrx, \"Allow simultaneous TX and RX\");\n\n\n \n\n \nstatic void\nwbcir_set_bits(unsigned long addr, u8 bits, u8 mask)\n{\n\tu8 val;\n\n\tval = inb(addr);\n\tval = ((val & ~mask) | (bits & mask));\n\toutb(val, addr);\n}\n\n \nstatic inline void\nwbcir_select_bank(struct wbcir_data *data, enum wbcir_bank bank)\n{\n\toutb(bank, data->sbase + WBCIR_REG_SP3_BSR);\n}\n\nstatic inline void\nwbcir_set_irqmask(struct wbcir_data *data, u8 irqmask)\n{\n\tif (data->irqmask == irqmask)\n\t\treturn;\n\n\twbcir_select_bank(data, WBCIR_BANK_0);\n\toutb(irqmask, data->sbase + WBCIR_REG_SP3_IER);\n\tdata->irqmask = irqmask;\n}\n\nstatic enum led_brightness\nwbcir_led_brightness_get(struct led_classdev *led_cdev)\n{\n\tstruct wbcir_data *data = container_of(led_cdev,\n\t\t\t\t\t       struct wbcir_data,\n\t\t\t\t\t       led);\n\n\tif (inb(data->ebase + WBCIR_REG_ECEIR_CTS) & WBCIR_LED_ENABLE)\n\t\treturn LED_FULL;\n\telse\n\t\treturn LED_OFF;\n}\n\nstatic void\nwbcir_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t enum led_brightness brightness)\n{\n\tstruct wbcir_data *data = container_of(led_cdev,\n\t\t\t\t\t       struct wbcir_data,\n\t\t\t\t\t       led);\n\n\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CTS,\n\t\t       brightness == LED_OFF ? 0x00 : WBCIR_LED_ENABLE,\n\t\t       WBCIR_LED_ENABLE);\n}\n\n \nstatic u8\nwbcir_to_rc6cells(u8 val)\n{\n\tu8 coded = 0x00;\n\tint i;\n\n\tval &= 0x0F;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (val & 0x01)\n\t\t\tcoded |= 0x02 << (i * 2);\n\t\telse\n\t\t\tcoded |= 0x01 << (i * 2);\n\t\tval >>= 1;\n\t}\n\n\treturn coded;\n}\n\n \n\nstatic void\nwbcir_carrier_report(struct wbcir_data *data)\n{\n\tunsigned counter = inb(data->ebase + WBCIR_REG_ECEIR_CNT_LO) |\n\t\t\tinb(data->ebase + WBCIR_REG_ECEIR_CNT_HI) << 8;\n\n\tif (counter > 0 && counter < 0xffff) {\n\t\tstruct ir_raw_event ev = {\n\t\t\t.carrier_report = 1,\n\t\t\t.carrier = DIV_ROUND_CLOSEST(counter * 1000000u,\n\t\t\t\t\t\tdata->pulse_duration)\n\t\t};\n\n\t\tir_raw_event_store(data->dev, &ev);\n\t}\n\n\t \n\tdata->pulse_duration = 0;\n\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_R,\n\t\t\t\t\t\tWBCIR_CNTR_EN | WBCIR_CNTR_R);\n\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_EN,\n\t\t\t\t\t\tWBCIR_CNTR_EN | WBCIR_CNTR_R);\n}\n\nstatic void\nwbcir_idle_rx(struct rc_dev *dev, bool idle)\n{\n\tstruct wbcir_data *data = dev->priv;\n\n\tif (!idle && data->rxstate == WBCIR_RXSTATE_INACTIVE)\n\t\tdata->rxstate = WBCIR_RXSTATE_ACTIVE;\n\n\tif (idle && data->rxstate != WBCIR_RXSTATE_INACTIVE) {\n\t\tdata->rxstate = WBCIR_RXSTATE_INACTIVE;\n\n\t\tif (data->carrier_report_enabled)\n\t\t\twbcir_carrier_report(data);\n\n\t\t \n\t\toutb(WBCIR_RX_DISABLE, data->sbase + WBCIR_REG_SP3_ASCR);\n\t}\n}\n\nstatic void\nwbcir_irq_rx(struct wbcir_data *data, struct pnp_dev *device)\n{\n\tu8 irdata;\n\tstruct ir_raw_event rawir = {};\n\n\t \n\twhile (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_AVAIL) {\n\t\tirdata = inb(data->sbase + WBCIR_REG_SP3_RXDATA);\n\t\tif (data->rxstate == WBCIR_RXSTATE_ERROR)\n\t\t\tcontinue;\n\n\t\trawir.duration = ((irdata & 0x7F) + 1) *\n\t\t\t(data->carrier_report_enabled ? 2 : 10);\n\t\trawir.pulse = irdata & 0x80 ? false : true;\n\n\t\tif (rawir.pulse)\n\t\t\tdata->pulse_duration += rawir.duration;\n\n\t\tir_raw_event_store_with_filter(data->dev, &rawir);\n\t}\n\n\tir_raw_event_handle(data->dev);\n}\n\nstatic void\nwbcir_irq_tx(struct wbcir_data *data)\n{\n\tunsigned int space;\n\tunsigned int used;\n\tu8 bytes[16];\n\tu8 byte;\n\n\tif (!data->txbuf)\n\t\treturn;\n\n\tswitch (data->txstate) {\n\tcase WBCIR_TXSTATE_INACTIVE:\n\t\t \n\t\tspace = 16;\n\t\tbreak;\n\tcase WBCIR_TXSTATE_ACTIVE:\n\t\t \n\t\tspace = 13;\n\t\tbreak;\n\tcase WBCIR_TXSTATE_ERROR:\n\t\tspace = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tfor (used = 0; used < space && data->txoff != data->txlen; used++) {\n\t\tif (data->txbuf[data->txoff] == 0) {\n\t\t\tdata->txoff++;\n\t\t\tcontinue;\n\t\t}\n\t\tbyte = min((u32)0x80, data->txbuf[data->txoff]);\n\t\tdata->txbuf[data->txoff] -= byte;\n\t\tbyte--;\n\t\tbyte |= (data->txoff % 2 ? 0x80 : 0x00);  \n\t\tbytes[used] = byte;\n\t}\n\n\twhile (data->txoff != data->txlen && data->txbuf[data->txoff] == 0)\n\t\tdata->txoff++;\n\n\tif (used == 0) {\n\t\t \n\t\tif (data->txstate == WBCIR_TXSTATE_ERROR)\n\t\t\t \n\t\t\toutb(WBCIR_TX_UNDERRUN, data->sbase + WBCIR_REG_SP3_ASCR);\n\t\twbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR);\n\t\tkfree(data->txbuf);\n\t\tdata->txbuf = NULL;\n\t\tdata->txstate = WBCIR_TXSTATE_INACTIVE;\n\t} else if (data->txoff == data->txlen) {\n\t\t \n\t\toutsb(data->sbase + WBCIR_REG_SP3_TXDATA, bytes, used - 1);\n\t\toutb(WBCIR_TX_EOT, data->sbase + WBCIR_REG_SP3_ASCR);\n\t\toutb(bytes[used - 1], data->sbase + WBCIR_REG_SP3_TXDATA);\n\t\twbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR |\n\t\t\t\t  WBCIR_IRQ_TX_EMPTY);\n\t} else {\n\t\t \n\t\toutsb(data->sbase + WBCIR_REG_SP3_RXDATA, bytes, used);\n\t\tif (data->txstate == WBCIR_TXSTATE_INACTIVE) {\n\t\t\twbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR |\n\t\t\t\t\t  WBCIR_IRQ_TX_LOW);\n\t\t\tdata->txstate = WBCIR_TXSTATE_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t\nwbcir_irq_handler(int irqno, void *cookie)\n{\n\tstruct pnp_dev *device = cookie;\n\tstruct wbcir_data *data = pnp_get_drvdata(device);\n\tunsigned long flags;\n\tu8 status;\n\n\tspin_lock_irqsave(&data->spinlock, flags);\n\twbcir_select_bank(data, WBCIR_BANK_0);\n\tstatus = inb(data->sbase + WBCIR_REG_SP3_EIR);\n\tstatus &= data->irqmask;\n\n\tif (!status) {\n\t\tspin_unlock_irqrestore(&data->spinlock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status & WBCIR_IRQ_ERR) {\n\t\t \n\t\tif (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_OVERRUN) {\n\t\t\tdata->rxstate = WBCIR_RXSTATE_ERROR;\n\t\t\tir_raw_event_overflow(data->dev);\n\t\t}\n\n\t\t \n\t\tif (inb(data->sbase + WBCIR_REG_SP3_ASCR) & WBCIR_TX_UNDERRUN)\n\t\t\tdata->txstate = WBCIR_TXSTATE_ERROR;\n\t}\n\n\tif (status & WBCIR_IRQ_RX)\n\t\twbcir_irq_rx(data, device);\n\n\tif (status & (WBCIR_IRQ_TX_LOW | WBCIR_IRQ_TX_EMPTY))\n\t\twbcir_irq_tx(data);\n\n\tspin_unlock_irqrestore(&data->spinlock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int\nwbcir_set_carrier_report(struct rc_dev *dev, int enable)\n{\n\tstruct wbcir_data *data = dev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->spinlock, flags);\n\n\tif (data->carrier_report_enabled == enable) {\n\t\tspin_unlock_irqrestore(&data->spinlock, flags);\n\t\treturn 0;\n\t}\n\n\tdata->pulse_duration = 0;\n\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_R,\n\t\t\t\t\t\tWBCIR_CNTR_EN | WBCIR_CNTR_R);\n\n\tif (enable && data->dev->idle)\n\t\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL,\n\t\t\t\tWBCIR_CNTR_EN, WBCIR_CNTR_EN | WBCIR_CNTR_R);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_2);\n\tdata->dev->rx_resolution = enable ? 2 : 10;\n\toutb(enable ? 0x03 : 0x0f, data->sbase + WBCIR_REG_SP3_BGDL);\n\toutb(0x00, data->sbase + WBCIR_REG_SP3_BGDH);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_7);\n\twbcir_set_bits(data->sbase + WBCIR_REG_SP3_RCCFG,\n\t\t\t\tenable ? WBCIR_RX_T_OV : 0, WBCIR_RX_T_OV);\n\n\tdata->carrier_report_enabled = enable;\n\tspin_unlock_irqrestore(&data->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int\nwbcir_txcarrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct wbcir_data *data = dev->priv;\n\tunsigned long flags;\n\tu8 val;\n\tu32 freq;\n\n\tfreq = DIV_ROUND_CLOSEST(carrier, 1000);\n\tif (freq < 30 || freq > 60)\n\t\treturn -EINVAL;\n\n\tswitch (freq) {\n\tcase 58:\n\tcase 59:\n\tcase 60:\n\t\tval = freq - 58;\n\t\tfreq *= 1000;\n\t\tbreak;\n\tcase 57:\n\t\tval = freq - 27;\n\t\tfreq = 56900;\n\t\tbreak;\n\tdefault:\n\t\tval = freq - 27;\n\t\tfreq *= 1000;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&data->spinlock, flags);\n\tif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\n\t\tspin_unlock_irqrestore(&data->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (data->txcarrier != freq) {\n\t\twbcir_select_bank(data, WBCIR_BANK_7);\n\t\twbcir_set_bits(data->sbase + WBCIR_REG_SP3_IRTXMC, val, 0x1F);\n\t\tdata->txcarrier = freq;\n\t}\n\n\tspin_unlock_irqrestore(&data->spinlock, flags);\n\treturn 0;\n}\n\nstatic int\nwbcir_txmask(struct rc_dev *dev, u32 mask)\n{\n\tstruct wbcir_data *data = dev->priv;\n\tunsigned long flags;\n\tu8 val;\n\n\t \n\tif (mask > 15)\n\t\treturn 4;\n\n\t \n\tswitch (mask) {\n\tcase 0x1:\n\t\tval = 0x0;\n\t\tbreak;\n\tcase 0x2:\n\t\tval = 0x1;\n\t\tbreak;\n\tcase 0x4:\n\t\tval = 0x2;\n\t\tbreak;\n\tcase 0x8:\n\t\tval = 0x3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&data->spinlock, flags);\n\tif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\n\t\tspin_unlock_irqrestore(&data->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (data->txmask != mask) {\n\t\twbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CTS, val, 0x0c);\n\t\tdata->txmask = mask;\n\t}\n\n\tspin_unlock_irqrestore(&data->spinlock, flags);\n\treturn 0;\n}\n\nstatic int\nwbcir_tx(struct rc_dev *dev, unsigned *b, unsigned count)\n{\n\tstruct wbcir_data *data = dev->priv;\n\tunsigned *buf;\n\tunsigned i;\n\tunsigned long flags;\n\n\tbuf = kmalloc_array(count, sizeof(*b), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tbuf[i] = DIV_ROUND_CLOSEST(b[i], 10);\n\n\t \n\tspin_lock_irqsave(&data->spinlock, flags);\n\tif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\n\t\tspin_unlock_irqrestore(&data->spinlock, flags);\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdata->txbuf = buf;\n\tdata->txlen = count;\n\tdata->txoff = 0;\n\twbcir_irq_tx(data);\n\n\t \n\tspin_unlock_irqrestore(&data->spinlock, flags);\n\treturn count;\n}\n\n \n\nstatic void\nwbcir_shutdown(struct pnp_dev *device)\n{\n\tstruct device *dev = &device->dev;\n\tstruct wbcir_data *data = pnp_get_drvdata(device);\n\tstruct rc_dev *rc = data->dev;\n\tbool do_wake = true;\n\tu8 match[11];\n\tu8 mask[11];\n\tu8 rc6_csl = 0;\n\tu8 proto;\n\tu32 wake_sc = rc->scancode_wakeup_filter.data;\n\tu32 mask_sc = rc->scancode_wakeup_filter.mask;\n\tint i;\n\n\tmemset(match, 0, sizeof(match));\n\tmemset(mask, 0, sizeof(mask));\n\n\tif (!mask_sc || !device_may_wakeup(dev)) {\n\t\tdo_wake = false;\n\t\tgoto finish;\n\t}\n\n\tswitch (rc->wakeup_protocol) {\n\tcase RC_PROTO_RC5:\n\t\t \n\t\tmask[0]  = (mask_sc & 0x003f);\n\t\tmask[0] |= (mask_sc & 0x0300) >> 2;\n\t\tmask[1]  = (mask_sc & 0x1c00) >> 10;\n\t\tif (mask_sc & 0x0040)\t\t       \n\t\t\tmatch[1] |= 0x10;\n\n\t\tmatch[0]  = (wake_sc & 0x003F);        \n\t\tmatch[0] |= (wake_sc & 0x0300) >> 2;   \n\t\tmatch[1]  = (wake_sc & 0x1c00) >> 10;  \n\t\tif (!(wake_sc & 0x0040))\t       \n\t\t\tmatch[1] |= 0x10;\n\n\t\tproto = IR_PROTOCOL_RC5;\n\t\tbreak;\n\n\tcase RC_PROTO_NEC:\n\t\tmask[1] = bitrev8(mask_sc);\n\t\tmask[0] = mask[1];\n\t\tmask[3] = bitrev8(mask_sc >> 8);\n\t\tmask[2] = mask[3];\n\n\t\tmatch[1] = bitrev8(wake_sc);\n\t\tmatch[0] = ~match[1];\n\t\tmatch[3] = bitrev8(wake_sc >> 8);\n\t\tmatch[2] = ~match[3];\n\n\t\tproto = IR_PROTOCOL_NEC;\n\t\tbreak;\n\n\tcase RC_PROTO_NECX:\n\t\tmask[1] = bitrev8(mask_sc);\n\t\tmask[0] = mask[1];\n\t\tmask[2] = bitrev8(mask_sc >> 8);\n\t\tmask[3] = bitrev8(mask_sc >> 16);\n\n\t\tmatch[1] = bitrev8(wake_sc);\n\t\tmatch[0] = ~match[1];\n\t\tmatch[2] = bitrev8(wake_sc >> 8);\n\t\tmatch[3] = bitrev8(wake_sc >> 16);\n\n\t\tproto = IR_PROTOCOL_NEC;\n\t\tbreak;\n\n\tcase RC_PROTO_NEC32:\n\t\tmask[0] = bitrev8(mask_sc);\n\t\tmask[1] = bitrev8(mask_sc >> 8);\n\t\tmask[2] = bitrev8(mask_sc >> 16);\n\t\tmask[3] = bitrev8(mask_sc >> 24);\n\n\t\tmatch[0] = bitrev8(wake_sc);\n\t\tmatch[1] = bitrev8(wake_sc >> 8);\n\t\tmatch[2] = bitrev8(wake_sc >> 16);\n\t\tmatch[3] = bitrev8(wake_sc >> 24);\n\n\t\tproto = IR_PROTOCOL_NEC;\n\t\tbreak;\n\n\tcase RC_PROTO_RC6_0:\n\t\t \n\t\tmatch[0] = wbcir_to_rc6cells(wake_sc >> 0);\n\t\tmask[0]  = wbcir_to_rc6cells(mask_sc >> 0);\n\t\tmatch[1] = wbcir_to_rc6cells(wake_sc >> 4);\n\t\tmask[1]  = wbcir_to_rc6cells(mask_sc >> 4);\n\n\t\t \n\t\tmatch[2] = wbcir_to_rc6cells(wake_sc >>  8);\n\t\tmask[2]  = wbcir_to_rc6cells(mask_sc >>  8);\n\t\tmatch[3] = wbcir_to_rc6cells(wake_sc >> 12);\n\t\tmask[3]  = wbcir_to_rc6cells(mask_sc >> 12);\n\n\t\t \n\t\tmatch[4] = 0x50;  \n\t\tmask[4]  = 0xF0;\n\t\tmatch[5] = 0x09;  \n\t\tmask[5]  = 0x0F;\n\n\t\trc6_csl = 44;\n\t\tproto = IR_PROTOCOL_RC6;\n\t\tbreak;\n\n\tcase RC_PROTO_RC6_6A_24:\n\tcase RC_PROTO_RC6_6A_32:\n\tcase RC_PROTO_RC6_MCE:\n\t\ti = 0;\n\n\t\t \n\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >>  0);\n\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >>  0);\n\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >>  4);\n\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >>  4);\n\n\t\t \n\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >>  8);\n\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >>  8);\n\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >> 12);\n\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >> 12);\n\n\t\t \n\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >> 16);\n\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >> 16);\n\n\t\tif (rc->wakeup_protocol == RC_PROTO_RC6_6A_20) {\n\t\t\trc6_csl = 52;\n\t\t} else {\n\t\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >> 20);\n\t\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >> 20);\n\n\t\t\tif (rc->wakeup_protocol == RC_PROTO_RC6_6A_24) {\n\t\t\t\trc6_csl = 60;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >> 24);\n\t\t\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >> 24);\n\t\t\t\tmatch[i]  = wbcir_to_rc6cells(wake_sc >> 28);\n\t\t\t\tmask[i++] = wbcir_to_rc6cells(mask_sc >> 28);\n\t\t\t\trc6_csl = 76;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmatch[i]  = 0x93;  \n\t\tmask[i++] = 0xFF;\n\t\tmatch[i]  = 0x0A;  \n\t\tmask[i++] = 0x0F;\n\t\tproto = IR_PROTOCOL_RC6;\n\t\tbreak;\n\tdefault:\n\t\tdo_wake = false;\n\t\tbreak;\n\t}\n\nfinish:\n\tif (do_wake) {\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_INDEX,\n\t\t\t       WBCIR_REGSEL_COMPARE | WBCIR_REG_ADDR0,\n\t\t\t       0x3F);\n\t\toutsb(data->wbase + WBCIR_REG_WCEIR_DATA, match, 11);\n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_INDEX,\n\t\t\t       WBCIR_REGSEL_MASK | WBCIR_REG_ADDR0,\n\t\t\t       0x3F);\n\t\toutsb(data->wbase + WBCIR_REG_WCEIR_DATA, mask, 11);\n\n\t\t \n\t\toutb(rc6_csl, data->wbase + WBCIR_REG_WCEIR_CSL);\n\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\n\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x01, 0x07);\n\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL,\n\t\t\t       (proto << 4) | 0x01, 0x31);\n\n\t} else {\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\n\n\t\t \n\t\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, 0x00, 0x01);\n\t}\n\n\t \n\twbcir_set_irqmask(data, WBCIR_IRQ_NONE);\n\tdisable_irq(data->irq);\n}\n\n \nstatic int\nwbcir_set_wakeup_filter(struct rc_dev *rc, struct rc_scancode_filter *filter)\n{\n\treturn 0;\n}\n\nstatic int\nwbcir_suspend(struct pnp_dev *device, pm_message_t state)\n{\n\tstruct wbcir_data *data = pnp_get_drvdata(device);\n\tled_classdev_suspend(&data->led);\n\twbcir_shutdown(device);\n\treturn 0;\n}\n\nstatic void\nwbcir_init_hw(struct wbcir_data *data)\n{\n\t \n\twbcir_set_irqmask(data, WBCIR_IRQ_NONE);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, invert ? 8 : 0, 0x09);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CFG1, 0x4A, 0x7F);\n\n\t \n\tif (invert)\n\t\toutb(WBCIR_IRTX_INV, data->ebase + WBCIR_REG_ECEIR_CCTL);\n\telse\n\t\toutb(0x00, data->ebase + WBCIR_REG_ECEIR_CCTL);\n\n\t \n\toutb(0x10, data->ebase + WBCIR_REG_ECEIR_CTS);\n\tdata->txmask = 0x1;\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_2);\n\toutb(WBCIR_EXT_ENABLE, data->sbase + WBCIR_REG_SP3_EXCR1);\n\n\t \n\n\t \n\toutb(0x30, data->sbase + WBCIR_REG_SP3_EXCR2);\n\n\t \n\toutb(0x0f, data->sbase + WBCIR_REG_SP3_BGDL);\n\toutb(0x00, data->sbase + WBCIR_REG_SP3_BGDH);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_0);\n\toutb(0xC0, data->sbase + WBCIR_REG_SP3_MCR);\n\tinb(data->sbase + WBCIR_REG_SP3_LSR);  \n\tinb(data->sbase + WBCIR_REG_SP3_MSR);  \n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_7);\n\toutb(0x90, data->sbase + WBCIR_REG_SP3_RCCFG);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_4);\n\toutb(0x00, data->sbase + WBCIR_REG_SP3_IRCR1);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_5);\n\toutb(txandrx ? 0x03 : 0x02, data->sbase + WBCIR_REG_SP3_IRCR2);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_6);\n\toutb(0x20, data->sbase + WBCIR_REG_SP3_IRCR3);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_7);\n\toutb(0xF2, data->sbase + WBCIR_REG_SP3_IRRXDC);\n\n\t \n\toutb(0x69, data->sbase + WBCIR_REG_SP3_IRTXMC);\n\tdata->txcarrier = 36000;\n\n\t \n\tif (invert)\n\t\toutb(0x10, data->sbase + WBCIR_REG_SP3_IRCFG4);\n\telse\n\t\toutb(0x00, data->sbase + WBCIR_REG_SP3_IRCFG4);\n\n\t \n\twbcir_select_bank(data, WBCIR_BANK_0);\n\toutb(0x97, data->sbase + WBCIR_REG_SP3_FCR);\n\n\t \n\toutb(0xE0, data->sbase + WBCIR_REG_SP3_ASCR);\n\n\t \n\tdata->rxstate = WBCIR_RXSTATE_INACTIVE;\n\twbcir_idle_rx(data->dev, true);\n\n\t \n\tif (data->txstate == WBCIR_TXSTATE_ACTIVE) {\n\t\tkfree(data->txbuf);\n\t\tdata->txbuf = NULL;\n\t\tdata->txstate = WBCIR_TXSTATE_INACTIVE;\n\t}\n\n\t \n\twbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR);\n}\n\nstatic int\nwbcir_resume(struct pnp_dev *device)\n{\n\tstruct wbcir_data *data = pnp_get_drvdata(device);\n\n\twbcir_init_hw(data);\n\tenable_irq(data->irq);\n\tled_classdev_resume(&data->led);\n\n\treturn 0;\n}\n\nstatic int\nwbcir_probe(struct pnp_dev *device, const struct pnp_device_id *dev_id)\n{\n\tstruct device *dev = &device->dev;\n\tstruct wbcir_data *data;\n\tint err;\n\n\tif (!(pnp_port_len(device, 0) == EHFUNC_IOMEM_LEN &&\n\t      pnp_port_len(device, 1) == WAKEUP_IOMEM_LEN &&\n\t      pnp_port_len(device, 2) == SP_IOMEM_LEN)) {\n\t\tdev_err(dev, \"Invalid resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tpnp_set_drvdata(device, data);\n\n\tspin_lock_init(&data->spinlock);\n\tdata->ebase = pnp_port_start(device, 0);\n\tdata->wbase = pnp_port_start(device, 1);\n\tdata->sbase = pnp_port_start(device, 2);\n\tdata->irq = pnp_irq(device, 0);\n\n\tif (data->wbase == 0 || data->ebase == 0 ||\n\t    data->sbase == 0 || data->irq == -1) {\n\t\terr = -ENODEV;\n\t\tdev_err(dev, \"Invalid resources\\n\");\n\t\tgoto exit_free_data;\n\t}\n\n\tdev_dbg(&device->dev, \"Found device (w: 0x%lX, e: 0x%lX, s: 0x%lX, i: %u)\\n\",\n\t\tdata->wbase, data->ebase, data->sbase, data->irq);\n\n\tdata->led.name = \"cir::activity\";\n\tdata->led.default_trigger = \"rc-feedback\";\n\tdata->led.brightness_set = wbcir_led_brightness_set;\n\tdata->led.brightness_get = wbcir_led_brightness_get;\n\terr = led_classdev_register(&device->dev, &data->led);\n\tif (err)\n\t\tgoto exit_free_data;\n\n\tdata->dev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!data->dev) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_unregister_led;\n\t}\n\n\tdata->dev->driver_name = DRVNAME;\n\tdata->dev->device_name = WBCIR_NAME;\n\tdata->dev->input_phys = \"wbcir/cir0\";\n\tdata->dev->input_id.bustype = BUS_HOST;\n\tdata->dev->input_id.vendor = PCI_VENDOR_ID_WINBOND;\n\tdata->dev->input_id.product = WBCIR_ID_FAMILY;\n\tdata->dev->input_id.version = WBCIR_ID_CHIP;\n\tdata->dev->map_name = RC_MAP_RC6_MCE;\n\tdata->dev->s_idle = wbcir_idle_rx;\n\tdata->dev->s_carrier_report = wbcir_set_carrier_report;\n\tdata->dev->s_tx_mask = wbcir_txmask;\n\tdata->dev->s_tx_carrier = wbcir_txcarrier;\n\tdata->dev->tx_ir = wbcir_tx;\n\tdata->dev->priv = data;\n\tdata->dev->dev.parent = &device->dev;\n\tdata->dev->min_timeout = 1;\n\tdata->dev->timeout = IR_DEFAULT_TIMEOUT;\n\tdata->dev->max_timeout = 10 * IR_DEFAULT_TIMEOUT;\n\tdata->dev->rx_resolution = 2;\n\tdata->dev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\tdata->dev->allowed_wakeup_protocols = RC_PROTO_BIT_NEC |\n\t\tRC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32 | RC_PROTO_BIT_RC5 |\n\t\tRC_PROTO_BIT_RC6_0 | RC_PROTO_BIT_RC6_6A_20 |\n\t\tRC_PROTO_BIT_RC6_6A_24 | RC_PROTO_BIT_RC6_6A_32 |\n\t\tRC_PROTO_BIT_RC6_MCE;\n\tdata->dev->wakeup_protocol = RC_PROTO_RC6_MCE;\n\tdata->dev->scancode_wakeup_filter.data = 0x800f040c;\n\tdata->dev->scancode_wakeup_filter.mask = 0xffff7fff;\n\tdata->dev->s_wakeup_filter = wbcir_set_wakeup_filter;\n\n\terr = rc_register_device(data->dev);\n\tif (err)\n\t\tgoto exit_free_rc;\n\n\tif (!request_region(data->wbase, WAKEUP_IOMEM_LEN, DRVNAME)) {\n\t\tdev_err(dev, \"Region 0x%lx-0x%lx already in use!\\n\",\n\t\t\tdata->wbase, data->wbase + WAKEUP_IOMEM_LEN - 1);\n\t\terr = -EBUSY;\n\t\tgoto exit_unregister_device;\n\t}\n\n\tif (!request_region(data->ebase, EHFUNC_IOMEM_LEN, DRVNAME)) {\n\t\tdev_err(dev, \"Region 0x%lx-0x%lx already in use!\\n\",\n\t\t\tdata->ebase, data->ebase + EHFUNC_IOMEM_LEN - 1);\n\t\terr = -EBUSY;\n\t\tgoto exit_release_wbase;\n\t}\n\n\tif (!request_region(data->sbase, SP_IOMEM_LEN, DRVNAME)) {\n\t\tdev_err(dev, \"Region 0x%lx-0x%lx already in use!\\n\",\n\t\t\tdata->sbase, data->sbase + SP_IOMEM_LEN - 1);\n\t\terr = -EBUSY;\n\t\tgoto exit_release_ebase;\n\t}\n\n\terr = request_irq(data->irq, wbcir_irq_handler,\n\t\t\t  0, DRVNAME, device);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to claim IRQ %u\\n\", data->irq);\n\t\terr = -EBUSY;\n\t\tgoto exit_release_sbase;\n\t}\n\n\tdevice_init_wakeup(&device->dev, 1);\n\n\twbcir_init_hw(data);\n\n\treturn 0;\n\nexit_release_sbase:\n\trelease_region(data->sbase, SP_IOMEM_LEN);\nexit_release_ebase:\n\trelease_region(data->ebase, EHFUNC_IOMEM_LEN);\nexit_release_wbase:\n\trelease_region(data->wbase, WAKEUP_IOMEM_LEN);\nexit_unregister_device:\n\trc_unregister_device(data->dev);\n\tdata->dev = NULL;\nexit_free_rc:\n\trc_free_device(data->dev);\nexit_unregister_led:\n\tled_classdev_unregister(&data->led);\nexit_free_data:\n\tkfree(data);\n\tpnp_set_drvdata(device, NULL);\nexit:\n\treturn err;\n}\n\nstatic void\nwbcir_remove(struct pnp_dev *device)\n{\n\tstruct wbcir_data *data = pnp_get_drvdata(device);\n\n\t \n\twbcir_set_irqmask(data, WBCIR_IRQ_NONE);\n\tfree_irq(data->irq, device);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, 0x00, 0x01);\n\n\t \n\twbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\n\n\trc_unregister_device(data->dev);\n\n\tled_classdev_unregister(&data->led);\n\n\t \n\twbcir_led_brightness_set(&data->led, LED_OFF);\n\n\trelease_region(data->wbase, WAKEUP_IOMEM_LEN);\n\trelease_region(data->ebase, EHFUNC_IOMEM_LEN);\n\trelease_region(data->sbase, SP_IOMEM_LEN);\n\n\tkfree(data);\n\n\tpnp_set_drvdata(device, NULL);\n}\n\nstatic const struct pnp_device_id wbcir_ids[] = {\n\t{ \"WEC1022\", 0 },\n\t{ \"\", 0 }\n};\nMODULE_DEVICE_TABLE(pnp, wbcir_ids);\n\nstatic struct pnp_driver wbcir_driver = {\n\t.name     = DRVNAME,\n\t.id_table = wbcir_ids,\n\t.probe    = wbcir_probe,\n\t.remove   = wbcir_remove,\n\t.suspend  = wbcir_suspend,\n\t.resume   = wbcir_resume,\n\t.shutdown = wbcir_shutdown\n};\n\nstatic int __init\nwbcir_init(void)\n{\n\tint ret;\n\n\tret = pnp_register_driver(&wbcir_driver);\n\tif (ret)\n\t\tpr_err(\"Unable to register driver\\n\");\n\n\treturn ret;\n}\n\nstatic void __exit\nwbcir_exit(void)\n{\n\tpnp_unregister_driver(&wbcir_driver);\n}\n\nmodule_init(wbcir_init);\nmodule_exit(wbcir_exit);\n\nMODULE_AUTHOR(\"David H\u00e4rdeman <david@hardeman.nu>\");\nMODULE_DESCRIPTION(\"Winbond SuperI/O Consumer IR Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}