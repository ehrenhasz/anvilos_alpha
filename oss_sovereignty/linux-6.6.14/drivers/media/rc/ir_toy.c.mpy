{
  "module_name": "ir_toy.c",
  "hash_id": "1c600512825dbb691759f29944c505897139b862187abb169836832d2b58219f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/ir_toy.c",
  "human_readable_source": "\n\n \n\n#include <asm/unaligned.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/usb/input.h>\n\n#include <media/rc-core.h>\n\nstatic const u8 COMMAND_VERSION[] = { 'v' };\n\nstatic const u8 COMMAND_RESET[] = { 0xff, 0xff, 0, 0, 0, 0, 0 };\nstatic const u8 COMMAND_SMODE_ENTER[] = { 's' };\nstatic const u8 COMMAND_SMODE_EXIT[] = { 0 };\nstatic const u8 COMMAND_TXSTART[] = { 0x26, 0x24, 0x25, 0x03 };\n\n#define REPLY_XMITCOUNT 't'\n#define REPLY_XMITSUCCESS 'C'\n#define REPLY_VERSION 'V'\n#define REPLY_SAMPLEMODEPROTO 'S'\n\n#define TIMEOUT 500\n\n#define LEN_XMITRES 3\n#define LEN_VERSION 4\n#define LEN_SAMPLEMODEPROTO 3\n\n#define MIN_FW_VERSION 20\n#define UNIT_US 21\n#define MAX_TIMEOUT_US (UNIT_US * U16_MAX)\n\n#define MAX_PACKET 64\n\nenum state {\n\tSTATE_IRDATA,\n\tSTATE_COMMAND_NO_RESP,\n\tSTATE_COMMAND,\n\tSTATE_TX,\n};\n\nstruct irtoy {\n\tstruct device *dev;\n\tstruct usb_device *usbdev;\n\n\tstruct rc_dev *rc;\n\tstruct urb *urb_in, *urb_out;\n\n\tu8 *in;\n\tu8 *out;\n\tstruct completion command_done;\n\n\tbool pulse;\n\tenum state state;\n\n\tvoid *tx_buf;\n\tuint tx_len;\n\n\tuint emitted;\n\tuint hw_version;\n\tuint sw_version;\n\tuint proto_version;\n\n\tchar phys[64];\n};\n\nstatic void irtoy_response(struct irtoy *irtoy, u32 len)\n{\n\tswitch (irtoy->state) {\n\tcase STATE_COMMAND:\n\t\tif (len == LEN_VERSION && irtoy->in[0] == REPLY_VERSION) {\n\t\t\tuint version;\n\n\t\t\tirtoy->in[LEN_VERSION] = 0;\n\n\t\t\tif (kstrtouint(irtoy->in + 1, 10, &version)) {\n\t\t\t\tdev_err(irtoy->dev, \"invalid version %*phN. Please make sure you are using firmware v20 or higher\",\n\t\t\t\t\tLEN_VERSION, irtoy->in);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev_dbg(irtoy->dev, \"version %s\\n\", irtoy->in);\n\n\t\t\tirtoy->hw_version = version / 100;\n\t\t\tirtoy->sw_version = version % 100;\n\n\t\t\tirtoy->state = STATE_IRDATA;\n\t\t\tcomplete(&irtoy->command_done);\n\t\t} else if (len == LEN_SAMPLEMODEPROTO &&\n\t\t\t   irtoy->in[0] == REPLY_SAMPLEMODEPROTO) {\n\t\t\tuint version;\n\n\t\t\tirtoy->in[LEN_SAMPLEMODEPROTO] = 0;\n\n\t\t\tif (kstrtouint(irtoy->in + 1, 10, &version)) {\n\t\t\t\tdev_err(irtoy->dev, \"invalid sample mode response %*phN\",\n\t\t\t\t\tLEN_SAMPLEMODEPROTO, irtoy->in);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdev_dbg(irtoy->dev, \"protocol %s\\n\", irtoy->in);\n\n\t\t\tirtoy->proto_version = version;\n\n\t\t\tirtoy->state = STATE_IRDATA;\n\t\t\tcomplete(&irtoy->command_done);\n\t\t} else {\n\t\t\tdev_err(irtoy->dev, \"unexpected response to command: %*phN\\n\",\n\t\t\t\tlen, irtoy->in);\n\t\t}\n\t\tbreak;\n\tcase STATE_COMMAND_NO_RESP:\n\tcase STATE_IRDATA: {\n\t\tstruct ir_raw_event rawir = { .pulse = irtoy->pulse };\n\t\t__be16 *in = (__be16 *)irtoy->in;\n\t\tint i;\n\n\t\tfor (i = 0; i < len / sizeof(__be16); i++) {\n\t\t\tu16 v = be16_to_cpu(in[i]);\n\n\t\t\tif (v == 0xffff) {\n\t\t\t\trawir.pulse = false;\n\t\t\t} else {\n\t\t\t\trawir.duration = v * UNIT_US;\n\t\t\t\tir_raw_event_store_with_timeout(irtoy->rc,\n\t\t\t\t\t\t\t\t&rawir);\n\t\t\t}\n\n\t\t\trawir.pulse = !rawir.pulse;\n\t\t}\n\n\t\tirtoy->pulse = rawir.pulse;\n\n\t\tir_raw_event_handle(irtoy->rc);\n\t\tbreak;\n\t}\n\tcase STATE_TX:\n\t\tif (irtoy->tx_len == 0) {\n\t\t\tif (len == LEN_XMITRES &&\n\t\t\t    irtoy->in[0] == REPLY_XMITCOUNT) {\n\t\t\t\tu16 emitted = get_unaligned_be16(irtoy->in + 1);\n\n\t\t\t\tdev_dbg(irtoy->dev, \"emitted:%u\\n\", emitted);\n\n\t\t\t\tirtoy->emitted = emitted;\n\t\t\t} else if (len == 1 &&\n\t\t\t\t   irtoy->in[0] == REPLY_XMITSUCCESS) {\n\t\t\t\tirtoy->state = STATE_IRDATA;\n\t\t\t\tcomplete(&irtoy->command_done);\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tuint space = irtoy->in[0];\n\t\t\tuint buf_len;\n\t\t\tint err;\n\n\t\t\tif (len != 1 || space > MAX_PACKET || space == 0) {\n\t\t\t\tdev_dbg(irtoy->dev, \"packet length expected: %*phN\\n\",\n\t\t\t\t\tlen, irtoy->in);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbuf_len = min(space, irtoy->tx_len);\n\n\t\t\tdev_dbg(irtoy->dev, \"remaining:%u sending:%u\\n\",\n\t\t\t\tirtoy->tx_len, buf_len);\n\n\t\t\tmemcpy(irtoy->out, irtoy->tx_buf, buf_len);\n\t\t\tirtoy->urb_out->transfer_buffer_length = buf_len;\n\t\t\terr = usb_submit_urb(irtoy->urb_out, GFP_ATOMIC);\n\t\t\tif (err != 0) {\n\t\t\t\tdev_err(irtoy->dev, \"fail to submit tx buf urb: %d\\n\",\n\t\t\t\t\terr);\n\t\t\t\tirtoy->state = STATE_IRDATA;\n\t\t\t\tcomplete(&irtoy->command_done);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tirtoy->tx_buf += buf_len;\n\t\t\tirtoy->tx_len -= buf_len;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void irtoy_out_callback(struct urb *urb)\n{\n\tstruct irtoy *irtoy = urb->context;\n\n\tif (urb->status == 0) {\n\t\tif (irtoy->state == STATE_COMMAND_NO_RESP)\n\t\t\tcomplete(&irtoy->command_done);\n\t} else {\n\t\tdev_warn(irtoy->dev, \"out urb status: %d\\n\", urb->status);\n\t}\n}\n\nstatic void irtoy_in_callback(struct urb *urb)\n{\n\tstruct irtoy *irtoy = urb->context;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tirtoy_response(irtoy, urb->actual_length);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EPROTO:\n\tcase -EPIPE:\n\t\tusb_unlink_urb(urb);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(irtoy->dev, \"in urb status: %d\\n\", urb->status);\n\t}\n\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret && ret != -ENODEV)\n\t\tdev_warn(irtoy->dev, \"failed to resubmit urb: %d\\n\", ret);\n}\n\nstatic int irtoy_command(struct irtoy *irtoy, const u8 *cmd, int cmd_len,\n\t\t\t enum state state)\n{\n\tint err;\n\n\tinit_completion(&irtoy->command_done);\n\n\tirtoy->state = state;\n\n\tmemcpy(irtoy->out, cmd, cmd_len);\n\tirtoy->urb_out->transfer_buffer_length = cmd_len;\n\n\terr = usb_submit_urb(irtoy->urb_out, GFP_KERNEL);\n\tif (err != 0)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&irtoy->command_done,\n\t\t\t\t\t msecs_to_jiffies(TIMEOUT))) {\n\t\tusb_kill_urb(irtoy->urb_out);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int irtoy_setup(struct irtoy *irtoy)\n{\n\tint err;\n\n\terr = irtoy_command(irtoy, COMMAND_RESET, sizeof(COMMAND_RESET),\n\t\t\t    STATE_COMMAND_NO_RESP);\n\tif (err != 0) {\n\t\tdev_err(irtoy->dev, \"could not write reset command: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tusleep_range(50, 50);\n\n\t\n\terr = irtoy_command(irtoy, COMMAND_VERSION, sizeof(COMMAND_VERSION),\n\t\t\t    STATE_COMMAND);\n\tif (err) {\n\t\tdev_err(irtoy->dev, \"could not write version command: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t\n\terr = irtoy_command(irtoy, COMMAND_SMODE_ENTER,\n\t\t\t    sizeof(COMMAND_SMODE_ENTER), STATE_COMMAND);\n\tif (err)\n\t\tdev_err(irtoy->dev, \"could not write sample command: %d\\n\",\n\t\t\terr);\n\n\treturn err;\n}\n\n \nstatic int irtoy_tx(struct rc_dev *rc, uint *txbuf, uint count)\n{\n\tstruct irtoy *irtoy = rc->priv;\n\tunsigned int i, size;\n\t__be16 *buf;\n\tint err;\n\n\tsize = sizeof(u16) * (count + 1);\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu16 v = DIV_ROUND_CLOSEST(txbuf[i], UNIT_US);\n\n\t\tif (!v)\n\t\t\tv = 1;\n\t\tbuf[i] = cpu_to_be16(v);\n\t}\n\n\tbuf[count] = cpu_to_be16(0xffff);\n\n\tirtoy->tx_buf = buf;\n\tirtoy->tx_len = size;\n\tirtoy->emitted = 0;\n\n\t\n\t\n\t\n\t\n\terr = irtoy_command(irtoy, COMMAND_SMODE_EXIT,\n\t\t\t    sizeof(COMMAND_SMODE_EXIT), STATE_COMMAND_NO_RESP);\n\tif (err) {\n\t\tdev_err(irtoy->dev, \"exit sample mode: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = irtoy_command(irtoy, COMMAND_SMODE_ENTER,\n\t\t\t    sizeof(COMMAND_SMODE_ENTER), STATE_COMMAND);\n\tif (err) {\n\t\tdev_err(irtoy->dev, \"enter sample mode: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = irtoy_command(irtoy, COMMAND_TXSTART, sizeof(COMMAND_TXSTART),\n\t\t\t    STATE_TX);\n\tkfree(buf);\n\n\tif (err) {\n\t\tdev_err(irtoy->dev, \"failed to send tx start command: %d\\n\",\n\t\t\terr);\n\t\t\n\t\tirtoy_setup(irtoy);\n\t\treturn err;\n\t}\n\n\tif (size != irtoy->emitted) {\n\t\tdev_err(irtoy->dev, \"expected %u emitted, got %u\\n\", size,\n\t\t\tirtoy->emitted);\n\t\t\n\t\tirtoy_setup(irtoy);\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic int irtoy_tx_carrier(struct rc_dev *rc, uint32_t carrier)\n{\n\tstruct irtoy *irtoy = rc->priv;\n\tu8 buf[3];\n\tint err;\n\n\tif (carrier < 11800)\n\t\treturn -EINVAL;\n\n\tbuf[0] = 0x06;\n\tbuf[1] = DIV_ROUND_CLOSEST(48000000, 16 * carrier) - 1;\n\tbuf[2] = 0;\n\n\terr = irtoy_command(irtoy, buf, sizeof(buf), STATE_COMMAND_NO_RESP);\n\tif (err)\n\t\tdev_err(irtoy->dev, \"could not write carrier command: %d\\n\",\n\t\t\terr);\n\n\treturn err;\n}\n\nstatic int irtoy_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *idesc = intf->cur_altsetting;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *ep_in = NULL;\n\tstruct usb_endpoint_descriptor *ep_out = NULL;\n\tstruct usb_endpoint_descriptor *ep = NULL;\n\tstruct irtoy *irtoy;\n\tstruct rc_dev *rc;\n\tstruct urb *urb;\n\tint i, pipe, err = -ENOMEM;\n\n\tfor (i = 0; i < idesc->desc.bNumEndpoints; i++) {\n\t\tep = &idesc->endpoint[i].desc;\n\n\t\tif (!ep_in && usb_endpoint_is_bulk_in(ep) &&\n\t\t    usb_endpoint_maxp(ep) == MAX_PACKET)\n\t\t\tep_in = ep;\n\n\t\tif (!ep_out && usb_endpoint_is_bulk_out(ep) &&\n\t\t    usb_endpoint_maxp(ep) == MAX_PACKET)\n\t\t\tep_out = ep;\n\t}\n\n\tif (!ep_in || !ep_out) {\n\t\tdev_err(&intf->dev, \"required endpoints not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirtoy = kzalloc(sizeof(*irtoy), GFP_KERNEL);\n\tif (!irtoy)\n\t\treturn -ENOMEM;\n\n\tirtoy->in = kmalloc(MAX_PACKET,  GFP_KERNEL);\n\tif (!irtoy->in)\n\t\tgoto free_irtoy;\n\n\tirtoy->out = kmalloc(MAX_PACKET,  GFP_KERNEL);\n\tif (!irtoy->out)\n\t\tgoto free_irtoy;\n\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc)\n\t\tgoto free_irtoy;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\tgoto free_rcdev;\n\n\tpipe = usb_rcvbulkpipe(usbdev, ep_in->bEndpointAddress);\n\tusb_fill_bulk_urb(urb, usbdev, pipe, irtoy->in, MAX_PACKET,\n\t\t\t  irtoy_in_callback, irtoy);\n\tirtoy->urb_in = urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\tgoto free_rcdev;\n\n\tpipe = usb_sndbulkpipe(usbdev, ep_out->bEndpointAddress);\n\tusb_fill_bulk_urb(urb, usbdev, pipe, irtoy->out, MAX_PACKET,\n\t\t\t  irtoy_out_callback, irtoy);\n\n\tirtoy->dev = &intf->dev;\n\tirtoy->usbdev = usbdev;\n\tirtoy->rc = rc;\n\tirtoy->urb_out = urb;\n\tirtoy->pulse = true;\n\n\terr = usb_submit_urb(irtoy->urb_in, GFP_KERNEL);\n\tif (err != 0) {\n\t\tdev_err(irtoy->dev, \"fail to submit in urb: %d\\n\", err);\n\t\tgoto free_rcdev;\n\t}\n\n\terr = irtoy_setup(irtoy);\n\tif (err)\n\t\tgoto free_rcdev;\n\n\tdev_info(irtoy->dev, \"version: hardware %u, firmware %u.%u, protocol %u\",\n\t\t irtoy->hw_version, irtoy->sw_version / 10,\n\t\t irtoy->sw_version % 10, irtoy->proto_version);\n\n\tif (irtoy->sw_version < MIN_FW_VERSION) {\n\t\tdev_err(irtoy->dev, \"need firmware V%02u or higher\",\n\t\t\tMIN_FW_VERSION);\n\t\terr = -ENODEV;\n\t\tgoto free_rcdev;\n\t}\n\n\tusb_make_path(usbdev, irtoy->phys, sizeof(irtoy->phys));\n\n\trc->device_name = \"Infrared Toy\";\n\trc->driver_name = KBUILD_MODNAME;\n\trc->input_phys = irtoy->phys;\n\tusb_to_input_id(usbdev, &rc->input_id);\n\trc->dev.parent = &intf->dev;\n\trc->priv = irtoy;\n\trc->tx_ir = irtoy_tx;\n\trc->s_tx_carrier = irtoy_tx_carrier;\n\trc->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->map_name = RC_MAP_RC6_MCE;\n\trc->rx_resolution = UNIT_US;\n\trc->timeout = IR_DEFAULT_TIMEOUT;\n\n\t \n\trc->min_timeout = MS_TO_US(40);\n\trc->max_timeout = MAX_TIMEOUT_US;\n\n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto free_rcdev;\n\n\tusb_set_intfdata(intf, irtoy);\n\n\treturn 0;\n\nfree_rcdev:\n\tusb_kill_urb(irtoy->urb_out);\n\tusb_free_urb(irtoy->urb_out);\n\tusb_kill_urb(irtoy->urb_in);\n\tusb_free_urb(irtoy->urb_in);\n\trc_free_device(rc);\nfree_irtoy:\n\tkfree(irtoy->in);\n\tkfree(irtoy->out);\n\tkfree(irtoy);\n\treturn err;\n}\n\nstatic void irtoy_disconnect(struct usb_interface *intf)\n{\n\tstruct irtoy *ir = usb_get_intfdata(intf);\n\n\trc_unregister_device(ir->rc);\n\tusb_set_intfdata(intf, NULL);\n\tusb_kill_urb(ir->urb_out);\n\tusb_free_urb(ir->urb_out);\n\tusb_kill_urb(ir->urb_in);\n\tusb_free_urb(ir->urb_in);\n\tkfree(ir->in);\n\tkfree(ir->out);\n\tkfree(ir);\n}\n\nstatic const struct usb_device_id irtoy_table[] = {\n\t{ USB_DEVICE_INTERFACE_CLASS(0x04d8, 0xfd08, USB_CLASS_CDC_DATA) },\n\t{ USB_DEVICE_INTERFACE_CLASS(0x04d8, 0xf58b, USB_CLASS_CDC_DATA) },\n\t{ }\n};\n\nstatic struct usb_driver irtoy_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = irtoy_probe,\n\t.disconnect = irtoy_disconnect,\n\t.id_table = irtoy_table,\n};\n\nmodule_usb_driver(irtoy_driver);\n\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_DESCRIPTION(\"Infrared Toy and IR Droid driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, irtoy_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}