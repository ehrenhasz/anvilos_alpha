{
  "module_name": "rc-main.c",
  "hash_id": "bd16c556556f03dd30070a590177e780ae11e7b587365a3869439b64d461bc92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/rc/rc-main.c",
  "human_readable_source": "\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/rc-core.h>\n#include <linux/bsearch.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include \"rc-core-priv.h\"\n\n \n#define IR_TAB_MIN_SIZE\t256\n#define IR_TAB_MAX_SIZE\t8192\n\nstatic const struct {\n\tconst char *name;\n\tunsigned int repeat_period;\n\tunsigned int scancode_bits;\n} protocols[] = {\n\t[RC_PROTO_UNKNOWN] = { .name = \"unknown\", .repeat_period = 125 },\n\t[RC_PROTO_OTHER] = { .name = \"other\", .repeat_period = 125 },\n\t[RC_PROTO_RC5] = { .name = \"rc-5\",\n\t\t.scancode_bits = 0x1f7f, .repeat_period = 114 },\n\t[RC_PROTO_RC5X_20] = { .name = \"rc-5x-20\",\n\t\t.scancode_bits = 0x1f7f3f, .repeat_period = 114 },\n\t[RC_PROTO_RC5_SZ] = { .name = \"rc-5-sz\",\n\t\t.scancode_bits = 0x2fff, .repeat_period = 114 },\n\t[RC_PROTO_JVC] = { .name = \"jvc\",\n\t\t.scancode_bits = 0xffff, .repeat_period = 125 },\n\t[RC_PROTO_SONY12] = { .name = \"sony-12\",\n\t\t.scancode_bits = 0x1f007f, .repeat_period = 100 },\n\t[RC_PROTO_SONY15] = { .name = \"sony-15\",\n\t\t.scancode_bits = 0xff007f, .repeat_period = 100 },\n\t[RC_PROTO_SONY20] = { .name = \"sony-20\",\n\t\t.scancode_bits = 0x1fff7f, .repeat_period = 100 },\n\t[RC_PROTO_NEC] = { .name = \"nec\",\n\t\t.scancode_bits = 0xffff, .repeat_period = 110 },\n\t[RC_PROTO_NECX] = { .name = \"nec-x\",\n\t\t.scancode_bits = 0xffffff, .repeat_period = 110 },\n\t[RC_PROTO_NEC32] = { .name = \"nec-32\",\n\t\t.scancode_bits = 0xffffffff, .repeat_period = 110 },\n\t[RC_PROTO_SANYO] = { .name = \"sanyo\",\n\t\t.scancode_bits = 0x1fffff, .repeat_period = 125 },\n\t[RC_PROTO_MCIR2_KBD] = { .name = \"mcir2-kbd\",\n\t\t.scancode_bits = 0xffffff, .repeat_period = 100 },\n\t[RC_PROTO_MCIR2_MSE] = { .name = \"mcir2-mse\",\n\t\t.scancode_bits = 0x1fffff, .repeat_period = 100 },\n\t[RC_PROTO_RC6_0] = { .name = \"rc-6-0\",\n\t\t.scancode_bits = 0xffff, .repeat_period = 114 },\n\t[RC_PROTO_RC6_6A_20] = { .name = \"rc-6-6a-20\",\n\t\t.scancode_bits = 0xfffff, .repeat_period = 114 },\n\t[RC_PROTO_RC6_6A_24] = { .name = \"rc-6-6a-24\",\n\t\t.scancode_bits = 0xffffff, .repeat_period = 114 },\n\t[RC_PROTO_RC6_6A_32] = { .name = \"rc-6-6a-32\",\n\t\t.scancode_bits = 0xffffffff, .repeat_period = 114 },\n\t[RC_PROTO_RC6_MCE] = { .name = \"rc-6-mce\",\n\t\t.scancode_bits = 0xffff7fff, .repeat_period = 114 },\n\t[RC_PROTO_SHARP] = { .name = \"sharp\",\n\t\t.scancode_bits = 0x1fff, .repeat_period = 125 },\n\t[RC_PROTO_XMP] = { .name = \"xmp\", .repeat_period = 125 },\n\t[RC_PROTO_CEC] = { .name = \"cec\", .repeat_period = 0 },\n\t[RC_PROTO_IMON] = { .name = \"imon\",\n\t\t.scancode_bits = 0x7fffffff, .repeat_period = 114 },\n\t[RC_PROTO_RCMM12] = { .name = \"rc-mm-12\",\n\t\t.scancode_bits = 0x00000fff, .repeat_period = 114 },\n\t[RC_PROTO_RCMM24] = { .name = \"rc-mm-24\",\n\t\t.scancode_bits = 0x00ffffff, .repeat_period = 114 },\n\t[RC_PROTO_RCMM32] = { .name = \"rc-mm-32\",\n\t\t.scancode_bits = 0xffffffff, .repeat_period = 114 },\n\t[RC_PROTO_XBOX_DVD] = { .name = \"xbox-dvd\", .repeat_period = 64 },\n};\n\n \nstatic LIST_HEAD(rc_map_list);\nstatic DEFINE_SPINLOCK(rc_map_lock);\nstatic struct led_trigger *led_feedback;\n\n \nstatic DEFINE_IDA(rc_ida);\n\nstatic struct rc_map_list *seek_rc_map(const char *name)\n{\n\tstruct rc_map_list *map = NULL;\n\n\tspin_lock(&rc_map_lock);\n\tlist_for_each_entry(map, &rc_map_list, list) {\n\t\tif (!strcmp(name, map->map.name)) {\n\t\t\tspin_unlock(&rc_map_lock);\n\t\t\treturn map;\n\t\t}\n\t}\n\tspin_unlock(&rc_map_lock);\n\n\treturn NULL;\n}\n\nstruct rc_map *rc_map_get(const char *name)\n{\n\n\tstruct rc_map_list *map;\n\n\tmap = seek_rc_map(name);\n#ifdef CONFIG_MODULES\n\tif (!map) {\n\t\tint rc = request_module(\"%s\", name);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"Couldn't load IR keymap %s\\n\", name);\n\t\t\treturn NULL;\n\t\t}\n\t\tmsleep(20);\t \n\n\t\tmap = seek_rc_map(name);\n\t}\n#endif\n\tif (!map) {\n\t\tpr_err(\"IR keymap %s not found\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tprintk(KERN_INFO \"Registered IR keymap %s\\n\", map->map.name);\n\n\treturn &map->map;\n}\nEXPORT_SYMBOL_GPL(rc_map_get);\n\nint rc_map_register(struct rc_map_list *map)\n{\n\tspin_lock(&rc_map_lock);\n\tlist_add_tail(&map->list, &rc_map_list);\n\tspin_unlock(&rc_map_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rc_map_register);\n\nvoid rc_map_unregister(struct rc_map_list *map)\n{\n\tspin_lock(&rc_map_lock);\n\tlist_del(&map->list);\n\tspin_unlock(&rc_map_lock);\n}\nEXPORT_SYMBOL_GPL(rc_map_unregister);\n\n\nstatic struct rc_map_table empty[] = {\n\t{ 0x2a, KEY_COFFEE },\n};\n\nstatic struct rc_map_list empty_map = {\n\t.map = {\n\t\t.scan     = empty,\n\t\t.size     = ARRAY_SIZE(empty),\n\t\t.rc_proto = RC_PROTO_UNKNOWN,\t \n\t\t.name     = RC_MAP_EMPTY,\n\t}\n};\n\n \nstatic int scancode_to_u64(const struct input_keymap_entry *ke, u64 *scancode)\n{\n\tswitch (ke->len) {\n\tcase 1:\n\t\t*scancode = *((u8 *)ke->scancode);\n\t\tbreak;\n\n\tcase 2:\n\t\t*scancode = *((u16 *)ke->scancode);\n\t\tbreak;\n\n\tcase 4:\n\t\t*scancode = *((u32 *)ke->scancode);\n\t\tbreak;\n\n\tcase 8:\n\t\t*scancode = *((u64 *)ke->scancode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ir_create_table(struct rc_dev *dev, struct rc_map *rc_map,\n\t\t\t   const char *name, u64 rc_proto, size_t size)\n{\n\trc_map->name = kstrdup(name, GFP_KERNEL);\n\tif (!rc_map->name)\n\t\treturn -ENOMEM;\n\trc_map->rc_proto = rc_proto;\n\trc_map->alloc = roundup_pow_of_two(size * sizeof(struct rc_map_table));\n\trc_map->size = rc_map->alloc / sizeof(struct rc_map_table);\n\trc_map->scan = kmalloc(rc_map->alloc, GFP_KERNEL);\n\tif (!rc_map->scan) {\n\t\tkfree(rc_map->name);\n\t\trc_map->name = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(&dev->dev, \"Allocated space for %u keycode entries (%u bytes)\\n\",\n\t\trc_map->size, rc_map->alloc);\n\treturn 0;\n}\n\n \nstatic void ir_free_table(struct rc_map *rc_map)\n{\n\trc_map->size = 0;\n\tkfree(rc_map->name);\n\trc_map->name = NULL;\n\tkfree(rc_map->scan);\n\trc_map->scan = NULL;\n}\n\n \nstatic int ir_resize_table(struct rc_dev *dev, struct rc_map *rc_map,\n\t\t\t   gfp_t gfp_flags)\n{\n\tunsigned int oldalloc = rc_map->alloc;\n\tunsigned int newalloc = oldalloc;\n\tstruct rc_map_table *oldscan = rc_map->scan;\n\tstruct rc_map_table *newscan;\n\n\tif (rc_map->size == rc_map->len) {\n\t\t \n\t\tif (rc_map->alloc >= IR_TAB_MAX_SIZE)\n\t\t\treturn -ENOMEM;\n\n\t\tnewalloc *= 2;\n\t\tdev_dbg(&dev->dev, \"Growing table to %u bytes\\n\", newalloc);\n\t}\n\n\tif ((rc_map->len * 3 < rc_map->size) && (oldalloc > IR_TAB_MIN_SIZE)) {\n\t\t \n\t\tnewalloc /= 2;\n\t\tdev_dbg(&dev->dev, \"Shrinking table to %u bytes\\n\", newalloc);\n\t}\n\n\tif (newalloc == oldalloc)\n\t\treturn 0;\n\n\tnewscan = kmalloc(newalloc, gfp_flags);\n\tif (!newscan)\n\t\treturn -ENOMEM;\n\n\tmemcpy(newscan, rc_map->scan, rc_map->len * sizeof(struct rc_map_table));\n\trc_map->scan = newscan;\n\trc_map->alloc = newalloc;\n\trc_map->size = rc_map->alloc / sizeof(struct rc_map_table);\n\tkfree(oldscan);\n\treturn 0;\n}\n\n \nstatic unsigned int ir_update_mapping(struct rc_dev *dev,\n\t\t\t\t      struct rc_map *rc_map,\n\t\t\t\t      unsigned int index,\n\t\t\t\t      unsigned int new_keycode)\n{\n\tint old_keycode = rc_map->scan[index].keycode;\n\tint i;\n\n\t \n\tif (new_keycode == KEY_RESERVED || new_keycode == KEY_UNKNOWN) {\n\t\tdev_dbg(&dev->dev, \"#%d: Deleting scan 0x%04llx\\n\",\n\t\t\tindex, rc_map->scan[index].scancode);\n\t\trc_map->len--;\n\t\tmemmove(&rc_map->scan[index], &rc_map->scan[index+ 1],\n\t\t\t(rc_map->len - index) * sizeof(struct rc_map_table));\n\t} else {\n\t\tdev_dbg(&dev->dev, \"#%d: %s scan 0x%04llx with key 0x%04x\\n\",\n\t\t\tindex,\n\t\t\told_keycode == KEY_RESERVED ? \"New\" : \"Replacing\",\n\t\t\trc_map->scan[index].scancode, new_keycode);\n\t\trc_map->scan[index].keycode = new_keycode;\n\t\t__set_bit(new_keycode, dev->input_dev->keybit);\n\t}\n\n\tif (old_keycode != KEY_RESERVED) {\n\t\t \n\t\t__clear_bit(old_keycode, dev->input_dev->keybit);\n\t\t \n\t\tfor (i = 0; i < rc_map->len; i++) {\n\t\t\tif (rc_map->scan[i].keycode == old_keycode) {\n\t\t\t\t__set_bit(old_keycode, dev->input_dev->keybit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tir_resize_table(dev, rc_map, GFP_ATOMIC);\n\t}\n\n\treturn old_keycode;\n}\n\n \nstatic unsigned int ir_establish_scancode(struct rc_dev *dev,\n\t\t\t\t\t  struct rc_map *rc_map,\n\t\t\t\t\t  u64 scancode, bool resize)\n{\n\tunsigned int i;\n\n\t \n\tif (dev->scancode_mask)\n\t\tscancode &= dev->scancode_mask;\n\n\t \n\tfor (i = 0; i < rc_map->len; i++) {\n\t\tif (rc_map->scan[i].scancode == scancode)\n\t\t\treturn i;\n\n\t\t \n\t\tif (rc_map->scan[i].scancode >= scancode)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (rc_map->size == rc_map->len) {\n\t\tif (!resize || ir_resize_table(dev, rc_map, GFP_ATOMIC))\n\t\t\treturn -1U;\n\t}\n\n\t \n\tif (i < rc_map->len)\n\t\tmemmove(&rc_map->scan[i + 1], &rc_map->scan[i],\n\t\t\t(rc_map->len - i) * sizeof(struct rc_map_table));\n\trc_map->scan[i].scancode = scancode;\n\trc_map->scan[i].keycode = KEY_RESERVED;\n\trc_map->len++;\n\n\treturn i;\n}\n\n \nstatic int ir_setkeycode(struct input_dev *idev,\n\t\t\t const struct input_keymap_entry *ke,\n\t\t\t unsigned int *old_keycode)\n{\n\tstruct rc_dev *rdev = input_get_drvdata(idev);\n\tstruct rc_map *rc_map = &rdev->rc_map;\n\tunsigned int index;\n\tu64 scancode;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rc_map->lock, flags);\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t\tif (index >= rc_map->len) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tretval = scancode_to_u64(ke, &scancode);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tindex = ir_establish_scancode(rdev, rc_map, scancode, true);\n\t\tif (index >= rc_map->len) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*old_keycode = ir_update_mapping(rdev, rc_map, index, ke->keycode);\n\nout:\n\tspin_unlock_irqrestore(&rc_map->lock, flags);\n\treturn retval;\n}\n\n \nstatic int ir_setkeytable(struct rc_dev *dev, const struct rc_map *from)\n{\n\tstruct rc_map *rc_map = &dev->rc_map;\n\tunsigned int i, index;\n\tint rc;\n\n\trc = ir_create_table(dev, rc_map, from->name, from->rc_proto,\n\t\t\t     from->size);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < from->size; i++) {\n\t\tindex = ir_establish_scancode(dev, rc_map,\n\t\t\t\t\t      from->scan[i].scancode, false);\n\t\tif (index >= rc_map->len) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tir_update_mapping(dev, rc_map, index,\n\t\t\t\t  from->scan[i].keycode);\n\t}\n\n\tif (rc)\n\t\tir_free_table(rc_map);\n\n\treturn rc;\n}\n\nstatic int rc_map_cmp(const void *key, const void *elt)\n{\n\tconst u64 *scancode = key;\n\tconst struct rc_map_table *e = elt;\n\n\tif (*scancode < e->scancode)\n\t\treturn -1;\n\telse if (*scancode > e->scancode)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic unsigned int ir_lookup_by_scancode(const struct rc_map *rc_map,\n\t\t\t\t\t  u64 scancode)\n{\n\tstruct rc_map_table *res;\n\n\tres = bsearch(&scancode, rc_map->scan, rc_map->len,\n\t\t      sizeof(struct rc_map_table), rc_map_cmp);\n\tif (!res)\n\t\treturn -1U;\n\telse\n\t\treturn res - rc_map->scan;\n}\n\n \nstatic int ir_getkeycode(struct input_dev *idev,\n\t\t\t struct input_keymap_entry *ke)\n{\n\tstruct rc_dev *rdev = input_get_drvdata(idev);\n\tstruct rc_map *rc_map = &rdev->rc_map;\n\tstruct rc_map_table *entry;\n\tunsigned long flags;\n\tunsigned int index;\n\tu64 scancode;\n\tint retval;\n\n\tspin_lock_irqsave(&rc_map->lock, flags);\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\tretval = scancode_to_u64(ke, &scancode);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tindex = ir_lookup_by_scancode(rc_map, scancode);\n\t}\n\n\tif (index < rc_map->len) {\n\t\tentry = &rc_map->scan[index];\n\n\t\tke->index = index;\n\t\tke->keycode = entry->keycode;\n\t\tke->len = sizeof(entry->scancode);\n\t\tmemcpy(ke->scancode, &entry->scancode, sizeof(entry->scancode));\n\t} else if (!(ke->flags & INPUT_KEYMAP_BY_INDEX)) {\n\t\t \n\t\tke->index = index;\n\t\tke->keycode = KEY_RESERVED;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\tspin_unlock_irqrestore(&rc_map->lock, flags);\n\treturn retval;\n}\n\n \nu32 rc_g_keycode_from_table(struct rc_dev *dev, u64 scancode)\n{\n\tstruct rc_map *rc_map = &dev->rc_map;\n\tunsigned int keycode;\n\tunsigned int index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rc_map->lock, flags);\n\n\tindex = ir_lookup_by_scancode(rc_map, scancode);\n\tkeycode = index < rc_map->len ?\n\t\t\trc_map->scan[index].keycode : KEY_RESERVED;\n\n\tspin_unlock_irqrestore(&rc_map->lock, flags);\n\n\tif (keycode != KEY_RESERVED)\n\t\tdev_dbg(&dev->dev, \"%s: scancode 0x%04llx keycode 0x%02x\\n\",\n\t\t\tdev->device_name, scancode, keycode);\n\n\treturn keycode;\n}\nEXPORT_SYMBOL_GPL(rc_g_keycode_from_table);\n\n \nstatic void ir_do_keyup(struct rc_dev *dev, bool sync)\n{\n\tif (!dev->keypressed)\n\t\treturn;\n\n\tdev_dbg(&dev->dev, \"keyup key 0x%04x\\n\", dev->last_keycode);\n\tdel_timer(&dev->timer_repeat);\n\tinput_report_key(dev->input_dev, dev->last_keycode, 0);\n\tled_trigger_event(led_feedback, LED_OFF);\n\tif (sync)\n\t\tinput_sync(dev->input_dev);\n\tdev->keypressed = false;\n}\n\n \nvoid rc_keyup(struct rc_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->keylock, flags);\n\tir_do_keyup(dev, true);\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\nEXPORT_SYMBOL_GPL(rc_keyup);\n\n \nstatic void ir_timer_keyup(struct timer_list *t)\n{\n\tstruct rc_dev *dev = from_timer(dev, t, timer_keyup);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->keylock, flags);\n\tif (time_is_before_eq_jiffies(dev->keyup_jiffies))\n\t\tir_do_keyup(dev, true);\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\n\n \nstatic void ir_timer_repeat(struct timer_list *t)\n{\n\tstruct rc_dev *dev = from_timer(dev, t, timer_repeat);\n\tstruct input_dev *input = dev->input_dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->keylock, flags);\n\tif (dev->keypressed) {\n\t\tinput_event(input, EV_KEY, dev->last_keycode, 2);\n\t\tinput_sync(input);\n\t\tif (input->rep[REP_PERIOD])\n\t\t\tmod_timer(&dev->timer_repeat, jiffies +\n\t\t\t\t  msecs_to_jiffies(input->rep[REP_PERIOD]));\n\t}\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\n\nstatic unsigned int repeat_period(int protocol)\n{\n\tif (protocol >= ARRAY_SIZE(protocols))\n\t\treturn 100;\n\n\treturn protocols[protocol].repeat_period;\n}\n\n \nvoid rc_repeat(struct rc_dev *dev)\n{\n\tunsigned long flags;\n\tunsigned int timeout = usecs_to_jiffies(dev->timeout) +\n\t\tmsecs_to_jiffies(repeat_period(dev->last_protocol));\n\tstruct lirc_scancode sc = {\n\t\t.scancode = dev->last_scancode, .rc_proto = dev->last_protocol,\n\t\t.keycode = dev->keypressed ? dev->last_keycode : KEY_RESERVED,\n\t\t.flags = LIRC_SCANCODE_FLAG_REPEAT |\n\t\t\t (dev->last_toggle ? LIRC_SCANCODE_FLAG_TOGGLE : 0)\n\t};\n\n\tif (dev->allowed_protocols != RC_PROTO_BIT_CEC)\n\t\tlirc_scancode_event(dev, &sc);\n\n\tspin_lock_irqsave(&dev->keylock, flags);\n\n\tif (dev->last_scancode <= U32_MAX) {\n\t\tinput_event(dev->input_dev, EV_MSC, MSC_SCAN,\n\t\t\t    dev->last_scancode);\n\t\tinput_sync(dev->input_dev);\n\t}\n\n\tif (dev->keypressed) {\n\t\tdev->keyup_jiffies = jiffies + timeout;\n\t\tmod_timer(&dev->timer_keyup, dev->keyup_jiffies);\n\t}\n\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\nEXPORT_SYMBOL_GPL(rc_repeat);\n\n \nstatic void ir_do_keydown(struct rc_dev *dev, enum rc_proto protocol,\n\t\t\t  u64 scancode, u32 keycode, u8 toggle)\n{\n\tbool new_event = (!dev->keypressed\t\t ||\n\t\t\t  dev->last_protocol != protocol ||\n\t\t\t  dev->last_scancode != scancode ||\n\t\t\t  dev->last_toggle   != toggle);\n\tstruct lirc_scancode sc = {\n\t\t.scancode = scancode, .rc_proto = protocol,\n\t\t.flags = (toggle ? LIRC_SCANCODE_FLAG_TOGGLE : 0) |\n\t\t\t (!new_event ? LIRC_SCANCODE_FLAG_REPEAT : 0),\n\t\t.keycode = keycode\n\t};\n\n\tif (dev->allowed_protocols != RC_PROTO_BIT_CEC)\n\t\tlirc_scancode_event(dev, &sc);\n\n\tif (new_event && dev->keypressed)\n\t\tir_do_keyup(dev, false);\n\n\tif (scancode <= U32_MAX)\n\t\tinput_event(dev->input_dev, EV_MSC, MSC_SCAN, scancode);\n\n\tdev->last_protocol = protocol;\n\tdev->last_scancode = scancode;\n\tdev->last_toggle = toggle;\n\tdev->last_keycode = keycode;\n\n\tif (new_event && keycode != KEY_RESERVED) {\n\t\t \n\t\tdev->keypressed = true;\n\n\t\tdev_dbg(&dev->dev, \"%s: key down event, key 0x%04x, protocol 0x%04x, scancode 0x%08llx\\n\",\n\t\t\tdev->device_name, keycode, protocol, scancode);\n\t\tinput_report_key(dev->input_dev, keycode, 1);\n\n\t\tled_trigger_event(led_feedback, LED_FULL);\n\t}\n\n\t \n\tif (!new_event && keycode != KEY_RESERVED &&\n\t    dev->allowed_protocols == RC_PROTO_BIT_CEC &&\n\t    !timer_pending(&dev->timer_repeat) &&\n\t    dev->input_dev->rep[REP_PERIOD] &&\n\t    !dev->input_dev->rep[REP_DELAY]) {\n\t\tinput_event(dev->input_dev, EV_KEY, keycode, 2);\n\t\tmod_timer(&dev->timer_repeat, jiffies +\n\t\t\t  msecs_to_jiffies(dev->input_dev->rep[REP_PERIOD]));\n\t}\n\n\tinput_sync(dev->input_dev);\n}\n\n \nvoid rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u64 scancode,\n\t\tu8 toggle)\n{\n\tunsigned long flags;\n\tu32 keycode = rc_g_keycode_from_table(dev, scancode);\n\n\tspin_lock_irqsave(&dev->keylock, flags);\n\tir_do_keydown(dev, protocol, scancode, keycode, toggle);\n\n\tif (dev->keypressed) {\n\t\tdev->keyup_jiffies = jiffies + usecs_to_jiffies(dev->timeout) +\n\t\t\tmsecs_to_jiffies(repeat_period(protocol));\n\t\tmod_timer(&dev->timer_keyup, dev->keyup_jiffies);\n\t}\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\nEXPORT_SYMBOL_GPL(rc_keydown);\n\n \nvoid rc_keydown_notimeout(struct rc_dev *dev, enum rc_proto protocol,\n\t\t\t  u64 scancode, u8 toggle)\n{\n\tunsigned long flags;\n\tu32 keycode = rc_g_keycode_from_table(dev, scancode);\n\n\tspin_lock_irqsave(&dev->keylock, flags);\n\tir_do_keydown(dev, protocol, scancode, keycode, toggle);\n\tspin_unlock_irqrestore(&dev->keylock, flags);\n}\nEXPORT_SYMBOL_GPL(rc_keydown_notimeout);\n\n \nbool rc_validate_scancode(enum rc_proto proto, u32 scancode)\n{\n\tswitch (proto) {\n\t \n\tcase RC_PROTO_NECX:\n\t\tif ((((scancode >> 16) ^ ~(scancode >> 8)) & 0xff) == 0)\n\t\t\treturn false;\n\t\tbreak;\n\t \n\tcase RC_PROTO_NEC32:\n\t\tif ((((scancode >> 8) ^ ~scancode) & 0xff) == 0)\n\t\t\treturn false;\n\t\tbreak;\n\t \n\tcase RC_PROTO_RC6_MCE:\n\t\tif ((scancode & 0xffff0000) != 0x800f0000)\n\t\t\treturn false;\n\t\tbreak;\n\tcase RC_PROTO_RC6_6A_32:\n\t\tif ((scancode & 0xffff0000) == 0x800f0000)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nstatic int rc_validate_filter(struct rc_dev *dev,\n\t\t\t      struct rc_scancode_filter *filter)\n{\n\tu32 mask, s = filter->data;\n\tenum rc_proto protocol = dev->wakeup_protocol;\n\n\tif (protocol >= ARRAY_SIZE(protocols))\n\t\treturn -EINVAL;\n\n\tmask = protocols[protocol].scancode_bits;\n\n\tif (!rc_validate_scancode(protocol, s))\n\t\treturn -EINVAL;\n\n\tfilter->data &= mask;\n\tfilter->mask &= mask;\n\n\t \n\tif (dev->encode_wakeup && filter->mask != 0 && filter->mask != mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint rc_open(struct rc_dev *rdev)\n{\n\tint rval = 0;\n\n\tif (!rdev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rdev->lock);\n\n\tif (!rdev->registered) {\n\t\trval = -ENODEV;\n\t} else {\n\t\tif (!rdev->users++ && rdev->open)\n\t\t\trval = rdev->open(rdev);\n\n\t\tif (rval)\n\t\t\trdev->users--;\n\t}\n\n\tmutex_unlock(&rdev->lock);\n\n\treturn rval;\n}\n\nstatic int ir_open(struct input_dev *idev)\n{\n\tstruct rc_dev *rdev = input_get_drvdata(idev);\n\n\treturn rc_open(rdev);\n}\n\nvoid rc_close(struct rc_dev *rdev)\n{\n\tif (rdev) {\n\t\tmutex_lock(&rdev->lock);\n\n\t\tif (!--rdev->users && rdev->close && rdev->registered)\n\t\t\trdev->close(rdev);\n\n\t\tmutex_unlock(&rdev->lock);\n\t}\n}\n\nstatic void ir_close(struct input_dev *idev)\n{\n\tstruct rc_dev *rdev = input_get_drvdata(idev);\n\trc_close(rdev);\n}\n\n \nstatic char *rc_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"rc/%s\", dev_name(dev));\n}\n\nstatic struct class rc_class = {\n\t.name\t\t= \"rc\",\n\t.devnode\t= rc_devnode,\n};\n\n \nstatic const struct {\n\tu64\ttype;\n\tconst char\t*name;\n\tconst char\t*module_name;\n} proto_names[] = {\n\t{ RC_PROTO_BIT_NONE,\t\"none\",\t\tNULL\t\t\t},\n\t{ RC_PROTO_BIT_OTHER,\t\"other\",\tNULL\t\t\t},\n\t{ RC_PROTO_BIT_UNKNOWN,\t\"unknown\",\tNULL\t\t\t},\n\t{ RC_PROTO_BIT_RC5 |\n\t  RC_PROTO_BIT_RC5X_20,\t\"rc-5\",\t\t\"ir-rc5-decoder\"\t},\n\t{ RC_PROTO_BIT_NEC |\n\t  RC_PROTO_BIT_NECX |\n\t  RC_PROTO_BIT_NEC32,\t\"nec\",\t\t\"ir-nec-decoder\"\t},\n\t{ RC_PROTO_BIT_RC6_0 |\n\t  RC_PROTO_BIT_RC6_6A_20 |\n\t  RC_PROTO_BIT_RC6_6A_24 |\n\t  RC_PROTO_BIT_RC6_6A_32 |\n\t  RC_PROTO_BIT_RC6_MCE,\t\"rc-6\",\t\t\"ir-rc6-decoder\"\t},\n\t{ RC_PROTO_BIT_JVC,\t\"jvc\",\t\t\"ir-jvc-decoder\"\t},\n\t{ RC_PROTO_BIT_SONY12 |\n\t  RC_PROTO_BIT_SONY15 |\n\t  RC_PROTO_BIT_SONY20,\t\"sony\",\t\t\"ir-sony-decoder\"\t},\n\t{ RC_PROTO_BIT_RC5_SZ,\t\"rc-5-sz\",\t\"ir-rc5-decoder\"\t},\n\t{ RC_PROTO_BIT_SANYO,\t\"sanyo\",\t\"ir-sanyo-decoder\"\t},\n\t{ RC_PROTO_BIT_SHARP,\t\"sharp\",\t\"ir-sharp-decoder\"\t},\n\t{ RC_PROTO_BIT_MCIR2_KBD |\n\t  RC_PROTO_BIT_MCIR2_MSE, \"mce_kbd\",\t\"ir-mce_kbd-decoder\"\t},\n\t{ RC_PROTO_BIT_XMP,\t\"xmp\",\t\t\"ir-xmp-decoder\"\t},\n\t{ RC_PROTO_BIT_CEC,\t\"cec\",\t\tNULL\t\t\t},\n\t{ RC_PROTO_BIT_IMON,\t\"imon\",\t\t\"ir-imon-decoder\"\t},\n\t{ RC_PROTO_BIT_RCMM12 |\n\t  RC_PROTO_BIT_RCMM24 |\n\t  RC_PROTO_BIT_RCMM32,\t\"rc-mm\",\t\"ir-rcmm-decoder\"\t},\n\t{ RC_PROTO_BIT_XBOX_DVD, \"xbox-dvd\",\tNULL\t\t\t},\n};\n\n \nstruct rc_filter_attribute {\n\tstruct device_attribute\t\tattr;\n\tenum rc_filter_type\t\ttype;\n\tbool\t\t\t\tmask;\n};\n#define to_rc_filter_attr(a) container_of(a, struct rc_filter_attribute, attr)\n\n#define RC_FILTER_ATTR(_name, _mode, _show, _store, _type, _mask)\t\\\n\tstruct rc_filter_attribute dev_attr_##_name = {\t\t\t\\\n\t\t.attr = __ATTR(_name, _mode, _show, _store),\t\t\\\n\t\t.type = (_type),\t\t\t\t\t\\\n\t\t.mask = (_mask),\t\t\t\t\t\\\n\t}\n\n \nstatic ssize_t show_protocols(struct device *device,\n\t\t\t      struct device_attribute *mattr, char *buf)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tu64 allowed, enabled;\n\tchar *tmp = buf;\n\tint i;\n\n\tmutex_lock(&dev->lock);\n\n\tenabled = dev->enabled_protocols;\n\tallowed = dev->allowed_protocols;\n\tif (dev->raw && !allowed)\n\t\tallowed = ir_raw_get_allowed_protocols();\n\n\tmutex_unlock(&dev->lock);\n\n\tdev_dbg(&dev->dev, \"%s: allowed - 0x%llx, enabled - 0x%llx\\n\",\n\t\t__func__, (long long)allowed, (long long)enabled);\n\n\tfor (i = 0; i < ARRAY_SIZE(proto_names); i++) {\n\t\tif (allowed & enabled & proto_names[i].type)\n\t\t\ttmp += sprintf(tmp, \"[%s] \", proto_names[i].name);\n\t\telse if (allowed & proto_names[i].type)\n\t\t\ttmp += sprintf(tmp, \"%s \", proto_names[i].name);\n\n\t\tif (allowed & proto_names[i].type)\n\t\t\tallowed &= ~proto_names[i].type;\n\t}\n\n#ifdef CONFIG_LIRC\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\ttmp += sprintf(tmp, \"[lirc] \");\n#endif\n\n\tif (tmp != buf)\n\t\ttmp--;\n\t*tmp = '\\n';\n\n\treturn tmp + 1 - buf;\n}\n\n \nstatic int parse_protocol_change(struct rc_dev *dev, u64 *protocols,\n\t\t\t\t const char *buf)\n{\n\tconst char *tmp;\n\tunsigned count = 0;\n\tbool enable, disable;\n\tu64 mask;\n\tint i;\n\n\twhile ((tmp = strsep((char **)&buf, \" \\n\")) != NULL) {\n\t\tif (!*tmp)\n\t\t\tbreak;\n\n\t\tif (*tmp == '+') {\n\t\t\tenable = true;\n\t\t\tdisable = false;\n\t\t\ttmp++;\n\t\t} else if (*tmp == '-') {\n\t\t\tenable = false;\n\t\t\tdisable = true;\n\t\t\ttmp++;\n\t\t} else {\n\t\t\tenable = false;\n\t\t\tdisable = false;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(proto_names); i++) {\n\t\t\tif (!strcasecmp(tmp, proto_names[i].name)) {\n\t\t\t\tmask = proto_names[i].type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(proto_names)) {\n\t\t\tif (!strcasecmp(tmp, \"lirc\"))\n\t\t\t\tmask = 0;\n\t\t\telse {\n\t\t\t\tdev_dbg(&dev->dev, \"Unknown protocol: '%s'\\n\",\n\t\t\t\t\ttmp);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tcount++;\n\n\t\tif (enable)\n\t\t\t*protocols |= mask;\n\t\telse if (disable)\n\t\t\t*protocols &= ~mask;\n\t\telse\n\t\t\t*protocols = mask;\n\t}\n\n\tif (!count) {\n\t\tdev_dbg(&dev->dev, \"Protocol not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nvoid ir_raw_load_modules(u64 *protocols)\n{\n\tu64 available;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(proto_names); i++) {\n\t\tif (proto_names[i].type == RC_PROTO_BIT_NONE ||\n\t\t    proto_names[i].type & (RC_PROTO_BIT_OTHER |\n\t\t\t\t\t   RC_PROTO_BIT_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tavailable = ir_raw_get_allowed_protocols();\n\t\tif (!(*protocols & proto_names[i].type & ~available))\n\t\t\tcontinue;\n\n\t\tif (!proto_names[i].module_name) {\n\t\t\tpr_err(\"Can't enable IR protocol %s\\n\",\n\t\t\t       proto_names[i].name);\n\t\t\t*protocols &= ~proto_names[i].type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = request_module(\"%s\", proto_names[i].module_name);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Couldn't load IR protocol module %s\\n\",\n\t\t\t       proto_names[i].module_name);\n\t\t\t*protocols &= ~proto_names[i].type;\n\t\t\tcontinue;\n\t\t}\n\t\tmsleep(20);\n\t\tavailable = ir_raw_get_allowed_protocols();\n\t\tif (!(*protocols & proto_names[i].type & ~available))\n\t\t\tcontinue;\n\n\t\tpr_err(\"Loaded IR protocol module %s, but protocol %s still not available\\n\",\n\t\t       proto_names[i].module_name,\n\t\t       proto_names[i].name);\n\t\t*protocols &= ~proto_names[i].type;\n\t}\n}\n\n \nstatic ssize_t store_protocols(struct device *device,\n\t\t\t       struct device_attribute *mattr,\n\t\t\t       const char *buf, size_t len)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tu64 *current_protocols;\n\tstruct rc_scancode_filter *filter;\n\tu64 old_protocols, new_protocols;\n\tssize_t rc;\n\n\tdev_dbg(&dev->dev, \"Normal protocol change requested\\n\");\n\tcurrent_protocols = &dev->enabled_protocols;\n\tfilter = &dev->scancode_filter;\n\n\tif (!dev->change_protocol) {\n\t\tdev_dbg(&dev->dev, \"Protocol switching not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->lock);\n\tif (!dev->registered) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\told_protocols = *current_protocols;\n\tnew_protocols = old_protocols;\n\trc = parse_protocol_change(dev, &new_protocols, buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\tir_raw_load_modules(&new_protocols);\n\n\trc = dev->change_protocol(dev, &new_protocols);\n\tif (rc < 0) {\n\t\tdev_dbg(&dev->dev, \"Error setting protocols to 0x%llx\\n\",\n\t\t\t(long long)new_protocols);\n\t\tgoto out;\n\t}\n\n\tif (new_protocols != old_protocols) {\n\t\t*current_protocols = new_protocols;\n\t\tdev_dbg(&dev->dev, \"Protocols changed to 0x%llx\\n\",\n\t\t\t(long long)new_protocols);\n\t}\n\n\t \n\tif (dev->s_filter && filter->mask) {\n\t\tif (new_protocols)\n\t\t\trc = dev->s_filter(dev, filter);\n\t\telse\n\t\t\trc = -1;\n\n\t\tif (rc < 0) {\n\t\t\tfilter->data = 0;\n\t\t\tfilter->mask = 0;\n\t\t\tdev->s_filter(dev, filter);\n\t\t}\n\t}\n\n\trc = len;\n\nout:\n\tmutex_unlock(&dev->lock);\n\treturn rc;\n}\n\n \nstatic ssize_t show_filter(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tstruct rc_filter_attribute *fattr = to_rc_filter_attr(attr);\n\tstruct rc_scancode_filter *filter;\n\tu32 val;\n\n\tmutex_lock(&dev->lock);\n\n\tif (fattr->type == RC_FILTER_NORMAL)\n\t\tfilter = &dev->scancode_filter;\n\telse\n\t\tfilter = &dev->scancode_wakeup_filter;\n\n\tif (fattr->mask)\n\t\tval = filter->mask;\n\telse\n\t\tval = filter->data;\n\tmutex_unlock(&dev->lock);\n\n\treturn sprintf(buf, \"%#x\\n\", val);\n}\n\n \nstatic ssize_t store_filter(struct device *device,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t len)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tstruct rc_filter_attribute *fattr = to_rc_filter_attr(attr);\n\tstruct rc_scancode_filter new_filter, *filter;\n\tint ret;\n\tunsigned long val;\n\tint (*set_filter)(struct rc_dev *dev, struct rc_scancode_filter *filter);\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fattr->type == RC_FILTER_NORMAL) {\n\t\tset_filter = dev->s_filter;\n\t\tfilter = &dev->scancode_filter;\n\t} else {\n\t\tset_filter = dev->s_wakeup_filter;\n\t\tfilter = &dev->scancode_wakeup_filter;\n\t}\n\n\tif (!set_filter)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->lock);\n\tif (!dev->registered) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tnew_filter = *filter;\n\tif (fattr->mask)\n\t\tnew_filter.mask = val;\n\telse\n\t\tnew_filter.data = val;\n\n\tif (fattr->type == RC_FILTER_WAKEUP) {\n\t\t \n\t\tif (dev->wakeup_protocol != RC_PROTO_UNKNOWN)\n\t\t\tret = rc_validate_filter(dev, &new_filter);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tif (ret != 0)\n\t\t\tgoto unlock;\n\t}\n\n\tif (fattr->type == RC_FILTER_NORMAL && !dev->enabled_protocols &&\n\t    val) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = set_filter(dev, &new_filter);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t*filter = new_filter;\n\nunlock:\n\tmutex_unlock(&dev->lock);\n\treturn (ret < 0) ? ret : len;\n}\n\n \nstatic ssize_t show_wakeup_protocols(struct device *device,\n\t\t\t\t     struct device_attribute *mattr,\n\t\t\t\t     char *buf)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tu64 allowed;\n\tenum rc_proto enabled;\n\tchar *tmp = buf;\n\tint i;\n\n\tmutex_lock(&dev->lock);\n\n\tallowed = dev->allowed_wakeup_protocols;\n\tenabled = dev->wakeup_protocol;\n\n\tmutex_unlock(&dev->lock);\n\n\tdev_dbg(&dev->dev, \"%s: allowed - 0x%llx, enabled - %d\\n\",\n\t\t__func__, (long long)allowed, enabled);\n\n\tfor (i = 0; i < ARRAY_SIZE(protocols); i++) {\n\t\tif (allowed & (1ULL << i)) {\n\t\t\tif (i == enabled)\n\t\t\t\ttmp += sprintf(tmp, \"[%s] \", protocols[i].name);\n\t\t\telse\n\t\t\t\ttmp += sprintf(tmp, \"%s \", protocols[i].name);\n\t\t}\n\t}\n\n\tif (tmp != buf)\n\t\ttmp--;\n\t*tmp = '\\n';\n\n\treturn tmp + 1 - buf;\n}\n\n \nstatic ssize_t store_wakeup_protocols(struct device *device,\n\t\t\t\t      struct device_attribute *mattr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tenum rc_proto protocol = RC_PROTO_UNKNOWN;\n\tssize_t rc;\n\tu64 allowed;\n\tint i;\n\n\tmutex_lock(&dev->lock);\n\tif (!dev->registered) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tallowed = dev->allowed_wakeup_protocols;\n\n\tif (!sysfs_streq(buf, \"none\")) {\n\t\tfor (i = 0; i < ARRAY_SIZE(protocols); i++) {\n\t\t\tif ((allowed & (1ULL << i)) &&\n\t\t\t    sysfs_streq(buf, protocols[i].name)) {\n\t\t\t\tprotocol = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(protocols)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (dev->encode_wakeup) {\n\t\t\tu64 mask = 1ULL << protocol;\n\n\t\t\tir_raw_load_modules(&mask);\n\t\t\tif (!mask) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dev->wakeup_protocol != protocol) {\n\t\tdev->wakeup_protocol = protocol;\n\t\tdev_dbg(&dev->dev, \"Wakeup protocol changed to %d\\n\", protocol);\n\n\t\tif (protocol == RC_PROTO_RC6_MCE)\n\t\t\tdev->scancode_wakeup_filter.data = 0x800f0000;\n\t\telse\n\t\t\tdev->scancode_wakeup_filter.data = 0;\n\t\tdev->scancode_wakeup_filter.mask = 0;\n\n\t\trc = dev->s_wakeup_filter(dev, &dev->scancode_wakeup_filter);\n\t\tif (rc == 0)\n\t\t\trc = len;\n\t} else {\n\t\trc = len;\n\t}\n\nout:\n\tmutex_unlock(&dev->lock);\n\treturn rc;\n}\n\nstatic void rc_dev_release(struct device *device)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\n\tkfree(dev);\n}\n\nstatic int rc_dev_uevent(const struct device *device, struct kobj_uevent_env *env)\n{\n\tstruct rc_dev *dev = to_rc_dev(device);\n\tint ret = 0;\n\n\tmutex_lock(&dev->lock);\n\n\tif (!dev->registered)\n\t\tret = -ENODEV;\n\tif (ret == 0 && dev->rc_map.name)\n\t\tret = add_uevent_var(env, \"NAME=%s\", dev->rc_map.name);\n\tif (ret == 0 && dev->driver_name)\n\t\tret = add_uevent_var(env, \"DRV_NAME=%s\", dev->driver_name);\n\tif (ret == 0 && dev->device_name)\n\t\tret = add_uevent_var(env, \"DEV_NAME=%s\", dev->device_name);\n\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\n \nstatic struct device_attribute dev_attr_ro_protocols =\n__ATTR(protocols, 0444, show_protocols, NULL);\nstatic struct device_attribute dev_attr_rw_protocols =\n__ATTR(protocols, 0644, show_protocols, store_protocols);\nstatic DEVICE_ATTR(wakeup_protocols, 0644, show_wakeup_protocols,\n\t\t   store_wakeup_protocols);\nstatic RC_FILTER_ATTR(filter, S_IRUGO|S_IWUSR,\n\t\t      show_filter, store_filter, RC_FILTER_NORMAL, false);\nstatic RC_FILTER_ATTR(filter_mask, S_IRUGO|S_IWUSR,\n\t\t      show_filter, store_filter, RC_FILTER_NORMAL, true);\nstatic RC_FILTER_ATTR(wakeup_filter, S_IRUGO|S_IWUSR,\n\t\t      show_filter, store_filter, RC_FILTER_WAKEUP, false);\nstatic RC_FILTER_ATTR(wakeup_filter_mask, S_IRUGO|S_IWUSR,\n\t\t      show_filter, store_filter, RC_FILTER_WAKEUP, true);\n\nstatic struct attribute *rc_dev_rw_protocol_attrs[] = {\n\t&dev_attr_rw_protocols.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rc_dev_rw_protocol_attr_grp = {\n\t.attrs\t= rc_dev_rw_protocol_attrs,\n};\n\nstatic struct attribute *rc_dev_ro_protocol_attrs[] = {\n\t&dev_attr_ro_protocols.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rc_dev_ro_protocol_attr_grp = {\n\t.attrs\t= rc_dev_ro_protocol_attrs,\n};\n\nstatic struct attribute *rc_dev_filter_attrs[] = {\n\t&dev_attr_filter.attr.attr,\n\t&dev_attr_filter_mask.attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rc_dev_filter_attr_grp = {\n\t.attrs\t= rc_dev_filter_attrs,\n};\n\nstatic struct attribute *rc_dev_wakeup_filter_attrs[] = {\n\t&dev_attr_wakeup_filter.attr.attr,\n\t&dev_attr_wakeup_filter_mask.attr.attr,\n\t&dev_attr_wakeup_protocols.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rc_dev_wakeup_filter_attr_grp = {\n\t.attrs\t= rc_dev_wakeup_filter_attrs,\n};\n\nstatic const struct device_type rc_dev_type = {\n\t.release\t= rc_dev_release,\n\t.uevent\t\t= rc_dev_uevent,\n};\n\nstruct rc_dev *rc_allocate_device(enum rc_driver_type type)\n{\n\tstruct rc_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (type != RC_DRIVER_IR_RAW_TX) {\n\t\tdev->input_dev = input_allocate_device();\n\t\tif (!dev->input_dev) {\n\t\t\tkfree(dev);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdev->input_dev->getkeycode = ir_getkeycode;\n\t\tdev->input_dev->setkeycode = ir_setkeycode;\n\t\tinput_set_drvdata(dev->input_dev, dev);\n\n\t\tdev->timeout = IR_DEFAULT_TIMEOUT;\n\t\ttimer_setup(&dev->timer_keyup, ir_timer_keyup, 0);\n\t\ttimer_setup(&dev->timer_repeat, ir_timer_repeat, 0);\n\n\t\tspin_lock_init(&dev->rc_map.lock);\n\t\tspin_lock_init(&dev->keylock);\n\t}\n\tmutex_init(&dev->lock);\n\n\tdev->dev.type = &rc_dev_type;\n\tdev->dev.class = &rc_class;\n\tdevice_initialize(&dev->dev);\n\n\tdev->driver_type = type;\n\n\t__module_get(THIS_MODULE);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(rc_allocate_device);\n\nvoid rc_free_device(struct rc_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tinput_free_device(dev->input_dev);\n\n\tput_device(&dev->dev);\n\n\t \n\n\tmodule_put(THIS_MODULE);\n}\nEXPORT_SYMBOL_GPL(rc_free_device);\n\nstatic void devm_rc_alloc_release(struct device *dev, void *res)\n{\n\trc_free_device(*(struct rc_dev **)res);\n}\n\nstruct rc_dev *devm_rc_allocate_device(struct device *dev,\n\t\t\t\t       enum rc_driver_type type)\n{\n\tstruct rc_dev **dr, *rc;\n\n\tdr = devres_alloc(devm_rc_alloc_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\trc = rc_allocate_device(type);\n\tif (!rc) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\trc->dev.parent = dev;\n\trc->managed_alloc = true;\n\t*dr = rc;\n\tdevres_add(dev, dr);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(devm_rc_allocate_device);\n\nstatic int rc_prepare_rx_device(struct rc_dev *dev)\n{\n\tint rc;\n\tstruct rc_map *rc_map;\n\tu64 rc_proto;\n\n\tif (!dev->map_name)\n\t\treturn -EINVAL;\n\n\trc_map = rc_map_get(dev->map_name);\n\tif (!rc_map)\n\t\trc_map = rc_map_get(RC_MAP_EMPTY);\n\tif (!rc_map || !rc_map->scan || rc_map->size == 0)\n\t\treturn -EINVAL;\n\n\trc = ir_setkeytable(dev, rc_map);\n\tif (rc)\n\t\treturn rc;\n\n\trc_proto = BIT_ULL(rc_map->rc_proto);\n\n\tif (dev->driver_type == RC_DRIVER_SCANCODE && !dev->change_protocol)\n\t\tdev->enabled_protocols = dev->allowed_protocols;\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\tir_raw_load_modules(&rc_proto);\n\n\tif (dev->change_protocol) {\n\t\trc = dev->change_protocol(dev, &rc_proto);\n\t\tif (rc < 0)\n\t\t\tgoto out_table;\n\t\tdev->enabled_protocols = rc_proto;\n\t}\n\n\t \n\tset_bit(EV_KEY, dev->input_dev->evbit);\n\tset_bit(EV_REP, dev->input_dev->evbit);\n\tset_bit(EV_MSC, dev->input_dev->evbit);\n\tset_bit(MSC_SCAN, dev->input_dev->mscbit);\n\n\t \n\tset_bit(INPUT_PROP_POINTING_STICK, dev->input_dev->propbit);\n\tset_bit(EV_REL, dev->input_dev->evbit);\n\tset_bit(REL_X, dev->input_dev->relbit);\n\tset_bit(REL_Y, dev->input_dev->relbit);\n\n\tif (dev->open)\n\t\tdev->input_dev->open = ir_open;\n\tif (dev->close)\n\t\tdev->input_dev->close = ir_close;\n\n\tdev->input_dev->dev.parent = &dev->dev;\n\tmemcpy(&dev->input_dev->id, &dev->input_id, sizeof(dev->input_id));\n\tdev->input_dev->phys = dev->input_phys;\n\tdev->input_dev->name = dev->device_name;\n\n\treturn 0;\n\nout_table:\n\tir_free_table(&dev->rc_map);\n\n\treturn rc;\n}\n\nstatic int rc_setup_rx_device(struct rc_dev *dev)\n{\n\tint rc;\n\n\t \n\trc = input_register_device(dev->input_dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (dev->allowed_protocols == RC_PROTO_BIT_CEC)\n\t\tdev->input_dev->rep[REP_DELAY] = 0;\n\telse\n\t\tdev->input_dev->rep[REP_DELAY] = 500;\n\n\t \n\tdev->input_dev->rep[REP_PERIOD] = 125;\n\n\treturn 0;\n}\n\nstatic void rc_free_rx_device(struct rc_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tif (dev->input_dev) {\n\t\tinput_unregister_device(dev->input_dev);\n\t\tdev->input_dev = NULL;\n\t}\n\n\tir_free_table(&dev->rc_map);\n}\n\nint rc_register_device(struct rc_dev *dev)\n{\n\tconst char *path;\n\tint attr = 0;\n\tint minor;\n\tint rc;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tminor = ida_alloc_max(&rc_ida, RC_DEV_MAX - 1, GFP_KERNEL);\n\tif (minor < 0)\n\t\treturn minor;\n\n\tdev->minor = minor;\n\tdev_set_name(&dev->dev, \"rc%u\", dev->minor);\n\tdev_set_drvdata(&dev->dev, dev);\n\n\tdev->dev.groups = dev->sysfs_groups;\n\tif (dev->driver_type == RC_DRIVER_SCANCODE && !dev->change_protocol)\n\t\tdev->sysfs_groups[attr++] = &rc_dev_ro_protocol_attr_grp;\n\telse if (dev->driver_type != RC_DRIVER_IR_RAW_TX)\n\t\tdev->sysfs_groups[attr++] = &rc_dev_rw_protocol_attr_grp;\n\tif (dev->s_filter)\n\t\tdev->sysfs_groups[attr++] = &rc_dev_filter_attr_grp;\n\tif (dev->s_wakeup_filter)\n\t\tdev->sysfs_groups[attr++] = &rc_dev_wakeup_filter_attr_grp;\n\tdev->sysfs_groups[attr++] = NULL;\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW) {\n\t\trc = ir_raw_event_prepare(dev);\n\t\tif (rc < 0)\n\t\t\tgoto out_minor;\n\t}\n\n\tif (dev->driver_type != RC_DRIVER_IR_RAW_TX) {\n\t\trc = rc_prepare_rx_device(dev);\n\t\tif (rc)\n\t\t\tgoto out_raw;\n\t}\n\n\tdev->registered = true;\n\n\trc = device_add(&dev->dev);\n\tif (rc)\n\t\tgoto out_rx_free;\n\n\tpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\tdev_info(&dev->dev, \"%s as %s\\n\",\n\t\t dev->device_name ?: \"Unspecified device\", path ?: \"N/A\");\n\tkfree(path);\n\n\t \n\tif (dev->allowed_protocols != RC_PROTO_BIT_CEC) {\n\t\trc = lirc_register(dev);\n\t\tif (rc < 0)\n\t\t\tgoto out_dev;\n\t}\n\n\tif (dev->driver_type != RC_DRIVER_IR_RAW_TX) {\n\t\trc = rc_setup_rx_device(dev);\n\t\tif (rc)\n\t\t\tgoto out_lirc;\n\t}\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW) {\n\t\trc = ir_raw_event_register(dev);\n\t\tif (rc < 0)\n\t\t\tgoto out_rx;\n\t}\n\n\tdev_dbg(&dev->dev, \"Registered rc%u (driver: %s)\\n\", dev->minor,\n\t\tdev->driver_name ? dev->driver_name : \"unknown\");\n\n\treturn 0;\n\nout_rx:\n\trc_free_rx_device(dev);\nout_lirc:\n\tif (dev->allowed_protocols != RC_PROTO_BIT_CEC)\n\t\tlirc_unregister(dev);\nout_dev:\n\tdevice_del(&dev->dev);\nout_rx_free:\n\tir_free_table(&dev->rc_map);\nout_raw:\n\tir_raw_event_free(dev);\nout_minor:\n\tida_free(&rc_ida, minor);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rc_register_device);\n\nstatic void devm_rc_release(struct device *dev, void *res)\n{\n\trc_unregister_device(*(struct rc_dev **)res);\n}\n\nint devm_rc_register_device(struct device *parent, struct rc_dev *dev)\n{\n\tstruct rc_dev **dr;\n\tint ret;\n\n\tdr = devres_alloc(devm_rc_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = rc_register_device(dev);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\t*dr = dev;\n\tdevres_add(parent, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_rc_register_device);\n\nvoid rc_unregister_device(struct rc_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tif (dev->driver_type == RC_DRIVER_IR_RAW)\n\t\tir_raw_event_unregister(dev);\n\n\tdel_timer_sync(&dev->timer_keyup);\n\tdel_timer_sync(&dev->timer_repeat);\n\n\tmutex_lock(&dev->lock);\n\tif (dev->users && dev->close)\n\t\tdev->close(dev);\n\tdev->registered = false;\n\tmutex_unlock(&dev->lock);\n\n\trc_free_rx_device(dev);\n\n\t \n\tif (dev->allowed_protocols != RC_PROTO_BIT_CEC)\n\t\tlirc_unregister(dev);\n\n\tdevice_del(&dev->dev);\n\n\tida_free(&rc_ida, dev->minor);\n\n\tif (!dev->managed_alloc)\n\t\trc_free_device(dev);\n}\n\nEXPORT_SYMBOL_GPL(rc_unregister_device);\n\n \n\nstatic int __init rc_core_init(void)\n{\n\tint rc = class_register(&rc_class);\n\tif (rc) {\n\t\tpr_err(\"rc_core: unable to register rc class\\n\");\n\t\treturn rc;\n\t}\n\n\trc = lirc_dev_init();\n\tif (rc) {\n\t\tpr_err(\"rc_core: unable to init lirc\\n\");\n\t\tclass_unregister(&rc_class);\n\t\treturn rc;\n\t}\n\n\tled_trigger_register_simple(\"rc-feedback\", &led_feedback);\n\trc_map_register(&empty_map);\n#ifdef CONFIG_MEDIA_CEC_RC\n\trc_map_register(&cec_map);\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit rc_core_exit(void)\n{\n\tlirc_dev_exit();\n\tclass_unregister(&rc_class);\n\tled_trigger_unregister_simple(led_feedback);\n#ifdef CONFIG_MEDIA_CEC_RC\n\trc_map_unregister(&cec_map);\n#endif\n\trc_map_unregister(&empty_map);\n}\n\nsubsys_initcall(rc_core_init);\nmodule_exit(rc_core_exit);\n\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}