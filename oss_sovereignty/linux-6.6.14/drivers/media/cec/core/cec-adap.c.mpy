{
  "module_name": "cec-adap.c",
  "hash_id": "7cbe25adfab4d46e17dc7054b3f5a6a01d59fd466ab2f82ca2c0bcdbfe858a6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-adap.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_file.h>\n\n#include \"cec-priv.h\"\n\nstatic void cec_fill_msg_report_features(struct cec_adapter *adap,\n\t\t\t\t\t struct cec_msg *msg,\n\t\t\t\t\t unsigned int la_idx);\n\nstatic int cec_log_addr2idx(const struct cec_adapter *adap, u8 log_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < adap->log_addrs.num_log_addrs; i++)\n\t\tif (adap->log_addrs.log_addr[i] == log_addr)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic unsigned int cec_log_addr2dev(const struct cec_adapter *adap, u8 log_addr)\n{\n\tint i = cec_log_addr2idx(adap, log_addr);\n\n\treturn adap->log_addrs.primary_device_type[i < 0 ? 0 : i];\n}\n\nu16 cec_get_edid_phys_addr(const u8 *edid, unsigned int size,\n\t\t\t   unsigned int *offset)\n{\n\tunsigned int loc = cec_get_edid_spa_location(edid, size);\n\n\tif (offset)\n\t\t*offset = loc;\n\tif (loc == 0)\n\t\treturn CEC_PHYS_ADDR_INVALID;\n\treturn (edid[loc] << 8) | edid[loc + 1];\n}\nEXPORT_SYMBOL_GPL(cec_get_edid_phys_addr);\n\nvoid cec_fill_conn_info_from_drm(struct cec_connector_info *conn_info,\n\t\t\t\t const struct drm_connector *connector)\n{\n\tmemset(conn_info, 0, sizeof(*conn_info));\n\tconn_info->type = CEC_CONNECTOR_TYPE_DRM;\n\tconn_info->drm.card_no = connector->dev->primary->index;\n\tconn_info->drm.connector_id = connector->base.id;\n}\nEXPORT_SYMBOL_GPL(cec_fill_conn_info_from_drm);\n\n \nvoid cec_queue_event_fh(struct cec_fh *fh,\n\t\t\tconst struct cec_event *new_ev, u64 ts)\n{\n\tstatic const u16 max_events[CEC_NUM_EVENTS] = {\n\t\t1, 1, 800, 800, 8, 8, 8, 8\n\t};\n\tstruct cec_event_entry *entry;\n\tunsigned int ev_idx = new_ev->event - 1;\n\n\tif (WARN_ON(ev_idx >= ARRAY_SIZE(fh->events)))\n\t\treturn;\n\n\tif (ts == 0)\n\t\tts = ktime_get_ns();\n\n\tmutex_lock(&fh->lock);\n\tif (ev_idx < CEC_NUM_CORE_EVENTS)\n\t\tentry = &fh->core_events[ev_idx];\n\telse\n\t\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry) {\n\t\tif (new_ev->event == CEC_EVENT_LOST_MSGS &&\n\t\t    fh->queued_events[ev_idx]) {\n\t\t\tentry->ev.lost_msgs.lost_msgs +=\n\t\t\t\tnew_ev->lost_msgs.lost_msgs;\n\t\t\tgoto unlock;\n\t\t}\n\t\tentry->ev = *new_ev;\n\t\tentry->ev.ts = ts;\n\n\t\tif (fh->queued_events[ev_idx] < max_events[ev_idx]) {\n\t\t\t \n\t\t\tlist_add_tail(&entry->list, &fh->events[ev_idx]);\n\t\t\tfh->queued_events[ev_idx]++;\n\t\t\tfh->total_queued_events++;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (ev_idx >= CEC_NUM_CORE_EVENTS) {\n\t\t\tlist_add_tail(&entry->list, &fh->events[ev_idx]);\n\t\t\t \n\t\t\tentry = list_first_entry(&fh->events[ev_idx],\n\t\t\t\t\t\t struct cec_event_entry, list);\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\t \n\tentry = list_first_entry_or_null(&fh->events[ev_idx],\n\t\t\t\t\t struct cec_event_entry, list);\n\tif (entry)\n\t\tentry->ev.flags |= CEC_EVENT_FL_DROPPED_EVENTS;\n\nunlock:\n\tmutex_unlock(&fh->lock);\n\twake_up_interruptible(&fh->wait);\n}\n\n \nstatic void cec_queue_event(struct cec_adapter *adap,\n\t\t\t    const struct cec_event *ev)\n{\n\tu64 ts = ktime_get_ns();\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list)\n\t\tcec_queue_event_fh(fh, ev, ts);\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\n\n \nvoid cec_queue_pin_cec_event(struct cec_adapter *adap, bool is_high,\n\t\t\t     bool dropped_events, ktime_t ts)\n{\n\tstruct cec_event ev = {\n\t\t.event = is_high ? CEC_EVENT_PIN_CEC_HIGH :\n\t\t\t\t   CEC_EVENT_PIN_CEC_LOW,\n\t\t.flags = dropped_events ? CEC_EVENT_FL_DROPPED_EVENTS : 0,\n\t};\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list) {\n\t\tif (fh->mode_follower == CEC_MODE_MONITOR_PIN)\n\t\t\tcec_queue_event_fh(fh, &ev, ktime_to_ns(ts));\n\t}\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\nEXPORT_SYMBOL_GPL(cec_queue_pin_cec_event);\n\n \nvoid cec_queue_pin_hpd_event(struct cec_adapter *adap, bool is_high, ktime_t ts)\n{\n\tstruct cec_event ev = {\n\t\t.event = is_high ? CEC_EVENT_PIN_HPD_HIGH :\n\t\t\t\t   CEC_EVENT_PIN_HPD_LOW,\n\t};\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list)\n\t\tcec_queue_event_fh(fh, &ev, ktime_to_ns(ts));\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\nEXPORT_SYMBOL_GPL(cec_queue_pin_hpd_event);\n\n \nvoid cec_queue_pin_5v_event(struct cec_adapter *adap, bool is_high, ktime_t ts)\n{\n\tstruct cec_event ev = {\n\t\t.event = is_high ? CEC_EVENT_PIN_5V_HIGH :\n\t\t\t\t   CEC_EVENT_PIN_5V_LOW,\n\t};\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list)\n\t\tcec_queue_event_fh(fh, &ev, ktime_to_ns(ts));\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\nEXPORT_SYMBOL_GPL(cec_queue_pin_5v_event);\n\n \nstatic void cec_queue_msg_fh(struct cec_fh *fh, const struct cec_msg *msg)\n{\n\tstatic const struct cec_event ev_lost_msgs = {\n\t\t.event = CEC_EVENT_LOST_MSGS,\n\t\t.flags = 0,\n\t\t{\n\t\t\t.lost_msgs = { 1 },\n\t\t},\n\t};\n\tstruct cec_msg_entry *entry;\n\n\tmutex_lock(&fh->lock);\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry) {\n\t\tentry->msg = *msg;\n\t\t \n\t\tlist_add_tail(&entry->list, &fh->msgs);\n\n\t\tif (fh->queued_msgs < CEC_MAX_MSG_RX_QUEUE_SZ) {\n\t\t\t \n\t\t\tfh->queued_msgs++;\n\t\t\tmutex_unlock(&fh->lock);\n\t\t\twake_up_interruptible(&fh->wait);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tentry = list_first_entry(&fh->msgs, struct cec_msg_entry, list);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&fh->lock);\n\n\t \n\tcec_queue_event_fh(fh, &ev_lost_msgs, ktime_get_ns());\n}\n\n \nstatic void cec_queue_msg_monitor(struct cec_adapter *adap,\n\t\t\t\t  const struct cec_msg *msg,\n\t\t\t\t  bool valid_la)\n{\n\tstruct cec_fh *fh;\n\tu32 monitor_mode = valid_la ? CEC_MODE_MONITOR :\n\t\t\t\t      CEC_MODE_MONITOR_ALL;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list) {\n\t\tif (fh->mode_follower >= monitor_mode)\n\t\t\tcec_queue_msg_fh(fh, msg);\n\t}\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\n\n \nstatic void cec_queue_msg_followers(struct cec_adapter *adap,\n\t\t\t\t    const struct cec_msg *msg)\n{\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&adap->devnode.lock_fhs);\n\tlist_for_each_entry(fh, &adap->devnode.fhs, list) {\n\t\tif (fh->mode_follower == CEC_MODE_FOLLOWER)\n\t\t\tcec_queue_msg_fh(fh, msg);\n\t}\n\tmutex_unlock(&adap->devnode.lock_fhs);\n}\n\n \nstatic void cec_post_state_event(struct cec_adapter *adap)\n{\n\tstruct cec_event ev = {\n\t\t.event = CEC_EVENT_STATE_CHANGE,\n\t};\n\n\tev.state_change.phys_addr = adap->phys_addr;\n\tev.state_change.log_addr_mask = adap->log_addrs.log_addr_mask;\n\tev.state_change.have_conn_info =\n\t\tadap->conn_info.type != CEC_CONNECTOR_TYPE_NO_CONNECTOR;\n\tcec_queue_event(adap, &ev);\n}\n\n \nstatic void cec_data_completed(struct cec_data *data)\n{\n\t \n\tif (data->fh)\n\t\tlist_del_init(&data->xfer_list);\n\n\tif (data->blocking) {\n\t\t \n\t\tdata->completed = true;\n\t\tcomplete(&data->c);\n\t} else {\n\t\t \n\t\tif (data->fh)\n\t\t\tcec_queue_msg_fh(data->fh, &data->msg);\n\t\tkfree(data);\n\t}\n}\n\n \nstatic void cec_data_cancel(struct cec_data *data, u8 tx_status, u8 rx_status)\n{\n\tstruct cec_adapter *adap = data->adap;\n\n\t \n\tif (adap->transmitting == data) {\n\t\tadap->transmitting = NULL;\n\t} else {\n\t\tlist_del_init(&data->list);\n\t\tif (!(data->msg.tx_status & CEC_TX_STATUS_OK))\n\t\t\tif (!WARN_ON(!adap->transmit_queue_sz))\n\t\t\t\tadap->transmit_queue_sz--;\n\t}\n\n\tif (data->msg.tx_status & CEC_TX_STATUS_OK) {\n\t\tdata->msg.rx_ts = ktime_get_ns();\n\t\tdata->msg.rx_status = rx_status;\n\t\tif (!data->blocking)\n\t\t\tdata->msg.tx_status = 0;\n\t} else {\n\t\tdata->msg.tx_ts = ktime_get_ns();\n\t\tdata->msg.tx_status |= tx_status |\n\t\t\t\t       CEC_TX_STATUS_MAX_RETRIES;\n\t\tdata->msg.tx_error_cnt++;\n\t\tdata->attempts = 0;\n\t\tif (!data->blocking)\n\t\t\tdata->msg.rx_status = 0;\n\t}\n\n\t \n\tcec_queue_msg_monitor(adap, &data->msg, 1);\n\n\tif (!data->blocking && data->msg.sequence)\n\t\t \n\t\tcall_void_op(adap, adap_nb_transmit_canceled, &data->msg);\n\n\tcec_data_completed(data);\n}\n\n \nstatic void cec_flush(struct cec_adapter *adap)\n{\n\tstruct cec_data *data, *n;\n\n\t \n\twhile (!list_empty(&adap->transmit_queue)) {\n\t\tdata = list_first_entry(&adap->transmit_queue,\n\t\t\t\t\tstruct cec_data, list);\n\t\tcec_data_cancel(data, CEC_TX_STATUS_ABORTED, 0);\n\t}\n\tif (adap->transmitting)\n\t\tadap->transmit_in_progress_aborted = true;\n\n\t \n\tlist_for_each_entry_safe(data, n, &adap->wait_queue, list) {\n\t\tif (cancel_delayed_work(&data->work))\n\t\t\tcec_data_cancel(data, CEC_TX_STATUS_OK, CEC_RX_STATUS_ABORTED);\n\t\t \n\t}\n\t \n\tif (WARN_ON(adap->transmit_queue_sz))\n\t\tadap->transmit_queue_sz = 0;\n}\n\n \nint cec_thread_func(void *_adap)\n{\n\tstruct cec_adapter *adap = _adap;\n\n\tfor (;;) {\n\t\tunsigned int signal_free_time;\n\t\tstruct cec_data *data;\n\t\tbool timeout = false;\n\t\tu8 attempts;\n\n\t\tif (adap->transmit_in_progress) {\n\t\t\tint err;\n\n\t\t\t \n\t\t\terr = wait_event_interruptible_timeout(adap->kthread_waitq,\n\t\t\t\t(adap->needs_hpd &&\n\t\t\t\t (!adap->is_configured && !adap->is_configuring)) ||\n\t\t\t\tkthread_should_stop() ||\n\t\t\t\t(!adap->transmit_in_progress &&\n\t\t\t\t !list_empty(&adap->transmit_queue)),\n\t\t\t\tmsecs_to_jiffies(adap->xfer_timeout_ms));\n\t\t\ttimeout = err == 0;\n\t\t} else {\n\t\t\t \n\t\t\twait_event_interruptible(adap->kthread_waitq,\n\t\t\t\tkthread_should_stop() ||\n\t\t\t\t(!adap->transmit_in_progress &&\n\t\t\t\t !list_empty(&adap->transmit_queue)));\n\t\t}\n\n\t\tmutex_lock(&adap->lock);\n\n\t\tif ((adap->needs_hpd &&\n\t\t     (!adap->is_configured && !adap->is_configuring)) ||\n\t\t    kthread_should_stop()) {\n\t\t\tcec_flush(adap);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (adap->transmit_in_progress && timeout) {\n\t\t\t \n\t\t\tif (adap->transmitting) {\n\t\t\t\tpr_warn(\"cec-%s: message %*ph timed out\\n\", adap->name,\n\t\t\t\t\tadap->transmitting->msg.len,\n\t\t\t\t\tadap->transmitting->msg.msg);\n\t\t\t\t \n\t\t\t\tcec_data_cancel(adap->transmitting,\n\t\t\t\t\t\tCEC_TX_STATUS_TIMEOUT, 0);\n\t\t\t} else {\n\t\t\t\tpr_warn(\"cec-%s: transmit timed out\\n\", adap->name);\n\t\t\t}\n\t\t\tadap->transmit_in_progress = false;\n\t\t\tadap->tx_timeouts++;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\tif (adap->transmit_in_progress || list_empty(&adap->transmit_queue))\n\t\t\tgoto unlock;\n\n\t\t \n\t\tdata = list_first_entry(&adap->transmit_queue,\n\t\t\t\t\tstruct cec_data, list);\n\t\tlist_del_init(&data->list);\n\t\tif (!WARN_ON(!data->adap->transmit_queue_sz))\n\t\t\tadap->transmit_queue_sz--;\n\n\t\t \n\t\tadap->transmitting = data;\n\n\t\t \n\t\tif (data->msg.len == 1 && adap->is_configured)\n\t\t\tattempts = 2;\n\t\telse\n\t\t\tattempts = 4;\n\n\t\t \n\t\tif (data->attempts) {\n\t\t\t \n\t\t\tsignal_free_time = CEC_SIGNAL_FREE_TIME_RETRY;\n\t\t} else if (adap->last_initiator !=\n\t\t\t   cec_msg_initiator(&data->msg)) {\n\t\t\t \n\t\t\tsignal_free_time = CEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\n\t\t\tadap->last_initiator = cec_msg_initiator(&data->msg);\n\t\t} else {\n\t\t\t \n\t\t\tsignal_free_time = CEC_SIGNAL_FREE_TIME_NEXT_XFER;\n\t\t}\n\t\tif (data->attempts == 0)\n\t\t\tdata->attempts = attempts;\n\n\t\tadap->transmit_in_progress_aborted = false;\n\t\t \n\t\tif (call_op(adap, adap_transmit, data->attempts,\n\t\t\t    signal_free_time, &data->msg))\n\t\t\tcec_data_cancel(data, CEC_TX_STATUS_ABORTED, 0);\n\t\telse\n\t\t\tadap->transmit_in_progress = true;\n\nunlock:\n\t\tmutex_unlock(&adap->lock);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nvoid cec_transmit_done_ts(struct cec_adapter *adap, u8 status,\n\t\t\t  u8 arb_lost_cnt, u8 nack_cnt, u8 low_drive_cnt,\n\t\t\t  u8 error_cnt, ktime_t ts)\n{\n\tstruct cec_data *data;\n\tstruct cec_msg *msg;\n\tunsigned int attempts_made = arb_lost_cnt + nack_cnt +\n\t\t\t\t     low_drive_cnt + error_cnt;\n\tbool done = status & (CEC_TX_STATUS_MAX_RETRIES | CEC_TX_STATUS_OK);\n\tbool aborted = adap->transmit_in_progress_aborted;\n\n\tdprintk(2, \"%s: status 0x%02x\\n\", __func__, status);\n\tif (attempts_made < 1)\n\t\tattempts_made = 1;\n\n\tmutex_lock(&adap->lock);\n\tdata = adap->transmitting;\n\tif (!data) {\n\t\t \n\t\tif (!adap->transmit_in_progress)\n\t\t\tdprintk(1, \"%s was called without an ongoing transmit!\\n\",\n\t\t\t\t__func__);\n\t\tadap->transmit_in_progress = false;\n\t\tgoto wake_thread;\n\t}\n\tadap->transmit_in_progress = false;\n\tadap->transmit_in_progress_aborted = false;\n\n\tmsg = &data->msg;\n\n\t \n\tWARN_ON(status == 0);\n\tmsg->tx_ts = ktime_to_ns(ts);\n\tmsg->tx_status |= status;\n\tmsg->tx_arb_lost_cnt += arb_lost_cnt;\n\tmsg->tx_nack_cnt += nack_cnt;\n\tmsg->tx_low_drive_cnt += low_drive_cnt;\n\tmsg->tx_error_cnt += error_cnt;\n\n\t \n\tadap->transmitting = NULL;\n\n\t \n\tif (!aborted && data->attempts > attempts_made && !done) {\n\t\t \n\t\tdata->attempts -= attempts_made;\n\t\tif (msg->timeout)\n\t\t\tdprintk(2, \"retransmit: %*ph (attempts: %d, wait for 0x%02x)\\n\",\n\t\t\t\tmsg->len, msg->msg, data->attempts, msg->reply);\n\t\telse\n\t\t\tdprintk(2, \"retransmit: %*ph (attempts: %d)\\n\",\n\t\t\t\tmsg->len, msg->msg, data->attempts);\n\t\t \n\t\tlist_add(&data->list, &adap->transmit_queue);\n\t\tadap->transmit_queue_sz++;\n\t\tgoto wake_thread;\n\t}\n\n\tif (aborted && !done)\n\t\tstatus |= CEC_TX_STATUS_ABORTED;\n\tdata->attempts = 0;\n\n\t \n\tif (!(status & CEC_TX_STATUS_OK))\n\t\tmsg->tx_status |= CEC_TX_STATUS_MAX_RETRIES;\n\n\t \n\tcec_queue_msg_monitor(adap, msg, 1);\n\n\tif ((status & CEC_TX_STATUS_OK) && adap->is_configured &&\n\t    msg->timeout) {\n\t\t \n\t\tlist_add_tail(&data->list, &adap->wait_queue);\n\t\tschedule_delayed_work(&data->work,\n\t\t\t\t      msecs_to_jiffies(msg->timeout));\n\t} else {\n\t\t \n\t\tcec_data_completed(data);\n\t}\n\nwake_thread:\n\t \n\twake_up_interruptible(&adap->kthread_waitq);\n\tmutex_unlock(&adap->lock);\n}\nEXPORT_SYMBOL_GPL(cec_transmit_done_ts);\n\nvoid cec_transmit_attempt_done_ts(struct cec_adapter *adap,\n\t\t\t\t  u8 status, ktime_t ts)\n{\n\tswitch (status & ~CEC_TX_STATUS_MAX_RETRIES) {\n\tcase CEC_TX_STATUS_OK:\n\t\tcec_transmit_done_ts(adap, status, 0, 0, 0, 0, ts);\n\t\treturn;\n\tcase CEC_TX_STATUS_ARB_LOST:\n\t\tcec_transmit_done_ts(adap, status, 1, 0, 0, 0, ts);\n\t\treturn;\n\tcase CEC_TX_STATUS_NACK:\n\t\tcec_transmit_done_ts(adap, status, 0, 1, 0, 0, ts);\n\t\treturn;\n\tcase CEC_TX_STATUS_LOW_DRIVE:\n\t\tcec_transmit_done_ts(adap, status, 0, 0, 1, 0, ts);\n\t\treturn;\n\tcase CEC_TX_STATUS_ERROR:\n\t\tcec_transmit_done_ts(adap, status, 0, 0, 0, 1, ts);\n\t\treturn;\n\tdefault:\n\t\t \n\t\tWARN(1, \"cec-%s: invalid status 0x%02x\\n\", adap->name, status);\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(cec_transmit_attempt_done_ts);\n\n \nstatic void cec_wait_timeout(struct work_struct *work)\n{\n\tstruct cec_data *data = container_of(work, struct cec_data, work.work);\n\tstruct cec_adapter *adap = data->adap;\n\n\tmutex_lock(&adap->lock);\n\t \n\tif (list_empty(&data->list))\n\t\tgoto unlock;\n\n\t \n\tlist_del_init(&data->list);\n\tcec_data_cancel(data, CEC_TX_STATUS_OK, CEC_RX_STATUS_TIMEOUT);\nunlock:\n\tmutex_unlock(&adap->lock);\n}\n\n \nint cec_transmit_msg_fh(struct cec_adapter *adap, struct cec_msg *msg,\n\t\t\tstruct cec_fh *fh, bool block)\n{\n\tstruct cec_data *data;\n\tbool is_raw = msg_is_raw(msg);\n\n\tif (adap->devnode.unregistered)\n\t\treturn -ENODEV;\n\n\tmsg->rx_ts = 0;\n\tmsg->tx_ts = 0;\n\tmsg->rx_status = 0;\n\tmsg->tx_status = 0;\n\tmsg->tx_arb_lost_cnt = 0;\n\tmsg->tx_nack_cnt = 0;\n\tmsg->tx_low_drive_cnt = 0;\n\tmsg->tx_error_cnt = 0;\n\tmsg->sequence = 0;\n\n\tif (msg->reply && msg->timeout == 0) {\n\t\t \n\t\tmsg->timeout = 1000;\n\t}\n\tmsg->flags &= CEC_MSG_FL_REPLY_TO_FOLLOWERS | CEC_MSG_FL_RAW;\n\n\tif (!msg->timeout)\n\t\tmsg->flags &= ~CEC_MSG_FL_REPLY_TO_FOLLOWERS;\n\n\t \n\tif (msg->len == 0 || msg->len > CEC_MAX_MSG_SIZE) {\n\t\tdprintk(1, \"%s: invalid length %d\\n\", __func__, msg->len);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(msg->msg + msg->len, 0, sizeof(msg->msg) - msg->len);\n\n\tif (msg->timeout)\n\t\tdprintk(2, \"%s: %*ph (wait for 0x%02x%s)\\n\",\n\t\t\t__func__, msg->len, msg->msg, msg->reply,\n\t\t\t!block ? \", nb\" : \"\");\n\telse\n\t\tdprintk(2, \"%s: %*ph%s\\n\",\n\t\t\t__func__, msg->len, msg->msg, !block ? \" (nb)\" : \"\");\n\n\tif (msg->timeout && msg->len == 1) {\n\t\tdprintk(1, \"%s: can't reply to poll msg\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_raw) {\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t \n\t\tif ((adap->log_addrs.flags & CEC_LOG_ADDRS_FL_CDC_ONLY) &&\n\t\t    (msg->len == 1 || msg->msg[1] != CEC_MSG_CDC_MESSAGE)) {\n\t\t\tdprintk(1, \"%s: not a CDC message\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (msg->len >= 4 && msg->msg[1] == CEC_MSG_CDC_MESSAGE) {\n\t\t\tmsg->msg[2] = adap->phys_addr >> 8;\n\t\t\tmsg->msg[3] = adap->phys_addr & 0xff;\n\t\t}\n\n\t\tif (msg->len == 1) {\n\t\t\tif (cec_msg_destination(msg) == 0xf) {\n\t\t\t\tdprintk(1, \"%s: invalid poll message\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (cec_has_log_addr(adap, cec_msg_destination(msg))) {\n\t\t\t\t \n\t\t\t\tmsg->tx_ts = ktime_get_ns();\n\t\t\t\tmsg->tx_status = CEC_TX_STATUS_NACK |\n\t\t\t\t\tCEC_TX_STATUS_MAX_RETRIES;\n\t\t\t\tmsg->tx_nack_cnt = 1;\n\t\t\t\tmsg->sequence = ++adap->sequence;\n\t\t\t\tif (!msg->sequence)\n\t\t\t\t\tmsg->sequence = ++adap->sequence;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (msg->len > 1 && !cec_msg_is_broadcast(msg) &&\n\t\t    cec_has_log_addr(adap, cec_msg_destination(msg))) {\n\t\t\tdprintk(1, \"%s: destination is the adapter itself\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (msg->len > 1 && adap->is_configured &&\n\t\t    !cec_has_log_addr(adap, cec_msg_initiator(msg))) {\n\t\t\tdprintk(1, \"%s: initiator has unknown logical address %d\\n\",\n\t\t\t\t__func__, cec_msg_initiator(msg));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (!adap->is_configured && !adap->is_configuring &&\n\t\t    (msg->len > 2 ||\n\t\t     cec_msg_destination(msg) != CEC_LOG_ADDR_TV ||\n\t\t     (msg->len == 2 && msg->msg[1] != CEC_MSG_IMAGE_VIEW_ON &&\n\t\t      msg->msg[1] != CEC_MSG_TEXT_VIEW_ON))) {\n\t\t\tdprintk(1, \"%s: adapter is unconfigured\\n\", __func__);\n\t\t\treturn -ENONET;\n\t\t}\n\t}\n\n\tif (!adap->is_configured && !adap->is_configuring) {\n\t\tif (adap->needs_hpd) {\n\t\t\tdprintk(1, \"%s: adapter is unconfigured and needs HPD\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -ENONET;\n\t\t}\n\t\tif (msg->reply) {\n\t\t\tdprintk(1, \"%s: invalid msg->reply\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (adap->transmit_queue_sz >= CEC_MAX_MSG_TX_QUEUE_SZ) {\n\t\tdprintk(2, \"%s: transmit queue full\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmsg->sequence = ++adap->sequence;\n\tif (!msg->sequence)\n\t\tmsg->sequence = ++adap->sequence;\n\n\tdata->msg = *msg;\n\tdata->fh = fh;\n\tdata->adap = adap;\n\tdata->blocking = block;\n\n\tinit_completion(&data->c);\n\tINIT_DELAYED_WORK(&data->work, cec_wait_timeout);\n\n\tif (fh)\n\t\tlist_add_tail(&data->xfer_list, &fh->xfer_list);\n\telse\n\t\tINIT_LIST_HEAD(&data->xfer_list);\n\n\tlist_add_tail(&data->list, &adap->transmit_queue);\n\tadap->transmit_queue_sz++;\n\tif (!adap->transmitting)\n\t\twake_up_interruptible(&adap->kthread_waitq);\n\n\t \n\tif (!block)\n\t\treturn 0;\n\n\t \n\tmutex_unlock(&adap->lock);\n\twait_for_completion_killable(&data->c);\n\tif (!data->completed)\n\t\tcancel_delayed_work_sync(&data->work);\n\tmutex_lock(&adap->lock);\n\n\t \n\tif (!data->completed) {\n\t\tif (data->msg.tx_status & CEC_TX_STATUS_OK)\n\t\t\tcec_data_cancel(data, CEC_TX_STATUS_OK, CEC_RX_STATUS_ABORTED);\n\t\telse\n\t\t\tcec_data_cancel(data, CEC_TX_STATUS_ABORTED, 0);\n\t}\n\n\t \n\t*msg = data->msg;\n\tif (WARN_ON(!list_empty(&data->list)))\n\t\tlist_del(&data->list);\n\tif (WARN_ON(!list_empty(&data->xfer_list)))\n\t\tlist_del(&data->xfer_list);\n\tkfree(data);\n\treturn 0;\n}\n\n \nint cec_transmit_msg(struct cec_adapter *adap, struct cec_msg *msg,\n\t\t     bool block)\n{\n\tint ret;\n\n\tmutex_lock(&adap->lock);\n\tret = cec_transmit_msg_fh(adap, msg, NULL, block);\n\tmutex_unlock(&adap->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cec_transmit_msg);\n\n \nstatic int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,\n\t\t\t      bool is_reply);\n\n#define DIRECTED\t0x80\n#define BCAST1_4\t0x40\n#define BCAST2_0\t0x20\t \n#define BCAST\t\t(BCAST1_4 | BCAST2_0)\n#define BOTH\t\t(BCAST | DIRECTED)\n\n \nstatic const u8 cec_msg_size[256] = {\n\t[CEC_MSG_ACTIVE_SOURCE] = 4 | BCAST,\n\t[CEC_MSG_IMAGE_VIEW_ON] = 2 | DIRECTED,\n\t[CEC_MSG_TEXT_VIEW_ON] = 2 | DIRECTED,\n\t[CEC_MSG_INACTIVE_SOURCE] = 4 | DIRECTED,\n\t[CEC_MSG_REQUEST_ACTIVE_SOURCE] = 2 | BCAST,\n\t[CEC_MSG_ROUTING_CHANGE] = 6 | BCAST,\n\t[CEC_MSG_ROUTING_INFORMATION] = 4 | BCAST,\n\t[CEC_MSG_SET_STREAM_PATH] = 4 | BCAST,\n\t[CEC_MSG_STANDBY] = 2 | BOTH,\n\t[CEC_MSG_RECORD_OFF] = 2 | DIRECTED,\n\t[CEC_MSG_RECORD_ON] = 3 | DIRECTED,\n\t[CEC_MSG_RECORD_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_RECORD_TV_SCREEN] = 2 | DIRECTED,\n\t[CEC_MSG_CLEAR_ANALOGUE_TIMER] = 13 | DIRECTED,\n\t[CEC_MSG_CLEAR_DIGITAL_TIMER] = 16 | DIRECTED,\n\t[CEC_MSG_CLEAR_EXT_TIMER] = 13 | DIRECTED,\n\t[CEC_MSG_SET_ANALOGUE_TIMER] = 13 | DIRECTED,\n\t[CEC_MSG_SET_DIGITAL_TIMER] = 16 | DIRECTED,\n\t[CEC_MSG_SET_EXT_TIMER] = 13 | DIRECTED,\n\t[CEC_MSG_SET_TIMER_PROGRAM_TITLE] = 2 | DIRECTED,\n\t[CEC_MSG_TIMER_CLEARED_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_TIMER_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_CEC_VERSION] = 3 | DIRECTED,\n\t[CEC_MSG_GET_CEC_VERSION] = 2 | DIRECTED,\n\t[CEC_MSG_GIVE_PHYSICAL_ADDR] = 2 | DIRECTED,\n\t[CEC_MSG_GET_MENU_LANGUAGE] = 2 | DIRECTED,\n\t[CEC_MSG_REPORT_PHYSICAL_ADDR] = 5 | BCAST,\n\t[CEC_MSG_SET_MENU_LANGUAGE] = 5 | BCAST,\n\t[CEC_MSG_REPORT_FEATURES] = 6 | BCAST,\n\t[CEC_MSG_GIVE_FEATURES] = 2 | DIRECTED,\n\t[CEC_MSG_DECK_CONTROL] = 3 | DIRECTED,\n\t[CEC_MSG_DECK_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_GIVE_DECK_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_PLAY] = 3 | DIRECTED,\n\t[CEC_MSG_GIVE_TUNER_DEVICE_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_SELECT_ANALOGUE_SERVICE] = 6 | DIRECTED,\n\t[CEC_MSG_SELECT_DIGITAL_SERVICE] = 9 | DIRECTED,\n\t[CEC_MSG_TUNER_DEVICE_STATUS] = 7 | DIRECTED,\n\t[CEC_MSG_TUNER_STEP_DECREMENT] = 2 | DIRECTED,\n\t[CEC_MSG_TUNER_STEP_INCREMENT] = 2 | DIRECTED,\n\t[CEC_MSG_DEVICE_VENDOR_ID] = 5 | BCAST,\n\t[CEC_MSG_GIVE_DEVICE_VENDOR_ID] = 2 | DIRECTED,\n\t[CEC_MSG_VENDOR_COMMAND] = 2 | DIRECTED,\n\t[CEC_MSG_VENDOR_COMMAND_WITH_ID] = 5 | BOTH,\n\t[CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN] = 2 | BOTH,\n\t[CEC_MSG_VENDOR_REMOTE_BUTTON_UP] = 2 | BOTH,\n\t[CEC_MSG_SET_OSD_STRING] = 3 | DIRECTED,\n\t[CEC_MSG_GIVE_OSD_NAME] = 2 | DIRECTED,\n\t[CEC_MSG_SET_OSD_NAME] = 2 | DIRECTED,\n\t[CEC_MSG_MENU_REQUEST] = 3 | DIRECTED,\n\t[CEC_MSG_MENU_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_USER_CONTROL_PRESSED] = 3 | DIRECTED,\n\t[CEC_MSG_USER_CONTROL_RELEASED] = 2 | DIRECTED,\n\t[CEC_MSG_GIVE_DEVICE_POWER_STATUS] = 2 | DIRECTED,\n\t[CEC_MSG_REPORT_POWER_STATUS] = 3 | DIRECTED | BCAST2_0,\n\t[CEC_MSG_FEATURE_ABORT] = 4 | DIRECTED,\n\t[CEC_MSG_ABORT] = 2 | DIRECTED,\n\t[CEC_MSG_GIVE_AUDIO_STATUS] = 2 | DIRECTED,\n\t[CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS] = 2 | DIRECTED,\n\t[CEC_MSG_REPORT_AUDIO_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR] = 2 | DIRECTED,\n\t[CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR] = 2 | DIRECTED,\n\t[CEC_MSG_SET_SYSTEM_AUDIO_MODE] = 3 | BOTH,\n\t[CEC_MSG_SET_AUDIO_VOLUME_LEVEL] = 3 | DIRECTED,\n\t[CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST] = 2 | DIRECTED,\n\t[CEC_MSG_SYSTEM_AUDIO_MODE_STATUS] = 3 | DIRECTED,\n\t[CEC_MSG_SET_AUDIO_RATE] = 3 | DIRECTED,\n\t[CEC_MSG_INITIATE_ARC] = 2 | DIRECTED,\n\t[CEC_MSG_REPORT_ARC_INITIATED] = 2 | DIRECTED,\n\t[CEC_MSG_REPORT_ARC_TERMINATED] = 2 | DIRECTED,\n\t[CEC_MSG_REQUEST_ARC_INITIATION] = 2 | DIRECTED,\n\t[CEC_MSG_REQUEST_ARC_TERMINATION] = 2 | DIRECTED,\n\t[CEC_MSG_TERMINATE_ARC] = 2 | DIRECTED,\n\t[CEC_MSG_REQUEST_CURRENT_LATENCY] = 4 | BCAST,\n\t[CEC_MSG_REPORT_CURRENT_LATENCY] = 6 | BCAST,\n\t[CEC_MSG_CDC_MESSAGE] = 2 | BCAST,\n};\n\n \nvoid cec_received_msg_ts(struct cec_adapter *adap,\n\t\t\t struct cec_msg *msg, ktime_t ts)\n{\n\tstruct cec_data *data;\n\tu8 msg_init = cec_msg_initiator(msg);\n\tu8 msg_dest = cec_msg_destination(msg);\n\tu8 cmd = msg->msg[1];\n\tbool is_reply = false;\n\tbool valid_la = true;\n\tbool monitor_valid_la = true;\n\tu8 min_len = 0;\n\n\tif (WARN_ON(!msg->len || msg->len > CEC_MAX_MSG_SIZE))\n\t\treturn;\n\n\tif (adap->devnode.unregistered)\n\t\treturn;\n\n\t \n\tif (msg_init != CEC_LOG_ADDR_UNREGISTERED &&\n\t    cec_has_log_addr(adap, msg_init))\n\t\treturn;\n\n\tmsg->rx_ts = ktime_to_ns(ts);\n\tmsg->rx_status = CEC_RX_STATUS_OK;\n\tmsg->sequence = msg->reply = msg->timeout = 0;\n\tmsg->tx_status = 0;\n\tmsg->tx_ts = 0;\n\tmsg->tx_arb_lost_cnt = 0;\n\tmsg->tx_nack_cnt = 0;\n\tmsg->tx_low_drive_cnt = 0;\n\tmsg->tx_error_cnt = 0;\n\tmsg->flags = 0;\n\tmemset(msg->msg + msg->len, 0, sizeof(msg->msg) - msg->len);\n\n\tmutex_lock(&adap->lock);\n\tdprintk(2, \"%s: %*ph\\n\", __func__, msg->len, msg->msg);\n\n\tif (!adap->transmit_in_progress)\n\t\tadap->last_initiator = 0xff;\n\n\t \n\tif (!cec_msg_is_broadcast(msg)) {\n\t\tvalid_la = cec_has_log_addr(adap, msg_dest);\n\t\tmonitor_valid_la = valid_la;\n\t}\n\n\t \n\tif (valid_la && msg->len > 1 && cec_msg_size[cmd]) {\n\t\tu8 dir_fl = cec_msg_size[cmd] & BOTH;\n\n\t\tmin_len = cec_msg_size[cmd] & 0x1f;\n\t\tif (msg->len < min_len)\n\t\t\tvalid_la = false;\n\t\telse if (!cec_msg_is_broadcast(msg) && !(dir_fl & DIRECTED))\n\t\t\tvalid_la = false;\n\t\telse if (cec_msg_is_broadcast(msg) && !(dir_fl & BCAST))\n\t\t\tvalid_la = false;\n\t\telse if (cec_msg_is_broadcast(msg) &&\n\t\t\t adap->log_addrs.cec_version < CEC_OP_CEC_VERSION_2_0 &&\n\t\t\t !(dir_fl & BCAST1_4))\n\t\t\tvalid_la = false;\n\t}\n\tif (valid_la && min_len) {\n\t\t \n\t\tswitch (cmd) {\n\t\tcase CEC_MSG_TIMER_STATUS:\n\t\t\tif (msg->msg[2] & 0x10) {\n\t\t\t\tswitch (msg->msg[2] & 0xf) {\n\t\t\t\tcase CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE:\n\t\t\t\tcase CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE:\n\t\t\t\t\tif (msg->len < 5)\n\t\t\t\t\t\tvalid_la = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ((msg->msg[2] & 0xf) == CEC_OP_PROG_ERROR_DUPLICATE) {\n\t\t\t\tif (msg->len < 5)\n\t\t\t\t\tvalid_la = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEC_MSG_RECORD_ON:\n\t\t\tswitch (msg->msg[2]) {\n\t\t\tcase CEC_OP_RECORD_SRC_OWN:\n\t\t\t\tbreak;\n\t\t\tcase CEC_OP_RECORD_SRC_DIGITAL:\n\t\t\t\tif (msg->len < 10)\n\t\t\t\t\tvalid_la = false;\n\t\t\t\tbreak;\n\t\t\tcase CEC_OP_RECORD_SRC_ANALOG:\n\t\t\t\tif (msg->len < 7)\n\t\t\t\t\tvalid_la = false;\n\t\t\t\tbreak;\n\t\t\tcase CEC_OP_RECORD_SRC_EXT_PLUG:\n\t\t\t\tif (msg->len < 4)\n\t\t\t\t\tvalid_la = false;\n\t\t\t\tbreak;\n\t\t\tcase CEC_OP_RECORD_SRC_EXT_PHYS_ADDR:\n\t\t\t\tif (msg->len < 5)\n\t\t\t\t\tvalid_la = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (valid_la && msg->len > 1 && cmd != CEC_MSG_CDC_MESSAGE) {\n\t\tbool abort = cmd == CEC_MSG_FEATURE_ABORT;\n\n\t\t \n\t\tif (abort)\n\t\t\tcmd = msg->msg[2];\n\n\t\t \n\t\tlist_for_each_entry(data, &adap->wait_queue, list) {\n\t\t\tstruct cec_msg *dst = &data->msg;\n\n\t\t\t \n\t\t\tif (!abort && dst->msg[1] == CEC_MSG_INITIATE_ARC &&\n\t\t\t    (cmd == CEC_MSG_REPORT_ARC_INITIATED ||\n\t\t\t     cmd == CEC_MSG_REPORT_ARC_TERMINATED) &&\n\t\t\t    (dst->reply == CEC_MSG_REPORT_ARC_INITIATED ||\n\t\t\t     dst->reply == CEC_MSG_REPORT_ARC_TERMINATED))\n\t\t\t\tdst->reply = cmd;\n\n\t\t\t \n\t\t\tif ((abort && cmd != dst->msg[1]) ||\n\t\t\t    (!abort && cmd != dst->reply))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (msg_init != cec_msg_destination(dst) &&\n\t\t\t    !cec_msg_is_broadcast(dst))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmemcpy(dst->msg, msg->msg, msg->len);\n\t\t\tdst->len = msg->len;\n\t\t\tdst->rx_ts = msg->rx_ts;\n\t\t\tdst->rx_status = msg->rx_status;\n\t\t\tif (abort)\n\t\t\t\tdst->rx_status |= CEC_RX_STATUS_FEATURE_ABORT;\n\t\t\tmsg->flags = dst->flags;\n\t\t\tmsg->sequence = dst->sequence;\n\t\t\t \n\t\t\tlist_del_init(&data->list);\n\n\t\t\t \n\t\t\tif (!cancel_delayed_work(&data->work)) {\n\t\t\t\tmutex_unlock(&adap->lock);\n\t\t\t\tcancel_delayed_work_sync(&data->work);\n\t\t\t\tmutex_lock(&adap->lock);\n\t\t\t}\n\t\t\t \n\t\t\tif (data->fh)\n\t\t\t\tis_reply = true;\n\t\t\tcec_data_completed(data);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&adap->lock);\n\n\t \n\tcec_queue_msg_monitor(adap, msg, monitor_valid_la);\n\n\t \n\tif (!valid_la || msg->len <= 1)\n\t\treturn;\n\n\tif (adap->log_addrs.log_addr_mask == 0)\n\t\treturn;\n\n\t \n\tcec_receive_notify(adap, msg, is_reply);\n}\nEXPORT_SYMBOL_GPL(cec_received_msg_ts);\n\n \n\n \nstatic int cec_config_log_addr(struct cec_adapter *adap,\n\t\t\t       unsigned int idx,\n\t\t\t       unsigned int log_addr)\n{\n\tstruct cec_log_addrs *las = &adap->log_addrs;\n\tstruct cec_msg msg = { };\n\tconst unsigned int max_retries = 2;\n\tunsigned int i;\n\tint err;\n\n\tif (cec_has_log_addr(adap, log_addr))\n\t\treturn 0;\n\n\t \n\tmsg.len = 1;\n\tmsg.msg[0] = (log_addr << 4) | log_addr;\n\n\tfor (i = 0; i < max_retries; i++) {\n\t\terr = cec_transmit_msg_fh(adap, &msg, NULL, true);\n\n\t\t \n\t\tif (adap->phys_addr == CEC_PHYS_ADDR_INVALID)\n\t\t\treturn -EINTR;\n\n\t\t \n\t\tif (adap->must_reconfigure)\n\t\t\treturn -EINTR;\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (msg.tx_status &\n\t\t    (CEC_TX_STATUS_ABORTED | CEC_TX_STATUS_TIMEOUT))\n\t\t\treturn -EINTR;\n\t\tif (msg.tx_status & CEC_TX_STATUS_OK)\n\t\t\treturn 0;\n\t\tif (msg.tx_status & CEC_TX_STATUS_NACK)\n\t\t\tbreak;\n\t\t \n\t}\n\n\t \n\tif (i == max_retries) {\n\t\tdprintk(0, \"polling for LA %u failed with tx_status=0x%04x\\n\",\n\t\t\tlog_addr, msg.tx_status);\n\t\treturn 0;\n\t}\n\n\t \n\terr = call_op(adap, adap_log_addr, log_addr);\n\tif (err)\n\t\treturn err;\n\n\tlas->log_addr[idx] = log_addr;\n\tlas->log_addr_mask |= 1 << log_addr;\n\treturn 1;\n}\n\n \nstatic void cec_adap_unconfigure(struct cec_adapter *adap)\n{\n\tif (!adap->needs_hpd || adap->phys_addr != CEC_PHYS_ADDR_INVALID)\n\t\tWARN_ON(call_op(adap, adap_log_addr, CEC_LOG_ADDR_INVALID));\n\tadap->log_addrs.log_addr_mask = 0;\n\tadap->is_configured = false;\n\tcec_flush(adap);\n\twake_up_interruptible(&adap->kthread_waitq);\n\tcec_post_state_event(adap);\n\tcall_void_op(adap, adap_unconfigured);\n}\n\n \nstatic int cec_config_thread_func(void *arg)\n{\n\t \n\tstatic const u8 tv_log_addrs[] = {\n\t\tCEC_LOG_ADDR_TV, CEC_LOG_ADDR_SPECIFIC,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 record_log_addrs[] = {\n\t\tCEC_LOG_ADDR_RECORD_1, CEC_LOG_ADDR_RECORD_2,\n\t\tCEC_LOG_ADDR_RECORD_3,\n\t\tCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 tuner_log_addrs[] = {\n\t\tCEC_LOG_ADDR_TUNER_1, CEC_LOG_ADDR_TUNER_2,\n\t\tCEC_LOG_ADDR_TUNER_3, CEC_LOG_ADDR_TUNER_4,\n\t\tCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 playback_log_addrs[] = {\n\t\tCEC_LOG_ADDR_PLAYBACK_1, CEC_LOG_ADDR_PLAYBACK_2,\n\t\tCEC_LOG_ADDR_PLAYBACK_3,\n\t\tCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 audiosystem_log_addrs[] = {\n\t\tCEC_LOG_ADDR_AUDIOSYSTEM,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 specific_use_log_addrs[] = {\n\t\tCEC_LOG_ADDR_SPECIFIC,\n\t\tCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\n\t\tCEC_LOG_ADDR_INVALID\n\t};\n\tstatic const u8 *type2addrs[6] = {\n\t\t[CEC_LOG_ADDR_TYPE_TV] = tv_log_addrs,\n\t\t[CEC_LOG_ADDR_TYPE_RECORD] = record_log_addrs,\n\t\t[CEC_LOG_ADDR_TYPE_TUNER] = tuner_log_addrs,\n\t\t[CEC_LOG_ADDR_TYPE_PLAYBACK] = playback_log_addrs,\n\t\t[CEC_LOG_ADDR_TYPE_AUDIOSYSTEM] = audiosystem_log_addrs,\n\t\t[CEC_LOG_ADDR_TYPE_SPECIFIC] = specific_use_log_addrs,\n\t};\n\tstatic const u16 type2mask[] = {\n\t\t[CEC_LOG_ADDR_TYPE_TV] = CEC_LOG_ADDR_MASK_TV,\n\t\t[CEC_LOG_ADDR_TYPE_RECORD] = CEC_LOG_ADDR_MASK_RECORD,\n\t\t[CEC_LOG_ADDR_TYPE_TUNER] = CEC_LOG_ADDR_MASK_TUNER,\n\t\t[CEC_LOG_ADDR_TYPE_PLAYBACK] = CEC_LOG_ADDR_MASK_PLAYBACK,\n\t\t[CEC_LOG_ADDR_TYPE_AUDIOSYSTEM] = CEC_LOG_ADDR_MASK_AUDIOSYSTEM,\n\t\t[CEC_LOG_ADDR_TYPE_SPECIFIC] = CEC_LOG_ADDR_MASK_SPECIFIC,\n\t};\n\tstruct cec_adapter *adap = arg;\n\tstruct cec_log_addrs *las = &adap->log_addrs;\n\tint err;\n\tint i, j;\n\n\tmutex_lock(&adap->lock);\n\tdprintk(1, \"physical address: %x.%x.%x.%x, claim %d logical addresses\\n\",\n\t\tcec_phys_addr_exp(adap->phys_addr), las->num_log_addrs);\n\tlas->log_addr_mask = 0;\n\n\tif (las->log_addr_type[0] == CEC_LOG_ADDR_TYPE_UNREGISTERED)\n\t\tgoto configured;\n\nreconfigure:\n\tfor (i = 0; i < las->num_log_addrs; i++) {\n\t\tunsigned int type = las->log_addr_type[i];\n\t\tconst u8 *la_list;\n\t\tu8 last_la;\n\n\t\t \n\t\tif (adap->phys_addr && type == CEC_LOG_ADDR_TYPE_TV)\n\t\t\ttype = CEC_LOG_ADDR_TYPE_SPECIFIC;\n\n\t\tla_list = type2addrs[type];\n\t\tlast_la = las->log_addr[i];\n\t\tlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\n\t\tif (last_la == CEC_LOG_ADDR_INVALID ||\n\t\t    last_la == CEC_LOG_ADDR_UNREGISTERED ||\n\t\t    !((1 << last_la) & type2mask[type]))\n\t\t\tlast_la = la_list[0];\n\n\t\terr = cec_config_log_addr(adap, i, last_la);\n\n\t\tif (adap->must_reconfigure) {\n\t\t\tadap->must_reconfigure = false;\n\t\t\tlas->log_addr_mask = 0;\n\t\t\tgoto reconfigure;\n\t\t}\n\n\t\tif (err > 0)  \n\t\t\tcontinue;\n\n\t\tif (err < 0)\n\t\t\tgoto unconfigure;\n\n\t\tfor (j = 0; la_list[j] != CEC_LOG_ADDR_INVALID; j++) {\n\t\t\t \n\t\t\tif (la_list[j] == last_la)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((la_list[j] == CEC_LOG_ADDR_BACKUP_1 ||\n\t\t\t     la_list[j] == CEC_LOG_ADDR_BACKUP_2) &&\n\t\t\t    las->cec_version < CEC_OP_CEC_VERSION_2_0)\n\t\t\t\tcontinue;\n\n\t\t\terr = cec_config_log_addr(adap, i, la_list[j]);\n\t\t\tif (err == 0)  \n\t\t\t\tcontinue;\n\t\t\tif (err < 0)\n\t\t\t\tgoto unconfigure;\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (la_list[j] == CEC_LOG_ADDR_INVALID)\n\t\t\tdprintk(1, \"could not claim LA %d\\n\", i);\n\t}\n\n\tif (adap->log_addrs.log_addr_mask == 0 &&\n\t    !(las->flags & CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK))\n\t\tgoto unconfigure;\n\nconfigured:\n\tif (adap->log_addrs.log_addr_mask == 0) {\n\t\t \n\t\tlas->log_addr[0] = CEC_LOG_ADDR_UNREGISTERED;\n\t\tlas->log_addr_mask = 1 << las->log_addr[0];\n\t\tfor (i = 1; i < las->num_log_addrs; i++)\n\t\t\tlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\n\t}\n\tfor (i = las->num_log_addrs; i < CEC_MAX_LOG_ADDRS; i++)\n\t\tlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\n\tadap->is_configured = true;\n\tadap->is_configuring = false;\n\tadap->must_reconfigure = false;\n\tcec_post_state_event(adap);\n\n\t \n\tfor (i = 0; i < las->num_log_addrs; i++) {\n\t\tstruct cec_msg msg = {};\n\n\t\tif (las->log_addr[i] == CEC_LOG_ADDR_INVALID ||\n\t\t    (las->flags & CEC_LOG_ADDRS_FL_CDC_ONLY))\n\t\t\tcontinue;\n\n\t\tmsg.msg[0] = (las->log_addr[i] << 4) | 0x0f;\n\n\t\t \n\t\tif (las->log_addr[i] != CEC_LOG_ADDR_UNREGISTERED &&\n\t\t    adap->log_addrs.cec_version >= CEC_OP_CEC_VERSION_2_0) {\n\t\t\tcec_fill_msg_report_features(adap, &msg, i);\n\t\t\tcec_transmit_msg_fh(adap, &msg, NULL, false);\n\t\t}\n\n\t\t \n\t\tcec_msg_report_physical_addr(&msg, adap->phys_addr,\n\t\t\t\t\t     las->primary_device_type[i]);\n\t\tdprintk(1, \"config: la %d pa %x.%x.%x.%x\\n\",\n\t\t\tlas->log_addr[i],\n\t\t\tcec_phys_addr_exp(adap->phys_addr));\n\t\tcec_transmit_msg_fh(adap, &msg, NULL, false);\n\n\t\t \n\t\tif (adap->log_addrs.vendor_id != CEC_VENDOR_ID_NONE) {\n\t\t\tcec_msg_device_vendor_id(&msg,\n\t\t\t\t\t\t adap->log_addrs.vendor_id);\n\t\t\tcec_transmit_msg_fh(adap, &msg, NULL, false);\n\t\t}\n\t}\n\tadap->kthread_config = NULL;\n\tcomplete(&adap->config_completion);\n\tmutex_unlock(&adap->lock);\n\tcall_void_op(adap, configured);\n\treturn 0;\n\nunconfigure:\n\tfor (i = 0; i < las->num_log_addrs; i++)\n\t\tlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\n\tcec_adap_unconfigure(adap);\n\tadap->is_configuring = false;\n\tadap->must_reconfigure = false;\n\tadap->kthread_config = NULL;\n\tcomplete(&adap->config_completion);\n\tmutex_unlock(&adap->lock);\n\treturn 0;\n}\n\n \nstatic void cec_claim_log_addrs(struct cec_adapter *adap, bool block)\n{\n\tif (WARN_ON(adap->is_configuring || adap->is_configured))\n\t\treturn;\n\n\tinit_completion(&adap->config_completion);\n\n\t \n\tadap->is_configuring = true;\n\tadap->kthread_config = kthread_run(cec_config_thread_func, adap,\n\t\t\t\t\t   \"ceccfg-%s\", adap->name);\n\tif (IS_ERR(adap->kthread_config)) {\n\t\tadap->kthread_config = NULL;\n\t\tadap->is_configuring = false;\n\t} else if (block) {\n\t\tmutex_unlock(&adap->lock);\n\t\twait_for_completion(&adap->config_completion);\n\t\tmutex_lock(&adap->lock);\n\t}\n}\n\n \nint cec_adap_enable(struct cec_adapter *adap)\n{\n\tbool enable;\n\tint ret = 0;\n\n\tenable = adap->monitor_all_cnt || adap->monitor_pin_cnt ||\n\t\t adap->log_addrs.num_log_addrs;\n\tif (adap->needs_hpd)\n\t\tenable = enable && adap->phys_addr != CEC_PHYS_ADDR_INVALID;\n\n\tif (adap->devnode.unregistered)\n\t\tenable = false;\n\n\tif (enable == adap->is_enabled)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&adap->devnode.lock);\n\tif (enable) {\n\t\tadap->last_initiator = 0xff;\n\t\tadap->transmit_in_progress = false;\n\t\tret = adap->ops->adap_enable(adap, true);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (adap->monitor_all_cnt)\n\t\t\t\tWARN_ON(call_op(adap, adap_monitor_all_enable, true));\n\t\t\tif (adap->monitor_pin_cnt)\n\t\t\t\tWARN_ON(call_op(adap, adap_monitor_pin_enable, true));\n\t\t}\n\t} else {\n\t\t \n\t\tif (adap->monitor_all_cnt)\n\t\t\tWARN_ON(call_op(adap, adap_monitor_all_enable, false));\n\t\tif (adap->monitor_pin_cnt)\n\t\t\tWARN_ON(call_op(adap, adap_monitor_pin_enable, false));\n\t\tWARN_ON(adap->ops->adap_enable(adap, false));\n\t\tadap->last_initiator = 0xff;\n\t\tadap->transmit_in_progress = false;\n\t\tadap->transmit_in_progress_aborted = false;\n\t\tif (adap->transmitting)\n\t\t\tcec_data_cancel(adap->transmitting, CEC_TX_STATUS_ABORTED, 0);\n\t}\n\tif (!ret)\n\t\tadap->is_enabled = enable;\n\twake_up_interruptible(&adap->kthread_waitq);\n\tmutex_unlock(&adap->devnode.lock);\n\treturn ret;\n}\n\n \nvoid __cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr, bool block)\n{\n\tbool becomes_invalid = phys_addr == CEC_PHYS_ADDR_INVALID;\n\tbool is_invalid = adap->phys_addr == CEC_PHYS_ADDR_INVALID;\n\n\tif (phys_addr == adap->phys_addr)\n\t\treturn;\n\tif (!becomes_invalid && adap->devnode.unregistered)\n\t\treturn;\n\n\tdprintk(1, \"new physical address %x.%x.%x.%x\\n\",\n\t\tcec_phys_addr_exp(phys_addr));\n\tif (becomes_invalid || !is_invalid) {\n\t\tadap->phys_addr = CEC_PHYS_ADDR_INVALID;\n\t\tcec_post_state_event(adap);\n\t\tcec_adap_unconfigure(adap);\n\t\tif (becomes_invalid) {\n\t\t\tcec_adap_enable(adap);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tadap->phys_addr = phys_addr;\n\tif (is_invalid)\n\t\tcec_adap_enable(adap);\n\n\tcec_post_state_event(adap);\n\tif (!adap->log_addrs.num_log_addrs)\n\t\treturn;\n\tif (adap->is_configuring)\n\t\tadap->must_reconfigure = true;\n\telse\n\t\tcec_claim_log_addrs(adap, block);\n}\n\nvoid cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr, bool block)\n{\n\tif (IS_ERR_OR_NULL(adap))\n\t\treturn;\n\n\tmutex_lock(&adap->lock);\n\t__cec_s_phys_addr(adap, phys_addr, block);\n\tmutex_unlock(&adap->lock);\n}\nEXPORT_SYMBOL_GPL(cec_s_phys_addr);\n\nvoid cec_s_phys_addr_from_edid(struct cec_adapter *adap,\n\t\t\t       const struct edid *edid)\n{\n\tu16 pa = CEC_PHYS_ADDR_INVALID;\n\n\tif (edid && edid->extensions)\n\t\tpa = cec_get_edid_phys_addr((const u8 *)edid,\n\t\t\t\tEDID_LENGTH * (edid->extensions + 1), NULL);\n\tcec_s_phys_addr(adap, pa, false);\n}\nEXPORT_SYMBOL_GPL(cec_s_phys_addr_from_edid);\n\nvoid cec_s_conn_info(struct cec_adapter *adap,\n\t\t     const struct cec_connector_info *conn_info)\n{\n\tif (IS_ERR_OR_NULL(adap))\n\t\treturn;\n\n\tif (!(adap->capabilities & CEC_CAP_CONNECTOR_INFO))\n\t\treturn;\n\n\tmutex_lock(&adap->lock);\n\tif (conn_info)\n\t\tadap->conn_info = *conn_info;\n\telse\n\t\tmemset(&adap->conn_info, 0, sizeof(adap->conn_info));\n\tcec_post_state_event(adap);\n\tmutex_unlock(&adap->lock);\n}\nEXPORT_SYMBOL_GPL(cec_s_conn_info);\n\n \nint __cec_s_log_addrs(struct cec_adapter *adap,\n\t\t      struct cec_log_addrs *log_addrs, bool block)\n{\n\tu16 type_mask = 0;\n\tint err;\n\tint i;\n\n\tif (adap->devnode.unregistered)\n\t\treturn -ENODEV;\n\n\tif (!log_addrs || log_addrs->num_log_addrs == 0) {\n\t\tif (!adap->log_addrs.num_log_addrs)\n\t\t\treturn 0;\n\t\tif (adap->is_configuring || adap->is_configured)\n\t\t\tcec_adap_unconfigure(adap);\n\t\tadap->log_addrs.num_log_addrs = 0;\n\t\tfor (i = 0; i < CEC_MAX_LOG_ADDRS; i++)\n\t\t\tadap->log_addrs.log_addr[i] = CEC_LOG_ADDR_INVALID;\n\t\tadap->log_addrs.osd_name[0] = '\\0';\n\t\tadap->log_addrs.vendor_id = CEC_VENDOR_ID_NONE;\n\t\tadap->log_addrs.cec_version = CEC_OP_CEC_VERSION_2_0;\n\t\tcec_adap_enable(adap);\n\t\treturn 0;\n\t}\n\n\tif (log_addrs->flags & CEC_LOG_ADDRS_FL_CDC_ONLY) {\n\t\t \n\t\tlog_addrs->num_log_addrs = 1;\n\t\tlog_addrs->osd_name[0] = '\\0';\n\t\tlog_addrs->vendor_id = CEC_VENDOR_ID_NONE;\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\n\t\t \n\t\tlog_addrs->primary_device_type[0] = CEC_OP_PRIM_DEVTYPE_SWITCH;\n\t\tlog_addrs->all_device_types[0] = 0;\n\t\tlog_addrs->features[0][0] = 0;\n\t\tlog_addrs->features[0][1] = 0;\n\t}\n\n\t \n\tlog_addrs->osd_name[sizeof(log_addrs->osd_name) - 1] = '\\0';\n\n\t \n\tif (log_addrs->num_log_addrs > adap->available_log_addrs) {\n\t\tdprintk(1, \"num_log_addrs > %d\\n\", adap->available_log_addrs);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (log_addrs->vendor_id != CEC_VENDOR_ID_NONE &&\n\t    (log_addrs->vendor_id & 0xff000000) != 0) {\n\t\tdprintk(1, \"invalid vendor ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (log_addrs->cec_version != CEC_OP_CEC_VERSION_1_4 &&\n\t    log_addrs->cec_version != CEC_OP_CEC_VERSION_2_0) {\n\t\tdprintk(1, \"invalid CEC version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (log_addrs->num_log_addrs > 1)\n\t\tfor (i = 0; i < log_addrs->num_log_addrs; i++)\n\t\t\tif (log_addrs->log_addr_type[i] ==\n\t\t\t\t\tCEC_LOG_ADDR_TYPE_UNREGISTERED) {\n\t\t\t\tdprintk(1, \"num_log_addrs > 1 can't be combined with unregistered LA\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\tfor (i = 0; i < log_addrs->num_log_addrs; i++) {\n\t\tconst u8 feature_sz = ARRAY_SIZE(log_addrs->features[0]);\n\t\tu8 *features = log_addrs->features[i];\n\t\tbool op_is_dev_features = false;\n\t\tunsigned int j;\n\n\t\tlog_addrs->log_addr[i] = CEC_LOG_ADDR_INVALID;\n\t\tif (log_addrs->log_addr_type[i] > CEC_LOG_ADDR_TYPE_UNREGISTERED) {\n\t\t\tdprintk(1, \"unknown logical address type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (type_mask & (1 << log_addrs->log_addr_type[i])) {\n\t\t\tdprintk(1, \"duplicate logical address type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttype_mask |= 1 << log_addrs->log_addr_type[i];\n\t\tif ((type_mask & (1 << CEC_LOG_ADDR_TYPE_RECORD)) &&\n\t\t    (type_mask & (1 << CEC_LOG_ADDR_TYPE_PLAYBACK))) {\n\t\t\t \n\t\t\tdprintk(1, \"invalid record + playback combination\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (log_addrs->primary_device_type[i] >\n\t\t\t\t\tCEC_OP_PRIM_DEVTYPE_PROCESSOR) {\n\t\t\tdprintk(1, \"unknown primary device type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (log_addrs->primary_device_type[i] == 2) {\n\t\t\tdprintk(1, \"invalid primary device type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (j = 0; j < feature_sz; j++) {\n\t\t\tif ((features[j] & 0x80) == 0) {\n\t\t\t\tif (op_is_dev_features)\n\t\t\t\t\tbreak;\n\t\t\t\top_is_dev_features = true;\n\t\t\t}\n\t\t}\n\t\tif (!op_is_dev_features || j == feature_sz) {\n\t\t\tdprintk(1, \"malformed features\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tmemset(features + j + 1, 0, feature_sz - j - 1);\n\t}\n\n\tif (log_addrs->cec_version >= CEC_OP_CEC_VERSION_2_0) {\n\t\tif (log_addrs->num_log_addrs > 2) {\n\t\t\tdprintk(1, \"CEC 2.0 allows no more than 2 logical addresses\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (log_addrs->num_log_addrs == 2) {\n\t\t\tif (!(type_mask & ((1 << CEC_LOG_ADDR_TYPE_AUDIOSYSTEM) |\n\t\t\t\t\t   (1 << CEC_LOG_ADDR_TYPE_TV)))) {\n\t\t\t\tdprintk(1, \"two LAs is only allowed for audiosystem and TV\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!(type_mask & ((1 << CEC_LOG_ADDR_TYPE_PLAYBACK) |\n\t\t\t\t\t   (1 << CEC_LOG_ADDR_TYPE_RECORD)))) {\n\t\t\t\tdprintk(1, \"an audiosystem/TV can only be combined with record or playback\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = log_addrs->num_log_addrs; i < CEC_MAX_LOG_ADDRS; i++) {\n\t\tlog_addrs->primary_device_type[i] = 0;\n\t\tlog_addrs->log_addr_type[i] = 0;\n\t\tlog_addrs->all_device_types[i] = 0;\n\t\tmemset(log_addrs->features[i], 0,\n\t\t       sizeof(log_addrs->features[i]));\n\t}\n\n\tlog_addrs->log_addr_mask = adap->log_addrs.log_addr_mask;\n\tadap->log_addrs = *log_addrs;\n\terr = cec_adap_enable(adap);\n\tif (!err && adap->phys_addr != CEC_PHYS_ADDR_INVALID)\n\t\tcec_claim_log_addrs(adap, block);\n\treturn err;\n}\n\nint cec_s_log_addrs(struct cec_adapter *adap,\n\t\t    struct cec_log_addrs *log_addrs, bool block)\n{\n\tint err;\n\n\tmutex_lock(&adap->lock);\n\terr = __cec_s_log_addrs(adap, log_addrs, block);\n\tmutex_unlock(&adap->lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cec_s_log_addrs);\n\n \n\n \nstatic void cec_fill_msg_report_features(struct cec_adapter *adap,\n\t\t\t\t\t struct cec_msg *msg,\n\t\t\t\t\t unsigned int la_idx)\n{\n\tconst struct cec_log_addrs *las = &adap->log_addrs;\n\tconst u8 *features = las->features[la_idx];\n\tbool op_is_dev_features = false;\n\tunsigned int idx;\n\n\t \n\tmsg->msg[0] = (las->log_addr[la_idx] << 4) | 0x0f;\n\tmsg->len = 4;\n\tmsg->msg[1] = CEC_MSG_REPORT_FEATURES;\n\tmsg->msg[2] = adap->log_addrs.cec_version;\n\tmsg->msg[3] = las->all_device_types[la_idx];\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(las->features[0]); idx++) {\n\t\tmsg->msg[msg->len++] = features[idx];\n\t\tif ((features[idx] & CEC_OP_FEAT_EXT) == 0) {\n\t\t\tif (op_is_dev_features)\n\t\t\t\tbreak;\n\t\t\top_is_dev_features = true;\n\t\t}\n\t}\n}\n\n \nstatic int cec_feature_abort_reason(struct cec_adapter *adap,\n\t\t\t\t    struct cec_msg *msg, u8 reason)\n{\n\tstruct cec_msg tx_msg = { };\n\n\t \n\tif (msg->msg[1] == CEC_MSG_FEATURE_ABORT)\n\t\treturn 0;\n\t \n\tif (cec_msg_initiator(msg) == CEC_LOG_ADDR_UNREGISTERED)\n\t\treturn 0;\n\tcec_msg_set_reply_to(&tx_msg, msg);\n\tcec_msg_feature_abort(&tx_msg, msg->msg[1], reason);\n\treturn cec_transmit_msg(adap, &tx_msg, false);\n}\n\nstatic int cec_feature_abort(struct cec_adapter *adap, struct cec_msg *msg)\n{\n\treturn cec_feature_abort_reason(adap, msg,\n\t\t\t\t\tCEC_OP_ABORT_UNRECOGNIZED_OP);\n}\n\nstatic int cec_feature_refused(struct cec_adapter *adap, struct cec_msg *msg)\n{\n\treturn cec_feature_abort_reason(adap, msg,\n\t\t\t\t\tCEC_OP_ABORT_REFUSED);\n}\n\n \nstatic int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,\n\t\t\t      bool is_reply)\n{\n\tbool is_broadcast = cec_msg_is_broadcast(msg);\n\tu8 dest_laddr = cec_msg_destination(msg);\n\tu8 init_laddr = cec_msg_initiator(msg);\n\tu8 devtype = cec_log_addr2dev(adap, dest_laddr);\n\tint la_idx = cec_log_addr2idx(adap, dest_laddr);\n\tbool from_unregistered = init_laddr == 0xf;\n\tstruct cec_msg tx_cec_msg = { };\n\n\tdprintk(2, \"%s: %*ph\\n\", __func__, msg->len, msg->msg);\n\n\t \n\tif (cec_is_cdc_only(&adap->log_addrs) &&\n\t    msg->msg[1] != CEC_MSG_CDC_MESSAGE)\n\t\treturn 0;\n\n\t \n\tif (adap->ops->received && !adap->devnode.unregistered &&\n\t    adap->ops->received(adap, msg) != -ENOMSG)\n\t\treturn 0;\n\n\t \n\tswitch (msg->msg[1]) {\n\tcase CEC_MSG_GET_CEC_VERSION:\n\tcase CEC_MSG_ABORT:\n\tcase CEC_MSG_GIVE_DEVICE_POWER_STATUS:\n\tcase CEC_MSG_GIVE_OSD_NAME:\n\t\t \n\t\tif (!adap->passthrough && from_unregistered)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase CEC_MSG_GIVE_DEVICE_VENDOR_ID:\n\tcase CEC_MSG_GIVE_FEATURES:\n\tcase CEC_MSG_GIVE_PHYSICAL_ADDR:\n\t\t \n\t\tif (adap->passthrough)\n\t\t\tgoto skip_processing;\n\t\t \n\t\tif (is_broadcast)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase CEC_MSG_USER_CONTROL_PRESSED:\n\tcase CEC_MSG_USER_CONTROL_RELEASED:\n\t\t \n\t\tif (is_broadcast || from_unregistered)\n\t\t\tgoto skip_processing;\n\t\tbreak;\n\n\tcase CEC_MSG_REPORT_PHYSICAL_ADDR:\n\t\t \n\t\tif (!is_broadcast)\n\t\t\tgoto skip_processing;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcec_msg_set_reply_to(&tx_cec_msg, msg);\n\n\tswitch (msg->msg[1]) {\n\t \n\tcase CEC_MSG_REPORT_PHYSICAL_ADDR: {\n\t\tu16 pa = (msg->msg[2] << 8) | msg->msg[3];\n\n\t\tdprintk(1, \"reported physical address %x.%x.%x.%x for logical address %d\\n\",\n\t\t\tcec_phys_addr_exp(pa), init_laddr);\n\t\tbreak;\n\t}\n\n\tcase CEC_MSG_USER_CONTROL_PRESSED:\n\t\tif (!(adap->capabilities & CEC_CAP_RC) ||\n\t\t    !(adap->log_addrs.flags & CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU))\n\t\t\tbreak;\n\n#ifdef CONFIG_MEDIA_CEC_RC\n\t\tswitch (msg->msg[2]) {\n\t\t \n\t\tcase CEC_OP_UI_CMD_PLAY_FUNCTION:\n\t\t\tif (msg->len == 2)\n\t\t\t\trc_keydown(adap->rc, RC_PROTO_CEC,\n\t\t\t\t\t   msg->msg[2], 0);\n\t\t\telse\n\t\t\t\trc_keydown(adap->rc, RC_PROTO_CEC,\n\t\t\t\t\t   msg->msg[2] << 8 | msg->msg[3], 0);\n\t\t\tbreak;\n\t\t \n\t\tcase CEC_OP_UI_CMD_SELECT_BROADCAST_TYPE:\n\t\tcase CEC_OP_UI_CMD_SELECT_SOUND_PRESENTATION:\n\t\tcase CEC_OP_UI_CMD_TUNE_FUNCTION:\n\t\tcase CEC_OP_UI_CMD_SELECT_MEDIA_FUNCTION:\n\t\tcase CEC_OP_UI_CMD_SELECT_AV_INPUT_FUNCTION:\n\t\tcase CEC_OP_UI_CMD_SELECT_AUDIO_INPUT_FUNCTION:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc_keydown(adap->rc, RC_PROTO_CEC, msg->msg[2], 0);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase CEC_MSG_USER_CONTROL_RELEASED:\n\t\tif (!(adap->capabilities & CEC_CAP_RC) ||\n\t\t    !(adap->log_addrs.flags & CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU))\n\t\t\tbreak;\n#ifdef CONFIG_MEDIA_CEC_RC\n\t\trc_keyup(adap->rc);\n#endif\n\t\tbreak;\n\n\t \n\tcase CEC_MSG_GET_CEC_VERSION:\n\t\tcec_msg_cec_version(&tx_cec_msg, adap->log_addrs.cec_version);\n\t\treturn cec_transmit_msg(adap, &tx_cec_msg, false);\n\n\tcase CEC_MSG_GIVE_PHYSICAL_ADDR:\n\t\t \n\t\tif (devtype == CEC_OP_PRIM_DEVTYPE_SWITCH && dest_laddr == 15)\n\t\t\treturn 0;\n\t\tcec_msg_report_physical_addr(&tx_cec_msg, adap->phys_addr, devtype);\n\t\treturn cec_transmit_msg(adap, &tx_cec_msg, false);\n\n\tcase CEC_MSG_GIVE_DEVICE_VENDOR_ID:\n\t\tif (adap->log_addrs.vendor_id == CEC_VENDOR_ID_NONE)\n\t\t\treturn cec_feature_abort(adap, msg);\n\t\tcec_msg_device_vendor_id(&tx_cec_msg, adap->log_addrs.vendor_id);\n\t\treturn cec_transmit_msg(adap, &tx_cec_msg, false);\n\n\tcase CEC_MSG_ABORT:\n\t\t \n\t\tif (devtype == CEC_OP_PRIM_DEVTYPE_SWITCH)\n\t\t\treturn 0;\n\t\treturn cec_feature_refused(adap, msg);\n\n\tcase CEC_MSG_GIVE_OSD_NAME: {\n\t\tif (adap->log_addrs.osd_name[0] == 0)\n\t\t\treturn cec_feature_abort(adap, msg);\n\t\tcec_msg_set_osd_name(&tx_cec_msg, adap->log_addrs.osd_name);\n\t\treturn cec_transmit_msg(adap, &tx_cec_msg, false);\n\t}\n\n\tcase CEC_MSG_GIVE_FEATURES:\n\t\tif (adap->log_addrs.cec_version < CEC_OP_CEC_VERSION_2_0)\n\t\t\treturn cec_feature_abort(adap, msg);\n\t\tcec_fill_msg_report_features(adap, &tx_cec_msg, la_idx);\n\t\treturn cec_transmit_msg(adap, &tx_cec_msg, false);\n\n\tdefault:\n\t\t \n\t\tif (!is_broadcast && !is_reply && !adap->follower_cnt &&\n\t\t    !adap->cec_follower && msg->msg[1] != CEC_MSG_FEATURE_ABORT)\n\t\t\treturn cec_feature_abort(adap, msg);\n\t\tbreak;\n\t}\n\nskip_processing:\n\t \n\tif (is_reply && !(msg->flags & CEC_MSG_FL_REPLY_TO_FOLLOWERS))\n\t\treturn 0;\n\n\t \n\tif (adap->cec_follower)\n\t\tcec_queue_msg_fh(adap->cec_follower, msg);\n\telse\n\t\tcec_queue_msg_followers(adap, msg);\n\treturn 0;\n}\n\n \nint cec_monitor_all_cnt_inc(struct cec_adapter *adap)\n{\n\tint ret;\n\n\tif (adap->monitor_all_cnt++)\n\t\treturn 0;\n\n\tret = cec_adap_enable(adap);\n\tif (ret)\n\t\tadap->monitor_all_cnt--;\n\treturn ret;\n}\n\nvoid cec_monitor_all_cnt_dec(struct cec_adapter *adap)\n{\n\tif (WARN_ON(!adap->monitor_all_cnt))\n\t\treturn;\n\tif (--adap->monitor_all_cnt)\n\t\treturn;\n\tWARN_ON(call_op(adap, adap_monitor_all_enable, false));\n\tcec_adap_enable(adap);\n}\n\n \nint cec_monitor_pin_cnt_inc(struct cec_adapter *adap)\n{\n\tint ret;\n\n\tif (adap->monitor_pin_cnt++)\n\t\treturn 0;\n\n\tret = cec_adap_enable(adap);\n\tif (ret)\n\t\tadap->monitor_pin_cnt--;\n\treturn ret;\n}\n\nvoid cec_monitor_pin_cnt_dec(struct cec_adapter *adap)\n{\n\tif (WARN_ON(!adap->monitor_pin_cnt))\n\t\treturn;\n\tif (--adap->monitor_pin_cnt)\n\t\treturn;\n\tWARN_ON(call_op(adap, adap_monitor_pin_enable, false));\n\tcec_adap_enable(adap);\n}\n\n#ifdef CONFIG_DEBUG_FS\n \nint cec_adap_status(struct seq_file *file, void *priv)\n{\n\tstruct cec_adapter *adap = dev_get_drvdata(file->private);\n\tstruct cec_data *data;\n\n\tmutex_lock(&adap->lock);\n\tseq_printf(file, \"enabled: %d\\n\", adap->is_enabled);\n\tseq_printf(file, \"configured: %d\\n\", adap->is_configured);\n\tseq_printf(file, \"configuring: %d\\n\", adap->is_configuring);\n\tseq_printf(file, \"phys_addr: %x.%x.%x.%x\\n\",\n\t\t   cec_phys_addr_exp(adap->phys_addr));\n\tseq_printf(file, \"number of LAs: %d\\n\", adap->log_addrs.num_log_addrs);\n\tseq_printf(file, \"LA mask: 0x%04x\\n\", adap->log_addrs.log_addr_mask);\n\tif (adap->cec_follower)\n\t\tseq_printf(file, \"has CEC follower%s\\n\",\n\t\t\t   adap->passthrough ? \" (in passthrough mode)\" : \"\");\n\tif (adap->cec_initiator)\n\t\tseq_puts(file, \"has CEC initiator\\n\");\n\tif (adap->monitor_all_cnt)\n\t\tseq_printf(file, \"file handles in Monitor All mode: %u\\n\",\n\t\t\t   adap->monitor_all_cnt);\n\tif (adap->monitor_pin_cnt)\n\t\tseq_printf(file, \"file handles in Monitor Pin mode: %u\\n\",\n\t\t\t   adap->monitor_pin_cnt);\n\tif (adap->tx_timeouts) {\n\t\tseq_printf(file, \"transmit timeouts: %u\\n\",\n\t\t\t   adap->tx_timeouts);\n\t\tadap->tx_timeouts = 0;\n\t}\n\tdata = adap->transmitting;\n\tif (data)\n\t\tseq_printf(file, \"transmitting message: %*ph (reply: %02x, timeout: %ums)\\n\",\n\t\t\t   data->msg.len, data->msg.msg, data->msg.reply,\n\t\t\t   data->msg.timeout);\n\tseq_printf(file, \"pending transmits: %u\\n\", adap->transmit_queue_sz);\n\tlist_for_each_entry(data, &adap->transmit_queue, list) {\n\t\tseq_printf(file, \"queued tx message: %*ph (reply: %02x, timeout: %ums)\\n\",\n\t\t\t   data->msg.len, data->msg.msg, data->msg.reply,\n\t\t\t   data->msg.timeout);\n\t}\n\tlist_for_each_entry(data, &adap->wait_queue, list) {\n\t\tseq_printf(file, \"message waiting for reply: %*ph (reply: %02x, timeout: %ums)\\n\",\n\t\t\t   data->msg.len, data->msg.msg, data->msg.reply,\n\t\t\t   data->msg.timeout);\n\t}\n\n\tcall_void_op(adap, adap_status, file);\n\tmutex_unlock(&adap->lock);\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}