{
  "module_name": "cec-core.c",
  "hash_id": "34166cdf97a2070e0e84485de668c7a7488a53c34067b229dc80410a29ffa6da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-core.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"cec-priv.h\"\n\n#define CEC_NUM_DEVICES\t256\n#define CEC_NAME\t\"cec\"\n\n \n#define CEC_XFER_TIMEOUT_MS (5 * 400 + 100)\n\nint cec_debug;\nmodule_param_named(debug, cec_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nstatic bool debug_phys_addr;\nmodule_param(debug_phys_addr, bool, 0644);\nMODULE_PARM_DESC(debug_phys_addr, \"add CEC_CAP_PHYS_ADDR if set\");\n\nstatic dev_t cec_dev_t;\n\n \nstatic DEFINE_MUTEX(cec_devnode_lock);\nstatic DECLARE_BITMAP(cec_devnode_nums, CEC_NUM_DEVICES);\n\nstatic struct dentry *top_cec_dir;\n\n \n#define to_cec_devnode(cd) container_of(cd, struct cec_devnode, dev)\n\nint cec_get_device(struct cec_devnode *devnode)\n{\n\t \n\tmutex_lock(&devnode->lock);\n\t \n\tif (!devnode->registered) {\n\t\tmutex_unlock(&devnode->lock);\n\t\treturn -ENXIO;\n\t}\n\t \n\tget_device(&devnode->dev);\n\tmutex_unlock(&devnode->lock);\n\treturn 0;\n}\n\nvoid cec_put_device(struct cec_devnode *devnode)\n{\n\tput_device(&devnode->dev);\n}\n\n \nstatic void cec_devnode_release(struct device *cd)\n{\n\tstruct cec_devnode *devnode = to_cec_devnode(cd);\n\n\tmutex_lock(&cec_devnode_lock);\n\t \n\tclear_bit(devnode->minor, cec_devnode_nums);\n\tmutex_unlock(&cec_devnode_lock);\n\n\tcec_delete_adapter(to_cec_adapter(devnode));\n}\n\nstatic struct bus_type cec_bus_type = {\n\t.name = CEC_NAME,\n};\n\n \nstatic int __must_check cec_devnode_register(struct cec_devnode *devnode,\n\t\t\t\t\t     struct module *owner)\n{\n\tint minor;\n\tint ret;\n\n\t \n\tmutex_lock(&cec_devnode_lock);\n\tminor = find_first_zero_bit(cec_devnode_nums, CEC_NUM_DEVICES);\n\tif (minor == CEC_NUM_DEVICES) {\n\t\tmutex_unlock(&cec_devnode_lock);\n\t\tpr_err(\"could not get a free minor\\n\");\n\t\treturn -ENFILE;\n\t}\n\n\tset_bit(minor, cec_devnode_nums);\n\tmutex_unlock(&cec_devnode_lock);\n\n\tdevnode->minor = minor;\n\tdevnode->dev.bus = &cec_bus_type;\n\tdevnode->dev.devt = MKDEV(MAJOR(cec_dev_t), minor);\n\tdevnode->dev.release = cec_devnode_release;\n\tdev_set_name(&devnode->dev, \"cec%d\", devnode->minor);\n\tdevice_initialize(&devnode->dev);\n\n\t \n\tcdev_init(&devnode->cdev, &cec_devnode_fops);\n\tdevnode->cdev.owner = owner;\n\tkobject_set_name(&devnode->cdev.kobj, \"cec%d\", devnode->minor);\n\n\tdevnode->registered = true;\n\tret = cdev_device_add(&devnode->cdev, &devnode->dev);\n\tif (ret) {\n\t\tdevnode->registered = false;\n\t\tpr_err(\"%s: cdev_device_add failed\\n\", __func__);\n\t\tgoto clr_bit;\n\t}\n\n\treturn 0;\n\nclr_bit:\n\tmutex_lock(&cec_devnode_lock);\n\tclear_bit(devnode->minor, cec_devnode_nums);\n\tmutex_unlock(&cec_devnode_lock);\n\treturn ret;\n}\n\n \nstatic void cec_devnode_unregister(struct cec_adapter *adap)\n{\n\tstruct cec_devnode *devnode = &adap->devnode;\n\tstruct cec_fh *fh;\n\n\tmutex_lock(&devnode->lock);\n\n\t \n\tif (!devnode->registered || devnode->unregistered) {\n\t\tmutex_unlock(&devnode->lock);\n\t\treturn;\n\t}\n\tdevnode->registered = false;\n\tdevnode->unregistered = true;\n\n\tmutex_lock(&devnode->lock_fhs);\n\tlist_for_each_entry(fh, &devnode->fhs, list)\n\t\twake_up_interruptible(&fh->wait);\n\tmutex_unlock(&devnode->lock_fhs);\n\n\tmutex_unlock(&devnode->lock);\n\n\tmutex_lock(&adap->lock);\n\t__cec_s_phys_addr(adap, CEC_PHYS_ADDR_INVALID, false);\n\t__cec_s_log_addrs(adap, NULL, false);\n\t \n\tcec_adap_enable(adap);\n\tmutex_unlock(&adap->lock);\n\n\tcdev_device_del(&devnode->cdev, &devnode->dev);\n\tput_device(&devnode->dev);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t cec_error_inj_write(struct file *file,\n\tconst char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct cec_adapter *adap = sf->private;\n\tchar *buf;\n\tchar *line;\n\tchar *p;\n\n\tbuf = memdup_user_nul(ubuf, min_t(size_t, PAGE_SIZE, count));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tp = buf;\n\twhile (p && *p) {\n\t\tp = skip_spaces(p);\n\t\tline = strsep(&p, \"\\n\");\n\t\tif (!*line || *line == '#')\n\t\t\tcontinue;\n\t\tif (!call_op(adap, error_inj_parse_line, line)) {\n\t\t\tkfree(buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tkfree(buf);\n\treturn count;\n}\n\nstatic int cec_error_inj_show(struct seq_file *sf, void *unused)\n{\n\tstruct cec_adapter *adap = sf->private;\n\n\treturn call_op(adap, error_inj_show, sf);\n}\n\nstatic int cec_error_inj_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cec_error_inj_show, inode->i_private);\n}\n\nstatic const struct file_operations cec_error_inj_fops = {\n\t.open = cec_error_inj_open,\n\t.write = cec_error_inj_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n#endif\n\nstruct cec_adapter *cec_allocate_adapter(const struct cec_adap_ops *ops,\n\t\t\t\t\t void *priv, const char *name, u32 caps,\n\t\t\t\t\t u8 available_las)\n{\n\tstruct cec_adapter *adap;\n\tint res;\n\n#ifndef CONFIG_MEDIA_CEC_RC\n\tcaps &= ~CEC_CAP_RC;\n#endif\n\n\tif (WARN_ON(!caps))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(!ops))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(!available_las || available_las > CEC_MAX_LOG_ADDRS))\n\t\treturn ERR_PTR(-EINVAL);\n\tadap = kzalloc(sizeof(*adap), GFP_KERNEL);\n\tif (!adap)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrscpy(adap->name, name, sizeof(adap->name));\n\tadap->phys_addr = CEC_PHYS_ADDR_INVALID;\n\tadap->cec_pin_is_high = true;\n\tadap->log_addrs.cec_version = CEC_OP_CEC_VERSION_2_0;\n\tadap->log_addrs.vendor_id = CEC_VENDOR_ID_NONE;\n\tadap->capabilities = caps;\n\tif (debug_phys_addr)\n\t\tadap->capabilities |= CEC_CAP_PHYS_ADDR;\n\tadap->needs_hpd = caps & CEC_CAP_NEEDS_HPD;\n\tadap->available_log_addrs = available_las;\n\tadap->sequence = 0;\n\tadap->ops = ops;\n\tadap->priv = priv;\n\tmutex_init(&adap->lock);\n\tINIT_LIST_HEAD(&adap->transmit_queue);\n\tINIT_LIST_HEAD(&adap->wait_queue);\n\tinit_waitqueue_head(&adap->kthread_waitq);\n\n\t \n\tINIT_LIST_HEAD(&adap->devnode.fhs);\n\tmutex_init(&adap->devnode.lock_fhs);\n\tmutex_init(&adap->devnode.lock);\n\n\tadap->kthread = kthread_run(cec_thread_func, adap, \"cec-%s\", name);\n\tif (IS_ERR(adap->kthread)) {\n\t\tpr_err(\"cec-%s: kernel_thread() failed\\n\", name);\n\t\tres = PTR_ERR(adap->kthread);\n\t\tkfree(adap);\n\t\treturn ERR_PTR(res);\n\t}\n\n#ifdef CONFIG_MEDIA_CEC_RC\n\tif (!(caps & CEC_CAP_RC))\n\t\treturn adap;\n\n\t \n\tadap->rc = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!adap->rc) {\n\t\tpr_err(\"cec-%s: failed to allocate memory for rc_dev\\n\",\n\t\t       name);\n\t\tkthread_stop(adap->kthread);\n\t\tkfree(adap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsnprintf(adap->input_phys, sizeof(adap->input_phys),\n\t\t \"%s/input0\", adap->name);\n\n\tadap->rc->device_name = adap->name;\n\tadap->rc->input_phys = adap->input_phys;\n\tadap->rc->input_id.bustype = BUS_CEC;\n\tadap->rc->input_id.vendor = 0;\n\tadap->rc->input_id.product = 0;\n\tadap->rc->input_id.version = 1;\n\tadap->rc->driver_name = CEC_NAME;\n\tadap->rc->allowed_protocols = RC_PROTO_BIT_CEC;\n\tadap->rc->priv = adap;\n\tadap->rc->map_name = RC_MAP_CEC;\n\tadap->rc->timeout = MS_TO_US(550);\n#endif\n\treturn adap;\n}\nEXPORT_SYMBOL_GPL(cec_allocate_adapter);\n\nint cec_register_adapter(struct cec_adapter *adap,\n\t\t\t struct device *parent)\n{\n\tint res;\n\n\tif (IS_ERR_OR_NULL(adap))\n\t\treturn 0;\n\n\tif (WARN_ON(!parent))\n\t\treturn -EINVAL;\n\n\tadap->owner = parent->driver->owner;\n\tadap->devnode.dev.parent = parent;\n\tif (!adap->xfer_timeout_ms)\n\t\tadap->xfer_timeout_ms = CEC_XFER_TIMEOUT_MS;\n\n#ifdef CONFIG_MEDIA_CEC_RC\n\tif (adap->capabilities & CEC_CAP_RC) {\n\t\tadap->rc->dev.parent = parent;\n\t\tres = rc_register_device(adap->rc);\n\n\t\tif (res) {\n\t\t\tpr_err(\"cec-%s: failed to prepare input device\\n\",\n\t\t\t       adap->name);\n\t\t\trc_free_device(adap->rc);\n\t\t\tadap->rc = NULL;\n\t\t\treturn res;\n\t\t}\n\t}\n#endif\n\n\tres = cec_devnode_register(&adap->devnode, adap->owner);\n\tif (res) {\n#ifdef CONFIG_MEDIA_CEC_RC\n\t\t \n\t\trc_unregister_device(adap->rc);\n\t\tadap->rc = NULL;\n#endif\n\t\treturn res;\n\t}\n\n\tdev_set_drvdata(&adap->devnode.dev, adap);\n#ifdef CONFIG_DEBUG_FS\n\tif (!top_cec_dir)\n\t\treturn 0;\n\n\tadap->cec_dir = debugfs_create_dir(dev_name(&adap->devnode.dev),\n\t\t\t\t\t   top_cec_dir);\n\n\tdebugfs_create_devm_seqfile(&adap->devnode.dev, \"status\", adap->cec_dir,\n\t\t\t\t    cec_adap_status);\n\n\tif (!adap->ops->error_inj_show || !adap->ops->error_inj_parse_line)\n\t\treturn 0;\n\tdebugfs_create_file(\"error-inj\", 0644, adap->cec_dir, adap,\n\t\t\t    &cec_error_inj_fops);\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cec_register_adapter);\n\nvoid cec_unregister_adapter(struct cec_adapter *adap)\n{\n\tif (IS_ERR_OR_NULL(adap))\n\t\treturn;\n\n#ifdef CONFIG_MEDIA_CEC_RC\n\t \n\trc_unregister_device(adap->rc);\n\tadap->rc = NULL;\n#endif\n\tdebugfs_remove_recursive(adap->cec_dir);\n#ifdef CONFIG_CEC_NOTIFIER\n\tcec_notifier_cec_adap_unregister(adap->notifier, adap);\n#endif\n\tcec_devnode_unregister(adap);\n}\nEXPORT_SYMBOL_GPL(cec_unregister_adapter);\n\nvoid cec_delete_adapter(struct cec_adapter *adap)\n{\n\tif (IS_ERR_OR_NULL(adap))\n\t\treturn;\n\tif (adap->kthread_config)\n\t\tkthread_stop(adap->kthread_config);\n\tkthread_stop(adap->kthread);\n\tif (adap->ops->adap_free)\n\t\tadap->ops->adap_free(adap);\n#ifdef CONFIG_MEDIA_CEC_RC\n\trc_free_device(adap->rc);\n#endif\n\tkfree(adap);\n}\nEXPORT_SYMBOL_GPL(cec_delete_adapter);\n\n \nstatic int __init cec_devnode_init(void)\n{\n\tint ret = alloc_chrdev_region(&cec_dev_t, 0, CEC_NUM_DEVICES, CEC_NAME);\n\n\tif (ret < 0) {\n\t\tpr_warn(\"cec: unable to allocate major\\n\");\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\ttop_cec_dir = debugfs_create_dir(\"cec\", NULL);\n\tif (IS_ERR_OR_NULL(top_cec_dir)) {\n\t\tpr_warn(\"cec: Failed to create debugfs cec dir\\n\");\n\t\ttop_cec_dir = NULL;\n\t}\n#endif\n\n\tret = bus_register(&cec_bus_type);\n\tif (ret < 0) {\n\t\tunregister_chrdev_region(cec_dev_t, CEC_NUM_DEVICES);\n\t\tpr_warn(\"cec: bus_register failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cec_devnode_exit(void)\n{\n\tdebugfs_remove_recursive(top_cec_dir);\n\tbus_unregister(&cec_bus_type);\n\tunregister_chrdev_region(cec_dev_t, CEC_NUM_DEVICES);\n}\n\nsubsys_initcall(cec_devnode_init);\nmodule_exit(cec_devnode_exit)\n\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com>\");\nMODULE_DESCRIPTION(\"Device node registration for cec drivers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}