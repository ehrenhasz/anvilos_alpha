{
  "module_name": "cec-pin-error-inj.c",
  "hash_id": "50f22d2789bc5ac8942f10c670a514751f341c147e672fcc960a38f3878860e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-pin-error-inj.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sched/types.h>\n\n#include <media/cec-pin.h>\n#include \"cec-pin-priv.h\"\n\nstruct cec_error_inj_cmd {\n\tunsigned int mode_offset;\n\tint arg_idx;\n\tconst char *cmd;\n};\n\nstatic const struct cec_error_inj_cmd cec_error_inj_cmds[] = {\n\t{ CEC_ERROR_INJ_RX_NACK_OFFSET, -1, \"rx-nack\" },\n\t{ CEC_ERROR_INJ_RX_LOW_DRIVE_OFFSET,\n\t  CEC_ERROR_INJ_RX_LOW_DRIVE_ARG_IDX, \"rx-low-drive\" },\n\t{ CEC_ERROR_INJ_RX_ADD_BYTE_OFFSET, -1, \"rx-add-byte\" },\n\t{ CEC_ERROR_INJ_RX_REMOVE_BYTE_OFFSET, -1, \"rx-remove-byte\" },\n\t{ CEC_ERROR_INJ_RX_ARB_LOST_OFFSET,\n\t  CEC_ERROR_INJ_RX_ARB_LOST_ARG_IDX, \"rx-arb-lost\" },\n\n\t{ CEC_ERROR_INJ_TX_NO_EOM_OFFSET, -1, \"tx-no-eom\" },\n\t{ CEC_ERROR_INJ_TX_EARLY_EOM_OFFSET, -1, \"tx-early-eom\" },\n\t{ CEC_ERROR_INJ_TX_ADD_BYTES_OFFSET,\n\t  CEC_ERROR_INJ_TX_ADD_BYTES_ARG_IDX, \"tx-add-bytes\" },\n\t{ CEC_ERROR_INJ_TX_REMOVE_BYTE_OFFSET, -1, \"tx-remove-byte\" },\n\t{ CEC_ERROR_INJ_TX_SHORT_BIT_OFFSET,\n\t  CEC_ERROR_INJ_TX_SHORT_BIT_ARG_IDX, \"tx-short-bit\" },\n\t{ CEC_ERROR_INJ_TX_LONG_BIT_OFFSET,\n\t  CEC_ERROR_INJ_TX_LONG_BIT_ARG_IDX, \"tx-long-bit\" },\n\t{ CEC_ERROR_INJ_TX_CUSTOM_BIT_OFFSET,\n\t  CEC_ERROR_INJ_TX_CUSTOM_BIT_ARG_IDX, \"tx-custom-bit\" },\n\t{ CEC_ERROR_INJ_TX_SHORT_START_OFFSET, -1, \"tx-short-start\" },\n\t{ CEC_ERROR_INJ_TX_LONG_START_OFFSET, -1, \"tx-long-start\" },\n\t{ CEC_ERROR_INJ_TX_CUSTOM_START_OFFSET, -1, \"tx-custom-start\" },\n\t{ CEC_ERROR_INJ_TX_LAST_BIT_OFFSET,\n\t  CEC_ERROR_INJ_TX_LAST_BIT_ARG_IDX, \"tx-last-bit\" },\n\t{ CEC_ERROR_INJ_TX_LOW_DRIVE_OFFSET,\n\t  CEC_ERROR_INJ_TX_LOW_DRIVE_ARG_IDX, \"tx-low-drive\" },\n\t{ 0, -1, NULL }\n};\n\nu16 cec_pin_rx_error_inj(struct cec_pin *pin)\n{\n\tu16 cmd = CEC_ERROR_INJ_OP_ANY;\n\n\t \n\tif (!(pin->error_inj[cmd] & CEC_ERROR_INJ_RX_MASK) &&\n\t    pin->rx_bit >= 18)\n\t\tcmd = pin->rx_msg.msg[1];\n\treturn (pin->error_inj[cmd] & CEC_ERROR_INJ_RX_MASK) ? cmd :\n\t\tCEC_ERROR_INJ_OP_ANY;\n}\n\nu16 cec_pin_tx_error_inj(struct cec_pin *pin)\n{\n\tu16 cmd = CEC_ERROR_INJ_OP_ANY;\n\n\tif (!(pin->error_inj[cmd] & CEC_ERROR_INJ_TX_MASK) &&\n\t    pin->tx_msg.len > 1)\n\t\tcmd = pin->tx_msg.msg[1];\n\treturn (pin->error_inj[cmd] & CEC_ERROR_INJ_TX_MASK) ? cmd :\n\t\tCEC_ERROR_INJ_OP_ANY;\n}\n\nbool cec_pin_error_inj_parse_line(struct cec_adapter *adap, char *line)\n{\n\tstatic const char *delims = \" \\t\\r\";\n\tstruct cec_pin *pin = adap->pin;\n\tunsigned int i;\n\tbool has_pos = false;\n\tchar *p = line;\n\tchar *token;\n\tchar *comma;\n\tu64 *error;\n\tu8 *args;\n\tbool has_op;\n\tu8 op;\n\tu8 mode;\n\tu8 pos;\n\n\tp = skip_spaces(p);\n\ttoken = strsep(&p, delims);\n\tif (!strcmp(token, \"clear\")) {\n\t\tmemset(pin->error_inj, 0, sizeof(pin->error_inj));\n\t\tpin->rx_toggle = pin->tx_toggle = false;\n\t\tpin->tx_ignore_nack_until_eom = false;\n\t\tpin->tx_custom_pulse = false;\n\t\tpin->tx_custom_low_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\t\tpin->tx_custom_high_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"rx-clear\")) {\n\t\tfor (i = 0; i <= CEC_ERROR_INJ_OP_ANY; i++)\n\t\t\tpin->error_inj[i] &= ~CEC_ERROR_INJ_RX_MASK;\n\t\tpin->rx_toggle = false;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"tx-clear\")) {\n\t\tfor (i = 0; i <= CEC_ERROR_INJ_OP_ANY; i++)\n\t\t\tpin->error_inj[i] &= ~CEC_ERROR_INJ_TX_MASK;\n\t\tpin->tx_toggle = false;\n\t\tpin->tx_ignore_nack_until_eom = false;\n\t\tpin->tx_custom_pulse = false;\n\t\tpin->tx_custom_low_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\t\tpin->tx_custom_high_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"tx-ignore-nack-until-eom\")) {\n\t\tpin->tx_ignore_nack_until_eom = true;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"tx-custom-pulse\")) {\n\t\tpin->tx_custom_pulse = true;\n\t\tcec_pin_start_timer(pin);\n\t\treturn true;\n\t}\n\tif (!p)\n\t\treturn false;\n\n\tp = skip_spaces(p);\n\tif (!strcmp(token, \"tx-custom-low-usecs\")) {\n\t\tu32 usecs;\n\n\t\tif (kstrtou32(p, 0, &usecs) || usecs > 10000000)\n\t\t\treturn false;\n\t\tpin->tx_custom_low_usecs = usecs;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"tx-custom-high-usecs\")) {\n\t\tu32 usecs;\n\n\t\tif (kstrtou32(p, 0, &usecs) || usecs > 10000000)\n\t\t\treturn false;\n\t\tpin->tx_custom_high_usecs = usecs;\n\t\treturn true;\n\t}\n\n\tcomma = strchr(token, ',');\n\tif (comma)\n\t\t*comma++ = '\\0';\n\tif (!strcmp(token, \"any\")) {\n\t\thas_op = false;\n\t\terror = pin->error_inj + CEC_ERROR_INJ_OP_ANY;\n\t\targs = pin->error_inj_args[CEC_ERROR_INJ_OP_ANY];\n\t} else if (!kstrtou8(token, 0, &op)) {\n\t\thas_op = true;\n\t\terror = pin->error_inj + op;\n\t\targs = pin->error_inj_args[op];\n\t} else {\n\t\treturn false;\n\t}\n\n\tmode = CEC_ERROR_INJ_MODE_ONCE;\n\tif (comma) {\n\t\tif (!strcmp(comma, \"off\"))\n\t\t\tmode = CEC_ERROR_INJ_MODE_OFF;\n\t\telse if (!strcmp(comma, \"once\"))\n\t\t\tmode = CEC_ERROR_INJ_MODE_ONCE;\n\t\telse if (!strcmp(comma, \"always\"))\n\t\t\tmode = CEC_ERROR_INJ_MODE_ALWAYS;\n\t\telse if (!strcmp(comma, \"toggle\"))\n\t\t\tmode = CEC_ERROR_INJ_MODE_TOGGLE;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\ttoken = strsep(&p, delims);\n\tif (p) {\n\t\tp = skip_spaces(p);\n\t\thas_pos = !kstrtou8(p, 0, &pos);\n\t}\n\n\tif (!strcmp(token, \"clear\")) {\n\t\t*error = 0;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"rx-clear\")) {\n\t\t*error &= ~CEC_ERROR_INJ_RX_MASK;\n\t\treturn true;\n\t}\n\tif (!strcmp(token, \"tx-clear\")) {\n\t\t*error &= ~CEC_ERROR_INJ_TX_MASK;\n\t\treturn true;\n\t}\n\n\tfor (i = 0; cec_error_inj_cmds[i].cmd; i++) {\n\t\tconst char *cmd = cec_error_inj_cmds[i].cmd;\n\t\tunsigned int mode_offset;\n\t\tu64 mode_mask;\n\t\tint arg_idx;\n\t\tbool is_bit_pos = true;\n\n\t\tif (strcmp(token, cmd))\n\t\t\tcontinue;\n\n\t\tmode_offset = cec_error_inj_cmds[i].mode_offset;\n\t\tmode_mask = CEC_ERROR_INJ_MODE_MASK << mode_offset;\n\t\targ_idx = cec_error_inj_cmds[i].arg_idx;\n\n\t\tif (mode_offset == CEC_ERROR_INJ_RX_ARB_LOST_OFFSET) {\n\t\t\tif (has_op)\n\t\t\t\treturn false;\n\t\t\tif (!has_pos)\n\t\t\t\tpos = 0x0f;\n\t\t\tis_bit_pos = false;\n\t\t} else if (mode_offset == CEC_ERROR_INJ_TX_ADD_BYTES_OFFSET) {\n\t\t\tif (!has_pos || !pos)\n\t\t\t\treturn false;\n\t\t\tis_bit_pos = false;\n\t\t}\n\n\t\tif (arg_idx >= 0 && is_bit_pos) {\n\t\t\tif (!has_pos || pos >= 160)\n\t\t\t\treturn false;\n\t\t\tif (has_op && pos < 10 + 8)\n\t\t\t\treturn false;\n\t\t\t \n\t\t\tif ((mode_offset == CEC_ERROR_INJ_TX_SHORT_BIT_OFFSET ||\n\t\t\t     mode_offset == CEC_ERROR_INJ_TX_LONG_BIT_OFFSET ||\n\t\t\t     mode_offset == CEC_ERROR_INJ_TX_CUSTOM_BIT_OFFSET) &&\n\t\t\t    (pos % 10) == 9)\n\t\t\t\treturn false;\n\t\t}\n\t\t*error &= ~mode_mask;\n\t\t*error |= (u64)mode << mode_offset;\n\t\tif (arg_idx >= 0)\n\t\t\targs[arg_idx] = pos;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void cec_pin_show_cmd(struct seq_file *sf, u32 cmd, u8 mode)\n{\n\tif (cmd == CEC_ERROR_INJ_OP_ANY)\n\t\tseq_puts(sf, \"any,\");\n\telse\n\t\tseq_printf(sf, \"0x%02x,\", cmd);\n\tswitch (mode) {\n\tcase CEC_ERROR_INJ_MODE_ONCE:\n\t\tseq_puts(sf, \"once \");\n\t\tbreak;\n\tcase CEC_ERROR_INJ_MODE_ALWAYS:\n\t\tseq_puts(sf, \"always \");\n\t\tbreak;\n\tcase CEC_ERROR_INJ_MODE_TOGGLE:\n\t\tseq_puts(sf, \"toggle \");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(sf, \"off \");\n\t\tbreak;\n\t}\n}\n\nint cec_pin_error_inj_show(struct cec_adapter *adap, struct seq_file *sf)\n{\n\tstruct cec_pin *pin = adap->pin;\n\tunsigned int i, j;\n\n\tseq_puts(sf, \"# Clear error injections:\\n\");\n\tseq_puts(sf, \"#   clear          clear all rx and tx error injections\\n\");\n\tseq_puts(sf, \"#   rx-clear       clear all rx error injections\\n\");\n\tseq_puts(sf, \"#   tx-clear       clear all tx error injections\\n\");\n\tseq_puts(sf, \"#   <op> clear     clear all rx and tx error injections for <op>\\n\");\n\tseq_puts(sf, \"#   <op> rx-clear  clear all rx error injections for <op>\\n\");\n\tseq_puts(sf, \"#   <op> tx-clear  clear all tx error injections for <op>\\n\");\n\tseq_puts(sf, \"#\\n\");\n\tseq_puts(sf, \"# RX error injection:\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] rx-nack              NACK the message instead of sending an ACK\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] rx-low-drive <bit>   force a low-drive condition at this bit position\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] rx-add-byte          add a spurious byte to the received CEC message\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] rx-remove-byte       remove the last byte from the received CEC message\\n\");\n\tseq_puts(sf, \"#    any[,<mode>] rx-arb-lost [<poll>] generate a POLL message to trigger an arbitration lost\\n\");\n\tseq_puts(sf, \"#\\n\");\n\tseq_puts(sf, \"# TX error injection settings:\\n\");\n\tseq_puts(sf, \"#   tx-ignore-nack-until-eom           ignore early NACKs until EOM\\n\");\n\tseq_puts(sf, \"#   tx-custom-low-usecs <usecs>        define the 'low' time for the custom pulse\\n\");\n\tseq_puts(sf, \"#   tx-custom-high-usecs <usecs>       define the 'high' time for the custom pulse\\n\");\n\tseq_puts(sf, \"#   tx-custom-pulse                    transmit the custom pulse once the bus is idle\\n\");\n\tseq_puts(sf, \"#\\n\");\n\tseq_puts(sf, \"# TX error injection:\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-no-eom            don't set the EOM bit\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-early-eom         set the EOM bit one byte too soon\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-add-bytes <num>   append <num> (1-255) spurious bytes to the message\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-remove-byte       drop the last byte from the message\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-short-bit <bit>   make this bit shorter than allowed\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-long-bit <bit>    make this bit longer than allowed\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-custom-bit <bit>  send the custom pulse instead of this bit\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-short-start       send a start pulse that's too short\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-long-start        send a start pulse that's too long\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-custom-start      send the custom pulse instead of the start pulse\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-last-bit <bit>    stop sending after this bit\\n\");\n\tseq_puts(sf, \"#   <op>[,<mode>] tx-low-drive <bit>   force a low-drive condition at this bit position\\n\");\n\tseq_puts(sf, \"#\\n\");\n\tseq_puts(sf, \"# <op>       CEC message opcode (0-255) or 'any'\\n\");\n\tseq_puts(sf, \"# <mode>     'once' (default), 'always', 'toggle' or 'off'\\n\");\n\tseq_puts(sf, \"# <bit>      CEC message bit (0-159)\\n\");\n\tseq_puts(sf, \"#            10 bits per 'byte': bits 0-7: data, bit 8: EOM, bit 9: ACK\\n\");\n\tseq_puts(sf, \"# <poll>     CEC poll message used to test arbitration lost (0x00-0xff, default 0x0f)\\n\");\n\tseq_puts(sf, \"# <usecs>    microseconds (0-10000000, default 1000)\\n\");\n\n\tseq_puts(sf, \"\\nclear\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(pin->error_inj); i++) {\n\t\tu64 e = pin->error_inj[i];\n\n\t\tfor (j = 0; cec_error_inj_cmds[j].cmd; j++) {\n\t\t\tconst char *cmd = cec_error_inj_cmds[j].cmd;\n\t\t\tunsigned int mode;\n\t\t\tunsigned int mode_offset;\n\t\t\tint arg_idx;\n\n\t\t\tmode_offset = cec_error_inj_cmds[j].mode_offset;\n\t\t\targ_idx = cec_error_inj_cmds[j].arg_idx;\n\t\t\tmode = (e >> mode_offset) & CEC_ERROR_INJ_MODE_MASK;\n\t\t\tif (!mode)\n\t\t\t\tcontinue;\n\t\t\tcec_pin_show_cmd(sf, i, mode);\n\t\t\tseq_puts(sf, cmd);\n\t\t\tif (arg_idx >= 0)\n\t\t\t\tseq_printf(sf, \" %u\",\n\t\t\t\t\t   pin->error_inj_args[i][arg_idx]);\n\t\t\tseq_puts(sf, \"\\n\");\n\t\t}\n\t}\n\n\tif (pin->tx_ignore_nack_until_eom)\n\t\tseq_puts(sf, \"tx-ignore-nack-until-eom\\n\");\n\tif (pin->tx_custom_pulse)\n\t\tseq_puts(sf, \"tx-custom-pulse\\n\");\n\tif (pin->tx_custom_low_usecs != CEC_TIM_CUSTOM_DEFAULT)\n\t\tseq_printf(sf, \"tx-custom-low-usecs %u\\n\",\n\t\t\t   pin->tx_custom_low_usecs);\n\tif (pin->tx_custom_high_usecs != CEC_TIM_CUSTOM_DEFAULT)\n\t\tseq_printf(sf, \"tx-custom-high-usecs %u\\n\",\n\t\t\t   pin->tx_custom_high_usecs);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}