{
  "module_name": "cec-pin.c",
  "hash_id": "7b456b13c451f19745f9f940a4c2166d4ac8447c3a57ffee24e9e2b21fc4db6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-pin.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sched/types.h>\n\n#include <media/cec-pin.h>\n#include \"cec-pin-priv.h\"\n\n \n\n \n#define CEC_TIM_START_BIT_LOW\t\t3700\n#define CEC_TIM_START_BIT_LOW_MIN\t3500\n#define CEC_TIM_START_BIT_LOW_MAX\t3900\n#define CEC_TIM_START_BIT_TOTAL\t\t4500\n#define CEC_TIM_START_BIT_TOTAL_MIN\t4300\n#define CEC_TIM_START_BIT_TOTAL_MAX\t4700\n\n \n#define CEC_TIM_DATA_BIT_0_LOW\t\t1500\n#define CEC_TIM_DATA_BIT_0_LOW_MIN\t1300\n#define CEC_TIM_DATA_BIT_0_LOW_MAX\t1700\n#define CEC_TIM_DATA_BIT_1_LOW\t\t600\n#define CEC_TIM_DATA_BIT_1_LOW_MIN\t400\n#define CEC_TIM_DATA_BIT_1_LOW_MAX\t800\n#define CEC_TIM_DATA_BIT_TOTAL\t\t2400\n#define CEC_TIM_DATA_BIT_TOTAL_MIN\t2050\n#define CEC_TIM_DATA_BIT_TOTAL_MAX\t2750\n \n#define CEC_TIM_DATA_BIT_SAMPLE\t\t850\n \n#define CEC_TIM_DATA_BIT_HIGH\t\t1750\n\n \n#define CEC_TIM_IDLE_SAMPLE\t\t1000\n \n#define CEC_TIM_START_BIT_SAMPLE\t500\n \n#define CEC_TIM_SAMPLE\t\t\t50\n\n#define CEC_TIM_LOW_DRIVE_ERROR\t\t(1.5 * CEC_TIM_DATA_BIT_TOTAL)\n\n \n#define CEC_TIM_DATA_BIT_TOTAL_SHORT\t1800\n#define CEC_TIM_DATA_BIT_TOTAL_LONG\t2900\n\n \n#define CEC_TIM_START_BIT_TOTAL_SHORT\t4100\n#define CEC_TIM_START_BIT_TOTAL_LONG\t5000\n\n \n#define EOM_BIT\t\t\t\t8\n#define ACK_BIT\t\t\t\t9\n\nstruct cec_state {\n\tconst char * const name;\n\tunsigned int usecs;\n};\n\nstatic const struct cec_state states[CEC_PIN_STATES] = {\n\t{ \"Off\",\t\t   0 },\n\t{ \"Idle\",\t\t   CEC_TIM_IDLE_SAMPLE },\n\t{ \"Tx Wait\",\t\t   CEC_TIM_SAMPLE },\n\t{ \"Tx Wait for High\",\t   CEC_TIM_IDLE_SAMPLE },\n\t{ \"Tx Start Bit Low\",\t   CEC_TIM_START_BIT_LOW },\n\t{ \"Tx Start Bit High\",\t   CEC_TIM_START_BIT_TOTAL - CEC_TIM_START_BIT_LOW },\n\t{ \"Tx Start Bit High Short\", CEC_TIM_START_BIT_TOTAL_SHORT - CEC_TIM_START_BIT_LOW },\n\t{ \"Tx Start Bit High Long\", CEC_TIM_START_BIT_TOTAL_LONG - CEC_TIM_START_BIT_LOW },\n\t{ \"Tx Start Bit Low Custom\", 0 },\n\t{ \"Tx Start Bit High Custom\", 0 },\n\t{ \"Tx Data 0 Low\",\t   CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Tx Data 0 High\",\t   CEC_TIM_DATA_BIT_TOTAL - CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Tx Data 0 High Short\",  CEC_TIM_DATA_BIT_TOTAL_SHORT - CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Tx Data 0 High Long\",   CEC_TIM_DATA_BIT_TOTAL_LONG - CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Tx Data 1 Low\",\t   CEC_TIM_DATA_BIT_1_LOW },\n\t{ \"Tx Data 1 High\",\t   CEC_TIM_DATA_BIT_TOTAL - CEC_TIM_DATA_BIT_1_LOW },\n\t{ \"Tx Data 1 High Short\",  CEC_TIM_DATA_BIT_TOTAL_SHORT - CEC_TIM_DATA_BIT_1_LOW },\n\t{ \"Tx Data 1 High Long\",   CEC_TIM_DATA_BIT_TOTAL_LONG - CEC_TIM_DATA_BIT_1_LOW },\n\t{ \"Tx Data 1 High Pre Sample\", CEC_TIM_DATA_BIT_SAMPLE - CEC_TIM_DATA_BIT_1_LOW },\n\t{ \"Tx Data 1 High Post Sample\", CEC_TIM_DATA_BIT_TOTAL - CEC_TIM_DATA_BIT_SAMPLE },\n\t{ \"Tx Data 1 High Post Sample Short\", CEC_TIM_DATA_BIT_TOTAL_SHORT - CEC_TIM_DATA_BIT_SAMPLE },\n\t{ \"Tx Data 1 High Post Sample Long\", CEC_TIM_DATA_BIT_TOTAL_LONG - CEC_TIM_DATA_BIT_SAMPLE },\n\t{ \"Tx Data Bit Low Custom\", 0 },\n\t{ \"Tx Data Bit High Custom\", 0 },\n\t{ \"Tx Pulse Low Custom\",   0 },\n\t{ \"Tx Pulse High Custom\",  0 },\n\t{ \"Tx Low Drive\",\t   CEC_TIM_LOW_DRIVE_ERROR },\n\t{ \"Rx Start Bit Low\",\t   CEC_TIM_SAMPLE },\n\t{ \"Rx Start Bit High\",\t   CEC_TIM_SAMPLE },\n\t{ \"Rx Data Sample\",\t   CEC_TIM_DATA_BIT_SAMPLE },\n\t{ \"Rx Data Post Sample\",   CEC_TIM_DATA_BIT_HIGH - CEC_TIM_DATA_BIT_SAMPLE },\n\t{ \"Rx Data Wait for Low\",  CEC_TIM_SAMPLE },\n\t{ \"Rx Ack Low\",\t\t   CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Rx Ack Low Post\",\t   CEC_TIM_DATA_BIT_HIGH - CEC_TIM_DATA_BIT_0_LOW },\n\t{ \"Rx Ack High Post\",\t   CEC_TIM_DATA_BIT_HIGH },\n\t{ \"Rx Ack Finish\",\t   CEC_TIM_DATA_BIT_TOTAL_MIN - CEC_TIM_DATA_BIT_HIGH },\n\t{ \"Rx Low Drive\",\t   CEC_TIM_LOW_DRIVE_ERROR },\n\t{ \"Rx Irq\",\t\t   0 },\n};\n\nstatic void cec_pin_update(struct cec_pin *pin, bool v, bool force)\n{\n\tif (!force && v == pin->adap->cec_pin_is_high)\n\t\treturn;\n\n\tpin->adap->cec_pin_is_high = v;\n\tif (atomic_read(&pin->work_pin_num_events) < CEC_NUM_PIN_EVENTS) {\n\t\tu8 ev = v;\n\n\t\tif (pin->work_pin_events_dropped) {\n\t\t\tpin->work_pin_events_dropped = false;\n\t\t\tev |= CEC_PIN_EVENT_FL_DROPPED;\n\t\t}\n\t\tpin->work_pin_events[pin->work_pin_events_wr] = ev;\n\t\tpin->work_pin_ts[pin->work_pin_events_wr] = ktime_get();\n\t\tpin->work_pin_events_wr =\n\t\t\t(pin->work_pin_events_wr + 1) % CEC_NUM_PIN_EVENTS;\n\t\tatomic_inc(&pin->work_pin_num_events);\n\t} else {\n\t\tpin->work_pin_events_dropped = true;\n\t\tpin->work_pin_events_dropped_cnt++;\n\t}\n\twake_up_interruptible(&pin->kthread_waitq);\n}\n\nstatic bool cec_pin_read(struct cec_pin *pin)\n{\n\tbool v = call_pin_op(pin, read);\n\n\tcec_pin_update(pin, v, false);\n\treturn v;\n}\n\nstatic void cec_pin_low(struct cec_pin *pin)\n{\n\tcall_void_pin_op(pin, low);\n\tcec_pin_update(pin, false, false);\n}\n\nstatic bool cec_pin_high(struct cec_pin *pin)\n{\n\tcall_void_pin_op(pin, high);\n\treturn cec_pin_read(pin);\n}\n\nstatic bool rx_error_inj(struct cec_pin *pin, unsigned int mode_offset,\n\t\t\t int arg_idx, u8 *arg)\n{\n#ifdef CONFIG_CEC_PIN_ERROR_INJ\n\tu16 cmd = cec_pin_rx_error_inj(pin);\n\tu64 e = pin->error_inj[cmd];\n\tunsigned int mode = (e >> mode_offset) & CEC_ERROR_INJ_MODE_MASK;\n\n\tif (arg_idx >= 0) {\n\t\tu8 pos = pin->error_inj_args[cmd][arg_idx];\n\n\t\tif (arg)\n\t\t\t*arg = pos;\n\t\telse if (pos != pin->rx_bit)\n\t\t\treturn false;\n\t}\n\n\tswitch (mode) {\n\tcase CEC_ERROR_INJ_MODE_ONCE:\n\t\tpin->error_inj[cmd] &=\n\t\t\t~(CEC_ERROR_INJ_MODE_MASK << mode_offset);\n\t\treturn true;\n\tcase CEC_ERROR_INJ_MODE_ALWAYS:\n\t\treturn true;\n\tcase CEC_ERROR_INJ_MODE_TOGGLE:\n\t\treturn pin->rx_toggle;\n\tdefault:\n\t\treturn false;\n\t}\n#else\n\treturn false;\n#endif\n}\n\nstatic bool rx_nack(struct cec_pin *pin)\n{\n\treturn rx_error_inj(pin, CEC_ERROR_INJ_RX_NACK_OFFSET, -1, NULL);\n}\n\nstatic bool rx_low_drive(struct cec_pin *pin)\n{\n\treturn rx_error_inj(pin, CEC_ERROR_INJ_RX_LOW_DRIVE_OFFSET,\n\t\t\t    CEC_ERROR_INJ_RX_LOW_DRIVE_ARG_IDX, NULL);\n}\n\nstatic bool rx_add_byte(struct cec_pin *pin)\n{\n\treturn rx_error_inj(pin, CEC_ERROR_INJ_RX_ADD_BYTE_OFFSET, -1, NULL);\n}\n\nstatic bool rx_remove_byte(struct cec_pin *pin)\n{\n\treturn rx_error_inj(pin, CEC_ERROR_INJ_RX_REMOVE_BYTE_OFFSET, -1, NULL);\n}\n\nstatic bool rx_arb_lost(struct cec_pin *pin, u8 *poll)\n{\n\treturn pin->tx_msg.len == 0 &&\n\t\trx_error_inj(pin, CEC_ERROR_INJ_RX_ARB_LOST_OFFSET,\n\t\t\t     CEC_ERROR_INJ_RX_ARB_LOST_ARG_IDX, poll);\n}\n\nstatic bool tx_error_inj(struct cec_pin *pin, unsigned int mode_offset,\n\t\t\t int arg_idx, u8 *arg)\n{\n#ifdef CONFIG_CEC_PIN_ERROR_INJ\n\tu16 cmd = cec_pin_tx_error_inj(pin);\n\tu64 e = pin->error_inj[cmd];\n\tunsigned int mode = (e >> mode_offset) & CEC_ERROR_INJ_MODE_MASK;\n\n\tif (arg_idx >= 0) {\n\t\tu8 pos = pin->error_inj_args[cmd][arg_idx];\n\n\t\tif (arg)\n\t\t\t*arg = pos;\n\t\telse if (pos != pin->tx_bit)\n\t\t\treturn false;\n\t}\n\n\tswitch (mode) {\n\tcase CEC_ERROR_INJ_MODE_ONCE:\n\t\tpin->error_inj[cmd] &=\n\t\t\t~(CEC_ERROR_INJ_MODE_MASK << mode_offset);\n\t\treturn true;\n\tcase CEC_ERROR_INJ_MODE_ALWAYS:\n\t\treturn true;\n\tcase CEC_ERROR_INJ_MODE_TOGGLE:\n\t\treturn pin->tx_toggle;\n\tdefault:\n\t\treturn false;\n\t}\n#else\n\treturn false;\n#endif\n}\n\nstatic bool tx_no_eom(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_NO_EOM_OFFSET, -1, NULL);\n}\n\nstatic bool tx_early_eom(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_EARLY_EOM_OFFSET, -1, NULL);\n}\n\nstatic bool tx_short_bit(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_SHORT_BIT_OFFSET,\n\t\t\t    CEC_ERROR_INJ_TX_SHORT_BIT_ARG_IDX, NULL);\n}\n\nstatic bool tx_long_bit(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_LONG_BIT_OFFSET,\n\t\t\t    CEC_ERROR_INJ_TX_LONG_BIT_ARG_IDX, NULL);\n}\n\nstatic bool tx_custom_bit(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_CUSTOM_BIT_OFFSET,\n\t\t\t    CEC_ERROR_INJ_TX_CUSTOM_BIT_ARG_IDX, NULL);\n}\n\nstatic bool tx_short_start(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_SHORT_START_OFFSET, -1, NULL);\n}\n\nstatic bool tx_long_start(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_LONG_START_OFFSET, -1, NULL);\n}\n\nstatic bool tx_custom_start(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_CUSTOM_START_OFFSET,\n\t\t\t    -1, NULL);\n}\n\nstatic bool tx_last_bit(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_LAST_BIT_OFFSET,\n\t\t\t    CEC_ERROR_INJ_TX_LAST_BIT_ARG_IDX, NULL);\n}\n\nstatic u8 tx_add_bytes(struct cec_pin *pin)\n{\n\tu8 bytes;\n\n\tif (tx_error_inj(pin, CEC_ERROR_INJ_TX_ADD_BYTES_OFFSET,\n\t\t\t CEC_ERROR_INJ_TX_ADD_BYTES_ARG_IDX, &bytes))\n\t\treturn bytes;\n\treturn 0;\n}\n\nstatic bool tx_remove_byte(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_REMOVE_BYTE_OFFSET, -1, NULL);\n}\n\nstatic bool tx_low_drive(struct cec_pin *pin)\n{\n\treturn tx_error_inj(pin, CEC_ERROR_INJ_TX_LOW_DRIVE_OFFSET,\n\t\t\t    CEC_ERROR_INJ_TX_LOW_DRIVE_ARG_IDX, NULL);\n}\n\nstatic void cec_pin_to_idle(struct cec_pin *pin)\n{\n\t \n\tpin->rx_bit = pin->tx_bit = 0;\n\tpin->rx_msg.len = 0;\n\tmemset(pin->rx_msg.msg, 0, sizeof(pin->rx_msg.msg));\n\tpin->ts = ns_to_ktime(0);\n\tpin->tx_generated_poll = false;\n\tpin->tx_post_eom = false;\n\tif (pin->state >= CEC_ST_TX_WAIT &&\n\t    pin->state <= CEC_ST_TX_LOW_DRIVE)\n\t\tpin->tx_toggle ^= 1;\n\tif (pin->state >= CEC_ST_RX_START_BIT_LOW &&\n\t    pin->state <= CEC_ST_RX_LOW_DRIVE)\n\t\tpin->rx_toggle ^= 1;\n\tpin->state = CEC_ST_IDLE;\n}\n\n \nstatic void cec_pin_tx_states(struct cec_pin *pin, ktime_t ts)\n{\n\tbool v;\n\tbool is_ack_bit, ack;\n\n\tswitch (pin->state) {\n\tcase CEC_ST_TX_WAIT_FOR_HIGH:\n\t\tif (cec_pin_read(pin))\n\t\t\tcec_pin_to_idle(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_START_BIT_LOW:\n\t\tif (tx_short_start(pin)) {\n\t\t\t \n\t\t\tpin->state = CEC_ST_TX_START_BIT_HIGH_SHORT;\n\t\t} else if (tx_long_start(pin)) {\n\t\t\t \n\t\t\tpin->state = CEC_ST_TX_START_BIT_HIGH_LONG;\n\t\t} else {\n\t\t\tpin->state = CEC_ST_TX_START_BIT_HIGH;\n\t\t}\n\t\t \n\t\tcec_pin_high(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_START_BIT_LOW_CUSTOM:\n\t\tpin->state = CEC_ST_TX_START_BIT_HIGH_CUSTOM;\n\t\t \n\t\tcec_pin_high(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_LONG:\n\t\tif (pin->tx_nacked) {\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tpin->tx_msg.len = 0;\n\t\t\tif (pin->tx_generated_poll)\n\t\t\t\tbreak;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_NACK;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH:\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH_LONG:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_LONG:\n\t\t \n\t\tif (!cec_pin_read(pin) && !pin->tx_generated_poll) {\n\t\t\t \n\t\t\tpin->tx_msg.len = 0;\n\t\t\tpin->state = CEC_ST_TX_WAIT_FOR_HIGH;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_LOW_DRIVE;\n\t\t\tpin->tx_low_drive_cnt++;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CEC_ST_TX_DATA_BIT_HIGH_CUSTOM:\n\t\tif (tx_last_bit(pin)) {\n\t\t\t \n\t\t\tcec_pin_to_idle(pin);\n\t\t\tpin->tx_msg.len = 0;\n\t\t\tif (pin->tx_generated_poll)\n\t\t\t\tbreak;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_OK;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tbreak;\n\t\t}\n\t\tpin->tx_bit++;\n\t\tfallthrough;\n\tcase CEC_ST_TX_START_BIT_HIGH:\n\tcase CEC_ST_TX_START_BIT_HIGH_SHORT:\n\tcase CEC_ST_TX_START_BIT_HIGH_LONG:\n\tcase CEC_ST_TX_START_BIT_HIGH_CUSTOM:\n\t\tif (tx_low_drive(pin)) {\n\t\t\t \n\t\t\tcec_pin_low(pin);\n\t\t\tpin->state = CEC_ST_TX_LOW_DRIVE;\n\t\t\tpin->tx_msg.len = 0;\n\t\t\tif (pin->tx_generated_poll)\n\t\t\t\tbreak;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_LOW_DRIVE;\n\t\t\tpin->tx_low_drive_cnt++;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tbreak;\n\t\t}\n\t\tif (pin->tx_bit / 10 >= pin->tx_msg.len + pin->tx_extra_bytes) {\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tpin->tx_msg.len = 0;\n\t\t\tif (pin->tx_generated_poll)\n\t\t\t\tbreak;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_OK;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pin->tx_bit % 10) {\n\t\tdefault: {\n\t\t\t \n\t\t\tunsigned int idx = (pin->tx_bit / 10);\n\t\t\tu8 val = idx;\n\n\t\t\tif (idx < pin->tx_msg.len)\n\t\t\t\tval = pin->tx_msg.msg[idx];\n\t\t\tv = val & (1 << (7 - (pin->tx_bit % 10)));\n\n\t\t\tpin->state = v ? CEC_ST_TX_DATA_BIT_1_LOW :\n\t\t\t\t\t CEC_ST_TX_DATA_BIT_0_LOW;\n\t\t\tbreak;\n\t\t}\n\t\tcase EOM_BIT: {\n\t\t\tunsigned int tot_len = pin->tx_msg.len +\n\t\t\t\t\t       pin->tx_extra_bytes;\n\t\t\tunsigned int tx_byte_idx = pin->tx_bit / 10;\n\n\t\t\tv = !pin->tx_post_eom && tx_byte_idx == tot_len - 1;\n\t\t\tif (tot_len > 1 && tx_byte_idx == tot_len - 2 &&\n\t\t\t    tx_early_eom(pin)) {\n\t\t\t\t \n\t\t\t\tv = true;\n\t\t\t\tpin->tx_post_eom = true;\n\t\t\t} else if (v && tx_no_eom(pin)) {\n\t\t\t\t \n\t\t\t\tv = false;\n\t\t\t}\n\t\t\tpin->state = v ? CEC_ST_TX_DATA_BIT_1_LOW :\n\t\t\t\t\t CEC_ST_TX_DATA_BIT_0_LOW;\n\t\t\tbreak;\n\t\t}\n\t\tcase ACK_BIT:\n\t\t\tpin->state = CEC_ST_TX_DATA_BIT_1_LOW;\n\t\t\tbreak;\n\t\t}\n\t\tif (tx_custom_bit(pin))\n\t\t\tpin->state = CEC_ST_TX_DATA_BIT_LOW_CUSTOM;\n\t\tcec_pin_low(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_DATA_BIT_0_LOW:\n\tcase CEC_ST_TX_DATA_BIT_1_LOW:\n\t\tv = pin->state == CEC_ST_TX_DATA_BIT_1_LOW;\n\t\tis_ack_bit = pin->tx_bit % 10 == ACK_BIT;\n\t\tif (v && (pin->tx_bit < 4 || is_ack_bit)) {\n\t\t\tpin->state = CEC_ST_TX_DATA_BIT_1_HIGH_PRE_SAMPLE;\n\t\t} else if (!is_ack_bit && tx_short_bit(pin)) {\n\t\t\t \n\t\t\tpin->state = v ? CEC_ST_TX_DATA_BIT_1_HIGH_SHORT :\n\t\t\t\t\t CEC_ST_TX_DATA_BIT_0_HIGH_SHORT;\n\t\t} else if (!is_ack_bit && tx_long_bit(pin)) {\n\t\t\t \n\t\t\tpin->state = v ? CEC_ST_TX_DATA_BIT_1_HIGH_LONG :\n\t\t\t\t\t CEC_ST_TX_DATA_BIT_0_HIGH_LONG;\n\t\t} else {\n\t\t\tpin->state = v ? CEC_ST_TX_DATA_BIT_1_HIGH :\n\t\t\t\t\t CEC_ST_TX_DATA_BIT_0_HIGH;\n\t\t}\n\t\tcec_pin_high(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_DATA_BIT_LOW_CUSTOM:\n\t\tpin->state = CEC_ST_TX_DATA_BIT_HIGH_CUSTOM;\n\t\tcec_pin_high(pin);\n\t\tbreak;\n\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_PRE_SAMPLE:\n\t\t \n\t\tv = cec_pin_read(pin);\n\t\tis_ack_bit = pin->tx_bit % 10 == ACK_BIT;\n\t\t \n\t\tif (!v && !is_ack_bit && !pin->tx_generated_poll) {\n\t\t\tpin->tx_msg.len = 0;\n\t\t\tpin->work_tx_ts = ts;\n\t\t\tpin->work_tx_status = CEC_TX_STATUS_ARB_LOST;\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tpin->rx_bit = pin->tx_bit;\n\t\t\tpin->tx_bit = 0;\n\t\t\tmemset(pin->rx_msg.msg, 0, sizeof(pin->rx_msg.msg));\n\t\t\tpin->rx_msg.msg[0] = pin->tx_msg.msg[0];\n\t\t\tpin->rx_msg.msg[0] &= (0xff << (8 - pin->rx_bit));\n\t\t\tpin->rx_msg.len = 0;\n\t\t\tpin->ts = ktime_sub_us(ts, CEC_TIM_DATA_BIT_SAMPLE);\n\t\t\tpin->state = CEC_ST_RX_DATA_POST_SAMPLE;\n\t\t\tpin->rx_bit++;\n\t\t\tbreak;\n\t\t}\n\t\tpin->state = CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE;\n\t\tif (!is_ack_bit && tx_short_bit(pin)) {\n\t\t\t \n\t\t\tpin->state = CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_SHORT;\n\t\t} else if (!is_ack_bit && tx_long_bit(pin)) {\n\t\t\t \n\t\t\tpin->state = CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_LONG;\n\t\t}\n\t\tif (!is_ack_bit)\n\t\t\tbreak;\n\t\t \n\t\tack = cec_msg_is_broadcast(&pin->tx_msg) ? v : !v;\n\t\tif (!ack && (!pin->tx_ignore_nack_until_eom ||\n\t\t    pin->tx_bit / 10 == pin->tx_msg.len - 1) &&\n\t\t    !pin->tx_post_eom) {\n\t\t\t \n\t\t\tpin->tx_nacked = true;\n\t\t}\n\t\tbreak;\n\n\tcase CEC_ST_TX_PULSE_LOW_CUSTOM:\n\t\tcec_pin_high(pin);\n\t\tpin->state = CEC_ST_TX_PULSE_HIGH_CUSTOM;\n\t\tbreak;\n\n\tcase CEC_ST_TX_PULSE_HIGH_CUSTOM:\n\t\tcec_pin_to_idle(pin);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void cec_pin_rx_states(struct cec_pin *pin, ktime_t ts)\n{\n\ts32 delta;\n\tbool v;\n\tbool ack;\n\tbool bcast, for_us;\n\tu8 dest;\n\tu8 poll;\n\n\tswitch (pin->state) {\n\t \n\tcase CEC_ST_RX_START_BIT_LOW:\n\t\tv = cec_pin_read(pin);\n\t\tif (!v)\n\t\t\tbreak;\n\t\tpin->state = CEC_ST_RX_START_BIT_HIGH;\n\t\tdelta = ktime_us_delta(ts, pin->ts);\n\t\t \n\t\tif (delta < CEC_TIM_START_BIT_LOW_MIN - CEC_TIM_IDLE_SAMPLE) {\n\t\t\tif (!pin->rx_start_bit_low_too_short_cnt++) {\n\t\t\t\tpin->rx_start_bit_low_too_short_ts = ktime_to_ns(pin->ts);\n\t\t\t\tpin->rx_start_bit_low_too_short_delta = delta;\n\t\t\t}\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tbreak;\n\t\t}\n\t\tif (rx_arb_lost(pin, &poll)) {\n\t\t\tcec_msg_init(&pin->tx_msg, poll >> 4, poll & 0xf);\n\t\t\tpin->tx_generated_poll = true;\n\t\t\tpin->tx_extra_bytes = 0;\n\t\t\tpin->state = CEC_ST_TX_START_BIT_HIGH;\n\t\t\tpin->ts = ts;\n\t\t}\n\t\tbreak;\n\n\tcase CEC_ST_RX_START_BIT_HIGH:\n\t\tv = cec_pin_read(pin);\n\t\tdelta = ktime_us_delta(ts, pin->ts);\n\t\t \n\t\tif (v && delta > CEC_TIM_START_BIT_TOTAL_LONG) {\n\t\t\tpin->rx_start_bit_too_long_cnt++;\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tbreak;\n\t\t}\n\t\tif (v)\n\t\t\tbreak;\n\t\t \n\t\tif (delta < CEC_TIM_START_BIT_TOTAL_MIN - CEC_TIM_IDLE_SAMPLE) {\n\t\t\tif (!pin->rx_start_bit_too_short_cnt++) {\n\t\t\t\tpin->rx_start_bit_too_short_ts = ktime_to_ns(pin->ts);\n\t\t\t\tpin->rx_start_bit_too_short_delta = delta;\n\t\t\t}\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tbreak;\n\t\t}\n\t\tif (rx_low_drive(pin)) {\n\t\t\t \n\t\t\tcec_pin_low(pin);\n\t\t\tpin->state = CEC_ST_RX_LOW_DRIVE;\n\t\t\tpin->rx_low_drive_cnt++;\n\t\t\tbreak;\n\t\t}\n\t\tpin->state = CEC_ST_RX_DATA_SAMPLE;\n\t\tpin->ts = ts;\n\t\tpin->rx_eom = false;\n\t\tbreak;\n\n\tcase CEC_ST_RX_DATA_SAMPLE:\n\t\tv = cec_pin_read(pin);\n\t\tpin->state = CEC_ST_RX_DATA_POST_SAMPLE;\n\t\tswitch (pin->rx_bit % 10) {\n\t\tdefault:\n\t\t\tif (pin->rx_bit / 10 < CEC_MAX_MSG_SIZE)\n\t\t\t\tpin->rx_msg.msg[pin->rx_bit / 10] |=\n\t\t\t\t\tv << (7 - (pin->rx_bit % 10));\n\t\t\tbreak;\n\t\tcase EOM_BIT:\n\t\t\tpin->rx_eom = v;\n\t\t\tpin->rx_msg.len = pin->rx_bit / 10 + 1;\n\t\t\tbreak;\n\t\tcase ACK_BIT:\n\t\t\tbreak;\n\t\t}\n\t\tpin->rx_bit++;\n\t\tbreak;\n\n\tcase CEC_ST_RX_DATA_POST_SAMPLE:\n\t\tpin->state = CEC_ST_RX_DATA_WAIT_FOR_LOW;\n\t\tbreak;\n\n\tcase CEC_ST_RX_DATA_WAIT_FOR_LOW:\n\t\tv = cec_pin_read(pin);\n\t\tdelta = ktime_us_delta(ts, pin->ts);\n\t\t \n\t\tif (v && delta > CEC_TIM_DATA_BIT_TOTAL_LONG) {\n\t\t\tpin->rx_data_bit_too_long_cnt++;\n\t\t\tcec_pin_to_idle(pin);\n\t\t\tbreak;\n\t\t}\n\t\tif (v)\n\t\t\tbreak;\n\n\t\tif (rx_low_drive(pin)) {\n\t\t\t \n\t\t\tcec_pin_low(pin);\n\t\t\tpin->state = CEC_ST_RX_LOW_DRIVE;\n\t\t\tpin->rx_low_drive_cnt++;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (delta < CEC_TIM_DATA_BIT_TOTAL_MIN) {\n\t\t\tif (!pin->rx_data_bit_too_short_cnt++) {\n\t\t\t\tpin->rx_data_bit_too_short_ts = ktime_to_ns(pin->ts);\n\t\t\t\tpin->rx_data_bit_too_short_delta = delta;\n\t\t\t}\n\t\t\tcec_pin_low(pin);\n\t\t\tpin->state = CEC_ST_RX_LOW_DRIVE;\n\t\t\tpin->rx_low_drive_cnt++;\n\t\t\tbreak;\n\t\t}\n\t\tpin->ts = ts;\n\t\tif (pin->rx_bit % 10 != 9) {\n\t\t\tpin->state = CEC_ST_RX_DATA_SAMPLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tdest = cec_msg_destination(&pin->rx_msg);\n\t\tbcast = dest == CEC_LOG_ADDR_BROADCAST;\n\t\t \n\t\tfor_us = bcast || (pin->la_mask & (1 << dest));\n\t\t \n\t\tack = bcast ? 1 : !for_us;\n\n\t\tif (for_us && rx_nack(pin)) {\n\t\t\t \n\t\t\tack = !ack;\n\t\t}\n\n\t\tif (ack) {\n\t\t\t \n\t\t\tpin->state = CEC_ST_RX_ACK_HIGH_POST;\n\t\t\tbreak;\n\t\t}\n\t\tcec_pin_low(pin);\n\t\tpin->state = CEC_ST_RX_ACK_LOW;\n\t\tbreak;\n\n\tcase CEC_ST_RX_ACK_LOW:\n\t\tcec_pin_high(pin);\n\t\tpin->state = CEC_ST_RX_ACK_LOW_POST;\n\t\tbreak;\n\n\tcase CEC_ST_RX_ACK_LOW_POST:\n\tcase CEC_ST_RX_ACK_HIGH_POST:\n\t\tv = cec_pin_read(pin);\n\t\tif (v && pin->rx_eom) {\n\t\t\tpin->work_rx_msg = pin->rx_msg;\n\t\t\tpin->work_rx_msg.rx_ts = ktime_to_ns(ts);\n\t\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\t\tpin->ts = ts;\n\t\t\tpin->state = CEC_ST_RX_ACK_FINISH;\n\t\t\tbreak;\n\t\t}\n\t\tpin->rx_bit++;\n\t\tpin->state = CEC_ST_RX_DATA_WAIT_FOR_LOW;\n\t\tbreak;\n\n\tcase CEC_ST_RX_ACK_FINISH:\n\t\tcec_pin_to_idle(pin);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic enum hrtimer_restart cec_pin_timer(struct hrtimer *timer)\n{\n\tstruct cec_pin *pin = container_of(timer, struct cec_pin, timer);\n\tstruct cec_adapter *adap = pin->adap;\n\tktime_t ts;\n\ts32 delta;\n\tu32 usecs;\n\n\tts = ktime_get();\n\tif (ktime_to_ns(pin->timer_ts)) {\n\t\tdelta = ktime_us_delta(ts, pin->timer_ts);\n\t\tpin->timer_cnt++;\n\t\tif (delta > 100 && pin->state != CEC_ST_IDLE) {\n\t\t\t \n\t\t\tpin->timer_sum_overrun += delta;\n\t\t\tpin->timer_100us_overruns++;\n\t\t\tif (delta > 300)\n\t\t\t\tpin->timer_300us_overruns++;\n\t\t\tif (delta > pin->timer_max_overrun)\n\t\t\t\tpin->timer_max_overrun = delta;\n\t\t}\n\t}\n\tif (adap->monitor_pin_cnt)\n\t\tcec_pin_read(pin);\n\n\tif (pin->wait_usecs) {\n\t\t \n\t\tif (pin->wait_usecs > 150) {\n\t\t\tpin->wait_usecs -= 100;\n\t\t\tpin->timer_ts = ktime_add_us(ts, 100);\n\t\t\thrtimer_forward_now(timer, ns_to_ktime(100000));\n\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\t\tif (pin->wait_usecs > 100) {\n\t\t\tpin->wait_usecs /= 2;\n\t\t\tpin->timer_ts = ktime_add_us(ts, pin->wait_usecs);\n\t\t\thrtimer_forward_now(timer,\n\t\t\t\t\tns_to_ktime(pin->wait_usecs * 1000));\n\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\t\tpin->timer_ts = ktime_add_us(ts, pin->wait_usecs);\n\t\thrtimer_forward_now(timer,\n\t\t\t\t    ns_to_ktime(pin->wait_usecs * 1000));\n\t\tpin->wait_usecs = 0;\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\tswitch (pin->state) {\n\t \n\tcase CEC_ST_TX_WAIT_FOR_HIGH:\n\tcase CEC_ST_TX_START_BIT_LOW:\n\tcase CEC_ST_TX_START_BIT_HIGH:\n\tcase CEC_ST_TX_START_BIT_HIGH_SHORT:\n\tcase CEC_ST_TX_START_BIT_HIGH_LONG:\n\tcase CEC_ST_TX_START_BIT_LOW_CUSTOM:\n\tcase CEC_ST_TX_START_BIT_HIGH_CUSTOM:\n\tcase CEC_ST_TX_DATA_BIT_0_LOW:\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH:\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_0_HIGH_LONG:\n\tcase CEC_ST_TX_DATA_BIT_1_LOW:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_LONG:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_PRE_SAMPLE:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_SHORT:\n\tcase CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE_LONG:\n\tcase CEC_ST_TX_DATA_BIT_LOW_CUSTOM:\n\tcase CEC_ST_TX_DATA_BIT_HIGH_CUSTOM:\n\tcase CEC_ST_TX_PULSE_LOW_CUSTOM:\n\tcase CEC_ST_TX_PULSE_HIGH_CUSTOM:\n\t\tcec_pin_tx_states(pin, ts);\n\t\tbreak;\n\n\t \n\tcase CEC_ST_RX_START_BIT_LOW:\n\tcase CEC_ST_RX_START_BIT_HIGH:\n\tcase CEC_ST_RX_DATA_SAMPLE:\n\tcase CEC_ST_RX_DATA_POST_SAMPLE:\n\tcase CEC_ST_RX_DATA_WAIT_FOR_LOW:\n\tcase CEC_ST_RX_ACK_LOW:\n\tcase CEC_ST_RX_ACK_LOW_POST:\n\tcase CEC_ST_RX_ACK_HIGH_POST:\n\tcase CEC_ST_RX_ACK_FINISH:\n\t\tcec_pin_rx_states(pin, ts);\n\t\tbreak;\n\n\tcase CEC_ST_IDLE:\n\tcase CEC_ST_TX_WAIT:\n\t\tif (!cec_pin_high(pin)) {\n\t\t\t \n\t\t\tpin->ts = ts;\n\t\t\tpin->state = CEC_ST_RX_START_BIT_LOW;\n\t\t\t \n\t\t\tif (pin->tx_msg.len && pin->tx_signal_free_time >\n\t\t\t    CEC_SIGNAL_FREE_TIME_NEW_INITIATOR)\n\t\t\t\tpin->tx_signal_free_time =\n\t\t\t\t\tCEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\n\t\t\tbreak;\n\t\t}\n\t\tif (ktime_to_ns(pin->ts) == 0)\n\t\t\tpin->ts = ts;\n\t\tif (pin->tx_msg.len) {\n\t\t\t \n\t\t\tdelta = ktime_us_delta(ts, pin->ts);\n\t\t\tif (delta / CEC_TIM_DATA_BIT_TOTAL >=\n\t\t\t    pin->tx_signal_free_time) {\n\t\t\t\tpin->tx_nacked = false;\n\t\t\t\tif (tx_custom_start(pin))\n\t\t\t\t\tpin->state = CEC_ST_TX_START_BIT_LOW_CUSTOM;\n\t\t\t\telse\n\t\t\t\t\tpin->state = CEC_ST_TX_START_BIT_LOW;\n\t\t\t\t \n\t\t\t\tcec_pin_low(pin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (delta / CEC_TIM_DATA_BIT_TOTAL >=\n\t\t\t    pin->tx_signal_free_time - 1)\n\t\t\t\tpin->state = CEC_ST_TX_WAIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (pin->tx_custom_pulse && pin->state == CEC_ST_IDLE) {\n\t\t\tpin->tx_custom_pulse = false;\n\t\t\t \n\t\t\tcec_pin_low(pin);\n\t\t\tpin->state = CEC_ST_TX_PULSE_LOW_CUSTOM;\n\t\t\tbreak;\n\t\t}\n\t\tif (pin->state != CEC_ST_IDLE || pin->ops->enable_irq == NULL ||\n\t\t    pin->enable_irq_failed || adap->is_configuring ||\n\t\t    adap->is_configured || adap->monitor_all_cnt || !adap->monitor_pin_cnt)\n\t\t\tbreak;\n\t\t \n\t\tatomic_set(&pin->work_irq_change, CEC_PIN_IRQ_ENABLE);\n\t\tpin->state = CEC_ST_RX_IRQ;\n\t\twake_up_interruptible(&pin->kthread_waitq);\n\t\treturn HRTIMER_NORESTART;\n\n\tcase CEC_ST_TX_LOW_DRIVE:\n\tcase CEC_ST_RX_LOW_DRIVE:\n\t\tcec_pin_high(pin);\n\t\tcec_pin_to_idle(pin);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (pin->state) {\n\tcase CEC_ST_TX_START_BIT_LOW_CUSTOM:\n\tcase CEC_ST_TX_DATA_BIT_LOW_CUSTOM:\n\tcase CEC_ST_TX_PULSE_LOW_CUSTOM:\n\t\tusecs = pin->tx_custom_low_usecs;\n\t\tbreak;\n\tcase CEC_ST_TX_START_BIT_HIGH_CUSTOM:\n\tcase CEC_ST_TX_DATA_BIT_HIGH_CUSTOM:\n\tcase CEC_ST_TX_PULSE_HIGH_CUSTOM:\n\t\tusecs = pin->tx_custom_high_usecs;\n\t\tbreak;\n\tdefault:\n\t\tusecs = states[pin->state].usecs;\n\t\tbreak;\n\t}\n\n\tif (!adap->monitor_pin_cnt || usecs <= 150) {\n\t\tpin->wait_usecs = 0;\n\t\tpin->timer_ts = ktime_add_us(ts, usecs);\n\t\thrtimer_forward_now(timer,\n\t\t\t\tns_to_ktime(usecs * 1000));\n\t\treturn HRTIMER_RESTART;\n\t}\n\tpin->wait_usecs = usecs - 100;\n\tpin->timer_ts = ktime_add_us(ts, 100);\n\thrtimer_forward_now(timer, ns_to_ktime(100000));\n\treturn HRTIMER_RESTART;\n}\n\nstatic int cec_pin_thread_func(void *_adap)\n{\n\tstruct cec_adapter *adap = _adap;\n\tstruct cec_pin *pin = adap->pin;\n\n\tpin->enabled_irq = false;\n\tpin->enable_irq_failed = false;\n\tfor (;;) {\n\t\twait_event_interruptible(pin->kthread_waitq,\n\t\t\t\t\t kthread_should_stop() ||\n\t\t\t\t\t pin->work_rx_msg.len ||\n\t\t\t\t\t pin->work_tx_status ||\n\t\t\t\t\t atomic_read(&pin->work_irq_change) ||\n\t\t\t\t\t atomic_read(&pin->work_pin_num_events));\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (pin->work_rx_msg.len) {\n\t\t\tstruct cec_msg *msg = &pin->work_rx_msg;\n\n\t\t\tif (msg->len > 1 && msg->len < CEC_MAX_MSG_SIZE &&\n\t\t\t    rx_add_byte(pin)) {\n\t\t\t\t \n\t\t\t\tmsg->msg[msg->len++] = 0x55;\n\t\t\t}\n\t\t\tif (msg->len > 2 && rx_remove_byte(pin)) {\n\t\t\t\t \n\t\t\t\tmsg->len--;\n\t\t\t}\n\t\t\tif (msg->len > CEC_MAX_MSG_SIZE)\n\t\t\t\tmsg->len = CEC_MAX_MSG_SIZE;\n\t\t\tcec_received_msg_ts(adap, msg,\n\t\t\t\tns_to_ktime(pin->work_rx_msg.rx_ts));\n\t\t\tmsg->len = 0;\n\t\t}\n\n\t\tif (pin->work_tx_status) {\n\t\t\tunsigned int tx_status = pin->work_tx_status;\n\n\t\t\tpin->work_tx_status = 0;\n\t\t\tcec_transmit_attempt_done_ts(adap, tx_status,\n\t\t\t\t\t\t     pin->work_tx_ts);\n\t\t}\n\n\t\twhile (atomic_read(&pin->work_pin_num_events)) {\n\t\t\tunsigned int idx = pin->work_pin_events_rd;\n\t\t\tu8 v = pin->work_pin_events[idx];\n\n\t\t\tcec_queue_pin_cec_event(adap,\n\t\t\t\t\t\tv & CEC_PIN_EVENT_FL_IS_HIGH,\n\t\t\t\t\t\tv & CEC_PIN_EVENT_FL_DROPPED,\n\t\t\t\t\t\tpin->work_pin_ts[idx]);\n\t\t\tpin->work_pin_events_rd = (idx + 1) % CEC_NUM_PIN_EVENTS;\n\t\t\tatomic_dec(&pin->work_pin_num_events);\n\t\t}\n\n\t\tswitch (atomic_xchg(&pin->work_irq_change,\n\t\t\t\t    CEC_PIN_IRQ_UNCHANGED)) {\n\t\tcase CEC_PIN_IRQ_DISABLE:\n\t\t\tif (pin->enabled_irq) {\n\t\t\t\tpin->ops->disable_irq(adap);\n\t\t\t\tpin->enabled_irq = false;\n\t\t\t\tpin->enable_irq_failed = false;\n\t\t\t}\n\t\t\tcec_pin_high(pin);\n\t\t\tif (pin->state == CEC_ST_OFF)\n\t\t\t\tbreak;\n\t\t\tcec_pin_to_idle(pin);\n\t\t\thrtimer_start(&pin->timer, ns_to_ktime(0),\n\t\t\t\t      HRTIMER_MODE_REL);\n\t\t\tbreak;\n\t\tcase CEC_PIN_IRQ_ENABLE:\n\t\t\tif (pin->enabled_irq || !pin->ops->enable_irq ||\n\t\t\t    pin->adap->devnode.unregistered)\n\t\t\t\tbreak;\n\t\t\tpin->enable_irq_failed = !pin->ops->enable_irq(adap);\n\t\t\tif (pin->enable_irq_failed) {\n\t\t\t\tcec_pin_to_idle(pin);\n\t\t\t\thrtimer_start(&pin->timer, ns_to_ktime(0),\n\t\t\t\t\t      HRTIMER_MODE_REL);\n\t\t\t} else {\n\t\t\t\tpin->enabled_irq = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pin->enabled_irq) {\n\t\tpin->ops->disable_irq(pin->adap);\n\t\tpin->enabled_irq = false;\n\t\tpin->enable_irq_failed = false;\n\t\tcec_pin_high(pin);\n\t}\n\treturn 0;\n}\n\nstatic int cec_pin_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tif (enable) {\n\t\tcec_pin_read(pin);\n\t\tcec_pin_to_idle(pin);\n\t\tpin->tx_msg.len = 0;\n\t\tpin->timer_ts = ns_to_ktime(0);\n\t\tatomic_set(&pin->work_irq_change, CEC_PIN_IRQ_UNCHANGED);\n\t\tif (!pin->kthread) {\n\t\t\tpin->kthread = kthread_run(cec_pin_thread_func, adap,\n\t\t\t\t\t\t   \"cec-pin\");\n\t\t\tif (IS_ERR(pin->kthread)) {\n\t\t\t\tint err = PTR_ERR(pin->kthread);\n\n\t\t\t\tpr_err(\"cec-pin: kernel_thread() failed\\n\");\n\t\t\t\tpin->kthread = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\thrtimer_start(&pin->timer, ns_to_ktime(0),\n\t\t\t      HRTIMER_MODE_REL);\n\t} else if (pin->kthread) {\n\t\thrtimer_cancel(&pin->timer);\n\t\tcec_pin_high(pin);\n\t\tcec_pin_to_idle(pin);\n\t\tpin->state = CEC_ST_OFF;\n\t\tpin->work_tx_status = 0;\n\t\tatomic_set(&pin->work_irq_change, CEC_PIN_IRQ_DISABLE);\n\t\twake_up_interruptible(&pin->kthread_waitq);\n\t}\n\treturn 0;\n}\n\nstatic int cec_pin_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tif (log_addr == CEC_LOG_ADDR_INVALID)\n\t\tpin->la_mask = 0;\n\telse\n\t\tpin->la_mask |= (1 << log_addr);\n\treturn 0;\n}\n\nvoid cec_pin_start_timer(struct cec_pin *pin)\n{\n\tif (pin->state != CEC_ST_RX_IRQ)\n\t\treturn;\n\n\tatomic_set(&pin->work_irq_change, CEC_PIN_IRQ_DISABLE);\n\twake_up_interruptible(&pin->kthread_waitq);\n}\n\nstatic int cec_pin_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t      u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\t \n\tif (pin->state != CEC_ST_IDLE &&\n\t    signal_free_time > CEC_SIGNAL_FREE_TIME_NEW_INITIATOR)\n\t\tsignal_free_time = CEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\n\n\tpin->tx_signal_free_time = signal_free_time;\n\tpin->tx_extra_bytes = 0;\n\tpin->tx_msg = *msg;\n\tif (msg->len > 1) {\n\t\t \n\t\tpin->tx_extra_bytes = tx_add_bytes(pin);\n\t}\n\tif (msg->len > 2 && tx_remove_byte(pin)) {\n\t\t \n\t\tpin->tx_msg.len--;\n\t}\n\tpin->work_tx_status = 0;\n\tpin->tx_bit = 0;\n\tcec_pin_start_timer(pin);\n\treturn 0;\n}\n\nstatic void cec_pin_adap_status(struct cec_adapter *adap,\n\t\t\t\t       struct seq_file *file)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tseq_printf(file, \"state: %s\\n\", states[pin->state].name);\n\tseq_printf(file, \"tx_bit: %d\\n\", pin->tx_bit);\n\tseq_printf(file, \"rx_bit: %d\\n\", pin->rx_bit);\n\tseq_printf(file, \"cec pin: %d\\n\", call_pin_op(pin, read));\n\tseq_printf(file, \"cec pin events dropped: %u\\n\",\n\t\t   pin->work_pin_events_dropped_cnt);\n\tif (pin->ops->enable_irq)\n\t\tseq_printf(file, \"irq %s\\n\", pin->enabled_irq ? \"enabled\" :\n\t\t\t   (pin->enable_irq_failed ? \"failed\" : \"disabled\"));\n\tif (pin->timer_100us_overruns) {\n\t\tseq_printf(file, \"timer overruns > 100us: %u of %u\\n\",\n\t\t\t   pin->timer_100us_overruns, pin->timer_cnt);\n\t\tseq_printf(file, \"timer overruns > 300us: %u of %u\\n\",\n\t\t\t   pin->timer_300us_overruns, pin->timer_cnt);\n\t\tseq_printf(file, \"max timer overrun: %u usecs\\n\",\n\t\t\t   pin->timer_max_overrun);\n\t\tseq_printf(file, \"avg timer overrun: %u usecs\\n\",\n\t\t\t   pin->timer_sum_overrun / pin->timer_100us_overruns);\n\t}\n\tif (pin->rx_start_bit_low_too_short_cnt)\n\t\tseq_printf(file,\n\t\t\t   \"rx start bit low too short: %u (delta %u, ts %llu)\\n\",\n\t\t\t   pin->rx_start_bit_low_too_short_cnt,\n\t\t\t   pin->rx_start_bit_low_too_short_delta,\n\t\t\t   pin->rx_start_bit_low_too_short_ts);\n\tif (pin->rx_start_bit_too_short_cnt)\n\t\tseq_printf(file,\n\t\t\t   \"rx start bit too short: %u (delta %u, ts %llu)\\n\",\n\t\t\t   pin->rx_start_bit_too_short_cnt,\n\t\t\t   pin->rx_start_bit_too_short_delta,\n\t\t\t   pin->rx_start_bit_too_short_ts);\n\tif (pin->rx_start_bit_too_long_cnt)\n\t\tseq_printf(file, \"rx start bit too long: %u\\n\",\n\t\t\t   pin->rx_start_bit_too_long_cnt);\n\tif (pin->rx_data_bit_too_short_cnt)\n\t\tseq_printf(file,\n\t\t\t   \"rx data bit too short: %u (delta %u, ts %llu)\\n\",\n\t\t\t   pin->rx_data_bit_too_short_cnt,\n\t\t\t   pin->rx_data_bit_too_short_delta,\n\t\t\t   pin->rx_data_bit_too_short_ts);\n\tif (pin->rx_data_bit_too_long_cnt)\n\t\tseq_printf(file, \"rx data bit too long: %u\\n\",\n\t\t\t   pin->rx_data_bit_too_long_cnt);\n\tseq_printf(file, \"rx initiated low drive: %u\\n\", pin->rx_low_drive_cnt);\n\tseq_printf(file, \"tx detected low drive: %u\\n\", pin->tx_low_drive_cnt);\n\tpin->work_pin_events_dropped_cnt = 0;\n\tpin->timer_cnt = 0;\n\tpin->timer_100us_overruns = 0;\n\tpin->timer_300us_overruns = 0;\n\tpin->timer_max_overrun = 0;\n\tpin->timer_sum_overrun = 0;\n\tpin->rx_start_bit_low_too_short_cnt = 0;\n\tpin->rx_start_bit_too_short_cnt = 0;\n\tpin->rx_start_bit_too_long_cnt = 0;\n\tpin->rx_data_bit_too_short_cnt = 0;\n\tpin->rx_data_bit_too_long_cnt = 0;\n\tpin->rx_low_drive_cnt = 0;\n\tpin->tx_low_drive_cnt = 0;\n\tcall_void_pin_op(pin, status, file);\n}\n\nstatic int cec_pin_adap_monitor_all_enable(struct cec_adapter *adap,\n\t\t\t\t\t\t  bool enable)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tpin->monitor_all = enable;\n\treturn 0;\n}\n\nstatic void cec_pin_adap_free(struct cec_adapter *adap)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tif (pin->kthread)\n\t\tkthread_stop(pin->kthread);\n\tpin->kthread = NULL;\n\tif (pin->ops->free)\n\t\tpin->ops->free(adap);\n\tadap->pin = NULL;\n\tkfree(pin);\n}\n\nstatic int cec_pin_received(struct cec_adapter *adap, struct cec_msg *msg)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tif (pin->ops->received && !adap->devnode.unregistered)\n\t\treturn pin->ops->received(adap, msg);\n\treturn -ENOMSG;\n}\n\nvoid cec_pin_changed(struct cec_adapter *adap, bool value)\n{\n\tstruct cec_pin *pin = adap->pin;\n\n\tcec_pin_update(pin, value, false);\n\tif (!value && (adap->is_configuring || adap->is_configured ||\n\t\t       adap->monitor_all_cnt || !adap->monitor_pin_cnt))\n\t\tatomic_set(&pin->work_irq_change, CEC_PIN_IRQ_DISABLE);\n}\nEXPORT_SYMBOL_GPL(cec_pin_changed);\n\nstatic const struct cec_adap_ops cec_pin_adap_ops = {\n\t.adap_enable = cec_pin_adap_enable,\n\t.adap_monitor_all_enable = cec_pin_adap_monitor_all_enable,\n\t.adap_log_addr = cec_pin_adap_log_addr,\n\t.adap_transmit = cec_pin_adap_transmit,\n\t.adap_status = cec_pin_adap_status,\n\t.adap_free = cec_pin_adap_free,\n#ifdef CONFIG_CEC_PIN_ERROR_INJ\n\t.error_inj_parse_line = cec_pin_error_inj_parse_line,\n\t.error_inj_show = cec_pin_error_inj_show,\n#endif\n\t.received = cec_pin_received,\n};\n\nstruct cec_adapter *cec_pin_allocate_adapter(const struct cec_pin_ops *pin_ops,\n\t\t\t\t\tvoid *priv, const char *name, u32 caps)\n{\n\tstruct cec_adapter *adap;\n\tstruct cec_pin *pin = kzalloc(sizeof(*pin), GFP_KERNEL);\n\n\tif (pin == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpin->ops = pin_ops;\n\thrtimer_init(&pin->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tatomic_set(&pin->work_pin_num_events, 0);\n\tpin->timer.function = cec_pin_timer;\n\tinit_waitqueue_head(&pin->kthread_waitq);\n\tpin->tx_custom_low_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\tpin->tx_custom_high_usecs = CEC_TIM_CUSTOM_DEFAULT;\n\n\tadap = cec_allocate_adapter(&cec_pin_adap_ops, priv, name,\n\t\t\t    caps | CEC_CAP_MONITOR_ALL | CEC_CAP_MONITOR_PIN,\n\t\t\t    CEC_MAX_LOG_ADDRS);\n\n\tif (IS_ERR(adap)) {\n\t\tkfree(pin);\n\t\treturn adap;\n\t}\n\n\tadap->pin = pin;\n\tpin->adap = adap;\n\tcec_pin_update(pin, cec_pin_high(pin), true);\n\treturn adap;\n}\nEXPORT_SYMBOL_GPL(cec_pin_allocate_adapter);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}