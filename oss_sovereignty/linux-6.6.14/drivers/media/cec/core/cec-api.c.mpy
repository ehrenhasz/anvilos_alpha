{
  "module_name": "cec-api.c",
  "hash_id": "fe8d10dd580ee7eca29112fbcf60390c110e16aeedbbcc0f5ea9a0e18da22156",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-api.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/version.h>\n\n#include <media/cec-pin.h>\n#include \"cec-priv.h\"\n#include \"cec-pin-priv.h\"\n\nstatic inline struct cec_devnode *cec_devnode_data(struct file *filp)\n{\n\tstruct cec_fh *fh = filp->private_data;\n\n\treturn &fh->adap->devnode;\n}\n\n \n\nstatic __poll_t cec_poll(struct file *filp,\n\t\t\t     struct poll_table_struct *poll)\n{\n\tstruct cec_fh *fh = filp->private_data;\n\tstruct cec_adapter *adap = fh->adap;\n\t__poll_t res = 0;\n\n\tpoll_wait(filp, &fh->wait, poll);\n\tif (!cec_is_registered(adap))\n\t\treturn EPOLLERR | EPOLLHUP | EPOLLPRI;\n\tmutex_lock(&adap->lock);\n\tif (adap->is_configured &&\n\t    adap->transmit_queue_sz < CEC_MAX_MSG_TX_QUEUE_SZ)\n\t\tres |= EPOLLOUT | EPOLLWRNORM;\n\tif (fh->queued_msgs)\n\t\tres |= EPOLLIN | EPOLLRDNORM;\n\tif (fh->total_queued_events)\n\t\tres |= EPOLLPRI;\n\tmutex_unlock(&adap->lock);\n\treturn res;\n}\n\nstatic bool cec_is_busy(const struct cec_adapter *adap,\n\t\t\tconst struct cec_fh *fh)\n{\n\tbool valid_initiator = adap->cec_initiator && adap->cec_initiator == fh;\n\tbool valid_follower = adap->cec_follower && adap->cec_follower == fh;\n\n\t \n\tif (valid_initiator || valid_follower)\n\t\treturn false;\n\t \n\treturn adap->cec_initiator ||\n\t       fh->mode_initiator == CEC_MODE_NO_INITIATOR;\n}\n\nstatic long cec_adap_g_caps(struct cec_adapter *adap,\n\t\t\t    struct cec_caps __user *parg)\n{\n\tstruct cec_caps caps = {};\n\n\tstrscpy(caps.driver, adap->devnode.dev.parent->driver->name,\n\t\tsizeof(caps.driver));\n\tstrscpy(caps.name, adap->name, sizeof(caps.name));\n\tcaps.available_log_addrs = adap->available_log_addrs;\n\tcaps.capabilities = adap->capabilities;\n\tcaps.version = LINUX_VERSION_CODE;\n\tif (copy_to_user(parg, &caps, sizeof(caps)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long cec_adap_g_phys_addr(struct cec_adapter *adap,\n\t\t\t\t __u16 __user *parg)\n{\n\tu16 phys_addr;\n\n\tmutex_lock(&adap->lock);\n\tphys_addr = adap->phys_addr;\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &phys_addr, sizeof(phys_addr)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int cec_validate_phys_addr(u16 phys_addr)\n{\n\tint i;\n\n\tif (phys_addr == CEC_PHYS_ADDR_INVALID)\n\t\treturn 0;\n\tfor (i = 0; i < 16; i += 4)\n\t\tif (phys_addr & (0xf << i))\n\t\t\tbreak;\n\tif (i == 16)\n\t\treturn 0;\n\tfor (i += 4; i < 16; i += 4)\n\t\tif ((phys_addr & (0xf << i)) == 0)\n\t\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic long cec_adap_s_phys_addr(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t\t\t bool block, __u16 __user *parg)\n{\n\tu16 phys_addr;\n\tlong err;\n\n\tif (!(adap->capabilities & CEC_CAP_PHYS_ADDR))\n\t\treturn -ENOTTY;\n\tif (copy_from_user(&phys_addr, parg, sizeof(phys_addr)))\n\t\treturn -EFAULT;\n\n\terr = cec_validate_phys_addr(phys_addr);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&adap->lock);\n\tif (cec_is_busy(adap, fh))\n\t\terr = -EBUSY;\n\telse\n\t\t__cec_s_phys_addr(adap, phys_addr, block);\n\tmutex_unlock(&adap->lock);\n\treturn err;\n}\n\nstatic long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\n\tmutex_lock(&adap->lock);\n\t \n\tmemcpy(&log_addrs, &adap->log_addrs, sizeof(log_addrs));\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long cec_adap_s_log_addrs(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t\t\t bool block, struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tlong err = -EBUSY;\n\n\tif (!(adap->capabilities & CEC_CAP_LOG_ADDRS))\n\t\treturn -ENOTTY;\n\tif (copy_from_user(&log_addrs, parg, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\tlog_addrs.flags &= CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK |\n\t\t\t   CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU |\n\t\t\t   CEC_LOG_ADDRS_FL_CDC_ONLY;\n\tmutex_lock(&adap->lock);\n\tif (!adap->is_configuring &&\n\t    (!log_addrs.num_log_addrs || !adap->is_configured) &&\n\t    !cec_is_busy(adap, fh)) {\n\t\terr = __cec_s_log_addrs(adap, &log_addrs, block);\n\t\tif (!err)\n\t\t\tlog_addrs = adap->log_addrs;\n\t}\n\tmutex_unlock(&adap->lock);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long cec_adap_g_connector_info(struct cec_adapter *adap,\n\t\t\t\t      struct cec_log_addrs __user *parg)\n{\n\tint ret = 0;\n\n\tif (!(adap->capabilities & CEC_CAP_CONNECTOR_INFO))\n\t\treturn -ENOTTY;\n\n\tmutex_lock(&adap->lock);\n\tif (copy_to_user(parg, &adap->conn_info, sizeof(adap->conn_info)))\n\t\tret = -EFAULT;\n\tmutex_unlock(&adap->lock);\n\treturn ret;\n}\n\nstatic long cec_transmit(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t\t bool block, struct cec_msg __user *parg)\n{\n\tstruct cec_msg msg = {};\n\tlong err = 0;\n\n\tif (!(adap->capabilities & CEC_CAP_TRANSMIT))\n\t\treturn -ENOTTY;\n\tif (copy_from_user(&msg, parg, sizeof(msg)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&adap->lock);\n\tif (adap->log_addrs.num_log_addrs == 0)\n\t\terr = -EPERM;\n\telse if (adap->is_configuring)\n\t\terr = -ENONET;\n\telse if (cec_is_busy(adap, fh))\n\t\terr = -EBUSY;\n\telse\n\t\terr = cec_transmit_msg_fh(adap, &msg, fh, block);\n\tmutex_unlock(&adap->lock);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(parg, &msg, sizeof(msg)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int cec_receive_msg(struct cec_fh *fh, struct cec_msg *msg, bool block)\n{\n\tu32 timeout = msg->timeout;\n\tint res;\n\n\tdo {\n\t\tmutex_lock(&fh->lock);\n\t\t \n\t\tif (fh->queued_msgs) {\n\t\t\t \n\t\t\tstruct cec_msg_entry *entry =\n\t\t\t\tlist_first_entry(&fh->msgs,\n\t\t\t\t\t\t struct cec_msg_entry, list);\n\n\t\t\tlist_del(&entry->list);\n\t\t\t*msg = entry->msg;\n\t\t\tkfree(entry);\n\t\t\tfh->queued_msgs--;\n\t\t\tmutex_unlock(&fh->lock);\n\t\t\t \n\t\t\tmsg->timeout = timeout;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&fh->lock);\n\n\t\t \n\t\tif (!block)\n\t\t\treturn -EAGAIN;\n\n\t\tif (msg->timeout) {\n\t\t\t \n\t\t\tres = wait_event_interruptible_timeout(fh->wait,\n\t\t\t\t\t\t\t       fh->queued_msgs,\n\t\t\t\tmsecs_to_jiffies(msg->timeout));\n\t\t\tif (res == 0)\n\t\t\t\tres = -ETIMEDOUT;\n\t\t\telse if (res > 0)\n\t\t\t\tres = 0;\n\t\t} else {\n\t\t\t \n\t\t\tres = wait_event_interruptible(fh->wait,\n\t\t\t\t\t\t       fh->queued_msgs);\n\t\t}\n\t\t \n\t} while (!res);\n\treturn res;\n}\n\nstatic long cec_receive(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t\tbool block, struct cec_msg __user *parg)\n{\n\tstruct cec_msg msg = {};\n\tlong err;\n\n\tif (copy_from_user(&msg, parg, sizeof(msg)))\n\t\treturn -EFAULT;\n\n\terr = cec_receive_msg(fh, &msg, block);\n\tif (err)\n\t\treturn err;\n\tmsg.flags = 0;\n\tif (copy_to_user(parg, &msg, sizeof(msg)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long cec_dqevent(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t\tbool block, struct cec_event __user *parg)\n{\n\tstruct cec_event_entry *ev = NULL;\n\tu64 ts = ~0ULL;\n\tunsigned int i;\n\tunsigned int ev_idx;\n\tlong err = 0;\n\n\tmutex_lock(&fh->lock);\n\twhile (!fh->total_queued_events && block) {\n\t\tmutex_unlock(&fh->lock);\n\t\terr = wait_event_interruptible(fh->wait,\n\t\t\t\t\t       fh->total_queued_events);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmutex_lock(&fh->lock);\n\t}\n\n\t \n\tfor (i = 0; i < CEC_NUM_EVENTS; i++) {\n\t\tstruct cec_event_entry *entry =\n\t\t\tlist_first_entry_or_null(&fh->events[i],\n\t\t\t\t\t\t struct cec_event_entry, list);\n\n\t\tif (entry && entry->ev.ts <= ts) {\n\t\t\tev = entry;\n\t\t\tev_idx = i;\n\t\t\tts = ev->ev.ts;\n\t\t}\n\t}\n\n\tif (!ev) {\n\t\terr = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\tlist_del(&ev->list);\n\n\tif (copy_to_user(parg, &ev->ev, sizeof(ev->ev)))\n\t\terr = -EFAULT;\n\tif (ev_idx >= CEC_NUM_CORE_EVENTS)\n\t\tkfree(ev);\n\tfh->queued_events[ev_idx]--;\n\tfh->total_queued_events--;\n\nunlock:\n\tmutex_unlock(&fh->lock);\n\treturn err;\n}\n\nstatic long cec_g_mode(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t       u32 __user *parg)\n{\n\tu32 mode = fh->mode_initiator | fh->mode_follower;\n\n\tif (copy_to_user(parg, &mode, sizeof(mode)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long cec_s_mode(struct cec_adapter *adap, struct cec_fh *fh,\n\t\t       u32 __user *parg)\n{\n\tu32 mode;\n\tu8 mode_initiator;\n\tu8 mode_follower;\n\tbool send_pin_event = false;\n\tlong err = 0;\n\n\tif (copy_from_user(&mode, parg, sizeof(mode)))\n\t\treturn -EFAULT;\n\tif (mode & ~(CEC_MODE_INITIATOR_MSK | CEC_MODE_FOLLOWER_MSK)) {\n\t\tdprintk(1, \"%s: invalid mode bits set\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmode_initiator = mode & CEC_MODE_INITIATOR_MSK;\n\tmode_follower = mode & CEC_MODE_FOLLOWER_MSK;\n\n\tif (mode_initiator > CEC_MODE_EXCL_INITIATOR ||\n\t    mode_follower > CEC_MODE_MONITOR_ALL) {\n\t\tdprintk(1, \"%s: unknown mode\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode_follower == CEC_MODE_MONITOR_ALL &&\n\t    !(adap->capabilities & CEC_CAP_MONITOR_ALL)) {\n\t\tdprintk(1, \"%s: MONITOR_ALL not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode_follower == CEC_MODE_MONITOR_PIN &&\n\t    !(adap->capabilities & CEC_CAP_MONITOR_PIN)) {\n\t\tdprintk(1, \"%s: MONITOR_PIN not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((mode_initiator == CEC_MODE_NO_INITIATOR ||\n\t     !(adap->capabilities & CEC_CAP_TRANSMIT)) &&\n\t    mode_follower >= CEC_MODE_FOLLOWER &&\n\t    mode_follower <= CEC_MODE_EXCL_FOLLOWER_PASSTHRU) {\n\t\tdprintk(1, \"%s: cannot transmit\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode_initiator && mode_follower >= CEC_MODE_MONITOR_PIN) {\n\t\tdprintk(1, \"%s: monitor modes require NO_INITIATOR\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode_follower >= CEC_MODE_MONITOR_PIN && !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&adap->lock);\n\t \n\tif ((mode_follower == CEC_MODE_EXCL_FOLLOWER ||\n\t     mode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU) &&\n\t    adap->cec_follower && adap->cec_follower != fh)\n\t\terr = -EBUSY;\n\t \n\tif (mode_initiator == CEC_MODE_EXCL_INITIATOR &&\n\t    adap->cec_initiator && adap->cec_initiator != fh)\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tbool old_mon_all = fh->mode_follower == CEC_MODE_MONITOR_ALL;\n\t\tbool new_mon_all = mode_follower == CEC_MODE_MONITOR_ALL;\n\n\t\tif (old_mon_all != new_mon_all) {\n\t\t\tif (new_mon_all)\n\t\t\t\terr = cec_monitor_all_cnt_inc(adap);\n\t\t\telse\n\t\t\t\tcec_monitor_all_cnt_dec(adap);\n\t\t}\n\t}\n\n\tif (!err) {\n\t\tbool old_mon_pin = fh->mode_follower == CEC_MODE_MONITOR_PIN;\n\t\tbool new_mon_pin = mode_follower == CEC_MODE_MONITOR_PIN;\n\n\t\tif (old_mon_pin != new_mon_pin) {\n\t\t\tsend_pin_event = new_mon_pin;\n\t\t\tif (new_mon_pin)\n\t\t\t\terr = cec_monitor_pin_cnt_inc(adap);\n\t\t\telse\n\t\t\t\tcec_monitor_pin_cnt_dec(adap);\n\t\t}\n\t}\n\n\tif (err) {\n\t\tmutex_unlock(&adap->lock);\n\t\treturn err;\n\t}\n\n\tif (fh->mode_follower == CEC_MODE_FOLLOWER)\n\t\tadap->follower_cnt--;\n\tif (mode_follower == CEC_MODE_FOLLOWER)\n\t\tadap->follower_cnt++;\n\tif (send_pin_event) {\n\t\tstruct cec_event ev = {\n\t\t\t.flags = CEC_EVENT_FL_INITIAL_STATE,\n\t\t};\n\n\t\tev.event = adap->cec_pin_is_high ? CEC_EVENT_PIN_CEC_HIGH :\n\t\t\t\t\t\t   CEC_EVENT_PIN_CEC_LOW;\n\t\tcec_queue_event_fh(fh, &ev, 0);\n\t}\n\tif (mode_follower == CEC_MODE_EXCL_FOLLOWER ||\n\t    mode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU) {\n\t\tadap->passthrough =\n\t\t\tmode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU;\n\t\tadap->cec_follower = fh;\n\t} else if (adap->cec_follower == fh) {\n\t\tadap->passthrough = false;\n\t\tadap->cec_follower = NULL;\n\t}\n\tif (mode_initiator == CEC_MODE_EXCL_INITIATOR)\n\t\tadap->cec_initiator = fh;\n\telse if (adap->cec_initiator == fh)\n\t\tadap->cec_initiator = NULL;\n\tfh->mode_initiator = mode_initiator;\n\tfh->mode_follower = mode_follower;\n\tmutex_unlock(&adap->lock);\n\treturn 0;\n}\n\nstatic long cec_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct cec_fh *fh = filp->private_data;\n\tstruct cec_adapter *adap = fh->adap;\n\tbool block = !(filp->f_flags & O_NONBLOCK);\n\tvoid __user *parg = (void __user *)arg;\n\n\tif (!cec_is_registered(adap))\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase CEC_ADAP_G_CAPS:\n\t\treturn cec_adap_g_caps(adap, parg);\n\n\tcase CEC_ADAP_G_PHYS_ADDR:\n\t\treturn cec_adap_g_phys_addr(adap, parg);\n\n\tcase CEC_ADAP_S_PHYS_ADDR:\n\t\treturn cec_adap_s_phys_addr(adap, fh, block, parg);\n\n\tcase CEC_ADAP_G_LOG_ADDRS:\n\t\treturn cec_adap_g_log_addrs(adap, parg);\n\n\tcase CEC_ADAP_S_LOG_ADDRS:\n\t\treturn cec_adap_s_log_addrs(adap, fh, block, parg);\n\n\tcase CEC_ADAP_G_CONNECTOR_INFO:\n\t\treturn cec_adap_g_connector_info(adap, parg);\n\n\tcase CEC_TRANSMIT:\n\t\treturn cec_transmit(adap, fh, block, parg);\n\n\tcase CEC_RECEIVE:\n\t\treturn cec_receive(adap, fh, block, parg);\n\n\tcase CEC_DQEVENT:\n\t\treturn cec_dqevent(adap, fh, block, parg);\n\n\tcase CEC_G_MODE:\n\t\treturn cec_g_mode(adap, fh, parg);\n\n\tcase CEC_S_MODE:\n\t\treturn cec_s_mode(adap, fh, parg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int cec_open(struct inode *inode, struct file *filp)\n{\n\tstruct cec_devnode *devnode =\n\t\tcontainer_of(inode->i_cdev, struct cec_devnode, cdev);\n\tstruct cec_adapter *adap = to_cec_adapter(devnode);\n\tstruct cec_fh *fh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\t \n\tstruct cec_event ev = {\n\t\t.event = CEC_EVENT_STATE_CHANGE,\n\t\t.flags = CEC_EVENT_FL_INITIAL_STATE,\n\t};\n\tunsigned int i;\n\tint err;\n\n\tif (!fh)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&fh->msgs);\n\tINIT_LIST_HEAD(&fh->xfer_list);\n\tfor (i = 0; i < CEC_NUM_EVENTS; i++)\n\t\tINIT_LIST_HEAD(&fh->events[i]);\n\tmutex_init(&fh->lock);\n\tinit_waitqueue_head(&fh->wait);\n\n\tfh->mode_initiator = CEC_MODE_INITIATOR;\n\tfh->adap = adap;\n\n\terr = cec_get_device(devnode);\n\tif (err) {\n\t\tkfree(fh);\n\t\treturn err;\n\t}\n\n\tfilp->private_data = fh;\n\n\t \n\tev.state_change.phys_addr = adap->phys_addr;\n\tev.state_change.log_addr_mask = adap->log_addrs.log_addr_mask;\n\tev.state_change.have_conn_info =\n\t\tadap->conn_info.type != CEC_CONNECTOR_TYPE_NO_CONNECTOR;\n\tcec_queue_event_fh(fh, &ev, 0);\n#ifdef CONFIG_CEC_PIN\n\tif (adap->pin && adap->pin->ops->read_hpd &&\n\t    !adap->devnode.unregistered) {\n\t\terr = adap->pin->ops->read_hpd(adap);\n\t\tif (err >= 0) {\n\t\t\tev.event = err ? CEC_EVENT_PIN_HPD_HIGH :\n\t\t\t\t\t CEC_EVENT_PIN_HPD_LOW;\n\t\t\tcec_queue_event_fh(fh, &ev, 0);\n\t\t}\n\t}\n\tif (adap->pin && adap->pin->ops->read_5v &&\n\t    !adap->devnode.unregistered) {\n\t\terr = adap->pin->ops->read_5v(adap);\n\t\tif (err >= 0) {\n\t\t\tev.event = err ? CEC_EVENT_PIN_5V_HIGH :\n\t\t\t\t\t CEC_EVENT_PIN_5V_LOW;\n\t\t\tcec_queue_event_fh(fh, &ev, 0);\n\t\t}\n\t}\n#endif\n\n\tmutex_lock(&devnode->lock);\n\tmutex_lock(&devnode->lock_fhs);\n\tlist_add(&fh->list, &devnode->fhs);\n\tmutex_unlock(&devnode->lock_fhs);\n\tmutex_unlock(&devnode->lock);\n\n\treturn 0;\n}\n\n \nstatic int cec_release(struct inode *inode, struct file *filp)\n{\n\tstruct cec_devnode *devnode = cec_devnode_data(filp);\n\tstruct cec_adapter *adap = to_cec_adapter(devnode);\n\tstruct cec_fh *fh = filp->private_data;\n\tunsigned int i;\n\n\tmutex_lock(&adap->lock);\n\tif (adap->cec_initiator == fh)\n\t\tadap->cec_initiator = NULL;\n\tif (adap->cec_follower == fh) {\n\t\tadap->cec_follower = NULL;\n\t\tadap->passthrough = false;\n\t}\n\tif (fh->mode_follower == CEC_MODE_FOLLOWER)\n\t\tadap->follower_cnt--;\n\tif (fh->mode_follower == CEC_MODE_MONITOR_PIN)\n\t\tcec_monitor_pin_cnt_dec(adap);\n\tif (fh->mode_follower == CEC_MODE_MONITOR_ALL)\n\t\tcec_monitor_all_cnt_dec(adap);\n\tmutex_unlock(&adap->lock);\n\n\tmutex_lock(&devnode->lock);\n\tmutex_lock(&devnode->lock_fhs);\n\tlist_del(&fh->list);\n\tmutex_unlock(&devnode->lock_fhs);\n\tmutex_unlock(&devnode->lock);\n\n\t \n\tmutex_lock(&adap->lock);\n\twhile (!list_empty(&fh->xfer_list)) {\n\t\tstruct cec_data *data =\n\t\t\tlist_first_entry(&fh->xfer_list, struct cec_data, xfer_list);\n\n\t\tdata->blocking = false;\n\t\tdata->fh = NULL;\n\t\tlist_del_init(&data->xfer_list);\n\t}\n\tmutex_unlock(&adap->lock);\n\twhile (!list_empty(&fh->msgs)) {\n\t\tstruct cec_msg_entry *entry =\n\t\t\tlist_first_entry(&fh->msgs, struct cec_msg_entry, list);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tfor (i = CEC_NUM_CORE_EVENTS; i < CEC_NUM_EVENTS; i++) {\n\t\twhile (!list_empty(&fh->events[i])) {\n\t\t\tstruct cec_event_entry *entry =\n\t\t\t\tlist_first_entry(&fh->events[i],\n\t\t\t\t\t\t struct cec_event_entry, list);\n\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\tkfree(fh);\n\n\tcec_put_device(devnode);\n\tfilp->private_data = NULL;\n\treturn 0;\n}\n\nconst struct file_operations cec_devnode_fops = {\n\t.owner = THIS_MODULE,\n\t.open = cec_open,\n\t.unlocked_ioctl = cec_ioctl,\n\t.compat_ioctl = cec_ioctl,\n\t.release = cec_release,\n\t.poll = cec_poll,\n\t.llseek = no_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}