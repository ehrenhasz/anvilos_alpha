{
  "module_name": "cec-notifier.c",
  "hash_id": "40e166f6bdfe0320eec0ecfa895b288b84b0cb4d12801ac672ac4a9170fda549",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/core/cec-notifier.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/of_platform.h>\n\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n#include <drm/drm_edid.h>\n\nstruct cec_notifier {\n\tstruct mutex lock;\n\tstruct list_head head;\n\tstruct kref kref;\n\tstruct device *hdmi_dev;\n\tstruct cec_connector_info conn_info;\n\tconst char *port_name;\n\tstruct cec_adapter *cec_adap;\n\n\tu16 phys_addr;\n};\n\nstatic LIST_HEAD(cec_notifiers);\nstatic DEFINE_MUTEX(cec_notifiers_lock);\n\n \nstatic struct cec_notifier *\ncec_notifier_get_conn(struct device *hdmi_dev, const char *port_name)\n{\n\tstruct cec_notifier *n;\n\n\tmutex_lock(&cec_notifiers_lock);\n\tlist_for_each_entry(n, &cec_notifiers, head) {\n\t\tif (n->hdmi_dev == hdmi_dev &&\n\t\t    (!port_name ||\n\t\t     (n->port_name && !strcmp(n->port_name, port_name)))) {\n\t\t\tkref_get(&n->kref);\n\t\t\tmutex_unlock(&cec_notifiers_lock);\n\t\t\treturn n;\n\t\t}\n\t}\n\tn = kzalloc(sizeof(*n), GFP_KERNEL);\n\tif (!n)\n\t\tgoto unlock;\n\tn->hdmi_dev = hdmi_dev;\n\tif (port_name) {\n\t\tn->port_name = kstrdup(port_name, GFP_KERNEL);\n\t\tif (!n->port_name) {\n\t\t\tkfree(n);\n\t\t\tn = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tn->phys_addr = CEC_PHYS_ADDR_INVALID;\n\n\tmutex_init(&n->lock);\n\tkref_init(&n->kref);\n\tlist_add_tail(&n->head, &cec_notifiers);\nunlock:\n\tmutex_unlock(&cec_notifiers_lock);\n\treturn n;\n}\n\nstatic void cec_notifier_release(struct kref *kref)\n{\n\tstruct cec_notifier *n =\n\t\tcontainer_of(kref, struct cec_notifier, kref);\n\n\tlist_del(&n->head);\n\tkfree(n->port_name);\n\tkfree(n);\n}\n\nstatic void cec_notifier_put(struct cec_notifier *n)\n{\n\tmutex_lock(&cec_notifiers_lock);\n\tkref_put(&n->kref, cec_notifier_release);\n\tmutex_unlock(&cec_notifiers_lock);\n}\n\nstruct cec_notifier *\ncec_notifier_conn_register(struct device *hdmi_dev, const char *port_name,\n\t\t\t   const struct cec_connector_info *conn_info)\n{\n\tstruct cec_notifier *n = cec_notifier_get_conn(hdmi_dev, port_name);\n\n\tif (!n)\n\t\treturn n;\n\n\tmutex_lock(&n->lock);\n\tn->phys_addr = CEC_PHYS_ADDR_INVALID;\n\tif (conn_info)\n\t\tn->conn_info = *conn_info;\n\telse\n\t\tmemset(&n->conn_info, 0, sizeof(n->conn_info));\n\tif (n->cec_adap) {\n\t\tif (!n->cec_adap->adap_controls_phys_addr)\n\t\t\tcec_phys_addr_invalidate(n->cec_adap);\n\t\tcec_s_conn_info(n->cec_adap, conn_info);\n\t}\n\tmutex_unlock(&n->lock);\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(cec_notifier_conn_register);\n\nvoid cec_notifier_conn_unregister(struct cec_notifier *n)\n{\n\tif (!n)\n\t\treturn;\n\n\tmutex_lock(&n->lock);\n\tmemset(&n->conn_info, 0, sizeof(n->conn_info));\n\tn->phys_addr = CEC_PHYS_ADDR_INVALID;\n\tif (n->cec_adap) {\n\t\tif (!n->cec_adap->adap_controls_phys_addr)\n\t\t\tcec_phys_addr_invalidate(n->cec_adap);\n\t\tcec_s_conn_info(n->cec_adap, NULL);\n\t}\n\tmutex_unlock(&n->lock);\n\tcec_notifier_put(n);\n}\nEXPORT_SYMBOL_GPL(cec_notifier_conn_unregister);\n\nstruct cec_notifier *\ncec_notifier_cec_adap_register(struct device *hdmi_dev, const char *port_name,\n\t\t\t       struct cec_adapter *adap)\n{\n\tstruct cec_notifier *n;\n\n\tif (WARN_ON(!adap))\n\t\treturn NULL;\n\n\tn = cec_notifier_get_conn(hdmi_dev, port_name);\n\tif (!n)\n\t\treturn n;\n\n\tmutex_lock(&n->lock);\n\tn->cec_adap = adap;\n\tadap->conn_info = n->conn_info;\n\tadap->notifier = n;\n\tif (!adap->adap_controls_phys_addr)\n\t\tcec_s_phys_addr(adap, n->phys_addr, false);\n\tmutex_unlock(&n->lock);\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(cec_notifier_cec_adap_register);\n\nvoid cec_notifier_cec_adap_unregister(struct cec_notifier *n,\n\t\t\t\t      struct cec_adapter *adap)\n{\n\tif (!n)\n\t\treturn;\n\n\tmutex_lock(&n->lock);\n\tadap->notifier = NULL;\n\tn->cec_adap = NULL;\n\tmutex_unlock(&n->lock);\n\tcec_notifier_put(n);\n}\nEXPORT_SYMBOL_GPL(cec_notifier_cec_adap_unregister);\n\nvoid cec_notifier_set_phys_addr(struct cec_notifier *n, u16 pa)\n{\n\tif (n == NULL)\n\t\treturn;\n\n\tmutex_lock(&n->lock);\n\tn->phys_addr = pa;\n\tif (n->cec_adap && !n->cec_adap->adap_controls_phys_addr)\n\t\tcec_s_phys_addr(n->cec_adap, n->phys_addr, false);\n\tmutex_unlock(&n->lock);\n}\nEXPORT_SYMBOL_GPL(cec_notifier_set_phys_addr);\n\nvoid cec_notifier_set_phys_addr_from_edid(struct cec_notifier *n,\n\t\t\t\t\t  const struct edid *edid)\n{\n\tu16 pa = CEC_PHYS_ADDR_INVALID;\n\n\tif (n == NULL)\n\t\treturn;\n\n\tif (edid && edid->extensions)\n\t\tpa = cec_get_edid_phys_addr((const u8 *)edid,\n\t\t\t\tEDID_LENGTH * (edid->extensions + 1), NULL);\n\tcec_notifier_set_phys_addr(n, pa);\n}\nEXPORT_SYMBOL_GPL(cec_notifier_set_phys_addr_from_edid);\n\nstruct device *cec_notifier_parse_hdmi_phandle(struct device *dev)\n{\n\tstruct platform_device *hdmi_pdev;\n\tstruct device *hdmi_dev = NULL;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(dev->of_node, \"hdmi-phandle\", 0);\n\n\tif (!np) {\n\t\tdev_err(dev, \"Failed to find HDMI node in device tree\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\thdmi_pdev = of_find_device_by_node(np);\n\tif (hdmi_pdev)\n\t\thdmi_dev = &hdmi_pdev->dev;\n#if IS_REACHABLE(CONFIG_I2C)\n\tif (!hdmi_dev) {\n\t\tstruct i2c_client *hdmi_client = of_find_i2c_device_by_node(np);\n\n\t\tif (hdmi_client)\n\t\t\thdmi_dev = &hdmi_client->dev;\n\t}\n#endif\n\tof_node_put(np);\n\tif (!hdmi_dev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tput_device(hdmi_dev);\n\treturn hdmi_dev;\n}\nEXPORT_SYMBOL_GPL(cec_notifier_parse_hdmi_phandle);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}