{
  "module_name": "pulse8-cec.c",
  "hash_id": "e95d4b5a5722b7de615af9593d1986c263c05557eb6d260bfa6bf6179b045f1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/usb/pulse8/pulse8-cec.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/delay.h>\n\n#include <media/cec.h>\n\nMODULE_AUTHOR(\"Hans Verkuil <hverkuil@xs4all.nl>\");\nMODULE_DESCRIPTION(\"Pulse Eight HDMI CEC driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nstatic int persistent_config;\nmodule_param(debug, int, 0644);\nmodule_param(persistent_config, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\nMODULE_PARM_DESC(persistent_config, \"read config from persistent memory (0-1)\");\n\nenum pulse8_msgcodes {\n\tMSGCODE_NOTHING = 0,\n\tMSGCODE_PING,\n\tMSGCODE_TIMEOUT_ERROR,\n\tMSGCODE_HIGH_ERROR,\n\tMSGCODE_LOW_ERROR,\n\tMSGCODE_FRAME_START,\n\tMSGCODE_FRAME_DATA,\n\tMSGCODE_RECEIVE_FAILED,\n\tMSGCODE_COMMAND_ACCEPTED,\t \n\tMSGCODE_COMMAND_REJECTED,\n\tMSGCODE_SET_ACK_MASK,\n\tMSGCODE_TRANSMIT,\n\tMSGCODE_TRANSMIT_EOM,\n\tMSGCODE_TRANSMIT_IDLETIME,\n\tMSGCODE_TRANSMIT_ACK_POLARITY,\n\tMSGCODE_TRANSMIT_LINE_TIMEOUT,\n\tMSGCODE_TRANSMIT_SUCCEEDED,\t \n\tMSGCODE_TRANSMIT_FAILED_LINE,\n\tMSGCODE_TRANSMIT_FAILED_ACK,\n\tMSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA,\n\tMSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE,\n\tMSGCODE_FIRMWARE_VERSION,\n\tMSGCODE_START_BOOTLOADER,\n\tMSGCODE_GET_BUILDDATE,\n\tMSGCODE_SET_CONTROLLED,\t\t \n\tMSGCODE_GET_AUTO_ENABLED,\n\tMSGCODE_SET_AUTO_ENABLED,\n\tMSGCODE_GET_DEFAULT_LOGICAL_ADDRESS,\n\tMSGCODE_SET_DEFAULT_LOGICAL_ADDRESS,\n\tMSGCODE_GET_LOGICAL_ADDRESS_MASK,\n\tMSGCODE_SET_LOGICAL_ADDRESS_MASK,\n\tMSGCODE_GET_PHYSICAL_ADDRESS,\n\tMSGCODE_SET_PHYSICAL_ADDRESS,\t \n\tMSGCODE_GET_DEVICE_TYPE,\n\tMSGCODE_SET_DEVICE_TYPE,\n\tMSGCODE_GET_HDMI_VERSION,\t \n\tMSGCODE_SET_HDMI_VERSION,\n\tMSGCODE_GET_OSD_NAME,\n\tMSGCODE_SET_OSD_NAME,\n\tMSGCODE_WRITE_EEPROM,\n\tMSGCODE_GET_ADAPTER_TYPE,\t \n\tMSGCODE_SET_ACTIVE_SOURCE,\n\tMSGCODE_GET_AUTO_POWER_ON,\t \n\tMSGCODE_SET_AUTO_POWER_ON,\n\n\tMSGCODE_FRAME_EOM = 0x80,\n\tMSGCODE_FRAME_ACK = 0x40,\n};\n\nstatic const char * const pulse8_msgnames[] = {\n\t\"NOTHING\",\n\t\"PING\",\n\t\"TIMEOUT_ERROR\",\n\t\"HIGH_ERROR\",\n\t\"LOW_ERROR\",\n\t\"FRAME_START\",\n\t\"FRAME_DATA\",\n\t\"RECEIVE_FAILED\",\n\t\"COMMAND_ACCEPTED\",\n\t\"COMMAND_REJECTED\",\n\t\"SET_ACK_MASK\",\n\t\"TRANSMIT\",\n\t\"TRANSMIT_EOM\",\n\t\"TRANSMIT_IDLETIME\",\n\t\"TRANSMIT_ACK_POLARITY\",\n\t\"TRANSMIT_LINE_TIMEOUT\",\n\t\"TRANSMIT_SUCCEEDED\",\n\t\"TRANSMIT_FAILED_LINE\",\n\t\"TRANSMIT_FAILED_ACK\",\n\t\"TRANSMIT_FAILED_TIMEOUT_DATA\",\n\t\"TRANSMIT_FAILED_TIMEOUT_LINE\",\n\t\"FIRMWARE_VERSION\",\n\t\"START_BOOTLOADER\",\n\t\"GET_BUILDDATE\",\n\t\"SET_CONTROLLED\",\n\t\"GET_AUTO_ENABLED\",\n\t\"SET_AUTO_ENABLED\",\n\t\"GET_DEFAULT_LOGICAL_ADDRESS\",\n\t\"SET_DEFAULT_LOGICAL_ADDRESS\",\n\t\"GET_LOGICAL_ADDRESS_MASK\",\n\t\"SET_LOGICAL_ADDRESS_MASK\",\n\t\"GET_PHYSICAL_ADDRESS\",\n\t\"SET_PHYSICAL_ADDRESS\",\n\t\"GET_DEVICE_TYPE\",\n\t\"SET_DEVICE_TYPE\",\n\t\"GET_HDMI_VERSION\",\n\t\"SET_HDMI_VERSION\",\n\t\"GET_OSD_NAME\",\n\t\"SET_OSD_NAME\",\n\t\"WRITE_EEPROM\",\n\t\"GET_ADAPTER_TYPE\",\n\t\"SET_ACTIVE_SOURCE\",\n\t\"GET_AUTO_POWER_ON\",\n\t\"SET_AUTO_POWER_ON\",\n};\n\nstatic const char *pulse8_msgname(u8 cmd)\n{\n\tstatic char unknown_msg[5];\n\n\tif ((cmd & 0x3f) < ARRAY_SIZE(pulse8_msgnames))\n\t\treturn pulse8_msgnames[cmd & 0x3f];\n\tsnprintf(unknown_msg, sizeof(unknown_msg), \"0x%02x\", cmd);\n\treturn unknown_msg;\n}\n\n#define MSGSTART\t0xff\n#define MSGEND\t\t0xfe\n#define MSGESC\t\t0xfd\n#define MSGOFFSET\t3\n\n#define DATA_SIZE 256\n\n#define PING_PERIOD\t(15 * HZ)\n\n#define NUM_MSGS 8\n\nstruct pulse8 {\n\tstruct device *dev;\n\tstruct serio *serio;\n\tstruct cec_adapter *adap;\n\tunsigned int vers;\n\n\tstruct delayed_work ping_eeprom_work;\n\n\tstruct work_struct irq_work;\n\tstruct cec_msg rx_msg[NUM_MSGS];\n\tunsigned int rx_msg_cur_idx, rx_msg_num;\n\t \n\tspinlock_t msg_lock;\n\tu8 new_rx_msg[CEC_MAX_MSG_SIZE];\n\tu8 new_rx_msg_len;\n\n\tstruct work_struct tx_work;\n\tu32 tx_done_status;\n\tu32 tx_signal_free_time;\n\tstruct cec_msg tx_msg;\n\tbool tx_msg_is_bcast;\n\n\tstruct completion cmd_done;\n\tu8 data[DATA_SIZE];\n\tunsigned int len;\n\tu8 buf[DATA_SIZE];\n\tunsigned int idx;\n\tbool escape;\n\tbool started;\n\n\t \n\tstruct mutex lock;\n\tbool config_pending;\n\tbool restoring_config;\n\tbool autonomous;\n};\n\nstatic int pulse8_send(struct serio *serio, const u8 *command, u8 cmd_len)\n{\n\tint err = 0;\n\n\terr = serio_write(serio, MSGSTART);\n\tif (err)\n\t\treturn err;\n\tfor (; !err && cmd_len; command++, cmd_len--) {\n\t\tif (*command >= MSGESC) {\n\t\t\terr = serio_write(serio, MSGESC);\n\t\t\tif (!err)\n\t\t\t\terr = serio_write(serio, *command - MSGOFFSET);\n\t\t} else {\n\t\t\terr = serio_write(serio, *command);\n\t\t}\n\t}\n\tif (!err)\n\t\terr = serio_write(serio, MSGEND);\n\n\treturn err;\n}\n\nstatic int pulse8_send_and_wait_once(struct pulse8 *pulse8,\n\t\t\t\t     const u8 *cmd, u8 cmd_len,\n\t\t\t\t     u8 response, u8 size)\n{\n\tint err;\n\n\tif (debug > 1)\n\t\tdev_info(pulse8->dev, \"transmit %s: %*ph\\n\",\n\t\t\t pulse8_msgname(cmd[0]), cmd_len, cmd);\n\tinit_completion(&pulse8->cmd_done);\n\n\terr = pulse8_send(pulse8->serio, cmd, cmd_len);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&pulse8->cmd_done, HZ))\n\t\treturn -ETIMEDOUT;\n\tif ((pulse8->data[0] & 0x3f) == MSGCODE_COMMAND_REJECTED &&\n\t    cmd[0] != MSGCODE_SET_CONTROLLED &&\n\t    cmd[0] != MSGCODE_SET_AUTO_ENABLED &&\n\t    cmd[0] != MSGCODE_GET_BUILDDATE)\n\t\treturn -ENOTTY;\n\tif (response &&\n\t    ((pulse8->data[0] & 0x3f) != response || pulse8->len < size + 1)) {\n\t\tdev_info(pulse8->dev, \"transmit %s failed with %s\\n\",\n\t\t\t pulse8_msgname(cmd[0]),\n\t\t\t pulse8_msgname(pulse8->data[0]));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int pulse8_send_and_wait(struct pulse8 *pulse8,\n\t\t\t\tconst u8 *cmd, u8 cmd_len, u8 response, u8 size)\n{\n\tu8 cmd_sc[2];\n\tint err;\n\n\terr = pulse8_send_and_wait_once(pulse8, cmd, cmd_len, response, size);\n\tif (err != -ENOTTY)\n\t\treturn err;\n\n\tcmd_sc[0] = MSGCODE_SET_CONTROLLED;\n\tcmd_sc[1] = 1;\n\terr = pulse8_send_and_wait_once(pulse8, cmd_sc, 2,\n\t\t\t\t\tMSGCODE_COMMAND_ACCEPTED, 1);\n\tif (!err)\n\t\terr = pulse8_send_and_wait_once(pulse8, cmd, cmd_len,\n\t\t\t\t\t\tresponse, size);\n\treturn err == -ENOTTY ? -EIO : err;\n}\n\nstatic void pulse8_tx_work_handler(struct work_struct *work)\n{\n\tstruct pulse8 *pulse8 = container_of(work, struct pulse8, tx_work);\n\tstruct cec_msg *msg = &pulse8->tx_msg;\n\tunsigned int i;\n\tu8 cmd[2];\n\tint err;\n\n\tif (msg->len == 0)\n\t\treturn;\n\n\tmutex_lock(&pulse8->lock);\n\tcmd[0] = MSGCODE_TRANSMIT_IDLETIME;\n\tcmd[1] = pulse8->tx_signal_free_time;\n\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 1);\n\tcmd[0] = MSGCODE_TRANSMIT_ACK_POLARITY;\n\tcmd[1] = cec_msg_is_broadcast(msg);\n\tpulse8->tx_msg_is_bcast = cec_msg_is_broadcast(msg);\n\tif (!err)\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 1);\n\tcmd[0] = msg->len == 1 ? MSGCODE_TRANSMIT_EOM : MSGCODE_TRANSMIT;\n\tcmd[1] = msg->msg[0];\n\tif (!err)\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 1);\n\tif (!err && msg->len > 1) {\n\t\tfor (i = 1; !err && i < msg->len; i++) {\n\t\t\tcmd[0] = ((i == msg->len - 1)) ?\n\t\t\t\tMSGCODE_TRANSMIT_EOM : MSGCODE_TRANSMIT;\n\t\t\tcmd[1] = msg->msg[i];\n\t\t\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 1);\n\t\t}\n\t}\n\tif (err && debug)\n\t\tdev_info(pulse8->dev, \"%s(0x%02x) failed with error %d for msg %*ph\\n\",\n\t\t\t pulse8_msgname(cmd[0]), cmd[1],\n\t\t\t err, msg->len, msg->msg);\n\tmsg->len = 0;\n\tmutex_unlock(&pulse8->lock);\n\tif (err)\n\t\tcec_transmit_attempt_done(pulse8->adap, CEC_TX_STATUS_ERROR);\n}\n\nstatic void pulse8_irq_work_handler(struct work_struct *work)\n{\n\tstruct pulse8 *pulse8 =\n\t\tcontainer_of(work, struct pulse8, irq_work);\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&pulse8->msg_lock, flags);\n\twhile (pulse8->rx_msg_num) {\n\t\tspin_unlock_irqrestore(&pulse8->msg_lock, flags);\n\t\tif (debug)\n\t\t\tdev_info(pulse8->dev, \"adap received %*ph\\n\",\n\t\t\t\t pulse8->rx_msg[pulse8->rx_msg_cur_idx].len,\n\t\t\t\t pulse8->rx_msg[pulse8->rx_msg_cur_idx].msg);\n\t\tcec_received_msg(pulse8->adap,\n\t\t\t\t &pulse8->rx_msg[pulse8->rx_msg_cur_idx]);\n\t\tspin_lock_irqsave(&pulse8->msg_lock, flags);\n\t\tif (pulse8->rx_msg_num)\n\t\t\tpulse8->rx_msg_num--;\n\t\tpulse8->rx_msg_cur_idx =\n\t\t\t(pulse8->rx_msg_cur_idx + 1) % NUM_MSGS;\n\t}\n\tspin_unlock_irqrestore(&pulse8->msg_lock, flags);\n\n\tmutex_lock(&pulse8->lock);\n\tstatus = pulse8->tx_done_status;\n\tpulse8->tx_done_status = 0;\n\tmutex_unlock(&pulse8->lock);\n\tif (status)\n\t\tcec_transmit_attempt_done(pulse8->adap, status);\n}\n\nstatic irqreturn_t pulse8_interrupt(struct serio *serio, unsigned char data,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct pulse8 *pulse8 = serio_get_drvdata(serio);\n\tunsigned long irq_flags;\n\tunsigned int idx;\n\n\tif (!pulse8->started && data != MSGSTART)\n\t\treturn IRQ_HANDLED;\n\tif (data == MSGESC) {\n\t\tpulse8->escape = true;\n\t\treturn IRQ_HANDLED;\n\t}\n\tif (pulse8->escape) {\n\t\tdata += MSGOFFSET;\n\t\tpulse8->escape = false;\n\t} else if (data == MSGEND) {\n\t\tu8 msgcode = pulse8->buf[0];\n\n\t\tif (debug > 1)\n\t\t\tdev_info(pulse8->dev, \"received %s: %*ph\\n\",\n\t\t\t\t pulse8_msgname(msgcode),\n\t\t\t\t pulse8->idx, pulse8->buf);\n\t\tswitch (msgcode & 0x3f) {\n\t\tcase MSGCODE_FRAME_START:\n\t\t\t \n\t\t\tif (!(msgcode & MSGCODE_FRAME_EOM)) {\n\t\t\t\tpulse8->new_rx_msg_len = 1;\n\t\t\t\tpulse8->new_rx_msg[0] = pulse8->buf[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase MSGCODE_FRAME_DATA:\n\t\t\tif (pulse8->new_rx_msg_len < CEC_MAX_MSG_SIZE)\n\t\t\t\tpulse8->new_rx_msg[pulse8->new_rx_msg_len++] =\n\t\t\t\t\tpulse8->buf[1];\n\t\t\tif (!(msgcode & MSGCODE_FRAME_EOM))\n\t\t\t\tbreak;\n\n\t\t\tspin_lock_irqsave(&pulse8->msg_lock, irq_flags);\n\t\t\tidx = (pulse8->rx_msg_cur_idx + pulse8->rx_msg_num) %\n\t\t\t\tNUM_MSGS;\n\t\t\tif (pulse8->rx_msg_num == NUM_MSGS) {\n\t\t\t\tdev_warn(pulse8->dev,\n\t\t\t\t\t \"message queue is full, dropping %*ph\\n\",\n\t\t\t\t\t pulse8->new_rx_msg_len,\n\t\t\t\t\t pulse8->new_rx_msg);\n\t\t\t\tspin_unlock_irqrestore(&pulse8->msg_lock,\n\t\t\t\t\t\t       irq_flags);\n\t\t\t\tpulse8->new_rx_msg_len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpulse8->rx_msg_num++;\n\t\t\tmemcpy(pulse8->rx_msg[idx].msg, pulse8->new_rx_msg,\n\t\t\t       pulse8->new_rx_msg_len);\n\t\t\tpulse8->rx_msg[idx].len = pulse8->new_rx_msg_len;\n\t\t\tspin_unlock_irqrestore(&pulse8->msg_lock, irq_flags);\n\t\t\tschedule_work(&pulse8->irq_work);\n\t\t\tpulse8->new_rx_msg_len = 0;\n\t\t\tbreak;\n\t\tcase MSGCODE_TRANSMIT_SUCCEEDED:\n\t\t\tWARN_ON(pulse8->tx_done_status);\n\t\t\tpulse8->tx_done_status = CEC_TX_STATUS_OK;\n\t\t\tschedule_work(&pulse8->irq_work);\n\t\t\tbreak;\n\t\tcase MSGCODE_TRANSMIT_FAILED_ACK:\n\t\t\t \n\t\t\tif (pulse8->tx_msg_is_bcast)\n\t\t\t\tbreak;\n\t\t\tWARN_ON(pulse8->tx_done_status);\n\t\t\tpulse8->tx_done_status = CEC_TX_STATUS_NACK;\n\t\t\tschedule_work(&pulse8->irq_work);\n\t\t\tbreak;\n\t\tcase MSGCODE_TRANSMIT_FAILED_LINE:\n\t\tcase MSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA:\n\t\tcase MSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE:\n\t\t\tWARN_ON(pulse8->tx_done_status);\n\t\t\tpulse8->tx_done_status = CEC_TX_STATUS_ERROR;\n\t\t\tschedule_work(&pulse8->irq_work);\n\t\t\tbreak;\n\t\tcase MSGCODE_HIGH_ERROR:\n\t\tcase MSGCODE_LOW_ERROR:\n\t\tcase MSGCODE_RECEIVE_FAILED:\n\t\tcase MSGCODE_TIMEOUT_ERROR:\n\t\t\tpulse8->new_rx_msg_len = 0;\n\t\t\tbreak;\n\t\tcase MSGCODE_COMMAND_ACCEPTED:\n\t\tcase MSGCODE_COMMAND_REJECTED:\n\t\tdefault:\n\t\t\tif (pulse8->idx == 0)\n\t\t\t\tbreak;\n\t\t\tmemcpy(pulse8->data, pulse8->buf, pulse8->idx);\n\t\t\tpulse8->len = pulse8->idx;\n\t\t\tcomplete(&pulse8->cmd_done);\n\t\t\tbreak;\n\t\t}\n\t\tpulse8->idx = 0;\n\t\tpulse8->started = false;\n\t\treturn IRQ_HANDLED;\n\t} else if (data == MSGSTART) {\n\t\tpulse8->idx = 0;\n\t\tpulse8->started = true;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (pulse8->idx >= DATA_SIZE) {\n\t\tdev_dbg(pulse8->dev,\n\t\t\t\"throwing away %d bytes of garbage\\n\", pulse8->idx);\n\t\tpulse8->idx = 0;\n\t}\n\tpulse8->buf[pulse8->idx++] = data;\n\treturn IRQ_HANDLED;\n}\n\nstatic int pulse8_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct pulse8 *pulse8 = cec_get_drvdata(adap);\n\tu8 cmd[16];\n\tint err;\n\n\tmutex_lock(&pulse8->lock);\n\tcmd[0] = MSGCODE_SET_CONTROLLED;\n\tcmd[1] = enable;\n\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 1);\n\tif (!enable) {\n\t\tpulse8->rx_msg_num = 0;\n\t\tpulse8->tx_done_status = 0;\n\t}\n\tmutex_unlock(&pulse8->lock);\n\treturn enable ? err : 0;\n}\n\nstatic int pulse8_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct pulse8 *pulse8 = cec_get_drvdata(adap);\n\tu16 mask = 0;\n\tu16 pa = adap->phys_addr;\n\tu8 cmd[16];\n\tint err = 0;\n\n\tmutex_lock(&pulse8->lock);\n\tif (log_addr != CEC_LOG_ADDR_INVALID)\n\t\tmask = 1 << log_addr;\n\tcmd[0] = MSGCODE_SET_ACK_MASK;\n\tcmd[1] = mask >> 8;\n\tcmd[2] = mask & 0xff;\n\terr = pulse8_send_and_wait(pulse8, cmd, 3,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif ((err && mask != 0) || pulse8->restoring_config)\n\t\tgoto unlock;\n\n\tcmd[0] = MSGCODE_SET_AUTO_ENABLED;\n\tcmd[1] = log_addr == CEC_LOG_ADDR_INVALID ? 0 : 1;\n\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif (err)\n\t\tgoto unlock;\n\tpulse8->autonomous = cmd[1];\n\tif (log_addr == CEC_LOG_ADDR_INVALID)\n\t\tgoto unlock;\n\n\tcmd[0] = MSGCODE_SET_DEVICE_TYPE;\n\tcmd[1] = adap->log_addrs.primary_device_type[0];\n\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif (err)\n\t\tgoto unlock;\n\n\tswitch (adap->log_addrs.primary_device_type[0]) {\n\tcase CEC_OP_PRIM_DEVTYPE_TV:\n\t\tmask = CEC_LOG_ADDR_MASK_TV;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_RECORD:\n\t\tmask = CEC_LOG_ADDR_MASK_RECORD;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_TUNER:\n\t\tmask = CEC_LOG_ADDR_MASK_TUNER;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_PLAYBACK:\n\t\tmask = CEC_LOG_ADDR_MASK_PLAYBACK;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM:\n\t\tmask = CEC_LOG_ADDR_MASK_AUDIOSYSTEM;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_SWITCH:\n\t\tmask = CEC_LOG_ADDR_MASK_UNREGISTERED;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_PROCESSOR:\n\t\tmask = CEC_LOG_ADDR_MASK_SPECIFIC;\n\t\tbreak;\n\tdefault:\n\t\tmask = 0;\n\t\tbreak;\n\t}\n\tcmd[0] = MSGCODE_SET_LOGICAL_ADDRESS_MASK;\n\tcmd[1] = mask >> 8;\n\tcmd[2] = mask & 0xff;\n\terr = pulse8_send_and_wait(pulse8, cmd, 3,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif (err)\n\t\tgoto unlock;\n\n\tcmd[0] = MSGCODE_SET_DEFAULT_LOGICAL_ADDRESS;\n\tcmd[1] = log_addr;\n\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif (err)\n\t\tgoto unlock;\n\n\tcmd[0] = MSGCODE_SET_PHYSICAL_ADDRESS;\n\tcmd[1] = pa >> 8;\n\tcmd[2] = pa & 0xff;\n\terr = pulse8_send_and_wait(pulse8, cmd, 3,\n\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (pulse8->vers < 10) {\n\t\tcmd[0] = MSGCODE_SET_HDMI_VERSION;\n\t\tcmd[1] = adap->log_addrs.cec_version;\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 2,\n\t\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tif (adap->log_addrs.osd_name[0]) {\n\t\tsize_t osd_len = strlen(adap->log_addrs.osd_name);\n\t\tchar *osd_str = cmd + 1;\n\n\t\tcmd[0] = MSGCODE_SET_OSD_NAME;\n\t\tstrscpy(cmd + 1, adap->log_addrs.osd_name, sizeof(cmd) - 1);\n\t\tif (osd_len < 4) {\n\t\t\tmemset(osd_str + osd_len, ' ', 4 - osd_len);\n\t\t\tosd_len = 4;\n\t\t\tosd_str[osd_len] = '\\0';\n\t\t\tstrscpy(adap->log_addrs.osd_name, osd_str,\n\t\t\t\tsizeof(adap->log_addrs.osd_name));\n\t\t}\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 1 + osd_len,\n\t\t\t\t\t   MSGCODE_COMMAND_ACCEPTED, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tif (pulse8->restoring_config)\n\t\tpulse8->restoring_config = false;\n\telse\n\t\tpulse8->config_pending = true;\n\tmutex_unlock(&pulse8->lock);\n\treturn log_addr == CEC_LOG_ADDR_INVALID ? 0 : err;\n}\n\nstatic int pulse8_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t    u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct pulse8 *pulse8 = cec_get_drvdata(adap);\n\n\tpulse8->tx_msg = *msg;\n\tif (debug)\n\t\tdev_info(pulse8->dev, \"adap transmit %*ph\\n\",\n\t\t\t msg->len, msg->msg);\n\tpulse8->tx_signal_free_time = signal_free_time;\n\tschedule_work(&pulse8->tx_work);\n\treturn 0;\n}\n\nstatic void pulse8_cec_adap_free(struct cec_adapter *adap)\n{\n\tstruct pulse8 *pulse8 = cec_get_drvdata(adap);\n\n\tcancel_delayed_work_sync(&pulse8->ping_eeprom_work);\n\tcancel_work_sync(&pulse8->irq_work);\n\tcancel_work_sync(&pulse8->tx_work);\n\tkfree(pulse8);\n}\n\nstatic const struct cec_adap_ops pulse8_cec_adap_ops = {\n\t.adap_enable = pulse8_cec_adap_enable,\n\t.adap_log_addr = pulse8_cec_adap_log_addr,\n\t.adap_transmit = pulse8_cec_adap_transmit,\n\t.adap_free = pulse8_cec_adap_free,\n};\n\nstatic void pulse8_disconnect(struct serio *serio)\n{\n\tstruct pulse8 *pulse8 = serio_get_drvdata(serio);\n\n\tcec_unregister_adapter(pulse8->adap);\n\tserio_set_drvdata(serio, NULL);\n\tserio_close(serio);\n}\n\nstatic int pulse8_setup(struct pulse8 *pulse8, struct serio *serio,\n\t\t\tstruct cec_log_addrs *log_addrs, u16 *pa)\n{\n\tu8 *data = pulse8->data + 1;\n\tu8 cmd[2];\n\tint err;\n\ttime64_t date;\n\n\tpulse8->vers = 0;\n\n\tcmd[0] = MSGCODE_FIRMWARE_VERSION;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 2);\n\tif (err)\n\t\treturn err;\n\tpulse8->vers = (data[0] << 8) | data[1];\n\tdev_info(pulse8->dev, \"Firmware version %04x\\n\", pulse8->vers);\n\tif (pulse8->vers < 2) {\n\t\t*pa = CEC_PHYS_ADDR_INVALID;\n\t\treturn 0;\n\t}\n\n\tcmd[0] = MSGCODE_GET_BUILDDATE;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 4);\n\tif (err)\n\t\treturn err;\n\tdate = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\n\tdev_info(pulse8->dev, \"Firmware build date %ptT\\n\", &date);\n\n\tdev_dbg(pulse8->dev, \"Persistent config:\\n\");\n\tcmd[0] = MSGCODE_GET_AUTO_ENABLED;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\n\tif (err)\n\t\treturn err;\n\tpulse8->autonomous = data[0];\n\tdev_dbg(pulse8->dev, \"Autonomous mode: %s\",\n\t\tdata[0] ? \"on\" : \"off\");\n\n\tif (pulse8->vers >= 10) {\n\t\tcmd[0] = MSGCODE_GET_AUTO_POWER_ON;\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\n\t\tif (!err)\n\t\t\tdev_dbg(pulse8->dev, \"Auto Power On: %s\",\n\t\t\t\tdata[0] ? \"on\" : \"off\");\n\t}\n\n\tcmd[0] = MSGCODE_GET_DEVICE_TYPE;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\n\tif (err)\n\t\treturn err;\n\tlog_addrs->primary_device_type[0] = data[0];\n\tdev_dbg(pulse8->dev, \"Primary device type: %d\\n\", data[0]);\n\tswitch (log_addrs->primary_device_type[0]) {\n\tcase CEC_OP_PRIM_DEVTYPE_TV:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_TV;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_TV;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_RECORD:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_RECORD;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_RECORD;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_TUNER:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_TUNER;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_TUNER;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_PLAYBACK:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_PLAYBACK;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_PLAYBACK;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_PLAYBACK;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_SWITCH:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\n\t\tbreak;\n\tcase CEC_OP_PRIM_DEVTYPE_PROCESSOR:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_SPECIFIC;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\n\t\tbreak;\n\tdefault:\n\t\tlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\n\t\tlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\n\t\tdev_info(pulse8->dev, \"Unknown Primary Device Type: %d\\n\",\n\t\t\t log_addrs->primary_device_type[0]);\n\t\tbreak;\n\t}\n\n\tcmd[0] = MSGCODE_GET_LOGICAL_ADDRESS_MASK;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 2);\n\tif (err)\n\t\treturn err;\n\tlog_addrs->log_addr_mask = (data[0] << 8) | data[1];\n\tdev_dbg(pulse8->dev, \"Logical address ACK mask: %x\\n\",\n\t\tlog_addrs->log_addr_mask);\n\tif (log_addrs->log_addr_mask)\n\t\tlog_addrs->num_log_addrs = 1;\n\n\tcmd[0] = MSGCODE_GET_PHYSICAL_ADDRESS;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\n\tif (err)\n\t\treturn err;\n\t*pa = (data[0] << 8) | data[1];\n\tdev_dbg(pulse8->dev, \"Physical address: %x.%x.%x.%x\\n\",\n\t\tcec_phys_addr_exp(*pa));\n\n\tlog_addrs->cec_version = CEC_OP_CEC_VERSION_1_4;\n\tif (pulse8->vers < 10) {\n\t\tcmd[0] = MSGCODE_GET_HDMI_VERSION;\n\t\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlog_addrs->cec_version = data[0];\n\t\tdev_dbg(pulse8->dev, \"CEC version: %d\\n\", log_addrs->cec_version);\n\t}\n\n\tcmd[0] = MSGCODE_GET_OSD_NAME;\n\terr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 0);\n\tif (err)\n\t\treturn err;\n\tstrscpy(log_addrs->osd_name, data, sizeof(log_addrs->osd_name));\n\tdev_dbg(pulse8->dev, \"OSD name: %s\\n\", log_addrs->osd_name);\n\n\treturn 0;\n}\n\nstatic int pulse8_apply_persistent_config(struct pulse8 *pulse8,\n\t\t\t\t\t  struct cec_log_addrs *log_addrs,\n\t\t\t\t\t  u16 pa)\n{\n\tint err;\n\n\terr = cec_s_log_addrs(pulse8->adap, log_addrs, false);\n\tif (err)\n\t\treturn err;\n\n\tcec_s_phys_addr(pulse8->adap, pa, false);\n\n\treturn 0;\n}\n\nstatic void pulse8_ping_eeprom_work_handler(struct work_struct *work)\n{\n\tstruct pulse8 *pulse8 =\n\t\tcontainer_of(work, struct pulse8, ping_eeprom_work.work);\n\tu8 cmd;\n\n\tmutex_lock(&pulse8->lock);\n\tcmd = MSGCODE_PING;\n\tif (pulse8_send_and_wait(pulse8, &cmd, 1,\n\t\t\t\t MSGCODE_COMMAND_ACCEPTED, 0)) {\n\t\tdev_warn(pulse8->dev, \"failed to ping EEPROM\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (pulse8->vers < 2)\n\t\tgoto unlock;\n\n\tif (pulse8->config_pending && persistent_config) {\n\t\tdev_dbg(pulse8->dev, \"writing pending config to EEPROM\\n\");\n\t\tcmd = MSGCODE_WRITE_EEPROM;\n\t\tif (pulse8_send_and_wait(pulse8, &cmd, 1,\n\t\t\t\t\t MSGCODE_COMMAND_ACCEPTED, 0))\n\t\t\tdev_info(pulse8->dev, \"failed to write pending config to EEPROM\\n\");\n\t\telse\n\t\t\tpulse8->config_pending = false;\n\t}\nunlock:\n\tschedule_delayed_work(&pulse8->ping_eeprom_work, PING_PERIOD);\n\tmutex_unlock(&pulse8->lock);\n}\n\nstatic int pulse8_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tu32 caps = CEC_CAP_DEFAULTS | CEC_CAP_PHYS_ADDR | CEC_CAP_MONITOR_ALL;\n\tstruct pulse8 *pulse8;\n\tint err = -ENOMEM;\n\tstruct cec_log_addrs log_addrs = {};\n\tu16 pa = CEC_PHYS_ADDR_INVALID;\n\n\tpulse8 = kzalloc(sizeof(*pulse8), GFP_KERNEL);\n\n\tif (!pulse8)\n\t\treturn -ENOMEM;\n\n\tpulse8->serio = serio;\n\tpulse8->adap = cec_allocate_adapter(&pulse8_cec_adap_ops, pulse8,\n\t\t\t\t\t    dev_name(&serio->dev), caps, 1);\n\terr = PTR_ERR_OR_ZERO(pulse8->adap);\n\tif (err < 0) {\n\t\tkfree(pulse8);\n\t\treturn err;\n\t}\n\n\tpulse8->dev = &serio->dev;\n\tserio_set_drvdata(serio, pulse8);\n\tINIT_WORK(&pulse8->irq_work, pulse8_irq_work_handler);\n\tINIT_WORK(&pulse8->tx_work, pulse8_tx_work_handler);\n\tINIT_DELAYED_WORK(&pulse8->ping_eeprom_work,\n\t\t\t  pulse8_ping_eeprom_work_handler);\n\tmutex_init(&pulse8->lock);\n\tspin_lock_init(&pulse8->msg_lock);\n\tpulse8->config_pending = false;\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto delete_adap;\n\n\terr = pulse8_setup(pulse8, serio, &log_addrs, &pa);\n\tif (err)\n\t\tgoto close_serio;\n\n\terr = cec_register_adapter(pulse8->adap, &serio->dev);\n\tif (err < 0)\n\t\tgoto close_serio;\n\n\tpulse8->dev = &pulse8->adap->devnode.dev;\n\n\tif (persistent_config && pulse8->autonomous) {\n\t\terr = pulse8_apply_persistent_config(pulse8, &log_addrs, pa);\n\t\tif (err)\n\t\t\tgoto close_serio;\n\t\tpulse8->restoring_config = true;\n\t}\n\n\tschedule_delayed_work(&pulse8->ping_eeprom_work, PING_PERIOD);\n\n\treturn 0;\n\nclose_serio:\n\tpulse8->serio = NULL;\n\tserio_set_drvdata(serio, NULL);\n\tserio_close(serio);\ndelete_adap:\n\tcec_delete_adapter(pulse8->adap);\n\treturn err;\n}\n\nstatic const struct serio_device_id pulse8_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_PULSE8_CEC,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, pulse8_serio_ids);\n\nstatic struct serio_driver pulse8_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"pulse8-cec\",\n\t},\n\t.description\t= \"Pulse Eight HDMI CEC driver\",\n\t.id_table\t= pulse8_serio_ids,\n\t.interrupt\t= pulse8_interrupt,\n\t.connect\t= pulse8_connect,\n\t.disconnect\t= pulse8_disconnect,\n};\n\nmodule_serio_driver(pulse8_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}