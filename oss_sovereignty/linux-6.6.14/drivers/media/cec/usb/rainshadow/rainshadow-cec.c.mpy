{
  "module_name": "rainshadow-cec.c",
  "hash_id": "a3c469baa98c7903cb6c0398a3153ac1be9f026c5f1420b4f23b297a6cbd9fe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/usb/rainshadow/rainshadow-cec.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#include <linux/workqueue.h>\n\n#include <media/cec.h>\n\nMODULE_AUTHOR(\"Hans Verkuil <hverkuil@xs4all.nl>\");\nMODULE_DESCRIPTION(\"RainShadow Tech HDMI CEC driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define DATA_SIZE 256\n\nstruct rain {\n\tstruct device *dev;\n\tstruct serio *serio;\n\tstruct cec_adapter *adap;\n\tstruct completion cmd_done;\n\tstruct work_struct work;\n\n\t \n\tchar buf[DATA_SIZE];\n\tunsigned int buf_rd_idx;\n\tunsigned int buf_wr_idx;\n\tunsigned int buf_len;\n\tspinlock_t buf_lock;\n\n\t \n\tchar cmd[DATA_SIZE];\n\tunsigned int cmd_idx;\n\tbool cmd_started;\n\n\t \n\tchar cmd_reply[DATA_SIZE];\n\n\tstruct mutex write_lock;\n};\n\nstatic void rain_process_msg(struct rain *rain)\n{\n\tstruct cec_msg msg = {};\n\tconst char *cmd = rain->cmd + 3;\n\tint stat = -1;\n\n\tfor (; *cmd; cmd++) {\n\t\tif (!isxdigit(*cmd))\n\t\t\tcontinue;\n\t\tif (isxdigit(cmd[0]) && isxdigit(cmd[1])) {\n\t\t\tif (msg.len == CEC_MAX_MSG_SIZE)\n\t\t\t\tbreak;\n\t\t\tif (hex2bin(msg.msg + msg.len, cmd, 1))\n\t\t\t\tcontinue;\n\t\t\tmsg.len++;\n\t\t\tcmd++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!cmd[1])\n\t\t\tstat = hex_to_bin(cmd[0]);\n\t\tbreak;\n\t}\n\n\tif (rain->cmd[0] == 'R') {\n\t\tif (stat == 1 || stat == 2)\n\t\t\tcec_received_msg(rain->adap, &msg);\n\t\treturn;\n\t}\n\n\tswitch (stat) {\n\tcase 1:\n\t\tcec_transmit_attempt_done(rain->adap, CEC_TX_STATUS_OK);\n\t\tbreak;\n\tcase 2:\n\t\tcec_transmit_attempt_done(rain->adap, CEC_TX_STATUS_NACK);\n\t\tbreak;\n\tdefault:\n\t\tcec_transmit_attempt_done(rain->adap, CEC_TX_STATUS_LOW_DRIVE);\n\t\tbreak;\n\t}\n}\n\nstatic void rain_irq_work_handler(struct work_struct *work)\n{\n\tstruct rain *rain =\n\t\tcontainer_of(work, struct rain, work);\n\n\twhile (true) {\n\t\tunsigned long flags;\n\t\tchar data;\n\n\t\tspin_lock_irqsave(&rain->buf_lock, flags);\n\t\tif (!rain->buf_len) {\n\t\t\tspin_unlock_irqrestore(&rain->buf_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata = rain->buf[rain->buf_rd_idx];\n\t\train->buf_len--;\n\t\train->buf_rd_idx = (rain->buf_rd_idx + 1) & 0xff;\n\n\t\tspin_unlock_irqrestore(&rain->buf_lock, flags);\n\n\t\tif (!rain->cmd_started && data != '?')\n\t\t\tcontinue;\n\n\t\tswitch (data) {\n\t\tcase '\\r':\n\t\t\train->cmd[rain->cmd_idx] = '\\0';\n\t\t\tdev_dbg(rain->dev, \"received: %s\\n\", rain->cmd);\n\t\t\tif (!memcmp(rain->cmd, \"REC\", 3) ||\n\t\t\t    !memcmp(rain->cmd, \"STA\", 3)) {\n\t\t\t\train_process_msg(rain);\n\t\t\t} else {\n\t\t\t\tstrscpy(rain->cmd_reply, rain->cmd,\n\t\t\t\t\tsizeof(rain->cmd_reply));\n\t\t\t\tcomplete(&rain->cmd_done);\n\t\t\t}\n\t\t\train->cmd_idx = 0;\n\t\t\train->cmd_started = false;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\train->cmd_idx = 0;\n\t\t\train->cmd_started = false;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\train->cmd_idx = 0;\n\t\t\train->cmd_started = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (rain->cmd_idx >= DATA_SIZE - 1) {\n\t\t\t\tdev_dbg(rain->dev,\n\t\t\t\t\t\"throwing away %d bytes of garbage\\n\", rain->cmd_idx);\n\t\t\t\train->cmd_idx = 0;\n\t\t\t}\n\t\t\train->cmd[rain->cmd_idx++] = data;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t rain_interrupt(struct serio *serio, unsigned char data,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct rain *rain = serio_get_drvdata(serio);\n\n\tif (rain->buf_len == DATA_SIZE) {\n\t\tdev_warn_once(rain->dev, \"buffer overflow\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\tspin_lock(&rain->buf_lock);\n\train->buf_len++;\n\train->buf[rain->buf_wr_idx] = data;\n\train->buf_wr_idx = (rain->buf_wr_idx + 1) & 0xff;\n\tspin_unlock(&rain->buf_lock);\n\tschedule_work(&rain->work);\n\treturn IRQ_HANDLED;\n}\n\nstatic void rain_disconnect(struct serio *serio)\n{\n\tstruct rain *rain = serio_get_drvdata(serio);\n\n\tcancel_work_sync(&rain->work);\n\tcec_unregister_adapter(rain->adap);\n\tdev_info(&serio->dev, \"disconnected\\n\");\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(rain);\n}\n\nstatic int rain_send(struct rain *rain, const char *command)\n{\n\tint err = serio_write(rain->serio, '!');\n\n\tdev_dbg(rain->dev, \"send: %s\\n\", command);\n\twhile (!err && *command)\n\t\terr = serio_write(rain->serio, *command++);\n\tif (!err)\n\t\terr = serio_write(rain->serio, '~');\n\n\treturn err;\n}\n\nstatic int rain_send_and_wait(struct rain *rain,\n\t\t\t      const char *cmd, const char *reply)\n{\n\tint err;\n\n\tinit_completion(&rain->cmd_done);\n\n\tmutex_lock(&rain->write_lock);\n\terr = rain_send(rain, cmd);\n\tif (err)\n\t\tgoto err;\n\n\tif (!wait_for_completion_timeout(&rain->cmd_done, HZ)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\tif (reply && strncmp(rain->cmd_reply, reply, strlen(reply))) {\n\t\tdev_dbg(rain->dev,\n\t\t\t \"transmit of '%s': received '%s' instead of '%s'\\n\",\n\t\t\t cmd, rain->cmd_reply, reply);\n\t\terr = -EIO;\n\t}\nerr:\n\tmutex_unlock(&rain->write_lock);\n\treturn err;\n}\n\nstatic int rain_setup(struct rain *rain, struct serio *serio,\n\t\t\tstruct cec_log_addrs *log_addrs, u16 *pa)\n{\n\tint err;\n\n\terr = rain_send_and_wait(rain, \"R\", \"REV\");\n\tif (err)\n\t\treturn err;\n\tdev_info(rain->dev, \"Firmware version %s\\n\", rain->cmd_reply + 4);\n\n\terr = rain_send_and_wait(rain, \"Q 1\", \"QTY\");\n\tif (err)\n\t\treturn err;\n\terr = rain_send_and_wait(rain, \"c0000\", \"CFG\");\n\tif (err)\n\t\treturn err;\n\treturn rain_send_and_wait(rain, \"A F 0000\", \"ADR\");\n}\n\nstatic int rain_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\treturn 0;\n}\n\nstatic int rain_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct rain *rain = cec_get_drvdata(adap);\n\tu8 cmd[16];\n\n\tif (log_addr == CEC_LOG_ADDR_INVALID)\n\t\tlog_addr = CEC_LOG_ADDR_UNREGISTERED;\n\tsnprintf(cmd, sizeof(cmd), \"A %x\", log_addr);\n\treturn rain_send_and_wait(rain, cmd, \"ADR\");\n}\n\nstatic int rain_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t    u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct rain *rain = cec_get_drvdata(adap);\n\tchar cmd[2 * CEC_MAX_MSG_SIZE + 16];\n\tunsigned int i;\n\tint err;\n\n\tif (msg->len == 1) {\n\t\tsnprintf(cmd, sizeof(cmd), \"x%x\", cec_msg_destination(msg));\n\t} else {\n\t\tchar hex[3];\n\n\t\tsnprintf(cmd, sizeof(cmd), \"x%x %02x \",\n\t\t\t cec_msg_destination(msg), msg->msg[1]);\n\t\tfor (i = 2; i < msg->len; i++) {\n\t\t\tsnprintf(hex, sizeof(hex), \"%02x\", msg->msg[i]);\n\t\t\tstrlcat(cmd, hex, sizeof(cmd));\n\t\t}\n\t}\n\tmutex_lock(&rain->write_lock);\n\terr = rain_send(rain, cmd);\n\tmutex_unlock(&rain->write_lock);\n\treturn err;\n}\n\nstatic const struct cec_adap_ops rain_cec_adap_ops = {\n\t.adap_enable = rain_cec_adap_enable,\n\t.adap_log_addr = rain_cec_adap_log_addr,\n\t.adap_transmit = rain_cec_adap_transmit,\n};\n\nstatic int rain_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tu32 caps = CEC_CAP_DEFAULTS | CEC_CAP_PHYS_ADDR | CEC_CAP_MONITOR_ALL;\n\tstruct rain *rain;\n\tint err = -ENOMEM;\n\tstruct cec_log_addrs log_addrs = {};\n\tu16 pa = CEC_PHYS_ADDR_INVALID;\n\n\train = kzalloc(sizeof(*rain), GFP_KERNEL);\n\n\tif (!rain)\n\t\treturn -ENOMEM;\n\n\train->serio = serio;\n\train->adap = cec_allocate_adapter(&rain_cec_adap_ops, rain,\n\t\t\t\t\t  dev_name(&serio->dev), caps, 1);\n\terr = PTR_ERR_OR_ZERO(rain->adap);\n\tif (err < 0)\n\t\tgoto free_device;\n\n\train->dev = &serio->dev;\n\tserio_set_drvdata(serio, rain);\n\tINIT_WORK(&rain->work, rain_irq_work_handler);\n\tmutex_init(&rain->write_lock);\n\tspin_lock_init(&rain->buf_lock);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto delete_adap;\n\n\terr = rain_setup(rain, serio, &log_addrs, &pa);\n\tif (err)\n\t\tgoto close_serio;\n\n\terr = cec_register_adapter(rain->adap, &serio->dev);\n\tif (err < 0)\n\t\tgoto close_serio;\n\n\train->dev = &rain->adap->devnode.dev;\n\treturn 0;\n\nclose_serio:\n\tserio_close(serio);\ndelete_adap:\n\tcec_delete_adapter(rain->adap);\n\tserio_set_drvdata(serio, NULL);\nfree_device:\n\tkfree(rain);\n\treturn err;\n}\n\nstatic const struct serio_device_id rain_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_RAINSHADOW_CEC,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, rain_serio_ids);\n\nstatic struct serio_driver rain_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"rainshadow-cec\",\n\t},\n\t.description\t= \"RainShadow Tech HDMI CEC driver\",\n\t.id_table\t= rain_serio_ids,\n\t.interrupt\t= rain_interrupt,\n\t.connect\t= rain_connect,\n\t.disconnect\t= rain_disconnect,\n};\n\nmodule_serio_driver(rain_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}