{
  "module_name": "ch7322.c",
  "hash_id": "bf131902d4d45d51e719ce250ed866de7769791ca76e666892695ba56e32a800",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/i2c/ch7322.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/cec.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/regmap.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n#define CH7322_WRITE\t\t0x00\n#define CH7322_WRITE_MSENT\t\t0x80\n#define CH7322_WRITE_BOK\t\t0x40\n#define CH7322_WRITE_NMASK\t\t0x0f\n\n \n#define CH7322_WRBUF\t\t0x01\n#define CH7322_WRBUF_LEN\t0x10\n\n#define CH7322_READ\t\t0x40\n#define CH7322_READ_NRDT\t\t0x80\n#define CH7322_READ_MSENT\t\t0x20\n#define CH7322_READ_NMASK\t\t0x0f\n\n \n#define CH7322_RDBUF\t\t0x41\n#define CH7322_RDBUF_LEN\t0x10\n\n#define CH7322_MODE\t\t0x11\n#define CH7322_MODE_AUTO\t\t0x78\n#define CH7322_MODE_SW\t\t\t0xb5\n\n#define CH7322_RESET\t\t0x12\n#define CH7322_RESET_RST\t\t0x00\n\n#define CH7322_POWER\t\t0x13\n#define CH7322_POWER_FPD\t\t0x04\n\n#define CH7322_CFG0\t\t0x17\n#define CH7322_CFG0_EOBEN\t\t0x40\n#define CH7322_CFG0_PEOB\t\t0x20\n#define CH7322_CFG0_CLRSPP\t\t0x10\n#define CH7322_CFG0_FLOW\t\t0x08\n\n#define CH7322_CFG1\t\t0x1a\n#define CH7322_CFG1_STDBYO\t\t0x04\n#define CH7322_CFG1_HPBP\t\t0x02\n#define CH7322_CFG1_PIO\t\t\t0x01\n\n#define CH7322_INTCTL\t\t0x1b\n#define CH7322_INTCTL_INTPB\t\t0x80\n#define CH7322_INTCTL_STDBY\t\t0x40\n#define CH7322_INTCTL_HPDFALL\t\t0x20\n#define CH7322_INTCTL_HPDRISE\t\t0x10\n#define CH7322_INTCTL_RXMSG\t\t0x08\n#define CH7322_INTCTL_TXMSG\t\t0x04\n#define CH7322_INTCTL_NEWPHA\t\t0x02\n#define CH7322_INTCTL_ERROR\t\t0x01\n\n#define CH7322_DVCLKFNH\t0x1d\n#define CH7322_DVCLKFNL\t0x1e\n\n#define CH7322_CTL\t\t0x31\n#define CH7322_CTL_FSTDBY\t\t0x80\n#define CH7322_CTL_PLSEN\t\t0x40\n#define CH7322_CTL_PLSPB\t\t0x20\n#define CH7322_CTL_SPADL\t\t0x10\n#define CH7322_CTL_HINIT\t\t0x08\n#define CH7322_CTL_WPHYA\t\t0x04\n#define CH7322_CTL_H1T\t\t\t0x02\n#define CH7322_CTL_S1T\t\t\t0x01\n\n#define CH7322_PAWH\t\t0x32\n#define CH7322_PAWL\t\t0x33\n\n#define CH7322_ADDLW\t\t0x34\n#define CH7322_ADDLW_MASK\t0xf0\n\n#define CH7322_ADDLR\t\t0x3d\n#define CH7322_ADDLR_HPD\t\t0x80\n#define CH7322_ADDLR_MASK\t\t0x0f\n\n#define CH7322_INTDATA\t\t0x3e\n#define CH7322_INTDATA_MODE\t\t0x80\n#define CH7322_INTDATA_STDBY\t\t0x40\n#define CH7322_INTDATA_HPDFALL\t\t0x20\n#define CH7322_INTDATA_HPDRISE\t\t0x10\n#define CH7322_INTDATA_RXMSG\t\t0x08\n#define CH7322_INTDATA_TXMSG\t\t0x04\n#define CH7322_INTDATA_NEWPHA\t\t0x02\n#define CH7322_INTDATA_ERROR\t\t0x01\n\n#define CH7322_EVENT\t\t0x3f\n#define CH7322_EVENT_TXERR\t\t0x80\n#define CH7322_EVENT_HRST\t\t0x40\n#define CH7322_EVENT_HFST\t\t0x20\n#define CH7322_EVENT_PHACHG\t\t0x10\n#define CH7322_EVENT_ACTST\t\t0x08\n#define CH7322_EVENT_PHARDY\t\t0x04\n#define CH7322_EVENT_BSOK\t\t0x02\n#define CH7322_EVENT_ERRADCF\t\t0x01\n\n#define CH7322_DID\t\t0x51\n#define CH7322_DID_CH7322\t\t0x5b\n#define CH7322_DID_CH7323\t\t0x5f\n\n#define CH7322_REVISIONID\t0x52\n\n#define CH7322_PARH\t\t0x53\n#define CH7322_PARL\t\t0x54\n\n#define CH7322_IOCFG2\t\t0x75\n#define CH7322_IOCFG_CIO\t\t0x80\n#define CH7322_IOCFG_IOCFGMASK\t\t0x78\n#define CH7322_IOCFG_AUDIO\t\t0x04\n#define CH7322_IOCFG_SPAMST\t\t0x02\n#define CH7322_IOCFG_SPAMSP\t\t0x01\n\n#define CH7322_CTL3\t\t0x7b\n#define CH7322_CTL3_SWENA\t\t0x80\n#define CH7322_CTL3_FC_INIT\t\t0x40\n#define CH7322_CTL3_SML_FL\t\t0x20\n#define CH7322_CTL3_SM_RDST\t\t0x10\n#define CH7322_CTL3_SPP_CIAH\t\t0x08\n#define CH7322_CTL3_SPP_CIAL\t\t0x04\n#define CH7322_CTL3_SPP_ACTH\t\t0x02\n#define CH7322_CTL3_SPP_ACTL\t\t0x01\n\n \n#define CH7322_TX_FLAG_NACK\tBIT(0)\n \n#define CH7322_TX_FLAG_RETRY\tBIT(1)\n\nstruct ch7322 {\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\tstruct cec_adapter *cec;\n\tstruct mutex mutex;\t \n\tu8 tx_flags;\n};\n\nstatic const struct regmap_config ch7322_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x7f,\n\t.disable_locking = true,\n};\n\nstatic int ch7322_send_message(struct ch7322 *ch7322, const struct cec_msg *msg)\n{\n\tunsigned int val;\n\tunsigned int len = msg->len;\n\tint ret;\n\tint i;\n\n\tWARN_ON(!mutex_is_locked(&ch7322->mutex));\n\n\tif (len > CH7322_WRBUF_LEN || len < 1)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(ch7322->regmap, CH7322_WRITE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(val & CH7322_WRITE_MSENT))\n\t\treturn -EBUSY;\n\n\tif (cec_msg_opcode(msg) == -1 &&\n\t    cec_msg_initiator(msg) == cec_msg_destination(msg)) {\n\t\tch7322->tx_flags = CH7322_TX_FLAG_NACK | CH7322_TX_FLAG_RETRY;\n\t} else if (cec_msg_is_broadcast(msg)) {\n\t\tch7322->tx_flags = CH7322_TX_FLAG_NACK;\n\t} else {\n\t\tch7322->tx_flags = CH7322_TX_FLAG_RETRY;\n\t}\n\n\tret = regmap_write(ch7322->regmap, CH7322_WRITE, len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = regmap_write(ch7322->regmap,\n\t\t\t\t   CH7322_WRBUF + i, msg->msg[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ch7322_receive_message(struct ch7322 *ch7322, struct cec_msg *msg)\n{\n\tunsigned int val;\n\tint ret = 0;\n\tint i;\n\n\tWARN_ON(!mutex_is_locked(&ch7322->mutex));\n\n\tret = regmap_read(ch7322->regmap, CH7322_READ, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(val & CH7322_READ_NRDT))\n\t\treturn -EIO;\n\n\tmsg->len = (val & CH7322_READ_NMASK) + 1;\n\n\t \n\tfor (i = 0; i < CH7322_RDBUF_LEN; i++) {\n\t\tret = regmap_read(ch7322->regmap, CH7322_RDBUF + i, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmsg->msg[i] = (u8)val;\n\t}\n\n\treturn 0;\n}\n\nstatic void ch7322_tx_done(struct ch7322 *ch7322)\n{\n\tint ret;\n\tunsigned int val;\n\tu8 status, flags;\n\n\tmutex_lock(&ch7322->mutex);\n\tret = regmap_read(ch7322->regmap, CH7322_WRITE, &val);\n\tflags = ch7322->tx_flags;\n\tmutex_unlock(&ch7322->mutex);\n\n\t \n\tif (ret)\n\t\tstatus = CEC_TX_STATUS_ERROR;\n\telse if ((val & CH7322_WRITE_BOK) && (flags & CH7322_TX_FLAG_NACK))\n\t\tstatus = CEC_TX_STATUS_NACK;\n\telse if (val & CH7322_WRITE_BOK)\n\t\tstatus = CEC_TX_STATUS_OK;\n\telse if (flags & CH7322_TX_FLAG_NACK)\n\t\tstatus = CEC_TX_STATUS_OK;\n\telse\n\t\tstatus = CEC_TX_STATUS_NACK;\n\n\tif (status == CEC_TX_STATUS_NACK && (flags & CH7322_TX_FLAG_RETRY))\n\t\tstatus |= CEC_TX_STATUS_MAX_RETRIES;\n\n\tcec_transmit_attempt_done(ch7322->cec, status);\n}\n\nstatic void ch7322_rx_done(struct ch7322 *ch7322)\n{\n\tstruct cec_msg msg;\n\tint ret;\n\n\tmutex_lock(&ch7322->mutex);\n\tret = ch7322_receive_message(ch7322, &msg);\n\tmutex_unlock(&ch7322->mutex);\n\n\tif (ret)\n\t\tdev_err(&ch7322->i2c->dev, \"cec receive error: %d\\n\", ret);\n\telse\n\t\tcec_received_msg(ch7322->cec, &msg);\n}\n\n \nstatic void ch7322_phys_addr(struct ch7322 *ch7322)\n{\n\tunsigned int pah, pal;\n\tint ret = 0;\n\n\tmutex_lock(&ch7322->mutex);\n\tret |= regmap_read(ch7322->regmap, CH7322_PARH, &pah);\n\tret |= regmap_read(ch7322->regmap, CH7322_PARL, &pal);\n\tmutex_unlock(&ch7322->mutex);\n\n\tif (ret)\n\t\tdev_err(&ch7322->i2c->dev, \"phys addr error\\n\");\n\telse\n\t\tcec_s_phys_addr(ch7322->cec, pal | (pah << 8), false);\n}\n\nstatic irqreturn_t ch7322_irq(int irq, void *dev)\n{\n\tstruct ch7322 *ch7322 = dev;\n\tunsigned int data = 0;\n\n\tmutex_lock(&ch7322->mutex);\n\tregmap_read(ch7322->regmap, CH7322_INTDATA, &data);\n\tregmap_write(ch7322->regmap, CH7322_INTDATA, data);\n\tmutex_unlock(&ch7322->mutex);\n\n\tif (data & CH7322_INTDATA_HPDFALL)\n\t\tcec_phys_addr_invalidate(ch7322->cec);\n\n\tif (data & CH7322_INTDATA_TXMSG)\n\t\tch7322_tx_done(ch7322);\n\n\tif (data & CH7322_INTDATA_RXMSG)\n\t\tch7322_rx_done(ch7322);\n\n\tif (data & CH7322_INTDATA_NEWPHA)\n\t\tch7322_phys_addr(ch7322);\n\n\tif (data & CH7322_INTDATA_ERROR)\n\t\tdev_dbg(&ch7322->i2c->dev, \"unknown error\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ch7322_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\treturn 0;\n}\n\nstatic int ch7322_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct ch7322 *ch7322 = cec_get_drvdata(adap);\n\tint ret;\n\n\tmutex_lock(&ch7322->mutex);\n\tret = regmap_update_bits(ch7322->regmap, CH7322_ADDLW,\n\t\t\t\t CH7322_ADDLW_MASK, log_addr << 4);\n\tmutex_unlock(&ch7322->mutex);\n\n\treturn ret;\n}\n\nstatic int ch7322_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t    u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct ch7322 *ch7322 = cec_get_drvdata(adap);\n\tint ret;\n\n\tmutex_lock(&ch7322->mutex);\n\tret = ch7322_send_message(ch7322, msg);\n\tmutex_unlock(&ch7322->mutex);\n\n\treturn ret;\n}\n\nstatic const struct cec_adap_ops ch7322_cec_adap_ops = {\n\t.adap_enable = ch7322_cec_adap_enable,\n\t.adap_log_addr = ch7322_cec_adap_log_addr,\n\t.adap_transmit = ch7322_cec_adap_transmit,\n};\n\n#if IS_ENABLED(CONFIG_PCI) && IS_ENABLED(CONFIG_DMI)\n\nstruct ch7322_conn_match {\n\tconst char *dev_name;\n\tconst char *pci_name;\n\tconst char *port_name;\n};\n\nstatic struct ch7322_conn_match google_endeavour[] = {\n\t{ \"i2c-PRP0001:00\", \"0000:00:02.0\", \"Port B\" },\n\t{ \"i2c-PRP0001:01\", \"0000:00:02.0\", \"Port C\" },\n\t{ },\n};\n\nstatic const struct dmi_system_id ch7322_dmi_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Endeavour\"),\n\t\t},\n\t\t.driver_data = google_endeavour,\n\t},\n\t{ },\n};\n\n \nstatic int ch7322_get_port(struct i2c_client *client,\n\t\t\t   struct device **dev,\n\t\t\t   const char **port)\n{\n\tconst struct dmi_system_id *system;\n\tconst struct ch7322_conn_match *conn;\n\n\t*dev = NULL;\n\t*port = NULL;\n\n\tsystem = dmi_first_match(ch7322_dmi_table);\n\tif (!system)\n\t\treturn 0;\n\n\tfor (conn = system->driver_data; conn->dev_name; conn++) {\n\t\tif (!strcmp(dev_name(&client->dev), conn->dev_name)) {\n\t\t\tstruct device *d;\n\n\t\t\td = bus_find_device_by_name(&pci_bus_type, NULL,\n\t\t\t\t\t\t    conn->pci_name);\n\t\t\tif (!d)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\tput_device(d);\n\n\t\t\t*dev = d;\n\t\t\t*port = conn->port_name;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#else\n\nstatic int ch7322_get_port(struct i2c_client *client,\n\t\t\t   struct device **dev,\n\t\t\t   const char **port)\n{\n\t*dev = NULL;\n\t*port = NULL;\n\n\treturn 0;\n}\n\n#endif\n\nstatic int ch7322_probe(struct i2c_client *client)\n{\n\tstruct device *hdmi_dev;\n\tconst char *port_name;\n\tstruct ch7322 *ch7322;\n\tstruct cec_notifier *notifier = NULL;\n\tu32 caps = CEC_CAP_DEFAULTS;\n\tint ret;\n\tunsigned int val;\n\n\tret = ch7322_get_port(client, &hdmi_dev, &port_name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hdmi_dev)\n\t\tcaps |= CEC_CAP_CONNECTOR_INFO;\n\n\tch7322 = devm_kzalloc(&client->dev, sizeof(*ch7322), GFP_KERNEL);\n\tif (!ch7322)\n\t\treturn -ENOMEM;\n\n\tch7322->regmap = devm_regmap_init_i2c(client, &ch7322_regmap);\n\tif (IS_ERR(ch7322->regmap))\n\t\treturn PTR_ERR(ch7322->regmap);\n\n\tret = regmap_read(ch7322->regmap, CH7322_DID, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != CH7322_DID_CH7322)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_init(&ch7322->mutex);\n\tch7322->i2c = client;\n\tch7322->tx_flags = 0;\n\n\ti2c_set_clientdata(client, ch7322);\n\n\t \n\tret = regmap_write(ch7322->regmap, CH7322_MODE, CH7322_MODE_SW);\n\tif (ret)\n\t\tgoto err_mutex;\n\n\t \n\tret = regmap_update_bits(ch7322->regmap, CH7322_CTL,\n\t\t\t\t CH7322_CTL_SPADL, CH7322_CTL_SPADL);\n\tif (ret)\n\t\tgoto err_mutex;\n\n\tch7322->cec = cec_allocate_adapter(&ch7322_cec_adap_ops, ch7322,\n\t\t\t\t\t   dev_name(&client->dev),\n\t\t\t\t\t   caps, 1);\n\n\tif (IS_ERR(ch7322->cec)) {\n\t\tret = PTR_ERR(ch7322->cec);\n\t\tgoto err_mutex;\n\t}\n\n\tch7322->cec->adap_controls_phys_addr = true;\n\n\tif (hdmi_dev) {\n\t\tnotifier = cec_notifier_cec_adap_register(hdmi_dev,\n\t\t\t\t\t\t\t  port_name,\n\t\t\t\t\t\t\t  ch7322->cec);\n\t\tif (!notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_cec;\n\t\t}\n\t}\n\n\t \n\tret = regmap_write(ch7322->regmap, CH7322_CFG1, 0);\n\tif (ret)\n\t\tgoto err_notifier;\n\tret = regmap_write(ch7322->regmap, CH7322_INTCTL, CH7322_INTCTL_INTPB);\n\tif (ret)\n\t\tgoto err_notifier;\n\tret = regmap_write(ch7322->regmap, CH7322_INTDATA, 0xff);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\t \n\tret = regmap_read(ch7322->regmap, CH7322_ADDLR, &val);\n\tif (ret)\n\t\tgoto err_notifier;\n\tif (val & CH7322_ADDLR_HPD)\n\t\tch7322_phys_addr(ch7322);\n\n\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\tch7322_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\tclient->name, ch7322);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\t \n\tmutex_lock(&ch7322->mutex);\n\tret = regmap_write(ch7322->regmap, CH7322_INTCTL, 0xff);\n\tmutex_unlock(&ch7322->mutex);\n\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tret = cec_register_adapter(ch7322->cec, &client->dev);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tdev_info(&client->dev, \"device registered\\n\");\n\n\treturn 0;\n\nerr_notifier:\n\tif (notifier)\n\t\tcec_notifier_cec_adap_unregister(notifier, ch7322->cec);\nerr_cec:\n\tcec_delete_adapter(ch7322->cec);\nerr_mutex:\n\tmutex_destroy(&ch7322->mutex);\n\treturn ret;\n}\n\nstatic void ch7322_remove(struct i2c_client *client)\n{\n\tstruct ch7322 *ch7322 = i2c_get_clientdata(client);\n\n\t \n\tmutex_lock(&ch7322->mutex);\n\tregmap_write(ch7322->regmap, CH7322_INTCTL, CH7322_INTCTL_INTPB);\n\tmutex_unlock(&ch7322->mutex);\n\n\tcec_unregister_adapter(ch7322->cec);\n\tmutex_destroy(&ch7322->mutex);\n\n\tdev_info(&client->dev, \"device unregistered\\n\");\n}\n\nstatic const struct of_device_id ch7322_of_match[] = {\n\t{ .compatible = \"chrontel,ch7322\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ch7322_of_match);\n\nstatic struct i2c_driver ch7322_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ch7322\",\n\t\t.of_match_table = ch7322_of_match,\n\t},\n\t.probe\t\t= ch7322_probe,\n\t.remove\t\t= ch7322_remove,\n};\n\nmodule_i2c_driver(ch7322_i2c_driver);\n\nMODULE_DESCRIPTION(\"Chrontel CH7322 CEC Controller Driver\");\nMODULE_AUTHOR(\"Jeff Chase <jnchase@google.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}