{
  "module_name": "cec-gpio.c",
  "hash_id": "c1e41840b50179d739e4e2a3c4bfca6bb7c2372a713d71af6d9ca68f4542e50a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/cec-gpio/cec-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <media/cec-notifier.h>\n#include <media/cec-pin.h>\n\nstruct cec_gpio {\n\tstruct cec_adapter\t*adap;\n\tstruct cec_notifier\t*notifier;\n\tstruct device\t\t*dev;\n\n\tstruct gpio_desc\t*cec_gpio;\n\tint\t\t\tcec_irq;\n\tbool\t\t\tcec_is_low;\n\n\tstruct gpio_desc\t*hpd_gpio;\n\tint\t\t\thpd_irq;\n\tbool\t\t\thpd_is_high;\n\tktime_t\t\t\thpd_ts;\n\n\tstruct gpio_desc\t*v5_gpio;\n\tint\t\t\tv5_irq;\n\tbool\t\t\tv5_is_high;\n\tktime_t\t\t\tv5_ts;\n};\n\nstatic int cec_gpio_read(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tif (cec->cec_is_low)\n\t\treturn 0;\n\treturn gpiod_get_value(cec->cec_gpio);\n}\n\nstatic void cec_gpio_high(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tif (!cec->cec_is_low)\n\t\treturn;\n\tcec->cec_is_low = false;\n\tgpiod_set_value(cec->cec_gpio, 1);\n}\n\nstatic void cec_gpio_low(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tif (cec->cec_is_low)\n\t\treturn;\n\tcec->cec_is_low = true;\n\tgpiod_set_value(cec->cec_gpio, 0);\n}\n\nstatic irqreturn_t cec_hpd_gpio_irq_handler_thread(int irq, void *priv)\n{\n\tstruct cec_gpio *cec = priv;\n\n\tcec_queue_pin_hpd_event(cec->adap, cec->hpd_is_high, cec->hpd_ts);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cec_5v_gpio_irq_handler(int irq, void *priv)\n{\n\tstruct cec_gpio *cec = priv;\n\tint val = gpiod_get_value(cec->v5_gpio);\n\tbool is_high = val > 0;\n\n\tif (val < 0 || is_high == cec->v5_is_high)\n\t\treturn IRQ_HANDLED;\n\tcec->v5_ts = ktime_get();\n\tcec->v5_is_high = is_high;\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t cec_5v_gpio_irq_handler_thread(int irq, void *priv)\n{\n\tstruct cec_gpio *cec = priv;\n\n\tcec_queue_pin_5v_event(cec->adap, cec->v5_is_high, cec->v5_ts);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cec_hpd_gpio_irq_handler(int irq, void *priv)\n{\n\tstruct cec_gpio *cec = priv;\n\tint val = gpiod_get_value(cec->hpd_gpio);\n\tbool is_high = val > 0;\n\n\tif (val < 0 || is_high == cec->hpd_is_high)\n\t\treturn IRQ_HANDLED;\n\tcec->hpd_ts = ktime_get();\n\tcec->hpd_is_high = is_high;\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t cec_gpio_irq_handler(int irq, void *priv)\n{\n\tstruct cec_gpio *cec = priv;\n\tint val = gpiod_get_value(cec->cec_gpio);\n\n\tif (val >= 0)\n\t\tcec_pin_changed(cec->adap, val > 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic bool cec_gpio_enable_irq(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tenable_irq(cec->cec_irq);\n\treturn true;\n}\n\nstatic void cec_gpio_disable_irq(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tdisable_irq(cec->cec_irq);\n}\n\nstatic void cec_gpio_status(struct cec_adapter *adap, struct seq_file *file)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tseq_printf(file, \"mode: %s\\n\", cec->cec_is_low ? \"low-drive\" : \"read\");\n\tseq_printf(file, \"using irq: %d\\n\", cec->cec_irq);\n\tif (cec->hpd_gpio)\n\t\tseq_printf(file, \"hpd: %s\\n\",\n\t\t\t   cec->hpd_is_high ? \"high\" : \"low\");\n\tif (cec->v5_gpio)\n\t\tseq_printf(file, \"5V: %s\\n\",\n\t\t\t   cec->v5_is_high ? \"high\" : \"low\");\n}\n\nstatic int cec_gpio_read_hpd(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tif (!cec->hpd_gpio)\n\t\treturn -ENOTTY;\n\treturn gpiod_get_value(cec->hpd_gpio);\n}\n\nstatic int cec_gpio_read_5v(struct cec_adapter *adap)\n{\n\tstruct cec_gpio *cec = cec_get_drvdata(adap);\n\n\tif (!cec->v5_gpio)\n\t\treturn -ENOTTY;\n\treturn gpiod_get_value(cec->v5_gpio);\n}\n\nstatic const struct cec_pin_ops cec_gpio_pin_ops = {\n\t.read = cec_gpio_read,\n\t.low = cec_gpio_low,\n\t.high = cec_gpio_high,\n\t.enable_irq = cec_gpio_enable_irq,\n\t.disable_irq = cec_gpio_disable_irq,\n\t.status = cec_gpio_status,\n\t.read_hpd = cec_gpio_read_hpd,\n\t.read_5v = cec_gpio_read_5v,\n};\n\nstatic int cec_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hdmi_dev;\n\tstruct cec_gpio *cec;\n\tu32 caps = CEC_CAP_DEFAULTS | CEC_CAP_MONITOR_ALL | CEC_CAP_MONITOR_PIN;\n\tint ret;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(dev);\n\tif (PTR_ERR(hdmi_dev) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(hdmi_dev);\n\tif (IS_ERR(hdmi_dev))\n\t\tcaps |= CEC_CAP_PHYS_ADDR;\n\n\tcec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tcec->dev = dev;\n\n\tcec->cec_gpio = devm_gpiod_get(dev, \"cec\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\tif (IS_ERR(cec->cec_gpio))\n\t\treturn PTR_ERR(cec->cec_gpio);\n\tcec->cec_irq = gpiod_to_irq(cec->cec_gpio);\n\n\tcec->hpd_gpio = devm_gpiod_get_optional(dev, \"hpd\", GPIOD_IN);\n\tif (IS_ERR(cec->hpd_gpio))\n\t\treturn PTR_ERR(cec->hpd_gpio);\n\n\tcec->v5_gpio = devm_gpiod_get_optional(dev, \"v5\", GPIOD_IN);\n\tif (IS_ERR(cec->v5_gpio))\n\t\treturn PTR_ERR(cec->v5_gpio);\n\n\tcec->adap = cec_pin_allocate_adapter(&cec_gpio_pin_ops,\n\t\t\t\t\t     cec, pdev->name, caps);\n\tif (IS_ERR(cec->adap))\n\t\treturn PTR_ERR(cec->adap);\n\n\tret = devm_request_irq(dev, cec->cec_irq, cec_gpio_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_NO_AUTOEN,\n\t\t\t       cec->adap->name, cec);\n\tif (ret)\n\t\tgoto del_adap;\n\n\tif (cec->hpd_gpio) {\n\t\tcec->hpd_irq = gpiod_to_irq(cec->hpd_gpio);\n\t\tret = devm_request_threaded_irq(dev, cec->hpd_irq,\n\t\t\tcec_hpd_gpio_irq_handler,\n\t\t\tcec_hpd_gpio_irq_handler_thread,\n\t\t\tIRQF_ONESHOT |\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\n\t\t\t\"hpd-gpio\", cec);\n\t\tif (ret)\n\t\t\tgoto del_adap;\n\t}\n\n\tif (cec->v5_gpio) {\n\t\tcec->v5_irq = gpiod_to_irq(cec->v5_gpio);\n\t\tret = devm_request_threaded_irq(dev, cec->v5_irq,\n\t\t\tcec_5v_gpio_irq_handler,\n\t\t\tcec_5v_gpio_irq_handler_thread,\n\t\t\tIRQF_ONESHOT |\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\n\t\t\t\"v5-gpio\", cec);\n\t\tif (ret)\n\t\t\tgoto del_adap;\n\t}\n\n\tif (!IS_ERR(hdmi_dev)) {\n\t\tcec->notifier = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t\t       cec->adap);\n\t\tif (!cec->notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto del_adap;\n\t\t}\n\t}\n\n\tret = cec_register_adapter(cec->adap, &pdev->dev);\n\tif (ret)\n\t\tgoto unreg_notifier;\n\n\tplatform_set_drvdata(pdev, cec);\n\treturn 0;\n\nunreg_notifier:\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\ndel_adap:\n\tcec_delete_adapter(cec->adap);\n\treturn ret;\n}\n\nstatic void cec_gpio_remove(struct platform_device *pdev)\n{\n\tstruct cec_gpio *cec = platform_get_drvdata(pdev);\n\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\tcec_unregister_adapter(cec->adap);\n}\n\nstatic const struct of_device_id cec_gpio_match[] = {\n\t{\n\t\t.compatible\t= \"cec-gpio\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cec_gpio_match);\n\nstatic struct platform_driver cec_gpio_pdrv = {\n\t.probe\t= cec_gpio_probe,\n\t.remove_new = cec_gpio_remove,\n\t.driver = {\n\t\t.name\t\t= \"cec-gpio\",\n\t\t.of_match_table\t= cec_gpio_match,\n\t},\n};\n\nmodule_platform_driver(cec_gpio_pdrv);\n\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CEC GPIO driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}