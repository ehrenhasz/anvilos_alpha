{
  "module_name": "stm32-cec.c",
  "hash_id": "faef3e651be4e8d22fa2e9b44bfd448766d5555fd6bd4f00b01cd10062b9e5ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/stm32/stm32-cec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <media/cec.h>\n\n#define CEC_NAME\t\"stm32-cec\"\n\n \n#define CEC_CR\t\t0x0000  \n#define CEC_CFGR\t0x0004  \n#define CEC_TXDR\t0x0008  \n#define CEC_RXDR\t0x000C  \n#define CEC_ISR\t\t0x0010  \n#define CEC_IER\t\t0x0014  \n\n#define TXEOM\t\tBIT(2)\n#define TXSOM\t\tBIT(1)\n#define CECEN\t\tBIT(0)\n\n#define LSTN\t\tBIT(31)\n#define OAR\t\tGENMASK(30, 16)\n#define SFTOP\t\tBIT(8)\n#define BRDNOGEN\tBIT(7)\n#define LBPEGEN\t\tBIT(6)\n#define BREGEN\t\tBIT(5)\n#define BRESTP\t\tBIT(4)\n#define RXTOL\t\tBIT(3)\n#define SFT\t\tGENMASK(2, 0)\n#define FULL_CFG\t(LSTN | SFTOP | BRDNOGEN | LBPEGEN | BREGEN | BRESTP \\\n\t\t\t | RXTOL)\n\n#define TXACKE\t\tBIT(12)\n#define TXERR\t\tBIT(11)\n#define TXUDR\t\tBIT(10)\n#define TXEND\t\tBIT(9)\n#define TXBR\t\tBIT(8)\n#define ARBLST\t\tBIT(7)\n#define RXACKE\t\tBIT(6)\n#define RXOVR\t\tBIT(2)\n#define RXEND\t\tBIT(1)\n#define RXBR\t\tBIT(0)\n\n#define ALL_TX_IT\t(TXEND | TXBR | TXACKE | TXERR | TXUDR | ARBLST)\n#define ALL_RX_IT\t(RXEND | RXBR | RXACKE | RXOVR)\n\n \n#define CEC_XFER_TIMEOUT_MS (5 * 400 + 100)\n\nstruct stm32_cec {\n\tstruct cec_adapter\t*adap;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk_cec;\n\tstruct clk\t\t*clk_hdmi_cec;\n\tstruct reset_control\t*rstc;\n\tstruct regmap\t\t*regmap;\n\tint\t\t\tirq;\n\tu32\t\t\tirq_status;\n\tstruct cec_msg\t\trx_msg;\n\tstruct cec_msg\t\ttx_msg;\n\tint\t\t\ttx_cnt;\n};\n\nstatic void cec_hw_init(struct stm32_cec *cec)\n{\n\tregmap_update_bits(cec->regmap, CEC_CR, TXEOM | TXSOM | CECEN, 0);\n\n\tregmap_update_bits(cec->regmap, CEC_IER, ALL_TX_IT | ALL_RX_IT,\n\t\t\t   ALL_TX_IT | ALL_RX_IT);\n\n\tregmap_update_bits(cec->regmap, CEC_CFGR, FULL_CFG, FULL_CFG);\n}\n\nstatic void stm32_tx_done(struct stm32_cec *cec, u32 status)\n{\n\tif (status & (TXERR | TXUDR)) {\n\t\tcec_transmit_done(cec->adap, CEC_TX_STATUS_ERROR,\n\t\t\t\t  0, 0, 0, 1);\n\t\treturn;\n\t}\n\n\tif (status & ARBLST) {\n\t\tcec_transmit_done(cec->adap, CEC_TX_STATUS_ARB_LOST,\n\t\t\t\t  1, 0, 0, 0);\n\t\treturn;\n\t}\n\n\tif (status & TXACKE) {\n\t\tcec_transmit_done(cec->adap, CEC_TX_STATUS_NACK,\n\t\t\t\t  0, 1, 0, 0);\n\t\treturn;\n\t}\n\n\tif (cec->irq_status & TXBR) {\n\t\t \n\t\tif (cec->tx_cnt < cec->tx_msg.len)\n\t\t\tregmap_write(cec->regmap, CEC_TXDR,\n\t\t\t\t     cec->tx_msg.msg[cec->tx_cnt++]);\n\n\t\t \n\t\tif (cec->tx_cnt == cec->tx_msg.len)\n\t\t\tregmap_update_bits(cec->regmap, CEC_CR, TXEOM, TXEOM);\n\t}\n\n\tif (cec->irq_status & TXEND)\n\t\tcec_transmit_done(cec->adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\n}\n\nstatic void stm32_rx_done(struct stm32_cec *cec, u32 status)\n{\n\tif (cec->irq_status & (RXACKE | RXOVR)) {\n\t\tcec->rx_msg.len = 0;\n\t\treturn;\n\t}\n\n\tif (cec->irq_status & RXBR) {\n\t\tu32 val;\n\n\t\tregmap_read(cec->regmap, CEC_RXDR, &val);\n\t\tcec->rx_msg.msg[cec->rx_msg.len++] = val & 0xFF;\n\t}\n\n\tif (cec->irq_status & RXEND) {\n\t\tcec_received_msg(cec->adap, &cec->rx_msg);\n\t\tcec->rx_msg.len = 0;\n\t}\n}\n\nstatic irqreturn_t stm32_cec_irq_thread(int irq, void *arg)\n{\n\tstruct stm32_cec *cec = arg;\n\n\tif (cec->irq_status & ALL_TX_IT)\n\t\tstm32_tx_done(cec, cec->irq_status);\n\n\tif (cec->irq_status & ALL_RX_IT)\n\t\tstm32_rx_done(cec, cec->irq_status);\n\n\tcec->irq_status = 0;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stm32_cec_irq_handler(int irq, void *arg)\n{\n\tstruct stm32_cec *cec = arg;\n\n\tregmap_read(cec->regmap, CEC_ISR, &cec->irq_status);\n\n\tregmap_update_bits(cec->regmap, CEC_ISR,\n\t\t\t   ALL_TX_IT | ALL_RX_IT,\n\t\t\t   ALL_TX_IT | ALL_RX_IT);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int stm32_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct stm32_cec *cec = adap->priv;\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = clk_enable(cec->clk_cec);\n\t\tif (ret)\n\t\t\tdev_err(cec->dev, \"fail to enable cec clock\\n\");\n\n\t\tclk_enable(cec->clk_hdmi_cec);\n\t\tregmap_update_bits(cec->regmap, CEC_CR, CECEN, CECEN);\n\t} else {\n\t\tclk_disable(cec->clk_cec);\n\t\tclk_disable(cec->clk_hdmi_cec);\n\t\tregmap_update_bits(cec->regmap, CEC_CR, CECEN, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_cec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct stm32_cec *cec = adap->priv;\n\tu32 oar = (1 << logical_addr) << 16;\n\tu32 val;\n\n\t \n\tregmap_read_poll_timeout(cec->regmap, CEC_CR, val, !(val & TXSOM),\n\t\t\t\t 100, CEC_XFER_TIMEOUT_MS * 1000);\n\tregmap_update_bits(cec->regmap, CEC_CR, CECEN, 0);\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID)\n\t\tregmap_update_bits(cec->regmap, CEC_CFGR, OAR, 0);\n\telse\n\t\tregmap_update_bits(cec->regmap, CEC_CFGR, oar, oar);\n\n\tregmap_update_bits(cec->regmap, CEC_CR, CECEN, CECEN);\n\n\treturn 0;\n}\n\nstatic int stm32_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t   u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct stm32_cec *cec = adap->priv;\n\n\t \n\tcec->tx_msg = *msg;\n\tcec->tx_cnt = 0;\n\n\t \n\tif (cec->tx_msg.len == 1)\n\t\tregmap_update_bits(cec->regmap, CEC_CR, TXEOM, TXEOM);\n\n\t \n\tregmap_update_bits(cec->regmap, CEC_CR, TXSOM, TXSOM);\n\n\t \n\tregmap_write(cec->regmap, CEC_TXDR, cec->tx_msg.msg[0]);\n\tcec->tx_cnt++;\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops stm32_cec_adap_ops = {\n\t.adap_enable = stm32_cec_adap_enable,\n\t.adap_log_addr = stm32_cec_adap_log_addr,\n\t.adap_transmit = stm32_cec_adap_transmit,\n};\n\nstatic const struct regmap_config stm32_cec_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = 0x14,\n\t.fast_io = true,\n};\n\nstatic int stm32_cec_probe(struct platform_device *pdev)\n{\n\tu32 caps = CEC_CAP_DEFAULTS | CEC_CAP_PHYS_ADDR | CEC_MODE_MONITOR_ALL;\n\tstruct stm32_cec *cec;\n\tvoid __iomem *mmio;\n\tint ret;\n\n\tcec = devm_kzalloc(&pdev->dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tcec->dev = &pdev->dev;\n\n\tmmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio))\n\t\treturn PTR_ERR(mmio);\n\n\tcec->regmap = devm_regmap_init_mmio_clk(&pdev->dev, \"cec\", mmio,\n\t\t\t\t\t\t&stm32_cec_regmap_cfg);\n\n\tif (IS_ERR(cec->regmap))\n\t\treturn PTR_ERR(cec->regmap);\n\n\tcec->irq = platform_get_irq(pdev, 0);\n\tif (cec->irq < 0)\n\t\treturn cec->irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, cec->irq,\n\t\t\t\t\tstm32_cec_irq_handler,\n\t\t\t\t\tstm32_cec_irq_thread,\n\t\t\t\t\t0,\n\t\t\t\t\tpdev->name, cec);\n\tif (ret)\n\t\treturn ret;\n\n\tcec->clk_cec = devm_clk_get(&pdev->dev, \"cec\");\n\tif (IS_ERR(cec->clk_cec))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cec->clk_cec),\n\t\t\t\t     \"Cannot get cec clock\\n\");\n\n\tret = clk_prepare(cec->clk_cec);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to prepare cec clock\\n\");\n\t\treturn ret;\n\t}\n\n\tcec->clk_hdmi_cec = devm_clk_get(&pdev->dev, \"hdmi-cec\");\n\tif (IS_ERR(cec->clk_hdmi_cec) &&\n\t    PTR_ERR(cec->clk_hdmi_cec) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_unprepare_cec_clk;\n\t}\n\n\tif (!IS_ERR(cec->clk_hdmi_cec)) {\n\t\tret = clk_prepare(cec->clk_hdmi_cec);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't prepare hdmi-cec clock\\n\");\n\t\t\tgoto err_unprepare_cec_clk;\n\t\t}\n\t}\n\n\t \n\tcec->adap = cec_allocate_adapter(&stm32_cec_adap_ops, cec,\n\t\t\tCEC_NAME, caps,\tCEC_MAX_LOG_ADDRS);\n\tret = PTR_ERR_OR_ZERO(cec->adap);\n\tif (ret)\n\t\tgoto err_unprepare_hdmi_cec_clk;\n\n\tret = cec_register_adapter(cec->adap, &pdev->dev);\n\tif (ret)\n\t\tgoto err_delete_adapter;\n\n\tcec_hw_init(cec);\n\n\tplatform_set_drvdata(pdev, cec);\n\n\treturn 0;\n\nerr_delete_adapter:\n\tcec_delete_adapter(cec->adap);\n\nerr_unprepare_hdmi_cec_clk:\n\tclk_unprepare(cec->clk_hdmi_cec);\n\nerr_unprepare_cec_clk:\n\tclk_unprepare(cec->clk_cec);\n\treturn ret;\n}\n\nstatic void stm32_cec_remove(struct platform_device *pdev)\n{\n\tstruct stm32_cec *cec = platform_get_drvdata(pdev);\n\n\tclk_unprepare(cec->clk_cec);\n\tclk_unprepare(cec->clk_hdmi_cec);\n\n\tcec_unregister_adapter(cec->adap);\n}\n\nstatic const struct of_device_id stm32_cec_of_match[] = {\n\t{ .compatible = \"st,stm32-cec\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, stm32_cec_of_match);\n\nstatic struct platform_driver stm32_cec_driver = {\n\t.probe  = stm32_cec_probe,\n\t.remove_new = stm32_cec_remove,\n\t.driver = {\n\t\t.name\t\t= CEC_NAME,\n\t\t.of_match_table = stm32_cec_of_match,\n\t},\n};\n\nmodule_platform_driver(stm32_cec_driver);\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Consumer Electronics Control\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}