{
  "module_name": "tegra_cec.c",
  "hash_id": "4377c3ec27834cb4bb0225632f6a8f08e28a8acdb4b12446427514f4ca32f60d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/tegra/tegra_cec.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/clk/tegra.h>\n\n#include <media/cec-notifier.h>\n\n#include \"tegra_cec.h\"\n\n#define TEGRA_CEC_NAME \"tegra-cec\"\n\nstruct tegra_cec {\n\tstruct cec_adapter\t*adap;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*cec_base;\n\tstruct cec_notifier\t*notifier;\n\tint\t\t\ttegra_cec_irq;\n\tbool\t\t\trx_done;\n\tbool\t\t\ttx_done;\n\tint\t\t\ttx_status;\n\tu8\t\t\trx_buf[CEC_MAX_MSG_SIZE];\n\tu8\t\t\trx_buf_cnt;\n\tu32\t\t\ttx_buf[CEC_MAX_MSG_SIZE];\n\tu8\t\t\ttx_buf_cur;\n\tu8\t\t\ttx_buf_cnt;\n};\n\nstatic inline u32 cec_read(struct tegra_cec *cec, u32 reg)\n{\n\treturn readl(cec->cec_base + reg);\n}\n\nstatic inline void cec_write(struct tegra_cec *cec, u32 reg, u32 val)\n{\n\twritel(val, cec->cec_base + reg);\n}\n\nstatic void tegra_cec_error_recovery(struct tegra_cec *cec)\n{\n\tu32 hw_ctrl;\n\n\thw_ctrl = cec_read(cec, TEGRA_CEC_HW_CONTROL);\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, 0);\n\tcec_write(cec, TEGRA_CEC_INT_STAT, 0xffffffff);\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, hw_ctrl);\n}\n\nstatic irqreturn_t tegra_cec_irq_thread_handler(int irq, void *data)\n{\n\tstruct device *dev = data;\n\tstruct tegra_cec *cec = dev_get_drvdata(dev);\n\n\tif (cec->tx_done) {\n\t\tcec_transmit_attempt_done(cec->adap, cec->tx_status);\n\t\tcec->tx_done = false;\n\t}\n\tif (cec->rx_done) {\n\t\tstruct cec_msg msg = {};\n\n\t\tmsg.len = cec->rx_buf_cnt;\n\t\tmemcpy(msg.msg, cec->rx_buf, msg.len);\n\t\tcec_received_msg(cec->adap, &msg);\n\t\tcec->rx_done = false;\n\t\tcec->rx_buf_cnt = 0;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_cec_irq_handler(int irq, void *data)\n{\n\tstruct device *dev = data;\n\tstruct tegra_cec *cec = dev_get_drvdata(dev);\n\tu32 status, mask;\n\n\tstatus = cec_read(cec, TEGRA_CEC_INT_STAT);\n\tmask = cec_read(cec, TEGRA_CEC_INT_MASK);\n\n\tstatus &= mask;\n\n\tif (!status)\n\t\treturn IRQ_HANDLED;\n\n\tif (status & TEGRA_CEC_INT_STAT_TX_REGISTER_UNDERRUN) {\n\t\tdev_err(dev, \"TX underrun, interrupt timing issue!\\n\");\n\n\t\ttegra_cec_error_recovery(cec);\n\t\tcec_write(cec, TEGRA_CEC_INT_MASK,\n\t\t\t  mask & ~TEGRA_CEC_INT_MASK_TX_REGISTER_EMPTY);\n\n\t\tcec->tx_done = true;\n\t\tcec->tx_status = CEC_TX_STATUS_ERROR;\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\tif ((status & TEGRA_CEC_INT_STAT_TX_ARBITRATION_FAILED) ||\n\t\t   (status & TEGRA_CEC_INT_STAT_TX_BUS_ANOMALY_DETECTED)) {\n\t\ttegra_cec_error_recovery(cec);\n\t\tcec_write(cec, TEGRA_CEC_INT_MASK,\n\t\t\t  mask & ~TEGRA_CEC_INT_MASK_TX_REGISTER_EMPTY);\n\n\t\tcec->tx_done = true;\n\t\tif (status & TEGRA_CEC_INT_STAT_TX_BUS_ANOMALY_DETECTED)\n\t\t\tcec->tx_status = CEC_TX_STATUS_LOW_DRIVE;\n\t\telse\n\t\t\tcec->tx_status = CEC_TX_STATUS_ARB_LOST;\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\tif (status & TEGRA_CEC_INT_STAT_TX_FRAME_TRANSMITTED) {\n\t\tcec_write(cec, TEGRA_CEC_INT_STAT,\n\t\t\t  TEGRA_CEC_INT_STAT_TX_FRAME_TRANSMITTED);\n\n\t\tif (status & TEGRA_CEC_INT_STAT_TX_FRAME_OR_BLOCK_NAKD) {\n\t\t\ttegra_cec_error_recovery(cec);\n\n\t\t\tcec->tx_done = true;\n\t\t\tcec->tx_status = CEC_TX_STATUS_NACK;\n\t\t} else {\n\t\t\tcec->tx_done = true;\n\t\t\tcec->tx_status = CEC_TX_STATUS_OK;\n\t\t}\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\tif (status & TEGRA_CEC_INT_STAT_TX_FRAME_OR_BLOCK_NAKD)\n\t\tdev_warn(dev, \"TX NAKed on the fly!\\n\");\n\n\tif (status & TEGRA_CEC_INT_STAT_TX_REGISTER_EMPTY) {\n\t\tif (cec->tx_buf_cur == cec->tx_buf_cnt) {\n\t\t\tcec_write(cec, TEGRA_CEC_INT_MASK,\n\t\t\t\t  mask & ~TEGRA_CEC_INT_MASK_TX_REGISTER_EMPTY);\n\t\t} else {\n\t\t\tcec_write(cec, TEGRA_CEC_TX_REGISTER,\n\t\t\t\t  cec->tx_buf[cec->tx_buf_cur++]);\n\t\t\tcec_write(cec, TEGRA_CEC_INT_STAT,\n\t\t\t\t  TEGRA_CEC_INT_STAT_TX_REGISTER_EMPTY);\n\t\t}\n\t}\n\n\tif (status & TEGRA_CEC_INT_STAT_RX_START_BIT_DETECTED) {\n\t\tcec_write(cec, TEGRA_CEC_INT_STAT,\n\t\t\t  TEGRA_CEC_INT_STAT_RX_START_BIT_DETECTED);\n\t\tcec->rx_done = false;\n\t\tcec->rx_buf_cnt = 0;\n\t}\n\tif (status & TEGRA_CEC_INT_STAT_RX_REGISTER_FULL) {\n\t\tu32 v;\n\n\t\tcec_write(cec, TEGRA_CEC_INT_STAT,\n\t\t\t  TEGRA_CEC_INT_STAT_RX_REGISTER_FULL);\n\t\tv = cec_read(cec, TEGRA_CEC_RX_REGISTER);\n\t\tif (cec->rx_buf_cnt < CEC_MAX_MSG_SIZE)\n\t\t\tcec->rx_buf[cec->rx_buf_cnt++] = v & 0xff;\n\t\tif (v & TEGRA_CEC_RX_REGISTER_EOM) {\n\t\t\tcec->rx_done = true;\n\t\t\treturn IRQ_WAKE_THREAD;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct tegra_cec *cec = adap->priv;\n\n\tcec->rx_buf_cnt = 0;\n\tcec->tx_buf_cnt = 0;\n\tcec->tx_buf_cur = 0;\n\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, 0);\n\tcec_write(cec, TEGRA_CEC_INT_MASK, 0);\n\tcec_write(cec, TEGRA_CEC_INT_STAT, 0xffffffff);\n\tcec_write(cec, TEGRA_CEC_SW_CONTROL, 0);\n\n\tif (!enable)\n\t\treturn 0;\n\n\tcec_write(cec, TEGRA_CEC_INPUT_FILTER, (1U << 31) | 0x20);\n\n\tcec_write(cec, TEGRA_CEC_RX_TIMING_0,\n\t\t  (0x7a << TEGRA_CEC_RX_TIM0_START_BIT_MAX_LO_TIME_SHIFT) |\n\t\t  (0x6d << TEGRA_CEC_RX_TIM0_START_BIT_MIN_LO_TIME_SHIFT) |\n\t\t  (0x93 << TEGRA_CEC_RX_TIM0_START_BIT_MAX_DURATION_SHIFT) |\n\t\t  (0x86 << TEGRA_CEC_RX_TIM0_START_BIT_MIN_DURATION_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_RX_TIMING_1,\n\t\t  (0x35 << TEGRA_CEC_RX_TIM1_DATA_BIT_MAX_LO_TIME_SHIFT) |\n\t\t  (0x21 << TEGRA_CEC_RX_TIM1_DATA_BIT_SAMPLE_TIME_SHIFT) |\n\t\t  (0x56 << TEGRA_CEC_RX_TIM1_DATA_BIT_MAX_DURATION_SHIFT) |\n\t\t  (0x40 << TEGRA_CEC_RX_TIM1_DATA_BIT_MIN_DURATION_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_RX_TIMING_2,\n\t\t  (0x50 << TEGRA_CEC_RX_TIM2_END_OF_BLOCK_TIME_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_TX_TIMING_0,\n\t\t  (0x74 << TEGRA_CEC_TX_TIM0_START_BIT_LO_TIME_SHIFT) |\n\t\t  (0x8d << TEGRA_CEC_TX_TIM0_START_BIT_DURATION_SHIFT) |\n\t\t  (0x08 << TEGRA_CEC_TX_TIM0_BUS_XITION_TIME_SHIFT) |\n\t\t  (0x71 << TEGRA_CEC_TX_TIM0_BUS_ERROR_LO_TIME_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_TX_TIMING_1,\n\t\t  (0x2f << TEGRA_CEC_TX_TIM1_LO_DATA_BIT_LO_TIME_SHIFT) |\n\t\t  (0x13 << TEGRA_CEC_TX_TIM1_HI_DATA_BIT_LO_TIME_SHIFT) |\n\t\t  (0x4b << TEGRA_CEC_TX_TIM1_DATA_BIT_DURATION_SHIFT) |\n\t\t  (0x21 << TEGRA_CEC_TX_TIM1_ACK_NAK_BIT_SAMPLE_TIME_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_TX_TIMING_2,\n\t\t  (0x07 << TEGRA_CEC_TX_TIM2_BUS_IDLE_TIME_ADDITIONAL_FRAME_SHIFT) |\n\t\t  (0x05 << TEGRA_CEC_TX_TIM2_BUS_IDLE_TIME_NEW_FRAME_SHIFT) |\n\t\t  (0x03 << TEGRA_CEC_TX_TIM2_BUS_IDLE_TIME_RETRY_FRAME_SHIFT));\n\n\tcec_write(cec, TEGRA_CEC_INT_MASK,\n\t\t  TEGRA_CEC_INT_MASK_TX_REGISTER_UNDERRUN |\n\t\t  TEGRA_CEC_INT_MASK_TX_FRAME_OR_BLOCK_NAKD |\n\t\t  TEGRA_CEC_INT_MASK_TX_ARBITRATION_FAILED |\n\t\t  TEGRA_CEC_INT_MASK_TX_BUS_ANOMALY_DETECTED |\n\t\t  TEGRA_CEC_INT_MASK_TX_FRAME_TRANSMITTED |\n\t\t  TEGRA_CEC_INT_MASK_RX_REGISTER_FULL |\n\t\t  TEGRA_CEC_INT_MASK_RX_START_BIT_DETECTED);\n\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, TEGRA_CEC_HWCTRL_TX_RX_MODE);\n\treturn 0;\n}\n\nstatic int tegra_cec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct tegra_cec *cec = adap->priv;\n\tu32 state = cec_read(cec, TEGRA_CEC_HW_CONTROL);\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID)\n\t\tstate &= ~TEGRA_CEC_HWCTRL_RX_LADDR_MASK;\n\telse\n\t\tstate |= TEGRA_CEC_HWCTRL_RX_LADDR((1 << logical_addr));\n\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, state);\n\treturn 0;\n}\n\nstatic int tegra_cec_adap_monitor_all_enable(struct cec_adapter *adap,\n\t\t\t\t\t     bool enable)\n{\n\tstruct tegra_cec *cec = adap->priv;\n\tu32 reg = cec_read(cec, TEGRA_CEC_HW_CONTROL);\n\n\tif (enable)\n\t\treg |= TEGRA_CEC_HWCTRL_RX_SNOOP;\n\telse\n\t\treg &= ~TEGRA_CEC_HWCTRL_RX_SNOOP;\n\tcec_write(cec, TEGRA_CEC_HW_CONTROL, reg);\n\treturn 0;\n}\n\nstatic int tegra_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t   u32 signal_free_time_ms, struct cec_msg *msg)\n{\n\tbool retry_xfer = signal_free_time_ms == CEC_SIGNAL_FREE_TIME_RETRY;\n\tstruct tegra_cec *cec = adap->priv;\n\tunsigned int i;\n\tu32 mode = 0;\n\tu32 mask;\n\n\tif (cec_msg_is_broadcast(msg))\n\t\tmode = TEGRA_CEC_TX_REG_BCAST;\n\n\tcec->tx_buf_cur = 0;\n\tcec->tx_buf_cnt = msg->len;\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\tcec->tx_buf[i] = mode | msg->msg[i];\n\t\tif (i == 0)\n\t\t\tcec->tx_buf[i] |= TEGRA_CEC_TX_REG_START_BIT;\n\t\tif (i == msg->len - 1)\n\t\t\tcec->tx_buf[i] |= TEGRA_CEC_TX_REG_EOM;\n\t\tif (i == 0 && retry_xfer)\n\t\t\tcec->tx_buf[i] |= TEGRA_CEC_TX_REG_RETRY;\n\t}\n\n\tmask = cec_read(cec, TEGRA_CEC_INT_MASK);\n\tcec_write(cec, TEGRA_CEC_INT_MASK,\n\t\t  mask | TEGRA_CEC_INT_MASK_TX_REGISTER_EMPTY);\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops tegra_cec_ops = {\n\t.adap_enable = tegra_cec_adap_enable,\n\t.adap_log_addr = tegra_cec_adap_log_addr,\n\t.adap_transmit = tegra_cec_adap_transmit,\n\t.adap_monitor_all_enable = tegra_cec_adap_monitor_all_enable,\n};\n\nstatic int tegra_cec_probe(struct platform_device *pdev)\n{\n\tstruct device *hdmi_dev;\n\tstruct tegra_cec *cec;\n\tstruct resource *res;\n\tint ret = 0;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(&pdev->dev);\n\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tcec = devm_kzalloc(&pdev->dev, sizeof(struct tegra_cec), GFP_KERNEL);\n\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (!res) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to allocate resources for device\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\n\t\tpdev->name)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to request mem region for device\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcec->tegra_cec_irq = platform_get_irq(pdev, 0);\n\n\tif (cec->tegra_cec_irq < 0)\n\t\treturn cec->tegra_cec_irq;\n\n\tcec->cec_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t     resource_size(res));\n\n\tif (!cec->cec_base) {\n\t\tdev_err(&pdev->dev, \"Unable to grab IOs for device\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcec->clk = devm_clk_get(&pdev->dev, \"cec\");\n\n\tif (IS_ERR_OR_NULL(cec->clk)) {\n\t\tdev_err(&pdev->dev, \"Can't get clock for CEC\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = clk_prepare_enable(cec->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to prepare clock for CEC\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcec->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, cec);\n\n\tret = devm_request_threaded_irq(&pdev->dev, cec->tegra_cec_irq,\n\t\ttegra_cec_irq_handler, tegra_cec_irq_thread_handler,\n\t\t0, \"cec_irq\", &pdev->dev);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to request interrupt for device\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tcec->adap = cec_allocate_adapter(&tegra_cec_ops, cec, TEGRA_CEC_NAME,\n\t\t\tCEC_CAP_DEFAULTS | CEC_CAP_MONITOR_ALL |\n\t\t\tCEC_CAP_CONNECTOR_INFO,\n\t\t\tCEC_MAX_LOG_ADDRS);\n\tif (IS_ERR(cec->adap)) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Couldn't create cec adapter\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tcec->notifier = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t       cec->adap);\n\tif (!cec->notifier) {\n\t\tret = -ENOMEM;\n\t\tgoto err_adapter;\n\t}\n\n\tret = cec_register_adapter(cec->adap, &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register device\\n\");\n\t\tgoto err_notifier;\n\t}\n\n\treturn 0;\n\nerr_notifier:\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\nerr_adapter:\n\tcec_delete_adapter(cec->adap);\nerr_clk:\n\tclk_disable_unprepare(cec->clk);\n\treturn ret;\n}\n\nstatic void tegra_cec_remove(struct platform_device *pdev)\n{\n\tstruct tegra_cec *cec = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(cec->clk);\n\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\tcec_unregister_adapter(cec->adap);\n}\n\n#ifdef CONFIG_PM\nstatic int tegra_cec_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct tegra_cec *cec = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(cec->clk);\n\n\tdev_notice(&pdev->dev, \"suspended\\n\");\n\treturn 0;\n}\n\nstatic int tegra_cec_resume(struct platform_device *pdev)\n{\n\tstruct tegra_cec *cec = platform_get_drvdata(pdev);\n\n\tdev_notice(&pdev->dev, \"Resuming\\n\");\n\n\treturn clk_prepare_enable(cec->clk);\n}\n#endif\n\nstatic const struct of_device_id tegra_cec_of_match[] = {\n\t{ .compatible = \"nvidia,tegra114-cec\", },\n\t{ .compatible = \"nvidia,tegra124-cec\", },\n\t{ .compatible = \"nvidia,tegra210-cec\", },\n\t{},\n};\n\nstatic struct platform_driver tegra_cec_driver = {\n\t.driver = {\n\t\t.name = TEGRA_CEC_NAME,\n\t\t.of_match_table = tegra_cec_of_match,\n\t},\n\t.probe = tegra_cec_probe,\n\t.remove_new = tegra_cec_remove,\n\n#ifdef CONFIG_PM\n\t.suspend = tegra_cec_suspend,\n\t.resume = tegra_cec_resume,\n#endif\n};\n\nmodule_platform_driver(tegra_cec_driver);\n\nMODULE_DESCRIPTION(\"Tegra HDMI CEC driver\");\nMODULE_AUTHOR(\"NVIDIA CORPORATION\");\nMODULE_AUTHOR(\"Cisco Systems, Inc. and/or its affiliates\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}