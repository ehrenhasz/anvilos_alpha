{
  "module_name": "ao-cec.c",
  "hash_id": "330ad00bdf5cbaf71d518887bd5913857d3cfa071f06b484bfbe82965d1915f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/meson/ao-cec.c",
  "human_readable_source": " \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/reset.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n \n\n \n#define CEC_GEN_CNTL_REG\t\t0x00\n\n#define CEC_GEN_CNTL_RESET\t\tBIT(0)\n#define CEC_GEN_CNTL_CLK_DISABLE\t0\n#define CEC_GEN_CNTL_CLK_ENABLE\t\t1\n#define CEC_GEN_CNTL_CLK_ENABLE_DBG\t2\n#define CEC_GEN_CNTL_CLK_CTRL_MASK\tGENMASK(2, 1)\n\n \n#define CEC_RW_REG\t\t\t0x04\n\n#define CEC_RW_ADDR\t\t\tGENMASK(7, 0)\n#define CEC_RW_WR_DATA\t\t\tGENMASK(15, 8)\n#define CEC_RW_WRITE_EN\t\t\tBIT(16)\n#define CEC_RW_BUS_BUSY\t\t\tBIT(23)\n#define CEC_RW_RD_DATA\t\t\tGENMASK(31, 24)\n\n \n#define CEC_INTR_MASKN_REG\t\t0x08\n#define CEC_INTR_CLR_REG\t\t0x0c\n#define CEC_INTR_STAT_REG\t\t0x10\n\n#define CEC_INTR_TX\t\t\tBIT(1)\n#define CEC_INTR_RX\t\t\tBIT(2)\n\n \n\n#define CEC_TX_MSG_0_HEADER\t\t0x00\n#define CEC_TX_MSG_1_OPCODE\t\t0x01\n#define CEC_TX_MSG_2_OP1\t\t0x02\n#define CEC_TX_MSG_3_OP2\t\t0x03\n#define CEC_TX_MSG_4_OP3\t\t0x04\n#define CEC_TX_MSG_5_OP4\t\t0x05\n#define CEC_TX_MSG_6_OP5\t\t0x06\n#define CEC_TX_MSG_7_OP6\t\t0x07\n#define CEC_TX_MSG_8_OP7\t\t0x08\n#define CEC_TX_MSG_9_OP8\t\t0x09\n#define CEC_TX_MSG_A_OP9\t\t0x0A\n#define CEC_TX_MSG_B_OP10\t\t0x0B\n#define CEC_TX_MSG_C_OP11\t\t0x0C\n#define CEC_TX_MSG_D_OP12\t\t0x0D\n#define CEC_TX_MSG_E_OP13\t\t0x0E\n#define CEC_TX_MSG_F_OP14\t\t0x0F\n#define CEC_TX_MSG_LENGTH\t\t0x10\n#define CEC_TX_MSG_CMD\t\t\t0x11\n#define CEC_TX_WRITE_BUF\t\t0x12\n#define CEC_TX_CLEAR_BUF\t\t0x13\n#define CEC_RX_MSG_CMD\t\t\t0x14\n#define CEC_RX_CLEAR_BUF\t\t0x15\n#define CEC_LOGICAL_ADDR0\t\t0x16\n#define CEC_LOGICAL_ADDR1\t\t0x17\n#define CEC_LOGICAL_ADDR2\t\t0x18\n#define CEC_LOGICAL_ADDR3\t\t0x19\n#define CEC_LOGICAL_ADDR4\t\t0x1A\n#define CEC_CLOCK_DIV_H\t\t\t0x1B\n#define CEC_CLOCK_DIV_L\t\t\t0x1C\n#define CEC_QUIESCENT_25MS_BIT7_0\t0x20\n#define CEC_QUIESCENT_25MS_BIT11_8\t0x21\n#define CEC_STARTBITMINL2H_3MS5_BIT7_0\t0x22\n#define CEC_STARTBITMINL2H_3MS5_BIT8\t0x23\n#define CEC_STARTBITMAXL2H_3MS9_BIT7_0\t0x24\n#define CEC_STARTBITMAXL2H_3MS9_BIT8\t0x25\n#define CEC_STARTBITMINH_0MS6_BIT7_0\t0x26\n#define CEC_STARTBITMINH_0MS6_BIT8\t0x27\n#define CEC_STARTBITMAXH_1MS0_BIT7_0\t0x28\n#define CEC_STARTBITMAXH_1MS0_BIT8\t0x29\n#define CEC_STARTBITMINTOT_4MS3_BIT7_0\t0x2A\n#define CEC_STARTBITMINTOT_4MS3_BIT9_8\t0x2B\n#define CEC_STARTBITMAXTOT_4MS7_BIT7_0\t0x2C\n#define CEC_STARTBITMAXTOT_4MS7_BIT9_8\t0x2D\n#define CEC_LOGIC1MINL2H_0MS4_BIT7_0\t0x2E\n#define CEC_LOGIC1MINL2H_0MS4_BIT8\t0x2F\n#define CEC_LOGIC1MAXL2H_0MS8_BIT7_0\t0x30\n#define CEC_LOGIC1MAXL2H_0MS8_BIT8\t0x31\n#define CEC_LOGIC0MINL2H_1MS3_BIT7_0\t0x32\n#define CEC_LOGIC0MINL2H_1MS3_BIT8\t0x33\n#define CEC_LOGIC0MAXL2H_1MS7_BIT7_0\t0x34\n#define CEC_LOGIC0MAXL2H_1MS7_BIT8\t0x35\n#define CEC_LOGICMINTOTAL_2MS05_BIT7_0\t0x36\n#define CEC_LOGICMINTOTAL_2MS05_BIT9_8\t0x37\n#define CEC_LOGICMAXHIGH_2MS8_BIT7_0\t0x38\n#define CEC_LOGICMAXHIGH_2MS8_BIT8\t0x39\n#define CEC_LOGICERRLOW_3MS4_BIT7_0\t0x3A\n#define CEC_LOGICERRLOW_3MS4_BIT8\t0x3B\n#define CEC_NOMSMPPOINT_1MS05\t\t0x3C\n#define CEC_DELCNTR_LOGICERR\t\t0x3E\n#define CEC_TXTIME_17MS_BIT7_0\t\t0x40\n#define CEC_TXTIME_17MS_BIT10_8\t\t0x41\n#define CEC_TXTIME_2BIT_BIT7_0\t\t0x42\n#define CEC_TXTIME_2BIT_BIT10_8\t\t0x43\n#define CEC_TXTIME_4BIT_BIT7_0\t\t0x44\n#define CEC_TXTIME_4BIT_BIT10_8\t\t0x45\n#define CEC_STARTBITNOML2H_3MS7_BIT7_0\t0x46\n#define CEC_STARTBITNOML2H_3MS7_BIT8\t0x47\n#define CEC_STARTBITNOMH_0MS8_BIT7_0\t0x48\n#define CEC_STARTBITNOMH_0MS8_BIT8\t0x49\n#define CEC_LOGIC1NOML2H_0MS6_BIT7_0\t0x4A\n#define CEC_LOGIC1NOML2H_0MS6_BIT8\t0x4B\n#define CEC_LOGIC0NOML2H_1MS5_BIT7_0\t0x4C\n#define CEC_LOGIC0NOML2H_1MS5_BIT8\t0x4D\n#define CEC_LOGIC1NOMH_1MS8_BIT7_0\t0x4E\n#define CEC_LOGIC1NOMH_1MS8_BIT8\t0x4F\n#define CEC_LOGIC0NOMH_0MS9_BIT7_0\t0x50\n#define CEC_LOGIC0NOMH_0MS9_BIT8\t0x51\n#define CEC_LOGICERRLOW_3MS6_BIT7_0\t0x52\n#define CEC_LOGICERRLOW_3MS6_BIT8\t0x53\n#define CEC_CHKCONTENTION_0MS1\t\t0x54\n#define CEC_PREPARENXTBIT_0MS05_BIT7_0\t0x56\n#define CEC_PREPARENXTBIT_0MS05_BIT8\t0x57\n#define CEC_NOMSMPACKPOINT_0MS45\t0x58\n#define CEC_ACK0NOML2H_1MS5_BIT7_0\t0x5A\n#define CEC_ACK0NOML2H_1MS5_BIT8\t0x5B\n#define CEC_BUGFIX_DISABLE_0\t\t0x60\n#define CEC_BUGFIX_DISABLE_1\t\t0x61\n#define CEC_RX_MSG_0_HEADER\t\t0x80\n#define CEC_RX_MSG_1_OPCODE\t\t0x81\n#define CEC_RX_MSG_2_OP1\t\t0x82\n#define CEC_RX_MSG_3_OP2\t\t0x83\n#define CEC_RX_MSG_4_OP3\t\t0x84\n#define CEC_RX_MSG_5_OP4\t\t0x85\n#define CEC_RX_MSG_6_OP5\t\t0x86\n#define CEC_RX_MSG_7_OP6\t\t0x87\n#define CEC_RX_MSG_8_OP7\t\t0x88\n#define CEC_RX_MSG_9_OP8\t\t0x89\n#define CEC_RX_MSG_A_OP9\t\t0x8A\n#define CEC_RX_MSG_B_OP10\t\t0x8B\n#define CEC_RX_MSG_C_OP11\t\t0x8C\n#define CEC_RX_MSG_D_OP12\t\t0x8D\n#define CEC_RX_MSG_E_OP13\t\t0x8E\n#define CEC_RX_MSG_F_OP14\t\t0x8F\n#define CEC_RX_MSG_LENGTH\t\t0x90\n#define CEC_RX_MSG_STATUS\t\t0x91\n#define CEC_RX_NUM_MSG\t\t\t0x92\n#define CEC_TX_MSG_STATUS\t\t0x93\n#define CEC_TX_NUM_MSG\t\t\t0x94\n\n\n \n#define TX_NO_OP\t0   \n#define TX_REQ_CURRENT\t1   \n#define TX_ABORT\t2   \n#define TX_REQ_NEXT\t3   \n\n \n#define TX_IDLE\t\t0   \n#define TX_BUSY\t\t1   \n#define TX_DONE\t\t2   \n#define TX_ERROR\t3   \n\n \n#define RX_NO_OP\t0   \n#define RX_ACK_CURRENT\t1   \n#define RX_DISABLE\t2   \n#define RX_ACK_NEXT\t3   \n\n \n#define RX_IDLE\t\t0   \n#define RX_BUSY\t\t1   \n#define RX_DONE\t\t2   \n#define RX_ERROR\t3   \n\n \n#define CLEAR_START\t1\n#define CLEAR_STOP\t0\n\n \n#define LOGICAL_ADDR_MASK\t0xf\n#define LOGICAL_ADDR_VALID\tBIT(4)\n#define LOGICAL_ADDR_DISABLE\t0\n\n#define CEC_CLK_RATE\t\t32768\n\nstruct meson_ao_cec_device {\n\tstruct platform_device\t\t*pdev;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*core;\n\tspinlock_t\t\t\tcec_reg_lock;\n\tstruct cec_notifier\t\t*notify;\n\tstruct cec_adapter\t\t*adap;\n\tstruct cec_msg\t\t\trx_msg;\n};\n\n#define writel_bits_relaxed(mask, val, addr) \\\n\twritel_relaxed((readl_relaxed(addr) & ~(mask)) | (val), addr)\n\nstatic inline int meson_ao_cec_wait_busy(struct meson_ao_cec_device *ao_cec)\n{\n\tktime_t timeout = ktime_add_us(ktime_get(), 5000);\n\n\twhile (readl_relaxed(ao_cec->base + CEC_RW_REG) & CEC_RW_BUS_BUSY) {\n\t\tif (ktime_compare(ktime_get(), timeout) > 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_ao_cec_read(struct meson_ao_cec_device *ao_cec,\n\t\t\t     unsigned long address, u8 *data,\n\t\t\t     int *res)\n{\n\tunsigned long flags;\n\tu32 reg = FIELD_PREP(CEC_RW_ADDR, address);\n\tint ret = 0;\n\n\tif (res && *res)\n\t\treturn;\n\n\tspin_lock_irqsave(&ao_cec->cec_reg_lock, flags);\n\n\tret = meson_ao_cec_wait_busy(ao_cec);\n\tif (ret)\n\t\tgoto read_out;\n\n\twritel_relaxed(reg, ao_cec->base + CEC_RW_REG);\n\n\tret = meson_ao_cec_wait_busy(ao_cec);\n\tif (ret)\n\t\tgoto read_out;\n\n\t*data = FIELD_GET(CEC_RW_RD_DATA,\n\t\t\t  readl_relaxed(ao_cec->base + CEC_RW_REG));\n\nread_out:\n\tspin_unlock_irqrestore(&ao_cec->cec_reg_lock, flags);\n\n\tif (res)\n\t\t*res = ret;\n}\n\nstatic void meson_ao_cec_write(struct meson_ao_cec_device *ao_cec,\n\t\t\t       unsigned long address, u8 data,\n\t\t\t       int *res)\n{\n\tunsigned long flags;\n\tu32 reg = FIELD_PREP(CEC_RW_ADDR, address) |\n\t\t  FIELD_PREP(CEC_RW_WR_DATA, data) |\n\t\t  CEC_RW_WRITE_EN;\n\tint ret = 0;\n\n\tif (res && *res)\n\t\treturn;\n\n\tspin_lock_irqsave(&ao_cec->cec_reg_lock, flags);\n\n\tret = meson_ao_cec_wait_busy(ao_cec);\n\tif (ret)\n\t\tgoto write_out;\n\n\twritel_relaxed(reg, ao_cec->base + CEC_RW_REG);\n\nwrite_out:\n\tspin_unlock_irqrestore(&ao_cec->cec_reg_lock, flags);\n\n\tif (res)\n\t\t*res = ret;\n}\n\nstatic inline void meson_ao_cec_irq_setup(struct meson_ao_cec_device *ao_cec,\n\t\t\t\t      bool enable)\n{\n\tu32 cfg = CEC_INTR_TX | CEC_INTR_RX;\n\n\twritel_bits_relaxed(cfg, enable ? cfg : 0,\n\t\t\t    ao_cec->base + CEC_INTR_MASKN_REG);\n}\n\nstatic inline int meson_ao_cec_clear(struct meson_ao_cec_device *ao_cec)\n{\n\tint ret = 0;\n\n\tmeson_ao_cec_write(ao_cec, CEC_RX_MSG_CMD, RX_DISABLE, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_CMD, TX_ABORT, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_RX_CLEAR_BUF, 1, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_TX_CLEAR_BUF, 1, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(100);\n\n\tmeson_ao_cec_write(ao_cec, CEC_RX_CLEAR_BUF, 0, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_TX_CLEAR_BUF, 0, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(100);\n\n\tmeson_ao_cec_write(ao_cec, CEC_RX_MSG_CMD, RX_NO_OP, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_CMD, TX_NO_OP, &ret);\n\n\treturn ret;\n}\n\nstatic int meson_ao_cec_arbit_bit_time_set(struct meson_ao_cec_device *ao_cec,\n\t\t\t\t\t   unsigned int bit_set,\n\t\t\t\t\t   unsigned int time_set)\n{\n\tint ret = 0;\n\n\tswitch (bit_set) {\n\tcase CEC_SIGNAL_FREE_TIME_RETRY:\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_4BIT_BIT7_0,\n\t\t\t\t   time_set & 0xff, &ret);\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_4BIT_BIT10_8,\n\t\t\t\t   (time_set >> 8) & 0x7, &ret);\n\t\tbreak;\n\n\tcase CEC_SIGNAL_FREE_TIME_NEW_INITIATOR:\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_2BIT_BIT7_0,\n\t\t\t\t   time_set & 0xff, &ret);\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_2BIT_BIT10_8,\n\t\t\t\t   (time_set >> 8) & 0x7, &ret);\n\t\tbreak;\n\n\tcase CEC_SIGNAL_FREE_TIME_NEXT_XFER:\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_17MS_BIT7_0,\n\t\t\t\t   time_set & 0xff, &ret);\n\t\tmeson_ao_cec_write(ao_cec, CEC_TXTIME_17MS_BIT10_8,\n\t\t\t\t   (time_set >> 8) & 0x7, &ret);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t meson_ao_cec_irq(int irq, void *data)\n{\n\tstruct meson_ao_cec_device *ao_cec = data;\n\tu32 stat = readl_relaxed(ao_cec->base + CEC_INTR_STAT_REG);\n\n\tif (stat)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_NONE;\n}\n\nstatic void meson_ao_cec_irq_tx(struct meson_ao_cec_device *ao_cec)\n{\n\tunsigned long tx_status = 0;\n\tu8 stat;\n\tint ret = 0;\n\n\tmeson_ao_cec_read(ao_cec, CEC_TX_MSG_STATUS, &stat, &ret);\n\tif (ret)\n\t\tgoto tx_reg_err;\n\n\tswitch (stat) {\n\tcase TX_DONE:\n\t\ttx_status = CEC_TX_STATUS_OK;\n\t\tbreak;\n\n\tcase TX_BUSY:\n\t\ttx_status = CEC_TX_STATUS_ARB_LOST;\n\t\tbreak;\n\n\tcase TX_IDLE:\n\t\ttx_status = CEC_TX_STATUS_LOW_DRIVE;\n\t\tbreak;\n\n\tcase TX_ERROR:\n\tdefault:\n\t\ttx_status = CEC_TX_STATUS_NACK;\n\t\tbreak;\n\t}\n\n\t \n\twritel_relaxed(CEC_INTR_TX, ao_cec->base + CEC_INTR_CLR_REG);\n\n\t \n\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_CMD, TX_NO_OP, &ret);\n\tif (ret)\n\t\tgoto tx_reg_err;\n\n\tcec_transmit_attempt_done(ao_cec->adap, tx_status);\n\treturn;\n\ntx_reg_err:\n\tcec_transmit_attempt_done(ao_cec->adap, CEC_TX_STATUS_ERROR);\n}\n\nstatic void meson_ao_cec_irq_rx(struct meson_ao_cec_device *ao_cec)\n{\n\tint i, ret = 0;\n\tu8 reg;\n\n\tmeson_ao_cec_read(ao_cec, CEC_RX_MSG_STATUS, &reg, &ret);\n\tif (reg != RX_DONE)\n\t\tgoto rx_out;\n\n\tmeson_ao_cec_read(ao_cec, CEC_RX_NUM_MSG, &reg, &ret);\n\tif (reg != 1)\n\t\tgoto rx_out;\n\n\tmeson_ao_cec_read(ao_cec, CEC_RX_MSG_LENGTH, &reg, &ret);\n\n\tao_cec->rx_msg.len = reg + 1;\n\tif (ao_cec->rx_msg.len > CEC_MAX_MSG_SIZE)\n\t\tao_cec->rx_msg.len = CEC_MAX_MSG_SIZE;\n\n\tfor (i = 0; i < ao_cec->rx_msg.len; i++) {\n\t\tu8 byte;\n\n\t\tmeson_ao_cec_read(ao_cec, CEC_RX_MSG_0_HEADER + i, &byte, &ret);\n\n\t\tao_cec->rx_msg.msg[i] = byte;\n\t}\n\n\tif (ret)\n\t\tgoto rx_out;\n\n\tcec_received_msg(ao_cec->adap, &ao_cec->rx_msg);\n\nrx_out:\n\t \n\twritel_relaxed(CEC_INTR_RX, ao_cec->base + CEC_INTR_CLR_REG);\n\n\t \n\tmeson_ao_cec_write(ao_cec, CEC_RX_MSG_CMD, RX_ACK_CURRENT, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_RX_MSG_CMD, RX_NO_OP, &ret);\n\n\t \n\tmeson_ao_cec_write(ao_cec, CEC_RX_CLEAR_BUF, CLEAR_START, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_RX_CLEAR_BUF, CLEAR_STOP, &ret);\n}\n\nstatic irqreturn_t meson_ao_cec_irq_thread(int irq, void *data)\n{\n\tstruct meson_ao_cec_device *ao_cec = data;\n\tu32 stat = readl_relaxed(ao_cec->base + CEC_INTR_STAT_REG);\n\n\tif (stat & CEC_INTR_TX)\n\t\tmeson_ao_cec_irq_tx(ao_cec);\n\n\tmeson_ao_cec_irq_rx(ao_cec);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int meson_ao_cec_set_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct meson_ao_cec_device *ao_cec = adap->priv;\n\tint ret = 0;\n\n\tmeson_ao_cec_write(ao_cec, CEC_LOGICAL_ADDR0,\n\t\t\t   LOGICAL_ADDR_DISABLE, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_ao_cec_clear(ao_cec);\n\tif (ret)\n\t\treturn ret;\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID)\n\t\treturn 0;\n\n\tmeson_ao_cec_write(ao_cec, CEC_LOGICAL_ADDR0,\n\t\t\t   logical_addr & LOGICAL_ADDR_MASK, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(100);\n\n\tmeson_ao_cec_write(ao_cec, CEC_LOGICAL_ADDR0,\n\t\t\t   (logical_addr & LOGICAL_ADDR_MASK) |\n\t\t\t   LOGICAL_ADDR_VALID, &ret);\n\n\treturn ret;\n}\n\nstatic int meson_ao_cec_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct meson_ao_cec_device *ao_cec = adap->priv;\n\tint i, ret = 0;\n\tu8 reg;\n\n\tmeson_ao_cec_read(ao_cec, CEC_TX_MSG_STATUS, &reg, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg == TX_BUSY) {\n\t\tdev_dbg(&ao_cec->pdev->dev, \"%s: busy TX: aborting\\n\",\n\t\t\t__func__);\n\t\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_CMD, TX_ABORT, &ret);\n\t}\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_0_HEADER + i,\n\t\t\t\t   msg->msg[i], &ret);\n\t}\n\n\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_LENGTH, msg->len - 1, &ret);\n\tmeson_ao_cec_write(ao_cec, CEC_TX_MSG_CMD, TX_REQ_CURRENT, &ret);\n\n\treturn ret;\n}\n\nstatic int meson_ao_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct meson_ao_cec_device *ao_cec = adap->priv;\n\tint ret;\n\n\tmeson_ao_cec_irq_setup(ao_cec, false);\n\n\twritel_bits_relaxed(CEC_GEN_CNTL_RESET, CEC_GEN_CNTL_RESET,\n\t\t\t    ao_cec->base + CEC_GEN_CNTL_REG);\n\n\tif (!enable)\n\t\treturn 0;\n\n\t \n\twritel_bits_relaxed(CEC_GEN_CNTL_CLK_CTRL_MASK,\n\t\t\t    FIELD_PREP(CEC_GEN_CNTL_CLK_CTRL_MASK,\n\t\t\t\t       CEC_GEN_CNTL_CLK_ENABLE),\n\t\t\t    ao_cec->base + CEC_GEN_CNTL_REG);\n\n\tudelay(100);\n\n\t \n\twritel_bits_relaxed(CEC_GEN_CNTL_RESET, 0,\n\t\t\t    ao_cec->base + CEC_GEN_CNTL_REG);\n\n\t \n\tret = meson_ao_cec_clear(ao_cec);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = meson_ao_cec_arbit_bit_time_set(ao_cec,\n\t\t\t\t\tCEC_SIGNAL_FREE_TIME_RETRY,\n\t\t\t\t\t0x118);\n\tif (ret)\n\t\treturn ret;\n\tret = meson_ao_cec_arbit_bit_time_set(ao_cec,\n\t\t\t\t\tCEC_SIGNAL_FREE_TIME_NEW_INITIATOR,\n\t\t\t\t\t0x000);\n\tif (ret)\n\t\treturn ret;\n\tret = meson_ao_cec_arbit_bit_time_set(ao_cec,\n\t\t\t\t\tCEC_SIGNAL_FREE_TIME_NEXT_XFER,\n\t\t\t\t\t0x2aa);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_ao_cec_irq_setup(ao_cec, true);\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops meson_ao_cec_ops = {\n\t.adap_enable = meson_ao_cec_adap_enable,\n\t.adap_log_addr = meson_ao_cec_set_log_addr,\n\t.adap_transmit = meson_ao_cec_transmit,\n};\n\nstatic int meson_ao_cec_probe(struct platform_device *pdev)\n{\n\tstruct meson_ao_cec_device *ao_cec;\n\tstruct device *hdmi_dev;\n\tint ret, irq;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(&pdev->dev);\n\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tao_cec = devm_kzalloc(&pdev->dev, sizeof(*ao_cec), GFP_KERNEL);\n\tif (!ao_cec)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ao_cec->cec_reg_lock);\n\n\tao_cec->adap = cec_allocate_adapter(&meson_ao_cec_ops, ao_cec,\n\t\t\t\t\t    \"meson_ao_cec\",\n\t\t\t\t\t    CEC_CAP_DEFAULTS |\n\t\t\t\t\t    CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t    1);  \n\tif (IS_ERR(ao_cec->adap))\n\t\treturn PTR_ERR(ao_cec->adap);\n\n\tao_cec->adap->owner = THIS_MODULE;\n\n\tao_cec->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ao_cec->base)) {\n\t\tret = PTR_ERR(ao_cec->base);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tmeson_ao_cec_irq,\n\t\t\t\t\tmeson_ao_cec_irq_thread,\n\t\t\t\t\t0, NULL, ao_cec);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request failed\\n\");\n\t\tgoto out_probe_adapter;\n\t}\n\n\tao_cec->core = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(ao_cec->core)) {\n\t\tdev_err(&pdev->dev, \"core clock request failed\\n\");\n\t\tret = PTR_ERR(ao_cec->core);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tret = clk_prepare_enable(ao_cec->core);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"core clock enable failed\\n\");\n\t\tgoto out_probe_adapter;\n\t}\n\n\tret = clk_set_rate(ao_cec->core, CEC_CLK_RATE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"core clock set rate failed\\n\");\n\t\tgoto out_probe_clk;\n\t}\n\n\tdevice_reset_optional(&pdev->dev);\n\n\tao_cec->pdev = pdev;\n\tplatform_set_drvdata(pdev, ao_cec);\n\n\tao_cec->notify = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t\tao_cec->adap);\n\tif (!ao_cec->notify) {\n\t\tret = -ENOMEM;\n\t\tgoto out_probe_clk;\n\t}\n\n\tret = cec_register_adapter(ao_cec->adap, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto out_probe_notify;\n\n\t \n\twritel_relaxed(CEC_GEN_CNTL_RESET,\n\t\t       ao_cec->base + CEC_GEN_CNTL_REG);\n\n\treturn 0;\n\nout_probe_notify:\n\tcec_notifier_cec_adap_unregister(ao_cec->notify, ao_cec->adap);\n\nout_probe_clk:\n\tclk_disable_unprepare(ao_cec->core);\n\nout_probe_adapter:\n\tcec_delete_adapter(ao_cec->adap);\n\n\tdev_err(&pdev->dev, \"CEC controller registration failed\\n\");\n\n\treturn ret;\n}\n\nstatic void meson_ao_cec_remove(struct platform_device *pdev)\n{\n\tstruct meson_ao_cec_device *ao_cec = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(ao_cec->core);\n\n\tcec_notifier_cec_adap_unregister(ao_cec->notify, ao_cec->adap);\n\tcec_unregister_adapter(ao_cec->adap);\n}\n\nstatic const struct of_device_id meson_ao_cec_of_match[] = {\n\t{ .compatible = \"amlogic,meson-gx-ao-cec\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_ao_cec_of_match);\n\nstatic struct platform_driver meson_ao_cec_driver = {\n\t.probe   = meson_ao_cec_probe,\n\t.remove_new = meson_ao_cec_remove,\n\t.driver  = {\n\t\t.name = \"meson-ao-cec\",\n\t\t.of_match_table = meson_ao_cec_of_match,\n\t},\n};\n\nmodule_platform_driver(meson_ao_cec_driver);\n\nMODULE_DESCRIPTION(\"Meson AO CEC Controller driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}