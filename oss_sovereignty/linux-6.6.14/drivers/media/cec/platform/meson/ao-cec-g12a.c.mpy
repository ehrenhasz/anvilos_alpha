{
  "module_name": "ao-cec-g12a.c",
  "hash_id": "6f812aae58f9ae56cd70b853b1fca364193a1f2c5493b7a7102e8f88ecd1ae5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/meson/ao-cec-g12a.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n#include <linux/clk-provider.h>\n\n \n\n#define CECB_CLK_CNTL_REG0\t\t0x00\n\n#define CECB_CLK_CNTL_N1\t\tGENMASK(11, 0)\n#define CECB_CLK_CNTL_N2\t\tGENMASK(23, 12)\n#define CECB_CLK_CNTL_DUAL_EN\t\tBIT(28)\n#define CECB_CLK_CNTL_OUTPUT_EN\t\tBIT(30)\n#define CECB_CLK_CNTL_INPUT_EN\t\tBIT(31)\n\n#define CECB_CLK_CNTL_REG1\t\t0x04\n\n#define CECB_CLK_CNTL_M1\t\tGENMASK(11, 0)\n#define CECB_CLK_CNTL_M2\t\tGENMASK(23, 12)\n#define CECB_CLK_CNTL_BYPASS_EN\t\tBIT(24)\n\n \n#define CECB_GEN_CNTL_REG\t\t0x08\n\n#define CECB_GEN_CNTL_RESET\t\tBIT(0)\n#define CECB_GEN_CNTL_CLK_DISABLE\t0\n#define CECB_GEN_CNTL_CLK_ENABLE\t1\n#define CECB_GEN_CNTL_CLK_ENABLE_DBG\t2\n#define CECB_GEN_CNTL_CLK_CTRL_MASK\tGENMASK(2, 1)\n#define CECB_GEN_CNTL_SYS_CLK_EN\tBIT(3)\n#define CECB_GEN_CNTL_FILTER_TICK_125NS\t0\n#define CECB_GEN_CNTL_FILTER_TICK_1US\t1\n#define CECB_GEN_CNTL_FILTER_TICK_10US\t2\n#define CECB_GEN_CNTL_FILTER_TICK_100US\t3\n#define CECB_GEN_CNTL_FILTER_TICK_SEL\tGENMASK(9, 8)\n#define CECB_GEN_CNTL_FILTER_DEL\tGENMASK(14, 12)\n\n \n#define CECB_RW_REG\t\t\t0x0c\n\n#define CECB_RW_ADDR\t\t\tGENMASK(7, 0)\n#define CECB_RW_WR_DATA\t\t\tGENMASK(15, 8)\n#define CECB_RW_WRITE_EN\t\tBIT(16)\n#define CECB_RW_BUS_BUSY\t\tBIT(23)\n#define CECB_RW_RD_DATA\t\t\tGENMASK(31, 24)\n\n \n#define CECB_INTR_MASKN_REG\t\t0x10\n#define CECB_INTR_CLR_REG\t\t0x14\n#define CECB_INTR_STAT_REG\t\t0x18\n\n#define CECB_INTR_DONE\t\t\tBIT(0)\n#define CECB_INTR_EOM\t\t\tBIT(1)\n#define CECB_INTR_NACK\t\t\tBIT(2)\n#define CECB_INTR_ARB_LOSS\t\tBIT(3)\n#define CECB_INTR_INITIATOR_ERR\t\tBIT(4)\n#define CECB_INTR_FOLLOWER_ERR\t\tBIT(5)\n#define CECB_INTR_WAKE_UP\t\tBIT(6)\n\n \n\n#define CECB_CTRL\t\t0x00\n\n#define CECB_CTRL_SEND\t\tBIT(0)\n#define CECB_CTRL_TYPE\t\tGENMASK(2, 1)\n#define CECB_CTRL_TYPE_RETRY\t0\n#define CECB_CTRL_TYPE_NEW\t1\n#define CECB_CTRL_TYPE_NEXT\t2\n\n#define CECB_CTRL2\t\t0x01\n\n#define CECB_CTRL2_RISE_DEL_MAX\tGENMASK(4, 0)\n\n#define CECB_INTR_MASK\t\t0x02\n#define CECB_LADD_LOW\t\t0x05\n#define CECB_LADD_HIGH\t\t0x06\n#define CECB_TX_CNT\t\t0x07\n#define CECB_RX_CNT\t\t0x08\n#define CECB_STAT0\t\t0x09\n#define CECB_TX_DATA00\t\t0x10\n#define CECB_TX_DATA01\t\t0x11\n#define CECB_TX_DATA02\t\t0x12\n#define CECB_TX_DATA03\t\t0x13\n#define CECB_TX_DATA04\t\t0x14\n#define CECB_TX_DATA05\t\t0x15\n#define CECB_TX_DATA06\t\t0x16\n#define CECB_TX_DATA07\t\t0x17\n#define CECB_TX_DATA08\t\t0x18\n#define CECB_TX_DATA09\t\t0x19\n#define CECB_TX_DATA10\t\t0x1A\n#define CECB_TX_DATA11\t\t0x1B\n#define CECB_TX_DATA12\t\t0x1C\n#define CECB_TX_DATA13\t\t0x1D\n#define CECB_TX_DATA14\t\t0x1E\n#define CECB_TX_DATA15\t\t0x1F\n#define CECB_RX_DATA00\t\t0x20\n#define CECB_RX_DATA01\t\t0x21\n#define CECB_RX_DATA02\t\t0x22\n#define CECB_RX_DATA03\t\t0x23\n#define CECB_RX_DATA04\t\t0x24\n#define CECB_RX_DATA05\t\t0x25\n#define CECB_RX_DATA06\t\t0x26\n#define CECB_RX_DATA07\t\t0x27\n#define CECB_RX_DATA08\t\t0x28\n#define CECB_RX_DATA09\t\t0x29\n#define CECB_RX_DATA10\t\t0x2A\n#define CECB_RX_DATA11\t\t0x2B\n#define CECB_RX_DATA12\t\t0x2C\n#define CECB_RX_DATA13\t\t0x2D\n#define CECB_RX_DATA14\t\t0x2E\n#define CECB_RX_DATA15\t\t0x2F\n#define CECB_LOCK_BUF\t\t0x30\n\n#define CECB_LOCK_BUF_EN\tBIT(0)\n\n#define CECB_WAKEUPCTRL\t\t0x31\n\nstruct meson_ao_cec_g12a_data {\n\t \n\tbool\t\t\t\tctrl2_setup;\n};\n\nstruct meson_ao_cec_g12a_device {\n\tstruct platform_device\t\t*pdev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regmap\t\t\t*regmap_cec;\n\tspinlock_t\t\t\tcec_reg_lock;\n\tstruct cec_notifier\t\t*notify;\n\tstruct cec_adapter\t\t*adap;\n\tstruct cec_msg\t\t\trx_msg;\n\tstruct clk\t\t\t*oscin;\n\tstruct clk\t\t\t*core;\n\tconst struct meson_ao_cec_g12a_data *data;\n};\n\nstatic const struct regmap_config meson_ao_cec_g12a_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = CECB_INTR_STAT_REG,\n};\n\n \n\nstruct meson_ao_cec_g12a_dualdiv_clk {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\n#define hw_to_meson_ao_cec_g12a_dualdiv_clk(_hw)\t\t\t\\\n\tcontainer_of(_hw, struct meson_ao_cec_g12a_dualdiv_clk, hw)\t\\\n\nstatic unsigned long\nmeson_ao_cec_g12a_dualdiv_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct meson_ao_cec_g12a_dualdiv_clk *dualdiv_clk =\n\t\thw_to_meson_ao_cec_g12a_dualdiv_clk(hw);\n\tunsigned long n1;\n\tu32 reg0, reg1;\n\n\tregmap_read(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0, &reg0);\n\tregmap_read(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0, &reg1);\n\n\tif (reg1 & CECB_CLK_CNTL_BYPASS_EN)\n\t\treturn parent_rate;\n\n\tif (reg0 & CECB_CLK_CNTL_DUAL_EN) {\n\t\tunsigned long n2, m1, m2, f1, f2, p1, p2;\n\n\t\tn1 = FIELD_GET(CECB_CLK_CNTL_N1, reg0) + 1;\n\t\tn2 = FIELD_GET(CECB_CLK_CNTL_N2, reg0) + 1;\n\n\t\tm1 = FIELD_GET(CECB_CLK_CNTL_M1, reg1) + 1;\n\t\tm2 = FIELD_GET(CECB_CLK_CNTL_M1, reg1) + 1;\n\n\t\tf1 = DIV_ROUND_CLOSEST(parent_rate, n1);\n\t\tf2 = DIV_ROUND_CLOSEST(parent_rate, n2);\n\n\t\tp1 = DIV_ROUND_CLOSEST(100000000 * m1, f1 * (m1 + m2));\n\t\tp2 = DIV_ROUND_CLOSEST(100000000 * m2, f2 * (m1 + m2));\n\n\t\treturn DIV_ROUND_UP(100000000, p1 + p2);\n\t}\n\n\tn1 = FIELD_GET(CECB_CLK_CNTL_N1, reg0) + 1;\n\n\treturn DIV_ROUND_CLOSEST(parent_rate, n1);\n}\n\nstatic int meson_ao_cec_g12a_dualdiv_clk_enable(struct clk_hw *hw)\n{\n\tstruct meson_ao_cec_g12a_dualdiv_clk *dualdiv_clk =\n\t\thw_to_meson_ao_cec_g12a_dualdiv_clk(hw);\n\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_INPUT_EN | CECB_CLK_CNTL_OUTPUT_EN,\n\t\t\t   0);\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_N1,\n\t\t\t   FIELD_PREP(CECB_CLK_CNTL_N1, 733 - 1));\n\n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_N2,\n\t\t\t   FIELD_PREP(CECB_CLK_CNTL_N2, 732 - 1));\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG1,\n\t\t\t   CECB_CLK_CNTL_M1,\n\t\t\t   FIELD_PREP(CECB_CLK_CNTL_M1, 8 - 1));\n\n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG1,\n\t\t\t   CECB_CLK_CNTL_M2,\n\t\t\t   FIELD_PREP(CECB_CLK_CNTL_M2, 11 - 1));\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_DUAL_EN, CECB_CLK_CNTL_DUAL_EN);\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG1,\n\t\t\t   CECB_CLK_CNTL_BYPASS_EN, 0);\n\n\t \n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_INPUT_EN | CECB_CLK_CNTL_OUTPUT_EN,\n\t\t\t   CECB_CLK_CNTL_INPUT_EN | CECB_CLK_CNTL_OUTPUT_EN);\n\n\treturn 0;\n}\n\nstatic void meson_ao_cec_g12a_dualdiv_clk_disable(struct clk_hw *hw)\n{\n\tstruct meson_ao_cec_g12a_dualdiv_clk *dualdiv_clk =\n\t\thw_to_meson_ao_cec_g12a_dualdiv_clk(hw);\n\n\tregmap_update_bits(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0,\n\t\t\t   CECB_CLK_CNTL_INPUT_EN | CECB_CLK_CNTL_OUTPUT_EN,\n\t\t\t   0);\n}\n\nstatic int meson_ao_cec_g12a_dualdiv_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct meson_ao_cec_g12a_dualdiv_clk *dualdiv_clk =\n\t\thw_to_meson_ao_cec_g12a_dualdiv_clk(hw);\n\tint val;\n\n\tregmap_read(dualdiv_clk->regmap, CECB_CLK_CNTL_REG0, &val);\n\n\treturn !!(val & (CECB_CLK_CNTL_INPUT_EN | CECB_CLK_CNTL_OUTPUT_EN));\n}\n\nstatic const struct clk_ops meson_ao_cec_g12a_dualdiv_clk_ops = {\n\t.recalc_rate\t= meson_ao_cec_g12a_dualdiv_clk_recalc_rate,\n\t.is_enabled\t= meson_ao_cec_g12a_dualdiv_clk_is_enabled,\n\t.enable\t\t= meson_ao_cec_g12a_dualdiv_clk_enable,\n\t.disable\t= meson_ao_cec_g12a_dualdiv_clk_disable,\n};\n\nstatic int meson_ao_cec_g12a_setup_clk(struct meson_ao_cec_g12a_device *ao_cec)\n{\n\tstruct meson_ao_cec_g12a_dualdiv_clk *dualdiv_clk;\n\tstruct device *dev = &ao_cec->pdev->dev;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tstruct clk *clk;\n\tchar *name;\n\n\tdualdiv_clk = devm_kzalloc(dev, sizeof(*dualdiv_clk), GFP_KERNEL);\n\tif (!dualdiv_clk)\n\t\treturn -ENOMEM;\n\n\tname = kasprintf(GFP_KERNEL, \"%s#dualdiv_clk\", dev_name(dev));\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tparent_name = __clk_get_name(ao_cec->oscin);\n\n\tinit.name = name;\n\tinit.ops = &meson_ao_cec_g12a_dualdiv_clk_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tdualdiv_clk->regmap = ao_cec->regmap;\n\tdualdiv_clk->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &dualdiv_clk->hw);\n\tkfree(name);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to register clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tao_cec->core = clk;\n\n\treturn 0;\n}\n\nstatic int meson_ao_cec_g12a_read(void *context, unsigned int addr,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = context;\n\tu32 reg = FIELD_PREP(CECB_RW_ADDR, addr);\n\tint ret = 0;\n\n\tret = regmap_write(ao_cec->regmap, CECB_RW_REG, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(ao_cec->regmap, CECB_RW_REG, reg,\n\t\t\t\t       !(reg & CECB_RW_BUS_BUSY),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(ao_cec->regmap, CECB_RW_REG, &reg);\n\n\t*data = FIELD_GET(CECB_RW_RD_DATA, reg);\n\n\treturn ret;\n}\n\nstatic int meson_ao_cec_g12a_write(void *context, unsigned int addr,\n\t\t\t\t   unsigned int data)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = context;\n\tu32 reg = FIELD_PREP(CECB_RW_ADDR, addr) |\n\t\t  FIELD_PREP(CECB_RW_WR_DATA, data) |\n\t\t  CECB_RW_WRITE_EN;\n\n\treturn regmap_write(ao_cec->regmap, CECB_RW_REG, reg);\n}\n\nstatic const struct regmap_config meson_ao_cec_g12a_cec_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_read = meson_ao_cec_g12a_read,\n\t.reg_write = meson_ao_cec_g12a_write,\n\t.max_register = 0xffff,\n};\n\nstatic inline void\nmeson_ao_cec_g12a_irq_setup(struct meson_ao_cec_g12a_device *ao_cec,\n\t\t\t    bool enable)\n{\n\tu32 cfg = CECB_INTR_DONE | CECB_INTR_EOM | CECB_INTR_NACK |\n\t\t  CECB_INTR_ARB_LOSS | CECB_INTR_INITIATOR_ERR |\n\t\t  CECB_INTR_FOLLOWER_ERR;\n\n\tregmap_write(ao_cec->regmap, CECB_INTR_MASKN_REG,\n\t\t     enable ? cfg : 0);\n}\n\nstatic void meson_ao_cec_g12a_irq_rx(struct meson_ao_cec_g12a_device *ao_cec)\n{\n\tint i, ret = 0;\n\tu32 val;\n\n\tret = regmap_read(ao_cec->regmap_cec, CECB_RX_CNT, &val);\n\n\tao_cec->rx_msg.len = val;\n\tif (ao_cec->rx_msg.len > CEC_MAX_MSG_SIZE)\n\t\tao_cec->rx_msg.len = CEC_MAX_MSG_SIZE;\n\n\tfor (i = 0; i < ao_cec->rx_msg.len; i++) {\n\t\tret |= regmap_read(ao_cec->regmap_cec,\n\t\t\t\t   CECB_RX_DATA00 + i, &val);\n\n\t\tao_cec->rx_msg.msg[i] = val & 0xff;\n\t}\n\n\tret |= regmap_write(ao_cec->regmap_cec, CECB_LOCK_BUF, 0);\n\tif (ret)\n\t\treturn;\n\n\tcec_received_msg(ao_cec->adap, &ao_cec->rx_msg);\n}\n\nstatic irqreturn_t meson_ao_cec_g12a_irq(int irq, void *data)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = data;\n\tu32 stat;\n\n\tregmap_read(ao_cec->regmap, CECB_INTR_STAT_REG, &stat);\n\tif (stat)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t meson_ao_cec_g12a_irq_thread(int irq, void *data)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = data;\n\tu32 stat;\n\n\tregmap_read(ao_cec->regmap, CECB_INTR_STAT_REG, &stat);\n\tregmap_write(ao_cec->regmap, CECB_INTR_CLR_REG, stat);\n\n\tif (stat & CECB_INTR_DONE)\n\t\tcec_transmit_attempt_done(ao_cec->adap, CEC_TX_STATUS_OK);\n\n\tif (stat & CECB_INTR_EOM)\n\t\tmeson_ao_cec_g12a_irq_rx(ao_cec);\n\n\tif (stat & CECB_INTR_NACK)\n\t\tcec_transmit_attempt_done(ao_cec->adap, CEC_TX_STATUS_NACK);\n\n\tif (stat & CECB_INTR_ARB_LOSS) {\n\t\tregmap_write(ao_cec->regmap_cec, CECB_TX_CNT, 0);\n\t\tregmap_update_bits(ao_cec->regmap_cec, CECB_CTRL,\n\t\t\t\t   CECB_CTRL_SEND | CECB_CTRL_TYPE, 0);\n\t\tcec_transmit_attempt_done(ao_cec->adap, CEC_TX_STATUS_ARB_LOST);\n\t}\n\n\t \n\tif (stat & CECB_INTR_INITIATOR_ERR)\n\t\tcec_transmit_attempt_done(ao_cec->adap, CEC_TX_STATUS_ERROR);\n\n\t \n\tif (stat & CECB_INTR_FOLLOWER_ERR)\n\t\tregmap_write(ao_cec->regmap_cec, CECB_LOCK_BUF, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nmeson_ao_cec_g12a_set_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = adap->priv;\n\tint ret = 0;\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID) {\n\t\t \n\t\tregmap_write(ao_cec->regmap_cec, CECB_LADD_LOW, 0);\n\t\tregmap_write(ao_cec->regmap_cec, CECB_LADD_HIGH, 0);\n\n\t\treturn 0;\n\t} else if (logical_addr < 8) {\n\t\tret = regmap_update_bits(ao_cec->regmap_cec, CECB_LADD_LOW,\n\t\t\t\t\t BIT(logical_addr),\n\t\t\t\t\t BIT(logical_addr));\n\t} else {\n\t\tret = regmap_update_bits(ao_cec->regmap_cec, CECB_LADD_HIGH,\n\t\t\t\t\t BIT(logical_addr - 8),\n\t\t\t\t\t BIT(logical_addr - 8));\n\t}\n\n\t \n\tret |= regmap_update_bits(ao_cec->regmap_cec, CECB_LADD_HIGH,\n\t\t\t\t  BIT(CEC_LOG_ADDR_UNREGISTERED - 8),\n\t\t\t\t  BIT(CEC_LOG_ADDR_UNREGISTERED - 8));\n\n\treturn ret ? -EIO : 0;\n}\n\nstatic int meson_ao_cec_g12a_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = adap->priv;\n\tunsigned int type;\n\tint ret = 0;\n\tu32 val;\n\tint i;\n\n\t \n\tret = regmap_read(ao_cec->regmap_cec, CECB_LOCK_BUF, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val & CECB_LOCK_BUF_EN)\n\t\treturn -EBUSY;\n\n\t \n\tret = regmap_read(ao_cec->regmap_cec, CECB_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val & CECB_CTRL_SEND)\n\t\treturn -EBUSY;\n\n\tswitch (signal_free_time) {\n\tcase CEC_SIGNAL_FREE_TIME_RETRY:\n\t\ttype = CECB_CTRL_TYPE_RETRY;\n\t\tbreak;\n\tcase CEC_SIGNAL_FREE_TIME_NEXT_XFER:\n\t\ttype = CECB_CTRL_TYPE_NEXT;\n\t\tbreak;\n\tcase CEC_SIGNAL_FREE_TIME_NEW_INITIATOR:\n\tdefault:\n\t\ttype = CECB_CTRL_TYPE_NEW;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < msg->len; i++)\n\t\tret |= regmap_write(ao_cec->regmap_cec, CECB_TX_DATA00 + i,\n\t\t\t\t    msg->msg[i]);\n\n\tret |= regmap_write(ao_cec->regmap_cec, CECB_TX_CNT, msg->len);\n\tif (ret)\n\t\treturn -EIO;\n\n\tret = regmap_update_bits(ao_cec->regmap_cec, CECB_CTRL,\n\t\t\t\t CECB_CTRL_SEND |\n\t\t\t\t CECB_CTRL_TYPE,\n\t\t\t\t CECB_CTRL_SEND |\n\t\t\t\t FIELD_PREP(CECB_CTRL_TYPE, type));\n\n\treturn ret;\n}\n\nstatic int meson_ao_cec_g12a_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = adap->priv;\n\n\tmeson_ao_cec_g12a_irq_setup(ao_cec, false);\n\n\tregmap_update_bits(ao_cec->regmap, CECB_GEN_CNTL_REG,\n\t\t\t   CECB_GEN_CNTL_RESET, CECB_GEN_CNTL_RESET);\n\n\tif (!enable)\n\t\treturn 0;\n\n\t \n\tregmap_update_bits(ao_cec->regmap, CECB_GEN_CNTL_REG,\n\t\t\t   CECB_GEN_CNTL_FILTER_TICK_SEL |\n\t\t\t   CECB_GEN_CNTL_FILTER_DEL,\n\t\t\t   FIELD_PREP(CECB_GEN_CNTL_FILTER_TICK_SEL,\n\t\t\t\t      CECB_GEN_CNTL_FILTER_TICK_1US) |\n\t\t\t   FIELD_PREP(CECB_GEN_CNTL_FILTER_DEL, 7));\n\n\t \n\tregmap_update_bits(ao_cec->regmap, CECB_GEN_CNTL_REG,\n\t\t\t   CECB_GEN_CNTL_SYS_CLK_EN,\n\t\t\t   CECB_GEN_CNTL_SYS_CLK_EN);\n\n\t \n\tregmap_update_bits(ao_cec->regmap, CECB_GEN_CNTL_REG,\n\t\t\t   CECB_GEN_CNTL_CLK_CTRL_MASK,\n\t\t\t    FIELD_PREP(CECB_GEN_CNTL_CLK_CTRL_MASK,\n\t\t\t\t       CECB_GEN_CNTL_CLK_ENABLE));\n\n\t \n\tregmap_update_bits(ao_cec->regmap, CECB_GEN_CNTL_REG,\n\t\t\t   CECB_GEN_CNTL_RESET, 0);\n\n\tif (ao_cec->data->ctrl2_setup)\n\t\tregmap_write(ao_cec->regmap_cec, CECB_CTRL2,\n\t\t\t     FIELD_PREP(CECB_CTRL2_RISE_DEL_MAX, 2));\n\n\tmeson_ao_cec_g12a_irq_setup(ao_cec, true);\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops meson_ao_cec_g12a_ops = {\n\t.adap_enable = meson_ao_cec_g12a_adap_enable,\n\t.adap_log_addr = meson_ao_cec_g12a_set_log_addr,\n\t.adap_transmit = meson_ao_cec_g12a_transmit,\n};\n\nstatic int meson_ao_cec_g12a_probe(struct platform_device *pdev)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec;\n\tstruct device *hdmi_dev;\n\tvoid __iomem *base;\n\tint ret, irq;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(&pdev->dev);\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tao_cec = devm_kzalloc(&pdev->dev, sizeof(*ao_cec), GFP_KERNEL);\n\tif (!ao_cec)\n\t\treturn -ENOMEM;\n\n\tao_cec->data = of_device_get_match_data(&pdev->dev);\n\tif (!ao_cec->data) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&ao_cec->cec_reg_lock);\n\tao_cec->pdev = pdev;\n\n\tao_cec->adap = cec_allocate_adapter(&meson_ao_cec_g12a_ops, ao_cec,\n\t\t\t\t\t    \"meson_g12a_ao_cec\",\n\t\t\t\t\t    CEC_CAP_DEFAULTS |\n\t\t\t\t\t    CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t    CEC_MAX_LOG_ADDRS);\n\tif (IS_ERR(ao_cec->adap))\n\t\treturn PTR_ERR(ao_cec->adap);\n\n\tao_cec->adap->owner = THIS_MODULE;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tao_cec->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t       &meson_ao_cec_g12a_regmap_conf);\n\tif (IS_ERR(ao_cec->regmap)) {\n\t\tret = PTR_ERR(ao_cec->regmap);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tao_cec->regmap_cec = devm_regmap_init(&pdev->dev, NULL, ao_cec,\n\t\t\t\t\t   &meson_ao_cec_g12a_cec_regmap_conf);\n\tif (IS_ERR(ao_cec->regmap_cec)) {\n\t\tret = PTR_ERR(ao_cec->regmap_cec);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tmeson_ao_cec_g12a_irq,\n\t\t\t\t\tmeson_ao_cec_g12a_irq_thread,\n\t\t\t\t\t0, NULL, ao_cec);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request failed\\n\");\n\t\tgoto out_probe_adapter;\n\t}\n\n\tao_cec->oscin = devm_clk_get(&pdev->dev, \"oscin\");\n\tif (IS_ERR(ao_cec->oscin)) {\n\t\tdev_err(&pdev->dev, \"oscin clock request failed\\n\");\n\t\tret = PTR_ERR(ao_cec->oscin);\n\t\tgoto out_probe_adapter;\n\t}\n\n\tret = meson_ao_cec_g12a_setup_clk(ao_cec);\n\tif (ret)\n\t\tgoto out_probe_adapter;\n\n\tret = clk_prepare_enable(ao_cec->core);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"core clock enable failed\\n\");\n\t\tgoto out_probe_adapter;\n\t}\n\n\tdevice_reset_optional(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, ao_cec);\n\n\tao_cec->notify = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t\tao_cec->adap);\n\tif (!ao_cec->notify) {\n\t\tret = -ENOMEM;\n\t\tgoto out_probe_core_clk;\n\t}\n\n\tret = cec_register_adapter(ao_cec->adap, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto out_probe_notify;\n\n\t \n\tregmap_write(ao_cec->regmap, CECB_GEN_CNTL_REG, CECB_GEN_CNTL_RESET);\n\n\treturn 0;\n\nout_probe_notify:\n\tcec_notifier_cec_adap_unregister(ao_cec->notify, ao_cec->adap);\n\nout_probe_core_clk:\n\tclk_disable_unprepare(ao_cec->core);\n\nout_probe_adapter:\n\tcec_delete_adapter(ao_cec->adap);\n\n\tdev_err(&pdev->dev, \"CEC controller registration failed\\n\");\n\n\treturn ret;\n}\n\nstatic void meson_ao_cec_g12a_remove(struct platform_device *pdev)\n{\n\tstruct meson_ao_cec_g12a_device *ao_cec = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(ao_cec->core);\n\n\tcec_notifier_cec_adap_unregister(ao_cec->notify, ao_cec->adap);\n\n\tcec_unregister_adapter(ao_cec->adap);\n}\n\nstatic const struct meson_ao_cec_g12a_data ao_cec_g12a_data = {\n\t.ctrl2_setup = false,\n};\n\nstatic const struct meson_ao_cec_g12a_data ao_cec_sm1_data = {\n\t.ctrl2_setup = true,\n};\n\nstatic const struct of_device_id meson_ao_cec_g12a_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-ao-cec\",\n\t\t.data = &ao_cec_g12a_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-sm1-ao-cec\",\n\t\t.data = &ao_cec_sm1_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_ao_cec_g12a_of_match);\n\nstatic struct platform_driver meson_ao_cec_g12a_driver = {\n\t.probe   = meson_ao_cec_g12a_probe,\n\t.remove_new = meson_ao_cec_g12a_remove,\n\t.driver  = {\n\t\t.name = \"meson-ao-cec-g12a\",\n\t\t.of_match_table = of_match_ptr(meson_ao_cec_g12a_of_match),\n\t},\n};\n\nmodule_platform_driver(meson_ao_cec_g12a_driver);\n\nMODULE_DESCRIPTION(\"Meson AO CEC G12A Controller driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}