{
  "module_name": "seco-cec.c",
  "hash_id": "3b0270ce163d04770f483c0802086a3103b84595b7576b6f1e99d79badab8992",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/seco/seco-cec.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n \n#include <media/cec-notifier.h>\n\n#include \"seco-cec.h\"\n\nstruct secocec_data {\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\tstruct cec_adapter *cec_adap;\n\tstruct cec_notifier *notifier;\n\tstruct rc_dev *ir;\n\tchar ir_input_phys[32];\n\tint irq;\n};\n\n#define smb_wr16(cmd, data) smb_word_op(SECOCEC_MICRO_ADDRESS, \\\n\t\t\t\t\tcmd, data, SMBUS_WRITE, NULL)\n#define smb_rd16(cmd, res) smb_word_op(SECOCEC_MICRO_ADDRESS, \\\n\t\t\t\t       cmd, 0, SMBUS_READ, res)\n\nstatic int smb_word_op(u16 slave_addr, u8 cmd, u16 data,\n\t\t       u8 operation, u16 *result)\n{\n\tunsigned int count;\n\tint status = 0;\n\n\t \n\tfor (count = 0; count <= SMBTIMEOUT; ++count) {\n\t\tif (!(inb(HSTS) & BRA_INUSE_STS))\n\t\t\tbreak;\n\t\tudelay(SMB_POLL_UDELAY);\n\t}\n\n\tif (count > SMBTIMEOUT)\n\t\t \n\t\toutb(0xff, HSTS);\n\n\toutb(0x00, HCNT);\n\toutb((u8)(slave_addr & 0xfe) | operation, XMIT_SLVA);\n\toutb(cmd, HCMD);\n\tinb(HCNT);\n\n\tif (operation == SMBUS_WRITE) {\n\t\toutb((u8)data, HDAT0);\n\t\toutb((u8)(data >> 8), HDAT1);\n\t}\n\n\toutb(BRA_START + BRA_SMB_CMD_WORD_DATA, HCNT);\n\n\tfor (count = 0; count <= SMBTIMEOUT; count++) {\n\t\tif (!(inb(HSTS) & BRA_HOST_BUSY))\n\t\t\tbreak;\n\t\tudelay(SMB_POLL_UDELAY);\n\t}\n\n\tif (count > SMBTIMEOUT) {\n\t\tstatus = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tif (inb(HSTS) & BRA_HSTS_ERR_MASK) {\n\t\tstatus = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (operation == SMBUS_READ)\n\t\t*result = ((inb(HDAT0) & 0xff) + ((inb(HDAT1) & 0xff) << 8));\n\nerr:\n\toutb(0xff, HSTS);\n\treturn status;\n}\n\nstatic int secocec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct secocec_data *cec = cec_get_drvdata(adap);\n\tstruct device *dev = cec->dev;\n\tu16 val = 0;\n\tint status;\n\n\tif (enable) {\n\t\t \n\t\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &val);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\t \n\t\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1,\n\t\t\t\t  val | SECOCEC_ENABLE_REG_1_CEC);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tdev_dbg(dev, \"Device enabled\\n\");\n\t} else {\n\t\t \n\t\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &val);\n\t\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\n\t\t \n\t\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\t\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1, val &\n\t\t\t\t  ~SECOCEC_ENABLE_REG_1_CEC &\n\t\t\t\t  ~SECOCEC_ENABLE_REG_1_IR);\n\n\t\tdev_dbg(dev, \"Device disabled\\n\");\n\t}\n\n\treturn 0;\nerr:\n\treturn status;\n}\n\nstatic int secocec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tu16 enable_val = 0;\n\tint status;\n\n\t \n\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &enable_val);\n\tif (status)\n\t\treturn status;\n\n\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1,\n\t\t\t  enable_val & ~SECOCEC_ENABLE_REG_1_CEC);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = smb_wr16(SECOCEC_DEVICE_LA, logical_addr & 0xf);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1,\n\t\t\t  enable_val | SECOCEC_ENABLE_REG_1_CEC);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic int secocec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t u32 signal_free_time, struct cec_msg *msg)\n{\n\tu16 payload_len, payload_id_len, destination, val = 0;\n\tu8 *payload_msg;\n\tint status;\n\tu8 i;\n\n\t \n\tpayload_id_len = msg->len - 1;\n\n\t \n\tstatus = smb_wr16(SECOCEC_WRITE_DATA_LENGTH, payload_id_len);\n\tif (status)\n\t\tgoto err;\n\n\t \n\tif (payload_id_len > 0) {\n\t\tstatus = smb_wr16(SECOCEC_WRITE_OPERATION_ID, msg->msg[1]);\n\t\tif (status)\n\t\t\tgoto err;\n\t}\n\t \n\tif (payload_id_len > 1) {\n\t\t \n\t\tpayload_len = msg->len - 2;\n\t\tpayload_msg = &msg->msg[2];\n\n\t\t \n\t\tfor (i = 0; i < payload_len; i += 2) {\n\t\t\t \n\t\t\tval = payload_msg[i + 1] << 8;\n\n\t\t\t \n\t\t\tval |= payload_msg[i];\n\n\t\t\tstatus = smb_wr16(SECOCEC_WRITE_DATA_00 + i / 2, val);\n\t\t\tif (status)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\t \n\tdestination = msg->msg[0];\n\tstatus = smb_wr16(SECOCEC_WRITE_BYTE0, destination);\n\tif (status)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn status;\n}\n\nstatic void secocec_tx_done(struct cec_adapter *adap, u16 status_val)\n{\n\tif (status_val & SECOCEC_STATUS_TX_ERROR_MASK) {\n\t\tif (status_val & SECOCEC_STATUS_TX_NACK_ERROR)\n\t\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_NACK);\n\t\telse\n\t\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_ERROR);\n\t} else {\n\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_OK);\n\t}\n\n\t \n\tstatus_val = SECOCEC_STATUS_TX_ERROR_MASK |\n\t\tSECOCEC_STATUS_MSG_SENT_MASK |\n\t\tSECOCEC_STATUS_TX_NACK_ERROR;\n\tsmb_wr16(SECOCEC_STATUS, status_val);\n}\n\nstatic void secocec_rx_done(struct cec_adapter *adap, u16 status_val)\n{\n\tstruct secocec_data *cec = cec_get_drvdata(adap);\n\tstruct device *dev = cec->dev;\n\tstruct cec_msg msg = { };\n\tbool flag_overflow = false;\n\tu8 payload_len, i = 0;\n\tu8 *payload_msg;\n\tu16 val = 0;\n\tint status;\n\n\tif (status_val & SECOCEC_STATUS_RX_OVERFLOW_MASK) {\n\t\t \n\t\tdev_warn(dev, \"Received more than 16 bytes. Discarding\\n\");\n\t\tflag_overflow = true;\n\t}\n\n\tif (status_val & SECOCEC_STATUS_RX_ERROR_MASK) {\n\t\tdev_warn(dev, \"Message received with errors. Discarding\\n\");\n\t\tstatus = -EIO;\n\t\tgoto rxerr;\n\t}\n\n\t \n\tstatus = smb_rd16(SECOCEC_READ_DATA_LENGTH, &val);\n\tif (status)\n\t\treturn;\n\n\t \n\tmsg.len = min(val + 1, CEC_MAX_MSG_SIZE);\n\n\t \n\tstatus = smb_rd16(SECOCEC_READ_BYTE0, &val);\n\tif (status)\n\t\treturn;\n\n\t \n\tmsg.msg[0] = val;\n\n\t \n\tstatus = smb_rd16(SECOCEC_READ_OPERATION_ID, &val);\n\tif (status)\n\t\treturn;\n\n\tmsg.msg[1] = val;\n\n\t \n\tif (msg.len > 1) {\n\t\tpayload_len = msg.len - 2;\n\t\tpayload_msg = &msg.msg[2];\n\n\t\t \n\t\tfor (i = 0; i < payload_len; i += 2) {\n\t\t\tstatus = smb_rd16(SECOCEC_READ_DATA_00 + i / 2, &val);\n\t\t\tif (status)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tpayload_msg[i] = val & 0x00ff;\n\n\t\t\t \n\t\t\tpayload_msg[i + 1] = (val & 0xff00) >> 8;\n\t\t}\n\t}\n\n\tcec_received_msg(cec->cec_adap, &msg);\n\n\t \n\tstatus_val = SECOCEC_STATUS_MSG_RECEIVED_MASK;\n\tif (flag_overflow)\n\t\tstatus_val |= SECOCEC_STATUS_RX_OVERFLOW_MASK;\n\n\tstatus = smb_wr16(SECOCEC_STATUS, status_val);\n\n\treturn;\n\nrxerr:\n\t \n\tstatus_val = SECOCEC_STATUS_MSG_RECEIVED_MASK |\n\t\tSECOCEC_STATUS_RX_ERROR_MASK;\n\tif (flag_overflow)\n\t\tstatus_val |= SECOCEC_STATUS_RX_OVERFLOW_MASK;\n\tsmb_wr16(SECOCEC_STATUS, status_val);\n}\n\nstatic const struct cec_adap_ops secocec_cec_adap_ops = {\n\t \n\t.adap_enable = secocec_adap_enable,\n\t.adap_log_addr = secocec_adap_log_addr,\n\t.adap_transmit = secocec_adap_transmit,\n};\n\n#ifdef CONFIG_CEC_SECO_RC\nstatic int secocec_ir_probe(void *priv)\n{\n\tstruct secocec_data *cec = priv;\n\tstruct device *dev = cec->dev;\n\tint status;\n\tu16 val;\n\n\t \n\tcec->ir = devm_rc_allocate_device(dev, RC_DRIVER_SCANCODE);\n\tif (!cec->ir)\n\t\treturn -ENOMEM;\n\n\tsnprintf(cec->ir_input_phys, sizeof(cec->ir_input_phys),\n\t\t \"%s/input0\", dev_name(dev));\n\n\tcec->ir->device_name = dev_name(dev);\n\tcec->ir->input_phys = cec->ir_input_phys;\n\tcec->ir->input_id.bustype = BUS_HOST;\n\tcec->ir->input_id.vendor = 0;\n\tcec->ir->input_id.product = 0;\n\tcec->ir->input_id.version = 1;\n\tcec->ir->driver_name = SECOCEC_DEV_NAME;\n\tcec->ir->allowed_protocols = RC_PROTO_BIT_RC5;\n\tcec->ir->priv = cec;\n\tcec->ir->map_name = RC_MAP_HAUPPAUGE;\n\tcec->ir->timeout = MS_TO_US(100);\n\n\t \n\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &val);\n\tif (status != 0)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\tif (status != 0)\n\t\tgoto err;\n\n\t \n\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\tif (status != 0)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1,\n\t\t\t  val | SECOCEC_ENABLE_REG_1_IR);\n\tif (status != 0)\n\t\tgoto err;\n\n\tdev_dbg(dev, \"IR enabled\\n\");\n\n\tstatus = devm_rc_register_device(dev, cec->ir);\n\n\tif (status) {\n\t\tdev_err(dev, \"Failed to prepare input device\\n\");\n\t\tcec->ir = NULL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tsmb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\n\tsmb_wr16(SECOCEC_ENABLE_REG_1,\n\t\t val & ~SECOCEC_ENABLE_REG_1_IR);\n\n\tdev_dbg(dev, \"IR disabled\\n\");\n\treturn status;\n}\n\nstatic int secocec_ir_rx(struct secocec_data *priv)\n{\n\tstruct secocec_data *cec = priv;\n\tstruct device *dev = cec->dev;\n\tu16 val, status, key, addr, toggle;\n\n\tif (!cec->ir)\n\t\treturn -ENODEV;\n\n\tstatus = smb_rd16(SECOCEC_IR_READ_DATA, &val);\n\tif (status != 0)\n\t\tgoto err;\n\n\tkey = val & SECOCEC_IR_COMMAND_MASK;\n\taddr = (val & SECOCEC_IR_ADDRESS_MASK) >> SECOCEC_IR_ADDRESS_SHL;\n\ttoggle = (val & SECOCEC_IR_TOGGLE_MASK) >> SECOCEC_IR_TOGGLE_SHL;\n\n\trc_keydown(cec->ir, RC_PROTO_RC5, RC_SCANCODE_RC5(addr, key), toggle);\n\n\tdev_dbg(dev, \"IR key pressed: 0x%02x addr 0x%02x toggle 0x%02x\\n\", key,\n\t\taddr, toggle);\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"IR Receive message failed (%d)\\n\", status);\n\treturn -EIO;\n}\n#else\nstatic void secocec_ir_rx(struct secocec_data *priv)\n{\n}\n\nstatic int secocec_ir_probe(void *priv)\n{\n\treturn 0;\n}\n#endif\n\nstatic irqreturn_t secocec_irq_handler(int irq, void *priv)\n{\n\tstruct secocec_data *cec = priv;\n\tstruct device *dev = cec->dev;\n\tu16 status_val, cec_val, val = 0;\n\tint status;\n\n\t \n\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &status_val);\n\tif (status)\n\t\tgoto err;\n\n\tif (status_val & SECOCEC_STATUS_REG_1_CEC) {\n\t\t \n\t\tstatus = smb_rd16(SECOCEC_STATUS, &cec_val);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tif (cec_val & SECOCEC_STATUS_MSG_RECEIVED_MASK)\n\t\t\tsecocec_rx_done(cec->cec_adap, cec_val);\n\n\t\tif (cec_val & SECOCEC_STATUS_MSG_SENT_MASK)\n\t\t\tsecocec_tx_done(cec->cec_adap, cec_val);\n\n\t\tif ((~cec_val & SECOCEC_STATUS_MSG_SENT_MASK) &&\n\t\t    (~cec_val & SECOCEC_STATUS_MSG_RECEIVED_MASK))\n\t\t\tdev_warn_once(dev,\n\t\t\t\t      \"Message not received or sent, but interrupt fired\");\n\n\t\tval = SECOCEC_STATUS_REG_1_CEC;\n\t}\n\n\tif (status_val & SECOCEC_STATUS_REG_1_IR) {\n\t\tval |= SECOCEC_STATUS_REG_1_IR;\n\n\t\tsecocec_ir_rx(cec);\n\t}\n\n\t \n\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\tif (status)\n\t\tgoto err;\n\n\treturn IRQ_HANDLED;\n\nerr:\n\tdev_err_once(dev, \"IRQ: R/W SMBus operation failed %d\\n\", status);\n\n\t \n\tval = SECOCEC_STATUS_REG_1_CEC | SECOCEC_STATUS_REG_1_IR;\n\tsmb_wr16(SECOCEC_STATUS_REG_1, val);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct cec_dmi_match {\n\tconst char *sys_vendor;\n\tconst char *product_name;\n\tconst char *devname;\n\tconst char *conn;\n};\n\nstatic const struct cec_dmi_match secocec_dmi_match_table[] = {\n\t \n\t{ \"SECO\", \"UDOO x86\", \"0000:00:02.0\", \"Port B\" },\n};\n\nstatic struct device *secocec_cec_find_hdmi_dev(struct device *dev,\n\t\t\t\t\t\tconst char **conn)\n{\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(secocec_dmi_match_table) ; ++i) {\n\t\tconst struct cec_dmi_match *m = &secocec_dmi_match_table[i];\n\n\t\tif (dmi_match(DMI_SYS_VENDOR, m->sys_vendor) &&\n\t\t    dmi_match(DMI_PRODUCT_NAME, m->product_name)) {\n\t\t\tstruct device *d;\n\n\t\t\t \n\t\t\td = bus_find_device_by_name(&pci_bus_type, NULL,\n\t\t\t\t\t\t    m->devname);\n\t\t\tif (!d)\n\t\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\t\t\tput_device(d);\n\t\t\t*conn = m->conn;\n\t\t\treturn d;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int secocec_acpi_probe(struct secocec_data *sdev)\n{\n\tstruct device *dev = sdev->dev;\n\tstruct gpio_desc *gpio;\n\tint irq = 0;\n\n\tgpio = devm_gpiod_get(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(dev, \"Cannot request interrupt gpio\\n\");\n\t\treturn PTR_ERR(gpio);\n\t}\n\n\tirq = gpiod_to_irq(gpio);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"Cannot find valid irq\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(dev, \"irq-gpio is bound to IRQ %d\\n\", irq);\n\n\tsdev->irq = irq;\n\n\treturn 0;\n}\n\nstatic int secocec_probe(struct platform_device *pdev)\n{\n\tstruct secocec_data *secocec;\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hdmi_dev;\n\tconst char *conn = NULL;\n\tint ret;\n\tu16 val;\n\n\thdmi_dev = secocec_cec_find_hdmi_dev(&pdev->dev, &conn);\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tsecocec = devm_kzalloc(dev, sizeof(*secocec), GFP_KERNEL);\n\tif (!secocec)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, secocec);\n\n\t \n\tif (!request_muxed_region(BRA_SMB_BASE_ADDR, 7, \"CEC00001\")) {\n\t\tdev_err(dev, \"Request memory region failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tsecocec->pdev = pdev;\n\tsecocec->dev = dev;\n\n\tif (!has_acpi_companion(dev)) {\n\t\tdev_dbg(dev, \"Cannot find any ACPI companion\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = secocec_acpi_probe(secocec);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot assign gpio to IRQ\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tret = smb_rd16(SECOCEC_VERSION, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot check fw version\\n\");\n\t\tgoto err;\n\t}\n\tif (val < SECOCEC_LATEST_FW) {\n\t\tdev_err(dev, \"CEC Firmware not supported (v.%04x). Use ver > v.%04x\\n\",\n\t\t\tval, SECOCEC_LATEST_FW);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = devm_request_threaded_irq(dev,\n\t\t\t\t\tsecocec->irq,\n\t\t\t\t\tNULL,\n\t\t\t\t\tsecocec_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev), secocec);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request IRQ %d\\n\", secocec->irq);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\tsecocec->cec_adap = cec_allocate_adapter(&secocec_cec_adap_ops,\n\t\t\t\t\t\t secocec,\n\t\t\t\t\t\t dev_name(dev),\n\t\t\t\t\t\t CEC_CAP_DEFAULTS |\n\t\t\t\t\t\t CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t\t SECOCEC_MAX_ADDRS);\n\n\tif (IS_ERR(secocec->cec_adap)) {\n\t\tret = PTR_ERR(secocec->cec_adap);\n\t\tgoto err;\n\t}\n\n\tsecocec->notifier = cec_notifier_cec_adap_register(hdmi_dev, conn,\n\t\t\t\t\t\t\t   secocec->cec_adap);\n\tif (!secocec->notifier) {\n\t\tret = -ENOMEM;\n\t\tgoto err_delete_adapter;\n\t}\n\n\tret = cec_register_adapter(secocec->cec_adap, dev);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tret = secocec_ir_probe(secocec);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tplatform_set_drvdata(pdev, secocec);\n\n\tdev_dbg(dev, \"Device registered\\n\");\n\n\treturn ret;\n\nerr_notifier:\n\tcec_notifier_cec_adap_unregister(secocec->notifier, secocec->cec_adap);\nerr_delete_adapter:\n\tcec_delete_adapter(secocec->cec_adap);\nerr:\n\trelease_region(BRA_SMB_BASE_ADDR, 7);\n\tdev_err(dev, \"%s device probe failed\\n\", dev_name(dev));\n\n\treturn ret;\n}\n\nstatic void secocec_remove(struct platform_device *pdev)\n{\n\tstruct secocec_data *secocec = platform_get_drvdata(pdev);\n\tu16 val;\n\n\tif (secocec->ir) {\n\t\tsmb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\n\t\tsmb_wr16(SECOCEC_ENABLE_REG_1, val & ~SECOCEC_ENABLE_REG_1_IR);\n\n\t\tdev_dbg(&pdev->dev, \"IR disabled\\n\");\n\t}\n\tcec_notifier_cec_adap_unregister(secocec->notifier, secocec->cec_adap);\n\tcec_unregister_adapter(secocec->cec_adap);\n\n\trelease_region(BRA_SMB_BASE_ADDR, 7);\n\n\tdev_dbg(&pdev->dev, \"CEC device removed\\n\");\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int secocec_suspend(struct device *dev)\n{\n\tint status;\n\tu16 val;\n\n\tdev_dbg(dev, \"Device going to suspend, disabling\\n\");\n\n\t \n\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &val);\n\tif (status)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\tif (status)\n\t\tgoto err;\n\n\t \n\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\tif (status)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1, val &\n\t\t\t  ~SECOCEC_ENABLE_REG_1_CEC & ~SECOCEC_ENABLE_REG_1_IR);\n\tif (status)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"Suspend failed: %d\\n\", status);\n\treturn status;\n}\n\nstatic int secocec_resume(struct device *dev)\n{\n\tint status;\n\tu16 val;\n\n\tdev_dbg(dev, \"Resuming device from suspend\\n\");\n\n\t \n\tstatus = smb_rd16(SECOCEC_STATUS_REG_1, &val);\n\tif (status)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_STATUS_REG_1, val);\n\tif (status)\n\t\tgoto err;\n\n\t \n\tstatus = smb_rd16(SECOCEC_ENABLE_REG_1, &val);\n\tif (status)\n\t\tgoto err;\n\n\tstatus = smb_wr16(SECOCEC_ENABLE_REG_1, val | SECOCEC_ENABLE_REG_1_CEC);\n\tif (status)\n\t\tgoto err;\n\n\tdev_dbg(dev, \"Device resumed from suspend\\n\");\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"Resume failed: %d\\n\", status);\n\treturn status;\n}\n\nstatic SIMPLE_DEV_PM_OPS(secocec_pm_ops, secocec_suspend, secocec_resume);\n#define SECOCEC_PM_OPS (&secocec_pm_ops)\n#else\n#define SECOCEC_PM_OPS NULL\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id secocec_acpi_match[] = {\n\t{\"CEC00001\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, secocec_acpi_match);\n#endif\n\nstatic struct platform_driver secocec_driver = {\n\t.driver = {\n\t\t   .name = SECOCEC_DEV_NAME,\n\t\t   .acpi_match_table = ACPI_PTR(secocec_acpi_match),\n\t\t   .pm = SECOCEC_PM_OPS,\n\t},\n\t.probe = secocec_probe,\n\t.remove_new = secocec_remove,\n};\n\nmodule_platform_driver(secocec_driver);\n\nMODULE_DESCRIPTION(\"SECO CEC X86 Driver\");\nMODULE_AUTHOR(\"Ettore Chimenti <ek5.chimenti@gmail.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}