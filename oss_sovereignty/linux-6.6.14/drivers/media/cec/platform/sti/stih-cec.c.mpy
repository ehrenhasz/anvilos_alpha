{
  "module_name": "stih-cec.c",
  "hash_id": "821589061716719e569cb8d845b3c7a5920304e4352001d6691de1e911bbdfb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/sti/stih-cec.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n#define CEC_NAME\t\"stih-cec\"\n\n \n#define CEC_CLK_DIV           0x0\n#define CEC_CTRL              0x4\n#define CEC_IRQ_CTRL          0x8\n#define CEC_STATUS            0xC\n#define CEC_EXT_STATUS        0x10\n#define CEC_TX_CTRL           0x14\n#define CEC_FREE_TIME_THRESH  0x18\n#define CEC_BIT_TOUT_THRESH   0x1C\n#define CEC_BIT_PULSE_THRESH  0x20\n#define CEC_DATA              0x24\n#define CEC_TX_ARRAY_CTRL     0x28\n#define CEC_CTRL2             0x2C\n#define CEC_TX_ERROR_STS      0x30\n#define CEC_ADDR_TABLE        0x34\n#define CEC_DATA_ARRAY_CTRL   0x38\n#define CEC_DATA_ARRAY_STATUS 0x3C\n#define CEC_TX_DATA_BASE      0x40\n#define CEC_TX_DATA_TOP       0x50\n#define CEC_TX_DATA_SIZE      0x1\n#define CEC_RX_DATA_BASE      0x54\n#define CEC_RX_DATA_TOP       0x64\n#define CEC_RX_DATA_SIZE      0x1\n\n \n#define CEC_LINE_INACTIVE_EN   BIT(0)\n#define CEC_AUTO_BUS_ERR_EN    BIT(1)\n#define CEC_STOP_ON_ARB_ERR_EN BIT(2)\n#define CEC_TX_REQ_WAIT_EN     BIT(3)\n\n \n#define CEC_TX_ARRAY_EN          BIT(0)\n#define CEC_RX_ARRAY_EN          BIT(1)\n#define CEC_TX_ARRAY_RESET       BIT(2)\n#define CEC_RX_ARRAY_RESET       BIT(3)\n#define CEC_TX_N_OF_BYTES_IRQ_EN BIT(4)\n#define CEC_TX_STOP_ON_NACK      BIT(7)\n\n \n#define CEC_TX_N_OF_BYTES  0x1F\n#define CEC_TX_START       BIT(5)\n#define CEC_TX_AUTO_SOM_EN BIT(6)\n#define CEC_TX_AUTO_EOM_EN BIT(7)\n\n \n#define CEC_TX_DONE_IRQ_EN   BIT(0)\n#define CEC_ERROR_IRQ_EN     BIT(2)\n#define CEC_RX_DONE_IRQ_EN   BIT(3)\n#define CEC_RX_SOM_IRQ_EN    BIT(4)\n#define CEC_RX_EOM_IRQ_EN    BIT(5)\n#define CEC_FREE_TIME_IRQ_EN BIT(6)\n#define CEC_PIN_STS_IRQ_EN   BIT(7)\n\n \n#define CEC_IN_FILTER_EN    BIT(0)\n#define CEC_PWR_SAVE_EN     BIT(1)\n#define CEC_EN              BIT(4)\n#define CEC_ACK_CTRL        BIT(5)\n#define CEC_RX_RESET_EN     BIT(6)\n#define CEC_IGNORE_RX_ERROR BIT(7)\n\n \n#define CEC_TX_DONE_STS       BIT(0)\n#define CEC_TX_ACK_GET_STS    BIT(1)\n#define CEC_ERROR_STS         BIT(2)\n#define CEC_RX_DONE_STS       BIT(3)\n#define CEC_RX_SOM_STS        BIT(4)\n#define CEC_RX_EOM_STS        BIT(5)\n#define CEC_FREE_TIME_IRQ_STS BIT(6)\n#define CEC_PIN_STS           BIT(7)\n#define CEC_SBIT_TOUT_STS     BIT(8)\n#define CEC_DBIT_TOUT_STS     BIT(9)\n#define CEC_LPULSE_ERROR_STS  BIT(10)\n#define CEC_HPULSE_ERROR_STS  BIT(11)\n#define CEC_TX_ERROR          BIT(12)\n#define CEC_TX_ARB_ERROR      BIT(13)\n#define CEC_RX_ERROR_MIN      BIT(14)\n#define CEC_RX_ERROR_MAX      BIT(15)\n\n \n#define CEC_PRESENT_INIT_SFT 7\n#define CEC_NEW_INIT_SFT     5\n#define CEC_RETRANSMIT_SFT   3\n\n \n#define CEC_SBIT_TOUT_47MS BIT(1)\n#define CEC_SBIT_TOUT_48MS (BIT(0) | BIT(1))\n#define CEC_SBIT_TOUT_50MS BIT(2)\n#define CEC_DBIT_TOUT_27MS BIT(0)\n#define CEC_DBIT_TOUT_28MS BIT(1)\n#define CEC_DBIT_TOUT_29MS (BIT(0) | BIT(1))\n\n \n#define CEC_BIT_LPULSE_03MS BIT(1)\n#define CEC_BIT_HPULSE_03MS BIT(3)\n\n \n#define CEC_RX_N_OF_BYTES                     0x1F\n#define CEC_TX_N_OF_BYTES_SENT                BIT(5)\n#define CEC_RX_OVERRUN                        BIT(6)\n\nstruct stih_cec {\n\tstruct cec_adapter\t*adap;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*regs;\n\tint\t\t\tirq;\n\tu32\t\t\tirq_status;\n\tstruct cec_notifier\t*notifier;\n};\n\nstatic int stih_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct stih_cec *cec = cec_get_drvdata(adap);\n\n\tif (enable) {\n\t\t \n\t\tunsigned long clk_freq = clk_get_rate(cec->clk);\n\t\tu32 cec_clk_div = clk_freq / 10000;\n\n\t\twritel(cec_clk_div, cec->regs + CEC_CLK_DIV);\n\n\t\t \n\t\twritel(CEC_SBIT_TOUT_47MS | (CEC_DBIT_TOUT_28MS << 4),\n\t\t       cec->regs + CEC_BIT_TOUT_THRESH);\n\n\t\t \n\t\twritel(CEC_BIT_LPULSE_03MS | CEC_BIT_HPULSE_03MS,\n\t\t       cec->regs + CEC_BIT_PULSE_THRESH);\n\n\t\t \n\t\twritel(BIT(5) | BIT(7), cec->regs + CEC_TX_CTRL);\n\n\t\t \n\t\twritel(CEC_TX_ARRAY_EN | CEC_RX_ARRAY_EN | CEC_TX_STOP_ON_NACK,\n\t\t       cec->regs + CEC_DATA_ARRAY_CTRL);\n\n\t\t \n\t\twritel(CEC_IN_FILTER_EN | CEC_EN | CEC_RX_RESET_EN,\n\t\t       cec->regs + CEC_CTRL);\n\n\t\t \n\t\twritel(0, cec->regs + CEC_ADDR_TABLE);\n\n\t\t \n\t\twritel(0x0, cec->regs + CEC_STATUS);\n\n\t\t \n\t\twritel(CEC_TX_DONE_IRQ_EN | CEC_RX_DONE_IRQ_EN |\n\t\t       CEC_RX_SOM_IRQ_EN | CEC_RX_EOM_IRQ_EN |\n\t\t       CEC_ERROR_IRQ_EN,\n\t\t       cec->regs + CEC_IRQ_CTRL);\n\n\t} else {\n\t\t \n\t\twritel(0, cec->regs + CEC_ADDR_TABLE);\n\n\t\t \n\t\twritel(0x0, cec->regs + CEC_STATUS);\n\n\t\t \n\t\twritel(0, cec->regs + CEC_IRQ_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int stih_cec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct stih_cec *cec = cec_get_drvdata(adap);\n\tu32 reg = readl(cec->regs + CEC_ADDR_TABLE);\n\n\treg |= 1 << logical_addr;\n\n\tif (logical_addr == CEC_LOG_ADDR_INVALID)\n\t\treg = 0;\n\n\twritel(reg, cec->regs + CEC_ADDR_TABLE);\n\n\treturn 0;\n}\n\nstatic int stih_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t  u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct stih_cec *cec = cec_get_drvdata(adap);\n\tint i;\n\n\t \n\tfor (i = 0; i < msg->len; i++)\n\t\twriteb(msg->msg[i], cec->regs + CEC_TX_DATA_BASE + i);\n\n\t \n\twritel(CEC_TX_AUTO_SOM_EN | CEC_TX_AUTO_EOM_EN | CEC_TX_START |\n\t       msg->len, cec->regs + CEC_TX_ARRAY_CTRL);\n\n\treturn 0;\n}\n\nstatic void stih_tx_done(struct stih_cec *cec, u32 status)\n{\n\tif (status & CEC_TX_ERROR) {\n\t\tcec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_ERROR);\n\t\treturn;\n\t}\n\n\tif (status & CEC_TX_ARB_ERROR) {\n\t\tcec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_ARB_LOST);\n\t\treturn;\n\t}\n\n\tif (!(status & CEC_TX_ACK_GET_STS)) {\n\t\tcec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_NACK);\n\t\treturn;\n\t}\n\n\tcec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_OK);\n}\n\nstatic void stih_rx_done(struct stih_cec *cec, u32 status)\n{\n\tstruct cec_msg msg = {};\n\tu8 i;\n\n\tif (status & CEC_RX_ERROR_MIN)\n\t\treturn;\n\n\tif (status & CEC_RX_ERROR_MAX)\n\t\treturn;\n\n\tmsg.len = readl(cec->regs + CEC_DATA_ARRAY_STATUS) & 0x1f;\n\n\tif (!msg.len)\n\t\treturn;\n\n\tif (msg.len > CEC_MAX_MSG_SIZE)\n\t\tmsg.len = CEC_MAX_MSG_SIZE;\n\n\tfor (i = 0; i < msg.len; i++)\n\t\tmsg.msg[i] = readl(cec->regs + CEC_RX_DATA_BASE + i);\n\n\tcec_received_msg(cec->adap, &msg);\n}\n\nstatic irqreturn_t stih_cec_irq_handler_thread(int irq, void *priv)\n{\n\tstruct stih_cec *cec = priv;\n\n\tif (cec->irq_status & CEC_TX_DONE_STS)\n\t\tstih_tx_done(cec, cec->irq_status);\n\n\tif (cec->irq_status & CEC_RX_DONE_STS)\n\t\tstih_rx_done(cec, cec->irq_status);\n\n\tcec->irq_status = 0;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stih_cec_irq_handler(int irq, void *priv)\n{\n\tstruct stih_cec *cec = priv;\n\n\tcec->irq_status = readl(cec->regs + CEC_STATUS);\n\twritel(cec->irq_status, cec->regs + CEC_STATUS);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic const struct cec_adap_ops sti_cec_adap_ops = {\n\t.adap_enable = stih_cec_adap_enable,\n\t.adap_log_addr = stih_cec_adap_log_addr,\n\t.adap_transmit = stih_cec_adap_transmit,\n};\n\nstatic int stih_cec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stih_cec *cec;\n\tstruct device *hdmi_dev;\n\tint ret;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(dev);\n\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tcec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tcec->dev = dev;\n\n\tcec->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cec->regs))\n\t\treturn PTR_ERR(cec->regs);\n\n\tcec->irq = platform_get_irq(pdev, 0);\n\tif (cec->irq < 0)\n\t\treturn cec->irq;\n\n\tret = devm_request_threaded_irq(dev, cec->irq, stih_cec_irq_handler,\n\t\t\t\t\tstih_cec_irq_handler_thread, 0,\n\t\t\t\t\tpdev->name, cec);\n\tif (ret)\n\t\treturn ret;\n\n\tcec->clk = devm_clk_get(dev, \"cec-clk\");\n\tif (IS_ERR(cec->clk)) {\n\t\tdev_err(dev, \"Cannot get cec clock\\n\");\n\t\treturn PTR_ERR(cec->clk);\n\t}\n\n\tcec->adap = cec_allocate_adapter(&sti_cec_adap_ops, cec, CEC_NAME,\n\t\t\t\t\t CEC_CAP_DEFAULTS |\n\t\t\t\t\t CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t CEC_MAX_LOG_ADDRS);\n\tret = PTR_ERR_OR_ZERO(cec->adap);\n\tif (ret)\n\t\treturn ret;\n\n\tcec->notifier = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t       cec->adap);\n\tif (!cec->notifier) {\n\t\tret = -ENOMEM;\n\t\tgoto err_delete_adapter;\n\t}\n\n\tret = cec_register_adapter(cec->adap, &pdev->dev);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tplatform_set_drvdata(pdev, cec);\n\treturn 0;\n\nerr_notifier:\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\nerr_delete_adapter:\n\tcec_delete_adapter(cec->adap);\n\treturn ret;\n}\n\nstatic void stih_cec_remove(struct platform_device *pdev)\n{\n\tstruct stih_cec *cec = platform_get_drvdata(pdev);\n\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\tcec_unregister_adapter(cec->adap);\n}\n\nstatic const struct of_device_id stih_cec_match[] = {\n\t{\n\t\t.compatible\t= \"st,stih-cec\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stih_cec_match);\n\nstatic struct platform_driver stih_cec_pdrv = {\n\t.probe\t= stih_cec_probe,\n\t.remove_new = stih_cec_remove,\n\t.driver = {\n\t\t.name\t\t= CEC_NAME,\n\t\t.of_match_table\t= stih_cec_match,\n\t},\n};\n\nmodule_platform_driver(stih_cec_pdrv);\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"STIH4xx CEC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}