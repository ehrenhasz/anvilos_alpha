{
  "module_name": "s5p_cec.c",
  "hash_id": "001a0c1b133bfaa3ab57648e2360479d4d30dbe352e0d503a4af847e5f1b0046",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/s5p/s5p_cec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n#include \"exynos_hdmi_cec.h\"\n#include \"regs-cec.h\"\n#include \"s5p_cec.h\"\n\n#define CEC_NAME\t\"s5p-cec\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nstatic int s5p_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tint ret;\n\tstruct s5p_cec_dev *cec = cec_get_drvdata(adap);\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(cec->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ts5p_cec_reset(cec);\n\n\t\ts5p_cec_set_divider(cec);\n\t\ts5p_cec_threshold(cec);\n\n\t\ts5p_cec_unmask_tx_interrupts(cec);\n\t\ts5p_cec_unmask_rx_interrupts(cec);\n\t\ts5p_cec_enable_rx(cec);\n\t} else {\n\t\ts5p_cec_mask_tx_interrupts(cec);\n\t\ts5p_cec_mask_rx_interrupts(cec);\n\t\tpm_runtime_put(cec->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int s5p_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct s5p_cec_dev *cec = cec_get_drvdata(adap);\n\n\ts5p_cec_set_addr(cec, addr);\n\treturn 0;\n}\n\nstatic int s5p_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct s5p_cec_dev *cec = cec_get_drvdata(adap);\n\n\t \n\ts5p_cec_copy_packet(cec, msg->msg, msg->len, max(1, attempts - 1));\n\treturn 0;\n}\n\nstatic irqreturn_t s5p_cec_irq_handler(int irq, void *priv)\n{\n\tstruct s5p_cec_dev *cec = priv;\n\tu32 status = 0;\n\n\tstatus = s5p_cec_get_status(cec);\n\n\tdev_dbg(cec->dev, \"irq received\\n\");\n\n\tif (status & CEC_STATUS_TX_DONE) {\n\t\tif (status & CEC_STATUS_TX_NACK) {\n\t\t\tdev_dbg(cec->dev, \"CEC_STATUS_TX_NACK set\\n\");\n\t\t\tcec->tx = STATE_NACK;\n\t\t} else if (status & CEC_STATUS_TX_ERROR) {\n\t\t\tdev_dbg(cec->dev, \"CEC_STATUS_TX_ERROR set\\n\");\n\t\t\tcec->tx = STATE_ERROR;\n\t\t} else {\n\t\t\tdev_dbg(cec->dev, \"CEC_STATUS_TX_DONE\\n\");\n\t\t\tcec->tx = STATE_DONE;\n\t\t}\n\t\ts5p_clr_pending_tx(cec);\n\t}\n\n\tif (status & CEC_STATUS_RX_DONE) {\n\t\tif (status & CEC_STATUS_RX_ERROR) {\n\t\t\tdev_dbg(cec->dev, \"CEC_STATUS_RX_ERROR set\\n\");\n\t\t\ts5p_cec_rx_reset(cec);\n\t\t\ts5p_cec_enable_rx(cec);\n\t\t} else {\n\t\t\tdev_dbg(cec->dev, \"CEC_STATUS_RX_DONE set\\n\");\n\t\t\tif (cec->rx != STATE_IDLE)\n\t\t\t\tdev_dbg(cec->dev, \"Buffer overrun (worker did not process previous message)\\n\");\n\t\t\tcec->rx = STATE_BUSY;\n\t\t\tcec->msg.len = status >> 24;\n\t\t\tif (cec->msg.len > CEC_MAX_MSG_SIZE)\n\t\t\t\tcec->msg.len = CEC_MAX_MSG_SIZE;\n\t\t\tcec->msg.rx_status = CEC_RX_STATUS_OK;\n\t\t\ts5p_cec_get_rx_buf(cec, cec->msg.len,\n\t\t\t\t\tcec->msg.msg);\n\t\t\tcec->rx = STATE_DONE;\n\t\t\ts5p_cec_enable_rx(cec);\n\t\t}\n\t\t \n\t\ts5p_clr_pending_rx(cec);\n\t}\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t s5p_cec_irq_handler_thread(int irq, void *priv)\n{\n\tstruct s5p_cec_dev *cec = priv;\n\n\tdev_dbg(cec->dev, \"irq processing thread\\n\");\n\tswitch (cec->tx) {\n\tcase STATE_DONE:\n\t\tcec_transmit_done(cec->adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\n\t\tcec->tx = STATE_IDLE;\n\t\tbreak;\n\tcase STATE_NACK:\n\t\tcec_transmit_done(cec->adap,\n\t\t\tCEC_TX_STATUS_MAX_RETRIES | CEC_TX_STATUS_NACK,\n\t\t\t0, 1, 0, 0);\n\t\tcec->tx = STATE_IDLE;\n\t\tbreak;\n\tcase STATE_ERROR:\n\t\tcec_transmit_done(cec->adap,\n\t\t\tCEC_TX_STATUS_MAX_RETRIES | CEC_TX_STATUS_ERROR,\n\t\t\t0, 0, 0, 1);\n\t\tcec->tx = STATE_IDLE;\n\t\tbreak;\n\tcase STATE_BUSY:\n\t\tdev_err(cec->dev, \"state set to busy, this should not occur here\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (cec->rx) {\n\tcase STATE_DONE:\n\t\tcec_received_msg(cec->adap, &cec->msg);\n\t\tcec->rx = STATE_IDLE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct cec_adap_ops s5p_cec_adap_ops = {\n\t.adap_enable = s5p_cec_adap_enable,\n\t.adap_log_addr = s5p_cec_adap_log_addr,\n\t.adap_transmit = s5p_cec_adap_transmit,\n};\n\nstatic int s5p_cec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hdmi_dev;\n\tstruct s5p_cec_dev *cec;\n\tbool needs_hpd = of_property_read_bool(pdev->dev.of_node, \"needs-hpd\");\n\tint ret;\n\n\thdmi_dev = cec_notifier_parse_hdmi_phandle(dev);\n\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tcec = devm_kzalloc(&pdev->dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tcec->dev = dev;\n\n\tcec->irq = platform_get_irq(pdev, 0);\n\tif (cec->irq < 0)\n\t\treturn cec->irq;\n\n\tret = devm_request_threaded_irq(dev, cec->irq, s5p_cec_irq_handler,\n\t\ts5p_cec_irq_handler_thread, 0, pdev->name, cec);\n\tif (ret)\n\t\treturn ret;\n\n\tcec->clk = devm_clk_get(dev, \"hdmicec\");\n\tif (IS_ERR(cec->clk))\n\t\treturn PTR_ERR(cec->clk);\n\n\tcec->pmu = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t \"samsung,syscon-phandle\");\n\tif (IS_ERR(cec->pmu))\n\t\treturn -EPROBE_DEFER;\n\n\tcec->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cec->reg))\n\t\treturn PTR_ERR(cec->reg);\n\n\tcec->adap = cec_allocate_adapter(&s5p_cec_adap_ops, cec, CEC_NAME,\n\t\tCEC_CAP_DEFAULTS | (needs_hpd ? CEC_CAP_NEEDS_HPD : 0) |\n\t\tCEC_CAP_CONNECTOR_INFO, 1);\n\tret = PTR_ERR_OR_ZERO(cec->adap);\n\tif (ret)\n\t\treturn ret;\n\n\tcec->notifier = cec_notifier_cec_adap_register(hdmi_dev, NULL,\n\t\t\t\t\t\t       cec->adap);\n\tif (!cec->notifier) {\n\t\tret = -ENOMEM;\n\t\tgoto err_delete_adapter;\n\t}\n\n\tret = cec_register_adapter(cec->adap, &pdev->dev);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\tplatform_set_drvdata(pdev, cec);\n\tpm_runtime_enable(dev);\n\n\tdev_dbg(dev, \"successfully probed\\n\");\n\treturn 0;\n\nerr_notifier:\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\nerr_delete_adapter:\n\tcec_delete_adapter(cec->adap);\n\treturn ret;\n}\n\nstatic void s5p_cec_remove(struct platform_device *pdev)\n{\n\tstruct s5p_cec_dev *cec = platform_get_drvdata(pdev);\n\n\tcec_notifier_cec_adap_unregister(cec->notifier, cec->adap);\n\tcec_unregister_adapter(cec->adap);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused s5p_cec_runtime_suspend(struct device *dev)\n{\n\tstruct s5p_cec_dev *cec = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(cec->clk);\n\treturn 0;\n}\n\nstatic int __maybe_unused s5p_cec_runtime_resume(struct device *dev)\n{\n\tstruct s5p_cec_dev *cec = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(cec->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops s5p_cec_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(s5p_cec_runtime_suspend, s5p_cec_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id s5p_cec_match[] = {\n\t{\n\t\t.compatible\t= \"samsung,s5p-cec\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s5p_cec_match);\n\nstatic struct platform_driver s5p_cec_pdrv = {\n\t.probe\t= s5p_cec_probe,\n\t.remove_new = s5p_cec_remove,\n\t.driver\t= {\n\t\t.name\t\t= CEC_NAME,\n\t\t.of_match_table\t= s5p_cec_match,\n\t\t.pm\t\t= &s5p_cec_pm_ops,\n\t},\n};\n\nmodule_platform_driver(s5p_cec_pdrv);\n\nMODULE_AUTHOR(\"Kamil Debski <kamil@wypas.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Samsung S5P CEC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}