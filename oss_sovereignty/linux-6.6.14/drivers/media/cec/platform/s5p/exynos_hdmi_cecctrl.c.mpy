{
  "module_name": "exynos_hdmi_cecctrl.c",
  "hash_id": "3a4b22fbb5a2f7fd01c19ee862cff8afc4aaaca8982d2193cad8dec743b9d5a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/s5p/exynos_hdmi_cecctrl.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/device.h>\n\n#include \"exynos_hdmi_cec.h\"\n#include \"regs-cec.h\"\n\n#define S5P_HDMI_FIN\t\t\t24000000\n#define CEC_DIV_RATIO\t\t\t320000\n\n#define CEC_MESSAGE_BROADCAST_MASK\t0x0F\n#define CEC_MESSAGE_BROADCAST\t\t0x0F\n#define CEC_FILTER_THRESHOLD\t\t0x15\n\nvoid s5p_cec_set_divider(struct s5p_cec_dev *cec)\n{\n\tu32 div_ratio, div_val;\n\tunsigned int reg;\n\n\tdiv_ratio  = S5P_HDMI_FIN / CEC_DIV_RATIO - 1;\n\n\tif (regmap_read(cec->pmu, EXYNOS_HDMI_PHY_CONTROL, &reg)) {\n\t\tdev_err(cec->dev, \"failed to read phy control\\n\");\n\t\treturn;\n\t}\n\n\treg = (reg & ~(0x3FF << 16)) | (div_ratio << 16);\n\n\tif (regmap_write(cec->pmu, EXYNOS_HDMI_PHY_CONTROL, reg)) {\n\t\tdev_err(cec->dev, \"failed to write phy control\\n\");\n\t\treturn;\n\t}\n\n\tdiv_val = CEC_DIV_RATIO * 0.00005 - 1;\n\n\twriteb(0x0, cec->reg + S5P_CEC_DIVISOR_3);\n\twriteb(0x0, cec->reg + S5P_CEC_DIVISOR_2);\n\twriteb(0x0, cec->reg + S5P_CEC_DIVISOR_1);\n\twriteb(div_val, cec->reg + S5P_CEC_DIVISOR_0);\n}\n\nvoid s5p_cec_enable_rx(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\treg = readb(cec->reg + S5P_CEC_RX_CTRL);\n\treg |= S5P_CEC_RX_CTRL_ENABLE;\n\twriteb(reg, cec->reg + S5P_CEC_RX_CTRL);\n}\n\nvoid s5p_cec_mask_rx_interrupts(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\treg = readb(cec->reg + S5P_CEC_IRQ_MASK);\n\treg |= S5P_CEC_IRQ_RX_DONE;\n\treg |= S5P_CEC_IRQ_RX_ERROR;\n\twriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\n}\n\nvoid s5p_cec_unmask_rx_interrupts(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\treg = readb(cec->reg + S5P_CEC_IRQ_MASK);\n\treg &= ~S5P_CEC_IRQ_RX_DONE;\n\treg &= ~S5P_CEC_IRQ_RX_ERROR;\n\twriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\n}\n\nvoid s5p_cec_mask_tx_interrupts(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\treg = readb(cec->reg + S5P_CEC_IRQ_MASK);\n\treg |= S5P_CEC_IRQ_TX_DONE;\n\treg |= S5P_CEC_IRQ_TX_ERROR;\n\twriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\n}\n\nvoid s5p_cec_unmask_tx_interrupts(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\treg = readb(cec->reg + S5P_CEC_IRQ_MASK);\n\treg &= ~S5P_CEC_IRQ_TX_DONE;\n\treg &= ~S5P_CEC_IRQ_TX_ERROR;\n\twriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\n}\n\nvoid s5p_cec_reset(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\twriteb(S5P_CEC_RX_CTRL_RESET, cec->reg + S5P_CEC_RX_CTRL);\n\twriteb(S5P_CEC_TX_CTRL_RESET, cec->reg + S5P_CEC_TX_CTRL);\n\n\treg = readb(cec->reg + 0xc4);\n\treg &= ~0x1;\n\twriteb(reg, cec->reg + 0xc4);\n}\n\nvoid s5p_cec_tx_reset(struct s5p_cec_dev *cec)\n{\n\twriteb(S5P_CEC_TX_CTRL_RESET, cec->reg + S5P_CEC_TX_CTRL);\n}\n\nvoid s5p_cec_rx_reset(struct s5p_cec_dev *cec)\n{\n\tu8 reg;\n\n\twriteb(S5P_CEC_RX_CTRL_RESET, cec->reg + S5P_CEC_RX_CTRL);\n\n\treg = readb(cec->reg + 0xc4);\n\treg &= ~0x1;\n\twriteb(reg, cec->reg + 0xc4);\n}\n\nvoid s5p_cec_threshold(struct s5p_cec_dev *cec)\n{\n\twriteb(CEC_FILTER_THRESHOLD, cec->reg + S5P_CEC_RX_FILTER_TH);\n\twriteb(0, cec->reg + S5P_CEC_RX_FILTER_CTRL);\n}\n\nvoid s5p_cec_copy_packet(struct s5p_cec_dev *cec, char *data,\n\t\t\t size_t count, u8 retries)\n{\n\tint i = 0;\n\tu8 reg;\n\n\twhile (i < count) {\n\t\twriteb(data[i], cec->reg + (S5P_CEC_TX_BUFF0 + (i * 4)));\n\t\ti++;\n\t}\n\n\twriteb(count, cec->reg + S5P_CEC_TX_BYTES);\n\treg = readb(cec->reg + S5P_CEC_TX_CTRL);\n\treg |= S5P_CEC_TX_CTRL_START;\n\treg &= ~0x70;\n\treg |= retries << 4;\n\n\tif ((data[0] & CEC_MESSAGE_BROADCAST_MASK) == CEC_MESSAGE_BROADCAST) {\n\t\tdev_dbg(cec->dev, \"Broadcast\");\n\t\treg |= S5P_CEC_TX_CTRL_BCAST;\n\t} else {\n\t\tdev_dbg(cec->dev, \"No Broadcast\");\n\t\treg &= ~S5P_CEC_TX_CTRL_BCAST;\n\t}\n\n\twriteb(reg, cec->reg + S5P_CEC_TX_CTRL);\n\tdev_dbg(cec->dev, \"cec-tx: cec count (%zu): %*ph\", count,\n\t\t(int)count, data);\n}\n\nvoid s5p_cec_set_addr(struct s5p_cec_dev *cec, u32 addr)\n{\n\twriteb(addr & 0x0F, cec->reg + S5P_CEC_LOGIC_ADDR);\n}\n\nu32 s5p_cec_get_status(struct s5p_cec_dev *cec)\n{\n\tu32 status = 0;\n\n\tstatus = readb(cec->reg + S5P_CEC_STATUS_0) & 0xf;\n\tstatus |= (readb(cec->reg + S5P_CEC_TX_STAT1) & 0xf) << 4;\n\tstatus |= readb(cec->reg + S5P_CEC_STATUS_1) << 8;\n\tstatus |= readb(cec->reg + S5P_CEC_STATUS_2) << 16;\n\tstatus |= readb(cec->reg + S5P_CEC_STATUS_3) << 24;\n\n\tdev_dbg(cec->dev, \"status = 0x%x!\\n\", status);\n\n\treturn status;\n}\n\nvoid s5p_clr_pending_tx(struct s5p_cec_dev *cec)\n{\n\twriteb(S5P_CEC_IRQ_TX_DONE | S5P_CEC_IRQ_TX_ERROR,\n\t       cec->reg + S5P_CEC_IRQ_CLEAR);\n}\n\nvoid s5p_clr_pending_rx(struct s5p_cec_dev *cec)\n{\n\twriteb(S5P_CEC_IRQ_RX_DONE | S5P_CEC_IRQ_RX_ERROR,\n\t       cec->reg + S5P_CEC_IRQ_CLEAR);\n}\n\nvoid s5p_cec_get_rx_buf(struct s5p_cec_dev *cec, u32 size, u8 *buffer)\n{\n\tu32 i = 0;\n\tchar debug[40];\n\n\twhile (i < size) {\n\t\tbuffer[i] = readb(cec->reg + S5P_CEC_RX_BUFF0 + (i * 4));\n\t\tsprintf(debug + i * 2, \"%02x \", buffer[i]);\n\t\ti++;\n\t}\n\tdev_dbg(cec->dev, \"cec-rx: cec size(%d): %s\", size, debug);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}