{
  "module_name": "cros-ec-cec.c",
  "hash_id": "69c6bf7a03bfdb8a97f46bbb3d37988737eb0169fb5845547ebccf4d2ebef670",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/cec/platform/cros-ec/cros-ec-cec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n#include <linux/cec.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\n#define DRV_NAME\t\"cros-ec-cec\"\n\n \nstruct cros_ec_cec {\n\tstruct cros_ec_device *cros_ec;\n\tstruct notifier_block notifier;\n\tstruct cec_adapter *adap;\n\tstruct cec_notifier *notify;\n\tstruct cec_msg rx_msg;\n};\n\nstatic void handle_cec_message(struct cros_ec_cec *cros_ec_cec)\n{\n\tstruct cros_ec_device *cros_ec = cros_ec_cec->cros_ec;\n\tuint8_t *cec_message = cros_ec->event_data.data.cec_message;\n\tunsigned int len = cros_ec->event_size;\n\n\tif (len > CEC_MAX_MSG_SIZE)\n\t\tlen = CEC_MAX_MSG_SIZE;\n\tcros_ec_cec->rx_msg.len = len;\n\tmemcpy(cros_ec_cec->rx_msg.msg, cec_message, len);\n\n\tcec_received_msg(cros_ec_cec->adap, &cros_ec_cec->rx_msg);\n}\n\nstatic void handle_cec_event(struct cros_ec_cec *cros_ec_cec)\n{\n\tstruct cros_ec_device *cros_ec = cros_ec_cec->cros_ec;\n\tuint32_t events = cros_ec->event_data.data.cec_events;\n\n\tif (events & EC_MKBP_CEC_SEND_OK)\n\t\tcec_transmit_attempt_done(cros_ec_cec->adap,\n\t\t\t\t\t  CEC_TX_STATUS_OK);\n\n\t \n\tif (events & EC_MKBP_CEC_SEND_FAILED)\n\t\tcec_transmit_attempt_done(cros_ec_cec->adap,\n\t\t\t\t\t  CEC_TX_STATUS_MAX_RETRIES |\n\t\t\t\t\t  CEC_TX_STATUS_NACK);\n}\n\nstatic int cros_ec_cec_event(struct notifier_block *nb,\n\t\t\t     unsigned long queued_during_suspend,\n\t\t\t     void *_notify)\n{\n\tstruct cros_ec_cec *cros_ec_cec;\n\tstruct cros_ec_device *cros_ec;\n\n\tcros_ec_cec = container_of(nb, struct cros_ec_cec, notifier);\n\tcros_ec = cros_ec_cec->cros_ec;\n\n\tif (cros_ec->event_data.event_type == EC_MKBP_EVENT_CEC_EVENT) {\n\t\thandle_cec_event(cros_ec_cec);\n\t\treturn NOTIFY_OK;\n\t}\n\n\tif (cros_ec->event_data.event_type == EC_MKBP_EVENT_CEC_MESSAGE) {\n\t\thandle_cec_message(cros_ec_cec);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int cros_ec_cec_set_log_addr(struct cec_adapter *adap, u8 logical_addr)\n{\n\tstruct cros_ec_cec *cros_ec_cec = adap->priv;\n\tstruct cros_ec_device *cros_ec = cros_ec_cec->cros_ec;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_params_cec_set data;\n\t} __packed msg = {};\n\tint ret;\n\n\tmsg.msg.command = EC_CMD_CEC_SET;\n\tmsg.msg.outsize = sizeof(msg.data);\n\tmsg.data.cmd = CEC_CMD_LOGICAL_ADDRESS;\n\tmsg.data.val = logical_addr;\n\n\tret = cros_ec_cmd_xfer_status(cros_ec, &msg.msg);\n\tif (ret < 0) {\n\t\tdev_err(cros_ec->dev,\n\t\t\t\"error setting CEC logical address on EC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_cec_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\tu32 signal_free_time, struct cec_msg *cec_msg)\n{\n\tstruct cros_ec_cec *cros_ec_cec = adap->priv;\n\tstruct cros_ec_device *cros_ec = cros_ec_cec->cros_ec;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_params_cec_write data;\n\t} __packed msg = {};\n\tint ret;\n\n\tmsg.msg.command = EC_CMD_CEC_WRITE_MSG;\n\tmsg.msg.outsize = cec_msg->len;\n\tmemcpy(msg.data.msg, cec_msg->msg, cec_msg->len);\n\n\tret = cros_ec_cmd_xfer_status(cros_ec, &msg.msg);\n\tif (ret < 0) {\n\t\tdev_err(cros_ec->dev,\n\t\t\t\"error writing CEC msg on EC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct cros_ec_cec *cros_ec_cec = adap->priv;\n\tstruct cros_ec_device *cros_ec = cros_ec_cec->cros_ec;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_params_cec_set data;\n\t} __packed msg = {};\n\tint ret;\n\n\tmsg.msg.command = EC_CMD_CEC_SET;\n\tmsg.msg.outsize = sizeof(msg.data);\n\tmsg.data.cmd = CEC_CMD_ENABLE;\n\tmsg.data.val = enable;\n\n\tret = cros_ec_cmd_xfer_status(cros_ec, &msg.msg);\n\tif (ret < 0) {\n\t\tdev_err(cros_ec->dev,\n\t\t\t\"error %sabling CEC on EC: %d\\n\",\n\t\t\t(enable ? \"en\" : \"dis\"), ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops cros_ec_cec_ops = {\n\t.adap_enable = cros_ec_cec_adap_enable,\n\t.adap_log_addr = cros_ec_cec_set_log_addr,\n\t.adap_transmit = cros_ec_cec_transmit,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_cec_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct cros_ec_cec *cros_ec_cec = dev_get_drvdata(&pdev->dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(cros_ec_cec->cros_ec->irq);\n\n\treturn 0;\n}\n\nstatic int cros_ec_cec_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct cros_ec_cec *cros_ec_cec = dev_get_drvdata(&pdev->dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(cros_ec_cec->cros_ec->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_cec_pm_ops,\n\tcros_ec_cec_suspend, cros_ec_cec_resume);\n\n#if IS_ENABLED(CONFIG_PCI) && IS_ENABLED(CONFIG_DMI)\n\n \n\nstruct cec_dmi_match {\n\tconst char *sys_vendor;\n\tconst char *product_name;\n\tconst char *devname;\n\tconst char *conn;\n};\n\nstatic const struct cec_dmi_match cec_dmi_match_table[] = {\n\t \n\t{ \"Google\", \"Fizz\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Brask\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Moli\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Kinox\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Kuldax\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Aurash\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Gladios\", \"0000:00:02.0\", \"Port B\" },\n\t \n\t{ \"Google\", \"Lisbon\", \"0000:00:02.0\", \"Port B\" },\n};\n\nstatic struct device *cros_ec_cec_find_hdmi_dev(struct device *dev,\n\t\t\t\t\t\tconst char **conn)\n{\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(cec_dmi_match_table) ; ++i) {\n\t\tconst struct cec_dmi_match *m = &cec_dmi_match_table[i];\n\n\t\tif (dmi_match(DMI_SYS_VENDOR, m->sys_vendor) &&\n\t\t    dmi_match(DMI_PRODUCT_NAME, m->product_name)) {\n\t\t\tstruct device *d;\n\n\t\t\t \n\t\t\td = bus_find_device_by_name(&pci_bus_type, NULL,\n\t\t\t\t\t\t    m->devname);\n\t\t\tif (!d)\n\t\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t\tput_device(d);\n\t\t\t*conn = m->conn;\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t \n\tdev_warn(dev, \"CEC notifier not configured for this hardware\\n\");\n\n\treturn ERR_PTR(-ENODEV);\n}\n\n#else\n\nstatic struct device *cros_ec_cec_find_hdmi_dev(struct device *dev,\n\t\t\t\t\t\tconst char **conn)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\n#endif\n\nstatic int cros_ec_cec_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct cros_ec_device *cros_ec = ec_dev->ec_dev;\n\tstruct cros_ec_cec *cros_ec_cec;\n\tstruct device *hdmi_dev;\n\tconst char *conn = NULL;\n\tint ret;\n\n\thdmi_dev = cros_ec_cec_find_hdmi_dev(&pdev->dev, &conn);\n\tif (IS_ERR(hdmi_dev))\n\t\treturn PTR_ERR(hdmi_dev);\n\n\tcros_ec_cec = devm_kzalloc(&pdev->dev, sizeof(*cros_ec_cec),\n\t\t\t\t   GFP_KERNEL);\n\tif (!cros_ec_cec)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, cros_ec_cec);\n\tcros_ec_cec->cros_ec = cros_ec;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tcros_ec_cec->adap = cec_allocate_adapter(&cros_ec_cec_ops, cros_ec_cec,\n\t\t\t\t\t\t DRV_NAME,\n\t\t\t\t\t\t CEC_CAP_DEFAULTS |\n\t\t\t\t\t\t CEC_CAP_CONNECTOR_INFO, 1);\n\tif (IS_ERR(cros_ec_cec->adap))\n\t\treturn PTR_ERR(cros_ec_cec->adap);\n\n\tcros_ec_cec->notify = cec_notifier_cec_adap_register(hdmi_dev, conn,\n\t\t\t\t\t\t\t     cros_ec_cec->adap);\n\tif (!cros_ec_cec->notify) {\n\t\tret = -ENOMEM;\n\t\tgoto out_probe_adapter;\n\t}\n\n\t \n\tcros_ec_cec->notifier.notifier_call = cros_ec_cec_event;\n\tret = blocking_notifier_chain_register(&cros_ec->event_notifier,\n\t\t\t\t\t       &cros_ec_cec->notifier);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register notifier\\n\");\n\t\tgoto out_probe_notify;\n\t}\n\n\tret = cec_register_adapter(cros_ec_cec->adap, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto out_probe_notify;\n\n\treturn 0;\n\nout_probe_notify:\n\tcec_notifier_cec_adap_unregister(cros_ec_cec->notify,\n\t\t\t\t\t cros_ec_cec->adap);\nout_probe_adapter:\n\tcec_delete_adapter(cros_ec_cec->adap);\n\treturn ret;\n}\n\nstatic void cros_ec_cec_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_cec *cros_ec_cec = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tret = blocking_notifier_chain_unregister(\n\t\t\t&cros_ec_cec->cros_ec->event_notifier,\n\t\t\t&cros_ec_cec->notifier);\n\tif (ret)\n\t\tdev_err(dev, \"failed to unregister notifier\\n\");\n\n\tcec_notifier_cec_adap_unregister(cros_ec_cec->notify,\n\t\t\t\t\t cros_ec_cec->adap);\n\tcec_unregister_adapter(cros_ec_cec->adap);\n}\n\nstatic struct platform_driver cros_ec_cec_driver = {\n\t.probe = cros_ec_cec_probe,\n\t.remove_new = cros_ec_cec_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_ec_cec_pm_ops,\n\t},\n};\n\nmodule_platform_driver(cros_ec_cec_driver);\n\nMODULE_DESCRIPTION(\"CEC driver for ChromeOS ECs\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}