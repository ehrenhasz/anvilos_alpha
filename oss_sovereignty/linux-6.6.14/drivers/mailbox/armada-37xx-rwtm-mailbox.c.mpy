{
  "module_name": "armada-37xx-rwtm-mailbox.c",
  "hash_id": "fd65f123179c1cd256c27499974e2815a33e42c47836de3dfda9098a32b4fe85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/armada-37xx-rwtm-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/armada-37xx-rwtm-mailbox.h>\n\n#define DRIVER_NAME\t\"armada-37xx-rwtm-mailbox\"\n\n \n#define RWTM_MBOX_PARAM(i)\t\t(0x0 + ((i) << 2))\n#define RWTM_MBOX_COMMAND\t\t0x40\n#define RWTM_MBOX_RETURN_STATUS\t\t0x80\n#define RWTM_MBOX_STATUS(i)\t\t(0x84 + ((i) << 2))\n#define RWTM_MBOX_FIFO_STATUS\t\t0xc4\n#define FIFO_STS_RDY\t\t\t0x100\n#define FIFO_STS_CNTR_MASK\t\t0x7\n#define FIFO_STS_CNTR_MAX\t\t4\n\n#define RWTM_HOST_INT_RESET\t\t0xc8\n#define RWTM_HOST_INT_MASK\t\t0xcc\n#define SP_CMD_COMPLETE\t\t\tBIT(0)\n#define SP_CMD_QUEUE_FULL_ACCESS\tBIT(17)\n#define SP_CMD_QUEUE_FULL\t\tBIT(18)\n\nstruct a37xx_mbox {\n\tstruct device *dev;\n\tstruct mbox_controller controller;\n\tvoid __iomem *base;\n\tint irq;\n};\n\nstatic void a37xx_mbox_receive(struct mbox_chan *chan)\n{\n\tstruct a37xx_mbox *mbox = chan->con_priv;\n\tstruct armada_37xx_rwtm_rx_msg rx_msg;\n\tint i;\n\n\trx_msg.retval = readl(mbox->base + RWTM_MBOX_RETURN_STATUS);\n\tfor (i = 0; i < 16; ++i)\n\t\trx_msg.status[i] = readl(mbox->base + RWTM_MBOX_STATUS(i));\n\n\tmbox_chan_received_data(chan, &rx_msg);\n}\n\nstatic irqreturn_t a37xx_mbox_irq_handler(int irq, void *data)\n{\n\tstruct mbox_chan *chan = data;\n\tstruct a37xx_mbox *mbox = chan->con_priv;\n\tu32 reg;\n\n\treg = readl(mbox->base + RWTM_HOST_INT_RESET);\n\n\tif (reg & SP_CMD_COMPLETE)\n\t\ta37xx_mbox_receive(chan);\n\n\tif (reg & (SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL))\n\t\tdev_err(mbox->dev, \"Secure processor command queue full\\n\");\n\n\twritel(reg, mbox->base + RWTM_HOST_INT_RESET);\n\tif (reg)\n\t\tmbox_chan_txdone(chan, 0);\n\n\treturn reg ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int a37xx_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct a37xx_mbox *mbox = chan->con_priv;\n\tstruct armada_37xx_rwtm_tx_msg *msg = data;\n\tint i;\n\tu32 reg;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\treg = readl(mbox->base + RWTM_MBOX_FIFO_STATUS);\n\tif (!(reg & FIFO_STS_RDY))\n\t\tdev_warn(mbox->dev, \"Secure processor not ready\\n\");\n\n\tif ((reg & FIFO_STS_CNTR_MASK) >= FIFO_STS_CNTR_MAX) {\n\t\tdev_err(mbox->dev, \"Secure processor command queue full\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < 16; ++i)\n\t\twritel(msg->args[i], mbox->base + RWTM_MBOX_PARAM(i));\n\twritel(msg->command, mbox->base + RWTM_MBOX_COMMAND);\n\n\treturn 0;\n}\n\nstatic int a37xx_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct a37xx_mbox *mbox = chan->con_priv;\n\tu32 reg;\n\tint ret;\n\n\tret = devm_request_irq(mbox->dev, mbox->irq, a37xx_mbox_irq_handler, 0,\n\t\t\t       DRIVER_NAME, chan);\n\tif (ret < 0) {\n\t\tdev_err(mbox->dev, \"Cannot request irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg = readl(mbox->base + RWTM_HOST_INT_MASK);\n\treg &= ~(SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL);\n\twritel(reg, mbox->base + RWTM_HOST_INT_MASK);\n\n\treturn 0;\n}\n\nstatic void a37xx_mbox_shutdown(struct mbox_chan *chan)\n{\n\tu32 reg;\n\tstruct a37xx_mbox *mbox = chan->con_priv;\n\n\t \n\treg = readl(mbox->base + RWTM_HOST_INT_MASK);\n\treg |= SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL;\n\twritel(reg, mbox->base + RWTM_HOST_INT_MASK);\n\n\tdevm_free_irq(mbox->dev, mbox->irq, chan);\n}\n\nstatic const struct mbox_chan_ops a37xx_mbox_ops = {\n\t.send_data\t= a37xx_mbox_send_data,\n\t.startup\t= a37xx_mbox_startup,\n\t.shutdown\t= a37xx_mbox_shutdown,\n};\n\nstatic int armada_37xx_mbox_probe(struct platform_device *pdev)\n{\n\tstruct a37xx_mbox *mbox;\n\tstruct mbox_chan *chans;\n\tint ret;\n\n\tmbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\t \n\tchans = devm_kzalloc(&pdev->dev, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tmbox->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->base))\n\t\treturn PTR_ERR(mbox->base);\n\n\tmbox->irq = platform_get_irq(pdev, 0);\n\tif (mbox->irq < 0)\n\t\treturn mbox->irq;\n\n\tmbox->dev = &pdev->dev;\n\n\t \n\tchans[0].con_priv = mbox;\n\tmbox->controller.dev = mbox->dev;\n\tmbox->controller.num_chans = 1;\n\tmbox->controller.chans = chans;\n\tmbox->controller.ops = &a37xx_mbox_ops;\n\tmbox->controller.txdone_irq = true;\n\n\tret = devm_mbox_controller_register(mbox->dev, &mbox->controller);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register mailbox controller\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, mbox);\n\treturn ret;\n}\n\n\nstatic const struct of_device_id armada_37xx_mbox_match[] = {\n\t{ .compatible = \"marvell,armada-3700-rwtm-mailbox\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, armada_37xx_mbox_match);\n\nstatic struct platform_driver armada_37xx_mbox_driver = {\n\t.probe\t= armada_37xx_mbox_probe,\n\t.driver\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= armada_37xx_mbox_match,\n\t},\n};\n\nmodule_platform_driver(armada_37xx_mbox_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"rWTM BIU Mailbox driver for Armada 37xx\");\nMODULE_AUTHOR(\"Marek Behun <kabel@kernel.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}