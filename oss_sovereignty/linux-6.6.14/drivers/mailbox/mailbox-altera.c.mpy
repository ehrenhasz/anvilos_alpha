{
  "module_name": "mailbox-altera.c",
  "hash_id": "249a56103e9e9dacc6cd0c1d8858261591ca79dfee5214ffdd194b9d8a5cddc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mailbox-altera.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_NAME\t\"altera-mailbox\"\n\n#define MAILBOX_CMD_REG\t\t\t0x00\n#define MAILBOX_PTR_REG\t\t\t0x04\n#define MAILBOX_STS_REG\t\t\t0x08\n#define MAILBOX_INTMASK_REG\t\t0x0C\n\n#define INT_PENDING_MSK\t\t\t0x1\n#define INT_SPACE_MSK\t\t\t0x2\n\n#define STS_PENDING_MSK\t\t\t0x1\n#define STS_FULL_MSK\t\t\t0x2\n#define STS_FULL_OFT\t\t\t0x1\n\n#define MBOX_PENDING(status)\t(((status) & STS_PENDING_MSK))\n#define MBOX_FULL(status)\t(((status) & STS_FULL_MSK) >> STS_FULL_OFT)\n\nenum altera_mbox_msg {\n\tMBOX_CMD = 0,\n\tMBOX_PTR,\n};\n\n#define MBOX_POLLING_MS\t\t5\t \n\nstruct altera_mbox {\n\tbool is_sender;\t\t \n\tbool intr_mode;\n\tint irq;\n\tvoid __iomem *mbox_base;\n\tstruct device *dev;\n\tstruct mbox_controller controller;\n\n\t \n\tstruct timer_list rxpoll_timer;\n\tstruct mbox_chan *chan;\n};\n\nstatic struct altera_mbox *mbox_chan_to_altera_mbox(struct mbox_chan *chan)\n{\n\tif (!chan || !chan->con_priv)\n\t\treturn NULL;\n\n\treturn (struct altera_mbox *)chan->con_priv;\n}\n\nstatic inline int altera_mbox_full(struct altera_mbox *mbox)\n{\n\tu32 status;\n\n\tstatus = readl_relaxed(mbox->mbox_base + MAILBOX_STS_REG);\n\treturn MBOX_FULL(status);\n}\n\nstatic inline int altera_mbox_pending(struct altera_mbox *mbox)\n{\n\tu32 status;\n\n\tstatus = readl_relaxed(mbox->mbox_base + MAILBOX_STS_REG);\n\treturn MBOX_PENDING(status);\n}\n\nstatic void altera_mbox_rx_intmask(struct altera_mbox *mbox, bool enable)\n{\n\tu32 mask;\n\n\tmask = readl_relaxed(mbox->mbox_base + MAILBOX_INTMASK_REG);\n\tif (enable)\n\t\tmask |= INT_PENDING_MSK;\n\telse\n\t\tmask &= ~INT_PENDING_MSK;\n\twritel_relaxed(mask, mbox->mbox_base + MAILBOX_INTMASK_REG);\n}\n\nstatic void altera_mbox_tx_intmask(struct altera_mbox *mbox, bool enable)\n{\n\tu32 mask;\n\n\tmask = readl_relaxed(mbox->mbox_base + MAILBOX_INTMASK_REG);\n\tif (enable)\n\t\tmask |= INT_SPACE_MSK;\n\telse\n\t\tmask &= ~INT_SPACE_MSK;\n\twritel_relaxed(mask, mbox->mbox_base + MAILBOX_INTMASK_REG);\n}\n\nstatic bool altera_mbox_is_sender(struct altera_mbox *mbox)\n{\n\tu32 reg;\n\t \n\t#define MBOX_MAGIC\t0xA5A5AA55\n\twritel_relaxed(MBOX_MAGIC, mbox->mbox_base + MAILBOX_PTR_REG);\n\treg = readl_relaxed(mbox->mbox_base + MAILBOX_PTR_REG);\n\tif (reg == MBOX_MAGIC) {\n\t\t \n\t\twritel_relaxed(0, mbox->mbox_base + MAILBOX_PTR_REG);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void altera_mbox_rx_data(struct mbox_chan *chan)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\tu32 data[2];\n\n\tif (altera_mbox_pending(mbox)) {\n\t\tdata[MBOX_PTR] =\n\t\t\treadl_relaxed(mbox->mbox_base + MAILBOX_PTR_REG);\n\t\tdata[MBOX_CMD] =\n\t\t\treadl_relaxed(mbox->mbox_base + MAILBOX_CMD_REG);\n\t\tmbox_chan_received_data(chan, (void *)data);\n\t}\n}\n\nstatic void altera_mbox_poll_rx(struct timer_list *t)\n{\n\tstruct altera_mbox *mbox = from_timer(mbox, t, rxpoll_timer);\n\n\taltera_mbox_rx_data(mbox->chan);\n\n\tmod_timer(&mbox->rxpoll_timer,\n\t\t  jiffies + msecs_to_jiffies(MBOX_POLLING_MS));\n}\n\nstatic irqreturn_t altera_mbox_tx_interrupt(int irq, void *p)\n{\n\tstruct mbox_chan *chan = (struct mbox_chan *)p;\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\taltera_mbox_tx_intmask(mbox, false);\n\tmbox_chan_txdone(chan, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t altera_mbox_rx_interrupt(int irq, void *p)\n{\n\tstruct mbox_chan *chan = (struct mbox_chan *)p;\n\n\taltera_mbox_rx_data(chan);\n\treturn IRQ_HANDLED;\n}\n\nstatic int altera_mbox_startup_sender(struct mbox_chan *chan)\n{\n\tint ret;\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\tif (mbox->intr_mode) {\n\t\tret = request_irq(mbox->irq, altera_mbox_tx_interrupt, 0,\n\t\t\t\t  DRIVER_NAME, chan);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(mbox->dev,\n\t\t\t\t\"failed to register mailbox interrupt:%d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int altera_mbox_startup_receiver(struct mbox_chan *chan)\n{\n\tint ret;\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\tif (mbox->intr_mode) {\n\t\tret = request_irq(mbox->irq, altera_mbox_rx_interrupt, 0,\n\t\t\t\t  DRIVER_NAME, chan);\n\t\tif (unlikely(ret)) {\n\t\t\tmbox->intr_mode = false;\n\t\t\tgoto polling;  \n\t\t}\n\n\t\taltera_mbox_rx_intmask(mbox, true);\n\t\treturn 0;\n\t}\n\npolling:\n\t \n\tmbox->chan = chan;\n\ttimer_setup(&mbox->rxpoll_timer, altera_mbox_poll_rx, 0);\n\tmod_timer(&mbox->rxpoll_timer,\n\t\t  jiffies + msecs_to_jiffies(MBOX_POLLING_MS));\n\n\treturn 0;\n}\n\nstatic int altera_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\tu32 *udata = (u32 *)data;\n\n\tif (!mbox || !data)\n\t\treturn -EINVAL;\n\tif (!mbox->is_sender) {\n\t\tdev_warn(mbox->dev,\n\t\t\t \"failed to send. This is receiver mailbox.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (altera_mbox_full(mbox))\n\t\treturn -EBUSY;\n\n\t \n\tif (mbox->intr_mode)\n\t\taltera_mbox_tx_intmask(mbox, true);\n\n\t \n\twritel_relaxed(udata[MBOX_PTR], mbox->mbox_base + MAILBOX_PTR_REG);\n\twritel_relaxed(udata[MBOX_CMD], mbox->mbox_base + MAILBOX_CMD_REG);\n\n\treturn 0;\n}\n\nstatic bool altera_mbox_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\t \n\treturn altera_mbox_full(mbox) ? false : true;\n}\n\nstatic bool altera_mbox_peek_data(struct mbox_chan *chan)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\treturn altera_mbox_pending(mbox) ? true : false;\n}\n\nstatic int altera_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\tint ret = 0;\n\n\tif (!mbox)\n\t\treturn -EINVAL;\n\n\tif (mbox->is_sender)\n\t\tret = altera_mbox_startup_sender(chan);\n\telse\n\t\tret = altera_mbox_startup_receiver(chan);\n\n\treturn ret;\n}\n\nstatic void altera_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct altera_mbox *mbox = mbox_chan_to_altera_mbox(chan);\n\n\tif (mbox->intr_mode) {\n\t\t \n\t\twritel_relaxed(~0, mbox->mbox_base + MAILBOX_INTMASK_REG);\n\t\tfree_irq(mbox->irq, chan);\n\t} else if (!mbox->is_sender) {\n\t\tdel_timer_sync(&mbox->rxpoll_timer);\n\t}\n}\n\nstatic const struct mbox_chan_ops altera_mbox_ops = {\n\t.send_data = altera_mbox_send_data,\n\t.startup = altera_mbox_startup,\n\t.shutdown = altera_mbox_shutdown,\n\t.last_tx_done = altera_mbox_last_tx_done,\n\t.peek_data = altera_mbox_peek_data,\n};\n\nstatic int altera_mbox_probe(struct platform_device *pdev)\n{\n\tstruct altera_mbox *mbox;\n\tstruct mbox_chan *chans;\n\tint ret;\n\n\tmbox = devm_kzalloc(&pdev->dev, sizeof(*mbox),\n\t\t\t    GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\t \n\tchans = devm_kzalloc(&pdev->dev, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tmbox->mbox_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->mbox_base))\n\t\treturn PTR_ERR(mbox->mbox_base);\n\n\t \n\tmbox->is_sender = altera_mbox_is_sender(mbox);\n\n\tmbox->irq = platform_get_irq(pdev, 0);\n\tif (mbox->irq >= 0)\n\t\tmbox->intr_mode = true;\n\n\tmbox->dev = &pdev->dev;\n\n\t \n\tchans[0].con_priv = mbox;\n\tmbox->controller.dev = mbox->dev;\n\tmbox->controller.num_chans = 1;\n\tmbox->controller.chans = chans;\n\tmbox->controller.ops = &altera_mbox_ops;\n\n\tif (mbox->is_sender) {\n\t\tif (mbox->intr_mode) {\n\t\t\tmbox->controller.txdone_irq = true;\n\t\t} else {\n\t\t\tmbox->controller.txdone_poll = true;\n\t\t\tmbox->controller.txpoll_period = MBOX_POLLING_MS;\n\t\t}\n\t}\n\n\tret = devm_mbox_controller_register(&pdev->dev, &mbox->controller);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Register mailbox failed\\n\");\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, mbox);\nerr:\n\treturn ret;\n}\n\nstatic const struct of_device_id altera_mbox_match[] = {\n\t{ .compatible = \"altr,mailbox-1.0\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, altera_mbox_match);\n\nstatic struct platform_driver altera_mbox_driver = {\n\t.probe\t= altera_mbox_probe,\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table\t= altera_mbox_match,\n\t},\n};\n\nmodule_platform_driver(altera_mbox_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Altera mailbox specific functions\");\nMODULE_AUTHOR(\"Ley Foon Tan <lftan@altera.com>\");\nMODULE_ALIAS(\"platform:altera-mailbox\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}