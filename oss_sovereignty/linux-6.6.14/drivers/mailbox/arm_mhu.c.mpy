{
  "module_name": "arm_mhu.c",
  "hash_id": "11c40f2dde5833abc5454a27945e39b9e7ffaca8c50bdd0a484e818c87a9a75a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/arm_mhu.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#define INTR_STAT_OFS\t0x0\n#define INTR_SET_OFS\t0x8\n#define INTR_CLR_OFS\t0x10\n\n#define MHU_LP_OFFSET\t0x0\n#define MHU_HP_OFFSET\t0x20\n#define MHU_SEC_OFFSET\t0x200\n#define TX_REG_OFFSET\t0x100\n\n#define MHU_CHANS\t3\n\nstruct mhu_link {\n\tunsigned irq;\n\tvoid __iomem *tx_reg;\n\tvoid __iomem *rx_reg;\n};\n\nstruct arm_mhu {\n\tvoid __iomem *base;\n\tstruct mhu_link mlink[MHU_CHANS];\n\tstruct mbox_chan chan[MHU_CHANS];\n\tstruct mbox_controller mbox;\n};\n\nstatic irqreturn_t mhu_rx_interrupt(int irq, void *p)\n{\n\tstruct mbox_chan *chan = p;\n\tstruct mhu_link *mlink = chan->con_priv;\n\tu32 val;\n\n\tval = readl_relaxed(mlink->rx_reg + INTR_STAT_OFS);\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tmbox_chan_received_data(chan, (void *)&val);\n\n\twritel_relaxed(val, mlink->rx_reg + INTR_CLR_OFS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool mhu_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct mhu_link *mlink = chan->con_priv;\n\tu32 val = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\n\n\treturn (val == 0);\n}\n\nstatic int mhu_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct mhu_link *mlink = chan->con_priv;\n\tu32 *arg = data;\n\n\twritel_relaxed(*arg, mlink->tx_reg + INTR_SET_OFS);\n\n\treturn 0;\n}\n\nstatic int mhu_startup(struct mbox_chan *chan)\n{\n\tstruct mhu_link *mlink = chan->con_priv;\n\tu32 val;\n\tint ret;\n\n\tval = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\n\twritel_relaxed(val, mlink->tx_reg + INTR_CLR_OFS);\n\n\tret = request_irq(mlink->irq, mhu_rx_interrupt,\n\t\t\t  IRQF_SHARED, \"mhu_link\", chan);\n\tif (ret) {\n\t\tdev_err(chan->mbox->dev,\n\t\t\t\"Unable to acquire IRQ %d\\n\", mlink->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mhu_shutdown(struct mbox_chan *chan)\n{\n\tstruct mhu_link *mlink = chan->con_priv;\n\n\tfree_irq(mlink->irq, chan);\n}\n\nstatic const struct mbox_chan_ops mhu_ops = {\n\t.send_data = mhu_send_data,\n\t.startup = mhu_startup,\n\t.shutdown = mhu_shutdown,\n\t.last_tx_done = mhu_last_tx_done,\n};\n\nstatic int mhu_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint i, err;\n\tstruct arm_mhu *mhu;\n\tstruct device *dev = &adev->dev;\n\tint mhu_reg[MHU_CHANS] = {MHU_LP_OFFSET, MHU_HP_OFFSET, MHU_SEC_OFFSET};\n\n\tif (!of_device_is_compatible(dev->of_node, \"arm,mhu\"))\n\t\treturn -ENODEV;\n\n\t \n\tmhu = devm_kzalloc(dev, sizeof(*mhu), GFP_KERNEL);\n\tif (!mhu)\n\t\treturn -ENOMEM;\n\n\tmhu->base = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(mhu->base))\n\t\treturn PTR_ERR(mhu->base);\n\n\tfor (i = 0; i < MHU_CHANS; i++) {\n\t\tmhu->chan[i].con_priv = &mhu->mlink[i];\n\t\tmhu->mlink[i].irq = adev->irq[i];\n\t\tmhu->mlink[i].rx_reg = mhu->base + mhu_reg[i];\n\t\tmhu->mlink[i].tx_reg = mhu->mlink[i].rx_reg + TX_REG_OFFSET;\n\t}\n\n\tmhu->mbox.dev = dev;\n\tmhu->mbox.chans = &mhu->chan[0];\n\tmhu->mbox.num_chans = MHU_CHANS;\n\tmhu->mbox.ops = &mhu_ops;\n\tmhu->mbox.txdone_irq = false;\n\tmhu->mbox.txdone_poll = true;\n\tmhu->mbox.txpoll_period = 1;\n\n\tamba_set_drvdata(adev, mhu);\n\n\terr = devm_mbox_controller_register(dev, &mhu->mbox);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mailboxes %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_info(dev, \"ARM MHU Mailbox registered\\n\");\n\treturn 0;\n}\n\nstatic struct amba_id mhu_ids[] = {\n\t{\n\t\t.id\t= 0x1bb098,\n\t\t.mask\t= 0xffffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, mhu_ids);\n\nstatic struct amba_driver arm_mhu_driver = {\n\t.drv = {\n\t\t.name\t= \"mhu\",\n\t},\n\t.id_table\t= mhu_ids,\n\t.probe\t\t= mhu_probe,\n};\nmodule_amba_driver(arm_mhu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ARM MHU Driver\");\nMODULE_AUTHOR(\"Jassi Brar <jassisinghbrar@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}