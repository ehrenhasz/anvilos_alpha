{
  "module_name": "bcm2835-mailbox.c",
  "hash_id": "466010d7a061811853a6575cfb60e9d47da6b8f7c56a1650afc4ca19494903e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/bcm2835-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n \n#define ARM_0_MAIL0\t0x00\n#define ARM_0_MAIL1\t0x20\n\n \n#define MAIL0_RD\t(ARM_0_MAIL0 + 0x00)\n#define MAIL0_POL\t(ARM_0_MAIL0 + 0x10)\n#define MAIL0_STA\t(ARM_0_MAIL0 + 0x18)\n#define MAIL0_CNF\t(ARM_0_MAIL0 + 0x1C)\n#define MAIL1_WRT\t(ARM_0_MAIL1 + 0x00)\n#define MAIL1_STA\t(ARM_0_MAIL1 + 0x18)\n\n \n#define ARM_MS_FULL\t\tBIT(31)\n#define ARM_MS_EMPTY\t\tBIT(30)\n\n \n#define ARM_MC_IHAVEDATAIRQEN\tBIT(0)\n\nstruct bcm2835_mbox {\n\tvoid __iomem *regs;\n\tspinlock_t lock;\n\tstruct mbox_controller controller;\n};\n\nstatic struct bcm2835_mbox *bcm2835_link_mbox(struct mbox_chan *link)\n{\n\treturn container_of(link->mbox, struct bcm2835_mbox, controller);\n}\n\nstatic irqreturn_t bcm2835_mbox_irq(int irq, void *dev_id)\n{\n\tstruct bcm2835_mbox *mbox = dev_id;\n\tstruct device *dev = mbox->controller.dev;\n\tstruct mbox_chan *link = &mbox->controller.chans[0];\n\n\twhile (!(readl(mbox->regs + MAIL0_STA) & ARM_MS_EMPTY)) {\n\t\tu32 msg = readl(mbox->regs + MAIL0_RD);\n\t\tdev_dbg(dev, \"Reply 0x%08X\\n\", msg);\n\t\tmbox_chan_received_data(link, &msg);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm2835_send_data(struct mbox_chan *link, void *data)\n{\n\tstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\n\tu32 msg = *(u32 *)data;\n\n\tspin_lock(&mbox->lock);\n\twritel(msg, mbox->regs + MAIL1_WRT);\n\tdev_dbg(mbox->controller.dev, \"Request 0x%08X\\n\", msg);\n\tspin_unlock(&mbox->lock);\n\treturn 0;\n}\n\nstatic int bcm2835_startup(struct mbox_chan *link)\n{\n\tstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\n\n\t \n\twritel(ARM_MC_IHAVEDATAIRQEN, mbox->regs + MAIL0_CNF);\n\n\treturn 0;\n}\n\nstatic void bcm2835_shutdown(struct mbox_chan *link)\n{\n\tstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\n\n\twritel(0, mbox->regs + MAIL0_CNF);\n}\n\nstatic bool bcm2835_last_tx_done(struct mbox_chan *link)\n{\n\tstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\n\tbool ret;\n\n\tspin_lock(&mbox->lock);\n\tret = !(readl(mbox->regs + MAIL1_STA) & ARM_MS_FULL);\n\tspin_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic const struct mbox_chan_ops bcm2835_mbox_chan_ops = {\n\t.send_data\t= bcm2835_send_data,\n\t.startup\t= bcm2835_startup,\n\t.shutdown\t= bcm2835_shutdown,\n\t.last_tx_done\t= bcm2835_last_tx_done\n};\n\nstatic struct mbox_chan *bcm2835_mbox_index_xlate(struct mbox_controller *mbox,\n\t\t    const struct of_phandle_args *sp)\n{\n\tif (sp->args_count != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &mbox->chans[0];\n}\n\nstatic int bcm2835_mbox_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\tstruct bcm2835_mbox *mbox;\n\n\tmbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);\n\tif (mbox == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&mbox->lock);\n\n\tret = devm_request_irq(dev, irq_of_parse_and_map(dev->of_node, 0),\n\t\t\t       bcm2835_mbox_irq, 0, dev_name(dev), mbox);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register a mailbox IRQ handler: %d\\n\",\n\t\t\tret);\n\t\treturn -ENODEV;\n\t}\n\n\tmbox->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->regs)) {\n\t\tret = PTR_ERR(mbox->regs);\n\t\treturn ret;\n\t}\n\n\tmbox->controller.txdone_poll = true;\n\tmbox->controller.txpoll_period = 5;\n\tmbox->controller.ops = &bcm2835_mbox_chan_ops;\n\tmbox->controller.of_xlate = &bcm2835_mbox_index_xlate;\n\tmbox->controller.dev = dev;\n\tmbox->controller.num_chans = 1;\n\tmbox->controller.chans = devm_kzalloc(dev,\n\t\tsizeof(*mbox->controller.chans), GFP_KERNEL);\n\tif (!mbox->controller.chans)\n\t\treturn -ENOMEM;\n\n\tret = devm_mbox_controller_register(dev, &mbox->controller);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, mbox);\n\tdev_info(dev, \"mailbox enabled\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id bcm2835_mbox_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-mbox\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm2835_mbox_of_match);\n\nstatic struct platform_driver bcm2835_mbox_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835-mbox\",\n\t\t.of_match_table = bcm2835_mbox_of_match,\n\t},\n\t.probe\t\t= bcm2835_mbox_probe,\n};\nmodule_platform_driver(bcm2835_mbox_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"BCM2835 mailbox IPC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}