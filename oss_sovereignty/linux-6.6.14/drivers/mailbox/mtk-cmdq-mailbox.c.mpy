{
  "module_name": "mtk-cmdq-mailbox.c",
  "hash_id": "29d2b1a9a4f1ce6d900bf34707780b604a6c97c7ff009b423f5777fe9a7a3ac0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mtk-cmdq-mailbox.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox/mtk-cmdq-mailbox.h>\n#include <linux/of.h>\n\n#define CMDQ_OP_CODE_MASK\t\t(0xff << CMDQ_OP_CODE_SHIFT)\n#define CMDQ_NUM_CMD(t)\t\t\t(t->cmd_buf_size / CMDQ_INST_SIZE)\n#define CMDQ_GCE_NUM_MAX\t\t(2)\n\n#define CMDQ_CURR_IRQ_STATUS\t\t0x10\n#define CMDQ_SYNC_TOKEN_UPDATE\t\t0x68\n#define CMDQ_THR_SLOT_CYCLES\t\t0x30\n#define CMDQ_THR_BASE\t\t\t0x100\n#define CMDQ_THR_SIZE\t\t\t0x80\n#define CMDQ_THR_WARM_RESET\t\t0x00\n#define CMDQ_THR_ENABLE_TASK\t\t0x04\n#define CMDQ_THR_SUSPEND_TASK\t\t0x08\n#define CMDQ_THR_CURR_STATUS\t\t0x0c\n#define CMDQ_THR_IRQ_STATUS\t\t0x10\n#define CMDQ_THR_IRQ_ENABLE\t\t0x14\n#define CMDQ_THR_CURR_ADDR\t\t0x20\n#define CMDQ_THR_END_ADDR\t\t0x24\n#define CMDQ_THR_WAIT_TOKEN\t\t0x30\n#define CMDQ_THR_PRIORITY\t\t0x40\n\n#define GCE_GCTL_VALUE\t\t\t0x48\n#define GCE_CTRL_BY_SW\t\t\t\tGENMASK(2, 0)\n#define GCE_DDR_EN\t\t\t\tGENMASK(18, 16)\n\n#define CMDQ_THR_ACTIVE_SLOT_CYCLES\t0x3200\n#define CMDQ_THR_ENABLED\t\t0x1\n#define CMDQ_THR_DISABLED\t\t0x0\n#define CMDQ_THR_SUSPEND\t\t0x1\n#define CMDQ_THR_RESUME\t\t\t0x0\n#define CMDQ_THR_STATUS_SUSPENDED\tBIT(1)\n#define CMDQ_THR_DO_WARM_RESET\t\tBIT(0)\n#define CMDQ_THR_IRQ_DONE\t\t0x1\n#define CMDQ_THR_IRQ_ERROR\t\t0x12\n#define CMDQ_THR_IRQ_EN\t\t\t(CMDQ_THR_IRQ_ERROR | CMDQ_THR_IRQ_DONE)\n#define CMDQ_THR_IS_WAITING\t\tBIT(31)\n\n#define CMDQ_JUMP_BY_OFFSET\t\t0x10000000\n#define CMDQ_JUMP_BY_PA\t\t\t0x10000001\n\nstruct cmdq_thread {\n\tstruct mbox_chan\t*chan;\n\tvoid __iomem\t\t*base;\n\tstruct list_head\ttask_busy_list;\n\tu32\t\t\tpriority;\n};\n\nstruct cmdq_task {\n\tstruct cmdq\t\t*cmdq;\n\tstruct list_head\tlist_entry;\n\tdma_addr_t\t\tpa_base;\n\tstruct cmdq_thread\t*thread;\n\tstruct cmdq_pkt\t\t*pkt;  \n};\n\nstruct cmdq {\n\tstruct mbox_controller\tmbox;\n\tvoid __iomem\t\t*base;\n\tint\t\t\tirq;\n\tu32\t\t\tirq_mask;\n\tconst struct gce_plat\t*pdata;\n\tstruct cmdq_thread\t*thread;\n\tstruct clk_bulk_data\tclocks[CMDQ_GCE_NUM_MAX];\n\tbool\t\t\tsuspended;\n};\n\nstruct gce_plat {\n\tu32 thread_nr;\n\tu8 shift;\n\tbool control_by_sw;\n\tbool sw_ddr_en;\n\tu32 gce_num;\n};\n\nstatic void cmdq_sw_ddr_enable(struct cmdq *cmdq, bool enable)\n{\n\tWARN_ON(clk_bulk_enable(cmdq->pdata->gce_num, cmdq->clocks));\n\n\tif (enable)\n\t\twritel(GCE_DDR_EN | GCE_CTRL_BY_SW, cmdq->base + GCE_GCTL_VALUE);\n\telse\n\t\twritel(GCE_CTRL_BY_SW, cmdq->base + GCE_GCTL_VALUE);\n\n\tclk_bulk_disable(cmdq->pdata->gce_num, cmdq->clocks);\n}\n\nu8 cmdq_get_shift_pa(struct mbox_chan *chan)\n{\n\tstruct cmdq *cmdq = container_of(chan->mbox, struct cmdq, mbox);\n\n\treturn cmdq->pdata->shift;\n}\nEXPORT_SYMBOL(cmdq_get_shift_pa);\n\nstatic int cmdq_thread_suspend(struct cmdq *cmdq, struct cmdq_thread *thread)\n{\n\tu32 status;\n\n\twritel(CMDQ_THR_SUSPEND, thread->base + CMDQ_THR_SUSPEND_TASK);\n\n\t \n\tif (!(readl(thread->base + CMDQ_THR_ENABLE_TASK) & CMDQ_THR_ENABLED))\n\t\treturn 0;\n\n\tif (readl_poll_timeout_atomic(thread->base + CMDQ_THR_CURR_STATUS,\n\t\t\tstatus, status & CMDQ_THR_STATUS_SUSPENDED, 0, 10)) {\n\t\tdev_err(cmdq->mbox.dev, \"suspend GCE thread 0x%x failed\\n\",\n\t\t\t(u32)(thread->base - cmdq->base));\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void cmdq_thread_resume(struct cmdq_thread *thread)\n{\n\twritel(CMDQ_THR_RESUME, thread->base + CMDQ_THR_SUSPEND_TASK);\n}\n\nstatic void cmdq_init(struct cmdq *cmdq)\n{\n\tint i;\n\tu32 gctl_regval = 0;\n\n\tWARN_ON(clk_bulk_enable(cmdq->pdata->gce_num, cmdq->clocks));\n\tif (cmdq->pdata->control_by_sw)\n\t\tgctl_regval = GCE_CTRL_BY_SW;\n\tif (cmdq->pdata->sw_ddr_en)\n\t\tgctl_regval |= GCE_DDR_EN;\n\n\tif (gctl_regval)\n\t\twritel(gctl_regval, cmdq->base + GCE_GCTL_VALUE);\n\n\twritel(CMDQ_THR_ACTIVE_SLOT_CYCLES, cmdq->base + CMDQ_THR_SLOT_CYCLES);\n\tfor (i = 0; i <= CMDQ_MAX_EVENT; i++)\n\t\twritel(i, cmdq->base + CMDQ_SYNC_TOKEN_UPDATE);\n\tclk_bulk_disable(cmdq->pdata->gce_num, cmdq->clocks);\n}\n\nstatic int cmdq_thread_reset(struct cmdq *cmdq, struct cmdq_thread *thread)\n{\n\tu32 warm_reset;\n\n\twritel(CMDQ_THR_DO_WARM_RESET, thread->base + CMDQ_THR_WARM_RESET);\n\tif (readl_poll_timeout_atomic(thread->base + CMDQ_THR_WARM_RESET,\n\t\t\twarm_reset, !(warm_reset & CMDQ_THR_DO_WARM_RESET),\n\t\t\t0, 10)) {\n\t\tdev_err(cmdq->mbox.dev, \"reset GCE thread 0x%x failed\\n\",\n\t\t\t(u32)(thread->base - cmdq->base));\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void cmdq_thread_disable(struct cmdq *cmdq, struct cmdq_thread *thread)\n{\n\tcmdq_thread_reset(cmdq, thread);\n\twritel(CMDQ_THR_DISABLED, thread->base + CMDQ_THR_ENABLE_TASK);\n}\n\n \nstatic void cmdq_thread_invalidate_fetched_data(struct cmdq_thread *thread)\n{\n\twritel(readl(thread->base + CMDQ_THR_CURR_ADDR),\n\t       thread->base + CMDQ_THR_CURR_ADDR);\n}\n\nstatic void cmdq_task_insert_into_thread(struct cmdq_task *task)\n{\n\tstruct device *dev = task->cmdq->mbox.dev;\n\tstruct cmdq_thread *thread = task->thread;\n\tstruct cmdq_task *prev_task = list_last_entry(\n\t\t\t&thread->task_busy_list, typeof(*task), list_entry);\n\tu64 *prev_task_base = prev_task->pkt->va_base;\n\n\t \n\tdma_sync_single_for_cpu(dev, prev_task->pa_base,\n\t\t\t\tprev_task->pkt->cmd_buf_size, DMA_TO_DEVICE);\n\tprev_task_base[CMDQ_NUM_CMD(prev_task->pkt) - 1] =\n\t\t(u64)CMDQ_JUMP_BY_PA << 32 |\n\t\t(task->pa_base >> task->cmdq->pdata->shift);\n\tdma_sync_single_for_device(dev, prev_task->pa_base,\n\t\t\t\t   prev_task->pkt->cmd_buf_size, DMA_TO_DEVICE);\n\n\tcmdq_thread_invalidate_fetched_data(thread);\n}\n\nstatic bool cmdq_thread_is_in_wfe(struct cmdq_thread *thread)\n{\n\treturn readl(thread->base + CMDQ_THR_WAIT_TOKEN) & CMDQ_THR_IS_WAITING;\n}\n\nstatic void cmdq_task_exec_done(struct cmdq_task *task, int sta)\n{\n\tstruct cmdq_cb_data data;\n\n\tdata.sta = sta;\n\tdata.pkt = task->pkt;\n\tmbox_chan_received_data(task->thread->chan, &data);\n\n\tlist_del(&task->list_entry);\n}\n\nstatic void cmdq_task_handle_error(struct cmdq_task *task)\n{\n\tstruct cmdq_thread *thread = task->thread;\n\tstruct cmdq_task *next_task;\n\tstruct cmdq *cmdq = task->cmdq;\n\n\tdev_err(cmdq->mbox.dev, \"task 0x%p error\\n\", task);\n\tWARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);\n\tnext_task = list_first_entry_or_null(&thread->task_busy_list,\n\t\t\tstruct cmdq_task, list_entry);\n\tif (next_task)\n\t\twritel(next_task->pa_base >> cmdq->pdata->shift,\n\t\t       thread->base + CMDQ_THR_CURR_ADDR);\n\tcmdq_thread_resume(thread);\n}\n\nstatic void cmdq_thread_irq_handler(struct cmdq *cmdq,\n\t\t\t\t    struct cmdq_thread *thread)\n{\n\tstruct cmdq_task *task, *tmp, *curr_task = NULL;\n\tu32 curr_pa, irq_flag, task_end_pa;\n\tbool err;\n\n\tirq_flag = readl(thread->base + CMDQ_THR_IRQ_STATUS);\n\twritel(~irq_flag, thread->base + CMDQ_THR_IRQ_STATUS);\n\n\t \n\tif (!(readl(thread->base + CMDQ_THR_ENABLE_TASK) & CMDQ_THR_ENABLED))\n\t\treturn;\n\n\tif (irq_flag & CMDQ_THR_IRQ_ERROR)\n\t\terr = true;\n\telse if (irq_flag & CMDQ_THR_IRQ_DONE)\n\t\terr = false;\n\telse\n\t\treturn;\n\n\tcurr_pa = readl(thread->base + CMDQ_THR_CURR_ADDR) << cmdq->pdata->shift;\n\n\tlist_for_each_entry_safe(task, tmp, &thread->task_busy_list,\n\t\t\t\t list_entry) {\n\t\ttask_end_pa = task->pa_base + task->pkt->cmd_buf_size;\n\t\tif (curr_pa >= task->pa_base && curr_pa < task_end_pa)\n\t\t\tcurr_task = task;\n\n\t\tif (!curr_task || curr_pa == task_end_pa - CMDQ_INST_SIZE) {\n\t\t\tcmdq_task_exec_done(task, 0);\n\t\t\tkfree(task);\n\t\t} else if (err) {\n\t\t\tcmdq_task_exec_done(task, -ENOEXEC);\n\t\t\tcmdq_task_handle_error(curr_task);\n\t\t\tkfree(task);\n\t\t}\n\n\t\tif (curr_task)\n\t\t\tbreak;\n\t}\n\n\tif (list_empty(&thread->task_busy_list)) {\n\t\tcmdq_thread_disable(cmdq, thread);\n\t\tclk_bulk_disable(cmdq->pdata->gce_num, cmdq->clocks);\n\t}\n}\n\nstatic irqreturn_t cmdq_irq_handler(int irq, void *dev)\n{\n\tstruct cmdq *cmdq = dev;\n\tunsigned long irq_status, flags = 0L;\n\tint bit;\n\n\tirq_status = readl(cmdq->base + CMDQ_CURR_IRQ_STATUS) & cmdq->irq_mask;\n\tif (!(irq_status ^ cmdq->irq_mask))\n\t\treturn IRQ_NONE;\n\n\tfor_each_clear_bit(bit, &irq_status, cmdq->pdata->thread_nr) {\n\t\tstruct cmdq_thread *thread = &cmdq->thread[bit];\n\n\t\tspin_lock_irqsave(&thread->chan->lock, flags);\n\t\tcmdq_thread_irq_handler(cmdq, thread);\n\t\tspin_unlock_irqrestore(&thread->chan->lock, flags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cmdq_suspend(struct device *dev)\n{\n\tstruct cmdq *cmdq = dev_get_drvdata(dev);\n\tstruct cmdq_thread *thread;\n\tint i;\n\tbool task_running = false;\n\n\tcmdq->suspended = true;\n\n\tfor (i = 0; i < cmdq->pdata->thread_nr; i++) {\n\t\tthread = &cmdq->thread[i];\n\t\tif (!list_empty(&thread->task_busy_list)) {\n\t\t\ttask_running = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (task_running)\n\t\tdev_warn(dev, \"exist running task(s) in suspend\\n\");\n\n\tif (cmdq->pdata->sw_ddr_en)\n\t\tcmdq_sw_ddr_enable(cmdq, false);\n\n\tclk_bulk_unprepare(cmdq->pdata->gce_num, cmdq->clocks);\n\n\treturn 0;\n}\n\nstatic int cmdq_resume(struct device *dev)\n{\n\tstruct cmdq *cmdq = dev_get_drvdata(dev);\n\n\tWARN_ON(clk_bulk_prepare(cmdq->pdata->gce_num, cmdq->clocks));\n\tcmdq->suspended = false;\n\n\tif (cmdq->pdata->sw_ddr_en)\n\t\tcmdq_sw_ddr_enable(cmdq, true);\n\n\treturn 0;\n}\n\nstatic int cmdq_remove(struct platform_device *pdev)\n{\n\tstruct cmdq *cmdq = platform_get_drvdata(pdev);\n\n\tif (cmdq->pdata->sw_ddr_en)\n\t\tcmdq_sw_ddr_enable(cmdq, false);\n\n\tclk_bulk_unprepare(cmdq->pdata->gce_num, cmdq->clocks);\n\treturn 0;\n}\n\nstatic int cmdq_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct cmdq_pkt *pkt = (struct cmdq_pkt *)data;\n\tstruct cmdq_thread *thread = (struct cmdq_thread *)chan->con_priv;\n\tstruct cmdq *cmdq = dev_get_drvdata(chan->mbox->dev);\n\tstruct cmdq_task *task;\n\tunsigned long curr_pa, end_pa;\n\n\t \n\tWARN_ON(cmdq->suspended);\n\n\ttask = kzalloc(sizeof(*task), GFP_ATOMIC);\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\ttask->cmdq = cmdq;\n\tINIT_LIST_HEAD(&task->list_entry);\n\ttask->pa_base = pkt->pa_base;\n\ttask->thread = thread;\n\ttask->pkt = pkt;\n\n\tif (list_empty(&thread->task_busy_list)) {\n\t\tWARN_ON(clk_bulk_enable(cmdq->pdata->gce_num, cmdq->clocks));\n\n\t\t \n\t\tWARN_ON(cmdq_thread_reset(cmdq, thread) < 0);\n\n\t\twritel(task->pa_base >> cmdq->pdata->shift,\n\t\t       thread->base + CMDQ_THR_CURR_ADDR);\n\t\twritel((task->pa_base + pkt->cmd_buf_size) >> cmdq->pdata->shift,\n\t\t       thread->base + CMDQ_THR_END_ADDR);\n\n\t\twritel(thread->priority, thread->base + CMDQ_THR_PRIORITY);\n\t\twritel(CMDQ_THR_IRQ_EN, thread->base + CMDQ_THR_IRQ_ENABLE);\n\t\twritel(CMDQ_THR_ENABLED, thread->base + CMDQ_THR_ENABLE_TASK);\n\t} else {\n\t\tWARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);\n\t\tcurr_pa = readl(thread->base + CMDQ_THR_CURR_ADDR) <<\n\t\t\tcmdq->pdata->shift;\n\t\tend_pa = readl(thread->base + CMDQ_THR_END_ADDR) <<\n\t\t\tcmdq->pdata->shift;\n\t\t \n\t\tif (curr_pa == end_pa - CMDQ_INST_SIZE ||\n\t\t    curr_pa == end_pa) {\n\t\t\t \n\t\t\twritel(task->pa_base >> cmdq->pdata->shift,\n\t\t\t       thread->base + CMDQ_THR_CURR_ADDR);\n\t\t} else {\n\t\t\tcmdq_task_insert_into_thread(task);\n\t\t\tsmp_mb();  \n\t\t}\n\t\twritel((task->pa_base + pkt->cmd_buf_size) >> cmdq->pdata->shift,\n\t\t       thread->base + CMDQ_THR_END_ADDR);\n\t\tcmdq_thread_resume(thread);\n\t}\n\tlist_move_tail(&task->list_entry, &thread->task_busy_list);\n\n\treturn 0;\n}\n\nstatic int cmdq_mbox_startup(struct mbox_chan *chan)\n{\n\treturn 0;\n}\n\nstatic void cmdq_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct cmdq_thread *thread = (struct cmdq_thread *)chan->con_priv;\n\tstruct cmdq *cmdq = dev_get_drvdata(chan->mbox->dev);\n\tstruct cmdq_task *task, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&thread->chan->lock, flags);\n\tif (list_empty(&thread->task_busy_list))\n\t\tgoto done;\n\n\tWARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);\n\n\t \n\tcmdq_thread_irq_handler(cmdq, thread);\n\tif (list_empty(&thread->task_busy_list))\n\t\tgoto done;\n\n\tlist_for_each_entry_safe(task, tmp, &thread->task_busy_list,\n\t\t\t\t list_entry) {\n\t\tcmdq_task_exec_done(task, -ECONNABORTED);\n\t\tkfree(task);\n\t}\n\n\tcmdq_thread_disable(cmdq, thread);\n\tclk_bulk_disable(cmdq->pdata->gce_num, cmdq->clocks);\n\ndone:\n\t \n\tspin_unlock_irqrestore(&thread->chan->lock, flags);\n}\n\nstatic int cmdq_mbox_flush(struct mbox_chan *chan, unsigned long timeout)\n{\n\tstruct cmdq_thread *thread = (struct cmdq_thread *)chan->con_priv;\n\tstruct cmdq_cb_data data;\n\tstruct cmdq *cmdq = dev_get_drvdata(chan->mbox->dev);\n\tstruct cmdq_task *task, *tmp;\n\tunsigned long flags;\n\tu32 enable;\n\n\tspin_lock_irqsave(&thread->chan->lock, flags);\n\tif (list_empty(&thread->task_busy_list))\n\t\tgoto out;\n\n\tWARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);\n\tif (!cmdq_thread_is_in_wfe(thread))\n\t\tgoto wait;\n\n\tlist_for_each_entry_safe(task, tmp, &thread->task_busy_list,\n\t\t\t\t list_entry) {\n\t\tdata.sta = -ECONNABORTED;\n\t\tdata.pkt = task->pkt;\n\t\tmbox_chan_received_data(task->thread->chan, &data);\n\t\tlist_del(&task->list_entry);\n\t\tkfree(task);\n\t}\n\n\tcmdq_thread_resume(thread);\n\tcmdq_thread_disable(cmdq, thread);\n\tclk_bulk_disable(cmdq->pdata->gce_num, cmdq->clocks);\n\nout:\n\tspin_unlock_irqrestore(&thread->chan->lock, flags);\n\treturn 0;\n\nwait:\n\tcmdq_thread_resume(thread);\n\tspin_unlock_irqrestore(&thread->chan->lock, flags);\n\tif (readl_poll_timeout_atomic(thread->base + CMDQ_THR_ENABLE_TASK,\n\t\t\t\t      enable, enable == 0, 1, timeout)) {\n\t\tdev_err(cmdq->mbox.dev, \"Fail to wait GCE thread 0x%x done\\n\",\n\t\t\t(u32)(thread->base - cmdq->base));\n\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic const struct mbox_chan_ops cmdq_mbox_chan_ops = {\n\t.send_data = cmdq_mbox_send_data,\n\t.startup = cmdq_mbox_startup,\n\t.shutdown = cmdq_mbox_shutdown,\n\t.flush = cmdq_mbox_flush,\n};\n\nstatic struct mbox_chan *cmdq_xlate(struct mbox_controller *mbox,\n\t\tconst struct of_phandle_args *sp)\n{\n\tint ind = sp->args[0];\n\tstruct cmdq_thread *thread;\n\n\tif (ind >= mbox->num_chans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tthread = (struct cmdq_thread *)mbox->chans[ind].con_priv;\n\tthread->priority = sp->args[1];\n\tthread->chan = &mbox->chans[ind];\n\n\treturn &mbox->chans[ind];\n}\n\nstatic int cmdq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cmdq *cmdq;\n\tint err, i;\n\tstruct device_node *phandle = dev->of_node;\n\tstruct device_node *node;\n\tint alias_id = 0;\n\tstatic const char * const clk_name = \"gce\";\n\tstatic const char * const clk_names[] = { \"gce0\", \"gce1\" };\n\n\tcmdq = devm_kzalloc(dev, sizeof(*cmdq), GFP_KERNEL);\n\tif (!cmdq)\n\t\treturn -ENOMEM;\n\n\tcmdq->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cmdq->base))\n\t\treturn PTR_ERR(cmdq->base);\n\n\tcmdq->irq = platform_get_irq(pdev, 0);\n\tif (cmdq->irq < 0)\n\t\treturn cmdq->irq;\n\n\tcmdq->pdata = device_get_match_data(dev);\n\tif (!cmdq->pdata) {\n\t\tdev_err(dev, \"failed to get match data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmdq->irq_mask = GENMASK(cmdq->pdata->thread_nr - 1, 0);\n\n\tdev_dbg(dev, \"cmdq device: addr:0x%p, va:0x%p, irq:%d\\n\",\n\t\tdev, cmdq->base, cmdq->irq);\n\n\tif (cmdq->pdata->gce_num > 1) {\n\t\tfor_each_child_of_node(phandle->parent, node) {\n\t\t\talias_id = of_alias_get_id(node, clk_name);\n\t\t\tif (alias_id >= 0 && alias_id < cmdq->pdata->gce_num) {\n\t\t\t\tcmdq->clocks[alias_id].id = clk_names[alias_id];\n\t\t\t\tcmdq->clocks[alias_id].clk = of_clk_get(node, 0);\n\t\t\t\tif (IS_ERR(cmdq->clocks[alias_id].clk)) {\n\t\t\t\t\tof_node_put(node);\n\t\t\t\t\treturn dev_err_probe(dev,\n\t\t\t\t\t\t\t     PTR_ERR(cmdq->clocks[alias_id].clk),\n\t\t\t\t\t\t\t     \"failed to get gce clk: %d\\n\",\n\t\t\t\t\t\t\t     alias_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcmdq->clocks[alias_id].id = clk_name;\n\t\tcmdq->clocks[alias_id].clk = devm_clk_get(&pdev->dev, clk_name);\n\t\tif (IS_ERR(cmdq->clocks[alias_id].clk)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(cmdq->clocks[alias_id].clk),\n\t\t\t\t\t     \"failed to get gce clk\\n\");\n\t\t}\n\t}\n\n\tcmdq->mbox.dev = dev;\n\tcmdq->mbox.chans = devm_kcalloc(dev, cmdq->pdata->thread_nr,\n\t\t\t\t\tsizeof(*cmdq->mbox.chans), GFP_KERNEL);\n\tif (!cmdq->mbox.chans)\n\t\treturn -ENOMEM;\n\n\tcmdq->mbox.num_chans = cmdq->pdata->thread_nr;\n\tcmdq->mbox.ops = &cmdq_mbox_chan_ops;\n\tcmdq->mbox.of_xlate = cmdq_xlate;\n\n\t \n\tcmdq->mbox.txdone_irq = false;\n\tcmdq->mbox.txdone_poll = false;\n\n\tcmdq->thread = devm_kcalloc(dev, cmdq->pdata->thread_nr,\n\t\t\t\t\tsizeof(*cmdq->thread), GFP_KERNEL);\n\tif (!cmdq->thread)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cmdq->pdata->thread_nr; i++) {\n\t\tcmdq->thread[i].base = cmdq->base + CMDQ_THR_BASE +\n\t\t\t\tCMDQ_THR_SIZE * i;\n\t\tINIT_LIST_HEAD(&cmdq->thread[i].task_busy_list);\n\t\tcmdq->mbox.chans[i].con_priv = (void *)&cmdq->thread[i];\n\t}\n\n\terr = devm_mbox_controller_register(dev, &cmdq->mbox);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register mailbox: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, cmdq);\n\n\tWARN_ON(clk_bulk_prepare(cmdq->pdata->gce_num, cmdq->clocks));\n\n\tcmdq_init(cmdq);\n\n\terr = devm_request_irq(dev, cmdq->irq, cmdq_irq_handler, IRQF_SHARED,\n\t\t\t       \"mtk_cmdq\", cmdq);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register ISR (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cmdq_pm_ops = {\n\t.suspend = cmdq_suspend,\n\t.resume = cmdq_resume,\n};\n\nstatic const struct gce_plat gce_plat_v2 = {\n\t.thread_nr = 16,\n\t.shift = 0,\n\t.control_by_sw = false,\n\t.gce_num = 1\n};\n\nstatic const struct gce_plat gce_plat_v3 = {\n\t.thread_nr = 24,\n\t.shift = 0,\n\t.control_by_sw = false,\n\t.gce_num = 1\n};\n\nstatic const struct gce_plat gce_plat_v4 = {\n\t.thread_nr = 24,\n\t.shift = 3,\n\t.control_by_sw = false,\n\t.gce_num = 1\n};\n\nstatic const struct gce_plat gce_plat_v5 = {\n\t.thread_nr = 24,\n\t.shift = 3,\n\t.control_by_sw = true,\n\t.gce_num = 1\n};\n\nstatic const struct gce_plat gce_plat_v6 = {\n\t.thread_nr = 24,\n\t.shift = 3,\n\t.control_by_sw = true,\n\t.gce_num = 2\n};\n\nstatic const struct gce_plat gce_plat_v7 = {\n\t.thread_nr = 24,\n\t.shift = 3,\n\t.control_by_sw = true,\n\t.sw_ddr_en = true,\n\t.gce_num = 1\n};\n\nstatic const struct of_device_id cmdq_of_ids[] = {\n\t{.compatible = \"mediatek,mt8173-gce\", .data = (void *)&gce_plat_v2},\n\t{.compatible = \"mediatek,mt8183-gce\", .data = (void *)&gce_plat_v3},\n\t{.compatible = \"mediatek,mt8186-gce\", .data = (void *)&gce_plat_v7},\n\t{.compatible = \"mediatek,mt6779-gce\", .data = (void *)&gce_plat_v4},\n\t{.compatible = \"mediatek,mt8192-gce\", .data = (void *)&gce_plat_v5},\n\t{.compatible = \"mediatek,mt8195-gce\", .data = (void *)&gce_plat_v6},\n\t{}\n};\n\nstatic struct platform_driver cmdq_drv = {\n\t.probe = cmdq_probe,\n\t.remove = cmdq_remove,\n\t.driver = {\n\t\t.name = \"mtk_cmdq\",\n\t\t.pm = &cmdq_pm_ops,\n\t\t.of_match_table = cmdq_of_ids,\n\t}\n};\n\nstatic int __init cmdq_drv_init(void)\n{\n\treturn platform_driver_register(&cmdq_drv);\n}\n\nstatic void __exit cmdq_drv_exit(void)\n{\n\tplatform_driver_unregister(&cmdq_drv);\n}\n\nsubsys_initcall(cmdq_drv_init);\nmodule_exit(cmdq_drv_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}