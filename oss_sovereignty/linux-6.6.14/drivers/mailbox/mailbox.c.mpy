{
  "module_name": "mailbox.c",
  "hash_id": "4514034943f4b0b9e49be78636e7b5027af1b99f380edcce568a68c2cf924584",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/bitops.h>\n#include <linux/mailbox_client.h>\n#include <linux/mailbox_controller.h>\n#include <linux/of.h>\n\n#include \"mailbox.h\"\n\nstatic LIST_HEAD(mbox_cons);\nstatic DEFINE_MUTEX(con_mutex);\n\nstatic int add_to_rbuf(struct mbox_chan *chan, void *mssg)\n{\n\tint idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\n\t \n\tif (chan->msg_count == MBOX_TX_QUEUE_LEN) {\n\t\tspin_unlock_irqrestore(&chan->lock, flags);\n\t\treturn -ENOBUFS;\n\t}\n\n\tidx = chan->msg_free;\n\tchan->msg_data[idx] = mssg;\n\tchan->msg_count++;\n\n\tif (idx == MBOX_TX_QUEUE_LEN - 1)\n\t\tchan->msg_free = 0;\n\telse\n\t\tchan->msg_free++;\n\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\treturn idx;\n}\n\nstatic void msg_submit(struct mbox_chan *chan)\n{\n\tunsigned count, idx;\n\tunsigned long flags;\n\tvoid *data;\n\tint err = -EBUSY;\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\n\tif (!chan->msg_count || chan->active_req)\n\t\tgoto exit;\n\n\tcount = chan->msg_count;\n\tidx = chan->msg_free;\n\tif (idx >= count)\n\t\tidx -= count;\n\telse\n\t\tidx += MBOX_TX_QUEUE_LEN - count;\n\n\tdata = chan->msg_data[idx];\n\n\tif (chan->cl->tx_prepare)\n\t\tchan->cl->tx_prepare(chan->cl, data);\n\t \n\terr = chan->mbox->ops->send_data(chan, data);\n\tif (!err) {\n\t\tchan->active_req = data;\n\t\tchan->msg_count--;\n\t}\nexit:\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\tif (!err && (chan->txdone_method & TXDONE_BY_POLL)) {\n\t\t \n\t\tspin_lock_irqsave(&chan->mbox->poll_hrt_lock, flags);\n\t\thrtimer_start(&chan->mbox->poll_hrt, 0, HRTIMER_MODE_REL);\n\t\tspin_unlock_irqrestore(&chan->mbox->poll_hrt_lock, flags);\n\t}\n}\n\nstatic void tx_tick(struct mbox_chan *chan, int r)\n{\n\tunsigned long flags;\n\tvoid *mssg;\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\tmssg = chan->active_req;\n\tchan->active_req = NULL;\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\t \n\tmsg_submit(chan);\n\n\tif (!mssg)\n\t\treturn;\n\n\t \n\tif (chan->cl->tx_done)\n\t\tchan->cl->tx_done(chan->cl, mssg, r);\n\n\tif (r != -ETIME && chan->cl->tx_block)\n\t\tcomplete(&chan->tx_complete);\n}\n\nstatic enum hrtimer_restart txdone_hrtimer(struct hrtimer *hrtimer)\n{\n\tstruct mbox_controller *mbox =\n\t\tcontainer_of(hrtimer, struct mbox_controller, poll_hrt);\n\tbool txdone, resched = false;\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tstruct mbox_chan *chan = &mbox->chans[i];\n\n\t\tif (chan->active_req && chan->cl) {\n\t\t\ttxdone = chan->mbox->ops->last_tx_done(chan);\n\t\t\tif (txdone)\n\t\t\t\ttx_tick(chan, 0);\n\t\t\telse\n\t\t\t\tresched = true;\n\t\t}\n\t}\n\n\tif (resched) {\n\t\tspin_lock_irqsave(&mbox->poll_hrt_lock, flags);\n\t\tif (!hrtimer_is_queued(hrtimer))\n\t\t\thrtimer_forward_now(hrtimer, ms_to_ktime(mbox->txpoll_period));\n\t\tspin_unlock_irqrestore(&mbox->poll_hrt_lock, flags);\n\n\t\treturn HRTIMER_RESTART;\n\t}\n\treturn HRTIMER_NORESTART;\n}\n\n \nvoid mbox_chan_received_data(struct mbox_chan *chan, void *mssg)\n{\n\t \n\tif (chan->cl->rx_callback)\n\t\tchan->cl->rx_callback(chan->cl, mssg);\n}\nEXPORT_SYMBOL_GPL(mbox_chan_received_data);\n\n \nvoid mbox_chan_txdone(struct mbox_chan *chan, int r)\n{\n\tif (unlikely(!(chan->txdone_method & TXDONE_BY_IRQ))) {\n\t\tdev_err(chan->mbox->dev,\n\t\t       \"Controller can't run the TX ticker\\n\");\n\t\treturn;\n\t}\n\n\ttx_tick(chan, r);\n}\nEXPORT_SYMBOL_GPL(mbox_chan_txdone);\n\n \nvoid mbox_client_txdone(struct mbox_chan *chan, int r)\n{\n\tif (unlikely(!(chan->txdone_method & TXDONE_BY_ACK))) {\n\t\tdev_err(chan->mbox->dev, \"Client can't run the TX ticker\\n\");\n\t\treturn;\n\t}\n\n\ttx_tick(chan, r);\n}\nEXPORT_SYMBOL_GPL(mbox_client_txdone);\n\n \nbool mbox_client_peek_data(struct mbox_chan *chan)\n{\n\tif (chan->mbox->ops->peek_data)\n\t\treturn chan->mbox->ops->peek_data(chan);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mbox_client_peek_data);\n\n \nint mbox_send_message(struct mbox_chan *chan, void *mssg)\n{\n\tint t;\n\n\tif (!chan || !chan->cl)\n\t\treturn -EINVAL;\n\n\tt = add_to_rbuf(chan, mssg);\n\tif (t < 0) {\n\t\tdev_err(chan->mbox->dev, \"Try increasing MBOX_TX_QUEUE_LEN\\n\");\n\t\treturn t;\n\t}\n\n\tmsg_submit(chan);\n\n\tif (chan->cl->tx_block) {\n\t\tunsigned long wait;\n\t\tint ret;\n\n\t\tif (!chan->cl->tx_tout)  \n\t\t\twait = msecs_to_jiffies(3600000);\n\t\telse\n\t\t\twait = msecs_to_jiffies(chan->cl->tx_tout);\n\n\t\tret = wait_for_completion_timeout(&chan->tx_complete, wait);\n\t\tif (ret == 0) {\n\t\t\tt = -ETIME;\n\t\t\ttx_tick(chan, t);\n\t\t}\n\t}\n\n\treturn t;\n}\nEXPORT_SYMBOL_GPL(mbox_send_message);\n\n \nint mbox_flush(struct mbox_chan *chan, unsigned long timeout)\n{\n\tint ret;\n\n\tif (!chan->mbox->ops->flush)\n\t\treturn -ENOTSUPP;\n\n\tret = chan->mbox->ops->flush(chan, timeout);\n\tif (ret < 0)\n\t\ttx_tick(chan, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mbox_flush);\n\nstatic int __mbox_bind_client(struct mbox_chan *chan, struct mbox_client *cl)\n{\n\tstruct device *dev = cl->dev;\n\tunsigned long flags;\n\tint ret;\n\n\tif (chan->cl || !try_module_get(chan->mbox->dev->driver->owner)) {\n\t\tdev_dbg(dev, \"%s: mailbox not free\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\tchan->msg_free = 0;\n\tchan->msg_count = 0;\n\tchan->active_req = NULL;\n\tchan->cl = cl;\n\tinit_completion(&chan->tx_complete);\n\n\tif (chan->txdone_method\t== TXDONE_BY_POLL && cl->knows_txdone)\n\t\tchan->txdone_method = TXDONE_BY_ACK;\n\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\tif (chan->mbox->ops->startup) {\n\t\tret = chan->mbox->ops->startup(chan);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to startup the chan (%d)\\n\", ret);\n\t\t\tmbox_free_channel(chan);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint mbox_bind_client(struct mbox_chan *chan, struct mbox_client *cl)\n{\n\tint ret;\n\n\tmutex_lock(&con_mutex);\n\tret = __mbox_bind_client(chan, cl);\n\tmutex_unlock(&con_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mbox_bind_client);\n\n \nstruct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)\n{\n\tstruct device *dev = cl->dev;\n\tstruct mbox_controller *mbox;\n\tstruct of_phandle_args spec;\n\tstruct mbox_chan *chan;\n\tint ret;\n\n\tif (!dev || !dev->of_node) {\n\t\tpr_debug(\"%s: No owner device node\\n\", __func__);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tmutex_lock(&con_mutex);\n\n\tif (of_parse_phandle_with_args(dev->of_node, \"mboxes\",\n\t\t\t\t       \"#mbox-cells\", index, &spec)) {\n\t\tdev_dbg(dev, \"%s: can't parse \\\"mboxes\\\" property\\n\", __func__);\n\t\tmutex_unlock(&con_mutex);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tchan = ERR_PTR(-EPROBE_DEFER);\n\tlist_for_each_entry(mbox, &mbox_cons, node)\n\t\tif (mbox->dev->of_node == spec.np) {\n\t\t\tchan = mbox->of_xlate(mbox, &spec);\n\t\t\tif (!IS_ERR(chan))\n\t\t\t\tbreak;\n\t\t}\n\n\tof_node_put(spec.np);\n\n\tif (IS_ERR(chan)) {\n\t\tmutex_unlock(&con_mutex);\n\t\treturn chan;\n\t}\n\n\tret = __mbox_bind_client(chan, cl);\n\tif (ret)\n\t\tchan = ERR_PTR(ret);\n\n\tmutex_unlock(&con_mutex);\n\treturn chan;\n}\nEXPORT_SYMBOL_GPL(mbox_request_channel);\n\nstruct mbox_chan *mbox_request_channel_byname(struct mbox_client *cl,\n\t\t\t\t\t      const char *name)\n{\n\tstruct device_node *np = cl->dev->of_node;\n\tstruct property *prop;\n\tconst char *mbox_name;\n\tint index = 0;\n\n\tif (!np) {\n\t\tdev_err(cl->dev, \"%s() currently only supports DT\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!of_get_property(np, \"mbox-names\", NULL)) {\n\t\tdev_err(cl->dev,\n\t\t\t\"%s() requires an \\\"mbox-names\\\" property\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tof_property_for_each_string(np, \"mbox-names\", prop, mbox_name) {\n\t\tif (!strncmp(name, mbox_name, strlen(name)))\n\t\t\treturn mbox_request_channel(cl, index);\n\t\tindex++;\n\t}\n\n\tdev_err(cl->dev, \"%s() could not locate channel named \\\"%s\\\"\\n\",\n\t\t__func__, name);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(mbox_request_channel_byname);\n\n \nvoid mbox_free_channel(struct mbox_chan *chan)\n{\n\tunsigned long flags;\n\n\tif (!chan || !chan->cl)\n\t\treturn;\n\n\tif (chan->mbox->ops->shutdown)\n\t\tchan->mbox->ops->shutdown(chan);\n\n\t \n\tspin_lock_irqsave(&chan->lock, flags);\n\tchan->cl = NULL;\n\tchan->active_req = NULL;\n\tif (chan->txdone_method == TXDONE_BY_ACK)\n\t\tchan->txdone_method = TXDONE_BY_POLL;\n\n\tmodule_put(chan->mbox->dev->driver->owner);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n}\nEXPORT_SYMBOL_GPL(mbox_free_channel);\n\nstatic struct mbox_chan *\nof_mbox_index_xlate(struct mbox_controller *mbox,\n\t\t    const struct of_phandle_args *sp)\n{\n\tint ind = sp->args[0];\n\n\tif (ind >= mbox->num_chans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &mbox->chans[ind];\n}\n\n \nint mbox_controller_register(struct mbox_controller *mbox)\n{\n\tint i, txdone;\n\n\t \n\tif (!mbox || !mbox->dev || !mbox->ops || !mbox->num_chans)\n\t\treturn -EINVAL;\n\n\tif (mbox->txdone_irq)\n\t\ttxdone = TXDONE_BY_IRQ;\n\telse if (mbox->txdone_poll)\n\t\ttxdone = TXDONE_BY_POLL;\n\telse  \n\t\ttxdone = TXDONE_BY_ACK;\n\n\tif (txdone == TXDONE_BY_POLL) {\n\n\t\tif (!mbox->ops->last_tx_done) {\n\t\t\tdev_err(mbox->dev, \"last_tx_done method is absent\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thrtimer_init(&mbox->poll_hrt, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL);\n\t\tmbox->poll_hrt.function = txdone_hrtimer;\n\t\tspin_lock_init(&mbox->poll_hrt_lock);\n\t}\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tstruct mbox_chan *chan = &mbox->chans[i];\n\n\t\tchan->cl = NULL;\n\t\tchan->mbox = mbox;\n\t\tchan->txdone_method = txdone;\n\t\tspin_lock_init(&chan->lock);\n\t}\n\n\tif (!mbox->of_xlate)\n\t\tmbox->of_xlate = of_mbox_index_xlate;\n\n\tmutex_lock(&con_mutex);\n\tlist_add_tail(&mbox->node, &mbox_cons);\n\tmutex_unlock(&con_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mbox_controller_register);\n\n \nvoid mbox_controller_unregister(struct mbox_controller *mbox)\n{\n\tint i;\n\n\tif (!mbox)\n\t\treturn;\n\n\tmutex_lock(&con_mutex);\n\n\tlist_del(&mbox->node);\n\n\tfor (i = 0; i < mbox->num_chans; i++)\n\t\tmbox_free_channel(&mbox->chans[i]);\n\n\tif (mbox->txdone_poll)\n\t\thrtimer_cancel(&mbox->poll_hrt);\n\n\tmutex_unlock(&con_mutex);\n}\nEXPORT_SYMBOL_GPL(mbox_controller_unregister);\n\nstatic void __devm_mbox_controller_unregister(struct device *dev, void *res)\n{\n\tstruct mbox_controller **mbox = res;\n\n\tmbox_controller_unregister(*mbox);\n}\n\nstatic int devm_mbox_controller_match(struct device *dev, void *res, void *data)\n{\n\tstruct mbox_controller **mbox = res;\n\n\tif (WARN_ON(!mbox || !*mbox))\n\t\treturn 0;\n\n\treturn *mbox == data;\n}\n\n \nint devm_mbox_controller_register(struct device *dev,\n\t\t\t\t  struct mbox_controller *mbox)\n{\n\tstruct mbox_controller **ptr;\n\tint err;\n\n\tptr = devres_alloc(__devm_mbox_controller_unregister, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\terr = mbox_controller_register(mbox);\n\tif (err < 0) {\n\t\tdevres_free(ptr);\n\t\treturn err;\n\t}\n\n\tdevres_add(dev, ptr);\n\t*ptr = mbox;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_mbox_controller_register);\n\n \nvoid devm_mbox_controller_unregister(struct device *dev, struct mbox_controller *mbox)\n{\n\tWARN_ON(devres_release(dev, __devm_mbox_controller_unregister,\n\t\t\t       devm_mbox_controller_match, mbox));\n}\nEXPORT_SYMBOL_GPL(devm_mbox_controller_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}