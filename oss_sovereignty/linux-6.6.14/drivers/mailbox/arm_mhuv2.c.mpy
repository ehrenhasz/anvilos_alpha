{
  "module_name": "arm_mhuv2.c",
  "hash_id": "70c9f3c004ff7be3e7bbabee396c272b737e418491005ea76b743e5527131f03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/arm_mhuv2.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/interrupt.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox/arm_mhuv2_message.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/spinlock.h>\n\n \n\n \n#define MHUV2_CH_WN_MAX\t\t\t124\n \n#define MHUV2_CMB_INT_ST_REG_CNT\t4\n#define MHUV2_STAT_BYTES\t\t(sizeof(u32))\n#define MHUV2_STAT_BITS\t\t\t(MHUV2_STAT_BYTES * __CHAR_BIT__)\n\n#define LSB_MASK(n)\t\t\t((1 << (n * __CHAR_BIT__)) - 1)\n#define MHUV2_PROTOCOL_PROP\t\t\"arm,mhuv2-protocols\"\n\n \nstruct mhu_cfg_t {\n\tu32 num_ch : 7;\n\tu32 pad : 25;\n} __packed;\n\n \nstruct int_st_t {\n\tu32 nr2r : 1;\n\tu32 r2nr : 1;\n\tu32 pad : 30;\n} __packed;\n\n \nstruct int_clr_t {\n\tu32 nr2r : 1;\n\tu32 r2nr : 1;\n\tu32 pad : 30;\n} __packed;\n\n \nstruct int_en_t {\n\tu32 r2nr : 1;\n\tu32 nr2r : 1;\n\tu32 chcomb : 1;\n\tu32 pad : 29;\n} __packed;\n\n \nstruct iidr_t {\n\tu32 implementer : 12;\n\tu32 revision : 4;\n\tu32 variant : 4;\n\tu32 product_id : 12;\n} __packed;\n\n \nstruct aidr_t {\n\tu32 arch_minor_rev : 4;\n\tu32 arch_major_rev : 4;\n\tu32 pad : 24;\n} __packed;\n\n \nstruct mhu2_send_ch_wn_reg {\n\tu32 stat;\n\tu8 pad1[0x0C - 0x04];\n\tu32 stat_set;\n\tu32 int_st;\n\tu32 int_clr;\n\tu32 int_en;\n\tu8 pad2[0x20 - 0x1C];\n} __packed;\n\n \nstruct mhu2_send_frame_reg {\n\tstruct mhu2_send_ch_wn_reg ch_wn[MHUV2_CH_WN_MAX];\n\tstruct mhu_cfg_t mhu_cfg;\n\tu32 resp_cfg;\n\tu32 access_request;\n\tu32 access_ready;\n\tstruct int_st_t int_st;\n\tstruct int_clr_t int_clr;\n\tstruct int_en_t int_en;\n\tu32 reserved0;\n\tu32 chcomb_int_st[MHUV2_CMB_INT_ST_REG_CNT];\n\tu8 pad[0xFC8 - 0xFB0];\n\tstruct iidr_t iidr;\n\tstruct aidr_t aidr;\n} __packed;\n\n \nstruct mhu2_recv_ch_wn_reg {\n\tu32 stat;\n\tu32 stat_masked;\n\tu32 stat_clear;\n\tu8 reserved0[0x10 - 0x0C];\n\tu32 mask;\n\tu32 mask_set;\n\tu32 mask_clear;\n\tu8 pad[0x20 - 0x1C];\n} __packed;\n\n \nstruct mhu2_recv_frame_reg {\n\tstruct mhu2_recv_ch_wn_reg ch_wn[MHUV2_CH_WN_MAX];\n\tstruct mhu_cfg_t mhu_cfg;\n\tu8 reserved0[0xF90 - 0xF84];\n\tstruct int_st_t int_st;\n\tstruct int_clr_t int_clr;\n\tstruct int_en_t int_en;\n\tu32 pad;\n\tu32 chcomb_int_st[MHUV2_CMB_INT_ST_REG_CNT];\n\tu8 reserved2[0xFC8 - 0xFB0];\n\tstruct iidr_t iidr;\n\tstruct aidr_t aidr;\n} __packed;\n\n\n \n\nenum mhuv2_transport_protocol {\n\tDOORBELL = 0,\n\tDATA_TRANSFER = 1\n};\n\nenum mhuv2_frame {\n\tRECEIVER_FRAME,\n\tSENDER_FRAME\n};\n\n \nstruct mhuv2 {\n\tstruct mbox_controller mbox;\n\tunion {\n\t\tstruct mhu2_send_frame_reg __iomem *send;\n\t\tstruct mhu2_recv_frame_reg __iomem *recv;\n\t};\n\tenum mhuv2_frame frame;\n\tunsigned int irq;\n\tunsigned int windows;\n\tunsigned int minor;\n\tunsigned int length;\n\tu32 *protocols;\n\n\tspinlock_t doorbell_pending_lock;\n};\n\n#define mhu_from_mbox(_mbox) container_of(_mbox, struct mhuv2, mbox)\n\n \nstruct mhuv2_protocol_ops {\n\tint (*rx_startup)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\tvoid (*rx_shutdown)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\tvoid *(*read_data)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\n\tvoid (*tx_startup)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\tvoid (*tx_shutdown)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\tint (*last_tx_done)(struct mhuv2 *mhu, struct mbox_chan *chan);\n\tint (*send_data)(struct mhuv2 *mhu, struct mbox_chan *chan, void *arg);\n};\n\n \nstruct mhuv2_mbox_chan_priv {\n\tconst struct mhuv2_protocol_ops *ops;\n\tu32 ch_wn_idx;\n\tunion {\n\t\tu32 windows;\n\t\tstruct {\n\t\t\tu32 doorbell;\n\t\t\tu32 pending;\n\t\t};\n\t};\n};\n\n \n#define readl_relaxed_bitfield(_regptr, _type, _field)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu32 _regval;\t\t\t\t\t\t\\\n\t\t_regval = readl_relaxed((_regptr));\t\t\t\\\n\t\t(*(_type *)(&_regval))._field;\t\t\t\t\\\n\t})\n\n \n#define writel_relaxed_bitfield(_value, _regptr, _type, _field)\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu32 _regval;\t\t\t\t\t\t\\\n\t\t_regval = readl_relaxed(_regptr);\t\t\t\\\n\t\t(*(_type *)(&_regval))._field = _value;\t\t\t\\\n\t\twritel_relaxed(_regval, _regptr);\t\t\t\\\n\t})\n\n\n \n\nstatic int mhuv2_doorbell_rx_startup(struct mhuv2 *mhu, struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\twritel_relaxed(BIT(priv->doorbell),\n\t\t       &mhu->recv->ch_wn[priv->ch_wn_idx].mask_clear);\n\treturn 0;\n}\n\nstatic void mhuv2_doorbell_rx_shutdown(struct mhuv2 *mhu,\n\t\t\t\t       struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\twritel_relaxed(BIT(priv->doorbell),\n\t\t       &mhu->recv->ch_wn[priv->ch_wn_idx].mask_set);\n}\n\nstatic void *mhuv2_doorbell_read_data(struct mhuv2 *mhu, struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\twritel_relaxed(BIT(priv->doorbell),\n\t\t       &mhu->recv->ch_wn[priv->ch_wn_idx].stat_clear);\n\treturn NULL;\n}\n\nstatic int mhuv2_doorbell_last_tx_done(struct mhuv2 *mhu,\n\t\t\t\t       struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\treturn !(readl_relaxed(&mhu->send->ch_wn[priv->ch_wn_idx].stat) &\n\t\t BIT(priv->doorbell));\n}\n\nstatic int mhuv2_doorbell_send_data(struct mhuv2 *mhu, struct mbox_chan *chan,\n\t\t\t\t    void *arg)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mhu->doorbell_pending_lock, flags);\n\n\tpriv->pending = 1;\n\twritel_relaxed(BIT(priv->doorbell),\n\t\t       &mhu->send->ch_wn[priv->ch_wn_idx].stat_set);\n\n\tspin_unlock_irqrestore(&mhu->doorbell_pending_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct mhuv2_protocol_ops mhuv2_doorbell_ops = {\n\t.rx_startup = mhuv2_doorbell_rx_startup,\n\t.rx_shutdown = mhuv2_doorbell_rx_shutdown,\n\t.read_data = mhuv2_doorbell_read_data,\n\t.last_tx_done = mhuv2_doorbell_last_tx_done,\n\t.send_data = mhuv2_doorbell_send_data,\n};\n#define IS_PROTOCOL_DOORBELL(_priv) (_priv->ops == &mhuv2_doorbell_ops)\n\n \n\nstatic int mhuv2_data_transfer_rx_startup(struct mhuv2 *mhu,\n\t\t\t\t\t  struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint i = priv->ch_wn_idx + priv->windows - 1;\n\n\t \n\twritel_relaxed(0xFFFFFFFF, &mhu->recv->ch_wn[i].mask_clear);\n\treturn 0;\n}\n\nstatic void mhuv2_data_transfer_rx_shutdown(struct mhuv2 *mhu,\n\t\t\t\t\t    struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint i = priv->ch_wn_idx + priv->windows - 1;\n\n\twritel_relaxed(0xFFFFFFFF, &mhu->recv->ch_wn[i].mask_set);\n}\n\nstatic void *mhuv2_data_transfer_read_data(struct mhuv2 *mhu,\n\t\t\t\t\t   struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tconst int windows = priv->windows;\n\tstruct arm_mhuv2_mbox_msg *msg;\n\tu32 *data;\n\tint i, idx;\n\n\tmsg = kzalloc(sizeof(*msg) + windows * MHUV2_STAT_BYTES, GFP_KERNEL);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = msg->data = msg + 1;\n\tmsg->len = windows * MHUV2_STAT_BYTES;\n\n\t \n\tfor (i = 0; i < windows; i++) {\n\t\tidx = priv->ch_wn_idx + i;\n\t\tdata[windows - 1 - i] = readl_relaxed(&mhu->recv->ch_wn[idx].stat);\n\t\twritel_relaxed(0xFFFFFFFF, &mhu->recv->ch_wn[idx].stat_clear);\n\t}\n\n\treturn msg;\n}\n\nstatic void mhuv2_data_transfer_tx_startup(struct mhuv2 *mhu,\n\t\t\t\t\t   struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint i = priv->ch_wn_idx + priv->windows - 1;\n\n\t \n\tif (mhu->minor) {\n\t\twritel_relaxed(0x1, &mhu->send->ch_wn[i].int_clr);\n\t\twritel_relaxed(0x1, &mhu->send->ch_wn[i].int_en);\n\t}\n}\n\nstatic void mhuv2_data_transfer_tx_shutdown(struct mhuv2 *mhu,\n\t\t\t\t\t    struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint i = priv->ch_wn_idx + priv->windows - 1;\n\n\tif (mhu->minor)\n\t\twritel_relaxed(0x0, &mhu->send->ch_wn[i].int_en);\n}\n\nstatic int mhuv2_data_transfer_last_tx_done(struct mhuv2 *mhu,\n\t\t\t\t\t    struct mbox_chan *chan)\n{\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint i = priv->ch_wn_idx + priv->windows - 1;\n\n\t \n\treturn !readl_relaxed(&mhu->send->ch_wn[i].stat);\n}\n\n \nstatic int mhuv2_data_transfer_send_data(struct mhuv2 *mhu,\n\t\t\t\t\t struct mbox_chan *chan, void *arg)\n{\n\tconst struct arm_mhuv2_mbox_msg *msg = arg;\n\tint bytes_left = msg->len, bytes_to_send, bytes_in_round, i;\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\tint windows = priv->windows;\n\tu32 *data = msg->data, word;\n\n\twhile (bytes_left) {\n\t\tif (!data[0]) {\n\t\t\tdev_err(mhu->mbox.dev, \"Data aligned at first window can't be zero to guarantee interrupt generation at receiver\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twhile(!mhuv2_data_transfer_last_tx_done(mhu, chan))\n\t\t\tcontinue;\n\n\t\tbytes_in_round = min(bytes_left, (int)(windows * MHUV2_STAT_BYTES));\n\n\t\tfor (i = windows - 1; i >= 0; i--) {\n\t\t\t \n\t\t\tif (unlikely(bytes_in_round <= i * MHUV2_STAT_BYTES))\n\t\t\t\tcontinue;\n\n\t\t\tword = data[i];\n\t\t\tbytes_to_send = bytes_in_round & (MHUV2_STAT_BYTES - 1);\n\t\t\tif (unlikely(bytes_to_send))\n\t\t\t\tword &= LSB_MASK(bytes_to_send);\n\t\t\telse\n\t\t\t\tbytes_to_send = MHUV2_STAT_BYTES;\n\n\t\t\twritel_relaxed(word, &mhu->send->ch_wn[priv->ch_wn_idx + windows - 1 - i].stat_set);\n\t\t\tbytes_left -= bytes_to_send;\n\t\t\tbytes_in_round -= bytes_to_send;\n\t\t}\n\n\t\tdata += windows;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mhuv2_protocol_ops mhuv2_data_transfer_ops = {\n\t.rx_startup = mhuv2_data_transfer_rx_startup,\n\t.rx_shutdown = mhuv2_data_transfer_rx_shutdown,\n\t.read_data = mhuv2_data_transfer_read_data,\n\t.tx_startup = mhuv2_data_transfer_tx_startup,\n\t.tx_shutdown = mhuv2_data_transfer_tx_shutdown,\n\t.last_tx_done = mhuv2_data_transfer_last_tx_done,\n\t.send_data = mhuv2_data_transfer_send_data,\n};\n\n \n\nstatic struct mbox_chan *get_irq_chan_comb(struct mhuv2 *mhu, u32 __iomem *reg)\n{\n\tstruct mbox_chan *chans = mhu->mbox.chans;\n\tint channel = 0, i, offset = 0, windows, protocol, ch_wn;\n\tu32 stat;\n\n\tfor (i = 0; i < MHUV2_CMB_INT_ST_REG_CNT; i++) {\n\t\tstat = readl_relaxed(reg + i);\n\t\tif (!stat)\n\t\t\tcontinue;\n\n\t\tch_wn = i * MHUV2_STAT_BITS + __builtin_ctz(stat);\n\n\t\tfor (i = 0; i < mhu->length; i += 2) {\n\t\t\tprotocol = mhu->protocols[i];\n\t\t\twindows = mhu->protocols[i + 1];\n\n\t\t\tif (ch_wn >= offset + windows) {\n\t\t\t\tif (protocol == DOORBELL)\n\t\t\t\t\tchannel += MHUV2_STAT_BITS * windows;\n\t\t\t\telse\n\t\t\t\t\tchannel++;\n\n\t\t\t\toffset += windows;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (protocol == DOORBELL)\n\t\t\t\tchannel += MHUV2_STAT_BITS * (ch_wn - offset);\n\n\t\t\treturn &chans[channel];\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EIO);\n}\n\nstatic irqreturn_t mhuv2_sender_interrupt(int irq, void *data)\n{\n\tstruct mhuv2 *mhu = data;\n\tstruct device *dev = mhu->mbox.dev;\n\tstruct mhuv2_mbox_chan_priv *priv;\n\tstruct mbox_chan *chan;\n\tunsigned long flags;\n\tint i, found = 0;\n\tu32 stat;\n\n\tchan = get_irq_chan_comb(mhu, mhu->send->chcomb_int_st);\n\tif (IS_ERR(chan)) {\n\t\tdev_warn(dev, \"Failed to find channel for the Tx interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\tpriv = chan->con_priv;\n\n\tif (!IS_PROTOCOL_DOORBELL(priv)) {\n\t\twritel_relaxed(1, &mhu->send->ch_wn[priv->ch_wn_idx + priv->windows - 1].int_clr);\n\n\t\tif (chan->cl) {\n\t\t\tmbox_chan_txdone(chan, 0);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tdev_warn(dev, \"Tx interrupt Received on channel (%u) not currently attached to a mailbox client\\n\",\n\t\t\t priv->ch_wn_idx);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel_relaxed(1, &mhu->send->ch_wn[priv->ch_wn_idx].int_clr);\n\n\t \n\tspin_lock_irqsave(&mhu->doorbell_pending_lock, flags);\n\n\t \n\tstat = readl_relaxed(&mhu->send->ch_wn[priv->ch_wn_idx].stat);\n\n\tfor (i = 0; i < MHUV2_STAT_BITS; i++) {\n\t\tpriv = chan[i].con_priv;\n\n\t\t \n\t\tif (priv->pending ^ ((stat >> i) & 0x1)) {\n\t\t\tBUG_ON(!priv->pending);\n\n\t\t\tif (!chan->cl) {\n\t\t\t\tdev_warn(dev, \"Tx interrupt received on doorbell (%u : %u) channel not currently attached to a mailbox client\\n\",\n\t\t\t\t\t priv->ch_wn_idx, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmbox_chan_txdone(&chan[i], 0);\n\t\t\tpriv->pending = 0;\n\t\t\tfound++;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&mhu->doorbell_pending_lock, flags);\n\n\tif (!found) {\n\t\t \n\t\tdev_dbg(dev, \"Couldn't find the doorbell (%u) for the Tx interrupt interrupt\\n\",\n\t\t\tpriv->ch_wn_idx);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct mbox_chan *get_irq_chan_comb_rx(struct mhuv2 *mhu)\n{\n\tstruct mhuv2_mbox_chan_priv *priv;\n\tstruct mbox_chan *chan;\n\tu32 stat;\n\n\tchan = get_irq_chan_comb(mhu, mhu->recv->chcomb_int_st);\n\tif (IS_ERR(chan))\n\t\treturn chan;\n\n\tpriv = chan->con_priv;\n\tif (!IS_PROTOCOL_DOORBELL(priv))\n\t\treturn chan;\n\n\t \n\tstat = readl_relaxed(&mhu->recv->ch_wn[priv->ch_wn_idx].stat_masked);\n\tBUG_ON(!stat);\n\n\treturn chan + __builtin_ctz(stat);\n}\n\nstatic struct mbox_chan *get_irq_chan_stat_rx(struct mhuv2 *mhu)\n{\n\tstruct mbox_chan *chans = mhu->mbox.chans;\n\tstruct mhuv2_mbox_chan_priv *priv;\n\tu32 stat;\n\tint i = 0;\n\n\twhile (i < mhu->mbox.num_chans) {\n\t\tpriv = chans[i].con_priv;\n\t\tstat = readl_relaxed(&mhu->recv->ch_wn[priv->ch_wn_idx].stat_masked);\n\n\t\tif (stat) {\n\t\t\tif (IS_PROTOCOL_DOORBELL(priv))\n\t\t\t\ti += __builtin_ctz(stat);\n\t\t\treturn &chans[i];\n\t\t}\n\n\t\ti += IS_PROTOCOL_DOORBELL(priv) ? MHUV2_STAT_BITS : 1;\n\t}\n\n\treturn ERR_PTR(-EIO);\n}\n\nstatic struct mbox_chan *get_irq_chan_rx(struct mhuv2 *mhu)\n{\n\tif (!mhu->minor)\n\t\treturn get_irq_chan_stat_rx(mhu);\n\n\treturn get_irq_chan_comb_rx(mhu);\n}\n\nstatic irqreturn_t mhuv2_receiver_interrupt(int irq, void *arg)\n{\n\tstruct mhuv2 *mhu = arg;\n\tstruct mbox_chan *chan = get_irq_chan_rx(mhu);\n\tstruct device *dev = mhu->mbox.dev;\n\tstruct mhuv2_mbox_chan_priv *priv;\n\tint ret = IRQ_NONE;\n\tvoid *data;\n\n\tif (IS_ERR(chan)) {\n\t\tdev_warn(dev, \"Failed to find channel for the rx interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\tpriv = chan->con_priv;\n\n\t \n\tdata = priv->ops->read_data(mhu, chan);\n\n\tif (!chan->cl) {\n\t\tdev_warn(dev, \"Received data on channel (%u) not currently attached to a mailbox client\\n\",\n\t\t\t priv->ch_wn_idx);\n\t} else if (IS_ERR(data)) {\n\t\tdev_err(dev, \"Failed to read data: %lu\\n\", PTR_ERR(data));\n\t} else {\n\t\tmbox_chan_received_data(chan, data);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (!IS_ERR(data))\n\t\tkfree(data);\n\n\treturn ret;\n}\n\n \nstatic bool mhuv2_sender_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\treturn priv->ops->last_tx_done(mhu, chan);\n}\n\nstatic int mhuv2_sender_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\tif (!priv->ops->last_tx_done(mhu, chan))\n\t\treturn -EBUSY;\n\n\treturn priv->ops->send_data(mhu, chan, data);\n}\n\nstatic int mhuv2_sender_startup(struct mbox_chan *chan)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\tif (priv->ops->tx_startup)\n\t\tpriv->ops->tx_startup(mhu, chan);\n\treturn 0;\n}\n\nstatic void mhuv2_sender_shutdown(struct mbox_chan *chan)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\tif (priv->ops->tx_shutdown)\n\t\tpriv->ops->tx_shutdown(mhu, chan);\n}\n\nstatic const struct mbox_chan_ops mhuv2_sender_ops = {\n\t.send_data = mhuv2_sender_send_data,\n\t.startup = mhuv2_sender_startup,\n\t.shutdown = mhuv2_sender_shutdown,\n\t.last_tx_done = mhuv2_sender_last_tx_done,\n};\n\nstatic int mhuv2_receiver_startup(struct mbox_chan *chan)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\treturn priv->ops->rx_startup(mhu, chan);\n}\n\nstatic void mhuv2_receiver_shutdown(struct mbox_chan *chan)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(chan->mbox);\n\tstruct mhuv2_mbox_chan_priv *priv = chan->con_priv;\n\n\tpriv->ops->rx_shutdown(mhu, chan);\n}\n\nstatic int mhuv2_receiver_send_data(struct mbox_chan *chan, void *data)\n{\n\tdev_err(chan->mbox->dev,\n\t\t\"Trying to transmit on a receiver MHU frame\\n\");\n\treturn -EIO;\n}\n\nstatic bool mhuv2_receiver_last_tx_done(struct mbox_chan *chan)\n{\n\tdev_err(chan->mbox->dev, \"Trying to Tx poll on a receiver MHU frame\\n\");\n\treturn true;\n}\n\nstatic const struct mbox_chan_ops mhuv2_receiver_ops = {\n\t.send_data = mhuv2_receiver_send_data,\n\t.startup = mhuv2_receiver_startup,\n\t.shutdown = mhuv2_receiver_shutdown,\n\t.last_tx_done = mhuv2_receiver_last_tx_done,\n};\n\nstatic struct mbox_chan *mhuv2_mbox_of_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t     const struct of_phandle_args *pa)\n{\n\tstruct mhuv2 *mhu = mhu_from_mbox(mbox);\n\tstruct mbox_chan *chans = mbox->chans;\n\tint channel = 0, i, offset, doorbell, protocol, windows;\n\n\tif (pa->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\toffset = pa->args[0];\n\tdoorbell = pa->args[1];\n\tif (doorbell >= MHUV2_STAT_BITS)\n\t\tgoto out;\n\n\tfor (i = 0; i < mhu->length; i += 2) {\n\t\tprotocol = mhu->protocols[i];\n\t\twindows = mhu->protocols[i + 1];\n\n\t\tif (protocol == DOORBELL) {\n\t\t\tif (offset < windows)\n\t\t\t\treturn &chans[channel + MHUV2_STAT_BITS * offset + doorbell];\n\n\t\t\tchannel += MHUV2_STAT_BITS * windows;\n\t\t\toffset -= windows;\n\t\t} else {\n\t\t\tif (offset == 0) {\n\t\t\t\tif (doorbell)\n\t\t\t\t\tgoto out;\n\n\t\t\t\treturn &chans[channel];\n\t\t\t}\n\n\t\t\tchannel++;\n\t\t\toffset--;\n\t\t}\n\t}\n\nout:\n\tdev_err(mbox->dev, \"Couldn't xlate to a valid channel (%d: %d)\\n\",\n\t\tpa->args[0], doorbell);\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int mhuv2_verify_protocol(struct mhuv2 *mhu)\n{\n\tstruct device *dev = mhu->mbox.dev;\n\tint protocol, windows, channels = 0, total_windows = 0, i;\n\n\tfor (i = 0; i < mhu->length; i += 2) {\n\t\tprotocol = mhu->protocols[i];\n\t\twindows = mhu->protocols[i + 1];\n\n\t\tif (!windows) {\n\t\t\tdev_err(dev, \"Window size can't be zero (%d)\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal_windows += windows;\n\n\t\tif (protocol == DOORBELL) {\n\t\t\tchannels += MHUV2_STAT_BITS * windows;\n\t\t} else if (protocol == DATA_TRANSFER) {\n\t\t\tchannels++;\n\t\t} else {\n\t\t\tdev_err(dev, \"Invalid protocol (%d) present in %s property at index %d\\n\",\n\t\t\t\tprotocol, MHUV2_PROTOCOL_PROP, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (total_windows > mhu->windows) {\n\t\tdev_err(dev, \"Channel windows can't be more than what's implemented by the hardware ( %d: %d)\\n\",\n\t\t\ttotal_windows, mhu->windows);\n\t\treturn -EINVAL;\n\t}\n\n\tmhu->mbox.num_chans = channels;\n\treturn 0;\n}\n\nstatic int mhuv2_allocate_channels(struct mhuv2 *mhu)\n{\n\tstruct mbox_controller *mbox = &mhu->mbox;\n\tstruct mhuv2_mbox_chan_priv *priv;\n\tstruct device *dev = mbox->dev;\n\tstruct mbox_chan *chans;\n\tint protocol, windows = 0, next_window = 0, i, j, k;\n\n\tchans = devm_kcalloc(dev, mbox->num_chans, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tmbox->chans = chans;\n\n\tfor (i = 0; i < mhu->length; i += 2) {\n\t\tnext_window += windows;\n\n\t\tprotocol = mhu->protocols[i];\n\t\twindows = mhu->protocols[i + 1];\n\n\t\tif (protocol == DATA_TRANSFER) {\n\t\t\tpriv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);\n\t\t\tif (!priv)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpriv->ch_wn_idx = next_window;\n\t\t\tpriv->ops = &mhuv2_data_transfer_ops;\n\t\t\tpriv->windows = windows;\n\t\t\tchans++->con_priv = priv;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < windows; j++) {\n\t\t\tfor (k = 0; k < MHUV2_STAT_BITS; k++) {\n\t\t\t\tpriv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);\n\t\t\t\tif (!priv)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tpriv->ch_wn_idx = next_window + j;\n\t\t\t\tpriv->ops = &mhuv2_doorbell_ops;\n\t\t\t\tpriv->doorbell = k;\n\t\t\t\tchans++->con_priv = priv;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mhu->frame == SENDER_FRAME && mhu->minor)\n\t\t\t\twritel_relaxed(0x1, &mhu->send->ch_wn[priv->ch_wn_idx].int_en);\n\t\t}\n\t}\n\n\t \n\tBUG_ON(chans - mbox->chans != mbox->num_chans);\n\n\treturn 0;\n}\n\nstatic int mhuv2_parse_channels(struct mhuv2 *mhu)\n{\n\tstruct device *dev = mhu->mbox.dev;\n\tconst struct device_node *np = dev->of_node;\n\tint ret, count;\n\tu32 *protocols;\n\n\tcount = of_property_count_u32_elems(np, MHUV2_PROTOCOL_PROP);\n\tif (count <= 0 || count % 2) {\n\t\tdev_err(dev, \"Invalid %s property (%d)\\n\", MHUV2_PROTOCOL_PROP,\n\t\t\tcount);\n\t\treturn -EINVAL;\n\t}\n\n\tprotocols = devm_kmalloc_array(dev, count, sizeof(*protocols), GFP_KERNEL);\n\tif (!protocols)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, MHUV2_PROTOCOL_PROP, protocols, count);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read %s property: %d\\n\",\n\t\t\tMHUV2_PROTOCOL_PROP, ret);\n\t\treturn ret;\n\t}\n\n\tmhu->protocols = protocols;\n\tmhu->length = count;\n\n\tret = mhuv2_verify_protocol(mhu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mhuv2_allocate_channels(mhu);\n}\n\nstatic int mhuv2_tx_init(struct amba_device *adev, struct mhuv2 *mhu,\n\t\t\t void __iomem *reg)\n{\n\tstruct device *dev = mhu->mbox.dev;\n\tint ret, i;\n\n\tmhu->frame = SENDER_FRAME;\n\tmhu->mbox.ops = &mhuv2_sender_ops;\n\tmhu->send = reg;\n\n\tmhu->windows = readl_relaxed_bitfield(&mhu->send->mhu_cfg, struct mhu_cfg_t, num_ch);\n\tmhu->minor = readl_relaxed_bitfield(&mhu->send->aidr, struct aidr_t, arch_minor_rev);\n\n\tspin_lock_init(&mhu->doorbell_pending_lock);\n\n\t \n\tif (mhu->minor && adev->irq[0]) {\n\t\tret = devm_request_threaded_irq(dev, adev->irq[0], NULL,\n\t\t\t\t\t\tmhuv2_sender_interrupt,\n\t\t\t\t\t\tIRQF_ONESHOT, \"mhuv2-tx\", mhu);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request tx IRQ, fallback to polling mode: %d\\n\",\n\t\t\t\tret);\n\t\t} else {\n\t\t\tmhu->mbox.txdone_irq = true;\n\t\t\tmhu->mbox.txdone_poll = false;\n\t\t\tmhu->irq = adev->irq[0];\n\n\t\t\twritel_relaxed_bitfield(1, &mhu->send->int_en, struct int_en_t, chcomb);\n\n\t\t\t \n\t\t\tfor (i = 0; i < mhu->windows; i++)\n\t\t\t\twritel_relaxed(0x0, &mhu->send->ch_wn[i].int_en);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmhu->mbox.txdone_irq = false;\n\tmhu->mbox.txdone_poll = true;\n\tmhu->mbox.txpoll_period = 1;\n\nout:\n\t \n\twritel_relaxed(0x1, &mhu->send->access_request);\n\twhile (!readl_relaxed(&mhu->send->access_ready))\n\t\tcontinue;\n\n\treturn 0;\n}\n\nstatic int mhuv2_rx_init(struct amba_device *adev, struct mhuv2 *mhu,\n\t\t\t void __iomem *reg)\n{\n\tstruct device *dev = mhu->mbox.dev;\n\tint ret, i;\n\n\tmhu->frame = RECEIVER_FRAME;\n\tmhu->mbox.ops = &mhuv2_receiver_ops;\n\tmhu->recv = reg;\n\n\tmhu->windows = readl_relaxed_bitfield(&mhu->recv->mhu_cfg, struct mhu_cfg_t, num_ch);\n\tmhu->minor = readl_relaxed_bitfield(&mhu->recv->aidr, struct aidr_t, arch_minor_rev);\n\n\tmhu->irq = adev->irq[0];\n\tif (!mhu->irq) {\n\t\tdev_err(dev, \"Missing receiver IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_threaded_irq(dev, mhu->irq, NULL,\n\t\t\t\t\tmhuv2_receiver_interrupt, IRQF_ONESHOT,\n\t\t\t\t\t\"mhuv2-rx\", mhu);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request rx IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < mhu->windows; i++)\n\t\twritel_relaxed(0xFFFFFFFF, &mhu->recv->ch_wn[i].mask_set);\n\n\tif (mhu->minor)\n\t\twritel_relaxed_bitfield(1, &mhu->recv->int_en, struct int_en_t, chcomb);\n\n\treturn 0;\n}\n\nstatic int mhuv2_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tconst struct device_node *np = dev->of_node;\n\tstruct mhuv2 *mhu;\n\tvoid __iomem *reg;\n\tint ret = -EINVAL;\n\n\treg = devm_of_iomap(dev, dev->of_node, 0, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tmhu = devm_kzalloc(dev, sizeof(*mhu), GFP_KERNEL);\n\tif (!mhu)\n\t\treturn -ENOMEM;\n\n\tmhu->mbox.dev = dev;\n\tmhu->mbox.of_xlate = mhuv2_mbox_of_xlate;\n\n\tif (of_device_is_compatible(np, \"arm,mhuv2-tx\"))\n\t\tret = mhuv2_tx_init(adev, mhu, reg);\n\telse if (of_device_is_compatible(np, \"arm,mhuv2-rx\"))\n\t\tret = mhuv2_rx_init(adev, mhu, reg);\n\telse\n\t\tdev_err(dev, \"Invalid compatible property\\n\");\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tBUG_ON(!mhu->windows);\n\n\tret = mhuv2_parse_channels(mhu);\n\tif (ret)\n\t\treturn ret;\n\n\tamba_set_drvdata(adev, mhu);\n\n\tret = devm_mbox_controller_register(dev, &mhu->mbox);\n\tif (ret)\n\t\tdev_err(dev, \"failed to register ARM MHUv2 driver %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mhuv2_remove(struct amba_device *adev)\n{\n\tstruct mhuv2 *mhu = amba_get_drvdata(adev);\n\n\tif (mhu->frame == SENDER_FRAME)\n\t\twritel_relaxed(0x0, &mhu->send->access_request);\n}\n\nstatic struct amba_id mhuv2_ids[] = {\n\t{\n\t\t \n\t\t.id = 0xbb0d1,\n\t\t.mask = 0xfffff,\n\t},\n\t{\n\t\t \n\t\t.id = 0xbb076,\n\t\t.mask = 0xfffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, mhuv2_ids);\n\nstatic struct amba_driver mhuv2_driver = {\n\t.drv = {\n\t\t.name\t= \"arm-mhuv2\",\n\t},\n\t.id_table\t= mhuv2_ids,\n\t.probe\t\t= mhuv2_probe,\n\t.remove\t\t= mhuv2_remove,\n};\nmodule_amba_driver(mhuv2_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ARM MHUv2 Driver\");\nMODULE_AUTHOR(\"Viresh Kumar <viresh.kumar@linaro.org>\");\nMODULE_AUTHOR(\"Tushar Khandelwal <tushar.khandelwal@arm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}