{
  "module_name": "hi6220-mailbox.c",
  "hash_id": "f9054e7d0f16e61b3fa0b01d3941f6daca7a496a25fdf277d063f7843e4c43c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/hi6220-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kfifo.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define MBOX_CHAN_MAX\t\t\t32\n\n#define MBOX_TX\t\t\t\t0x1\n\n \n#define MBOX_MSG_LEN\t\t\t8\n\n \n#define MBOX_OFF(m)\t\t\t(0x40 * (m))\n#define MBOX_MODE_REG(m)\t\t(MBOX_OFF(m) + 0x0)\n#define MBOX_DATA_REG(m)\t\t(MBOX_OFF(m) + 0x4)\n\n#define MBOX_STATE_MASK\t\t\t(0xF << 4)\n#define MBOX_STATE_IDLE\t\t\t(0x1 << 4)\n#define MBOX_STATE_TX\t\t\t(0x2 << 4)\n#define MBOX_STATE_RX\t\t\t(0x4 << 4)\n#define MBOX_STATE_ACK\t\t\t(0x8 << 4)\n#define MBOX_ACK_CONFIG_MASK\t\t(0x1 << 0)\n#define MBOX_ACK_AUTOMATIC\t\t(0x1 << 0)\n#define MBOX_ACK_IRQ\t\t\t(0x0 << 0)\n\n \n#define ACK_INT_RAW_REG(i)\t\t((i) + 0x400)\n#define ACK_INT_MSK_REG(i)\t\t((i) + 0x404)\n#define ACK_INT_STAT_REG(i)\t\t((i) + 0x408)\n#define ACK_INT_CLR_REG(i)\t\t((i) + 0x40c)\n#define ACK_INT_ENA_REG(i)\t\t((i) + 0x500)\n#define ACK_INT_DIS_REG(i)\t\t((i) + 0x504)\n#define DST_INT_RAW_REG(i)\t\t((i) + 0x420)\n\n\nstruct hi6220_mbox_chan {\n\n\t \n\tunsigned int dir, dst_irq, ack_irq;\n\tunsigned int slot;\n\n\tstruct hi6220_mbox *parent;\n};\n\nstruct hi6220_mbox {\n\tstruct device *dev;\n\n\tint irq;\n\n\t \n\tbool tx_irq_mode;\n\n\t \n\tvoid __iomem *ipc;\n\n\t \n\tvoid __iomem *base;\n\n\tunsigned int chan_num;\n\tstruct hi6220_mbox_chan *mchan;\n\n\tvoid *irq_map_chan[MBOX_CHAN_MAX];\n\tstruct mbox_chan *chan;\n\tstruct mbox_controller controller;\n};\n\nstatic void mbox_set_state(struct hi6220_mbox *mbox,\n\t\t\t   unsigned int slot, u32 val)\n{\n\tu32 status;\n\n\tstatus = readl(mbox->base + MBOX_MODE_REG(slot));\n\tstatus = (status & ~MBOX_STATE_MASK) | val;\n\twritel(status, mbox->base + MBOX_MODE_REG(slot));\n}\n\nstatic void mbox_set_mode(struct hi6220_mbox *mbox,\n\t\t\t  unsigned int slot, u32 val)\n{\n\tu32 mode;\n\n\tmode = readl(mbox->base + MBOX_MODE_REG(slot));\n\tmode = (mode & ~MBOX_ACK_CONFIG_MASK) | val;\n\twritel(mode, mbox->base + MBOX_MODE_REG(slot));\n}\n\nstatic bool hi6220_mbox_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct hi6220_mbox_chan *mchan = chan->con_priv;\n\tstruct hi6220_mbox *mbox = mchan->parent;\n\tu32 state;\n\n\t \n\tBUG_ON(mbox->tx_irq_mode);\n\n\tstate = readl(mbox->base + MBOX_MODE_REG(mchan->slot));\n\treturn ((state & MBOX_STATE_MASK) == MBOX_STATE_IDLE);\n}\n\nstatic int hi6220_mbox_send_data(struct mbox_chan *chan, void *msg)\n{\n\tstruct hi6220_mbox_chan *mchan = chan->con_priv;\n\tstruct hi6220_mbox *mbox = mchan->parent;\n\tunsigned int slot = mchan->slot;\n\tu32 *buf = msg;\n\tint i;\n\n\t \n\tmchan->dir = MBOX_TX;\n\n\tmbox_set_state(mbox, slot, MBOX_STATE_TX);\n\n\tif (mbox->tx_irq_mode)\n\t\tmbox_set_mode(mbox, slot, MBOX_ACK_IRQ);\n\telse\n\t\tmbox_set_mode(mbox, slot, MBOX_ACK_AUTOMATIC);\n\n\tfor (i = 0; i < MBOX_MSG_LEN; i++)\n\t\twritel(buf[i], mbox->base + MBOX_DATA_REG(slot) + i * 4);\n\n\t \n\twritel(BIT(mchan->dst_irq), DST_INT_RAW_REG(mbox->ipc));\n\treturn 0;\n}\n\nstatic irqreturn_t hi6220_mbox_interrupt(int irq, void *p)\n{\n\tstruct hi6220_mbox *mbox = p;\n\tstruct hi6220_mbox_chan *mchan;\n\tstruct mbox_chan *chan;\n\tunsigned int state, intr_bit, i;\n\tu32 msg[MBOX_MSG_LEN];\n\n\tstate = readl(ACK_INT_STAT_REG(mbox->ipc));\n\tif (!state) {\n\t\tdev_warn(mbox->dev, \"%s: spurious interrupt\\n\",\n\t\t\t __func__);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (state) {\n\t\tintr_bit = __ffs(state);\n\t\tstate &= (state - 1);\n\n\t\tchan = mbox->irq_map_chan[intr_bit];\n\t\tif (!chan) {\n\t\t\tdev_warn(mbox->dev, \"%s: unexpected irq vector %d\\n\",\n\t\t\t\t __func__, intr_bit);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmchan = chan->con_priv;\n\t\tif (mchan->dir == MBOX_TX)\n\t\t\tmbox_chan_txdone(chan, 0);\n\t\telse {\n\t\t\tfor (i = 0; i < MBOX_MSG_LEN; i++)\n\t\t\t\tmsg[i] = readl(mbox->base +\n\t\t\t\t\tMBOX_DATA_REG(mchan->slot) + i * 4);\n\n\t\t\tmbox_chan_received_data(chan, (void *)msg);\n\t\t}\n\n\t\t \n\t\twritel(BIT(mchan->ack_irq), ACK_INT_CLR_REG(mbox->ipc));\n\t\tmbox_set_state(mbox, mchan->slot, MBOX_STATE_IDLE);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hi6220_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct hi6220_mbox_chan *mchan = chan->con_priv;\n\tstruct hi6220_mbox *mbox = mchan->parent;\n\n\tmchan->dir = 0;\n\n\t \n\twritel(BIT(mchan->ack_irq), ACK_INT_ENA_REG(mbox->ipc));\n\treturn 0;\n}\n\nstatic void hi6220_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct hi6220_mbox_chan *mchan = chan->con_priv;\n\tstruct hi6220_mbox *mbox = mchan->parent;\n\n\t \n\twritel(BIT(mchan->ack_irq), ACK_INT_DIS_REG(mbox->ipc));\n\tmbox->irq_map_chan[mchan->ack_irq] = NULL;\n}\n\nstatic const struct mbox_chan_ops hi6220_mbox_ops = {\n\t.send_data    = hi6220_mbox_send_data,\n\t.startup      = hi6220_mbox_startup,\n\t.shutdown     = hi6220_mbox_shutdown,\n\t.last_tx_done = hi6220_mbox_last_tx_done,\n};\n\nstatic struct mbox_chan *hi6220_mbox_xlate(struct mbox_controller *controller,\n\t\t\t\t\t   const struct of_phandle_args *spec)\n{\n\tstruct hi6220_mbox *mbox = dev_get_drvdata(controller->dev);\n\tstruct hi6220_mbox_chan *mchan;\n\tstruct mbox_chan *chan;\n\tunsigned int i = spec->args[0];\n\tunsigned int dst_irq = spec->args[1];\n\tunsigned int ack_irq = spec->args[2];\n\n\t \n\tif (i >= mbox->chan_num || dst_irq >= mbox->chan_num ||\n\t    ack_irq >= mbox->chan_num) {\n\t\tdev_err(mbox->dev,\n\t\t\t\"Invalid channel idx %d dst_irq %d ack_irq %d\\n\",\n\t\t\ti, dst_irq, ack_irq);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tchan = &mbox->chan[i];\n\tif (mbox->irq_map_chan[ack_irq] == (void *)chan) {\n\t\tdev_err(mbox->dev, \"Channel in use\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tmchan = chan->con_priv;\n\tmchan->dst_irq = dst_irq;\n\tmchan->ack_irq = ack_irq;\n\n\tmbox->irq_map_chan[ack_irq] = (void *)chan;\n\treturn chan;\n}\n\nstatic const struct of_device_id hi6220_mbox_of_match[] = {\n\t{ .compatible = \"hisilicon,hi6220-mbox\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hi6220_mbox_of_match);\n\nstatic int hi6220_mbox_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct hi6220_mbox *mbox;\n\tint i, err;\n\n\tmbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tmbox->dev = dev;\n\tmbox->chan_num = MBOX_CHAN_MAX;\n\tmbox->mchan = devm_kcalloc(dev,\n\t\tmbox->chan_num, sizeof(*mbox->mchan), GFP_KERNEL);\n\tif (!mbox->mchan)\n\t\treturn -ENOMEM;\n\n\tmbox->chan = devm_kcalloc(dev,\n\t\tmbox->chan_num, sizeof(*mbox->chan), GFP_KERNEL);\n\tif (!mbox->chan)\n\t\treturn -ENOMEM;\n\n\tmbox->irq = platform_get_irq(pdev, 0);\n\tif (mbox->irq < 0)\n\t\treturn mbox->irq;\n\n\tmbox->ipc = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->ipc)) {\n\t\tdev_err(dev, \"ioremap ipc failed\\n\");\n\t\treturn PTR_ERR(mbox->ipc);\n\t}\n\n\tmbox->base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(mbox->base)) {\n\t\tdev_err(dev, \"ioremap buffer failed\\n\");\n\t\treturn PTR_ERR(mbox->base);\n\t}\n\n\terr = devm_request_irq(dev, mbox->irq, hi6220_mbox_interrupt, 0,\n\t\t\tdev_name(dev), mbox);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register a mailbox IRQ handler: %d\\n\",\n\t\t\terr);\n\t\treturn -ENODEV;\n\t}\n\n\tmbox->controller.dev = dev;\n\tmbox->controller.chans = &mbox->chan[0];\n\tmbox->controller.num_chans = mbox->chan_num;\n\tmbox->controller.ops = &hi6220_mbox_ops;\n\tmbox->controller.of_xlate = hi6220_mbox_xlate;\n\n\tfor (i = 0; i < mbox->chan_num; i++) {\n\t\tmbox->chan[i].con_priv = &mbox->mchan[i];\n\t\tmbox->irq_map_chan[i] = NULL;\n\n\t\tmbox->mchan[i].parent = mbox;\n\t\tmbox->mchan[i].slot   = i;\n\t}\n\n\t \n\twritel(0x0,  ACK_INT_MSK_REG(mbox->ipc));\n\twritel(~0x0, ACK_INT_CLR_REG(mbox->ipc));\n\n\t \n\tmbox->tx_irq_mode = !of_property_read_bool(node, \"hi6220,mbox-tx-noirq\");\n\n\tif (mbox->tx_irq_mode)\n\t\tmbox->controller.txdone_irq = true;\n\telse {\n\t\tmbox->controller.txdone_poll = true;\n\t\tmbox->controller.txpoll_period = 5;\n\t}\n\n\terr = devm_mbox_controller_register(dev, &mbox->controller);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mailbox %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, mbox);\n\tdev_info(dev, \"Mailbox enabled\\n\");\n\treturn 0;\n}\n\nstatic struct platform_driver hi6220_mbox_driver = {\n\t.driver = {\n\t\t.name = \"hi6220-mbox\",\n\t\t.of_match_table = hi6220_mbox_of_match,\n\t},\n\t.probe\t= hi6220_mbox_probe,\n};\n\nstatic int __init hi6220_mbox_init(void)\n{\n\treturn platform_driver_register(&hi6220_mbox_driver);\n}\ncore_initcall(hi6220_mbox_init);\n\nstatic void __exit hi6220_mbox_exit(void)\n{\n\tplatform_driver_unregister(&hi6220_mbox_driver);\n}\nmodule_exit(hi6220_mbox_exit);\n\nMODULE_AUTHOR(\"Leo Yan <leo.yan@linaro.org>\");\nMODULE_DESCRIPTION(\"Hi6220 mailbox driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}