{
  "module_name": "sprd-mailbox.c",
  "hash_id": "4f1700390f17e1b09597592ce58c5b099ef09b3b84aee74ce63ed26156fb3d90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/sprd-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n\n#define SPRD_MBOX_ID\t\t0x0\n#define SPRD_MBOX_MSG_LOW\t0x4\n#define SPRD_MBOX_MSG_HIGH\t0x8\n#define SPRD_MBOX_TRIGGER\t0xc\n#define SPRD_MBOX_FIFO_RST\t0x10\n#define SPRD_MBOX_FIFO_STS\t0x14\n#define SPRD_MBOX_IRQ_STS\t0x18\n#define SPRD_MBOX_IRQ_MSK\t0x1c\n#define SPRD_MBOX_LOCK\t\t0x20\n#define SPRD_MBOX_FIFO_DEPTH\t0x24\n\n \n#define SPRD_INBOX_FIFO_DELIVER_MASK\t\tGENMASK(23, 16)\n#define SPRD_INBOX_FIFO_OVERLOW_MASK\t\tGENMASK(15, 8)\n#define SPRD_INBOX_FIFO_DELIVER_SHIFT\t\t16\n#define SPRD_INBOX_FIFO_BUSY_MASK\t\tGENMASK(7, 0)\n\n \n#define SPRD_MBOX_IRQ_CLR\t\t\tBIT(0)\n\n \n#define SPRD_OUTBOX_FIFO_FULL\t\t\tBIT(2)\n#define SPRD_OUTBOX_FIFO_WR_SHIFT\t\t16\n#define SPRD_OUTBOX_FIFO_RD_SHIFT\t\t24\n#define SPRD_OUTBOX_FIFO_POS_MASK\t\tGENMASK(7, 0)\n\n \n#define SPRD_INBOX_FIFO_BLOCK_IRQ\t\tBIT(0)\n#define SPRD_INBOX_FIFO_OVERFLOW_IRQ\t\tBIT(1)\n#define SPRD_INBOX_FIFO_DELIVER_IRQ\t\tBIT(2)\n#define SPRD_INBOX_FIFO_IRQ_MASK\t\tGENMASK(2, 0)\n\n \n#define SPRD_OUTBOX_FIFO_NOT_EMPTY_IRQ\t\tBIT(0)\n#define SPRD_OUTBOX_FIFO_IRQ_MASK\t\tGENMASK(4, 0)\n\n#define SPRD_OUTBOX_BASE_SPAN\t\t\t0x1000\n#define SPRD_MBOX_CHAN_MAX\t\t\t8\n#define SPRD_SUPP_INBOX_ID_SC9863A\t\t7\n\nstruct sprd_mbox_priv {\n\tstruct mbox_controller\tmbox;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*inbox_base;\n\tvoid __iomem\t\t*outbox_base;\n\t \n\tvoid __iomem\t\t*supp_base;\n\tstruct clk\t\t*clk;\n\tu32\t\t\toutbox_fifo_depth;\n\n\tstruct mutex\t\tlock;\n\tu32\t\t\trefcnt;\n\tstruct mbox_chan\tchan[SPRD_MBOX_CHAN_MAX];\n};\n\nstatic struct sprd_mbox_priv *to_sprd_mbox_priv(struct mbox_controller *mbox)\n{\n\treturn container_of(mbox, struct sprd_mbox_priv, mbox);\n}\n\nstatic u32 sprd_mbox_get_fifo_len(struct sprd_mbox_priv *priv, u32 fifo_sts)\n{\n\tu32 wr_pos = (fifo_sts >> SPRD_OUTBOX_FIFO_WR_SHIFT) &\n\t\tSPRD_OUTBOX_FIFO_POS_MASK;\n\tu32 rd_pos = (fifo_sts >> SPRD_OUTBOX_FIFO_RD_SHIFT) &\n\t\tSPRD_OUTBOX_FIFO_POS_MASK;\n\tu32 fifo_len;\n\n\t \n\tif (wr_pos == rd_pos) {\n\t\tif (fifo_sts & SPRD_OUTBOX_FIFO_FULL)\n\t\t\tfifo_len = priv->outbox_fifo_depth;\n\t\telse\n\t\t\tfifo_len = 0;\n\t} else if (wr_pos > rd_pos) {\n\t\tfifo_len = wr_pos - rd_pos;\n\t} else {\n\t\tfifo_len = priv->outbox_fifo_depth - rd_pos + wr_pos;\n\t}\n\n\treturn fifo_len;\n}\n\nstatic irqreturn_t do_outbox_isr(void __iomem *base, struct sprd_mbox_priv *priv)\n{\n\tstruct mbox_chan *chan;\n\tu32 fifo_sts, fifo_len, msg[2];\n\tint i, id;\n\n\tfifo_sts = readl(base + SPRD_MBOX_FIFO_STS);\n\n\tfifo_len = sprd_mbox_get_fifo_len(priv, fifo_sts);\n\tif (!fifo_len) {\n\t\tdev_warn_ratelimited(priv->dev, \"spurious outbox interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tfor (i = 0; i < fifo_len; i++) {\n\t\tmsg[0] = readl(base + SPRD_MBOX_MSG_LOW);\n\t\tmsg[1] = readl(base + SPRD_MBOX_MSG_HIGH);\n\t\tid = readl(base + SPRD_MBOX_ID);\n\n\t\tchan = &priv->chan[id];\n\t\tif (chan->cl)\n\t\t\tmbox_chan_received_data(chan, (void *)msg);\n\t\telse\n\t\t\tdev_warn_ratelimited(priv->dev,\n\t\t\t\t    \"message's been dropped at ch[%d]\\n\", id);\n\n\t\t \n\t\twritel(0x1, base + SPRD_MBOX_TRIGGER);\n\t}\n\n\t \n\twritel(SPRD_MBOX_IRQ_CLR, base + SPRD_MBOX_IRQ_STS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sprd_mbox_outbox_isr(int irq, void *data)\n{\n\tstruct sprd_mbox_priv *priv = data;\n\n\treturn do_outbox_isr(priv->outbox_base, priv);\n}\n\nstatic irqreturn_t sprd_mbox_supp_isr(int irq, void *data)\n{\n\tstruct sprd_mbox_priv *priv = data;\n\n\treturn do_outbox_isr(priv->supp_base, priv);\n}\n\nstatic irqreturn_t sprd_mbox_inbox_isr(int irq, void *data)\n{\n\tstruct sprd_mbox_priv *priv = data;\n\tstruct mbox_chan *chan;\n\tu32 fifo_sts, send_sts, busy, id;\n\n\tfifo_sts = readl(priv->inbox_base + SPRD_MBOX_FIFO_STS);\n\n\t \n\tsend_sts = (fifo_sts & SPRD_INBOX_FIFO_DELIVER_MASK) >>\n\t\tSPRD_INBOX_FIFO_DELIVER_SHIFT;\n\tif (!send_sts) {\n\t\tdev_warn_ratelimited(priv->dev, \"spurious inbox interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\twhile (send_sts) {\n\t\tid = __ffs(send_sts);\n\t\tsend_sts &= (send_sts - 1);\n\n\t\tchan = &priv->chan[id];\n\n\t\t \n\t\tbusy = fifo_sts & SPRD_INBOX_FIFO_BUSY_MASK;\n\t\tif (!(busy & BIT(id)))\n\t\t\tmbox_chan_txdone(chan, 0);\n\t}\n\n\t \n\twritel(fifo_sts &\n\t       (SPRD_INBOX_FIFO_DELIVER_MASK | SPRD_INBOX_FIFO_OVERLOW_MASK),\n\t       priv->inbox_base + SPRD_MBOX_FIFO_RST);\n\n\t \n\twritel(SPRD_MBOX_IRQ_CLR, priv->inbox_base + SPRD_MBOX_IRQ_STS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sprd_mbox_send_data(struct mbox_chan *chan, void *msg)\n{\n\tstruct sprd_mbox_priv *priv = to_sprd_mbox_priv(chan->mbox);\n\tunsigned long id = (unsigned long)chan->con_priv;\n\tu32 *data = msg;\n\n\t \n\twritel(data[0], priv->inbox_base + SPRD_MBOX_MSG_LOW);\n\twritel(data[1], priv->inbox_base + SPRD_MBOX_MSG_HIGH);\n\n\t \n\twritel(id, priv->inbox_base + SPRD_MBOX_ID);\n\n\t \n\twritel(0x1, priv->inbox_base + SPRD_MBOX_TRIGGER);\n\n\treturn 0;\n}\n\nstatic int sprd_mbox_flush(struct mbox_chan *chan, unsigned long timeout)\n{\n\tstruct sprd_mbox_priv *priv = to_sprd_mbox_priv(chan->mbox);\n\tunsigned long id = (unsigned long)chan->con_priv;\n\tu32 busy;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tbusy = readl(priv->inbox_base + SPRD_MBOX_FIFO_STS) &\n\t\t\tSPRD_INBOX_FIFO_BUSY_MASK;\n\t\tif (!(busy & BIT(id))) {\n\t\t\tmbox_chan_txdone(chan, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIME;\n}\n\nstatic int sprd_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct sprd_mbox_priv *priv = to_sprd_mbox_priv(chan->mbox);\n\tu32 val;\n\n\tmutex_lock(&priv->lock);\n\tif (priv->refcnt++ == 0) {\n\t\t \n\t\twritel(0x0, priv->outbox_base + SPRD_MBOX_FIFO_RST);\n\n\t\t \n\t\tval = readl(priv->inbox_base + SPRD_MBOX_IRQ_MSK);\n\t\tval &= ~(SPRD_INBOX_FIFO_OVERFLOW_IRQ | SPRD_INBOX_FIFO_DELIVER_IRQ);\n\t\twritel(val, priv->inbox_base + SPRD_MBOX_IRQ_MSK);\n\n\t\t \n\t\tval = readl(priv->outbox_base + SPRD_MBOX_IRQ_MSK);\n\t\tval &= ~SPRD_OUTBOX_FIFO_NOT_EMPTY_IRQ;\n\t\twritel(val, priv->outbox_base + SPRD_MBOX_IRQ_MSK);\n\n\t\t \n\t\tif (priv->supp_base) {\n\t\t\twritel(0x0, priv->supp_base + SPRD_MBOX_FIFO_RST);\n\t\t\tval = readl(priv->supp_base + SPRD_MBOX_IRQ_MSK);\n\t\t\tval &= ~SPRD_OUTBOX_FIFO_NOT_EMPTY_IRQ;\n\t\t\twritel(val, priv->supp_base + SPRD_MBOX_IRQ_MSK);\n\t\t}\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic void sprd_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct sprd_mbox_priv *priv = to_sprd_mbox_priv(chan->mbox);\n\n\tmutex_lock(&priv->lock);\n\tif (--priv->refcnt == 0) {\n\t\t \n\t\twritel(SPRD_INBOX_FIFO_IRQ_MASK, priv->inbox_base + SPRD_MBOX_IRQ_MSK);\n\t\twritel(SPRD_OUTBOX_FIFO_IRQ_MASK, priv->outbox_base + SPRD_MBOX_IRQ_MSK);\n\n\t\tif (priv->supp_base)\n\t\t\twritel(SPRD_OUTBOX_FIFO_IRQ_MASK,\n\t\t\t       priv->supp_base + SPRD_MBOX_IRQ_MSK);\n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic const struct mbox_chan_ops sprd_mbox_ops = {\n\t.send_data\t= sprd_mbox_send_data,\n\t.flush\t\t= sprd_mbox_flush,\n\t.startup\t= sprd_mbox_startup,\n\t.shutdown\t= sprd_mbox_shutdown,\n};\n\nstatic void sprd_mbox_disable(void *data)\n{\n\tstruct sprd_mbox_priv *priv = data;\n\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic int sprd_mbox_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sprd_mbox_priv *priv;\n\tint ret, inbox_irq, outbox_irq, supp_irq;\n\tunsigned long id, supp;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tmutex_init(&priv->lock);\n\n\t \n\tpriv->inbox_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->inbox_base))\n\t\treturn PTR_ERR(priv->inbox_base);\n\n\tpriv->outbox_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->outbox_base))\n\t\treturn PTR_ERR(priv->outbox_base);\n\n\tpriv->clk = devm_clk_get(dev, \"enable\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get mailbox clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, sprd_mbox_disable, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add mailbox disable action\\n\");\n\t\treturn ret;\n\t}\n\n\tinbox_irq = platform_get_irq_byname(pdev, \"inbox\");\n\tif (inbox_irq < 0)\n\t\treturn inbox_irq;\n\n\tret = devm_request_irq(dev, inbox_irq, sprd_mbox_inbox_isr,\n\t\t\t       IRQF_NO_SUSPEND, dev_name(dev), priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request inbox IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\toutbox_irq = platform_get_irq_byname(pdev, \"outbox\");\n\tif (outbox_irq < 0)\n\t\treturn outbox_irq;\n\n\tret = devm_request_irq(dev, outbox_irq, sprd_mbox_outbox_isr,\n\t\t\t       IRQF_NO_SUSPEND, dev_name(dev), priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request outbox IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsupp_irq = platform_get_irq_byname(pdev, \"supp-outbox\");\n\tif (supp_irq > 0) {\n\t\tret = devm_request_irq(dev, supp_irq, sprd_mbox_supp_isr,\n\t\t\t\t       IRQF_NO_SUSPEND, dev_name(dev), priv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request outbox IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsupp = (unsigned long) of_device_get_match_data(dev);\n\t\tif (!supp) {\n\t\t\tdev_err(dev, \"no supplementary outbox specified\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tpriv->supp_base = priv->outbox_base + (SPRD_OUTBOX_BASE_SPAN * supp);\n\t}\n\n\t \n\tpriv->outbox_fifo_depth =\n\t\treadl(priv->outbox_base + SPRD_MBOX_FIFO_DEPTH) + 1;\n\tpriv->mbox.dev = dev;\n\tpriv->mbox.chans = &priv->chan[0];\n\tpriv->mbox.num_chans = SPRD_MBOX_CHAN_MAX;\n\tpriv->mbox.ops = &sprd_mbox_ops;\n\tpriv->mbox.txdone_irq = true;\n\n\tfor (id = 0; id < SPRD_MBOX_CHAN_MAX; id++)\n\t\tpriv->chan[id].con_priv = (void *)id;\n\n\tret = devm_mbox_controller_register(dev, &priv->mbox);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register mailbox: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_mbox_of_match[] = {\n\t{ .compatible = \"sprd,sc9860-mailbox\" },\n\t{ .compatible = \"sprd,sc9863a-mailbox\",\n\t  .data = (void *)SPRD_SUPP_INBOX_ID_SC9863A },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_mbox_of_match);\n\nstatic struct platform_driver sprd_mbox_driver = {\n\t.driver = {\n\t\t.name = \"sprd-mailbox\",\n\t\t.of_match_table = sprd_mbox_of_match,\n\t},\n\t.probe\t= sprd_mbox_probe,\n};\nmodule_platform_driver(sprd_mbox_driver);\n\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@unisoc.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum mailbox driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}