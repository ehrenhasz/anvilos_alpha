{
  "module_name": "hi3660-mailbox.c",
  "hash_id": "b4257c60643a307be77c0857732f6dce29d72c6252d90e525c61fec69afae922",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/hi3660-mailbox.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"mailbox.h\"\n\n#define MBOX_CHAN_MAX\t\t\t32\n\n#define MBOX_RX\t\t\t\t0x0\n#define MBOX_TX\t\t\t\t0x1\n\n#define MBOX_BASE(mbox, ch)\t\t((mbox)->base + ((ch) * 0x40))\n#define MBOX_SRC_REG\t\t\t0x00\n#define MBOX_DST_REG\t\t\t0x04\n#define MBOX_DCLR_REG\t\t\t0x08\n#define MBOX_DSTAT_REG\t\t\t0x0c\n#define MBOX_MODE_REG\t\t\t0x10\n#define MBOX_IMASK_REG\t\t\t0x14\n#define MBOX_ICLR_REG\t\t\t0x18\n#define MBOX_SEND_REG\t\t\t0x1c\n#define MBOX_DATA_REG\t\t\t0x20\n\n#define MBOX_IPC_LOCK_REG\t\t0xa00\n#define MBOX_IPC_UNLOCK\t\t\t0x1acce551\n\n#define MBOX_AUTOMATIC_ACK\t\t1\n\n#define MBOX_STATE_IDLE\t\t\tBIT(4)\n#define MBOX_STATE_READY\t\tBIT(5)\n#define MBOX_STATE_ACK\t\t\tBIT(7)\n\n#define MBOX_MSG_LEN\t\t\t8\n\n \nstruct hi3660_chan_info {\n\tunsigned int dst_irq;\n\tunsigned int ack_irq;\n};\n\n \nstruct hi3660_mbox {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct mbox_chan chan[MBOX_CHAN_MAX];\n\tstruct hi3660_chan_info mchan[MBOX_CHAN_MAX];\n\tstruct mbox_controller controller;\n};\n\nstatic struct hi3660_mbox *to_hi3660_mbox(struct mbox_controller *mbox)\n{\n\treturn container_of(mbox, struct hi3660_mbox, controller);\n}\n\nstatic int hi3660_mbox_check_state(struct mbox_chan *chan)\n{\n\tunsigned long ch = (unsigned long)chan->con_priv;\n\tstruct hi3660_mbox *mbox = to_hi3660_mbox(chan->mbox);\n\tstruct hi3660_chan_info *mchan = &mbox->mchan[ch];\n\tvoid __iomem *base = MBOX_BASE(mbox, ch);\n\tunsigned long val;\n\tunsigned int ret;\n\n\t \n\tif (readl(base + MBOX_MODE_REG) & MBOX_STATE_READY)\n\t\treturn 0;\n\n\t \n\tret = readx_poll_timeout_atomic(readl, base + MBOX_MODE_REG,\n\t\t\tval, (val & MBOX_STATE_ACK), 1000, 300000);\n\tif (ret) {\n\t\tdev_err(mbox->dev, \"%s: timeout for receiving ack\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\twritel(BIT(mchan->ack_irq), base + MBOX_ICLR_REG);\n\n\treturn 0;\n}\n\nstatic int hi3660_mbox_unlock(struct mbox_chan *chan)\n{\n\tstruct hi3660_mbox *mbox = to_hi3660_mbox(chan->mbox);\n\tunsigned int val, retry = 3;\n\n\tdo {\n\t\twritel(MBOX_IPC_UNLOCK, mbox->base + MBOX_IPC_LOCK_REG);\n\n\t\tval = readl(mbox->base + MBOX_IPC_LOCK_REG);\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t} while (retry--);\n\n\tif (val)\n\t\tdev_err(mbox->dev, \"%s: failed to unlock mailbox\\n\", __func__);\n\n\treturn (!val) ? 0 : -ETIMEDOUT;\n}\n\nstatic int hi3660_mbox_acquire_channel(struct mbox_chan *chan)\n{\n\tunsigned long ch = (unsigned long)chan->con_priv;\n\tstruct hi3660_mbox *mbox = to_hi3660_mbox(chan->mbox);\n\tstruct hi3660_chan_info *mchan = &mbox->mchan[ch];\n\tvoid __iomem *base = MBOX_BASE(mbox, ch);\n\tunsigned int val, retry;\n\n\tfor (retry = 10; retry; retry--) {\n\t\t \n\t\tif (readl(base + MBOX_MODE_REG) & MBOX_STATE_IDLE) {\n\t\t\twritel(BIT(mchan->ack_irq), base + MBOX_SRC_REG);\n\n\t\t\t \n\t\t\tval = readl(base + MBOX_SRC_REG);\n\t\t\tif (val & BIT(mchan->ack_irq))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!retry)\n\t\tdev_err(mbox->dev, \"%s: failed to acquire channel\\n\", __func__);\n\n\treturn retry ? 0 : -ETIMEDOUT;\n}\n\nstatic int hi3660_mbox_startup(struct mbox_chan *chan)\n{\n\tint ret;\n\n\tret = hi3660_mbox_unlock(chan);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hi3660_mbox_acquire_channel(chan);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hi3660_mbox_send_data(struct mbox_chan *chan, void *msg)\n{\n\tunsigned long ch = (unsigned long)chan->con_priv;\n\tstruct hi3660_mbox *mbox = to_hi3660_mbox(chan->mbox);\n\tstruct hi3660_chan_info *mchan = &mbox->mchan[ch];\n\tvoid __iomem *base = MBOX_BASE(mbox, ch);\n\tu32 *buf = msg;\n\tunsigned int i;\n\tint ret;\n\n\tret = hi3660_mbox_check_state(chan);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel_relaxed(~BIT(mchan->dst_irq), base + MBOX_IMASK_REG);\n\n\t \n\twritel_relaxed(BIT(mchan->dst_irq), base + MBOX_DST_REG);\n\n\t \n\twritel_relaxed(MBOX_AUTOMATIC_ACK, base + MBOX_MODE_REG);\n\n\t \n\tfor (i = 0; i < MBOX_MSG_LEN; i++)\n\t\twritel_relaxed(buf[i], base + MBOX_DATA_REG + i * 4);\n\n\t \n\twritel(BIT(mchan->ack_irq), base + MBOX_SEND_REG);\n\treturn 0;\n}\n\nstatic const struct mbox_chan_ops hi3660_mbox_ops = {\n\t.startup\t= hi3660_mbox_startup,\n\t.send_data\t= hi3660_mbox_send_data,\n};\n\nstatic struct mbox_chan *hi3660_mbox_xlate(struct mbox_controller *controller,\n\t\t\t\t\t   const struct of_phandle_args *spec)\n{\n\tstruct hi3660_mbox *mbox = to_hi3660_mbox(controller);\n\tstruct hi3660_chan_info *mchan;\n\tunsigned int ch = spec->args[0];\n\n\tif (ch >= MBOX_CHAN_MAX) {\n\t\tdev_err(mbox->dev, \"Invalid channel idx %d\\n\", ch);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmchan = &mbox->mchan[ch];\n\tmchan->dst_irq = spec->args[1];\n\tmchan->ack_irq = spec->args[2];\n\n\treturn &mbox->chan[ch];\n}\n\nstatic const struct of_device_id hi3660_mbox_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3660-mbox\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, hi3660_mbox_of_match);\n\nstatic int hi3660_mbox_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hi3660_mbox *mbox;\n\tstruct mbox_chan *chan;\n\tunsigned long ch;\n\tint err;\n\n\tmbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tmbox->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->base))\n\t\treturn PTR_ERR(mbox->base);\n\n\tmbox->dev = dev;\n\tmbox->controller.dev = dev;\n\tmbox->controller.chans = mbox->chan;\n\tmbox->controller.num_chans = MBOX_CHAN_MAX;\n\tmbox->controller.ops = &hi3660_mbox_ops;\n\tmbox->controller.of_xlate = hi3660_mbox_xlate;\n\n\t \n\tchan = mbox->chan;\n\tfor (ch = 0; ch < MBOX_CHAN_MAX; ch++)\n\t\tchan[ch].con_priv = (void *)ch;\n\n\terr = devm_mbox_controller_register(dev, &mbox->controller);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mailbox %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, mbox);\n\tdev_info(dev, \"Mailbox enabled\\n\");\n\treturn 0;\n}\n\nstatic struct platform_driver hi3660_mbox_driver = {\n\t.probe  = hi3660_mbox_probe,\n\t.driver = {\n\t\t.name = \"hi3660-mbox\",\n\t\t.of_match_table = hi3660_mbox_of_match,\n\t},\n};\n\nstatic int __init hi3660_mbox_init(void)\n{\n\treturn platform_driver_register(&hi3660_mbox_driver);\n}\ncore_initcall(hi3660_mbox_init);\n\nstatic void __exit hi3660_mbox_exit(void)\n{\n\tplatform_driver_unregister(&hi3660_mbox_driver);\n}\nmodule_exit(hi3660_mbox_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Hisilicon Hi3660 Mailbox Controller\");\nMODULE_AUTHOR(\"Leo Yan <leo.yan@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}