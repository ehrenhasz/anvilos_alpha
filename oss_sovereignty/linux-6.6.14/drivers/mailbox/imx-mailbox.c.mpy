{
  "module_name": "imx-mailbox.c",
  "hash_id": "b16b8ff707a0538116ebe6ff1d64eefe5a5c747d2336cc1766dae394b836f4e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/imx-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/firmware/imx/ipc.h>\n#include <linux/firmware/imx/s4.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <linux/slab.h>\n\n#define IMX_MU_CHANS\t\t17\n \n#define IMX_MU_SCU_CHANS\t6\n \n#define IMX_MU_S4_CHANS\t\t2\n#define IMX_MU_CHAN_NAME_SIZE\t20\n\n#define IMX_MU_NUM_RR\t\t4\n\n#define IMX_MU_SECO_TX_TOUT (msecs_to_jiffies(3000))\n#define IMX_MU_SECO_RX_TOUT (msecs_to_jiffies(3000))\n\n \nenum imx_mu_chan_type {\n\tIMX_MU_TYPE_TX\t\t= 0,  \n\tIMX_MU_TYPE_RX\t\t= 1,  \n\tIMX_MU_TYPE_TXDB\t= 2,  \n\tIMX_MU_TYPE_RXDB\t= 3,  \n\tIMX_MU_TYPE_RST\t\t= 4,  \n};\n\nenum imx_mu_xcr {\n\tIMX_MU_CR,\n\tIMX_MU_GIER,\n\tIMX_MU_GCR,\n\tIMX_MU_TCR,\n\tIMX_MU_RCR,\n\tIMX_MU_xCR_MAX,\n};\n\nenum imx_mu_xsr {\n\tIMX_MU_SR,\n\tIMX_MU_GSR,\n\tIMX_MU_TSR,\n\tIMX_MU_RSR,\n\tIMX_MU_xSR_MAX,\n};\n\nstruct imx_sc_rpc_msg_max {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 data[30];\n};\n\nstruct imx_s4_rpc_msg_max {\n\tstruct imx_s4_rpc_msg hdr;\n\tu32 data[254];\n};\n\nstruct imx_mu_con_priv {\n\tunsigned int\t\tidx;\n\tchar\t\t\tirq_desc[IMX_MU_CHAN_NAME_SIZE];\n\tenum imx_mu_chan_type\ttype;\n\tstruct mbox_chan\t*chan;\n\tstruct tasklet_struct\ttxdb_tasklet;\n};\n\nstruct imx_mu_priv {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tvoid\t\t\t*msg;\n\tspinlock_t\t\txcr_lock;  \n\n\tstruct mbox_controller\tmbox;\n\tstruct mbox_chan\tmbox_chans[IMX_MU_CHANS];\n\n\tstruct imx_mu_con_priv  con_priv[IMX_MU_CHANS];\n\tconst struct imx_mu_dcfg\t*dcfg;\n\tstruct clk\t\t*clk;\n\tint\t\t\tirq[IMX_MU_CHANS];\n\tbool\t\t\tsuspend;\n\n\tu32 xcr[IMX_MU_xCR_MAX];\n\n\tbool\t\t\tside_b;\n};\n\nenum imx_mu_type {\n\tIMX_MU_V1,\n\tIMX_MU_V2 = BIT(1),\n\tIMX_MU_V2_S4 = BIT(15),\n\tIMX_MU_V2_IRQ = BIT(16),\n};\n\nstruct imx_mu_dcfg {\n\tint (*tx)(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp, void *data);\n\tint (*rx)(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp);\n\tint (*rxdb)(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp);\n\tvoid (*init)(struct imx_mu_priv *priv);\n\tenum imx_mu_type type;\n\tu32\txTR;\t\t \n\tu32\txRR;\t\t \n\tu32\txSR[IMX_MU_xSR_MAX];\t \n\tu32\txCR[IMX_MU_xCR_MAX];\t \n};\n\n#define IMX_MU_xSR_GIPn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(28 + (3 - (x))))\n#define IMX_MU_xSR_RFn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(24 + (3 - (x))))\n#define IMX_MU_xSR_TEn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(20 + (3 - (x))))\n\n \n#define IMX_MU_xCR_GIEn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(28 + (3 - (x))))\n \n#define IMX_MU_xCR_RIEn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(24 + (3 - (x))))\n \n#define IMX_MU_xCR_TIEn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(20 + (3 - (x))))\n \n#define IMX_MU_xCR_GIRn(type, x) (type & IMX_MU_V2 ? BIT(x) : BIT(16 + (3 - (x))))\n \n#define IMX_MU_xCR_RST(type)\t(type & IMX_MU_V2 ? BIT(0) : BIT(5))\n#define IMX_MU_xSR_RST(type)\t(type & IMX_MU_V2 ? BIT(0) : BIT(7))\n\n\nstatic struct imx_mu_priv *to_imx_mu_priv(struct mbox_controller *mbox)\n{\n\treturn container_of(mbox, struct imx_mu_priv, mbox);\n}\n\nstatic void imx_mu_write(struct imx_mu_priv *priv, u32 val, u32 offs)\n{\n\tiowrite32(val, priv->base + offs);\n}\n\nstatic u32 imx_mu_read(struct imx_mu_priv *priv, u32 offs)\n{\n\treturn ioread32(priv->base + offs);\n}\n\nstatic int imx_mu_tx_waiting_write(struct imx_mu_priv *priv, u32 val, u32 idx)\n{\n\tu64 timeout_time = get_jiffies_64() + IMX_MU_SECO_TX_TOUT;\n\tu32 status;\n\tu32 can_write;\n\n\tdev_dbg(priv->dev, \"Trying to write %.8x to idx %d\\n\", val, idx);\n\n\tdo {\n\t\tstatus = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_TSR]);\n\t\tcan_write = status & IMX_MU_xSR_TEn(priv->dcfg->type, idx % 4);\n\t} while (!can_write && time_is_after_jiffies64(timeout_time));\n\n\tif (!can_write) {\n\t\tdev_err(priv->dev, \"timeout trying to write %.8x at %d(%.8x)\\n\",\n\t\t\tval, idx, status);\n\t\treturn -ETIME;\n\t}\n\n\timx_mu_write(priv, val, priv->dcfg->xTR + (idx % 4) * 4);\n\n\treturn 0;\n}\n\nstatic int imx_mu_rx_waiting_read(struct imx_mu_priv *priv, u32 *val, u32 idx)\n{\n\tu64 timeout_time = get_jiffies_64() + IMX_MU_SECO_RX_TOUT;\n\tu32 status;\n\tu32 can_read;\n\n\tdev_dbg(priv->dev, \"Trying to read from idx %d\\n\", idx);\n\n\tdo {\n\t\tstatus = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_RSR]);\n\t\tcan_read = status & IMX_MU_xSR_RFn(priv->dcfg->type, idx % 4);\n\t} while (!can_read && time_is_after_jiffies64(timeout_time));\n\n\tif (!can_read) {\n\t\tdev_err(priv->dev, \"timeout trying to read idx %d (%.8x)\\n\",\n\t\t\tidx, status);\n\t\treturn -ETIME;\n\t}\n\n\t*val = imx_mu_read(priv, priv->dcfg->xRR + (idx % 4) * 4);\n\tdev_dbg(priv->dev, \"Read %.8x\\n\", *val);\n\n\treturn 0;\n}\n\nstatic u32 imx_mu_xcr_rmw(struct imx_mu_priv *priv, enum imx_mu_xcr type, u32 set, u32 clr)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&priv->xcr_lock, flags);\n\tval = imx_mu_read(priv, priv->dcfg->xCR[type]);\n\tval &= ~clr;\n\tval |= set;\n\timx_mu_write(priv, val, priv->dcfg->xCR[type]);\n\tspin_unlock_irqrestore(&priv->xcr_lock, flags);\n\n\treturn val;\n}\n\nstatic int imx_mu_generic_tx(struct imx_mu_priv *priv,\n\t\t\t     struct imx_mu_con_priv *cp,\n\t\t\t     void *data)\n{\n\tu32 *arg = data;\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_TX:\n\t\timx_mu_write(priv, *arg, priv->dcfg->xTR + cp->idx * 4);\n\t\timx_mu_xcr_rmw(priv, IMX_MU_TCR, IMX_MU_xCR_TIEn(priv->dcfg->type, cp->idx), 0);\n\t\tbreak;\n\tcase IMX_MU_TYPE_TXDB:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_GCR, IMX_MU_xCR_GIRn(priv->dcfg->type, cp->idx), 0);\n\t\ttasklet_schedule(&cp->txdb_tasklet);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn_ratelimited(priv->dev, \"Send data on wrong channel type: %d\\n\", cp->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_mu_generic_rx(struct imx_mu_priv *priv,\n\t\t\t     struct imx_mu_con_priv *cp)\n{\n\tu32 dat;\n\n\tdat = imx_mu_read(priv, priv->dcfg->xRR + (cp->idx) * 4);\n\tmbox_chan_received_data(cp->chan, (void *)&dat);\n\n\treturn 0;\n}\n\nstatic int imx_mu_generic_rxdb(struct imx_mu_priv *priv,\n\t\t\t       struct imx_mu_con_priv *cp)\n{\n\timx_mu_write(priv, IMX_MU_xSR_GIPn(priv->dcfg->type, cp->idx),\n\t\t     priv->dcfg->xSR[IMX_MU_GSR]);\n\tmbox_chan_received_data(cp->chan, NULL);\n\n\treturn 0;\n}\n\nstatic int imx_mu_specific_tx(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp, void *data)\n{\n\tu32 *arg = data;\n\tint i, ret;\n\tu32 xsr;\n\tu32 size, max_size, num_tr;\n\n\tif (priv->dcfg->type & IMX_MU_V2_S4) {\n\t\tsize = ((struct imx_s4_rpc_msg_max *)data)->hdr.size;\n\t\tmax_size = sizeof(struct imx_s4_rpc_msg_max);\n\t\tnum_tr = 8;\n\t} else {\n\t\tsize = ((struct imx_sc_rpc_msg_max *)data)->hdr.size;\n\t\tmax_size = sizeof(struct imx_sc_rpc_msg_max);\n\t\tnum_tr = 4;\n\t}\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_TX:\n\t\t \n\n\t\tif (size > max_size / 4) {\n\t\t\t \n\t\t\tdev_err(priv->dev, \"Maximal message size (%u bytes) exceeded on TX; got: %i bytes\\n\", max_size, size << 2);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < num_tr && i < size; i++)\n\t\t\timx_mu_write(priv, *arg++, priv->dcfg->xTR + (i % num_tr) * 4);\n\t\tfor (; i < size; i++) {\n\t\t\tret = readl_poll_timeout(priv->base + priv->dcfg->xSR[IMX_MU_TSR],\n\t\t\t\t\t\t xsr,\n\t\t\t\t\t\t xsr & IMX_MU_xSR_TEn(priv->dcfg->type, i % num_tr),\n\t\t\t\t\t\t 0, 5 * USEC_PER_SEC);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev, \"Send data index: %d timeout\\n\", i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\timx_mu_write(priv, *arg++, priv->dcfg->xTR + (i % num_tr) * 4);\n\t\t}\n\n\t\timx_mu_xcr_rmw(priv, IMX_MU_TCR, IMX_MU_xCR_TIEn(priv->dcfg->type, cp->idx), 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn_ratelimited(priv->dev, \"Send data on wrong channel type: %d\\n\", cp->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_mu_specific_rx(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp)\n{\n\tu32 *data;\n\tint i, ret;\n\tu32 xsr;\n\tu32 size, max_size;\n\n\tdata = (u32 *)priv->msg;\n\n\timx_mu_xcr_rmw(priv, IMX_MU_RCR, 0, IMX_MU_xCR_RIEn(priv->dcfg->type, 0));\n\t*data++ = imx_mu_read(priv, priv->dcfg->xRR);\n\n\tif (priv->dcfg->type & IMX_MU_V2_S4) {\n\t\tsize = ((struct imx_s4_rpc_msg_max *)priv->msg)->hdr.size;\n\t\tmax_size = sizeof(struct imx_s4_rpc_msg_max);\n\t} else {\n\t\tsize = ((struct imx_sc_rpc_msg_max *)priv->msg)->hdr.size;\n\t\tmax_size = sizeof(struct imx_sc_rpc_msg_max);\n\t}\n\n\tif (size > max_size / 4) {\n\t\tdev_err(priv->dev, \"Maximal message size (%u bytes) exceeded on RX; got: %i bytes\\n\", max_size, size << 2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i < size; i++) {\n\t\tret = readl_poll_timeout(priv->base + priv->dcfg->xSR[IMX_MU_RSR], xsr,\n\t\t\t\t\t xsr & IMX_MU_xSR_RFn(priv->dcfg->type, i % 4), 0,\n\t\t\t\t\t 5 * USEC_PER_SEC);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"timeout read idx %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t\t*data++ = imx_mu_read(priv, priv->dcfg->xRR + (i % 4) * 4);\n\t}\n\n\timx_mu_xcr_rmw(priv, IMX_MU_RCR, IMX_MU_xCR_RIEn(priv->dcfg->type, 0), 0);\n\tmbox_chan_received_data(cp->chan, (void *)priv->msg);\n\n\treturn 0;\n}\n\nstatic int imx_mu_seco_tx(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp,\n\t\t\t  void *data)\n{\n\tstruct imx_sc_rpc_msg_max *msg = data;\n\tu32 *arg = data;\n\tu32 byte_size;\n\tint err;\n\tint i;\n\n\tdev_dbg(priv->dev, \"Sending message\\n\");\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_TXDB:\n\t\tbyte_size = msg->hdr.size * sizeof(u32);\n\t\tif (byte_size > sizeof(*msg)) {\n\t\t\t \n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Exceed max msg size (%zu) on TX, got: %i\\n\",\n\t\t\t\tsizeof(*msg), byte_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprint_hex_dump_debug(\"from client \", DUMP_PREFIX_OFFSET, 4, 4,\n\t\t\t\t     data, byte_size, false);\n\n\t\t \n\t\tdev_dbg(priv->dev, \"Sending header\\n\");\n\t\timx_mu_write(priv, *arg++, priv->dcfg->xTR);\n\n\t\t \n\t\tdev_dbg(priv->dev, \"Sending signaling\\n\");\n\t\timx_mu_xcr_rmw(priv, IMX_MU_GCR,\n\t\t\t       IMX_MU_xCR_GIRn(priv->dcfg->type, cp->idx), 0);\n\n\t\t \n\t\tfor (i = 1; i < 4 && i < msg->hdr.size; i++) {\n\t\t\tdev_dbg(priv->dev, \"Sending word %d\\n\", i);\n\t\t\timx_mu_write(priv, *arg++,\n\t\t\t\t     priv->dcfg->xTR + (i % 4) * 4);\n\t\t}\n\n\t\t \n\t\tfor (; i < msg->hdr.size; i++) {\n\t\t\tdev_dbg(priv->dev, \"Sending word %d\\n\", i);\n\t\t\terr = imx_mu_tx_waiting_write(priv, *arg++, i);\n\t\t\tif (err) {\n\t\t\t\tdev_err(priv->dev, \"Timeout tx %d\\n\", i);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttasklet_schedule(&cp->txdb_tasklet);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn_ratelimited(priv->dev,\n\t\t\t\t     \"Send data on wrong channel type: %d\\n\",\n\t\t\t\t     cp->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_mu_seco_rxdb(struct imx_mu_priv *priv, struct imx_mu_con_priv *cp)\n{\n\tstruct imx_sc_rpc_msg_max msg;\n\tu32 *data = (u32 *)&msg;\n\tu32 byte_size;\n\tint err = 0;\n\tint i;\n\n\tdev_dbg(priv->dev, \"Receiving message\\n\");\n\n\t \n\tdev_dbg(priv->dev, \"Receiving header\\n\");\n\t*data++ = imx_mu_read(priv, priv->dcfg->xRR);\n\tbyte_size = msg.hdr.size * sizeof(u32);\n\tif (byte_size > sizeof(msg)) {\n\t\tdev_err(priv->dev, \"Exceed max msg size (%zu) on RX, got: %i\\n\",\n\t\t\tsizeof(msg), byte_size);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 1; i < msg.hdr.size; i++) {\n\t\tdev_dbg(priv->dev, \"Receiving word %d\\n\", i);\n\t\terr = imx_mu_rx_waiting_read(priv, data++, i);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"Timeout rx %d\\n\", i);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\timx_mu_write(priv, IMX_MU_xSR_GIPn(priv->dcfg->type, cp->idx),\n\t\t     priv->dcfg->xSR[IMX_MU_GSR]);\n\n\tprint_hex_dump_debug(\"to client \", DUMP_PREFIX_OFFSET, 4, 4,\n\t\t\t     &msg, byte_size, false);\n\n\t \n\tdev_dbg(priv->dev, \"Sending message to client\\n\");\n\tmbox_chan_received_data(cp->chan, (void *)&msg);\n\n\tgoto exit;\n\nerror:\n\tmbox_chan_received_data(cp->chan, ERR_PTR(err));\n\nexit:\n\treturn err;\n}\n\nstatic void imx_mu_txdb_tasklet(unsigned long data)\n{\n\tstruct imx_mu_con_priv *cp = (struct imx_mu_con_priv *)data;\n\n\tmbox_chan_txdone(cp->chan, 0);\n}\n\nstatic irqreturn_t imx_mu_isr(int irq, void *p)\n{\n\tstruct mbox_chan *chan = p;\n\tstruct imx_mu_priv *priv = to_imx_mu_priv(chan->mbox);\n\tstruct imx_mu_con_priv *cp = chan->con_priv;\n\tu32 val, ctrl;\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_TX:\n\t\tctrl = imx_mu_read(priv, priv->dcfg->xCR[IMX_MU_TCR]);\n\t\tval = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_TSR]);\n\t\tval &= IMX_MU_xSR_TEn(priv->dcfg->type, cp->idx) &\n\t\t\t(ctrl & IMX_MU_xCR_TIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RX:\n\t\tctrl = imx_mu_read(priv, priv->dcfg->xCR[IMX_MU_RCR]);\n\t\tval = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_RSR]);\n\t\tval &= IMX_MU_xSR_RFn(priv->dcfg->type, cp->idx) &\n\t\t\t(ctrl & IMX_MU_xCR_RIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RXDB:\n\t\tctrl = imx_mu_read(priv, priv->dcfg->xCR[IMX_MU_GIER]);\n\t\tval = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_GSR]);\n\t\tval &= IMX_MU_xSR_GIPn(priv->dcfg->type, cp->idx) &\n\t\t\t(ctrl & IMX_MU_xCR_GIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RST:\n\t\treturn IRQ_NONE;\n\tdefault:\n\t\tdev_warn_ratelimited(priv->dev, \"Unhandled channel type %d\\n\",\n\t\t\t\t     cp->type);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif ((val == IMX_MU_xSR_TEn(priv->dcfg->type, cp->idx)) &&\n\t    (cp->type == IMX_MU_TYPE_TX)) {\n\t\timx_mu_xcr_rmw(priv, IMX_MU_TCR, 0, IMX_MU_xCR_TIEn(priv->dcfg->type, cp->idx));\n\t\tmbox_chan_txdone(chan, 0);\n\t} else if ((val == IMX_MU_xSR_RFn(priv->dcfg->type, cp->idx)) &&\n\t\t   (cp->type == IMX_MU_TYPE_RX)) {\n\t\tpriv->dcfg->rx(priv, cp);\n\t} else if ((val == IMX_MU_xSR_GIPn(priv->dcfg->type, cp->idx)) &&\n\t\t   (cp->type == IMX_MU_TYPE_RXDB)) {\n\t\tpriv->dcfg->rxdb(priv, cp);\n\t} else {\n\t\tdev_warn_ratelimited(priv->dev, \"Not handled interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (priv->suspend)\n\t\tpm_system_wakeup();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx_mu_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct imx_mu_priv *priv = to_imx_mu_priv(chan->mbox);\n\tstruct imx_mu_con_priv *cp = chan->con_priv;\n\n\treturn priv->dcfg->tx(priv, cp, data);\n}\n\nstatic int imx_mu_startup(struct mbox_chan *chan)\n{\n\tstruct imx_mu_priv *priv = to_imx_mu_priv(chan->mbox);\n\tstruct imx_mu_con_priv *cp = chan->con_priv;\n\tunsigned long irq_flag = 0;\n\tint ret;\n\n\tpm_runtime_get_sync(priv->dev);\n\tif (cp->type == IMX_MU_TYPE_TXDB) {\n\t\t \n\t\ttasklet_init(&cp->txdb_tasklet, imx_mu_txdb_tasklet,\n\t\t\t     (unsigned long)cp);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!priv->dev->pm_domain)\n\t\tirq_flag |= IRQF_NO_SUSPEND;\n\n\tif (!(priv->dcfg->type & IMX_MU_V2_IRQ))\n\t\tirq_flag |= IRQF_SHARED;\n\n\tret = request_irq(priv->irq[cp->type], imx_mu_isr, irq_flag, cp->irq_desc, chan);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Unable to acquire IRQ %d\\n\", priv->irq[cp->type]);\n\t\treturn ret;\n\t}\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_RX:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_RCR, IMX_MU_xCR_RIEn(priv->dcfg->type, cp->idx), 0);\n\t\tbreak;\n\tcase IMX_MU_TYPE_RXDB:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_GIER, IMX_MU_xCR_GIEn(priv->dcfg->type, cp->idx), 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_mu_shutdown(struct mbox_chan *chan)\n{\n\tstruct imx_mu_priv *priv = to_imx_mu_priv(chan->mbox);\n\tstruct imx_mu_con_priv *cp = chan->con_priv;\n\tint ret;\n\tu32 sr;\n\n\tif (cp->type == IMX_MU_TYPE_TXDB) {\n\t\ttasklet_kill(&cp->txdb_tasklet);\n\t\tpm_runtime_put_sync(priv->dev);\n\t\treturn;\n\t}\n\n\tswitch (cp->type) {\n\tcase IMX_MU_TYPE_TX:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_TCR, 0, IMX_MU_xCR_TIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RX:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_RCR, 0, IMX_MU_xCR_RIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RXDB:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_GIER, 0, IMX_MU_xCR_GIEn(priv->dcfg->type, cp->idx));\n\t\tbreak;\n\tcase IMX_MU_TYPE_RST:\n\t\timx_mu_xcr_rmw(priv, IMX_MU_CR, IMX_MU_xCR_RST(priv->dcfg->type), 0);\n\t\tret = readl_poll_timeout(priv->base + priv->dcfg->xSR[IMX_MU_SR], sr,\n\t\t\t\t\t !(sr & IMX_MU_xSR_RST(priv->dcfg->type)), 1, 5);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"RST channel timeout\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfree_irq(priv->irq[cp->type], chan);\n\tpm_runtime_put_sync(priv->dev);\n}\n\nstatic const struct mbox_chan_ops imx_mu_ops = {\n\t.send_data = imx_mu_send_data,\n\t.startup = imx_mu_startup,\n\t.shutdown = imx_mu_shutdown,\n};\n\nstatic struct mbox_chan *imx_mu_specific_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t       const struct of_phandle_args *sp)\n{\n\tu32 type, idx, chan;\n\n\tif (sp->args_count != 2) {\n\t\tdev_err(mbox->dev, \"Invalid argument count %d\\n\", sp->args_count);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttype = sp->args[0];  \n\tidx = sp->args[1];  \n\n\tswitch (type) {\n\tcase IMX_MU_TYPE_TX:\n\tcase IMX_MU_TYPE_RX:\n\t\tif (idx != 0)\n\t\t\tdev_err(mbox->dev, \"Invalid chan idx: %d\\n\", idx);\n\t\tchan = type;\n\t\tbreak;\n\tcase IMX_MU_TYPE_RXDB:\n\t\tchan = 2 + idx;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mbox->dev, \"Invalid chan type: %d\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (chan >= mbox->num_chans) {\n\t\tdev_err(mbox->dev, \"Not supported channel number: %d. (type: %d, idx: %d)\\n\", chan, type, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &mbox->chans[chan];\n}\n\nstatic struct mbox_chan * imx_mu_xlate(struct mbox_controller *mbox,\n\t\t\t\t       const struct of_phandle_args *sp)\n{\n\tu32 type, idx, chan;\n\n\tif (sp->args_count != 2) {\n\t\tdev_err(mbox->dev, \"Invalid argument count %d\\n\", sp->args_count);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttype = sp->args[0];  \n\tidx = sp->args[1];  \n\tchan = type * 4 + idx;\n\n\tif (chan >= mbox->num_chans) {\n\t\tdev_err(mbox->dev, \"Not supported channel number: %d. (type: %d, idx: %d)\\n\", chan, type, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &mbox->chans[chan];\n}\n\nstatic struct mbox_chan *imx_mu_seco_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t   const struct of_phandle_args *sp)\n{\n\tu32 type;\n\n\tif (sp->args_count < 1) {\n\t\tdev_err(mbox->dev, \"Invalid argument count %d\\n\", sp->args_count);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttype = sp->args[0];  \n\n\t \n\tif (type == IMX_MU_TYPE_TX || type == IMX_MU_TYPE_RX) {\n\t\tdev_err(mbox->dev, \"Invalid type: %d\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn imx_mu_xlate(mbox, sp);\n}\n\nstatic void imx_mu_init_generic(struct imx_mu_priv *priv)\n{\n\tunsigned int i;\n\tunsigned int val;\n\n\tfor (i = 0; i < IMX_MU_CHANS; i++) {\n\t\tstruct imx_mu_con_priv *cp = &priv->con_priv[i];\n\n\t\tcp->idx = i % 4;\n\t\tcp->type = i >> 2;\n\t\tcp->chan = &priv->mbox_chans[i];\n\t\tpriv->mbox_chans[i].con_priv = cp;\n\t\tsnprintf(cp->irq_desc, sizeof(cp->irq_desc),\n\t\t\t \"imx_mu_chan[%i-%i]\", cp->type, cp->idx);\n\t}\n\n\tpriv->mbox.num_chans = IMX_MU_CHANS;\n\tpriv->mbox.of_xlate = imx_mu_xlate;\n\n\tif (priv->side_b)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < IMX_MU_xCR_MAX; i++)\n\t\timx_mu_write(priv, 0, priv->dcfg->xCR[i]);\n\n\t \n\tval = imx_mu_read(priv, priv->dcfg->xSR[IMX_MU_GSR]);\n\timx_mu_write(priv, val, priv->dcfg->xSR[IMX_MU_GSR]);\n\n\t \n\tfor (i = 0; i < IMX_MU_NUM_RR; i++)\n\t\timx_mu_read(priv, priv->dcfg->xRR + (i % 4) * 4);\n}\n\nstatic void imx_mu_init_specific(struct imx_mu_priv *priv)\n{\n\tunsigned int i;\n\tint num_chans = priv->dcfg->type & IMX_MU_V2_S4 ? IMX_MU_S4_CHANS : IMX_MU_SCU_CHANS;\n\n\tfor (i = 0; i < num_chans; i++) {\n\t\tstruct imx_mu_con_priv *cp = &priv->con_priv[i];\n\n\t\tcp->idx = i < 2 ? 0 : i - 2;\n\t\tcp->type = i < 2 ? i : IMX_MU_TYPE_RXDB;\n\t\tcp->chan = &priv->mbox_chans[i];\n\t\tpriv->mbox_chans[i].con_priv = cp;\n\t\tsnprintf(cp->irq_desc, sizeof(cp->irq_desc),\n\t\t\t \"imx_mu_chan[%i-%i]\", cp->type, cp->idx);\n\t}\n\n\tpriv->mbox.num_chans = num_chans;\n\tpriv->mbox.of_xlate = imx_mu_specific_xlate;\n\n\t \n\tfor (i = 0; i < IMX_MU_xCR_MAX; i++)\n\t\timx_mu_write(priv, 0, priv->dcfg->xCR[i]);\n}\n\nstatic void imx_mu_init_seco(struct imx_mu_priv *priv)\n{\n\timx_mu_init_generic(priv);\n\tpriv->mbox.of_xlate = imx_mu_seco_xlate;\n}\n\nstatic int imx_mu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct imx_mu_priv *priv;\n\tconst struct imx_mu_dcfg *dcfg;\n\tint i, ret;\n\tu32 size;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tdcfg = of_device_get_match_data(dev);\n\tif (!dcfg)\n\t\treturn -EINVAL;\n\tpriv->dcfg = dcfg;\n\tif (priv->dcfg->type & IMX_MU_V2_IRQ) {\n\t\tpriv->irq[IMX_MU_TYPE_TX] = platform_get_irq_byname(pdev, \"tx\");\n\t\tif (priv->irq[IMX_MU_TYPE_TX] < 0)\n\t\t\treturn priv->irq[IMX_MU_TYPE_TX];\n\t\tpriv->irq[IMX_MU_TYPE_RX] = platform_get_irq_byname(pdev, \"rx\");\n\t\tif (priv->irq[IMX_MU_TYPE_RX] < 0)\n\t\t\treturn priv->irq[IMX_MU_TYPE_RX];\n\t} else {\n\t\tret = platform_get_irq(pdev, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < IMX_MU_CHANS; i++)\n\t\t\tpriv->irq[i] = ret;\n\t}\n\n\tif (priv->dcfg->type & IMX_MU_V2_S4)\n\t\tsize = sizeof(struct imx_s4_rpc_msg_max);\n\telse\n\t\tsize = sizeof(struct imx_sc_rpc_msg_max);\n\n\tpriv->msg = devm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!priv->msg)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tif (PTR_ERR(priv->clk) != -ENOENT)\n\t\t\treturn PTR_ERR(priv->clk);\n\n\t\tpriv->clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->side_b = of_property_read_bool(np, \"fsl,mu-side-b\");\n\n\tpriv->dcfg->init(priv);\n\n\tspin_lock_init(&priv->xcr_lock);\n\n\tpriv->mbox.dev = dev;\n\tpriv->mbox.ops = &imx_mu_ops;\n\tpriv->mbox.chans = priv->mbox_chans;\n\tpriv->mbox.txdone_irq = true;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = devm_mbox_controller_register(dev, &priv->mbox);\n\tif (ret) {\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto disable_runtime_pm;\n\n\tret = pm_runtime_put_sync(dev);\n\tif (ret < 0)\n\t\tgoto disable_runtime_pm;\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n\ndisable_runtime_pm:\n\tpm_runtime_disable(dev);\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic int imx_mu_remove(struct platform_device *pdev)\n{\n\tstruct imx_mu_priv *priv = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(priv->dev);\n\n\treturn 0;\n}\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx6sx = {\n\t.tx\t= imx_mu_generic_tx,\n\t.rx\t= imx_mu_generic_rx,\n\t.rxdb\t= imx_mu_generic_rxdb,\n\t.init\t= imx_mu_init_generic,\n\t.xTR\t= 0x0,\n\t.xRR\t= 0x10,\n\t.xSR\t= {0x20, 0x20, 0x20, 0x20},\n\t.xCR\t= {0x24, 0x24, 0x24, 0x24, 0x24},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx7ulp = {\n\t.tx\t= imx_mu_generic_tx,\n\t.rx\t= imx_mu_generic_rx,\n\t.rxdb\t= imx_mu_generic_rxdb,\n\t.init\t= imx_mu_init_generic,\n\t.xTR\t= 0x20,\n\t.xRR\t= 0x40,\n\t.xSR\t= {0x60, 0x60, 0x60, 0x60},\n\t.xCR\t= {0x64, 0x64, 0x64, 0x64, 0x64},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx8ulp = {\n\t.tx\t= imx_mu_generic_tx,\n\t.rx\t= imx_mu_generic_rx,\n\t.rxdb\t= imx_mu_generic_rxdb,\n\t.init\t= imx_mu_init_generic,\n\t.type\t= IMX_MU_V2,\n\t.xTR\t= 0x200,\n\t.xRR\t= 0x280,\n\t.xSR\t= {0xC, 0x118, 0x124, 0x12C},\n\t.xCR\t= {0x8, 0x110, 0x114, 0x120, 0x128},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx8ulp_s4 = {\n\t.tx\t= imx_mu_specific_tx,\n\t.rx\t= imx_mu_specific_rx,\n\t.init\t= imx_mu_init_specific,\n\t.type\t= IMX_MU_V2 | IMX_MU_V2_S4,\n\t.xTR\t= 0x200,\n\t.xRR\t= 0x280,\n\t.xSR\t= {0xC, 0x118, 0x124, 0x12C},\n\t.xCR\t= {0x8, 0x110, 0x114, 0x120, 0x128},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx93_s4 = {\n\t.tx\t= imx_mu_specific_tx,\n\t.rx\t= imx_mu_specific_rx,\n\t.init\t= imx_mu_init_specific,\n\t.type\t= IMX_MU_V2 | IMX_MU_V2_S4 | IMX_MU_V2_IRQ,\n\t.xTR\t= 0x200,\n\t.xRR\t= 0x280,\n\t.xSR\t= {0xC, 0x118, 0x124, 0x12C},\n\t.xCR\t= {0x8, 0x110, 0x114, 0x120, 0x128},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx8_scu = {\n\t.tx\t= imx_mu_specific_tx,\n\t.rx\t= imx_mu_specific_rx,\n\t.init\t= imx_mu_init_specific,\n\t.rxdb\t= imx_mu_generic_rxdb,\n\t.xTR\t= 0x0,\n\t.xRR\t= 0x10,\n\t.xSR\t= {0x20, 0x20, 0x20, 0x20},\n\t.xCR\t= {0x24, 0x24, 0x24, 0x24, 0x24},\n};\n\nstatic const struct imx_mu_dcfg imx_mu_cfg_imx8_seco = {\n\t.tx\t= imx_mu_seco_tx,\n\t.rx\t= imx_mu_generic_rx,\n\t.rxdb\t= imx_mu_seco_rxdb,\n\t.init\t= imx_mu_init_seco,\n\t.xTR\t= 0x0,\n\t.xRR\t= 0x10,\n\t.xSR\t= {0x20, 0x20, 0x20, 0x20},\n\t.xCR\t= {0x24, 0x24, 0x24, 0x24, 0x24},\n};\n\nstatic const struct of_device_id imx_mu_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7ulp-mu\", .data = &imx_mu_cfg_imx7ulp },\n\t{ .compatible = \"fsl,imx6sx-mu\", .data = &imx_mu_cfg_imx6sx },\n\t{ .compatible = \"fsl,imx8ulp-mu\", .data = &imx_mu_cfg_imx8ulp },\n\t{ .compatible = \"fsl,imx8ulp-mu-s4\", .data = &imx_mu_cfg_imx8ulp_s4 },\n\t{ .compatible = \"fsl,imx93-mu-s4\", .data = &imx_mu_cfg_imx93_s4 },\n\t{ .compatible = \"fsl,imx8-mu-scu\", .data = &imx_mu_cfg_imx8_scu },\n\t{ .compatible = \"fsl,imx8-mu-seco\", .data = &imx_mu_cfg_imx8_seco },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx_mu_dt_ids);\n\nstatic int __maybe_unused imx_mu_suspend_noirq(struct device *dev)\n{\n\tstruct imx_mu_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\n\tif (!priv->clk) {\n\t\tfor (i = 0; i < IMX_MU_xCR_MAX; i++)\n\t\t\tpriv->xcr[i] = imx_mu_read(priv, priv->dcfg->xCR[i]);\n\t}\n\n\tpriv->suspend = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_mu_resume_noirq(struct device *dev)\n{\n\tstruct imx_mu_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tif (!priv->clk && !imx_mu_read(priv, priv->dcfg->xCR[0])) {\n\t\tfor (i = 0; i < IMX_MU_xCR_MAX; i++)\n\t\t\timx_mu_write(priv, priv->xcr[i], priv->dcfg->xCR[i]);\n\t}\n\n\tpriv->suspend = false;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_mu_runtime_suspend(struct device *dev)\n{\n\tstruct imx_mu_priv *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_mu_runtime_resume(struct device *dev)\n{\n\tstruct imx_mu_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx_mu_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_mu_suspend_noirq,\n\t\t\t\t      imx_mu_resume_noirq)\n\tSET_RUNTIME_PM_OPS(imx_mu_runtime_suspend,\n\t\t\t   imx_mu_runtime_resume, NULL)\n};\n\nstatic struct platform_driver imx_mu_driver = {\n\t.probe\t\t= imx_mu_probe,\n\t.remove\t\t= imx_mu_remove,\n\t.driver = {\n\t\t.name\t= \"imx_mu\",\n\t\t.of_match_table = imx_mu_dt_ids,\n\t\t.pm = &imx_mu_pm_ops,\n\t},\n};\nmodule_platform_driver(imx_mu_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <o.rempel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Message Unit driver for i.MX\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}