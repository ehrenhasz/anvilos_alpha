{
  "module_name": "tegra-hsp.c",
  "hash_id": "8cef4ec21c5c0df36d6c183f955f49ae51538d1f66d694765fe91d88801ff744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/tegra-hsp.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_controller.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/fuse.h>\n\n#include <dt-bindings/mailbox/tegra186-hsp.h>\n\n#include \"mailbox.h\"\n\n#define HSP_INT_IE(x)\t\t(0x100 + ((x) * 4))\n#define HSP_INT_IV\t\t0x300\n#define HSP_INT_IR\t\t0x304\n\n#define HSP_INT_EMPTY_SHIFT\t0\n#define HSP_INT_EMPTY_MASK\t0xff\n#define HSP_INT_FULL_SHIFT\t8\n#define HSP_INT_FULL_MASK\t0xff\n\n#define HSP_INT_DIMENSIONING\t0x380\n#define HSP_nSM_SHIFT\t\t0\n#define HSP_nSS_SHIFT\t\t4\n#define HSP_nAS_SHIFT\t\t8\n#define HSP_nDB_SHIFT\t\t12\n#define HSP_nSI_SHIFT\t\t16\n#define HSP_nINT_MASK\t\t0xf\n\n#define HSP_DB_TRIGGER\t0x0\n#define HSP_DB_ENABLE\t0x4\n#define HSP_DB_RAW\t0x8\n#define HSP_DB_PENDING\t0xc\n\n#define HSP_SM_SHRD_MBOX\t0x0\n#define HSP_SM_SHRD_MBOX_FULL\tBIT(31)\n#define HSP_SM_SHRD_MBOX_FULL_INT_IE\t0x04\n#define HSP_SM_SHRD_MBOX_EMPTY_INT_IE\t0x08\n\n#define HSP_SHRD_MBOX_TYPE1_TAG\t\t0x40\n#define HSP_SHRD_MBOX_TYPE1_DATA0\t0x48\n#define HSP_SHRD_MBOX_TYPE1_DATA1\t0x4c\n#define HSP_SHRD_MBOX_TYPE1_DATA2\t0x50\n#define HSP_SHRD_MBOX_TYPE1_DATA3\t0x54\n\n#define HSP_DB_CCPLEX\t\t1\n#define HSP_DB_BPMP\t\t3\n#define HSP_DB_MAX\t\t7\n\n#define HSP_MBOX_TYPE_MASK\t0xff\n\nstruct tegra_hsp_channel;\nstruct tegra_hsp;\n\nstruct tegra_hsp_channel {\n\tstruct tegra_hsp *hsp;\n\tstruct mbox_chan *chan;\n\tvoid __iomem *regs;\n};\n\nstruct tegra_hsp_doorbell {\n\tstruct tegra_hsp_channel channel;\n\tstruct list_head list;\n\tconst char *name;\n\tunsigned int master;\n\tunsigned int index;\n};\n\nstruct tegra_hsp_sm_ops {\n\tvoid (*send)(struct tegra_hsp_channel *channel, void *data);\n\tvoid (*recv)(struct tegra_hsp_channel *channel);\n};\n\nstruct tegra_hsp_mailbox {\n\tstruct tegra_hsp_channel channel;\n\tconst struct tegra_hsp_sm_ops *ops;\n\tunsigned int index;\n\tbool producer;\n};\n\nstruct tegra_hsp_db_map {\n\tconst char *name;\n\tunsigned int master;\n\tunsigned int index;\n};\n\nstruct tegra_hsp_soc {\n\tconst struct tegra_hsp_db_map *map;\n\tbool has_per_mb_ie;\n\tbool has_128_bit_mb;\n\tunsigned int reg_stride;\n};\n\nstruct tegra_hsp {\n\tstruct device *dev;\n\tconst struct tegra_hsp_soc *soc;\n\tstruct mbox_controller mbox_db;\n\tstruct mbox_controller mbox_sm;\n\tvoid __iomem *regs;\n\tunsigned int doorbell_irq;\n\tunsigned int *shared_irqs;\n\tunsigned int shared_irq;\n\tunsigned int num_sm;\n\tunsigned int num_as;\n\tunsigned int num_ss;\n\tunsigned int num_db;\n\tunsigned int num_si;\n\n\tspinlock_t lock;\n\tstruct lock_class_key lock_key;\n\n\tstruct list_head doorbells;\n\tstruct tegra_hsp_mailbox *mailboxes;\n\n\tunsigned long mask;\n};\n\nstatic inline u32 tegra_hsp_readl(struct tegra_hsp *hsp, unsigned int offset)\n{\n\treturn readl(hsp->regs + offset);\n}\n\nstatic inline void tegra_hsp_writel(struct tegra_hsp *hsp, u32 value,\n\t\t\t\t    unsigned int offset)\n{\n\twritel(value, hsp->regs + offset);\n}\n\nstatic inline u32 tegra_hsp_channel_readl(struct tegra_hsp_channel *channel,\n\t\t\t\t\t  unsigned int offset)\n{\n\treturn readl(channel->regs + offset);\n}\n\nstatic inline void tegra_hsp_channel_writel(struct tegra_hsp_channel *channel,\n\t\t\t\t\t    u32 value, unsigned int offset)\n{\n\twritel(value, channel->regs + offset);\n}\n\nstatic bool tegra_hsp_doorbell_can_ring(struct tegra_hsp_doorbell *db)\n{\n\tu32 value;\n\n\tvalue = tegra_hsp_channel_readl(&db->channel, HSP_DB_ENABLE);\n\n\treturn (value & BIT(TEGRA_HSP_DB_MASTER_CCPLEX)) != 0;\n}\n\nstatic struct tegra_hsp_doorbell *\n__tegra_hsp_doorbell_get(struct tegra_hsp *hsp, unsigned int master)\n{\n\tstruct tegra_hsp_doorbell *entry;\n\n\tlist_for_each_entry(entry, &hsp->doorbells, list)\n\t\tif (entry->master == master)\n\t\t\treturn entry;\n\n\treturn NULL;\n}\n\nstatic struct tegra_hsp_doorbell *\ntegra_hsp_doorbell_get(struct tegra_hsp *hsp, unsigned int master)\n{\n\tstruct tegra_hsp_doorbell *db;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\tdb = __tegra_hsp_doorbell_get(hsp, master);\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\treturn db;\n}\n\nstatic irqreturn_t tegra_hsp_doorbell_irq(int irq, void *data)\n{\n\tstruct tegra_hsp *hsp = data;\n\tstruct tegra_hsp_doorbell *db;\n\tunsigned long master, value;\n\n\tdb = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\n\tif (!db)\n\t\treturn IRQ_NONE;\n\n\tvalue = tegra_hsp_channel_readl(&db->channel, HSP_DB_PENDING);\n\ttegra_hsp_channel_writel(&db->channel, value, HSP_DB_PENDING);\n\n\tspin_lock(&hsp->lock);\n\n\tfor_each_set_bit(master, &value, hsp->mbox_db.num_chans) {\n\t\tstruct tegra_hsp_doorbell *db;\n\n\t\tdb = __tegra_hsp_doorbell_get(hsp, master);\n\t\t \n\t\tif (db && db->channel.chan)\n\t\t\tmbox_chan_received_data(db->channel.chan, NULL);\n\t}\n\n\tspin_unlock(&hsp->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_hsp_shared_irq(int irq, void *data)\n{\n\tstruct tegra_hsp *hsp = data;\n\tunsigned long bit, mask;\n\tu32 status;\n\n\tstatus = tegra_hsp_readl(hsp, HSP_INT_IR) & hsp->mask;\n\n\t \n\tmask = (status >> HSP_INT_EMPTY_SHIFT) & HSP_INT_EMPTY_MASK;\n\n\tfor_each_set_bit(bit, &mask, hsp->num_sm) {\n\t\tstruct tegra_hsp_mailbox *mb = &hsp->mailboxes[bit];\n\n\t\tif (mb->producer) {\n\t\t\t \n\t\t\tspin_lock(&hsp->lock);\n\n\t\t\thsp->mask &= ~BIT(HSP_INT_EMPTY_SHIFT + mb->index);\n\t\t\ttegra_hsp_writel(hsp, hsp->mask,\n\t\t\t\t\t HSP_INT_IE(hsp->shared_irq));\n\n\t\t\tspin_unlock(&hsp->lock);\n\n\t\t\tmbox_chan_txdone(mb->channel.chan, 0);\n\t\t}\n\t}\n\n\t \n\tmask = (status >> HSP_INT_FULL_SHIFT) & HSP_INT_FULL_MASK;\n\n\tfor_each_set_bit(bit, &mask, hsp->num_sm) {\n\t\tstruct tegra_hsp_mailbox *mb = &hsp->mailboxes[bit];\n\n\t\tif (!mb->producer)\n\t\t\tmb->ops->recv(&mb->channel);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct tegra_hsp_channel *\ntegra_hsp_doorbell_create(struct tegra_hsp *hsp, const char *name,\n\t\t\t  unsigned int master, unsigned int index)\n{\n\tstruct tegra_hsp_doorbell *db;\n\tunsigned int offset;\n\tunsigned long flags;\n\n\tdb = devm_kzalloc(hsp->dev, sizeof(*db), GFP_KERNEL);\n\tif (!db)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toffset = (1 + (hsp->num_sm / 2) + hsp->num_ss + hsp->num_as) * SZ_64K;\n\toffset += index * hsp->soc->reg_stride;\n\n\tdb->channel.regs = hsp->regs + offset;\n\tdb->channel.hsp = hsp;\n\n\tdb->name = devm_kstrdup_const(hsp->dev, name, GFP_KERNEL);\n\tdb->master = master;\n\tdb->index = index;\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\tlist_add_tail(&db->list, &hsp->doorbells);\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\treturn &db->channel;\n}\n\nstatic int tegra_hsp_doorbell_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct tegra_hsp_doorbell *db = chan->con_priv;\n\n\ttegra_hsp_channel_writel(&db->channel, 1, HSP_DB_TRIGGER);\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_doorbell_startup(struct mbox_chan *chan)\n{\n\tstruct tegra_hsp_doorbell *db = chan->con_priv;\n\tstruct tegra_hsp *hsp = db->channel.hsp;\n\tstruct tegra_hsp_doorbell *ccplex;\n\tunsigned long flags;\n\tu32 value;\n\n\tif (db->master >= chan->mbox->num_chans) {\n\t\tdev_err(chan->mbox->dev,\n\t\t\t\"invalid master ID %u for HSP channel\\n\",\n\t\t\tdb->master);\n\t\treturn -EINVAL;\n\t}\n\n\tccplex = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\n\tif (!ccplex)\n\t\treturn -ENODEV;\n\n\t \n\tif (tegra_is_silicon() && !tegra_hsp_doorbell_can_ring(db))\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\tvalue = tegra_hsp_channel_readl(&ccplex->channel, HSP_DB_ENABLE);\n\tvalue |= BIT(db->master);\n\ttegra_hsp_channel_writel(&ccplex->channel, value, HSP_DB_ENABLE);\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\treturn 0;\n}\n\nstatic void tegra_hsp_doorbell_shutdown(struct mbox_chan *chan)\n{\n\tstruct tegra_hsp_doorbell *db = chan->con_priv;\n\tstruct tegra_hsp *hsp = db->channel.hsp;\n\tstruct tegra_hsp_doorbell *ccplex;\n\tunsigned long flags;\n\tu32 value;\n\n\tccplex = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\n\tif (!ccplex)\n\t\treturn;\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\tvalue = tegra_hsp_channel_readl(&ccplex->channel, HSP_DB_ENABLE);\n\tvalue &= ~BIT(db->master);\n\ttegra_hsp_channel_writel(&ccplex->channel, value, HSP_DB_ENABLE);\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n}\n\nstatic const struct mbox_chan_ops tegra_hsp_db_ops = {\n\t.send_data = tegra_hsp_doorbell_send_data,\n\t.startup = tegra_hsp_doorbell_startup,\n\t.shutdown = tegra_hsp_doorbell_shutdown,\n};\n\nstatic void tegra_hsp_sm_send32(struct tegra_hsp_channel *channel, void *data)\n{\n\tu32 value;\n\n\t \n\tvalue = (u32)(unsigned long)data;\n\tvalue |= HSP_SM_SHRD_MBOX_FULL;\n\n\ttegra_hsp_channel_writel(channel, value, HSP_SM_SHRD_MBOX);\n}\n\nstatic void tegra_hsp_sm_recv32(struct tegra_hsp_channel *channel)\n{\n\tu32 value;\n\tvoid *msg;\n\n\tvalue = tegra_hsp_channel_readl(channel, HSP_SM_SHRD_MBOX);\n\tvalue &= ~HSP_SM_SHRD_MBOX_FULL;\n\tmsg = (void *)(unsigned long)value;\n\tmbox_chan_received_data(channel->chan, msg);\n\n\t \n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SM_SHRD_MBOX);\n}\n\nstatic const struct tegra_hsp_sm_ops tegra_hsp_sm_32bit_ops = {\n\t.send = tegra_hsp_sm_send32,\n\t.recv = tegra_hsp_sm_recv32,\n};\n\nstatic void tegra_hsp_sm_send128(struct tegra_hsp_channel *channel, void *data)\n{\n\tu32 value[4];\n\n\tmemcpy(value, data, sizeof(value));\n\n\t \n\ttegra_hsp_channel_writel(channel, value[0], HSP_SHRD_MBOX_TYPE1_DATA0);\n\ttegra_hsp_channel_writel(channel, value[1], HSP_SHRD_MBOX_TYPE1_DATA1);\n\ttegra_hsp_channel_writel(channel, value[2], HSP_SHRD_MBOX_TYPE1_DATA2);\n\ttegra_hsp_channel_writel(channel, value[3], HSP_SHRD_MBOX_TYPE1_DATA3);\n\n\t \n\ttegra_hsp_channel_writel(channel, HSP_SM_SHRD_MBOX_FULL,\n\t\t\t\t HSP_SHRD_MBOX_TYPE1_TAG);\n}\n\nstatic void tegra_hsp_sm_recv128(struct tegra_hsp_channel *channel)\n{\n\tu32 value[4];\n\tvoid *msg;\n\n\tvalue[0] = tegra_hsp_channel_readl(channel, HSP_SHRD_MBOX_TYPE1_DATA0);\n\tvalue[1] = tegra_hsp_channel_readl(channel, HSP_SHRD_MBOX_TYPE1_DATA1);\n\tvalue[2] = tegra_hsp_channel_readl(channel, HSP_SHRD_MBOX_TYPE1_DATA2);\n\tvalue[3] = tegra_hsp_channel_readl(channel, HSP_SHRD_MBOX_TYPE1_DATA3);\n\n\tmsg = (void *)(unsigned long)value;\n\tmbox_chan_received_data(channel->chan, msg);\n\n\t \n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SHRD_MBOX_TYPE1_DATA0);\n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SHRD_MBOX_TYPE1_DATA1);\n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SHRD_MBOX_TYPE1_DATA2);\n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SHRD_MBOX_TYPE1_DATA3);\n\ttegra_hsp_channel_writel(channel, 0x0, HSP_SHRD_MBOX_TYPE1_TAG);\n}\n\nstatic const struct tegra_hsp_sm_ops tegra_hsp_sm_128bit_ops = {\n\t.send = tegra_hsp_sm_send128,\n\t.recv = tegra_hsp_sm_recv128,\n};\n\nstatic int tegra_hsp_mailbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct tegra_hsp_mailbox *mb = chan->con_priv;\n\tstruct tegra_hsp *hsp = mb->channel.hsp;\n\tunsigned long flags;\n\n\tif (WARN_ON(!mb->producer))\n\t\treturn -EPERM;\n\n\tmb->ops->send(&mb->channel, data);\n\n\t \n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\thsp->mask |= BIT(HSP_INT_EMPTY_SHIFT + mb->index);\n\ttegra_hsp_writel(hsp, hsp->mask, HSP_INT_IE(hsp->shared_irq));\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_mailbox_flush(struct mbox_chan *chan,\n\t\t\t\t   unsigned long timeout)\n{\n\tstruct tegra_hsp_mailbox *mb = chan->con_priv;\n\tstruct tegra_hsp_channel *ch = &mb->channel;\n\tu32 value;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_hsp_channel_readl(ch, HSP_SM_SHRD_MBOX);\n\t\tif ((value & HSP_SM_SHRD_MBOX_FULL) == 0) {\n\t\t\tmbox_chan_txdone(chan, 0);\n\n\t\t\t \n\t\t\tif (chan->active_req != NULL)\n\t\t\t\tcontinue;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIME;\n}\n\nstatic int tegra_hsp_mailbox_startup(struct mbox_chan *chan)\n{\n\tstruct tegra_hsp_mailbox *mb = chan->con_priv;\n\tstruct tegra_hsp_channel *ch = &mb->channel;\n\tstruct tegra_hsp *hsp = mb->channel.hsp;\n\tunsigned long flags;\n\n\tchan->txdone_method = TXDONE_BY_IRQ;\n\n\t \n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\tif (mb->producer)\n\t\thsp->mask &= ~BIT(HSP_INT_EMPTY_SHIFT + mb->index);\n\telse\n\t\thsp->mask |= BIT(HSP_INT_FULL_SHIFT + mb->index);\n\n\ttegra_hsp_writel(hsp, hsp->mask, HSP_INT_IE(hsp->shared_irq));\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\tif (hsp->soc->has_per_mb_ie) {\n\t\tif (mb->producer)\n\t\t\ttegra_hsp_channel_writel(ch, 0x0,\n\t\t\t\t\t\t HSP_SM_SHRD_MBOX_EMPTY_INT_IE);\n\t\telse\n\t\t\ttegra_hsp_channel_writel(ch, 0x1,\n\t\t\t\t\t\t HSP_SM_SHRD_MBOX_FULL_INT_IE);\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_hsp_mailbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct tegra_hsp_mailbox *mb = chan->con_priv;\n\tstruct tegra_hsp_channel *ch = &mb->channel;\n\tstruct tegra_hsp *hsp = mb->channel.hsp;\n\tunsigned long flags;\n\n\tif (hsp->soc->has_per_mb_ie) {\n\t\tif (mb->producer)\n\t\t\ttegra_hsp_channel_writel(ch, 0x0,\n\t\t\t\t\t\t HSP_SM_SHRD_MBOX_EMPTY_INT_IE);\n\t\telse\n\t\t\ttegra_hsp_channel_writel(ch, 0x0,\n\t\t\t\t\t\t HSP_SM_SHRD_MBOX_FULL_INT_IE);\n\t}\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\tif (mb->producer)\n\t\thsp->mask &= ~BIT(HSP_INT_EMPTY_SHIFT + mb->index);\n\telse\n\t\thsp->mask &= ~BIT(HSP_INT_FULL_SHIFT + mb->index);\n\n\ttegra_hsp_writel(hsp, hsp->mask, HSP_INT_IE(hsp->shared_irq));\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n}\n\nstatic const struct mbox_chan_ops tegra_hsp_sm_ops = {\n\t.send_data = tegra_hsp_mailbox_send_data,\n\t.flush = tegra_hsp_mailbox_flush,\n\t.startup = tegra_hsp_mailbox_startup,\n\t.shutdown = tegra_hsp_mailbox_shutdown,\n};\n\nstatic struct mbox_chan *tegra_hsp_db_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t    const struct of_phandle_args *args)\n{\n\tstruct tegra_hsp *hsp = container_of(mbox, struct tegra_hsp, mbox_db);\n\tunsigned int type = args->args[0], master = args->args[1];\n\tstruct tegra_hsp_channel *channel = ERR_PTR(-ENODEV);\n\tstruct tegra_hsp_doorbell *db;\n\tstruct mbox_chan *chan;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (type != TEGRA_HSP_MBOX_TYPE_DB || !hsp->doorbell_irq)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdb = tegra_hsp_doorbell_get(hsp, master);\n\tif (db)\n\t\tchannel = &db->channel;\n\n\tif (IS_ERR(channel))\n\t\treturn ERR_CAST(channel);\n\n\tspin_lock_irqsave(&hsp->lock, flags);\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tchan = &mbox->chans[i];\n\t\tif (!chan->con_priv) {\n\t\t\tchannel->chan = chan;\n\t\t\tchan->con_priv = db;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&hsp->lock, flags);\n\n\treturn chan ?: ERR_PTR(-EBUSY);\n}\n\nstatic struct mbox_chan *tegra_hsp_sm_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t    const struct of_phandle_args *args)\n{\n\tstruct tegra_hsp *hsp = container_of(mbox, struct tegra_hsp, mbox_sm);\n\tunsigned int type = args->args[0], index;\n\tstruct tegra_hsp_mailbox *mb;\n\n\tindex = args->args[1] & TEGRA_HSP_SM_MASK;\n\n\tif ((type & HSP_MBOX_TYPE_MASK) != TEGRA_HSP_MBOX_TYPE_SM ||\n\t    !hsp->shared_irqs || index >= hsp->num_sm)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmb = &hsp->mailboxes[index];\n\n\tif (type & TEGRA_HSP_MBOX_TYPE_SM_128BIT) {\n\t\tif (!hsp->soc->has_128_bit_mb)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\tmb->ops = &tegra_hsp_sm_128bit_ops;\n\t} else {\n\t\tmb->ops = &tegra_hsp_sm_32bit_ops;\n\t}\n\n\tif ((args->args[1] & TEGRA_HSP_SM_FLAG_TX) == 0)\n\t\tmb->producer = false;\n\telse\n\t\tmb->producer = true;\n\n\treturn mb->channel.chan;\n}\n\nstatic int tegra_hsp_add_doorbells(struct tegra_hsp *hsp)\n{\n\tconst struct tegra_hsp_db_map *map = hsp->soc->map;\n\tstruct tegra_hsp_channel *channel;\n\n\twhile (map->name) {\n\t\tchannel = tegra_hsp_doorbell_create(hsp, map->name,\n\t\t\t\t\t\t    map->master, map->index);\n\t\tif (IS_ERR(channel))\n\t\t\treturn PTR_ERR(channel);\n\n\t\tmap++;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_add_mailboxes(struct tegra_hsp *hsp, struct device *dev)\n{\n\tint i;\n\n\thsp->mailboxes = devm_kcalloc(dev, hsp->num_sm, sizeof(*hsp->mailboxes),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hsp->mailboxes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hsp->num_sm; i++) {\n\t\tstruct tegra_hsp_mailbox *mb = &hsp->mailboxes[i];\n\n\t\tmb->index = i;\n\n\t\tmb->channel.hsp = hsp;\n\t\tmb->channel.regs = hsp->regs + SZ_64K + i * SZ_32K;\n\t\tmb->channel.chan = &hsp->mbox_sm.chans[i];\n\t\tmb->channel.chan->con_priv = mb;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_request_shared_irq(struct tegra_hsp *hsp)\n{\n\tunsigned int i, irq = 0;\n\tint err;\n\n\tfor (i = 0; i < hsp->num_si; i++) {\n\t\tirq = hsp->shared_irqs[i];\n\t\tif (irq <= 0)\n\t\t\tcontinue;\n\n\t\terr = devm_request_irq(hsp->dev, irq, tegra_hsp_shared_irq, 0,\n\t\t\t\t       dev_name(hsp->dev), hsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(hsp->dev, \"failed to request interrupt: %d\\n\",\n\t\t\t\terr);\n\t\t\tcontinue;\n\t\t}\n\n\t\thsp->shared_irq = i;\n\n\t\t \n\t\ttegra_hsp_writel(hsp, 0, HSP_INT_IE(hsp->shared_irq));\n\n\t\tdev_dbg(hsp->dev, \"interrupt requested: %u\\n\", irq);\n\n\t\tbreak;\n\t}\n\n\tif (i == hsp->num_si) {\n\t\tdev_err(hsp->dev, \"failed to find available interrupt\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_probe(struct platform_device *pdev)\n{\n\tstruct tegra_hsp *hsp;\n\tunsigned int i;\n\tu32 value;\n\tint err;\n\n\thsp = devm_kzalloc(&pdev->dev, sizeof(*hsp), GFP_KERNEL);\n\tif (!hsp)\n\t\treturn -ENOMEM;\n\n\thsp->dev = &pdev->dev;\n\thsp->soc = of_device_get_match_data(&pdev->dev);\n\tINIT_LIST_HEAD(&hsp->doorbells);\n\tspin_lock_init(&hsp->lock);\n\n\thsp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hsp->regs))\n\t\treturn PTR_ERR(hsp->regs);\n\n\tvalue = tegra_hsp_readl(hsp, HSP_INT_DIMENSIONING);\n\thsp->num_sm = (value >> HSP_nSM_SHIFT) & HSP_nINT_MASK;\n\thsp->num_ss = (value >> HSP_nSS_SHIFT) & HSP_nINT_MASK;\n\thsp->num_as = (value >> HSP_nAS_SHIFT) & HSP_nINT_MASK;\n\thsp->num_db = (value >> HSP_nDB_SHIFT) & HSP_nINT_MASK;\n\thsp->num_si = (value >> HSP_nSI_SHIFT) & HSP_nINT_MASK;\n\n\terr = platform_get_irq_byname_optional(pdev, \"doorbell\");\n\tif (err >= 0)\n\t\thsp->doorbell_irq = err;\n\n\tif (hsp->num_si > 0) {\n\t\tunsigned int count = 0;\n\n\t\thsp->shared_irqs = devm_kcalloc(&pdev->dev, hsp->num_si,\n\t\t\t\t\t\tsizeof(*hsp->shared_irqs),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hsp->shared_irqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < hsp->num_si; i++) {\n\t\t\tchar *name;\n\n\t\t\tname = kasprintf(GFP_KERNEL, \"shared%u\", i);\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\terr = platform_get_irq_byname_optional(pdev, name);\n\t\t\tif (err >= 0) {\n\t\t\t\thsp->shared_irqs[i] = err;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tkfree(name);\n\t\t}\n\n\t\tif (count == 0) {\n\t\t\tdevm_kfree(&pdev->dev, hsp->shared_irqs);\n\t\t\thsp->shared_irqs = NULL;\n\t\t}\n\t}\n\n\t \n\thsp->mbox_db.of_xlate = tegra_hsp_db_xlate;\n\thsp->mbox_db.num_chans = 32;\n\thsp->mbox_db.dev = &pdev->dev;\n\thsp->mbox_db.ops = &tegra_hsp_db_ops;\n\n\thsp->mbox_db.chans = devm_kcalloc(&pdev->dev, hsp->mbox_db.num_chans,\n\t\t\t\t\t  sizeof(*hsp->mbox_db.chans),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!hsp->mbox_db.chans)\n\t\treturn -ENOMEM;\n\n\tif (hsp->doorbell_irq) {\n\t\terr = tegra_hsp_add_doorbells(hsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to add doorbells: %d\\n\",\n\t\t\t        err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = devm_mbox_controller_register(&pdev->dev, &hsp->mbox_db);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register doorbell mailbox: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\thsp->mbox_sm.of_xlate = tegra_hsp_sm_xlate;\n\thsp->mbox_sm.num_chans = hsp->num_sm;\n\thsp->mbox_sm.dev = &pdev->dev;\n\thsp->mbox_sm.ops = &tegra_hsp_sm_ops;\n\n\thsp->mbox_sm.chans = devm_kcalloc(&pdev->dev, hsp->mbox_sm.num_chans,\n\t\t\t\t\t  sizeof(*hsp->mbox_sm.chans),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!hsp->mbox_sm.chans)\n\t\treturn -ENOMEM;\n\n\tif (hsp->shared_irqs) {\n\t\terr = tegra_hsp_add_mailboxes(hsp, &pdev->dev);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to add mailboxes: %d\\n\",\n\t\t\t        err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = devm_mbox_controller_register(&pdev->dev, &hsp->mbox_sm);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register shared mailbox: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, hsp);\n\n\tif (hsp->doorbell_irq) {\n\t\terr = devm_request_irq(&pdev->dev, hsp->doorbell_irq,\n\t\t\t\t       tegra_hsp_doorbell_irq, IRQF_NO_SUSPEND,\n\t\t\t\t       dev_name(&pdev->dev), hsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t        \"failed to request doorbell IRQ#%u: %d\\n\",\n\t\t\t\thsp->doorbell_irq, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (hsp->shared_irqs) {\n\t\terr = tegra_hsp_request_shared_irq(hsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tlockdep_register_key(&hsp->lock_key);\n\tlockdep_set_class(&hsp->lock, &hsp->lock_key);\n\n\treturn 0;\n}\n\nstatic int tegra_hsp_remove(struct platform_device *pdev)\n{\n\tstruct tegra_hsp *hsp = platform_get_drvdata(pdev);\n\n\tlockdep_unregister_key(&hsp->lock_key);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_hsp_resume(struct device *dev)\n{\n\tstruct tegra_hsp *hsp = dev_get_drvdata(dev);\n\tunsigned int i;\n\tstruct tegra_hsp_doorbell *db;\n\n\tlist_for_each_entry(db, &hsp->doorbells, list) {\n\t\tif (db->channel.chan)\n\t\t\ttegra_hsp_doorbell_startup(db->channel.chan);\n\t}\n\n\tif (hsp->mailboxes) {\n\t\tfor (i = 0; i < hsp->num_sm; i++) {\n\t\t\tstruct tegra_hsp_mailbox *mb = &hsp->mailboxes[i];\n\n\t\t\tif (mb->channel.chan->cl)\n\t\t\t\ttegra_hsp_mailbox_startup(mb->channel.chan);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_hsp_pm_ops = {\n\t.resume_noirq = tegra_hsp_resume,\n};\n\nstatic const struct tegra_hsp_db_map tegra186_hsp_db_map[] = {\n\t{ \"ccplex\", TEGRA_HSP_DB_MASTER_CCPLEX, HSP_DB_CCPLEX, },\n\t{ \"bpmp\",   TEGRA_HSP_DB_MASTER_BPMP,   HSP_DB_BPMP,   },\n\t{   }\n};\n\nstatic const struct tegra_hsp_soc tegra186_hsp_soc = {\n\t.map = tegra186_hsp_db_map,\n\t.has_per_mb_ie = false,\n\t.has_128_bit_mb = false,\n\t.reg_stride = 0x100,\n};\n\nstatic const struct tegra_hsp_soc tegra194_hsp_soc = {\n\t.map = tegra186_hsp_db_map,\n\t.has_per_mb_ie = true,\n\t.has_128_bit_mb = false,\n\t.reg_stride = 0x100,\n};\n\nstatic const struct tegra_hsp_soc tegra234_hsp_soc = {\n\t.map = tegra186_hsp_db_map,\n\t.has_per_mb_ie = false,\n\t.has_128_bit_mb = true,\n\t.reg_stride = 0x100,\n};\n\nstatic const struct tegra_hsp_soc tegra264_hsp_soc = {\n\t.map = tegra186_hsp_db_map,\n\t.has_per_mb_ie = false,\n\t.has_128_bit_mb = true,\n\t.reg_stride = 0x1000,\n};\n\nstatic const struct of_device_id tegra_hsp_match[] = {\n\t{ .compatible = \"nvidia,tegra186-hsp\", .data = &tegra186_hsp_soc },\n\t{ .compatible = \"nvidia,tegra194-hsp\", .data = &tegra194_hsp_soc },\n\t{ .compatible = \"nvidia,tegra234-hsp\", .data = &tegra234_hsp_soc },\n\t{ .compatible = \"nvidia,tegra264-hsp\", .data = &tegra264_hsp_soc },\n\t{ }\n};\n\nstatic struct platform_driver tegra_hsp_driver = {\n\t.driver = {\n\t\t.name = \"tegra-hsp\",\n\t\t.of_match_table = tegra_hsp_match,\n\t\t.pm = &tegra_hsp_pm_ops,\n\t},\n\t.probe = tegra_hsp_probe,\n\t.remove = tegra_hsp_remove,\n};\n\nstatic int __init tegra_hsp_init(void)\n{\n\treturn platform_driver_register(&tegra_hsp_driver);\n}\ncore_initcall(tegra_hsp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}