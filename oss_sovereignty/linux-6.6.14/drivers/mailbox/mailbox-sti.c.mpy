{
  "module_name": "mailbox-sti.c",
  "hash_id": "bcbe4b19d501b12c4b3c5a570a43038e52344bb937045c9700d89d0f51df1c61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mailbox-sti.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"mailbox.h\"\n\n#define STI_MBOX_INST_MAX\t4       \n#define STI_MBOX_CHAN_MAX\t20      \n\n#define STI_IRQ_VAL_OFFSET\t0x04    \n#define STI_IRQ_SET_OFFSET\t0x24    \n#define STI_IRQ_CLR_OFFSET\t0x44    \n#define STI_ENA_VAL_OFFSET\t0x64    \n#define STI_ENA_SET_OFFSET\t0x84    \n#define STI_ENA_CLR_OFFSET\t0xa4    \n\n#define MBOX_BASE(mdev, inst)   ((mdev)->base + ((inst) * 4))\n\n \nstruct sti_mbox_device {\n\tstruct device\t\t*dev;\n\tstruct mbox_controller\t*mbox;\n\tvoid __iomem\t\t*base;\n\tconst char\t\t*name;\n\tu32\t\t\tenabled[STI_MBOX_INST_MAX];\n\tspinlock_t\t\tlock;\n};\n\n \nstruct sti_mbox_pdata {\n\tunsigned int\t\tnum_inst;\n\tunsigned int\t\tnum_chan;\n};\n\n \nstruct sti_channel {\n\tstruct sti_mbox_device\t*mdev;\n\tunsigned int\t\tinstance;\n\tunsigned int\t\tchannel;\n};\n\nstatic inline bool sti_mbox_channel_is_enabled(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\n\treturn mdev->enabled[instance] & BIT(channel);\n}\n\nstatic inline\nstruct mbox_chan *sti_mbox_to_channel(struct mbox_controller *mbox,\n\t\t\t\t      unsigned int instance,\n\t\t\t\t      unsigned int channel)\n{\n\tstruct sti_channel *chan_info;\n\tint i;\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tchan_info = mbox->chans[i].con_priv;\n\t\tif (chan_info &&\n\t\t    chan_info->instance == instance &&\n\t\t    chan_info->channel == channel)\n\t\t\treturn &mbox->chans[i];\n\t}\n\n\tdev_err(mbox->dev,\n\t\t\"Channel not registered: instance: %d channel: %d\\n\",\n\t\tinstance, channel);\n\n\treturn NULL;\n}\n\nstatic void sti_mbox_enable_channel(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\tunsigned long flags;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\tspin_lock_irqsave(&mdev->lock, flags);\n\tmdev->enabled[instance] |= BIT(channel);\n\twritel_relaxed(BIT(channel), base + STI_ENA_SET_OFFSET);\n\tspin_unlock_irqrestore(&mdev->lock, flags);\n}\n\nstatic void sti_mbox_disable_channel(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\tunsigned long flags;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\tspin_lock_irqsave(&mdev->lock, flags);\n\tmdev->enabled[instance] &= ~BIT(channel);\n\twritel_relaxed(BIT(channel), base + STI_ENA_CLR_OFFSET);\n\tspin_unlock_irqrestore(&mdev->lock, flags);\n}\n\nstatic void sti_mbox_clear_irq(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\twritel_relaxed(BIT(channel), base + STI_IRQ_CLR_OFFSET);\n}\n\nstatic struct mbox_chan *sti_mbox_irq_to_channel(struct sti_mbox_device *mdev,\n\t\t\t\t\t\t unsigned int instance)\n{\n\tstruct mbox_controller *mbox = mdev->mbox;\n\tstruct mbox_chan *chan = NULL;\n\tunsigned int channel;\n\tunsigned long bits;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\tbits = readl_relaxed(base + STI_IRQ_VAL_OFFSET);\n\tif (!bits)\n\t\t \n\t\treturn NULL;\n\n\t \n\tfor (channel = 0; bits; channel++) {\n\t\tif (!test_and_clear_bit(channel, &bits))\n\t\t\tcontinue;\n\n\t\tchan = sti_mbox_to_channel(mbox, instance, channel);\n\t\tif (chan) {\n\t\t\tdev_dbg(mbox->dev,\n\t\t\t\t\"IRQ fired on instance: %d channel: %d\\n\",\n\t\t\t\tinstance, channel);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn chan;\n}\n\nstatic irqreturn_t sti_mbox_thread_handler(int irq, void *data)\n{\n\tstruct sti_mbox_device *mdev = data;\n\tstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\n\tstruct mbox_chan *chan;\n\tunsigned int instance;\n\n\tfor (instance = 0; instance < pdata->num_inst; instance++) {\nkeep_looking:\n\t\tchan = sti_mbox_irq_to_channel(mdev, instance);\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\tmbox_chan_received_data(chan, NULL);\n\t\tsti_mbox_clear_irq(chan);\n\t\tsti_mbox_enable_channel(chan);\n\t\tgoto keep_looking;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sti_mbox_irq_handler(int irq, void *data)\n{\n\tstruct sti_mbox_device *mdev = data;\n\tstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\n\tstruct sti_channel *chan_info;\n\tstruct mbox_chan *chan;\n\tunsigned int instance;\n\tint ret = IRQ_NONE;\n\n\tfor (instance = 0; instance < pdata->num_inst; instance++) {\n\t\tchan = sti_mbox_irq_to_channel(mdev, instance);\n\t\tif (!chan)\n\t\t\tcontinue;\n\t\tchan_info = chan->con_priv;\n\n\t\tif (!sti_mbox_channel_is_enabled(chan)) {\n\t\t\tdev_warn(mdev->dev,\n\t\t\t\t \"Unexpected IRQ: %s\\n\"\n\t\t\t\t \"  instance: %d: channel: %d [enabled: %x]\\n\",\n\t\t\t\t mdev->name, chan_info->instance,\n\t\t\t\t chan_info->channel, mdev->enabled[instance]);\n\n\t\t\t \n\t\t\tif (ret == IRQ_NONE)\n\t\t\t\tret = IRQ_HANDLED;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsti_mbox_disable_channel(chan);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (ret == IRQ_NONE)\n\t\tdev_err(mdev->dev, \"Spurious IRQ - was a channel requested?\\n\");\n\n\treturn ret;\n}\n\nstatic bool sti_mbox_tx_is_ready(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\tif (!(readl_relaxed(base + STI_ENA_VAL_OFFSET) & BIT(channel))) {\n\t\tdev_dbg(mdev->dev, \"Mbox: %s: inst: %d, chan: %d disabled\\n\",\n\t\t\tmdev->name, instance, channel);\n\t\treturn false;\n\t}\n\n\tif (readl_relaxed(base + STI_IRQ_VAL_OFFSET) & BIT(channel)) {\n\t\tdev_dbg(mdev->dev, \"Mbox: %s: inst: %d, chan: %d not ready\\n\",\n\t\t\tmdev->name, instance, channel);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int sti_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct sti_mbox_device *mdev = chan_info->mdev;\n\tunsigned int instance = chan_info->instance;\n\tunsigned int channel = chan_info->channel;\n\tvoid __iomem *base = MBOX_BASE(mdev, instance);\n\n\t \n\twritel_relaxed(BIT(channel), base + STI_IRQ_SET_OFFSET);\n\n\tdev_dbg(mdev->dev,\n\t\t\"Sent via Mailbox %s: instance: %d channel: %d\\n\",\n\t\tmdev->name, instance, channel);\n\n\treturn 0;\n}\n\nstatic int sti_mbox_startup_chan(struct mbox_chan *chan)\n{\n\tsti_mbox_clear_irq(chan);\n\tsti_mbox_enable_channel(chan);\n\n\treturn 0;\n}\n\nstatic void sti_mbox_shutdown_chan(struct mbox_chan *chan)\n{\n\tstruct sti_channel *chan_info = chan->con_priv;\n\tstruct mbox_controller *mbox = chan_info->mdev->mbox;\n\tint i;\n\n\tfor (i = 0; i < mbox->num_chans; i++)\n\t\tif (chan == &mbox->chans[i])\n\t\t\tbreak;\n\n\tif (mbox->num_chans == i) {\n\t\tdev_warn(mbox->dev, \"Request to free non-existent channel\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsti_mbox_disable_channel(chan);\n\tsti_mbox_clear_irq(chan);\n\tchan->con_priv = NULL;\n}\n\nstatic struct mbox_chan *sti_mbox_xlate(struct mbox_controller *mbox,\n\t\t\t\t\tconst struct of_phandle_args *spec)\n{\n\tstruct sti_mbox_device *mdev = dev_get_drvdata(mbox->dev);\n\tstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\n\tstruct sti_channel *chan_info;\n\tstruct mbox_chan *chan = NULL;\n\tunsigned int instance  = spec->args[0];\n\tunsigned int channel   = spec->args[1];\n\tint i;\n\n\t \n\tif (instance >= pdata->num_inst || channel  >= pdata->num_chan) {\n\t\tdev_err(mbox->dev,\n\t\t\t\"Invalid channel requested instance: %d channel: %d\\n\",\n\t\t\tinstance, channel);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tchan_info = mbox->chans[i].con_priv;\n\n\t\t \n\t\tif (chan_info &&\n\t\t    mbox->dev == chan_info->mdev->dev &&\n\t\t    instance == chan_info->instance &&\n\t\t    channel == chan_info->channel) {\n\n\t\t\tdev_err(mbox->dev, \"Channel in use\\n\");\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\n\t\t \n\t\tif (!chan && !chan_info)\n\t\t\tchan = &mbox->chans[i];\n\t}\n\n\tif (!chan) {\n\t\tdev_err(mbox->dev, \"No free channels left\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tchan_info = devm_kzalloc(mbox->dev, sizeof(*chan_info), GFP_KERNEL);\n\tif (!chan_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchan_info->mdev\t\t= mdev;\n\tchan_info->instance\t= instance;\n\tchan_info->channel\t= channel;\n\n\tchan->con_priv = chan_info;\n\n\tdev_info(mbox->dev,\n\t\t \"Mbox: %s: Created channel: instance: %d channel: %d\\n\",\n\t\t mdev->name, instance, channel);\n\n\treturn chan;\n}\n\nstatic const struct mbox_chan_ops sti_mbox_ops = {\n\t.startup\t= sti_mbox_startup_chan,\n\t.shutdown\t= sti_mbox_shutdown_chan,\n\t.send_data\t= sti_mbox_send_data,\n\t.last_tx_done\t= sti_mbox_tx_is_ready,\n};\n\nstatic const struct sti_mbox_pdata mbox_stih407_pdata = {\n\t.num_inst\t= 4,\n\t.num_chan\t= 32,\n};\n\nstatic const struct of_device_id sti_mailbox_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-mailbox\",\n\t\t.data = (void *)&mbox_stih407_pdata\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sti_mailbox_match);\n\nstatic int sti_mbox_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct mbox_controller *mbox;\n\tstruct sti_mbox_device *mdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mbox_chan *chans;\n\tint irq;\n\tint ret;\n\n\tmatch = of_match_device(sti_mailbox_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"No configuration found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpdev->dev.platform_data = (struct sti_mbox_pdata *) match->data;\n\n\tmdev = devm_kzalloc(&pdev->dev, sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mdev);\n\n\tmdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->base))\n\t\treturn PTR_ERR(mdev->base);\n\n\tret = of_property_read_string(np, \"mbox-name\", &mdev->name);\n\tif (ret)\n\t\tmdev->name = np->full_name;\n\n\tmbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tchans = devm_kcalloc(&pdev->dev,\n\t\t\t     STI_MBOX_CHAN_MAX, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tmdev->dev\t\t= &pdev->dev;\n\tmdev->mbox\t\t= mbox;\n\n\tspin_lock_init(&mdev->lock);\n\n\t \n\tmbox->txdone_irq\t= false;\n\tmbox->txdone_poll\t= true;\n\tmbox->txpoll_period\t= 100;\n\tmbox->ops\t\t= &sti_mbox_ops;\n\tmbox->dev\t\t= mdev->dev;\n\tmbox->of_xlate\t\t= sti_mbox_xlate;\n\tmbox->chans\t\t= chans;\n\tmbox->num_chans\t\t= STI_MBOX_CHAN_MAX;\n\n\tret = devm_mbox_controller_register(&pdev->dev, mbox);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"%s: Registered Tx only Mailbox\\n\", mdev->name);\n\t\treturn 0;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tsti_mbox_irq_handler,\n\t\t\t\t\tsti_mbox_thread_handler,\n\t\t\t\t\tIRQF_ONESHOT, mdev->name, mdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't claim IRQ %d\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&pdev->dev, \"%s: Registered Tx/Rx Mailbox\\n\", mdev->name);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sti_mbox_driver = {\n\t.probe = sti_mbox_probe,\n\t.driver = {\n\t\t.name = \"sti-mailbox\",\n\t\t.of_match_table = sti_mailbox_match,\n\t},\n};\nmodule_platform_driver(sti_mbox_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"STMicroelectronics Mailbox Controller\");\nMODULE_AUTHOR(\"Lee Jones <lee.jones@linaro.org\");\nMODULE_ALIAS(\"platform:mailbox-sti\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}