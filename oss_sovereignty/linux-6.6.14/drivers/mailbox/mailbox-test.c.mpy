{
  "module_name": "mailbox-test.c",
  "hash_id": "f5ca66e82d3e56014f8e7890a7c37e8b9a3130aac0a4bfbaac505069ba62ccaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mailbox-test.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n\n#define MBOX_MAX_SIG_LEN\t8\n#define MBOX_MAX_MSG_LEN\t128\n#define MBOX_BYTES_PER_LINE\t16\n#define MBOX_HEXDUMP_LINE_LEN\t((MBOX_BYTES_PER_LINE * 4) + 2)\n#define MBOX_HEXDUMP_MAX_LEN\t(MBOX_HEXDUMP_LINE_LEN *\t\t\\\n\t\t\t\t (MBOX_MAX_MSG_LEN / MBOX_BYTES_PER_LINE))\n\nstatic bool mbox_data_ready;\n\nstruct mbox_test_device {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*tx_mmio;\n\tvoid __iomem\t\t*rx_mmio;\n\tstruct mbox_chan\t*tx_channel;\n\tstruct mbox_chan\t*rx_channel;\n\tchar\t\t\t*rx_buffer;\n\tchar\t\t\t*signal;\n\tchar\t\t\t*message;\n\tspinlock_t\t\tlock;\n\tstruct mutex\t\tmutex;\n\twait_queue_head_t\twaitq;\n\tstruct fasync_struct\t*async_queue;\n\tstruct dentry\t\t*root_debugfs_dir;\n};\n\nstatic ssize_t mbox_test_signal_write(struct file *filp,\n\t\t\t\t       const char __user *userbuf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct mbox_test_device *tdev = filp->private_data;\n\n\tif (!tdev->tx_channel) {\n\t\tdev_err(tdev->dev, \"Channel cannot do Tx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count > MBOX_MAX_SIG_LEN) {\n\t\tdev_err(tdev->dev,\n\t\t\t\"Signal length %zd greater than max allowed %d\\n\",\n\t\t\tcount, MBOX_MAX_SIG_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!tdev->signal) {\n\t\ttdev->signal = kzalloc(MBOX_MAX_SIG_LEN, GFP_KERNEL);\n\t\tif (!tdev->signal)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(tdev->signal, userbuf, count)) {\n\t\tkfree(tdev->signal);\n\t\ttdev->signal = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations mbox_test_signal_ops = {\n\t.write\t= mbox_test_signal_write,\n\t.open\t= simple_open,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic int mbox_test_message_fasync(int fd, struct file *filp, int on)\n{\n\tstruct mbox_test_device *tdev = filp->private_data;\n\n\treturn fasync_helper(fd, filp, on, &tdev->async_queue);\n}\n\nstatic ssize_t mbox_test_message_write(struct file *filp,\n\t\t\t\t       const char __user *userbuf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct mbox_test_device *tdev = filp->private_data;\n\tchar *message;\n\tvoid *data;\n\tint ret;\n\n\tif (!tdev->tx_channel) {\n\t\tdev_err(tdev->dev, \"Channel cannot do Tx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count > MBOX_MAX_MSG_LEN) {\n\t\tdev_err(tdev->dev,\n\t\t\t\"Message length %zd greater than max allowed %d\\n\",\n\t\t\tcount, MBOX_MAX_MSG_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmessage = kzalloc(MBOX_MAX_MSG_LEN, GFP_KERNEL);\n\tif (!message)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&tdev->mutex);\n\n\ttdev->message = message;\n\tret = copy_from_user(tdev->message, userbuf, count);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tdev->tx_mmio && tdev->signal) {\n\t\tprint_hex_dump_bytes(\"Client: Sending: Signal: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t     tdev->signal, MBOX_MAX_SIG_LEN);\n\n\t\tdata = tdev->signal;\n\t} else\n\t\tdata = tdev->message;\n\n\tprint_hex_dump_bytes(\"Client: Sending: Message: \", DUMP_PREFIX_ADDRESS,\n\t\t\t     tdev->message, MBOX_MAX_MSG_LEN);\n\n\tret = mbox_send_message(tdev->tx_channel, data);\n\tif (ret < 0)\n\t\tdev_err(tdev->dev, \"Failed to send message via mailbox\\n\");\n\nout:\n\tkfree(tdev->signal);\n\tkfree(tdev->message);\n\ttdev->signal = NULL;\n\n\tmutex_unlock(&tdev->mutex);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic bool mbox_test_message_data_ready(struct mbox_test_device *tdev)\n{\n\tbool data_ready;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tdev->lock, flags);\n\tdata_ready = mbox_data_ready;\n\tspin_unlock_irqrestore(&tdev->lock, flags);\n\n\treturn data_ready;\n}\n\nstatic ssize_t mbox_test_message_read(struct file *filp, char __user *userbuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct mbox_test_device *tdev = filp->private_data;\n\tunsigned long flags;\n\tchar *touser, *ptr;\n\tint l = 0;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(wait, current);\n\n\ttouser = kzalloc(MBOX_HEXDUMP_MAX_LEN + 1, GFP_KERNEL);\n\tif (!touser)\n\t\treturn -ENOMEM;\n\n\tif (!tdev->rx_channel) {\n\t\tret = snprintf(touser, 20, \"<NO RX CAPABILITY>\\n\");\n\t\tret = simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t\t      touser, ret);\n\t\tgoto kfree_err;\n\t}\n\n\tadd_wait_queue(&tdev->waitq, &wait);\n\n\tdo {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (mbox_test_message_data_ready(tdev))\n\t\t\tbreak;\n\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto waitq_err;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto waitq_err;\n\t\t}\n\t\tschedule();\n\n\t} while (1);\n\n\tspin_lock_irqsave(&tdev->lock, flags);\n\n\tptr = tdev->rx_buffer;\n\twhile (l < MBOX_HEXDUMP_MAX_LEN) {\n\t\thex_dump_to_buffer(ptr,\n\t\t\t\t   MBOX_BYTES_PER_LINE,\n\t\t\t\t   MBOX_BYTES_PER_LINE, 1, touser + l,\n\t\t\t\t   MBOX_HEXDUMP_LINE_LEN, true);\n\n\t\tptr += MBOX_BYTES_PER_LINE;\n\t\tl += MBOX_HEXDUMP_LINE_LEN;\n\t\t*(touser + (l - 1)) = '\\n';\n\t}\n\t*(touser + l) = '\\0';\n\n\tmemset(tdev->rx_buffer, 0, MBOX_MAX_MSG_LEN);\n\tmbox_data_ready = false;\n\n\tspin_unlock_irqrestore(&tdev->lock, flags);\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, touser, MBOX_HEXDUMP_MAX_LEN);\nwaitq_err:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tdev->waitq, &wait);\nkfree_err:\n\tkfree(touser);\n\treturn ret;\n}\n\nstatic __poll_t\nmbox_test_message_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct mbox_test_device *tdev = filp->private_data;\n\n\tpoll_wait(filp, &tdev->waitq, wait);\n\n\tif (mbox_test_message_data_ready(tdev))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic const struct file_operations mbox_test_message_ops = {\n\t.write\t= mbox_test_message_write,\n\t.read\t= mbox_test_message_read,\n\t.fasync\t= mbox_test_message_fasync,\n\t.poll\t= mbox_test_message_poll,\n\t.open\t= simple_open,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic int mbox_test_add_debugfs(struct platform_device *pdev,\n\t\t\t\t struct mbox_test_device *tdev)\n{\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\n\ttdev->root_debugfs_dir = debugfs_create_dir(dev_name(&pdev->dev), NULL);\n\tif (!tdev->root_debugfs_dir) {\n\t\tdev_err(&pdev->dev, \"Failed to create Mailbox debugfs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebugfs_create_file(\"message\", 0600, tdev->root_debugfs_dir,\n\t\t\t    tdev, &mbox_test_message_ops);\n\n\tdebugfs_create_file(\"signal\", 0200, tdev->root_debugfs_dir,\n\t\t\t    tdev, &mbox_test_signal_ops);\n\n\treturn 0;\n}\n\nstatic void mbox_test_receive_message(struct mbox_client *client, void *message)\n{\n\tstruct mbox_test_device *tdev = dev_get_drvdata(client->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tdev->lock, flags);\n\tif (tdev->rx_mmio) {\n\t\tmemcpy_fromio(tdev->rx_buffer, tdev->rx_mmio, MBOX_MAX_MSG_LEN);\n\t\tprint_hex_dump_bytes(\"Client: Received [MMIO]: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t     tdev->rx_buffer, MBOX_MAX_MSG_LEN);\n\t} else if (message) {\n\t\tprint_hex_dump_bytes(\"Client: Received [API]: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t     message, MBOX_MAX_MSG_LEN);\n\t\tmemcpy(tdev->rx_buffer, message, MBOX_MAX_MSG_LEN);\n\t}\n\tmbox_data_ready = true;\n\tspin_unlock_irqrestore(&tdev->lock, flags);\n\n\twake_up_interruptible(&tdev->waitq);\n\n\tkill_fasync(&tdev->async_queue, SIGIO, POLL_IN);\n}\n\nstatic void mbox_test_prepare_message(struct mbox_client *client, void *message)\n{\n\tstruct mbox_test_device *tdev = dev_get_drvdata(client->dev);\n\n\tif (tdev->tx_mmio) {\n\t\tif (tdev->signal)\n\t\t\tmemcpy_toio(tdev->tx_mmio, tdev->message, MBOX_MAX_MSG_LEN);\n\t\telse\n\t\t\tmemcpy_toio(tdev->tx_mmio, message, MBOX_MAX_MSG_LEN);\n\t}\n}\n\nstatic void mbox_test_message_sent(struct mbox_client *client,\n\t\t\t\t   void *message, int r)\n{\n\tif (r)\n\t\tdev_warn(client->dev,\n\t\t\t \"Client: Message could not be sent: %d\\n\", r);\n\telse\n\t\tdev_info(client->dev,\n\t\t\t \"Client: Message sent\\n\");\n}\n\nstatic struct mbox_chan *\nmbox_test_request_channel(struct platform_device *pdev, const char *name)\n{\n\tstruct mbox_client *client;\n\tstruct mbox_chan *channel;\n\n\tclient = devm_kzalloc(&pdev->dev, sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient->dev\t\t= &pdev->dev;\n\tclient->rx_callback\t= mbox_test_receive_message;\n\tclient->tx_prepare\t= mbox_test_prepare_message;\n\tclient->tx_done\t\t= mbox_test_message_sent;\n\tclient->tx_block\t= true;\n\tclient->knows_txdone\t= false;\n\tclient->tx_tout\t\t= 500;\n\n\tchannel = mbox_request_channel_byname(client, name);\n\tif (IS_ERR(channel)) {\n\t\tdev_warn(&pdev->dev, \"Failed to request %s channel\\n\", name);\n\t\treturn NULL;\n\t}\n\n\treturn channel;\n}\n\nstatic int mbox_test_probe(struct platform_device *pdev)\n{\n\tstruct mbox_test_device *tdev;\n\tstruct resource *res;\n\tresource_size_t size;\n\tint ret;\n\n\ttdev = devm_kzalloc(&pdev->dev, sizeof(*tdev), GFP_KERNEL);\n\tif (!tdev)\n\t\treturn -ENOMEM;\n\n\t \n\ttdev->tx_mmio = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (PTR_ERR(tdev->tx_mmio) == -EBUSY) {\n\t\t \n\t\tsize = resource_size(res);\n\t\ttdev->tx_mmio = devm_ioremap(&pdev->dev, res->start, size);\n\t} else if (IS_ERR(tdev->tx_mmio)) {\n\t\ttdev->tx_mmio = NULL;\n\t}\n\n\t \n\ttdev->rx_mmio = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\tif (PTR_ERR(tdev->rx_mmio) == -EBUSY) {\n\t\tsize = resource_size(res);\n\t\ttdev->rx_mmio = devm_ioremap(&pdev->dev, res->start, size);\n\t} else if (IS_ERR(tdev->rx_mmio)) {\n\t\ttdev->rx_mmio = tdev->tx_mmio;\n\t}\n\n\ttdev->tx_channel = mbox_test_request_channel(pdev, \"tx\");\n\ttdev->rx_channel = mbox_test_request_channel(pdev, \"rx\");\n\n\tif (IS_ERR_OR_NULL(tdev->tx_channel) && IS_ERR_OR_NULL(tdev->rx_channel))\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tif (!tdev->rx_channel && (tdev->rx_mmio != tdev->tx_mmio))\n\t\ttdev->rx_channel = tdev->tx_channel;\n\n\ttdev->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, tdev);\n\n\tspin_lock_init(&tdev->lock);\n\tmutex_init(&tdev->mutex);\n\n\tif (tdev->rx_channel) {\n\t\ttdev->rx_buffer = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t       MBOX_MAX_MSG_LEN, GFP_KERNEL);\n\t\tif (!tdev->rx_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = mbox_test_add_debugfs(pdev, tdev);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&tdev->waitq);\n\tdev_info(&pdev->dev, \"Successfully registered\\n\");\n\n\treturn 0;\n}\n\nstatic int mbox_test_remove(struct platform_device *pdev)\n{\n\tstruct mbox_test_device *tdev = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(tdev->root_debugfs_dir);\n\n\tif (tdev->tx_channel)\n\t\tmbox_free_channel(tdev->tx_channel);\n\tif (tdev->rx_channel)\n\t\tmbox_free_channel(tdev->rx_channel);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mbox_test_match[] = {\n\t{ .compatible = \"mailbox-test\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mbox_test_match);\n\nstatic struct platform_driver mbox_test_driver = {\n\t.driver = {\n\t\t.name = \"mailbox_test\",\n\t\t.of_match_table = mbox_test_match,\n\t},\n\t.probe  = mbox_test_probe,\n\t.remove = mbox_test_remove,\n};\nmodule_platform_driver(mbox_test_driver);\n\nMODULE_DESCRIPTION(\"Generic Mailbox Testing Facility\");\nMODULE_AUTHOR(\"Lee Jones <lee.jones@linaro.org\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}