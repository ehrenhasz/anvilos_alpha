{
  "module_name": "pl320-ipc.c",
  "hash_id": "3a14971bbed7d104663040e2e232d1ed8aabeeada573141108876631c83a0812",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/pl320-ipc.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/amba/bus.h>\n\n#include <linux/pl320-ipc.h>\n\n#define IPCMxSOURCE(m)\t\t((m) * 0x40)\n#define IPCMxDSET(m)\t\t(((m) * 0x40) + 0x004)\n#define IPCMxDCLEAR(m)\t\t(((m) * 0x40) + 0x008)\n#define IPCMxDSTATUS(m)\t\t(((m) * 0x40) + 0x00C)\n#define IPCMxMODE(m)\t\t(((m) * 0x40) + 0x010)\n#define IPCMxMSET(m)\t\t(((m) * 0x40) + 0x014)\n#define IPCMxMCLEAR(m)\t\t(((m) * 0x40) + 0x018)\n#define IPCMxMSTATUS(m)\t\t(((m) * 0x40) + 0x01C)\n#define IPCMxSEND(m)\t\t(((m) * 0x40) + 0x020)\n#define IPCMxDR(m, dr)\t\t(((m) * 0x40) + ((dr) * 4) + 0x024)\n\n#define IPCMMIS(irq)\t\t(((irq) * 8) + 0x800)\n#define IPCMRIS(irq)\t\t(((irq) * 8) + 0x804)\n\n#define MBOX_MASK(n)\t\t(1 << (n))\n#define IPC_TX_MBOX\t\t1\n#define IPC_RX_MBOX\t\t2\n\n#define CHAN_MASK(n)\t\t(1 << (n))\n#define A9_SOURCE\t\t1\n#define M3_SOURCE\t\t0\n\nstatic void __iomem *ipc_base;\nstatic int ipc_irq;\nstatic DEFINE_MUTEX(ipc_m1_lock);\nstatic DECLARE_COMPLETION(ipc_completion);\nstatic ATOMIC_NOTIFIER_HEAD(ipc_notifier);\n\nstatic inline void set_destination(int source, int mbox)\n{\n\twritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxDSET(mbox));\n\twritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxMSET(mbox));\n}\n\nstatic inline void clear_destination(int source, int mbox)\n{\n\twritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxDCLEAR(mbox));\n\twritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxMCLEAR(mbox));\n}\n\nstatic void __ipc_send(int mbox, u32 *data)\n{\n\tint i;\n\tfor (i = 0; i < 7; i++)\n\t\twritel_relaxed(data[i], ipc_base + IPCMxDR(mbox, i));\n\twritel_relaxed(0x1, ipc_base + IPCMxSEND(mbox));\n}\n\nstatic u32 __ipc_rcv(int mbox, u32 *data)\n{\n\tint i;\n\tfor (i = 0; i < 7; i++)\n\t\tdata[i] = readl_relaxed(ipc_base + IPCMxDR(mbox, i));\n\treturn data[1];\n}\n\n \nint pl320_ipc_transmit(u32 *data)\n{\n\tint ret;\n\n\tmutex_lock(&ipc_m1_lock);\n\n\tinit_completion(&ipc_completion);\n\t__ipc_send(IPC_TX_MBOX, data);\n\tret = wait_for_completion_timeout(&ipc_completion,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tret = __ipc_rcv(IPC_TX_MBOX, data);\nout:\n\tmutex_unlock(&ipc_m1_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pl320_ipc_transmit);\n\nstatic irqreturn_t ipc_handler(int irq, void *dev)\n{\n\tu32 irq_stat;\n\tu32 data[7];\n\n\tirq_stat = readl_relaxed(ipc_base + IPCMMIS(1));\n\tif (irq_stat & MBOX_MASK(IPC_TX_MBOX)) {\n\t\twritel_relaxed(0, ipc_base + IPCMxSEND(IPC_TX_MBOX));\n\t\tcomplete(&ipc_completion);\n\t}\n\tif (irq_stat & MBOX_MASK(IPC_RX_MBOX)) {\n\t\t__ipc_rcv(IPC_RX_MBOX, data);\n\t\tatomic_notifier_call_chain(&ipc_notifier, data[0], data + 1);\n\t\twritel_relaxed(2, ipc_base + IPCMxSEND(IPC_RX_MBOX));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint pl320_ipc_register_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&ipc_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(pl320_ipc_register_notifier);\n\nint pl320_ipc_unregister_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&ipc_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(pl320_ipc_unregister_notifier);\n\nstatic int pl320_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\n\tipc_base = ioremap(adev->res.start, resource_size(&adev->res));\n\tif (ipc_base == NULL)\n\t\treturn -ENOMEM;\n\n\twritel_relaxed(0, ipc_base + IPCMxSEND(IPC_TX_MBOX));\n\n\tipc_irq = adev->irq[0];\n\tret = request_irq(ipc_irq, ipc_handler, 0, dev_name(&adev->dev), NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\twritel_relaxed(CHAN_MASK(A9_SOURCE),\n\t\t       ipc_base + IPCMxSOURCE(IPC_TX_MBOX));\n\twritel_relaxed(CHAN_MASK(M3_SOURCE),\n\t\t       ipc_base + IPCMxDSET(IPC_TX_MBOX));\n\twritel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),\n\t\t       ipc_base + IPCMxMSET(IPC_TX_MBOX));\n\n\t \n\twritel_relaxed(CHAN_MASK(M3_SOURCE),\n\t\t       ipc_base + IPCMxSOURCE(IPC_RX_MBOX));\n\twritel_relaxed(CHAN_MASK(A9_SOURCE),\n\t\t       ipc_base + IPCMxDSET(IPC_RX_MBOX));\n\twritel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),\n\t\t       ipc_base + IPCMxMSET(IPC_RX_MBOX));\n\n\treturn 0;\nerr:\n\tiounmap(ipc_base);\n\treturn ret;\n}\n\nstatic struct amba_id pl320_ids[] = {\n\t{\n\t\t.id\t= 0x00041320,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\n\nstatic struct amba_driver pl320_driver = {\n\t.drv = {\n\t\t.name\t= \"pl320\",\n\t},\n\t.id_table\t= pl320_ids,\n\t.probe\t\t= pl320_probe,\n};\n\nstatic int __init ipc_init(void)\n{\n\treturn amba_driver_register(&pl320_driver);\n}\nsubsys_initcall(ipc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}