{
  "module_name": "stm32-ipcc.c",
  "hash_id": "30241d865c3984f312ea5a5a7f8e2df6c10acc5601af72b35551967d41ae4f91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/stm32-ipcc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n\n#define IPCC_XCR\t\t0x000\n#define XCR_RXOIE\t\tBIT(0)\n#define XCR_TXOIE\t\tBIT(16)\n\n#define IPCC_XMR\t\t0x004\n#define IPCC_XSCR\t\t0x008\n#define IPCC_XTOYSR\t\t0x00c\n\n#define IPCC_PROC_OFFST\t\t0x010\n\n#define IPCC_HWCFGR\t\t0x3f0\n#define IPCFGR_CHAN_MASK\tGENMASK(7, 0)\n\n#define IPCC_VER\t\t0x3f4\n#define VER_MINREV_MASK\t\tGENMASK(3, 0)\n#define VER_MAJREV_MASK\t\tGENMASK(7, 4)\n\n#define RX_BIT_MASK\t\tGENMASK(15, 0)\n#define RX_BIT_CHAN(chan)\tBIT(chan)\n#define TX_BIT_SHIFT\t\t16\n#define TX_BIT_MASK\t\tGENMASK(31, 16)\n#define TX_BIT_CHAN(chan)\tBIT(TX_BIT_SHIFT + (chan))\n\n#define STM32_MAX_PROCS\t\t2\n\nenum {\n\tIPCC_IRQ_RX,\n\tIPCC_IRQ_TX,\n\tIPCC_IRQ_NUM,\n};\n\nstruct stm32_ipcc {\n\tstruct mbox_controller controller;\n\tvoid __iomem *reg_base;\n\tvoid __iomem *reg_proc;\n\tstruct clk *clk;\n\tspinlock_t lock;  \n\tint irqs[IPCC_IRQ_NUM];\n\tu32 proc_id;\n\tu32 n_chans;\n\tu32 xcr;\n\tu32 xmr;\n};\n\nstatic inline void stm32_ipcc_set_bits(spinlock_t *lock, void __iomem *reg,\n\t\t\t\t       u32 mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\twritel_relaxed(readl_relaxed(reg) | mask, reg);\n\tspin_unlock_irqrestore(lock, flags);\n}\n\nstatic inline void stm32_ipcc_clr_bits(spinlock_t *lock, void __iomem *reg,\n\t\t\t\t       u32 mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\twritel_relaxed(readl_relaxed(reg) & ~mask, reg);\n\tspin_unlock_irqrestore(lock, flags);\n}\n\nstatic irqreturn_t stm32_ipcc_rx_irq(int irq, void *data)\n{\n\tstruct stm32_ipcc *ipcc = data;\n\tstruct device *dev = ipcc->controller.dev;\n\tu32 status, mr, tosr, chan;\n\tirqreturn_t ret = IRQ_NONE;\n\tint proc_offset;\n\n\t \n\tproc_offset = ipcc->proc_id ? -IPCC_PROC_OFFST : IPCC_PROC_OFFST;\n\ttosr = readl_relaxed(ipcc->reg_proc + proc_offset + IPCC_XTOYSR);\n\tmr = readl_relaxed(ipcc->reg_proc + IPCC_XMR);\n\n\t \n\tstatus = tosr & FIELD_GET(RX_BIT_MASK, ~mr);\n\n\tfor (chan = 0; chan < ipcc->n_chans; chan++) {\n\t\tif (!(status & (1 << chan)))\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"%s: chan:%d rx\\n\", __func__, chan);\n\n\t\tmbox_chan_received_data(&ipcc->controller.chans[chan], NULL);\n\n\t\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XSCR,\n\t\t\t\t    RX_BIT_CHAN(chan));\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t stm32_ipcc_tx_irq(int irq, void *data)\n{\n\tstruct stm32_ipcc *ipcc = data;\n\tstruct device *dev = ipcc->controller.dev;\n\tu32 status, mr, tosr, chan;\n\tirqreturn_t ret = IRQ_NONE;\n\n\ttosr = readl_relaxed(ipcc->reg_proc + IPCC_XTOYSR);\n\tmr = readl_relaxed(ipcc->reg_proc + IPCC_XMR);\n\n\t \n\tstatus = ~tosr & FIELD_GET(TX_BIT_MASK, ~mr);\n\n\tfor (chan = 0; chan < ipcc->n_chans ; chan++) {\n\t\tif (!(status & (1 << chan)))\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"%s: chan:%d tx\\n\", __func__, chan);\n\n\t\t \n\t\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,\n\t\t\t\t    TX_BIT_CHAN(chan));\n\n\t\tmbox_chan_txdone(&ipcc->controller.chans[chan], 0);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_ipcc_send_data(struct mbox_chan *link, void *data)\n{\n\tunsigned long chan = (unsigned long)link->con_priv;\n\tstruct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,\n\t\t\t\t\t       controller);\n\n\tdev_dbg(ipcc->controller.dev, \"%s: chan:%lu\\n\", __func__, chan);\n\n\t \n\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XSCR,\n\t\t\t    TX_BIT_CHAN(chan));\n\n\t \n\tstm32_ipcc_clr_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,\n\t\t\t    TX_BIT_CHAN(chan));\n\n\treturn 0;\n}\n\nstatic int stm32_ipcc_startup(struct mbox_chan *link)\n{\n\tunsigned long chan = (unsigned long)link->con_priv;\n\tstruct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,\n\t\t\t\t\t       controller);\n\tint ret;\n\n\tret = clk_prepare_enable(ipcc->clk);\n\tif (ret) {\n\t\tdev_err(ipcc->controller.dev, \"can not enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tstm32_ipcc_clr_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,\n\t\t\t    RX_BIT_CHAN(chan));\n\n\treturn 0;\n}\n\nstatic void stm32_ipcc_shutdown(struct mbox_chan *link)\n{\n\tunsigned long chan = (unsigned long)link->con_priv;\n\tstruct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,\n\t\t\t\t\t       controller);\n\n\t \n\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,\n\t\t\t    RX_BIT_CHAN(chan) | TX_BIT_CHAN(chan));\n\n\tclk_disable_unprepare(ipcc->clk);\n}\n\nstatic const struct mbox_chan_ops stm32_ipcc_ops = {\n\t.send_data\t= stm32_ipcc_send_data,\n\t.startup\t= stm32_ipcc_startup,\n\t.shutdown\t= stm32_ipcc_shutdown,\n};\n\nstatic int stm32_ipcc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct stm32_ipcc *ipcc;\n\tunsigned long i;\n\tint ret;\n\tu32 ip_ver;\n\tstatic const char * const irq_name[] = {\"rx\", \"tx\"};\n\tirq_handler_t irq_thread[] = {stm32_ipcc_rx_irq, stm32_ipcc_tx_irq};\n\n\tif (!np) {\n\t\tdev_err(dev, \"No DT found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tipcc = devm_kzalloc(dev, sizeof(*ipcc), GFP_KERNEL);\n\tif (!ipcc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ipcc->lock);\n\n\t \n\tif (of_property_read_u32(np, \"st,proc-id\", &ipcc->proc_id)) {\n\t\tdev_err(dev, \"Missing st,proc-id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ipcc->proc_id >= STM32_MAX_PROCS) {\n\t\tdev_err(dev, \"Invalid proc_id (%d)\\n\", ipcc->proc_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tipcc->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ipcc->reg_base))\n\t\treturn PTR_ERR(ipcc->reg_base);\n\n\tipcc->reg_proc = ipcc->reg_base + ipcc->proc_id * IPCC_PROC_OFFST;\n\n\t \n\tipcc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ipcc->clk))\n\t\treturn PTR_ERR(ipcc->clk);\n\n\tret = clk_prepare_enable(ipcc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < IPCC_IRQ_NUM; i++) {\n\t\tipcc->irqs[i] = platform_get_irq_byname(pdev, irq_name[i]);\n\t\tif (ipcc->irqs[i] < 0) {\n\t\t\tret = ipcc->irqs[i];\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, ipcc->irqs[i], NULL,\n\t\t\t\t\t\tirq_thread[i], IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), ipcc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request irq %lu (%d)\\n\", i, ret);\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\t \n\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,\n\t\t\t    RX_BIT_MASK | TX_BIT_MASK);\n\tstm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XCR,\n\t\t\t    XCR_RXOIE | XCR_TXOIE);\n\n\t \n\tif (of_property_read_bool(np, \"wakeup-source\")) {\n\t\tdevice_set_wakeup_capable(dev, true);\n\n\t\tret = dev_pm_set_wake_irq(dev, ipcc->irqs[IPCC_IRQ_RX]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set wake up irq\\n\");\n\t\t\tgoto err_init_wkp;\n\t\t}\n\t}\n\n\t \n\tipcc->n_chans = readl_relaxed(ipcc->reg_base + IPCC_HWCFGR);\n\tipcc->n_chans &= IPCFGR_CHAN_MASK;\n\n\tipcc->controller.dev = dev;\n\tipcc->controller.txdone_irq = true;\n\tipcc->controller.ops = &stm32_ipcc_ops;\n\tipcc->controller.num_chans = ipcc->n_chans;\n\tipcc->controller.chans = devm_kcalloc(dev, ipcc->controller.num_chans,\n\t\t\t\t\t      sizeof(*ipcc->controller.chans),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!ipcc->controller.chans) {\n\t\tret = -ENOMEM;\n\t\tgoto err_irq_wkp;\n\t}\n\n\tfor (i = 0; i < ipcc->controller.num_chans; i++)\n\t\tipcc->controller.chans[i].con_priv = (void *)i;\n\n\tret = devm_mbox_controller_register(dev, &ipcc->controller);\n\tif (ret)\n\t\tgoto err_irq_wkp;\n\n\tplatform_set_drvdata(pdev, ipcc);\n\n\tip_ver = readl_relaxed(ipcc->reg_base + IPCC_VER);\n\n\tdev_info(dev, \"ipcc rev:%ld.%ld enabled, %d chans, proc %d\\n\",\n\t\t FIELD_GET(VER_MAJREV_MASK, ip_ver),\n\t\t FIELD_GET(VER_MINREV_MASK, ip_ver),\n\t\t ipcc->controller.num_chans, ipcc->proc_id);\n\n\tclk_disable_unprepare(ipcc->clk);\n\treturn 0;\n\nerr_irq_wkp:\n\tif (of_property_read_bool(np, \"wakeup-source\"))\n\t\tdev_pm_clear_wake_irq(dev);\nerr_init_wkp:\n\tdevice_set_wakeup_capable(dev, false);\nerr_clk:\n\tclk_disable_unprepare(ipcc->clk);\n\treturn ret;\n}\n\nstatic int stm32_ipcc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tif (of_property_read_bool(dev->of_node, \"wakeup-source\"))\n\t\tdev_pm_clear_wake_irq(&pdev->dev);\n\n\tdevice_set_wakeup_capable(dev, false);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_ipcc_suspend(struct device *dev)\n{\n\tstruct stm32_ipcc *ipcc = dev_get_drvdata(dev);\n\n\tipcc->xmr = readl_relaxed(ipcc->reg_proc + IPCC_XMR);\n\tipcc->xcr = readl_relaxed(ipcc->reg_proc + IPCC_XCR);\n\n\treturn 0;\n}\n\nstatic int stm32_ipcc_resume(struct device *dev)\n{\n\tstruct stm32_ipcc *ipcc = dev_get_drvdata(dev);\n\n\twritel_relaxed(ipcc->xmr, ipcc->reg_proc + IPCC_XMR);\n\twritel_relaxed(ipcc->xcr, ipcc->reg_proc + IPCC_XCR);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(stm32_ipcc_pm_ops,\n\t\t\t stm32_ipcc_suspend, stm32_ipcc_resume);\n\nstatic const struct of_device_id stm32_ipcc_of_match[] = {\n\t{ .compatible = \"st,stm32mp1-ipcc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_ipcc_of_match);\n\nstatic struct platform_driver stm32_ipcc_driver = {\n\t.driver = {\n\t\t.name = \"stm32-ipcc\",\n\t\t.pm = &stm32_ipcc_pm_ops,\n\t\t.of_match_table = stm32_ipcc_of_match,\n\t},\n\t.probe\t\t= stm32_ipcc_probe,\n\t.remove\t\t= stm32_ipcc_remove,\n};\n\nmodule_platform_driver(stm32_ipcc_driver);\n\nMODULE_AUTHOR(\"Ludovic Barre <ludovic.barre@st.com>\");\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_DESCRIPTION(\"STM32 IPCC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}