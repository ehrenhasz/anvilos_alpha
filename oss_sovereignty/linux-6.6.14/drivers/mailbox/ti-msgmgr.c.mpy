{
  "module_name": "ti-msgmgr.c",
  "hash_id": "d8598de35903e20e1a6ef8f8f52d6a7642e4c723ae31206cfdac8a9f302450ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/ti-msgmgr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ti/ti-msgmgr.h>\n\n#define Q_DATA_OFFSET(proxy, queue, reg)\t\\\n\t\t     ((0x10000 * (proxy)) + (0x80 * (queue)) + ((reg) * 4))\n#define Q_STATE_OFFSET(queue)\t\t\t((queue) * 0x4)\n#define Q_STATE_ENTRY_COUNT_MASK\t\t(0xFFF000)\n\n#define SPROXY_THREAD_OFFSET(tid) (0x1000 * (tid))\n#define SPROXY_THREAD_DATA_OFFSET(tid, reg) \\\n\t(SPROXY_THREAD_OFFSET(tid) + ((reg) * 0x4) + 0x4)\n\n#define SPROXY_THREAD_STATUS_OFFSET(tid) (SPROXY_THREAD_OFFSET(tid))\n\n#define SPROXY_THREAD_STATUS_COUNT_MASK (0xFF)\n\n#define SPROXY_THREAD_CTRL_OFFSET(tid) (0x1000 + SPROXY_THREAD_OFFSET(tid))\n#define SPROXY_THREAD_CTRL_DIR_MASK (0x1 << 31)\n\n \nstruct ti_msgmgr_valid_queue_desc {\n\tu8 queue_id;\n\tu8 proxy_id;\n\tbool is_tx;\n};\n\n \nstruct ti_msgmgr_desc {\n\tu8 queue_count;\n\tu8 max_message_size;\n\tu8 max_messages;\n\tu8 data_first_reg;\n\tu8 data_last_reg;\n\tu32 status_cnt_mask;\n\tu32 status_err_mask;\n\tbool tx_polled;\n\tint tx_poll_timeout_ms;\n\tconst struct ti_msgmgr_valid_queue_desc *valid_queues;\n\tconst char *data_region_name;\n\tconst char *status_region_name;\n\tconst char *ctrl_region_name;\n\tint num_valid_queues;\n\tbool is_sproxy;\n};\n\n \nstruct ti_queue_inst {\n\tchar name[30];\n\tu8 queue_id;\n\tu8 proxy_id;\n\tint irq;\n\tbool is_tx;\n\tvoid __iomem *queue_buff_start;\n\tvoid __iomem *queue_buff_end;\n\tvoid __iomem *queue_state;\n\tvoid __iomem *queue_ctrl;\n\tstruct mbox_chan *chan;\n\tu32 *rx_buff;\n\tbool polled_rx_mode;\n};\n\n \nstruct ti_msgmgr_inst {\n\tstruct device *dev;\n\tconst struct ti_msgmgr_desc *desc;\n\tvoid __iomem *queue_proxy_region;\n\tvoid __iomem *queue_state_debug_region;\n\tvoid __iomem *queue_ctrl_region;\n\tu8 num_valid_queues;\n\tstruct ti_queue_inst *qinsts;\n\tstruct mbox_controller mbox;\n\tstruct mbox_chan *chans;\n};\n\n \nstatic inline int\nti_msgmgr_queue_get_num_messages(const struct ti_msgmgr_desc *d,\n\t\t\t\t struct ti_queue_inst *qinst)\n{\n\tu32 val;\n\tu32 status_cnt_mask = d->status_cnt_mask;\n\n\t \n\tval = readl(qinst->queue_state) & status_cnt_mask;\n\tval >>= __ffs(status_cnt_mask);\n\n\treturn val;\n}\n\n \nstatic inline bool ti_msgmgr_queue_is_error(const struct ti_msgmgr_desc *d,\n\t\t\t\t\t    struct ti_queue_inst *qinst)\n{\n\tu32 val;\n\n\t \n\tif (!d->is_sproxy)\n\t\treturn false;\n\n\t \n\tval = readl(qinst->queue_state) & d->status_err_mask;\n\n\treturn val ? true : false;\n}\n\nstatic int ti_msgmgr_queue_rx_data(struct mbox_chan *chan, struct ti_queue_inst *qinst,\n\t\t\t\t   const struct ti_msgmgr_desc *desc)\n{\n\tint num_words;\n\tstruct ti_msgmgr_message message;\n\tvoid __iomem *data_reg;\n\tu32 *word_data;\n\n\t \n\tmessage.len = desc->max_message_size;\n\tmessage.buf = (u8 *)qinst->rx_buff;\n\n\t \n\tfor (data_reg = qinst->queue_buff_start, word_data = qinst->rx_buff,\n\t     num_words = (desc->max_message_size / sizeof(u32));\n\t     num_words; num_words--, data_reg += sizeof(u32), word_data++)\n\t\t*word_data = readl(data_reg);\n\n\t \n\tmbox_chan_received_data(chan, (void *)&message);\n\n\treturn 0;\n}\n\nstatic int ti_msgmgr_queue_rx_poll_timeout(struct mbox_chan *chan, int timeout_us)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tconst struct ti_msgmgr_desc *desc = inst->desc;\n\tint msg_count;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(qinst->queue_state, msg_count,\n\t\t\t\t\t(msg_count & desc->status_cnt_mask),\n\t\t\t\t\t10, timeout_us);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tti_msgmgr_queue_rx_data(chan, qinst, desc);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t ti_msgmgr_queue_rx_interrupt(int irq, void *p)\n{\n\tstruct mbox_chan *chan = p;\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tconst struct ti_msgmgr_desc *desc;\n\tint msg_count;\n\n\tif (WARN_ON(!inst)) {\n\t\tdev_err(dev, \"no platform drv data??\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (qinst->is_tx) {\n\t\tdev_err(dev, \"Cannot handle rx interrupt on tx channel %s\\n\",\n\t\t\tqinst->name);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdesc = inst->desc;\n\tif (ti_msgmgr_queue_is_error(desc, qinst)) {\n\t\tdev_err(dev, \"Error on Rx channel %s\\n\", qinst->name);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tmsg_count = ti_msgmgr_queue_get_num_messages(desc, qinst);\n\tif (!msg_count) {\n\t\t \n\t\tdev_dbg(dev, \"Spurious event - 0 pending data!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tti_msgmgr_queue_rx_data(chan, qinst, desc);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic bool ti_msgmgr_queue_peek_data(struct mbox_chan *chan)\n{\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tconst struct ti_msgmgr_desc *desc = inst->desc;\n\tint msg_count;\n\n\tif (qinst->is_tx)\n\t\treturn false;\n\n\tif (ti_msgmgr_queue_is_error(desc, qinst)) {\n\t\tdev_err(dev, \"Error on channel %s\\n\", qinst->name);\n\t\treturn false;\n\t}\n\n\tmsg_count = ti_msgmgr_queue_get_num_messages(desc, qinst);\n\n\treturn msg_count ? true : false;\n}\n\n \nstatic bool ti_msgmgr_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tconst struct ti_msgmgr_desc *desc = inst->desc;\n\tint msg_count;\n\n\tif (!qinst->is_tx)\n\t\treturn false;\n\n\tif (ti_msgmgr_queue_is_error(desc, qinst)) {\n\t\tdev_err(dev, \"Error on channel %s\\n\", qinst->name);\n\t\treturn false;\n\t}\n\n\tmsg_count = ti_msgmgr_queue_get_num_messages(desc, qinst);\n\n\tif (desc->is_sproxy) {\n\t\t \n\t\treturn msg_count ? true : false;\n\t}\n\n\t \n\treturn msg_count ? false : true;\n}\n\nstatic bool ti_msgmgr_chan_has_polled_queue_rx(struct mbox_chan *chan)\n{\n\tstruct ti_queue_inst *qinst;\n\n\tif (!chan)\n\t\treturn false;\n\n\tqinst = chan->con_priv;\n\treturn qinst->polled_rx_mode;\n}\n\n \nstatic int ti_msgmgr_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tconst struct ti_msgmgr_desc *desc;\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tint num_words, trail_bytes;\n\tstruct ti_msgmgr_message *message = data;\n\tvoid __iomem *data_reg;\n\tu32 *word_data;\n\tint ret = 0;\n\n\tif (WARN_ON(!inst)) {\n\t\tdev_err(dev, \"no platform drv data??\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdesc = inst->desc;\n\n\tif (ti_msgmgr_queue_is_error(desc, qinst)) {\n\t\tdev_err(dev, \"Error on channel %s\\n\", qinst->name);\n\t\treturn false;\n\t}\n\n\tif (desc->max_message_size < message->len) {\n\t\tdev_err(dev, \"Queue %s message length %zu > max %d\\n\",\n\t\t\tqinst->name, message->len, desc->max_message_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (data_reg = qinst->queue_buff_start,\n\t     num_words = message->len / sizeof(u32),\n\t     word_data = (u32 *)message->buf;\n\t     num_words; num_words--, data_reg += sizeof(u32), word_data++)\n\t\twritel(*word_data, data_reg);\n\n\ttrail_bytes = message->len % sizeof(u32);\n\tif (trail_bytes) {\n\t\tu32 data_trail = *word_data;\n\n\t\t \n\t\tdata_trail &= 0xFFFFFFFF >> (8 * (sizeof(u32) - trail_bytes));\n\t\twritel(data_trail, data_reg);\n\t\tdata_reg += sizeof(u32);\n\t}\n\n\t \n\twhile (data_reg <= qinst->queue_buff_end) {\n\t\twritel(0, data_reg);\n\t\tdata_reg += sizeof(u32);\n\t}\n\n\t \n\tif (ti_msgmgr_chan_has_polled_queue_rx(message->chan_rx))\n\t\tret = ti_msgmgr_queue_rx_poll_timeout(message->chan_rx,\n\t\t\t\t\t\t      message->timeout_rx_ms * 1000);\n\n\treturn ret;\n}\n\n \nstatic int ti_msgmgr_queue_rx_irq_req(struct device *dev,\n\t\t\t\t      const struct ti_msgmgr_desc *d,\n\t\t\t\t      struct ti_queue_inst *qinst,\n\t\t\t\t      struct mbox_chan *chan)\n{\n\tint ret = 0;\n\tchar of_rx_irq_name[7];\n\tstruct device_node *np;\n\n\tsnprintf(of_rx_irq_name, sizeof(of_rx_irq_name),\n\t\t \"rx_%03d\", d->is_sproxy ? qinst->proxy_id : qinst->queue_id);\n\n\t \n\tif (qinst->irq < 0) {\n\t\tnp = of_node_get(dev->of_node);\n\t\tif (!np)\n\t\t\treturn -ENODATA;\n\t\tqinst->irq = of_irq_get_byname(np, of_rx_irq_name);\n\t\tof_node_put(np);\n\n\t\tif (qinst->irq < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"QID %d PID %d:No IRQ[%s]: %d\\n\",\n\t\t\t\tqinst->queue_id, qinst->proxy_id,\n\t\t\t\tof_rx_irq_name, qinst->irq);\n\t\t\treturn qinst->irq;\n\t\t}\n\t}\n\n\t \n\tret = request_irq(qinst->irq, ti_msgmgr_queue_rx_interrupt,\n\t\t\t  IRQF_SHARED, qinst->name, chan);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to get IRQ %d on %s(res=%d)\\n\",\n\t\t\tqinst->irq, qinst->name, ret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ti_msgmgr_queue_startup(struct mbox_chan *chan)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\tconst struct ti_msgmgr_desc *d = inst->desc;\n\tint ret;\n\tint msg_count;\n\n\t \n\tif (d->is_sproxy) {\n\t\tqinst->is_tx = (readl(qinst->queue_ctrl) &\n\t\t\t\tSPROXY_THREAD_CTRL_DIR_MASK) ? false : true;\n\n\t\tmsg_count = ti_msgmgr_queue_get_num_messages(d, qinst);\n\n\t\tif (!msg_count && qinst->is_tx) {\n\t\t\tdev_err(dev, \"%s: Cannot transmit with 0 credits!\\n\",\n\t\t\t\tqinst->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!qinst->is_tx) {\n\t\t \n\t\tqinst->rx_buff = kzalloc(d->max_message_size, GFP_KERNEL);\n\t\tif (!qinst->rx_buff)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tret = ti_msgmgr_queue_rx_irq_req(dev, d, qinst, chan);\n\t\tif (ret) {\n\t\t\tkfree(qinst->rx_buff);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ti_msgmgr_queue_shutdown(struct mbox_chan *chan)\n{\n\tstruct ti_queue_inst *qinst = chan->con_priv;\n\n\tif (!qinst->is_tx) {\n\t\tfree_irq(qinst->irq, chan);\n\t\tkfree(qinst->rx_buff);\n\t}\n}\n\n \nstatic struct mbox_chan *ti_msgmgr_of_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t    const struct of_phandle_args *p)\n{\n\tstruct ti_msgmgr_inst *inst;\n\tint req_qid, req_pid;\n\tstruct ti_queue_inst *qinst;\n\tconst struct ti_msgmgr_desc *d;\n\tint i, ncells;\n\n\tinst = container_of(mbox, struct ti_msgmgr_inst, mbox);\n\tif (WARN_ON(!inst))\n\t\treturn ERR_PTR(-EINVAL);\n\n\td = inst->desc;\n\n\tif (d->is_sproxy)\n\t\tncells = 1;\n\telse\n\t\tncells = 2;\n\tif (p->args_count != ncells) {\n\t\tdev_err(inst->dev, \"Invalid arguments in dt[%d]. Must be %d\\n\",\n\t\t\tp->args_count, ncells);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (ncells == 1) {\n\t\treq_qid = 0;\n\t\treq_pid = p->args[0];\n\t} else {\n\t\treq_qid = p->args[0];\n\t\treq_pid = p->args[1];\n\t}\n\n\tif (d->is_sproxy) {\n\t\tif (req_pid >= d->num_valid_queues)\n\t\t\tgoto err;\n\t\tqinst = &inst->qinsts[req_pid];\n\t\treturn qinst->chan;\n\t}\n\n\tfor (qinst = inst->qinsts, i = 0; i < inst->num_valid_queues;\n\t     i++, qinst++) {\n\t\tif (req_qid == qinst->queue_id && req_pid == qinst->proxy_id)\n\t\t\treturn qinst->chan;\n\t}\n\nerr:\n\tdev_err(inst->dev, \"Queue ID %d, Proxy ID %d is wrong on %pOFn\\n\",\n\t\treq_qid, req_pid, p->np);\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstatic int ti_msgmgr_queue_setup(int idx, struct device *dev,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct ti_msgmgr_inst *inst,\n\t\t\t\t const struct ti_msgmgr_desc *d,\n\t\t\t\t const struct ti_msgmgr_valid_queue_desc *qd,\n\t\t\t\t struct ti_queue_inst *qinst,\n\t\t\t\t struct mbox_chan *chan)\n{\n\tchar *dir;\n\n\tqinst->proxy_id = qd->proxy_id;\n\tqinst->queue_id = qd->queue_id;\n\n\tif (qinst->queue_id > d->queue_count) {\n\t\tdev_err(dev, \"Queue Data [idx=%d] queuid %d > %d\\n\",\n\t\t\tidx, qinst->queue_id, d->queue_count);\n\t\treturn -ERANGE;\n\t}\n\n\tif (d->is_sproxy) {\n\t\tqinst->queue_buff_start = inst->queue_proxy_region +\n\t\t    SPROXY_THREAD_DATA_OFFSET(qinst->proxy_id,\n\t\t\t\t\t      d->data_first_reg);\n\t\tqinst->queue_buff_end = inst->queue_proxy_region +\n\t\t    SPROXY_THREAD_DATA_OFFSET(qinst->proxy_id,\n\t\t\t\t\t      d->data_last_reg);\n\t\tqinst->queue_state = inst->queue_state_debug_region +\n\t\t    SPROXY_THREAD_STATUS_OFFSET(qinst->proxy_id);\n\t\tqinst->queue_ctrl = inst->queue_ctrl_region +\n\t\t    SPROXY_THREAD_CTRL_OFFSET(qinst->proxy_id);\n\n\t\t \n\t\tdir = \"thr\";\n\t\tsnprintf(qinst->name, sizeof(qinst->name), \"%s %s_%03d\",\n\t\t\t dev_name(dev), dir, qinst->proxy_id);\n\t} else {\n\t\tqinst->queue_buff_start = inst->queue_proxy_region +\n\t\t    Q_DATA_OFFSET(qinst->proxy_id, qinst->queue_id,\n\t\t\t\t  d->data_first_reg);\n\t\tqinst->queue_buff_end = inst->queue_proxy_region +\n\t\t    Q_DATA_OFFSET(qinst->proxy_id, qinst->queue_id,\n\t\t\t\t  d->data_last_reg);\n\t\tqinst->queue_state =\n\t\t    inst->queue_state_debug_region +\n\t\t    Q_STATE_OFFSET(qinst->queue_id);\n\t\tqinst->is_tx = qd->is_tx;\n\t\tdir = qinst->is_tx ? \"tx\" : \"rx\";\n\t\tsnprintf(qinst->name, sizeof(qinst->name), \"%s %s_%03d_%03d\",\n\t\t\t dev_name(dev), dir, qinst->queue_id, qinst->proxy_id);\n\t}\n\n\tqinst->chan = chan;\n\n\t \n\tqinst->irq = -EINVAL;\n\n\tchan->con_priv = qinst;\n\n\tdev_dbg(dev, \"[%d] qidx=%d pidx=%d irq=%d q_s=%p q_e = %p\\n\",\n\t\tidx, qinst->queue_id, qinst->proxy_id, qinst->irq,\n\t\tqinst->queue_buff_start, qinst->queue_buff_end);\n\treturn 0;\n}\n\nstatic int ti_msgmgr_queue_rx_set_polled_mode(struct ti_queue_inst *qinst, bool enable)\n{\n\tif (enable) {\n\t\tdisable_irq(qinst->irq);\n\t\tqinst->polled_rx_mode = true;\n\t} else {\n\t\tenable_irq(qinst->irq);\n\t\tqinst->polled_rx_mode = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_msgmgr_suspend(struct device *dev)\n{\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tstruct ti_queue_inst *qinst;\n\tint i;\n\n\t \n\tfor (qinst = inst->qinsts, i = 0; i < inst->num_valid_queues; qinst++, i++) {\n\t\tif (!qinst->is_tx)\n\t\t\tti_msgmgr_queue_rx_set_polled_mode(qinst, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_msgmgr_resume(struct device *dev)\n{\n\tstruct ti_msgmgr_inst *inst = dev_get_drvdata(dev);\n\tstruct ti_queue_inst *qinst;\n\tint i;\n\n\tfor (qinst = inst->qinsts, i = 0; i < inst->num_valid_queues; qinst++, i++) {\n\t\tif (!qinst->is_tx)\n\t\t\tti_msgmgr_queue_rx_set_polled_mode(qinst, false);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ti_msgmgr_pm_ops, ti_msgmgr_suspend, ti_msgmgr_resume);\n\n \nstatic const struct mbox_chan_ops ti_msgmgr_chan_ops = {\n\t.startup = ti_msgmgr_queue_startup,\n\t.shutdown = ti_msgmgr_queue_shutdown,\n\t.peek_data = ti_msgmgr_queue_peek_data,\n\t.last_tx_done = ti_msgmgr_last_tx_done,\n\t.send_data = ti_msgmgr_send_data,\n};\n\n \nstatic const struct ti_msgmgr_valid_queue_desc k2g_valid_queues[] = {\n\t{.queue_id = 0, .proxy_id = 0, .is_tx = true,},\n\t{.queue_id = 1, .proxy_id = 0, .is_tx = true,},\n\t{.queue_id = 2, .proxy_id = 0, .is_tx = true,},\n\t{.queue_id = 3, .proxy_id = 0, .is_tx = true,},\n\t{.queue_id = 5, .proxy_id = 2, .is_tx = false,},\n\t{.queue_id = 56, .proxy_id = 1, .is_tx = true,},\n\t{.queue_id = 57, .proxy_id = 2, .is_tx = false,},\n\t{.queue_id = 58, .proxy_id = 3, .is_tx = true,},\n\t{.queue_id = 59, .proxy_id = 4, .is_tx = true,},\n\t{.queue_id = 60, .proxy_id = 5, .is_tx = true,},\n\t{.queue_id = 61, .proxy_id = 6, .is_tx = true,},\n};\n\nstatic const struct ti_msgmgr_desc k2g_desc = {\n\t.queue_count = 64,\n\t.max_message_size = 64,\n\t.max_messages = 128,\n\t.data_region_name = \"queue_proxy_region\",\n\t.status_region_name = \"queue_state_debug_region\",\n\t.data_first_reg = 16,\n\t.data_last_reg = 31,\n\t.status_cnt_mask = Q_STATE_ENTRY_COUNT_MASK,\n\t.tx_polled = false,\n\t.valid_queues = k2g_valid_queues,\n\t.num_valid_queues = ARRAY_SIZE(k2g_valid_queues),\n\t.is_sproxy = false,\n};\n\nstatic const struct ti_msgmgr_desc am654_desc = {\n\t.queue_count = 190,\n\t.num_valid_queues = 190,\n\t.max_message_size = 60,\n\t.data_region_name = \"target_data\",\n\t.status_region_name = \"rt\",\n\t.ctrl_region_name = \"scfg\",\n\t.data_first_reg = 0,\n\t.data_last_reg = 14,\n\t.status_cnt_mask = SPROXY_THREAD_STATUS_COUNT_MASK,\n\t.tx_polled = false,\n\t.is_sproxy = true,\n};\n\nstatic const struct of_device_id ti_msgmgr_of_match[] = {\n\t{.compatible = \"ti,k2g-message-manager\", .data = &k2g_desc},\n\t{.compatible = \"ti,am654-secure-proxy\", .data = &am654_desc},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, ti_msgmgr_of_match);\n\nstatic int ti_msgmgr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tstruct device_node *np;\n\tconst struct ti_msgmgr_desc *desc;\n\tstruct ti_msgmgr_inst *inst;\n\tstruct ti_queue_inst *qinst;\n\tstruct mbox_controller *mbox;\n\tstruct mbox_chan *chans;\n\tint queue_count;\n\tint i;\n\tint ret = -EINVAL;\n\tconst struct ti_msgmgr_valid_queue_desc *queue_desc;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"no OF information\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnp = dev->of_node;\n\n\tof_id = of_match_device(ti_msgmgr_of_match, dev);\n\tif (!of_id) {\n\t\tdev_err(dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdesc = of_id->data;\n\n\tinst = devm_kzalloc(dev, sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->dev = dev;\n\tinst->desc = desc;\n\n\tinst->queue_proxy_region =\n\t\tdevm_platform_ioremap_resource_byname(pdev, desc->data_region_name);\n\tif (IS_ERR(inst->queue_proxy_region))\n\t\treturn PTR_ERR(inst->queue_proxy_region);\n\n\tinst->queue_state_debug_region =\n\t\tdevm_platform_ioremap_resource_byname(pdev, desc->status_region_name);\n\tif (IS_ERR(inst->queue_state_debug_region))\n\t\treturn PTR_ERR(inst->queue_state_debug_region);\n\n\tif (desc->is_sproxy) {\n\t\tinst->queue_ctrl_region =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, desc->ctrl_region_name);\n\t\tif (IS_ERR(inst->queue_ctrl_region))\n\t\t\treturn PTR_ERR(inst->queue_ctrl_region);\n\t}\n\n\tdev_dbg(dev, \"proxy region=%p, queue_state=%p\\n\",\n\t\tinst->queue_proxy_region, inst->queue_state_debug_region);\n\n\tqueue_count = desc->num_valid_queues;\n\tif (!queue_count || queue_count > desc->queue_count) {\n\t\tdev_crit(dev, \"Invalid Number of queues %d. Max %d\\n\",\n\t\t\t queue_count, desc->queue_count);\n\t\treturn -ERANGE;\n\t}\n\tinst->num_valid_queues = queue_count;\n\n\tqinst = devm_kcalloc(dev, queue_count, sizeof(*qinst), GFP_KERNEL);\n\tif (!qinst)\n\t\treturn -ENOMEM;\n\tinst->qinsts = qinst;\n\n\tchans = devm_kcalloc(dev, queue_count, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\tinst->chans = chans;\n\n\tif (desc->is_sproxy) {\n\t\tstruct ti_msgmgr_valid_queue_desc sproxy_desc;\n\n\t\t \n\t\tfor (i = 0; i < queue_count; i++, qinst++, chans++) {\n\t\t\tsproxy_desc.queue_id = 0;\n\t\t\tsproxy_desc.proxy_id = i;\n\t\t\tret = ti_msgmgr_queue_setup(i, dev, np, inst,\n\t\t\t\t\t\t    desc, &sproxy_desc, qinst,\n\t\t\t\t\t\t    chans);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0, queue_desc = desc->valid_queues;\n\t\t     i < queue_count; i++, qinst++, chans++, queue_desc++) {\n\t\t\tret = ti_msgmgr_queue_setup(i, dev, np, inst,\n\t\t\t\t\t\t    desc, queue_desc, qinst,\n\t\t\t\t\t\t    chans);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmbox = &inst->mbox;\n\tmbox->dev = dev;\n\tmbox->ops = &ti_msgmgr_chan_ops;\n\tmbox->chans = inst->chans;\n\tmbox->num_chans = inst->num_valid_queues;\n\tmbox->txdone_irq = false;\n\tmbox->txdone_poll = desc->tx_polled;\n\tif (desc->tx_polled)\n\t\tmbox->txpoll_period = desc->tx_poll_timeout_ms;\n\tmbox->of_xlate = ti_msgmgr_of_xlate;\n\n\tplatform_set_drvdata(pdev, inst);\n\tret = devm_mbox_controller_register(dev, mbox);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register mbox_controller(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver ti_msgmgr_driver = {\n\t.probe = ti_msgmgr_probe,\n\t.driver = {\n\t\t   .name = \"ti-msgmgr\",\n\t\t   .of_match_table = of_match_ptr(ti_msgmgr_of_match),\n\t\t   .pm = &ti_msgmgr_pm_ops,\n\t},\n};\nmodule_platform_driver(ti_msgmgr_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI message manager driver\");\nMODULE_AUTHOR(\"Nishanth Menon\");\nMODULE_ALIAS(\"platform:ti-msgmgr\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}