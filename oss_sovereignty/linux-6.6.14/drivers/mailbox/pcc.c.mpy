{
  "module_name": "pcc.c",
  "hash_id": "e3ce61efc5893348f4dbdf08cb66c480fa3c03096967a856f746cc59805f0640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/pcc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/platform_device.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox_client.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <acpi/pcc.h>\n\n#include \"mailbox.h\"\n\n#define MBOX_IRQ_NAME\t\t\"pcc-mbox\"\n\n \nstruct pcc_chan_reg {\n\tvoid __iomem *vaddr;\n\tstruct acpi_generic_address *gas;\n\tu64 preserve_mask;\n\tu64 set_mask;\n\tu64 status_mask;\n};\n\n \nstruct pcc_chan_info {\n\tstruct pcc_mbox_chan chan;\n\tstruct pcc_chan_reg db;\n\tstruct pcc_chan_reg plat_irq_ack;\n\tstruct pcc_chan_reg cmd_complete;\n\tstruct pcc_chan_reg cmd_update;\n\tstruct pcc_chan_reg error;\n\tint plat_irq;\n};\n\n#define to_pcc_chan_info(c) container_of(c, struct pcc_chan_info, chan)\nstatic struct pcc_chan_info *chan_info;\nstatic int pcc_chan_count;\n\n \nstatic void read_register(void __iomem *vaddr, u64 *val, unsigned int bit_width)\n{\n\tswitch (bit_width) {\n\tcase 8:\n\t\t*val = readb(vaddr);\n\t\tbreak;\n\tcase 16:\n\t\t*val = readw(vaddr);\n\t\tbreak;\n\tcase 32:\n\t\t*val = readl(vaddr);\n\t\tbreak;\n\tcase 64:\n\t\t*val = readq(vaddr);\n\t\tbreak;\n\t}\n}\n\nstatic void write_register(void __iomem *vaddr, u64 val, unsigned int bit_width)\n{\n\tswitch (bit_width) {\n\tcase 8:\n\t\twriteb(val, vaddr);\n\t\tbreak;\n\tcase 16:\n\t\twritew(val, vaddr);\n\t\tbreak;\n\tcase 32:\n\t\twritel(val, vaddr);\n\t\tbreak;\n\tcase 64:\n\t\twriteq(val, vaddr);\n\t\tbreak;\n\t}\n}\n\nstatic int pcc_chan_reg_read(struct pcc_chan_reg *reg, u64 *val)\n{\n\tint ret = 0;\n\n\tif (!reg->gas) {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\n\tif (reg->vaddr)\n\t\tread_register(reg->vaddr, val, reg->gas->bit_width);\n\telse\n\t\tret = acpi_read(val, reg->gas);\n\n\treturn ret;\n}\n\nstatic int pcc_chan_reg_write(struct pcc_chan_reg *reg, u64 val)\n{\n\tint ret = 0;\n\n\tif (!reg->gas)\n\t\treturn 0;\n\n\tif (reg->vaddr)\n\t\twrite_register(reg->vaddr, val, reg->gas->bit_width);\n\telse\n\t\tret = acpi_write(val, reg->gas);\n\n\treturn ret;\n}\n\nstatic int pcc_chan_reg_read_modify_write(struct pcc_chan_reg *reg)\n{\n\tint ret = 0;\n\tu64 val;\n\n\tret = pcc_chan_reg_read(reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= reg->preserve_mask;\n\tval |= reg->set_mask;\n\n\treturn pcc_chan_reg_write(reg, val);\n}\n\n \nstatic int pcc_map_interrupt(u32 interrupt, u32 flags)\n{\n\tint trigger, polarity;\n\n\tif (!interrupt)\n\t\treturn 0;\n\n\ttrigger = (flags & ACPI_PCCT_INTERRUPT_MODE) ? ACPI_EDGE_SENSITIVE\n\t\t\t: ACPI_LEVEL_SENSITIVE;\n\n\tpolarity = (flags & ACPI_PCCT_INTERRUPT_POLARITY) ? ACPI_ACTIVE_LOW\n\t\t\t: ACPI_ACTIVE_HIGH;\n\n\treturn acpi_register_gsi(NULL, interrupt, trigger, polarity);\n}\n\n \nstatic irqreturn_t pcc_mbox_irq(int irq, void *p)\n{\n\tstruct pcc_chan_info *pchan;\n\tstruct mbox_chan *chan = p;\n\tu64 val;\n\tint ret;\n\n\tpchan = chan->con_priv;\n\n\tret = pcc_chan_reg_read(&pchan->cmd_complete, &val);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (val) {  \n\t\tval &= pchan->cmd_complete.status_mask;\n\t\tif (!val)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tret = pcc_chan_reg_read(&pchan->error, &val);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\tval &= pchan->error.status_mask;\n\tif (val) {\n\t\tval &= ~pchan->error.status_mask;\n\t\tpcc_chan_reg_write(&pchan->error, val);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (pcc_chan_reg_read_modify_write(&pchan->plat_irq_ack))\n\t\treturn IRQ_NONE;\n\n\tmbox_chan_received_data(chan, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstruct pcc_mbox_chan *\npcc_mbox_request_channel(struct mbox_client *cl, int subspace_id)\n{\n\tstruct pcc_chan_info *pchan;\n\tstruct mbox_chan *chan;\n\tint rc;\n\n\tif (subspace_id < 0 || subspace_id >= pcc_chan_count)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tpchan = chan_info + subspace_id;\n\tchan = pchan->chan.mchan;\n\tif (IS_ERR(chan) || chan->cl) {\n\t\tpr_err(\"Channel not found for idx: %d\\n\", subspace_id);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\trc = mbox_bind_client(chan, cl);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn &pchan->chan;\n}\nEXPORT_SYMBOL_GPL(pcc_mbox_request_channel);\n\n \nvoid pcc_mbox_free_channel(struct pcc_mbox_chan *pchan)\n{\n\tstruct mbox_chan *chan = pchan->mchan;\n\n\tif (!chan || !chan->cl)\n\t\treturn;\n\n\tmbox_free_channel(chan);\n}\nEXPORT_SYMBOL_GPL(pcc_mbox_free_channel);\n\n \nstatic int pcc_send_data(struct mbox_chan *chan, void *data)\n{\n\tint ret;\n\tstruct pcc_chan_info *pchan = chan->con_priv;\n\n\tret = pcc_chan_reg_read_modify_write(&pchan->cmd_update);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pcc_chan_reg_read_modify_write(&pchan->db);\n}\n\n \nstatic int pcc_startup(struct mbox_chan *chan)\n{\n\tstruct pcc_chan_info *pchan = chan->con_priv;\n\tint rc;\n\n\tif (pchan->plat_irq > 0) {\n\t\trc = devm_request_irq(chan->mbox->dev, pchan->plat_irq, pcc_mbox_irq, 0,\n\t\t\t\t      MBOX_IRQ_NAME, chan);\n\t\tif (unlikely(rc)) {\n\t\t\tdev_err(chan->mbox->dev, \"failed to register PCC interrupt %d\\n\",\n\t\t\t\tpchan->plat_irq);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pcc_shutdown(struct mbox_chan *chan)\n{\n\tstruct pcc_chan_info *pchan = chan->con_priv;\n\n\tif (pchan->plat_irq > 0)\n\t\tdevm_free_irq(chan->mbox->dev, pchan->plat_irq, chan);\n}\n\nstatic const struct mbox_chan_ops pcc_chan_ops = {\n\t.send_data = pcc_send_data,\n\t.startup = pcc_startup,\n\t.shutdown = pcc_shutdown,\n};\n\n \nstatic int parse_pcc_subspace(union acpi_subtable_headers *header,\n\t\tconst unsigned long end)\n{\n\tstruct acpi_pcct_subspace *ss = (struct acpi_pcct_subspace *) header;\n\n\tif (ss->header.type < ACPI_PCCT_TYPE_RESERVED)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int\npcc_chan_reg_init(struct pcc_chan_reg *reg, struct acpi_generic_address *gas,\n\t\t  u64 preserve_mask, u64 set_mask, u64 status_mask, char *name)\n{\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\tif (!(gas->bit_width >= 8 && gas->bit_width <= 64 &&\n\t\t      is_power_of_2(gas->bit_width))) {\n\t\t\tpr_err(\"Error: Cannot access register of %u bit width\",\n\t\t\t       gas->bit_width);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treg->vaddr = acpi_os_ioremap(gas->address, gas->bit_width / 8);\n\t\tif (!reg->vaddr) {\n\t\t\tpr_err(\"Failed to ioremap PCC %s register\\n\", name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treg->gas = gas;\n\treg->preserve_mask = preserve_mask;\n\treg->set_mask = set_mask;\n\treg->status_mask = status_mask;\n\treturn 0;\n}\n\n \nstatic int pcc_parse_subspace_irq(struct pcc_chan_info *pchan,\n\t\t\t\t  struct acpi_subtable_header *pcct_entry)\n{\n\tint ret = 0;\n\tstruct acpi_pcct_hw_reduced *pcct_ss;\n\n\tif (pcct_entry->type < ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE ||\n\t    pcct_entry->type > ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE)\n\t\treturn 0;\n\n\tpcct_ss = (struct acpi_pcct_hw_reduced *)pcct_entry;\n\tpchan->plat_irq = pcc_map_interrupt(pcct_ss->platform_interrupt,\n\t\t\t\t\t    (u32)pcct_ss->flags);\n\tif (pchan->plat_irq <= 0) {\n\t\tpr_err(\"PCC GSI %d not registered\\n\",\n\t\t       pcct_ss->platform_interrupt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcct_ss->header.type == ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2) {\n\t\tstruct acpi_pcct_hw_reduced_type2 *pcct2_ss = (void *)pcct_ss;\n\n\t\tret = pcc_chan_reg_init(&pchan->plat_irq_ack,\n\t\t\t\t\t&pcct2_ss->platform_ack_register,\n\t\t\t\t\tpcct2_ss->ack_preserve_mask,\n\t\t\t\t\tpcct2_ss->ack_write_mask, 0,\n\t\t\t\t\t\"PLAT IRQ ACK\");\n\n\t} else if (pcct_ss->header.type == ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE ||\n\t\t   pcct_ss->header.type == ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE) {\n\t\tstruct acpi_pcct_ext_pcc_master *pcct_ext = (void *)pcct_ss;\n\n\t\tret = pcc_chan_reg_init(&pchan->plat_irq_ack,\n\t\t\t\t\t&pcct_ext->platform_ack_register,\n\t\t\t\t\tpcct_ext->ack_preserve_mask,\n\t\t\t\t\tpcct_ext->ack_set_mask, 0,\n\t\t\t\t\t\"PLAT IRQ ACK\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic int pcc_parse_subspace_db_reg(struct pcc_chan_info *pchan,\n\t\t\t\t     struct acpi_subtable_header *pcct_entry)\n{\n\tint ret = 0;\n\n\tif (pcct_entry->type <= ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2) {\n\t\tstruct acpi_pcct_subspace *pcct_ss;\n\n\t\tpcct_ss = (struct acpi_pcct_subspace *)pcct_entry;\n\n\t\tret = pcc_chan_reg_init(&pchan->db,\n\t\t\t\t\t&pcct_ss->doorbell_register,\n\t\t\t\t\tpcct_ss->preserve_mask,\n\t\t\t\t\tpcct_ss->write_mask, 0,\t\"Doorbell\");\n\n\t} else {\n\t\tstruct acpi_pcct_ext_pcc_master *pcct_ext;\n\n\t\tpcct_ext = (struct acpi_pcct_ext_pcc_master *)pcct_entry;\n\n\t\tret = pcc_chan_reg_init(&pchan->db,\n\t\t\t\t\t&pcct_ext->doorbell_register,\n\t\t\t\t\tpcct_ext->preserve_mask,\n\t\t\t\t\tpcct_ext->write_mask, 0, \"Doorbell\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pcc_chan_reg_init(&pchan->cmd_complete,\n\t\t\t\t\t&pcct_ext->cmd_complete_register,\n\t\t\t\t\t0, 0, pcct_ext->cmd_complete_mask,\n\t\t\t\t\t\"Command Complete Check\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pcc_chan_reg_init(&pchan->cmd_update,\n\t\t\t\t\t&pcct_ext->cmd_update_register,\n\t\t\t\t\tpcct_ext->cmd_update_preserve_mask,\n\t\t\t\t\tpcct_ext->cmd_update_set_mask, 0,\n\t\t\t\t\t\"Command Complete Update\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pcc_chan_reg_init(&pchan->error,\n\t\t\t\t\t&pcct_ext->error_status_register,\n\t\t\t\t\t0, 0, pcct_ext->error_status_mask,\n\t\t\t\t\t\"Error Status\");\n\t}\n\treturn ret;\n}\n\n \nstatic void pcc_parse_subspace_shmem(struct pcc_chan_info *pchan,\n\t\t\t\t     struct acpi_subtable_header *pcct_entry)\n{\n\tif (pcct_entry->type <= ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2) {\n\t\tstruct acpi_pcct_subspace *pcct_ss =\n\t\t\t(struct acpi_pcct_subspace *)pcct_entry;\n\n\t\tpchan->chan.shmem_base_addr = pcct_ss->base_address;\n\t\tpchan->chan.shmem_size = pcct_ss->length;\n\t\tpchan->chan.latency = pcct_ss->latency;\n\t\tpchan->chan.max_access_rate = pcct_ss->max_access_rate;\n\t\tpchan->chan.min_turnaround_time = pcct_ss->min_turnaround_time;\n\t} else {\n\t\tstruct acpi_pcct_ext_pcc_master *pcct_ext =\n\t\t\t(struct acpi_pcct_ext_pcc_master *)pcct_entry;\n\n\t\tpchan->chan.shmem_base_addr = pcct_ext->base_address;\n\t\tpchan->chan.shmem_size = pcct_ext->length;\n\t\tpchan->chan.latency = pcct_ext->latency;\n\t\tpchan->chan.max_access_rate = pcct_ext->max_access_rate;\n\t\tpchan->chan.min_turnaround_time = pcct_ext->min_turnaround_time;\n\t}\n}\n\n \nstatic int __init acpi_pcc_probe(void)\n{\n\tint count, i, rc = 0;\n\tacpi_status status;\n\tstruct acpi_table_header *pcct_tbl;\n\tstruct acpi_subtable_proc proc[ACPI_PCCT_TYPE_RESERVED];\n\n\tstatus = acpi_get_table(ACPI_SIG_PCCT, 0, &pcct_tbl);\n\tif (ACPI_FAILURE(status) || !pcct_tbl)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = ACPI_PCCT_TYPE_GENERIC_SUBSPACE;\n\t     i < ACPI_PCCT_TYPE_RESERVED; i++) {\n\t\tproc[i].id = i;\n\t\tproc[i].count = 0;\n\t\tproc[i].handler = parse_pcc_subspace;\n\t}\n\n\tcount = acpi_table_parse_entries_array(ACPI_SIG_PCCT,\n\t\t\tsizeof(struct acpi_table_pcct), proc,\n\t\t\tACPI_PCCT_TYPE_RESERVED, MAX_PCC_SUBSPACES);\n\tif (count <= 0 || count > MAX_PCC_SUBSPACES) {\n\t\tif (count < 0)\n\t\t\tpr_warn(\"Error parsing PCC subspaces from PCCT\\n\");\n\t\telse\n\t\t\tpr_warn(\"Invalid PCCT: %d PCC subspaces\\n\", count);\n\n\t\trc = -EINVAL;\n\t} else {\n\t\tpcc_chan_count = count;\n\t}\n\n\tacpi_put_table(pcct_tbl);\n\n\treturn rc;\n}\n\n \nstatic int pcc_mbox_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mbox_controller *pcc_mbox_ctrl;\n\tstruct mbox_chan *pcc_mbox_channels;\n\tstruct acpi_table_header *pcct_tbl;\n\tstruct acpi_subtable_header *pcct_entry;\n\tstruct acpi_table_pcct *acpi_pcct_tbl;\n\tacpi_status status = AE_OK;\n\tint i, rc, count = pcc_chan_count;\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_PCCT, 0, &pcct_tbl);\n\n\tif (ACPI_FAILURE(status) || !pcct_tbl)\n\t\treturn -ENODEV;\n\n\tpcc_mbox_channels = devm_kcalloc(dev, count, sizeof(*pcc_mbox_channels),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!pcc_mbox_channels) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tchan_info = devm_kcalloc(dev, count, sizeof(*chan_info), GFP_KERNEL);\n\tif (!chan_info) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpcc_mbox_ctrl = devm_kzalloc(dev, sizeof(*pcc_mbox_ctrl), GFP_KERNEL);\n\tif (!pcc_mbox_ctrl) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tpcct_entry = (struct acpi_subtable_header *) (\n\t\t(unsigned long) pcct_tbl + sizeof(struct acpi_table_pcct));\n\n\tacpi_pcct_tbl = (struct acpi_table_pcct *) pcct_tbl;\n\tif (acpi_pcct_tbl->flags & ACPI_PCCT_DOORBELL)\n\t\tpcc_mbox_ctrl->txdone_irq = true;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct pcc_chan_info *pchan = chan_info + i;\n\n\t\tpcc_mbox_channels[i].con_priv = pchan;\n\t\tpchan->chan.mchan = &pcc_mbox_channels[i];\n\n\t\tif (pcct_entry->type == ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE &&\n\t\t    !pcc_mbox_ctrl->txdone_irq) {\n\t\t\tpr_err(\"Platform Interrupt flag must be set to 1\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (pcc_mbox_ctrl->txdone_irq) {\n\t\t\trc = pcc_parse_subspace_irq(pchan, pcct_entry);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t\trc = pcc_parse_subspace_db_reg(pchan, pcct_entry);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\n\t\tpcc_parse_subspace_shmem(pchan, pcct_entry);\n\n\t\tpcct_entry = (struct acpi_subtable_header *)\n\t\t\t((unsigned long) pcct_entry + pcct_entry->length);\n\t}\n\n\tpcc_mbox_ctrl->num_chans = count;\n\n\tpr_info(\"Detected %d PCC Subspaces\\n\", pcc_mbox_ctrl->num_chans);\n\n\tpcc_mbox_ctrl->chans = pcc_mbox_channels;\n\tpcc_mbox_ctrl->ops = &pcc_chan_ops;\n\tpcc_mbox_ctrl->dev = dev;\n\n\tpr_info(\"Registering PCC driver as Mailbox controller\\n\");\n\trc = mbox_controller_register(pcc_mbox_ctrl);\n\tif (rc)\n\t\tpr_err(\"Err registering PCC as Mailbox controller: %d\\n\", rc);\n\telse\n\t\treturn 0;\nerr:\n\tacpi_put_table(pcct_tbl);\n\treturn rc;\n}\n\nstatic struct platform_driver pcc_mbox_driver = {\n\t.probe = pcc_mbox_probe,\n\t.driver = {\n\t\t.name = \"PCCT\",\n\t},\n};\n\nstatic int __init pcc_init(void)\n{\n\tint ret;\n\tstruct platform_device *pcc_pdev;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\t \n\tret = acpi_pcc_probe();\n\n\tif (ret) {\n\t\tpr_debug(\"ACPI PCC probe failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcc_pdev = platform_create_bundle(&pcc_mbox_driver,\n\t\t\tpcc_mbox_probe, NULL, 0, NULL, 0);\n\n\tif (IS_ERR(pcc_pdev)) {\n\t\tpr_debug(\"Err creating PCC platform bundle\\n\");\n\t\tpcc_chan_count = 0;\n\t\treturn PTR_ERR(pcc_pdev);\n\t}\n\n\treturn 0;\n}\n\n \npostcore_initcall(pcc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}