{
  "module_name": "rockchip-mailbox.c",
  "hash_id": "e4906403f35ad809aee1aea7fef85176e744696f2db4456f15612162bd0d8444",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/rockchip-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define MAILBOX_A2B_INTEN\t\t0x00\n#define MAILBOX_A2B_STATUS\t\t0x04\n#define MAILBOX_A2B_CMD(x)\t\t(0x08 + (x) * 8)\n#define MAILBOX_A2B_DAT(x)\t\t(0x0c + (x) * 8)\n\n#define MAILBOX_B2A_INTEN\t\t0x28\n#define MAILBOX_B2A_STATUS\t\t0x2C\n#define MAILBOX_B2A_CMD(x)\t\t(0x30 + (x) * 8)\n#define MAILBOX_B2A_DAT(x)\t\t(0x34 + (x) * 8)\n\nstruct rockchip_mbox_msg {\n\tu32 cmd;\n\tint rx_size;\n};\n\nstruct rockchip_mbox_data {\n\tint num_chans;\n};\n\nstruct rockchip_mbox_chan {\n\tint idx;\n\tint irq;\n\tstruct rockchip_mbox_msg *msg;\n\tstruct rockchip_mbox *mb;\n};\n\nstruct rockchip_mbox {\n\tstruct mbox_controller mbox;\n\tstruct clk *pclk;\n\tvoid __iomem *mbox_base;\n\n\t \n\tu32 buf_size;\n\n\tstruct rockchip_mbox_chan *chans;\n};\n\nstatic int rockchip_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);\n\tstruct rockchip_mbox_msg *msg = data;\n\tstruct rockchip_mbox_chan *chans = mb->chans;\n\n\tif (!msg)\n\t\treturn -EINVAL;\n\n\tif (msg->rx_size > mb->buf_size) {\n\t\tdev_err(mb->mbox.dev, \"Transmit size over buf size(%d)\\n\",\n\t\t\tmb->buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(mb->mbox.dev, \"Chan[%d]: A2B message, cmd 0x%08x\\n\",\n\t\tchans->idx, msg->cmd);\n\n\tmb->chans[chans->idx].msg = msg;\n\n\twritel_relaxed(msg->cmd, mb->mbox_base + MAILBOX_A2B_CMD(chans->idx));\n\twritel_relaxed(msg->rx_size, mb->mbox_base +\n\t\t       MAILBOX_A2B_DAT(chans->idx));\n\n\treturn 0;\n}\n\nstatic int rockchip_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);\n\n\t \n\twritel_relaxed((1 << mb->mbox.num_chans) - 1,\n\t\t       mb->mbox_base + MAILBOX_B2A_INTEN);\n\n\treturn 0;\n}\n\nstatic void rockchip_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);\n\tstruct rockchip_mbox_chan *chans = mb->chans;\n\n\t \n\twritel_relaxed(0, mb->mbox_base + MAILBOX_B2A_INTEN);\n\n\tmb->chans[chans->idx].msg = NULL;\n}\n\nstatic const struct mbox_chan_ops rockchip_mbox_chan_ops = {\n\t.send_data\t= rockchip_mbox_send_data,\n\t.startup\t= rockchip_mbox_startup,\n\t.shutdown\t= rockchip_mbox_shutdown,\n};\n\nstatic irqreturn_t rockchip_mbox_irq(int irq, void *dev_id)\n{\n\tint idx;\n\tstruct rockchip_mbox *mb = (struct rockchip_mbox *)dev_id;\n\tu32 status = readl_relaxed(mb->mbox_base + MAILBOX_B2A_STATUS);\n\n\tfor (idx = 0; idx < mb->mbox.num_chans; idx++) {\n\t\tif ((status & (1 << idx)) && (irq == mb->chans[idx].irq)) {\n\t\t\t \n\t\t\twritel_relaxed(1 << idx,\n\t\t\t\t       mb->mbox_base + MAILBOX_B2A_STATUS);\n\t\t\treturn IRQ_WAKE_THREAD;\n\t\t}\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t rockchip_mbox_isr(int irq, void *dev_id)\n{\n\tint idx;\n\tstruct rockchip_mbox_msg *msg = NULL;\n\tstruct rockchip_mbox *mb = (struct rockchip_mbox *)dev_id;\n\n\tfor (idx = 0; idx < mb->mbox.num_chans; idx++) {\n\t\tif (irq != mb->chans[idx].irq)\n\t\t\tcontinue;\n\n\t\tmsg = mb->chans[idx].msg;\n\t\tif (!msg) {\n\t\t\tdev_err(mb->mbox.dev,\n\t\t\t\t\"Chan[%d]: B2A message is NULL\\n\", idx);\n\t\t\tbreak;  \n\t\t}\n\n\t\tmbox_chan_received_data(&mb->mbox.chans[idx], msg);\n\t\tmb->chans[idx].msg = NULL;\n\n\t\tdev_dbg(mb->mbox.dev, \"Chan[%d]: B2A message, cmd 0x%08x\\n\",\n\t\t\tidx, msg->cmd);\n\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rockchip_mbox_data rk3368_drv_data = {\n\t.num_chans = 4,\n};\n\nstatic const struct of_device_id rockchip_mbox_of_match[] = {\n\t{ .compatible = \"rockchip,rk3368-mailbox\", .data = &rk3368_drv_data},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rockchp_mbox_of_match);\n\nstatic int rockchip_mbox_probe(struct platform_device *pdev)\n{\n\tstruct rockchip_mbox *mb;\n\tconst struct rockchip_mbox_data *drv_data;\n\tstruct resource *res;\n\tint ret, irq, i;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tdrv_data = (const struct rockchip_mbox_data *) device_get_match_data(&pdev->dev);\n\n\tmb = devm_kzalloc(&pdev->dev, sizeof(*mb), GFP_KERNEL);\n\tif (!mb)\n\t\treturn -ENOMEM;\n\n\tmb->chans = devm_kcalloc(&pdev->dev, drv_data->num_chans,\n\t\t\t\t sizeof(*mb->chans), GFP_KERNEL);\n\tif (!mb->chans)\n\t\treturn -ENOMEM;\n\n\tmb->mbox.chans = devm_kcalloc(&pdev->dev, drv_data->num_chans,\n\t\t\t\t      sizeof(*mb->mbox.chans), GFP_KERNEL);\n\tif (!mb->mbox.chans)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mb);\n\n\tmb->mbox.dev = &pdev->dev;\n\tmb->mbox.num_chans = drv_data->num_chans;\n\tmb->mbox.ops = &rockchip_mbox_chan_ops;\n\tmb->mbox.txdone_irq = true;\n\n\tmb->mbox_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(mb->mbox_base))\n\t\treturn PTR_ERR(mb->mbox_base);\n\n\t \n\tmb->buf_size = (size_t)resource_size(res) / (drv_data->num_chans * 2);\n\n\tmb->pclk = devm_clk_get(&pdev->dev, \"pclk_mailbox\");\n\tif (IS_ERR(mb->pclk)) {\n\t\tret = PTR_ERR(mb->pclk);\n\t\tdev_err(&pdev->dev, \"failed to get pclk_mailbox clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(mb->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable pclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < mb->mbox.num_chans; i++) {\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t\trockchip_mbox_irq,\n\t\t\t\t\t\trockchip_mbox_isr, IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&pdev->dev), mb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmb->chans[i].idx = i;\n\t\tmb->chans[i].irq = irq;\n\t\tmb->chans[i].mb = mb;\n\t\tmb->chans[i].msg = NULL;\n\t}\n\n\tret = devm_mbox_controller_register(&pdev->dev, &mb->mbox);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to register mailbox: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver rockchip_mbox_driver = {\n\t.probe\t= rockchip_mbox_probe,\n\t.driver = {\n\t\t.name = \"rockchip-mailbox\",\n\t\t.of_match_table = rockchip_mbox_of_match,\n\t},\n};\n\nmodule_platform_driver(rockchip_mbox_driver);\n\nMODULE_DESCRIPTION(\"Rockchip mailbox: communicate between CPU cores and MCU\");\nMODULE_AUTHOR(\"Addy Ke <addy.ke@rock-chips.com>\");\nMODULE_AUTHOR(\"Caesar Wang <wxt@rock-chips.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}