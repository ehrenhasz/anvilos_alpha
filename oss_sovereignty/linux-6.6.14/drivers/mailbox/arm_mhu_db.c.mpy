{
  "module_name": "arm_mhu_db.c",
  "hash_id": "dfeadf59567391383754bc8feae459f0f8a60850937ac867db1c9bae52f96957",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/arm_mhu_db.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#define INTR_STAT_OFS\t0x0\n#define INTR_SET_OFS\t0x8\n#define INTR_CLR_OFS\t0x10\n\n#define MHU_LP_OFFSET\t0x0\n#define MHU_HP_OFFSET\t0x20\n#define MHU_SEC_OFFSET\t0x200\n#define TX_REG_OFFSET\t0x100\n\n#define MHU_CHANS\t3\t \n#define MHU_CHAN_MAX\t20\t \n#define MHU_NUM_DOORBELLS\t32\n\nstruct mhu_db_link {\n\tunsigned int irq;\n\tvoid __iomem *tx_reg;\n\tvoid __iomem *rx_reg;\n};\n\nstruct arm_mhu {\n\tvoid __iomem *base;\n\tstruct mhu_db_link mlink[MHU_CHANS];\n\tstruct mbox_controller mbox;\n\tstruct device *dev;\n};\n\n \nstruct mhu_db_channel {\n\tstruct arm_mhu *mhu;\n\tunsigned int pchan;\n\tunsigned int doorbell;\n};\n\nstatic inline struct mbox_chan *\nmhu_db_mbox_to_channel(struct mbox_controller *mbox, unsigned int pchan,\n\t\t       unsigned int doorbell)\n{\n\tint i;\n\tstruct mhu_db_channel *chan_info;\n\n\tfor (i = 0; i < mbox->num_chans; i++) {\n\t\tchan_info = mbox->chans[i].con_priv;\n\t\tif (chan_info && chan_info->pchan == pchan &&\n\t\t    chan_info->doorbell == doorbell)\n\t\t\treturn &mbox->chans[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void mhu_db_mbox_clear_irq(struct mbox_chan *chan)\n{\n\tstruct mhu_db_channel *chan_info = chan->con_priv;\n\tvoid __iomem *base = chan_info->mhu->mlink[chan_info->pchan].rx_reg;\n\n\twritel_relaxed(BIT(chan_info->doorbell), base + INTR_CLR_OFS);\n}\n\nstatic unsigned int mhu_db_mbox_irq_to_pchan_num(struct arm_mhu *mhu, int irq)\n{\n\tunsigned int pchan;\n\n\tfor (pchan = 0; pchan < MHU_CHANS; pchan++)\n\t\tif (mhu->mlink[pchan].irq == irq)\n\t\t\tbreak;\n\treturn pchan;\n}\n\nstatic struct mbox_chan *\nmhu_db_mbox_irq_to_channel(struct arm_mhu *mhu, unsigned int pchan)\n{\n\tunsigned long bits;\n\tunsigned int doorbell;\n\tstruct mbox_chan *chan = NULL;\n\tstruct mbox_controller *mbox = &mhu->mbox;\n\tvoid __iomem *base = mhu->mlink[pchan].rx_reg;\n\n\tbits = readl_relaxed(base + INTR_STAT_OFS);\n\tif (!bits)\n\t\t \n\t\treturn NULL;\n\n\t \n\tfor (doorbell = 0; bits; doorbell++) {\n\t\tif (!test_and_clear_bit(doorbell, &bits))\n\t\t\tcontinue;\n\n\t\tchan = mhu_db_mbox_to_channel(mbox, pchan, doorbell);\n\t\tif (chan)\n\t\t\tbreak;\n\t\tdev_err(mbox->dev,\n\t\t\t\"Channel not registered: pchan: %d doorbell: %d\\n\",\n\t\t\tpchan, doorbell);\n\t}\n\n\treturn chan;\n}\n\nstatic irqreturn_t mhu_db_mbox_rx_handler(int irq, void *data)\n{\n\tstruct mbox_chan *chan;\n\tstruct arm_mhu *mhu = data;\n\tunsigned int pchan = mhu_db_mbox_irq_to_pchan_num(mhu, irq);\n\n\twhile (NULL != (chan = mhu_db_mbox_irq_to_channel(mhu, pchan))) {\n\t\tmbox_chan_received_data(chan, NULL);\n\t\tmhu_db_mbox_clear_irq(chan);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool mhu_db_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct mhu_db_channel *chan_info = chan->con_priv;\n\tvoid __iomem *base = chan_info->mhu->mlink[chan_info->pchan].tx_reg;\n\n\tif (readl_relaxed(base + INTR_STAT_OFS) & BIT(chan_info->doorbell))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mhu_db_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct mhu_db_channel *chan_info = chan->con_priv;\n\tvoid __iomem *base = chan_info->mhu->mlink[chan_info->pchan].tx_reg;\n\n\t \n\twritel_relaxed(BIT(chan_info->doorbell), base + INTR_SET_OFS);\n\n\treturn 0;\n}\n\nstatic int mhu_db_startup(struct mbox_chan *chan)\n{\n\tmhu_db_mbox_clear_irq(chan);\n\treturn 0;\n}\n\nstatic void mhu_db_shutdown(struct mbox_chan *chan)\n{\n\tstruct mhu_db_channel *chan_info = chan->con_priv;\n\tstruct mbox_controller *mbox = &chan_info->mhu->mbox;\n\tint i;\n\n\tfor (i = 0; i < mbox->num_chans; i++)\n\t\tif (chan == &mbox->chans[i])\n\t\t\tbreak;\n\n\tif (mbox->num_chans == i) {\n\t\tdev_warn(mbox->dev, \"Request to free non-existent channel\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmhu_db_mbox_clear_irq(chan);\n\tdevm_kfree(mbox->dev, chan->con_priv);\n\tchan->con_priv = NULL;\n}\n\nstatic struct mbox_chan *mhu_db_mbox_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t   const struct of_phandle_args *spec)\n{\n\tstruct arm_mhu *mhu = dev_get_drvdata(mbox->dev);\n\tstruct mhu_db_channel *chan_info;\n\tstruct mbox_chan *chan;\n\tunsigned int pchan = spec->args[0];\n\tunsigned int doorbell = spec->args[1];\n\tint i;\n\n\t \n\tif (pchan >= MHU_CHANS || doorbell >= MHU_NUM_DOORBELLS) {\n\t\tdev_err(mbox->dev,\n\t\t\t\"Invalid channel requested pchan: %d doorbell: %d\\n\",\n\t\t\tpchan, doorbell);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tchan = mhu_db_mbox_to_channel(mbox, pchan, doorbell);\n\tif (chan) {\n\t\tdev_err(mbox->dev, \"Channel in use: pchan: %d doorbell: %d\\n\",\n\t\t\tpchan, doorbell);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\t \n\tfor (i = 0; i < mbox->num_chans; i++)\n\t\tif (!mbox->chans[i].con_priv)\n\t\t\tbreak;\n\n\tif (mbox->num_chans == i) {\n\t\tdev_err(mbox->dev, \"No free channels left\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tchan = &mbox->chans[i];\n\n\tchan_info = devm_kzalloc(mbox->dev, sizeof(*chan_info), GFP_KERNEL);\n\tif (!chan_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchan_info->mhu = mhu;\n\tchan_info->pchan = pchan;\n\tchan_info->doorbell = doorbell;\n\n\tchan->con_priv = chan_info;\n\n\tdev_dbg(mbox->dev, \"mbox: created channel phys: %d doorbell: %d\\n\",\n\t\tpchan, doorbell);\n\n\treturn chan;\n}\n\nstatic const struct mbox_chan_ops mhu_db_ops = {\n\t.send_data = mhu_db_send_data,\n\t.startup = mhu_db_startup,\n\t.shutdown = mhu_db_shutdown,\n\t.last_tx_done = mhu_db_last_tx_done,\n};\n\nstatic int mhu_db_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tu32 cell_count;\n\tint i, err, max_chans;\n\tstruct arm_mhu *mhu;\n\tstruct mbox_chan *chans;\n\tstruct device *dev = &adev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint mhu_reg[MHU_CHANS] = {\n\t\tMHU_LP_OFFSET, MHU_HP_OFFSET, MHU_SEC_OFFSET,\n\t};\n\n\tif (!of_device_is_compatible(np, \"arm,mhu-doorbell\"))\n\t\treturn -ENODEV;\n\n\terr = of_property_read_u32(np, \"#mbox-cells\", &cell_count);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read #mbox-cells in '%pOF'\\n\", np);\n\t\treturn err;\n\t}\n\n\tif (cell_count == 2) {\n\t\tmax_chans = MHU_CHAN_MAX;\n\t} else {\n\t\tdev_err(dev, \"incorrect value of #mbox-cells in '%pOF'\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tmhu = devm_kzalloc(dev, sizeof(*mhu), GFP_KERNEL);\n\tif (!mhu)\n\t\treturn -ENOMEM;\n\n\tmhu->base = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(mhu->base))\n\t\treturn PTR_ERR(mhu->base);\n\n\tchans = devm_kcalloc(dev, max_chans, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tmhu->dev = dev;\n\tmhu->mbox.dev = dev;\n\tmhu->mbox.chans = chans;\n\tmhu->mbox.num_chans = max_chans;\n\tmhu->mbox.txdone_irq = false;\n\tmhu->mbox.txdone_poll = true;\n\tmhu->mbox.txpoll_period = 1;\n\n\tmhu->mbox.of_xlate = mhu_db_mbox_xlate;\n\tamba_set_drvdata(adev, mhu);\n\n\tmhu->mbox.ops = &mhu_db_ops;\n\n\terr = devm_mbox_controller_register(dev, &mhu->mbox);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mailboxes %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < MHU_CHANS; i++) {\n\t\tint irq = mhu->mlink[i].irq = adev->irq[i];\n\n\t\tif (irq <= 0) {\n\t\t\tdev_dbg(dev, \"No IRQ found for Channel %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmhu->mlink[i].rx_reg = mhu->base + mhu_reg[i];\n\t\tmhu->mlink[i].tx_reg = mhu->mlink[i].rx_reg + TX_REG_OFFSET;\n\n\t\terr = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t\tmhu_db_mbox_rx_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, \"mhu_db_link\", mhu);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Can't claim IRQ %d\\n\", irq);\n\t\t\tmbox_controller_unregister(&mhu->mbox);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdev_info(dev, \"ARM MHU Doorbell mailbox registered\\n\");\n\treturn 0;\n}\n\nstatic struct amba_id mhu_ids[] = {\n\t{\n\t\t.id\t= 0x1bb098,\n\t\t.mask\t= 0xffffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, mhu_ids);\n\nstatic struct amba_driver arm_mhu_db_driver = {\n\t.drv = {\n\t\t.name\t= \"mhu-doorbell\",\n\t},\n\t.id_table\t= mhu_ids,\n\t.probe\t\t= mhu_db_probe,\n};\nmodule_amba_driver(arm_mhu_db_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ARM MHU Doorbell Driver\");\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}