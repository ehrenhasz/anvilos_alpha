{
  "module_name": "omap-mailbox.c",
  "hash_id": "164d3322de98c6c264b9199a69fbd366ebdce624282004f153149d7bd642202d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/omap-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/kfifo.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/omap-mailbox.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox_client.h>\n\n#include \"mailbox.h\"\n\n#define MAILBOX_REVISION\t\t0x000\n#define MAILBOX_MESSAGE(m)\t\t(0x040 + 4 * (m))\n#define MAILBOX_FIFOSTATUS(m)\t\t(0x080 + 4 * (m))\n#define MAILBOX_MSGSTATUS(m)\t\t(0x0c0 + 4 * (m))\n\n#define OMAP2_MAILBOX_IRQSTATUS(u)\t(0x100 + 8 * (u))\n#define OMAP2_MAILBOX_IRQENABLE(u)\t(0x104 + 8 * (u))\n\n#define OMAP4_MAILBOX_IRQSTATUS(u)\t(0x104 + 0x10 * (u))\n#define OMAP4_MAILBOX_IRQENABLE(u)\t(0x108 + 0x10 * (u))\n#define OMAP4_MAILBOX_IRQENABLE_CLR(u)\t(0x10c + 0x10 * (u))\n\n#define MAILBOX_IRQSTATUS(type, u)\t(type ? OMAP4_MAILBOX_IRQSTATUS(u) : \\\n\t\t\t\t\t\tOMAP2_MAILBOX_IRQSTATUS(u))\n#define MAILBOX_IRQENABLE(type, u)\t(type ? OMAP4_MAILBOX_IRQENABLE(u) : \\\n\t\t\t\t\t\tOMAP2_MAILBOX_IRQENABLE(u))\n#define MAILBOX_IRQDISABLE(type, u)\t(type ? OMAP4_MAILBOX_IRQENABLE_CLR(u) \\\n\t\t\t\t\t\t: OMAP2_MAILBOX_IRQENABLE(u))\n\n#define MAILBOX_IRQ_NEWMSG(m)\t\t(1 << (2 * (m)))\n#define MAILBOX_IRQ_NOTFULL(m)\t\t(1 << (2 * (m) + 1))\n\n \n#define MBOX_INTR_CFG_TYPE1\t\t0\n#define MBOX_INTR_CFG_TYPE2\t\t1\n\nstruct omap_mbox_fifo {\n\tunsigned long msg;\n\tunsigned long fifo_stat;\n\tunsigned long msg_stat;\n\tunsigned long irqenable;\n\tunsigned long irqstatus;\n\tunsigned long irqdisable;\n\tu32 intr_bit;\n};\n\nstruct omap_mbox_queue {\n\tspinlock_t\t\tlock;\n\tstruct kfifo\t\tfifo;\n\tstruct work_struct\twork;\n\tstruct omap_mbox\t*mbox;\n\tbool full;\n};\n\nstruct omap_mbox_match_data {\n\tu32 intr_type;\n};\n\nstruct omap_mbox_device {\n\tstruct device *dev;\n\tstruct mutex cfg_lock;\n\tvoid __iomem *mbox_base;\n\tu32 *irq_ctx;\n\tu32 num_users;\n\tu32 num_fifos;\n\tu32 intr_type;\n\tstruct omap_mbox **mboxes;\n\tstruct mbox_controller controller;\n\tstruct list_head elem;\n};\n\nstruct omap_mbox_fifo_info {\n\tint tx_id;\n\tint tx_usr;\n\tint tx_irq;\n\n\tint rx_id;\n\tint rx_usr;\n\tint rx_irq;\n\n\tconst char *name;\n\tbool send_no_irq;\n};\n\nstruct omap_mbox {\n\tconst char\t\t*name;\n\tint\t\t\tirq;\n\tstruct omap_mbox_queue\t*rxq;\n\tstruct device\t\t*dev;\n\tstruct omap_mbox_device *parent;\n\tstruct omap_mbox_fifo\ttx_fifo;\n\tstruct omap_mbox_fifo\trx_fifo;\n\tu32\t\t\tintr_type;\n\tstruct mbox_chan\t*chan;\n\tbool\t\t\tsend_no_irq;\n};\n\n \nstatic DEFINE_MUTEX(omap_mbox_devices_lock);\nstatic LIST_HEAD(omap_mbox_devices);\n\nstatic unsigned int mbox_kfifo_size = CONFIG_OMAP_MBOX_KFIFO_SIZE;\nmodule_param(mbox_kfifo_size, uint, S_IRUGO);\nMODULE_PARM_DESC(mbox_kfifo_size, \"Size of omap's mailbox kfifo (bytes)\");\n\nstatic struct omap_mbox *mbox_chan_to_omap_mbox(struct mbox_chan *chan)\n{\n\tif (!chan || !chan->con_priv)\n\t\treturn NULL;\n\n\treturn (struct omap_mbox *)chan->con_priv;\n}\n\nstatic inline\nunsigned int mbox_read_reg(struct omap_mbox_device *mdev, size_t ofs)\n{\n\treturn __raw_readl(mdev->mbox_base + ofs);\n}\n\nstatic inline\nvoid mbox_write_reg(struct omap_mbox_device *mdev, u32 val, size_t ofs)\n{\n\t__raw_writel(val, mdev->mbox_base + ofs);\n}\n\n \nstatic u32 mbox_fifo_read(struct omap_mbox *mbox)\n{\n\tstruct omap_mbox_fifo *fifo = &mbox->rx_fifo;\n\n\treturn mbox_read_reg(mbox->parent, fifo->msg);\n}\n\nstatic void mbox_fifo_write(struct omap_mbox *mbox, u32 msg)\n{\n\tstruct omap_mbox_fifo *fifo = &mbox->tx_fifo;\n\n\tmbox_write_reg(mbox->parent, msg, fifo->msg);\n}\n\nstatic int mbox_fifo_empty(struct omap_mbox *mbox)\n{\n\tstruct omap_mbox_fifo *fifo = &mbox->rx_fifo;\n\n\treturn (mbox_read_reg(mbox->parent, fifo->msg_stat) == 0);\n}\n\nstatic int mbox_fifo_full(struct omap_mbox *mbox)\n{\n\tstruct omap_mbox_fifo *fifo = &mbox->tx_fifo;\n\n\treturn mbox_read_reg(mbox->parent, fifo->fifo_stat);\n}\n\n \nstatic void ack_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\n{\n\tstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\n\t\t\t\t&mbox->tx_fifo : &mbox->rx_fifo;\n\tu32 bit = fifo->intr_bit;\n\tu32 irqstatus = fifo->irqstatus;\n\n\tmbox_write_reg(mbox->parent, bit, irqstatus);\n\n\t \n\tmbox_read_reg(mbox->parent, irqstatus);\n}\n\nstatic int is_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\n{\n\tstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\n\t\t\t\t&mbox->tx_fifo : &mbox->rx_fifo;\n\tu32 bit = fifo->intr_bit;\n\tu32 irqenable = fifo->irqenable;\n\tu32 irqstatus = fifo->irqstatus;\n\n\tu32 enable = mbox_read_reg(mbox->parent, irqenable);\n\tu32 status = mbox_read_reg(mbox->parent, irqstatus);\n\n\treturn (int)(enable & status & bit);\n}\n\nstatic void _omap_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\n{\n\tu32 l;\n\tstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\n\t\t\t\t&mbox->tx_fifo : &mbox->rx_fifo;\n\tu32 bit = fifo->intr_bit;\n\tu32 irqenable = fifo->irqenable;\n\n\tl = mbox_read_reg(mbox->parent, irqenable);\n\tl |= bit;\n\tmbox_write_reg(mbox->parent, l, irqenable);\n}\n\nstatic void _omap_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\n{\n\tstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\n\t\t\t\t&mbox->tx_fifo : &mbox->rx_fifo;\n\tu32 bit = fifo->intr_bit;\n\tu32 irqdisable = fifo->irqdisable;\n\n\t \n\tif (!mbox->intr_type)\n\t\tbit = mbox_read_reg(mbox->parent, irqdisable) & ~bit;\n\n\tmbox_write_reg(mbox->parent, bit, irqdisable);\n}\n\nvoid omap_mbox_enable_irq(struct mbox_chan *chan, omap_mbox_irq_t irq)\n{\n\tstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\n\n\tif (WARN_ON(!mbox))\n\t\treturn;\n\n\t_omap_mbox_enable_irq(mbox, irq);\n}\nEXPORT_SYMBOL(omap_mbox_enable_irq);\n\nvoid omap_mbox_disable_irq(struct mbox_chan *chan, omap_mbox_irq_t irq)\n{\n\tstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\n\n\tif (WARN_ON(!mbox))\n\t\treturn;\n\n\t_omap_mbox_disable_irq(mbox, irq);\n}\nEXPORT_SYMBOL(omap_mbox_disable_irq);\n\n \nstatic void mbox_rx_work(struct work_struct *work)\n{\n\tstruct omap_mbox_queue *mq =\n\t\t\tcontainer_of(work, struct omap_mbox_queue, work);\n\tmbox_msg_t data;\n\tu32 msg;\n\tint len;\n\n\twhile (kfifo_len(&mq->fifo) >= sizeof(msg)) {\n\t\tlen = kfifo_out(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\n\t\tWARN_ON(len != sizeof(msg));\n\t\tdata = msg;\n\n\t\tmbox_chan_received_data(mq->mbox->chan, (void *)data);\n\t\tspin_lock_irq(&mq->lock);\n\t\tif (mq->full) {\n\t\t\tmq->full = false;\n\t\t\t_omap_mbox_enable_irq(mq->mbox, IRQ_RX);\n\t\t}\n\t\tspin_unlock_irq(&mq->lock);\n\t}\n}\n\n \nstatic void __mbox_tx_interrupt(struct omap_mbox *mbox)\n{\n\t_omap_mbox_disable_irq(mbox, IRQ_TX);\n\tack_mbox_irq(mbox, IRQ_TX);\n\tmbox_chan_txdone(mbox->chan, 0);\n}\n\nstatic void __mbox_rx_interrupt(struct omap_mbox *mbox)\n{\n\tstruct omap_mbox_queue *mq = mbox->rxq;\n\tu32 msg;\n\tint len;\n\n\twhile (!mbox_fifo_empty(mbox)) {\n\t\tif (unlikely(kfifo_avail(&mq->fifo) < sizeof(msg))) {\n\t\t\t_omap_mbox_disable_irq(mbox, IRQ_RX);\n\t\t\tmq->full = true;\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tmsg = mbox_fifo_read(mbox);\n\n\t\tlen = kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\n\t\tWARN_ON(len != sizeof(msg));\n\t}\n\n\t \n\tack_mbox_irq(mbox, IRQ_RX);\nnomem:\n\tschedule_work(&mbox->rxq->work);\n}\n\nstatic irqreturn_t mbox_interrupt(int irq, void *p)\n{\n\tstruct omap_mbox *mbox = p;\n\n\tif (is_mbox_irq(mbox, IRQ_TX))\n\t\t__mbox_tx_interrupt(mbox);\n\n\tif (is_mbox_irq(mbox, IRQ_RX))\n\t\t__mbox_rx_interrupt(mbox);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct omap_mbox_queue *mbox_queue_alloc(struct omap_mbox *mbox,\n\t\t\t\t\tvoid (*work)(struct work_struct *))\n{\n\tstruct omap_mbox_queue *mq;\n\n\tif (!work)\n\t\treturn NULL;\n\n\tmq = kzalloc(sizeof(*mq), GFP_KERNEL);\n\tif (!mq)\n\t\treturn NULL;\n\n\tspin_lock_init(&mq->lock);\n\n\tif (kfifo_alloc(&mq->fifo, mbox_kfifo_size, GFP_KERNEL))\n\t\tgoto error;\n\n\tINIT_WORK(&mq->work, work);\n\treturn mq;\n\nerror:\n\tkfree(mq);\n\treturn NULL;\n}\n\nstatic void mbox_queue_free(struct omap_mbox_queue *q)\n{\n\tkfifo_free(&q->fifo);\n\tkfree(q);\n}\n\nstatic int omap_mbox_startup(struct omap_mbox *mbox)\n{\n\tint ret = 0;\n\tstruct omap_mbox_queue *mq;\n\n\tmq = mbox_queue_alloc(mbox, mbox_rx_work);\n\tif (!mq)\n\t\treturn -ENOMEM;\n\tmbox->rxq = mq;\n\tmq->mbox = mbox;\n\n\tret = request_irq(mbox->irq, mbox_interrupt, IRQF_SHARED,\n\t\t\t  mbox->name, mbox);\n\tif (unlikely(ret)) {\n\t\tpr_err(\"failed to register mailbox interrupt:%d\\n\", ret);\n\t\tgoto fail_request_irq;\n\t}\n\n\tif (mbox->send_no_irq)\n\t\tmbox->chan->txdone_method = TXDONE_BY_ACK;\n\n\t_omap_mbox_enable_irq(mbox, IRQ_RX);\n\n\treturn 0;\n\nfail_request_irq:\n\tmbox_queue_free(mbox->rxq);\n\treturn ret;\n}\n\nstatic void omap_mbox_fini(struct omap_mbox *mbox)\n{\n\t_omap_mbox_disable_irq(mbox, IRQ_RX);\n\tfree_irq(mbox->irq, mbox);\n\tflush_work(&mbox->rxq->work);\n\tmbox_queue_free(mbox->rxq);\n}\n\nstatic struct omap_mbox *omap_mbox_device_find(struct omap_mbox_device *mdev,\n\t\t\t\t\t       const char *mbox_name)\n{\n\tstruct omap_mbox *_mbox, *mbox = NULL;\n\tstruct omap_mbox **mboxes = mdev->mboxes;\n\tint i;\n\n\tif (!mboxes)\n\t\treturn NULL;\n\n\tfor (i = 0; (_mbox = mboxes[i]); i++) {\n\t\tif (!strcmp(_mbox->name, mbox_name)) {\n\t\t\tmbox = _mbox;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mbox;\n}\n\nstruct mbox_chan *omap_mbox_request_channel(struct mbox_client *cl,\n\t\t\t\t\t    const char *chan_name)\n{\n\tstruct device *dev = cl->dev;\n\tstruct omap_mbox *mbox = NULL;\n\tstruct omap_mbox_device *mdev;\n\tint ret;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (dev->of_node) {\n\t\tpr_err(\"%s: please use mbox_request_channel(), this API is supported only for OMAP non-DT usage\\n\",\n\t\t       __func__);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tmutex_lock(&omap_mbox_devices_lock);\n\tlist_for_each_entry(mdev, &omap_mbox_devices, elem) {\n\t\tmbox = omap_mbox_device_find(mdev, chan_name);\n\t\tif (mbox)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&omap_mbox_devices_lock);\n\n\tif (!mbox || !mbox->chan)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = mbox_bind_client(mbox->chan, cl);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn mbox->chan;\n}\nEXPORT_SYMBOL(omap_mbox_request_channel);\n\nstatic struct class omap_mbox_class = { .name = \"mbox\", };\n\nstatic int omap_mbox_register(struct omap_mbox_device *mdev)\n{\n\tint ret;\n\tint i;\n\tstruct omap_mbox **mboxes;\n\n\tif (!mdev || !mdev->mboxes)\n\t\treturn -EINVAL;\n\n\tmboxes = mdev->mboxes;\n\tfor (i = 0; mboxes[i]; i++) {\n\t\tstruct omap_mbox *mbox = mboxes[i];\n\n\t\tmbox->dev = device_create(&omap_mbox_class, mdev->dev,\n\t\t\t\t\t0, mbox, \"%s\", mbox->name);\n\t\tif (IS_ERR(mbox->dev)) {\n\t\t\tret = PTR_ERR(mbox->dev);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tmutex_lock(&omap_mbox_devices_lock);\n\tlist_add(&mdev->elem, &omap_mbox_devices);\n\tmutex_unlock(&omap_mbox_devices_lock);\n\n\tret = devm_mbox_controller_register(mdev->dev, &mdev->controller);\n\nerr_out:\n\tif (ret) {\n\t\twhile (i--)\n\t\t\tdevice_unregister(mboxes[i]->dev);\n\t}\n\treturn ret;\n}\n\nstatic int omap_mbox_unregister(struct omap_mbox_device *mdev)\n{\n\tint i;\n\tstruct omap_mbox **mboxes;\n\n\tif (!mdev || !mdev->mboxes)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&omap_mbox_devices_lock);\n\tlist_del(&mdev->elem);\n\tmutex_unlock(&omap_mbox_devices_lock);\n\n\tmboxes = mdev->mboxes;\n\tfor (i = 0; mboxes[i]; i++)\n\t\tdevice_unregister(mboxes[i]->dev);\n\treturn 0;\n}\n\nstatic int omap_mbox_chan_startup(struct mbox_chan *chan)\n{\n\tstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\n\tstruct omap_mbox_device *mdev = mbox->parent;\n\tint ret = 0;\n\n\tmutex_lock(&mdev->cfg_lock);\n\tpm_runtime_get_sync(mdev->dev);\n\tret = omap_mbox_startup(mbox);\n\tif (ret)\n\t\tpm_runtime_put_sync(mdev->dev);\n\tmutex_unlock(&mdev->cfg_lock);\n\treturn ret;\n}\n\nstatic void omap_mbox_chan_shutdown(struct mbox_chan *chan)\n{\n\tstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\n\tstruct omap_mbox_device *mdev = mbox->parent;\n\n\tmutex_lock(&mdev->cfg_lock);\n\tomap_mbox_fini(mbox);\n\tpm_runtime_put_sync(mdev->dev);\n\tmutex_unlock(&mdev->cfg_lock);\n}\n\nstatic int omap_mbox_chan_send_noirq(struct omap_mbox *mbox, u32 msg)\n{\n\tint ret = -EBUSY;\n\n\tif (!mbox_fifo_full(mbox)) {\n\t\t_omap_mbox_enable_irq(mbox, IRQ_RX);\n\t\tmbox_fifo_write(mbox, msg);\n\t\tret = 0;\n\t\t_omap_mbox_disable_irq(mbox, IRQ_RX);\n\n\t\t \n\t\tmbox_fifo_read(mbox);\n\t\tack_mbox_irq(mbox, IRQ_RX);\n\t}\n\n\treturn ret;\n}\n\nstatic int omap_mbox_chan_send(struct omap_mbox *mbox, u32 msg)\n{\n\tint ret = -EBUSY;\n\n\tif (!mbox_fifo_full(mbox)) {\n\t\tmbox_fifo_write(mbox, msg);\n\t\tret = 0;\n\t}\n\n\t \n\t_omap_mbox_enable_irq(mbox, IRQ_TX);\n\treturn ret;\n}\n\nstatic int omap_mbox_chan_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\n\tint ret;\n\tu32 msg = omap_mbox_message(data);\n\n\tif (!mbox)\n\t\treturn -EINVAL;\n\n\tif (mbox->send_no_irq)\n\t\tret = omap_mbox_chan_send_noirq(mbox, msg);\n\telse\n\t\tret = omap_mbox_chan_send(mbox, msg);\n\n\treturn ret;\n}\n\nstatic const struct mbox_chan_ops omap_mbox_chan_ops = {\n\t.startup        = omap_mbox_chan_startup,\n\t.send_data      = omap_mbox_chan_send_data,\n\t.shutdown       = omap_mbox_chan_shutdown,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_mbox_suspend(struct device *dev)\n{\n\tstruct omap_mbox_device *mdev = dev_get_drvdata(dev);\n\tu32 usr, fifo, reg;\n\n\tif (pm_runtime_status_suspended(dev))\n\t\treturn 0;\n\n\tfor (fifo = 0; fifo < mdev->num_fifos; fifo++) {\n\t\tif (mbox_read_reg(mdev, MAILBOX_MSGSTATUS(fifo))) {\n\t\t\tdev_err(mdev->dev, \"fifo %d has unexpected unread messages\\n\",\n\t\t\t\tfifo);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tfor (usr = 0; usr < mdev->num_users; usr++) {\n\t\treg = MAILBOX_IRQENABLE(mdev->intr_type, usr);\n\t\tmdev->irq_ctx[usr] = mbox_read_reg(mdev, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_mbox_resume(struct device *dev)\n{\n\tstruct omap_mbox_device *mdev = dev_get_drvdata(dev);\n\tu32 usr, reg;\n\n\tif (pm_runtime_status_suspended(dev))\n\t\treturn 0;\n\n\tfor (usr = 0; usr < mdev->num_users; usr++) {\n\t\treg = MAILBOX_IRQENABLE(mdev->intr_type, usr);\n\t\tmbox_write_reg(mdev, mdev->irq_ctx[usr], reg);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops omap_mbox_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(omap_mbox_suspend, omap_mbox_resume)\n};\n\nstatic const struct omap_mbox_match_data omap2_data = { MBOX_INTR_CFG_TYPE1 };\nstatic const struct omap_mbox_match_data omap4_data = { MBOX_INTR_CFG_TYPE2 };\n\nstatic const struct of_device_id omap_mailbox_of_match[] = {\n\t{\n\t\t.compatible\t= \"ti,omap2-mailbox\",\n\t\t.data\t\t= &omap2_data,\n\t},\n\t{\n\t\t.compatible\t= \"ti,omap3-mailbox\",\n\t\t.data\t\t= &omap2_data,\n\t},\n\t{\n\t\t.compatible\t= \"ti,omap4-mailbox\",\n\t\t.data\t\t= &omap4_data,\n\t},\n\t{\n\t\t.compatible\t= \"ti,am654-mailbox\",\n\t\t.data\t\t= &omap4_data,\n\t},\n\t{\n\t\t.compatible\t= \"ti,am64-mailbox\",\n\t\t.data\t\t= &omap4_data,\n\t},\n\t{\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, omap_mailbox_of_match);\n\nstatic struct mbox_chan *omap_mbox_of_xlate(struct mbox_controller *controller,\n\t\t\t\t\t    const struct of_phandle_args *sp)\n{\n\tphandle phandle = sp->args[0];\n\tstruct device_node *node;\n\tstruct omap_mbox_device *mdev;\n\tstruct omap_mbox *mbox;\n\n\tmdev = container_of(controller, struct omap_mbox_device, controller);\n\tif (WARN_ON(!mdev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnode = of_find_node_by_phandle(phandle);\n\tif (!node) {\n\t\tpr_err(\"%s: could not find node phandle 0x%x\\n\",\n\t\t       __func__, phandle);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tmbox = omap_mbox_device_find(mdev, node->name);\n\tof_node_put(node);\n\treturn mbox ? mbox->chan : ERR_PTR(-ENOENT);\n}\n\nstatic int omap_mbox_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct mbox_chan *chnls;\n\tstruct omap_mbox **list, *mbox, *mboxblk;\n\tstruct omap_mbox_fifo_info *finfo, *finfoblk;\n\tstruct omap_mbox_device *mdev;\n\tstruct omap_mbox_fifo *fifo;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *child;\n\tconst struct omap_mbox_match_data *match_data;\n\tu32 intr_type, info_count;\n\tu32 num_users, num_fifos;\n\tu32 tmp[3];\n\tu32 l;\n\tint i;\n\n\tif (!node) {\n\t\tpr_err(\"%s: only DT-based devices are supported\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmatch_data = of_device_get_match_data(&pdev->dev);\n\tif (!match_data)\n\t\treturn -ENODEV;\n\tintr_type = match_data->intr_type;\n\n\tif (of_property_read_u32(node, \"ti,mbox-num-users\", &num_users))\n\t\treturn -ENODEV;\n\n\tif (of_property_read_u32(node, \"ti,mbox-num-fifos\", &num_fifos))\n\t\treturn -ENODEV;\n\n\tinfo_count = of_get_available_child_count(node);\n\tif (!info_count) {\n\t\tdev_err(&pdev->dev, \"no available mbox devices found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfinfoblk = devm_kcalloc(&pdev->dev, info_count, sizeof(*finfoblk),\n\t\t\t\tGFP_KERNEL);\n\tif (!finfoblk)\n\t\treturn -ENOMEM;\n\n\tfinfo = finfoblk;\n\tchild = NULL;\n\tfor (i = 0; i < info_count; i++, finfo++) {\n\t\tchild = of_get_next_available_child(node, child);\n\t\tret = of_property_read_u32_array(child, \"ti,mbox-tx\", tmp,\n\t\t\t\t\t\t ARRAY_SIZE(tmp));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfinfo->tx_id = tmp[0];\n\t\tfinfo->tx_irq = tmp[1];\n\t\tfinfo->tx_usr = tmp[2];\n\n\t\tret = of_property_read_u32_array(child, \"ti,mbox-rx\", tmp,\n\t\t\t\t\t\t ARRAY_SIZE(tmp));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfinfo->rx_id = tmp[0];\n\t\tfinfo->rx_irq = tmp[1];\n\t\tfinfo->rx_usr = tmp[2];\n\n\t\tfinfo->name = child->name;\n\n\t\tfinfo->send_no_irq = of_property_read_bool(child, \"ti,mbox-send-noirq\");\n\n\t\tif (finfo->tx_id >= num_fifos || finfo->rx_id >= num_fifos ||\n\t\t    finfo->tx_usr >= num_users || finfo->rx_usr >= num_users)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmdev = devm_kzalloc(&pdev->dev, sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->mbox_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->mbox_base))\n\t\treturn PTR_ERR(mdev->mbox_base);\n\n\tmdev->irq_ctx = devm_kcalloc(&pdev->dev, num_users, sizeof(u32),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mdev->irq_ctx)\n\t\treturn -ENOMEM;\n\n\t \n\tlist = devm_kcalloc(&pdev->dev, info_count + 1, sizeof(*list),\n\t\t\t    GFP_KERNEL);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tchnls = devm_kcalloc(&pdev->dev, info_count + 1, sizeof(*chnls),\n\t\t\t     GFP_KERNEL);\n\tif (!chnls)\n\t\treturn -ENOMEM;\n\n\tmboxblk = devm_kcalloc(&pdev->dev, info_count, sizeof(*mbox),\n\t\t\t       GFP_KERNEL);\n\tif (!mboxblk)\n\t\treturn -ENOMEM;\n\n\tmbox = mboxblk;\n\tfinfo = finfoblk;\n\tfor (i = 0; i < info_count; i++, finfo++) {\n\t\tfifo = &mbox->tx_fifo;\n\t\tfifo->msg = MAILBOX_MESSAGE(finfo->tx_id);\n\t\tfifo->fifo_stat = MAILBOX_FIFOSTATUS(finfo->tx_id);\n\t\tfifo->intr_bit = MAILBOX_IRQ_NOTFULL(finfo->tx_id);\n\t\tfifo->irqenable = MAILBOX_IRQENABLE(intr_type, finfo->tx_usr);\n\t\tfifo->irqstatus = MAILBOX_IRQSTATUS(intr_type, finfo->tx_usr);\n\t\tfifo->irqdisable = MAILBOX_IRQDISABLE(intr_type, finfo->tx_usr);\n\n\t\tfifo = &mbox->rx_fifo;\n\t\tfifo->msg = MAILBOX_MESSAGE(finfo->rx_id);\n\t\tfifo->msg_stat =  MAILBOX_MSGSTATUS(finfo->rx_id);\n\t\tfifo->intr_bit = MAILBOX_IRQ_NEWMSG(finfo->rx_id);\n\t\tfifo->irqenable = MAILBOX_IRQENABLE(intr_type, finfo->rx_usr);\n\t\tfifo->irqstatus = MAILBOX_IRQSTATUS(intr_type, finfo->rx_usr);\n\t\tfifo->irqdisable = MAILBOX_IRQDISABLE(intr_type, finfo->rx_usr);\n\n\t\tmbox->send_no_irq = finfo->send_no_irq;\n\t\tmbox->intr_type = intr_type;\n\n\t\tmbox->parent = mdev;\n\t\tmbox->name = finfo->name;\n\t\tmbox->irq = platform_get_irq(pdev, finfo->tx_irq);\n\t\tif (mbox->irq < 0)\n\t\t\treturn mbox->irq;\n\t\tmbox->chan = &chnls[i];\n\t\tchnls[i].con_priv = mbox;\n\t\tlist[i] = mbox++;\n\t}\n\n\tmutex_init(&mdev->cfg_lock);\n\tmdev->dev = &pdev->dev;\n\tmdev->num_users = num_users;\n\tmdev->num_fifos = num_fifos;\n\tmdev->intr_type = intr_type;\n\tmdev->mboxes = list;\n\n\t \n\tmdev->controller.txdone_irq = true;\n\tmdev->controller.dev = mdev->dev;\n\tmdev->controller.ops = &omap_mbox_chan_ops;\n\tmdev->controller.chans = chnls;\n\tmdev->controller.num_chans = info_count;\n\tmdev->controller.of_xlate = omap_mbox_of_xlate;\n\tret = omap_mbox_register(mdev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, mdev);\n\tpm_runtime_enable(mdev->dev);\n\n\tret = pm_runtime_resume_and_get(mdev->dev);\n\tif (ret < 0)\n\t\tgoto unregister;\n\n\t \n\tl = mbox_read_reg(mdev, MAILBOX_REVISION);\n\tdev_info(mdev->dev, \"omap mailbox rev 0x%x\\n\", l);\n\n\tret = pm_runtime_put_sync(mdev->dev);\n\tif (ret < 0 && ret != -ENOSYS)\n\t\tgoto unregister;\n\n\tdevm_kfree(&pdev->dev, finfoblk);\n\treturn 0;\n\nunregister:\n\tpm_runtime_disable(mdev->dev);\n\tomap_mbox_unregister(mdev);\n\treturn ret;\n}\n\nstatic int omap_mbox_remove(struct platform_device *pdev)\n{\n\tstruct omap_mbox_device *mdev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(mdev->dev);\n\tomap_mbox_unregister(mdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver omap_mbox_driver = {\n\t.probe\t= omap_mbox_probe,\n\t.remove\t= omap_mbox_remove,\n\t.driver\t= {\n\t\t.name = \"omap-mailbox\",\n\t\t.pm = &omap_mbox_pm_ops,\n\t\t.of_match_table = of_match_ptr(omap_mailbox_of_match),\n\t},\n};\n\nstatic int __init omap_mbox_init(void)\n{\n\tint err;\n\n\terr = class_register(&omap_mbox_class);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmbox_kfifo_size = ALIGN(mbox_kfifo_size, sizeof(u32));\n\tmbox_kfifo_size = max_t(unsigned int, mbox_kfifo_size, sizeof(u32));\n\n\terr = platform_driver_register(&omap_mbox_driver);\n\tif (err)\n\t\tclass_unregister(&omap_mbox_class);\n\n\treturn err;\n}\nsubsys_initcall(omap_mbox_init);\n\nstatic void __exit omap_mbox_exit(void)\n{\n\tplatform_driver_unregister(&omap_mbox_driver);\n\tclass_unregister(&omap_mbox_class);\n}\nmodule_exit(omap_mbox_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"omap mailbox: interrupt driven messaging\");\nMODULE_AUTHOR(\"Toshihiro Kobayashi\");\nMODULE_AUTHOR(\"Hiroshi DOYU\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}