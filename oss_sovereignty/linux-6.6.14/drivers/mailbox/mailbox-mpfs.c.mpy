{
  "module_name": "mailbox-mpfs.c",
  "hash_id": "19b54e099154920bd5b93d0b61722d6cb43f9a19499042bebd8a538ca013a772",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/mailbox-mpfs.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/mailbox_controller.h>\n#include <soc/microchip/mpfs.h>\n\n#define SERVICES_CR_OFFSET\t\t0x50u\n#define SERVICES_SR_OFFSET\t\t0x54u\n#define MAILBOX_REG_OFFSET\t\t0x800u\n#define MSS_SYS_MAILBOX_DATA_OFFSET\t0u\n#define SCB_MASK_WIDTH\t\t\t16u\n\n \n\n#define SCB_CTRL_REQ (0)\n#define SCB_CTRL_REQ_MASK BIT(SCB_CTRL_REQ)\n\n#define SCB_CTRL_BUSY (1)\n#define SCB_CTRL_BUSY_MASK BIT(SCB_CTRL_BUSY)\n\n#define SCB_CTRL_ABORT (2)\n#define SCB_CTRL_ABORT_MASK BIT(SCB_CTRL_ABORT)\n\n#define SCB_CTRL_NOTIFY (3)\n#define SCB_CTRL_NOTIFY_MASK BIT(SCB_CTRL_NOTIFY)\n\n#define SCB_CTRL_POS (16)\n#define SCB_CTRL_MASK GENMASK(SCB_CTRL_POS + SCB_MASK_WIDTH - 1, SCB_CTRL_POS)\n\n \n\n#define SCB_STATUS_REQ (0)\n#define SCB_STATUS_REQ_MASK BIT(SCB_STATUS_REQ)\n\n#define SCB_STATUS_BUSY (1)\n#define SCB_STATUS_BUSY_MASK BIT(SCB_STATUS_BUSY)\n\n#define SCB_STATUS_ABORT (2)\n#define SCB_STATUS_ABORT_MASK BIT(SCB_STATUS_ABORT)\n\n#define SCB_STATUS_NOTIFY (3)\n#define SCB_STATUS_NOTIFY_MASK BIT(SCB_STATUS_NOTIFY)\n\n#define SCB_STATUS_POS (16)\n#define SCB_STATUS_MASK GENMASK(SCB_STATUS_POS + SCB_MASK_WIDTH - 1, SCB_STATUS_POS)\n\nstruct mpfs_mbox {\n\tstruct mbox_controller controller;\n\tstruct device *dev;\n\tint irq;\n\tvoid __iomem *ctrl_base;\n\tvoid __iomem *mbox_base;\n\tvoid __iomem *int_reg;\n\tstruct mbox_chan chans[1];\n\tstruct mpfs_mss_response *response;\n\tu16 resp_offset;\n};\n\nstatic bool mpfs_mbox_busy(struct mpfs_mbox *mbox)\n{\n\tu32 status;\n\n\tstatus = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);\n\n\treturn status & SCB_STATUS_BUSY_MASK;\n}\n\nstatic bool mpfs_mbox_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\tstruct mpfs_mss_response *response = mbox->response;\n\tu32 val;\n\n\tif (mpfs_mbox_busy(mbox))\n\t\treturn false;\n\n\t \n\tval = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);\n\tresponse->resp_status = (val & SCB_STATUS_MASK) >> SCB_STATUS_POS;\n\n\treturn true;\n}\n\nstatic int mpfs_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\tstruct mpfs_mss_msg *msg = data;\n\tu32 tx_trigger;\n\tu16 opt_sel;\n\tu32 val = 0u;\n\n\tmbox->response = msg->response;\n\tmbox->resp_offset = msg->resp_offset;\n\n\tif (mpfs_mbox_busy(mbox))\n\t\treturn -EBUSY;\n\n\tif (msg->cmd_data_size) {\n\t\tu32 index;\n\t\tu8 extra_bits = msg->cmd_data_size & 3;\n\t\tu32 *word_buf = (u32 *)msg->cmd_data;\n\n\t\tfor (index = 0; index < (msg->cmd_data_size / 4); index++)\n\t\t\twritel_relaxed(word_buf[index],\n\t\t\t\t       mbox->mbox_base + msg->mbox_offset + index * 0x4);\n\t\tif (extra_bits) {\n\t\t\tu8 i;\n\t\t\tu8 byte_off = ALIGN_DOWN(msg->cmd_data_size, 4);\n\t\t\tu8 *byte_buf = msg->cmd_data + byte_off;\n\n\t\t\tval = readl_relaxed(mbox->mbox_base + msg->mbox_offset + index * 0x4);\n\n\t\t\tfor (i = 0u; i < extra_bits; i++) {\n\t\t\t\tval &= ~(0xffu << (i * 8u));\n\t\t\t\tval |= (byte_buf[i] << (i * 8u));\n\t\t\t}\n\n\t\t\twritel_relaxed(val, mbox->mbox_base + msg->mbox_offset + index * 0x4);\n\t\t}\n\t}\n\n\topt_sel = ((msg->mbox_offset << 7u) | (msg->cmd_opcode & 0x7fu));\n\n\ttx_trigger = (opt_sel << SCB_CTRL_POS) & SCB_CTRL_MASK;\n\ttx_trigger |= SCB_CTRL_REQ_MASK | SCB_STATUS_NOTIFY_MASK;\n\twritel_relaxed(tx_trigger, mbox->ctrl_base + SERVICES_CR_OFFSET);\n\n\treturn 0;\n}\n\nstatic void mpfs_mbox_rx_data(struct mbox_chan *chan)\n{\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\tstruct mpfs_mss_response *response = mbox->response;\n\tu16 num_words = ALIGN((response->resp_size), (4)) / 4U;\n\tu32 i;\n\n\tif (!response->resp_msg) {\n\t\tdev_err(mbox->dev, \"failed to assign memory for response %d\\n\", -ENOMEM);\n\t\treturn;\n\t}\n\n\t \n\tif (mpfs_mbox_busy(mbox)) {\n\t\tdev_err(mbox->dev, \"got an interrupt but system controller is busy\\n\");\n\t\tresponse->resp_status = 0xDEAD;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_words; i++) {\n\t\tresponse->resp_msg[i] =\n\t\t\treadl_relaxed(mbox->mbox_base\n\t\t\t\t      + mbox->resp_offset + i * 0x4);\n\t}\n\n\tmbox_chan_received_data(chan, response);\n}\n\nstatic irqreturn_t mpfs_mbox_inbox_isr(int irq, void *data)\n{\n\tstruct mbox_chan *chan = data;\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\n\twritel_relaxed(0, mbox->int_reg);\n\n\tmpfs_mbox_rx_data(chan);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mpfs_mbox_startup(struct mbox_chan *chan)\n{\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\tint ret = 0;\n\n\tif (!mbox)\n\t\treturn -EINVAL;\n\n\tret = devm_request_irq(mbox->dev, mbox->irq, mpfs_mbox_inbox_isr, 0, \"mpfs-mailbox\", chan);\n\tif (ret)\n\t\tdev_err(mbox->dev, \"failed to register mailbox interrupt:%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mpfs_mbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;\n\n\tdevm_free_irq(mbox->dev, mbox->irq, chan);\n}\n\nstatic const struct mbox_chan_ops mpfs_mbox_ops = {\n\t.send_data = mpfs_mbox_send_data,\n\t.startup = mpfs_mbox_startup,\n\t.shutdown = mpfs_mbox_shutdown,\n\t.last_tx_done = mpfs_mbox_last_tx_done,\n};\n\nstatic int mpfs_mbox_probe(struct platform_device *pdev)\n{\n\tstruct mpfs_mbox *mbox;\n\tstruct resource *regs;\n\tint ret;\n\n\tmbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tmbox->ctrl_base = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(mbox->ctrl_base))\n\t\treturn PTR_ERR(mbox->ctrl_base);\n\n\tmbox->int_reg = devm_platform_get_and_ioremap_resource(pdev, 1, &regs);\n\tif (IS_ERR(mbox->int_reg))\n\t\treturn PTR_ERR(mbox->int_reg);\n\n\tmbox->mbox_base = devm_platform_get_and_ioremap_resource(pdev, 2, &regs);\n\tif (IS_ERR(mbox->mbox_base)) \n\t\tmbox->mbox_base = mbox->ctrl_base + MAILBOX_REG_OFFSET;\n\n\tmbox->irq = platform_get_irq(pdev, 0);\n\tif (mbox->irq < 0)\n\t\treturn mbox->irq;\n\n\tmbox->dev = &pdev->dev;\n\n\tmbox->chans[0].con_priv = mbox;\n\tmbox->controller.dev = mbox->dev;\n\tmbox->controller.num_chans = 1;\n\tmbox->controller.chans = mbox->chans;\n\tmbox->controller.ops = &mpfs_mbox_ops;\n\tmbox->controller.txdone_poll = true;\n\tmbox->controller.txpoll_period = 10u;\n\n\tret = devm_mbox_controller_register(&pdev->dev, &mbox->controller);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Registering MPFS mailbox controller failed\\n\");\n\t\treturn ret;\n\t}\n\tdev_info(&pdev->dev, \"Registered MPFS mailbox controller driver\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mpfs_mbox_of_match[] = {\n\t{.compatible = \"microchip,mpfs-mailbox\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpfs_mbox_of_match);\n\nstatic struct platform_driver mpfs_mbox_driver = {\n\t.driver = {\n\t\t.name = \"mpfs-mailbox\",\n\t\t.of_match_table = mpfs_mbox_of_match,\n\t},\n\t.probe = mpfs_mbox_probe,\n};\nmodule_platform_driver(mpfs_mbox_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_DESCRIPTION(\"MPFS mailbox controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}