{
  "module_name": "zynqmp-ipi-mailbox.c",
  "hash_id": "935b977af05e57a9a4b3e69c22df7ab4c6e10ebbf862dbc41468257248e180a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/zynqmp-ipi-mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/mailbox/zynqmp-ipi-message.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n \n#define IPI_ID_ANY 0xFFUL\n\n \n#define USE_SMC 0\n#define USE_HVC 1\n\n \n#define SMC_IPI_MAILBOX_OPEN\t\t0x82001000U\n#define SMC_IPI_MAILBOX_RELEASE\t\t0x82001001U\n#define SMC_IPI_MAILBOX_STATUS_ENQUIRY\t0x82001002U\n#define SMC_IPI_MAILBOX_NOTIFY\t\t0x82001003U\n#define SMC_IPI_MAILBOX_ACK\t\t0x82001004U\n#define SMC_IPI_MAILBOX_ENABLE_IRQ\t0x82001005U\n#define SMC_IPI_MAILBOX_DISABLE_IRQ\t0x82001006U\n\n \n#define IPI_SMC_ENQUIRY_DIRQ_MASK\t0x00000001UL  \n#define IPI_SMC_ACK_EIRQ_MASK\t\t0x00000001UL  \n\n \n#define IPI_MB_STATUS_IDLE\t\t0\n#define IPI_MB_STATUS_SEND_PENDING\t1\n#define IPI_MB_STATUS_RECV_PENDING\t2\n\n#define IPI_MB_CHNL_TX\t0  \n#define IPI_MB_CHNL_RX\t1  \n\n \nstruct zynqmp_ipi_mchan {\n\tint is_opened;\n\tvoid __iomem *req_buf;\n\tvoid __iomem *resp_buf;\n\tvoid *rx_buf;\n\tsize_t req_buf_size;\n\tsize_t resp_buf_size;\n\tunsigned int chan_type;\n};\n\n \nstruct zynqmp_ipi_mbox {\n\tstruct zynqmp_ipi_pdata *pdata;\n\tstruct device dev;\n\tu32 remote_id;\n\tstruct mbox_controller mbox;\n\tstruct zynqmp_ipi_mchan mchans[2];\n};\n\n \nstruct zynqmp_ipi_pdata {\n\tstruct device *dev;\n\tint irq;\n\tunsigned int method;\n\tu32 local_id;\n\tint num_mboxes;\n\tstruct zynqmp_ipi_mbox ipi_mboxes[];\n};\n\nstatic struct device_driver zynqmp_ipi_mbox_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"zynqmp-ipi-mbox\",\n};\n\nstatic void zynqmp_ipi_fw_call(struct zynqmp_ipi_mbox *ipi_mbox,\n\t\t\t       unsigned long a0, unsigned long a3,\n\t\t\t       struct arm_smccc_res *res)\n{\n\tstruct zynqmp_ipi_pdata *pdata = ipi_mbox->pdata;\n\tunsigned long a1, a2;\n\n\ta1 = pdata->local_id;\n\ta2 = ipi_mbox->remote_id;\n\tif (pdata->method == USE_SMC)\n\t\tarm_smccc_smc(a0, a1, a2, a3, 0, 0, 0, 0, res);\n\telse\n\t\tarm_smccc_hvc(a0, a1, a2, a3, 0, 0, 0, 0, res);\n}\n\n \nstatic irqreturn_t zynqmp_ipi_interrupt(int irq, void *data)\n{\n\tstruct zynqmp_ipi_pdata *pdata = data;\n\tstruct mbox_chan *chan;\n\tstruct zynqmp_ipi_mbox *ipi_mbox;\n\tstruct zynqmp_ipi_mchan *mchan;\n\tstruct zynqmp_ipi_message *msg;\n\tu64 arg0, arg3;\n\tstruct arm_smccc_res res;\n\tint ret, i, status = IRQ_NONE;\n\n\t(void)irq;\n\targ0 = SMC_IPI_MAILBOX_STATUS_ENQUIRY;\n\targ3 = IPI_SMC_ENQUIRY_DIRQ_MASK;\n\tfor (i = 0; i < pdata->num_mboxes; i++) {\n\t\tipi_mbox = &pdata->ipi_mboxes[i];\n\t\tmchan = &ipi_mbox->mchans[IPI_MB_CHNL_RX];\n\t\tchan = &ipi_mbox->mbox.chans[IPI_MB_CHNL_RX];\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, arg3, &res);\n\t\tret = (int)(res.a0 & 0xFFFFFFFF);\n\t\tif (ret > 0 && ret & IPI_MB_STATUS_RECV_PENDING) {\n\t\t\tif (mchan->is_opened) {\n\t\t\t\tmsg = mchan->rx_buf;\n\t\t\t\tmsg->len = mchan->req_buf_size;\n\t\t\t\tmemcpy_fromio(msg->data, mchan->req_buf,\n\t\t\t\t\t      msg->len);\n\t\t\t\tmbox_chan_received_data(chan, (void *)msg);\n\t\t\t\tstatus = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic bool zynqmp_ipi_peek_data(struct mbox_chan *chan)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct zynqmp_ipi_mbox *ipi_mbox = dev_get_drvdata(dev);\n\tstruct zynqmp_ipi_mchan *mchan = chan->con_priv;\n\tint ret;\n\tu64 arg0;\n\tstruct arm_smccc_res res;\n\n\tif (WARN_ON(!ipi_mbox)) {\n\t\tdev_err(dev, \"no platform drv data??\\n\");\n\t\treturn false;\n\t}\n\n\targ0 = SMC_IPI_MAILBOX_STATUS_ENQUIRY;\n\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\tret = (int)(res.a0 & 0xFFFFFFFF);\n\n\tif (mchan->chan_type == IPI_MB_CHNL_TX) {\n\t\t \n\t\tif (ret < 0 || ret & IPI_MB_STATUS_SEND_PENDING)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t} else if (ret > 0 && ret & IPI_MB_STATUS_RECV_PENDING) {\n\t\t \n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool zynqmp_ipi_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct zynqmp_ipi_mbox *ipi_mbox = dev_get_drvdata(dev);\n\tstruct zynqmp_ipi_mchan *mchan = chan->con_priv;\n\tint ret;\n\tu64 arg0;\n\tstruct arm_smccc_res res;\n\n\tif (WARN_ON(!ipi_mbox)) {\n\t\tdev_err(dev, \"no platform drv data??\\n\");\n\t\treturn false;\n\t}\n\n\tif (mchan->chan_type == IPI_MB_CHNL_TX) {\n\t\t \n\t\targ0 = SMC_IPI_MAILBOX_STATUS_ENQUIRY;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t\t \n\t\tret = (int)(res.a0 & 0xFFFFFFFF);\n\t\tif (ret < 0 || ret & IPI_MB_STATUS_SEND_PENDING)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t \n\treturn true;\n}\n\n \nstatic int zynqmp_ipi_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct zynqmp_ipi_mbox *ipi_mbox = dev_get_drvdata(dev);\n\tstruct zynqmp_ipi_mchan *mchan = chan->con_priv;\n\tstruct zynqmp_ipi_message *msg = data;\n\tu64 arg0;\n\tstruct arm_smccc_res res;\n\n\tif (WARN_ON(!ipi_mbox)) {\n\t\tdev_err(dev, \"no platform drv data??\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mchan->chan_type == IPI_MB_CHNL_TX) {\n\t\t \n\t\tif (msg && msg->len > mchan->req_buf_size) {\n\t\t\tdev_err(dev, \"channel %d message length %u > max %lu\\n\",\n\t\t\t\tmchan->chan_type, (unsigned int)msg->len,\n\t\t\t\tmchan->req_buf_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (msg && msg->len)\n\t\t\tmemcpy_toio(mchan->req_buf, msg->data, msg->len);\n\t\t \n\t\targ0 = SMC_IPI_MAILBOX_NOTIFY;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t} else {\n\t\t \n\t\tif (msg && msg->len > mchan->resp_buf_size) {\n\t\t\tdev_err(dev, \"channel %d message length %u > max %lu\\n\",\n\t\t\t\tmchan->chan_type, (unsigned int)msg->len,\n\t\t\t\tmchan->resp_buf_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (msg && msg->len)\n\t\t\tmemcpy_toio(mchan->resp_buf, msg->data, msg->len);\n\t\targ0 = SMC_IPI_MAILBOX_ACK;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, IPI_SMC_ACK_EIRQ_MASK,\n\t\t\t\t   &res);\n\t}\n\treturn 0;\n}\n\n \nstatic int zynqmp_ipi_startup(struct mbox_chan *chan)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct zynqmp_ipi_mbox *ipi_mbox = dev_get_drvdata(dev);\n\tstruct zynqmp_ipi_mchan *mchan = chan->con_priv;\n\tu64 arg0;\n\tstruct arm_smccc_res res;\n\tint ret = 0;\n\tunsigned int nchan_type;\n\n\tif (mchan->is_opened)\n\t\treturn 0;\n\n\t \n\tnchan_type = (mchan->chan_type + 1) % 2;\n\tif (!ipi_mbox->mchans[nchan_type].is_opened) {\n\t\targ0 = SMC_IPI_MAILBOX_OPEN;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t\t \n\t\tret = (int)(res.a0 & 0xFFFFFFFF);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"SMC to open the IPI channel failed.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = 0;\n\t}\n\n\t \n\tif (mchan->chan_type == IPI_MB_CHNL_RX) {\n\t\targ0 = SMC_IPI_MAILBOX_ENABLE_IRQ;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t}\n\tmchan->is_opened = 1;\n\n\treturn ret;\n}\n\n \nstatic void zynqmp_ipi_shutdown(struct mbox_chan *chan)\n{\n\tstruct device *dev = chan->mbox->dev;\n\tstruct zynqmp_ipi_mbox *ipi_mbox = dev_get_drvdata(dev);\n\tstruct zynqmp_ipi_mchan *mchan = chan->con_priv;\n\tu64 arg0;\n\tstruct arm_smccc_res res;\n\tunsigned int chan_type;\n\n\tif (!mchan->is_opened)\n\t\treturn;\n\n\t \n\tchan_type = mchan->chan_type;\n\tif (chan_type == IPI_MB_CHNL_RX) {\n\t\targ0 = SMC_IPI_MAILBOX_DISABLE_IRQ;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t}\n\t \n\tchan_type = (chan_type + 1) % 2;\n\tif (!ipi_mbox->mchans[chan_type].is_opened) {\n\t\targ0 = SMC_IPI_MAILBOX_RELEASE;\n\t\tzynqmp_ipi_fw_call(ipi_mbox, arg0, 0, &res);\n\t}\n\n\tmchan->is_opened = 0;\n}\n\n \nstatic const struct mbox_chan_ops zynqmp_ipi_chan_ops = {\n\t.startup = zynqmp_ipi_startup,\n\t.shutdown = zynqmp_ipi_shutdown,\n\t.peek_data = zynqmp_ipi_peek_data,\n\t.last_tx_done = zynqmp_ipi_last_tx_done,\n\t.send_data = zynqmp_ipi_send_data,\n};\n\n \nstatic struct mbox_chan *zynqmp_ipi_of_xlate(struct mbox_controller *mbox,\n\t\t\t\t\t     const struct of_phandle_args *p)\n{\n\tstruct mbox_chan *chan;\n\tstruct device *dev = mbox->dev;\n\tunsigned int chan_type;\n\n\t \n\tchan_type = p->args[0];\n\tif (chan_type != IPI_MB_CHNL_TX && chan_type != IPI_MB_CHNL_RX) {\n\t\tdev_err(dev, \"req chnl failure: invalid chnl type %u.\\n\",\n\t\t\tchan_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tchan = &mbox->chans[chan_type];\n\treturn chan;\n}\n\nstatic const struct of_device_id zynqmp_ipi_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-ipi-mailbox\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, zynqmp_ipi_of_match);\n\n \nstatic int zynqmp_ipi_mbox_get_buf_res(struct device_node *node,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct resource *res)\n{\n\tint ret, index;\n\n\tindex = of_property_match_string(node, \"reg-names\", name);\n\tif (index >= 0) {\n\t\tret = of_address_to_resource(node, index, res);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic void zynqmp_ipi_mbox_dev_release(struct device *dev)\n{\n\t(void)dev;\n}\n\n \nstatic int zynqmp_ipi_mbox_probe(struct zynqmp_ipi_mbox *ipi_mbox,\n\t\t\t\t struct device_node *node)\n{\n\tstruct zynqmp_ipi_mchan *mchan;\n\tstruct mbox_chan *chans;\n\tstruct mbox_controller *mbox;\n\tstruct resource res;\n\tstruct device *dev, *mdev;\n\tconst char *name;\n\tint ret;\n\n\tdev = ipi_mbox->pdata->dev;\n\t \n\tipi_mbox->dev.parent = dev;\n\tipi_mbox->dev.release = NULL;\n\tipi_mbox->dev.of_node = node;\n\tdev_set_name(&ipi_mbox->dev, \"%s\", of_node_full_name(node));\n\tdev_set_drvdata(&ipi_mbox->dev, ipi_mbox);\n\tipi_mbox->dev.release = zynqmp_ipi_mbox_dev_release;\n\tipi_mbox->dev.driver = &zynqmp_ipi_mbox_driver;\n\tret = device_register(&ipi_mbox->dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register ipi mbox dev.\\n\");\n\t\tput_device(&ipi_mbox->dev);\n\t\treturn ret;\n\t}\n\tmdev = &ipi_mbox->dev;\n\n\tmchan = &ipi_mbox->mchans[IPI_MB_CHNL_TX];\n\tname = \"local_request_region\";\n\tret = zynqmp_ipi_mbox_get_buf_res(node, name, &res);\n\tif (!ret) {\n\t\tmchan->req_buf_size = resource_size(&res);\n\t\tmchan->req_buf = devm_ioremap(mdev, res.start,\n\t\t\t\t\t      mchan->req_buf_size);\n\t\tif (!mchan->req_buf) {\n\t\t\tdev_err(mdev, \"Unable to map IPI buffer I/O memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (ret != -ENODEV) {\n\t\tdev_err(mdev, \"Unmatched resource %s, %d.\\n\", name, ret);\n\t\treturn ret;\n\t}\n\n\tname = \"remote_response_region\";\n\tret = zynqmp_ipi_mbox_get_buf_res(node, name, &res);\n\tif (!ret) {\n\t\tmchan->resp_buf_size = resource_size(&res);\n\t\tmchan->resp_buf = devm_ioremap(mdev, res.start,\n\t\t\t\t\t       mchan->resp_buf_size);\n\t\tif (!mchan->resp_buf) {\n\t\t\tdev_err(mdev, \"Unable to map IPI buffer I/O memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (ret != -ENODEV) {\n\t\tdev_err(mdev, \"Unmatched resource %s.\\n\", name);\n\t\treturn ret;\n\t}\n\tmchan->rx_buf = devm_kzalloc(mdev,\n\t\t\t\t     mchan->resp_buf_size +\n\t\t\t\t     sizeof(struct zynqmp_ipi_message),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mchan->rx_buf)\n\t\treturn -ENOMEM;\n\n\tmchan = &ipi_mbox->mchans[IPI_MB_CHNL_RX];\n\tname = \"remote_request_region\";\n\tret = zynqmp_ipi_mbox_get_buf_res(node, name, &res);\n\tif (!ret) {\n\t\tmchan->req_buf_size = resource_size(&res);\n\t\tmchan->req_buf = devm_ioremap(mdev, res.start,\n\t\t\t\t\t      mchan->req_buf_size);\n\t\tif (!mchan->req_buf) {\n\t\t\tdev_err(mdev, \"Unable to map IPI buffer I/O memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (ret != -ENODEV) {\n\t\tdev_err(mdev, \"Unmatched resource %s.\\n\", name);\n\t\treturn ret;\n\t}\n\n\tname = \"local_response_region\";\n\tret = zynqmp_ipi_mbox_get_buf_res(node, name, &res);\n\tif (!ret) {\n\t\tmchan->resp_buf_size = resource_size(&res);\n\t\tmchan->resp_buf = devm_ioremap(mdev, res.start,\n\t\t\t\t\t       mchan->resp_buf_size);\n\t\tif (!mchan->resp_buf) {\n\t\t\tdev_err(mdev, \"Unable to map IPI buffer I/O memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (ret != -ENODEV) {\n\t\tdev_err(mdev, \"Unmatched resource %s.\\n\", name);\n\t\treturn ret;\n\t}\n\tmchan->rx_buf = devm_kzalloc(mdev,\n\t\t\t\t     mchan->resp_buf_size +\n\t\t\t\t     sizeof(struct zynqmp_ipi_message),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mchan->rx_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = of_property_read_u32(node, \"xlnx,ipi-id\", &ipi_mbox->remote_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"No IPI remote ID is specified.\\n\");\n\t\treturn ret;\n\t}\n\n\tmbox = &ipi_mbox->mbox;\n\tmbox->dev = mdev;\n\tmbox->ops = &zynqmp_ipi_chan_ops;\n\tmbox->num_chans = 2;\n\tmbox->txdone_irq = false;\n\tmbox->txdone_poll = true;\n\tmbox->txpoll_period = 5;\n\tmbox->of_xlate = zynqmp_ipi_of_xlate;\n\tchans = devm_kzalloc(mdev, 2 * sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\tmbox->chans = chans;\n\tchans[IPI_MB_CHNL_TX].con_priv = &ipi_mbox->mchans[IPI_MB_CHNL_TX];\n\tchans[IPI_MB_CHNL_RX].con_priv = &ipi_mbox->mchans[IPI_MB_CHNL_RX];\n\tipi_mbox->mchans[IPI_MB_CHNL_TX].chan_type = IPI_MB_CHNL_TX;\n\tipi_mbox->mchans[IPI_MB_CHNL_RX].chan_type = IPI_MB_CHNL_RX;\n\tret = devm_mbox_controller_register(mdev, mbox);\n\tif (ret)\n\t\tdev_err(mdev,\n\t\t\t\"Failed to register mbox_controller(%d)\\n\", ret);\n\telse\n\t\tdev_info(mdev,\n\t\t\t \"Registered ZynqMP IPI mbox with TX/RX channels.\\n\");\n\treturn ret;\n}\n\n \nstatic void zynqmp_ipi_free_mboxes(struct zynqmp_ipi_pdata *pdata)\n{\n\tstruct zynqmp_ipi_mbox *ipi_mbox;\n\tint i;\n\n\ti = pdata->num_mboxes;\n\tfor (; i >= 0; i--) {\n\t\tipi_mbox = &pdata->ipi_mboxes[i];\n\t\tif (ipi_mbox->dev.parent) {\n\t\t\tmbox_controller_unregister(&ipi_mbox->mbox);\n\t\t\tif (device_is_registered(&ipi_mbox->dev))\n\t\t\t\tdevice_unregister(&ipi_mbox->dev);\n\t\t}\n\t}\n}\n\nstatic int zynqmp_ipi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *nc, *np = pdev->dev.of_node;\n\tstruct zynqmp_ipi_pdata *pdata;\n\tstruct zynqmp_ipi_mbox *mbox;\n\tint num_mboxes, ret = -EINVAL;\n\n\tnum_mboxes = of_get_available_child_count(np);\n\tif (num_mboxes == 0) {\n\t\tdev_err(dev, \"mailbox nodes not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata = devm_kzalloc(dev, struct_size(pdata, ipi_mboxes, num_mboxes),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tpdata->dev = dev;\n\n\t \n\tret = of_property_read_u32(np, \"xlnx,ipi-id\", &pdata->local_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"No IPI local ID is specified.\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->num_mboxes = num_mboxes;\n\n\tmbox = pdata->ipi_mboxes;\n\tfor_each_available_child_of_node(np, nc) {\n\t\tmbox->pdata = pdata;\n\t\tret = zynqmp_ipi_mbox_probe(mbox, nc);\n\t\tif (ret) {\n\t\t\tof_node_put(nc);\n\t\t\tdev_err(dev, \"failed to probe subdev.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_mbox_dev;\n\t\t}\n\t\tmbox++;\n\t}\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto free_mbox_dev;\n\n\tpdata->irq = ret;\n\tret = devm_request_irq(dev, pdata->irq, zynqmp_ipi_interrupt,\n\t\t\t       IRQF_SHARED, dev_name(dev), pdata);\n\tif (ret) {\n\t\tdev_err(dev, \"IRQ %d is not requested successfully.\\n\",\n\t\t\tpdata->irq);\n\t\tgoto free_mbox_dev;\n\t}\n\n\tplatform_set_drvdata(pdev, pdata);\n\treturn ret;\n\nfree_mbox_dev:\n\tzynqmp_ipi_free_mboxes(pdata);\n\treturn ret;\n}\n\nstatic int zynqmp_ipi_remove(struct platform_device *pdev)\n{\n\tstruct zynqmp_ipi_pdata *pdata;\n\n\tpdata = platform_get_drvdata(pdev);\n\tzynqmp_ipi_free_mboxes(pdata);\n\n\treturn 0;\n}\n\nstatic struct platform_driver zynqmp_ipi_driver = {\n\t.probe = zynqmp_ipi_probe,\n\t.remove = zynqmp_ipi_remove,\n\t.driver = {\n\t\t   .name = \"zynqmp-ipi\",\n\t\t   .of_match_table = of_match_ptr(zynqmp_ipi_of_match),\n\t},\n};\n\nstatic int __init zynqmp_ipi_init(void)\n{\n\treturn platform_driver_register(&zynqmp_ipi_driver);\n}\nsubsys_initcall(zynqmp_ipi_init);\n\nstatic void __exit zynqmp_ipi_exit(void)\n{\n\tplatform_driver_unregister(&zynqmp_ipi_driver);\n}\nmodule_exit(zynqmp_ipi_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Xilinx ZynqMP IPI Mailbox driver\");\nMODULE_AUTHOR(\"Xilinx Inc.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}