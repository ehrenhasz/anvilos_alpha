{
  "module_name": "sun6i-msgbox.c",
  "hash_id": "1a35f5a6474f5f254f0b4e05d84a3d3f9d52e900834c9e461291c60da4b010ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/sun6i-msgbox.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#define NUM_CHANS\t\t8\n\n#define CTRL_REG(n)\t\t(0x0000 + 0x4 * ((n) / 4))\n#define CTRL_RX(n)\t\tBIT(0 + 8 * ((n) % 4))\n#define CTRL_TX(n)\t\tBIT(4 + 8 * ((n) % 4))\n\n#define REMOTE_IRQ_EN_REG\t0x0040\n#define REMOTE_IRQ_STAT_REG\t0x0050\n#define LOCAL_IRQ_EN_REG\t0x0060\n#define LOCAL_IRQ_STAT_REG\t0x0070\n\n#define RX_IRQ(n)\t\tBIT(0 + 2 * (n))\n#define RX_IRQ_MASK\t\t0x5555\n#define TX_IRQ(n)\t\tBIT(1 + 2 * (n))\n#define TX_IRQ_MASK\t\t0xaaaa\n\n#define FIFO_STAT_REG(n)\t(0x0100 + 0x4 * (n))\n#define FIFO_STAT_MASK\t\tGENMASK(0, 0)\n\n#define MSG_STAT_REG(n)\t\t(0x0140 + 0x4 * (n))\n#define MSG_STAT_MASK\t\tGENMASK(2, 0)\n\n#define MSG_DATA_REG(n)\t\t(0x0180 + 0x4 * (n))\n\n#define mbox_dbg(mbox, ...)\tdev_dbg((mbox)->controller.dev, __VA_ARGS__)\n\nstruct sun6i_msgbox {\n\tstruct mbox_controller controller;\n\tstruct clk *clk;\n\tspinlock_t lock;\n\tvoid __iomem *regs;\n};\n\nstatic bool sun6i_msgbox_last_tx_done(struct mbox_chan *chan);\nstatic bool sun6i_msgbox_peek_data(struct mbox_chan *chan);\n\nstatic inline int channel_number(struct mbox_chan *chan)\n{\n\treturn chan - chan->mbox->chans;\n}\n\nstatic inline struct sun6i_msgbox *to_sun6i_msgbox(struct mbox_chan *chan)\n{\n\treturn chan->con_priv;\n}\n\nstatic irqreturn_t sun6i_msgbox_irq(int irq, void *dev_id)\n{\n\tstruct sun6i_msgbox *mbox = dev_id;\n\tuint32_t status;\n\tint n;\n\n\t \n\tstatus = readl(mbox->regs + LOCAL_IRQ_EN_REG) &\n\t\t readl(mbox->regs + LOCAL_IRQ_STAT_REG);\n\n\tif (!(status & RX_IRQ_MASK))\n\t\treturn IRQ_NONE;\n\n\tfor (n = 0; n < NUM_CHANS; ++n) {\n\t\tstruct mbox_chan *chan = &mbox->controller.chans[n];\n\n\t\tif (!(status & RX_IRQ(n)))\n\t\t\tcontinue;\n\n\t\twhile (sun6i_msgbox_peek_data(chan)) {\n\t\t\tuint32_t msg = readl(mbox->regs + MSG_DATA_REG(n));\n\n\t\t\tmbox_dbg(mbox, \"Channel %d received 0x%08x\\n\", n, msg);\n\t\t\tmbox_chan_received_data(chan, &msg);\n\t\t}\n\n\t\t \n\t\twritel(RX_IRQ(n), mbox->regs + LOCAL_IRQ_STAT_REG);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun6i_msgbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct sun6i_msgbox *mbox = to_sun6i_msgbox(chan);\n\tint n = channel_number(chan);\n\tuint32_t msg = *(uint32_t *)data;\n\n\t \n\tif (WARN_ON_ONCE(!(readl(mbox->regs + CTRL_REG(n)) & CTRL_TX(n))))\n\t\treturn 0;\n\n\twritel(msg, mbox->regs + MSG_DATA_REG(n));\n\tmbox_dbg(mbox, \"Channel %d sent 0x%08x\\n\", n, msg);\n\n\treturn 0;\n}\n\nstatic int sun6i_msgbox_startup(struct mbox_chan *chan)\n{\n\tstruct sun6i_msgbox *mbox = to_sun6i_msgbox(chan);\n\tint n = channel_number(chan);\n\n\t \n\tif (readl(mbox->regs + CTRL_REG(n)) & CTRL_RX(n)) {\n\t\t \n\t\twhile (sun6i_msgbox_peek_data(chan))\n\t\t\treadl(mbox->regs + MSG_DATA_REG(n));\n\t\twritel(RX_IRQ(n), mbox->regs + LOCAL_IRQ_STAT_REG);\n\n\t\t \n\t\tspin_lock(&mbox->lock);\n\t\twritel(readl(mbox->regs + LOCAL_IRQ_EN_REG) | RX_IRQ(n),\n\t\t       mbox->regs + LOCAL_IRQ_EN_REG);\n\t\tspin_unlock(&mbox->lock);\n\t}\n\n\tmbox_dbg(mbox, \"Channel %d startup complete\\n\", n);\n\n\treturn 0;\n}\n\nstatic void sun6i_msgbox_shutdown(struct mbox_chan *chan)\n{\n\tstruct sun6i_msgbox *mbox = to_sun6i_msgbox(chan);\n\tint n = channel_number(chan);\n\n\tif (readl(mbox->regs + CTRL_REG(n)) & CTRL_RX(n)) {\n\t\t \n\t\tspin_lock(&mbox->lock);\n\t\twritel(readl(mbox->regs + LOCAL_IRQ_EN_REG) & ~RX_IRQ(n),\n\t\t       mbox->regs + LOCAL_IRQ_EN_REG);\n\t\tspin_unlock(&mbox->lock);\n\n\t\t \n\t\tdo {\n\t\t\twhile (sun6i_msgbox_peek_data(chan))\n\t\t\t\treadl(mbox->regs + MSG_DATA_REG(n));\n\t\t\twritel(RX_IRQ(n), mbox->regs + LOCAL_IRQ_STAT_REG);\n\t\t} while (readl(mbox->regs + LOCAL_IRQ_STAT_REG) & RX_IRQ(n));\n\t}\n\n\tmbox_dbg(mbox, \"Channel %d shutdown complete\\n\", n);\n}\n\nstatic bool sun6i_msgbox_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct sun6i_msgbox *mbox = to_sun6i_msgbox(chan);\n\tint n = channel_number(chan);\n\n\t \n\treturn !(readl(mbox->regs + REMOTE_IRQ_STAT_REG) & RX_IRQ(n));\n}\n\nstatic bool sun6i_msgbox_peek_data(struct mbox_chan *chan)\n{\n\tstruct sun6i_msgbox *mbox = to_sun6i_msgbox(chan);\n\tint n = channel_number(chan);\n\n\treturn readl(mbox->regs + MSG_STAT_REG(n)) & MSG_STAT_MASK;\n}\n\nstatic const struct mbox_chan_ops sun6i_msgbox_chan_ops = {\n\t.send_data    = sun6i_msgbox_send_data,\n\t.startup      = sun6i_msgbox_startup,\n\t.shutdown     = sun6i_msgbox_shutdown,\n\t.last_tx_done = sun6i_msgbox_last_tx_done,\n\t.peek_data    = sun6i_msgbox_peek_data,\n};\n\nstatic int sun6i_msgbox_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mbox_chan *chans;\n\tstruct reset_control *reset;\n\tstruct sun6i_msgbox *mbox;\n\tint i, ret;\n\n\tmbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tchans = devm_kcalloc(dev, NUM_CHANS, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < NUM_CHANS; ++i)\n\t\tchans[i].con_priv = mbox;\n\n\tmbox->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(mbox->clk)) {\n\t\tret = PTR_ERR(mbox->clk);\n\t\tdev_err(dev, \"Failed to get clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(mbox->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(reset)) {\n\t\tret = PTR_ERR(reset);\n\t\tdev_err(dev, \"Failed to get reset control: %d\\n\", ret);\n\t\tgoto err_disable_unprepare;\n\t}\n\n\t \n\tret = reset_control_deassert(reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert reset: %d\\n\", ret);\n\t\tgoto err_disable_unprepare;\n\t}\n\n\tmbox->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mbox->regs)) {\n\t\tret = PTR_ERR(mbox->regs);\n\t\tdev_err(dev, \"Failed to map MMIO resource: %d\\n\", ret);\n\t\tgoto err_disable_unprepare;\n\t}\n\n\t \n\twritel(0, mbox->regs + LOCAL_IRQ_EN_REG);\n\n\tret = devm_request_irq(dev, irq_of_parse_and_map(dev->of_node, 0),\n\t\t\t       sun6i_msgbox_irq, 0, dev_name(dev), mbox);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IRQ handler: %d\\n\", ret);\n\t\tgoto err_disable_unprepare;\n\t}\n\n\tmbox->controller.dev           = dev;\n\tmbox->controller.ops           = &sun6i_msgbox_chan_ops;\n\tmbox->controller.chans         = chans;\n\tmbox->controller.num_chans     = NUM_CHANS;\n\tmbox->controller.txdone_irq    = false;\n\tmbox->controller.txdone_poll   = true;\n\tmbox->controller.txpoll_period = 5;\n\n\tspin_lock_init(&mbox->lock);\n\tplatform_set_drvdata(pdev, mbox);\n\n\tret = mbox_controller_register(&mbox->controller);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register controller: %d\\n\", ret);\n\t\tgoto err_disable_unprepare;\n\t}\n\n\treturn 0;\n\nerr_disable_unprepare:\n\tclk_disable_unprepare(mbox->clk);\n\n\treturn ret;\n}\n\nstatic int sun6i_msgbox_remove(struct platform_device *pdev)\n{\n\tstruct sun6i_msgbox *mbox = platform_get_drvdata(pdev);\n\n\tmbox_controller_unregister(&mbox->controller);\n\t \n\tclk_disable_unprepare(mbox->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun6i_msgbox_of_match[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-msgbox\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sun6i_msgbox_of_match);\n\nstatic struct platform_driver sun6i_msgbox_driver = {\n\t.driver = {\n\t\t.name = \"sun6i-msgbox\",\n\t\t.of_match_table = sun6i_msgbox_of_match,\n\t},\n\t.probe  = sun6i_msgbox_probe,\n\t.remove = sun6i_msgbox_remove,\n};\nmodule_platform_driver(sun6i_msgbox_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Allwinner sun6i/sun8i/sun9i/sun50i Message Box\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}