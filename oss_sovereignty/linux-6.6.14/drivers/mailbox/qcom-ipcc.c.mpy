{
  "module_name": "qcom-ipcc.c",
  "hash_id": "7898dcd1ef63f2c6d6183083ebeac3e9d9bec4d460ba6e2bba2fa495e76f76f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/qcom-ipcc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mailbox_controller.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/mailbox/qcom-ipcc.h>\n\n \n#define IPCC_REG_SEND_ID\t\t0x0c\n#define IPCC_REG_RECV_ID\t\t0x10\n#define IPCC_REG_RECV_SIGNAL_ENABLE\t0x14\n#define IPCC_REG_RECV_SIGNAL_DISABLE\t0x18\n#define IPCC_REG_RECV_SIGNAL_CLEAR\t0x1c\n#define IPCC_REG_CLIENT_CLEAR\t\t0x38\n\n#define IPCC_SIGNAL_ID_MASK\t\tGENMASK(15, 0)\n#define IPCC_CLIENT_ID_MASK\t\tGENMASK(31, 16)\n\n#define IPCC_NO_PENDING_IRQ\t\tGENMASK(31, 0)\n\n \nstruct qcom_ipcc_chan_info {\n\tu16 client_id;\n\tu16 signal_id;\n};\n\n \nstruct qcom_ipcc {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct irq_domain *irq_domain;\n\tstruct mbox_chan *chans;\n\tstruct qcom_ipcc_chan_info *mchan;\n\tstruct mbox_controller mbox;\n\tint num_chans;\n\tint irq;\n};\n\nstatic inline struct qcom_ipcc *to_qcom_ipcc(struct mbox_controller *mbox)\n{\n\treturn container_of(mbox, struct qcom_ipcc, mbox);\n}\n\nstatic inline u32 qcom_ipcc_get_hwirq(u16 client_id, u16 signal_id)\n{\n\treturn FIELD_PREP(IPCC_CLIENT_ID_MASK, client_id) |\n\t       FIELD_PREP(IPCC_SIGNAL_ID_MASK, signal_id);\n}\n\nstatic irqreturn_t qcom_ipcc_irq_fn(int irq, void *data)\n{\n\tstruct qcom_ipcc *ipcc = data;\n\tu32 hwirq;\n\tint virq;\n\n\tfor (;;) {\n\t\thwirq = readl(ipcc->base + IPCC_REG_RECV_ID);\n\t\tif (hwirq == IPCC_NO_PENDING_IRQ)\n\t\t\tbreak;\n\n\t\tvirq = irq_find_mapping(ipcc->irq_domain, hwirq);\n\t\twritel(hwirq, ipcc->base + IPCC_REG_RECV_SIGNAL_CLEAR);\n\t\tgeneric_handle_irq(virq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void qcom_ipcc_mask_irq(struct irq_data *irqd)\n{\n\tstruct qcom_ipcc *ipcc = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(irqd);\n\n\twritel(hwirq, ipcc->base + IPCC_REG_RECV_SIGNAL_DISABLE);\n}\n\nstatic void qcom_ipcc_unmask_irq(struct irq_data *irqd)\n{\n\tstruct qcom_ipcc *ipcc = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(irqd);\n\n\twritel(hwirq, ipcc->base + IPCC_REG_RECV_SIGNAL_ENABLE);\n}\n\nstatic struct irq_chip qcom_ipcc_irq_chip = {\n\t.name = \"ipcc\",\n\t.irq_mask = qcom_ipcc_mask_irq,\n\t.irq_unmask = qcom_ipcc_unmask_irq,\n\t.flags = IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic int qcom_ipcc_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct qcom_ipcc *ipcc = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &qcom_ipcc_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, ipcc);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic int qcom_ipcc_domain_xlate(struct irq_domain *d,\n\t\t\t\t  struct device_node *node, const u32 *intspec,\n\t\t\t\t  unsigned int intsize,\n\t\t\t\t  unsigned long *out_hwirq,\n\t\t\t\t  unsigned int *out_type)\n{\n\tif (intsize != 3)\n\t\treturn -EINVAL;\n\n\t*out_hwirq = qcom_ipcc_get_hwirq(intspec[0], intspec[1]);\n\t*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops qcom_ipcc_irq_ops = {\n\t.map = qcom_ipcc_domain_map,\n\t.xlate = qcom_ipcc_domain_xlate,\n};\n\nstatic int qcom_ipcc_mbox_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct qcom_ipcc *ipcc = to_qcom_ipcc(chan->mbox);\n\tstruct qcom_ipcc_chan_info *mchan = chan->con_priv;\n\tu32 hwirq;\n\n\thwirq = qcom_ipcc_get_hwirq(mchan->client_id, mchan->signal_id);\n\twritel(hwirq, ipcc->base + IPCC_REG_SEND_ID);\n\n\treturn 0;\n}\n\nstatic void qcom_ipcc_mbox_shutdown(struct mbox_chan *chan)\n{\n\tchan->con_priv = NULL;\n}\n\nstatic struct mbox_chan *qcom_ipcc_mbox_xlate(struct mbox_controller *mbox,\n\t\t\t\t\tconst struct of_phandle_args *ph)\n{\n\tstruct qcom_ipcc *ipcc = to_qcom_ipcc(mbox);\n\tstruct qcom_ipcc_chan_info *mchan;\n\tstruct mbox_chan *chan;\n\tstruct device *dev;\n\tint chan_id;\n\n\tdev = ipcc->dev;\n\n\tif (ph->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (chan_id = 0; chan_id < mbox->num_chans; chan_id++) {\n\t\tchan = &ipcc->chans[chan_id];\n\t\tmchan = chan->con_priv;\n\n\t\tif (!mchan)\n\t\t\tbreak;\n\t\telse if (mchan->client_id == ph->args[0] &&\n\t\t\t\tmchan->signal_id == ph->args[1])\n\t\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (chan_id >= mbox->num_chans)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tmchan = devm_kzalloc(dev, sizeof(*mchan), GFP_KERNEL);\n\tif (!mchan)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmchan->client_id = ph->args[0];\n\tmchan->signal_id = ph->args[1];\n\tchan->con_priv = mchan;\n\n\treturn chan;\n}\n\nstatic const struct mbox_chan_ops ipcc_mbox_chan_ops = {\n\t.send_data = qcom_ipcc_mbox_send_data,\n\t.shutdown = qcom_ipcc_mbox_shutdown,\n};\n\nstatic int qcom_ipcc_setup_mbox(struct qcom_ipcc *ipcc,\n\t\t\t\tstruct device_node *controller_dn)\n{\n\tstruct of_phandle_args curr_ph;\n\tstruct device_node *client_dn;\n\tstruct mbox_controller *mbox;\n\tstruct device *dev = ipcc->dev;\n\tint i, j, ret;\n\n\t \n\tipcc->num_chans = 0;\n\tfor_each_node_with_property(client_dn, \"mboxes\") {\n\t\tif (!of_device_is_available(client_dn))\n\t\t\tcontinue;\n\t\ti = of_count_phandle_with_args(client_dn,\n\t\t\t\t\t\t\"mboxes\", \"#mbox-cells\");\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tret = of_parse_phandle_with_args(client_dn, \"mboxes\",\n\t\t\t\t\t\t\"#mbox-cells\", j, &curr_ph);\n\t\t\tof_node_put(curr_ph.np);\n\t\t\tif (!ret && curr_ph.np == controller_dn)\n\t\t\t\tipcc->num_chans++;\n\t\t}\n\t}\n\n\t \n\tif (!ipcc->num_chans)\n\t\treturn 0;\n\n\tipcc->chans = devm_kcalloc(dev, ipcc->num_chans,\n\t\t\t\t\tsizeof(struct mbox_chan), GFP_KERNEL);\n\tif (!ipcc->chans)\n\t\treturn -ENOMEM;\n\n\tmbox = &ipcc->mbox;\n\tmbox->dev = dev;\n\tmbox->num_chans = ipcc->num_chans;\n\tmbox->chans = ipcc->chans;\n\tmbox->ops = &ipcc_mbox_chan_ops;\n\tmbox->of_xlate = qcom_ipcc_mbox_xlate;\n\tmbox->txdone_irq = false;\n\tmbox->txdone_poll = false;\n\n\treturn devm_mbox_controller_register(dev, mbox);\n}\n\nstatic int qcom_ipcc_pm_resume(struct device *dev)\n{\n\tstruct qcom_ipcc *ipcc = dev_get_drvdata(dev);\n\tu32 hwirq;\n\tint virq;\n\n\thwirq = readl(ipcc->base + IPCC_REG_RECV_ID);\n\tif (hwirq == IPCC_NO_PENDING_IRQ)\n\t\treturn 0;\n\n\tvirq = irq_find_mapping(ipcc->irq_domain, hwirq);\n\n\tdev_dbg(dev, \"virq: %d triggered client-id: %ld; signal-id: %ld\\n\", virq,\n\t\tFIELD_GET(IPCC_CLIENT_ID_MASK, hwirq), FIELD_GET(IPCC_SIGNAL_ID_MASK, hwirq));\n\n\treturn 0;\n}\n\nstatic int qcom_ipcc_probe(struct platform_device *pdev)\n{\n\tstruct qcom_ipcc *ipcc;\n\tstatic int id;\n\tchar *name;\n\tint ret;\n\n\tipcc = devm_kzalloc(&pdev->dev, sizeof(*ipcc), GFP_KERNEL);\n\tif (!ipcc)\n\t\treturn -ENOMEM;\n\n\tipcc->dev = &pdev->dev;\n\n\tipcc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ipcc->base))\n\t\treturn PTR_ERR(ipcc->base);\n\n\tipcc->irq = platform_get_irq(pdev, 0);\n\tif (ipcc->irq < 0)\n\t\treturn ipcc->irq;\n\n\tname = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"ipcc_%d\", id++);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tipcc->irq_domain = irq_domain_add_tree(pdev->dev.of_node,\n\t\t\t\t\t       &qcom_ipcc_irq_ops, ipcc);\n\tif (!ipcc->irq_domain)\n\t\treturn -ENOMEM;\n\n\tret = qcom_ipcc_setup_mbox(ipcc, pdev->dev.of_node);\n\tif (ret)\n\t\tgoto err_mbox;\n\n\tret = devm_request_irq(&pdev->dev, ipcc->irq, qcom_ipcc_irq_fn,\n\t\t\t       IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND |\n\t\t\t       IRQF_NO_THREAD, name, ipcc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register the irq: %d\\n\", ret);\n\t\tgoto err_req_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, ipcc);\n\n\treturn 0;\n\nerr_req_irq:\n\tif (ipcc->num_chans)\n\t\tmbox_controller_unregister(&ipcc->mbox);\nerr_mbox:\n\tirq_domain_remove(ipcc->irq_domain);\n\n\treturn ret;\n}\n\nstatic int qcom_ipcc_remove(struct platform_device *pdev)\n{\n\tstruct qcom_ipcc *ipcc = platform_get_drvdata(pdev);\n\n\tdisable_irq_wake(ipcc->irq);\n\tirq_domain_remove(ipcc->irq_domain);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_ipcc_of_match[] = {\n\t{ .compatible = \"qcom,ipcc\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_ipcc_of_match);\n\nstatic const struct dev_pm_ops qcom_ipcc_dev_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, qcom_ipcc_pm_resume)\n};\n\nstatic struct platform_driver qcom_ipcc_driver = {\n\t.probe = qcom_ipcc_probe,\n\t.remove = qcom_ipcc_remove,\n\t.driver = {\n\t\t.name = \"qcom-ipcc\",\n\t\t.of_match_table = qcom_ipcc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = pm_sleep_ptr(&qcom_ipcc_dev_pm_ops),\n\t},\n};\n\nstatic int __init qcom_ipcc_init(void)\n{\n\treturn platform_driver_register(&qcom_ipcc_driver);\n}\narch_initcall(qcom_ipcc_init);\n\nMODULE_AUTHOR(\"Venkata Narendra Kumar Gutta <vnkgutta@codeaurora.org>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. IPCC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}