{
  "module_name": "platform_mhu.c",
  "hash_id": "2312bc3c6b5b4f48ee6b549bddabaa3fc078527cea43e2862ce8668f222507ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mailbox/platform_mhu.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mailbox_controller.h>\n\n#define INTR_SET_OFS\t0x0\n#define INTR_STAT_OFS\t0x4\n#define INTR_CLR_OFS\t0x8\n\n#define MHU_SEC_OFFSET\t0x0\n#define MHU_LP_OFFSET\t0xc\n#define MHU_HP_OFFSET\t0x18\n#define TX_REG_OFFSET\t0x24\n\n#define MHU_CHANS\t3\n\nstruct platform_mhu_link {\n\tint irq;\n\tvoid __iomem *tx_reg;\n\tvoid __iomem *rx_reg;\n};\n\nstruct platform_mhu {\n\tvoid __iomem *base;\n\tstruct platform_mhu_link mlink[MHU_CHANS];\n\tstruct mbox_chan chan[MHU_CHANS];\n\tstruct mbox_controller mbox;\n};\n\nstatic irqreturn_t platform_mhu_rx_interrupt(int irq, void *p)\n{\n\tstruct mbox_chan *chan = p;\n\tstruct platform_mhu_link *mlink = chan->con_priv;\n\tu32 val;\n\n\tval = readl_relaxed(mlink->rx_reg + INTR_STAT_OFS);\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tmbox_chan_received_data(chan, (void *)&val);\n\n\twritel_relaxed(val, mlink->rx_reg + INTR_CLR_OFS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool platform_mhu_last_tx_done(struct mbox_chan *chan)\n{\n\tstruct platform_mhu_link *mlink = chan->con_priv;\n\tu32 val = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\n\n\treturn (val == 0);\n}\n\nstatic int platform_mhu_send_data(struct mbox_chan *chan, void *data)\n{\n\tstruct platform_mhu_link *mlink = chan->con_priv;\n\tu32 *arg = data;\n\n\twritel_relaxed(*arg, mlink->tx_reg + INTR_SET_OFS);\n\n\treturn 0;\n}\n\nstatic int platform_mhu_startup(struct mbox_chan *chan)\n{\n\tstruct platform_mhu_link *mlink = chan->con_priv;\n\tu32 val;\n\tint ret;\n\n\tval = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\n\twritel_relaxed(val, mlink->tx_reg + INTR_CLR_OFS);\n\n\tret = request_irq(mlink->irq, platform_mhu_rx_interrupt,\n\t\t\t  IRQF_SHARED, \"platform_mhu_link\", chan);\n\tif (ret) {\n\t\tdev_err(chan->mbox->dev,\n\t\t\t\"Unable to acquire IRQ %d\\n\", mlink->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void platform_mhu_shutdown(struct mbox_chan *chan)\n{\n\tstruct platform_mhu_link *mlink = chan->con_priv;\n\n\tfree_irq(mlink->irq, chan);\n}\n\nstatic const struct mbox_chan_ops platform_mhu_ops = {\n\t.send_data = platform_mhu_send_data,\n\t.startup = platform_mhu_startup,\n\t.shutdown = platform_mhu_shutdown,\n\t.last_tx_done = platform_mhu_last_tx_done,\n};\n\nstatic int platform_mhu_probe(struct platform_device *pdev)\n{\n\tint i, err;\n\tstruct platform_mhu *mhu;\n\tstruct device *dev = &pdev->dev;\n\tint platform_mhu_reg[MHU_CHANS] = {\n\t\tMHU_SEC_OFFSET, MHU_LP_OFFSET, MHU_HP_OFFSET\n\t};\n\n\t \n\tmhu = devm_kzalloc(dev, sizeof(*mhu), GFP_KERNEL);\n\tif (!mhu)\n\t\treturn -ENOMEM;\n\n\tmhu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mhu->base)) {\n\t\tdev_err(dev, \"ioremap failed\\n\");\n\t\treturn PTR_ERR(mhu->base);\n\t}\n\n\tfor (i = 0; i < MHU_CHANS; i++) {\n\t\tmhu->chan[i].con_priv = &mhu->mlink[i];\n\t\tmhu->mlink[i].irq = platform_get_irq(pdev, i);\n\t\tif (mhu->mlink[i].irq < 0)\n\t\t\treturn mhu->mlink[i].irq;\n\t\tmhu->mlink[i].rx_reg = mhu->base + platform_mhu_reg[i];\n\t\tmhu->mlink[i].tx_reg = mhu->mlink[i].rx_reg + TX_REG_OFFSET;\n\t}\n\n\tmhu->mbox.dev = dev;\n\tmhu->mbox.chans = &mhu->chan[0];\n\tmhu->mbox.num_chans = MHU_CHANS;\n\tmhu->mbox.ops = &platform_mhu_ops;\n\tmhu->mbox.txdone_irq = false;\n\tmhu->mbox.txdone_poll = true;\n\tmhu->mbox.txpoll_period = 1;\n\n\tplatform_set_drvdata(pdev, mhu);\n\n\terr = devm_mbox_controller_register(dev, &mhu->mbox);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mailboxes %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_info(dev, \"Platform MHU Mailbox registered\\n\");\n\treturn 0;\n}\n\nstatic const struct of_device_id platform_mhu_dt_ids[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-mhu\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, platform_mhu_dt_ids);\n\nstatic struct platform_driver platform_mhu_driver = {\n\t.probe\t= platform_mhu_probe,\n\t.driver = {\n\t\t.name = \"platform-mhu\",\n\t\t.of_match_table\t= platform_mhu_dt_ids,\n\t},\n};\n\nmodule_platform_driver(platform_mhu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:platform-mhu\");\nMODULE_DESCRIPTION(\"Platform MHU Driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}