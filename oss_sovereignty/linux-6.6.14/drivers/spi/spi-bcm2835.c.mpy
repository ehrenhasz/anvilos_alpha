{
  "module_name": "spi-bcm2835.c",
  "hash_id": "58fe44b1c93af480d454c13e01289177d96decb229d981013710804b9d4ad615",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>  \n#include <linux/gpio/driver.h>  \n#include <linux/of_irq.h>\n#include <linux/spi/spi.h>\n\n \n#define BCM2835_SPI_CS\t\t\t0x00\n#define BCM2835_SPI_FIFO\t\t0x04\n#define BCM2835_SPI_CLK\t\t\t0x08\n#define BCM2835_SPI_DLEN\t\t0x0c\n#define BCM2835_SPI_LTOH\t\t0x10\n#define BCM2835_SPI_DC\t\t\t0x14\n\n \n#define BCM2835_SPI_CS_LEN_LONG\t\t0x02000000\n#define BCM2835_SPI_CS_DMA_LEN\t\t0x01000000\n#define BCM2835_SPI_CS_CSPOL2\t\t0x00800000\n#define BCM2835_SPI_CS_CSPOL1\t\t0x00400000\n#define BCM2835_SPI_CS_CSPOL0\t\t0x00200000\n#define BCM2835_SPI_CS_RXF\t\t0x00100000\n#define BCM2835_SPI_CS_RXR\t\t0x00080000\n#define BCM2835_SPI_CS_TXD\t\t0x00040000\n#define BCM2835_SPI_CS_RXD\t\t0x00020000\n#define BCM2835_SPI_CS_DONE\t\t0x00010000\n#define BCM2835_SPI_CS_LEN\t\t0x00002000\n#define BCM2835_SPI_CS_REN\t\t0x00001000\n#define BCM2835_SPI_CS_ADCS\t\t0x00000800\n#define BCM2835_SPI_CS_INTR\t\t0x00000400\n#define BCM2835_SPI_CS_INTD\t\t0x00000200\n#define BCM2835_SPI_CS_DMAEN\t\t0x00000100\n#define BCM2835_SPI_CS_TA\t\t0x00000080\n#define BCM2835_SPI_CS_CSPOL\t\t0x00000040\n#define BCM2835_SPI_CS_CLEAR_RX\t\t0x00000020\n#define BCM2835_SPI_CS_CLEAR_TX\t\t0x00000010\n#define BCM2835_SPI_CS_CPOL\t\t0x00000008\n#define BCM2835_SPI_CS_CPHA\t\t0x00000004\n#define BCM2835_SPI_CS_CS_10\t\t0x00000002\n#define BCM2835_SPI_CS_CS_01\t\t0x00000001\n\n#define BCM2835_SPI_FIFO_SIZE\t\t64\n#define BCM2835_SPI_FIFO_SIZE_3_4\t48\n#define BCM2835_SPI_DMA_MIN_LENGTH\t96\n#define BCM2835_SPI_MODE_BITS\t(SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \\\n\t\t\t\t| SPI_NO_CS | SPI_3WIRE)\n\n#define DRV_NAME\t\"spi-bcm2835\"\n\n \nstatic unsigned int polling_limit_us = 30;\nmodule_param(polling_limit_us, uint, 0664);\nMODULE_PARM_DESC(polling_limit_us,\n\t\t \"time in us to run a transfer in polling mode\\n\");\n\n \nstruct bcm2835_spi {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tunsigned long clk_hz;\n\tint irq;\n\tstruct spi_transfer *tfr;\n\tstruct spi_controller *ctlr;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tint tx_len;\n\tint rx_len;\n\tint tx_prologue;\n\tint rx_prologue;\n\tunsigned int tx_spillover;\n\n\tstruct dentry *debugfs_dir;\n\tu64 count_transfer_polling;\n\tu64 count_transfer_irq;\n\tu64 count_transfer_irq_after_polling;\n\tu64 count_transfer_dma;\n\n\tstruct bcm2835_spidev *target;\n\tunsigned int tx_dma_active;\n\tunsigned int rx_dma_active;\n\tstruct dma_async_tx_descriptor *fill_tx_desc;\n\tdma_addr_t fill_tx_addr;\n};\n\n \nstruct bcm2835_spidev {\n\tu32 prepare_cs;\n\tstruct dma_async_tx_descriptor *clear_rx_desc;\n\tdma_addr_t clear_rx_addr;\n\tu32 clear_rx_cs ____cacheline_aligned;\n};\n\n#if defined(CONFIG_DEBUG_FS)\nstatic void bcm2835_debugfs_create(struct bcm2835_spi *bs,\n\t\t\t\t   const char *dname)\n{\n\tchar name[64];\n\tstruct dentry *dir;\n\n\t \n\tsnprintf(name, sizeof(name), \"spi-bcm2835-%s\", dname);\n\n\t \n\tdir = debugfs_create_dir(name, NULL);\n\tbs->debugfs_dir = dir;\n\n\t \n\tdebugfs_create_u64(\"count_transfer_polling\", 0444, dir,\n\t\t\t   &bs->count_transfer_polling);\n\tdebugfs_create_u64(\"count_transfer_irq\", 0444, dir,\n\t\t\t   &bs->count_transfer_irq);\n\tdebugfs_create_u64(\"count_transfer_irq_after_polling\", 0444, dir,\n\t\t\t   &bs->count_transfer_irq_after_polling);\n\tdebugfs_create_u64(\"count_transfer_dma\", 0444, dir,\n\t\t\t   &bs->count_transfer_dma);\n}\n\nstatic void bcm2835_debugfs_remove(struct bcm2835_spi *bs)\n{\n\tdebugfs_remove_recursive(bs->debugfs_dir);\n\tbs->debugfs_dir = NULL;\n}\n#else\nstatic void bcm2835_debugfs_create(struct bcm2835_spi *bs,\n\t\t\t\t   const char *dname)\n{\n}\n\nstatic void bcm2835_debugfs_remove(struct bcm2835_spi *bs)\n{\n}\n#endif  \n\nstatic inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned int reg)\n{\n\treturn readl(bs->regs + reg);\n}\n\nstatic inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned int reg, u32 val)\n{\n\twritel(val, bs->regs + reg);\n}\n\nstatic inline void bcm2835_rd_fifo(struct bcm2835_spi *bs)\n{\n\tu8 byte;\n\n\twhile ((bs->rx_len) &&\n\t       (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_RXD)) {\n\t\tbyte = bcm2835_rd(bs, BCM2835_SPI_FIFO);\n\t\tif (bs->rx_buf)\n\t\t\t*bs->rx_buf++ = byte;\n\t\tbs->rx_len--;\n\t}\n}\n\nstatic inline void bcm2835_wr_fifo(struct bcm2835_spi *bs)\n{\n\tu8 byte;\n\n\twhile ((bs->tx_len) &&\n\t       (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_TXD)) {\n\t\tbyte = bs->tx_buf ? *bs->tx_buf++ : 0;\n\t\tbcm2835_wr(bs, BCM2835_SPI_FIFO, byte);\n\t\tbs->tx_len--;\n\t}\n}\n\n \nstatic inline void bcm2835_rd_fifo_count(struct bcm2835_spi *bs, int count)\n{\n\tu32 val;\n\tint len;\n\n\tbs->rx_len -= count;\n\n\tdo {\n\t\tval = bcm2835_rd(bs, BCM2835_SPI_FIFO);\n\t\tlen = min(count, 4);\n\t\tmemcpy(bs->rx_buf, &val, len);\n\t\tbs->rx_buf += len;\n\t\tcount -= 4;\n\t} while (count > 0);\n}\n\n \nstatic inline void bcm2835_wr_fifo_count(struct bcm2835_spi *bs, int count)\n{\n\tu32 val;\n\tint len;\n\n\tbs->tx_len -= count;\n\n\tdo {\n\t\tif (bs->tx_buf) {\n\t\t\tlen = min(count, 4);\n\t\t\tmemcpy(&val, bs->tx_buf, len);\n\t\t\tbs->tx_buf += len;\n\t\t} else {\n\t\t\tval = 0;\n\t\t}\n\t\tbcm2835_wr(bs, BCM2835_SPI_FIFO, val);\n\t\tcount -= 4;\n\t} while (count > 0);\n}\n\n \nstatic inline void bcm2835_wait_tx_fifo_empty(struct bcm2835_spi *bs)\n{\n\twhile (!(bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_DONE))\n\t\tcpu_relax();\n}\n\n \nstatic inline void bcm2835_rd_fifo_blind(struct bcm2835_spi *bs, int count)\n{\n\tu8 val;\n\n\tcount = min(count, bs->rx_len);\n\tbs->rx_len -= count;\n\n\tdo {\n\t\tval = bcm2835_rd(bs, BCM2835_SPI_FIFO);\n\t\tif (bs->rx_buf)\n\t\t\t*bs->rx_buf++ = val;\n\t} while (--count);\n}\n\n \nstatic inline void bcm2835_wr_fifo_blind(struct bcm2835_spi *bs, int count)\n{\n\tu8 val;\n\n\tcount = min(count, bs->tx_len);\n\tbs->tx_len -= count;\n\n\tdo {\n\t\tval = bs->tx_buf ? *bs->tx_buf++ : 0;\n\t\tbcm2835_wr(bs, BCM2835_SPI_FIFO, val);\n\t} while (--count);\n}\n\nstatic void bcm2835_spi_reset_hw(struct bcm2835_spi *bs)\n{\n\tu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\n\n\t \n\tcs &= ~(BCM2835_SPI_CS_INTR |\n\t\tBCM2835_SPI_CS_INTD |\n\t\tBCM2835_SPI_CS_DMAEN |\n\t\tBCM2835_SPI_CS_TA);\n\t \n\tcs |= BCM2835_SPI_CS_DONE;\n\t \n\tcs |= BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX;\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS, cs);\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_DLEN, 0);\n}\n\nstatic irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct bcm2835_spi *bs = dev_id;\n\tu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\n\n\t \n\tif (!(cs & BCM2835_SPI_CS_INTR))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (cs & BCM2835_SPI_CS_RXF)\n\t\tbcm2835_rd_fifo_blind(bs, BCM2835_SPI_FIFO_SIZE);\n\telse if (cs & BCM2835_SPI_CS_RXR)\n\t\tbcm2835_rd_fifo_blind(bs, BCM2835_SPI_FIFO_SIZE_3_4);\n\n\tif (bs->tx_len && cs & BCM2835_SPI_CS_DONE)\n\t\tbcm2835_wr_fifo_blind(bs, BCM2835_SPI_FIFO_SIZE);\n\n\t \n\tbcm2835_rd_fifo(bs);\n\t \n\tbcm2835_wr_fifo(bs);\n\n\tif (!bs->rx_len) {\n\t\t \n\t\tbcm2835_spi_reset_hw(bs);\n\t\t \n\t\tspi_finalize_current_transfer(bs->ctlr);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm2835_spi_transfer_one_irq(struct spi_controller *ctlr,\n\t\t\t\t\tstruct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *tfr,\n\t\t\t\t\tu32 cs, bool fifo_empty)\n{\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\n\t \n\tbs->count_transfer_irq++;\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA);\n\n\t \n\tif (fifo_empty)\n\t\tbcm2835_wr_fifo_blind(bs, BCM2835_SPI_FIFO_SIZE);\n\tbcm2835_wr_fifo(bs);\n\n\t \n\tcs |= BCM2835_SPI_CS_INTR | BCM2835_SPI_CS_INTD | BCM2835_SPI_CS_TA;\n\tbcm2835_wr(bs, BCM2835_SPI_CS, cs);\n\n\t \n\treturn 1;\n}\n\n \nstatic void bcm2835_spi_transfer_prologue(struct spi_controller *ctlr,\n\t\t\t\t\t  struct spi_transfer *tfr,\n\t\t\t\t\t  struct bcm2835_spi *bs,\n\t\t\t\t\t  u32 cs)\n{\n\tint tx_remaining;\n\n\tbs->tfr\t\t = tfr;\n\tbs->tx_prologue  = 0;\n\tbs->rx_prologue  = 0;\n\tbs->tx_spillover = false;\n\n\tif (bs->tx_buf && !sg_is_last(&tfr->tx_sg.sgl[0]))\n\t\tbs->tx_prologue = sg_dma_len(&tfr->tx_sg.sgl[0]) & 3;\n\n\tif (bs->rx_buf && !sg_is_last(&tfr->rx_sg.sgl[0])) {\n\t\tbs->rx_prologue = sg_dma_len(&tfr->rx_sg.sgl[0]) & 3;\n\n\t\tif (bs->rx_prologue > bs->tx_prologue) {\n\t\t\tif (!bs->tx_buf || sg_is_last(&tfr->tx_sg.sgl[0])) {\n\t\t\t\tbs->tx_prologue  = bs->rx_prologue;\n\t\t\t} else {\n\t\t\t\tbs->tx_prologue += 4;\n\t\t\t\tbs->tx_spillover =\n\t\t\t\t\t!(sg_dma_len(&tfr->tx_sg.sgl[0]) & ~3);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!bs->tx_prologue)\n\t\treturn;\n\n\t \n\tif (bs->rx_prologue) {\n\t\tbcm2835_wr(bs, BCM2835_SPI_DLEN, bs->rx_prologue);\n\t\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA\n\t\t\t\t\t\t  | BCM2835_SPI_CS_DMAEN);\n\t\tbcm2835_wr_fifo_count(bs, bs->rx_prologue);\n\t\tbcm2835_wait_tx_fifo_empty(bs);\n\t\tbcm2835_rd_fifo_count(bs, bs->rx_prologue);\n\t\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_CLEAR_RX\n\t\t\t\t\t\t  | BCM2835_SPI_CS_CLEAR_TX\n\t\t\t\t\t\t  | BCM2835_SPI_CS_DONE);\n\n\t\tdma_sync_single_for_device(ctlr->dma_rx->device->dev,\n\t\t\t\t\t   sg_dma_address(&tfr->rx_sg.sgl[0]),\n\t\t\t\t\t   bs->rx_prologue, DMA_FROM_DEVICE);\n\n\t\tsg_dma_address(&tfr->rx_sg.sgl[0]) += bs->rx_prologue;\n\t\tsg_dma_len(&tfr->rx_sg.sgl[0])     -= bs->rx_prologue;\n\t}\n\n\tif (!bs->tx_buf)\n\t\treturn;\n\n\t \n\ttx_remaining = bs->tx_prologue - bs->rx_prologue;\n\tif (tx_remaining) {\n\t\tbcm2835_wr(bs, BCM2835_SPI_DLEN, tx_remaining);\n\t\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA\n\t\t\t\t\t\t  | BCM2835_SPI_CS_DMAEN);\n\t\tbcm2835_wr_fifo_count(bs, tx_remaining);\n\t\tbcm2835_wait_tx_fifo_empty(bs);\n\t\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_CLEAR_TX\n\t\t\t\t\t\t  | BCM2835_SPI_CS_DONE);\n\t}\n\n\tif (likely(!bs->tx_spillover)) {\n\t\tsg_dma_address(&tfr->tx_sg.sgl[0]) += bs->tx_prologue;\n\t\tsg_dma_len(&tfr->tx_sg.sgl[0])     -= bs->tx_prologue;\n\t} else {\n\t\tsg_dma_len(&tfr->tx_sg.sgl[0])      = 0;\n\t\tsg_dma_address(&tfr->tx_sg.sgl[1]) += 4;\n\t\tsg_dma_len(&tfr->tx_sg.sgl[1])     -= 4;\n\t}\n}\n\n \nstatic void bcm2835_spi_undo_prologue(struct bcm2835_spi *bs)\n{\n\tstruct spi_transfer *tfr = bs->tfr;\n\n\tif (!bs->tx_prologue)\n\t\treturn;\n\n\tif (bs->rx_prologue) {\n\t\tsg_dma_address(&tfr->rx_sg.sgl[0]) -= bs->rx_prologue;\n\t\tsg_dma_len(&tfr->rx_sg.sgl[0])     += bs->rx_prologue;\n\t}\n\n\tif (!bs->tx_buf)\n\t\tgoto out;\n\n\tif (likely(!bs->tx_spillover)) {\n\t\tsg_dma_address(&tfr->tx_sg.sgl[0]) -= bs->tx_prologue;\n\t\tsg_dma_len(&tfr->tx_sg.sgl[0])     += bs->tx_prologue;\n\t} else {\n\t\tsg_dma_len(&tfr->tx_sg.sgl[0])      = bs->tx_prologue - 4;\n\t\tsg_dma_address(&tfr->tx_sg.sgl[1]) -= 4;\n\t\tsg_dma_len(&tfr->tx_sg.sgl[1])     += 4;\n\t}\nout:\n\tbs->tx_prologue = 0;\n}\n\n \nstatic void bcm2835_spi_dma_rx_done(void *data)\n{\n\tstruct spi_controller *ctlr = data;\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\n\t \n\tdmaengine_terminate_async(ctlr->dma_tx);\n\tbs->tx_dma_active = false;\n\tbs->rx_dma_active = false;\n\tbcm2835_spi_undo_prologue(bs);\n\n\t \n\tbcm2835_spi_reset_hw(bs);\n\n\t ;\n\tspi_finalize_current_transfer(ctlr);\n}\n\n \nstatic void bcm2835_spi_dma_tx_done(void *data)\n{\n\tstruct spi_controller *ctlr = data;\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\n\t \n\twhile (!(bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_DONE))\n\t\tbcm2835_wr(bs, BCM2835_SPI_CS, bs->target->clear_rx_cs);\n\n\tbs->tx_dma_active = false;\n\tsmp_wmb();\n\n\t \n\tif (cmpxchg(&bs->rx_dma_active, true, false))\n\t\tdmaengine_terminate_async(ctlr->dma_rx);\n\n\tbcm2835_spi_undo_prologue(bs);\n\tbcm2835_spi_reset_hw(bs);\n\tspi_finalize_current_transfer(ctlr);\n}\n\n \nstatic int bcm2835_spi_prepare_sg(struct spi_controller *ctlr,\n\t\t\t\t  struct spi_transfer *tfr,\n\t\t\t\t  struct bcm2835_spi *bs,\n\t\t\t\t  struct bcm2835_spidev *target,\n\t\t\t\t  bool is_tx)\n{\n\tstruct dma_chan *chan;\n\tstruct scatterlist *sgl;\n\tunsigned int nents;\n\tenum dma_transfer_direction dir;\n\tunsigned long flags;\n\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\n\tif (is_tx) {\n\t\tdir   = DMA_MEM_TO_DEV;\n\t\tchan  = ctlr->dma_tx;\n\t\tnents = tfr->tx_sg.nents;\n\t\tsgl   = tfr->tx_sg.sgl;\n\t\tflags = tfr->rx_buf ? 0 : DMA_PREP_INTERRUPT;\n\t} else {\n\t\tdir   = DMA_DEV_TO_MEM;\n\t\tchan  = ctlr->dma_rx;\n\t\tnents = tfr->rx_sg.nents;\n\t\tsgl   = tfr->rx_sg.sgl;\n\t\tflags = DMA_PREP_INTERRUPT;\n\t}\n\t \n\tdesc = dmaengine_prep_slave_sg(chan, sgl, nents, dir, flags);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_tx) {\n\t\tdesc->callback = bcm2835_spi_dma_rx_done;\n\t\tdesc->callback_param = ctlr;\n\t} else if (!tfr->rx_buf) {\n\t\tdesc->callback = bcm2835_spi_dma_tx_done;\n\t\tdesc->callback_param = ctlr;\n\t\tbs->target = target;\n\t}\n\n\t \n\tcookie = dmaengine_submit(desc);\n\n\treturn dma_submit_error(cookie);\n}\n\n \nstatic int bcm2835_spi_transfer_one_dma(struct spi_controller *ctlr,\n\t\t\t\t\tstruct spi_transfer *tfr,\n\t\t\t\t\tstruct bcm2835_spidev *target,\n\t\t\t\t\tu32 cs)\n{\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\tdma_cookie_t cookie;\n\tint ret;\n\n\t \n\tbs->count_transfer_dma++;\n\n\t \n\tbcm2835_spi_transfer_prologue(ctlr, tfr, bs, cs);\n\n\t \n\tif (bs->tx_buf) {\n\t\tret = bcm2835_spi_prepare_sg(ctlr, tfr, bs, target, true);\n\t} else {\n\t\tcookie = dmaengine_submit(bs->fill_tx_desc);\n\t\tret = dma_submit_error(cookie);\n\t}\n\tif (ret)\n\t\tgoto err_reset_hw;\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_DLEN, bs->tx_len);\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS,\n\t\t   cs | BCM2835_SPI_CS_TA | BCM2835_SPI_CS_DMAEN);\n\n\tbs->tx_dma_active = true;\n\tsmp_wmb();\n\n\t \n\tdma_async_issue_pending(ctlr->dma_tx);\n\n\t \n\tif (bs->rx_buf) {\n\t\tret = bcm2835_spi_prepare_sg(ctlr, tfr, bs, target, false);\n\t} else {\n\t\tcookie = dmaengine_submit(target->clear_rx_desc);\n\t\tret = dma_submit_error(cookie);\n\t}\n\tif (ret) {\n\t\t \n\t\tdmaengine_terminate_sync(ctlr->dma_tx);\n\t\tbs->tx_dma_active = false;\n\t\tgoto err_reset_hw;\n\t}\n\n\t \n\tdma_async_issue_pending(ctlr->dma_rx);\n\tbs->rx_dma_active = true;\n\tsmp_mb();\n\n\t \n\tif (!bs->rx_buf && !bs->tx_dma_active &&\n\t    cmpxchg(&bs->rx_dma_active, true, false)) {\n\t\tdmaengine_terminate_async(ctlr->dma_rx);\n\t\tbcm2835_spi_reset_hw(bs);\n\t}\n\n\t \n\treturn 1;\n\nerr_reset_hw:\n\tbcm2835_spi_reset_hw(bs);\n\tbcm2835_spi_undo_prologue(bs);\n\treturn ret;\n}\n\nstatic bool bcm2835_spi_can_dma(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *tfr)\n{\n\t \n\tif (tfr->len < BCM2835_SPI_DMA_MIN_LENGTH)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic void bcm2835_dma_release(struct spi_controller *ctlr,\n\t\t\t\tstruct bcm2835_spi *bs)\n{\n\tif (ctlr->dma_tx) {\n\t\tdmaengine_terminate_sync(ctlr->dma_tx);\n\n\t\tif (bs->fill_tx_desc)\n\t\t\tdmaengine_desc_free(bs->fill_tx_desc);\n\n\t\tif (bs->fill_tx_addr)\n\t\t\tdma_unmap_page_attrs(ctlr->dma_tx->device->dev,\n\t\t\t\t\t     bs->fill_tx_addr, sizeof(u32),\n\t\t\t\t\t     DMA_TO_DEVICE,\n\t\t\t\t\t     DMA_ATTR_SKIP_CPU_SYNC);\n\n\t\tdma_release_channel(ctlr->dma_tx);\n\t\tctlr->dma_tx = NULL;\n\t}\n\n\tif (ctlr->dma_rx) {\n\t\tdmaengine_terminate_sync(ctlr->dma_rx);\n\t\tdma_release_channel(ctlr->dma_rx);\n\t\tctlr->dma_rx = NULL;\n\t}\n}\n\nstatic int bcm2835_dma_init(struct spi_controller *ctlr, struct device *dev,\n\t\t\t    struct bcm2835_spi *bs)\n{\n\tstruct dma_slave_config slave_config;\n\tconst __be32 *addr;\n\tdma_addr_t dma_reg_base;\n\tint ret;\n\n\t \n\taddr = of_get_address(ctlr->dev.of_node, 0, NULL, NULL);\n\tif (!addr) {\n\t\tdev_err(dev, \"could not get DMA-register address - not using dma mode\\n\");\n\t\t \n\t\treturn 0;\n\t}\n\tdma_reg_base = be32_to_cpup(addr);\n\n\t \n\tctlr->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(ctlr->dma_tx)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(ctlr->dma_tx),\n\t\t\t\"no tx-dma configuration found - not using dma mode\\n\");\n\t\tctlr->dma_tx = NULL;\n\t\tgoto err;\n\t}\n\tctlr->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(ctlr->dma_rx)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(ctlr->dma_rx),\n\t\t\t\"no rx-dma configuration found - not using dma mode\\n\");\n\t\tctlr->dma_rx = NULL;\n\t\tgoto err_release;\n\t}\n\n\t \n\tslave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);\n\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tret = dmaengine_slave_config(ctlr->dma_tx, &slave_config);\n\tif (ret)\n\t\tgoto err_config;\n\n\tbs->fill_tx_addr = dma_map_page_attrs(ctlr->dma_tx->device->dev,\n\t\t\t\t\t      ZERO_PAGE(0), 0, sizeof(u32),\n\t\t\t\t\t      DMA_TO_DEVICE,\n\t\t\t\t\t      DMA_ATTR_SKIP_CPU_SYNC);\n\tif (dma_mapping_error(ctlr->dma_tx->device->dev, bs->fill_tx_addr)) {\n\t\tdev_err(dev, \"cannot map zero page - not using DMA mode\\n\");\n\t\tbs->fill_tx_addr = 0;\n\t\tret = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\tbs->fill_tx_desc = dmaengine_prep_dma_cyclic(ctlr->dma_tx,\n\t\t\t\t\t\t     bs->fill_tx_addr,\n\t\t\t\t\t\t     sizeof(u32), 0,\n\t\t\t\t\t\t     DMA_MEM_TO_DEV, 0);\n\tif (!bs->fill_tx_desc) {\n\t\tdev_err(dev, \"cannot prepare fill_tx_desc - not using DMA mode\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\tret = dmaengine_desc_set_reuse(bs->fill_tx_desc);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot reuse fill_tx_desc - not using DMA mode\\n\");\n\t\tgoto err_release;\n\t}\n\n\t \n\tslave_config.src_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);\n\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tslave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_CS);\n\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tret = dmaengine_slave_config(ctlr->dma_rx, &slave_config);\n\tif (ret)\n\t\tgoto err_config;\n\n\t \n\tctlr->can_dma = bcm2835_spi_can_dma;\n\n\treturn 0;\n\nerr_config:\n\tdev_err(dev, \"issue configuring dma: %d - not using DMA mode\\n\",\n\t\tret);\nerr_release:\n\tbcm2835_dma_release(ctlr, bs);\nerr:\n\t \n\tif (ret != -EPROBE_DEFER)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int bcm2835_spi_transfer_one_poll(struct spi_controller *ctlr,\n\t\t\t\t\t struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *tfr,\n\t\t\t\t\t u32 cs)\n{\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\tunsigned long timeout;\n\n\t \n\tbs->count_transfer_polling++;\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA);\n\n\t \n\tbcm2835_wr_fifo_blind(bs, BCM2835_SPI_FIFO_SIZE);\n\n\t \n\ttimeout = jiffies + 2 + HZ * polling_limit_us / 1000000;\n\n\t \n\twhile (bs->rx_len) {\n\t\t \n\t\tbcm2835_wr_fifo(bs);\n\n\t\t \n\t\tbcm2835_rd_fifo(bs);\n\n\t\t \n\t\tif (bs->rx_len && time_after(jiffies, timeout)) {\n\t\t\tdev_dbg_ratelimited(&spi->dev,\n\t\t\t\t\t    \"timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\\n\",\n\t\t\t\t\t    jiffies - timeout,\n\t\t\t\t\t    bs->tx_len, bs->rx_len);\n\t\t\t \n\n\t\t\t \n\t\t\tbs->count_transfer_irq_after_polling++;\n\n\t\t\treturn bcm2835_spi_transfer_one_irq(ctlr, spi,\n\t\t\t\t\t\t\t    tfr, cs, false);\n\t\t}\n\t}\n\n\t \n\tbcm2835_spi_reset_hw(bs);\n\t \n\treturn 0;\n}\n\nstatic int bcm2835_spi_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *tfr)\n{\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\tstruct bcm2835_spidev *target = spi_get_ctldata(spi);\n\tunsigned long spi_hz, cdiv;\n\tunsigned long hz_per_byte, byte_limit;\n\tu32 cs = target->prepare_cs;\n\n\t \n\tspi_hz = tfr->speed_hz;\n\n\tif (spi_hz >= bs->clk_hz / 2) {\n\t\tcdiv = 2;  \n\t} else if (spi_hz) {\n\t\t \n\t\tcdiv = DIV_ROUND_UP(bs->clk_hz, spi_hz);\n\t\tcdiv += (cdiv % 2);\n\n\t\tif (cdiv >= 65536)\n\t\t\tcdiv = 0;  \n\t} else {\n\t\tcdiv = 0;  \n\t}\n\ttfr->effective_speed_hz = cdiv ? (bs->clk_hz / cdiv) : (bs->clk_hz / 65536);\n\tbcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);\n\n\t \n\tif (spi->mode & SPI_3WIRE && tfr->rx_buf)\n\t\tcs |= BCM2835_SPI_CS_REN;\n\n\t \n\tbs->tx_buf = tfr->tx_buf;\n\tbs->rx_buf = tfr->rx_buf;\n\tbs->tx_len = tfr->len;\n\tbs->rx_len = tfr->len;\n\n\t \n\thz_per_byte = polling_limit_us ? (9 * 1000000) / polling_limit_us : 0;\n\tbyte_limit = hz_per_byte ? tfr->effective_speed_hz / hz_per_byte : 1;\n\n\t \n\tif (tfr->len < byte_limit)\n\t\treturn bcm2835_spi_transfer_one_poll(ctlr, spi, tfr, cs);\n\n\t \n\tif (ctlr->can_dma && bcm2835_spi_can_dma(ctlr, spi, tfr))\n\t\treturn bcm2835_spi_transfer_one_dma(ctlr, tfr, target, cs);\n\n\t \n\treturn bcm2835_spi_transfer_one_irq(ctlr, spi, tfr, cs, true);\n}\n\nstatic int bcm2835_spi_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_message *msg)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\tstruct bcm2835_spidev *target = spi_get_ctldata(spi);\n\tint ret;\n\n\tif (ctlr->can_dma) {\n\t\t \n\t\tret = spi_split_transfers_maxsize(ctlr, msg, 65532,\n\t\t\t\t\t\t  GFP_KERNEL | GFP_DMA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS, target->prepare_cs);\n\n\treturn 0;\n}\n\nstatic void bcm2835_spi_handle_err(struct spi_controller *ctlr,\n\t\t\t\t   struct spi_message *msg)\n{\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\n\t \n\tif (ctlr->dma_tx) {\n\t\tdmaengine_terminate_sync(ctlr->dma_tx);\n\t\tbs->tx_dma_active = false;\n\t}\n\tif (ctlr->dma_rx) {\n\t\tdmaengine_terminate_sync(ctlr->dma_rx);\n\t\tbs->rx_dma_active = false;\n\t}\n\tbcm2835_spi_undo_prologue(bs);\n\n\t \n\tbcm2835_spi_reset_hw(bs);\n}\n\nstatic int chip_match_name(struct gpio_chip *chip, void *data)\n{\n\treturn !strcmp(chip->label, data);\n}\n\nstatic void bcm2835_spi_cleanup(struct spi_device *spi)\n{\n\tstruct bcm2835_spidev *target = spi_get_ctldata(spi);\n\tstruct spi_controller *ctlr = spi->controller;\n\n\tif (target->clear_rx_desc)\n\t\tdmaengine_desc_free(target->clear_rx_desc);\n\n\tif (target->clear_rx_addr)\n\t\tdma_unmap_single(ctlr->dma_rx->device->dev,\n\t\t\t\t target->clear_rx_addr,\n\t\t\t\t sizeof(u32),\n\t\t\t\t DMA_TO_DEVICE);\n\n\tkfree(target);\n}\n\nstatic int bcm2835_spi_setup_dma(struct spi_controller *ctlr,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct bcm2835_spi *bs,\n\t\t\t\t struct bcm2835_spidev *target)\n{\n\tint ret;\n\n\tif (!ctlr->dma_rx)\n\t\treturn 0;\n\n\ttarget->clear_rx_addr = dma_map_single(ctlr->dma_rx->device->dev,\n\t\t\t\t\t       &target->clear_rx_cs,\n\t\t\t\t\t       sizeof(u32),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctlr->dma_rx->device->dev, target->clear_rx_addr)) {\n\t\tdev_err(&spi->dev, \"cannot map clear_rx_cs\\n\");\n\t\ttarget->clear_rx_addr = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\ttarget->clear_rx_desc = dmaengine_prep_dma_cyclic(ctlr->dma_rx,\n\t\t\t\t\t\t          target->clear_rx_addr,\n\t\t\t\t\t\t          sizeof(u32), 0,\n\t\t\t\t\t\t          DMA_MEM_TO_DEV, 0);\n\tif (!target->clear_rx_desc) {\n\t\tdev_err(&spi->dev, \"cannot prepare clear_rx_desc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = dmaengine_desc_set_reuse(target->clear_rx_desc);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"cannot reuse clear_rx_desc\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm2835_spi_setup(struct spi_device *spi)\n{\n\tstruct spi_controller *ctlr = spi->controller;\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\tstruct bcm2835_spidev *target = spi_get_ctldata(spi);\n\tstruct gpio_chip *chip;\n\tint ret;\n\tu32 cs;\n\n\tif (!target) {\n\t\ttarget = kzalloc(ALIGN(sizeof(*target), dma_get_cache_alignment()),\n\t\t\t      GFP_KERNEL);\n\t\tif (!target)\n\t\t\treturn -ENOMEM;\n\n\t\tspi_set_ctldata(spi, target);\n\n\t\tret = bcm2835_spi_setup_dma(ctlr, spi, bs, target);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\t}\n\n\t \n\tcs = BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;\n\tif (spi->mode & SPI_CPOL)\n\t\tcs |= BCM2835_SPI_CS_CPOL;\n\tif (spi->mode & SPI_CPHA)\n\t\tcs |= BCM2835_SPI_CS_CPHA;\n\ttarget->prepare_cs = cs;\n\n\t \n\tif (ctlr->dma_rx) {\n\t\ttarget->clear_rx_cs = cs | BCM2835_SPI_CS_TA |\n\t\t\t\t\tBCM2835_SPI_CS_DMAEN |\n\t\t\t\t\tBCM2835_SPI_CS_CLEAR_RX;\n\t\tdma_sync_single_for_device(ctlr->dma_rx->device->dev,\n\t\t\t\t\t   target->clear_rx_addr,\n\t\t\t\t\t   sizeof(u32),\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t}\n\n\t \n\tif (spi->mode & SPI_NO_CS)\n\t\treturn 0;\n\t \n\tif (spi_get_csgpiod(spi, 0))\n\t\treturn 0;\n\tif (spi_get_chipselect(spi, 0) > 1) {\n\t\t \n\t\tdev_err(&spi->dev,\n\t\t\t\"setup: only two native chip-selects are supported\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\n\t \n\tchip = gpiochip_find(\"pinctrl-bcm2835\", chip_match_name);\n\tif (!chip)\n\t\treturn 0;\n\n\tspi_set_csgpiod(spi, 0, gpiochip_request_own_desc(chip,\n\t\t\t\t\t\t\t  8 - (spi_get_chipselect(spi, 0)),\n\t\t\t\t\t\t\t  DRV_NAME,\n\t\t\t\t\t\t\t  GPIO_LOOKUP_FLAGS_DEFAULT,\n\t\t\t\t\t\t\t  GPIOD_OUT_LOW));\n\tif (IS_ERR(spi_get_csgpiod(spi, 0))) {\n\t\tret = PTR_ERR(spi_get_csgpiod(spi, 0));\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tdev_info(&spi->dev, \"setting up native-CS%i to use GPIO\\n\",\n\t\t spi_get_chipselect(spi, 0));\n\n\treturn 0;\n\nerr_cleanup:\n\tbcm2835_spi_cleanup(spi);\n\treturn ret;\n}\n\nstatic int bcm2835_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct bcm2835_spi *bs;\n\tint err;\n\n\tctlr = devm_spi_alloc_host(&pdev->dev, sizeof(*bs));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\tctlr->use_gpio_descriptors = true;\n\tctlr->mode_bits = BCM2835_SPI_MODE_BITS;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->num_chipselect = 3;\n\tctlr->setup = bcm2835_spi_setup;\n\tctlr->cleanup = bcm2835_spi_cleanup;\n\tctlr->transfer_one = bcm2835_spi_transfer_one;\n\tctlr->handle_err = bcm2835_spi_handle_err;\n\tctlr->prepare_message = bcm2835_spi_prepare_message;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\n\tbs = spi_controller_get_devdata(ctlr);\n\tbs->ctlr = ctlr;\n\n\tbs->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bs->regs))\n\t\treturn PTR_ERR(bs->regs);\n\n\tbs->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(bs->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(bs->clk),\n\t\t\t\t     \"could not get clk\\n\");\n\n\tctlr->max_speed_hz = clk_get_rate(bs->clk) / 2;\n\n\tbs->irq = platform_get_irq(pdev, 0);\n\tif (bs->irq < 0)\n\t\treturn bs->irq;\n\n\terr = clk_prepare_enable(bs->clk);\n\tif (err)\n\t\treturn err;\n\tbs->clk_hz = clk_get_rate(bs->clk);\n\n\terr = bcm2835_dma_init(ctlr, &pdev->dev, bs);\n\tif (err)\n\t\tgoto out_clk_disable;\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS,\n\t\t   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\n\n\terr = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt,\n\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), bs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not request IRQ: %d\\n\", err);\n\t\tgoto out_dma_release;\n\t}\n\n\terr = spi_register_controller(ctlr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not register SPI controller: %d\\n\",\n\t\t\terr);\n\t\tgoto out_dma_release;\n\t}\n\n\tbcm2835_debugfs_create(bs, dev_name(&pdev->dev));\n\n\treturn 0;\n\nout_dma_release:\n\tbcm2835_dma_release(ctlr, bs);\nout_clk_disable:\n\tclk_disable_unprepare(bs->clk);\n\treturn err;\n}\n\nstatic void bcm2835_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = platform_get_drvdata(pdev);\n\tstruct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);\n\n\tbcm2835_debugfs_remove(bs);\n\n\tspi_unregister_controller(ctlr);\n\n\tbcm2835_dma_release(ctlr, bs);\n\n\t \n\tbcm2835_wr(bs, BCM2835_SPI_CS,\n\t\t   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\n\n\tclk_disable_unprepare(bs->clk);\n}\n\nstatic const struct of_device_id bcm2835_spi_match[] = {\n\t{ .compatible = \"brcm,bcm2835-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bcm2835_spi_match);\n\nstatic struct platform_driver bcm2835_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= bcm2835_spi_match,\n\t},\n\t.probe\t\t= bcm2835_spi_probe,\n\t.remove_new\t= bcm2835_spi_remove,\n\t.shutdown\t= bcm2835_spi_remove,\n};\nmodule_platform_driver(bcm2835_spi_driver);\n\nMODULE_DESCRIPTION(\"SPI controller driver for Broadcom BCM2835\");\nMODULE_AUTHOR(\"Chris Boot <bootc@bootc.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}