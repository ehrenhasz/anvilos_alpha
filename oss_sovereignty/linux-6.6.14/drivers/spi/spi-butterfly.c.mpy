{
  "module_name": "spi-butterfly.c",
  "hash_id": "c187c50aed1c53b1fa2ebcb2e826ffe094f78d8b1a9b97c5a221b9d3ed80da3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-butterfly.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/parport.h>\n\n#include <linux/sched.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/flash.h>\n\n#include <linux/mtd/partitions.h>\n\n \n\n \n#define\tbutterfly_nreset (1 << 1)\t\t \n\n#define\tspi_sck_bit\t(1 << 0)\t\t \n#define\tspi_mosi_bit\t(1 << 7)\t\t \n\n#define\tvcc_bits\t((1 << 6) | (1 << 5))\t \n\n \n#define\tspi_miso_bit\tPARPORT_STATUS_BUSY\t \n\n \n#define\tspi_cs_bit\tPARPORT_CONTROL_SELECT\t \n\nstatic inline struct butterfly *spidev_to_pp(struct spi_device *spi)\n{\n\treturn spi->controller_data;\n}\n\nstruct butterfly {\n\t \n\tstruct spi_bitbang\tbitbang;\n\n\tstruct parport\t\t*port;\n\tstruct pardevice\t*pd;\n\n\tu8\t\t\tlastbyte;\n\n\tstruct spi_device\t*dataflash;\n\tstruct spi_device\t*butterfly;\n\tstruct spi_board_info\tinfo[2];\n\n};\n\n \n\nstatic inline void\nsetsck(struct spi_device *spi, int is_on)\n{\n\tstruct butterfly\t*pp = spidev_to_pp(spi);\n\tu8\t\t\tbit, byte = pp->lastbyte;\n\n\tbit = spi_sck_bit;\n\n\tif (is_on)\n\t\tbyte |= bit;\n\telse\n\t\tbyte &= ~bit;\n\tparport_write_data(pp->port, byte);\n\tpp->lastbyte = byte;\n}\n\nstatic inline void\nsetmosi(struct spi_device *spi, int is_on)\n{\n\tstruct butterfly\t*pp = spidev_to_pp(spi);\n\tu8\t\t\tbit, byte = pp->lastbyte;\n\n\tbit = spi_mosi_bit;\n\n\tif (is_on)\n\t\tbyte |= bit;\n\telse\n\t\tbyte &= ~bit;\n\tparport_write_data(pp->port, byte);\n\tpp->lastbyte = byte;\n}\n\nstatic inline int getmiso(struct spi_device *spi)\n{\n\tstruct butterfly\t*pp = spidev_to_pp(spi);\n\tint\t\t\tvalue;\n\tu8\t\t\tbit;\n\n\tbit = spi_miso_bit;\n\n\t \n\tvalue = !(parport_read_status(pp->port) & bit);\n\treturn (bit == PARPORT_STATUS_BUSY) ? value : !value;\n}\n\nstatic void butterfly_chipselect(struct spi_device *spi, int value)\n{\n\tstruct butterfly\t*pp = spidev_to_pp(spi);\n\n\t \n\tif (value != BITBANG_CS_INACTIVE)\n\t\tsetsck(spi, spi->mode & SPI_CPOL);\n\n\t \n\tif (spi_cs_bit == PARPORT_CONTROL_INIT)\n\t\tvalue = !value;\n\n\tparport_frob_control(pp->port, spi_cs_bit, value ? spi_cs_bit : 0);\n}\n\n \n\n#define spidelay(X)\tdo { } while (0)\n \n\n#include \"spi-bitbang-txrx.h\"\n\nstatic u32\nbutterfly_txrx_word_mode0(struct spi_device *spi, unsigned nsecs, u32 word,\n\t\t\t  u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\n \n\n \nstatic struct mtd_partition partitions[] = { {\n\t \n\n\t \n\t.name\t\t= \"bookkeeping\",\t \n\t.offset\t\t= 0,\n\t.size\t\t= (8 + 248) * 264,\n\t \n}, {\n\t \n\t.name\t\t= \"filesystem\",\t\t \n\t.offset\t\t= MTDPART_OFS_APPEND,\n\t.size\t\t= MTDPART_SIZ_FULL,\n} };\n\nstatic struct flash_platform_data flash = {\n\t.name\t\t= \"butterflash\",\n\t.parts\t\t= partitions,\n\t.nr_parts\t= ARRAY_SIZE(partitions),\n};\n\n \nstatic struct butterfly *butterfly;\n\nstatic void butterfly_attach(struct parport *p)\n{\n\tstruct pardevice\t*pd;\n\tint\t\t\tstatus;\n\tstruct butterfly\t*pp;\n\tstruct spi_controller\t*host;\n\tstruct device\t\t*dev = p->physport->dev;\n\tstruct pardev_cb\tbutterfly_cb;\n\n\tif (butterfly || !dev)\n\t\treturn;\n\n\t \n\n\thost = spi_alloc_host(dev, sizeof(*pp));\n\tif (!host) {\n\t\tstatus = -ENOMEM;\n\t\tgoto done;\n\t}\n\tpp = spi_controller_get_devdata(host);\n\n\t \n\thost->bus_num = 42;\n\thost->num_chipselect = 2;\n\n\tpp->bitbang.master = host;\n\tpp->bitbang.chipselect = butterfly_chipselect;\n\tpp->bitbang.txrx_word[SPI_MODE_0] = butterfly_txrx_word_mode0;\n\n\t \n\tpp->port = p;\n\tmemset(&butterfly_cb, 0, sizeof(butterfly_cb));\n\tbutterfly_cb.private = pp;\n\tpd = parport_register_dev_model(p, \"spi_butterfly\", &butterfly_cb, 0);\n\tif (!pd) {\n\t\tstatus = -ENOMEM;\n\t\tgoto clean0;\n\t}\n\tpp->pd = pd;\n\n\tstatus = parport_claim(pd);\n\tif (status < 0)\n\t\tgoto clean1;\n\n\t \n\tpr_debug(\"%s: powerup/reset Butterfly\\n\", p->name);\n\n\t \n\tparport_frob_control(pp->port, spi_cs_bit, 0);\n\n\t \n\tpp->lastbyte |= vcc_bits;\n\tparport_write_data(pp->port, pp->lastbyte);\n\tmsleep(5);\n\n\t \n\tpp->lastbyte |= butterfly_nreset;\n\tparport_write_data(pp->port, pp->lastbyte);\n\tmsleep(100);\n\n\t \n\tstatus = spi_bitbang_start(&pp->bitbang);\n\tif (status < 0)\n\t\tgoto clean2;\n\n\t \n\n\tpp->info[0].max_speed_hz = 15 * 1000 * 1000;\n\tstrcpy(pp->info[0].modalias, \"mtd_dataflash\");\n\tpp->info[0].platform_data = &flash;\n\tpp->info[0].chip_select = 1;\n\tpp->info[0].controller_data = pp;\n\tpp->dataflash = spi_new_device(pp->bitbang.master, &pp->info[0]);\n\tif (pp->dataflash)\n\t\tpr_debug(\"%s: dataflash at %s\\n\", p->name,\n\t\t\t dev_name(&pp->dataflash->dev));\n\n\tpr_info(\"%s: AVR Butterfly\\n\", p->name);\n\tbutterfly = pp;\n\treturn;\n\nclean2:\n\t \n\tparport_write_data(pp->port, 0);\n\n\tparport_release(pp->pd);\nclean1:\n\tparport_unregister_device(pd);\nclean0:\n\tspi_controller_put(host);\ndone:\n\tpr_debug(\"%s: butterfly probe, fail %d\\n\", p->name, status);\n}\n\nstatic void butterfly_detach(struct parport *p)\n{\n\tstruct butterfly\t*pp;\n\n\t \n\tif (!butterfly || butterfly->port != p)\n\t\treturn;\n\tpp = butterfly;\n\tbutterfly = NULL;\n\n\t \n\tspi_bitbang_stop(&pp->bitbang);\n\n\t \n\tparport_write_data(pp->port, 0);\n\tmsleep(10);\n\n\tparport_release(pp->pd);\n\tparport_unregister_device(pp->pd);\n\n\tspi_controller_put(pp->bitbang.master);\n}\n\nstatic struct parport_driver butterfly_driver = {\n\t.name =\t\t\"spi_butterfly\",\n\t.match_port =\tbutterfly_attach,\n\t.detach =\tbutterfly_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(butterfly_driver);\n\nMODULE_DESCRIPTION(\"Parport Adapter driver for AVR Butterfly\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}