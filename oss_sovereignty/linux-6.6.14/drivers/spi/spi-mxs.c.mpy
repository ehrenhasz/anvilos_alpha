{
  "module_name": "spi-mxs.c",
  "hash_id": "560a10c773ac0a05ceac56e6c85f81730d7be33748f9d600db5d50ef2bfcb6ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mxs.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/highmem.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/stmp_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/mxs-spi.h>\n#include <trace/events/spi.h>\n\n#define DRIVER_NAME\t\t\"mxs-spi\"\n\n \n#define SSP_TIMEOUT\t\t10000\n\n#define SG_MAXLEN\t\t0xff00\n\n \n#define TXRX_WRITE\t\t(1<<0)\t \n#define TXRX_DEASSERT_CS\t(1<<1)\t \n\nstruct mxs_spi {\n\tstruct mxs_ssp\t\tssp;\n\tstruct completion\tc;\n\tunsigned int\t\tsck;\t \n};\n\nstatic int mxs_spi_setup_transfer(struct spi_device *dev,\n\t\t\t\t  const struct spi_transfer *t)\n{\n\tstruct mxs_spi *spi = spi_master_get_devdata(dev->master);\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tconst unsigned int hz = min(dev->max_speed_hz, t->speed_hz);\n\n\tif (hz == 0) {\n\t\tdev_err(&dev->dev, \"SPI clock rate of zero not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hz != spi->sck) {\n\t\tmxs_ssp_set_clk_rate(ssp, hz);\n\t\t \n\t\tspi->sck = hz;\n\t\t \n\t}\n\n\twritel(BM_SSP_CTRL0_LOCK_CS,\n\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\twritel(BF_SSP_CTRL1_SSP_MODE(BV_SSP_CTRL1_SSP_MODE__SPI) |\n\t       BF_SSP_CTRL1_WORD_LENGTH(BV_SSP_CTRL1_WORD_LENGTH__EIGHT_BITS) |\n\t       ((dev->mode & SPI_CPOL) ? BM_SSP_CTRL1_POLARITY : 0) |\n\t       ((dev->mode & SPI_CPHA) ? BM_SSP_CTRL1_PHASE : 0),\n\t       ssp->base + HW_SSP_CTRL1(ssp));\n\n\twritel(0x0, ssp->base + HW_SSP_CMD0);\n\twritel(0x0, ssp->base + HW_SSP_CMD1);\n\n\treturn 0;\n}\n\nstatic u32 mxs_spi_cs_to_reg(unsigned cs)\n{\n\tu32 select = 0;\n\n\t \n\tif (cs & 1)\n\t\tselect |= BM_SSP_CTRL0_WAIT_FOR_CMD;\n\tif (cs & 2)\n\t\tselect |= BM_SSP_CTRL0_WAIT_FOR_IRQ;\n\n\treturn select;\n}\n\nstatic int mxs_ssp_wait(struct mxs_spi *spi, int offset, int mask, bool set)\n{\n\tconst unsigned long timeout = jiffies + msecs_to_jiffies(SSP_TIMEOUT);\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tu32 reg;\n\n\tdo {\n\t\treg = readl_relaxed(ssp->base + offset);\n\n\t\tif (!set)\n\t\t\treg = ~reg;\n\n\t\treg &= mask;\n\n\t\tif (reg == mask)\n\t\t\treturn 0;\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void mxs_ssp_dma_irq_callback(void *param)\n{\n\tstruct mxs_spi *spi = param;\n\n\tcomplete(&spi->c);\n}\n\nstatic irqreturn_t mxs_ssp_irq_handler(int irq, void *dev_id)\n{\n\tstruct mxs_ssp *ssp = dev_id;\n\n\tdev_err(ssp->dev, \"%s[%i] CTRL1=%08x STATUS=%08x\\n\",\n\t\t__func__, __LINE__,\n\t\treadl(ssp->base + HW_SSP_CTRL1(ssp)),\n\t\treadl(ssp->base + HW_SSP_STATUS(ssp)));\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxs_spi_txrx_dma(struct mxs_spi *spi,\n\t\t\t    unsigned char *buf, int len,\n\t\t\t    unsigned int flags)\n{\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tconst bool vmalloced_buf = is_vmalloc_addr(buf);\n\tconst int desc_len = vmalloced_buf ? PAGE_SIZE : SG_MAXLEN;\n\tconst int sgs = DIV_ROUND_UP(len, desc_len);\n\tint sg_count;\n\tint min, ret;\n\tu32 ctrl0;\n\tstruct page *vm_page;\n\tstruct {\n\t\tu32\t\t\tpio[4];\n\t\tstruct scatterlist\tsg;\n\t} *dma_xfer;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tdma_xfer = kcalloc(sgs, sizeof(*dma_xfer), GFP_KERNEL);\n\tif (!dma_xfer)\n\t\treturn -ENOMEM;\n\n\treinit_completion(&spi->c);\n\n\t \n\tctrl0 = readl(ssp->base + HW_SSP_CTRL0);\n\tctrl0 &= ~(BM_SSP_CTRL0_XFER_COUNT | BM_SSP_CTRL0_IGNORE_CRC |\n\t\t BM_SSP_CTRL0_READ);\n\tctrl0 |= BM_SSP_CTRL0_DATA_XFER;\n\n\tif (!(flags & TXRX_WRITE))\n\t\tctrl0 |= BM_SSP_CTRL0_READ;\n\n\t \n\tfor (sg_count = 0; sg_count < sgs; sg_count++) {\n\t\t \n\t\tmin = min(len, desc_len);\n\n\t\t \n\t\tif ((sg_count + 1 == sgs) && (flags & TXRX_DEASSERT_CS))\n\t\t\tctrl0 |= BM_SSP_CTRL0_IGNORE_CRC;\n\n\t\tif (ssp->devid == IMX23_SSP) {\n\t\t\tctrl0 &= ~BM_SSP_CTRL0_XFER_COUNT;\n\t\t\tctrl0 |= min;\n\t\t}\n\n\t\tdma_xfer[sg_count].pio[0] = ctrl0;\n\t\tdma_xfer[sg_count].pio[3] = min;\n\n\t\tif (vmalloced_buf) {\n\t\t\tvm_page = vmalloc_to_page(buf);\n\t\t\tif (!vm_page) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_vmalloc;\n\t\t\t}\n\n\t\t\tsg_init_table(&dma_xfer[sg_count].sg, 1);\n\t\t\tsg_set_page(&dma_xfer[sg_count].sg, vm_page,\n\t\t\t\t    min, offset_in_page(buf));\n\t\t} else {\n\t\t\tsg_init_one(&dma_xfer[sg_count].sg, buf, min);\n\t\t}\n\n\t\tret = dma_map_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,\n\t\t\t(flags & TXRX_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\t\tlen -= min;\n\t\tbuf += min;\n\n\t\t \n\t\tdesc = dmaengine_prep_slave_sg(ssp->dmach,\n\t\t\t\t(struct scatterlist *)dma_xfer[sg_count].pio,\n\t\t\t\t(ssp->devid == IMX23_SSP) ? 1 : 4,\n\t\t\t\tDMA_TRANS_NONE,\n\t\t\t\tsg_count ? DMA_PREP_INTERRUPT : 0);\n\t\tif (!desc) {\n\t\t\tdev_err(ssp->dev,\n\t\t\t\t\"Failed to get PIO reg. write descriptor.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_mapped;\n\t\t}\n\n\t\tdesc = dmaengine_prep_slave_sg(ssp->dmach,\n\t\t\t\t&dma_xfer[sg_count].sg, 1,\n\t\t\t\t(flags & TXRX_WRITE) ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\t\tif (!desc) {\n\t\t\tdev_err(ssp->dev,\n\t\t\t\t\"Failed to get DMA data write descriptor.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_mapped;\n\t\t}\n\t}\n\n\t \n\tdesc->callback = mxs_ssp_dma_irq_callback;\n\tdesc->callback_param = spi;\n\n\t \n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(ssp->dmach);\n\n\tif (!wait_for_completion_timeout(&spi->c,\n\t\t\t\t\t msecs_to_jiffies(SSP_TIMEOUT))) {\n\t\tdev_err(ssp->dev, \"DMA transfer timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tdmaengine_terminate_all(ssp->dmach);\n\t\tgoto err_vmalloc;\n\t}\n\n\tret = 0;\n\nerr_vmalloc:\n\twhile (--sg_count >= 0) {\nerr_mapped:\n\t\tdma_unmap_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,\n\t\t\t(flags & TXRX_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t}\n\n\tkfree(dma_xfer);\n\n\treturn ret;\n}\n\nstatic int mxs_spi_txrx_pio(struct mxs_spi *spi,\n\t\t\t    unsigned char *buf, int len,\n\t\t\t    unsigned int flags)\n{\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\n\twritel(BM_SSP_CTRL0_IGNORE_CRC,\n\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\n\n\twhile (len--) {\n\t\tif (len == 0 && (flags & TXRX_DEASSERT_CS))\n\t\t\twritel(BM_SSP_CTRL0_IGNORE_CRC,\n\t\t\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\t\tif (ssp->devid == IMX23_SSP) {\n\t\t\twritel(BM_SSP_CTRL0_XFER_COUNT,\n\t\t\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\n\t\t\twritel(1,\n\t\t\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\t\t} else {\n\t\t\twritel(1, ssp->base + HW_SSP_XFER_SIZE);\n\t\t}\n\n\t\tif (flags & TXRX_WRITE)\n\t\t\twritel(BM_SSP_CTRL0_READ,\n\t\t\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\n\t\telse\n\t\t\twritel(BM_SSP_CTRL0_READ,\n\t\t\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\t\twritel(BM_SSP_CTRL0_RUN,\n\t\t\t\tssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\t\tif (mxs_ssp_wait(spi, HW_SSP_CTRL0, BM_SSP_CTRL0_RUN, 1))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif (flags & TXRX_WRITE)\n\t\t\twritel(*buf, ssp->base + HW_SSP_DATA(ssp));\n\n\t\twritel(BM_SSP_CTRL0_DATA_XFER,\n\t\t\t     ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\t\tif (!(flags & TXRX_WRITE)) {\n\t\t\tif (mxs_ssp_wait(spi, HW_SSP_STATUS(ssp),\n\t\t\t\t\t\tBM_SSP_STATUS_FIFO_EMPTY, 0))\n\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\t*buf = (readl(ssp->base + HW_SSP_DATA(ssp)) & 0xff);\n\t\t}\n\n\t\tif (mxs_ssp_wait(spi, HW_SSP_CTRL0, BM_SSP_CTRL0_RUN, 0))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tbuf++;\n\t}\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mxs_spi_transfer_one(struct spi_master *master,\n\t\t\t\tstruct spi_message *m)\n{\n\tstruct mxs_spi *spi = spi_master_get_devdata(master);\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tstruct spi_transfer *t;\n\tunsigned int flag;\n\tint status = 0;\n\n\t \n\twritel(BM_SSP_CTRL0_WAIT_FOR_CMD | BM_SSP_CTRL0_WAIT_FOR_IRQ,\n\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\n\twritel(mxs_spi_cs_to_reg(spi_get_chipselect(m->spi, 0)),\n\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\n\t\ttrace_spi_transfer_start(m, t);\n\n\t\tstatus = mxs_spi_setup_transfer(m->spi, t);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tflag = (&t->transfer_list == m->transfers.prev) ^ t->cs_change ?\n\t\t       TXRX_DEASSERT_CS : 0;\n\n\t\t \n\t\tif (t->len < 32) {\n\t\t\twritel(BM_SSP_CTRL1_DMA_ENABLE,\n\t\t\t\tssp->base + HW_SSP_CTRL1(ssp) +\n\t\t\t\tSTMP_OFFSET_REG_CLR);\n\n\t\t\tif (t->tx_buf)\n\t\t\t\tstatus = mxs_spi_txrx_pio(spi,\n\t\t\t\t\t\t(void *)t->tx_buf,\n\t\t\t\t\t\tt->len, flag | TXRX_WRITE);\n\t\t\tif (t->rx_buf)\n\t\t\t\tstatus = mxs_spi_txrx_pio(spi,\n\t\t\t\t\t\tt->rx_buf, t->len,\n\t\t\t\t\t\tflag);\n\t\t} else {\n\t\t\twritel(BM_SSP_CTRL1_DMA_ENABLE,\n\t\t\t\tssp->base + HW_SSP_CTRL1(ssp) +\n\t\t\t\tSTMP_OFFSET_REG_SET);\n\n\t\t\tif (t->tx_buf)\n\t\t\t\tstatus = mxs_spi_txrx_dma(spi,\n\t\t\t\t\t\t(void *)t->tx_buf, t->len,\n\t\t\t\t\t\tflag | TXRX_WRITE);\n\t\t\tif (t->rx_buf)\n\t\t\t\tstatus = mxs_spi_txrx_dma(spi,\n\t\t\t\t\t\tt->rx_buf, t->len,\n\t\t\t\t\t\tflag);\n\t\t}\n\n\t\ttrace_spi_transfer_stop(m, t);\n\n\t\tif (status) {\n\t\t\tstmp_reset_block(ssp->base);\n\t\t\tbreak;\n\t\t}\n\n\t\tm->actual_length += t->len;\n\t}\n\n\tm->status = status;\n\tspi_finalize_current_message(master);\n\n\treturn status;\n}\n\nstatic int mxs_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct mxs_spi *spi = spi_master_get_devdata(master);\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tint ret;\n\n\tclk_disable_unprepare(ssp->clk);\n\n\tret = pinctrl_pm_select_idle_state(dev);\n\tif (ret) {\n\t\tint ret2 = clk_prepare_enable(ssp->clk);\n\n\t\tif (ret2)\n\t\t\tdev_warn(dev, \"Failed to reenable clock after failing pinctrl request (pinctrl: %d, clk: %d)\\n\",\n\t\t\t\t ret, ret2);\n\t}\n\n\treturn ret;\n}\n\nstatic int mxs_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct mxs_spi *spi = spi_master_get_devdata(master);\n\tstruct mxs_ssp *ssp = &spi->ssp;\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ssp->clk);\n\tif (ret)\n\t\tpinctrl_pm_select_idle_state(dev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused mxs_spi_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_master_suspend(master);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\treturn mxs_spi_runtime_suspend(dev);\n\telse\n\t\treturn 0;\n}\n\nstatic int __maybe_unused mxs_spi_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tret = mxs_spi_runtime_resume(dev);\n\telse\n\t\tret = 0;\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_master_resume(master);\n\tif (ret < 0 && !pm_runtime_suspended(dev))\n\t\tmxs_spi_runtime_suspend(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mxs_spi_pm = {\n\tSET_RUNTIME_PM_OPS(mxs_spi_runtime_suspend,\n\t\t\t   mxs_spi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(mxs_spi_suspend, mxs_spi_resume)\n};\n\nstatic const struct of_device_id mxs_spi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-spi\", .data = (void *) IMX23_SSP, },\n\t{ .compatible = \"fsl,imx28-spi\", .data = (void *) IMX28_SSP, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_spi_dt_ids);\n\nstatic int mxs_spi_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(mxs_spi_dt_ids, &pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spi_master *master;\n\tstruct mxs_spi *spi;\n\tstruct mxs_ssp *ssp;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint devid, clk_freq;\n\tint ret = 0, irq_err;\n\n\t \n\tconst int clk_freq_default = 160000000;\n\n\tirq_err = platform_get_irq(pdev, 0);\n\tif (irq_err < 0)\n\t\treturn irq_err;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tdevid = (enum mxs_ssp_id) of_id->data;\n\tret = of_property_read_u32(np, \"clock-frequency\",\n\t\t\t\t   &clk_freq);\n\tif (ret)\n\t\tclk_freq = clk_freq_default;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*spi));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tmaster->transfer_one_message = mxs_spi_transfer_one;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA;\n\tmaster->num_chipselect = 3;\n\tmaster->dev.of_node = np;\n\tmaster->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tmaster->auto_runtime_pm = true;\n\n\tspi = spi_master_get_devdata(master);\n\tssp = &spi->ssp;\n\tssp->dev = &pdev->dev;\n\tssp->clk = clk;\n\tssp->base = base;\n\tssp->devid = devid;\n\n\tinit_completion(&spi->c);\n\n\tret = devm_request_irq(&pdev->dev, irq_err, mxs_ssp_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), ssp);\n\tif (ret)\n\t\tgoto out_master_free;\n\n\tssp->dmach = dma_request_chan(&pdev->dev, \"rx-tx\");\n\tif (IS_ERR(ssp->dmach)) {\n\t\tdev_err(ssp->dev, \"Failed to request DMA\\n\");\n\t\tret = PTR_ERR(ssp->dmach);\n\t\tgoto out_master_free;\n\t}\n\n\tpm_runtime_enable(ssp->dev);\n\tif (!pm_runtime_enabled(ssp->dev)) {\n\t\tret = mxs_spi_runtime_resume(ssp->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ssp->dev, \"runtime resume failed\\n\");\n\t\t\tgoto out_dma_release;\n\t\t}\n\t}\n\n\tret = pm_runtime_resume_and_get(ssp->dev);\n\tif (ret < 0) {\n\t\tdev_err(ssp->dev, \"runtime_get_sync failed\\n\");\n\t\tgoto out_pm_runtime_disable;\n\t}\n\n\tclk_set_rate(ssp->clk, clk_freq);\n\n\tret = stmp_reset_block(ssp->base);\n\tif (ret)\n\t\tgoto out_pm_runtime_put;\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot register SPI master, %d\\n\", ret);\n\t\tgoto out_pm_runtime_put;\n\t}\n\n\tpm_runtime_put(ssp->dev);\n\n\treturn 0;\n\nout_pm_runtime_put:\n\tpm_runtime_put(ssp->dev);\nout_pm_runtime_disable:\n\tpm_runtime_disable(ssp->dev);\nout_dma_release:\n\tdma_release_channel(ssp->dmach);\nout_master_free:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void mxs_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct mxs_spi *spi;\n\tstruct mxs_ssp *ssp;\n\n\tmaster = platform_get_drvdata(pdev);\n\tspi = spi_master_get_devdata(master);\n\tssp = &spi->ssp;\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tmxs_spi_runtime_suspend(&pdev->dev);\n\n\tdma_release_channel(ssp->dmach);\n}\n\nstatic struct platform_driver mxs_spi_driver = {\n\t.probe\t= mxs_spi_probe,\n\t.remove_new = mxs_spi_remove,\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = mxs_spi_dt_ids,\n\t\t.pm = &mxs_spi_pm,\n\t},\n};\n\nmodule_platform_driver(mxs_spi_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"MXS SPI master driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxs-spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}