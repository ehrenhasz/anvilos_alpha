{
  "module_name": "spi-fsl-dspi.c",
  "hash_id": "e881af592f043fd846c5db31737921dd3fa13b4eb4412d98426fbfdd1ad58de4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-dspi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-fsl-dspi.h>\n\n#define DRIVER_NAME\t\t\t\"fsl-dspi\"\n\n#define SPI_MCR\t\t\t\t0x00\n#define SPI_MCR_HOST\t\t\tBIT(31)\n#define SPI_MCR_PCSIS(x)\t\t((x) << 16)\n#define SPI_MCR_CLR_TXF\t\t\tBIT(11)\n#define SPI_MCR_CLR_RXF\t\t\tBIT(10)\n#define SPI_MCR_XSPI\t\t\tBIT(3)\n#define SPI_MCR_DIS_TXF\t\t\tBIT(13)\n#define SPI_MCR_DIS_RXF\t\t\tBIT(12)\n#define SPI_MCR_HALT\t\t\tBIT(0)\n\n#define SPI_TCR\t\t\t\t0x08\n#define SPI_TCR_GET_TCNT(x)\t\t(((x) & GENMASK(31, 16)) >> 16)\n\n#define SPI_CTAR(x)\t\t\t(0x0c + (((x) & GENMASK(1, 0)) * 4))\n#define SPI_CTAR_FMSZ(x)\t\t(((x) << 27) & GENMASK(30, 27))\n#define SPI_CTAR_CPOL\t\t\tBIT(26)\n#define SPI_CTAR_CPHA\t\t\tBIT(25)\n#define SPI_CTAR_LSBFE\t\t\tBIT(24)\n#define SPI_CTAR_PCSSCK(x)\t\t(((x) << 22) & GENMASK(23, 22))\n#define SPI_CTAR_PASC(x)\t\t(((x) << 20) & GENMASK(21, 20))\n#define SPI_CTAR_PDT(x)\t\t\t(((x) << 18) & GENMASK(19, 18))\n#define SPI_CTAR_PBR(x)\t\t\t(((x) << 16) & GENMASK(17, 16))\n#define SPI_CTAR_CSSCK(x)\t\t(((x) << 12) & GENMASK(15, 12))\n#define SPI_CTAR_ASC(x)\t\t\t(((x) << 8) & GENMASK(11, 8))\n#define SPI_CTAR_DT(x)\t\t\t(((x) << 4) & GENMASK(7, 4))\n#define SPI_CTAR_BR(x)\t\t\t((x) & GENMASK(3, 0))\n#define SPI_CTAR_SCALE_BITS\t\t0xf\n\n#define SPI_CTAR0_SLAVE\t\t\t0x0c\n\n#define SPI_SR\t\t\t\t0x2c\n#define SPI_SR_TCFQF\t\t\tBIT(31)\n#define SPI_SR_TFUF\t\t\tBIT(27)\n#define SPI_SR_TFFF\t\t\tBIT(25)\n#define SPI_SR_CMDTCF\t\t\tBIT(23)\n#define SPI_SR_SPEF\t\t\tBIT(21)\n#define SPI_SR_RFOF\t\t\tBIT(19)\n#define SPI_SR_TFIWF\t\t\tBIT(18)\n#define SPI_SR_RFDF\t\t\tBIT(17)\n#define SPI_SR_CMDFFF\t\t\tBIT(16)\n#define SPI_SR_CLEAR\t\t\t(SPI_SR_TCFQF | \\\n\t\t\t\t\tSPI_SR_TFUF | SPI_SR_TFFF | \\\n\t\t\t\t\tSPI_SR_CMDTCF | SPI_SR_SPEF | \\\n\t\t\t\t\tSPI_SR_RFOF | SPI_SR_TFIWF | \\\n\t\t\t\t\tSPI_SR_RFDF | SPI_SR_CMDFFF)\n\n#define SPI_RSER_TFFFE\t\t\tBIT(25)\n#define SPI_RSER_TFFFD\t\t\tBIT(24)\n#define SPI_RSER_RFDFE\t\t\tBIT(17)\n#define SPI_RSER_RFDFD\t\t\tBIT(16)\n\n#define SPI_RSER\t\t\t0x30\n#define SPI_RSER_TCFQE\t\t\tBIT(31)\n#define SPI_RSER_CMDTCFE\t\tBIT(23)\n\n#define SPI_PUSHR\t\t\t0x34\n#define SPI_PUSHR_CMD_CONT\t\tBIT(15)\n#define SPI_PUSHR_CMD_CTAS(x)\t\t(((x) << 12 & GENMASK(14, 12)))\n#define SPI_PUSHR_CMD_EOQ\t\tBIT(11)\n#define SPI_PUSHR_CMD_CTCNT\t\tBIT(10)\n#define SPI_PUSHR_CMD_PCS(x)\t\t(BIT(x) & GENMASK(5, 0))\n\n#define SPI_PUSHR_SLAVE\t\t\t0x34\n\n#define SPI_POPR\t\t\t0x38\n\n#define SPI_TXFR0\t\t\t0x3c\n#define SPI_TXFR1\t\t\t0x40\n#define SPI_TXFR2\t\t\t0x44\n#define SPI_TXFR3\t\t\t0x48\n#define SPI_RXFR0\t\t\t0x7c\n#define SPI_RXFR1\t\t\t0x80\n#define SPI_RXFR2\t\t\t0x84\n#define SPI_RXFR3\t\t\t0x88\n\n#define SPI_CTARE(x)\t\t\t(0x11c + (((x) & GENMASK(1, 0)) * 4))\n#define SPI_CTARE_FMSZE(x)\t\t(((x) & 0x1) << 16)\n#define SPI_CTARE_DTCP(x)\t\t((x) & 0x7ff)\n\n#define SPI_SREX\t\t\t0x13c\n\n#define SPI_FRAME_BITS(bits)\t\tSPI_CTAR_FMSZ((bits) - 1)\n#define SPI_FRAME_EBITS(bits)\t\tSPI_CTARE_FMSZE(((bits) - 1) >> 4)\n\n#define DMA_COMPLETION_TIMEOUT\t\tmsecs_to_jiffies(3000)\n\nstruct chip_data {\n\tu32\t\t\tctar_val;\n};\n\nenum dspi_trans_mode {\n\tDSPI_XSPI_MODE,\n\tDSPI_DMA_MODE,\n};\n\nstruct fsl_dspi_devtype_data {\n\tenum dspi_trans_mode\ttrans_mode;\n\tu8\t\t\tmax_clock_factor;\n\tint\t\t\tfifo_size;\n};\n\nenum {\n\tLS1021A,\n\tLS1012A,\n\tLS1028A,\n\tLS1043A,\n\tLS1046A,\n\tLS2080A,\n\tLS2085A,\n\tLX2160A,\n\tMCF5441X,\n\tVF610,\n};\n\nstatic const struct fsl_dspi_devtype_data devtype_data[] = {\n\t[VF610] = {\n\t\t.trans_mode\t\t= DSPI_DMA_MODE,\n\t\t.max_clock_factor\t= 2,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[LS1021A] = {\n\t\t \n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[LS1012A] = {\n\t\t \n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 16,\n\t},\n\t[LS1028A] = {\n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[LS1043A] = {\n\t\t \n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 16,\n\t},\n\t[LS1046A] = {\n\t\t \n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 16,\n\t},\n\t[LS2080A] = {\n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[LS2085A] = {\n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[LX2160A] = {\n\t\t.trans_mode\t\t= DSPI_XSPI_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 4,\n\t},\n\t[MCF5441X] = {\n\t\t.trans_mode\t\t= DSPI_DMA_MODE,\n\t\t.max_clock_factor\t= 8,\n\t\t.fifo_size\t\t= 16,\n\t},\n};\n\nstruct fsl_dspi_dma {\n\tu32\t\t\t\t\t*tx_dma_buf;\n\tstruct dma_chan\t\t\t\t*chan_tx;\n\tdma_addr_t\t\t\t\ttx_dma_phys;\n\tstruct completion\t\t\tcmd_tx_complete;\n\tstruct dma_async_tx_descriptor\t\t*tx_desc;\n\n\tu32\t\t\t\t\t*rx_dma_buf;\n\tstruct dma_chan\t\t\t\t*chan_rx;\n\tdma_addr_t\t\t\t\trx_dma_phys;\n\tstruct completion\t\t\tcmd_rx_complete;\n\tstruct dma_async_tx_descriptor\t\t*rx_desc;\n};\n\nstruct fsl_dspi {\n\tstruct spi_controller\t\t\t*ctlr;\n\tstruct platform_device\t\t\t*pdev;\n\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct regmap\t\t\t\t*regmap_pushr;\n\tint\t\t\t\t\tirq;\n\tstruct clk\t\t\t\t*clk;\n\n\tstruct spi_transfer\t\t\t*cur_transfer;\n\tstruct spi_message\t\t\t*cur_msg;\n\tstruct chip_data\t\t\t*cur_chip;\n\tsize_t\t\t\t\t\tprogress;\n\tsize_t\t\t\t\t\tlen;\n\tconst void\t\t\t\t*tx;\n\tvoid\t\t\t\t\t*rx;\n\tu16\t\t\t\t\ttx_cmd;\n\tconst struct fsl_dspi_devtype_data\t*devtype_data;\n\n\tstruct completion\t\t\txfer_done;\n\n\tstruct fsl_dspi_dma\t\t\t*dma;\n\n\tint\t\t\t\t\toper_word_size;\n\tint\t\t\t\t\toper_bits_per_word;\n\n\tint\t\t\t\t\twords_in_flight;\n\n\t \n\tint\t\t\t\t\tpushr_cmd;\n\tint\t\t\t\t\tpushr_tx;\n\n\tvoid (*host_to_dev)(struct fsl_dspi *dspi, u32 *txdata);\n\tvoid (*dev_to_host)(struct fsl_dspi *dspi, u32 rxdata);\n};\n\nstatic void dspi_native_host_to_dev(struct fsl_dspi *dspi, u32 *txdata)\n{\n\tswitch (dspi->oper_word_size) {\n\tcase 1:\n\t\t*txdata = *(u8 *)dspi->tx;\n\t\tbreak;\n\tcase 2:\n\t\t*txdata = *(u16 *)dspi->tx;\n\t\tbreak;\n\tcase 4:\n\t\t*txdata = *(u32 *)dspi->tx;\n\t\tbreak;\n\t}\n\tdspi->tx += dspi->oper_word_size;\n}\n\nstatic void dspi_native_dev_to_host(struct fsl_dspi *dspi, u32 rxdata)\n{\n\tswitch (dspi->oper_word_size) {\n\tcase 1:\n\t\t*(u8 *)dspi->rx = rxdata;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)dspi->rx = rxdata;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)dspi->rx = rxdata;\n\t\tbreak;\n\t}\n\tdspi->rx += dspi->oper_word_size;\n}\n\nstatic void dspi_8on32_host_to_dev(struct fsl_dspi *dspi, u32 *txdata)\n{\n\t*txdata = cpu_to_be32(*(u32 *)dspi->tx);\n\tdspi->tx += sizeof(u32);\n}\n\nstatic void dspi_8on32_dev_to_host(struct fsl_dspi *dspi, u32 rxdata)\n{\n\t*(u32 *)dspi->rx = be32_to_cpu(rxdata);\n\tdspi->rx += sizeof(u32);\n}\n\nstatic void dspi_8on16_host_to_dev(struct fsl_dspi *dspi, u32 *txdata)\n{\n\t*txdata = cpu_to_be16(*(u16 *)dspi->tx);\n\tdspi->tx += sizeof(u16);\n}\n\nstatic void dspi_8on16_dev_to_host(struct fsl_dspi *dspi, u32 rxdata)\n{\n\t*(u16 *)dspi->rx = be16_to_cpu(rxdata);\n\tdspi->rx += sizeof(u16);\n}\n\nstatic void dspi_16on32_host_to_dev(struct fsl_dspi *dspi, u32 *txdata)\n{\n\tu16 hi = *(u16 *)dspi->tx;\n\tu16 lo = *(u16 *)(dspi->tx + 2);\n\n\t*txdata = (u32)hi << 16 | lo;\n\tdspi->tx += sizeof(u32);\n}\n\nstatic void dspi_16on32_dev_to_host(struct fsl_dspi *dspi, u32 rxdata)\n{\n\tu16 hi = rxdata & 0xffff;\n\tu16 lo = rxdata >> 16;\n\n\t*(u16 *)dspi->rx = lo;\n\t*(u16 *)(dspi->rx + 2) = hi;\n\tdspi->rx += sizeof(u32);\n}\n\n \nstatic u32 dspi_pop_tx(struct fsl_dspi *dspi)\n{\n\tu32 txdata = 0;\n\n\tif (dspi->tx)\n\t\tdspi->host_to_dev(dspi, &txdata);\n\tdspi->len -= dspi->oper_word_size;\n\treturn txdata;\n}\n\n \nstatic u32 dspi_pop_tx_pushr(struct fsl_dspi *dspi)\n{\n\tu16 cmd = dspi->tx_cmd, data = dspi_pop_tx(dspi);\n\n\tif (spi_controller_is_target(dspi->ctlr))\n\t\treturn data;\n\n\tif (dspi->len > 0)\n\t\tcmd |= SPI_PUSHR_CMD_CONT;\n\treturn cmd << 16 | data;\n}\n\n \nstatic void dspi_push_rx(struct fsl_dspi *dspi, u32 rxdata)\n{\n\tif (!dspi->rx)\n\t\treturn;\n\tdspi->dev_to_host(dspi, rxdata);\n}\n\nstatic void dspi_tx_dma_callback(void *arg)\n{\n\tstruct fsl_dspi *dspi = arg;\n\tstruct fsl_dspi_dma *dma = dspi->dma;\n\n\tcomplete(&dma->cmd_tx_complete);\n}\n\nstatic void dspi_rx_dma_callback(void *arg)\n{\n\tstruct fsl_dspi *dspi = arg;\n\tstruct fsl_dspi_dma *dma = dspi->dma;\n\tint i;\n\n\tif (dspi->rx) {\n\t\tfor (i = 0; i < dspi->words_in_flight; i++)\n\t\t\tdspi_push_rx(dspi, dspi->dma->rx_dma_buf[i]);\n\t}\n\n\tcomplete(&dma->cmd_rx_complete);\n}\n\nstatic int dspi_next_xfer_dma_submit(struct fsl_dspi *dspi)\n{\n\tstruct device *dev = &dspi->pdev->dev;\n\tstruct fsl_dspi_dma *dma = dspi->dma;\n\tint time_left;\n\tint i;\n\n\tfor (i = 0; i < dspi->words_in_flight; i++)\n\t\tdspi->dma->tx_dma_buf[i] = dspi_pop_tx_pushr(dspi);\n\n\tdma->tx_desc = dmaengine_prep_slave_single(dma->chan_tx,\n\t\t\t\t\tdma->tx_dma_phys,\n\t\t\t\t\tdspi->words_in_flight *\n\t\t\t\t\tDMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!dma->tx_desc) {\n\t\tdev_err(dev, \"Not able to get desc for DMA xfer\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma->tx_desc->callback = dspi_tx_dma_callback;\n\tdma->tx_desc->callback_param = dspi;\n\tif (dma_submit_error(dmaengine_submit(dma->tx_desc))) {\n\t\tdev_err(dev, \"DMA submit failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma->rx_desc = dmaengine_prep_slave_single(dma->chan_rx,\n\t\t\t\t\tdma->rx_dma_phys,\n\t\t\t\t\tdspi->words_in_flight *\n\t\t\t\t\tDMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!dma->rx_desc) {\n\t\tdev_err(dev, \"Not able to get desc for DMA xfer\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma->rx_desc->callback = dspi_rx_dma_callback;\n\tdma->rx_desc->callback_param = dspi;\n\tif (dma_submit_error(dmaengine_submit(dma->rx_desc))) {\n\t\tdev_err(dev, \"DMA submit failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treinit_completion(&dspi->dma->cmd_rx_complete);\n\treinit_completion(&dspi->dma->cmd_tx_complete);\n\n\tdma_async_issue_pending(dma->chan_rx);\n\tdma_async_issue_pending(dma->chan_tx);\n\n\tif (spi_controller_is_target(dspi->ctlr)) {\n\t\twait_for_completion_interruptible(&dspi->dma->cmd_rx_complete);\n\t\treturn 0;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&dspi->dma->cmd_tx_complete,\n\t\t\t\t\t\tDMA_COMPLETION_TIMEOUT);\n\tif (time_left == 0) {\n\t\tdev_err(dev, \"DMA tx timeout\\n\");\n\t\tdmaengine_terminate_all(dma->chan_tx);\n\t\tdmaengine_terminate_all(dma->chan_rx);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&dspi->dma->cmd_rx_complete,\n\t\t\t\t\t\tDMA_COMPLETION_TIMEOUT);\n\tif (time_left == 0) {\n\t\tdev_err(dev, \"DMA rx timeout\\n\");\n\t\tdmaengine_terminate_all(dma->chan_tx);\n\t\tdmaengine_terminate_all(dma->chan_rx);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void dspi_setup_accel(struct fsl_dspi *dspi);\n\nstatic int dspi_dma_xfer(struct fsl_dspi *dspi)\n{\n\tstruct spi_message *message = dspi->cur_msg;\n\tstruct device *dev = &dspi->pdev->dev;\n\tint ret = 0;\n\n\t \n\twhile (dspi->len) {\n\t\t \n\t\tdspi_setup_accel(dspi);\n\n\t\tdspi->words_in_flight = dspi->len / dspi->oper_word_size;\n\t\tif (dspi->words_in_flight > dspi->devtype_data->fifo_size)\n\t\t\tdspi->words_in_flight = dspi->devtype_data->fifo_size;\n\n\t\tmessage->actual_length += dspi->words_in_flight *\n\t\t\t\t\t  dspi->oper_word_size;\n\n\t\tret = dspi_next_xfer_dma_submit(dspi);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"DMA transfer failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int dspi_request_dma(struct fsl_dspi *dspi, phys_addr_t phy_addr)\n{\n\tint dma_bufsize = dspi->devtype_data->fifo_size * 2;\n\tstruct device *dev = &dspi->pdev->dev;\n\tstruct dma_slave_config cfg;\n\tstruct fsl_dspi_dma *dma;\n\tint ret;\n\n\tdma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn -ENOMEM;\n\n\tdma->chan_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(dma->chan_rx)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(dma->chan_rx),\n\t\t\t\"rx dma channel not available\\n\");\n\t}\n\n\tdma->chan_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(dma->chan_tx)) {\n\t\tret = PTR_ERR(dma->chan_tx);\n\t\tdev_err_probe(dev, ret, \"tx dma channel not available\\n\");\n\t\tgoto err_tx_channel;\n\t}\n\n\tdma->tx_dma_buf = dma_alloc_coherent(dma->chan_tx->device->dev,\n\t\t\t\t\t     dma_bufsize, &dma->tx_dma_phys,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dma->tx_dma_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_tx_dma_buf;\n\t}\n\n\tdma->rx_dma_buf = dma_alloc_coherent(dma->chan_rx->device->dev,\n\t\t\t\t\t     dma_bufsize, &dma->rx_dma_phys,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dma->rx_dma_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rx_dma_buf;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.src_addr = phy_addr + SPI_POPR;\n\tcfg.dst_addr = phy_addr + SPI_PUSHR;\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_maxburst = 1;\n\tcfg.dst_maxburst = 1;\n\n\tcfg.direction = DMA_DEV_TO_MEM;\n\tret = dmaengine_slave_config(dma->chan_rx, &cfg);\n\tif (ret) {\n\t\tdev_err(dev, \"can't configure rx dma channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_slave_config;\n\t}\n\n\tcfg.direction = DMA_MEM_TO_DEV;\n\tret = dmaengine_slave_config(dma->chan_tx, &cfg);\n\tif (ret) {\n\t\tdev_err(dev, \"can't configure tx dma channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_slave_config;\n\t}\n\n\tdspi->dma = dma;\n\tinit_completion(&dma->cmd_tx_complete);\n\tinit_completion(&dma->cmd_rx_complete);\n\n\treturn 0;\n\nerr_slave_config:\n\tdma_free_coherent(dma->chan_rx->device->dev,\n\t\t\t  dma_bufsize, dma->rx_dma_buf, dma->rx_dma_phys);\nerr_rx_dma_buf:\n\tdma_free_coherent(dma->chan_tx->device->dev,\n\t\t\t  dma_bufsize, dma->tx_dma_buf, dma->tx_dma_phys);\nerr_tx_dma_buf:\n\tdma_release_channel(dma->chan_tx);\nerr_tx_channel:\n\tdma_release_channel(dma->chan_rx);\n\n\tdevm_kfree(dev, dma);\n\tdspi->dma = NULL;\n\n\treturn ret;\n}\n\nstatic void dspi_release_dma(struct fsl_dspi *dspi)\n{\n\tint dma_bufsize = dspi->devtype_data->fifo_size * 2;\n\tstruct fsl_dspi_dma *dma = dspi->dma;\n\n\tif (!dma)\n\t\treturn;\n\n\tif (dma->chan_tx) {\n\t\tdma_free_coherent(dma->chan_tx->device->dev, dma_bufsize,\n\t\t\t\t  dma->tx_dma_buf, dma->tx_dma_phys);\n\t\tdma_release_channel(dma->chan_tx);\n\t}\n\n\tif (dma->chan_rx) {\n\t\tdma_free_coherent(dma->chan_rx->device->dev, dma_bufsize,\n\t\t\t\t  dma->rx_dma_buf, dma->rx_dma_phys);\n\t\tdma_release_channel(dma->chan_rx);\n\t}\n}\n\nstatic void hz_to_spi_baud(char *pbr, char *br, int speed_hz,\n\t\t\t   unsigned long clkrate)\n{\n\t \n\tint pbr_tbl[4] = {2, 3, 5, 7};\n\tint brs[16] = {\t2,\t4,\t6,\t8,\n\t\t\t16,\t32,\t64,\t128,\n\t\t\t256,\t512,\t1024,\t2048,\n\t\t\t4096,\t8192,\t16384,\t32768 };\n\tint scale_needed, scale, minscale = INT_MAX;\n\tint i, j;\n\n\tscale_needed = clkrate / speed_hz;\n\tif (clkrate % speed_hz)\n\t\tscale_needed++;\n\n\tfor (i = 0; i < ARRAY_SIZE(brs); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(pbr_tbl); j++) {\n\t\t\tscale = brs[i] * pbr_tbl[j];\n\t\t\tif (scale >= scale_needed) {\n\t\t\t\tif (scale < minscale) {\n\t\t\t\t\tminscale = scale;\n\t\t\t\t\t*br = i;\n\t\t\t\t\t*pbr = j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (minscale == INT_MAX) {\n\t\tpr_warn(\"Can not find valid baud rate,speed_hz is %d,clkrate is %ld, we use the max prescaler value.\\n\",\n\t\t\tspeed_hz, clkrate);\n\t\t*pbr = ARRAY_SIZE(pbr_tbl) - 1;\n\t\t*br =  ARRAY_SIZE(brs) - 1;\n\t}\n}\n\nstatic void ns_delay_scale(char *psc, char *sc, int delay_ns,\n\t\t\t   unsigned long clkrate)\n{\n\tint scale_needed, scale, minscale = INT_MAX;\n\tint pscale_tbl[4] = {1, 3, 5, 7};\n\tu32 remainder;\n\tint i, j;\n\n\tscale_needed = div_u64_rem((u64)delay_ns * clkrate, NSEC_PER_SEC,\n\t\t\t\t   &remainder);\n\tif (remainder)\n\t\tscale_needed++;\n\n\tfor (i = 0; i < ARRAY_SIZE(pscale_tbl); i++)\n\t\tfor (j = 0; j <= SPI_CTAR_SCALE_BITS; j++) {\n\t\t\tscale = pscale_tbl[i] * (2 << j);\n\t\t\tif (scale >= scale_needed) {\n\t\t\t\tif (scale < minscale) {\n\t\t\t\t\tminscale = scale;\n\t\t\t\t\t*psc = i;\n\t\t\t\t\t*sc = j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (minscale == INT_MAX) {\n\t\tpr_warn(\"Cannot find correct scale values for %dns delay at clkrate %ld, using max prescaler value\",\n\t\t\tdelay_ns, clkrate);\n\t\t*psc = ARRAY_SIZE(pscale_tbl) - 1;\n\t\t*sc = SPI_CTAR_SCALE_BITS;\n\t}\n}\n\nstatic void dspi_pushr_cmd_write(struct fsl_dspi *dspi, u16 cmd)\n{\n\t \n\tif (dspi->len > dspi->oper_word_size)\n\t\tcmd |= SPI_PUSHR_CMD_CONT;\n\tregmap_write(dspi->regmap_pushr, dspi->pushr_cmd, cmd);\n}\n\nstatic void dspi_pushr_txdata_write(struct fsl_dspi *dspi, u16 txdata)\n{\n\tregmap_write(dspi->regmap_pushr, dspi->pushr_tx, txdata);\n}\n\nstatic void dspi_xspi_fifo_write(struct fsl_dspi *dspi, int num_words)\n{\n\tint num_bytes = num_words * dspi->oper_word_size;\n\tu16 tx_cmd = dspi->tx_cmd;\n\n\t \n\tif (!(dspi->tx_cmd & SPI_PUSHR_CMD_CONT) && num_bytes == dspi->len)\n\t\ttx_cmd |= SPI_PUSHR_CMD_EOQ;\n\n\t \n\tregmap_write(dspi->regmap, SPI_CTARE(0),\n\t\t     SPI_FRAME_EBITS(dspi->oper_bits_per_word) |\n\t\t     SPI_CTARE_DTCP(num_words));\n\n\t \n\tdspi_pushr_cmd_write(dspi, tx_cmd);\n\n\t \n\twhile (num_words--) {\n\t\tu32 data = dspi_pop_tx(dspi);\n\n\t\tdspi_pushr_txdata_write(dspi, data & 0xFFFF);\n\t\tif (dspi->oper_bits_per_word > 16)\n\t\t\tdspi_pushr_txdata_write(dspi, data >> 16);\n\t}\n}\n\nstatic u32 dspi_popr_read(struct fsl_dspi *dspi)\n{\n\tu32 rxdata = 0;\n\n\tregmap_read(dspi->regmap, SPI_POPR, &rxdata);\n\treturn rxdata;\n}\n\nstatic void dspi_fifo_read(struct fsl_dspi *dspi)\n{\n\tint num_fifo_entries = dspi->words_in_flight;\n\n\t \n\twhile (num_fifo_entries--)\n\t\tdspi_push_rx(dspi, dspi_popr_read(dspi));\n}\n\nstatic void dspi_setup_accel(struct fsl_dspi *dspi)\n{\n\tstruct spi_transfer *xfer = dspi->cur_transfer;\n\tbool odd = !!(dspi->len & 1);\n\n\t \n\tif (xfer->bits_per_word % 8)\n\t\tgoto no_accel;\n\n\tif (!odd && dspi->len <= dspi->devtype_data->fifo_size * 2) {\n\t\tdspi->oper_bits_per_word = 16;\n\t} else if (odd && dspi->len <= dspi->devtype_data->fifo_size) {\n\t\tdspi->oper_bits_per_word = 8;\n\t} else {\n\t\t \n\t\tif (dspi->devtype_data->trans_mode == DSPI_XSPI_MODE)\n\t\t\tdspi->oper_bits_per_word = 32;\n\t\telse\n\t\t\tdspi->oper_bits_per_word = 16;\n\n\t\t \n\t\tdo {\n\t\t\tif (dspi->len >= DIV_ROUND_UP(dspi->oper_bits_per_word, 8))\n\t\t\t\tbreak;\n\n\t\t\tdspi->oper_bits_per_word /= 2;\n\t\t} while (dspi->oper_bits_per_word > 8);\n\t}\n\n\tif (xfer->bits_per_word == 8 && dspi->oper_bits_per_word == 32) {\n\t\tdspi->dev_to_host = dspi_8on32_dev_to_host;\n\t\tdspi->host_to_dev = dspi_8on32_host_to_dev;\n\t} else if (xfer->bits_per_word == 8 && dspi->oper_bits_per_word == 16) {\n\t\tdspi->dev_to_host = dspi_8on16_dev_to_host;\n\t\tdspi->host_to_dev = dspi_8on16_host_to_dev;\n\t} else if (xfer->bits_per_word == 16 && dspi->oper_bits_per_word == 32) {\n\t\tdspi->dev_to_host = dspi_16on32_dev_to_host;\n\t\tdspi->host_to_dev = dspi_16on32_host_to_dev;\n\t} else {\nno_accel:\n\t\tdspi->dev_to_host = dspi_native_dev_to_host;\n\t\tdspi->host_to_dev = dspi_native_host_to_dev;\n\t\tdspi->oper_bits_per_word = xfer->bits_per_word;\n\t}\n\n\tdspi->oper_word_size = DIV_ROUND_UP(dspi->oper_bits_per_word, 8);\n\n\t \n\tregmap_write(dspi->regmap, SPI_CTAR(0),\n\t\t     dspi->cur_chip->ctar_val |\n\t\t     SPI_FRAME_BITS(dspi->oper_bits_per_word));\n}\n\nstatic void dspi_fifo_write(struct fsl_dspi *dspi)\n{\n\tint num_fifo_entries = dspi->devtype_data->fifo_size;\n\tstruct spi_transfer *xfer = dspi->cur_transfer;\n\tstruct spi_message *msg = dspi->cur_msg;\n\tint num_words, num_bytes;\n\n\tdspi_setup_accel(dspi);\n\n\t \n\tif (dspi->oper_word_size == 4)\n\t\tnum_fifo_entries /= 2;\n\n\t \n\tnum_words = dspi->len / dspi->oper_word_size;\n\tif (num_words > num_fifo_entries)\n\t\tnum_words = num_fifo_entries;\n\n\t \n\tnum_bytes = num_words * dspi->oper_word_size;\n\tmsg->actual_length += num_bytes;\n\tdspi->progress += num_bytes / DIV_ROUND_UP(xfer->bits_per_word, 8);\n\n\t \n\tdspi->words_in_flight = num_words;\n\n\tspi_take_timestamp_pre(dspi->ctlr, xfer, dspi->progress, !dspi->irq);\n\n\tdspi_xspi_fifo_write(dspi, num_words);\n\t \n\n\tspi_take_timestamp_post(dspi->ctlr, dspi->cur_transfer,\n\t\t\t\tdspi->progress, !dspi->irq);\n}\n\nstatic int dspi_rxtx(struct fsl_dspi *dspi)\n{\n\tdspi_fifo_read(dspi);\n\n\tif (!dspi->len)\n\t\t \n\t\treturn 0;\n\n\tdspi_fifo_write(dspi);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int dspi_poll(struct fsl_dspi *dspi)\n{\n\tint tries = 1000;\n\tu32 spi_sr;\n\n\tdo {\n\t\tregmap_read(dspi->regmap, SPI_SR, &spi_sr);\n\t\tregmap_write(dspi->regmap, SPI_SR, spi_sr);\n\n\t\tif (spi_sr & SPI_SR_CMDTCF)\n\t\t\tbreak;\n\t} while (--tries);\n\n\tif (!tries)\n\t\treturn -ETIMEDOUT;\n\n\treturn dspi_rxtx(dspi);\n}\n\nstatic irqreturn_t dspi_interrupt(int irq, void *dev_id)\n{\n\tstruct fsl_dspi *dspi = (struct fsl_dspi *)dev_id;\n\tu32 spi_sr;\n\n\tregmap_read(dspi->regmap, SPI_SR, &spi_sr);\n\tregmap_write(dspi->regmap, SPI_SR, spi_sr);\n\n\tif (!(spi_sr & SPI_SR_CMDTCF))\n\t\treturn IRQ_NONE;\n\n\tif (dspi_rxtx(dspi) == 0)\n\t\tcomplete(&dspi->xfer_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dspi_assert_cs(struct spi_device *spi, bool *cs)\n{\n\tif (!spi_get_csgpiod(spi, 0) || *cs)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), true);\n\t*cs = true;\n}\n\nstatic void dspi_deassert_cs(struct spi_device *spi, bool *cs)\n{\n\tif (!spi_get_csgpiod(spi, 0) || !*cs)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), false);\n\t*cs = false;\n}\n\nstatic int dspi_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t     struct spi_message *message)\n{\n\tstruct fsl_dspi *dspi = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = message->spi;\n\tstruct spi_transfer *transfer;\n\tbool cs = false;\n\tint status = 0;\n\n\tmessage->actual_length = 0;\n\n\tlist_for_each_entry(transfer, &message->transfers, transfer_list) {\n\t\tdspi->cur_transfer = transfer;\n\t\tdspi->cur_msg = message;\n\t\tdspi->cur_chip = spi_get_ctldata(spi);\n\n\t\tdspi_assert_cs(spi, &cs);\n\n\t\t \n\t\tdspi->tx_cmd = SPI_PUSHR_CMD_CTAS(0);\n\t\tif (!spi_get_csgpiod(spi, 0))\n\t\t\tdspi->tx_cmd |= SPI_PUSHR_CMD_PCS(spi_get_chipselect(spi, 0));\n\n\t\tif (list_is_last(&dspi->cur_transfer->transfer_list,\n\t\t\t\t &dspi->cur_msg->transfers)) {\n\t\t\t \n\t\t\tif (transfer->cs_change)\n\t\t\t\tdspi->tx_cmd |= SPI_PUSHR_CMD_CONT;\n\t\t} else {\n\t\t\t \n\t\t\tif (!transfer->cs_change)\n\t\t\t\tdspi->tx_cmd |= SPI_PUSHR_CMD_CONT;\n\t\t}\n\n\t\tdspi->tx = transfer->tx_buf;\n\t\tdspi->rx = transfer->rx_buf;\n\t\tdspi->len = transfer->len;\n\t\tdspi->progress = 0;\n\n\t\tregmap_update_bits(dspi->regmap, SPI_MCR,\n\t\t\t\t   SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,\n\t\t\t\t   SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);\n\n\t\tspi_take_timestamp_pre(dspi->ctlr, dspi->cur_transfer,\n\t\t\t\t       dspi->progress, !dspi->irq);\n\n\t\tif (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {\n\t\t\tstatus = dspi_dma_xfer(dspi);\n\t\t} else {\n\t\t\tdspi_fifo_write(dspi);\n\n\t\t\tif (dspi->irq) {\n\t\t\t\twait_for_completion(&dspi->xfer_done);\n\t\t\t\treinit_completion(&dspi->xfer_done);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tstatus = dspi_poll(dspi);\n\t\t\t\t} while (status == -EINPROGRESS);\n\t\t\t}\n\t\t}\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tspi_transfer_delay_exec(transfer);\n\n\t\tif (!(dspi->tx_cmd & SPI_PUSHR_CMD_CONT))\n\t\t\tdspi_deassert_cs(spi, &cs);\n\t}\n\n\tmessage->status = status;\n\tspi_finalize_current_message(ctlr);\n\n\treturn status;\n}\n\nstatic int dspi_setup(struct spi_device *spi)\n{\n\tstruct fsl_dspi *dspi = spi_controller_get_devdata(spi->controller);\n\tu32 period_ns = DIV_ROUND_UP(NSEC_PER_SEC, spi->max_speed_hz);\n\tunsigned char br = 0, pbr = 0, pcssck = 0, cssck = 0;\n\tu32 quarter_period_ns = DIV_ROUND_UP(period_ns, 4);\n\tu32 cs_sck_delay = 0, sck_cs_delay = 0;\n\tstruct fsl_dspi_platform_data *pdata;\n\tunsigned char pasc = 0, asc = 0;\n\tstruct chip_data *chip;\n\tunsigned long clkrate;\n\tbool cs = true;\n\n\t \n\tchip = spi_get_ctldata(spi);\n\tif (chip == NULL) {\n\t\tchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpdata = dev_get_platdata(&dspi->pdev->dev);\n\n\tif (!pdata) {\n\t\tof_property_read_u32(spi->dev.of_node, \"fsl,spi-cs-sck-delay\",\n\t\t\t\t     &cs_sck_delay);\n\n\t\tof_property_read_u32(spi->dev.of_node, \"fsl,spi-sck-cs-delay\",\n\t\t\t\t     &sck_cs_delay);\n\t} else {\n\t\tcs_sck_delay = pdata->cs_sck_delay;\n\t\tsck_cs_delay = pdata->sck_cs_delay;\n\t}\n\n\t \n\tif (cs_sck_delay < quarter_period_ns)\n\t\tcs_sck_delay = quarter_period_ns;\n\tif (sck_cs_delay < quarter_period_ns)\n\t\tsck_cs_delay = quarter_period_ns;\n\n\tdev_dbg(&spi->dev,\n\t\t\"DSPI controller timing params: CS-to-SCK delay %u ns, SCK-to-CS delay %u ns\\n\",\n\t\tcs_sck_delay, sck_cs_delay);\n\n\tclkrate = clk_get_rate(dspi->clk);\n\thz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);\n\n\t \n\tns_delay_scale(&pcssck, &cssck, cs_sck_delay, clkrate);\n\n\t \n\tns_delay_scale(&pasc, &asc, sck_cs_delay, clkrate);\n\n\tchip->ctar_val = 0;\n\tif (spi->mode & SPI_CPOL)\n\t\tchip->ctar_val |= SPI_CTAR_CPOL;\n\tif (spi->mode & SPI_CPHA)\n\t\tchip->ctar_val |= SPI_CTAR_CPHA;\n\n\tif (!spi_controller_is_target(dspi->ctlr)) {\n\t\tchip->ctar_val |= SPI_CTAR_PCSSCK(pcssck) |\n\t\t\t\t  SPI_CTAR_CSSCK(cssck) |\n\t\t\t\t  SPI_CTAR_PASC(pasc) |\n\t\t\t\t  SPI_CTAR_ASC(asc) |\n\t\t\t\t  SPI_CTAR_PBR(pbr) |\n\t\t\t\t  SPI_CTAR_BR(br);\n\n\t\tif (spi->mode & SPI_LSB_FIRST)\n\t\t\tchip->ctar_val |= SPI_CTAR_LSBFE;\n\t}\n\n\tgpiod_direction_output(spi_get_csgpiod(spi, 0), false);\n\tdspi_deassert_cs(spi, &cs);\n\n\tspi_set_ctldata(spi, chip);\n\n\treturn 0;\n}\n\nstatic void dspi_cleanup(struct spi_device *spi)\n{\n\tstruct chip_data *chip = spi_get_ctldata(spi);\n\n\tdev_dbg(&spi->dev, \"spi_device %u.%u cleanup\\n\",\n\t\tspi->controller->bus_num, spi_get_chipselect(spi, 0));\n\n\tkfree(chip);\n}\n\nstatic const struct of_device_id fsl_dspi_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,vf610-dspi\",\n\t\t.data = &devtype_data[VF610],\n\t}, {\n\t\t.compatible = \"fsl,ls1021a-v1.0-dspi\",\n\t\t.data = &devtype_data[LS1021A],\n\t}, {\n\t\t.compatible = \"fsl,ls1012a-dspi\",\n\t\t.data = &devtype_data[LS1012A],\n\t}, {\n\t\t.compatible = \"fsl,ls1028a-dspi\",\n\t\t.data = &devtype_data[LS1028A],\n\t}, {\n\t\t.compatible = \"fsl,ls1043a-dspi\",\n\t\t.data = &devtype_data[LS1043A],\n\t}, {\n\t\t.compatible = \"fsl,ls1046a-dspi\",\n\t\t.data = &devtype_data[LS1046A],\n\t}, {\n\t\t.compatible = \"fsl,ls2080a-dspi\",\n\t\t.data = &devtype_data[LS2080A],\n\t}, {\n\t\t.compatible = \"fsl,ls2085a-dspi\",\n\t\t.data = &devtype_data[LS2085A],\n\t}, {\n\t\t.compatible = \"fsl,lx2160a-dspi\",\n\t\t.data = &devtype_data[LX2160A],\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_dspi_dt_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dspi_suspend(struct device *dev)\n{\n\tstruct fsl_dspi *dspi = dev_get_drvdata(dev);\n\n\tif (dspi->irq)\n\t\tdisable_irq(dspi->irq);\n\tspi_controller_suspend(dspi->ctlr);\n\tclk_disable_unprepare(dspi->clk);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int dspi_resume(struct device *dev)\n{\n\tstruct fsl_dspi *dspi = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = clk_prepare_enable(dspi->clk);\n\tif (ret)\n\t\treturn ret;\n\tspi_controller_resume(dspi->ctlr);\n\tif (dspi->irq)\n\t\tenable_irq(dspi->irq);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(dspi_pm, dspi_suspend, dspi_resume);\n\nstatic const struct regmap_range dspi_volatile_ranges[] = {\n\tregmap_reg_range(SPI_MCR, SPI_TCR),\n\tregmap_reg_range(SPI_SR, SPI_SR),\n\tregmap_reg_range(SPI_PUSHR, SPI_RXFR3),\n};\n\nstatic const struct regmap_access_table dspi_volatile_table = {\n\t.yes_ranges\t= dspi_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(dspi_volatile_ranges),\n};\n\nstatic const struct regmap_config dspi_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x88,\n\t.volatile_table\t= &dspi_volatile_table,\n};\n\nstatic const struct regmap_range dspi_xspi_volatile_ranges[] = {\n\tregmap_reg_range(SPI_MCR, SPI_TCR),\n\tregmap_reg_range(SPI_SR, SPI_SR),\n\tregmap_reg_range(SPI_PUSHR, SPI_RXFR3),\n\tregmap_reg_range(SPI_SREX, SPI_SREX),\n};\n\nstatic const struct regmap_access_table dspi_xspi_volatile_table = {\n\t.yes_ranges\t= dspi_xspi_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(dspi_xspi_volatile_ranges),\n};\n\nstatic const struct regmap_config dspi_xspi_regmap_config[] = {\n\t{\n\t\t.reg_bits\t= 32,\n\t\t.val_bits\t= 32,\n\t\t.reg_stride\t= 4,\n\t\t.max_register\t= 0x13c,\n\t\t.volatile_table\t= &dspi_xspi_volatile_table,\n\t},\n\t{\n\t\t.name\t\t= \"pushr\",\n\t\t.reg_bits\t= 16,\n\t\t.val_bits\t= 16,\n\t\t.reg_stride\t= 2,\n\t\t.max_register\t= 0x2,\n\t},\n};\n\nstatic int dspi_init(struct fsl_dspi *dspi)\n{\n\tunsigned int mcr;\n\n\t \n\tmcr = SPI_MCR_PCSIS(GENMASK(dspi->ctlr->max_native_cs - 1, 0));\n\n\tif (dspi->devtype_data->trans_mode == DSPI_XSPI_MODE)\n\t\tmcr |= SPI_MCR_XSPI;\n\tif (!spi_controller_is_target(dspi->ctlr))\n\t\tmcr |= SPI_MCR_HOST;\n\n\tregmap_write(dspi->regmap, SPI_MCR, mcr);\n\tregmap_write(dspi->regmap, SPI_SR, SPI_SR_CLEAR);\n\n\tswitch (dspi->devtype_data->trans_mode) {\n\tcase DSPI_XSPI_MODE:\n\t\tregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_CMDTCFE);\n\t\tbreak;\n\tcase DSPI_DMA_MODE:\n\t\tregmap_write(dspi->regmap, SPI_RSER,\n\t\t\t     SPI_RSER_TFFFE | SPI_RSER_TFFFD |\n\t\t\t     SPI_RSER_RFDFE | SPI_RSER_RFDFD);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dspi->pdev->dev, \"unsupported trans_mode %u\\n\",\n\t\t\tdspi->devtype_data->trans_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dspi_target_abort(struct spi_controller *host)\n{\n\tstruct fsl_dspi *dspi = spi_controller_get_devdata(host);\n\n\t \n\tif (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {\n\t\tdmaengine_terminate_sync(dspi->dma->chan_rx);\n\t\tdmaengine_terminate_sync(dspi->dma->chan_tx);\n\t}\n\n\t \n\tregmap_update_bits(dspi->regmap, SPI_MCR,\n\t\t\t   SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,\n\t\t\t   SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);\n\n\treturn 0;\n}\n\nstatic int dspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct regmap_config *regmap_config;\n\tstruct fsl_dspi_platform_data *pdata;\n\tstruct spi_controller *ctlr;\n\tint ret, cs_num, bus_num = -1;\n\tstruct fsl_dspi *dspi;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tbool big_endian;\n\n\tdspi = devm_kzalloc(&pdev->dev, sizeof(*dspi), GFP_KERNEL);\n\tif (!dspi)\n\t\treturn -ENOMEM;\n\n\tctlr = spi_alloc_host(&pdev->dev, 0);\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tspi_controller_set_devdata(ctlr, dspi);\n\tplatform_set_drvdata(pdev, dspi);\n\n\tdspi->pdev = pdev;\n\tdspi->ctlr = ctlr;\n\n\tctlr->setup = dspi_setup;\n\tctlr->transfer_one_message = dspi_transfer_one_message;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\n\tctlr->cleanup = dspi_cleanup;\n\tctlr->target_abort = dspi_target_abort;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n\tctlr->use_gpio_descriptors = true;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\tctlr->num_chipselect = ctlr->max_native_cs = pdata->cs_num;\n\t\tctlr->bus_num = pdata->bus_num;\n\n\t\t \n\t\tdspi->devtype_data = &devtype_data[MCF5441X];\n\t\tbig_endian = true;\n\t} else {\n\n\t\tret = of_property_read_u32(np, \"spi-num-chipselects\", &cs_num);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"can't get spi-num-chipselects\\n\");\n\t\t\tgoto out_ctlr_put;\n\t\t}\n\t\tctlr->num_chipselect = ctlr->max_native_cs = cs_num;\n\n\t\tof_property_read_u32(np, \"bus-num\", &bus_num);\n\t\tctlr->bus_num = bus_num;\n\n\t\tif (of_property_read_bool(np, \"spi-slave\"))\n\t\t\tctlr->target = true;\n\n\t\tdspi->devtype_data = of_device_get_match_data(&pdev->dev);\n\t\tif (!dspi->devtype_data) {\n\t\t\tdev_err(&pdev->dev, \"can't get devtype_data\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_ctlr_put;\n\t\t}\n\n\t\tbig_endian = of_device_is_big_endian(np);\n\t}\n\tif (big_endian) {\n\t\tdspi->pushr_cmd = 0;\n\t\tdspi->pushr_tx = 2;\n\t} else {\n\t\tdspi->pushr_cmd = 2;\n\t\tdspi->pushr_tx = 0;\n\t}\n\n\tif (dspi->devtype_data->trans_mode == DSPI_XSPI_MODE)\n\t\tctlr->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\telse\n\t\tctlr->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto out_ctlr_put;\n\t}\n\n\tif (dspi->devtype_data->trans_mode == DSPI_XSPI_MODE)\n\t\tregmap_config = &dspi_xspi_regmap_config[0];\n\telse\n\t\tregmap_config = &dspi_regmap_config;\n\tdspi->regmap = devm_regmap_init_mmio(&pdev->dev, base, regmap_config);\n\tif (IS_ERR(dspi->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to init regmap: %ld\\n\",\n\t\t\t\tPTR_ERR(dspi->regmap));\n\t\tret = PTR_ERR(dspi->regmap);\n\t\tgoto out_ctlr_put;\n\t}\n\n\tif (dspi->devtype_data->trans_mode == DSPI_XSPI_MODE) {\n\t\tdspi->regmap_pushr = devm_regmap_init_mmio(\n\t\t\t&pdev->dev, base + SPI_PUSHR,\n\t\t\t&dspi_xspi_regmap_config[1]);\n\t\tif (IS_ERR(dspi->regmap_pushr)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to init pushr regmap: %ld\\n\",\n\t\t\t\tPTR_ERR(dspi->regmap_pushr));\n\t\t\tret = PTR_ERR(dspi->regmap_pushr);\n\t\t\tgoto out_ctlr_put;\n\t\t}\n\t}\n\n\tdspi->clk = devm_clk_get(&pdev->dev, \"dspi\");\n\tif (IS_ERR(dspi->clk)) {\n\t\tret = PTR_ERR(dspi->clk);\n\t\tdev_err(&pdev->dev, \"unable to get clock\\n\");\n\t\tgoto out_ctlr_put;\n\t}\n\tret = clk_prepare_enable(dspi->clk);\n\tif (ret)\n\t\tgoto out_ctlr_put;\n\n\tret = dspi_init(dspi);\n\tif (ret)\n\t\tgoto out_clk_put;\n\n\tdspi->irq = platform_get_irq(pdev, 0);\n\tif (dspi->irq <= 0) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"can't get platform irq, using poll mode\\n\");\n\t\tdspi->irq = 0;\n\t\tgoto poll_mode;\n\t}\n\n\tinit_completion(&dspi->xfer_done);\n\n\tret = request_threaded_irq(dspi->irq, dspi_interrupt, NULL,\n\t\t\t\t   IRQF_SHARED, pdev->name, dspi);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to attach DSPI interrupt\\n\");\n\t\tgoto out_clk_put;\n\t}\n\npoll_mode:\n\n\tif (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {\n\t\tret = dspi_request_dma(dspi, res->start);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"can't get dma channels\\n\");\n\t\t\tgoto out_free_irq;\n\t\t}\n\t}\n\n\tctlr->max_speed_hz =\n\t\tclk_get_rate(dspi->clk) / dspi->devtype_data->max_clock_factor;\n\n\tif (dspi->devtype_data->trans_mode != DSPI_DMA_MODE)\n\t\tctlr->ptp_sts_supported = true;\n\n\tret = spi_register_controller(ctlr);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Problem registering DSPI ctlr\\n\");\n\t\tgoto out_release_dma;\n\t}\n\n\treturn ret;\n\nout_release_dma:\n\tdspi_release_dma(dspi);\nout_free_irq:\n\tif (dspi->irq)\n\t\tfree_irq(dspi->irq, dspi);\nout_clk_put:\n\tclk_disable_unprepare(dspi->clk);\nout_ctlr_put:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic void dspi_remove(struct platform_device *pdev)\n{\n\tstruct fsl_dspi *dspi = platform_get_drvdata(pdev);\n\n\t \n\tspi_unregister_controller(dspi->ctlr);\n\n\t \n\tregmap_update_bits(dspi->regmap, SPI_MCR,\n\t\t\t   SPI_MCR_DIS_TXF | SPI_MCR_DIS_RXF,\n\t\t\t   SPI_MCR_DIS_TXF | SPI_MCR_DIS_RXF);\n\n\t \n\tregmap_update_bits(dspi->regmap, SPI_MCR, SPI_MCR_HALT, SPI_MCR_HALT);\n\n\tdspi_release_dma(dspi);\n\tif (dspi->irq)\n\t\tfree_irq(dspi->irq, dspi);\n\tclk_disable_unprepare(dspi->clk);\n}\n\nstatic void dspi_shutdown(struct platform_device *pdev)\n{\n\tdspi_remove(pdev);\n}\n\nstatic struct platform_driver fsl_dspi_driver = {\n\t.driver.name\t\t= DRIVER_NAME,\n\t.driver.of_match_table\t= fsl_dspi_dt_ids,\n\t.driver.owner\t\t= THIS_MODULE,\n\t.driver.pm\t\t= &dspi_pm,\n\t.probe\t\t\t= dspi_probe,\n\t.remove_new\t\t= dspi_remove,\n\t.shutdown\t\t= dspi_shutdown,\n};\nmodule_platform_driver(fsl_dspi_driver);\n\nMODULE_DESCRIPTION(\"Freescale DSPI Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}