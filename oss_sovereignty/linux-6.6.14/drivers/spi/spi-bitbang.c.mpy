{
  "module_name": "spi-bitbang.c",
  "hash_id": "f90d02e3409bd5c267168a974d19633ebefbb000e328b659a30054e33c684c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bitbang.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n\n#define SPI_BITBANG_CS_DELAY\t100\n\n\n \n\n \n\nstruct spi_bitbang_cs {\n\tunsigned\tnsecs;\t \n\tu32\t\t(*txrx_word)(struct spi_device *spi, unsigned nsecs,\n\t\t\t\t\tu32 word, u8 bits, unsigned flags);\n\tunsigned\t(*txrx_bufs)(struct spi_device *,\n\t\t\t\t\tu32 (*txrx_word)(\n\t\t\t\t\t\tstruct spi_device *spi,\n\t\t\t\t\t\tunsigned nsecs,\n\t\t\t\t\t\tu32 word, u8 bits,\n\t\t\t\t\t\tunsigned flags),\n\t\t\t\t\tunsigned, struct spi_transfer *,\n\t\t\t\t\tunsigned);\n};\n\nstatic unsigned bitbang_txrx_8(\n\tstruct spi_device\t*spi,\n\tu32\t\t\t(*txrx_word)(struct spi_device *spi,\n\t\t\t\t\tunsigned nsecs,\n\t\t\t\t\tu32 word, u8 bits,\n\t\t\t\t\tunsigned flags),\n\tunsigned\t\tns,\n\tstruct spi_transfer\t*t,\n\tunsigned flags\n)\n{\n\tunsigned\t\tbits = t->bits_per_word;\n\tunsigned\t\tcount = t->len;\n\tconst u8\t\t*tx = t->tx_buf;\n\tu8\t\t\t*rx = t->rx_buf;\n\n\twhile (likely(count > 0)) {\n\t\tu8\t\tword = 0;\n\n\t\tif (tx)\n\t\t\tword = *tx++;\n\t\tword = txrx_word(spi, ns, word, bits, flags);\n\t\tif (rx)\n\t\t\t*rx++ = word;\n\t\tcount -= 1;\n\t}\n\treturn t->len - count;\n}\n\nstatic unsigned bitbang_txrx_16(\n\tstruct spi_device\t*spi,\n\tu32\t\t\t(*txrx_word)(struct spi_device *spi,\n\t\t\t\t\tunsigned nsecs,\n\t\t\t\t\tu32 word, u8 bits,\n\t\t\t\t\tunsigned flags),\n\tunsigned\t\tns,\n\tstruct spi_transfer\t*t,\n\tunsigned flags\n)\n{\n\tunsigned\t\tbits = t->bits_per_word;\n\tunsigned\t\tcount = t->len;\n\tconst u16\t\t*tx = t->tx_buf;\n\tu16\t\t\t*rx = t->rx_buf;\n\n\twhile (likely(count > 1)) {\n\t\tu16\t\tword = 0;\n\n\t\tif (tx)\n\t\t\tword = *tx++;\n\t\tword = txrx_word(spi, ns, word, bits, flags);\n\t\tif (rx)\n\t\t\t*rx++ = word;\n\t\tcount -= 2;\n\t}\n\treturn t->len - count;\n}\n\nstatic unsigned bitbang_txrx_32(\n\tstruct spi_device\t*spi,\n\tu32\t\t\t(*txrx_word)(struct spi_device *spi,\n\t\t\t\t\tunsigned nsecs,\n\t\t\t\t\tu32 word, u8 bits,\n\t\t\t\t\tunsigned flags),\n\tunsigned\t\tns,\n\tstruct spi_transfer\t*t,\n\tunsigned flags\n)\n{\n\tunsigned\t\tbits = t->bits_per_word;\n\tunsigned\t\tcount = t->len;\n\tconst u32\t\t*tx = t->tx_buf;\n\tu32\t\t\t*rx = t->rx_buf;\n\n\twhile (likely(count > 3)) {\n\t\tu32\t\tword = 0;\n\n\t\tif (tx)\n\t\t\tword = *tx++;\n\t\tword = txrx_word(spi, ns, word, bits, flags);\n\t\tif (rx)\n\t\t\t*rx++ = word;\n\t\tcount -= 4;\n\t}\n\treturn t->len - count;\n}\n\nint spi_bitbang_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct spi_bitbang_cs\t*cs = spi->controller_state;\n\tu8\t\t\tbits_per_word;\n\tu32\t\t\thz;\n\n\tif (t) {\n\t\tbits_per_word = t->bits_per_word;\n\t\thz = t->speed_hz;\n\t} else {\n\t\tbits_per_word = 0;\n\t\thz = 0;\n\t}\n\n\t \n\tif (!bits_per_word)\n\t\tbits_per_word = spi->bits_per_word;\n\tif (bits_per_word <= 8)\n\t\tcs->txrx_bufs = bitbang_txrx_8;\n\telse if (bits_per_word <= 16)\n\t\tcs->txrx_bufs = bitbang_txrx_16;\n\telse if (bits_per_word <= 32)\n\t\tcs->txrx_bufs = bitbang_txrx_32;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (!hz)\n\t\thz = spi->max_speed_hz;\n\tif (hz) {\n\t\tcs->nsecs = (1000000000/2) / hz;\n\t\tif (cs->nsecs > (MAX_UDELAY_MS * 1000 * 1000))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_setup_transfer);\n\n \nint spi_bitbang_setup(struct spi_device *spi)\n{\n\tstruct spi_bitbang_cs\t*cs = spi->controller_state;\n\tstruct spi_bitbang\t*bitbang;\n\tbool\t\t\tinitial_setup = false;\n\tint\t\t\tretval;\n\n\tbitbang = spi_master_get_devdata(spi->master);\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tspi->controller_state = cs;\n\t\tinitial_setup = true;\n\t}\n\n\t \n\tcs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL|SPI_CPHA)];\n\tif (!cs->txrx_word) {\n\t\tretval = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tif (bitbang->setup_transfer) {\n\t\tretval = bitbang->setup_transfer(spi, NULL);\n\t\tif (retval < 0)\n\t\t\tgoto err_free;\n\t}\n\n\tdev_dbg(&spi->dev, \"%s, %u nsec/bit\\n\", __func__, 2 * cs->nsecs);\n\n\treturn 0;\n\nerr_free:\n\tif (initial_setup)\n\t\tkfree(cs);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_setup);\n\n \nvoid spi_bitbang_cleanup(struct spi_device *spi)\n{\n\tkfree(spi->controller_state);\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_cleanup);\n\nstatic int spi_bitbang_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct spi_bitbang_cs\t*cs = spi->controller_state;\n\tunsigned\t\tnsecs = cs->nsecs;\n\tstruct spi_bitbang\t*bitbang;\n\n\tbitbang = spi_master_get_devdata(spi->master);\n\tif (bitbang->set_line_direction) {\n\t\tint err;\n\n\t\terr = bitbang->set_line_direction(spi, !!(t->tx_buf));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (spi->mode & SPI_3WIRE) {\n\t\tunsigned flags;\n\n\t\tflags = t->tx_buf ? SPI_CONTROLLER_NO_RX : SPI_CONTROLLER_NO_TX;\n\t\treturn cs->txrx_bufs(spi, cs->txrx_word, nsecs, t, flags);\n\t}\n\treturn cs->txrx_bufs(spi, cs->txrx_word, nsecs, t, 0);\n}\n\n \n\n \n\nstatic int spi_bitbang_prepare_hardware(struct spi_master *spi)\n{\n\tstruct spi_bitbang\t*bitbang;\n\n\tbitbang = spi_master_get_devdata(spi);\n\n\tmutex_lock(&bitbang->lock);\n\tbitbang->busy = 1;\n\tmutex_unlock(&bitbang->lock);\n\n\treturn 0;\n}\n\nstatic int spi_bitbang_transfer_one(struct spi_master *master,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *transfer)\n{\n\tstruct spi_bitbang *bitbang = spi_master_get_devdata(master);\n\tint status = 0;\n\n\tif (bitbang->setup_transfer) {\n\t\tstatus = bitbang->setup_transfer(spi, transfer);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (transfer->len)\n\t\tstatus = bitbang->txrx_bufs(spi, transfer);\n\n\tif (status == transfer->len)\n\t\tstatus = 0;\n\telse if (status >= 0)\n\t\tstatus = -EREMOTEIO;\n\nout:\n\tspi_finalize_current_transfer(master);\n\n\treturn status;\n}\n\nstatic int spi_bitbang_unprepare_hardware(struct spi_master *spi)\n{\n\tstruct spi_bitbang\t*bitbang;\n\n\tbitbang = spi_master_get_devdata(spi);\n\n\tmutex_lock(&bitbang->lock);\n\tbitbang->busy = 0;\n\tmutex_unlock(&bitbang->lock);\n\n\treturn 0;\n}\n\nstatic void spi_bitbang_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct spi_bitbang *bitbang = spi_master_get_devdata(spi->master);\n\n\t \n\tenable = (!!(spi->mode & SPI_CS_HIGH) == enable);\n\n\tndelay(SPI_BITBANG_CS_DELAY);\n\tbitbang->chipselect(spi, enable ? BITBANG_CS_ACTIVE :\n\t\t\t    BITBANG_CS_INACTIVE);\n\tndelay(SPI_BITBANG_CS_DELAY);\n}\n\n \n\nint spi_bitbang_init(struct spi_bitbang *bitbang)\n{\n\tstruct spi_master *master = bitbang->master;\n\tbool custom_cs;\n\n\tif (!master)\n\t\treturn -EINVAL;\n\t \n\tcustom_cs = (!master->use_gpio_descriptors ||\n\t\t     (master->flags & SPI_CONTROLLER_GPIO_SS));\n\n\tif (custom_cs && !bitbang->chipselect)\n\t\treturn -EINVAL;\n\n\tmutex_init(&bitbang->lock);\n\n\tif (!master->mode_bits)\n\t\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | bitbang->flags;\n\n\tif (master->transfer || master->transfer_one_message)\n\t\treturn -EINVAL;\n\n\tmaster->prepare_transfer_hardware = spi_bitbang_prepare_hardware;\n\tmaster->unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;\n\tmaster->transfer_one = spi_bitbang_transfer_one;\n\t \n\tif (custom_cs)\n\t\tmaster->set_cs = spi_bitbang_set_cs;\n\n\tif (!bitbang->txrx_bufs) {\n\t\tbitbang->use_dma = 0;\n\t\tbitbang->txrx_bufs = spi_bitbang_bufs;\n\t\tif (!master->setup) {\n\t\t\tif (!bitbang->setup_transfer)\n\t\t\t\tbitbang->setup_transfer =\n\t\t\t\t\t spi_bitbang_setup_transfer;\n\t\t\tmaster->setup = spi_bitbang_setup;\n\t\t\tmaster->cleanup = spi_bitbang_cleanup;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_init);\n\n \nint spi_bitbang_start(struct spi_bitbang *bitbang)\n{\n\tstruct spi_master *master = bitbang->master;\n\tint ret;\n\n\tret = spi_bitbang_init(bitbang);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = spi_register_master(spi_master_get(master));\n\tif (ret)\n\t\tspi_master_put(master);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_start);\n\n \nvoid spi_bitbang_stop(struct spi_bitbang *bitbang)\n{\n\tspi_unregister_master(bitbang->master);\n}\nEXPORT_SYMBOL_GPL(spi_bitbang_stop);\n\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}