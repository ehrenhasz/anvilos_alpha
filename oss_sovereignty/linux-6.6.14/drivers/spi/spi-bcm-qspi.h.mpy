{
  "module_name": "spi-bcm-qspi.h",
  "hash_id": "ee2a65de4f5ff1baee0ad4b9bb0387bd694d8a4742fb5dc7b74a95686d7dbcff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm-qspi.h",
  "human_readable_source": " \n \n\n#ifndef __SPI_BCM_QSPI_H__\n#define __SPI_BCM_QSPI_H__\n\n#include <linux/types.h>\n#include <linux/io.h>\n\n \n#define INTR_BSPI_LR_OVERREAD_MASK\t\tBIT(4)\n#define INTR_BSPI_LR_SESSION_DONE_MASK\t\tBIT(3)\n#define INTR_BSPI_LR_IMPATIENT_MASK\t\tBIT(2)\n#define INTR_BSPI_LR_SESSION_ABORTED_MASK\tBIT(1)\n#define INTR_BSPI_LR_FULLNESS_REACHED_MASK\tBIT(0)\n\n#define BSPI_LR_INTERRUPTS_DATA\t\t       \\\n\t(INTR_BSPI_LR_SESSION_DONE_MASK |\t       \\\n\t INTR_BSPI_LR_FULLNESS_REACHED_MASK)\n\n#define BSPI_LR_INTERRUPTS_ERROR               \\\n\t(INTR_BSPI_LR_OVERREAD_MASK |\t       \\\n\t INTR_BSPI_LR_IMPATIENT_MASK |\t       \\\n\t INTR_BSPI_LR_SESSION_ABORTED_MASK)\n\n#define BSPI_LR_INTERRUPTS_ALL                 \\\n\t(BSPI_LR_INTERRUPTS_ERROR |\t       \\\n\t BSPI_LR_INTERRUPTS_DATA)\n\n \n#define INTR_MSPI_HALTED_MASK\t\t\tBIT(6)\n#define INTR_MSPI_DONE_MASK\t\t\tBIT(5)\n\n#define MSPI_INTERRUPTS_ALL\t\t       \\\n\t(INTR_MSPI_DONE_MASK |\t\t       \\\n\t INTR_MSPI_HALTED_MASK)\n\n#define QSPI_INTERRUPTS_ALL                    \\\n\t(MSPI_INTERRUPTS_ALL |\t\t       \\\n\t BSPI_LR_INTERRUPTS_ALL)\n\nstruct platform_device;\nstruct dev_pm_ops;\n\nenum {\n\tMSPI_DONE = 0x1,\n\tBSPI_DONE = 0x2,\n\tBSPI_ERR = 0x4,\n\tMSPI_BSPI_DONE = 0x7\n};\n\nstruct bcm_qspi_soc_intc {\n\tvoid (*bcm_qspi_int_ack)(struct bcm_qspi_soc_intc *soc_intc, int type);\n\tvoid (*bcm_qspi_int_set)(struct bcm_qspi_soc_intc *soc_intc, int type,\n\t\t\t\t bool en);\n\tu32 (*bcm_qspi_get_int_status)(struct bcm_qspi_soc_intc *soc_intc);\n};\n\n \nstatic inline u32 bcm_qspi_readl(bool be, void __iomem *addr)\n{\n\tif (be)\n\t\treturn ioread32be(addr);\n\telse\n\t\treturn readl_relaxed(addr);\n}\n\n \nstatic inline void bcm_qspi_writel(bool be,\n\t\t\t\t   unsigned int data, void __iomem *addr)\n{\n\tif (be)\n\t\tiowrite32be(data, addr);\n\telse\n\t\twritel_relaxed(data, addr);\n}\n\nstatic inline u32 get_qspi_mask(int type)\n{\n\tswitch (type) {\n\tcase MSPI_DONE:\n\t\treturn INTR_MSPI_DONE_MASK;\n\tcase BSPI_DONE:\n\t\treturn BSPI_LR_INTERRUPTS_ALL;\n\tcase MSPI_BSPI_DONE:\n\t\treturn QSPI_INTERRUPTS_ALL;\n\tcase BSPI_ERR:\n\t\treturn BSPI_LR_INTERRUPTS_ERROR;\n\t}\n\n\treturn 0;\n}\n\n \nint bcm_qspi_probe(struct platform_device *pdev,\n\t\t   struct bcm_qspi_soc_intc *soc_intc);\nvoid bcm_qspi_remove(struct platform_device *pdev);\n\n \nextern const struct dev_pm_ops bcm_qspi_pm_ops;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}