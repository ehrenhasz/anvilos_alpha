{
  "module_name": "spi-img-spfi.c",
  "hash_id": "f5987859d5d721b7c70301080164d9238f2a6bf203298745fbb2db0c370b8001",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-img-spfi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n\n#define SPFI_DEVICE_PARAMETER(x)\t\t(0x00 + 0x4 * (x))\n#define SPFI_DEVICE_PARAMETER_BITCLK_SHIFT\t24\n#define SPFI_DEVICE_PARAMETER_BITCLK_MASK\t0xff\n#define SPFI_DEVICE_PARAMETER_CSSETUP_SHIFT\t16\n#define SPFI_DEVICE_PARAMETER_CSSETUP_MASK\t0xff\n#define SPFI_DEVICE_PARAMETER_CSHOLD_SHIFT\t8\n#define SPFI_DEVICE_PARAMETER_CSHOLD_MASK\t0xff\n#define SPFI_DEVICE_PARAMETER_CSDELAY_SHIFT\t0\n#define SPFI_DEVICE_PARAMETER_CSDELAY_MASK\t0xff\n\n#define SPFI_CONTROL\t\t\t\t0x14\n#define SPFI_CONTROL_CONTINUE\t\t\tBIT(12)\n#define SPFI_CONTROL_SOFT_RESET\t\t\tBIT(11)\n#define SPFI_CONTROL_SEND_DMA\t\t\tBIT(10)\n#define SPFI_CONTROL_GET_DMA\t\t\tBIT(9)\n#define SPFI_CONTROL_SE\t\t\tBIT(8)\n#define SPFI_CONTROL_TMODE_SHIFT\t\t5\n#define SPFI_CONTROL_TMODE_MASK\t\t\t0x7\n#define SPFI_CONTROL_TMODE_SINGLE\t\t0\n#define SPFI_CONTROL_TMODE_DUAL\t\t\t1\n#define SPFI_CONTROL_TMODE_QUAD\t\t\t2\n#define SPFI_CONTROL_SPFI_EN\t\t\tBIT(0)\n\n#define SPFI_TRANSACTION\t\t\t0x18\n#define SPFI_TRANSACTION_TSIZE_SHIFT\t\t16\n#define SPFI_TRANSACTION_TSIZE_MASK\t\t0xffff\n\n#define SPFI_PORT_STATE\t\t\t\t0x1c\n#define SPFI_PORT_STATE_DEV_SEL_SHIFT\t\t20\n#define SPFI_PORT_STATE_DEV_SEL_MASK\t\t0x7\n#define SPFI_PORT_STATE_CK_POL(x)\t\tBIT(19 - (x))\n#define SPFI_PORT_STATE_CK_PHASE(x)\t\tBIT(14 - (x))\n\n#define SPFI_TX_32BIT_VALID_DATA\t\t0x20\n#define SPFI_TX_8BIT_VALID_DATA\t\t\t0x24\n#define SPFI_RX_32BIT_VALID_DATA\t\t0x28\n#define SPFI_RX_8BIT_VALID_DATA\t\t\t0x2c\n\n#define SPFI_INTERRUPT_STATUS\t\t\t0x30\n#define SPFI_INTERRUPT_ENABLE\t\t\t0x34\n#define SPFI_INTERRUPT_CLEAR\t\t\t0x38\n#define SPFI_INTERRUPT_IACCESS\t\t\tBIT(12)\n#define SPFI_INTERRUPT_GDEX8BIT\t\t\tBIT(11)\n#define SPFI_INTERRUPT_ALLDONETRIG\t\tBIT(9)\n#define SPFI_INTERRUPT_GDFUL\t\t\tBIT(8)\n#define SPFI_INTERRUPT_GDHF\t\t\tBIT(7)\n#define SPFI_INTERRUPT_GDEX32BIT\t\tBIT(6)\n#define SPFI_INTERRUPT_GDTRIG\t\t\tBIT(5)\n#define SPFI_INTERRUPT_SDFUL\t\t\tBIT(3)\n#define SPFI_INTERRUPT_SDHF\t\t\tBIT(2)\n#define SPFI_INTERRUPT_SDE\t\t\tBIT(1)\n#define SPFI_INTERRUPT_SDTRIG\t\t\tBIT(0)\n\n \n#define SPFI_32BIT_FIFO_SIZE\t\t\t64\n#define SPFI_8BIT_FIFO_SIZE\t\t\t16\n\nstruct img_spfi {\n\tstruct device *dev;\n\tstruct spi_controller *host;\n\tspinlock_t lock;\n\n\tvoid __iomem *regs;\n\tphys_addr_t phys;\n\tint irq;\n\tstruct clk *spfi_clk;\n\tstruct clk *sys_clk;\n\n\tstruct dma_chan *rx_ch;\n\tstruct dma_chan *tx_ch;\n\tbool tx_dma_busy;\n\tbool rx_dma_busy;\n};\n\nstatic inline u32 spfi_readl(struct img_spfi *spfi, u32 reg)\n{\n\treturn readl(spfi->regs + reg);\n}\n\nstatic inline void spfi_writel(struct img_spfi *spfi, u32 val, u32 reg)\n{\n\twritel(val, spfi->regs + reg);\n}\n\nstatic inline void spfi_start(struct img_spfi *spfi)\n{\n\tu32 val;\n\n\tval = spfi_readl(spfi, SPFI_CONTROL);\n\tval |= SPFI_CONTROL_SPFI_EN;\n\tspfi_writel(spfi, val, SPFI_CONTROL);\n}\n\nstatic inline void spfi_reset(struct img_spfi *spfi)\n{\n\tspfi_writel(spfi, SPFI_CONTROL_SOFT_RESET, SPFI_CONTROL);\n\tspfi_writel(spfi, 0, SPFI_CONTROL);\n}\n\nstatic int spfi_wait_all_done(struct img_spfi *spfi)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(50);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tu32 status = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\n\t\tif (status & SPFI_INTERRUPT_ALLDONETRIG) {\n\t\t\tspfi_writel(spfi, SPFI_INTERRUPT_ALLDONETRIG,\n\t\t\t\t    SPFI_INTERRUPT_CLEAR);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\tdev_err(spfi->dev, \"Timed out waiting for transaction to complete\\n\");\n\tspfi_reset(spfi);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic unsigned int spfi_pio_write32(struct img_spfi *spfi, const u32 *buf,\n\t\t\t\t     unsigned int max)\n{\n\tunsigned int count = 0;\n\tu32 status;\n\n\twhile (count < max / 4) {\n\t\tspfi_writel(spfi, SPFI_INTERRUPT_SDFUL, SPFI_INTERRUPT_CLEAR);\n\t\tstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\t\tif (status & SPFI_INTERRUPT_SDFUL)\n\t\t\tbreak;\n\t\tspfi_writel(spfi, buf[count], SPFI_TX_32BIT_VALID_DATA);\n\t\tcount++;\n\t}\n\n\treturn count * 4;\n}\n\nstatic unsigned int spfi_pio_write8(struct img_spfi *spfi, const u8 *buf,\n\t\t\t\t    unsigned int max)\n{\n\tunsigned int count = 0;\n\tu32 status;\n\n\twhile (count < max) {\n\t\tspfi_writel(spfi, SPFI_INTERRUPT_SDFUL, SPFI_INTERRUPT_CLEAR);\n\t\tstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\t\tif (status & SPFI_INTERRUPT_SDFUL)\n\t\t\tbreak;\n\t\tspfi_writel(spfi, buf[count], SPFI_TX_8BIT_VALID_DATA);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic unsigned int spfi_pio_read32(struct img_spfi *spfi, u32 *buf,\n\t\t\t\t    unsigned int max)\n{\n\tunsigned int count = 0;\n\tu32 status;\n\n\twhile (count < max / 4) {\n\t\tspfi_writel(spfi, SPFI_INTERRUPT_GDEX32BIT,\n\t\t\t    SPFI_INTERRUPT_CLEAR);\n\t\tstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\t\tif (!(status & SPFI_INTERRUPT_GDEX32BIT))\n\t\t\tbreak;\n\t\tbuf[count] = spfi_readl(spfi, SPFI_RX_32BIT_VALID_DATA);\n\t\tcount++;\n\t}\n\n\treturn count * 4;\n}\n\nstatic unsigned int spfi_pio_read8(struct img_spfi *spfi, u8 *buf,\n\t\t\t\t   unsigned int max)\n{\n\tunsigned int count = 0;\n\tu32 status;\n\n\twhile (count < max) {\n\t\tspfi_writel(spfi, SPFI_INTERRUPT_GDEX8BIT,\n\t\t\t    SPFI_INTERRUPT_CLEAR);\n\t\tstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\t\tif (!(status & SPFI_INTERRUPT_GDEX8BIT))\n\t\t\tbreak;\n\t\tbuf[count] = spfi_readl(spfi, SPFI_RX_8BIT_VALID_DATA);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int img_spfi_start_pio(struct spi_controller *host,\n\t\t\t       struct spi_device *spi,\n\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(spi->controller);\n\tunsigned int tx_bytes = 0, rx_bytes = 0;\n\tconst void *tx_buf = xfer->tx_buf;\n\tvoid *rx_buf = xfer->rx_buf;\n\tunsigned long timeout;\n\tint ret;\n\n\tif (tx_buf)\n\t\ttx_bytes = xfer->len;\n\tif (rx_buf)\n\t\trx_bytes = xfer->len;\n\n\tspfi_start(spfi);\n\n\ttimeout = jiffies +\n\t\tmsecs_to_jiffies(xfer->len * 8 * 1000 / xfer->speed_hz + 100);\n\twhile ((tx_bytes > 0 || rx_bytes > 0) &&\n\t       time_before(jiffies, timeout)) {\n\t\tunsigned int tx_count, rx_count;\n\n\t\tif (tx_bytes >= 4)\n\t\t\ttx_count = spfi_pio_write32(spfi, tx_buf, tx_bytes);\n\t\telse\n\t\t\ttx_count = spfi_pio_write8(spfi, tx_buf, tx_bytes);\n\n\t\tif (rx_bytes >= 4)\n\t\t\trx_count = spfi_pio_read32(spfi, rx_buf, rx_bytes);\n\t\telse\n\t\t\trx_count = spfi_pio_read8(spfi, rx_buf, rx_bytes);\n\n\t\ttx_buf += tx_count;\n\t\trx_buf += rx_count;\n\t\ttx_bytes -= tx_count;\n\t\trx_bytes -= rx_count;\n\n\t\tcpu_relax();\n\t}\n\n\tif (rx_bytes > 0 || tx_bytes > 0) {\n\t\tdev_err(spfi->dev, \"PIO transfer timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = spfi_wait_all_done(spfi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void img_spfi_dma_rx_cb(void *data)\n{\n\tstruct img_spfi *spfi = data;\n\tunsigned long flags;\n\n\tspfi_wait_all_done(spfi);\n\n\tspin_lock_irqsave(&spfi->lock, flags);\n\tspfi->rx_dma_busy = false;\n\tif (!spfi->tx_dma_busy)\n\t\tspi_finalize_current_transfer(spfi->host);\n\tspin_unlock_irqrestore(&spfi->lock, flags);\n}\n\nstatic void img_spfi_dma_tx_cb(void *data)\n{\n\tstruct img_spfi *spfi = data;\n\tunsigned long flags;\n\n\tspfi_wait_all_done(spfi);\n\n\tspin_lock_irqsave(&spfi->lock, flags);\n\tspfi->tx_dma_busy = false;\n\tif (!spfi->rx_dma_busy)\n\t\tspi_finalize_current_transfer(spfi->host);\n\tspin_unlock_irqrestore(&spfi->lock, flags);\n}\n\nstatic int img_spfi_start_dma(struct spi_controller *host,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(spi->controller);\n\tstruct dma_async_tx_descriptor *rxdesc = NULL, *txdesc = NULL;\n\tstruct dma_slave_config rxconf, txconf;\n\n\tspfi->rx_dma_busy = false;\n\tspfi->tx_dma_busy = false;\n\n\tif (xfer->rx_buf) {\n\t\trxconf.direction = DMA_DEV_TO_MEM;\n\t\tif (xfer->len % 4 == 0) {\n\t\t\trxconf.src_addr = spfi->phys + SPFI_RX_32BIT_VALID_DATA;\n\t\t\trxconf.src_addr_width = 4;\n\t\t\trxconf.src_maxburst = 4;\n\t\t} else {\n\t\t\trxconf.src_addr = spfi->phys + SPFI_RX_8BIT_VALID_DATA;\n\t\t\trxconf.src_addr_width = 1;\n\t\t\trxconf.src_maxburst = 4;\n\t\t}\n\t\tdmaengine_slave_config(spfi->rx_ch, &rxconf);\n\n\t\trxdesc = dmaengine_prep_slave_sg(spfi->rx_ch, xfer->rx_sg.sgl,\n\t\t\t\t\t\t xfer->rx_sg.nents,\n\t\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT);\n\t\tif (!rxdesc)\n\t\t\tgoto stop_dma;\n\n\t\trxdesc->callback = img_spfi_dma_rx_cb;\n\t\trxdesc->callback_param = spfi;\n\t}\n\n\tif (xfer->tx_buf) {\n\t\ttxconf.direction = DMA_MEM_TO_DEV;\n\t\tif (xfer->len % 4 == 0) {\n\t\t\ttxconf.dst_addr = spfi->phys + SPFI_TX_32BIT_VALID_DATA;\n\t\t\ttxconf.dst_addr_width = 4;\n\t\t\ttxconf.dst_maxburst = 4;\n\t\t} else {\n\t\t\ttxconf.dst_addr = spfi->phys + SPFI_TX_8BIT_VALID_DATA;\n\t\t\ttxconf.dst_addr_width = 1;\n\t\t\ttxconf.dst_maxburst = 4;\n\t\t}\n\t\tdmaengine_slave_config(spfi->tx_ch, &txconf);\n\n\t\ttxdesc = dmaengine_prep_slave_sg(spfi->tx_ch, xfer->tx_sg.sgl,\n\t\t\t\t\t\t xfer->tx_sg.nents,\n\t\t\t\t\t\t DMA_MEM_TO_DEV,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT);\n\t\tif (!txdesc)\n\t\t\tgoto stop_dma;\n\n\t\ttxdesc->callback = img_spfi_dma_tx_cb;\n\t\ttxdesc->callback_param = spfi;\n\t}\n\n\tif (xfer->rx_buf) {\n\t\tspfi->rx_dma_busy = true;\n\t\tdmaengine_submit(rxdesc);\n\t\tdma_async_issue_pending(spfi->rx_ch);\n\t}\n\n\tspfi_start(spfi);\n\n\tif (xfer->tx_buf) {\n\t\tspfi->tx_dma_busy = true;\n\t\tdmaengine_submit(txdesc);\n\t\tdma_async_issue_pending(spfi->tx_ch);\n\t}\n\n\treturn 1;\n\nstop_dma:\n\tdmaengine_terminate_all(spfi->rx_ch);\n\tdmaengine_terminate_all(spfi->tx_ch);\n\treturn -EIO;\n}\n\nstatic void img_spfi_handle_err(struct spi_controller *host,\n\t\t\t\tstruct spi_message *msg)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&spfi->lock, flags);\n\tif (spfi->tx_dma_busy || spfi->rx_dma_busy) {\n\t\tspfi->tx_dma_busy = false;\n\t\tspfi->rx_dma_busy = false;\n\n\t\tdmaengine_terminate_all(spfi->tx_ch);\n\t\tdmaengine_terminate_all(spfi->rx_ch);\n\t}\n\tspin_unlock_irqrestore(&spfi->lock, flags);\n}\n\nstatic int img_spfi_prepare(struct spi_controller *host, struct spi_message *msg)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\tu32 val;\n\n\tval = spfi_readl(spfi, SPFI_PORT_STATE);\n\tval &= ~(SPFI_PORT_STATE_DEV_SEL_MASK <<\n\t\t SPFI_PORT_STATE_DEV_SEL_SHIFT);\n\tval |= spi_get_chipselect(msg->spi, 0) << SPFI_PORT_STATE_DEV_SEL_SHIFT;\n\tif (msg->spi->mode & SPI_CPHA)\n\t\tval |= SPFI_PORT_STATE_CK_PHASE(spi_get_chipselect(msg->spi, 0));\n\telse\n\t\tval &= ~SPFI_PORT_STATE_CK_PHASE(spi_get_chipselect(msg->spi, 0));\n\tif (msg->spi->mode & SPI_CPOL)\n\t\tval |= SPFI_PORT_STATE_CK_POL(spi_get_chipselect(msg->spi, 0));\n\telse\n\t\tval &= ~SPFI_PORT_STATE_CK_POL(spi_get_chipselect(msg->spi, 0));\n\tspfi_writel(spfi, val, SPFI_PORT_STATE);\n\n\treturn 0;\n}\n\nstatic int img_spfi_unprepare(struct spi_controller *host,\n\t\t\t      struct spi_message *msg)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\n\tspfi_reset(spfi);\n\n\treturn 0;\n}\n\nstatic void img_spfi_config(struct spi_controller *host, struct spi_device *spi,\n\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(spi->controller);\n\tu32 val, div;\n\n\t \n\tdiv = DIV_ROUND_UP(clk_get_rate(spfi->spfi_clk), xfer->speed_hz);\n\tdiv = clamp(512 / (1 << get_count_order(div)), 1, 128);\n\n\tval = spfi_readl(spfi, SPFI_DEVICE_PARAMETER(spi_get_chipselect(spi, 0)));\n\tval &= ~(SPFI_DEVICE_PARAMETER_BITCLK_MASK <<\n\t\t SPFI_DEVICE_PARAMETER_BITCLK_SHIFT);\n\tval |= div << SPFI_DEVICE_PARAMETER_BITCLK_SHIFT;\n\tspfi_writel(spfi, val, SPFI_DEVICE_PARAMETER(spi_get_chipselect(spi, 0)));\n\n\tspfi_writel(spfi, xfer->len << SPFI_TRANSACTION_TSIZE_SHIFT,\n\t\t    SPFI_TRANSACTION);\n\n\tval = spfi_readl(spfi, SPFI_CONTROL);\n\tval &= ~(SPFI_CONTROL_SEND_DMA | SPFI_CONTROL_GET_DMA);\n\tif (xfer->tx_buf)\n\t\tval |= SPFI_CONTROL_SEND_DMA;\n\tif (xfer->rx_buf)\n\t\tval |= SPFI_CONTROL_GET_DMA;\n\tval &= ~(SPFI_CONTROL_TMODE_MASK << SPFI_CONTROL_TMODE_SHIFT);\n\tif (xfer->tx_nbits == SPI_NBITS_DUAL &&\n\t    xfer->rx_nbits == SPI_NBITS_DUAL)\n\t\tval |= SPFI_CONTROL_TMODE_DUAL << SPFI_CONTROL_TMODE_SHIFT;\n\telse if (xfer->tx_nbits == SPI_NBITS_QUAD &&\n\t\t xfer->rx_nbits == SPI_NBITS_QUAD)\n\t\tval |= SPFI_CONTROL_TMODE_QUAD << SPFI_CONTROL_TMODE_SHIFT;\n\tval |= SPFI_CONTROL_SE;\n\tspfi_writel(spfi, val, SPFI_CONTROL);\n}\n\nstatic int img_spfi_transfer_one(struct spi_controller *host,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *xfer)\n{\n\tstruct img_spfi *spfi = spi_controller_get_devdata(spi->controller);\n\tint ret;\n\n\tif (xfer->len > SPFI_TRANSACTION_TSIZE_MASK) {\n\t\tdev_err(spfi->dev,\n\t\t\t\"Transfer length (%d) is greater than the max supported (%d)\",\n\t\t\txfer->len, SPFI_TRANSACTION_TSIZE_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\timg_spfi_config(host, spi, xfer);\n\tif (host->can_dma && host->can_dma(host, spi, xfer))\n\t\tret = img_spfi_start_dma(host, spi, xfer);\n\telse\n\t\tret = img_spfi_start_pio(host, spi, xfer);\n\n\treturn ret;\n}\n\nstatic bool img_spfi_can_dma(struct spi_controller *host, struct spi_device *spi,\n\t\t\t     struct spi_transfer *xfer)\n{\n\tif (xfer->len > SPFI_32BIT_FIFO_SIZE)\n\t\treturn true;\n\treturn false;\n}\n\nstatic irqreturn_t img_spfi_irq(int irq, void *dev_id)\n{\n\tstruct img_spfi *spfi = (struct img_spfi *)dev_id;\n\tu32 status;\n\n\tstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\n\tif (status & SPFI_INTERRUPT_IACCESS) {\n\t\tspfi_writel(spfi, SPFI_INTERRUPT_IACCESS, SPFI_INTERRUPT_CLEAR);\n\t\tdev_err(spfi->dev, \"Illegal access interrupt\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int img_spfi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct img_spfi *spfi;\n\tstruct resource *res;\n\tint ret;\n\tu32 max_speed_hz;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*spfi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, host);\n\n\tspfi = spi_controller_get_devdata(host);\n\tspfi->dev = &pdev->dev;\n\tspfi->host = host;\n\tspin_lock_init(&spfi->lock);\n\n\tspfi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(spfi->regs)) {\n\t\tret = PTR_ERR(spfi->regs);\n\t\tgoto put_spi;\n\t}\n\tspfi->phys = res->start;\n\n\tspfi->irq = platform_get_irq(pdev, 0);\n\tif (spfi->irq < 0) {\n\t\tret = spfi->irq;\n\t\tgoto put_spi;\n\t}\n\tret = devm_request_irq(spfi->dev, spfi->irq, img_spfi_irq,\n\t\t\t       IRQ_TYPE_LEVEL_HIGH, dev_name(spfi->dev), spfi);\n\tif (ret)\n\t\tgoto put_spi;\n\n\tspfi->sys_clk = devm_clk_get(spfi->dev, \"sys\");\n\tif (IS_ERR(spfi->sys_clk)) {\n\t\tret = PTR_ERR(spfi->sys_clk);\n\t\tgoto put_spi;\n\t}\n\tspfi->spfi_clk = devm_clk_get(spfi->dev, \"spfi\");\n\tif (IS_ERR(spfi->spfi_clk)) {\n\t\tret = PTR_ERR(spfi->spfi_clk);\n\t\tgoto put_spi;\n\t}\n\n\tret = clk_prepare_enable(spfi->sys_clk);\n\tif (ret)\n\t\tgoto put_spi;\n\tret = clk_prepare_enable(spfi->spfi_clk);\n\tif (ret)\n\t\tgoto disable_pclk;\n\n\tspfi_reset(spfi);\n\t \n\tspfi_writel(spfi, SPFI_INTERRUPT_IACCESS, SPFI_INTERRUPT_ENABLE);\n\n\thost->auto_runtime_pm = true;\n\thost->bus_num = pdev->id;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_TX_DUAL | SPI_RX_DUAL;\n\tif (of_property_read_bool(spfi->dev->of_node, \"img,supports-quad-mode\"))\n\t\thost->mode_bits |= SPI_TX_QUAD | SPI_RX_QUAD;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(8);\n\thost->max_speed_hz = clk_get_rate(spfi->spfi_clk) / 4;\n\thost->min_speed_hz = clk_get_rate(spfi->spfi_clk) / 512;\n\n\t \n\tif (!of_property_read_u32(spfi->dev->of_node, \"spfi-max-frequency\",\n\t\t\t\t  &max_speed_hz)) {\n\t\tif (host->max_speed_hz > max_speed_hz)\n\t\t\thost->max_speed_hz = max_speed_hz;\n\t}\n\n\thost->transfer_one = img_spfi_transfer_one;\n\thost->prepare_message = img_spfi_prepare;\n\thost->unprepare_message = img_spfi_unprepare;\n\thost->handle_err = img_spfi_handle_err;\n\thost->use_gpio_descriptors = true;\n\n\tspfi->tx_ch = dma_request_chan(spfi->dev, \"tx\");\n\tif (IS_ERR(spfi->tx_ch)) {\n\t\tret = PTR_ERR(spfi->tx_ch);\n\t\tspfi->tx_ch = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto disable_pm;\n\t}\n\n\tspfi->rx_ch = dma_request_chan(spfi->dev, \"rx\");\n\tif (IS_ERR(spfi->rx_ch)) {\n\t\tret = PTR_ERR(spfi->rx_ch);\n\t\tspfi->rx_ch = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto disable_pm;\n\t}\n\n\tif (!spfi->tx_ch || !spfi->rx_ch) {\n\t\tif (spfi->tx_ch)\n\t\t\tdma_release_channel(spfi->tx_ch);\n\t\tif (spfi->rx_ch)\n\t\t\tdma_release_channel(spfi->rx_ch);\n\t\tspfi->tx_ch = NULL;\n\t\tspfi->rx_ch = NULL;\n\t\tdev_warn(spfi->dev, \"Failed to get DMA channels, falling back to PIO mode\\n\");\n\t} else {\n\t\thost->dma_tx = spfi->tx_ch;\n\t\thost->dma_rx = spfi->rx_ch;\n\t\thost->can_dma = img_spfi_can_dma;\n\t}\n\n\tpm_runtime_set_active(spfi->dev);\n\tpm_runtime_enable(spfi->dev);\n\n\tret = devm_spi_register_controller(spfi->dev, host);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(spfi->dev);\n\tif (spfi->rx_ch)\n\t\tdma_release_channel(spfi->rx_ch);\n\tif (spfi->tx_ch)\n\t\tdma_release_channel(spfi->tx_ch);\n\tclk_disable_unprepare(spfi->spfi_clk);\ndisable_pclk:\n\tclk_disable_unprepare(spfi->sys_clk);\nput_spi:\n\tspi_controller_put(host);\n\n\treturn ret;\n}\n\nstatic void img_spfi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\n\tif (spfi->tx_ch)\n\t\tdma_release_channel(spfi->tx_ch);\n\tif (spfi->rx_ch)\n\t\tdma_release_channel(spfi->rx_ch);\n\n\tpm_runtime_disable(spfi->dev);\n\tif (!pm_runtime_status_suspended(spfi->dev)) {\n\t\tclk_disable_unprepare(spfi->spfi_clk);\n\t\tclk_disable_unprepare(spfi->sys_clk);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int img_spfi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\n\tclk_disable_unprepare(spfi->spfi_clk);\n\tclk_disable_unprepare(spfi->sys_clk);\n\n\treturn 0;\n}\n\nstatic int img_spfi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(spfi->sys_clk);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_prepare_enable(spfi->spfi_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(spfi->sys_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\nstatic int img_spfi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\n\treturn spi_controller_suspend(host);\n}\n\nstatic int img_spfi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct img_spfi *spfi = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tspfi_reset(spfi);\n\tpm_runtime_put(dev);\n\n\treturn spi_controller_resume(host);\n}\n#endif  \n\nstatic const struct dev_pm_ops img_spfi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(img_spfi_runtime_suspend, img_spfi_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(img_spfi_suspend, img_spfi_resume)\n};\n\nstatic const struct of_device_id img_spfi_of_match[] = {\n\t{ .compatible = \"img,spfi\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, img_spfi_of_match);\n\nstatic struct platform_driver img_spfi_driver = {\n\t.driver = {\n\t\t.name = \"img-spfi\",\n\t\t.pm = &img_spfi_pm_ops,\n\t\t.of_match_table = of_match_ptr(img_spfi_of_match),\n\t},\n\t.probe = img_spfi_probe,\n\t.remove_new = img_spfi_remove,\n};\nmodule_platform_driver(img_spfi_driver);\n\nMODULE_DESCRIPTION(\"IMG SPFI controller driver\");\nMODULE_AUTHOR(\"Andrew Bresticker <abrestic@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}