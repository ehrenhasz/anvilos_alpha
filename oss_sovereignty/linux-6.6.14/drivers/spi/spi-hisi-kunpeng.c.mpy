{
  "module_name": "spi-hisi-kunpeng.c",
  "hash_id": "2085910bdeb24f02c08fa104ae0f162e0b32e5da7463c35ff3fd6026a8225e67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-hisi-kunpeng.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n \n#define HISI_SPI_CSCR\t\t0x00\t \n#define HISI_SPI_CR\t\t0x04\t \n#define HISI_SPI_ENR\t\t0x08\t \n#define HISI_SPI_FIFOC\t\t0x0c\t \n#define HISI_SPI_IMR\t\t0x10\t \n#define HISI_SPI_DIN\t\t0x14\t \n#define HISI_SPI_DOUT\t\t0x18\t \n#define HISI_SPI_SR\t\t0x1c\t \n#define HISI_SPI_RISR\t\t0x20\t \n#define HISI_SPI_ISR\t\t0x24\t \n#define HISI_SPI_ICR\t\t0x28\t \n#define HISI_SPI_VERSION\t0xe0\t \n\n \n#define CR_LOOP_MASK\t\tGENMASK(1, 1)\n#define CR_CPOL_MASK\t\tGENMASK(2, 2)\n#define CR_CPHA_MASK\t\tGENMASK(3, 3)\n#define CR_DIV_PRE_MASK\t\tGENMASK(11, 4)\n#define CR_DIV_POST_MASK\tGENMASK(19, 12)\n#define CR_BPW_MASK\t\tGENMASK(24, 20)\n#define CR_SPD_MODE_MASK\tGENMASK(25, 25)\n\n \n#define FIFOC_TX_MASK\t\tGENMASK(5, 3)\n#define FIFOC_RX_MASK\t\tGENMASK(11, 9)\n\n \n#define IMR_RXOF\t\tBIT(0)\t\t \n#define IMR_RXTO\t\tBIT(1)\t\t \n#define IMR_RX\t\t\tBIT(2)\t\t \n#define IMR_TX\t\t\tBIT(3)\t\t \n#define IMR_MASK\t\t(IMR_RXOF | IMR_RXTO | IMR_RX | IMR_TX)\n\n \n#define SR_TXE\t\t\tBIT(0)\t\t \n#define SR_TXNF\t\t\tBIT(1)\t\t \n#define SR_RXNE\t\t\tBIT(2)\t\t \n#define SR_RXF\t\t\tBIT(3)\t\t \n#define SR_BUSY\t\t\tBIT(4)\t\t \n\n \n#define ISR_RXOF\t\tBIT(0)\t\t \n#define ISR_RXTO\t\tBIT(1)\t\t \n#define ISR_RX\t\t\tBIT(2)\t\t \n#define ISR_TX\t\t\tBIT(3)\t\t \n#define ISR_MASK\t\t(ISR_RXOF | ISR_RXTO | ISR_RX | ISR_TX)\n\n \n#define ICR_RXOF\t\tBIT(0)\t\t \n#define ICR_RXTO\t\tBIT(1)\t\t \n#define ICR_MASK\t\t(ICR_RXOF | ICR_RXTO)\n\n#define DIV_POST_MAX\t\t0xFF\n#define DIV_POST_MIN\t\t0x00\n#define DIV_PRE_MAX\t\t0xFE\n#define DIV_PRE_MIN\t\t0x02\n#define CLK_DIV_MAX\t\t((1 + DIV_POST_MAX) * DIV_PRE_MAX)\n#define CLK_DIV_MIN\t\t((1 + DIV_POST_MIN) * DIV_PRE_MIN)\n\n#define DEFAULT_NUM_CS\t\t1\n\n#define HISI_SPI_WAIT_TIMEOUT_MS\t10UL\n\nenum hisi_spi_rx_level_trig {\n\tHISI_SPI_RX_1,\n\tHISI_SPI_RX_4,\n\tHISI_SPI_RX_8,\n\tHISI_SPI_RX_16,\n\tHISI_SPI_RX_32,\n\tHISI_SPI_RX_64,\n\tHISI_SPI_RX_128\n};\n\nenum hisi_spi_tx_level_trig {\n\tHISI_SPI_TX_1_OR_LESS,\n\tHISI_SPI_TX_4_OR_LESS,\n\tHISI_SPI_TX_8_OR_LESS,\n\tHISI_SPI_TX_16_OR_LESS,\n\tHISI_SPI_TX_32_OR_LESS,\n\tHISI_SPI_TX_64_OR_LESS,\n\tHISI_SPI_TX_128_OR_LESS\n};\n\nenum hisi_spi_frame_n_bytes {\n\tHISI_SPI_N_BYTES_NULL,\n\tHISI_SPI_N_BYTES_U8,\n\tHISI_SPI_N_BYTES_U16,\n\tHISI_SPI_N_BYTES_U32 = 4\n};\n\n \nstruct hisi_chip_data {\n\tu32 cr;\n\tu32 speed_hz;\t \n\tu16 clk_div;\t \n\n\t \n\tu8 div_post;\t \n\tu8 div_pre;\t \n};\n\nstruct hisi_spi {\n\tstruct device\t\t*dev;\n\n\tvoid __iomem\t\t*regs;\n\tint\t\t\tirq;\n\tu32\t\t\tfifo_len;  \n\n\t \n\tconst void\t\t*tx;\n\tunsigned int\t\ttx_len;\n\tvoid\t\t\t*rx;\n\tunsigned int\t\trx_len;\n\tu8\t\t\tn_bytes;  \n\n\tstruct dentry *debugfs;\n\tstruct debugfs_regset32 regset;\n};\n\n#define HISI_SPI_DBGFS_REG(_name, _off)\t\\\n{\t\t\t\t\t\\\n\t.name = _name,\t\t\t\\\n\t.offset = _off,\t\t\t\\\n}\n\nstatic const struct debugfs_reg32 hisi_spi_regs[] = {\n\tHISI_SPI_DBGFS_REG(\"CSCR\", HISI_SPI_CSCR),\n\tHISI_SPI_DBGFS_REG(\"CR\", HISI_SPI_CR),\n\tHISI_SPI_DBGFS_REG(\"ENR\", HISI_SPI_ENR),\n\tHISI_SPI_DBGFS_REG(\"FIFOC\", HISI_SPI_FIFOC),\n\tHISI_SPI_DBGFS_REG(\"IMR\", HISI_SPI_IMR),\n\tHISI_SPI_DBGFS_REG(\"DIN\", HISI_SPI_DIN),\n\tHISI_SPI_DBGFS_REG(\"DOUT\", HISI_SPI_DOUT),\n\tHISI_SPI_DBGFS_REG(\"SR\", HISI_SPI_SR),\n\tHISI_SPI_DBGFS_REG(\"RISR\", HISI_SPI_RISR),\n\tHISI_SPI_DBGFS_REG(\"ISR\", HISI_SPI_ISR),\n\tHISI_SPI_DBGFS_REG(\"ICR\", HISI_SPI_ICR),\n\tHISI_SPI_DBGFS_REG(\"VERSION\", HISI_SPI_VERSION),\n};\n\nstatic int hisi_spi_debugfs_init(struct hisi_spi *hs)\n{\n\tchar name[32];\n\n\tstruct spi_controller *host;\n\n\thost = container_of(hs->dev, struct spi_controller, dev);\n\tsnprintf(name, 32, \"hisi_spi%d\", host->bus_num);\n\ths->debugfs = debugfs_create_dir(name, NULL);\n\tif (IS_ERR(hs->debugfs))\n\t\treturn -ENOMEM;\n\n\ths->regset.regs = hisi_spi_regs;\n\ths->regset.nregs = ARRAY_SIZE(hisi_spi_regs);\n\ths->regset.base = hs->regs;\n\tdebugfs_create_regset32(\"registers\", 0400, hs->debugfs, &hs->regset);\n\n\treturn 0;\n}\n\nstatic u32 hisi_spi_busy(struct hisi_spi *hs)\n{\n\treturn readl(hs->regs + HISI_SPI_SR) & SR_BUSY;\n}\n\nstatic u32 hisi_spi_rx_not_empty(struct hisi_spi *hs)\n{\n\treturn readl(hs->regs + HISI_SPI_SR) & SR_RXNE;\n}\n\nstatic u32 hisi_spi_tx_not_full(struct hisi_spi *hs)\n{\n\treturn readl(hs->regs + HISI_SPI_SR) & SR_TXNF;\n}\n\nstatic void hisi_spi_flush_fifo(struct hisi_spi *hs)\n{\n\tunsigned long limit = loops_per_jiffy << 1;\n\n\tdo {\n\t\twhile (hisi_spi_rx_not_empty(hs))\n\t\t\treadl(hs->regs + HISI_SPI_DOUT);\n\t} while (hisi_spi_busy(hs) && limit--);\n}\n\n \nstatic void hisi_spi_disable(struct hisi_spi *hs)\n{\n\twritel(0, hs->regs + HISI_SPI_ENR);\n\twritel(IMR_MASK, hs->regs + HISI_SPI_IMR);\n\twritel(ICR_MASK, hs->regs + HISI_SPI_ICR);\n}\n\nstatic u8 hisi_spi_n_bytes(struct spi_transfer *transfer)\n{\n\tif (transfer->bits_per_word <= 8)\n\t\treturn HISI_SPI_N_BYTES_U8;\n\telse if (transfer->bits_per_word <= 16)\n\t\treturn HISI_SPI_N_BYTES_U16;\n\telse\n\t\treturn HISI_SPI_N_BYTES_U32;\n}\n\nstatic void hisi_spi_reader(struct hisi_spi *hs)\n{\n\tu32 max = min_t(u32, hs->rx_len, hs->fifo_len);\n\tu32 rxw;\n\n\twhile (hisi_spi_rx_not_empty(hs) && max--) {\n\t\trxw = readl(hs->regs + HISI_SPI_DOUT);\n\t\t \n\t\tif (hs->rx) {\n\t\t\tswitch (hs->n_bytes) {\n\t\t\tcase HISI_SPI_N_BYTES_U8:\n\t\t\t\t*(u8 *)(hs->rx) = rxw;\n\t\t\t\tbreak;\n\t\t\tcase HISI_SPI_N_BYTES_U16:\n\t\t\t\t*(u16 *)(hs->rx) = rxw;\n\t\t\t\tbreak;\n\t\t\tcase HISI_SPI_N_BYTES_U32:\n\t\t\t\t*(u32 *)(hs->rx) = rxw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ths->rx += hs->n_bytes;\n\t\t}\n\t\t--hs->rx_len;\n\t}\n}\n\nstatic void hisi_spi_writer(struct hisi_spi *hs)\n{\n\tu32 max = min_t(u32, hs->tx_len, hs->fifo_len);\n\tu32 txw = 0;\n\n\twhile (hisi_spi_tx_not_full(hs) && max--) {\n\t\t \n\t\tif (hs->tx) {\n\t\t\tswitch (hs->n_bytes) {\n\t\t\tcase HISI_SPI_N_BYTES_U8:\n\t\t\t\ttxw = *(u8 *)(hs->tx);\n\t\t\t\tbreak;\n\t\t\tcase HISI_SPI_N_BYTES_U16:\n\t\t\t\ttxw = *(u16 *)(hs->tx);\n\t\t\t\tbreak;\n\t\t\tcase HISI_SPI_N_BYTES_U32:\n\t\t\t\ttxw = *(u32 *)(hs->tx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ths->tx += hs->n_bytes;\n\t\t}\n\t\twritel(txw, hs->regs + HISI_SPI_DIN);\n\t\t--hs->tx_len;\n\t}\n}\n\nstatic void __hisi_calc_div_reg(struct hisi_chip_data *chip)\n{\n\tchip->div_pre = DIV_PRE_MAX;\n\twhile (chip->div_pre >= DIV_PRE_MIN) {\n\t\tif (chip->clk_div % chip->div_pre == 0)\n\t\t\tbreak;\n\n\t\tchip->div_pre -= 2;\n\t}\n\n\tif (chip->div_pre > chip->clk_div)\n\t\tchip->div_pre = chip->clk_div;\n\n\tchip->div_post = (chip->clk_div / chip->div_pre) - 1;\n}\n\nstatic u32 hisi_calc_effective_speed(struct spi_controller *host,\n\t\t\tstruct hisi_chip_data *chip, u32 speed_hz)\n{\n\tu32 effective_speed;\n\n\t \n\tchip->clk_div = DIV_ROUND_UP(host->max_speed_hz, speed_hz) + 1;\n\tchip->clk_div &= 0xfffe;\n\tif (chip->clk_div > CLK_DIV_MAX)\n\t\tchip->clk_div = CLK_DIV_MAX;\n\n\teffective_speed = host->max_speed_hz / chip->clk_div;\n\tif (chip->speed_hz != effective_speed) {\n\t\t__hisi_calc_div_reg(chip);\n\t\tchip->speed_hz = effective_speed;\n\t}\n\n\treturn effective_speed;\n}\n\nstatic u32 hisi_spi_prepare_cr(struct spi_device *spi)\n{\n\tu32 cr = FIELD_PREP(CR_SPD_MODE_MASK, 1);\n\n\tcr |= FIELD_PREP(CR_CPHA_MASK, (spi->mode & SPI_CPHA) ? 1 : 0);\n\tcr |= FIELD_PREP(CR_CPOL_MASK, (spi->mode & SPI_CPOL) ? 1 : 0);\n\tcr |= FIELD_PREP(CR_LOOP_MASK, (spi->mode & SPI_LOOP) ? 1 : 0);\n\n\treturn cr;\n}\n\nstatic void hisi_spi_hw_init(struct hisi_spi *hs)\n{\n\thisi_spi_disable(hs);\n\n\t \n\twritel(FIELD_PREP(FIFOC_TX_MASK, HISI_SPI_TX_64_OR_LESS) |\n\t\tFIELD_PREP(FIFOC_RX_MASK, HISI_SPI_RX_16),\n\t\ths->regs + HISI_SPI_FIFOC);\n\n\ths->fifo_len = 256;\n}\n\nstatic irqreturn_t hisi_spi_irq(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = dev_id;\n\tstruct hisi_spi *hs = spi_controller_get_devdata(host);\n\tu32 irq_status = readl(hs->regs + HISI_SPI_ISR) & ISR_MASK;\n\n\tif (!irq_status)\n\t\treturn IRQ_NONE;\n\n\tif (!host->cur_msg)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (irq_status & ISR_RXOF) {\n\t\tdev_err(hs->dev, \"interrupt_transfer: fifo overflow\\n\");\n\t\thost->cur_msg->status = -EIO;\n\t\tgoto finalize_transfer;\n\t}\n\n\t \n\thisi_spi_reader(hs);\n\tif (!hs->rx_len)\n\t\tgoto finalize_transfer;\n\n\t \n\tif (irq_status & ISR_TX)\n\t\thisi_spi_writer(hs);\n\n\treturn IRQ_HANDLED;\n\nfinalize_transfer:\n\thisi_spi_disable(hs);\n\tspi_finalize_current_transfer(host);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hisi_spi_transfer_one(struct spi_controller *host,\n\t\tstruct spi_device *spi, struct spi_transfer *transfer)\n{\n\tstruct hisi_spi *hs = spi_controller_get_devdata(host);\n\tstruct hisi_chip_data *chip = spi_get_ctldata(spi);\n\tu32 cr = chip->cr;\n\n\t \n\ttransfer->effective_speed_hz =\n\t\thisi_calc_effective_speed(host, chip, transfer->speed_hz);\n\tcr |= FIELD_PREP(CR_DIV_PRE_MASK, chip->div_pre);\n\tcr |= FIELD_PREP(CR_DIV_POST_MASK, chip->div_post);\n\tcr |= FIELD_PREP(CR_BPW_MASK, transfer->bits_per_word - 1);\n\twritel(cr, hs->regs + HISI_SPI_CR);\n\n\thisi_spi_flush_fifo(hs);\n\n\ths->n_bytes = hisi_spi_n_bytes(transfer);\n\ths->tx = transfer->tx_buf;\n\ths->tx_len = transfer->len / hs->n_bytes;\n\ths->rx = transfer->rx_buf;\n\ths->rx_len = hs->tx_len;\n\n\t \n\tsmp_mb();\n\n\t \n\twritel(~(u32)IMR_MASK, hs->regs + HISI_SPI_IMR);\n\twritel(1, hs->regs + HISI_SPI_ENR);\n\n\treturn 1;\n}\n\nstatic void hisi_spi_handle_err(struct spi_controller *host,\n\t\tstruct spi_message *msg)\n{\n\tstruct hisi_spi *hs = spi_controller_get_devdata(host);\n\n\thisi_spi_disable(hs);\n\n\t \n\tmsleep(HISI_SPI_WAIT_TIMEOUT_MS);\n}\n\nstatic int hisi_spi_setup(struct spi_device *spi)\n{\n\tstruct hisi_chip_data *chip;\n\n\t \n\tchip = spi_get_ctldata(spi);\n\tif (!chip) {\n\t\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\t\tspi_set_ctldata(spi, chip);\n\t}\n\n\tchip->cr = hisi_spi_prepare_cr(spi);\n\n\treturn 0;\n}\n\nstatic void hisi_spi_cleanup(struct spi_device *spi)\n{\n\tstruct hisi_chip_data *chip = spi_get_ctldata(spi);\n\n\tkfree(chip);\n\tspi_set_ctldata(spi, NULL);\n}\n\nstatic int hisi_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *host;\n\tstruct hisi_spi *hs;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = devm_spi_alloc_host(dev, sizeof(*hs));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, host);\n\n\ths = spi_controller_get_devdata(host);\n\ths->dev = dev;\n\ths->irq = irq;\n\n\ths->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hs->regs))\n\t\treturn PTR_ERR(hs->regs);\n\n\t \n\tret = device_property_read_u32(dev, \"spi-max-frequency\",\n\t\t\t\t\t&host->max_speed_hz);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get max SPI clocking speed, ret=%d\\n\",\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u16(dev, \"num-cs\",\n\t\t\t\t\t&host->num_chipselect);\n\tif (ret)\n\t\thost->num_chipselect = DEFAULT_NUM_CS;\n\n\thost->use_gpio_descriptors = true;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\thost->bus_num = pdev->id;\n\thost->setup = hisi_spi_setup;\n\thost->cleanup = hisi_spi_cleanup;\n\thost->transfer_one = hisi_spi_transfer_one;\n\thost->handle_err = hisi_spi_handle_err;\n\thost->dev.fwnode = dev->fwnode;\n\n\thisi_spi_hw_init(hs);\n\n\tret = devm_request_irq(dev, hs->irq, hisi_spi_irq, 0, dev_name(dev),\n\t\t\t       host);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get IRQ=%d, ret=%d\\n\", hs->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = spi_register_controller(host);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register spi host, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (hisi_spi_debugfs_init(hs))\n\t\tdev_info(dev, \"failed to create debugfs dir\\n\");\n\n\tdev_info(dev, \"hw version:0x%x max-freq:%u kHz\\n\",\n\t\treadl(hs->regs + HISI_SPI_VERSION),\n\t\thost->max_speed_hz / 1000);\n\n\treturn 0;\n}\n\nstatic void hisi_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct hisi_spi *hs = spi_controller_get_devdata(host);\n\n\tdebugfs_remove_recursive(hs->debugfs);\n\tspi_unregister_controller(host);\n}\n\nstatic const struct acpi_device_id hisi_spi_acpi_match[] = {\n\t{\"HISI03E1\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_spi_acpi_match);\n\nstatic struct platform_driver hisi_spi_driver = {\n\t.probe\t\t= hisi_spi_probe,\n\t.remove_new\t= hisi_spi_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hisi-kunpeng-spi\",\n\t\t.acpi_match_table = hisi_spi_acpi_match,\n\t},\n};\nmodule_platform_driver(hisi_spi_driver);\n\nMODULE_AUTHOR(\"Jay Fang <f.fangjian@huawei.com>\");\nMODULE_DESCRIPTION(\"HiSilicon SPI Controller Driver for Kunpeng SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}