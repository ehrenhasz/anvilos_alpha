{
  "module_name": "spi-mpc512x-psc.c",
  "hash_id": "783aad35c495fa3948d66775284dd81a7b38b9cbd3a4ea4fc3892e2f56d8f78d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mpc512x-psc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/spi/spi.h>\n#include <asm/mpc52xx_psc.h>\n\nenum {\n\tTYPE_MPC5121,\n\tTYPE_MPC5125,\n};\n\n \n#define psc_addr(mps, regname) ({\t\t\t\t\t\\\n\tvoid *__ret = NULL;\t\t\t\t\t\t\\\n\tswitch (mps->type) {\t\t\t\t\t\t\\\n\tcase TYPE_MPC5121: {\t\t\t\t\t\t\\\n\t\t\tstruct mpc52xx_psc __iomem *psc = mps->psc;\t\\\n\t\t\t__ret = &psc->regname;\t\t\t\t\\\n\t\t};\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase TYPE_MPC5125: {\t\t\t\t\t\t\\\n\t\t\tstruct mpc5125_psc __iomem *psc = mps->psc;\t\\\n\t\t\t__ret = &psc->regname;\t\t\t\t\\\n\t\t};\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__ret; })\n\nstruct mpc512x_psc_spi {\n\t \n\tint type;\n\tvoid __iomem *psc;\n\tstruct mpc512x_psc_fifo __iomem *fifo;\n\tint irq;\n\tu8 bits_per_word;\n\tu32 mclk_rate;\n\n\tstruct completion txisrdone;\n};\n\n \nstruct mpc512x_psc_spi_cs {\n\tint bits_per_word;\n\tint speed_hz;\n};\n\n \nstatic int mpc512x_psc_spi_transfer_setup(struct spi_device *spi,\n\t\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct mpc512x_psc_spi_cs *cs = spi->controller_state;\n\n\tcs->speed_hz = (t && t->speed_hz)\n\t    ? t->speed_hz : spi->max_speed_hz;\n\tcs->bits_per_word = (t && t->bits_per_word)\n\t    ? t->bits_per_word : spi->bits_per_word;\n\tcs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;\n\treturn 0;\n}\n\nstatic void mpc512x_psc_spi_activate_cs(struct spi_device *spi)\n{\n\tstruct mpc512x_psc_spi_cs *cs = spi->controller_state;\n\tstruct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);\n\tu32 sicr;\n\tu32 ccr;\n\tint speed;\n\tu16 bclkdiv;\n\n\tsicr = in_be32(psc_addr(mps, sicr));\n\n\t \n\tif (spi->mode & SPI_CPHA)\n\t\tsicr |= 0x00001000;\n\telse\n\t\tsicr &= ~0x00001000;\n\n\tif (spi->mode & SPI_CPOL)\n\t\tsicr |= 0x00002000;\n\telse\n\t\tsicr &= ~0x00002000;\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tsicr |= 0x10000000;\n\telse\n\t\tsicr &= ~0x10000000;\n\tout_be32(psc_addr(mps, sicr), sicr);\n\n\tccr = in_be32(psc_addr(mps, ccr));\n\tccr &= 0xFF000000;\n\tspeed = cs->speed_hz;\n\tif (!speed)\n\t\tspeed = 1000000;\t \n\tbclkdiv = (mps->mclk_rate / speed) - 1;\n\n\tccr |= (((bclkdiv & 0xff) << 16) | (((bclkdiv >> 8) & 0xff) << 8));\n\tout_be32(psc_addr(mps, ccr), ccr);\n\tmps->bits_per_word = cs->bits_per_word;\n\n\tif (spi_get_csgpiod(spi, 0)) {\n\t\t \n\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 1);\n\t}\n}\n\nstatic void mpc512x_psc_spi_deactivate_cs(struct spi_device *spi)\n{\n\tif (spi_get_csgpiod(spi, 0)) {\n\t\t \n\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 0);\n\t}\n}\n\n \n#define MPC512x_PSC_FIFO_SZ(sz) ((sz & 0x7ff) << 2);\n\n#define EOFBYTE 1\n\nstatic int mpc512x_psc_spi_transfer_rxtx(struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *t)\n{\n\tstruct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);\n\tstruct mpc512x_psc_fifo __iomem *fifo = mps->fifo;\n\tsize_t tx_len = t->len;\n\tsize_t rx_len = t->len;\n\tu8 *tx_buf = (u8 *)t->tx_buf;\n\tu8 *rx_buf = (u8 *)t->rx_buf;\n\n\tif (!tx_buf && !rx_buf && t->len)\n\t\treturn -EINVAL;\n\n\twhile (rx_len || tx_len) {\n\t\tsize_t txcount;\n\t\tu8 data;\n\t\tsize_t fifosz;\n\t\tsize_t rxcount;\n\t\tint rxtries;\n\n\t\t \n\t\tfifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->txsz));\n\t\ttxcount = min(fifosz, tx_len);\n\t\tfifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->rxsz));\n\t\tfifosz -= in_be32(&fifo->rxcnt) + 1;\n\t\ttxcount = min(fifosz, txcount);\n\t\tif (txcount) {\n\n\t\t\t \n\t\t\twhile (txcount-- > 0) {\n\t\t\t\tdata = tx_buf ? *tx_buf++ : 0;\n\t\t\t\tif (tx_len == EOFBYTE && t->cs_change)\n\t\t\t\t\tsetbits32(&fifo->txcmd,\n\t\t\t\t\t\t  MPC512x_PSC_FIFO_EOF);\n\t\t\t\tout_8(&fifo->txdata_8, data);\n\t\t\t\ttx_len--;\n\t\t\t}\n\n\t\t\t \n\t\t\treinit_completion(&mps->txisrdone);\n\t\t\tout_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);\n\t\t\tout_be32(&fifo->tximr, MPC512x_PSC_FIFO_EMPTY);\n\t\t\twait_for_completion(&mps->txisrdone);\n\t\t}\n\n\t\t \n\t\trxtries = 50;\n\t\tdo {\n\n\t\t\t \n\t\t\tfifosz = in_be32(&fifo->rxcnt);\n\t\t\trxcount = min(fifosz, rx_len);\n\t\t\twhile (rxcount-- > 0) {\n\t\t\t\tdata = in_8(&fifo->rxdata_8);\n\t\t\t\tif (rx_buf)\n\t\t\t\t\t*rx_buf++ = data;\n\t\t\t\trx_len--;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tx_len)\n\t\t\t\tbreak;\n\t\t\tif (!rx_len)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tusleep_range(10, 100);\n\n\t\t} while (--rxtries > 0);\n\t\tif (!tx_len && rx_len && !rxtries) {\n\t\t\t \n\t\t\trxcount = in_be32(&fifo->rxcnt);\n\t\t\tdev_warn(&spi->dev,\n\t\t\t\t \"short xfer, missing %zd RX bytes, FIFO level %zd\\n\",\n\t\t\t\t rx_len, rxcount);\n\t\t}\n\n\t\t \n\t\tif (!tx_len && !rx_len) {\n\t\t\twhile (in_be32(&fifo->rxcnt))\n\t\t\t\tin_8(&fifo->rxdata_8);\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nstatic int mpc512x_psc_spi_msg_xfer(struct spi_master *master,\n\t\t\t\t    struct spi_message *m)\n{\n\tstruct spi_device *spi;\n\tunsigned cs_change;\n\tint status;\n\tstruct spi_transfer *t;\n\n\tspi = m->spi;\n\tcs_change = 1;\n\tstatus = 0;\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tstatus = mpc512x_psc_spi_transfer_setup(spi, t);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (cs_change)\n\t\t\tmpc512x_psc_spi_activate_cs(spi);\n\t\tcs_change = t->cs_change;\n\n\t\tstatus = mpc512x_psc_spi_transfer_rxtx(spi, t);\n\t\tif (status)\n\t\t\tbreak;\n\t\tm->actual_length += t->len;\n\n\t\tspi_transfer_delay_exec(t);\n\n\t\tif (cs_change)\n\t\t\tmpc512x_psc_spi_deactivate_cs(spi);\n\t}\n\n\tm->status = status;\n\tif (m->complete)\n\t\tm->complete(m->context);\n\n\tif (status || !cs_change)\n\t\tmpc512x_psc_spi_deactivate_cs(spi);\n\n\tmpc512x_psc_spi_transfer_setup(spi, NULL);\n\n\tspi_finalize_current_message(master);\n\treturn status;\n}\n\nstatic int mpc512x_psc_spi_prep_xfer_hw(struct spi_master *master)\n{\n\tstruct mpc512x_psc_spi *mps = spi_master_get_devdata(master);\n\n\tdev_dbg(&master->dev, \"%s()\\n\", __func__);\n\n\t \n\tin_8(psc_addr(mps, mr2));\n\tout_8(psc_addr(mps, mr2), 0x0);\n\n\t \n\tout_8(psc_addr(mps, command), MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\n\n\treturn 0;\n}\n\nstatic int mpc512x_psc_spi_unprep_xfer_hw(struct spi_master *master)\n{\n\tstruct mpc512x_psc_spi *mps = spi_master_get_devdata(master);\n\tstruct mpc512x_psc_fifo __iomem *fifo = mps->fifo;\n\n\tdev_dbg(&master->dev, \"%s()\\n\", __func__);\n\n\t \n\tout_8(psc_addr(mps, command), MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\n\tout_be32(&fifo->tximr, 0);\n\n\treturn 0;\n}\n\nstatic int mpc512x_psc_spi_setup(struct spi_device *spi)\n{\n\tstruct mpc512x_psc_spi_cs *cs = spi->controller_state;\n\n\tif (spi->bits_per_word % 8)\n\t\treturn -EINVAL;\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\n\t\tspi->controller_state = cs;\n\t}\n\n\tcs->bits_per_word = spi->bits_per_word;\n\tcs->speed_hz = spi->max_speed_hz;\n\n\treturn 0;\n}\n\nstatic void mpc512x_psc_spi_cleanup(struct spi_device *spi)\n{\n\tkfree(spi->controller_state);\n}\n\nstatic int mpc512x_psc_spi_port_config(struct spi_master *master,\n\t\t\t\t       struct mpc512x_psc_spi *mps)\n{\n\tstruct mpc512x_psc_fifo __iomem *fifo = mps->fifo;\n\tu32 sicr;\n\tu32 ccr;\n\tint speed;\n\tu16 bclkdiv;\n\n\t \n\tout_8(psc_addr(mps, command), MPC52xx_PSC_RST_RX);\n\tout_8(psc_addr(mps, command), MPC52xx_PSC_RST_TX);\n\tout_8(psc_addr(mps, command), MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\n\n\t \n\tout_be16(psc_addr(mps, isr_imr.imr), 0);\n\n\t \n\tout_be32(&fifo->tximr, 0);\n\tout_be32(&fifo->rximr, 0);\n\n\t \n\t \n\t \n\n\tsicr =\t0x01000000 |\t \n\t\t0x00800000 |\t \n\t\t0x00008000 |\t \n\t\t0x00004000 |\t \n\t\t0x00000800;\t \n\n\tout_be32(psc_addr(mps, sicr), sicr);\n\n\tccr = in_be32(psc_addr(mps, ccr));\n\tccr &= 0xFF000000;\n\tspeed = 1000000;\t \n\tbclkdiv = (mps->mclk_rate / speed) - 1;\n\tccr |= (((bclkdiv & 0xff) << 16) | (((bclkdiv >> 8) & 0xff) << 8));\n\tout_be32(psc_addr(mps, ccr), ccr);\n\n\t \n\tout_8(psc_addr(mps, ctur), 0x00);\n\tout_8(psc_addr(mps, ctlr), 0x82);\n\n\t \n\tout_be32(&fifo->rxalarm, 0xfff);\n\tout_be32(&fifo->txalarm, 0);\n\n\t \n\tout_be32(&fifo->rxcmd,\n\t\t MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);\n\tout_be32(&fifo->txcmd,\n\t\t MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);\n\n\tmps->bits_per_word = 8;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mpc512x_psc_spi_isr(int irq, void *dev_id)\n{\n\tstruct mpc512x_psc_spi *mps = (struct mpc512x_psc_spi *)dev_id;\n\tstruct mpc512x_psc_fifo __iomem *fifo = mps->fifo;\n\n\t \n\tif (in_be32(&fifo->txisr) &\n\t    in_be32(&fifo->tximr) & MPC512x_PSC_FIFO_EMPTY) {\n\t\tout_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);\n\t\tout_be32(&fifo->tximr, 0);\n\t\tcomplete(&mps->txisrdone);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int mpc512x_psc_spi_of_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mpc512x_psc_spi *mps;\n\tstruct spi_master *master;\n\tint ret;\n\tvoid *tempp;\n\tstruct clk *clk;\n\n\tmaster = devm_spi_alloc_master(dev, sizeof(*mps));\n\tif (master == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, master);\n\tmps = spi_master_get_devdata(master);\n\tmps->type = (int)device_get_match_data(dev);\n\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\tmaster->setup = mpc512x_psc_spi_setup;\n\tmaster->prepare_transfer_hardware = mpc512x_psc_spi_prep_xfer_hw;\n\tmaster->transfer_one_message = mpc512x_psc_spi_msg_xfer;\n\tmaster->unprepare_transfer_hardware = mpc512x_psc_spi_unprep_xfer_hw;\n\tmaster->use_gpio_descriptors = true;\n\tmaster->cleanup = mpc512x_psc_spi_cleanup;\n\n\tdevice_set_node(&master->dev, dev_fwnode(dev));\n\n\ttempp = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(tempp))\n\t\treturn dev_err_probe(dev, PTR_ERR(tempp), \"could not ioremap I/O port range\\n\");\n\tmps->psc = tempp;\n\tmps->fifo =\n\t\t(struct mpc512x_psc_fifo *)(tempp + sizeof(struct mpc52xx_psc));\n\n\tmps->irq = platform_get_irq(pdev, 0);\n\tif (mps->irq < 0)\n\t\treturn mps->irq;\n\n\tret = devm_request_irq(dev, mps->irq, mpc512x_psc_spi_isr, IRQF_SHARED,\n\t\t\t\t\"mpc512x-psc-spi\", mps);\n\tif (ret)\n\t\treturn ret;\n\tinit_completion(&mps->txisrdone);\n\n\tclk = devm_clk_get_enabled(dev, \"mclk\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tmps->mclk_rate = clk_get_rate(clk);\n\n\tclk = devm_clk_get_enabled(dev, \"ipg\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = mpc512x_psc_spi_port_config(master, mps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_spi_register_master(dev, master);\n}\n\nstatic const struct of_device_id mpc512x_psc_spi_of_match[] = {\n\t{ .compatible = \"fsl,mpc5121-psc-spi\", .data = (void *)TYPE_MPC5121 },\n\t{ .compatible = \"fsl,mpc5125-psc-spi\", .data = (void *)TYPE_MPC5125 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mpc512x_psc_spi_of_match);\n\nstatic struct platform_driver mpc512x_psc_spi_of_driver = {\n\t.probe = mpc512x_psc_spi_of_probe,\n\t.driver = {\n\t\t.name = \"mpc512x-psc-spi\",\n\t\t.of_match_table = mpc512x_psc_spi_of_match,\n\t},\n};\nmodule_platform_driver(mpc512x_psc_spi_of_driver);\n\nMODULE_AUTHOR(\"John Rigby\");\nMODULE_DESCRIPTION(\"MPC512x PSC SPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}