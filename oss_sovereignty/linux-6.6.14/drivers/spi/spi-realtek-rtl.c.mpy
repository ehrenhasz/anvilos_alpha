{
  "module_name": "spi-realtek-rtl.c",
  "hash_id": "96f987c14c40d12647b776e75ddd61cedac704fb47c36a97372e29d95a2f97ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-realtek-rtl.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n\nstruct rtspi {\n\tvoid __iomem *base;\n};\n\n \n#define RTL_SPI_SFCR\t\t\t0x00\n#define RTL_SPI_SFCR_RBO\t\tBIT(28)\n#define RTL_SPI_SFCR_WBO\t\tBIT(27)\n\n \n#define RTL_SPI_SFCSR\t\t\t0x08\n#define RTL_SPI_SFCSR_CSB0\t\tBIT(31)\n#define RTL_SPI_SFCSR_CSB1\t\tBIT(30)\n#define RTL_SPI_SFCSR_RDY\t\tBIT(27)\n#define RTL_SPI_SFCSR_CS\t\tBIT(24)\n#define RTL_SPI_SFCSR_LEN_MASK\t\t~(0x03 << 28)\n#define RTL_SPI_SFCSR_LEN1\t\t(0x00 << 28)\n#define RTL_SPI_SFCSR_LEN4\t\t(0x03 << 28)\n\n \n#define RTL_SPI_SFDR\t\t\t0x0c\n\n#define REG(x)\t\t(rtspi->base + x)\n\n\nstatic void rt_set_cs(struct spi_device *spi, bool active)\n{\n\tstruct rtspi *rtspi = spi_controller_get_devdata(spi->controller);\n\tu32 value;\n\n\t \n\tvalue = readl(REG(RTL_SPI_SFCSR));\n\tif (active)\n\t\tvalue |= RTL_SPI_SFCSR_CSB0;\n\telse\n\t\tvalue &= ~RTL_SPI_SFCSR_CSB0;\n\twritel(value, REG(RTL_SPI_SFCSR));\n}\n\nstatic void set_size(struct rtspi *rtspi, int size)\n{\n\tu32 value;\n\n\tvalue = readl(REG(RTL_SPI_SFCSR));\n\tvalue &= RTL_SPI_SFCSR_LEN_MASK;\n\tif (size == 4)\n\t\tvalue |= RTL_SPI_SFCSR_LEN4;\n\telse if (size == 1)\n\t\tvalue |= RTL_SPI_SFCSR_LEN1;\n\twritel(value, REG(RTL_SPI_SFCSR));\n}\n\nstatic inline void wait_ready(struct rtspi *rtspi)\n{\n\twhile (!(readl(REG(RTL_SPI_SFCSR)) & RTL_SPI_SFCSR_RDY))\n\t\tcpu_relax();\n}\nstatic void send4(struct rtspi *rtspi, const u32 *buf)\n{\n\twait_ready(rtspi);\n\tset_size(rtspi, 4);\n\twritel(*buf, REG(RTL_SPI_SFDR));\n}\n\nstatic void send1(struct rtspi *rtspi, const u8 *buf)\n{\n\twait_ready(rtspi);\n\tset_size(rtspi, 1);\n\twritel(buf[0] << 24, REG(RTL_SPI_SFDR));\n}\n\nstatic void rcv4(struct rtspi *rtspi, u32 *buf)\n{\n\twait_ready(rtspi);\n\tset_size(rtspi, 4);\n\t*buf = readl(REG(RTL_SPI_SFDR));\n}\n\nstatic void rcv1(struct rtspi *rtspi, u8 *buf)\n{\n\twait_ready(rtspi);\n\tset_size(rtspi, 1);\n\t*buf = readl(REG(RTL_SPI_SFDR)) >> 24;\n}\n\nstatic int transfer_one(struct spi_controller *ctrl, struct spi_device *spi,\n\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct rtspi *rtspi = spi_controller_get_devdata(ctrl);\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tint cnt;\n\n\ttx_buf = xfer->tx_buf;\n\trx_buf = xfer->rx_buf;\n\tcnt = xfer->len;\n\tif (tx_buf) {\n\t\twhile (cnt >= 4) {\n\t\t\tsend4(rtspi, tx_buf);\n\t\t\ttx_buf += 4;\n\t\t\tcnt -= 4;\n\t\t}\n\t\twhile (cnt) {\n\t\t\tsend1(rtspi, tx_buf);\n\t\t\ttx_buf++;\n\t\t\tcnt--;\n\t\t}\n\t} else if (rx_buf) {\n\t\twhile (cnt >= 4) {\n\t\t\trcv4(rtspi, rx_buf);\n\t\t\trx_buf += 4;\n\t\t\tcnt -= 4;\n\t\t}\n\t\twhile (cnt) {\n\t\t\trcv1(rtspi, rx_buf);\n\t\t\trx_buf++;\n\t\t\tcnt--;\n\t\t}\n\t}\n\n\tspi_finalize_current_transfer(ctrl);\n\n\treturn 0;\n}\n\nstatic void init_hw(struct rtspi *rtspi)\n{\n\tu32 value;\n\n\t \n\tvalue = readl(REG(RTL_SPI_SFCR));\n\tvalue |= RTL_SPI_SFCR_RBO | RTL_SPI_SFCR_WBO;\n\twritel(value, REG(RTL_SPI_SFCR));\n\n\tvalue = readl(REG(RTL_SPI_SFCSR));\n\t \n\tvalue |= RTL_SPI_SFCSR_CSB1;\n\t \n\tvalue &= RTL_SPI_SFCSR_CS;\n\twritel(value, REG(RTL_SPI_SFCSR));\n}\n\nstatic int realtek_rtl_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl;\n\tstruct rtspi *rtspi;\n\tint err;\n\n\tctrl = devm_spi_alloc_host(&pdev->dev, sizeof(*rtspi));\n\tif (!ctrl) {\n\t\tdev_err(&pdev->dev, \"Error allocating SPI controller\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, ctrl);\n\trtspi = spi_controller_get_devdata(ctrl);\n\n\trtspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(rtspi->base)) {\n\t\tdev_err(&pdev->dev, \"Could not map SPI register address\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_hw(rtspi);\n\n\tctrl->dev.of_node = pdev->dev.of_node;\n\tctrl->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tctrl->set_cs = rt_set_cs;\n\tctrl->transfer_one = transfer_one;\n\n\terr = devm_spi_register_controller(&pdev->dev, ctrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not register SPI controller\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct of_device_id realtek_rtl_spi_of_ids[] = {\n\t{ .compatible = \"realtek,rtl8380-spi\" },\n\t{ .compatible = \"realtek,rtl8382-spi\" },\n\t{ .compatible = \"realtek,rtl8391-spi\" },\n\t{ .compatible = \"realtek,rtl8392-spi\" },\n\t{ .compatible = \"realtek,rtl8393-spi\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, realtek_rtl_spi_of_ids);\n\nstatic struct platform_driver realtek_rtl_spi_driver = {\n\t.probe = realtek_rtl_spi_probe,\n\t.driver = {\n\t\t.name = \"realtek-rtl-spi\",\n\t\t.of_match_table = realtek_rtl_spi_of_ids,\n\t},\n};\n\nmodule_platform_driver(realtek_rtl_spi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Bert Vermeulen <bert@biot.com>\");\nMODULE_DESCRIPTION(\"Realtek RTL SPI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}