{
  "module_name": "spi-cs42l43.c",
  "hash_id": "fcc3d1da9579daf62c8cce5e67548fbd50b7100a707ecc8860f8d3d3036690c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-cs42l43.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/mfd/cs42l43.h>\n#include <linux/mfd/cs42l43-regs.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#define CS42L43_FIFO_SIZE\t\t16\n#define CS42L43_SPI_ROOT_HZ\t\t(40 * HZ_PER_MHZ)\n#define CS42L43_SPI_MAX_LENGTH\t\t65532\n\nenum cs42l43_spi_cmd {\n\tCS42L43_WRITE,\n\tCS42L43_READ\n};\n\nstruct cs42l43_spi {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct spi_controller *ctlr;\n};\n\nstatic const unsigned int cs42l43_clock_divs[] = {\n\t2, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n};\n\nstatic int cs42l43_spi_tx(struct regmap *regmap, const u8 *buf, unsigned int len)\n{\n\tconst u8 *end = buf + len;\n\tu32 val = 0;\n\tint ret;\n\n\twhile (buf < end) {\n\t\tconst u8 *block = min(buf + CS42L43_FIFO_SIZE, end);\n\n\t\twhile (buf < block) {\n\t\t\tconst u8 *word = min(buf + sizeof(u32), block);\n\t\t\tint pad = (buf + sizeof(u32)) - word;\n\n\t\t\twhile (buf < word) {\n\t\t\t\tval >>= BITS_PER_BYTE;\n\t\t\t\tval |= FIELD_PREP(GENMASK(31, 24), *buf);\n\n\t\t\t\tbuf++;\n\t\t\t}\n\n\t\t\tval >>= pad * BITS_PER_BYTE;\n\n\t\t\tregmap_write(regmap, CS42L43_TX_DATA, val);\n\t\t}\n\n\t\tregmap_write(regmap, CS42L43_TRAN_CONFIG8, CS42L43_SPI_TX_DONE_MASK);\n\n\t\tret = regmap_read_poll_timeout(regmap, CS42L43_TRAN_STATUS1,\n\t\t\t\t\t       val, (val & CS42L43_SPI_TX_REQUEST_MASK),\n\t\t\t\t\t       1000, 5000);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l43_spi_rx(struct regmap *regmap, u8 *buf, unsigned int len)\n{\n\tu8 *end = buf + len;\n\tu32 val;\n\tint ret;\n\n\twhile (buf < end) {\n\t\tu8 *block = min(buf + CS42L43_FIFO_SIZE, end);\n\n\t\tret = regmap_read_poll_timeout(regmap, CS42L43_TRAN_STATUS1,\n\t\t\t\t\t       val, (val & CS42L43_SPI_RX_REQUEST_MASK),\n\t\t\t\t\t       1000, 5000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twhile (buf < block) {\n\t\t\tu8 *word = min(buf + sizeof(u32), block);\n\n\t\t\tret = regmap_read(regmap, CS42L43_RX_DATA, &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twhile (buf < word) {\n\t\t\t\t*buf = FIELD_GET(GENMASK(7, 0), val);\n\n\t\t\t\tval >>= BITS_PER_BYTE;\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t}\n\n\t\tregmap_write(regmap, CS42L43_TRAN_CONFIG8, CS42L43_SPI_RX_DONE_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l43_transfer_one(struct spi_controller *ctlr, struct spi_device *spi,\n\t\t\t\tstruct spi_transfer *tfr)\n{\n\tstruct cs42l43_spi *priv = spi_controller_get_devdata(spi->controller);\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l43_clock_divs); i++) {\n\t\tif (CS42L43_SPI_ROOT_HZ / cs42l43_clock_divs[i] <= tfr->speed_hz)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(cs42l43_clock_divs))\n\t\treturn -EINVAL;\n\n\tregmap_write(priv->regmap, CS42L43_SPI_CLK_CONFIG1, i);\n\n\tif (tfr->tx_buf) {\n\t\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG3, CS42L43_WRITE);\n\t\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG4, tfr->len - 1);\n\t} else if (tfr->rx_buf) {\n\t\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG3, CS42L43_READ);\n\t\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG5, tfr->len - 1);\n\t}\n\n\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG1, CS42L43_SPI_START_MASK);\n\n\tif (tfr->tx_buf)\n\t\tret = cs42l43_spi_tx(priv->regmap, (const u8 *)tfr->tx_buf, tfr->len);\n\telse if (tfr->rx_buf)\n\t\tret = cs42l43_spi_rx(priv->regmap, (u8 *)tfr->rx_buf, tfr->len);\n\n\treturn ret;\n}\n\nstatic void cs42l43_set_cs(struct spi_device *spi, bool is_high)\n{\n\tstruct cs42l43_spi *priv = spi_controller_get_devdata(spi->controller);\n\n\tif (spi_get_chipselect(spi, 0) == 0)\n\t\tregmap_write(priv->regmap, CS42L43_SPI_CONFIG2, !is_high);\n}\n\nstatic int cs42l43_prepare_message(struct spi_controller *ctlr, struct spi_message *msg)\n{\n\tstruct cs42l43_spi *priv = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = msg->spi;\n\tunsigned int spi_config1 = 0;\n\n\t \n\tif (spi_get_csgpiod(spi, 0))\n\t\tspi_config1 |= 1 << CS42L43_SPI_SS_SEL_SHIFT;\n\tif (spi->mode & SPI_CPOL)\n\t\tspi_config1 |= CS42L43_SPI_CPOL_MASK;\n\tif (spi->mode & SPI_CPHA)\n\t\tspi_config1 |= CS42L43_SPI_CPHA_MASK;\n\tif (spi->mode & SPI_3WIRE)\n\t\tspi_config1 |= CS42L43_SPI_THREE_WIRE_MASK;\n\n\tregmap_write(priv->regmap, CS42L43_SPI_CONFIG1, spi_config1);\n\n\treturn 0;\n}\n\nstatic int cs42l43_prepare_transfer_hardware(struct spi_controller *ctlr)\n{\n\tstruct cs42l43_spi *priv = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = regmap_write(priv->regmap, CS42L43_BLOCK_EN2, CS42L43_SPI_MSTR_EN_MASK);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to enable SPI controller: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cs42l43_unprepare_transfer_hardware(struct spi_controller *ctlr)\n{\n\tstruct cs42l43_spi *priv = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = regmap_write(priv->regmap, CS42L43_BLOCK_EN2, 0);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to disable SPI controller: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic size_t cs42l43_spi_max_length(struct spi_device *spi)\n{\n\treturn CS42L43_SPI_MAX_LENGTH;\n}\n\nstatic int cs42l43_spi_probe(struct platform_device *pdev)\n{\n\tstruct cs42l43 *cs42l43 = dev_get_drvdata(pdev->dev.parent);\n\tstruct cs42l43_spi *priv;\n\tstruct fwnode_handle *fwnode = dev_fwnode(cs42l43->dev);\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ctlr = devm_spi_alloc_master(&pdev->dev, sizeof(*priv->ctlr));\n\tif (!priv->ctlr)\n\t\treturn -ENOMEM;\n\n\tspi_controller_set_devdata(priv->ctlr, priv);\n\n\tpriv->dev = &pdev->dev;\n\tpriv->regmap = cs42l43->regmap;\n\n\tpriv->ctlr->prepare_message = cs42l43_prepare_message;\n\tpriv->ctlr->prepare_transfer_hardware = cs42l43_prepare_transfer_hardware;\n\tpriv->ctlr->unprepare_transfer_hardware = cs42l43_unprepare_transfer_hardware;\n\tpriv->ctlr->transfer_one = cs42l43_transfer_one;\n\tpriv->ctlr->set_cs = cs42l43_set_cs;\n\tpriv->ctlr->max_transfer_size = cs42l43_spi_max_length;\n\n\tif (is_of_node(fwnode))\n\t\tfwnode = fwnode_get_named_child_node(fwnode, \"spi\");\n\n\tdevice_set_node(&priv->ctlr->dev, fwnode);\n\n\tpriv->ctlr->mode_bits = SPI_3WIRE | SPI_MODE_X_MASK;\n\tpriv->ctlr->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tpriv->ctlr->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\n\t\t\t\t\t SPI_BPW_MASK(32);\n\tpriv->ctlr->min_speed_hz = CS42L43_SPI_ROOT_HZ /\n\t\t\t\t   cs42l43_clock_divs[ARRAY_SIZE(cs42l43_clock_divs) - 1];\n\tpriv->ctlr->max_speed_hz = CS42L43_SPI_ROOT_HZ / cs42l43_clock_divs[0];\n\tpriv->ctlr->use_gpio_descriptors = true;\n\tpriv->ctlr->auto_runtime_pm = true;\n\n\tdevm_pm_runtime_enable(priv->dev);\n\tpm_runtime_idle(priv->dev);\n\n\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG6, CS42L43_FIFO_SIZE - 1);\n\tregmap_write(priv->regmap, CS42L43_TRAN_CONFIG7, CS42L43_FIFO_SIZE - 1);\n\n\t\n\tregmap_write(priv->regmap, CS42L43_SPI_CONFIG3, 0);\n\tregmap_write(priv->regmap, CS42L43_SPI_CONFIG4, CS42L43_SPI_STALL_ENA_MASK);\n\n\tret = devm_spi_register_controller(priv->dev, priv->ctlr);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to register SPI controller: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct platform_device_id cs42l43_spi_id_table[] = {\n\t{ \"cs42l43-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, cs42l43_spi_id_table);\n\nstatic struct platform_driver cs42l43_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"cs42l43-spi\",\n\t},\n\t.probe\t\t= cs42l43_spi_probe,\n\t.id_table\t= cs42l43_spi_id_table,\n};\nmodule_platform_driver(cs42l43_spi_driver);\n\nMODULE_DESCRIPTION(\"CS42L43 SPI Driver\");\nMODULE_AUTHOR(\"Lucas Tanure <tanureal@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Maciej Strozek <mstrozek@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}