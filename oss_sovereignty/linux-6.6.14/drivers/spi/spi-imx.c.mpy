{
  "module_name": "spi-imx.c",
  "hash_id": "121620940705c49e6d4a02c1058a268544b647897e413b1a614557ca42265963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-imx.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include <linux/property.h>\n\n#include <linux/dma/imx-dma.h>\n\n#define DRIVER_NAME \"spi_imx\"\n\nstatic bool use_dma = true;\nmodule_param(use_dma, bool, 0644);\nMODULE_PARM_DESC(use_dma, \"Enable usage of DMA when available (default)\");\n\n \nstatic unsigned int polling_limit_us = 30;\nmodule_param(polling_limit_us, uint, 0664);\nMODULE_PARM_DESC(polling_limit_us,\n\t\t \"time in us to run a transfer in polling mode\\n\");\n\n#define MXC_RPM_TIMEOUT\t\t2000  \n\n#define MXC_CSPIRXDATA\t\t0x00\n#define MXC_CSPITXDATA\t\t0x04\n#define MXC_CSPICTRL\t\t0x08\n#define MXC_CSPIINT\t\t0x0c\n#define MXC_RESET\t\t0x1c\n\n \n#define MXC_INT_RR\t(1 << 0)  \n#define MXC_INT_TE\t(1 << 1)  \n#define MXC_INT_RDR\tBIT(4)  \n\n \n#define MAX_SDMA_BD_BYTES (1 << 15)\n#define MX51_ECSPI_CTRL_MAX_BURST\t512\n \n#define MX53_MAX_TRANSFER_BYTES\t\t512\n\nenum spi_imx_devtype {\n\tIMX1_CSPI,\n\tIMX21_CSPI,\n\tIMX27_CSPI,\n\tIMX31_CSPI,\n\tIMX35_CSPI,\t \n\tIMX51_ECSPI,\t \n\tIMX53_ECSPI,\t \n};\n\nstruct spi_imx_data;\n\nstruct spi_imx_devtype_data {\n\tvoid (*intctrl)(struct spi_imx_data *spi_imx, int enable);\n\tint (*prepare_message)(struct spi_imx_data *spi_imx, struct spi_message *msg);\n\tint (*prepare_transfer)(struct spi_imx_data *spi_imx, struct spi_device *spi);\n\tvoid (*trigger)(struct spi_imx_data *spi_imx);\n\tint (*rx_available)(struct spi_imx_data *spi_imx);\n\tvoid (*reset)(struct spi_imx_data *spi_imx);\n\tvoid (*setup_wml)(struct spi_imx_data *spi_imx);\n\tvoid (*disable)(struct spi_imx_data *spi_imx);\n\tbool has_dmamode;\n\tbool has_targetmode;\n\tunsigned int fifo_size;\n\tbool dynamic_burst;\n\t \n\tbool tx_glitch_fixed;\n\tenum spi_imx_devtype devtype;\n};\n\nstruct spi_imx_data {\n\tstruct spi_controller *controller;\n\tstruct device *dev;\n\n\tstruct completion xfer_done;\n\tvoid __iomem *base;\n\tunsigned long base_phys;\n\n\tstruct clk *clk_per;\n\tstruct clk *clk_ipg;\n\tunsigned long spi_clk;\n\tunsigned int spi_bus_clk;\n\n\tunsigned int bits_per_word;\n\tunsigned int spi_drctl;\n\n\tunsigned int count, remainder;\n\tvoid (*tx)(struct spi_imx_data *spi_imx);\n\tvoid (*rx)(struct spi_imx_data *spi_imx);\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tunsigned int txfifo;  \n\tunsigned int dynamic_burst;\n\tbool rx_only;\n\n\t \n\tbool target_mode;\n\tbool target_aborted;\n\tunsigned int target_burst;\n\n\t \n\tbool usedma;\n\tu32 wml;\n\tstruct completion dma_rx_completion;\n\tstruct completion dma_tx_completion;\n\n\tconst struct spi_imx_devtype_data *devtype_data;\n};\n\nstatic inline int is_imx27_cspi(struct spi_imx_data *d)\n{\n\treturn d->devtype_data->devtype == IMX27_CSPI;\n}\n\nstatic inline int is_imx35_cspi(struct spi_imx_data *d)\n{\n\treturn d->devtype_data->devtype == IMX35_CSPI;\n}\n\nstatic inline int is_imx51_ecspi(struct spi_imx_data *d)\n{\n\treturn d->devtype_data->devtype == IMX51_ECSPI;\n}\n\nstatic inline int is_imx53_ecspi(struct spi_imx_data *d)\n{\n\treturn d->devtype_data->devtype == IMX53_ECSPI;\n}\n\n#define MXC_SPI_BUF_RX(type)\t\t\t\t\t\t\\\nstatic void spi_imx_buf_rx_##type(struct spi_imx_data *spi_imx)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (spi_imx->rx_buf) {\t\t\t\t\t\t\\\n\t\t*(type *)spi_imx->rx_buf = val;\t\t\t\t\\\n\t\tspi_imx->rx_buf += sizeof(type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspi_imx->remainder -= sizeof(type);\t\t\t\t\\\n}\n\n#define MXC_SPI_BUF_TX(type)\t\t\t\t\t\t\\\nstatic void spi_imx_buf_tx_##type(struct spi_imx_data *spi_imx)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype val = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (spi_imx->tx_buf) {\t\t\t\t\t\t\\\n\t\tval = *(type *)spi_imx->tx_buf;\t\t\t\t\\\n\t\tspi_imx->tx_buf += sizeof(type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspi_imx->count -= sizeof(type);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twritel(val, spi_imx->base + MXC_CSPITXDATA);\t\t\t\\\n}\n\nMXC_SPI_BUF_RX(u8)\nMXC_SPI_BUF_TX(u8)\nMXC_SPI_BUF_RX(u16)\nMXC_SPI_BUF_TX(u16)\nMXC_SPI_BUF_RX(u32)\nMXC_SPI_BUF_TX(u32)\n\n \nstatic int mxc_clkdivs[] = {0, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192,\n\t256, 384, 512, 768, 1024};\n\n \nstatic unsigned int spi_imx_clkdiv_1(unsigned int fin,\n\t\tunsigned int fspi, unsigned int max, unsigned int *fres)\n{\n\tint i;\n\n\tfor (i = 2; i < max; i++)\n\t\tif (fspi * mxc_clkdivs[i] >= fin)\n\t\t\tbreak;\n\n\t*fres = fin / mxc_clkdivs[i];\n\treturn i;\n}\n\n \nstatic unsigned int spi_imx_clkdiv_2(unsigned int fin,\n\t\tunsigned int fspi, unsigned int *fres)\n{\n\tint i, div = 4;\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (fspi * div >= fin)\n\t\t\tgoto out;\n\t\tdiv <<= 1;\n\t}\n\nout:\n\t*fres = fin / div;\n\treturn i;\n}\n\nstatic int spi_imx_bytes_per_word(const int bits_per_word)\n{\n\tif (bits_per_word <= 8)\n\t\treturn 1;\n\telse if (bits_per_word <= 16)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}\n\nstatic bool spi_imx_can_dma(struct spi_controller *controller, struct spi_device *spi,\n\t\t\t struct spi_transfer *transfer)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\n\tif (!use_dma || controller->fallback)\n\t\treturn false;\n\n\tif (!controller->dma_rx)\n\t\treturn false;\n\n\tif (spi_imx->target_mode)\n\t\treturn false;\n\n\tif (transfer->len < spi_imx->devtype_data->fifo_size)\n\t\treturn false;\n\n\tspi_imx->dynamic_burst = 0;\n\n\treturn true;\n}\n\n \n\n#define MX51_ECSPI_CTRL\t\t0x08\n#define MX51_ECSPI_CTRL_ENABLE\t\t(1 <<  0)\n#define MX51_ECSPI_CTRL_XCH\t\t(1 <<  2)\n#define MX51_ECSPI_CTRL_SMC\t\t(1 << 3)\n#define MX51_ECSPI_CTRL_MODE_MASK\t(0xf << 4)\n#define MX51_ECSPI_CTRL_DRCTL(drctl)\t((drctl) << 16)\n#define MX51_ECSPI_CTRL_POSTDIV_OFFSET\t8\n#define MX51_ECSPI_CTRL_PREDIV_OFFSET\t12\n#define MX51_ECSPI_CTRL_CS(cs)\t\t((cs & 3) << 18)\n#define MX51_ECSPI_CTRL_BL_OFFSET\t20\n#define MX51_ECSPI_CTRL_BL_MASK\t\t(0xfff << 20)\n\n#define MX51_ECSPI_CONFIG\t0x0c\n#define MX51_ECSPI_CONFIG_SCLKPHA(cs)\t(1 << ((cs & 3) +  0))\n#define MX51_ECSPI_CONFIG_SCLKPOL(cs)\t(1 << ((cs & 3) +  4))\n#define MX51_ECSPI_CONFIG_SBBCTRL(cs)\t(1 << ((cs & 3) +  8))\n#define MX51_ECSPI_CONFIG_SSBPOL(cs)\t(1 << ((cs & 3) + 12))\n#define MX51_ECSPI_CONFIG_DATACTL(cs)\t(1 << ((cs & 3) + 16))\n#define MX51_ECSPI_CONFIG_SCLKCTL(cs)\t(1 << ((cs & 3) + 20))\n\n#define MX51_ECSPI_INT\t\t0x10\n#define MX51_ECSPI_INT_TEEN\t\t(1 <<  0)\n#define MX51_ECSPI_INT_RREN\t\t(1 <<  3)\n#define MX51_ECSPI_INT_RDREN\t\t(1 <<  4)\n\n#define MX51_ECSPI_DMA\t\t0x14\n#define MX51_ECSPI_DMA_TX_WML(wml)\t((wml) & 0x3f)\n#define MX51_ECSPI_DMA_RX_WML(wml)\t(((wml) & 0x3f) << 16)\n#define MX51_ECSPI_DMA_RXT_WML(wml)\t(((wml) & 0x3f) << 24)\n\n#define MX51_ECSPI_DMA_TEDEN\t\t(1 << 7)\n#define MX51_ECSPI_DMA_RXDEN\t\t(1 << 23)\n#define MX51_ECSPI_DMA_RXTDEN\t\t(1 << 31)\n\n#define MX51_ECSPI_STAT\t\t0x18\n#define MX51_ECSPI_STAT_RR\t\t(1 <<  3)\n\n#define MX51_ECSPI_TESTREG\t0x20\n#define MX51_ECSPI_TESTREG_LBC\tBIT(31)\n\nstatic void spi_imx_buf_rx_swap_u32(struct spi_imx_data *spi_imx)\n{\n\tunsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);\n\n\tif (spi_imx->rx_buf) {\n#ifdef __LITTLE_ENDIAN\n\t\tunsigned int bytes_per_word;\n\n\t\tbytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);\n\t\tif (bytes_per_word == 1)\n\t\t\tswab32s(&val);\n\t\telse if (bytes_per_word == 2)\n\t\t\tswahw32s(&val);\n#endif\n\t\t*(u32 *)spi_imx->rx_buf = val;\n\t\tspi_imx->rx_buf += sizeof(u32);\n\t}\n\n\tspi_imx->remainder -= sizeof(u32);\n}\n\nstatic void spi_imx_buf_rx_swap(struct spi_imx_data *spi_imx)\n{\n\tint unaligned;\n\tu32 val;\n\n\tunaligned = spi_imx->remainder % 4;\n\n\tif (!unaligned) {\n\t\tspi_imx_buf_rx_swap_u32(spi_imx);\n\t\treturn;\n\t}\n\n\tif (spi_imx_bytes_per_word(spi_imx->bits_per_word) == 2) {\n\t\tspi_imx_buf_rx_u16(spi_imx);\n\t\treturn;\n\t}\n\n\tval = readl(spi_imx->base + MXC_CSPIRXDATA);\n\n\twhile (unaligned--) {\n\t\tif (spi_imx->rx_buf) {\n\t\t\t*(u8 *)spi_imx->rx_buf = (val >> (8 * unaligned)) & 0xff;\n\t\t\tspi_imx->rx_buf++;\n\t\t}\n\t\tspi_imx->remainder--;\n\t}\n}\n\nstatic void spi_imx_buf_tx_swap_u32(struct spi_imx_data *spi_imx)\n{\n\tu32 val = 0;\n#ifdef __LITTLE_ENDIAN\n\tunsigned int bytes_per_word;\n#endif\n\n\tif (spi_imx->tx_buf) {\n\t\tval = *(u32 *)spi_imx->tx_buf;\n\t\tspi_imx->tx_buf += sizeof(u32);\n\t}\n\n\tspi_imx->count -= sizeof(u32);\n#ifdef __LITTLE_ENDIAN\n\tbytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);\n\n\tif (bytes_per_word == 1)\n\t\tswab32s(&val);\n\telse if (bytes_per_word == 2)\n\t\tswahw32s(&val);\n#endif\n\twritel(val, spi_imx->base + MXC_CSPITXDATA);\n}\n\nstatic void spi_imx_buf_tx_swap(struct spi_imx_data *spi_imx)\n{\n\tint unaligned;\n\tu32 val = 0;\n\n\tunaligned = spi_imx->count % 4;\n\n\tif (!unaligned) {\n\t\tspi_imx_buf_tx_swap_u32(spi_imx);\n\t\treturn;\n\t}\n\n\tif (spi_imx_bytes_per_word(spi_imx->bits_per_word) == 2) {\n\t\tspi_imx_buf_tx_u16(spi_imx);\n\t\treturn;\n\t}\n\n\twhile (unaligned--) {\n\t\tif (spi_imx->tx_buf) {\n\t\t\tval |= *(u8 *)spi_imx->tx_buf << (8 * unaligned);\n\t\t\tspi_imx->tx_buf++;\n\t\t}\n\t\tspi_imx->count--;\n\t}\n\n\twritel(val, spi_imx->base + MXC_CSPITXDATA);\n}\n\nstatic void mx53_ecspi_rx_target(struct spi_imx_data *spi_imx)\n{\n\tu32 val = be32_to_cpu(readl(spi_imx->base + MXC_CSPIRXDATA));\n\n\tif (spi_imx->rx_buf) {\n\t\tint n_bytes = spi_imx->target_burst % sizeof(val);\n\n\t\tif (!n_bytes)\n\t\t\tn_bytes = sizeof(val);\n\n\t\tmemcpy(spi_imx->rx_buf,\n\t\t       ((u8 *)&val) + sizeof(val) - n_bytes, n_bytes);\n\n\t\tspi_imx->rx_buf += n_bytes;\n\t\tspi_imx->target_burst -= n_bytes;\n\t}\n\n\tspi_imx->remainder -= sizeof(u32);\n}\n\nstatic void mx53_ecspi_tx_target(struct spi_imx_data *spi_imx)\n{\n\tu32 val = 0;\n\tint n_bytes = spi_imx->count % sizeof(val);\n\n\tif (!n_bytes)\n\t\tn_bytes = sizeof(val);\n\n\tif (spi_imx->tx_buf) {\n\t\tmemcpy(((u8 *)&val) + sizeof(val) - n_bytes,\n\t\t       spi_imx->tx_buf, n_bytes);\n\t\tval = cpu_to_be32(val);\n\t\tspi_imx->tx_buf += n_bytes;\n\t}\n\n\tspi_imx->count -= n_bytes;\n\n\twritel(val, spi_imx->base + MXC_CSPITXDATA);\n}\n\n \nstatic unsigned int mx51_ecspi_clkdiv(struct spi_imx_data *spi_imx,\n\t\t\t\t      unsigned int fspi, unsigned int *fres)\n{\n\t \n\tunsigned int pre, post;\n\tunsigned int fin = spi_imx->spi_clk;\n\n\tfspi = min(fspi, fin);\n\n\tpost = fls(fin) - fls(fspi);\n\tif (fin > fspi << post)\n\t\tpost++;\n\n\t \n\n\tpost = max(4U, post) - 4;\n\tif (unlikely(post > 0xf)) {\n\t\tdev_err(spi_imx->dev, \"cannot set clock freq: %u (base freq: %u)\\n\",\n\t\t\t\tfspi, fin);\n\t\treturn 0xff;\n\t}\n\n\tpre = DIV_ROUND_UP(fin, fspi << post) - 1;\n\n\tdev_dbg(spi_imx->dev, \"%s: fin: %u, fspi: %u, post: %u, pre: %u\\n\",\n\t\t\t__func__, fin, fspi, post, pre);\n\n\t \n\t*fres = (fin / (pre + 1)) >> post;\n\n\treturn (pre << MX51_ECSPI_CTRL_PREDIV_OFFSET) |\n\t\t(post << MX51_ECSPI_CTRL_POSTDIV_OFFSET);\n}\n\nstatic void mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)\n{\n\tunsigned int val = 0;\n\n\tif (enable & MXC_INT_TE)\n\t\tval |= MX51_ECSPI_INT_TEEN;\n\n\tif (enable & MXC_INT_RR)\n\t\tval |= MX51_ECSPI_INT_RREN;\n\n\tif (enable & MXC_INT_RDR)\n\t\tval |= MX51_ECSPI_INT_RDREN;\n\n\twritel(val, spi_imx->base + MX51_ECSPI_INT);\n}\n\nstatic void mx51_ecspi_trigger(struct spi_imx_data *spi_imx)\n{\n\tu32 reg;\n\n\treg = readl(spi_imx->base + MX51_ECSPI_CTRL);\n\treg |= MX51_ECSPI_CTRL_XCH;\n\twritel(reg, spi_imx->base + MX51_ECSPI_CTRL);\n}\n\nstatic void mx51_ecspi_disable(struct spi_imx_data *spi_imx)\n{\n\tu32 ctrl;\n\n\tctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);\n\tctrl &= ~MX51_ECSPI_CTRL_ENABLE;\n\twritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\n}\n\nstatic int mx51_ecspi_channel(const struct spi_device *spi)\n{\n\tif (!spi_get_csgpiod(spi, 0))\n\t\treturn spi_get_chipselect(spi, 0);\n\treturn spi->controller->unused_native_cs;\n}\n\nstatic int mx51_ecspi_prepare_message(struct spi_imx_data *spi_imx,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct spi_transfer *xfer;\n\tu32 ctrl = MX51_ECSPI_CTRL_ENABLE;\n\tu32 min_speed_hz = ~0U;\n\tu32 testreg, delay;\n\tu32 cfg = readl(spi_imx->base + MX51_ECSPI_CONFIG);\n\tu32 current_cfg = cfg;\n\tint channel = mx51_ecspi_channel(spi);\n\n\t \n\tif (spi_imx->target_mode)\n\t\tctrl &= ~MX51_ECSPI_CTRL_MODE_MASK;\n\telse\n\t\tctrl |= MX51_ECSPI_CTRL_MODE_MASK;\n\n\t \n\tif (spi->mode & SPI_READY)\n\t\tctrl |= MX51_ECSPI_CTRL_DRCTL(spi_imx->spi_drctl);\n\n\t \n\tctrl |= MX51_ECSPI_CTRL_CS(channel);\n\n\t \n\twritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\n\n\ttestreg = readl(spi_imx->base + MX51_ECSPI_TESTREG);\n\tif (spi->mode & SPI_LOOP)\n\t\ttestreg |= MX51_ECSPI_TESTREG_LBC;\n\telse\n\t\ttestreg &= ~MX51_ECSPI_TESTREG_LBC;\n\twritel(testreg, spi_imx->base + MX51_ECSPI_TESTREG);\n\n\t \n\tif (spi_imx->target_mode && is_imx53_ecspi(spi_imx))\n\t\tcfg &= ~MX51_ECSPI_CONFIG_SBBCTRL(channel);\n\telse\n\t\tcfg |= MX51_ECSPI_CONFIG_SBBCTRL(channel);\n\n\tif (spi->mode & SPI_CPOL) {\n\t\tcfg |= MX51_ECSPI_CONFIG_SCLKPOL(channel);\n\t\tcfg |= MX51_ECSPI_CONFIG_SCLKCTL(channel);\n\t} else {\n\t\tcfg &= ~MX51_ECSPI_CONFIG_SCLKPOL(channel);\n\t\tcfg &= ~MX51_ECSPI_CONFIG_SCLKCTL(channel);\n\t}\n\n\tif (spi->mode & SPI_MOSI_IDLE_LOW)\n\t\tcfg |= MX51_ECSPI_CONFIG_DATACTL(channel);\n\telse\n\t\tcfg &= ~MX51_ECSPI_CONFIG_DATACTL(channel);\n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tcfg |= MX51_ECSPI_CONFIG_SSBPOL(channel);\n\telse\n\t\tcfg &= ~MX51_ECSPI_CONFIG_SSBPOL(channel);\n\n\tif (cfg == current_cfg)\n\t\treturn 0;\n\n\twritel(cfg, spi_imx->base + MX51_ECSPI_CONFIG);\n\n\t \n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tif (!xfer->speed_hz)\n\t\t\tcontinue;\n\t\tmin_speed_hz = min(xfer->speed_hz, min_speed_hz);\n\t}\n\n\tdelay = (2 * 1000000) / min_speed_hz;\n\tif (likely(delay < 10))\t \n\t\tudelay(delay);\n\telse\t\t\t \n\t\tusleep_range(delay, delay + 10);\n\n\treturn 0;\n}\n\nstatic void mx51_configure_cpha(struct spi_imx_data *spi_imx,\n\t\t\t\tstruct spi_device *spi)\n{\n\tbool cpha = (spi->mode & SPI_CPHA);\n\tbool flip_cpha = (spi->mode & SPI_RX_CPHA_FLIP) && spi_imx->rx_only;\n\tu32 cfg = readl(spi_imx->base + MX51_ECSPI_CONFIG);\n\tint channel = mx51_ecspi_channel(spi);\n\n\t \n\tcpha ^= flip_cpha;\n\n\tif (cpha)\n\t\tcfg |= MX51_ECSPI_CONFIG_SCLKPHA(channel);\n\telse\n\t\tcfg &= ~MX51_ECSPI_CONFIG_SCLKPHA(channel);\n\n\twritel(cfg, spi_imx->base + MX51_ECSPI_CONFIG);\n}\n\nstatic int mx51_ecspi_prepare_transfer(struct spi_imx_data *spi_imx,\n\t\t\t\t       struct spi_device *spi)\n{\n\tu32 ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);\n\tu32 clk;\n\n\t \n\tctrl &= ~MX51_ECSPI_CTRL_BL_MASK;\n\tif (spi_imx->target_mode && is_imx53_ecspi(spi_imx))\n\t\tctrl |= (spi_imx->target_burst * 8 - 1)\n\t\t\t<< MX51_ECSPI_CTRL_BL_OFFSET;\n\telse {\n\t\tif (spi_imx->usedma) {\n\t\t\tctrl |= (spi_imx->bits_per_word *\n\t\t\t\tspi_imx_bytes_per_word(spi_imx->bits_per_word) - 1)\n\t\t\t\t<< MX51_ECSPI_CTRL_BL_OFFSET;\n\t\t} else {\n\t\t\tif (spi_imx->count >= MX51_ECSPI_CTRL_MAX_BURST)\n\t\t\t\tctrl |= (MX51_ECSPI_CTRL_MAX_BURST - 1)\n\t\t\t\t\t\t<< MX51_ECSPI_CTRL_BL_OFFSET;\n\t\t\telse\n\t\t\t\tctrl |= (spi_imx->count * spi_imx->bits_per_word - 1)\n\t\t\t\t\t\t<< MX51_ECSPI_CTRL_BL_OFFSET;\n\t\t}\n\t}\n\n\t \n\tctrl &= ~(0xf << MX51_ECSPI_CTRL_POSTDIV_OFFSET |\n\t\t  0xf << MX51_ECSPI_CTRL_PREDIV_OFFSET);\n\tctrl |= mx51_ecspi_clkdiv(spi_imx, spi_imx->spi_bus_clk, &clk);\n\tspi_imx->spi_bus_clk = clk;\n\n\tmx51_configure_cpha(spi_imx, spi);\n\n\t \n\tif (spi_imx->usedma && spi_imx->devtype_data->tx_glitch_fixed)\n\t\tctrl |= MX51_ECSPI_CTRL_SMC;\n\telse\n\t\tctrl &= ~MX51_ECSPI_CTRL_SMC;\n\n\twritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\n\n\treturn 0;\n}\n\nstatic void mx51_setup_wml(struct spi_imx_data *spi_imx)\n{\n\tu32 tx_wml = 0;\n\n\tif (spi_imx->devtype_data->tx_glitch_fixed)\n\t\ttx_wml = spi_imx->wml;\n\t \n\twritel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml - 1) |\n\t\tMX51_ECSPI_DMA_TX_WML(tx_wml) |\n\t\tMX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |\n\t\tMX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |\n\t\tMX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);\n}\n\nstatic int mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)\n{\n\treturn readl(spi_imx->base + MX51_ECSPI_STAT) & MX51_ECSPI_STAT_RR;\n}\n\nstatic void mx51_ecspi_reset(struct spi_imx_data *spi_imx)\n{\n\t \n\twhile (mx51_ecspi_rx_available(spi_imx))\n\t\treadl(spi_imx->base + MXC_CSPIRXDATA);\n}\n\n#define MX31_INTREG_TEEN\t(1 << 0)\n#define MX31_INTREG_RREN\t(1 << 3)\n\n#define MX31_CSPICTRL_ENABLE\t(1 << 0)\n#define MX31_CSPICTRL_HOST\t(1 << 1)\n#define MX31_CSPICTRL_XCH\t(1 << 2)\n#define MX31_CSPICTRL_SMC\t(1 << 3)\n#define MX31_CSPICTRL_POL\t(1 << 4)\n#define MX31_CSPICTRL_PHA\t(1 << 5)\n#define MX31_CSPICTRL_SSCTL\t(1 << 6)\n#define MX31_CSPICTRL_SSPOL\t(1 << 7)\n#define MX31_CSPICTRL_BC_SHIFT\t8\n#define MX35_CSPICTRL_BL_SHIFT\t20\n#define MX31_CSPICTRL_CS_SHIFT\t24\n#define MX35_CSPICTRL_CS_SHIFT\t12\n#define MX31_CSPICTRL_DR_SHIFT\t16\n\n#define MX31_CSPI_DMAREG\t0x10\n#define MX31_DMAREG_RH_DEN\t(1<<4)\n#define MX31_DMAREG_TH_DEN\t(1<<1)\n\n#define MX31_CSPISTATUS\t\t0x14\n#define MX31_STATUS_RR\t\t(1 << 3)\n\n#define MX31_CSPI_TESTREG\t0x1C\n#define MX31_TEST_LBC\t\t(1 << 14)\n\n \nstatic void mx31_intctrl(struct spi_imx_data *spi_imx, int enable)\n{\n\tunsigned int val = 0;\n\n\tif (enable & MXC_INT_TE)\n\t\tval |= MX31_INTREG_TEEN;\n\tif (enable & MXC_INT_RR)\n\t\tval |= MX31_INTREG_RREN;\n\n\twritel(val, spi_imx->base + MXC_CSPIINT);\n}\n\nstatic void mx31_trigger(struct spi_imx_data *spi_imx)\n{\n\tunsigned int reg;\n\n\treg = readl(spi_imx->base + MXC_CSPICTRL);\n\treg |= MX31_CSPICTRL_XCH;\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n}\n\nstatic int mx31_prepare_message(struct spi_imx_data *spi_imx,\n\t\t\t\tstruct spi_message *msg)\n{\n\treturn 0;\n}\n\nstatic int mx31_prepare_transfer(struct spi_imx_data *spi_imx,\n\t\t\t\t struct spi_device *spi)\n{\n\tunsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_HOST;\n\tunsigned int clk;\n\n\treg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<\n\t\tMX31_CSPICTRL_DR_SHIFT;\n\tspi_imx->spi_bus_clk = clk;\n\n\tif (is_imx35_cspi(spi_imx)) {\n\t\treg |= (spi_imx->bits_per_word - 1) << MX35_CSPICTRL_BL_SHIFT;\n\t\treg |= MX31_CSPICTRL_SSCTL;\n\t} else {\n\t\treg |= (spi_imx->bits_per_word - 1) << MX31_CSPICTRL_BC_SHIFT;\n\t}\n\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= MX31_CSPICTRL_PHA;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= MX31_CSPICTRL_POL;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\treg |= MX31_CSPICTRL_SSPOL;\n\tif (!spi_get_csgpiod(spi, 0))\n\t\treg |= (spi_get_chipselect(spi, 0)) <<\n\t\t\t(is_imx35_cspi(spi_imx) ? MX35_CSPICTRL_CS_SHIFT :\n\t\t\t\t\t\t  MX31_CSPICTRL_CS_SHIFT);\n\n\tif (spi_imx->usedma)\n\t\treg |= MX31_CSPICTRL_SMC;\n\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n\n\treg = readl(spi_imx->base + MX31_CSPI_TESTREG);\n\tif (spi->mode & SPI_LOOP)\n\t\treg |= MX31_TEST_LBC;\n\telse\n\t\treg &= ~MX31_TEST_LBC;\n\twritel(reg, spi_imx->base + MX31_CSPI_TESTREG);\n\n\tif (spi_imx->usedma) {\n\t\t \n\t\twritel(MX31_DMAREG_RH_DEN | MX31_DMAREG_TH_DEN,\n\t\t\tspi_imx->base + MX31_CSPI_DMAREG);\n\t}\n\n\treturn 0;\n}\n\nstatic int mx31_rx_available(struct spi_imx_data *spi_imx)\n{\n\treturn readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR;\n}\n\nstatic void mx31_reset(struct spi_imx_data *spi_imx)\n{\n\t \n\twhile (readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR)\n\t\treadl(spi_imx->base + MXC_CSPIRXDATA);\n}\n\n#define MX21_INTREG_RR\t\t(1 << 4)\n#define MX21_INTREG_TEEN\t(1 << 9)\n#define MX21_INTREG_RREN\t(1 << 13)\n\n#define MX21_CSPICTRL_POL\t(1 << 5)\n#define MX21_CSPICTRL_PHA\t(1 << 6)\n#define MX21_CSPICTRL_SSPOL\t(1 << 8)\n#define MX21_CSPICTRL_XCH\t(1 << 9)\n#define MX21_CSPICTRL_ENABLE\t(1 << 10)\n#define MX21_CSPICTRL_HOST\t(1 << 11)\n#define MX21_CSPICTRL_DR_SHIFT\t14\n#define MX21_CSPICTRL_CS_SHIFT\t19\n\nstatic void mx21_intctrl(struct spi_imx_data *spi_imx, int enable)\n{\n\tunsigned int val = 0;\n\n\tif (enable & MXC_INT_TE)\n\t\tval |= MX21_INTREG_TEEN;\n\tif (enable & MXC_INT_RR)\n\t\tval |= MX21_INTREG_RREN;\n\n\twritel(val, spi_imx->base + MXC_CSPIINT);\n}\n\nstatic void mx21_trigger(struct spi_imx_data *spi_imx)\n{\n\tunsigned int reg;\n\n\treg = readl(spi_imx->base + MXC_CSPICTRL);\n\treg |= MX21_CSPICTRL_XCH;\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n}\n\nstatic int mx21_prepare_message(struct spi_imx_data *spi_imx,\n\t\t\t\tstruct spi_message *msg)\n{\n\treturn 0;\n}\n\nstatic int mx21_prepare_transfer(struct spi_imx_data *spi_imx,\n\t\t\t\t struct spi_device *spi)\n{\n\tunsigned int reg = MX21_CSPICTRL_ENABLE | MX21_CSPICTRL_HOST;\n\tunsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;\n\tunsigned int clk;\n\n\treg |= spi_imx_clkdiv_1(spi_imx->spi_clk, spi_imx->spi_bus_clk, max, &clk)\n\t\t<< MX21_CSPICTRL_DR_SHIFT;\n\tspi_imx->spi_bus_clk = clk;\n\n\treg |= spi_imx->bits_per_word - 1;\n\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= MX21_CSPICTRL_PHA;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= MX21_CSPICTRL_POL;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\treg |= MX21_CSPICTRL_SSPOL;\n\tif (!spi_get_csgpiod(spi, 0))\n\t\treg |= spi_get_chipselect(spi, 0) << MX21_CSPICTRL_CS_SHIFT;\n\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n\n\treturn 0;\n}\n\nstatic int mx21_rx_available(struct spi_imx_data *spi_imx)\n{\n\treturn readl(spi_imx->base + MXC_CSPIINT) & MX21_INTREG_RR;\n}\n\nstatic void mx21_reset(struct spi_imx_data *spi_imx)\n{\n\twritel(1, spi_imx->base + MXC_RESET);\n}\n\n#define MX1_INTREG_RR\t\t(1 << 3)\n#define MX1_INTREG_TEEN\t\t(1 << 8)\n#define MX1_INTREG_RREN\t\t(1 << 11)\n\n#define MX1_CSPICTRL_POL\t(1 << 4)\n#define MX1_CSPICTRL_PHA\t(1 << 5)\n#define MX1_CSPICTRL_XCH\t(1 << 8)\n#define MX1_CSPICTRL_ENABLE\t(1 << 9)\n#define MX1_CSPICTRL_HOST\t(1 << 10)\n#define MX1_CSPICTRL_DR_SHIFT\t13\n\nstatic void mx1_intctrl(struct spi_imx_data *spi_imx, int enable)\n{\n\tunsigned int val = 0;\n\n\tif (enable & MXC_INT_TE)\n\t\tval |= MX1_INTREG_TEEN;\n\tif (enable & MXC_INT_RR)\n\t\tval |= MX1_INTREG_RREN;\n\n\twritel(val, spi_imx->base + MXC_CSPIINT);\n}\n\nstatic void mx1_trigger(struct spi_imx_data *spi_imx)\n{\n\tunsigned int reg;\n\n\treg = readl(spi_imx->base + MXC_CSPICTRL);\n\treg |= MX1_CSPICTRL_XCH;\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n}\n\nstatic int mx1_prepare_message(struct spi_imx_data *spi_imx,\n\t\t\t       struct spi_message *msg)\n{\n\treturn 0;\n}\n\nstatic int mx1_prepare_transfer(struct spi_imx_data *spi_imx,\n\t\t\t\tstruct spi_device *spi)\n{\n\tunsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_HOST;\n\tunsigned int clk;\n\n\treg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<\n\t\tMX1_CSPICTRL_DR_SHIFT;\n\tspi_imx->spi_bus_clk = clk;\n\n\treg |= spi_imx->bits_per_word - 1;\n\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= MX1_CSPICTRL_PHA;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= MX1_CSPICTRL_POL;\n\n\twritel(reg, spi_imx->base + MXC_CSPICTRL);\n\n\treturn 0;\n}\n\nstatic int mx1_rx_available(struct spi_imx_data *spi_imx)\n{\n\treturn readl(spi_imx->base + MXC_CSPIINT) & MX1_INTREG_RR;\n}\n\nstatic void mx1_reset(struct spi_imx_data *spi_imx)\n{\n\twritel(1, spi_imx->base + MXC_RESET);\n}\n\nstatic struct spi_imx_devtype_data imx1_cspi_devtype_data = {\n\t.intctrl = mx1_intctrl,\n\t.prepare_message = mx1_prepare_message,\n\t.prepare_transfer = mx1_prepare_transfer,\n\t.trigger = mx1_trigger,\n\t.rx_available = mx1_rx_available,\n\t.reset = mx1_reset,\n\t.fifo_size = 8,\n\t.has_dmamode = false,\n\t.dynamic_burst = false,\n\t.has_targetmode = false,\n\t.devtype = IMX1_CSPI,\n};\n\nstatic struct spi_imx_devtype_data imx21_cspi_devtype_data = {\n\t.intctrl = mx21_intctrl,\n\t.prepare_message = mx21_prepare_message,\n\t.prepare_transfer = mx21_prepare_transfer,\n\t.trigger = mx21_trigger,\n\t.rx_available = mx21_rx_available,\n\t.reset = mx21_reset,\n\t.fifo_size = 8,\n\t.has_dmamode = false,\n\t.dynamic_burst = false,\n\t.has_targetmode = false,\n\t.devtype = IMX21_CSPI,\n};\n\nstatic struct spi_imx_devtype_data imx27_cspi_devtype_data = {\n\t \n\t.intctrl = mx21_intctrl,\n\t.prepare_message = mx21_prepare_message,\n\t.prepare_transfer = mx21_prepare_transfer,\n\t.trigger = mx21_trigger,\n\t.rx_available = mx21_rx_available,\n\t.reset = mx21_reset,\n\t.fifo_size = 8,\n\t.has_dmamode = false,\n\t.dynamic_burst = false,\n\t.has_targetmode = false,\n\t.devtype = IMX27_CSPI,\n};\n\nstatic struct spi_imx_devtype_data imx31_cspi_devtype_data = {\n\t.intctrl = mx31_intctrl,\n\t.prepare_message = mx31_prepare_message,\n\t.prepare_transfer = mx31_prepare_transfer,\n\t.trigger = mx31_trigger,\n\t.rx_available = mx31_rx_available,\n\t.reset = mx31_reset,\n\t.fifo_size = 8,\n\t.has_dmamode = false,\n\t.dynamic_burst = false,\n\t.has_targetmode = false,\n\t.devtype = IMX31_CSPI,\n};\n\nstatic struct spi_imx_devtype_data imx35_cspi_devtype_data = {\n\t \n\t.intctrl = mx31_intctrl,\n\t.prepare_message = mx31_prepare_message,\n\t.prepare_transfer = mx31_prepare_transfer,\n\t.trigger = mx31_trigger,\n\t.rx_available = mx31_rx_available,\n\t.reset = mx31_reset,\n\t.fifo_size = 8,\n\t.has_dmamode = true,\n\t.dynamic_burst = false,\n\t.has_targetmode = false,\n\t.devtype = IMX35_CSPI,\n};\n\nstatic struct spi_imx_devtype_data imx51_ecspi_devtype_data = {\n\t.intctrl = mx51_ecspi_intctrl,\n\t.prepare_message = mx51_ecspi_prepare_message,\n\t.prepare_transfer = mx51_ecspi_prepare_transfer,\n\t.trigger = mx51_ecspi_trigger,\n\t.rx_available = mx51_ecspi_rx_available,\n\t.reset = mx51_ecspi_reset,\n\t.setup_wml = mx51_setup_wml,\n\t.fifo_size = 64,\n\t.has_dmamode = true,\n\t.dynamic_burst = true,\n\t.has_targetmode = true,\n\t.disable = mx51_ecspi_disable,\n\t.devtype = IMX51_ECSPI,\n};\n\nstatic struct spi_imx_devtype_data imx53_ecspi_devtype_data = {\n\t.intctrl = mx51_ecspi_intctrl,\n\t.prepare_message = mx51_ecspi_prepare_message,\n\t.prepare_transfer = mx51_ecspi_prepare_transfer,\n\t.trigger = mx51_ecspi_trigger,\n\t.rx_available = mx51_ecspi_rx_available,\n\t.reset = mx51_ecspi_reset,\n\t.fifo_size = 64,\n\t.has_dmamode = true,\n\t.has_targetmode = true,\n\t.disable = mx51_ecspi_disable,\n\t.devtype = IMX53_ECSPI,\n};\n\nstatic struct spi_imx_devtype_data imx6ul_ecspi_devtype_data = {\n\t.intctrl = mx51_ecspi_intctrl,\n\t.prepare_message = mx51_ecspi_prepare_message,\n\t.prepare_transfer = mx51_ecspi_prepare_transfer,\n\t.trigger = mx51_ecspi_trigger,\n\t.rx_available = mx51_ecspi_rx_available,\n\t.reset = mx51_ecspi_reset,\n\t.setup_wml = mx51_setup_wml,\n\t.fifo_size = 64,\n\t.has_dmamode = true,\n\t.dynamic_burst = true,\n\t.has_targetmode = true,\n\t.tx_glitch_fixed = true,\n\t.disable = mx51_ecspi_disable,\n\t.devtype = IMX51_ECSPI,\n};\n\nstatic const struct of_device_id spi_imx_dt_ids[] = {\n\t{ .compatible = \"fsl,imx1-cspi\", .data = &imx1_cspi_devtype_data, },\n\t{ .compatible = \"fsl,imx21-cspi\", .data = &imx21_cspi_devtype_data, },\n\t{ .compatible = \"fsl,imx27-cspi\", .data = &imx27_cspi_devtype_data, },\n\t{ .compatible = \"fsl,imx31-cspi\", .data = &imx31_cspi_devtype_data, },\n\t{ .compatible = \"fsl,imx35-cspi\", .data = &imx35_cspi_devtype_data, },\n\t{ .compatible = \"fsl,imx51-ecspi\", .data = &imx51_ecspi_devtype_data, },\n\t{ .compatible = \"fsl,imx53-ecspi\", .data = &imx53_ecspi_devtype_data, },\n\t{ .compatible = \"fsl,imx6ul-ecspi\", .data = &imx6ul_ecspi_devtype_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, spi_imx_dt_ids);\n\nstatic void spi_imx_set_burst_len(struct spi_imx_data *spi_imx, int n_bits)\n{\n\tu32 ctrl;\n\n\tctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);\n\tctrl &= ~MX51_ECSPI_CTRL_BL_MASK;\n\tctrl |= ((n_bits - 1) << MX51_ECSPI_CTRL_BL_OFFSET);\n\twritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\n}\n\nstatic void spi_imx_push(struct spi_imx_data *spi_imx)\n{\n\tunsigned int burst_len;\n\n\t \n\tif (!spi_imx->remainder) {\n\t\tif (spi_imx->dynamic_burst) {\n\n\t\t\t \n\t\t\tburst_len = spi_imx->count % MX51_ECSPI_CTRL_MAX_BURST;\n\n\t\t\tif (!burst_len)\n\t\t\t\tburst_len = MX51_ECSPI_CTRL_MAX_BURST;\n\n\t\t\tspi_imx_set_burst_len(spi_imx, burst_len * 8);\n\n\t\t\tspi_imx->remainder = burst_len;\n\t\t} else {\n\t\t\tspi_imx->remainder = spi_imx_bytes_per_word(spi_imx->bits_per_word);\n\t\t}\n\t}\n\n\twhile (spi_imx->txfifo < spi_imx->devtype_data->fifo_size) {\n\t\tif (!spi_imx->count)\n\t\t\tbreak;\n\t\tif (spi_imx->dynamic_burst &&\n\t\t    spi_imx->txfifo >= DIV_ROUND_UP(spi_imx->remainder, 4))\n\t\t\tbreak;\n\t\tspi_imx->tx(spi_imx);\n\t\tspi_imx->txfifo++;\n\t}\n\n\tif (!spi_imx->target_mode)\n\t\tspi_imx->devtype_data->trigger(spi_imx);\n}\n\nstatic irqreturn_t spi_imx_isr(int irq, void *dev_id)\n{\n\tstruct spi_imx_data *spi_imx = dev_id;\n\n\twhile (spi_imx->txfifo &&\n\t       spi_imx->devtype_data->rx_available(spi_imx)) {\n\t\tspi_imx->rx(spi_imx);\n\t\tspi_imx->txfifo--;\n\t}\n\n\tif (spi_imx->count) {\n\t\tspi_imx_push(spi_imx);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (spi_imx->txfifo) {\n\t\t \n\t\tspi_imx->devtype_data->intctrl(\n\t\t\t\tspi_imx, MXC_INT_RR);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspi_imx->devtype_data->intctrl(spi_imx, 0);\n\tcomplete(&spi_imx->xfer_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spi_imx_dma_configure(struct spi_controller *controller)\n{\n\tint ret;\n\tenum dma_slave_buswidth buswidth;\n\tstruct dma_slave_config rx = {}, tx = {};\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\n\tswitch (spi_imx_bytes_per_word(spi_imx->bits_per_word)) {\n\tcase 4:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tcase 2:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 1:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttx.direction = DMA_MEM_TO_DEV;\n\ttx.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;\n\ttx.dst_addr_width = buswidth;\n\ttx.dst_maxburst = spi_imx->wml;\n\tret = dmaengine_slave_config(controller->dma_tx, &tx);\n\tif (ret) {\n\t\tdev_err(spi_imx->dev, \"TX dma configuration failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trx.direction = DMA_DEV_TO_MEM;\n\trx.src_addr = spi_imx->base_phys + MXC_CSPIRXDATA;\n\trx.src_addr_width = buswidth;\n\trx.src_maxburst = spi_imx->wml;\n\tret = dmaengine_slave_config(controller->dma_rx, &rx);\n\tif (ret) {\n\t\tdev_err(spi_imx->dev, \"RX dma configuration failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_imx_setupxfer(struct spi_device *spi,\n\t\t\t\t struct spi_transfer *t)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(spi->controller);\n\n\tif (!t)\n\t\treturn 0;\n\n\tif (!t->speed_hz) {\n\t\tif (!spi->max_speed_hz) {\n\t\t\tdev_err(&spi->dev, \"no speed_hz provided!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_dbg(&spi->dev, \"using spi->max_speed_hz!\\n\");\n\t\tspi_imx->spi_bus_clk = spi->max_speed_hz;\n\t} else\n\t\tspi_imx->spi_bus_clk = t->speed_hz;\n\n\tspi_imx->bits_per_word = t->bits_per_word;\n\tspi_imx->count = t->len;\n\n\t \n\tif (spi_imx->devtype_data->dynamic_burst && !spi_imx->target_mode &&\n\t    !(spi->mode & SPI_CS_WORD) &&\n\t    (spi_imx->bits_per_word == 8 ||\n\t    spi_imx->bits_per_word == 16 ||\n\t    spi_imx->bits_per_word == 32)) {\n\n\t\tspi_imx->rx = spi_imx_buf_rx_swap;\n\t\tspi_imx->tx = spi_imx_buf_tx_swap;\n\t\tspi_imx->dynamic_burst = 1;\n\n\t} else {\n\t\tif (spi_imx->bits_per_word <= 8) {\n\t\t\tspi_imx->rx = spi_imx_buf_rx_u8;\n\t\t\tspi_imx->tx = spi_imx_buf_tx_u8;\n\t\t} else if (spi_imx->bits_per_word <= 16) {\n\t\t\tspi_imx->rx = spi_imx_buf_rx_u16;\n\t\t\tspi_imx->tx = spi_imx_buf_tx_u16;\n\t\t} else {\n\t\t\tspi_imx->rx = spi_imx_buf_rx_u32;\n\t\t\tspi_imx->tx = spi_imx_buf_tx_u32;\n\t\t}\n\t\tspi_imx->dynamic_burst = 0;\n\t}\n\n\tif (spi_imx_can_dma(spi_imx->controller, spi, t))\n\t\tspi_imx->usedma = true;\n\telse\n\t\tspi_imx->usedma = false;\n\n\tspi_imx->rx_only = ((t->tx_buf == NULL)\n\t\t\t|| (t->tx_buf == spi->controller->dummy_tx));\n\n\tif (is_imx53_ecspi(spi_imx) && spi_imx->target_mode) {\n\t\tspi_imx->rx = mx53_ecspi_rx_target;\n\t\tspi_imx->tx = mx53_ecspi_tx_target;\n\t\tspi_imx->target_burst = t->len;\n\t}\n\n\tspi_imx->devtype_data->prepare_transfer(spi_imx, spi);\n\n\treturn 0;\n}\n\nstatic void spi_imx_sdma_exit(struct spi_imx_data *spi_imx)\n{\n\tstruct spi_controller *controller = spi_imx->controller;\n\n\tif (controller->dma_rx) {\n\t\tdma_release_channel(controller->dma_rx);\n\t\tcontroller->dma_rx = NULL;\n\t}\n\n\tif (controller->dma_tx) {\n\t\tdma_release_channel(controller->dma_tx);\n\t\tcontroller->dma_tx = NULL;\n\t}\n}\n\nstatic int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,\n\t\t\t     struct spi_controller *controller)\n{\n\tint ret;\n\n\tspi_imx->wml = spi_imx->devtype_data->fifo_size / 2;\n\n\t \n\tcontroller->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(controller->dma_tx)) {\n\t\tret = PTR_ERR(controller->dma_tx);\n\t\tdev_dbg(dev, \"can't get the TX DMA channel, error %d!\\n\", ret);\n\t\tcontroller->dma_tx = NULL;\n\t\tgoto err;\n\t}\n\n\t \n\tcontroller->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(controller->dma_rx)) {\n\t\tret = PTR_ERR(controller->dma_rx);\n\t\tdev_dbg(dev, \"can't get the RX DMA channel, error %d\\n\", ret);\n\t\tcontroller->dma_rx = NULL;\n\t\tgoto err;\n\t}\n\n\tinit_completion(&spi_imx->dma_rx_completion);\n\tinit_completion(&spi_imx->dma_tx_completion);\n\tcontroller->can_dma = spi_imx_can_dma;\n\tcontroller->max_dma_len = MAX_SDMA_BD_BYTES;\n\tspi_imx->controller->flags = SPI_CONTROLLER_MUST_RX |\n\t\t\t\t\t SPI_CONTROLLER_MUST_TX;\n\n\treturn 0;\nerr:\n\tspi_imx_sdma_exit(spi_imx);\n\treturn ret;\n}\n\nstatic void spi_imx_dma_rx_callback(void *cookie)\n{\n\tstruct spi_imx_data *spi_imx = (struct spi_imx_data *)cookie;\n\n\tcomplete(&spi_imx->dma_rx_completion);\n}\n\nstatic void spi_imx_dma_tx_callback(void *cookie)\n{\n\tstruct spi_imx_data *spi_imx = (struct spi_imx_data *)cookie;\n\n\tcomplete(&spi_imx->dma_tx_completion);\n}\n\nstatic int spi_imx_calculate_timeout(struct spi_imx_data *spi_imx, int size)\n{\n\tunsigned long timeout = 0;\n\n\t \n\ttimeout = (8 + 4) * size / spi_imx->spi_bus_clk;\n\n\t \n\ttimeout += 1;\n\n\t \n\treturn msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);\n}\n\nstatic int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct dma_async_tx_descriptor *desc_tx, *desc_rx;\n\tunsigned long transfer_timeout;\n\tunsigned long timeout;\n\tstruct spi_controller *controller = spi_imx->controller;\n\tstruct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;\n\tstruct scatterlist *last_sg = sg_last(rx->sgl, rx->nents);\n\tunsigned int bytes_per_word, i;\n\tint ret;\n\n\t \n\tbytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);\n\tfor (i = spi_imx->devtype_data->fifo_size / 2; i > 0; i--) {\n\t\tif (!(sg_dma_len(last_sg) % (i * bytes_per_word)))\n\t\t\tbreak;\n\t}\n\t \n\tif (i == 0)\n\t\ti = 1;\n\n\tspi_imx->wml =  i;\n\n\tret = spi_imx_dma_configure(controller);\n\tif (ret)\n\t\tgoto dma_failure_no_start;\n\n\tif (!spi_imx->devtype_data->setup_wml) {\n\t\tdev_err(spi_imx->dev, \"No setup_wml()?\\n\");\n\t\tret = -EINVAL;\n\t\tgoto dma_failure_no_start;\n\t}\n\tspi_imx->devtype_data->setup_wml(spi_imx);\n\n\t \n\tdesc_rx = dmaengine_prep_slave_sg(controller->dma_rx,\n\t\t\t\trx->sgl, rx->nents, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx) {\n\t\tret = -EINVAL;\n\t\tgoto dma_failure_no_start;\n\t}\n\n\tdesc_rx->callback = spi_imx_dma_rx_callback;\n\tdesc_rx->callback_param = (void *)spi_imx;\n\tdmaengine_submit(desc_rx);\n\treinit_completion(&spi_imx->dma_rx_completion);\n\tdma_async_issue_pending(controller->dma_rx);\n\n\tdesc_tx = dmaengine_prep_slave_sg(controller->dma_tx,\n\t\t\t\ttx->sgl, tx->nents, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_tx->callback = spi_imx_dma_tx_callback;\n\tdesc_tx->callback_param = (void *)spi_imx;\n\tdmaengine_submit(desc_tx);\n\treinit_completion(&spi_imx->dma_tx_completion);\n\tdma_async_issue_pending(controller->dma_tx);\n\n\ttransfer_timeout = spi_imx_calculate_timeout(spi_imx, transfer->len);\n\n\t \n\ttimeout = wait_for_completion_timeout(&spi_imx->dma_tx_completion,\n\t\t\t\t\t\ttransfer_timeout);\n\tif (!timeout) {\n\t\tdev_err(spi_imx->dev, \"I/O Error in DMA TX\\n\");\n\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\ttimeout = wait_for_completion_timeout(&spi_imx->dma_rx_completion,\n\t\t\t\t\t      transfer_timeout);\n\tif (!timeout) {\n\t\tdev_err(&controller->dev, \"I/O Error in DMA RX\\n\");\n\t\tspi_imx->devtype_data->reset(spi_imx);\n\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n \ndma_failure_no_start:\n\ttransfer->error |= SPI_TRANS_FAIL_NO_START;\n\treturn ret;\n}\n\nstatic int spi_imx_pio_transfer(struct spi_device *spi,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(spi->controller);\n\tunsigned long transfer_timeout;\n\tunsigned long timeout;\n\n\tspi_imx->tx_buf = transfer->tx_buf;\n\tspi_imx->rx_buf = transfer->rx_buf;\n\tspi_imx->count = transfer->len;\n\tspi_imx->txfifo = 0;\n\tspi_imx->remainder = 0;\n\n\treinit_completion(&spi_imx->xfer_done);\n\n\tspi_imx_push(spi_imx);\n\n\tspi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE);\n\n\ttransfer_timeout = spi_imx_calculate_timeout(spi_imx, transfer->len);\n\n\ttimeout = wait_for_completion_timeout(&spi_imx->xfer_done,\n\t\t\t\t\t      transfer_timeout);\n\tif (!timeout) {\n\t\tdev_err(&spi->dev, \"I/O Error in PIO\\n\");\n\t\tspi_imx->devtype_data->reset(spi_imx);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_imx_poll_transfer(struct spi_device *spi,\n\t\t\t\t struct spi_transfer *transfer)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(spi->controller);\n\tunsigned long timeout;\n\n\tspi_imx->tx_buf = transfer->tx_buf;\n\tspi_imx->rx_buf = transfer->rx_buf;\n\tspi_imx->count = transfer->len;\n\tspi_imx->txfifo = 0;\n\tspi_imx->remainder = 0;\n\n\t \n\tspi_imx_push(spi_imx);\n\n\ttimeout = spi_imx_calculate_timeout(spi_imx, transfer->len) + jiffies;\n\twhile (spi_imx->txfifo) {\n\t\t \n\t\twhile (spi_imx->txfifo &&\n\t\t       spi_imx->devtype_data->rx_available(spi_imx)) {\n\t\t\tspi_imx->rx(spi_imx);\n\t\t\tspi_imx->txfifo--;\n\t\t}\n\n\t\t \n\t\tif (spi_imx->count) {\n\t\t\tspi_imx_push(spi_imx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (spi_imx->txfifo &&\n\t\t    time_after(jiffies, timeout)) {\n\n\t\t\tdev_err_ratelimited(&spi->dev,\n\t\t\t\t\t    \"timeout period reached: jiffies: %lu- falling back to interrupt mode\\n\",\n\t\t\t\t\t    jiffies - timeout);\n\n\t\t\t \n\t\t\treturn spi_imx_pio_transfer(spi, transfer);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_imx_pio_transfer_target(struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *transfer)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(spi->controller);\n\tint ret = 0;\n\n\tif (is_imx53_ecspi(spi_imx) &&\n\t    transfer->len > MX53_MAX_TRANSFER_BYTES) {\n\t\tdev_err(&spi->dev, \"Transaction too big, max size is %d bytes\\n\",\n\t\t\tMX53_MAX_TRANSFER_BYTES);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tspi_imx->tx_buf = transfer->tx_buf;\n\tspi_imx->rx_buf = transfer->rx_buf;\n\tspi_imx->count = transfer->len;\n\tspi_imx->txfifo = 0;\n\tspi_imx->remainder = 0;\n\n\treinit_completion(&spi_imx->xfer_done);\n\tspi_imx->target_aborted = false;\n\n\tspi_imx_push(spi_imx);\n\n\tspi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE | MXC_INT_RDR);\n\n\tif (wait_for_completion_interruptible(&spi_imx->xfer_done) ||\n\t    spi_imx->target_aborted) {\n\t\tdev_dbg(&spi->dev, \"interrupted\\n\");\n\t\tret = -EINTR;\n\t}\n\n\t \n\tif (spi_imx->devtype_data->disable)\n\t\tspi_imx->devtype_data->disable(spi_imx);\n\n\treturn ret;\n}\n\nstatic int spi_imx_transfer_one(struct spi_controller *controller,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(spi->controller);\n\tunsigned long hz_per_byte, byte_limit;\n\n\tspi_imx_setupxfer(spi, transfer);\n\ttransfer->effective_speed_hz = spi_imx->spi_bus_clk;\n\n\t \n\twhile (spi_imx->devtype_data->rx_available(spi_imx))\n\t\treadl(spi_imx->base + MXC_CSPIRXDATA);\n\n\tif (spi_imx->target_mode)\n\t\treturn spi_imx_pio_transfer_target(spi, transfer);\n\n\t \n\tif (spi_imx->usedma)\n\t\treturn spi_imx_dma_transfer(spi_imx, transfer);\n\t \n\thz_per_byte = polling_limit_us ? ((8 + 4) * USEC_PER_SEC) / polling_limit_us : 0;\n\tbyte_limit = hz_per_byte ? transfer->effective_speed_hz / hz_per_byte : 1;\n\n\t \n\tif (transfer->len < byte_limit)\n\t\treturn spi_imx_poll_transfer(spi, transfer);\n\n\treturn spi_imx_pio_transfer(spi, transfer);\n}\n\nstatic int spi_imx_setup(struct spi_device *spi)\n{\n\tdev_dbg(&spi->dev, \"%s: mode %d, %u bpw, %d hz\\n\", __func__,\n\t\t spi->mode, spi->bits_per_word, spi->max_speed_hz);\n\n\treturn 0;\n}\n\nstatic void spi_imx_cleanup(struct spi_device *spi)\n{\n}\n\nstatic int\nspi_imx_prepare_message(struct spi_controller *controller, struct spi_message *msg)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(spi_imx->dev);\n\tif (ret < 0) {\n\t\tdev_err(spi_imx->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = spi_imx->devtype_data->prepare_message(spi_imx, msg);\n\tif (ret) {\n\t\tpm_runtime_mark_last_busy(spi_imx->dev);\n\t\tpm_runtime_put_autosuspend(spi_imx->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nspi_imx_unprepare_message(struct spi_controller *controller, struct spi_message *msg)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\n\tpm_runtime_mark_last_busy(spi_imx->dev);\n\tpm_runtime_put_autosuspend(spi_imx->dev);\n\treturn 0;\n}\n\nstatic int spi_imx_target_abort(struct spi_controller *controller)\n{\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\n\tspi_imx->target_aborted = true;\n\tcomplete(&spi_imx->xfer_done);\n\n\treturn 0;\n}\n\nstatic int spi_imx_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_data *spi_imx;\n\tstruct resource *res;\n\tint ret, irq, spi_drctl;\n\tconst struct spi_imx_devtype_data *devtype_data =\n\t\t\tof_device_get_match_data(&pdev->dev);\n\tbool target_mode;\n\tu32 val;\n\n\ttarget_mode = devtype_data->has_targetmode &&\n\t\t      of_property_read_bool(np, \"spi-slave\");\n\tif (target_mode)\n\t\tcontroller = spi_alloc_target(&pdev->dev,\n\t\t\t\t\t      sizeof(struct spi_imx_data));\n\telse\n\t\tcontroller = spi_alloc_host(&pdev->dev,\n\t\t\t\t\t    sizeof(struct spi_imx_data));\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"fsl,spi-rdy-drctl\", &spi_drctl);\n\tif ((ret < 0) || (spi_drctl >= 0x3)) {\n\t\t \n\t\tspi_drctl = 0;\n\t}\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\tcontroller->bus_num = np ? -1 : pdev->id;\n\tcontroller->use_gpio_descriptors = true;\n\n\tspi_imx = spi_controller_get_devdata(controller);\n\tspi_imx->controller = controller;\n\tspi_imx->dev = &pdev->dev;\n\tspi_imx->target_mode = target_mode;\n\n\tspi_imx->devtype_data = devtype_data;\n\n\t \n\tif (!device_property_read_u32(&pdev->dev, \"num-cs\", &val))\n\t\tcontroller->num_chipselect = val;\n\telse\n\t\tcontroller->num_chipselect = 3;\n\n\tcontroller->transfer_one = spi_imx_transfer_one;\n\tcontroller->setup = spi_imx_setup;\n\tcontroller->cleanup = spi_imx_cleanup;\n\tcontroller->prepare_message = spi_imx_prepare_message;\n\tcontroller->unprepare_message = spi_imx_unprepare_message;\n\tcontroller->target_abort = spi_imx_target_abort;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_NO_CS |\n\t\t\t\tSPI_MOSI_IDLE_LOW;\n\n\tif (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx) ||\n\t    is_imx53_ecspi(spi_imx))\n\t\tcontroller->mode_bits |= SPI_LOOP | SPI_READY;\n\n\tif (is_imx51_ecspi(spi_imx) || is_imx53_ecspi(spi_imx))\n\t\tcontroller->mode_bits |= SPI_RX_CPHA_FLIP;\n\n\tif (is_imx51_ecspi(spi_imx) &&\n\t    device_property_read_u32(&pdev->dev, \"cs-gpios\", NULL))\n\t\t \n\t\tcontroller->mode_bits |= SPI_CS_WORD;\n\n\tif (is_imx51_ecspi(spi_imx) || is_imx53_ecspi(spi_imx)) {\n\t\tcontroller->max_native_cs = 4;\n\t\tcontroller->flags |= SPI_CONTROLLER_GPIO_SS;\n\t}\n\n\tspi_imx->spi_drctl = spi_drctl;\n\n\tinit_completion(&spi_imx->xfer_done);\n\n\tspi_imx->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(spi_imx->base)) {\n\t\tret = PTR_ERR(spi_imx->base);\n\t\tgoto out_controller_put;\n\t}\n\tspi_imx->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, spi_imx_isr, 0,\n\t\t\t       dev_name(&pdev->dev), spi_imx);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tspi_imx->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(spi_imx->clk_ipg)) {\n\t\tret = PTR_ERR(spi_imx->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\tspi_imx->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(spi_imx->clk_per)) {\n\t\tret = PTR_ERR(spi_imx->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tret = clk_prepare_enable(spi_imx->clk_per);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = clk_prepare_enable(spi_imx->clk_ipg);\n\tif (ret)\n\t\tgoto out_put_per;\n\n\tpm_runtime_set_autosuspend_delay(spi_imx->dev, MXC_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(spi_imx->dev);\n\tpm_runtime_get_noresume(spi_imx->dev);\n\tpm_runtime_set_active(spi_imx->dev);\n\tpm_runtime_enable(spi_imx->dev);\n\n\tspi_imx->spi_clk = clk_get_rate(spi_imx->clk_per);\n\t \n\tif (spi_imx->devtype_data->has_dmamode) {\n\t\tret = spi_imx_sdma_init(&pdev->dev, spi_imx, controller);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto out_runtime_pm_put;\n\n\t\tif (ret < 0)\n\t\t\tdev_dbg(&pdev->dev, \"dma setup error %d, use pio\\n\",\n\t\t\t\tret);\n\t}\n\n\tspi_imx->devtype_data->reset(spi_imx);\n\n\tspi_imx->devtype_data->intctrl(spi_imx, 0);\n\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tret = spi_register_controller(controller);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"register controller failed\\n\");\n\t\tgoto out_register_controller;\n\t}\n\n\tpm_runtime_mark_last_busy(spi_imx->dev);\n\tpm_runtime_put_autosuspend(spi_imx->dev);\n\n\treturn ret;\n\nout_register_controller:\n\tif (spi_imx->devtype_data->has_dmamode)\n\t\tspi_imx_sdma_exit(spi_imx);\nout_runtime_pm_put:\n\tpm_runtime_dont_use_autosuspend(spi_imx->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_disable(spi_imx->dev);\n\n\tclk_disable_unprepare(spi_imx->clk_ipg);\nout_put_per:\n\tclk_disable_unprepare(spi_imx->clk_per);\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}\n\nstatic void spi_imx_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *controller = platform_get_drvdata(pdev);\n\tstruct spi_imx_data *spi_imx = spi_controller_get_devdata(controller);\n\tint ret;\n\n\tspi_unregister_controller(controller);\n\n\tret = pm_runtime_get_sync(spi_imx->dev);\n\tif (ret >= 0)\n\t\twritel(0, spi_imx->base + MXC_CSPICTRL);\n\telse\n\t\tdev_warn(spi_imx->dev, \"failed to enable clock, skip hw disable\\n\");\n\n\tpm_runtime_dont_use_autosuspend(spi_imx->dev);\n\tpm_runtime_put_sync(spi_imx->dev);\n\tpm_runtime_disable(spi_imx->dev);\n\n\tspi_imx_sdma_exit(spi_imx);\n}\n\nstatic int __maybe_unused spi_imx_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct spi_imx_data *spi_imx;\n\tint ret;\n\n\tspi_imx = spi_controller_get_devdata(controller);\n\n\tret = clk_prepare_enable(spi_imx->clk_per);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(spi_imx->clk_ipg);\n\tif (ret) {\n\t\tclk_disable_unprepare(spi_imx->clk_per);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused spi_imx_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct spi_imx_data *spi_imx;\n\n\tspi_imx = spi_controller_get_devdata(controller);\n\n\tclk_disable_unprepare(spi_imx->clk_per);\n\tclk_disable_unprepare(spi_imx->clk_ipg);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused spi_imx_suspend(struct device *dev)\n{\n\tpinctrl_pm_select_sleep_state(dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused spi_imx_resume(struct device *dev)\n{\n\tpinctrl_pm_select_default_state(dev);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx_spi_pm = {\n\tSET_RUNTIME_PM_OPS(spi_imx_runtime_suspend,\n\t\t\t\tspi_imx_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(spi_imx_suspend, spi_imx_resume)\n};\n\nstatic struct platform_driver spi_imx_driver = {\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = spi_imx_dt_ids,\n\t\t   .pm = &imx_spi_pm,\n\t},\n\t.probe = spi_imx_probe,\n\t.remove_new = spi_imx_remove,\n};\nmodule_platform_driver(spi_imx_driver);\n\nMODULE_DESCRIPTION(\"i.MX SPI Controller driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}