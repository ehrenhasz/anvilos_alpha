{
  "module_name": "spi-jcore.c",
  "hash_id": "896738e19c796a2de2a6ec9ed386bb868c7027f7cd5070e205fa3fdc85f8ac70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-jcore.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n\n#define DRV_NAME\t\"jcore_spi\"\n\n#define CTRL_REG\t0x0\n#define DATA_REG\t0x4\n\n#define JCORE_SPI_CTRL_XMIT\t\t0x02\n#define JCORE_SPI_STAT_BUSY\t\t0x02\n#define JCORE_SPI_CTRL_LOOP\t\t0x08\n#define JCORE_SPI_CTRL_CS_BITS\t\t0x15\n\n#define JCORE_SPI_WAIT_RDY_MAX_LOOP\t2000000\n\nstruct jcore_spi {\n\tstruct spi_controller *host;\n\tvoid __iomem *base;\n\tunsigned int cs_reg;\n\tunsigned int speed_reg;\n\tunsigned int speed_hz;\n\tunsigned int clock_freq;\n};\n\nstatic int jcore_spi_wait(void __iomem *ctrl_reg)\n{\n\tunsigned timeout = JCORE_SPI_WAIT_RDY_MAX_LOOP;\n\n\tdo {\n\t\tif (!(readl(ctrl_reg) & JCORE_SPI_STAT_BUSY))\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (--timeout);\n\n\treturn -EBUSY;\n}\n\nstatic void jcore_spi_program(struct jcore_spi *hw)\n{\n\tvoid __iomem *ctrl_reg = hw->base + CTRL_REG;\n\n\tif (jcore_spi_wait(ctrl_reg))\n\t\tdev_err(hw->host->dev.parent,\n\t\t\t\"timeout waiting to program ctrl reg.\\n\");\n\n\twritel(hw->cs_reg | hw->speed_reg, ctrl_reg);\n}\n\nstatic void jcore_spi_chipsel(struct spi_device *spi, bool value)\n{\n\tstruct jcore_spi *hw = spi_controller_get_devdata(spi->controller);\n\tu32 csbit = 1U << (2 * spi_get_chipselect(spi, 0));\n\n\tdev_dbg(hw->host->dev.parent, \"chipselect %d\\n\", spi_get_chipselect(spi, 0));\n\n\tif (value)\n\t\thw->cs_reg |= csbit;\n\telse\n\t\thw->cs_reg &= ~csbit;\n\n\tjcore_spi_program(hw);\n}\n\nstatic void jcore_spi_baudrate(struct jcore_spi *hw, int speed)\n{\n\tif (speed == hw->speed_hz)\n\t\treturn;\n\thw->speed_hz = speed;\n\tif (speed >= hw->clock_freq / 2)\n\t\thw->speed_reg = 0;\n\telse\n\t\thw->speed_reg = ((hw->clock_freq / 2 / speed) - 1) << 27;\n\tjcore_spi_program(hw);\n\tdev_dbg(hw->host->dev.parent, \"speed=%d reg=0x%x\\n\",\n\t\tspeed, hw->speed_reg);\n}\n\nstatic int jcore_spi_txrx(struct spi_controller *host, struct spi_device *spi,\n\t\t\t  struct spi_transfer *t)\n{\n\tstruct jcore_spi *hw = spi_controller_get_devdata(host);\n\n\tvoid __iomem *ctrl_reg = hw->base + CTRL_REG;\n\tvoid __iomem *data_reg = hw->base + DATA_REG;\n\tu32 xmit;\n\n\t \n\tconst unsigned char *tx;\n\tunsigned char *rx;\n\tunsigned int len;\n\tunsigned int count;\n\n\tjcore_spi_baudrate(hw, t->speed_hz);\n\n\txmit = hw->cs_reg | hw->speed_reg | JCORE_SPI_CTRL_XMIT;\n\ttx = t->tx_buf;\n\trx = t->rx_buf;\n\tlen = t->len;\n\n\tfor (count = 0; count < len; count++) {\n\t\tif (jcore_spi_wait(ctrl_reg))\n\t\t\tbreak;\n\n\t\twritel(tx ? *tx++ : 0, data_reg);\n\t\twritel(xmit, ctrl_reg);\n\n\t\tif (jcore_spi_wait(ctrl_reg))\n\t\t\tbreak;\n\n\t\tif (rx)\n\t\t\t*rx++ = readl(data_reg);\n\t}\n\n\tspi_finalize_current_transfer(host);\n\n\tif (count < len)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int jcore_spi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct jcore_spi *hw;\n\tstruct spi_controller *host;\n\tstruct resource *res;\n\tu32 clock_freq;\n\tstruct clk *clk;\n\tint err = -ENODEV;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(struct jcore_spi));\n\tif (!host)\n\t\treturn err;\n\n\t \n\thost->num_chipselect = 3;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\thost->transfer_one = jcore_spi_txrx;\n\thost->set_cs = jcore_spi_chipsel;\n\thost->dev.of_node = node;\n\thost->bus_num = pdev->id;\n\n\thw = spi_controller_get_devdata(host);\n\thw->host = host;\n\tplatform_set_drvdata(pdev, hw);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\tgoto exit_busy;\n\tif (!devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t     resource_size(res), pdev->name))\n\t\tgoto exit_busy;\n\thw->base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\tresource_size(res));\n\tif (!hw->base)\n\t\tgoto exit_busy;\n\n\t \n\tclock_freq = 50000000;\n\tclk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\tif (!IS_ERR(clk)) {\n\t\tif (clk_prepare_enable(clk) == 0) {\n\t\t\tclock_freq = clk_get_rate(clk);\n\t\t\tclk_disable_unprepare(clk);\n\t\t} else\n\t\t\tdev_warn(&pdev->dev, \"could not enable ref_clk\\n\");\n\t}\n\thw->clock_freq = clock_freq;\n\n\t \n\thw->cs_reg = JCORE_SPI_CTRL_CS_BITS;\n\tjcore_spi_baudrate(hw, 400000);\n\n\t \n\terr = devm_spi_register_controller(&pdev->dev, host);\n\tif (err)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit_busy:\n\terr = -EBUSY;\nexit:\n\tspi_controller_put(host);\n\treturn err;\n}\n\nstatic const struct of_device_id jcore_spi_of_match[] = {\n\t{ .compatible = \"jcore,spi2\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jcore_spi_of_match);\n\nstatic struct platform_driver jcore_spi_driver = {\n\t.probe = jcore_spi_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = jcore_spi_of_match,\n\t},\n};\n\nmodule_platform_driver(jcore_spi_driver);\n\nMODULE_DESCRIPTION(\"J-Core SPI driver\");\nMODULE_AUTHOR(\"Rich Felker <dalias@libc.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}