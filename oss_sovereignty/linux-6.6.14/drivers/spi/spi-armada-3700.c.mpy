{
  "module_name": "spi-armada-3700.c",
  "hash_id": "1be22e6ef2d9784fea29bcc7800b2f61a4f4a6a6ef371f812673e78f2b1008ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-armada-3700.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/spi/spi.h>\n\n#define DRIVER_NAME\t\t\t\"armada_3700_spi\"\n\n#define A3700_SPI_MAX_SPEED_HZ\t\t100000000\n#define A3700_SPI_MAX_PRESCALE\t\t30\n#define A3700_SPI_TIMEOUT\t\t10\n\n \n#define A3700_SPI_IF_CTRL_REG\t\t0x00\n#define A3700_SPI_IF_CFG_REG\t\t0x04\n#define A3700_SPI_DATA_OUT_REG\t\t0x08\n#define A3700_SPI_DATA_IN_REG\t\t0x0C\n#define A3700_SPI_IF_INST_REG\t\t0x10\n#define A3700_SPI_IF_ADDR_REG\t\t0x14\n#define A3700_SPI_IF_RMODE_REG\t\t0x18\n#define A3700_SPI_IF_HDR_CNT_REG\t0x1C\n#define A3700_SPI_IF_DIN_CNT_REG\t0x20\n#define A3700_SPI_IF_TIME_REG\t\t0x24\n#define A3700_SPI_INT_STAT_REG\t\t0x28\n#define A3700_SPI_INT_MASK_REG\t\t0x2C\n\n \n#define A3700_SPI_EN\t\t\tBIT(16)\n#define A3700_SPI_ADDR_NOT_CONFIG\tBIT(12)\n#define A3700_SPI_WFIFO_OVERFLOW\tBIT(11)\n#define A3700_SPI_WFIFO_UNDERFLOW\tBIT(10)\n#define A3700_SPI_RFIFO_OVERFLOW\tBIT(9)\n#define A3700_SPI_RFIFO_UNDERFLOW\tBIT(8)\n#define A3700_SPI_WFIFO_FULL\t\tBIT(7)\n#define A3700_SPI_WFIFO_EMPTY\t\tBIT(6)\n#define A3700_SPI_RFIFO_FULL\t\tBIT(5)\n#define A3700_SPI_RFIFO_EMPTY\t\tBIT(4)\n#define A3700_SPI_WFIFO_RDY\t\tBIT(3)\n#define A3700_SPI_RFIFO_RDY\t\tBIT(2)\n#define A3700_SPI_XFER_RDY\t\tBIT(1)\n#define A3700_SPI_XFER_DONE\t\tBIT(0)\n\n \n#define A3700_SPI_WFIFO_THRS\t\tBIT(28)\n#define A3700_SPI_RFIFO_THRS\t\tBIT(24)\n#define A3700_SPI_AUTO_CS\t\tBIT(20)\n#define A3700_SPI_DMA_RD_EN\t\tBIT(18)\n#define A3700_SPI_FIFO_MODE\t\tBIT(17)\n#define A3700_SPI_SRST\t\t\tBIT(16)\n#define A3700_SPI_XFER_START\t\tBIT(15)\n#define A3700_SPI_XFER_STOP\t\tBIT(14)\n#define A3700_SPI_INST_PIN\t\tBIT(13)\n#define A3700_SPI_ADDR_PIN\t\tBIT(12)\n#define A3700_SPI_DATA_PIN1\t\tBIT(11)\n#define A3700_SPI_DATA_PIN0\t\tBIT(10)\n#define A3700_SPI_FIFO_FLUSH\t\tBIT(9)\n#define A3700_SPI_RW_EN\t\t\tBIT(8)\n#define A3700_SPI_CLK_POL\t\tBIT(7)\n#define A3700_SPI_CLK_PHA\t\tBIT(6)\n#define A3700_SPI_BYTE_LEN\t\tBIT(5)\n#define A3700_SPI_CLK_PRESCALE\t\tBIT(0)\n#define A3700_SPI_CLK_PRESCALE_MASK\t(0x1f)\n#define A3700_SPI_CLK_EVEN_OFFS\t\t(0x10)\n\n#define A3700_SPI_WFIFO_THRS_BIT\t28\n#define A3700_SPI_RFIFO_THRS_BIT\t24\n#define A3700_SPI_FIFO_THRS_MASK\t0x7\n\n#define A3700_SPI_DATA_PIN_MASK\t\t0x3\n\n \n#define A3700_SPI_DUMMY_CNT_BIT\t\t12\n#define A3700_SPI_DUMMY_CNT_MASK\t0x7\n#define A3700_SPI_RMODE_CNT_BIT\t\t8\n#define A3700_SPI_RMODE_CNT_MASK\t0x3\n#define A3700_SPI_ADDR_CNT_BIT\t\t4\n#define A3700_SPI_ADDR_CNT_MASK\t\t0x7\n#define A3700_SPI_INSTR_CNT_BIT\t\t0\n#define A3700_SPI_INSTR_CNT_MASK\t0x3\n\n \n#define A3700_SPI_CLK_CAPT_EDGE\t\tBIT(7)\n\nstruct a3700_spi {\n\tstruct spi_controller *host;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tunsigned int irq;\n\tunsigned int flags;\n\tbool xmit_data;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tsize_t buf_len;\n\tu8 byte_len;\n\tu32 wait_mask;\n\tstruct completion done;\n};\n\nstatic u32 spireg_read(struct a3700_spi *a3700_spi, u32 offset)\n{\n\treturn readl(a3700_spi->base + offset);\n}\n\nstatic void spireg_write(struct a3700_spi *a3700_spi, u32 offset, u32 data)\n{\n\twritel(data, a3700_spi->base + offset);\n}\n\nstatic void a3700_spi_auto_cs_unset(struct a3700_spi *a3700_spi)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval &= ~A3700_SPI_AUTO_CS;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n}\n\nstatic void a3700_spi_activate_cs(struct a3700_spi *a3700_spi, unsigned int cs)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\tval |= (A3700_SPI_EN << cs);\n\tspireg_write(a3700_spi, A3700_SPI_IF_CTRL_REG, val);\n}\n\nstatic void a3700_spi_deactivate_cs(struct a3700_spi *a3700_spi,\n\t\t\t\t    unsigned int cs)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\tval &= ~(A3700_SPI_EN << cs);\n\tspireg_write(a3700_spi, A3700_SPI_IF_CTRL_REG, val);\n}\n\nstatic int a3700_spi_pin_mode_set(struct a3700_spi *a3700_spi,\n\t\t\t\t  unsigned int pin_mode, bool receiving)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval &= ~(A3700_SPI_INST_PIN | A3700_SPI_ADDR_PIN);\n\tval &= ~(A3700_SPI_DATA_PIN0 | A3700_SPI_DATA_PIN1);\n\n\tswitch (pin_mode) {\n\tcase SPI_NBITS_SINGLE:\n\t\tbreak;\n\tcase SPI_NBITS_DUAL:\n\t\tval |= A3700_SPI_DATA_PIN0;\n\t\tbreak;\n\tcase SPI_NBITS_QUAD:\n\t\tval |= A3700_SPI_DATA_PIN1;\n\t\t \n\t\tif (receiving)\n\t\t\tval |= A3700_SPI_ADDR_PIN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&a3700_spi->host->dev, \"wrong pin mode %u\", pin_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\treturn 0;\n}\n\nstatic void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi, bool enable)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tif (enable)\n\t\tval |= A3700_SPI_FIFO_MODE;\n\telse\n\t\tval &= ~A3700_SPI_FIFO_MODE;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n}\n\nstatic void a3700_spi_mode_set(struct a3700_spi *a3700_spi,\n\t\t\t       unsigned int mode_bits)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\n\tif (mode_bits & SPI_CPOL)\n\t\tval |= A3700_SPI_CLK_POL;\n\telse\n\t\tval &= ~A3700_SPI_CLK_POL;\n\n\tif (mode_bits & SPI_CPHA)\n\t\tval |= A3700_SPI_CLK_PHA;\n\telse\n\t\tval &= ~A3700_SPI_CLK_PHA;\n\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n}\n\nstatic void a3700_spi_clock_set(struct a3700_spi *a3700_spi,\n\t\t\t\tunsigned int speed_hz)\n{\n\tu32 val;\n\tu32 prescale;\n\n\tprescale = DIV_ROUND_UP(clk_get_rate(a3700_spi->clk), speed_hz);\n\n\t \n\tif (prescale > 15)\n\t\tprescale = A3700_SPI_CLK_EVEN_OFFS + DIV_ROUND_UP(prescale, 2);\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval = val & ~A3700_SPI_CLK_PRESCALE_MASK;\n\n\tval = val | (prescale & A3700_SPI_CLK_PRESCALE_MASK);\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\tif (prescale <= 2) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_TIME_REG);\n\t\tval |= A3700_SPI_CLK_CAPT_EDGE;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_TIME_REG, val);\n\t}\n}\n\nstatic void a3700_spi_bytelen_set(struct a3700_spi *a3700_spi, unsigned int len)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tif (len == 4)\n\t\tval |= A3700_SPI_BYTE_LEN;\n\telse\n\t\tval &= ~A3700_SPI_BYTE_LEN;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\ta3700_spi->byte_len = len;\n}\n\nstatic int a3700_spi_fifo_flush(struct a3700_spi *a3700_spi)\n{\n\tint timeout = A3700_SPI_TIMEOUT;\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval |= A3700_SPI_FIFO_FLUSH;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\twhile (--timeout) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tif (!(val & A3700_SPI_FIFO_FLUSH))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void a3700_spi_init(struct a3700_spi *a3700_spi)\n{\n\tstruct spi_controller *host = a3700_spi->host;\n\tu32 val;\n\tint i;\n\n\t \n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval |= A3700_SPI_SRST;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\tudelay(A3700_SPI_TIMEOUT);\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval &= ~A3700_SPI_SRST;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\t \n\ta3700_spi_auto_cs_unset(a3700_spi);\n\tfor (i = 0; i < host->num_chipselect; i++)\n\t\ta3700_spi_deactivate_cs(a3700_spi, i);\n\n\t \n\ta3700_spi_fifo_mode_set(a3700_spi, true);\n\n\t \n\ta3700_spi_mode_set(a3700_spi, host->mode_bits);\n\n\t \n\tspireg_write(a3700_spi, A3700_SPI_IF_HDR_CNT_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_IF_DIN_CNT_REG, 0);\n\n\t \n\tspireg_write(a3700_spi, A3700_SPI_INT_MASK_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_INT_STAT_REG, ~0U);\n}\n\nstatic irqreturn_t a3700_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = dev_id;\n\tstruct a3700_spi *a3700_spi;\n\tu32 cause;\n\n\ta3700_spi = spi_controller_get_devdata(host);\n\n\t \n\tcause = spireg_read(a3700_spi, A3700_SPI_INT_STAT_REG);\n\n\tif (!cause || !(a3700_spi->wait_mask & cause))\n\t\treturn IRQ_NONE;\n\n\t \n\tspireg_write(a3700_spi, A3700_SPI_INT_MASK_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_INT_STAT_REG, cause);\n\n\t \n\tcomplete(&a3700_spi->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool a3700_spi_wait_completion(struct spi_device *spi)\n{\n\tstruct a3700_spi *a3700_spi;\n\tunsigned int timeout;\n\tunsigned int ctrl_reg;\n\tunsigned long timeout_jiffies;\n\n\ta3700_spi = spi_controller_get_devdata(spi->controller);\n\n\t \n\tctrl_reg = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\tif (a3700_spi->wait_mask & ctrl_reg)\n\t\treturn true;\n\n\treinit_completion(&a3700_spi->done);\n\n\tspireg_write(a3700_spi, A3700_SPI_INT_MASK_REG,\n\t\t     a3700_spi->wait_mask);\n\n\ttimeout_jiffies = msecs_to_jiffies(A3700_SPI_TIMEOUT);\n\ttimeout = wait_for_completion_timeout(&a3700_spi->done,\n\t\t\t\t\t      timeout_jiffies);\n\n\ta3700_spi->wait_mask = 0;\n\n\tif (timeout)\n\t\treturn true;\n\n\t \n\tctrl_reg = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\tif (a3700_spi->wait_mask & ctrl_reg)\n\t\treturn true;\n\n\tspireg_write(a3700_spi, A3700_SPI_INT_MASK_REG, 0);\n\n\t \n\treturn false;\n}\n\nstatic bool a3700_spi_transfer_wait(struct spi_device *spi,\n\t\t\t\t    unsigned int bit_mask)\n{\n\tstruct a3700_spi *a3700_spi;\n\n\ta3700_spi = spi_controller_get_devdata(spi->controller);\n\ta3700_spi->wait_mask = bit_mask;\n\n\treturn a3700_spi_wait_completion(spi);\n}\n\nstatic void a3700_spi_fifo_thres_set(struct a3700_spi *a3700_spi,\n\t\t\t\t     unsigned int bytes)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval &= ~(A3700_SPI_FIFO_THRS_MASK << A3700_SPI_RFIFO_THRS_BIT);\n\tval |= (bytes - 1) << A3700_SPI_RFIFO_THRS_BIT;\n\tval &= ~(A3700_SPI_FIFO_THRS_MASK << A3700_SPI_WFIFO_THRS_BIT);\n\tval |= (7 - bytes) << A3700_SPI_WFIFO_THRS_BIT;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n}\n\nstatic void a3700_spi_transfer_setup(struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *xfer)\n{\n\tstruct a3700_spi *a3700_spi;\n\n\ta3700_spi = spi_controller_get_devdata(spi->controller);\n\n\ta3700_spi_clock_set(a3700_spi, xfer->speed_hz);\n\n\t \n\ta3700_spi_bytelen_set(a3700_spi, 4);\n\n\t \n\ta3700_spi->tx_buf  = xfer->tx_buf;\n\ta3700_spi->rx_buf  = xfer->rx_buf;\n\ta3700_spi->buf_len = xfer->len;\n}\n\nstatic void a3700_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct a3700_spi *a3700_spi = spi_controller_get_devdata(spi->controller);\n\n\tif (!enable)\n\t\ta3700_spi_activate_cs(a3700_spi, spi_get_chipselect(spi, 0));\n\telse\n\t\ta3700_spi_deactivate_cs(a3700_spi, spi_get_chipselect(spi, 0));\n}\n\nstatic void a3700_spi_header_set(struct a3700_spi *a3700_spi)\n{\n\tunsigned int addr_cnt;\n\tu32 val = 0;\n\n\t \n\tspireg_write(a3700_spi, A3700_SPI_IF_INST_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_IF_ADDR_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_IF_RMODE_REG, 0);\n\tspireg_write(a3700_spi, A3700_SPI_IF_HDR_CNT_REG, 0);\n\n\t \n\tif (a3700_spi->tx_buf) {\n\t\t \n\t\taddr_cnt = a3700_spi->buf_len % 4;\n\t\tif (addr_cnt) {\n\t\t\tval = (addr_cnt & A3700_SPI_ADDR_CNT_MASK)\n\t\t\t\t<< A3700_SPI_ADDR_CNT_BIT;\n\t\t\tspireg_write(a3700_spi, A3700_SPI_IF_HDR_CNT_REG, val);\n\n\t\t\t \n\t\t\ta3700_spi->buf_len -= addr_cnt;\n\n\t\t\t \n\t\t\tval = 0;\n\t\t\twhile (addr_cnt--) {\n\t\t\t\tval = (val << 8) | a3700_spi->tx_buf[0];\n\t\t\t\ta3700_spi->tx_buf++;\n\t\t\t}\n\t\t\tspireg_write(a3700_spi, A3700_SPI_IF_ADDR_REG, val);\n\t\t}\n\t}\n}\n\nstatic int a3700_is_wfifo_full(struct a3700_spi *a3700_spi)\n{\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\treturn (val & A3700_SPI_WFIFO_FULL);\n}\n\nstatic int a3700_spi_fifo_write(struct a3700_spi *a3700_spi)\n{\n\tu32 val;\n\n\twhile (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {\n\t\tval = *(u32 *)a3700_spi->tx_buf;\n\t\tspireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, cpu_to_le32(val));\n\t\ta3700_spi->buf_len -= 4;\n\t\ta3700_spi->tx_buf += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int a3700_is_rfifo_empty(struct a3700_spi *a3700_spi)\n{\n\tu32 val = spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG);\n\n\treturn (val & A3700_SPI_RFIFO_EMPTY);\n}\n\nstatic int a3700_spi_fifo_read(struct a3700_spi *a3700_spi)\n{\n\tu32 val;\n\n\twhile (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);\n\t\tif (a3700_spi->buf_len >= 4) {\n\t\t\tval = le32_to_cpu(val);\n\t\t\tmemcpy(a3700_spi->rx_buf, &val, 4);\n\n\t\t\ta3700_spi->buf_len -= 4;\n\t\t\ta3700_spi->rx_buf += 4;\n\t\t} else {\n\t\t\t \n\t\t\twhile (a3700_spi->buf_len) {\n\t\t\t\t*a3700_spi->rx_buf = val & 0xff;\n\t\t\t\tval >>= 8;\n\n\t\t\t\ta3700_spi->buf_len--;\n\t\t\t\ta3700_spi->rx_buf++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void a3700_spi_transfer_abort_fifo(struct a3700_spi *a3700_spi)\n{\n\tint timeout = A3700_SPI_TIMEOUT;\n\tu32 val;\n\n\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\tval |= A3700_SPI_XFER_STOP;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\twhile (--timeout) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tif (!(val & A3700_SPI_XFER_START))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\ta3700_spi_fifo_flush(a3700_spi);\n\n\tval &= ~A3700_SPI_XFER_STOP;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n}\n\nstatic int a3700_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t     struct spi_message *message)\n{\n\tstruct a3700_spi *a3700_spi = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = message->spi;\n\tint ret;\n\n\tret = clk_enable(a3700_spi->clk);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to enable clk with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = a3700_spi_fifo_flush(a3700_spi);\n\tif (ret)\n\t\treturn ret;\n\n\ta3700_spi_mode_set(a3700_spi, spi->mode);\n\n\treturn 0;\n}\n\nstatic int a3700_spi_transfer_one_fifo(struct spi_controller *host,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\tstruct a3700_spi *a3700_spi = spi_controller_get_devdata(host);\n\tint ret = 0, timeout = A3700_SPI_TIMEOUT;\n\tunsigned int nbits = 0, byte_len;\n\tu32 val;\n\n\t \n\ta3700_spi_fifo_mode_set(a3700_spi, true);\n\n\t \n\tbyte_len = xfer->bits_per_word >> 3;\n\ta3700_spi_fifo_thres_set(a3700_spi, byte_len);\n\n\tif (xfer->tx_buf)\n\t\tnbits = xfer->tx_nbits;\n\telse if (xfer->rx_buf)\n\t\tnbits = xfer->rx_nbits;\n\n\ta3700_spi_pin_mode_set(a3700_spi, nbits, xfer->rx_buf ? true : false);\n\n\t \n\ta3700_spi_fifo_flush(a3700_spi);\n\n\t \n\ta3700_spi_header_set(a3700_spi);\n\n\tif (xfer->rx_buf) {\n\t\t \n\t\tspireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, 0);\n\n\t\t \n\t\tspireg_write(a3700_spi, A3700_SPI_IF_DIN_CNT_REG,\n\t\t\t     a3700_spi->buf_len);\n\t\t \n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval &= ~A3700_SPI_RW_EN;\n\t\tval |= A3700_SPI_XFER_START;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t} else if (xfer->tx_buf) {\n\t\t \n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= (A3700_SPI_XFER_START | A3700_SPI_RW_EN);\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\n\t\t \n\t\ta3700_spi->xmit_data = (a3700_spi->buf_len != 0);\n\t}\n\n\twhile (a3700_spi->buf_len) {\n\t\tif (a3700_spi->tx_buf) {\n\t\t\t \n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"wait wfifo ready timed out\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tret = a3700_spi_fifo_write(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (a3700_spi->rx_buf) {\n\t\t\t \n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_RFIFO_RDY)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"wait rfifo ready timed out\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tret = a3700_spi_fifo_read(a3700_spi);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (a3700_spi->tx_buf) {\n\t\tif (a3700_spi->xmit_data) {\n\t\t\t \n\t\t\tif (!a3700_spi_transfer_wait(spi,\n\t\t\t\t\t\t     A3700_SPI_WFIFO_EMPTY)) {\n\t\t\t\tdev_err(&spi->dev, \"wait wfifo empty timed out\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\tif (!a3700_spi_transfer_wait(spi, A3700_SPI_XFER_RDY)) {\n\t\t\tdev_err(&spi->dev, \"wait xfer ready timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tval |= A3700_SPI_XFER_STOP;\n\t\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\t}\n\n\twhile (--timeout) {\n\t\tval = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);\n\t\tif (!(val & A3700_SPI_XFER_START))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(&spi->dev, \"wait transfer start clear timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tval &= ~A3700_SPI_XFER_STOP;\n\tspireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);\n\tgoto out;\n\nerror:\n\ta3700_spi_transfer_abort_fifo(a3700_spi);\nout:\n\tspi_finalize_current_transfer(host);\n\n\treturn ret;\n}\n\nstatic int a3700_spi_transfer_one_full_duplex(struct spi_controller *host,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\tstruct a3700_spi *a3700_spi = spi_controller_get_devdata(host);\n\tu32 val;\n\n\t \n\ta3700_spi_fifo_mode_set(a3700_spi, false);\n\n\twhile (a3700_spi->buf_len) {\n\n\t\t \n\t\tif (a3700_spi->buf_len < 4)\n\t\t\ta3700_spi_bytelen_set(a3700_spi, 1);\n\n\t\tif (a3700_spi->byte_len == 1)\n\t\t\tval = *a3700_spi->tx_buf;\n\t\telse\n\t\t\tval = *(u32 *)a3700_spi->tx_buf;\n\n\t\tspireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);\n\n\t\t \n\t\twhile (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &\n\t\t\t\tA3700_SPI_XFER_DONE))\n\t\t\tcpu_relax();\n\n\t\tval = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);\n\n\t\tmemcpy(a3700_spi->rx_buf, &val, a3700_spi->byte_len);\n\n\t\ta3700_spi->buf_len -= a3700_spi->byte_len;\n\t\ta3700_spi->tx_buf += a3700_spi->byte_len;\n\t\ta3700_spi->rx_buf += a3700_spi->byte_len;\n\n\t}\n\n\tspi_finalize_current_transfer(host);\n\n\treturn 0;\n}\n\nstatic int a3700_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\ta3700_spi_transfer_setup(spi, xfer);\n\n\tif (xfer->tx_buf && xfer->rx_buf)\n\t\treturn a3700_spi_transfer_one_full_duplex(host, spi, xfer);\n\n\treturn a3700_spi_transfer_one_fifo(host, spi, xfer);\n}\n\nstatic int a3700_spi_unprepare_message(struct spi_controller *host,\n\t\t\t\t       struct spi_message *message)\n{\n\tstruct a3700_spi *a3700_spi = spi_controller_get_devdata(host);\n\n\tclk_disable(a3700_spi->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id a3700_spi_dt_ids[] = {\n\t{ .compatible = \"marvell,armada-3700-spi\", .data = NULL },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, a3700_spi_dt_ids);\n\nstatic int a3700_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct spi_controller *host;\n\tstruct a3700_spi *spi;\n\tu32 num_cs = 0;\n\tint irq, ret = 0;\n\n\thost = spi_alloc_host(dev, sizeof(*spi));\n\tif (!host) {\n\t\tdev_err(dev, \"host allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(of_node, \"num-cs\", &num_cs)) {\n\t\tdev_err(dev, \"could not find num-cs\\n\");\n\t\tret = -ENXIO;\n\t\tgoto error;\n\t}\n\n\thost->bus_num = pdev->id;\n\thost->dev.of_node = of_node;\n\thost->mode_bits = SPI_MODE_3;\n\thost->num_chipselect = num_cs;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(32);\n\thost->prepare_message =  a3700_spi_prepare_message;\n\thost->transfer_one = a3700_spi_transfer_one;\n\thost->unprepare_message = a3700_spi_unprepare_message;\n\thost->set_cs = a3700_spi_set_cs;\n\thost->mode_bits |= (SPI_RX_DUAL | SPI_TX_DUAL |\n\t\t\t      SPI_RX_QUAD | SPI_TX_QUAD);\n\n\tplatform_set_drvdata(pdev, host);\n\n\tspi = spi_controller_get_devdata(host);\n\n\tspi->host = host;\n\n\tspi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spi->base)) {\n\t\tret = PTR_ERR(spi->base);\n\t\tgoto error;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENXIO;\n\t\tgoto error;\n\t}\n\tspi->irq = irq;\n\n\tinit_completion(&spi->done);\n\n\tspi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(spi->clk)) {\n\t\tdev_err(dev, \"could not find clk: %ld\\n\", PTR_ERR(spi->clk));\n\t\tgoto error;\n\t}\n\n\tret = clk_prepare(spi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not prepare clk: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\thost->max_speed_hz = min_t(unsigned long, A3700_SPI_MAX_SPEED_HZ,\n\t\t\t\t\tclk_get_rate(spi->clk));\n\thost->min_speed_hz = DIV_ROUND_UP(clk_get_rate(spi->clk),\n\t\t\t\t\t\tA3700_SPI_MAX_PRESCALE);\n\n\ta3700_spi_init(spi);\n\n\tret = devm_request_irq(dev, spi->irq, a3700_spi_interrupt, 0,\n\t\t\t       dev_name(dev), host);\n\tif (ret) {\n\t\tdev_err(dev, \"could not request IRQ: %d\\n\", ret);\n\t\tgoto error_clk;\n\t}\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register host\\n\");\n\t\tgoto error_clk;\n\t}\n\n\treturn 0;\n\nerror_clk:\n\tclk_unprepare(spi->clk);\nerror:\n\tspi_controller_put(host);\nout:\n\treturn ret;\n}\n\nstatic void a3700_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct a3700_spi *spi = spi_controller_get_devdata(host);\n\n\tclk_unprepare(spi->clk);\n}\n\nstatic struct platform_driver a3700_spi_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(a3700_spi_dt_ids),\n\t},\n\t.probe\t\t= a3700_spi_probe,\n\t.remove_new\t= a3700_spi_remove,\n};\n\nmodule_platform_driver(a3700_spi_driver);\n\nMODULE_DESCRIPTION(\"Armada-3700 SPI driver\");\nMODULE_AUTHOR(\"Wilson Ding <dingwei@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}