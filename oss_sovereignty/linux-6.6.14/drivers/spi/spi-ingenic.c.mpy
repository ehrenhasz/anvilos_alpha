{
  "module_name": "spi-ingenic.c",
  "hash_id": "32bc720388dbd9ac629aed47cb71b38d95a5fe65e85028cd9c79d942410dedab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ingenic.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#define REG_SSIDR\t0x0\n#define REG_SSICR0\t0x4\n#define REG_SSICR1\t0x8\n#define REG_SSISR\t0xc\n#define REG_SSIGR\t0x18\n\n#define REG_SSICR0_TENDIAN_LSB\t\tBIT(19)\n#define REG_SSICR0_RENDIAN_LSB\t\tBIT(17)\n#define REG_SSICR0_SSIE\t\t\tBIT(15)\n#define REG_SSICR0_LOOP\t\t\tBIT(10)\n#define REG_SSICR0_EACLRUN\t\tBIT(7)\n#define REG_SSICR0_FSEL\t\t\tBIT(6)\n#define REG_SSICR0_TFLUSH\t\tBIT(2)\n#define REG_SSICR0_RFLUSH\t\tBIT(1)\n\n#define REG_SSICR1_FRMHL_MASK\t\t(BIT(31) | BIT(30))\n#define REG_SSICR1_FRMHL\t\tBIT(30)\n#define REG_SSICR1_LFST\t\t\tBIT(25)\n#define REG_SSICR1_UNFIN\t\tBIT(23)\n#define REG_SSICR1_PHA\t\t\tBIT(1)\n#define REG_SSICR1_POL\t\t\tBIT(0)\n\n#define REG_SSISR_END\t\t\tBIT(7)\n#define REG_SSISR_BUSY\t\t\tBIT(6)\n#define REG_SSISR_TFF\t\t\tBIT(5)\n#define REG_SSISR_RFE\t\t\tBIT(4)\n#define REG_SSISR_RFHF\t\t\tBIT(2)\n#define REG_SSISR_UNDR\t\t\tBIT(1)\n#define REG_SSISR_OVER\t\t\tBIT(0)\n\n#define SPI_INGENIC_FIFO_SIZE\t\t128u\n\nstruct jz_soc_info {\n\tu32 bits_per_word_mask;\n\tstruct reg_field flen_field;\n\tbool has_trendian;\n\n\tunsigned int max_speed_hz;\n\tunsigned int max_native_cs;\n};\n\nstruct ingenic_spi {\n\tconst struct jz_soc_info *soc_info;\n\tstruct clk *clk;\n\tstruct resource *mem_res;\n\n\tstruct regmap *map;\n\tstruct regmap_field *flen_field;\n};\n\nstatic int spi_ingenic_wait(struct ingenic_spi *priv,\n\t\t\t    unsigned long mask,\n\t\t\t    bool condition)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(priv->map, REG_SSISR, val,\n\t\t\t\t\t!!(val & mask) == condition,\n\t\t\t\t\t100, 10000);\n}\n\nstatic void spi_ingenic_set_cs(struct spi_device *spi, bool disable)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(spi->controller);\n\n\tif (disable) {\n\t\tregmap_clear_bits(priv->map, REG_SSICR1, REG_SSICR1_UNFIN);\n\t\tregmap_clear_bits(priv->map, REG_SSISR,\n\t\t\t\t  REG_SSISR_UNDR | REG_SSISR_OVER);\n\n\t\tspi_ingenic_wait(priv, REG_SSISR_END, true);\n\t} else {\n\t\tregmap_set_bits(priv->map, REG_SSICR1, REG_SSICR1_UNFIN);\n\t}\n\n\tregmap_set_bits(priv->map, REG_SSICR0,\n\t\t\tREG_SSICR0_RFLUSH | REG_SSICR0_TFLUSH);\n}\n\nstatic void spi_ingenic_prepare_transfer(struct ingenic_spi *priv,\n\t\t\t\t\t struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *xfer)\n{\n\tunsigned long clk_hz = clk_get_rate(priv->clk);\n\tu32 cdiv, speed_hz = xfer->speed_hz ?: spi->max_speed_hz,\n\t    bits_per_word = xfer->bits_per_word ?: spi->bits_per_word;\n\n\tcdiv = clk_hz / (speed_hz * 2);\n\tcdiv = clamp(cdiv, 1u, 0x100u) - 1;\n\n\tregmap_write(priv->map, REG_SSIGR, cdiv);\n\n\tregmap_field_write(priv->flen_field, bits_per_word - 2);\n}\n\nstatic void spi_ingenic_finalize_transfer(void *controller)\n{\n\tspi_finalize_current_transfer(controller);\n}\n\nstatic struct dma_async_tx_descriptor *\nspi_ingenic_prepare_dma(struct spi_controller *ctlr, struct dma_chan *chan,\n\t\t\tstruct sg_table *sg, enum dma_transfer_direction dir,\n\t\t\tunsigned int bits)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(ctlr);\n\tstruct dma_slave_config cfg = {\n\t\t.direction = dir,\n\t\t.src_addr = priv->mem_res->start + REG_SSIDR,\n\t\t.dst_addr = priv->mem_res->start + REG_SSIDR,\n\t};\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (bits > 16) {\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tcfg.src_maxburst = cfg.dst_maxburst = 4;\n\t} else if (bits > 8) {\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tcfg.src_maxburst = cfg.dst_maxburst = 2;\n\t} else {\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tcfg.src_maxburst = cfg.dst_maxburst = 1;\n\t}\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdesc = dmaengine_prep_slave_sg(chan, sg->sgl, sg->nents, dir,\n\t\t\t\t       DMA_PREP_INTERRUPT);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dir == DMA_DEV_TO_MEM) {\n\t\tdesc->callback = spi_ingenic_finalize_transfer;\n\t\tdesc->callback_param = ctlr;\n\t}\n\n\tcookie = dmaengine_submit(desc);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdmaengine_desc_free(desc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn desc;\n}\n\nstatic int spi_ingenic_dma_tx(struct spi_controller *ctlr,\n\t\t\t      struct spi_transfer *xfer, unsigned int bits)\n{\n\tstruct dma_async_tx_descriptor *rx_desc, *tx_desc;\n\n\trx_desc = spi_ingenic_prepare_dma(ctlr, ctlr->dma_rx,\n\t\t\t\t\t  &xfer->rx_sg, DMA_DEV_TO_MEM, bits);\n\tif (IS_ERR(rx_desc))\n\t\treturn PTR_ERR(rx_desc);\n\n\ttx_desc = spi_ingenic_prepare_dma(ctlr, ctlr->dma_tx,\n\t\t\t\t\t  &xfer->tx_sg, DMA_MEM_TO_DEV, bits);\n\tif (IS_ERR(tx_desc)) {\n\t\tdmaengine_terminate_async(ctlr->dma_rx);\n\t\tdmaengine_desc_free(rx_desc);\n\t\treturn PTR_ERR(tx_desc);\n\t}\n\n\tdma_async_issue_pending(ctlr->dma_rx);\n\tdma_async_issue_pending(ctlr->dma_tx);\n\n\treturn 1;\n}\n\n#define SPI_INGENIC_TX(x)\t\t\t\t\t\t\t\\\nstatic int spi_ingenic_tx##x(struct ingenic_spi *priv,\t\t\t\t\\\n\t\t\t     struct spi_transfer *xfer)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned int count = xfer->len / (x / 8);\t\t\t\t\\\n\tunsigned int prefill = min(count, SPI_INGENIC_FIFO_SIZE);\t\t\\\n\tconst u##x *tx_buf = xfer->tx_buf;\t\t\t\t\t\\\n\tu##x *rx_buf = xfer->rx_buf;\t\t\t\t\t\t\\\n\tunsigned int i, val;\t\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tfor (i = 0; i < prefill; i++) {\t\t\t\t\t\t\\\n\t\tval = tx_buf ? tx_buf[i] : 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tregmap_write(priv->map, REG_SSIDR, val);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < count; i++) {\t\t\t\t\t\t\\\n\t\terr = spi_ingenic_wait(priv, REG_SSISR_RFE, false);\t\t\\\n\t\tif (err)\t\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tregmap_read(priv->map, REG_SSIDR, &val);\t\t\t\\\n\t\tif (rx_buf)\t\t\t\t\t\t\t\\\n\t\t\trx_buf[i] = val;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (i < count - prefill) {\t\t\t\t\t\\\n\t\t\tval = tx_buf ? tx_buf[i + prefill] : 0;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tregmap_write(priv->map, REG_SSIDR, val);\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\t\\\n}\nSPI_INGENIC_TX(8)\nSPI_INGENIC_TX(16)\nSPI_INGENIC_TX(32)\n#undef SPI_INGENIC_TX\n\nstatic int spi_ingenic_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(ctlr);\n\tunsigned int bits = xfer->bits_per_word ?: spi->bits_per_word;\n\tbool can_dma = ctlr->can_dma && ctlr->can_dma(ctlr, spi, xfer);\n\n\tspi_ingenic_prepare_transfer(priv, spi, xfer);\n\n\tif (ctlr->cur_msg_mapped && can_dma)\n\t\treturn spi_ingenic_dma_tx(ctlr, xfer, bits);\n\n\tif (bits > 16)\n\t\treturn spi_ingenic_tx32(priv, xfer);\n\n\tif (bits > 8)\n\t\treturn spi_ingenic_tx16(priv, xfer);\n\n\treturn spi_ingenic_tx8(priv, xfer);\n}\n\nstatic int spi_ingenic_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_message *message)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = message->spi;\n\tunsigned int cs = REG_SSICR1_FRMHL << spi_get_chipselect(spi, 0);\n\tunsigned int ssicr0_mask = REG_SSICR0_LOOP | REG_SSICR0_FSEL;\n\tunsigned int ssicr1_mask = REG_SSICR1_PHA | REG_SSICR1_POL | cs;\n\tunsigned int ssicr0 = 0, ssicr1 = 0;\n\n\tif (priv->soc_info->has_trendian) {\n\t\tssicr0_mask |= REG_SSICR0_RENDIAN_LSB | REG_SSICR0_TENDIAN_LSB;\n\n\t\tif (spi->mode & SPI_LSB_FIRST)\n\t\t\tssicr0 |= REG_SSICR0_RENDIAN_LSB | REG_SSICR0_TENDIAN_LSB;\n\t} else {\n\t\tssicr1_mask |= REG_SSICR1_LFST;\n\n\t\tif (spi->mode & SPI_LSB_FIRST)\n\t\t\tssicr1 |= REG_SSICR1_LFST;\n\t}\n\n\tif (spi->mode & SPI_LOOP)\n\t\tssicr0 |= REG_SSICR0_LOOP;\n\tif (spi_get_chipselect(spi, 0))\n\t\tssicr0 |= REG_SSICR0_FSEL;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tssicr1 |= REG_SSICR1_PHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tssicr1 |= REG_SSICR1_POL;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tssicr1 |= cs;\n\n\tregmap_update_bits(priv->map, REG_SSICR0, ssicr0_mask, ssicr0);\n\tregmap_update_bits(priv->map, REG_SSICR1, ssicr1_mask, ssicr1);\n\n\treturn 0;\n}\n\nstatic int spi_ingenic_prepare_hardware(struct spi_controller *ctlr)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->map, REG_SSICR0, REG_SSICR0_EACLRUN);\n\tregmap_write(priv->map, REG_SSICR1, 0);\n\tregmap_write(priv->map, REG_SSISR, 0);\n\tregmap_set_bits(priv->map, REG_SSICR0, REG_SSICR0_SSIE);\n\n\treturn 0;\n}\n\nstatic int spi_ingenic_unprepare_hardware(struct spi_controller *ctlr)\n{\n\tstruct ingenic_spi *priv = spi_controller_get_devdata(ctlr);\n\n\tregmap_clear_bits(priv->map, REG_SSICR0, REG_SSICR0_SSIE);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic bool spi_ingenic_can_dma(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct dma_slave_caps caps;\n\tint ret;\n\n\tret = dma_get_slave_caps(ctlr->dma_tx, &caps);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Unable to get slave caps: %d\\n\", ret);\n\t\treturn false;\n\t}\n\n\treturn !caps.max_sg_burst ||\n\t\txfer->len <= caps.max_sg_burst * SPI_INGENIC_FIFO_SIZE;\n}\n\nstatic int spi_ingenic_request_dma(struct spi_controller *ctlr,\n\t\t\t\t   struct device *dev)\n{\n\tctlr->dma_tx = dma_request_slave_channel(dev, \"tx\");\n\tif (!ctlr->dma_tx)\n\t\treturn -ENODEV;\n\n\tctlr->dma_rx = dma_request_slave_channel(dev, \"rx\");\n\n\tif (!ctlr->dma_rx)\n\t\treturn -ENODEV;\n\n\tctlr->can_dma = spi_ingenic_can_dma;\n\n\treturn 0;\n}\n\nstatic void spi_ingenic_release_dma(void *data)\n{\n\tstruct spi_controller *ctlr = data;\n\n\tif (ctlr->dma_tx)\n\t\tdma_release_channel(ctlr->dma_tx);\n\tif (ctlr->dma_rx)\n\t\tdma_release_channel(ctlr->dma_rx);\n}\n\nstatic const struct regmap_config spi_ingenic_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = REG_SSIGR,\n};\n\nstatic int spi_ingenic_probe(struct platform_device *pdev)\n{\n\tconst struct jz_soc_info *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *ctlr;\n\tstruct ingenic_spi *priv;\n\tvoid __iomem *base;\n\tint num_cs, ret;\n\n\tpdata = of_device_get_match_data(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Missing platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctlr = devm_spi_alloc_host(dev, sizeof(*priv));\n\tif (!ctlr) {\n\t\tdev_err(dev, \"Unable to allocate SPI controller.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = spi_controller_get_devdata(ctlr);\n\tpriv->soc_info = pdata;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"Unable to get clock.\\n\");\n\t}\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &priv->mem_res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->map = devm_regmap_init_mmio(dev, base, &spi_ingenic_regmap_config);\n\tif (IS_ERR(priv->map))\n\t\treturn PTR_ERR(priv->map);\n\n\tpriv->flen_field = devm_regmap_field_alloc(dev, priv->map,\n\t\t\t\t\t\t   pdata->flen_field);\n\tif (IS_ERR(priv->flen_field))\n\t\treturn PTR_ERR(priv->flen_field);\n\n\tif (device_property_read_u32(dev, \"num-cs\", &num_cs))\n\t\tnum_cs = pdata->max_native_cs;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\tctlr->prepare_transfer_hardware = spi_ingenic_prepare_hardware;\n\tctlr->unprepare_transfer_hardware = spi_ingenic_unprepare_hardware;\n\tctlr->prepare_message = spi_ingenic_prepare_message;\n\tctlr->set_cs = spi_ingenic_set_cs;\n\tctlr->transfer_one = spi_ingenic_transfer_one;\n\tctlr->mode_bits = SPI_MODE_3 | SPI_LSB_FIRST | SPI_LOOP | SPI_CS_HIGH;\n\tctlr->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\tctlr->max_dma_len = SPI_INGENIC_FIFO_SIZE;\n\tctlr->bits_per_word_mask = pdata->bits_per_word_mask;\n\tctlr->min_speed_hz = 7200;\n\tctlr->max_speed_hz = pdata->max_speed_hz;\n\tctlr->use_gpio_descriptors = true;\n\tctlr->max_native_cs = pdata->max_native_cs;\n\tctlr->num_chipselect = num_cs;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\n\tif (spi_ingenic_request_dma(ctlr, dev))\n\t\tdev_warn(dev, \"DMA not available.\\n\");\n\n\tret = devm_add_action_or_reset(dev, spi_ingenic_release_dma, ctlr);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to add action.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret)\n\t\tdev_err(dev, \"Unable to register SPI controller.\\n\");\n\n\treturn ret;\n}\n\nstatic const struct jz_soc_info jz4750_soc_info = {\n\t.bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 17),\n\t.flen_field = REG_FIELD(REG_SSICR1, 4, 7),\n\t.has_trendian = false,\n\n\t.max_speed_hz = 54000000,\n\t.max_native_cs = 2,\n};\n\nstatic const struct jz_soc_info jz4780_soc_info = {\n\t.bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 32),\n\t.flen_field = REG_FIELD(REG_SSICR1, 3, 7),\n\t.has_trendian = true,\n\n\t.max_speed_hz = 54000000,\n\t.max_native_cs = 2,\n};\n\nstatic const struct jz_soc_info x1000_soc_info = {\n\t.bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 32),\n\t.flen_field = REG_FIELD(REG_SSICR1, 3, 7),\n\t.has_trendian = true,\n\n\t.max_speed_hz = 50000000,\n\t.max_native_cs = 2,\n};\n\nstatic const struct jz_soc_info x2000_soc_info = {\n\t.bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 32),\n\t.flen_field = REG_FIELD(REG_SSICR1, 3, 7),\n\t.has_trendian = true,\n\n\t.max_speed_hz = 50000000,\n\t.max_native_cs = 1,\n};\n\nstatic const struct of_device_id spi_ingenic_of_match[] = {\n\t{ .compatible = \"ingenic,jz4750-spi\", .data = &jz4750_soc_info },\n\t{ .compatible = \"ingenic,jz4775-spi\", .data = &jz4780_soc_info },\n\t{ .compatible = \"ingenic,jz4780-spi\", .data = &jz4780_soc_info },\n\t{ .compatible = \"ingenic,x1000-spi\", .data = &x1000_soc_info },\n\t{ .compatible = \"ingenic,x2000-spi\", .data = &x2000_soc_info },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spi_ingenic_of_match);\n\nstatic struct platform_driver spi_ingenic_driver = {\n\t.driver = {\n\t\t.name = \"spi-ingenic\",\n\t\t.of_match_table = spi_ingenic_of_match,\n\t},\n\t.probe = spi_ingenic_probe,\n};\n\nmodule_platform_driver(spi_ingenic_driver);\nMODULE_DESCRIPTION(\"SPI bus driver for the Ingenic SoCs\");\nMODULE_AUTHOR(\"Artur Rojek <contact@artur-rojek.eu>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_AUTHOR(\"\u5468\u7430\u6770 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}