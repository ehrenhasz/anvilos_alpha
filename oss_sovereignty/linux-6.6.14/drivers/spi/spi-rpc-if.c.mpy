{
  "module_name": "spi-rpc-if.c",
  "hash_id": "2d3f51a65674adbbcf6b901bfbf3bfd85059b63b364a61f9bc442d8b20ea9cbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rpc-if.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#include <memory/renesas-rpc-if.h>\n\n#include <asm/unaligned.h>\n\nstatic void rpcif_spi_mem_prepare(struct spi_device *spi_dev,\n\t\t\t\t  const struct spi_mem_op *spi_op,\n\t\t\t\t  u64 *offs, size_t *len)\n{\n\tstruct rpcif *rpc = spi_controller_get_devdata(spi_dev->controller);\n\tstruct rpcif_op rpc_op = { };\n\n\trpc_op.cmd.opcode = spi_op->cmd.opcode;\n\trpc_op.cmd.buswidth = spi_op->cmd.buswidth;\n\n\tif (spi_op->addr.nbytes) {\n\t\trpc_op.addr.buswidth = spi_op->addr.buswidth;\n\t\trpc_op.addr.nbytes = spi_op->addr.nbytes;\n\t\trpc_op.addr.val = spi_op->addr.val;\n\t}\n\n\tif (spi_op->dummy.nbytes) {\n\t\trpc_op.dummy.buswidth = spi_op->dummy.buswidth;\n\t\trpc_op.dummy.ncycles  = spi_op->dummy.nbytes * 8 /\n\t\t\t\t\tspi_op->dummy.buswidth;\n\t}\n\n\tif (spi_op->data.nbytes || (offs && len)) {\n\t\trpc_op.data.buswidth = spi_op->data.buswidth;\n\t\trpc_op.data.nbytes = spi_op->data.nbytes;\n\t\tswitch (spi_op->data.dir) {\n\t\tcase SPI_MEM_DATA_IN:\n\t\t\trpc_op.data.dir = RPCIF_DATA_IN;\n\t\t\trpc_op.data.buf.in = spi_op->data.buf.in;\n\t\t\tbreak;\n\t\tcase SPI_MEM_DATA_OUT:\n\t\t\trpc_op.data.dir = RPCIF_DATA_OUT;\n\t\t\trpc_op.data.buf.out = spi_op->data.buf.out;\n\t\t\tbreak;\n\t\tcase SPI_MEM_NO_DATA:\n\t\t\trpc_op.data.dir = RPCIF_NO_DATA;\n\t\t\tbreak;\n\t\t}\n\t} else\t{\n\t\trpc_op.data.dir = RPCIF_NO_DATA;\n\t}\n\n\trpcif_prepare(rpc->dev, &rpc_op, offs, len);\n}\n\nstatic bool rpcif_spi_mem_supports_op(struct spi_mem *mem,\n\t\t\t\t      const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\tif (op->data.buswidth > 4 || op->addr.buswidth > 4 ||\n\t    op->dummy.buswidth > 4 || op->cmd.buswidth > 4 ||\n\t    op->addr.nbytes > 4)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic ssize_t rpcif_spi_mem_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t\t u64 offs, size_t len, void *buf)\n{\n\tstruct rpcif *rpc =\n\t\tspi_controller_get_devdata(desc->mem->spi->controller);\n\n\tif (offs + desc->info.offset + len > U32_MAX)\n\t\treturn -EINVAL;\n\n\trpcif_spi_mem_prepare(desc->mem->spi, &desc->info.op_tmpl, &offs, &len);\n\n\treturn rpcif_dirmap_read(rpc->dev, offs, len, buf);\n}\n\nstatic int rpcif_spi_mem_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct rpcif *rpc =\n\t\tspi_controller_get_devdata(desc->mem->spi->controller);\n\n\tif (desc->info.offset + desc->info.length > U32_MAX)\n\t\treturn -ENOTSUPP;\n\n\tif (!rpcif_spi_mem_supports_op(desc->mem, &desc->info.op_tmpl))\n\t\treturn -ENOTSUPP;\n\n\tif (!rpc->dirmap && desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN)\n\t\treturn -ENOTSUPP;\n\n\tif (desc->info.op_tmpl.data.dir == SPI_MEM_DATA_OUT)\n\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic int rpcif_spi_mem_exec_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct rpcif *rpc =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\n\trpcif_spi_mem_prepare(mem->spi, op, NULL, NULL);\n\n\treturn rpcif_manual_xfer(rpc->dev);\n}\n\nstatic const struct spi_controller_mem_ops rpcif_spi_mem_ops = {\n\t.supports_op\t= rpcif_spi_mem_supports_op,\n\t.exec_op\t= rpcif_spi_mem_exec_op,\n\t.dirmap_create\t= rpcif_spi_mem_dirmap_create,\n\t.dirmap_read\t= rpcif_spi_mem_dirmap_read,\n};\n\nstatic int rpcif_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *parent = pdev->dev.parent;\n\tstruct spi_controller *ctlr;\n\tstruct rpcif *rpc;\n\tint error;\n\n\tctlr = devm_spi_alloc_host(&pdev->dev, sizeof(*rpc));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\trpc = spi_controller_get_devdata(ctlr);\n\terror = rpcif_sw_init(rpc, parent);\n\tif (error)\n\t\treturn error;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\tctlr->dev.of_node = parent->of_node;\n\n\tpm_runtime_enable(rpc->dev);\n\n\tctlr->num_chipselect = 1;\n\tctlr->mem_ops = &rpcif_spi_mem_ops;\n\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_TX_QUAD | SPI_RX_QUAD;\n\tctlr->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\n\terror = rpcif_hw_init(rpc->dev, false);\n\tif (error)\n\t\tgoto out_disable_rpm;\n\n\terror = spi_register_controller(ctlr);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller failed\\n\");\n\t\tgoto out_disable_rpm;\n\t}\n\n\treturn 0;\n\nout_disable_rpm:\n\tpm_runtime_disable(rpc->dev);\n\treturn error;\n}\n\nstatic void rpcif_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = platform_get_drvdata(pdev);\n\tstruct rpcif *rpc = spi_controller_get_devdata(ctlr);\n\n\tspi_unregister_controller(ctlr);\n\tpm_runtime_disable(rpc->dev);\n}\n\nstatic int __maybe_unused rpcif_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\n\treturn spi_controller_suspend(ctlr);\n}\n\nstatic int __maybe_unused rpcif_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\n\treturn spi_controller_resume(ctlr);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rpcif_spi_pm_ops, rpcif_spi_suspend, rpcif_spi_resume);\n\nstatic struct platform_driver rpcif_spi_driver = {\n\t.probe\t= rpcif_spi_probe,\n\t.remove_new = rpcif_spi_remove,\n\t.driver = {\n\t\t.name\t= \"rpc-if-spi\",\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &rpcif_spi_pm_ops,\n#endif\n\t},\n};\nmodule_platform_driver(rpcif_spi_driver);\n\nMODULE_DESCRIPTION(\"Renesas RPC-IF SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}