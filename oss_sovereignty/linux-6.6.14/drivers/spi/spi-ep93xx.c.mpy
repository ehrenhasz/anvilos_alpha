{
  "module_name": "spi-ep93xx.c",
  "hash_id": "fbca4dd39fdfea174e642748681308df7ab3eadfba1f45144d86cdc367febc67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ep93xx.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/scatterlist.h>\n#include <linux/spi/spi.h>\n\n#include <linux/platform_data/dma-ep93xx.h>\n#include <linux/platform_data/spi-ep93xx.h>\n\n#define SSPCR0\t\t\t0x0000\n#define SSPCR0_SPO\t\tBIT(6)\n#define SSPCR0_SPH\t\tBIT(7)\n#define SSPCR0_SCR_SHIFT\t8\n\n#define SSPCR1\t\t\t0x0004\n#define SSPCR1_RIE\t\tBIT(0)\n#define SSPCR1_TIE\t\tBIT(1)\n#define SSPCR1_RORIE\t\tBIT(2)\n#define SSPCR1_LBM\t\tBIT(3)\n#define SSPCR1_SSE\t\tBIT(4)\n#define SSPCR1_MS\t\tBIT(5)\n#define SSPCR1_SOD\t\tBIT(6)\n\n#define SSPDR\t\t\t0x0008\n\n#define SSPSR\t\t\t0x000c\n#define SSPSR_TFE\t\tBIT(0)\n#define SSPSR_TNF\t\tBIT(1)\n#define SSPSR_RNE\t\tBIT(2)\n#define SSPSR_RFF\t\tBIT(3)\n#define SSPSR_BSY\t\tBIT(4)\n#define SSPCPSR\t\t\t0x0010\n\n#define SSPIIR\t\t\t0x0014\n#define SSPIIR_RIS\t\tBIT(0)\n#define SSPIIR_TIS\t\tBIT(1)\n#define SSPIIR_RORIS\t\tBIT(2)\n#define SSPICR\t\t\tSSPIIR\n\n \n#define SPI_TIMEOUT\t\t5\n \n#define SPI_FIFO_SIZE\t\t8\n\n \nstruct ep93xx_spi {\n\tstruct clk\t\t\t*clk;\n\tvoid __iomem\t\t\t*mmio;\n\tunsigned long\t\t\tsspdr_phys;\n\tsize_t\t\t\t\ttx;\n\tsize_t\t\t\t\trx;\n\tsize_t\t\t\t\tfifo_level;\n\tstruct dma_chan\t\t\t*dma_rx;\n\tstruct dma_chan\t\t\t*dma_tx;\n\tstruct ep93xx_dma_data\t\tdma_rx_data;\n\tstruct ep93xx_dma_data\t\tdma_tx_data;\n\tstruct sg_table\t\t\trx_sgt;\n\tstruct sg_table\t\t\ttx_sgt;\n\tvoid\t\t\t\t*zeropage;\n};\n\n \n#define bits_per_word_to_dss(bpw)\t((bpw) - 1)\n\n \nstatic int ep93xx_spi_calc_divisors(struct spi_controller *host,\n\t\t\t\t    u32 rate, u8 *div_cpsr, u8 *div_scr)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tunsigned long spi_clk_rate = clk_get_rate(espi->clk);\n\tint cpsr, scr;\n\n\t \n\trate = clamp(rate, host->min_speed_hz, host->max_speed_hz);\n\n\t \n\tfor (cpsr = 2; cpsr <= 254; cpsr += 2) {\n\t\tfor (scr = 0; scr <= 255; scr++) {\n\t\t\tif ((spi_clk_rate / (cpsr * (scr + 1))) <= rate) {\n\t\t\t\t*div_scr = (u8)scr;\n\t\t\t\t*div_cpsr = (u8)cpsr;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ep93xx_spi_chip_setup(struct spi_controller *host,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *xfer)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tu8 dss = bits_per_word_to_dss(xfer->bits_per_word);\n\tu8 div_cpsr = 0;\n\tu8 div_scr = 0;\n\tu16 cr0;\n\tint err;\n\n\terr = ep93xx_spi_calc_divisors(host, xfer->speed_hz,\n\t\t\t\t       &div_cpsr, &div_scr);\n\tif (err)\n\t\treturn err;\n\n\tcr0 = div_scr << SSPCR0_SCR_SHIFT;\n\tif (spi->mode & SPI_CPOL)\n\t\tcr0 |= SSPCR0_SPO;\n\tif (spi->mode & SPI_CPHA)\n\t\tcr0 |= SSPCR0_SPH;\n\tcr0 |= dss;\n\n\tdev_dbg(&host->dev, \"setup: mode %d, cpsr %d, scr %d, dss %d\\n\",\n\t\tspi->mode, div_cpsr, div_scr, dss);\n\tdev_dbg(&host->dev, \"setup: cr0 %#x\\n\", cr0);\n\n\twritel(div_cpsr, espi->mmio + SSPCPSR);\n\twritel(cr0, espi->mmio + SSPCR0);\n\n\treturn 0;\n}\n\nstatic void ep93xx_do_write(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct spi_transfer *xfer = host->cur_msg->state;\n\tu32 val = 0;\n\n\tif (xfer->bits_per_word > 8) {\n\t\tif (xfer->tx_buf)\n\t\t\tval = ((u16 *)xfer->tx_buf)[espi->tx];\n\t\tespi->tx += 2;\n\t} else {\n\t\tif (xfer->tx_buf)\n\t\t\tval = ((u8 *)xfer->tx_buf)[espi->tx];\n\t\tespi->tx += 1;\n\t}\n\twritel(val, espi->mmio + SSPDR);\n}\n\nstatic void ep93xx_do_read(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct spi_transfer *xfer = host->cur_msg->state;\n\tu32 val;\n\n\tval = readl(espi->mmio + SSPDR);\n\tif (xfer->bits_per_word > 8) {\n\t\tif (xfer->rx_buf)\n\t\t\t((u16 *)xfer->rx_buf)[espi->rx] = val;\n\t\tespi->rx += 2;\n\t} else {\n\t\tif (xfer->rx_buf)\n\t\t\t((u8 *)xfer->rx_buf)[espi->rx] = val;\n\t\tespi->rx += 1;\n\t}\n}\n\n \nstatic int ep93xx_spi_read_write(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct spi_transfer *xfer = host->cur_msg->state;\n\n\t \n\twhile ((readl(espi->mmio + SSPSR) & SSPSR_RNE)) {\n\t\tep93xx_do_read(host);\n\t\tespi->fifo_level--;\n\t}\n\n\t \n\twhile (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < xfer->len) {\n\t\tep93xx_do_write(host);\n\t\tespi->fifo_level++;\n\t}\n\n\tif (espi->rx == xfer->len)\n\t\treturn 0;\n\n\treturn -EINPROGRESS;\n}\n\nstatic enum dma_transfer_direction\nep93xx_dma_data_to_trans_dir(enum dma_data_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_TO_DEVICE:\n\t\treturn DMA_MEM_TO_DEV;\n\tcase DMA_FROM_DEVICE:\n\t\treturn DMA_DEV_TO_MEM;\n\tdefault:\n\t\treturn DMA_TRANS_NONE;\n\t}\n}\n\n \nstatic struct dma_async_tx_descriptor *\nep93xx_spi_dma_prepare(struct spi_controller *host,\n\t\t       enum dma_data_direction dir)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct spi_transfer *xfer = host->cur_msg->state;\n\tstruct dma_async_tx_descriptor *txd;\n\tenum dma_slave_buswidth buswidth;\n\tstruct dma_slave_config conf;\n\tstruct scatterlist *sg;\n\tstruct sg_table *sgt;\n\tstruct dma_chan *chan;\n\tconst void *buf, *pbuf;\n\tsize_t len = xfer->len;\n\tint i, ret, nents;\n\n\tif (xfer->bits_per_word > 8)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\n\tmemset(&conf, 0, sizeof(conf));\n\tconf.direction = ep93xx_dma_data_to_trans_dir(dir);\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tchan = espi->dma_rx;\n\t\tbuf = xfer->rx_buf;\n\t\tsgt = &espi->rx_sgt;\n\n\t\tconf.src_addr = espi->sspdr_phys;\n\t\tconf.src_addr_width = buswidth;\n\t} else {\n\t\tchan = espi->dma_tx;\n\t\tbuf = xfer->tx_buf;\n\t\tsgt = &espi->tx_sgt;\n\n\t\tconf.dst_addr = espi->sspdr_phys;\n\t\tconf.dst_addr_width = buswidth;\n\t}\n\n\tret = dmaengine_slave_config(chan, &conf);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\n\tnents = DIV_ROUND_UP(len, PAGE_SIZE);\n\tif (nents != sgt->nents) {\n\t\tsg_free_table(sgt);\n\n\t\tret = sg_alloc_table(sgt, nents, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tpbuf = buf;\n\tfor_each_sg(sgt->sgl, sg, sgt->nents, i) {\n\t\tsize_t bytes = min_t(size_t, len, PAGE_SIZE);\n\n\t\tif (buf) {\n\t\t\tsg_set_page(sg, virt_to_page(pbuf), bytes,\n\t\t\t\t    offset_in_page(pbuf));\n\t\t} else {\n\t\t\tsg_set_page(sg, virt_to_page(espi->zeropage),\n\t\t\t\t    bytes, 0);\n\t\t}\n\n\t\tpbuf += bytes;\n\t\tlen -= bytes;\n\t}\n\n\tif (WARN_ON(len)) {\n\t\tdev_warn(&host->dev, \"len = %zu expected 0!\\n\", len);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnents = dma_map_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\n\tif (!nents)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttxd = dmaengine_prep_slave_sg(chan, sgt->sgl, nents, conf.direction,\n\t\t\t\t      DMA_CTRL_ACK);\n\tif (!txd) {\n\t\tdma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\treturn txd;\n}\n\n \nstatic void ep93xx_spi_dma_finish(struct spi_controller *host,\n\t\t\t\t  enum dma_data_direction dir)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct dma_chan *chan;\n\tstruct sg_table *sgt;\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tchan = espi->dma_rx;\n\t\tsgt = &espi->rx_sgt;\n\t} else {\n\t\tchan = espi->dma_tx;\n\t\tsgt = &espi->tx_sgt;\n\t}\n\n\tdma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\n}\n\nstatic void ep93xx_spi_dma_callback(void *callback_param)\n{\n\tstruct spi_controller *host = callback_param;\n\n\tep93xx_spi_dma_finish(host, DMA_TO_DEVICE);\n\tep93xx_spi_dma_finish(host, DMA_FROM_DEVICE);\n\n\tspi_finalize_current_transfer(host);\n}\n\nstatic int ep93xx_spi_dma_transfer(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tstruct dma_async_tx_descriptor *rxd, *txd;\n\n\trxd = ep93xx_spi_dma_prepare(host, DMA_FROM_DEVICE);\n\tif (IS_ERR(rxd)) {\n\t\tdev_err(&host->dev, \"DMA RX failed: %ld\\n\", PTR_ERR(rxd));\n\t\treturn PTR_ERR(rxd);\n\t}\n\n\ttxd = ep93xx_spi_dma_prepare(host, DMA_TO_DEVICE);\n\tif (IS_ERR(txd)) {\n\t\tep93xx_spi_dma_finish(host, DMA_FROM_DEVICE);\n\t\tdev_err(&host->dev, \"DMA TX failed: %ld\\n\", PTR_ERR(txd));\n\t\treturn PTR_ERR(txd);\n\t}\n\n\t \n\trxd->callback = ep93xx_spi_dma_callback;\n\trxd->callback_param = host;\n\n\t \n\tdmaengine_submit(rxd);\n\tdmaengine_submit(txd);\n\n\tdma_async_issue_pending(espi->dma_rx);\n\tdma_async_issue_pending(espi->dma_tx);\n\n\t \n\treturn 1;\n}\n\nstatic irqreturn_t ep93xx_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = dev_id;\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tu32 val;\n\n\t \n\tif (readl(espi->mmio + SSPIIR) & SSPIIR_RORIS) {\n\t\t \n\t\twritel(0, espi->mmio + SSPICR);\n\t\tdev_warn(&host->dev,\n\t\t\t \"receive overrun, aborting the message\\n\");\n\t\thost->cur_msg->status = -EIO;\n\t} else {\n\t\t \n\t\tif (ep93xx_spi_read_write(host)) {\n\t\t\t \n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tval = readl(espi->mmio + SSPCR1);\n\tval &= ~(SSPCR1_RORIE | SSPCR1_TIE | SSPCR1_RIE);\n\twritel(val, espi->mmio + SSPCR1);\n\n\tspi_finalize_current_transfer(host);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ep93xx_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t   struct spi_device *spi,\n\t\t\t\t   struct spi_transfer *xfer)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tu32 val;\n\tint ret;\n\n\tret = ep93xx_spi_chip_setup(host, spi, xfer);\n\tif (ret) {\n\t\tdev_err(&host->dev, \"failed to setup chip for transfer\\n\");\n\t\treturn ret;\n\t}\n\n\thost->cur_msg->state = xfer;\n\tespi->rx = 0;\n\tespi->tx = 0;\n\n\t \n\tif (espi->dma_rx && xfer->len > SPI_FIFO_SIZE)\n\t\treturn ep93xx_spi_dma_transfer(host);\n\n\t \n\tep93xx_spi_read_write(host);\n\n\tval = readl(espi->mmio + SSPCR1);\n\tval |= (SSPCR1_RORIE | SSPCR1_TIE | SSPCR1_RIE);\n\twritel(val, espi->mmio + SSPCR1);\n\n\t \n\treturn 1;\n}\n\nstatic int ep93xx_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tunsigned long timeout;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(SPI_TIMEOUT);\n\twhile (readl(espi->mmio + SSPSR) & SSPSR_RNE) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(&host->dev,\n\t\t\t\t \"timeout while flushing RX FIFO\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\treadl(espi->mmio + SSPDR);\n\t}\n\n\t \n\tespi->fifo_level = 0;\n\n\treturn 0;\n}\n\nstatic int ep93xx_spi_prepare_hardware(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tu32 val;\n\tint ret;\n\n\tret = clk_prepare_enable(espi->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tval = readl(espi->mmio + SSPCR1);\n\tval |= SSPCR1_SSE;\n\twritel(val, espi->mmio + SSPCR1);\n\n\treturn 0;\n}\n\nstatic int ep93xx_spi_unprepare_hardware(struct spi_controller *host)\n{\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\tu32 val;\n\n\tval = readl(espi->mmio + SSPCR1);\n\tval &= ~SSPCR1_SSE;\n\twritel(val, espi->mmio + SSPCR1);\n\n\tclk_disable_unprepare(espi->clk);\n\n\treturn 0;\n}\n\nstatic bool ep93xx_spi_dma_filter(struct dma_chan *chan, void *filter_param)\n{\n\tif (ep93xx_dma_chan_is_m2p(chan))\n\t\treturn false;\n\n\tchan->private = filter_param;\n\treturn true;\n}\n\nstatic int ep93xx_spi_setup_dma(struct ep93xx_spi *espi)\n{\n\tdma_cap_mask_t mask;\n\tint ret;\n\n\tespi->zeropage = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!espi->zeropage)\n\t\treturn -ENOMEM;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tespi->dma_rx_data.port = EP93XX_DMA_SSP;\n\tespi->dma_rx_data.direction = DMA_DEV_TO_MEM;\n\tespi->dma_rx_data.name = \"ep93xx-spi-rx\";\n\n\tespi->dma_rx = dma_request_channel(mask, ep93xx_spi_dma_filter,\n\t\t\t\t\t   &espi->dma_rx_data);\n\tif (!espi->dma_rx) {\n\t\tret = -ENODEV;\n\t\tgoto fail_free_page;\n\t}\n\n\tespi->dma_tx_data.port = EP93XX_DMA_SSP;\n\tespi->dma_tx_data.direction = DMA_MEM_TO_DEV;\n\tespi->dma_tx_data.name = \"ep93xx-spi-tx\";\n\n\tespi->dma_tx = dma_request_channel(mask, ep93xx_spi_dma_filter,\n\t\t\t\t\t   &espi->dma_tx_data);\n\tif (!espi->dma_tx) {\n\t\tret = -ENODEV;\n\t\tgoto fail_release_rx;\n\t}\n\n\treturn 0;\n\nfail_release_rx:\n\tdma_release_channel(espi->dma_rx);\n\tespi->dma_rx = NULL;\nfail_free_page:\n\tfree_page((unsigned long)espi->zeropage);\n\n\treturn ret;\n}\n\nstatic void ep93xx_spi_release_dma(struct ep93xx_spi *espi)\n{\n\tif (espi->dma_rx) {\n\t\tdma_release_channel(espi->dma_rx);\n\t\tsg_free_table(&espi->rx_sgt);\n\t}\n\tif (espi->dma_tx) {\n\t\tdma_release_channel(espi->dma_tx);\n\t\tsg_free_table(&espi->tx_sgt);\n\t}\n\n\tif (espi->zeropage)\n\t\tfree_page((unsigned long)espi->zeropage);\n}\n\nstatic int ep93xx_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct ep93xx_spi_info *info;\n\tstruct ep93xx_spi *espi;\n\tstruct resource *res;\n\tint irq;\n\tint error;\n\n\tinfo = dev_get_platdata(&pdev->dev);\n\tif (!info) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*espi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->use_gpio_descriptors = true;\n\thost->prepare_transfer_hardware = ep93xx_spi_prepare_hardware;\n\thost->unprepare_transfer_hardware = ep93xx_spi_unprepare_hardware;\n\thost->prepare_message = ep93xx_spi_prepare_message;\n\thost->transfer_one = ep93xx_spi_transfer_one;\n\thost->bus_num = pdev->id;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\n\t \n\thost->num_chipselect = 0;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tespi = spi_controller_get_devdata(host);\n\n\tespi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(espi->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to get spi clock\\n\");\n\t\terror = PTR_ERR(espi->clk);\n\t\tgoto fail_release_host;\n\t}\n\n\t \n\thost->max_speed_hz = clk_get_rate(espi->clk) / 2;\n\thost->min_speed_hz = clk_get_rate(espi->clk) / (254 * 256);\n\n\tespi->mmio = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(espi->mmio)) {\n\t\terror = PTR_ERR(espi->mmio);\n\t\tgoto fail_release_host;\n\t}\n\tespi->sspdr_phys = res->start + SSPDR;\n\n\terror = devm_request_irq(&pdev->dev, irq, ep93xx_spi_interrupt,\n\t\t\t\t0, \"ep93xx-spi\", host);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request irq\\n\");\n\t\tgoto fail_release_host;\n\t}\n\n\tif (info->use_dma && ep93xx_spi_setup_dma(espi))\n\t\tdev_warn(&pdev->dev, \"DMA setup failed. Falling back to PIO\\n\");\n\n\t \n\twritel(0, espi->mmio + SSPCR1);\n\n\terror = devm_spi_register_controller(&pdev->dev, host);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register SPI host\\n\");\n\t\tgoto fail_free_dma;\n\t}\n\n\tdev_info(&pdev->dev, \"EP93xx SPI Controller at 0x%08lx irq %d\\n\",\n\t\t (unsigned long)res->start, irq);\n\n\treturn 0;\n\nfail_free_dma:\n\tep93xx_spi_release_dma(espi);\nfail_release_host:\n\tspi_controller_put(host);\n\n\treturn error;\n}\n\nstatic void ep93xx_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct ep93xx_spi *espi = spi_controller_get_devdata(host);\n\n\tep93xx_spi_release_dma(espi);\n}\n\nstatic struct platform_driver ep93xx_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ep93xx-spi\",\n\t},\n\t.probe\t\t= ep93xx_spi_probe,\n\t.remove_new\t= ep93xx_spi_remove,\n};\nmodule_platform_driver(ep93xx_spi_driver);\n\nMODULE_DESCRIPTION(\"EP93xx SPI Controller driver\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ep93xx-spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}