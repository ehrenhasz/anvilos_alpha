{
  "module_name": "spi-wpcm-fiu.c",
  "hash_id": "d828e86f2a1f785cbd9d4ce8069a7b2fbfcc237771332c4aaee4e7e1071b46ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-wpcm-fiu.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi-mem.h>\n\n#define FIU_CFG\t\t0x00\n#define FIU_BURST_BFG\t0x01\n#define FIU_RESP_CFG\t0x02\n#define FIU_CFBB_PROT\t0x03\n#define FIU_FWIN1_LOW\t0x04\n#define FIU_FWIN1_HIGH\t0x06\n#define FIU_FWIN2_LOW\t0x08\n#define FIU_FWIN2_HIGH\t0x0a\n#define FIU_FWIN3_LOW\t0x0c\n#define FIU_FWIN3_HIGH\t0x0e\n#define FIU_PROT_LOCK\t0x10\n#define FIU_PROT_CLEAR\t0x11\n#define FIU_SPI_FL_CFG\t0x14\n#define FIU_UMA_CODE\t0x16\n#define FIU_UMA_AB0\t0x17\n#define FIU_UMA_AB1\t0x18\n#define FIU_UMA_AB2\t0x19\n#define FIU_UMA_DB0\t0x1a\n#define FIU_UMA_DB1\t0x1b\n#define FIU_UMA_DB2\t0x1c\n#define FIU_UMA_DB3\t0x1d\n#define FIU_UMA_CTS\t0x1e\n#define FIU_UMA_ECTS\t0x1f\n\n#define FIU_BURST_CFG_R16\t3\n\n#define FIU_UMA_CTS_D_SIZE(x)\t(x)\n#define FIU_UMA_CTS_A_SIZE\tBIT(3)\n#define FIU_UMA_CTS_WR\t\tBIT(4)\n#define FIU_UMA_CTS_CS(x)\t((x) << 5)\n#define FIU_UMA_CTS_EXEC_DONE\tBIT(7)\n\n#define SHM_FLASH_SIZE\t0x02\n#define SHM_FLASH_SIZE_STALL_HOST BIT(6)\n\n \n#define UMA_WAIT_ITERATIONS 100\n\n \n#define MAX_MEMORY_SIZE_PER_CS\t(16 << 20)\n#define MAX_MEMORY_SIZE_TOTAL\t(4 * MAX_MEMORY_SIZE_PER_CS)\n\nstruct wpcm_fiu_spi {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n\tvoid __iomem *memory;\n\tsize_t memory_size;\n\tstruct regmap *shm_regmap;\n};\n\nstatic void wpcm_fiu_set_opcode(struct wpcm_fiu_spi *fiu, u8 opcode)\n{\n\twriteb(opcode, fiu->regs + FIU_UMA_CODE);\n}\n\nstatic void wpcm_fiu_set_addr(struct wpcm_fiu_spi *fiu, u32 addr)\n{\n\twriteb((addr >>  0) & 0xff, fiu->regs + FIU_UMA_AB0);\n\twriteb((addr >>  8) & 0xff, fiu->regs + FIU_UMA_AB1);\n\twriteb((addr >> 16) & 0xff, fiu->regs + FIU_UMA_AB2);\n}\n\nstatic void wpcm_fiu_set_data(struct wpcm_fiu_spi *fiu, const u8 *data, unsigned int nbytes)\n{\n\tint i;\n\n\tfor (i = 0; i < nbytes; i++)\n\t\twriteb(data[i], fiu->regs + FIU_UMA_DB0 + i);\n}\n\nstatic void wpcm_fiu_get_data(struct wpcm_fiu_spi *fiu, u8 *data, unsigned int nbytes)\n{\n\tint i;\n\n\tfor (i = 0; i < nbytes; i++)\n\t\tdata[i] = readb(fiu->regs + FIU_UMA_DB0 + i);\n}\n\n \nstatic int wpcm_fiu_do_uma(struct wpcm_fiu_spi *fiu, unsigned int cs,\n\t\t\t   bool use_addr, bool write, int data_bytes)\n{\n\tint i = 0;\n\tu8 cts = FIU_UMA_CTS_EXEC_DONE | FIU_UMA_CTS_CS(cs);\n\n\tif (use_addr)\n\t\tcts |= FIU_UMA_CTS_A_SIZE;\n\tif (write)\n\t\tcts |= FIU_UMA_CTS_WR;\n\tcts |= FIU_UMA_CTS_D_SIZE(data_bytes);\n\n\twriteb(cts, fiu->regs + FIU_UMA_CTS);\n\n\tfor (i = 0; i < UMA_WAIT_ITERATIONS; i++)\n\t\tif (!(readb(fiu->regs + FIU_UMA_CTS) & FIU_UMA_CTS_EXEC_DONE))\n\t\t\treturn 0;\n\n\tdev_info(fiu->dev, \"UMA transfer has not finished in %d iterations\\n\", UMA_WAIT_ITERATIONS);\n\treturn -EIO;\n}\n\nstatic void wpcm_fiu_ects_assert(struct wpcm_fiu_spi *fiu, unsigned int cs)\n{\n\tu8 ects = readb(fiu->regs + FIU_UMA_ECTS);\n\n\tects &= ~BIT(cs);\n\twriteb(ects, fiu->regs + FIU_UMA_ECTS);\n}\n\nstatic void wpcm_fiu_ects_deassert(struct wpcm_fiu_spi *fiu, unsigned int cs)\n{\n\tu8 ects = readb(fiu->regs + FIU_UMA_ECTS);\n\n\tects |= BIT(cs);\n\twriteb(ects, fiu->regs + FIU_UMA_ECTS);\n}\n\nstruct wpcm_fiu_op_shape {\n\tbool (*match)(const struct spi_mem_op *op);\n\tint (*exec)(struct spi_mem *mem, const struct spi_mem_op *op);\n};\n\nstatic bool wpcm_fiu_normal_match(const struct spi_mem_op *op)\n{\n\t\n\tif (op->cmd.opcode == 0x0b)\n\t\treturn false;\n\n\treturn (op->addr.nbytes == 0 || op->addr.nbytes == 3) &&\n\t       op->dummy.nbytes == 0 && op->data.nbytes <= 4;\n}\n\nstatic int wpcm_fiu_normal_exec(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(mem->spi->controller);\n\tint ret;\n\n\twpcm_fiu_set_opcode(fiu, op->cmd.opcode);\n\twpcm_fiu_set_addr(fiu, op->addr.val);\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\twpcm_fiu_set_data(fiu, op->data.buf.out, op->data.nbytes);\n\n\tret = wpcm_fiu_do_uma(fiu, spi_get_chipselect(mem->spi, 0), op->addr.nbytes == 3,\n\t\t\t      op->data.dir == SPI_MEM_DATA_OUT, op->data.nbytes);\n\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\twpcm_fiu_get_data(fiu, op->data.buf.in, op->data.nbytes);\n\n\treturn ret;\n}\n\nstatic bool wpcm_fiu_fast_read_match(const struct spi_mem_op *op)\n{\n\treturn op->cmd.opcode == 0x0b && op->addr.nbytes == 3 &&\n\t       op->dummy.nbytes == 1 &&\n\t       op->data.nbytes >= 1 && op->data.nbytes <= 4 &&\n\t       op->data.dir == SPI_MEM_DATA_IN;\n}\n\nstatic int wpcm_fiu_fast_read_exec(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\treturn -EINVAL;\n}\n\n \nstatic bool wpcm_fiu_4ba_match(const struct spi_mem_op *op)\n{\n\treturn op->addr.nbytes == 4 && op->dummy.nbytes == 0 && op->data.nbytes <= 4;\n}\n\nstatic int wpcm_fiu_4ba_exec(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(mem->spi->controller);\n\tint cs = spi_get_chipselect(mem->spi, 0);\n\n\twpcm_fiu_ects_assert(fiu, cs);\n\n\twpcm_fiu_set_opcode(fiu, op->cmd.opcode);\n\twpcm_fiu_set_addr(fiu, op->addr.val >> 8);\n\twpcm_fiu_do_uma(fiu, cs, true, false, 0);\n\n\twpcm_fiu_set_opcode(fiu, op->addr.val & 0xff);\n\twpcm_fiu_set_addr(fiu, 0);\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\twpcm_fiu_set_data(fiu, op->data.buf.out, op->data.nbytes);\n\twpcm_fiu_do_uma(fiu, cs, false, op->data.dir == SPI_MEM_DATA_OUT, op->data.nbytes);\n\n\twpcm_fiu_ects_deassert(fiu, cs);\n\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\twpcm_fiu_get_data(fiu, op->data.buf.in, op->data.nbytes);\n\n\treturn 0;\n}\n\n \nstatic bool wpcm_fiu_rdid_match(const struct spi_mem_op *op)\n{\n\treturn op->cmd.opcode == 0x9f && op->addr.nbytes == 0 &&\n\t       op->dummy.nbytes == 0 && op->data.nbytes == 6 &&\n\t       op->data.dir == SPI_MEM_DATA_IN;\n}\n\nstatic int wpcm_fiu_rdid_exec(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(mem->spi->controller);\n\tint cs = spi_get_chipselect(mem->spi, 0);\n\n\t \n\twpcm_fiu_set_opcode(fiu, op->cmd.opcode);\n\twpcm_fiu_set_addr(fiu, 0);\n\twpcm_fiu_do_uma(fiu, cs, false, false, 3);\n\twpcm_fiu_get_data(fiu, op->data.buf.in, 3);\n\n\t \n\twpcm_fiu_set_opcode(fiu, op->cmd.opcode);\n\twpcm_fiu_set_addr(fiu, 0);\n\twpcm_fiu_do_uma(fiu, cs, true, false, 3);\n\twpcm_fiu_get_data(fiu, op->data.buf.in + 3, 3);\n\n\treturn 0;\n}\n\n \nstatic bool wpcm_fiu_dummy_match(const struct spi_mem_op *op)\n{\n\t\n\tif (op->cmd.opcode == 0x0b)\n\t\treturn false;\n\n\treturn (op->addr.nbytes == 0 || op->addr.nbytes == 3) &&\n\t       op->dummy.nbytes >= 1 && op->dummy.nbytes <= 5 &&\n\t       op->data.nbytes <= 4;\n}\n\nstatic int wpcm_fiu_dummy_exec(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(mem->spi->controller);\n\tint cs = spi_get_chipselect(mem->spi, 0);\n\n\twpcm_fiu_ects_assert(fiu, cs);\n\n\t \n\twpcm_fiu_set_opcode(fiu, op->cmd.opcode);\n\twpcm_fiu_set_addr(fiu, op->addr.val);\n\twpcm_fiu_do_uma(fiu, cs, op->addr.nbytes != 0, true, op->dummy.nbytes - 1);\n\n\t \n\twpcm_fiu_set_opcode(fiu, 0);\n\twpcm_fiu_set_addr(fiu, 0);\n\twpcm_fiu_do_uma(fiu, cs, false, false, op->data.nbytes);\n\twpcm_fiu_get_data(fiu, op->data.buf.in, op->data.nbytes);\n\n\twpcm_fiu_ects_deassert(fiu, cs);\n\n\treturn 0;\n}\n\nstatic const struct wpcm_fiu_op_shape wpcm_fiu_op_shapes[] = {\n\t{ .match = wpcm_fiu_normal_match, .exec = wpcm_fiu_normal_exec },\n\t{ .match = wpcm_fiu_fast_read_match, .exec = wpcm_fiu_fast_read_exec },\n\t{ .match = wpcm_fiu_4ba_match, .exec = wpcm_fiu_4ba_exec },\n\t{ .match = wpcm_fiu_rdid_match, .exec = wpcm_fiu_rdid_exec },\n\t{ .match = wpcm_fiu_dummy_match, .exec = wpcm_fiu_dummy_exec },\n};\n\nstatic const struct wpcm_fiu_op_shape *wpcm_fiu_find_op_shape(const struct spi_mem_op *op)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wpcm_fiu_op_shapes); i++) {\n\t\tconst struct wpcm_fiu_op_shape *shape = &wpcm_fiu_op_shapes[i];\n\n\t\tif (shape->match(op))\n\t\t\treturn shape;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool wpcm_fiu_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\tif (op->cmd.dtr || op->addr.dtr || op->dummy.dtr || op->data.dtr)\n\t\treturn false;\n\n\tif (op->cmd.buswidth > 1 || op->addr.buswidth > 1 ||\n\t    op->dummy.buswidth > 1 || op->data.buswidth > 1)\n\t\treturn false;\n\n\treturn wpcm_fiu_find_op_shape(op) != NULL;\n}\n\n \nstatic void wpcm_fiu_stall_host(struct wpcm_fiu_spi *fiu, bool stall)\n{\n\tif (fiu->shm_regmap) {\n\t\tint res = regmap_update_bits(fiu->shm_regmap, SHM_FLASH_SIZE,\n\t\t\t\t\t     SHM_FLASH_SIZE_STALL_HOST,\n\t\t\t\t\t     stall ? SHM_FLASH_SIZE_STALL_HOST : 0);\n\t\tif (res)\n\t\t\tdev_warn(fiu->dev, \"Failed to (un)stall host memory accesses: %d\\n\", res);\n\t}\n}\n\nstatic int wpcm_fiu_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(mem->spi->controller);\n\tconst struct wpcm_fiu_op_shape *shape = wpcm_fiu_find_op_shape(op);\n\n\twpcm_fiu_stall_host(fiu, true);\n\n\tif (shape)\n\t\treturn shape->exec(mem, op);\n\n\twpcm_fiu_stall_host(fiu, false);\n\n\treturn -ENOTSUPP;\n}\n\nstatic int wpcm_fiu_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tif (op->data.nbytes > 4)\n\t\top->data.nbytes = 4;\n\n\treturn 0;\n}\n\nstatic int wpcm_fiu_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(desc->mem->spi->controller);\n\tint cs = spi_get_chipselect(desc->mem->spi, 0);\n\n\tif (desc->info.op_tmpl.data.dir != SPI_MEM_DATA_IN)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (desc->info.offset + desc->info.length > MAX_MEMORY_SIZE_PER_CS)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (cs * MAX_MEMORY_SIZE_PER_CS + desc->info.offset + desc->info.length > fiu->memory_size)\n\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic ssize_t wpcm_fiu_direct_read(struct spi_mem_dirmap_desc *desc, u64 offs, size_t len, void *buf)\n{\n\tstruct wpcm_fiu_spi *fiu = spi_controller_get_devdata(desc->mem->spi->controller);\n\tint cs = spi_get_chipselect(desc->mem->spi, 0);\n\n\tif (offs >= MAX_MEMORY_SIZE_PER_CS)\n\t\treturn -ENOTSUPP;\n\n\toffs += cs * MAX_MEMORY_SIZE_PER_CS;\n\n\tif (!fiu->memory || offs >= fiu->memory_size)\n\t\treturn -ENOTSUPP;\n\n\tlen = min_t(size_t, len, fiu->memory_size - offs);\n\tmemcpy_fromio(buf, fiu->memory + offs, len);\n\n\treturn len;\n}\n\nstatic const struct spi_controller_mem_ops wpcm_fiu_mem_ops = {\n\t.adjust_op_size = wpcm_fiu_adjust_op_size,\n\t.supports_op = wpcm_fiu_supports_op,\n\t.exec_op = wpcm_fiu_exec_op,\n\t.dirmap_create = wpcm_fiu_dirmap_create,\n\t.dirmap_read = wpcm_fiu_direct_read,\n};\n\nstatic void wpcm_fiu_hw_init(struct wpcm_fiu_spi *fiu)\n{\n\t \n\twriteb(FIU_BURST_CFG_R16, fiu->regs + FIU_BURST_BFG);\n\twriteb(MAX_MEMORY_SIZE_TOTAL / (512 << 10), fiu->regs + FIU_CFG);\n\twriteb(MAX_MEMORY_SIZE_PER_CS / (512 << 10) | BIT(6), fiu->regs + FIU_SPI_FL_CFG);\n\n\t \n\twriteb(0x0f, fiu->regs + FIU_UMA_ECTS);\n}\n\nstatic int wpcm_fiu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *ctrl;\n\tstruct wpcm_fiu_spi *fiu;\n\tstruct resource *res;\n\n\tctrl = devm_spi_alloc_master(dev, sizeof(*fiu));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tfiu = spi_controller_get_devdata(ctrl);\n\tfiu->dev = dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"control\");\n\tfiu->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(fiu->regs)) {\n\t\tdev_err(dev, \"Failed to map registers\\n\");\n\t\treturn PTR_ERR(fiu->regs);\n\t}\n\n\tfiu->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(fiu->clk))\n\t\treturn PTR_ERR(fiu->clk);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"memory\");\n\tfiu->memory = devm_ioremap_resource(dev, res);\n\tfiu->memory_size = min_t(size_t, resource_size(res), MAX_MEMORY_SIZE_TOTAL);\n\tif (IS_ERR(fiu->memory)) {\n\t\tdev_err(dev, \"Failed to map flash memory window\\n\");\n\t\treturn PTR_ERR(fiu->memory);\n\t}\n\n\tfiu->shm_regmap = syscon_regmap_lookup_by_phandle_optional(dev->of_node, \"nuvoton,shm\");\n\n\twpcm_fiu_hw_init(fiu);\n\n\tctrl->bus_num = -1;\n\tctrl->mem_ops = &wpcm_fiu_mem_ops;\n\tctrl->num_chipselect = 4;\n\tctrl->dev.of_node = dev->of_node;\n\n\t \n\tctrl->min_speed_hz = clk_get_rate(fiu->clk);\n\tctrl->max_speed_hz = clk_get_rate(fiu->clk);\n\n\treturn devm_spi_register_controller(dev, ctrl);\n}\n\nstatic const struct of_device_id wpcm_fiu_dt_ids[] = {\n\t{ .compatible = \"nuvoton,wpcm450-fiu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wpcm_fiu_dt_ids);\n\nstatic struct platform_driver wpcm_fiu_driver = {\n\t.driver = {\n\t\t.name\t= \"wpcm450-fiu\",\n\t\t.bus\t= &platform_bus_type,\n\t\t.of_match_table = wpcm_fiu_dt_ids,\n\t},\n\t.probe      = wpcm_fiu_probe,\n};\nmodule_platform_driver(wpcm_fiu_driver);\n\nMODULE_DESCRIPTION(\"Nuvoton WPCM450 FIU SPI controller driver\");\nMODULE_AUTHOR(\"Jonathan Neusch\u00e4fer <j.neuschaefer@gmx.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}