{
  "module_name": "spi-slave-mt27xx.c",
  "hash_id": "665413a875aa24fc27aa181f744d5532d831401a8caa83ef2bd0f186a83f24e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-slave-mt27xx.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n\n\n#define SPIS_IRQ_EN_REG\t\t0x0\n#define SPIS_IRQ_CLR_REG\t0x4\n#define SPIS_IRQ_ST_REG\t\t0x8\n#define SPIS_IRQ_MASK_REG\t0xc\n#define SPIS_CFG_REG\t\t0x10\n#define SPIS_RX_DATA_REG\t0x14\n#define SPIS_TX_DATA_REG\t0x18\n#define SPIS_RX_DST_REG\t\t0x1c\n#define SPIS_TX_SRC_REG\t\t0x20\n#define SPIS_DMA_CFG_REG\t0x30\n#define SPIS_SOFT_RST_REG\t0x40\n\n \n#define DMA_DONE_EN\t\tBIT(7)\n#define DATA_DONE_EN\t\tBIT(2)\n#define RSTA_DONE_EN\t\tBIT(1)\n#define CMD_INVALID_EN\t\tBIT(0)\n\n \n#define DMA_DONE_ST\t\tBIT(7)\n#define DATA_DONE_ST\t\tBIT(2)\n#define RSTA_DONE_ST\t\tBIT(1)\n#define CMD_INVALID_ST\t\tBIT(0)\n\n \n#define DMA_DONE_MASK\t\tBIT(7)\n#define DATA_DONE_MASK\t\tBIT(2)\n#define RSTA_DONE_MASK\t\tBIT(1)\n#define CMD_INVALID_MASK\tBIT(0)\n\n \n#define SPIS_TX_ENDIAN\t\tBIT(7)\n#define SPIS_RX_ENDIAN\t\tBIT(6)\n#define SPIS_TXMSBF\t\tBIT(5)\n#define SPIS_RXMSBF\t\tBIT(4)\n#define SPIS_CPHA\t\tBIT(3)\n#define SPIS_CPOL\t\tBIT(2)\n#define SPIS_TX_EN\t\tBIT(1)\n#define SPIS_RX_EN\t\tBIT(0)\n\n \n#define TX_DMA_TRIG_EN\t\tBIT(31)\n#define TX_DMA_EN\t\tBIT(30)\n#define RX_DMA_EN\t\tBIT(29)\n#define TX_DMA_LEN\t\t0xfffff\n\n \n#define SPIS_DMA_ADDR_EN\tBIT(1)\n#define SPIS_SOFT_RST\t\tBIT(0)\n\nstruct mtk_spi_slave {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *spi_clk;\n\tstruct completion xfer_done;\n\tstruct spi_transfer *cur_transfer;\n\tbool slave_aborted;\n\tconst struct mtk_spi_compatible *dev_comp;\n};\n\nstruct mtk_spi_compatible {\n\tconst u32 max_fifo_size;\n\tbool must_rx;\n};\n\nstatic const struct mtk_spi_compatible mt2712_compat = {\n\t.max_fifo_size = 512,\n};\nstatic const struct mtk_spi_compatible mt8195_compat = {\n\t.max_fifo_size = 128,\n\t.must_rx = true,\n};\n\nstatic const struct of_device_id mtk_spi_slave_of_match[] = {\n\t{ .compatible = \"mediatek,mt2712-spi-slave\",\n\t  .data = (void *)&mt2712_compat,},\n\t{ .compatible = \"mediatek,mt8195-spi-slave\",\n\t  .data = (void *)&mt8195_compat,},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_spi_slave_of_match);\n\nstatic void mtk_spi_slave_disable_dma(struct mtk_spi_slave *mdata)\n{\n\tu32 reg_val;\n\n\treg_val = readl(mdata->base + SPIS_DMA_CFG_REG);\n\treg_val &= ~RX_DMA_EN;\n\treg_val &= ~TX_DMA_EN;\n\twritel(reg_val, mdata->base + SPIS_DMA_CFG_REG);\n}\n\nstatic void mtk_spi_slave_disable_xfer(struct mtk_spi_slave *mdata)\n{\n\tu32 reg_val;\n\n\treg_val = readl(mdata->base + SPIS_CFG_REG);\n\treg_val &= ~SPIS_TX_EN;\n\treg_val &= ~SPIS_RX_EN;\n\twritel(reg_val, mdata->base + SPIS_CFG_REG);\n}\n\nstatic int mtk_spi_slave_wait_for_completion(struct mtk_spi_slave *mdata)\n{\n\tif (wait_for_completion_interruptible(&mdata->xfer_done) ||\n\t    mdata->slave_aborted) {\n\t\tdev_err(mdata->dev, \"interrupted\\n\");\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_spi_slave_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t\t struct spi_message *msg)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = msg->spi;\n\tbool cpha, cpol;\n\tu32 reg_val;\n\n\tcpha = spi->mode & SPI_CPHA ? 1 : 0;\n\tcpol = spi->mode & SPI_CPOL ? 1 : 0;\n\n\treg_val = readl(mdata->base + SPIS_CFG_REG);\n\tif (cpha)\n\t\treg_val |= SPIS_CPHA;\n\telse\n\t\treg_val &= ~SPIS_CPHA;\n\tif (cpol)\n\t\treg_val |= SPIS_CPOL;\n\telse\n\t\treg_val &= ~SPIS_CPOL;\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\treg_val &= ~(SPIS_TXMSBF | SPIS_RXMSBF);\n\telse\n\t\treg_val |= SPIS_TXMSBF | SPIS_RXMSBF;\n\n\treg_val &= ~SPIS_TX_ENDIAN;\n\treg_val &= ~SPIS_RX_ENDIAN;\n\twritel(reg_val, mdata->base + SPIS_CFG_REG);\n\n\treturn 0;\n}\n\nstatic int mtk_spi_slave_fifo_transfer(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tint reg_val, cnt, remainder, ret;\n\n\twritel(SPIS_SOFT_RST, mdata->base + SPIS_SOFT_RST_REG);\n\n\treg_val = readl(mdata->base + SPIS_CFG_REG);\n\tif (xfer->rx_buf)\n\t\treg_val |= SPIS_RX_EN;\n\tif (xfer->tx_buf)\n\t\treg_val |= SPIS_TX_EN;\n\twritel(reg_val, mdata->base + SPIS_CFG_REG);\n\n\tcnt = xfer->len / 4;\n\tif (xfer->tx_buf)\n\t\tiowrite32_rep(mdata->base + SPIS_TX_DATA_REG,\n\t\t\t      xfer->tx_buf, cnt);\n\n\tremainder = xfer->len % 4;\n\tif (xfer->tx_buf && remainder > 0) {\n\t\treg_val = 0;\n\t\tmemcpy(&reg_val, xfer->tx_buf + cnt * 4, remainder);\n\t\twritel(reg_val, mdata->base + SPIS_TX_DATA_REG);\n\t}\n\n\tret = mtk_spi_slave_wait_for_completion(mdata);\n\tif (ret) {\n\t\tmtk_spi_slave_disable_xfer(mdata);\n\t\twritel(SPIS_SOFT_RST, mdata->base + SPIS_SOFT_RST_REG);\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_spi_slave_dma_transfer(struct spi_controller *ctlr,\n\t\t\t\t      struct spi_device *spi,\n\t\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tstruct device *dev = mdata->dev;\n\tint reg_val, ret;\n\n\twritel(SPIS_SOFT_RST, mdata->base + SPIS_SOFT_RST_REG);\n\n\tif (xfer->tx_buf) {\n\t\t \n\t\tvoid *nonconst_tx = (void *)xfer->tx_buf;\n\n\t\txfer->tx_dma = dma_map_single(dev, nonconst_tx,\n\t\t\t\t\t      xfer->len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->tx_dma)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto disable_transfer;\n\t\t}\n\t}\n\n\tif (xfer->rx_buf) {\n\t\txfer->rx_dma = dma_map_single(dev, xfer->rx_buf,\n\t\t\t\t\t      xfer->len, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->rx_dma)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_txdma;\n\t\t}\n\t}\n\n\twritel(xfer->tx_dma, mdata->base + SPIS_TX_SRC_REG);\n\twritel(xfer->rx_dma, mdata->base + SPIS_RX_DST_REG);\n\n\twritel(SPIS_DMA_ADDR_EN, mdata->base + SPIS_SOFT_RST_REG);\n\n\t \n\treg_val = readl(mdata->base + SPIS_CFG_REG);\n\tif (xfer->tx_buf)\n\t\treg_val |= SPIS_TX_EN;\n\tif (xfer->rx_buf)\n\t\treg_val |= SPIS_RX_EN;\n\twritel(reg_val, mdata->base + SPIS_CFG_REG);\n\n\t \n\treg_val = 0;\n\treg_val |= (xfer->len - 1) & TX_DMA_LEN;\n\twritel(reg_val, mdata->base + SPIS_DMA_CFG_REG);\n\n\treg_val = readl(mdata->base + SPIS_DMA_CFG_REG);\n\tif (xfer->tx_buf)\n\t\treg_val |= TX_DMA_EN;\n\tif (xfer->rx_buf)\n\t\treg_val |= RX_DMA_EN;\n\treg_val |= TX_DMA_TRIG_EN;\n\twritel(reg_val, mdata->base + SPIS_DMA_CFG_REG);\n\n\tret = mtk_spi_slave_wait_for_completion(mdata);\n\tif (ret)\n\t\tgoto unmap_rxdma;\n\n\treturn 0;\n\nunmap_rxdma:\n\tif (xfer->rx_buf)\n\t\tdma_unmap_single(dev, xfer->rx_dma,\n\t\t\t\t xfer->len, DMA_FROM_DEVICE);\n\nunmap_txdma:\n\tif (xfer->tx_buf)\n\t\tdma_unmap_single(dev, xfer->tx_dma,\n\t\t\t\t xfer->len, DMA_TO_DEVICE);\n\ndisable_transfer:\n\tmtk_spi_slave_disable_dma(mdata);\n\tmtk_spi_slave_disable_xfer(mdata);\n\twritel(SPIS_SOFT_RST, mdata->base + SPIS_SOFT_RST_REG);\n\n\treturn ret;\n}\n\nstatic int mtk_spi_slave_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t      struct spi_device *spi,\n\t\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\n\treinit_completion(&mdata->xfer_done);\n\tmdata->slave_aborted = false;\n\tmdata->cur_transfer = xfer;\n\n\tif (xfer->len > mdata->dev_comp->max_fifo_size)\n\t\treturn mtk_spi_slave_dma_transfer(ctlr, spi, xfer);\n\telse\n\t\treturn mtk_spi_slave_fifo_transfer(ctlr, spi, xfer);\n}\n\nstatic int mtk_spi_slave_setup(struct spi_device *spi)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(spi->master);\n\tu32 reg_val;\n\n\treg_val = DMA_DONE_EN | DATA_DONE_EN |\n\t\t  RSTA_DONE_EN | CMD_INVALID_EN;\n\twritel(reg_val, mdata->base + SPIS_IRQ_EN_REG);\n\n\treg_val = DMA_DONE_MASK | DATA_DONE_MASK |\n\t\t  RSTA_DONE_MASK | CMD_INVALID_MASK;\n\twritel(reg_val, mdata->base + SPIS_IRQ_MASK_REG);\n\n\tmtk_spi_slave_disable_dma(mdata);\n\tmtk_spi_slave_disable_xfer(mdata);\n\n\treturn 0;\n}\n\nstatic int mtk_slave_abort(struct spi_controller *ctlr)\n{\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\n\tmdata->slave_aborted = true;\n\tcomplete(&mdata->xfer_done);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mtk_spi_slave_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctlr = dev_id;\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tstruct spi_transfer *trans = mdata->cur_transfer;\n\tu32 int_status, reg_val, cnt, remainder;\n\n\tint_status = readl(mdata->base + SPIS_IRQ_ST_REG);\n\twritel(int_status, mdata->base + SPIS_IRQ_CLR_REG);\n\n\tif (!trans)\n\t\treturn IRQ_NONE;\n\n\tif ((int_status & DMA_DONE_ST) &&\n\t    ((int_status & DATA_DONE_ST) ||\n\t    (int_status & RSTA_DONE_ST))) {\n\t\twritel(SPIS_SOFT_RST, mdata->base + SPIS_SOFT_RST_REG);\n\n\t\tif (trans->tx_buf)\n\t\t\tdma_unmap_single(mdata->dev, trans->tx_dma,\n\t\t\t\t\t trans->len, DMA_TO_DEVICE);\n\t\tif (trans->rx_buf)\n\t\t\tdma_unmap_single(mdata->dev, trans->rx_dma,\n\t\t\t\t\t trans->len, DMA_FROM_DEVICE);\n\n\t\tmtk_spi_slave_disable_dma(mdata);\n\t\tmtk_spi_slave_disable_xfer(mdata);\n\t}\n\n\tif ((!(int_status & DMA_DONE_ST)) &&\n\t    ((int_status & DATA_DONE_ST) ||\n\t    (int_status & RSTA_DONE_ST))) {\n\t\tcnt = trans->len / 4;\n\t\tif (trans->rx_buf)\n\t\t\tioread32_rep(mdata->base + SPIS_RX_DATA_REG,\n\t\t\t\t     trans->rx_buf, cnt);\n\t\tremainder = trans->len % 4;\n\t\tif (trans->rx_buf && remainder > 0) {\n\t\t\treg_val = readl(mdata->base + SPIS_RX_DATA_REG);\n\t\t\tmemcpy(trans->rx_buf + (cnt * 4),\n\t\t\t       &reg_val, remainder);\n\t\t}\n\n\t\tmtk_spi_slave_disable_xfer(mdata);\n\t}\n\n\tif (int_status & CMD_INVALID_ST) {\n\t\tdev_warn(&ctlr->dev, \"cmd invalid\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tmdata->cur_transfer = NULL;\n\tcomplete(&mdata->xfer_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_spi_slave_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct mtk_spi_slave *mdata;\n\tint irq, ret;\n\tconst struct of_device_id *of_id;\n\n\tctlr = spi_alloc_slave(&pdev->dev, sizeof(*mdata));\n\tif (!ctlr) {\n\t\tdev_err(&pdev->dev, \"failed to alloc spi slave\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctlr->auto_runtime_pm = true;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA;\n\tctlr->mode_bits |= SPI_LSB_FIRST;\n\n\tctlr->prepare_message = mtk_spi_slave_prepare_message;\n\tctlr->transfer_one = mtk_spi_slave_transfer_one;\n\tctlr->setup = mtk_spi_slave_setup;\n\tctlr->slave_abort = mtk_slave_abort;\n\n\tof_id = of_match_node(mtk_spi_slave_of_match, pdev->dev.of_node);\n\tif (!of_id) {\n\t\tdev_err(&pdev->dev, \"failed to probe of_node\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_ctlr;\n\t}\n\tmdata = spi_controller_get_devdata(ctlr);\n\tmdata->dev_comp = of_id->data;\n\n\tif (mdata->dev_comp->must_rx)\n\t\tctlr->flags = SPI_CONTROLLER_MUST_RX;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\tinit_completion(&mdata->xfer_done);\n\tmdata->dev = &pdev->dev;\n\tmdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdata->base)) {\n\t\tret = PTR_ERR(mdata->base);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_put_ctlr;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, mtk_spi_slave_interrupt,\n\t\t\t       IRQF_TRIGGER_NONE, dev_name(&pdev->dev), ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register irq (%d)\\n\", ret);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tmdata->spi_clk = devm_clk_get(&pdev->dev, \"spi\");\n\tif (IS_ERR(mdata->spi_clk)) {\n\t\tret = PTR_ERR(mdata->spi_clk);\n\t\tdev_err(&pdev->dev, \"failed to get spi-clk: %d\\n\", ret);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tret = clk_prepare_enable(mdata->spi_clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable spi_clk (%d)\\n\", ret);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register slave controller(%d)\\n\", ret);\n\t\tclk_disable_unprepare(mdata->spi_clk);\n\t\tgoto err_disable_runtime_pm;\n\t}\n\n\tclk_disable_unprepare(mdata->spi_clk);\n\n\treturn 0;\n\nerr_disable_runtime_pm:\n\tpm_runtime_disable(&pdev->dev);\nerr_put_ctlr:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic void mtk_spi_slave_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_spi_slave_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = spi_controller_suspend(ctlr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tclk_disable_unprepare(mdata->spi_clk);\n\n\treturn ret;\n}\n\nstatic int mtk_spi_slave_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = clk_prepare_enable(mdata->spi_clk);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to enable spi_clk (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = spi_controller_resume(ctlr);\n\tif (ret < 0)\n\t\tclk_disable_unprepare(mdata->spi_clk);\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int mtk_spi_slave_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\n\tclk_disable_unprepare(mdata->spi_clk);\n\n\treturn 0;\n}\n\nstatic int mtk_spi_slave_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_spi_slave *mdata = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = clk_prepare_enable(mdata->spi_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable spi_clk (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops mtk_spi_slave_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mtk_spi_slave_suspend, mtk_spi_slave_resume)\n\tSET_RUNTIME_PM_OPS(mtk_spi_slave_runtime_suspend,\n\t\t\t   mtk_spi_slave_runtime_resume, NULL)\n};\n\nstatic struct platform_driver mtk_spi_slave_driver = {\n\t.driver = {\n\t\t.name = \"mtk-spi-slave\",\n\t\t.pm\t= &mtk_spi_slave_pm,\n\t\t.of_match_table = mtk_spi_slave_of_match,\n\t},\n\t.probe = mtk_spi_slave_probe,\n\t.remove_new = mtk_spi_slave_remove,\n};\n\nmodule_platform_driver(mtk_spi_slave_driver);\n\nMODULE_DESCRIPTION(\"MTK SPI Slave Controller driver\");\nMODULE_AUTHOR(\"Leilk Liu <leilk.liu@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:mtk-spi-slave\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}