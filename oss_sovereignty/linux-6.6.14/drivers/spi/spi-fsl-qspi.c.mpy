{
  "module_name": "spi-fsl-qspi.c",
  "hash_id": "59cde6d725e95e7f9ced5fefbfd7e220d15adacb2c57be0c4732b228db64cd44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-qspi.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_qos.h>\n#include <linux/sizes.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define\tSEQID_LUT\t\t\t15\n\n \n#define QUADSPI_MCR\t\t\t0x00\n#define QUADSPI_MCR_RESERVED_MASK\tGENMASK(19, 16)\n#define QUADSPI_MCR_MDIS_MASK\t\tBIT(14)\n#define QUADSPI_MCR_CLR_TXF_MASK\tBIT(11)\n#define QUADSPI_MCR_CLR_RXF_MASK\tBIT(10)\n#define QUADSPI_MCR_DDR_EN_MASK\t\tBIT(7)\n#define QUADSPI_MCR_END_CFG_MASK\tGENMASK(3, 2)\n#define QUADSPI_MCR_SWRSTHD_MASK\tBIT(1)\n#define QUADSPI_MCR_SWRSTSD_MASK\tBIT(0)\n\n#define QUADSPI_IPCR\t\t\t0x08\n#define QUADSPI_IPCR_SEQID(x)\t\t((x) << 24)\n\n#define QUADSPI_FLSHCR\t\t\t0x0c\n#define QUADSPI_FLSHCR_TCSS_MASK\tGENMASK(3, 0)\n#define QUADSPI_FLSHCR_TCSH_MASK\tGENMASK(11, 8)\n#define QUADSPI_FLSHCR_TDH_MASK\t\tGENMASK(17, 16)\n\n#define QUADSPI_BUF0CR                  0x10\n#define QUADSPI_BUF1CR                  0x14\n#define QUADSPI_BUF2CR                  0x18\n#define QUADSPI_BUFXCR_INVALID_MSTRID   0xe\n\n#define QUADSPI_BUF3CR\t\t\t0x1c\n#define QUADSPI_BUF3CR_ALLMST_MASK\tBIT(31)\n#define QUADSPI_BUF3CR_ADATSZ(x)\t((x) << 8)\n#define QUADSPI_BUF3CR_ADATSZ_MASK\tGENMASK(15, 8)\n\n#define QUADSPI_BFGENCR\t\t\t0x20\n#define QUADSPI_BFGENCR_SEQID(x)\t((x) << 12)\n\n#define QUADSPI_BUF0IND\t\t\t0x30\n#define QUADSPI_BUF1IND\t\t\t0x34\n#define QUADSPI_BUF2IND\t\t\t0x38\n#define QUADSPI_SFAR\t\t\t0x100\n\n#define QUADSPI_SMPR\t\t\t0x108\n#define QUADSPI_SMPR_DDRSMP_MASK\tGENMASK(18, 16)\n#define QUADSPI_SMPR_FSDLY_MASK\t\tBIT(6)\n#define QUADSPI_SMPR_FSPHS_MASK\t\tBIT(5)\n#define QUADSPI_SMPR_HSENA_MASK\t\tBIT(0)\n\n#define QUADSPI_RBCT\t\t\t0x110\n#define QUADSPI_RBCT_WMRK_MASK\t\tGENMASK(4, 0)\n#define QUADSPI_RBCT_RXBRD_USEIPS\tBIT(8)\n\n#define QUADSPI_TBDR\t\t\t0x154\n\n#define QUADSPI_SR\t\t\t0x15c\n#define QUADSPI_SR_IP_ACC_MASK\t\tBIT(1)\n#define QUADSPI_SR_AHB_ACC_MASK\t\tBIT(2)\n\n#define QUADSPI_FR\t\t\t0x160\n#define QUADSPI_FR_TFF_MASK\t\tBIT(0)\n\n#define QUADSPI_RSER\t\t\t0x164\n#define QUADSPI_RSER_TFIE\t\tBIT(0)\n\n#define QUADSPI_SPTRCLR\t\t\t0x16c\n#define QUADSPI_SPTRCLR_IPPTRC\t\tBIT(8)\n#define QUADSPI_SPTRCLR_BFPTRC\t\tBIT(0)\n\n#define QUADSPI_SFA1AD\t\t\t0x180\n#define QUADSPI_SFA2AD\t\t\t0x184\n#define QUADSPI_SFB1AD\t\t\t0x188\n#define QUADSPI_SFB2AD\t\t\t0x18c\n#define QUADSPI_RBDR(x)\t\t\t(0x200 + ((x) * 4))\n\n#define QUADSPI_LUTKEY\t\t\t0x300\n#define QUADSPI_LUTKEY_VALUE\t\t0x5AF05AF0\n\n#define QUADSPI_LCKCR\t\t\t0x304\n#define QUADSPI_LCKER_LOCK\t\tBIT(0)\n#define QUADSPI_LCKER_UNLOCK\t\tBIT(1)\n\n#define QUADSPI_LUT_BASE\t\t0x310\n#define QUADSPI_LUT_OFFSET\t\t(SEQID_LUT * 4 * 4)\n#define QUADSPI_LUT_REG(idx) \\\n\t(QUADSPI_LUT_BASE + QUADSPI_LUT_OFFSET + (idx) * 4)\n\n \n#define LUT_STOP\t\t0\n#define LUT_CMD\t\t\t1\n#define LUT_ADDR\t\t2\n#define LUT_DUMMY\t\t3\n#define LUT_MODE\t\t4\n#define LUT_MODE2\t\t5\n#define LUT_MODE4\t\t6\n#define LUT_FSL_READ\t\t7\n#define LUT_FSL_WRITE\t\t8\n#define LUT_JMP_ON_CS\t\t9\n#define LUT_ADDR_DDR\t\t10\n#define LUT_MODE_DDR\t\t11\n#define LUT_MODE2_DDR\t\t12\n#define LUT_MODE4_DDR\t\t13\n#define LUT_FSL_READ_DDR\t14\n#define LUT_FSL_WRITE_DDR\t15\n#define LUT_DATA_LEARN\t\t16\n\n \n#define LUT_PAD(x) (fls(x) - 1)\n\n \n#define LUT_DEF(idx, ins, pad, opr)\t\t\t\t\t\\\n\t((((ins) << 10) | ((pad) << 8) | (opr)) << (((idx) % 2) * 16))\n\n \n#define QUADSPI_QUIRK_SWAP_ENDIAN\tBIT(0)\n\n \n#define QUADSPI_QUIRK_4X_INT_CLK\tBIT(1)\n\n \n#define QUADSPI_QUIRK_TKT253890\t\tBIT(2)\n\n \n#define QUADSPI_QUIRK_TKT245618\t\tBIT(3)\n\n \n#define QUADSPI_QUIRK_BASE_INTERNAL\tBIT(4)\n\n \n#define QUADSPI_QUIRK_USE_TDH_SETTING\tBIT(5)\n\nstruct fsl_qspi_devtype_data {\n\tunsigned int rxfifo;\n\tunsigned int txfifo;\n\tint invalid_mstrid;\n\tunsigned int ahb_buf_size;\n\tunsigned int quirks;\n\tbool little_endian;\n};\n\nstatic const struct fsl_qspi_devtype_data vybrid_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_64,\n\t.invalid_mstrid = QUADSPI_BUFXCR_INVALID_MSTRID,\n\t.ahb_buf_size = SZ_1K,\n\t.quirks = QUADSPI_QUIRK_SWAP_ENDIAN,\n\t.little_endian = true,\n};\n\nstatic const struct fsl_qspi_devtype_data imx6sx_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_512,\n\t.invalid_mstrid = QUADSPI_BUFXCR_INVALID_MSTRID,\n\t.ahb_buf_size = SZ_1K,\n\t.quirks = QUADSPI_QUIRK_4X_INT_CLK | QUADSPI_QUIRK_TKT245618,\n\t.little_endian = true,\n};\n\nstatic const struct fsl_qspi_devtype_data imx7d_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_512,\n\t.invalid_mstrid = QUADSPI_BUFXCR_INVALID_MSTRID,\n\t.ahb_buf_size = SZ_1K,\n\t.quirks = QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK |\n\t\t  QUADSPI_QUIRK_USE_TDH_SETTING,\n\t.little_endian = true,\n};\n\nstatic const struct fsl_qspi_devtype_data imx6ul_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_512,\n\t.invalid_mstrid = QUADSPI_BUFXCR_INVALID_MSTRID,\n\t.ahb_buf_size = SZ_1K,\n\t.quirks = QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK |\n\t\t  QUADSPI_QUIRK_USE_TDH_SETTING,\n\t.little_endian = true,\n};\n\nstatic const struct fsl_qspi_devtype_data ls1021a_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_64,\n\t.invalid_mstrid = QUADSPI_BUFXCR_INVALID_MSTRID,\n\t.ahb_buf_size = SZ_1K,\n\t.quirks = 0,\n\t.little_endian = false,\n};\n\nstatic const struct fsl_qspi_devtype_data ls2080a_data = {\n\t.rxfifo = SZ_128,\n\t.txfifo = SZ_64,\n\t.ahb_buf_size = SZ_1K,\n\t.invalid_mstrid = 0x0,\n\t.quirks = QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_BASE_INTERNAL,\n\t.little_endian = true,\n};\n\nstruct fsl_qspi {\n\tvoid __iomem *iobase;\n\tvoid __iomem *ahb_addr;\n\tu32 memmap_phy;\n\tstruct clk *clk, *clk_en;\n\tstruct device *dev;\n\tstruct completion c;\n\tconst struct fsl_qspi_devtype_data *devtype_data;\n\tstruct mutex lock;\n\tstruct pm_qos_request pm_qos_req;\n\tint selected;\n};\n\nstatic inline int needs_swap_endian(struct fsl_qspi *q)\n{\n\treturn q->devtype_data->quirks & QUADSPI_QUIRK_SWAP_ENDIAN;\n}\n\nstatic inline int needs_4x_clock(struct fsl_qspi *q)\n{\n\treturn q->devtype_data->quirks & QUADSPI_QUIRK_4X_INT_CLK;\n}\n\nstatic inline int needs_fill_txfifo(struct fsl_qspi *q)\n{\n\treturn q->devtype_data->quirks & QUADSPI_QUIRK_TKT253890;\n}\n\nstatic inline int needs_wakeup_wait_mode(struct fsl_qspi *q)\n{\n\treturn q->devtype_data->quirks & QUADSPI_QUIRK_TKT245618;\n}\n\nstatic inline int needs_amba_base_offset(struct fsl_qspi *q)\n{\n\treturn !(q->devtype_data->quirks & QUADSPI_QUIRK_BASE_INTERNAL);\n}\n\nstatic inline int needs_tdh_setting(struct fsl_qspi *q)\n{\n\treturn q->devtype_data->quirks & QUADSPI_QUIRK_USE_TDH_SETTING;\n}\n\n \nstatic inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)\n{\n\treturn needs_swap_endian(q) ? __swab32(a) : a;\n}\n\n \nstatic void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem *addr)\n{\n\tif (q->devtype_data->little_endian)\n\t\tiowrite32(val, addr);\n\telse\n\t\tiowrite32be(val, addr);\n}\n\nstatic u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr)\n{\n\tif (q->devtype_data->little_endian)\n\t\treturn ioread32(addr);\n\n\treturn ioread32be(addr);\n}\n\nstatic irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id)\n{\n\tstruct fsl_qspi *q = dev_id;\n\tu32 reg;\n\n\t \n\treg = qspi_readl(q, q->iobase + QUADSPI_FR);\n\tqspi_writel(q, reg, q->iobase + QUADSPI_FR);\n\n\tif (reg & QUADSPI_FR_TFF_MASK)\n\t\tcomplete(&q->c);\n\n\tdev_dbg(q->dev, \"QUADSPI_FR : 0x%.8x:0x%.8x\\n\", 0, reg);\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsl_qspi_check_buswidth(struct fsl_qspi *q, u8 width)\n{\n\tswitch (width) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic bool fsl_qspi_supports_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct fsl_qspi *q = spi_controller_get_devdata(mem->spi->controller);\n\tint ret;\n\n\tret = fsl_qspi_check_buswidth(q, op->cmd.buswidth);\n\n\tif (op->addr.nbytes)\n\t\tret |= fsl_qspi_check_buswidth(q, op->addr.buswidth);\n\n\tif (op->dummy.nbytes)\n\t\tret |= fsl_qspi_check_buswidth(q, op->dummy.buswidth);\n\n\tif (op->data.nbytes)\n\t\tret |= fsl_qspi_check_buswidth(q, op->data.buswidth);\n\n\tif (ret)\n\t\treturn false;\n\n\t \n\tif (op->addr.nbytes +\n\t   (op->dummy.nbytes ? 1:0) +\n\t   (op->data.nbytes ? 1:0) > 6)\n\t\treturn false;\n\n\t \n\tif (op->dummy.nbytes &&\n\t    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))\n\t\treturn false;\n\n\t \n\tif (op->data.dir == SPI_MEM_DATA_IN &&\n\t    (op->data.nbytes > q->devtype_data->ahb_buf_size ||\n\t     (op->data.nbytes > q->devtype_data->rxfifo - 4 &&\n\t      !IS_ALIGNED(op->data.nbytes, 8))))\n\t\treturn false;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT &&\n\t    op->data.nbytes > q->devtype_data->txfifo)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic void fsl_qspi_prepare_lut(struct fsl_qspi *q,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = q->iobase;\n\tu32 lutval[4] = {};\n\tint lutidx = 1, i;\n\n\tlutval[0] |= LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),\n\t\t\t     op->cmd.opcode);\n\n\t \n\tfor (i = 0; i < op->addr.nbytes; i++) {\n\t\tu8 addrbyte = op->addr.val >> (8 * (op->addr.nbytes - i - 1));\n\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_MODE,\n\t\t\t\t\t      LUT_PAD(op->addr.buswidth),\n\t\t\t\t\t      addrbyte);\n\t\tlutidx++;\n\t}\n\n\tif (op->dummy.nbytes) {\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_DUMMY,\n\t\t\t\t\t      LUT_PAD(op->dummy.buswidth),\n\t\t\t\t\t      op->dummy.nbytes * 8 /\n\t\t\t\t\t      op->dummy.buswidth);\n\t\tlutidx++;\n\t}\n\n\tif (op->data.nbytes) {\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx,\n\t\t\t\t\t      op->data.dir == SPI_MEM_DATA_IN ?\n\t\t\t\t\t      LUT_FSL_READ : LUT_FSL_WRITE,\n\t\t\t\t\t      LUT_PAD(op->data.buswidth),\n\t\t\t\t\t      0);\n\t\tlutidx++;\n\t}\n\n\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_STOP, 0, 0);\n\n\t \n\tqspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\n\tqspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lutval); i++)\n\t\tqspi_writel(q, lutval[i], base + QUADSPI_LUT_REG(i));\n\n\t \n\tqspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\n\tqspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR);\n}\n\nstatic int fsl_qspi_clk_prep_enable(struct fsl_qspi *q)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(q->clk_en);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(q->clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(q->clk_en);\n\t\treturn ret;\n\t}\n\n\tif (needs_wakeup_wait_mode(q))\n\t\tcpu_latency_qos_add_request(&q->pm_qos_req, 0);\n\n\treturn 0;\n}\n\nstatic void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q)\n{\n\tif (needs_wakeup_wait_mode(q))\n\t\tcpu_latency_qos_remove_request(&q->pm_qos_req);\n\n\tclk_disable_unprepare(q->clk);\n\tclk_disable_unprepare(q->clk_en);\n}\n\n \nstatic void fsl_qspi_invalidate(struct fsl_qspi *q)\n{\n\tu32 reg;\n\n\treg = qspi_readl(q, q->iobase + QUADSPI_MCR);\n\treg |= QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK;\n\tqspi_writel(q, reg, q->iobase + QUADSPI_MCR);\n\n\t \n\tudelay(1);\n\n\treg &= ~(QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK);\n\tqspi_writel(q, reg, q->iobase + QUADSPI_MCR);\n}\n\nstatic void fsl_qspi_select_mem(struct fsl_qspi *q, struct spi_device *spi)\n{\n\tunsigned long rate = spi->max_speed_hz;\n\tint ret;\n\n\tif (q->selected == spi_get_chipselect(spi, 0))\n\t\treturn;\n\n\tif (needs_4x_clock(q))\n\t\trate *= 4;\n\n\tfsl_qspi_clk_disable_unprep(q);\n\n\tret = clk_set_rate(q->clk, rate);\n\tif (ret)\n\t\treturn;\n\n\tret = fsl_qspi_clk_prep_enable(q);\n\tif (ret)\n\t\treturn;\n\n\tq->selected = spi_get_chipselect(spi, 0);\n\n\tfsl_qspi_invalidate(q);\n}\n\nstatic void fsl_qspi_read_ahb(struct fsl_qspi *q, const struct spi_mem_op *op)\n{\n\tmemcpy_fromio(op->data.buf.in,\n\t\t      q->ahb_addr + q->selected * q->devtype_data->ahb_buf_size,\n\t\t      op->data.nbytes);\n}\n\nstatic void fsl_qspi_fill_txfifo(struct fsl_qspi *q,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = q->iobase;\n\tint i;\n\tu32 val;\n\n\tfor (i = 0; i < ALIGN_DOWN(op->data.nbytes, 4); i += 4) {\n\t\tmemcpy(&val, op->data.buf.out + i, 4);\n\t\tval = fsl_qspi_endian_xchg(q, val);\n\t\tqspi_writel(q, val, base + QUADSPI_TBDR);\n\t}\n\n\tif (i < op->data.nbytes) {\n\t\tmemcpy(&val, op->data.buf.out + i, op->data.nbytes - i);\n\t\tval = fsl_qspi_endian_xchg(q, val);\n\t\tqspi_writel(q, val, base + QUADSPI_TBDR);\n\t}\n\n\tif (needs_fill_txfifo(q)) {\n\t\tfor (i = op->data.nbytes; i < 16; i += 4)\n\t\t\tqspi_writel(q, 0, base + QUADSPI_TBDR);\n\t}\n}\n\nstatic void fsl_qspi_read_rxfifo(struct fsl_qspi *q,\n\t\t\t  const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = q->iobase;\n\tint i;\n\tu8 *buf = op->data.buf.in;\n\tu32 val;\n\n\tfor (i = 0; i < ALIGN_DOWN(op->data.nbytes, 4); i += 4) {\n\t\tval = qspi_readl(q, base + QUADSPI_RBDR(i / 4));\n\t\tval = fsl_qspi_endian_xchg(q, val);\n\t\tmemcpy(buf + i, &val, 4);\n\t}\n\n\tif (i < op->data.nbytes) {\n\t\tval = qspi_readl(q, base + QUADSPI_RBDR(i / 4));\n\t\tval = fsl_qspi_endian_xchg(q, val);\n\t\tmemcpy(buf + i, &val, op->data.nbytes - i);\n\t}\n}\n\nstatic int fsl_qspi_do_op(struct fsl_qspi *q, const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = q->iobase;\n\tint err = 0;\n\n\tinit_completion(&q->c);\n\n\t \n\tqspi_writel(q, op->data.nbytes | QUADSPI_IPCR_SEQID(SEQID_LUT),\n\t\t    base + QUADSPI_IPCR);\n\n\t \n\tif (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000)))\n\t\terr = -ETIMEDOUT;\n\n\tif (!err && op->data.nbytes && op->data.dir == SPI_MEM_DATA_IN)\n\t\tfsl_qspi_read_rxfifo(q, op);\n\n\treturn err;\n}\n\nstatic int fsl_qspi_readl_poll_tout(struct fsl_qspi *q, void __iomem *base,\n\t\t\t\t    u32 mask, u32 delay_us, u32 timeout_us)\n{\n\tu32 reg;\n\n\tif (!q->devtype_data->little_endian)\n\t\tmask = (u32)cpu_to_be32(mask);\n\n\treturn readl_poll_timeout(base, reg, !(reg & mask), delay_us,\n\t\t\t\t  timeout_us);\n}\n\nstatic int fsl_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct fsl_qspi *q = spi_controller_get_devdata(mem->spi->controller);\n\tvoid __iomem *base = q->iobase;\n\tu32 addr_offset = 0;\n\tint err = 0;\n\tint invalid_mstrid = q->devtype_data->invalid_mstrid;\n\n\tmutex_lock(&q->lock);\n\n\t \n\tfsl_qspi_readl_poll_tout(q, base + QUADSPI_SR, (QUADSPI_SR_IP_ACC_MASK |\n\t\t\t\t QUADSPI_SR_AHB_ACC_MASK), 10, 1000);\n\n\tfsl_qspi_select_mem(q, mem->spi);\n\n\tif (needs_amba_base_offset(q))\n\t\taddr_offset = q->memmap_phy;\n\n\tqspi_writel(q,\n\t\t    q->selected * q->devtype_data->ahb_buf_size + addr_offset,\n\t\t    base + QUADSPI_SFAR);\n\n\tqspi_writel(q, qspi_readl(q, base + QUADSPI_MCR) |\n\t\t    QUADSPI_MCR_CLR_RXF_MASK | QUADSPI_MCR_CLR_TXF_MASK,\n\t\t    base + QUADSPI_MCR);\n\n\tqspi_writel(q, QUADSPI_SPTRCLR_BFPTRC | QUADSPI_SPTRCLR_IPPTRC,\n\t\t    base + QUADSPI_SPTRCLR);\n\n\tqspi_writel(q, invalid_mstrid, base + QUADSPI_BUF0CR);\n\tqspi_writel(q, invalid_mstrid, base + QUADSPI_BUF1CR);\n\tqspi_writel(q, invalid_mstrid, base + QUADSPI_BUF2CR);\n\n\tfsl_qspi_prepare_lut(q, op);\n\n\t \n\tif (op->data.nbytes > (q->devtype_data->rxfifo - 4) &&\n\t    op->data.dir == SPI_MEM_DATA_IN) {\n\t\tfsl_qspi_read_ahb(q, op);\n\t} else {\n\t\tqspi_writel(q, QUADSPI_RBCT_WMRK_MASK |\n\t\t\t    QUADSPI_RBCT_RXBRD_USEIPS, base + QUADSPI_RBCT);\n\n\t\tif (op->data.nbytes && op->data.dir == SPI_MEM_DATA_OUT)\n\t\t\tfsl_qspi_fill_txfifo(q, op);\n\n\t\terr = fsl_qspi_do_op(q, op);\n\t}\n\n\t \n\tfsl_qspi_invalidate(q);\n\n\tmutex_unlock(&q->lock);\n\n\treturn err;\n}\n\nstatic int fsl_qspi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct fsl_qspi *q = spi_controller_get_devdata(mem->spi->controller);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\tif (op->data.nbytes > q->devtype_data->txfifo)\n\t\t\top->data.nbytes = q->devtype_data->txfifo;\n\t} else {\n\t\tif (op->data.nbytes > q->devtype_data->ahb_buf_size)\n\t\t\top->data.nbytes = q->devtype_data->ahb_buf_size;\n\t\telse if (op->data.nbytes > (q->devtype_data->rxfifo - 4))\n\t\t\top->data.nbytes = ALIGN_DOWN(op->data.nbytes, 8);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_qspi_default_setup(struct fsl_qspi *q)\n{\n\tvoid __iomem *base = q->iobase;\n\tu32 reg, addr_offset = 0;\n\tint ret;\n\n\t \n\tfsl_qspi_clk_disable_unprep(q);\n\n\t \n\tret = clk_set_rate(q->clk, 66000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fsl_qspi_clk_prep_enable(q);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tqspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK | QUADSPI_MCR_SWRSTHD_MASK,\n\t\t    base + QUADSPI_MCR);\n\tudelay(1);\n\n\t \n\tqspi_writel(q, QUADSPI_MCR_MDIS_MASK | QUADSPI_MCR_RESERVED_MASK,\n\t\t    base + QUADSPI_MCR);\n\n\t \n\tif (needs_tdh_setting(q))\n\t\tqspi_writel(q, qspi_readl(q, base + QUADSPI_FLSHCR) &\n\t\t\t    ~QUADSPI_FLSHCR_TDH_MASK,\n\t\t\t    base + QUADSPI_FLSHCR);\n\n\treg = qspi_readl(q, base + QUADSPI_SMPR);\n\tqspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK\n\t\t\t| QUADSPI_SMPR_FSPHS_MASK\n\t\t\t| QUADSPI_SMPR_HSENA_MASK\n\t\t\t| QUADSPI_SMPR_DDRSMP_MASK), base + QUADSPI_SMPR);\n\n\t \n\tqspi_writel(q, 0, base + QUADSPI_BUF0IND);\n\tqspi_writel(q, 0, base + QUADSPI_BUF1IND);\n\tqspi_writel(q, 0, base + QUADSPI_BUF2IND);\n\n\tqspi_writel(q, QUADSPI_BFGENCR_SEQID(SEQID_LUT),\n\t\t    q->iobase + QUADSPI_BFGENCR);\n\tqspi_writel(q, QUADSPI_RBCT_WMRK_MASK, base + QUADSPI_RBCT);\n\tqspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |\n\t\t    QUADSPI_BUF3CR_ADATSZ(q->devtype_data->ahb_buf_size / 8),\n\t\t    base + QUADSPI_BUF3CR);\n\n\tif (needs_amba_base_offset(q))\n\t\taddr_offset = q->memmap_phy;\n\n\t \n\tqspi_writel(q, q->devtype_data->ahb_buf_size + addr_offset,\n\t\t    base + QUADSPI_SFA1AD);\n\tqspi_writel(q, q->devtype_data->ahb_buf_size * 2 + addr_offset,\n\t\t    base + QUADSPI_SFA2AD);\n\tqspi_writel(q, q->devtype_data->ahb_buf_size * 3 + addr_offset,\n\t\t    base + QUADSPI_SFB1AD);\n\tqspi_writel(q, q->devtype_data->ahb_buf_size * 4 + addr_offset,\n\t\t    base + QUADSPI_SFB2AD);\n\n\tq->selected = -1;\n\n\t \n\tqspi_writel(q, QUADSPI_MCR_RESERVED_MASK | QUADSPI_MCR_END_CFG_MASK,\n\t\t    base + QUADSPI_MCR);\n\n\t \n\tqspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);\n\n\t \n\tqspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);\n\n\treturn 0;\n}\n\nstatic const char *fsl_qspi_get_name(struct spi_mem *mem)\n{\n\tstruct fsl_qspi *q = spi_controller_get_devdata(mem->spi->controller);\n\tstruct device *dev = &mem->spi->dev;\n\tconst char *name;\n\n\t \n\tif (of_get_available_child_count(q->dev->of_node) == 1)\n\t\treturn dev_name(q->dev);\n\n\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t      \"%s-%d\", dev_name(q->dev),\n\t\t\t      spi_get_chipselect(mem->spi, 0));\n\n\tif (!name) {\n\t\tdev_err(dev, \"failed to get memory for custom flash name\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn name;\n}\n\nstatic const struct spi_controller_mem_ops fsl_qspi_mem_ops = {\n\t.adjust_op_size = fsl_qspi_adjust_op_size,\n\t.supports_op = fsl_qspi_supports_op,\n\t.exec_op = fsl_qspi_exec_op,\n\t.get_name = fsl_qspi_get_name,\n};\n\nstatic int fsl_qspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *res;\n\tstruct fsl_qspi *q;\n\tint ret;\n\n\tctlr = spi_alloc_host(&pdev->dev, sizeof(*q));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tctlr->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD |\n\t\t\t  SPI_TX_DUAL | SPI_TX_QUAD;\n\n\tq = spi_controller_get_devdata(ctlr);\n\tq->dev = dev;\n\tq->devtype_data = of_device_get_match_data(dev);\n\tif (!q->devtype_data) {\n\t\tret = -ENODEV;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tplatform_set_drvdata(pdev, q);\n\n\t \n\tq->iobase = devm_platform_ioremap_resource_byname(pdev, \"QuadSPI\");\n\tif (IS_ERR(q->iobase)) {\n\t\tret = PTR_ERR(q->iobase);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\"QuadSPI-memory\");\n\tif (!res) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_ctrl;\n\t}\n\tq->memmap_phy = res->start;\n\t \n\tq->ahb_addr = devm_ioremap(dev, q->memmap_phy,\n\t\t\t\t   (q->devtype_data->ahb_buf_size * 4));\n\tif (!q->ahb_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_ctrl;\n\t}\n\n\t \n\tq->clk_en = devm_clk_get(dev, \"qspi_en\");\n\tif (IS_ERR(q->clk_en)) {\n\t\tret = PTR_ERR(q->clk_en);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tq->clk = devm_clk_get(dev, \"qspi\");\n\tif (IS_ERR(q->clk)) {\n\t\tret = PTR_ERR(q->clk);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tret = fsl_qspi_clk_prep_enable(q);\n\tif (ret) {\n\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\tgoto err_put_ctrl;\n\t}\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_disable_clk;\n\n\tret = devm_request_irq(dev, ret,\n\t\t\tfsl_qspi_irq_handler, 0, pdev->name, q);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq: %d\\n\", ret);\n\t\tgoto err_disable_clk;\n\t}\n\n\tmutex_init(&q->lock);\n\n\tctlr->bus_num = -1;\n\tctlr->num_chipselect = 4;\n\tctlr->mem_ops = &fsl_qspi_mem_ops;\n\n\tfsl_qspi_default_setup(q);\n\n\tctlr->dev.of_node = np;\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret)\n\t\tgoto err_destroy_mutex;\n\n\treturn 0;\n\nerr_destroy_mutex:\n\tmutex_destroy(&q->lock);\n\nerr_disable_clk:\n\tfsl_qspi_clk_disable_unprep(q);\n\nerr_put_ctrl:\n\tspi_controller_put(ctlr);\n\n\tdev_err(dev, \"Freescale QuadSPI probe failed\\n\");\n\treturn ret;\n}\n\nstatic void fsl_qspi_remove(struct platform_device *pdev)\n{\n\tstruct fsl_qspi *q = platform_get_drvdata(pdev);\n\n\t \n\tqspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);\n\tqspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);\n\n\tfsl_qspi_clk_disable_unprep(q);\n\n\tmutex_destroy(&q->lock);\n}\n\nstatic int fsl_qspi_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int fsl_qspi_resume(struct device *dev)\n{\n\tstruct fsl_qspi *q = dev_get_drvdata(dev);\n\n\tfsl_qspi_default_setup(q);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsl_qspi_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-qspi\", .data = &vybrid_data, },\n\t{ .compatible = \"fsl,imx6sx-qspi\", .data = &imx6sx_data, },\n\t{ .compatible = \"fsl,imx7d-qspi\", .data = &imx7d_data, },\n\t{ .compatible = \"fsl,imx6ul-qspi\", .data = &imx6ul_data, },\n\t{ .compatible = \"fsl,ls1021a-qspi\", .data = &ls1021a_data, },\n\t{ .compatible = \"fsl,ls2080a-qspi\", .data = &ls2080a_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);\n\nstatic const struct dev_pm_ops fsl_qspi_pm_ops = {\n\t.suspend\t= fsl_qspi_suspend,\n\t.resume\t\t= fsl_qspi_resume,\n};\n\nstatic struct platform_driver fsl_qspi_driver = {\n\t.driver = {\n\t\t.name\t= \"fsl-quadspi\",\n\t\t.of_match_table = fsl_qspi_dt_ids,\n\t\t.pm =   &fsl_qspi_pm_ops,\n\t},\n\t.probe          = fsl_qspi_probe,\n\t.remove_new\t= fsl_qspi_remove,\n};\nmodule_platform_driver(fsl_qspi_driver);\n\nMODULE_DESCRIPTION(\"Freescale QuadSPI Controller Driver\");\nMODULE_AUTHOR(\"Freescale Semiconductor Inc.\");\nMODULE_AUTHOR(\"Boris Brezillon <bbrezillon@kernel.org>\");\nMODULE_AUTHOR(\"Frieder Schrempf <frieder.schrempf@kontron.de>\");\nMODULE_AUTHOR(\"Yogesh Gaur <yogeshnarayan.gaur@nxp.com>\");\nMODULE_AUTHOR(\"Suresh Gupta <suresh.gupta@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}