{
  "module_name": "spi-uniphier.c",
  "hash_id": "1945f5e80c57cb73c7ea388dbb5b1dca1309eaaad4bbafec3bbca68147d13e83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-uniphier.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n#define SSI_TIMEOUT_MS\t\t2000\n#define SSI_POLL_TIMEOUT_US\t200\n#define SSI_MAX_CLK_DIVIDER\t254\n#define SSI_MIN_CLK_DIVIDER\t4\n\nstruct uniphier_spi_priv {\n\tvoid __iomem *base;\n\tdma_addr_t base_dma_addr;\n\tstruct clk *clk;\n\tstruct spi_master *master;\n\tstruct completion xfer_done;\n\n\tint error;\n\tunsigned int tx_bytes;\n\tunsigned int rx_bytes;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tatomic_t dma_busy;\n\n\tbool is_save_param;\n\tu8 bits_per_word;\n\tu16 mode;\n\tu32 speed_hz;\n};\n\n#define SSI_CTL\t\t\t0x00\n#define   SSI_CTL_EN\t\tBIT(0)\n\n#define SSI_CKS\t\t\t0x04\n#define   SSI_CKS_CKRAT_MASK\tGENMASK(7, 0)\n#define   SSI_CKS_CKPHS\t\tBIT(14)\n#define   SSI_CKS_CKINIT\tBIT(13)\n#define   SSI_CKS_CKDLY\t\tBIT(12)\n\n#define SSI_TXWDS\t\t0x08\n#define   SSI_TXWDS_WDLEN_MASK\tGENMASK(13, 8)\n#define   SSI_TXWDS_TDTF_MASK\tGENMASK(7, 6)\n#define   SSI_TXWDS_DTLEN_MASK\tGENMASK(5, 0)\n\n#define SSI_RXWDS\t\t0x0c\n#define   SSI_RXWDS_DTLEN_MASK\tGENMASK(5, 0)\n\n#define SSI_FPS\t\t\t0x10\n#define   SSI_FPS_FSPOL\t\tBIT(15)\n#define   SSI_FPS_FSTRT\t\tBIT(14)\n\n#define SSI_SR\t\t\t0x14\n#define   SSI_SR_BUSY\t\tBIT(7)\n#define   SSI_SR_RNE\t\tBIT(0)\n\n#define SSI_IE\t\t\t0x18\n#define   SSI_IE_TCIE\t\tBIT(4)\n#define   SSI_IE_RCIE\t\tBIT(3)\n#define   SSI_IE_TXRE\t\tBIT(2)\n#define   SSI_IE_RXRE\t\tBIT(1)\n#define   SSI_IE_RORIE\t\tBIT(0)\n#define   SSI_IE_ALL_MASK\tGENMASK(4, 0)\n\n#define SSI_IS\t\t\t0x1c\n#define   SSI_IS_RXRS\t\tBIT(9)\n#define   SSI_IS_RCID\t\tBIT(3)\n#define   SSI_IS_RORID\t\tBIT(0)\n\n#define SSI_IC\t\t\t0x1c\n#define   SSI_IC_TCIC\t\tBIT(4)\n#define   SSI_IC_RCIC\t\tBIT(3)\n#define   SSI_IC_RORIC\t\tBIT(0)\n\n#define SSI_FC\t\t\t0x20\n#define   SSI_FC_TXFFL\t\tBIT(12)\n#define   SSI_FC_TXFTH_MASK\tGENMASK(11, 8)\n#define   SSI_FC_RXFFL\t\tBIT(4)\n#define   SSI_FC_RXFTH_MASK\tGENMASK(3, 0)\n\n#define SSI_TXDR\t\t0x24\n#define SSI_RXDR\t\t0x24\n\n#define SSI_FIFO_DEPTH\t\t8U\n#define SSI_FIFO_BURST_NUM\t1\n\n#define SSI_DMA_RX_BUSY\t\tBIT(1)\n#define SSI_DMA_TX_BUSY\t\tBIT(0)\n\nstatic inline unsigned int bytes_per_word(unsigned int bits)\n{\n\treturn bits <= 8 ? 1 : (bits <= 16 ? 2 : 4);\n}\n\nstatic inline void uniphier_spi_irq_enable(struct uniphier_spi_priv *priv,\n\t\t\t\t\t   u32 mask)\n{\n\tu32 val;\n\n\tval = readl(priv->base + SSI_IE);\n\tval |= mask;\n\twritel(val, priv->base + SSI_IE);\n}\n\nstatic inline void uniphier_spi_irq_disable(struct uniphier_spi_priv *priv,\n\t\t\t\t\t    u32 mask)\n{\n\tu32 val;\n\n\tval = readl(priv->base + SSI_IE);\n\tval &= ~mask;\n\twritel(val, priv->base + SSI_IE);\n}\n\nstatic void uniphier_spi_set_mode(struct spi_device *spi)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(spi->master);\n\tu32 val1, val2;\n\n\t \n\tswitch (spi->mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\t\t \n\t\tval1 = SSI_CKS_CKPHS | SSI_CKS_CKDLY;\n\t\tval2 = 0;\n\t\tbreak;\n\tcase SPI_MODE_1:\n\t\t \n\t\tval1 = 0;\n\t\tval2 = SSI_FPS_FSTRT;\n\t\tbreak;\n\tcase SPI_MODE_2:\n\t\t \n\t\tval1 = SSI_CKS_CKINIT | SSI_CKS_CKDLY;\n\t\tval2 = SSI_FPS_FSTRT;\n\t\tbreak;\n\tcase SPI_MODE_3:\n\t\t \n\t\tval1 = SSI_CKS_CKPHS | SSI_CKS_CKINIT;\n\t\tval2 = 0;\n\t\tbreak;\n\t}\n\n\tif (!(spi->mode & SPI_CS_HIGH))\n\t\tval2 |= SSI_FPS_FSPOL;\n\n\twritel(val1, priv->base + SSI_CKS);\n\twritel(val2, priv->base + SSI_FPS);\n\n\tval1 = 0;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tval1 |= FIELD_PREP(SSI_TXWDS_TDTF_MASK, 1);\n\twritel(val1, priv->base + SSI_TXWDS);\n\twritel(val1, priv->base + SSI_RXWDS);\n}\n\nstatic void uniphier_spi_set_transfer_size(struct spi_device *spi, int size)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(spi->master);\n\tu32 val;\n\n\tval = readl(priv->base + SSI_TXWDS);\n\tval &= ~(SSI_TXWDS_WDLEN_MASK | SSI_TXWDS_DTLEN_MASK);\n\tval |= FIELD_PREP(SSI_TXWDS_WDLEN_MASK, size);\n\tval |= FIELD_PREP(SSI_TXWDS_DTLEN_MASK, size);\n\twritel(val, priv->base + SSI_TXWDS);\n\n\tval = readl(priv->base + SSI_RXWDS);\n\tval &= ~SSI_RXWDS_DTLEN_MASK;\n\tval |= FIELD_PREP(SSI_RXWDS_DTLEN_MASK, size);\n\twritel(val, priv->base + SSI_RXWDS);\n}\n\nstatic void uniphier_spi_set_baudrate(struct spi_device *spi,\n\t\t\t\t      unsigned int speed)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(spi->master);\n\tu32 val, ckdiv;\n\n\t \n\tckdiv = DIV_ROUND_UP(clk_get_rate(priv->clk), speed);\n\tckdiv = round_up(ckdiv, 2);\n\n\tval = readl(priv->base + SSI_CKS);\n\tval &= ~SSI_CKS_CKRAT_MASK;\n\tval |= ckdiv & SSI_CKS_CKRAT_MASK;\n\twritel(val, priv->base + SSI_CKS);\n}\n\nstatic void uniphier_spi_setup_transfer(struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(spi->master);\n\tu32 val;\n\n\tpriv->error = 0;\n\tpriv->tx_buf = t->tx_buf;\n\tpriv->rx_buf = t->rx_buf;\n\tpriv->tx_bytes = priv->rx_bytes = t->len;\n\n\tif (!priv->is_save_param || priv->mode != spi->mode) {\n\t\tuniphier_spi_set_mode(spi);\n\t\tpriv->mode = spi->mode;\n\t\tpriv->is_save_param = false;\n\t}\n\n\tif (!priv->is_save_param || priv->bits_per_word != t->bits_per_word) {\n\t\tuniphier_spi_set_transfer_size(spi, t->bits_per_word);\n\t\tpriv->bits_per_word = t->bits_per_word;\n\t}\n\n\tif (!priv->is_save_param || priv->speed_hz != t->speed_hz) {\n\t\tuniphier_spi_set_baudrate(spi, t->speed_hz);\n\t\tpriv->speed_hz = t->speed_hz;\n\t}\n\n\tpriv->is_save_param = true;\n\n\t \n\tval = SSI_FC_TXFFL | SSI_FC_RXFFL;\n\twritel(val, priv->base + SSI_FC);\n}\n\nstatic void uniphier_spi_send(struct uniphier_spi_priv *priv)\n{\n\tint wsize;\n\tu32 val = 0;\n\n\twsize = min(bytes_per_word(priv->bits_per_word), priv->tx_bytes);\n\tpriv->tx_bytes -= wsize;\n\n\tif (priv->tx_buf) {\n\t\tswitch (wsize) {\n\t\tcase 1:\n\t\t\tval = *priv->tx_buf;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = get_unaligned_le16(priv->tx_buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = get_unaligned_le32(priv->tx_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->tx_buf += wsize;\n\t}\n\n\twritel(val, priv->base + SSI_TXDR);\n}\n\nstatic void uniphier_spi_recv(struct uniphier_spi_priv *priv)\n{\n\tint rsize;\n\tu32 val;\n\n\trsize = min(bytes_per_word(priv->bits_per_word), priv->rx_bytes);\n\tpriv->rx_bytes -= rsize;\n\n\tval = readl(priv->base + SSI_RXDR);\n\n\tif (priv->rx_buf) {\n\t\tswitch (rsize) {\n\t\tcase 1:\n\t\t\t*priv->rx_buf = val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tput_unaligned_le16(val, priv->rx_buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tput_unaligned_le32(val, priv->rx_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rx_buf += rsize;\n\t}\n}\n\nstatic void uniphier_spi_set_fifo_threshold(struct uniphier_spi_priv *priv,\n\t\t\t\t\t    unsigned int threshold)\n{\n\tu32 val;\n\n\tval = readl(priv->base + SSI_FC);\n\tval &= ~(SSI_FC_TXFTH_MASK | SSI_FC_RXFTH_MASK);\n\tval |= FIELD_PREP(SSI_FC_TXFTH_MASK, SSI_FIFO_DEPTH - threshold);\n\tval |= FIELD_PREP(SSI_FC_RXFTH_MASK, threshold);\n\twritel(val, priv->base + SSI_FC);\n}\n\nstatic void uniphier_spi_fill_tx_fifo(struct uniphier_spi_priv *priv)\n{\n\tunsigned int fifo_threshold, fill_words;\n\tunsigned int bpw = bytes_per_word(priv->bits_per_word);\n\n\tfifo_threshold = DIV_ROUND_UP(priv->rx_bytes, bpw);\n\tfifo_threshold = min(fifo_threshold, SSI_FIFO_DEPTH);\n\n\tuniphier_spi_set_fifo_threshold(priv, fifo_threshold);\n\n\tfill_words = fifo_threshold -\n\t\tDIV_ROUND_UP(priv->rx_bytes - priv->tx_bytes, bpw);\n\n\twhile (fill_words--)\n\t\tuniphier_spi_send(priv);\n}\n\nstatic void uniphier_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(spi->master);\n\tu32 val;\n\n\tval = readl(priv->base + SSI_FPS);\n\n\tif (enable)\n\t\tval |= SSI_FPS_FSPOL;\n\telse\n\t\tval &= ~SSI_FPS_FSPOL;\n\n\twritel(val, priv->base + SSI_FPS);\n}\n\nstatic bool uniphier_spi_can_dma(struct spi_master *master,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tunsigned int bpw = bytes_per_word(priv->bits_per_word);\n\n\tif ((!master->dma_tx && !master->dma_rx)\n\t    || (!master->dma_tx && t->tx_buf)\n\t    || (!master->dma_rx && t->rx_buf))\n\t\treturn false;\n\n\treturn DIV_ROUND_UP(t->len, bpw) > SSI_FIFO_DEPTH;\n}\n\nstatic void uniphier_spi_dma_rxcb(void *data)\n{\n\tstruct spi_master *master = data;\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tint state = atomic_fetch_andnot(SSI_DMA_RX_BUSY, &priv->dma_busy);\n\n\tuniphier_spi_irq_disable(priv, SSI_IE_RXRE);\n\n\tif (!(state & SSI_DMA_TX_BUSY))\n\t\tspi_finalize_current_transfer(master);\n}\n\nstatic void uniphier_spi_dma_txcb(void *data)\n{\n\tstruct spi_master *master = data;\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tint state = atomic_fetch_andnot(SSI_DMA_TX_BUSY, &priv->dma_busy);\n\n\tuniphier_spi_irq_disable(priv, SSI_IE_TXRE);\n\n\tif (!(state & SSI_DMA_RX_BUSY))\n\t\tspi_finalize_current_transfer(master);\n}\n\nstatic int uniphier_spi_transfer_one_dma(struct spi_master *master,\n\t\t\t\t\t struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tstruct dma_async_tx_descriptor *rxdesc = NULL, *txdesc = NULL;\n\tint buswidth;\n\n\tatomic_set(&priv->dma_busy, 0);\n\n\tuniphier_spi_set_fifo_threshold(priv, SSI_FIFO_BURST_NUM);\n\n\tif (priv->bits_per_word <= 8)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\telse if (priv->bits_per_word <= 16)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tif (priv->rx_buf) {\n\t\tstruct dma_slave_config rxconf = {\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_addr = priv->base_dma_addr + SSI_RXDR,\n\t\t\t.src_addr_width = buswidth,\n\t\t\t.src_maxburst = SSI_FIFO_BURST_NUM,\n\t\t};\n\n\t\tdmaengine_slave_config(master->dma_rx, &rxconf);\n\n\t\trxdesc = dmaengine_prep_slave_sg(\n\t\t\tmaster->dma_rx,\n\t\t\tt->rx_sg.sgl, t->rx_sg.nents,\n\t\t\tDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!rxdesc)\n\t\t\tgoto out_err_prep;\n\n\t\trxdesc->callback = uniphier_spi_dma_rxcb;\n\t\trxdesc->callback_param = master;\n\n\t\tuniphier_spi_irq_enable(priv, SSI_IE_RXRE);\n\t\tatomic_or(SSI_DMA_RX_BUSY, &priv->dma_busy);\n\n\t\tdmaengine_submit(rxdesc);\n\t\tdma_async_issue_pending(master->dma_rx);\n\t}\n\n\tif (priv->tx_buf) {\n\t\tstruct dma_slave_config txconf = {\n\t\t\t.direction = DMA_MEM_TO_DEV,\n\t\t\t.dst_addr = priv->base_dma_addr + SSI_TXDR,\n\t\t\t.dst_addr_width = buswidth,\n\t\t\t.dst_maxburst = SSI_FIFO_BURST_NUM,\n\t\t};\n\n\t\tdmaengine_slave_config(master->dma_tx, &txconf);\n\n\t\ttxdesc = dmaengine_prep_slave_sg(\n\t\t\tmaster->dma_tx,\n\t\t\tt->tx_sg.sgl, t->tx_sg.nents,\n\t\t\tDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!txdesc)\n\t\t\tgoto out_err_prep;\n\n\t\ttxdesc->callback = uniphier_spi_dma_txcb;\n\t\ttxdesc->callback_param = master;\n\n\t\tuniphier_spi_irq_enable(priv, SSI_IE_TXRE);\n\t\tatomic_or(SSI_DMA_TX_BUSY, &priv->dma_busy);\n\n\t\tdmaengine_submit(txdesc);\n\t\tdma_async_issue_pending(master->dma_tx);\n\t}\n\n\t \n\treturn (priv->tx_buf || priv->rx_buf);\n\nout_err_prep:\n\tif (rxdesc)\n\t\tdmaengine_terminate_sync(master->dma_rx);\n\n\treturn -EINVAL;\n}\n\nstatic int uniphier_spi_transfer_one_irq(struct spi_master *master,\n\t\t\t\t\t struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tstruct device *dev = master->dev.parent;\n\tunsigned long time_left;\n\n\treinit_completion(&priv->xfer_done);\n\n\tuniphier_spi_fill_tx_fifo(priv);\n\n\tuniphier_spi_irq_enable(priv, SSI_IE_RCIE | SSI_IE_RORIE);\n\n\ttime_left = wait_for_completion_timeout(&priv->xfer_done,\n\t\t\t\t\tmsecs_to_jiffies(SSI_TIMEOUT_MS));\n\n\tuniphier_spi_irq_disable(priv, SSI_IE_RCIE | SSI_IE_RORIE);\n\n\tif (!time_left) {\n\t\tdev_err(dev, \"transfer timeout.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn priv->error;\n}\n\nstatic int uniphier_spi_transfer_one_poll(struct spi_master *master,\n\t\t\t\t\t  struct spi_device *spi,\n\t\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tint loop = SSI_POLL_TIMEOUT_US * 10;\n\n\twhile (priv->tx_bytes) {\n\t\tuniphier_spi_fill_tx_fifo(priv);\n\n\t\twhile ((priv->rx_bytes - priv->tx_bytes) > 0) {\n\t\t\twhile (!(readl(priv->base + SSI_SR) & SSI_SR_RNE)\n\t\t\t\t\t\t\t\t&& loop--)\n\t\t\t\tndelay(100);\n\n\t\t\tif (loop == -1)\n\t\t\t\tgoto irq_transfer;\n\n\t\t\tuniphier_spi_recv(priv);\n\t\t}\n\t}\n\n\treturn 0;\n\nirq_transfer:\n\treturn uniphier_spi_transfer_one_irq(master, spi, t);\n}\n\nstatic int uniphier_spi_transfer_one(struct spi_master *master,\n\t\t\t\t     struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *t)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tunsigned long threshold;\n\tbool use_dma;\n\n\t \n\tif (!t->len)\n\t\treturn 0;\n\n\tuniphier_spi_setup_transfer(spi, t);\n\n\tuse_dma = master->can_dma ? master->can_dma(master, spi, t) : false;\n\tif (use_dma)\n\t\treturn uniphier_spi_transfer_one_dma(master, spi, t);\n\n\t \n\tthreshold = DIV_ROUND_UP(SSI_POLL_TIMEOUT_US * priv->speed_hz,\n\t\t\t\t\tUSEC_PER_SEC * BITS_PER_BYTE);\n\tif (t->len > threshold)\n\t\treturn uniphier_spi_transfer_one_irq(master, spi, t);\n\telse\n\t\treturn uniphier_spi_transfer_one_poll(master, spi, t);\n}\n\nstatic int uniphier_spi_prepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\n\twritel(SSI_CTL_EN, priv->base + SSI_CTL);\n\n\treturn 0;\n}\n\nstatic int uniphier_spi_unprepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\n\twritel(0, priv->base + SSI_CTL);\n\n\treturn 0;\n}\n\nstatic void uniphier_spi_handle_err(struct spi_master *master,\n\t\t\t\t    struct spi_message *msg)\n{\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\tu32 val;\n\n\t \n\twritel(0, priv->base + SSI_CTL);\n\n\t \n\tval = SSI_FC_TXFFL | SSI_FC_RXFFL;\n\twritel(val, priv->base + SSI_FC);\n\n\tuniphier_spi_irq_disable(priv, SSI_IE_ALL_MASK);\n\n\tif (atomic_read(&priv->dma_busy) & SSI_DMA_TX_BUSY) {\n\t\tdmaengine_terminate_async(master->dma_tx);\n\t\tatomic_andnot(SSI_DMA_TX_BUSY, &priv->dma_busy);\n\t}\n\n\tif (atomic_read(&priv->dma_busy) & SSI_DMA_RX_BUSY) {\n\t\tdmaengine_terminate_async(master->dma_rx);\n\t\tatomic_andnot(SSI_DMA_RX_BUSY, &priv->dma_busy);\n\t}\n}\n\nstatic irqreturn_t uniphier_spi_handler(int irq, void *dev_id)\n{\n\tstruct uniphier_spi_priv *priv = dev_id;\n\tu32 val, stat;\n\n\tstat = readl(priv->base + SSI_IS);\n\tval = SSI_IC_TCIC | SSI_IC_RCIC | SSI_IC_RORIC;\n\twritel(val, priv->base + SSI_IC);\n\n\t \n\tif (stat & SSI_IS_RORID) {\n\t\tpriv->error = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif ((stat & SSI_IS_RCID) && (stat & SSI_IS_RXRS)) {\n\t\twhile ((readl(priv->base + SSI_SR) & SSI_SR_RNE) &&\n\t\t\t\t(priv->rx_bytes - priv->tx_bytes) > 0)\n\t\t\tuniphier_spi_recv(priv);\n\n\t\tif ((readl(priv->base + SSI_SR) & SSI_SR_RNE) ||\n\t\t\t\t(priv->rx_bytes != priv->tx_bytes)) {\n\t\t\tpriv->error = -EIO;\n\t\t\tgoto done;\n\t\t} else if (priv->rx_bytes == 0)\n\t\t\tgoto done;\n\n\t\t \n\t\tuniphier_spi_fill_tx_fifo(priv);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n\ndone:\n\tcomplete(&priv->xfer_done);\n\treturn IRQ_HANDLED;\n}\n\nstatic int uniphier_spi_probe(struct platform_device *pdev)\n{\n\tstruct uniphier_spi_priv *priv;\n\tstruct spi_master *master;\n\tstruct resource *res;\n\tstruct dma_slave_caps caps;\n\tu32 dma_tx_burst = 0, dma_rx_burst = 0;\n\tunsigned long clk_rate;\n\tint irq;\n\tint ret;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*priv));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tpriv = spi_master_get_devdata(master);\n\tpriv->master = master;\n\tpriv->is_save_param = false;\n\n\tpriv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto out_master_put;\n\t}\n\tpriv->base_dma_addr = res->start;\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto out_master_put;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tgoto out_master_put;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_disable_clk;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, uniphier_spi_handler,\n\t\t\t       0, \"uniphier-spi\", priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\tgoto out_disable_clk;\n\t}\n\n\tinit_completion(&priv->xfer_done);\n\n\tclk_rate = clk_get_rate(priv->clk);\n\n\tmaster->max_speed_hz = DIV_ROUND_UP(clk_rate, SSI_MIN_CLK_DIVIDER);\n\tmaster->min_speed_hz = DIV_ROUND_UP(clk_rate, SSI_MAX_CLK_DIVIDER);\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->bus_num = pdev->id;\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\n\tmaster->set_cs = uniphier_spi_set_cs;\n\tmaster->transfer_one = uniphier_spi_transfer_one;\n\tmaster->prepare_transfer_hardware\n\t\t\t\t= uniphier_spi_prepare_transfer_hardware;\n\tmaster->unprepare_transfer_hardware\n\t\t\t\t= uniphier_spi_unprepare_transfer_hardware;\n\tmaster->handle_err = uniphier_spi_handle_err;\n\tmaster->can_dma = uniphier_spi_can_dma;\n\n\tmaster->num_chipselect = 1;\n\tmaster->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\n\tmaster->dma_tx = dma_request_chan(&pdev->dev, \"tx\");\n\tif (IS_ERR_OR_NULL(master->dma_tx)) {\n\t\tif (PTR_ERR(master->dma_tx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out_disable_clk;\n\t\t}\n\t\tmaster->dma_tx = NULL;\n\t\tdma_tx_burst = INT_MAX;\n\t} else {\n\t\tret = dma_get_slave_caps(master->dma_tx, &caps);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to get TX DMA capacities: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out_release_dma;\n\t\t}\n\t\tdma_tx_burst = caps.max_burst;\n\t}\n\n\tmaster->dma_rx = dma_request_chan(&pdev->dev, \"rx\");\n\tif (IS_ERR_OR_NULL(master->dma_rx)) {\n\t\tif (PTR_ERR(master->dma_rx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out_release_dma;\n\t\t}\n\t\tmaster->dma_rx = NULL;\n\t\tdma_rx_burst = INT_MAX;\n\t} else {\n\t\tret = dma_get_slave_caps(master->dma_rx, &caps);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to get RX DMA capacities: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out_release_dma;\n\t\t}\n\t\tdma_rx_burst = caps.max_burst;\n\t}\n\n\tmaster->max_dma_len = min(dma_tx_burst, dma_rx_burst);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret)\n\t\tgoto out_release_dma;\n\n\treturn 0;\n\nout_release_dma:\n\tif (!IS_ERR_OR_NULL(master->dma_rx)) {\n\t\tdma_release_channel(master->dma_rx);\n\t\tmaster->dma_rx = NULL;\n\t}\n\tif (!IS_ERR_OR_NULL(master->dma_tx)) {\n\t\tdma_release_channel(master->dma_tx);\n\t\tmaster->dma_tx = NULL;\n\t}\n\nout_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\nout_master_put:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void uniphier_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct uniphier_spi_priv *priv = spi_master_get_devdata(master);\n\n\tif (master->dma_tx)\n\t\tdma_release_channel(master->dma_tx);\n\tif (master->dma_rx)\n\t\tdma_release_channel(master->dma_rx);\n\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic const struct of_device_id uniphier_spi_match[] = {\n\t{ .compatible = \"socionext,uniphier-scssi\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_spi_match);\n\nstatic struct platform_driver uniphier_spi_driver = {\n\t.probe = uniphier_spi_probe,\n\t.remove_new = uniphier_spi_remove,\n\t.driver = {\n\t\t.name = \"uniphier-spi\",\n\t\t.of_match_table = uniphier_spi_match,\n\t},\n};\nmodule_platform_driver(uniphier_spi_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_AUTHOR(\"Keiji Hayashibara <hayashibara.keiji@socionext.com>\");\nMODULE_DESCRIPTION(\"Socionext UniPhier SPI controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}