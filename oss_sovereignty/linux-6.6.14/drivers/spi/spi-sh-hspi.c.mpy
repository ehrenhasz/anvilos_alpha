{
  "module_name": "spi-sh-hspi.c",
  "hash_id": "8d131216ce59735f6077ea831b3165b94a69a7b44aeeda353a859e0639cbb21c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sh-hspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/io.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/sh_hspi.h>\n\n#define SPCR\t0x00\n#define SPSR\t0x04\n#define SPSCR\t0x08\n#define SPTBR\t0x0C\n#define SPRBR\t0x10\n#define SPCR2\t0x14\n\n \n#define RXFL\t(1 << 2)\n\nstruct hspi_priv {\n\tvoid __iomem *addr;\n\tstruct spi_controller *ctlr;\n\tstruct device *dev;\n\tstruct clk *clk;\n};\n\n \nstatic void hspi_write(struct hspi_priv *hspi, int reg, u32 val)\n{\n\tiowrite32(val, hspi->addr + reg);\n}\n\nstatic u32 hspi_read(struct hspi_priv *hspi, int reg)\n{\n\treturn ioread32(hspi->addr + reg);\n}\n\nstatic void hspi_bit_set(struct hspi_priv *hspi, int reg, u32 mask, u32 set)\n{\n\tu32 val = hspi_read(hspi, reg);\n\n\tval &= ~mask;\n\tval |= set & mask;\n\n\thspi_write(hspi, reg, val);\n}\n\n \nstatic int hspi_status_check_timeout(struct hspi_priv *hspi, u32 mask, u32 val)\n{\n\tint t = 256;\n\n\twhile (t--) {\n\t\tif ((mask & hspi_read(hspi, SPSR)) == val)\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\t}\n\n\tdev_err(hspi->dev, \"timeout\\n\");\n\treturn -ETIMEDOUT;\n}\n\n \n\n#define hspi_hw_cs_enable(hspi)\t\thspi_hw_cs_ctrl(hspi, 0)\n#define hspi_hw_cs_disable(hspi)\thspi_hw_cs_ctrl(hspi, 1)\nstatic void hspi_hw_cs_ctrl(struct hspi_priv *hspi, int hi)\n{\n\thspi_bit_set(hspi, SPSCR, (1 << 6), (hi) << 6);\n}\n\nstatic void hspi_hw_setup(struct hspi_priv *hspi,\n\t\t\t  struct spi_message *msg,\n\t\t\t  struct spi_transfer *t)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct device *dev = hspi->dev;\n\tu32 spcr, idiv_clk;\n\tu32 rate, best_rate, min, tmp;\n\n\t \n\tmin = ~0;\n\tbest_rate = 0;\n\tspcr = 0;\n\tfor (idiv_clk = 0x00; idiv_clk <= 0x3F; idiv_clk++) {\n\t\trate = clk_get_rate(hspi->clk);\n\n\t\t \n\t\tif (idiv_clk & (1 << 5))\n\t\t\trate /= 128;\n\t\telse\n\t\t\trate /= 16;\n\n\t\t \n\t\trate /= (((idiv_clk & 0x1F) + 1) * 2);\n\n\t\t \n\t\ttmp = abs(t->speed_hz - rate);\n\t\tif (tmp < min) {\n\t\t\tmin = tmp;\n\t\t\tspcr = idiv_clk;\n\t\t\tbest_rate = rate;\n\t\t}\n\t}\n\n\tif (spi->mode & SPI_CPHA)\n\t\tspcr |= 1 << 7;\n\tif (spi->mode & SPI_CPOL)\n\t\tspcr |= 1 << 6;\n\n\tdev_dbg(dev, \"speed %d/%d\\n\", t->speed_hz, best_rate);\n\n\thspi_write(hspi, SPCR, spcr);\n\thspi_write(hspi, SPSR, 0x0);\n\thspi_write(hspi, SPSCR, 0x21);\t \n}\n\nstatic int hspi_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t     struct spi_message *msg)\n{\n\tstruct hspi_priv *hspi = spi_controller_get_devdata(ctlr);\n\tstruct spi_transfer *t;\n\tu32 tx;\n\tu32 rx;\n\tint ret, i;\n\tunsigned int cs_change;\n\tconst int nsecs = 50;\n\n\tdev_dbg(hspi->dev, \"%s\\n\", __func__);\n\n\tcs_change = 1;\n\tret = 0;\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\n\t\tif (cs_change) {\n\t\t\thspi_hw_setup(hspi, msg, t);\n\t\t\thspi_hw_cs_enable(hspi);\n\t\t\tndelay(nsecs);\n\t\t}\n\t\tcs_change = t->cs_change;\n\n\t\tfor (i = 0; i < t->len; i++) {\n\n\t\t\t \n\t\t\tret = hspi_status_check_timeout(hspi, 0x1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\ttx = 0;\n\t\t\tif (t->tx_buf)\n\t\t\t\ttx = (u32)((u8 *)t->tx_buf)[i];\n\n\t\t\thspi_write(hspi, SPTBR, tx);\n\n\t\t\t \n\t\t\tret = hspi_status_check_timeout(hspi, 0x4, 0x4);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\trx = hspi_read(hspi, SPRBR);\n\t\t\tif (t->rx_buf)\n\t\t\t\t((u8 *)t->rx_buf)[i] = (u8)rx;\n\n\t\t}\n\n\t\tmsg->actual_length += t->len;\n\n\t\tspi_transfer_delay_exec(t);\n\n\t\tif (cs_change) {\n\t\t\tndelay(nsecs);\n\t\t\thspi_hw_cs_disable(hspi);\n\t\t\tndelay(nsecs);\n\t\t}\n\t}\n\n\tmsg->status = ret;\n\tif (!cs_change) {\n\t\tndelay(nsecs);\n\t\thspi_hw_cs_disable(hspi);\n\t}\n\tspi_finalize_current_message(ctlr);\n\n\treturn ret;\n}\n\nstatic int hspi_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct spi_controller *ctlr;\n\tstruct hspi_priv *hspi;\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctlr = spi_alloc_host(&pdev->dev, sizeof(*hspi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tclk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"couldn't get clock\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error0;\n\t}\n\n\thspi = spi_controller_get_devdata(ctlr);\n\tplatform_set_drvdata(pdev, hspi);\n\n\t \n\thspi->ctlr\t= ctlr;\n\thspi->dev\t= &pdev->dev;\n\thspi->clk\t= clk;\n\thspi->addr\t= devm_ioremap(hspi->dev,\n\t\t\t\t       res->start, resource_size(res));\n\tif (!hspi->addr) {\n\t\tret = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tctlr->bus_num = pdev->id;\n\tctlr->mode_bits\t= SPI_CPOL | SPI_CPHA;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->auto_runtime_pm = true;\n\tctlr->transfer_one_message = hspi_transfer_one_message;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"devm_spi_register_controller error.\\n\");\n\t\tgoto error2;\n\t}\n\n\treturn 0;\n\n error2:\n\tpm_runtime_disable(&pdev->dev);\n error1:\n\tclk_put(clk);\n error0:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic void hspi_remove(struct platform_device *pdev)\n{\n\tstruct hspi_priv *hspi = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_put(hspi->clk);\n}\n\nstatic const struct of_device_id hspi_of_match[] = {\n\t{ .compatible = \"renesas,hspi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hspi_of_match);\n\nstatic struct platform_driver hspi_driver = {\n\t.probe = hspi_probe,\n\t.remove_new = hspi_remove,\n\t.driver = {\n\t\t.name = \"sh-hspi\",\n\t\t.of_match_table = hspi_of_match,\n\t},\n};\nmodule_platform_driver(hspi_driver);\n\nMODULE_DESCRIPTION(\"SuperH HSPI bus driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_ALIAS(\"platform:sh-hspi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}