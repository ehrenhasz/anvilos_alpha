{
  "module_name": "spi-iproc-qspi.c",
  "hash_id": "cff737466519119e9f68e2cd725bfd3ccc0b28e743dd4e572eb55c83ac629e80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-iproc-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"spi-bcm-qspi.h\"\n\n#define INTR_BASE_BIT_SHIFT\t\t\t0x02\n#define INTR_COUNT\t\t\t\t0x07\n\nstruct bcm_iproc_intc {\n\tstruct bcm_qspi_soc_intc soc_intc;\n\tstruct platform_device *pdev;\n\tvoid __iomem *int_reg;\n\tvoid __iomem *int_status_reg;\n\tspinlock_t soclock;\n\tbool big_endian;\n};\n\nstatic u32 bcm_iproc_qspi_get_l2_int_status(struct bcm_qspi_soc_intc *soc_intc)\n{\n\tstruct bcm_iproc_intc *priv =\n\t\t\tcontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\n\tvoid __iomem *mmio = priv->int_status_reg;\n\tint i;\n\tu32 val = 0, sts = 0;\n\n\tfor (i = 0; i < INTR_COUNT; i++) {\n\t\tif (bcm_qspi_readl(priv->big_endian, mmio + (i * 4)))\n\t\t\tval |= 1UL << i;\n\t}\n\n\tif (val & INTR_MSPI_DONE_MASK)\n\t\tsts |= MSPI_DONE;\n\n\tif (val & BSPI_LR_INTERRUPTS_ALL)\n\t\tsts |= BSPI_DONE;\n\n\tif (val & BSPI_LR_INTERRUPTS_ERROR)\n\t\tsts |= BSPI_ERR;\n\n\treturn sts;\n}\n\nstatic void bcm_iproc_qspi_int_ack(struct bcm_qspi_soc_intc *soc_intc, int type)\n{\n\tstruct bcm_iproc_intc *priv =\n\t\t\tcontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\n\tvoid __iomem *mmio = priv->int_status_reg;\n\tu32 mask = get_qspi_mask(type);\n\tint i;\n\n\tfor (i = 0; i < INTR_COUNT; i++) {\n\t\tif (mask & (1UL << i))\n\t\t\tbcm_qspi_writel(priv->big_endian, 1, mmio + (i * 4));\n\t}\n}\n\nstatic void bcm_iproc_qspi_int_set(struct bcm_qspi_soc_intc *soc_intc, int type,\n\t\t\t\t   bool en)\n{\n\tstruct bcm_iproc_intc *priv =\n\t\t\tcontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\n\tvoid __iomem *mmio = priv->int_reg;\n\tu32 mask = get_qspi_mask(type);\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->soclock, flags);\n\n\tval = bcm_qspi_readl(priv->big_endian, mmio);\n\n\tif (en)\n\t\tval = val | (mask << INTR_BASE_BIT_SHIFT);\n\telse\n\t\tval = val & ~(mask << INTR_BASE_BIT_SHIFT);\n\n\tbcm_qspi_writel(priv->big_endian, val, mmio);\n\n\tspin_unlock_irqrestore(&priv->soclock, flags);\n}\n\nstatic int bcm_iproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm_iproc_intc *priv;\n\tstruct bcm_qspi_soc_intc *soc_intc;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tsoc_intc = &priv->soc_intc;\n\tpriv->pdev = pdev;\n\n\tspin_lock_init(&priv->soclock);\n\n\tpriv->int_reg = devm_platform_ioremap_resource_byname(pdev, \"intr_regs\");\n\tif (IS_ERR(priv->int_reg))\n\t\treturn PTR_ERR(priv->int_reg);\n\n\tpriv->int_status_reg = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\t\t\t     \"intr_status_reg\");\n\tif (IS_ERR(priv->int_status_reg))\n\t\treturn PTR_ERR(priv->int_status_reg);\n\n\tpriv->big_endian = of_device_is_big_endian(dev->of_node);\n\n\tbcm_iproc_qspi_int_ack(soc_intc, MSPI_BSPI_DONE);\n\tbcm_iproc_qspi_int_set(soc_intc, MSPI_BSPI_DONE, false);\n\n\tsoc_intc->bcm_qspi_int_ack = bcm_iproc_qspi_int_ack;\n\tsoc_intc->bcm_qspi_int_set = bcm_iproc_qspi_int_set;\n\tsoc_intc->bcm_qspi_get_int_status = bcm_iproc_qspi_get_l2_int_status;\n\n\treturn bcm_qspi_probe(pdev, soc_intc);\n}\n\nstatic void bcm_iproc_remove(struct platform_device *pdev)\n{\n\tbcm_qspi_remove(pdev);\n}\n\nstatic const struct of_device_id bcm_iproc_of_match[] = {\n\t{ .compatible = \"brcm,spi-nsp-qspi\" },\n\t{ .compatible = \"brcm,spi-ns2-qspi\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm_iproc_of_match);\n\nstatic struct platform_driver bcm_iproc_driver = {\n\t.probe\t\t\t= bcm_iproc_probe,\n\t.remove_new\t\t= bcm_iproc_remove,\n\t.driver = {\n\t\t.name\t\t= \"bcm_iproc\",\n\t\t.pm\t\t= &bcm_qspi_pm_ops,\n\t\t.of_match_table = bcm_iproc_of_match,\n\t}\n};\nmodule_platform_driver(bcm_iproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Kamal Dasu\");\nMODULE_DESCRIPTION(\"SPI flash driver for Broadcom iProc SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}