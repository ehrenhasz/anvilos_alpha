{
  "module_name": "spi-cavium.c",
  "hash_id": "c3212d5b0614c0dd60d916fe81f0e11e4f184d14ed266e160780710eaf6fcca9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-cavium.c",
  "human_readable_source": " \n\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include \"spi-cavium.h\"\n\nstatic void octeon_spi_wait_ready(struct octeon_spi *p)\n{\n\tunion cvmx_mpi_sts mpi_sts;\n\tunsigned int loops = 0;\n\n\tdo {\n\t\tif (loops++)\n\t\t\t__delay(500);\n\t\tmpi_sts.u64 = readq(p->register_base + OCTEON_SPI_STS(p));\n\t} while (mpi_sts.s.busy);\n}\n\nstatic int octeon_spi_do_transfer(struct octeon_spi *p,\n\t\t\t\t  struct spi_message *msg,\n\t\t\t\t  struct spi_transfer *xfer,\n\t\t\t\t  bool last_xfer)\n{\n\tstruct spi_device *spi = msg->spi;\n\tunion cvmx_mpi_cfg mpi_cfg;\n\tunion cvmx_mpi_tx mpi_tx;\n\tunsigned int clkdiv;\n\tint mode;\n\tbool cpha, cpol;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tint len;\n\tint i;\n\n\tmode = spi->mode;\n\tcpha = mode & SPI_CPHA;\n\tcpol = mode & SPI_CPOL;\n\n\tclkdiv = p->sys_freq / (2 * xfer->speed_hz);\n\n\tmpi_cfg.u64 = 0;\n\n\tmpi_cfg.s.clkdiv = clkdiv;\n\tmpi_cfg.s.cshi = (mode & SPI_CS_HIGH) ? 1 : 0;\n\tmpi_cfg.s.lsbfirst = (mode & SPI_LSB_FIRST) ? 1 : 0;\n\tmpi_cfg.s.wireor = (mode & SPI_3WIRE) ? 1 : 0;\n\tmpi_cfg.s.idlelo = cpha != cpol;\n\tmpi_cfg.s.cslate = cpha ? 1 : 0;\n\tmpi_cfg.s.enable = 1;\n\n\tif (spi_get_chipselect(spi, 0) < 4)\n\t\tp->cs_enax |= 1ull << (12 + spi_get_chipselect(spi, 0));\n\tmpi_cfg.u64 |= p->cs_enax;\n\n\tif (mpi_cfg.u64 != p->last_cfg) {\n\t\tp->last_cfg = mpi_cfg.u64;\n\t\twriteq(mpi_cfg.u64, p->register_base + OCTEON_SPI_CFG(p));\n\t}\n\ttx_buf = xfer->tx_buf;\n\trx_buf = xfer->rx_buf;\n\tlen = xfer->len;\n\twhile (len > OCTEON_SPI_MAX_BYTES) {\n\t\tfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\n\t\t\tu8 d;\n\t\t\tif (tx_buf)\n\t\t\t\td = *tx_buf++;\n\t\t\telse\n\t\t\t\td = 0;\n\t\t\twriteq(d, p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\n\t\t}\n\t\tmpi_tx.u64 = 0;\n\t\tmpi_tx.s.csid = spi_get_chipselect(spi, 0);\n\t\tmpi_tx.s.leavecs = 1;\n\t\tmpi_tx.s.txnum = tx_buf ? OCTEON_SPI_MAX_BYTES : 0;\n\t\tmpi_tx.s.totnum = OCTEON_SPI_MAX_BYTES;\n\t\twriteq(mpi_tx.u64, p->register_base + OCTEON_SPI_TX(p));\n\n\t\tocteon_spi_wait_ready(p);\n\t\tif (rx_buf)\n\t\t\tfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\n\t\t\t\tu64 v = readq(p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\n\t\t\t\t*rx_buf++ = (u8)v;\n\t\t\t}\n\t\tlen -= OCTEON_SPI_MAX_BYTES;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tu8 d;\n\t\tif (tx_buf)\n\t\t\td = *tx_buf++;\n\t\telse\n\t\t\td = 0;\n\t\twriteq(d, p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\n\t}\n\n\tmpi_tx.u64 = 0;\n\tmpi_tx.s.csid = spi_get_chipselect(spi, 0);\n\tif (last_xfer)\n\t\tmpi_tx.s.leavecs = xfer->cs_change;\n\telse\n\t\tmpi_tx.s.leavecs = !xfer->cs_change;\n\tmpi_tx.s.txnum = tx_buf ? len : 0;\n\tmpi_tx.s.totnum = len;\n\twriteq(mpi_tx.u64, p->register_base + OCTEON_SPI_TX(p));\n\n\tocteon_spi_wait_ready(p);\n\tif (rx_buf)\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tu64 v = readq(p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\n\t\t\t*rx_buf++ = (u8)v;\n\t\t}\n\n\tspi_transfer_delay_exec(xfer);\n\n\treturn xfer->len;\n}\n\nint octeon_spi_transfer_one_message(struct spi_master *master,\n\t\t\t\t    struct spi_message *msg)\n{\n\tstruct octeon_spi *p = spi_master_get_devdata(master);\n\tunsigned int total_len = 0;\n\tint status = 0;\n\tstruct spi_transfer *xfer;\n\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tbool last_xfer = list_is_last(&xfer->transfer_list,\n\t\t\t\t\t      &msg->transfers);\n\t\tint r = octeon_spi_do_transfer(p, msg, xfer, last_xfer);\n\t\tif (r < 0) {\n\t\t\tstatus = r;\n\t\t\tgoto err;\n\t\t}\n\t\ttotal_len += r;\n\t}\nerr:\n\tmsg->status = status;\n\tmsg->actual_length = total_len;\n\tspi_finalize_current_message(master);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}