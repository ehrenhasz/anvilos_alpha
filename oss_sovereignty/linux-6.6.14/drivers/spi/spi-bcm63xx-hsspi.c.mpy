{
  "module_name": "spi-bcm63xx-hsspi.c",
  "hash_id": "b1c1a1ec3710b3cb78ce6ec324ccec7efa0078047a05a044c4b7785e29647fe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm63xx-hsspi.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/reset.h>\n#include <linux/pm_runtime.h>\n\n#define HSSPI_GLOBAL_CTRL_REG\t\t\t0x0\n#define GLOBAL_CTRL_CS_POLARITY_SHIFT\t\t0\n#define GLOBAL_CTRL_CS_POLARITY_MASK\t\t0x000000ff\n#define GLOBAL_CTRL_PLL_CLK_CTRL_SHIFT\t\t8\n#define GLOBAL_CTRL_PLL_CLK_CTRL_MASK\t\t0x0000ff00\n#define GLOBAL_CTRL_CLK_GATE_SSOFF\t\tBIT(16)\n#define GLOBAL_CTRL_CLK_POLARITY\t\tBIT(17)\n#define GLOBAL_CTRL_MOSI_IDLE\t\t\tBIT(18)\n\n#define HSSPI_GLOBAL_EXT_TRIGGER_REG\t\t0x4\n\n#define HSSPI_INT_STATUS_REG\t\t\t0x8\n#define HSSPI_INT_STATUS_MASKED_REG\t\t0xc\n#define HSSPI_INT_MASK_REG\t\t\t0x10\n\n#define HSSPI_PINGx_CMD_DONE(i)\t\t\tBIT((i * 8) + 0)\n#define HSSPI_PINGx_RX_OVER(i)\t\t\tBIT((i * 8) + 1)\n#define HSSPI_PINGx_TX_UNDER(i)\t\t\tBIT((i * 8) + 2)\n#define HSSPI_PINGx_POLL_TIMEOUT(i)\t\tBIT((i * 8) + 3)\n#define HSSPI_PINGx_CTRL_INVAL(i)\t\tBIT((i * 8) + 4)\n\n#define HSSPI_INT_CLEAR_ALL\t\t\t0xff001f1f\n\n#define HSSPI_PINGPONG_COMMAND_REG(x)\t\t(0x80 + (x) * 0x40)\n#define PINGPONG_CMD_COMMAND_MASK\t\t0xf\n#define PINGPONG_COMMAND_NOOP\t\t\t0\n#define PINGPONG_COMMAND_START_NOW\t\t1\n#define PINGPONG_COMMAND_START_TRIGGER\t\t2\n#define PINGPONG_COMMAND_HALT\t\t\t3\n#define PINGPONG_COMMAND_FLUSH\t\t\t4\n#define PINGPONG_CMD_PROFILE_SHIFT\t\t8\n#define PINGPONG_CMD_SS_SHIFT\t\t\t12\n\n#define HSSPI_PINGPONG_STATUS_REG(x)\t\t(0x84 + (x) * 0x40)\n#define HSSPI_PINGPONG_STATUS_SRC_BUSY\t\tBIT(1)\n\n#define HSSPI_PROFILE_CLK_CTRL_REG(x)\t\t(0x100 + (x) * 0x20)\n#define CLK_CTRL_FREQ_CTRL_MASK\t\t\t0x0000ffff\n#define CLK_CTRL_SPI_CLK_2X_SEL\t\t\tBIT(14)\n#define CLK_CTRL_ACCUM_RST_ON_LOOP\t\tBIT(15)\n\n#define HSSPI_PROFILE_SIGNAL_CTRL_REG(x)\t(0x104 + (x) * 0x20)\n#define SIGNAL_CTRL_LATCH_RISING\t\tBIT(12)\n#define SIGNAL_CTRL_LAUNCH_RISING\t\tBIT(13)\n#define SIGNAL_CTRL_ASYNC_INPUT_PATH\t\tBIT(16)\n\n#define HSSPI_PROFILE_MODE_CTRL_REG(x)\t\t(0x108 + (x) * 0x20)\n#define MODE_CTRL_MULTIDATA_RD_STRT_SHIFT\t8\n#define MODE_CTRL_MULTIDATA_WR_STRT_SHIFT\t12\n#define MODE_CTRL_MULTIDATA_RD_SIZE_SHIFT\t16\n#define MODE_CTRL_MULTIDATA_WR_SIZE_SHIFT\t18\n#define MODE_CTRL_MODE_3WIRE\t\t\tBIT(20)\n#define MODE_CTRL_PREPENDBYTE_CNT_SHIFT\t\t24\n\n#define HSSPI_FIFO_REG(x)\t\t\t(0x200 + (x) * 0x200)\n\n\n#define HSSPI_OP_MULTIBIT\t\t\tBIT(11)\n#define HSSPI_OP_CODE_SHIFT\t\t\t13\n#define HSSPI_OP_SLEEP\t\t\t\t(0 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_READ_WRITE\t\t\t(1 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_WRITE\t\t\t\t(2 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_READ\t\t\t\t(3 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_SETIRQ\t\t\t\t(4 << HSSPI_OP_CODE_SHIFT)\n\n#define HSSPI_BUFFER_LEN\t\t\t512\n#define HSSPI_OPCODE_LEN\t\t\t2\n\n#define HSSPI_MAX_PREPEND_LEN\t\t\t15\n\n \n#define HSSPI_MAX_SYNC_CLOCK\t\t\t25000000\n\n#define HSSPI_SPI_MAX_CS\t\t\t8\n#define HSSPI_BUS_NUM\t\t\t\t1  \n#define HSSPI_POLL_STATUS_TIMEOUT_MS\t100\n\n#define HSSPI_WAIT_MODE_POLLING\t\t0\n#define HSSPI_WAIT_MODE_INTR\t\t1\n#define HSSPI_WAIT_MODE_MAX\t\t\tHSSPI_WAIT_MODE_INTR\n\n \n#define HSSPI_XFER_MODE_AUTO\t\t0\n#define HSSPI_XFER_MODE_PREPEND\t\t1\n#define HSSPI_XFER_MODE_DUMMYCS\t\t2\n#define HSSPI_XFER_MODE_MAX\t\t\tHSSPI_XFER_MODE_DUMMYCS\n\n#define bcm63xx_prepend_printk_on_checkfail(bs, fmt, ...)\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (bs->xfer_mode == HSSPI_XFER_MODE_AUTO)\t\t\t\t\\\n\t\tdev_dbg(&bs->pdev->dev, fmt, ##__VA_ARGS__);\t\t\\\n\telse if (bs->xfer_mode == HSSPI_XFER_MODE_PREPEND)\t\t\\\n\t\tdev_err(&bs->pdev->dev, fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n\nstruct bcm63xx_hsspi {\n\tstruct completion done;\n\tstruct mutex bus_mutex;\n\tstruct mutex msg_mutex;\n\tstruct platform_device *pdev;\n\tstruct clk *clk;\n\tstruct clk *pll_clk;\n\tvoid __iomem *regs;\n\tu8 __iomem *fifo;\n\n\tu32 speed_hz;\n\tu8 cs_polarity;\n\tu32 wait_mode;\n\tu32 xfer_mode;\n\tu32 prepend_cnt;\n\tu8 *prepend_buf;\n};\n\nstatic ssize_t wait_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(ctrl);\n\n\treturn sprintf(buf, \"%d\\n\", bs->wait_mode);\n}\n\nstatic ssize_t wait_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(ctrl);\n\tu32 val;\n\n\tif (kstrtou32(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > HSSPI_WAIT_MODE_MAX) {\n\t\tdev_warn(dev, \"invalid wait mode %u\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&bs->msg_mutex);\n\tbs->wait_mode = val;\n\t \n\tif (val == HSSPI_WAIT_MODE_INTR)\n\t\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\tmutex_unlock(&bs->msg_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(wait_mode);\n\nstatic ssize_t xfer_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(ctrl);\n\n\treturn sprintf(buf, \"%d\\n\", bs->xfer_mode);\n}\n\nstatic ssize_t xfer_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(ctrl);\n\tu32 val;\n\n\tif (kstrtou32(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > HSSPI_XFER_MODE_MAX) {\n\t\tdev_warn(dev, \"invalid xfer mode %u\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&bs->msg_mutex);\n\tbs->xfer_mode = val;\n\tmutex_unlock(&bs->msg_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(xfer_mode);\n\nstatic struct attribute *bcm63xx_hsspi_attrs[] = {\n\t&dev_attr_wait_mode.attr,\n\t&dev_attr_xfer_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bcm63xx_hsspi_group = {\n\t.attrs = bcm63xx_hsspi_attrs,\n};\n\nstatic void bcm63xx_hsspi_set_clk(struct bcm63xx_hsspi *bs,\n\t\t\t\t  struct spi_device *spi, int hz);\n\nstatic size_t bcm63xx_hsspi_max_message_size(struct spi_device *spi)\n{\n\treturn HSSPI_BUFFER_LEN - HSSPI_OPCODE_LEN;\n}\n\nstatic int bcm63xx_hsspi_wait_cmd(struct bcm63xx_hsspi *bs)\n{\n\tunsigned long limit;\n\tu32 reg = 0;\n\tint rc = 0;\n\n\tif (bs->wait_mode == HSSPI_WAIT_MODE_INTR) {\n\t\tif (wait_for_completion_timeout(&bs->done, HZ) == 0)\n\t\t\trc = 1;\n\t} else {\n\t\t \n\t\tlimit = jiffies + msecs_to_jiffies(HSSPI_POLL_STATUS_TIMEOUT_MS);\n\n\t\twhile (!time_after(jiffies, limit)) {\n\t\t\treg = __raw_readl(bs->regs + HSSPI_PINGPONG_STATUS_REG(0));\n\t\t\tif (reg & HSSPI_PINGPONG_STATUS_SRC_BUSY)\n\t\t\t\tcpu_relax();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (reg & HSSPI_PINGPONG_STATUS_SRC_BUSY)\n\t\t\trc = 1;\n\t}\n\n\tif (rc)\n\t\tdev_err(&bs->pdev->dev, \"transfer timed out!\\n\");\n\n\treturn rc;\n}\n\nstatic bool bcm63xx_prepare_prepend_transfer(struct spi_controller *host,\n\t\t\t\t\t  struct spi_message *msg,\n\t\t\t\t\t  struct spi_transfer *t_prepend)\n{\n\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(host);\n\tbool tx_only = false;\n\tstruct spi_transfer *t;\n\n\t \n\tbs->prepend_cnt = 0;\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\t\tif ((spi_delay_to_ns(&t->delay, t) > 0) || t->cs_change) {\n\t\t\tbcm63xx_prepend_printk_on_checkfail(bs,\n\t\t\t\t \"Delay or cs change not supported in prepend mode!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\ttx_only = false;\n\t\tif (t->tx_buf && !t->rx_buf) {\n\t\t\ttx_only = true;\n\t\t\tif (bs->prepend_cnt + t->len >\n\t\t\t\t(HSSPI_BUFFER_LEN - HSSPI_OPCODE_LEN)) {\n\t\t\t\tbcm63xx_prepend_printk_on_checkfail(bs,\n\t\t\t\t\t \"exceed max buf len, abort prepending transfers!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (t->tx_nbits > SPI_NBITS_SINGLE &&\n\t\t\t\t!list_is_last(&t->transfer_list, &msg->transfers)) {\n\t\t\t\tbcm63xx_prepend_printk_on_checkfail(bs,\n\t\t\t\t\t \"multi-bit prepend buf not supported!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (t->tx_nbits == SPI_NBITS_SINGLE) {\n\t\t\t\tmemcpy(bs->prepend_buf + bs->prepend_cnt, t->tx_buf, t->len);\n\t\t\t\tbs->prepend_cnt += t->len;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!list_is_last(&t->transfer_list, &msg->transfers)) {\n\t\t\t\tbcm63xx_prepend_printk_on_checkfail(bs,\n\t\t\t\t\t \"rx/tx_rx transfer not supported when it is not last one!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (list_is_last(&t->transfer_list, &msg->transfers)) {\n\t\t\tmemcpy(t_prepend, t, sizeof(struct spi_transfer));\n\n\t\t\tif (tx_only && t->tx_nbits == SPI_NBITS_SINGLE) {\n\t\t\t\t \n\t\t\t\tt_prepend->len = bs->prepend_cnt;\n\t\t\t\tt_prepend->tx_buf = bs->prepend_buf;\n\t\t\t\tbs->prepend_cnt = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bs->prepend_cnt > HSSPI_MAX_PREPEND_LEN) {\n\t\t\t\t\tbcm63xx_prepend_printk_on_checkfail(bs,\n\t\t\t\t\t\t\"exceed max prepend len, abort prepending transfers!\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int bcm63xx_hsspi_do_prepend_txrx(struct spi_device *spi,\n\t\t\t\t\t struct spi_transfer *t)\n{\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tunsigned int chip_select = spi_get_chipselect(spi, 0);\n\tu16 opcode = 0, val;\n\tconst u8 *tx = t->tx_buf;\n\tu8 *rx = t->rx_buf;\n\tu32 reg = 0;\n\n\t \n\tif (t->len + bs->prepend_cnt > (HSSPI_BUFFER_LEN - HSSPI_OPCODE_LEN)) {\n\t\tdev_warn(&bs->pdev->dev,\n\t\t\t \"Prepend message large than fifo size len %d prepend %d\\n\",\n\t\t\t t->len, bs->prepend_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tbcm63xx_hsspi_set_clk(bs, spi, t->speed_hz);\n\n\tif (tx && rx)\n\t\topcode = HSSPI_OP_READ_WRITE;\n\telse if (tx)\n\t\topcode = HSSPI_OP_WRITE;\n\telse if (rx)\n\t\topcode = HSSPI_OP_READ;\n\n\tif ((opcode == HSSPI_OP_READ && t->rx_nbits == SPI_NBITS_DUAL) ||\n\t    (opcode == HSSPI_OP_WRITE && t->tx_nbits == SPI_NBITS_DUAL)) {\n\t\topcode |= HSSPI_OP_MULTIBIT;\n\n\t\tif (t->rx_nbits == SPI_NBITS_DUAL) {\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_RD_SIZE_SHIFT;\n\t\t\treg |= bs->prepend_cnt << MODE_CTRL_MULTIDATA_RD_STRT_SHIFT;\n\t\t}\n\t\tif (t->tx_nbits == SPI_NBITS_DUAL) {\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_WR_SIZE_SHIFT;\n\t\t\treg |= bs->prepend_cnt << MODE_CTRL_MULTIDATA_WR_STRT_SHIFT;\n\t\t}\n\t}\n\n\treg |= bs->prepend_cnt << MODE_CTRL_PREPENDBYTE_CNT_SHIFT;\n\t__raw_writel(reg | 0xff,\n\t\t     bs->regs + HSSPI_PROFILE_MODE_CTRL_REG(chip_select));\n\n\treinit_completion(&bs->done);\n\tif (bs->prepend_cnt)\n\t\tmemcpy_toio(bs->fifo + HSSPI_OPCODE_LEN, bs->prepend_buf,\n\t\t\t    bs->prepend_cnt);\n\tif (tx)\n\t\tmemcpy_toio(bs->fifo + HSSPI_OPCODE_LEN + bs->prepend_cnt, tx,\n\t\t\t    t->len);\n\n\t*(__be16 *)(&val) = cpu_to_be16(opcode | t->len);\n\t__raw_writew(val, bs->fifo);\n\t \n\tif (bs->wait_mode == HSSPI_WAIT_MODE_INTR)\n\t\t__raw_writel(HSSPI_PINGx_CMD_DONE(0), bs->regs + HSSPI_INT_MASK_REG);\n\n\t \n\treg = chip_select << PINGPONG_CMD_SS_SHIFT |\n\t    chip_select << PINGPONG_CMD_PROFILE_SHIFT |\n\t    PINGPONG_COMMAND_START_NOW;\n\t__raw_writel(reg, bs->regs + HSSPI_PINGPONG_COMMAND_REG(0));\n\n\tif (bcm63xx_hsspi_wait_cmd(bs))\n\t\treturn -ETIMEDOUT;\n\n\tif (rx)\n\t\tmemcpy_fromio(rx, bs->fifo, t->len);\n\n\treturn 0;\n}\n\nstatic void bcm63xx_hsspi_set_cs(struct bcm63xx_hsspi *bs, unsigned int cs,\n\t\t\t\t bool active)\n{\n\tu32 reg;\n\n\tmutex_lock(&bs->bus_mutex);\n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\treg &= ~BIT(cs);\n\tif (active == !(bs->cs_polarity & BIT(cs)))\n\t\treg |= BIT(cs);\n\n\t__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\tmutex_unlock(&bs->bus_mutex);\n}\n\nstatic void bcm63xx_hsspi_set_clk(struct bcm63xx_hsspi *bs,\n\t\t\t\t  struct spi_device *spi, int hz)\n{\n\tunsigned int profile = spi_get_chipselect(spi, 0);\n\tu32 reg;\n\n\treg = DIV_ROUND_UP(2048, DIV_ROUND_UP(bs->speed_hz, hz));\n\t__raw_writel(CLK_CTRL_ACCUM_RST_ON_LOOP | reg,\n\t\t     bs->regs + HSSPI_PROFILE_CLK_CTRL_REG(profile));\n\n\treg = __raw_readl(bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));\n\tif (hz > HSSPI_MAX_SYNC_CLOCK)\n\t\treg |= SIGNAL_CTRL_ASYNC_INPUT_PATH;\n\telse\n\t\treg &= ~SIGNAL_CTRL_ASYNC_INPUT_PATH;\n\t__raw_writel(reg, bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));\n\n\tmutex_lock(&bs->bus_mutex);\n\t \n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\treg &= ~GLOBAL_CTRL_CLK_POLARITY;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= GLOBAL_CTRL_CLK_POLARITY;\n\t__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\tmutex_unlock(&bs->bus_mutex);\n}\n\nstatic int bcm63xx_hsspi_do_txrx(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tunsigned int chip_select = spi_get_chipselect(spi, 0);\n\tu16 opcode = 0, val;\n\tint pending = t->len;\n\tint step_size = HSSPI_BUFFER_LEN;\n\tconst u8 *tx = t->tx_buf;\n\tu8 *rx = t->rx_buf;\n\tu32 reg = 0;\n\n\tbcm63xx_hsspi_set_clk(bs, spi, t->speed_hz);\n\tif (!t->cs_off)\n\t\tbcm63xx_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), true);\n\n\tif (tx && rx)\n\t\topcode = HSSPI_OP_READ_WRITE;\n\telse if (tx)\n\t\topcode = HSSPI_OP_WRITE;\n\telse if (rx)\n\t\topcode = HSSPI_OP_READ;\n\n\tif (opcode != HSSPI_OP_READ)\n\t\tstep_size -= HSSPI_OPCODE_LEN;\n\n\tif ((opcode == HSSPI_OP_READ && t->rx_nbits == SPI_NBITS_DUAL) ||\n\t    (opcode == HSSPI_OP_WRITE && t->tx_nbits == SPI_NBITS_DUAL)) {\n\t\topcode |= HSSPI_OP_MULTIBIT;\n\n\t\tif (t->rx_nbits == SPI_NBITS_DUAL)\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_RD_SIZE_SHIFT;\n\t\tif (t->tx_nbits == SPI_NBITS_DUAL)\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_WR_SIZE_SHIFT;\n\t}\n\n\t__raw_writel(reg | 0xff,\n\t\t     bs->regs + HSSPI_PROFILE_MODE_CTRL_REG(chip_select));\n\n\twhile (pending > 0) {\n\t\tint curr_step = min_t(int, step_size, pending);\n\n\t\treinit_completion(&bs->done);\n\t\tif (tx) {\n\t\t\tmemcpy_toio(bs->fifo + HSSPI_OPCODE_LEN, tx, curr_step);\n\t\t\ttx += curr_step;\n\t\t}\n\n\t\t*(__be16 *)(&val) = cpu_to_be16(opcode | curr_step);\n\t\t__raw_writew(val, bs->fifo);\n\n\t\t \n\t\tif (bs->wait_mode == HSSPI_WAIT_MODE_INTR)\n\t\t\t__raw_writel(HSSPI_PINGx_CMD_DONE(0),\n\t\t\t\t     bs->regs + HSSPI_INT_MASK_REG);\n\n\t\treg =  !chip_select << PINGPONG_CMD_SS_SHIFT |\n\t\t\t    chip_select << PINGPONG_CMD_PROFILE_SHIFT |\n\t\t\t    PINGPONG_COMMAND_START_NOW;\n\t\t__raw_writel(reg, bs->regs + HSSPI_PINGPONG_COMMAND_REG(0));\n\n\t\tif (bcm63xx_hsspi_wait_cmd(bs))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif (rx) {\n\t\t\tmemcpy_fromio(rx, bs->fifo, curr_step);\n\t\t\trx += curr_step;\n\t\t}\n\n\t\tpending -= curr_step;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm63xx_hsspi_setup(struct spi_device *spi)\n{\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tu32 reg;\n\n\treg = __raw_readl(bs->regs +\n\t\t\t  HSSPI_PROFILE_SIGNAL_CTRL_REG(spi_get_chipselect(spi, 0)));\n\treg &= ~(SIGNAL_CTRL_LAUNCH_RISING | SIGNAL_CTRL_LATCH_RISING);\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= SIGNAL_CTRL_LAUNCH_RISING;\n\telse\n\t\treg |= SIGNAL_CTRL_LATCH_RISING;\n\t__raw_writel(reg, bs->regs +\n\t\t     HSSPI_PROFILE_SIGNAL_CTRL_REG(spi_get_chipselect(spi, 0)));\n\n\tmutex_lock(&bs->bus_mutex);\n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\t \n\tif ((reg & GLOBAL_CTRL_CS_POLARITY_MASK) == bs->cs_polarity) {\n\t\tif (spi->mode & SPI_CS_HIGH)\n\t\t\treg |= BIT(spi_get_chipselect(spi, 0));\n\t\telse\n\t\t\treg &= ~BIT(spi_get_chipselect(spi, 0));\n\t\t__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\t}\n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tbs->cs_polarity |= BIT(spi_get_chipselect(spi, 0));\n\telse\n\t\tbs->cs_polarity &= ~BIT(spi_get_chipselect(spi, 0));\n\n\tmutex_unlock(&bs->bus_mutex);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_hsspi_do_dummy_cs_txrx(struct spi_device *spi,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tint status = -EINVAL;\n\tint dummy_cs;\n\tbool keep_cs = false;\n\tstruct spi_transfer *t;\n\n\t \n\n\tdummy_cs = !spi_get_chipselect(spi, 0);\n\tbcm63xx_hsspi_set_cs(bs, dummy_cs, true);\n\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\t\t \n\t\tif (bs->xfer_mode == HSSPI_XFER_MODE_AUTO) {\n\t\t\tif (t->speed_hz > HSSPI_MAX_SYNC_CLOCK) {\n\t\t\t\tt->speed_hz = HSSPI_MAX_SYNC_CLOCK;\n\t\t\t\tdev_warn_once(&bs->pdev->dev,\n\t\t\t\t\t\"Force to dummy cs mode. Reduce the speed to %dHz\",\n\t\t\t\t\tt->speed_hz);\n\t\t\t}\n\t\t}\n\n\t\tstatus = bcm63xx_hsspi_do_txrx(spi, t);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tmsg->actual_length += t->len;\n\n\t\tspi_transfer_delay_exec(t);\n\n\t\t \n\t\tif (t->cs_change) {\n\t\t\tif (list_is_last(&t->transfer_list, &msg->transfers)) {\n\t\t\t\tkeep_cs = true;\n\t\t\t} else {\n\t\t\t\tif (!t->cs_off)\n\t\t\t\t\tbcm63xx_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), false);\n\n\t\t\t\tspi_transfer_cs_change_delay_exec(msg, t);\n\n\t\t\t\tif (!list_next_entry(t, transfer_list)->cs_off)\n\t\t\t\t\tbcm63xx_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), true);\n\t\t\t}\n\t\t} else if (!list_is_last(&t->transfer_list, &msg->transfers) &&\n\t\t\t   t->cs_off != list_next_entry(t, transfer_list)->cs_off) {\n\t\t\tbcm63xx_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), t->cs_off);\n\t\t}\n\t}\n\n\tbcm63xx_hsspi_set_cs(bs, dummy_cs, false);\n\tif (status || !keep_cs)\n\t\tbcm63xx_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), false);\n\n\treturn status;\n}\n\nstatic int bcm63xx_hsspi_transfer_one(struct spi_controller *host,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = msg->spi;\n\tint status = -EINVAL;\n\tbool prependable = false;\n\tstruct spi_transfer t_prepend;\n\n\tmutex_lock(&bs->msg_mutex);\n\n\tif (bs->xfer_mode != HSSPI_XFER_MODE_DUMMYCS)\n\t\tprependable = bcm63xx_prepare_prepend_transfer(host, msg, &t_prepend);\n\n\tif (prependable) {\n\t\tstatus = bcm63xx_hsspi_do_prepend_txrx(spi, &t_prepend);\n\t\tmsg->actual_length = (t_prepend.len + bs->prepend_cnt);\n\t} else {\n\t\tif (bs->xfer_mode == HSSPI_XFER_MODE_PREPEND) {\n\t\t\tdev_err(&bs->pdev->dev,\n\t\t\t\t\"User sets prepend mode but msg not prependable! Abort transfer\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t} else\n\t\t\tstatus = bcm63xx_hsspi_do_dummy_cs_txrx(spi, msg);\n\t}\n\n\tmutex_unlock(&bs->msg_mutex);\n\tmsg->status = status;\n\tspi_finalize_current_message(host);\n\n\treturn 0;\n}\n\nstatic bool bcm63xx_hsspi_mem_supports_op(struct spi_mem *mem,\n\t\t\t    const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\t \n\tif ((op->cmd.opcode == SPINOR_OP_READ_1_2_2) ||\n\t\t(op->cmd.opcode == SPINOR_OP_READ_1_2_2_4B) ||\n\t\t(op->cmd.opcode == SPINOR_OP_READ_1_2_2_DTR) ||\n\t\t(op->cmd.opcode == SPINOR_OP_READ_1_2_2_DTR_4B))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct spi_controller_mem_ops bcm63xx_hsspi_mem_ops = {\n\t.supports_op = bcm63xx_hsspi_mem_supports_op,\n};\n\nstatic irqreturn_t bcm63xx_hsspi_interrupt(int irq, void *dev_id)\n{\n\tstruct bcm63xx_hsspi *bs = (struct bcm63xx_hsspi *)dev_id;\n\n\tif (__raw_readl(bs->regs + HSSPI_INT_STATUS_MASKED_REG) == 0)\n\t\treturn IRQ_NONE;\n\n\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\n\tcomplete(&bs->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm63xx_hsspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct bcm63xx_hsspi *bs;\n\tvoid __iomem *regs;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk, *pll_clk = NULL;\n\tint irq, ret;\n\tu32 reg, rate, num_cs = HSSPI_SPI_MAX_CS;\n\tstruct reset_control *reset;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tclk = devm_clk_get(dev, \"hsspi\");\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\treset = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_reset(reset);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to reset device: %d\\n\", ret);\n\t\tgoto out_disable_clk;\n\t}\n\n\trate = clk_get_rate(clk);\n\tif (!rate) {\n\t\tpll_clk = devm_clk_get(dev, \"pll\");\n\n\t\tif (IS_ERR(pll_clk)) {\n\t\t\tret = PTR_ERR(pll_clk);\n\t\t\tgoto out_disable_clk;\n\t\t}\n\n\t\tret = clk_prepare_enable(pll_clk);\n\t\tif (ret)\n\t\t\tgoto out_disable_clk;\n\n\t\trate = clk_get_rate(pll_clk);\n\t\tif (!rate) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_disable_pll_clk;\n\t\t}\n\t}\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*bs));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_pll_clk;\n\t}\n\n\tbs = spi_controller_get_devdata(host);\n\tbs->pdev = pdev;\n\tbs->clk = clk;\n\tbs->pll_clk = pll_clk;\n\tbs->regs = regs;\n\tbs->speed_hz = rate;\n\tbs->fifo = (u8 __iomem *)(bs->regs + HSSPI_FIFO_REG(0));\n\tbs->wait_mode = HSSPI_WAIT_MODE_POLLING;\n\tbs->prepend_buf = devm_kzalloc(dev, HSSPI_BUFFER_LEN, GFP_KERNEL);\n\tif (!bs->prepend_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_host;\n\t}\n\n\tmutex_init(&bs->bus_mutex);\n\tmutex_init(&bs->msg_mutex);\n\tinit_completion(&bs->done);\n\n\thost->mem_ops = &bcm63xx_hsspi_mem_ops;\n\thost->dev.of_node = dev->of_node;\n\tif (!dev->of_node)\n\t\thost->bus_num = HSSPI_BUS_NUM;\n\n\tof_property_read_u32(dev->of_node, \"num-cs\", &num_cs);\n\tif (num_cs > 8) {\n\t\tdev_warn(dev, \"unsupported number of cs (%i), reducing to 8\\n\",\n\t\t\t num_cs);\n\t\tnum_cs = HSSPI_SPI_MAX_CS;\n\t}\n\thost->num_chipselect = num_cs;\n\thost->setup = bcm63xx_hsspi_setup;\n\thost->transfer_one_message = bcm63xx_hsspi_transfer_one;\n\thost->max_transfer_size = bcm63xx_hsspi_max_message_size;\n\thost->max_message_size = bcm63xx_hsspi_max_message_size;\n\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |\n\t\t\t    SPI_RX_DUAL | SPI_TX_DUAL;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->auto_runtime_pm = true;\n\n\tplatform_set_drvdata(pdev, host);\n\n\t \n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\n\t \n\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\n\t \n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\tbs->cs_polarity = reg & GLOBAL_CTRL_CS_POLARITY_MASK;\n\t__raw_writel(reg | GLOBAL_CTRL_CLK_GATE_SSOFF,\n\t\t     bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\tif (irq > 0) {\n\t\tret = devm_request_irq(dev, irq, bcm63xx_hsspi_interrupt, IRQF_SHARED,\n\t\t\t\t       pdev->name, bs);\n\n\t\tif (ret)\n\t\t\tgoto out_put_host;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &bcm63xx_hsspi_group);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"couldn't register sysfs group\\n\");\n\t\tgoto out_pm_disable;\n\t}\n\n\t \n\tret = devm_spi_register_controller(dev, host);\n\tif (ret)\n\t\tgoto out_sysgroup_disable;\n\n\tdev_info(dev, \"Broadcom 63XX High Speed SPI Controller driver\");\n\n\treturn 0;\n\nout_sysgroup_disable:\n\tsysfs_remove_group(&pdev->dev.kobj, &bcm63xx_hsspi_group);\nout_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nout_put_host:\n\tspi_controller_put(host);\nout_disable_pll_clk:\n\tclk_disable_unprepare(pll_clk);\nout_disable_clk:\n\tclk_disable_unprepare(clk);\n\treturn ret;\n}\n\n\nstatic void bcm63xx_hsspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(host);\n\n\t \n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\tclk_disable_unprepare(bs->pll_clk);\n\tclk_disable_unprepare(bs->clk);\n\tsysfs_remove_group(&pdev->dev.kobj, &bcm63xx_hsspi_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bcm63xx_hsspi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(host);\n\n\tspi_controller_suspend(host);\n\tclk_disable_unprepare(bs->pll_clk);\n\tclk_disable_unprepare(bs->clk);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_hsspi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcm63xx_hsspi *bs = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(bs->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bs->pll_clk) {\n\t\tret = clk_prepare_enable(bs->pll_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(bs->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspi_controller_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(bcm63xx_hsspi_pm_ops, bcm63xx_hsspi_suspend,\n\t\t\t bcm63xx_hsspi_resume);\n\nstatic const struct of_device_id bcm63xx_hsspi_of_match[] = {\n\t{ .compatible = \"brcm,bcm6328-hsspi\", },\n\t{ .compatible = \"brcm,bcmbca-hsspi-v1.0\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm63xx_hsspi_of_match);\n\nstatic struct platform_driver bcm63xx_hsspi_driver = {\n\t.driver = {\n\t\t.name\t= \"bcm63xx-hsspi\",\n\t\t.pm\t= &bcm63xx_hsspi_pm_ops,\n\t\t.of_match_table = bcm63xx_hsspi_of_match,\n\t},\n\t.probe\t\t= bcm63xx_hsspi_probe,\n\t.remove_new\t= bcm63xx_hsspi_remove,\n};\n\nmodule_platform_driver(bcm63xx_hsspi_driver);\n\nMODULE_ALIAS(\"platform:bcm63xx_hsspi\");\nMODULE_DESCRIPTION(\"Broadcom BCM63xx High Speed SPI Controller driver\");\nMODULE_AUTHOR(\"Jonas Gorski <jogo@openwrt.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}