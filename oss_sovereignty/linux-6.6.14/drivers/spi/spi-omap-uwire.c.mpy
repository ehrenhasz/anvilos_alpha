{
  "module_name": "spi-omap-uwire.c",
  "hash_id": "2bbd32fa5e6de87ae07eb3610f139e1f1e8da94bcd1ca6e272e1f6b6ae7407d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-omap-uwire.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#include <asm/mach-types.h>\n#include <linux/soc/ti/omap1-io.h>\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/soc/ti/omap1-mux.h>\n\n \n#define UWIRE_BASE_PHYS\t\t0xFFFB3000\n\n \n#define UWIRE_IO_SIZE 0x20\n#define UWIRE_TDR     0x00\n#define UWIRE_RDR     0x00\n#define UWIRE_CSR     0x01\n#define UWIRE_SR1     0x02\n#define UWIRE_SR2     0x03\n#define UWIRE_SR3     0x04\n#define UWIRE_SR4     0x05\n#define UWIRE_SR5     0x06\n\n \n#define\tRDRB\t(1 << 15)\n#define\tCSRB\t(1 << 14)\n#define\tSTART\t(1 << 13)\n#define\tCS_CMD\t(1 << 12)\n\n \n#define UWIRE_READ_FALLING_EDGE\t\t0x0001\n#define UWIRE_READ_RISING_EDGE\t\t0x0000\n#define UWIRE_WRITE_FALLING_EDGE\t0x0000\n#define UWIRE_WRITE_RISING_EDGE\t\t0x0002\n#define UWIRE_CS_ACTIVE_LOW\t\t0x0000\n#define UWIRE_CS_ACTIVE_HIGH\t\t0x0004\n#define UWIRE_FREQ_DIV_2\t\t0x0000\n#define UWIRE_FREQ_DIV_4\t\t0x0008\n#define UWIRE_FREQ_DIV_8\t\t0x0010\n#define UWIRE_CHK_READY\t\t\t0x0020\n#define UWIRE_CLK_INVERTED\t\t0x0040\n\n\nstruct uwire_spi {\n\tstruct spi_bitbang\tbitbang;\n\tstruct clk\t\t*ck;\n};\n\nstruct uwire_state {\n\tunsigned\tdiv1_idx;\n};\n\n \n \nstatic unsigned int uwire_idx_shift = 2;\nstatic void __iomem *uwire_base;\n\nstatic inline void uwire_write_reg(int idx, u16 val)\n{\n\t__raw_writew(val, uwire_base + (idx << uwire_idx_shift));\n}\n\nstatic inline u16 uwire_read_reg(int idx)\n{\n\treturn __raw_readw(uwire_base + (idx << uwire_idx_shift));\n}\n\nstatic inline void omap_uwire_configure_mode(u8 cs, unsigned long flags)\n{\n\tu16\tw, val = 0;\n\tint\tshift, reg;\n\n\tif (flags & UWIRE_CLK_INVERTED)\n\t\tval ^= 0x03;\n\tval = flags & 0x3f;\n\tif (cs & 1)\n\t\tshift = 6;\n\telse\n\t\tshift = 0;\n\tif (cs <= 1)\n\t\treg = UWIRE_SR1;\n\telse\n\t\treg = UWIRE_SR2;\n\n\tw = uwire_read_reg(reg);\n\tw &= ~(0x3f << shift);\n\tw |= val << shift;\n\tuwire_write_reg(reg, w);\n}\n\nstatic int wait_uwire_csr_flag(u16 mask, u16 val, int might_not_catch)\n{\n\tu16 w;\n\tint c = 0;\n\tunsigned long max_jiffies = jiffies + HZ;\n\n\tfor (;;) {\n\t\tw = uwire_read_reg(UWIRE_CSR);\n\t\tif ((w & mask) == val)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, max_jiffies)) {\n\t\t\tprintk(KERN_ERR \"%s: timeout. reg=%#06x \"\n\t\t\t\t\t\"mask=%#06x val=%#06x\\n\",\n\t\t\t       __func__, w, mask, val);\n\t\t\treturn -1;\n\t\t}\n\t\tc++;\n\t\tif (might_not_catch && c > 64)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void uwire_set_clk1_div(int div1_idx)\n{\n\tu16 w;\n\n\tw = uwire_read_reg(UWIRE_SR3);\n\tw &= ~(0x03 << 1);\n\tw |= div1_idx << 1;\n\tuwire_write_reg(UWIRE_SR3, w);\n}\n\nstatic void uwire_chipselect(struct spi_device *spi, int value)\n{\n\tstruct\tuwire_state *ust = spi->controller_state;\n\tu16\tw;\n\tint\told_cs;\n\n\n\tBUG_ON(wait_uwire_csr_flag(CSRB, 0, 0));\n\n\tw = uwire_read_reg(UWIRE_CSR);\n\told_cs = (w >> 10) & 0x03;\n\tif (value == BITBANG_CS_INACTIVE || old_cs != spi_get_chipselect(spi, 0)) {\n\t\t \n\t\tw &= ~CS_CMD;\n\t\tuwire_write_reg(UWIRE_CSR, w);\n\t}\n\t \n\tif (value == BITBANG_CS_ACTIVE) {\n\t\tuwire_set_clk1_div(ust->div1_idx);\n\t\t \n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tuwire_write_reg(UWIRE_SR4, 1);\n\t\telse\n\t\t\tuwire_write_reg(UWIRE_SR4, 0);\n\n\t\tw = spi_get_chipselect(spi, 0) << 10;\n\t\tw |= CS_CMD;\n\t\tuwire_write_reg(UWIRE_CSR, w);\n\t}\n}\n\nstatic int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)\n{\n\tunsigned\tlen = t->len;\n\tunsigned\tbits = t->bits_per_word;\n\tunsigned\tbytes;\n\tu16\t\tval, w;\n\tint\t\tstatus = 0;\n\n\tif (!t->tx_buf && !t->rx_buf)\n\t\treturn 0;\n\n\tw = spi_get_chipselect(spi, 0) << 10;\n\tw |= CS_CMD;\n\n\tif (t->tx_buf) {\n\t\tconst u8\t*buf = t->tx_buf;\n\n\t\t \n\n\t\t \n\t\twhile (len >= 1) {\n\t\t\t \n\t\t\tval = *buf++;\n\t\t\tif (bits > 8) {\n\t\t\t\tbytes = 2;\n\t\t\t\tval |= *buf++ << 8;\n\t\t\t} else\n\t\t\t\tbytes = 1;\n\t\t\tval <<= 16 - bits;\n\n#ifdef\tVERBOSE\n\t\t\tpr_debug(\"%s: write-%d =%04x\\n\",\n\t\t\t\t\tdev_name(&spi->dev), bits, val);\n#endif\n\t\t\tif (wait_uwire_csr_flag(CSRB, 0, 0))\n\t\t\t\tgoto eio;\n\n\t\t\tuwire_write_reg(UWIRE_TDR, val);\n\n\t\t\t \n\t\t\tval = START | w | (bits << 5);\n\n\t\t\tuwire_write_reg(UWIRE_CSR, val);\n\t\t\tlen -= bytes;\n\n\t\t\t \n\t\t\tif (wait_uwire_csr_flag(CSRB, CSRB, 1))\n\t\t\t\tgoto eio;\n\n\t\t\tstatus += bytes;\n\t\t}\n\n\t\t \n\t\tif (wait_uwire_csr_flag(CSRB, 0, 0))\n\t\t\tgoto eio;\n\n\t} else if (t->rx_buf) {\n\t\tu8\t\t*buf = t->rx_buf;\n\n\t\t \n\t\twhile (len) {\n\t\t\tif (bits > 8) {\n\t\t\t\tbytes = 2;\n\t\t\t} else\n\t\t\t\tbytes = 1;\n\n\t\t\t \n\t\t\tval = START | w | (bits << 0);\n\t\t\tuwire_write_reg(UWIRE_CSR, val);\n\t\t\tlen -= bytes;\n\n\t\t\t \n\t\t\t(void) wait_uwire_csr_flag(CSRB, CSRB, 1);\n\n\t\t\tif (wait_uwire_csr_flag(RDRB | CSRB,\n\t\t\t\t\t\tRDRB, 0))\n\t\t\t\tgoto eio;\n\n\t\t\t \n\t\t\tval = uwire_read_reg(UWIRE_RDR);\n\t\t\tval &= (1 << bits) - 1;\n\t\t\t*buf++ = (u8) val;\n\t\t\tif (bytes == 2)\n\t\t\t\t*buf++ = val >> 8;\n\t\t\tstatus += bytes;\n#ifdef\tVERBOSE\n\t\t\tpr_debug(\"%s: read-%d =%04x\\n\",\n\t\t\t\t\tdev_name(&spi->dev), bits, val);\n#endif\n\n\t\t}\n\t}\n\treturn status;\neio:\n\treturn -EIO;\n}\n\nstatic int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct uwire_state\t*ust = spi->controller_state;\n\tstruct uwire_spi\t*uwire;\n\tunsigned\t\tflags = 0;\n\tunsigned\t\thz;\n\tunsigned long\t\trate;\n\tint\t\t\tdiv1_idx;\n\tint\t\t\tdiv1;\n\tint\t\t\tdiv2;\n\tint\t\t\tstatus;\n\n\tuwire = spi_master_get_devdata(spi->master);\n\n\t \n\tif (spi->mode & SPI_CS_HIGH)\n\t\tflags |= UWIRE_CS_ACTIVE_HIGH;\n\n\tif (spi->mode & SPI_CPOL)\n\t\tflags |= UWIRE_CLK_INVERTED;\n\n\tswitch (spi->mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\tcase SPI_MODE_3:\n\t\tflags |= UWIRE_WRITE_FALLING_EDGE | UWIRE_READ_RISING_EDGE;\n\t\tbreak;\n\tcase SPI_MODE_1:\n\tcase SPI_MODE_2:\n\t\tflags |= UWIRE_WRITE_RISING_EDGE | UWIRE_READ_FALLING_EDGE;\n\t\tbreak;\n\t}\n\n\t \n\trate = clk_get_rate(uwire->ck);\n\n\tif (t != NULL)\n\t\thz = t->speed_hz;\n\telse\n\t\thz = spi->max_speed_hz;\n\n\tif (!hz) {\n\t\tpr_debug(\"%s: zero speed?\\n\", dev_name(&spi->dev));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (div1_idx = 0; div1_idx < 4; div1_idx++) {\n\t\tswitch (div1_idx) {\n\t\tcase 0:\n\t\t\tdiv1 = 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdiv1 = 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdiv1 = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 3:\n\t\t\tdiv1 = 10;\n\t\t\tbreak;\n\t\t}\n\t\tdiv2 = (rate / div1 + hz - 1) / hz;\n\t\tif (div2 <= 8)\n\t\t\tbreak;\n\t}\n\tif (div1_idx == 4) {\n\t\tpr_debug(\"%s: lowest clock %ld, need %d\\n\",\n\t\t\tdev_name(&spi->dev), rate / 10 / 8, hz);\n\t\tstatus = -EDOM;\n\t\tgoto done;\n\t}\n\n\t \n\tust->div1_idx = div1_idx;\n\tuwire_set_clk1_div(div1_idx);\n\n\trate /= div1;\n\n\tswitch (div2) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tflags |= UWIRE_FREQ_DIV_2;\n\t\trate /= 2;\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\t\tflags |= UWIRE_FREQ_DIV_4;\n\t\trate /= 4;\n\t\tbreak;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\tcase 8:\n\t\tflags |= UWIRE_FREQ_DIV_8;\n\t\trate /= 8;\n\t\tbreak;\n\t}\n\tomap_uwire_configure_mode(spi_get_chipselect(spi, 0), flags);\n\tpr_debug(\"%s: uwire flags %02x, armxor %lu KHz, SCK %lu KHz\\n\",\n\t\t\t__func__, flags,\n\t\t\tclk_get_rate(uwire->ck) / 1000,\n\t\t\trate / 1000);\n\tstatus = 0;\ndone:\n\treturn status;\n}\n\nstatic int uwire_setup(struct spi_device *spi)\n{\n\tstruct uwire_state *ust = spi->controller_state;\n\tbool initial_setup = false;\n\tint status;\n\n\tif (ust == NULL) {\n\t\tust = kzalloc(sizeof(*ust), GFP_KERNEL);\n\t\tif (ust == NULL)\n\t\t\treturn -ENOMEM;\n\t\tspi->controller_state = ust;\n\t\tinitial_setup = true;\n\t}\n\n\tstatus = uwire_setup_transfer(spi, NULL);\n\tif (status && initial_setup)\n\t\tkfree(ust);\n\n\treturn status;\n}\n\nstatic void uwire_cleanup(struct spi_device *spi)\n{\n\tkfree(spi->controller_state);\n}\n\nstatic void uwire_off(struct uwire_spi *uwire)\n{\n\tuwire_write_reg(UWIRE_SR3, 0);\n\tclk_disable_unprepare(uwire->ck);\n\tspi_master_put(uwire->bitbang.master);\n}\n\nstatic int uwire_probe(struct platform_device *pdev)\n{\n\tstruct spi_master\t*master;\n\tstruct uwire_spi\t*uwire;\n\tint\t\t\tstatus;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*uwire));\n\tif (!master)\n\t\treturn -ENODEV;\n\n\tuwire = spi_master_get_devdata(master);\n\n\tuwire_base = devm_ioremap(&pdev->dev, UWIRE_BASE_PHYS, UWIRE_IO_SIZE);\n\tif (!uwire_base) {\n\t\tdev_dbg(&pdev->dev, \"can't ioremap UWIRE\\n\");\n\t\tspi_master_put(master);\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, uwire);\n\n\tuwire->ck = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(uwire->ck)) {\n\t\tstatus = PTR_ERR(uwire->ck);\n\t\tdev_dbg(&pdev->dev, \"no functional clock?\\n\");\n\t\tspi_master_put(master);\n\t\treturn status;\n\t}\n\tclk_prepare_enable(uwire->ck);\n\n\tuwire_write_reg(UWIRE_SR3, 1);\n\n\t \n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);\n\tmaster->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\n\tmaster->bus_num = 2;\t \n\tmaster->num_chipselect = 4;\n\tmaster->setup = uwire_setup;\n\tmaster->cleanup = uwire_cleanup;\n\n\tuwire->bitbang.master = master;\n\tuwire->bitbang.chipselect = uwire_chipselect;\n\tuwire->bitbang.setup_transfer = uwire_setup_transfer;\n\tuwire->bitbang.txrx_bufs = uwire_txrx;\n\n\tstatus = spi_bitbang_start(&uwire->bitbang);\n\tif (status < 0) {\n\t\tuwire_off(uwire);\n\t}\n\treturn status;\n}\n\nstatic void uwire_remove(struct platform_device *pdev)\n{\n\tstruct uwire_spi\t*uwire = platform_get_drvdata(pdev);\n\n\t\n\n\tspi_bitbang_stop(&uwire->bitbang);\n\tuwire_off(uwire);\n}\n\n \nMODULE_ALIAS(\"platform:omap_uwire\");\n\nstatic struct platform_driver uwire_driver = {\n\t.driver = {\n\t\t.name\t\t= \"omap_uwire\",\n\t},\n\t.probe = uwire_probe,\n\t.remove_new = uwire_remove,\n\t\n\t\n};\n\nstatic int __init omap_uwire_init(void)\n{\n\treturn platform_driver_register(&uwire_driver);\n}\n\nstatic void __exit omap_uwire_exit(void)\n{\n\tplatform_driver_unregister(&uwire_driver);\n}\n\nsubsys_initcall(omap_uwire_init);\nmodule_exit(omap_uwire_exit);\n\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}