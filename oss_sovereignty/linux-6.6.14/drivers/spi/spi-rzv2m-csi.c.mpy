{
  "module_name": "spi-rzv2m-csi.c",
  "hash_id": "3546aa86f91c12cbc24717ee644ffbaf990b90762752f4bcaebb4c5689219efc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rzv2m-csi.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/count_zeros.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/log2.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n \n#define CSI_MODE\t\t0x00\t \n#define CSI_CLKSEL\t\t0x04\t \n#define CSI_CNT\t\t\t0x08\t \n#define CSI_INT\t\t\t0x0C\t \n#define CSI_IFIFOL\t\t0x10\t \n#define CSI_OFIFOL\t\t0x14\t \n#define CSI_IFIFO\t\t0x18\t \n#define CSI_OFIFO\t\t0x1C\t \n#define CSI_FIFOTRG\t\t0x20\t \n\n \n#define CSI_MODE_CSIE\t\tBIT(7)\n#define CSI_MODE_TRMD\t\tBIT(6)\n#define CSI_MODE_CCL\t\tBIT(5)\n#define CSI_MODE_DIR\t\tBIT(4)\n#define CSI_MODE_CSOT\t\tBIT(0)\n\n#define CSI_MODE_SETUP\t\t0x00000040\n\n \n#define CSI_CLKSEL_CKP\t\tBIT(17)\n#define CSI_CLKSEL_DAP\t\tBIT(16)\n#define CSI_CLKSEL_MODE\t\t(CSI_CLKSEL_CKP|CSI_CLKSEL_DAP)\n#define CSI_CLKSEL_SLAVE\tBIT(15)\n#define CSI_CLKSEL_CKS\t\tGENMASK(14, 1)\n\n \n#define CSI_CNT_CSIRST\t\tBIT(28)\n#define CSI_CNT_R_TRGEN\t\tBIT(19)\n#define CSI_CNT_UNDER_E\t\tBIT(13)\n#define CSI_CNT_OVERF_E\t\tBIT(12)\n#define CSI_CNT_TREND_E\t\tBIT(9)\n#define CSI_CNT_CSIEND_E\tBIT(8)\n#define CSI_CNT_T_TRGR_E\tBIT(4)\n#define CSI_CNT_R_TRGR_E\tBIT(0)\n\n \n#define CSI_INT_UNDER\t\tBIT(13)\n#define CSI_INT_OVERF\t\tBIT(12)\n#define CSI_INT_TREND\t\tBIT(9)\n#define CSI_INT_CSIEND\t\tBIT(8)\n#define CSI_INT_T_TRGR\t\tBIT(4)\n#define CSI_INT_R_TRGR\t\tBIT(0)\n\n \n#define CSI_FIFOTRG_R_TRG       GENMASK(2, 0)\n\n#define CSI_FIFO_SIZE_BYTES\t32U\n#define CSI_FIFO_HALF_SIZE\t16U\n#define CSI_EN_DIS_TIMEOUT_US\t100\n \n#define CSI_CKS_MAX\t\tGENMASK(13, 0)\n\n#define UNDERRUN_ERROR\t\tBIT(0)\n#define OVERFLOW_ERROR\t\tBIT(1)\n#define TX_TIMEOUT_ERROR\tBIT(2)\n#define RX_TIMEOUT_ERROR\tBIT(3)\n\n#define CSI_MAX_SPI_SCKO\t(8 * HZ_PER_MHZ)\n\nstruct rzv2m_csi_priv {\n\tvoid __iomem *base;\n\tstruct clk *csiclk;\n\tstruct clk *pclk;\n\tstruct device *dev;\n\tstruct spi_controller *controller;\n\tconst void *txbuf;\n\tvoid *rxbuf;\n\tunsigned int buffer_len;\n\tunsigned int bytes_sent;\n\tunsigned int bytes_received;\n\tunsigned int bytes_to_transfer;\n\tunsigned int words_to_transfer;\n\tunsigned int bytes_per_word;\n\twait_queue_head_t wait;\n\tu32 errors;\n\tu32 status;\n};\n\nstatic void rzv2m_csi_reg_write_bit(const struct rzv2m_csi_priv *csi,\n\t\t\t\t    int reg_offs, int bit_mask, u32 value)\n{\n\tint nr_zeros;\n\tu32 tmp;\n\n\tnr_zeros = count_trailing_zeros(bit_mask);\n\tvalue <<= nr_zeros;\n\n\ttmp = (readl(csi->base + reg_offs) & ~bit_mask) | value;\n\twritel(tmp, csi->base + reg_offs);\n}\n\nstatic int rzv2m_csi_sw_reset(struct rzv2m_csi_priv *csi, int assert)\n{\n\tu32 reg;\n\n\trzv2m_csi_reg_write_bit(csi, CSI_CNT, CSI_CNT_CSIRST, assert);\n\n\tif (!assert)\n\t\treturn 0;\n\n\treturn readl_poll_timeout(csi->base + CSI_MODE, reg,\n\t\t\t\t  !(reg & CSI_MODE_CSOT), 0,\n\t\t\t\t  CSI_EN_DIS_TIMEOUT_US);\n}\n\nstatic int rzv2m_csi_start_stop_operation(const struct rzv2m_csi_priv *csi,\n\t\t\t\t\t  int enable, bool wait)\n{\n\tu32 reg;\n\n\trzv2m_csi_reg_write_bit(csi, CSI_MODE, CSI_MODE_CSIE, enable);\n\n\tif (enable || !wait)\n\t\treturn 0;\n\n\treturn readl_poll_timeout(csi->base + CSI_MODE, reg,\n\t\t\t\t  !(reg & CSI_MODE_CSOT), 0,\n\t\t\t\t  CSI_EN_DIS_TIMEOUT_US);\n}\n\nstatic int rzv2m_csi_fill_txfifo(struct rzv2m_csi_priv *csi)\n{\n\tunsigned int i;\n\n\tif (readl(csi->base + CSI_OFIFOL))\n\t\treturn -EIO;\n\n\tif (csi->bytes_per_word == 2) {\n\t\tconst u16 *buf = csi->txbuf;\n\n\t\tfor (i = 0; i < csi->words_to_transfer; i++)\n\t\t\twritel(buf[i], csi->base + CSI_OFIFO);\n\t} else {\n\t\tconst u8 *buf = csi->txbuf;\n\n\t\tfor (i = 0; i < csi->words_to_transfer; i++)\n\t\t\twritel(buf[i], csi->base + CSI_OFIFO);\n\t}\n\n\tcsi->txbuf += csi->bytes_to_transfer;\n\tcsi->bytes_sent += csi->bytes_to_transfer;\n\n\treturn 0;\n}\n\nstatic int rzv2m_csi_read_rxfifo(struct rzv2m_csi_priv *csi)\n{\n\tunsigned int i;\n\n\tif (readl(csi->base + CSI_IFIFOL) != csi->bytes_to_transfer)\n\t\treturn -EIO;\n\n\tif (csi->bytes_per_word == 2) {\n\t\tu16 *buf = csi->rxbuf;\n\n\t\tfor (i = 0; i < csi->words_to_transfer; i++)\n\t\t\tbuf[i] = (u16)readl(csi->base + CSI_IFIFO);\n\t} else {\n\t\tu8 *buf = csi->rxbuf;\n\n\t\tfor (i = 0; i < csi->words_to_transfer; i++)\n\t\t\tbuf[i] = (u8)readl(csi->base + CSI_IFIFO);\n\t}\n\n\tcsi->rxbuf += csi->bytes_to_transfer;\n\tcsi->bytes_received += csi->bytes_to_transfer;\n\n\treturn 0;\n}\n\nstatic inline void rzv2m_csi_calc_current_transfer(struct rzv2m_csi_priv *csi)\n{\n\tunsigned int bytes_transferred = max(csi->bytes_received, csi->bytes_sent);\n\tunsigned int bytes_remaining = csi->buffer_len - bytes_transferred;\n\tunsigned int to_transfer;\n\n\tif (csi->txbuf)\n\t\t \n\t\tto_transfer = min(CSI_FIFO_HALF_SIZE, bytes_remaining);\n\telse\n\t\tto_transfer = min(CSI_FIFO_SIZE_BYTES, bytes_remaining);\n\n\tif (csi->bytes_per_word == 2)\n\t\tto_transfer >>= 1;\n\n\t \n\tcsi->words_to_transfer = rounddown_pow_of_two(to_transfer);\n\n\tif (csi->bytes_per_word == 2)\n\t\tcsi->bytes_to_transfer = csi->words_to_transfer << 1;\n\telse\n\t\tcsi->bytes_to_transfer = csi->words_to_transfer;\n}\n\nstatic inline void rzv2m_csi_set_rx_fifo_trigger_level(struct rzv2m_csi_priv *csi)\n{\n\trzv2m_csi_reg_write_bit(csi, CSI_FIFOTRG, CSI_FIFOTRG_R_TRG,\n\t\t\t\tilog2(csi->words_to_transfer));\n}\n\nstatic inline void rzv2m_csi_enable_rx_trigger(struct rzv2m_csi_priv *csi,\n\t\t\t\t\t       bool enable)\n{\n\trzv2m_csi_reg_write_bit(csi, CSI_CNT, CSI_CNT_R_TRGEN, enable);\n}\n\nstatic void rzv2m_csi_disable_irqs(const struct rzv2m_csi_priv *csi,\n\t\t\t\t   u32 enable_bits)\n{\n\tu32 cnt = readl(csi->base + CSI_CNT);\n\n\twritel(cnt & ~enable_bits, csi->base + CSI_CNT);\n}\n\nstatic void rzv2m_csi_disable_all_irqs(struct rzv2m_csi_priv *csi)\n{\n\trzv2m_csi_disable_irqs(csi, CSI_CNT_R_TRGR_E | CSI_CNT_T_TRGR_E |\n\t\t\t       CSI_CNT_CSIEND_E | CSI_CNT_TREND_E |\n\t\t\t       CSI_CNT_OVERF_E | CSI_CNT_UNDER_E);\n}\n\nstatic inline void rzv2m_csi_clear_irqs(struct rzv2m_csi_priv *csi, u32 irqs)\n{\n\twritel(irqs, csi->base + CSI_INT);\n}\n\nstatic void rzv2m_csi_clear_all_irqs(struct rzv2m_csi_priv *csi)\n{\n\trzv2m_csi_clear_irqs(csi, CSI_INT_UNDER | CSI_INT_OVERF |\n\t\t\t     CSI_INT_TREND | CSI_INT_CSIEND |  CSI_INT_T_TRGR |\n\t\t\t     CSI_INT_R_TRGR);\n}\n\nstatic void rzv2m_csi_enable_irqs(struct rzv2m_csi_priv *csi, u32 enable_bits)\n{\n\tu32 cnt = readl(csi->base + CSI_CNT);\n\n\twritel(cnt | enable_bits, csi->base + CSI_CNT);\n}\n\nstatic int rzv2m_csi_wait_for_interrupt(struct rzv2m_csi_priv *csi,\n\t\t\t\t\tu32 wait_mask, u32 enable_bits)\n{\n\tint ret;\n\n\trzv2m_csi_enable_irqs(csi, enable_bits);\n\n\tret = wait_event_timeout(csi->wait,\n\t\t\t\t ((csi->status & wait_mask) == wait_mask) ||\n\t\t\t\t csi->errors, HZ);\n\n\trzv2m_csi_disable_irqs(csi, enable_bits);\n\n\tif (csi->errors)\n\t\treturn -EIO;\n\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int rzv2m_csi_wait_for_tx_empty(struct rzv2m_csi_priv *csi)\n{\n\tint ret;\n\n\tif (readl(csi->base + CSI_OFIFOL) == 0)\n\t\treturn 0;\n\n\tret = rzv2m_csi_wait_for_interrupt(csi, CSI_INT_TREND, CSI_CNT_TREND_E);\n\tif (ret == -ETIMEDOUT)\n\t\tcsi->errors |= TX_TIMEOUT_ERROR;\n\n\treturn ret;\n}\n\nstatic inline int rzv2m_csi_wait_for_rx_ready(struct rzv2m_csi_priv *csi)\n{\n\tint ret;\n\n\tif (readl(csi->base + CSI_IFIFOL) == csi->bytes_to_transfer)\n\t\treturn 0;\n\n\tret = rzv2m_csi_wait_for_interrupt(csi, CSI_INT_R_TRGR,\n\t\t\t\t\t   CSI_CNT_R_TRGR_E);\n\tif (ret == -ETIMEDOUT)\n\t\tcsi->errors |= RX_TIMEOUT_ERROR;\n\n\treturn ret;\n}\n\nstatic irqreturn_t rzv2m_csi_irq_handler(int irq, void *data)\n{\n\tstruct rzv2m_csi_priv *csi = data;\n\n\tcsi->status = readl(csi->base + CSI_INT);\n\trzv2m_csi_disable_irqs(csi, csi->status);\n\n\tif (csi->status & CSI_INT_OVERF)\n\t\tcsi->errors |= OVERFLOW_ERROR;\n\tif (csi->status & CSI_INT_UNDER)\n\t\tcsi->errors |= UNDERRUN_ERROR;\n\n\twake_up(&csi->wait);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rzv2m_csi_setup_clock(struct rzv2m_csi_priv *csi, u32 spi_hz)\n{\n\tunsigned long csiclk_rate = clk_get_rate(csi->csiclk);\n\tunsigned long pclk_rate = clk_get_rate(csi->pclk);\n\tunsigned long csiclk_rate_limit = pclk_rate >> 1;\n\tu32 cks;\n\n\t \n\tif (csiclk_rate > csiclk_rate_limit) {\n\t\tclk_set_rate(csi->csiclk, csiclk_rate >> 1);\n\t\tcsiclk_rate = clk_get_rate(csi->csiclk);\n\t} else if ((csiclk_rate << 1) <= csiclk_rate_limit) {\n\t\tclk_set_rate(csi->csiclk, csiclk_rate << 1);\n\t\tcsiclk_rate = clk_get_rate(csi->csiclk);\n\t}\n\n\tspi_hz = spi_hz > CSI_MAX_SPI_SCKO ? CSI_MAX_SPI_SCKO : spi_hz;\n\n\tcks = DIV_ROUND_UP(csiclk_rate, spi_hz << 1);\n\tif (cks > CSI_CKS_MAX)\n\t\tcks = CSI_CKS_MAX;\n\n\tdev_dbg(csi->dev, \"SPI clk rate is %ldHz\\n\", csiclk_rate / (cks << 1));\n\n\trzv2m_csi_reg_write_bit(csi, CSI_CLKSEL, CSI_CLKSEL_CKS, cks);\n}\n\nstatic void rzv2m_csi_setup_operating_mode(struct rzv2m_csi_priv *csi,\n\t\t\t\t\t   struct spi_transfer *t)\n{\n\tif (t->rx_buf && !t->tx_buf)\n\t\t \n\t\trzv2m_csi_reg_write_bit(csi, CSI_MODE, CSI_MODE_TRMD, 0);\n\telse\n\t\t \n\t\trzv2m_csi_reg_write_bit(csi, CSI_MODE, CSI_MODE_TRMD, 1);\n\n\tcsi->bytes_per_word = t->bits_per_word / 8;\n\trzv2m_csi_reg_write_bit(csi, CSI_MODE, CSI_MODE_CCL,\n\t\t\t\tcsi->bytes_per_word == 2);\n}\n\nstatic int rzv2m_csi_setup(struct spi_device *spi)\n{\n\tstruct rzv2m_csi_priv *csi = spi_controller_get_devdata(spi->controller);\n\tint ret;\n\n\trzv2m_csi_sw_reset(csi, 0);\n\n\twritel(CSI_MODE_SETUP, csi->base + CSI_MODE);\n\n\t \n\trzv2m_csi_reg_write_bit(csi, CSI_CLKSEL, CSI_CLKSEL_MODE,\n\t\t\t\t~spi->mode & SPI_MODE_X_MASK);\n\n\t \n\trzv2m_csi_reg_write_bit(csi, CSI_MODE, CSI_MODE_DIR,\n\t\t\t\t!!(spi->mode & SPI_LSB_FIRST));\n\n\t \n\trzv2m_csi_reg_write_bit(csi, CSI_CLKSEL, CSI_CLKSEL_SLAVE, 0);\n\n\t \n\tret = rzv2m_csi_sw_reset(csi, 1);\n\tif (ret)\n\t\treturn ret;\n\trzv2m_csi_sw_reset(csi, 0);\n\n\t \n\trzv2m_csi_start_stop_operation(csi, 1, false);\n\tudelay(10);\n\trzv2m_csi_start_stop_operation(csi, 0, false);\n\n\treturn 0;\n}\n\nstatic int rzv2m_csi_pio_transfer(struct rzv2m_csi_priv *csi)\n{\n\tbool tx_completed = !csi->txbuf;\n\tbool rx_completed = !csi->rxbuf;\n\tint ret = 0;\n\n\t \n\twritel(0, csi->base + CSI_OFIFOL);\n\n\tcsi->bytes_sent = 0;\n\tcsi->bytes_received = 0;\n\tcsi->errors = 0;\n\n\trzv2m_csi_disable_all_irqs(csi);\n\trzv2m_csi_clear_all_irqs(csi);\n\trzv2m_csi_enable_rx_trigger(csi, true);\n\n\twhile (!tx_completed || !rx_completed) {\n\t\t \n\t\trzv2m_csi_calc_current_transfer(csi);\n\t\trzv2m_csi_set_rx_fifo_trigger_level(csi);\n\n\t\trzv2m_csi_enable_irqs(csi, CSI_INT_OVERF | CSI_INT_UNDER);\n\n\t\t \n\t\twritel(0, csi->base + CSI_IFIFOL);\n\n\t\twritel(readl(csi->base + CSI_INT), csi->base + CSI_INT);\n\t\tcsi->status = 0;\n\n\t\trzv2m_csi_start_stop_operation(csi, 1, false);\n\n\t\t \n\t\tif (csi->txbuf) {\n\t\t\tret = rzv2m_csi_fill_txfifo(csi);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tret = rzv2m_csi_wait_for_tx_empty(csi);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (csi->bytes_sent == csi->buffer_len)\n\t\t\t\ttx_completed = true;\n\t\t}\n\n\t\t \n\t\tret = rzv2m_csi_wait_for_rx_ready(csi);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (csi->rxbuf) {\n\t\t\trzv2m_csi_start_stop_operation(csi, 0, false);\n\n\t\t\tret = rzv2m_csi_read_rxfifo(csi);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (csi->bytes_received == csi->buffer_len)\n\t\t\t\trx_completed = true;\n\t\t}\n\n\t\tret = rzv2m_csi_start_stop_operation(csi, 0, true);\n\t\tif (ret)\n\t\t\tgoto pio_quit;\n\n\t\tif (csi->errors) {\n\t\t\tret = -EIO;\n\t\t\tgoto pio_quit;\n\t\t}\n\t}\n\n\trzv2m_csi_start_stop_operation(csi, 0, true);\n\npio_quit:\n\trzv2m_csi_disable_all_irqs(csi);\n\trzv2m_csi_enable_rx_trigger(csi, false);\n\trzv2m_csi_clear_all_irqs(csi);\n\n\treturn ret;\n}\n\nstatic int rzv2m_csi_transfer_one(struct spi_controller *controller,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *transfer)\n{\n\tstruct rzv2m_csi_priv *csi = spi_controller_get_devdata(controller);\n\tstruct device *dev = csi->dev;\n\tint ret;\n\n\tcsi->txbuf = transfer->tx_buf;\n\tcsi->rxbuf = transfer->rx_buf;\n\tcsi->buffer_len = transfer->len;\n\n\trzv2m_csi_setup_operating_mode(csi, transfer);\n\n\trzv2m_csi_setup_clock(csi, transfer->speed_hz);\n\n\tret = rzv2m_csi_pio_transfer(csi);\n\tif (ret) {\n\t\tif (csi->errors & UNDERRUN_ERROR)\n\t\t\tdev_err(dev, \"Underrun error\\n\");\n\t\tif (csi->errors & OVERFLOW_ERROR)\n\t\t\tdev_err(dev, \"Overflow error\\n\");\n\t\tif (csi->errors & TX_TIMEOUT_ERROR)\n\t\t\tdev_err(dev, \"TX timeout error\\n\");\n\t\tif (csi->errors & RX_TIMEOUT_ERROR)\n\t\t\tdev_err(dev, \"RX timeout error\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int rzv2m_csi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *controller;\n\tstruct device *dev = &pdev->dev;\n\tstruct rzv2m_csi_priv *csi;\n\tstruct reset_control *rstc;\n\tint irq;\n\tint ret;\n\n\tcontroller = devm_spi_alloc_host(dev, sizeof(*csi));\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tcsi = spi_controller_get_devdata(controller);\n\tplatform_set_drvdata(pdev, csi);\n\n\tcsi->dev = dev;\n\tcsi->controller = controller;\n\n\tcsi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi->base))\n\t\treturn PTR_ERR(csi->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tcsi->csiclk = devm_clk_get(dev, \"csiclk\");\n\tif (IS_ERR(csi->csiclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(csi->csiclk),\n\t\t\t\t     \"could not get csiclk\\n\");\n\n\tcsi->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(csi->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(csi->pclk),\n\t\t\t\t     \"could not get pclk\\n\");\n\n\trstc = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(rstc), \"Missing reset ctrl\\n\");\n\n\tinit_waitqueue_head(&csi->wait);\n\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n\tcontroller->bits_per_word_mask = SPI_BPW_MASK(16) | SPI_BPW_MASK(8);\n\tcontroller->setup = rzv2m_csi_setup;\n\tcontroller->transfer_one = rzv2m_csi_transfer_one;\n\tcontroller->use_gpio_descriptors = true;\n\n\tdevice_set_node(&controller->dev, dev_fwnode(dev));\n\n\tret = devm_request_irq(dev, irq, rzv2m_csi_irq_handler, 0,\n\t\t\t       dev_name(dev), csi);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot request IRQ\\n\");\n\n\t \n\treset_control_deassert(rstc);\n\n\t \n\tret = rzv2m_csi_sw_reset(csi, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(csi->csiclk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not enable csiclk\\n\");\n\n\tret = spi_register_controller(controller);\n\tif (ret) {\n\t\tclk_disable_unprepare(csi->csiclk);\n\t\treturn dev_err_probe(dev, ret, \"register controller failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void rzv2m_csi_remove(struct platform_device *pdev)\n{\n\tstruct rzv2m_csi_priv *csi = platform_get_drvdata(pdev);\n\n\tspi_unregister_controller(csi->controller);\n\trzv2m_csi_sw_reset(csi, 1);\n\tclk_disable_unprepare(csi->csiclk);\n}\n\nstatic const struct of_device_id rzv2m_csi_match[] = {\n\t{ .compatible = \"renesas,rzv2m-csi\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzv2m_csi_match);\n\nstatic struct platform_driver rzv2m_csi_drv = {\n\t.probe = rzv2m_csi_probe,\n\t.remove_new = rzv2m_csi_remove,\n\t.driver = {\n\t\t.name = \"rzv2m_csi\",\n\t\t.of_match_table = rzv2m_csi_match,\n\t},\n};\nmodule_platform_driver(rzv2m_csi_drv);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fabrizio Castro <castro.fabrizio.jz@renesas.com>\");\nMODULE_DESCRIPTION(\"Clocked Serial Interface Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}