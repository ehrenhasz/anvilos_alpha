{
  "module_name": "spi-xilinx.c",
  "hash_id": "776f9f10627b56f0d13f8f7cb153ee44fa8df0cedc60f5eceae5827d1a154d9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-xilinx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/xilinx_spi.h>\n#include <linux/io.h>\n\n#define XILINX_SPI_MAX_CS\t32\n\n#define XILINX_SPI_NAME \"xilinx_spi\"\n\n \n#define XSPI_CR_OFFSET\t\t0x60\t \n\n#define XSPI_CR_LOOP\t\t0x01\n#define XSPI_CR_ENABLE\t\t0x02\n#define XSPI_CR_MASTER_MODE\t0x04\n#define XSPI_CR_CPOL\t\t0x08\n#define XSPI_CR_CPHA\t\t0x10\n#define XSPI_CR_MODE_MASK\t(XSPI_CR_CPHA | XSPI_CR_CPOL | \\\n\t\t\t\t XSPI_CR_LSB_FIRST | XSPI_CR_LOOP)\n#define XSPI_CR_TXFIFO_RESET\t0x20\n#define XSPI_CR_RXFIFO_RESET\t0x40\n#define XSPI_CR_MANUAL_SSELECT\t0x80\n#define XSPI_CR_TRANS_INHIBIT\t0x100\n#define XSPI_CR_LSB_FIRST\t0x200\n\n#define XSPI_SR_OFFSET\t\t0x64\t \n\n#define XSPI_SR_RX_EMPTY_MASK\t0x01\t \n#define XSPI_SR_RX_FULL_MASK\t0x02\t \n#define XSPI_SR_TX_EMPTY_MASK\t0x04\t \n#define XSPI_SR_TX_FULL_MASK\t0x08\t \n#define XSPI_SR_MODE_FAULT_MASK\t0x10\t \n\n#define XSPI_TXD_OFFSET\t\t0x68\t \n#define XSPI_RXD_OFFSET\t\t0x6c\t \n\n#define XSPI_SSR_OFFSET\t\t0x70\t \n\n \n#define XIPIF_V123B_DGIER_OFFSET\t0x1c\t \n#define XIPIF_V123B_GINTR_ENABLE\t0x80000000\n\n#define XIPIF_V123B_IISR_OFFSET\t\t0x20\t \n#define XIPIF_V123B_IIER_OFFSET\t\t0x28\t \n\n#define XSPI_INTR_MODE_FAULT\t\t0x01\t \n#define XSPI_INTR_SLAVE_MODE_FAULT\t0x02\t \n#define XSPI_INTR_TX_EMPTY\t\t0x04\t \n#define XSPI_INTR_TX_UNDERRUN\t\t0x08\t \n#define XSPI_INTR_RX_FULL\t\t0x10\t \n#define XSPI_INTR_RX_OVERRUN\t\t0x20\t \n#define XSPI_INTR_TX_HALF_EMPTY\t\t0x40\t \n\n#define XIPIF_V123B_RESETR_OFFSET\t0x40\t \n#define XIPIF_V123B_RESET_MASK\t\t0x0a\t \n\nstruct xilinx_spi {\n\t \n\tstruct spi_bitbang bitbang;\n\tstruct completion done;\n\tvoid __iomem\t*regs;\t \n\n\tint\t\tirq;\n\tbool force_irq;\t\t \n\tu8 *rx_ptr;\t\t \n\tconst u8 *tx_ptr;\t \n\tu8 bytes_per_word;\n\tint buffer_size;\t \n\tu32 cs_inactive;\t \n\tunsigned int (*read_fn)(void __iomem *);\n\tvoid (*write_fn)(u32, void __iomem *);\n};\n\nstatic void xspi_write32(u32 val, void __iomem *addr)\n{\n\tiowrite32(val, addr);\n}\n\nstatic unsigned int xspi_read32(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\nstatic void xspi_write32_be(u32 val, void __iomem *addr)\n{\n\tiowrite32be(val, addr);\n}\n\nstatic unsigned int xspi_read32_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic void xilinx_spi_tx(struct xilinx_spi *xspi)\n{\n\tu32 data = 0;\n\n\tif (!xspi->tx_ptr) {\n\t\txspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);\n\t\treturn;\n\t}\n\n\tswitch (xspi->bytes_per_word) {\n\tcase 1:\n\t\tdata = *(u8 *)(xspi->tx_ptr);\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *)(xspi->tx_ptr);\n\t\tbreak;\n\tcase 4:\n\t\tdata = *(u32 *)(xspi->tx_ptr);\n\t\tbreak;\n\t}\n\n\txspi->write_fn(data, xspi->regs + XSPI_TXD_OFFSET);\n\txspi->tx_ptr += xspi->bytes_per_word;\n}\n\nstatic void xilinx_spi_rx(struct xilinx_spi *xspi)\n{\n\tu32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);\n\n\tif (!xspi->rx_ptr)\n\t\treturn;\n\n\tswitch (xspi->bytes_per_word) {\n\tcase 1:\n\t\t*(u8 *)(xspi->rx_ptr) = data;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)(xspi->rx_ptr) = data;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)(xspi->rx_ptr) = data;\n\t\tbreak;\n\t}\n\n\txspi->rx_ptr += xspi->bytes_per_word;\n}\n\nstatic void xspi_init_hw(struct xilinx_spi *xspi)\n{\n\tvoid __iomem *regs_base = xspi->regs;\n\n\t \n\txspi->write_fn(XIPIF_V123B_RESET_MASK,\n\t\tregs_base + XIPIF_V123B_RESETR_OFFSET);\n\t \n\txspi->write_fn(XSPI_INTR_TX_EMPTY,\n\t\t\tregs_base + XIPIF_V123B_IIER_OFFSET);\n\t \n\txspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);\n\t \n\txspi->write_fn(0xffff, regs_base + XSPI_SSR_OFFSET);\n\t \n\txspi->write_fn(XSPI_CR_MANUAL_SSELECT |\tXSPI_CR_MASTER_MODE |\n\t\tXSPI_CR_ENABLE | XSPI_CR_TXFIFO_RESET |\tXSPI_CR_RXFIFO_RESET,\n\t\tregs_base + XSPI_CR_OFFSET);\n}\n\nstatic void xilinx_spi_chipselect(struct spi_device *spi, int is_on)\n{\n\tstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\n\tu16 cr;\n\tu32 cs;\n\n\tif (is_on == BITBANG_CS_INACTIVE) {\n\t\t \n\t\txspi->write_fn(xspi->cs_inactive, xspi->regs + XSPI_SSR_OFFSET);\n\t\treturn;\n\t}\n\n\t \n\tcr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET)\t& ~XSPI_CR_MODE_MASK;\n\tif (spi->mode & SPI_CPHA)\n\t\tcr |= XSPI_CR_CPHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tcr |= XSPI_CR_CPOL;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tcr |= XSPI_CR_LSB_FIRST;\n\tif (spi->mode & SPI_LOOP)\n\t\tcr |= XSPI_CR_LOOP;\n\txspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\n\n\t \n\n\tcs = xspi->cs_inactive;\n\tcs ^= BIT(spi_get_chipselect(spi, 0));\n\n\t \n\txspi->write_fn(cs, xspi->regs + XSPI_SSR_OFFSET);\n}\n\n \nstatic int xilinx_spi_setup_transfer(struct spi_device *spi,\n\t\tstruct spi_transfer *t)\n{\n\tstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\txspi->cs_inactive &= ~BIT(spi_get_chipselect(spi, 0));\n\telse\n\t\txspi->cs_inactive |= BIT(spi_get_chipselect(spi, 0));\n\n\treturn 0;\n}\n\nstatic int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\n\tint remaining_words;\t \n\tbool use_irq = false;\n\tu16 cr = 0;\n\n\t \n\n\txspi->tx_ptr = t->tx_buf;\n\txspi->rx_ptr = t->rx_buf;\n\tremaining_words = t->len / xspi->bytes_per_word;\n\n\tif (xspi->irq >= 0 &&\n\t    (xspi->force_irq || remaining_words > xspi->buffer_size)) {\n\t\tu32 isr;\n\t\tuse_irq = true;\n\t\t \n\t\tcr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);\n\t\txspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,\n\t\t\t       xspi->regs + XSPI_CR_OFFSET);\n\t\t \n\t\tisr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);\n\t\tif (isr)\n\t\t\txspi->write_fn(isr,\n\t\t\t\t       xspi->regs + XIPIF_V123B_IISR_OFFSET);\n\t\t \n\t\txspi->write_fn(XIPIF_V123B_GINTR_ENABLE,\n\t\t\t\txspi->regs + XIPIF_V123B_DGIER_OFFSET);\n\t\treinit_completion(&xspi->done);\n\t}\n\n\twhile (remaining_words) {\n\t\tint n_words, tx_words, rx_words;\n\t\tu32 sr;\n\t\tint stalled;\n\n\t\tn_words = min(remaining_words, xspi->buffer_size);\n\n\t\ttx_words = n_words;\n\t\twhile (tx_words--)\n\t\t\txilinx_spi_tx(xspi);\n\n\t\t \n\n\t\tif (use_irq) {\n\t\t\txspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\n\t\t\twait_for_completion(&xspi->done);\n\t\t\t \n\t\t\txspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,\n\t\t\t\t       xspi->regs + XSPI_CR_OFFSET);\n\t\t\tsr = XSPI_SR_TX_EMPTY_MASK;\n\t\t} else\n\t\t\tsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\n\n\t\t \n\t\trx_words = n_words;\n\t\tstalled = 10;\n\t\twhile (rx_words) {\n\t\t\tif (rx_words == n_words && !(stalled--) &&\n\t\t\t    !(sr & XSPI_SR_TX_EMPTY_MASK) &&\n\t\t\t    (sr & XSPI_SR_RX_EMPTY_MASK)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"Detected stall. Check C_SPI_MODE and C_SPI_MEMORY\\n\");\n\t\t\t\txspi_init_hw(xspi);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif ((sr & XSPI_SR_TX_EMPTY_MASK) && (rx_words > 1)) {\n\t\t\t\txilinx_spi_rx(xspi);\n\t\t\t\trx_words--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\n\t\t\tif (!(sr & XSPI_SR_RX_EMPTY_MASK)) {\n\t\t\t\txilinx_spi_rx(xspi);\n\t\t\t\trx_words--;\n\t\t\t}\n\t\t}\n\n\t\tremaining_words -= n_words;\n\t}\n\n\tif (use_irq) {\n\t\txspi->write_fn(0, xspi->regs + XIPIF_V123B_DGIER_OFFSET);\n\t\txspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\n\t}\n\n\treturn t->len;\n}\n\n\n \nstatic irqreturn_t xilinx_spi_irq(int irq, void *dev_id)\n{\n\tstruct xilinx_spi *xspi = dev_id;\n\tu32 ipif_isr;\n\n\t \n\tipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);\n\txspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);\n\n\tif (ipif_isr & XSPI_INTR_TX_EMPTY) {\t \n\t\tcomplete(&xspi->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int xilinx_spi_find_buffer_size(struct xilinx_spi *xspi)\n{\n\tu8 sr;\n\tint n_words = 0;\n\n\t \n\txspi->write_fn(XIPIF_V123B_RESET_MASK,\n\t\txspi->regs + XIPIF_V123B_RESETR_OFFSET);\n\n\t \n\tdo {\n\t\txspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);\n\t\tsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\n\t\tn_words++;\n\t} while (!(sr & XSPI_SR_TX_FULL_MASK));\n\n\treturn n_words;\n}\n\nstatic const struct of_device_id xilinx_spi_of_match[] = {\n\t{ .compatible = \"xlnx,axi-quad-spi-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-spi-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-spi-2.00.b\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, xilinx_spi_of_match);\n\nstatic int xilinx_spi_probe(struct platform_device *pdev)\n{\n\tstruct xilinx_spi *xspi;\n\tstruct xspi_platform_data *pdata;\n\tstruct resource *res;\n\tint ret, num_cs = 0, bits_per_word;\n\tstruct spi_master *master;\n\tbool force_irq = false;\n\tu32 tmp;\n\tu8 i;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\tnum_cs = pdata->num_chipselect;\n\t\tbits_per_word = pdata->bits_per_word;\n\t\tforce_irq = pdata->force_irq;\n\t} else {\n\t\tof_property_read_u32(pdev->dev.of_node, \"xlnx,num-ss-bits\",\n\t\t\t\t\t  &num_cs);\n\t\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t   \"xlnx,num-transfer-bits\",\n\t\t\t\t\t   &bits_per_word);\n\t\tif (ret)\n\t\t\tbits_per_word = 8;\n\t}\n\n\tif (!num_cs) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Missing slave select configuration data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_cs > XILINX_SPI_MAX_CS) {\n\t\tdev_err(&pdev->dev, \"Invalid number of spi slaves\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmaster = devm_spi_alloc_master(&pdev->dev, sizeof(struct xilinx_spi));\n\tif (!master)\n\t\treturn -ENODEV;\n\n\t \n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_LOOP |\n\t\t\t    SPI_CS_HIGH;\n\n\txspi = spi_master_get_devdata(master);\n\txspi->cs_inactive = 0xffffffff;\n\txspi->bitbang.master = master;\n\txspi->bitbang.chipselect = xilinx_spi_chipselect;\n\txspi->bitbang.setup_transfer = xilinx_spi_setup_transfer;\n\txspi->bitbang.txrx_bufs = xilinx_spi_txrx_bufs;\n\tinit_completion(&xspi->done);\n\n\txspi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(xspi->regs))\n\t\treturn PTR_ERR(xspi->regs);\n\n\tmaster->bus_num = pdev->id;\n\tmaster->num_chipselect = num_cs;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\n\t \n\txspi->read_fn = xspi_read32;\n\txspi->write_fn = xspi_write32;\n\n\txspi->write_fn(XSPI_CR_LOOP, xspi->regs + XSPI_CR_OFFSET);\n\ttmp = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);\n\ttmp &= XSPI_CR_LOOP;\n\tif (tmp != XSPI_CR_LOOP) {\n\t\txspi->read_fn = xspi_read32_be;\n\t\txspi->write_fn = xspi_write32_be;\n\t}\n\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(bits_per_word);\n\txspi->bytes_per_word = bits_per_word / 8;\n\txspi->buffer_size = xilinx_spi_find_buffer_size(xspi);\n\n\txspi->irq = platform_get_irq(pdev, 0);\n\tif (xspi->irq < 0 && xspi->irq != -ENXIO) {\n\t\treturn xspi->irq;\n\t} else if (xspi->irq >= 0) {\n\t\t \n\t\tret = devm_request_irq(&pdev->dev, xspi->irq, xilinx_spi_irq, 0,\n\t\t\t\tdev_name(&pdev->dev), xspi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\txspi->force_irq = force_irq;\n\t}\n\n\t \n\txspi_init_hw(xspi);\n\n\tret = spi_bitbang_start(&xspi->bitbang);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_bitbang_start FAILED\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"at %pR, irq=%d\\n\", res, xspi->irq);\n\n\tif (pdata) {\n\t\tfor (i = 0; i < pdata->num_devices; i++)\n\t\t\tspi_new_device(master, pdata->devices + i);\n\t}\n\n\tplatform_set_drvdata(pdev, master);\n\treturn 0;\n}\n\nstatic void xilinx_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct xilinx_spi *xspi = spi_master_get_devdata(master);\n\tvoid __iomem *regs_base = xspi->regs;\n\n\tspi_bitbang_stop(&xspi->bitbang);\n\n\t \n\txspi->write_fn(0, regs_base + XIPIF_V123B_IIER_OFFSET);\n\t \n\txspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);\n\n\tspi_master_put(xspi->bitbang.master);\n}\n\n \nMODULE_ALIAS(\"platform:\" XILINX_SPI_NAME);\n\nstatic struct platform_driver xilinx_spi_driver = {\n\t.probe = xilinx_spi_probe,\n\t.remove_new = xilinx_spi_remove,\n\t.driver = {\n\t\t.name = XILINX_SPI_NAME,\n\t\t.of_match_table = xilinx_spi_of_match,\n\t},\n};\nmodule_platform_driver(xilinx_spi_driver);\n\nMODULE_AUTHOR(\"MontaVista Software, Inc. <source@mvista.com>\");\nMODULE_DESCRIPTION(\"Xilinx SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}