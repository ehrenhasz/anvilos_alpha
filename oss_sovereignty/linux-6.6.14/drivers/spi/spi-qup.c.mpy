{
  "module_name": "spi-qup.c",
  "hash_id": "034286930aa0450c30b7234c2ba23dd012376faed94f7f681558716fc7d79330",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-qup.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n\n#define QUP_CONFIG\t\t\t0x0000\n#define QUP_STATE\t\t\t0x0004\n#define QUP_IO_M_MODES\t\t\t0x0008\n#define QUP_SW_RESET\t\t\t0x000c\n#define QUP_OPERATIONAL\t\t\t0x0018\n#define QUP_ERROR_FLAGS\t\t\t0x001c\n#define QUP_ERROR_FLAGS_EN\t\t0x0020\n#define QUP_OPERATIONAL_MASK\t\t0x0028\n#define QUP_HW_VERSION\t\t\t0x0030\n#define QUP_MX_OUTPUT_CNT\t\t0x0100\n#define QUP_OUTPUT_FIFO\t\t\t0x0110\n#define QUP_MX_WRITE_CNT\t\t0x0150\n#define QUP_MX_INPUT_CNT\t\t0x0200\n#define QUP_MX_READ_CNT\t\t\t0x0208\n#define QUP_INPUT_FIFO\t\t\t0x0218\n\n#define SPI_CONFIG\t\t\t0x0300\n#define SPI_IO_CONTROL\t\t\t0x0304\n#define SPI_ERROR_FLAGS\t\t\t0x0308\n#define SPI_ERROR_FLAGS_EN\t\t0x030c\n\n \n#define QUP_CONFIG_SPI_MODE\t\t(1 << 8)\n#define QUP_CONFIG_CLOCK_AUTO_GATE\tBIT(13)\n#define QUP_CONFIG_NO_INPUT\t\tBIT(7)\n#define QUP_CONFIG_NO_OUTPUT\t\tBIT(6)\n#define QUP_CONFIG_N\t\t\t0x001f\n\n \n#define QUP_STATE_VALID\t\t\tBIT(2)\n#define QUP_STATE_RESET\t\t\t0\n#define QUP_STATE_RUN\t\t\t1\n#define QUP_STATE_PAUSE\t\t\t3\n#define QUP_STATE_MASK\t\t\t3\n#define QUP_STATE_CLEAR\t\t\t2\n\n#define QUP_HW_VERSION_2_1_1\t\t0x20010001\n\n \n#define QUP_IO_M_PACK_EN\t\tBIT(15)\n#define QUP_IO_M_UNPACK_EN\t\tBIT(14)\n#define QUP_IO_M_INPUT_MODE_MASK_SHIFT\t12\n#define QUP_IO_M_OUTPUT_MODE_MASK_SHIFT\t10\n#define QUP_IO_M_INPUT_MODE_MASK\t(3 << QUP_IO_M_INPUT_MODE_MASK_SHIFT)\n#define QUP_IO_M_OUTPUT_MODE_MASK\t(3 << QUP_IO_M_OUTPUT_MODE_MASK_SHIFT)\n\n#define QUP_IO_M_OUTPUT_BLOCK_SIZE(x)\t(((x) & (0x03 << 0)) >> 0)\n#define QUP_IO_M_OUTPUT_FIFO_SIZE(x)\t(((x) & (0x07 << 2)) >> 2)\n#define QUP_IO_M_INPUT_BLOCK_SIZE(x)\t(((x) & (0x03 << 5)) >> 5)\n#define QUP_IO_M_INPUT_FIFO_SIZE(x)\t(((x) & (0x07 << 7)) >> 7)\n\n#define QUP_IO_M_MODE_FIFO\t\t0\n#define QUP_IO_M_MODE_BLOCK\t\t1\n#define QUP_IO_M_MODE_DMOV\t\t2\n#define QUP_IO_M_MODE_BAM\t\t3\n\n \n#define QUP_OP_IN_BLOCK_READ_REQ\tBIT(13)\n#define QUP_OP_OUT_BLOCK_WRITE_REQ\tBIT(12)\n#define QUP_OP_MAX_INPUT_DONE_FLAG\tBIT(11)\n#define QUP_OP_MAX_OUTPUT_DONE_FLAG\tBIT(10)\n#define QUP_OP_IN_SERVICE_FLAG\t\tBIT(9)\n#define QUP_OP_OUT_SERVICE_FLAG\t\tBIT(8)\n#define QUP_OP_IN_FIFO_FULL\t\tBIT(7)\n#define QUP_OP_OUT_FIFO_FULL\t\tBIT(6)\n#define QUP_OP_IN_FIFO_NOT_EMPTY\tBIT(5)\n#define QUP_OP_OUT_FIFO_NOT_EMPTY\tBIT(4)\n\n \n#define QUP_ERROR_OUTPUT_OVER_RUN\tBIT(5)\n#define QUP_ERROR_INPUT_UNDER_RUN\tBIT(4)\n#define QUP_ERROR_OUTPUT_UNDER_RUN\tBIT(3)\n#define QUP_ERROR_INPUT_OVER_RUN\tBIT(2)\n\n \n#define SPI_CONFIG_HS_MODE\t\tBIT(10)\n#define SPI_CONFIG_INPUT_FIRST\t\tBIT(9)\n#define SPI_CONFIG_LOOPBACK\t\tBIT(8)\n\n \n#define SPI_IO_C_FORCE_CS\t\tBIT(11)\n#define SPI_IO_C_CLK_IDLE_HIGH\t\tBIT(10)\n#define SPI_IO_C_MX_CS_MODE\t\tBIT(8)\n#define SPI_IO_C_CS_N_POLARITY_0\tBIT(4)\n#define SPI_IO_C_CS_SELECT(x)\t\t(((x) & 3) << 2)\n#define SPI_IO_C_CS_SELECT_MASK\t\t0x000c\n#define SPI_IO_C_TRISTATE_CS\t\tBIT(1)\n#define SPI_IO_C_NO_TRI_STATE\t\tBIT(0)\n\n \n#define SPI_ERROR_CLK_OVER_RUN\t\tBIT(1)\n#define SPI_ERROR_CLK_UNDER_RUN\t\tBIT(0)\n\n#define SPI_NUM_CHIPSELECTS\t\t4\n\n#define SPI_MAX_XFER\t\t\t(SZ_64K - 64)\n\n \n#define SPI_HS_MIN_RATE\t\t\t26000000\n#define SPI_MAX_RATE\t\t\t50000000\n\n#define SPI_DELAY_THRESHOLD\t\t1\n#define SPI_DELAY_RETRY\t\t\t10\n\nstruct spi_qup {\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*cclk;\t \n\tstruct clk\t\t*iclk;\t \n\tint\t\t\tirq;\n\tspinlock_t\t\tlock;\n\n\tint\t\t\tin_fifo_sz;\n\tint\t\t\tout_fifo_sz;\n\tint\t\t\tin_blk_sz;\n\tint\t\t\tout_blk_sz;\n\n\tstruct spi_transfer\t*xfer;\n\tstruct completion\tdone;\n\tint\t\t\terror;\n\tint\t\t\tw_size;\t \n\tint\t\t\tn_words;\n\tint\t\t\ttx_bytes;\n\tint\t\t\trx_bytes;\n\tconst u8\t\t*tx_buf;\n\tu8\t\t\t*rx_buf;\n\tint\t\t\tqup_v1;\n\n\tint\t\t\tmode;\n\tstruct dma_slave_config\trx_conf;\n\tstruct dma_slave_config\ttx_conf;\n};\n\nstatic int spi_qup_io_config(struct spi_device *spi, struct spi_transfer *xfer);\n\nstatic inline bool spi_qup_is_flag_set(struct spi_qup *controller, u32 flag)\n{\n\tu32 opflag = readl_relaxed(controller->base + QUP_OPERATIONAL);\n\n\treturn (opflag & flag) != 0;\n}\n\nstatic inline bool spi_qup_is_dma_xfer(int mode)\n{\n\tif (mode == QUP_IO_M_MODE_DMOV || mode == QUP_IO_M_MODE_BAM)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline unsigned int spi_qup_len(struct spi_qup *controller)\n{\n\treturn controller->n_words * controller->w_size;\n}\n\nstatic inline bool spi_qup_is_valid_state(struct spi_qup *controller)\n{\n\tu32 opstate = readl_relaxed(controller->base + QUP_STATE);\n\n\treturn opstate & QUP_STATE_VALID;\n}\n\nstatic int spi_qup_set_state(struct spi_qup *controller, u32 state)\n{\n\tunsigned long loop;\n\tu32 cur_state;\n\n\tloop = 0;\n\twhile (!spi_qup_is_valid_state(controller)) {\n\n\t\tusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\n\n\t\tif (++loop > SPI_DELAY_RETRY)\n\t\t\treturn -EIO;\n\t}\n\n\tif (loop)\n\t\tdev_dbg(controller->dev, \"invalid state for %ld,us %d\\n\",\n\t\t\tloop, state);\n\n\tcur_state = readl_relaxed(controller->base + QUP_STATE);\n\t \n\tif (((cur_state & QUP_STATE_MASK) == QUP_STATE_PAUSE) &&\n\t    (state == QUP_STATE_RESET)) {\n\t\twritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\n\t\twritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\n\t} else {\n\t\tcur_state &= ~QUP_STATE_MASK;\n\t\tcur_state |= state;\n\t\twritel_relaxed(cur_state, controller->base + QUP_STATE);\n\t}\n\n\tloop = 0;\n\twhile (!spi_qup_is_valid_state(controller)) {\n\n\t\tusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\n\n\t\tif (++loop > SPI_DELAY_RETRY)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void spi_qup_read_from_fifo(struct spi_qup *controller, u32 num_words)\n{\n\tu8 *rx_buf = controller->rx_buf;\n\tint i, shift, num_bytes;\n\tu32 word;\n\n\tfor (; num_words; num_words--) {\n\n\t\tword = readl_relaxed(controller->base + QUP_INPUT_FIFO);\n\n\t\tnum_bytes = min_t(int, spi_qup_len(controller) -\n\t\t\t\t       controller->rx_bytes,\n\t\t\t\t       controller->w_size);\n\n\t\tif (!rx_buf) {\n\t\t\tcontroller->rx_bytes += num_bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < num_bytes; i++, controller->rx_bytes++) {\n\t\t\t \n\t\t\tshift = BITS_PER_BYTE;\n\t\t\tshift *= (controller->w_size - i - 1);\n\t\t\trx_buf[controller->rx_bytes] = word >> shift;\n\t\t}\n\t}\n}\n\nstatic void spi_qup_read(struct spi_qup *controller, u32 *opflags)\n{\n\tu32 remainder, words_per_block, num_words;\n\tbool is_block_mode = controller->mode == QUP_IO_M_MODE_BLOCK;\n\n\tremainder = DIV_ROUND_UP(spi_qup_len(controller) - controller->rx_bytes,\n\t\t\t\t controller->w_size);\n\twords_per_block = controller->in_blk_sz >> 2;\n\n\tdo {\n\t\t \n\t\twritel_relaxed(QUP_OP_IN_SERVICE_FLAG,\n\t\t\t       controller->base + QUP_OPERATIONAL);\n\n\t\tif (!remainder)\n\t\t\tgoto exit;\n\n\t\tif (is_block_mode) {\n\t\t\tnum_words = (remainder > words_per_block) ?\n\t\t\t\t\twords_per_block : remainder;\n\t\t} else {\n\t\t\tif (!spi_qup_is_flag_set(controller,\n\t\t\t\t\t\t QUP_OP_IN_FIFO_NOT_EMPTY))\n\t\t\t\tbreak;\n\n\t\t\tnum_words = 1;\n\t\t}\n\n\t\t \n\t\tspi_qup_read_from_fifo(controller, num_words);\n\n\t\tremainder -= num_words;\n\n\t\t \n\t\tif (is_block_mode && !spi_qup_is_flag_set(controller,\n\t\t\t\t\tQUP_OP_IN_BLOCK_READ_REQ))\n\t\t\tbreak;\n\n\t} while (remainder);\n\n\t \nexit:\n\tif (!remainder) {\n\t\t*opflags = readl_relaxed(controller->base + QUP_OPERATIONAL);\n\t\tif (is_block_mode && *opflags & QUP_OP_MAX_INPUT_DONE_FLAG)\n\t\t\twritel_relaxed(QUP_OP_IN_SERVICE_FLAG,\n\t\t\t\t       controller->base + QUP_OPERATIONAL);\n\t}\n}\n\nstatic void spi_qup_write_to_fifo(struct spi_qup *controller, u32 num_words)\n{\n\tconst u8 *tx_buf = controller->tx_buf;\n\tint i, num_bytes;\n\tu32 word, data;\n\n\tfor (; num_words; num_words--) {\n\t\tword = 0;\n\n\t\tnum_bytes = min_t(int, spi_qup_len(controller) -\n\t\t\t\t       controller->tx_bytes,\n\t\t\t\t       controller->w_size);\n\t\tif (tx_buf)\n\t\t\tfor (i = 0; i < num_bytes; i++) {\n\t\t\t\tdata = tx_buf[controller->tx_bytes + i];\n\t\t\t\tword |= data << (BITS_PER_BYTE * (3 - i));\n\t\t\t}\n\n\t\tcontroller->tx_bytes += num_bytes;\n\n\t\twritel_relaxed(word, controller->base + QUP_OUTPUT_FIFO);\n\t}\n}\n\nstatic void spi_qup_dma_done(void *data)\n{\n\tstruct spi_qup *qup = data;\n\n\tcomplete(&qup->done);\n}\n\nstatic void spi_qup_write(struct spi_qup *controller)\n{\n\tbool is_block_mode = controller->mode == QUP_IO_M_MODE_BLOCK;\n\tu32 remainder, words_per_block, num_words;\n\n\tremainder = DIV_ROUND_UP(spi_qup_len(controller) - controller->tx_bytes,\n\t\t\t\t controller->w_size);\n\twords_per_block = controller->out_blk_sz >> 2;\n\n\tdo {\n\t\t \n\t\twritel_relaxed(QUP_OP_OUT_SERVICE_FLAG,\n\t\t\t       controller->base + QUP_OPERATIONAL);\n\n\t\t \n\t\tif (!remainder)\n\t\t\treturn;\n\n\t\tif (is_block_mode) {\n\t\t\tnum_words = (remainder > words_per_block) ?\n\t\t\t\twords_per_block : remainder;\n\t\t} else {\n\t\t\tif (spi_qup_is_flag_set(controller,\n\t\t\t\t\t\tQUP_OP_OUT_FIFO_FULL))\n\t\t\t\tbreak;\n\n\t\t\tnum_words = 1;\n\t\t}\n\n\t\tspi_qup_write_to_fifo(controller, num_words);\n\n\t\tremainder -= num_words;\n\n\t\t \n\t\tif (is_block_mode && !spi_qup_is_flag_set(controller,\n\t\t\t\t\tQUP_OP_OUT_BLOCK_WRITE_REQ))\n\t\t\tbreak;\n\n\t} while (remainder);\n}\n\nstatic int spi_qup_prep_sg(struct spi_controller *host, struct scatterlist *sgl,\n\t\t\t   unsigned int nents, enum dma_transfer_direction dir,\n\t\t\t   dma_async_tx_callback callback)\n{\n\tstruct spi_qup *qup = spi_controller_get_devdata(host);\n\tunsigned long flags = DMA_PREP_INTERRUPT | DMA_PREP_FENCE;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan *chan;\n\tdma_cookie_t cookie;\n\n\tif (dir == DMA_MEM_TO_DEV)\n\t\tchan = host->dma_tx;\n\telse\n\t\tchan = host->dma_rx;\n\n\tdesc = dmaengine_prep_slave_sg(chan, sgl, nents, dir, flags);\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn desc ? PTR_ERR(desc) : -EINVAL;\n\n\tdesc->callback = callback;\n\tdesc->callback_param = qup;\n\n\tcookie = dmaengine_submit(desc);\n\n\treturn dma_submit_error(cookie);\n}\n\nstatic void spi_qup_dma_terminate(struct spi_controller *host,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\tif (xfer->tx_buf)\n\t\tdmaengine_terminate_all(host->dma_tx);\n\tif (xfer->rx_buf)\n\t\tdmaengine_terminate_all(host->dma_rx);\n}\n\nstatic u32 spi_qup_sgl_get_nents_len(struct scatterlist *sgl, u32 max,\n\t\t\t\t     u32 *nents)\n{\n\tstruct scatterlist *sg;\n\tu32 total = 0;\n\n\tfor (sg = sgl; sg; sg = sg_next(sg)) {\n\t\tunsigned int len = sg_dma_len(sg);\n\n\t\t \n\t\tif (((total + len) < total) || ((total + len) > max))\n\t\t\tbreak;\n\n\t\ttotal += len;\n\t\t(*nents)++;\n\t}\n\n\treturn total;\n}\n\nstatic int spi_qup_do_dma(struct spi_device *spi, struct spi_transfer *xfer,\n\t\t\t  unsigned long timeout)\n{\n\tdma_async_tx_callback rx_done = NULL, tx_done = NULL;\n\tstruct spi_controller *host = spi->controller;\n\tstruct spi_qup *qup = spi_controller_get_devdata(host);\n\tstruct scatterlist *tx_sgl, *rx_sgl;\n\tint ret;\n\n\tif (xfer->rx_buf)\n\t\trx_done = spi_qup_dma_done;\n\telse if (xfer->tx_buf)\n\t\ttx_done = spi_qup_dma_done;\n\n\trx_sgl = xfer->rx_sg.sgl;\n\ttx_sgl = xfer->tx_sg.sgl;\n\n\tdo {\n\t\tu32 rx_nents = 0, tx_nents = 0;\n\n\t\tif (rx_sgl)\n\t\t\tqup->n_words = spi_qup_sgl_get_nents_len(rx_sgl,\n\t\t\t\t\tSPI_MAX_XFER, &rx_nents) / qup->w_size;\n\t\tif (tx_sgl)\n\t\t\tqup->n_words = spi_qup_sgl_get_nents_len(tx_sgl,\n\t\t\t\t\tSPI_MAX_XFER, &tx_nents) / qup->w_size;\n\t\tif (!qup->n_words)\n\t\t\treturn -EIO;\n\n\t\tret = spi_qup_io_config(spi, xfer);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = spi_qup_set_state(qup, QUP_STATE_RUN);\n\t\tif (ret) {\n\t\t\tdev_warn(qup->dev, \"cannot set RUN state\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (rx_sgl) {\n\t\t\tret = spi_qup_prep_sg(host, rx_sgl, rx_nents,\n\t\t\t\t\t      DMA_DEV_TO_MEM, rx_done);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdma_async_issue_pending(host->dma_rx);\n\t\t}\n\n\t\tif (tx_sgl) {\n\t\t\tret = spi_qup_prep_sg(host, tx_sgl, tx_nents,\n\t\t\t\t\t      DMA_MEM_TO_DEV, tx_done);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tdma_async_issue_pending(host->dma_tx);\n\t\t}\n\n\t\tif (!wait_for_completion_timeout(&qup->done, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tfor (; rx_sgl && rx_nents--; rx_sgl = sg_next(rx_sgl))\n\t\t\t;\n\t\tfor (; tx_sgl && tx_nents--; tx_sgl = sg_next(tx_sgl))\n\t\t\t;\n\n\t} while (rx_sgl || tx_sgl);\n\n\treturn 0;\n}\n\nstatic int spi_qup_do_pio(struct spi_device *spi, struct spi_transfer *xfer,\n\t\t\t  unsigned long timeout)\n{\n\tstruct spi_controller *host = spi->controller;\n\tstruct spi_qup *qup = spi_controller_get_devdata(host);\n\tint ret, n_words, iterations, offset = 0;\n\n\tn_words = qup->n_words;\n\titerations = n_words / SPI_MAX_XFER;  \n\tqup->rx_buf = xfer->rx_buf;\n\tqup->tx_buf = xfer->tx_buf;\n\n\tdo {\n\t\tif (iterations)\n\t\t\tqup->n_words = SPI_MAX_XFER;\n\t\telse\n\t\t\tqup->n_words = n_words % SPI_MAX_XFER;\n\n\t\tif (qup->tx_buf && offset)\n\t\t\tqup->tx_buf = xfer->tx_buf + offset * SPI_MAX_XFER;\n\n\t\tif (qup->rx_buf && offset)\n\t\t\tqup->rx_buf = xfer->rx_buf + offset * SPI_MAX_XFER;\n\n\t\t \n\t\tif (qup->n_words <= (qup->in_fifo_sz / sizeof(u32)))\n\t\t\tqup->mode = QUP_IO_M_MODE_FIFO;\n\n\t\tret = spi_qup_io_config(spi, xfer);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = spi_qup_set_state(qup, QUP_STATE_RUN);\n\t\tif (ret) {\n\t\t\tdev_warn(qup->dev, \"cannot set RUN state\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = spi_qup_set_state(qup, QUP_STATE_PAUSE);\n\t\tif (ret) {\n\t\t\tdev_warn(qup->dev, \"cannot set PAUSE state\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (qup->mode == QUP_IO_M_MODE_FIFO)\n\t\t\tspi_qup_write(qup);\n\n\t\tret = spi_qup_set_state(qup, QUP_STATE_RUN);\n\t\tif (ret) {\n\t\t\tdev_warn(qup->dev, \"cannot set RUN state\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!wait_for_completion_timeout(&qup->done, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\toffset++;\n\t} while (iterations--);\n\n\treturn 0;\n}\n\nstatic bool spi_qup_data_pending(struct spi_qup *controller)\n{\n\tunsigned int remainder_tx, remainder_rx;\n\n\tremainder_tx = DIV_ROUND_UP(spi_qup_len(controller) -\n\t\t\t\t    controller->tx_bytes, controller->w_size);\n\n\tremainder_rx = DIV_ROUND_UP(spi_qup_len(controller) -\n\t\t\t\t    controller->rx_bytes, controller->w_size);\n\n\treturn remainder_tx || remainder_rx;\n}\n\nstatic irqreturn_t spi_qup_qup_irq(int irq, void *dev_id)\n{\n\tstruct spi_qup *controller = dev_id;\n\tu32 opflags, qup_err, spi_err;\n\tint error = 0;\n\n\tqup_err = readl_relaxed(controller->base + QUP_ERROR_FLAGS);\n\tspi_err = readl_relaxed(controller->base + SPI_ERROR_FLAGS);\n\topflags = readl_relaxed(controller->base + QUP_OPERATIONAL);\n\n\twritel_relaxed(qup_err, controller->base + QUP_ERROR_FLAGS);\n\twritel_relaxed(spi_err, controller->base + SPI_ERROR_FLAGS);\n\n\tif (qup_err) {\n\t\tif (qup_err & QUP_ERROR_OUTPUT_OVER_RUN)\n\t\t\tdev_warn(controller->dev, \"OUTPUT_OVER_RUN\\n\");\n\t\tif (qup_err & QUP_ERROR_INPUT_UNDER_RUN)\n\t\t\tdev_warn(controller->dev, \"INPUT_UNDER_RUN\\n\");\n\t\tif (qup_err & QUP_ERROR_OUTPUT_UNDER_RUN)\n\t\t\tdev_warn(controller->dev, \"OUTPUT_UNDER_RUN\\n\");\n\t\tif (qup_err & QUP_ERROR_INPUT_OVER_RUN)\n\t\t\tdev_warn(controller->dev, \"INPUT_OVER_RUN\\n\");\n\n\t\terror = -EIO;\n\t}\n\n\tif (spi_err) {\n\t\tif (spi_err & SPI_ERROR_CLK_OVER_RUN)\n\t\t\tdev_warn(controller->dev, \"CLK_OVER_RUN\\n\");\n\t\tif (spi_err & SPI_ERROR_CLK_UNDER_RUN)\n\t\t\tdev_warn(controller->dev, \"CLK_UNDER_RUN\\n\");\n\n\t\terror = -EIO;\n\t}\n\n\tspin_lock(&controller->lock);\n\tif (!controller->error)\n\t\tcontroller->error = error;\n\tspin_unlock(&controller->lock);\n\n\tif (spi_qup_is_dma_xfer(controller->mode)) {\n\t\twritel_relaxed(opflags, controller->base + QUP_OPERATIONAL);\n\t} else {\n\t\tif (opflags & QUP_OP_IN_SERVICE_FLAG)\n\t\t\tspi_qup_read(controller, &opflags);\n\n\t\tif (opflags & QUP_OP_OUT_SERVICE_FLAG)\n\t\t\tspi_qup_write(controller);\n\n\t\tif (!spi_qup_data_pending(controller))\n\t\t\tcomplete(&controller->done);\n\t}\n\n\tif (error)\n\t\tcomplete(&controller->done);\n\n\tif (opflags & QUP_OP_MAX_INPUT_DONE_FLAG) {\n\t\tif (!spi_qup_is_dma_xfer(controller->mode)) {\n\t\t\tif (spi_qup_data_pending(controller))\n\t\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tcomplete(&controller->done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int spi_qup_io_prep(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct spi_qup *controller = spi_controller_get_devdata(spi->controller);\n\tint ret;\n\n\tif (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {\n\t\tdev_err(controller->dev, \"too big size for loopback %d > %d\\n\",\n\t\t\txfer->len, controller->in_fifo_sz);\n\t\treturn -EIO;\n\t}\n\n\tret = clk_set_rate(controller->cclk, xfer->speed_hz);\n\tif (ret) {\n\t\tdev_err(controller->dev, \"fail to set frequency %d\",\n\t\t\txfer->speed_hz);\n\t\treturn -EIO;\n\t}\n\n\tcontroller->w_size = DIV_ROUND_UP(xfer->bits_per_word, 8);\n\tcontroller->n_words = xfer->len / controller->w_size;\n\n\tif (controller->n_words <= (controller->in_fifo_sz / sizeof(u32)))\n\t\tcontroller->mode = QUP_IO_M_MODE_FIFO;\n\telse if (spi->controller->can_dma &&\n\t\t spi->controller->can_dma(spi->controller, spi, xfer) &&\n\t\t spi->controller->cur_msg_mapped)\n\t\tcontroller->mode = QUP_IO_M_MODE_BAM;\n\telse\n\t\tcontroller->mode = QUP_IO_M_MODE_BLOCK;\n\n\treturn 0;\n}\n\n \nstatic int spi_qup_io_config(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct spi_qup *controller = spi_controller_get_devdata(spi->controller);\n\tu32 config, iomode, control;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&controller->lock, flags);\n\tcontroller->xfer     = xfer;\n\tcontroller->error    = 0;\n\tcontroller->rx_bytes = 0;\n\tcontroller->tx_bytes = 0;\n\tspin_unlock_irqrestore(&controller->lock, flags);\n\n\n\tif (spi_qup_set_state(controller, QUP_STATE_RESET)) {\n\t\tdev_err(controller->dev, \"cannot set RESET state\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (controller->mode) {\n\tcase QUP_IO_M_MODE_FIFO:\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_READ_CNT);\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_WRITE_CNT);\n\t\t \n\t\twritel_relaxed(0, controller->base + QUP_MX_INPUT_CNT);\n\t\twritel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);\n\t\tbreak;\n\tcase QUP_IO_M_MODE_BAM:\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_INPUT_CNT);\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_OUTPUT_CNT);\n\t\t \n\t\twritel_relaxed(0, controller->base + QUP_MX_READ_CNT);\n\t\twritel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);\n\n\t\tif (!controller->qup_v1) {\n\t\t\tvoid __iomem *input_cnt;\n\n\t\t\tinput_cnt = controller->base + QUP_MX_INPUT_CNT;\n\t\t\t \n\t\t\tif (xfer->tx_buf)\n\t\t\t\twritel_relaxed(0, input_cnt);\n\t\t\telse\n\t\t\t\twritel_relaxed(controller->n_words, input_cnt);\n\n\t\t\twritel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);\n\t\t}\n\t\tbreak;\n\tcase QUP_IO_M_MODE_BLOCK:\n\t\treinit_completion(&controller->done);\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_INPUT_CNT);\n\t\twritel_relaxed(controller->n_words,\n\t\t\t       controller->base + QUP_MX_OUTPUT_CNT);\n\t\t \n\t\twritel_relaxed(0, controller->base + QUP_MX_READ_CNT);\n\t\twritel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(controller->dev, \"unknown mode = %d\\n\",\n\t\t\t\tcontroller->mode);\n\t\treturn -EIO;\n\t}\n\n\tiomode = readl_relaxed(controller->base + QUP_IO_M_MODES);\n\t \n\tiomode &= ~(QUP_IO_M_INPUT_MODE_MASK | QUP_IO_M_OUTPUT_MODE_MASK);\n\n\tif (!spi_qup_is_dma_xfer(controller->mode))\n\t\tiomode &= ~(QUP_IO_M_PACK_EN | QUP_IO_M_UNPACK_EN);\n\telse\n\t\tiomode |= QUP_IO_M_PACK_EN | QUP_IO_M_UNPACK_EN;\n\n\tiomode |= (controller->mode << QUP_IO_M_OUTPUT_MODE_MASK_SHIFT);\n\tiomode |= (controller->mode << QUP_IO_M_INPUT_MODE_MASK_SHIFT);\n\n\twritel_relaxed(iomode, controller->base + QUP_IO_M_MODES);\n\n\tcontrol = readl_relaxed(controller->base + SPI_IO_CONTROL);\n\n\tif (spi->mode & SPI_CPOL)\n\t\tcontrol |= SPI_IO_C_CLK_IDLE_HIGH;\n\telse\n\t\tcontrol &= ~SPI_IO_C_CLK_IDLE_HIGH;\n\n\twritel_relaxed(control, controller->base + SPI_IO_CONTROL);\n\n\tconfig = readl_relaxed(controller->base + SPI_CONFIG);\n\n\tif (spi->mode & SPI_LOOP)\n\t\tconfig |= SPI_CONFIG_LOOPBACK;\n\telse\n\t\tconfig &= ~SPI_CONFIG_LOOPBACK;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tconfig &= ~SPI_CONFIG_INPUT_FIRST;\n\telse\n\t\tconfig |= SPI_CONFIG_INPUT_FIRST;\n\n\t \n\tif ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))\n\t\tconfig |= SPI_CONFIG_HS_MODE;\n\telse\n\t\tconfig &= ~SPI_CONFIG_HS_MODE;\n\n\twritel_relaxed(config, controller->base + SPI_CONFIG);\n\n\tconfig = readl_relaxed(controller->base + QUP_CONFIG);\n\tconfig &= ~(QUP_CONFIG_NO_INPUT | QUP_CONFIG_NO_OUTPUT | QUP_CONFIG_N);\n\tconfig |= xfer->bits_per_word - 1;\n\tconfig |= QUP_CONFIG_SPI_MODE;\n\n\tif (spi_qup_is_dma_xfer(controller->mode)) {\n\t\tif (!xfer->tx_buf)\n\t\t\tconfig |= QUP_CONFIG_NO_OUTPUT;\n\t\tif (!xfer->rx_buf)\n\t\t\tconfig |= QUP_CONFIG_NO_INPUT;\n\t}\n\n\twritel_relaxed(config, controller->base + QUP_CONFIG);\n\n\t \n\tif (!controller->qup_v1) {\n\t\tu32 mask = 0;\n\n\t\t \n\n\t\tif (spi_qup_is_dma_xfer(controller->mode))\n\t\t\tmask = QUP_OP_IN_SERVICE_FLAG | QUP_OP_OUT_SERVICE_FLAG;\n\n\t\twritel_relaxed(mask, controller->base + QUP_OPERATIONAL_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_qup_transfer_one(struct spi_controller *host,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tunsigned long timeout, flags;\n\tint ret;\n\n\tret = spi_qup_io_prep(spi, xfer);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = DIV_ROUND_UP(xfer->speed_hz, MSEC_PER_SEC);\n\ttimeout = DIV_ROUND_UP(min_t(unsigned long, SPI_MAX_XFER,\n\t\t\t\t     xfer->len) * 8, timeout);\n\ttimeout = 100 * msecs_to_jiffies(timeout);\n\n\treinit_completion(&controller->done);\n\n\tspin_lock_irqsave(&controller->lock, flags);\n\tcontroller->xfer     = xfer;\n\tcontroller->error    = 0;\n\tcontroller->rx_bytes = 0;\n\tcontroller->tx_bytes = 0;\n\tspin_unlock_irqrestore(&controller->lock, flags);\n\n\tif (spi_qup_is_dma_xfer(controller->mode))\n\t\tret = spi_qup_do_dma(spi, xfer, timeout);\n\telse\n\t\tret = spi_qup_do_pio(spi, xfer, timeout);\n\n\tspi_qup_set_state(controller, QUP_STATE_RESET);\n\tspin_lock_irqsave(&controller->lock, flags);\n\tif (!ret)\n\t\tret = controller->error;\n\tspin_unlock_irqrestore(&controller->lock, flags);\n\n\tif (ret && spi_qup_is_dma_xfer(controller->mode))\n\t\tspi_qup_dma_terminate(host, xfer);\n\n\treturn ret;\n}\n\nstatic bool spi_qup_can_dma(struct spi_controller *host, struct spi_device *spi,\n\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct spi_qup *qup = spi_controller_get_devdata(host);\n\tsize_t dma_align = dma_get_cache_alignment();\n\tint n_words;\n\n\tif (xfer->rx_buf) {\n\t\tif (!IS_ALIGNED((size_t)xfer->rx_buf, dma_align) ||\n\t\t    IS_ERR_OR_NULL(host->dma_rx))\n\t\t\treturn false;\n\t\tif (qup->qup_v1 && (xfer->len % qup->in_blk_sz))\n\t\t\treturn false;\n\t}\n\n\tif (xfer->tx_buf) {\n\t\tif (!IS_ALIGNED((size_t)xfer->tx_buf, dma_align) ||\n\t\t    IS_ERR_OR_NULL(host->dma_tx))\n\t\t\treturn false;\n\t\tif (qup->qup_v1 && (xfer->len % qup->out_blk_sz))\n\t\t\treturn false;\n\t}\n\n\tn_words = xfer->len / DIV_ROUND_UP(xfer->bits_per_word, 8);\n\tif (n_words <= (qup->in_fifo_sz / sizeof(u32)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void spi_qup_release_dma(struct spi_controller *host)\n{\n\tif (!IS_ERR_OR_NULL(host->dma_rx))\n\t\tdma_release_channel(host->dma_rx);\n\tif (!IS_ERR_OR_NULL(host->dma_tx))\n\t\tdma_release_channel(host->dma_tx);\n}\n\nstatic int spi_qup_init_dma(struct spi_controller *host, resource_size_t base)\n{\n\tstruct spi_qup *spi = spi_controller_get_devdata(host);\n\tstruct dma_slave_config *rx_conf = &spi->rx_conf,\n\t\t\t\t*tx_conf = &spi->tx_conf;\n\tstruct device *dev = spi->dev;\n\tint ret;\n\n\t \n\thost->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(host->dma_rx))\n\t\treturn PTR_ERR(host->dma_rx);\n\n\thost->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\tret = PTR_ERR(host->dma_tx);\n\t\tgoto err_tx;\n\t}\n\n\t \n\trx_conf->direction = DMA_DEV_TO_MEM;\n\trx_conf->device_fc = 1;\n\trx_conf->src_addr = base + QUP_INPUT_FIFO;\n\trx_conf->src_maxburst = spi->in_blk_sz;\n\n\ttx_conf->direction = DMA_MEM_TO_DEV;\n\ttx_conf->device_fc = 1;\n\ttx_conf->dst_addr = base + QUP_OUTPUT_FIFO;\n\ttx_conf->dst_maxburst = spi->out_blk_sz;\n\n\tret = dmaengine_slave_config(host->dma_rx, rx_conf);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to configure RX channel\\n\");\n\t\tgoto err;\n\t}\n\n\tret = dmaengine_slave_config(host->dma_tx, tx_conf);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to configure TX channel\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdma_release_channel(host->dma_tx);\nerr_tx:\n\tdma_release_channel(host->dma_rx);\n\treturn ret;\n}\n\nstatic void spi_qup_set_cs(struct spi_device *spi, bool val)\n{\n\tstruct spi_qup *controller;\n\tu32 spi_ioc;\n\tu32 spi_ioc_orig;\n\n\tcontroller = spi_controller_get_devdata(spi->controller);\n\tspi_ioc = readl_relaxed(controller->base + SPI_IO_CONTROL);\n\tspi_ioc_orig = spi_ioc;\n\tif (!val)\n\t\tspi_ioc |= SPI_IO_C_FORCE_CS;\n\telse\n\t\tspi_ioc &= ~SPI_IO_C_FORCE_CS;\n\n\tif (spi_ioc != spi_ioc_orig)\n\t\twritel_relaxed(spi_ioc, controller->base + SPI_IO_CONTROL);\n}\n\nstatic int spi_qup_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct clk *iclk, *cclk;\n\tstruct spi_qup *controller;\n\tstruct resource *res;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tu32 max_freq, iomode, num_cs;\n\tint ret, irq, size;\n\n\tdev = &pdev->dev;\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tcclk = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(cclk))\n\t\treturn PTR_ERR(cclk);\n\n\ticlk = devm_clk_get(dev, \"iface\");\n\tif (IS_ERR(iclk))\n\t\treturn PTR_ERR(iclk);\n\n\t \n\tif (of_property_read_u32(dev->of_node, \"spi-max-frequency\", &max_freq))\n\t\tmax_freq = SPI_MAX_RATE;\n\n\tif (!max_freq || max_freq > SPI_MAX_RATE) {\n\t\tdev_err(dev, \"invalid clock frequency %d\\n\", max_freq);\n\t\treturn -ENXIO;\n\t}\n\n\thost = spi_alloc_host(dev, sizeof(struct spi_qup));\n\tif (!host) {\n\t\tdev_err(dev, \"cannot allocate host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (of_property_read_u32(dev->of_node, \"num-cs\", &num_cs) ||\n\t    num_cs > SPI_NUM_CHIPSELECTS)\n\t\thost->num_chipselect = SPI_NUM_CHIPSELECTS;\n\telse\n\t\thost->num_chipselect = num_cs;\n\n\thost->use_gpio_descriptors = true;\n\thost->max_native_cs = SPI_NUM_CHIPSELECTS;\n\thost->bus_num = pdev->id;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\thost->max_speed_hz = max_freq;\n\thost->transfer_one = spi_qup_transfer_one;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->auto_runtime_pm = true;\n\thost->dma_alignment = dma_get_cache_alignment();\n\thost->max_dma_len = SPI_MAX_XFER;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tcontroller = spi_controller_get_devdata(host);\n\n\tcontroller->dev = dev;\n\tcontroller->base = base;\n\tcontroller->iclk = iclk;\n\tcontroller->cclk = cclk;\n\tcontroller->irq = irq;\n\n\tret = spi_qup_init_dma(host, res->start);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto error;\n\telse if (!ret)\n\t\thost->can_dma = spi_qup_can_dma;\n\n\tcontroller->qup_v1 = (uintptr_t)of_device_get_match_data(dev);\n\n\tif (!controller->qup_v1)\n\t\thost->set_cs = spi_qup_set_cs;\n\n\tspin_lock_init(&controller->lock);\n\tinit_completion(&controller->done);\n\n\tret = clk_prepare_enable(cclk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot enable core clock\\n\");\n\t\tgoto error_dma;\n\t}\n\n\tret = clk_prepare_enable(iclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(cclk);\n\t\tdev_err(dev, \"cannot enable iface clock\\n\");\n\t\tgoto error_dma;\n\t}\n\n\tiomode = readl_relaxed(base + QUP_IO_M_MODES);\n\n\tsize = QUP_IO_M_OUTPUT_BLOCK_SIZE(iomode);\n\tif (size)\n\t\tcontroller->out_blk_sz = size * 16;\n\telse\n\t\tcontroller->out_blk_sz = 4;\n\n\tsize = QUP_IO_M_INPUT_BLOCK_SIZE(iomode);\n\tif (size)\n\t\tcontroller->in_blk_sz = size * 16;\n\telse\n\t\tcontroller->in_blk_sz = 4;\n\n\tsize = QUP_IO_M_OUTPUT_FIFO_SIZE(iomode);\n\tcontroller->out_fifo_sz = controller->out_blk_sz * (2 << size);\n\n\tsize = QUP_IO_M_INPUT_FIFO_SIZE(iomode);\n\tcontroller->in_fifo_sz = controller->in_blk_sz * (2 << size);\n\n\tdev_info(dev, \"IN:block:%d, fifo:%d, OUT:block:%d, fifo:%d\\n\",\n\t\t controller->in_blk_sz, controller->in_fifo_sz,\n\t\t controller->out_blk_sz, controller->out_fifo_sz);\n\n\twritel_relaxed(1, base + QUP_SW_RESET);\n\n\tret = spi_qup_set_state(controller, QUP_STATE_RESET);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot set RESET state\\n\");\n\t\tgoto error_clk;\n\t}\n\n\twritel_relaxed(0, base + QUP_OPERATIONAL);\n\twritel_relaxed(0, base + QUP_IO_M_MODES);\n\n\tif (!controller->qup_v1)\n\t\twritel_relaxed(0, base + QUP_OPERATIONAL_MASK);\n\n\twritel_relaxed(SPI_ERROR_CLK_UNDER_RUN | SPI_ERROR_CLK_OVER_RUN,\n\t\t       base + SPI_ERROR_FLAGS_EN);\n\n\t \n\tif (controller->qup_v1)\n\t\twritel_relaxed(QUP_ERROR_OUTPUT_OVER_RUN |\n\t\t\tQUP_ERROR_INPUT_UNDER_RUN | QUP_ERROR_OUTPUT_UNDER_RUN,\n\t\t\tbase + QUP_ERROR_FLAGS_EN);\n\n\twritel_relaxed(0, base + SPI_CONFIG);\n\twritel_relaxed(SPI_IO_C_NO_TRI_STATE, base + SPI_IO_CONTROL);\n\n\tret = devm_request_irq(dev, irq, spi_qup_qup_irq,\n\t\t\t       IRQF_TRIGGER_HIGH, pdev->name, controller);\n\tif (ret)\n\t\tgoto error_clk;\n\n\tpm_runtime_set_autosuspend_delay(dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(&pdev->dev);\nerror_clk:\n\tclk_disable_unprepare(cclk);\n\tclk_disable_unprepare(iclk);\nerror_dma:\n\tspi_qup_release_dma(host);\nerror:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int spi_qup_pm_suspend_runtime(struct device *device)\n{\n\tstruct spi_controller *host = dev_get_drvdata(device);\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tu32 config;\n\n\t \n\tconfig = readl(controller->base + QUP_CONFIG);\n\tconfig |= QUP_CONFIG_CLOCK_AUTO_GATE;\n\twritel_relaxed(config, controller->base + QUP_CONFIG);\n\n\tclk_disable_unprepare(controller->cclk);\n\tclk_disable_unprepare(controller->iclk);\n\n\treturn 0;\n}\n\nstatic int spi_qup_pm_resume_runtime(struct device *device)\n{\n\tstruct spi_controller *host = dev_get_drvdata(device);\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tu32 config;\n\tint ret;\n\n\tret = clk_prepare_enable(controller->iclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(controller->cclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(controller->iclk);\n\t\treturn ret;\n\t}\n\n\t \n\tconfig = readl_relaxed(controller->base + QUP_CONFIG);\n\tconfig &= ~QUP_CONFIG_CLOCK_AUTO_GATE;\n\twritel_relaxed(config, controller->base + QUP_CONFIG);\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\nstatic int spi_qup_suspend(struct device *device)\n{\n\tstruct spi_controller *host = dev_get_drvdata(device);\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tint ret;\n\n\tif (pm_runtime_suspended(device)) {\n\t\tret = spi_qup_pm_resume_runtime(device);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_qup_set_state(controller, QUP_STATE_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(controller->cclk);\n\tclk_disable_unprepare(controller->iclk);\n\treturn 0;\n}\n\nstatic int spi_qup_resume(struct device *device)\n{\n\tstruct spi_controller *host = dev_get_drvdata(device);\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(controller->iclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(controller->cclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(controller->iclk);\n\t\treturn ret;\n\t}\n\n\tret = spi_qup_set_state(controller, QUP_STATE_RESET);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = spi_controller_resume(host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(controller->cclk);\n\tclk_disable_unprepare(controller->iclk);\n\treturn ret;\n}\n#endif  \n\nstatic void spi_qup_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(&pdev->dev);\n\tstruct spi_qup *controller = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\n\tif (ret >= 0) {\n\t\tret = spi_qup_set_state(controller, QUP_STATE_RESET);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"failed to reset controller (%pe)\\n\",\n\t\t\t\t ERR_PTR(ret));\n\n\t\tclk_disable_unprepare(controller->cclk);\n\t\tclk_disable_unprepare(controller->iclk);\n\t} else {\n\t\tdev_warn(&pdev->dev, \"failed to resume, skip hw disable (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n\t}\n\n\tspi_qup_release_dma(host);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id spi_qup_dt_match[] = {\n\t{ .compatible = \"qcom,spi-qup-v1.1.1\", .data = (void *)1, },\n\t{ .compatible = \"qcom,spi-qup-v2.1.1\", },\n\t{ .compatible = \"qcom,spi-qup-v2.2.1\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, spi_qup_dt_match);\n\nstatic const struct dev_pm_ops spi_qup_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(spi_qup_suspend, spi_qup_resume)\n\tSET_RUNTIME_PM_OPS(spi_qup_pm_suspend_runtime,\n\t\t\t   spi_qup_pm_resume_runtime,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver spi_qup_driver = {\n\t.driver = {\n\t\t.name\t\t= \"spi_qup\",\n\t\t.pm\t\t= &spi_qup_dev_pm_ops,\n\t\t.of_match_table = spi_qup_dt_match,\n\t},\n\t.probe = spi_qup_probe,\n\t.remove_new = spi_qup_remove,\n};\nmodule_platform_driver(spi_qup_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:spi_qup\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}