{
  "module_name": "spi-npcm-fiu.c",
  "hash_id": "b32aa4b41bf4370a7bff8038dbe68540fcfd931c93ed1ee7d7ce14bde36d692c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-npcm-fiu.c",
  "human_readable_source": "\n\n\n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/vmalloc.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/mfd/syscon.h>\n\n \n#define NPCM7XX_INTCR3_OFFSET\t\t0x9C\n#define NPCM7XX_INTCR3_FIU_FIX\t\tBIT(6)\n\n \n#define NPCM_FIU_DRD_CFG\t\t0x00\n#define NPCM_FIU_DWR_CFG\t\t0x04\n#define NPCM_FIU_UMA_CFG\t\t0x08\n#define NPCM_FIU_UMA_CTS\t\t0x0C\n#define NPCM_FIU_UMA_CMD\t\t0x10\n#define NPCM_FIU_UMA_ADDR\t\t0x14\n#define NPCM_FIU_PRT_CFG\t\t0x18\n#define NPCM_FIU_UMA_DW0\t\t0x20\n#define NPCM_FIU_UMA_DW1\t\t0x24\n#define NPCM_FIU_UMA_DW2\t\t0x28\n#define NPCM_FIU_UMA_DW3\t\t0x2C\n#define NPCM_FIU_UMA_DR0\t\t0x30\n#define NPCM_FIU_UMA_DR1\t\t0x34\n#define NPCM_FIU_UMA_DR2\t\t0x38\n#define NPCM_FIU_UMA_DR3\t\t0x3C\n#define NPCM_FIU_CFG\t\t\t0x78\n#define NPCM_FIU_MAX_REG_LIMIT\t\t0x80\n\n \n#define NPCM_FIU_DRD_CFG_LCK\t\tBIT(31)\n#define NPCM_FIU_DRD_CFG_R_BURST\tGENMASK(25, 24)\n#define NPCM_FIU_DRD_CFG_ADDSIZ\t\tGENMASK(17, 16)\n#define NPCM_FIU_DRD_CFG_DBW\t\tGENMASK(13, 12)\n#define NPCM_FIU_DRD_CFG_ACCTYPE\tGENMASK(9, 8)\n#define NPCM_FIU_DRD_CFG_RDCMD\t\tGENMASK(7, 0)\n#define NPCM_FIU_DRD_ADDSIZ_SHIFT\t16\n#define NPCM_FIU_DRD_DBW_SHIFT\t\t12\n#define NPCM_FIU_DRD_ACCTYPE_SHIFT\t8\n\n \n#define NPCM_FIU_DWR_CFG_LCK\t\tBIT(31)\n#define NPCM_FIU_DWR_CFG_W_BURST\tGENMASK(25, 24)\n#define NPCM_FIU_DWR_CFG_ADDSIZ\t\tGENMASK(17, 16)\n#define NPCM_FIU_DWR_CFG_ABPCK\t\tGENMASK(11, 10)\n#define NPCM_FIU_DWR_CFG_DBPCK\t\tGENMASK(9, 8)\n#define NPCM_FIU_DWR_CFG_WRCMD\t\tGENMASK(7, 0)\n#define NPCM_FIU_DWR_ADDSIZ_SHIFT\t16\n#define NPCM_FIU_DWR_ABPCK_SHIFT\t10\n#define NPCM_FIU_DWR_DBPCK_SHIFT\t8\n\n \n#define NPCM_FIU_UMA_CFG_LCK\t\tBIT(31)\n#define NPCM_FIU_UMA_CFG_CMMLCK\t\tBIT(30)\n#define NPCM_FIU_UMA_CFG_RDATSIZ\tGENMASK(28, 24)\n#define NPCM_FIU_UMA_CFG_DBSIZ\t\tGENMASK(23, 21)\n#define NPCM_FIU_UMA_CFG_WDATSIZ\tGENMASK(20, 16)\n#define NPCM_FIU_UMA_CFG_ADDSIZ\t\tGENMASK(13, 11)\n#define NPCM_FIU_UMA_CFG_CMDSIZ\t\tBIT(10)\n#define NPCM_FIU_UMA_CFG_RDBPCK\t\tGENMASK(9, 8)\n#define NPCM_FIU_UMA_CFG_DBPCK\t\tGENMASK(7, 6)\n#define NPCM_FIU_UMA_CFG_WDBPCK\t\tGENMASK(5, 4)\n#define NPCM_FIU_UMA_CFG_ADBPCK\t\tGENMASK(3, 2)\n#define NPCM_FIU_UMA_CFG_CMBPCK\t\tGENMASK(1, 0)\n#define NPCM_FIU_UMA_CFG_ADBPCK_SHIFT\t2\n#define NPCM_FIU_UMA_CFG_WDBPCK_SHIFT\t4\n#define NPCM_FIU_UMA_CFG_DBPCK_SHIFT\t6\n#define NPCM_FIU_UMA_CFG_RDBPCK_SHIFT\t8\n#define NPCM_FIU_UMA_CFG_ADDSIZ_SHIFT\t11\n#define NPCM_FIU_UMA_CFG_WDATSIZ_SHIFT\t16\n#define NPCM_FIU_UMA_CFG_DBSIZ_SHIFT\t21\n#define NPCM_FIU_UMA_CFG_RDATSIZ_SHIFT\t24\n\n \n#define NPCM_FIU_UMA_CTS_RDYIE\t\tBIT(25)\n#define NPCM_FIU_UMA_CTS_RDYST\t\tBIT(24)\n#define NPCM_FIU_UMA_CTS_SW_CS\t\tBIT(16)\n#define NPCM_FIU_UMA_CTS_DEV_NUM\tGENMASK(9, 8)\n#define NPCM_FIU_UMA_CTS_EXEC_DONE\tBIT(0)\n#define NPCM_FIU_UMA_CTS_DEV_NUM_SHIFT\t8\n\n \n#define NPCM_FIU_UMA_CMD_DUM3\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_CMD_DUM2\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_CMD_DUM1\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_CMD_CMD\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_ADDR_UMA_ADDR\tGENMASK(31, 0)\n#define NPCM_FIU_UMA_ADDR_AB3\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_ADDR_AB2\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_ADDR_AB1\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_ADDR_AB0\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DW0_WB3\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DW0_WB2\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DW0_WB1\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DW0_WB0\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DW1_WB7\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DW1_WB6\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DW1_WB5\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DW1_WB4\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DW2_WB11\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DW2_WB10\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DW2_WB9\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DW2_WB8\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DW3_WB15\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DW3_WB14\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DW3_WB13\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DW3_WB12\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DR0_RB3\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DR0_RB2\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DR0_RB1\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DR0_RB0\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DR1_RB15\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DR1_RB14\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DR1_RB13\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DR1_RB12\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DR2_RB15\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DR2_RB14\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DR2_RB13\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DR2_RB12\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_UMA_DR3_RB15\t\tGENMASK(31, 24)\n#define NPCM_FIU_UMA_DR3_RB14\t\tGENMASK(23, 16)\n#define NPCM_FIU_UMA_DR3_RB13\t\tGENMASK(15, 8)\n#define NPCM_FIU_UMA_DR3_RB12\t\tGENMASK(7, 0)\n\n \n#define NPCM_FIU_CFG_FIU_FIX\t\tBIT(31)\n\n \nenum {\n\tDRD_SINGLE_WIRE_MODE\t= 0,\n\tDRD_DUAL_IO_MODE\t= 1,\n\tDRD_QUAD_IO_MODE\t= 2,\n\tDRD_SPI_X_MODE\t\t= 3,\n};\n\nenum {\n\tDWR_ABPCK_BIT_PER_CLK\t= 0,\n\tDWR_ABPCK_2_BIT_PER_CLK\t= 1,\n\tDWR_ABPCK_4_BIT_PER_CLK\t= 2,\n};\n\nenum {\n\tDWR_DBPCK_BIT_PER_CLK\t= 0,\n\tDWR_DBPCK_2_BIT_PER_CLK\t= 1,\n\tDWR_DBPCK_4_BIT_PER_CLK\t= 2,\n};\n\n#define NPCM_FIU_DRD_16_BYTE_BURST\t0x3000000\n#define NPCM_FIU_DWR_16_BYTE_BURST\t0x3000000\n\n#define MAP_SIZE_128MB\t\t\t0x8000000\n#define MAP_SIZE_16MB\t\t\t0x1000000\n#define MAP_SIZE_8MB\t\t\t0x800000\n\n#define FIU_DRD_MAX_DUMMY_NUMBER\t3\n#define NPCM_MAX_CHIP_NUM\t\t4\n#define CHUNK_SIZE\t\t\t16\n#define UMA_MICRO_SEC_TIMEOUT\t\t150\n\nenum {\n\tFIU0 = 0,\n\tFIU3,\n\tFIUX,\n\tFIU1,\n};\n\nstruct npcm_fiu_info {\n\tchar *name;\n\tu32 fiu_id;\n\tu32 max_map_size;\n\tu32 max_cs;\n};\n\nstruct fiu_data {\n\tconst struct npcm_fiu_info *npcm_fiu_data_info;\n\tint fiu_max;\n};\n\nstatic const struct npcm_fiu_info npcm7xx_fiu_info[] = {\n\t{.name = \"FIU0\", .fiu_id = FIU0,\n\t\t.max_map_size = MAP_SIZE_128MB, .max_cs = 2},\n\t{.name = \"FIU3\", .fiu_id = FIU3,\n\t\t.max_map_size = MAP_SIZE_128MB, .max_cs = 4},\n\t{.name = \"FIUX\", .fiu_id = FIUX,\n\t\t.max_map_size = MAP_SIZE_16MB, .max_cs = 2} };\n\nstatic const struct fiu_data npcm7xx_fiu_data = {\n\t.npcm_fiu_data_info = npcm7xx_fiu_info,\n\t.fiu_max = 3,\n};\n\nstatic const struct npcm_fiu_info npxm8xx_fiu_info[] = {\n\t{.name = \"FIU0\", .fiu_id = FIU0,\n\t\t.max_map_size = MAP_SIZE_128MB, .max_cs = 2},\n\t{.name = \"FIU3\", .fiu_id = FIU3,\n\t\t.max_map_size = MAP_SIZE_128MB, .max_cs = 4},\n\t{.name = \"FIUX\", .fiu_id = FIUX,\n\t\t.max_map_size = MAP_SIZE_16MB, .max_cs = 2},\n\t{.name = \"FIU1\", .fiu_id = FIU1,\n\t\t.max_map_size = MAP_SIZE_16MB, .max_cs = 4} };\n\nstatic const struct fiu_data npxm8xx_fiu_data = {\n\t.npcm_fiu_data_info = npxm8xx_fiu_info,\n\t.fiu_max = 4,\n};\n\nstruct npcm_fiu_spi;\n\nstruct npcm_fiu_chip {\n\tvoid __iomem *flash_region_mapped_ptr;\n\tstruct npcm_fiu_spi *fiu;\n\tunsigned long clkrate;\n\tu32 chipselect;\n};\n\nstruct npcm_fiu_spi {\n\tstruct npcm_fiu_chip chip[NPCM_MAX_CHIP_NUM];\n\tconst struct npcm_fiu_info *info;\n\tstruct spi_mem_op drd_op;\n\tstruct resource *res_mem;\n\tstruct regmap *regmap;\n\tunsigned long clkrate;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tbool spix_mode;\n};\n\nstatic const struct regmap_config npcm_mtd_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = NPCM_FIU_MAX_REG_LIMIT,\n};\n\nstatic void npcm_fiu_set_drd(struct npcm_fiu_spi *fiu,\n\t\t\t     const struct spi_mem_op *op)\n{\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_ACCTYPE,\n\t\t\t   ilog2(op->addr.buswidth) <<\n\t\t\t   NPCM_FIU_DRD_ACCTYPE_SHIFT);\n\tfiu->drd_op.addr.buswidth = op->addr.buswidth;\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_DBW,\n\t\t\t   op->dummy.nbytes << NPCM_FIU_DRD_DBW_SHIFT);\n\tfiu->drd_op.dummy.nbytes = op->dummy.nbytes;\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_RDCMD, op->cmd.opcode);\n\tfiu->drd_op.cmd.opcode = op->cmd.opcode;\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_ADDSIZ,\n\t\t\t   (op->addr.nbytes - 3) << NPCM_FIU_DRD_ADDSIZ_SHIFT);\n\tfiu->drd_op.addr.nbytes = op->addr.nbytes;\n}\n\nstatic ssize_t npcm_fiu_direct_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t    u64 offs, size_t len, void *buf)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(desc->mem->spi->controller);\n\tstruct npcm_fiu_chip *chip = &fiu->chip[spi_get_chipselect(desc->mem->spi, 0)];\n\tvoid __iomem *src = (void __iomem *)(chip->flash_region_mapped_ptr +\n\t\t\t\t\t     offs);\n\tu8 *buf_rx = buf;\n\tu32 i;\n\n\tif (fiu->spix_mode) {\n\t\tfor (i = 0 ; i < len ; i++)\n\t\t\t*(buf_rx + i) = ioread8(src + i);\n\t} else {\n\t\tif (desc->info.op_tmpl.addr.buswidth != fiu->drd_op.addr.buswidth ||\n\t\t    desc->info.op_tmpl.dummy.nbytes != fiu->drd_op.dummy.nbytes ||\n\t\t    desc->info.op_tmpl.cmd.opcode != fiu->drd_op.cmd.opcode ||\n\t\t    desc->info.op_tmpl.addr.nbytes != fiu->drd_op.addr.nbytes)\n\t\t\tnpcm_fiu_set_drd(fiu, &desc->info.op_tmpl);\n\n\t\tmemcpy_fromio(buf_rx, src, len);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t npcm_fiu_direct_write(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t     u64 offs, size_t len, const void *buf)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(desc->mem->spi->controller);\n\tstruct npcm_fiu_chip *chip = &fiu->chip[spi_get_chipselect(desc->mem->spi, 0)];\n\tvoid __iomem *dst = (void __iomem *)(chip->flash_region_mapped_ptr +\n\t\t\t\t\t     offs);\n\tconst u8 *buf_tx = buf;\n\tu32 i;\n\n\tif (fiu->spix_mode)\n\t\tfor (i = 0 ; i < len ; i++)\n\t\t\tiowrite8(*(buf_tx + i), dst + i);\n\telse\n\t\tmemcpy_toio(dst, buf_tx, len);\n\n\treturn len;\n}\n\nstatic int npcm_fiu_uma_read(struct spi_mem *mem,\n\t\t\t     const struct spi_mem_op *op, u32 addr,\n\t\t\t      bool is_address_size, u8 *data, u32 data_size)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tu32 uma_cfg = BIT(10);\n\tu32 data_reg[4];\n\tint ret;\n\tu32 val;\n\tu32 i;\n\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t   NPCM_FIU_UMA_CTS_DEV_NUM,\n\t\t\t   (spi_get_chipselect(mem->spi, 0) <<\n\t\t\t    NPCM_FIU_UMA_CTS_DEV_NUM_SHIFT));\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CMD,\n\t\t\t   NPCM_FIU_UMA_CMD_CMD, op->cmd.opcode);\n\n\tif (is_address_size) {\n\t\tuma_cfg |= ilog2(op->cmd.buswidth);\n\t\tuma_cfg |= ilog2(op->addr.buswidth)\n\t\t\t<< NPCM_FIU_UMA_CFG_ADBPCK_SHIFT;\n\t\tif (op->dummy.nbytes)\n\t\t\tuma_cfg |= ilog2(op->dummy.buswidth)\n\t\t\t\t<< NPCM_FIU_UMA_CFG_DBPCK_SHIFT;\n\t\tuma_cfg |= ilog2(op->data.buswidth)\n\t\t\t<< NPCM_FIU_UMA_CFG_RDBPCK_SHIFT;\n\t\tuma_cfg |= op->dummy.nbytes << NPCM_FIU_UMA_CFG_DBSIZ_SHIFT;\n\t\tuma_cfg |= op->addr.nbytes << NPCM_FIU_UMA_CFG_ADDSIZ_SHIFT;\n\t\tregmap_write(fiu->regmap, NPCM_FIU_UMA_ADDR, addr);\n\t} else {\n\t\tregmap_write(fiu->regmap, NPCM_FIU_UMA_ADDR, 0x0);\n\t}\n\n\tuma_cfg |= data_size << NPCM_FIU_UMA_CFG_RDATSIZ_SHIFT;\n\tregmap_write(fiu->regmap, NPCM_FIU_UMA_CFG, uma_cfg);\n\tregmap_write_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t  NPCM_FIU_UMA_CTS_EXEC_DONE,\n\t\t\t  NPCM_FIU_UMA_CTS_EXEC_DONE);\n\tret = regmap_read_poll_timeout(fiu->regmap, NPCM_FIU_UMA_CTS, val,\n\t\t\t\t       (!(val & NPCM_FIU_UMA_CTS_EXEC_DONE)), 0,\n\t\t\t\t       UMA_MICRO_SEC_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data_size) {\n\t\tfor (i = 0; i < DIV_ROUND_UP(data_size, 4); i++)\n\t\t\tregmap_read(fiu->regmap, NPCM_FIU_UMA_DR0 + (i * 4),\n\t\t\t\t    &data_reg[i]);\n\t\tmemcpy(data, data_reg, data_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int npcm_fiu_uma_write(struct spi_mem *mem,\n\t\t\t      const struct spi_mem_op *op, u8 cmd,\n\t\t\t      bool is_address_size, u8 *data, u32 data_size)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tu32 uma_cfg = BIT(10);\n\tu32 data_reg[4] = {0};\n\tu32 val;\n\tu32 i;\n\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t   NPCM_FIU_UMA_CTS_DEV_NUM,\n\t\t\t   (spi_get_chipselect(mem->spi, 0) <<\n\t\t\t    NPCM_FIU_UMA_CTS_DEV_NUM_SHIFT));\n\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CMD,\n\t\t\t   NPCM_FIU_UMA_CMD_CMD, cmd);\n\n\tif (data_size) {\n\t\tmemcpy(data_reg, data, data_size);\n\t\tfor (i = 0; i < DIV_ROUND_UP(data_size, 4); i++)\n\t\t\tregmap_write(fiu->regmap, NPCM_FIU_UMA_DW0 + (i * 4),\n\t\t\t\t     data_reg[i]);\n\t}\n\n\tif (is_address_size) {\n\t\tuma_cfg |= ilog2(op->cmd.buswidth);\n\t\tuma_cfg |= ilog2(op->addr.buswidth) <<\n\t\t\tNPCM_FIU_UMA_CFG_ADBPCK_SHIFT;\n\t\tuma_cfg |= ilog2(op->data.buswidth) <<\n\t\t\tNPCM_FIU_UMA_CFG_WDBPCK_SHIFT;\n\t\tuma_cfg |= op->addr.nbytes << NPCM_FIU_UMA_CFG_ADDSIZ_SHIFT;\n\t\tregmap_write(fiu->regmap, NPCM_FIU_UMA_ADDR, op->addr.val);\n\t} else {\n\t\tregmap_write(fiu->regmap, NPCM_FIU_UMA_ADDR, 0x0);\n\t}\n\n\tuma_cfg |= (data_size << NPCM_FIU_UMA_CFG_WDATSIZ_SHIFT);\n\tregmap_write(fiu->regmap, NPCM_FIU_UMA_CFG, uma_cfg);\n\n\tregmap_write_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t  NPCM_FIU_UMA_CTS_EXEC_DONE,\n\t\t\t  NPCM_FIU_UMA_CTS_EXEC_DONE);\n\n\treturn regmap_read_poll_timeout(fiu->regmap, NPCM_FIU_UMA_CTS, val,\n\t\t\t\t       (!(val & NPCM_FIU_UMA_CTS_EXEC_DONE)), 0,\n\t\t\t\t\tUMA_MICRO_SEC_TIMEOUT);\n}\n\nstatic int npcm_fiu_manualwrite(struct spi_mem *mem,\n\t\t\t\tconst struct spi_mem_op *op)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tu8 *data = (u8 *)op->data.buf.out;\n\tu32 num_data_chunks;\n\tu32 remain_data;\n\tu32 idx = 0;\n\tint ret;\n\n\tnum_data_chunks  = op->data.nbytes / CHUNK_SIZE;\n\tremain_data  = op->data.nbytes % CHUNK_SIZE;\n\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t   NPCM_FIU_UMA_CTS_DEV_NUM,\n\t\t\t   (spi_get_chipselect(mem->spi, 0) <<\n\t\t\t    NPCM_FIU_UMA_CTS_DEV_NUM_SHIFT));\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t   NPCM_FIU_UMA_CTS_SW_CS, 0);\n\n\tret = npcm_fiu_uma_write(mem, op, op->cmd.opcode, true, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (idx = 0; idx < num_data_chunks; ++idx) {\n\t\tret = npcm_fiu_uma_write(mem, op, data[0], false,\n\t\t\t\t\t &data[1], CHUNK_SIZE - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata += CHUNK_SIZE;\n\t}\n\n\t \n\tif (remain_data > 0) {\n\t\tret = npcm_fiu_uma_write(mem, op, data[0], false,\n\t\t\t\t\t &data[1], remain_data - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_UMA_CTS,\n\t\t\t   NPCM_FIU_UMA_CTS_SW_CS, NPCM_FIU_UMA_CTS_SW_CS);\n\n\treturn 0;\n}\n\nstatic int npcm_fiu_read(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tu8 *data = op->data.buf.in;\n\tint i, readlen, currlen;\n\tu8 *buf_ptr;\n\tu32 addr;\n\tint ret;\n\n\ti = 0;\n\tcurrlen = op->data.nbytes;\n\n\tdo {\n\t\taddr = ((u32)op->addr.val + i);\n\t\tif (currlen < 16)\n\t\t\treadlen = currlen;\n\t\telse\n\t\t\treadlen = 16;\n\n\t\tbuf_ptr = data + i;\n\t\tret = npcm_fiu_uma_read(mem, op, addr, true, buf_ptr,\n\t\t\t\t\treadlen);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ti += readlen;\n\t\tcurrlen -= 16;\n\t} while (currlen > 0);\n\n\treturn 0;\n}\n\nstatic void npcm_fiux_set_direct_wr(struct npcm_fiu_spi *fiu)\n{\n\tregmap_write(fiu->regmap, NPCM_FIU_DWR_CFG,\n\t\t     NPCM_FIU_DWR_16_BYTE_BURST);\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DWR_CFG,\n\t\t\t   NPCM_FIU_DWR_CFG_ABPCK,\n\t\t\t   DWR_ABPCK_4_BIT_PER_CLK << NPCM_FIU_DWR_ABPCK_SHIFT);\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DWR_CFG,\n\t\t\t   NPCM_FIU_DWR_CFG_DBPCK,\n\t\t\t   DWR_DBPCK_4_BIT_PER_CLK << NPCM_FIU_DWR_DBPCK_SHIFT);\n}\n\nstatic void npcm_fiux_set_direct_rd(struct npcm_fiu_spi *fiu)\n{\n\tu32 rx_dummy = 0;\n\n\tregmap_write(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t     NPCM_FIU_DRD_16_BYTE_BURST);\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_ACCTYPE,\n\t\t\t   DRD_SPI_X_MODE << NPCM_FIU_DRD_ACCTYPE_SHIFT);\n\tregmap_update_bits(fiu->regmap, NPCM_FIU_DRD_CFG,\n\t\t\t   NPCM_FIU_DRD_CFG_DBW,\n\t\t\t   rx_dummy << NPCM_FIU_DRD_DBW_SHIFT);\n}\n\nstatic int npcm_fiu_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tstruct npcm_fiu_chip *chip = &fiu->chip[spi_get_chipselect(mem->spi, 0)];\n\tint ret = 0;\n\tu8 *buf;\n\n\tdev_dbg(fiu->dev, \"cmd:%#x mode:%d.%d.%d.%d addr:%#llx len:%#x\\n\",\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth, op->addr.val,\n\t\top->data.nbytes);\n\n\tif (fiu->spix_mode || op->addr.nbytes > 4)\n\t\treturn -ENOTSUPP;\n\n\tif (fiu->clkrate != chip->clkrate) {\n\t\tret = clk_set_rate(fiu->clk, chip->clkrate);\n\t\tif (ret < 0)\n\t\t\tdev_warn(fiu->dev, \"Failed setting %lu frequency, stay at %lu frequency\\n\",\n\t\t\t\t chip->clkrate, fiu->clkrate);\n\t\telse\n\t\t\tfiu->clkrate = chip->clkrate;\n\t}\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (!op->addr.nbytes) {\n\t\t\tbuf = op->data.buf.in;\n\t\t\tret = npcm_fiu_uma_read(mem, op, op->addr.val, false,\n\t\t\t\t\t\tbuf, op->data.nbytes);\n\t\t} else {\n\t\t\tret = npcm_fiu_read(mem, op);\n\t\t}\n\t} else  {\n\t\tif (!op->addr.nbytes && !op->data.nbytes)\n\t\t\tret = npcm_fiu_uma_write(mem, op, op->cmd.opcode, false,\n\t\t\t\t\t\t NULL, 0);\n\t\tif (op->addr.nbytes && !op->data.nbytes) {\n\t\t\tint i;\n\t\t\tu8 buf_addr[4];\n\t\t\tu32 addr = op->addr.val;\n\n\t\t\tfor (i = op->addr.nbytes - 1; i >= 0; i--) {\n\t\t\t\tbuf_addr[i] = addr & 0xff;\n\t\t\t\taddr >>= 8;\n\t\t\t}\n\t\t\tret = npcm_fiu_uma_write(mem, op, op->cmd.opcode, false,\n\t\t\t\t\t\t buf_addr, op->addr.nbytes);\n\t\t}\n\t\tif (!op->addr.nbytes && op->data.nbytes)\n\t\t\tret = npcm_fiu_uma_write(mem, op, op->cmd.opcode, false,\n\t\t\t\t\t\t (u8 *)op->data.buf.out,\n\t\t\t\t\t\t op->data.nbytes);\n\t\tif (op->addr.nbytes && op->data.nbytes)\n\t\t\tret = npcm_fiu_manualwrite(mem, op);\n\t}\n\n\treturn ret;\n}\n\nstatic int npcm_fiu_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct npcm_fiu_spi *fiu =\n\t\tspi_controller_get_devdata(desc->mem->spi->controller);\n\tstruct npcm_fiu_chip *chip = &fiu->chip[spi_get_chipselect(desc->mem->spi, 0)];\n\tstruct regmap *gcr_regmap;\n\n\tif (!fiu->res_mem) {\n\t\tdev_warn(fiu->dev, \"Reserved memory not defined, direct read disabled\\n\");\n\t\tdesc->nodirmap = true;\n\t\treturn 0;\n\t}\n\n\tif (!fiu->spix_mode &&\n\t    desc->info.op_tmpl.data.dir == SPI_MEM_DATA_OUT) {\n\t\tdesc->nodirmap = true;\n\t\treturn 0;\n\t}\n\n\tif (!chip->flash_region_mapped_ptr) {\n\t\tchip->flash_region_mapped_ptr =\n\t\t\tdevm_ioremap(fiu->dev, (fiu->res_mem->start +\n\t\t\t\t\t\t\t(fiu->info->max_map_size *\n\t\t\t\t\t\t    spi_get_chipselect(desc->mem->spi, 0))),\n\t\t\t\t\t     (u32)desc->info.length);\n\t\tif (!chip->flash_region_mapped_ptr) {\n\t\t\tdev_warn(fiu->dev, \"Error mapping memory region, direct read disabled\\n\");\n\t\t\tdesc->nodirmap = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (of_device_is_compatible(fiu->dev->of_node, \"nuvoton,npcm750-fiu\")) {\n\t\tgcr_regmap =\n\t\t\tsyscon_regmap_lookup_by_compatible(\"nuvoton,npcm750-gcr\");\n\t\tif (IS_ERR(gcr_regmap)) {\n\t\t\tdev_warn(fiu->dev, \"Didn't find nuvoton,npcm750-gcr, direct read disabled\\n\");\n\t\t\tdesc->nodirmap = true;\n\t\t\treturn 0;\n\t\t}\n\t\tregmap_update_bits(gcr_regmap, NPCM7XX_INTCR3_OFFSET,\n\t\t\t\t   NPCM7XX_INTCR3_FIU_FIX,\n\t\t\t\t   NPCM7XX_INTCR3_FIU_FIX);\n\t} else {\n\t\tregmap_update_bits(fiu->regmap, NPCM_FIU_CFG,\n\t\t\t\t   NPCM_FIU_CFG_FIU_FIX,\n\t\t\t\t   NPCM_FIU_CFG_FIU_FIX);\n\t}\n\n\tif (desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN) {\n\t\tif (!fiu->spix_mode)\n\t\t\tnpcm_fiu_set_drd(fiu, &desc->info.op_tmpl);\n\t\telse\n\t\t\tnpcm_fiux_set_direct_rd(fiu);\n\n\t} else {\n\t\tnpcm_fiux_set_direct_wr(fiu);\n\t}\n\n\treturn 0;\n}\n\nstatic int npcm_fiu_setup(struct spi_device *spi)\n{\n\tstruct spi_controller *ctrl = spi->controller;\n\tstruct npcm_fiu_spi *fiu = spi_controller_get_devdata(ctrl);\n\tstruct npcm_fiu_chip *chip;\n\n\tchip = &fiu->chip[spi_get_chipselect(spi, 0)];\n\tchip->fiu = fiu;\n\tchip->chipselect = spi_get_chipselect(spi, 0);\n\tchip->clkrate = spi->max_speed_hz;\n\n\tfiu->clkrate = clk_get_rate(fiu->clk);\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops npcm_fiu_mem_ops = {\n\t.exec_op = npcm_fiu_exec_op,\n\t.dirmap_create = npcm_fiu_dirmap_create,\n\t.dirmap_read = npcm_fiu_direct_read,\n\t.dirmap_write = npcm_fiu_direct_write,\n};\n\nstatic const struct of_device_id npcm_fiu_dt_ids[] = {\n\t{ .compatible = \"nuvoton,npcm750-fiu\", .data = &npcm7xx_fiu_data  },\n\t{ .compatible = \"nuvoton,npcm845-fiu\", .data = &npxm8xx_fiu_data  },\n\t{   }\n};\n\nstatic int npcm_fiu_probe(struct platform_device *pdev)\n{\n\tconst struct fiu_data *fiu_data_match;\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *ctrl;\n\tstruct npcm_fiu_spi *fiu;\n\tvoid __iomem *regbase;\n\tint id, ret;\n\n\tctrl = devm_spi_alloc_host(dev, sizeof(*fiu));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tfiu = spi_controller_get_devdata(ctrl);\n\n\tfiu_data_match = of_device_get_match_data(dev);\n\tif (!fiu_data_match) {\n\t\tdev_err(dev, \"No compatible OF match\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tid = of_alias_get_id(dev->of_node, \"fiu\");\n\tif (id < 0 || id >= fiu_data_match->fiu_max) {\n\t\tdev_err(dev, \"Invalid platform device id: %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tfiu->info = &fiu_data_match->npcm_fiu_data_info[id];\n\n\tplatform_set_drvdata(pdev, fiu);\n\tfiu->dev = dev;\n\n\tregbase = devm_platform_ioremap_resource_byname(pdev, \"control\");\n\tif (IS_ERR(regbase))\n\t\treturn PTR_ERR(regbase);\n\n\tfiu->regmap = devm_regmap_init_mmio(dev, regbase,\n\t\t\t\t\t    &npcm_mtd_regmap_config);\n\tif (IS_ERR(fiu->regmap)) {\n\t\tdev_err(dev, \"Failed to create regmap\\n\");\n\t\treturn PTR_ERR(fiu->regmap);\n\t}\n\n\tfiu->res_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t    \"memory\");\n\tfiu->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(fiu->clk))\n\t\treturn PTR_ERR(fiu->clk);\n\n\tfiu->spix_mode = of_property_read_bool(dev->of_node,\n\t\t\t\t\t       \"nuvoton,spix-mode\");\n\n\tplatform_set_drvdata(pdev, fiu);\n\tclk_prepare_enable(fiu->clk);\n\n\tctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD\n\t\t| SPI_TX_DUAL | SPI_TX_QUAD;\n\tctrl->setup = npcm_fiu_setup;\n\tctrl->bus_num = -1;\n\tctrl->mem_ops = &npcm_fiu_mem_ops;\n\tctrl->num_chipselect = fiu->info->max_cs;\n\tctrl->dev.of_node = dev->of_node;\n\n\tret = devm_spi_register_controller(dev, ctrl);\n\tif (ret)\n\t\tclk_disable_unprepare(fiu->clk);\n\n\treturn ret;\n}\n\nstatic void npcm_fiu_remove(struct platform_device *pdev)\n{\n\tstruct npcm_fiu_spi *fiu = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(fiu->clk);\n}\n\nMODULE_DEVICE_TABLE(of, npcm_fiu_dt_ids);\n\nstatic struct platform_driver npcm_fiu_driver = {\n\t.driver = {\n\t\t.name\t= \"NPCM-FIU\",\n\t\t.bus\t= &platform_bus_type,\n\t\t.of_match_table = npcm_fiu_dt_ids,\n\t},\n\t.probe      = npcm_fiu_probe,\n\t.remove_new\t    = npcm_fiu_remove,\n};\nmodule_platform_driver(npcm_fiu_driver);\n\nMODULE_DESCRIPTION(\"Nuvoton FLASH Interface Unit SPI Controller Driver\");\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}