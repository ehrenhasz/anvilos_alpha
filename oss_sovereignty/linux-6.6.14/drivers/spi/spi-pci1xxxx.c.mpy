{
  "module_name": "spi-pci1xxxx.c",
  "hash_id": "fef4ac6fc8d8b3a6915997313b58054c83ea9d1f1524a136fc7c440959780bba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-pci1xxxx.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#define DRV_NAME \"spi-pci1xxxx\"\n\n#define\tSYS_FREQ_DEFAULT\t\t(62500000)\n\n#define\tPCI1XXXX_SPI_MAX_CLOCK_HZ\t(30000000)\n#define\tPCI1XXXX_SPI_CLK_20MHZ\t\t(20000000)\n#define\tPCI1XXXX_SPI_CLK_15MHZ\t\t(15000000)\n#define\tPCI1XXXX_SPI_CLK_12MHZ\t\t(12000000)\n#define\tPCI1XXXX_SPI_CLK_10MHZ\t\t(10000000)\n#define\tPCI1XXXX_SPI_MIN_CLOCK_HZ\t(2000000)\n\n#define\tPCI1XXXX_SPI_BUFFER_SIZE\t(320)\n\n#define\tSPI_MST_CTL_DEVSEL_MASK\t\t(GENMASK(27, 25))\n#define\tSPI_MST_CTL_CMD_LEN_MASK\t(GENMASK(16, 8))\n#define\tSPI_MST_CTL_SPEED_MASK\t\t(GENMASK(7, 5))\n#define\tSPI_MSI_VECTOR_SEL_MASK\t\t(GENMASK(4, 4))\n\n#define\tSPI_MST_CTL_FORCE_CE\t\t(BIT(4))\n#define\tSPI_MST_CTL_MODE_SEL\t\t(BIT(2))\n#define\tSPI_MST_CTL_GO\t\t\t(BIT(0))\n\n#define\tSPI_MST1_ADDR_BASE\t\t(0x800)\n\n \n\n#define\tSPI_MST_CMD_BUF_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x00)\n#define\tSPI_MST_RSP_BUF_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x200)\n#define\tSPI_MST_CTL_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x400)\n#define\tSPI_MST_EVENT_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x420)\n#define\tSPI_MST_EVENT_MASK_REG_OFFSET(x)\t(((x) * SPI_MST1_ADDR_BASE) + 0x424)\n#define\tSPI_MST_PAD_CTL_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x460)\n#define\tSPIALERT_MST_DB_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x464)\n#define\tSPIALERT_MST_VAL_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x468)\n#define\tSPI_PCI_CTRL_REG_OFFSET(x)\t\t(((x) * SPI_MST1_ADDR_BASE) + 0x480)\n\n#define PCI1XXXX_IRQ_FLAGS\t\t\t(IRQF_NO_SUSPEND | IRQF_TRIGGER_NONE)\n#define SPI_MAX_DATA_LEN\t\t\t320\n\n#define PCI1XXXX_SPI_TIMEOUT\t\t\t(msecs_to_jiffies(100))\n\n#define SPI_INTR\t\tBIT(8)\n#define SPI_FORCE_CE\t\tBIT(4)\n\n#define SPI_CHIP_SEL_COUNT 7\n#define VENDOR_ID_MCHP 0x1055\n\n#define SPI_SUSPEND_CONFIG 0x101\n#define SPI_RESUME_CONFIG 0x203\n\nstruct pci1xxxx_spi_internal {\n\tu8 hw_inst;\n\tbool spi_xfer_in_progress;\n\tint irq;\n\tstruct completion spi_xfer_done;\n\tstruct spi_controller *spi_host;\n\tstruct pci1xxxx_spi *parent;\n\tstruct {\n\t\tunsigned int dev_sel : 3;\n\t\tunsigned int msi_vector_sel : 1;\n\t} prev_val;\n};\n\nstruct pci1xxxx_spi {\n\tstruct pci_dev *dev;\n\tu8 total_hw_instances;\n\tvoid __iomem *reg_base;\n\tstruct pci1xxxx_spi_internal *spi_int[];\n};\n\nstatic const struct pci_device_id pci1xxxx_spi_pci_id_table[] = {\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa004, PCI_ANY_ID, 0x0001), 0, 0, 0x02},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa004, PCI_ANY_ID, 0x0002), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa004, PCI_ANY_ID, 0x0003), 0, 0, 0x11},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa004, PCI_ANY_ID, PCI_ANY_ID), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa014, PCI_ANY_ID, 0x0001), 0, 0, 0x02},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa014, PCI_ANY_ID, 0x0002), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa014, PCI_ANY_ID, 0x0003), 0, 0, 0x11},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa014, PCI_ANY_ID, PCI_ANY_ID), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa024, PCI_ANY_ID, 0x0001), 0, 0, 0x02},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa024, PCI_ANY_ID, 0x0002), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa024, PCI_ANY_ID, 0x0003), 0, 0, 0x11},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa024, PCI_ANY_ID, PCI_ANY_ID), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa034, PCI_ANY_ID, 0x0001), 0, 0, 0x02},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa034, PCI_ANY_ID, 0x0002), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa034, PCI_ANY_ID, 0x0003), 0, 0, 0x11},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa034, PCI_ANY_ID, PCI_ANY_ID), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa044, PCI_ANY_ID, 0x0001), 0, 0, 0x02},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa044, PCI_ANY_ID, 0x0002), 0, 0, 0x01},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa044, PCI_ANY_ID, 0x0003), 0, 0, 0x11},\n\t{ PCI_DEVICE_SUB(VENDOR_ID_MCHP, 0xa044, PCI_ANY_ID, PCI_ANY_ID), 0, 0, 0x01},\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, pci1xxxx_spi_pci_id_table);\n\nstatic void pci1xxxx_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct pci1xxxx_spi_internal *p = spi_controller_get_devdata(spi->controller);\n\tstruct pci1xxxx_spi *par = p->parent;\n\tu32 regval;\n\n\t \n\tregval = readl(par->reg_base + SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n\tif (!enable) {\n\t\tregval |= SPI_FORCE_CE;\n\t\tregval &= ~SPI_MST_CTL_DEVSEL_MASK;\n\t\tregval |= (spi_get_chipselect(spi, 0) << 25);\n\t} else {\n\t\tregval &= ~SPI_FORCE_CE;\n\t}\n\twritel(regval, par->reg_base + SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n}\n\nstatic u8 pci1xxxx_get_clock_div(u32 hz)\n{\n\tu8 val = 0;\n\n\tif (hz >= PCI1XXXX_SPI_MAX_CLOCK_HZ)\n\t\tval = 2;\n\telse if ((hz < PCI1XXXX_SPI_MAX_CLOCK_HZ) && (hz >= PCI1XXXX_SPI_CLK_20MHZ))\n\t\tval = 3;\n\telse if ((hz < PCI1XXXX_SPI_CLK_20MHZ) && (hz >= PCI1XXXX_SPI_CLK_15MHZ))\n\t\tval = 4;\n\telse if ((hz < PCI1XXXX_SPI_CLK_15MHZ) && (hz >= PCI1XXXX_SPI_CLK_12MHZ))\n\t\tval = 5;\n\telse if ((hz < PCI1XXXX_SPI_CLK_12MHZ) && (hz >= PCI1XXXX_SPI_CLK_10MHZ))\n\t\tval = 6;\n\telse if ((hz < PCI1XXXX_SPI_CLK_10MHZ) && (hz >= PCI1XXXX_SPI_MIN_CLOCK_HZ))\n\t\tval = 7;\n\telse\n\t\tval = 2;\n\n\treturn val;\n}\n\nstatic int pci1xxxx_spi_transfer_one(struct spi_controller *spi_ctlr,\n\t\t\t\t     struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct pci1xxxx_spi_internal *p = spi_controller_get_devdata(spi_ctlr);\n\tint mode, len, loop_iter, transfer_len;\n\tstruct pci1xxxx_spi *par = p->parent;\n\tunsigned long bytes_transfered;\n\tunsigned long bytes_recvd;\n\tunsigned long loop_count;\n\tu8 *rx_buf, result;\n\tconst u8 *tx_buf;\n\tu32 regval;\n\tu8 clkdiv;\n\n\tp->spi_xfer_in_progress = true;\n\tmode = spi->mode;\n\tclkdiv = pci1xxxx_get_clock_div(xfer->speed_hz);\n\ttx_buf = xfer->tx_buf;\n\trx_buf = xfer->rx_buf;\n\ttransfer_len = xfer->len;\n\tregval = readl(par->reg_base + SPI_MST_EVENT_REG_OFFSET(p->hw_inst));\n\twritel(regval, par->reg_base + SPI_MST_EVENT_REG_OFFSET(p->hw_inst));\n\n\tif (tx_buf) {\n\t\tbytes_transfered = 0;\n\t\tbytes_recvd = 0;\n\t\tloop_count = transfer_len / SPI_MAX_DATA_LEN;\n\t\tif (transfer_len % SPI_MAX_DATA_LEN != 0)\n\t\t\tloop_count += 1;\n\n\t\tfor (loop_iter = 0; loop_iter < loop_count; loop_iter++) {\n\t\t\tlen = SPI_MAX_DATA_LEN;\n\t\t\tif ((transfer_len % SPI_MAX_DATA_LEN != 0) &&\n\t\t\t    (loop_iter == loop_count - 1))\n\t\t\t\tlen = transfer_len % SPI_MAX_DATA_LEN;\n\n\t\t\treinit_completion(&p->spi_xfer_done);\n\t\t\tmemcpy_toio(par->reg_base + SPI_MST_CMD_BUF_OFFSET(p->hw_inst),\n\t\t\t\t    &tx_buf[bytes_transfered], len);\n\t\t\tbytes_transfered += len;\n\t\t\tregval = readl(par->reg_base +\n\t\t\t\t       SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n\t\t\tregval &= ~(SPI_MST_CTL_MODE_SEL | SPI_MST_CTL_CMD_LEN_MASK |\n\t\t\t\t    SPI_MST_CTL_SPEED_MASK);\n\n\t\t\tif (mode == SPI_MODE_3)\n\t\t\t\tregval |= SPI_MST_CTL_MODE_SEL;\n\t\t\telse\n\t\t\t\tregval &= ~SPI_MST_CTL_MODE_SEL;\n\n\t\t\tregval |= (clkdiv << 5);\n\t\t\tregval &= ~SPI_MST_CTL_CMD_LEN_MASK;\n\t\t\tregval |= (len << 8);\n\t\t\twritel(regval, par->reg_base +\n\t\t\t       SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n\t\t\tregval = readl(par->reg_base +\n\t\t\t\t       SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n\t\t\tregval |= SPI_MST_CTL_GO;\n\t\t\twritel(regval, par->reg_base +\n\t\t\t       SPI_MST_CTL_REG_OFFSET(p->hw_inst));\n\n\t\t\t \n\t\t\tresult = wait_for_completion_timeout(&p->spi_xfer_done,\n\t\t\t\t\t\t\t     PCI1XXXX_SPI_TIMEOUT);\n\t\t\tif (!result)\n\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\tif (rx_buf) {\n\t\t\t\tmemcpy_fromio(&rx_buf[bytes_recvd], par->reg_base +\n\t\t\t\t\t      SPI_MST_RSP_BUF_OFFSET(p->hw_inst), len);\n\t\t\t\tbytes_recvd += len;\n\t\t\t}\n\t\t}\n\t}\n\tp->spi_xfer_in_progress = false;\n\n\treturn 0;\n}\n\nstatic irqreturn_t pci1xxxx_spi_isr(int irq, void *dev)\n{\n\tstruct pci1xxxx_spi_internal *p = dev;\n\tirqreturn_t spi_int_fired = IRQ_NONE;\n\tu32 regval;\n\n\t \n\tregval = readl(p->parent->reg_base + SPI_MST_EVENT_REG_OFFSET(p->hw_inst));\n\tif (regval & SPI_INTR) {\n\t\t \n\t\tcomplete(&p->spi_xfer_done);\n\t\tspi_int_fired = IRQ_HANDLED;\n\t}\n\n\twritel(regval, p->parent->reg_base + SPI_MST_EVENT_REG_OFFSET(p->hw_inst));\n\n\treturn spi_int_fired;\n}\n\nstatic int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start, only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart = (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\telse\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t       struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\tif (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt; iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev, hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\t \n\t\t\tregval = readl(spi_bus->reg_base +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\tregval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev, spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tregval = readl(spi_bus->reg_base + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\t \n\t\t\tregval = readl(spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\tregval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev, spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0 | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev, spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n\nstatic void store_restore_config(struct pci1xxxx_spi *spi_ptr,\n\t\t\t\t struct pci1xxxx_spi_internal *spi_sub_ptr,\n\t\t\t\t u8 inst, bool store)\n{\n\tu32 regval;\n\n\tif (store) {\n\t\tregval = readl(spi_ptr->reg_base +\n\t\t\t       SPI_MST_CTL_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\tregval &= SPI_MST_CTL_DEVSEL_MASK;\n\t\tspi_sub_ptr->prev_val.dev_sel = (regval >> 25) & 7;\n\t\tregval = readl(spi_ptr->reg_base +\n\t\t\t       SPI_PCI_CTRL_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\tregval &= SPI_MSI_VECTOR_SEL_MASK;\n\t\tspi_sub_ptr->prev_val.msi_vector_sel = (regval >> 4) & 1;\n\t} else {\n\t\tregval = readl(spi_ptr->reg_base + SPI_MST_CTL_REG_OFFSET(inst));\n\t\tregval &= ~SPI_MST_CTL_DEVSEL_MASK;\n\t\tregval |= (spi_sub_ptr->prev_val.dev_sel << 25);\n\t\twritel(regval,\n\t\t       spi_ptr->reg_base + SPI_MST_CTL_REG_OFFSET(inst));\n\t\twritel((spi_sub_ptr->prev_val.msi_vector_sel << 4),\n\t\t\tspi_ptr->reg_base + SPI_PCI_CTRL_REG_OFFSET(inst));\n\t}\n}\n\nstatic int pci1xxxx_spi_resume(struct device *dev)\n{\n\tstruct pci1xxxx_spi *spi_ptr = dev_get_drvdata(dev);\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tu32 regval = SPI_RESUME_CONFIG;\n\tu8 iter;\n\n\tfor (iter = 0; iter < spi_ptr->total_hw_instances; iter++) {\n\t\tspi_sub_ptr = spi_ptr->spi_int[iter];\n\t\tspi_controller_resume(spi_sub_ptr->spi_host);\n\t\twritel(regval, spi_ptr->reg_base +\n\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(iter));\n\n\t\t \n\t\tstore_restore_config(spi_ptr, spi_sub_ptr, iter, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_spi_suspend(struct device *dev)\n{\n\tstruct pci1xxxx_spi *spi_ptr = dev_get_drvdata(dev);\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tu32 reg1 = SPI_SUSPEND_CONFIG;\n\tu8 iter;\n\n\tfor (iter = 0; iter < spi_ptr->total_hw_instances; iter++) {\n\t\tspi_sub_ptr = spi_ptr->spi_int[iter];\n\n\t\twhile (spi_sub_ptr->spi_xfer_in_progress)\n\t\t\tmsleep(20);\n\n\t\t \n\t\tstore_restore_config(spi_ptr, spi_sub_ptr, iter, 1);\n\t\tspi_controller_suspend(spi_sub_ptr->spi_host);\n\t\twritel(reg1, spi_ptr->reg_base +\n\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(iter));\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(spi_pm_ops, pci1xxxx_spi_suspend,\n\t\t\t\tpci1xxxx_spi_resume);\n\nstatic struct pci_driver pci1xxxx_spi_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= pci1xxxx_spi_pci_id_table,\n\t.probe\t\t= pci1xxxx_spi_probe,\n\t.driver\t\t=\t{\n\t\t.pm = pm_sleep_ptr(&spi_pm_ops),\n\t},\n};\n\nmodule_pci_driver(pci1xxxx_spi_driver);\n\nMODULE_DESCRIPTION(\"Microchip Technology Inc. pci1xxxx SPI bus driver\");\nMODULE_AUTHOR(\"Tharun Kumar P<tharunkumar.pasumarthi@microchip.com>\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan<kumaravel.thiagarajan@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}