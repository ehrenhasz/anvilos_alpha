{
  "module_name": "spi-mpc52xx.c",
  "hash_id": "8b2603c228b6658babf6f151c4c62317bf35ab2bbfcd53003b31d104409ab772",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mpc52xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/of_platform.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/time.h>\n#include <asm/mpc52xx.h>\n\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_DESCRIPTION(\"MPC52xx SPI (non-PSC) Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define SPI_CTRL1\t0x00\n#define SPI_CTRL1_SPIE\t\t(1 << 7)\n#define SPI_CTRL1_SPE\t\t(1 << 6)\n#define SPI_CTRL1_MSTR\t\t(1 << 4)\n#define SPI_CTRL1_CPOL\t\t(1 << 3)\n#define SPI_CTRL1_CPHA\t\t(1 << 2)\n#define SPI_CTRL1_SSOE\t\t(1 << 1)\n#define SPI_CTRL1_LSBFE\t\t(1 << 0)\n\n#define SPI_CTRL2\t0x01\n#define SPI_BRR\t\t0x04\n\n#define SPI_STATUS\t0x05\n#define SPI_STATUS_SPIF\t\t(1 << 7)\n#define SPI_STATUS_WCOL\t\t(1 << 6)\n#define SPI_STATUS_MODF\t\t(1 << 4)\n\n#define SPI_DATA\t0x09\n#define SPI_PORTDATA\t0x0d\n#define SPI_DATADIR\t0x10\n\n \n#define FSM_STOP\t0\t \n\t\t\t\t \n\t\t\t\t \n#define FSM_POLL\t1\t \n\t\t\t\t \n#define FSM_CONTINUE\t2\t \n\n \nstruct mpc52xx_spi {\n\tstruct spi_master *master;\n\tvoid __iomem *regs;\n\tint irq0;\t \n\tint irq1;\t \n\tunsigned int ipb_freq;\n\n\t \n\tint msg_count;\n\tint wcol_count;\n\tint wcol_ticks;\n\tu32 wcol_tx_timestamp;\n\tint modf_count;\n\tint byte_count;\n\n\tstruct list_head queue;\t\t \n\tspinlock_t lock;\n\tstruct work_struct work;\n\n\t \n\tstruct spi_message *message;\t \n\tstruct spi_transfer *transfer;\t \n\tint (*state)(int irq, struct mpc52xx_spi *ms, u8 status, u8 data);\n\tint len;\n\tint timestamp;\n\tu8 *rx_buf;\n\tconst u8 *tx_buf;\n\tint cs_change;\n\tint gpio_cs_count;\n\tstruct gpio_desc **gpio_cs;\n};\n\n \nstatic void mpc52xx_spi_chipsel(struct mpc52xx_spi *ms, int value)\n{\n\tint cs;\n\n\tif (ms->gpio_cs_count > 0) {\n\t\tcs = spi_get_chipselect(ms->message->spi, 0);\n\t\tgpiod_set_value(ms->gpio_cs[cs], value);\n\t} else {\n\t\tout_8(ms->regs + SPI_PORTDATA, value ? 0 : 0x08);\n\t}\n}\n\n \nstatic void mpc52xx_spi_start_transfer(struct mpc52xx_spi *ms)\n{\n\tms->rx_buf = ms->transfer->rx_buf;\n\tms->tx_buf = ms->transfer->tx_buf;\n\tms->len = ms->transfer->len;\n\n\t \n\tif (ms->cs_change)\n\t\tmpc52xx_spi_chipsel(ms, 1);\n\tms->cs_change = ms->transfer->cs_change;\n\n\t \n\tms->wcol_tx_timestamp = mftb();\n\tif (ms->tx_buf)\n\t\tout_8(ms->regs + SPI_DATA, *ms->tx_buf++);\n\telse\n\t\tout_8(ms->regs + SPI_DATA, 0);\n}\n\n \nstatic int mpc52xx_spi_fsmstate_transfer(int irq, struct mpc52xx_spi *ms,\n\t\t\t\t\t u8 status, u8 data);\nstatic int mpc52xx_spi_fsmstate_wait(int irq, struct mpc52xx_spi *ms,\n\t\t\t\t     u8 status, u8 data);\n\n \nstatic int\nmpc52xx_spi_fsmstate_idle(int irq, struct mpc52xx_spi *ms, u8 status, u8 data)\n{\n\tstruct spi_device *spi;\n\tint spr, sppr;\n\tu8 ctrl1;\n\n\tif (status && irq)\n\t\tdev_err(&ms->master->dev, \"spurious irq, status=0x%.2x\\n\",\n\t\t\tstatus);\n\n\t \n\tif (list_empty(&ms->queue))\n\t\treturn FSM_STOP;\n\n\t \n\tms->message = list_first_entry(&ms->queue, struct spi_message, queue);\n\tlist_del_init(&ms->message->queue);\n\n\t \n\tctrl1 = SPI_CTRL1_SPIE | SPI_CTRL1_SPE | SPI_CTRL1_MSTR;\n\tspi = ms->message->spi;\n\tif (spi->mode & SPI_CPHA)\n\t\tctrl1 |= SPI_CTRL1_CPHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tctrl1 |= SPI_CTRL1_CPOL;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tctrl1 |= SPI_CTRL1_LSBFE;\n\tout_8(ms->regs + SPI_CTRL1, ctrl1);\n\n\t \n\t \n\tsppr = ((ms->ipb_freq / ms->message->spi->max_speed_hz) + 1) >> 1;\n\tspr = 0;\n\tif (sppr < 1)\n\t\tsppr = 1;\n\twhile (((sppr - 1) & ~0x7) != 0) {\n\t\tsppr = (sppr + 1) >> 1;  \n\t\tspr++;\n\t}\n\tsppr--;\t\t \n\tif (spr > 7) {\n\t\t \n\t\tspr = 7;\n\t\tsppr = 7;\n\t}\n\tout_8(ms->regs + SPI_BRR, sppr << 4 | spr);  \n\n\tms->cs_change = 1;\n\tms->transfer = container_of(ms->message->transfers.next,\n\t\t\t\t    struct spi_transfer, transfer_list);\n\n\tmpc52xx_spi_start_transfer(ms);\n\tms->state = mpc52xx_spi_fsmstate_transfer;\n\n\treturn FSM_CONTINUE;\n}\n\n \nstatic int mpc52xx_spi_fsmstate_transfer(int irq, struct mpc52xx_spi *ms,\n\t\t\t\t\t u8 status, u8 data)\n{\n\tif (!status)\n\t\treturn ms->irq0 ? FSM_STOP : FSM_POLL;\n\n\tif (status & SPI_STATUS_WCOL) {\n\t\t \n\t\tms->wcol_count++;\n\t\tms->wcol_ticks += mftb() - ms->wcol_tx_timestamp;\n\t\tms->wcol_tx_timestamp = mftb();\n\t\tdata = 0;\n\t\tif (ms->tx_buf)\n\t\t\tdata = *(ms->tx_buf - 1);\n\t\tout_8(ms->regs + SPI_DATA, data);  \n\t\treturn FSM_CONTINUE;\n\t} else if (status & SPI_STATUS_MODF) {\n\t\tms->modf_count++;\n\t\tdev_err(&ms->master->dev, \"mode fault\\n\");\n\t\tmpc52xx_spi_chipsel(ms, 0);\n\t\tms->message->status = -EIO;\n\t\tif (ms->message->complete)\n\t\t\tms->message->complete(ms->message->context);\n\t\tms->state = mpc52xx_spi_fsmstate_idle;\n\t\treturn FSM_CONTINUE;\n\t}\n\n\t \n\tms->byte_count++;\n\tif (ms->rx_buf)\n\t\t*ms->rx_buf++ = data;\n\n\t \n\tms->len--;\n\tif (ms->len == 0) {\n\t\tms->timestamp = mftb();\n\t\tif (ms->transfer->delay.unit == SPI_DELAY_UNIT_USECS)\n\t\t\tms->timestamp += ms->transfer->delay.value *\n\t\t\t\t\t tb_ticks_per_usec;\n\t\tms->state = mpc52xx_spi_fsmstate_wait;\n\t\treturn FSM_CONTINUE;\n\t}\n\n\t \n\tms->wcol_tx_timestamp = mftb();\n\tif (ms->tx_buf)\n\t\tout_8(ms->regs + SPI_DATA, *ms->tx_buf++);\n\telse\n\t\tout_8(ms->regs + SPI_DATA, 0);\n\n\treturn FSM_CONTINUE;\n}\n\n \nstatic int\nmpc52xx_spi_fsmstate_wait(int irq, struct mpc52xx_spi *ms, u8 status, u8 data)\n{\n\tif (status && irq)\n\t\tdev_err(&ms->master->dev, \"spurious irq, status=0x%.2x\\n\",\n\t\t\tstatus);\n\n\tif (((int)mftb()) - ms->timestamp < 0)\n\t\treturn FSM_POLL;\n\n\tms->message->actual_length += ms->transfer->len;\n\n\t \n\tif (ms->transfer->transfer_list.next == &ms->message->transfers) {\n\t\tms->msg_count++;\n\t\tmpc52xx_spi_chipsel(ms, 0);\n\t\tms->message->status = 0;\n\t\tif (ms->message->complete)\n\t\t\tms->message->complete(ms->message->context);\n\t\tms->state = mpc52xx_spi_fsmstate_idle;\n\t\treturn FSM_CONTINUE;\n\t}\n\n\t \n\n\tif (ms->cs_change)\n\t\tmpc52xx_spi_chipsel(ms, 0);\n\n\tms->transfer = container_of(ms->transfer->transfer_list.next,\n\t\t\t\t    struct spi_transfer, transfer_list);\n\tmpc52xx_spi_start_transfer(ms);\n\tms->state = mpc52xx_spi_fsmstate_transfer;\n\treturn FSM_CONTINUE;\n}\n\n \nstatic void mpc52xx_spi_fsm_process(int irq, struct mpc52xx_spi *ms)\n{\n\tint rc = FSM_CONTINUE;\n\tu8 status, data;\n\n\twhile (rc == FSM_CONTINUE) {\n\t\t \n\t\tstatus = in_8(ms->regs + SPI_STATUS);\n\t\tdata = in_8(ms->regs + SPI_DATA);\n\t\trc = ms->state(irq, ms, status, data);\n\t}\n\n\tif (rc == FSM_POLL)\n\t\tschedule_work(&ms->work);\n}\n\n \nstatic irqreturn_t mpc52xx_spi_irq(int irq, void *_ms)\n{\n\tstruct mpc52xx_spi *ms = _ms;\n\tspin_lock(&ms->lock);\n\tmpc52xx_spi_fsm_process(irq, ms);\n\tspin_unlock(&ms->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void mpc52xx_spi_wq(struct work_struct *work)\n{\n\tstruct mpc52xx_spi *ms = container_of(work, struct mpc52xx_spi, work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ms->lock, flags);\n\tmpc52xx_spi_fsm_process(0, ms);\n\tspin_unlock_irqrestore(&ms->lock, flags);\n}\n\n \n\nstatic int mpc52xx_spi_transfer(struct spi_device *spi, struct spi_message *m)\n{\n\tstruct mpc52xx_spi *ms = spi_master_get_devdata(spi->master);\n\tunsigned long flags;\n\n\tm->actual_length = 0;\n\tm->status = -EINPROGRESS;\n\n\tspin_lock_irqsave(&ms->lock, flags);\n\tlist_add_tail(&m->queue, &ms->queue);\n\tspin_unlock_irqrestore(&ms->lock, flags);\n\tschedule_work(&ms->work);\n\n\treturn 0;\n}\n\n \nstatic int mpc52xx_spi_probe(struct platform_device *op)\n{\n\tstruct spi_master *master;\n\tstruct mpc52xx_spi *ms;\n\tstruct gpio_desc *gpio_cs;\n\tvoid __iomem *regs;\n\tu8 ctrl1;\n\tint rc, i = 0;\n\n\t \n\tdev_dbg(&op->dev, \"probing mpc5200 SPI device\\n\");\n\tregs = of_iomap(op->dev.of_node, 0);\n\tif (!regs)\n\t\treturn -ENODEV;\n\n\t \n\tctrl1 = SPI_CTRL1_SPIE | SPI_CTRL1_SPE | SPI_CTRL1_MSTR;\n\tout_8(regs + SPI_CTRL1, ctrl1);\n\tout_8(regs + SPI_CTRL2, 0x0);\n\tout_8(regs + SPI_DATADIR, 0xe);\t \n\tout_8(regs + SPI_PORTDATA, 0x8);\t \n\n\t \n\tin_8(regs + SPI_STATUS);\n\tout_8(regs + SPI_CTRL1, ctrl1);\n\n\tin_8(regs + SPI_DATA);\n\tif (in_8(regs + SPI_STATUS) & SPI_STATUS_MODF) {\n\t\tdev_err(&op->dev, \"mode fault; is port_config correct?\\n\");\n\t\trc = -EIO;\n\t\tgoto err_init;\n\t}\n\n\tdev_dbg(&op->dev, \"allocating spi_master struct\\n\");\n\tmaster = spi_alloc_master(&op->dev, sizeof(*ms));\n\tif (!master) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tmaster->transfer = mpc52xx_spi_transfer;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->dev.of_node = op->dev.of_node;\n\n\tplatform_set_drvdata(op, master);\n\n\tms = spi_master_get_devdata(master);\n\tms->master = master;\n\tms->regs = regs;\n\tms->irq0 = irq_of_parse_and_map(op->dev.of_node, 0);\n\tms->irq1 = irq_of_parse_and_map(op->dev.of_node, 1);\n\tms->state = mpc52xx_spi_fsmstate_idle;\n\tms->ipb_freq = mpc5xxx_get_bus_frequency(&op->dev);\n\tms->gpio_cs_count = gpiod_count(&op->dev, NULL);\n\tif (ms->gpio_cs_count > 0) {\n\t\tmaster->num_chipselect = ms->gpio_cs_count;\n\t\tms->gpio_cs = kmalloc_array(ms->gpio_cs_count,\n\t\t\t\t\t    sizeof(*ms->gpio_cs),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ms->gpio_cs) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_alloc_gpio;\n\t\t}\n\n\t\tfor (i = 0; i < ms->gpio_cs_count; i++) {\n\t\t\tgpio_cs = gpiod_get_index(&op->dev,\n\t\t\t\t\t\t  NULL, i, GPIOD_OUT_LOW);\n\t\t\trc = PTR_ERR_OR_ZERO(gpio_cs);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(&op->dev,\n\t\t\t\t\t\"failed to get spi cs gpio #%d: %d\\n\",\n\t\t\t\t\ti, rc);\n\t\t\t\tgoto err_gpio;\n\t\t\t}\n\n\t\t\tms->gpio_cs[i] = gpio_cs;\n\t\t}\n\t}\n\n\tspin_lock_init(&ms->lock);\n\tINIT_LIST_HEAD(&ms->queue);\n\tINIT_WORK(&ms->work, mpc52xx_spi_wq);\n\n\t \n\tif (ms->irq0 && ms->irq1) {\n\t\trc = request_irq(ms->irq0, mpc52xx_spi_irq, 0,\n\t\t\t\t  \"mpc5200-spi-modf\", ms);\n\t\trc |= request_irq(ms->irq1, mpc52xx_spi_irq, 0,\n\t\t\t\t  \"mpc5200-spi-spif\", ms);\n\t\tif (rc) {\n\t\t\tfree_irq(ms->irq0, ms);\n\t\t\tfree_irq(ms->irq1, ms);\n\t\t\tms->irq0 = ms->irq1 = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tms->irq0 = ms->irq1 = 0;\n\t}\n\n\tif (!ms->irq0)\n\t\tdev_info(&op->dev, \"using polled mode\\n\");\n\n\tdev_dbg(&op->dev, \"registering spi_master struct\\n\");\n\trc = spi_register_master(master);\n\tif (rc)\n\t\tgoto err_register;\n\n\tdev_info(&ms->master->dev, \"registered MPC5200 SPI bus\\n\");\n\n\treturn rc;\n\n err_register:\n\tdev_err(&ms->master->dev, \"initialization failed\\n\");\n err_gpio:\n\twhile (i-- > 0)\n\t\tgpiod_put(ms->gpio_cs[i]);\n\n\tkfree(ms->gpio_cs);\n err_alloc_gpio:\n\tspi_master_put(master);\n err_alloc:\n err_init:\n\tiounmap(regs);\n\treturn rc;\n}\n\nstatic void mpc52xx_spi_remove(struct platform_device *op)\n{\n\tstruct spi_master *master = spi_master_get(platform_get_drvdata(op));\n\tstruct mpc52xx_spi *ms = spi_master_get_devdata(master);\n\tint i;\n\n\tfree_irq(ms->irq0, ms);\n\tfree_irq(ms->irq1, ms);\n\n\tfor (i = 0; i < ms->gpio_cs_count; i++)\n\t\tgpiod_put(ms->gpio_cs[i]);\n\n\tkfree(ms->gpio_cs);\n\tspi_unregister_master(master);\n\tiounmap(ms->regs);\n\tspi_master_put(master);\n}\n\nstatic const struct of_device_id mpc52xx_spi_match[] = {\n\t{ .compatible = \"fsl,mpc5200-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mpc52xx_spi_match);\n\nstatic struct platform_driver mpc52xx_spi_of_driver = {\n\t.driver = {\n\t\t.name = \"mpc52xx-spi\",\n\t\t.of_match_table = mpc52xx_spi_match,\n\t},\n\t.probe = mpc52xx_spi_probe,\n\t.remove_new = mpc52xx_spi_remove,\n};\nmodule_platform_driver(mpc52xx_spi_of_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}