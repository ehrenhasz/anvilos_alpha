{
  "module_name": "spi-hisi-sfc-v3xx.c",
  "hash_id": "ae881033cd64ff7178c1833578ef21194e3c80d833af379df91030866784d110",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-hisi-sfc-v3xx.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/dmi.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#define HISI_SFC_V3XX_VERSION (0x1f8)\n\n#define HISI_SFC_V3XX_GLB_CFG (0x100)\n#define HISI_SFC_V3XX_GLB_CFG_CS0_ADDR_MODE BIT(2)\n#define HISI_SFC_V3XX_RAW_INT_STAT (0x120)\n#define HISI_SFC_V3XX_INT_STAT (0x124)\n#define HISI_SFC_V3XX_INT_MASK (0x128)\n#define HISI_SFC_V3XX_INT_CLR (0x12c)\n#define HISI_SFC_V3XX_CMD_CFG (0x300)\n#define HISI_SFC_V3XX_CMD_CFG_DATA_CNT_OFF 9\n#define HISI_SFC_V3XX_CMD_CFG_RW_MSK BIT(8)\n#define HISI_SFC_V3XX_CMD_CFG_DATA_EN_MSK BIT(7)\n#define HISI_SFC_V3XX_CMD_CFG_DUMMY_CNT_OFF 4\n#define HISI_SFC_V3XX_CMD_CFG_ADDR_EN_MSK BIT(3)\n#define HISI_SFC_V3XX_CMD_CFG_CS_SEL_OFF 1\n#define HISI_SFC_V3XX_CMD_CFG_START_MSK BIT(0)\n#define HISI_SFC_V3XX_CMD_INS (0x308)\n#define HISI_SFC_V3XX_CMD_ADDR (0x30c)\n#define HISI_SFC_V3XX_CMD_DATABUF0 (0x400)\n\n \n#define HISI_SFC_V3XX_INT_MASK_ALL (0x1ff)\t \n#define HISI_SFC_V3XX_INT_MASK_CPLT BIT(0)\t \n#define HISI_SFC_V3XX_INT_MASK_PP_ERR BIT(2)\t \n#define HISI_SFC_V3XX_INT_MASK_IACCES BIT(5)\t \n\n \n#define HISI_SFC_V3XX_STD (0 << 17)\n#define HISI_SFC_V3XX_DIDO (1 << 17)\n#define HISI_SFC_V3XX_DIO (2 << 17)\n#define HISI_SFC_V3XX_FULL_DIO (3 << 17)\n#define HISI_SFC_V3XX_QIQO (5 << 17)\n#define HISI_SFC_V3XX_QIO (6 << 17)\n#define HISI_SFC_V3XX_FULL_QIO (7 << 17)\n\n \nstatic const int hisi_sfc_v3xx_io_modes[2][3][3] = {\n\t{\n\t\t{ HISI_SFC_V3XX_DIDO, HISI_SFC_V3XX_DIDO, HISI_SFC_V3XX_DIDO },\n\t\t{ HISI_SFC_V3XX_DIO, HISI_SFC_V3XX_FULL_DIO, -EIO },\n\t\t{ -EIO, -EIO, -EIO },\n\t},\n\t{\n\t\t{ HISI_SFC_V3XX_QIQO, HISI_SFC_V3XX_QIQO, HISI_SFC_V3XX_QIQO },\n\t\t{ -EIO, -EIO, -EIO },\n\t\t{ HISI_SFC_V3XX_QIO, -EIO, HISI_SFC_V3XX_FULL_QIO },\n\t},\n};\n\nstruct hisi_sfc_v3xx_host {\n\tstruct device *dev;\n\tvoid __iomem *regbase;\n\tint max_cmd_dword;\n\tstruct completion *completion;\n\tu8 address_mode;\n\tint irq;\n};\n\nstatic void hisi_sfc_v3xx_disable_int(struct hisi_sfc_v3xx_host *host)\n{\n\twritel(0, host->regbase + HISI_SFC_V3XX_INT_MASK);\n}\n\nstatic void hisi_sfc_v3xx_enable_int(struct hisi_sfc_v3xx_host *host)\n{\n\twritel(HISI_SFC_V3XX_INT_MASK_ALL, host->regbase + HISI_SFC_V3XX_INT_MASK);\n}\n\nstatic void hisi_sfc_v3xx_clear_int(struct hisi_sfc_v3xx_host *host)\n{\n\twritel(HISI_SFC_V3XX_INT_MASK_ALL, host->regbase + HISI_SFC_V3XX_INT_CLR);\n}\n\n \nstatic int hisi_sfc_v3xx_handle_completion(struct hisi_sfc_v3xx_host *host)\n{\n\tu32 reg;\n\n\treg = readl(host->regbase + HISI_SFC_V3XX_RAW_INT_STAT);\n\thisi_sfc_v3xx_clear_int(host);\n\n\tif (reg & HISI_SFC_V3XX_INT_MASK_IACCES) {\n\t\tdev_err(host->dev, \"fail to access protected address\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (reg & HISI_SFC_V3XX_INT_MASK_PP_ERR) {\n\t\tdev_err(host->dev, \"page program operation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!(reg & HISI_SFC_V3XX_INT_MASK_CPLT)) {\n\t\tdev_err(host->dev, \"unsupported error occurred, status=0x%x\\n\", reg);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n#define HISI_SFC_V3XX_WAIT_TIMEOUT_US\t\t1000000\n#define HISI_SFC_V3XX_WAIT_POLL_INTERVAL_US\t10\n\nstatic int hisi_sfc_v3xx_wait_cmd_idle(struct hisi_sfc_v3xx_host *host)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(host->regbase + HISI_SFC_V3XX_CMD_CFG, reg,\n\t\t\t\t  !(reg & HISI_SFC_V3XX_CMD_CFG_START_MSK),\n\t\t\t\t  HISI_SFC_V3XX_WAIT_POLL_INTERVAL_US,\n\t\t\t\t  HISI_SFC_V3XX_WAIT_TIMEOUT_US);\n}\n\nstatic int hisi_sfc_v3xx_adjust_op_size(struct spi_mem *mem,\n\t\t\t\t\tstruct spi_mem_op *op)\n{\n\tstruct spi_device *spi = mem->spi;\n\tstruct hisi_sfc_v3xx_host *host;\n\tuintptr_t addr = (uintptr_t)op->data.buf.in;\n\tint max_byte_count;\n\n\thost = spi_controller_get_devdata(spi->controller);\n\n\tmax_byte_count = host->max_cmd_dword * 4;\n\n\tif (!IS_ALIGNED(addr, 4) && op->data.nbytes >= 4)\n\t\top->data.nbytes = 4 - (addr % 4);\n\telse if (op->data.nbytes > max_byte_count)\n\t\top->data.nbytes = max_byte_count;\n\n\treturn 0;\n}\n\n \nstatic bool hisi_sfc_v3xx_supports_op(struct spi_mem *mem,\n\t\t\t\t      const struct spi_mem_op *op)\n{\n\tstruct spi_device *spi = mem->spi;\n\tstruct hisi_sfc_v3xx_host *host;\n\n\thost = spi_controller_get_devdata(spi->controller);\n\n\tif (op->data.buswidth > 4 || op->dummy.buswidth > 4 ||\n\t    op->addr.buswidth > 4 || op->cmd.buswidth > 4)\n\t\treturn false;\n\n\tif (op->addr.nbytes != host->address_mode && op->addr.nbytes)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\n \nstatic void hisi_sfc_v3xx_read_databuf(struct hisi_sfc_v3xx_host *host,\n\t\t\t\t       u8 *to, unsigned int len)\n{\n\tvoid __iomem *from;\n\tint i;\n\n\tfrom = host->regbase + HISI_SFC_V3XX_CMD_DATABUF0;\n\n\tif (IS_ALIGNED((uintptr_t)to, 4)) {\n\t\tint words = len / 4;\n\n\t\t__ioread32_copy(to, from, words);\n\n\t\tlen -= words * 4;\n\t\tif (len) {\n\t\t\tu32 val;\n\n\t\t\tto += words * 4;\n\t\t\tfrom += words * 4;\n\n\t\t\tval = __raw_readl(from);\n\n\t\t\tfor (i = 0; i < len; i++, val >>= 8, to++)\n\t\t\t\t*to = (u8)val;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < DIV_ROUND_UP(len, 4); i++, from += 4) {\n\t\t\tu32 val = __raw_readl(from);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < 4 && (j + (i * 4) < len);\n\t\t\t     to++, val >>= 8, j++)\n\t\t\t\t*to = (u8)val;\n\t\t}\n\t}\n}\n\nstatic void hisi_sfc_v3xx_write_databuf(struct hisi_sfc_v3xx_host *host,\n\t\t\t\t\tconst u8 *from, unsigned int len)\n{\n\tvoid __iomem *to;\n\tint i;\n\n\tto = host->regbase + HISI_SFC_V3XX_CMD_DATABUF0;\n\n\tif (IS_ALIGNED((uintptr_t)from, 4)) {\n\t\tint words = len / 4;\n\n\t\t__iowrite32_copy(to, from, words);\n\n\t\tlen -= words * 4;\n\t\tif (len) {\n\t\t\tu32 val = 0;\n\n\t\t\tto += words * 4;\n\t\t\tfrom += words * 4;\n\n\t\t\tfor (i = 0; i < len; i++, from++)\n\t\t\t\tval |= *from << i * 8;\n\t\t\t__raw_writel(val, to);\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < DIV_ROUND_UP(len, 4); i++, to += 4) {\n\t\t\tu32 val = 0;\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < 4 && (j + (i * 4) < len);\n\t\t\t     from++, j++)\n\t\t\t\tval |= *from << j * 8;\n\t\t\t__raw_writel(val, to);\n\t\t}\n\t}\n}\n\nstatic int hisi_sfc_v3xx_start_bus(struct hisi_sfc_v3xx_host *host,\n\t\t\t\t   const struct spi_mem_op *op,\n\t\t\t\t   u8 chip_select)\n{\n\tint len = op->data.nbytes, buswidth_mode;\n\tu32 config = 0;\n\n\tif (op->addr.nbytes)\n\t\tconfig |= HISI_SFC_V3XX_CMD_CFG_ADDR_EN_MSK;\n\n\tif (op->data.buswidth == 0 || op->data.buswidth == 1) {\n\t\tbuswidth_mode = HISI_SFC_V3XX_STD;\n\t} else {\n\t\tint data_idx, addr_idx, cmd_idx;\n\n\t\tdata_idx = (op->data.buswidth - 1) / 2;\n\t\taddr_idx = op->addr.buswidth / 2;\n\t\tcmd_idx = op->cmd.buswidth / 2;\n\t\tbuswidth_mode = hisi_sfc_v3xx_io_modes[data_idx][addr_idx][cmd_idx];\n\t}\n\tif (buswidth_mode < 0)\n\t\treturn buswidth_mode;\n\tconfig |= buswidth_mode;\n\n\tif (op->data.dir != SPI_MEM_NO_DATA) {\n\t\tconfig |= (len - 1) << HISI_SFC_V3XX_CMD_CFG_DATA_CNT_OFF;\n\t\tconfig |= HISI_SFC_V3XX_CMD_CFG_DATA_EN_MSK;\n\t}\n\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\tconfig |= HISI_SFC_V3XX_CMD_CFG_RW_MSK;\n\n\tconfig |= op->dummy.nbytes << HISI_SFC_V3XX_CMD_CFG_DUMMY_CNT_OFF |\n\t\t  chip_select << HISI_SFC_V3XX_CMD_CFG_CS_SEL_OFF |\n\t\t  HISI_SFC_V3XX_CMD_CFG_START_MSK;\n\n\twritel(op->addr.val, host->regbase + HISI_SFC_V3XX_CMD_ADDR);\n\twritel(op->cmd.opcode, host->regbase + HISI_SFC_V3XX_CMD_INS);\n\n\twritel(config, host->regbase + HISI_SFC_V3XX_CMD_CFG);\n\n\treturn 0;\n}\n\nstatic int hisi_sfc_v3xx_generic_exec_op(struct hisi_sfc_v3xx_host *host,\n\t\t\t\t\t const struct spi_mem_op *op,\n\t\t\t\t\t u8 chip_select)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint ret;\n\n\tif (host->irq) {\n\t\thost->completion = &done;\n\t\thisi_sfc_v3xx_enable_int(host);\n\t}\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\thisi_sfc_v3xx_write_databuf(host, op->data.buf.out, op->data.nbytes);\n\n\tret = hisi_sfc_v3xx_start_bus(host, op, chip_select);\n\tif (ret)\n\t\treturn ret;\n\n\tif (host->irq) {\n\t\tret = wait_for_completion_timeout(host->completion,\n\t\t\t\t\t\t  usecs_to_jiffies(HISI_SFC_V3XX_WAIT_TIMEOUT_US));\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\tret = 0;\n\n\t\thisi_sfc_v3xx_disable_int(host);\n\t\tsynchronize_irq(host->irq);\n\t\thost->completion = NULL;\n\t} else {\n\t\tret = hisi_sfc_v3xx_wait_cmd_idle(host);\n\t}\n\tif (hisi_sfc_v3xx_handle_completion(host) || ret)\n\t\treturn -EIO;\n\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\thisi_sfc_v3xx_read_databuf(host, op->data.buf.in, op->data.nbytes);\n\n\treturn 0;\n}\n\nstatic int hisi_sfc_v3xx_exec_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct hisi_sfc_v3xx_host *host;\n\tstruct spi_device *spi = mem->spi;\n\tu8 chip_select = spi_get_chipselect(spi, 0);\n\n\thost = spi_controller_get_devdata(spi->controller);\n\n\treturn hisi_sfc_v3xx_generic_exec_op(host, op, chip_select);\n}\n\nstatic const struct spi_controller_mem_ops hisi_sfc_v3xx_mem_ops = {\n\t.adjust_op_size = hisi_sfc_v3xx_adjust_op_size,\n\t.supports_op = hisi_sfc_v3xx_supports_op,\n\t.exec_op = hisi_sfc_v3xx_exec_op,\n};\n\nstatic irqreturn_t hisi_sfc_v3xx_isr(int irq, void *data)\n{\n\tstruct hisi_sfc_v3xx_host *host = data;\n\n\thisi_sfc_v3xx_disable_int(host);\n\n\tcomplete(host->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hisi_sfc_v3xx_buswidth_override_bits;\n\n \nstatic int __init hisi_sfc_v3xx_dmi_quirk(const struct dmi_system_id *d)\n{\n\thisi_sfc_v3xx_buswidth_override_bits = SPI_RX_QUAD | SPI_TX_QUAD;\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id hisi_sfc_v3xx_dmi_quirk_table[]  = {\n\t{\n\t.callback = hisi_sfc_v3xx_dmi_quirk,\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Huawei\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"D06\"),\n\t},\n\t},\n\t{\n\t.callback = hisi_sfc_v3xx_dmi_quirk,\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Huawei\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TaiShan 2280 V2\"),\n\t},\n\t},\n\t{\n\t.callback = hisi_sfc_v3xx_dmi_quirk,\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Huawei\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TaiShan 200 (Model 2280)\"),\n\t},\n\t},\n\t{}\n};\n\nstatic int hisi_sfc_v3xx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hisi_sfc_v3xx_host *host;\n\tstruct spi_controller *ctlr;\n\tu32 version, glb_config;\n\tint ret;\n\n\tctlr = spi_alloc_host(&pdev->dev, sizeof(*host));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tctlr->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD |\n\t\t\t  SPI_TX_DUAL | SPI_TX_QUAD;\n\n\tctlr->buswidth_override_bits = hisi_sfc_v3xx_buswidth_override_bits;\n\n\thost = spi_controller_get_devdata(ctlr);\n\thost->dev = dev;\n\n\tplatform_set_drvdata(pdev, host);\n\n\thost->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->regbase)) {\n\t\tret = PTR_ERR(host->regbase);\n\t\tgoto err_put_host;\n\t}\n\n\thost->irq = platform_get_irq_optional(pdev, 0);\n\tif (host->irq == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_put_host;\n\t}\n\n\thisi_sfc_v3xx_disable_int(host);\n\n\tif (host->irq > 0) {\n\t\tret = devm_request_irq(dev, host->irq, hisi_sfc_v3xx_isr, 0,\n\t\t\t\t       \"hisi-sfc-v3xx\", host);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request irq%d, ret = %d\\n\", host->irq, ret);\n\t\t\thost->irq = 0;\n\t\t}\n\t} else {\n\t\thost->irq = 0;\n\t}\n\n\tctlr->bus_num = -1;\n\tctlr->num_chipselect = 1;\n\tctlr->mem_ops = &hisi_sfc_v3xx_mem_ops;\n\n\t \n\tglb_config = readl(host->regbase + HISI_SFC_V3XX_GLB_CFG);\n\tif (glb_config & HISI_SFC_V3XX_GLB_CFG_CS0_ADDR_MODE)\n\t\thost->address_mode = 4;\n\telse\n\t\thost->address_mode = 3;\n\n\tversion = readl(host->regbase + HISI_SFC_V3XX_VERSION);\n\n\tif (version >= 0x351)\n\t\thost->max_cmd_dword = 64;\n\telse\n\t\thost->max_cmd_dword = 16;\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret)\n\t\tgoto err_put_host;\n\n\tdev_info(&pdev->dev, \"hw version 0x%x, %s mode.\\n\",\n\t\t version, host->irq ? \"irq\" : \"polling\");\n\n\treturn 0;\n\nerr_put_host:\n\tspi_controller_put(ctlr);\n\treturn ret;\n}\n\nstatic const struct acpi_device_id hisi_sfc_v3xx_acpi_ids[] = {\n\t{\"HISI0341\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, hisi_sfc_v3xx_acpi_ids);\n\nstatic struct platform_driver hisi_sfc_v3xx_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"hisi-sfc-v3xx\",\n\t\t.acpi_match_table = hisi_sfc_v3xx_acpi_ids,\n\t},\n\t.probe\t= hisi_sfc_v3xx_probe,\n};\n\nstatic int __init hisi_sfc_v3xx_spi_init(void)\n{\n\tdmi_check_system(hisi_sfc_v3xx_dmi_quirk_table);\n\n\treturn platform_driver_register(&hisi_sfc_v3xx_spi_driver);\n}\n\nstatic void __exit hisi_sfc_v3xx_spi_exit(void)\n{\n\tplatform_driver_unregister(&hisi_sfc_v3xx_spi_driver);\n}\n\nmodule_init(hisi_sfc_v3xx_spi_init);\nmodule_exit(hisi_sfc_v3xx_spi_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Garry <john.garry@huawei.com>\");\nMODULE_DESCRIPTION(\"HiSilicon SPI NOR V3XX Flash Controller Driver for hi16xx chipsets\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}