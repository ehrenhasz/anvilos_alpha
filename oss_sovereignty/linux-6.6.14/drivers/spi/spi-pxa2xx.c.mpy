{
  "module_name": "spi-pxa2xx.c",
  "hash_id": "1b26913a3b2b941e584d7adc6e1b986e8bdccce0b8c30ba3b10836275c8c82f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-pxa2xx.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/spi/pxa2xx_spi.h>\n#include <linux/spi/spi.h>\n\n#include \"spi-pxa2xx.h\"\n\nMODULE_AUTHOR(\"Stephen Street\");\nMODULE_DESCRIPTION(\"PXA2xx SSP SPI Controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-spi\");\n\n#define TIMOUT_DFLT\t\t1000\n\n \n#define SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \\\n\t\t\t\t| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \\\n\t\t\t\t| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \\\n\t\t\t\t| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \\\n\t\t\t\t| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \\\n\t\t\t\t| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)\n\n#define QUARK_X1000_SSCR1_CHANGE_MASK (QUARK_X1000_SSCR1_STRF\t\\\n\t\t\t\t| QUARK_X1000_SSCR1_EFWR\t\\\n\t\t\t\t| QUARK_X1000_SSCR1_RFT\t\t\\\n\t\t\t\t| QUARK_X1000_SSCR1_TFT\t\t\\\n\t\t\t\t| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)\n\n#define CE4100_SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \\\n\t\t\t\t| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \\\n\t\t\t\t| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \\\n\t\t\t\t| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \\\n\t\t\t\t| CE4100_SSCR1_RFT | CE4100_SSCR1_TFT | SSCR1_MWDS \\\n\t\t\t\t| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)\n\n#define LPSS_GENERAL_REG_RXTO_HOLDOFF_DISABLE\tBIT(24)\n#define LPSS_CS_CONTROL_SW_MODE\t\t\tBIT(0)\n#define LPSS_CS_CONTROL_CS_HIGH\t\t\tBIT(1)\n#define LPSS_CAPS_CS_EN_SHIFT\t\t\t9\n#define LPSS_CAPS_CS_EN_MASK\t\t\t(0xf << LPSS_CAPS_CS_EN_SHIFT)\n\n#define LPSS_PRIV_CLOCK_GATE 0x38\n#define LPSS_PRIV_CLOCK_GATE_CLK_CTL_MASK 0x3\n#define LPSS_PRIV_CLOCK_GATE_CLK_CTL_FORCE_ON 0x3\n\nstruct lpss_config {\n\t \n\tunsigned offset;\n\t \n\tint reg_general;\n\tint reg_ssp;\n\tint reg_cs_ctrl;\n\tint reg_capabilities;\n\t \n\tu32 rx_threshold;\n\tu32 tx_threshold_lo;\n\tu32 tx_threshold_hi;\n\t \n\tunsigned cs_sel_shift;\n\tunsigned cs_sel_mask;\n\tunsigned cs_num;\n\t \n\tunsigned cs_clk_stays_gated : 1;\n};\n\n \nstatic const struct lpss_config lpss_platforms[] = {\n\t{\t \n\t\t.offset = 0x800,\n\t\t.reg_general = 0x08,\n\t\t.reg_ssp = 0x0c,\n\t\t.reg_cs_ctrl = 0x18,\n\t\t.reg_capabilities = -1,\n\t\t.rx_threshold = 64,\n\t\t.tx_threshold_lo = 160,\n\t\t.tx_threshold_hi = 224,\n\t},\n\t{\t \n\t\t.offset = 0x400,\n\t\t.reg_general = 0x08,\n\t\t.reg_ssp = 0x0c,\n\t\t.reg_cs_ctrl = 0x18,\n\t\t.reg_capabilities = -1,\n\t\t.rx_threshold = 64,\n\t\t.tx_threshold_lo = 160,\n\t\t.tx_threshold_hi = 224,\n\t},\n\t{\t \n\t\t.offset = 0x400,\n\t\t.reg_general = 0x08,\n\t\t.reg_ssp = 0x0c,\n\t\t.reg_cs_ctrl = 0x18,\n\t\t.reg_capabilities = -1,\n\t\t.rx_threshold = 64,\n\t\t.tx_threshold_lo = 160,\n\t\t.tx_threshold_hi = 224,\n\t\t.cs_sel_shift = 2,\n\t\t.cs_sel_mask = 1 << 2,\n\t\t.cs_num = 2,\n\t},\n\t{\t \n\t\t.offset = 0x200,\n\t\t.reg_general = -1,\n\t\t.reg_ssp = 0x20,\n\t\t.reg_cs_ctrl = 0x24,\n\t\t.reg_capabilities = -1,\n\t\t.rx_threshold = 1,\n\t\t.tx_threshold_lo = 32,\n\t\t.tx_threshold_hi = 56,\n\t},\n\t{\t \n\t\t.offset = 0x200,\n\t\t.reg_general = -1,\n\t\t.reg_ssp = 0x20,\n\t\t.reg_cs_ctrl = 0x24,\n\t\t.reg_capabilities = 0xfc,\n\t\t.rx_threshold = 1,\n\t\t.tx_threshold_lo = 16,\n\t\t.tx_threshold_hi = 48,\n\t\t.cs_sel_shift = 8,\n\t\t.cs_sel_mask = 3 << 8,\n\t\t.cs_clk_stays_gated = true,\n\t},\n\t{\t \n\t\t.offset = 0x200,\n\t\t.reg_general = -1,\n\t\t.reg_ssp = 0x20,\n\t\t.reg_cs_ctrl = 0x24,\n\t\t.reg_capabilities = 0xfc,\n\t\t.rx_threshold = 1,\n\t\t.tx_threshold_lo = 32,\n\t\t.tx_threshold_hi = 56,\n\t\t.cs_sel_shift = 8,\n\t\t.cs_sel_mask = 3 << 8,\n\t\t.cs_clk_stays_gated = true,\n\t},\n};\n\nstatic inline const struct lpss_config\n*lpss_get_config(const struct driver_data *drv_data)\n{\n\treturn &lpss_platforms[drv_data->ssp_type - LPSS_LPT_SSP];\n}\n\nstatic bool is_lpss_ssp(const struct driver_data *drv_data)\n{\n\tswitch (drv_data->ssp_type) {\n\tcase LPSS_LPT_SSP:\n\tcase LPSS_BYT_SSP:\n\tcase LPSS_BSW_SSP:\n\tcase LPSS_SPT_SSP:\n\tcase LPSS_BXT_SSP:\n\tcase LPSS_CNL_SSP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_quark_x1000_ssp(const struct driver_data *drv_data)\n{\n\treturn drv_data->ssp_type == QUARK_X1000_SSP;\n}\n\nstatic bool is_mmp2_ssp(const struct driver_data *drv_data)\n{\n\treturn drv_data->ssp_type == MMP2_SSP;\n}\n\nstatic bool is_mrfld_ssp(const struct driver_data *drv_data)\n{\n\treturn drv_data->ssp_type == MRFLD_SSP;\n}\n\nstatic void pxa2xx_spi_update(const struct driver_data *drv_data, u32 reg, u32 mask, u32 value)\n{\n\tif ((pxa2xx_spi_read(drv_data, reg) & mask) != value)\n\t\tpxa2xx_spi_write(drv_data, reg, value & mask);\n}\n\nstatic u32 pxa2xx_spi_get_ssrc1_change_mask(const struct driver_data *drv_data)\n{\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\treturn QUARK_X1000_SSCR1_CHANGE_MASK;\n\tcase CE4100_SSP:\n\t\treturn CE4100_SSCR1_CHANGE_MASK;\n\tdefault:\n\t\treturn SSCR1_CHANGE_MASK;\n\t}\n}\n\nstatic u32\npxa2xx_spi_get_rx_default_thre(const struct driver_data *drv_data)\n{\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\treturn RX_THRESH_QUARK_X1000_DFLT;\n\tcase CE4100_SSP:\n\t\treturn RX_THRESH_CE4100_DFLT;\n\tdefault:\n\t\treturn RX_THRESH_DFLT;\n\t}\n}\n\nstatic bool pxa2xx_spi_txfifo_full(const struct driver_data *drv_data)\n{\n\tu32 mask;\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\tmask = QUARK_X1000_SSSR_TFL_MASK;\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\tmask = CE4100_SSSR_TFL_MASK;\n\t\tbreak;\n\tdefault:\n\t\tmask = SSSR_TFL_MASK;\n\t\tbreak;\n\t}\n\n\treturn read_SSSR_bits(drv_data, mask) == mask;\n}\n\nstatic void pxa2xx_spi_clear_rx_thre(const struct driver_data *drv_data,\n\t\t\t\t     u32 *sccr1_reg)\n{\n\tu32 mask;\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\tmask = QUARK_X1000_SSCR1_RFT;\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\tmask = CE4100_SSCR1_RFT;\n\t\tbreak;\n\tdefault:\n\t\tmask = SSCR1_RFT;\n\t\tbreak;\n\t}\n\t*sccr1_reg &= ~mask;\n}\n\nstatic void pxa2xx_spi_set_rx_thre(const struct driver_data *drv_data,\n\t\t\t\t   u32 *sccr1_reg, u32 threshold)\n{\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\t*sccr1_reg |= QUARK_X1000_SSCR1_RxTresh(threshold);\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\t*sccr1_reg |= CE4100_SSCR1_RxTresh(threshold);\n\t\tbreak;\n\tdefault:\n\t\t*sccr1_reg |= SSCR1_RxTresh(threshold);\n\t\tbreak;\n\t}\n}\n\nstatic u32 pxa2xx_configure_sscr0(const struct driver_data *drv_data,\n\t\t\t\t  u32 clk_div, u8 bits)\n{\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\treturn clk_div\n\t\t\t| QUARK_X1000_SSCR0_Motorola\n\t\t\t| QUARK_X1000_SSCR0_DataSize(bits > 32 ? 8 : bits);\n\tdefault:\n\t\treturn clk_div\n\t\t\t| SSCR0_Motorola\n\t\t\t| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)\n\t\t\t| (bits > 16 ? SSCR0_EDSS : 0);\n\t}\n}\n\n \nstatic u32 __lpss_ssp_read_priv(struct driver_data *drv_data, unsigned offset)\n{\n\tWARN_ON(!drv_data->lpss_base);\n\treturn readl(drv_data->lpss_base + offset);\n}\n\nstatic void __lpss_ssp_write_priv(struct driver_data *drv_data,\n\t\t\t\t  unsigned offset, u32 value)\n{\n\tWARN_ON(!drv_data->lpss_base);\n\twritel(value, drv_data->lpss_base + offset);\n}\n\n \nstatic void lpss_ssp_setup(struct driver_data *drv_data)\n{\n\tconst struct lpss_config *config;\n\tu32 value;\n\n\tconfig = lpss_get_config(drv_data);\n\tdrv_data->lpss_base = drv_data->ssp->mmio_base + config->offset;\n\n\t \n\tvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\n\tvalue &= ~(LPSS_CS_CONTROL_SW_MODE | LPSS_CS_CONTROL_CS_HIGH);\n\tvalue |= LPSS_CS_CONTROL_SW_MODE | LPSS_CS_CONTROL_CS_HIGH;\n\t__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);\n\n\t \n\tif (drv_data->controller_info->enable_dma) {\n\t\t__lpss_ssp_write_priv(drv_data, config->reg_ssp, 1);\n\n\t\tif (config->reg_general >= 0) {\n\t\t\tvalue = __lpss_ssp_read_priv(drv_data,\n\t\t\t\t\t\t     config->reg_general);\n\t\t\tvalue |= LPSS_GENERAL_REG_RXTO_HOLDOFF_DISABLE;\n\t\t\t__lpss_ssp_write_priv(drv_data,\n\t\t\t\t\t      config->reg_general, value);\n\t\t}\n\t}\n}\n\nstatic void lpss_ssp_select_cs(struct spi_device *spi,\n\t\t\t       const struct lpss_config *config)\n{\n\tstruct driver_data *drv_data =\n\t\tspi_controller_get_devdata(spi->controller);\n\tu32 value, cs;\n\n\tif (!config->cs_sel_mask)\n\t\treturn;\n\n\tvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\n\n\tcs = spi_get_chipselect(spi, 0);\n\tcs <<= config->cs_sel_shift;\n\tif (cs != (value & config->cs_sel_mask)) {\n\t\t \n\t\tvalue &= ~config->cs_sel_mask;\n\t\tvalue |= cs;\n\t\t__lpss_ssp_write_priv(drv_data,\n\t\t\t\t      config->reg_cs_ctrl, value);\n\t\tndelay(1000000000 /\n\t\t       (drv_data->controller->max_speed_hz / 2));\n\t}\n}\n\nstatic void lpss_ssp_cs_control(struct spi_device *spi, bool enable)\n{\n\tstruct driver_data *drv_data =\n\t\tspi_controller_get_devdata(spi->controller);\n\tconst struct lpss_config *config;\n\tu32 value;\n\n\tconfig = lpss_get_config(drv_data);\n\n\tif (enable)\n\t\tlpss_ssp_select_cs(spi, config);\n\n\tvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\n\tif (enable)\n\t\tvalue &= ~LPSS_CS_CONTROL_CS_HIGH;\n\telse\n\t\tvalue |= LPSS_CS_CONTROL_CS_HIGH;\n\t__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);\n\tif (config->cs_clk_stays_gated) {\n\t\tu32 clkgate;\n\n\t\t \n\t\tclkgate = __lpss_ssp_read_priv(drv_data, LPSS_PRIV_CLOCK_GATE);\n\t\tvalue = (clkgate & ~LPSS_PRIV_CLOCK_GATE_CLK_CTL_MASK) |\n\t\t\tLPSS_PRIV_CLOCK_GATE_CLK_CTL_FORCE_ON;\n\n\t\t__lpss_ssp_write_priv(drv_data, LPSS_PRIV_CLOCK_GATE, value);\n\t\t__lpss_ssp_write_priv(drv_data, LPSS_PRIV_CLOCK_GATE, clkgate);\n\t}\n}\n\nstatic void cs_assert(struct spi_device *spi)\n{\n\tstruct driver_data *drv_data =\n\t\tspi_controller_get_devdata(spi->controller);\n\n\tif (drv_data->ssp_type == CE4100_SSP) {\n\t\tpxa2xx_spi_write(drv_data, SSSR, spi_get_chipselect(spi, 0));\n\t\treturn;\n\t}\n\n\tif (is_lpss_ssp(drv_data))\n\t\tlpss_ssp_cs_control(spi, true);\n}\n\nstatic void cs_deassert(struct spi_device *spi)\n{\n\tstruct driver_data *drv_data =\n\t\tspi_controller_get_devdata(spi->controller);\n\tunsigned long timeout;\n\n\tif (drv_data->ssp_type == CE4100_SSP)\n\t\treturn;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(10);\n\twhile (pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY &&\n\t       !time_after(jiffies, timeout))\n\t\tcpu_relax();\n\n\tif (is_lpss_ssp(drv_data))\n\t\tlpss_ssp_cs_control(spi, false);\n}\n\nstatic void pxa2xx_spi_set_cs(struct spi_device *spi, bool level)\n{\n\tif (level)\n\t\tcs_deassert(spi);\n\telse\n\t\tcs_assert(spi);\n}\n\nint pxa2xx_spi_flush(struct driver_data *drv_data)\n{\n\tunsigned long limit = loops_per_jiffy << 1;\n\n\tdo {\n\t\twhile (read_SSSR_bits(drv_data, SSSR_RNE))\n\t\t\tpxa2xx_spi_read(drv_data, SSDR);\n\t} while ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY) && --limit);\n\twrite_SSSR_CS(drv_data, SSSR_ROR);\n\n\treturn limit;\n}\n\nstatic void pxa2xx_spi_off(struct driver_data *drv_data)\n{\n\t \n\tif (is_mmp2_ssp(drv_data))\n\t\treturn;\n\n\tpxa_ssp_disable(drv_data->ssp);\n}\n\nstatic int null_writer(struct driver_data *drv_data)\n{\n\tu8 n_bytes = drv_data->n_bytes;\n\n\tif (pxa2xx_spi_txfifo_full(drv_data)\n\t\t|| (drv_data->tx == drv_data->tx_end))\n\t\treturn 0;\n\n\tpxa2xx_spi_write(drv_data, SSDR, 0);\n\tdrv_data->tx += n_bytes;\n\n\treturn 1;\n}\n\nstatic int null_reader(struct driver_data *drv_data)\n{\n\tu8 n_bytes = drv_data->n_bytes;\n\n\twhile (read_SSSR_bits(drv_data, SSSR_RNE) && drv_data->rx < drv_data->rx_end) {\n\t\tpxa2xx_spi_read(drv_data, SSDR);\n\t\tdrv_data->rx += n_bytes;\n\t}\n\n\treturn drv_data->rx == drv_data->rx_end;\n}\n\nstatic int u8_writer(struct driver_data *drv_data)\n{\n\tif (pxa2xx_spi_txfifo_full(drv_data)\n\t\t|| (drv_data->tx == drv_data->tx_end))\n\t\treturn 0;\n\n\tpxa2xx_spi_write(drv_data, SSDR, *(u8 *)(drv_data->tx));\n\t++drv_data->tx;\n\n\treturn 1;\n}\n\nstatic int u8_reader(struct driver_data *drv_data)\n{\n\twhile (read_SSSR_bits(drv_data, SSSR_RNE) && drv_data->rx < drv_data->rx_end) {\n\t\t*(u8 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\n\t\t++drv_data->rx;\n\t}\n\n\treturn drv_data->rx == drv_data->rx_end;\n}\n\nstatic int u16_writer(struct driver_data *drv_data)\n{\n\tif (pxa2xx_spi_txfifo_full(drv_data)\n\t\t|| (drv_data->tx == drv_data->tx_end))\n\t\treturn 0;\n\n\tpxa2xx_spi_write(drv_data, SSDR, *(u16 *)(drv_data->tx));\n\tdrv_data->tx += 2;\n\n\treturn 1;\n}\n\nstatic int u16_reader(struct driver_data *drv_data)\n{\n\twhile (read_SSSR_bits(drv_data, SSSR_RNE) && drv_data->rx < drv_data->rx_end) {\n\t\t*(u16 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\n\t\tdrv_data->rx += 2;\n\t}\n\n\treturn drv_data->rx == drv_data->rx_end;\n}\n\nstatic int u32_writer(struct driver_data *drv_data)\n{\n\tif (pxa2xx_spi_txfifo_full(drv_data)\n\t\t|| (drv_data->tx == drv_data->tx_end))\n\t\treturn 0;\n\n\tpxa2xx_spi_write(drv_data, SSDR, *(u32 *)(drv_data->tx));\n\tdrv_data->tx += 4;\n\n\treturn 1;\n}\n\nstatic int u32_reader(struct driver_data *drv_data)\n{\n\twhile (read_SSSR_bits(drv_data, SSSR_RNE) && drv_data->rx < drv_data->rx_end) {\n\t\t*(u32 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\n\t\tdrv_data->rx += 4;\n\t}\n\n\treturn drv_data->rx == drv_data->rx_end;\n}\n\nstatic void reset_sccr1(struct driver_data *drv_data)\n{\n\tu32 mask = drv_data->int_cr1 | drv_data->dma_cr1, threshold;\n\tstruct chip_data *chip;\n\n\tif (drv_data->controller->cur_msg) {\n\t\tchip = spi_get_ctldata(drv_data->controller->cur_msg->spi);\n\t\tthreshold = chip->threshold;\n\t} else {\n\t\tthreshold = 0;\n\t}\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\tmask |= QUARK_X1000_SSCR1_RFT;\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\tmask |= CE4100_SSCR1_RFT;\n\t\tbreak;\n\tdefault:\n\t\tmask |= SSCR1_RFT;\n\t\tbreak;\n\t}\n\n\tpxa2xx_spi_update(drv_data, SSCR1, mask, threshold);\n}\n\nstatic void int_stop_and_reset(struct driver_data *drv_data)\n{\n\t \n\twrite_SSSR_CS(drv_data, drv_data->clear_sr);\n\treset_sccr1(drv_data);\n\tif (pxa25x_ssp_comp(drv_data))\n\t\treturn;\n\n\tpxa2xx_spi_write(drv_data, SSTO, 0);\n}\n\nstatic void int_error_stop(struct driver_data *drv_data, const char *msg, int err)\n{\n\tint_stop_and_reset(drv_data);\n\tpxa2xx_spi_flush(drv_data);\n\tpxa2xx_spi_off(drv_data);\n\n\tdev_err(drv_data->ssp->dev, \"%s\\n\", msg);\n\n\tdrv_data->controller->cur_msg->status = err;\n\tspi_finalize_current_transfer(drv_data->controller);\n}\n\nstatic void int_transfer_complete(struct driver_data *drv_data)\n{\n\tint_stop_and_reset(drv_data);\n\n\tspi_finalize_current_transfer(drv_data->controller);\n}\n\nstatic irqreturn_t interrupt_transfer(struct driver_data *drv_data)\n{\n\tu32 irq_status;\n\n\tirq_status = read_SSSR_bits(drv_data, drv_data->mask_sr);\n\tif (!(pxa2xx_spi_read(drv_data, SSCR1) & SSCR1_TIE))\n\t\tirq_status &= ~SSSR_TFS;\n\n\tif (irq_status & SSSR_ROR) {\n\t\tint_error_stop(drv_data, \"interrupt_transfer: FIFO overrun\", -EIO);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (irq_status & SSSR_TUR) {\n\t\tint_error_stop(drv_data, \"interrupt_transfer: FIFO underrun\", -EIO);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (irq_status & SSSR_TINT) {\n\t\tpxa2xx_spi_write(drv_data, SSSR, SSSR_TINT);\n\t\tif (drv_data->read(drv_data)) {\n\t\t\tint_transfer_complete(drv_data);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tdo {\n\t\tif (drv_data->read(drv_data)) {\n\t\t\tint_transfer_complete(drv_data);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t} while (drv_data->write(drv_data));\n\n\tif (drv_data->read(drv_data)) {\n\t\tint_transfer_complete(drv_data);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (drv_data->tx == drv_data->tx_end) {\n\t\tu32 bytes_left;\n\t\tu32 sccr1_reg;\n\n\t\tsccr1_reg = pxa2xx_spi_read(drv_data, SSCR1);\n\t\tsccr1_reg &= ~SSCR1_TIE;\n\n\t\t \n\t\tif (pxa25x_ssp_comp(drv_data)) {\n\t\t\tu32 rx_thre;\n\n\t\t\tpxa2xx_spi_clear_rx_thre(drv_data, &sccr1_reg);\n\n\t\t\tbytes_left = drv_data->rx_end - drv_data->rx;\n\t\t\tswitch (drv_data->n_bytes) {\n\t\t\tcase 4:\n\t\t\t\tbytes_left >>= 2;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbytes_left >>= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trx_thre = pxa2xx_spi_get_rx_default_thre(drv_data);\n\t\t\tif (rx_thre > bytes_left)\n\t\t\t\trx_thre = bytes_left;\n\n\t\t\tpxa2xx_spi_set_rx_thre(drv_data, &sccr1_reg, rx_thre);\n\t\t}\n\t\tpxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);\n\t}\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic void handle_bad_msg(struct driver_data *drv_data)\n{\n\tint_stop_and_reset(drv_data);\n\tpxa2xx_spi_off(drv_data);\n\n\tdev_err(drv_data->ssp->dev, \"bad message state in interrupt handler\\n\");\n}\n\nstatic irqreturn_t ssp_int(int irq, void *dev_id)\n{\n\tstruct driver_data *drv_data = dev_id;\n\tu32 sccr1_reg;\n\tu32 mask = drv_data->mask_sr;\n\tu32 status;\n\n\t \n\tif (pm_runtime_suspended(drv_data->ssp->dev))\n\t\treturn IRQ_NONE;\n\n\t \n\tstatus = pxa2xx_spi_read(drv_data, SSSR);\n\tif (status == ~0)\n\t\treturn IRQ_NONE;\n\n\tsccr1_reg = pxa2xx_spi_read(drv_data, SSCR1);\n\n\t \n\tif (!(sccr1_reg & SSCR1_TIE))\n\t\tmask &= ~SSSR_TFS;\n\n\t \n\tif (!(sccr1_reg & SSCR1_TINTE))\n\t\tmask &= ~SSSR_TINT;\n\n\tif (!(status & mask))\n\t\treturn IRQ_NONE;\n\n\tpxa2xx_spi_write(drv_data, SSCR1, sccr1_reg & ~drv_data->int_cr1);\n\tpxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);\n\n\tif (!drv_data->controller->cur_msg) {\n\t\thandle_bad_msg(drv_data);\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn drv_data->transfer_handler(drv_data);\n}\n\n \nstatic unsigned int quark_x1000_get_clk_div(int rate, u32 *dds)\n{\n\tunsigned long xtal = 200000000;\n\tunsigned long fref = xtal / 2;\t\t \n\t\t\t\t\t\t \n\tunsigned long fref1 = fref / 2;\t\t \n\tunsigned long fref2 = fref * 2 / 5;\t \n\tunsigned long scale;\n\tunsigned long q, q1, q2;\n\tlong r, r1, r2;\n\tu32 mul;\n\n\t \n\n\t \n\tmul = (1 << 24) >> 1;\n\n\t \n\tq1 = DIV_ROUND_UP(fref1, rate);\n\n\t \n\tif (q1 > 256) {\n\t\t \n\t\tscale = fls_long(q1 - 1);\n\t\tif (scale > 9) {\n\t\t\tq1 >>= scale - 9;\n\t\t\tmul >>= scale - 9;\n\t\t}\n\n\t\t \n\t\tq1 += q1 & 1;\n\t}\n\n\t \n\tscale = __ffs(q1);\n\tq1 >>= scale;\n\tmul >>= scale;\n\n\t \n\tr1 = abs(fref1 / (1 << (24 - fls_long(mul))) / q1 - rate);\n\n\t \n\n\tq2 = DIV_ROUND_UP(fref2, rate);\n\tr2 = abs(fref2 / q2 - rate);\n\n\t \n\tif (r2 >= r1 || q2 > 256) {\n\t\t \n\t\tr = r1;\n\t\tq = q1;\n\t} else {\n\t\t \n\t\tr = r2;\n\t\tq = q2;\n\t\tmul = (1 << 24) * 2 / 5;\n\t}\n\n\t \n\tif (fref / rate >= 80) {\n\t\tu64 fssp;\n\t\tu32 m;\n\n\t\t \n\t\tq1 = DIV_ROUND_UP(fref, rate);\n\t\tm = (1 << 24) / q1;\n\n\t\t \n\t\tfssp = (u64)fref * m;\n\t\tdo_div(fssp, 1 << 24);\n\t\tr1 = abs(fssp - rate);\n\n\t\t \n\t\tif (r1 < r) {\n\t\t\t \n\t\t\tq = 1;\n\t\t\tmul = m;\n\t\t}\n\t}\n\n\t*dds = mul;\n\treturn q - 1;\n}\n\nstatic unsigned int ssp_get_clk_div(struct driver_data *drv_data, int rate)\n{\n\tunsigned long ssp_clk = drv_data->controller->max_speed_hz;\n\tconst struct ssp_device *ssp = drv_data->ssp;\n\n\trate = min_t(int, ssp_clk, rate);\n\n\t \n\tif (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)\n\t\treturn (DIV_ROUND_UP(ssp_clk, 2 * rate) - 1) & 0xff;\n\telse\n\t\treturn (DIV_ROUND_UP(ssp_clk, rate) - 1)  & 0xfff;\n}\n\nstatic unsigned int pxa2xx_ssp_get_clk_div(struct driver_data *drv_data,\n\t\t\t\t\t   int rate)\n{\n\tstruct chip_data *chip =\n\t\tspi_get_ctldata(drv_data->controller->cur_msg->spi);\n\tunsigned int clk_div;\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\tclk_div = quark_x1000_get_clk_div(rate, &chip->dds_rate);\n\t\tbreak;\n\tdefault:\n\t\tclk_div = ssp_get_clk_div(drv_data, rate);\n\t\tbreak;\n\t}\n\treturn clk_div << 8;\n}\n\nstatic bool pxa2xx_spi_can_dma(struct spi_controller *controller,\n\t\t\t       struct spi_device *spi,\n\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct chip_data *chip = spi_get_ctldata(spi);\n\n\treturn chip->enable_dma &&\n\t       xfer->len <= MAX_DMA_LEN &&\n\t       xfer->len >= chip->dma_burst_size;\n}\n\nstatic int pxa2xx_spi_transfer_one(struct spi_controller *controller,\n\t\t\t\t   struct spi_device *spi,\n\t\t\t\t   struct spi_transfer *transfer)\n{\n\tstruct driver_data *drv_data = spi_controller_get_devdata(controller);\n\tstruct spi_message *message = controller->cur_msg;\n\tstruct chip_data *chip = spi_get_ctldata(spi);\n\tu32 dma_thresh = chip->dma_threshold;\n\tu32 dma_burst = chip->dma_burst_size;\n\tu32 change_mask = pxa2xx_spi_get_ssrc1_change_mask(drv_data);\n\tu32 clk_div;\n\tu8 bits;\n\tu32 speed;\n\tu32 cr0;\n\tu32 cr1;\n\tint err;\n\tint dma_mapped;\n\n\t \n\tif (transfer->len > MAX_DMA_LEN && chip->enable_dma) {\n\n\t\t \n\t\tif (message->is_dma_mapped\n\t\t\t\t|| transfer->rx_dma || transfer->tx_dma) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Mapped transfer length of %u is greater than %d\\n\",\n\t\t\t\ttransfer->len, MAX_DMA_LEN);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tdev_warn_ratelimited(&spi->dev,\n\t\t\t\t     \"DMA disabled for transfer length %u greater than %d\\n\",\n\t\t\t\t     transfer->len, MAX_DMA_LEN);\n\t}\n\n\t \n\tif (pxa2xx_spi_flush(drv_data) == 0) {\n\t\tdev_err(&spi->dev, \"Flush failed\\n\");\n\t\treturn -EIO;\n\t}\n\tdrv_data->tx = (void *)transfer->tx_buf;\n\tdrv_data->tx_end = drv_data->tx + transfer->len;\n\tdrv_data->rx = transfer->rx_buf;\n\tdrv_data->rx_end = drv_data->rx + transfer->len;\n\n\t \n\tbits = transfer->bits_per_word;\n\tspeed = transfer->speed_hz;\n\n\tclk_div = pxa2xx_ssp_get_clk_div(drv_data, speed);\n\n\tif (bits <= 8) {\n\t\tdrv_data->n_bytes = 1;\n\t\tdrv_data->read = drv_data->rx ? u8_reader : null_reader;\n\t\tdrv_data->write = drv_data->tx ? u8_writer : null_writer;\n\t} else if (bits <= 16) {\n\t\tdrv_data->n_bytes = 2;\n\t\tdrv_data->read = drv_data->rx ? u16_reader : null_reader;\n\t\tdrv_data->write = drv_data->tx ? u16_writer : null_writer;\n\t} else if (bits <= 32) {\n\t\tdrv_data->n_bytes = 4;\n\t\tdrv_data->read = drv_data->rx ? u32_reader : null_reader;\n\t\tdrv_data->write = drv_data->tx ? u32_writer : null_writer;\n\t}\n\t \n\tif (chip->enable_dma) {\n\t\tif (pxa2xx_spi_set_dma_burst_and_threshold(chip,\n\t\t\t\t\t\tspi,\n\t\t\t\t\t\tbits, &dma_burst,\n\t\t\t\t\t\t&dma_thresh))\n\t\t\tdev_warn_ratelimited(&spi->dev,\n\t\t\t\t\t     \"DMA burst size reduced to match bits_per_word\\n\");\n\t}\n\n\tdma_mapped = controller->can_dma &&\n\t\t     controller->can_dma(controller, spi, transfer) &&\n\t\t     controller->cur_msg_mapped;\n\tif (dma_mapped) {\n\n\t\t \n\t\tdrv_data->transfer_handler = pxa2xx_spi_dma_transfer;\n\n\t\terr = pxa2xx_spi_dma_prepare(drv_data, transfer);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tcr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;\n\t\tpxa2xx_spi_write(drv_data, SSSR, drv_data->clear_sr);\n\n\t\tpxa2xx_spi_dma_start(drv_data);\n\t} else {\n\t\t \n\t\tdrv_data->transfer_handler = interrupt_transfer;\n\n\t\t \n\t\tcr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;\n\t\twrite_SSSR_CS(drv_data, drv_data->clear_sr);\n\t}\n\n\t \n\tcr0 = pxa2xx_configure_sscr0(drv_data, clk_div, bits);\n\tif (!pxa25x_ssp_comp(drv_data))\n\t\tdev_dbg(&spi->dev, \"%u Hz actual, %s\\n\",\n\t\t\tcontroller->max_speed_hz\n\t\t\t\t/ (1 + ((cr0 & SSCR0_SCR(0xfff)) >> 8)),\n\t\t\tdma_mapped ? \"DMA\" : \"PIO\");\n\telse\n\t\tdev_dbg(&spi->dev, \"%u Hz actual, %s\\n\",\n\t\t\tcontroller->max_speed_hz / 2\n\t\t\t\t/ (1 + ((cr0 & SSCR0_SCR(0x0ff)) >> 8)),\n\t\t\tdma_mapped ? \"DMA\" : \"PIO\");\n\n\tif (is_lpss_ssp(drv_data)) {\n\t\tpxa2xx_spi_update(drv_data, SSIRF, GENMASK(7, 0), chip->lpss_rx_threshold);\n\t\tpxa2xx_spi_update(drv_data, SSITF, GENMASK(15, 0), chip->lpss_tx_threshold);\n\t}\n\n\tif (is_mrfld_ssp(drv_data)) {\n\t\tu32 mask = SFIFOTT_RFT | SFIFOTT_TFT;\n\t\tu32 thresh = 0;\n\n\t\tthresh |= SFIFOTT_RxThresh(chip->lpss_rx_threshold);\n\t\tthresh |= SFIFOTT_TxThresh(chip->lpss_tx_threshold);\n\n\t\tpxa2xx_spi_update(drv_data, SFIFOTT, mask, thresh);\n\t}\n\n\tif (is_quark_x1000_ssp(drv_data))\n\t\tpxa2xx_spi_update(drv_data, DDS_RATE, GENMASK(23, 0), chip->dds_rate);\n\n\t \n\tif (!is_mmp2_ssp(drv_data))\n\t\tpxa_ssp_disable(drv_data->ssp);\n\n\tif (!pxa25x_ssp_comp(drv_data))\n\t\tpxa2xx_spi_write(drv_data, SSTO, chip->timeout);\n\n\t \n\tpxa2xx_spi_update(drv_data, SSCR1, change_mask, cr1);\n\n\t \n\tpxa2xx_spi_update(drv_data, SSCR0, GENMASK(31, 0), cr0);\n\n\t \n\tpxa_ssp_enable(drv_data->ssp);\n\n\tif (is_mmp2_ssp(drv_data)) {\n\t\tu8 tx_level = read_SSSR_bits(drv_data, SSSR_TFL_MASK) >> 8;\n\n\t\tif (tx_level) {\n\t\t\t \n\t\t\tdev_warn(&spi->dev, \"%u bytes of garbage in Tx FIFO!\\n\", tx_level);\n\t\t\tif (tx_level > transfer->len)\n\t\t\t\ttx_level = transfer->len;\n\t\t\tdrv_data->tx += tx_level;\n\t\t}\n\t}\n\n\tif (spi_controller_is_target(controller)) {\n\t\twhile (drv_data->write(drv_data))\n\t\t\t;\n\t\tif (drv_data->gpiod_ready) {\n\t\t\tgpiod_set_value(drv_data->gpiod_ready, 1);\n\t\t\tudelay(1);\n\t\t\tgpiod_set_value(drv_data->gpiod_ready, 0);\n\t\t}\n\t}\n\n\t \n\tpxa2xx_spi_write(drv_data, SSCR1, cr1);\n\n\treturn 1;\n}\n\nstatic int pxa2xx_spi_target_abort(struct spi_controller *controller)\n{\n\tstruct driver_data *drv_data = spi_controller_get_devdata(controller);\n\n\tint_error_stop(drv_data, \"transfer aborted\", -EINTR);\n\n\treturn 0;\n}\n\nstatic void pxa2xx_spi_handle_err(struct spi_controller *controller,\n\t\t\t\t struct spi_message *msg)\n{\n\tstruct driver_data *drv_data = spi_controller_get_devdata(controller);\n\n\tint_stop_and_reset(drv_data);\n\n\t \n\tpxa2xx_spi_off(drv_data);\n\n\t \n\tif (atomic_read(&drv_data->dma_running))\n\t\tpxa2xx_spi_dma_stop(drv_data);\n}\n\nstatic int pxa2xx_spi_unprepare_transfer(struct spi_controller *controller)\n{\n\tstruct driver_data *drv_data = spi_controller_get_devdata(controller);\n\n\t \n\tpxa2xx_spi_off(drv_data);\n\n\treturn 0;\n}\n\nstatic int setup(struct spi_device *spi)\n{\n\tstruct pxa2xx_spi_chip *chip_info;\n\tstruct chip_data *chip;\n\tconst struct lpss_config *config;\n\tstruct driver_data *drv_data =\n\t\tspi_controller_get_devdata(spi->controller);\n\tuint tx_thres, tx_hi_thres, rx_thres;\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\ttx_thres = TX_THRESH_QUARK_X1000_DFLT;\n\t\ttx_hi_thres = 0;\n\t\trx_thres = RX_THRESH_QUARK_X1000_DFLT;\n\t\tbreak;\n\tcase MRFLD_SSP:\n\t\ttx_thres = TX_THRESH_MRFLD_DFLT;\n\t\ttx_hi_thres = 0;\n\t\trx_thres = RX_THRESH_MRFLD_DFLT;\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\ttx_thres = TX_THRESH_CE4100_DFLT;\n\t\ttx_hi_thres = 0;\n\t\trx_thres = RX_THRESH_CE4100_DFLT;\n\t\tbreak;\n\tcase LPSS_LPT_SSP:\n\tcase LPSS_BYT_SSP:\n\tcase LPSS_BSW_SSP:\n\tcase LPSS_SPT_SSP:\n\tcase LPSS_BXT_SSP:\n\tcase LPSS_CNL_SSP:\n\t\tconfig = lpss_get_config(drv_data);\n\t\ttx_thres = config->tx_threshold_lo;\n\t\ttx_hi_thres = config->tx_threshold_hi;\n\t\trx_thres = config->rx_threshold;\n\t\tbreak;\n\tdefault:\n\t\ttx_hi_thres = 0;\n\t\tif (spi_controller_is_target(drv_data->controller)) {\n\t\t\ttx_thres = 1;\n\t\t\trx_thres = 2;\n\t\t} else {\n\t\t\ttx_thres = TX_THRESH_DFLT;\n\t\t\trx_thres = RX_THRESH_DFLT;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tchip = spi_get_ctldata(spi);\n\tif (!chip) {\n\t\tchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\n\t\tif (drv_data->ssp_type == CE4100_SSP) {\n\t\t\tif (spi_get_chipselect(spi, 0) > 4) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"failed setup: cs number must not be > 4.\\n\");\n\t\t\t\tkfree(chip);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tchip->enable_dma = drv_data->controller_info->enable_dma;\n\t\tchip->timeout = TIMOUT_DFLT;\n\t}\n\n\t \n\tchip_info = spi->controller_data;\n\n\t \n\tif (chip_info) {\n\t\tif (chip_info->timeout)\n\t\t\tchip->timeout = chip_info->timeout;\n\t\tif (chip_info->tx_threshold)\n\t\t\ttx_thres = chip_info->tx_threshold;\n\t\tif (chip_info->tx_hi_threshold)\n\t\t\ttx_hi_thres = chip_info->tx_hi_threshold;\n\t\tif (chip_info->rx_threshold)\n\t\t\trx_thres = chip_info->rx_threshold;\n\t\tchip->dma_threshold = 0;\n\t}\n\n\tchip->cr1 = 0;\n\tif (spi_controller_is_target(drv_data->controller)) {\n\t\tchip->cr1 |= SSCR1_SCFR;\n\t\tchip->cr1 |= SSCR1_SCLKDIR;\n\t\tchip->cr1 |= SSCR1_SFRMDIR;\n\t\tchip->cr1 |= SSCR1_SPH;\n\t}\n\n\tif (is_lpss_ssp(drv_data)) {\n\t\tchip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);\n\t\tchip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres) |\n\t\t\t\t\t  SSITF_TxHiThresh(tx_hi_thres);\n\t}\n\n\tif (is_mrfld_ssp(drv_data)) {\n\t\tchip->lpss_rx_threshold = rx_thres;\n\t\tchip->lpss_tx_threshold = tx_thres;\n\t}\n\n\t \n\tif (chip->enable_dma) {\n\t\t \n\t\tif (pxa2xx_spi_set_dma_burst_and_threshold(chip, spi,\n\t\t\t\t\t\tspi->bits_per_word,\n\t\t\t\t\t\t&chip->dma_burst_size,\n\t\t\t\t\t\t&chip->dma_threshold)) {\n\t\t\tdev_warn(&spi->dev,\n\t\t\t\t \"in setup: DMA burst size reduced to match bits_per_word\\n\");\n\t\t}\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"in setup: DMA burst size set to %u\\n\",\n\t\t\tchip->dma_burst_size);\n\t}\n\n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\tchip->threshold = (QUARK_X1000_SSCR1_RxTresh(rx_thres)\n\t\t\t\t   & QUARK_X1000_SSCR1_RFT)\n\t\t\t\t   | (QUARK_X1000_SSCR1_TxTresh(tx_thres)\n\t\t\t\t   & QUARK_X1000_SSCR1_TFT);\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\tchip->threshold = (CE4100_SSCR1_RxTresh(rx_thres) & CE4100_SSCR1_RFT) |\n\t\t\t(CE4100_SSCR1_TxTresh(tx_thres) & CE4100_SSCR1_TFT);\n\t\tbreak;\n\tdefault:\n\t\tchip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |\n\t\t\t(SSCR1_TxTresh(tx_thres) & SSCR1_TFT);\n\t\tbreak;\n\t}\n\n\tchip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);\n\tchip->cr1 |= ((spi->mode & SPI_CPHA) ? SSCR1_SPH : 0) |\n\t\t     ((spi->mode & SPI_CPOL) ? SSCR1_SPO : 0);\n\n\tif (spi->mode & SPI_LOOP)\n\t\tchip->cr1 |= SSCR1_LBM;\n\n\tspi_set_ctldata(spi, chip);\n\n\treturn 0;\n}\n\nstatic void cleanup(struct spi_device *spi)\n{\n\tstruct chip_data *chip = spi_get_ctldata(spi);\n\n\tkfree(chip);\n}\n\nstatic bool pxa2xx_spi_idma_filter(struct dma_chan *chan, void *param)\n{\n\treturn param == chan->device->dev;\n}\n\nstatic struct pxa2xx_spi_controller *\npxa2xx_spi_init_pdata(struct platform_device *pdev)\n{\n\tstruct pxa2xx_spi_controller *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\tstruct ssp_device *ssp;\n\tstruct resource *res;\n\tenum pxa_ssp_type type = SSP_UNDEFINED;\n\tconst void *match;\n\tbool is_lpss_priv;\n\tint status;\n\tu64 uid;\n\n\tis_lpss_priv = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"lpss_priv\");\n\n\tmatch = device_get_match_data(dev);\n\tif (match)\n\t\ttype = (uintptr_t)match;\n\telse if (is_lpss_priv) {\n\t\tu32 value;\n\n\t\tstatus = device_property_read_u32(dev, \"intel,spi-pxa2xx-type\", &value);\n\t\tif (status)\n\t\t\treturn ERR_PTR(status);\n\n\t\ttype = (enum pxa_ssp_type)value;\n\t}\n\n\t \n\tif (!(type > SSP_UNDEFINED && type < SSP_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tssp = &pdata->ssp;\n\n\tssp->mmio_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ssp->mmio_base))\n\t\treturn ERR_CAST(ssp->mmio_base);\n\n\tssp->phys_base = res->start;\n\n\t \n\tif (is_lpss_priv) {\n\t\tpdata->tx_param = parent;\n\t\tpdata->rx_param = parent;\n\t\tpdata->dma_filter = pxa2xx_spi_idma_filter;\n\t}\n\n\tssp->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ssp->clk))\n\t\treturn ERR_CAST(ssp->clk);\n\n\tssp->irq = platform_get_irq(pdev, 0);\n\tif (ssp->irq < 0)\n\t\treturn ERR_PTR(ssp->irq);\n\n\tssp->type = type;\n\tssp->dev = dev;\n\n\tstatus = acpi_dev_uid_to_integer(ACPI_COMPANION(dev), &uid);\n\tif (status)\n\t\tssp->port_id = -1;\n\telse\n\t\tssp->port_id = uid;\n\n\tpdata->is_target = device_property_read_bool(dev, \"spi-slave\");\n\tpdata->num_chipselect = 1;\n\tpdata->enable_dma = true;\n\tpdata->dma_burst_size = 1;\n\n\treturn pdata;\n}\n\nstatic int pxa2xx_spi_fw_translate_cs(struct spi_controller *controller,\n\t\t\t\t      unsigned int cs)\n{\n\tstruct driver_data *drv_data = spi_controller_get_devdata(controller);\n\n\tif (has_acpi_companion(drv_data->ssp->dev)) {\n\t\tswitch (drv_data->ssp_type) {\n\t\t \n\t\tcase LPSS_BYT_SSP:\n\t\tcase LPSS_BSW_SSP:\n\t\t\treturn cs - 1;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cs;\n}\n\nstatic size_t pxa2xx_spi_max_dma_transfer_size(struct spi_device *spi)\n{\n\treturn MAX_DMA_LEN;\n}\n\nstatic int pxa2xx_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pxa2xx_spi_controller *platform_info;\n\tstruct spi_controller *controller;\n\tstruct driver_data *drv_data;\n\tstruct ssp_device *ssp;\n\tconst struct lpss_config *config;\n\tint status;\n\tu32 tmp;\n\n\tplatform_info = dev_get_platdata(dev);\n\tif (!platform_info) {\n\t\tplatform_info = pxa2xx_spi_init_pdata(pdev);\n\t\tif (IS_ERR(platform_info)) {\n\t\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\t\treturn PTR_ERR(platform_info);\n\t\t}\n\t}\n\n\tssp = pxa_ssp_request(pdev->id, pdev->name);\n\tif (!ssp)\n\t\tssp = &platform_info->ssp;\n\n\tif (!ssp->mmio_base) {\n\t\tdev_err(&pdev->dev, \"failed to get SSP\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (platform_info->is_target)\n\t\tcontroller = devm_spi_alloc_target(dev, sizeof(*drv_data));\n\telse\n\t\tcontroller = devm_spi_alloc_host(dev, sizeof(*drv_data));\n\n\tif (!controller) {\n\t\tdev_err(&pdev->dev, \"cannot alloc spi_controller\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto out_error_controller_alloc;\n\t}\n\tdrv_data = spi_controller_get_devdata(controller);\n\tdrv_data->controller = controller;\n\tdrv_data->controller_info = platform_info;\n\tdrv_data->ssp = ssp;\n\n\tdevice_set_node(&controller->dev, dev_fwnode(dev));\n\n\t \n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\n\n\tcontroller->bus_num = ssp->port_id;\n\tcontroller->dma_alignment = DMA_ALIGNMENT;\n\tcontroller->cleanup = cleanup;\n\tcontroller->setup = setup;\n\tcontroller->set_cs = pxa2xx_spi_set_cs;\n\tcontroller->transfer_one = pxa2xx_spi_transfer_one;\n\tcontroller->target_abort = pxa2xx_spi_target_abort;\n\tcontroller->handle_err = pxa2xx_spi_handle_err;\n\tcontroller->unprepare_transfer_hardware = pxa2xx_spi_unprepare_transfer;\n\tcontroller->fw_translate_cs = pxa2xx_spi_fw_translate_cs;\n\tcontroller->auto_runtime_pm = true;\n\tcontroller->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\n\tdrv_data->ssp_type = ssp->type;\n\n\tif (pxa25x_ssp_comp(drv_data)) {\n\t\tswitch (drv_data->ssp_type) {\n\t\tcase QUARK_X1000_SSP:\n\t\t\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE;\n\t\tdrv_data->dma_cr1 = 0;\n\t\tdrv_data->clear_sr = SSSR_ROR;\n\t\tdrv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;\n\t} else {\n\t\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\t\tdrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;\n\t\tdrv_data->dma_cr1 = DEFAULT_DMA_CR1;\n\t\tdrv_data->clear_sr = SSSR_ROR | SSSR_TINT;\n\t\tdrv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS\n\t\t\t\t\t\t| SSSR_ROR | SSSR_TUR;\n\t}\n\n\tstatus = request_irq(ssp->irq, ssp_int, IRQF_SHARED, dev_name(dev),\n\t\t\tdrv_data);\n\tif (status < 0) {\n\t\tdev_err(&pdev->dev, \"cannot get IRQ %d\\n\", ssp->irq);\n\t\tgoto out_error_controller_alloc;\n\t}\n\n\t \n\tif (platform_info->enable_dma) {\n\t\tstatus = pxa2xx_spi_dma_setup(drv_data);\n\t\tif (status) {\n\t\t\tdev_warn(dev, \"no DMA channels available, using PIO\\n\");\n\t\t\tplatform_info->enable_dma = false;\n\t\t} else {\n\t\t\tcontroller->can_dma = pxa2xx_spi_can_dma;\n\t\t\tcontroller->max_dma_len = MAX_DMA_LEN;\n\t\t\tcontroller->max_transfer_size =\n\t\t\t\tpxa2xx_spi_max_dma_transfer_size;\n\t\t}\n\t}\n\n\t \n\tstatus = clk_prepare_enable(ssp->clk);\n\tif (status)\n\t\tgoto out_error_dma_irq_alloc;\n\n\tcontroller->max_speed_hz = clk_get_rate(ssp->clk);\n\t \n\tif (!pxa25x_ssp_comp(drv_data))\n\t\tcontroller->min_speed_hz =\n\t\t\tDIV_ROUND_UP(controller->max_speed_hz, 4096);\n\telse if (!is_quark_x1000_ssp(drv_data))\n\t\tcontroller->min_speed_hz =\n\t\t\tDIV_ROUND_UP(controller->max_speed_hz, 512);\n\n\tpxa_ssp_disable(ssp);\n\n\t \n\tswitch (drv_data->ssp_type) {\n\tcase QUARK_X1000_SSP:\n\t\ttmp = QUARK_X1000_SSCR1_RxTresh(RX_THRESH_QUARK_X1000_DFLT) |\n\t\t      QUARK_X1000_SSCR1_TxTresh(TX_THRESH_QUARK_X1000_DFLT);\n\t\tpxa2xx_spi_write(drv_data, SSCR1, tmp);\n\n\t\t \n\t\ttmp = QUARK_X1000_SSCR0_Motorola | QUARK_X1000_SSCR0_DataSize(8);\n\t\tpxa2xx_spi_write(drv_data, SSCR0, tmp);\n\t\tbreak;\n\tcase CE4100_SSP:\n\t\ttmp = CE4100_SSCR1_RxTresh(RX_THRESH_CE4100_DFLT) |\n\t\t      CE4100_SSCR1_TxTresh(TX_THRESH_CE4100_DFLT);\n\t\tpxa2xx_spi_write(drv_data, SSCR1, tmp);\n\t\ttmp = SSCR0_SCR(2) | SSCR0_Motorola | SSCR0_DataSize(8);\n\t\tpxa2xx_spi_write(drv_data, SSCR0, tmp);\n\t\tbreak;\n\tdefault:\n\n\t\tif (spi_controller_is_target(controller)) {\n\t\t\ttmp = SSCR1_SCFR |\n\t\t\t      SSCR1_SCLKDIR |\n\t\t\t      SSCR1_SFRMDIR |\n\t\t\t      SSCR1_RxTresh(2) |\n\t\t\t      SSCR1_TxTresh(1) |\n\t\t\t      SSCR1_SPH;\n\t\t} else {\n\t\t\ttmp = SSCR1_RxTresh(RX_THRESH_DFLT) |\n\t\t\t      SSCR1_TxTresh(TX_THRESH_DFLT);\n\t\t}\n\t\tpxa2xx_spi_write(drv_data, SSCR1, tmp);\n\t\ttmp = SSCR0_Motorola | SSCR0_DataSize(8);\n\t\tif (!spi_controller_is_target(controller))\n\t\t\ttmp |= SSCR0_SCR(2);\n\t\tpxa2xx_spi_write(drv_data, SSCR0, tmp);\n\t\tbreak;\n\t}\n\n\tif (!pxa25x_ssp_comp(drv_data))\n\t\tpxa2xx_spi_write(drv_data, SSTO, 0);\n\n\tif (!is_quark_x1000_ssp(drv_data))\n\t\tpxa2xx_spi_write(drv_data, SSPSP, 0);\n\n\tif (is_lpss_ssp(drv_data)) {\n\t\tlpss_ssp_setup(drv_data);\n\t\tconfig = lpss_get_config(drv_data);\n\t\tif (config->reg_capabilities >= 0) {\n\t\t\ttmp = __lpss_ssp_read_priv(drv_data,\n\t\t\t\t\t\t   config->reg_capabilities);\n\t\t\ttmp &= LPSS_CAPS_CS_EN_MASK;\n\t\t\ttmp >>= LPSS_CAPS_CS_EN_SHIFT;\n\t\t\tplatform_info->num_chipselect = ffz(tmp);\n\t\t} else if (config->cs_num) {\n\t\t\tplatform_info->num_chipselect = config->cs_num;\n\t\t}\n\t}\n\tcontroller->num_chipselect = platform_info->num_chipselect;\n\tcontroller->use_gpio_descriptors = true;\n\n\tif (platform_info->is_target) {\n\t\tdrv_data->gpiod_ready = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t\"ready\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(drv_data->gpiod_ready)) {\n\t\t\tstatus = PTR_ERR(drv_data->gpiod_ready);\n\t\t\tgoto out_error_clock_enabled;\n\t\t}\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tplatform_set_drvdata(pdev, drv_data);\n\tstatus = spi_register_controller(controller);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"problem registering SPI controller\\n\");\n\t\tgoto out_error_pm_runtime_enabled;\n\t}\n\n\treturn status;\n\nout_error_pm_runtime_enabled:\n\tpm_runtime_disable(&pdev->dev);\n\nout_error_clock_enabled:\n\tclk_disable_unprepare(ssp->clk);\n\nout_error_dma_irq_alloc:\n\tpxa2xx_spi_dma_release(drv_data);\n\tfree_irq(ssp->irq, drv_data);\n\nout_error_controller_alloc:\n\tpxa_ssp_free(ssp);\n\treturn status;\n}\n\nstatic void pxa2xx_spi_remove(struct platform_device *pdev)\n{\n\tstruct driver_data *drv_data = platform_get_drvdata(pdev);\n\tstruct ssp_device *ssp = drv_data->ssp;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tspi_unregister_controller(drv_data->controller);\n\n\t \n\tpxa_ssp_disable(ssp);\n\tclk_disable_unprepare(ssp->clk);\n\n\t \n\tif (drv_data->controller_info->enable_dma)\n\t\tpxa2xx_spi_dma_release(drv_data);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\t \n\tfree_irq(ssp->irq, drv_data);\n\n\t \n\tpxa_ssp_free(ssp);\n}\n\nstatic int pxa2xx_spi_suspend(struct device *dev)\n{\n\tstruct driver_data *drv_data = dev_get_drvdata(dev);\n\tstruct ssp_device *ssp = drv_data->ssp;\n\tint status;\n\n\tstatus = spi_controller_suspend(drv_data->controller);\n\tif (status)\n\t\treturn status;\n\n\tpxa_ssp_disable(ssp);\n\n\tif (!pm_runtime_suspended(dev))\n\t\tclk_disable_unprepare(ssp->clk);\n\n\treturn 0;\n}\n\nstatic int pxa2xx_spi_resume(struct device *dev)\n{\n\tstruct driver_data *drv_data = dev_get_drvdata(dev);\n\tstruct ssp_device *ssp = drv_data->ssp;\n\tint status;\n\n\t \n\tif (!pm_runtime_suspended(dev)) {\n\t\tstatus = clk_prepare_enable(ssp->clk);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\treturn spi_controller_resume(drv_data->controller);\n}\n\nstatic int pxa2xx_spi_runtime_suspend(struct device *dev)\n{\n\tstruct driver_data *drv_data = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(drv_data->ssp->clk);\n\treturn 0;\n}\n\nstatic int pxa2xx_spi_runtime_resume(struct device *dev)\n{\n\tstruct driver_data *drv_data = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(drv_data->ssp->clk);\n}\n\nstatic const struct dev_pm_ops pxa2xx_spi_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(pxa2xx_spi_suspend, pxa2xx_spi_resume)\n\tRUNTIME_PM_OPS(pxa2xx_spi_runtime_suspend, pxa2xx_spi_runtime_resume, NULL)\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id pxa2xx_spi_acpi_match[] = {\n\t{ \"80860F0E\", LPSS_BYT_SSP },\n\t{ \"8086228E\", LPSS_BSW_SSP },\n\t{ \"INT33C0\", LPSS_LPT_SSP },\n\t{ \"INT33C1\", LPSS_LPT_SSP },\n\t{ \"INT3430\", LPSS_LPT_SSP },\n\t{ \"INT3431\", LPSS_LPT_SSP },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, pxa2xx_spi_acpi_match);\n#endif\n\nstatic const struct of_device_id pxa2xx_spi_of_match[] __maybe_unused = {\n\t{ .compatible = \"marvell,mmp2-ssp\", .data = (void *)MMP2_SSP },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pxa2xx_spi_of_match);\n\nstatic struct platform_driver driver = {\n\t.driver = {\n\t\t.name\t= \"pxa2xx-spi\",\n\t\t.pm\t= pm_ptr(&pxa2xx_spi_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(pxa2xx_spi_acpi_match),\n\t\t.of_match_table = of_match_ptr(pxa2xx_spi_of_match),\n\t},\n\t.probe = pxa2xx_spi_probe,\n\t.remove_new = pxa2xx_spi_remove,\n};\n\nstatic int __init pxa2xx_spi_init(void)\n{\n\treturn platform_driver_register(&driver);\n}\nsubsys_initcall(pxa2xx_spi_init);\n\nstatic void __exit pxa2xx_spi_exit(void)\n{\n\tplatform_driver_unregister(&driver);\n}\nmodule_exit(pxa2xx_spi_exit);\n\nMODULE_SOFTDEP(\"pre: dw_dmac\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}