{
  "module_name": "spi-altera-platform.c",
  "hash_id": "7f85e7cc89c1ad4435725ba947c927d6bf7704b3a12525770485d695d7affa38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-altera-platform.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/altera.h>\n#include <linux/spi/spi.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#define DRV_NAME \"spi_altera\"\n\nenum altera_spi_type {\n\tALTERA_SPI_TYPE_UNKNOWN,\n\tALTERA_SPI_TYPE_SUBDEV,\n};\n\nstatic const struct regmap_config spi_altera_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n};\n\nstatic int altera_spi_probe(struct platform_device *pdev)\n{\n\tconst struct platform_device_id *platid = platform_get_device_id(pdev);\n\tstruct altera_spi_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tenum altera_spi_type type = ALTERA_SPI_TYPE_UNKNOWN;\n\tstruct altera_spi *hw;\n\tstruct spi_controller *host;\n\tint err = -ENODEV;\n\tu16 i;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(struct altera_spi));\n\tif (!host)\n\t\treturn err;\n\n\t \n\thost->bus_num = -1;\n\n\tif (pdata) {\n\t\tif (pdata->num_chipselect > ALTERA_SPI_MAX_CS) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Invalid number of chipselect: %u\\n\",\n\t\t\t\tpdata->num_chipselect);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\thost->num_chipselect = pdata->num_chipselect;\n\t\thost->mode_bits = pdata->mode_bits;\n\t\thost->bits_per_word_mask = pdata->bits_per_word_mask;\n\t} else {\n\t\thost->num_chipselect = 16;\n\t\thost->mode_bits = SPI_CS_HIGH;\n\t\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);\n\t}\n\n\thost->dev.of_node = pdev->dev.of_node;\n\n\thw = spi_controller_get_devdata(host);\n\thw->dev = &pdev->dev;\n\n\tif (platid)\n\t\ttype = platid->driver_data;\n\n\t \n\tif (type == ALTERA_SPI_TYPE_SUBDEV) {\n\t\tstruct resource *regoff;\n\n\t\thw->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\t\tif (!hw->regmap) {\n\t\t\tdev_err(&pdev->dev, \"get regmap failed\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tregoff = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\t\tif (regoff)\n\t\t\thw->regoff = regoff->start;\n\t} else {\n\t\tvoid __iomem *res;\n\n\t\tres = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(res)) {\n\t\t\terr = PTR_ERR(res);\n\t\t\tgoto exit;\n\t\t}\n\n\t\thw->regmap = devm_regmap_init_mmio(&pdev->dev, res,\n\t\t\t\t\t\t   &spi_altera_config);\n\t\tif (IS_ERR(hw->regmap)) {\n\t\t\tdev_err(&pdev->dev, \"regmap mmio init failed\\n\");\n\t\t\terr = PTR_ERR(hw->regmap);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\taltera_spi_init_host(host);\n\n\t \n\thw->irq = platform_get_irq(pdev, 0);\n\tif (hw->irq >= 0) {\n\t\terr = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,\n\t\t\t\t       pdev->name, host);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\n\terr = devm_spi_register_controller(&pdev->dev, host);\n\tif (err)\n\t\tgoto exit;\n\n\tif (pdata) {\n\t\tfor (i = 0; i < pdata->num_devices; i++) {\n\t\t\tif (!spi_new_device(host, pdata->devices + i))\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"unable to create SPI device: %s\\n\",\n\t\t\t\t\t pdata->devices[i].modalias);\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev, \"regoff %u, irq %d\\n\", hw->regoff, hw->irq);\n\n\treturn 0;\nexit:\n\tspi_controller_put(host);\n\treturn err;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id altera_spi_match[] = {\n\t{ .compatible = \"ALTR,spi-1.0\", },\n\t{ .compatible = \"altr,spi-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_spi_match);\n#endif  \n\nstatic const struct platform_device_id altera_spi_ids[] = {\n\t{ DRV_NAME,\t\tALTERA_SPI_TYPE_UNKNOWN },\n\t{ \"subdev_spi_altera\",\tALTERA_SPI_TYPE_SUBDEV },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, altera_spi_ids);\n\nstatic struct platform_driver altera_spi_driver = {\n\t.probe = altera_spi_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = NULL,\n\t\t.of_match_table = of_match_ptr(altera_spi_match),\n\t},\n\t.id_table\t= altera_spi_ids,\n};\nmodule_platform_driver(altera_spi_driver);\n\nMODULE_DESCRIPTION(\"Altera SPI driver\");\nMODULE_AUTHOR(\"Thomas Chou <thomas@wytron.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}