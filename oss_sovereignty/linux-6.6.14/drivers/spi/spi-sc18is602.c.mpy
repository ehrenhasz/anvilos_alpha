{
  "module_name": "spi-sc18is602.c",
  "hash_id": "955114d39663fa4952d1c834c43155b566f90c50d86bcb40b281e1156758e645",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sc18is602.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/platform_data/sc18is602.h>\n#include <linux/gpio/consumer.h>\n\nenum chips { sc18is602, sc18is602b, sc18is603 };\n\n#define SC18IS602_BUFSIZ\t\t200\n#define SC18IS602_CLOCK\t\t\t7372000\n\n#define SC18IS602_MODE_CPHA\t\tBIT(2)\n#define SC18IS602_MODE_CPOL\t\tBIT(3)\n#define SC18IS602_MODE_LSB_FIRST\tBIT(5)\n#define SC18IS602_MODE_CLOCK_DIV_4\t0x0\n#define SC18IS602_MODE_CLOCK_DIV_16\t0x1\n#define SC18IS602_MODE_CLOCK_DIV_64\t0x2\n#define SC18IS602_MODE_CLOCK_DIV_128\t0x3\n\nstruct sc18is602 {\n\tstruct spi_controller\t*host;\n\tstruct device\t\t*dev;\n\tu8\t\t\tctrl;\n\tu32\t\t\tfreq;\n\tu32\t\t\tspeed;\n\n\t \n\tstruct i2c_client\t*client;\n\tenum chips\t\tid;\n\tu8\t\t\tbuffer[SC18IS602_BUFSIZ + 1];\n\tint\t\t\ttlen;\t \n\tint\t\t\trindex;\t \n\n\tstruct gpio_desc\t*reset;\n};\n\nstatic int sc18is602_wait_ready(struct sc18is602 *hw, int len)\n{\n\tint i, err;\n\tint usecs = 1000000 * len / hw->speed + 1;\n\tu8 dummy[1];\n\n\tfor (i = 0; i < 10; i++) {\n\t\terr = i2c_master_recv(hw->client, dummy, 1);\n\t\tif (err >= 0)\n\t\t\treturn 0;\n\t\tusleep_range(usecs, usecs * 2);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int sc18is602_txrx(struct sc18is602 *hw, struct spi_message *msg,\n\t\t\t  struct spi_transfer *t, bool do_transfer)\n{\n\tunsigned int len = t->len;\n\tint ret;\n\n\tif (hw->tlen == 0) {\n\t\t \n\t\thw->buffer[0] = 1 << spi_get_chipselect(msg->spi, 0);\n\t\thw->tlen = 1;\n\t\thw->rindex = 0;\n\t}\n\t \n\tif (t->tx_buf) {\n\t\tmemcpy(&hw->buffer[hw->tlen], t->tx_buf, len);\n\t\thw->tlen += len;\n\t\tif (t->rx_buf)\n\t\t\tdo_transfer = true;\n\t\telse\n\t\t\thw->rindex = hw->tlen - 1;\n\t} else if (t->rx_buf) {\n\t\t \n\t\thw->rindex = hw->tlen - 1;\n\t\tmemset(&hw->buffer[hw->tlen], 0, len);\n\t\thw->tlen += len;\n\t\tdo_transfer = true;\n\t}\n\n\tif (do_transfer && hw->tlen > 1) {\n\t\tret = sc18is602_wait_ready(hw, SC18IS602_BUFSIZ);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_master_send(hw->client, hw->buffer, hw->tlen);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret != hw->tlen)\n\t\t\treturn -EIO;\n\n\t\tif (t->rx_buf) {\n\t\t\tint rlen = hw->rindex + len;\n\n\t\t\tret = sc18is602_wait_ready(hw, hw->tlen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = i2c_master_recv(hw->client, hw->buffer, rlen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret != rlen)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(t->rx_buf, &hw->buffer[hw->rindex], len);\n\t\t}\n\t\thw->tlen = 0;\n\t}\n\treturn len;\n}\n\nstatic int sc18is602_setup_transfer(struct sc18is602 *hw, u32 hz, u8 mode)\n{\n\tu8 ctrl = 0;\n\tint ret;\n\n\tif (mode & SPI_CPHA)\n\t\tctrl |= SC18IS602_MODE_CPHA;\n\tif (mode & SPI_CPOL)\n\t\tctrl |= SC18IS602_MODE_CPOL;\n\tif (mode & SPI_LSB_FIRST)\n\t\tctrl |= SC18IS602_MODE_LSB_FIRST;\n\n\t \n\tif (hz >= hw->freq / 4) {\n\t\tctrl |= SC18IS602_MODE_CLOCK_DIV_4;\n\t\thw->speed = hw->freq / 4;\n\t} else if (hz >= hw->freq / 16) {\n\t\tctrl |= SC18IS602_MODE_CLOCK_DIV_16;\n\t\thw->speed = hw->freq / 16;\n\t} else if (hz >= hw->freq / 64) {\n\t\tctrl |= SC18IS602_MODE_CLOCK_DIV_64;\n\t\thw->speed = hw->freq / 64;\n\t} else {\n\t\tctrl |= SC18IS602_MODE_CLOCK_DIV_128;\n\t\thw->speed = hw->freq / 128;\n\t}\n\n\t \n\tif (ctrl == hw->ctrl)\n\t\treturn 0;\n\n\tret = i2c_smbus_write_byte_data(hw->client, 0xf0, ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thw->ctrl = ctrl;\n\n\treturn 0;\n}\n\nstatic int sc18is602_check_transfer(struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *t, int tlen)\n{\n\tif (t && t->len + tlen > SC18IS602_BUFSIZ + 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sc18is602_transfer_one(struct spi_controller *host,\n\t\t\t\t  struct spi_message *m)\n{\n\tstruct sc18is602 *hw = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = m->spi;\n\tstruct spi_transfer *t;\n\tint status = 0;\n\n\thw->tlen = 0;\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tbool do_transfer;\n\n\t\tstatus = sc18is602_check_transfer(spi, t, hw->tlen);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tdo_transfer = t->cs_change || list_is_last(&t->transfer_list,\n\t\t\t\t\t\t\t   &m->transfers);\n\n\t\tif (t->len) {\n\t\t\tstatus = sc18is602_txrx(hw, m, t, do_transfer);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tm->actual_length += status;\n\t\t}\n\t\tstatus = 0;\n\n\t\tspi_transfer_delay_exec(t);\n\t}\n\tm->status = status;\n\tspi_finalize_current_message(host);\n\n\treturn status;\n}\n\nstatic size_t sc18is602_max_transfer_size(struct spi_device *spi)\n{\n\treturn SC18IS602_BUFSIZ;\n}\n\nstatic int sc18is602_setup(struct spi_device *spi)\n{\n\tstruct sc18is602 *hw = spi_controller_get_devdata(spi->controller);\n\n\t \n\tif (hw->id == sc18is602 && (spi_get_chipselect(spi, 0) == 2))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int sc18is602_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sc18is602_platform_data *pdata = dev_get_platdata(dev);\n\tstruct sc18is602 *hw;\n\tstruct spi_controller *host;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -EINVAL;\n\n\thost = devm_spi_alloc_host(dev, sizeof(struct sc18is602));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thw = spi_controller_get_devdata(host);\n\ti2c_set_clientdata(client, hw);\n\n\t \n\thw->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hw->reset))\n\t\treturn PTR_ERR(hw->reset);\n\tgpiod_set_value_cansleep(hw->reset, 0);\n\n\thw->host = host;\n\thw->client = client;\n\thw->dev = dev;\n\thw->ctrl = 0xff;\n\n\tif (client->dev.of_node)\n\t\thw->id = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\thw->id = id->driver_data;\n\n\tswitch (hw->id) {\n\tcase sc18is602:\n\tcase sc18is602b:\n\t\thost->num_chipselect = 4;\n\t\thw->freq = SC18IS602_CLOCK;\n\t\tbreak;\n\tcase sc18is603:\n\t\thost->num_chipselect = 2;\n\t\tif (pdata) {\n\t\t\thw->freq = pdata->clock_frequency;\n\t\t} else {\n\t\t\tconst __be32 *val;\n\t\t\tint len;\n\n\t\t\tval = of_get_property(np, \"clock-frequency\", &len);\n\t\t\tif (val && len >= sizeof(__be32))\n\t\t\t\thw->freq = be32_to_cpup(val);\n\t\t}\n\t\tif (!hw->freq)\n\t\t\thw->freq = SC18IS602_CLOCK;\n\t\tbreak;\n\t}\n\thost->bus_num = np ? -1 : client->adapter->nr;\n\thost->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->setup = sc18is602_setup;\n\thost->transfer_one_message = sc18is602_transfer_one;\n\thost->max_transfer_size = sc18is602_max_transfer_size;\n\thost->max_message_size = sc18is602_max_transfer_size;\n\thost->dev.of_node = np;\n\thost->min_speed_hz = hw->freq / 128;\n\thost->max_speed_hz = hw->freq / 4;\n\n\treturn devm_spi_register_controller(dev, host);\n}\n\nstatic const struct i2c_device_id sc18is602_id[] = {\n\t{ \"sc18is602\", sc18is602 },\n\t{ \"sc18is602b\", sc18is602b },\n\t{ \"sc18is603\", sc18is603 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sc18is602_id);\n\nstatic const struct of_device_id sc18is602_of_match[] __maybe_unused = {\n\t{\n\t\t.compatible = \"nxp,sc18is602\",\n\t\t.data = (void *)sc18is602\n\t},\n\t{\n\t\t.compatible = \"nxp,sc18is602b\",\n\t\t.data = (void *)sc18is602b\n\t},\n\t{\n\t\t.compatible = \"nxp,sc18is603\",\n\t\t.data = (void *)sc18is603\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sc18is602_of_match);\n\nstatic struct i2c_driver sc18is602_driver = {\n\t.driver = {\n\t\t.name = \"sc18is602\",\n\t\t.of_match_table = of_match_ptr(sc18is602_of_match),\n\t},\n\t.probe = sc18is602_probe,\n\t.id_table = sc18is602_id,\n};\n\nmodule_i2c_driver(sc18is602_driver);\n\nMODULE_DESCRIPTION(\"SC18IS602/603 SPI Host Driver\");\nMODULE_AUTHOR(\"Guenter Roeck\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}