{
  "module_name": "spi-dw-pci.c",
  "hash_id": "6de2cee5af46c3478b6bcf3bb177ec7748c1c207a6f45e1180e895d5b03b42a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-dw-pci.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include \"spi-dw.h\"\n\n#define DRIVER_NAME \"dw_spi_pci\"\n\n \n#define MRST_SPI_CLK_BASE\t100000000\t \n#define MRST_CLK_SPI_REG\t0xff11d86c\n#define CLK_SPI_BDIV_OFFSET\t0\n#define CLK_SPI_BDIV_MASK\t0x00000007\n#define CLK_SPI_CDIV_OFFSET\t9\n#define CLK_SPI_CDIV_MASK\t0x00000e00\n#define CLK_SPI_DISABLE_OFFSET\t8\n\nstruct dw_spi_pci_desc {\n\tint\t(*setup)(struct dw_spi *);\n\tu16\tnum_cs;\n\tu16\tbus_num;\n\tu32\tmax_freq;\n};\n\nstatic int dw_spi_pci_mid_init(struct dw_spi *dws)\n{\n\tvoid __iomem *clk_reg;\n\tu32 clk_cdiv;\n\n\tclk_reg = ioremap(MRST_CLK_SPI_REG, 16);\n\tif (!clk_reg)\n\t\treturn -ENOMEM;\n\n\t \n\tclk_cdiv = readl(clk_reg + dws->bus_num * sizeof(u32));\n\tclk_cdiv &= CLK_SPI_CDIV_MASK;\n\tclk_cdiv >>= CLK_SPI_CDIV_OFFSET;\n\tdws->max_freq = MRST_SPI_CLK_BASE / (clk_cdiv + 1);\n\n\tiounmap(clk_reg);\n\n\tdw_spi_dma_setup_mfld(dws);\n\n\treturn 0;\n}\n\nstatic int dw_spi_pci_generic_init(struct dw_spi *dws)\n{\n\tdw_spi_dma_setup_generic(dws);\n\n\treturn 0;\n}\n\nstatic struct dw_spi_pci_desc dw_spi_pci_mid_desc_1 = {\n\t.setup = dw_spi_pci_mid_init,\n\t.num_cs = 5,\n\t.bus_num = 0,\n};\n\nstatic struct dw_spi_pci_desc dw_spi_pci_mid_desc_2 = {\n\t.setup = dw_spi_pci_mid_init,\n\t.num_cs = 2,\n\t.bus_num = 1,\n};\n\nstatic struct dw_spi_pci_desc dw_spi_pci_ehl_desc = {\n\t.setup = dw_spi_pci_generic_init,\n\t.num_cs = 2,\n\t.bus_num = -1,\n\t.max_freq = 100000000,\n};\n\nstatic int dw_spi_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct dw_spi_pci_desc *desc = (struct dw_spi_pci_desc *)ent->driver_data;\n\tstruct dw_spi *dws;\n\tint pci_bar = 0;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdws = devm_kzalloc(&pdev->dev, sizeof(*dws), GFP_KERNEL);\n\tif (!dws)\n\t\treturn -ENOMEM;\n\n\t \n\tdws->paddr = pci_resource_start(pdev, pci_bar);\n\tpci_set_master(pdev);\n\n\tret = pcim_iomap_regions(pdev, 1 << pci_bar, pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdws->regs = pcim_iomap_table(pdev)[pci_bar];\n\tdws->irq = pci_irq_vector(pdev, 0);\n\n\t \n\tif (desc) {\n\t\tdws->num_cs = desc->num_cs;\n\t\tdws->bus_num = desc->bus_num;\n\t\tdws->max_freq = desc->max_freq;\n\n\t\tif (desc->setup) {\n\t\t\tret = desc->setup(dws);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_irq_vectors;\n\t\t}\n\t} else {\n\t\tret = -ENODEV;\n\t\tgoto err_free_irq_vectors;\n\t}\n\n\tret = dw_spi_add_host(&pdev->dev, dws);\n\tif (ret)\n\t\tgoto err_free_irq_vectors;\n\n\t \n\tpci_set_drvdata(pdev, dws);\n\n\tdev_info(&pdev->dev, \"found PCI SPI controller(ID: %04x:%04x)\\n\",\n\t\tpdev->vendor, pdev->device);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 1000);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\tpm_runtime_allow(&pdev->dev);\n\n\treturn 0;\n\nerr_free_irq_vectors:\n\tpci_free_irq_vectors(pdev);\n\treturn ret;\n}\n\nstatic void dw_spi_pci_remove(struct pci_dev *pdev)\n{\n\tstruct dw_spi *dws = pci_get_drvdata(pdev);\n\n\tpm_runtime_forbid(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tdw_spi_remove_host(dws);\n\tpci_free_irq_vectors(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dw_spi_pci_suspend(struct device *dev)\n{\n\tstruct dw_spi *dws = dev_get_drvdata(dev);\n\n\treturn dw_spi_suspend_host(dws);\n}\n\nstatic int dw_spi_pci_resume(struct device *dev)\n{\n\tstruct dw_spi *dws = dev_get_drvdata(dev);\n\n\treturn dw_spi_resume_host(dws);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(dw_spi_pci_pm_ops, dw_spi_pci_suspend, dw_spi_pci_resume);\n\nstatic const struct pci_device_id dw_spi_pci_ids[] = {\n\t \n\t \n\t \n\t{ PCI_VDEVICE(INTEL, 0x0800), (kernel_ulong_t)&dw_spi_pci_mid_desc_1},\n\t \n\t{ PCI_VDEVICE(INTEL, 0x0812), (kernel_ulong_t)&dw_spi_pci_mid_desc_2},\n\t \n\t{ PCI_VDEVICE(INTEL, 0x4b84), (kernel_ulong_t)&dw_spi_pci_ehl_desc},\n\t{ PCI_VDEVICE(INTEL, 0x4b85), (kernel_ulong_t)&dw_spi_pci_ehl_desc},\n\t{ PCI_VDEVICE(INTEL, 0x4b86), (kernel_ulong_t)&dw_spi_pci_ehl_desc},\n\t{ PCI_VDEVICE(INTEL, 0x4b87), (kernel_ulong_t)&dw_spi_pci_ehl_desc},\n\t{},\n};\nMODULE_DEVICE_TABLE(pci, dw_spi_pci_ids);\n\nstatic struct pci_driver dw_spi_pci_driver = {\n\t.name =\t\tDRIVER_NAME,\n\t.id_table =\tdw_spi_pci_ids,\n\t.probe =\tdw_spi_pci_probe,\n\t.remove =\tdw_spi_pci_remove,\n\t.driver         = {\n\t\t.pm     = &dw_spi_pci_pm_ops,\n\t},\n};\nmodule_pci_driver(dw_spi_pci_driver);\n\nMODULE_AUTHOR(\"Feng Tang <feng.tang@intel.com>\");\nMODULE_DESCRIPTION(\"PCI interface driver for DW SPI Core\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SPI_DW_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}