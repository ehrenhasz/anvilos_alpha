{
  "module_name": "spi-mtk-nor.c",
  "hash_id": "92ada2f2b0e2bc8d00c53d806d8f716b5d45ab907e712c3f9c96d826e5e50c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mtk-nor.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/string.h>\n\n#define DRIVER_NAME \"mtk-spi-nor\"\n\n#define MTK_NOR_REG_CMD\t\t\t0x00\n#define MTK_NOR_CMD_WRITE\t\tBIT(4)\n#define MTK_NOR_CMD_PROGRAM\t\tBIT(2)\n#define MTK_NOR_CMD_READ\t\tBIT(0)\n#define MTK_NOR_CMD_MASK\t\tGENMASK(5, 0)\n\n#define MTK_NOR_REG_PRG_CNT\t\t0x04\n#define MTK_NOR_PRG_CNT_MAX\t\t56\n#define MTK_NOR_REG_RDATA\t\t0x0c\n\n#define MTK_NOR_REG_RADR0\t\t0x10\n#define MTK_NOR_REG_RADR(n)\t\t(MTK_NOR_REG_RADR0 + 4 * (n))\n#define MTK_NOR_REG_RADR3\t\t0xc8\n\n#define MTK_NOR_REG_WDATA\t\t0x1c\n\n#define MTK_NOR_REG_PRGDATA0\t\t0x20\n#define MTK_NOR_REG_PRGDATA(n)\t\t(MTK_NOR_REG_PRGDATA0 + 4 * (n))\n#define MTK_NOR_REG_PRGDATA_MAX\t\t5\n\n#define MTK_NOR_REG_SHIFT0\t\t0x38\n#define MTK_NOR_REG_SHIFT(n)\t\t(MTK_NOR_REG_SHIFT0 + 4 * (n))\n#define MTK_NOR_REG_SHIFT_MAX\t\t9\n\n#define MTK_NOR_REG_CFG1\t\t0x60\n#define MTK_NOR_FAST_READ\t\tBIT(0)\n\n#define MTK_NOR_REG_CFG2\t\t0x64\n#define MTK_NOR_WR_CUSTOM_OP_EN\t\tBIT(4)\n#define MTK_NOR_WR_BUF_EN\t\tBIT(0)\n\n#define MTK_NOR_REG_PP_DATA\t\t0x98\n\n#define MTK_NOR_REG_IRQ_STAT\t\t0xa8\n#define MTK_NOR_REG_IRQ_EN\t\t0xac\n#define MTK_NOR_IRQ_DMA\t\t\tBIT(7)\n#define MTK_NOR_IRQ_MASK\t\tGENMASK(7, 0)\n\n#define MTK_NOR_REG_CFG3\t\t0xb4\n#define MTK_NOR_DISABLE_WREN\t\tBIT(7)\n#define MTK_NOR_DISABLE_SR_POLL\t\tBIT(5)\n\n#define MTK_NOR_REG_WP\t\t\t0xc4\n#define MTK_NOR_ENABLE_SF_CMD\t\t0x30\n\n#define MTK_NOR_REG_BUSCFG\t\t0xcc\n#define MTK_NOR_4B_ADDR\t\t\tBIT(4)\n#define MTK_NOR_QUAD_ADDR\t\tBIT(3)\n#define MTK_NOR_QUAD_READ\t\tBIT(2)\n#define MTK_NOR_DUAL_ADDR\t\tBIT(1)\n#define MTK_NOR_DUAL_READ\t\tBIT(0)\n#define MTK_NOR_BUS_MODE_MASK\t\tGENMASK(4, 0)\n\n#define MTK_NOR_REG_DMA_CTL\t\t0x718\n#define MTK_NOR_DMA_START\t\tBIT(0)\n\n#define MTK_NOR_REG_DMA_FADR\t\t0x71c\n#define MTK_NOR_REG_DMA_DADR\t\t0x720\n#define MTK_NOR_REG_DMA_END_DADR\t0x724\n#define MTK_NOR_REG_CG_DIS\t\t0x728\n#define MTK_NOR_SFC_SW_RST\t\tBIT(2)\n\n#define MTK_NOR_REG_DMA_DADR_HB\t\t0x738\n#define MTK_NOR_REG_DMA_END_DADR_HB\t0x73c\n\n#define MTK_NOR_PRG_MAX_SIZE\t\t6\n\n#define MTK_NOR_DMA_ALIGN\t\t16\n#define MTK_NOR_DMA_ALIGN_MASK\t\t(MTK_NOR_DMA_ALIGN - 1)\n\n#define MTK_NOR_BOUNCE_BUF_SIZE\t\tPAGE_SIZE\n\n\n#define MTK_NOR_PP_SIZE\t\t\t128\n\n#define CLK_TO_US(sp, clkcnt)\t\tDIV_ROUND_UP(clkcnt, sp->spi_freq / 1000000)\n\nstruct mtk_nor_caps {\n\tu8 dma_bits;\n\n\t \n\tu8 extra_dummy_bit;\n};\n\nstruct mtk_nor {\n\tstruct spi_controller *ctlr;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tu8 *buffer;\n\tdma_addr_t buffer_dma;\n\tstruct clk *spi_clk;\n\tstruct clk *ctlr_clk;\n\tstruct clk *axi_clk;\n\tstruct clk *axi_s_clk;\n\tunsigned int spi_freq;\n\tbool wbuf_en;\n\tbool has_irq;\n\tbool high_dma;\n\tstruct completion op_done;\n\tconst struct mtk_nor_caps *caps;\n};\n\nstatic inline void mtk_nor_rmw(struct mtk_nor *sp, u32 reg, u32 set, u32 clr)\n{\n\tu32 val = readl(sp->base + reg);\n\n\tval &= ~clr;\n\tval |= set;\n\twritel(val, sp->base + reg);\n}\n\nstatic inline int mtk_nor_cmd_exec(struct mtk_nor *sp, u32 cmd, ulong clk)\n{\n\tulong delay = CLK_TO_US(sp, clk);\n\tu32 reg;\n\tint ret;\n\n\twritel(cmd, sp->base + MTK_NOR_REG_CMD);\n\tret = readl_poll_timeout(sp->base + MTK_NOR_REG_CMD, reg, !(reg & cmd),\n\t\t\t\t delay / 3, (delay + 1) * 200);\n\tif (ret < 0)\n\t\tdev_err(sp->dev, \"command %u timeout.\\n\", cmd);\n\treturn ret;\n}\n\nstatic void mtk_nor_reset(struct mtk_nor *sp)\n{\n\tmtk_nor_rmw(sp, MTK_NOR_REG_CG_DIS, 0, MTK_NOR_SFC_SW_RST);\n\tmb();  \n\tmtk_nor_rmw(sp, MTK_NOR_REG_CG_DIS, MTK_NOR_SFC_SW_RST, 0);\n\tmb();  \n\twritel(MTK_NOR_ENABLE_SF_CMD, sp->base + MTK_NOR_REG_WP);\n}\n\nstatic void mtk_nor_set_addr(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tu32 addr = op->addr.val;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\twriteb(addr & 0xff, sp->base + MTK_NOR_REG_RADR(i));\n\t\taddr >>= 8;\n\t}\n\tif (op->addr.nbytes == 4) {\n\t\twriteb(addr & 0xff, sp->base + MTK_NOR_REG_RADR3);\n\t\tmtk_nor_rmw(sp, MTK_NOR_REG_BUSCFG, MTK_NOR_4B_ADDR, 0);\n\t} else {\n\t\tmtk_nor_rmw(sp, MTK_NOR_REG_BUSCFG, 0, MTK_NOR_4B_ADDR);\n\t}\n}\n\nstatic bool need_bounce(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\treturn ((uintptr_t)op->data.buf.in & MTK_NOR_DMA_ALIGN_MASK);\n}\n\nstatic bool mtk_nor_match_read(const struct spi_mem_op *op)\n{\n\tint dummy = 0;\n\n\tif (op->dummy.nbytes)\n\t\tdummy = op->dummy.nbytes * BITS_PER_BYTE / op->dummy.buswidth;\n\n\tif ((op->data.buswidth == 2) || (op->data.buswidth == 4)) {\n\t\tif (op->addr.buswidth == 1)\n\t\t\treturn dummy == 8;\n\t\telse if (op->addr.buswidth == 2)\n\t\t\treturn dummy == 4;\n\t\telse if (op->addr.buswidth == 4)\n\t\t\treturn dummy == 6;\n\t} else if ((op->addr.buswidth == 1) && (op->data.buswidth == 1)) {\n\t\tif (op->cmd.opcode == 0x03)\n\t\t\treturn dummy == 0;\n\t\telse if (op->cmd.opcode == 0x0b)\n\t\t\treturn dummy == 8;\n\t}\n\treturn false;\n}\n\nstatic bool mtk_nor_match_prg(const struct spi_mem_op *op)\n{\n\tint tx_len, rx_len, prg_len, prg_left;\n\n\t \n\tif ((op->cmd.buswidth > 1) || (op->addr.buswidth > 1) ||\n\t    (op->dummy.buswidth > 1) || (op->data.buswidth > 1))\n\t\treturn false;\n\n\ttx_len = op->cmd.nbytes + op->addr.nbytes;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\t \n\t\ttx_len += op->dummy.nbytes;\n\n\t\t \n\t\tif (tx_len > MTK_NOR_REG_PRGDATA_MAX)\n\t\t\treturn false;\n\n\t\t \n\t\t\n\t\tif ((!op->addr.nbytes) &&\n\t\t    (tx_len + op->data.nbytes > MTK_NOR_REG_PRGDATA_MAX + 1))\n\t\t\treturn false;\n\t} else if (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (tx_len > MTK_NOR_REG_PRGDATA_MAX + 1)\n\t\t\treturn false;\n\n\t\trx_len = op->data.nbytes;\n\t\tprg_left = MTK_NOR_PRG_CNT_MAX / 8 - tx_len - op->dummy.nbytes;\n\t\tif (prg_left > MTK_NOR_REG_SHIFT_MAX + 1)\n\t\t\tprg_left = MTK_NOR_REG_SHIFT_MAX + 1;\n\t\tif (rx_len > prg_left) {\n\t\t\tif (!op->addr.nbytes)\n\t\t\t\treturn false;\n\t\t\trx_len = prg_left;\n\t\t}\n\n\t\tprg_len = tx_len + op->dummy.nbytes + rx_len;\n\t\tif (prg_len > MTK_NOR_PRG_CNT_MAX / 8)\n\t\t\treturn false;\n\t} else {\n\t\tprg_len = tx_len + op->dummy.nbytes;\n\t\tif (prg_len > MTK_NOR_PRG_CNT_MAX / 8)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void mtk_nor_adj_prg_size(struct spi_mem_op *op)\n{\n\tint tx_len, tx_left, prg_left;\n\n\ttx_len = op->cmd.nbytes + op->addr.nbytes;\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\ttx_len += op->dummy.nbytes;\n\t\ttx_left = MTK_NOR_REG_PRGDATA_MAX + 1 - tx_len;\n\t\tif (op->data.nbytes > tx_left)\n\t\t\top->data.nbytes = tx_left;\n\t} else if (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tprg_left = MTK_NOR_PRG_CNT_MAX / 8 - tx_len - op->dummy.nbytes;\n\t\tif (prg_left > MTK_NOR_REG_SHIFT_MAX + 1)\n\t\t\tprg_left = MTK_NOR_REG_SHIFT_MAX + 1;\n\t\tif (op->data.nbytes > prg_left)\n\t\t\top->data.nbytes = prg_left;\n\t}\n}\n\nstatic int mtk_nor_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct mtk_nor *sp = spi_controller_get_devdata(mem->spi->master);\n\n\tif (!op->data.nbytes)\n\t\treturn 0;\n\n\tif ((op->addr.nbytes == 3) || (op->addr.nbytes == 4)) {\n\t\tif ((op->data.dir == SPI_MEM_DATA_IN) &&\n\t\t    mtk_nor_match_read(op)) {\n\t\t\t\n\t\t\tif (op->data.nbytes > 0x400000)\n\t\t\t\top->data.nbytes = 0x400000;\n\n\t\t\tif ((op->addr.val & MTK_NOR_DMA_ALIGN_MASK) ||\n\t\t\t    (op->data.nbytes < MTK_NOR_DMA_ALIGN))\n\t\t\t\top->data.nbytes = 1;\n\t\t\telse if (!need_bounce(sp, op))\n\t\t\t\top->data.nbytes &= ~MTK_NOR_DMA_ALIGN_MASK;\n\t\t\telse if (op->data.nbytes > MTK_NOR_BOUNCE_BUF_SIZE)\n\t\t\t\top->data.nbytes = MTK_NOR_BOUNCE_BUF_SIZE;\n\t\t\treturn 0;\n\t\t} else if (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\t\tif (op->data.nbytes >= MTK_NOR_PP_SIZE)\n\t\t\t\top->data.nbytes = MTK_NOR_PP_SIZE;\n\t\t\telse\n\t\t\t\top->data.nbytes = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmtk_nor_adj_prg_size(op);\n\treturn 0;\n}\n\nstatic bool mtk_nor_supports_op(struct spi_mem *mem,\n\t\t\t\tconst struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\tif (op->cmd.buswidth != 1)\n\t\treturn false;\n\n\tif ((op->addr.nbytes == 3) || (op->addr.nbytes == 4)) {\n\t\tswitch (op->data.dir) {\n\t\tcase SPI_MEM_DATA_IN:\n\t\t\tif (mtk_nor_match_read(op))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase SPI_MEM_DATA_OUT:\n\t\t\tif ((op->addr.buswidth == 1) &&\n\t\t\t    (op->dummy.nbytes == 0) &&\n\t\t\t    (op->data.buswidth == 1))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mtk_nor_match_prg(op);\n}\n\nstatic void mtk_nor_setup_bus(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tu32 reg = 0;\n\n\tif (op->addr.nbytes == 4)\n\t\treg |= MTK_NOR_4B_ADDR;\n\n\tif (op->data.buswidth == 4) {\n\t\treg |= MTK_NOR_QUAD_READ;\n\t\twriteb(op->cmd.opcode, sp->base + MTK_NOR_REG_PRGDATA(4));\n\t\tif (op->addr.buswidth == 4)\n\t\t\treg |= MTK_NOR_QUAD_ADDR;\n\t} else if (op->data.buswidth == 2) {\n\t\treg |= MTK_NOR_DUAL_READ;\n\t\twriteb(op->cmd.opcode, sp->base + MTK_NOR_REG_PRGDATA(3));\n\t\tif (op->addr.buswidth == 2)\n\t\t\treg |= MTK_NOR_DUAL_ADDR;\n\t} else {\n\t\tif (op->cmd.opcode == 0x0b)\n\t\t\tmtk_nor_rmw(sp, MTK_NOR_REG_CFG1, MTK_NOR_FAST_READ, 0);\n\t\telse\n\t\t\tmtk_nor_rmw(sp, MTK_NOR_REG_CFG1, 0, MTK_NOR_FAST_READ);\n\t}\n\tmtk_nor_rmw(sp, MTK_NOR_REG_BUSCFG, reg, MTK_NOR_BUS_MODE_MASK);\n}\n\nstatic int mtk_nor_dma_exec(struct mtk_nor *sp, u32 from, unsigned int length,\n\t\t\t    dma_addr_t dma_addr)\n{\n\tint ret = 0;\n\tu32 delay, timeout;\n\tu32 reg;\n\n\twritel(from, sp->base + MTK_NOR_REG_DMA_FADR);\n\twritel(dma_addr, sp->base + MTK_NOR_REG_DMA_DADR);\n\twritel(dma_addr + length, sp->base + MTK_NOR_REG_DMA_END_DADR);\n\n\tif (sp->high_dma) {\n\t\twritel(upper_32_bits(dma_addr),\n\t\t       sp->base + MTK_NOR_REG_DMA_DADR_HB);\n\t\twritel(upper_32_bits(dma_addr + length),\n\t\t       sp->base + MTK_NOR_REG_DMA_END_DADR_HB);\n\t}\n\n\tif (sp->has_irq) {\n\t\treinit_completion(&sp->op_done);\n\t\tmtk_nor_rmw(sp, MTK_NOR_REG_IRQ_EN, MTK_NOR_IRQ_DMA, 0);\n\t}\n\n\tmtk_nor_rmw(sp, MTK_NOR_REG_DMA_CTL, MTK_NOR_DMA_START, 0);\n\n\tdelay = CLK_TO_US(sp, (length + 5) * BITS_PER_BYTE);\n\ttimeout = (delay + 1) * 100;\n\n\tif (sp->has_irq) {\n\t\tif (!wait_for_completion_timeout(&sp->op_done,\n\t\t    usecs_to_jiffies(max(timeout, 10000U))))\n\t\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = readl_poll_timeout(sp->base + MTK_NOR_REG_DMA_CTL, reg,\n\t\t\t\t\t !(reg & MTK_NOR_DMA_START), delay / 3,\n\t\t\t\t\t timeout);\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(sp->dev, \"dma read timeout.\\n\");\n\n\treturn ret;\n}\n\nstatic int mtk_nor_read_bounce(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tunsigned int rdlen;\n\tint ret;\n\n\tif (op->data.nbytes & MTK_NOR_DMA_ALIGN_MASK)\n\t\trdlen = (op->data.nbytes + MTK_NOR_DMA_ALIGN) & ~MTK_NOR_DMA_ALIGN_MASK;\n\telse\n\t\trdlen = op->data.nbytes;\n\n\tret = mtk_nor_dma_exec(sp, op->addr.val, rdlen, sp->buffer_dma);\n\n\tif (!ret)\n\t\tmemcpy(op->data.buf.in, sp->buffer, op->data.nbytes);\n\n\treturn ret;\n}\n\nstatic int mtk_nor_read_dma(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tint ret;\n\tdma_addr_t dma_addr;\n\n\tif (need_bounce(sp, op))\n\t\treturn mtk_nor_read_bounce(sp, op);\n\n\tdma_addr = dma_map_single(sp->dev, op->data.buf.in,\n\t\t\t\t  op->data.nbytes, DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(sp->dev, dma_addr))\n\t\treturn -EINVAL;\n\n\tret = mtk_nor_dma_exec(sp, op->addr.val, op->data.nbytes, dma_addr);\n\n\tdma_unmap_single(sp->dev, dma_addr, op->data.nbytes, DMA_FROM_DEVICE);\n\n\treturn ret;\n}\n\nstatic int mtk_nor_read_pio(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tu8 *buf = op->data.buf.in;\n\tint ret;\n\n\tret = mtk_nor_cmd_exec(sp, MTK_NOR_CMD_READ, 6 * BITS_PER_BYTE);\n\tif (!ret)\n\t\tbuf[0] = readb(sp->base + MTK_NOR_REG_RDATA);\n\treturn ret;\n}\n\nstatic int mtk_nor_setup_write_buffer(struct mtk_nor *sp, bool on)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!(sp->wbuf_en ^ on))\n\t\treturn 0;\n\n\tval = readl(sp->base + MTK_NOR_REG_CFG2);\n\tif (on) {\n\t\twritel(val | MTK_NOR_WR_BUF_EN, sp->base + MTK_NOR_REG_CFG2);\n\t\tret = readl_poll_timeout(sp->base + MTK_NOR_REG_CFG2, val,\n\t\t\t\t\t val & MTK_NOR_WR_BUF_EN, 0, 10000);\n\t} else {\n\t\twritel(val & ~MTK_NOR_WR_BUF_EN, sp->base + MTK_NOR_REG_CFG2);\n\t\tret = readl_poll_timeout(sp->base + MTK_NOR_REG_CFG2, val,\n\t\t\t\t\t !(val & MTK_NOR_WR_BUF_EN), 0, 10000);\n\t}\n\n\tif (!ret)\n\t\tsp->wbuf_en = on;\n\n\treturn ret;\n}\n\nstatic int mtk_nor_pp_buffered(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tconst u8 *buf = op->data.buf.out;\n\tu32 val;\n\tint ret, i;\n\n\tret = mtk_nor_setup_write_buffer(sp, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < op->data.nbytes; i += 4) {\n\t\tval = buf[i + 3] << 24 | buf[i + 2] << 16 | buf[i + 1] << 8 |\n\t\t      buf[i];\n\t\twritel(val, sp->base + MTK_NOR_REG_PP_DATA);\n\t}\n\treturn mtk_nor_cmd_exec(sp, MTK_NOR_CMD_WRITE,\n\t\t\t\t(op->data.nbytes + 5) * BITS_PER_BYTE);\n}\n\nstatic int mtk_nor_pp_unbuffered(struct mtk_nor *sp,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tconst u8 *buf = op->data.buf.out;\n\tint ret;\n\n\tret = mtk_nor_setup_write_buffer(sp, false);\n\tif (ret < 0)\n\t\treturn ret;\n\twriteb(buf[0], sp->base + MTK_NOR_REG_WDATA);\n\treturn mtk_nor_cmd_exec(sp, MTK_NOR_CMD_WRITE, 6 * BITS_PER_BYTE);\n}\n\nstatic int mtk_nor_spi_mem_prg(struct mtk_nor *sp, const struct spi_mem_op *op)\n{\n\tint rx_len = 0;\n\tint reg_offset = MTK_NOR_REG_PRGDATA_MAX;\n\tint tx_len, prg_len;\n\tint i, ret;\n\tvoid __iomem *reg;\n\tu8 bufbyte;\n\n\ttx_len = op->cmd.nbytes + op->addr.nbytes;\n\n\t\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\ttx_len += op->dummy.nbytes + op->data.nbytes;\n\telse if (op->data.dir == SPI_MEM_DATA_IN)\n\t\trx_len = op->data.nbytes;\n\n\tprg_len = op->cmd.nbytes + op->addr.nbytes + op->dummy.nbytes +\n\t\t  op->data.nbytes;\n\n\t\n\t\n\t\n\tif ((tx_len > MTK_NOR_REG_PRGDATA_MAX + 1) ||\n\t    (rx_len > MTK_NOR_REG_SHIFT_MAX + 1) ||\n\t    (prg_len > MTK_NOR_PRG_CNT_MAX / 8))\n\t\treturn -EINVAL;\n\n\t\n\tfor (i = op->cmd.nbytes; i > 0; i--, reg_offset--) {\n\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\tbufbyte = (op->cmd.opcode >> ((i - 1) * BITS_PER_BYTE)) & 0xff;\n\t\twriteb(bufbyte, reg);\n\t}\n\n\tfor (i = op->addr.nbytes; i > 0; i--, reg_offset--) {\n\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\tbufbyte = (op->addr.val >> ((i - 1) * BITS_PER_BYTE)) & 0xff;\n\t\twriteb(bufbyte, reg);\n\t}\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\tfor (i = 0; i < op->dummy.nbytes; i++, reg_offset--) {\n\t\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\t\twriteb(0, reg);\n\t\t}\n\n\t\tfor (i = 0; i < op->data.nbytes; i++, reg_offset--) {\n\t\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\t\twriteb(((const u8 *)(op->data.buf.out))[i], reg);\n\t\t}\n\t}\n\n\tfor (; reg_offset >= 0; reg_offset--) {\n\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\twriteb(0, reg);\n\t}\n\n\t\n\tif (rx_len)\n\t\twritel(prg_len * BITS_PER_BYTE + sp->caps->extra_dummy_bit,\n\t\t       sp->base + MTK_NOR_REG_PRG_CNT);\n\telse\n\t\twritel(prg_len * BITS_PER_BYTE, sp->base + MTK_NOR_REG_PRG_CNT);\n\n\tret = mtk_nor_cmd_exec(sp, MTK_NOR_CMD_PROGRAM,\n\t\t\t       prg_len * BITS_PER_BYTE);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\treg_offset = 0;\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tfor (i = op->data.nbytes - 1; i >= 0; i--, reg_offset++) {\n\t\t\treg = sp->base + MTK_NOR_REG_SHIFT(reg_offset);\n\t\t\t((u8 *)(op->data.buf.in))[i] = readb(reg);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_nor_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct mtk_nor *sp = spi_controller_get_devdata(mem->spi->master);\n\tint ret;\n\n\tif ((op->data.nbytes == 0) ||\n\t    ((op->addr.nbytes != 3) && (op->addr.nbytes != 4)))\n\t\treturn mtk_nor_spi_mem_prg(sp, op);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\tmtk_nor_set_addr(sp, op);\n\t\twriteb(op->cmd.opcode, sp->base + MTK_NOR_REG_PRGDATA0);\n\t\tif (op->data.nbytes == MTK_NOR_PP_SIZE)\n\t\t\treturn mtk_nor_pp_buffered(sp, op);\n\t\treturn mtk_nor_pp_unbuffered(sp, op);\n\t}\n\n\tif ((op->data.dir == SPI_MEM_DATA_IN) && mtk_nor_match_read(op)) {\n\t\tret = mtk_nor_setup_write_buffer(sp, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmtk_nor_setup_bus(sp, op);\n\t\tif (op->data.nbytes == 1) {\n\t\t\tmtk_nor_set_addr(sp, op);\n\t\t\treturn mtk_nor_read_pio(sp, op);\n\t\t} else {\n\t\t\tret = mtk_nor_read_dma(sp, op);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\t \n\t\t\t\tmtk_nor_reset(sp);\n\t\t\t\tmtk_nor_setup_bus(sp, op);\n\t\t\t\treturn mtk_nor_read_dma(sp, op);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn mtk_nor_spi_mem_prg(sp, op);\n}\n\nstatic int mtk_nor_setup(struct spi_device *spi)\n{\n\tstruct mtk_nor *sp = spi_controller_get_devdata(spi->master);\n\n\tif (spi->max_speed_hz && (spi->max_speed_hz < sp->spi_freq)) {\n\t\tdev_err(&spi->dev, \"spi clock should be %u Hz.\\n\",\n\t\t\tsp->spi_freq);\n\t\treturn -EINVAL;\n\t}\n\tspi->max_speed_hz = sp->spi_freq;\n\n\treturn 0;\n}\n\nstatic int mtk_nor_transfer_one_message(struct spi_controller *master,\n\t\t\t\t\tstruct spi_message *m)\n{\n\tstruct mtk_nor *sp = spi_controller_get_devdata(master);\n\tstruct spi_transfer *t = NULL;\n\tunsigned long trx_len = 0;\n\tint stat = 0;\n\tint reg_offset = MTK_NOR_REG_PRGDATA_MAX;\n\tvoid __iomem *reg;\n\tconst u8 *txbuf;\n\tu8 *rxbuf;\n\tint i;\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\ttxbuf = t->tx_buf;\n\t\tfor (i = 0; i < t->len; i++, reg_offset--) {\n\t\t\treg = sp->base + MTK_NOR_REG_PRGDATA(reg_offset);\n\t\t\tif (txbuf)\n\t\t\t\twriteb(txbuf[i], reg);\n\t\t\telse\n\t\t\t\twriteb(0, reg);\n\t\t}\n\t\ttrx_len += t->len;\n\t}\n\n\twritel(trx_len * BITS_PER_BYTE, sp->base + MTK_NOR_REG_PRG_CNT);\n\n\tstat = mtk_nor_cmd_exec(sp, MTK_NOR_CMD_PROGRAM,\n\t\t\t\ttrx_len * BITS_PER_BYTE);\n\tif (stat < 0)\n\t\tgoto msg_done;\n\n\treg_offset = trx_len - 1;\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\trxbuf = t->rx_buf;\n\t\tfor (i = 0; i < t->len; i++, reg_offset--) {\n\t\t\treg = sp->base + MTK_NOR_REG_SHIFT(reg_offset);\n\t\t\tif (rxbuf)\n\t\t\t\trxbuf[i] = readb(reg);\n\t\t}\n\t}\n\n\tm->actual_length = trx_len;\nmsg_done:\n\tm->status = stat;\n\tspi_finalize_current_message(master);\n\n\treturn 0;\n}\n\nstatic void mtk_nor_disable_clk(struct mtk_nor *sp)\n{\n\tclk_disable_unprepare(sp->spi_clk);\n\tclk_disable_unprepare(sp->ctlr_clk);\n\tclk_disable_unprepare(sp->axi_clk);\n\tclk_disable_unprepare(sp->axi_s_clk);\n}\n\nstatic int mtk_nor_enable_clk(struct mtk_nor *sp)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(sp->spi_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(sp->ctlr_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(sp->spi_clk);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(sp->axi_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(sp->spi_clk);\n\t\tclk_disable_unprepare(sp->ctlr_clk);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(sp->axi_s_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(sp->spi_clk);\n\t\tclk_disable_unprepare(sp->ctlr_clk);\n\t\tclk_disable_unprepare(sp->axi_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_nor_init(struct mtk_nor *sp)\n{\n\twritel(0, sp->base + MTK_NOR_REG_IRQ_EN);\n\twritel(MTK_NOR_IRQ_MASK, sp->base + MTK_NOR_REG_IRQ_STAT);\n\n\twritel(MTK_NOR_ENABLE_SF_CMD, sp->base + MTK_NOR_REG_WP);\n\tmtk_nor_rmw(sp, MTK_NOR_REG_CFG2, MTK_NOR_WR_CUSTOM_OP_EN, 0);\n\tmtk_nor_rmw(sp, MTK_NOR_REG_CFG3,\n\t\t    MTK_NOR_DISABLE_WREN | MTK_NOR_DISABLE_SR_POLL, 0);\n}\n\nstatic irqreturn_t mtk_nor_irq_handler(int irq, void *data)\n{\n\tstruct mtk_nor *sp = data;\n\tu32 irq_status, irq_enabled;\n\n\tirq_status = readl(sp->base + MTK_NOR_REG_IRQ_STAT);\n\tirq_enabled = readl(sp->base + MTK_NOR_REG_IRQ_EN);\n\t\n\twritel(irq_status, sp->base + MTK_NOR_REG_IRQ_STAT);\n\n\tif (!(irq_status & irq_enabled))\n\t\treturn IRQ_NONE;\n\n\tif (irq_status & MTK_NOR_IRQ_DMA) {\n\t\tcomplete(&sp->op_done);\n\t\twritel(0, sp->base + MTK_NOR_REG_IRQ_EN);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic size_t mtk_max_msg_size(struct spi_device *spi)\n{\n\treturn MTK_NOR_PRG_MAX_SIZE;\n}\n\nstatic const struct spi_controller_mem_ops mtk_nor_mem_ops = {\n\t.adjust_op_size = mtk_nor_adjust_op_size,\n\t.supports_op = mtk_nor_supports_op,\n\t.exec_op = mtk_nor_exec_op\n};\n\nstatic const struct mtk_nor_caps mtk_nor_caps_mt8173 = {\n\t.dma_bits = 32,\n\t.extra_dummy_bit = 0,\n};\n\nstatic const struct mtk_nor_caps mtk_nor_caps_mt8186 = {\n\t.dma_bits = 32,\n\t.extra_dummy_bit = 1,\n};\n\nstatic const struct mtk_nor_caps mtk_nor_caps_mt8192 = {\n\t.dma_bits = 36,\n\t.extra_dummy_bit = 0,\n};\n\nstatic const struct of_device_id mtk_nor_match[] = {\n\t{ .compatible = \"mediatek,mt8173-nor\", .data = &mtk_nor_caps_mt8173 },\n\t{ .compatible = \"mediatek,mt8186-nor\", .data = &mtk_nor_caps_mt8186 },\n\t{ .compatible = \"mediatek,mt8192-nor\", .data = &mtk_nor_caps_mt8192 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mtk_nor_match);\n\nstatic int mtk_nor_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct mtk_nor *sp;\n\tstruct mtk_nor_caps *caps;\n\tvoid __iomem *base;\n\tstruct clk *spi_clk, *ctlr_clk, *axi_clk, *axi_s_clk;\n\tint ret, irq;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tspi_clk = devm_clk_get(&pdev->dev, \"spi\");\n\tif (IS_ERR(spi_clk))\n\t\treturn PTR_ERR(spi_clk);\n\n\tctlr_clk = devm_clk_get(&pdev->dev, \"sf\");\n\tif (IS_ERR(ctlr_clk))\n\t\treturn PTR_ERR(ctlr_clk);\n\n\taxi_clk = devm_clk_get_optional(&pdev->dev, \"axi\");\n\tif (IS_ERR(axi_clk))\n\t\treturn PTR_ERR(axi_clk);\n\n\taxi_s_clk = devm_clk_get_optional(&pdev->dev, \"axi_s\");\n\tif (IS_ERR(axi_s_clk))\n\t\treturn PTR_ERR(axi_s_clk);\n\n\tcaps = (struct mtk_nor_caps *)of_device_get_match_data(&pdev->dev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(caps->dma_bits));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to set dma mask(%u)\\n\", caps->dma_bits);\n\t\treturn ret;\n\t}\n\n\tctlr = devm_spi_alloc_master(&pdev->dev, sizeof(*sp));\n\tif (!ctlr) {\n\t\tdev_err(&pdev->dev, \"failed to allocate spi controller\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->max_message_size = mtk_max_msg_size;\n\tctlr->mem_ops = &mtk_nor_mem_ops;\n\tctlr->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_DUAL | SPI_TX_QUAD;\n\tctlr->num_chipselect = 1;\n\tctlr->setup = mtk_nor_setup;\n\tctlr->transfer_one_message = mtk_nor_transfer_one_message;\n\tctlr->auto_runtime_pm = true;\n\n\tdev_set_drvdata(&pdev->dev, ctlr);\n\n\tsp = spi_controller_get_devdata(ctlr);\n\tsp->base = base;\n\tsp->has_irq = false;\n\tsp->wbuf_en = false;\n\tsp->ctlr = ctlr;\n\tsp->dev = &pdev->dev;\n\tsp->spi_clk = spi_clk;\n\tsp->ctlr_clk = ctlr_clk;\n\tsp->axi_clk = axi_clk;\n\tsp->axi_s_clk = axi_s_clk;\n\tsp->caps = caps;\n\tsp->high_dma = caps->dma_bits > 32;\n\tsp->buffer = dmam_alloc_coherent(&pdev->dev,\n\t\t\t\tMTK_NOR_BOUNCE_BUF_SIZE + MTK_NOR_DMA_ALIGN,\n\t\t\t\t&sp->buffer_dma, GFP_KERNEL);\n\tif (!sp->buffer)\n\t\treturn -ENOMEM;\n\n\tif ((uintptr_t)sp->buffer & MTK_NOR_DMA_ALIGN_MASK) {\n\t\tdev_err(sp->dev, \"misaligned allocation of internal buffer.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = mtk_nor_enable_clk(sp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsp->spi_freq = clk_get_rate(sp->spi_clk);\n\n\tmtk_nor_init(sp);\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\n\tif (irq < 0) {\n\t\tdev_warn(sp->dev, \"IRQ not available.\");\n\t} else {\n\t\tret = devm_request_irq(sp->dev, irq, mtk_nor_irq_handler, 0,\n\t\t\t\t       pdev->name, sp);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(sp->dev, \"failed to request IRQ.\");\n\t\t} else {\n\t\t\tinit_completion(&sp->op_done);\n\t\t\tsp->has_irq = true;\n\t\t}\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, -1);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret < 0)\n\t\tgoto err_probe;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tdev_info(&pdev->dev, \"spi frequency: %d Hz\\n\", sp->spi_freq);\n\n\treturn 0;\n\nerr_probe:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\tmtk_nor_disable_clk(sp);\n\n\treturn ret;\n}\n\nstatic void mtk_nor_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(&pdev->dev);\n\tstruct mtk_nor *sp = spi_controller_get_devdata(ctlr);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\tmtk_nor_disable_clk(sp);\n}\n\nstatic int __maybe_unused mtk_nor_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_nor *sp = spi_controller_get_devdata(ctlr);\n\n\tmtk_nor_disable_clk(sp);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk_nor_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_nor *sp = spi_controller_get_devdata(ctlr);\n\n\treturn mtk_nor_enable_clk(sp);\n}\n\nstatic int __maybe_unused mtk_nor_suspend(struct device *dev)\n{\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused mtk_nor_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct mtk_nor *sp = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_nor_init(sp);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk_nor_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mtk_nor_runtime_suspend,\n\t\t\t   mtk_nor_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(mtk_nor_suspend, mtk_nor_resume)\n};\n\nstatic struct platform_driver mtk_nor_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = mtk_nor_match,\n\t\t.pm = &mtk_nor_pm_ops,\n\t},\n\t.probe = mtk_nor_probe,\n\t.remove_new = mtk_nor_remove,\n};\n\nmodule_platform_driver(mtk_nor_driver);\n\nMODULE_DESCRIPTION(\"Mediatek SPI NOR controller driver\");\nMODULE_AUTHOR(\"Chuanhong Guo <gch981213@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}