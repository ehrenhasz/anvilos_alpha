{
  "module_name": "spi-dw-core.c",
  "hash_id": "e17112e8af7a846729fca7cd49354faa3d7b1e61f50c18964d7dac98ce456d06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-dw-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/highmem.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/string.h>\n#include <linux/of.h>\n\n#include \"spi-dw.h\"\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n#endif\n\n \nstruct dw_spi_chip_data {\n\tu32 cr0;\n\tu32 rx_sample_dly;\t \n};\n\n#ifdef CONFIG_DEBUG_FS\n\n#define DW_SPI_DBGFS_REG(_name, _off)\t\\\n{\t\t\t\t\t\\\n\t.name = _name,\t\t\t\\\n\t.offset = _off,\t\t\t\\\n}\n\nstatic const struct debugfs_reg32 dw_spi_dbgfs_regs[] = {\n\tDW_SPI_DBGFS_REG(\"CTRLR0\", DW_SPI_CTRLR0),\n\tDW_SPI_DBGFS_REG(\"CTRLR1\", DW_SPI_CTRLR1),\n\tDW_SPI_DBGFS_REG(\"SSIENR\", DW_SPI_SSIENR),\n\tDW_SPI_DBGFS_REG(\"SER\", DW_SPI_SER),\n\tDW_SPI_DBGFS_REG(\"BAUDR\", DW_SPI_BAUDR),\n\tDW_SPI_DBGFS_REG(\"TXFTLR\", DW_SPI_TXFTLR),\n\tDW_SPI_DBGFS_REG(\"RXFTLR\", DW_SPI_RXFTLR),\n\tDW_SPI_DBGFS_REG(\"TXFLR\", DW_SPI_TXFLR),\n\tDW_SPI_DBGFS_REG(\"RXFLR\", DW_SPI_RXFLR),\n\tDW_SPI_DBGFS_REG(\"SR\", DW_SPI_SR),\n\tDW_SPI_DBGFS_REG(\"IMR\", DW_SPI_IMR),\n\tDW_SPI_DBGFS_REG(\"ISR\", DW_SPI_ISR),\n\tDW_SPI_DBGFS_REG(\"DMACR\", DW_SPI_DMACR),\n\tDW_SPI_DBGFS_REG(\"DMATDLR\", DW_SPI_DMATDLR),\n\tDW_SPI_DBGFS_REG(\"DMARDLR\", DW_SPI_DMARDLR),\n\tDW_SPI_DBGFS_REG(\"RX_SAMPLE_DLY\", DW_SPI_RX_SAMPLE_DLY),\n};\n\nstatic void dw_spi_debugfs_init(struct dw_spi *dws)\n{\n\tchar name[32];\n\n\tsnprintf(name, 32, \"dw_spi%d\", dws->host->bus_num);\n\tdws->debugfs = debugfs_create_dir(name, NULL);\n\n\tdws->regset.regs = dw_spi_dbgfs_regs;\n\tdws->regset.nregs = ARRAY_SIZE(dw_spi_dbgfs_regs);\n\tdws->regset.base = dws->regs;\n\tdebugfs_create_regset32(\"registers\", 0400, dws->debugfs, &dws->regset);\n}\n\nstatic void dw_spi_debugfs_remove(struct dw_spi *dws)\n{\n\tdebugfs_remove_recursive(dws->debugfs);\n}\n\n#else\nstatic inline void dw_spi_debugfs_init(struct dw_spi *dws)\n{\n}\n\nstatic inline void dw_spi_debugfs_remove(struct dw_spi *dws)\n{\n}\n#endif  \n\nvoid dw_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\tbool cs_high = !!(spi->mode & SPI_CS_HIGH);\n\n\t \n\tif (cs_high == enable)\n\t\tdw_writel(dws, DW_SPI_SER, BIT(spi_get_chipselect(spi, 0)));\n\telse\n\t\tdw_writel(dws, DW_SPI_SER, 0);\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_set_cs, SPI_DW_CORE);\n\n \nstatic inline u32 dw_spi_tx_max(struct dw_spi *dws)\n{\n\tu32 tx_room, rxtx_gap;\n\n\ttx_room = dws->fifo_len - dw_readl(dws, DW_SPI_TXFLR);\n\n\t \n\trxtx_gap = dws->fifo_len - (dws->rx_len - dws->tx_len);\n\n\treturn min3((u32)dws->tx_len, tx_room, rxtx_gap);\n}\n\n \nstatic inline u32 dw_spi_rx_max(struct dw_spi *dws)\n{\n\treturn min_t(u32, dws->rx_len, dw_readl(dws, DW_SPI_RXFLR));\n}\n\nstatic void dw_writer(struct dw_spi *dws)\n{\n\tu32 max = dw_spi_tx_max(dws);\n\tu32 txw = 0;\n\n\twhile (max--) {\n\t\tif (dws->tx) {\n\t\t\tif (dws->n_bytes == 1)\n\t\t\t\ttxw = *(u8 *)(dws->tx);\n\t\t\telse if (dws->n_bytes == 2)\n\t\t\t\ttxw = *(u16 *)(dws->tx);\n\t\t\telse\n\t\t\t\ttxw = *(u32 *)(dws->tx);\n\n\t\t\tdws->tx += dws->n_bytes;\n\t\t}\n\t\tdw_write_io_reg(dws, DW_SPI_DR, txw);\n\t\t--dws->tx_len;\n\t}\n}\n\nstatic void dw_reader(struct dw_spi *dws)\n{\n\tu32 max = dw_spi_rx_max(dws);\n\tu32 rxw;\n\n\twhile (max--) {\n\t\trxw = dw_read_io_reg(dws, DW_SPI_DR);\n\t\tif (dws->rx) {\n\t\t\tif (dws->n_bytes == 1)\n\t\t\t\t*(u8 *)(dws->rx) = rxw;\n\t\t\telse if (dws->n_bytes == 2)\n\t\t\t\t*(u16 *)(dws->rx) = rxw;\n\t\t\telse\n\t\t\t\t*(u32 *)(dws->rx) = rxw;\n\n\t\t\tdws->rx += dws->n_bytes;\n\t\t}\n\t\t--dws->rx_len;\n\t}\n}\n\nint dw_spi_check_status(struct dw_spi *dws, bool raw)\n{\n\tu32 irq_status;\n\tint ret = 0;\n\n\tif (raw)\n\t\tirq_status = dw_readl(dws, DW_SPI_RISR);\n\telse\n\t\tirq_status = dw_readl(dws, DW_SPI_ISR);\n\n\tif (irq_status & DW_SPI_INT_RXOI) {\n\t\tdev_err(&dws->host->dev, \"RX FIFO overflow detected\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (irq_status & DW_SPI_INT_RXUI) {\n\t\tdev_err(&dws->host->dev, \"RX FIFO underflow detected\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (irq_status & DW_SPI_INT_TXOI) {\n\t\tdev_err(&dws->host->dev, \"TX FIFO overflow detected\\n\");\n\t\tret = -EIO;\n\t}\n\n\t \n\tif (ret) {\n\t\tdw_spi_reset_chip(dws);\n\t\tif (dws->host->cur_msg)\n\t\t\tdws->host->cur_msg->status = ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_check_status, SPI_DW_CORE);\n\nstatic irqreturn_t dw_spi_transfer_handler(struct dw_spi *dws)\n{\n\tu16 irq_status = dw_readl(dws, DW_SPI_ISR);\n\n\tif (dw_spi_check_status(dws, false)) {\n\t\tspi_finalize_current_transfer(dws->host);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tdw_reader(dws);\n\tif (!dws->rx_len) {\n\t\tdw_spi_mask_intr(dws, 0xff);\n\t\tspi_finalize_current_transfer(dws->host);\n\t} else if (dws->rx_len <= dw_readl(dws, DW_SPI_RXFTLR)) {\n\t\tdw_writel(dws, DW_SPI_RXFTLR, dws->rx_len - 1);\n\t}\n\n\t \n\tif (irq_status & DW_SPI_INT_TXEI) {\n\t\tdw_writer(dws);\n\t\tif (!dws->tx_len)\n\t\t\tdw_spi_mask_intr(dws, DW_SPI_INT_TXEI);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dw_spi_irq(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = dev_id;\n\tstruct dw_spi *dws = spi_controller_get_devdata(host);\n\tu16 irq_status = dw_readl(dws, DW_SPI_ISR) & DW_SPI_INT_MASK;\n\n\tif (!irq_status)\n\t\treturn IRQ_NONE;\n\n\tif (!host->cur_msg) {\n\t\tdw_spi_mask_intr(dws, 0xff);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn dws->transfer_handler(dws);\n}\n\nstatic u32 dw_spi_prepare_cr0(struct dw_spi *dws, struct spi_device *spi)\n{\n\tu32 cr0 = 0;\n\n\tif (dw_spi_ip_is(dws, PSSI)) {\n\t\t \n\t\tcr0 |= FIELD_PREP(DW_PSSI_CTRLR0_FRF_MASK, DW_SPI_CTRLR0_FRF_MOTO_SPI);\n\n\t\t \n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tcr0 |= DW_PSSI_CTRLR0_SCPOL;\n\t\tif (spi->mode & SPI_CPHA)\n\t\t\tcr0 |= DW_PSSI_CTRLR0_SCPHA;\n\n\t\t \n\t\tif (spi->mode & SPI_LOOP)\n\t\t\tcr0 |= DW_PSSI_CTRLR0_SRL;\n\t} else {\n\t\t \n\t\tcr0 |= FIELD_PREP(DW_HSSI_CTRLR0_FRF_MASK, DW_SPI_CTRLR0_FRF_MOTO_SPI);\n\n\t\t \n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tcr0 |= DW_HSSI_CTRLR0_SCPOL;\n\t\tif (spi->mode & SPI_CPHA)\n\t\t\tcr0 |= DW_HSSI_CTRLR0_SCPHA;\n\n\t\t \n\t\tif (spi->mode & SPI_LOOP)\n\t\t\tcr0 |= DW_HSSI_CTRLR0_SRL;\n\n\t\t \n\t\tif (dw_spi_ver_is_ge(dws, HSSI, 102A))\n\t\t\tcr0 |= DW_HSSI_CTRLR0_MST;\n\t}\n\n\treturn cr0;\n}\n\nvoid dw_spi_update_config(struct dw_spi *dws, struct spi_device *spi,\n\t\t\t  struct dw_spi_cfg *cfg)\n{\n\tstruct dw_spi_chip_data *chip = spi_get_ctldata(spi);\n\tu32 cr0 = chip->cr0;\n\tu32 speed_hz;\n\tu16 clk_div;\n\n\t \n\tcr0 |= (cfg->dfs - 1) << dws->dfs_offset;\n\n\tif (dw_spi_ip_is(dws, PSSI))\n\t\t \n\t\tcr0 |= FIELD_PREP(DW_PSSI_CTRLR0_TMOD_MASK, cfg->tmode);\n\telse\n\t\t \n\t\tcr0 |= FIELD_PREP(DW_HSSI_CTRLR0_TMOD_MASK, cfg->tmode);\n\n\tdw_writel(dws, DW_SPI_CTRLR0, cr0);\n\n\tif (cfg->tmode == DW_SPI_CTRLR0_TMOD_EPROMREAD ||\n\t    cfg->tmode == DW_SPI_CTRLR0_TMOD_RO)\n\t\tdw_writel(dws, DW_SPI_CTRLR1, cfg->ndf ? cfg->ndf - 1 : 0);\n\n\t \n\tclk_div = (DIV_ROUND_UP(dws->max_freq, cfg->freq) + 1) & 0xfffe;\n\tspeed_hz = dws->max_freq / clk_div;\n\n\tif (dws->current_freq != speed_hz) {\n\t\tdw_spi_set_clk(dws, clk_div);\n\t\tdws->current_freq = speed_hz;\n\t}\n\n\t \n\tif (dws->cur_rx_sample_dly != chip->rx_sample_dly) {\n\t\tdw_writel(dws, DW_SPI_RX_SAMPLE_DLY, chip->rx_sample_dly);\n\t\tdws->cur_rx_sample_dly = chip->rx_sample_dly;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_update_config, SPI_DW_CORE);\n\nstatic void dw_spi_irq_setup(struct dw_spi *dws)\n{\n\tu16 level;\n\tu8 imask;\n\n\t \n\tlevel = min_t(unsigned int, dws->fifo_len / 2, dws->tx_len);\n\tdw_writel(dws, DW_SPI_TXFTLR, level);\n\tdw_writel(dws, DW_SPI_RXFTLR, level - 1);\n\n\tdws->transfer_handler = dw_spi_transfer_handler;\n\n\timask = DW_SPI_INT_TXEI | DW_SPI_INT_TXOI |\n\t\tDW_SPI_INT_RXUI | DW_SPI_INT_RXOI | DW_SPI_INT_RXFI;\n\tdw_spi_umask_intr(dws, imask);\n}\n\n \nstatic int dw_spi_poll_transfer(struct dw_spi *dws,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct spi_delay delay;\n\tu16 nbits;\n\tint ret;\n\n\tdelay.unit = SPI_DELAY_UNIT_SCK;\n\tnbits = dws->n_bytes * BITS_PER_BYTE;\n\n\tdo {\n\t\tdw_writer(dws);\n\n\t\tdelay.value = nbits * (dws->rx_len - dws->tx_len);\n\t\tspi_delay_exec(&delay, transfer);\n\n\t\tdw_reader(dws);\n\n\t\tret = dw_spi_check_status(dws, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (dws->rx_len);\n\n\treturn 0;\n}\n\nstatic int dw_spi_transfer_one(struct spi_controller *host,\n\t\t\t       struct spi_device *spi,\n\t\t\t       struct spi_transfer *transfer)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(host);\n\tstruct dw_spi_cfg cfg = {\n\t\t.tmode = DW_SPI_CTRLR0_TMOD_TR,\n\t\t.dfs = transfer->bits_per_word,\n\t\t.freq = transfer->speed_hz,\n\t};\n\tint ret;\n\n\tdws->dma_mapped = 0;\n\tdws->n_bytes =\n\t\troundup_pow_of_two(DIV_ROUND_UP(transfer->bits_per_word,\n\t\t\t\t\t\tBITS_PER_BYTE));\n\n\tdws->tx = (void *)transfer->tx_buf;\n\tdws->tx_len = transfer->len / dws->n_bytes;\n\tdws->rx = transfer->rx_buf;\n\tdws->rx_len = dws->tx_len;\n\n\t \n\tsmp_mb();\n\n\tdw_spi_enable_chip(dws, 0);\n\n\tdw_spi_update_config(dws, spi, &cfg);\n\n\ttransfer->effective_speed_hz = dws->current_freq;\n\n\t \n\tif (host->can_dma && host->can_dma(host, spi, transfer))\n\t\tdws->dma_mapped = host->cur_msg_mapped;\n\n\t \n\tdw_spi_mask_intr(dws, 0xff);\n\n\tif (dws->dma_mapped) {\n\t\tret = dws->dma_ops->dma_setup(dws, transfer);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdw_spi_enable_chip(dws, 1);\n\n\tif (dws->dma_mapped)\n\t\treturn dws->dma_ops->dma_transfer(dws, transfer);\n\telse if (dws->irq == IRQ_NOTCONNECTED)\n\t\treturn dw_spi_poll_transfer(dws, transfer);\n\n\tdw_spi_irq_setup(dws);\n\n\treturn 1;\n}\n\nstatic void dw_spi_handle_err(struct spi_controller *host,\n\t\t\t      struct spi_message *msg)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(host);\n\n\tif (dws->dma_mapped)\n\t\tdws->dma_ops->dma_stop(dws);\n\n\tdw_spi_reset_chip(dws);\n}\n\nstatic int dw_spi_adjust_mem_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\top->data.nbytes = clamp_val(op->data.nbytes, 0, DW_SPI_NDF_MASK + 1);\n\n\treturn 0;\n}\n\nstatic bool dw_spi_supports_mem_op(struct spi_mem *mem,\n\t\t\t\t   const struct spi_mem_op *op)\n{\n\tif (op->data.buswidth > 1 || op->addr.buswidth > 1 ||\n\t    op->dummy.buswidth > 1 || op->cmd.buswidth > 1)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic int dw_spi_init_mem_buf(struct dw_spi *dws, const struct spi_mem_op *op)\n{\n\tunsigned int i, j, len;\n\tu8 *out;\n\n\t \n\tlen = op->cmd.nbytes + op->addr.nbytes + op->dummy.nbytes;\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\tlen += op->data.nbytes;\n\n\tif (len <= DW_SPI_BUF_SIZE) {\n\t\tout = dws->buf;\n\t} else {\n\t\tout = kzalloc(len, GFP_KERNEL);\n\t\tif (!out)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < op->cmd.nbytes; ++i)\n\t\tout[i] = DW_SPI_GET_BYTE(op->cmd.opcode, op->cmd.nbytes - i - 1);\n\tfor (j = 0; j < op->addr.nbytes; ++i, ++j)\n\t\tout[i] = DW_SPI_GET_BYTE(op->addr.val, op->addr.nbytes - j - 1);\n\tfor (j = 0; j < op->dummy.nbytes; ++i, ++j)\n\t\tout[i] = 0x0;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\tmemcpy(&out[i], op->data.buf.out, op->data.nbytes);\n\n\tdws->n_bytes = 1;\n\tdws->tx = out;\n\tdws->tx_len = len;\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tdws->rx = op->data.buf.in;\n\t\tdws->rx_len = op->data.nbytes;\n\t} else {\n\t\tdws->rx = NULL;\n\t\tdws->rx_len = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_spi_free_mem_buf(struct dw_spi *dws)\n{\n\tif (dws->tx != dws->buf)\n\t\tkfree(dws->tx);\n}\n\nstatic int dw_spi_write_then_read(struct dw_spi *dws, struct spi_device *spi)\n{\n\tu32 room, entries, sts;\n\tunsigned int len;\n\tu8 *buf;\n\n\t \n\tlen = min(dws->fifo_len, dws->tx_len);\n\tbuf = dws->tx;\n\twhile (len--)\n\t\tdw_write_io_reg(dws, DW_SPI_DR, *buf++);\n\n\t \n\tlen = dws->tx_len - ((void *)buf - dws->tx);\n\tdw_spi_set_cs(spi, false);\n\twhile (len) {\n\t\tentries = readl_relaxed(dws->regs + DW_SPI_TXFLR);\n\t\tif (!entries) {\n\t\t\tdev_err(&dws->host->dev, \"CS de-assertion on Tx\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\troom = min(dws->fifo_len - entries, len);\n\t\tfor (; room; --room, --len)\n\t\t\tdw_write_io_reg(dws, DW_SPI_DR, *buf++);\n\t}\n\n\t \n\tlen = dws->rx_len;\n\tbuf = dws->rx;\n\twhile (len) {\n\t\tentries = readl_relaxed(dws->regs + DW_SPI_RXFLR);\n\t\tif (!entries) {\n\t\t\tsts = readl_relaxed(dws->regs + DW_SPI_RISR);\n\t\t\tif (sts & DW_SPI_INT_RXOI) {\n\t\t\t\tdev_err(&dws->host->dev, \"FIFO overflow on Rx\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tentries = min(entries, len);\n\t\tfor (; entries; --entries, --len)\n\t\t\t*buf++ = dw_read_io_reg(dws, DW_SPI_DR);\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool dw_spi_ctlr_busy(struct dw_spi *dws)\n{\n\treturn dw_readl(dws, DW_SPI_SR) & DW_SPI_SR_BUSY;\n}\n\nstatic int dw_spi_wait_mem_op_done(struct dw_spi *dws)\n{\n\tint retry = DW_SPI_WAIT_RETRIES;\n\tstruct spi_delay delay;\n\tunsigned long ns, us;\n\tu32 nents;\n\n\tnents = dw_readl(dws, DW_SPI_TXFLR);\n\tns = NSEC_PER_SEC / dws->current_freq * nents;\n\tns *= dws->n_bytes * BITS_PER_BYTE;\n\tif (ns <= NSEC_PER_USEC) {\n\t\tdelay.unit = SPI_DELAY_UNIT_NSECS;\n\t\tdelay.value = ns;\n\t} else {\n\t\tus = DIV_ROUND_UP(ns, NSEC_PER_USEC);\n\t\tdelay.unit = SPI_DELAY_UNIT_USECS;\n\t\tdelay.value = clamp_val(us, 0, USHRT_MAX);\n\t}\n\n\twhile (dw_spi_ctlr_busy(dws) && retry--)\n\t\tspi_delay_exec(&delay, NULL);\n\n\tif (retry < 0) {\n\t\tdev_err(&dws->host->dev, \"Mem op hanged up\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_spi_stop_mem_op(struct dw_spi *dws, struct spi_device *spi)\n{\n\tdw_spi_enable_chip(dws, 0);\n\tdw_spi_set_cs(spi, true);\n\tdw_spi_enable_chip(dws, 1);\n}\n\n \nstatic int dw_spi_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(mem->spi->controller);\n\tstruct dw_spi_cfg cfg;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tret = dw_spi_init_mem_buf(dws, op);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcfg.dfs = 8;\n\tcfg.freq = clamp(mem->spi->max_speed_hz, 0U, dws->max_mem_freq);\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tcfg.tmode = DW_SPI_CTRLR0_TMOD_EPROMREAD;\n\t\tcfg.ndf = op->data.nbytes;\n\t} else {\n\t\tcfg.tmode = DW_SPI_CTRLR0_TMOD_TO;\n\t}\n\n\tdw_spi_enable_chip(dws, 0);\n\n\tdw_spi_update_config(dws, mem->spi, &cfg);\n\n\tdw_spi_mask_intr(dws, 0xff);\n\n\tdw_spi_enable_chip(dws, 1);\n\n\t \n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\tret = dw_spi_write_then_read(dws, mem->spi);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\t \n\tif (!ret) {\n\t\tret = dw_spi_wait_mem_op_done(dws);\n\t\tif (!ret)\n\t\t\tret = dw_spi_check_status(dws, true);\n\t}\n\n\tdw_spi_stop_mem_op(dws, mem->spi);\n\n\tdw_spi_free_mem_buf(dws);\n\n\treturn ret;\n}\n\n \nstatic void dw_spi_init_mem_ops(struct dw_spi *dws)\n{\n\tif (!dws->mem_ops.exec_op && !(dws->caps & DW_SPI_CAP_CS_OVERRIDE) &&\n\t    !dws->set_cs) {\n\t\tdws->mem_ops.adjust_op_size = dw_spi_adjust_mem_op_size;\n\t\tdws->mem_ops.supports_op = dw_spi_supports_mem_op;\n\t\tdws->mem_ops.exec_op = dw_spi_exec_mem_op;\n\t\tif (!dws->max_mem_freq)\n\t\t\tdws->max_mem_freq = dws->max_freq;\n\t}\n}\n\n \nstatic int dw_spi_setup(struct spi_device *spi)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\tstruct dw_spi_chip_data *chip;\n\n\t \n\tchip = spi_get_ctldata(spi);\n\tif (!chip) {\n\t\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\t\tu32 rx_sample_dly_ns;\n\n\t\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\t\tspi_set_ctldata(spi, chip);\n\t\t \n\t\tif (device_property_read_u32(&spi->dev,\n\t\t\t\t\t     \"rx-sample-delay-ns\",\n\t\t\t\t\t     &rx_sample_dly_ns) != 0)\n\t\t\t \n\t\t\trx_sample_dly_ns = dws->def_rx_sample_dly_ns;\n\t\tchip->rx_sample_dly = DIV_ROUND_CLOSEST(rx_sample_dly_ns,\n\t\t\t\t\t\t\tNSEC_PER_SEC /\n\t\t\t\t\t\t\tdws->max_freq);\n\t}\n\n\t \n\tchip->cr0 = dw_spi_prepare_cr0(dws, spi);\n\n\treturn 0;\n}\n\nstatic void dw_spi_cleanup(struct spi_device *spi)\n{\n\tstruct dw_spi_chip_data *chip = spi_get_ctldata(spi);\n\n\tkfree(chip);\n\tspi_set_ctldata(spi, NULL);\n}\n\n \nstatic void dw_spi_hw_init(struct device *dev, struct dw_spi *dws)\n{\n\tdw_spi_reset_chip(dws);\n\n\t \n\tif (!dws->ver) {\n\t\tdws->ver = dw_readl(dws, DW_SPI_VERSION);\n\n\t\tdev_dbg(dev, \"Synopsys DWC%sSSI v%c.%c%c\\n\",\n\t\t\tdw_spi_ip_is(dws, PSSI) ? \" APB \" : \" \",\n\t\t\tDW_SPI_GET_BYTE(dws->ver, 3), DW_SPI_GET_BYTE(dws->ver, 2),\n\t\t\tDW_SPI_GET_BYTE(dws->ver, 1));\n\t}\n\n\t \n\tif (!dws->fifo_len) {\n\t\tu32 fifo;\n\n\t\tfor (fifo = 1; fifo < 256; fifo++) {\n\t\t\tdw_writel(dws, DW_SPI_TXFTLR, fifo);\n\t\t\tif (fifo != dw_readl(dws, DW_SPI_TXFTLR))\n\t\t\t\tbreak;\n\t\t}\n\t\tdw_writel(dws, DW_SPI_TXFTLR, 0);\n\n\t\tdws->fifo_len = (fifo == 1) ? 0 : fifo;\n\t\tdev_dbg(dev, \"Detected FIFO size: %u bytes\\n\", dws->fifo_len);\n\t}\n\n\t \n\tif (dw_spi_ip_is(dws, PSSI)) {\n\t\tu32 cr0, tmp = dw_readl(dws, DW_SPI_CTRLR0);\n\n\t\tdw_spi_enable_chip(dws, 0);\n\t\tdw_writel(dws, DW_SPI_CTRLR0, 0xffffffff);\n\t\tcr0 = dw_readl(dws, DW_SPI_CTRLR0);\n\t\tdw_writel(dws, DW_SPI_CTRLR0, tmp);\n\t\tdw_spi_enable_chip(dws, 1);\n\n\t\tif (!(cr0 & DW_PSSI_CTRLR0_DFS_MASK)) {\n\t\t\tdws->caps |= DW_SPI_CAP_DFS32;\n\t\t\tdws->dfs_offset = __bf_shf(DW_PSSI_CTRLR0_DFS32_MASK);\n\t\t\tdev_dbg(dev, \"Detected 32-bits max data frame size\\n\");\n\t\t}\n\t} else {\n\t\tdws->caps |= DW_SPI_CAP_DFS32;\n\t}\n\n\t \n\tif (dws->caps & DW_SPI_CAP_CS_OVERRIDE)\n\t\tdw_writel(dws, DW_SPI_CS_OVERRIDE, 0xF);\n}\n\nint dw_spi_add_host(struct device *dev, struct dw_spi *dws)\n{\n\tstruct spi_controller *host;\n\tint ret;\n\n\tif (!dws)\n\t\treturn -EINVAL;\n\n\thost = spi_alloc_host(dev, 0);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tdevice_set_node(&host->dev, dev_fwnode(dev));\n\n\tdws->host = host;\n\tdws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);\n\n\tspi_controller_set_devdata(host, dws);\n\n\t \n\tdw_spi_hw_init(dev, dws);\n\n\tret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev),\n\t\t\t  host);\n\tif (ret < 0 && ret != -ENOTCONN) {\n\t\tdev_err(dev, \"can not get IRQ\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\tdw_spi_init_mem_ops(dws);\n\n\thost->use_gpio_descriptors = true;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;\n\tif (dws->caps & DW_SPI_CAP_DFS32)\n\t\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\telse\n\t\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\n\thost->bus_num = dws->bus_num;\n\thost->num_chipselect = dws->num_cs;\n\thost->setup = dw_spi_setup;\n\thost->cleanup = dw_spi_cleanup;\n\tif (dws->set_cs)\n\t\thost->set_cs = dws->set_cs;\n\telse\n\t\thost->set_cs = dw_spi_set_cs;\n\thost->transfer_one = dw_spi_transfer_one;\n\thost->handle_err = dw_spi_handle_err;\n\tif (dws->mem_ops.exec_op)\n\t\thost->mem_ops = &dws->mem_ops;\n\thost->max_speed_hz = dws->max_freq;\n\thost->flags = SPI_CONTROLLER_GPIO_SS;\n\thost->auto_runtime_pm = true;\n\n\t \n\tdevice_property_read_u32(dev, \"rx-sample-delay-ns\",\n\t\t\t\t &dws->def_rx_sample_dly_ns);\n\n\tif (dws->dma_ops && dws->dma_ops->dma_init) {\n\t\tret = dws->dma_ops->dma_init(dev, dws);\n\t\tif (ret == -EPROBE_DEFER) {\n\t\t\tgoto err_free_irq;\n\t\t} else if (ret) {\n\t\t\tdev_warn(dev, \"DMA init failed\\n\");\n\t\t} else {\n\t\t\thost->can_dma = dws->dma_ops->can_dma;\n\t\t\thost->flags |= SPI_CONTROLLER_MUST_TX;\n\t\t}\n\t}\n\n\tret = spi_register_controller(host);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"problem registering spi host\\n\");\n\t\tgoto err_dma_exit;\n\t}\n\n\tdw_spi_debugfs_init(dws);\n\treturn 0;\n\nerr_dma_exit:\n\tif (dws->dma_ops && dws->dma_ops->dma_exit)\n\t\tdws->dma_ops->dma_exit(dws);\n\tdw_spi_enable_chip(dws, 0);\nerr_free_irq:\n\tfree_irq(dws->irq, host);\nerr_free_host:\n\tspi_controller_put(host);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_add_host, SPI_DW_CORE);\n\nvoid dw_spi_remove_host(struct dw_spi *dws)\n{\n\tdw_spi_debugfs_remove(dws);\n\n\tspi_unregister_controller(dws->host);\n\n\tif (dws->dma_ops && dws->dma_ops->dma_exit)\n\t\tdws->dma_ops->dma_exit(dws);\n\n\tdw_spi_shutdown_chip(dws);\n\n\tfree_irq(dws->irq, dws->host);\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_remove_host, SPI_DW_CORE);\n\nint dw_spi_suspend_host(struct dw_spi *dws)\n{\n\tint ret;\n\n\tret = spi_controller_suspend(dws->host);\n\tif (ret)\n\t\treturn ret;\n\n\tdw_spi_shutdown_chip(dws);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_suspend_host, SPI_DW_CORE);\n\nint dw_spi_resume_host(struct dw_spi *dws)\n{\n\tdw_spi_hw_init(&dws->host->dev, dws);\n\treturn spi_controller_resume(dws->host);\n}\nEXPORT_SYMBOL_NS_GPL(dw_spi_resume_host, SPI_DW_CORE);\n\nMODULE_AUTHOR(\"Feng Tang <feng.tang@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for DesignWare SPI controller core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}