{
  "module_name": "spi-mem.c",
  "hash_id": "4ea14603d3eccd257e5c87d75d288391858a34f07f358b373be181fed06abe42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mem.c",
  "human_readable_source": "\n \n#include <linux/dmaengine.h>\n#include <linux/iopoll.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/sched/task_stack.h>\n\n#include \"internals.h\"\n\n#define SPI_MEM_MAX_BUSWIDTH\t\t8\n\n \nint spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,\n\t\t\t\t       const struct spi_mem_op *op,\n\t\t\t\t       struct sg_table *sgt)\n{\n\tstruct device *dmadev;\n\n\tif (!op->data.nbytes)\n\t\treturn -EINVAL;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT && ctlr->dma_tx)\n\t\tdmadev = ctlr->dma_tx->device->dev;\n\telse if (op->data.dir == SPI_MEM_DATA_IN && ctlr->dma_rx)\n\t\tdmadev = ctlr->dma_rx->device->dev;\n\telse\n\t\tdmadev = ctlr->dev.parent;\n\n\tif (!dmadev)\n\t\treturn -EINVAL;\n\n\treturn spi_map_buf(ctlr, dmadev, sgt, op->data.buf.in, op->data.nbytes,\n\t\t\t   op->data.dir == SPI_MEM_DATA_IN ?\n\t\t\t   DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(spi_controller_dma_map_mem_op_data);\n\n \nvoid spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,\n\t\t\t\t\t  const struct spi_mem_op *op,\n\t\t\t\t\t  struct sg_table *sgt)\n{\n\tstruct device *dmadev;\n\n\tif (!op->data.nbytes)\n\t\treturn;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT && ctlr->dma_tx)\n\t\tdmadev = ctlr->dma_tx->device->dev;\n\telse if (op->data.dir == SPI_MEM_DATA_IN && ctlr->dma_rx)\n\t\tdmadev = ctlr->dma_rx->device->dev;\n\telse\n\t\tdmadev = ctlr->dev.parent;\n\n\tspi_unmap_buf(ctlr, dmadev, sgt,\n\t\t      op->data.dir == SPI_MEM_DATA_IN ?\n\t\t      DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(spi_controller_dma_unmap_mem_op_data);\n\nstatic int spi_check_buswidth_req(struct spi_mem *mem, u8 buswidth, bool tx)\n{\n\tu32 mode = mem->spi->mode;\n\n\tswitch (buswidth) {\n\tcase 1:\n\t\treturn 0;\n\n\tcase 2:\n\t\tif ((tx &&\n\t\t     (mode & (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL))) ||\n\t\t    (!tx &&\n\t\t     (mode & (SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL))))\n\t\t\treturn 0;\n\n\t\tbreak;\n\n\tcase 4:\n\t\tif ((tx && (mode & (SPI_TX_QUAD | SPI_TX_OCTAL))) ||\n\t\t    (!tx && (mode & (SPI_RX_QUAD | SPI_RX_OCTAL))))\n\t\t\treturn 0;\n\n\t\tbreak;\n\n\tcase 8:\n\t\tif ((tx && (mode & SPI_TX_OCTAL)) ||\n\t\t    (!tx && (mode & SPI_RX_OCTAL)))\n\t\t\treturn 0;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic bool spi_mem_check_buswidth(struct spi_mem *mem,\n\t\t\t\t   const struct spi_mem_op *op)\n{\n\tif (spi_check_buswidth_req(mem, op->cmd.buswidth, true))\n\t\treturn false;\n\n\tif (op->addr.nbytes &&\n\t    spi_check_buswidth_req(mem, op->addr.buswidth, true))\n\t\treturn false;\n\n\tif (op->dummy.nbytes &&\n\t    spi_check_buswidth_req(mem, op->dummy.buswidth, true))\n\t\treturn false;\n\n\tif (op->data.dir != SPI_MEM_NO_DATA &&\n\t    spi_check_buswidth_req(mem, op->data.buswidth,\n\t\t\t\t   op->data.dir == SPI_MEM_DATA_OUT))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool spi_mem_default_supports_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\tbool op_is_dtr =\n\t\top->cmd.dtr || op->addr.dtr || op->dummy.dtr || op->data.dtr;\n\n\tif (op_is_dtr) {\n\t\tif (!spi_mem_controller_is_capable(ctlr, dtr))\n\t\t\treturn false;\n\n\t\tif (op->cmd.nbytes != 2)\n\t\t\treturn false;\n\t} else {\n\t\tif (op->cmd.nbytes != 1)\n\t\t\treturn false;\n\t}\n\n\tif (op->data.ecc) {\n\t\tif (!spi_mem_controller_is_capable(ctlr, ecc))\n\t\t\treturn false;\n\t}\n\n\treturn spi_mem_check_buswidth(mem, op);\n}\nEXPORT_SYMBOL_GPL(spi_mem_default_supports_op);\n\nstatic bool spi_mem_buswidth_is_valid(u8 buswidth)\n{\n\tif (hweight8(buswidth) > 1 || buswidth > SPI_MEM_MAX_BUSWIDTH)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int spi_mem_check_op(const struct spi_mem_op *op)\n{\n\tif (!op->cmd.buswidth || !op->cmd.nbytes)\n\t\treturn -EINVAL;\n\n\tif ((op->addr.nbytes && !op->addr.buswidth) ||\n\t    (op->dummy.nbytes && !op->dummy.buswidth) ||\n\t    (op->data.nbytes && !op->data.buswidth))\n\t\treturn -EINVAL;\n\n\tif (!spi_mem_buswidth_is_valid(op->cmd.buswidth) ||\n\t    !spi_mem_buswidth_is_valid(op->addr.buswidth) ||\n\t    !spi_mem_buswidth_is_valid(op->dummy.buswidth) ||\n\t    !spi_mem_buswidth_is_valid(op->data.buswidth))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON_ONCE(op->data.dir == SPI_MEM_DATA_IN &&\n\t\t\t object_is_on_stack(op->data.buf.in)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(op->data.dir == SPI_MEM_DATA_OUT &&\n\t\t\t object_is_on_stack(op->data.buf.out)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool spi_mem_internal_supports_op(struct spi_mem *mem,\n\t\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\n\tif (ctlr->mem_ops && ctlr->mem_ops->supports_op)\n\t\treturn ctlr->mem_ops->supports_op(mem, op);\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\n \nbool spi_mem_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tif (spi_mem_check_op(op))\n\t\treturn false;\n\n\treturn spi_mem_internal_supports_op(mem, op);\n}\nEXPORT_SYMBOL_GPL(spi_mem_supports_op);\n\nstatic int spi_mem_access_start(struct spi_mem *mem)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\n\t \n\tspi_flush_queue(ctlr);\n\n\tif (ctlr->auto_runtime_pm) {\n\t\tint ret;\n\n\t\tret = pm_runtime_resume_and_get(ctlr->dev.parent);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&ctlr->dev, \"Failed to power device: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&ctlr->bus_lock_mutex);\n\tmutex_lock(&ctlr->io_mutex);\n\n\treturn 0;\n}\n\nstatic void spi_mem_access_end(struct spi_mem *mem)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\n\tmutex_unlock(&ctlr->io_mutex);\n\tmutex_unlock(&ctlr->bus_lock_mutex);\n\n\tif (ctlr->auto_runtime_pm)\n\t\tpm_runtime_put(ctlr->dev.parent);\n}\n\n \nint spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tunsigned int tmpbufsize, xferpos = 0, totalxferlen = 0;\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\tstruct spi_transfer xfers[4] = { };\n\tstruct spi_message msg;\n\tu8 *tmpbuf;\n\tint ret;\n\n\tret = spi_mem_check_op(op);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!spi_mem_internal_supports_op(mem, op))\n\t\treturn -ENOTSUPP;\n\n\tif (ctlr->mem_ops && ctlr->mem_ops->exec_op && !spi_get_csgpiod(mem->spi, 0)) {\n\t\tret = spi_mem_access_start(mem);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ctlr->mem_ops->exec_op(mem, op);\n\n\t\tspi_mem_access_end(mem);\n\n\t\t \n\t\tif (!ret || ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\ttmpbufsize = op->cmd.nbytes + op->addr.nbytes + op->dummy.nbytes;\n\n\t \n\ttmpbuf = kzalloc(tmpbufsize, GFP_KERNEL | GFP_DMA);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&msg);\n\n\ttmpbuf[0] = op->cmd.opcode;\n\txfers[xferpos].tx_buf = tmpbuf;\n\txfers[xferpos].len = op->cmd.nbytes;\n\txfers[xferpos].tx_nbits = op->cmd.buswidth;\n\tspi_message_add_tail(&xfers[xferpos], &msg);\n\txferpos++;\n\ttotalxferlen++;\n\n\tif (op->addr.nbytes) {\n\t\tint i;\n\n\t\tfor (i = 0; i < op->addr.nbytes; i++)\n\t\t\ttmpbuf[i + 1] = op->addr.val >>\n\t\t\t\t\t(8 * (op->addr.nbytes - i - 1));\n\n\t\txfers[xferpos].tx_buf = tmpbuf + 1;\n\t\txfers[xferpos].len = op->addr.nbytes;\n\t\txfers[xferpos].tx_nbits = op->addr.buswidth;\n\t\tspi_message_add_tail(&xfers[xferpos], &msg);\n\t\txferpos++;\n\t\ttotalxferlen += op->addr.nbytes;\n\t}\n\n\tif (op->dummy.nbytes) {\n\t\tmemset(tmpbuf + op->addr.nbytes + 1, 0xff, op->dummy.nbytes);\n\t\txfers[xferpos].tx_buf = tmpbuf + op->addr.nbytes + 1;\n\t\txfers[xferpos].len = op->dummy.nbytes;\n\t\txfers[xferpos].tx_nbits = op->dummy.buswidth;\n\t\txfers[xferpos].dummy_data = 1;\n\t\tspi_message_add_tail(&xfers[xferpos], &msg);\n\t\txferpos++;\n\t\ttotalxferlen += op->dummy.nbytes;\n\t}\n\n\tif (op->data.nbytes) {\n\t\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\t\txfers[xferpos].rx_buf = op->data.buf.in;\n\t\t\txfers[xferpos].rx_nbits = op->data.buswidth;\n\t\t} else {\n\t\t\txfers[xferpos].tx_buf = op->data.buf.out;\n\t\t\txfers[xferpos].tx_nbits = op->data.buswidth;\n\t\t}\n\n\t\txfers[xferpos].len = op->data.nbytes;\n\t\tspi_message_add_tail(&xfers[xferpos], &msg);\n\t\txferpos++;\n\t\ttotalxferlen += op->data.nbytes;\n\t}\n\n\tret = spi_sync(mem->spi, &msg);\n\n\tkfree(tmpbuf);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg.actual_length != totalxferlen)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_mem_exec_op);\n\n \nconst char *spi_mem_get_name(struct spi_mem *mem)\n{\n\treturn mem->name;\n}\nEXPORT_SYMBOL_GPL(spi_mem_get_name);\n\n \nint spi_mem_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\tsize_t len;\n\n\tif (ctlr->mem_ops && ctlr->mem_ops->adjust_op_size)\n\t\treturn ctlr->mem_ops->adjust_op_size(mem, op);\n\n\tif (!ctlr->mem_ops || !ctlr->mem_ops->exec_op) {\n\t\tlen = op->cmd.nbytes + op->addr.nbytes + op->dummy.nbytes;\n\n\t\tif (len > spi_max_transfer_size(mem->spi))\n\t\t\treturn -EINVAL;\n\n\t\top->data.nbytes = min3((size_t)op->data.nbytes,\n\t\t\t\t       spi_max_transfer_size(mem->spi),\n\t\t\t\t       spi_max_message_size(mem->spi) -\n\t\t\t\t       len);\n\t\tif (!op->data.nbytes)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_mem_adjust_op_size);\n\nstatic ssize_t spi_mem_no_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t      u64 offs, size_t len, void *buf)\n{\n\tstruct spi_mem_op op = desc->info.op_tmpl;\n\tint ret;\n\n\top.addr.val = desc->info.offset + offs;\n\top.data.buf.in = buf;\n\top.data.nbytes = len;\n\tret = spi_mem_adjust_op_size(desc->mem, &op);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_mem_exec_op(desc->mem, &op);\n\tif (ret)\n\t\treturn ret;\n\n\treturn op.data.nbytes;\n}\n\nstatic ssize_t spi_mem_no_dirmap_write(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t       u64 offs, size_t len, const void *buf)\n{\n\tstruct spi_mem_op op = desc->info.op_tmpl;\n\tint ret;\n\n\top.addr.val = desc->info.offset + offs;\n\top.data.buf.out = buf;\n\top.data.nbytes = len;\n\tret = spi_mem_adjust_op_size(desc->mem, &op);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_mem_exec_op(desc->mem, &op);\n\tif (ret)\n\t\treturn ret;\n\n\treturn op.data.nbytes;\n}\n\n \nstruct spi_mem_dirmap_desc *\nspi_mem_dirmap_create(struct spi_mem *mem,\n\t\t      const struct spi_mem_dirmap_info *info)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\tstruct spi_mem_dirmap_desc *desc;\n\tint ret = -ENOTSUPP;\n\n\t \n\tif (!info->op_tmpl.addr.nbytes || info->op_tmpl.addr.nbytes > 8)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (info->op_tmpl.data.dir == SPI_MEM_NO_DATA)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->mem = mem;\n\tdesc->info = *info;\n\tif (ctlr->mem_ops && ctlr->mem_ops->dirmap_create)\n\t\tret = ctlr->mem_ops->dirmap_create(desc);\n\n\tif (ret) {\n\t\tdesc->nodirmap = true;\n\t\tif (!spi_mem_supports_op(desc->mem, &desc->info.op_tmpl))\n\t\t\tret = -ENOTSUPP;\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\tif (ret) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(spi_mem_dirmap_create);\n\n \nvoid spi_mem_dirmap_destroy(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct spi_controller *ctlr = desc->mem->spi->controller;\n\n\tif (!desc->nodirmap && ctlr->mem_ops && ctlr->mem_ops->dirmap_destroy)\n\t\tctlr->mem_ops->dirmap_destroy(desc);\n\n\tkfree(desc);\n}\nEXPORT_SYMBOL_GPL(spi_mem_dirmap_destroy);\n\nstatic void devm_spi_mem_dirmap_release(struct device *dev, void *res)\n{\n\tstruct spi_mem_dirmap_desc *desc = *(struct spi_mem_dirmap_desc **)res;\n\n\tspi_mem_dirmap_destroy(desc);\n}\n\n \nstruct spi_mem_dirmap_desc *\ndevm_spi_mem_dirmap_create(struct device *dev, struct spi_mem *mem,\n\t\t\t   const struct spi_mem_dirmap_info *info)\n{\n\tstruct spi_mem_dirmap_desc **ptr, *desc;\n\n\tptr = devres_alloc(devm_spi_mem_dirmap_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc = spi_mem_dirmap_create(mem, info);\n\tif (IS_ERR(desc)) {\n\t\tdevres_free(ptr);\n\t} else {\n\t\t*ptr = desc;\n\t\tdevres_add(dev, ptr);\n\t}\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(devm_spi_mem_dirmap_create);\n\nstatic int devm_spi_mem_dirmap_match(struct device *dev, void *res, void *data)\n{\n\tstruct spi_mem_dirmap_desc **ptr = res;\n\n\tif (WARN_ON(!ptr || !*ptr))\n\t\treturn 0;\n\n\treturn *ptr == data;\n}\n\n \nvoid devm_spi_mem_dirmap_destroy(struct device *dev,\n\t\t\t\t struct spi_mem_dirmap_desc *desc)\n{\n\tdevres_release(dev, devm_spi_mem_dirmap_release,\n\t\t       devm_spi_mem_dirmap_match, desc);\n}\nEXPORT_SYMBOL_GPL(devm_spi_mem_dirmap_destroy);\n\n \nssize_t spi_mem_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t    u64 offs, size_t len, void *buf)\n{\n\tstruct spi_controller *ctlr = desc->mem->spi->controller;\n\tssize_t ret;\n\n\tif (desc->info.op_tmpl.data.dir != SPI_MEM_DATA_IN)\n\t\treturn -EINVAL;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (desc->nodirmap) {\n\t\tret = spi_mem_no_dirmap_read(desc, offs, len, buf);\n\t} else if (ctlr->mem_ops && ctlr->mem_ops->dirmap_read) {\n\t\tret = spi_mem_access_start(desc->mem);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ctlr->mem_ops->dirmap_read(desc, offs, len, buf);\n\n\t\tspi_mem_access_end(desc->mem);\n\t} else {\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_mem_dirmap_read);\n\n \nssize_t spi_mem_dirmap_write(struct spi_mem_dirmap_desc *desc,\n\t\t\t     u64 offs, size_t len, const void *buf)\n{\n\tstruct spi_controller *ctlr = desc->mem->spi->controller;\n\tssize_t ret;\n\n\tif (desc->info.op_tmpl.data.dir != SPI_MEM_DATA_OUT)\n\t\treturn -EINVAL;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (desc->nodirmap) {\n\t\tret = spi_mem_no_dirmap_write(desc, offs, len, buf);\n\t} else if (ctlr->mem_ops && ctlr->mem_ops->dirmap_write) {\n\t\tret = spi_mem_access_start(desc->mem);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ctlr->mem_ops->dirmap_write(desc, offs, len, buf);\n\n\t\tspi_mem_access_end(desc->mem);\n\t} else {\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_mem_dirmap_write);\n\nstatic inline struct spi_mem_driver *to_spi_mem_drv(struct device_driver *drv)\n{\n\treturn container_of(drv, struct spi_mem_driver, spidrv.driver);\n}\n\nstatic int spi_mem_read_status(struct spi_mem *mem,\n\t\t\t       const struct spi_mem_op *op,\n\t\t\t       u16 *status)\n{\n\tconst u8 *bytes = (u8 *)op->data.buf.in;\n\tint ret;\n\n\tret = spi_mem_exec_op(mem, op);\n\tif (ret)\n\t\treturn ret;\n\n\tif (op->data.nbytes > 1)\n\t\t*status = ((u16)bytes[0] << 8) | bytes[1];\n\telse\n\t\t*status = bytes[0];\n\n\treturn 0;\n}\n\n \nint spi_mem_poll_status(struct spi_mem *mem,\n\t\t\tconst struct spi_mem_op *op,\n\t\t\tu16 mask, u16 match,\n\t\t\tunsigned long initial_delay_us,\n\t\t\tunsigned long polling_delay_us,\n\t\t\tu16 timeout_ms)\n{\n\tstruct spi_controller *ctlr = mem->spi->controller;\n\tint ret = -EOPNOTSUPP;\n\tint read_status_ret;\n\tu16 status;\n\n\tif (op->data.nbytes < 1 || op->data.nbytes > 2 ||\n\t    op->data.dir != SPI_MEM_DATA_IN)\n\t\treturn -EINVAL;\n\n\tif (ctlr->mem_ops && ctlr->mem_ops->poll_status && !spi_get_csgpiod(mem->spi, 0)) {\n\t\tret = spi_mem_access_start(mem);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ctlr->mem_ops->poll_status(mem, op, mask, match,\n\t\t\t\t\t\t initial_delay_us, polling_delay_us,\n\t\t\t\t\t\t timeout_ms);\n\n\t\tspi_mem_access_end(mem);\n\t}\n\n\tif (ret == -EOPNOTSUPP) {\n\t\tif (!spi_mem_supports_op(mem, op))\n\t\t\treturn ret;\n\n\t\tif (initial_delay_us < 10)\n\t\t\tudelay(initial_delay_us);\n\t\telse\n\t\t\tusleep_range((initial_delay_us >> 2) + 1,\n\t\t\t\t     initial_delay_us);\n\n\t\tret = read_poll_timeout(spi_mem_read_status, read_status_ret,\n\t\t\t\t\t(read_status_ret || ((status) & mask) == match),\n\t\t\t\t\tpolling_delay_us, timeout_ms * 1000, false, mem,\n\t\t\t\t\top, &status);\n\t\tif (read_status_ret)\n\t\t\treturn read_status_ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_mem_poll_status);\n\nstatic int spi_mem_probe(struct spi_device *spi)\n{\n\tstruct spi_mem_driver *memdrv = to_spi_mem_drv(spi->dev.driver);\n\tstruct spi_controller *ctlr = spi->controller;\n\tstruct spi_mem *mem;\n\n\tmem = devm_kzalloc(&spi->dev, sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tmem->spi = spi;\n\n\tif (ctlr->mem_ops && ctlr->mem_ops->get_name)\n\t\tmem->name = ctlr->mem_ops->get_name(mem);\n\telse\n\t\tmem->name = dev_name(&spi->dev);\n\n\tif (IS_ERR_OR_NULL(mem->name))\n\t\treturn PTR_ERR_OR_ZERO(mem->name);\n\n\tspi_set_drvdata(spi, mem);\n\n\treturn memdrv->probe(mem);\n}\n\nstatic void spi_mem_remove(struct spi_device *spi)\n{\n\tstruct spi_mem_driver *memdrv = to_spi_mem_drv(spi->dev.driver);\n\tstruct spi_mem *mem = spi_get_drvdata(spi);\n\n\tif (memdrv->remove)\n\t\tmemdrv->remove(mem);\n}\n\nstatic void spi_mem_shutdown(struct spi_device *spi)\n{\n\tstruct spi_mem_driver *memdrv = to_spi_mem_drv(spi->dev.driver);\n\tstruct spi_mem *mem = spi_get_drvdata(spi);\n\n\tif (memdrv->shutdown)\n\t\tmemdrv->shutdown(mem);\n}\n\n \n\nint spi_mem_driver_register_with_owner(struct spi_mem_driver *memdrv,\n\t\t\t\t       struct module *owner)\n{\n\tmemdrv->spidrv.probe = spi_mem_probe;\n\tmemdrv->spidrv.remove = spi_mem_remove;\n\tmemdrv->spidrv.shutdown = spi_mem_shutdown;\n\n\treturn __spi_register_driver(owner, &memdrv->spidrv);\n}\nEXPORT_SYMBOL_GPL(spi_mem_driver_register_with_owner);\n\n \nvoid spi_mem_driver_unregister(struct spi_mem_driver *memdrv)\n{\n\tspi_unregister_driver(&memdrv->spidrv);\n}\nEXPORT_SYMBOL_GPL(spi_mem_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}