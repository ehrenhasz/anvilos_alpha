{
  "module_name": "spi-lp8841-rtc.c",
  "hash_id": "7148518932d97675d03ebabe5654134af228021b1ed814a62996d0efa8d5e009",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-lp8841-rtc.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n#define DRIVER_NAME\t\"spi_lp8841_rtc\"\n\n#define SPI_LP8841_RTC_CE\t0x01\n#define SPI_LP8841_RTC_CLK\t0x02\n#define SPI_LP8841_RTC_nWE\t0x04\n#define SPI_LP8841_RTC_MOSI\t0x08\n#define SPI_LP8841_RTC_MISO\t0x01\n\n \n\nstruct spi_lp8841_rtc {\n\tvoid\t\t*iomem;\n\tunsigned long\tstate;\n};\n\nstatic inline void\nsetsck(struct spi_lp8841_rtc *data, int is_on)\n{\n\tif (is_on)\n\t\tdata->state |= SPI_LP8841_RTC_CLK;\n\telse\n\t\tdata->state &= ~SPI_LP8841_RTC_CLK;\n\twriteb(data->state, data->iomem);\n}\n\nstatic inline void\nsetmosi(struct spi_lp8841_rtc *data, int is_on)\n{\n\tif (is_on)\n\t\tdata->state |= SPI_LP8841_RTC_MOSI;\n\telse\n\t\tdata->state &= ~SPI_LP8841_RTC_MOSI;\n\twriteb(data->state, data->iomem);\n}\n\nstatic inline int\ngetmiso(struct spi_lp8841_rtc *data)\n{\n\treturn ioread8(data->iomem) & SPI_LP8841_RTC_MISO;\n}\n\nstatic inline u32\nbitbang_txrx_be_cpha0_lsb(struct spi_lp8841_rtc *data,\n\t\tunsigned usecs, unsigned cpol, unsigned flags,\n\t\tu32 word, u8 bits)\n{\n\t \n\n\tu32 shift = 32 - bits;\n\t \n\tfor (; likely(bits); bits--) {\n\n\t\t \n\t\tif ((flags & SPI_CONTROLLER_NO_TX) == 0)\n\t\t\tsetmosi(data, (word & 1));\n\n\t\tusleep_range(usecs, usecs + 1);\t \n\n\t\t \n\t\tword >>= 1;\n\t\tif ((flags & SPI_CONTROLLER_NO_RX) == 0)\n\t\t\tword |= (getmiso(data) << 31);\n\n\t\tsetsck(data, !cpol);\n\t\tusleep_range(usecs, usecs + 1);\n\n\t\tsetsck(data, cpol);\n\t}\n\n\tword >>= shift;\n\treturn word;\n}\n\nstatic int\nspi_lp8841_rtc_transfer_one(struct spi_master *master,\n\t\t\t    struct spi_device *spi,\n\t\t\t    struct spi_transfer *t)\n{\n\tstruct spi_lp8841_rtc\t*data = spi_master_get_devdata(master);\n\tunsigned\t\tcount = t->len;\n\tconst u8\t\t*tx = t->tx_buf;\n\tu8\t\t\t*rx = t->rx_buf;\n\tu8\t\t\tword = 0;\n\tint\t\t\tret = 0;\n\n\tif (tx) {\n\t\tdata->state &= ~SPI_LP8841_RTC_nWE;\n\t\twriteb(data->state, data->iomem);\n\t\twhile (likely(count > 0)) {\n\t\t\tword = *tx++;\n\t\t\tbitbang_txrx_be_cpha0_lsb(data, 1, 0,\n\t\t\t\t\tSPI_CONTROLLER_NO_RX, word, 8);\n\t\t\tcount--;\n\t\t}\n\t} else if (rx) {\n\t\tdata->state |= SPI_LP8841_RTC_nWE;\n\t\twriteb(data->state, data->iomem);\n\t\twhile (likely(count > 0)) {\n\t\t\tword = bitbang_txrx_be_cpha0_lsb(data, 1, 0,\n\t\t\t\t\tSPI_CONTROLLER_NO_TX, word, 8);\n\t\t\t*rx++ = word;\n\t\t\tcount--;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tspi_finalize_current_transfer(master);\n\n\treturn ret;\n}\n\nstatic void\nspi_lp8841_rtc_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct spi_lp8841_rtc *data = spi_master_get_devdata(spi->master);\n\n\tdata->state = 0;\n\twriteb(data->state, data->iomem);\n\tif (enable) {\n\t\tusleep_range(4, 5);\n\t\tdata->state |= SPI_LP8841_RTC_CE;\n\t\twriteb(data->state, data->iomem);\n\t\tusleep_range(4, 5);\n\t}\n}\n\nstatic int\nspi_lp8841_rtc_setup(struct spi_device *spi)\n{\n\tif ((spi->mode & SPI_CS_HIGH) == 0) {\n\t\tdev_err(&spi->dev, \"unsupported active low chip select\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((spi->mode & SPI_LSB_FIRST) == 0) {\n\t\tdev_err(&spi->dev, \"unsupported MSB first mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((spi->mode & SPI_3WIRE) == 0) {\n\t\tdev_err(&spi->dev, \"unsupported wiring. 3 wires required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spi_lp8841_rtc_dt_ids[] = {\n\t{ .compatible = \"icpdas,lp8841-spi-rtc\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, spi_lp8841_rtc_dt_ids);\n#endif\n\nstatic int\nspi_lp8841_rtc_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tret;\n\tstruct spi_master\t\t*master;\n\tstruct spi_lp8841_rtc\t\t*data;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*data));\n\tif (!master)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, master);\n\n\tmaster->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tmaster->mode_bits = SPI_CS_HIGH | SPI_3WIRE | SPI_LSB_FIRST;\n\n\tmaster->bus_num = pdev->id;\n\tmaster->num_chipselect = 1;\n\tmaster->setup = spi_lp8841_rtc_setup;\n\tmaster->set_cs = spi_lp8841_rtc_set_cs;\n\tmaster->transfer_one = spi_lp8841_rtc_transfer_one;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n#ifdef CONFIG_OF\n\tmaster->dev.of_node = pdev->dev.of_node;\n#endif\n\n\tdata = spi_master_get_devdata(master);\n\n\tdata->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tret = PTR_ERR_OR_ZERO(data->iomem);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get IO address\\n\");\n\t\tgoto err_put_master;\n\t}\n\n\t \n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register spi master\\n\");\n\t\tgoto err_put_master;\n\t}\n\n\treturn ret;\n\n\nerr_put_master:\n\tspi_master_put(master);\n\n\treturn ret;\n}\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n\nstatic struct platform_driver spi_lp8841_rtc_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(spi_lp8841_rtc_dt_ids),\n\t},\n\t.probe\t\t= spi_lp8841_rtc_probe,\n};\nmodule_platform_driver(spi_lp8841_rtc_driver);\n\nMODULE_DESCRIPTION(\"SPI master driver for ICP DAS LP-8841 RTC\");\nMODULE_AUTHOR(\"Sergei Ianovich\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}