{
  "module_name": "spi-amd.c",
  "hash_id": "5436f2e3ee34ae08ab7df26568b7a0f3546c69ee6722e382a1cf7bf3b6fb5d68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-amd.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/iopoll.h>\n\n#define AMD_SPI_CTRL0_REG\t0x00\n#define AMD_SPI_EXEC_CMD\tBIT(16)\n#define AMD_SPI_FIFO_CLEAR\tBIT(20)\n#define AMD_SPI_BUSY\t\tBIT(31)\n\n#define AMD_SPI_OPCODE_REG\t0x45\n#define AMD_SPI_CMD_TRIGGER_REG\t0x47\n#define AMD_SPI_TRIGGER_CMD\tBIT(7)\n\n#define AMD_SPI_OPCODE_MASK\t0xFF\n\n#define AMD_SPI_ALT_CS_REG\t0x1D\n#define AMD_SPI_ALT_CS_MASK\t0x3\n\n#define AMD_SPI_FIFO_BASE\t0x80\n#define AMD_SPI_TX_COUNT_REG\t0x48\n#define AMD_SPI_RX_COUNT_REG\t0x4B\n#define AMD_SPI_STATUS_REG\t0x4C\n\n#define AMD_SPI_FIFO_SIZE\t70\n#define AMD_SPI_MEM_SIZE\t200\n\n#define AMD_SPI_ENA_REG\t\t0x20\n#define AMD_SPI_ALT_SPD_SHIFT\t20\n#define AMD_SPI_ALT_SPD_MASK\tGENMASK(23, AMD_SPI_ALT_SPD_SHIFT)\n#define AMD_SPI_SPI100_SHIFT\t0\n#define AMD_SPI_SPI100_MASK\tGENMASK(AMD_SPI_SPI100_SHIFT, AMD_SPI_SPI100_SHIFT)\n#define AMD_SPI_SPEED_REG\t0x6C\n#define AMD_SPI_SPD7_SHIFT\t8\n#define AMD_SPI_SPD7_MASK\tGENMASK(13, AMD_SPI_SPD7_SHIFT)\n\n#define AMD_SPI_MAX_HZ\t\t100000000\n#define AMD_SPI_MIN_HZ\t\t800000\n\n \nenum amd_spi_versions {\n\tAMD_SPI_V1 = 1,\n\tAMD_SPI_V2,\n};\n\nenum amd_spi_speed {\n\tF_66_66MHz,\n\tF_33_33MHz,\n\tF_22_22MHz,\n\tF_16_66MHz,\n\tF_100MHz,\n\tF_800KHz,\n\tSPI_SPD7 = 0x7,\n\tF_50MHz = 0x4,\n\tF_4MHz = 0x32,\n\tF_3_17MHz = 0x3F\n};\n\n \nstruct amd_spi_freq {\n\tu32 speed_hz;\n\tu32 enable_val;\n\tu32 spd7_val;\n};\n\n \nstruct amd_spi {\n\tvoid __iomem *io_remap_addr;\n\tenum amd_spi_versions version;\n\tunsigned int speed_hz;\n};\n\nstatic inline u8 amd_spi_readreg8(struct amd_spi *amd_spi, int idx)\n{\n\treturn ioread8((u8 __iomem *)amd_spi->io_remap_addr + idx);\n}\n\nstatic inline void amd_spi_writereg8(struct amd_spi *amd_spi, int idx, u8 val)\n{\n\tiowrite8(val, ((u8 __iomem *)amd_spi->io_remap_addr + idx));\n}\n\nstatic void amd_spi_setclear_reg8(struct amd_spi *amd_spi, int idx, u8 set, u8 clear)\n{\n\tu8 tmp = amd_spi_readreg8(amd_spi, idx);\n\n\ttmp = (tmp & ~clear) | set;\n\tamd_spi_writereg8(amd_spi, idx, tmp);\n}\n\nstatic inline u32 amd_spi_readreg32(struct amd_spi *amd_spi, int idx)\n{\n\treturn ioread32((u8 __iomem *)amd_spi->io_remap_addr + idx);\n}\n\nstatic inline void amd_spi_writereg32(struct amd_spi *amd_spi, int idx, u32 val)\n{\n\tiowrite32(val, ((u8 __iomem *)amd_spi->io_remap_addr + idx));\n}\n\nstatic inline void amd_spi_setclear_reg32(struct amd_spi *amd_spi, int idx, u32 set, u32 clear)\n{\n\tu32 tmp = amd_spi_readreg32(amd_spi, idx);\n\n\ttmp = (tmp & ~clear) | set;\n\tamd_spi_writereg32(amd_spi, idx, tmp);\n}\n\nstatic void amd_spi_select_chip(struct amd_spi *amd_spi, u8 cs)\n{\n\tamd_spi_setclear_reg8(amd_spi, AMD_SPI_ALT_CS_REG, cs, AMD_SPI_ALT_CS_MASK);\n}\n\nstatic inline void amd_spi_clear_chip(struct amd_spi *amd_spi, u8 chip_select)\n{\n\tamd_spi_writereg8(amd_spi, AMD_SPI_ALT_CS_REG, chip_select & ~AMD_SPI_ALT_CS_MASK);\n}\n\nstatic void amd_spi_clear_fifo_ptr(struct amd_spi *amd_spi)\n{\n\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_CTRL0_REG, AMD_SPI_FIFO_CLEAR, AMD_SPI_FIFO_CLEAR);\n}\n\nstatic int amd_spi_set_opcode(struct amd_spi *amd_spi, u8 cmd_opcode)\n{\n\tswitch (amd_spi->version) {\n\tcase AMD_SPI_V1:\n\t\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_CTRL0_REG, cmd_opcode,\n\t\t\t\t       AMD_SPI_OPCODE_MASK);\n\t\treturn 0;\n\tcase AMD_SPI_V2:\n\t\tamd_spi_writereg8(amd_spi, AMD_SPI_OPCODE_REG, cmd_opcode);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic inline void amd_spi_set_rx_count(struct amd_spi *amd_spi, u8 rx_count)\n{\n\tamd_spi_setclear_reg8(amd_spi, AMD_SPI_RX_COUNT_REG, rx_count, 0xff);\n}\n\nstatic inline void amd_spi_set_tx_count(struct amd_spi *amd_spi, u8 tx_count)\n{\n\tamd_spi_setclear_reg8(amd_spi, AMD_SPI_TX_COUNT_REG, tx_count, 0xff);\n}\n\nstatic int amd_spi_busy_wait(struct amd_spi *amd_spi)\n{\n\tu32 val;\n\tint reg;\n\n\tswitch (amd_spi->version) {\n\tcase AMD_SPI_V1:\n\t\treg = AMD_SPI_CTRL0_REG;\n\t\tbreak;\n\tcase AMD_SPI_V2:\n\t\treg = AMD_SPI_STATUS_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn readl_poll_timeout(amd_spi->io_remap_addr + reg, val,\n\t\t\t\t  !(val & AMD_SPI_BUSY), 20, 2000000);\n}\n\nstatic int amd_spi_execute_opcode(struct amd_spi *amd_spi)\n{\n\tint ret;\n\n\tret = amd_spi_busy_wait(amd_spi);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (amd_spi->version) {\n\tcase AMD_SPI_V1:\n\t\t \n\t\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_CTRL0_REG, AMD_SPI_EXEC_CMD,\n\t\t\t\t       AMD_SPI_EXEC_CMD);\n\t\treturn 0;\n\tcase AMD_SPI_V2:\n\t\t \n\t\tamd_spi_setclear_reg8(amd_spi, AMD_SPI_CMD_TRIGGER_REG,\n\t\t\t\t      AMD_SPI_TRIGGER_CMD, AMD_SPI_TRIGGER_CMD);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int amd_spi_host_setup(struct spi_device *spi)\n{\n\tstruct amd_spi *amd_spi = spi_controller_get_devdata(spi->controller);\n\n\tamd_spi_clear_fifo_ptr(amd_spi);\n\n\treturn 0;\n}\n\nstatic const struct amd_spi_freq amd_spi_freq[] = {\n\t{ AMD_SPI_MAX_HZ,   F_100MHz,         0},\n\t{       66660000, F_66_66MHz,         0},\n\t{       50000000,   SPI_SPD7,   F_50MHz},\n\t{       33330000, F_33_33MHz,         0},\n\t{       22220000, F_22_22MHz,         0},\n\t{       16660000, F_16_66MHz,         0},\n\t{        4000000,   SPI_SPD7,    F_4MHz},\n\t{        3170000,   SPI_SPD7, F_3_17MHz},\n\t{ AMD_SPI_MIN_HZ,   F_800KHz,         0},\n};\n\nstatic int amd_set_spi_freq(struct amd_spi *amd_spi, u32 speed_hz)\n{\n\tunsigned int i, spd7_val, alt_spd;\n\n\tif (speed_hz < AMD_SPI_MIN_HZ)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)\n\t\tif (speed_hz >= amd_spi_freq[i].speed_hz)\n\t\t\tbreak;\n\n\tif (amd_spi->speed_hz == amd_spi_freq[i].speed_hz)\n\t\treturn 0;\n\n\tamd_spi->speed_hz = amd_spi_freq[i].speed_hz;\n\n\talt_spd = (amd_spi_freq[i].enable_val << AMD_SPI_ALT_SPD_SHIFT)\n\t\t   & AMD_SPI_ALT_SPD_MASK;\n\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_ENA_REG, alt_spd,\n\t\t\t       AMD_SPI_ALT_SPD_MASK);\n\n\tif (amd_spi->speed_hz == AMD_SPI_MAX_HZ)\n\t\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_ENA_REG, 1,\n\t\t\t\t       AMD_SPI_SPI100_MASK);\n\n\tif (amd_spi_freq[i].spd7_val) {\n\t\tspd7_val = (amd_spi_freq[i].spd7_val << AMD_SPI_SPD7_SHIFT)\n\t\t\t    & AMD_SPI_SPD7_MASK;\n\t\tamd_spi_setclear_reg32(amd_spi, AMD_SPI_SPEED_REG, spd7_val,\n\t\t\t\t       AMD_SPI_SPD7_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int amd_spi_fifo_xfer(struct amd_spi *amd_spi,\n\t\t\t\t    struct spi_controller *host,\n\t\t\t\t    struct spi_message *message)\n{\n\tstruct spi_transfer *xfer = NULL;\n\tstruct spi_device *spi = message->spi;\n\tu8 cmd_opcode = 0, fifo_pos = AMD_SPI_FIFO_BASE;\n\tu8 *buf = NULL;\n\tu32 i = 0;\n\tu32 tx_len = 0, rx_len = 0;\n\n\tlist_for_each_entry(xfer, &message->transfers,\n\t\t\t    transfer_list) {\n\t\tif (xfer->speed_hz)\n\t\t\tamd_set_spi_freq(amd_spi, xfer->speed_hz);\n\t\telse\n\t\t\tamd_set_spi_freq(amd_spi, spi->max_speed_hz);\n\n\t\tif (xfer->tx_buf) {\n\t\t\tbuf = (u8 *)xfer->tx_buf;\n\t\t\tif (!tx_len) {\n\t\t\t\tcmd_opcode = *(u8 *)xfer->tx_buf;\n\t\t\t\tbuf++;\n\t\t\t\txfer->len--;\n\t\t\t}\n\t\t\ttx_len += xfer->len;\n\n\t\t\t \n\t\t\tfor (i = 0; i < xfer->len; i++)\n\t\t\t\tamd_spi_writereg8(amd_spi, fifo_pos + i, buf[i]);\n\n\t\t\tfifo_pos += xfer->len;\n\t\t}\n\n\t\t \n\t\tif (xfer->rx_buf)\n\t\t\trx_len += xfer->len;\n\t}\n\n\tif (!buf) {\n\t\tmessage->status = -EINVAL;\n\t\tgoto fin_msg;\n\t}\n\n\tamd_spi_set_opcode(amd_spi, cmd_opcode);\n\tamd_spi_set_tx_count(amd_spi, tx_len);\n\tamd_spi_set_rx_count(amd_spi, rx_len);\n\n\t \n\tmessage->status = amd_spi_execute_opcode(amd_spi);\n\tif (message->status)\n\t\tgoto fin_msg;\n\n\tif (rx_len) {\n\t\tmessage->status = amd_spi_busy_wait(amd_spi);\n\t\tif (message->status)\n\t\t\tgoto fin_msg;\n\n\t\tlist_for_each_entry(xfer, &message->transfers, transfer_list)\n\t\t\tif (xfer->rx_buf) {\n\t\t\t\tbuf = (u8 *)xfer->rx_buf;\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < xfer->len; i++)\n\t\t\t\t\tbuf[i] = amd_spi_readreg8(amd_spi, fifo_pos + i);\n\t\t\t\tfifo_pos += xfer->len;\n\t\t\t}\n\t}\n\n\t \n\tmessage->actual_length = tx_len + rx_len + 1;\n\nfin_msg:\n\tswitch (amd_spi->version) {\n\tcase AMD_SPI_V1:\n\t\tbreak;\n\tcase AMD_SPI_V2:\n\t\tamd_spi_clear_chip(amd_spi, spi_get_chipselect(message->spi, 0));\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tspi_finalize_current_message(host);\n\n\treturn message->status;\n}\n\nstatic int amd_spi_host_transfer(struct spi_controller *host,\n\t\t\t\t   struct spi_message *msg)\n{\n\tstruct amd_spi *amd_spi = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = msg->spi;\n\n\tamd_spi_select_chip(amd_spi, spi_get_chipselect(spi, 0));\n\n\t \n\treturn amd_spi_fifo_xfer(amd_spi, host, msg);\n}\n\nstatic size_t amd_spi_max_transfer_size(struct spi_device *spi)\n{\n\treturn AMD_SPI_FIFO_SIZE;\n}\n\nstatic int amd_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *host;\n\tstruct amd_spi *amd_spi;\n\tint err;\n\n\t \n\thost = devm_spi_alloc_host(dev, sizeof(struct amd_spi));\n\tif (!host)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"Error allocating SPI host\\n\");\n\n\tamd_spi = spi_controller_get_devdata(host);\n\tamd_spi->io_remap_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(amd_spi->io_remap_addr))\n\t\treturn dev_err_probe(dev, PTR_ERR(amd_spi->io_remap_addr),\n\t\t\t\t     \"ioremap of SPI registers failed\\n\");\n\n\tdev_dbg(dev, \"io_remap_address: %p\\n\", amd_spi->io_remap_addr);\n\n\tamd_spi->version = (uintptr_t) device_get_match_data(dev);\n\n\t \n\thost->bus_num = 0;\n\thost->num_chipselect = 4;\n\thost->mode_bits = 0;\n\thost->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\thost->max_speed_hz = AMD_SPI_MAX_HZ;\n\thost->min_speed_hz = AMD_SPI_MIN_HZ;\n\thost->setup = amd_spi_host_setup;\n\thost->transfer_one_message = amd_spi_host_transfer;\n\thost->max_transfer_size = amd_spi_max_transfer_size;\n\thost->max_message_size = amd_spi_max_transfer_size;\n\n\t \n\terr = devm_spi_register_controller(dev, host);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"error registering SPI controller\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id spi_acpi_match[] = {\n\t{ \"AMDI0061\", AMD_SPI_V1 },\n\t{ \"AMDI0062\", AMD_SPI_V2 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, spi_acpi_match);\n#endif\n\nstatic struct platform_driver amd_spi_driver = {\n\t.driver = {\n\t\t.name = \"amd_spi\",\n\t\t.acpi_match_table = ACPI_PTR(spi_acpi_match),\n\t},\n\t.probe = amd_spi_probe,\n};\n\nmodule_platform_driver(amd_spi_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Sanjay Mehta <sanju.mehta@amd.com>\");\nMODULE_DESCRIPTION(\"AMD SPI Master Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}