{
  "module_name": "spi-tle62x0.c",
  "hash_id": "69120fc1f58ed03a0c41ee611b600920f38c8489ec8af73cb087ba9e0c6fd37c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-tle62x0.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/tle62x0.h>\n\n\n#define CMD_READ\t0x00\n#define CMD_SET\t\t0xff\n\n#define DIAG_NORMAL\t0x03\n#define DIAG_OVERLOAD\t0x02\n#define DIAG_OPEN\t0x01\n#define DIAG_SHORTGND\t0x00\n\nstruct tle62x0_state {\n\tstruct spi_device\t*us;\n\tstruct mutex\t\tlock;\n\tunsigned int\t\tnr_gpio;\n\tunsigned int\t\tgpio_state;\n\n\tunsigned char\t\ttx_buff[4];\n\tunsigned char\t\trx_buff[4];\n};\n\nstatic int to_gpio_num(struct device_attribute *attr);\n\nstatic inline int tle62x0_write(struct tle62x0_state *st)\n{\n\tunsigned char *buff = st->tx_buff;\n\tunsigned int gpio_state = st->gpio_state;\n\n\tbuff[0] = CMD_SET;\n\n\tif (st->nr_gpio == 16) {\n\t\tbuff[1] = gpio_state >> 8;\n\t\tbuff[2] = gpio_state;\n\t} else {\n\t\tbuff[1] = gpio_state;\n\t}\n\n\tdev_dbg(&st->us->dev, \"buff %3ph\\n\", buff);\n\n\treturn spi_write(st->us, buff, (st->nr_gpio == 16) ? 3 : 2);\n}\n\nstatic inline int tle62x0_read(struct tle62x0_state *st)\n{\n\tunsigned char *txbuff = st->tx_buff;\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf\t\t= txbuff,\n\t\t.rx_buf\t\t= st->rx_buff,\n\t\t.len\t\t= (st->nr_gpio * 2) / 8,\n\t};\n\tstruct spi_message msg;\n\n\ttxbuff[0] = CMD_READ;\n\ttxbuff[1] = 0x00;\n\ttxbuff[2] = 0x00;\n\ttxbuff[3] = 0x00;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\treturn spi_sync(st->us, &msg);\n}\n\nstatic unsigned char *decode_fault(unsigned int fault_code)\n{\n\tfault_code &= 3;\n\n\tswitch (fault_code) {\n\tcase DIAG_NORMAL:\n\t\treturn \"N\";\n\tcase DIAG_OVERLOAD:\n\t\treturn \"V\";\n\tcase DIAG_OPEN:\n\t\treturn \"O\";\n\tcase DIAG_SHORTGND:\n\t\treturn \"G\";\n\t}\n\n\treturn \"?\";\n}\n\nstatic ssize_t tle62x0_status_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tle62x0_state *st = dev_get_drvdata(dev);\n\tchar *bp = buf;\n\tunsigned char *buff = st->rx_buff;\n\tunsigned long fault = 0;\n\tint ptr;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = tle62x0_read(st);\n\tdev_dbg(dev, \"tle62x0_read() returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\t}\n\n\tfor (ptr = 0; ptr < (st->nr_gpio * 2)/8; ptr += 1) {\n\t\tfault <<= 8;\n\t\tfault  |= ((unsigned long)buff[ptr]);\n\n\t\tdev_dbg(dev, \"byte %d is %02x\\n\", ptr, buff[ptr]);\n\t}\n\n\tfor (ptr = 0; ptr < st->nr_gpio; ptr++) {\n\t\tbp += sprintf(bp, \"%s \", decode_fault(fault >> (ptr * 2)));\n\t}\n\n\t*bp++ = '\\n';\n\n\tmutex_unlock(&st->lock);\n\treturn bp - buf;\n}\n\nstatic DEVICE_ATTR(status_show, S_IRUGO, tle62x0_status_show, NULL);\n\nstatic ssize_t tle62x0_gpio_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tle62x0_state *st = dev_get_drvdata(dev);\n\tint gpio_num = to_gpio_num(attr);\n\tint value;\n\n\tmutex_lock(&st->lock);\n\tvalue = (st->gpio_state >> gpio_num) & 1;\n\tmutex_unlock(&st->lock);\n\n\treturn sysfs_emit(buf, \"%d\", value);\n}\n\nstatic ssize_t tle62x0_gpio_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct tle62x0_state *st = dev_get_drvdata(dev);\n\tint gpio_num = to_gpio_num(attr);\n\tunsigned long val;\n\tchar *endp;\n\n\tval = simple_strtoul(buf, &endp, 0);\n\tif (buf == endp)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"setting gpio %d to %ld\\n\", gpio_num, val);\n\n\tmutex_lock(&st->lock);\n\n\tif (val)\n\t\tst->gpio_state |= 1 << gpio_num;\n\telse\n\t\tst->gpio_state &= ~(1 << gpio_num);\n\n\ttle62x0_write(st);\n\tmutex_unlock(&st->lock);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(gpio1, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio2, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio3, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio4, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio5, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio6, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio7, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio8, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio9, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio10, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio11, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio12, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio13, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio14, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio15, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\nstatic DEVICE_ATTR(gpio16, S_IWUSR|S_IRUGO,\n\t\ttle62x0_gpio_show, tle62x0_gpio_store);\n\nstatic struct device_attribute *gpio_attrs[] = {\n\t[0]\t\t= &dev_attr_gpio1,\n\t[1]\t\t= &dev_attr_gpio2,\n\t[2]\t\t= &dev_attr_gpio3,\n\t[3]\t\t= &dev_attr_gpio4,\n\t[4]\t\t= &dev_attr_gpio5,\n\t[5]\t\t= &dev_attr_gpio6,\n\t[6]\t\t= &dev_attr_gpio7,\n\t[7]\t\t= &dev_attr_gpio8,\n\t[8]\t\t= &dev_attr_gpio9,\n\t[9]\t\t= &dev_attr_gpio10,\n\t[10]\t\t= &dev_attr_gpio11,\n\t[11]\t\t= &dev_attr_gpio12,\n\t[12]\t\t= &dev_attr_gpio13,\n\t[13]\t\t= &dev_attr_gpio14,\n\t[14]\t\t= &dev_attr_gpio15,\n\t[15]\t\t= &dev_attr_gpio16\n};\n\nstatic int to_gpio_num(struct device_attribute *attr)\n{\n\tint ptr;\n\n\tfor (ptr = 0; ptr < ARRAY_SIZE(gpio_attrs); ptr++) {\n\t\tif (gpio_attrs[ptr] == attr)\n\t\t\treturn ptr;\n\t}\n\n\treturn -1;\n}\n\nstatic int tle62x0_probe(struct spi_device *spi)\n{\n\tstruct tle62x0_state *st;\n\tstruct tle62x0_pdata *pdata;\n\tint ptr;\n\tint ret;\n\n\tpdata = dev_get_platdata(&spi->dev);\n\tif (pdata == NULL) {\n\t\tdev_err(&spi->dev, \"no device data specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tst = kzalloc(sizeof(struct tle62x0_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn -ENOMEM;\n\n\tst->us = spi;\n\tst->nr_gpio = pdata->gpio_count;\n\tst->gpio_state = pdata->init_state;\n\n\tmutex_init(&st->lock);\n\n\tret = device_create_file(&spi->dev, &dev_attr_status_show);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"cannot create status attribute\\n\");\n\t\tgoto err_status;\n\t}\n\n\tfor (ptr = 0; ptr < pdata->gpio_count; ptr++) {\n\t\tret = device_create_file(&spi->dev, gpio_attrs[ptr]);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"cannot create gpio attribute\\n\");\n\t\t\tgoto err_gpios;\n\t\t}\n\t}\n\n\t \n\tspi_set_drvdata(spi, st);\n\treturn 0;\n\n err_gpios:\n\twhile (--ptr >= 0)\n\t\tdevice_remove_file(&spi->dev, gpio_attrs[ptr]);\n\n\tdevice_remove_file(&spi->dev, &dev_attr_status_show);\n\n err_status:\n\tkfree(st);\n\treturn ret;\n}\n\nstatic void tle62x0_remove(struct spi_device *spi)\n{\n\tstruct tle62x0_state *st = spi_get_drvdata(spi);\n\tint ptr;\n\n\tfor (ptr = 0; ptr < st->nr_gpio; ptr++)\n\t\tdevice_remove_file(&spi->dev, gpio_attrs[ptr]);\n\n\tdevice_remove_file(&spi->dev, &dev_attr_status_show);\n\tkfree(st);\n}\n\nstatic struct spi_driver tle62x0_driver = {\n\t.driver = {\n\t\t.name\t= \"tle62x0\",\n\t},\n\t.probe\t\t= tle62x0_probe,\n\t.remove\t\t= tle62x0_remove,\n};\n\nmodule_spi_driver(tle62x0_driver);\n\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_DESCRIPTION(\"TLE62x0 SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:tle62x0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}