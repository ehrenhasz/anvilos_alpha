{
  "module_name": "spi-intel.c",
  "hash_id": "74980eb9778a5bc0959b01d77373163b610c192e1f2d35a90726c705b60648d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-intel.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/module.h>\n\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spi-nor.h>\n\n#include <linux/spi/flash.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#include \"spi-intel.h\"\n\n \n#define BFPREG\t\t\t\t0x00\n\n#define HSFSTS_CTL\t\t\t0x04\n#define HSFSTS_CTL_FSMIE\t\tBIT(31)\n#define HSFSTS_CTL_FDBC_SHIFT\t\t24\n#define HSFSTS_CTL_FDBC_MASK\t\t(0x3f << HSFSTS_CTL_FDBC_SHIFT)\n\n#define HSFSTS_CTL_FCYCLE_SHIFT\t\t17\n#define HSFSTS_CTL_FCYCLE_MASK\t\t(0x0f << HSFSTS_CTL_FCYCLE_SHIFT)\n \n#define HSFSTS_CTL_FCYCLE_READ\t\t(0x00 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_WRITE\t\t(0x02 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_ERASE\t\t(0x03 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_ERASE_64K\t(0x04 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_RDSFDP\t(0x05 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_RDID\t\t(0x06 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_WRSR\t\t(0x07 << HSFSTS_CTL_FCYCLE_SHIFT)\n#define HSFSTS_CTL_FCYCLE_RDSR\t\t(0x08 << HSFSTS_CTL_FCYCLE_SHIFT)\n\n#define HSFSTS_CTL_FGO\t\t\tBIT(16)\n#define HSFSTS_CTL_FLOCKDN\t\tBIT(15)\n#define HSFSTS_CTL_FDV\t\t\tBIT(14)\n#define HSFSTS_CTL_SCIP\t\t\tBIT(5)\n#define HSFSTS_CTL_AEL\t\t\tBIT(2)\n#define HSFSTS_CTL_FCERR\t\tBIT(1)\n#define HSFSTS_CTL_FDONE\t\tBIT(0)\n\n#define FADDR\t\t\t\t0x08\n#define DLOCK\t\t\t\t0x0c\n#define FDATA(n)\t\t\t(0x10 + ((n) * 4))\n\n#define FRACC\t\t\t\t0x50\n\n#define FREG(n)\t\t\t\t(0x54 + ((n) * 4))\n#define FREG_BASE_MASK\t\t\tGENMASK(14, 0)\n#define FREG_LIMIT_SHIFT\t\t16\n#define FREG_LIMIT_MASK\t\t\tGENMASK(30, 16)\n\n \n#define PR(n)\t\t\t\t((n) * 4)\n#define PR_WPE\t\t\t\tBIT(31)\n#define PR_LIMIT_SHIFT\t\t\t16\n#define PR_LIMIT_MASK\t\t\tGENMASK(30, 16)\n#define PR_RPE\t\t\t\tBIT(15)\n#define PR_BASE_MASK\t\t\tGENMASK(14, 0)\n\n \n#define SSFSTS_CTL\t\t\t0x00\n#define SSFSTS_CTL_FSMIE\t\tBIT(23)\n#define SSFSTS_CTL_DS\t\t\tBIT(22)\n#define SSFSTS_CTL_DBC_SHIFT\t\t16\n#define SSFSTS_CTL_SPOP\t\t\tBIT(11)\n#define SSFSTS_CTL_ACS\t\t\tBIT(10)\n#define SSFSTS_CTL_SCGO\t\t\tBIT(9)\n#define SSFSTS_CTL_COP_SHIFT\t\t12\n#define SSFSTS_CTL_FRS\t\t\tBIT(7)\n#define SSFSTS_CTL_DOFRS\t\tBIT(6)\n#define SSFSTS_CTL_AEL\t\t\tBIT(4)\n#define SSFSTS_CTL_FCERR\t\tBIT(3)\n#define SSFSTS_CTL_FDONE\t\tBIT(2)\n#define SSFSTS_CTL_SCIP\t\t\tBIT(0)\n\n#define PREOP_OPTYPE\t\t\t0x04\n#define OPMENU0\t\t\t\t0x08\n#define OPMENU1\t\t\t\t0x0c\n\n#define OPTYPE_READ_NO_ADDR\t\t0\n#define OPTYPE_WRITE_NO_ADDR\t\t1\n#define OPTYPE_READ_WITH_ADDR\t\t2\n#define OPTYPE_WRITE_WITH_ADDR\t\t3\n\n \n#define BYT_PR\t\t\t\t0x74\n#define BYT_SSFSTS_CTL\t\t\t0x90\n#define BYT_FREG_NUM\t\t\t5\n#define BYT_PR_NUM\t\t\t5\n\n#define LPT_PR\t\t\t\t0x74\n#define LPT_SSFSTS_CTL\t\t\t0x90\n#define LPT_FREG_NUM\t\t\t5\n#define LPT_PR_NUM\t\t\t5\n\n#define BXT_PR\t\t\t\t0x84\n#define BXT_SSFSTS_CTL\t\t\t0xa0\n#define BXT_FREG_NUM\t\t\t12\n#define BXT_PR_NUM\t\t\t5\n\n#define CNL_PR\t\t\t\t0x84\n#define CNL_FREG_NUM\t\t\t6\n#define CNL_PR_NUM\t\t\t5\n\n#define LVSCC\t\t\t\t0xc4\n#define UVSCC\t\t\t\t0xc8\n#define ERASE_OPCODE_SHIFT\t\t8\n#define ERASE_OPCODE_MASK\t\t(0xff << ERASE_OPCODE_SHIFT)\n#define ERASE_64K_OPCODE_SHIFT\t\t16\n#define ERASE_64K_OPCODE_MASK\t\t(0xff << ERASE_64K_OPCODE_SHIFT)\n\n \n#define FLVALSIG_MAGIC\t\t\t0x0ff0a55a\n#define FLMAP0_NC_MASK\t\t\tGENMASK(9, 8)\n#define FLMAP0_NC_SHIFT\t\t\t8\n#define FLMAP0_FCBA_MASK\t\tGENMASK(7, 0)\n\n#define FLCOMP_C0DEN_MASK\t\tGENMASK(3, 0)\n#define FLCOMP_C0DEN_512K\t\t0x00\n#define FLCOMP_C0DEN_1M\t\t\t0x01\n#define FLCOMP_C0DEN_2M\t\t\t0x02\n#define FLCOMP_C0DEN_4M\t\t\t0x03\n#define FLCOMP_C0DEN_8M\t\t\t0x04\n#define FLCOMP_C0DEN_16M\t\t0x05\n#define FLCOMP_C0DEN_32M\t\t0x06\n#define FLCOMP_C0DEN_64M\t\t0x07\n\n#define INTEL_SPI_TIMEOUT\t\t5000  \n#define INTEL_SPI_FIFO_SZ\t\t64\n\n \nstruct intel_spi {\n\tstruct device *dev;\n\tconst struct intel_spi_boardinfo *info;\n\tvoid __iomem *base;\n\tvoid __iomem *pregs;\n\tvoid __iomem *sregs;\n\tstruct spi_controller *host;\n\tsize_t nregions;\n\tsize_t pr_num;\n\tsize_t chip0_size;\n\tbool locked;\n\tbool swseq_reg;\n\tbool swseq_erase;\n\tu8 atomic_preopcode;\n\tu8 opcodes[8];\n\tconst struct intel_spi_mem_op *mem_ops;\n};\n\nstruct intel_spi_mem_op {\n\tstruct spi_mem_op mem_op;\n\tu32 replacement_op;\n\tint (*exec_op)(struct intel_spi *ispi,\n\t\t       const struct spi_mem *mem,\n\t\t       const struct intel_spi_mem_op *iop,\n\t\t       const struct spi_mem_op *op);\n};\n\nstatic bool writeable;\nmodule_param(writeable, bool, 0);\nMODULE_PARM_DESC(writeable, \"Enable write access to SPI flash chip (default=0)\");\n\nstatic void intel_spi_dump_regs(struct intel_spi *ispi)\n{\n\tu32 value;\n\tint i;\n\n\tdev_dbg(ispi->dev, \"BFPREG=0x%08x\\n\", readl(ispi->base + BFPREG));\n\n\tvalue = readl(ispi->base + HSFSTS_CTL);\n\tdev_dbg(ispi->dev, \"HSFSTS_CTL=0x%08x\\n\", value);\n\tif (value & HSFSTS_CTL_FLOCKDN)\n\t\tdev_dbg(ispi->dev, \"-> Locked\\n\");\n\n\tdev_dbg(ispi->dev, \"FADDR=0x%08x\\n\", readl(ispi->base + FADDR));\n\tdev_dbg(ispi->dev, \"DLOCK=0x%08x\\n\", readl(ispi->base + DLOCK));\n\n\tfor (i = 0; i < 16; i++)\n\t\tdev_dbg(ispi->dev, \"FDATA(%d)=0x%08x\\n\",\n\t\t\ti, readl(ispi->base + FDATA(i)));\n\n\tdev_dbg(ispi->dev, \"FRACC=0x%08x\\n\", readl(ispi->base + FRACC));\n\n\tfor (i = 0; i < ispi->nregions; i++)\n\t\tdev_dbg(ispi->dev, \"FREG(%d)=0x%08x\\n\", i,\n\t\t\treadl(ispi->base + FREG(i)));\n\tfor (i = 0; i < ispi->pr_num; i++)\n\t\tdev_dbg(ispi->dev, \"PR(%d)=0x%08x\\n\", i,\n\t\t\treadl(ispi->pregs + PR(i)));\n\n\tif (ispi->sregs) {\n\t\tvalue = readl(ispi->sregs + SSFSTS_CTL);\n\t\tdev_dbg(ispi->dev, \"SSFSTS_CTL=0x%08x\\n\", value);\n\t\tdev_dbg(ispi->dev, \"PREOP_OPTYPE=0x%08x\\n\",\n\t\t\treadl(ispi->sregs + PREOP_OPTYPE));\n\t\tdev_dbg(ispi->dev, \"OPMENU0=0x%08x\\n\",\n\t\t\treadl(ispi->sregs + OPMENU0));\n\t\tdev_dbg(ispi->dev, \"OPMENU1=0x%08x\\n\",\n\t\t\treadl(ispi->sregs + OPMENU1));\n\t}\n\n\tdev_dbg(ispi->dev, \"LVSCC=0x%08x\\n\", readl(ispi->base + LVSCC));\n\tdev_dbg(ispi->dev, \"UVSCC=0x%08x\\n\", readl(ispi->base + UVSCC));\n\n\tdev_dbg(ispi->dev, \"Protected regions:\\n\");\n\tfor (i = 0; i < ispi->pr_num; i++) {\n\t\tu32 base, limit;\n\n\t\tvalue = readl(ispi->pregs + PR(i));\n\t\tif (!(value & (PR_WPE | PR_RPE)))\n\t\t\tcontinue;\n\n\t\tlimit = (value & PR_LIMIT_MASK) >> PR_LIMIT_SHIFT;\n\t\tbase = value & PR_BASE_MASK;\n\n\t\tdev_dbg(ispi->dev, \" %02d base: 0x%08x limit: 0x%08x [%c%c]\\n\",\n\t\t\ti, base << 12, (limit << 12) | 0xfff,\n\t\t\tvalue & PR_WPE ? 'W' : '.', value & PR_RPE ? 'R' : '.');\n\t}\n\n\tdev_dbg(ispi->dev, \"Flash regions:\\n\");\n\tfor (i = 0; i < ispi->nregions; i++) {\n\t\tu32 region, base, limit;\n\n\t\tregion = readl(ispi->base + FREG(i));\n\t\tbase = region & FREG_BASE_MASK;\n\t\tlimit = (region & FREG_LIMIT_MASK) >> FREG_LIMIT_SHIFT;\n\n\t\tif (base >= limit || (i > 0 && limit == 0))\n\t\t\tdev_dbg(ispi->dev, \" %02d disabled\\n\", i);\n\t\telse\n\t\t\tdev_dbg(ispi->dev, \" %02d base: 0x%08x limit: 0x%08x\\n\",\n\t\t\t\ti, base << 12, (limit << 12) | 0xfff);\n\t}\n\n\tdev_dbg(ispi->dev, \"Using %cW sequencer for register access\\n\",\n\t\tispi->swseq_reg ? 'S' : 'H');\n\tdev_dbg(ispi->dev, \"Using %cW sequencer for erase operation\\n\",\n\t\tispi->swseq_erase ? 'S' : 'H');\n}\n\n \nstatic int intel_spi_read_block(struct intel_spi *ispi, void *buf, size_t size)\n{\n\tsize_t bytes;\n\tint i = 0;\n\n\tif (size > INTEL_SPI_FIFO_SZ)\n\t\treturn -EINVAL;\n\n\twhile (size > 0) {\n\t\tbytes = min_t(size_t, size, 4);\n\t\tmemcpy_fromio(buf, ispi->base + FDATA(i), bytes);\n\t\tsize -= bytes;\n\t\tbuf += bytes;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int intel_spi_write_block(struct intel_spi *ispi, const void *buf,\n\t\t\t\t size_t size)\n{\n\tsize_t bytes;\n\tint i = 0;\n\n\tif (size > INTEL_SPI_FIFO_SZ)\n\t\treturn -EINVAL;\n\n\twhile (size > 0) {\n\t\tbytes = min_t(size_t, size, 4);\n\t\tmemcpy_toio(ispi->base + FDATA(i), buf, bytes);\n\t\tsize -= bytes;\n\t\tbuf += bytes;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_spi_wait_hw_busy(struct intel_spi *ispi)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(ispi->base + HSFSTS_CTL, val,\n\t\t\t\t  !(val & HSFSTS_CTL_SCIP), 0,\n\t\t\t\t  INTEL_SPI_TIMEOUT * 1000);\n}\n\nstatic int intel_spi_wait_sw_busy(struct intel_spi *ispi)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(ispi->sregs + SSFSTS_CTL, val,\n\t\t\t\t  !(val & SSFSTS_CTL_SCIP), 0,\n\t\t\t\t  INTEL_SPI_TIMEOUT * 1000);\n}\n\nstatic bool intel_spi_set_writeable(struct intel_spi *ispi)\n{\n\tif (!ispi->info->set_writeable)\n\t\treturn false;\n\n\treturn ispi->info->set_writeable(ispi->base, ispi->info->data);\n}\n\nstatic int intel_spi_opcode_index(struct intel_spi *ispi, u8 opcode, int optype)\n{\n\tint i;\n\tint preop;\n\n\tif (ispi->locked) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ispi->opcodes); i++)\n\t\t\tif (ispi->opcodes[i] == opcode)\n\t\t\t\treturn i;\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twritel(opcode, ispi->sregs + OPMENU0);\n\tpreop = readw(ispi->sregs + PREOP_OPTYPE);\n\twritel(optype << 16 | preop, ispi->sregs + PREOP_OPTYPE);\n\n\treturn 0;\n}\n\nstatic int intel_spi_hw_cycle(struct intel_spi *ispi,\n\t\t\t      const struct intel_spi_mem_op *iop, size_t len)\n{\n\tu32 val, status;\n\tint ret;\n\n\tif (!iop->replacement_op)\n\t\treturn -EINVAL;\n\n\tval = readl(ispi->base + HSFSTS_CTL);\n\tval &= ~(HSFSTS_CTL_FCYCLE_MASK | HSFSTS_CTL_FDBC_MASK);\n\tval |= (len - 1) << HSFSTS_CTL_FDBC_SHIFT;\n\tval |= HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\n\tval |= HSFSTS_CTL_FGO;\n\tval |= iop->replacement_op;\n\twritel(val, ispi->base + HSFSTS_CTL);\n\n\tret = intel_spi_wait_hw_busy(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = readl(ispi->base + HSFSTS_CTL);\n\tif (status & HSFSTS_CTL_FCERR)\n\t\treturn -EIO;\n\telse if (status & HSFSTS_CTL_AEL)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int intel_spi_sw_cycle(struct intel_spi *ispi, u8 opcode, size_t len,\n\t\t\t      int optype)\n{\n\tu32 val = 0, status;\n\tu8 atomic_preopcode;\n\tint ret;\n\n\tret = intel_spi_opcode_index(ispi, opcode, optype);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tatomic_preopcode = ispi->atomic_preopcode;\n\tispi->atomic_preopcode = 0;\n\n\t \n\tif (len > 0)\n\t\tval = ((len - 1) << SSFSTS_CTL_DBC_SHIFT) | SSFSTS_CTL_DS;\n\tval |= ret << SSFSTS_CTL_COP_SHIFT;\n\tval |= SSFSTS_CTL_FCERR | SSFSTS_CTL_FDONE;\n\tval |= SSFSTS_CTL_SCGO;\n\tif (atomic_preopcode) {\n\t\tu16 preop;\n\n\t\tswitch (optype) {\n\t\tcase OPTYPE_WRITE_NO_ADDR:\n\t\tcase OPTYPE_WRITE_WITH_ADDR:\n\t\t\t \n\t\t\tpreop = readw(ispi->sregs + PREOP_OPTYPE);\n\t\t\tif ((preop & 0xff) == atomic_preopcode)\n\t\t\t\t;  \n\t\t\telse if ((preop >> 8) == atomic_preopcode)\n\t\t\t\tval |= SSFSTS_CTL_SPOP;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tval |= SSFSTS_CTL_ACS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\twritel(val, ispi->sregs + SSFSTS_CTL);\n\n\tret = intel_spi_wait_sw_busy(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = readl(ispi->sregs + SSFSTS_CTL);\n\tif (status & SSFSTS_CTL_FCERR)\n\t\treturn -EIO;\n\telse if (status & SSFSTS_CTL_AEL)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic u32 intel_spi_chip_addr(const struct intel_spi *ispi,\n\t\t\t       const struct spi_mem *mem)\n{\n\t \n\tif (!mem)\n\t\treturn 0;\n\treturn (spi_get_chipselect(mem->spi, 0) == 1) ? ispi->chip0_size : 0;\n}\n\nstatic int intel_spi_read_reg(struct intel_spi *ispi, const struct spi_mem *mem,\n\t\t\t      const struct intel_spi_mem_op *iop,\n\t\t\t      const struct spi_mem_op *op)\n{\n\tu32 addr = intel_spi_chip_addr(ispi, mem) + op->addr.val;\n\tsize_t nbytes = op->data.nbytes;\n\tu8 opcode = op->cmd.opcode;\n\tint ret;\n\n\twritel(addr, ispi->base + FADDR);\n\n\tif (ispi->swseq_reg)\n\t\tret = intel_spi_sw_cycle(ispi, opcode, nbytes,\n\t\t\t\t\t OPTYPE_READ_NO_ADDR);\n\telse\n\t\tret = intel_spi_hw_cycle(ispi, iop, nbytes);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn intel_spi_read_block(ispi, op->data.buf.in, nbytes);\n}\n\nstatic int intel_spi_write_reg(struct intel_spi *ispi, const struct spi_mem *mem,\n\t\t\t       const struct intel_spi_mem_op *iop,\n\t\t\t       const struct spi_mem_op *op)\n{\n\tu32 addr = intel_spi_chip_addr(ispi, mem) + op->addr.val;\n\tsize_t nbytes = op->data.nbytes;\n\tu8 opcode = op->cmd.opcode;\n\tint ret;\n\n\t \n\tif (opcode == SPINOR_OP_WREN) {\n\t\tu16 preop;\n\n\t\tif (!ispi->swseq_reg)\n\t\t\treturn 0;\n\n\t\tpreop = readw(ispi->sregs + PREOP_OPTYPE);\n\t\tif ((preop & 0xff) != opcode && (preop >> 8) != opcode) {\n\t\t\tif (ispi->locked)\n\t\t\t\treturn -EINVAL;\n\t\t\twritel(opcode, ispi->sregs + PREOP_OPTYPE);\n\t\t}\n\n\t\t \n\t\tispi->atomic_preopcode = opcode;\n\t\treturn 0;\n\t}\n\n\t \n\tif (opcode == SPINOR_OP_WRDI)\n\t\treturn 0;\n\n\twritel(addr, ispi->base + FADDR);\n\n\t \n\tret = intel_spi_write_block(ispi, op->data.buf.out, nbytes);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ispi->swseq_reg)\n\t\treturn intel_spi_sw_cycle(ispi, opcode, nbytes,\n\t\t\t\t\t  OPTYPE_WRITE_NO_ADDR);\n\treturn intel_spi_hw_cycle(ispi, iop, nbytes);\n}\n\nstatic int intel_spi_read(struct intel_spi *ispi, const struct spi_mem *mem,\n\t\t\t  const struct intel_spi_mem_op *iop,\n\t\t\t  const struct spi_mem_op *op)\n{\n\tu32 addr = intel_spi_chip_addr(ispi, mem) + op->addr.val;\n\tsize_t block_size, nbytes = op->data.nbytes;\n\tvoid *read_buf = op->data.buf.in;\n\tu32 val, status;\n\tint ret;\n\n\t \n\tif (WARN_ON_ONCE(ispi->atomic_preopcode))\n\t\tispi->atomic_preopcode = 0;\n\n\twhile (nbytes > 0) {\n\t\tblock_size = min_t(size_t, nbytes, INTEL_SPI_FIFO_SZ);\n\n\t\t \n\t\tblock_size = min_t(loff_t, addr + block_size,\n\t\t\t\t   round_up(addr + 1, SZ_4K)) - addr;\n\n\t\twritel(addr, ispi->base + FADDR);\n\n\t\tval = readl(ispi->base + HSFSTS_CTL);\n\t\tval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\n\t\tval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\n\t\tval |= (block_size - 1) << HSFSTS_CTL_FDBC_SHIFT;\n\t\tval |= HSFSTS_CTL_FCYCLE_READ;\n\t\tval |= HSFSTS_CTL_FGO;\n\t\twritel(val, ispi->base + HSFSTS_CTL);\n\n\t\tret = intel_spi_wait_hw_busy(ispi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstatus = readl(ispi->base + HSFSTS_CTL);\n\t\tif (status & HSFSTS_CTL_FCERR)\n\t\t\tret = -EIO;\n\t\telse if (status & HSFSTS_CTL_AEL)\n\t\t\tret = -EACCES;\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(ispi->dev, \"read error: %x: %#x\\n\", addr, status);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = intel_spi_read_block(ispi, read_buf, block_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnbytes -= block_size;\n\t\taddr += block_size;\n\t\tread_buf += block_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_spi_write(struct intel_spi *ispi, const struct spi_mem *mem,\n\t\t\t   const struct intel_spi_mem_op *iop,\n\t\t\t   const struct spi_mem_op *op)\n{\n\tu32 addr = intel_spi_chip_addr(ispi, mem) + op->addr.val;\n\tsize_t block_size, nbytes = op->data.nbytes;\n\tconst void *write_buf = op->data.buf.out;\n\tu32 val, status;\n\tint ret;\n\n\t \n\tispi->atomic_preopcode = 0;\n\n\twhile (nbytes > 0) {\n\t\tblock_size = min_t(size_t, nbytes, INTEL_SPI_FIFO_SZ);\n\n\t\t \n\t\tblock_size = min_t(loff_t, addr + block_size,\n\t\t\t\t   round_up(addr + 1, SZ_4K)) - addr;\n\n\t\twritel(addr, ispi->base + FADDR);\n\n\t\tval = readl(ispi->base + HSFSTS_CTL);\n\t\tval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\n\t\tval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\n\t\tval |= (block_size - 1) << HSFSTS_CTL_FDBC_SHIFT;\n\t\tval |= HSFSTS_CTL_FCYCLE_WRITE;\n\n\t\tret = intel_spi_write_block(ispi, write_buf, block_size);\n\t\tif (ret) {\n\t\t\tdev_err(ispi->dev, \"failed to write block\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tval |= HSFSTS_CTL_FGO;\n\t\twritel(val, ispi->base + HSFSTS_CTL);\n\n\t\tret = intel_spi_wait_hw_busy(ispi);\n\t\tif (ret) {\n\t\t\tdev_err(ispi->dev, \"timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tstatus = readl(ispi->base + HSFSTS_CTL);\n\t\tif (status & HSFSTS_CTL_FCERR)\n\t\t\tret = -EIO;\n\t\telse if (status & HSFSTS_CTL_AEL)\n\t\t\tret = -EACCES;\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(ispi->dev, \"write error: %x: %#x\\n\", addr, status);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnbytes -= block_size;\n\t\taddr += block_size;\n\t\twrite_buf += block_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_spi_erase(struct intel_spi *ispi, const struct spi_mem *mem,\n\t\t\t   const struct intel_spi_mem_op *iop,\n\t\t\t   const struct spi_mem_op *op)\n{\n\tu32 addr = intel_spi_chip_addr(ispi, mem) + op->addr.val;\n\tu8 opcode = op->cmd.opcode;\n\tu32 val, status;\n\tint ret;\n\n\twritel(addr, ispi->base + FADDR);\n\n\tif (ispi->swseq_erase)\n\t\treturn intel_spi_sw_cycle(ispi, opcode, 0,\n\t\t\t\t\t  OPTYPE_WRITE_WITH_ADDR);\n\n\t \n\tispi->atomic_preopcode = 0;\n\n\tval = readl(ispi->base + HSFSTS_CTL);\n\tval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\n\tval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\n\tval |= HSFSTS_CTL_FGO;\n\tval |= iop->replacement_op;\n\twritel(val, ispi->base + HSFSTS_CTL);\n\n\tret = intel_spi_wait_hw_busy(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = readl(ispi->base + HSFSTS_CTL);\n\tif (status & HSFSTS_CTL_FCERR)\n\t\treturn -EIO;\n\tif (status & HSFSTS_CTL_AEL)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int intel_spi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\top->data.nbytes = clamp_val(op->data.nbytes, 0, INTEL_SPI_FIFO_SZ);\n\treturn 0;\n}\n\nstatic bool intel_spi_cmp_mem_op(const struct intel_spi_mem_op *iop,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tif (iop->mem_op.cmd.nbytes != op->cmd.nbytes ||\n\t    iop->mem_op.cmd.buswidth != op->cmd.buswidth ||\n\t    iop->mem_op.cmd.dtr != op->cmd.dtr ||\n\t    iop->mem_op.cmd.opcode != op->cmd.opcode)\n\t\treturn false;\n\n\tif (iop->mem_op.addr.nbytes != op->addr.nbytes ||\n\t    iop->mem_op.addr.dtr != op->addr.dtr)\n\t\treturn false;\n\n\tif (iop->mem_op.data.dir != op->data.dir ||\n\t    iop->mem_op.data.dtr != op->data.dtr)\n\t\treturn false;\n\n\tif (iop->mem_op.data.dir != SPI_MEM_NO_DATA) {\n\t\tif (iop->mem_op.data.buswidth != op->data.buswidth)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const struct intel_spi_mem_op *\nintel_spi_match_mem_op(struct intel_spi *ispi, const struct spi_mem_op *op)\n{\n\tconst struct intel_spi_mem_op *iop;\n\n\tfor (iop = ispi->mem_ops; iop->mem_op.cmd.opcode; iop++) {\n\t\tif (intel_spi_cmp_mem_op(iop, op))\n\t\t\tbreak;\n\t}\n\n\treturn iop->mem_op.cmd.opcode ? iop : NULL;\n}\n\nstatic bool intel_spi_supports_mem_op(struct spi_mem *mem,\n\t\t\t\t      const struct spi_mem_op *op)\n{\n\tstruct intel_spi *ispi = spi_controller_get_devdata(mem->spi->controller);\n\tconst struct intel_spi_mem_op *iop;\n\n\tiop = intel_spi_match_mem_op(ispi, op);\n\tif (!iop) {\n\t\tdev_dbg(ispi->dev, \"%#x not supported\\n\", op->cmd.opcode);\n\t\treturn false;\n\t}\n\n\t \n\tif (ispi->swseq_reg && ispi->locked) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ispi->opcodes); i++) {\n\t\t\tif (ispi->opcodes[i] == op->cmd.opcode)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tdev_dbg(ispi->dev, \"%#x not supported\\n\", op->cmd.opcode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int intel_spi_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct intel_spi *ispi = spi_controller_get_devdata(mem->spi->controller);\n\tconst struct intel_spi_mem_op *iop;\n\n\tiop = intel_spi_match_mem_op(ispi, op);\n\tif (!iop)\n\t\treturn -EOPNOTSUPP;\n\n\treturn iop->exec_op(ispi, mem, iop, op);\n}\n\nstatic const char *intel_spi_get_name(struct spi_mem *mem)\n{\n\tconst struct intel_spi *ispi = spi_controller_get_devdata(mem->spi->controller);\n\n\t \n\treturn dev_name(ispi->dev);\n}\n\nstatic int intel_spi_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct intel_spi *ispi = spi_controller_get_devdata(desc->mem->spi->controller);\n\tconst struct intel_spi_mem_op *iop;\n\n\tiop = intel_spi_match_mem_op(ispi, &desc->info.op_tmpl);\n\tif (!iop)\n\t\treturn -EOPNOTSUPP;\n\n\tdesc->priv = (void *)iop;\n\treturn 0;\n}\n\nstatic ssize_t intel_spi_dirmap_read(struct spi_mem_dirmap_desc *desc, u64 offs,\n\t\t\t\t     size_t len, void *buf)\n{\n\tstruct intel_spi *ispi = spi_controller_get_devdata(desc->mem->spi->controller);\n\tconst struct intel_spi_mem_op *iop = desc->priv;\n\tstruct spi_mem_op op = desc->info.op_tmpl;\n\tint ret;\n\n\t \n\top.addr.val = offs;\n\top.data.nbytes = len;\n\top.data.buf.in = buf;\n\n\tret = iop->exec_op(ispi, desc->mem, iop, &op);\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t intel_spi_dirmap_write(struct spi_mem_dirmap_desc *desc, u64 offs,\n\t\t\t\t      size_t len, const void *buf)\n{\n\tstruct intel_spi *ispi = spi_controller_get_devdata(desc->mem->spi->controller);\n\tconst struct intel_spi_mem_op *iop = desc->priv;\n\tstruct spi_mem_op op = desc->info.op_tmpl;\n\tint ret;\n\n\top.addr.val = offs;\n\top.data.nbytes = len;\n\top.data.buf.out = buf;\n\n\tret = iop->exec_op(ispi, desc->mem, iop, &op);\n\treturn ret ? ret : len;\n}\n\nstatic const struct spi_controller_mem_ops intel_spi_mem_ops = {\n\t.adjust_op_size = intel_spi_adjust_op_size,\n\t.supports_op = intel_spi_supports_mem_op,\n\t.exec_op = intel_spi_exec_mem_op,\n\t.get_name = intel_spi_get_name,\n\t.dirmap_create = intel_spi_dirmap_create,\n\t.dirmap_read = intel_spi_dirmap_read,\n\t.dirmap_write = intel_spi_dirmap_write,\n};\n\n#define INTEL_SPI_OP_ADDR(__nbytes)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.nbytes = __nbytes,\t\t\t\t\t\\\n\t}\n\n#define INTEL_SPI_OP_NO_DATA\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.dir = SPI_MEM_NO_DATA,\t\t\t\t\t\\\n\t}\n\n#define INTEL_SPI_OP_DATA_IN(__buswidth)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.dir = SPI_MEM_DATA_IN,\t\t\t\t\t\\\n\t\t.buswidth = __buswidth,\t\t\t\t\t\\\n\t}\n\n#define INTEL_SPI_OP_DATA_OUT(__buswidth)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.dir = SPI_MEM_DATA_OUT,\t\t\t\t\\\n\t\t.buswidth = __buswidth,\t\t\t\t\t\\\n\t}\n\n#define INTEL_SPI_MEM_OP(__cmd, __addr, __data, __exec_op)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.mem_op = {\t\t\t\t\t\t\\\n\t\t\t.cmd = __cmd,\t\t\t\t\t\\\n\t\t\t.addr = __addr,\t\t\t\t\t\\\n\t\t\t.data = __data,\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.exec_op = __exec_op,\t\t\t\t\t\\\n\t}\n\n#define INTEL_SPI_MEM_OP_REPL(__cmd, __addr, __data, __exec_op, __repl)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.mem_op = {\t\t\t\t\t\t\\\n\t\t\t.cmd = __cmd,\t\t\t\t\t\\\n\t\t\t.addr = __addr,\t\t\t\t\t\\\n\t\t\t.data = __data,\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.exec_op = __exec_op,\t\t\t\t\t\\\n\t\t.replacement_op = __repl,\t\t\t\t\\\n\t}\n\n \n#define INTEL_SPI_GENERIC_OPS\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_RDID, 1),\t\\\n\t\t\t      SPI_MEM_OP_NO_ADDR,\t\t\t\\\n\t\t\t      INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t      intel_spi_read_reg,\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_RDID),\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_RDSR, 1),\t\\\n\t\t\t      SPI_MEM_OP_NO_ADDR,\t\t\t\\\n\t\t\t      INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t      intel_spi_read_reg,\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_RDSR),\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_WRSR, 1),\t\\\n\t\t\t      SPI_MEM_OP_NO_ADDR,\t\t\t\\\n\t\t\t      INTEL_SPI_OP_DATA_OUT(1),\t\t\t\\\n\t\t\t      intel_spi_write_reg,\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_WRSR),\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_RDSFDP, 1),\t\\\n\t\t\t      INTEL_SPI_OP_ADDR(3),\t\t\t\\\n\t\t\t      INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t      intel_spi_read_reg,\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_RDSFDP),\t\t\\\n\t \t\t\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\t \t\t\t\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\t \t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_4B, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_4B, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_4B, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\t \t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST_4B, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(1),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST_4B, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(2),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ_FAST_4B, 1),\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_IN(4),\t\t\t\\\n\t\t\t intel_spi_read),\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_PP, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(3),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_OUT(1),\t\t\t\\\n\t\t\t intel_spi_write),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_PP, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_OUT(1),\t\t\t\\\n\t\t\t intel_spi_write),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_PP_4B, 1),\t\t\\\n\t\t\t INTEL_SPI_OP_ADDR(4),\t\t\t\t\\\n\t\t\t INTEL_SPI_OP_DATA_OUT(1),\t\t\t\\\n\t\t\t intel_spi_write),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_WREN, 1),\t\t\\\n\t\t\t SPI_MEM_OP_NO_ADDR,\t\t\t\t\\\n\t\t\t SPI_MEM_OP_NO_DATA,\t\t\t\t\\\n\t\t\t intel_spi_write_reg),\t\t\t\t\\\n\tINTEL_SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_WRDI, 1),\t\t\\\n\t\t\t SPI_MEM_OP_NO_ADDR,\t\t\t\t\\\n\t\t\t SPI_MEM_OP_NO_DATA,\t\t\t\t\\\n\t\t\t intel_spi_write_reg),\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_BE_4K, 1),\t\\\n\t\t\t      INTEL_SPI_OP_ADDR(3),\t\t\t\\\n\t\t\t      SPI_MEM_OP_NO_DATA,\t\t\t\\\n\t\t\t      intel_spi_erase,\t\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE),\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_BE_4K, 1),\t\\\n\t\t\t      INTEL_SPI_OP_ADDR(4),\t\t\t\\\n\t\t\t      SPI_MEM_OP_NO_DATA,\t\t\t\\\n\t\t\t      intel_spi_erase,\t\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE),\t\t\t\\\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_BE_4K_4B, 1),\t\\\n\t\t\t      INTEL_SPI_OP_ADDR(4),\t\t\t\\\n\t\t\t      SPI_MEM_OP_NO_DATA,\t\t\t\\\n\t\t\t      intel_spi_erase,\t\t\t\t\\\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE)\t\t\t\\\n\nstatic const struct intel_spi_mem_op generic_mem_ops[] = {\n\tINTEL_SPI_GENERIC_OPS,\n\t{ },\n};\n\nstatic const struct intel_spi_mem_op erase_64k_mem_ops[] = {\n\tINTEL_SPI_GENERIC_OPS,\n\t \n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_SE, 1),\n\t\t\t      INTEL_SPI_OP_ADDR(3),\n\t\t\t      SPI_MEM_OP_NO_DATA,\n\t\t\t      intel_spi_erase,\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE_64K),\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_SE, 1),\n\t\t\t      INTEL_SPI_OP_ADDR(4),\n\t\t\t      SPI_MEM_OP_NO_DATA,\n\t\t\t      intel_spi_erase,\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE_64K),\n\tINTEL_SPI_MEM_OP_REPL(SPI_MEM_OP_CMD(SPINOR_OP_SE_4B, 1),\n\t\t\t      INTEL_SPI_OP_ADDR(4),\n\t\t\t      SPI_MEM_OP_NO_DATA,\n\t\t\t      intel_spi_erase,\n\t\t\t      HSFSTS_CTL_FCYCLE_ERASE_64K),\n\t{ },\n};\n\nstatic int intel_spi_init(struct intel_spi *ispi)\n{\n\tu32 opmenu0, opmenu1, lvscc, uvscc, val;\n\tbool erase_64k = false;\n\tint i;\n\n\tswitch (ispi->info->type) {\n\tcase INTEL_SPI_BYT:\n\t\tispi->sregs = ispi->base + BYT_SSFSTS_CTL;\n\t\tispi->pregs = ispi->base + BYT_PR;\n\t\tispi->nregions = BYT_FREG_NUM;\n\t\tispi->pr_num = BYT_PR_NUM;\n\t\tispi->swseq_reg = true;\n\t\tbreak;\n\n\tcase INTEL_SPI_LPT:\n\t\tispi->sregs = ispi->base + LPT_SSFSTS_CTL;\n\t\tispi->pregs = ispi->base + LPT_PR;\n\t\tispi->nregions = LPT_FREG_NUM;\n\t\tispi->pr_num = LPT_PR_NUM;\n\t\tispi->swseq_reg = true;\n\t\tbreak;\n\n\tcase INTEL_SPI_BXT:\n\t\tispi->sregs = ispi->base + BXT_SSFSTS_CTL;\n\t\tispi->pregs = ispi->base + BXT_PR;\n\t\tispi->nregions = BXT_FREG_NUM;\n\t\tispi->pr_num = BXT_PR_NUM;\n\t\terase_64k = true;\n\t\tbreak;\n\n\tcase INTEL_SPI_CNL:\n\t\tispi->sregs = NULL;\n\t\tispi->pregs = ispi->base + CNL_PR;\n\t\tispi->nregions = CNL_FREG_NUM;\n\t\tispi->pr_num = CNL_PR_NUM;\n\t\terase_64k = true;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (writeable && !intel_spi_set_writeable(ispi)) {\n\t\tdev_warn(ispi->dev, \"can't disable chip write protection\\n\");\n\t\twriteable = false;\n\t}\n\n\t \n\tval = readl(ispi->base + HSFSTS_CTL);\n\tval &= ~HSFSTS_CTL_FSMIE;\n\twritel(val, ispi->base + HSFSTS_CTL);\n\n\t \n\tlvscc = readl(ispi->base + LVSCC);\n\tuvscc = readl(ispi->base + UVSCC);\n\tif (!(lvscc & ERASE_OPCODE_MASK) || !(uvscc & ERASE_OPCODE_MASK))\n\t\tispi->swseq_erase = true;\n\t \n\tif (ispi->info->type == INTEL_SPI_BXT && !ispi->swseq_erase)\n\t\tif (!(lvscc & ERASE_64K_OPCODE_MASK) ||\n\t\t    !(uvscc & ERASE_64K_OPCODE_MASK))\n\t\t\terase_64k = false;\n\n\tif (!ispi->sregs && (ispi->swseq_reg || ispi->swseq_erase)) {\n\t\tdev_err(ispi->dev, \"software sequencer not supported, but required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ispi->swseq_reg) {\n\t\t \n\t\tval = readl(ispi->sregs + SSFSTS_CTL);\n\t\tval &= ~SSFSTS_CTL_FSMIE;\n\t\twritel(val, ispi->sregs + SSFSTS_CTL);\n\t}\n\n\t \n\tval = readl(ispi->base + HSFSTS_CTL);\n\tispi->locked = !!(val & HSFSTS_CTL_FLOCKDN);\n\n\tif (ispi->locked && ispi->sregs) {\n\t\t \n\t\topmenu0 = readl(ispi->sregs + OPMENU0);\n\t\topmenu1 = readl(ispi->sregs + OPMENU1);\n\n\t\tif (opmenu0 && opmenu1) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(ispi->opcodes) / 2; i++) {\n\t\t\t\tispi->opcodes[i] = opmenu0 >> i * 8;\n\t\t\t\tispi->opcodes[i + 4] = opmenu1 >> i * 8;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (erase_64k) {\n\t\tdev_dbg(ispi->dev, \"Using erase_64k memory operations\");\n\t\tispi->mem_ops = erase_64k_mem_ops;\n\t} else {\n\t\tdev_dbg(ispi->dev, \"Using generic memory operations\");\n\t\tispi->mem_ops = generic_mem_ops;\n\t}\n\n\tintel_spi_dump_regs(ispi);\n\treturn 0;\n}\n\nstatic bool intel_spi_is_protected(const struct intel_spi *ispi,\n\t\t\t\t   unsigned int base, unsigned int limit)\n{\n\tint i;\n\n\tfor (i = 0; i < ispi->pr_num; i++) {\n\t\tu32 pr_base, pr_limit, pr_value;\n\n\t\tpr_value = readl(ispi->pregs + PR(i));\n\t\tif (!(pr_value & (PR_WPE | PR_RPE)))\n\t\t\tcontinue;\n\n\t\tpr_limit = (pr_value & PR_LIMIT_MASK) >> PR_LIMIT_SHIFT;\n\t\tpr_base = pr_value & PR_BASE_MASK;\n\n\t\tif (pr_base >= base && pr_limit <= limit)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void intel_spi_fill_partition(struct intel_spi *ispi,\n\t\t\t\t     struct mtd_partition *part)\n{\n\tu64 end;\n\tint i;\n\n\tmemset(part, 0, sizeof(*part));\n\n\t \n\tpart->size = 4096;\n\tpart->name = \"BIOS\";\n\n\t \n\tfor (i = 1; i < ispi->nregions; i++) {\n\t\tu32 region, base, limit;\n\n\t\tregion = readl(ispi->base + FREG(i));\n\t\tbase = region & FREG_BASE_MASK;\n\t\tlimit = (region & FREG_LIMIT_MASK) >> FREG_LIMIT_SHIFT;\n\n\t\tif (base >= limit || limit == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!writeable || intel_spi_is_protected(ispi, base, limit))\n\t\t\tpart->mask_flags |= MTD_WRITEABLE;\n\n\t\tend = (limit << 12) + 4096;\n\t\tif (end > part->size)\n\t\t\tpart->size = end;\n\t}\n}\n\nstatic int intel_spi_read_desc(struct intel_spi *ispi)\n{\n\tstruct spi_mem_op op =\n\t\tSPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_READ, 0),\n\t\t\t   SPI_MEM_OP_ADDR(3, 0, 0),\n\t\t\t   SPI_MEM_OP_NO_DUMMY,\n\t\t\t   SPI_MEM_OP_DATA_IN(0, NULL, 0));\n\tu32 buf[2], nc, fcba, flcomp;\n\tssize_t ret;\n\n\top.addr.val = 0x10;\n\top.data.buf.in = buf;\n\top.data.nbytes = sizeof(buf);\n\n\tret = intel_spi_read(ispi, NULL, NULL, &op);\n\tif (ret) {\n\t\tdev_warn(ispi->dev, \"failed to read descriptor\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(ispi->dev, \"FLVALSIG=0x%08x\\n\", buf[0]);\n\tdev_dbg(ispi->dev, \"FLMAP0=0x%08x\\n\", buf[1]);\n\n\tif (buf[0] != FLVALSIG_MAGIC) {\n\t\tdev_warn(ispi->dev, \"descriptor signature not valid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfcba = (buf[1] & FLMAP0_FCBA_MASK) << 4;\n\tdev_dbg(ispi->dev, \"FCBA=%#x\\n\", fcba);\n\n\top.addr.val = fcba;\n\top.data.buf.in = &flcomp;\n\top.data.nbytes = sizeof(flcomp);\n\n\tret = intel_spi_read(ispi, NULL, NULL, &op);\n\tif (ret) {\n\t\tdev_warn(ispi->dev, \"failed to read FLCOMP\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(ispi->dev, \"FLCOMP=0x%08x\\n\", flcomp);\n\n\tswitch (flcomp & FLCOMP_C0DEN_MASK) {\n\tcase FLCOMP_C0DEN_512K:\n\t\tispi->chip0_size = SZ_512K;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_1M:\n\t\tispi->chip0_size = SZ_1M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_2M:\n\t\tispi->chip0_size = SZ_2M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_4M:\n\t\tispi->chip0_size = SZ_4M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_8M:\n\t\tispi->chip0_size = SZ_8M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_16M:\n\t\tispi->chip0_size = SZ_16M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_32M:\n\t\tispi->chip0_size = SZ_32M;\n\t\tbreak;\n\tcase FLCOMP_C0DEN_64M:\n\t\tispi->chip0_size = SZ_64M;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ispi->dev, \"chip0 size %zd KB\\n\", ispi->chip0_size / SZ_1K);\n\n\tnc = (buf[1] & FLMAP0_NC_MASK) >> FLMAP0_NC_SHIFT;\n\tif (!nc)\n\t\tispi->host->num_chipselect = 1;\n\telse if (nc == 1)\n\t\tispi->host->num_chipselect = 2;\n\telse\n\t\treturn -EINVAL;\n\n\tdev_dbg(ispi->dev, \"%u flash components found\\n\",\n\t\tispi->host->num_chipselect);\n\treturn 0;\n}\n\nstatic int intel_spi_populate_chip(struct intel_spi *ispi)\n{\n\tstruct flash_platform_data *pdata;\n\tstruct spi_board_info chip;\n\tint ret;\n\n\tpdata = devm_kzalloc(ispi->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->nr_parts = 1;\n\tpdata->parts = devm_kcalloc(ispi->dev, pdata->nr_parts,\n\t\t\t\t    sizeof(*pdata->parts), GFP_KERNEL);\n\tif (!pdata->parts)\n\t\treturn -ENOMEM;\n\n\tintel_spi_fill_partition(ispi, pdata->parts);\n\n\tmemset(&chip, 0, sizeof(chip));\n\tsnprintf(chip.modalias, 8, \"spi-nor\");\n\tchip.platform_data = pdata;\n\n\tif (!spi_new_device(ispi->host, &chip))\n\t\treturn -ENODEV;\n\n\tret = intel_spi_read_desc(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ispi->host->num_chipselect < 2)\n\t\treturn 0;\n\n\tchip.platform_data = NULL;\n\tchip.chip_select = 1;\n\n\tif (!spi_new_device(ispi->host, &chip))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n \nint intel_spi_probe(struct device *dev, struct resource *mem,\n\t\t    const struct intel_spi_boardinfo *info)\n{\n\tstruct spi_controller *host;\n\tstruct intel_spi *ispi;\n\tint ret;\n\n\thost = devm_spi_alloc_host(dev, sizeof(*ispi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->mem_ops = &intel_spi_mem_ops;\n\n\tispi = spi_controller_get_devdata(host);\n\n\tispi->base = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(ispi->base))\n\t\treturn PTR_ERR(ispi->base);\n\n\tispi->dev = dev;\n\tispi->host = host;\n\tispi->info = info;\n\n\tret = intel_spi_init(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret)\n\t\treturn ret;\n\n\treturn intel_spi_populate_chip(ispi);\n}\nEXPORT_SYMBOL_GPL(intel_spi_probe);\n\nMODULE_DESCRIPTION(\"Intel PCH/PCU SPI flash core driver\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}