{
  "module_name": "spi-gxp.c",
  "hash_id": "666257cb903853dee3060fd5f091ff7058b683cf71d65570620a0f082839f013",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-gxp.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#define GXP_SPI0_MAX_CHIPSELECT\t2\n#define GXP_SPI_SLEEP_TIME\t1\n#define GXP_SPI_TIMEOUT (130 * 1000000 / GXP_SPI_SLEEP_TIME)\n\n#define MANUAL_MODE\t\t0\n#define DIRECT_MODE\t\t1\n#define SPILDAT_LEN\t\t256\n\n#define OFFSET_SPIMCFG\t\t0x0\n#define OFFSET_SPIMCTRL\t\t0x4\n#define OFFSET_SPICMD\t\t0x5\n#define OFFSET_SPIDCNT\t\t0x6\n#define OFFSET_SPIADDR\t\t0x8\n#define OFFSET_SPIINTSTS\t0xc\n\n#define SPIMCTRL_START\t\t0x01\n#define SPIMCTRL_BUSY\t\t0x02\n#define SPIMCTRL_DIR\t\t0x08\n\nstruct gxp_spi;\n\nstruct gxp_spi_chip {\n\tstruct gxp_spi *spifi;\n\tu32 cs;\n};\n\nstruct gxp_spi_data {\n\tu32 max_cs;\n\tu32 mode_bits;\n};\n\nstruct gxp_spi {\n\tconst struct gxp_spi_data *data;\n\tvoid __iomem *reg_base;\n\tvoid __iomem *dat_base;\n\tvoid __iomem *dir_base;\n\tstruct device *dev;\n\tstruct gxp_spi_chip chips[GXP_SPI0_MAX_CHIPSELECT];\n};\n\nstatic void gxp_spi_set_mode(struct gxp_spi *spifi, int mode)\n{\n\tu8 value;\n\tvoid __iomem *reg_base = spifi->reg_base;\n\n\tvalue = readb(reg_base + OFFSET_SPIMCTRL);\n\n\tif (mode == MANUAL_MODE) {\n\t\twriteb(0x55, reg_base + OFFSET_SPICMD);\n\t\twriteb(0xaa, reg_base + OFFSET_SPICMD);\n\t\tvalue &= ~0x30;\n\t} else {\n\t\tvalue |= 0x30;\n\t}\n\twriteb(value, reg_base + OFFSET_SPIMCTRL);\n}\n\nstatic int gxp_spi_read_reg(struct gxp_spi_chip *chip, const struct spi_mem_op *op)\n{\n\tint ret;\n\tstruct gxp_spi *spifi = chip->spifi;\n\tvoid __iomem *reg_base = spifi->reg_base;\n\tu32 value;\n\n\tvalue = readl(reg_base + OFFSET_SPIMCFG);\n\tvalue &= ~(1 << 24);\n\tvalue |= (chip->cs << 24);\n\tvalue &= ~(0x07 << 16);\n\tvalue &= ~(0x1f << 19);\n\twritel(value, reg_base + OFFSET_SPIMCFG);\n\n\twritel(0, reg_base + OFFSET_SPIADDR);\n\n\twriteb(op->cmd.opcode, reg_base + OFFSET_SPICMD);\n\n\twritew(op->data.nbytes, reg_base + OFFSET_SPIDCNT);\n\n\tvalue = readb(reg_base + OFFSET_SPIMCTRL);\n\tvalue &= ~SPIMCTRL_DIR;\n\tvalue |= SPIMCTRL_START;\n\n\twriteb(value, reg_base + OFFSET_SPIMCTRL);\n\n\tret = readb_poll_timeout(reg_base + OFFSET_SPIMCTRL, value,\n\t\t\t\t !(value & SPIMCTRL_BUSY),\n\t\t\t\t GXP_SPI_SLEEP_TIME, GXP_SPI_TIMEOUT);\n\tif (ret) {\n\t\tdev_warn(spifi->dev, \"read reg busy time out\\n\");\n\t\treturn ret;\n\t}\n\n\tmemcpy_fromio(op->data.buf.in, spifi->dat_base, op->data.nbytes);\n\treturn ret;\n}\n\nstatic int gxp_spi_write_reg(struct gxp_spi_chip *chip, const struct spi_mem_op *op)\n{\n\tint ret;\n\tstruct gxp_spi *spifi = chip->spifi;\n\tvoid __iomem *reg_base = spifi->reg_base;\n\tu32 value;\n\n\tvalue = readl(reg_base + OFFSET_SPIMCFG);\n\tvalue &= ~(1 << 24);\n\tvalue |= (chip->cs << 24);\n\tvalue &= ~(0x07 << 16);\n\tvalue &= ~(0x1f << 19);\n\twritel(value, reg_base + OFFSET_SPIMCFG);\n\n\twritel(0, reg_base + OFFSET_SPIADDR);\n\n\twriteb(op->cmd.opcode, reg_base + OFFSET_SPICMD);\n\n\tmemcpy_toio(spifi->dat_base, op->data.buf.in, op->data.nbytes);\n\n\twritew(op->data.nbytes, reg_base + OFFSET_SPIDCNT);\n\n\tvalue = readb(reg_base + OFFSET_SPIMCTRL);\n\tvalue |= SPIMCTRL_DIR;\n\tvalue |= SPIMCTRL_START;\n\n\twriteb(value, reg_base + OFFSET_SPIMCTRL);\n\n\tret = readb_poll_timeout(reg_base + OFFSET_SPIMCTRL, value,\n\t\t\t\t !(value & SPIMCTRL_BUSY),\n\t\t\t\t GXP_SPI_SLEEP_TIME, GXP_SPI_TIMEOUT);\n\tif (ret)\n\t\tdev_warn(spifi->dev, \"write reg busy time out\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t gxp_spi_read(struct gxp_spi_chip *chip, const struct spi_mem_op *op)\n{\n\tstruct gxp_spi *spifi = chip->spifi;\n\tu32 offset = op->addr.val;\n\n\tif (chip->cs == 0)\n\t\toffset += 0x4000000;\n\n\tmemcpy_fromio(op->data.buf.in, spifi->dir_base + offset, op->data.nbytes);\n\n\treturn 0;\n}\n\nstatic ssize_t gxp_spi_write(struct gxp_spi_chip *chip, const struct spi_mem_op *op)\n{\n\tstruct gxp_spi *spifi = chip->spifi;\n\tvoid __iomem *reg_base = spifi->reg_base;\n\tu32 write_len;\n\tu32 value;\n\tint ret;\n\n\twrite_len = op->data.nbytes;\n\tif (write_len > SPILDAT_LEN)\n\t\twrite_len = SPILDAT_LEN;\n\n\tvalue = readl(reg_base + OFFSET_SPIMCFG);\n\tvalue &= ~(1 << 24);\n\tvalue |= (chip->cs << 24);\n\tvalue &= ~(0x07 << 16);\n\tvalue |= (op->addr.nbytes << 16);\n\tvalue &= ~(0x1f << 19);\n\twritel(value, reg_base + OFFSET_SPIMCFG);\n\n\twritel(op->addr.val, reg_base + OFFSET_SPIADDR);\n\n\twriteb(op->cmd.opcode, reg_base + OFFSET_SPICMD);\n\n\twritew(write_len, reg_base + OFFSET_SPIDCNT);\n\n\tmemcpy_toio(spifi->dat_base, op->data.buf.in, write_len);\n\n\tvalue = readb(reg_base + OFFSET_SPIMCTRL);\n\tvalue |= SPIMCTRL_DIR;\n\tvalue |= SPIMCTRL_START;\n\n\twriteb(value, reg_base + OFFSET_SPIMCTRL);\n\n\tret = readb_poll_timeout(reg_base + OFFSET_SPIMCTRL, value,\n\t\t\t\t !(value & SPIMCTRL_BUSY),\n\t\t\t\t GXP_SPI_SLEEP_TIME, GXP_SPI_TIMEOUT);\n\tif (ret) {\n\t\tdev_warn(spifi->dev, \"write busy time out\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_gxp_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct gxp_spi *spifi = spi_controller_get_devdata(mem->spi->controller);\n\tstruct gxp_spi_chip *chip = &spifi->chips[spi_get_chipselect(mem->spi, 0)];\n\tint ret;\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (!op->addr.nbytes)\n\t\t\tret = gxp_spi_read_reg(chip, op);\n\t\telse\n\t\t\tret = gxp_spi_read(chip, op);\n\t} else {\n\t\tif (!op->addr.nbytes)\n\t\t\tret = gxp_spi_write_reg(chip, op);\n\t\telse\n\t\t\tret = gxp_spi_write(chip, op);\n\t}\n\n\treturn ret;\n}\n\nstatic int gxp_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tint ret;\n\n\tret = do_gxp_exec_mem_op(mem, op);\n\tif (ret)\n\t\tdev_err(&mem->spi->dev, \"operation failed: %d\", ret);\n\n\treturn ret;\n}\n\nstatic const struct spi_controller_mem_ops gxp_spi_mem_ops = {\n\t.exec_op = gxp_exec_mem_op,\n};\n\nstatic int gxp_spi_setup(struct spi_device *spi)\n{\n\tstruct gxp_spi *spifi = spi_controller_get_devdata(spi->controller);\n\tunsigned int cs = spi_get_chipselect(spi, 0);\n\tstruct gxp_spi_chip *chip = &spifi->chips[cs];\n\n\tchip->spifi = spifi;\n\tchip->cs = cs;\n\n\tgxp_spi_set_mode(spifi, MANUAL_MODE);\n\n\treturn 0;\n}\n\nstatic int gxp_spifi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct gxp_spi_data *data;\n\tstruct spi_controller *ctlr;\n\tstruct gxp_spi *spifi;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\tctlr = devm_spi_alloc_host(dev, sizeof(*spifi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tspifi = spi_controller_get_devdata(ctlr);\n\n\tplatform_set_drvdata(pdev, spifi);\n\tspifi->data = data;\n\tspifi->dev = dev;\n\n\tspifi->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spifi->reg_base))\n\t\treturn PTR_ERR(spifi->reg_base);\n\n\tspifi->dat_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(spifi->dat_base))\n\t\treturn PTR_ERR(spifi->dat_base);\n\n\tspifi->dir_base = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(spifi->dir_base))\n\t\treturn PTR_ERR(spifi->dir_base);\n\n\tctlr->mode_bits = data->mode_bits;\n\tctlr->bus_num = pdev->id;\n\tctlr->mem_ops = &gxp_spi_mem_ops;\n\tctlr->setup = gxp_spi_setup;\n\tctlr->num_chipselect = data->max_cs;\n\tctlr->dev.of_node = dev->of_node;\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret) {\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to register spi controller\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct gxp_spi_data gxp_spifi_data = {\n\t.max_cs\t= 2,\n\t.mode_bits = 0,\n};\n\nstatic const struct of_device_id gxp_spifi_match[] = {\n\t{.compatible = \"hpe,gxp-spifi\", .data = &gxp_spifi_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, gxp_spifi_match);\n\nstatic struct platform_driver gxp_spifi_driver = {\n\t.probe = gxp_spifi_probe,\n\t.driver = {\n\t\t.name = \"gxp-spifi\",\n\t\t.of_match_table = gxp_spifi_match,\n\t},\n};\nmodule_platform_driver(gxp_spifi_driver);\n\nMODULE_DESCRIPTION(\"HPE GXP SPI Flash Interface driver\");\nMODULE_AUTHOR(\"Nick Hawkins <nick.hawkins@hpe.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}