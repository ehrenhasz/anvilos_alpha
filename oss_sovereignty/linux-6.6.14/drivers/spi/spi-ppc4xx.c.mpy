{
  "module_name": "spi-ppc4xx.c",
  "hash_id": "a8d1ae901d6ea8133e90153162a771b5a53250e94ae53ca3c96a2e5c77c71d32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ppc4xx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/wait.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n\n#include <linux/io.h>\n#include <asm/dcr.h>\n#include <asm/dcr-regs.h>\n\n \n\n \n#define SPI_PPC4XX_MODE_SCP\t(0x80 >> 3)\n\n \n#define SPI_PPC4XX_MODE_SPE\t(0x80 >> 4)\n\n \n#define SPI_PPC4XX_MODE_RD\t(0x80 >> 5)\n\n \n#define SPI_PPC4XX_MODE_CI\t(0x80 >> 6)\n\n \n#define SPI_PPC4XX_MODE_IL\t(0x80 >> 7)\n\n \n \n#define SPI_PPC4XX_CR_STR\t(0x80 >> 7)\n\n \n \n#define SPI_PPC4XX_SR_BSY\t(0x80 >> 6)\n \n#define SPI_PPC4XX_SR_RBR\t(0x80 >> 7)\n\n \n#define SPI_CLK_MODE0\t(SPI_PPC4XX_MODE_SCP | 0)\n#define SPI_CLK_MODE1\t(0 | 0)\n#define SPI_CLK_MODE2\t(SPI_PPC4XX_MODE_SCP | SPI_PPC4XX_MODE_CI)\n#define SPI_CLK_MODE3\t(0 | SPI_PPC4XX_MODE_CI)\n\n#define DRIVER_NAME\t\"spi_ppc4xx_of\"\n\nstruct spi_ppc4xx_regs {\n\tu8 mode;\n\tu8 rxd;\n\tu8 txd;\n\tu8 cr;\n\tu8 sr;\n\tu8 dummy;\n\t \n\tu8 cdm;\n};\n\n \nstruct ppc4xx_spi {\n\t \n\tstruct spi_bitbang bitbang;\n\tstruct completion done;\n\n\tu64 mapbase;\n\tu64 mapsize;\n\tint irqnum;\n\t \n\tunsigned int opb_freq;\n\n\t \n\tint len;\n\tint count;\n\t \n\tconst unsigned char *tx;\n\tunsigned char *rx;\n\n\tstruct spi_ppc4xx_regs __iomem *regs;  \n\tstruct spi_controller *host;\n\tstruct device *dev;\n};\n\n \nstruct spi_ppc4xx_cs {\n\tu8 mode;\n};\n\nstatic int spi_ppc4xx_txrx(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct ppc4xx_spi *hw;\n\tu8 data;\n\n\tdev_dbg(&spi->dev, \"txrx: tx %p, rx %p, len %d\\n\",\n\t\tt->tx_buf, t->rx_buf, t->len);\n\n\thw = spi_controller_get_devdata(spi->controller);\n\n\thw->tx = t->tx_buf;\n\thw->rx = t->rx_buf;\n\thw->len = t->len;\n\thw->count = 0;\n\n\t \n\tdata = hw->tx ? hw->tx[0] : 0;\n\tout_8(&hw->regs->txd, data);\n\tout_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);\n\twait_for_completion(&hw->done);\n\n\treturn hw->count;\n}\n\nstatic int spi_ppc4xx_setupxfer(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct ppc4xx_spi *hw = spi_controller_get_devdata(spi->controller);\n\tstruct spi_ppc4xx_cs *cs = spi->controller_state;\n\tint scr;\n\tu8 cdm = 0;\n\tu32 speed;\n\tu8 bits_per_word;\n\n\t \n\tbits_per_word = spi->bits_per_word;\n\tspeed = spi->max_speed_hz;\n\n\t \n\tif (t) {\n\t\tif (t->bits_per_word)\n\t\t\tbits_per_word = t->bits_per_word;\n\n\t\tif (t->speed_hz)\n\t\t\tspeed = min(t->speed_hz, spi->max_speed_hz);\n\t}\n\n\tif (!speed || (speed > spi->max_speed_hz)) {\n\t\tdev_err(&spi->dev, \"invalid speed_hz (%d)\\n\", speed);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tout_8(&hw->regs->mode, cs->mode);\n\n\t \n\t \n\tscr = (hw->opb_freq / speed) - 1;\n\tif (scr > 0)\n\t\tcdm = min(scr, 0xff);\n\n\tdev_dbg(&spi->dev, \"setting pre-scaler to %d (hz %d)\\n\", cdm, speed);\n\n\tif (in_8(&hw->regs->cdm) != cdm)\n\t\tout_8(&hw->regs->cdm, cdm);\n\n\tmutex_lock(&hw->bitbang.lock);\n\tif (!hw->bitbang.busy) {\n\t\thw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);\n\t\t \n\t}\n\tmutex_unlock(&hw->bitbang.lock);\n\n\treturn 0;\n}\n\nstatic int spi_ppc4xx_setup(struct spi_device *spi)\n{\n\tstruct spi_ppc4xx_cs *cs = spi->controller_state;\n\n\tif (!spi->max_speed_hz) {\n\t\tdev_err(&spi->dev, \"invalid max_speed_hz (must be non-zero)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cs == NULL) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tspi->controller_state = cs;\n\t}\n\n\t \n\tcs->mode = SPI_PPC4XX_MODE_SPE;\n\n\tswitch (spi->mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\t\tcs->mode |= SPI_CLK_MODE0;\n\t\tbreak;\n\tcase SPI_MODE_1:\n\t\tcs->mode |= SPI_CLK_MODE1;\n\t\tbreak;\n\tcase SPI_MODE_2:\n\t\tcs->mode |= SPI_CLK_MODE2;\n\t\tbreak;\n\tcase SPI_MODE_3:\n\t\tcs->mode |= SPI_CLK_MODE3;\n\t\tbreak;\n\t}\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tcs->mode |= SPI_PPC4XX_MODE_RD;\n\n\treturn 0;\n}\n\nstatic irqreturn_t spi_ppc4xx_int(int irq, void *dev_id)\n{\n\tstruct ppc4xx_spi *hw;\n\tu8 status;\n\tu8 data;\n\tunsigned int count;\n\n\thw = (struct ppc4xx_spi *)dev_id;\n\n\tstatus = in_8(&hw->regs->sr);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\n\tif (unlikely(status & SPI_PPC4XX_SR_BSY)) {\n\t\tu8 lstatus;\n\t\tint cnt = 0;\n\n\t\tdev_dbg(hw->dev, \"got interrupt but spi still busy?\\n\");\n\t\tdo {\n\t\t\tndelay(10);\n\t\t\tlstatus = in_8(&hw->regs->sr);\n\t\t} while (++cnt < 100 && lstatus & SPI_PPC4XX_SR_BSY);\n\n\t\tif (cnt >= 100) {\n\t\t\tdev_err(hw->dev, \"busywait: too many loops!\\n\");\n\t\t\tcomplete(&hw->done);\n\t\t\treturn IRQ_HANDLED;\n\t\t} else {\n\t\t\t \n\t\t\tstatus = in_8(&hw->regs->sr);\n\t\t\tdev_dbg(hw->dev, \"loops %d status %x\\n\", cnt, status);\n\t\t}\n\t}\n\n\tcount = hw->count;\n\thw->count++;\n\n\t \n\tdata = in_8(&hw->regs->rxd);\n\tif (hw->rx)\n\t\thw->rx[count] = data;\n\n\tcount++;\n\n\tif (count < hw->len) {\n\t\tdata = hw->tx ? hw->tx[count] : 0;\n\t\tout_8(&hw->regs->txd, data);\n\t\tout_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);\n\t} else {\n\t\tcomplete(&hw->done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void spi_ppc4xx_cleanup(struct spi_device *spi)\n{\n\tkfree(spi->controller_state);\n}\n\nstatic void spi_ppc4xx_enable(struct ppc4xx_spi *hw)\n{\n\t \n\n\t \n\tdcri_clrset(SDR0, SDR0_PFC1, 0x80000000 >> 14, 0);\n}\n\n \nstatic int spi_ppc4xx_of_probe(struct platform_device *op)\n{\n\tstruct ppc4xx_spi *hw;\n\tstruct spi_controller *host;\n\tstruct spi_bitbang *bbp;\n\tstruct resource resource;\n\tstruct device_node *np = op->dev.of_node;\n\tstruct device *dev = &op->dev;\n\tstruct device_node *opbnp;\n\tint ret;\n\tconst unsigned int *clk;\n\n\thost = spi_alloc_host(dev, sizeof(*hw));\n\tif (host == NULL)\n\t\treturn -ENOMEM;\n\thost->dev.of_node = np;\n\tplatform_set_drvdata(op, host);\n\thw = spi_controller_get_devdata(host);\n\thw->host = host;\n\thw->dev = dev;\n\n\tinit_completion(&hw->done);\n\n\t \n\tbbp = &hw->bitbang;\n\tbbp->master = hw->host;\n\tbbp->setup_transfer = spi_ppc4xx_setupxfer;\n\tbbp->txrx_bufs = spi_ppc4xx_txrx;\n\tbbp->use_dma = 0;\n\tbbp->master->setup = spi_ppc4xx_setup;\n\tbbp->master->cleanup = spi_ppc4xx_cleanup;\n\tbbp->master->bits_per_word_mask = SPI_BPW_MASK(8);\n\tbbp->master->use_gpio_descriptors = true;\n\t \n\tbbp->master->num_chipselect = 0;\n\n\t \n\tbbp->master->mode_bits =\n\t\tSPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST;\n\n\t \n\topbnp = of_find_compatible_node(NULL, NULL, \"ibm,opb\");\n\tif (opbnp == NULL) {\n\t\tdev_err(dev, \"OPB: cannot find node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_host;\n\t}\n\t \n\tclk = of_get_property(opbnp, \"clock-frequency\", NULL);\n\tif (clk == NULL) {\n\t\tdev_err(dev, \"OPB: no clock-frequency property set\\n\");\n\t\tof_node_put(opbnp);\n\t\tret = -ENODEV;\n\t\tgoto free_host;\n\t}\n\thw->opb_freq = *clk;\n\thw->opb_freq >>= 2;\n\tof_node_put(opbnp);\n\n\tret = of_address_to_resource(np, 0, &resource);\n\tif (ret) {\n\t\tdev_err(dev, \"error while parsing device node resource\\n\");\n\t\tgoto free_host;\n\t}\n\thw->mapbase = resource.start;\n\thw->mapsize = resource_size(&resource);\n\n\t \n\tif (hw->mapsize < sizeof(struct spi_ppc4xx_regs)) {\n\t\tdev_err(dev, \"too small to map registers\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_host;\n\t}\n\n\t \n\thw->irqnum = irq_of_parse_and_map(np, 0);\n\tret = request_irq(hw->irqnum, spi_ppc4xx_int,\n\t\t\t  0, \"spi_ppc4xx_of\", (void *)hw);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to allocate interrupt\\n\");\n\t\tgoto free_host;\n\t}\n\n\tif (!request_mem_region(hw->mapbase, hw->mapsize, DRIVER_NAME)) {\n\t\tdev_err(dev, \"resource unavailable\\n\");\n\t\tret = -EBUSY;\n\t\tgoto request_mem_error;\n\t}\n\n\thw->regs = ioremap(hw->mapbase, sizeof(struct spi_ppc4xx_regs));\n\n\tif (!hw->regs) {\n\t\tdev_err(dev, \"unable to memory map registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto map_io_error;\n\t}\n\n\tspi_ppc4xx_enable(hw);\n\n\t \n\tdev->dma_mask = 0;\n\tret = spi_bitbang_start(bbp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register SPI host\\n\");\n\t\tgoto unmap_regs;\n\t}\n\n\tdev_info(dev, \"driver initialized\\n\");\n\n\treturn 0;\n\nunmap_regs:\n\tiounmap(hw->regs);\nmap_io_error:\n\trelease_mem_region(hw->mapbase, hw->mapsize);\nrequest_mem_error:\n\tfree_irq(hw->irqnum, hw);\nfree_host:\n\tspi_controller_put(host);\n\n\tdev_err(dev, \"initialization failed\\n\");\n\treturn ret;\n}\n\nstatic void spi_ppc4xx_of_remove(struct platform_device *op)\n{\n\tstruct spi_controller *host = platform_get_drvdata(op);\n\tstruct ppc4xx_spi *hw = spi_controller_get_devdata(host);\n\n\tspi_bitbang_stop(&hw->bitbang);\n\trelease_mem_region(hw->mapbase, hw->mapsize);\n\tfree_irq(hw->irqnum, hw);\n\tiounmap(hw->regs);\n\tspi_controller_put(host);\n}\n\nstatic const struct of_device_id spi_ppc4xx_of_match[] = {\n\t{ .compatible = \"ibm,ppc4xx-spi\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, spi_ppc4xx_of_match);\n\nstatic struct platform_driver spi_ppc4xx_of_driver = {\n\t.probe = spi_ppc4xx_of_probe,\n\t.remove_new = spi_ppc4xx_of_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = spi_ppc4xx_of_match,\n\t},\n};\nmodule_platform_driver(spi_ppc4xx_of_driver);\n\nMODULE_AUTHOR(\"Gary Jennejohn & Stefan Roese\");\nMODULE_DESCRIPTION(\"Simple PPC4xx SPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}