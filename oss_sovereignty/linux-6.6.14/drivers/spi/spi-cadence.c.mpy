{
  "module_name": "spi-cadence.c",
  "hash_id": "f01181ed6c12c926fd649fa63602cf7790240271ae291f16532fe4c4eca17972",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-cadence.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n\n \n#define CDNS_SPI_NAME\t\t\"cdns-spi\"\n\n \n#define CDNS_SPI_CR\t0x00  \n#define CDNS_SPI_ISR\t0x04  \n#define CDNS_SPI_IER\t0x08  \n#define CDNS_SPI_IDR\t0x0c  \n#define CDNS_SPI_IMR\t0x10  \n#define CDNS_SPI_ER\t0x14  \n#define CDNS_SPI_DR\t0x18  \n#define CDNS_SPI_TXD\t0x1C  \n#define CDNS_SPI_RXD\t0x20  \n#define CDNS_SPI_SICR\t0x24  \n#define CDNS_SPI_THLD\t0x28  \n\n#define SPI_AUTOSUSPEND_TIMEOUT\t\t3000\n \n#define CDNS_SPI_CR_MANSTRT\t0x00010000  \n#define CDNS_SPI_CR_CPHA\t\t0x00000004  \n#define CDNS_SPI_CR_CPOL\t\t0x00000002  \n#define CDNS_SPI_CR_SSCTRL\t\t0x00003C00  \n#define CDNS_SPI_CR_PERI_SEL\t0x00000200  \n#define CDNS_SPI_CR_BAUD_DIV\t0x00000038  \n#define CDNS_SPI_CR_MSTREN\t\t0x00000001  \n#define CDNS_SPI_CR_MANSTRTEN\t0x00008000  \n#define CDNS_SPI_CR_SSFORCE\t0x00004000  \n#define CDNS_SPI_CR_BAUD_DIV_4\t0x00000008  \n#define CDNS_SPI_CR_DEFAULT\t(CDNS_SPI_CR_MSTREN | \\\n\t\t\t\t\tCDNS_SPI_CR_SSCTRL | \\\n\t\t\t\t\tCDNS_SPI_CR_SSFORCE | \\\n\t\t\t\t\tCDNS_SPI_CR_BAUD_DIV_4)\n\n \n\n#define CDNS_SPI_BAUD_DIV_MAX\t\t7  \n#define CDNS_SPI_BAUD_DIV_MIN\t\t1  \n#define CDNS_SPI_BAUD_DIV_SHIFT\t\t3  \n#define CDNS_SPI_SS_SHIFT\t\t10  \n#define CDNS_SPI_SS0\t\t\t0x1  \n#define CDNS_SPI_NOSS\t\t\t0xF  \n\n \n#define CDNS_SPI_IXR_TXOW\t0x00000004  \n#define CDNS_SPI_IXR_MODF\t0x00000002  \n#define CDNS_SPI_IXR_RXNEMTY 0x00000010  \n#define CDNS_SPI_IXR_DEFAULT\t(CDNS_SPI_IXR_TXOW | \\\n\t\t\t\t\tCDNS_SPI_IXR_MODF)\n#define CDNS_SPI_IXR_TXFULL\t0x00000008  \n#define CDNS_SPI_IXR_ALL\t0x0000007F  \n\n \n#define CDNS_SPI_ER_ENABLE\t0x00000001  \n#define CDNS_SPI_ER_DISABLE\t0x0  \n\n \n#define CDNS_SPI_DEFAULT_NUM_CS\t\t4\n\n \nstruct cdns_spi {\n\tvoid __iomem *regs;\n\tstruct clk *ref_clk;\n\tstruct clk *pclk;\n\tunsigned int clk_rate;\n\tu32 speed_hz;\n\tconst u8 *txbuf;\n\tu8 *rxbuf;\n\tint tx_bytes;\n\tint rx_bytes;\n\tu8 dev_busy;\n\tu32 is_decoded_cs;\n\tunsigned int tx_fifo_depth;\n};\n\n \nstatic inline u32 cdns_spi_read(struct cdns_spi *xspi, u32 offset)\n{\n\treturn readl_relaxed(xspi->regs + offset);\n}\n\nstatic inline void cdns_spi_write(struct cdns_spi *xspi, u32 offset, u32 val)\n{\n\twritel_relaxed(val, xspi->regs + offset);\n}\n\n \nstatic void cdns_spi_init_hw(struct cdns_spi *xspi, bool is_target)\n{\n\tu32 ctrl_reg = 0;\n\n\tif (!is_target)\n\t\tctrl_reg |= CDNS_SPI_CR_DEFAULT;\n\n\tif (xspi->is_decoded_cs)\n\t\tctrl_reg |= CDNS_SPI_CR_PERI_SEL;\n\n\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\n\tcdns_spi_write(xspi, CDNS_SPI_IDR, CDNS_SPI_IXR_ALL);\n\n\t \n\twhile (cdns_spi_read(xspi, CDNS_SPI_ISR) & CDNS_SPI_IXR_RXNEMTY)\n\t\tcdns_spi_read(xspi, CDNS_SPI_RXD);\n\n\tcdns_spi_write(xspi, CDNS_SPI_ISR, CDNS_SPI_IXR_ALL);\n\tcdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\n\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\n}\n\n \nstatic void cdns_spi_chipselect(struct spi_device *spi, bool is_high)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(spi->controller);\n\tu32 ctrl_reg;\n\n\tctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\n\n\tif (is_high) {\n\t\t \n\t\tctrl_reg |= CDNS_SPI_CR_SSCTRL;\n\t} else {\n\t\t \n\t\tctrl_reg &= ~CDNS_SPI_CR_SSCTRL;\n\t\tif (!(xspi->is_decoded_cs))\n\t\t\tctrl_reg |= ((~(CDNS_SPI_SS0 << spi_get_chipselect(spi, 0))) <<\n\t\t\t\t     CDNS_SPI_SS_SHIFT) &\n\t\t\t\t     CDNS_SPI_CR_SSCTRL;\n\t\telse\n\t\t\tctrl_reg |= (spi_get_chipselect(spi, 0) << CDNS_SPI_SS_SHIFT) &\n\t\t\t\t     CDNS_SPI_CR_SSCTRL;\n\t}\n\n\tcdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\n}\n\n \nstatic void cdns_spi_config_clock_mode(struct spi_device *spi)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(spi->controller);\n\tu32 ctrl_reg, new_ctrl_reg;\n\n\tnew_ctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\n\tctrl_reg = new_ctrl_reg;\n\n\t \n\tnew_ctrl_reg &= ~(CDNS_SPI_CR_CPHA | CDNS_SPI_CR_CPOL);\n\tif (spi->mode & SPI_CPHA)\n\t\tnew_ctrl_reg |= CDNS_SPI_CR_CPHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tnew_ctrl_reg |= CDNS_SPI_CR_CPOL;\n\n\tif (new_ctrl_reg != ctrl_reg) {\n\t\t \n\t\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\n\t\tcdns_spi_write(xspi, CDNS_SPI_CR, new_ctrl_reg);\n\t\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\n\t}\n}\n\n \nstatic void cdns_spi_config_clock_freq(struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *transfer)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(spi->controller);\n\tu32 ctrl_reg, baud_rate_val;\n\tunsigned long frequency;\n\n\tfrequency = xspi->clk_rate;\n\n\tctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\n\n\t \n\tif (xspi->speed_hz != transfer->speed_hz) {\n\t\t \n\t\tbaud_rate_val = CDNS_SPI_BAUD_DIV_MIN;\n\t\twhile ((baud_rate_val < CDNS_SPI_BAUD_DIV_MAX) &&\n\t\t       (frequency / (2 << baud_rate_val)) > transfer->speed_hz)\n\t\t\tbaud_rate_val++;\n\n\t\tctrl_reg &= ~CDNS_SPI_CR_BAUD_DIV;\n\t\tctrl_reg |= baud_rate_val << CDNS_SPI_BAUD_DIV_SHIFT;\n\n\t\txspi->speed_hz = frequency / (2 << baud_rate_val);\n\t}\n\tcdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\n}\n\n \nstatic int cdns_spi_setup_transfer(struct spi_device *spi,\n\t\t\t\t   struct spi_transfer *transfer)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(spi->controller);\n\n\tcdns_spi_config_clock_freq(spi, transfer);\n\n\tdev_dbg(&spi->dev, \"%s, mode %d, %u bits/w, %u clock speed\\n\",\n\t\t__func__, spi->mode, spi->bits_per_word,\n\t\txspi->speed_hz);\n\n\treturn 0;\n}\n\n \nstatic void cdns_spi_process_fifo(struct cdns_spi *xspi, int ntx, int nrx)\n{\n\tntx = clamp(ntx, 0, xspi->tx_bytes);\n\tnrx = clamp(nrx, 0, xspi->rx_bytes);\n\n\txspi->tx_bytes -= ntx;\n\txspi->rx_bytes -= nrx;\n\n\twhile (ntx || nrx) {\n\t\tif (ntx) {\n\t\t\tif (xspi->txbuf)\n\t\t\t\tcdns_spi_write(xspi, CDNS_SPI_TXD, *xspi->txbuf++);\n\t\t\telse\n\t\t\t\tcdns_spi_write(xspi, CDNS_SPI_TXD, 0);\n\n\t\t\tntx--;\n\t\t}\n\n\t\tif (nrx) {\n\t\t\tu8 data = cdns_spi_read(xspi, CDNS_SPI_RXD);\n\n\t\t\tif (xspi->rxbuf)\n\t\t\t\t*xspi->rxbuf++ = data;\n\n\t\t\tnrx--;\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t cdns_spi_irq(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctlr = dev_id;\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\tirqreturn_t status;\n\tu32 intr_status;\n\n\tstatus = IRQ_NONE;\n\tintr_status = cdns_spi_read(xspi, CDNS_SPI_ISR);\n\tcdns_spi_write(xspi, CDNS_SPI_ISR, intr_status);\n\n\tif (intr_status & CDNS_SPI_IXR_MODF) {\n\t\t \n\t\tcdns_spi_write(xspi, CDNS_SPI_IDR, CDNS_SPI_IXR_DEFAULT);\n\t\tspi_finalize_current_transfer(ctlr);\n\t\tstatus = IRQ_HANDLED;\n\t} else if (intr_status & CDNS_SPI_IXR_TXOW) {\n\t\tint threshold = cdns_spi_read(xspi, CDNS_SPI_THLD);\n\t\tint trans_cnt = xspi->rx_bytes - xspi->tx_bytes;\n\n\t\tif (threshold > 1)\n\t\t\ttrans_cnt -= threshold;\n\n\t\t \n\t\tif (xspi->tx_bytes < xspi->tx_fifo_depth >> 1)\n\t\t\tcdns_spi_write(xspi, CDNS_SPI_THLD, 1);\n\n\t\tif (xspi->tx_bytes) {\n\t\t\tcdns_spi_process_fifo(xspi, trans_cnt, trans_cnt);\n\t\t} else {\n\t\t\t \n\t\t\tudelay(10);\n\t\t\tcdns_spi_process_fifo(xspi, 0, trans_cnt);\n\t\t\tcdns_spi_write(xspi, CDNS_SPI_IDR,\n\t\t\t\t       CDNS_SPI_IXR_DEFAULT);\n\t\t\tspi_finalize_current_transfer(ctlr);\n\t\t}\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\treturn status;\n}\n\nstatic int cdns_prepare_message(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_message *msg)\n{\n\tif (!spi_controller_is_target(ctlr))\n\t\tcdns_spi_config_clock_mode(msg->spi);\n\treturn 0;\n}\n\n \nstatic int cdns_transfer_one(struct spi_controller *ctlr,\n\t\t\t     struct spi_device *spi,\n\t\t\t     struct spi_transfer *transfer)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\n\txspi->txbuf = transfer->tx_buf;\n\txspi->rxbuf = transfer->rx_buf;\n\txspi->tx_bytes = transfer->len;\n\txspi->rx_bytes = transfer->len;\n\n\tif (!spi_controller_is_target(ctlr)) {\n\t\tcdns_spi_setup_transfer(spi, transfer);\n\t} else {\n\t\t \n\t\tif (xspi->tx_bytes > xspi->tx_fifo_depth)\n\t\t\tcdns_spi_write(xspi, CDNS_SPI_THLD, xspi->tx_fifo_depth >> 1);\n\t}\n\n\t \n\tif (cdns_spi_read(xspi, CDNS_SPI_ISR) & CDNS_SPI_IXR_TXFULL)\n\t\tudelay(10);\n\n\tcdns_spi_process_fifo(xspi, xspi->tx_fifo_depth, 0);\n\n\tcdns_spi_write(xspi, CDNS_SPI_IER, CDNS_SPI_IXR_DEFAULT);\n\treturn transfer->len;\n}\n\n \nstatic int cdns_prepare_transfer_hardware(struct spi_controller *ctlr)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\n\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\n\n\treturn 0;\n}\n\n \nstatic int cdns_unprepare_transfer_hardware(struct spi_controller *ctlr)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\tu32 ctrl_reg;\n\tunsigned int cnt = xspi->tx_fifo_depth;\n\n\tif (spi_controller_is_target(ctlr)) {\n\t\twhile (cnt--)\n\t\t\tcdns_spi_read(xspi, CDNS_SPI_RXD);\n\t}\n\n\t \n\tctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\n\tctrl_reg = (ctrl_reg & CDNS_SPI_CR_SSCTRL) >>  CDNS_SPI_SS_SHIFT;\n\tif (ctrl_reg == CDNS_SPI_NOSS || spi_controller_is_target(ctlr))\n\t\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\n\n\t \n\tcdns_spi_write(xspi, CDNS_SPI_THLD, 0x1);\n\treturn 0;\n}\n\n \nstatic void cdns_spi_detect_fifo_depth(struct cdns_spi *xspi)\n{\n\t \n\tcdns_spi_write(xspi, CDNS_SPI_THLD, 0xffff);\n\txspi->tx_fifo_depth = cdns_spi_read(xspi, CDNS_SPI_THLD) + 1;\n\n\t \n\tcdns_spi_write(xspi, CDNS_SPI_THLD, 0x1);\n}\n\n \nstatic int cdns_target_abort(struct spi_controller *ctlr)\n{\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\tu32 intr_status;\n\n\tintr_status = cdns_spi_read(xspi, CDNS_SPI_ISR);\n\tcdns_spi_write(xspi, CDNS_SPI_ISR, intr_status);\n\tcdns_spi_write(xspi, CDNS_SPI_IDR, (CDNS_SPI_IXR_MODF | CDNS_SPI_IXR_RXNEMTY));\n\tspi_finalize_current_transfer(ctlr);\n\n\treturn 0;\n}\n\n \nstatic int cdns_spi_probe(struct platform_device *pdev)\n{\n\tint ret = 0, irq;\n\tstruct spi_controller *ctlr;\n\tstruct cdns_spi *xspi;\n\tu32 num_cs;\n\tbool target;\n\n\ttarget = of_property_read_bool(pdev->dev.of_node, \"spi-slave\");\n\tif (target)\n\t\tctlr = spi_alloc_target(&pdev->dev, sizeof(*xspi));\n\telse\n\t\tctlr = spi_alloc_host(&pdev->dev, sizeof(*xspi));\n\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\txspi = spi_controller_get_devdata(ctlr);\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tplatform_set_drvdata(pdev, ctlr);\n\n\txspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xspi->regs)) {\n\t\tret = PTR_ERR(xspi->regs);\n\t\tgoto remove_ctlr;\n\t}\n\n\txspi->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(xspi->pclk)) {\n\t\tdev_err(&pdev->dev, \"pclk clock not found.\\n\");\n\t\tret = PTR_ERR(xspi->pclk);\n\t\tgoto remove_ctlr;\n\t}\n\n\tret = clk_prepare_enable(xspi->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable APB clock.\\n\");\n\t\tgoto remove_ctlr;\n\t}\n\n\tif (!spi_controller_is_target(ctlr)) {\n\t\txspi->ref_clk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\t\tif (IS_ERR(xspi->ref_clk)) {\n\t\t\tdev_err(&pdev->dev, \"ref_clk clock not found.\\n\");\n\t\t\tret = PTR_ERR(xspi->ref_clk);\n\t\t\tgoto clk_dis_apb;\n\t\t}\n\n\t\tret = clk_prepare_enable(xspi->ref_clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Unable to enable device clock.\\n\");\n\t\t\tgoto clk_dis_apb;\n\t\t}\n\n\t\tpm_runtime_use_autosuspend(&pdev->dev);\n\t\tpm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\t\tpm_runtime_set_active(&pdev->dev);\n\t\tpm_runtime_enable(&pdev->dev);\n\n\t\tret = of_property_read_u32(pdev->dev.of_node, \"num-cs\", &num_cs);\n\t\tif (ret < 0)\n\t\t\tctlr->num_chipselect = CDNS_SPI_DEFAULT_NUM_CS;\n\t\telse\n\t\t\tctlr->num_chipselect = num_cs;\n\n\t\tret = of_property_read_u32(pdev->dev.of_node, \"is-decoded-cs\",\n\t\t\t\t\t   &xspi->is_decoded_cs);\n\t\tif (ret < 0)\n\t\t\txspi->is_decoded_cs = 0;\n\t}\n\n\tcdns_spi_detect_fifo_depth(xspi);\n\n\t \n\tcdns_spi_init_hw(xspi, spi_controller_is_target(ctlr));\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto clk_dis_all;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, cdns_spi_irq,\n\t\t\t       0, pdev->name, ctlr);\n\tif (ret != 0) {\n\t\tret = -ENXIO;\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\tctlr->use_gpio_descriptors = true;\n\tctlr->prepare_transfer_hardware = cdns_prepare_transfer_hardware;\n\tctlr->prepare_message = cdns_prepare_message;\n\tctlr->transfer_one = cdns_transfer_one;\n\tctlr->unprepare_transfer_hardware = cdns_unprepare_transfer_hardware;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\n\tif (!spi_controller_is_target(ctlr)) {\n\t\tctlr->mode_bits |=  SPI_CS_HIGH;\n\t\tctlr->set_cs = cdns_spi_chipselect;\n\t\tctlr->auto_runtime_pm = true;\n\t\txspi->clk_rate = clk_get_rate(xspi->ref_clk);\n\t\t \n\t\tctlr->max_speed_hz = xspi->clk_rate / 4;\n\t\txspi->speed_hz = ctlr->max_speed_hz;\n\t\tpm_runtime_mark_last_busy(&pdev->dev);\n\t\tpm_runtime_put_autosuspend(&pdev->dev);\n\t} else {\n\t\tctlr->mode_bits |= SPI_NO_CS;\n\t\tctlr->target_abort = cdns_target_abort;\n\t}\n\tret = spi_register_controller(ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\treturn ret;\n\nclk_dis_all:\n\tif (!spi_controller_is_target(ctlr)) {\n\t\tpm_runtime_set_suspended(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tclk_disable_unprepare(xspi->ref_clk);\n\t}\nclk_dis_apb:\n\tclk_disable_unprepare(xspi->pclk);\nremove_ctlr:\n\tspi_controller_put(ctlr);\n\treturn ret;\n}\n\n \nstatic void cdns_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = platform_get_drvdata(pdev);\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\n\tcdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\n\n\tclk_disable_unprepare(xspi->ref_clk);\n\tclk_disable_unprepare(xspi->pclk);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tspi_unregister_controller(ctlr);\n}\n\n \nstatic int __maybe_unused cdns_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\n\treturn spi_controller_suspend(ctlr);\n}\n\n \nstatic int __maybe_unused cdns_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\n\tcdns_spi_init_hw(xspi, spi_controller_is_target(ctlr));\n\treturn spi_controller_resume(ctlr);\n}\n\n \nstatic int __maybe_unused cdns_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\tint ret;\n\n\tret = clk_prepare_enable(xspi->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable APB clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(xspi->ref_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable device clock.\\n\");\n\t\tclk_disable_unprepare(xspi->pclk);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int __maybe_unused cdns_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct cdns_spi *xspi = spi_controller_get_devdata(ctlr);\n\n\tclk_disable_unprepare(xspi->ref_clk);\n\tclk_disable_unprepare(xspi->pclk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cdns_spi_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cdns_spi_runtime_suspend,\n\t\t\t   cdns_spi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(cdns_spi_suspend, cdns_spi_resume)\n};\n\nstatic const struct of_device_id cdns_spi_of_match[] = {\n\t{ .compatible = \"xlnx,zynq-spi-r1p6\" },\n\t{ .compatible = \"cdns,spi-r1p6\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cdns_spi_of_match);\n\n \nstatic struct platform_driver cdns_spi_driver = {\n\t.probe\t= cdns_spi_probe,\n\t.remove_new = cdns_spi_remove,\n\t.driver = {\n\t\t.name = CDNS_SPI_NAME,\n\t\t.of_match_table = cdns_spi_of_match,\n\t\t.pm = &cdns_spi_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(cdns_spi_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Cadence SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}