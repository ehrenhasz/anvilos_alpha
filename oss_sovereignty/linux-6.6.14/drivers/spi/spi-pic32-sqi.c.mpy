{
  "module_name": "spi-pic32-sqi.c",
  "hash_id": "bf3c068baf55151c54b357a14aa18a073c55ce63baf19c188798917c89346c01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-pic32-sqi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n \n#define PESQI_XIP_CONF1_REG\t0x00\n#define PESQI_XIP_CONF2_REG\t0x04\n#define PESQI_CONF_REG\t\t0x08\n#define PESQI_CTRL_REG\t\t0x0C\n#define PESQI_CLK_CTRL_REG\t0x10\n#define PESQI_CMD_THRES_REG\t0x14\n#define PESQI_INT_THRES_REG\t0x18\n#define PESQI_INT_ENABLE_REG\t0x1C\n#define PESQI_INT_STAT_REG\t0x20\n#define PESQI_TX_DATA_REG\t0x24\n#define PESQI_RX_DATA_REG\t0x28\n#define PESQI_STAT1_REG\t\t0x2C\n#define PESQI_STAT2_REG\t\t0x30\n#define PESQI_BD_CTRL_REG\t0x34\n#define PESQI_BD_CUR_ADDR_REG\t0x38\n#define PESQI_BD_BASE_ADDR_REG\t0x40\n#define PESQI_BD_STAT_REG\t0x44\n#define PESQI_BD_POLL_CTRL_REG\t0x48\n#define PESQI_BD_TX_DMA_STAT_REG\t0x4C\n#define PESQI_BD_RX_DMA_STAT_REG\t0x50\n#define PESQI_THRES_REG\t\t0x54\n#define PESQI_INT_SIGEN_REG\t0x58\n\n \n#define PESQI_MODE\t\t0x7\n#define  PESQI_MODE_BOOT\t0\n#define  PESQI_MODE_PIO\t\t1\n#define  PESQI_MODE_DMA\t\t2\n#define  PESQI_MODE_XIP\t\t3\n#define PESQI_MODE_SHIFT\t0\n#define PESQI_CPHA\t\tBIT(3)\n#define PESQI_CPOL\t\tBIT(4)\n#define PESQI_LSBF\t\tBIT(5)\n#define PESQI_RXLATCH\t\tBIT(7)\n#define PESQI_SERMODE\t\tBIT(8)\n#define PESQI_WP_EN\t\tBIT(9)\n#define PESQI_HOLD_EN\t\tBIT(10)\n#define PESQI_BURST_EN\t\tBIT(12)\n#define PESQI_CS_CTRL_HW\tBIT(15)\n#define PESQI_SOFT_RESET\tBIT(16)\n#define PESQI_LANES_SHIFT\t20\n#define  PESQI_SINGLE_LANE\t0\n#define  PESQI_DUAL_LANE\t1\n#define  PESQI_QUAD_LANE\t2\n#define PESQI_CSEN_SHIFT\t24\n#define PESQI_EN\t\tBIT(23)\n\n \n#define PESQI_CLK_EN\t\tBIT(0)\n#define PESQI_CLK_STABLE\tBIT(1)\n#define PESQI_CLKDIV_SHIFT\t8\n#define PESQI_CLKDIV\t\t0xff\n\n \n#define PESQI_TXTHR_MASK\t0x1f\n#define PESQI_TXTHR_SHIFT\t8\n#define PESQI_RXTHR_MASK\t0x1f\n#define PESQI_RXTHR_SHIFT\t0\n\n \n#define PESQI_TXEMPTY\t\tBIT(0)\n#define PESQI_TXFULL\t\tBIT(1)\n#define PESQI_TXTHR\t\tBIT(2)\n#define PESQI_RXEMPTY\t\tBIT(3)\n#define PESQI_RXFULL\t\tBIT(4)\n#define PESQI_RXTHR\t\tBIT(5)\n#define PESQI_BDDONE\t\tBIT(9)   \n#define PESQI_PKTCOMP\t\tBIT(10)  \n#define PESQI_DMAERR\t\tBIT(11)  \n\n \n#define PESQI_DMA_EN\t\tBIT(0)  \n#define PESQI_POLL_EN\t\tBIT(1)  \n#define PESQI_BDP_START\t\tBIT(2)  \n\n \nstruct buf_desc {\n\tu32 bd_ctrl;\t \n\tu32 bd_status;\t \n\tu32 bd_addr;\t \n\tu32 bd_nextp;\t \n};\n\n \n#define BD_BUFLEN\t\t0x1ff\n#define BD_CBD_INT_EN\t\tBIT(16)\t \n#define BD_PKT_INT_EN\t\tBIT(17)  \n#define BD_LIFM\t\t\tBIT(18)  \n#define BD_LAST\t\t\tBIT(19)  \n#define BD_DATA_RECV\t\tBIT(20)  \n#define BD_DDR\t\t\tBIT(21)  \n#define BD_DUAL\t\t\tBIT(22)\t \n#define BD_QUAD\t\t\tBIT(23)  \n#define BD_LSBF\t\t\tBIT(25)\t \n#define BD_STAT_CHECK\t\tBIT(27)  \n#define BD_DEVSEL_SHIFT\t\t28\t \n#define BD_CS_DEASSERT\t\tBIT(30)  \n#define BD_EN\t\t\tBIT(31)  \n\n \nstruct ring_desc {\n\tstruct list_head list;\n\tstruct buf_desc *bd;\n\tdma_addr_t bd_dma;\n\tu32 xfer_len;\n};\n\n \n#define PESQI_BD_BUF_LEN_MAX\t256\n#define PESQI_BD_COUNT\t\t256  \n\nstruct pic32_sqi {\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*sys_clk;\n\tstruct clk\t\t*base_clk;  \n\tstruct spi_controller\t*host;\n\tint\t\t\tirq;\n\tstruct completion\txfer_done;\n\tstruct ring_desc\t*ring;\n\tvoid\t\t\t*bd;\n\tdma_addr_t\t\tbd_dma;\n\tstruct list_head\tbd_list_free;  \n\tstruct list_head\tbd_list_used;  \n\tstruct spi_device\t*cur_spi;\n\tu32\t\t\tcur_speed;\n\tu8\t\t\tcur_mode;\n};\n\nstatic inline void pic32_setbits(void __iomem *reg, u32 set)\n{\n\twritel(readl(reg) | set, reg);\n}\n\nstatic inline void pic32_clrbits(void __iomem *reg, u32 clr)\n{\n\twritel(readl(reg) & ~clr, reg);\n}\n\nstatic int pic32_sqi_set_clk_rate(struct pic32_sqi *sqi, u32 sck)\n{\n\tu32 val, div;\n\n\t \n\tdiv = clk_get_rate(sqi->base_clk) / (2 * sck);\n\tdiv &= PESQI_CLKDIV;\n\n\tval = readl(sqi->regs + PESQI_CLK_CTRL_REG);\n\t \n\tval &= ~(PESQI_CLK_STABLE | (PESQI_CLKDIV << PESQI_CLKDIV_SHIFT));\n\tval |= div << PESQI_CLKDIV_SHIFT;\n\twritel(val, sqi->regs + PESQI_CLK_CTRL_REG);\n\n\t \n\treturn readl_poll_timeout(sqi->regs + PESQI_CLK_CTRL_REG, val,\n\t\t\t\t  val & PESQI_CLK_STABLE, 1, 5000);\n}\n\nstatic inline void pic32_sqi_enable_int(struct pic32_sqi *sqi)\n{\n\tu32 mask = PESQI_DMAERR | PESQI_BDDONE | PESQI_PKTCOMP;\n\n\twritel(mask, sqi->regs + PESQI_INT_ENABLE_REG);\n\t \n\twritel(mask, sqi->regs + PESQI_INT_SIGEN_REG);\n}\n\nstatic inline void pic32_sqi_disable_int(struct pic32_sqi *sqi)\n{\n\twritel(0, sqi->regs + PESQI_INT_ENABLE_REG);\n\twritel(0, sqi->regs + PESQI_INT_SIGEN_REG);\n}\n\nstatic irqreturn_t pic32_sqi_isr(int irq, void *dev_id)\n{\n\tstruct pic32_sqi *sqi = dev_id;\n\tu32 enable, status;\n\n\tenable = readl(sqi->regs + PESQI_INT_ENABLE_REG);\n\tstatus = readl(sqi->regs + PESQI_INT_STAT_REG);\n\n\t \n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (status & PESQI_DMAERR) {\n\t\tenable = 0;\n\t\tgoto irq_done;\n\t}\n\n\tif (status & PESQI_TXTHR)\n\t\tenable &= ~(PESQI_TXTHR | PESQI_TXFULL | PESQI_TXEMPTY);\n\n\tif (status & PESQI_RXTHR)\n\t\tenable &= ~(PESQI_RXTHR | PESQI_RXFULL | PESQI_RXEMPTY);\n\n\tif (status & PESQI_BDDONE)\n\t\tenable &= ~PESQI_BDDONE;\n\n\t \n\tif (status & PESQI_PKTCOMP) {\n\t\t \n\t\tenable = 0;\n\t\t \n\t\tcomplete(&sqi->xfer_done);\n\t}\n\nirq_done:\n\t \n\twritel(enable, sqi->regs + PESQI_INT_ENABLE_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct ring_desc *ring_desc_get(struct pic32_sqi *sqi)\n{\n\tstruct ring_desc *rdesc;\n\n\tif (list_empty(&sqi->bd_list_free))\n\t\treturn NULL;\n\n\trdesc = list_first_entry(&sqi->bd_list_free, struct ring_desc, list);\n\tlist_move_tail(&rdesc->list, &sqi->bd_list_used);\n\treturn rdesc;\n}\n\nstatic void ring_desc_put(struct pic32_sqi *sqi, struct ring_desc *rdesc)\n{\n\tlist_move(&rdesc->list, &sqi->bd_list_free);\n}\n\nstatic int pic32_sqi_one_transfer(struct pic32_sqi *sqi,\n\t\t\t\t  struct spi_message *mesg,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\tstruct spi_device *spi = mesg->spi;\n\tstruct scatterlist *sg, *sgl;\n\tstruct ring_desc *rdesc;\n\tstruct buf_desc *bd;\n\tint nents, i;\n\tu32 bd_ctrl;\n\tu32 nbits;\n\n\t \n\tbd_ctrl = spi_get_chipselect(spi, 0) << BD_DEVSEL_SHIFT;\n\n\t \n\tif (xfer->rx_buf) {\n\t\tbd_ctrl |= BD_DATA_RECV;\n\t\tnbits = xfer->rx_nbits;\n\t\tsgl = xfer->rx_sg.sgl;\n\t\tnents = xfer->rx_sg.nents;\n\t} else {\n\t\tnbits = xfer->tx_nbits;\n\t\tsgl = xfer->tx_sg.sgl;\n\t\tnents = xfer->tx_sg.nents;\n\t}\n\n\tif (nbits & SPI_NBITS_QUAD)\n\t\tbd_ctrl |= BD_QUAD;\n\telse if (nbits & SPI_NBITS_DUAL)\n\t\tbd_ctrl |= BD_DUAL;\n\n\t \n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tbd_ctrl |= BD_LSBF;\n\n\t \n\tbd_ctrl |= BD_EN;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\t \n\t\trdesc = ring_desc_get(sqi);\n\t\tif (!rdesc)\n\t\t\tbreak;\n\n\t\tbd = rdesc->bd;\n\n\t\t \n\t\trdesc->xfer_len = sg_dma_len(sg);\n\t\tbd->bd_ctrl = bd_ctrl;\n\t\tbd->bd_ctrl |= rdesc->xfer_len;\n\n\t\t \n\t\tbd->bd_status = 0;\n\n\t\t \n\t\tbd->bd_addr = sg->dma_address;\n\t}\n\n\treturn 0;\n}\n\nstatic int pic32_sqi_prepare_hardware(struct spi_controller *host)\n{\n\tstruct pic32_sqi *sqi = spi_controller_get_devdata(host);\n\n\t \n\tpic32_setbits(sqi->regs + PESQI_CONF_REG, PESQI_EN);\n\t \n\tpic32_setbits(sqi->regs + PESQI_CLK_CTRL_REG, PESQI_CLK_EN);\n\n\treturn 0;\n}\n\nstatic bool pic32_sqi_can_dma(struct spi_controller *host,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *x)\n{\n\t \n\treturn true;\n}\n\nstatic int pic32_sqi_one_message(struct spi_controller *host,\n\t\t\t\t struct spi_message *msg)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct ring_desc *rdesc, *next;\n\tstruct spi_transfer *xfer;\n\tstruct pic32_sqi *sqi;\n\tint ret = 0, mode;\n\tunsigned long timeout;\n\tu32 val;\n\n\tsqi = spi_controller_get_devdata(host);\n\n\treinit_completion(&sqi->xfer_done);\n\tmsg->actual_length = 0;\n\n\t \n\tif (sqi->cur_spi != spi) {\n\t\t \n\t\tif (sqi->cur_speed != spi->max_speed_hz) {\n\t\t\tsqi->cur_speed = spi->max_speed_hz;\n\t\t\tret = pic32_sqi_set_clk_rate(sqi, spi->max_speed_hz);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(&spi->dev, \"set_clk, %d\\n\", ret);\n\t\t}\n\n\t\t \n\t\tmode = spi->mode & (SPI_MODE_3 | SPI_LSB_FIRST);\n\t\tif (sqi->cur_mode != mode) {\n\t\t\tval = readl(sqi->regs + PESQI_CONF_REG);\n\t\t\tval &= ~(PESQI_CPOL | PESQI_CPHA | PESQI_LSBF);\n\t\t\tif (mode & SPI_CPOL)\n\t\t\t\tval |= PESQI_CPOL;\n\t\t\tif (mode & SPI_LSB_FIRST)\n\t\t\t\tval |= PESQI_LSBF;\n\t\t\tval |= PESQI_CPHA;\n\t\t\twritel(val, sqi->regs + PESQI_CONF_REG);\n\n\t\t\tsqi->cur_mode = mode;\n\t\t}\n\t\tsqi->cur_spi = spi;\n\t}\n\n\t \n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tret = pic32_sqi_one_transfer(sqi, msg, xfer);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"xfer %p err\\n\", xfer);\n\t\t\tgoto xfer_out;\n\t\t}\n\t}\n\n\t \n\trdesc = list_last_entry(&sqi->bd_list_used, struct ring_desc, list);\n\trdesc->bd->bd_ctrl |= BD_LAST | BD_CS_DEASSERT |\n\t\t\t      BD_LIFM | BD_PKT_INT_EN;\n\n\t \n\trdesc = list_first_entry(&sqi->bd_list_used, struct ring_desc, list);\n\twritel(rdesc->bd_dma, sqi->regs + PESQI_BD_BASE_ADDR_REG);\n\n\t \n\tpic32_sqi_enable_int(sqi);\n\n\t \n\tval = PESQI_DMA_EN | PESQI_POLL_EN | PESQI_BDP_START;\n\twritel(val, sqi->regs + PESQI_BD_CTRL_REG);\n\n\t \n\ttimeout = wait_for_completion_timeout(&sqi->xfer_done, 5 * HZ);\n\tif (timeout == 0) {\n\t\tdev_err(&sqi->host->dev, \"wait timedout/interrupted\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tmsg->status = ret;\n\t} else {\n\t\t \n\t\tmsg->status = 0;\n\t\tret = 0;\n\t}\n\n\t \n\twritel(0, sqi->regs + PESQI_BD_CTRL_REG);\n\n\tpic32_sqi_disable_int(sqi);\n\nxfer_out:\n\tlist_for_each_entry_safe_reverse(rdesc, next,\n\t\t\t\t\t &sqi->bd_list_used, list) {\n\t\t \n\t\tmsg->actual_length += rdesc->xfer_len;\n\t\t \n\t\tring_desc_put(sqi, rdesc);\n\t}\n\tspi_finalize_current_message(spi->controller);\n\n\treturn ret;\n}\n\nstatic int pic32_sqi_unprepare_hardware(struct spi_controller *host)\n{\n\tstruct pic32_sqi *sqi = spi_controller_get_devdata(host);\n\n\t \n\tpic32_clrbits(sqi->regs + PESQI_CLK_CTRL_REG, PESQI_CLK_EN);\n\t \n\tpic32_clrbits(sqi->regs + PESQI_CONF_REG, PESQI_EN);\n\n\treturn 0;\n}\n\nstatic int ring_desc_ring_alloc(struct pic32_sqi *sqi)\n{\n\tstruct ring_desc *rdesc;\n\tstruct buf_desc *bd;\n\tint i;\n\n\t \n\tsqi->bd = dma_alloc_coherent(&sqi->host->dev,\n\t\t\t\t     sizeof(*bd) * PESQI_BD_COUNT,\n\t\t\t\t     &sqi->bd_dma, GFP_KERNEL);\n\tif (!sqi->bd) {\n\t\tdev_err(&sqi->host->dev, \"failed allocating dma buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsqi->ring = kcalloc(PESQI_BD_COUNT, sizeof(*rdesc), GFP_KERNEL);\n\tif (!sqi->ring) {\n\t\tdma_free_coherent(&sqi->host->dev,\n\t\t\t\t  sizeof(*bd) * PESQI_BD_COUNT,\n\t\t\t\t  sqi->bd, sqi->bd_dma);\n\t\treturn -ENOMEM;\n\t}\n\n\tbd = (struct buf_desc *)sqi->bd;\n\n\tINIT_LIST_HEAD(&sqi->bd_list_free);\n\tINIT_LIST_HEAD(&sqi->bd_list_used);\n\n\t \n\tfor (i = 0, rdesc = sqi->ring; i < PESQI_BD_COUNT; i++, rdesc++) {\n\t\tINIT_LIST_HEAD(&rdesc->list);\n\t\trdesc->bd = &bd[i];\n\t\trdesc->bd_dma = sqi->bd_dma + (void *)&bd[i] - (void *)bd;\n\t\tlist_add_tail(&rdesc->list, &sqi->bd_list_free);\n\t}\n\n\t \n\tfor (i = 0, rdesc = sqi->ring; i < PESQI_BD_COUNT - 1; i++)\n\t\tbd[i].bd_nextp = rdesc[i + 1].bd_dma;\n\tbd[PESQI_BD_COUNT - 1].bd_nextp = 0;\n\n\treturn 0;\n}\n\nstatic void ring_desc_ring_free(struct pic32_sqi *sqi)\n{\n\tdma_free_coherent(&sqi->host->dev,\n\t\t\t  sizeof(struct buf_desc) * PESQI_BD_COUNT,\n\t\t\t  sqi->bd, sqi->bd_dma);\n\tkfree(sqi->ring);\n}\n\nstatic void pic32_sqi_hw_init(struct pic32_sqi *sqi)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\twritel(PESQI_SOFT_RESET, sqi->regs + PESQI_CONF_REG);\n\n\t \n\treadl_poll_timeout_atomic(sqi->regs + PESQI_CONF_REG, val,\n\t\t\t\t  !(val & PESQI_SOFT_RESET), 1, 5000);\n\n\t \n\tpic32_sqi_disable_int(sqi);\n\n\t \n\tlocal_irq_restore(flags);\n\n\t \n\tval = readl(sqi->regs + PESQI_CMD_THRES_REG);\n\tval &= ~(PESQI_TXTHR_MASK << PESQI_TXTHR_SHIFT);\n\tval &= ~(PESQI_RXTHR_MASK << PESQI_RXTHR_SHIFT);\n\tval |= (1U << PESQI_TXTHR_SHIFT) | (1U << PESQI_RXTHR_SHIFT);\n\twritel(val, sqi->regs + PESQI_CMD_THRES_REG);\n\n\tval = readl(sqi->regs + PESQI_INT_THRES_REG);\n\tval &= ~(PESQI_TXTHR_MASK << PESQI_TXTHR_SHIFT);\n\tval &= ~(PESQI_RXTHR_MASK << PESQI_RXTHR_SHIFT);\n\tval |= (1U << PESQI_TXTHR_SHIFT) | (1U << PESQI_RXTHR_SHIFT);\n\twritel(val, sqi->regs + PESQI_INT_THRES_REG);\n\n\t \n\tval = readl(sqi->regs + PESQI_CONF_REG);\n\n\t \n\tval &= ~PESQI_MODE;\n\tval |= PESQI_MODE_DMA << PESQI_MODE_SHIFT;\n\twritel(val, sqi->regs + PESQI_CONF_REG);\n\n\t \n\tval |= PESQI_QUAD_LANE << PESQI_LANES_SHIFT;\n\n\t \n\tval |= PESQI_BURST_EN;\n\n\t \n\tval |= 3U << PESQI_CSEN_SHIFT;\n\twritel(val, sqi->regs + PESQI_CONF_REG);\n\n\t \n\twritel(0, sqi->regs + PESQI_BD_POLL_CTRL_REG);\n\n\tsqi->cur_speed = 0;\n\tsqi->cur_mode = -1;\n}\n\nstatic int pic32_sqi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct pic32_sqi *sqi;\n\tint ret;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*sqi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tsqi = spi_controller_get_devdata(host);\n\tsqi->host = host;\n\n\tsqi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sqi->regs)) {\n\t\tret = PTR_ERR(sqi->regs);\n\t\tgoto err_free_host;\n\t}\n\n\t \n\tsqi->irq = platform_get_irq(pdev, 0);\n\tif (sqi->irq < 0) {\n\t\tret = sqi->irq;\n\t\tgoto err_free_host;\n\t}\n\n\t \n\tsqi->sys_clk = devm_clk_get(&pdev->dev, \"reg_ck\");\n\tif (IS_ERR(sqi->sys_clk)) {\n\t\tret = PTR_ERR(sqi->sys_clk);\n\t\tdev_err(&pdev->dev, \"no sys_clk ?\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\tsqi->base_clk = devm_clk_get(&pdev->dev, \"spi_ck\");\n\tif (IS_ERR(sqi->base_clk)) {\n\t\tret = PTR_ERR(sqi->base_clk);\n\t\tdev_err(&pdev->dev, \"no base clk ?\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\tret = clk_prepare_enable(sqi->sys_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"sys clk enable failed\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\tret = clk_prepare_enable(sqi->base_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"base clk enable failed\\n\");\n\t\tclk_disable_unprepare(sqi->sys_clk);\n\t\tgoto err_free_host;\n\t}\n\n\tinit_completion(&sqi->xfer_done);\n\n\t \n\tpic32_sqi_hw_init(sqi);\n\n\t \n\tret = ring_desc_ring_alloc(sqi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"ring alloc failed\\n\");\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\tret = request_irq(sqi->irq, pic32_sqi_isr, 0,\n\t\t\t  dev_name(&pdev->dev), sqi);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq(%d), failed\\n\", sqi->irq);\n\t\tgoto err_free_ring;\n\t}\n\n\t \n\thost->num_chipselect\t= 2;\n\thost->max_speed_hz\t= clk_get_rate(sqi->base_clk);\n\thost->dma_alignment\t= 32;\n\thost->max_dma_len\t= PESQI_BD_BUF_LEN_MAX;\n\thost->dev.of_node\t= pdev->dev.of_node;\n\thost->mode_bits\t\t= SPI_MODE_3 | SPI_MODE_0 | SPI_TX_DUAL |\n\t\t\t\t  SPI_RX_DUAL | SPI_TX_QUAD | SPI_RX_QUAD;\n\thost->flags\t\t= SPI_CONTROLLER_HALF_DUPLEX;\n\thost->can_dma\t\t= pic32_sqi_can_dma;\n\thost->bits_per_word_mask\t= SPI_BPW_RANGE_MASK(8, 32);\n\thost->transfer_one_message\t= pic32_sqi_one_message;\n\thost->prepare_transfer_hardware\t= pic32_sqi_prepare_hardware;\n\thost->unprepare_transfer_hardware\t= pic32_sqi_unprepare_hardware;\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret) {\n\t\tdev_err(&host->dev, \"failed registering spi host\\n\");\n\t\tfree_irq(sqi->irq, sqi);\n\t\tgoto err_free_ring;\n\t}\n\n\tplatform_set_drvdata(pdev, sqi);\n\n\treturn 0;\n\nerr_free_ring:\n\tring_desc_ring_free(sqi);\n\nerr_disable_clk:\n\tclk_disable_unprepare(sqi->base_clk);\n\tclk_disable_unprepare(sqi->sys_clk);\n\nerr_free_host:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic void pic32_sqi_remove(struct platform_device *pdev)\n{\n\tstruct pic32_sqi *sqi = platform_get_drvdata(pdev);\n\n\t \n\tfree_irq(sqi->irq, sqi);\n\tring_desc_ring_free(sqi);\n\n\t \n\tclk_disable_unprepare(sqi->base_clk);\n\tclk_disable_unprepare(sqi->sys_clk);\n}\n\nstatic const struct of_device_id pic32_sqi_of_ids[] = {\n\t{.compatible = \"microchip,pic32mzda-sqi\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pic32_sqi_of_ids);\n\nstatic struct platform_driver pic32_sqi_driver = {\n\t.driver = {\n\t\t.name = \"sqi-pic32\",\n\t\t.of_match_table = of_match_ptr(pic32_sqi_of_ids),\n\t},\n\t.probe = pic32_sqi_probe,\n\t.remove_new = pic32_sqi_remove,\n};\n\nmodule_platform_driver(pic32_sqi_driver);\n\nMODULE_AUTHOR(\"Purna Chandra Mandal <purna.mandal@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip SPI driver for PIC32 SQI controller.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}