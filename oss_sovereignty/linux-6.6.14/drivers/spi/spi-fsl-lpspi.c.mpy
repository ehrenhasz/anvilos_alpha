{
  "module_name": "spi-fsl-lpspi.c",
  "hash_id": "cffb6583b98b9c5ca54510c6f06ecd6ed9ffd5fc79c9062acf5056d351d8160b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-lpspi.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/dma/imx-dma.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/types.h>\n\n#define DRIVER_NAME \"fsl_lpspi\"\n\n#define FSL_LPSPI_RPM_TIMEOUT 50  \n\n \n#define FSL_LPSPI_MAX_EDMA_BYTES  ((1 << 15) - 1)\n\n \n#define IMX7ULP_VERID\t0x0\n#define IMX7ULP_PARAM\t0x4\n#define IMX7ULP_CR\t0x10\n#define IMX7ULP_SR\t0x14\n#define IMX7ULP_IER\t0x18\n#define IMX7ULP_DER\t0x1c\n#define IMX7ULP_CFGR0\t0x20\n#define IMX7ULP_CFGR1\t0x24\n#define IMX7ULP_DMR0\t0x30\n#define IMX7ULP_DMR1\t0x34\n#define IMX7ULP_CCR\t0x40\n#define IMX7ULP_FCR\t0x58\n#define IMX7ULP_FSR\t0x5c\n#define IMX7ULP_TCR\t0x60\n#define IMX7ULP_TDR\t0x64\n#define IMX7ULP_RSR\t0x70\n#define IMX7ULP_RDR\t0x74\n\n \n#define CR_RRF\t\tBIT(9)\n#define CR_RTF\t\tBIT(8)\n#define CR_RST\t\tBIT(1)\n#define CR_MEN\t\tBIT(0)\n#define SR_MBF\t\tBIT(24)\n#define SR_TCF\t\tBIT(10)\n#define SR_FCF\t\tBIT(9)\n#define SR_RDF\t\tBIT(1)\n#define SR_TDF\t\tBIT(0)\n#define IER_TCIE\tBIT(10)\n#define IER_FCIE\tBIT(9)\n#define IER_RDIE\tBIT(1)\n#define IER_TDIE\tBIT(0)\n#define DER_RDDE\tBIT(1)\n#define DER_TDDE\tBIT(0)\n#define CFGR1_PCSCFG\tBIT(27)\n#define CFGR1_PINCFG\t(BIT(24)|BIT(25))\n#define CFGR1_PCSPOL\tBIT(8)\n#define CFGR1_NOSTALL\tBIT(3)\n#define CFGR1_HOST\tBIT(0)\n#define FSR_TXCOUNT\t(0xFF)\n#define RSR_RXEMPTY\tBIT(1)\n#define TCR_CPOL\tBIT(31)\n#define TCR_CPHA\tBIT(30)\n#define TCR_CONT\tBIT(21)\n#define TCR_CONTC\tBIT(20)\n#define TCR_RXMSK\tBIT(19)\n#define TCR_TXMSK\tBIT(18)\n\nstruct lpspi_config {\n\tu8 bpw;\n\tu8 chip_select;\n\tu8 prescale;\n\tu16 mode;\n\tu32 speed_hz;\n};\n\nstruct fsl_lpspi_data {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned long base_phys;\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_per;\n\tbool is_target;\n\tbool is_only_cs1;\n\tbool is_first_byte;\n\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tvoid (*tx)(struct fsl_lpspi_data *);\n\tvoid (*rx)(struct fsl_lpspi_data *);\n\n\tu32 remain;\n\tu8 watermark;\n\tu8 txfifosize;\n\tu8 rxfifosize;\n\n\tstruct lpspi_config config;\n\tstruct completion xfer_done;\n\n\tbool target_aborted;\n\n\t \n\tbool usedma;\n\tstruct completion dma_rx_completion;\n\tstruct completion dma_tx_completion;\n};\n\nstatic const struct of_device_id fsl_lpspi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7ulp-spi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_lpspi_dt_ids);\n\n#define LPSPI_BUF_RX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_rx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int val = readl(fsl_lpspi->base + IMX7ULP_RDR);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->rx_buf) {\t\t\t\t\t\\\n\t\t*(type *)fsl_lpspi->rx_buf = val;\t\t\t\\\n\t\tfsl_lpspi->rx_buf += sizeof(type);                      \\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define LPSPI_BUF_TX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_tx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype val = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->tx_buf) {\t\t\t\t\t\\\n\t\tval = *(type *)fsl_lpspi->tx_buf;\t\t\t\\\n\t\tfsl_lpspi->tx_buf += sizeof(type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfsl_lpspi->remain -= sizeof(type);\t\t\t\t\\\n\twritel(val, fsl_lpspi->base + IMX7ULP_TDR);\t\t\t\\\n}\n\nLPSPI_BUF_RX(u8)\nLPSPI_BUF_TX(u8)\nLPSPI_BUF_RX(u16)\nLPSPI_BUF_TX(u16)\nLPSPI_BUF_RX(u32)\nLPSPI_BUF_TX(u32)\n\nstatic void fsl_lpspi_intctrl(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      unsigned int enable)\n{\n\twritel(enable, fsl_lpspi->base + IMX7ULP_IER);\n}\n\nstatic int fsl_lpspi_bytes_per_word(const int bpw)\n{\n\treturn DIV_ROUND_UP(bpw, BITS_PER_BYTE);\n}\n\nstatic bool fsl_lpspi_can_dma(struct spi_controller *controller,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *transfer)\n{\n\tunsigned int bytes_per_word;\n\n\tif (!controller->dma_rx)\n\t\treturn false;\n\n\tbytes_per_word = fsl_lpspi_bytes_per_word(transfer->bits_per_word);\n\n\tswitch (bytes_per_word) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int lpspi_prepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpspi_unprepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tpm_runtime_mark_last_busy(fsl_lpspi->dev);\n\tpm_runtime_put_autosuspend(fsl_lpspi->dev);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_write_tx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu8 txfifo_cnt;\n\tu32 temp;\n\n\ttxfifo_cnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;\n\n\twhile (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->remain)\n\t\t\tbreak;\n\t\tfsl_lpspi->tx(fsl_lpspi);\n\t\ttxfifo_cnt++;\n\t}\n\n\tif (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->is_target) {\n\t\t\ttemp = readl(fsl_lpspi->base + IMX7ULP_TCR);\n\t\t\ttemp &= ~TCR_CONTC;\n\t\t\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\t\t}\n\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t} else\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_TDIE);\n}\n\nstatic void fsl_lpspi_read_rx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\twhile (!(readl(fsl_lpspi->base + IMX7ULP_RSR) & RSR_RXEMPTY))\n\t\tfsl_lpspi->rx(fsl_lpspi);\n}\n\nstatic void fsl_lpspi_set_cmd(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp = 0;\n\n\ttemp |= fsl_lpspi->config.bpw - 1;\n\ttemp |= (fsl_lpspi->config.mode & 0x3) << 30;\n\ttemp |= (fsl_lpspi->config.chip_select & 0x3) << 24;\n\tif (!fsl_lpspi->is_target) {\n\t\ttemp |= fsl_lpspi->config.prescale << 27;\n\t\t \n\t\tif (!fsl_lpspi->usedma) {\n\t\t\ttemp |= TCR_CONT;\n\t\t\tif (fsl_lpspi->is_first_byte)\n\t\t\t\ttemp &= ~TCR_CONTC;\n\t\t\telse\n\t\t\t\ttemp |= TCR_CONTC;\n\t\t}\n\t}\n\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"TCR=0x%x\\n\", temp);\n}\n\nstatic void fsl_lpspi_set_watermark(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma)\n\t\ttemp = fsl_lpspi->watermark >> 1 |\n\t\t       (fsl_lpspi->watermark >> 1) << 16;\n\telse\n\t\ttemp = fsl_lpspi->watermark >> 1;\n\n\twritel(temp, fsl_lpspi->base + IMX7ULP_FCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"FCR=0x%x\\n\", temp);\n}\n\nstatic int fsl_lpspi_set_bitrate(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct lpspi_config config = fsl_lpspi->config;\n\tunsigned int perclk_rate, scldiv;\n\tu8 prescale;\n\n\tperclk_rate = clk_get_rate(fsl_lpspi->clk_per);\n\n\tif (!config.speed_hz) {\n\t\tdev_err(fsl_lpspi->dev,\n\t\t\t\"error: the transmission speed provided is 0!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (config.speed_hz > perclk_rate / 2) {\n\t\tdev_err(fsl_lpspi->dev,\n\t\t      \"per-clk should be at least two times of transfer speed\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (prescale = 0; prescale < 8; prescale++) {\n\t\tscldiv = perclk_rate / config.speed_hz / (1 << prescale) - 2;\n\t\tif (scldiv < 256) {\n\t\t\tfsl_lpspi->config.prescale = prescale;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (scldiv >= 256)\n\t\treturn -EINVAL;\n\n\twritel(scldiv | (scldiv << 8) | ((scldiv >> 1) << 16),\n\t\t\t\t\tfsl_lpspi->base + IMX7ULP_CCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"perclk=%d, speed=%d, prescale=%d, scldiv=%d\\n\",\n\t\tperclk_rate, config.speed_hz, prescale, scldiv);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_dma_configure(struct spi_controller *controller)\n{\n\tint ret;\n\tenum dma_slave_buswidth buswidth;\n\tstruct dma_slave_config rx = {}, tx = {};\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tswitch (fsl_lpspi_bytes_per_word(fsl_lpspi->config.bpw)) {\n\tcase 4:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tcase 2:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 1:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttx.direction = DMA_MEM_TO_DEV;\n\ttx.dst_addr = fsl_lpspi->base_phys + IMX7ULP_TDR;\n\ttx.dst_addr_width = buswidth;\n\ttx.dst_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_tx, &tx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"TX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trx.direction = DMA_DEV_TO_MEM;\n\trx.src_addr = fsl_lpspi->base_phys + IMX7ULP_RDR;\n\trx.src_addr_width = buswidth;\n\trx.src_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_rx, &rx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"RX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_config(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\tint ret;\n\n\tif (!fsl_lpspi->is_target) {\n\t\tret = fsl_lpspi_set_bitrate(fsl_lpspi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfsl_lpspi_set_watermark(fsl_lpspi);\n\n\tif (!fsl_lpspi->is_target)\n\t\ttemp = CFGR1_HOST;\n\telse\n\t\ttemp = CFGR1_PINCFG;\n\tif (fsl_lpspi->config.mode & SPI_CS_HIGH)\n\t\ttemp |= CFGR1_PCSPOL;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CFGR1);\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_CR);\n\ttemp |= CR_RRF | CR_RTF | CR_MEN;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\ttemp = 0;\n\tif (fsl_lpspi->usedma)\n\t\ttemp = DER_TDDE | DER_RDDE;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_DER);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_setup_transfer(struct spi_controller *controller,\n\t\t\t\t     struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(spi->controller);\n\n\tif (t == NULL)\n\t\treturn -EINVAL;\n\n\tfsl_lpspi->config.mode = spi->mode;\n\tfsl_lpspi->config.bpw = t->bits_per_word;\n\tfsl_lpspi->config.speed_hz = t->speed_hz;\n\tif (fsl_lpspi->is_only_cs1)\n\t\tfsl_lpspi->config.chip_select = 1;\n\telse\n\t\tfsl_lpspi->config.chip_select = spi_get_chipselect(spi, 0);\n\n\tif (!fsl_lpspi->config.speed_hz)\n\t\tfsl_lpspi->config.speed_hz = spi->max_speed_hz;\n\tif (!fsl_lpspi->config.bpw)\n\t\tfsl_lpspi->config.bpw = spi->bits_per_word;\n\n\t \n\tif (fsl_lpspi->config.bpw <= 8) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u8;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u8;\n\t} else if (fsl_lpspi->config.bpw <= 16) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u16;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u16;\n\t} else {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u32;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u32;\n\t}\n\n\tif (t->len <= fsl_lpspi->txfifosize)\n\t\tfsl_lpspi->watermark = t->len;\n\telse\n\t\tfsl_lpspi->watermark = fsl_lpspi->txfifosize;\n\n\tif (fsl_lpspi_can_dma(controller, spi, t))\n\t\tfsl_lpspi->usedma = true;\n\telse\n\t\tfsl_lpspi->usedma = false;\n\n\treturn fsl_lpspi_config(fsl_lpspi);\n}\n\nstatic int fsl_lpspi_target_abort(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tfsl_lpspi->target_aborted = true;\n\tif (!fsl_lpspi->usedma)\n\t\tcomplete(&fsl_lpspi->xfer_done);\n\telse {\n\t\tcomplete(&fsl_lpspi->dma_tx_completion);\n\t\tcomplete(&fsl_lpspi->dma_rx_completion);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_wait_for_completion(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tif (fsl_lpspi->is_target) {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->xfer_done) ||\n\t\t\tfsl_lpspi->target_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"interrupted\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t} else {\n\t\tif (!wait_for_completion_timeout(&fsl_lpspi->xfer_done, HZ)) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"wait for completion timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_reset(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma) {\n\t\t \n\t\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\t}\n\n\t \n\ttemp = 0x3F << 8;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_SR);\n\n\t \n\ttemp = CR_RRF | CR_RTF;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_rx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_rx_completion);\n}\n\nstatic void fsl_lpspi_dma_tx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_tx_completion);\n}\n\nstatic int fsl_lpspi_calculate_timeout(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\t       int size)\n{\n\tunsigned long timeout = 0;\n\n\t \n\ttimeout = (8 + 4) * size / fsl_lpspi->config.speed_hz;\n\n\t \n\ttimeout += 1;\n\n\t \n\treturn msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);\n}\n\nstatic int fsl_lpspi_dma_transfer(struct spi_controller *controller,\n\t\t\t\tstruct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct dma_async_tx_descriptor *desc_tx, *desc_rx;\n\tunsigned long transfer_timeout;\n\tunsigned long timeout;\n\tstruct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;\n\tint ret;\n\n\tret = fsl_lpspi_dma_configure(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc_rx = dmaengine_prep_slave_sg(controller->dma_rx,\n\t\t\t\trx->sgl, rx->nents, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx)\n\t\treturn -EINVAL;\n\n\tdesc_rx->callback = fsl_lpspi_dma_rx_callback;\n\tdesc_rx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_rx);\n\treinit_completion(&fsl_lpspi->dma_rx_completion);\n\tdma_async_issue_pending(controller->dma_rx);\n\n\tdesc_tx = dmaengine_prep_slave_sg(controller->dma_tx,\n\t\t\t\ttx->sgl, tx->nents, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_tx->callback = fsl_lpspi_dma_tx_callback;\n\tdesc_tx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_tx);\n\treinit_completion(&fsl_lpspi->dma_tx_completion);\n\tdma_async_issue_pending(controller->dma_tx);\n\n\tfsl_lpspi->target_aborted = false;\n\n\tif (!fsl_lpspi->is_target) {\n\t\ttransfer_timeout = fsl_lpspi_calculate_timeout(fsl_lpspi,\n\t\t\t\t\t\t\t       transfer->len);\n\n\t\t \n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_tx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA TX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_rx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA RX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_tx_completion) ||\n\t\t\tfsl_lpspi->target_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA TX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_rx_completion) ||\n\t\t\tfsl_lpspi->target_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA RX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_exit(struct spi_controller *controller)\n{\n\tif (controller->dma_rx) {\n\t\tdma_release_channel(controller->dma_rx);\n\t\tcontroller->dma_rx = NULL;\n\t}\n\n\tif (controller->dma_tx) {\n\t\tdma_release_channel(controller->dma_tx);\n\t\tcontroller->dma_tx = NULL;\n\t}\n}\n\nstatic int fsl_lpspi_dma_init(struct device *dev,\n\t\t\t      struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      struct spi_controller *controller)\n{\n\tint ret;\n\n\t \n\tcontroller->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(controller->dma_tx)) {\n\t\tret = PTR_ERR(controller->dma_tx);\n\t\tdev_dbg(dev, \"can't get the TX DMA channel, error %d!\\n\", ret);\n\t\tcontroller->dma_tx = NULL;\n\t\tgoto err;\n\t}\n\n\t \n\tcontroller->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(controller->dma_rx)) {\n\t\tret = PTR_ERR(controller->dma_rx);\n\t\tdev_dbg(dev, \"can't get the RX DMA channel, error %d\\n\", ret);\n\t\tcontroller->dma_rx = NULL;\n\t\tgoto err;\n\t}\n\n\tinit_completion(&fsl_lpspi->dma_rx_completion);\n\tinit_completion(&fsl_lpspi->dma_tx_completion);\n\tcontroller->can_dma = fsl_lpspi_can_dma;\n\tcontroller->max_dma_len = FSL_LPSPI_MAX_EDMA_BYTES;\n\n\treturn 0;\nerr:\n\tfsl_lpspi_dma_exit(controller);\n\treturn ret;\n}\n\nstatic int fsl_lpspi_pio_transfer(struct spi_controller *controller,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->tx_buf = t->tx_buf;\n\tfsl_lpspi->rx_buf = t->rx_buf;\n\tfsl_lpspi->remain = t->len;\n\n\treinit_completion(&fsl_lpspi->xfer_done);\n\tfsl_lpspi->target_aborted = false;\n\n\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\n\tret = fsl_lpspi_wait_for_completion(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_transfer_one(struct spi_controller *controller,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->is_first_byte = true;\n\tret = fsl_lpspi_setup_transfer(controller, spi, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsl_lpspi_set_cmd(fsl_lpspi);\n\tfsl_lpspi->is_first_byte = false;\n\n\tif (fsl_lpspi->usedma)\n\t\tret = fsl_lpspi_dma_transfer(controller, fsl_lpspi, t);\n\telse\n\t\tret = fsl_lpspi_pio_transfer(controller, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic irqreturn_t fsl_lpspi_isr(int irq, void *dev_id)\n{\n\tu32 temp_SR, temp_IER;\n\tstruct fsl_lpspi_data *fsl_lpspi = dev_id;\n\n\ttemp_IER = readl(fsl_lpspi->base + IMX7ULP_IER);\n\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\ttemp_SR = readl(fsl_lpspi->base + IMX7ULP_SR);\n\n\tfsl_lpspi_read_rx_fifo(fsl_lpspi);\n\n\tif ((temp_SR & SR_TDF) && (temp_IER & IER_TDIE)) {\n\t\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_MBF ||\n\t    readl(fsl_lpspi->base + IMX7ULP_FSR) & FSR_TXCOUNT) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_FCF && (temp_IER & IER_FCIE)) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\tcomplete(&fsl_lpspi->xfer_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_lpspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tint ret;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_per);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_ipg);\n\tif (ret) {\n\t\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\tclk_disable_unprepare(fsl_lpspi->clk_ipg);\n\n\treturn 0;\n}\n#endif\n\nstatic int fsl_lpspi_init_rpm(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct device *dev = fsl_lpspi->dev;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, FSL_LPSPI_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct resource *res;\n\tint ret, irq;\n\tu32 num_cs;\n\tu32 temp;\n\tbool is_target;\n\n\tis_target = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_target)\n\t\tcontroller = spi_alloc_target(&pdev->dev,\n\t\t\t\t\t      sizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_host(&pdev->dev,\n\t\t\t\t\t    sizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_target = is_target;\n\tfsl_lpspi->is_only_cs1 = of_property_read_bool((&pdev->dev)->of_node,\n\t\t\t\t\t\t\"fsl,spi-only-use-cs1-sel\");\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tfsl_lpspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t \n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\tgoto out_pm_get;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\tif (of_property_read_u32((&pdev->dev)->of_node, \"num-cs\",\n\t\t\t\t &num_cs)) {\n\t\tif (of_device_is_compatible(pdev->dev.of_node, \"fsl,imx93-spi\"))\n\t\t\tnum_cs = ((temp >> 16) & 0xf);\n\t\telse\n\t\t\tnum_cs = 1;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->num_chipselect = num_cs;\n\tcontroller->target_abort = fsl_lpspi_target_abort;\n\tif (!fsl_lpspi->is_target)\n\t\tcontroller->use_gpio_descriptors = true;\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_pm_get;\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\telse\n\t\t \n\t\tdisable_irq(irq);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret, \"spi_register_controller error\\n\");\n\t\tgoto free_dma;\n\t}\n\n\tpm_runtime_mark_last_busy(fsl_lpspi->dev);\n\tpm_runtime_put_autosuspend(fsl_lpspi->dev);\n\n\treturn 0;\n\nfree_dma:\n\tfsl_lpspi_dma_exit(controller);\nout_pm_get:\n\tpm_runtime_dont_use_autosuspend(fsl_lpspi->dev);\n\tpm_runtime_put_sync(fsl_lpspi->dev);\n\tpm_runtime_disable(fsl_lpspi->dev);\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}\n\nstatic void fsl_lpspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *controller = platform_get_drvdata(pdev);\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tfsl_lpspi_dma_exit(controller);\n\n\tpm_runtime_disable(fsl_lpspi->dev);\n}\n\nstatic int __maybe_unused fsl_lpspi_suspend(struct device *dev)\n{\n\tpinctrl_pm_select_sleep_state(dev);\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused fsl_lpspi_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Error in resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops fsl_lpspi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_lpspi_runtime_suspend,\n\t\t\t\tfsl_lpspi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_lpspi_suspend, fsl_lpspi_resume)\n};\n\nstatic struct platform_driver fsl_lpspi_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = fsl_lpspi_dt_ids,\n\t\t.pm = &fsl_lpspi_pm_ops,\n\t},\n\t.probe = fsl_lpspi_probe,\n\t.remove_new = fsl_lpspi_remove,\n};\nmodule_platform_driver(fsl_lpspi_driver);\n\nMODULE_DESCRIPTION(\"LPSPI Controller driver\");\nMODULE_AUTHOR(\"Gao Pan <pandy.gao@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}