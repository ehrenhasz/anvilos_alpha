{
  "module_name": "spi-st-ssc4.c",
  "hash_id": "cba69e4ba01de43ca7f85aa74a46eec569ab43791da3bca207ac377c960f8eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-st-ssc4.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n\n \n#define SSC_BRG\t\t\t\t0x000\n#define SSC_TBUF\t\t\t0x004\n#define SSC_RBUF\t\t\t0x008\n#define SSC_CTL\t\t\t\t0x00C\n#define SSC_IEN\t\t\t\t0x010\n#define SSC_I2C\t\t\t\t0x018\n\n \n#define SSC_CTL_DATA_WIDTH_9\t\t0x8\n#define SSC_CTL_DATA_WIDTH_MSK\t\t0xf\n#define SSC_CTL_BM\t\t\t0xf\n#define SSC_CTL_HB\t\t\tBIT(4)\n#define SSC_CTL_PH\t\t\tBIT(5)\n#define SSC_CTL_PO\t\t\tBIT(6)\n#define SSC_CTL_SR\t\t\tBIT(7)\n#define SSC_CTL_MS\t\t\tBIT(8)\n#define SSC_CTL_EN\t\t\tBIT(9)\n#define SSC_CTL_LPB\t\t\tBIT(10)\n#define SSC_CTL_EN_TX_FIFO\t\tBIT(11)\n#define SSC_CTL_EN_RX_FIFO\t\tBIT(12)\n#define SSC_CTL_EN_CLST_RX\t\tBIT(13)\n\n \n#define SSC_IEN_TEEN\t\t\tBIT(2)\n\n#define FIFO_SIZE\t\t\t8\n\nstruct spi_st {\n\t \n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct device\t\t*dev;\n\n\t \n\tconst u8\t\t*tx_ptr;\n\tu8\t\t\t*rx_ptr;\n\tu16\t\t\tbytes_per_word;\n\tunsigned int\t\twords_remaining;\n\tunsigned int\t\tbaud;\n\tstruct completion\tdone;\n};\n\n \nstatic void ssc_write_tx_fifo(struct spi_st *spi_st)\n{\n\tunsigned int count, i;\n\tuint32_t word = 0;\n\n\tif (spi_st->words_remaining > FIFO_SIZE)\n\t\tcount = FIFO_SIZE;\n\telse\n\t\tcount = spi_st->words_remaining;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (spi_st->tx_ptr) {\n\t\t\tif (spi_st->bytes_per_word == 1) {\n\t\t\t\tword = *spi_st->tx_ptr++;\n\t\t\t} else {\n\t\t\t\tword = *spi_st->tx_ptr++;\n\t\t\t\tword = *spi_st->tx_ptr++ | (word << 8);\n\t\t\t}\n\t\t}\n\t\twritel_relaxed(word, spi_st->base + SSC_TBUF);\n\t}\n}\n\n \nstatic void ssc_read_rx_fifo(struct spi_st *spi_st)\n{\n\tunsigned int count, i;\n\tuint32_t word = 0;\n\n\tif (spi_st->words_remaining > FIFO_SIZE)\n\t\tcount = FIFO_SIZE;\n\telse\n\t\tcount = spi_st->words_remaining;\n\n\tfor (i = 0; i < count; i++) {\n\t\tword = readl_relaxed(spi_st->base + SSC_RBUF);\n\n\t\tif (spi_st->rx_ptr) {\n\t\t\tif (spi_st->bytes_per_word == 1) {\n\t\t\t\t*spi_st->rx_ptr++ = (uint8_t)word;\n\t\t\t} else {\n\t\t\t\t*spi_st->rx_ptr++ = (word >> 8);\n\t\t\t\t*spi_st->rx_ptr++ = word & 0xff;\n\t\t\t}\n\t\t}\n\t}\n\tspi_st->words_remaining -= count;\n}\n\nstatic int spi_st_transfer_one(struct spi_master *master,\n\t\t\t       struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct spi_st *spi_st = spi_master_get_devdata(master);\n\tuint32_t ctl = 0;\n\n\t \n\tspi_st->tx_ptr = t->tx_buf;\n\tspi_st->rx_ptr = t->rx_buf;\n\n\tif (spi->bits_per_word > 8) {\n\t\t \n\t\tspi_st->bytes_per_word = 2;\n\t\tspi_st->words_remaining = t->len / 2;\n\n\t} else if (spi->bits_per_word == 8 && !(t->len & 0x1)) {\n\t\t \n\t\tspi_st->bytes_per_word = 2;\n\t\tspi_st->words_remaining = t->len / 2;\n\n\t\t \n\t\tctl = readl_relaxed(spi_st->base + SSC_CTL);\n\t\twritel_relaxed((ctl | 0xf), spi_st->base + SSC_CTL);\n\n\t\treadl_relaxed(spi_st->base + SSC_RBUF);\n\n\t} else {\n\t\tspi_st->bytes_per_word = 1;\n\t\tspi_st->words_remaining = t->len;\n\t}\n\n\treinit_completion(&spi_st->done);\n\n\t \n\tssc_write_tx_fifo(spi_st);\n\twritel_relaxed(SSC_IEN_TEEN, spi_st->base + SSC_IEN);\n\n\t \n\twait_for_completion(&spi_st->done);\n\n\t \n\tif (ctl)\n\t\twritel_relaxed(ctl, spi_st->base + SSC_CTL);\n\n\tspi_finalize_current_transfer(spi->master);\n\n\treturn t->len;\n}\n\n \n#define MODEBITS  (SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_LOOP | SPI_CS_HIGH)\nstatic int spi_st_setup(struct spi_device *spi)\n{\n\tstruct spi_st *spi_st = spi_master_get_devdata(spi->master);\n\tu32 spi_st_clk, sscbrg, var;\n\tu32 hz = spi->max_speed_hz;\n\n\tif (!hz)  {\n\t\tdev_err(&spi->dev, \"max_speed_hz unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!spi_get_csgpiod(spi, 0)) {\n\t\tdev_err(&spi->dev, \"no valid gpio assigned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspi_st_clk = clk_get_rate(spi_st->clk);\n\n\t \n\tsscbrg = spi_st_clk / (2 * hz);\n\tif (sscbrg < 0x07 || sscbrg > BIT(16)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"baudrate %d outside valid range %d\\n\", sscbrg, hz);\n\t\treturn -EINVAL;\n\t}\n\n\tspi_st->baud = spi_st_clk / (2 * sscbrg);\n\tif (sscbrg == BIT(16))  \n\t\tsscbrg = 0x0;\n\n\twritel_relaxed(sscbrg, spi_st->base + SSC_BRG);\n\n\tdev_dbg(&spi->dev,\n\t\t\"setting baudrate:target= %u hz, actual= %u hz, sscbrg= %u\\n\",\n\t\thz, spi_st->baud, sscbrg);\n\n\t \n\tvar = readl_relaxed(spi_st->base + SSC_CTL);\n\tvar |= SSC_CTL_MS;\n\n\tif (spi->mode & SPI_CPOL)\n\t\tvar |= SSC_CTL_PO;\n\telse\n\t\tvar &= ~SSC_CTL_PO;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tvar |= SSC_CTL_PH;\n\telse\n\t\tvar &= ~SSC_CTL_PH;\n\n\tif ((spi->mode & SPI_LSB_FIRST) == 0)\n\t\tvar |= SSC_CTL_HB;\n\telse\n\t\tvar &= ~SSC_CTL_HB;\n\n\tif (spi->mode & SPI_LOOP)\n\t\tvar |= SSC_CTL_LPB;\n\telse\n\t\tvar &= ~SSC_CTL_LPB;\n\n\tvar &= ~SSC_CTL_DATA_WIDTH_MSK;\n\tvar |= (spi->bits_per_word - 1);\n\n\tvar |= SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO;\n\tvar |= SSC_CTL_EN;\n\n\twritel_relaxed(var, spi_st->base + SSC_CTL);\n\n\t \n\treadl_relaxed(spi_st->base + SSC_RBUF);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t spi_st_irq(int irq, void *dev_id)\n{\n\tstruct spi_st *spi_st = (struct spi_st *)dev_id;\n\n\t \n\tssc_read_rx_fifo(spi_st);\n\n\t \n\tif (spi_st->words_remaining) {\n\t\tssc_write_tx_fifo(spi_st);\n\t} else {\n\t\t \n\t\twritel_relaxed(0x0, spi_st->base + SSC_IEN);\n\t\t \n\t\treadl(spi_st->base + SSC_IEN);\n\t\tcomplete(&spi_st->done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spi_st_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spi_master *master;\n\tstruct spi_st *spi_st;\n\tint irq, ret = 0;\n\tu32 var;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*spi_st));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->dev.of_node\t\t= np;\n\tmaster->mode_bits\t\t= MODEBITS;\n\tmaster->setup\t\t\t= spi_st_setup;\n\tmaster->transfer_one\t\t= spi_st_transfer_one;\n\tmaster->bits_per_word_mask\t= SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n\tmaster->auto_runtime_pm\t\t= true;\n\tmaster->bus_num\t\t\t= pdev->id;\n\tmaster->use_gpio_descriptors\t= true;\n\tspi_st\t\t\t\t= spi_master_get_devdata(master);\n\n\tspi_st->clk = devm_clk_get(&pdev->dev, \"ssc\");\n\tif (IS_ERR(spi_st->clk)) {\n\t\tdev_err(&pdev->dev, \"Unable to request clock\\n\");\n\t\tret = PTR_ERR(spi_st->clk);\n\t\tgoto put_master;\n\t}\n\n\tret = clk_prepare_enable(spi_st->clk);\n\tif (ret)\n\t\tgoto put_master;\n\n\tinit_completion(&spi_st->done);\n\n\t \n\tspi_st->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spi_st->base)) {\n\t\tret = PTR_ERR(spi_st->base);\n\t\tgoto clk_disable;\n\t}\n\n\t \n\twritel_relaxed(0x0, spi_st->base + SSC_I2C);\n\tvar = readw_relaxed(spi_st->base + SSC_CTL);\n\tvar |= SSC_CTL_SR;\n\twritel_relaxed(var, spi_st->base + SSC_CTL);\n\n\tudelay(1);\n\tvar = readl_relaxed(spi_st->base + SSC_CTL);\n\tvar &= ~SSC_CTL_SR;\n\twritel_relaxed(var, spi_st->base + SSC_CTL);\n\n\t \n\tvar = readl_relaxed(spi_st->base + SSC_CTL);\n\tvar &= ~SSC_CTL_MS;\n\twritel_relaxed(var, spi_st->base + SSC_CTL);\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tdev_err(&pdev->dev, \"IRQ missing or invalid\\n\");\n\t\tret = -EINVAL;\n\t\tgoto clk_disable;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, spi_st_irq, 0,\n\t\t\t       pdev->name, spi_st);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq %d\\n\", irq);\n\t\tgoto clk_disable;\n\t}\n\n\t \n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, master);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register master\\n\");\n\t\tgoto rpm_disable;\n\t}\n\n\treturn 0;\n\nrpm_disable:\n\tpm_runtime_disable(&pdev->dev);\nclk_disable:\n\tclk_disable_unprepare(spi_st->clk);\nput_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void spi_st_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct spi_st *spi_st = spi_master_get_devdata(master);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(spi_st->clk);\n\n\tpinctrl_pm_select_sleep_state(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int spi_st_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct spi_st *spi_st = spi_master_get_devdata(master);\n\n\twritel_relaxed(0, spi_st->base + SSC_IEN);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\tclk_disable_unprepare(spi_st->clk);\n\n\treturn 0;\n}\n\nstatic int spi_st_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct spi_st *spi_st = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(spi_st->clk);\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int spi_st_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_master_suspend(master);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int spi_st_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_master_resume(master);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_resume(dev);\n}\n#endif\n\nstatic const struct dev_pm_ops spi_st_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(spi_st_suspend, spi_st_resume)\n\tSET_RUNTIME_PM_OPS(spi_st_runtime_suspend, spi_st_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id stm_spi_match[] = {\n\t{ .compatible = \"st,comms-ssc4-spi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm_spi_match);\n\nstatic struct platform_driver spi_st_driver = {\n\t.driver = {\n\t\t.name = \"spi-st\",\n\t\t.pm = &spi_st_pm,\n\t\t.of_match_table = of_match_ptr(stm_spi_match),\n\t},\n\t.probe = spi_st_probe,\n\t.remove_new = spi_st_remove,\n};\nmodule_platform_driver(spi_st_driver);\n\nMODULE_AUTHOR(\"Patrice Chotard <patrice.chotard@st.com>\");\nMODULE_DESCRIPTION(\"STM SSC SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}