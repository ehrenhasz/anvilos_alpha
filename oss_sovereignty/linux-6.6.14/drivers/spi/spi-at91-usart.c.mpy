{
  "module_name": "spi-at91-usart.c",
  "hash_id": "68e7747b35cf1db5bc34c44856fbff192d364ec9e8cae335fb6a5bd4738ed608",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-at91-usart.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-direction.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/spi/spi.h>\n\n#define US_CR\t\t\t0x00\n#define US_MR\t\t\t0x04\n#define US_IER\t\t\t0x08\n#define US_IDR\t\t\t0x0C\n#define US_CSR\t\t\t0x14\n#define US_RHR\t\t\t0x18\n#define US_THR\t\t\t0x1C\n#define US_BRGR\t\t\t0x20\n#define US_VERSION\t\t0xFC\n\n#define US_CR_RSTRX\t\tBIT(2)\n#define US_CR_RSTTX\t\tBIT(3)\n#define US_CR_RXEN\t\tBIT(4)\n#define US_CR_RXDIS\t\tBIT(5)\n#define US_CR_TXEN\t\tBIT(6)\n#define US_CR_TXDIS\t\tBIT(7)\n\n#define US_MR_SPI_HOST\t\t0x0E\n#define US_MR_CHRL\t\tGENMASK(7, 6)\n#define US_MR_CPHA\t\tBIT(8)\n#define US_MR_CPOL\t\tBIT(16)\n#define US_MR_CLKO\t\tBIT(18)\n#define US_MR_WRDBT\t\tBIT(20)\n#define US_MR_LOOP\t\tBIT(15)\n\n#define US_IR_RXRDY\t\tBIT(0)\n#define US_IR_TXRDY\t\tBIT(1)\n#define US_IR_OVRE\t\tBIT(5)\n\n#define US_BRGR_SIZE\t\tBIT(16)\n\n#define US_MIN_CLK_DIV\t\t0x06\n#define US_MAX_CLK_DIV\t\tBIT(16)\n\n#define US_RESET\t\t(US_CR_RSTRX | US_CR_RSTTX)\n#define US_DISABLE\t\t(US_CR_RXDIS | US_CR_TXDIS)\n#define US_ENABLE\t\t(US_CR_RXEN | US_CR_TXEN)\n#define US_OVRE_RXRDY_IRQS\t(US_IR_OVRE | US_IR_RXRDY)\n\n#define US_INIT \\\n\t(US_MR_SPI_HOST | US_MR_CHRL | US_MR_CLKO | US_MR_WRDBT)\n#define US_DMA_MIN_BYTES       16\n#define US_DMA_TIMEOUT         (msecs_to_jiffies(1000))\n\n \n#define at91_usart_spi_readl(port, reg) \\\n\treadl_relaxed((port)->regs + US_##reg)\n#define at91_usart_spi_writel(port, reg, value) \\\n\twritel_relaxed((value), (port)->regs + US_##reg)\n\n#define at91_usart_spi_readb(port, reg) \\\n\treadb_relaxed((port)->regs + US_##reg)\n#define at91_usart_spi_writeb(port, reg, value) \\\n\twriteb_relaxed((value), (port)->regs + US_##reg)\n\nstruct at91_usart_spi {\n\tstruct platform_device  *mpdev;\n\tstruct spi_transfer\t*current_transfer;\n\tvoid __iomem\t\t*regs;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\n\tstruct completion\txfer_completion;\n\n\t \n\tspinlock_t\t\tlock;\n\n\tphys_addr_t\t\tphybase;\n\n\tint\t\t\tirq;\n\tunsigned int\t\tcurrent_tx_remaining_bytes;\n\tunsigned int\t\tcurrent_rx_remaining_bytes;\n\n\tu32\t\t\tspi_clk;\n\tu32\t\t\tstatus;\n\n\tbool\t\t\txfer_failed;\n\tbool\t\t\tuse_dma;\n};\n\nstatic void dma_callback(void *data)\n{\n\tstruct spi_controller   *ctlr = data;\n\tstruct at91_usart_spi   *aus = spi_controller_get_devdata(ctlr);\n\n\tat91_usart_spi_writel(aus, IER, US_IR_RXRDY);\n\taus->current_rx_remaining_bytes = 0;\n\tcomplete(&aus->xfer_completion);\n}\n\nstatic bool at91_usart_spi_can_dma(struct spi_controller *ctrl,\n\t\t\t\t   struct spi_device *spi,\n\t\t\t\t   struct spi_transfer *xfer)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctrl);\n\n\treturn aus->use_dma && xfer->len >= US_DMA_MIN_BYTES;\n}\n\nstatic int at91_usart_spi_configure_dma(struct spi_controller *ctlr,\n\t\t\t\t\tstruct at91_usart_spi *aus)\n{\n\tstruct dma_slave_config slave_config;\n\tstruct device *dev = &aus->mpdev->dev;\n\tphys_addr_t phybase = aus->phybase;\n\tdma_cap_mask_t mask;\n\tint err = 0;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tctlr->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR_OR_NULL(ctlr->dma_tx)) {\n\t\tif (IS_ERR(ctlr->dma_tx)) {\n\t\t\terr = PTR_ERR(ctlr->dma_tx);\n\t\t\tgoto at91_usart_spi_error_clear;\n\t\t}\n\n\t\tdev_dbg(dev,\n\t\t\t\"DMA TX channel not available, SPI unable to use DMA\\n\");\n\t\terr = -EBUSY;\n\t\tgoto at91_usart_spi_error_clear;\n\t}\n\n\tctlr->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR_OR_NULL(ctlr->dma_rx)) {\n\t\tif (IS_ERR(ctlr->dma_rx)) {\n\t\t\terr = PTR_ERR(ctlr->dma_rx);\n\t\t\tgoto at91_usart_spi_error;\n\t\t}\n\n\t\tdev_dbg(dev,\n\t\t\t\"DMA RX channel not available, SPI unable to use DMA\\n\");\n\t\terr = -EBUSY;\n\t\tgoto at91_usart_spi_error;\n\t}\n\n\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tslave_config.dst_addr = (dma_addr_t)phybase + US_THR;\n\tslave_config.src_addr = (dma_addr_t)phybase + US_RHR;\n\tslave_config.src_maxburst = 1;\n\tslave_config.dst_maxburst = 1;\n\tslave_config.device_fc = false;\n\n\tslave_config.direction = DMA_DEV_TO_MEM;\n\tif (dmaengine_slave_config(ctlr->dma_rx, &slave_config)) {\n\t\tdev_err(&ctlr->dev,\n\t\t\t\"failed to configure rx dma channel\\n\");\n\t\terr = -EINVAL;\n\t\tgoto at91_usart_spi_error;\n\t}\n\n\tslave_config.direction = DMA_MEM_TO_DEV;\n\tif (dmaengine_slave_config(ctlr->dma_tx, &slave_config)) {\n\t\tdev_err(&ctlr->dev,\n\t\t\t\"failed to configure tx dma channel\\n\");\n\t\terr = -EINVAL;\n\t\tgoto at91_usart_spi_error;\n\t}\n\n\taus->use_dma = true;\n\treturn 0;\n\nat91_usart_spi_error:\n\tif (!IS_ERR_OR_NULL(ctlr->dma_tx))\n\t\tdma_release_channel(ctlr->dma_tx);\n\tif (!IS_ERR_OR_NULL(ctlr->dma_rx))\n\t\tdma_release_channel(ctlr->dma_rx);\n\tctlr->dma_tx = NULL;\n\tctlr->dma_rx = NULL;\n\nat91_usart_spi_error_clear:\n\treturn err;\n}\n\nstatic void at91_usart_spi_release_dma(struct spi_controller *ctlr)\n{\n\tif (ctlr->dma_rx)\n\t\tdma_release_channel(ctlr->dma_rx);\n\tif (ctlr->dma_tx)\n\t\tdma_release_channel(ctlr->dma_tx);\n}\n\nstatic void at91_usart_spi_stop_dma(struct spi_controller *ctlr)\n{\n\tif (ctlr->dma_rx)\n\t\tdmaengine_terminate_all(ctlr->dma_rx);\n\tif (ctlr->dma_tx)\n\t\tdmaengine_terminate_all(ctlr->dma_tx);\n}\n\nstatic int at91_usart_spi_dma_transfer(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\tstruct dma_chan\t *rxchan = ctlr->dma_rx;\n\tstruct dma_chan *txchan = ctlr->dma_tx;\n\tstruct dma_async_tx_descriptor *rxdesc;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tdma_cookie_t cookie;\n\n\t \n\tat91_usart_spi_writel(aus, IDR, US_IR_RXRDY);\n\n\trxdesc = dmaengine_prep_slave_sg(rxchan,\n\t\t\t\t\t xfer->rx_sg.sgl,\n\t\t\t\t\t xfer->rx_sg.nents,\n\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT |\n\t\t\t\t\t DMA_CTRL_ACK);\n\tif (!rxdesc)\n\t\tgoto at91_usart_spi_err_dma;\n\n\ttxdesc = dmaengine_prep_slave_sg(txchan,\n\t\t\t\t\t xfer->tx_sg.sgl,\n\t\t\t\t\t xfer->tx_sg.nents,\n\t\t\t\t\t DMA_MEM_TO_DEV,\n\t\t\t\t\t DMA_PREP_INTERRUPT |\n\t\t\t\t\t DMA_CTRL_ACK);\n\tif (!txdesc)\n\t\tgoto at91_usart_spi_err_dma;\n\n\trxdesc->callback = dma_callback;\n\trxdesc->callback_param = ctlr;\n\n\tcookie = rxdesc->tx_submit(rxdesc);\n\tif (dma_submit_error(cookie))\n\t\tgoto at91_usart_spi_err_dma;\n\n\tcookie = txdesc->tx_submit(txdesc);\n\tif (dma_submit_error(cookie))\n\t\tgoto at91_usart_spi_err_dma;\n\n\trxchan->device->device_issue_pending(rxchan);\n\ttxchan->device->device_issue_pending(txchan);\n\n\treturn 0;\n\nat91_usart_spi_err_dma:\n\t \n\tat91_usart_spi_writel(aus, IER, US_IR_RXRDY);\n\tat91_usart_spi_stop_dma(ctlr);\n\n\treturn -ENOMEM;\n}\n\nstatic unsigned long at91_usart_spi_dma_timeout(struct at91_usart_spi *aus)\n{\n\treturn wait_for_completion_timeout(&aus->xfer_completion,\n\t\t\t\t\t   US_DMA_TIMEOUT);\n}\n\nstatic inline u32 at91_usart_spi_tx_ready(struct at91_usart_spi *aus)\n{\n\treturn aus->status & US_IR_TXRDY;\n}\n\nstatic inline u32 at91_usart_spi_rx_ready(struct at91_usart_spi *aus)\n{\n\treturn aus->status & US_IR_RXRDY;\n}\n\nstatic inline u32 at91_usart_spi_check_overrun(struct at91_usart_spi *aus)\n{\n\treturn aus->status & US_IR_OVRE;\n}\n\nstatic inline u32 at91_usart_spi_read_status(struct at91_usart_spi *aus)\n{\n\taus->status = at91_usart_spi_readl(aus, CSR);\n\treturn aus->status;\n}\n\nstatic inline void at91_usart_spi_tx(struct at91_usart_spi *aus)\n{\n\tunsigned int len = aus->current_transfer->len;\n\tunsigned int remaining = aus->current_tx_remaining_bytes;\n\tconst u8  *tx_buf = aus->current_transfer->tx_buf;\n\n\tif (!remaining)\n\t\treturn;\n\n\tif (at91_usart_spi_tx_ready(aus)) {\n\t\tat91_usart_spi_writeb(aus, THR, tx_buf[len - remaining]);\n\t\taus->current_tx_remaining_bytes--;\n\t}\n}\n\nstatic inline void at91_usart_spi_rx(struct at91_usart_spi *aus)\n{\n\tint len = aus->current_transfer->len;\n\tint remaining = aus->current_rx_remaining_bytes;\n\tu8  *rx_buf = aus->current_transfer->rx_buf;\n\n\tif (!remaining)\n\t\treturn;\n\n\trx_buf[len - remaining] = at91_usart_spi_readb(aus, RHR);\n\taus->current_rx_remaining_bytes--;\n}\n\nstatic inline void\nat91_usart_spi_set_xfer_speed(struct at91_usart_spi *aus,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tat91_usart_spi_writel(aus, BRGR,\n\t\t\t      DIV_ROUND_UP(aus->spi_clk, xfer->speed_hz));\n}\n\nstatic irqreturn_t at91_usart_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *controller = dev_id;\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(controller);\n\n\tspin_lock(&aus->lock);\n\tat91_usart_spi_read_status(aus);\n\n\tif (at91_usart_spi_check_overrun(aus)) {\n\t\taus->xfer_failed = true;\n\t\tat91_usart_spi_writel(aus, IDR, US_IR_OVRE | US_IR_RXRDY);\n\t\tspin_unlock(&aus->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (at91_usart_spi_rx_ready(aus)) {\n\t\tat91_usart_spi_rx(aus);\n\t\tspin_unlock(&aus->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&aus->lock);\n\n\treturn IRQ_NONE;\n}\n\nstatic int at91_usart_spi_setup(struct spi_device *spi)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(spi->controller);\n\tu32 *ausd = spi->controller_state;\n\tunsigned int mr = at91_usart_spi_readl(aus, MR);\n\n\tif (spi->mode & SPI_CPOL)\n\t\tmr |= US_MR_CPOL;\n\telse\n\t\tmr &= ~US_MR_CPOL;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tmr |= US_MR_CPHA;\n\telse\n\t\tmr &= ~US_MR_CPHA;\n\n\tif (spi->mode & SPI_LOOP)\n\t\tmr |= US_MR_LOOP;\n\telse\n\t\tmr &= ~US_MR_LOOP;\n\n\tif (!ausd) {\n\t\tausd = kzalloc(sizeof(*ausd), GFP_KERNEL);\n\t\tif (!ausd)\n\t\t\treturn -ENOMEM;\n\n\t\tspi->controller_state = ausd;\n\t}\n\n\t*ausd = mr;\n\n\tdev_dbg(&spi->dev,\n\t\t\"setup: bpw %u mode 0x%x -> mr %d %08x\\n\",\n\t\tspi->bits_per_word, spi->mode, spi_get_chipselect(spi, 0), mr);\n\n\treturn 0;\n}\n\nstatic int at91_usart_spi_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\tunsigned long dma_timeout = 0;\n\tint ret = 0;\n\n\tat91_usart_spi_set_xfer_speed(aus, xfer);\n\taus->xfer_failed = false;\n\taus->current_transfer = xfer;\n\taus->current_tx_remaining_bytes = xfer->len;\n\taus->current_rx_remaining_bytes = xfer->len;\n\n\twhile ((aus->current_tx_remaining_bytes ||\n\t\taus->current_rx_remaining_bytes) && !aus->xfer_failed) {\n\t\treinit_completion(&aus->xfer_completion);\n\t\tif (at91_usart_spi_can_dma(ctlr, spi, xfer) &&\n\t\t    !ret) {\n\t\t\tret = at91_usart_spi_dma_transfer(ctlr, xfer);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tdma_timeout = at91_usart_spi_dma_timeout(aus);\n\n\t\t\tif (WARN_ON(dma_timeout == 0)) {\n\t\t\t\tdev_err(&spi->dev, \"DMA transfer timeout\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\taus->current_tx_remaining_bytes = 0;\n\t\t} else {\n\t\t\tat91_usart_spi_read_status(aus);\n\t\t\tat91_usart_spi_tx(aus);\n\t\t}\n\n\t\tcpu_relax();\n\t}\n\n\tif (aus->xfer_failed) {\n\t\tdev_err(aus->dev, \"Overrun!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_usart_spi_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t\t  struct spi_message *message)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = message->spi;\n\tu32 *ausd = spi->controller_state;\n\n\tat91_usart_spi_writel(aus, CR, US_ENABLE);\n\tat91_usart_spi_writel(aus, IER, US_OVRE_RXRDY_IRQS);\n\tat91_usart_spi_writel(aus, MR, *ausd);\n\n\treturn 0;\n}\n\nstatic int at91_usart_spi_unprepare_message(struct spi_controller *ctlr,\n\t\t\t\t\t    struct spi_message *message)\n{\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\n\tat91_usart_spi_writel(aus, CR, US_RESET | US_DISABLE);\n\tat91_usart_spi_writel(aus, IDR, US_OVRE_RXRDY_IRQS);\n\n\treturn 0;\n}\n\nstatic void at91_usart_spi_cleanup(struct spi_device *spi)\n{\n\tstruct at91_usart_spi_device *ausd = spi->controller_state;\n\n\tspi->controller_state = NULL;\n\tkfree(ausd);\n}\n\nstatic void at91_usart_spi_init(struct at91_usart_spi *aus)\n{\n\tat91_usart_spi_writel(aus, MR, US_INIT);\n\tat91_usart_spi_writel(aus, CR, US_RESET | US_DISABLE);\n}\n\nstatic int at91_usart_gpio_setup(struct platform_device *pdev)\n{\n\tstruct gpio_descs *cs_gpios;\n\n\tcs_gpios = devm_gpiod_get_array_optional(&pdev->dev, \"cs\", GPIOD_OUT_LOW);\n\n\treturn PTR_ERR_OR_ZERO(cs_gpios);\n}\n\nstatic int at91_usart_spi_probe(struct platform_device *pdev)\n{\n\tstruct resource *regs;\n\tstruct spi_controller *controller;\n\tstruct at91_usart_spi *aus;\n\tstruct clk *clk;\n\tint irq;\n\tint ret;\n\n\tregs = platform_get_resource(to_platform_device(pdev->dev.parent),\n\t\t\t\t     IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(to_platform_device(pdev->dev.parent), 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tclk = devm_clk_get(pdev->dev.parent, \"usart\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = -ENOMEM;\n\tcontroller = spi_alloc_host(&pdev->dev, sizeof(*aus));\n\tif (!controller)\n\t\tgoto at91_usart_spi_probe_fail;\n\n\tret = at91_usart_gpio_setup(pdev);\n\tif (ret)\n\t\tgoto at91_usart_spi_probe_fail;\n\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP | SPI_CS_HIGH;\n\tcontroller->dev.of_node = pdev->dev.parent->of_node;\n\tcontroller->bits_per_word_mask = SPI_BPW_MASK(8);\n\tcontroller->setup = at91_usart_spi_setup;\n\tcontroller->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\tcontroller->transfer_one = at91_usart_spi_transfer_one;\n\tcontroller->prepare_message = at91_usart_spi_prepare_message;\n\tcontroller->unprepare_message = at91_usart_spi_unprepare_message;\n\tcontroller->can_dma = at91_usart_spi_can_dma;\n\tcontroller->cleanup = at91_usart_spi_cleanup;\n\tcontroller->max_speed_hz = DIV_ROUND_UP(clk_get_rate(clk),\n\t\t\t\t\t\tUS_MIN_CLK_DIV);\n\tcontroller->min_speed_hz = DIV_ROUND_UP(clk_get_rate(clk),\n\t\t\t\t\t\tUS_MAX_CLK_DIV);\n\tplatform_set_drvdata(pdev, controller);\n\n\taus = spi_controller_get_devdata(controller);\n\n\taus->dev = &pdev->dev;\n\taus->regs = devm_ioremap_resource(&pdev->dev, regs);\n\tif (IS_ERR(aus->regs)) {\n\t\tret = PTR_ERR(aus->regs);\n\t\tgoto at91_usart_spi_probe_fail;\n\t}\n\n\taus->irq = irq;\n\taus->clk = clk;\n\n\tret = devm_request_irq(&pdev->dev, irq, at91_usart_spi_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), controller);\n\tif (ret)\n\t\tgoto at91_usart_spi_probe_fail;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto at91_usart_spi_probe_fail;\n\n\taus->spi_clk = clk_get_rate(clk);\n\tat91_usart_spi_init(aus);\n\n\taus->phybase = regs->start;\n\n\taus->mpdev = to_platform_device(pdev->dev.parent);\n\n\tret = at91_usart_spi_configure_dma(controller, aus);\n\tif (ret)\n\t\tgoto at91_usart_fail_dma;\n\n\tspin_lock_init(&aus->lock);\n\tinit_completion(&aus->xfer_completion);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret)\n\t\tgoto at91_usart_fail_register_controller;\n\n\tdev_info(&pdev->dev,\n\t\t \"AT91 USART SPI Controller version 0x%x at %pa (irq %d)\\n\",\n\t\t at91_usart_spi_readl(aus, VERSION),\n\t\t &regs->start, irq);\n\n\treturn 0;\n\nat91_usart_fail_register_controller:\n\tat91_usart_spi_release_dma(controller);\nat91_usart_fail_dma:\n\tclk_disable_unprepare(clk);\nat91_usart_spi_probe_fail:\n\tspi_controller_put(controller);\n\treturn ret;\n}\n\n__maybe_unused static int at91_usart_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\n\tclk_disable_unprepare(aus->clk);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\n__maybe_unused static int at91_usart_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctrl);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn clk_prepare_enable(aus->clk);\n}\n\n__maybe_unused static int at91_usart_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tat91_usart_spi_runtime_suspend(dev);\n\n\treturn 0;\n}\n\n__maybe_unused static int at91_usart_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = at91_usart_spi_runtime_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tat91_usart_spi_init(aus);\n\n\treturn spi_controller_resume(ctrl);\n}\n\nstatic void at91_usart_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = platform_get_drvdata(pdev);\n\tstruct at91_usart_spi *aus = spi_controller_get_devdata(ctlr);\n\n\tat91_usart_spi_release_dma(ctlr);\n\tclk_disable_unprepare(aus->clk);\n}\n\nstatic const struct dev_pm_ops at91_usart_spi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(at91_usart_spi_suspend, at91_usart_spi_resume)\n\tSET_RUNTIME_PM_OPS(at91_usart_spi_runtime_suspend,\n\t\t\t   at91_usart_spi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver at91_usart_spi_driver = {\n\t.driver = {\n\t\t.name = \"at91_usart_spi\",\n\t\t.pm = &at91_usart_spi_pm_ops,\n\t},\n\t.probe = at91_usart_spi_probe,\n\t.remove_new = at91_usart_spi_remove,\n};\n\nmodule_platform_driver(at91_usart_spi_driver);\n\nMODULE_DESCRIPTION(\"Microchip AT91 USART SPI Controller driver\");\nMODULE_AUTHOR(\"Radu Pirea <radu.pirea@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:at91_usart_spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}