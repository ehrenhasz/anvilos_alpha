{
  "module_name": "spi-sunplus-sp7021.c",
  "hash_id": "696572a203f1409cc9d229bda89fab2f0ecc45b3c12f5f066160d4f464fa7a36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sunplus-sp7021.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n\n#define SP7021_DATA_RDY_REG\t\t0x0044\n#define SP7021_SLAVE_DMA_CTRL_REG\t0x0048\n#define SP7021_SLAVE_DMA_LENGTH_REG\t0x004c\n#define SP7021_SLAVE_DMA_ADDR_REG\t0x004c\n\n#define SP7021_SLAVE_DATA_RDY\t\tBIT(0)\n#define SP7021_SLAVE_SW_RST\t\tBIT(1)\n#define SP7021_SLA_DMA_W_INT\t\tBIT(8)\n#define SP7021_SLAVE_CLR_INT\t\tBIT(8)\n#define SP7021_SLAVE_DMA_EN\t\tBIT(0)\n#define SP7021_SLAVE_DMA_RW\t\tBIT(6)\n#define SP7021_SLAVE_DMA_CMD\t\tGENMASK(3, 2)\n\n#define SP7021_FIFO_REG\t\t\t0x0034\n#define SP7021_SPI_STATUS_REG\t\t0x0038\n#define SP7021_SPI_CONFIG_REG\t\t0x003c\n#define SP7021_INT_BUSY_REG\t\t0x004c\n#define SP7021_DMA_CTRL_REG\t\t0x0050\n\n#define SP7021_SPI_START_FD\t\tBIT(0)\n#define SP7021_FD_SW_RST\t\tBIT(1)\n#define SP7021_TX_EMP_FLAG\t\tBIT(2)\n#define SP7021_RX_EMP_FLAG\t\tBIT(4)\n#define SP7021_RX_FULL_FLAG\t\tBIT(5)\n#define SP7021_FINISH_FLAG\t\tBIT(6)\n\n#define SP7021_TX_CNT_MASK\t\tGENMASK(11, 8)\n#define SP7021_RX_CNT_MASK\t\tGENMASK(15, 12)\n#define SP7021_TX_LEN_MASK\t\tGENMASK(23, 16)\n#define SP7021_GET_LEN_MASK\t\tGENMASK(31, 24)\n#define SP7021_SET_TX_LEN\t\tGENMASK(23, 16)\n#define SP7021_SET_XFER_LEN\t\tGENMASK(31, 24)\n\n#define SP7021_CPOL_FD\t\t\tBIT(0)\n#define SP7021_CPHA_R\t\t\tBIT(1)\n#define SP7021_CPHA_W\t\t\tBIT(2)\n#define SP7021_LSB_SEL\t\t\tBIT(4)\n#define SP7021_CS_POR\t\t\tBIT(5)\n#define SP7021_FD_SEL\t\t\tBIT(6)\n\n#define SP7021_RX_UNIT\t\t\tGENMASK(8, 7)\n#define SP7021_TX_UNIT\t\t\tGENMASK(10, 9)\n#define SP7021_TX_EMP_FLAG_MASK\t\tBIT(11)\n#define SP7021_RX_FULL_FLAG_MASK\tBIT(14)\n#define SP7021_FINISH_FLAG_MASK\t\tBIT(15)\n#define SP7021_CLEAN_RW_BYTE\t\tGENMASK(10, 7)\n#define SP7021_CLEAN_FLUG_MASK\t\tGENMASK(15, 11)\n#define SP7021_CLK_MASK\t\t\tGENMASK(31, 16)\n\n#define SP7021_INT_BYPASS\t\tBIT(3)\n#define SP7021_CLR_MASTER_INT\t\tBIT(6)\n\n#define SP7021_SPI_DATA_SIZE\t\t(255)\n#define SP7021_FIFO_DATA_LEN\t\t(16)\n\nenum {\n\tSP7021_MASTER_MODE = 0,\n\tSP7021_SLAVE_MODE = 1,\n};\n\nstruct sp7021_spi_ctlr {\n\tstruct device *dev;\n\tstruct spi_controller *ctlr;\n\tvoid __iomem *m_base;\n\tvoid __iomem *s_base;\n\tu32 xfer_conf;\n\tint mode;\n\tint m_irq;\n\tint s_irq;\n\tstruct clk *spi_clk;\n\tstruct reset_control *rstc;\n\t\n\tstruct mutex buf_lock;\n\tstruct completion isr_done;\n\tstruct completion slave_isr;\n\tunsigned int  rx_cur_len;\n\tunsigned int  tx_cur_len;\n\tunsigned int  data_unit;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n};\n\nstatic irqreturn_t sp7021_spi_slave_irq(int irq, void *dev)\n{\n\tstruct sp7021_spi_ctlr *pspim = dev;\n\tunsigned int data_status;\n\n\tdata_status = readl(pspim->s_base + SP7021_DATA_RDY_REG);\n\tdata_status |= SP7021_SLAVE_CLR_INT;\n\twritel(data_status , pspim->s_base + SP7021_DATA_RDY_REG);\n\tcomplete(&pspim->slave_isr);\n\treturn IRQ_HANDLED;\n}\n\nstatic int sp7021_spi_slave_abort(struct spi_controller *ctlr)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\tcomplete(&pspim->slave_isr);\n\tcomplete(&pspim->isr_done);\n\treturn 0;\n}\n\nstatic int sp7021_spi_slave_tx(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_controller_get_devdata(spi->controller);\n\tu32 value;\n\n\treinit_completion(&pspim->slave_isr);\n\tvalue = SP7021_SLAVE_DMA_EN | SP7021_SLAVE_DMA_RW | FIELD_PREP(SP7021_SLAVE_DMA_CMD, 3);\n\twritel(value, pspim->s_base + SP7021_SLAVE_DMA_CTRL_REG);\n\twritel(xfer->len, pspim->s_base + SP7021_SLAVE_DMA_LENGTH_REG);\n\twritel(xfer->tx_dma, pspim->s_base + SP7021_SLAVE_DMA_ADDR_REG);\n\tvalue = readl(pspim->s_base + SP7021_DATA_RDY_REG);\n\tvalue |= SP7021_SLAVE_DATA_RDY;\n\twritel(value, pspim->s_base + SP7021_DATA_RDY_REG);\n\tif (wait_for_completion_interruptible(&pspim->isr_done)) {\n\t\tdev_err(&spi->dev, \"%s() wait_for_completion err\\n\", __func__);\n\t\treturn -EINTR;\n\t}\n\treturn 0;\n}\n\nstatic int sp7021_spi_slave_rx(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_controller_get_devdata(spi->controller);\n\tu32 value;\n\n\treinit_completion(&pspim->isr_done);\n\tvalue = SP7021_SLAVE_DMA_EN | FIELD_PREP(SP7021_SLAVE_DMA_CMD, 3);\n\twritel(value, pspim->s_base + SP7021_SLAVE_DMA_CTRL_REG);\n\twritel(xfer->len, pspim->s_base + SP7021_SLAVE_DMA_LENGTH_REG);\n\twritel(xfer->rx_dma, pspim->s_base + SP7021_SLAVE_DMA_ADDR_REG);\n\tif (wait_for_completion_interruptible(&pspim->isr_done)) {\n\t\tdev_err(&spi->dev, \"%s() wait_for_completion err\\n\", __func__);\n\t\treturn -EINTR;\n\t}\n\twritel(SP7021_SLAVE_SW_RST, pspim->s_base + SP7021_SLAVE_DMA_CTRL_REG);\n\treturn 0;\n}\n\nstatic void sp7021_spi_master_rb(struct sp7021_spi_ctlr *pspim, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tpspim->rx_buf[pspim->rx_cur_len] =\n\t\t\treadl(pspim->m_base + SP7021_FIFO_REG);\n\t\tpspim->rx_cur_len++;\n\t}\n}\n\nstatic void sp7021_spi_master_wb(struct sp7021_spi_ctlr *pspim, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\twritel(pspim->tx_buf[pspim->tx_cur_len],\n\t\t       pspim->m_base + SP7021_FIFO_REG);\n\t\tpspim->tx_cur_len++;\n\t}\n}\n\nstatic irqreturn_t sp7021_spi_master_irq(int irq, void *dev)\n{\n\tstruct sp7021_spi_ctlr *pspim = dev;\n\tunsigned int tx_cnt, total_len;\n\tunsigned int tx_len, rx_cnt;\n\tunsigned int fd_status;\n\tbool isrdone = false;\n\tu32 value;\n\n\tfd_status = readl(pspim->m_base + SP7021_SPI_STATUS_REG);\n\ttx_cnt = FIELD_GET(SP7021_TX_CNT_MASK, fd_status);\n\ttx_len = FIELD_GET(SP7021_TX_LEN_MASK, fd_status);\n\ttotal_len = FIELD_GET(SP7021_GET_LEN_MASK, fd_status);\n\n\tif ((fd_status & SP7021_TX_EMP_FLAG) && (fd_status & SP7021_RX_EMP_FLAG) && total_len == 0)\n\t\treturn IRQ_NONE;\n\n\tif (tx_len == 0 && total_len == 0)\n\t\treturn IRQ_NONE;\n\n\trx_cnt = FIELD_GET(SP7021_RX_CNT_MASK, fd_status);\n\tif (fd_status & SP7021_RX_FULL_FLAG)\n\t\trx_cnt = pspim->data_unit;\n\n\ttx_cnt = min(tx_len - pspim->tx_cur_len, pspim->data_unit - tx_cnt);\n\tdev_dbg(pspim->dev, \"fd_st=0x%x rx_c:%d tx_c:%d tx_l:%d\",\n\t\tfd_status, rx_cnt, tx_cnt, tx_len);\n\n\tif (rx_cnt > 0)\n\t\tsp7021_spi_master_rb(pspim, rx_cnt);\n\tif (tx_cnt > 0)\n\t\tsp7021_spi_master_wb(pspim, tx_cnt);\n\n\tfd_status = readl(pspim->m_base + SP7021_SPI_STATUS_REG);\n\ttx_len = FIELD_GET(SP7021_TX_LEN_MASK, fd_status);\n\ttotal_len = FIELD_GET(SP7021_GET_LEN_MASK, fd_status);\n\n\tif (fd_status & SP7021_FINISH_FLAG || tx_len == pspim->tx_cur_len) {\n\t\twhile (total_len != pspim->rx_cur_len) {\n\t\t\tfd_status = readl(pspim->m_base + SP7021_SPI_STATUS_REG);\n\t\t\ttotal_len = FIELD_GET(SP7021_GET_LEN_MASK, fd_status);\n\t\t\tif (fd_status & SP7021_RX_FULL_FLAG)\n\t\t\t\trx_cnt = pspim->data_unit;\n\t\t\telse\n\t\t\t\trx_cnt = FIELD_GET(SP7021_RX_CNT_MASK, fd_status);\n\n\t\t\tif (rx_cnt > 0)\n\t\t\t\tsp7021_spi_master_rb(pspim, rx_cnt);\n\t\t}\n\t\tvalue = readl(pspim->m_base + SP7021_INT_BUSY_REG);\n\t\tvalue |= SP7021_CLR_MASTER_INT;\n\t\twritel(value, pspim->m_base + SP7021_INT_BUSY_REG);\n\t\twritel(SP7021_FINISH_FLAG, pspim->m_base + SP7021_SPI_STATUS_REG);\n\t\tisrdone = true;\n\t}\n\n\tif (isrdone)\n\t\tcomplete(&pspim->isr_done);\n\treturn IRQ_HANDLED;\n}\n\nstatic void sp7021_prep_transfer(struct spi_controller *ctlr, struct spi_device *spi)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\tpspim->tx_cur_len = 0;\n\tpspim->rx_cur_len = 0;\n\tpspim->data_unit = SP7021_FIFO_DATA_LEN;\n}\n\n\nstatic int sp7021_spi_controller_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t\t\t struct spi_message *msg)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\tstruct spi_device *s = msg->spi;\n\tu32 valus, rs = 0;\n\n\tvalus = readl(pspim->m_base + SP7021_SPI_STATUS_REG);\n\tvalus |= SP7021_FD_SW_RST;\n\twritel(valus, pspim->m_base + SP7021_SPI_STATUS_REG);\n\trs |= SP7021_FD_SEL;\n\tif (s->mode & SPI_CPOL)\n\t\trs |= SP7021_CPOL_FD;\n\n\tif (s->mode & SPI_LSB_FIRST)\n\t\trs |= SP7021_LSB_SEL;\n\n\tif (s->mode & SPI_CS_HIGH)\n\t\trs |= SP7021_CS_POR;\n\n\tif (s->mode & SPI_CPHA)\n\t\trs |=  SP7021_CPHA_R;\n\telse\n\t\trs |=  SP7021_CPHA_W;\n\n\trs |=  FIELD_PREP(SP7021_TX_UNIT, 0) | FIELD_PREP(SP7021_RX_UNIT, 0);\n\tpspim->xfer_conf = rs;\n\tif (pspim->xfer_conf & SP7021_CPOL_FD)\n\t\twritel(pspim->xfer_conf, pspim->m_base + SP7021_SPI_CONFIG_REG);\n\n\treturn 0;\n}\n\nstatic void sp7021_spi_setup_clk(struct spi_controller *ctlr, struct spi_transfer *xfer)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\tu32 clk_rate, clk_sel, div;\n\n\tclk_rate = clk_get_rate(pspim->spi_clk);\n\tdiv = max(2U, clk_rate / xfer->speed_hz);\n\n\tclk_sel = (div / 2) - 1;\n\tpspim->xfer_conf &= ~SP7021_CLK_MASK;\n\tpspim->xfer_conf |= FIELD_PREP(SP7021_CLK_MASK, clk_sel);\n\twritel(pspim->xfer_conf, pspim->m_base + SP7021_SPI_CONFIG_REG);\n}\n\nstatic int sp7021_spi_master_transfer_one(struct spi_controller *ctlr, struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\tunsigned long timeout = msecs_to_jiffies(1000);\n\tunsigned int xfer_cnt, xfer_len, last_len;\n\tunsigned int i, len_temp;\n\tu32 reg_temp;\n\n\txfer_cnt = xfer->len / SP7021_SPI_DATA_SIZE;\n\tlast_len = xfer->len % SP7021_SPI_DATA_SIZE;\n\n\tfor (i = 0; i <= xfer_cnt; i++) {\n\t\tmutex_lock(&pspim->buf_lock);\n\t\tsp7021_prep_transfer(ctlr, spi);\n\t\tsp7021_spi_setup_clk(ctlr, xfer);\n\t\treinit_completion(&pspim->isr_done);\n\n\t\tif (i == xfer_cnt)\n\t\t\txfer_len = last_len;\n\t\telse\n\t\t\txfer_len = SP7021_SPI_DATA_SIZE;\n\n\t\tpspim->tx_buf = xfer->tx_buf + i * SP7021_SPI_DATA_SIZE;\n\t\tpspim->rx_buf = xfer->rx_buf + i * SP7021_SPI_DATA_SIZE;\n\n\t\tif (pspim->tx_cur_len < xfer_len) {\n\t\t\tlen_temp = min(pspim->data_unit, xfer_len);\n\t\t\tsp7021_spi_master_wb(pspim, len_temp);\n\t\t}\n\t\treg_temp = readl(pspim->m_base + SP7021_SPI_CONFIG_REG);\n\t\treg_temp &= ~SP7021_CLEAN_RW_BYTE;\n\t\treg_temp &= ~SP7021_CLEAN_FLUG_MASK;\n\t\treg_temp |= SP7021_FD_SEL | SP7021_FINISH_FLAG_MASK |\n\t\t\t    SP7021_TX_EMP_FLAG_MASK | SP7021_RX_FULL_FLAG_MASK |\n\t\t\t    FIELD_PREP(SP7021_TX_UNIT, 0) | FIELD_PREP(SP7021_RX_UNIT, 0);\n\t\twritel(reg_temp, pspim->m_base + SP7021_SPI_CONFIG_REG);\n\n\t\treg_temp = FIELD_PREP(SP7021_SET_TX_LEN, xfer_len) |\n\t\t\t\t      FIELD_PREP(SP7021_SET_XFER_LEN, xfer_len) |\n\t\t\t\t      SP7021_SPI_START_FD;\n\t\twritel(reg_temp, pspim->m_base + SP7021_SPI_STATUS_REG);\n\n\t\tif (!wait_for_completion_interruptible_timeout(&pspim->isr_done, timeout)) {\n\t\t\tdev_err(&spi->dev, \"wait_for_completion err\\n\");\n\t\t\tmutex_unlock(&pspim->buf_lock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\treg_temp = readl(pspim->m_base + SP7021_SPI_STATUS_REG);\n\t\tif (reg_temp & SP7021_FINISH_FLAG) {\n\t\t\twritel(SP7021_FINISH_FLAG, pspim->m_base + SP7021_SPI_STATUS_REG);\n\t\t\twritel(readl(pspim->m_base + SP7021_SPI_CONFIG_REG) &\n\t\t\t\tSP7021_CLEAN_FLUG_MASK, pspim->m_base + SP7021_SPI_CONFIG_REG);\n\t\t}\n\n\t\tif (pspim->xfer_conf & SP7021_CPOL_FD)\n\t\t\twritel(pspim->xfer_conf, pspim->m_base + SP7021_SPI_CONFIG_REG);\n\n\t\tmutex_unlock(&pspim->buf_lock);\n\t}\n\treturn 0;\n}\n\nstatic int sp7021_spi_slave_transfer_one(struct spi_controller *ctlr, struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\tstruct device *dev = pspim->dev;\n\tint ret;\n\n\tif (xfer->tx_buf && !xfer->rx_buf) {\n\t\txfer->tx_dma = dma_map_single(dev, (void *)xfer->tx_buf,\n\t\t\t\t\t      xfer->len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->tx_dma))\n\t\t\treturn -ENOMEM;\n\t\tret = sp7021_spi_slave_tx(spi, xfer);\n\t\tdma_unmap_single(dev, xfer->tx_dma, xfer->len, DMA_TO_DEVICE);\n\t} else if (xfer->rx_buf && !xfer->tx_buf) {\n\t\txfer->rx_dma = dma_map_single(dev, xfer->rx_buf, xfer->len,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->rx_dma))\n\t\t\treturn -ENOMEM;\n\t\tret = sp7021_spi_slave_rx(spi, xfer);\n\t\tdma_unmap_single(dev, xfer->rx_dma, xfer->len, DMA_FROM_DEVICE);\n\t} else {\n\t\tdev_dbg(&ctlr->dev, \"%s() wrong command\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspi_finalize_current_transfer(ctlr);\n\treturn ret;\n}\n\nstatic void sp7021_spi_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void sp7021_spi_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int sp7021_spi_controller_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp7021_spi_ctlr *pspim;\n\tstruct spi_controller *ctlr;\n\tint mode, ret;\n\n\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"sp_spi\");\n\n\tif (device_property_read_bool(dev, \"spi-slave\"))\n\t\tmode = SP7021_SLAVE_MODE;\n\telse\n\t\tmode = SP7021_MASTER_MODE;\n\n\tif (mode == SP7021_SLAVE_MODE)\n\t\tctlr = devm_spi_alloc_slave(dev, sizeof(*pspim));\n\telse\n\t\tctlr = devm_spi_alloc_master(dev, sizeof(*pspim));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\tdevice_set_node(&ctlr->dev, dev_fwnode(dev));\n\tctlr->bus_num = pdev->id;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\tctlr->auto_runtime_pm = true;\n\tctlr->prepare_message = sp7021_spi_controller_prepare_message;\n\tif (mode == SP7021_SLAVE_MODE) {\n\t\tctlr->transfer_one = sp7021_spi_slave_transfer_one;\n\t\tctlr->slave_abort = sp7021_spi_slave_abort;\n\t\tctlr->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\t} else {\n\t\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\t\tctlr->min_speed_hz = 40000;\n\t\tctlr->max_speed_hz = 25000000;\n\t\tctlr->use_gpio_descriptors = true;\n\t\tctlr->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\t\tctlr->transfer_one = sp7021_spi_master_transfer_one;\n\t}\n\tplatform_set_drvdata(pdev, ctlr);\n\tpspim = spi_controller_get_devdata(ctlr);\n\tpspim->mode = mode;\n\tpspim->ctlr = ctlr;\n\tpspim->dev = dev;\n\tmutex_init(&pspim->buf_lock);\n\tinit_completion(&pspim->isr_done);\n\tinit_completion(&pspim->slave_isr);\n\n\tpspim->m_base = devm_platform_ioremap_resource_byname(pdev, \"master\");\n\tif (IS_ERR(pspim->m_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(pspim->m_base), \"m_base get fail\\n\");\n\n\tpspim->s_base = devm_platform_ioremap_resource_byname(pdev, \"slave\");\n\tif (IS_ERR(pspim->s_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(pspim->s_base), \"s_base get fail\\n\");\n\n\tpspim->m_irq = platform_get_irq_byname(pdev, \"master_risc\");\n\tif (pspim->m_irq < 0)\n\t\treturn pspim->m_irq;\n\n\tpspim->s_irq = platform_get_irq_byname(pdev, \"slave_risc\");\n\tif (pspim->s_irq < 0)\n\t\treturn pspim->s_irq;\n\n\tpspim->spi_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pspim->spi_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pspim->spi_clk), \"clk get fail\\n\");\n\n\tpspim->rstc = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(pspim->rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(pspim->rstc), \"rst get fail\\n\");\n\n\tret = clk_prepare_enable(pspim->spi_clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable clk\\n\");\n\n\tret = devm_add_action_or_reset(dev, sp7021_spi_disable_unprepare, pspim->spi_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(pspim->rstc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to deassert reset\\n\");\n\n\tret = devm_add_action_or_reset(dev, sp7021_spi_reset_control_assert, pspim->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, pspim->m_irq, sp7021_spi_master_irq,\n\t\t\t       IRQF_TRIGGER_RISING, pdev->name, pspim);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, pspim->s_irq, sp7021_spi_slave_irq,\n\t\t\t       IRQF_TRIGGER_RISING, pdev->name, pspim);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tret = spi_register_controller(ctlr);\n\tif (ret) {\n\t\tpm_runtime_disable(dev);\n\t\treturn dev_err_probe(dev, ret, \"spi_register_master fail\\n\");\n\t}\n\treturn 0;\n}\n\nstatic void sp7021_spi_controller_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(&pdev->dev);\n\n\tspi_unregister_controller(ctlr);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n}\n\nstatic int __maybe_unused sp7021_spi_controller_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\treturn reset_control_assert(pspim->rstc);\n}\n\nstatic int __maybe_unused sp7021_spi_controller_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\treset_control_deassert(pspim->rstc);\n\treturn clk_prepare_enable(pspim->spi_clk);\n}\n\n#ifdef CONFIG_PM\nstatic int sp7021_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\treturn reset_control_assert(pspim->rstc);\n}\n\nstatic int sp7021_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct sp7021_spi_ctlr *pspim = spi_master_get_devdata(ctlr);\n\n\treturn reset_control_deassert(pspim->rstc);\n}\n#endif\n\nstatic const struct dev_pm_ops sp7021_spi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sp7021_spi_runtime_suspend,\n\t\t\t   sp7021_spi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(sp7021_spi_controller_suspend,\n\t\t\t\tsp7021_spi_controller_resume)\n};\n\nstatic const struct of_device_id sp7021_spi_controller_ids[] = {\n\t{ .compatible = \"sunplus,sp7021-spi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sp7021_spi_controller_ids);\n\nstatic struct platform_driver sp7021_spi_controller_driver = {\n\t.probe = sp7021_spi_controller_probe,\n\t.remove_new = sp7021_spi_controller_remove,\n\t.driver = {\n\t\t.name = \"sunplus,sp7021-spi-controller\",\n\t\t.of_match_table = sp7021_spi_controller_ids,\n\t\t.pm     = &sp7021_spi_pm_ops,\n\t},\n};\nmodule_platform_driver(sp7021_spi_controller_driver);\n\nMODULE_AUTHOR(\"Li-hao Kuo <lhjeff911@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus SPI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}