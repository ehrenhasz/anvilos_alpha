{
  "module_name": "spi-synquacer.c",
  "hash_id": "df94f3c78d5cbb08943b1c34c27ed9c7f6f4cbabedce12984a0260fafd8369bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-synquacer.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n#include <linux/clk.h>\n\n \n#define SYNQUACER_HSSPI_REG_MCTRL\t0x00\n#define SYNQUACER_HSSPI_REG_PCC0\t0x04\n#define SYNQUACER_HSSPI_REG_PCC(n)\t(SYNQUACER_HSSPI_REG_PCC0 + (n) * 4)\n#define SYNQUACER_HSSPI_REG_TXF\t\t0x14\n#define SYNQUACER_HSSPI_REG_TXE\t\t0x18\n#define SYNQUACER_HSSPI_REG_TXC\t\t0x1C\n#define SYNQUACER_HSSPI_REG_RXF\t\t0x20\n#define SYNQUACER_HSSPI_REG_RXE\t\t0x24\n#define SYNQUACER_HSSPI_REG_RXC\t\t0x28\n#define SYNQUACER_HSSPI_REG_FAULTF\t0x2C\n#define SYNQUACER_HSSPI_REG_FAULTC\t0x30\n#define SYNQUACER_HSSPI_REG_DMCFG\t0x34\n#define SYNQUACER_HSSPI_REG_DMSTART\t0x38\n#define SYNQUACER_HSSPI_REG_DMBCC\t0x3C\n#define SYNQUACER_HSSPI_REG_DMSTATUS\t0x40\n#define SYNQUACER_HSSPI_REG_FIFOCFG\t0x4C\n#define SYNQUACER_HSSPI_REG_TX_FIFO\t0x50\n#define SYNQUACER_HSSPI_REG_RX_FIFO\t0x90\n#define SYNQUACER_HSSPI_REG_MID\t\t0xFC\n\n \n#define SYNQUACER_HSSPI_MCTRL_MEN\t\t\tBIT(0)\n#define SYNQUACER_HSSPI_MCTRL_COMMAND_SEQUENCE_EN\tBIT(1)\n#define SYNQUACER_HSSPI_MCTRL_CDSS\t\t\tBIT(3)\n#define SYNQUACER_HSSPI_MCTRL_MES\t\t\tBIT(4)\n#define SYNQUACER_HSSPI_MCTRL_SYNCON\t\t\tBIT(5)\n\n#define SYNQUACER_HSSPI_PCC_CPHA\t\tBIT(0)\n#define SYNQUACER_HSSPI_PCC_CPOL\t\tBIT(1)\n#define SYNQUACER_HSSPI_PCC_ACES\t\tBIT(2)\n#define SYNQUACER_HSSPI_PCC_RTM\t\t\tBIT(3)\n#define SYNQUACER_HSSPI_PCC_SSPOL\t\tBIT(4)\n#define SYNQUACER_HSSPI_PCC_SDIR\t\tBIT(7)\n#define SYNQUACER_HSSPI_PCC_SENDIAN\t\tBIT(8)\n#define SYNQUACER_HSSPI_PCC_SAFESYNC\t\tBIT(16)\n#define SYNQUACER_HSSPI_PCC_SS2CD_SHIFT\t\t5U\n#define SYNQUACER_HSSPI_PCC_CDRS_MASK\t\t0x7f\n#define SYNQUACER_HSSPI_PCC_CDRS_SHIFT\t\t9U\n\n#define SYNQUACER_HSSPI_TXF_FIFO_FULL\t\tBIT(0)\n#define SYNQUACER_HSSPI_TXF_FIFO_EMPTY\t\tBIT(1)\n#define SYNQUACER_HSSPI_TXF_SLAVE_RELEASED\tBIT(6)\n\n#define SYNQUACER_HSSPI_TXE_FIFO_FULL\t\tBIT(0)\n#define SYNQUACER_HSSPI_TXE_FIFO_EMPTY\t\tBIT(1)\n#define SYNQUACER_HSSPI_TXE_SLAVE_RELEASED\tBIT(6)\n\n#define SYNQUACER_HSSPI_RXF_FIFO_MORE_THAN_THRESHOLD\t\tBIT(5)\n#define SYNQUACER_HSSPI_RXF_SLAVE_RELEASED\t\t\tBIT(6)\n\n#define SYNQUACER_HSSPI_RXE_FIFO_MORE_THAN_THRESHOLD\t\tBIT(5)\n#define SYNQUACER_HSSPI_RXE_SLAVE_RELEASED\t\t\tBIT(6)\n\n#define SYNQUACER_HSSPI_DMCFG_SSDC\t\tBIT(1)\n#define SYNQUACER_HSSPI_DMCFG_MSTARTEN\t\tBIT(2)\n\n#define SYNQUACER_HSSPI_DMSTART_START\t\tBIT(0)\n#define SYNQUACER_HSSPI_DMSTOP_STOP\t\tBIT(8)\n#define SYNQUACER_HSSPI_DMPSEL_CS_MASK\t\t0x3\n#define SYNQUACER_HSSPI_DMPSEL_CS_SHIFT\t\t16U\n#define SYNQUACER_HSSPI_DMTRP_BUS_WIDTH_SHIFT\t24U\n#define SYNQUACER_HSSPI_DMTRP_DATA_MASK\t\t0x3\n#define SYNQUACER_HSSPI_DMTRP_DATA_SHIFT\t26U\n#define SYNQUACER_HSSPI_DMTRP_DATA_TXRX\t\t0\n#define SYNQUACER_HSSPI_DMTRP_DATA_RX\t\t1\n#define SYNQUACER_HSSPI_DMTRP_DATA_TX\t\t2\n\n#define SYNQUACER_HSSPI_DMSTATUS_RX_DATA_MASK\t0x1f\n#define SYNQUACER_HSSPI_DMSTATUS_RX_DATA_SHIFT\t8U\n#define SYNQUACER_HSSPI_DMSTATUS_TX_DATA_MASK\t0x1f\n#define SYNQUACER_HSSPI_DMSTATUS_TX_DATA_SHIFT\t16U\n\n#define SYNQUACER_HSSPI_FIFOCFG_RX_THRESHOLD_MASK\t0xf\n#define SYNQUACER_HSSPI_FIFOCFG_RX_THRESHOLD_SHIFT\t0U\n#define SYNQUACER_HSSPI_FIFOCFG_TX_THRESHOLD_MASK\t0xf\n#define SYNQUACER_HSSPI_FIFOCFG_TX_THRESHOLD_SHIFT\t4U\n#define SYNQUACER_HSSPI_FIFOCFG_FIFO_WIDTH_MASK\t\t0x3\n#define SYNQUACER_HSSPI_FIFOCFG_FIFO_WIDTH_SHIFT\t8U\n#define SYNQUACER_HSSPI_FIFOCFG_RX_FLUSH\t\tBIT(11)\n#define SYNQUACER_HSSPI_FIFOCFG_TX_FLUSH\t\tBIT(12)\n\n#define SYNQUACER_HSSPI_FIFO_DEPTH\t\t16U\n#define SYNQUACER_HSSPI_FIFO_TX_THRESHOLD\t4U\n#define SYNQUACER_HSSPI_FIFO_RX_THRESHOLD \\\n\t(SYNQUACER_HSSPI_FIFO_DEPTH - SYNQUACER_HSSPI_FIFO_TX_THRESHOLD)\n\n#define SYNQUACER_HSSPI_TRANSFER_MODE_TX\tBIT(1)\n#define SYNQUACER_HSSPI_TRANSFER_MODE_RX\tBIT(2)\n#define SYNQUACER_HSSPI_TRANSFER_TMOUT_MSEC\t2000U\n#define SYNQUACER_HSSPI_ENABLE_TMOUT_MSEC\t1000U\n\n#define SYNQUACER_HSSPI_CLOCK_SRC_IHCLK\t\t0\n#define SYNQUACER_HSSPI_CLOCK_SRC_IPCLK\t\t1\n\n#define SYNQUACER_HSSPI_NUM_CHIP_SELECT\t\t4U\n#define SYNQUACER_HSSPI_IRQ_NAME_MAX\t\t32U\n\nstruct synquacer_spi {\n\tstruct device *dev;\n\tstruct completion transfer_done;\n\tunsigned int cs;\n\tunsigned int bpw;\n\tunsigned int mode;\n\tunsigned int speed;\n\tbool aces, rtm;\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tstruct clk *clk;\n\tint clk_src_type;\n\tvoid __iomem *regs;\n\tu32 tx_words, rx_words;\n\tunsigned int bus_width;\n\tunsigned int transfer_mode;\n\tchar rx_irq_name[SYNQUACER_HSSPI_IRQ_NAME_MAX];\n\tchar tx_irq_name[SYNQUACER_HSSPI_IRQ_NAME_MAX];\n};\n\nstatic int read_fifo(struct synquacer_spi *sspi)\n{\n\tu32 len = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTATUS);\n\n\tlen = (len >> SYNQUACER_HSSPI_DMSTATUS_RX_DATA_SHIFT) &\n\t       SYNQUACER_HSSPI_DMSTATUS_RX_DATA_MASK;\n\tlen = min(len, sspi->rx_words);\n\n\tswitch (sspi->bpw) {\n\tcase 8: {\n\t\tu8 *buf = sspi->rx_buf;\n\n\t\tioread8_rep(sspi->regs + SYNQUACER_HSSPI_REG_RX_FIFO,\n\t\t\t    buf, len);\n\t\tsspi->rx_buf = buf + len;\n\t\tbreak;\n\t}\n\tcase 16: {\n\t\tu16 *buf = sspi->rx_buf;\n\n\t\tioread16_rep(sspi->regs + SYNQUACER_HSSPI_REG_RX_FIFO,\n\t\t\t     buf, len);\n\t\tsspi->rx_buf = buf + len;\n\t\tbreak;\n\t}\n\tcase 24:\n\t\t \n\tcase 32: {\n\t\tu32 *buf = sspi->rx_buf;\n\n\t\tioread32_rep(sspi->regs + SYNQUACER_HSSPI_REG_RX_FIFO,\n\t\t\t     buf, len);\n\t\tsspi->rx_buf = buf + len;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsspi->rx_words -= len;\n\treturn 0;\n}\n\nstatic int write_fifo(struct synquacer_spi *sspi)\n{\n\tu32 len = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTATUS);\n\n\tlen = (len >> SYNQUACER_HSSPI_DMSTATUS_TX_DATA_SHIFT) &\n\t       SYNQUACER_HSSPI_DMSTATUS_TX_DATA_MASK;\n\tlen = min(SYNQUACER_HSSPI_FIFO_DEPTH - len,\n\t\t    sspi->tx_words);\n\n\tswitch (sspi->bpw) {\n\tcase 8: {\n\t\tconst u8 *buf = sspi->tx_buf;\n\n\t\tiowrite8_rep(sspi->regs + SYNQUACER_HSSPI_REG_TX_FIFO,\n\t\t\t     buf, len);\n\t\tsspi->tx_buf = buf + len;\n\t\tbreak;\n\t}\n\tcase 16: {\n\t\tconst u16 *buf = sspi->tx_buf;\n\n\t\tiowrite16_rep(sspi->regs + SYNQUACER_HSSPI_REG_TX_FIFO,\n\t\t\t      buf, len);\n\t\tsspi->tx_buf = buf + len;\n\t\tbreak;\n\t}\n\tcase 24:\n\t\t \n\tcase 32: {\n\t\tconst u32 *buf = sspi->tx_buf;\n\n\t\tiowrite32_rep(sspi->regs + SYNQUACER_HSSPI_REG_TX_FIFO,\n\t\t\t      buf, len);\n\t\tsspi->tx_buf = buf + len;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsspi->tx_words -= len;\n\treturn 0;\n}\n\nstatic int synquacer_spi_config(struct spi_master *master,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\tunsigned int speed, mode, bpw, cs, bus_width, transfer_mode;\n\tu32 rate, val, div;\n\n\t \n\tif (xfer->rx_buf && xfer->tx_buf &&\n\t    (xfer->rx_nbits != 1 || xfer->tx_nbits != 1)) {\n\t\tdev_err(sspi->dev,\n\t\t\t\"RX and TX bus widths must be 1-bit for Full-Duplex!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xfer->tx_buf) {\n\t\tbus_width = xfer->tx_nbits;\n\t\ttransfer_mode = SYNQUACER_HSSPI_TRANSFER_MODE_TX;\n\t} else {\n\t\tbus_width = xfer->rx_nbits;\n\t\ttransfer_mode = SYNQUACER_HSSPI_TRANSFER_MODE_RX;\n\t}\n\n\tmode = spi->mode;\n\tcs = spi_get_chipselect(spi, 0);\n\tspeed = xfer->speed_hz;\n\tbpw = xfer->bits_per_word;\n\n\t \n\tif (speed == sspi->speed &&\n\t\tbus_width == sspi->bus_width && bpw == sspi->bpw &&\n\t\tmode == sspi->mode && cs == sspi->cs &&\n\t\ttransfer_mode == sspi->transfer_mode) {\n\t\treturn 0;\n\t}\n\n\tsspi->transfer_mode = transfer_mode;\n\trate = master->max_speed_hz;\n\n\tdiv = DIV_ROUND_UP(rate, speed);\n\tif (div > 254) {\n\t\tdev_err(sspi->dev, \"Requested rate too low (%u)\\n\",\n\t\t\tsspi->speed);\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_PCC(cs));\n\tval &= ~SYNQUACER_HSSPI_PCC_SAFESYNC;\n\tif (bpw == 8 &&\t(mode & (SPI_TX_DUAL | SPI_RX_DUAL)) && div < 3)\n\t\tval |= SYNQUACER_HSSPI_PCC_SAFESYNC;\n\tif (bpw == 8 &&\t(mode & (SPI_TX_QUAD | SPI_RX_QUAD)) && div < 6)\n\t\tval |= SYNQUACER_HSSPI_PCC_SAFESYNC;\n\tif (bpw == 16 && (mode & (SPI_TX_QUAD | SPI_RX_QUAD)) && div < 3)\n\t\tval |= SYNQUACER_HSSPI_PCC_SAFESYNC;\n\n\tif (mode & SPI_CPHA)\n\t\tval |= SYNQUACER_HSSPI_PCC_CPHA;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_CPHA;\n\n\tif (mode & SPI_CPOL)\n\t\tval |= SYNQUACER_HSSPI_PCC_CPOL;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_CPOL;\n\n\tif (mode & SPI_CS_HIGH)\n\t\tval |= SYNQUACER_HSSPI_PCC_SSPOL;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_SSPOL;\n\n\tif (mode & SPI_LSB_FIRST)\n\t\tval |= SYNQUACER_HSSPI_PCC_SDIR;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_SDIR;\n\n\tif (sspi->aces)\n\t\tval |= SYNQUACER_HSSPI_PCC_ACES;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_ACES;\n\n\tif (sspi->rtm)\n\t\tval |= SYNQUACER_HSSPI_PCC_RTM;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_PCC_RTM;\n\n\tval |= (3 << SYNQUACER_HSSPI_PCC_SS2CD_SHIFT);\n\tval |= SYNQUACER_HSSPI_PCC_SENDIAN;\n\n\tval &= ~(SYNQUACER_HSSPI_PCC_CDRS_MASK <<\n\t\t SYNQUACER_HSSPI_PCC_CDRS_SHIFT);\n\tval |= ((div >> 1) << SYNQUACER_HSSPI_PCC_CDRS_SHIFT);\n\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_PCC(cs));\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\tval &= ~(SYNQUACER_HSSPI_FIFOCFG_FIFO_WIDTH_MASK <<\n\t\t SYNQUACER_HSSPI_FIFOCFG_FIFO_WIDTH_SHIFT);\n\tval |= ((bpw / 8 - 1) << SYNQUACER_HSSPI_FIFOCFG_FIFO_WIDTH_SHIFT);\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\tval &= ~(SYNQUACER_HSSPI_DMTRP_DATA_MASK <<\n\t\t SYNQUACER_HSSPI_DMTRP_DATA_SHIFT);\n\n\tif (xfer->rx_buf)\n\t\tval |= (SYNQUACER_HSSPI_DMTRP_DATA_RX <<\n\t\t\tSYNQUACER_HSSPI_DMTRP_DATA_SHIFT);\n\telse\n\t\tval |= (SYNQUACER_HSSPI_DMTRP_DATA_TX <<\n\t\t\tSYNQUACER_HSSPI_DMTRP_DATA_SHIFT);\n\n\tval &= ~(3 << SYNQUACER_HSSPI_DMTRP_BUS_WIDTH_SHIFT);\n\tval |= ((bus_width >> 1) << SYNQUACER_HSSPI_DMTRP_BUS_WIDTH_SHIFT);\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\n\tsspi->bpw = bpw;\n\tsspi->mode = mode;\n\tsspi->speed = speed;\n\tsspi->cs = spi_get_chipselect(spi, 0);\n\tsspi->bus_width = bus_width;\n\n\treturn 0;\n}\n\nstatic int synquacer_spi_transfer_one(struct spi_master *master,\n\t\t\t\t      struct spi_device *spi,\n\t\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\tint ret;\n\tint status = 0;\n\tu32 words;\n\tu8 bpw;\n\tu32 val;\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\tval &= ~SYNQUACER_HSSPI_DMSTOP_STOP;\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\tval |= SYNQUACER_HSSPI_FIFOCFG_RX_FLUSH;\n\tval |= SYNQUACER_HSSPI_FIFOCFG_TX_FLUSH;\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\n\t \n\tbpw = xfer->bits_per_word;\n\tif (bpw == 8 && !(xfer->len % 4) && !(spi->mode & SPI_LSB_FIRST))\n\t\txfer->bits_per_word = 32;\n\n\tret = synquacer_spi_config(master, spi, xfer);\n\n\t \n\txfer->bits_per_word = bpw;\n\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&sspi->transfer_done);\n\n\tsspi->tx_buf = xfer->tx_buf;\n\tsspi->rx_buf = xfer->rx_buf;\n\n\tswitch (sspi->bpw) {\n\tcase 8:\n\t\twords = xfer->len;\n\t\tbreak;\n\tcase 16:\n\t\twords = xfer->len / 2;\n\t\tbreak;\n\tcase 24:\n\t\t \n\tcase 32:\n\t\twords = xfer->len / 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sspi->dev, \"unsupported bpw: %d\\n\", sspi->bpw);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xfer->tx_buf)\n\t\tsspi->tx_words = words;\n\telse\n\t\tsspi->tx_words = 0;\n\n\tif (xfer->rx_buf)\n\t\tsspi->rx_words = words;\n\telse\n\t\tsspi->rx_words = 0;\n\n\tif (xfer->tx_buf) {\n\t\tstatus = write_fifo(sspi);\n\t\tif (status < 0) {\n\t\t\tdev_err(sspi->dev, \"failed write_fifo. status: 0x%x\\n\",\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (xfer->rx_buf) {\n\t\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\t\tval &= ~(SYNQUACER_HSSPI_FIFOCFG_RX_THRESHOLD_MASK <<\n\t\t\t SYNQUACER_HSSPI_FIFOCFG_RX_THRESHOLD_SHIFT);\n\t\tval |= ((sspi->rx_words > SYNQUACER_HSSPI_FIFO_DEPTH ?\n\t\t\tSYNQUACER_HSSPI_FIFO_RX_THRESHOLD : sspi->rx_words) <<\n\t\t\tSYNQUACER_HSSPI_FIFOCFG_RX_THRESHOLD_SHIFT);\n\t\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_FIFOCFG);\n\t}\n\n\twritel(~0, sspi->regs + SYNQUACER_HSSPI_REG_TXC);\n\twritel(~0, sspi->regs + SYNQUACER_HSSPI_REG_RXC);\n\n\t \n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\tval |= SYNQUACER_HSSPI_DMSTART_START;\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\n\tif (xfer->tx_buf) {\n\t\tval = SYNQUACER_HSSPI_TXE_FIFO_EMPTY;\n\t\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_TXE);\n\t\tstatus = wait_for_completion_timeout(&sspi->transfer_done,\n\t\t\tmsecs_to_jiffies(SYNQUACER_HSSPI_TRANSFER_TMOUT_MSEC));\n\t\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_TXE);\n\t}\n\n\tif (xfer->rx_buf) {\n\t\tu32 buf[SYNQUACER_HSSPI_FIFO_DEPTH];\n\n\t\tval = SYNQUACER_HSSPI_RXE_FIFO_MORE_THAN_THRESHOLD |\n\t\t      SYNQUACER_HSSPI_RXE_SLAVE_RELEASED;\n\t\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_RXE);\n\t\tstatus = wait_for_completion_timeout(&sspi->transfer_done,\n\t\t\tmsecs_to_jiffies(SYNQUACER_HSSPI_TRANSFER_TMOUT_MSEC));\n\t\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_RXE);\n\n\t\t \n\t\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\t\tval |= SYNQUACER_HSSPI_DMSTOP_STOP;\n\t\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\t\tsspi->rx_buf = buf;\n\t\tsspi->rx_words = SYNQUACER_HSSPI_FIFO_DEPTH;\n\t\tread_fifo(sspi);\n\t}\n\n\tif (status == 0) {\n\t\tdev_err(sspi->dev, \"failed to transfer. Timeout.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void synquacer_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(spi->master);\n\tu32 val;\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n\tval &= ~(SYNQUACER_HSSPI_DMPSEL_CS_MASK <<\n\t\t SYNQUACER_HSSPI_DMPSEL_CS_SHIFT);\n\tval |= spi_get_chipselect(spi, 0) << SYNQUACER_HSSPI_DMPSEL_CS_SHIFT;\n\n\tif (!enable)\n\t\tval |= SYNQUACER_HSSPI_DMSTOP_STOP;\n\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMSTART);\n}\n\nstatic int synquacer_spi_wait_status_update(struct synquacer_spi *sspi,\n\t\t\t\t\t    bool enable)\n{\n\tu32 val;\n\tunsigned long timeout = jiffies +\n\t\tmsecs_to_jiffies(SYNQUACER_HSSPI_ENABLE_TMOUT_MSEC);\n\n\t \n\tdo {\n\t\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_MCTRL) &\n\t\t      SYNQUACER_HSSPI_MCTRL_MES;\n\t\tif (enable && val)\n\t\t\treturn 0;\n\t\tif (!enable && !val)\n\t\t\treturn 0;\n\t} while (time_before(jiffies, timeout));\n\n\tdev_err(sspi->dev, \"timeout occurs in updating Module Enable Status\\n\");\n\treturn -EBUSY;\n}\n\nstatic int synquacer_spi_enable(struct spi_master *master)\n{\n\tu32 val;\n\tint status;\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\n\t \n\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_MCTRL);\n\tstatus = synquacer_spi_wait_status_update(sspi, false);\n\tif (status < 0)\n\t\treturn status;\n\n\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_TXE);\n\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_RXE);\n\twritel(~0, sspi->regs + SYNQUACER_HSSPI_REG_TXC);\n\twritel(~0, sspi->regs + SYNQUACER_HSSPI_REG_RXC);\n\twritel(~0, sspi->regs + SYNQUACER_HSSPI_REG_FAULTC);\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_DMCFG);\n\tval &= ~SYNQUACER_HSSPI_DMCFG_SSDC;\n\tval &= ~SYNQUACER_HSSPI_DMCFG_MSTARTEN;\n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_DMCFG);\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_MCTRL);\n\tif (sspi->clk_src_type == SYNQUACER_HSSPI_CLOCK_SRC_IPCLK)\n\t\tval |= SYNQUACER_HSSPI_MCTRL_CDSS;\n\telse\n\t\tval &= ~SYNQUACER_HSSPI_MCTRL_CDSS;\n\n\tval &= ~SYNQUACER_HSSPI_MCTRL_COMMAND_SEQUENCE_EN;\n\tval |= SYNQUACER_HSSPI_MCTRL_MEN;\n\tval |= SYNQUACER_HSSPI_MCTRL_SYNCON;\n\n\t \n\twritel(val, sspi->regs + SYNQUACER_HSSPI_REG_MCTRL);\n\tstatus = synquacer_spi_wait_status_update(sspi, true);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic irqreturn_t sq_spi_rx_handler(int irq, void *priv)\n{\n\tuint32_t val;\n\tstruct synquacer_spi *sspi = priv;\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_RXF);\n\tif ((val & SYNQUACER_HSSPI_RXF_SLAVE_RELEASED) ||\n\t    (val & SYNQUACER_HSSPI_RXF_FIFO_MORE_THAN_THRESHOLD)) {\n\t\tread_fifo(sspi);\n\n\t\tif (sspi->rx_words == 0) {\n\t\t\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_RXE);\n\t\t\tcomplete(&sspi->transfer_done);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t sq_spi_tx_handler(int irq, void *priv)\n{\n\tuint32_t val;\n\tstruct synquacer_spi *sspi = priv;\n\n\tval = readl(sspi->regs + SYNQUACER_HSSPI_REG_TXF);\n\tif (val & SYNQUACER_HSSPI_TXF_FIFO_EMPTY) {\n\t\tif (sspi->tx_words == 0) {\n\t\t\twritel(0, sspi->regs + SYNQUACER_HSSPI_REG_TXE);\n\t\t\tcomplete(&sspi->transfer_done);\n\t\t} else {\n\t\t\twrite_fifo(sspi);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int synquacer_spi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spi_master *master;\n\tstruct synquacer_spi *sspi;\n\tint ret;\n\tint rx_irq, tx_irq;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*sspi));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tsspi = spi_master_get_devdata(master);\n\tsspi->dev = &pdev->dev;\n\n\tinit_completion(&sspi->transfer_done);\n\n\tsspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sspi->regs)) {\n\t\tret = PTR_ERR(sspi->regs);\n\t\tgoto put_spi;\n\t}\n\n\tsspi->clk_src_type = SYNQUACER_HSSPI_CLOCK_SRC_IHCLK;  \n\tdevice_property_read_u32(&pdev->dev, \"socionext,ihclk-rate\",\n\t\t\t\t &master->max_speed_hz);  \n\n\tif (dev_of_node(&pdev->dev)) {\n\t\tif (device_property_match_string(&pdev->dev,\n\t\t\t\t\t \"clock-names\", \"iHCLK\") >= 0) {\n\t\t\tsspi->clk_src_type = SYNQUACER_HSSPI_CLOCK_SRC_IHCLK;\n\t\t\tsspi->clk = devm_clk_get(sspi->dev, \"iHCLK\");\n\t\t} else if (device_property_match_string(&pdev->dev,\n\t\t\t\t\t\t\"clock-names\", \"iPCLK\") >= 0) {\n\t\t\tsspi->clk_src_type = SYNQUACER_HSSPI_CLOCK_SRC_IPCLK;\n\t\t\tsspi->clk = devm_clk_get(sspi->dev, \"iPCLK\");\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"specified wrong clock source\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_spi;\n\t\t}\n\n\t\tif (IS_ERR(sspi->clk)) {\n\t\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(sspi->clk),\n\t\t\t\t\t    \"clock not found\\n\");\n\t\t\tgoto put_spi;\n\t\t}\n\n\t\tret = clk_prepare_enable(sspi->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to enable clock (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto put_spi;\n\t\t}\n\n\t\tmaster->max_speed_hz = clk_get_rate(sspi->clk);\n\t}\n\n\tif (!master->max_speed_hz) {\n\t\tdev_err(&pdev->dev, \"missing clock source\\n\");\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\tmaster->min_speed_hz = master->max_speed_hz / 254;\n\n\tsspi->aces = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t       \"socionext,set-aces\");\n\tsspi->rtm = device_property_read_bool(&pdev->dev, \"socionext,use-rtm\");\n\n\tmaster->num_chipselect = SYNQUACER_HSSPI_NUM_CHIP_SELECT;\n\n\trx_irq = platform_get_irq(pdev, 0);\n\tif (rx_irq <= 0) {\n\t\tret = rx_irq;\n\t\tgoto disable_clk;\n\t}\n\tsnprintf(sspi->rx_irq_name, SYNQUACER_HSSPI_IRQ_NAME_MAX, \"%s-rx\",\n\t\t dev_name(&pdev->dev));\n\tret = devm_request_irq(&pdev->dev, rx_irq, sq_spi_rx_handler,\n\t\t\t\t0, sspi->rx_irq_name, sspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request rx_irq failed (%d)\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\ttx_irq = platform_get_irq(pdev, 1);\n\tif (tx_irq <= 0) {\n\t\tret = tx_irq;\n\t\tgoto disable_clk;\n\t}\n\tsnprintf(sspi->tx_irq_name, SYNQUACER_HSSPI_IRQ_NAME_MAX, \"%s-tx\",\n\t\t dev_name(&pdev->dev));\n\tret = devm_request_irq(&pdev->dev, tx_irq, sq_spi_tx_handler,\n\t\t\t\t0, sspi->tx_irq_name, sspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request tx_irq failed (%d)\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\tmaster->dev.of_node = np;\n\tmaster->dev.fwnode = pdev->dev.fwnode;\n\tmaster->auto_runtime_pm = true;\n\tmaster->bus_num = pdev->id;\n\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_TX_DUAL | SPI_RX_DUAL |\n\t\t\t    SPI_TX_QUAD | SPI_RX_QUAD;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(24) |\n\t\t\t\t     SPI_BPW_MASK(16) | SPI_BPW_MASK(8);\n\n\tmaster->set_cs = synquacer_spi_set_cs;\n\tmaster->transfer_one = synquacer_spi_transfer_one;\n\n\tret = synquacer_spi_enable(master);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tpm_runtime_set_active(sspi->dev);\n\tpm_runtime_enable(sspi->dev);\n\n\tret = devm_spi_register_master(sspi->dev, master);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(sspi->dev);\ndisable_clk:\n\tclk_disable_unprepare(sspi->clk);\nput_spi:\n\tspi_master_put(master);\n\n\treturn ret;\n}\n\nstatic void synquacer_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\n\tpm_runtime_disable(sspi->dev);\n\n\tclk_disable_unprepare(sspi->clk);\n}\n\nstatic int __maybe_unused synquacer_spi_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = spi_master_suspend(master);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tclk_disable_unprepare(sspi->clk);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused synquacer_spi_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct synquacer_spi *sspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\t \n\t\tsspi->speed = 0;\n\n\t\tret = clk_prepare_enable(sspi->clk);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to enable clk (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = synquacer_spi_enable(master);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(sspi->clk);\n\t\t\tdev_err(dev, \"failed to enable spi (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = spi_master_resume(master);\n\tif (ret < 0)\n\t\tclk_disable_unprepare(sspi->clk);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(synquacer_spi_pm_ops, synquacer_spi_suspend,\n\t\t\t synquacer_spi_resume);\n\nstatic const struct of_device_id synquacer_spi_of_match[] = {\n\t{.compatible = \"socionext,synquacer-spi\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, synquacer_spi_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id synquacer_hsspi_acpi_ids[] = {\n\t{ \"SCX0004\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, synquacer_hsspi_acpi_ids);\n#endif\n\nstatic struct platform_driver synquacer_spi_driver = {\n\t.driver = {\n\t\t.name = \"synquacer-spi\",\n\t\t.pm = &synquacer_spi_pm_ops,\n\t\t.of_match_table = synquacer_spi_of_match,\n\t\t.acpi_match_table = ACPI_PTR(synquacer_hsspi_acpi_ids),\n\t},\n\t.probe = synquacer_spi_probe,\n\t.remove_new = synquacer_spi_remove,\n};\nmodule_platform_driver(synquacer_spi_driver);\n\nMODULE_DESCRIPTION(\"Socionext Synquacer HS-SPI controller driver\");\nMODULE_AUTHOR(\"Masahisa Kojima <masahisa.kojima@linaro.org>\");\nMODULE_AUTHOR(\"Jassi Brar <jaswinder.singh@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}