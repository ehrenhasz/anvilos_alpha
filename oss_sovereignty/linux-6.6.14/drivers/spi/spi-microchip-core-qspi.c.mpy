{
  "module_name": "spi-microchip-core-qspi.c",
  "hash_id": "9507509476025e8cad847dee3cb411bc97da6c5542506d44c87631dcaaac0eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-microchip-core-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define CONTROL_ENABLE\t\tBIT(0)\n#define CONTROL_MASTER\t\tBIT(1)\n#define CONTROL_XIP\t\tBIT(2)\n#define CONTROL_XIPADDR\t\tBIT(3)\n#define CONTROL_CLKIDLE\t\tBIT(10)\n#define CONTROL_SAMPLE_MASK\tGENMASK(12, 11)\n#define CONTROL_MODE0\t\tBIT(13)\n#define CONTROL_MODE12_MASK\tGENMASK(15, 14)\n#define CONTROL_MODE12_EX_RO\tBIT(14)\n#define CONTROL_MODE12_EX_RW\tBIT(15)\n#define CONTROL_MODE12_FULL\tGENMASK(15, 14)\n#define CONTROL_FLAGSX4\t\tBIT(16)\n#define CONTROL_CLKRATE_MASK\tGENMASK(27, 24)\n#define CONTROL_CLKRATE_SHIFT\t24\n\n \n#define FRAMES_TOTALBYTES_MASK\tGENMASK(15, 0)\n#define FRAMES_CMDBYTES_MASK\tGENMASK(24, 16)\n#define FRAMES_CMDBYTES_SHIFT\t16\n#define FRAMES_SHIFT\t\t25\n#define FRAMES_IDLE_MASK\tGENMASK(29, 26)\n#define FRAMES_IDLE_SHIFT\t26\n#define FRAMES_FLAGBYTE\t\tBIT(30)\n#define FRAMES_FLAGWORD\t\tBIT(31)\n\n \n#define IEN_TXDONE\t\tBIT(0)\n#define IEN_RXDONE\t\tBIT(1)\n#define IEN_RXAVAILABLE\t\tBIT(2)\n#define IEN_TXAVAILABLE\t\tBIT(3)\n#define IEN_RXFIFOEMPTY\t\tBIT(4)\n#define IEN_TXFIFOFULL\t\tBIT(5)\n\n \n#define STATUS_TXDONE\t\tBIT(0)\n#define STATUS_RXDONE\t\tBIT(1)\n#define STATUS_RXAVAILABLE\tBIT(2)\n#define STATUS_TXAVAILABLE\tBIT(3)\n#define STATUS_RXFIFOEMPTY\tBIT(4)\n#define STATUS_TXFIFOFULL\tBIT(5)\n#define STATUS_READY\t\tBIT(7)\n#define STATUS_FLAGSX4\t\tBIT(8)\n#define STATUS_MASK\t\tGENMASK(8, 0)\n\n#define BYTESUPPER_MASK\t\tGENMASK(31, 16)\n#define BYTESLOWER_MASK\t\tGENMASK(15, 0)\n\n#define MAX_DIVIDER\t\t16\n#define MIN_DIVIDER\t\t0\n#define MAX_DATA_CMD_LEN\t256\n\n \n#define TIMEOUT_MS\t\t500\n\n \n#define REG_CONTROL\t\t(0x00)\n#define REG_FRAMES\t\t(0x04)\n#define REG_IEN\t\t\t(0x0c)\n#define REG_STATUS\t\t(0x10)\n#define REG_DIRECT_ACCESS\t(0x14)\n#define REG_UPPER_ACCESS\t(0x18)\n#define REG_RX_DATA\t\t(0x40)\n#define REG_TX_DATA\t\t(0x44)\n#define REG_X4_RX_DATA\t\t(0x48)\n#define REG_X4_TX_DATA\t\t(0x4c)\n#define REG_FRAMESUP\t\t(0x50)\n\n \nstruct mchp_coreqspi {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct completion data_completion;\n\tstruct mutex op_lock;  \n\tu8 *txbuf;\n\tu8 *rxbuf;\n\tint irq;\n\tint tx_len;\n\tint rx_len;\n};\n\nstatic int mchp_coreqspi_set_mode(struct mchp_coreqspi *qspi, const struct spi_mem_op *op)\n{\n\tu32 control = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\t \n\tif (op->data.buswidth == 4 || op->data.buswidth == 2) {\n\t\tcontrol &= ~CONTROL_MODE12_MASK;\n\t\tif (op->cmd.buswidth == 1 && (op->addr.buswidth == 1 || op->addr.buswidth == 0))\n\t\t\tcontrol |= CONTROL_MODE12_EX_RO;\n\t\telse if (op->cmd.buswidth == 1)\n\t\t\tcontrol |= CONTROL_MODE12_EX_RW;\n\t\telse\n\t\t\tcontrol |= CONTROL_MODE12_FULL;\n\n\t\tcontrol |= CONTROL_MODE0;\n\t} else {\n\t\tcontrol &= ~(CONTROL_MODE12_MASK |\n\t\t\t     CONTROL_MODE0);\n\t}\n\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\treturn 0;\n}\n\nstatic inline void mchp_coreqspi_read_op(struct mchp_coreqspi *qspi)\n{\n\tu32 control, data;\n\n\tif (!qspi->rx_len)\n\t\treturn;\n\n\tcontrol = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\t \n\tcontrol |= CONTROL_FLAGSX4;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\twhile (qspi->rx_len >= 4) {\n\t\twhile (readl_relaxed(qspi->regs + REG_STATUS) & STATUS_RXFIFOEMPTY)\n\t\t\t;\n\t\tdata = readl_relaxed(qspi->regs + REG_X4_RX_DATA);\n\t\t*(u32 *)qspi->rxbuf = data;\n\t\tqspi->rxbuf += 4;\n\t\tqspi->rx_len -= 4;\n\t}\n\n\tcontrol &= ~CONTROL_FLAGSX4;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\twhile (qspi->rx_len--) {\n\t\twhile (readl_relaxed(qspi->regs + REG_STATUS) & STATUS_RXFIFOEMPTY)\n\t\t\t;\n\t\tdata = readl_relaxed(qspi->regs + REG_RX_DATA);\n\t\t*qspi->rxbuf++ = (data & 0xFF);\n\t}\n}\n\nstatic inline void mchp_coreqspi_write_op(struct mchp_coreqspi *qspi, bool word)\n{\n\tu32 control, data;\n\n\tcontrol = readl_relaxed(qspi->regs + REG_CONTROL);\n\tcontrol |= CONTROL_FLAGSX4;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\twhile (qspi->tx_len >= 4) {\n\t\twhile (readl_relaxed(qspi->regs + REG_STATUS) & STATUS_TXFIFOFULL)\n\t\t\t;\n\t\tdata = *(u32 *)qspi->txbuf;\n\t\tqspi->txbuf += 4;\n\t\tqspi->tx_len -= 4;\n\t\twritel_relaxed(data, qspi->regs + REG_X4_TX_DATA);\n\t}\n\n\tcontrol &= ~CONTROL_FLAGSX4;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\twhile (qspi->tx_len--) {\n\t\twhile (readl_relaxed(qspi->regs + REG_STATUS) & STATUS_TXFIFOFULL)\n\t\t\t;\n\t\tdata =  *qspi->txbuf++;\n\t\twritel_relaxed(data, qspi->regs + REG_TX_DATA);\n\t}\n}\n\nstatic void mchp_coreqspi_enable_ints(struct mchp_coreqspi *qspi)\n{\n\tu32 mask = IEN_TXDONE |\n\t\t   IEN_RXDONE |\n\t\t   IEN_RXAVAILABLE;\n\n\twritel_relaxed(mask, qspi->regs + REG_IEN);\n}\n\nstatic void mchp_coreqspi_disable_ints(struct mchp_coreqspi *qspi)\n{\n\twritel_relaxed(0, qspi->regs + REG_IEN);\n}\n\nstatic irqreturn_t mchp_coreqspi_isr(int irq, void *dev_id)\n{\n\tstruct mchp_coreqspi *qspi = (struct mchp_coreqspi *)dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tint intfield = readl_relaxed(qspi->regs + REG_STATUS) & STATUS_MASK;\n\n\tif (intfield == 0)\n\t\treturn ret;\n\n\tif (intfield & IEN_TXDONE) {\n\t\twritel_relaxed(IEN_TXDONE, qspi->regs + REG_STATUS);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (intfield & IEN_RXAVAILABLE) {\n\t\twritel_relaxed(IEN_RXAVAILABLE, qspi->regs + REG_STATUS);\n\t\tmchp_coreqspi_read_op(qspi);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (intfield & IEN_RXDONE) {\n\t\twritel_relaxed(IEN_RXDONE, qspi->regs + REG_STATUS);\n\t\tcomplete(&qspi->data_completion);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int mchp_coreqspi_setup_clock(struct mchp_coreqspi *qspi, struct spi_device *spi)\n{\n\tunsigned long clk_hz;\n\tu32 control, baud_rate_val = 0;\n\n\tclk_hz = clk_get_rate(qspi->clk);\n\tif (!clk_hz)\n\t\treturn -EINVAL;\n\n\tbaud_rate_val = DIV_ROUND_UP(clk_hz, 2 * spi->max_speed_hz);\n\tif (baud_rate_val > MAX_DIVIDER || baud_rate_val < MIN_DIVIDER) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"could not configure the clock for spi clock %d Hz & system clock %ld Hz\\n\",\n\t\t\tspi->max_speed_hz, clk_hz);\n\t\treturn -EINVAL;\n\t}\n\n\tcontrol = readl_relaxed(qspi->regs + REG_CONTROL);\n\tcontrol |= baud_rate_val << CONTROL_CLKRATE_SHIFT;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\tcontrol = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\tif ((spi->mode & SPI_CPOL) && (spi->mode & SPI_CPHA))\n\t\tcontrol |= CONTROL_CLKIDLE;\n\telse\n\t\tcontrol &= ~CONTROL_CLKIDLE;\n\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\treturn 0;\n}\n\nstatic int mchp_coreqspi_setup_op(struct spi_device *spi_dev)\n{\n\tstruct spi_controller *ctlr = spi_dev->master;\n\tstruct mchp_coreqspi *qspi = spi_controller_get_devdata(ctlr);\n\tu32 control = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\tcontrol |= (CONTROL_MASTER | CONTROL_ENABLE);\n\tcontrol &= ~CONTROL_CLKIDLE;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\n\treturn 0;\n}\n\nstatic inline void mchp_coreqspi_config_op(struct mchp_coreqspi *qspi, const struct spi_mem_op *op)\n{\n\tu32 idle_cycles = 0;\n\tint total_bytes, cmd_bytes, frames, ctrl;\n\n\tcmd_bytes = op->cmd.nbytes + op->addr.nbytes;\n\ttotal_bytes = cmd_bytes + op->data.nbytes;\n\n\t \n\tif (!(op->data.dir == SPI_MEM_DATA_IN))\n\t\tcmd_bytes = total_bytes;\n\n\tframes = total_bytes & BYTESUPPER_MASK;\n\twritel_relaxed(frames, qspi->regs + REG_FRAMESUP);\n\tframes = total_bytes & BYTESLOWER_MASK;\n\tframes |= cmd_bytes << FRAMES_CMDBYTES_SHIFT;\n\n\tif (op->dummy.buswidth)\n\t\tidle_cycles = op->dummy.nbytes * 8 / op->dummy.buswidth;\n\n\tframes |= idle_cycles << FRAMES_IDLE_SHIFT;\n\tctrl = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\tif (ctrl & CONTROL_MODE12_MASK)\n\t\tframes |= (1 << FRAMES_SHIFT);\n\n\tframes |= FRAMES_FLAGWORD;\n\twritel_relaxed(frames, qspi->regs + REG_FRAMES);\n}\n\nstatic int mchp_qspi_wait_for_ready(struct spi_mem *mem)\n{\n\tstruct mchp_coreqspi *qspi = spi_controller_get_devdata\n\t\t\t\t    (mem->spi->master);\n\tu32 status;\n\tint ret;\n\n\tret = readl_poll_timeout(qspi->regs + REG_STATUS, status,\n\t\t\t\t (status & STATUS_READY), 0,\n\t\t\t\t TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&mem->spi->dev,\n\t\t\t\"Timeout waiting on QSPI ready.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int mchp_coreqspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct mchp_coreqspi *qspi = spi_controller_get_devdata\n\t\t\t\t    (mem->spi->master);\n\tu32 address = op->addr.val;\n\tu8 opcode = op->cmd.opcode;\n\tu8 opaddr[5];\n\tint err, i;\n\n\tmutex_lock(&qspi->op_lock);\n\terr = mchp_qspi_wait_for_ready(mem);\n\tif (err)\n\t\tgoto error;\n\n\terr = mchp_coreqspi_setup_clock(qspi, mem->spi);\n\tif (err)\n\t\tgoto error;\n\n\terr = mchp_coreqspi_set_mode(qspi, op);\n\tif (err)\n\t\tgoto error;\n\n\treinit_completion(&qspi->data_completion);\n\tmchp_coreqspi_config_op(qspi, op);\n\tif (op->cmd.opcode) {\n\t\tqspi->txbuf = &opcode;\n\t\tqspi->rxbuf = NULL;\n\t\tqspi->tx_len = op->cmd.nbytes;\n\t\tqspi->rx_len = 0;\n\t\tmchp_coreqspi_write_op(qspi, false);\n\t}\n\n\tqspi->txbuf = &opaddr[0];\n\tif (op->addr.nbytes) {\n\t\tfor (i = 0; i < op->addr.nbytes; i++)\n\t\t\tqspi->txbuf[i] = address >> (8 * (op->addr.nbytes - i - 1));\n\n\t\tqspi->rxbuf = NULL;\n\t\tqspi->tx_len = op->addr.nbytes;\n\t\tqspi->rx_len = 0;\n\t\tmchp_coreqspi_write_op(qspi, false);\n\t}\n\n\tif (op->data.nbytes) {\n\t\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\t\tqspi->txbuf = (u8 *)op->data.buf.out;\n\t\t\tqspi->rxbuf = NULL;\n\t\t\tqspi->rx_len = 0;\n\t\t\tqspi->tx_len = op->data.nbytes;\n\t\t\tmchp_coreqspi_write_op(qspi, true);\n\t\t} else {\n\t\t\tqspi->txbuf = NULL;\n\t\t\tqspi->rxbuf = (u8 *)op->data.buf.in;\n\t\t\tqspi->rx_len = op->data.nbytes;\n\t\t\tqspi->tx_len = 0;\n\t\t}\n\t}\n\n\tmchp_coreqspi_enable_ints(qspi);\n\n\tif (!wait_for_completion_timeout(&qspi->data_completion, msecs_to_jiffies(1000)))\n\t\terr = -ETIMEDOUT;\n\nerror:\n\tmutex_unlock(&qspi->op_lock);\n\tmchp_coreqspi_disable_ints(qspi);\n\n\treturn err;\n}\n\nstatic bool mchp_coreqspi_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\tif ((op->data.buswidth == 4 || op->data.buswidth == 2) &&\n\t    (op->cmd.buswidth == 1 && (op->addr.buswidth == 1 || op->addr.buswidth == 0))) {\n\t\t \n\t\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int mchp_coreqspi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tif (op->data.dir == SPI_MEM_DATA_OUT || op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (op->data.nbytes > MAX_DATA_CMD_LEN)\n\t\t\top->data.nbytes = MAX_DATA_CMD_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops mchp_coreqspi_mem_ops = {\n\t.adjust_op_size = mchp_coreqspi_adjust_op_size,\n\t.supports_op = mchp_coreqspi_supports_op,\n\t.exec_op = mchp_coreqspi_exec_op,\n};\n\nstatic int mchp_coreqspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct mchp_coreqspi *qspi;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tctlr = devm_spi_alloc_master(&pdev->dev, sizeof(*qspi));\n\tif (!ctlr)\n\t\treturn dev_err_probe(&pdev->dev, -ENOMEM,\n\t\t\t\t     \"unable to allocate master for QSPI controller\\n\");\n\n\tqspi = spi_controller_get_devdata(ctlr);\n\tplatform_set_drvdata(pdev, qspi);\n\n\tqspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qspi->regs))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(qspi->regs),\n\t\t\t\t     \"failed to map registers\\n\");\n\n\tqspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(qspi->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(qspi->clk),\n\t\t\t\t     \"could not get clock\\n\");\n\n\tret = clk_prepare_enable(qspi->clk);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to enable clock\\n\");\n\n\tinit_completion(&qspi->data_completion);\n\tmutex_init(&qspi->op_lock);\n\n\tqspi->irq = platform_get_irq(pdev, 0);\n\tif (qspi->irq < 0) {\n\t\tret = qspi->irq;\n\t\tgoto out;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, qspi->irq, mchp_coreqspi_isr,\n\t\t\t       IRQF_SHARED, pdev->name, qspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->mem_ops = &mchp_coreqspi_mem_ops;\n\tctlr->setup = mchp_coreqspi_setup_op;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD |\n\t\t\t  SPI_TX_DUAL | SPI_TX_QUAD;\n\tctlr->dev.of_node = np;\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret,\n\t\t\t      \"spi_register_controller failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tclk_disable_unprepare(qspi->clk);\n\n\treturn ret;\n}\n\nstatic void mchp_coreqspi_remove(struct platform_device *pdev)\n{\n\tstruct mchp_coreqspi *qspi = platform_get_drvdata(pdev);\n\tu32 control = readl_relaxed(qspi->regs + REG_CONTROL);\n\n\tmchp_coreqspi_disable_ints(qspi);\n\tcontrol &= ~CONTROL_ENABLE;\n\twritel_relaxed(control, qspi->regs + REG_CONTROL);\n\tclk_disable_unprepare(qspi->clk);\n}\n\nstatic const struct of_device_id mchp_coreqspi_of_match[] = {\n\t{ .compatible = \"microchip,coreqspi-rtl-v2\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_coreqspi_of_match);\n\nstatic struct platform_driver mchp_coreqspi_driver = {\n\t.probe = mchp_coreqspi_probe,\n\t.driver = {\n\t\t.name = \"microchip,coreqspi\",\n\t\t.of_match_table = mchp_coreqspi_of_match,\n\t},\n\t.remove_new = mchp_coreqspi_remove,\n};\nmodule_platform_driver(mchp_coreqspi_driver);\n\nMODULE_AUTHOR(\"Naga Sureshkumar Relli <nagasuresh.relli@microchip.com\");\nMODULE_DESCRIPTION(\"Microchip coreQSPI QSPI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}