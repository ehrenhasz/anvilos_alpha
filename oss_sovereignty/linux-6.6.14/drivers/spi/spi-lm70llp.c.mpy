{
  "module_name": "spi-lm70llp.c",
  "hash_id": "f526ebac80d80655bbb150c9aa226c7d8450b96996509f686cfb1c0a67357308",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-lm70llp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/parport.h>\n#include <linux/sysfs.h>\n#include <linux/workqueue.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n\n \n\n#define DRVNAME\t\t\"spi-lm70llp\"\n\n#define lm70_INIT\t0xBE\n#define SIO\t\t0x10\n#define nCS\t\t0x20\n#define SCLK\t\t0x40\n\n \n\nstruct spi_lm70llp {\n\tstruct spi_bitbang\tbitbang;\n\tstruct parport\t\t*port;\n\tstruct pardevice\t*pd;\n\tstruct spi_device\t*spidev_lm70;\n\tstruct spi_board_info\tinfo;\n\t\n};\n\n \nstatic struct spi_lm70llp *lm70llp;\n\n \n\nstatic inline struct spi_lm70llp *spidev_to_pp(struct spi_device *spi)\n{\n\treturn spi->controller_data;\n}\n\n \n\n \n\nstatic inline void deassertCS(struct spi_lm70llp *pp)\n{\n\tu8 data = parport_read_data(pp->port);\n\n\tdata &= ~0x80;\t\t \n\tparport_write_data(pp->port, data | nCS);\n}\n\nstatic inline void assertCS(struct spi_lm70llp *pp)\n{\n\tu8 data = parport_read_data(pp->port);\n\n\tdata |= 0x80;\t\t \n\tparport_write_data(pp->port, data & ~nCS);\n}\n\nstatic inline void clkHigh(struct spi_lm70llp *pp)\n{\n\tu8 data = parport_read_data(pp->port);\n\n\tparport_write_data(pp->port, data | SCLK);\n}\n\nstatic inline void clkLow(struct spi_lm70llp *pp)\n{\n\tu8 data = parport_read_data(pp->port);\n\n\tparport_write_data(pp->port, data & ~SCLK);\n}\n\n \n\nstatic inline void spidelay(unsigned d)\n{\n\tudelay(d);\n}\n\nstatic inline void setsck(struct spi_device *s, int is_on)\n{\n\tstruct spi_lm70llp *pp = spidev_to_pp(s);\n\n\tif (is_on)\n\t\tclkHigh(pp);\n\telse\n\t\tclkLow(pp);\n}\n\nstatic inline void setmosi(struct spi_device *s, int is_on)\n{\n\t \n}\n\n \nstatic inline int getmiso(struct spi_device *s)\n{\n\tstruct spi_lm70llp *pp = spidev_to_pp(s);\n\n\treturn ((SIO == (parport_read_status(pp->port) & SIO)) ? 0 : 1);\n}\n\n \n\n#include \"spi-bitbang-txrx.h\"\n\nstatic void lm70_chipselect(struct spi_device *spi, int value)\n{\n\tstruct spi_lm70llp *pp = spidev_to_pp(spi);\n\n\tif (value)\n\t\tassertCS(pp);\n\telse\n\t\tdeassertCS(pp);\n}\n\n \nstatic u32 lm70_txrx(struct spi_device *spi, unsigned nsecs, u32 word, u8 bits,\n\t\t     unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic void spi_lm70llp_attach(struct parport *p)\n{\n\tstruct pardevice\t*pd;\n\tstruct spi_lm70llp\t*pp;\n\tstruct spi_master\t*master;\n\tint\t\t\tstatus;\n\tstruct pardev_cb\tlm70llp_cb;\n\n\tif (lm70llp) {\n\t\tpr_warn(\"spi_lm70llp instance already loaded. Aborting.\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tmaster = spi_alloc_master(p->physport->dev, sizeof(*pp));\n\tif (!master) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\tpp = spi_master_get_devdata(master);\n\n\t \n\tpp->bitbang.master = master;\n\tpp->bitbang.chipselect = lm70_chipselect;\n\tpp->bitbang.txrx_word[SPI_MODE_0] = lm70_txrx;\n\tpp->bitbang.flags = SPI_3WIRE;\n\n\t \n\tpp->port = p;\n\tmemset(&lm70llp_cb, 0, sizeof(lm70llp_cb));\n\tlm70llp_cb.private = pp;\n\tlm70llp_cb.flags = PARPORT_FLAG_EXCL;\n\tpd = parport_register_dev_model(p, DRVNAME, &lm70llp_cb, 0);\n\n\tif (!pd) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_free_master;\n\t}\n\tpp->pd = pd;\n\n\tstatus = parport_claim(pd);\n\tif (status < 0)\n\t\tgoto out_parport_unreg;\n\n\t \n\tstatus = spi_bitbang_start(&pp->bitbang);\n\tif (status < 0) {\n\t\tdev_warn(&pd->dev, \"spi_bitbang_start failed with status %d\\n\",\n\t\t\t status);\n\t\tgoto out_off_and_release;\n\t}\n\n\t \n\tstrcpy(pp->info.modalias, \"lm70\");\n\tpp->info.max_speed_hz = 6 * 1000 * 1000;\n\tpp->info.chip_select = 0;\n\tpp->info.mode = SPI_3WIRE | SPI_MODE_0;\n\n\t \n\tparport_write_data(pp->port, lm70_INIT);\n\n\t \n\tpp->info.controller_data = pp;\n\tpp->spidev_lm70 = spi_new_device(pp->bitbang.master, &pp->info);\n\tif (pp->spidev_lm70)\n\t\tdev_dbg(&pp->spidev_lm70->dev, \"spidev_lm70 at %s\\n\",\n\t\t\tdev_name(&pp->spidev_lm70->dev));\n\telse {\n\t\tdev_warn(&pd->dev, \"spi_new_device failed\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto out_bitbang_stop;\n\t}\n\tpp->spidev_lm70->bits_per_word = 8;\n\n\tlm70llp = pp;\n\treturn;\n\nout_bitbang_stop:\n\tspi_bitbang_stop(&pp->bitbang);\nout_off_and_release:\n\t \n\tparport_write_data(pp->port, 0);\n\tmdelay(10);\n\tparport_release(pp->pd);\nout_parport_unreg:\n\tparport_unregister_device(pd);\nout_free_master:\n\tspi_master_put(master);\nout_fail:\n\tpr_info(\"spi_lm70llp probe fail, status %d\\n\", status);\n}\n\nstatic void spi_lm70llp_detach(struct parport *p)\n{\n\tstruct spi_lm70llp\t\t*pp;\n\n\tif (!lm70llp || lm70llp->port != p)\n\t\treturn;\n\n\tpp = lm70llp;\n\tspi_bitbang_stop(&pp->bitbang);\n\n\t \n\tparport_write_data(pp->port, 0);\n\n\tparport_release(pp->pd);\n\tparport_unregister_device(pp->pd);\n\n\tspi_master_put(pp->bitbang.master);\n\n\tlm70llp = NULL;\n}\n\nstatic struct parport_driver spi_lm70llp_drv = {\n\t.name =\t\tDRVNAME,\n\t.match_port =\tspi_lm70llp_attach,\n\t.detach =\tspi_lm70llp_detach,\n\t.devmodel =\ttrue,\n};\nmodule_parport_driver(spi_lm70llp_drv);\n\nMODULE_AUTHOR(\"Kaiwan N Billimoria <kaiwan@designergraphix.com>\");\nMODULE_DESCRIPTION(\n\t\"Parport adapter for the National Semiconductor LM70 LLP eval board\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}