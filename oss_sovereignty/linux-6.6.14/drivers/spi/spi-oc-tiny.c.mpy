{
  "module_name": "spi-oc-tiny.c",
  "hash_id": "1cb14ff9f2f54c027b3fe2cb166a0328bccc735659be568e7b90d1f33684b688",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-oc-tiny.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/spi_oc_tiny.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#define DRV_NAME \"spi_oc_tiny\"\n\n#define TINY_SPI_RXDATA 0\n#define TINY_SPI_TXDATA 4\n#define TINY_SPI_STATUS 8\n#define TINY_SPI_CONTROL 12\n#define TINY_SPI_BAUD 16\n\n#define TINY_SPI_STATUS_TXE 0x1\n#define TINY_SPI_STATUS_TXR 0x2\n\nstruct tiny_spi {\n\t \n\tstruct spi_bitbang bitbang;\n\tstruct completion done;\n\n\tvoid __iomem *base;\n\tint irq;\n\tunsigned int freq;\n\tunsigned int baudwidth;\n\tunsigned int baud;\n\tunsigned int speed_hz;\n\tunsigned int mode;\n\tunsigned int len;\n\tunsigned int txc, rxc;\n\tconst u8 *txp;\n\tu8 *rxp;\n};\n\nstatic inline struct tiny_spi *tiny_spi_to_hw(struct spi_device *sdev)\n{\n\treturn spi_master_get_devdata(sdev->master);\n}\n\nstatic unsigned int tiny_spi_baud(struct spi_device *spi, unsigned int hz)\n{\n\tstruct tiny_spi *hw = tiny_spi_to_hw(spi);\n\n\treturn min(DIV_ROUND_UP(hw->freq, hz * 2), (1U << hw->baudwidth)) - 1;\n}\n\nstatic int tiny_spi_setup_transfer(struct spi_device *spi,\n\t\t\t\t   struct spi_transfer *t)\n{\n\tstruct tiny_spi *hw = tiny_spi_to_hw(spi);\n\tunsigned int baud = hw->baud;\n\n\tif (t) {\n\t\tif (t->speed_hz && t->speed_hz != hw->speed_hz)\n\t\t\tbaud = tiny_spi_baud(spi, t->speed_hz);\n\t}\n\twritel(baud, hw->base + TINY_SPI_BAUD);\n\twritel(hw->mode, hw->base + TINY_SPI_CONTROL);\n\treturn 0;\n}\n\nstatic int tiny_spi_setup(struct spi_device *spi)\n{\n\tstruct tiny_spi *hw = tiny_spi_to_hw(spi);\n\n\tif (spi->max_speed_hz != hw->speed_hz) {\n\t\thw->speed_hz = spi->max_speed_hz;\n\t\thw->baud = tiny_spi_baud(spi, hw->speed_hz);\n\t}\n\thw->mode = spi->mode & SPI_MODE_X_MASK;\n\treturn 0;\n}\n\nstatic inline void tiny_spi_wait_txr(struct tiny_spi *hw)\n{\n\twhile (!(readb(hw->base + TINY_SPI_STATUS) &\n\t\t TINY_SPI_STATUS_TXR))\n\t\tcpu_relax();\n}\n\nstatic inline void tiny_spi_wait_txe(struct tiny_spi *hw)\n{\n\twhile (!(readb(hw->base + TINY_SPI_STATUS) &\n\t\t TINY_SPI_STATUS_TXE))\n\t\tcpu_relax();\n}\n\nstatic int tiny_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct tiny_spi *hw = tiny_spi_to_hw(spi);\n\tconst u8 *txp = t->tx_buf;\n\tu8 *rxp = t->rx_buf;\n\tunsigned int i;\n\n\tif (hw->irq >= 0) {\n\t\t \n\t\thw->len = t->len;\n\t\thw->txp = t->tx_buf;\n\t\thw->rxp = t->rx_buf;\n\t\thw->txc = 0;\n\t\thw->rxc = 0;\n\n\t\t \n\t\tif (t->len > 1) {\n\t\t\twriteb(hw->txp ? *hw->txp++ : 0,\n\t\t\t       hw->base + TINY_SPI_TXDATA);\n\t\t\thw->txc++;\n\t\t\twriteb(hw->txp ? *hw->txp++ : 0,\n\t\t\t       hw->base + TINY_SPI_TXDATA);\n\t\t\thw->txc++;\n\t\t\twriteb(TINY_SPI_STATUS_TXR, hw->base + TINY_SPI_STATUS);\n\t\t} else {\n\t\t\twriteb(hw->txp ? *hw->txp++ : 0,\n\t\t\t       hw->base + TINY_SPI_TXDATA);\n\t\t\thw->txc++;\n\t\t\twriteb(TINY_SPI_STATUS_TXE, hw->base + TINY_SPI_STATUS);\n\t\t}\n\n\t\twait_for_completion(&hw->done);\n\t} else {\n\t\t \n\t\twriteb(txp ? *txp++ : 0, hw->base + TINY_SPI_TXDATA);\n\t\tfor (i = 1; i < t->len; i++) {\n\t\t\twriteb(txp ? *txp++ : 0, hw->base + TINY_SPI_TXDATA);\n\n\t\t\tif (rxp || (i != t->len - 1))\n\t\t\t\ttiny_spi_wait_txr(hw);\n\t\t\tif (rxp)\n\t\t\t\t*rxp++ = readb(hw->base + TINY_SPI_TXDATA);\n\t\t}\n\t\ttiny_spi_wait_txe(hw);\n\t\tif (rxp)\n\t\t\t*rxp++ = readb(hw->base + TINY_SPI_RXDATA);\n\t}\n\n\treturn t->len;\n}\n\nstatic irqreturn_t tiny_spi_irq(int irq, void *dev)\n{\n\tstruct tiny_spi *hw = dev;\n\n\twriteb(0, hw->base + TINY_SPI_STATUS);\n\tif (hw->rxc + 1 == hw->len) {\n\t\tif (hw->rxp)\n\t\t\t*hw->rxp++ = readb(hw->base + TINY_SPI_RXDATA);\n\t\thw->rxc++;\n\t\tcomplete(&hw->done);\n\t} else {\n\t\tif (hw->rxp)\n\t\t\t*hw->rxp++ = readb(hw->base + TINY_SPI_TXDATA);\n\t\thw->rxc++;\n\t\tif (hw->txc < hw->len) {\n\t\t\twriteb(hw->txp ? *hw->txp++ : 0,\n\t\t\t       hw->base + TINY_SPI_TXDATA);\n\t\t\thw->txc++;\n\t\t\twriteb(TINY_SPI_STATUS_TXR,\n\t\t\t       hw->base + TINY_SPI_STATUS);\n\t\t} else {\n\t\t\twriteb(TINY_SPI_STATUS_TXE,\n\t\t\t       hw->base + TINY_SPI_STATUS);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_OF\n#include <linux/of_gpio.h>\n\nstatic int tiny_spi_of_probe(struct platform_device *pdev)\n{\n\tstruct tiny_spi *hw = platform_get_drvdata(pdev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 val;\n\n\tif (!np)\n\t\treturn 0;\n\thw->bitbang.master->dev.of_node = pdev->dev.of_node;\n\tif (!of_property_read_u32(np, \"clock-frequency\", &val))\n\t\thw->freq = val;\n\tif (!of_property_read_u32(np, \"baud-width\", &val))\n\t\thw->baudwidth = val;\n\treturn 0;\n}\n#else  \nstatic int tiny_spi_of_probe(struct platform_device *pdev)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int tiny_spi_probe(struct platform_device *pdev)\n{\n\tstruct tiny_spi_platform_data *platp = dev_get_platdata(&pdev->dev);\n\tstruct tiny_spi *hw;\n\tstruct spi_master *master;\n\tint err = -ENODEV;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(struct tiny_spi));\n\tif (!master)\n\t\treturn err;\n\n\t \n\tmaster->bus_num = pdev->id;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->setup = tiny_spi_setup;\n\tmaster->use_gpio_descriptors = true;\n\n\thw = spi_master_get_devdata(master);\n\tplatform_set_drvdata(pdev, hw);\n\n\t \n\thw->bitbang.master = master;\n\thw->bitbang.setup_transfer = tiny_spi_setup_transfer;\n\thw->bitbang.txrx_bufs = tiny_spi_txrx_bufs;\n\n\t \n\thw->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hw->base)) {\n\t\terr = PTR_ERR(hw->base);\n\t\tgoto exit;\n\t}\n\t \n\thw->irq = platform_get_irq(pdev, 0);\n\tif (hw->irq >= 0) {\n\t\tinit_completion(&hw->done);\n\t\terr = devm_request_irq(&pdev->dev, hw->irq, tiny_spi_irq, 0,\n\t\t\t\t       pdev->name, hw);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\t \n\tif (platp) {\n\t\thw->freq = platp->freq;\n\t\thw->baudwidth = platp->baudwidth;\n\t} else {\n\t\terr = tiny_spi_of_probe(pdev);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\n\t \n\terr = spi_bitbang_start(&hw->bitbang);\n\tif (err)\n\t\tgoto exit;\n\tdev_info(&pdev->dev, \"base %p, irq %d\\n\", hw->base, hw->irq);\n\n\treturn 0;\n\nexit:\n\tspi_master_put(master);\n\treturn err;\n}\n\nstatic void tiny_spi_remove(struct platform_device *pdev)\n{\n\tstruct tiny_spi *hw = platform_get_drvdata(pdev);\n\tstruct spi_master *master = hw->bitbang.master;\n\n\tspi_bitbang_stop(&hw->bitbang);\n\tspi_master_put(master);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tiny_spi_match[] = {\n\t{ .compatible = \"opencores,tiny-spi-rtlsvn2\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tiny_spi_match);\n#endif  \n\nstatic struct platform_driver tiny_spi_driver = {\n\t.probe = tiny_spi_probe,\n\t.remove_new = tiny_spi_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = NULL,\n\t\t.of_match_table = of_match_ptr(tiny_spi_match),\n\t},\n};\nmodule_platform_driver(tiny_spi_driver);\n\nMODULE_DESCRIPTION(\"OpenCores tiny SPI driver\");\nMODULE_AUTHOR(\"Thomas Chou <thomas@wytron.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}