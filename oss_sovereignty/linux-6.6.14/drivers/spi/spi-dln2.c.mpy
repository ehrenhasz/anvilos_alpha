{
  "module_name": "spi-dln2.c",
  "hash_id": "ea2af5e1f5746f0542dd38a7f6c0f0b4e1adecdf78d5a27101fff476caf02629",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-dln2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/mfd/dln2.h>\n#include <linux/spi/spi.h>\n#include <linux/pm_runtime.h>\n#include <asm/unaligned.h>\n\n#define DLN2_SPI_MODULE_ID\t\t0x02\n#define DLN2_SPI_CMD(cmd)\t\tDLN2_CMD(cmd, DLN2_SPI_MODULE_ID)\n\n \n#define DLN2_SPI_GET_PORT_COUNT\t\t\tDLN2_SPI_CMD(0x00)\n#define DLN2_SPI_ENABLE\t\t\t\tDLN2_SPI_CMD(0x11)\n#define DLN2_SPI_DISABLE\t\t\tDLN2_SPI_CMD(0x12)\n#define DLN2_SPI_IS_ENABLED\t\t\tDLN2_SPI_CMD(0x13)\n#define DLN2_SPI_SET_MODE\t\t\tDLN2_SPI_CMD(0x14)\n#define DLN2_SPI_GET_MODE\t\t\tDLN2_SPI_CMD(0x15)\n#define DLN2_SPI_SET_FRAME_SIZE\t\t\tDLN2_SPI_CMD(0x16)\n#define DLN2_SPI_GET_FRAME_SIZE\t\t\tDLN2_SPI_CMD(0x17)\n#define DLN2_SPI_SET_FREQUENCY\t\t\tDLN2_SPI_CMD(0x18)\n#define DLN2_SPI_GET_FREQUENCY\t\t\tDLN2_SPI_CMD(0x19)\n#define DLN2_SPI_READ_WRITE\t\t\tDLN2_SPI_CMD(0x1A)\n#define DLN2_SPI_READ\t\t\t\tDLN2_SPI_CMD(0x1B)\n#define DLN2_SPI_WRITE\t\t\t\tDLN2_SPI_CMD(0x1C)\n#define DLN2_SPI_SET_DELAY_BETWEEN_SS\t\tDLN2_SPI_CMD(0x20)\n#define DLN2_SPI_GET_DELAY_BETWEEN_SS\t\tDLN2_SPI_CMD(0x21)\n#define DLN2_SPI_SET_DELAY_AFTER_SS\t\tDLN2_SPI_CMD(0x22)\n#define DLN2_SPI_GET_DELAY_AFTER_SS\t\tDLN2_SPI_CMD(0x23)\n#define DLN2_SPI_SET_DELAY_BETWEEN_FRAMES\tDLN2_SPI_CMD(0x24)\n#define DLN2_SPI_GET_DELAY_BETWEEN_FRAMES\tDLN2_SPI_CMD(0x25)\n#define DLN2_SPI_SET_SS\t\t\t\tDLN2_SPI_CMD(0x26)\n#define DLN2_SPI_GET_SS\t\t\t\tDLN2_SPI_CMD(0x27)\n#define DLN2_SPI_RELEASE_SS\t\t\tDLN2_SPI_CMD(0x28)\n#define DLN2_SPI_SS_VARIABLE_ENABLE\t\tDLN2_SPI_CMD(0x2B)\n#define DLN2_SPI_SS_VARIABLE_DISABLE\t\tDLN2_SPI_CMD(0x2C)\n#define DLN2_SPI_SS_VARIABLE_IS_ENABLED\t\tDLN2_SPI_CMD(0x2D)\n#define DLN2_SPI_SS_AAT_ENABLE\t\t\tDLN2_SPI_CMD(0x2E)\n#define DLN2_SPI_SS_AAT_DISABLE\t\t\tDLN2_SPI_CMD(0x2F)\n#define DLN2_SPI_SS_AAT_IS_ENABLED\t\tDLN2_SPI_CMD(0x30)\n#define DLN2_SPI_SS_BETWEEN_FRAMES_ENABLE\tDLN2_SPI_CMD(0x31)\n#define DLN2_SPI_SS_BETWEEN_FRAMES_DISABLE\tDLN2_SPI_CMD(0x32)\n#define DLN2_SPI_SS_BETWEEN_FRAMES_IS_ENABLED\tDLN2_SPI_CMD(0x33)\n#define DLN2_SPI_SET_CPHA\t\t\tDLN2_SPI_CMD(0x34)\n#define DLN2_SPI_GET_CPHA\t\t\tDLN2_SPI_CMD(0x35)\n#define DLN2_SPI_SET_CPOL\t\t\tDLN2_SPI_CMD(0x36)\n#define DLN2_SPI_GET_CPOL\t\t\tDLN2_SPI_CMD(0x37)\n#define DLN2_SPI_SS_MULTI_ENABLE\t\tDLN2_SPI_CMD(0x38)\n#define DLN2_SPI_SS_MULTI_DISABLE\t\tDLN2_SPI_CMD(0x39)\n#define DLN2_SPI_SS_MULTI_IS_ENABLED\t\tDLN2_SPI_CMD(0x3A)\n#define DLN2_SPI_GET_SUPPORTED_MODES\t\tDLN2_SPI_CMD(0x40)\n#define DLN2_SPI_GET_SUPPORTED_CPHA_VALUES\tDLN2_SPI_CMD(0x41)\n#define DLN2_SPI_GET_SUPPORTED_CPOL_VALUES\tDLN2_SPI_CMD(0x42)\n#define DLN2_SPI_GET_SUPPORTED_FRAME_SIZES\tDLN2_SPI_CMD(0x43)\n#define DLN2_SPI_GET_SS_COUNT\t\t\tDLN2_SPI_CMD(0x44)\n#define DLN2_SPI_GET_MIN_FREQUENCY\t\tDLN2_SPI_CMD(0x45)\n#define DLN2_SPI_GET_MAX_FREQUENCY\t\tDLN2_SPI_CMD(0x46)\n#define DLN2_SPI_GET_MIN_DELAY_BETWEEN_SS\tDLN2_SPI_CMD(0x47)\n#define DLN2_SPI_GET_MAX_DELAY_BETWEEN_SS\tDLN2_SPI_CMD(0x48)\n#define DLN2_SPI_GET_MIN_DELAY_AFTER_SS\t\tDLN2_SPI_CMD(0x49)\n#define DLN2_SPI_GET_MAX_DELAY_AFTER_SS\t\tDLN2_SPI_CMD(0x4A)\n#define DLN2_SPI_GET_MIN_DELAY_BETWEEN_FRAMES\tDLN2_SPI_CMD(0x4B)\n#define DLN2_SPI_GET_MAX_DELAY_BETWEEN_FRAMES\tDLN2_SPI_CMD(0x4C)\n\n#define DLN2_SPI_MAX_XFER_SIZE\t\t\t256\n#define DLN2_SPI_BUF_SIZE\t\t\t(DLN2_SPI_MAX_XFER_SIZE + 16)\n#define DLN2_SPI_ATTR_LEAVE_SS_LOW\t\tBIT(0)\n#define DLN2_TRANSFERS_WAIT_COMPLETE\t\t1\n#define DLN2_TRANSFERS_CANCEL\t\t\t0\n#define DLN2_RPM_AUTOSUSPEND_TIMEOUT\t\t2000\n\nstruct dln2_spi {\n\tstruct platform_device *pdev;\n\tstruct spi_controller *host;\n\tu8 port;\n\n\t \n\tvoid *buf;\n\n\tu8 bpw;\n\tu32 speed;\n\tu16 mode;\n\tu8 cs;\n};\n\n \nstatic int dln2_spi_enable(struct dln2_spi *dln2, bool enable)\n{\n\tu16 cmd;\n\tstruct {\n\t\tu8 port;\n\t\tu8 wait_for_completion;\n\t} tx;\n\tunsigned len = sizeof(tx);\n\n\ttx.port = dln2->port;\n\n\tif (enable) {\n\t\tcmd = DLN2_SPI_ENABLE;\n\t\tlen -= sizeof(tx.wait_for_completion);\n\t} else {\n\t\ttx.wait_for_completion = DLN2_TRANSFERS_WAIT_COMPLETE;\n\t\tcmd = DLN2_SPI_DISABLE;\n\t}\n\n\treturn dln2_transfer_tx(dln2->pdev, cmd, &tx, len);\n}\n\n \nstatic int dln2_spi_cs_set(struct dln2_spi *dln2, u8 cs_mask)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 cs;\n\t} tx;\n\n\ttx.port = dln2->port;\n\n\t \n\ttx.cs = ~cs_mask;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_SS, &tx, sizeof(tx));\n}\n\n \nstatic int dln2_spi_cs_set_one(struct dln2_spi *dln2, u8 cs)\n{\n\treturn dln2_spi_cs_set(dln2, BIT(cs));\n}\n\n \nstatic int dln2_spi_cs_enable(struct dln2_spi *dln2, u8 cs_mask, bool enable)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 cs;\n\t} tx;\n\tu16 cmd;\n\n\ttx.port = dln2->port;\n\ttx.cs = cs_mask;\n\tcmd = enable ? DLN2_SPI_SS_MULTI_ENABLE : DLN2_SPI_SS_MULTI_DISABLE;\n\n\treturn dln2_transfer_tx(dln2->pdev, cmd, &tx, sizeof(tx));\n}\n\nstatic int dln2_spi_cs_enable_all(struct dln2_spi *dln2, bool enable)\n{\n\tu8 cs_mask = GENMASK(dln2->host->num_chipselect - 1, 0);\n\n\treturn dln2_spi_cs_enable(dln2, cs_mask, enable);\n}\n\nstatic int dln2_spi_get_cs_num(struct dln2_spi *dln2, u16 *cs_num)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t} tx;\n\tstruct {\n\t\t__le16 cs_count;\n\t} rx;\n\tunsigned rx_len = sizeof(rx);\n\n\ttx.port = dln2->port;\n\tret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SS_COUNT, &tx, sizeof(tx),\n\t\t\t    &rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx))\n\t\treturn -EPROTO;\n\n\t*cs_num = le16_to_cpu(rx.cs_count);\n\n\tdev_dbg(&dln2->pdev->dev, \"cs_num = %d\\n\", *cs_num);\n\n\treturn 0;\n}\n\nstatic int dln2_spi_get_speed(struct dln2_spi *dln2, u16 cmd, u32 *freq)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t} tx;\n\tstruct {\n\t\t__le32 speed;\n\t} rx;\n\tunsigned rx_len = sizeof(rx);\n\n\ttx.port = dln2->port;\n\n\tret = dln2_transfer(dln2->pdev, cmd, &tx, sizeof(tx), &rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx))\n\t\treturn -EPROTO;\n\n\t*freq = le32_to_cpu(rx.speed);\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_get_speed_range(struct dln2_spi *dln2, u32 *fmin, u32 *fmax)\n{\n\tint ret;\n\n\tret = dln2_spi_get_speed(dln2, DLN2_SPI_GET_MIN_FREQUENCY, fmin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dln2_spi_get_speed(dln2, DLN2_SPI_GET_MAX_FREQUENCY, fmax);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&dln2->pdev->dev, \"freq_min = %d, freq_max = %d\\n\",\n\t\t*fmin, *fmax);\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_set_speed(struct dln2_spi *dln2, u32 speed)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t\t__le32 speed;\n\t} __packed tx;\n\tstruct {\n\t\t__le32 speed;\n\t} rx;\n\tint rx_len = sizeof(rx);\n\n\ttx.port = dln2->port;\n\ttx.speed = cpu_to_le32(speed);\n\n\tret = dln2_transfer(dln2->pdev, DLN2_SPI_SET_FREQUENCY, &tx, sizeof(tx),\n\t\t\t    &rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_set_mode(struct dln2_spi *dln2, u8 mode)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 mode;\n\t} tx;\n\n\ttx.port = dln2->port;\n\ttx.mode = mode;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));\n}\n\n \nstatic int dln2_spi_set_bpw(struct dln2_spi *dln2, u8 bpw)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 bpw;\n\t} tx;\n\n\ttx.port = dln2->port;\n\ttx.bpw = bpw;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_FRAME_SIZE,\n\t\t\t\t&tx, sizeof(tx));\n}\n\nstatic int dln2_spi_get_supported_frame_sizes(struct dln2_spi *dln2,\n\t\t\t\t\t      u32 *bpw_mask)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t} tx;\n\tstruct {\n\t\tu8 count;\n\t\tu8 frame_sizes[36];\n\t} *rx = dln2->buf;\n\tunsigned rx_len = sizeof(*rx);\n\tint i;\n\n\ttx.port = dln2->port;\n\n\tret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SUPPORTED_FRAME_SIZES,\n\t\t\t    &tx, sizeof(tx), rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(*rx))\n\t\treturn -EPROTO;\n\tif (rx->count > ARRAY_SIZE(rx->frame_sizes))\n\t\treturn -EPROTO;\n\n\t*bpw_mask = 0;\n\tfor (i = 0; i < rx->count; i++)\n\t\t*bpw_mask |= BIT(rx->frame_sizes[i] - 1);\n\n\tdev_dbg(&dln2->pdev->dev, \"bpw_mask = 0x%X\\n\", *bpw_mask);\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_copy_to_buf(u8 *dln2_buf, const u8 *src, u16 len, u8 bpw)\n{\n#ifdef __LITTLE_ENDIAN\n\tmemcpy(dln2_buf, src, len);\n#else\n\tif (bpw <= 8) {\n\t\tmemcpy(dln2_buf, src, len);\n\t} else if (bpw <= 16) {\n\t\t__le16 *d = (__le16 *)dln2_buf;\n\t\tu16 *s = (u16 *)src;\n\n\t\tlen = len / 2;\n\t\twhile (len--)\n\t\t\t*d++ = cpu_to_le16p(s++);\n\t} else {\n\t\t__le32 *d = (__le32 *)dln2_buf;\n\t\tu32 *s = (u32 *)src;\n\n\t\tlen = len / 4;\n\t\twhile (len--)\n\t\t\t*d++ = cpu_to_le32p(s++);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_copy_from_buf(u8 *dest, const u8 *dln2_buf, u16 len, u8 bpw)\n{\n#ifdef __LITTLE_ENDIAN\n\tmemcpy(dest, dln2_buf, len);\n#else\n\tif (bpw <= 8) {\n\t\tmemcpy(dest, dln2_buf, len);\n\t} else if (bpw <= 16) {\n\t\tu16 *d = (u16 *)dest;\n\t\t__le16 *s = (__le16 *)dln2_buf;\n\n\t\tlen = len / 2;\n\t\twhile (len--)\n\t\t\t*d++ = le16_to_cpup(s++);\n\t} else {\n\t\tu32 *d = (u32 *)dest;\n\t\t__le32 *s = (__le32 *)dln2_buf;\n\n\t\tlen = len / 4;\n\t\twhile (len--)\n\t\t\t*d++ = get_unaligned_le32(s++);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_write_one(struct dln2_spi *dln2, const u8 *data,\n\t\t\t      u16 data_len, u8 attr)\n{\n\tstruct {\n\t\tu8 port;\n\t\t__le16 size;\n\t\tu8 attr;\n\t\tu8 buf[DLN2_SPI_MAX_XFER_SIZE];\n\t} __packed *tx = dln2->buf;\n\tunsigned tx_len;\n\n\tBUILD_BUG_ON(sizeof(*tx) > DLN2_SPI_BUF_SIZE);\n\n\tif (data_len > DLN2_SPI_MAX_XFER_SIZE)\n\t\treturn -EINVAL;\n\n\ttx->port = dln2->port;\n\ttx->size = cpu_to_le16(data_len);\n\ttx->attr = attr;\n\n\tdln2_spi_copy_to_buf(tx->buf, data, data_len, dln2->bpw);\n\n\ttx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_WRITE, tx, tx_len);\n}\n\n \nstatic int dln2_spi_read_one(struct dln2_spi *dln2, u8 *data,\n\t\t\t     u16 data_len, u8 attr)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t\t__le16 size;\n\t\tu8 attr;\n\t} __packed tx;\n\tstruct {\n\t\t__le16 size;\n\t\tu8 buf[DLN2_SPI_MAX_XFER_SIZE];\n\t} __packed *rx = dln2->buf;\n\tunsigned rx_len = sizeof(*rx);\n\n\tBUILD_BUG_ON(sizeof(*rx) > DLN2_SPI_BUF_SIZE);\n\n\tif (data_len > DLN2_SPI_MAX_XFER_SIZE)\n\t\treturn -EINVAL;\n\n\ttx.port = dln2->port;\n\ttx.size = cpu_to_le16(data_len);\n\ttx.attr = attr;\n\n\tret = dln2_transfer(dln2->pdev, DLN2_SPI_READ, &tx, sizeof(tx),\n\t\t\t    rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx->size) + data_len)\n\t\treturn -EPROTO;\n\tif (le16_to_cpu(rx->size) != data_len)\n\t\treturn -EPROTO;\n\n\tdln2_spi_copy_from_buf(data, rx->buf, data_len, dln2->bpw);\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_read_write_one(struct dln2_spi *dln2, const u8 *tx_data,\n\t\t\t\t   u8 *rx_data, u16 data_len, u8 attr)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t\t__le16 size;\n\t\tu8 attr;\n\t\tu8 buf[DLN2_SPI_MAX_XFER_SIZE];\n\t} __packed *tx;\n\tstruct {\n\t\t__le16 size;\n\t\tu8 buf[DLN2_SPI_MAX_XFER_SIZE];\n\t} __packed *rx;\n\tunsigned tx_len, rx_len;\n\n\tBUILD_BUG_ON(sizeof(*tx) > DLN2_SPI_BUF_SIZE ||\n\t\t     sizeof(*rx) > DLN2_SPI_BUF_SIZE);\n\n\tif (data_len > DLN2_SPI_MAX_XFER_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\ttx = dln2->buf;\n\trx = dln2->buf;\n\n\ttx->port = dln2->port;\n\ttx->size = cpu_to_le16(data_len);\n\ttx->attr = attr;\n\n\tdln2_spi_copy_to_buf(tx->buf, tx_data, data_len, dln2->bpw);\n\n\ttx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;\n\trx_len = sizeof(*rx);\n\n\tret = dln2_transfer(dln2->pdev, DLN2_SPI_READ_WRITE, tx, tx_len,\n\t\t\t    rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx->size) + data_len)\n\t\treturn -EPROTO;\n\tif (le16_to_cpu(rx->size) != data_len)\n\t\treturn -EPROTO;\n\n\tdln2_spi_copy_from_buf(rx_data, rx->buf, data_len, dln2->bpw);\n\n\treturn 0;\n}\n\n \nstatic int dln2_spi_rdwr(struct dln2_spi *dln2, const u8 *tx_data,\n\t\t\t u8 *rx_data, u16 data_len, u8 attr)\n{\n\tint ret;\n\tu16 len;\n\tu8 temp_attr;\n\tu16 remaining = data_len;\n\tu16 offset;\n\n\tdo {\n\t\tif (remaining > DLN2_SPI_MAX_XFER_SIZE) {\n\t\t\tlen = DLN2_SPI_MAX_XFER_SIZE;\n\t\t\ttemp_attr = DLN2_SPI_ATTR_LEAVE_SS_LOW;\n\t\t} else {\n\t\t\tlen = remaining;\n\t\t\ttemp_attr = attr;\n\t\t}\n\n\t\toffset = data_len - remaining;\n\n\t\tif (tx_data && rx_data) {\n\t\t\tret = dln2_spi_read_write_one(dln2,\n\t\t\t\t\t\t      tx_data + offset,\n\t\t\t\t\t\t      rx_data + offset,\n\t\t\t\t\t\t      len, temp_attr);\n\t\t} else if (tx_data) {\n\t\t\tret = dln2_spi_write_one(dln2,\n\t\t\t\t\t\t tx_data + offset,\n\t\t\t\t\t\t len, temp_attr);\n\t\t} else if (rx_data) {\n\t\t\tret = dln2_spi_read_one(dln2,\n\t\t\t\t\t\trx_data + offset,\n\t\t\t\t\t\tlen, temp_attr);\n\t\t } else {\n\t\t\treturn -EINVAL;\n\t\t }\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tremaining -= len;\n\t} while (remaining);\n\n\treturn 0;\n}\n\nstatic int dln2_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t    struct spi_message *message)\n{\n\tint ret;\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = message->spi;\n\n\tif (dln2->cs != spi_get_chipselect(spi, 0)) {\n\t\tret = dln2_spi_cs_set_one(dln2, spi_get_chipselect(spi, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdln2->cs = spi_get_chipselect(spi, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int dln2_spi_transfer_setup(struct dln2_spi *dln2, u32 speed,\n\t\t\t\t   u8 bpw, u8 mode)\n{\n\tint ret;\n\tbool bus_setup_change;\n\n\tbus_setup_change = dln2->speed != speed || dln2->mode != mode ||\n\t\t\t   dln2->bpw != bpw;\n\n\tif (!bus_setup_change)\n\t\treturn 0;\n\n\tret = dln2_spi_enable(dln2, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dln2->speed != speed) {\n\t\tret = dln2_spi_set_speed(dln2, speed);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdln2->speed = speed;\n\t}\n\n\tif (dln2->mode != mode) {\n\t\tret = dln2_spi_set_mode(dln2, mode & 0x3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdln2->mode = mode;\n\t}\n\n\tif (dln2->bpw != bpw) {\n\t\tret = dln2_spi_set_bpw(dln2, bpw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdln2->bpw = bpw;\n\t}\n\n\treturn dln2_spi_enable(dln2, true);\n}\n\nstatic int dln2_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *xfer)\n{\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\tint status;\n\tu8 attr = 0;\n\n\tstatus = dln2_spi_transfer_setup(dln2, xfer->speed_hz,\n\t\t\t\t\t xfer->bits_per_word,\n\t\t\t\t\t spi->mode);\n\tif (status < 0) {\n\t\tdev_err(&dln2->pdev->dev, \"Cannot setup transfer\\n\");\n\t\treturn status;\n\t}\n\n\tif (!xfer->cs_change && !spi_transfer_is_last(host, xfer))\n\t\tattr = DLN2_SPI_ATTR_LEAVE_SS_LOW;\n\n\tstatus = dln2_spi_rdwr(dln2, xfer->tx_buf, xfer->rx_buf,\n\t\t\t       xfer->len, attr);\n\tif (status < 0)\n\t\tdev_err(&dln2->pdev->dev, \"write/read failed!\\n\");\n\n\treturn status;\n}\n\nstatic int dln2_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct dln2_spi *dln2;\n\tstruct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*dln2));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tdevice_set_node(&host->dev, dev_fwnode(dev));\n\n\tplatform_set_drvdata(pdev, host);\n\n\tdln2 = spi_controller_get_devdata(host);\n\n\tdln2->buf = devm_kmalloc(&pdev->dev, DLN2_SPI_BUF_SIZE, GFP_KERNEL);\n\tif (!dln2->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_free_host;\n\t}\n\n\tdln2->host = host;\n\tdln2->pdev = pdev;\n\tdln2->port = pdata->port;\n\t \n\tdln2->cs = 0xff;\n\tdln2->mode = 0xff;\n\n\t \n\tret = dln2_spi_enable(dln2, false);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to disable SPI module\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\tret = dln2_spi_get_cs_num(dln2, &host->num_chipselect);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get number of CS pins\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\tret = dln2_spi_get_speed_range(dln2,\n\t\t\t\t       &host->min_speed_hz,\n\t\t\t\t       &host->max_speed_hz);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to read bus min/max freqs\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\tret = dln2_spi_get_supported_frame_sizes(dln2,\n\t\t\t\t\t\t &host->bits_per_word_mask);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to read supported frame sizes\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\tret = dln2_spi_cs_enable_all(dln2, true);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable CS pins\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\thost->bus_num = -1;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA;\n\thost->prepare_message = dln2_spi_prepare_message;\n\thost->transfer_one = dln2_spi_transfer_one;\n\thost->auto_runtime_pm = true;\n\n\t \n\tret = dln2_spi_enable(dln2, true);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable SPI module\\n\");\n\t\tgoto exit_free_host;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t DLN2_RPM_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register host\\n\");\n\t\tgoto exit_register;\n\t}\n\n\treturn ret;\n\nexit_register:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tif (dln2_spi_enable(dln2, false) < 0)\n\t\tdev_err(&pdev->dev, \"Failed to disable SPI module\\n\");\nexit_free_host:\n\tspi_controller_put(host);\n\n\treturn ret;\n}\n\nstatic void dln2_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (dln2_spi_enable(dln2, false) < 0)\n\t\tdev_err(&pdev->dev, \"Failed to disable SPI module\\n\");\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dln2_spi_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\n\tret = spi_controller_suspend(host);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = dln2_spi_enable(dln2, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdln2->cs = 0xff;\n\tdln2->speed = 0;\n\tdln2->bpw = 0;\n\tdln2->mode = 0xff;\n\n\treturn 0;\n}\n\nstatic int dln2_spi_resume(struct device *dev)\n{\n\tint ret;\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = dln2_spi_cs_enable_all(dln2, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = dln2_spi_enable(dln2, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn spi_controller_resume(host);\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int dln2_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\n\treturn dln2_spi_enable(dln2, false);\n}\n\nstatic int dln2_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct dln2_spi *dln2 = spi_controller_get_devdata(host);\n\n\treturn  dln2_spi_enable(dln2, true);\n}\n#endif  \n\nstatic const struct dev_pm_ops dln2_spi_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dln2_spi_suspend, dln2_spi_resume)\n\tSET_RUNTIME_PM_OPS(dln2_spi_runtime_suspend,\n\t\t\t   dln2_spi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver spi_dln2_driver = {\n\t.driver = {\n\t\t.name\t= \"dln2-spi\",\n\t\t.pm\t= &dln2_spi_pm,\n\t},\n\t.probe\t\t= dln2_spi_probe,\n\t.remove_new\t= dln2_spi_remove,\n};\nmodule_platform_driver(spi_dln2_driver);\n\nMODULE_DESCRIPTION(\"Driver for the Diolan DLN2 SPI host interface\");\nMODULE_AUTHOR(\"Laurentiu Palcu <laurentiu.palcu@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dln2-spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}