{
  "module_name": "spi-sh-sci.c",
  "hash_id": "e1650685f91279e8fa9f5b6df357a9033844dd866c6b7d0ac115b1dbc767caa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sh-sci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/module.h>\n\n#include <asm/spi.h>\n#include <asm/io.h>\n\nstruct sh_sci_spi {\n\tstruct spi_bitbang bitbang;\n\n\tvoid __iomem *membase;\n\tunsigned char val;\n\tstruct sh_spi_info *info;\n\tstruct platform_device *dev;\n};\n\n#define SCSPTR(sp)\t(sp->membase + 0x1c)\n#define PIN_SCK\t\t(1 << 2)\n#define PIN_TXD\t\t(1 << 0)\n#define PIN_RXD\t\tPIN_TXD\n#define PIN_INIT\t((1 << 1) | (1 << 3) | PIN_SCK | PIN_TXD)\n\nstatic inline void setbits(struct sh_sci_spi *sp, int bits, int on)\n{\n\t \n\n\tif (on)\n\t\tsp->val |= bits;\n\telse\n\t\tsp->val &= ~bits;\n\n\tiowrite8(sp->val, SCSPTR(sp));\n}\n\nstatic inline void setsck(struct spi_device *dev, int on)\n{\n\tsetbits(spi_controller_get_devdata(dev->controller), PIN_SCK, on);\n}\n\nstatic inline void setmosi(struct spi_device *dev, int on)\n{\n\tsetbits(spi_controller_get_devdata(dev->controller), PIN_TXD, on);\n}\n\nstatic inline u32 getmiso(struct spi_device *dev)\n{\n\tstruct sh_sci_spi *sp = spi_controller_get_devdata(dev->controller);\n\n\treturn (ioread8(SCSPTR(sp)) & PIN_RXD) ? 1 : 0;\n}\n\n#define spidelay(x) ndelay(x)\n\n#include \"spi-bitbang-txrx.h\"\n\nstatic u32 sh_sci_spi_txrx_mode0(struct spi_device *spi,\n\t\t\t\t unsigned nsecs, u32 word, u8 bits,\n\t\t\t\t unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 sh_sci_spi_txrx_mode1(struct spi_device *spi,\n\t\t\t\t unsigned nsecs, u32 word, u8 bits,\n\t\t\t\t unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 sh_sci_spi_txrx_mode2(struct spi_device *spi,\n\t\t\t\t unsigned nsecs, u32 word, u8 bits,\n\t\t\t\t unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 sh_sci_spi_txrx_mode3(struct spi_device *spi,\n\t\t\t\t unsigned nsecs, u32 word, u8 bits,\n\t\t\t\t unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic void sh_sci_spi_chipselect(struct spi_device *dev, int value)\n{\n\tstruct sh_sci_spi *sp = spi_controller_get_devdata(dev->controller);\n\n\tif (sp->info->chip_select)\n\t\t(sp->info->chip_select)(sp->info, spi_get_chipselect(dev, 0), value);\n}\n\nstatic int sh_sci_spi_probe(struct platform_device *dev)\n{\n\tstruct resource\t*r;\n\tstruct spi_controller *host;\n\tstruct sh_sci_spi *sp;\n\tint ret;\n\n\thost = spi_alloc_host(&dev->dev, sizeof(struct sh_sci_spi));\n\tif (host == NULL) {\n\t\tdev_err(&dev->dev, \"failed to allocate spi host\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tsp = spi_controller_get_devdata(host);\n\n\tplatform_set_drvdata(dev, sp);\n\tsp->info = dev_get_platdata(&dev->dev);\n\tif (!sp->info) {\n\t\tdev_err(&dev->dev, \"platform data is missing\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err1;\n\t}\n\n\t \n\tsp->bitbang.master = host;\n\tsp->bitbang.master->bus_num = sp->info->bus_num;\n\tsp->bitbang.master->num_chipselect = sp->info->num_chipselect;\n\tsp->bitbang.chipselect = sh_sci_spi_chipselect;\n\n\tsp->bitbang.txrx_word[SPI_MODE_0] = sh_sci_spi_txrx_mode0;\n\tsp->bitbang.txrx_word[SPI_MODE_1] = sh_sci_spi_txrx_mode1;\n\tsp->bitbang.txrx_word[SPI_MODE_2] = sh_sci_spi_txrx_mode2;\n\tsp->bitbang.txrx_word[SPI_MODE_3] = sh_sci_spi_txrx_mode3;\n\n\tr = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (r == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto err1;\n\t}\n\tsp->membase = ioremap(r->start, resource_size(r));\n\tif (!sp->membase) {\n\t\tret = -ENXIO;\n\t\tgoto err1;\n\t}\n\tsp->val = ioread8(SCSPTR(sp));\n\tsetbits(sp, PIN_INIT, 1);\n\n\tret = spi_bitbang_start(&sp->bitbang);\n\tif (!ret)\n\t\treturn 0;\n\n\tsetbits(sp, PIN_INIT, 0);\n\tiounmap(sp->membase);\n err1:\n\tspi_controller_put(sp->bitbang.master);\n err0:\n\treturn ret;\n}\n\nstatic void sh_sci_spi_remove(struct platform_device *dev)\n{\n\tstruct sh_sci_spi *sp = platform_get_drvdata(dev);\n\n\tspi_bitbang_stop(&sp->bitbang);\n\tsetbits(sp, PIN_INIT, 0);\n\tiounmap(sp->membase);\n\tspi_controller_put(sp->bitbang.master);\n}\n\nstatic struct platform_driver sh_sci_spi_drv = {\n\t.probe\t\t= sh_sci_spi_probe,\n\t.remove_new\t= sh_sci_spi_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"spi_sh_sci\",\n\t},\n};\nmodule_platform_driver(sh_sci_spi_drv);\n\nMODULE_DESCRIPTION(\"SH SCI SPI Driver\");\nMODULE_AUTHOR(\"Magnus Damm <damm@opensource.se>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:spi_sh_sci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}