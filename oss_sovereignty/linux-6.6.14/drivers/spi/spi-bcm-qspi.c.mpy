{
  "module_name": "spi-bcm-qspi.c",
  "hash_id": "c89b3c78f25036c25458809fc465ee0562c5b40500034ee4512c2af9d732f947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include \"spi-bcm-qspi.h\"\n\n#define DRIVER_NAME \"bcm_qspi\"\n\n\n \n#define BSPI_REVISION_ID\t\t\t0x000\n#define BSPI_SCRATCH\t\t\t\t0x004\n#define BSPI_MAST_N_BOOT_CTRL\t\t\t0x008\n#define BSPI_BUSY_STATUS\t\t\t0x00c\n#define BSPI_INTR_STATUS\t\t\t0x010\n#define BSPI_B0_STATUS\t\t\t\t0x014\n#define BSPI_B0_CTRL\t\t\t\t0x018\n#define BSPI_B1_STATUS\t\t\t\t0x01c\n#define BSPI_B1_CTRL\t\t\t\t0x020\n#define BSPI_STRAP_OVERRIDE_CTRL\t\t0x024\n#define BSPI_FLEX_MODE_ENABLE\t\t\t0x028\n#define BSPI_BITS_PER_CYCLE\t\t\t0x02c\n#define BSPI_BITS_PER_PHASE\t\t\t0x030\n#define BSPI_CMD_AND_MODE_BYTE\t\t\t0x034\n#define BSPI_BSPI_FLASH_UPPER_ADDR_BYTE\t0x038\n#define BSPI_BSPI_XOR_VALUE\t\t\t0x03c\n#define BSPI_BSPI_XOR_ENABLE\t\t\t0x040\n#define BSPI_BSPI_PIO_MODE_ENABLE\t\t0x044\n#define BSPI_BSPI_PIO_IODIR\t\t\t0x048\n#define BSPI_BSPI_PIO_DATA\t\t\t0x04c\n\n \n#define BSPI_RAF_START_ADDR\t\t\t0x100\n#define BSPI_RAF_NUM_WORDS\t\t\t0x104\n#define BSPI_RAF_CTRL\t\t\t\t0x108\n#define BSPI_RAF_FULLNESS\t\t\t0x10c\n#define BSPI_RAF_WATERMARK\t\t\t0x110\n#define BSPI_RAF_STATUS\t\t\t0x114\n#define BSPI_RAF_READ_DATA\t\t\t0x118\n#define BSPI_RAF_WORD_CNT\t\t\t0x11c\n#define BSPI_RAF_CURR_ADDR\t\t\t0x120\n\n \n#define BSPI_STRAP_OVERRIDE_CTRL_OVERRIDE\tBIT(0)\n#define BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL\tBIT(1)\n#define BSPI_STRAP_OVERRIDE_CTRL_ADDR_4BYTE\tBIT(2)\n#define BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD\tBIT(3)\n#define BSPI_STRAP_OVERRIDE_CTRL_ENDAIN_MODE\tBIT(4)\n\n#define BSPI_ADDRLEN_3BYTES\t\t\t3\n#define BSPI_ADDRLEN_4BYTES\t\t\t4\n\n#define BSPI_RAF_STATUS_FIFO_EMPTY_MASK\tBIT(1)\n\n#define BSPI_RAF_CTRL_START_MASK\t\tBIT(0)\n#define BSPI_RAF_CTRL_CLEAR_MASK\t\tBIT(1)\n\n#define BSPI_BPP_MODE_SELECT_MASK\t\tBIT(8)\n#define BSPI_BPP_ADDR_SELECT_MASK\t\tBIT(16)\n\n#define BSPI_READ_LENGTH\t\t\t256\n\n \n#define MSPI_SPCR0_LSB\t\t\t\t0x000\n#define MSPI_SPCR0_MSB\t\t\t\t0x004\n#define MSPI_SPCR0_MSB_CPHA\t\t\tBIT(0)\n#define MSPI_SPCR0_MSB_CPOL\t\t\tBIT(1)\n#define MSPI_SPCR0_MSB_BITS_SHIFT\t\t0x2\n#define MSPI_SPCR1_LSB\t\t\t\t0x008\n#define MSPI_SPCR1_MSB\t\t\t\t0x00c\n#define MSPI_NEWQP\t\t\t\t0x010\n#define MSPI_ENDQP\t\t\t\t0x014\n#define MSPI_SPCR2\t\t\t\t0x018\n#define MSPI_MSPI_STATUS\t\t\t0x020\n#define MSPI_CPTQP\t\t\t\t0x024\n#define MSPI_SPCR3\t\t\t\t0x028\n#define MSPI_REV\t\t\t\t0x02c\n#define MSPI_TXRAM\t\t\t\t0x040\n#define MSPI_RXRAM\t\t\t\t0x0c0\n#define MSPI_CDRAM\t\t\t\t0x140\n#define MSPI_WRITE_LOCK\t\t\t0x180\n\n#define MSPI_MASTER_BIT\t\t\tBIT(7)\n\n#define MSPI_NUM_CDRAM\t\t\t\t16\n#define MSPI_CDRAM_OUTP\t\t\t\tBIT(8)\n#define MSPI_CDRAM_CONT_BIT\t\t\tBIT(7)\n#define MSPI_CDRAM_BITSE_BIT\t\t\tBIT(6)\n#define MSPI_CDRAM_DT_BIT\t\t\tBIT(5)\n#define MSPI_CDRAM_PCS\t\t\t\t0xf\n\n#define MSPI_SPCR2_SPE\t\t\t\tBIT(6)\n#define MSPI_SPCR2_CONT_AFTER_CMD\t\tBIT(7)\n\n#define MSPI_SPCR3_FASTBR\t\t\tBIT(0)\n#define MSPI_SPCR3_FASTDT\t\t\tBIT(1)\n#define MSPI_SPCR3_SYSCLKSEL_MASK\t\tGENMASK(11, 10)\n#define MSPI_SPCR3_SYSCLKSEL_27\t\t\t(MSPI_SPCR3_SYSCLKSEL_MASK & \\\n\t\t\t\t\t\t ~(BIT(10) | BIT(11)))\n#define MSPI_SPCR3_SYSCLKSEL_108\t\t(MSPI_SPCR3_SYSCLKSEL_MASK & \\\n\t\t\t\t\t\t BIT(11))\n#define MSPI_SPCR3_TXRXDAM_MASK\t\t\tGENMASK(4, 2)\n#define MSPI_SPCR3_DAM_8BYTE\t\t\t0\n#define MSPI_SPCR3_DAM_16BYTE\t\t\t(BIT(2) | BIT(4))\n#define MSPI_SPCR3_DAM_32BYTE\t\t\t(BIT(3) | BIT(5))\n#define MSPI_SPCR3_HALFDUPLEX\t\t\tBIT(6)\n#define MSPI_SPCR3_HDOUTTYPE\t\t\tBIT(7)\n#define MSPI_SPCR3_DATA_REG_SZ\t\t\tBIT(8)\n#define MSPI_SPCR3_CPHARX\t\t\tBIT(9)\n\n#define MSPI_MSPI_STATUS_SPIF\t\t\tBIT(0)\n\n#define INTR_BASE_BIT_SHIFT\t\t\t0x02\n#define INTR_COUNT\t\t\t\t0x07\n\n#define NUM_CHIPSELECT\t\t\t\t4\n#define QSPI_SPBR_MAX\t\t\t\t255U\n#define MSPI_BASE_FREQ\t\t\t\t27000000UL\n\n#define OPCODE_DIOR\t\t\t\t0xBB\n#define OPCODE_QIOR\t\t\t\t0xEB\n#define OPCODE_DIOR_4B\t\t\t\t0xBC\n#define OPCODE_QIOR_4B\t\t\t\t0xEC\n\n#define MAX_CMD_SIZE\t\t\t\t6\n\n#define ADDR_4MB_MASK\t\t\t\tGENMASK(22, 0)\n\n \n#define TRANS_STATUS_BREAK_NONE\t\t0\n \n#define TRANS_STATUS_BREAK_EOM\t\t\t1\n \n#define TRANS_STATUS_BREAK_DELAY\t\t2\n \n#define TRANS_STATUS_BREAK_CS_CHANGE\t\t4\n \n#define TRANS_STATUS_BREAK_NO_BYTES\t\t8\n\n \n#define TRANS_STATUS_BREAK_TX (TRANS_STATUS_BREAK_EOM |\t\t\\\n\t\t\t       TRANS_STATUS_BREAK_DELAY |\t\t\\\n\t\t\t       TRANS_STATUS_BREAK_CS_CHANGE)\n\n \n#define TRANS_STATUS_BREAK_DESELECT (TRANS_STATUS_BREAK_EOM |\t\t\\\n\t\t\t\t     TRANS_STATUS_BREAK_CS_CHANGE)\n\n \n#define swap4bytes(__val) \\\n\t((((__val) >> 24) & 0x000000FF) | (((__val) >>  8) & 0x0000FF00) | \\\n\t (((__val) <<  8) & 0x00FF0000) | (((__val) << 24) & 0xFF000000))\n\nstruct bcm_qspi_parms {\n\tu32 speed_hz;\n\tu8 mode;\n\tu8 bits_per_word;\n};\n\nstruct bcm_xfer_mode {\n\tbool flex_mode;\n\tunsigned int width;\n\tunsigned int addrlen;\n\tunsigned int hp;\n};\n\nenum base_type {\n\tMSPI,\n\tBSPI,\n\tCHIP_SELECT,\n\tBASEMAX,\n};\n\nenum irq_source {\n\tSINGLE_L2,\n\tMUXED_L1,\n};\n\nstruct bcm_qspi_irq {\n\tconst char *irq_name;\n\tconst irq_handler_t irq_handler;\n\tint irq_source;\n\tu32 mask;\n};\n\nstruct bcm_qspi_dev_id {\n\tconst struct bcm_qspi_irq *irqp;\n\tvoid *dev;\n};\n\n\nstruct qspi_trans {\n\tstruct spi_transfer *trans;\n\tint byte;\n\tbool mspi_last_trans;\n};\n\nstruct bcm_qspi {\n\tstruct platform_device *pdev;\n\tstruct spi_controller *host;\n\tstruct clk *clk;\n\tu32 base_clk;\n\tu32 max_speed_hz;\n\tvoid __iomem *base[BASEMAX];\n\n\t \n\tstruct bcm_qspi_soc_intc\t*soc_intc;\n\n\tstruct bcm_qspi_parms last_parms;\n\tstruct qspi_trans  trans_pos;\n\tint curr_cs;\n\tint bspi_maj_rev;\n\tint bspi_min_rev;\n\tint bspi_enabled;\n\tconst struct spi_mem_op *bspi_rf_op;\n\tu32 bspi_rf_op_idx;\n\tu32 bspi_rf_op_len;\n\tu32 bspi_rf_op_status;\n\tstruct bcm_xfer_mode xfer_mode;\n\tu32 s3_strap_override_ctrl;\n\tbool bspi_mode;\n\tbool big_endian;\n\tint num_irqs;\n\tstruct bcm_qspi_dev_id *dev_ids;\n\tstruct completion mspi_done;\n\tstruct completion bspi_done;\n\tu8 mspi_maj_rev;\n\tu8 mspi_min_rev;\n\tbool mspi_spcr3_sysclk;\n};\n\nstatic inline bool has_bspi(struct bcm_qspi *qspi)\n{\n\treturn qspi->bspi_mode;\n}\n\n \nstatic inline bool bcm_qspi_has_fastbr(struct bcm_qspi *qspi)\n{\n\tif (!has_bspi(qspi) &&\n\t    ((qspi->mspi_maj_rev >= 1) &&\n\t     (qspi->mspi_min_rev >= 5)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline bool bcm_qspi_has_sysclk_108(struct bcm_qspi *qspi)\n{\n\tif (!has_bspi(qspi) && (qspi->mspi_spcr3_sysclk ||\n\t    ((qspi->mspi_maj_rev >= 1) &&\n\t     (qspi->mspi_min_rev >= 6))))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline int bcm_qspi_spbr_min(struct bcm_qspi *qspi)\n{\n\tif (bcm_qspi_has_fastbr(qspi))\n\t\treturn (bcm_qspi_has_sysclk_108(qspi) ? 4 : 1);\n\telse\n\t\treturn 8;\n}\n\nstatic u32 bcm_qspi_calc_spbr(u32 clk_speed_hz,\n\t\t\t      const struct bcm_qspi_parms *xp)\n{\n\tu32 spbr = 0;\n\n\t \n\tif (xp->speed_hz)\n\t\tspbr = clk_speed_hz / (xp->speed_hz * 2);\n\n\treturn spbr;\n}\n\n \nstatic inline u32 bcm_qspi_read(struct bcm_qspi *qspi, enum base_type type,\n\t\t\t\tunsigned int offset)\n{\n\treturn bcm_qspi_readl(qspi->big_endian, qspi->base[type] + offset);\n}\n\n \nstatic inline void bcm_qspi_write(struct bcm_qspi *qspi, enum base_type type,\n\t\t\t\t  unsigned int offset, unsigned int data)\n{\n\tbcm_qspi_writel(qspi->big_endian, data, qspi->base[type] + offset);\n}\n\n \nstatic int bcm_qspi_bspi_busy_poll(struct bcm_qspi *qspi)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tif (!(bcm_qspi_read(qspi, BSPI, BSPI_BUSY_STATUS) & 1))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\tdev_warn(&qspi->pdev->dev, \"timeout waiting for !busy_status\\n\");\n\treturn -EIO;\n}\n\nstatic inline bool bcm_qspi_bspi_ver_three(struct bcm_qspi *qspi)\n{\n\tif (qspi->bspi_maj_rev < 4)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void bcm_qspi_bspi_flush_prefetch_buffers(struct bcm_qspi *qspi)\n{\n\tbcm_qspi_bspi_busy_poll(qspi);\n\t \n\tbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 1);\n\tbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 1);\n\tbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 0);\n\tbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 0);\n}\n\nstatic int bcm_qspi_bspi_lr_is_fifo_empty(struct bcm_qspi *qspi)\n{\n\treturn (bcm_qspi_read(qspi, BSPI, BSPI_RAF_STATUS) &\n\t\t\t\tBSPI_RAF_STATUS_FIFO_EMPTY_MASK);\n}\n\nstatic inline u32 bcm_qspi_bspi_lr_read_fifo(struct bcm_qspi *qspi)\n{\n\tu32 data = bcm_qspi_read(qspi, BSPI, BSPI_RAF_READ_DATA);\n\n\t \n\tif (bcm_qspi_bspi_ver_three(qspi))\n\t\tdata = le32_to_cpu(data);\n\n\treturn data;\n}\n\nstatic inline void bcm_qspi_bspi_lr_start(struct bcm_qspi *qspi)\n{\n\tbcm_qspi_bspi_busy_poll(qspi);\n\tbcm_qspi_write(qspi, BSPI, BSPI_RAF_CTRL,\n\t\t       BSPI_RAF_CTRL_START_MASK);\n}\n\nstatic inline void bcm_qspi_bspi_lr_clear(struct bcm_qspi *qspi)\n{\n\tbcm_qspi_write(qspi, BSPI, BSPI_RAF_CTRL,\n\t\t       BSPI_RAF_CTRL_CLEAR_MASK);\n\tbcm_qspi_bspi_flush_prefetch_buffers(qspi);\n}\n\nstatic void bcm_qspi_bspi_lr_data_read(struct bcm_qspi *qspi)\n{\n\tu32 *buf = (u32 *)qspi->bspi_rf_op->data.buf.in;\n\tu32 data = 0;\n\n\tdev_dbg(&qspi->pdev->dev, \"xfer %p rx %p rxlen %d\\n\", qspi->bspi_rf_op,\n\t\tqspi->bspi_rf_op->data.buf.in, qspi->bspi_rf_op_len);\n\twhile (!bcm_qspi_bspi_lr_is_fifo_empty(qspi)) {\n\t\tdata = bcm_qspi_bspi_lr_read_fifo(qspi);\n\t\tif (likely(qspi->bspi_rf_op_len >= 4) &&\n\t\t    IS_ALIGNED((uintptr_t)buf, 4)) {\n\t\t\tbuf[qspi->bspi_rf_op_idx++] = data;\n\t\t\tqspi->bspi_rf_op_len -= 4;\n\t\t} else {\n\t\t\t \n\t\t\tu8 *cbuf = (u8 *)&buf[qspi->bspi_rf_op_idx];\n\n\t\t\tdata = cpu_to_le32(data);\n\t\t\twhile (qspi->bspi_rf_op_len) {\n\t\t\t\t*cbuf++ = (u8)data;\n\t\t\t\tdata >>= 8;\n\t\t\t\tqspi->bspi_rf_op_len--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bcm_qspi_bspi_set_xfer_params(struct bcm_qspi *qspi, u8 cmd_byte,\n\t\t\t\t\t  int bpp, int bpc, int flex_mode)\n{\n\tbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE, 0);\n\tbcm_qspi_write(qspi, BSPI, BSPI_BITS_PER_CYCLE, bpc);\n\tbcm_qspi_write(qspi, BSPI, BSPI_BITS_PER_PHASE, bpp);\n\tbcm_qspi_write(qspi, BSPI, BSPI_CMD_AND_MODE_BYTE, cmd_byte);\n\tbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE, flex_mode);\n}\n\nstatic int bcm_qspi_bspi_set_flex_mode(struct bcm_qspi *qspi,\n\t\t\t\t       const struct spi_mem_op *op, int hp)\n{\n\tint bpc = 0, bpp = 0;\n\tu8 command = op->cmd.opcode;\n\tint width = op->data.buswidth ? op->data.buswidth : SPI_NBITS_SINGLE;\n\tint addrlen = op->addr.nbytes;\n\tint flex_mode = 1;\n\n\tdev_dbg(&qspi->pdev->dev, \"set flex mode w %x addrlen %x hp %d\\n\",\n\t\twidth, addrlen, hp);\n\n\tif (addrlen == BSPI_ADDRLEN_4BYTES)\n\t\tbpp = BSPI_BPP_ADDR_SELECT_MASK;\n\n\tif (op->dummy.nbytes)\n\t\tbpp |= (op->dummy.nbytes * 8) / op->dummy.buswidth;\n\n\tswitch (width) {\n\tcase SPI_NBITS_SINGLE:\n\t\tif (addrlen == BSPI_ADDRLEN_3BYTES)\n\t\t\t \n\t\t\tflex_mode = 0;\n\t\tbreak;\n\tcase SPI_NBITS_DUAL:\n\t\tbpc = 0x00000001;\n\t\tif (hp) {\n\t\t\tbpc |= 0x00010100;  \n\t\t\tbpp = BSPI_BPP_MODE_SELECT_MASK;\n\t\t}\n\t\tbreak;\n\tcase SPI_NBITS_QUAD:\n\t\tbpc = 0x00000002;\n\t\tif (hp) {\n\t\t\tbpc |= 0x00020200;  \n\t\t\tbpp |= BSPI_BPP_MODE_SELECT_MASK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbcm_qspi_bspi_set_xfer_params(qspi, command, bpp, bpc, flex_mode);\n\n\treturn 0;\n}\n\nstatic int bcm_qspi_bspi_set_override(struct bcm_qspi *qspi,\n\t\t\t\t      const struct spi_mem_op *op, int hp)\n{\n\tint width = op->data.buswidth ? op->data.buswidth : SPI_NBITS_SINGLE;\n\tint addrlen = op->addr.nbytes;\n\tu32 data = bcm_qspi_read(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL);\n\n\tdev_dbg(&qspi->pdev->dev, \"set override mode w %x addrlen %x hp %d\\n\",\n\t\twidth, addrlen, hp);\n\n\tswitch (width) {\n\tcase SPI_NBITS_SINGLE:\n\t\t \n\t\tdata &= ~(BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD |\n\t\t\t  BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL);\n\t\tbreak;\n\tcase SPI_NBITS_QUAD:\n\t\t \n\t\tdata &= ~BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL;\n\t\tdata |= BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD;\n\t\tbreak;\n\tcase SPI_NBITS_DUAL:\n\t\t \n\t\tdata &= ~BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD;\n\t\tdata |= BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (addrlen == BSPI_ADDRLEN_4BYTES)\n\t\t \n\t\tdata |= BSPI_STRAP_OVERRIDE_CTRL_ADDR_4BYTE;\n\telse\n\t\t \n\t\tdata &= ~BSPI_STRAP_OVERRIDE_CTRL_ADDR_4BYTE;\n\n\t \n\tdata |=\tBSPI_STRAP_OVERRIDE_CTRL_OVERRIDE;\n\tbcm_qspi_write(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL, data);\n\tbcm_qspi_bspi_set_xfer_params(qspi, op->cmd.opcode, 0, 0, 0);\n\n\treturn 0;\n}\n\nstatic int bcm_qspi_bspi_set_mode(struct bcm_qspi *qspi,\n\t\t\t\t  const struct spi_mem_op *op, int hp)\n{\n\tint error = 0;\n\tint width = op->data.buswidth ? op->data.buswidth : SPI_NBITS_SINGLE;\n\tint addrlen = op->addr.nbytes;\n\n\t \n\tqspi->xfer_mode.flex_mode = true;\n\n\tif (!bcm_qspi_bspi_ver_three(qspi)) {\n\t\tu32 val, mask;\n\n\t\tval = bcm_qspi_read(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL);\n\t\tmask = BSPI_STRAP_OVERRIDE_CTRL_OVERRIDE;\n\t\tif (val & mask || qspi->s3_strap_override_ctrl & mask) {\n\t\t\tqspi->xfer_mode.flex_mode = false;\n\t\t\tbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE, 0);\n\t\t\terror = bcm_qspi_bspi_set_override(qspi, op, hp);\n\t\t}\n\t}\n\n\tif (qspi->xfer_mode.flex_mode)\n\t\terror = bcm_qspi_bspi_set_flex_mode(qspi, op, hp);\n\n\tif (error) {\n\t\tdev_warn(&qspi->pdev->dev,\n\t\t\t \"INVALID COMBINATION: width=%d addrlen=%d hp=%d\\n\",\n\t\t\t width, addrlen, hp);\n\t} else if (qspi->xfer_mode.width != width ||\n\t\t   qspi->xfer_mode.addrlen != addrlen ||\n\t\t   qspi->xfer_mode.hp != hp) {\n\t\tqspi->xfer_mode.width = width;\n\t\tqspi->xfer_mode.addrlen = addrlen;\n\t\tqspi->xfer_mode.hp = hp;\n\t\tdev_dbg(&qspi->pdev->dev,\n\t\t\t\"cs:%d %d-lane output, %d-byte address%s\\n\",\n\t\t\tqspi->curr_cs,\n\t\t\tqspi->xfer_mode.width,\n\t\t\tqspi->xfer_mode.addrlen,\n\t\t\tqspi->xfer_mode.hp != -1 ? \", hp mode\" : \"\");\n\t}\n\n\treturn error;\n}\n\nstatic void bcm_qspi_enable_bspi(struct bcm_qspi *qspi)\n{\n\tif (!has_bspi(qspi))\n\t\treturn;\n\n\tqspi->bspi_enabled = 1;\n\tif ((bcm_qspi_read(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL) & 1) == 0)\n\t\treturn;\n\n\tbcm_qspi_bspi_flush_prefetch_buffers(qspi);\n\tudelay(1);\n\tbcm_qspi_write(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL, 0);\n\tudelay(1);\n}\n\nstatic void bcm_qspi_disable_bspi(struct bcm_qspi *qspi)\n{\n\tif (!has_bspi(qspi))\n\t\treturn;\n\n\tqspi->bspi_enabled = 0;\n\tif ((bcm_qspi_read(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL) & 1))\n\t\treturn;\n\n\tbcm_qspi_bspi_busy_poll(qspi);\n\tbcm_qspi_write(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL, 1);\n\tudelay(1);\n}\n\nstatic void bcm_qspi_chip_select(struct bcm_qspi *qspi, int cs)\n{\n\tu32 rd = 0;\n\tu32 wr = 0;\n\n\tif (cs >= 0 && qspi->base[CHIP_SELECT]) {\n\t\trd = bcm_qspi_read(qspi, CHIP_SELECT, 0);\n\t\twr = (rd & ~0xff) | (1 << cs);\n\t\tif (rd == wr)\n\t\t\treturn;\n\t\tbcm_qspi_write(qspi, CHIP_SELECT, 0, wr);\n\t\tusleep_range(10, 20);\n\t}\n\n\tdev_dbg(&qspi->pdev->dev, \"using cs:%d\\n\", cs);\n\tqspi->curr_cs = cs;\n}\n\nstatic bool bcmspi_parms_did_change(const struct bcm_qspi_parms * const cur,\n\t\t\t\t    const struct bcm_qspi_parms * const prev)\n{\n\treturn (cur->speed_hz != prev->speed_hz) ||\n\t\t(cur->mode != prev->mode) ||\n\t\t(cur->bits_per_word != prev->bits_per_word);\n}\n\n\n \nstatic void bcm_qspi_hw_set_parms(struct bcm_qspi *qspi,\n\t\t\t\t  const struct bcm_qspi_parms *xp)\n{\n\tu32 spcr, spbr = 0;\n\n\tif (!bcmspi_parms_did_change(xp, &qspi->last_parms))\n\t\treturn;\n\n\tif (!qspi->mspi_maj_rev)\n\t\t \n\t\tspcr = MSPI_MASTER_BIT;\n\telse\n\t\tspcr = 0;\n\n\t \n\tif (xp->bits_per_word != 16 && xp->bits_per_word != 64)\n\t\tspcr |= xp->bits_per_word << MSPI_SPCR0_MSB_BITS_SHIFT;\n\n\tspcr |= xp->mode & (MSPI_SPCR0_MSB_CPHA | MSPI_SPCR0_MSB_CPOL);\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR0_MSB, spcr);\n\n\tif (bcm_qspi_has_fastbr(qspi)) {\n\t\tspcr = 0;\n\n\t\t \n\t\tspcr |=\tMSPI_SPCR3_FASTBR;\n\n\t\tif (xp->mode & SPI_3WIRE)\n\t\t\tspcr |= MSPI_SPCR3_HALFDUPLEX |  MSPI_SPCR3_HDOUTTYPE;\n\n\t\tif (bcm_qspi_has_sysclk_108(qspi)) {\n\t\t\t \n\t\t\tspbr = bcm_qspi_calc_spbr(MSPI_BASE_FREQ * 4, xp);\n\t\t\tif (spbr > QSPI_SPBR_MAX) {\n\t\t\t\t \n\t\t\t\tspcr &= ~MSPI_SPCR3_SYSCLKSEL_MASK;\n\t\t\t\tqspi->base_clk = MSPI_BASE_FREQ;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspcr |= MSPI_SPCR3_SYSCLKSEL_108;\n\t\t\t\tqspi->base_clk = MSPI_BASE_FREQ * 4;\n\t\t\t}\n\t\t}\n\n\t\tif (xp->bits_per_word > 16) {\n\t\t\t \n\t\t\tspcr |=\tMSPI_SPCR3_DATA_REG_SZ;\n\t\t\t \n\t\t\tspcr |=\tMSPI_SPCR3_DAM_32BYTE  | MSPI_SPCR3_FASTDT;\n\t\t\t \n\t\t\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR1_LSB, 1);\n\t\t} else {\n\t\t\t \n\t\t\tspcr &=\t~(MSPI_SPCR3_DATA_REG_SZ);\n\n\t\t\t \n\t\t\tspcr &= ~(MSPI_SPCR3_DAM_32BYTE);\n\t\t}\n\t\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR3, spcr);\n\t}\n\n\t \n\tqspi->max_speed_hz = qspi->base_clk / (bcm_qspi_spbr_min(qspi) * 2);\n\tspbr = bcm_qspi_calc_spbr(qspi->base_clk, xp);\n\tspbr = clamp_val(spbr, bcm_qspi_spbr_min(qspi), QSPI_SPBR_MAX);\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR0_LSB, spbr);\n\n\tqspi->last_parms = *xp;\n}\n\nstatic void bcm_qspi_update_parms(struct bcm_qspi *qspi,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *trans)\n{\n\tstruct bcm_qspi_parms xp;\n\n\txp.speed_hz = trans->speed_hz;\n\txp.bits_per_word = trans->bits_per_word;\n\txp.mode = spi->mode;\n\n\tbcm_qspi_hw_set_parms(qspi, &xp);\n}\n\nstatic int bcm_qspi_setup(struct spi_device *spi)\n{\n\tstruct bcm_qspi_parms *xp;\n\n\tif (spi->bits_per_word > 64)\n\t\treturn -EINVAL;\n\n\txp = spi_get_ctldata(spi);\n\tif (!xp) {\n\t\txp = kzalloc(sizeof(*xp), GFP_KERNEL);\n\t\tif (!xp)\n\t\t\treturn -ENOMEM;\n\t\tspi_set_ctldata(spi, xp);\n\t}\n\txp->speed_hz = spi->max_speed_hz;\n\txp->mode = spi->mode;\n\n\tif (spi->bits_per_word)\n\t\txp->bits_per_word = spi->bits_per_word;\n\telse\n\t\txp->bits_per_word = 8;\n\n\treturn 0;\n}\n\nstatic bool bcm_qspi_mspi_transfer_is_last(struct bcm_qspi *qspi,\n\t\t\t\t\t   struct qspi_trans *qt)\n{\n\tif (qt->mspi_last_trans &&\n\t    spi_transfer_is_last(qspi->host, qt->trans))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int update_qspi_trans_byte_count(struct bcm_qspi *qspi,\n\t\t\t\t\tstruct qspi_trans *qt, int flags)\n{\n\tint ret = TRANS_STATUS_BREAK_NONE;\n\n\t \n\tif (qt->trans->bits_per_word <= 8)\n\t\tqt->byte++;\n\telse if (qt->trans->bits_per_word <= 16)\n\t\tqt->byte += 2;\n\telse if (qt->trans->bits_per_word <= 32)\n\t\tqt->byte += 4;\n\telse if (qt->trans->bits_per_word <= 64)\n\t\tqt->byte += 8;\n\n\tif (qt->byte >= qt->trans->len) {\n\t\t \n\t\t \n\t\tif (qt->trans->delay.value &&\n\t\t    (flags & TRANS_STATUS_BREAK_DELAY))\n\t\t\tret |= TRANS_STATUS_BREAK_DELAY;\n\t\tif (qt->trans->cs_change &&\n\t\t    (flags & TRANS_STATUS_BREAK_CS_CHANGE))\n\t\t\tret |= TRANS_STATUS_BREAK_CS_CHANGE;\n\n\t\tif (bcm_qspi_mspi_transfer_is_last(qspi, qt))\n\t\t\tret |= TRANS_STATUS_BREAK_EOM;\n\t\telse\n\t\t\tret |= TRANS_STATUS_BREAK_NO_BYTES;\n\n\t\tqt->trans = NULL;\n\t}\n\n\tdev_dbg(&qspi->pdev->dev, \"trans %p len %d byte %d ret %x\\n\",\n\t\tqt->trans, qt->trans ? qt->trans->len : 0, qt->byte, ret);\n\treturn ret;\n}\n\nstatic inline u8 read_rxram_slot_u8(struct bcm_qspi *qspi, int slot)\n{\n\tu32 slot_offset = MSPI_RXRAM + (slot << 3) + 0x4;\n\n\t \n\treturn bcm_qspi_read(qspi, MSPI, slot_offset) & 0xff;\n}\n\nstatic inline u16 read_rxram_slot_u16(struct bcm_qspi *qspi, int slot)\n{\n\tu32 reg_offset = MSPI_RXRAM;\n\tu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\n\tu32 msb_offset = reg_offset + (slot << 3);\n\n\treturn (bcm_qspi_read(qspi, MSPI, lsb_offset) & 0xff) |\n\t\t((bcm_qspi_read(qspi, MSPI, msb_offset) & 0xff) << 8);\n}\n\nstatic inline u32 read_rxram_slot_u32(struct bcm_qspi *qspi, int slot)\n{\n\tu32 reg_offset = MSPI_RXRAM;\n\tu32 offset = reg_offset + (slot << 3);\n\tu32 val;\n\n\tval = bcm_qspi_read(qspi, MSPI, offset);\n\tval = swap4bytes(val);\n\n\treturn val;\n}\n\nstatic inline u64 read_rxram_slot_u64(struct bcm_qspi *qspi, int slot)\n{\n\tu32 reg_offset = MSPI_RXRAM;\n\tu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\n\tu32 msb_offset = reg_offset + (slot << 3);\n\tu32 msb, lsb;\n\n\tmsb = bcm_qspi_read(qspi, MSPI, msb_offset);\n\tmsb = swap4bytes(msb);\n\tlsb = bcm_qspi_read(qspi, MSPI, lsb_offset);\n\tlsb = swap4bytes(lsb);\n\n\treturn ((u64)msb << 32 | lsb);\n}\n\nstatic void read_from_hw(struct bcm_qspi *qspi, int slots)\n{\n\tstruct qspi_trans tp;\n\tint slot;\n\n\tbcm_qspi_disable_bspi(qspi);\n\n\tif (slots > MSPI_NUM_CDRAM) {\n\t\t \n\t\tdev_err(&qspi->pdev->dev, \"%s: too many slots!\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttp = qspi->trans_pos;\n\n\tfor (slot = 0; slot < slots; slot++) {\n\t\tif (tp.trans->bits_per_word <= 8) {\n\t\t\tu8 *buf = tp.trans->rx_buf;\n\n\t\t\tif (buf)\n\t\t\t\tbuf[tp.byte] = read_rxram_slot_u8(qspi, slot);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"RD %02x\\n\",\n\t\t\t\tbuf ? buf[tp.byte] : 0x0);\n\t\t} else if (tp.trans->bits_per_word <= 16) {\n\t\t\tu16 *buf = tp.trans->rx_buf;\n\n\t\t\tif (buf)\n\t\t\t\tbuf[tp.byte / 2] = read_rxram_slot_u16(qspi,\n\t\t\t\t\t\t\t\t      slot);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"RD %04x\\n\",\n\t\t\t\tbuf ? buf[tp.byte / 2] : 0x0);\n\t\t} else if (tp.trans->bits_per_word <= 32) {\n\t\t\tu32 *buf = tp.trans->rx_buf;\n\n\t\t\tif (buf)\n\t\t\t\tbuf[tp.byte / 4] = read_rxram_slot_u32(qspi,\n\t\t\t\t\t\t\t\t      slot);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"RD %08x\\n\",\n\t\t\t\tbuf ? buf[tp.byte / 4] : 0x0);\n\n\t\t} else if (tp.trans->bits_per_word <= 64) {\n\t\t\tu64 *buf = tp.trans->rx_buf;\n\n\t\t\tif (buf)\n\t\t\t\tbuf[tp.byte / 8] = read_rxram_slot_u64(qspi,\n\t\t\t\t\t\t\t\t      slot);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"RD %llx\\n\",\n\t\t\t\tbuf ? buf[tp.byte / 8] : 0x0);\n\n\n\t\t}\n\n\t\tupdate_qspi_trans_byte_count(qspi, &tp,\n\t\t\t\t\t     TRANS_STATUS_BREAK_NONE);\n\t}\n\n\tqspi->trans_pos = tp;\n}\n\nstatic inline void write_txram_slot_u8(struct bcm_qspi *qspi, int slot,\n\t\t\t\t       u8 val)\n{\n\tu32 reg_offset = MSPI_TXRAM + (slot << 3);\n\n\t \n\tbcm_qspi_write(qspi, MSPI, reg_offset, val);\n}\n\nstatic inline void write_txram_slot_u16(struct bcm_qspi *qspi, int slot,\n\t\t\t\t\tu16 val)\n{\n\tu32 reg_offset = MSPI_TXRAM;\n\tu32 msb_offset = reg_offset + (slot << 3);\n\tu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\n\n\tbcm_qspi_write(qspi, MSPI, msb_offset, (val >> 8));\n\tbcm_qspi_write(qspi, MSPI, lsb_offset, (val & 0xff));\n}\n\nstatic inline void write_txram_slot_u32(struct bcm_qspi *qspi, int slot,\n\t\t\t\t\tu32 val)\n{\n\tu32 reg_offset = MSPI_TXRAM;\n\tu32 msb_offset = reg_offset + (slot << 3);\n\n\tbcm_qspi_write(qspi, MSPI, msb_offset, swap4bytes(val));\n}\n\nstatic inline void write_txram_slot_u64(struct bcm_qspi *qspi, int slot,\n\t\t\t\t\tu64 val)\n{\n\tu32 reg_offset = MSPI_TXRAM;\n\tu32 msb_offset = reg_offset + (slot << 3);\n\tu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\n\tu32 msb = upper_32_bits(val);\n\tu32 lsb = lower_32_bits(val);\n\n\tbcm_qspi_write(qspi, MSPI, msb_offset, swap4bytes(msb));\n\tbcm_qspi_write(qspi, MSPI, lsb_offset, swap4bytes(lsb));\n}\n\nstatic inline u32 read_cdram_slot(struct bcm_qspi *qspi, int slot)\n{\n\treturn bcm_qspi_read(qspi, MSPI, MSPI_CDRAM + (slot << 2));\n}\n\nstatic inline void write_cdram_slot(struct bcm_qspi *qspi, int slot, u32 val)\n{\n\tbcm_qspi_write(qspi, MSPI, (MSPI_CDRAM + (slot << 2)), val);\n}\n\n \nstatic int write_to_hw(struct bcm_qspi *qspi, struct spi_device *spi)\n{\n\tstruct qspi_trans tp;\n\tint slot = 0, tstatus = 0;\n\tu32 mspi_cdram = 0;\n\n\tbcm_qspi_disable_bspi(qspi);\n\ttp = qspi->trans_pos;\n\tbcm_qspi_update_parms(qspi, spi, tp.trans);\n\n\t \n\twhile (!tstatus && slot < MSPI_NUM_CDRAM) {\n\t\tmspi_cdram = MSPI_CDRAM_CONT_BIT;\n\t\tif (tp.trans->bits_per_word <= 8) {\n\t\t\tconst u8 *buf = tp.trans->tx_buf;\n\t\t\tu8 val = buf ? buf[tp.byte] : 0x00;\n\n\t\t\twrite_txram_slot_u8(qspi, slot, val);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"WR %02x\\n\", val);\n\t\t} else if (tp.trans->bits_per_word <= 16) {\n\t\t\tconst u16 *buf = tp.trans->tx_buf;\n\t\t\tu16 val = buf ? buf[tp.byte / 2] : 0x0000;\n\n\t\t\twrite_txram_slot_u16(qspi, slot, val);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"WR %04x\\n\", val);\n\t\t} else if (tp.trans->bits_per_word <= 32) {\n\t\t\tconst u32 *buf = tp.trans->tx_buf;\n\t\t\tu32 val = buf ? buf[tp.byte/4] : 0x0;\n\n\t\t\twrite_txram_slot_u32(qspi, slot, val);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"WR %08x\\n\", val);\n\t\t} else if (tp.trans->bits_per_word <= 64) {\n\t\t\tconst u64 *buf = tp.trans->tx_buf;\n\t\t\tu64 val = (buf ? buf[tp.byte/8] : 0x0);\n\n\t\t\t \n\t\t\tif (bcm_qspi_has_fastbr(qspi))\n\t\t\t\tmspi_cdram |= MSPI_CDRAM_DT_BIT;\n\n\t\t\twrite_txram_slot_u64(qspi, slot, val);\n\t\t\tdev_dbg(&qspi->pdev->dev, \"WR %llx\\n\", val);\n\t\t}\n\n\t\tmspi_cdram |= ((tp.trans->bits_per_word <= 8) ? 0 :\n\t\t\t       MSPI_CDRAM_BITSE_BIT);\n\n\t\t \n\t\tif ((spi->mode & SPI_3WIRE) && tp.trans->tx_buf)\n\t\t\tmspi_cdram |= MSPI_CDRAM_OUTP;\n\n\t\tif (has_bspi(qspi))\n\t\t\tmspi_cdram &= ~1;\n\t\telse\n\t\t\tmspi_cdram |= (~(1 << spi_get_chipselect(spi, 0)) &\n\t\t\t\t       MSPI_CDRAM_PCS);\n\n\t\twrite_cdram_slot(qspi, slot, mspi_cdram);\n\n\t\ttstatus = update_qspi_trans_byte_count(qspi, &tp,\n\t\t\t\t\t\t       TRANS_STATUS_BREAK_TX);\n\t\tslot++;\n\t}\n\n\tif (!slot) {\n\t\tdev_err(&qspi->pdev->dev, \"%s: no data to send?\", __func__);\n\t\tgoto done;\n\t}\n\n\tdev_dbg(&qspi->pdev->dev, \"submitting %d slots\\n\", slot);\n\tbcm_qspi_write(qspi, MSPI, MSPI_NEWQP, 0);\n\tbcm_qspi_write(qspi, MSPI, MSPI_ENDQP, slot - 1);\n\n\t \n\tif (((tstatus & TRANS_STATUS_BREAK_DESELECT)\n\t     == TRANS_STATUS_BREAK_CS_CHANGE) ||\n\t    ((tstatus & TRANS_STATUS_BREAK_DESELECT)\n\t     == TRANS_STATUS_BREAK_EOM)) {\n\t\tmspi_cdram = read_cdram_slot(qspi, slot - 1) &\n\t\t\t~MSPI_CDRAM_CONT_BIT;\n\t\twrite_cdram_slot(qspi, slot - 1, mspi_cdram);\n\t}\n\n\tif (has_bspi(qspi))\n\t\tbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 1);\n\n\t \n\tmb();\n\t \n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0xe0);\n\ndone:\n\treturn slot;\n}\n\nstatic int bcm_qspi_bspi_exec_mem_op(struct spi_device *spi,\n\t\t\t\t     const struct spi_mem_op *op)\n{\n\tstruct bcm_qspi *qspi = spi_controller_get_devdata(spi->controller);\n\tu32 addr = 0, len, rdlen, len_words, from = 0;\n\tint ret = 0;\n\tunsigned long timeo = msecs_to_jiffies(100);\n\tstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\n\n\tif (bcm_qspi_bspi_ver_three(qspi))\n\t\tif (op->addr.nbytes == BSPI_ADDRLEN_4BYTES)\n\t\t\treturn -EIO;\n\n\tfrom = op->addr.val;\n\tif (!spi_get_csgpiod(spi, 0))\n\t\tbcm_qspi_chip_select(qspi, spi_get_chipselect(spi, 0));\n\tbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 0);\n\n\t \n\tif (!bcm_qspi_bspi_ver_three(qspi)) {\n\t\taddr = from & 0xff000000;\n\t\tbcm_qspi_write(qspi, BSPI,\n\t\t\t       BSPI_BSPI_FLASH_UPPER_ADDR_BYTE, addr);\n\t}\n\n\tif (!qspi->xfer_mode.flex_mode)\n\t\taddr = from;\n\telse\n\t\taddr = from & 0x00ffffff;\n\n\tif (bcm_qspi_bspi_ver_three(qspi) == true)\n\t\taddr = (addr + 0xc00000) & 0xffffff;\n\n\t \n\tlen = op->data.nbytes;\n\tqspi->bspi_rf_op_idx = 0;\n\n\tdo {\n\t\tif (len > BSPI_READ_LENGTH)\n\t\t\trdlen = BSPI_READ_LENGTH;\n\t\telse\n\t\t\trdlen = len;\n\n\t\treinit_completion(&qspi->bspi_done);\n\t\tbcm_qspi_enable_bspi(qspi);\n\t\tlen_words = (rdlen + 3) >> 2;\n\t\tqspi->bspi_rf_op = op;\n\t\tqspi->bspi_rf_op_status = 0;\n\t\tqspi->bspi_rf_op_len = rdlen;\n\t\tdev_dbg(&qspi->pdev->dev,\n\t\t\t\"bspi xfr addr 0x%x len 0x%x\", addr, rdlen);\n\t\tbcm_qspi_write(qspi, BSPI, BSPI_RAF_START_ADDR, addr);\n\t\tbcm_qspi_write(qspi, BSPI, BSPI_RAF_NUM_WORDS, len_words);\n\t\tbcm_qspi_write(qspi, BSPI, BSPI_RAF_WATERMARK, 0);\n\t\tif (qspi->soc_intc) {\n\t\t\t \n\t\t\tsoc_intc->bcm_qspi_int_ack(soc_intc, MSPI_BSPI_DONE);\n\t\t\tsoc_intc->bcm_qspi_int_set(soc_intc, BSPI_DONE, true);\n\t\t}\n\n\t\t \n\t\tmb();\n\t\tbcm_qspi_bspi_lr_start(qspi);\n\t\tif (!wait_for_completion_timeout(&qspi->bspi_done, timeo)) {\n\t\t\tdev_err(&qspi->pdev->dev, \"timeout waiting for BSPI\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\taddr += rdlen;\n\t\tlen -= rdlen;\n\t} while (len);\n\n\treturn ret;\n}\n\nstatic int bcm_qspi_transfer_one(struct spi_controller *host,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *trans)\n{\n\tstruct bcm_qspi *qspi = spi_controller_get_devdata(host);\n\tint slots;\n\tunsigned long timeo = msecs_to_jiffies(100);\n\n\tif (!spi_get_csgpiod(spi, 0))\n\t\tbcm_qspi_chip_select(qspi, spi_get_chipselect(spi, 0));\n\tqspi->trans_pos.trans = trans;\n\tqspi->trans_pos.byte = 0;\n\n\twhile (qspi->trans_pos.byte < trans->len) {\n\t\treinit_completion(&qspi->mspi_done);\n\n\t\tslots = write_to_hw(qspi, spi);\n\t\tif (!wait_for_completion_timeout(&qspi->mspi_done, timeo)) {\n\t\t\tdev_err(&qspi->pdev->dev, \"timeout waiting for MSPI\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tread_from_hw(qspi, slots);\n\t}\n\tbcm_qspi_enable_bspi(qspi);\n\n\treturn 0;\n}\n\nstatic int bcm_qspi_mspi_exec_mem_op(struct spi_device *spi,\n\t\t\t\t     const struct spi_mem_op *op)\n{\n\tstruct spi_controller *host = spi->controller;\n\tstruct bcm_qspi *qspi = spi_controller_get_devdata(host);\n\tstruct spi_transfer t[2];\n\tu8 cmd[6] = { };\n\tint ret, i;\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tmemset(t, 0, sizeof(t));\n\n\t \n\t \n\tcmd[0] = op->cmd.opcode;\n\tfor (i = 0; i < op->addr.nbytes; i++)\n\t\tcmd[1 + i] = op->addr.val >> (8 * (op->addr.nbytes - i - 1));\n\n\tt[0].tx_buf = cmd;\n\tt[0].len = op->addr.nbytes + op->dummy.nbytes + 1;\n\tt[0].bits_per_word = spi->bits_per_word;\n\tt[0].tx_nbits = op->cmd.buswidth;\n\t \n\tqspi->trans_pos.mspi_last_trans = false;\n\tret = bcm_qspi_transfer_one(host, spi, &t[0]);\n\n\t \n\tqspi->trans_pos.mspi_last_trans = true;\n\tif (!ret) {\n\t\t \n\t\tt[1].rx_buf = op->data.buf.in;\n\t\tt[1].len = op->data.nbytes;\n\t\tt[1].rx_nbits =  op->data.buswidth;\n\t\tt[1].bits_per_word = spi->bits_per_word;\n\t\tret = bcm_qspi_transfer_one(host, spi, &t[1]);\n\t}\n\n\treturn ret;\n}\n\nstatic int bcm_qspi_exec_mem_op(struct spi_mem *mem,\n\t\t\t\tconst struct spi_mem_op *op)\n{\n\tstruct spi_device *spi = mem->spi;\n\tstruct bcm_qspi *qspi = spi_controller_get_devdata(spi->controller);\n\tint ret = 0;\n\tbool mspi_read = false;\n\tu32 addr = 0, len;\n\tu_char *buf;\n\n\tif (!op->data.nbytes || !op->addr.nbytes || op->addr.nbytes > 4 ||\n\t    op->data.dir != SPI_MEM_DATA_IN)\n\t\treturn -ENOTSUPP;\n\n\tbuf = op->data.buf.in;\n\taddr = op->addr.val;\n\tlen = op->data.nbytes;\n\n\tif (has_bspi(qspi) && bcm_qspi_bspi_ver_three(qspi) == true) {\n\t\t \n\t\taddr = (addr + 0xc00000) & 0xffffff;\n\n\t\tif ((~ADDR_4MB_MASK & addr) ^\n\t\t    (~ADDR_4MB_MASK & (addr + len - 1)))\n\t\t\tmspi_read = true;\n\t}\n\n\t \n\tif (!IS_ALIGNED((uintptr_t)addr, 4) || !IS_ALIGNED((uintptr_t)buf, 4) ||\n\t    len < 4)\n\t\tmspi_read = true;\n\n\tif (!has_bspi(qspi) || mspi_read)\n\t\treturn bcm_qspi_mspi_exec_mem_op(spi, op);\n\n\tret = bcm_qspi_bspi_set_mode(qspi, op, 0);\n\n\tif (!ret)\n\t\tret = bcm_qspi_bspi_exec_mem_op(spi, op);\n\n\treturn ret;\n}\n\nstatic void bcm_qspi_cleanup(struct spi_device *spi)\n{\n\tstruct bcm_qspi_parms *xp = spi_get_ctldata(spi);\n\n\tkfree(xp);\n}\n\nstatic irqreturn_t bcm_qspi_mspi_l2_isr(int irq, void *dev_id)\n{\n\tstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\n\tstruct bcm_qspi *qspi = qspi_dev_id->dev;\n\tu32 status = bcm_qspi_read(qspi, MSPI, MSPI_MSPI_STATUS);\n\n\tif (status & MSPI_MSPI_STATUS_SPIF) {\n\t\tstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\n\t\t \n\t\tstatus &= ~MSPI_MSPI_STATUS_SPIF;\n\t\tbcm_qspi_write(qspi, MSPI, MSPI_MSPI_STATUS, status);\n\t\tif (qspi->soc_intc)\n\t\t\tsoc_intc->bcm_qspi_int_ack(soc_intc, MSPI_DONE);\n\t\tcomplete(&qspi->mspi_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t bcm_qspi_bspi_lr_l2_isr(int irq, void *dev_id)\n{\n\tstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\n\tstruct bcm_qspi *qspi = qspi_dev_id->dev;\n\tstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\n\tu32 status = qspi_dev_id->irqp->mask;\n\n\tif (qspi->bspi_enabled && qspi->bspi_rf_op) {\n\t\tbcm_qspi_bspi_lr_data_read(qspi);\n\t\tif (qspi->bspi_rf_op_len == 0) {\n\t\t\tqspi->bspi_rf_op = NULL;\n\t\t\tif (qspi->soc_intc) {\n\t\t\t\t \n\t\t\t\tsoc_intc->bcm_qspi_int_set(soc_intc, BSPI_DONE,\n\t\t\t\t\t\t\t   false);\n\t\t\t\t \n\t\t\t\tstatus = INTR_BSPI_LR_SESSION_DONE_MASK;\n\t\t\t}\n\n\t\t\tif (qspi->bspi_rf_op_status)\n\t\t\t\tbcm_qspi_bspi_lr_clear(qspi);\n\t\t\telse\n\t\t\t\tbcm_qspi_bspi_flush_prefetch_buffers(qspi);\n\t\t}\n\n\t\tif (qspi->soc_intc)\n\t\t\t \n\t\t\tsoc_intc->bcm_qspi_int_ack(soc_intc, BSPI_DONE);\n\t}\n\n\tstatus &= INTR_BSPI_LR_SESSION_DONE_MASK;\n\tif (qspi->bspi_enabled && status && qspi->bspi_rf_op_len == 0)\n\t\tcomplete(&qspi->bspi_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bcm_qspi_bspi_lr_err_l2_isr(int irq, void *dev_id)\n{\n\tstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\n\tstruct bcm_qspi *qspi = qspi_dev_id->dev;\n\tstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\n\n\tdev_err(&qspi->pdev->dev, \"BSPI INT error\\n\");\n\tqspi->bspi_rf_op_status = -EIO;\n\tif (qspi->soc_intc)\n\t\t \n\t\tsoc_intc->bcm_qspi_int_ack(soc_intc, BSPI_ERR);\n\n\tcomplete(&qspi->bspi_done);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bcm_qspi_l1_isr(int irq, void *dev_id)\n{\n\tstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\n\tstruct bcm_qspi *qspi = qspi_dev_id->dev;\n\tstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (soc_intc) {\n\t\tu32 status = soc_intc->bcm_qspi_get_int_status(soc_intc);\n\n\t\tif (status & MSPI_DONE)\n\t\t\tret = bcm_qspi_mspi_l2_isr(irq, dev_id);\n\t\telse if (status & BSPI_DONE)\n\t\t\tret = bcm_qspi_bspi_lr_l2_isr(irq, dev_id);\n\t\telse if (status & BSPI_ERR)\n\t\t\tret = bcm_qspi_bspi_lr_err_l2_isr(irq, dev_id);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct bcm_qspi_irq qspi_irq_tab[] = {\n\t{\n\t\t.irq_name = \"spi_lr_fullness_reached\",\n\t\t.irq_handler = bcm_qspi_bspi_lr_l2_isr,\n\t\t.mask = INTR_BSPI_LR_FULLNESS_REACHED_MASK,\n\t},\n\t{\n\t\t.irq_name = \"spi_lr_session_aborted\",\n\t\t.irq_handler = bcm_qspi_bspi_lr_err_l2_isr,\n\t\t.mask = INTR_BSPI_LR_SESSION_ABORTED_MASK,\n\t},\n\t{\n\t\t.irq_name = \"spi_lr_impatient\",\n\t\t.irq_handler = bcm_qspi_bspi_lr_err_l2_isr,\n\t\t.mask = INTR_BSPI_LR_IMPATIENT_MASK,\n\t},\n\t{\n\t\t.irq_name = \"spi_lr_session_done\",\n\t\t.irq_handler = bcm_qspi_bspi_lr_l2_isr,\n\t\t.mask = INTR_BSPI_LR_SESSION_DONE_MASK,\n\t},\n#ifdef QSPI_INT_DEBUG\n\t \n\t{\n\t\t.irq_name = \"spi_lr_overread\",\n\t\t.irq_handler = bcm_qspi_bspi_lr_err_l2_isr,\n\t\t.mask = INTR_BSPI_LR_OVERREAD_MASK,\n\t},\n#endif\n\t{\n\t\t.irq_name = \"mspi_done\",\n\t\t.irq_handler = bcm_qspi_mspi_l2_isr,\n\t\t.mask = INTR_MSPI_DONE_MASK,\n\t},\n\t{\n\t\t.irq_name = \"mspi_halted\",\n\t\t.irq_handler = bcm_qspi_mspi_l2_isr,\n\t\t.mask = INTR_MSPI_HALTED_MASK,\n\t},\n\t{\n\t\t \n\t\t.irq_name = \"spi_l1_intr\",\n\t\t.irq_handler = bcm_qspi_l1_isr,\n\t\t.irq_source = MUXED_L1,\n\t\t.mask = QSPI_INTERRUPTS_ALL,\n\t},\n};\n\nstatic void bcm_qspi_bspi_init(struct bcm_qspi *qspi)\n{\n\tu32 val = 0;\n\n\tval = bcm_qspi_read(qspi, BSPI, BSPI_REVISION_ID);\n\tqspi->bspi_maj_rev = (val >> 8) & 0xff;\n\tqspi->bspi_min_rev = val & 0xff;\n\tif (!(bcm_qspi_bspi_ver_three(qspi))) {\n\t\t \n\t\tbcm_qspi_write(qspi, BSPI, BSPI_BSPI_XOR_VALUE, 0);\n\t\tbcm_qspi_write(qspi, BSPI, BSPI_BSPI_XOR_ENABLE, 1);\n\t}\n\tqspi->bspi_enabled = 1;\n\tbcm_qspi_disable_bspi(qspi);\n\tbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 0);\n\tbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 0);\n}\n\nstatic void bcm_qspi_hw_init(struct bcm_qspi *qspi)\n{\n\tstruct bcm_qspi_parms parms;\n\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR1_LSB, 0);\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR1_MSB, 0);\n\tbcm_qspi_write(qspi, MSPI, MSPI_NEWQP, 0);\n\tbcm_qspi_write(qspi, MSPI, MSPI_ENDQP, 0);\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0x20);\n\n\tparms.mode = SPI_MODE_3;\n\tparms.bits_per_word = 8;\n\tparms.speed_hz = qspi->max_speed_hz;\n\tbcm_qspi_hw_set_parms(qspi, &parms);\n\n\tif (has_bspi(qspi))\n\t\tbcm_qspi_bspi_init(qspi);\n}\n\nstatic void bcm_qspi_hw_uninit(struct bcm_qspi *qspi)\n{\n\tu32 status = bcm_qspi_read(qspi, MSPI, MSPI_MSPI_STATUS);\n\n\tbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0);\n\tif (has_bspi(qspi))\n\t\tbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 0);\n\n\t \n\tbcm_qspi_write(qspi, MSPI, MSPI_MSPI_STATUS, status & ~1);\n}\n\nstatic const struct spi_controller_mem_ops bcm_qspi_mem_ops = {\n\t.exec_op = bcm_qspi_exec_mem_op,\n};\n\nstruct bcm_qspi_data {\n\tbool\thas_mspi_rev;\n\tbool\thas_spcr3_sysclk;\n};\n\nstatic const struct bcm_qspi_data bcm_qspi_no_rev_data = {\n\t.has_mspi_rev\t= false,\n\t.has_spcr3_sysclk = false,\n};\n\nstatic const struct bcm_qspi_data bcm_qspi_rev_data = {\n\t.has_mspi_rev\t= true,\n\t.has_spcr3_sysclk = false,\n};\n\nstatic const struct bcm_qspi_data bcm_qspi_spcr3_data = {\n\t.has_mspi_rev\t= true,\n\t.has_spcr3_sysclk = true,\n};\n\nstatic const struct of_device_id bcm_qspi_of_match[] __maybe_unused = {\n\t{\n\t\t.compatible = \"brcm,spi-bcm7445-qspi\",\n\t\t.data = &bcm_qspi_rev_data,\n\n\t},\n\t{\n\t\t.compatible = \"brcm,spi-bcm-qspi\",\n\t\t.data = &bcm_qspi_no_rev_data,\n\t},\n\t{\n\t\t.compatible = \"brcm,spi-bcm7216-qspi\",\n\t\t.data = &bcm_qspi_spcr3_data,\n\t},\n\t{\n\t\t.compatible = \"brcm,spi-bcm7278-qspi\",\n\t\t.data = &bcm_qspi_spcr3_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm_qspi_of_match);\n\nint bcm_qspi_probe(struct platform_device *pdev,\n\t\t   struct bcm_qspi_soc_intc *soc_intc)\n{\n\tconst struct of_device_id *of_id = NULL;\n\tconst struct bcm_qspi_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm_qspi *qspi;\n\tstruct spi_controller *host;\n\tstruct resource *res;\n\tint irq, ret = 0, num_ints = 0;\n\tu32 val;\n\tu32 rev = 0;\n\tconst char *name = NULL;\n\tint num_irqs = ARRAY_SIZE(qspi_irq_tab);\n\n\t \n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tof_id = of_match_node(bcm_qspi_of_match, dev->of_node);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tdata = of_id->data;\n\n\thost = devm_spi_alloc_host(dev, sizeof(struct bcm_qspi));\n\tif (!host) {\n\t\tdev_err(dev, \"error allocating spi_controller\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqspi = spi_controller_get_devdata(host);\n\n\tqspi->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(qspi->clk))\n\t\treturn PTR_ERR(qspi->clk);\n\n\tqspi->pdev = pdev;\n\tqspi->trans_pos.trans = NULL;\n\tqspi->trans_pos.byte = 0;\n\tqspi->trans_pos.mspi_last_trans = true;\n\tqspi->host = host;\n\n\thost->bus_num = -1;\n\thost->mode_bits = SPI_CPHA | SPI_CPOL | SPI_RX_DUAL | SPI_RX_QUAD |\n\t\t\t\tSPI_3WIRE;\n\thost->setup = bcm_qspi_setup;\n\thost->transfer_one = bcm_qspi_transfer_one;\n\thost->mem_ops = &bcm_qspi_mem_ops;\n\thost->cleanup = bcm_qspi_cleanup;\n\thost->dev.of_node = dev->of_node;\n\thost->num_chipselect = NUM_CHIPSELECT;\n\thost->use_gpio_descriptors = true;\n\n\tqspi->big_endian = of_device_is_big_endian(dev->of_node);\n\n\tif (!of_property_read_u32(dev->of_node, \"num-cs\", &val))\n\t\thost->num_chipselect = val;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hif_mspi\");\n\tif (!res)\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"mspi\");\n\n\tqspi->base[MSPI]  = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(qspi->base[MSPI]))\n\t\treturn PTR_ERR(qspi->base[MSPI]);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"bspi\");\n\tif (res) {\n\t\tqspi->base[BSPI]  = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(qspi->base[BSPI]))\n\t\t\treturn PTR_ERR(qspi->base[BSPI]);\n\t\tqspi->bspi_mode = true;\n\t} else {\n\t\tqspi->bspi_mode = false;\n\t}\n\n\tdev_info(dev, \"using %smspi mode\\n\", qspi->bspi_mode ? \"bspi-\" : \"\");\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cs_reg\");\n\tif (res) {\n\t\tqspi->base[CHIP_SELECT]  = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(qspi->base[CHIP_SELECT]))\n\t\t\treturn PTR_ERR(qspi->base[CHIP_SELECT]);\n\t}\n\n\tqspi->dev_ids = kcalloc(num_irqs, sizeof(struct bcm_qspi_dev_id),\n\t\t\t\tGFP_KERNEL);\n\tif (!qspi->dev_ids)\n\t\treturn -ENOMEM;\n\n\t \n\tif (soc_intc) {\n\t\tqspi->soc_intc = soc_intc;\n\t\tsoc_intc->bcm_qspi_int_set(soc_intc, MSPI_DONE, true);\n\t} else {\n\t\tqspi->soc_intc = NULL;\n\t}\n\n\tif (qspi->clk) {\n\t\tret = clk_prepare_enable(qspi->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to prepare clock\\n\");\n\t\t\tgoto qspi_probe_err;\n\t\t}\n\t\tqspi->base_clk = clk_get_rate(qspi->clk);\n\t} else {\n\t\tqspi->base_clk = MSPI_BASE_FREQ;\n\t}\n\n\tif (data->has_mspi_rev) {\n\t\trev = bcm_qspi_read(qspi, MSPI, MSPI_REV);\n\t\t \n\t\tif ((rev & 0xff) == 0xff)\n\t\t\trev = 0;\n\t}\n\n\tqspi->mspi_maj_rev = (rev >> 4) & 0xf;\n\tqspi->mspi_min_rev = rev & 0xf;\n\tqspi->mspi_spcr3_sysclk = data->has_spcr3_sysclk;\n\n\tqspi->max_speed_hz = qspi->base_clk / (bcm_qspi_spbr_min(qspi) * 2);\n\n\t \n\tbcm_qspi_hw_uninit(qspi);\n\n\tfor (val = 0; val < num_irqs; val++) {\n\t\tirq = -1;\n\t\tname = qspi_irq_tab[val].irq_name;\n\t\tif (qspi_irq_tab[val].irq_source == SINGLE_L2) {\n\t\t\t \n\t\t\tirq = platform_get_irq_byname_optional(pdev, name);\n\t\t} else if (!num_ints && soc_intc) {\n\t\t\t \n\t\t\tirq = platform_get_irq(pdev, 0);\n\t\t}\n\n\t\tif (irq  >= 0) {\n\t\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t\t       qspi_irq_tab[val].irq_handler, 0,\n\t\t\t\t\t       name,\n\t\t\t\t\t       &qspi->dev_ids[val]);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"IRQ %s not found\\n\", name);\n\t\t\t\tgoto qspi_unprepare_err;\n\t\t\t}\n\n\t\t\tqspi->dev_ids[val].dev = qspi;\n\t\t\tqspi->dev_ids[val].irqp = &qspi_irq_tab[val];\n\t\t\tnum_ints++;\n\t\t\tdev_dbg(&pdev->dev, \"registered IRQ %s %d\\n\",\n\t\t\t\tqspi_irq_tab[val].irq_name,\n\t\t\t\tirq);\n\t\t}\n\t}\n\n\tif (!num_ints) {\n\t\tdev_err(&pdev->dev, \"no IRQs registered, cannot init driver\\n\");\n\t\tret = -EINVAL;\n\t\tgoto qspi_unprepare_err;\n\t}\n\n\tbcm_qspi_hw_init(qspi);\n\tinit_completion(&qspi->mspi_done);\n\tinit_completion(&qspi->bspi_done);\n\tqspi->curr_cs = -1;\n\n\tplatform_set_drvdata(pdev, qspi);\n\n\tqspi->xfer_mode.width = -1;\n\tqspi->xfer_mode.addrlen = -1;\n\tqspi->xfer_mode.hp = -1;\n\n\tret = spi_register_controller(host);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register host\\n\");\n\t\tgoto qspi_reg_err;\n\t}\n\n\treturn 0;\n\nqspi_reg_err:\n\tbcm_qspi_hw_uninit(qspi);\nqspi_unprepare_err:\n\tclk_disable_unprepare(qspi->clk);\nqspi_probe_err:\n\tkfree(qspi->dev_ids);\n\treturn ret;\n}\n \nEXPORT_SYMBOL_GPL(bcm_qspi_probe);\n\nvoid bcm_qspi_remove(struct platform_device *pdev)\n{\n\tstruct bcm_qspi *qspi = platform_get_drvdata(pdev);\n\n\tspi_unregister_controller(qspi->host);\n\tbcm_qspi_hw_uninit(qspi);\n\tclk_disable_unprepare(qspi->clk);\n\tkfree(qspi->dev_ids);\n}\n\n \nEXPORT_SYMBOL_GPL(bcm_qspi_remove);\n\nstatic int __maybe_unused bcm_qspi_suspend(struct device *dev)\n{\n\tstruct bcm_qspi *qspi = dev_get_drvdata(dev);\n\n\t \n\tif (!bcm_qspi_bspi_ver_three(qspi))\n\t\tqspi->s3_strap_override_ctrl =\n\t\t\tbcm_qspi_read(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL);\n\n\tspi_controller_suspend(qspi->host);\n\tclk_disable_unprepare(qspi->clk);\n\tbcm_qspi_hw_uninit(qspi);\n\n\treturn 0;\n};\n\nstatic int __maybe_unused bcm_qspi_resume(struct device *dev)\n{\n\tstruct bcm_qspi *qspi = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tbcm_qspi_hw_init(qspi);\n\tbcm_qspi_chip_select(qspi, qspi->curr_cs);\n\tif (qspi->soc_intc)\n\t\t \n\t\tqspi->soc_intc->bcm_qspi_int_set(qspi->soc_intc, MSPI_DONE,\n\t\t\t\t\t\t true);\n\n\tret = clk_prepare_enable(qspi->clk);\n\tif (!ret)\n\t\tspi_controller_resume(qspi->host);\n\n\treturn ret;\n}\n\nSIMPLE_DEV_PM_OPS(bcm_qspi_pm_ops, bcm_qspi_suspend, bcm_qspi_resume);\n\n \nEXPORT_SYMBOL_GPL(bcm_qspi_pm_ops);\n\nMODULE_AUTHOR(\"Kamal Dasu\");\nMODULE_DESCRIPTION(\"Broadcom QSPI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}