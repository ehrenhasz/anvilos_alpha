{
  "module_name": "spi-davinci.c",
  "hash_id": "8a2ed0489d382a992ef211d4eabdf080ad6e6622105ff9b39464418de25a5b5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-davinci.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/slab.h>\n\n#include <linux/platform_data/spi-davinci.h>\n\n#define CS_DEFAULT\t0xFF\n\n#define SPIFMT_PHASE_MASK\tBIT(16)\n#define SPIFMT_POLARITY_MASK\tBIT(17)\n#define SPIFMT_DISTIMER_MASK\tBIT(18)\n#define SPIFMT_SHIFTDIR_MASK\tBIT(20)\n#define SPIFMT_WAITENA_MASK\tBIT(21)\n#define SPIFMT_PARITYENA_MASK\tBIT(22)\n#define SPIFMT_ODD_PARITY_MASK\tBIT(23)\n#define SPIFMT_WDELAY_MASK\t0x3f000000u\n#define SPIFMT_WDELAY_SHIFT\t24\n#define SPIFMT_PRESCALE_SHIFT\t8\n\n \n#define SPIPC0_DIFUN_MASK\tBIT(11)\t\t \n#define SPIPC0_DOFUN_MASK\tBIT(10)\t\t \n#define SPIPC0_CLKFUN_MASK\tBIT(9)\t\t \n#define SPIPC0_SPIENA_MASK\tBIT(8)\t\t \n\n#define SPIINT_MASKALL\t\t0x0101035F\n#define SPIINT_MASKINT\t\t0x0000015F\n#define SPI_INTLVL_1\t\t0x000001FF\n#define SPI_INTLVL_0\t\t0x00000000\n\n \n#define SPIDAT1_CSHOLD_MASK\tBIT(12)\n#define SPIDAT1_WDEL\t\tBIT(10)\n\n \n#define SPIGCR1_CLKMOD_MASK\tBIT(1)\n#define SPIGCR1_MASTER_MASK     BIT(0)\n#define SPIGCR1_POWERDOWN_MASK\tBIT(8)\n#define SPIGCR1_LOOPBACK_MASK\tBIT(16)\n#define SPIGCR1_SPIENA_MASK\tBIT(24)\n\n \n#define SPIBUF_TXFULL_MASK\tBIT(29)\n#define SPIBUF_RXEMPTY_MASK\tBIT(31)\n\n \n#define SPIDELAY_C2TDELAY_SHIFT 24\n#define SPIDELAY_C2TDELAY_MASK  (0xFF << SPIDELAY_C2TDELAY_SHIFT)\n#define SPIDELAY_T2CDELAY_SHIFT 16\n#define SPIDELAY_T2CDELAY_MASK  (0xFF << SPIDELAY_T2CDELAY_SHIFT)\n#define SPIDELAY_T2EDELAY_SHIFT 8\n#define SPIDELAY_T2EDELAY_MASK  (0xFF << SPIDELAY_T2EDELAY_SHIFT)\n#define SPIDELAY_C2EDELAY_SHIFT 0\n#define SPIDELAY_C2EDELAY_MASK  0xFF\n\n \n#define SPIFLG_DLEN_ERR_MASK\t\tBIT(0)\n#define SPIFLG_TIMEOUT_MASK\t\tBIT(1)\n#define SPIFLG_PARERR_MASK\t\tBIT(2)\n#define SPIFLG_DESYNC_MASK\t\tBIT(3)\n#define SPIFLG_BITERR_MASK\t\tBIT(4)\n#define SPIFLG_OVRRUN_MASK\t\tBIT(6)\n#define SPIFLG_BUF_INIT_ACTIVE_MASK\tBIT(24)\n#define SPIFLG_ERROR_MASK\t\t(SPIFLG_DLEN_ERR_MASK \\\n\t\t\t\t| SPIFLG_TIMEOUT_MASK | SPIFLG_PARERR_MASK \\\n\t\t\t\t| SPIFLG_DESYNC_MASK | SPIFLG_BITERR_MASK \\\n\t\t\t\t| SPIFLG_OVRRUN_MASK)\n\n#define SPIINT_DMA_REQ_EN\tBIT(16)\n\n \n#define SPIGCR0\t\t0x00\n#define SPIGCR1\t\t0x04\n#define SPIINT\t\t0x08\n#define SPILVL\t\t0x0c\n#define SPIFLG\t\t0x10\n#define SPIPC0\t\t0x14\n#define SPIDAT1\t\t0x3c\n#define SPIBUF\t\t0x40\n#define SPIDELAY\t0x48\n#define SPIDEF\t\t0x4c\n#define SPIFMT0\t\t0x50\n\n#define DMA_MIN_BYTES\t16\n\n \nstruct davinci_spi {\n\tstruct spi_bitbang\tbitbang;\n\tstruct clk\t\t*clk;\n\n\tu8\t\t\tversion;\n\tresource_size_t\t\tpbase;\n\tvoid __iomem\t\t*base;\n\tu32\t\t\tirq;\n\tstruct completion\tdone;\n\n\tconst void\t\t*tx;\n\tvoid\t\t\t*rx;\n\tint\t\t\trcount;\n\tint\t\t\twcount;\n\n\tstruct dma_chan\t\t*dma_rx;\n\tstruct dma_chan\t\t*dma_tx;\n\n\tstruct davinci_spi_platform_data pdata;\n\n\tvoid\t\t\t(*get_rx)(u32 rx_data, struct davinci_spi *);\n\tu32\t\t\t(*get_tx)(struct davinci_spi *);\n\n\tu8\t\t\t*bytes_per_word;\n\n\tu8\t\t\tprescaler_limit;\n};\n\nstatic struct davinci_spi_config davinci_spi_default_cfg;\n\nstatic void davinci_spi_rx_buf_u8(u32 data, struct davinci_spi *dspi)\n{\n\tif (dspi->rx) {\n\t\tu8 *rx = dspi->rx;\n\t\t*rx++ = (u8)data;\n\t\tdspi->rx = rx;\n\t}\n}\n\nstatic void davinci_spi_rx_buf_u16(u32 data, struct davinci_spi *dspi)\n{\n\tif (dspi->rx) {\n\t\tu16 *rx = dspi->rx;\n\t\t*rx++ = (u16)data;\n\t\tdspi->rx = rx;\n\t}\n}\n\nstatic u32 davinci_spi_tx_buf_u8(struct davinci_spi *dspi)\n{\n\tu32 data = 0;\n\n\tif (dspi->tx) {\n\t\tconst u8 *tx = dspi->tx;\n\n\t\tdata = *tx++;\n\t\tdspi->tx = tx;\n\t}\n\treturn data;\n}\n\nstatic u32 davinci_spi_tx_buf_u16(struct davinci_spi *dspi)\n{\n\tu32 data = 0;\n\n\tif (dspi->tx) {\n\t\tconst u16 *tx = dspi->tx;\n\n\t\tdata = *tx++;\n\t\tdspi->tx = tx;\n\t}\n\treturn data;\n}\n\nstatic inline void set_io_bits(void __iomem *addr, u32 bits)\n{\n\tu32 v = ioread32(addr);\n\n\tv |= bits;\n\tiowrite32(v, addr);\n}\n\nstatic inline void clear_io_bits(void __iomem *addr, u32 bits)\n{\n\tu32 v = ioread32(addr);\n\n\tv &= ~bits;\n\tiowrite32(v, addr);\n}\n\n \nstatic void davinci_spi_chipselect(struct spi_device *spi, int value)\n{\n\tstruct davinci_spi *dspi;\n\tstruct davinci_spi_config *spicfg = spi->controller_data;\n\tu8 chip_sel = spi_get_chipselect(spi, 0);\n\tu16 spidat1 = CS_DEFAULT;\n\n\tdspi = spi_controller_get_devdata(spi->controller);\n\n\t \n\tif (spicfg && spicfg->wdelay)\n\t\tspidat1 |= SPIDAT1_WDEL;\n\n\t \n\tif (spi_get_csgpiod(spi, 0)) {\n\t\tif (value == BITBANG_CS_ACTIVE)\n\t\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 1);\n\t\telse\n\t\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 0);\n\t} else {\n\t\tif (value == BITBANG_CS_ACTIVE) {\n\t\t\tif (!(spi->mode & SPI_CS_WORD))\n\t\t\t\tspidat1 |= SPIDAT1_CSHOLD_MASK;\n\t\t\tspidat1 &= ~(0x1 << chip_sel);\n\t\t}\n\t}\n\n\tiowrite16(spidat1, dspi->base + SPIDAT1 + 2);\n}\n\n \nstatic inline int davinci_spi_get_prescale(struct davinci_spi *dspi,\n\t\t\t\t\t\t\tu32 max_speed_hz)\n{\n\tint ret;\n\n\t \n\tret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz) - 1;\n\n\tif (ret < dspi->prescaler_limit || ret > 255)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\n \nstatic int davinci_spi_setup_transfer(struct spi_device *spi,\n\t\tstruct spi_transfer *t)\n{\n\n\tstruct davinci_spi *dspi;\n\tstruct davinci_spi_config *spicfg;\n\tu8 bits_per_word = 0;\n\tu32 hz = 0, spifmt = 0;\n\tint prescale;\n\n\tdspi = spi_controller_get_devdata(spi->controller);\n\tspicfg = spi->controller_data;\n\tif (!spicfg)\n\t\tspicfg = &davinci_spi_default_cfg;\n\n\tif (t) {\n\t\tbits_per_word = t->bits_per_word;\n\t\thz = t->speed_hz;\n\t}\n\n\t \n\tif (!bits_per_word)\n\t\tbits_per_word = spi->bits_per_word;\n\n\t \n\tif (bits_per_word <= 8) {\n\t\tdspi->get_rx = davinci_spi_rx_buf_u8;\n\t\tdspi->get_tx = davinci_spi_tx_buf_u8;\n\t\tdspi->bytes_per_word[spi_get_chipselect(spi, 0)] = 1;\n\t} else {\n\t\tdspi->get_rx = davinci_spi_rx_buf_u16;\n\t\tdspi->get_tx = davinci_spi_tx_buf_u16;\n\t\tdspi->bytes_per_word[spi_get_chipselect(spi, 0)] = 2;\n\t}\n\n\tif (!hz)\n\t\thz = spi->max_speed_hz;\n\n\t \n\n\tprescale = davinci_spi_get_prescale(dspi, hz);\n\tif (prescale < 0)\n\t\treturn prescale;\n\n\tspifmt = (prescale << SPIFMT_PRESCALE_SHIFT) | (bits_per_word & 0x1f);\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tspifmt |= SPIFMT_SHIFTDIR_MASK;\n\n\tif (spi->mode & SPI_CPOL)\n\t\tspifmt |= SPIFMT_POLARITY_MASK;\n\n\tif (!(spi->mode & SPI_CPHA))\n\t\tspifmt |= SPIFMT_PHASE_MASK;\n\n\t \n\tif (spicfg->wdelay)\n\t\tspifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)\n\t\t\t\t& SPIFMT_WDELAY_MASK);\n\n\t \n\n\tif (dspi->version == SPI_VERSION_2) {\n\n\t\tu32 delay = 0;\n\n\t\tif (spicfg->odd_parity)\n\t\t\tspifmt |= SPIFMT_ODD_PARITY_MASK;\n\n\t\tif (spicfg->parity_enable)\n\t\t\tspifmt |= SPIFMT_PARITYENA_MASK;\n\n\t\tif (spicfg->timer_disable) {\n\t\t\tspifmt |= SPIFMT_DISTIMER_MASK;\n\t\t} else {\n\t\t\tdelay |= (spicfg->c2tdelay << SPIDELAY_C2TDELAY_SHIFT)\n\t\t\t\t\t\t& SPIDELAY_C2TDELAY_MASK;\n\t\t\tdelay |= (spicfg->t2cdelay << SPIDELAY_T2CDELAY_SHIFT)\n\t\t\t\t\t\t& SPIDELAY_T2CDELAY_MASK;\n\t\t}\n\n\t\tif (spi->mode & SPI_READY) {\n\t\t\tspifmt |= SPIFMT_WAITENA_MASK;\n\t\t\tdelay |= (spicfg->t2edelay << SPIDELAY_T2EDELAY_SHIFT)\n\t\t\t\t\t\t& SPIDELAY_T2EDELAY_MASK;\n\t\t\tdelay |= (spicfg->c2edelay << SPIDELAY_C2EDELAY_SHIFT)\n\t\t\t\t\t\t& SPIDELAY_C2EDELAY_MASK;\n\t\t}\n\n\t\tiowrite32(delay, dspi->base + SPIDELAY);\n\t}\n\n\tiowrite32(spifmt, dspi->base + SPIFMT0);\n\n\treturn 0;\n}\n\nstatic int davinci_spi_of_setup(struct spi_device *spi)\n{\n\tstruct davinci_spi_config *spicfg = spi->controller_data;\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct davinci_spi *dspi = spi_controller_get_devdata(spi->controller);\n\tu32 prop;\n\n\tif (spicfg == NULL && np) {\n\t\tspicfg = kzalloc(sizeof(*spicfg), GFP_KERNEL);\n\t\tif (!spicfg)\n\t\t\treturn -ENOMEM;\n\t\t*spicfg = davinci_spi_default_cfg;\n\t\t \n\t\tif (!of_property_read_u32(np, \"ti,spi-wdelay\", &prop))\n\t\t\tspicfg->wdelay = (u8)prop;\n\t\tspi->controller_data = spicfg;\n\n\t\tif (dspi->dma_rx && dspi->dma_tx)\n\t\t\tspicfg->io_type = SPI_IO_TYPE_DMA;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int davinci_spi_setup(struct spi_device *spi)\n{\n\tstruct davinci_spi *dspi;\n\tstruct device_node *np = spi->dev.of_node;\n\tbool internal_cs = true;\n\n\tdspi = spi_controller_get_devdata(spi->controller);\n\n\tif (!(spi->mode & SPI_NO_CS)) {\n\t\tif (np && spi_get_csgpiod(spi, 0))\n\t\t\tinternal_cs = false;\n\n\t\tif (internal_cs)\n\t\t\tset_io_bits(dspi->base + SPIPC0, 1 << spi_get_chipselect(spi, 0));\n\t}\n\n\tif (spi->mode & SPI_READY)\n\t\tset_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);\n\n\tif (spi->mode & SPI_LOOP)\n\t\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\n\telse\n\t\tclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\n\n\treturn davinci_spi_of_setup(spi);\n}\n\nstatic void davinci_spi_cleanup(struct spi_device *spi)\n{\n\tstruct davinci_spi_config *spicfg = spi->controller_data;\n\n\tspi->controller_data = NULL;\n\tif (spi->dev.of_node)\n\t\tkfree(spicfg);\n}\n\nstatic bool davinci_spi_can_dma(struct spi_controller *host,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct davinci_spi_config *spicfg = spi->controller_data;\n\tbool can_dma = false;\n\n\tif (spicfg)\n\t\tcan_dma = (spicfg->io_type == SPI_IO_TYPE_DMA) &&\n\t\t\t(xfer->len >= DMA_MIN_BYTES) &&\n\t\t\t!is_vmalloc_addr(xfer->rx_buf) &&\n\t\t\t!is_vmalloc_addr(xfer->tx_buf);\n\n\treturn can_dma;\n}\n\nstatic int davinci_spi_check_error(struct davinci_spi *dspi, int int_status)\n{\n\tstruct device *sdev = dspi->bitbang.master->dev.parent;\n\n\tif (int_status & SPIFLG_TIMEOUT_MASK) {\n\t\tdev_err(sdev, \"SPI Time-out Error\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (int_status & SPIFLG_DESYNC_MASK) {\n\t\tdev_err(sdev, \"SPI Desynchronization Error\\n\");\n\t\treturn -EIO;\n\t}\n\tif (int_status & SPIFLG_BITERR_MASK) {\n\t\tdev_err(sdev, \"SPI Bit error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (dspi->version == SPI_VERSION_2) {\n\t\tif (int_status & SPIFLG_DLEN_ERR_MASK) {\n\t\t\tdev_err(sdev, \"SPI Data Length Error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (int_status & SPIFLG_PARERR_MASK) {\n\t\t\tdev_err(sdev, \"SPI Parity Error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (int_status & SPIFLG_OVRRUN_MASK) {\n\t\t\tdev_err(sdev, \"SPI Data Overrun error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (int_status & SPIFLG_BUF_INIT_ACTIVE_MASK) {\n\t\t\tdev_err(sdev, \"SPI Buffer Init Active\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int davinci_spi_process_events(struct davinci_spi *dspi)\n{\n\tu32 buf, status, errors = 0, spidat1;\n\n\tbuf = ioread32(dspi->base + SPIBUF);\n\n\tif (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {\n\t\tdspi->get_rx(buf & 0xFFFF, dspi);\n\t\tdspi->rcount--;\n\t}\n\n\tstatus = ioread32(dspi->base + SPIFLG);\n\n\tif (unlikely(status & SPIFLG_ERROR_MASK)) {\n\t\terrors = status & SPIFLG_ERROR_MASK;\n\t\tgoto out;\n\t}\n\n\tif (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {\n\t\tspidat1 = ioread32(dspi->base + SPIDAT1);\n\t\tdspi->wcount--;\n\t\tspidat1 &= ~0xFFFF;\n\t\tspidat1 |= 0xFFFF & dspi->get_tx(dspi);\n\t\tiowrite32(spidat1, dspi->base + SPIDAT1);\n\t}\n\nout:\n\treturn errors;\n}\n\nstatic void davinci_spi_dma_rx_callback(void *data)\n{\n\tstruct davinci_spi *dspi = (struct davinci_spi *)data;\n\n\tdspi->rcount = 0;\n\n\tif (!dspi->wcount && !dspi->rcount)\n\t\tcomplete(&dspi->done);\n}\n\nstatic void davinci_spi_dma_tx_callback(void *data)\n{\n\tstruct davinci_spi *dspi = (struct davinci_spi *)data;\n\n\tdspi->wcount = 0;\n\n\tif (!dspi->wcount && !dspi->rcount)\n\t\tcomplete(&dspi->done);\n}\n\n \nstatic int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct davinci_spi *dspi;\n\tint data_type, ret = -ENOMEM;\n\tu32 tx_data, spidat1;\n\tu32 errors = 0;\n\tstruct davinci_spi_config *spicfg;\n\tstruct davinci_spi_platform_data *pdata;\n\n\tdspi = spi_controller_get_devdata(spi->controller);\n\tpdata = &dspi->pdata;\n\tspicfg = (struct davinci_spi_config *)spi->controller_data;\n\tif (!spicfg)\n\t\tspicfg = &davinci_spi_default_cfg;\n\n\t \n\tdata_type = dspi->bytes_per_word[spi_get_chipselect(spi, 0)];\n\n\tdspi->tx = t->tx_buf;\n\tdspi->rx = t->rx_buf;\n\tdspi->wcount = t->len / data_type;\n\tdspi->rcount = dspi->wcount;\n\n\tspidat1 = ioread32(dspi->base + SPIDAT1);\n\n\tclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\n\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\n\n\treinit_completion(&dspi->done);\n\n\tif (!davinci_spi_can_dma(spi->controller, spi, t)) {\n\t\tif (spicfg->io_type != SPI_IO_TYPE_POLL)\n\t\t\tset_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\n\t\t \n\t\tdspi->wcount--;\n\t\ttx_data = dspi->get_tx(dspi);\n\t\tspidat1 &= 0xFFFF0000;\n\t\tspidat1 |= tx_data & 0xFFFF;\n\t\tiowrite32(spidat1, dspi->base + SPIDAT1);\n\t} else {\n\t\tstruct dma_slave_config dma_rx_conf = {\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_addr = (unsigned long)dspi->pbase + SPIBUF,\n\t\t\t.src_addr_width = data_type,\n\t\t\t.src_maxburst = 1,\n\t\t};\n\t\tstruct dma_slave_config dma_tx_conf = {\n\t\t\t.direction = DMA_MEM_TO_DEV,\n\t\t\t.dst_addr = (unsigned long)dspi->pbase + SPIDAT1,\n\t\t\t.dst_addr_width = data_type,\n\t\t\t.dst_maxburst = 1,\n\t\t};\n\t\tstruct dma_async_tx_descriptor *rxdesc;\n\t\tstruct dma_async_tx_descriptor *txdesc;\n\n\t\tdmaengine_slave_config(dspi->dma_rx, &dma_rx_conf);\n\t\tdmaengine_slave_config(dspi->dma_tx, &dma_tx_conf);\n\n\t\trxdesc = dmaengine_prep_slave_sg(dspi->dma_rx,\n\t\t\t\tt->rx_sg.sgl, t->rx_sg.nents, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!rxdesc)\n\t\t\tgoto err_desc;\n\n\t\tif (!t->tx_buf) {\n\t\t\t \n\t\t\tt->tx_sg.sgl = t->rx_sg.sgl;\n\t\t\tt->tx_sg.nents = t->rx_sg.nents;\n\t\t}\n\n\t\ttxdesc = dmaengine_prep_slave_sg(dspi->dma_tx,\n\t\t\t\tt->tx_sg.sgl, t->tx_sg.nents, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!txdesc)\n\t\t\tgoto err_desc;\n\n\t\trxdesc->callback = davinci_spi_dma_rx_callback;\n\t\trxdesc->callback_param = (void *)dspi;\n\t\ttxdesc->callback = davinci_spi_dma_tx_callback;\n\t\ttxdesc->callback_param = (void *)dspi;\n\n\t\tif (pdata->cshold_bug)\n\t\t\tiowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);\n\n\t\tdmaengine_submit(rxdesc);\n\t\tdmaengine_submit(txdesc);\n\n\t\tdma_async_issue_pending(dspi->dma_rx);\n\t\tdma_async_issue_pending(dspi->dma_tx);\n\n\t\tset_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\n\t}\n\n\t \n\tif (spicfg->io_type != SPI_IO_TYPE_POLL) {\n\t\tif (wait_for_completion_timeout(&dspi->done, HZ) == 0)\n\t\t\terrors = SPIFLG_TIMEOUT_MASK;\n\t} else {\n\t\twhile (dspi->rcount > 0 || dspi->wcount > 0) {\n\t\t\terrors = davinci_spi_process_events(dspi);\n\t\t\tif (errors)\n\t\t\t\tbreak;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\tclear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);\n\tif (davinci_spi_can_dma(spi->controller, spi, t))\n\t\tclear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\n\n\tclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\n\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\n\n\t \n\tif (errors) {\n\t\tret = davinci_spi_check_error(dspi, errors);\n\t\tWARN(!ret, \"%s: error reported but no error found!\\n\",\n\t\t\t\t\t\t\tdev_name(&spi->dev));\n\t\treturn ret;\n\t}\n\n\tif (dspi->rcount != 0 || dspi->wcount != 0) {\n\t\tdev_err(&spi->dev, \"SPI data transfer error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn t->len;\n\nerr_desc:\n\treturn ret;\n}\n\n \nstatic irqreturn_t dummy_thread_fn(s32 irq, void *data)\n{\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t davinci_spi_irq(s32 irq, void *data)\n{\n\tstruct davinci_spi *dspi = data;\n\tint status;\n\n\tstatus = davinci_spi_process_events(dspi);\n\tif (unlikely(status != 0))\n\t\tclear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\n\n\tif ((!dspi->rcount && !dspi->wcount) || status)\n\t\tcomplete(&dspi->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int davinci_spi_request_dma(struct davinci_spi *dspi)\n{\n\tstruct device *sdev = dspi->bitbang.master->dev.parent;\n\n\tdspi->dma_rx = dma_request_chan(sdev, \"rx\");\n\tif (IS_ERR(dspi->dma_rx))\n\t\treturn PTR_ERR(dspi->dma_rx);\n\n\tdspi->dma_tx = dma_request_chan(sdev, \"tx\");\n\tif (IS_ERR(dspi->dma_tx)) {\n\t\tdma_release_channel(dspi->dma_rx);\n\t\treturn PTR_ERR(dspi->dma_tx);\n\t}\n\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\n\n \nstruct davinci_spi_of_data {\n\tu8\tversion;\n\tu8\tprescaler_limit;\n};\n\nstatic const struct davinci_spi_of_data dm6441_spi_data = {\n\t.version = SPI_VERSION_1,\n\t.prescaler_limit = 2,\n};\n\nstatic const struct davinci_spi_of_data da830_spi_data = {\n\t.version = SPI_VERSION_2,\n\t.prescaler_limit = 2,\n};\n\nstatic const struct davinci_spi_of_data keystone_spi_data = {\n\t.version = SPI_VERSION_1,\n\t.prescaler_limit = 0,\n};\n\nstatic const struct of_device_id davinci_spi_of_match[] = {\n\t{\n\t\t.compatible = \"ti,dm6441-spi\",\n\t\t.data = &dm6441_spi_data,\n\t},\n\t{\n\t\t.compatible = \"ti,da830-spi\",\n\t\t.data = &da830_spi_data,\n\t},\n\t{\n\t\t.compatible = \"ti,keystone-spi\",\n\t\t.data = &keystone_spi_data,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, davinci_spi_of_match);\n\n \nstatic int spi_davinci_get_pdata(struct platform_device *pdev,\n\t\t\tstruct davinci_spi *dspi)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct davinci_spi_of_data *spi_data;\n\tstruct davinci_spi_platform_data *pdata;\n\tunsigned int num_cs, intr_line = 0;\n\n\tpdata = &dspi->pdata;\n\n\tspi_data = device_get_match_data(&pdev->dev);\n\n\tpdata->version = spi_data->version;\n\tpdata->prescaler_limit = spi_data->prescaler_limit;\n\t \n\tnum_cs = 1;\n\tof_property_read_u32(node, \"num-cs\", &num_cs);\n\tpdata->num_chipselect = num_cs;\n\tof_property_read_u32(node, \"ti,davinci-spi-intr-line\", &intr_line);\n\tpdata->intr_line = intr_line;\n\treturn 0;\n}\n#else\nstatic int spi_davinci_get_pdata(struct platform_device *pdev,\n\t\t\tstruct davinci_spi *dspi)\n{\n\treturn -ENODEV;\n}\n#endif\n\n \nstatic int davinci_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct davinci_spi *dspi;\n\tstruct davinci_spi_platform_data *pdata;\n\tstruct resource *r;\n\tint ret = 0;\n\tu32 spipc0;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(struct davinci_spi));\n\tif (host == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, host);\n\n\tdspi = spi_controller_get_devdata(host);\n\n\tif (dev_get_platdata(&pdev->dev)) {\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tdspi->pdata = *pdata;\n\t} else {\n\t\t \n\t\tret = spi_davinci_get_pdata(pdev, dspi);\n\t\tif (ret < 0)\n\t\t\tgoto free_host;\n\t}\n\n\t \n\tpdata = &dspi->pdata;\n\n\tdspi->bytes_per_word = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t    pdata->num_chipselect,\n\t\t\t\t\t    sizeof(*dspi->bytes_per_word),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (dspi->bytes_per_word == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto free_host;\n\t}\n\n\tdspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(dspi->base)) {\n\t\tret = PTR_ERR(dspi->base);\n\t\tgoto free_host;\n\t}\n\tdspi->pbase = r->start;\n\n\tinit_completion(&dspi->done);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto free_host;\n\tdspi->irq = ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev, dspi->irq, davinci_spi_irq,\n\t\t\t\tdummy_thread_fn, 0, dev_name(&pdev->dev), dspi);\n\tif (ret)\n\t\tgoto free_host;\n\n\tdspi->bitbang.master = host;\n\n\tdspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dspi->clk)) {\n\t\tret = -ENODEV;\n\t\tgoto free_host;\n\t}\n\tret = clk_prepare_enable(dspi->clk);\n\tif (ret)\n\t\tgoto free_host;\n\n\thost->use_gpio_descriptors = true;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = pdev->id;\n\thost->num_chipselect = pdata->num_chipselect;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 16);\n\thost->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_GPIO_SS;\n\thost->setup = davinci_spi_setup;\n\thost->cleanup = davinci_spi_cleanup;\n\thost->can_dma = davinci_spi_can_dma;\n\n\tdspi->bitbang.chipselect = davinci_spi_chipselect;\n\tdspi->bitbang.setup_transfer = davinci_spi_setup_transfer;\n\tdspi->prescaler_limit = pdata->prescaler_limit;\n\tdspi->version = pdata->version;\n\n\tdspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP | SPI_CS_WORD;\n\tif (dspi->version == SPI_VERSION_2)\n\t\tdspi->bitbang.flags |= SPI_READY;\n\n\tdspi->bitbang.txrx_bufs = davinci_spi_bufs;\n\n\tret = davinci_spi_request_dma(dspi);\n\tif (ret == -EPROBE_DEFER) {\n\t\tgoto free_clk;\n\t} else if (ret) {\n\t\tdev_info(&pdev->dev, \"DMA is not supported (%d)\\n\", ret);\n\t\tdspi->dma_rx = NULL;\n\t\tdspi->dma_tx = NULL;\n\t}\n\n\tdspi->get_rx = davinci_spi_rx_buf_u8;\n\tdspi->get_tx = davinci_spi_tx_buf_u8;\n\n\t \n\tiowrite32(0, dspi->base + SPIGCR0);\n\tudelay(100);\n\tiowrite32(1, dspi->base + SPIGCR0);\n\n\t \n\tspipc0 = SPIPC0_DIFUN_MASK | SPIPC0_DOFUN_MASK | SPIPC0_CLKFUN_MASK;\n\tiowrite32(spipc0, dspi->base + SPIPC0);\n\n\tif (pdata->intr_line)\n\t\tiowrite32(SPI_INTLVL_1, dspi->base + SPILVL);\n\telse\n\t\tiowrite32(SPI_INTLVL_0, dspi->base + SPILVL);\n\n\tiowrite32(CS_DEFAULT, dspi->base + SPIDEF);\n\n\t \n\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);\n\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);\n\tset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\n\n\tret = spi_bitbang_start(&dspi->bitbang);\n\tif (ret)\n\t\tgoto free_dma;\n\n\tdev_info(&pdev->dev, \"Controller at 0x%p\\n\", dspi->base);\n\n\treturn ret;\n\nfree_dma:\n\tif (dspi->dma_rx) {\n\t\tdma_release_channel(dspi->dma_rx);\n\t\tdma_release_channel(dspi->dma_tx);\n\t}\nfree_clk:\n\tclk_disable_unprepare(dspi->clk);\nfree_host:\n\tspi_controller_put(host);\nerr:\n\treturn ret;\n}\n\n \nstatic void davinci_spi_remove(struct platform_device *pdev)\n{\n\tstruct davinci_spi *dspi;\n\tstruct spi_controller *host;\n\n\thost = platform_get_drvdata(pdev);\n\tdspi = spi_controller_get_devdata(host);\n\n\tspi_bitbang_stop(&dspi->bitbang);\n\n\tclk_disable_unprepare(dspi->clk);\n\n\tif (dspi->dma_rx) {\n\t\tdma_release_channel(dspi->dma_rx);\n\t\tdma_release_channel(dspi->dma_tx);\n\t}\n\n\tspi_controller_put(host);\n}\n\nstatic struct platform_driver davinci_spi_driver = {\n\t.driver = {\n\t\t.name = \"spi_davinci\",\n\t\t.of_match_table = of_match_ptr(davinci_spi_of_match),\n\t},\n\t.probe = davinci_spi_probe,\n\t.remove_new = davinci_spi_remove,\n};\nmodule_platform_driver(davinci_spi_driver);\n\nMODULE_DESCRIPTION(\"TI DaVinci SPI Master Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}