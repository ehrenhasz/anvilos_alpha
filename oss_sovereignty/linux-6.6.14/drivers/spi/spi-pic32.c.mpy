{
  "module_name": "spi-pic32.c",
  "hash_id": "894dd96faef27c2dd9e15f9897a139fbd7225fdf5e4c241a50f1d25c94b8847e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-pic32.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_gpio.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n \nstruct pic32_spi_regs {\n\tu32 ctrl;\n\tu32 ctrl_clr;\n\tu32 ctrl_set;\n\tu32 ctrl_inv;\n\tu32 status;\n\tu32 status_clr;\n\tu32 status_set;\n\tu32 status_inv;\n\tu32 buf;\n\tu32 dontuse[3];\n\tu32 baud;\n\tu32 dontuse2[3];\n\tu32 ctrl2;\n\tu32 ctrl2_clr;\n\tu32 ctrl2_set;\n\tu32 ctrl2_inv;\n};\n\n \n#define CTRL_RX_INT_SHIFT\t0   \n#define  RX_FIFO_EMPTY\t\t0\n#define  RX_FIFO_NOT_EMPTY\t1  \n#define  RX_FIFO_HALF_FULL\t2  \n#define  RX_FIFO_FULL\t\t3  \n\n#define CTRL_TX_INT_SHIFT\t2   \n#define  TX_FIFO_ALL_EMPTY\t0  \n#define  TX_FIFO_EMPTY\t\t1  \n#define  TX_FIFO_HALF_EMPTY\t2  \n#define  TX_FIFO_NOT_FULL\t3  \n\n#define CTRL_MSTEN\tBIT(5)  \n#define CTRL_CKP\tBIT(6)  \n#define CTRL_CKE\tBIT(8)  \n#define CTRL_SMP\tBIT(9)  \n#define CTRL_BPW_MASK\t0x03    \n#define CTRL_BPW_SHIFT\t10\n#define  PIC32_BPW_8\t0\n#define  PIC32_BPW_16\t1\n#define  PIC32_BPW_32\t2\n#define CTRL_SIDL\tBIT(13)  \n#define CTRL_ON\t\tBIT(15)  \n#define CTRL_ENHBUF\tBIT(16)  \n#define CTRL_MCLKSEL\tBIT(23)  \n#define CTRL_MSSEN\tBIT(28)  \n#define CTRL_FRMEN\tBIT(31)  \n\n \n#define STAT_RF_EMPTY\tBIT(5)  \n#define STAT_RX_OV\tBIT(6)  \n#define STAT_TX_UR\tBIT(8)  \n#define STAT_FRM_ERR\tBIT(12)  \n#define STAT_TF_LVL_MASK\t0x1F\n#define STAT_TF_LVL_SHIFT\t16\n#define STAT_RF_LVL_MASK\t0x1F\n#define STAT_RF_LVL_SHIFT\t24\n\n \n#define BAUD_MASK\t\t0x1ff\n\n \n#define CTRL2_TX_UR_EN\t\tBIT(10)  \n#define CTRL2_RX_OV_EN\t\tBIT(11)  \n#define CTRL2_FRM_ERR_EN\tBIT(12)  \n\n \n#define PIC32_DMA_LEN_MIN\t64\n\nstruct pic32_spi {\n\tdma_addr_t\t\tdma_base;\n\tstruct pic32_spi_regs __iomem *regs;\n\tint\t\t\tfault_irq;\n\tint\t\t\trx_irq;\n\tint\t\t\ttx_irq;\n\tu32\t\t\tfifo_n_byte;  \n\tstruct clk\t\t*clk;\n\tstruct spi_controller\t*host;\n\t \n\tu32\t\t\tspeed_hz;  \n\tu32\t\t\tmode;\n\tu32\t\t\tbits_per_word;\n\tu32\t\t\tfifo_n_elm;  \n#define PIC32F_DMA_PREP\t\t0  \n\tunsigned long\t\tflags;\n\t \n\tstruct completion\txfer_done;\n\t \n\tconst void\t\t*tx;\n\tconst void\t\t*tx_end;\n\tconst void\t\t*rx;\n\tconst void\t\t*rx_end;\n\tint\t\t\tlen;\n\tvoid (*rx_fifo)(struct pic32_spi *);\n\tvoid (*tx_fifo)(struct pic32_spi *);\n};\n\nstatic inline void pic32_spi_enable(struct pic32_spi *pic32s)\n{\n\twritel(CTRL_ON | CTRL_SIDL, &pic32s->regs->ctrl_set);\n}\n\nstatic inline void pic32_spi_disable(struct pic32_spi *pic32s)\n{\n\twritel(CTRL_ON | CTRL_SIDL, &pic32s->regs->ctrl_clr);\n\n\t \n\tndelay(20);\n}\n\nstatic void pic32_spi_set_clk_rate(struct pic32_spi *pic32s, u32 spi_ck)\n{\n\tu32 div;\n\n\t \n\tdiv = DIV_ROUND_CLOSEST(clk_get_rate(pic32s->clk), 2 * spi_ck) - 1;\n\n\twritel(div & BAUD_MASK, &pic32s->regs->baud);\n}\n\nstatic inline u32 pic32_rx_fifo_level(struct pic32_spi *pic32s)\n{\n\tu32 sr = readl(&pic32s->regs->status);\n\n\treturn (sr >> STAT_RF_LVL_SHIFT) & STAT_RF_LVL_MASK;\n}\n\nstatic inline u32 pic32_tx_fifo_level(struct pic32_spi *pic32s)\n{\n\tu32 sr = readl(&pic32s->regs->status);\n\n\treturn (sr >> STAT_TF_LVL_SHIFT) & STAT_TF_LVL_MASK;\n}\n\n \nstatic u32 pic32_tx_max(struct pic32_spi *pic32s, int n_bytes)\n{\n\tu32 tx_left, tx_room, rxtx_gap;\n\n\ttx_left = (pic32s->tx_end - pic32s->tx) / n_bytes;\n\ttx_room = pic32s->fifo_n_elm - pic32_tx_fifo_level(pic32s);\n\n\t \n\trxtx_gap = ((pic32s->rx_end - pic32s->rx) -\n\t\t    (pic32s->tx_end - pic32s->tx)) / n_bytes;\n\treturn min3(tx_left, tx_room, (u32)(pic32s->fifo_n_elm - rxtx_gap));\n}\n\n \nstatic u32 pic32_rx_max(struct pic32_spi *pic32s, int n_bytes)\n{\n\tu32 rx_left = (pic32s->rx_end - pic32s->rx) / n_bytes;\n\n\treturn min_t(u32, rx_left, pic32_rx_fifo_level(pic32s));\n}\n\n#define BUILD_SPI_FIFO_RW(__name, __type, __bwl)\t\t\\\nstatic void pic32_spi_rx_##__name(struct pic32_spi *pic32s)\t\\\n{\t\t\t\t\t\t\t\t\\\n\t__type v;\t\t\t\t\t\t\\\n\tu32 mx = pic32_rx_max(pic32s, sizeof(__type));\t\t\\\n\tfor (; mx; mx--) {\t\t\t\t\t\\\n\t\tv = read##__bwl(&pic32s->regs->buf);\t\t\\\n\t\tif (pic32s->rx_end - pic32s->len)\t\t\\\n\t\t\t*(__type *)(pic32s->rx) = v;\t\t\\\n\t\tpic32s->rx += sizeof(__type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic void pic32_spi_tx_##__name(struct pic32_spi *pic32s)\t\\\n{\t\t\t\t\t\t\t\t\\\n\t__type v;\t\t\t\t\t\t\\\n\tu32 mx = pic32_tx_max(pic32s, sizeof(__type));\t\t\\\n\tfor (; mx ; mx--) {\t\t\t\t\t\\\n\t\tv = (__type)~0U;\t\t\t\t\\\n\t\tif (pic32s->tx_end - pic32s->len)\t\t\\\n\t\t\tv = *(__type *)(pic32s->tx);\t\t\\\n\t\twrite##__bwl(v, &pic32s->regs->buf);\t\t\\\n\t\tpic32s->tx += sizeof(__type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n}\n\nBUILD_SPI_FIFO_RW(byte, u8, b);\nBUILD_SPI_FIFO_RW(word, u16, w);\nBUILD_SPI_FIFO_RW(dword, u32, l);\n\nstatic void pic32_err_stop(struct pic32_spi *pic32s, const char *msg)\n{\n\t \n\tdisable_irq_nosync(pic32s->fault_irq);\n\tdisable_irq_nosync(pic32s->rx_irq);\n\tdisable_irq_nosync(pic32s->tx_irq);\n\n\t \n\tdev_err(&pic32s->host->dev, \"%s\\n\", msg);\n\tif (pic32s->host->cur_msg)\n\t\tpic32s->host->cur_msg->status = -EIO;\n\tcomplete(&pic32s->xfer_done);\n}\n\nstatic irqreturn_t pic32_spi_fault_irq(int irq, void *dev_id)\n{\n\tstruct pic32_spi *pic32s = dev_id;\n\tu32 status;\n\n\tstatus = readl(&pic32s->regs->status);\n\n\t \n\tif (status & (STAT_RX_OV | STAT_TX_UR)) {\n\t\twritel(STAT_RX_OV, &pic32s->regs->status_clr);\n\t\twritel(STAT_TX_UR, &pic32s->regs->status_clr);\n\t\tpic32_err_stop(pic32s, \"err_irq: fifo ov/ur-run\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (status & STAT_FRM_ERR) {\n\t\tpic32_err_stop(pic32s, \"err_irq: frame error\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!pic32s->host->cur_msg) {\n\t\tpic32_err_stop(pic32s, \"err_irq: no mesg\");\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t pic32_spi_rx_irq(int irq, void *dev_id)\n{\n\tstruct pic32_spi *pic32s = dev_id;\n\n\tpic32s->rx_fifo(pic32s);\n\n\t \n\tif (pic32s->rx_end == pic32s->rx) {\n\t\t \n\t\tdisable_irq_nosync(pic32s->fault_irq);\n\t\tdisable_irq_nosync(pic32s->rx_irq);\n\n\t\t \n\t\tcomplete(&pic32s->xfer_done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pic32_spi_tx_irq(int irq, void *dev_id)\n{\n\tstruct pic32_spi *pic32s = dev_id;\n\n\tpic32s->tx_fifo(pic32s);\n\n\t \n\tif (pic32s->tx_end == pic32s->tx)\n\t\tdisable_irq_nosync(pic32s->tx_irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pic32_spi_dma_rx_notify(void *data)\n{\n\tstruct pic32_spi *pic32s = data;\n\n\tcomplete(&pic32s->xfer_done);\n}\n\nstatic int pic32_spi_dma_transfer(struct pic32_spi *pic32s,\n\t\t\t\t  struct spi_transfer *xfer)\n{\n\tstruct spi_controller *host = pic32s->host;\n\tstruct dma_async_tx_descriptor *desc_rx;\n\tstruct dma_async_tx_descriptor *desc_tx;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (!host->dma_rx || !host->dma_tx)\n\t\treturn -ENODEV;\n\n\tdesc_rx = dmaengine_prep_slave_sg(host->dma_rx,\n\t\t\t\t\t  xfer->rx_sg.sgl,\n\t\t\t\t\t  xfer->rx_sg.nents,\n\t\t\t\t\t  DMA_DEV_TO_MEM,\n\t\t\t\t\t  DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx) {\n\t\tret = -EINVAL;\n\t\tgoto err_dma;\n\t}\n\n\tdesc_tx = dmaengine_prep_slave_sg(host->dma_tx,\n\t\t\t\t\t  xfer->tx_sg.sgl,\n\t\t\t\t\t  xfer->tx_sg.nents,\n\t\t\t\t\t  DMA_MEM_TO_DEV,\n\t\t\t\t\t  DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tret = -EINVAL;\n\t\tgoto err_dma;\n\t}\n\n\t \n\tdesc_rx->callback = pic32_spi_dma_rx_notify;\n\tdesc_rx->callback_param = pic32s;\n\n\tcookie = dmaengine_submit(desc_rx);\n\tret = dma_submit_error(cookie);\n\tif (ret)\n\t\tgoto err_dma;\n\n\tcookie = dmaengine_submit(desc_tx);\n\tret = dma_submit_error(cookie);\n\tif (ret)\n\t\tgoto err_dma_tx;\n\n\tdma_async_issue_pending(host->dma_rx);\n\tdma_async_issue_pending(host->dma_tx);\n\n\treturn 0;\n\nerr_dma_tx:\n\tdmaengine_terminate_all(host->dma_rx);\nerr_dma:\n\treturn ret;\n}\n\nstatic int pic32_spi_dma_config(struct pic32_spi *pic32s, u32 dma_width)\n{\n\tint buf_offset = offsetof(struct pic32_spi_regs, buf);\n\tstruct spi_controller *host = pic32s->host;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.device_fc = true;\n\tcfg.src_addr = pic32s->dma_base + buf_offset;\n\tcfg.dst_addr = pic32s->dma_base + buf_offset;\n\tcfg.src_maxburst = pic32s->fifo_n_elm / 2;  \n\tcfg.dst_maxburst = pic32s->fifo_n_elm / 2;  \n\tcfg.src_addr_width = dma_width;\n\tcfg.dst_addr_width = dma_width;\n\t \n\tcfg.direction = DMA_MEM_TO_DEV;\n\tret = dmaengine_slave_config(host->dma_tx, &cfg);\n\tif (ret) {\n\t\tdev_err(&host->dev, \"tx channel setup failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tcfg.direction = DMA_DEV_TO_MEM;\n\tret = dmaengine_slave_config(host->dma_rx, &cfg);\n\tif (ret)\n\t\tdev_err(&host->dev, \"rx channel setup failed\\n\");\n\n\treturn ret;\n}\n\nstatic int pic32_spi_set_word_size(struct pic32_spi *pic32s, u8 bits_per_word)\n{\n\tenum dma_slave_buswidth dmawidth;\n\tu32 buswidth, v;\n\n\tswitch (bits_per_word) {\n\tcase 8:\n\t\tpic32s->rx_fifo = pic32_spi_rx_byte;\n\t\tpic32s->tx_fifo = pic32_spi_tx_byte;\n\t\tbuswidth = PIC32_BPW_8;\n\t\tdmawidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tcase 16:\n\t\tpic32s->rx_fifo = pic32_spi_rx_word;\n\t\tpic32s->tx_fifo = pic32_spi_tx_word;\n\t\tbuswidth = PIC32_BPW_16;\n\t\tdmawidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 32:\n\t\tpic32s->rx_fifo = pic32_spi_rx_dword;\n\t\tpic32s->tx_fifo = pic32_spi_tx_dword;\n\t\tbuswidth = PIC32_BPW_32;\n\t\tdmawidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpic32s->fifo_n_elm = DIV_ROUND_UP(pic32s->fifo_n_byte,\n\t\t\t\t\t  bits_per_word / 8);\n\t \n\tv = readl(&pic32s->regs->ctrl);\n\tv &= ~(CTRL_BPW_MASK << CTRL_BPW_SHIFT);\n\tv |= buswidth << CTRL_BPW_SHIFT;\n\twritel(v, &pic32s->regs->ctrl);\n\n\t \n\tif (test_bit(PIC32F_DMA_PREP, &pic32s->flags))\n\t\tpic32_spi_dma_config(pic32s, dmawidth);\n\n\treturn 0;\n}\n\nstatic int pic32_spi_prepare_hardware(struct spi_controller *host)\n{\n\tstruct pic32_spi *pic32s = spi_controller_get_devdata(host);\n\n\tpic32_spi_enable(pic32s);\n\n\treturn 0;\n}\n\nstatic int pic32_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t     struct spi_message *msg)\n{\n\tstruct pic32_spi *pic32s = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = msg->spi;\n\tu32 val;\n\n\t \n\tif (pic32s->bits_per_word != spi->bits_per_word) {\n\t\tpic32_spi_set_word_size(pic32s, spi->bits_per_word);\n\t\tpic32s->bits_per_word = spi->bits_per_word;\n\t}\n\n\t \n\tif (pic32s->speed_hz != spi->max_speed_hz) {\n\t\tpic32_spi_set_clk_rate(pic32s, spi->max_speed_hz);\n\t\tpic32s->speed_hz = spi->max_speed_hz;\n\t}\n\n\t \n\tif (pic32s->mode != spi->mode) {\n\t\tval = readl(&pic32s->regs->ctrl);\n\t\t \n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tval |= CTRL_CKP;\n\t\telse\n\t\t\tval &= ~CTRL_CKP;\n\t\t \n\t\tif (spi->mode & SPI_CPHA)\n\t\t\tval &= ~CTRL_CKE;\n\t\telse\n\t\t\tval |= CTRL_CKE;\n\n\t\t \n\t\tval |= CTRL_SMP;\n\t\twritel(val, &pic32s->regs->ctrl);\n\t\tpic32s->mode = spi->mode;\n\t}\n\n\treturn 0;\n}\n\nstatic bool pic32_spi_can_dma(struct spi_controller *host,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct pic32_spi *pic32s = spi_controller_get_devdata(host);\n\n\t \n\treturn (xfer->len >= PIC32_DMA_LEN_MIN) &&\n\t       test_bit(PIC32F_DMA_PREP, &pic32s->flags);\n}\n\nstatic int pic32_spi_one_transfer(struct spi_controller *host,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *transfer)\n{\n\tstruct pic32_spi *pic32s;\n\tbool dma_issued = false;\n\tunsigned long timeout;\n\tint ret;\n\n\tpic32s = spi_controller_get_devdata(host);\n\n\t \n\tif (transfer->bits_per_word &&\n\t    (transfer->bits_per_word != pic32s->bits_per_word)) {\n\t\tret = pic32_spi_set_word_size(pic32s, transfer->bits_per_word);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpic32s->bits_per_word = transfer->bits_per_word;\n\t}\n\n\t \n\tif (transfer->speed_hz && (transfer->speed_hz != pic32s->speed_hz)) {\n\t\tpic32_spi_set_clk_rate(pic32s, transfer->speed_hz);\n\t\tpic32s->speed_hz = transfer->speed_hz;\n\t}\n\n\treinit_completion(&pic32s->xfer_done);\n\n\t \n\tif (transfer->rx_sg.nents && transfer->tx_sg.nents) {\n\t\tret = pic32_spi_dma_transfer(pic32s, transfer);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"dma submit error\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdma_issued = true;\n\t} else {\n\t\t \n\t\tpic32s->tx = (const void *)transfer->tx_buf;\n\t\tpic32s->rx = (const void *)transfer->rx_buf;\n\t\tpic32s->tx_end = pic32s->tx + transfer->len;\n\t\tpic32s->rx_end = pic32s->rx + transfer->len;\n\t\tpic32s->len = transfer->len;\n\n\t\t \n\t\tenable_irq(pic32s->fault_irq);\n\t\tenable_irq(pic32s->rx_irq);\n\t\tenable_irq(pic32s->tx_irq);\n\t}\n\n\t \n\ttimeout = wait_for_completion_timeout(&pic32s->xfer_done, 2 * HZ);\n\tif (timeout == 0) {\n\t\tdev_err(&spi->dev, \"wait error/timedout\\n\");\n\t\tif (dma_issued) {\n\t\t\tdmaengine_terminate_all(host->dma_rx);\n\t\t\tdmaengine_terminate_all(host->dma_tx);\n\t\t}\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int pic32_spi_unprepare_message(struct spi_controller *host,\n\t\t\t\t       struct spi_message *msg)\n{\n\t \n\treturn 0;\n}\n\nstatic int pic32_spi_unprepare_hardware(struct spi_controller *host)\n{\n\tstruct pic32_spi *pic32s = spi_controller_get_devdata(host);\n\n\tpic32_spi_disable(pic32s);\n\n\treturn 0;\n}\n\n \nstatic int pic32_spi_setup(struct spi_device *spi)\n{\n\tif (!spi->max_speed_hz) {\n\t\tdev_err(&spi->dev, \"No max speed HZ parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!spi_get_csgpiod(spi, 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void pic32_spi_cleanup(struct spi_device *spi)\n{\n\t \n\tgpiod_direction_output(spi_get_csgpiod(spi, 0), 0);\n}\n\nstatic int pic32_spi_dma_prep(struct pic32_spi *pic32s, struct device *dev)\n{\n\tstruct spi_controller *host = pic32s->host;\n\tint ret = 0;\n\n\thost->dma_rx = dma_request_chan(dev, \"spi-rx\");\n\tif (IS_ERR(host->dma_rx)) {\n\t\tif (PTR_ERR(host->dma_rx) == -EPROBE_DEFER)\n\t\t\tret = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_warn(dev, \"RX channel not found.\\n\");\n\n\t\thost->dma_rx = NULL;\n\t\tgoto out_err;\n\t}\n\n\thost->dma_tx = dma_request_chan(dev, \"spi-tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\tif (PTR_ERR(host->dma_tx) == -EPROBE_DEFER)\n\t\t\tret = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_warn(dev, \"TX channel not found.\\n\");\n\n\t\thost->dma_tx = NULL;\n\t\tgoto out_err;\n\t}\n\n\tif (pic32_spi_dma_config(pic32s, DMA_SLAVE_BUSWIDTH_1_BYTE))\n\t\tgoto out_err;\n\n\t \n\tset_bit(PIC32F_DMA_PREP, &pic32s->flags);\n\n\treturn 0;\n\nout_err:\n\tif (host->dma_rx) {\n\t\tdma_release_channel(host->dma_rx);\n\t\thost->dma_rx = NULL;\n\t}\n\n\tif (host->dma_tx) {\n\t\tdma_release_channel(host->dma_tx);\n\t\thost->dma_tx = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void pic32_spi_dma_unprep(struct pic32_spi *pic32s)\n{\n\tif (!test_bit(PIC32F_DMA_PREP, &pic32s->flags))\n\t\treturn;\n\n\tclear_bit(PIC32F_DMA_PREP, &pic32s->flags);\n\tif (pic32s->host->dma_rx)\n\t\tdma_release_channel(pic32s->host->dma_rx);\n\n\tif (pic32s->host->dma_tx)\n\t\tdma_release_channel(pic32s->host->dma_tx);\n}\n\nstatic void pic32_spi_hw_init(struct pic32_spi *pic32s)\n{\n\tu32 ctrl;\n\n\t \n\tpic32_spi_disable(pic32s);\n\n\tctrl = readl(&pic32s->regs->ctrl);\n\t \n\tctrl |= CTRL_ENHBUF;\n\tpic32s->fifo_n_byte = 16;\n\n\t \n\tctrl &= ~CTRL_FRMEN;\n\n\t \n\tctrl |= CTRL_MSTEN;\n\n\t \n\tctrl &= ~(0x3 << CTRL_TX_INT_SHIFT);\n\tctrl |= (TX_FIFO_HALF_EMPTY << CTRL_TX_INT_SHIFT);\n\n\t \n\tctrl &= ~(0x3 << CTRL_RX_INT_SHIFT);\n\tctrl |= (RX_FIFO_NOT_EMPTY << CTRL_RX_INT_SHIFT);\n\n\t \n\tctrl &= ~CTRL_MCLKSEL;\n\n\t \n\tctrl &= ~CTRL_MSSEN;\n\n\twritel(ctrl, &pic32s->regs->ctrl);\n\n\t \n\tctrl = CTRL2_TX_UR_EN | CTRL2_RX_OV_EN | CTRL2_FRM_ERR_EN;\n\twritel(ctrl, &pic32s->regs->ctrl2_set);\n}\n\nstatic int pic32_spi_hw_probe(struct platform_device *pdev,\n\t\t\t      struct pic32_spi *pic32s)\n{\n\tstruct resource *mem;\n\tint ret;\n\n\tpic32s->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(pic32s->regs))\n\t\treturn PTR_ERR(pic32s->regs);\n\n\tpic32s->dma_base = mem->start;\n\n\t \n\tpic32s->fault_irq = platform_get_irq_byname(pdev, \"fault\");\n\tif (pic32s->fault_irq < 0)\n\t\treturn pic32s->fault_irq;\n\n\tpic32s->rx_irq = platform_get_irq_byname(pdev, \"rx\");\n\tif (pic32s->rx_irq < 0)\n\t\treturn pic32s->rx_irq;\n\n\tpic32s->tx_irq = platform_get_irq_byname(pdev, \"tx\");\n\tif (pic32s->tx_irq < 0)\n\t\treturn pic32s->tx_irq;\n\n\t \n\tpic32s->clk = devm_clk_get(&pdev->dev, \"mck0\");\n\tif (IS_ERR(pic32s->clk)) {\n\t\tdev_err(&pdev->dev, \"clk not found\\n\");\n\t\tret = PTR_ERR(pic32s->clk);\n\t\tgoto err_unmap_mem;\n\t}\n\n\tret = clk_prepare_enable(pic32s->clk);\n\tif (ret)\n\t\tgoto err_unmap_mem;\n\n\tpic32_spi_hw_init(pic32s);\n\n\treturn 0;\n\nerr_unmap_mem:\n\tdev_err(&pdev->dev, \"%s failed, err %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int pic32_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct pic32_spi *pic32s;\n\tint ret;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*pic32s));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tpic32s = spi_controller_get_devdata(host);\n\tpic32s->host = host;\n\n\tret = pic32_spi_hw_probe(pdev, pic32s);\n\tif (ret)\n\t\tgoto err_host;\n\n\thost->dev.of_node\t= pdev->dev.of_node;\n\thost->mode_bits\t= SPI_MODE_3 | SPI_MODE_0 | SPI_CS_HIGH;\n\thost->num_chipselect\t= 1;  \n\thost->max_speed_hz\t= clk_get_rate(pic32s->clk);\n\thost->setup\t\t= pic32_spi_setup;\n\thost->cleanup\t\t= pic32_spi_cleanup;\n\thost->flags\t\t= SPI_CONTROLLER_MUST_TX | SPI_CONTROLLER_MUST_RX;\n\thost->bits_per_word_mask\t= SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\n\t\t\t\t\t  SPI_BPW_MASK(32);\n\thost->transfer_one\t\t= pic32_spi_one_transfer;\n\thost->prepare_message\t\t= pic32_spi_prepare_message;\n\thost->unprepare_message\t= pic32_spi_unprepare_message;\n\thost->prepare_transfer_hardware\t= pic32_spi_prepare_hardware;\n\thost->unprepare_transfer_hardware\t= pic32_spi_unprepare_hardware;\n\thost->use_gpio_descriptors = true;\n\n\t \n\tret = pic32_spi_dma_prep(pic32s, &pdev->dev);\n\tif (ret)\n\t\tgoto err_bailout;\n\n\tif (test_bit(PIC32F_DMA_PREP, &pic32s->flags))\n\t\thost->can_dma\t= pic32_spi_can_dma;\n\n\tinit_completion(&pic32s->xfer_done);\n\tpic32s->mode = -1;\n\n\t \n\tirq_set_status_flags(pic32s->fault_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, pic32s->fault_irq,\n\t\t\t       pic32_spi_fault_irq, IRQF_NO_THREAD,\n\t\t\t       dev_name(&pdev->dev), pic32s);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request fault-irq %d\\n\", pic32s->rx_irq);\n\t\tgoto err_bailout;\n\t}\n\n\t \n\tirq_set_status_flags(pic32s->rx_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, pic32s->rx_irq,\n\t\t\t       pic32_spi_rx_irq, IRQF_NO_THREAD,\n\t\t\t       dev_name(&pdev->dev), pic32s);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request rx-irq %d\\n\", pic32s->rx_irq);\n\t\tgoto err_bailout;\n\t}\n\n\t \n\tirq_set_status_flags(pic32s->tx_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, pic32s->tx_irq,\n\t\t\t       pic32_spi_tx_irq, IRQF_NO_THREAD,\n\t\t\t       dev_name(&pdev->dev), pic32s);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request tx-irq %d\\n\", pic32s->tx_irq);\n\t\tgoto err_bailout;\n\t}\n\n\t \n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret) {\n\t\tdev_err(&host->dev, \"failed registering spi host\\n\");\n\t\tgoto err_bailout;\n\t}\n\n\tplatform_set_drvdata(pdev, pic32s);\n\n\treturn 0;\n\nerr_bailout:\n\tpic32_spi_dma_unprep(pic32s);\n\tclk_disable_unprepare(pic32s->clk);\nerr_host:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic void pic32_spi_remove(struct platform_device *pdev)\n{\n\tstruct pic32_spi *pic32s;\n\n\tpic32s = platform_get_drvdata(pdev);\n\tpic32_spi_disable(pic32s);\n\tclk_disable_unprepare(pic32s->clk);\n\tpic32_spi_dma_unprep(pic32s);\n}\n\nstatic const struct of_device_id pic32_spi_of_match[] = {\n\t{.compatible = \"microchip,pic32mzda-spi\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pic32_spi_of_match);\n\nstatic struct platform_driver pic32_spi_driver = {\n\t.driver = {\n\t\t.name = \"spi-pic32\",\n\t\t.of_match_table = of_match_ptr(pic32_spi_of_match),\n\t},\n\t.probe = pic32_spi_probe,\n\t.remove_new = pic32_spi_remove,\n};\n\nmodule_platform_driver(pic32_spi_driver);\n\nMODULE_AUTHOR(\"Purna Chandra Mandal <purna.mandal@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip SPI driver for PIC32 SPI controller.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}