{
  "module_name": "spi-zynq-qspi.c",
  "hash_id": "7c155cce69494f83c3aa1ae75e5ec77ba7b7a0486ea4a2cbfb95936058ed72f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-zynq-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/workqueue.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define ZYNQ_QSPI_CONFIG_OFFSET\t\t0x00  \n#define ZYNQ_QSPI_STATUS_OFFSET\t\t0x04  \n#define ZYNQ_QSPI_IEN_OFFSET\t\t0x08  \n#define ZYNQ_QSPI_IDIS_OFFSET\t\t0x0C  \n#define ZYNQ_QSPI_IMASK_OFFSET\t\t0x10  \n#define ZYNQ_QSPI_ENABLE_OFFSET\t\t0x14  \n#define ZYNQ_QSPI_DELAY_OFFSET\t\t0x18  \n#define ZYNQ_QSPI_TXD_00_00_OFFSET\t0x1C  \n#define ZYNQ_QSPI_TXD_00_01_OFFSET\t0x80  \n#define ZYNQ_QSPI_TXD_00_10_OFFSET\t0x84  \n#define ZYNQ_QSPI_TXD_00_11_OFFSET\t0x88  \n#define ZYNQ_QSPI_RXD_OFFSET\t\t0x20  \n#define ZYNQ_QSPI_SIC_OFFSET\t\t0x24  \n#define ZYNQ_QSPI_TX_THRESH_OFFSET\t0x28  \n#define ZYNQ_QSPI_RX_THRESH_OFFSET\t0x2C  \n#define ZYNQ_QSPI_GPIO_OFFSET\t\t0x30  \n#define ZYNQ_QSPI_LINEAR_CFG_OFFSET\t0xA0  \n#define ZYNQ_QSPI_MOD_ID_OFFSET\t\t0xFC  \n\n \n#define ZYNQ_QSPI_CONFIG_IFMODE_MASK\tBIT(31)  \n#define ZYNQ_QSPI_CONFIG_MANSRT_MASK\tBIT(16)  \n#define ZYNQ_QSPI_CONFIG_MANSRTEN_MASK\tBIT(15)  \n#define ZYNQ_QSPI_CONFIG_SSFORCE_MASK\tBIT(14)  \n#define ZYNQ_QSPI_CONFIG_BDRATE_MASK\tGENMASK(5, 3)  \n#define ZYNQ_QSPI_CONFIG_CPHA_MASK\tBIT(2)  \n#define ZYNQ_QSPI_CONFIG_CPOL_MASK\tBIT(1)  \n#define ZYNQ_QSPI_CONFIG_FWIDTH_MASK\tGENMASK(7, 6)  \n#define ZYNQ_QSPI_CONFIG_MSTREN_MASK\tBIT(0)  \n\n \n#define ZYNQ_QSPI_CONFIG_BAUD_DIV_MAX\tGENMASK(2, 0)  \n#define ZYNQ_QSPI_CONFIG_BAUD_DIV_SHIFT\t3  \n#define ZYNQ_QSPI_CONFIG_PCS\t\tBIT(10)  \n\n \n#define ZYNQ_QSPI_IXR_RX_OVERFLOW_MASK\tBIT(0)  \n#define ZYNQ_QSPI_IXR_TXNFULL_MASK\tBIT(2)  \n#define ZYNQ_QSPI_IXR_TXFULL_MASK\tBIT(3)  \n#define ZYNQ_QSPI_IXR_RXNEMTY_MASK\tBIT(4)  \n#define ZYNQ_QSPI_IXR_RXF_FULL_MASK\tBIT(5)  \n#define ZYNQ_QSPI_IXR_TXF_UNDRFLOW_MASK\tBIT(6)  \n#define ZYNQ_QSPI_IXR_ALL_MASK\t\t(ZYNQ_QSPI_IXR_RX_OVERFLOW_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_TXNFULL_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_TXFULL_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_RXNEMTY_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_RXF_FULL_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_TXF_UNDRFLOW_MASK)\n#define ZYNQ_QSPI_IXR_RXTX_MASK\t\t(ZYNQ_QSPI_IXR_TXNFULL_MASK | \\\n\t\t\t\t\tZYNQ_QSPI_IXR_RXNEMTY_MASK)\n\n \n#define ZYNQ_QSPI_ENABLE_ENABLE_MASK\tBIT(0)  \n\n \n#define ZYNQ_QSPI_LCFG_TWO_MEM\t\tBIT(30)  \n#define ZYNQ_QSPI_LCFG_SEP_BUS\t\tBIT(29)  \n#define ZYNQ_QSPI_LCFG_U_PAGE\t\tBIT(28)  \n\n#define ZYNQ_QSPI_LCFG_DUMMY_SHIFT\t8\n\n#define ZYNQ_QSPI_FAST_READ_QOUT_CODE\t0x6B  \n#define ZYNQ_QSPI_FIFO_DEPTH\t\t63  \n#define ZYNQ_QSPI_RX_THRESHOLD\t\t32  \n#define ZYNQ_QSPI_TX_THRESHOLD\t\t1  \n\n \n#define ZYNQ_QSPI_MODEBITS\t\t\t(SPI_CPOL | SPI_CPHA)\n\n \n#define ZYNQ_QSPI_MAX_NUM_CS\t\t2\n\n \nstruct zynq_qspi {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *refclk;\n\tstruct clk *pclk;\n\tint irq;\n\tu8 *txbuf;\n\tu8 *rxbuf;\n\tint tx_bytes;\n\tint rx_bytes;\n\tstruct completion data_completion;\n};\n\n \nstatic inline u32 zynq_qspi_read(struct zynq_qspi *xqspi, u32 offset)\n{\n\treturn readl_relaxed(xqspi->regs + offset);\n}\n\nstatic inline void zynq_qspi_write(struct zynq_qspi *xqspi, u32 offset,\n\t\t\t\t   u32 val)\n{\n\twritel_relaxed(val, xqspi->regs + offset);\n}\n\n \nstatic void zynq_qspi_init_hw(struct zynq_qspi *xqspi, unsigned int num_cs)\n{\n\tu32 config_reg;\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET, 0);\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_IDIS_OFFSET, ZYNQ_QSPI_IXR_ALL_MASK);\n\n\t \n\tconfig_reg = 0;\n\t \n\tif (num_cs > 1)\n\t\tconfig_reg |= ZYNQ_QSPI_LCFG_TWO_MEM;\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET, config_reg);\n\n\t \n\twhile (zynq_qspi_read(xqspi, ZYNQ_QSPI_STATUS_OFFSET) &\n\t\t\t      ZYNQ_QSPI_IXR_RXNEMTY_MASK)\n\t\tzynq_qspi_read(xqspi, ZYNQ_QSPI_RXD_OFFSET);\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_STATUS_OFFSET, ZYNQ_QSPI_IXR_ALL_MASK);\n\tconfig_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_CONFIG_OFFSET);\n\tconfig_reg &= ~(ZYNQ_QSPI_CONFIG_MSTREN_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_CPOL_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_CPHA_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_BDRATE_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_SSFORCE_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_MANSRTEN_MASK |\n\t\t\tZYNQ_QSPI_CONFIG_MANSRT_MASK);\n\tconfig_reg |= (ZYNQ_QSPI_CONFIG_MSTREN_MASK |\n\t\t       ZYNQ_QSPI_CONFIG_SSFORCE_MASK |\n\t\t       ZYNQ_QSPI_CONFIG_FWIDTH_MASK |\n\t\t       ZYNQ_QSPI_CONFIG_IFMODE_MASK);\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_CONFIG_OFFSET, config_reg);\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_RX_THRESH_OFFSET,\n\t\t\tZYNQ_QSPI_RX_THRESHOLD);\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_TX_THRESH_OFFSET,\n\t\t\tZYNQ_QSPI_TX_THRESHOLD);\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET,\n\t\t\tZYNQ_QSPI_ENABLE_ENABLE_MASK);\n}\n\nstatic bool zynq_qspi_supports_op(struct spi_mem *mem,\n\t\t\t\t  const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\t \n\tif (op->addr.nbytes > 3)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void zynq_qspi_rxfifo_op(struct zynq_qspi *xqspi, unsigned int size)\n{\n\tu32 data;\n\n\tdata = zynq_qspi_read(xqspi, ZYNQ_QSPI_RXD_OFFSET);\n\n\tif (xqspi->rxbuf) {\n\t\tmemcpy(xqspi->rxbuf, ((u8 *)&data) + 4 - size, size);\n\t\txqspi->rxbuf += size;\n\t}\n\n\txqspi->rx_bytes -= size;\n\tif (xqspi->rx_bytes < 0)\n\t\txqspi->rx_bytes = 0;\n}\n\n \nstatic void zynq_qspi_txfifo_op(struct zynq_qspi *xqspi, unsigned int size)\n{\n\tstatic const unsigned int offset[4] = {\n\t\tZYNQ_QSPI_TXD_00_01_OFFSET, ZYNQ_QSPI_TXD_00_10_OFFSET,\n\t\tZYNQ_QSPI_TXD_00_11_OFFSET, ZYNQ_QSPI_TXD_00_00_OFFSET };\n\tu32 data;\n\n\tif (xqspi->txbuf) {\n\t\tdata = 0xffffffff;\n\t\tmemcpy(&data, xqspi->txbuf, size);\n\t\txqspi->txbuf += size;\n\t} else {\n\t\tdata = 0;\n\t}\n\n\txqspi->tx_bytes -= size;\n\tzynq_qspi_write(xqspi, offset[size - 1], data);\n}\n\n \nstatic void zynq_qspi_chipselect(struct spi_device *spi, bool assert)\n{\n\tstruct spi_controller *ctlr = spi->master;\n\tstruct zynq_qspi *xqspi = spi_controller_get_devdata(ctlr);\n\tu32 config_reg;\n\n\t \n\tif (ctlr->num_chipselect > 1) {\n\t\tconfig_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET);\n\t\tif (!spi_get_chipselect(spi, 0))\n\t\t\tconfig_reg &= ~ZYNQ_QSPI_LCFG_U_PAGE;\n\t\telse\n\t\t\tconfig_reg |= ZYNQ_QSPI_LCFG_U_PAGE;\n\n\t\tzynq_qspi_write(xqspi, ZYNQ_QSPI_LINEAR_CFG_OFFSET, config_reg);\n\t}\n\n\t \n\tconfig_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_CONFIG_OFFSET);\n\tif (assert)\n\t\tconfig_reg &= ~ZYNQ_QSPI_CONFIG_PCS;\n\telse\n\t\tconfig_reg |= ZYNQ_QSPI_CONFIG_PCS;\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_CONFIG_OFFSET, config_reg);\n}\n\n \nstatic int zynq_qspi_config_op(struct zynq_qspi *xqspi, struct spi_device *spi)\n{\n\tu32 config_reg, baud_rate_val = 0;\n\n\t \n\twhile ((baud_rate_val < ZYNQ_QSPI_CONFIG_BAUD_DIV_MAX)  &&\n\t       (clk_get_rate(xqspi->refclk) / (2 << baud_rate_val)) >\n\t\tspi->max_speed_hz)\n\t\tbaud_rate_val++;\n\n\tconfig_reg = zynq_qspi_read(xqspi, ZYNQ_QSPI_CONFIG_OFFSET);\n\n\t \n\tconfig_reg &= (~ZYNQ_QSPI_CONFIG_CPHA_MASK) &\n\t\t      (~ZYNQ_QSPI_CONFIG_CPOL_MASK);\n\tif (spi->mode & SPI_CPHA)\n\t\tconfig_reg |= ZYNQ_QSPI_CONFIG_CPHA_MASK;\n\tif (spi->mode & SPI_CPOL)\n\t\tconfig_reg |= ZYNQ_QSPI_CONFIG_CPOL_MASK;\n\n\tconfig_reg &= ~ZYNQ_QSPI_CONFIG_BDRATE_MASK;\n\tconfig_reg |= (baud_rate_val << ZYNQ_QSPI_CONFIG_BAUD_DIV_SHIFT);\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_CONFIG_OFFSET, config_reg);\n\n\treturn 0;\n}\n\n \nstatic int zynq_qspi_setup_op(struct spi_device *spi)\n{\n\tstruct spi_controller *ctlr = spi->master;\n\tstruct zynq_qspi *qspi = spi_controller_get_devdata(ctlr);\n\n\tif (ctlr->busy)\n\t\treturn -EBUSY;\n\n\tclk_enable(qspi->refclk);\n\tclk_enable(qspi->pclk);\n\tzynq_qspi_write(qspi, ZYNQ_QSPI_ENABLE_OFFSET,\n\t\t\tZYNQ_QSPI_ENABLE_ENABLE_MASK);\n\n\treturn 0;\n}\n\n \nstatic void zynq_qspi_write_op(struct zynq_qspi *xqspi, int txcount,\n\t\t\t       bool txempty)\n{\n\tint count, len, k;\n\n\tlen = xqspi->tx_bytes;\n\tif (len && len < 4) {\n\t\t \n\t\tif (txempty)\n\t\t\tzynq_qspi_txfifo_op(xqspi, len);\n\n\t\treturn;\n\t}\n\n\tcount = len / 4;\n\tif (count > txcount)\n\t\tcount = txcount;\n\n\tif (xqspi->txbuf) {\n\t\tiowrite32_rep(xqspi->regs + ZYNQ_QSPI_TXD_00_00_OFFSET,\n\t\t\t      xqspi->txbuf, count);\n\t\txqspi->txbuf += count * 4;\n\t} else {\n\t\tfor (k = 0; k < count; k++)\n\t\t\twritel_relaxed(0, xqspi->regs +\n\t\t\t\t\t  ZYNQ_QSPI_TXD_00_00_OFFSET);\n\t}\n\n\txqspi->tx_bytes -= count * 4;\n}\n\n \nstatic void zynq_qspi_read_op(struct zynq_qspi *xqspi, int rxcount)\n{\n\tint count, len, k;\n\n\tlen = xqspi->rx_bytes - xqspi->tx_bytes;\n\tcount = len / 4;\n\tif (count > rxcount)\n\t\tcount = rxcount;\n\tif (xqspi->rxbuf) {\n\t\tioread32_rep(xqspi->regs + ZYNQ_QSPI_RXD_OFFSET,\n\t\t\t     xqspi->rxbuf, count);\n\t\txqspi->rxbuf += count * 4;\n\t} else {\n\t\tfor (k = 0; k < count; k++)\n\t\t\treadl_relaxed(xqspi->regs + ZYNQ_QSPI_RXD_OFFSET);\n\t}\n\txqspi->rx_bytes -= count * 4;\n\tlen -= count * 4;\n\n\tif (len && len < 4 && count < rxcount)\n\t\tzynq_qspi_rxfifo_op(xqspi, len);\n}\n\n \nstatic irqreturn_t zynq_qspi_irq(int irq, void *dev_id)\n{\n\tu32 intr_status;\n\tbool txempty;\n\tstruct zynq_qspi *xqspi = (struct zynq_qspi *)dev_id;\n\n\tintr_status = zynq_qspi_read(xqspi, ZYNQ_QSPI_STATUS_OFFSET);\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_STATUS_OFFSET, intr_status);\n\n\tif ((intr_status & ZYNQ_QSPI_IXR_TXNFULL_MASK) ||\n\t    (intr_status & ZYNQ_QSPI_IXR_RXNEMTY_MASK)) {\n\t\t \n\t\ttxempty = !!(intr_status & ZYNQ_QSPI_IXR_TXNFULL_MASK);\n\t\t \n\t\tzynq_qspi_read_op(xqspi, ZYNQ_QSPI_RX_THRESHOLD);\n\t\tif (xqspi->tx_bytes) {\n\t\t\t \n\t\t\tzynq_qspi_write_op(xqspi, ZYNQ_QSPI_RX_THRESHOLD,\n\t\t\t\t\t   txempty);\n\t\t} else {\n\t\t\t \n\t\t\tif (!xqspi->rx_bytes) {\n\t\t\t\tzynq_qspi_write(xqspi,\n\t\t\t\t\t\tZYNQ_QSPI_IDIS_OFFSET,\n\t\t\t\t\t\tZYNQ_QSPI_IXR_RXTX_MASK);\n\t\t\t\tcomplete(&xqspi->data_completion);\n\t\t\t}\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int zynq_qspi_exec_mem_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct zynq_qspi *xqspi = spi_controller_get_devdata(mem->spi->master);\n\tint err = 0, i;\n\tu8 *tmpbuf;\n\n\tdev_dbg(xqspi->dev, \"cmd:%#x mode:%d.%d.%d.%d\\n\",\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth);\n\n\tzynq_qspi_chipselect(mem->spi, true);\n\tzynq_qspi_config_op(xqspi, mem->spi);\n\n\tif (op->cmd.opcode) {\n\t\treinit_completion(&xqspi->data_completion);\n\t\txqspi->txbuf = (u8 *)&op->cmd.opcode;\n\t\txqspi->rxbuf = NULL;\n\t\txqspi->tx_bytes = op->cmd.nbytes;\n\t\txqspi->rx_bytes = op->cmd.nbytes;\n\t\tzynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);\n\t\tzynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,\n\t\t\t\tZYNQ_QSPI_IXR_RXTX_MASK);\n\t\tif (!wait_for_completion_timeout(&xqspi->data_completion,\n\t\t\t\t\t\t\t       msecs_to_jiffies(1000)))\n\t\t\terr = -ETIMEDOUT;\n\t}\n\n\tif (op->addr.nbytes) {\n\t\tfor (i = 0; i < op->addr.nbytes; i++) {\n\t\t\txqspi->txbuf[i] = op->addr.val >>\n\t\t\t\t\t(8 * (op->addr.nbytes - i - 1));\n\t\t}\n\n\t\treinit_completion(&xqspi->data_completion);\n\t\txqspi->rxbuf = NULL;\n\t\txqspi->tx_bytes = op->addr.nbytes;\n\t\txqspi->rx_bytes = op->addr.nbytes;\n\t\tzynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);\n\t\tzynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,\n\t\t\t\tZYNQ_QSPI_IXR_RXTX_MASK);\n\t\tif (!wait_for_completion_timeout(&xqspi->data_completion,\n\t\t\t\t\t\t\t       msecs_to_jiffies(1000)))\n\t\t\terr = -ETIMEDOUT;\n\t}\n\n\tif (op->dummy.nbytes) {\n\t\ttmpbuf = kzalloc(op->dummy.nbytes, GFP_KERNEL);\n\t\tif (!tmpbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(tmpbuf, 0xff, op->dummy.nbytes);\n\t\treinit_completion(&xqspi->data_completion);\n\t\txqspi->txbuf = tmpbuf;\n\t\txqspi->rxbuf = NULL;\n\t\txqspi->tx_bytes = op->dummy.nbytes;\n\t\txqspi->rx_bytes = op->dummy.nbytes;\n\t\tzynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);\n\t\tzynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,\n\t\t\t\tZYNQ_QSPI_IXR_RXTX_MASK);\n\t\tif (!wait_for_completion_timeout(&xqspi->data_completion,\n\t\t\t\t\t\t\t       msecs_to_jiffies(1000)))\n\t\t\terr = -ETIMEDOUT;\n\n\t\tkfree(tmpbuf);\n\t}\n\n\tif (op->data.nbytes) {\n\t\treinit_completion(&xqspi->data_completion);\n\t\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\t\txqspi->txbuf = (u8 *)op->data.buf.out;\n\t\t\txqspi->tx_bytes = op->data.nbytes;\n\t\t\txqspi->rxbuf = NULL;\n\t\t\txqspi->rx_bytes = op->data.nbytes;\n\t\t} else {\n\t\t\txqspi->txbuf = NULL;\n\t\t\txqspi->rxbuf = (u8 *)op->data.buf.in;\n\t\t\txqspi->rx_bytes = op->data.nbytes;\n\t\t\txqspi->tx_bytes = op->data.nbytes;\n\t\t}\n\n\t\tzynq_qspi_write_op(xqspi, ZYNQ_QSPI_FIFO_DEPTH, true);\n\t\tzynq_qspi_write(xqspi, ZYNQ_QSPI_IEN_OFFSET,\n\t\t\t\tZYNQ_QSPI_IXR_RXTX_MASK);\n\t\tif (!wait_for_completion_timeout(&xqspi->data_completion,\n\t\t\t\t\t\t\t       msecs_to_jiffies(1000)))\n\t\t\terr = -ETIMEDOUT;\n\t}\n\tzynq_qspi_chipselect(mem->spi, false);\n\n\treturn err;\n}\n\nstatic const struct spi_controller_mem_ops zynq_qspi_mem_ops = {\n\t.supports_op = zynq_qspi_supports_op,\n\t.exec_op = zynq_qspi_exec_mem_op,\n};\n\n \nstatic int zynq_qspi_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct spi_controller *ctlr;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct zynq_qspi *xqspi;\n\tu32 num_cs;\n\n\tctlr = spi_alloc_master(&pdev->dev, sizeof(*xqspi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\txqspi = spi_controller_get_devdata(ctlr);\n\txqspi->dev = dev;\n\tplatform_set_drvdata(pdev, xqspi);\n\txqspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xqspi->regs)) {\n\t\tret = PTR_ERR(xqspi->regs);\n\t\tgoto remove_master;\n\t}\n\n\txqspi->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(xqspi->pclk)) {\n\t\tdev_err(&pdev->dev, \"pclk clock not found.\\n\");\n\t\tret = PTR_ERR(xqspi->pclk);\n\t\tgoto remove_master;\n\t}\n\n\tinit_completion(&xqspi->data_completion);\n\n\txqspi->refclk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\tif (IS_ERR(xqspi->refclk)) {\n\t\tdev_err(&pdev->dev, \"ref_clk clock not found.\\n\");\n\t\tret = PTR_ERR(xqspi->refclk);\n\t\tgoto remove_master;\n\t}\n\n\tret = clk_prepare_enable(xqspi->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable APB clock.\\n\");\n\t\tgoto remove_master;\n\t}\n\n\tret = clk_prepare_enable(xqspi->refclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable device clock.\\n\");\n\t\tgoto clk_dis_pclk;\n\t}\n\n\txqspi->irq = platform_get_irq(pdev, 0);\n\tif (xqspi->irq < 0) {\n\t\tret = xqspi->irq;\n\t\tgoto clk_dis_all;\n\t}\n\tret = devm_request_irq(&pdev->dev, xqspi->irq, zynq_qspi_irq,\n\t\t\t       0, pdev->name, xqspi);\n\tif (ret != 0) {\n\t\tret = -ENXIO;\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\tret = of_property_read_u32(np, \"num-cs\",\n\t\t\t\t   &num_cs);\n\tif (ret < 0) {\n\t\tctlr->num_chipselect = 1;\n\t} else if (num_cs > ZYNQ_QSPI_MAX_NUM_CS) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"only 2 chip selects are available\\n\");\n\t\tgoto clk_dis_all;\n\t} else {\n\t\tctlr->num_chipselect = num_cs;\n\t}\n\n\tctlr->mode_bits =  SPI_RX_DUAL | SPI_RX_QUAD |\n\t\t\t    SPI_TX_DUAL | SPI_TX_QUAD;\n\tctlr->mem_ops = &zynq_qspi_mem_ops;\n\tctlr->setup = zynq_qspi_setup_op;\n\tctlr->max_speed_hz = clk_get_rate(xqspi->refclk) / 2;\n\tctlr->dev.of_node = np;\n\n\t \n\tzynq_qspi_init_hw(xqspi, ctlr->num_chipselect);\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_register_master failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\treturn ret;\n\nclk_dis_all:\n\tclk_disable_unprepare(xqspi->refclk);\nclk_dis_pclk:\n\tclk_disable_unprepare(xqspi->pclk);\nremove_master:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\n \nstatic void zynq_qspi_remove(struct platform_device *pdev)\n{\n\tstruct zynq_qspi *xqspi = platform_get_drvdata(pdev);\n\n\tzynq_qspi_write(xqspi, ZYNQ_QSPI_ENABLE_OFFSET, 0);\n\n\tclk_disable_unprepare(xqspi->refclk);\n\tclk_disable_unprepare(xqspi->pclk);\n}\n\nstatic const struct of_device_id zynq_qspi_of_match[] = {\n\t{ .compatible = \"xlnx,zynq-qspi-1.0\", },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, zynq_qspi_of_match);\n\n \nstatic struct platform_driver zynq_qspi_driver = {\n\t.probe = zynq_qspi_probe,\n\t.remove_new = zynq_qspi_remove,\n\t.driver = {\n\t\t.name = \"zynq-qspi\",\n\t\t.of_match_table = zynq_qspi_of_match,\n\t},\n};\n\nmodule_platform_driver(zynq_qspi_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx Zynq QSPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}