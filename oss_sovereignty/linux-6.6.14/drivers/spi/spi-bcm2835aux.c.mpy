{
  "module_name": "spi-bcm2835aux.c",
  "hash_id": "c61047f9f88cc8d79eb5a04208f6425f5a68f2de2d00b27824a383491864674b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm2835aux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n\n \nstatic unsigned int polling_limit_us = 30;\nmodule_param(polling_limit_us, uint, 0664);\nMODULE_PARM_DESC(polling_limit_us,\n\t\t \"time in us to run a transfer in polling mode - if zero no polling is used\\n\");\n\n \n\n \n#define BCM2835_AUX_SPI_CNTL0\t0x00\n#define BCM2835_AUX_SPI_CNTL1\t0x04\n#define BCM2835_AUX_SPI_STAT\t0x08\n#define BCM2835_AUX_SPI_PEEK\t0x0C\n#define BCM2835_AUX_SPI_IO\t0x20\n#define BCM2835_AUX_SPI_TXHOLD\t0x30\n\n \n#define BCM2835_AUX_SPI_CNTL0_SPEED\t0xFFF00000\n#define BCM2835_AUX_SPI_CNTL0_SPEED_MAX\t0xFFF\n#define BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT\t20\n#define BCM2835_AUX_SPI_CNTL0_CS\t0x000E0000\n#define BCM2835_AUX_SPI_CNTL0_POSTINPUT\t0x00010000\n#define BCM2835_AUX_SPI_CNTL0_VAR_CS\t0x00008000\n#define BCM2835_AUX_SPI_CNTL0_VAR_WIDTH\t0x00004000\n#define BCM2835_AUX_SPI_CNTL0_DOUTHOLD\t0x00003000\n#define BCM2835_AUX_SPI_CNTL0_ENABLE\t0x00000800\n#define BCM2835_AUX_SPI_CNTL0_IN_RISING\t0x00000400\n#define BCM2835_AUX_SPI_CNTL0_CLEARFIFO\t0x00000200\n#define BCM2835_AUX_SPI_CNTL0_OUT_RISING\t0x00000100\n#define BCM2835_AUX_SPI_CNTL0_CPOL\t0x00000080\n#define BCM2835_AUX_SPI_CNTL0_MSBF_OUT\t0x00000040\n#define BCM2835_AUX_SPI_CNTL0_SHIFTLEN\t0x0000003F\n\n \n#define BCM2835_AUX_SPI_CNTL1_CSHIGH\t0x00000700\n#define BCM2835_AUX_SPI_CNTL1_TXEMPTY\t0x00000080\n#define BCM2835_AUX_SPI_CNTL1_IDLE\t0x00000040\n#define BCM2835_AUX_SPI_CNTL1_MSBF_IN\t0x00000002\n#define BCM2835_AUX_SPI_CNTL1_KEEP_IN\t0x00000001\n\n \n#define BCM2835_AUX_SPI_STAT_TX_LVL\t0xFF000000\n#define BCM2835_AUX_SPI_STAT_RX_LVL\t0x00FF0000\n#define BCM2835_AUX_SPI_STAT_TX_FULL\t0x00000400\n#define BCM2835_AUX_SPI_STAT_TX_EMPTY\t0x00000200\n#define BCM2835_AUX_SPI_STAT_RX_FULL\t0x00000100\n#define BCM2835_AUX_SPI_STAT_RX_EMPTY\t0x00000080\n#define BCM2835_AUX_SPI_STAT_BUSY\t0x00000040\n#define BCM2835_AUX_SPI_STAT_BITCOUNT\t0x0000003F\n\nstruct bcm2835aux_spi {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tint irq;\n\tu32 cntl[2];\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tint tx_len;\n\tint rx_len;\n\tint pending;\n\n\tu64 count_transfer_polling;\n\tu64 count_transfer_irq;\n\tu64 count_transfer_irq_after_poll;\n\n\tstruct dentry *debugfs_dir;\n};\n\n#if defined(CONFIG_DEBUG_FS)\nstatic void bcm2835aux_debugfs_create(struct bcm2835aux_spi *bs,\n\t\t\t\t      const char *dname)\n{\n\tchar name[64];\n\tstruct dentry *dir;\n\n\t \n\tsnprintf(name, sizeof(name), \"spi-bcm2835aux-%s\", dname);\n\n\t \n\tdir = debugfs_create_dir(name, NULL);\n\tbs->debugfs_dir = dir;\n\n\t \n\tdebugfs_create_u64(\"count_transfer_polling\", 0444, dir,\n\t\t\t   &bs->count_transfer_polling);\n\tdebugfs_create_u64(\"count_transfer_irq\", 0444, dir,\n\t\t\t   &bs->count_transfer_irq);\n\tdebugfs_create_u64(\"count_transfer_irq_after_poll\", 0444, dir,\n\t\t\t   &bs->count_transfer_irq_after_poll);\n}\n\nstatic void bcm2835aux_debugfs_remove(struct bcm2835aux_spi *bs)\n{\n\tdebugfs_remove_recursive(bs->debugfs_dir);\n\tbs->debugfs_dir = NULL;\n}\n#else\nstatic void bcm2835aux_debugfs_create(struct bcm2835aux_spi *bs,\n\t\t\t\t      const char *dname)\n{\n}\n\nstatic void bcm2835aux_debugfs_remove(struct bcm2835aux_spi *bs)\n{\n}\n#endif  \n\nstatic inline u32 bcm2835aux_rd(struct bcm2835aux_spi *bs, unsigned int reg)\n{\n\treturn readl(bs->regs + reg);\n}\n\nstatic inline void bcm2835aux_wr(struct bcm2835aux_spi *bs, unsigned int reg,\n\t\t\t\t u32 val)\n{\n\twritel(val, bs->regs + reg);\n}\n\nstatic inline void bcm2835aux_rd_fifo(struct bcm2835aux_spi *bs)\n{\n\tu32 data;\n\tint count = min(bs->rx_len, 3);\n\n\tdata = bcm2835aux_rd(bs, BCM2835_AUX_SPI_IO);\n\tif (bs->rx_buf) {\n\t\tswitch (count) {\n\t\tcase 3:\n\t\t\t*bs->rx_buf++ = (data >> 16) & 0xff;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\t*bs->rx_buf++ = (data >> 8) & 0xff;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\t*bs->rx_buf++ = (data >> 0) & 0xff;\n\t\t\t \n\t\t}\n\t}\n\tbs->rx_len -= count;\n\tbs->pending -= count;\n}\n\nstatic inline void bcm2835aux_wr_fifo(struct bcm2835aux_spi *bs)\n{\n\tu32 data;\n\tu8 byte;\n\tint count;\n\tint i;\n\n\t \n\tcount = min(bs->tx_len, 3);\n\tdata = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tbyte = bs->tx_buf ? *bs->tx_buf++ : 0;\n\t\tdata |= byte << (8 * (2 - i));\n\t}\n\n\t \n\tdata |= (count * 8) << 24;\n\n\t \n\tbs->tx_len -= count;\n\tbs->pending += count;\n\n\t \n\tif (bs->tx_len)\n\t\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_TXHOLD, data);\n\telse\n\t\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_IO, data);\n}\n\nstatic void bcm2835aux_spi_reset_hw(struct bcm2835aux_spi *bs)\n{\n\t \n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, 0);\n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0,\n\t\t      BCM2835_AUX_SPI_CNTL0_CLEARFIFO);\n}\n\nstatic void bcm2835aux_spi_transfer_helper(struct bcm2835aux_spi *bs)\n{\n\tu32 stat = bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT);\n\n\t \n\tfor (; bs->rx_len && (stat & BCM2835_AUX_SPI_STAT_RX_LVL);\n\t     stat = bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT))\n\t\tbcm2835aux_rd_fifo(bs);\n\n\t \n\twhile (bs->tx_len &&\n\t       (bs->pending < 12) &&\n\t       (!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\n\t\t  BCM2835_AUX_SPI_STAT_TX_FULL))) {\n\t\tbcm2835aux_wr_fifo(bs);\n\t}\n}\n\nstatic irqreturn_t bcm2835aux_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = dev_id;\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\t \n\tif (!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_CNTL1) &\n\t      (BCM2835_AUX_SPI_CNTL1_TXEMPTY | BCM2835_AUX_SPI_CNTL1_IDLE)))\n\t\treturn IRQ_NONE;\n\n\t \n\tbcm2835aux_spi_transfer_helper(bs);\n\n\tif (!bs->tx_len) {\n\t\t \n\t\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1] |\n\t\t\tBCM2835_AUX_SPI_CNTL1_IDLE);\n\t}\n\n\t \n\tif (!bs->rx_len) {\n\t\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\n\t\tspi_finalize_current_transfer(host);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __bcm2835aux_spi_transfer_one_irq(struct spi_controller *host,\n\t\t\t\t\t     struct spi_device *spi,\n\t\t\t\t\t     struct spi_transfer *tfr)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\t \n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1] |\n\t\tBCM2835_AUX_SPI_CNTL1_TXEMPTY |\n\t\tBCM2835_AUX_SPI_CNTL1_IDLE);\n\n\t \n\treturn 1;\n}\n\nstatic int bcm2835aux_spi_transfer_one_irq(struct spi_controller *host,\n\t\t\t\t\t   struct spi_device *spi,\n\t\t\t\t\t   struct spi_transfer *tfr)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\t \n\tbs->count_transfer_irq++;\n\n\t \n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\n\n\t \n\twhile ((bs->tx_len) &&\n\t       (bs->pending < 12) &&\n\t       (!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\n\t\t  BCM2835_AUX_SPI_STAT_TX_FULL))) {\n\t\tbcm2835aux_wr_fifo(bs);\n\t}\n\n\t \n\treturn __bcm2835aux_spi_transfer_one_irq(host, spi, tfr);\n}\n\nstatic int bcm2835aux_spi_transfer_one_poll(struct spi_controller *host,\n\t\t\t\t\t    struct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *tfr)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\tunsigned long timeout;\n\n\t \n\tbs->count_transfer_polling++;\n\n\t \n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\n\n\t \n\ttimeout = jiffies + 2 + HZ * polling_limit_us / 1000000;\n\n\t \n\twhile (bs->rx_len) {\n\n\t\t \n\t\tbcm2835aux_spi_transfer_helper(bs);\n\n\t\t \n\t\tif (bs->rx_len && time_after(jiffies, timeout)) {\n\t\t\tdev_dbg_ratelimited(&spi->dev,\n\t\t\t\t\t    \"timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\\n\",\n\t\t\t\t\t    jiffies - timeout,\n\t\t\t\t\t    bs->tx_len, bs->rx_len);\n\t\t\t \n\t\t\tbs->count_transfer_irq_after_poll++;\n\t\t\treturn __bcm2835aux_spi_transfer_one_irq(host,\n\t\t\t\t\t\t\t       spi, tfr);\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int bcm2835aux_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t       struct spi_device *spi,\n\t\t\t\t       struct spi_transfer *tfr)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\tunsigned long spi_hz, clk_hz, speed;\n\tunsigned long hz_per_byte, byte_limit;\n\n\t \n\n\t \n\tspi_hz = tfr->speed_hz;\n\tclk_hz = clk_get_rate(bs->clk);\n\n\tif (spi_hz >= clk_hz / 2) {\n\t\tspeed = 0;\n\t} else if (spi_hz) {\n\t\tspeed = DIV_ROUND_UP(clk_hz, 2 * spi_hz) - 1;\n\t\tif (speed >  BCM2835_AUX_SPI_CNTL0_SPEED_MAX)\n\t\t\tspeed = BCM2835_AUX_SPI_CNTL0_SPEED_MAX;\n\t} else {  \n\t\tspeed = BCM2835_AUX_SPI_CNTL0_SPEED_MAX;\n\t}\n\t \n\tbs->cntl[0] &= ~(BCM2835_AUX_SPI_CNTL0_SPEED);\n\t \n\tbs->cntl[0] |= speed << BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT;\n\n\ttfr->effective_speed_hz = clk_hz / (2 * (speed + 1));\n\n\t \n\tbs->tx_buf = tfr->tx_buf;\n\tbs->rx_buf = tfr->rx_buf;\n\tbs->tx_len = tfr->len;\n\tbs->rx_len = tfr->len;\n\tbs->pending = 0;\n\n\t \n\thz_per_byte = polling_limit_us ? (9 * 1000000) / polling_limit_us : 0;\n\tbyte_limit = hz_per_byte ? tfr->effective_speed_hz / hz_per_byte : 1;\n\n\t \n\tif (tfr->len < byte_limit)\n\t\treturn bcm2835aux_spi_transfer_one_poll(host, spi, tfr);\n\n\t \n\treturn bcm2835aux_spi_transfer_one_irq(host, spi, tfr);\n}\n\nstatic int bcm2835aux_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t\t  struct spi_message *msg)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\tbs->cntl[0] = BCM2835_AUX_SPI_CNTL0_ENABLE |\n\t\t      BCM2835_AUX_SPI_CNTL0_VAR_WIDTH |\n\t\t      BCM2835_AUX_SPI_CNTL0_MSBF_OUT;\n\tbs->cntl[1] = BCM2835_AUX_SPI_CNTL1_MSBF_IN;\n\n\t \n\tif (spi->mode & SPI_CPOL) {\n\t\tbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_CPOL;\n\t\tbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_OUT_RISING;\n\t} else {\n\t\tbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_IN_RISING;\n\t}\n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\n\tbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\n\n\treturn 0;\n}\n\nstatic int bcm2835aux_spi_unprepare_message(struct spi_controller *host,\n\t\t\t\t\t    struct spi_message *msg)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\tbcm2835aux_spi_reset_hw(bs);\n\n\treturn 0;\n}\n\nstatic void bcm2835aux_spi_handle_err(struct spi_controller *host,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\tbcm2835aux_spi_reset_hw(bs);\n}\n\nstatic int bcm2835aux_spi_setup(struct spi_device *spi)\n{\n\t \n\tif (spi->mode & SPI_NO_CS)\n\t\treturn 0;\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\treturn 0;\n\n\t \n\tdev_warn(&spi->dev,\n\t\t \"Native CS is not supported - please configure cs-gpio in device-tree\\n\");\n\n\tif (spi_get_chipselect(spi, 0) == 0)\n\t\treturn 0;\n\n\tdev_warn(&spi->dev, \"Native CS is not working for cs > 0\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int bcm2835aux_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct bcm2835aux_spi *bs;\n\tunsigned long clk_hz;\n\tint err;\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(*bs));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, host);\n\thost->mode_bits = (SPI_CPOL | SPI_CS_HIGH | SPI_NO_CS);\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\t \n\thost->num_chipselect = 1;\n\thost->setup = bcm2835aux_spi_setup;\n\thost->transfer_one = bcm2835aux_spi_transfer_one;\n\thost->handle_err = bcm2835aux_spi_handle_err;\n\thost->prepare_message = bcm2835aux_spi_prepare_message;\n\thost->unprepare_message = bcm2835aux_spi_unprepare_message;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->use_gpio_descriptors = true;\n\n\tbs = spi_controller_get_devdata(host);\n\n\t \n\tbs->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bs->regs))\n\t\treturn PTR_ERR(bs->regs);\n\n\tbs->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(bs->clk)) {\n\t\terr = PTR_ERR(bs->clk);\n\t\tdev_err(&pdev->dev, \"could not get clk: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tbs->irq = platform_get_irq(pdev, 0);\n\tif (bs->irq < 0)\n\t\treturn bs->irq;\n\n\t \n\terr = clk_prepare_enable(bs->clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not prepare clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tclk_hz = clk_get_rate(bs->clk);\n\tif (!clk_hz) {\n\t\tdev_err(&pdev->dev, \"clock returns 0 Hz\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\tbcm2835aux_spi_reset_hw(bs);\n\n\terr = devm_request_irq(&pdev->dev, bs->irq,\n\t\t\t       bcm2835aux_spi_interrupt,\n\t\t\t       IRQF_SHARED,\n\t\t\t       dev_name(&pdev->dev), host);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not request IRQ: %d\\n\", err);\n\t\tgoto out_clk_disable;\n\t}\n\n\terr = spi_register_controller(host);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not register SPI host: %d\\n\", err);\n\t\tgoto out_clk_disable;\n\t}\n\n\tbcm2835aux_debugfs_create(bs, dev_name(&pdev->dev));\n\n\treturn 0;\n\nout_clk_disable:\n\tclk_disable_unprepare(bs->clk);\n\treturn err;\n}\n\nstatic void bcm2835aux_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct bcm2835aux_spi *bs = spi_controller_get_devdata(host);\n\n\tbcm2835aux_debugfs_remove(bs);\n\n\tspi_unregister_controller(host);\n\n\tbcm2835aux_spi_reset_hw(bs);\n\n\t \n\tclk_disable_unprepare(bs->clk);\n}\n\nstatic const struct of_device_id bcm2835aux_spi_match[] = {\n\t{ .compatible = \"brcm,bcm2835-aux-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bcm2835aux_spi_match);\n\nstatic struct platform_driver bcm2835aux_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"spi-bcm2835aux\",\n\t\t.of_match_table\t= bcm2835aux_spi_match,\n\t},\n\t.probe\t\t= bcm2835aux_spi_probe,\n\t.remove_new\t= bcm2835aux_spi_remove,\n};\nmodule_platform_driver(bcm2835aux_spi_driver);\n\nMODULE_DESCRIPTION(\"SPI controller driver for Broadcom BCM2835 aux\");\nMODULE_AUTHOR(\"Martin Sperl <kernel@martin.sperl.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}