{
  "module_name": "spi-xcomm.c",
  "hash_id": "267e759bef76f15b553863c16c5d946c37a7563642d59bfa2a06b7da36f4c595",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-xcomm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <asm/unaligned.h>\n\n#define SPI_XCOMM_SETTINGS_LEN_OFFSET\t\t10\n#define SPI_XCOMM_SETTINGS_3WIRE\t\tBIT(6)\n#define SPI_XCOMM_SETTINGS_CS_HIGH\t\tBIT(5)\n#define SPI_XCOMM_SETTINGS_SAMPLE_END\t\tBIT(4)\n#define SPI_XCOMM_SETTINGS_CPHA\t\t\tBIT(3)\n#define SPI_XCOMM_SETTINGS_CPOL\t\t\tBIT(2)\n#define SPI_XCOMM_SETTINGS_CLOCK_DIV_MASK\t0x3\n#define SPI_XCOMM_SETTINGS_CLOCK_DIV_64\t\t0x2\n#define SPI_XCOMM_SETTINGS_CLOCK_DIV_16\t\t0x1\n#define SPI_XCOMM_SETTINGS_CLOCK_DIV_4\t\t0x0\n\n#define SPI_XCOMM_CMD_UPDATE_CONFIG\t0x03\n#define SPI_XCOMM_CMD_WRITE\t\t0x04\n\n#define SPI_XCOMM_CLOCK 48000000\n\nstruct spi_xcomm {\n\tstruct i2c_client *i2c;\n\n\tuint16_t settings;\n\tuint16_t chipselect;\n\n\tunsigned int current_speed;\n\n\tuint8_t buf[63];\n};\n\nstatic int spi_xcomm_sync_config(struct spi_xcomm *spi_xcomm, unsigned int len)\n{\n\tuint16_t settings;\n\tuint8_t *buf = spi_xcomm->buf;\n\n\tsettings = spi_xcomm->settings;\n\tsettings |= len << SPI_XCOMM_SETTINGS_LEN_OFFSET;\n\n\tbuf[0] = SPI_XCOMM_CMD_UPDATE_CONFIG;\n\tput_unaligned_be16(settings, &buf[1]);\n\tput_unaligned_be16(spi_xcomm->chipselect, &buf[3]);\n\n\treturn i2c_master_send(spi_xcomm->i2c, buf, 5);\n}\n\nstatic void spi_xcomm_chipselect(struct spi_xcomm *spi_xcomm,\n\tstruct spi_device *spi, int is_active)\n{\n\tunsigned long cs = spi_get_chipselect(spi, 0);\n\tuint16_t chipselect = spi_xcomm->chipselect;\n\n\tif (is_active)\n\t\tchipselect |= BIT(cs);\n\telse\n\t\tchipselect &= ~BIT(cs);\n\n\tspi_xcomm->chipselect = chipselect;\n}\n\nstatic int spi_xcomm_setup_transfer(struct spi_xcomm *spi_xcomm,\n\tstruct spi_device *spi, struct spi_transfer *t, unsigned int *settings)\n{\n\tif (t->len > 62)\n\t\treturn -EINVAL;\n\n\tif (t->speed_hz != spi_xcomm->current_speed) {\n\t\tunsigned int divider;\n\n\t\tdivider = DIV_ROUND_UP(SPI_XCOMM_CLOCK, t->speed_hz);\n\t\tif (divider >= 64)\n\t\t\t*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_64;\n\t\telse if (divider >= 16)\n\t\t\t*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_16;\n\t\telse\n\t\t\t*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_4;\n\n\t\tspi_xcomm->current_speed = t->speed_hz;\n\t}\n\n\tif (spi->mode & SPI_CPOL)\n\t\t*settings |= SPI_XCOMM_SETTINGS_CPOL;\n\telse\n\t\t*settings &= ~SPI_XCOMM_SETTINGS_CPOL;\n\n\tif (spi->mode & SPI_CPHA)\n\t\t*settings &= ~SPI_XCOMM_SETTINGS_CPHA;\n\telse\n\t\t*settings |= SPI_XCOMM_SETTINGS_CPHA;\n\n\tif (spi->mode & SPI_3WIRE)\n\t\t*settings |= SPI_XCOMM_SETTINGS_3WIRE;\n\telse\n\t\t*settings &= ~SPI_XCOMM_SETTINGS_3WIRE;\n\n\treturn 0;\n}\n\nstatic int spi_xcomm_txrx_bufs(struct spi_xcomm *spi_xcomm,\n\tstruct spi_device *spi, struct spi_transfer *t)\n{\n\tint ret;\n\n\tif (t->tx_buf) {\n\t\tspi_xcomm->buf[0] = SPI_XCOMM_CMD_WRITE;\n\t\tmemcpy(spi_xcomm->buf + 1, t->tx_buf, t->len);\n\n\t\tret = i2c_master_send(spi_xcomm->i2c, spi_xcomm->buf, t->len + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != t->len + 1)\n\t\t\treturn -EIO;\n\t} else if (t->rx_buf) {\n\t\tret = i2c_master_recv(spi_xcomm->i2c, t->rx_buf, t->len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != t->len)\n\t\t\treturn -EIO;\n\t}\n\n\treturn t->len;\n}\n\nstatic int spi_xcomm_transfer_one(struct spi_master *master,\n\tstruct spi_message *msg)\n{\n\tstruct spi_xcomm *spi_xcomm = spi_master_get_devdata(master);\n\tunsigned int settings = spi_xcomm->settings;\n\tstruct spi_device *spi = msg->spi;\n\tunsigned cs_change = 0;\n\tstruct spi_transfer *t;\n\tbool is_first = true;\n\tint status = 0;\n\tbool is_last;\n\n\tspi_xcomm_chipselect(spi_xcomm, spi, true);\n\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\n\t\tif (!t->tx_buf && !t->rx_buf && t->len) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = spi_xcomm_setup_transfer(spi_xcomm, spi, t, &settings);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tis_last = list_is_last(&t->transfer_list, &msg->transfers);\n\t\tcs_change = t->cs_change;\n\n\t\tif (cs_change ^ is_last)\n\t\t\tsettings |= BIT(5);\n\t\telse\n\t\t\tsettings &= ~BIT(5);\n\n\t\tif (t->rx_buf) {\n\t\t\tspi_xcomm->settings = settings;\n\t\t\tstatus = spi_xcomm_sync_config(spi_xcomm, t->len);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (settings != spi_xcomm->settings || is_first) {\n\t\t\tspi_xcomm->settings = settings;\n\t\t\tstatus = spi_xcomm_sync_config(spi_xcomm, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (t->len) {\n\t\t\tstatus = spi_xcomm_txrx_bufs(spi_xcomm, spi, t);\n\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (status > 0)\n\t\t\t\tmsg->actual_length += status;\n\t\t}\n\t\tstatus = 0;\n\n\t\tspi_transfer_delay_exec(t);\n\n\t\tis_first = false;\n\t}\n\n\tif (status != 0 || !cs_change)\n\t\tspi_xcomm_chipselect(spi_xcomm, spi, false);\n\n\tmsg->status = status;\n\tspi_finalize_current_message(master);\n\n\treturn status;\n}\n\nstatic int spi_xcomm_probe(struct i2c_client *i2c)\n{\n\tstruct spi_xcomm *spi_xcomm;\n\tstruct spi_master *master;\n\tint ret;\n\n\tmaster = spi_alloc_master(&i2c->dev, sizeof(*spi_xcomm));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tspi_xcomm = spi_master_get_devdata(master);\n\tspi_xcomm->i2c = i2c;\n\n\tmaster->num_chipselect = 16;\n\tmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_3WIRE;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tmaster->transfer_one_message = spi_xcomm_transfer_one;\n\tmaster->dev.of_node = i2c->dev.of_node;\n\ti2c_set_clientdata(i2c, master);\n\n\tret = devm_spi_register_master(&i2c->dev, master);\n\tif (ret < 0)\n\t\tspi_master_put(master);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id spi_xcomm_ids[] = {\n\t{ \"spi-xcomm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, spi_xcomm_ids);\n\nstatic struct i2c_driver spi_xcomm_driver = {\n\t.driver = {\n\t\t.name\t= \"spi-xcomm\",\n\t},\n\t.id_table\t= spi_xcomm_ids,\n\t.probe\t\t= spi_xcomm_probe,\n};\nmodule_i2c_driver(spi_xcomm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD-FMCOMMS1-EBZ board I2C-SPI bridge driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}