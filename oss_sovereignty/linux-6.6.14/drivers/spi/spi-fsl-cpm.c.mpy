{
  "module_name": "spi-fsl-cpm.c",
  "hash_id": "cfb399d066f06f0de31df8f42dee253aaae254be3dd9a04c9b0263e811b9f4de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-cpm.c",
  "human_readable_source": "\n \n#include <asm/cpm.h>\n#include <soc/fsl/qe/qe.h>\n#include <linux/dma-mapping.h>\n#include <linux/fsl_devices.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/byteorder/generic.h>\n\n#include \"spi-fsl-cpm.h\"\n#include \"spi-fsl-lib.h\"\n#include \"spi-fsl-spi.h\"\n\n \n#ifdef CONFIG_CPM1\n#include <asm/cpm1.h>\n#define CPM_SPI_CMD mk_cr_cmd(CPM_CR_CH_SPI, 0)\n#else\n#include <asm/cpm2.h>\n#define CPM_SPI_CMD mk_cr_cmd(CPM_CR_SPI_PAGE, CPM_CR_SPI_SBLOCK, 0, 0)\n#endif\n\n#define\tSPIE_TXB\t0x00000200\t \n#define\tSPIE_RXB\t0x00000100\t \n\n \n#define\tSPCOM_STR\t(1 << 23)\t \n\n#define\tSPI_PRAM_SIZE\t0x100\n#define\tSPI_MRBLR\t((unsigned int)PAGE_SIZE)\n\nstatic void *fsl_dummy_rx;\nstatic DEFINE_MUTEX(fsl_dummy_rx_lock);\nstatic int fsl_dummy_rx_refcnt;\n\nvoid fsl_spi_cpm_reinit_txrx(struct mpc8xxx_spi *mspi)\n{\n\tif (mspi->flags & SPI_QE) {\n\t\tqe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,\n\t\t\t     QE_CR_PROTOCOL_UNSPECIFIED, 0);\n\t} else {\n\t\tif (mspi->flags & SPI_CPM1) {\n\t\t\tiowrite32be(0, &mspi->pram->rstate);\n\t\t\tiowrite16be(ioread16be(&mspi->pram->rbase),\n\t\t\t\t    &mspi->pram->rbptr);\n\t\t\tiowrite32be(0, &mspi->pram->tstate);\n\t\t\tiowrite16be(ioread16be(&mspi->pram->tbase),\n\t\t\t\t    &mspi->pram->tbptr);\n\t\t} else {\n\t\t\tcpm_command(CPM_SPI_CMD, CPM_CR_INIT_TRX);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_reinit_txrx);\n\nstatic void fsl_spi_cpm_bufs_start(struct mpc8xxx_spi *mspi)\n{\n\tstruct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;\n\tstruct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;\n\tunsigned int xfer_len = min(mspi->count, SPI_MRBLR);\n\tunsigned int xfer_ofs;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\txfer_ofs = mspi->xfer_in_progress->len - mspi->count;\n\n\tif (mspi->rx_dma == mspi->dma_dummy_rx)\n\t\tiowrite32be(mspi->rx_dma, &rx_bd->cbd_bufaddr);\n\telse\n\t\tiowrite32be(mspi->rx_dma + xfer_ofs, &rx_bd->cbd_bufaddr);\n\tiowrite16be(0, &rx_bd->cbd_datlen);\n\tiowrite16be(BD_SC_EMPTY | BD_SC_INTRPT | BD_SC_WRAP, &rx_bd->cbd_sc);\n\n\tif (mspi->tx_dma == mspi->dma_dummy_tx)\n\t\tiowrite32be(mspi->tx_dma, &tx_bd->cbd_bufaddr);\n\telse\n\t\tiowrite32be(mspi->tx_dma + xfer_ofs, &tx_bd->cbd_bufaddr);\n\tiowrite16be(xfer_len, &tx_bd->cbd_datlen);\n\tiowrite16be(BD_SC_READY | BD_SC_INTRPT | BD_SC_WRAP | BD_SC_LAST,\n\t\t    &tx_bd->cbd_sc);\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->command, SPCOM_STR);\n}\n\nint fsl_spi_cpm_bufs(struct mpc8xxx_spi *mspi,\n\t\t     struct spi_transfer *t, bool is_dma_mapped)\n{\n\tstruct device *dev = mspi->dev;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\tif (is_dma_mapped) {\n\t\tmspi->map_tx_dma = 0;\n\t\tmspi->map_rx_dma = 0;\n\t} else {\n\t\tmspi->map_tx_dma = 1;\n\t\tmspi->map_rx_dma = 1;\n\t}\n\n\tif (!t->tx_buf) {\n\t\tmspi->tx_dma = mspi->dma_dummy_tx;\n\t\tmspi->map_tx_dma = 0;\n\t}\n\n\tif (!t->rx_buf) {\n\t\tmspi->rx_dma = mspi->dma_dummy_rx;\n\t\tmspi->map_rx_dma = 0;\n\t}\n\tif (t->bits_per_word == 16 && t->tx_buf) {\n\t\tconst u16 *src = t->tx_buf;\n\t\t__le16 *dst;\n\t\tint i;\n\n\t\tdst = kmalloc(t->len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < t->len >> 1; i++)\n\t\t\tdst[i] = cpu_to_le16p(src + i);\n\n\t\tmspi->tx = dst;\n\t\tmspi->map_tx_dma = 1;\n\t}\n\n\tif (mspi->map_tx_dma) {\n\t\tvoid *nonconst_tx = (void *)mspi->tx;  \n\n\t\tmspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, mspi->tx_dma)) {\n\t\t\tdev_err(dev, \"unable to map tx dma\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (t->tx_buf) {\n\t\tmspi->tx_dma = t->tx_dma;\n\t}\n\n\tif (mspi->map_rx_dma) {\n\t\tmspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, mspi->rx_dma)) {\n\t\t\tdev_err(dev, \"unable to map rx dma\\n\");\n\t\t\tgoto err_rx_dma;\n\t\t}\n\t} else if (t->rx_buf) {\n\t\tmspi->rx_dma = t->rx_dma;\n\t}\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->mask, SPIE_RXB);\n\n\tmspi->xfer_in_progress = t;\n\tmspi->count = t->len;\n\n\t \n\tfsl_spi_cpm_bufs_start(mspi);\n\n\treturn 0;\n\nerr_rx_dma:\n\tif (mspi->map_tx_dma)\n\t\tdma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_bufs);\n\nvoid fsl_spi_cpm_bufs_complete(struct mpc8xxx_spi *mspi)\n{\n\tstruct device *dev = mspi->dev;\n\tstruct spi_transfer *t = mspi->xfer_in_progress;\n\n\tif (mspi->map_tx_dma)\n\t\tdma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\n\tif (mspi->map_rx_dma)\n\t\tdma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);\n\tmspi->xfer_in_progress = NULL;\n\n\tif (t->bits_per_word == 16 && t->rx_buf) {\n\t\tint i;\n\n\t\tfor (i = 0; i < t->len; i += 2)\n\t\t\tle16_to_cpus(t->rx_buf + i);\n\t}\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_bufs_complete);\n\nvoid fsl_spi_cpm_irq(struct mpc8xxx_spi *mspi, u32 events)\n{\n\tu16 len;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\tdev_dbg(mspi->dev, \"%s: bd datlen %d, count %d\\n\", __func__,\n\t\tioread16be(&mspi->rx_bd->cbd_datlen), mspi->count);\n\n\tlen = ioread16be(&mspi->rx_bd->cbd_datlen);\n\tif (len > mspi->count) {\n\t\tWARN_ON(1);\n\t\tlen = mspi->count;\n\t}\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->event, events);\n\n\tmspi->count -= len;\n\tif (mspi->count)\n\t\tfsl_spi_cpm_bufs_start(mspi);\n\telse\n\t\tcomplete(&mspi->done);\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_irq);\n\nstatic void *fsl_spi_alloc_dummy_rx(void)\n{\n\tmutex_lock(&fsl_dummy_rx_lock);\n\n\tif (!fsl_dummy_rx)\n\t\tfsl_dummy_rx = kmalloc(SPI_MRBLR, GFP_KERNEL);\n\tif (fsl_dummy_rx)\n\t\tfsl_dummy_rx_refcnt++;\n\n\tmutex_unlock(&fsl_dummy_rx_lock);\n\n\treturn fsl_dummy_rx;\n}\n\nstatic void fsl_spi_free_dummy_rx(void)\n{\n\tmutex_lock(&fsl_dummy_rx_lock);\n\n\tswitch (fsl_dummy_rx_refcnt) {\n\tcase 0:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase 1:\n\t\tkfree(fsl_dummy_rx);\n\t\tfsl_dummy_rx = NULL;\n\t\tfallthrough;\n\tdefault:\n\t\tfsl_dummy_rx_refcnt--;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&fsl_dummy_rx_lock);\n}\n\nstatic unsigned long fsl_spi_cpm_get_pram(struct mpc8xxx_spi *mspi)\n{\n\tstruct device *dev = mspi->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst u32 *iprop;\n\tint size;\n\tvoid __iomem *spi_base;\n\tunsigned long pram_ofs = -ENOMEM;\n\n\t \n\tiprop = of_get_property(np, \"reg\", &size);\n\n\t \n\tif (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)\n\t\treturn cpm_muram_alloc_fixed(iprop[2], SPI_PRAM_SIZE);\n\n\t \n\tif (mspi->flags & SPI_QE) {\n\t\tpram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\n\t\tqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,\n\t\t\t     QE_CR_PROTOCOL_UNSPECIFIED, pram_ofs);\n\t\treturn pram_ofs;\n\t}\n\n\tspi_base = of_iomap(np, 1);\n\tif (spi_base == NULL)\n\t\treturn -EINVAL;\n\n\tif (mspi->flags & SPI_CPM2) {\n\t\tpram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\n\t\tout_be16(spi_base, pram_ofs);\n\t}\n\n\tiounmap(spi_base);\n\treturn pram_ofs;\n}\n\nint fsl_spi_cpm_init(struct mpc8xxx_spi *mspi)\n{\n\tstruct device *dev = mspi->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst u32 *iprop;\n\tint size;\n\tunsigned long bds_ofs;\n\n\tif (!(mspi->flags & SPI_CPM_MODE))\n\t\treturn 0;\n\n\tif (!fsl_spi_alloc_dummy_rx())\n\t\treturn -ENOMEM;\n\n\tif (mspi->flags & SPI_QE) {\n\t\tiprop = of_get_property(np, \"cell-index\", &size);\n\t\tif (iprop && size == sizeof(*iprop))\n\t\t\tmspi->subblock = *iprop;\n\n\t\tswitch (mspi->subblock) {\n\t\tdefault:\n\t\t\tdev_warn(dev, \"cell-index unspecified, assuming SPI1\\n\");\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tmspi->subblock = QE_CR_SUBBLOCK_SPI1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmspi->subblock = QE_CR_SUBBLOCK_SPI2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mspi->flags & SPI_CPM1) {\n\t\tvoid __iomem *pram;\n\n\t\tpram = devm_platform_ioremap_resource(to_platform_device(dev),\n\t\t\t\t\t\t      1);\n\t\tif (IS_ERR(pram))\n\t\t\tmspi->pram = NULL;\n\t\telse\n\t\t\tmspi->pram = pram;\n\t} else {\n\t\tunsigned long pram_ofs = fsl_spi_cpm_get_pram(mspi);\n\n\t\tif (IS_ERR_VALUE(pram_ofs))\n\t\t\tmspi->pram = NULL;\n\t\telse\n\t\t\tmspi->pram = cpm_muram_addr(pram_ofs);\n\t}\n\tif (mspi->pram == NULL) {\n\t\tdev_err(dev, \"can't allocate spi parameter ram\\n\");\n\t\tgoto err_pram;\n\t}\n\n\tbds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +\n\t\t\t\t  sizeof(*mspi->rx_bd), 8);\n\tif (IS_ERR_VALUE(bds_ofs)) {\n\t\tdev_err(dev, \"can't allocate bds\\n\");\n\t\tgoto err_bds;\n\t}\n\n\tmspi->dma_dummy_tx = dma_map_single(dev, ZERO_PAGE(0), PAGE_SIZE,\n\t\t\t\t\t    DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, mspi->dma_dummy_tx)) {\n\t\tdev_err(dev, \"unable to map dummy tx buffer\\n\");\n\t\tgoto err_dummy_tx;\n\t}\n\n\tmspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, mspi->dma_dummy_rx)) {\n\t\tdev_err(dev, \"unable to map dummy rx buffer\\n\");\n\t\tgoto err_dummy_rx;\n\t}\n\n\tmspi->tx_bd = cpm_muram_addr(bds_ofs);\n\tmspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));\n\n\t \n\tiowrite16be(cpm_muram_offset(mspi->tx_bd), &mspi->pram->tbase);\n\tiowrite16be(cpm_muram_offset(mspi->rx_bd), &mspi->pram->rbase);\n\tiowrite8(CPMFCR_EB | CPMFCR_GBL, &mspi->pram->tfcr);\n\tiowrite8(CPMFCR_EB | CPMFCR_GBL, &mspi->pram->rfcr);\n\tiowrite16be(SPI_MRBLR, &mspi->pram->mrblr);\n\tiowrite32be(0, &mspi->pram->rstate);\n\tiowrite32be(0, &mspi->pram->rdp);\n\tiowrite16be(0, &mspi->pram->rbptr);\n\tiowrite16be(0, &mspi->pram->rbc);\n\tiowrite32be(0, &mspi->pram->rxtmp);\n\tiowrite32be(0, &mspi->pram->tstate);\n\tiowrite32be(0, &mspi->pram->tdp);\n\tiowrite16be(0, &mspi->pram->tbptr);\n\tiowrite16be(0, &mspi->pram->tbc);\n\tiowrite32be(0, &mspi->pram->txtmp);\n\n\treturn 0;\n\nerr_dummy_rx:\n\tdma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\nerr_dummy_tx:\n\tcpm_muram_free(bds_ofs);\nerr_bds:\n\tif (!(mspi->flags & SPI_CPM1))\n\t\tcpm_muram_free(cpm_muram_offset(mspi->pram));\nerr_pram:\n\tfsl_spi_free_dummy_rx();\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_init);\n\nvoid fsl_spi_cpm_free(struct mpc8xxx_spi *mspi)\n{\n\tstruct device *dev = mspi->dev;\n\n\tif (!(mspi->flags & SPI_CPM_MODE))\n\t\treturn;\n\n\tdma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);\n\tdma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\n\tcpm_muram_free(cpm_muram_offset(mspi->tx_bd));\n\tif (!(mspi->flags & SPI_CPM1))\n\t\tcpm_muram_free(cpm_muram_offset(mspi->pram));\n\tfsl_spi_free_dummy_rx();\n}\nEXPORT_SYMBOL_GPL(fsl_spi_cpm_free);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}