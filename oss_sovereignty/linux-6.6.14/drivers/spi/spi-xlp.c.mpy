{
  "module_name": "spi-xlp.c",
  "hash_id": "759f4b648265430c3ec62fe4edf728ee6309ba2811573d158b0b37ddcd58b783",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-xlp.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n\n \n#define XLP_SPI_CONFIG\t\t\t0x00\n#define XLP_SPI_CPHA\t\t\tBIT(0)\n#define XLP_SPI_CPOL\t\t\tBIT(1)\n#define XLP_SPI_CS_POL\t\t\tBIT(2)\n#define XLP_SPI_TXMISO_EN\t\tBIT(3)\n#define XLP_SPI_TXMOSI_EN\t\tBIT(4)\n#define XLP_SPI_RXMISO_EN\t\tBIT(5)\n#define XLP_SPI_CS_LSBFE\t\tBIT(10)\n#define XLP_SPI_RXCAP_EN\t\tBIT(11)\n\n \n#define XLP_SPI_FDIV\t\t\t0x04\n\n \n#define XLP_SPI_CMD\t\t\t0x08\n#define XLP_SPI_CMD_IDLE_MASK\t\t0x0\n#define XLP_SPI_CMD_TX_MASK\t\t0x1\n#define XLP_SPI_CMD_RX_MASK\t\t0x2\n#define XLP_SPI_CMD_TXRX_MASK\t\t0x3\n#define XLP_SPI_CMD_CONT\t\tBIT(4)\n#define XLP_SPI_XFR_BITCNT_SHIFT\t16\n\n \n#define XLP_SPI_STATUS\t\t\t0x0c\n#define XLP_SPI_XFR_PENDING\t\tBIT(0)\n#define XLP_SPI_XFR_DONE\t\tBIT(1)\n#define XLP_SPI_TX_INT\t\t\tBIT(2)\n#define XLP_SPI_RX_INT\t\t\tBIT(3)\n#define XLP_SPI_TX_UF\t\t\tBIT(4)\n#define XLP_SPI_RX_OF\t\t\tBIT(5)\n#define XLP_SPI_STAT_MASK\t\t0x3f\n\n \n#define XLP_SPI_INTR_EN\t\t\t0x10\n#define XLP_SPI_INTR_DONE\t\tBIT(0)\n#define XLP_SPI_INTR_TXTH\t\tBIT(1)\n#define XLP_SPI_INTR_RXTH\t\tBIT(2)\n#define XLP_SPI_INTR_TXUF\t\tBIT(3)\n#define XLP_SPI_INTR_RXOF\t\tBIT(4)\n\n \n#define XLP_SPI_FIFO_THRESH\t\t0x14\n\n \n#define XLP_SPI_FIFO_WCNT\t\t0x18\n#define XLP_SPI_RXFIFO_WCNT_MASK\t0xf\n#define XLP_SPI_TXFIFO_WCNT_MASK\t0xf0\n#define XLP_SPI_TXFIFO_WCNT_SHIFT\t4\n\n \n#define XLP_SPI_TXDATA_FIFO\t\t0x1c\n\n \n#define XLP_SPI_RXDATA_FIFO\t\t0x20\n\n \n#define XLP_SPI_SYSCTRL\t\t\t0x100\n#define XLP_SPI_SYS_RESET\t\tBIT(0)\n#define XLP_SPI_SYS_CLKDIS\t\tBIT(1)\n#define XLP_SPI_SYS_PMEN\t\tBIT(8)\n\n#define SPI_CS_OFFSET\t\t\t0x40\n#define XLP_SPI_TXRXTH\t\t\t0x80\n#define XLP_SPI_FIFO_SIZE\t\t8\n#define XLP_SPI_MAX_CS\t\t\t4\n#define XLP_SPI_DEFAULT_FREQ\t\t133333333\n#define XLP_SPI_FDIV_MIN\t\t4\n#define XLP_SPI_FDIV_MAX\t\t65535\n \n#define XLP_SPI_XFER_SIZE\t\t28\n\nstruct xlp_spi_priv {\n\tstruct device\t\tdev;\t\t \n\tvoid __iomem\t\t*base;\t\t \n\tconst u8\t\t*tx_buf;\t \n\tu8\t\t\t*rx_buf;\t \n\tint\t\t\ttx_len;\t\t \n\tint\t\t\trx_len;\t\t \n\tint\t\t\ttxerrors;\t \n\tint\t\t\trxerrors;\t \n\tint\t\t\tcs;\t\t \n\tu32\t\t\tspi_clk;\t \n\tbool\t\t\tcmd_cont;\t \n\tstruct completion\tdone;\t\t \n};\n\nstatic inline u32 xlp_spi_reg_read(struct xlp_spi_priv *priv,\n\t\t\t\tint cs, int regoff)\n{\n\treturn readl(priv->base + regoff + cs * SPI_CS_OFFSET);\n}\n\nstatic inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,\n\t\t\t\tint regoff, u32 val)\n{\n\twritel(val, priv->base + regoff + cs * SPI_CS_OFFSET);\n}\n\nstatic inline void xlp_spi_sysctl_write(struct xlp_spi_priv *priv,\n\t\t\t\tint regoff, u32 val)\n{\n\twritel(val, priv->base + regoff);\n}\n\n \nstatic void xlp_spi_sysctl_setup(struct xlp_spi_priv *xspi)\n{\n\tint cs;\n\n\tfor (cs = 0; cs < XLP_SPI_MAX_CS; cs++)\n\t\txlp_spi_sysctl_write(xspi, XLP_SPI_SYSCTRL,\n\t\t\t\tXLP_SPI_SYS_RESET << cs);\n\txlp_spi_sysctl_write(xspi, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);\n}\n\nstatic int xlp_spi_setup(struct spi_device *spi)\n{\n\tstruct xlp_spi_priv *xspi;\n\tu32 fdiv, cfg;\n\tint cs;\n\n\txspi = spi_master_get_devdata(spi->master);\n\tcs = spi_get_chipselect(spi, 0);\n\t \n\tfdiv = DIV_ROUND_UP(xspi->spi_clk, spi->max_speed_hz);\n\tif (fdiv > XLP_SPI_FDIV_MAX)\n\t\tfdiv = XLP_SPI_FDIV_MAX;\n\telse if (fdiv < XLP_SPI_FDIV_MIN)\n\t\tfdiv = XLP_SPI_FDIV_MIN;\n\n\txlp_spi_reg_write(xspi, cs, XLP_SPI_FDIV, fdiv);\n\txlp_spi_reg_write(xspi, cs, XLP_SPI_FIFO_THRESH, XLP_SPI_TXRXTH);\n\tcfg = xlp_spi_reg_read(xspi, cs, XLP_SPI_CONFIG);\n\tif (spi->mode & SPI_CPHA)\n\t\tcfg |= XLP_SPI_CPHA;\n\telse\n\t\tcfg &= ~XLP_SPI_CPHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tcfg |= XLP_SPI_CPOL;\n\telse\n\t\tcfg &= ~XLP_SPI_CPOL;\n\tif (!(spi->mode & SPI_CS_HIGH))\n\t\tcfg |= XLP_SPI_CS_POL;\n\telse\n\t\tcfg &= ~XLP_SPI_CS_POL;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tcfg |= XLP_SPI_CS_LSBFE;\n\telse\n\t\tcfg &= ~XLP_SPI_CS_LSBFE;\n\n\tcfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN;\n\tif (fdiv == 4)\n\t\tcfg |= XLP_SPI_RXCAP_EN;\n\txlp_spi_reg_write(xspi, cs, XLP_SPI_CONFIG, cfg);\n\n\treturn 0;\n}\n\nstatic void xlp_spi_read_rxfifo(struct xlp_spi_priv *xspi)\n{\n\tu32 rx_data, rxfifo_cnt;\n\tint i, j, nbytes;\n\n\trxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);\n\trxfifo_cnt &= XLP_SPI_RXFIFO_WCNT_MASK;\n\twhile (rxfifo_cnt) {\n\t\trx_data = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_RXDATA_FIFO);\n\t\tj = 0;\n\t\tnbytes = min(xspi->rx_len, 4);\n\t\tfor (i = nbytes - 1; i >= 0; i--, j++)\n\t\t\txspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;\n\n\t\txspi->rx_len -= nbytes;\n\t\txspi->rx_buf += nbytes;\n\t\trxfifo_cnt--;\n\t}\n}\n\nstatic void xlp_spi_fill_txfifo(struct xlp_spi_priv *xspi)\n{\n\tu32 tx_data, txfifo_cnt;\n\tint i, j, nbytes;\n\n\ttxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);\n\ttxfifo_cnt &= XLP_SPI_TXFIFO_WCNT_MASK;\n\ttxfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_SHIFT;\n\twhile (xspi->tx_len && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {\n\t\tj = 0;\n\t\ttx_data = 0;\n\t\tnbytes = min(xspi->tx_len, 4);\n\t\tfor (i = nbytes - 1; i >= 0; i--, j++)\n\t\t\ttx_data |= xspi->tx_buf[i] << (j * 8);\n\n\t\txlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);\n\t\txspi->tx_len -= nbytes;\n\t\txspi->tx_buf += nbytes;\n\t\ttxfifo_cnt++;\n\t}\n}\n\nstatic irqreturn_t xlp_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct xlp_spi_priv *xspi = dev_id;\n\tu32 stat;\n\n\tstat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS) &\n\t\tXLP_SPI_STAT_MASK;\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\tif (stat & XLP_SPI_TX_INT) {\n\t\tif (xspi->tx_len)\n\t\t\txlp_spi_fill_txfifo(xspi);\n\t\tif (stat & XLP_SPI_TX_UF)\n\t\t\txspi->txerrors++;\n\t}\n\n\tif (stat & XLP_SPI_RX_INT) {\n\t\tif (xspi->rx_len)\n\t\t\txlp_spi_read_rxfifo(xspi);\n\t\tif (stat & XLP_SPI_RX_OF)\n\t\t\txspi->rxerrors++;\n\t}\n\n\t \n\txlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, stat);\n\tif (stat & XLP_SPI_XFR_DONE)\n\t\tcomplete(&xspi->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,\n\t\t\tint cmd_cont)\n{\n\tu32 cmd = 0;\n\n\tif (xspi->tx_buf)\n\t\tcmd |= XLP_SPI_CMD_TX_MASK;\n\tif (xspi->rx_buf)\n\t\tcmd |= XLP_SPI_CMD_RX_MASK;\n\tif (cmd_cont)\n\t\tcmd |= XLP_SPI_CMD_CONT;\n\tcmd |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_SHIFT);\n\txlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, cmd);\n}\n\nstatic int xlp_spi_xfer_block(struct  xlp_spi_priv *xs,\n\t\tconst unsigned char *tx_buf,\n\t\tunsigned char *rx_buf, int xfer_len, int cmd_cont)\n{\n\tint timeout;\n\tu32 intr_mask = 0;\n\n\txs->tx_buf = tx_buf;\n\txs->rx_buf = rx_buf;\n\txs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;\n\txs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;\n\txs->txerrors = xs->rxerrors = 0;\n\n\t \n\tif (xs->tx_len)\n\t\txlp_spi_fill_txfifo(xs);\n\n\txlp_spi_send_cmd(xs, xfer_len, cmd_cont);\n\n\t \n\tif (xs->tx_len)\n\t\tintr_mask |= XLP_SPI_INTR_TXTH | XLP_SPI_INTR_TXUF |\n\t\t\t\tXLP_SPI_INTR_RXTH | XLP_SPI_INTR_RXOF;\n\telse\n\t\tintr_mask |= XLP_SPI_INTR_RXTH | XLP_SPI_INTR_RXOF;\n\n\tintr_mask |= XLP_SPI_INTR_DONE;\n\txlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, intr_mask);\n\n\ttimeout = wait_for_completion_timeout(&xs->done,\n\t\t\t\tmsecs_to_jiffies(1000));\n\t \n\txlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x0);\n\tif (!timeout) {\n\t\tdev_err(&xs->dev, \"xfer timedout!\\n\");\n\t\tgoto out;\n\t}\n\tif (xs->txerrors || xs->rxerrors)\n\t\tdev_err(&xs->dev, \"Over/Underflow rx %d tx %d xfer %d!\\n\",\n\t\t\t\txs->rxerrors, xs->txerrors, xfer_len);\n\n\treturn xfer_len;\nout:\n\treturn -ETIMEDOUT;\n}\n\nstatic int xlp_spi_txrx_bufs(struct xlp_spi_priv *xs, struct spi_transfer *t)\n{\n\tint bytesleft, sz;\n\tunsigned char *rx_buf;\n\tconst unsigned char *tx_buf;\n\n\ttx_buf = t->tx_buf;\n\trx_buf = t->rx_buf;\n\tbytesleft = t->len;\n\twhile (bytesleft) {\n\t\tif (bytesleft > XLP_SPI_XFER_SIZE)\n\t\t\tsz = xlp_spi_xfer_block(xs, tx_buf, rx_buf,\n\t\t\t\t\tXLP_SPI_XFER_SIZE, 1);\n\t\telse\n\t\t\tsz = xlp_spi_xfer_block(xs, tx_buf, rx_buf,\n\t\t\t\t\tbytesleft, xs->cmd_cont);\n\t\tif (sz < 0)\n\t\t\treturn sz;\n\t\tbytesleft -= sz;\n\t\tif (tx_buf)\n\t\t\ttx_buf += sz;\n\t\tif (rx_buf)\n\t\t\trx_buf += sz;\n\t}\n\treturn bytesleft;\n}\n\nstatic int xlp_spi_transfer_one(struct spi_master *master,\n\t\t\t\t\tstruct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *t)\n{\n\tstruct xlp_spi_priv *xspi = spi_master_get_devdata(master);\n\tint ret = 0;\n\n\txspi->cs = spi_get_chipselect(spi, 0);\n\txspi->dev = spi->dev;\n\n\tif (spi_transfer_is_last(master, t))\n\t\txspi->cmd_cont = 0;\n\telse\n\t\txspi->cmd_cont = 1;\n\n\tif (xlp_spi_txrx_bufs(xspi, t))\n\t\tret = -EIO;\n\n\tspi_finalize_current_transfer(master);\n\treturn ret;\n}\n\nstatic int xlp_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct xlp_spi_priv *xspi;\n\tstruct clk *clk;\n\tint irq, err;\n\n\txspi = devm_kzalloc(&pdev->dev, sizeof(*xspi), GFP_KERNEL);\n\tif (!xspi)\n\t\treturn -ENOMEM;\n\n\txspi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xspi->base))\n\t\treturn PTR_ERR(xspi->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\terr = devm_request_irq(&pdev->dev, irq, xlp_spi_interrupt, 0,\n\t\t\tpdev->name, xspi);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to request irq %d\\n\", irq);\n\t\treturn err;\n\t}\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"could not get spi clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\txspi->spi_clk = clk_get_rate(clk);\n\n\tmaster = spi_alloc_master(&pdev->dev, 0);\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"could not alloc master\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmaster->bus_num = 0;\n\tmaster->num_chipselect = XLP_SPI_MAX_CS;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->setup = xlp_spi_setup;\n\tmaster->transfer_one = xlp_spi_transfer_one;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&xspi->done);\n\tspi_master_set_devdata(master, xspi);\n\txlp_spi_sysctl_setup(xspi);\n\n\t \n\terr = devm_spi_register_master(&pdev->dev, master);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"spi register master failed!\\n\");\n\t\tspi_master_put(master);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xlp_spi_acpi_match[] = {\n\t{ \"BRCM900D\", 0 },\n\t{ \"CAV900D\",  0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, xlp_spi_acpi_match);\n#endif\n\nstatic struct platform_driver xlp_spi_driver = {\n\t.probe\t= xlp_spi_probe,\n\t.driver = {\n\t\t.name\t= \"xlp-spi\",\n\t\t.acpi_match_table = ACPI_PTR(xlp_spi_acpi_match),\n\t},\n};\nmodule_platform_driver(xlp_spi_driver);\n\nMODULE_AUTHOR(\"Kamlakant Patel <kamlakant.patel@broadcom.com>\");\nMODULE_DESCRIPTION(\"Netlogic XLP SPI controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}