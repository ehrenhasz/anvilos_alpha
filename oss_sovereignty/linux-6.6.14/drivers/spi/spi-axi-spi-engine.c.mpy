{
  "module_name": "spi-axi-spi-engine.c",
  "hash_id": "3fcd26cf67f6c568dd5df5062943ec2bb5bfd3a4d8a51b5d01fd54f318b509c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-axi-spi-engine.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n#define SPI_ENGINE_VERSION_MAJOR(x)\t((x >> 16) & 0xff)\n#define SPI_ENGINE_VERSION_MINOR(x)\t((x >> 8) & 0xff)\n#define SPI_ENGINE_VERSION_PATCH(x)\t(x & 0xff)\n\n#define SPI_ENGINE_REG_VERSION\t\t\t0x00\n\n#define SPI_ENGINE_REG_RESET\t\t\t0x40\n\n#define SPI_ENGINE_REG_INT_ENABLE\t\t0x80\n#define SPI_ENGINE_REG_INT_PENDING\t\t0x84\n#define SPI_ENGINE_REG_INT_SOURCE\t\t0x88\n\n#define SPI_ENGINE_REG_SYNC_ID\t\t\t0xc0\n\n#define SPI_ENGINE_REG_CMD_FIFO_ROOM\t\t0xd0\n#define SPI_ENGINE_REG_SDO_FIFO_ROOM\t\t0xd4\n#define SPI_ENGINE_REG_SDI_FIFO_LEVEL\t\t0xd8\n\n#define SPI_ENGINE_REG_CMD_FIFO\t\t\t0xe0\n#define SPI_ENGINE_REG_SDO_DATA_FIFO\t\t0xe4\n#define SPI_ENGINE_REG_SDI_DATA_FIFO\t\t0xe8\n#define SPI_ENGINE_REG_SDI_DATA_FIFO_PEEK\t0xec\n\n#define SPI_ENGINE_INT_CMD_ALMOST_EMPTY\t\tBIT(0)\n#define SPI_ENGINE_INT_SDO_ALMOST_EMPTY\t\tBIT(1)\n#define SPI_ENGINE_INT_SDI_ALMOST_FULL\t\tBIT(2)\n#define SPI_ENGINE_INT_SYNC\t\t\tBIT(3)\n\n#define SPI_ENGINE_CONFIG_CPHA\t\t\tBIT(0)\n#define SPI_ENGINE_CONFIG_CPOL\t\t\tBIT(1)\n#define SPI_ENGINE_CONFIG_3WIRE\t\t\tBIT(2)\n\n#define SPI_ENGINE_INST_TRANSFER\t\t0x0\n#define SPI_ENGINE_INST_ASSERT\t\t\t0x1\n#define SPI_ENGINE_INST_WRITE\t\t\t0x2\n#define SPI_ENGINE_INST_MISC\t\t\t0x3\n\n#define SPI_ENGINE_CMD_REG_CLK_DIV\t\t0x0\n#define SPI_ENGINE_CMD_REG_CONFIG\t\t0x1\n\n#define SPI_ENGINE_MISC_SYNC\t\t\t0x0\n#define SPI_ENGINE_MISC_SLEEP\t\t\t0x1\n\n#define SPI_ENGINE_TRANSFER_WRITE\t\t0x1\n#define SPI_ENGINE_TRANSFER_READ\t\t0x2\n\n#define SPI_ENGINE_CMD(inst, arg1, arg2) \\\n\t(((inst) << 12) | ((arg1) << 8) | (arg2))\n\n#define SPI_ENGINE_CMD_TRANSFER(flags, n) \\\n\tSPI_ENGINE_CMD(SPI_ENGINE_INST_TRANSFER, (flags), (n))\n#define SPI_ENGINE_CMD_ASSERT(delay, cs) \\\n\tSPI_ENGINE_CMD(SPI_ENGINE_INST_ASSERT, (delay), (cs))\n#define SPI_ENGINE_CMD_WRITE(reg, val) \\\n\tSPI_ENGINE_CMD(SPI_ENGINE_INST_WRITE, (reg), (val))\n#define SPI_ENGINE_CMD_SLEEP(delay) \\\n\tSPI_ENGINE_CMD(SPI_ENGINE_INST_MISC, SPI_ENGINE_MISC_SLEEP, (delay))\n#define SPI_ENGINE_CMD_SYNC(id) \\\n\tSPI_ENGINE_CMD(SPI_ENGINE_INST_MISC, SPI_ENGINE_MISC_SYNC, (id))\n\nstruct spi_engine_program {\n\tunsigned int length;\n\tuint16_t instructions[];\n};\n\nstruct spi_engine {\n\tstruct clk *clk;\n\tstruct clk *ref_clk;\n\n\tspinlock_t lock;\n\n\tvoid __iomem *base;\n\n\tstruct spi_message *msg;\n\tstruct spi_engine_program *p;\n\tunsigned cmd_length;\n\tconst uint16_t *cmd_buf;\n\n\tstruct spi_transfer *tx_xfer;\n\tunsigned int tx_length;\n\tconst uint8_t *tx_buf;\n\n\tstruct spi_transfer *rx_xfer;\n\tunsigned int rx_length;\n\tuint8_t *rx_buf;\n\n\tunsigned int sync_id;\n\tunsigned int completed_id;\n\n\tunsigned int int_enable;\n};\n\nstatic void spi_engine_program_add_cmd(struct spi_engine_program *p,\n\tbool dry, uint16_t cmd)\n{\n\tif (!dry)\n\t\tp->instructions[p->length] = cmd;\n\tp->length++;\n}\n\nstatic unsigned int spi_engine_get_config(struct spi_device *spi)\n{\n\tunsigned int config = 0;\n\n\tif (spi->mode & SPI_CPOL)\n\t\tconfig |= SPI_ENGINE_CONFIG_CPOL;\n\tif (spi->mode & SPI_CPHA)\n\t\tconfig |= SPI_ENGINE_CONFIG_CPHA;\n\tif (spi->mode & SPI_3WIRE)\n\t\tconfig |= SPI_ENGINE_CONFIG_3WIRE;\n\n\treturn config;\n}\n\nstatic unsigned int spi_engine_get_clk_div(struct spi_engine *spi_engine,\n\tstruct spi_device *spi, struct spi_transfer *xfer)\n{\n\tunsigned int clk_div;\n\n\tclk_div = DIV_ROUND_UP(clk_get_rate(spi_engine->ref_clk),\n\t\txfer->speed_hz * 2);\n\tif (clk_div > 255)\n\t\tclk_div = 255;\n\telse if (clk_div > 0)\n\t\tclk_div -= 1;\n\n\treturn clk_div;\n}\n\nstatic void spi_engine_gen_xfer(struct spi_engine_program *p, bool dry,\n\tstruct spi_transfer *xfer)\n{\n\tunsigned int len = xfer->len;\n\n\twhile (len) {\n\t\tunsigned int n = min(len, 256U);\n\t\tunsigned int flags = 0;\n\n\t\tif (xfer->tx_buf)\n\t\t\tflags |= SPI_ENGINE_TRANSFER_WRITE;\n\t\tif (xfer->rx_buf)\n\t\t\tflags |= SPI_ENGINE_TRANSFER_READ;\n\n\t\tspi_engine_program_add_cmd(p, dry,\n\t\t\tSPI_ENGINE_CMD_TRANSFER(flags, n - 1));\n\t\tlen -= n;\n\t}\n}\n\nstatic void spi_engine_gen_sleep(struct spi_engine_program *p, bool dry,\n\tstruct spi_engine *spi_engine, unsigned int clk_div,\n\tstruct spi_transfer *xfer)\n{\n\tunsigned int spi_clk = clk_get_rate(spi_engine->ref_clk);\n\tunsigned int t;\n\tint delay;\n\n\tdelay = spi_delay_to_ns(&xfer->delay, xfer);\n\tif (delay < 0)\n\t\treturn;\n\tdelay /= 1000;\n\n\tif (delay == 0)\n\t\treturn;\n\n\tt = DIV_ROUND_UP(delay * spi_clk, (clk_div + 1) * 2);\n\twhile (t) {\n\t\tunsigned int n = min(t, 256U);\n\n\t\tspi_engine_program_add_cmd(p, dry, SPI_ENGINE_CMD_SLEEP(n - 1));\n\t\tt -= n;\n\t}\n}\n\nstatic void spi_engine_gen_cs(struct spi_engine_program *p, bool dry,\n\t\tstruct spi_device *spi, bool assert)\n{\n\tunsigned int mask = 0xff;\n\n\tif (assert)\n\t\tmask ^= BIT(spi_get_chipselect(spi, 0));\n\n\tspi_engine_program_add_cmd(p, dry, SPI_ENGINE_CMD_ASSERT(1, mask));\n}\n\nstatic int spi_engine_compile_message(struct spi_engine *spi_engine,\n\tstruct spi_message *msg, bool dry, struct spi_engine_program *p)\n{\n\tstruct spi_device *spi = msg->spi;\n\tstruct spi_transfer *xfer;\n\tint clk_div, new_clk_div;\n\tbool cs_change = true;\n\n\tclk_div = -1;\n\n\tspi_engine_program_add_cmd(p, dry,\n\t\tSPI_ENGINE_CMD_WRITE(SPI_ENGINE_CMD_REG_CONFIG,\n\t\t\tspi_engine_get_config(spi)));\n\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tnew_clk_div = spi_engine_get_clk_div(spi_engine, spi, xfer);\n\t\tif (new_clk_div != clk_div) {\n\t\t\tclk_div = new_clk_div;\n\t\t\tspi_engine_program_add_cmd(p, dry,\n\t\t\t\tSPI_ENGINE_CMD_WRITE(SPI_ENGINE_CMD_REG_CLK_DIV,\n\t\t\t\t\tclk_div));\n\t\t}\n\n\t\tif (cs_change)\n\t\t\tspi_engine_gen_cs(p, dry, spi, true);\n\n\t\tspi_engine_gen_xfer(p, dry, xfer);\n\t\tspi_engine_gen_sleep(p, dry, spi_engine, clk_div, xfer);\n\n\t\tcs_change = xfer->cs_change;\n\t\tif (list_is_last(&xfer->transfer_list, &msg->transfers))\n\t\t\tcs_change = !cs_change;\n\n\t\tif (cs_change)\n\t\t\tspi_engine_gen_cs(p, dry, spi, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void spi_engine_xfer_next(struct spi_engine *spi_engine,\n\tstruct spi_transfer **_xfer)\n{\n\tstruct spi_message *msg = spi_engine->msg;\n\tstruct spi_transfer *xfer = *_xfer;\n\n\tif (!xfer) {\n\t\txfer = list_first_entry(&msg->transfers,\n\t\t\tstruct spi_transfer, transfer_list);\n\t} else if (list_is_last(&xfer->transfer_list, &msg->transfers)) {\n\t\txfer = NULL;\n\t} else {\n\t\txfer = list_next_entry(xfer, transfer_list);\n\t}\n\n\t*_xfer = xfer;\n}\n\nstatic void spi_engine_tx_next(struct spi_engine *spi_engine)\n{\n\tstruct spi_transfer *xfer = spi_engine->tx_xfer;\n\n\tdo {\n\t\tspi_engine_xfer_next(spi_engine, &xfer);\n\t} while (xfer && !xfer->tx_buf);\n\n\tspi_engine->tx_xfer = xfer;\n\tif (xfer) {\n\t\tspi_engine->tx_length = xfer->len;\n\t\tspi_engine->tx_buf = xfer->tx_buf;\n\t} else {\n\t\tspi_engine->tx_buf = NULL;\n\t}\n}\n\nstatic void spi_engine_rx_next(struct spi_engine *spi_engine)\n{\n\tstruct spi_transfer *xfer = spi_engine->rx_xfer;\n\n\tdo {\n\t\tspi_engine_xfer_next(spi_engine, &xfer);\n\t} while (xfer && !xfer->rx_buf);\n\n\tspi_engine->rx_xfer = xfer;\n\tif (xfer) {\n\t\tspi_engine->rx_length = xfer->len;\n\t\tspi_engine->rx_buf = xfer->rx_buf;\n\t} else {\n\t\tspi_engine->rx_buf = NULL;\n\t}\n}\n\nstatic bool spi_engine_write_cmd_fifo(struct spi_engine *spi_engine)\n{\n\tvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_CMD_FIFO;\n\tunsigned int n, m, i;\n\tconst uint16_t *buf;\n\n\tn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_CMD_FIFO_ROOM);\n\twhile (n && spi_engine->cmd_length) {\n\t\tm = min(n, spi_engine->cmd_length);\n\t\tbuf = spi_engine->cmd_buf;\n\t\tfor (i = 0; i < m; i++)\n\t\t\twritel_relaxed(buf[i], addr);\n\t\tspi_engine->cmd_buf += m;\n\t\tspi_engine->cmd_length -= m;\n\t\tn -= m;\n\t}\n\n\treturn spi_engine->cmd_length != 0;\n}\n\nstatic bool spi_engine_write_tx_fifo(struct spi_engine *spi_engine)\n{\n\tvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_SDO_DATA_FIFO;\n\tunsigned int n, m, i;\n\tconst uint8_t *buf;\n\n\tn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_SDO_FIFO_ROOM);\n\twhile (n && spi_engine->tx_length) {\n\t\tm = min(n, spi_engine->tx_length);\n\t\tbuf = spi_engine->tx_buf;\n\t\tfor (i = 0; i < m; i++)\n\t\t\twritel_relaxed(buf[i], addr);\n\t\tspi_engine->tx_buf += m;\n\t\tspi_engine->tx_length -= m;\n\t\tn -= m;\n\t\tif (spi_engine->tx_length == 0)\n\t\t\tspi_engine_tx_next(spi_engine);\n\t}\n\n\treturn spi_engine->tx_length != 0;\n}\n\nstatic bool spi_engine_read_rx_fifo(struct spi_engine *spi_engine)\n{\n\tvoid __iomem *addr = spi_engine->base + SPI_ENGINE_REG_SDI_DATA_FIFO;\n\tunsigned int n, m, i;\n\tuint8_t *buf;\n\n\tn = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_SDI_FIFO_LEVEL);\n\twhile (n && spi_engine->rx_length) {\n\t\tm = min(n, spi_engine->rx_length);\n\t\tbuf = spi_engine->rx_buf;\n\t\tfor (i = 0; i < m; i++)\n\t\t\tbuf[i] = readl_relaxed(addr);\n\t\tspi_engine->rx_buf += m;\n\t\tspi_engine->rx_length -= m;\n\t\tn -= m;\n\t\tif (spi_engine->rx_length == 0)\n\t\t\tspi_engine_rx_next(spi_engine);\n\t}\n\n\treturn spi_engine->rx_length != 0;\n}\n\nstatic irqreturn_t spi_engine_irq(int irq, void *devid)\n{\n\tstruct spi_controller *host = devid;\n\tstruct spi_engine *spi_engine = spi_controller_get_devdata(host);\n\tunsigned int disable_int = 0;\n\tunsigned int pending;\n\n\tpending = readl_relaxed(spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\n\n\tif (pending & SPI_ENGINE_INT_SYNC) {\n\t\twritel_relaxed(SPI_ENGINE_INT_SYNC,\n\t\t\tspi_engine->base + SPI_ENGINE_REG_INT_PENDING);\n\t\tspi_engine->completed_id = readl_relaxed(\n\t\t\tspi_engine->base + SPI_ENGINE_REG_SYNC_ID);\n\t}\n\n\tspin_lock(&spi_engine->lock);\n\n\tif (pending & SPI_ENGINE_INT_CMD_ALMOST_EMPTY) {\n\t\tif (!spi_engine_write_cmd_fifo(spi_engine))\n\t\t\tdisable_int |= SPI_ENGINE_INT_CMD_ALMOST_EMPTY;\n\t}\n\n\tif (pending & SPI_ENGINE_INT_SDO_ALMOST_EMPTY) {\n\t\tif (!spi_engine_write_tx_fifo(spi_engine))\n\t\t\tdisable_int |= SPI_ENGINE_INT_SDO_ALMOST_EMPTY;\n\t}\n\n\tif (pending & (SPI_ENGINE_INT_SDI_ALMOST_FULL | SPI_ENGINE_INT_SYNC)) {\n\t\tif (!spi_engine_read_rx_fifo(spi_engine))\n\t\t\tdisable_int |= SPI_ENGINE_INT_SDI_ALMOST_FULL;\n\t}\n\n\tif (pending & SPI_ENGINE_INT_SYNC) {\n\t\tif (spi_engine->msg &&\n\t\t    spi_engine->completed_id == spi_engine->sync_id) {\n\t\t\tstruct spi_message *msg = spi_engine->msg;\n\n\t\t\tkfree(spi_engine->p);\n\t\t\tmsg->status = 0;\n\t\t\tmsg->actual_length = msg->frame_length;\n\t\t\tspi_engine->msg = NULL;\n\t\t\tspi_finalize_current_message(host);\n\t\t\tdisable_int |= SPI_ENGINE_INT_SYNC;\n\t\t}\n\t}\n\n\tif (disable_int) {\n\t\tspi_engine->int_enable &= ~disable_int;\n\t\twritel_relaxed(spi_engine->int_enable,\n\t\t\tspi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\n\t}\n\n\tspin_unlock(&spi_engine->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spi_engine_transfer_one_message(struct spi_controller *host,\n\tstruct spi_message *msg)\n{\n\tstruct spi_engine_program p_dry, *p;\n\tstruct spi_engine *spi_engine = spi_controller_get_devdata(host);\n\tunsigned int int_enable = 0;\n\tunsigned long flags;\n\tsize_t size;\n\n\tp_dry.length = 0;\n\tspi_engine_compile_message(spi_engine, msg, true, &p_dry);\n\n\tsize = sizeof(*p->instructions) * (p_dry.length + 1);\n\tp = kzalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tspi_engine_compile_message(spi_engine, msg, false, p);\n\n\tspin_lock_irqsave(&spi_engine->lock, flags);\n\tspi_engine->sync_id = (spi_engine->sync_id + 1) & 0xff;\n\tspi_engine_program_add_cmd(p, false,\n\t\tSPI_ENGINE_CMD_SYNC(spi_engine->sync_id));\n\n\tspi_engine->msg = msg;\n\tspi_engine->p = p;\n\n\tspi_engine->cmd_buf = p->instructions;\n\tspi_engine->cmd_length = p->length;\n\tif (spi_engine_write_cmd_fifo(spi_engine))\n\t\tint_enable |= SPI_ENGINE_INT_CMD_ALMOST_EMPTY;\n\n\tspi_engine_tx_next(spi_engine);\n\tif (spi_engine_write_tx_fifo(spi_engine))\n\t\tint_enable |= SPI_ENGINE_INT_SDO_ALMOST_EMPTY;\n\n\tspi_engine_rx_next(spi_engine);\n\tif (spi_engine->rx_length != 0)\n\t\tint_enable |= SPI_ENGINE_INT_SDI_ALMOST_FULL;\n\n\tint_enable |= SPI_ENGINE_INT_SYNC;\n\n\twritel_relaxed(int_enable,\n\t\tspi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\n\tspi_engine->int_enable = int_enable;\n\tspin_unlock_irqrestore(&spi_engine->lock, flags);\n\n\treturn 0;\n}\n\nstatic int spi_engine_probe(struct platform_device *pdev)\n{\n\tstruct spi_engine *spi_engine;\n\tstruct spi_controller *host;\n\tunsigned int version;\n\tint irq;\n\tint ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tspi_engine = devm_kzalloc(&pdev->dev, sizeof(*spi_engine), GFP_KERNEL);\n\tif (!spi_engine)\n\t\treturn -ENOMEM;\n\n\thost = spi_alloc_host(&pdev->dev, 0);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tspi_controller_set_devdata(host, spi_engine);\n\n\tspin_lock_init(&spi_engine->lock);\n\n\tspi_engine->clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(spi_engine->clk)) {\n\t\tret = PTR_ERR(spi_engine->clk);\n\t\tgoto err_put_host;\n\t}\n\n\tspi_engine->ref_clk = devm_clk_get(&pdev->dev, \"spi_clk\");\n\tif (IS_ERR(spi_engine->ref_clk)) {\n\t\tret = PTR_ERR(spi_engine->ref_clk);\n\t\tgoto err_put_host;\n\t}\n\n\tret = clk_prepare_enable(spi_engine->clk);\n\tif (ret)\n\t\tgoto err_put_host;\n\n\tret = clk_prepare_enable(spi_engine->ref_clk);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tspi_engine->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spi_engine->base)) {\n\t\tret = PTR_ERR(spi_engine->base);\n\t\tgoto err_ref_clk_disable;\n\t}\n\n\tversion = readl(spi_engine->base + SPI_ENGINE_REG_VERSION);\n\tif (SPI_ENGINE_VERSION_MAJOR(version) != 1) {\n\t\tdev_err(&pdev->dev, \"Unsupported peripheral version %u.%u.%c\\n\",\n\t\t\tSPI_ENGINE_VERSION_MAJOR(version),\n\t\t\tSPI_ENGINE_VERSION_MINOR(version),\n\t\t\tSPI_ENGINE_VERSION_PATCH(version));\n\t\tret = -ENODEV;\n\t\tgoto err_ref_clk_disable;\n\t}\n\n\twritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_RESET);\n\twritel_relaxed(0xff, spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\n\twritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\n\n\tret = request_irq(irq, spi_engine_irq, 0, pdev->name, host);\n\tif (ret)\n\t\tgoto err_ref_clk_disable;\n\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_3WIRE;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->max_speed_hz = clk_get_rate(spi_engine->ref_clk) / 2;\n\thost->transfer_one_message = spi_engine_transfer_one_message;\n\thost->num_chipselect = 8;\n\n\tret = spi_register_controller(host);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tplatform_set_drvdata(pdev, host);\n\n\treturn 0;\nerr_free_irq:\n\tfree_irq(irq, host);\nerr_ref_clk_disable:\n\tclk_disable_unprepare(spi_engine->ref_clk);\nerr_clk_disable:\n\tclk_disable_unprepare(spi_engine->clk);\nerr_put_host:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic void spi_engine_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = spi_controller_get(platform_get_drvdata(pdev));\n\tstruct spi_engine *spi_engine = spi_controller_get_devdata(host);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tspi_unregister_controller(host);\n\n\tfree_irq(irq, host);\n\n\tspi_controller_put(host);\n\n\twritel_relaxed(0xff, spi_engine->base + SPI_ENGINE_REG_INT_PENDING);\n\twritel_relaxed(0x00, spi_engine->base + SPI_ENGINE_REG_INT_ENABLE);\n\twritel_relaxed(0x01, spi_engine->base + SPI_ENGINE_REG_RESET);\n\n\tclk_disable_unprepare(spi_engine->ref_clk);\n\tclk_disable_unprepare(spi_engine->clk);\n}\n\nstatic const struct of_device_id spi_engine_match_table[] = {\n\t{ .compatible = \"adi,axi-spi-engine-1.00.a\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, spi_engine_match_table);\n\nstatic struct platform_driver spi_engine_driver = {\n\t.probe = spi_engine_probe,\n\t.remove_new = spi_engine_remove,\n\t.driver = {\n\t\t.name = \"spi-engine\",\n\t\t.of_match_table = spi_engine_match_table,\n\t},\n};\nmodule_platform_driver(spi_engine_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices SPI engine peripheral driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}