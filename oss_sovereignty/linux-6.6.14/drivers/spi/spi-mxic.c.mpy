{
  "module_name": "spi-mxic.c",
  "hash_id": "3819151742a589f518782785877ea3daf60ef4909abdd1ccb695ae973e886d91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mxic.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-mxic.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#define HC_CFG\t\t\t0x0\n#define HC_CFG_IF_CFG(x)\t((x) << 27)\n#define HC_CFG_DUAL_SLAVE\tBIT(31)\n#define HC_CFG_INDIVIDUAL\tBIT(30)\n#define HC_CFG_NIO(x)\t\t(((x) / 4) << 27)\n#define HC_CFG_TYPE(s, t)\t((t) << (23 + ((s) * 2)))\n#define HC_CFG_TYPE_SPI_NOR\t0\n#define HC_CFG_TYPE_SPI_NAND\t1\n#define HC_CFG_TYPE_SPI_RAM\t2\n#define HC_CFG_TYPE_RAW_NAND\t3\n#define HC_CFG_SLV_ACT(x)\t((x) << 21)\n#define HC_CFG_CLK_PH_EN\tBIT(20)\n#define HC_CFG_CLK_POL_INV\tBIT(19)\n#define HC_CFG_BIG_ENDIAN\tBIT(18)\n#define HC_CFG_DATA_PASS\tBIT(17)\n#define HC_CFG_IDLE_SIO_LVL(x)\t((x) << 16)\n#define HC_CFG_MAN_START_EN\tBIT(3)\n#define HC_CFG_MAN_START\tBIT(2)\n#define HC_CFG_MAN_CS_EN\tBIT(1)\n#define HC_CFG_MAN_CS_ASSERT\tBIT(0)\n\n#define INT_STS\t\t\t0x4\n#define INT_STS_EN\t\t0x8\n#define INT_SIG_EN\t\t0xc\n#define INT_STS_ALL\t\tGENMASK(31, 0)\n#define INT_RDY_PIN\t\tBIT(26)\n#define INT_RDY_SR\t\tBIT(25)\n#define INT_LNR_SUSP\t\tBIT(24)\n#define INT_ECC_ERR\t\tBIT(17)\n#define INT_CRC_ERR\t\tBIT(16)\n#define INT_LWR_DIS\t\tBIT(12)\n#define INT_LRD_DIS\t\tBIT(11)\n#define INT_SDMA_INT\t\tBIT(10)\n#define INT_DMA_FINISH\t\tBIT(9)\n#define INT_RX_NOT_FULL\t\tBIT(3)\n#define INT_RX_NOT_EMPTY\tBIT(2)\n#define INT_TX_NOT_FULL\t\tBIT(1)\n#define INT_TX_EMPTY\t\tBIT(0)\n\n#define HC_EN\t\t\t0x10\n#define HC_EN_BIT\t\tBIT(0)\n\n#define TXD(x)\t\t\t(0x14 + ((x) * 4))\n#define RXD\t\t\t0x24\n\n#define SS_CTRL(s)\t\t(0x30 + ((s) * 4))\n#define LRD_CFG\t\t\t0x44\n#define LWR_CFG\t\t\t0x80\n#define RWW_CFG\t\t\t0x70\n#define OP_READ\t\t\tBIT(23)\n#define OP_DUMMY_CYC(x)\t\t((x) << 17)\n#define OP_ADDR_BYTES(x)\t((x) << 14)\n#define OP_CMD_BYTES(x)\t\t(((x) - 1) << 13)\n#define OP_OCTA_CRC_EN\t\tBIT(12)\n#define OP_DQS_EN\t\tBIT(11)\n#define OP_ENHC_EN\t\tBIT(10)\n#define OP_PREAMBLE_EN\t\tBIT(9)\n#define OP_DATA_DDR\t\tBIT(8)\n#define OP_DATA_BUSW(x)\t\t((x) << 6)\n#define OP_ADDR_DDR\t\tBIT(5)\n#define OP_ADDR_BUSW(x)\t\t((x) << 3)\n#define OP_CMD_DDR\t\tBIT(2)\n#define OP_CMD_BUSW(x)\t\t(x)\n#define OP_BUSW_1\t\t0\n#define OP_BUSW_2\t\t1\n#define OP_BUSW_4\t\t2\n#define OP_BUSW_8\t\t3\n\n#define OCTA_CRC\t\t0x38\n#define OCTA_CRC_IN_EN(s)\tBIT(3 + ((s) * 16))\n#define OCTA_CRC_CHUNK(s, x)\t((fls((x) / 32)) << (1 + ((s) * 16)))\n#define OCTA_CRC_OUT_EN(s)\tBIT(0 + ((s) * 16))\n\n#define ONFI_DIN_CNT(s)\t\t(0x3c + (s))\n\n#define LRD_CTRL\t\t0x48\n#define RWW_CTRL\t\t0x74\n#define LWR_CTRL\t\t0x84\n#define LMODE_EN\t\tBIT(31)\n#define LMODE_SLV_ACT(x)\t((x) << 21)\n#define LMODE_CMD1(x)\t\t((x) << 8)\n#define LMODE_CMD0(x)\t\t(x)\n\n#define LRD_ADDR\t\t0x4c\n#define LWR_ADDR\t\t0x88\n#define LRD_RANGE\t\t0x50\n#define LWR_RANGE\t\t0x8c\n\n#define AXI_SLV_ADDR\t\t0x54\n\n#define DMAC_RD_CFG\t\t0x58\n#define DMAC_WR_CFG\t\t0x94\n#define DMAC_CFG_PERIPH_EN\tBIT(31)\n#define DMAC_CFG_ALLFLUSH_EN\tBIT(30)\n#define DMAC_CFG_LASTFLUSH_EN\tBIT(29)\n#define DMAC_CFG_QE(x)\t\t(((x) + 1) << 16)\n#define DMAC_CFG_BURST_LEN(x)\t(((x) + 1) << 12)\n#define DMAC_CFG_BURST_SZ(x)\t((x) << 8)\n#define DMAC_CFG_DIR_READ\tBIT(1)\n#define DMAC_CFG_START\t\tBIT(0)\n\n#define DMAC_RD_CNT\t\t0x5c\n#define DMAC_WR_CNT\t\t0x98\n\n#define SDMA_ADDR\t\t0x60\n\n#define DMAM_CFG\t\t0x64\n#define DMAM_CFG_START\t\tBIT(31)\n#define DMAM_CFG_CONT\t\tBIT(30)\n#define DMAM_CFG_SDMA_GAP(x)\t(fls((x) / 8192) << 2)\n#define DMAM_CFG_DIR_READ\tBIT(1)\n#define DMAM_CFG_EN\t\tBIT(0)\n\n#define DMAM_CNT\t\t0x68\n\n#define LNR_TIMER_TH\t\t0x6c\n\n#define RDM_CFG0\t\t0x78\n#define RDM_CFG0_POLY(x)\t(x)\n\n#define RDM_CFG1\t\t0x7c\n#define RDM_CFG1_RDM_EN\t\tBIT(31)\n#define RDM_CFG1_SEED(x)\t(x)\n\n#define LWR_SUSP_CTRL\t\t0x90\n#define LWR_SUSP_CTRL_EN\tBIT(31)\n\n#define DMAS_CTRL\t\t0x9c\n#define DMAS_CTRL_EN\t\tBIT(31)\n#define DMAS_CTRL_DIR_READ\tBIT(30)\n\n#define DATA_STROB\t\t0xa0\n#define DATA_STROB_EDO_EN\tBIT(2)\n#define DATA_STROB_INV_POL\tBIT(1)\n#define DATA_STROB_DELAY_2CYC\tBIT(0)\n\n#define IDLY_CODE(x)\t\t(0xa4 + ((x) * 4))\n#define IDLY_CODE_VAL(x, v)\t((v) << (((x) % 4) * 8))\n\n#define GPIO\t\t\t0xc4\n#define GPIO_PT(x)\t\tBIT(3 + ((x) * 16))\n#define GPIO_RESET(x)\t\tBIT(2 + ((x) * 16))\n#define GPIO_HOLDB(x)\t\tBIT(1 + ((x) * 16))\n#define GPIO_WPB(x)\t\tBIT((x) * 16)\n\n#define HC_VER\t\t\t0xd0\n\n#define HW_TEST(x)\t\t(0xe0 + ((x) * 4))\n\nstruct mxic_spi {\n\tstruct device *dev;\n\tstruct clk *ps_clk;\n\tstruct clk *send_clk;\n\tstruct clk *send_dly_clk;\n\tvoid __iomem *regs;\n\tu32 cur_speed_hz;\n\tstruct {\n\t\tvoid __iomem *map;\n\t\tdma_addr_t dma;\n\t\tsize_t size;\n\t} linear;\n\n\tstruct {\n\t\tbool use_pipelined_conf;\n\t\tstruct nand_ecc_engine *pipelined_engine;\n\t\tvoid *ctx;\n\t} ecc;\n};\n\nstatic int mxic_spi_clk_enable(struct mxic_spi *mxic)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(mxic->send_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(mxic->send_dly_clk);\n\tif (ret)\n\t\tgoto err_send_dly_clk;\n\n\treturn ret;\n\nerr_send_dly_clk:\n\tclk_disable_unprepare(mxic->send_clk);\n\n\treturn ret;\n}\n\nstatic void mxic_spi_clk_disable(struct mxic_spi *mxic)\n{\n\tclk_disable_unprepare(mxic->send_clk);\n\tclk_disable_unprepare(mxic->send_dly_clk);\n}\n\nstatic void mxic_spi_set_input_delay_dqs(struct mxic_spi *mxic, u8 idly_code)\n{\n\twritel(IDLY_CODE_VAL(0, idly_code) |\n\t       IDLY_CODE_VAL(1, idly_code) |\n\t       IDLY_CODE_VAL(2, idly_code) |\n\t       IDLY_CODE_VAL(3, idly_code),\n\t       mxic->regs + IDLY_CODE(0));\n\twritel(IDLY_CODE_VAL(4, idly_code) |\n\t       IDLY_CODE_VAL(5, idly_code) |\n\t       IDLY_CODE_VAL(6, idly_code) |\n\t       IDLY_CODE_VAL(7, idly_code),\n\t       mxic->regs + IDLY_CODE(1));\n}\n\nstatic int mxic_spi_clk_setup(struct mxic_spi *mxic, unsigned long freq)\n{\n\tint ret;\n\n\tret = clk_set_rate(mxic->send_clk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(mxic->send_dly_clk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmxic_spi_set_input_delay_dqs(mxic, 0xf);\n\n\t \n\tret = clk_set_phase(mxic->send_dly_clk, 9 * freq / 25000000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mxic_spi_set_freq(struct mxic_spi *mxic, unsigned long freq)\n{\n\tint ret;\n\n\tif (mxic->cur_speed_hz == freq)\n\t\treturn 0;\n\n\tmxic_spi_clk_disable(mxic);\n\tret = mxic_spi_clk_setup(mxic, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mxic_spi_clk_enable(mxic);\n\tif (ret)\n\t\treturn ret;\n\n\tmxic->cur_speed_hz = freq;\n\n\treturn 0;\n}\n\nstatic void mxic_spi_hw_init(struct mxic_spi *mxic)\n{\n\twritel(0, mxic->regs + DATA_STROB);\n\twritel(INT_STS_ALL, mxic->regs + INT_STS_EN);\n\twritel(0, mxic->regs + HC_EN);\n\twritel(0, mxic->regs + LRD_CFG);\n\twritel(0, mxic->regs + LRD_CTRL);\n\twritel(HC_CFG_NIO(1) | HC_CFG_TYPE(0, HC_CFG_TYPE_SPI_NOR) |\n\t       HC_CFG_SLV_ACT(0) | HC_CFG_MAN_CS_EN | HC_CFG_IDLE_SIO_LVL(1),\n\t       mxic->regs + HC_CFG);\n}\n\nstatic u32 mxic_spi_prep_hc_cfg(struct spi_device *spi, u32 flags)\n{\n\tint nio = 1;\n\n\tif (spi->mode & (SPI_TX_OCTAL | SPI_RX_OCTAL))\n\t\tnio = 8;\n\telse if (spi->mode & (SPI_TX_QUAD | SPI_RX_QUAD))\n\t\tnio = 4;\n\telse if (spi->mode & (SPI_TX_DUAL | SPI_RX_DUAL))\n\t\tnio = 2;\n\n\treturn flags | HC_CFG_NIO(nio) |\n\t       HC_CFG_TYPE(spi_get_chipselect(spi, 0), HC_CFG_TYPE_SPI_NOR) |\n\t       HC_CFG_SLV_ACT(spi_get_chipselect(spi, 0)) | HC_CFG_IDLE_SIO_LVL(1);\n}\n\nstatic u32 mxic_spi_mem_prep_op_cfg(const struct spi_mem_op *op,\n\t\t\t\t    unsigned int data_len)\n{\n\tu32 cfg = OP_CMD_BYTES(op->cmd.nbytes) |\n\t\t  OP_CMD_BUSW(fls(op->cmd.buswidth) - 1) |\n\t\t  (op->cmd.dtr ? OP_CMD_DDR : 0);\n\n\tif (op->addr.nbytes)\n\t\tcfg |= OP_ADDR_BYTES(op->addr.nbytes) |\n\t\t       OP_ADDR_BUSW(fls(op->addr.buswidth) - 1) |\n\t\t       (op->addr.dtr ? OP_ADDR_DDR : 0);\n\n\tif (op->dummy.nbytes)\n\t\tcfg |= OP_DUMMY_CYC(op->dummy.nbytes);\n\n\t \n\tif (data_len) {\n\t\tcfg |= OP_DATA_BUSW(fls(op->data.buswidth) - 1) |\n\t\t       (op->data.dtr ? OP_DATA_DDR : 0);\n\t\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\t\tcfg |= OP_READ;\n\t\t\tif (op->data.dtr)\n\t\t\t\tcfg |= OP_DQS_EN;\n\t\t}\n\t}\n\n\treturn cfg;\n}\n\nstatic int mxic_spi_data_xfer(struct mxic_spi *mxic, const void *txbuf,\n\t\t\t      void *rxbuf, unsigned int len)\n{\n\tunsigned int pos = 0;\n\n\twhile (pos < len) {\n\t\tunsigned int nbytes = len - pos;\n\t\tu32 data = 0xffffffff;\n\t\tu32 sts;\n\t\tint ret;\n\n\t\tif (nbytes > 4)\n\t\t\tnbytes = 4;\n\n\t\tif (txbuf)\n\t\t\tmemcpy(&data, txbuf + pos, nbytes);\n\n\t\tret = readl_poll_timeout(mxic->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_TX_EMPTY, 0, USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritel(data, mxic->regs + TXD(nbytes % 4));\n\n\t\tret = readl_poll_timeout(mxic->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_TX_EMPTY, 0, USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = readl_poll_timeout(mxic->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_RX_NOT_EMPTY, 0,\n\t\t\t\t\t USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = readl(mxic->regs + RXD);\n\t\tif (rxbuf) {\n\t\t\tdata >>= (8 * (4 - nbytes));\n\t\t\tmemcpy(rxbuf + pos, &data, nbytes);\n\t\t}\n\t\tWARN_ON(readl(mxic->regs + INT_STS) & INT_RX_NOT_EMPTY);\n\n\t\tpos += nbytes;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t mxic_spi_mem_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t\tu64 offs, size_t len, void *buf)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(desc->mem->spi->master);\n\tint ret;\n\tu32 sts;\n\n\tif (WARN_ON(offs + desc->info.offset + len > U32_MAX))\n\t\treturn -EINVAL;\n\n\twritel(mxic_spi_prep_hc_cfg(desc->mem->spi, 0), mxic->regs + HC_CFG);\n\n\twritel(mxic_spi_mem_prep_op_cfg(&desc->info.op_tmpl, len),\n\t       mxic->regs + LRD_CFG);\n\twritel(desc->info.offset + offs, mxic->regs + LRD_ADDR);\n\tlen = min_t(size_t, len, mxic->linear.size);\n\twritel(len, mxic->regs + LRD_RANGE);\n\twritel(LMODE_CMD0(desc->info.op_tmpl.cmd.opcode) |\n\t       LMODE_SLV_ACT(spi_get_chipselect(desc->mem->spi, 0)) |\n\t       LMODE_EN,\n\t       mxic->regs + LRD_CTRL);\n\n\tif (mxic->ecc.use_pipelined_conf && desc->info.op_tmpl.data.ecc) {\n\t\tret = mxic_ecc_process_data_pipelined(mxic->ecc.pipelined_engine,\n\t\t\t\t\t\t      NAND_PAGE_READ,\n\t\t\t\t\t\t      mxic->linear.dma + offs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tmemcpy_fromio(buf, mxic->linear.map, len);\n\t}\n\n\twritel(INT_LRD_DIS, mxic->regs + INT_STS);\n\twritel(0, mxic->regs + LRD_CTRL);\n\n\tret = readl_poll_timeout(mxic->regs + INT_STS, sts,\n\t\t\t\t sts & INT_LRD_DIS, 0, USEC_PER_SEC);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t mxic_spi_mem_dirmap_write(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t\t u64 offs, size_t len,\n\t\t\t\t\t const void *buf)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(desc->mem->spi->master);\n\tu32 sts;\n\tint ret;\n\n\tif (WARN_ON(offs + desc->info.offset + len > U32_MAX))\n\t\treturn -EINVAL;\n\n\twritel(mxic_spi_prep_hc_cfg(desc->mem->spi, 0), mxic->regs + HC_CFG);\n\n\twritel(mxic_spi_mem_prep_op_cfg(&desc->info.op_tmpl, len),\n\t       mxic->regs + LWR_CFG);\n\twritel(desc->info.offset + offs, mxic->regs + LWR_ADDR);\n\tlen = min_t(size_t, len, mxic->linear.size);\n\twritel(len, mxic->regs + LWR_RANGE);\n\twritel(LMODE_CMD0(desc->info.op_tmpl.cmd.opcode) |\n\t       LMODE_SLV_ACT(spi_get_chipselect(desc->mem->spi, 0)) |\n\t       LMODE_EN,\n\t       mxic->regs + LWR_CTRL);\n\n\tif (mxic->ecc.use_pipelined_conf && desc->info.op_tmpl.data.ecc) {\n\t\tret = mxic_ecc_process_data_pipelined(mxic->ecc.pipelined_engine,\n\t\t\t\t\t\t      NAND_PAGE_WRITE,\n\t\t\t\t\t\t      mxic->linear.dma + offs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tmemcpy_toio(mxic->linear.map, buf, len);\n\t}\n\n\twritel(INT_LWR_DIS, mxic->regs + INT_STS);\n\twritel(0, mxic->regs + LWR_CTRL);\n\n\tret = readl_poll_timeout(mxic->regs + INT_STS, sts,\n\t\t\t\t sts & INT_LWR_DIS, 0, USEC_PER_SEC);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic bool mxic_spi_mem_supports_op(struct spi_mem *mem,\n\t\t\t\t     const struct spi_mem_op *op)\n{\n\tif (op->data.buswidth > 8 || op->addr.buswidth > 8 ||\n\t    op->dummy.buswidth > 8 || op->cmd.buswidth > 8)\n\t\treturn false;\n\n\tif (op->data.nbytes && op->dummy.nbytes &&\n\t    op->data.buswidth != op->dummy.buswidth)\n\t\treturn false;\n\n\tif (op->addr.nbytes > 7)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic int mxic_spi_mem_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(desc->mem->spi->master);\n\n\tif (!mxic->linear.map)\n\t\treturn -EINVAL;\n\n\tif (desc->info.offset + desc->info.length > U32_MAX)\n\t\treturn -EINVAL;\n\n\tif (!mxic_spi_mem_supports_op(desc->mem, &desc->info.op_tmpl))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int mxic_spi_mem_exec_op(struct spi_mem *mem,\n\t\t\t\tconst struct spi_mem_op *op)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(mem->spi->master);\n\tint i, ret;\n\tu8 addr[8], cmd[2];\n\n\tret = mxic_spi_set_freq(mxic, mem->spi->max_speed_hz);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(mxic_spi_prep_hc_cfg(mem->spi, HC_CFG_MAN_CS_EN),\n\t       mxic->regs + HC_CFG);\n\n\twritel(HC_EN_BIT, mxic->regs + HC_EN);\n\n\twritel(mxic_spi_mem_prep_op_cfg(op, op->data.nbytes),\n\t       mxic->regs + SS_CTRL(spi_get_chipselect(mem->spi, 0)));\n\n\twritel(readl(mxic->regs + HC_CFG) | HC_CFG_MAN_CS_ASSERT,\n\t       mxic->regs + HC_CFG);\n\n\tfor (i = 0; i < op->cmd.nbytes; i++)\n\t\tcmd[i] = op->cmd.opcode >> (8 * (op->cmd.nbytes - i - 1));\n\n\tret = mxic_spi_data_xfer(mxic, cmd, NULL, op->cmd.nbytes);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < op->addr.nbytes; i++)\n\t\taddr[i] = op->addr.val >> (8 * (op->addr.nbytes - i - 1));\n\n\tret = mxic_spi_data_xfer(mxic, addr, NULL, op->addr.nbytes);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mxic_spi_data_xfer(mxic, NULL, NULL, op->dummy.nbytes);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mxic_spi_data_xfer(mxic,\n\t\t\t\t op->data.dir == SPI_MEM_DATA_OUT ?\n\t\t\t\t op->data.buf.out : NULL,\n\t\t\t\t op->data.dir == SPI_MEM_DATA_IN ?\n\t\t\t\t op->data.buf.in : NULL,\n\t\t\t\t op->data.nbytes);\n\nout:\n\twritel(readl(mxic->regs + HC_CFG) & ~HC_CFG_MAN_CS_ASSERT,\n\t       mxic->regs + HC_CFG);\n\twritel(0, mxic->regs + HC_EN);\n\n\treturn ret;\n}\n\nstatic const struct spi_controller_mem_ops mxic_spi_mem_ops = {\n\t.supports_op = mxic_spi_mem_supports_op,\n\t.exec_op = mxic_spi_mem_exec_op,\n\t.dirmap_create = mxic_spi_mem_dirmap_create,\n\t.dirmap_read = mxic_spi_mem_dirmap_read,\n\t.dirmap_write = mxic_spi_mem_dirmap_write,\n};\n\nstatic const struct spi_controller_mem_caps mxic_spi_mem_caps = {\n\t.dtr = true,\n\t.ecc = true,\n};\n\nstatic void mxic_spi_set_cs(struct spi_device *spi, bool lvl)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(spi->master);\n\n\tif (!lvl) {\n\t\twritel(readl(mxic->regs + HC_CFG) | HC_CFG_MAN_CS_EN,\n\t\t       mxic->regs + HC_CFG);\n\t\twritel(HC_EN_BIT, mxic->regs + HC_EN);\n\t\twritel(readl(mxic->regs + HC_CFG) | HC_CFG_MAN_CS_ASSERT,\n\t\t       mxic->regs + HC_CFG);\n\t} else {\n\t\twritel(readl(mxic->regs + HC_CFG) & ~HC_CFG_MAN_CS_ASSERT,\n\t\t       mxic->regs + HC_CFG);\n\t\twritel(0, mxic->regs + HC_EN);\n\t}\n}\n\nstatic int mxic_spi_transfer_one(struct spi_master *master,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *t)\n{\n\tstruct mxic_spi *mxic = spi_master_get_devdata(master);\n\tunsigned int busw = OP_BUSW_1;\n\tint ret;\n\n\tif (t->rx_buf && t->tx_buf) {\n\t\tif (((spi->mode & SPI_TX_QUAD) &&\n\t\t     !(spi->mode & SPI_RX_QUAD)) ||\n\t\t    ((spi->mode & SPI_TX_DUAL) &&\n\t\t     !(spi->mode & SPI_RX_DUAL)))\n\t\t\treturn -ENOTSUPP;\n\t}\n\n\tret = mxic_spi_set_freq(mxic, t->speed_hz);\n\tif (ret)\n\t\treturn ret;\n\n\tif (t->tx_buf) {\n\t\tif (spi->mode & SPI_TX_QUAD)\n\t\t\tbusw = OP_BUSW_4;\n\t\telse if (spi->mode & SPI_TX_DUAL)\n\t\t\tbusw = OP_BUSW_2;\n\t} else if (t->rx_buf) {\n\t\tif (spi->mode & SPI_RX_QUAD)\n\t\t\tbusw = OP_BUSW_4;\n\t\telse if (spi->mode & SPI_RX_DUAL)\n\t\t\tbusw = OP_BUSW_2;\n\t}\n\n\twritel(OP_CMD_BYTES(1) | OP_CMD_BUSW(busw) |\n\t       OP_DATA_BUSW(busw) | (t->rx_buf ? OP_READ : 0),\n\t       mxic->regs + SS_CTRL(0));\n\n\tret = mxic_spi_data_xfer(mxic, t->tx_buf, t->rx_buf, t->len);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_finalize_current_transfer(master);\n\n\treturn 0;\n}\n\n \nstatic int mxic_spi_mem_ecc_init_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_engine_ops *ops = mxic_ecc_get_pipelined_ops();\n\tstruct mxic_spi *mxic = nand->ecc.engine->priv;\n\n\tmxic->ecc.use_pipelined_conf = true;\n\n\treturn ops->init_ctx(nand);\n}\n\nstatic void mxic_spi_mem_ecc_cleanup_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_engine_ops *ops = mxic_ecc_get_pipelined_ops();\n\tstruct mxic_spi *mxic = nand->ecc.engine->priv;\n\n\tmxic->ecc.use_pipelined_conf = false;\n\n\tops->cleanup_ctx(nand);\n}\n\nstatic int mxic_spi_mem_ecc_prepare_io_req(struct nand_device *nand,\n\t\t\t\t\t   struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_engine_ops *ops = mxic_ecc_get_pipelined_ops();\n\n\treturn ops->prepare_io_req(nand, req);\n}\n\nstatic int mxic_spi_mem_ecc_finish_io_req(struct nand_device *nand,\n\t\t\t\t\t  struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_engine_ops *ops = mxic_ecc_get_pipelined_ops();\n\n\treturn ops->finish_io_req(nand, req);\n}\n\nstatic struct nand_ecc_engine_ops mxic_spi_mem_ecc_engine_pipelined_ops = {\n\t.init_ctx = mxic_spi_mem_ecc_init_ctx,\n\t.cleanup_ctx = mxic_spi_mem_ecc_cleanup_ctx,\n\t.prepare_io_req = mxic_spi_mem_ecc_prepare_io_req,\n\t.finish_io_req = mxic_spi_mem_ecc_finish_io_req,\n};\n\nstatic void mxic_spi_mem_ecc_remove(struct mxic_spi *mxic)\n{\n\tif (mxic->ecc.pipelined_engine) {\n\t\tmxic_ecc_put_pipelined_engine(mxic->ecc.pipelined_engine);\n\t\tnand_ecc_unregister_on_host_hw_engine(mxic->ecc.pipelined_engine);\n\t}\n}\n\nstatic int mxic_spi_mem_ecc_probe(struct platform_device *pdev,\n\t\t\t\t  struct mxic_spi *mxic)\n{\n\tstruct nand_ecc_engine *eng;\n\n\tif (!mxic_ecc_get_pipelined_ops())\n\t\treturn -EOPNOTSUPP;\n\n\teng = mxic_ecc_get_pipelined_engine(pdev);\n\tif (IS_ERR(eng))\n\t\treturn PTR_ERR(eng);\n\n\teng->dev = &pdev->dev;\n\teng->integration = NAND_ECC_ENGINE_INTEGRATION_PIPELINED;\n\teng->ops = &mxic_spi_mem_ecc_engine_pipelined_ops;\n\teng->priv = mxic;\n\tmxic->ecc.pipelined_engine = eng;\n\tnand_ecc_register_on_host_hw_engine(eng);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mxic_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct mxic_spi *mxic = spi_master_get_devdata(master);\n\n\tmxic_spi_clk_disable(mxic);\n\tclk_disable_unprepare(mxic->ps_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mxic_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct mxic_spi *mxic = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(mxic->ps_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable ps_clock.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn mxic_spi_clk_enable(mxic);\n}\n\nstatic const struct dev_pm_ops mxic_spi_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mxic_spi_runtime_suspend,\n\t\t\t   mxic_spi_runtime_resume, NULL)\n};\n\nstatic int mxic_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct resource *res;\n\tstruct mxic_spi *mxic;\n\tint ret;\n\n\tmaster = devm_spi_alloc_master(&pdev->dev, sizeof(struct mxic_spi));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tmxic = spi_master_get_devdata(master);\n\tmxic->dev = &pdev->dev;\n\n\tmaster->dev.of_node = pdev->dev.of_node;\n\n\tmxic->ps_clk = devm_clk_get(&pdev->dev, \"ps_clk\");\n\tif (IS_ERR(mxic->ps_clk))\n\t\treturn PTR_ERR(mxic->ps_clk);\n\n\tmxic->send_clk = devm_clk_get(&pdev->dev, \"send_clk\");\n\tif (IS_ERR(mxic->send_clk))\n\t\treturn PTR_ERR(mxic->send_clk);\n\n\tmxic->send_dly_clk = devm_clk_get(&pdev->dev, \"send_dly_clk\");\n\tif (IS_ERR(mxic->send_dly_clk))\n\t\treturn PTR_ERR(mxic->send_dly_clk);\n\n\tmxic->regs = devm_platform_ioremap_resource_byname(pdev, \"regs\");\n\tif (IS_ERR(mxic->regs))\n\t\treturn PTR_ERR(mxic->regs);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dirmap\");\n\tmxic->linear.map = devm_ioremap_resource(&pdev->dev, res);\n\tif (!IS_ERR(mxic->linear.map)) {\n\t\tmxic->linear.dma = res->start;\n\t\tmxic->linear.size = resource_size(res);\n\t} else {\n\t\tmxic->linear.map = NULL;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tmaster->auto_runtime_pm = true;\n\n\tmaster->num_chipselect = 1;\n\tmaster->mem_ops = &mxic_spi_mem_ops;\n\tmaster->mem_caps = &mxic_spi_mem_caps;\n\n\tmaster->set_cs = mxic_spi_set_cs;\n\tmaster->transfer_one = mxic_spi_transfer_one;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA |\n\t\t\tSPI_RX_DUAL | SPI_TX_DUAL |\n\t\t\tSPI_RX_QUAD | SPI_TX_QUAD |\n\t\t\tSPI_RX_OCTAL | SPI_TX_OCTAL;\n\n\tmxic_spi_hw_init(mxic);\n\n\tret = mxic_spi_mem_ecc_probe(pdev, mxic);\n\tif (ret == -EPROBE_DEFER) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tret = spi_register_master(master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_register_master failed\\n\");\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tmxic_spi_mem_ecc_remove(mxic);\n\t}\n\n\treturn ret;\n}\n\nstatic void mxic_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct mxic_spi *mxic = spi_master_get_devdata(master);\n\n\tpm_runtime_disable(&pdev->dev);\n\tmxic_spi_mem_ecc_remove(mxic);\n\tspi_unregister_master(master);\n}\n\nstatic const struct of_device_id mxic_spi_of_ids[] = {\n\t{ .compatible = \"mxicy,mx25f0a-spi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxic_spi_of_ids);\n\nstatic struct platform_driver mxic_spi_driver = {\n\t.probe = mxic_spi_probe,\n\t.remove_new = mxic_spi_remove,\n\t.driver = {\n\t\t.name = \"mxic-spi\",\n\t\t.of_match_table = mxic_spi_of_ids,\n\t\t.pm = &mxic_spi_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(mxic_spi_driver);\n\nMODULE_AUTHOR(\"Mason Yang <masonccyang@mxic.com.tw>\");\nMODULE_DESCRIPTION(\"MX25F0A SPI controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}