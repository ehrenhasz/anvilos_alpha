{
  "module_name": "spi-coldfire-qspi.c",
  "hash_id": "f825735fe52fb8359ab1197957c2b68ba43216836cc22f18b4b98a52e9052005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-coldfire-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/spi/spi.h>\n#include <linux/pm_runtime.h>\n\n#include <asm/coldfire.h>\n#include <asm/mcfsim.h>\n#include <asm/mcfqspi.h>\n\n#define\tDRIVER_NAME \"mcfqspi\"\n\n#define\tMCFQSPI_BUSCLK\t\t\t(MCF_BUSCLK / 2)\n\n#define\tMCFQSPI_QMR\t\t\t0x00\n#define\t\tMCFQSPI_QMR_MSTR\t0x8000\n#define\t\tMCFQSPI_QMR_CPOL\t0x0200\n#define\t\tMCFQSPI_QMR_CPHA\t0x0100\n#define\tMCFQSPI_QDLYR\t\t\t0x04\n#define\t\tMCFQSPI_QDLYR_SPE\t0x8000\n#define\tMCFQSPI_QWR\t\t\t0x08\n#define\t\tMCFQSPI_QWR_HALT\t0x8000\n#define\t\tMCFQSPI_QWR_WREN\t0x4000\n#define\t\tMCFQSPI_QWR_CSIV\t0x1000\n#define\tMCFQSPI_QIR\t\t\t0x0C\n#define\t\tMCFQSPI_QIR_WCEFB\t0x8000\n#define\t\tMCFQSPI_QIR_ABRTB\t0x4000\n#define\t\tMCFQSPI_QIR_ABRTL\t0x1000\n#define\t\tMCFQSPI_QIR_WCEFE\t0x0800\n#define\t\tMCFQSPI_QIR_ABRTE\t0x0400\n#define\t\tMCFQSPI_QIR_SPIFE\t0x0100\n#define\t\tMCFQSPI_QIR_WCEF\t0x0008\n#define\t\tMCFQSPI_QIR_ABRT\t0x0004\n#define\t\tMCFQSPI_QIR_SPIF\t0x0001\n#define\tMCFQSPI_QAR\t\t\t0x010\n#define\t\tMCFQSPI_QAR_TXBUF\t0x00\n#define\t\tMCFQSPI_QAR_RXBUF\t0x10\n#define\t\tMCFQSPI_QAR_CMDBUF\t0x20\n#define\tMCFQSPI_QDR\t\t\t0x014\n#define\tMCFQSPI_QCR\t\t\t0x014\n#define\t\tMCFQSPI_QCR_CONT\t0x8000\n#define\t\tMCFQSPI_QCR_BITSE\t0x4000\n#define\t\tMCFQSPI_QCR_DT\t\t0x2000\n\nstruct mcfqspi {\n\tvoid __iomem *iobase;\n\tint irq;\n\tstruct clk *clk;\n\tstruct mcfqspi_cs_control *cs_control;\n\n\twait_queue_head_t waitq;\n};\n\nstatic void mcfqspi_wr_qmr(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QMR);\n}\n\nstatic void mcfqspi_wr_qdlyr(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QDLYR);\n}\n\nstatic u16 mcfqspi_rd_qdlyr(struct mcfqspi *mcfqspi)\n{\n\treturn readw(mcfqspi->iobase + MCFQSPI_QDLYR);\n}\n\nstatic void mcfqspi_wr_qwr(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QWR);\n}\n\nstatic void mcfqspi_wr_qir(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QIR);\n}\n\nstatic void mcfqspi_wr_qar(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QAR);\n}\n\nstatic void mcfqspi_wr_qdr(struct mcfqspi *mcfqspi, u16 val)\n{\n\twritew(val, mcfqspi->iobase + MCFQSPI_QDR);\n}\n\nstatic u16 mcfqspi_rd_qdr(struct mcfqspi *mcfqspi)\n{\n\treturn readw(mcfqspi->iobase + MCFQSPI_QDR);\n}\n\nstatic void mcfqspi_cs_select(struct mcfqspi *mcfqspi, u8 chip_select,\n\t\t\t    bool cs_high)\n{\n\tmcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);\n}\n\nstatic void mcfqspi_cs_deselect(struct mcfqspi *mcfqspi, u8 chip_select,\n\t\t\t\tbool cs_high)\n{\n\tmcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);\n}\n\nstatic int mcfqspi_cs_setup(struct mcfqspi *mcfqspi)\n{\n\treturn (mcfqspi->cs_control->setup) ?\n\t\tmcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;\n}\n\nstatic void mcfqspi_cs_teardown(struct mcfqspi *mcfqspi)\n{\n\tif (mcfqspi->cs_control->teardown)\n\t\tmcfqspi->cs_control->teardown(mcfqspi->cs_control);\n}\n\nstatic u8 mcfqspi_qmr_baud(u32 speed_hz)\n{\n\treturn clamp((MCFQSPI_BUSCLK + speed_hz - 1) / speed_hz, 2u, 255u);\n}\n\nstatic bool mcfqspi_qdlyr_spe(struct mcfqspi *mcfqspi)\n{\n\treturn mcfqspi_rd_qdlyr(mcfqspi) & MCFQSPI_QDLYR_SPE;\n}\n\nstatic irqreturn_t mcfqspi_irq_handler(int this_irq, void *dev_id)\n{\n\tstruct mcfqspi *mcfqspi = dev_id;\n\n\t \n\tmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE | MCFQSPI_QIR_SPIF);\n\twake_up(&mcfqspi->waitq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mcfqspi_transfer_msg8(struct mcfqspi *mcfqspi, unsigned count,\n\t\t\t\t  const u8 *txbuf, u8 *rxbuf)\n{\n\tunsigned i, n, offset = 0;\n\n\tn = min(count, 16u);\n\n\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\n\tfor (i = 0; i < n; ++i)\n\t\tmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\n\n\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\n\tif (txbuf)\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tmcfqspi_wr_qdr(mcfqspi, *txbuf++);\n\telse\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmcfqspi_wr_qdr(mcfqspi, 0);\n\n\tcount -= n;\n\tif (count) {\n\t\tu16 qwr = 0xf08;\n\t\tmcfqspi_wr_qwr(mcfqspi, 0x700);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\n\t\tdo {\n\t\t\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\t\t\tmcfqspi_wr_qwr(mcfqspi, qwr);\n\t\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t\t\tif (rxbuf) {\n\t\t\t\tmcfqspi_wr_qar(mcfqspi,\n\t\t\t\t\t       MCFQSPI_QAR_RXBUF + offset);\n\t\t\t\tfor (i = 0; i < 8; ++i)\n\t\t\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t\t\t}\n\t\t\tn = min(count, 8u);\n\t\t\tif (txbuf) {\n\t\t\t\tmcfqspi_wr_qar(mcfqspi,\n\t\t\t\t\t       MCFQSPI_QAR_TXBUF + offset);\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tmcfqspi_wr_qdr(mcfqspi, *txbuf++);\n\t\t\t}\n\t\t\tqwr = (offset ? 0x808 : 0) + ((n - 1) << 8);\n\t\t\toffset ^= 8;\n\t\t\tcount -= n;\n\t\t} while (count);\n\t\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\t\tmcfqspi_wr_qwr(mcfqspi, qwr);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t\tif (rxbuf) {\n\t\t\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\n\t\t\tfor (i = 0; i < 8; ++i)\n\t\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t\t\toffset ^= 8;\n\t\t}\n\t} else {\n\t\tmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t}\n\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\tif (rxbuf) {\n\t\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\n\t\tfor (i = 0; i < n; ++i)\n\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t}\n}\n\nstatic void mcfqspi_transfer_msg16(struct mcfqspi *mcfqspi, unsigned count,\n\t\t\t\t   const u16 *txbuf, u16 *rxbuf)\n{\n\tunsigned i, n, offset = 0;\n\n\tn = min(count, 16u);\n\n\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\n\tfor (i = 0; i < n; ++i)\n\t\tmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\n\n\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\n\tif (txbuf)\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tmcfqspi_wr_qdr(mcfqspi, *txbuf++);\n\telse\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmcfqspi_wr_qdr(mcfqspi, 0);\n\n\tcount -= n;\n\tif (count) {\n\t\tu16 qwr = 0xf08;\n\t\tmcfqspi_wr_qwr(mcfqspi, 0x700);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\n\t\tdo {\n\t\t\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\t\t\tmcfqspi_wr_qwr(mcfqspi, qwr);\n\t\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t\t\tif (rxbuf) {\n\t\t\t\tmcfqspi_wr_qar(mcfqspi,\n\t\t\t\t\t       MCFQSPI_QAR_RXBUF + offset);\n\t\t\t\tfor (i = 0; i < 8; ++i)\n\t\t\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t\t\t}\n\t\t\tn = min(count, 8u);\n\t\t\tif (txbuf) {\n\t\t\t\tmcfqspi_wr_qar(mcfqspi,\n\t\t\t\t\t       MCFQSPI_QAR_TXBUF + offset);\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tmcfqspi_wr_qdr(mcfqspi, *txbuf++);\n\t\t\t}\n\t\t\tqwr = (offset ? 0x808 : 0x000) + ((n - 1) << 8);\n\t\t\toffset ^= 8;\n\t\t\tcount -= n;\n\t\t} while (count);\n\t\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\t\tmcfqspi_wr_qwr(mcfqspi, qwr);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t\tif (rxbuf) {\n\t\t\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\n\t\t\tfor (i = 0; i < 8; ++i)\n\t\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t\t\toffset ^= 8;\n\t\t}\n\t} else {\n\t\tmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\n\t\tmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\n\t}\n\twait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\n\tif (rxbuf) {\n\t\tmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\n\t\tfor (i = 0; i < n; ++i)\n\t\t\t*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\n\t}\n}\n\nstatic void mcfqspi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(spi->controller);\n\tbool cs_high = spi->mode & SPI_CS_HIGH;\n\n\tif (enable)\n\t\tmcfqspi_cs_select(mcfqspi, spi_get_chipselect(spi, 0), cs_high);\n\telse\n\t\tmcfqspi_cs_deselect(mcfqspi, spi_get_chipselect(spi, 0), cs_high);\n}\n\nstatic int mcfqspi_transfer_one(struct spi_controller *host,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *t)\n{\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\tu16 qmr = MCFQSPI_QMR_MSTR;\n\n\tqmr |= t->bits_per_word << 10;\n\tif (spi->mode & SPI_CPHA)\n\t\tqmr |= MCFQSPI_QMR_CPHA;\n\tif (spi->mode & SPI_CPOL)\n\t\tqmr |= MCFQSPI_QMR_CPOL;\n\tqmr |= mcfqspi_qmr_baud(t->speed_hz);\n\tmcfqspi_wr_qmr(mcfqspi, qmr);\n\n\tmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE);\n\tif (t->bits_per_word == 8)\n\t\tmcfqspi_transfer_msg8(mcfqspi, t->len, t->tx_buf, t->rx_buf);\n\telse\n\t\tmcfqspi_transfer_msg16(mcfqspi, t->len / 2, t->tx_buf,\n\t\t\t\t       t->rx_buf);\n\tmcfqspi_wr_qir(mcfqspi, 0);\n\n\treturn 0;\n}\n\nstatic int mcfqspi_setup(struct spi_device *spi)\n{\n\tmcfqspi_cs_deselect(spi_controller_get_devdata(spi->controller),\n\t\t\t    spi_get_chipselect(spi, 0), spi->mode & SPI_CS_HIGH);\n\n\tdev_dbg(&spi->dev,\n\t\t\t\"bits per word %d, chip select %d, speed %d KHz\\n\",\n\t\t\tspi->bits_per_word, spi_get_chipselect(spi, 0),\n\t\t\t(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))\n\t\t\t/ 1000);\n\n\treturn 0;\n}\n\nstatic int mcfqspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct mcfqspi *mcfqspi;\n\tstruct mcfqspi_platform_data *pdata;\n\tint status;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_dbg(&pdev->dev, \"platform data is missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!pdata->cs_control) {\n\t\tdev_dbg(&pdev->dev, \"pdata->cs_control is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*mcfqspi));\n\tif (host == NULL) {\n\t\tdev_dbg(&pdev->dev, \"spi_alloc_host failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmcfqspi = spi_controller_get_devdata(host);\n\n\tmcfqspi->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mcfqspi->iobase)) {\n\t\tstatus = PTR_ERR(mcfqspi->iobase);\n\t\tgoto fail0;\n\t}\n\n\tmcfqspi->irq = platform_get_irq(pdev, 0);\n\tif (mcfqspi->irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"platform_get_irq failed\\n\");\n\t\tstatus = -ENXIO;\n\t\tgoto fail0;\n\t}\n\n\tstatus = devm_request_irq(&pdev->dev, mcfqspi->irq, mcfqspi_irq_handler,\n\t\t\t\t0, pdev->name, mcfqspi);\n\tif (status) {\n\t\tdev_dbg(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto fail0;\n\t}\n\n\tmcfqspi->clk = devm_clk_get_enabled(&pdev->dev, \"qspi_clk\");\n\tif (IS_ERR(mcfqspi->clk)) {\n\t\tdev_dbg(&pdev->dev, \"clk_get failed\\n\");\n\t\tstatus = PTR_ERR(mcfqspi->clk);\n\t\tgoto fail0;\n\t}\n\n\thost->bus_num = pdata->bus_num;\n\thost->num_chipselect = pdata->num_chipselect;\n\n\tmcfqspi->cs_control = pdata->cs_control;\n\tstatus = mcfqspi_cs_setup(mcfqspi);\n\tif (status) {\n\t\tdev_dbg(&pdev->dev, \"error initializing cs_control\\n\");\n\t\tgoto fail0;\n\t}\n\n\tinit_waitqueue_head(&mcfqspi->waitq);\n\n\thost->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);\n\thost->setup = mcfqspi_setup;\n\thost->set_cs = mcfqspi_set_cs;\n\thost->transfer_one = mcfqspi_transfer_one;\n\thost->auto_runtime_pm = true;\n\n\tplatform_set_drvdata(pdev, host);\n\tpm_runtime_enable(&pdev->dev);\n\n\tstatus = devm_spi_register_controller(&pdev->dev, host);\n\tif (status) {\n\t\tdev_dbg(&pdev->dev, \"devm_spi_register_controller failed\\n\");\n\t\tgoto fail1;\n\t}\n\n\tdev_info(&pdev->dev, \"Coldfire QSPI bus driver\\n\");\n\n\treturn 0;\n\nfail1:\n\tpm_runtime_disable(&pdev->dev);\n\tmcfqspi_cs_teardown(mcfqspi);\nfail0:\n\tspi_controller_put(host);\n\n\tdev_dbg(&pdev->dev, \"Coldfire QSPI probe failed\\n\");\n\n\treturn status;\n}\n\nstatic void mcfqspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\n\tpm_runtime_disable(&pdev->dev);\n\t \n\tmcfqspi_wr_qmr(mcfqspi, MCFQSPI_QMR_MSTR);\n\n\tmcfqspi_cs_teardown(mcfqspi);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mcfqspi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable(mcfqspi->clk);\n\n\treturn 0;\n}\n\nstatic int mcfqspi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\n\tclk_enable(mcfqspi->clk);\n\n\treturn spi_controller_resume(host);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int mcfqspi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\n\tclk_disable(mcfqspi->clk);\n\n\treturn 0;\n}\n\nstatic int mcfqspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct mcfqspi *mcfqspi = spi_controller_get_devdata(host);\n\n\tclk_enable(mcfqspi->clk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops mcfqspi_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mcfqspi_suspend, mcfqspi_resume)\n\tSET_RUNTIME_PM_OPS(mcfqspi_runtime_suspend, mcfqspi_runtime_resume,\n\t\t\tNULL)\n};\n\nstatic struct platform_driver mcfqspi_driver = {\n\t.driver.name\t= DRIVER_NAME,\n\t.driver.owner\t= THIS_MODULE,\n\t.driver.pm\t= &mcfqspi_pm,\n\t.probe\t\t= mcfqspi_probe,\n\t.remove_new\t= mcfqspi_remove,\n};\nmodule_platform_driver(mcfqspi_driver);\n\nMODULE_AUTHOR(\"Steven King <sfking@fdwdc.com>\");\nMODULE_DESCRIPTION(\"Coldfire QSPI Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}