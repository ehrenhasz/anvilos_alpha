{
  "module_name": "spi-mux.c",
  "hash_id": "3c520c5183d6d2bc763ee96699db8bb3e54dbaa732e793dc98c89df725db85b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mux.c",
  "human_readable_source": "\n\n\n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mux/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n#define SPI_MUX_NO_CS\t((unsigned int)-1)\n\n \n\n \nstruct spi_mux_priv {\n\tstruct spi_device\t*spi;\n\tunsigned int\t\tcurrent_cs;\n\n\tvoid\t\t\t(*child_msg_complete)(void *context);\n\tvoid\t\t\t*child_msg_context;\n\tstruct spi_device\t*child_msg_dev;\n\tstruct mux_control\t*mux;\n};\n\n \nstatic int spi_mux_select(struct spi_device *spi)\n{\n\tstruct spi_mux_priv *priv = spi_controller_get_devdata(spi->controller);\n\tint ret;\n\n\tret = mux_control_select(priv->mux, spi_get_chipselect(spi, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->current_cs == spi_get_chipselect(spi, 0))\n\t\treturn 0;\n\n\tdev_dbg(&priv->spi->dev, \"setting up the mux for cs %d\\n\",\n\t\tspi_get_chipselect(spi, 0));\n\n\t \n\tpriv->spi->max_speed_hz = spi->max_speed_hz;\n\tpriv->spi->mode = spi->mode;\n\tpriv->spi->bits_per_word = spi->bits_per_word;\n\n\tpriv->current_cs = spi_get_chipselect(spi, 0);\n\n\treturn 0;\n}\n\nstatic int spi_mux_setup(struct spi_device *spi)\n{\n\tstruct spi_mux_priv *priv = spi_controller_get_devdata(spi->controller);\n\n\t \n\treturn spi_setup(priv->spi);\n}\n\nstatic void spi_mux_complete_cb(void *context)\n{\n\tstruct spi_mux_priv *priv = (struct spi_mux_priv *)context;\n\tstruct spi_controller *ctlr = spi_get_drvdata(priv->spi);\n\tstruct spi_message *m = ctlr->cur_msg;\n\n\tm->complete = priv->child_msg_complete;\n\tm->context = priv->child_msg_context;\n\tm->spi = priv->child_msg_dev;\n\tspi_finalize_current_message(ctlr);\n\tmux_control_deselect(priv->mux);\n}\n\nstatic int spi_mux_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t\t\tstruct spi_message *m)\n{\n\tstruct spi_mux_priv *priv = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = m->spi;\n\tint ret;\n\n\tret = spi_mux_select(spi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->child_msg_complete = m->complete;\n\tpriv->child_msg_context = m->context;\n\tpriv->child_msg_dev = m->spi;\n\n\tm->complete = spi_mux_complete_cb;\n\tm->context = priv;\n\tm->spi = priv->spi;\n\n\t \n\treturn spi_async(priv->spi, m);\n}\n\nstatic int spi_mux_probe(struct spi_device *spi)\n{\n\tstruct spi_controller *ctlr;\n\tstruct spi_mux_priv *priv;\n\tint ret;\n\n\tctlr = spi_alloc_master(&spi->dev, sizeof(*priv));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, ctlr);\n\tpriv = spi_controller_get_devdata(ctlr);\n\tpriv->spi = spi;\n\n\t \n\tlockdep_set_subclass(&ctlr->io_mutex, 1);\n\tlockdep_set_subclass(&ctlr->add_lock, 1);\n\n\tpriv->mux = devm_mux_control_get(&spi->dev, NULL);\n\tif (IS_ERR(priv->mux)) {\n\t\tret = dev_err_probe(&spi->dev, PTR_ERR(priv->mux),\n\t\t\t\t    \"failed to get control-mux\\n\");\n\t\tgoto err_put_ctlr;\n\t}\n\n\tpriv->current_cs = SPI_MUX_NO_CS;\n\n\t \n\tctlr->mode_bits = spi->controller->mode_bits;\n\tctlr->flags = spi->controller->flags;\n\tctlr->transfer_one_message = spi_mux_transfer_one_message;\n\tctlr->setup = spi_mux_setup;\n\tctlr->num_chipselect = mux_control_states(priv->mux);\n\tctlr->bus_num = -1;\n\tctlr->dev.of_node = spi->dev.of_node;\n\tctlr->must_async = true;\n\n\tret = devm_spi_register_controller(&spi->dev, ctlr);\n\tif (ret)\n\t\tgoto err_put_ctlr;\n\n\treturn 0;\n\nerr_put_ctlr:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic const struct spi_device_id spi_mux_id[] = {\n\t{ \"spi-mux\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, spi_mux_id);\n\nstatic const struct of_device_id spi_mux_of_match[] = {\n\t{ .compatible = \"spi-mux\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, spi_mux_of_match);\n\nstatic struct spi_driver spi_mux_driver = {\n\t.probe  = spi_mux_probe,\n\t.driver = {\n\t\t.name   = \"spi-mux\",\n\t\t.of_match_table = spi_mux_of_match,\n\t},\n\t.id_table = spi_mux_id,\n};\n\nmodule_spi_driver(spi_mux_driver);\n\nMODULE_DESCRIPTION(\"SPI multiplexer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}