{
  "module_name": "spi-meson-spicc.c",
  "hash_id": "664aaa1e11d7f26e290c79f0a5e8b5696c626a7251004cfcd10366c8db098bee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-meson-spicc.c",
  "human_readable_source": " \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/reset.h>\n#include <linux/pinctrl/consumer.h>\n\n \n\n#define SPICC_MAX_BURST\t128\n\n \n#define SPICC_RXDATA\t0x00\n\n#define SPICC_TXDATA\t0x04\n\n#define SPICC_CONREG\t0x08\n#define SPICC_ENABLE\t\tBIT(0)\n#define SPICC_MODE_MASTER\tBIT(1)\n#define SPICC_XCH\t\tBIT(2)\n#define SPICC_SMC\t\tBIT(3)\n#define SPICC_POL\t\tBIT(4)\n#define SPICC_PHA\t\tBIT(5)\n#define SPICC_SSCTL\t\tBIT(6)\n#define SPICC_SSPOL\t\tBIT(7)\n#define SPICC_DRCTL_MASK\tGENMASK(9, 8)\n#define SPICC_DRCTL_IGNORE\t0\n#define SPICC_DRCTL_FALLING\t1\n#define SPICC_DRCTL_LOWLEVEL\t2\n#define SPICC_CS_MASK\t\tGENMASK(13, 12)\n#define SPICC_DATARATE_MASK\tGENMASK(18, 16)\n#define SPICC_DATARATE_DIV4\t0\n#define SPICC_DATARATE_DIV8\t1\n#define SPICC_DATARATE_DIV16\t2\n#define SPICC_DATARATE_DIV32\t3\n#define SPICC_BITLENGTH_MASK\tGENMASK(24, 19)\n#define SPICC_BURSTLENGTH_MASK\tGENMASK(31, 25)\n\n#define SPICC_INTREG\t0x0c\n#define SPICC_TE_EN\tBIT(0)  \n#define SPICC_TH_EN\tBIT(1)  \n#define SPICC_TF_EN\tBIT(2)  \n#define SPICC_RR_EN\tBIT(3)  \n#define SPICC_RH_EN\tBIT(4)  \n#define SPICC_RF_EN\tBIT(5)  \n#define SPICC_RO_EN\tBIT(6)  \n#define SPICC_TC_EN\tBIT(7)  \n\n#define SPICC_DMAREG\t0x10\n#define SPICC_DMA_ENABLE\t\tBIT(0)\n#define SPICC_TXFIFO_THRESHOLD_MASK\tGENMASK(5, 1)\n#define SPICC_RXFIFO_THRESHOLD_MASK\tGENMASK(10, 6)\n#define SPICC_READ_BURST_MASK\t\tGENMASK(14, 11)\n#define SPICC_WRITE_BURST_MASK\t\tGENMASK(18, 15)\n#define SPICC_DMA_URGENT\t\tBIT(19)\n#define SPICC_DMA_THREADID_MASK\t\tGENMASK(25, 20)\n#define SPICC_DMA_BURSTNUM_MASK\t\tGENMASK(31, 26)\n\n#define SPICC_STATREG\t0x14\n#define SPICC_TE\tBIT(0)  \n#define SPICC_TH\tBIT(1)  \n#define SPICC_TF\tBIT(2)  \n#define SPICC_RR\tBIT(3)  \n#define SPICC_RH\tBIT(4)  \n#define SPICC_RF\tBIT(5)  \n#define SPICC_RO\tBIT(6)  \n#define SPICC_TC\tBIT(7)  \n\n#define SPICC_PERIODREG\t0x18\n#define SPICC_PERIOD\tGENMASK(14, 0)\t \n\n#define SPICC_TESTREG\t0x1c\n#define SPICC_TXCNT_MASK\tGENMASK(4, 0)\t \n#define SPICC_RXCNT_MASK\tGENMASK(9, 5)\t \n#define SPICC_SMSTATUS_MASK\tGENMASK(12, 10)\t \n#define SPICC_LBC_RO\t\tBIT(13)\t \n#define SPICC_LBC_W1\t\tBIT(14)  \n#define SPICC_SWAP_RO\t\tBIT(14)  \n#define SPICC_SWAP_W1\t\tBIT(15)  \n#define SPICC_DLYCTL_RO_MASK\tGENMASK(20, 15)  \n#define SPICC_MO_DELAY_MASK\tGENMASK(17, 16)  \n#define SPICC_MO_NO_DELAY\t0\n#define SPICC_MO_DELAY_1_CYCLE\t1\n#define SPICC_MO_DELAY_2_CYCLE\t2\n#define SPICC_MO_DELAY_3_CYCLE\t3\n#define SPICC_MI_DELAY_MASK\tGENMASK(19, 18)  \n#define SPICC_MI_NO_DELAY\t0\n#define SPICC_MI_DELAY_1_CYCLE\t1\n#define SPICC_MI_DELAY_2_CYCLE\t2\n#define SPICC_MI_DELAY_3_CYCLE\t3\n#define SPICC_MI_CAP_DELAY_MASK\tGENMASK(21, 20)  \n#define SPICC_CAP_AHEAD_2_CYCLE\t0\n#define SPICC_CAP_AHEAD_1_CYCLE\t1\n#define SPICC_CAP_NO_DELAY\t2\n#define SPICC_CAP_DELAY_1_CYCLE\t3\n#define SPICC_FIFORST_RO_MASK\tGENMASK(22, 21)  \n#define SPICC_FIFORST_W1_MASK\tGENMASK(23, 22)  \n\n#define SPICC_DRADDR\t0x20\t \n\n#define SPICC_DWADDR\t0x24\t \n\n#define SPICC_ENH_CTL0\t0x38\t \n#define SPICC_ENH_CLK_CS_DELAY_MASK\tGENMASK(15, 0)\n#define SPICC_ENH_DATARATE_MASK\t\tGENMASK(23, 16)\n#define SPICC_ENH_DATARATE_EN\t\tBIT(24)\n#define SPICC_ENH_MOSI_OEN\t\tBIT(25)\n#define SPICC_ENH_CLK_OEN\t\tBIT(26)\n#define SPICC_ENH_CS_OEN\t\tBIT(27)\n#define SPICC_ENH_CLK_CS_DELAY_EN\tBIT(28)\n#define SPICC_ENH_MAIN_CLK_AO\t\tBIT(29)\n\n#define writel_bits_relaxed(mask, val, addr) \\\n\twritel_relaxed((readl_relaxed(addr) & ~(mask)) | (val), addr)\n\nstruct meson_spicc_data {\n\tunsigned int\t\t\tmax_speed_hz;\n\tunsigned int\t\t\tmin_speed_hz;\n\tunsigned int\t\t\tfifo_size;\n\tbool\t\t\t\thas_oen;\n\tbool\t\t\t\thas_enhance_clk_div;\n\tbool\t\t\t\thas_pclk;\n};\n\nstruct meson_spicc_device {\n\tstruct spi_master\t\t*master;\n\tstruct platform_device\t\t*pdev;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*core;\n\tstruct clk\t\t\t*pclk;\n\tstruct clk_divider\t\tpow2_div;\n\tstruct clk\t\t\t*clk;\n\tstruct spi_message\t\t*message;\n\tstruct spi_transfer\t\t*xfer;\n\tstruct completion\t\tdone;\n\tconst struct meson_spicc_data\t*data;\n\tu8\t\t\t\t*tx_buf;\n\tu8\t\t\t\t*rx_buf;\n\tunsigned int\t\t\tbytes_per_word;\n\tunsigned long\t\t\ttx_remain;\n\tunsigned long\t\t\trx_remain;\n\tunsigned long\t\t\txfer_remain;\n\tstruct pinctrl\t\t\t*pinctrl;\n\tstruct pinctrl_state\t\t*pins_idle_high;\n\tstruct pinctrl_state\t\t*pins_idle_low;\n};\n\n#define pow2_clk_to_spicc(_div) container_of(_div, struct meson_spicc_device, pow2_div)\n\nstatic void meson_spicc_oen_enable(struct meson_spicc_device *spicc)\n{\n\tu32 conf;\n\n\tif (!spicc->data->has_oen) {\n\t\t \n\t\tspicc->pins_idle_high = pinctrl_lookup_state(spicc->pinctrl,\n\t\t\t\t\t\t\t     \"idle-high\");\n\t\tif (IS_ERR(spicc->pins_idle_high)) {\n\t\t\tdev_warn(&spicc->pdev->dev, \"can't get idle-high pinctrl\\n\");\n\t\t\tspicc->pins_idle_high = NULL;\n\t\t}\n\t\tspicc->pins_idle_low = pinctrl_lookup_state(spicc->pinctrl,\n\t\t\t\t\t\t\t     \"idle-low\");\n\t\tif (IS_ERR(spicc->pins_idle_low)) {\n\t\t\tdev_warn(&spicc->pdev->dev, \"can't get idle-low pinctrl\\n\");\n\t\t\tspicc->pins_idle_low = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tconf = readl_relaxed(spicc->base + SPICC_ENH_CTL0) |\n\t\tSPICC_ENH_MOSI_OEN | SPICC_ENH_CLK_OEN | SPICC_ENH_CS_OEN;\n\n\twritel_relaxed(conf, spicc->base + SPICC_ENH_CTL0);\n}\n\nstatic inline bool meson_spicc_txfull(struct meson_spicc_device *spicc)\n{\n\treturn !!FIELD_GET(SPICC_TF,\n\t\t\t   readl_relaxed(spicc->base + SPICC_STATREG));\n}\n\nstatic inline bool meson_spicc_rxready(struct meson_spicc_device *spicc)\n{\n\treturn FIELD_GET(SPICC_RH | SPICC_RR | SPICC_RF,\n\t\t\t readl_relaxed(spicc->base + SPICC_STATREG));\n}\n\nstatic inline u32 meson_spicc_pull_data(struct meson_spicc_device *spicc)\n{\n\tunsigned int bytes = spicc->bytes_per_word;\n\tunsigned int byte_shift = 0;\n\tu32 data = 0;\n\tu8 byte;\n\n\twhile (bytes--) {\n\t\tbyte = *spicc->tx_buf++;\n\t\tdata |= (byte & 0xff) << byte_shift;\n\t\tbyte_shift += 8;\n\t}\n\n\tspicc->tx_remain--;\n\treturn data;\n}\n\nstatic inline void meson_spicc_push_data(struct meson_spicc_device *spicc,\n\t\t\t\t\t u32 data)\n{\n\tunsigned int bytes = spicc->bytes_per_word;\n\tunsigned int byte_shift = 0;\n\tu8 byte;\n\n\twhile (bytes--) {\n\t\tbyte = (data >> byte_shift) & 0xff;\n\t\t*spicc->rx_buf++ = byte;\n\t\tbyte_shift += 8;\n\t}\n\n\tspicc->rx_remain--;\n}\n\nstatic inline void meson_spicc_rx(struct meson_spicc_device *spicc)\n{\n\t \n\twhile (spicc->rx_remain &&\n\t       meson_spicc_rxready(spicc))\n\t\tmeson_spicc_push_data(spicc,\n\t\t\t\treadl_relaxed(spicc->base + SPICC_RXDATA));\n}\n\nstatic inline void meson_spicc_tx(struct meson_spicc_device *spicc)\n{\n\t \n\twhile (spicc->tx_remain &&\n\t       !meson_spicc_txfull(spicc))\n\t\twritel_relaxed(meson_spicc_pull_data(spicc),\n\t\t\t       spicc->base + SPICC_TXDATA);\n}\n\nstatic inline void meson_spicc_setup_burst(struct meson_spicc_device *spicc)\n{\n\n\tunsigned int burst_len = min_t(unsigned int,\n\t\t\t\t       spicc->xfer_remain /\n\t\t\t\t       spicc->bytes_per_word,\n\t\t\t\t       spicc->data->fifo_size);\n\t \n\tspicc->tx_remain = burst_len;\n\tspicc->rx_remain = burst_len;\n\tspicc->xfer_remain -= burst_len * spicc->bytes_per_word;\n\n\t \n\twritel_bits_relaxed(SPICC_BURSTLENGTH_MASK,\n\t\t\tFIELD_PREP(SPICC_BURSTLENGTH_MASK,\n\t\t\t\tburst_len - 1),\n\t\t\tspicc->base + SPICC_CONREG);\n\n\t \n\tmeson_spicc_tx(spicc);\n}\n\nstatic irqreturn_t meson_spicc_irq(int irq, void *data)\n{\n\tstruct meson_spicc_device *spicc = (void *) data;\n\n\twritel_bits_relaxed(SPICC_TC, SPICC_TC, spicc->base + SPICC_STATREG);\n\n\t \n\tmeson_spicc_rx(spicc);\n\n\tif (!spicc->xfer_remain) {\n\t\t \n\t\twritel(0, spicc->base + SPICC_INTREG);\n\n\t\tcomplete(&spicc->done);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tmeson_spicc_setup_burst(spicc);\n\n\t \n\twritel_bits_relaxed(SPICC_XCH, SPICC_XCH, spicc->base + SPICC_CONREG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void meson_spicc_auto_io_delay(struct meson_spicc_device *spicc)\n{\n\tu32 div, hz;\n\tu32 mi_delay, cap_delay;\n\tu32 conf;\n\n\tif (spicc->data->has_enhance_clk_div) {\n\t\tdiv = FIELD_GET(SPICC_ENH_DATARATE_MASK,\n\t\t\t\treadl_relaxed(spicc->base + SPICC_ENH_CTL0));\n\t\tdiv++;\n\t\tdiv <<= 1;\n\t} else {\n\t\tdiv = FIELD_GET(SPICC_DATARATE_MASK,\n\t\t\t\treadl_relaxed(spicc->base + SPICC_CONREG));\n\t\tdiv += 2;\n\t\tdiv = 1 << div;\n\t}\n\n\tmi_delay = SPICC_MI_NO_DELAY;\n\tcap_delay = SPICC_CAP_AHEAD_2_CYCLE;\n\thz = clk_get_rate(spicc->clk);\n\n\tif (hz >= 100000000)\n\t\tcap_delay = SPICC_CAP_DELAY_1_CYCLE;\n\telse if (hz >= 80000000)\n\t\tcap_delay = SPICC_CAP_NO_DELAY;\n\telse if (hz >= 40000000)\n\t\tcap_delay = SPICC_CAP_AHEAD_1_CYCLE;\n\telse if (div >= 16)\n\t\tmi_delay = SPICC_MI_DELAY_3_CYCLE;\n\telse if (div >= 8)\n\t\tmi_delay = SPICC_MI_DELAY_2_CYCLE;\n\telse if (div >= 6)\n\t\tmi_delay = SPICC_MI_DELAY_1_CYCLE;\n\n\tconf = readl_relaxed(spicc->base + SPICC_TESTREG);\n\tconf &= ~(SPICC_MO_DELAY_MASK | SPICC_MI_DELAY_MASK\n\t\t  | SPICC_MI_CAP_DELAY_MASK);\n\tconf |= FIELD_PREP(SPICC_MI_DELAY_MASK, mi_delay);\n\tconf |= FIELD_PREP(SPICC_MI_CAP_DELAY_MASK, cap_delay);\n\twritel_relaxed(conf, spicc->base + SPICC_TESTREG);\n}\n\nstatic void meson_spicc_setup_xfer(struct meson_spicc_device *spicc,\n\t\t\t\t   struct spi_transfer *xfer)\n{\n\tu32 conf, conf_orig;\n\n\t \n\tconf = conf_orig = readl_relaxed(spicc->base + SPICC_CONREG);\n\n\t \n\tconf &= ~SPICC_BITLENGTH_MASK;\n\tconf |= FIELD_PREP(SPICC_BITLENGTH_MASK,\n\t\t\t   (spicc->bytes_per_word << 3) - 1);\n\n\t \n\tif (conf != conf_orig)\n\t\twritel_relaxed(conf, spicc->base + SPICC_CONREG);\n\n\tclk_set_rate(spicc->clk, xfer->speed_hz);\n\n\tmeson_spicc_auto_io_delay(spicc);\n\n\twritel_relaxed(0, spicc->base + SPICC_DMAREG);\n}\n\nstatic void meson_spicc_reset_fifo(struct meson_spicc_device *spicc)\n{\n\tif (spicc->data->has_oen)\n\t\twritel_bits_relaxed(SPICC_ENH_MAIN_CLK_AO,\n\t\t\t\t    SPICC_ENH_MAIN_CLK_AO,\n\t\t\t\t    spicc->base + SPICC_ENH_CTL0);\n\n\twritel_bits_relaxed(SPICC_FIFORST_W1_MASK, SPICC_FIFORST_W1_MASK,\n\t\t\t    spicc->base + SPICC_TESTREG);\n\n\twhile (meson_spicc_rxready(spicc))\n\t\treadl_relaxed(spicc->base + SPICC_RXDATA);\n\n\tif (spicc->data->has_oen)\n\t\twritel_bits_relaxed(SPICC_ENH_MAIN_CLK_AO, 0,\n\t\t\t\t    spicc->base + SPICC_ENH_CTL0);\n}\n\nstatic int meson_spicc_transfer_one(struct spi_master *master,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\n\tuint64_t timeout;\n\n\t \n\tspicc->xfer = xfer;\n\n\t \n\tspicc->tx_buf = (u8 *)xfer->tx_buf;\n\tspicc->rx_buf = (u8 *)xfer->rx_buf;\n\tspicc->xfer_remain = xfer->len;\n\n\t \n\tspicc->bytes_per_word =\n\t   DIV_ROUND_UP(spicc->xfer->bits_per_word, 8);\n\n\tif (xfer->len % spicc->bytes_per_word)\n\t\treturn -EINVAL;\n\n\t \n\tmeson_spicc_setup_xfer(spicc, xfer);\n\n\tmeson_spicc_reset_fifo(spicc);\n\n\t \n\tmeson_spicc_setup_burst(spicc);\n\n\t \n\treinit_completion(&spicc->done);\n\n\t \n\ttimeout = 8LL * MSEC_PER_SEC * xfer->len;\n\tdo_div(timeout, xfer->speed_hz);\n\n\t \n\ttimeout += ((xfer->len >> 4) * 10) / MSEC_PER_SEC;\n\n\t \n\ttimeout += timeout + 200;\n\n\t \n\twritel_bits_relaxed(SPICC_XCH, SPICC_XCH, spicc->base + SPICC_CONREG);\n\n\t \n\twritel_relaxed(SPICC_TC_EN, spicc->base + SPICC_INTREG);\n\n\tif (!wait_for_completion_timeout(&spicc->done, msecs_to_jiffies(timeout)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int meson_spicc_prepare_message(struct spi_master *master,\n\t\t\t\t       struct spi_message *message)\n{\n\tstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\n\tstruct spi_device *spi = message->spi;\n\tu32 conf = readl_relaxed(spicc->base + SPICC_CONREG) & SPICC_DATARATE_MASK;\n\n\t \n\tspicc->message = message;\n\n\t \n\tconf |= SPICC_ENABLE;\n\tconf |= SPICC_MODE_MASTER;\n\n\t \n\n\t \n\tif (spi->mode & SPI_CPOL)\n\t\tconf |= SPICC_POL;\n\telse\n\t\tconf &= ~SPICC_POL;\n\n\tif (!spicc->data->has_oen) {\n\t\tif (spi->mode & SPI_CPOL) {\n\t\t\tif (spicc->pins_idle_high)\n\t\t\t\tpinctrl_select_state(spicc->pinctrl, spicc->pins_idle_high);\n\t\t} else {\n\t\t\tif (spicc->pins_idle_low)\n\t\t\t\tpinctrl_select_state(spicc->pinctrl, spicc->pins_idle_low);\n\t\t}\n\t}\n\n\tif (spi->mode & SPI_CPHA)\n\t\tconf |= SPICC_PHA;\n\telse\n\t\tconf &= ~SPICC_PHA;\n\n\t \n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tconf |= SPICC_SSPOL;\n\telse\n\t\tconf &= ~SPICC_SSPOL;\n\n\tif (spi->mode & SPI_READY)\n\t\tconf |= FIELD_PREP(SPICC_DRCTL_MASK, SPICC_DRCTL_LOWLEVEL);\n\telse\n\t\tconf |= FIELD_PREP(SPICC_DRCTL_MASK, SPICC_DRCTL_IGNORE);\n\n\t \n\tconf |= FIELD_PREP(SPICC_CS_MASK, spi_get_chipselect(spi, 0));\n\n\t \n\tconf |= FIELD_PREP(SPICC_BITLENGTH_MASK, 8 - 1);\n\n\twritel_relaxed(conf, spicc->base + SPICC_CONREG);\n\n\t \n\twritel_relaxed(0, spicc->base + SPICC_PERIODREG);\n\n\twritel_bits_relaxed(SPICC_LBC_W1, 0, spicc->base + SPICC_TESTREG);\n\n\treturn 0;\n}\n\nstatic int meson_spicc_unprepare_transfer(struct spi_master *master)\n{\n\tstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\n\tu32 conf = readl_relaxed(spicc->base + SPICC_CONREG) & SPICC_DATARATE_MASK;\n\n\t \n\twritel(0, spicc->base + SPICC_INTREG);\n\n\tdevice_reset_optional(&spicc->pdev->dev);\n\n\t \n\twritel_relaxed(conf, spicc->base + SPICC_CONREG);\n\n\tif (!spicc->data->has_oen)\n\t\tpinctrl_select_default_state(&spicc->pdev->dev);\n\n\treturn 0;\n}\n\nstatic int meson_spicc_setup(struct spi_device *spi)\n{\n\tif (!spi->controller_state)\n\t\tspi->controller_state = spi_master_get_devdata(spi->master);\n\n\treturn 0;\n}\n\nstatic void meson_spicc_cleanup(struct spi_device *spi)\n{\n\tspi->controller_state = NULL;\n}\n\n \n\nstatic unsigned long meson_spicc_pow2_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tstruct meson_spicc_device *spicc = pow2_clk_to_spicc(divider);\n\n\tif (!spicc->master->cur_msg)\n\t\treturn 0;\n\n\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic int meson_spicc_pow2_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tstruct meson_spicc_device *spicc = pow2_clk_to_spicc(divider);\n\n\tif (!spicc->master->cur_msg)\n\t\treturn -EINVAL;\n\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic int meson_spicc_pow2_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tstruct meson_spicc_device *spicc = pow2_clk_to_spicc(divider);\n\n\tif (!spicc->master->cur_msg)\n\t\treturn -EINVAL;\n\n\treturn clk_divider_ops.set_rate(hw, rate, parent_rate);\n}\n\nstatic const struct clk_ops meson_spicc_pow2_clk_ops = {\n\t.recalc_rate = meson_spicc_pow2_recalc_rate,\n\t.determine_rate = meson_spicc_pow2_determine_rate,\n\t.set_rate = meson_spicc_pow2_set_rate,\n};\n\nstatic int meson_spicc_pow2_clk_init(struct meson_spicc_device *spicc)\n{\n\tstruct device *dev = &spicc->pdev->dev;\n\tstruct clk_fixed_factor *pow2_fixed_div;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\tstruct clk_parent_data parent_data[2];\n\tchar name[64];\n\n\tmemset(&init, 0, sizeof(init));\n\tmemset(&parent_data, 0, sizeof(parent_data));\n\n\tinit.parent_data = parent_data;\n\n\t \n\n\tpow2_fixed_div = devm_kzalloc(dev, sizeof(*pow2_fixed_div), GFP_KERNEL);\n\tif (!pow2_fixed_div)\n\t\treturn -ENOMEM;\n\n\tsnprintf(name, sizeof(name), \"%s#pow2_fixed_div\", dev_name(dev));\n\tinit.name = name;\n\tinit.ops = &clk_fixed_factor_ops;\n\tinit.flags = 0;\n\tif (spicc->data->has_pclk)\n\t\tparent_data[0].hw = __clk_get_hw(spicc->pclk);\n\telse\n\t\tparent_data[0].hw = __clk_get_hw(spicc->core);\n\tinit.num_parents = 1;\n\n\tpow2_fixed_div->mult = 1,\n\tpow2_fixed_div->div = 4,\n\tpow2_fixed_div->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &pow2_fixed_div->hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tsnprintf(name, sizeof(name), \"%s#pow2_div\", dev_name(dev));\n\tinit.name = name;\n\tinit.ops = &meson_spicc_pow2_clk_ops;\n\t \n\tinit.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE;\n\tparent_data[0].hw = &pow2_fixed_div->hw;\n\tinit.num_parents = 1;\n\n\tspicc->pow2_div.shift = 16,\n\tspicc->pow2_div.width = 3,\n\tspicc->pow2_div.flags = CLK_DIVIDER_POWER_OF_TWO,\n\tspicc->pow2_div.reg = spicc->base + SPICC_CONREG;\n\tspicc->pow2_div.hw.init = &init;\n\n\tspicc->clk = devm_clk_register(dev, &spicc->pow2_div.hw);\n\tif (WARN_ON(IS_ERR(spicc->clk)))\n\t\treturn PTR_ERR(spicc->clk);\n\n\treturn 0;\n}\n\nstatic int meson_spicc_enh_clk_init(struct meson_spicc_device *spicc)\n{\n\tstruct device *dev = &spicc->pdev->dev;\n\tstruct clk_fixed_factor *enh_fixed_div;\n\tstruct clk_divider *enh_div;\n\tstruct clk_mux *mux;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\tstruct clk_parent_data parent_data[2];\n\tchar name[64];\n\n\tmemset(&init, 0, sizeof(init));\n\tmemset(&parent_data, 0, sizeof(parent_data));\n\n\tinit.parent_data = parent_data;\n\n\t \n\n\tenh_fixed_div = devm_kzalloc(dev, sizeof(*enh_fixed_div), GFP_KERNEL);\n\tif (!enh_fixed_div)\n\t\treturn -ENOMEM;\n\n\tsnprintf(name, sizeof(name), \"%s#enh_fixed_div\", dev_name(dev));\n\tinit.name = name;\n\tinit.ops = &clk_fixed_factor_ops;\n\tinit.flags = 0;\n\tif (spicc->data->has_pclk)\n\t\tparent_data[0].hw = __clk_get_hw(spicc->pclk);\n\telse\n\t\tparent_data[0].hw = __clk_get_hw(spicc->core);\n\tinit.num_parents = 1;\n\n\tenh_fixed_div->mult = 1,\n\tenh_fixed_div->div = 2,\n\tenh_fixed_div->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &enh_fixed_div->hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tenh_div = devm_kzalloc(dev, sizeof(*enh_div), GFP_KERNEL);\n\tif (!enh_div)\n\t\treturn -ENOMEM;\n\n\tsnprintf(name, sizeof(name), \"%s#enh_div\", dev_name(dev));\n\tinit.name = name;\n\tinit.ops = &clk_divider_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tparent_data[0].hw = &enh_fixed_div->hw;\n\tinit.num_parents = 1;\n\n\tenh_div->shift\t= 16,\n\tenh_div->width\t= 8,\n\tenh_div->reg = spicc->base + SPICC_ENH_CTL0;\n\tenh_div->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &enh_div->hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tsnprintf(name, sizeof(name), \"%s#sel\", dev_name(dev));\n\tinit.name = name;\n\tinit.ops = &clk_mux_ops;\n\tparent_data[0].hw = &spicc->pow2_div.hw;\n\tparent_data[1].hw = &enh_div->hw;\n\tinit.num_parents = 2;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\tmux->mask = 0x1,\n\tmux->shift = 24,\n\tmux->reg = spicc->base + SPICC_ENH_CTL0;\n\tmux->hw.init = &init;\n\n\tspicc->clk = devm_clk_register(dev, &mux->hw);\n\tif (WARN_ON(IS_ERR(spicc->clk)))\n\t\treturn PTR_ERR(spicc->clk);\n\n\treturn 0;\n}\n\nstatic int meson_spicc_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct meson_spicc_device *spicc;\n\tint ret, irq;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*spicc));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"master allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspicc = spi_master_get_devdata(master);\n\tspicc->master = master;\n\n\tspicc->data = of_device_get_match_data(&pdev->dev);\n\tif (!spicc->data) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_master;\n\t}\n\n\tspicc->pdev = pdev;\n\tplatform_set_drvdata(pdev, spicc);\n\n\tinit_completion(&spicc->done);\n\n\tspicc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spicc->base)) {\n\t\tdev_err(&pdev->dev, \"io resource mapping failed\\n\");\n\t\tret = PTR_ERR(spicc->base);\n\t\tgoto out_master;\n\t}\n\n\t \n\twritel_relaxed(SPICC_ENABLE | SPICC_MODE_MASTER,\n\t\t       spicc->base + SPICC_CONREG);\n\n\t \n\twritel_relaxed(0, spicc->base + SPICC_INTREG);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_master;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, meson_spicc_irq,\n\t\t\t       0, NULL, spicc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request failed\\n\");\n\t\tgoto out_master;\n\t}\n\n\tspicc->core = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(spicc->core)) {\n\t\tdev_err(&pdev->dev, \"core clock request failed\\n\");\n\t\tret = PTR_ERR(spicc->core);\n\t\tgoto out_master;\n\t}\n\n\tif (spicc->data->has_pclk) {\n\t\tspicc->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\t\tif (IS_ERR(spicc->pclk)) {\n\t\t\tdev_err(&pdev->dev, \"pclk clock request failed\\n\");\n\t\t\tret = PTR_ERR(spicc->pclk);\n\t\t\tgoto out_master;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(spicc->core);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"core clock enable failed\\n\");\n\t\tgoto out_master;\n\t}\n\n\tret = clk_prepare_enable(spicc->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pclk clock enable failed\\n\");\n\t\tgoto out_core_clk;\n\t}\n\n\tspicc->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(spicc->pinctrl)) {\n\t\tret = PTR_ERR(spicc->pinctrl);\n\t\tgoto out_clk;\n\t}\n\n\tdevice_reset_optional(&pdev->dev);\n\n\tmaster->num_chipselect = 4;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(32) |\n\t\t\t\t     SPI_BPW_MASK(24) |\n\t\t\t\t     SPI_BPW_MASK(16) |\n\t\t\t\t     SPI_BPW_MASK(8);\n\tmaster->flags = (SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX);\n\tmaster->min_speed_hz = spicc->data->min_speed_hz;\n\tmaster->max_speed_hz = spicc->data->max_speed_hz;\n\tmaster->setup = meson_spicc_setup;\n\tmaster->cleanup = meson_spicc_cleanup;\n\tmaster->prepare_message = meson_spicc_prepare_message;\n\tmaster->unprepare_transfer_hardware = meson_spicc_unprepare_transfer;\n\tmaster->transfer_one = meson_spicc_transfer_one;\n\tmaster->use_gpio_descriptors = true;\n\n\tmeson_spicc_oen_enable(spicc);\n\n\tret = meson_spicc_pow2_clk_init(spicc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pow2 clock registration failed\\n\");\n\t\tgoto out_clk;\n\t}\n\n\tif (spicc->data->has_enhance_clk_div) {\n\t\tret = meson_spicc_enh_clk_init(spicc);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"clock registration failed\\n\");\n\t\t\tgoto out_clk;\n\t\t}\n\t}\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi master registration failed\\n\");\n\t\tgoto out_clk;\n\t}\n\n\treturn 0;\n\nout_clk:\n\tclk_disable_unprepare(spicc->pclk);\n\nout_core_clk:\n\tclk_disable_unprepare(spicc->core);\n\nout_master:\n\tspi_master_put(master);\n\n\treturn ret;\n}\n\nstatic void meson_spicc_remove(struct platform_device *pdev)\n{\n\tstruct meson_spicc_device *spicc = platform_get_drvdata(pdev);\n\n\t \n\twritel(0, spicc->base + SPICC_CONREG);\n\n\tclk_disable_unprepare(spicc->core);\n\tclk_disable_unprepare(spicc->pclk);\n\n\tspi_master_put(spicc->master);\n}\n\nstatic const struct meson_spicc_data meson_spicc_gx_data = {\n\t.max_speed_hz\t\t= 30000000,\n\t.min_speed_hz\t\t= 325000,\n\t.fifo_size\t\t= 16,\n};\n\nstatic const struct meson_spicc_data meson_spicc_axg_data = {\n\t.max_speed_hz\t\t= 80000000,\n\t.min_speed_hz\t\t= 325000,\n\t.fifo_size\t\t= 16,\n\t.has_oen\t\t= true,\n\t.has_enhance_clk_div\t= true,\n};\n\nstatic const struct meson_spicc_data meson_spicc_g12a_data = {\n\t.max_speed_hz\t\t= 166666666,\n\t.min_speed_hz\t\t= 50000,\n\t.fifo_size\t\t= 15,\n\t.has_oen\t\t= true,\n\t.has_enhance_clk_div\t= true,\n\t.has_pclk\t\t= true,\n};\n\nstatic const struct of_device_id meson_spicc_of_match[] = {\n\t{\n\t\t.compatible\t= \"amlogic,meson-gx-spicc\",\n\t\t.data\t\t= &meson_spicc_gx_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-spicc\",\n\t\t.data\t\t= &meson_spicc_axg_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-spicc\",\n\t\t.data\t\t= &meson_spicc_g12a_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_spicc_of_match);\n\nstatic struct platform_driver meson_spicc_driver = {\n\t.probe   = meson_spicc_probe,\n\t.remove_new = meson_spicc_remove,\n\t.driver  = {\n\t\t.name = \"meson-spicc\",\n\t\t.of_match_table = of_match_ptr(meson_spicc_of_match),\n\t},\n};\n\nmodule_platform_driver(meson_spicc_driver);\n\nMODULE_DESCRIPTION(\"Meson SPI Communication Controller driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}