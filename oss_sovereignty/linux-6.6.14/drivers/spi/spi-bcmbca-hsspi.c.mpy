{
  "module_name": "spi-bcmbca-hsspi.c",
  "hash_id": "6dca052399542c015911883daa03e1852fc35249aaa42d7b41576254075ef996",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcmbca-hsspi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/pm_runtime.h>\n\n#define HSSPI_GLOBAL_CTRL_REG\t\t\t0x0\n#define GLOBAL_CTRL_CS_POLARITY_SHIFT\t\t0\n#define GLOBAL_CTRL_CS_POLARITY_MASK\t\t0x000000ff\n#define GLOBAL_CTRL_PLL_CLK_CTRL_SHIFT\t\t8\n#define GLOBAL_CTRL_PLL_CLK_CTRL_MASK\t\t0x0000ff00\n#define GLOBAL_CTRL_CLK_GATE_SSOFF\t\tBIT(16)\n#define GLOBAL_CTRL_CLK_POLARITY\t\tBIT(17)\n#define GLOBAL_CTRL_MOSI_IDLE\t\t\tBIT(18)\n\n#define HSSPI_GLOBAL_EXT_TRIGGER_REG\t\t0x4\n\n#define HSSPI_INT_STATUS_REG\t\t\t0x8\n#define HSSPI_INT_STATUS_MASKED_REG\t\t0xc\n#define HSSPI_INT_MASK_REG\t\t\t0x10\n\n#define HSSPI_PINGx_CMD_DONE(i)\t\t\tBIT((i * 8) + 0)\n#define HSSPI_PINGx_RX_OVER(i)\t\t\tBIT((i * 8) + 1)\n#define HSSPI_PINGx_TX_UNDER(i)\t\t\tBIT((i * 8) + 2)\n#define HSSPI_PINGx_POLL_TIMEOUT(i)\t\tBIT((i * 8) + 3)\n#define HSSPI_PINGx_CTRL_INVAL(i)\t\tBIT((i * 8) + 4)\n\n#define HSSPI_INT_CLEAR_ALL\t\t\t0xff001f1f\n\n#define HSSPI_PINGPONG_COMMAND_REG(x)\t\t(0x80 + (x) * 0x40)\n#define PINGPONG_CMD_COMMAND_MASK\t\t0xf\n#define PINGPONG_COMMAND_NOOP\t\t\t0\n#define PINGPONG_COMMAND_START_NOW\t\t1\n#define PINGPONG_COMMAND_START_TRIGGER\t\t2\n#define PINGPONG_COMMAND_HALT\t\t\t3\n#define PINGPONG_COMMAND_FLUSH\t\t\t4\n#define PINGPONG_CMD_PROFILE_SHIFT\t\t8\n#define PINGPONG_CMD_SS_SHIFT\t\t\t12\n\n#define HSSPI_PINGPONG_STATUS_REG(x)\t\t(0x84 + (x) * 0x40)\n#define HSSPI_PINGPONG_STATUS_SRC_BUSY          BIT(1)\n\n#define HSSPI_PROFILE_CLK_CTRL_REG(x)\t\t(0x100 + (x) * 0x20)\n#define CLK_CTRL_FREQ_CTRL_MASK\t\t\t0x0000ffff\n#define CLK_CTRL_SPI_CLK_2X_SEL\t\t\tBIT(14)\n#define CLK_CTRL_ACCUM_RST_ON_LOOP\t\tBIT(15)\n#define CLK_CTRL_CLK_POLARITY\t\t\tBIT(16)\n\n#define HSSPI_PROFILE_SIGNAL_CTRL_REG(x)\t(0x104 + (x) * 0x20)\n#define SIGNAL_CTRL_LATCH_RISING\t\tBIT(12)\n#define SIGNAL_CTRL_LAUNCH_RISING\t\tBIT(13)\n#define SIGNAL_CTRL_ASYNC_INPUT_PATH\t\tBIT(16)\n\n#define HSSPI_PROFILE_MODE_CTRL_REG(x)\t\t(0x108 + (x) * 0x20)\n#define MODE_CTRL_MULTIDATA_RD_STRT_SHIFT\t8\n#define MODE_CTRL_MULTIDATA_WR_STRT_SHIFT\t12\n#define MODE_CTRL_MULTIDATA_RD_SIZE_SHIFT\t16\n#define MODE_CTRL_MULTIDATA_WR_SIZE_SHIFT\t18\n#define MODE_CTRL_MODE_3WIRE\t\t\tBIT(20)\n#define MODE_CTRL_PREPENDBYTE_CNT_SHIFT\t\t24\n\n#define HSSPI_FIFO_REG(x)\t\t\t(0x200 + (x) * 0x200)\n\n#define HSSPI_OP_MULTIBIT\t\t\tBIT(11)\n#define HSSPI_OP_CODE_SHIFT\t\t\t13\n#define HSSPI_OP_SLEEP\t\t\t\t(0 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_READ_WRITE\t\t\t(1 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_WRITE\t\t\t\t(2 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_READ\t\t\t\t(3 << HSSPI_OP_CODE_SHIFT)\n#define HSSPI_OP_SETIRQ\t\t\t\t(4 << HSSPI_OP_CODE_SHIFT)\n\n#define HSSPI_BUFFER_LEN\t\t\t512\n#define HSSPI_OPCODE_LEN\t\t\t2\n\n#define HSSPI_MAX_PREPEND_LEN\t\t\t15\n\n#define HSSPI_MAX_SYNC_CLOCK\t\t\t30000000\n\n#define HSSPI_SPI_MAX_CS\t\t\t8\n#define HSSPI_BUS_NUM\t\t\t\t1\t \n#define HSSPI_POLL_STATUS_TIMEOUT_MS\t100\n\n#define HSSPI_WAIT_MODE_POLLING\t\t0\n#define HSSPI_WAIT_MODE_INTR\t\t1\n#define HSSPI_WAIT_MODE_MAX\t\t\tHSSPI_WAIT_MODE_INTR\n\n#define SPIM_CTRL_CS_OVERRIDE_SEL_SHIFT\t\t0\n#define SPIM_CTRL_CS_OVERRIDE_SEL_MASK\t\t0xff\n#define SPIM_CTRL_CS_OVERRIDE_VAL_SHIFT\t\t8\n#define SPIM_CTRL_CS_OVERRIDE_VAL_MASK\t\t0xff\n\nstruct bcmbca_hsspi {\n\tstruct completion done;\n\tstruct mutex bus_mutex;\n\tstruct mutex msg_mutex;\n\tstruct platform_device *pdev;\n\tstruct clk *clk;\n\tstruct clk *pll_clk;\n\tvoid __iomem *regs;\n\tvoid __iomem *spim_ctrl;\n\tu8 __iomem *fifo;\n\tu32 speed_hz;\n\tu8 cs_polarity;\n\tu32 wait_mode;\n};\n\nstatic ssize_t wait_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(ctrl);\n\n\treturn sprintf(buf, \"%d\\n\", bs->wait_mode);\n}\n\nstatic ssize_t wait_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(ctrl);\n\tu32 val;\n\n\tif (kstrtou32(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > HSSPI_WAIT_MODE_MAX) {\n\t\tdev_warn(dev, \"invalid wait mode %u\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&bs->msg_mutex);\n\tbs->wait_mode = val;\n\t \n\tif (val == HSSPI_WAIT_MODE_INTR)\n\t\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\tmutex_unlock(&bs->msg_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(wait_mode);\n\nstatic struct attribute *bcmbca_hsspi_attrs[] = {\n\t&dev_attr_wait_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bcmbca_hsspi_group = {\n\t.attrs = bcmbca_hsspi_attrs,\n};\n\nstatic void bcmbca_hsspi_set_cs(struct bcmbca_hsspi *bs, unsigned int cs,\n\t\t\t\t bool active)\n{\n\tu32 reg;\n\n\t \n\tif (cs == 7)\n\t\treturn;\n\n\tmutex_lock(&bs->bus_mutex);\n\n\treg = __raw_readl(bs->spim_ctrl);\n\tif (active)\n\t\treg |= BIT(cs + SPIM_CTRL_CS_OVERRIDE_SEL_SHIFT);\n\telse\n\t\treg &= ~BIT(cs + SPIM_CTRL_CS_OVERRIDE_SEL_SHIFT);\n\n\t__raw_writel(reg, bs->spim_ctrl);\n\n\tmutex_unlock(&bs->bus_mutex);\n}\n\nstatic void bcmbca_hsspi_set_clk(struct bcmbca_hsspi *bs,\n\t\t\t\t  struct spi_device *spi, int hz)\n{\n\tunsigned int profile = spi_get_chipselect(spi, 0);\n\tu32 reg;\n\n\treg = DIV_ROUND_UP(2048, DIV_ROUND_UP(bs->speed_hz, hz));\n\t__raw_writel(CLK_CTRL_ACCUM_RST_ON_LOOP | reg,\n\t\t     bs->regs + HSSPI_PROFILE_CLK_CTRL_REG(profile));\n\n\treg = __raw_readl(bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));\n\tif (hz > HSSPI_MAX_SYNC_CLOCK)\n\t\treg |= SIGNAL_CTRL_ASYNC_INPUT_PATH;\n\telse\n\t\treg &= ~SIGNAL_CTRL_ASYNC_INPUT_PATH;\n\t__raw_writel(reg, bs->regs + HSSPI_PROFILE_SIGNAL_CTRL_REG(profile));\n\n\tmutex_lock(&bs->bus_mutex);\n\t \n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\treg &= ~GLOBAL_CTRL_CLK_POLARITY;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= GLOBAL_CTRL_CLK_POLARITY;\n\t__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\tmutex_unlock(&bs->bus_mutex);\n}\n\nstatic int bcmbca_hsspi_wait_cmd(struct bcmbca_hsspi *bs, unsigned int cs)\n{\n\tunsigned long limit;\n\tu32 reg = 0;\n\tint rc = 0;\n\n\tif (bs->wait_mode == HSSPI_WAIT_MODE_INTR) {\n\t\tif (wait_for_completion_timeout(&bs->done, HZ) == 0)\n\t\t\trc = 1;\n\t} else {\n\t\tlimit = jiffies + msecs_to_jiffies(HSSPI_POLL_STATUS_TIMEOUT_MS);\n\n\t\twhile (!time_after(jiffies, limit)) {\n\t\t\treg = __raw_readl(bs->regs + HSSPI_PINGPONG_STATUS_REG(0));\n\t\t\tif (reg & HSSPI_PINGPONG_STATUS_SRC_BUSY)\n\t\t\t\tcpu_relax();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (reg & HSSPI_PINGPONG_STATUS_SRC_BUSY)\n\t\t\trc = 1;\n\t}\n\n\tif (rc)\n\t\tdev_err(&bs->pdev->dev, \"transfer timed out!\\n\");\n\n\treturn rc;\n}\n\nstatic int bcmbca_hsspi_do_txrx(struct spi_device *spi, struct spi_transfer *t,\n\t\t\t\t\t\t\t\tstruct spi_message *msg)\n{\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tunsigned int chip_select = spi_get_chipselect(spi, 0);\n\tu16 opcode = 0, val;\n\tint pending = t->len;\n\tint step_size = HSSPI_BUFFER_LEN;\n\tconst u8 *tx = t->tx_buf;\n\tu8 *rx = t->rx_buf;\n\tu32 reg = 0, cs_act = 0;\n\n\tbcmbca_hsspi_set_clk(bs, spi, t->speed_hz);\n\n\tif (tx && rx)\n\t\topcode = HSSPI_OP_READ_WRITE;\n\telse if (tx)\n\t\topcode = HSSPI_OP_WRITE;\n\telse if (rx)\n\t\topcode = HSSPI_OP_READ;\n\n\tif (opcode != HSSPI_OP_READ)\n\t\tstep_size -= HSSPI_OPCODE_LEN;\n\n\tif ((opcode == HSSPI_OP_READ && t->rx_nbits == SPI_NBITS_DUAL) ||\n\t    (opcode == HSSPI_OP_WRITE && t->tx_nbits == SPI_NBITS_DUAL)) {\n\t\topcode |= HSSPI_OP_MULTIBIT;\n\n\t\tif (t->rx_nbits == SPI_NBITS_DUAL)\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_RD_SIZE_SHIFT;\n\t\tif (t->tx_nbits == SPI_NBITS_DUAL)\n\t\t\treg |= 1 << MODE_CTRL_MULTIDATA_WR_SIZE_SHIFT;\n\t}\n\n\t__raw_writel(reg | 0xff,\n\t\t     bs->regs + HSSPI_PROFILE_MODE_CTRL_REG(chip_select));\n\n\twhile (pending > 0) {\n\t\tint curr_step = min_t(int, step_size, pending);\n\n\t\treinit_completion(&bs->done);\n\t\tif (tx) {\n\t\t\tmemcpy_toio(bs->fifo + HSSPI_OPCODE_LEN, tx, curr_step);\n\t\t\ttx += curr_step;\n\t\t}\n\n\t\t*(__be16 *)(&val) = cpu_to_be16(opcode | curr_step);\n\t\t__raw_writew(val, bs->fifo);\n\n\t\t \n\t\tif (bs->wait_mode == HSSPI_WAIT_MODE_INTR)\n\t\t\t__raw_writel(HSSPI_PINGx_CMD_DONE(0),\n\t\t\t    bs->regs + HSSPI_INT_MASK_REG);\n\n\t\tif (!cs_act) {\n\t\t\t \n\t\t\tbcmbca_hsspi_set_cs(bs, chip_select, true);\n\t\t\tcs_act = 1;\n\t\t}\n\n\t\treg = chip_select << PINGPONG_CMD_SS_SHIFT |\n\t\t\t    chip_select << PINGPONG_CMD_PROFILE_SHIFT |\n\t\t\t    PINGPONG_COMMAND_START_NOW;\n\t\t__raw_writel(reg, bs->regs + HSSPI_PINGPONG_COMMAND_REG(0));\n\n\t\tif (bcmbca_hsspi_wait_cmd(bs, spi_get_chipselect(spi, 0)))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tpending -= curr_step;\n\n\t\tif (rx) {\n\t\t\tmemcpy_fromio(rx, bs->fifo, curr_step);\n\t\t\trx += curr_step;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcmbca_hsspi_setup(struct spi_device *spi)\n{\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(spi->controller);\n\tu32 reg;\n\n\treg = __raw_readl(bs->regs +\n\t\t\t  HSSPI_PROFILE_SIGNAL_CTRL_REG(spi_get_chipselect(spi, 0)));\n\treg &= ~(SIGNAL_CTRL_LAUNCH_RISING | SIGNAL_CTRL_LATCH_RISING);\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= SIGNAL_CTRL_LAUNCH_RISING;\n\telse\n\t\treg |= SIGNAL_CTRL_LATCH_RISING;\n\t__raw_writel(reg, bs->regs +\n\t\t     HSSPI_PROFILE_SIGNAL_CTRL_REG(spi_get_chipselect(spi, 0)));\n\n\tmutex_lock(&bs->bus_mutex);\n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\treg |= BIT(spi_get_chipselect(spi, 0));\n\telse\n\t\treg &= ~BIT(spi_get_chipselect(spi, 0));\n\t__raw_writel(reg, bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tbs->cs_polarity |= BIT(spi_get_chipselect(spi, 0));\n\telse\n\t\tbs->cs_polarity &= ~BIT(spi_get_chipselect(spi, 0));\n\n\treg = __raw_readl(bs->spim_ctrl);\n\treg &= ~BIT(spi_get_chipselect(spi, 0) + SPIM_CTRL_CS_OVERRIDE_VAL_SHIFT);\n\tif (spi->mode & SPI_CS_HIGH)\n\t\treg |= BIT(spi_get_chipselect(spi, 0) + SPIM_CTRL_CS_OVERRIDE_VAL_SHIFT);\n\t__raw_writel(reg, bs->spim_ctrl);\n\n\tmutex_unlock(&bs->bus_mutex);\n\n\treturn 0;\n}\n\nstatic int bcmbca_hsspi_transfer_one(struct spi_controller *host,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(host);\n\tstruct spi_transfer *t;\n\tstruct spi_device *spi = msg->spi;\n\tint status = -EINVAL;\n\tbool keep_cs = false;\n\n\tmutex_lock(&bs->msg_mutex);\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\t\tstatus = bcmbca_hsspi_do_txrx(spi, t, msg);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tspi_transfer_delay_exec(t);\n\n\t\tif (t->cs_change) {\n\t\t\tif (list_is_last(&t->transfer_list,\t&msg->transfers)) {\n\t\t\t\tkeep_cs = true;\n\t\t\t} else {\n\t\t\t\tif (!t->cs_off)\n\t\t\t\t\tbcmbca_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), false);\n\n\t\t\t\tspi_transfer_cs_change_delay_exec(msg, t);\n\n\t\t\t\tif (!list_next_entry(t, transfer_list)->cs_off)\n\t\t\t\t\tbcmbca_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), true);\n\t\t\t}\n\t\t} else if (!list_is_last(&t->transfer_list, &msg->transfers) &&\n\t\t\t   t->cs_off != list_next_entry(t, transfer_list)->cs_off) {\n\t\t\tbcmbca_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), t->cs_off);\n\t\t}\n\n\t\tmsg->actual_length += t->len;\n\t}\n\n\tmutex_unlock(&bs->msg_mutex);\n\n\tif (status || !keep_cs)\n\t\tbcmbca_hsspi_set_cs(bs, spi_get_chipselect(spi, 0), false);\n\n\tmsg->status = status;\n\tspi_finalize_current_message(host);\n\n\treturn 0;\n}\n\nstatic irqreturn_t bcmbca_hsspi_interrupt(int irq, void *dev_id)\n{\n\tstruct bcmbca_hsspi *bs = (struct bcmbca_hsspi *)dev_id;\n\n\tif (__raw_readl(bs->regs + HSSPI_INT_STATUS_MASKED_REG) == 0)\n\t\treturn IRQ_NONE;\n\n\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\n\tcomplete(&bs->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcmbca_hsspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct bcmbca_hsspi *bs;\n\tstruct resource *res_mem;\n\tvoid __iomem *spim_ctrl;\n\tvoid __iomem *regs;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk, *pll_clk = NULL;\n\tint irq, ret;\n\tu32 reg, rate, num_cs = HSSPI_SPI_MAX_CS;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tres_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hsspi\");\n\tif (!res_mem)\n\t\treturn -EINVAL;\n\tregs = devm_ioremap_resource(dev, res_mem);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tres_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"spim-ctrl\");\n\tif (!res_mem)\n\t\treturn -EINVAL;\n\tspim_ctrl = devm_ioremap_resource(dev, res_mem);\n\tif (IS_ERR(spim_ctrl))\n\t\treturn PTR_ERR(spim_ctrl);\n\n\tclk = devm_clk_get(dev, \"hsspi\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\trate = clk_get_rate(clk);\n\tif (!rate) {\n\t\tpll_clk = devm_clk_get(dev, \"pll\");\n\n\t\tif (IS_ERR(pll_clk)) {\n\t\t\tret = PTR_ERR(pll_clk);\n\t\t\tgoto out_disable_clk;\n\t\t}\n\n\t\tret = clk_prepare_enable(pll_clk);\n\t\tif (ret)\n\t\t\tgoto out_disable_clk;\n\n\t\trate = clk_get_rate(pll_clk);\n\t\tif (!rate) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_disable_pll_clk;\n\t\t}\n\t}\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*bs));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_pll_clk;\n\t}\n\n\tbs = spi_controller_get_devdata(host);\n\tbs->pdev = pdev;\n\tbs->clk = clk;\n\tbs->pll_clk = pll_clk;\n\tbs->regs = regs;\n\tbs->spim_ctrl = spim_ctrl;\n\tbs->speed_hz = rate;\n\tbs->fifo = (u8 __iomem *) (bs->regs + HSSPI_FIFO_REG(0));\n\tbs->wait_mode = HSSPI_WAIT_MODE_POLLING;\n\n\tmutex_init(&bs->bus_mutex);\n\tmutex_init(&bs->msg_mutex);\n\tinit_completion(&bs->done);\n\n\thost->dev.of_node = dev->of_node;\n\tif (!dev->of_node)\n\t\thost->bus_num = HSSPI_BUS_NUM;\n\n\tof_property_read_u32(dev->of_node, \"num-cs\", &num_cs);\n\tif (num_cs > 8) {\n\t\tdev_warn(dev, \"unsupported number of cs (%i), reducing to 8\\n\",\n\t\t\t num_cs);\n\t\tnum_cs = HSSPI_SPI_MAX_CS;\n\t}\n\thost->num_chipselect = num_cs;\n\thost->setup = bcmbca_hsspi_setup;\n\thost->transfer_one_message = bcmbca_hsspi_transfer_one;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |\n\t\t\t  SPI_RX_DUAL | SPI_TX_DUAL;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->auto_runtime_pm = true;\n\n\tplatform_set_drvdata(pdev, host);\n\n\t \n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\n\t \n\t__raw_writel(HSSPI_INT_CLEAR_ALL, bs->regs + HSSPI_INT_STATUS_REG);\n\n\t \n\treg = __raw_readl(bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\tbs->cs_polarity = reg & GLOBAL_CTRL_CS_POLARITY_MASK;\n\t__raw_writel(reg | GLOBAL_CTRL_CLK_GATE_SSOFF,\n\t\t     bs->regs + HSSPI_GLOBAL_CTRL_REG);\n\n\tif (irq > 0) {\n\t\tret = devm_request_irq(dev, irq, bcmbca_hsspi_interrupt, IRQF_SHARED,\n\t\t\t       pdev->name, bs);\n\t\tif (ret)\n\t\t\tgoto out_put_host;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &bcmbca_hsspi_group);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"couldn't register sysfs group\\n\");\n\t\tgoto out_pm_disable;\n\t}\n\n\t \n\tret = devm_spi_register_controller(dev, host);\n\tif (ret)\n\t\tgoto out_sysgroup_disable;\n\n\tdev_info(dev, \"Broadcom BCMBCA High Speed SPI Controller driver\");\n\n\treturn 0;\n\nout_sysgroup_disable:\n\tsysfs_remove_group(&pdev->dev.kobj, &bcmbca_hsspi_group);\nout_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nout_put_host:\n\tspi_controller_put(host);\nout_disable_pll_clk:\n\tclk_disable_unprepare(pll_clk);\nout_disable_clk:\n\tclk_disable_unprepare(clk);\n\treturn ret;\n}\n\nstatic void bcmbca_hsspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(host);\n\n\t \n\t__raw_writel(0, bs->regs + HSSPI_INT_MASK_REG);\n\tclk_disable_unprepare(bs->pll_clk);\n\tclk_disable_unprepare(bs->clk);\n\tsysfs_remove_group(&pdev->dev.kobj, &bcmbca_hsspi_group);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bcmbca_hsspi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(host);\n\n\tspi_controller_suspend(host);\n\tclk_disable_unprepare(bs->pll_clk);\n\tclk_disable_unprepare(bs->clk);\n\n\treturn 0;\n}\n\nstatic int bcmbca_hsspi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcmbca_hsspi *bs = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(bs->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bs->pll_clk) {\n\t\tret = clk_prepare_enable(bs->pll_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(bs->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspi_controller_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(bcmbca_hsspi_pm_ops, bcmbca_hsspi_suspend,\n\t\t\t bcmbca_hsspi_resume);\n\nstatic const struct of_device_id bcmbca_hsspi_of_match[] = {\n\t{ .compatible = \"brcm,bcmbca-hsspi-v1.1\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, bcmbca_hsspi_of_match);\n\nstatic struct platform_driver bcmbca_hsspi_driver = {\n\t.driver = {\n\t\t   .name = \"bcmbca-hsspi\",\n\t\t   .pm = &bcmbca_hsspi_pm_ops,\n\t\t   .of_match_table = bcmbca_hsspi_of_match,\n\t\t   },\n\t.probe = bcmbca_hsspi_probe,\n\t.remove_new = bcmbca_hsspi_remove,\n};\n\nmodule_platform_driver(bcmbca_hsspi_driver);\n\nMODULE_ALIAS(\"platform:bcmbca_hsspi\");\nMODULE_DESCRIPTION(\"Broadcom BCMBCA High Speed SPI Controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}