{
  "module_name": "spi-tegra20-slink.c",
  "hash_id": "ff39f7a609594c676c4d1887abd6898d6ed03effc2a138763ea3787b6b8beb9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-tegra20-slink.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n\n#include <soc/tegra/common.h>\n\n#define SLINK_COMMAND\t\t\t0x000\n#define SLINK_BIT_LENGTH(x)\t\t(((x) & 0x1f) << 0)\n#define SLINK_WORD_SIZE(x)\t\t(((x) & 0x1f) << 5)\n#define SLINK_BOTH_EN\t\t\t(1 << 10)\n#define SLINK_CS_SW\t\t\t(1 << 11)\n#define SLINK_CS_VALUE\t\t\t(1 << 12)\n#define SLINK_CS_POLARITY\t\t(1 << 13)\n#define SLINK_IDLE_SDA_DRIVE_LOW\t(0 << 16)\n#define SLINK_IDLE_SDA_DRIVE_HIGH\t(1 << 16)\n#define SLINK_IDLE_SDA_PULL_LOW\t\t(2 << 16)\n#define SLINK_IDLE_SDA_PULL_HIGH\t(3 << 16)\n#define SLINK_IDLE_SDA_MASK\t\t(3 << 16)\n#define SLINK_CS_POLARITY1\t\t(1 << 20)\n#define SLINK_CK_SDA\t\t\t(1 << 21)\n#define SLINK_CS_POLARITY2\t\t(1 << 22)\n#define SLINK_CS_POLARITY3\t\t(1 << 23)\n#define SLINK_IDLE_SCLK_DRIVE_LOW\t(0 << 24)\n#define SLINK_IDLE_SCLK_DRIVE_HIGH\t(1 << 24)\n#define SLINK_IDLE_SCLK_PULL_LOW\t(2 << 24)\n#define SLINK_IDLE_SCLK_PULL_HIGH\t(3 << 24)\n#define SLINK_IDLE_SCLK_MASK\t\t(3 << 24)\n#define SLINK_M_S\t\t\t(1 << 28)\n#define SLINK_WAIT\t\t\t(1 << 29)\n#define SLINK_GO\t\t\t(1 << 30)\n#define SLINK_ENB\t\t\t(1 << 31)\n\n#define SLINK_MODES\t\t\t(SLINK_IDLE_SCLK_MASK | SLINK_CK_SDA)\n\n#define SLINK_COMMAND2\t\t\t0x004\n#define SLINK_LSBFE\t\t\t(1 << 0)\n#define SLINK_SSOE\t\t\t(1 << 1)\n#define SLINK_SPIE\t\t\t(1 << 4)\n#define SLINK_BIDIROE\t\t\t(1 << 6)\n#define SLINK_MODFEN\t\t\t(1 << 7)\n#define SLINK_INT_SIZE(x)\t\t(((x) & 0x1f) << 8)\n#define SLINK_CS_ACTIVE_BETWEEN\t\t(1 << 17)\n#define SLINK_SS_EN_CS(x)\t\t(((x) & 0x3) << 18)\n#define SLINK_SS_SETUP(x)\t\t(((x) & 0x3) << 20)\n#define SLINK_FIFO_REFILLS_0\t\t(0 << 22)\n#define SLINK_FIFO_REFILLS_1\t\t(1 << 22)\n#define SLINK_FIFO_REFILLS_2\t\t(2 << 22)\n#define SLINK_FIFO_REFILLS_3\t\t(3 << 22)\n#define SLINK_FIFO_REFILLS_MASK\t\t(3 << 22)\n#define SLINK_WAIT_PACK_INT(x)\t\t(((x) & 0x7) << 26)\n#define SLINK_SPC0\t\t\t(1 << 29)\n#define SLINK_TXEN\t\t\t(1 << 30)\n#define SLINK_RXEN\t\t\t(1 << 31)\n\n#define SLINK_STATUS\t\t\t0x008\n#define SLINK_COUNT(val)\t\t(((val) >> 0) & 0x1f)\n#define SLINK_WORD(val)\t\t\t(((val) >> 5) & 0x1f)\n#define SLINK_BLK_CNT(val)\t\t(((val) >> 0) & 0xffff)\n#define SLINK_MODF\t\t\t(1 << 16)\n#define SLINK_RX_UNF\t\t\t(1 << 18)\n#define SLINK_TX_OVF\t\t\t(1 << 19)\n#define SLINK_TX_FULL\t\t\t(1 << 20)\n#define SLINK_TX_EMPTY\t\t\t(1 << 21)\n#define SLINK_RX_FULL\t\t\t(1 << 22)\n#define SLINK_RX_EMPTY\t\t\t(1 << 23)\n#define SLINK_TX_UNF\t\t\t(1 << 24)\n#define SLINK_RX_OVF\t\t\t(1 << 25)\n#define SLINK_TX_FLUSH\t\t\t(1 << 26)\n#define SLINK_RX_FLUSH\t\t\t(1 << 27)\n#define SLINK_SCLK\t\t\t(1 << 28)\n#define SLINK_ERR\t\t\t(1 << 29)\n#define SLINK_RDY\t\t\t(1 << 30)\n#define SLINK_BSY\t\t\t(1 << 31)\n#define SLINK_FIFO_ERROR\t\t(SLINK_TX_OVF | SLINK_RX_UNF |\t\\\n\t\t\t\t\tSLINK_TX_UNF | SLINK_RX_OVF)\n\n#define SLINK_FIFO_EMPTY\t\t(SLINK_TX_EMPTY | SLINK_RX_EMPTY)\n\n#define SLINK_MAS_DATA\t\t\t0x010\n#define SLINK_SLAVE_DATA\t\t0x014\n\n#define SLINK_DMA_CTL\t\t\t0x018\n#define SLINK_DMA_BLOCK_SIZE(x)\t\t(((x) & 0xffff) << 0)\n#define SLINK_TX_TRIG_1\t\t\t(0 << 16)\n#define SLINK_TX_TRIG_4\t\t\t(1 << 16)\n#define SLINK_TX_TRIG_8\t\t\t(2 << 16)\n#define SLINK_TX_TRIG_16\t\t(3 << 16)\n#define SLINK_TX_TRIG_MASK\t\t(3 << 16)\n#define SLINK_RX_TRIG_1\t\t\t(0 << 18)\n#define SLINK_RX_TRIG_4\t\t\t(1 << 18)\n#define SLINK_RX_TRIG_8\t\t\t(2 << 18)\n#define SLINK_RX_TRIG_16\t\t(3 << 18)\n#define SLINK_RX_TRIG_MASK\t\t(3 << 18)\n#define SLINK_PACKED\t\t\t(1 << 20)\n#define SLINK_PACK_SIZE_4\t\t(0 << 21)\n#define SLINK_PACK_SIZE_8\t\t(1 << 21)\n#define SLINK_PACK_SIZE_16\t\t(2 << 21)\n#define SLINK_PACK_SIZE_32\t\t(3 << 21)\n#define SLINK_PACK_SIZE_MASK\t\t(3 << 21)\n#define SLINK_IE_TXC\t\t\t(1 << 26)\n#define SLINK_IE_RXC\t\t\t(1 << 27)\n#define SLINK_DMA_EN\t\t\t(1 << 31)\n\n#define SLINK_STATUS2\t\t\t0x01c\n#define SLINK_TX_FIFO_EMPTY_COUNT(val)\t(((val) & 0x3f) >> 0)\n#define SLINK_RX_FIFO_FULL_COUNT(val)\t(((val) & 0x3f0000) >> 16)\n#define SLINK_SS_HOLD_TIME(val)\t\t(((val) & 0xF) << 6)\n\n#define SLINK_TX_FIFO\t\t\t0x100\n#define SLINK_RX_FIFO\t\t\t0x180\n\n#define DATA_DIR_TX\t\t\t(1 << 0)\n#define DATA_DIR_RX\t\t\t(1 << 1)\n\n#define SLINK_DMA_TIMEOUT\t\t(msecs_to_jiffies(1000))\n\n#define DEFAULT_SPI_DMA_BUF_LEN\t\t(16*1024)\n#define TX_FIFO_EMPTY_COUNT_MAX\t\tSLINK_TX_FIFO_EMPTY_COUNT(0x20)\n#define RX_FIFO_FULL_COUNT_ZERO\t\tSLINK_RX_FIFO_FULL_COUNT(0)\n\n#define SLINK_STATUS2_RESET \\\n\t(TX_FIFO_EMPTY_COUNT_MAX | RX_FIFO_FULL_COUNT_ZERO << 16)\n\n#define MAX_CHIP_SELECT\t\t\t4\n#define SLINK_FIFO_DEPTH\t\t32\n\nstruct tegra_slink_chip_data {\n\tbool cs_hold_time;\n};\n\nstruct tegra_slink_data {\n\tstruct device\t\t\t\t*dev;\n\tstruct spi_master\t\t\t*master;\n\tconst struct tegra_slink_chip_data\t*chip_data;\n\tspinlock_t\t\t\t\tlock;\n\n\tstruct clk\t\t\t\t*clk;\n\tstruct reset_control\t\t\t*rst;\n\tvoid __iomem\t\t\t\t*base;\n\tphys_addr_t\t\t\t\tphys;\n\tunsigned\t\t\t\tirq;\n\tu32\t\t\t\t\tcur_speed;\n\n\tstruct spi_device\t\t\t*cur_spi;\n\tunsigned\t\t\t\tcur_pos;\n\tunsigned\t\t\t\tcur_len;\n\tunsigned\t\t\t\twords_per_32bit;\n\tunsigned\t\t\t\tbytes_per_word;\n\tunsigned\t\t\t\tcurr_dma_words;\n\tunsigned\t\t\t\tcur_direction;\n\n\tunsigned\t\t\t\tcur_rx_pos;\n\tunsigned\t\t\t\tcur_tx_pos;\n\n\tunsigned\t\t\t\tdma_buf_size;\n\tunsigned\t\t\t\tmax_buf_size;\n\tbool\t\t\t\t\tis_curr_dma_xfer;\n\n\tstruct completion\t\t\trx_dma_complete;\n\tstruct completion\t\t\ttx_dma_complete;\n\n\tu32\t\t\t\t\ttx_status;\n\tu32\t\t\t\t\trx_status;\n\tu32\t\t\t\t\tstatus_reg;\n\tbool\t\t\t\t\tis_packed;\n\tu32\t\t\t\t\tpacked_size;\n\n\tu32\t\t\t\t\tcommand_reg;\n\tu32\t\t\t\t\tcommand2_reg;\n\tu32\t\t\t\t\tdma_control_reg;\n\tu32\t\t\t\t\tdef_command_reg;\n\tu32\t\t\t\t\tdef_command2_reg;\n\n\tstruct completion\t\t\txfer_completion;\n\tstruct spi_transfer\t\t\t*curr_xfer;\n\tstruct dma_chan\t\t\t\t*rx_dma_chan;\n\tu32\t\t\t\t\t*rx_dma_buf;\n\tdma_addr_t\t\t\t\trx_dma_phys;\n\tstruct dma_async_tx_descriptor\t\t*rx_dma_desc;\n\n\tstruct dma_chan\t\t\t\t*tx_dma_chan;\n\tu32\t\t\t\t\t*tx_dma_buf;\n\tdma_addr_t\t\t\t\ttx_dma_phys;\n\tstruct dma_async_tx_descriptor\t\t*tx_dma_desc;\n};\n\nstatic inline u32 tegra_slink_readl(struct tegra_slink_data *tspi,\n\t\tunsigned long reg)\n{\n\treturn readl(tspi->base + reg);\n}\n\nstatic inline void tegra_slink_writel(struct tegra_slink_data *tspi,\n\t\tu32 val, unsigned long reg)\n{\n\twritel(val, tspi->base + reg);\n\n\t \n\tif (reg != SLINK_TX_FIFO)\n\t\treadl(tspi->base + SLINK_MAS_DATA);\n}\n\nstatic void tegra_slink_clear_status(struct tegra_slink_data *tspi)\n{\n\tu32 val_write;\n\n\ttegra_slink_readl(tspi, SLINK_STATUS);\n\n\t \n\tval_write = SLINK_RDY | SLINK_FIFO_ERROR;\n\ttegra_slink_writel(tspi, val_write, SLINK_STATUS);\n}\n\nstatic u32 tegra_slink_get_packed_size(struct tegra_slink_data *tspi,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tswitch (tspi->bytes_per_word) {\n\tcase 0:\n\t\treturn SLINK_PACK_SIZE_4;\n\tcase 1:\n\t\treturn SLINK_PACK_SIZE_8;\n\tcase 2:\n\t\treturn SLINK_PACK_SIZE_16;\n\tcase 4:\n\t\treturn SLINK_PACK_SIZE_32;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned tegra_slink_calculate_curr_xfer_param(\n\tstruct spi_device *spi, struct tegra_slink_data *tspi,\n\tstruct spi_transfer *t)\n{\n\tunsigned remain_len = t->len - tspi->cur_pos;\n\tunsigned max_word;\n\tunsigned bits_per_word;\n\tunsigned max_len;\n\tunsigned total_fifo_words;\n\n\tbits_per_word = t->bits_per_word;\n\ttspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);\n\n\tif (bits_per_word == 8 || bits_per_word == 16) {\n\t\ttspi->is_packed = true;\n\t\ttspi->words_per_32bit = 32/bits_per_word;\n\t} else {\n\t\ttspi->is_packed = false;\n\t\ttspi->words_per_32bit = 1;\n\t}\n\ttspi->packed_size = tegra_slink_get_packed_size(tspi, t);\n\n\tif (tspi->is_packed) {\n\t\tmax_len = min(remain_len, tspi->max_buf_size);\n\t\ttspi->curr_dma_words = max_len/tspi->bytes_per_word;\n\t\ttotal_fifo_words = max_len/4;\n\t} else {\n\t\tmax_word = (remain_len - 1) / tspi->bytes_per_word + 1;\n\t\tmax_word = min(max_word, tspi->max_buf_size/4);\n\t\ttspi->curr_dma_words = max_word;\n\t\ttotal_fifo_words = max_word;\n\t}\n\treturn total_fifo_words;\n}\n\nstatic unsigned tegra_slink_fill_tx_fifo_from_client_txbuf(\n\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\tunsigned nbytes;\n\tunsigned tx_empty_count;\n\tu32 fifo_status;\n\tunsigned max_n_32bit;\n\tunsigned i, count;\n\tunsigned int written_words;\n\tunsigned fifo_words_left;\n\tu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\n\n\tfifo_status = tegra_slink_readl(tspi, SLINK_STATUS2);\n\ttx_empty_count = SLINK_TX_FIFO_EMPTY_COUNT(fifo_status);\n\n\tif (tspi->is_packed) {\n\t\tfifo_words_left = tx_empty_count * tspi->words_per_32bit;\n\t\twritten_words = min(fifo_words_left, tspi->curr_dma_words);\n\t\tnbytes = written_words * tspi->bytes_per_word;\n\t\tmax_n_32bit = DIV_ROUND_UP(nbytes, 4);\n\t\tfor (count = 0; count < max_n_32bit; count++) {\n\t\t\tu32 x = 0;\n\t\t\tfor (i = 0; (i < 4) && nbytes; i++, nbytes--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttegra_slink_writel(tspi, x, SLINK_TX_FIFO);\n\t\t}\n\t} else {\n\t\tmax_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);\n\t\twritten_words = max_n_32bit;\n\t\tnbytes = written_words * tspi->bytes_per_word;\n\t\tfor (count = 0; count < max_n_32bit; count++) {\n\t\t\tu32 x = 0;\n\t\t\tfor (i = 0; nbytes && (i < tspi->bytes_per_word);\n\t\t\t\t\t\t\ti++, nbytes--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttegra_slink_writel(tspi, x, SLINK_TX_FIFO);\n\t\t}\n\t}\n\ttspi->cur_tx_pos += written_words * tspi->bytes_per_word;\n\treturn written_words;\n}\n\nstatic unsigned int tegra_slink_read_rx_fifo_to_client_rxbuf(\n\t\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\tunsigned rx_full_count;\n\tu32 fifo_status;\n\tunsigned i, count;\n\tunsigned int read_words = 0;\n\tunsigned len;\n\tu8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;\n\n\tfifo_status = tegra_slink_readl(tspi, SLINK_STATUS2);\n\trx_full_count = SLINK_RX_FIFO_FULL_COUNT(fifo_status);\n\tif (tspi->is_packed) {\n\t\tlen = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tfor (count = 0; count < rx_full_count; count++) {\n\t\t\tu32 x = tegra_slink_readl(tspi, SLINK_RX_FIFO);\n\t\t\tfor (i = 0; len && (i < 4); i++, len--)\n\t\t\t\t*rx_buf++ = (x >> i*8) & 0xFF;\n\t\t}\n\t\ttspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tread_words += tspi->curr_dma_words;\n\t} else {\n\t\tfor (count = 0; count < rx_full_count; count++) {\n\t\t\tu32 x = tegra_slink_readl(tspi, SLINK_RX_FIFO);\n\t\t\tfor (i = 0; (i < tspi->bytes_per_word); i++)\n\t\t\t\t*rx_buf++ = (x >> (i*8)) & 0xFF;\n\t\t}\n\t\ttspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;\n\t\tread_words += rx_full_count;\n\t}\n\treturn read_words;\n}\n\nstatic void tegra_slink_copy_client_txbuf_to_spi_txbuf(\n\t\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\t \n\tdma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_TO_DEVICE);\n\n\tif (tspi->is_packed) {\n\t\tunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tmemcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);\n\t} else {\n\t\tunsigned int i;\n\t\tunsigned int count;\n\t\tu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\n\t\tunsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;\n\n\t\tfor (count = 0; count < tspi->curr_dma_words; count++) {\n\t\t\tu32 x = 0;\n\t\t\tfor (i = 0; consume && (i < tspi->bytes_per_word);\n\t\t\t\t\t\t\ti++, consume--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttspi->tx_dma_buf[count] = x;\n\t\t}\n\t}\n\ttspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\n\t \n\tdma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_TO_DEVICE);\n}\n\nstatic void tegra_slink_copy_spi_rxbuf_to_client_rxbuf(\n\t\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\tunsigned len;\n\n\t \n\tdma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,\n\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\n\tif (tspi->is_packed) {\n\t\tlen = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tmemcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);\n\t} else {\n\t\tunsigned int i;\n\t\tunsigned int count;\n\t\tunsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;\n\t\tu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\n\n\t\tfor (count = 0; count < tspi->curr_dma_words; count++) {\n\t\t\tu32 x = tspi->rx_dma_buf[count] & rx_mask;\n\t\t\tfor (i = 0; (i < tspi->bytes_per_word); i++)\n\t\t\t\t*rx_buf++ = (x >> (i*8)) & 0xFF;\n\t\t}\n\t}\n\ttspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\n\t \n\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n}\n\nstatic void tegra_slink_dma_complete(void *args)\n{\n\tstruct completion *dma_complete = args;\n\n\tcomplete(dma_complete);\n}\n\nstatic int tegra_slink_start_tx_dma(struct tegra_slink_data *tspi, int len)\n{\n\treinit_completion(&tspi->tx_dma_complete);\n\ttspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,\n\t\t\t\ttspi->tx_dma_phys, len, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT |  DMA_CTRL_ACK);\n\tif (!tspi->tx_dma_desc) {\n\t\tdev_err(tspi->dev, \"Not able to get desc for Tx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttspi->tx_dma_desc->callback = tegra_slink_dma_complete;\n\ttspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;\n\n\tdmaengine_submit(tspi->tx_dma_desc);\n\tdma_async_issue_pending(tspi->tx_dma_chan);\n\treturn 0;\n}\n\nstatic int tegra_slink_start_rx_dma(struct tegra_slink_data *tspi, int len)\n{\n\treinit_completion(&tspi->rx_dma_complete);\n\ttspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,\n\t\t\t\ttspi->rx_dma_phys, len, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT |  DMA_CTRL_ACK);\n\tif (!tspi->rx_dma_desc) {\n\t\tdev_err(tspi->dev, \"Not able to get desc for Rx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttspi->rx_dma_desc->callback = tegra_slink_dma_complete;\n\ttspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;\n\n\tdmaengine_submit(tspi->rx_dma_desc);\n\tdma_async_issue_pending(tspi->rx_dma_chan);\n\treturn 0;\n}\n\nstatic int tegra_slink_start_dma_based_transfer(\n\t\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned int len;\n\tint ret = 0;\n\tu32 status;\n\n\t \n\tstatus = tegra_slink_readl(tspi, SLINK_STATUS);\n\tif ((status & SLINK_FIFO_EMPTY) != SLINK_FIFO_EMPTY) {\n\t\tdev_err(tspi->dev, \"Rx/Tx fifo are not empty status 0x%08x\\n\",\n\t\t\t(unsigned)status);\n\t\treturn -EIO;\n\t}\n\n\tval = SLINK_DMA_BLOCK_SIZE(tspi->curr_dma_words - 1);\n\tval |= tspi->packed_size;\n\tif (tspi->is_packed)\n\t\tlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\n\t\t\t\t\t4) * 4;\n\telse\n\t\tlen = tspi->curr_dma_words * 4;\n\n\t \n\tif (len & 0xF)\n\t\tval |= SLINK_TX_TRIG_1 | SLINK_RX_TRIG_1;\n\telse if (((len) >> 4) & 0x1)\n\t\tval |= SLINK_TX_TRIG_4 | SLINK_RX_TRIG_4;\n\telse\n\t\tval |= SLINK_TX_TRIG_8 | SLINK_RX_TRIG_8;\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\tval |= SLINK_IE_TXC;\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\tval |= SLINK_IE_RXC;\n\n\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\ttegra_slink_copy_client_txbuf_to_spi_txbuf(tspi, t);\n\t\twmb();\n\t\tret = tegra_slink_start_tx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting tx dma failed, err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstatus = tegra_slink_readl(tspi, SLINK_STATUS);\n\t\twhile (!(status & SLINK_TX_FULL))\n\t\t\tstatus = tegra_slink_readl(tspi, SLINK_STATUS);\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\t \n\t\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\n\t\tret = tegra_slink_start_rx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting rx dma failed, err %d\\n\", ret);\n\t\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ttspi->is_curr_dma_xfer = true;\n\tif (tspi->is_packed) {\n\t\tval |= SLINK_PACKED;\n\t\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\t\t \n\t\tudelay(1);\n\t}\n\ttspi->dma_control_reg = val;\n\n\tval |= SLINK_DMA_EN;\n\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\treturn ret;\n}\n\nstatic int tegra_slink_start_cpu_based_transfer(\n\t\tstruct tegra_slink_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned cur_words;\n\n\tval = tspi->packed_size;\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\tval |= SLINK_IE_TXC;\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\tval |= SLINK_IE_RXC;\n\n\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\tcur_words = tegra_slink_fill_tx_fifo_from_client_txbuf(tspi, t);\n\telse\n\t\tcur_words = tspi->curr_dma_words;\n\tval |= SLINK_DMA_BLOCK_SIZE(cur_words - 1);\n\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\ttspi->is_curr_dma_xfer = false;\n\tif (tspi->is_packed) {\n\t\tval |= SLINK_PACKED;\n\t\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\t\tudelay(1);\n\t\twmb();\n\t}\n\ttspi->dma_control_reg = val;\n\tval |= SLINK_DMA_EN;\n\ttegra_slink_writel(tspi, val, SLINK_DMA_CTL);\n\treturn 0;\n}\n\nstatic int tegra_slink_init_dma_param(struct tegra_slink_data *tspi,\n\t\t\tbool dma_to_memory)\n{\n\tstruct dma_chan *dma_chan;\n\tu32 *dma_buf;\n\tdma_addr_t dma_phys;\n\tint ret;\n\tstruct dma_slave_config dma_sconfig;\n\n\tdma_chan = dma_request_chan(tspi->dev, dma_to_memory ? \"rx\" : \"tx\");\n\tif (IS_ERR(dma_chan))\n\t\treturn dev_err_probe(tspi->dev, PTR_ERR(dma_chan),\n\t\t\t\t     \"Dma channel is not available\\n\");\n\n\tdma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,\n\t\t\t\t&dma_phys, GFP_KERNEL);\n\tif (!dma_buf) {\n\t\tdev_err(tspi->dev, \" Not able to allocate the dma buffer\\n\");\n\t\tdma_release_channel(dma_chan);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (dma_to_memory) {\n\t\tdma_sconfig.src_addr = tspi->phys + SLINK_RX_FIFO;\n\t\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.src_maxburst = 0;\n\t} else {\n\t\tdma_sconfig.dst_addr = tspi->phys + SLINK_TX_FIFO;\n\t\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.dst_maxburst = 0;\n\t}\n\n\tret = dmaengine_slave_config(dma_chan, &dma_sconfig);\n\tif (ret)\n\t\tgoto scrub;\n\tif (dma_to_memory) {\n\t\ttspi->rx_dma_chan = dma_chan;\n\t\ttspi->rx_dma_buf = dma_buf;\n\t\ttspi->rx_dma_phys = dma_phys;\n\t} else {\n\t\ttspi->tx_dma_chan = dma_chan;\n\t\ttspi->tx_dma_buf = dma_buf;\n\t\ttspi->tx_dma_phys = dma_phys;\n\t}\n\treturn 0;\n\nscrub:\n\tdma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\n\tdma_release_channel(dma_chan);\n\treturn ret;\n}\n\nstatic void tegra_slink_deinit_dma_param(struct tegra_slink_data *tspi,\n\tbool dma_to_memory)\n{\n\tu32 *dma_buf;\n\tdma_addr_t dma_phys;\n\tstruct dma_chan *dma_chan;\n\n\tif (dma_to_memory) {\n\t\tdma_buf = tspi->rx_dma_buf;\n\t\tdma_chan = tspi->rx_dma_chan;\n\t\tdma_phys = tspi->rx_dma_phys;\n\t\ttspi->rx_dma_chan = NULL;\n\t\ttspi->rx_dma_buf = NULL;\n\t} else {\n\t\tdma_buf = tspi->tx_dma_buf;\n\t\tdma_chan = tspi->tx_dma_chan;\n\t\tdma_phys = tspi->tx_dma_phys;\n\t\ttspi->tx_dma_buf = NULL;\n\t\ttspi->tx_dma_chan = NULL;\n\t}\n\tif (!dma_chan)\n\t\treturn;\n\n\tdma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\n\tdma_release_channel(dma_chan);\n}\n\nstatic int tegra_slink_start_transfer_one(struct spi_device *spi,\n\t\tstruct spi_transfer *t)\n{\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);\n\tu32 speed;\n\tu8 bits_per_word;\n\tunsigned total_fifo_words;\n\tint ret;\n\tu32 command;\n\tu32 command2;\n\n\tbits_per_word = t->bits_per_word;\n\tspeed = t->speed_hz;\n\tif (speed != tspi->cur_speed) {\n\t\tdev_pm_opp_set_rate(tspi->dev, speed * 4);\n\t\ttspi->cur_speed = speed;\n\t}\n\n\ttspi->cur_spi = spi;\n\ttspi->cur_pos = 0;\n\ttspi->cur_rx_pos = 0;\n\ttspi->cur_tx_pos = 0;\n\ttspi->curr_xfer = t;\n\ttotal_fifo_words = tegra_slink_calculate_curr_xfer_param(spi, tspi, t);\n\n\tcommand = tspi->command_reg;\n\tcommand &= ~SLINK_BIT_LENGTH(~0);\n\tcommand |= SLINK_BIT_LENGTH(bits_per_word - 1);\n\n\tcommand2 = tspi->command2_reg;\n\tcommand2 &= ~(SLINK_RXEN | SLINK_TXEN);\n\n\ttspi->cur_direction = 0;\n\tif (t->rx_buf) {\n\t\tcommand2 |= SLINK_RXEN;\n\t\ttspi->cur_direction |= DATA_DIR_RX;\n\t}\n\tif (t->tx_buf) {\n\t\tcommand2 |= SLINK_TXEN;\n\t\ttspi->cur_direction |= DATA_DIR_TX;\n\t}\n\n\t \n\ttegra_slink_writel(tspi, command2, SLINK_COMMAND2);\n\ttspi->command2_reg = command2;\n\n\ttegra_slink_writel(tspi, command, SLINK_COMMAND);\n\ttspi->command_reg = command;\n\n\tif (total_fifo_words > SLINK_FIFO_DEPTH)\n\t\tret = tegra_slink_start_dma_based_transfer(tspi, t);\n\telse\n\t\tret = tegra_slink_start_cpu_based_transfer(tspi, t);\n\treturn ret;\n}\n\nstatic int tegra_slink_setup(struct spi_device *spi)\n{\n\tstatic const u32 cs_pol_bit[MAX_CHIP_SELECT] = {\n\t\t\tSLINK_CS_POLARITY,\n\t\t\tSLINK_CS_POLARITY1,\n\t\t\tSLINK_CS_POLARITY2,\n\t\t\tSLINK_CS_POLARITY3,\n\t};\n\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);\n\tu32 val;\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"setup %d bpw, %scpol, %scpha, %dHz\\n\",\n\t\tspi->bits_per_word,\n\t\tspi->mode & SPI_CPOL ? \"\" : \"~\",\n\t\tspi->mode & SPI_CPHA ? \"\" : \"~\",\n\t\tspi->max_speed_hz);\n\n\tret = pm_runtime_resume_and_get(tspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(tspi->dev, \"pm runtime failed, e = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\tval = tspi->def_command_reg;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tval |= cs_pol_bit[spi_get_chipselect(spi, 0)];\n\telse\n\t\tval &= ~cs_pol_bit[spi_get_chipselect(spi, 0)];\n\ttspi->def_command_reg = val;\n\ttegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\n\tpm_runtime_put(tspi->dev);\n\treturn 0;\n}\n\nstatic int tegra_slink_prepare_message(struct spi_master *master,\n\t\t\t\t       struct spi_message *msg)\n{\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\tstruct spi_device *spi = msg->spi;\n\n\ttegra_slink_clear_status(tspi);\n\n\ttspi->command_reg = tspi->def_command_reg;\n\ttspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;\n\n\ttspi->command2_reg = tspi->def_command2_reg;\n\ttspi->command2_reg |= SLINK_SS_EN_CS(spi_get_chipselect(spi, 0));\n\n\ttspi->command_reg &= ~SLINK_MODES;\n\tif (spi->mode & SPI_CPHA)\n\t\ttspi->command_reg |= SLINK_CK_SDA;\n\n\tif (spi->mode & SPI_CPOL)\n\t\ttspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;\n\telse\n\t\ttspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;\n\n\treturn 0;\n}\n\nstatic int tegra_slink_transfer_one(struct spi_master *master,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\tint ret;\n\n\treinit_completion(&tspi->xfer_completion);\n\tret = tegra_slink_start_transfer_one(spi, xfer);\n\tif (ret < 0) {\n\t\tdev_err(tspi->dev,\n\t\t\t\"spi can not start transfer, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&tspi->xfer_completion,\n\t\t\t\t\t  SLINK_DMA_TIMEOUT);\n\tif (WARN_ON(ret == 0)) {\n\t\tdev_err(tspi->dev,\n\t\t\t\"spi transfer timeout, err %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tif (tspi->tx_status)\n\t\treturn tspi->tx_status;\n\tif (tspi->rx_status)\n\t\treturn tspi->rx_status;\n\n\treturn 0;\n}\n\nstatic int tegra_slink_unprepare_message(struct spi_master *master,\n\t\t\t\t\t struct spi_message *msg)\n{\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\n\ttegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\n\ttegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);\n\n\treturn 0;\n}\n\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_slink_data *tspi)\n{\n\tstruct spi_transfer *t = tspi->curr_xfer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\tif (tspi->tx_status ||  tspi->rx_status ||\n\t\t\t\t(tspi->status_reg & SLINK_BSY)) {\n\t\tdev_err(tspi->dev,\n\t\t\t\"CpuXfer ERROR bit set 0x%x\\n\", tspi->status_reg);\n\t\tdev_err(tspi->dev,\n\t\t\t\"CpuXfer 0x%08x:0x%08x:0x%08x\\n\", tspi->command_reg,\n\t\t\t\ttspi->command2_reg, tspi->dma_control_reg);\n\t\treset_control_assert(tspi->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(tspi->rst);\n\t\tcomplete(&tspi->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttegra_slink_read_rx_fifo_to_client_rxbuf(tspi, t);\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->cur_pos = tspi->cur_tx_pos;\n\telse\n\t\ttspi->cur_pos = tspi->cur_rx_pos;\n\n\tif (tspi->cur_pos == t->len) {\n\t\tcomplete(&tspi->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\ttegra_slink_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);\n\ttegra_slink_start_cpu_based_transfer(tspi, t);\nexit:\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t handle_dma_based_xfer(struct tegra_slink_data *tspi)\n{\n\tstruct spi_transfer *t = tspi->curr_xfer;\n\tlong wait_status;\n\tint err = 0;\n\tunsigned total_fifo_words;\n\tunsigned long flags;\n\n\t \n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\tif (tspi->tx_status) {\n\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\terr += 1;\n\t\t} else {\n\t\t\twait_status = wait_for_completion_interruptible_timeout(\n\t\t\t\t&tspi->tx_dma_complete, SLINK_DMA_TIMEOUT);\n\t\t\tif (wait_status <= 0) {\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\t\tdev_err(tspi->dev, \"TxDma Xfer failed\\n\");\n\t\t\t\terr += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\tif (tspi->rx_status) {\n\t\t\tdmaengine_terminate_all(tspi->rx_dma_chan);\n\t\t\terr += 2;\n\t\t} else {\n\t\t\twait_status = wait_for_completion_interruptible_timeout(\n\t\t\t\t&tspi->rx_dma_complete, SLINK_DMA_TIMEOUT);\n\t\t\tif (wait_status <= 0) {\n\t\t\t\tdmaengine_terminate_all(tspi->rx_dma_chan);\n\t\t\t\tdev_err(tspi->dev, \"RxDma Xfer failed\\n\");\n\t\t\t\terr += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\tif (err) {\n\t\tdev_err(tspi->dev,\n\t\t\t\"DmaXfer: ERROR bit set 0x%x\\n\", tspi->status_reg);\n\t\tdev_err(tspi->dev,\n\t\t\t\"DmaXfer 0x%08x:0x%08x:0x%08x\\n\", tspi->command_reg,\n\t\t\t\ttspi->command2_reg, tspi->dma_control_reg);\n\t\treset_control_assert(tspi->rst);\n\t\tudelay(2);\n\t\treset_control_assert(tspi->rst);\n\t\tcomplete(&tspi->xfer_completion);\n\t\tspin_unlock_irqrestore(&tspi->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttegra_slink_copy_spi_rxbuf_to_client_rxbuf(tspi, t);\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->cur_pos = tspi->cur_tx_pos;\n\telse\n\t\ttspi->cur_pos = tspi->cur_rx_pos;\n\n\tif (tspi->cur_pos == t->len) {\n\t\tcomplete(&tspi->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\t \n\ttotal_fifo_words = tegra_slink_calculate_curr_xfer_param(tspi->cur_spi,\n\t\t\t\t\t\t\ttspi, t);\n\tif (total_fifo_words > SLINK_FIFO_DEPTH)\n\t\terr = tegra_slink_start_dma_based_transfer(tspi, t);\n\telse\n\t\terr = tegra_slink_start_cpu_based_transfer(tspi, t);\n\nexit:\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_slink_isr_thread(int irq, void *context_data)\n{\n\tstruct tegra_slink_data *tspi = context_data;\n\n\tif (!tspi->is_curr_dma_xfer)\n\t\treturn handle_cpu_based_xfer(tspi);\n\treturn handle_dma_based_xfer(tspi);\n}\n\nstatic irqreturn_t tegra_slink_isr(int irq, void *context_data)\n{\n\tstruct tegra_slink_data *tspi = context_data;\n\n\ttspi->status_reg = tegra_slink_readl(tspi, SLINK_STATUS);\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->tx_status = tspi->status_reg &\n\t\t\t\t\t(SLINK_TX_OVF | SLINK_TX_UNF);\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttspi->rx_status = tspi->status_reg &\n\t\t\t\t\t(SLINK_RX_OVF | SLINK_RX_UNF);\n\ttegra_slink_clear_status(tspi);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic const struct tegra_slink_chip_data tegra30_spi_cdata = {\n\t.cs_hold_time = true,\n};\n\nstatic const struct tegra_slink_chip_data tegra20_spi_cdata = {\n\t.cs_hold_time = false,\n};\n\nstatic const struct of_device_id tegra_slink_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-slink\", .data = &tegra30_spi_cdata, },\n\t{ .compatible = \"nvidia,tegra20-slink\", .data = &tegra20_spi_cdata, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_slink_of_match);\n\nstatic int tegra_slink_probe(struct platform_device *pdev)\n{\n\tstruct spi_master\t*master;\n\tstruct tegra_slink_data\t*tspi;\n\tstruct resource\t\t*r;\n\tint ret, spi_irq;\n\tconst struct tegra_slink_chip_data *cdata = NULL;\n\n\tcdata = of_device_get_match_data(&pdev->dev);\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*tspi));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"master allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->setup = tegra_slink_setup;\n\tmaster->prepare_message = tegra_slink_prepare_message;\n\tmaster->transfer_one = tegra_slink_transfer_one;\n\tmaster->unprepare_message = tegra_slink_unprepare_message;\n\tmaster->auto_runtime_pm = true;\n\tmaster->num_chipselect = MAX_CHIP_SELECT;\n\n\tplatform_set_drvdata(pdev, master);\n\ttspi = spi_master_get_devdata(master);\n\ttspi->master = master;\n\ttspi->dev = &pdev->dev;\n\ttspi->chip_data = cdata;\n\tspin_lock_init(&tspi->lock);\n\n\tif (of_property_read_u32(tspi->dev->of_node, \"spi-max-frequency\",\n\t\t\t\t &master->max_speed_hz))\n\t\tmaster->max_speed_hz = 25000000;  \n\n\ttspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(tspi->base)) {\n\t\tret = PTR_ERR(tspi->base);\n\t\tgoto exit_free_master;\n\t}\n\ttspi->phys = r->start;\n\n\t \n\ttspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tspi->clk)) {\n\t\tret = PTR_ERR(tspi->clk);\n\t\tdev_err(&pdev->dev, \"Can not get clock %d\\n\", ret);\n\t\tgoto exit_free_master;\n\t}\n\n\ttspi->rst = devm_reset_control_get_exclusive(&pdev->dev, \"spi\");\n\tif (IS_ERR(tspi->rst)) {\n\t\tdev_err(&pdev->dev, \"can not get reset\\n\");\n\t\tret = PTR_ERR(tspi->rst);\n\t\tgoto exit_free_master;\n\t}\n\n\tret = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (ret)\n\t\tgoto exit_free_master;\n\n\ttspi->max_buf_size = SLINK_FIFO_DEPTH << 2;\n\ttspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;\n\n\tret = tegra_slink_init_dma_param(tspi, true);\n\tif (ret < 0)\n\t\tgoto exit_free_master;\n\tret = tegra_slink_init_dma_param(tspi, false);\n\tif (ret < 0)\n\t\tgoto exit_rx_dma_free;\n\ttspi->max_buf_size = tspi->dma_buf_size;\n\tinit_completion(&tspi->tx_dma_complete);\n\tinit_completion(&tspi->rx_dma_complete);\n\n\tinit_completion(&tspi->xfer_completion);\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pm runtime get failed, e = %d\\n\", ret);\n\t\tgoto exit_pm_disable;\n\t}\n\n\treset_control_assert(tspi->rst);\n\tudelay(2);\n\treset_control_deassert(tspi->rst);\n\n\tspi_irq = platform_get_irq(pdev, 0);\n\tif (spi_irq < 0)\n\t\treturn spi_irq;\n\ttspi->irq = spi_irq;\n\tret = request_threaded_irq(tspi->irq, tegra_slink_isr,\n\t\t\t\t   tegra_slink_isr_thread, IRQF_ONESHOT,\n\t\t\t\t   dev_name(&pdev->dev), tspi);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register ISR for IRQ %d\\n\",\n\t\t\ttspi->irq);\n\t\tgoto exit_pm_put;\n\t}\n\n\ttspi->def_command_reg  = SLINK_M_S;\n\ttspi->def_command2_reg = SLINK_CS_ACTIVE_BETWEEN;\n\ttegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\n\ttegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);\n\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tret = spi_register_master(master);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can not register to master err %d\\n\", ret);\n\t\tgoto exit_free_irq;\n\t}\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn ret;\n\nexit_free_irq:\n\tfree_irq(spi_irq, tspi);\nexit_pm_put:\n\tpm_runtime_put(&pdev->dev);\nexit_pm_disable:\n\tpm_runtime_force_suspend(&pdev->dev);\n\n\ttegra_slink_deinit_dma_param(tspi, false);\nexit_rx_dma_free:\n\ttegra_slink_deinit_dma_param(tspi, true);\nexit_free_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void tegra_slink_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = spi_master_get(platform_get_drvdata(pdev));\n\tstruct tegra_slink_data\t*tspi = spi_master_get_devdata(master);\n\n\tspi_unregister_master(master);\n\n\tfree_irq(tspi->irq, tspi);\n\n\tpm_runtime_force_suspend(&pdev->dev);\n\n\tif (tspi->tx_dma_chan)\n\t\ttegra_slink_deinit_dma_param(tspi, false);\n\n\tif (tspi->rx_dma_chan)\n\t\ttegra_slink_deinit_dma_param(tspi, true);\n\n\tspi_master_put(master);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_slink_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\n\treturn spi_master_suspend(master);\n}\n\nstatic int tegra_slink_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm runtime failed, e = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ttegra_slink_writel(tspi, tspi->command_reg, SLINK_COMMAND);\n\ttegra_slink_writel(tspi, tspi->command2_reg, SLINK_COMMAND2);\n\tpm_runtime_put(dev);\n\n\treturn spi_master_resume(master);\n}\n#endif\n\nstatic int __maybe_unused tegra_slink_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\n\t \n\ttegra_slink_readl(tspi, SLINK_MAS_DATA);\n\n\tclk_disable_unprepare(tspi->clk);\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_slink_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(tspi->clk);\n\tif (ret < 0) {\n\t\tdev_err(tspi->dev, \"clk_prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops slink_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_slink_runtime_suspend,\n\t\ttegra_slink_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_slink_suspend, tegra_slink_resume)\n};\nstatic struct platform_driver tegra_slink_driver = {\n\t.driver = {\n\t\t.name\t\t= \"spi-tegra-slink\",\n\t\t.pm\t\t= &slink_pm_ops,\n\t\t.of_match_table\t= tegra_slink_of_match,\n\t},\n\t.probe =\ttegra_slink_probe,\n\t.remove_new =\ttegra_slink_remove,\n};\nmodule_platform_driver(tegra_slink_driver);\n\nMODULE_ALIAS(\"platform:spi-tegra-slink\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra20/Tegra30 SLINK Controller Driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}