{
  "module_name": "spidev.c",
  "hash_id": "ef4cf949229f6e5d6be0b774307bebadc4633d5a03e31716b68b3eea3d21c55f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spidev.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spidev.h>\n\n#include <linux/uaccess.h>\n\n\n \n#define SPIDEV_MAJOR\t\t\t153\t \n#define N_SPI_MINORS\t\t\t32\t \n\nstatic DECLARE_BITMAP(minors, N_SPI_MINORS);\n\nstatic_assert(N_SPI_MINORS > 0 && N_SPI_MINORS <= 256);\n\n \n#define SPI_MODE_MASK\t\t(SPI_MODE_X_MASK | SPI_CS_HIGH \\\n\t\t\t\t| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP \\\n\t\t\t\t| SPI_NO_CS | SPI_READY | SPI_TX_DUAL \\\n\t\t\t\t| SPI_TX_QUAD | SPI_TX_OCTAL | SPI_RX_DUAL \\\n\t\t\t\t| SPI_RX_QUAD | SPI_RX_OCTAL \\\n\t\t\t\t| SPI_RX_CPHA_FLIP | SPI_3WIRE_HIZ \\\n\t\t\t\t| SPI_MOSI_IDLE_LOW)\n\nstruct spidev_data {\n\tdev_t\t\t\tdevt;\n\tstruct mutex\t\tspi_lock;\n\tstruct spi_device\t*spi;\n\tstruct list_head\tdevice_entry;\n\n\t \n\tstruct mutex\t\tbuf_lock;\n\tunsigned\t\tusers;\n\tu8\t\t\t*tx_buffer;\n\tu8\t\t\t*rx_buffer;\n\tu32\t\t\tspeed_hz;\n};\n\nstatic LIST_HEAD(device_list);\nstatic DEFINE_MUTEX(device_list_lock);\n\nstatic unsigned bufsiz = 4096;\nmodule_param(bufsiz, uint, S_IRUGO);\nMODULE_PARM_DESC(bufsiz, \"data bytes in biggest supported SPI message\");\n\n \n\nstatic ssize_t\nspidev_sync_unlocked(struct spi_device *spi, struct spi_message *message)\n{\n\tssize_t status;\n\n\tstatus = spi_sync(spi, message);\n\tif (status == 0)\n\t\tstatus = message->actual_length;\n\n\treturn status;\n}\n\nstatic ssize_t\nspidev_sync(struct spidev_data *spidev, struct spi_message *message)\n{\n\tssize_t status;\n\tstruct spi_device *spi;\n\n\tmutex_lock(&spidev->spi_lock);\n\tspi = spidev->spi;\n\n\tif (spi == NULL)\n\t\tstatus = -ESHUTDOWN;\n\telse\n\t\tstatus = spidev_sync_unlocked(spi, message);\n\n\tmutex_unlock(&spidev->spi_lock);\n\treturn status;\n}\n\nstatic inline ssize_t\nspidev_sync_write(struct spidev_data *spidev, size_t len)\n{\n\tstruct spi_transfer\tt = {\n\t\t\t.tx_buf\t\t= spidev->tx_buffer,\n\t\t\t.len\t\t= len,\n\t\t\t.speed_hz\t= spidev->speed_hz,\n\t\t};\n\tstruct spi_message\tm;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\treturn spidev_sync(spidev, &m);\n}\n\nstatic inline ssize_t\nspidev_sync_read(struct spidev_data *spidev, size_t len)\n{\n\tstruct spi_transfer\tt = {\n\t\t\t.rx_buf\t\t= spidev->rx_buffer,\n\t\t\t.len\t\t= len,\n\t\t\t.speed_hz\t= spidev->speed_hz,\n\t\t};\n\tstruct spi_message\tm;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\treturn spidev_sync(spidev, &m);\n}\n\n \n\n \nstatic ssize_t\nspidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)\n{\n\tstruct spidev_data\t*spidev;\n\tssize_t\t\t\tstatus;\n\n\t \n\tif (count > bufsiz)\n\t\treturn -EMSGSIZE;\n\n\tspidev = filp->private_data;\n\n\tmutex_lock(&spidev->buf_lock);\n\tstatus = spidev_sync_read(spidev, count);\n\tif (status > 0) {\n\t\tunsigned long\tmissing;\n\n\t\tmissing = copy_to_user(buf, spidev->rx_buffer, status);\n\t\tif (missing == status)\n\t\t\tstatus = -EFAULT;\n\t\telse\n\t\t\tstatus = status - missing;\n\t}\n\tmutex_unlock(&spidev->buf_lock);\n\n\treturn status;\n}\n\n \nstatic ssize_t\nspidev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct spidev_data\t*spidev;\n\tssize_t\t\t\tstatus;\n\tunsigned long\t\tmissing;\n\n\t \n\tif (count > bufsiz)\n\t\treturn -EMSGSIZE;\n\n\tspidev = filp->private_data;\n\n\tmutex_lock(&spidev->buf_lock);\n\tmissing = copy_from_user(spidev->tx_buffer, buf, count);\n\tif (missing == 0)\n\t\tstatus = spidev_sync_write(spidev, count);\n\telse\n\t\tstatus = -EFAULT;\n\tmutex_unlock(&spidev->buf_lock);\n\n\treturn status;\n}\n\nstatic int spidev_message(struct spidev_data *spidev,\n\t\tstruct spi_ioc_transfer *u_xfers, unsigned n_xfers)\n{\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\t*k_xfers;\n\tstruct spi_transfer\t*k_tmp;\n\tstruct spi_ioc_transfer *u_tmp;\n\tunsigned\t\tn, total, tx_total, rx_total;\n\tu8\t\t\t*tx_buf, *rx_buf;\n\tint\t\t\tstatus = -EFAULT;\n\n\tspi_message_init(&msg);\n\tk_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);\n\tif (k_xfers == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\ttx_buf = spidev->tx_buffer;\n\trx_buf = spidev->rx_buffer;\n\ttotal = 0;\n\ttx_total = 0;\n\trx_total = 0;\n\tfor (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;\n\t\t\tn;\n\t\t\tn--, k_tmp++, u_tmp++) {\n\t\t \n\t\tunsigned int len_aligned = ALIGN(u_tmp->len, ARCH_DMA_MINALIGN);\n\n\t\tk_tmp->len = u_tmp->len;\n\n\t\ttotal += k_tmp->len;\n\t\t \n\t\tif (total > INT_MAX || k_tmp->len > INT_MAX) {\n\t\t\tstatus = -EMSGSIZE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (u_tmp->rx_buf) {\n\t\t\t \n\t\t\trx_total += len_aligned;\n\t\t\tif (rx_total > bufsiz) {\n\t\t\t\tstatus = -EMSGSIZE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tk_tmp->rx_buf = rx_buf;\n\t\t\trx_buf += len_aligned;\n\t\t}\n\t\tif (u_tmp->tx_buf) {\n\t\t\t \n\t\t\ttx_total += len_aligned;\n\t\t\tif (tx_total > bufsiz) {\n\t\t\t\tstatus = -EMSGSIZE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tk_tmp->tx_buf = tx_buf;\n\t\t\tif (copy_from_user(tx_buf, (const u8 __user *)\n\t\t\t\t\t\t(uintptr_t) u_tmp->tx_buf,\n\t\t\t\t\tu_tmp->len))\n\t\t\t\tgoto done;\n\t\t\ttx_buf += len_aligned;\n\t\t}\n\n\t\tk_tmp->cs_change = !!u_tmp->cs_change;\n\t\tk_tmp->tx_nbits = u_tmp->tx_nbits;\n\t\tk_tmp->rx_nbits = u_tmp->rx_nbits;\n\t\tk_tmp->bits_per_word = u_tmp->bits_per_word;\n\t\tk_tmp->delay.value = u_tmp->delay_usecs;\n\t\tk_tmp->delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tk_tmp->speed_hz = u_tmp->speed_hz;\n\t\tk_tmp->word_delay.value = u_tmp->word_delay_usecs;\n\t\tk_tmp->word_delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tif (!k_tmp->speed_hz)\n\t\t\tk_tmp->speed_hz = spidev->speed_hz;\n#ifdef VERBOSE\n\t\tdev_dbg(&spidev->spi->dev,\n\t\t\t\"  xfer len %u %s%s%s%dbits %u usec %u usec %uHz\\n\",\n\t\t\tk_tmp->len,\n\t\t\tk_tmp->rx_buf ? \"rx \" : \"\",\n\t\t\tk_tmp->tx_buf ? \"tx \" : \"\",\n\t\t\tk_tmp->cs_change ? \"cs \" : \"\",\n\t\t\tk_tmp->bits_per_word ? : spidev->spi->bits_per_word,\n\t\t\tk_tmp->delay.value,\n\t\t\tk_tmp->word_delay.value,\n\t\t\tk_tmp->speed_hz ? : spidev->spi->max_speed_hz);\n#endif\n\t\tspi_message_add_tail(k_tmp, &msg);\n\t}\n\n\tstatus = spidev_sync_unlocked(spidev->spi, &msg);\n\tif (status < 0)\n\t\tgoto done;\n\n\t \n\tfor (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;\n\t\t\tn;\n\t\t\tn--, k_tmp++, u_tmp++) {\n\t\tif (u_tmp->rx_buf) {\n\t\t\tif (copy_to_user((u8 __user *)\n\t\t\t\t\t(uintptr_t) u_tmp->rx_buf, k_tmp->rx_buf,\n\t\t\t\t\tu_tmp->len)) {\n\t\t\t\tstatus = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tstatus = total;\n\ndone:\n\tkfree(k_xfers);\n\treturn status;\n}\n\nstatic struct spi_ioc_transfer *\nspidev_get_ioc_message(unsigned int cmd, struct spi_ioc_transfer __user *u_ioc,\n\t\tunsigned *n_ioc)\n{\n\tu32\ttmp;\n\n\t \n\tif (_IOC_TYPE(cmd) != SPI_IOC_MAGIC\n\t\t\t|| _IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))\n\t\t\t|| _IOC_DIR(cmd) != _IOC_WRITE)\n\t\treturn ERR_PTR(-ENOTTY);\n\n\ttmp = _IOC_SIZE(cmd);\n\tif ((tmp % sizeof(struct spi_ioc_transfer)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\t*n_ioc = tmp / sizeof(struct spi_ioc_transfer);\n\tif (*n_ioc == 0)\n\t\treturn NULL;\n\n\t \n\treturn memdup_user(u_ioc, tmp);\n}\n\nstatic long\nspidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint\t\t\tretval = 0;\n\tstruct spidev_data\t*spidev;\n\tstruct spi_device\t*spi;\n\tu32\t\t\ttmp;\n\tunsigned\t\tn_ioc;\n\tstruct spi_ioc_transfer\t*ioc;\n\n\t \n\tif (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\n\t \n\tspidev = filp->private_data;\n\tmutex_lock(&spidev->spi_lock);\n\tspi = spi_dev_get(spidev->spi);\n\tif (spi == NULL) {\n\t\tmutex_unlock(&spidev->spi_lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tmutex_lock(&spidev->buf_lock);\n\n\tswitch (cmd) {\n\t \n\tcase SPI_IOC_RD_MODE:\n\tcase SPI_IOC_RD_MODE32:\n\t\ttmp = spi->mode;\n\n\t\t{\n\t\t\tstruct spi_controller *ctlr = spi->controller;\n\n\t\t\tif (ctlr->use_gpio_descriptors && ctlr->cs_gpiods &&\n\t\t\t    ctlr->cs_gpiods[spi_get_chipselect(spi, 0)])\n\t\t\t\ttmp &= ~SPI_CS_HIGH;\n\t\t}\n\n\t\tif (cmd == SPI_IOC_RD_MODE)\n\t\t\tretval = put_user(tmp & SPI_MODE_MASK,\n\t\t\t\t\t  (__u8 __user *)arg);\n\t\telse\n\t\t\tretval = put_user(tmp & SPI_MODE_MASK,\n\t\t\t\t\t  (__u32 __user *)arg);\n\t\tbreak;\n\tcase SPI_IOC_RD_LSB_FIRST:\n\t\tretval = put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,\n\t\t\t\t\t(__u8 __user *)arg);\n\t\tbreak;\n\tcase SPI_IOC_RD_BITS_PER_WORD:\n\t\tretval = put_user(spi->bits_per_word, (__u8 __user *)arg);\n\t\tbreak;\n\tcase SPI_IOC_RD_MAX_SPEED_HZ:\n\t\tretval = put_user(spidev->speed_hz, (__u32 __user *)arg);\n\t\tbreak;\n\n\t \n\tcase SPI_IOC_WR_MODE:\n\tcase SPI_IOC_WR_MODE32:\n\t\tif (cmd == SPI_IOC_WR_MODE)\n\t\t\tretval = get_user(tmp, (u8 __user *)arg);\n\t\telse\n\t\t\tretval = get_user(tmp, (u32 __user *)arg);\n\t\tif (retval == 0) {\n\t\t\tstruct spi_controller *ctlr = spi->controller;\n\t\t\tu32\tsave = spi->mode;\n\n\t\t\tif (tmp & ~SPI_MODE_MASK) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctlr->use_gpio_descriptors && ctlr->cs_gpiods &&\n\t\t\t    ctlr->cs_gpiods[spi_get_chipselect(spi, 0)])\n\t\t\t\ttmp |= SPI_CS_HIGH;\n\n\t\t\ttmp |= spi->mode & ~SPI_MODE_MASK;\n\t\t\tspi->mode = tmp & SPI_MODE_USER_MASK;\n\t\t\tretval = spi_setup(spi);\n\t\t\tif (retval < 0)\n\t\t\t\tspi->mode = save;\n\t\t\telse\n\t\t\t\tdev_dbg(&spi->dev, \"spi mode %x\\n\", tmp);\n\t\t}\n\t\tbreak;\n\tcase SPI_IOC_WR_LSB_FIRST:\n\t\tretval = get_user(tmp, (__u8 __user *)arg);\n\t\tif (retval == 0) {\n\t\t\tu32\tsave = spi->mode;\n\n\t\t\tif (tmp)\n\t\t\t\tspi->mode |= SPI_LSB_FIRST;\n\t\t\telse\n\t\t\t\tspi->mode &= ~SPI_LSB_FIRST;\n\t\t\tretval = spi_setup(spi);\n\t\t\tif (retval < 0)\n\t\t\t\tspi->mode = save;\n\t\t\telse\n\t\t\t\tdev_dbg(&spi->dev, \"%csb first\\n\",\n\t\t\t\t\t\ttmp ? 'l' : 'm');\n\t\t}\n\t\tbreak;\n\tcase SPI_IOC_WR_BITS_PER_WORD:\n\t\tretval = get_user(tmp, (__u8 __user *)arg);\n\t\tif (retval == 0) {\n\t\t\tu8\tsave = spi->bits_per_word;\n\n\t\t\tspi->bits_per_word = tmp;\n\t\t\tretval = spi_setup(spi);\n\t\t\tif (retval < 0)\n\t\t\t\tspi->bits_per_word = save;\n\t\t\telse\n\t\t\t\tdev_dbg(&spi->dev, \"%d bits per word\\n\", tmp);\n\t\t}\n\t\tbreak;\n\tcase SPI_IOC_WR_MAX_SPEED_HZ: {\n\t\tu32 save;\n\n\t\tretval = get_user(tmp, (__u32 __user *)arg);\n\t\tif (retval)\n\t\t\tbreak;\n\t\tif (tmp == 0) {\n\t\t\tretval = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsave = spi->max_speed_hz;\n\n\t\tspi->max_speed_hz = tmp;\n\t\tretval = spi_setup(spi);\n\t\tif (retval == 0) {\n\t\t\tspidev->speed_hz = tmp;\n\t\t\tdev_dbg(&spi->dev, \"%d Hz (max)\\n\", spidev->speed_hz);\n\t\t}\n\n\t\tspi->max_speed_hz = save;\n\t\tbreak;\n\t}\n\tdefault:\n\t\t \n\t\t \n\t\tioc = spidev_get_ioc_message(cmd,\n\t\t\t\t(struct spi_ioc_transfer __user *)arg, &n_ioc);\n\t\tif (IS_ERR(ioc)) {\n\t\t\tretval = PTR_ERR(ioc);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ioc)\n\t\t\tbreak;\t \n\n\t\t \n\t\tretval = spidev_message(spidev, ioc, n_ioc);\n\t\tkfree(ioc);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&spidev->buf_lock);\n\tspi_dev_put(spi);\n\tmutex_unlock(&spidev->spi_lock);\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nspidev_compat_ioc_message(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct spi_ioc_transfer __user\t*u_ioc;\n\tint\t\t\t\tretval = 0;\n\tstruct spidev_data\t\t*spidev;\n\tstruct spi_device\t\t*spi;\n\tunsigned\t\t\tn_ioc, n;\n\tstruct spi_ioc_transfer\t\t*ioc;\n\n\tu_ioc = (struct spi_ioc_transfer __user *) compat_ptr(arg);\n\n\t \n\tspidev = filp->private_data;\n\tmutex_lock(&spidev->spi_lock);\n\tspi = spi_dev_get(spidev->spi);\n\tif (spi == NULL) {\n\t\tmutex_unlock(&spidev->spi_lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tmutex_lock(&spidev->buf_lock);\n\n\t \n\tioc = spidev_get_ioc_message(cmd, u_ioc, &n_ioc);\n\tif (IS_ERR(ioc)) {\n\t\tretval = PTR_ERR(ioc);\n\t\tgoto done;\n\t}\n\tif (!ioc)\n\t\tgoto done;\t \n\n\t \n\tfor (n = 0; n < n_ioc; n++) {\n\t\tioc[n].rx_buf = (uintptr_t) compat_ptr(ioc[n].rx_buf);\n\t\tioc[n].tx_buf = (uintptr_t) compat_ptr(ioc[n].tx_buf);\n\t}\n\n\t \n\tretval = spidev_message(spidev, ioc, n_ioc);\n\tkfree(ioc);\n\ndone:\n\tmutex_unlock(&spidev->buf_lock);\n\tspi_dev_put(spi);\n\tmutex_unlock(&spidev->spi_lock);\n\treturn retval;\n}\n\nstatic long\nspidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tif (_IOC_TYPE(cmd) == SPI_IOC_MAGIC\n\t\t\t&& _IOC_NR(cmd) == _IOC_NR(SPI_IOC_MESSAGE(0))\n\t\t\t&& _IOC_DIR(cmd) == _IOC_WRITE)\n\t\treturn spidev_compat_ioc_message(filp, cmd, arg);\n\n\treturn spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define spidev_compat_ioctl NULL\n#endif  \n\nstatic int spidev_open(struct inode *inode, struct file *filp)\n{\n\tstruct spidev_data\t*spidev = NULL, *iter;\n\tint\t\t\tstatus = -ENXIO;\n\n\tmutex_lock(&device_list_lock);\n\n\tlist_for_each_entry(iter, &device_list, device_entry) {\n\t\tif (iter->devt == inode->i_rdev) {\n\t\t\tstatus = 0;\n\t\t\tspidev = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!spidev) {\n\t\tpr_debug(\"spidev: nothing for minor %d\\n\", iminor(inode));\n\t\tgoto err_find_dev;\n\t}\n\n\tif (!spidev->tx_buffer) {\n\t\tspidev->tx_buffer = kmalloc(bufsiz, GFP_KERNEL);\n\t\tif (!spidev->tx_buffer) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto err_find_dev;\n\t\t}\n\t}\n\n\tif (!spidev->rx_buffer) {\n\t\tspidev->rx_buffer = kmalloc(bufsiz, GFP_KERNEL);\n\t\tif (!spidev->rx_buffer) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto err_alloc_rx_buf;\n\t\t}\n\t}\n\n\tspidev->users++;\n\tfilp->private_data = spidev;\n\tstream_open(inode, filp);\n\n\tmutex_unlock(&device_list_lock);\n\treturn 0;\n\nerr_alloc_rx_buf:\n\tkfree(spidev->tx_buffer);\n\tspidev->tx_buffer = NULL;\nerr_find_dev:\n\tmutex_unlock(&device_list_lock);\n\treturn status;\n}\n\nstatic int spidev_release(struct inode *inode, struct file *filp)\n{\n\tstruct spidev_data\t*spidev;\n\tint\t\t\tdofree;\n\n\tmutex_lock(&device_list_lock);\n\tspidev = filp->private_data;\n\tfilp->private_data = NULL;\n\n\tmutex_lock(&spidev->spi_lock);\n\t \n\tdofree = (spidev->spi == NULL);\n\tmutex_unlock(&spidev->spi_lock);\n\n\t \n\tspidev->users--;\n\tif (!spidev->users) {\n\n\t\tkfree(spidev->tx_buffer);\n\t\tspidev->tx_buffer = NULL;\n\n\t\tkfree(spidev->rx_buffer);\n\t\tspidev->rx_buffer = NULL;\n\n\t\tif (dofree)\n\t\t\tkfree(spidev);\n\t\telse\n\t\t\tspidev->speed_hz = spidev->spi->max_speed_hz;\n\t}\n#ifdef CONFIG_SPI_SLAVE\n\tif (!dofree)\n\t\tspi_slave_abort(spidev->spi);\n#endif\n\tmutex_unlock(&device_list_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations spidev_fops = {\n\t.owner =\tTHIS_MODULE,\n\t \n\t.write =\tspidev_write,\n\t.read =\t\tspidev_read,\n\t.unlocked_ioctl = spidev_ioctl,\n\t.compat_ioctl = spidev_compat_ioctl,\n\t.open =\t\tspidev_open,\n\t.release =\tspidev_release,\n\t.llseek =\tno_llseek,\n};\n\n \n\n \n\nstatic struct class *spidev_class;\n\nstatic const struct spi_device_id spidev_spi_ids[] = {\n\t{ .name = \"dh2228fv\" },\n\t{ .name = \"ltc2488\" },\n\t{ .name = \"sx1301\" },\n\t{ .name = \"bk4\" },\n\t{ .name = \"dhcom-board\" },\n\t{ .name = \"m53cpld\" },\n\t{ .name = \"spi-petra\" },\n\t{ .name = \"spi-authenta\" },\n\t{ .name = \"em3581\" },\n\t{ .name = \"si3210\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, spidev_spi_ids);\n\n \nstatic int spidev_of_check(struct device *dev)\n{\n\tif (device_property_match_string(dev, \"compatible\", \"spidev\") < 0)\n\t\treturn 0;\n\n\tdev_err(dev, \"spidev listed directly in DT is not supported\\n\");\n\treturn -EINVAL;\n}\n\nstatic const struct of_device_id spidev_dt_ids[] = {\n\t{ .compatible = \"cisco,spi-petra\", .data = &spidev_of_check },\n\t{ .compatible = \"dh,dhcom-board\", .data = &spidev_of_check },\n\t{ .compatible = \"lineartechnology,ltc2488\", .data = &spidev_of_check },\n\t{ .compatible = \"lwn,bk4\", .data = &spidev_of_check },\n\t{ .compatible = \"menlo,m53cpld\", .data = &spidev_of_check },\n\t{ .compatible = \"micron,spi-authenta\", .data = &spidev_of_check },\n\t{ .compatible = \"rohm,dh2228fv\", .data = &spidev_of_check },\n\t{ .compatible = \"semtech,sx1301\", .data = &spidev_of_check },\n\t{ .compatible = \"silabs,em3581\", .data = &spidev_of_check },\n\t{ .compatible = \"silabs,si3210\", .data = &spidev_of_check },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, spidev_dt_ids);\n\n \nstatic int spidev_acpi_check(struct device *dev)\n{\n\tdev_warn(dev, \"do not use this driver in production systems!\\n\");\n\treturn 0;\n}\n\nstatic const struct acpi_device_id spidev_acpi_ids[] = {\n\t \n\t{ \"SPT0001\", (kernel_ulong_t)&spidev_acpi_check },\n\t{ \"SPT0002\", (kernel_ulong_t)&spidev_acpi_check },\n\t{ \"SPT0003\", (kernel_ulong_t)&spidev_acpi_check },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, spidev_acpi_ids);\n\n \n\nstatic int spidev_probe(struct spi_device *spi)\n{\n\tint (*match)(struct device *dev);\n\tstruct spidev_data\t*spidev;\n\tint\t\t\tstatus;\n\tunsigned long\t\tminor;\n\n\tmatch = device_get_match_data(&spi->dev);\n\tif (match) {\n\t\tstatus = match(&spi->dev);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tspidev = kzalloc(sizeof(*spidev), GFP_KERNEL);\n\tif (!spidev)\n\t\treturn -ENOMEM;\n\n\t \n\tspidev->spi = spi;\n\tmutex_init(&spidev->spi_lock);\n\tmutex_init(&spidev->buf_lock);\n\n\tINIT_LIST_HEAD(&spidev->device_entry);\n\n\t \n\tmutex_lock(&device_list_lock);\n\tminor = find_first_zero_bit(minors, N_SPI_MINORS);\n\tif (minor < N_SPI_MINORS) {\n\t\tstruct device *dev;\n\n\t\tspidev->devt = MKDEV(SPIDEV_MAJOR, minor);\n\t\tdev = device_create(spidev_class, &spi->dev, spidev->devt,\n\t\t\t\t    spidev, \"spidev%d.%d\",\n\t\t\t\t    spi->master->bus_num, spi_get_chipselect(spi, 0));\n\t\tstatus = PTR_ERR_OR_ZERO(dev);\n\t} else {\n\t\tdev_dbg(&spi->dev, \"no minor number available!\\n\");\n\t\tstatus = -ENODEV;\n\t}\n\tif (status == 0) {\n\t\tset_bit(minor, minors);\n\t\tlist_add(&spidev->device_entry, &device_list);\n\t}\n\tmutex_unlock(&device_list_lock);\n\n\tspidev->speed_hz = spi->max_speed_hz;\n\n\tif (status == 0)\n\t\tspi_set_drvdata(spi, spidev);\n\telse\n\t\tkfree(spidev);\n\n\treturn status;\n}\n\nstatic void spidev_remove(struct spi_device *spi)\n{\n\tstruct spidev_data\t*spidev = spi_get_drvdata(spi);\n\n\t \n\tmutex_lock(&device_list_lock);\n\t \n\tmutex_lock(&spidev->spi_lock);\n\tspidev->spi = NULL;\n\tmutex_unlock(&spidev->spi_lock);\n\n\tlist_del(&spidev->device_entry);\n\tdevice_destroy(spidev_class, spidev->devt);\n\tclear_bit(MINOR(spidev->devt), minors);\n\tif (spidev->users == 0)\n\t\tkfree(spidev);\n\tmutex_unlock(&device_list_lock);\n}\n\nstatic struct spi_driver spidev_spi_driver = {\n\t.driver = {\n\t\t.name =\t\t\"spidev\",\n\t\t.of_match_table = spidev_dt_ids,\n\t\t.acpi_match_table = spidev_acpi_ids,\n\t},\n\t.probe =\tspidev_probe,\n\t.remove =\tspidev_remove,\n\t.id_table =\tspidev_spi_ids,\n\n\t \n};\n\n \n\nstatic int __init spidev_init(void)\n{\n\tint status;\n\n\t \n\tstatus = register_chrdev(SPIDEV_MAJOR, \"spi\", &spidev_fops);\n\tif (status < 0)\n\t\treturn status;\n\n\tspidev_class = class_create(\"spidev\");\n\tif (IS_ERR(spidev_class)) {\n\t\tunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\n\t\treturn PTR_ERR(spidev_class);\n\t}\n\n\tstatus = spi_register_driver(&spidev_spi_driver);\n\tif (status < 0) {\n\t\tclass_destroy(spidev_class);\n\t\tunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\n\t}\n\treturn status;\n}\nmodule_init(spidev_init);\n\nstatic void __exit spidev_exit(void)\n{\n\tspi_unregister_driver(&spidev_spi_driver);\n\tclass_destroy(spidev_class);\n\tunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\n}\nmodule_exit(spidev_exit);\n\nMODULE_AUTHOR(\"Andrea Paterniani, <a.paterniani@swapp-eng.it>\");\nMODULE_DESCRIPTION(\"User mode SPI device interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:spidev\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}