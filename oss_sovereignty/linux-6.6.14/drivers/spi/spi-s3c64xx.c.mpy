{
  "module_name": "spi-s3c64xx.c",
  "hash_id": "7e6c98dd8ad4ba431798b6d846bf6d89bccd060bc490b0aef378d1fd12101051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-s3c64xx.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/spi-s3c64xx.h>\n\n#define MAX_SPI_PORTS\t\t12\n#define S3C64XX_SPI_QUIRK_CS_AUTO\t(1 << 1)\n#define AUTOSUSPEND_TIMEOUT\t2000\n\n \n\n#define S3C64XX_SPI_CH_CFG\t\t0x00\n#define S3C64XX_SPI_CLK_CFG\t\t0x04\n#define S3C64XX_SPI_MODE_CFG\t\t0x08\n#define S3C64XX_SPI_CS_REG\t\t0x0C\n#define S3C64XX_SPI_INT_EN\t\t0x10\n#define S3C64XX_SPI_STATUS\t\t0x14\n#define S3C64XX_SPI_TX_DATA\t\t0x18\n#define S3C64XX_SPI_RX_DATA\t\t0x1C\n#define S3C64XX_SPI_PACKET_CNT\t\t0x20\n#define S3C64XX_SPI_PENDING_CLR\t\t0x24\n#define S3C64XX_SPI_SWAP_CFG\t\t0x28\n#define S3C64XX_SPI_FB_CLK\t\t0x2C\n\n#define S3C64XX_SPI_CH_HS_EN\t\t(1<<6)\t \n#define S3C64XX_SPI_CH_SW_RST\t\t(1<<5)\n#define S3C64XX_SPI_CH_SLAVE\t\t(1<<4)\n#define S3C64XX_SPI_CPOL_L\t\t(1<<3)\n#define S3C64XX_SPI_CPHA_B\t\t(1<<2)\n#define S3C64XX_SPI_CH_RXCH_ON\t\t(1<<1)\n#define S3C64XX_SPI_CH_TXCH_ON\t\t(1<<0)\n\n#define S3C64XX_SPI_CLKSEL_SRCMSK\t(3<<9)\n#define S3C64XX_SPI_CLKSEL_SRCSHFT\t9\n#define S3C64XX_SPI_ENCLK_ENABLE\t(1<<8)\n#define S3C64XX_SPI_PSR_MASK\t\t0xff\n\n#define S3C64XX_SPI_MODE_CH_TSZ_BYTE\t\t(0<<29)\n#define S3C64XX_SPI_MODE_CH_TSZ_HALFWORD\t(1<<29)\n#define S3C64XX_SPI_MODE_CH_TSZ_WORD\t\t(2<<29)\n#define S3C64XX_SPI_MODE_CH_TSZ_MASK\t\t(3<<29)\n#define S3C64XX_SPI_MODE_BUS_TSZ_BYTE\t\t(0<<17)\n#define S3C64XX_SPI_MODE_BUS_TSZ_HALFWORD\t(1<<17)\n#define S3C64XX_SPI_MODE_BUS_TSZ_WORD\t\t(2<<17)\n#define S3C64XX_SPI_MODE_BUS_TSZ_MASK\t\t(3<<17)\n#define S3C64XX_SPI_MODE_RX_RDY_LVL\t\tGENMASK(16, 11)\n#define S3C64XX_SPI_MODE_RX_RDY_LVL_SHIFT\t11\n#define S3C64XX_SPI_MODE_SELF_LOOPBACK\t\t(1<<3)\n#define S3C64XX_SPI_MODE_RXDMA_ON\t\t(1<<2)\n#define S3C64XX_SPI_MODE_TXDMA_ON\t\t(1<<1)\n#define S3C64XX_SPI_MODE_4BURST\t\t\t(1<<0)\n\n#define S3C64XX_SPI_CS_NSC_CNT_2\t\t(2<<4)\n#define S3C64XX_SPI_CS_AUTO\t\t\t(1<<1)\n#define S3C64XX_SPI_CS_SIG_INACT\t\t(1<<0)\n\n#define S3C64XX_SPI_INT_TRAILING_EN\t\t(1<<6)\n#define S3C64XX_SPI_INT_RX_OVERRUN_EN\t\t(1<<5)\n#define S3C64XX_SPI_INT_RX_UNDERRUN_EN\t\t(1<<4)\n#define S3C64XX_SPI_INT_TX_OVERRUN_EN\t\t(1<<3)\n#define S3C64XX_SPI_INT_TX_UNDERRUN_EN\t\t(1<<2)\n#define S3C64XX_SPI_INT_RX_FIFORDY_EN\t\t(1<<1)\n#define S3C64XX_SPI_INT_TX_FIFORDY_EN\t\t(1<<0)\n\n#define S3C64XX_SPI_ST_RX_OVERRUN_ERR\t\t(1<<5)\n#define S3C64XX_SPI_ST_RX_UNDERRUN_ERR\t\t(1<<4)\n#define S3C64XX_SPI_ST_TX_OVERRUN_ERR\t\t(1<<3)\n#define S3C64XX_SPI_ST_TX_UNDERRUN_ERR\t\t(1<<2)\n#define S3C64XX_SPI_ST_RX_FIFORDY\t\t(1<<1)\n#define S3C64XX_SPI_ST_TX_FIFORDY\t\t(1<<0)\n\n#define S3C64XX_SPI_PACKET_CNT_EN\t\t(1<<16)\n#define S3C64XX_SPI_PACKET_CNT_MASK\t\tGENMASK(15, 0)\n\n#define S3C64XX_SPI_PND_TX_UNDERRUN_CLR\t\t(1<<4)\n#define S3C64XX_SPI_PND_TX_OVERRUN_CLR\t\t(1<<3)\n#define S3C64XX_SPI_PND_RX_UNDERRUN_CLR\t\t(1<<2)\n#define S3C64XX_SPI_PND_RX_OVERRUN_CLR\t\t(1<<1)\n#define S3C64XX_SPI_PND_TRAILING_CLR\t\t(1<<0)\n\n#define S3C64XX_SPI_SWAP_RX_HALF_WORD\t\t(1<<7)\n#define S3C64XX_SPI_SWAP_RX_BYTE\t\t(1<<6)\n#define S3C64XX_SPI_SWAP_RX_BIT\t\t\t(1<<5)\n#define S3C64XX_SPI_SWAP_RX_EN\t\t\t(1<<4)\n#define S3C64XX_SPI_SWAP_TX_HALF_WORD\t\t(1<<3)\n#define S3C64XX_SPI_SWAP_TX_BYTE\t\t(1<<2)\n#define S3C64XX_SPI_SWAP_TX_BIT\t\t\t(1<<1)\n#define S3C64XX_SPI_SWAP_TX_EN\t\t\t(1<<0)\n\n#define S3C64XX_SPI_FBCLK_MSK\t\t\t(3<<0)\n\n#define FIFO_LVL_MASK(i) ((i)->port_conf->fifo_lvl_mask[i->port_id])\n#define S3C64XX_SPI_ST_TX_DONE(v, i) (((v) & \\\n\t\t\t\t(1 << (i)->port_conf->tx_st_done)) ? 1 : 0)\n#define TX_FIFO_LVL(v, i) (((v) >> 6) & FIFO_LVL_MASK(i))\n#define RX_FIFO_LVL(v, i) (((v) >> (i)->port_conf->rx_lvl_offset) & \\\n\t\t\t\t\tFIFO_LVL_MASK(i))\n\n#define S3C64XX_SPI_MAX_TRAILCNT\t0x3ff\n#define S3C64XX_SPI_TRAILCNT_OFF\t19\n\n#define S3C64XX_SPI_TRAILCNT\t\tS3C64XX_SPI_MAX_TRAILCNT\n\n#define S3C64XX_SPI_POLLING_SIZE\t32\n\n#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)\n#define is_polling(x)\t(x->cntrlr_info->polling)\n\n#define RXBUSY    (1<<2)\n#define TXBUSY    (1<<3)\n\nstruct s3c64xx_spi_dma_data {\n\tstruct dma_chan *ch;\n\tdma_cookie_t cookie;\n\tenum dma_transfer_direction direction;\n};\n\n \nstruct s3c64xx_spi_port_config {\n\tint\tfifo_lvl_mask[MAX_SPI_PORTS];\n\tint\trx_lvl_offset;\n\tint\ttx_st_done;\n\tint\tquirks;\n\tint\tclk_div;\n\tbool\thigh_speed;\n\tbool\tclk_from_cmu;\n\tbool\tclk_ioclk;\n\tbool\thas_loopback;\n};\n\n \nstruct s3c64xx_spi_driver_data {\n\tvoid __iomem                    *regs;\n\tstruct clk                      *clk;\n\tstruct clk                      *src_clk;\n\tstruct clk                      *ioclk;\n\tstruct platform_device          *pdev;\n\tstruct spi_controller           *host;\n\tstruct s3c64xx_spi_info         *cntrlr_info;\n\tspinlock_t                      lock;\n\tunsigned long                   sfr_start;\n\tstruct completion               xfer_completion;\n\tunsigned                        state;\n\tunsigned                        cur_mode, cur_bpw;\n\tunsigned                        cur_speed;\n\tstruct s3c64xx_spi_dma_data\trx_dma;\n\tstruct s3c64xx_spi_dma_data\ttx_dma;\n\tconst struct s3c64xx_spi_port_config\t*port_conf;\n\tunsigned int\t\t\tport_id;\n};\n\nstatic void s3c64xx_flush_fifo(struct s3c64xx_spi_driver_data *sdd)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tunsigned long loops;\n\tu32 val;\n\n\twritel(0, regs + S3C64XX_SPI_PACKET_CNT);\n\n\tval = readl(regs + S3C64XX_SPI_CH_CFG);\n\tval &= ~(S3C64XX_SPI_CH_RXCH_ON | S3C64XX_SPI_CH_TXCH_ON);\n\twritel(val, regs + S3C64XX_SPI_CH_CFG);\n\n\tval = readl(regs + S3C64XX_SPI_CH_CFG);\n\tval |= S3C64XX_SPI_CH_SW_RST;\n\tval &= ~S3C64XX_SPI_CH_HS_EN;\n\twritel(val, regs + S3C64XX_SPI_CH_CFG);\n\n\t \n\tloops = msecs_to_loops(1);\n\tdo {\n\t\tval = readl(regs + S3C64XX_SPI_STATUS);\n\t} while (TX_FIFO_LVL(val, sdd) && loops--);\n\n\tif (loops == 0)\n\t\tdev_warn(&sdd->pdev->dev, \"Timed out flushing TX FIFO\\n\");\n\n\t \n\tloops = msecs_to_loops(1);\n\tdo {\n\t\tval = readl(regs + S3C64XX_SPI_STATUS);\n\t\tif (RX_FIFO_LVL(val, sdd))\n\t\t\treadl(regs + S3C64XX_SPI_RX_DATA);\n\t\telse\n\t\t\tbreak;\n\t} while (loops--);\n\n\tif (loops == 0)\n\t\tdev_warn(&sdd->pdev->dev, \"Timed out flushing RX FIFO\\n\");\n\n\tval = readl(regs + S3C64XX_SPI_CH_CFG);\n\tval &= ~S3C64XX_SPI_CH_SW_RST;\n\twritel(val, regs + S3C64XX_SPI_CH_CFG);\n\n\tval = readl(regs + S3C64XX_SPI_MODE_CFG);\n\tval &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\n\twritel(val, regs + S3C64XX_SPI_MODE_CFG);\n}\n\nstatic void s3c64xx_spi_dmacb(void *data)\n{\n\tstruct s3c64xx_spi_driver_data *sdd;\n\tstruct s3c64xx_spi_dma_data *dma = data;\n\tunsigned long flags;\n\n\tif (dma->direction == DMA_DEV_TO_MEM)\n\t\tsdd = container_of(data,\n\t\t\tstruct s3c64xx_spi_driver_data, rx_dma);\n\telse\n\t\tsdd = container_of(data,\n\t\t\tstruct s3c64xx_spi_driver_data, tx_dma);\n\n\tspin_lock_irqsave(&sdd->lock, flags);\n\n\tif (dma->direction == DMA_DEV_TO_MEM) {\n\t\tsdd->state &= ~RXBUSY;\n\t\tif (!(sdd->state & TXBUSY))\n\t\t\tcomplete(&sdd->xfer_completion);\n\t} else {\n\t\tsdd->state &= ~TXBUSY;\n\t\tif (!(sdd->state & RXBUSY))\n\t\t\tcomplete(&sdd->xfer_completion);\n\t}\n\n\tspin_unlock_irqrestore(&sdd->lock, flags);\n}\n\nstatic int prepare_dma(struct s3c64xx_spi_dma_data *dma,\n\t\t\tstruct sg_table *sgt)\n{\n\tstruct s3c64xx_spi_driver_data *sdd;\n\tstruct dma_slave_config config;\n\tstruct dma_async_tx_descriptor *desc;\n\tint ret;\n\n\tmemset(&config, 0, sizeof(config));\n\n\tif (dma->direction == DMA_DEV_TO_MEM) {\n\t\tsdd = container_of((void *)dma,\n\t\t\tstruct s3c64xx_spi_driver_data, rx_dma);\n\t\tconfig.direction = dma->direction;\n\t\tconfig.src_addr = sdd->sfr_start + S3C64XX_SPI_RX_DATA;\n\t\tconfig.src_addr_width = sdd->cur_bpw / 8;\n\t\tconfig.src_maxburst = 1;\n\t\tdmaengine_slave_config(dma->ch, &config);\n\t} else {\n\t\tsdd = container_of((void *)dma,\n\t\t\tstruct s3c64xx_spi_driver_data, tx_dma);\n\t\tconfig.direction = dma->direction;\n\t\tconfig.dst_addr = sdd->sfr_start + S3C64XX_SPI_TX_DATA;\n\t\tconfig.dst_addr_width = sdd->cur_bpw / 8;\n\t\tconfig.dst_maxburst = 1;\n\t\tdmaengine_slave_config(dma->ch, &config);\n\t}\n\n\tdesc = dmaengine_prep_slave_sg(dma->ch, sgt->sgl, sgt->nents,\n\t\t\t\t       dma->direction, DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tdev_err(&sdd->pdev->dev, \"unable to prepare %s scatterlist\",\n\t\t\tdma->direction == DMA_DEV_TO_MEM ? \"rx\" : \"tx\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc->callback = s3c64xx_spi_dmacb;\n\tdesc->callback_param = dma;\n\n\tdma->cookie = dmaengine_submit(desc);\n\tret = dma_submit_error(dma->cookie);\n\tif (ret) {\n\t\tdev_err(&sdd->pdev->dev, \"DMA submission failed\");\n\t\treturn -EIO;\n\t}\n\n\tdma_async_issue_pending(dma->ch);\n\treturn 0;\n}\n\nstatic void s3c64xx_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct s3c64xx_spi_driver_data *sdd =\n\t\t\t\t\tspi_controller_get_devdata(spi->controller);\n\n\tif (sdd->cntrlr_info->no_cs)\n\t\treturn;\n\n\tif (enable) {\n\t\tif (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO)) {\n\t\t\twritel(0, sdd->regs + S3C64XX_SPI_CS_REG);\n\t\t} else {\n\t\t\tu32 ssel = readl(sdd->regs + S3C64XX_SPI_CS_REG);\n\n\t\t\tssel |= (S3C64XX_SPI_CS_AUTO |\n\t\t\t\t\t\tS3C64XX_SPI_CS_NSC_CNT_2);\n\t\t\twritel(ssel, sdd->regs + S3C64XX_SPI_CS_REG);\n\t\t}\n\t} else {\n\t\tif (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))\n\t\t\twritel(S3C64XX_SPI_CS_SIG_INACT,\n\t\t\t       sdd->regs + S3C64XX_SPI_CS_REG);\n\t}\n}\n\nstatic int s3c64xx_spi_prepare_transfer(struct spi_controller *spi)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(spi);\n\n\tif (is_polling(sdd))\n\t\treturn 0;\n\n\t \n\tsdd->rx_dma.ch = dma_request_chan(&sdd->pdev->dev, \"rx\");\n\tif (IS_ERR(sdd->rx_dma.ch)) {\n\t\tdev_err(&sdd->pdev->dev, \"Failed to get RX DMA channel\\n\");\n\t\tsdd->rx_dma.ch = NULL;\n\t\treturn 0;\n\t}\n\n\tsdd->tx_dma.ch = dma_request_chan(&sdd->pdev->dev, \"tx\");\n\tif (IS_ERR(sdd->tx_dma.ch)) {\n\t\tdev_err(&sdd->pdev->dev, \"Failed to get TX DMA channel\\n\");\n\t\tdma_release_channel(sdd->rx_dma.ch);\n\t\tsdd->tx_dma.ch = NULL;\n\t\tsdd->rx_dma.ch = NULL;\n\t\treturn 0;\n\t}\n\n\tspi->dma_rx = sdd->rx_dma.ch;\n\tspi->dma_tx = sdd->tx_dma.ch;\n\n\treturn 0;\n}\n\nstatic int s3c64xx_spi_unprepare_transfer(struct spi_controller *spi)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(spi);\n\n\tif (is_polling(sdd))\n\t\treturn 0;\n\n\t \n\tif (sdd->rx_dma.ch && sdd->tx_dma.ch) {\n\t\tdma_release_channel(sdd->rx_dma.ch);\n\t\tdma_release_channel(sdd->tx_dma.ch);\n\t\tsdd->rx_dma.ch = NULL;\n\t\tsdd->tx_dma.ch = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool s3c64xx_spi_can_dma(struct spi_controller *host,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\n\tif (sdd->rx_dma.ch && sdd->tx_dma.ch) {\n\t\treturn xfer->len > (FIFO_LVL_MASK(sdd) >> 1) + 1;\n\t} else {\n\t\treturn false;\n\t}\n\n}\n\nstatic int s3c64xx_enable_datapath(struct s3c64xx_spi_driver_data *sdd,\n\t\t\t\t    struct spi_transfer *xfer, int dma_mode)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tu32 modecfg, chcfg;\n\tint ret = 0;\n\n\tmodecfg = readl(regs + S3C64XX_SPI_MODE_CFG);\n\tmodecfg &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\n\n\tchcfg = readl(regs + S3C64XX_SPI_CH_CFG);\n\tchcfg &= ~S3C64XX_SPI_CH_TXCH_ON;\n\n\tif (dma_mode) {\n\t\tchcfg &= ~S3C64XX_SPI_CH_RXCH_ON;\n\t} else {\n\t\t \n\t\tchcfg |= S3C64XX_SPI_CH_RXCH_ON;\n\t\twritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\n\t\t\t\t\t| S3C64XX_SPI_PACKET_CNT_EN,\n\t\t\t\t\tregs + S3C64XX_SPI_PACKET_CNT);\n\t}\n\n\tif (xfer->tx_buf != NULL) {\n\t\tsdd->state |= TXBUSY;\n\t\tchcfg |= S3C64XX_SPI_CH_TXCH_ON;\n\t\tif (dma_mode) {\n\t\t\tmodecfg |= S3C64XX_SPI_MODE_TXDMA_ON;\n\t\t\tret = prepare_dma(&sdd->tx_dma, &xfer->tx_sg);\n\t\t} else {\n\t\t\tswitch (sdd->cur_bpw) {\n\t\t\tcase 32:\n\t\t\t\tiowrite32_rep(regs + S3C64XX_SPI_TX_DATA,\n\t\t\t\t\txfer->tx_buf, xfer->len / 4);\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tiowrite16_rep(regs + S3C64XX_SPI_TX_DATA,\n\t\t\t\t\txfer->tx_buf, xfer->len / 2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiowrite8_rep(regs + S3C64XX_SPI_TX_DATA,\n\t\t\t\t\txfer->tx_buf, xfer->len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (xfer->rx_buf != NULL) {\n\t\tsdd->state |= RXBUSY;\n\n\t\tif (sdd->port_conf->high_speed && sdd->cur_speed >= 30000000UL\n\t\t\t\t\t&& !(sdd->cur_mode & SPI_CPHA))\n\t\t\tchcfg |= S3C64XX_SPI_CH_HS_EN;\n\n\t\tif (dma_mode) {\n\t\t\tmodecfg |= S3C64XX_SPI_MODE_RXDMA_ON;\n\t\t\tchcfg |= S3C64XX_SPI_CH_RXCH_ON;\n\t\t\twritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\n\t\t\t\t\t| S3C64XX_SPI_PACKET_CNT_EN,\n\t\t\t\t\tregs + S3C64XX_SPI_PACKET_CNT);\n\t\t\tret = prepare_dma(&sdd->rx_dma, &xfer->rx_sg);\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\twritel(modecfg, regs + S3C64XX_SPI_MODE_CFG);\n\twritel(chcfg, regs + S3C64XX_SPI_CH_CFG);\n\n\treturn 0;\n}\n\nstatic u32 s3c64xx_spi_wait_for_timeout(struct s3c64xx_spi_driver_data *sdd,\n\t\t\t\t\tint timeout_ms)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tunsigned long val = 1;\n\tu32 status;\n\n\t \n\tu32 max_fifo = (FIFO_LVL_MASK(sdd) >> 1) + 1;\n\n\tif (timeout_ms)\n\t\tval = msecs_to_loops(timeout_ms);\n\n\tdo {\n\t\tstatus = readl(regs + S3C64XX_SPI_STATUS);\n\t} while (RX_FIFO_LVL(status, sdd) < max_fifo && --val);\n\n\t \n\treturn RX_FIFO_LVL(status, sdd);\n}\n\nstatic int s3c64xx_wait_for_dma(struct s3c64xx_spi_driver_data *sdd,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tunsigned long val;\n\tu32 status;\n\tint ms;\n\n\t \n\tms = xfer->len * 8 * 1000 / sdd->cur_speed;\n\tms += 30;                \n\tms = max(ms, 100);       \n\n\tval = msecs_to_jiffies(ms) + 10;\n\tval = wait_for_completion_timeout(&sdd->xfer_completion, val);\n\n\t \n\tif (val && !xfer->rx_buf) {\n\t\tval = msecs_to_loops(10);\n\t\tstatus = readl(regs + S3C64XX_SPI_STATUS);\n\t\twhile ((TX_FIFO_LVL(status, sdd)\n\t\t\t|| !S3C64XX_SPI_ST_TX_DONE(status, sdd))\n\t\t       && --val) {\n\t\t\tcpu_relax();\n\t\t\tstatus = readl(regs + S3C64XX_SPI_STATUS);\n\t\t}\n\n\t}\n\n\t \n\tif (!val)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int s3c64xx_wait_for_pio(struct s3c64xx_spi_driver_data *sdd,\n\t\t\t\tstruct spi_transfer *xfer, bool use_irq)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tunsigned long val;\n\tu32 status;\n\tint loops;\n\tu32 cpy_len;\n\tu8 *buf;\n\tint ms;\n\tunsigned long time_us;\n\n\t \n\ttime_us = (xfer->len * 8 * 1000 * 1000) / sdd->cur_speed;\n\tms = (time_us / 1000);\n\tms += 10;  \n\n\t \n\tstatus = readl(regs + S3C64XX_SPI_STATUS);\n\tif (RX_FIFO_LVL(status, sdd) < xfer->len)\n\t\tusleep_range(time_us / 2, time_us);\n\n\tif (use_irq) {\n\t\tval = msecs_to_jiffies(ms);\n\t\tif (!wait_for_completion_timeout(&sdd->xfer_completion, val))\n\t\t\treturn -EIO;\n\t}\n\n\tval = msecs_to_loops(ms);\n\tdo {\n\t\tstatus = readl(regs + S3C64XX_SPI_STATUS);\n\t} while (RX_FIFO_LVL(status, sdd) < xfer->len && --val);\n\n\tif (!val)\n\t\treturn -EIO;\n\n\t \n\tif (!xfer->rx_buf) {\n\t\tsdd->state &= ~TXBUSY;\n\t\treturn 0;\n\t}\n\n\t \n\tloops = xfer->len / ((FIFO_LVL_MASK(sdd) >> 1) + 1);\n\tbuf = xfer->rx_buf;\n\tdo {\n\t\t \n\t\tcpy_len = s3c64xx_spi_wait_for_timeout(sdd,\n\t\t\t\t\t\t       (loops ? ms : 0));\n\n\t\tswitch (sdd->cur_bpw) {\n\t\tcase 32:\n\t\t\tioread32_rep(regs + S3C64XX_SPI_RX_DATA,\n\t\t\t\t     buf, cpy_len / 4);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tioread16_rep(regs + S3C64XX_SPI_RX_DATA,\n\t\t\t\t     buf, cpy_len / 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioread8_rep(regs + S3C64XX_SPI_RX_DATA,\n\t\t\t\t    buf, cpy_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = buf + cpy_len;\n\t} while (loops--);\n\tsdd->state &= ~RXBUSY;\n\n\treturn 0;\n}\n\nstatic int s3c64xx_spi_config(struct s3c64xx_spi_driver_data *sdd)\n{\n\tvoid __iomem *regs = sdd->regs;\n\tint ret;\n\tu32 val;\n\tint div = sdd->port_conf->clk_div;\n\n\t \n\tif (!sdd->port_conf->clk_from_cmu) {\n\t\tval = readl(regs + S3C64XX_SPI_CLK_CFG);\n\t\tval &= ~S3C64XX_SPI_ENCLK_ENABLE;\n\t\twritel(val, regs + S3C64XX_SPI_CLK_CFG);\n\t}\n\n\t \n\tval = readl(regs + S3C64XX_SPI_CH_CFG);\n\tval &= ~(S3C64XX_SPI_CH_SLAVE |\n\t\t\tS3C64XX_SPI_CPOL_L |\n\t\t\tS3C64XX_SPI_CPHA_B);\n\n\tif (sdd->cur_mode & SPI_CPOL)\n\t\tval |= S3C64XX_SPI_CPOL_L;\n\n\tif (sdd->cur_mode & SPI_CPHA)\n\t\tval |= S3C64XX_SPI_CPHA_B;\n\n\twritel(val, regs + S3C64XX_SPI_CH_CFG);\n\n\t \n\tval = readl(regs + S3C64XX_SPI_MODE_CFG);\n\tval &= ~(S3C64XX_SPI_MODE_BUS_TSZ_MASK\n\t\t\t| S3C64XX_SPI_MODE_CH_TSZ_MASK);\n\n\tswitch (sdd->cur_bpw) {\n\tcase 32:\n\t\tval |= S3C64XX_SPI_MODE_BUS_TSZ_WORD;\n\t\tval |= S3C64XX_SPI_MODE_CH_TSZ_WORD;\n\t\tbreak;\n\tcase 16:\n\t\tval |= S3C64XX_SPI_MODE_BUS_TSZ_HALFWORD;\n\t\tval |= S3C64XX_SPI_MODE_CH_TSZ_HALFWORD;\n\t\tbreak;\n\tdefault:\n\t\tval |= S3C64XX_SPI_MODE_BUS_TSZ_BYTE;\n\t\tval |= S3C64XX_SPI_MODE_CH_TSZ_BYTE;\n\t\tbreak;\n\t}\n\n\tif ((sdd->cur_mode & SPI_LOOP) && sdd->port_conf->has_loopback)\n\t\tval |= S3C64XX_SPI_MODE_SELF_LOOPBACK;\n\telse\n\t\tval &= ~S3C64XX_SPI_MODE_SELF_LOOPBACK;\n\n\twritel(val, regs + S3C64XX_SPI_MODE_CFG);\n\n\tif (sdd->port_conf->clk_from_cmu) {\n\t\tret = clk_set_rate(sdd->src_clk, sdd->cur_speed * div);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsdd->cur_speed = clk_get_rate(sdd->src_clk) / div;\n\t} else {\n\t\t \n\t\tval = readl(regs + S3C64XX_SPI_CLK_CFG);\n\t\tval &= ~S3C64XX_SPI_PSR_MASK;\n\t\tval |= ((clk_get_rate(sdd->src_clk) / sdd->cur_speed / div - 1)\n\t\t\t\t& S3C64XX_SPI_PSR_MASK);\n\t\twritel(val, regs + S3C64XX_SPI_CLK_CFG);\n\n\t\t \n\t\tval = readl(regs + S3C64XX_SPI_CLK_CFG);\n\t\tval |= S3C64XX_SPI_ENCLK_ENABLE;\n\t\twritel(val, regs + S3C64XX_SPI_CLK_CFG);\n\t}\n\n\treturn 0;\n}\n\n#define XFER_DMAADDR_INVALID DMA_BIT_MASK(32)\n\nstatic int s3c64xx_spi_prepare_message(struct spi_controller *host,\n\t\t\t\t       struct spi_message *msg)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\tstruct spi_device *spi = msg->spi;\n\tstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\n\n\t \n\tif (!cs)\n\t\t \n\t\twritel(0, sdd->regs + S3C64XX_SPI_FB_CLK);\n\telse\n\t\twritel(cs->fb_delay & 0x3, sdd->regs + S3C64XX_SPI_FB_CLK);\n\n\treturn 0;\n}\n\nstatic size_t s3c64xx_spi_max_transfer_size(struct spi_device *spi)\n{\n\tstruct spi_controller *ctlr = spi->controller;\n\n\treturn ctlr->can_dma ? S3C64XX_SPI_PACKET_CNT_MASK : SIZE_MAX;\n}\n\nstatic int s3c64xx_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\tconst unsigned int fifo_len = (FIFO_LVL_MASK(sdd) >> 1) + 1;\n\tconst void *tx_buf = NULL;\n\tvoid *rx_buf = NULL;\n\tint target_len = 0, origin_len = 0;\n\tint use_dma = 0;\n\tbool use_irq = false;\n\tint status;\n\tu32 speed;\n\tu8 bpw;\n\tunsigned long flags;\n\tu32 rdy_lv;\n\tu32 val;\n\n\treinit_completion(&sdd->xfer_completion);\n\n\t \n\tbpw = xfer->bits_per_word;\n\tspeed = xfer->speed_hz;\n\n\tif (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {\n\t\tsdd->cur_bpw = bpw;\n\t\tsdd->cur_speed = speed;\n\t\tsdd->cur_mode = spi->mode;\n\t\tstatus = s3c64xx_spi_config(sdd);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (!is_polling(sdd) && (xfer->len > fifo_len) &&\n\t    sdd->rx_dma.ch && sdd->tx_dma.ch) {\n\t\tuse_dma = 1;\n\n\t} else if (xfer->len >= fifo_len) {\n\t\ttx_buf = xfer->tx_buf;\n\t\trx_buf = xfer->rx_buf;\n\t\torigin_len = xfer->len;\n\t\ttarget_len = xfer->len;\n\t\txfer->len = fifo_len - 1;\n\t}\n\n\tdo {\n\t\t \n\t\tif (!use_dma && xfer->len > S3C64XX_SPI_POLLING_SIZE)\n\t\t\tuse_irq = true;\n\n\t\tif (use_irq) {\n\t\t\treinit_completion(&sdd->xfer_completion);\n\n\t\t\trdy_lv = xfer->len;\n\t\t\t \n\t\t\tif (fifo_len == 128)\n\t\t\t\trdy_lv /= 2;\n\t\t\telse if (fifo_len == 256)\n\t\t\t\trdy_lv /= 4;\n\n\t\t\tval = readl(sdd->regs + S3C64XX_SPI_MODE_CFG);\n\t\t\tval &= ~S3C64XX_SPI_MODE_RX_RDY_LVL;\n\t\t\tval |= (rdy_lv << S3C64XX_SPI_MODE_RX_RDY_LVL_SHIFT);\n\t\t\twritel(val, sdd->regs + S3C64XX_SPI_MODE_CFG);\n\n\t\t\t \n\t\t\tval = readl(sdd->regs + S3C64XX_SPI_INT_EN);\n\t\t\twritel((val | S3C64XX_SPI_INT_RX_FIFORDY_EN),\n\t\t\t\t\tsdd->regs + S3C64XX_SPI_INT_EN);\n\n\t\t}\n\n\t\tspin_lock_irqsave(&sdd->lock, flags);\n\n\t\t \n\t\tsdd->state &= ~RXBUSY;\n\t\tsdd->state &= ~TXBUSY;\n\n\t\t \n\t\ts3c64xx_spi_set_cs(spi, true);\n\n\t\tstatus = s3c64xx_enable_datapath(sdd, xfer, use_dma);\n\n\t\tspin_unlock_irqrestore(&sdd->lock, flags);\n\n\t\tif (status) {\n\t\t\tdev_err(&spi->dev, \"failed to enable data path for transfer: %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (use_dma)\n\t\t\tstatus = s3c64xx_wait_for_dma(sdd, xfer);\n\t\telse\n\t\t\tstatus = s3c64xx_wait_for_pio(sdd, xfer, use_irq);\n\n\t\tif (status) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"I/O Error: rx-%d tx-%d rx-%c tx-%c len-%d dma-%d res-(%d)\\n\",\n\t\t\t\txfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,\n\t\t\t\t(sdd->state & RXBUSY) ? 'f' : 'p',\n\t\t\t\t(sdd->state & TXBUSY) ? 'f' : 'p',\n\t\t\t\txfer->len, use_dma ? 1 : 0, status);\n\n\t\t\tif (use_dma) {\n\t\t\t\tstruct dma_tx_state s;\n\n\t\t\t\tif (xfer->tx_buf && (sdd->state & TXBUSY)) {\n\t\t\t\t\tdmaengine_pause(sdd->tx_dma.ch);\n\t\t\t\t\tdmaengine_tx_status(sdd->tx_dma.ch, sdd->tx_dma.cookie, &s);\n\t\t\t\t\tdmaengine_terminate_all(sdd->tx_dma.ch);\n\t\t\t\t\tdev_err(&spi->dev, \"TX residue: %d\\n\", s.residue);\n\n\t\t\t\t}\n\t\t\t\tif (xfer->rx_buf && (sdd->state & RXBUSY)) {\n\t\t\t\t\tdmaengine_pause(sdd->rx_dma.ch);\n\t\t\t\t\tdmaengine_tx_status(sdd->rx_dma.ch, sdd->rx_dma.cookie, &s);\n\t\t\t\t\tdmaengine_terminate_all(sdd->rx_dma.ch);\n\t\t\t\t\tdev_err(&spi->dev, \"RX residue: %d\\n\", s.residue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts3c64xx_flush_fifo(sdd);\n\t\t}\n\t\tif (target_len > 0) {\n\t\t\ttarget_len -= xfer->len;\n\n\t\t\tif (xfer->tx_buf)\n\t\t\t\txfer->tx_buf += xfer->len;\n\n\t\t\tif (xfer->rx_buf)\n\t\t\t\txfer->rx_buf += xfer->len;\n\n\t\t\tif (target_len >= fifo_len)\n\t\t\t\txfer->len = fifo_len - 1;\n\t\t\telse\n\t\t\t\txfer->len = target_len;\n\t\t}\n\t} while (target_len > 0);\n\n\tif (origin_len) {\n\t\t \n\t\txfer->tx_buf = tx_buf;\n\t\txfer->rx_buf = rx_buf;\n\t\txfer->len = origin_len;\n\t}\n\n\treturn status;\n}\n\nstatic struct s3c64xx_spi_csinfo *s3c64xx_get_target_ctrldata(\n\t\t\t\tstruct spi_device *spi)\n{\n\tstruct s3c64xx_spi_csinfo *cs;\n\tstruct device_node *target_np, *data_np = NULL;\n\tu32 fb_delay = 0;\n\n\ttarget_np = spi->dev.of_node;\n\tif (!target_np) {\n\t\tdev_err(&spi->dev, \"device node not found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata_np = of_get_child_by_name(target_np, \"controller-data\");\n\tif (!data_np) {\n\t\tdev_info(&spi->dev, \"feedback delay set to default (0)\\n\");\n\t\treturn cs;\n\t}\n\n\tof_property_read_u32(data_np, \"samsung,spi-feedback-delay\", &fb_delay);\n\tcs->fb_delay = fb_delay;\n\tof_node_put(data_np);\n\treturn cs;\n}\n\n \nstatic int s3c64xx_spi_setup(struct spi_device *spi)\n{\n\tstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\n\tstruct s3c64xx_spi_driver_data *sdd;\n\tint err;\n\tint div;\n\n\tsdd = spi_controller_get_devdata(spi->controller);\n\tif (spi->dev.of_node) {\n\t\tcs = s3c64xx_get_target_ctrldata(spi);\n\t\tspi->controller_data = cs;\n\t}\n\n\t \n\tif (IS_ERR(cs)) {\n\t\tdev_err(&spi->dev, \"No CS for SPI(%d)\\n\", spi_get_chipselect(spi, 0));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!spi_get_ctldata(spi))\n\t\tspi_set_ctldata(spi, cs);\n\n\tpm_runtime_get_sync(&sdd->pdev->dev);\n\n\tdiv = sdd->port_conf->clk_div;\n\n\t \n\tif (!sdd->port_conf->clk_from_cmu) {\n\t\tu32 psr, speed;\n\n\t\t \n\t\tspeed = clk_get_rate(sdd->src_clk) / div / (0 + 1);\n\n\t\tif (spi->max_speed_hz > speed)\n\t\t\tspi->max_speed_hz = speed;\n\n\t\tpsr = clk_get_rate(sdd->src_clk) / div / spi->max_speed_hz - 1;\n\t\tpsr &= S3C64XX_SPI_PSR_MASK;\n\t\tif (psr == S3C64XX_SPI_PSR_MASK)\n\t\t\tpsr--;\n\n\t\tspeed = clk_get_rate(sdd->src_clk) / div / (psr + 1);\n\t\tif (spi->max_speed_hz < speed) {\n\t\t\tif (psr+1 < S3C64XX_SPI_PSR_MASK) {\n\t\t\t\tpsr++;\n\t\t\t} else {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto setup_exit;\n\t\t\t}\n\t\t}\n\n\t\tspeed = clk_get_rate(sdd->src_clk) / div / (psr + 1);\n\t\tif (spi->max_speed_hz >= speed) {\n\t\t\tspi->max_speed_hz = speed;\n\t\t} else {\n\t\t\tdev_err(&spi->dev, \"Can't set %dHz transfer speed\\n\",\n\t\t\t\tspi->max_speed_hz);\n\t\t\terr = -EINVAL;\n\t\t\tgoto setup_exit;\n\t\t}\n\t}\n\n\tpm_runtime_mark_last_busy(&sdd->pdev->dev);\n\tpm_runtime_put_autosuspend(&sdd->pdev->dev);\n\ts3c64xx_spi_set_cs(spi, false);\n\n\treturn 0;\n\nsetup_exit:\n\tpm_runtime_mark_last_busy(&sdd->pdev->dev);\n\tpm_runtime_put_autosuspend(&sdd->pdev->dev);\n\t \n\ts3c64xx_spi_set_cs(spi, false);\n\n\tspi_set_ctldata(spi, NULL);\n\n\t \n\tif (spi->dev.of_node)\n\t\tkfree(cs);\n\n\treturn err;\n}\n\nstatic void s3c64xx_spi_cleanup(struct spi_device *spi)\n{\n\tstruct s3c64xx_spi_csinfo *cs = spi_get_ctldata(spi);\n\n\t \n\tif (spi->dev.of_node)\n\t\tkfree(cs);\n\n\tspi_set_ctldata(spi, NULL);\n}\n\nstatic irqreturn_t s3c64xx_spi_irq(int irq, void *data)\n{\n\tstruct s3c64xx_spi_driver_data *sdd = data;\n\tstruct spi_controller *spi = sdd->host;\n\tunsigned int val, clr = 0;\n\n\tval = readl(sdd->regs + S3C64XX_SPI_STATUS);\n\n\tif (val & S3C64XX_SPI_ST_RX_OVERRUN_ERR) {\n\t\tclr = S3C64XX_SPI_PND_RX_OVERRUN_CLR;\n\t\tdev_err(&spi->dev, \"RX overrun\\n\");\n\t}\n\tif (val & S3C64XX_SPI_ST_RX_UNDERRUN_ERR) {\n\t\tclr |= S3C64XX_SPI_PND_RX_UNDERRUN_CLR;\n\t\tdev_err(&spi->dev, \"RX underrun\\n\");\n\t}\n\tif (val & S3C64XX_SPI_ST_TX_OVERRUN_ERR) {\n\t\tclr |= S3C64XX_SPI_PND_TX_OVERRUN_CLR;\n\t\tdev_err(&spi->dev, \"TX overrun\\n\");\n\t}\n\tif (val & S3C64XX_SPI_ST_TX_UNDERRUN_ERR) {\n\t\tclr |= S3C64XX_SPI_PND_TX_UNDERRUN_CLR;\n\t\tdev_err(&spi->dev, \"TX underrun\\n\");\n\t}\n\n\tif (val & S3C64XX_SPI_ST_RX_FIFORDY) {\n\t\tcomplete(&sdd->xfer_completion);\n\t\t \n\t\tval = readl(sdd->regs + S3C64XX_SPI_INT_EN);\n\t\twritel((val & ~S3C64XX_SPI_INT_RX_FIFORDY_EN),\n\t\t\t\tsdd->regs + S3C64XX_SPI_INT_EN);\n\t}\n\n\t \n\twritel(clr, sdd->regs + S3C64XX_SPI_PENDING_CLR);\n\twritel(0, sdd->regs + S3C64XX_SPI_PENDING_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void s3c64xx_spi_hwinit(struct s3c64xx_spi_driver_data *sdd)\n{\n\tstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\n\tvoid __iomem *regs = sdd->regs;\n\tunsigned int val;\n\n\tsdd->cur_speed = 0;\n\n\tif (sci->no_cs)\n\t\twritel(0, sdd->regs + S3C64XX_SPI_CS_REG);\n\telse if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))\n\t\twritel(S3C64XX_SPI_CS_SIG_INACT, sdd->regs + S3C64XX_SPI_CS_REG);\n\n\t \n\twritel(0, regs + S3C64XX_SPI_INT_EN);\n\n\tif (!sdd->port_conf->clk_from_cmu)\n\t\twritel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,\n\t\t\t\tregs + S3C64XX_SPI_CLK_CFG);\n\twritel(0, regs + S3C64XX_SPI_MODE_CFG);\n\twritel(0, regs + S3C64XX_SPI_PACKET_CNT);\n\n\t \n\tval = S3C64XX_SPI_PND_RX_OVERRUN_CLR |\n\t\tS3C64XX_SPI_PND_RX_UNDERRUN_CLR |\n\t\tS3C64XX_SPI_PND_TX_OVERRUN_CLR |\n\t\tS3C64XX_SPI_PND_TX_UNDERRUN_CLR;\n\twritel(val, regs + S3C64XX_SPI_PENDING_CLR);\n\twritel(0, regs + S3C64XX_SPI_PENDING_CLR);\n\n\twritel(0, regs + S3C64XX_SPI_SWAP_CFG);\n\n\tval = readl(regs + S3C64XX_SPI_MODE_CFG);\n\tval &= ~S3C64XX_SPI_MODE_4BURST;\n\tval &= ~(S3C64XX_SPI_MAX_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\n\tval |= (S3C64XX_SPI_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\n\twritel(val, regs + S3C64XX_SPI_MODE_CFG);\n\n\ts3c64xx_flush_fifo(sdd);\n}\n\n#ifdef CONFIG_OF\nstatic struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)\n{\n\tstruct s3c64xx_spi_info *sci;\n\tu32 temp;\n\n\tsci = devm_kzalloc(dev, sizeof(*sci), GFP_KERNEL);\n\tif (!sci)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (of_property_read_u32(dev->of_node, \"samsung,spi-src-clk\", &temp)) {\n\t\tdev_warn(dev, \"spi bus clock parent not specified, using clock at index 0 as parent\\n\");\n\t\tsci->src_clk_nr = 0;\n\t} else {\n\t\tsci->src_clk_nr = temp;\n\t}\n\n\tif (of_property_read_u32(dev->of_node, \"num-cs\", &temp)) {\n\t\tdev_warn(dev, \"number of chip select lines not specified, assuming 1 chip select line\\n\");\n\t\tsci->num_cs = 1;\n\t} else {\n\t\tsci->num_cs = temp;\n\t}\n\n\tsci->no_cs = of_property_read_bool(dev->of_node, \"no-cs-readback\");\n\tsci->polling = !of_property_present(dev->of_node, \"dmas\");\n\n\treturn sci;\n}\n#else\nstatic struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)\n{\n\treturn dev_get_platdata(dev);\n}\n#endif\n\nstatic inline const struct s3c64xx_spi_port_config *s3c64xx_spi_get_port_config(\n\t\t\t\t\t\tstruct platform_device *pdev)\n{\n#ifdef CONFIG_OF\n\tif (pdev->dev.of_node)\n\t\treturn of_device_get_match_data(&pdev->dev);\n#endif\n\treturn (const struct s3c64xx_spi_port_config *)platform_get_device_id(pdev)->driver_data;\n}\n\nstatic int s3c64xx_spi_probe(struct platform_device *pdev)\n{\n\tstruct resource\t*mem_res;\n\tstruct s3c64xx_spi_driver_data *sdd;\n\tstruct s3c64xx_spi_info *sci = dev_get_platdata(&pdev->dev);\n\tstruct spi_controller *host;\n\tint ret, irq;\n\tchar clk_name[16];\n\n\tif (!sci && pdev->dev.of_node) {\n\t\tsci = s3c64xx_spi_parse_dt(&pdev->dev);\n\t\tif (IS_ERR(sci))\n\t\t\treturn PTR_ERR(sci);\n\t}\n\n\tif (!sci)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV,\n\t\t\t\t     \"Platform_data missing!\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(*sdd));\n\tif (!host)\n\t\treturn dev_err_probe(&pdev->dev, -ENOMEM,\n\t\t\t\t     \"Unable to allocate SPI Host\\n\");\n\n\tplatform_set_drvdata(pdev, host);\n\n\tsdd = spi_controller_get_devdata(host);\n\tsdd->port_conf = s3c64xx_spi_get_port_config(pdev);\n\tsdd->host = host;\n\tsdd->cntrlr_info = sci;\n\tsdd->pdev = pdev;\n\tif (pdev->dev.of_node) {\n\t\tret = of_alias_get_id(pdev->dev.of_node, \"spi\");\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"Failed to get alias id\\n\");\n\t\tsdd->port_id = ret;\n\t} else {\n\t\tsdd->port_id = pdev->id;\n\t}\n\n\tsdd->cur_bpw = 8;\n\n\tsdd->tx_dma.direction = DMA_MEM_TO_DEV;\n\tsdd->rx_dma.direction = DMA_DEV_TO_MEM;\n\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = sdd->port_id;\n\thost->setup = s3c64xx_spi_setup;\n\thost->cleanup = s3c64xx_spi_cleanup;\n\thost->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;\n\thost->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;\n\thost->prepare_message = s3c64xx_spi_prepare_message;\n\thost->transfer_one = s3c64xx_spi_transfer_one;\n\thost->max_transfer_size = s3c64xx_spi_max_transfer_size;\n\thost->num_chipselect = sci->num_cs;\n\thost->use_gpio_descriptors = true;\n\thost->dma_alignment = 8;\n\thost->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |\n\t\t\t\t   SPI_BPW_MASK(8);\n\t \n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tif (sdd->port_conf->has_loopback)\n\t\thost->mode_bits |= SPI_LOOP;\n\thost->auto_runtime_pm = true;\n\tif (!is_polling(sdd))\n\t\thost->can_dma = s3c64xx_spi_can_dma;\n\n\tsdd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);\n\tif (IS_ERR(sdd->regs))\n\t\treturn PTR_ERR(sdd->regs);\n\tsdd->sfr_start = mem_res->start;\n\n\tif (sci->cfg_gpio && sci->cfg_gpio())\n\t\treturn dev_err_probe(&pdev->dev, -EBUSY,\n\t\t\t\t     \"Unable to config gpio\\n\");\n\n\t \n\tsdd->clk = devm_clk_get_enabled(&pdev->dev, \"spi\");\n\tif (IS_ERR(sdd->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sdd->clk),\n\t\t\t\t     \"Unable to acquire clock 'spi'\\n\");\n\n\tsprintf(clk_name, \"spi_busclk%d\", sci->src_clk_nr);\n\tsdd->src_clk = devm_clk_get_enabled(&pdev->dev, clk_name);\n\tif (IS_ERR(sdd->src_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sdd->src_clk),\n\t\t\t\t     \"Unable to acquire clock '%s'\\n\",\n\t\t\t\t     clk_name);\n\n\tif (sdd->port_conf->clk_ioclk) {\n\t\tsdd->ioclk = devm_clk_get_enabled(&pdev->dev, \"spi_ioclk\");\n\t\tif (IS_ERR(sdd->ioclk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sdd->ioclk),\n\t\t\t\t\t     \"Unable to acquire 'ioclk'\\n\");\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\ts3c64xx_spi_hwinit(sdd);\n\n\tspin_lock_init(&sdd->lock);\n\tinit_completion(&sdd->xfer_completion);\n\n\tret = devm_request_irq(&pdev->dev, irq, s3c64xx_spi_irq, 0,\n\t\t\t\t\"spi-s3c64xx\", sdd);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err_pm_put;\n\t}\n\n\twritel(S3C64XX_SPI_INT_RX_OVERRUN_EN | S3C64XX_SPI_INT_RX_UNDERRUN_EN |\n\t       S3C64XX_SPI_INT_TX_OVERRUN_EN | S3C64XX_SPI_INT_TX_UNDERRUN_EN,\n\t       sdd->regs + S3C64XX_SPI_INT_EN);\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"cannot register SPI host: %d\\n\", ret);\n\t\tgoto err_pm_put;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Samsung SoC SPI Driver loaded for Bus SPI-%d with %d Targets attached\\n\",\n\t\t\t\t\tsdd->port_id, host->num_chipselect);\n\tdev_dbg(&pdev->dev, \"\\tIOmem=[%pR]\\tFIFO %dbytes\\n\",\n\t\t\t\t\tmem_res, (FIFO_LVL_MASK(sdd) >> 1) + 1);\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void s3c64xx_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\twritel(0, sdd->regs + S3C64XX_SPI_INT_EN);\n\n\tif (!is_polling(sdd)) {\n\t\tdma_release_channel(sdd->rx_dma.ch);\n\t\tdma_release_channel(sdd->tx_dma.ch);\n\t}\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int s3c64xx_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\n\tint ret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsdd->cur_speed = 0;  \n\n\treturn 0;\n}\n\nstatic int s3c64xx_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\tstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\n\tint ret;\n\n\tif (sci->cfg_gpio)\n\t\tsci->cfg_gpio();\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn spi_controller_resume(host);\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int s3c64xx_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\n\tclk_disable_unprepare(sdd->clk);\n\tclk_disable_unprepare(sdd->src_clk);\n\tclk_disable_unprepare(sdd->ioclk);\n\n\treturn 0;\n}\n\nstatic int s3c64xx_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct s3c64xx_spi_driver_data *sdd = spi_controller_get_devdata(host);\n\tint ret;\n\n\tif (sdd->port_conf->clk_ioclk) {\n\t\tret = clk_prepare_enable(sdd->ioclk);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(sdd->src_clk);\n\tif (ret != 0)\n\t\tgoto err_disable_ioclk;\n\n\tret = clk_prepare_enable(sdd->clk);\n\tif (ret != 0)\n\t\tgoto err_disable_src_clk;\n\n\ts3c64xx_spi_hwinit(sdd);\n\n\twritel(S3C64XX_SPI_INT_RX_OVERRUN_EN | S3C64XX_SPI_INT_RX_UNDERRUN_EN |\n\t       S3C64XX_SPI_INT_TX_OVERRUN_EN | S3C64XX_SPI_INT_TX_UNDERRUN_EN,\n\t       sdd->regs + S3C64XX_SPI_INT_EN);\n\n\treturn 0;\n\nerr_disable_src_clk:\n\tclk_disable_unprepare(sdd->src_clk);\nerr_disable_ioclk:\n\tclk_disable_unprepare(sdd->ioclk);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct dev_pm_ops s3c64xx_spi_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(s3c64xx_spi_suspend, s3c64xx_spi_resume)\n\tSET_RUNTIME_PM_OPS(s3c64xx_spi_runtime_suspend,\n\t\t\t   s3c64xx_spi_runtime_resume, NULL)\n};\n\nstatic const struct s3c64xx_spi_port_config s3c2443_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x7f },\n\t.rx_lvl_offset\t= 13,\n\t.tx_st_done\t= 21,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n};\n\nstatic const struct s3c64xx_spi_port_config s3c6410_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x7f, 0x7F },\n\t.rx_lvl_offset\t= 13,\n\t.tx_st_done\t= 21,\n\t.clk_div\t= 2,\n};\n\nstatic const struct s3c64xx_spi_port_config s5pv210_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x1ff, 0x7F },\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n};\n\nstatic const struct s3c64xx_spi_port_config exynos4_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x1ff, 0x7F, 0x7F },\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n\t.clk_from_cmu\t= true,\n\t.quirks\t\t= S3C64XX_SPI_QUIRK_CS_AUTO,\n};\n\nstatic const struct s3c64xx_spi_port_config exynos7_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x1ff, 0x7F, 0x7F, 0x7F, 0x7F, 0x1ff},\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n\t.clk_from_cmu\t= true,\n\t.quirks\t\t= S3C64XX_SPI_QUIRK_CS_AUTO,\n};\n\nstatic const struct s3c64xx_spi_port_config exynos5433_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x1ff, 0x7f, 0x7f, 0x7f, 0x7f, 0x1ff},\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n\t.clk_from_cmu\t= true,\n\t.clk_ioclk\t= true,\n\t.quirks\t\t= S3C64XX_SPI_QUIRK_CS_AUTO,\n};\n\nstatic const struct s3c64xx_spi_port_config exynosautov9_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x1ff, 0x1ff, 0x7f, 0x7f, 0x7f, 0x7f, 0x1ff, 0x7f,\n\t\t\t    0x7f, 0x7f, 0x7f, 0x7f},\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 4,\n\t.high_speed\t= true,\n\t.clk_from_cmu\t= true,\n\t.clk_ioclk\t= true,\n\t.has_loopback\t= true,\n\t.quirks\t\t= S3C64XX_SPI_QUIRK_CS_AUTO,\n};\n\nstatic const struct s3c64xx_spi_port_config fsd_spi_port_config = {\n\t.fifo_lvl_mask\t= { 0x7f, 0x7f, 0x7f, 0x7f, 0x7f},\n\t.rx_lvl_offset\t= 15,\n\t.tx_st_done\t= 25,\n\t.clk_div\t= 2,\n\t.high_speed\t= true,\n\t.clk_from_cmu\t= true,\n\t.clk_ioclk\t= false,\n\t.quirks\t\t= S3C64XX_SPI_QUIRK_CS_AUTO,\n};\n\nstatic const struct platform_device_id s3c64xx_spi_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c2443-spi\",\n\t\t.driver_data\t= (kernel_ulong_t)&s3c2443_spi_port_config,\n\t}, {\n\t\t.name\t\t= \"s3c6410-spi\",\n\t\t.driver_data\t= (kernel_ulong_t)&s3c6410_spi_port_config,\n\t},\n\t{ },\n};\n\nstatic const struct of_device_id s3c64xx_spi_dt_match[] = {\n\t{ .compatible = \"samsung,s3c2443-spi\",\n\t\t\t.data = (void *)&s3c2443_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,s3c6410-spi\",\n\t\t\t.data = (void *)&s3c6410_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,s5pv210-spi\",\n\t\t\t.data = (void *)&s5pv210_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,exynos4210-spi\",\n\t\t\t.data = (void *)&exynos4_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,exynos7-spi\",\n\t\t\t.data = (void *)&exynos7_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,exynos5433-spi\",\n\t\t\t.data = (void *)&exynos5433_spi_port_config,\n\t},\n\t{ .compatible = \"samsung,exynosautov9-spi\",\n\t\t\t.data = (void *)&exynosautov9_spi_port_config,\n\t},\n\t{ .compatible = \"tesla,fsd-spi\",\n\t\t\t.data = (void *)&fsd_spi_port_config,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, s3c64xx_spi_dt_match);\n\nstatic struct platform_driver s3c64xx_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"s3c64xx-spi\",\n\t\t.pm = &s3c64xx_spi_pm,\n\t\t.of_match_table = of_match_ptr(s3c64xx_spi_dt_match),\n\t},\n\t.probe = s3c64xx_spi_probe,\n\t.remove_new = s3c64xx_spi_remove,\n\t.id_table = s3c64xx_spi_driver_ids,\n};\nMODULE_ALIAS(\"platform:s3c64xx-spi\");\n\nmodule_platform_driver(s3c64xx_spi_driver);\n\nMODULE_AUTHOR(\"Jaswinder Singh <jassi.brar@samsung.com>\");\nMODULE_DESCRIPTION(\"S3C64XX SPI Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}