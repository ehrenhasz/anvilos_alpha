{
  "module_name": "spi-loopback-test.c",
  "hash_id": "4fdd75b8e8a0edbc1caf4267552780c095de0d88da5e102bc2be0b019e727a36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-loopback-test.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/list.h>\n#include <linux/list_sort.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/vmalloc.h>\n#include <linux/spi/spi.h>\n\n#include \"spi-test.h\"\n\n \nstatic int simulate_only;\nmodule_param(simulate_only, int, 0);\nMODULE_PARM_DESC(simulate_only, \"if not 0 do not execute the spi message\");\n\n \nstatic int dump_messages;\nmodule_param(dump_messages, int, 0);\nMODULE_PARM_DESC(dump_messages,\n\t\t \"=1 dump the basic spi_message_structure, \" \\\n\t\t \"=2 dump the spi_message_structure including data, \" \\\n\t\t \"=3 dump the spi_message structure before and after execution\");\n \nstatic int loopback;\nmodule_param(loopback, int, 0);\nMODULE_PARM_DESC(loopback,\n\t\t \"if set enable loopback mode, where the rx_buf \"\t\\\n\t\t \"is checked to match tx_buf after the spi_message \"\t\\\n\t\t \"is executed\");\n\nstatic int loop_req;\nmodule_param(loop_req, int, 0);\nMODULE_PARM_DESC(loop_req,\n\t\t \"if set controller will be asked to enable test loop mode. \" \\\n\t\t \"If controller supported it, MISO and MOSI will be connected\");\n\nstatic int no_cs;\nmodule_param(no_cs, int, 0);\nMODULE_PARM_DESC(no_cs,\n\t\t \"if set Chip Select (CS) will not be used\");\n\n \nstatic int run_only_iter_len = -1;\nmodule_param(run_only_iter_len, int, 0);\nMODULE_PARM_DESC(run_only_iter_len,\n\t\t \"only run tests for a length of this number in iterate_len list\");\n\n \nstatic int run_only_test = -1;\nmodule_param(run_only_test, int, 0);\nMODULE_PARM_DESC(run_only_test,\n\t\t \"only run the test with this number (0-based !)\");\n\n \nstatic int use_vmalloc;\nmodule_param(use_vmalloc, int, 0644);\nMODULE_PARM_DESC(use_vmalloc,\n\t\t \"use vmalloc'ed buffers instead of kmalloc'ed\");\n\n \nstatic int check_ranges = 1;\nmodule_param(check_ranges, int, 0644);\nMODULE_PARM_DESC(check_ranges,\n\t\t \"checks rx_buffer pattern are valid\");\n\nstatic unsigned int delay_ms = 100;\nmodule_param(delay_ms, uint, 0644);\nMODULE_PARM_DESC(delay_ms,\n\t\t \"delay between tests, in milliseconds (default: 100)\");\n\n \nstatic struct spi_test spi_tests[] = {\n\t{\n\t\t.description\t= \"tx/rx-transfer - start of page\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_rx_align = ITERATE_ALIGN,\n\t\t.transfer_count = 1,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"tx/rx-transfer - crossing PAGE_SIZE\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_rx_align = ITERATE_ALIGN,\n\t\t.transfer_count = 1,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(PAGE_SIZE - 4),\n\t\t\t\t.rx_buf = RX(PAGE_SIZE - 4),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"tx-transfer - only\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.transfer_count = 1,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"rx-transfer - only\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_rx_align = ITERATE_ALIGN,\n\t\t.transfer_count = 1,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx-transfers - alter both\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0) | BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.tx_buf = TX(SPI_TEST_MAX_SIZE_HALF),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx-transfers - alter first\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(64),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx-transfers - alter second\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.len = 16,\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.tx_buf = TX(64),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two transfers tx then rx - alter both\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0) | BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two transfers tx then rx - alter tx\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two transfers tx then rx - alter rx\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx+rx transfers - alter both\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0) | BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.tx_buf = TX(SPI_TEST_MAX_SIZE_HALF),\n\t\t\t\t.rx_buf = RX(SPI_TEST_MAX_SIZE_HALF),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx+rx transfers - alter first\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(0),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.tx_buf = TX(1024),\n\t\t\t\t.rx_buf = RX(1024),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t \n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx+rx transfers - alter second\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_tx_align = ITERATE_ALIGN,\n\t\t.iterate_transfer_mask = BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.tx_buf = TX(1024),\n\t\t\t\t.rx_buf = RX(1024),\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"two tx+rx transfers - delay after transfer\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t.iterate_len    = { ITERATE_MAX_LEN },\n\t\t.iterate_transfer_mask = BIT(0) | BIT(1),\n\t\t.transfer_count = 2,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t\t.delay = {\n\t\t\t\t\t.value = 1000,\n\t\t\t\t\t.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t\t.delay = {\n\t\t\t\t\t.value = 1000,\n\t\t\t\t\t.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.description\t= \"three tx+rx transfers with overlapping cache lines\",\n\t\t.fill_option\t= FILL_COUNT_8,\n\t\t \n\t\t.iterate_len    = { 512, -1 },\n\t\t.iterate_transfer_mask = BIT(1),\n\t\t.transfer_count = 3,\n\t\t.transfers\t\t= {\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.tx_buf = TX(0),\n\t\t\t\t.rx_buf = RX(0),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.tx_buf = TX(1),\n\t\t\t\t.rx_buf = RX(1),\n\t\t\t},\n\t\t\t{\n\t\t\t\t.len = 1,\n\t\t\t\t.tx_buf = TX(513),\n\t\t\t\t.rx_buf = RX(513),\n\t\t\t},\n\t\t},\n\t},\n\n\t{   }\n};\n\nstatic int spi_loopback_test_probe(struct spi_device *spi)\n{\n\tint ret;\n\n\tif (loop_req || no_cs) {\n\t\tspi->mode |= loop_req ? SPI_LOOP : 0;\n\t\tspi->mode |= no_cs ? SPI_NO_CS : 0;\n\t\tret = spi_setup(spi);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"SPI setup with SPI_LOOP or SPI_NO_CS failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_info(&spi->dev, \"Executing spi-loopback-tests\\n\");\n\n\tret = spi_test_run_tests(spi, spi_tests);\n\n\tdev_info(&spi->dev, \"Finished spi-loopback-tests with return: %i\\n\",\n\t\t ret);\n\n\treturn ret;\n}\n\n \nstatic struct of_device_id spi_loopback_test_of_match[] = {\n\t{ .compatible\t= \"linux,spi-loopback-test\", },\n\t{ }\n};\n\n \nmodule_param_string(compatible, spi_loopback_test_of_match[0].compatible,\n\t\t    sizeof(spi_loopback_test_of_match[0].compatible),\n\t\t    0000);\n\nMODULE_DEVICE_TABLE(of, spi_loopback_test_of_match);\n\nstatic struct spi_driver spi_loopback_test_driver = {\n\t.driver = {\n\t\t.name = \"spi-loopback-test\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = spi_loopback_test_of_match,\n\t},\n\t.probe = spi_loopback_test_probe,\n};\n\nmodule_spi_driver(spi_loopback_test_driver);\n\nMODULE_AUTHOR(\"Martin Sperl <kernel@martin.sperl.org>\");\nMODULE_DESCRIPTION(\"test spi_driver to check core functionality\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \n\n#define RANGE_CHECK(ptr, plen, start, slen) \\\n\t((ptr >= start) && (ptr + plen <= start + slen))\n\n \n#define SPI_TEST_MAX_SIZE_PLUS (SPI_TEST_MAX_SIZE + PAGE_SIZE)\n\nstatic void spi_test_print_hex_dump(char *pre, const void *ptr, size_t len)\n{\n\t \n\tif (len < 1024) {\n\t\tprint_hex_dump(KERN_INFO, pre,\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       ptr, len, 0);\n\t\treturn;\n\t}\n\t \n\tprint_hex_dump(KERN_INFO, pre,\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       ptr, 512, 0);\n\t \n\tpr_info(\"%s truncated - continuing at offset %04zx\\n\",\n\t\tpre, len - 512);\n\tprint_hex_dump(KERN_INFO, pre,\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       ptr + (len - 512), 512, 0);\n}\n\nstatic void spi_test_dump_message(struct spi_device *spi,\n\t\t\t\t  struct spi_message *msg,\n\t\t\t\t  bool dump_data)\n{\n\tstruct spi_transfer *xfer;\n\tint i;\n\tu8 b;\n\n\tdev_info(&spi->dev, \"  spi_msg@%pK\\n\", msg);\n\tif (msg->status)\n\t\tdev_info(&spi->dev, \"    status:        %i\\n\",\n\t\t\t msg->status);\n\tdev_info(&spi->dev, \"    frame_length:  %i\\n\",\n\t\t msg->frame_length);\n\tdev_info(&spi->dev, \"    actual_length: %i\\n\",\n\t\t msg->actual_length);\n\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tdev_info(&spi->dev, \"    spi_transfer@%pK\\n\", xfer);\n\t\tdev_info(&spi->dev, \"      len:    %i\\n\", xfer->len);\n\t\tdev_info(&spi->dev, \"      tx_buf: %pK\\n\", xfer->tx_buf);\n\t\tif (dump_data && xfer->tx_buf)\n\t\t\tspi_test_print_hex_dump(\"          TX: \",\n\t\t\t\t\t\txfer->tx_buf,\n\t\t\t\t\t\txfer->len);\n\n\t\tdev_info(&spi->dev, \"      rx_buf: %pK\\n\", xfer->rx_buf);\n\t\tif (dump_data && xfer->rx_buf)\n\t\t\tspi_test_print_hex_dump(\"          RX: \",\n\t\t\t\t\t\txfer->rx_buf,\n\t\t\t\t\t\txfer->len);\n\t\t \n\t\tif (xfer->rx_buf) {\n\t\t\tfor (i = 0 ; i < xfer->len ; i++) {\n\t\t\t\tb = ((u8 *)xfer->rx_buf)[xfer->len - 1 - i];\n\t\t\t\tif (b != SPI_TEST_PATTERN_UNWRITTEN)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tdev_info(&spi->dev,\n\t\t\t\t\t \"      rx_buf filled with %02x starts at offset: %i\\n\",\n\t\t\t\t\t SPI_TEST_PATTERN_UNWRITTEN,\n\t\t\t\t\t xfer->len - i);\n\t\t}\n\t}\n}\n\nstruct rx_ranges {\n\tstruct list_head list;\n\tu8 *start;\n\tu8 *end;\n};\n\nstatic int rx_ranges_cmp(void *priv, const struct list_head *a,\n\t\t\t const struct list_head *b)\n{\n\tstruct rx_ranges *rx_a = list_entry(a, struct rx_ranges, list);\n\tstruct rx_ranges *rx_b = list_entry(b, struct rx_ranges, list);\n\n\tif (rx_a->start > rx_b->start)\n\t\treturn 1;\n\tif (rx_a->start < rx_b->start)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int spi_check_rx_ranges(struct spi_device *spi,\n\t\t\t       struct spi_message *msg,\n\t\t\t       void *rx)\n{\n\tstruct spi_transfer *xfer;\n\tstruct rx_ranges ranges[SPI_TEST_MAX_TRANSFERS], *r;\n\tint i = 0;\n\tLIST_HEAD(ranges_list);\n\tu8 *addr;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\t \n\t\tif (!xfer->rx_buf)\n\t\t\tcontinue;\n\t\t \n\t\tif (RANGE_CHECK(xfer->rx_buf, xfer->len,\n\t\t\t\trx, SPI_TEST_MAX_SIZE_PLUS)) {\n\t\t\tranges[i].start = xfer->rx_buf;\n\t\t\tranges[i].end = xfer->rx_buf + xfer->len;\n\t\t\tlist_add(&ranges[i].list, &ranges_list);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tif (!i)\n\t\treturn 0;\n\n\t \n\tlist_sort(NULL, &ranges_list, rx_ranges_cmp);\n\n\t \n\tfor (addr = rx; addr < (u8 *)rx + SPI_TEST_MAX_SIZE_PLUS; addr++) {\n\t\t \n\t\tif (*addr == SPI_TEST_PATTERN_DO_NOT_WRITE)\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(r, &ranges_list, list) {\n\t\t\t \n\t\t\tif ((addr >= r->start) && (addr < r->end))\n\t\t\t\taddr = r->end;\n\t\t}\n\t\t \n\t\tif (*addr == SPI_TEST_PATTERN_DO_NOT_WRITE)\n\t\t\tcontinue;\n\n\t\t \n\t\t \n\t\tdev_err(&spi->dev,\n\t\t\t\"loopback strangeness - rx changed outside of allowed range at: %pK\\n\",\n\t\t\taddr);\n\t\t \n\t\tret = -ERANGE;\n\t}\n\n\treturn ret;\n}\n\nstatic int spi_test_check_elapsed_time(struct spi_device *spi,\n\t\t\t\t       struct spi_test *test)\n{\n\tint i;\n\tunsigned long long estimated_time = 0;\n\tunsigned long long delay_usecs = 0;\n\n\tfor (i = 0; i < test->transfer_count; i++) {\n\t\tstruct spi_transfer *xfer = test->transfers + i;\n\t\tunsigned long long nbits = (unsigned long long)BITS_PER_BYTE *\n\t\t\t\t\t   xfer->len;\n\n\t\tdelay_usecs += xfer->delay.value;\n\t\tif (!xfer->speed_hz)\n\t\t\tcontinue;\n\t\testimated_time += div_u64(nbits * NSEC_PER_SEC, xfer->speed_hz);\n\t}\n\n\testimated_time += delay_usecs * NSEC_PER_USEC;\n\tif (test->elapsed_time < estimated_time) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"elapsed time %lld ns is shorter than minimum estimated time %lld ns\\n\",\n\t\t\ttest->elapsed_time, estimated_time);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_test_check_loopback_result(struct spi_device *spi,\n\t\t\t\t\t  struct spi_message *msg,\n\t\t\t\t\t  void *tx, void *rx)\n{\n\tstruct spi_transfer *xfer;\n\tu8 rxb, txb;\n\tsize_t i;\n\tint ret;\n\n\t \n\tif (check_ranges) {\n\t\tret = spi_check_rx_ranges(spi, msg, rx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!loopback)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\t \n\t\tif (!xfer->len || !xfer->rx_buf)\n\t\t\tcontinue;\n\t\t \n\t\tif (xfer->tx_buf) {\n\t\t\tfor (i = 0; i < xfer->len; i++) {\n\t\t\t\ttxb = ((u8 *)xfer->tx_buf)[i];\n\t\t\t\trxb = ((u8 *)xfer->rx_buf)[i];\n\t\t\t\tif (txb != rxb)\n\t\t\t\t\tgoto mismatch_error;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttxb = ((u8 *)xfer->rx_buf)[0];\n\t\t\t \n\t\t\tif (!((txb == 0) || (txb == 0xff))) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"loopback strangeness - we expect 0x00 or 0xff, but not 0x%02x\\n\",\n\t\t\t\t\ttxb);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tfor (i = 1; i < xfer->len; i++) {\n\t\t\t\trxb = ((u8 *)xfer->rx_buf)[i];\n\t\t\t\tif (rxb != txb)\n\t\t\t\t\tgoto mismatch_error;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nmismatch_error:\n\tdev_err(&spi->dev,\n\t\t\"loopback strangeness - transfer mismatch on byte %04zx - expected 0x%02x, but got 0x%02x\\n\",\n\t\ti, txb, rxb);\n\n\treturn -EINVAL;\n}\n\nstatic int spi_test_translate(struct spi_device *spi,\n\t\t\t      void **ptr, size_t len,\n\t\t\t      void *tx, void *rx)\n{\n\tsize_t off;\n\n\t \n\tif (!*ptr)\n\t\treturn 0;\n\n\t \n\tif (((size_t)*ptr) & SPI_TEST_MAX_SIZE_HALF)\n\t\t \n\t\t*ptr += (SPI_TEST_MAX_SIZE_PLUS / 2) -\n\t\t\tSPI_TEST_MAX_SIZE_HALF;\n\n\t \n\tif (RANGE_CHECK(*ptr, len,  RX(0), SPI_TEST_MAX_SIZE_PLUS)) {\n\t\toff = *ptr - RX(0);\n\t\t*ptr = rx + off;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (RANGE_CHECK(*ptr, len,  TX(0), SPI_TEST_MAX_SIZE_PLUS)) {\n\t\toff = *ptr - TX(0);\n\t\t*ptr = tx + off;\n\n\t\treturn 0;\n\t}\n\n\tdev_err(&spi->dev,\n\t\t\"PointerRange [%pK:%pK[ not in range [%pK:%pK[ or [%pK:%pK[\\n\",\n\t\t*ptr, *ptr + len,\n\t\tRX(0), RX(SPI_TEST_MAX_SIZE),\n\t\tTX(0), TX(SPI_TEST_MAX_SIZE));\n\n\treturn -EINVAL;\n}\n\nstatic int spi_test_fill_pattern(struct spi_device *spi,\n\t\t\t\t struct spi_test *test)\n{\n\tstruct spi_transfer *xfers = test->transfers;\n\tu8 *tx_buf;\n\tsize_t count = 0;\n\tint i, j;\n\n#ifdef __BIG_ENDIAN\n#define GET_VALUE_BYTE(value, index, bytes) \\\n\t(value >> (8 * (bytes - 1 - count % bytes)))\n#else\n#define GET_VALUE_BYTE(value, index, bytes) \\\n\t(value >> (8 * (count % bytes)))\n#endif\n\n\t \n\tfor (i = 0; i < test->transfer_count; i++) {\n\t\t \n\t\tif (xfers[i].rx_buf)\n\t\t\tmemset(xfers[i].rx_buf, SPI_TEST_PATTERN_UNWRITTEN,\n\t\t\t       xfers[i].len);\n\t\t \n\t\ttx_buf = (u8 *)xfers[i].tx_buf;\n\t\tif (!tx_buf)\n\t\t\tcontinue;\n\t\t \n\t\tfor (j = 0; j < xfers[i].len; j++, tx_buf++, count++) {\n\t\t\t \n\t\t\tswitch (test->fill_option) {\n\t\t\tcase FILL_MEMSET_8:\n\t\t\t\t*tx_buf = test->fill_pattern;\n\t\t\t\tbreak;\n\t\t\tcase FILL_MEMSET_16:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(test->fill_pattern,\n\t\t\t\t\t\t\t count, 2);\n\t\t\t\tbreak;\n\t\t\tcase FILL_MEMSET_24:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(test->fill_pattern,\n\t\t\t\t\t\t\t count, 3);\n\t\t\t\tbreak;\n\t\t\tcase FILL_MEMSET_32:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(test->fill_pattern,\n\t\t\t\t\t\t\t count, 4);\n\t\t\t\tbreak;\n\t\t\tcase FILL_COUNT_8:\n\t\t\t\t*tx_buf = count;\n\t\t\t\tbreak;\n\t\t\tcase FILL_COUNT_16:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(count, count, 2);\n\t\t\t\tbreak;\n\t\t\tcase FILL_COUNT_24:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(count, count, 3);\n\t\t\t\tbreak;\n\t\t\tcase FILL_COUNT_32:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(count, count, 4);\n\t\t\t\tbreak;\n\t\t\tcase FILL_TRANSFER_BYTE_8:\n\t\t\t\t*tx_buf = j;\n\t\t\t\tbreak;\n\t\t\tcase FILL_TRANSFER_BYTE_16:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(j, j, 2);\n\t\t\t\tbreak;\n\t\t\tcase FILL_TRANSFER_BYTE_24:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(j, j, 3);\n\t\t\t\tbreak;\n\t\t\tcase FILL_TRANSFER_BYTE_32:\n\t\t\t\t*tx_buf = GET_VALUE_BYTE(j, j, 4);\n\t\t\t\tbreak;\n\t\t\tcase FILL_TRANSFER_NUM:\n\t\t\t\t*tx_buf = i;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"unsupported fill_option: %i\\n\",\n\t\t\t\t\ttest->fill_option);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _spi_test_run_iter(struct spi_device *spi,\n\t\t\t      struct spi_test *test,\n\t\t\t      void *tx, void *rx)\n{\n\tstruct spi_message *msg = &test->msg;\n\tstruct spi_transfer *x;\n\tint i, ret;\n\n\t \n\tspi_message_init_no_memset(msg);\n\n\t \n\tmemset(rx, SPI_TEST_PATTERN_DO_NOT_WRITE, SPI_TEST_MAX_SIZE_PLUS);\n\n\t \n\tfor (i = 0; i < test->transfer_count; i++) {\n\t\tx = &test->transfers[i];\n\n\t\t \n\t\tret = spi_test_translate(spi, (void **)&x->tx_buf, x->len,\n\t\t\t\t\t (void *)tx, rx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = spi_test_translate(spi, &x->rx_buf, x->len,\n\t\t\t\t\t (void *)tx, rx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tspi_message_add_tail(x, msg);\n\t}\n\n\t \n\tret = spi_test_fill_pattern(spi, test);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (test->execute_msg)\n\t\tret = test->execute_msg(spi, test, tx, rx);\n\telse\n\t\tret = spi_test_execute_msg(spi, test, tx, rx);\n\n\t \n\tif (ret == test->expected_return)\n\t\treturn 0;\n\n\tdev_err(&spi->dev,\n\t\t\"test failed - test returned %i, but we expect %i\\n\",\n\t\tret, test->expected_return);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn -EFAULT;\n}\n\nstatic int spi_test_run_iter(struct spi_device *spi,\n\t\t\t     const struct spi_test *testtemplate,\n\t\t\t     void *tx, void *rx,\n\t\t\t     size_t len,\n\t\t\t     size_t tx_off,\n\t\t\t     size_t rx_off\n\t)\n{\n\tstruct spi_test test;\n\tint i, tx_count, rx_count;\n\n\t \n\tmemcpy(&test, testtemplate, sizeof(test));\n\n\t \n\tif (!(test.iterate_transfer_mask & (BIT(test.transfer_count) - 1)))\n\t\ttest.iterate_transfer_mask = 1;\n\n\t \n\trx_count = tx_count = 0;\n\tfor (i = 0; i < test.transfer_count; i++) {\n\t\tif (test.transfers[i].tx_buf)\n\t\t\ttx_count++;\n\t\tif (test.transfers[i].rx_buf)\n\t\t\trx_count++;\n\t}\n\n\t \n\tif (tx_off && (!tx_count)) {\n\t\tdev_warn_once(&spi->dev,\n\t\t\t      \"%s: iterate_tx_off configured with tx_buf==NULL - ignoring\\n\",\n\t\t\t      test.description);\n\t\treturn 0;\n\t}\n\tif (rx_off && (!rx_count)) {\n\t\tdev_warn_once(&spi->dev,\n\t\t\t      \"%s: iterate_rx_off configured with rx_buf==NULL - ignoring\\n\",\n\t\t\t      test.description);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(len || tx_off || rx_off)) {\n\t\tdev_info(&spi->dev, \"Running test %s\\n\", test.description);\n\t} else {\n\t\tdev_info(&spi->dev,\n\t\t\t \"  with iteration values: len = %zu, tx_off = %zu, rx_off = %zu\\n\",\n\t\t\t len, tx_off, rx_off);\n\t}\n\n\t \n\tfor (i = 0; i < test.transfer_count; i++) {\n\t\t \n\t\tif (!(test.iterate_transfer_mask & BIT(i)))\n\t\t\tcontinue;\n\t\ttest.transfers[i].len = len;\n\t\tif (test.transfers[i].tx_buf)\n\t\t\ttest.transfers[i].tx_buf += tx_off;\n\t\tif (test.transfers[i].rx_buf)\n\t\t\ttest.transfers[i].rx_buf += rx_off;\n\t}\n\n\t \n\treturn _spi_test_run_iter(spi, &test, tx, rx);\n}\n\n \nint spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,\n\t\t\t void *tx, void *rx)\n{\n\tstruct spi_message *msg = &test->msg;\n\tint ret = 0;\n\tint i;\n\n\t \n\tif (!simulate_only) {\n\t\tktime_t start;\n\n\t\t \n\t\tif (dump_messages == 3)\n\t\t\tspi_test_dump_message(spi, msg, true);\n\n\t\tstart = ktime_get();\n\t\t \n\t\tret = spi_sync(spi, msg);\n\t\ttest->elapsed_time = ktime_to_ns(ktime_sub(ktime_get(), start));\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tdev_info(&spi->dev,\n\t\t\t\t \"spi-message timed out - rerunning...\\n\");\n\t\t\t \n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tschedule();\n\t\t\tret = spi_sync(spi, msg);\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed to execute spi_message: %i\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (msg->frame_length != msg->actual_length) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"actual length differs from expected\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tret = spi_test_check_loopback_result(spi, msg, tx, rx);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = spi_test_check_elapsed_time(spi, test);\n\t}\n\n\t \nexit:\n\tif (dump_messages || ret)\n\t\tspi_test_dump_message(spi, msg,\n\t\t\t\t      (dump_messages >= 2) || (ret));\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_test_execute_msg);\n\n \n\nint spi_test_run_test(struct spi_device *spi, const struct spi_test *test,\n\t\t      void *tx, void *rx)\n{\n\tint idx_len;\n\tsize_t len;\n\tsize_t tx_align, rx_align;\n\tint ret;\n\n\t \n\tif (test->transfer_count >= SPI_TEST_MAX_TRANSFERS) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: Exceeded max number of transfers with %i\\n\",\n\t\t\ttest->description, test->transfer_count);\n\t\treturn -E2BIG;\n\t}\n\n\t \n\n\t \n#define FOR_EACH_ALIGNMENT(var)\t\t\t\t\t\t\\\n\tfor (var = 0;\t\t\t\t\t\t\t\\\n\t    var < (test->iterate_##var ?\t\t\t\t\\\n\t\t\t(spi->master->dma_alignment ?\t\t\t\\\n\t\t\t spi->master->dma_alignment :\t\t\t\\\n\t\t\t test->iterate_##var) :\t\t\t\t\\\n\t\t\t1);\t\t\t\t\t\t\\\n\t    var++)\n\n\tfor (idx_len = 0; idx_len < SPI_TEST_MAX_ITERATE &&\n\t     (len = test->iterate_len[idx_len]) != -1; idx_len++) {\n\t\tif ((run_only_iter_len > -1) && len != run_only_iter_len)\n\t\t\tcontinue;\n\t\tFOR_EACH_ALIGNMENT(tx_align) {\n\t\t\tFOR_EACH_ALIGNMENT(rx_align) {\n\t\t\t\t \n\t\t\t\tret = spi_test_run_iter(spi, test,\n\t\t\t\t\t\t\ttx, rx,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\ttx_align,\n\t\t\t\t\t\t\trx_align);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_test_run_test);\n\n \n\nint spi_test_run_tests(struct spi_device *spi,\n\t\t       struct spi_test *tests)\n{\n\tchar *rx = NULL, *tx = NULL;\n\tint ret = 0, count = 0;\n\tstruct spi_test *test;\n\n\t \n\tif (use_vmalloc)\n\t\trx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);\n\telse\n\t\trx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);\n\tif (!rx)\n\t\treturn -ENOMEM;\n\n\n\tif (use_vmalloc)\n\t\ttx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);\n\telse\n\t\ttx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);\n\tif (!tx) {\n\t\tret = -ENOMEM;\n\t\tgoto err_tx;\n\t}\n\n\t \n\tfor (test = tests, count = 0; test->description[0];\n\t     test++, count++) {\n\t\t \n\t\tif ((run_only_test > -1) && (count != run_only_test))\n\t\t\tcontinue;\n\t\t \n\t\tif (test->run_test)\n\t\t\tret = test->run_test(spi, test, tx, rx);\n\t\telse\n\t\t\tret = spi_test_run_test(spi, test, tx, rx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\tif (delay_ms)\n\t\t\tmdelay(delay_ms);\n\t\tschedule();\n\t}\n\nout:\n\tkvfree(tx);\nerr_tx:\n\tkvfree(rx);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(spi_test_run_tests);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}