{
  "module_name": "spi-rspi.c",
  "hash_id": "2471ee61f18c4ff54e32d788b3e8b1b134b14e1c11330358ec2309ea6336cf32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rspi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sh_dma.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/rspi.h>\n#include <linux/spinlock.h>\n\n#define RSPI_SPCR\t\t0x00\t \n#define RSPI_SSLP\t\t0x01\t \n#define RSPI_SPPCR\t\t0x02\t \n#define RSPI_SPSR\t\t0x03\t \n#define RSPI_SPDR\t\t0x04\t \n#define RSPI_SPSCR\t\t0x08\t \n#define RSPI_SPSSR\t\t0x09\t \n#define RSPI_SPBR\t\t0x0a\t \n#define RSPI_SPDCR\t\t0x0b\t \n#define RSPI_SPCKD\t\t0x0c\t \n#define RSPI_SSLND\t\t0x0d\t \n#define RSPI_SPND\t\t0x0e\t \n#define RSPI_SPCR2\t\t0x0f\t \n#define RSPI_SPCMD0\t\t0x10\t \n#define RSPI_SPCMD1\t\t0x12\t \n#define RSPI_SPCMD2\t\t0x14\t \n#define RSPI_SPCMD3\t\t0x16\t \n#define RSPI_SPCMD4\t\t0x18\t \n#define RSPI_SPCMD5\t\t0x1a\t \n#define RSPI_SPCMD6\t\t0x1c\t \n#define RSPI_SPCMD7\t\t0x1e\t \n#define RSPI_SPCMD(i)\t\t(RSPI_SPCMD0 + (i) * 2)\n#define RSPI_NUM_SPCMD\t\t8\n#define RSPI_RZ_NUM_SPCMD\t4\n#define QSPI_NUM_SPCMD\t\t4\n\n \n#define RSPI_SPBFCR\t\t0x20\t \n#define RSPI_SPBFDR\t\t0x22\t \n\n \n#define QSPI_SPBFCR\t\t0x18\t \n#define QSPI_SPBDCR\t\t0x1a\t \n#define QSPI_SPBMUL0\t\t0x1c\t \n#define QSPI_SPBMUL1\t\t0x20\t \n#define QSPI_SPBMUL2\t\t0x24\t \n#define QSPI_SPBMUL3\t\t0x28\t \n#define QSPI_SPBMUL(i)\t\t(QSPI_SPBMUL0 + (i) * 4)\n\n \n#define SPCR_SPRIE\t\t0x80\t \n#define SPCR_SPE\t\t0x40\t \n#define SPCR_SPTIE\t\t0x20\t \n#define SPCR_SPEIE\t\t0x10\t \n#define SPCR_MSTR\t\t0x08\t \n#define SPCR_MODFEN\t\t0x04\t \n \n#define SPCR_TXMD\t\t0x02\t \n#define SPCR_SPMS\t\t0x01\t \n \n#define SPCR_WSWAP\t\t0x02\t \n#define SPCR_BSWAP\t\t0x01\t \n\n \n#define SSLP_SSLP(i)\t\tBIT(i)\t \n\n \n#define SPPCR_MOIFE\t\t0x20\t \n#define SPPCR_MOIFV\t\t0x10\t \n#define SPPCR_SPOM\t\t0x04\n#define SPPCR_SPLP2\t\t0x02\t \n#define SPPCR_SPLP\t\t0x01\t \n\n#define SPPCR_IO3FV\t\t0x04\t \n#define SPPCR_IO2FV\t\t0x04\t \n\n \n#define SPSR_SPRF\t\t0x80\t \n#define SPSR_TEND\t\t0x40\t \n#define SPSR_SPTEF\t\t0x20\t \n#define SPSR_PERF\t\t0x08\t \n#define SPSR_MODF\t\t0x04\t \n#define SPSR_IDLNF\t\t0x02\t \n#define SPSR_OVRF\t\t0x01\t \n\n \n#define SPSCR_SPSLN_MASK\t0x07\t \n\n \n#define SPSSR_SPECM_MASK\t0x70\t \n#define SPSSR_SPCP_MASK\t\t0x07\t \n\n \n#define SPDCR_TXDMY\t\t0x80\t \n#define SPDCR_SPLW1\t\t0x40\t \n#define SPDCR_SPLW0\t\t0x20\t \n#define SPDCR_SPLLWORD\t\t(SPDCR_SPLW1 | SPDCR_SPLW0)\n#define SPDCR_SPLWORD\t\tSPDCR_SPLW1\n#define SPDCR_SPLBYTE\t\tSPDCR_SPLW0\n#define SPDCR_SPLW\t\t0x20\t \n#define SPDCR_SPRDTD\t\t0x10\t \n#define SPDCR_SLSEL1\t\t0x08\n#define SPDCR_SLSEL0\t\t0x04\n#define SPDCR_SLSEL_MASK\t0x0c\t \n#define SPDCR_SPFC1\t\t0x02\n#define SPDCR_SPFC0\t\t0x01\n#define SPDCR_SPFC_MASK\t\t0x03\t \n\n \n#define SPCKD_SCKDL_MASK\t0x07\t \n\n \n#define SSLND_SLNDL_MASK\t0x07\t \n\n \n#define SPND_SPNDL_MASK\t\t0x07\t \n\n \n#define SPCR2_PTE\t\t0x08\t \n#define SPCR2_SPIE\t\t0x04\t \n#define SPCR2_SPOE\t\t0x02\t \n#define SPCR2_SPPE\t\t0x01\t \n\n \n#define SPCMD_SCKDEN\t\t0x8000\t \n#define SPCMD_SLNDEN\t\t0x4000\t \n#define SPCMD_SPNDEN\t\t0x2000\t \n#define SPCMD_LSBF\t\t0x1000\t \n#define SPCMD_SPB_MASK\t\t0x0f00\t \n#define SPCMD_SPB_8_TO_16(bit)\t(((bit - 1) << 8) & SPCMD_SPB_MASK)\n#define SPCMD_SPB_8BIT\t\t0x0000\t \n#define SPCMD_SPB_16BIT\t\t0x0100\n#define SPCMD_SPB_20BIT\t\t0x0000\n#define SPCMD_SPB_24BIT\t\t0x0100\n#define SPCMD_SPB_32BIT\t\t0x0200\n#define SPCMD_SSLKP\t\t0x0080\t \n#define SPCMD_SPIMOD_MASK\t0x0060\t \n#define SPCMD_SPIMOD1\t\t0x0040\n#define SPCMD_SPIMOD0\t\t0x0020\n#define SPCMD_SPIMOD_SINGLE\t0\n#define SPCMD_SPIMOD_DUAL\tSPCMD_SPIMOD0\n#define SPCMD_SPIMOD_QUAD\tSPCMD_SPIMOD1\n#define SPCMD_SPRW\t\t0x0010\t \n#define SPCMD_SSLA(i)\t\t((i) << 4)\t \n#define SPCMD_BRDV_MASK\t\t0x000c\t \n#define SPCMD_BRDV(brdv)\t((brdv) << 2)\n#define SPCMD_CPOL\t\t0x0002\t \n#define SPCMD_CPHA\t\t0x0001\t \n\n \n#define SPBFCR_TXRST\t\t0x80\t \n#define SPBFCR_RXRST\t\t0x40\t \n#define SPBFCR_TXTRG_MASK\t0x30\t \n#define SPBFCR_RXTRG_MASK\t0x07\t \n \n#define SPBFCR_TXTRG_1B\t\t0x00\t \n#define SPBFCR_TXTRG_32B\t0x30\t \n#define SPBFCR_RXTRG_1B\t\t0x00\t \n#define SPBFCR_RXTRG_32B\t0x07\t \n\n#define QSPI_BUFFER_SIZE        32u\n\nstruct rspi_data {\n\tvoid __iomem *addr;\n\tu32 speed_hz;\n\tstruct spi_controller *ctlr;\n\tstruct platform_device *pdev;\n\twait_queue_head_t wait;\n\tspinlock_t lock;\t\t \n\tstruct clk *clk;\n\tu16 spcmd;\n\tu8 spsr;\n\tu8 sppcr;\n\tint rx_irq, tx_irq;\n\tconst struct spi_ops *ops;\n\n\tunsigned dma_callbacked:1;\n\tunsigned byte_access:1;\n};\n\nstatic void rspi_write8(const struct rspi_data *rspi, u8 data, u16 offset)\n{\n\tiowrite8(data, rspi->addr + offset);\n}\n\nstatic void rspi_write16(const struct rspi_data *rspi, u16 data, u16 offset)\n{\n\tiowrite16(data, rspi->addr + offset);\n}\n\nstatic void rspi_write32(const struct rspi_data *rspi, u32 data, u16 offset)\n{\n\tiowrite32(data, rspi->addr + offset);\n}\n\nstatic u8 rspi_read8(const struct rspi_data *rspi, u16 offset)\n{\n\treturn ioread8(rspi->addr + offset);\n}\n\nstatic u16 rspi_read16(const struct rspi_data *rspi, u16 offset)\n{\n\treturn ioread16(rspi->addr + offset);\n}\n\nstatic void rspi_write_data(const struct rspi_data *rspi, u16 data)\n{\n\tif (rspi->byte_access)\n\t\trspi_write8(rspi, data, RSPI_SPDR);\n\telse  \n\t\trspi_write16(rspi, data, RSPI_SPDR);\n}\n\nstatic u16 rspi_read_data(const struct rspi_data *rspi)\n{\n\tif (rspi->byte_access)\n\t\treturn rspi_read8(rspi, RSPI_SPDR);\n\telse  \n\t\treturn rspi_read16(rspi, RSPI_SPDR);\n}\n\n \nstruct spi_ops {\n\tint (*set_config_register)(struct rspi_data *rspi, int access_size);\n\tint (*transfer_one)(struct spi_controller *ctlr,\n\t\t\t    struct spi_device *spi, struct spi_transfer *xfer);\n\tu16 extra_mode_bits;\n\tu16 min_div;\n\tu16 max_div;\n\tu16 flags;\n\tu16 fifo_size;\n\tu8 num_hw_ss;\n};\n\nstatic void rspi_set_rate(struct rspi_data *rspi)\n{\n\tunsigned long clksrc;\n\tint brdv = 0, spbr;\n\n\tclksrc = clk_get_rate(rspi->clk);\n\tspbr = DIV_ROUND_UP(clksrc, 2 * rspi->speed_hz) - 1;\n\twhile (spbr > 255 && brdv < 3) {\n\t\tbrdv++;\n\t\tspbr = DIV_ROUND_UP(spbr + 1, 2) - 1;\n\t}\n\n\trspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);\n\trspi->spcmd |= SPCMD_BRDV(brdv);\n\trspi->speed_hz = DIV_ROUND_UP(clksrc, (2U << brdv) * (spbr + 1));\n}\n\n \nstatic int rspi_set_config_register(struct rspi_data *rspi, int access_size)\n{\n\t \n\trspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\n\n\t \n\trspi_set_rate(rspi);\n\n\t \n\trspi_write8(rspi, 0, RSPI_SPDCR);\n\trspi->byte_access = 0;\n\n\t \n\trspi_write8(rspi, 0x00, RSPI_SPCKD);\n\trspi_write8(rspi, 0x00, RSPI_SSLND);\n\trspi_write8(rspi, 0x00, RSPI_SPND);\n\n\t \n\trspi_write8(rspi, 0x00, RSPI_SPCR2);\n\n\t \n\trspi_write8(rspi, 0, RSPI_SPSCR);\n\trspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);\n\trspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\n\n\t \n\trspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\n\n\treturn 0;\n}\n\n \nstatic int rspi_rz_set_config_register(struct rspi_data *rspi, int access_size)\n{\n\t \n\trspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\n\n\t \n\trspi_set_rate(rspi);\n\n\t \n\trspi_write8(rspi, SPDCR_SPLBYTE, RSPI_SPDCR);\n\trspi->byte_access = 1;\n\n\t \n\trspi_write8(rspi, 0x00, RSPI_SPCKD);\n\trspi_write8(rspi, 0x00, RSPI_SSLND);\n\trspi_write8(rspi, 0x00, RSPI_SPND);\n\n\t \n\trspi_write8(rspi, 0, RSPI_SPSCR);\n\trspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);\n\trspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\n\n\t \n\trspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\n\n\treturn 0;\n}\n\n \nstatic int qspi_set_config_register(struct rspi_data *rspi, int access_size)\n{\n\tunsigned long clksrc;\n\tint brdv = 0, spbr;\n\n\t \n\trspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);\n\n\t \n\tclksrc = clk_get_rate(rspi->clk);\n\tif (rspi->speed_hz >= clksrc) {\n\t\tspbr = 0;\n\t\trspi->speed_hz = clksrc;\n\t} else {\n\t\tspbr = DIV_ROUND_UP(clksrc, 2 * rspi->speed_hz);\n\t\twhile (spbr > 255 && brdv < 3) {\n\t\t\tbrdv++;\n\t\t\tspbr = DIV_ROUND_UP(spbr, 2);\n\t\t}\n\t\tspbr = clamp(spbr, 0, 255);\n\t\trspi->speed_hz = DIV_ROUND_UP(clksrc, (2U << brdv) * spbr);\n\t}\n\trspi_write8(rspi, spbr, RSPI_SPBR);\n\trspi->spcmd |= SPCMD_BRDV(brdv);\n\n\t \n\trspi_write8(rspi, 0, RSPI_SPDCR);\n\trspi->byte_access = 1;\n\n\t \n\trspi_write8(rspi, 0x00, RSPI_SPCKD);\n\trspi_write8(rspi, 0x00, RSPI_SSLND);\n\trspi_write8(rspi, 0x00, RSPI_SPND);\n\n\t \n\tif (access_size == 8)\n\t\trspi->spcmd |= SPCMD_SPB_8BIT;\n\telse if (access_size == 16)\n\t\trspi->spcmd |= SPCMD_SPB_16BIT;\n\telse\n\t\trspi->spcmd |= SPCMD_SPB_32BIT;\n\n\trspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;\n\n\t \n\trspi_write32(rspi, 0, QSPI_SPBMUL0);\n\n\t \n\trspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, QSPI_SPBFCR);\n\t \n\trspi_write8(rspi, 0x00, QSPI_SPBFCR);\n\n\t \n\trspi_write8(rspi, 0, RSPI_SPSCR);\n\trspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\n\n\t \n\trspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\n\n\treturn 0;\n}\n\nstatic void qspi_update(const struct rspi_data *rspi, u8 mask, u8 val, u8 reg)\n{\n\tu8 data;\n\n\tdata = rspi_read8(rspi, reg);\n\tdata &= ~mask;\n\tdata |= (val & mask);\n\trspi_write8(rspi, data, reg);\n}\n\nstatic unsigned int qspi_set_send_trigger(struct rspi_data *rspi,\n\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int n;\n\n\tn = min(len, QSPI_BUFFER_SIZE);\n\n\tif (len >= QSPI_BUFFER_SIZE) {\n\t\t \n\t\tqspi_update(rspi, SPBFCR_TXTRG_MASK,\n\t\t\t     SPBFCR_TXTRG_32B, QSPI_SPBFCR);\n\t} else {\n\t\t \n\t\tqspi_update(rspi, SPBFCR_TXTRG_MASK,\n\t\t\t     SPBFCR_TXTRG_1B, QSPI_SPBFCR);\n\t}\n\n\treturn n;\n}\n\nstatic int qspi_set_receive_trigger(struct rspi_data *rspi, unsigned int len)\n{\n\tunsigned int n;\n\n\tn = min(len, QSPI_BUFFER_SIZE);\n\n\tif (len >= QSPI_BUFFER_SIZE) {\n\t\t \n\t\tqspi_update(rspi, SPBFCR_RXTRG_MASK,\n\t\t\t     SPBFCR_RXTRG_32B, QSPI_SPBFCR);\n\t} else {\n\t\t \n\t\tqspi_update(rspi, SPBFCR_RXTRG_MASK,\n\t\t\t     SPBFCR_RXTRG_1B, QSPI_SPBFCR);\n\t}\n\treturn n;\n}\n\nstatic void rspi_enable_irq(const struct rspi_data *rspi, u8 enable)\n{\n\trspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | enable, RSPI_SPCR);\n}\n\nstatic void rspi_disable_irq(const struct rspi_data *rspi, u8 disable)\n{\n\trspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~disable, RSPI_SPCR);\n}\n\nstatic int rspi_wait_for_interrupt(struct rspi_data *rspi, u8 wait_mask,\n\t\t\t\t   u8 enable_bit)\n{\n\tint ret;\n\n\trspi->spsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (rspi->spsr & wait_mask)\n\t\treturn 0;\n\n\trspi_enable_irq(rspi, enable_bit);\n\tret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);\n\tif (ret == 0 && !(rspi->spsr & wait_mask))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic inline int rspi_wait_for_tx_empty(struct rspi_data *rspi)\n{\n\treturn rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);\n}\n\nstatic inline int rspi_wait_for_rx_full(struct rspi_data *rspi)\n{\n\treturn rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE);\n}\n\nstatic int rspi_data_out(struct rspi_data *rspi, u8 data)\n{\n\tint error = rspi_wait_for_tx_empty(rspi);\n\tif (error < 0) {\n\t\tdev_err(&rspi->ctlr->dev, \"transmit timeout\\n\");\n\t\treturn error;\n\t}\n\trspi_write_data(rspi, data);\n\treturn 0;\n}\n\nstatic int rspi_data_in(struct rspi_data *rspi)\n{\n\tint error;\n\tu8 data;\n\n\terror = rspi_wait_for_rx_full(rspi);\n\tif (error < 0) {\n\t\tdev_err(&rspi->ctlr->dev, \"receive timeout\\n\");\n\t\treturn error;\n\t}\n\tdata = rspi_read_data(rspi);\n\treturn data;\n}\n\nstatic int rspi_pio_transfer(struct rspi_data *rspi, const u8 *tx, u8 *rx,\n\t\t\t     unsigned int n)\n{\n\twhile (n-- > 0) {\n\t\tif (tx) {\n\t\t\tint ret = rspi_data_out(rspi, *tx++);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (rx) {\n\t\t\tint ret = rspi_data_in(rspi);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*rx++ = ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rspi_dma_complete(void *arg)\n{\n\tstruct rspi_data *rspi = arg;\n\n\trspi->dma_callbacked = 1;\n\twake_up_interruptible(&rspi->wait);\n}\n\nstatic int rspi_dma_transfer(struct rspi_data *rspi, struct sg_table *tx,\n\t\t\t     struct sg_table *rx)\n{\n\tstruct dma_async_tx_descriptor *desc_tx = NULL, *desc_rx = NULL;\n\tu8 irq_mask = 0;\n\tunsigned int other_irq = 0;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\t \n\tif (rx) {\n\t\tdesc_rx = dmaengine_prep_slave_sg(rspi->ctlr->dma_rx, rx->sgl,\n\t\t\t\t\trx->nents, DMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc_rx) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto no_dma_rx;\n\t\t}\n\n\t\tdesc_rx->callback = rspi_dma_complete;\n\t\tdesc_rx->callback_param = rspi;\n\t\tcookie = dmaengine_submit(desc_rx);\n\t\tif (dma_submit_error(cookie)) {\n\t\t\tret = cookie;\n\t\t\tgoto no_dma_rx;\n\t\t}\n\n\t\tirq_mask |= SPCR_SPRIE;\n\t}\n\n\tif (tx) {\n\t\tdesc_tx = dmaengine_prep_slave_sg(rspi->ctlr->dma_tx, tx->sgl,\n\t\t\t\t\ttx->nents, DMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc_tx) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto no_dma_tx;\n\t\t}\n\n\t\tif (rx) {\n\t\t\t \n\t\t\tdesc_tx->callback = NULL;\n\t\t} else {\n\t\t\tdesc_tx->callback = rspi_dma_complete;\n\t\t\tdesc_tx->callback_param = rspi;\n\t\t}\n\t\tcookie = dmaengine_submit(desc_tx);\n\t\tif (dma_submit_error(cookie)) {\n\t\t\tret = cookie;\n\t\t\tgoto no_dma_tx;\n\t\t}\n\n\t\tirq_mask |= SPCR_SPTIE;\n\t}\n\n\t \n\tif (tx)\n\t\tdisable_irq(other_irq = rspi->tx_irq);\n\tif (rx && rspi->rx_irq != other_irq)\n\t\tdisable_irq(rspi->rx_irq);\n\n\trspi_enable_irq(rspi, irq_mask);\n\trspi->dma_callbacked = 0;\n\n\t \n\tif (rx)\n\t\tdma_async_issue_pending(rspi->ctlr->dma_rx);\n\tif (tx)\n\t\tdma_async_issue_pending(rspi->ctlr->dma_tx);\n\n\tret = wait_event_interruptible_timeout(rspi->wait,\n\t\t\t\t\t       rspi->dma_callbacked, HZ);\n\tif (ret > 0 && rspi->dma_callbacked) {\n\t\tret = 0;\n\t\tif (tx)\n\t\t\tdmaengine_synchronize(rspi->ctlr->dma_tx);\n\t\tif (rx)\n\t\t\tdmaengine_synchronize(rspi->ctlr->dma_rx);\n\t} else {\n\t\tif (!ret) {\n\t\t\tdev_err(&rspi->ctlr->dev, \"DMA timeout\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t\tif (tx)\n\t\t\tdmaengine_terminate_sync(rspi->ctlr->dma_tx);\n\t\tif (rx)\n\t\t\tdmaengine_terminate_sync(rspi->ctlr->dma_rx);\n\t}\n\n\trspi_disable_irq(rspi, irq_mask);\n\n\tif (tx)\n\t\tenable_irq(rspi->tx_irq);\n\tif (rx && rspi->rx_irq != other_irq)\n\t\tenable_irq(rspi->rx_irq);\n\n\treturn ret;\n\nno_dma_tx:\n\tif (rx)\n\t\tdmaengine_terminate_sync(rspi->ctlr->dma_rx);\nno_dma_rx:\n\tif (ret == -EAGAIN) {\n\t\tdev_warn_once(&rspi->ctlr->dev,\n\t\t\t      \"DMA not available, falling back to PIO\\n\");\n\t}\n\treturn ret;\n}\n\nstatic void rspi_receive_init(const struct rspi_data *rspi)\n{\n\tu8 spsr;\n\n\tspsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (spsr & SPSR_SPRF)\n\t\trspi_read_data(rspi);\t \n\tif (spsr & SPSR_OVRF)\n\t\trspi_write8(rspi, rspi_read8(rspi, RSPI_SPSR) & ~SPSR_OVRF,\n\t\t\t    RSPI_SPSR);\n}\n\nstatic void rspi_rz_receive_init(const struct rspi_data *rspi)\n{\n\trspi_receive_init(rspi);\n\trspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, RSPI_SPBFCR);\n\trspi_write8(rspi, 0, RSPI_SPBFCR);\n}\n\nstatic void qspi_receive_init(const struct rspi_data *rspi)\n{\n\tu8 spsr;\n\n\tspsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (spsr & SPSR_SPRF)\n\t\trspi_read_data(rspi);    \n\trspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, QSPI_SPBFCR);\n\trspi_write8(rspi, 0, QSPI_SPBFCR);\n}\n\nstatic bool __rspi_can_dma(const struct rspi_data *rspi,\n\t\t\t   const struct spi_transfer *xfer)\n{\n\treturn xfer->len > rspi->ops->fifo_size;\n}\n\nstatic bool rspi_can_dma(struct spi_controller *ctlr, struct spi_device *spi,\n\t\t\t struct spi_transfer *xfer)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\n\treturn __rspi_can_dma(rspi, xfer);\n}\n\nstatic int rspi_dma_check_then_transfer(struct rspi_data *rspi,\n\t\t\t\t\t struct spi_transfer *xfer)\n{\n\tif (!rspi->ctlr->can_dma || !__rspi_can_dma(rspi, xfer))\n\t\treturn -EAGAIN;\n\n\t \n\treturn rspi_dma_transfer(rspi, &xfer->tx_sg,\n\t\t\t\txfer->rx_buf ? &xfer->rx_sg : NULL);\n}\n\nstatic int rspi_common_transfer(struct rspi_data *rspi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tint ret;\n\n\txfer->effective_speed_hz = rspi->speed_hz;\n\n\tret = rspi_dma_check_then_transfer(rspi, xfer);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\tret = rspi_pio_transfer(rspi, xfer->tx_buf, xfer->rx_buf, xfer->len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\trspi_wait_for_tx_empty(rspi);\n\n\treturn 0;\n}\n\nstatic int rspi_transfer_one(struct spi_controller *ctlr,\n\t\t\t     struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\tu8 spcr;\n\n\tspcr = rspi_read8(rspi, RSPI_SPCR);\n\tif (xfer->rx_buf) {\n\t\trspi_receive_init(rspi);\n\t\tspcr &= ~SPCR_TXMD;\n\t} else {\n\t\tspcr |= SPCR_TXMD;\n\t}\n\trspi_write8(rspi, spcr, RSPI_SPCR);\n\n\treturn rspi_common_transfer(rspi, xfer);\n}\n\nstatic int rspi_rz_transfer_one(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\n\trspi_rz_receive_init(rspi);\n\n\treturn rspi_common_transfer(rspi, xfer);\n}\n\nstatic int qspi_trigger_transfer_out_in(struct rspi_data *rspi, const u8 *tx,\n\t\t\t\t\tu8 *rx, unsigned int len)\n{\n\tunsigned int i, n;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tn = qspi_set_send_trigger(rspi, len);\n\t\tqspi_set_receive_trigger(rspi, len);\n\t\tret = rspi_wait_for_tx_empty(rspi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&rspi->ctlr->dev, \"transmit timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t\trspi_write_data(rspi, *tx++);\n\n\t\tret = rspi_wait_for_rx_full(rspi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&rspi->ctlr->dev, \"receive timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t\t*rx++ = rspi_read_data(rspi);\n\n\t\tlen -= n;\n\t}\n\n\treturn 0;\n}\n\nstatic int qspi_transfer_out_in(struct rspi_data *rspi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tint ret;\n\n\tqspi_receive_init(rspi);\n\n\tret = rspi_dma_check_then_transfer(rspi, xfer);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\treturn qspi_trigger_transfer_out_in(rspi, xfer->tx_buf,\n\t\t\t\t\t    xfer->rx_buf, xfer->len);\n}\n\nstatic int qspi_transfer_out(struct rspi_data *rspi, struct spi_transfer *xfer)\n{\n\tconst u8 *tx = xfer->tx_buf;\n\tunsigned int n = xfer->len;\n\tunsigned int i, len;\n\tint ret;\n\n\tif (rspi->ctlr->can_dma && __rspi_can_dma(rspi, xfer)) {\n\t\tret = rspi_dma_transfer(rspi, &xfer->tx_sg, NULL);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\n\twhile (n > 0) {\n\t\tlen = qspi_set_send_trigger(rspi, n);\n\t\tret = rspi_wait_for_tx_empty(rspi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&rspi->ctlr->dev, \"transmit timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < len; i++)\n\t\t\trspi_write_data(rspi, *tx++);\n\n\t\tn -= len;\n\t}\n\n\t \n\trspi_wait_for_tx_empty(rspi);\n\n\treturn 0;\n}\n\nstatic int qspi_transfer_in(struct rspi_data *rspi, struct spi_transfer *xfer)\n{\n\tu8 *rx = xfer->rx_buf;\n\tunsigned int n = xfer->len;\n\tunsigned int i, len;\n\tint ret;\n\n\tif (rspi->ctlr->can_dma && __rspi_can_dma(rspi, xfer)) {\n\t\tret = rspi_dma_transfer(rspi, NULL, &xfer->rx_sg);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\n\twhile (n > 0) {\n\t\tlen = qspi_set_receive_trigger(rspi, n);\n\t\tret = rspi_wait_for_rx_full(rspi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&rspi->ctlr->dev, \"receive timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*rx++ = rspi_read_data(rspi);\n\n\t\tn -= len;\n\t}\n\n\treturn 0;\n}\n\nstatic int qspi_transfer_one(struct spi_controller *ctlr,\n\t\t\t     struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\n\txfer->effective_speed_hz = rspi->speed_hz;\n\tif (spi->mode & SPI_LOOP) {\n\t\treturn qspi_transfer_out_in(rspi, xfer);\n\t} else if (xfer->tx_nbits > SPI_NBITS_SINGLE) {\n\t\t \n\t\treturn qspi_transfer_out(rspi, xfer);\n\t} else if (xfer->rx_nbits > SPI_NBITS_SINGLE) {\n\t\t \n\t\treturn qspi_transfer_in(rspi, xfer);\n\t} else {\n\t\t \n\t\treturn qspi_transfer_out_in(rspi, xfer);\n\t}\n}\n\nstatic u16 qspi_transfer_mode(const struct spi_transfer *xfer)\n{\n\tif (xfer->tx_buf)\n\t\tswitch (xfer->tx_nbits) {\n\t\tcase SPI_NBITS_QUAD:\n\t\t\treturn SPCMD_SPIMOD_QUAD;\n\t\tcase SPI_NBITS_DUAL:\n\t\t\treturn SPCMD_SPIMOD_DUAL;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tif (xfer->rx_buf)\n\t\tswitch (xfer->rx_nbits) {\n\t\tcase SPI_NBITS_QUAD:\n\t\t\treturn SPCMD_SPIMOD_QUAD | SPCMD_SPRW;\n\t\tcase SPI_NBITS_DUAL:\n\t\t\treturn SPCMD_SPIMOD_DUAL | SPCMD_SPRW;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int qspi_setup_sequencer(struct rspi_data *rspi,\n\t\t\t\tconst struct spi_message *msg)\n{\n\tconst struct spi_transfer *xfer;\n\tunsigned int i = 0, len = 0;\n\tu16 current_mode = 0xffff, mode;\n\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tmode = qspi_transfer_mode(xfer);\n\t\tif (mode == current_mode) {\n\t\t\tlen += xfer->len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (i) {\n\t\t\t \n\t\t\trspi_write32(rspi, len, QSPI_SPBMUL(i - 1));\n\t\t}\n\n\t\tif (i >= QSPI_NUM_SPCMD) {\n\t\t\tdev_err(&msg->spi->dev,\n\t\t\t\t\"Too many different transfer modes\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\trspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));\n\t\tcurrent_mode = mode;\n\t\tlen = xfer->len;\n\t\ti++;\n\t}\n\tif (i) {\n\t\t \n\t\trspi_write32(rspi, len, QSPI_SPBMUL(i - 1));\n\t\trspi_write8(rspi, i - 1, RSPI_SPSCR);\n\t}\n\n\treturn 0;\n}\n\nstatic int rspi_setup(struct spi_device *spi)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(spi->controller);\n\tu8 sslp;\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\treturn 0;\n\n\tpm_runtime_get_sync(&rspi->pdev->dev);\n\tspin_lock_irq(&rspi->lock);\n\n\tsslp = rspi_read8(rspi, RSPI_SSLP);\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tsslp |= SSLP_SSLP(spi_get_chipselect(spi, 0));\n\telse\n\t\tsslp &= ~SSLP_SSLP(spi_get_chipselect(spi, 0));\n\trspi_write8(rspi, sslp, RSPI_SSLP);\n\n\tspin_unlock_irq(&rspi->lock);\n\tpm_runtime_put(&rspi->pdev->dev);\n\treturn 0;\n}\n\nstatic int rspi_prepare_message(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_message *msg)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\tstruct spi_device *spi = msg->spi;\n\tconst struct spi_transfer *xfer;\n\tint ret;\n\n\t \n\trspi->speed_hz = spi->max_speed_hz;\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tif (xfer->speed_hz < rspi->speed_hz)\n\t\t\trspi->speed_hz = xfer->speed_hz;\n\t}\n\n\trspi->spcmd = SPCMD_SSLKP;\n\tif (spi->mode & SPI_CPOL)\n\t\trspi->spcmd |= SPCMD_CPOL;\n\tif (spi->mode & SPI_CPHA)\n\t\trspi->spcmd |= SPCMD_CPHA;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\trspi->spcmd |= SPCMD_LSBF;\n\n\t \n\trspi->spcmd |= SPCMD_SSLA(spi_get_csgpiod(spi, 0) ? rspi->ctlr->unused_native_cs\n\t\t\t\t\t\t: spi_get_chipselect(spi, 0));\n\n\t \n\trspi->sppcr = 0;\n\tif (spi->mode & SPI_LOOP)\n\t\trspi->sppcr |= SPPCR_SPLP;\n\n\trspi->ops->set_config_register(rspi, 8);\n\n\tif (msg->spi->mode &\n\t    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)) {\n\t\t \n\t\tret = qspi_setup_sequencer(rspi, msg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\trspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_SPE, RSPI_SPCR);\n\treturn 0;\n}\n\nstatic int rspi_unprepare_message(struct spi_controller *ctlr,\n\t\t\t\t  struct spi_message *msg)\n{\n\tstruct rspi_data *rspi = spi_controller_get_devdata(ctlr);\n\n\t \n\trspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);\n\n\t \n\trspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);\n\trspi_write8(rspi, 0, RSPI_SPSCR);\n\treturn 0;\n}\n\nstatic irqreturn_t rspi_irq_mux(int irq, void *_sr)\n{\n\tstruct rspi_data *rspi = _sr;\n\tu8 spsr;\n\tirqreturn_t ret = IRQ_NONE;\n\tu8 disable_irq = 0;\n\n\trspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (spsr & SPSR_SPRF)\n\t\tdisable_irq |= SPCR_SPRIE;\n\tif (spsr & SPSR_SPTEF)\n\t\tdisable_irq |= SPCR_SPTIE;\n\n\tif (disable_irq) {\n\t\tret = IRQ_HANDLED;\n\t\trspi_disable_irq(rspi, disable_irq);\n\t\twake_up(&rspi->wait);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t rspi_irq_rx(int irq, void *_sr)\n{\n\tstruct rspi_data *rspi = _sr;\n\tu8 spsr;\n\n\trspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (spsr & SPSR_SPRF) {\n\t\trspi_disable_irq(rspi, SPCR_SPRIE);\n\t\twake_up(&rspi->wait);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rspi_irq_tx(int irq, void *_sr)\n{\n\tstruct rspi_data *rspi = _sr;\n\tu8 spsr;\n\n\trspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\n\tif (spsr & SPSR_SPTEF) {\n\t\trspi_disable_irq(rspi, SPCR_SPTIE);\n\t\twake_up(&rspi->wait);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dma_chan *rspi_request_dma_chan(struct device *dev,\n\t\t\t\t\t      enum dma_transfer_direction dir,\n\t\t\t\t\t      unsigned int id,\n\t\t\t\t\t      dma_addr_t port_addr)\n{\n\tdma_cap_mask_t mask;\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tchan = dma_request_slave_channel_compat(mask, shdma_chan_filter,\n\t\t\t\t(void *)(unsigned long)id, dev,\n\t\t\t\tdir == DMA_MEM_TO_DEV ? \"tx\" : \"rx\");\n\tif (!chan) {\n\t\tdev_warn(dev, \"dma_request_slave_channel_compat failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.dst_addr = port_addr + RSPI_SPDR;\n\tcfg.src_addr = port_addr + RSPI_SPDR;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tcfg.direction = dir;\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret) {\n\t\tdev_warn(dev, \"dmaengine_slave_config failed %d\\n\", ret);\n\t\tdma_release_channel(chan);\n\t\treturn NULL;\n\t}\n\n\treturn chan;\n}\n\nstatic int rspi_request_dma(struct device *dev, struct spi_controller *ctlr,\n\t\t\t    const struct resource *res)\n{\n\tconst struct rspi_plat_data *rspi_pd = dev_get_platdata(dev);\n\tunsigned int dma_tx_id, dma_rx_id;\n\n\tif (dev->of_node) {\n\t\t \n\t\tdma_tx_id = 0;\n\t\tdma_rx_id = 0;\n\t} else if (rspi_pd && rspi_pd->dma_tx_id && rspi_pd->dma_rx_id) {\n\t\tdma_tx_id = rspi_pd->dma_tx_id;\n\t\tdma_rx_id = rspi_pd->dma_rx_id;\n\t} else {\n\t\t \n\t\treturn 0;\n\t}\n\n\tctlr->dma_tx = rspi_request_dma_chan(dev, DMA_MEM_TO_DEV, dma_tx_id,\n\t\t\t\t\t     res->start);\n\tif (!ctlr->dma_tx)\n\t\treturn -ENODEV;\n\n\tctlr->dma_rx = rspi_request_dma_chan(dev, DMA_DEV_TO_MEM, dma_rx_id,\n\t\t\t\t\t     res->start);\n\tif (!ctlr->dma_rx) {\n\t\tdma_release_channel(ctlr->dma_tx);\n\t\tctlr->dma_tx = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\tctlr->can_dma = rspi_can_dma;\n\tdev_info(dev, \"DMA available\");\n\treturn 0;\n}\n\nstatic void rspi_release_dma(struct spi_controller *ctlr)\n{\n\tif (ctlr->dma_tx)\n\t\tdma_release_channel(ctlr->dma_tx);\n\tif (ctlr->dma_rx)\n\t\tdma_release_channel(ctlr->dma_rx);\n}\n\nstatic void rspi_remove(struct platform_device *pdev)\n{\n\tstruct rspi_data *rspi = platform_get_drvdata(pdev);\n\n\trspi_release_dma(rspi->ctlr);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct spi_ops rspi_ops = {\n\t.set_config_register =\trspi_set_config_register,\n\t.transfer_one =\t\trspi_transfer_one,\n\t.min_div =\t\t2,\n\t.max_div =\t\t4096,\n\t.flags =\t\tSPI_CONTROLLER_MUST_TX,\n\t.fifo_size =\t\t8,\n\t.num_hw_ss =\t\t2,\n};\n\nstatic const struct spi_ops rspi_rz_ops __maybe_unused = {\n\t.set_config_register =\trspi_rz_set_config_register,\n\t.transfer_one =\t\trspi_rz_transfer_one,\n\t.min_div =\t\t2,\n\t.max_div =\t\t4096,\n\t.flags =\t\tSPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX,\n\t.fifo_size =\t\t8,\t \n\t.num_hw_ss =\t\t1,\n};\n\nstatic const struct spi_ops qspi_ops __maybe_unused = {\n\t.set_config_register =\tqspi_set_config_register,\n\t.transfer_one =\t\tqspi_transfer_one,\n\t.extra_mode_bits =\tSPI_TX_DUAL | SPI_TX_QUAD |\n\t\t\t\tSPI_RX_DUAL | SPI_RX_QUAD,\n\t.min_div =\t\t1,\n\t.max_div =\t\t4080,\n\t.flags =\t\tSPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX,\n\t.fifo_size =\t\t32,\n\t.num_hw_ss =\t\t1,\n};\n\nstatic const struct of_device_id rspi_of_match[] __maybe_unused = {\n\t \n\t{ .compatible = \"renesas,rspi\", .data = &rspi_ops },\n\t \n\t{ .compatible = \"renesas,rspi-rz\", .data = &rspi_rz_ops },\n\t \n\t{ .compatible = \"renesas,qspi\", .data = &qspi_ops },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, rspi_of_match);\n\n#ifdef CONFIG_OF\nstatic void rspi_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int rspi_parse_dt(struct device *dev, struct spi_controller *ctlr)\n{\n\tstruct reset_control *rstc;\n\tu32 num_cs;\n\tint error;\n\n\t \n\terror = of_property_read_u32(dev->of_node, \"num-cs\", &num_cs);\n\tif (error) {\n\t\tdev_err(dev, \"of_property_read_u32 num-cs failed %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tctlr->num_chipselect = num_cs;\n\n\trstc = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(rstc),\n\t\t\t\t\t     \"failed to get reset ctrl\\n\");\n\n\terror = reset_control_deassert(rstc);\n\tif (error) {\n\t\tdev_err(dev, \"failed to deassert reset %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, rspi_reset_control_assert, rstc);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register assert devm action, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n#else\n#define rspi_of_match\tNULL\nstatic inline int rspi_parse_dt(struct device *dev, struct spi_controller *ctlr)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic int rspi_request_irq(struct device *dev, unsigned int irq,\n\t\t\t    irq_handler_t handler, const char *suffix,\n\t\t\t    void *dev_id)\n{\n\tconst char *name = devm_kasprintf(dev, GFP_KERNEL, \"%s:%s\",\n\t\t\t\t\t  dev_name(dev), suffix);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\treturn devm_request_irq(dev, irq, handler, 0, name, dev_id);\n}\n\nstatic int rspi_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct spi_controller *ctlr;\n\tstruct rspi_data *rspi;\n\tint ret;\n\tconst struct rspi_plat_data *rspi_pd;\n\tconst struct spi_ops *ops;\n\tunsigned long clksrc;\n\n\tctlr = spi_alloc_host(&pdev->dev, sizeof(struct rspi_data));\n\tif (ctlr == NULL)\n\t\treturn -ENOMEM;\n\n\tops = of_device_get_match_data(&pdev->dev);\n\tif (ops) {\n\t\tret = rspi_parse_dt(&pdev->dev, ctlr);\n\t\tif (ret)\n\t\t\tgoto error1;\n\t} else {\n\t\tops = (struct spi_ops *)pdev->id_entry->driver_data;\n\t\trspi_pd = dev_get_platdata(&pdev->dev);\n\t\tif (rspi_pd && rspi_pd->num_chipselect)\n\t\t\tctlr->num_chipselect = rspi_pd->num_chipselect;\n\t\telse\n\t\t\tctlr->num_chipselect = 2;  \n\t}\n\n\trspi = spi_controller_get_devdata(ctlr);\n\tplatform_set_drvdata(pdev, rspi);\n\trspi->ops = ops;\n\trspi->ctlr = ctlr;\n\n\trspi->addr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(rspi->addr)) {\n\t\tret = PTR_ERR(rspi->addr);\n\t\tgoto error1;\n\t}\n\n\trspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(rspi->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\tret = PTR_ERR(rspi->clk);\n\t\tgoto error1;\n\t}\n\n\trspi->pdev = pdev;\n\tpm_runtime_enable(&pdev->dev);\n\n\tinit_waitqueue_head(&rspi->wait);\n\tspin_lock_init(&rspi->lock);\n\n\tctlr->bus_num = pdev->id;\n\tctlr->setup = rspi_setup;\n\tctlr->auto_runtime_pm = true;\n\tctlr->transfer_one = ops->transfer_one;\n\tctlr->prepare_message = rspi_prepare_message;\n\tctlr->unprepare_message = rspi_unprepare_message;\n\tctlr->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |\n\t\t\t  SPI_LOOP | ops->extra_mode_bits;\n\tclksrc = clk_get_rate(rspi->clk);\n\tctlr->min_speed_hz = DIV_ROUND_UP(clksrc, ops->max_div);\n\tctlr->max_speed_hz = DIV_ROUND_UP(clksrc, ops->min_div);\n\tctlr->flags = ops->flags;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->use_gpio_descriptors = true;\n\tctlr->max_native_cs = rspi->ops->num_hw_ss;\n\n\tret = platform_get_irq_byname_optional(pdev, \"rx\");\n\tif (ret < 0) {\n\t\tret = platform_get_irq_byname_optional(pdev, \"mux\");\n\t\tif (ret < 0)\n\t\t\tret = platform_get_irq(pdev, 0);\n\t\tif (ret >= 0)\n\t\t\trspi->rx_irq = rspi->tx_irq = ret;\n\t} else {\n\t\trspi->rx_irq = ret;\n\t\tret = platform_get_irq_byname(pdev, \"tx\");\n\t\tif (ret >= 0)\n\t\t\trspi->tx_irq = ret;\n\t}\n\n\tif (rspi->rx_irq == rspi->tx_irq) {\n\t\t \n\t\tret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,\n\t\t\t\t       \"mux\", rspi);\n\t} else {\n\t\t \n\t\tret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,\n\t\t\t\t       \"rx\", rspi);\n\t\tif (!ret)\n\t\t\tret = rspi_request_irq(&pdev->dev, rspi->tx_irq,\n\t\t\t\t\t       rspi_irq_tx, \"tx\", rspi);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq error\\n\");\n\t\tgoto error2;\n\t}\n\n\tret = rspi_request_dma(&pdev->dev, ctlr, res);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"DMA not available, using PIO\\n\");\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"devm_spi_register_controller error.\\n\");\n\t\tgoto error3;\n\t}\n\n\tdev_info(&pdev->dev, \"probed\\n\");\n\n\treturn 0;\n\nerror3:\n\trspi_release_dma(ctlr);\nerror2:\n\tpm_runtime_disable(&pdev->dev);\nerror1:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic const struct platform_device_id spi_driver_ids[] = {\n\t{ \"rspi\",\t(kernel_ulong_t)&rspi_ops },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(platform, spi_driver_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rspi_suspend(struct device *dev)\n{\n\tstruct rspi_data *rspi = dev_get_drvdata(dev);\n\n\treturn spi_controller_suspend(rspi->ctlr);\n}\n\nstatic int rspi_resume(struct device *dev)\n{\n\tstruct rspi_data *rspi = dev_get_drvdata(dev);\n\n\treturn spi_controller_resume(rspi->ctlr);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rspi_pm_ops, rspi_suspend, rspi_resume);\n#define DEV_PM_OPS\t&rspi_pm_ops\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic struct platform_driver rspi_driver = {\n\t.probe =\trspi_probe,\n\t.remove_new =\trspi_remove,\n\t.id_table =\tspi_driver_ids,\n\t.driver\t\t= {\n\t\t.name = \"renesas_spi\",\n\t\t.pm = DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(rspi_of_match),\n\t},\n};\nmodule_platform_driver(rspi_driver);\n\nMODULE_DESCRIPTION(\"Renesas RSPI bus driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}