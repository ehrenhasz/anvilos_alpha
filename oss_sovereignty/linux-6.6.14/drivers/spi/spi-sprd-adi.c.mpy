{
  "module_name": "spi-sprd-adi.c",
  "hash_id": "35df982307cde7968f051f052715bff3045a4637533ef0085671726c549cb2b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sprd-adi.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/hwspinlock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/spi/spi.h>\n#include <linux/sizes.h>\n\n \n#define REG_ADI_CTRL0\t\t\t0x4\n#define REG_ADI_CHN_PRIL\t\t0x8\n#define REG_ADI_CHN_PRIH\t\t0xc\n#define REG_ADI_INT_EN\t\t\t0x10\n#define REG_ADI_INT_RAW\t\t\t0x14\n#define REG_ADI_INT_MASK\t\t0x18\n#define REG_ADI_INT_CLR\t\t\t0x1c\n#define REG_ADI_GSSI_CFG0\t\t0x20\n#define REG_ADI_GSSI_CFG1\t\t0x24\n#define REG_ADI_RD_CMD\t\t\t0x28\n#define REG_ADI_RD_DATA\t\t\t0x2c\n#define REG_ADI_ARM_FIFO_STS\t\t0x30\n#define REG_ADI_STS\t\t\t0x34\n#define REG_ADI_EVT_FIFO_STS\t\t0x38\n#define REG_ADI_ARM_CMD_STS\t\t0x3c\n#define REG_ADI_CHN_EN\t\t\t0x40\n#define REG_ADI_CHN_ADDR(id)\t\t(0x44 + (id - 2) * 4)\n#define REG_ADI_CHN_EN1\t\t\t0x20c\n\n \n#define BIT_CLK_ALL_ON\t\t\tBIT(30)\n\n \n#define BIT_RD_CMD_BUSY\t\t\tBIT(31)\n#define RD_ADDR_SHIFT\t\t\t16\n#define RD_VALUE_MASK\t\t\tGENMASK(15, 0)\n#define RD_ADDR_MASK\t\t\tGENMASK(30, 16)\n\n \n#define BIT_FIFO_FULL\t\t\tBIT(11)\n#define BIT_FIFO_EMPTY\t\t\tBIT(10)\n\n \n#define ADI_10BIT_SLAVE_ADDR_SIZE\tSZ_4K\n#define ADI_10BIT_SLAVE_OFFSET\t\t0x8000\n#define ADI_12BIT_SLAVE_ADDR_SIZE\tSZ_16K\n#define ADI_12BIT_SLAVE_OFFSET\t\t0x8000\n#define ADI_15BIT_SLAVE_ADDR_SIZE\tSZ_128K\n#define ADI_15BIT_SLAVE_OFFSET\t\t0x20000\n\n \n#define ADI_HWSPINLOCK_TIMEOUT\t\t5000\n \n#define ADI_HW_CHNS\t\t\t50\n\n#define ADI_FIFO_DRAIN_TIMEOUT\t\t1000\n#define ADI_READ_TIMEOUT\t\t2000\n\n \n#define RDBACK_ADDR_MASK_R2\t\tGENMASK(14, 0)\n#define RDBACK_ADDR_MASK_R3\t\tGENMASK(16, 2)\n#define RDBACK_ADDR_SHIFT_R3\t\t2\n\n \n#define REG_WDG_LOAD_LOW\t\t0x0\n#define REG_WDG_LOAD_HIGH\t\t0x4\n#define REG_WDG_CTRL\t\t\t0x8\n#define REG_WDG_LOCK\t\t\t0x20\n\n \n#define BIT_WDG_RUN\t\t\tBIT(1)\n#define BIT_WDG_NEW\t\t\tBIT(2)\n#define BIT_WDG_RST\t\t\tBIT(3)\n\n \n#define BIT_WDG_EN\t\t\tBIT(2)\n\n \n#define PMIC_RST_STATUS\t\t\t0xee8\n#define PMIC_MODULE_EN\t\t\t0xc08\n#define PMIC_CLK_EN\t\t\t0xc18\n#define PMIC_WDG_BASE\t\t\t0x80\n\n \n#define HWRST_STATUS_SECURITY\t\t0x02\n#define HWRST_STATUS_RECOVERY\t\t0x20\n#define HWRST_STATUS_NORMAL\t\t0x40\n#define HWRST_STATUS_ALARM\t\t0x50\n#define HWRST_STATUS_SLEEP\t\t0x60\n#define HWRST_STATUS_FASTBOOT\t\t0x30\n#define HWRST_STATUS_SPECIAL\t\t0x70\n#define HWRST_STATUS_PANIC\t\t0x80\n#define HWRST_STATUS_CFTREBOOT\t\t0x90\n#define HWRST_STATUS_AUTODLOADER\t0xa0\n#define HWRST_STATUS_IQMODE\t\t0xb0\n#define HWRST_STATUS_SPRDISK\t\t0xc0\n#define HWRST_STATUS_FACTORYTEST\t0xe0\n#define HWRST_STATUS_WATCHDOG\t\t0xf0\n\n \n#define WDG_LOAD_VAL\t\t\t((50 * 32768) / 1000)\n#define WDG_LOAD_MASK\t\t\tGENMASK(15, 0)\n#define WDG_UNLOCK_KEY\t\t\t0xe551\n\nstruct sprd_adi_wdg {\n\tu32 base;\n\tu32 rst_sts;\n\tu32 wdg_en;\n\tu32 wdg_clk;\n};\n\nstruct sprd_adi_data {\n\tu32 slave_offset;\n\tu32 slave_addr_size;\n\tint (*read_check)(u32 val, u32 reg);\n\tint (*restart)(struct notifier_block *this,\n\t\t       unsigned long mode, void *cmd);\n\tvoid (*wdg_rst)(void *p);\n};\n\nstruct sprd_adi {\n\tstruct spi_controller\t*ctlr;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct hwspinlock\t*hwlock;\n\tunsigned long\t\tslave_vbase;\n\tunsigned long\t\tslave_pbase;\n\tstruct notifier_block\trestart_handler;\n\tconst struct sprd_adi_data *data;\n};\n\nstatic int sprd_adi_check_addr(struct sprd_adi *sadi, u32 reg)\n{\n\tif (reg >= sadi->data->slave_addr_size) {\n\t\tdev_err(sadi->dev,\n\t\t\t\"slave address offset is incorrect, reg = 0x%x\\n\",\n\t\t\treg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_adi_drain_fifo(struct sprd_adi *sadi)\n{\n\tu32 timeout = ADI_FIFO_DRAIN_TIMEOUT;\n\tu32 sts;\n\n\tdo {\n\t\tsts = readl_relaxed(sadi->base + REG_ADI_ARM_FIFO_STS);\n\t\tif (sts & BIT_FIFO_EMPTY)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t} while (--timeout);\n\n\tif (timeout == 0) {\n\t\tdev_err(sadi->dev, \"drain write fifo timeout\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_adi_fifo_is_full(struct sprd_adi *sadi)\n{\n\treturn readl_relaxed(sadi->base + REG_ADI_ARM_FIFO_STS) & BIT_FIFO_FULL;\n}\n\nstatic int sprd_adi_read_check(u32 val, u32 addr)\n{\n\tu32 rd_addr;\n\n\trd_addr = (val & RD_ADDR_MASK) >> RD_ADDR_SHIFT;\n\n\tif (rd_addr != addr) {\n\t\tpr_err(\"ADI read error, addr = 0x%x, val = 0x%x\\n\", addr, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_adi_read_check_r2(u32 val, u32 reg)\n{\n\treturn sprd_adi_read_check(val, reg & RDBACK_ADDR_MASK_R2);\n}\n\nstatic int sprd_adi_read_check_r3(u32 val, u32 reg)\n{\n\treturn sprd_adi_read_check(val, (reg & RDBACK_ADDR_MASK_R3) >> RDBACK_ADDR_SHIFT_R3);\n}\n\nstatic int sprd_adi_read(struct sprd_adi *sadi, u32 reg, u32 *read_val)\n{\n\tint read_timeout = ADI_READ_TIMEOUT;\n\tunsigned long flags;\n\tu32 val;\n\tint ret = 0;\n\n\tif (sadi->hwlock) {\n\t\tret = hwspin_lock_timeout_irqsave(sadi->hwlock,\n\t\t\t\t\t\t  ADI_HWSPINLOCK_TIMEOUT,\n\t\t\t\t\t\t  &flags);\n\t\tif (ret) {\n\t\t\tdev_err(sadi->dev, \"get the hw lock failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sprd_adi_check_addr(sadi, reg);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twritel_relaxed(reg, sadi->base + REG_ADI_RD_CMD);\n\n\t \n\tdo {\n\t\tval = readl_relaxed(sadi->base + REG_ADI_RD_DATA);\n\t\tif (!(val & BIT_RD_CMD_BUSY))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t} while (--read_timeout);\n\n\tif (read_timeout == 0) {\n\t\tdev_err(sadi->dev, \"ADI read timeout\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sadi->data->read_check) {\n\t\tret = sadi->data->read_check(val, reg);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*read_val = val & RD_VALUE_MASK;\n\nout:\n\tif (sadi->hwlock)\n\t\thwspin_unlock_irqrestore(sadi->hwlock, &flags);\n\treturn ret;\n}\n\nstatic int sprd_adi_write(struct sprd_adi *sadi, u32 reg, u32 val)\n{\n\tu32 timeout = ADI_FIFO_DRAIN_TIMEOUT;\n\tunsigned long flags;\n\tint ret;\n\n\tif (sadi->hwlock) {\n\t\tret = hwspin_lock_timeout_irqsave(sadi->hwlock,\n\t\t\t\t\t\t  ADI_HWSPINLOCK_TIMEOUT,\n\t\t\t\t\t\t  &flags);\n\t\tif (ret) {\n\t\t\tdev_err(sadi->dev, \"get the hw lock failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sprd_adi_check_addr(sadi, reg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = sprd_adi_drain_fifo(sadi);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tdo {\n\t\tif (!sprd_adi_fifo_is_full(sadi)) {\n\t\t\t \n\t\t\twritel_relaxed(val, (void __iomem *)(sadi->slave_vbase + reg));\n\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax();\n\t} while (--timeout);\n\n\tif (timeout == 0) {\n\t\tdev_err(sadi->dev, \"write fifo is full\\n\");\n\t\tret = -EBUSY;\n\t}\n\nout:\n\tif (sadi->hwlock)\n\t\thwspin_unlock_irqrestore(sadi->hwlock, &flags);\n\treturn ret;\n}\n\nstatic int sprd_adi_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t struct spi_device *spi_dev,\n\t\t\t\t struct spi_transfer *t)\n{\n\tstruct sprd_adi *sadi = spi_controller_get_devdata(ctlr);\n\tu32 reg, val;\n\tint ret;\n\n\tif (t->rx_buf) {\n\t\treg = *(u32 *)t->rx_buf;\n\t\tret = sprd_adi_read(sadi, reg, &val);\n\t\t*(u32 *)t->rx_buf = val;\n\t} else if (t->tx_buf) {\n\t\tu32 *p = (u32 *)t->tx_buf;\n\t\treg = *p++;\n\t\tval = *p;\n\t\tret = sprd_adi_write(sadi, reg, val);\n\t} else {\n\t\tdev_err(sadi->dev, \"no buffer for transfer\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void sprd_adi_set_wdt_rst_mode(void *p)\n{\n#if IS_ENABLED(CONFIG_SPRD_WATCHDOG)\n\tu32 val;\n\tstruct sprd_adi *sadi = (struct sprd_adi *)p;\n\n\t \n\tsprd_adi_read(sadi, PMIC_RST_STATUS, &val);\n\tval |= HWRST_STATUS_WATCHDOG;\n\tsprd_adi_write(sadi, PMIC_RST_STATUS, val);\n#endif\n}\n\nstatic int sprd_adi_restart(struct notifier_block *this, unsigned long mode,\n\t\t\t\t  void *cmd, struct sprd_adi_wdg *wdg)\n{\n\tstruct sprd_adi *sadi = container_of(this, struct sprd_adi,\n\t\t\t\t\t     restart_handler);\n\tu32 val, reboot_mode = 0;\n\n\tif (!cmd)\n\t\treboot_mode = HWRST_STATUS_NORMAL;\n\telse if (!strncmp(cmd, \"recovery\", 8))\n\t\treboot_mode = HWRST_STATUS_RECOVERY;\n\telse if (!strncmp(cmd, \"alarm\", 5))\n\t\treboot_mode = HWRST_STATUS_ALARM;\n\telse if (!strncmp(cmd, \"fastsleep\", 9))\n\t\treboot_mode = HWRST_STATUS_SLEEP;\n\telse if (!strncmp(cmd, \"bootloader\", 10))\n\t\treboot_mode = HWRST_STATUS_FASTBOOT;\n\telse if (!strncmp(cmd, \"panic\", 5))\n\t\treboot_mode = HWRST_STATUS_PANIC;\n\telse if (!strncmp(cmd, \"special\", 7))\n\t\treboot_mode = HWRST_STATUS_SPECIAL;\n\telse if (!strncmp(cmd, \"cftreboot\", 9))\n\t\treboot_mode = HWRST_STATUS_CFTREBOOT;\n\telse if (!strncmp(cmd, \"autodloader\", 11))\n\t\treboot_mode = HWRST_STATUS_AUTODLOADER;\n\telse if (!strncmp(cmd, \"iqmode\", 6))\n\t\treboot_mode = HWRST_STATUS_IQMODE;\n\telse if (!strncmp(cmd, \"sprdisk\", 7))\n\t\treboot_mode = HWRST_STATUS_SPRDISK;\n\telse if (!strncmp(cmd, \"tospanic\", 8))\n\t\treboot_mode = HWRST_STATUS_SECURITY;\n\telse if (!strncmp(cmd, \"factorytest\", 11))\n\t\treboot_mode = HWRST_STATUS_FACTORYTEST;\n\telse\n\t\treboot_mode = HWRST_STATUS_NORMAL;\n\n\t \n\tsprd_adi_read(sadi, wdg->rst_sts, &val);\n\tval &= ~HWRST_STATUS_WATCHDOG;\n\tval |= reboot_mode;\n\tsprd_adi_write(sadi, wdg->rst_sts, val);\n\n\t \n\tsprd_adi_read(sadi, wdg->wdg_en, &val);\n\tval |= BIT_WDG_EN;\n\tsprd_adi_write(sadi, wdg->wdg_en, val);\n\n\t \n\tsprd_adi_read(sadi, wdg->wdg_clk, &val);\n\tval |= BIT_WDG_EN;\n\tsprd_adi_write(sadi, wdg->wdg_clk, val);\n\n\t \n\tsprd_adi_write(sadi, wdg->base + REG_WDG_LOCK, WDG_UNLOCK_KEY);\n\n\tsprd_adi_read(sadi, wdg->base + REG_WDG_CTRL, &val);\n\tval |= BIT_WDG_NEW;\n\tsprd_adi_write(sadi, wdg->base + REG_WDG_CTRL, val);\n\n\t \n\tsprd_adi_write(sadi, wdg->base + REG_WDG_LOAD_HIGH, 0);\n\tsprd_adi_write(sadi, wdg->base + REG_WDG_LOAD_LOW,\n\t\t       WDG_LOAD_VAL & WDG_LOAD_MASK);\n\n\t \n\tsprd_adi_read(sadi, wdg->base + REG_WDG_CTRL, &val);\n\tval |= BIT_WDG_RUN | BIT_WDG_RST;\n\tsprd_adi_write(sadi, wdg->base + REG_WDG_CTRL, val);\n\n\t \n\tsprd_adi_write(sadi, wdg->base + REG_WDG_LOCK, ~WDG_UNLOCK_KEY);\n\n\tmdelay(1000);\n\n\tdev_emerg(sadi->dev, \"Unable to restart system\\n\");\n\treturn NOTIFY_DONE;\n}\n\nstatic int sprd_adi_restart_sc9860(struct notifier_block *this,\n\t\t\t\t\t   unsigned long mode, void *cmd)\n{\n\tstruct sprd_adi_wdg wdg = {\n\t\t.base = PMIC_WDG_BASE,\n\t\t.rst_sts = PMIC_RST_STATUS,\n\t\t.wdg_en = PMIC_MODULE_EN,\n\t\t.wdg_clk = PMIC_CLK_EN,\n\t};\n\n\treturn sprd_adi_restart(this, mode, cmd, &wdg);\n}\n\nstatic void sprd_adi_hw_init(struct sprd_adi *sadi)\n{\n\tstruct device_node *np = sadi->dev->of_node;\n\tint i, size, chn_cnt;\n\tconst __be32 *list;\n\tu32 tmp;\n\n\t \n\twritel_relaxed(0, sadi->base + REG_ADI_CHN_PRIL);\n\twritel_relaxed(0, sadi->base + REG_ADI_CHN_PRIH);\n\n\t \n\ttmp = readl_relaxed(sadi->base + REG_ADI_GSSI_CFG0);\n\ttmp &= ~BIT_CLK_ALL_ON;\n\twritel_relaxed(tmp, sadi->base + REG_ADI_GSSI_CFG0);\n\n\t \n\tlist = of_get_property(np, \"sprd,hw-channels\", &size);\n\tif (!list || !size) {\n\t\tdev_info(sadi->dev, \"no hw channels setting in node\\n\");\n\t\treturn;\n\t}\n\n\tchn_cnt = size / 8;\n\tfor (i = 0; i < chn_cnt; i++) {\n\t\tu32 value;\n\t\tu32 chn_id = be32_to_cpu(*list++);\n\t\tu32 chn_config = be32_to_cpu(*list++);\n\n\t\t \n\t\tif (chn_id < 2)\n\t\t\tcontinue;\n\n\t\twritel_relaxed(chn_config, sadi->base +\n\t\t\t       REG_ADI_CHN_ADDR(chn_id));\n\n\t\tif (chn_id < 32) {\n\t\t\tvalue = readl_relaxed(sadi->base + REG_ADI_CHN_EN);\n\t\t\tvalue |= BIT(chn_id);\n\t\t\twritel_relaxed(value, sadi->base + REG_ADI_CHN_EN);\n\t\t} else if (chn_id < ADI_HW_CHNS) {\n\t\t\tvalue = readl_relaxed(sadi->base + REG_ADI_CHN_EN1);\n\t\t\tvalue |= BIT(chn_id - 32);\n\t\t\twritel_relaxed(value, sadi->base + REG_ADI_CHN_EN1);\n\t\t}\n\t}\n}\n\nstatic int sprd_adi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct sprd_adi_data *data;\n\tstruct spi_controller *ctlr;\n\tstruct sprd_adi *sadi;\n\tstruct resource *res;\n\tu16 num_chipselect;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"can not find the adi bus node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdev->id = of_alias_get_id(np, \"spi\");\n\tnum_chipselect = of_get_child_count(np);\n\n\tctlr = spi_alloc_master(&pdev->dev, sizeof(struct sprd_adi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, ctlr);\n\tsadi = spi_controller_get_devdata(ctlr);\n\n\tsadi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(sadi->base)) {\n\t\tret = PTR_ERR(sadi->base);\n\t\tgoto put_ctlr;\n\t}\n\n\tsadi->slave_vbase = (unsigned long)sadi->base +\n\t\t\t    data->slave_offset;\n\tsadi->slave_pbase = res->start + data->slave_offset;\n\tsadi->ctlr = ctlr;\n\tsadi->dev = &pdev->dev;\n\tsadi->data = data;\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret > 0 || (IS_ENABLED(CONFIG_HWSPINLOCK) && ret == 0)) {\n\t\tsadi->hwlock =\n\t\t\tdevm_hwspin_lock_request_specific(&pdev->dev, ret);\n\t\tif (!sadi->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto put_ctlr;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase -ENOENT:\n\t\t\tdev_info(&pdev->dev, \"no hardware spinlock supplied\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err_probe(&pdev->dev, ret, \"failed to find hwlock id\\n\");\n\t\t\tgoto put_ctlr;\n\t\t}\n\t}\n\n\tsprd_adi_hw_init(sadi);\n\n\tif (sadi->data->wdg_rst)\n\t\tsadi->data->wdg_rst(sadi);\n\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->bus_num = pdev->id;\n\tctlr->num_chipselect = num_chipselect;\n\tctlr->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tctlr->bits_per_word_mask = 0;\n\tctlr->transfer_one = sprd_adi_transfer_one;\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register SPI controller\\n\");\n\t\tgoto put_ctlr;\n\t}\n\n\tif (sadi->data->restart) {\n\t\tsadi->restart_handler.notifier_call = sadi->data->restart;\n\t\tsadi->restart_handler.priority = 128;\n\t\tret = register_restart_handler(&sadi->restart_handler);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"can not register restart handler\\n\");\n\t\t\tgoto put_ctlr;\n\t\t}\n\t}\n\n\treturn 0;\n\nput_ctlr:\n\tspi_controller_put(ctlr);\n\treturn ret;\n}\n\nstatic void sprd_adi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(&pdev->dev);\n\tstruct sprd_adi *sadi = spi_controller_get_devdata(ctlr);\n\n\tunregister_restart_handler(&sadi->restart_handler);\n}\n\nstatic struct sprd_adi_data sc9860_data = {\n\t.slave_offset = ADI_10BIT_SLAVE_OFFSET,\n\t.slave_addr_size = ADI_10BIT_SLAVE_ADDR_SIZE,\n\t.read_check = sprd_adi_read_check_r2,\n\t.restart = sprd_adi_restart_sc9860,\n\t.wdg_rst = sprd_adi_set_wdt_rst_mode,\n};\n\nstatic struct sprd_adi_data sc9863_data = {\n\t.slave_offset = ADI_12BIT_SLAVE_OFFSET,\n\t.slave_addr_size = ADI_12BIT_SLAVE_ADDR_SIZE,\n\t.read_check = sprd_adi_read_check_r3,\n};\n\nstatic struct sprd_adi_data ums512_data = {\n\t.slave_offset = ADI_15BIT_SLAVE_OFFSET,\n\t.slave_addr_size = ADI_15BIT_SLAVE_ADDR_SIZE,\n\t.read_check = sprd_adi_read_check_r3,\n};\n\nstatic const struct of_device_id sprd_adi_of_match[] = {\n\t{\n\t\t.compatible = \"sprd,sc9860-adi\",\n\t\t.data = &sc9860_data,\n\t},\n\t{\n\t\t.compatible = \"sprd,sc9863-adi\",\n\t\t.data = &sc9863_data,\n\t},\n\t{\n\t\t.compatible = \"sprd,ums512-adi\",\n\t\t.data = &ums512_data,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_adi_of_match);\n\nstatic struct platform_driver sprd_adi_driver = {\n\t.driver = {\n\t\t.name = \"sprd-adi\",\n\t\t.of_match_table = sprd_adi_of_match,\n\t},\n\t.probe = sprd_adi_probe,\n\t.remove_new = sprd_adi_remove,\n};\nmodule_platform_driver(sprd_adi_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum ADI Controller Driver\");\nMODULE_AUTHOR(\"Baolin Wang <Baolin.Wang@spreadtrum.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}