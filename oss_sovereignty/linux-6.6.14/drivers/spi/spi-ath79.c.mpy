{
  "module_name": "spi-ath79.c",
  "hash_id": "0416af4435bd876b66334f78baf19f30566db8427ab3f702f07fc7d1e6aad1fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ath79.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n\n#define DRV_NAME\t\"ath79-spi\"\n\n#define ATH79_SPI_RRW_DELAY_FACTOR\t12000\n#define MHZ\t\t\t\t(1000 * 1000)\n\n#define AR71XX_SPI_REG_FS\t\t0x00\t \n#define AR71XX_SPI_REG_CTRL\t\t0x04\t \n#define AR71XX_SPI_REG_IOC\t\t0x08\t \n#define AR71XX_SPI_REG_RDS\t\t0x0c\t \n\n#define AR71XX_SPI_FS_GPIO\t\tBIT(0)\t \n\n#define AR71XX_SPI_IOC_DO\t\tBIT(0)\t \n#define AR71XX_SPI_IOC_CLK\t\tBIT(8)\t \n#define AR71XX_SPI_IOC_CS(n)\t\tBIT(16 + (n))\n\nstruct ath79_spi {\n\tstruct spi_bitbang\tbitbang;\n\tu32\t\t\tioc_base;\n\tu32\t\t\treg_ctrl;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tunsigned int\t\trrw_delay;\n};\n\nstatic inline u32 ath79_spi_rr(struct ath79_spi *sp, unsigned int reg)\n{\n\treturn ioread32(sp->base + reg);\n}\n\nstatic inline void ath79_spi_wr(struct ath79_spi *sp, unsigned int reg, u32 val)\n{\n\tiowrite32(val, sp->base + reg);\n}\n\nstatic inline struct ath79_spi *ath79_spidev_to_sp(struct spi_device *spi)\n{\n\treturn spi_controller_get_devdata(spi->controller);\n}\n\nstatic inline void ath79_spi_delay(struct ath79_spi *sp, unsigned int nsecs)\n{\n\tif (nsecs > sp->rrw_delay)\n\t\tndelay(nsecs - sp->rrw_delay);\n}\n\nstatic void ath79_spi_chipselect(struct spi_device *spi, int is_active)\n{\n\tstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\n\tint cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;\n\tu32 cs_bit = AR71XX_SPI_IOC_CS(spi_get_chipselect(spi, 0));\n\n\tif (cs_high)\n\t\tsp->ioc_base |= cs_bit;\n\telse\n\t\tsp->ioc_base &= ~cs_bit;\n\n\tath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\n}\n\nstatic void ath79_spi_enable(struct ath79_spi *sp)\n{\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\n\n\t \n\tsp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);\n\tsp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);\n\n\t \n\tsp->ioc_base &= ~(AR71XX_SPI_IOC_DO | AR71XX_SPI_IOC_CLK);\n\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);\n}\n\nstatic void ath79_spi_disable(struct ath79_spi *sp)\n{\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, sp->reg_ctrl);\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);\n}\n\nstatic u32 ath79_spi_txrx_mode0(struct spi_device *spi, unsigned int nsecs,\n\t\t\t       u32 word, u8 bits, unsigned flags)\n{\n\tstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\n\tu32 ioc = sp->ioc_base;\n\n\t \n\tfor (word <<= (32 - bits); likely(bits); bits--) {\n\t\tu32 out;\n\n\t\tif (word & (1 << 31))\n\t\t\tout = ioc | AR71XX_SPI_IOC_DO;\n\t\telse\n\t\t\tout = ioc & ~AR71XX_SPI_IOC_DO;\n\n\t\t \n\t\tath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out);\n\t\tath79_spi_delay(sp, nsecs);\n\t\tath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out | AR71XX_SPI_IOC_CLK);\n\t\tath79_spi_delay(sp, nsecs);\n\t\tif (bits == 1)\n\t\t\tath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out);\n\n\t\tword <<= 1;\n\t}\n\n\treturn ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);\n}\n\nstatic int ath79_exec_mem_op(struct spi_mem *mem,\n\t\t\t     const struct spi_mem_op *op)\n{\n\tstruct ath79_spi *sp = ath79_spidev_to_sp(mem->spi);\n\n\t \n\tif (spi_get_chipselect(mem->spi, 0) || spi_get_csgpiod(mem->spi, 0))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (op->cmd.opcode != 0x0b || op->data.dir != SPI_MEM_DATA_IN ||\n\t    op->addr.nbytes != 3 || op->dummy.nbytes != 1)\n\t\treturn -ENOTSUPP;\n\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);\n\n\tmemcpy_fromio(op->data.buf.in, sp->base + op->addr.val, op->data.nbytes);\n\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\n\n\t \n\tath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops ath79_mem_ops = {\n\t.exec_op = ath79_exec_mem_op,\n};\n\nstatic int ath79_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct ath79_spi *sp;\n\tunsigned long rate;\n\tint ret;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*sp));\n\tif (host == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to allocate spi host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsp = spi_controller_get_devdata(host);\n\thost->dev.of_node = pdev->dev.of_node;\n\tplatform_set_drvdata(pdev, sp);\n\n\thost->use_gpio_descriptors = true;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\thost->flags = SPI_CONTROLLER_GPIO_SS;\n\thost->num_chipselect = 3;\n\thost->mem_ops = &ath79_mem_ops;\n\n\tsp->bitbang.master = host;\n\tsp->bitbang.chipselect = ath79_spi_chipselect;\n\tsp->bitbang.txrx_word[SPI_MODE_0] = ath79_spi_txrx_mode0;\n\tsp->bitbang.flags = SPI_CS_HIGH;\n\n\tsp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sp->base)) {\n\t\tret = PTR_ERR(sp->base);\n\t\tgoto err_put_host;\n\t}\n\n\tsp->clk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(sp->clk)) {\n\t\tret = PTR_ERR(sp->clk);\n\t\tgoto err_put_host;\n\t}\n\n\tret = clk_prepare_enable(sp->clk);\n\tif (ret)\n\t\tgoto err_put_host;\n\n\trate = DIV_ROUND_UP(clk_get_rate(sp->clk), MHZ);\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tsp->rrw_delay = ATH79_SPI_RRW_DELAY_FACTOR / rate;\n\tdev_dbg(&pdev->dev, \"register read/write delay is %u nsecs\\n\",\n\t\tsp->rrw_delay);\n\n\tath79_spi_enable(sp);\n\tret = spi_bitbang_start(&sp->bitbang);\n\tif (ret)\n\t\tgoto err_disable;\n\n\treturn 0;\n\nerr_disable:\n\tath79_spi_disable(sp);\nerr_clk_disable:\n\tclk_disable_unprepare(sp->clk);\nerr_put_host:\n\tspi_controller_put(host);\n\n\treturn ret;\n}\n\nstatic void ath79_spi_remove(struct platform_device *pdev)\n{\n\tstruct ath79_spi *sp = platform_get_drvdata(pdev);\n\n\tspi_bitbang_stop(&sp->bitbang);\n\tath79_spi_disable(sp);\n\tclk_disable_unprepare(sp->clk);\n\tspi_controller_put(sp->bitbang.master);\n}\n\nstatic void ath79_spi_shutdown(struct platform_device *pdev)\n{\n\tath79_spi_remove(pdev);\n}\n\nstatic const struct of_device_id ath79_spi_of_match[] = {\n\t{ .compatible = \"qca,ar7100-spi\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ath79_spi_of_match);\n\nstatic struct platform_driver ath79_spi_driver = {\n\t.probe\t\t= ath79_spi_probe,\n\t.remove_new\t= ath79_spi_remove,\n\t.shutdown\t= ath79_spi_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = ath79_spi_of_match,\n\t},\n};\nmodule_platform_driver(ath79_spi_driver);\n\nMODULE_DESCRIPTION(\"SPI controller driver for Atheros AR71XX/AR724X/AR913X\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}