{
  "module_name": "spi-dw-bt1.c",
  "hash_id": "f32cbe3abf0fe04181f56b0331616e5060133d21f4cc8e7afc90e623e3d2eea5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-dw-bt1.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/cpumask.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/spi/spi.h>\n\n#include \"spi-dw.h\"\n\n#define BT1_BOOT_DIRMAP\t\t0\n#define BT1_BOOT_REGS\t\t1\n\nstruct dw_spi_bt1 {\n\tstruct dw_spi\t\tdws;\n\tstruct clk\t\t*clk;\n\tstruct mux_control\t*mux;\n\n#ifdef CONFIG_SPI_DW_BT1_DIRMAP\n\tvoid __iomem\t\t*map;\n\tresource_size_t\t\tmap_len;\n#endif\n};\n#define to_dw_spi_bt1(_ctlr) \\\n\tcontainer_of(spi_controller_get_devdata(_ctlr), struct dw_spi_bt1, dws)\n\ntypedef int (*dw_spi_bt1_init_cb)(struct platform_device *pdev,\n\t\t\t\t    struct dw_spi_bt1 *dwsbt1);\n\n#ifdef CONFIG_SPI_DW_BT1_DIRMAP\n\nstatic int dw_spi_bt1_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct dw_spi_bt1 *dwsbt1 = to_dw_spi_bt1(desc->mem->spi->controller);\n\n\tif (!dwsbt1->map ||\n\t    !dwsbt1->dws.mem_ops.supports_op(desc->mem, &desc->info.op_tmpl))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (desc->info.offset + desc->info.length > dwsbt1->map_len ||\n\t    desc->info.op_tmpl.data.dir != SPI_MEM_DATA_IN)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n \nstatic void dw_spi_bt1_dirmap_copy_from_map(void *to, void __iomem *from, size_t len)\n{\n\tsize_t shift, chunk;\n\tu32 data;\n\n\t \n\tshift = (size_t)from & 0x3;\n\tif (shift) {\n\t\tchunk = min_t(size_t, 4 - shift, len);\n\t\tdata = readl_relaxed(from - shift);\n\t\tmemcpy(to, (char *)&data + shift, chunk);\n\t\tfrom += chunk;\n\t\tto += chunk;\n\t\tlen -= chunk;\n\t}\n\n\twhile (len >= 4) {\n\t\tdata = readl_relaxed(from);\n\t\tmemcpy(to, &data, 4);\n\t\tfrom += 4;\n\t\tto += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (len) {\n\t\tdata = readl_relaxed(from);\n\t\tmemcpy(to, &data, len);\n\t}\n}\n\nstatic ssize_t dw_spi_bt1_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t      u64 offs, size_t len, void *buf)\n{\n\tstruct dw_spi_bt1 *dwsbt1 = to_dw_spi_bt1(desc->mem->spi->controller);\n\tstruct dw_spi *dws = &dwsbt1->dws;\n\tstruct spi_mem *mem = desc->mem;\n\tstruct dw_spi_cfg cfg;\n\tint ret;\n\n\t \n\tif (offs >= dwsbt1->map_len || !len)\n\t\treturn 0;\n\n\tlen = min_t(size_t, len, dwsbt1->map_len - offs);\n\n\t \n\tcfg.tmode = DW_SPI_CTRLR0_TMOD_EPROMREAD;\n\tcfg.dfs = 8;\n\tcfg.ndf = 4;\n\tcfg.freq = mem->spi->max_speed_hz;\n\n\t \n\tdw_spi_set_cs(mem->spi, false);\n\n\tdw_spi_enable_chip(dws, 0);\n\n\tdw_spi_update_config(dws, mem->spi, &cfg);\n\n\tdw_spi_umask_intr(dws, DW_SPI_INT_RXFI);\n\n\tdw_spi_enable_chip(dws, 1);\n\n\t \n\tret = mux_control_select(dwsbt1->mux, BT1_BOOT_DIRMAP);\n\tif (ret)\n\t\treturn ret;\n\n\tdw_spi_bt1_dirmap_copy_from_map(buf, dwsbt1->map + offs, len);\n\n\tmux_control_deselect(dwsbt1->mux);\n\n\tdw_spi_set_cs(mem->spi, true);\n\n\tret = dw_spi_check_status(dws, true);\n\n\treturn ret ?: len;\n}\n\n#endif  \n\nstatic int dw_spi_bt1_std_init(struct platform_device *pdev,\n\t\t\t       struct dw_spi_bt1 *dwsbt1)\n{\n\tstruct dw_spi *dws = &dwsbt1->dws;\n\n\tdws->irq = platform_get_irq(pdev, 0);\n\tif (dws->irq < 0)\n\t\treturn dws->irq;\n\n\tdws->num_cs = 4;\n\n\t \n\tdws->max_mem_freq = 20000000U;\n\n\tdw_spi_dma_setup_generic(dws);\n\n\treturn 0;\n}\n\nstatic int dw_spi_bt1_sys_init(struct platform_device *pdev,\n\t\t\t       struct dw_spi_bt1 *dwsbt1)\n{\n\tstruct resource *mem __maybe_unused;\n\tstruct dw_spi *dws = &dwsbt1->dws;\n\n\t \n\tdwsbt1->mux = devm_mux_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(dwsbt1->mux))\n\t\treturn PTR_ERR(dwsbt1->mux);\n\n\t \n#ifdef CONFIG_SPI_DW_BT1_DIRMAP\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (mem) {\n\t\tdwsbt1->map = devm_ioremap_resource(&pdev->dev, mem);\n\t\tif (!IS_ERR(dwsbt1->map)) {\n\t\t\tdwsbt1->map_len = resource_size(mem);\n\t\t\tdws->mem_ops.dirmap_create = dw_spi_bt1_dirmap_create;\n\t\t\tdws->mem_ops.dirmap_read = dw_spi_bt1_dirmap_read;\n\t\t} else {\n\t\t\tdwsbt1->map = NULL;\n\t\t}\n\t}\n#endif  \n\n\t \n\tdws->irq = IRQ_NOTCONNECTED;\n\tdws->num_cs = 1;\n\n\t \n\tif (num_possible_cpus() > 1)\n\t\tdws->max_mem_freq = 10000000U;\n\telse\n\t\tdws->max_mem_freq = 20000000U;\n\n\treturn 0;\n}\n\nstatic int dw_spi_bt1_probe(struct platform_device *pdev)\n{\n\tdw_spi_bt1_init_cb init_func;\n\tstruct dw_spi_bt1 *dwsbt1;\n\tstruct resource *mem;\n\tstruct dw_spi *dws;\n\tint ret;\n\n\tdwsbt1 = devm_kzalloc(&pdev->dev, sizeof(struct dw_spi_bt1), GFP_KERNEL);\n\tif (!dwsbt1)\n\t\treturn -ENOMEM;\n\n\tdws = &dwsbt1->dws;\n\n\tdws->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(dws->regs))\n\t\treturn PTR_ERR(dws->regs);\n\n\tdws->paddr = mem->start;\n\n\tdwsbt1->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dwsbt1->clk))\n\t\treturn PTR_ERR(dwsbt1->clk);\n\n\tret = clk_prepare_enable(dwsbt1->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tdws->bus_num = pdev->id;\n\tdws->reg_io_width = 4;\n\tdws->max_freq = clk_get_rate(dwsbt1->clk);\n\tif (!dws->max_freq) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk;\n\t}\n\n\tinit_func = device_get_match_data(&pdev->dev);\n\tret = init_func(pdev, dwsbt1);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = dw_spi_add_host(&pdev->dev, dws);\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tgoto err_disable_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, dwsbt1);\n\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(dwsbt1->clk);\n\n\treturn ret;\n}\n\nstatic void dw_spi_bt1_remove(struct platform_device *pdev)\n{\n\tstruct dw_spi_bt1 *dwsbt1 = platform_get_drvdata(pdev);\n\n\tdw_spi_remove_host(&dwsbt1->dws);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(dwsbt1->clk);\n}\n\nstatic const struct of_device_id dw_spi_bt1_of_match[] = {\n\t{ .compatible = \"baikal,bt1-ssi\", .data = dw_spi_bt1_std_init},\n\t{ .compatible = \"baikal,bt1-sys-ssi\", .data = dw_spi_bt1_sys_init},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dw_spi_bt1_of_match);\n\nstatic struct platform_driver dw_spi_bt1_driver = {\n\t.probe\t= dw_spi_bt1_probe,\n\t.remove_new = dw_spi_bt1_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"bt1-sys-ssi\",\n\t\t.of_match_table\t= dw_spi_bt1_of_match,\n\t},\n};\nmodule_platform_driver(dw_spi_bt1_driver);\n\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 System Boot SPI Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SPI_DW_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}