{
  "module_name": "spi-sh.c",
  "hash_id": "4dc26cdbf9a3eb74e4a05757cf39384a28fd5493229bc0ae444a137ba3ca10ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sh.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/spi/spi.h>\n\n#define SPI_SH_TBR\t\t0x00\n#define SPI_SH_RBR\t\t0x00\n#define SPI_SH_CR1\t\t0x08\n#define SPI_SH_CR2\t\t0x10\n#define SPI_SH_CR3\t\t0x18\n#define SPI_SH_CR4\t\t0x20\n#define SPI_SH_CR5\t\t0x28\n\n \n#define SPI_SH_TBE\t\t0x80\n#define SPI_SH_TBF\t\t0x40\n#define SPI_SH_RBE\t\t0x20\n#define SPI_SH_RBF\t\t0x10\n#define SPI_SH_PFONRD\t\t0x08\n#define SPI_SH_SSDB\t\t0x04\n#define SPI_SH_SSD\t\t0x02\n#define SPI_SH_SSA\t\t0x01\n\n \n#define SPI_SH_RSTF\t\t0x80\n#define SPI_SH_LOOPBK\t\t0x40\n#define SPI_SH_CPOL\t\t0x20\n#define SPI_SH_CPHA\t\t0x10\n#define SPI_SH_L1M0\t\t0x08\n\n \n#define SPI_SH_MAX_BYTE\t\t0xFF\n\n \n#define SPI_SH_TBEI\t\t0x80\n#define SPI_SH_TBFI\t\t0x40\n#define SPI_SH_RBEI\t\t0x20\n#define SPI_SH_RBFI\t\t0x10\n#define SPI_SH_WPABRT\t\t0x04\n#define SPI_SH_SSS\t\t0x01\n\n \n#define SPI_SH_P1L0\t\t0x80\n#define SPI_SH_PP1L0\t\t0x40\n#define SPI_SH_MUXI\t\t0x20\n#define SPI_SH_MUXIRQ\t\t0x10\n\n#define SPI_SH_FIFO_SIZE\t32\n#define SPI_SH_SEND_TIMEOUT\t(3 * HZ)\n#define SPI_SH_RECEIVE_TIMEOUT\t(HZ >> 3)\n\n#undef DEBUG\n\nstruct spi_sh_data {\n\tvoid __iomem *addr;\n\tint irq;\n\tstruct spi_controller *host;\n\tunsigned long cr1;\n\twait_queue_head_t wait;\n\tint width;\n};\n\nstatic void spi_sh_write(struct spi_sh_data *ss, unsigned long data,\n\t\t\t     unsigned long offset)\n{\n\tif (ss->width == 8)\n\t\tiowrite8(data, ss->addr + (offset >> 2));\n\telse if (ss->width == 32)\n\t\tiowrite32(data, ss->addr + offset);\n}\n\nstatic unsigned long spi_sh_read(struct spi_sh_data *ss, unsigned long offset)\n{\n\tif (ss->width == 8)\n\t\treturn ioread8(ss->addr + (offset >> 2));\n\telse if (ss->width == 32)\n\t\treturn ioread32(ss->addr + offset);\n\telse\n\t\treturn 0;\n}\n\nstatic void spi_sh_set_bit(struct spi_sh_data *ss, unsigned long val,\n\t\t\t\tunsigned long offset)\n{\n\tunsigned long tmp;\n\n\ttmp = spi_sh_read(ss, offset);\n\ttmp |= val;\n\tspi_sh_write(ss, tmp, offset);\n}\n\nstatic void spi_sh_clear_bit(struct spi_sh_data *ss, unsigned long val,\n\t\t\t\tunsigned long offset)\n{\n\tunsigned long tmp;\n\n\ttmp = spi_sh_read(ss, offset);\n\ttmp &= ~val;\n\tspi_sh_write(ss, tmp, offset);\n}\n\nstatic void clear_fifo(struct spi_sh_data *ss)\n{\n\tspi_sh_set_bit(ss, SPI_SH_RSTF, SPI_SH_CR2);\n\tspi_sh_clear_bit(ss, SPI_SH_RSTF, SPI_SH_CR2);\n}\n\nstatic int spi_sh_wait_receive_buffer(struct spi_sh_data *ss)\n{\n\tint timeout = 100000;\n\n\twhile (spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {\n\t\tudelay(10);\n\t\tif (timeout-- < 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic int spi_sh_wait_write_buffer_empty(struct spi_sh_data *ss)\n{\n\tint timeout = 100000;\n\n\twhile (!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBE)) {\n\t\tudelay(10);\n\t\tif (timeout-- < 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic int spi_sh_send(struct spi_sh_data *ss, struct spi_message *mesg,\n\t\t\tstruct spi_transfer *t)\n{\n\tint i, retval = 0;\n\tint remain = t->len;\n\tint cur_len;\n\tunsigned char *data;\n\tlong ret;\n\n\tif (t->len)\n\t\tspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\n\n\tdata = (unsigned char *)t->tx_buf;\n\twhile (remain > 0) {\n\t\tcur_len = min(SPI_SH_FIFO_SIZE, remain);\n\t\tfor (i = 0; i < cur_len &&\n\t\t\t\t!(spi_sh_read(ss, SPI_SH_CR4) &\n\t\t\t\t\t\t\tSPI_SH_WPABRT) &&\n\t\t\t\t!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBF);\n\t\t\t\ti++)\n\t\t\tspi_sh_write(ss, (unsigned long)data[i], SPI_SH_TBR);\n\n\t\tif (spi_sh_read(ss, SPI_SH_CR4) & SPI_SH_WPABRT) {\n\t\t\t \n\t\t\tspi_sh_set_bit(ss, SPI_SH_WPABRT, SPI_SH_CR4);\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tcur_len = i;\n\n\t\tremain -= cur_len;\n\t\tdata += cur_len;\n\n\t\tif (remain > 0) {\n\t\t\tss->cr1 &= ~SPI_SH_TBE;\n\t\t\tspi_sh_set_bit(ss, SPI_SH_TBE, SPI_SH_CR4);\n\t\t\tret = wait_event_interruptible_timeout(ss->wait,\n\t\t\t\t\t\t ss->cr1 & SPI_SH_TBE,\n\t\t\t\t\t\t SPI_SH_SEND_TIMEOUT);\n\t\t\tif (ret == 0 && !(ss->cr1 & SPI_SH_TBE)) {\n\t\t\t\tprintk(KERN_ERR \"%s: timeout\\n\", __func__);\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_is_last(&t->transfer_list, &mesg->transfers)) {\n\t\tspi_sh_clear_bit(ss, SPI_SH_SSD | SPI_SH_SSDB, SPI_SH_CR1);\n\t\tspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\n\n\t\tss->cr1 &= ~SPI_SH_TBE;\n\t\tspi_sh_set_bit(ss, SPI_SH_TBE, SPI_SH_CR4);\n\t\tret = wait_event_interruptible_timeout(ss->wait,\n\t\t\t\t\t ss->cr1 & SPI_SH_TBE,\n\t\t\t\t\t SPI_SH_SEND_TIMEOUT);\n\t\tif (ret == 0 && (ss->cr1 & SPI_SH_TBE)) {\n\t\t\tprintk(KERN_ERR \"%s: timeout\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int spi_sh_receive(struct spi_sh_data *ss, struct spi_message *mesg,\n\t\t\t  struct spi_transfer *t)\n{\n\tint i;\n\tint remain = t->len;\n\tint cur_len;\n\tunsigned char *data;\n\tlong ret;\n\n\tif (t->len > SPI_SH_MAX_BYTE)\n\t\tspi_sh_write(ss, SPI_SH_MAX_BYTE, SPI_SH_CR3);\n\telse\n\t\tspi_sh_write(ss, t->len, SPI_SH_CR3);\n\n\tspi_sh_clear_bit(ss, SPI_SH_SSD | SPI_SH_SSDB, SPI_SH_CR1);\n\tspi_sh_set_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\n\n\tspi_sh_wait_write_buffer_empty(ss);\n\n\tdata = (unsigned char *)t->rx_buf;\n\twhile (remain > 0) {\n\t\tif (remain >= SPI_SH_FIFO_SIZE) {\n\t\t\tss->cr1 &= ~SPI_SH_RBF;\n\t\t\tspi_sh_set_bit(ss, SPI_SH_RBF, SPI_SH_CR4);\n\t\t\tret = wait_event_interruptible_timeout(ss->wait,\n\t\t\t\t\t\t ss->cr1 & SPI_SH_RBF,\n\t\t\t\t\t\t SPI_SH_RECEIVE_TIMEOUT);\n\t\t\tif (ret == 0 &&\n\t\t\t    spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {\n\t\t\t\tprintk(KERN_ERR \"%s: timeout\\n\", __func__);\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\tcur_len = min(SPI_SH_FIFO_SIZE, remain);\n\t\tfor (i = 0; i < cur_len; i++) {\n\t\t\tif (spi_sh_wait_receive_buffer(ss))\n\t\t\t\tbreak;\n\t\t\tdata[i] = (unsigned char)spi_sh_read(ss, SPI_SH_RBR);\n\t\t}\n\n\t\tremain -= cur_len;\n\t\tdata += cur_len;\n\t}\n\n\t \n\tif (t->len > SPI_SH_MAX_BYTE) {\n\t\tclear_fifo(ss);\n\t\tspi_sh_write(ss, 1, SPI_SH_CR3);\n\t} else {\n\t\tspi_sh_write(ss, 0, SPI_SH_CR3);\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_sh_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t\tstruct spi_message *mesg)\n{\n\tstruct spi_sh_data *ss = spi_controller_get_devdata(ctlr);\n\tstruct spi_transfer *t;\n\tint ret;\n\n\tpr_debug(\"%s: enter\\n\", __func__);\n\n\tspi_sh_clear_bit(ss, SPI_SH_SSA, SPI_SH_CR1);\n\n\tlist_for_each_entry(t, &mesg->transfers, transfer_list) {\n\t\tpr_debug(\"tx_buf = %p, rx_buf = %p\\n\",\n\t\t\t t->tx_buf, t->rx_buf);\n\t\tpr_debug(\"len = %d, delay.value = %d\\n\",\n\t\t\t t->len, t->delay.value);\n\n\t\tif (t->tx_buf) {\n\t\t\tret = spi_sh_send(ss, mesg, t);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tif (t->rx_buf) {\n\t\t\tret = spi_sh_receive(ss, mesg, t);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tmesg->actual_length += t->len;\n\t}\n\n\tmesg->status = 0;\n\tspi_finalize_current_message(ctlr);\n\n\tclear_fifo(ss);\n\tspi_sh_set_bit(ss, SPI_SH_SSD, SPI_SH_CR1);\n\tudelay(100);\n\n\tspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\n\t\t\t SPI_SH_CR1);\n\n\tclear_fifo(ss);\n\n\treturn 0;\n\n error:\n\tmesg->status = ret;\n\tspi_finalize_current_message(ctlr);\n\tif (mesg->complete)\n\t\tmesg->complete(mesg->context);\n\n\tspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\n\t\t\t SPI_SH_CR1);\n\tclear_fifo(ss);\n\n\treturn ret;\n}\n\nstatic int spi_sh_setup(struct spi_device *spi)\n{\n\tstruct spi_sh_data *ss = spi_controller_get_devdata(spi->controller);\n\n\tpr_debug(\"%s: enter\\n\", __func__);\n\n\tspi_sh_write(ss, 0xfe, SPI_SH_CR1);\t \n\tspi_sh_write(ss, 0x00, SPI_SH_CR1);\t \n\tspi_sh_write(ss, 0x00, SPI_SH_CR3);\t \n\n\tclear_fifo(ss);\n\n\t \n\tspi_sh_write(ss, spi_sh_read(ss, SPI_SH_CR2) | 0x07, SPI_SH_CR2);\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic void spi_sh_cleanup(struct spi_device *spi)\n{\n\tstruct spi_sh_data *ss = spi_controller_get_devdata(spi->controller);\n\n\tpr_debug(\"%s: enter\\n\", __func__);\n\n\tspi_sh_clear_bit(ss, SPI_SH_SSA | SPI_SH_SSDB | SPI_SH_SSD,\n\t\t\t SPI_SH_CR1);\n}\n\nstatic irqreturn_t spi_sh_irq(int irq, void *_ss)\n{\n\tstruct spi_sh_data *ss = (struct spi_sh_data *)_ss;\n\tunsigned long cr1;\n\n\tcr1 = spi_sh_read(ss, SPI_SH_CR1);\n\tif (cr1 & SPI_SH_TBE)\n\t\tss->cr1 |= SPI_SH_TBE;\n\tif (cr1 & SPI_SH_TBF)\n\t\tss->cr1 |= SPI_SH_TBF;\n\tif (cr1 & SPI_SH_RBE)\n\t\tss->cr1 |= SPI_SH_RBE;\n\tif (cr1 & SPI_SH_RBF)\n\t\tss->cr1 |= SPI_SH_RBF;\n\n\tif (ss->cr1) {\n\t\tspi_sh_clear_bit(ss, ss->cr1, SPI_SH_CR4);\n\t\twake_up(&ss->wait);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void spi_sh_remove(struct platform_device *pdev)\n{\n\tstruct spi_sh_data *ss = platform_get_drvdata(pdev);\n\n\tspi_unregister_controller(ss->host);\n\tfree_irq(ss->irq, ss);\n}\n\nstatic int spi_sh_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct spi_controller *host;\n\tstruct spi_sh_data *ss;\n\tint ret, irq;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(res == NULL)) {\n\t\tdev_err(&pdev->dev, \"invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(struct spi_sh_data));\n\tif (host == NULL) {\n\t\tdev_err(&pdev->dev, \"devm_spi_alloc_host error.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tss = spi_controller_get_devdata(host);\n\tplatform_set_drvdata(pdev, ss);\n\n\tswitch (res->flags & IORESOURCE_MEM_TYPE_MASK) {\n\tcase IORESOURCE_MEM_8BIT:\n\t\tss->width = 8;\n\t\tbreak;\n\tcase IORESOURCE_MEM_32BIT:\n\t\tss->width = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"No support width\\n\");\n\t\treturn -ENODEV;\n\t}\n\tss->irq = irq;\n\tss->host = host;\n\tss->addr = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (ss->addr == NULL) {\n\t\tdev_err(&pdev->dev, \"ioremap error.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tinit_waitqueue_head(&ss->wait);\n\n\tret = request_irq(irq, spi_sh_irq, 0, \"spi_sh\", ss);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq error\\n\");\n\t\treturn ret;\n\t}\n\n\thost->num_chipselect = 2;\n\thost->bus_num = pdev->id;\n\thost->setup = spi_sh_setup;\n\thost->transfer_one_message = spi_sh_transfer_one_message;\n\thost->cleanup = spi_sh_cleanup;\n\n\tret = spi_register_controller(host);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"spi_register_controller error.\\n\");\n\t\tgoto error3;\n\t}\n\n\treturn 0;\n\n error3:\n\tfree_irq(irq, ss);\n\treturn ret;\n}\n\nstatic struct platform_driver spi_sh_driver = {\n\t.probe = spi_sh_probe,\n\t.remove_new = spi_sh_remove,\n\t.driver = {\n\t\t.name = \"sh_spi\",\n\t},\n};\nmodule_platform_driver(spi_sh_driver);\n\nMODULE_DESCRIPTION(\"SH SPI bus driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_ALIAS(\"platform:sh_spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}