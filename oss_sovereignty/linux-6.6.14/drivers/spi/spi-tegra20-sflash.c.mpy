{
  "module_name": "spi-tegra20-sflash.c",
  "hash_id": "2dbb761476adce25cb2e828dc81a9d758af9ba8942bc399e51402b2dbdeb9e2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-tegra20-sflash.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n\n#define SPI_COMMAND\t\t\t\t0x000\n#define SPI_GO\t\t\t\t\tBIT(30)\n#define SPI_M_S\t\t\t\t\tBIT(28)\n#define SPI_ACTIVE_SCLK_MASK\t\t\t(0x3 << 26)\n#define SPI_ACTIVE_SCLK_DRIVE_LOW\t\t(0 << 26)\n#define SPI_ACTIVE_SCLK_DRIVE_HIGH\t\t(1 << 26)\n#define SPI_ACTIVE_SCLK_PULL_LOW\t\t(2 << 26)\n#define SPI_ACTIVE_SCLK_PULL_HIGH\t\t(3 << 26)\n\n#define SPI_CK_SDA_FALLING\t\t\t(1 << 21)\n#define SPI_CK_SDA_RISING\t\t\t(0 << 21)\n#define SPI_CK_SDA_MASK\t\t\t\t(1 << 21)\n#define SPI_ACTIVE_SDA\t\t\t\t(0x3 << 18)\n#define SPI_ACTIVE_SDA_DRIVE_LOW\t\t(0 << 18)\n#define SPI_ACTIVE_SDA_DRIVE_HIGH\t\t(1 << 18)\n#define SPI_ACTIVE_SDA_PULL_LOW\t\t\t(2 << 18)\n#define SPI_ACTIVE_SDA_PULL_HIGH\t\t(3 << 18)\n\n#define SPI_CS_POL_INVERT\t\t\tBIT(16)\n#define SPI_TX_EN\t\t\t\tBIT(15)\n#define SPI_RX_EN\t\t\t\tBIT(14)\n#define SPI_CS_VAL_HIGH\t\t\t\tBIT(13)\n#define SPI_CS_VAL_LOW\t\t\t\t0x0\n#define SPI_CS_SW\t\t\t\tBIT(12)\n#define SPI_CS_HW\t\t\t\t0x0\n#define SPI_CS_DELAY_MASK\t\t\t(7 << 9)\n#define SPI_CS3_EN\t\t\t\tBIT(8)\n#define SPI_CS2_EN\t\t\t\tBIT(7)\n#define SPI_CS1_EN\t\t\t\tBIT(6)\n#define SPI_CS0_EN\t\t\t\tBIT(5)\n\n#define SPI_CS_MASK\t\t\t(SPI_CS3_EN | SPI_CS2_EN |\t\\\n\t\t\t\t\tSPI_CS1_EN | SPI_CS0_EN)\n#define SPI_BIT_LENGTH(x)\t\t(((x) & 0x1f) << 0)\n\n#define SPI_MODES\t\t\t(SPI_ACTIVE_SCLK_MASK | SPI_CK_SDA_MASK)\n\n#define SPI_STATUS\t\t\t0x004\n#define SPI_BSY\t\t\t\tBIT(31)\n#define SPI_RDY\t\t\t\tBIT(30)\n#define SPI_TXF_FLUSH\t\t\tBIT(29)\n#define SPI_RXF_FLUSH\t\t\tBIT(28)\n#define SPI_RX_UNF\t\t\tBIT(27)\n#define SPI_TX_OVF\t\t\tBIT(26)\n#define SPI_RXF_EMPTY\t\t\tBIT(25)\n#define SPI_RXF_FULL\t\t\tBIT(24)\n#define SPI_TXF_EMPTY\t\t\tBIT(23)\n#define SPI_TXF_FULL\t\t\tBIT(22)\n#define SPI_BLK_CNT(count)\t\t(((count) & 0xffff) + 1)\n\n#define SPI_FIFO_ERROR\t\t\t(SPI_RX_UNF | SPI_TX_OVF)\n#define SPI_FIFO_EMPTY\t\t\t(SPI_TX_EMPTY | SPI_RX_EMPTY)\n\n#define SPI_RX_CMP\t\t\t0x8\n#define SPI_DMA_CTL\t\t\t0x0C\n#define SPI_DMA_EN\t\t\tBIT(31)\n#define SPI_IE_RXC\t\t\tBIT(27)\n#define SPI_IE_TXC\t\t\tBIT(26)\n#define SPI_PACKED\t\t\tBIT(20)\n#define SPI_RX_TRIG_MASK\t\t(0x3 << 18)\n#define SPI_RX_TRIG_1W\t\t\t(0x0 << 18)\n#define SPI_RX_TRIG_4W\t\t\t(0x1 << 18)\n#define SPI_TX_TRIG_MASK\t\t(0x3 << 16)\n#define SPI_TX_TRIG_1W\t\t\t(0x0 << 16)\n#define SPI_TX_TRIG_4W\t\t\t(0x1 << 16)\n#define SPI_DMA_BLK_COUNT(count)\t(((count) - 1) & 0xFFFF)\n\n#define SPI_TX_FIFO\t\t\t0x10\n#define SPI_RX_FIFO\t\t\t0x20\n\n#define DATA_DIR_TX\t\t\t(1 << 0)\n#define DATA_DIR_RX\t\t\t(1 << 1)\n\n#define MAX_CHIP_SELECT\t\t\t4\n#define SPI_FIFO_DEPTH\t\t\t4\n#define SPI_DMA_TIMEOUT               (msecs_to_jiffies(1000))\n\nstruct tegra_sflash_data {\n\tstruct device\t\t\t\t*dev;\n\tstruct spi_master\t\t\t*master;\n\tspinlock_t\t\t\t\tlock;\n\n\tstruct clk\t\t\t\t*clk;\n\tstruct reset_control\t\t\t*rst;\n\tvoid __iomem\t\t\t\t*base;\n\tunsigned\t\t\t\tirq;\n\tu32\t\t\t\t\tcur_speed;\n\n\tstruct spi_device\t\t\t*cur_spi;\n\tunsigned\t\t\t\tcur_pos;\n\tunsigned\t\t\t\tcur_len;\n\tunsigned\t\t\t\tbytes_per_word;\n\tunsigned\t\t\t\tcur_direction;\n\tunsigned\t\t\t\tcurr_xfer_words;\n\n\tunsigned\t\t\t\tcur_rx_pos;\n\tunsigned\t\t\t\tcur_tx_pos;\n\n\tu32\t\t\t\t\ttx_status;\n\tu32\t\t\t\t\trx_status;\n\tu32\t\t\t\t\tstatus_reg;\n\n\tu32\t\t\t\t\tdef_command_reg;\n\tu32\t\t\t\t\tcommand_reg;\n\tu32\t\t\t\t\tdma_control_reg;\n\n\tstruct completion\t\t\txfer_completion;\n\tstruct spi_transfer\t\t\t*curr_xfer;\n};\n\nstatic int tegra_sflash_runtime_suspend(struct device *dev);\nstatic int tegra_sflash_runtime_resume(struct device *dev);\n\nstatic inline u32 tegra_sflash_readl(struct tegra_sflash_data *tsd,\n\t\tunsigned long reg)\n{\n\treturn readl(tsd->base + reg);\n}\n\nstatic inline void tegra_sflash_writel(struct tegra_sflash_data *tsd,\n\t\tu32 val, unsigned long reg)\n{\n\twritel(val, tsd->base + reg);\n}\n\nstatic void tegra_sflash_clear_status(struct tegra_sflash_data *tsd)\n{\n\t \n\ttegra_sflash_writel(tsd, SPI_RDY | SPI_FIFO_ERROR, SPI_STATUS);\n}\n\nstatic unsigned tegra_sflash_calculate_curr_xfer_param(\n\tstruct spi_device *spi, struct tegra_sflash_data *tsd,\n\tstruct spi_transfer *t)\n{\n\tunsigned remain_len = t->len - tsd->cur_pos;\n\tunsigned max_word;\n\n\ttsd->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);\n\tmax_word = remain_len / tsd->bytes_per_word;\n\tif (max_word > SPI_FIFO_DEPTH)\n\t\tmax_word = SPI_FIFO_DEPTH;\n\ttsd->curr_xfer_words = max_word;\n\treturn max_word;\n}\n\nstatic unsigned tegra_sflash_fill_tx_fifo_from_client_txbuf(\n\tstruct tegra_sflash_data *tsd, struct spi_transfer *t)\n{\n\tunsigned nbytes;\n\tu32 status;\n\tunsigned max_n_32bit = tsd->curr_xfer_words;\n\tu8 *tx_buf = (u8 *)t->tx_buf + tsd->cur_tx_pos;\n\n\tif (max_n_32bit > SPI_FIFO_DEPTH)\n\t\tmax_n_32bit = SPI_FIFO_DEPTH;\n\tnbytes = max_n_32bit * tsd->bytes_per_word;\n\n\tstatus = tegra_sflash_readl(tsd, SPI_STATUS);\n\twhile (!(status & SPI_TXF_FULL)) {\n\t\tint i;\n\t\tu32 x = 0;\n\n\t\tfor (i = 0; nbytes && (i < tsd->bytes_per_word);\n\t\t\t\t\t\t\ti++, nbytes--)\n\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\ttegra_sflash_writel(tsd, x, SPI_TX_FIFO);\n\t\tif (!nbytes)\n\t\t\tbreak;\n\n\t\tstatus = tegra_sflash_readl(tsd, SPI_STATUS);\n\t}\n\ttsd->cur_tx_pos += max_n_32bit * tsd->bytes_per_word;\n\treturn max_n_32bit;\n}\n\nstatic int tegra_sflash_read_rx_fifo_to_client_rxbuf(\n\t\tstruct tegra_sflash_data *tsd, struct spi_transfer *t)\n{\n\tu32 status;\n\tunsigned int read_words = 0;\n\tu8 *rx_buf = (u8 *)t->rx_buf + tsd->cur_rx_pos;\n\n\tstatus = tegra_sflash_readl(tsd, SPI_STATUS);\n\twhile (!(status & SPI_RXF_EMPTY)) {\n\t\tint i;\n\t\tu32 x = tegra_sflash_readl(tsd, SPI_RX_FIFO);\n\n\t\tfor (i = 0; (i < tsd->bytes_per_word); i++)\n\t\t\t*rx_buf++ = (x >> (i*8)) & 0xFF;\n\t\tread_words++;\n\t\tstatus = tegra_sflash_readl(tsd, SPI_STATUS);\n\t}\n\ttsd->cur_rx_pos += read_words * tsd->bytes_per_word;\n\treturn 0;\n}\n\nstatic int tegra_sflash_start_cpu_based_transfer(\n\t\tstruct tegra_sflash_data *tsd, struct spi_transfer *t)\n{\n\tu32 val = 0;\n\tunsigned cur_words;\n\n\tif (tsd->cur_direction & DATA_DIR_TX)\n\t\tval |= SPI_IE_TXC;\n\n\tif (tsd->cur_direction & DATA_DIR_RX)\n\t\tval |= SPI_IE_RXC;\n\n\ttegra_sflash_writel(tsd, val, SPI_DMA_CTL);\n\ttsd->dma_control_reg = val;\n\n\tif (tsd->cur_direction & DATA_DIR_TX)\n\t\tcur_words = tegra_sflash_fill_tx_fifo_from_client_txbuf(tsd, t);\n\telse\n\t\tcur_words = tsd->curr_xfer_words;\n\tval |= SPI_DMA_BLK_COUNT(cur_words);\n\ttegra_sflash_writel(tsd, val, SPI_DMA_CTL);\n\ttsd->dma_control_reg = val;\n\tval |= SPI_DMA_EN;\n\ttegra_sflash_writel(tsd, val, SPI_DMA_CTL);\n\treturn 0;\n}\n\nstatic int tegra_sflash_start_transfer_one(struct spi_device *spi,\n\t\tstruct spi_transfer *t, bool is_first_of_msg,\n\t\tbool is_single_xfer)\n{\n\tstruct tegra_sflash_data *tsd = spi_master_get_devdata(spi->master);\n\tu32 speed;\n\tu32 command;\n\n\tspeed = t->speed_hz;\n\tif (speed != tsd->cur_speed) {\n\t\tclk_set_rate(tsd->clk, speed);\n\t\ttsd->cur_speed = speed;\n\t}\n\n\ttsd->cur_spi = spi;\n\ttsd->cur_pos = 0;\n\ttsd->cur_rx_pos = 0;\n\ttsd->cur_tx_pos = 0;\n\ttsd->curr_xfer = t;\n\ttegra_sflash_calculate_curr_xfer_param(spi, tsd, t);\n\tif (is_first_of_msg) {\n\t\tcommand = tsd->def_command_reg;\n\t\tcommand |= SPI_BIT_LENGTH(t->bits_per_word - 1);\n\t\tcommand |= SPI_CS_VAL_HIGH;\n\n\t\tcommand &= ~SPI_MODES;\n\t\tif (spi->mode & SPI_CPHA)\n\t\t\tcommand |= SPI_CK_SDA_FALLING;\n\n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tcommand |= SPI_ACTIVE_SCLK_DRIVE_HIGH;\n\t\telse\n\t\t\tcommand |= SPI_ACTIVE_SCLK_DRIVE_LOW;\n\t\tcommand |= SPI_CS0_EN << spi_get_chipselect(spi, 0);\n\t} else {\n\t\tcommand = tsd->command_reg;\n\t\tcommand &= ~SPI_BIT_LENGTH(~0);\n\t\tcommand |= SPI_BIT_LENGTH(t->bits_per_word - 1);\n\t\tcommand &= ~(SPI_RX_EN | SPI_TX_EN);\n\t}\n\n\ttsd->cur_direction = 0;\n\tif (t->rx_buf) {\n\t\tcommand |= SPI_RX_EN;\n\t\ttsd->cur_direction |= DATA_DIR_RX;\n\t}\n\tif (t->tx_buf) {\n\t\tcommand |= SPI_TX_EN;\n\t\ttsd->cur_direction |= DATA_DIR_TX;\n\t}\n\ttegra_sflash_writel(tsd, command, SPI_COMMAND);\n\ttsd->command_reg = command;\n\n\treturn tegra_sflash_start_cpu_based_transfer(tsd, t);\n}\n\nstatic int tegra_sflash_transfer_one_message(struct spi_master *master,\n\t\t\tstruct spi_message *msg)\n{\n\tbool is_first_msg = true;\n\tint single_xfer;\n\tstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\n\tstruct spi_transfer *xfer;\n\tstruct spi_device *spi = msg->spi;\n\tint ret;\n\n\tmsg->status = 0;\n\tmsg->actual_length = 0;\n\tsingle_xfer = list_is_singular(&msg->transfers);\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\treinit_completion(&tsd->xfer_completion);\n\t\tret = tegra_sflash_start_transfer_one(spi, xfer,\n\t\t\t\t\tis_first_msg, single_xfer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tsd->dev,\n\t\t\t\t\"spi can not start transfer, err %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tis_first_msg = false;\n\t\tret = wait_for_completion_timeout(&tsd->xfer_completion,\n\t\t\t\t\t\tSPI_DMA_TIMEOUT);\n\t\tif (WARN_ON(ret == 0)) {\n\t\t\tdev_err(tsd->dev,\n\t\t\t\t\"spi transfer timeout, err %d\\n\", ret);\n\t\t\tret = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (tsd->tx_status ||  tsd->rx_status) {\n\t\t\tdev_err(tsd->dev, \"Error in Transfer\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tmsg->actual_length += xfer->len;\n\t\tif (xfer->cs_change && xfer->delay.value) {\n\t\t\ttegra_sflash_writel(tsd, tsd->def_command_reg,\n\t\t\t\t\tSPI_COMMAND);\n\t\t\tspi_transfer_delay_exec(xfer);\n\t\t}\n\t}\n\tret = 0;\nexit:\n\ttegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);\n\tmsg->status = ret;\n\tspi_finalize_current_message(master);\n\treturn ret;\n}\n\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_sflash_data *tsd)\n{\n\tstruct spi_transfer *t = tsd->curr_xfer;\n\n\tspin_lock(&tsd->lock);\n\tif (tsd->tx_status || tsd->rx_status || (tsd->status_reg & SPI_BSY)) {\n\t\tdev_err(tsd->dev,\n\t\t\t\"CpuXfer ERROR bit set 0x%x\\n\", tsd->status_reg);\n\t\tdev_err(tsd->dev,\n\t\t\t\"CpuXfer 0x%08x:0x%08x\\n\", tsd->command_reg,\n\t\t\t\ttsd->dma_control_reg);\n\t\treset_control_assert(tsd->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(tsd->rst);\n\t\tcomplete(&tsd->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\tif (tsd->cur_direction & DATA_DIR_RX)\n\t\ttegra_sflash_read_rx_fifo_to_client_rxbuf(tsd, t);\n\n\tif (tsd->cur_direction & DATA_DIR_TX)\n\t\ttsd->cur_pos = tsd->cur_tx_pos;\n\telse\n\t\ttsd->cur_pos = tsd->cur_rx_pos;\n\n\tif (tsd->cur_pos == t->len) {\n\t\tcomplete(&tsd->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\ttegra_sflash_calculate_curr_xfer_param(tsd->cur_spi, tsd, t);\n\ttegra_sflash_start_cpu_based_transfer(tsd, t);\nexit:\n\tspin_unlock(&tsd->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_sflash_isr(int irq, void *context_data)\n{\n\tstruct tegra_sflash_data *tsd = context_data;\n\n\ttsd->status_reg = tegra_sflash_readl(tsd, SPI_STATUS);\n\tif (tsd->cur_direction & DATA_DIR_TX)\n\t\ttsd->tx_status = tsd->status_reg & SPI_TX_OVF;\n\n\tif (tsd->cur_direction & DATA_DIR_RX)\n\t\ttsd->rx_status = tsd->status_reg & SPI_RX_UNF;\n\ttegra_sflash_clear_status(tsd);\n\n\treturn handle_cpu_based_xfer(tsd);\n}\n\nstatic const struct of_device_id tegra_sflash_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-sflash\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_sflash_of_match);\n\nstatic int tegra_sflash_probe(struct platform_device *pdev)\n{\n\tstruct spi_master\t*master;\n\tstruct tegra_sflash_data\t*tsd;\n\tint ret;\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_device(tegra_sflash_of_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*tsd));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"master allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA;\n\tmaster->transfer_one_message = tegra_sflash_transfer_one_message;\n\tmaster->auto_runtime_pm = true;\n\tmaster->num_chipselect = MAX_CHIP_SELECT;\n\n\tplatform_set_drvdata(pdev, master);\n\ttsd = spi_master_get_devdata(master);\n\ttsd->master = master;\n\ttsd->dev = &pdev->dev;\n\tspin_lock_init(&tsd->lock);\n\n\tif (of_property_read_u32(tsd->dev->of_node, \"spi-max-frequency\",\n\t\t\t\t &master->max_speed_hz))\n\t\tmaster->max_speed_hz = 25000000;  \n\n\ttsd->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tsd->base)) {\n\t\tret = PTR_ERR(tsd->base);\n\t\tgoto exit_free_master;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto exit_free_master;\n\ttsd->irq = ret;\n\n\tret = request_irq(tsd->irq, tegra_sflash_isr, 0,\n\t\t\tdev_name(&pdev->dev), tsd);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register ISR for IRQ %d\\n\",\n\t\t\t\t\ttsd->irq);\n\t\tgoto exit_free_master;\n\t}\n\n\ttsd->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tsd->clk)) {\n\t\tdev_err(&pdev->dev, \"can not get clock\\n\");\n\t\tret = PTR_ERR(tsd->clk);\n\t\tgoto exit_free_irq;\n\t}\n\n\ttsd->rst = devm_reset_control_get_exclusive(&pdev->dev, \"spi\");\n\tif (IS_ERR(tsd->rst)) {\n\t\tdev_err(&pdev->dev, \"can not get reset\\n\");\n\t\tret = PTR_ERR(tsd->rst);\n\t\tgoto exit_free_irq;\n\t}\n\n\tinit_completion(&tsd->xfer_completion);\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = tegra_sflash_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto exit_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pm runtime get failed, e = %d\\n\", ret);\n\t\tgoto exit_pm_disable;\n\t}\n\n\t \n\treset_control_assert(tsd->rst);\n\tudelay(2);\n\treset_control_deassert(tsd->rst);\n\n\ttsd->def_command_reg  = SPI_M_S | SPI_CS_SW;\n\ttegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);\n\tpm_runtime_put(&pdev->dev);\n\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can not register to master err %d\\n\", ret);\n\t\tgoto exit_pm_disable;\n\t}\n\treturn ret;\n\nexit_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ttegra_sflash_runtime_suspend(&pdev->dev);\nexit_free_irq:\n\tfree_irq(tsd->irq, tsd);\nexit_free_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void tegra_sflash_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct tegra_sflash_data\t*tsd = spi_master_get_devdata(master);\n\n\tfree_irq(tsd->irq, tsd);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ttegra_sflash_runtime_suspend(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_sflash_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\n\treturn spi_master_suspend(master);\n}\n\nstatic int tegra_sflash_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm runtime failed, e = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ttegra_sflash_writel(tsd, tsd->command_reg, SPI_COMMAND);\n\tpm_runtime_put(dev);\n\n\treturn spi_master_resume(master);\n}\n#endif\n\nstatic int tegra_sflash_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\n\n\t \n\ttegra_sflash_readl(tsd, SPI_COMMAND);\n\n\tclk_disable_unprepare(tsd->clk);\n\treturn 0;\n}\n\nstatic int tegra_sflash_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(tsd->clk);\n\tif (ret < 0) {\n\t\tdev_err(tsd->dev, \"clk_prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops slink_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_sflash_runtime_suspend,\n\t\ttegra_sflash_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_sflash_suspend, tegra_sflash_resume)\n};\nstatic struct platform_driver tegra_sflash_driver = {\n\t.driver = {\n\t\t.name\t\t= \"spi-tegra-sflash\",\n\t\t.pm\t\t= &slink_pm_ops,\n\t\t.of_match_table\t= tegra_sflash_of_match,\n\t},\n\t.probe =\ttegra_sflash_probe,\n\t.remove_new =\ttegra_sflash_remove,\n};\nmodule_platform_driver(tegra_sflash_driver);\n\nMODULE_ALIAS(\"platform:spi-tegra-sflash\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra20 Serial Flash Controller Driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}