{
  "module_name": "spi-sun6i.c",
  "hash_id": "ac735d7e410cfaa8b8d7beb9567054e6f140b3961a96f66051f8b246cdcb3626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sun6i.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/dmaengine.h>\n\n#include <linux/spi/spi.h>\n\n#define SUN6I_AUTOSUSPEND_TIMEOUT\t2000\n\n#define SUN6I_FIFO_DEPTH\t\t128\n#define SUN8I_FIFO_DEPTH\t\t64\n\n#define SUN6I_GBL_CTL_REG\t\t0x04\n#define SUN6I_GBL_CTL_BUS_ENABLE\t\tBIT(0)\n#define SUN6I_GBL_CTL_MASTER\t\t\tBIT(1)\n#define SUN6I_GBL_CTL_TP\t\t\tBIT(7)\n#define SUN6I_GBL_CTL_RST\t\t\tBIT(31)\n\n#define SUN6I_TFR_CTL_REG\t\t0x08\n#define SUN6I_TFR_CTL_CPHA\t\t\tBIT(0)\n#define SUN6I_TFR_CTL_CPOL\t\t\tBIT(1)\n#define SUN6I_TFR_CTL_SPOL\t\t\tBIT(2)\n#define SUN6I_TFR_CTL_CS_MASK\t\t\t0x30\n#define SUN6I_TFR_CTL_CS(cs)\t\t\t(((cs) << 4) & SUN6I_TFR_CTL_CS_MASK)\n#define SUN6I_TFR_CTL_CS_MANUAL\t\t\tBIT(6)\n#define SUN6I_TFR_CTL_CS_LEVEL\t\t\tBIT(7)\n#define SUN6I_TFR_CTL_DHB\t\t\tBIT(8)\n#define SUN6I_TFR_CTL_SDC\t\t\tBIT(11)\n#define SUN6I_TFR_CTL_FBS\t\t\tBIT(12)\n#define SUN6I_TFR_CTL_SDM\t\t\tBIT(13)\n#define SUN6I_TFR_CTL_XCH\t\t\tBIT(31)\n\n#define SUN6I_INT_CTL_REG\t\t0x10\n#define SUN6I_INT_CTL_RF_RDY\t\t\tBIT(0)\n#define SUN6I_INT_CTL_TF_ERQ\t\t\tBIT(4)\n#define SUN6I_INT_CTL_RF_OVF\t\t\tBIT(8)\n#define SUN6I_INT_CTL_TC\t\t\tBIT(12)\n\n#define SUN6I_INT_STA_REG\t\t0x14\n\n#define SUN6I_FIFO_CTL_REG\t\t0x18\n#define SUN6I_FIFO_CTL_RF_RDY_TRIG_LEVEL_MASK\t0xff\n#define SUN6I_FIFO_CTL_RF_DRQ_EN\t\tBIT(8)\n#define SUN6I_FIFO_CTL_RF_RDY_TRIG_LEVEL_BITS\t0\n#define SUN6I_FIFO_CTL_RF_RST\t\t\tBIT(15)\n#define SUN6I_FIFO_CTL_TF_ERQ_TRIG_LEVEL_MASK\t0xff\n#define SUN6I_FIFO_CTL_TF_ERQ_TRIG_LEVEL_BITS\t16\n#define SUN6I_FIFO_CTL_TF_DRQ_EN\t\tBIT(24)\n#define SUN6I_FIFO_CTL_TF_RST\t\t\tBIT(31)\n\n#define SUN6I_FIFO_STA_REG\t\t0x1c\n#define SUN6I_FIFO_STA_RF_CNT_MASK\t\tGENMASK(7, 0)\n#define SUN6I_FIFO_STA_TF_CNT_MASK\t\tGENMASK(23, 16)\n\n#define SUN6I_CLK_CTL_REG\t\t0x24\n#define SUN6I_CLK_CTL_CDR2_MASK\t\t\t0xff\n#define SUN6I_CLK_CTL_CDR2(div)\t\t\t(((div) & SUN6I_CLK_CTL_CDR2_MASK) << 0)\n#define SUN6I_CLK_CTL_CDR1_MASK\t\t\t0xf\n#define SUN6I_CLK_CTL_CDR1(div)\t\t\t(((div) & SUN6I_CLK_CTL_CDR1_MASK) << 8)\n#define SUN6I_CLK_CTL_DRS\t\t\tBIT(12)\n\n#define SUN6I_MAX_XFER_SIZE\t\t0xffffff\n\n#define SUN6I_BURST_CNT_REG\t\t0x30\n\n#define SUN6I_XMIT_CNT_REG\t\t0x34\n\n#define SUN6I_BURST_CTL_CNT_REG\t\t0x38\n#define SUN6I_BURST_CTL_CNT_STC_MASK\t\tGENMASK(23, 0)\n#define SUN6I_BURST_CTL_CNT_DRM\t\t\tBIT(28)\n#define SUN6I_BURST_CTL_CNT_QUAD_EN\t\tBIT(29)\n\n#define SUN6I_TXDATA_REG\t\t0x200\n#define SUN6I_RXDATA_REG\t\t0x300\n\nstruct sun6i_spi_cfg {\n\tunsigned long\t\tfifo_depth;\n\tbool\t\t\thas_clk_ctl;\n\tu32\t\t\tmode_bits;\n};\n\nstruct sun6i_spi {\n\tstruct spi_master\t*master;\n\tvoid __iomem\t\t*base_addr;\n\tdma_addr_t\t\tdma_addr_rx;\n\tdma_addr_t\t\tdma_addr_tx;\n\tstruct clk\t\t*hclk;\n\tstruct clk\t\t*mclk;\n\tstruct reset_control\t*rstc;\n\n\tstruct completion\tdone;\n\tstruct completion\tdma_rx_done;\n\n\tconst u8\t\t*tx_buf;\n\tu8\t\t\t*rx_buf;\n\tint\t\t\tlen;\n\tconst struct sun6i_spi_cfg *cfg;\n};\n\nstatic inline u32 sun6i_spi_read(struct sun6i_spi *sspi, u32 reg)\n{\n\treturn readl(sspi->base_addr + reg);\n}\n\nstatic inline void sun6i_spi_write(struct sun6i_spi *sspi, u32 reg, u32 value)\n{\n\twritel(value, sspi->base_addr + reg);\n}\n\nstatic inline u32 sun6i_spi_get_rx_fifo_count(struct sun6i_spi *sspi)\n{\n\tu32 reg = sun6i_spi_read(sspi, SUN6I_FIFO_STA_REG);\n\n\treturn FIELD_GET(SUN6I_FIFO_STA_RF_CNT_MASK, reg);\n}\n\nstatic inline u32 sun6i_spi_get_tx_fifo_count(struct sun6i_spi *sspi)\n{\n\tu32 reg = sun6i_spi_read(sspi, SUN6I_FIFO_STA_REG);\n\n\treturn FIELD_GET(SUN6I_FIFO_STA_TF_CNT_MASK, reg);\n}\n\nstatic inline void sun6i_spi_disable_interrupt(struct sun6i_spi *sspi, u32 mask)\n{\n\tu32 reg = sun6i_spi_read(sspi, SUN6I_INT_CTL_REG);\n\n\treg &= ~mask;\n\tsun6i_spi_write(sspi, SUN6I_INT_CTL_REG, reg);\n}\n\nstatic inline void sun6i_spi_drain_fifo(struct sun6i_spi *sspi)\n{\n\tu32 len;\n\tu8 byte;\n\n\t \n\tlen = sun6i_spi_get_rx_fifo_count(sspi);\n\n\twhile (len--) {\n\t\tbyte = readb(sspi->base_addr + SUN6I_RXDATA_REG);\n\t\tif (sspi->rx_buf)\n\t\t\t*sspi->rx_buf++ = byte;\n\t}\n}\n\nstatic inline void sun6i_spi_fill_fifo(struct sun6i_spi *sspi)\n{\n\tu32 cnt;\n\tint len;\n\tu8 byte;\n\n\t \n\tcnt = sspi->cfg->fifo_depth - sun6i_spi_get_tx_fifo_count(sspi);\n\n\tlen = min((int)cnt, sspi->len);\n\n\twhile (len--) {\n\t\tbyte = sspi->tx_buf ? *sspi->tx_buf++ : 0;\n\t\twriteb(byte, sspi->base_addr + SUN6I_TXDATA_REG);\n\t\tsspi->len--;\n\t}\n}\n\nstatic void sun6i_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct sun6i_spi *sspi = spi_master_get_devdata(spi->master);\n\tu32 reg;\n\n\treg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\n\treg &= ~SUN6I_TFR_CTL_CS_MASK;\n\treg |= SUN6I_TFR_CTL_CS(spi_get_chipselect(spi, 0));\n\n\tif (enable)\n\t\treg |= SUN6I_TFR_CTL_CS_LEVEL;\n\telse\n\t\treg &= ~SUN6I_TFR_CTL_CS_LEVEL;\n\n\tsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg);\n}\n\nstatic size_t sun6i_spi_max_transfer_size(struct spi_device *spi)\n{\n\treturn SUN6I_MAX_XFER_SIZE - 1;\n}\n\nstatic void sun6i_spi_dma_rx_cb(void *param)\n{\n\tstruct sun6i_spi *sspi = param;\n\n\tcomplete(&sspi->dma_rx_done);\n}\n\nstatic int sun6i_spi_prepare_dma(struct sun6i_spi *sspi,\n\t\t\t\t struct spi_transfer *tfr)\n{\n\tstruct dma_async_tx_descriptor *rxdesc, *txdesc;\n\tstruct spi_master *master = sspi->master;\n\n\trxdesc = NULL;\n\tif (tfr->rx_buf) {\n\t\tstruct dma_slave_config rxconf = {\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_addr = sspi->dma_addr_rx,\n\t\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\n\t\t\t.src_maxburst = 8,\n\t\t};\n\n\t\tdmaengine_slave_config(master->dma_rx, &rxconf);\n\n\t\trxdesc = dmaengine_prep_slave_sg(master->dma_rx,\n\t\t\t\t\t\t tfr->rx_sg.sgl,\n\t\t\t\t\t\t tfr->rx_sg.nents,\n\t\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT);\n\t\tif (!rxdesc)\n\t\t\treturn -EINVAL;\n\t\trxdesc->callback_param = sspi;\n\t\trxdesc->callback = sun6i_spi_dma_rx_cb;\n\t}\n\n\ttxdesc = NULL;\n\tif (tfr->tx_buf) {\n\t\tstruct dma_slave_config txconf = {\n\t\t\t.direction = DMA_MEM_TO_DEV,\n\t\t\t.dst_addr = sspi->dma_addr_tx,\n\t\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t\t.dst_maxburst = 8,\n\t\t};\n\n\t\tdmaengine_slave_config(master->dma_tx, &txconf);\n\n\t\ttxdesc = dmaengine_prep_slave_sg(master->dma_tx,\n\t\t\t\t\t\t tfr->tx_sg.sgl,\n\t\t\t\t\t\t tfr->tx_sg.nents,\n\t\t\t\t\t\t DMA_MEM_TO_DEV,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT);\n\t\tif (!txdesc) {\n\t\t\tif (rxdesc)\n\t\t\t\tdmaengine_terminate_sync(master->dma_rx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (tfr->rx_buf) {\n\t\tdmaengine_submit(rxdesc);\n\t\tdma_async_issue_pending(master->dma_rx);\n\t}\n\n\tif (tfr->tx_buf) {\n\t\tdmaengine_submit(txdesc);\n\t\tdma_async_issue_pending(master->dma_tx);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun6i_spi_transfer_one(struct spi_master *master,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *tfr)\n{\n\tstruct sun6i_spi *sspi = spi_master_get_devdata(master);\n\tunsigned int div, div_cdr1, div_cdr2, timeout;\n\tunsigned int start, end, tx_time;\n\tunsigned int trig_level;\n\tunsigned int tx_len = 0, rx_len = 0, nbits = 0;\n\tbool use_dma;\n\tint ret = 0;\n\tu32 reg;\n\n\tif (tfr->len > SUN6I_MAX_XFER_SIZE)\n\t\treturn -EINVAL;\n\n\treinit_completion(&sspi->done);\n\treinit_completion(&sspi->dma_rx_done);\n\tsspi->tx_buf = tfr->tx_buf;\n\tsspi->rx_buf = tfr->rx_buf;\n\tsspi->len = tfr->len;\n\tuse_dma = master->can_dma ? master->can_dma(master, spi, tfr) : false;\n\n\t \n\tsun6i_spi_write(sspi, SUN6I_INT_STA_REG, ~0);\n\n\t \n\tsun6i_spi_write(sspi, SUN6I_FIFO_CTL_REG,\n\t\t\tSUN6I_FIFO_CTL_RF_RST | SUN6I_FIFO_CTL_TF_RST);\n\n\treg = 0;\n\n\tif (!use_dma) {\n\t\t \n\t\ttrig_level = sspi->cfg->fifo_depth / 4 * 3;\n\t} else {\n\t\t \n\t\ttrig_level = sspi->cfg->fifo_depth / 2;\n\n\t\tif (tfr->tx_buf)\n\t\t\treg |= SUN6I_FIFO_CTL_TF_DRQ_EN;\n\t\tif (tfr->rx_buf)\n\t\t\treg |= SUN6I_FIFO_CTL_RF_DRQ_EN;\n\t}\n\n\treg |= (trig_level << SUN6I_FIFO_CTL_RF_RDY_TRIG_LEVEL_BITS) |\n\t       (trig_level << SUN6I_FIFO_CTL_TF_ERQ_TRIG_LEVEL_BITS);\n\n\tsun6i_spi_write(sspi, SUN6I_FIFO_CTL_REG, reg);\n\n\t \n\treg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\n\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= SUN6I_TFR_CTL_CPOL;\n\telse\n\t\treg &= ~SUN6I_TFR_CTL_CPOL;\n\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= SUN6I_TFR_CTL_CPHA;\n\telse\n\t\treg &= ~SUN6I_TFR_CTL_CPHA;\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\treg |= SUN6I_TFR_CTL_FBS;\n\telse\n\t\treg &= ~SUN6I_TFR_CTL_FBS;\n\n\t \n\tif (sspi->rx_buf) {\n\t\treg &= ~SUN6I_TFR_CTL_DHB;\n\t\trx_len = tfr->len;\n\t} else {\n\t\treg |= SUN6I_TFR_CTL_DHB;\n\t}\n\n\t \n\treg |= SUN6I_TFR_CTL_CS_MANUAL;\n\n\tsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg);\n\n\tif (sspi->cfg->has_clk_ctl) {\n\t\tunsigned int mclk_rate = clk_get_rate(sspi->mclk);\n\n\t\t \n\t\tif (mclk_rate < (2 * tfr->speed_hz)) {\n\t\t\tclk_set_rate(sspi->mclk, 2 * tfr->speed_hz);\n\t\t\tmclk_rate = clk_get_rate(sspi->mclk);\n\t\t}\n\n\t\t \n\t\tdiv_cdr1 = DIV_ROUND_UP(mclk_rate, tfr->speed_hz);\n\t\tdiv_cdr2 = DIV_ROUND_UP(div_cdr1, 2);\n\t\tif (div_cdr2 <= (SUN6I_CLK_CTL_CDR2_MASK + 1)) {\n\t\t\treg = SUN6I_CLK_CTL_CDR2(div_cdr2 - 1) | SUN6I_CLK_CTL_DRS;\n\t\t\ttfr->effective_speed_hz = mclk_rate / (2 * div_cdr2);\n\t\t} else {\n\t\t\tdiv = min(SUN6I_CLK_CTL_CDR1_MASK, order_base_2(div_cdr1));\n\t\t\treg = SUN6I_CLK_CTL_CDR1(div);\n\t\t\ttfr->effective_speed_hz = mclk_rate / (1 << div);\n\t\t}\n\n\t\tsun6i_spi_write(sspi, SUN6I_CLK_CTL_REG, reg);\n\t} else {\n\t\tclk_set_rate(sspi->mclk, tfr->speed_hz);\n\t\ttfr->effective_speed_hz = clk_get_rate(sspi->mclk);\n\n\t\t \n\t\treg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\n\t\treg &= ~(SUN6I_TFR_CTL_SDM | SUN6I_TFR_CTL_SDC);\n\n\t\tif (tfr->effective_speed_hz <= 24000000)\n\t\t\treg |= SUN6I_TFR_CTL_SDM;\n\t\telse if (tfr->effective_speed_hz >= 80000000)\n\t\t\treg |= SUN6I_TFR_CTL_SDC;\n\n\t\tsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg);\n\t}\n\n\t \n\treg = sun6i_spi_read(sspi, SUN6I_GBL_CTL_REG);\n\treg |= SUN6I_GBL_CTL_BUS_ENABLE;\n\tsun6i_spi_write(sspi, SUN6I_GBL_CTL_REG, reg);\n\n\t \n\tif (sspi->tx_buf) {\n\t\ttx_len = tfr->len;\n\t\tnbits = tfr->tx_nbits;\n\t} else if (tfr->rx_buf) {\n\t\tnbits = tfr->rx_nbits;\n\t}\n\n\tswitch (nbits) {\n\tcase SPI_NBITS_DUAL:\n\t\treg = SUN6I_BURST_CTL_CNT_DRM;\n\t\tbreak;\n\tcase SPI_NBITS_QUAD:\n\t\treg = SUN6I_BURST_CTL_CNT_QUAD_EN;\n\t\tbreak;\n\tcase SPI_NBITS_SINGLE:\n\tdefault:\n\t\treg = FIELD_PREP(SUN6I_BURST_CTL_CNT_STC_MASK, tx_len);\n\t}\n\n\t \n\tsun6i_spi_write(sspi, SUN6I_BURST_CTL_CNT_REG, reg);\n\tsun6i_spi_write(sspi, SUN6I_BURST_CNT_REG, tfr->len);\n\tsun6i_spi_write(sspi, SUN6I_XMIT_CNT_REG, tx_len);\n\n\tif (!use_dma) {\n\t\t \n\t\tsun6i_spi_fill_fifo(sspi);\n\t} else {\n\t\tret = sun6i_spi_prepare_dma(sspi, tfr);\n\t\tif (ret) {\n\t\t\tdev_warn(&master->dev,\n\t\t\t\t \"%s: prepare DMA failed, ret=%d\",\n\t\t\t\t dev_name(&spi->dev), ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treg = SUN6I_INT_CTL_TC;\n\n\tif (!use_dma) {\n\t\tif (rx_len > sspi->cfg->fifo_depth)\n\t\t\treg |= SUN6I_INT_CTL_RF_RDY;\n\t\tif (tx_len > sspi->cfg->fifo_depth)\n\t\t\treg |= SUN6I_INT_CTL_TF_ERQ;\n\t}\n\n\tsun6i_spi_write(sspi, SUN6I_INT_CTL_REG, reg);\n\n\t \n\treg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\n\tsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg | SUN6I_TFR_CTL_XCH);\n\n\ttx_time = spi_controller_xfer_timeout(master, tfr);\n\tstart = jiffies;\n\ttimeout = wait_for_completion_timeout(&sspi->done,\n\t\t\t\t\t      msecs_to_jiffies(tx_time));\n\n\tif (!use_dma) {\n\t\tsun6i_spi_drain_fifo(sspi);\n\t} else {\n\t\tif (timeout && rx_len) {\n\t\t\t \n\t\t\ttimeout = wait_for_completion_timeout(&sspi->dma_rx_done,\n\t\t\t\t\t\t\t      timeout);\n\t\t\tif (!timeout)\n\t\t\t\tdev_warn(&master->dev, \"RX DMA timeout\\n\");\n\t\t}\n\t}\n\n\tend = jiffies;\n\tif (!timeout) {\n\t\tdev_warn(&master->dev,\n\t\t\t \"%s: timeout transferring %u bytes@%iHz for %i(%i)ms\",\n\t\t\t dev_name(&spi->dev), tfr->len, tfr->speed_hz,\n\t\t\t jiffies_to_msecs(end - start), tx_time);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\tsun6i_spi_write(sspi, SUN6I_INT_CTL_REG, 0);\n\n\tif (ret && use_dma) {\n\t\tdmaengine_terminate_sync(master->dma_rx);\n\t\tdmaengine_terminate_sync(master->dma_tx);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t sun6i_spi_handler(int irq, void *dev_id)\n{\n\tstruct sun6i_spi *sspi = dev_id;\n\tu32 status = sun6i_spi_read(sspi, SUN6I_INT_STA_REG);\n\n\t \n\tif (status & SUN6I_INT_CTL_TC) {\n\t\tsun6i_spi_write(sspi, SUN6I_INT_STA_REG, SUN6I_INT_CTL_TC);\n\t\tcomplete(&sspi->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & SUN6I_INT_CTL_RF_RDY) {\n\t\tsun6i_spi_drain_fifo(sspi);\n\t\t \n\t\tsun6i_spi_write(sspi, SUN6I_INT_STA_REG, SUN6I_INT_CTL_RF_RDY);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & SUN6I_INT_CTL_TF_ERQ) {\n\t\tsun6i_spi_fill_fifo(sspi);\n\n\t\tif (!sspi->len)\n\t\t\t \n\t\t\tsun6i_spi_disable_interrupt(sspi, SUN6I_INT_CTL_TF_ERQ);\n\n\t\t \n\t\tsun6i_spi_write(sspi, SUN6I_INT_STA_REG, SUN6I_INT_CTL_TF_ERQ);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int sun6i_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct sun6i_spi *sspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(sspi->hclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't enable AHB clock\\n\");\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(sspi->mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't enable module clock\\n\");\n\t\tgoto err;\n\t}\n\n\tret = reset_control_deassert(sspi->rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't deassert the device from reset\\n\");\n\t\tgoto err2;\n\t}\n\n\tsun6i_spi_write(sspi, SUN6I_GBL_CTL_REG,\n\t\t\tSUN6I_GBL_CTL_MASTER | SUN6I_GBL_CTL_TP);\n\n\treturn 0;\n\nerr2:\n\tclk_disable_unprepare(sspi->mclk);\nerr:\n\tclk_disable_unprepare(sspi->hclk);\nout:\n\treturn ret;\n}\n\nstatic int sun6i_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct sun6i_spi *sspi = spi_master_get_devdata(master);\n\n\treset_control_assert(sspi->rstc);\n\tclk_disable_unprepare(sspi->mclk);\n\tclk_disable_unprepare(sspi->hclk);\n\n\treturn 0;\n}\n\nstatic bool sun6i_spi_can_dma(struct spi_master *master,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct sun6i_spi *sspi = spi_master_get_devdata(master);\n\n\t \n\treturn xfer->len > sspi->cfg->fifo_depth;\n}\n\nstatic int sun6i_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct sun6i_spi *sspi;\n\tstruct resource *mem;\n\tint ret = 0, irq;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(struct sun6i_spi));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate SPI Master\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, master);\n\tsspi = spi_master_get_devdata(master);\n\n\tsspi->base_addr = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(sspi->base_addr)) {\n\t\tret = PTR_ERR(sspi->base_addr);\n\t\tgoto err_free_master;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENXIO;\n\t\tgoto err_free_master;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, sun6i_spi_handler,\n\t\t\t       0, \"sun6i-spi\", sspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request IRQ\\n\");\n\t\tgoto err_free_master;\n\t}\n\n\tsspi->master = master;\n\tsspi->cfg = of_device_get_match_data(&pdev->dev);\n\n\tmaster->max_speed_hz = 100 * 1000 * 1000;\n\tmaster->min_speed_hz = 3 * 1000;\n\tmaster->use_gpio_descriptors = true;\n\tmaster->set_cs = sun6i_spi_set_cs;\n\tmaster->transfer_one = sun6i_spi_transfer_one;\n\tmaster->num_chipselect = 4;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST |\n\t\t\t    sspi->cfg->mode_bits;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->auto_runtime_pm = true;\n\tmaster->max_transfer_size = sun6i_spi_max_transfer_size;\n\n\tsspi->hclk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(sspi->hclk)) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire AHB clock\\n\");\n\t\tret = PTR_ERR(sspi->hclk);\n\t\tgoto err_free_master;\n\t}\n\n\tsspi->mclk = devm_clk_get(&pdev->dev, \"mod\");\n\tif (IS_ERR(sspi->mclk)) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire module clock\\n\");\n\t\tret = PTR_ERR(sspi->mclk);\n\t\tgoto err_free_master;\n\t}\n\n\tinit_completion(&sspi->done);\n\tinit_completion(&sspi->dma_rx_done);\n\n\tsspi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(sspi->rstc)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get reset controller\\n\");\n\t\tret = PTR_ERR(sspi->rstc);\n\t\tgoto err_free_master;\n\t}\n\n\tmaster->dma_tx = dma_request_chan(&pdev->dev, \"tx\");\n\tif (IS_ERR(master->dma_tx)) {\n\t\t \n\t\tif (PTR_ERR(master->dma_tx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_free_master;\n\t\t}\n\t\tdev_warn(&pdev->dev, \"Failed to request TX DMA channel\\n\");\n\t\tmaster->dma_tx = NULL;\n\t}\n\n\tmaster->dma_rx = dma_request_chan(&pdev->dev, \"rx\");\n\tif (IS_ERR(master->dma_rx)) {\n\t\tif (PTR_ERR(master->dma_rx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_free_dma_tx;\n\t\t}\n\t\tdev_warn(&pdev->dev, \"Failed to request RX DMA channel\\n\");\n\t\tmaster->dma_rx = NULL;\n\t}\n\n\tif (master->dma_tx && master->dma_rx) {\n\t\tsspi->dma_addr_tx = mem->start + SUN6I_TXDATA_REG;\n\t\tsspi->dma_addr_rx = mem->start + SUN6I_RXDATA_REG;\n\t\tmaster->can_dma = sun6i_spi_can_dma;\n\t}\n\n\t \n\tret = sun6i_spi_runtime_resume(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't resume the device\\n\");\n\t\tgoto err_free_dma_rx;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, SUN6I_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register SPI master\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tsun6i_spi_runtime_suspend(&pdev->dev);\nerr_free_dma_rx:\n\tif (master->dma_rx)\n\t\tdma_release_channel(master->dma_rx);\nerr_free_dma_tx:\n\tif (master->dma_tx)\n\t\tdma_release_channel(master->dma_tx);\nerr_free_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void sun6i_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\n\tpm_runtime_force_suspend(&pdev->dev);\n\n\tif (master->dma_tx)\n\t\tdma_release_channel(master->dma_tx);\n\tif (master->dma_rx)\n\t\tdma_release_channel(master->dma_rx);\n}\n\nstatic const struct sun6i_spi_cfg sun6i_a31_spi_cfg = {\n\t.fifo_depth\t= SUN6I_FIFO_DEPTH,\n\t.has_clk_ctl\t= true,\n};\n\nstatic const struct sun6i_spi_cfg sun8i_h3_spi_cfg = {\n\t.fifo_depth\t= SUN8I_FIFO_DEPTH,\n\t.has_clk_ctl\t= true,\n};\n\nstatic const struct sun6i_spi_cfg sun50i_r329_spi_cfg = {\n\t.fifo_depth\t= SUN8I_FIFO_DEPTH,\n\t.mode_bits\t= SPI_RX_DUAL | SPI_TX_DUAL | SPI_RX_QUAD | SPI_TX_QUAD,\n};\n\nstatic const struct of_device_id sun6i_spi_match[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-spi\", .data = &sun6i_a31_spi_cfg },\n\t{ .compatible = \"allwinner,sun8i-h3-spi\",  .data = &sun8i_h3_spi_cfg },\n\t{\n\t\t.compatible = \"allwinner,sun50i-r329-spi\",\n\t\t.data = &sun50i_r329_spi_cfg\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sun6i_spi_match);\n\nstatic const struct dev_pm_ops sun6i_spi_pm_ops = {\n\t.runtime_resume\t\t= sun6i_spi_runtime_resume,\n\t.runtime_suspend\t= sun6i_spi_runtime_suspend,\n};\n\nstatic struct platform_driver sun6i_spi_driver = {\n\t.probe\t= sun6i_spi_probe,\n\t.remove_new = sun6i_spi_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"sun6i-spi\",\n\t\t.of_match_table\t= sun6i_spi_match,\n\t\t.pm\t\t= &sun6i_spi_pm_ops,\n\t},\n};\nmodule_platform_driver(sun6i_spi_driver);\n\nMODULE_AUTHOR(\"Pan Nan <pannan@allwinnertech.com>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A31 SPI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}