{
  "module_name": "spi-npcm-pspi.c",
  "hash_id": "69f038ed3c7cb955f548c91c1b2d7999eec3eed56f7a71c33a7dd5bd8e5b82da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-npcm-pspi.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/reset.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\nstruct npcm_pspi {\n\tstruct completion xfer_done;\n\tstruct reset_control *reset;\n\tstruct spi_master *master;\n\tunsigned int tx_bytes;\n\tunsigned int rx_bytes;\n\tvoid __iomem *base;\n\tbool is_save_param;\n\tu8 bits_per_word;\n\tconst u8 *tx_buf;\n\tstruct clk *clk;\n\tu32 speed_hz;\n\tu8 *rx_buf;\n\tu16 mode;\n\tu32 id;\n};\n\n#define DRIVER_NAME \"npcm-pspi\"\n\n#define NPCM_PSPI_DATA\t\t0x00\n#define NPCM_PSPI_CTL1\t\t0x02\n#define NPCM_PSPI_STAT\t\t0x04\n\n \n#define NPCM_PSPI_CTL1_SPIEN\tBIT(0)\n#define NPCM_PSPI_CTL1_MOD\tBIT(2)\n#define NPCM_PSPI_CTL1_EIR\tBIT(5)\n#define NPCM_PSPI_CTL1_EIW\tBIT(6)\n#define NPCM_PSPI_CTL1_SCM\tBIT(7)\n#define NPCM_PSPI_CTL1_SCIDL\tBIT(8)\n#define NPCM_PSPI_CTL1_SCDV6_0\tGENMASK(15, 9)\n\n#define NPCM_PSPI_STAT_BSY\tBIT(0)\n#define NPCM_PSPI_STAT_RBF\tBIT(1)\n\n \n#define NPCM_PSPI_TIMEOUT_MS\t\t2000\n#define NPCM_PSPI_MAX_CLK_DIVIDER\t256\n#define NPCM_PSPI_MIN_CLK_DIVIDER\t4\n#define NPCM_PSPI_DEFAULT_CLK\t\t25000000\n\nstatic inline unsigned int bytes_per_word(unsigned int bits)\n{\n\treturn bits <= 8 ? 1 : 2;\n}\n\nstatic inline void npcm_pspi_irq_enable(struct npcm_pspi *priv, u16 mask)\n{\n\tu16 val;\n\n\tval = ioread16(priv->base + NPCM_PSPI_CTL1);\n\tval |= mask;\n\tiowrite16(val, priv->base + NPCM_PSPI_CTL1);\n}\n\nstatic inline void npcm_pspi_irq_disable(struct npcm_pspi *priv, u16 mask)\n{\n\tu16 val;\n\n\tval = ioread16(priv->base + NPCM_PSPI_CTL1);\n\tval &= ~mask;\n\tiowrite16(val, priv->base + NPCM_PSPI_CTL1);\n}\n\nstatic inline void npcm_pspi_enable(struct npcm_pspi *priv)\n{\n\tu16 val;\n\n\tval = ioread16(priv->base + NPCM_PSPI_CTL1);\n\tval |= NPCM_PSPI_CTL1_SPIEN;\n\tiowrite16(val, priv->base + NPCM_PSPI_CTL1);\n}\n\nstatic inline void npcm_pspi_disable(struct npcm_pspi *priv)\n{\n\tu16 val;\n\n\tval = ioread16(priv->base + NPCM_PSPI_CTL1);\n\tval &= ~NPCM_PSPI_CTL1_SPIEN;\n\tiowrite16(val, priv->base + NPCM_PSPI_CTL1);\n}\n\nstatic void npcm_pspi_set_mode(struct spi_device *spi)\n{\n\tstruct npcm_pspi *priv = spi_master_get_devdata(spi->master);\n\tu16 regtemp;\n\tu16 mode_val;\n\n\tswitch (spi->mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\t\tmode_val = 0;\n\t\tbreak;\n\tcase SPI_MODE_1:\n\t\tmode_val = NPCM_PSPI_CTL1_SCIDL;\n\t\tbreak;\n\tcase SPI_MODE_2:\n\t\tmode_val = NPCM_PSPI_CTL1_SCM;\n\t\tbreak;\n\tcase SPI_MODE_3:\n\t\tmode_val = NPCM_PSPI_CTL1_SCIDL | NPCM_PSPI_CTL1_SCM;\n\t\tbreak;\n\t}\n\n\tregtemp = ioread16(priv->base + NPCM_PSPI_CTL1);\n\tregtemp &= ~(NPCM_PSPI_CTL1_SCM | NPCM_PSPI_CTL1_SCIDL);\n\tiowrite16(regtemp | mode_val, priv->base + NPCM_PSPI_CTL1);\n}\n\nstatic void npcm_pspi_set_transfer_size(struct npcm_pspi *priv, int size)\n{\n\tu16 regtemp;\n\n\tregtemp = ioread16(NPCM_PSPI_CTL1 + priv->base);\n\n\tswitch (size) {\n\tcase 8:\n\t\tregtemp &= ~NPCM_PSPI_CTL1_MOD;\n\t\tbreak;\n\tcase 16:\n\t\tregtemp |= NPCM_PSPI_CTL1_MOD;\n\t\tbreak;\n\t}\n\n\tiowrite16(regtemp, NPCM_PSPI_CTL1 + priv->base);\n}\n\nstatic void npcm_pspi_set_baudrate(struct npcm_pspi *priv, unsigned int speed)\n{\n\tu32 ckdiv;\n\tu16 regtemp;\n\n\t \n\tckdiv = DIV_ROUND_CLOSEST(clk_get_rate(priv->clk), (2 * speed)) - 1;\n\n\tregtemp = ioread16(NPCM_PSPI_CTL1 + priv->base);\n\tregtemp &= ~NPCM_PSPI_CTL1_SCDV6_0;\n\tiowrite16(regtemp | (ckdiv << 9), NPCM_PSPI_CTL1 + priv->base);\n}\n\nstatic void npcm_pspi_setup_transfer(struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *t)\n{\n\tstruct npcm_pspi *priv = spi_master_get_devdata(spi->master);\n\n\tpriv->tx_buf = t->tx_buf;\n\tpriv->rx_buf = t->rx_buf;\n\tpriv->tx_bytes = t->len;\n\tpriv->rx_bytes = t->len;\n\n\tif (!priv->is_save_param || priv->mode != spi->mode) {\n\t\tnpcm_pspi_set_mode(spi);\n\t\tpriv->mode = spi->mode;\n\t}\n\n\t \n\tif (priv->bits_per_word == 8 && !(t->len & 0x1))\n\t\tt->bits_per_word = 16;\n\n\tif (!priv->is_save_param || priv->bits_per_word != t->bits_per_word) {\n\t\tnpcm_pspi_set_transfer_size(priv, t->bits_per_word);\n\t\tpriv->bits_per_word = t->bits_per_word;\n\t}\n\n\tif (!priv->is_save_param || priv->speed_hz != t->speed_hz) {\n\t\tnpcm_pspi_set_baudrate(priv, t->speed_hz);\n\t\tpriv->speed_hz = t->speed_hz;\n\t}\n\n\tif (!priv->is_save_param)\n\t\tpriv->is_save_param = true;\n}\n\nstatic void npcm_pspi_send(struct npcm_pspi *priv)\n{\n\tint wsize;\n\tu16 val;\n\n\twsize = min(bytes_per_word(priv->bits_per_word), priv->tx_bytes);\n\tpriv->tx_bytes -= wsize;\n\n\tif (!priv->tx_buf)\n\t\treturn;\n\n\tswitch (wsize) {\n\tcase 1:\n\t\tval = *priv->tx_buf++;\n\t\tiowrite8(val, NPCM_PSPI_DATA + priv->base);\n\t\tbreak;\n\tcase 2:\n\t\tval = *priv->tx_buf++;\n\t\tval = *priv->tx_buf++ | (val << 8);\n\t\tiowrite16(val, NPCM_PSPI_DATA + priv->base);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n}\n\nstatic void npcm_pspi_recv(struct npcm_pspi *priv)\n{\n\tint rsize;\n\tu16 val;\n\n\trsize = min(bytes_per_word(priv->bits_per_word), priv->rx_bytes);\n\tpriv->rx_bytes -= rsize;\n\n\tif (!priv->rx_buf)\n\t\treturn;\n\n\tswitch (rsize) {\n\tcase 1:\n\t\t*priv->rx_buf++ = ioread8(priv->base + NPCM_PSPI_DATA);\n\t\tbreak;\n\tcase 2:\n\t\tval = ioread16(priv->base + NPCM_PSPI_DATA);\n\t\t*priv->rx_buf++ = (val >> 8);\n\t\t*priv->rx_buf++ = val & 0xff;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n}\n\nstatic int npcm_pspi_transfer_one(struct spi_master *master,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct npcm_pspi *priv = spi_master_get_devdata(master);\n\tint status;\n\n\tnpcm_pspi_setup_transfer(spi, t);\n\treinit_completion(&priv->xfer_done);\n\tnpcm_pspi_enable(priv);\n\tstatus = wait_for_completion_timeout(&priv->xfer_done,\n\t\t\t\t\t     msecs_to_jiffies\n\t\t\t\t\t     (NPCM_PSPI_TIMEOUT_MS));\n\tif (status == 0) {\n\t\tnpcm_pspi_disable(priv);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int npcm_pspi_prepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct npcm_pspi *priv = spi_master_get_devdata(master);\n\n\tnpcm_pspi_irq_enable(priv, NPCM_PSPI_CTL1_EIR | NPCM_PSPI_CTL1_EIW);\n\n\treturn 0;\n}\n\nstatic int npcm_pspi_unprepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct npcm_pspi *priv = spi_master_get_devdata(master);\n\n\tnpcm_pspi_irq_disable(priv, NPCM_PSPI_CTL1_EIR | NPCM_PSPI_CTL1_EIW);\n\n\treturn 0;\n}\n\nstatic void npcm_pspi_reset_hw(struct npcm_pspi *priv)\n{\n\treset_control_assert(priv->reset);\n\tudelay(5);\n\treset_control_deassert(priv->reset);\n}\n\nstatic irqreturn_t npcm_pspi_handler(int irq, void *dev_id)\n{\n\tstruct npcm_pspi *priv = dev_id;\n\tu8 stat;\n\n\tstat = ioread8(priv->base + NPCM_PSPI_STAT);\n\n\tif (!priv->tx_buf && !priv->rx_buf)\n\t\treturn IRQ_NONE;\n\n\tif (priv->tx_buf) {\n\t\tif (stat & NPCM_PSPI_STAT_RBF) {\n\t\t\tioread8(NPCM_PSPI_DATA + priv->base);\n\t\t\tif (priv->tx_bytes == 0) {\n\t\t\t\tnpcm_pspi_disable(priv);\n\t\t\t\tcomplete(&priv->xfer_done);\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\n\t\tif ((stat & NPCM_PSPI_STAT_BSY) == 0)\n\t\t\tif (priv->tx_bytes)\n\t\t\t\tnpcm_pspi_send(priv);\n\t}\n\n\tif (priv->rx_buf) {\n\t\tif (stat & NPCM_PSPI_STAT_RBF) {\n\t\t\tif (!priv->rx_bytes)\n\t\t\t\treturn IRQ_NONE;\n\n\t\t\tnpcm_pspi_recv(priv);\n\n\t\t\tif (!priv->rx_bytes) {\n\t\t\t\tnpcm_pspi_disable(priv);\n\t\t\t\tcomplete(&priv->xfer_done);\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\n\t\tif (((stat & NPCM_PSPI_STAT_BSY) == 0) && !priv->tx_buf)\n\t\t\tiowrite8(0x0, NPCM_PSPI_DATA + priv->base);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int npcm_pspi_probe(struct platform_device *pdev)\n{\n\tstruct npcm_pspi *priv;\n\tstruct spi_master *master;\n\tunsigned long clk_hz;\n\tint irq;\n\tint ret;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*priv));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tpriv = spi_master_get_devdata(master);\n\tpriv->master = master;\n\tpriv->is_save_param = false;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto out_master_put;\n\t}\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto out_master_put;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tgoto out_master_put;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_disable_clk;\n\t}\n\n\tpriv->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->reset)) {\n\t\tret = PTR_ERR(priv->reset);\n\t\tgoto out_disable_clk;\n\t}\n\n\t \n\tnpcm_pspi_reset_hw(priv);\n\n\tret = devm_request_irq(&pdev->dev, irq, npcm_pspi_handler, 0,\n\t\t\t       \"npcm-pspi\", priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\tgoto out_disable_clk;\n\t}\n\n\tinit_completion(&priv->xfer_done);\n\n\tclk_hz = clk_get_rate(priv->clk);\n\n\tmaster->max_speed_hz = DIV_ROUND_UP(clk_hz, NPCM_PSPI_MIN_CLK_DIVIDER);\n\tmaster->min_speed_hz = DIV_ROUND_UP(clk_hz, NPCM_PSPI_MAX_CLK_DIVIDER);\n\tmaster->mode_bits = SPI_CPHA | SPI_CPOL;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->bus_num = -1;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n\tmaster->transfer_one = npcm_pspi_transfer_one;\n\tmaster->prepare_transfer_hardware =\n\t\tnpcm_pspi_prepare_transfer_hardware;\n\tmaster->unprepare_transfer_hardware =\n\t\tnpcm_pspi_unprepare_transfer_hardware;\n\tmaster->use_gpio_descriptors = true;\n\n\t \n\tnpcm_pspi_set_baudrate(priv, NPCM_PSPI_DEFAULT_CLK);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret)\n\t\tgoto out_disable_clk;\n\n\tpr_info(\"NPCM Peripheral SPI %d probed\\n\", master->bus_num);\n\n\treturn 0;\n\nout_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\nout_master_put:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void npcm_pspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct npcm_pspi *priv = spi_master_get_devdata(master);\n\n\tnpcm_pspi_reset_hw(priv);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic const struct of_device_id npcm_pspi_match[] = {\n\t{ .compatible = \"nuvoton,npcm750-pspi\", .data = NULL },\n\t{ .compatible = \"nuvoton,npcm845-pspi\", .data = NULL },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, npcm_pspi_match);\n\nstatic struct platform_driver npcm_pspi_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= npcm_pspi_match,\n\t},\n\t.probe\t\t= npcm_pspi_probe,\n\t.remove_new\t= npcm_pspi_remove,\n};\nmodule_platform_driver(npcm_pspi_driver);\n\nMODULE_DESCRIPTION(\"NPCM peripheral SPI Controller driver\");\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}