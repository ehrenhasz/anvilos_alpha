{
  "module_name": "spi-altera-dfl.c",
  "hash_id": "04cb0642086d0b508177beb65581e520b156c33fc4d2116b78f2601ed564a1f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-altera-dfl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/bitfield.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/altera.h>\n#include <linux/dfl.h>\n\n#define FME_FEATURE_ID_MAX10_SPI\t0xe\n#define FME_FEATURE_REV_MAX10_SPI_N5010\t0x1\n\n#define SPI_CORE_PARAMETER      0x8\n#define SHIFT_MODE              BIT_ULL(1)\n#define SHIFT_MODE_MSB          0\n#define SHIFT_MODE_LSB          1\n#define DATA_WIDTH              GENMASK_ULL(7, 2)\n#define NUM_CHIPSELECT          GENMASK_ULL(13, 8)\n#define CLK_POLARITY            BIT_ULL(14)\n#define CLK_PHASE               BIT_ULL(15)\n#define PERIPHERAL_ID           GENMASK_ULL(47, 32)\n#define SPI_CLK                 GENMASK_ULL(31, 22)\n#define SPI_INDIRECT_ACC_OFST   0x10\n\n#define INDIRECT_ADDR           (SPI_INDIRECT_ACC_OFST+0x0)\n#define INDIRECT_WR             BIT_ULL(8)\n#define INDIRECT_RD             BIT_ULL(9)\n#define INDIRECT_RD_DATA        (SPI_INDIRECT_ACC_OFST+0x8)\n#define INDIRECT_DATA_MASK      GENMASK_ULL(31, 0)\n#define INDIRECT_DEBUG          BIT_ULL(32)\n#define INDIRECT_WR_DATA        (SPI_INDIRECT_ACC_OFST+0x10)\n#define INDIRECT_TIMEOUT        10000\n\nstatic int indirect_bus_reg_read(void *context, unsigned int reg,\n\t\t\t\t unsigned int *val)\n{\n\tvoid __iomem *base = context;\n\tint loops;\n\tu64 v;\n\n\twriteq((reg >> 2) | INDIRECT_RD, base + INDIRECT_ADDR);\n\n\tloops = 0;\n\twhile ((readq(base + INDIRECT_ADDR) & INDIRECT_RD) &&\n\t       (loops++ < INDIRECT_TIMEOUT))\n\t\tcpu_relax();\n\n\tif (loops >= INDIRECT_TIMEOUT) {\n\t\tpr_err(\"%s timed out %d\\n\", __func__, loops);\n\t\treturn -ETIME;\n\t}\n\n\tv = readq(base + INDIRECT_RD_DATA);\n\n\t*val = v & INDIRECT_DATA_MASK;\n\n\treturn 0;\n}\n\nstatic int indirect_bus_reg_write(void *context, unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\tvoid __iomem *base = context;\n\tint loops;\n\n\twriteq(val, base + INDIRECT_WR_DATA);\n\twriteq((reg >> 2) | INDIRECT_WR, base + INDIRECT_ADDR);\n\n\tloops = 0;\n\twhile ((readq(base + INDIRECT_ADDR) & INDIRECT_WR) &&\n\t       (loops++ < INDIRECT_TIMEOUT))\n\t\tcpu_relax();\n\n\tif (loops >= INDIRECT_TIMEOUT) {\n\t\tpr_err(\"%s timed out %d\\n\", __func__, loops);\n\t\treturn -ETIME;\n\t}\n\treturn 0;\n}\n\nstatic const struct regmap_config indirect_regbus_cfg = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n\t.max_register = 24,\n\n\t.reg_write = indirect_bus_reg_write,\n\t.reg_read = indirect_bus_reg_read,\n};\n\nstatic void config_spi_host(void __iomem *base, struct spi_controller *host)\n{\n\tu64 v;\n\n\tv = readq(base + SPI_CORE_PARAMETER);\n\n\thost->mode_bits = SPI_CS_HIGH;\n\tif (FIELD_GET(CLK_POLARITY, v))\n\t\thost->mode_bits |= SPI_CPOL;\n\tif (FIELD_GET(CLK_PHASE, v))\n\t\thost->mode_bits |= SPI_CPHA;\n\n\thost->num_chipselect = FIELD_GET(NUM_CHIPSELECT, v);\n\thost->bits_per_word_mask =\n\t\tSPI_BPW_RANGE_MASK(1, FIELD_GET(DATA_WIDTH, v));\n}\n\nstatic int dfl_spi_altera_probe(struct dfl_device *dfl_dev)\n{\n\tstruct spi_board_info board_info = { 0 };\n\tstruct device *dev = &dfl_dev->dev;\n\tstruct spi_controller *host;\n\tstruct altera_spi *hw;\n\tvoid __iomem *base;\n\tint err;\n\n\thost = devm_spi_alloc_host(dev, sizeof(struct altera_spi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->bus_num = -1;\n\n\thw = spi_controller_get_devdata(host);\n\n\thw->dev = dev;\n\n\tbase = devm_ioremap_resource(dev, &dfl_dev->mmio_res);\n\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tconfig_spi_host(base, host);\n\tdev_dbg(dev, \"%s cs %u bpm 0x%x mode 0x%x\\n\", __func__,\n\t\thost->num_chipselect, host->bits_per_word_mask,\n\t\thost->mode_bits);\n\n\thw->regmap = devm_regmap_init(dev, NULL, base, &indirect_regbus_cfg);\n\tif (IS_ERR(hw->regmap))\n\t\treturn PTR_ERR(hw->regmap);\n\n\thw->irq = -EINVAL;\n\n\taltera_spi_init_host(host);\n\n\terr = devm_spi_register_controller(dev, host);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"%s failed to register spi host\\n\",\n\t\t\t\t     __func__);\n\n\tif (dfl_dev->revision == FME_FEATURE_REV_MAX10_SPI_N5010)\n\t\tstrscpy(board_info.modalias, \"m10-n5010\", SPI_NAME_SIZE);\n\telse\n\t\tstrscpy(board_info.modalias, \"m10-d5005\", SPI_NAME_SIZE);\n\n\tboard_info.max_speed_hz = 12500000;\n\tboard_info.bus_num = 0;\n\tboard_info.chip_select = 0;\n\n\tif (!spi_new_device(host, &board_info)) {\n\t\tdev_err(dev, \"%s failed to create SPI device: %s\\n\",\n\t\t\t__func__, board_info.modalias);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dfl_device_id dfl_spi_altera_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_MAX10_SPI },\n\t{ }\n};\n\nstatic struct dfl_driver dfl_spi_altera_driver = {\n\t.drv\t= {\n\t\t.name       = \"dfl-spi-altera\",\n\t},\n\t.id_table = dfl_spi_altera_ids,\n\t.probe   = dfl_spi_altera_probe,\n};\n\nmodule_dfl_driver(dfl_spi_altera_driver);\n\nMODULE_DEVICE_TABLE(dfl, dfl_spi_altera_ids);\nMODULE_DESCRIPTION(\"DFL spi altera driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}