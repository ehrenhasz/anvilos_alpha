{
  "module_name": "spi-nxp-fspi.c",
  "hash_id": "866dc604557db8ff543065c0e45694cc4a7332a06f90725f9e2567f97fd44942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-nxp-fspi.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_qos.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n#include <linux/sys_soc.h>\n\n#include <linux/mfd/syscon.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define\tSEQID_LUT\t\t\t31\n\n \n#define FSPI_MCR0\t\t\t0x00\n#define FSPI_MCR0_AHB_TIMEOUT(x)\t((x) << 24)\n#define FSPI_MCR0_IP_TIMEOUT(x)\t\t((x) << 16)\n#define FSPI_MCR0_LEARN_EN\t\tBIT(15)\n#define FSPI_MCR0_SCRFRUN_EN\t\tBIT(14)\n#define FSPI_MCR0_OCTCOMB_EN\t\tBIT(13)\n#define FSPI_MCR0_DOZE_EN\t\tBIT(12)\n#define FSPI_MCR0_HSEN\t\t\tBIT(11)\n#define FSPI_MCR0_SERCLKDIV\t\tBIT(8)\n#define FSPI_MCR0_ATDF_EN\t\tBIT(7)\n#define FSPI_MCR0_ARDF_EN\t\tBIT(6)\n#define FSPI_MCR0_RXCLKSRC(x)\t\t((x) << 4)\n#define FSPI_MCR0_END_CFG(x)\t\t((x) << 2)\n#define FSPI_MCR0_MDIS\t\t\tBIT(1)\n#define FSPI_MCR0_SWRST\t\t\tBIT(0)\n\n#define FSPI_MCR1\t\t\t0x04\n#define FSPI_MCR1_SEQ_TIMEOUT(x)\t((x) << 16)\n#define FSPI_MCR1_AHB_TIMEOUT(x)\t(x)\n\n#define FSPI_MCR2\t\t\t0x08\n#define FSPI_MCR2_IDLE_WAIT(x)\t\t((x) << 24)\n#define FSPI_MCR2_SAMEDEVICEEN\t\tBIT(15)\n#define FSPI_MCR2_CLRLRPHS\t\tBIT(14)\n#define FSPI_MCR2_ABRDATSZ\t\tBIT(8)\n#define FSPI_MCR2_ABRLEARN\t\tBIT(7)\n#define FSPI_MCR2_ABR_READ\t\tBIT(6)\n#define FSPI_MCR2_ABRWRITE\t\tBIT(5)\n#define FSPI_MCR2_ABRDUMMY\t\tBIT(4)\n#define FSPI_MCR2_ABR_MODE\t\tBIT(3)\n#define FSPI_MCR2_ABRCADDR\t\tBIT(2)\n#define FSPI_MCR2_ABRRADDR\t\tBIT(1)\n#define FSPI_MCR2_ABR_CMD\t\tBIT(0)\n\n#define FSPI_AHBCR\t\t\t0x0c\n#define FSPI_AHBCR_RDADDROPT\t\tBIT(6)\n#define FSPI_AHBCR_PREF_EN\t\tBIT(5)\n#define FSPI_AHBCR_BUFF_EN\t\tBIT(4)\n#define FSPI_AHBCR_CACH_EN\t\tBIT(3)\n#define FSPI_AHBCR_CLRTXBUF\t\tBIT(2)\n#define FSPI_AHBCR_CLRRXBUF\t\tBIT(1)\n#define FSPI_AHBCR_PAR_EN\t\tBIT(0)\n\n#define FSPI_INTEN\t\t\t0x10\n#define FSPI_INTEN_SCLKSBWR\t\tBIT(9)\n#define FSPI_INTEN_SCLKSBRD\t\tBIT(8)\n#define FSPI_INTEN_DATALRNFL\t\tBIT(7)\n#define FSPI_INTEN_IPTXWE\t\tBIT(6)\n#define FSPI_INTEN_IPRXWA\t\tBIT(5)\n#define FSPI_INTEN_AHBCMDERR\t\tBIT(4)\n#define FSPI_INTEN_IPCMDERR\t\tBIT(3)\n#define FSPI_INTEN_AHBCMDGE\t\tBIT(2)\n#define FSPI_INTEN_IPCMDGE\t\tBIT(1)\n#define FSPI_INTEN_IPCMDDONE\t\tBIT(0)\n\n#define FSPI_INTR\t\t\t0x14\n#define FSPI_INTR_SCLKSBWR\t\tBIT(9)\n#define FSPI_INTR_SCLKSBRD\t\tBIT(8)\n#define FSPI_INTR_DATALRNFL\t\tBIT(7)\n#define FSPI_INTR_IPTXWE\t\tBIT(6)\n#define FSPI_INTR_IPRXWA\t\tBIT(5)\n#define FSPI_INTR_AHBCMDERR\t\tBIT(4)\n#define FSPI_INTR_IPCMDERR\t\tBIT(3)\n#define FSPI_INTR_AHBCMDGE\t\tBIT(2)\n#define FSPI_INTR_IPCMDGE\t\tBIT(1)\n#define FSPI_INTR_IPCMDDONE\t\tBIT(0)\n\n#define FSPI_LUTKEY\t\t\t0x18\n#define FSPI_LUTKEY_VALUE\t\t0x5AF05AF0\n\n#define FSPI_LCKCR\t\t\t0x1C\n\n#define FSPI_LCKER_LOCK\t\t\t0x1\n#define FSPI_LCKER_UNLOCK\t\t0x2\n\n#define FSPI_BUFXCR_INVALID_MSTRID\t0xE\n#define FSPI_AHBRX_BUF0CR0\t\t0x20\n#define FSPI_AHBRX_BUF1CR0\t\t0x24\n#define FSPI_AHBRX_BUF2CR0\t\t0x28\n#define FSPI_AHBRX_BUF3CR0\t\t0x2C\n#define FSPI_AHBRX_BUF4CR0\t\t0x30\n#define FSPI_AHBRX_BUF5CR0\t\t0x34\n#define FSPI_AHBRX_BUF6CR0\t\t0x38\n#define FSPI_AHBRX_BUF7CR0\t\t0x3C\n#define FSPI_AHBRXBUF0CR7_PREF\t\tBIT(31)\n\n#define FSPI_AHBRX_BUF0CR1\t\t0x40\n#define FSPI_AHBRX_BUF1CR1\t\t0x44\n#define FSPI_AHBRX_BUF2CR1\t\t0x48\n#define FSPI_AHBRX_BUF3CR1\t\t0x4C\n#define FSPI_AHBRX_BUF4CR1\t\t0x50\n#define FSPI_AHBRX_BUF5CR1\t\t0x54\n#define FSPI_AHBRX_BUF6CR1\t\t0x58\n#define FSPI_AHBRX_BUF7CR1\t\t0x5C\n\n#define FSPI_FLSHA1CR0\t\t\t0x60\n#define FSPI_FLSHA2CR0\t\t\t0x64\n#define FSPI_FLSHB1CR0\t\t\t0x68\n#define FSPI_FLSHB2CR0\t\t\t0x6C\n#define FSPI_FLSHXCR0_SZ_KB\t\t10\n#define FSPI_FLSHXCR0_SZ(x)\t\t((x) >> FSPI_FLSHXCR0_SZ_KB)\n\n#define FSPI_FLSHA1CR1\t\t\t0x70\n#define FSPI_FLSHA2CR1\t\t\t0x74\n#define FSPI_FLSHB1CR1\t\t\t0x78\n#define FSPI_FLSHB2CR1\t\t\t0x7C\n#define FSPI_FLSHXCR1_CSINTR(x)\t\t((x) << 16)\n#define FSPI_FLSHXCR1_CAS(x)\t\t((x) << 11)\n#define FSPI_FLSHXCR1_WA\t\tBIT(10)\n#define FSPI_FLSHXCR1_TCSH(x)\t\t((x) << 5)\n#define FSPI_FLSHXCR1_TCSS(x)\t\t(x)\n\n#define FSPI_FLSHA1CR2\t\t\t0x80\n#define FSPI_FLSHA2CR2\t\t\t0x84\n#define FSPI_FLSHB1CR2\t\t\t0x88\n#define FSPI_FLSHB2CR2\t\t\t0x8C\n#define FSPI_FLSHXCR2_CLRINSP\t\tBIT(24)\n#define FSPI_FLSHXCR2_AWRWAIT\t\tBIT(16)\n#define FSPI_FLSHXCR2_AWRSEQN_SHIFT\t13\n#define FSPI_FLSHXCR2_AWRSEQI_SHIFT\t8\n#define FSPI_FLSHXCR2_ARDSEQN_SHIFT\t5\n#define FSPI_FLSHXCR2_ARDSEQI_SHIFT\t0\n\n#define FSPI_IPCR0\t\t\t0xA0\n\n#define FSPI_IPCR1\t\t\t0xA4\n#define FSPI_IPCR1_IPAREN\t\tBIT(31)\n#define FSPI_IPCR1_SEQNUM_SHIFT\t\t24\n#define FSPI_IPCR1_SEQID_SHIFT\t\t16\n#define FSPI_IPCR1_IDATSZ(x)\t\t(x)\n\n#define FSPI_IPCMD\t\t\t0xB0\n#define FSPI_IPCMD_TRG\t\t\tBIT(0)\n\n#define FSPI_DLPR\t\t\t0xB4\n\n#define FSPI_IPRXFCR\t\t\t0xB8\n#define FSPI_IPRXFCR_CLR\t\tBIT(0)\n#define FSPI_IPRXFCR_DMA_EN\t\tBIT(1)\n#define FSPI_IPRXFCR_WMRK(x)\t\t((x) << 2)\n\n#define FSPI_IPTXFCR\t\t\t0xBC\n#define FSPI_IPTXFCR_CLR\t\tBIT(0)\n#define FSPI_IPTXFCR_DMA_EN\t\tBIT(1)\n#define FSPI_IPTXFCR_WMRK(x)\t\t((x) << 2)\n\n#define FSPI_DLLACR\t\t\t0xC0\n#define FSPI_DLLACR_OVRDEN\t\tBIT(8)\n#define FSPI_DLLACR_SLVDLY(x)\t\t((x) << 3)\n#define FSPI_DLLACR_DLLRESET\t\tBIT(1)\n#define FSPI_DLLACR_DLLEN\t\tBIT(0)\n\n#define FSPI_DLLBCR\t\t\t0xC4\n#define FSPI_DLLBCR_OVRDEN\t\tBIT(8)\n#define FSPI_DLLBCR_SLVDLY(x)\t\t((x) << 3)\n#define FSPI_DLLBCR_DLLRESET\t\tBIT(1)\n#define FSPI_DLLBCR_DLLEN\t\tBIT(0)\n\n#define FSPI_STS0\t\t\t0xE0\n#define FSPI_STS0_DLPHB(x)\t\t((x) << 8)\n#define FSPI_STS0_DLPHA(x)\t\t((x) << 4)\n#define FSPI_STS0_CMD_SRC(x)\t\t((x) << 2)\n#define FSPI_STS0_ARB_IDLE\t\tBIT(1)\n#define FSPI_STS0_SEQ_IDLE\t\tBIT(0)\n\n#define FSPI_STS1\t\t\t0xE4\n#define FSPI_STS1_IP_ERRCD(x)\t\t((x) << 24)\n#define FSPI_STS1_IP_ERRID(x)\t\t((x) << 16)\n#define FSPI_STS1_AHB_ERRCD(x)\t\t((x) << 8)\n#define FSPI_STS1_AHB_ERRID(x)\t\t(x)\n\n#define FSPI_STS2\t\t\t0xE8\n#define FSPI_STS2_BREFLOCK\t\tBIT(17)\n#define FSPI_STS2_BSLVLOCK\t\tBIT(16)\n#define FSPI_STS2_AREFLOCK\t\tBIT(1)\n#define FSPI_STS2_ASLVLOCK\t\tBIT(0)\n#define FSPI_STS2_AB_LOCK\t\t(FSPI_STS2_BREFLOCK | \\\n\t\t\t\t\t FSPI_STS2_BSLVLOCK | \\\n\t\t\t\t\t FSPI_STS2_AREFLOCK | \\\n\t\t\t\t\t FSPI_STS2_ASLVLOCK)\n\n#define FSPI_AHBSPNST\t\t\t0xEC\n#define FSPI_AHBSPNST_DATLFT(x)\t\t((x) << 16)\n#define FSPI_AHBSPNST_BUFID(x)\t\t((x) << 1)\n#define FSPI_AHBSPNST_ACTIVE\t\tBIT(0)\n\n#define FSPI_IPRXFSTS\t\t\t0xF0\n#define FSPI_IPRXFSTS_RDCNTR(x)\t\t((x) << 16)\n#define FSPI_IPRXFSTS_FILL(x)\t\t(x)\n\n#define FSPI_IPTXFSTS\t\t\t0xF4\n#define FSPI_IPTXFSTS_WRCNTR(x)\t\t((x) << 16)\n#define FSPI_IPTXFSTS_FILL(x)\t\t(x)\n\n#define FSPI_RFDR\t\t\t0x100\n#define FSPI_TFDR\t\t\t0x180\n\n#define FSPI_LUT_BASE\t\t\t0x200\n#define FSPI_LUT_OFFSET\t\t\t(SEQID_LUT * 4 * 4)\n#define FSPI_LUT_REG(idx) \\\n\t(FSPI_LUT_BASE + FSPI_LUT_OFFSET + (idx) * 4)\n\n \n\n \n#define LUT_STOP\t\t\t0x00\n#define LUT_CMD\t\t\t\t0x01\n#define LUT_ADDR\t\t\t0x02\n#define LUT_CADDR_SDR\t\t\t0x03\n#define LUT_MODE\t\t\t0x04\n#define LUT_MODE2\t\t\t0x05\n#define LUT_MODE4\t\t\t0x06\n#define LUT_MODE8\t\t\t0x07\n#define LUT_NXP_WRITE\t\t\t0x08\n#define LUT_NXP_READ\t\t\t0x09\n#define LUT_LEARN_SDR\t\t\t0x0A\n#define LUT_DATSZ_SDR\t\t\t0x0B\n#define LUT_DUMMY\t\t\t0x0C\n#define LUT_DUMMY_RWDS_SDR\t\t0x0D\n#define LUT_JMP_ON_CS\t\t\t0x1F\n#define LUT_CMD_DDR\t\t\t0x21\n#define LUT_ADDR_DDR\t\t\t0x22\n#define LUT_CADDR_DDR\t\t\t0x23\n#define LUT_MODE_DDR\t\t\t0x24\n#define LUT_MODE2_DDR\t\t\t0x25\n#define LUT_MODE4_DDR\t\t\t0x26\n#define LUT_MODE8_DDR\t\t\t0x27\n#define LUT_WRITE_DDR\t\t\t0x28\n#define LUT_READ_DDR\t\t\t0x29\n#define LUT_LEARN_DDR\t\t\t0x2A\n#define LUT_DATSZ_DDR\t\t\t0x2B\n#define LUT_DUMMY_DDR\t\t\t0x2C\n#define LUT_DUMMY_RWDS_DDR\t\t0x2D\n\n \n#define LUT_PAD(x) (fls(x) - 1)\n\n \n#define PAD_SHIFT\t\t8\n#define INSTR_SHIFT\t\t10\n#define OPRND_SHIFT\t\t16\n\n \n#define LUT_DEF(idx, ins, pad, opr)\t\t\t  \\\n\t((((ins) << INSTR_SHIFT) | ((pad) << PAD_SHIFT) | \\\n\t(opr)) << (((idx) % 2) * OPRND_SHIFT))\n\n#define POLL_TOUT\t\t5000\n#define NXP_FSPI_MAX_CHIPSELECT\t\t4\n#define NXP_FSPI_MIN_IOMAP\tSZ_4M\n\n#define DCFG_RCWSR1\t\t0x100\n#define SYS_PLL_RAT\t\tGENMASK(6, 2)\n\n \n#define FSPI_QUIRK_USE_IP_ONLY\tBIT(0)\n\nstruct nxp_fspi_devtype_data {\n\tunsigned int rxfifo;\n\tunsigned int txfifo;\n\tunsigned int ahb_buf_size;\n\tunsigned int quirks;\n\tbool little_endian;\n};\n\nstatic struct nxp_fspi_devtype_data lx2160a_data = {\n\t.rxfifo = SZ_512,        \n\t.txfifo = SZ_1K,         \n\t.ahb_buf_size = SZ_2K,   \n\t.quirks = 0,\n\t.little_endian = true,   \n};\n\nstatic struct nxp_fspi_devtype_data imx8mm_data = {\n\t.rxfifo = SZ_512,        \n\t.txfifo = SZ_1K,         \n\t.ahb_buf_size = SZ_2K,   \n\t.quirks = 0,\n\t.little_endian = true,   \n};\n\nstatic struct nxp_fspi_devtype_data imx8qxp_data = {\n\t.rxfifo = SZ_512,        \n\t.txfifo = SZ_1K,         \n\t.ahb_buf_size = SZ_2K,   \n\t.quirks = 0,\n\t.little_endian = true,   \n};\n\nstatic struct nxp_fspi_devtype_data imx8dxl_data = {\n\t.rxfifo = SZ_512,        \n\t.txfifo = SZ_1K,         \n\t.ahb_buf_size = SZ_2K,   \n\t.quirks = FSPI_QUIRK_USE_IP_ONLY,\n\t.little_endian = true,   \n};\n\nstruct nxp_fspi {\n\tvoid __iomem *iobase;\n\tvoid __iomem *ahb_addr;\n\tu32 memmap_phy;\n\tu32 memmap_phy_size;\n\tu32 memmap_start;\n\tu32 memmap_len;\n\tstruct clk *clk, *clk_en;\n\tstruct device *dev;\n\tstruct completion c;\n\tstruct nxp_fspi_devtype_data *devtype_data;\n\tstruct mutex lock;\n\tstruct pm_qos_request pm_qos_req;\n\tint selected;\n};\n\nstatic inline int needs_ip_only(struct nxp_fspi *f)\n{\n\treturn f->devtype_data->quirks & FSPI_QUIRK_USE_IP_ONLY;\n}\n\n \nstatic void fspi_writel(struct nxp_fspi *f, u32 val, void __iomem *addr)\n{\n\tif (f->devtype_data->little_endian)\n\t\tiowrite32(val, addr);\n\telse\n\t\tiowrite32be(val, addr);\n}\n\nstatic u32 fspi_readl(struct nxp_fspi *f, void __iomem *addr)\n{\n\tif (f->devtype_data->little_endian)\n\t\treturn ioread32(addr);\n\telse\n\t\treturn ioread32be(addr);\n}\n\nstatic irqreturn_t nxp_fspi_irq_handler(int irq, void *dev_id)\n{\n\tstruct nxp_fspi *f = dev_id;\n\tu32 reg;\n\n\t \n\treg = fspi_readl(f, f->iobase + FSPI_INTR);\n\tfspi_writel(f, FSPI_INTR_IPCMDDONE, f->iobase + FSPI_INTR);\n\n\tif (reg & FSPI_INTR_IPCMDDONE)\n\t\tcomplete(&f->c);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nxp_fspi_check_buswidth(struct nxp_fspi *f, u8 width)\n{\n\tswitch (width) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic bool nxp_fspi_supports_op(struct spi_mem *mem,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct nxp_fspi *f = spi_controller_get_devdata(mem->spi->master);\n\tint ret;\n\n\tret = nxp_fspi_check_buswidth(f, op->cmd.buswidth);\n\n\tif (op->addr.nbytes)\n\t\tret |= nxp_fspi_check_buswidth(f, op->addr.buswidth);\n\n\tif (op->dummy.nbytes)\n\t\tret |= nxp_fspi_check_buswidth(f, op->dummy.buswidth);\n\n\tif (op->data.nbytes)\n\t\tret |= nxp_fspi_check_buswidth(f, op->data.buswidth);\n\n\tif (ret)\n\t\treturn false;\n\n\t \n\tif (op->addr.nbytes > 4)\n\t\treturn false;\n\n\t \n\tif (op->addr.val >= f->memmap_phy_size)\n\t\treturn false;\n\n\t \n\tif (op->dummy.buswidth &&\n\t    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))\n\t\treturn false;\n\n\t \n\tif (op->data.dir == SPI_MEM_DATA_IN &&\n\t    (op->data.nbytes > f->devtype_data->ahb_buf_size ||\n\t     (op->data.nbytes > f->devtype_data->rxfifo - 4 &&\n\t      !IS_ALIGNED(op->data.nbytes, 8))))\n\t\treturn false;\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT &&\n\t    op->data.nbytes > f->devtype_data->txfifo)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\n \nstatic int fspi_readl_poll_tout(struct nxp_fspi *f, void __iomem *base,\n\t\t\t\tu32 mask, u32 delay_us,\n\t\t\t\tu32 timeout_us, bool c)\n{\n\tu32 reg;\n\n\tif (!f->devtype_data->little_endian)\n\t\tmask = (u32)cpu_to_be32(mask);\n\n\tif (c)\n\t\treturn readl_poll_timeout(base, reg, (reg & mask),\n\t\t\t\t\t  delay_us, timeout_us);\n\telse\n\t\treturn readl_poll_timeout(base, reg, !(reg & mask),\n\t\t\t\t\t  delay_us, timeout_us);\n}\n\n \nstatic inline void nxp_fspi_invalid(struct nxp_fspi *f)\n{\n\tu32 reg;\n\tint ret;\n\n\treg = fspi_readl(f, f->iobase + FSPI_MCR0);\n\tfspi_writel(f, reg | FSPI_MCR0_SWRST, f->iobase + FSPI_MCR0);\n\n\t \n\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_MCR0,\n\t\t\t\t   FSPI_MCR0_SWRST, 0, POLL_TOUT, false);\n\tWARN_ON(ret);\n}\n\nstatic void nxp_fspi_prepare_lut(struct nxp_fspi *f,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = f->iobase;\n\tu32 lutval[4] = {};\n\tint lutidx = 1, i;\n\n\t \n\tlutval[0] |= LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),\n\t\t\t     op->cmd.opcode);\n\n\t \n\tif (op->addr.nbytes) {\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_ADDR,\n\t\t\t\t\t      LUT_PAD(op->addr.buswidth),\n\t\t\t\t\t      op->addr.nbytes * 8);\n\t\tlutidx++;\n\t}\n\n\t \n\tif (op->dummy.nbytes) {\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_DUMMY,\n\t\t \n\t\t\t\t\t      LUT_PAD(op->data.buswidth),\n\t\t\t\t\t      op->dummy.nbytes * 8 /\n\t\t\t\t\t      op->dummy.buswidth);\n\t\tlutidx++;\n\t}\n\n\t \n\tif (op->data.nbytes) {\n\t\tlutval[lutidx / 2] |= LUT_DEF(lutidx,\n\t\t\t\t\t      op->data.dir == SPI_MEM_DATA_IN ?\n\t\t\t\t\t      LUT_NXP_READ : LUT_NXP_WRITE,\n\t\t\t\t\t      LUT_PAD(op->data.buswidth),\n\t\t\t\t\t      0);\n\t\tlutidx++;\n\t}\n\n\t \n\tlutval[lutidx / 2] |= LUT_DEF(lutidx, LUT_STOP, 0, 0);\n\n\t \n\tfspi_writel(f, FSPI_LUTKEY_VALUE, f->iobase + FSPI_LUTKEY);\n\tfspi_writel(f, FSPI_LCKER_UNLOCK, f->iobase + FSPI_LCKCR);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lutval); i++)\n\t\tfspi_writel(f, lutval[i], base + FSPI_LUT_REG(i));\n\n\tdev_dbg(f->dev, \"CMD[%x] lutval[0:%x \\t 1:%x \\t 2:%x \\t 3:%x], size: 0x%08x\\n\",\n\t\top->cmd.opcode, lutval[0], lutval[1], lutval[2], lutval[3], op->data.nbytes);\n\n\t \n\tfspi_writel(f, FSPI_LUTKEY_VALUE, f->iobase + FSPI_LUTKEY);\n\tfspi_writel(f, FSPI_LCKER_LOCK, f->iobase + FSPI_LCKCR);\n}\n\nstatic int nxp_fspi_clk_prep_enable(struct nxp_fspi *f)\n{\n\tint ret;\n\n\tif (is_acpi_node(dev_fwnode(f->dev)))\n\t\treturn 0;\n\n\tret = clk_prepare_enable(f->clk_en);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(f->clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(f->clk_en);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_fspi_clk_disable_unprep(struct nxp_fspi *f)\n{\n\tif (is_acpi_node(dev_fwnode(f->dev)))\n\t\treturn 0;\n\n\tclk_disable_unprepare(f->clk);\n\tclk_disable_unprepare(f->clk_en);\n\n\treturn 0;\n}\n\nstatic void nxp_fspi_dll_calibration(struct nxp_fspi *f)\n{\n\tint ret;\n\n\t \n\tfspi_writel(f, FSPI_DLLACR_DLLRESET, f->iobase + FSPI_DLLACR);\n\tfspi_writel(f, FSPI_DLLBCR_DLLRESET, f->iobase + FSPI_DLLBCR);\n\tfspi_writel(f, 0, f->iobase + FSPI_DLLACR);\n\tfspi_writel(f, 0, f->iobase + FSPI_DLLBCR);\n\n\t \n\tfspi_writel(f, FSPI_DLLACR_DLLEN | FSPI_DLLACR_SLVDLY(0xF),\n\t\t    f->iobase + FSPI_DLLACR);\n\tfspi_writel(f, FSPI_DLLBCR_DLLEN | FSPI_DLLBCR_SLVDLY(0xF),\n\t\t    f->iobase + FSPI_DLLBCR);\n\n\t \n\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_STS2, FSPI_STS2_AB_LOCK,\n\t\t\t\t   0, POLL_TOUT, true);\n\tif (ret)\n\t\tdev_warn(f->dev, \"DLL lock failed, please fix it!\\n\");\n}\n\n \nstatic void nxp_fspi_select_mem(struct nxp_fspi *f, struct spi_device *spi)\n{\n\tunsigned long rate = spi->max_speed_hz;\n\tint ret;\n\tuint64_t size_kb;\n\n\t \n\tif (f->selected == spi_get_chipselect(spi, 0))\n\t\treturn;\n\n\t \n\tfspi_writel(f, 0, f->iobase + FSPI_FLSHA1CR0);\n\tfspi_writel(f, 0, f->iobase + FSPI_FLSHA2CR0);\n\tfspi_writel(f, 0, f->iobase + FSPI_FLSHB1CR0);\n\tfspi_writel(f, 0, f->iobase + FSPI_FLSHB2CR0);\n\n\t \n\tsize_kb = FSPI_FLSHXCR0_SZ(f->memmap_phy_size);\n\n\tfspi_writel(f, size_kb, f->iobase + FSPI_FLSHA1CR0 +\n\t\t    4 * spi_get_chipselect(spi, 0));\n\n\tdev_dbg(f->dev, \"Slave device [CS:%x] selected\\n\", spi_get_chipselect(spi, 0));\n\n\tnxp_fspi_clk_disable_unprep(f);\n\n\tret = clk_set_rate(f->clk, rate);\n\tif (ret)\n\t\treturn;\n\n\tret = nxp_fspi_clk_prep_enable(f);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (rate > 100000000)\n\t\tnxp_fspi_dll_calibration(f);\n\n\tf->selected = spi_get_chipselect(spi, 0);\n}\n\nstatic int nxp_fspi_read_ahb(struct nxp_fspi *f, const struct spi_mem_op *op)\n{\n\tu32 start = op->addr.val;\n\tu32 len = op->data.nbytes;\n\n\t \n\tif ((!f->ahb_addr) || start < f->memmap_start ||\n\t     start + len > f->memmap_start + f->memmap_len) {\n\t\tif (f->ahb_addr)\n\t\t\tiounmap(f->ahb_addr);\n\n\t\tf->memmap_start = start;\n\t\tf->memmap_len = len > NXP_FSPI_MIN_IOMAP ?\n\t\t\t\tlen : NXP_FSPI_MIN_IOMAP;\n\n\t\tf->ahb_addr = ioremap(f->memmap_phy + f->memmap_start,\n\t\t\t\t\t f->memmap_len);\n\n\t\tif (!f->ahb_addr) {\n\t\t\tdev_err(f->dev, \"failed to alloc memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tmemcpy_fromio(op->data.buf.in,\n\t\t      f->ahb_addr + start - f->memmap_start, len);\n\n\treturn 0;\n}\n\nstatic void nxp_fspi_fill_txfifo(struct nxp_fspi *f,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = f->iobase;\n\tint i, ret;\n\tu8 *buf = (u8 *) op->data.buf.out;\n\n\t \n\tfspi_writel(f, FSPI_IPTXFCR_CLR, base + FSPI_IPTXFCR);\n\n\t \n\n\tfor (i = 0; i < ALIGN_DOWN(op->data.nbytes, 8); i += 8) {\n\t\t \n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPTXWE, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\tfspi_writel(f, *(u32 *) (buf + i), base + FSPI_TFDR);\n\t\tfspi_writel(f, *(u32 *) (buf + i + 4), base + FSPI_TFDR + 4);\n\t\tfspi_writel(f, FSPI_INTR_IPTXWE, base + FSPI_INTR);\n\t}\n\n\tif (i < op->data.nbytes) {\n\t\tu32 data = 0;\n\t\tint j;\n\t\t \n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPTXWE, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\tfor (j = 0; j < ALIGN(op->data.nbytes - i, 4); j += 4) {\n\t\t\tmemcpy(&data, buf + i + j, 4);\n\t\t\tfspi_writel(f, data, base + FSPI_TFDR + j);\n\t\t}\n\t\tfspi_writel(f, FSPI_INTR_IPTXWE, base + FSPI_INTR);\n\t}\n}\n\nstatic void nxp_fspi_read_rxfifo(struct nxp_fspi *f,\n\t\t\t  const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = f->iobase;\n\tint i, ret;\n\tint len = op->data.nbytes;\n\tu8 *buf = (u8 *) op->data.buf.in;\n\n\t \n\tfor (i = 0; i < ALIGN_DOWN(len, 8); i += 8) {\n\t\t \n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPRXWA, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\t*(u32 *)(buf + i) = fspi_readl(f, base + FSPI_RFDR);\n\t\t*(u32 *)(buf + i + 4) = fspi_readl(f, base + FSPI_RFDR + 4);\n\t\t \n\t\tfspi_writel(f, FSPI_INTR_IPRXWA, base + FSPI_INTR);\n\t}\n\n\tif (i < len) {\n\t\tu32 tmp;\n\t\tint size, j;\n\n\t\tbuf = op->data.buf.in + i;\n\t\t \n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPRXWA, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\tlen = op->data.nbytes - i;\n\t\tfor (j = 0; j < op->data.nbytes - i; j += 4) {\n\t\t\ttmp = fspi_readl(f, base + FSPI_RFDR + j);\n\t\t\tsize = min(len, 4);\n\t\t\tmemcpy(buf + j, &tmp, size);\n\t\t\tlen -= size;\n\t\t}\n\t}\n\n\t \n\tfspi_writel(f, FSPI_IPRXFCR_CLR, base + FSPI_IPRXFCR);\n\t \n\tfspi_writel(f, FSPI_INTR_IPRXWA, base + FSPI_INTR);\n}\n\nstatic int nxp_fspi_do_op(struct nxp_fspi *f, const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = f->iobase;\n\tint seqnum = 0;\n\tint err = 0;\n\tu32 reg;\n\n\treg = fspi_readl(f, base + FSPI_IPRXFCR);\n\t \n\treg &= ~FSPI_IPRXFCR_DMA_EN;\n\treg = reg | FSPI_IPRXFCR_CLR;\n\tfspi_writel(f, reg, base + FSPI_IPRXFCR);\n\n\tinit_completion(&f->c);\n\n\tfspi_writel(f, op->addr.val, base + FSPI_IPCR0);\n\t \n\tfspi_writel(f, op->data.nbytes |\n\t\t (SEQID_LUT << FSPI_IPCR1_SEQID_SHIFT) |\n\t\t (seqnum << FSPI_IPCR1_SEQNUM_SHIFT),\n\t\t base + FSPI_IPCR1);\n\n\t \n\tfspi_writel(f, FSPI_IPCMD_TRG, base + FSPI_IPCMD);\n\n\t \n\tif (!wait_for_completion_timeout(&f->c, msecs_to_jiffies(1000)))\n\t\terr = -ETIMEDOUT;\n\n\t \n\tif (!err && op->data.nbytes && op->data.dir == SPI_MEM_DATA_IN)\n\t\tnxp_fspi_read_rxfifo(f, op);\n\n\treturn err;\n}\n\nstatic int nxp_fspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct nxp_fspi *f = spi_controller_get_devdata(mem->spi->master);\n\tint err = 0;\n\n\tmutex_lock(&f->lock);\n\n\t \n\terr = fspi_readl_poll_tout(f, f->iobase + FSPI_STS0,\n\t\t\t\t   FSPI_STS0_ARB_IDLE, 1, POLL_TOUT, true);\n\tWARN_ON(err);\n\n\tnxp_fspi_select_mem(f, mem->spi);\n\n\tnxp_fspi_prepare_lut(f, op);\n\t \n\tif (op->data.nbytes > (f->devtype_data->rxfifo - 4) &&\n\t    op->data.dir == SPI_MEM_DATA_IN &&\n\t    !needs_ip_only(f)) {\n\t\terr = nxp_fspi_read_ahb(f, op);\n\t} else {\n\t\tif (op->data.nbytes && op->data.dir == SPI_MEM_DATA_OUT)\n\t\t\tnxp_fspi_fill_txfifo(f, op);\n\n\t\terr = nxp_fspi_do_op(f, op);\n\t}\n\n\t \n\tnxp_fspi_invalid(f);\n\n\tmutex_unlock(&f->lock);\n\n\treturn err;\n}\n\nstatic int nxp_fspi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct nxp_fspi *f = spi_controller_get_devdata(mem->spi->master);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\tif (op->data.nbytes > f->devtype_data->txfifo)\n\t\t\top->data.nbytes = f->devtype_data->txfifo;\n\t} else {\n\t\tif (op->data.nbytes > f->devtype_data->ahb_buf_size)\n\t\t\top->data.nbytes = f->devtype_data->ahb_buf_size;\n\t\telse if (op->data.nbytes > (f->devtype_data->rxfifo - 4))\n\t\t\top->data.nbytes = ALIGN_DOWN(op->data.nbytes, 8);\n\t}\n\n\t \n\tif (op->data.dir == SPI_MEM_DATA_IN &&\n\t    needs_ip_only(f) &&\n\t    op->data.nbytes > f->devtype_data->rxfifo)\n\t\top->data.nbytes = f->devtype_data->rxfifo;\n\n\treturn 0;\n}\n\nstatic void erratum_err050568(struct nxp_fspi *f)\n{\n\tstatic const struct soc_device_attribute ls1028a_soc_attr[] = {\n\t\t{ .family = \"QorIQ LS1028A\" },\n\t\t{   }\n\t};\n\tstruct regmap *map;\n\tu32 val, sys_pll_ratio;\n\tint ret;\n\n\t \n\tif (!soc_device_match(ls1028a_soc_attr)) {\n\t\tdev_dbg(f->dev, \"Errata applicable only for LS1028A\\n\");\n\t\treturn;\n\t}\n\n\tmap = syscon_regmap_lookup_by_compatible(\"fsl,ls1028a-dcfg\");\n\tif (IS_ERR(map)) {\n\t\tdev_err(f->dev, \"No syscon regmap\\n\");\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(map, DCFG_RCWSR1, &val);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsys_pll_ratio = FIELD_GET(SYS_PLL_RAT, val);\n\tdev_dbg(f->dev, \"val: 0x%08x, sys_pll_ratio: %d\\n\", val, sys_pll_ratio);\n\n\t \n\tif (sys_pll_ratio == 3)\n\t\tf->devtype_data->quirks |= FSPI_QUIRK_USE_IP_ONLY;\n\n\treturn;\n\nerr:\n\tdev_err(f->dev, \"Errata cannot be executed. Read via IP bus may not work\\n\");\n}\n\nstatic int nxp_fspi_default_setup(struct nxp_fspi *f)\n{\n\tvoid __iomem *base = f->iobase;\n\tint ret, i;\n\tu32 reg;\n\n\t \n\tnxp_fspi_clk_disable_unprep(f);\n\n\t \n\tret = clk_set_rate(f->clk, 20000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nxp_fspi_clk_prep_enable(f);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (of_device_is_compatible(f->dev->of_node, \"nxp,lx2160a-fspi\"))\n\t\terratum_err050568(f);\n\n\t \n\t \n\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_MCR0,\n\t\t\t\t   FSPI_MCR0_SWRST, 0, POLL_TOUT, false);\n\tWARN_ON(ret);\n\n\t \n\tfspi_writel(f, FSPI_MCR0_MDIS, base + FSPI_MCR0);\n\n\t \n\tfspi_writel(f, FSPI_DLLACR_OVRDEN, base + FSPI_DLLACR);\n\tfspi_writel(f, FSPI_DLLBCR_OVRDEN, base + FSPI_DLLBCR);\n\n\t \n\tfspi_writel(f, FSPI_MCR0_AHB_TIMEOUT(0xFF) |\n\t\t    FSPI_MCR0_IP_TIMEOUT(0xFF) | (u32) FSPI_MCR0_OCTCOMB_EN,\n\t\t    base + FSPI_MCR0);\n\n\t \n\treg = fspi_readl(f, f->iobase + FSPI_MCR2);\n\treg = reg & ~(FSPI_MCR2_SAMEDEVICEEN);\n\tfspi_writel(f, reg, base + FSPI_MCR2);\n\n\t \n\tfor (i = 0; i < 7; i++)\n\t\tfspi_writel(f, 0, base + FSPI_AHBRX_BUF0CR0 + 4 * i);\n\n\t \n\tfspi_writel(f, (f->devtype_data->ahb_buf_size / 8 |\n\t\t  FSPI_AHBRXBUF0CR7_PREF), base + FSPI_AHBRX_BUF7CR0);\n\n\t \n\tfspi_writel(f, FSPI_AHBCR_PREF_EN | FSPI_AHBCR_RDADDROPT,\n\t\t base + FSPI_AHBCR);\n\n\t \n\treg = FSPI_FLSHXCR1_TCSH(0x3) | FSPI_FLSHXCR1_TCSS(0x3);\n\tfspi_writel(f, reg, base + FSPI_FLSHA1CR1);\n\tfspi_writel(f, reg, base + FSPI_FLSHA2CR1);\n\tfspi_writel(f, reg, base + FSPI_FLSHB1CR1);\n\tfspi_writel(f, reg, base + FSPI_FLSHB2CR1);\n\n\t \n\tfspi_writel(f, SEQID_LUT, base + FSPI_FLSHA1CR2);\n\tfspi_writel(f, SEQID_LUT, base + FSPI_FLSHA2CR2);\n\tfspi_writel(f, SEQID_LUT, base + FSPI_FLSHB1CR2);\n\tfspi_writel(f, SEQID_LUT, base + FSPI_FLSHB2CR2);\n\n\tf->selected = -1;\n\n\t \n\tfspi_writel(f, FSPI_INTEN_IPCMDDONE, base + FSPI_INTEN);\n\n\treturn 0;\n}\n\nstatic const char *nxp_fspi_get_name(struct spi_mem *mem)\n{\n\tstruct nxp_fspi *f = spi_controller_get_devdata(mem->spi->master);\n\tstruct device *dev = &mem->spi->dev;\n\tconst char *name;\n\n\t\n\tif (of_get_available_child_count(f->dev->of_node) == 1)\n\t\treturn dev_name(f->dev);\n\n\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t      \"%s-%d\", dev_name(f->dev),\n\t\t\t      spi_get_chipselect(mem->spi, 0));\n\n\tif (!name) {\n\t\tdev_err(dev, \"failed to get memory for custom flash name\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn name;\n}\n\nstatic const struct spi_controller_mem_ops nxp_fspi_mem_ops = {\n\t.adjust_op_size = nxp_fspi_adjust_op_size,\n\t.supports_op = nxp_fspi_supports_op,\n\t.exec_op = nxp_fspi_exec_op,\n\t.get_name = nxp_fspi_get_name,\n};\n\nstatic int nxp_fspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *res;\n\tstruct nxp_fspi *f;\n\tint ret;\n\tu32 reg;\n\n\tctlr = spi_alloc_master(&pdev->dev, sizeof(*f));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tctlr->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL |\n\t\t\t  SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL;\n\n\tf = spi_controller_get_devdata(ctlr);\n\tf->dev = dev;\n\tf->devtype_data = (struct nxp_fspi_devtype_data *)device_get_match_data(dev);\n\tif (!f->devtype_data) {\n\t\tret = -ENODEV;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tplatform_set_drvdata(pdev, f);\n\n\t \n\tif (is_acpi_node(dev_fwnode(f->dev)))\n\t\tf->iobase = devm_platform_ioremap_resource(pdev, 0);\n\telse\n\t\tf->iobase = devm_platform_ioremap_resource_byname(pdev, \"fspi_base\");\n\n\tif (IS_ERR(f->iobase)) {\n\t\tret = PTR_ERR(f->iobase);\n\t\tgoto err_put_ctrl;\n\t}\n\n\t \n\tif (is_acpi_node(dev_fwnode(f->dev)))\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\telse\n\t\tres = platform_get_resource_byname(pdev,\n\t\t\t\tIORESOURCE_MEM, \"fspi_mmap\");\n\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto err_put_ctrl;\n\t}\n\n\t \n\tf->memmap_phy = res->start;\n\tf->memmap_phy_size = resource_size(res);\n\n\t \n\tif (dev_of_node(&pdev->dev)) {\n\t\tf->clk_en = devm_clk_get(dev, \"fspi_en\");\n\t\tif (IS_ERR(f->clk_en)) {\n\t\t\tret = PTR_ERR(f->clk_en);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\n\t\tf->clk = devm_clk_get(dev, \"fspi\");\n\t\tif (IS_ERR(f->clk)) {\n\t\t\tret = PTR_ERR(f->clk);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\n\t\tret = nxp_fspi_clk_prep_enable(f);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\t}\n\n\t \n\treg = fspi_readl(f, f->iobase + FSPI_INTR);\n\tif (reg)\n\t\tfspi_writel(f, reg, f->iobase + FSPI_INTR);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_disable_clk;\n\n\tret = devm_request_irq(dev, ret,\n\t\t\tnxp_fspi_irq_handler, 0, pdev->name, f);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq: %d\\n\", ret);\n\t\tgoto err_disable_clk;\n\t}\n\n\tmutex_init(&f->lock);\n\n\tctlr->bus_num = -1;\n\tctlr->num_chipselect = NXP_FSPI_MAX_CHIPSELECT;\n\tctlr->mem_ops = &nxp_fspi_mem_ops;\n\n\tnxp_fspi_default_setup(f);\n\n\tctlr->dev.of_node = np;\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret)\n\t\tgoto err_destroy_mutex;\n\n\treturn 0;\n\nerr_destroy_mutex:\n\tmutex_destroy(&f->lock);\n\nerr_disable_clk:\n\tnxp_fspi_clk_disable_unprep(f);\n\nerr_put_ctrl:\n\tspi_controller_put(ctlr);\n\n\tdev_err(dev, \"NXP FSPI probe failed\\n\");\n\treturn ret;\n}\n\nstatic void nxp_fspi_remove(struct platform_device *pdev)\n{\n\tstruct nxp_fspi *f = platform_get_drvdata(pdev);\n\n\t \n\tfspi_writel(f, FSPI_MCR0_MDIS, f->iobase + FSPI_MCR0);\n\n\tnxp_fspi_clk_disable_unprep(f);\n\n\tmutex_destroy(&f->lock);\n\n\tif (f->ahb_addr)\n\t\tiounmap(f->ahb_addr);\n}\n\nstatic int nxp_fspi_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int nxp_fspi_resume(struct device *dev)\n{\n\tstruct nxp_fspi *f = dev_get_drvdata(dev);\n\n\tnxp_fspi_default_setup(f);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nxp_fspi_dt_ids[] = {\n\t{ .compatible = \"nxp,lx2160a-fspi\", .data = (void *)&lx2160a_data, },\n\t{ .compatible = \"nxp,imx8mm-fspi\", .data = (void *)&imx8mm_data, },\n\t{ .compatible = \"nxp,imx8mp-fspi\", .data = (void *)&imx8mm_data, },\n\t{ .compatible = \"nxp,imx8qxp-fspi\", .data = (void *)&imx8qxp_data, },\n\t{ .compatible = \"nxp,imx8dxl-fspi\", .data = (void *)&imx8dxl_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nxp_fspi_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id nxp_fspi_acpi_ids[] = {\n\t{ \"NXP0009\", .driver_data = (kernel_ulong_t)&lx2160a_data, },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, nxp_fspi_acpi_ids);\n#endif\n\nstatic const struct dev_pm_ops nxp_fspi_pm_ops = {\n\t.suspend\t= nxp_fspi_suspend,\n\t.resume\t\t= nxp_fspi_resume,\n};\n\nstatic struct platform_driver nxp_fspi_driver = {\n\t.driver = {\n\t\t.name\t= \"nxp-fspi\",\n\t\t.of_match_table = nxp_fspi_dt_ids,\n\t\t.acpi_match_table = ACPI_PTR(nxp_fspi_acpi_ids),\n\t\t.pm =   &nxp_fspi_pm_ops,\n\t},\n\t.probe          = nxp_fspi_probe,\n\t.remove_new\t= nxp_fspi_remove,\n};\nmodule_platform_driver(nxp_fspi_driver);\n\nMODULE_DESCRIPTION(\"NXP FSPI Controller Driver\");\nMODULE_AUTHOR(\"NXP Semiconductor\");\nMODULE_AUTHOR(\"Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>\");\nMODULE_AUTHOR(\"Boris Brezillon <bbrezillon@kernel.org>\");\nMODULE_AUTHOR(\"Frieder Schrempf <frieder.schrempf@kontron.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}