{
  "module_name": "spi-ar934x.c",
  "hash_id": "4bd068582f9baa6e28bbaec043e5c69a6cd9c11e28d0019ef85850372faa8ef8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ar934x.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n#define DRIVER_NAME \"spi-ar934x\"\n\n#define AR934X_SPI_REG_FS\t\t0x00\n#define AR934X_SPI_ENABLE\t\tBIT(0)\n\n#define AR934X_SPI_REG_IOC\t\t0x08\n#define AR934X_SPI_IOC_INITVAL\t\t0x70000\n\n#define AR934X_SPI_REG_CTRL\t\t0x04\n#define AR934X_SPI_CLK_MASK\t\tGENMASK(5, 0)\n\n#define AR934X_SPI_DATAOUT\t\t0x10\n\n#define AR934X_SPI_REG_SHIFT_CTRL\t0x14\n#define AR934X_SPI_SHIFT_EN\t\tBIT(31)\n#define AR934X_SPI_SHIFT_CS(n)\t\tBIT(28 + (n))\n#define AR934X_SPI_SHIFT_TERM\t\t26\n#define AR934X_SPI_SHIFT_VAL(cs, term, count)\t\t\t\\\n\t(AR934X_SPI_SHIFT_EN | AR934X_SPI_SHIFT_CS(cs) |\t\\\n\t(term) << AR934X_SPI_SHIFT_TERM | (count))\n\n#define AR934X_SPI_DATAIN 0x18\n\nstruct ar934x_spi {\n\tstruct spi_controller *ctlr;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tunsigned int clk_freq;\n};\n\nstatic inline int ar934x_spi_clk_div(struct ar934x_spi *sp, unsigned int freq)\n{\n\tint div = DIV_ROUND_UP(sp->clk_freq, freq * 2) - 1;\n\n\tif (div < 0)\n\t\treturn 0;\n\telse if (div > AR934X_SPI_CLK_MASK)\n\t\treturn -EINVAL;\n\telse\n\t\treturn div;\n}\n\nstatic int ar934x_spi_setup(struct spi_device *spi)\n{\n\tstruct ar934x_spi *sp = spi_controller_get_devdata(spi->controller);\n\n\tif ((spi->max_speed_hz == 0) ||\n\t    (spi->max_speed_hz > (sp->clk_freq / 2))) {\n\t\tspi->max_speed_hz = sp->clk_freq / 2;\n\t} else if (spi->max_speed_hz < (sp->clk_freq / 128)) {\n\t\tdev_err(&spi->dev, \"spi clock is too low\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ar934x_spi_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t\t   struct spi_message *m)\n{\n\tstruct ar934x_spi *sp = spi_controller_get_devdata(ctlr);\n\tstruct spi_transfer *t = NULL;\n\tstruct spi_device *spi = m->spi;\n\tunsigned long trx_done, trx_cur;\n\tint stat = 0;\n\tu8 bpw, term = 0;\n\tint div, i;\n\tu32 reg;\n\tconst u8 *tx_buf;\n\tu8 *buf;\n\n\tm->actual_length = 0;\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (t->bits_per_word >= 8 && t->bits_per_word < 32)\n\t\t\tbpw = t->bits_per_word >> 3;\n\t\telse\n\t\t\tbpw = 4;\n\n\t\tif (t->speed_hz)\n\t\t\tdiv = ar934x_spi_clk_div(sp, t->speed_hz);\n\t\telse\n\t\t\tdiv = ar934x_spi_clk_div(sp, spi->max_speed_hz);\n\t\tif (div < 0) {\n\t\t\tstat = -EIO;\n\t\t\tgoto msg_done;\n\t\t}\n\n\t\treg = ioread32(sp->base + AR934X_SPI_REG_CTRL);\n\t\treg &= ~AR934X_SPI_CLK_MASK;\n\t\treg |= div;\n\t\tiowrite32(reg, sp->base + AR934X_SPI_REG_CTRL);\n\t\tiowrite32(0, sp->base + AR934X_SPI_DATAOUT);\n\n\t\tfor (trx_done = 0; trx_done < t->len; trx_done += bpw) {\n\t\t\ttrx_cur = t->len - trx_done;\n\t\t\tif (trx_cur > bpw)\n\t\t\t\ttrx_cur = bpw;\n\t\t\telse if (list_is_last(&t->transfer_list, &m->transfers))\n\t\t\t\tterm = 1;\n\n\t\t\tif (t->tx_buf) {\n\t\t\t\ttx_buf = t->tx_buf + trx_done;\n\t\t\t\treg = tx_buf[0];\n\t\t\t\tfor (i = 1; i < trx_cur; i++)\n\t\t\t\t\treg = reg << 8 | tx_buf[i];\n\t\t\t\tiowrite32(reg, sp->base + AR934X_SPI_DATAOUT);\n\t\t\t}\n\n\t\t\treg = AR934X_SPI_SHIFT_VAL(spi_get_chipselect(spi, 0), term,\n\t\t\t\t\t\t   trx_cur * 8);\n\t\t\tiowrite32(reg, sp->base + AR934X_SPI_REG_SHIFT_CTRL);\n\t\t\tstat = readl_poll_timeout(\n\t\t\t\tsp->base + AR934X_SPI_REG_SHIFT_CTRL, reg,\n\t\t\t\t!(reg & AR934X_SPI_SHIFT_EN), 0, 5);\n\t\t\tif (stat < 0)\n\t\t\t\tgoto msg_done;\n\n\t\t\tif (t->rx_buf) {\n\t\t\t\treg = ioread32(sp->base + AR934X_SPI_DATAIN);\n\t\t\t\tbuf = t->rx_buf + trx_done;\n\t\t\t\tfor (i = 0; i < trx_cur; i++) {\n\t\t\t\t\tbuf[trx_cur - i - 1] = reg & 0xff;\n\t\t\t\t\treg >>= 8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspi_delay_exec(&t->word_delay, t);\n\t\t}\n\t\tm->actual_length += t->len;\n\t\tspi_transfer_delay_exec(t);\n\t}\n\nmsg_done:\n\tm->status = stat;\n\tspi_finalize_current_message(ctlr);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ar934x_spi_match[] = {\n\t{ .compatible = \"qca,ar934x-spi\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ar934x_spi_match);\n\nstatic int ar934x_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct ar934x_spi *sp;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tint ret;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\tctlr = devm_spi_alloc_host(&pdev->dev, sizeof(*sp));\n\tif (!ctlr) {\n\t\tdev_info(&pdev->dev, \"failed to allocate spi controller\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\tiowrite32(AR934X_SPI_ENABLE, base + AR934X_SPI_REG_FS);\n\t \n\tiowrite32(AR934X_SPI_IOC_INITVAL, base + AR934X_SPI_REG_IOC);\n\n\tctlr->mode_bits = SPI_LSB_FIRST;\n\tctlr->setup = ar934x_spi_setup;\n\tctlr->transfer_one_message = ar934x_spi_transfer_one_message;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(24) |\n\t\t\t\t   SPI_BPW_MASK(16) | SPI_BPW_MASK(8);\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->num_chipselect = 3;\n\n\tdev_set_drvdata(&pdev->dev, ctlr);\n\n\tsp = spi_controller_get_devdata(ctlr);\n\tsp->base = base;\n\tsp->clk = clk;\n\tsp->clk_freq = clk_get_rate(clk);\n\tsp->ctlr = ctlr;\n\n\tret = spi_register_controller(ctlr);\n\tif (!ret)\n\t\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(clk);\n\treturn ret;\n}\n\nstatic void ar934x_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct ar934x_spi *sp;\n\n\tctlr = dev_get_drvdata(&pdev->dev);\n\tsp = spi_controller_get_devdata(ctlr);\n\n\tspi_unregister_controller(ctlr);\n\tclk_disable_unprepare(sp->clk);\n}\n\nstatic struct platform_driver ar934x_spi_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = ar934x_spi_match,\n\t},\n\t.probe = ar934x_spi_probe,\n\t.remove_new = ar934x_spi_remove,\n};\n\nmodule_platform_driver(ar934x_spi_driver);\n\nMODULE_DESCRIPTION(\"SPI controller driver for Qualcomm Atheros AR934x/QCA95xx\");\nMODULE_AUTHOR(\"Chuanhong Guo <gch981213@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}