{
  "module_name": "spi-cadence-quadspi.c",
  "hash_id": "01aec674be0e7e29b831b38712ef4bb0175a7abe432e9e09cbafae381f04be3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-cadence-quadspi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sched.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/timer.h>\n\n#define CQSPI_NAME\t\t\t\"cadence-qspi\"\n#define CQSPI_MAX_CHIPSELECT\t\t16\n\n \n#define CQSPI_NEEDS_WR_DELAY\t\tBIT(0)\n#define CQSPI_DISABLE_DAC_MODE\t\tBIT(1)\n#define CQSPI_SUPPORT_EXTERNAL_DMA\tBIT(2)\n#define CQSPI_NO_SUPPORT_WR_COMPLETION\tBIT(3)\n#define CQSPI_SLOW_SRAM\t\tBIT(4)\n#define CQSPI_NEEDS_APB_AHB_HAZARD_WAR\tBIT(5)\n\n \n#define CQSPI_SUPPORTS_OCTAL\t\tBIT(0)\n\n#define CQSPI_OP_WIDTH(part) ((part).nbytes ? ilog2((part).buswidth) : 0)\n\nenum {\n\tCLK_QSPI_APB = 0,\n\tCLK_QSPI_AHB,\n\tCLK_QSPI_NUM,\n};\n\nstruct cqspi_st;\n\nstruct cqspi_flash_pdata {\n\tstruct cqspi_st\t*cqspi;\n\tu32\t\tclk_rate;\n\tu32\t\tread_delay;\n\tu32\t\ttshsl_ns;\n\tu32\t\ttsd2d_ns;\n\tu32\t\ttchsh_ns;\n\tu32\t\ttslch_ns;\n\tu8\t\tcs;\n};\n\nstruct cqspi_st {\n\tstruct platform_device\t*pdev;\n\tstruct spi_controller\t*host;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*clks[CLK_QSPI_NUM];\n\tunsigned int\t\tsclk;\n\n\tvoid __iomem\t\t*iobase;\n\tvoid __iomem\t\t*ahb_base;\n\tresource_size_t\t\tahb_size;\n\tstruct completion\ttransfer_complete;\n\n\tstruct dma_chan\t\t*rx_chan;\n\tstruct completion\trx_dma_complete;\n\tdma_addr_t\t\tmmap_phys_base;\n\n\tint\t\t\tcurrent_cs;\n\tunsigned long\t\tmaster_ref_clk_hz;\n\tbool\t\t\tis_decoded_cs;\n\tu32\t\t\tfifo_depth;\n\tu32\t\t\tfifo_width;\n\tu32\t\t\tnum_chipselect;\n\tbool\t\t\trclk_en;\n\tu32\t\t\ttrigger_address;\n\tu32\t\t\twr_delay;\n\tbool\t\t\tuse_direct_mode;\n\tbool\t\t\tuse_direct_mode_wr;\n\tstruct cqspi_flash_pdata f_pdata[CQSPI_MAX_CHIPSELECT];\n\tbool\t\t\tuse_dma_read;\n\tu32\t\t\tpd_dev_id;\n\tbool\t\t\twr_completion;\n\tbool\t\t\tslow_sram;\n\tbool\t\t\tapb_ahb_hazard;\n\n\tbool\t\t\tis_jh7110;  \n};\n\nstruct cqspi_driver_platdata {\n\tu32 hwcaps_mask;\n\tu8 quirks;\n\tint (*indirect_read_dma)(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t u_char *rxbuf, loff_t from_addr, size_t n_rx);\n\tu32 (*get_dma_status)(struct cqspi_st *cqspi);\n\tint (*jh7110_clk_init)(struct platform_device *pdev,\n\t\t\t       struct cqspi_st *cqspi);\n};\n\n \n#define CQSPI_TIMEOUT_MS\t\t\t500\n#define CQSPI_READ_TIMEOUT_MS\t\t\t10\n\n#define CQSPI_DUMMY_CLKS_PER_BYTE\t\t8\n#define CQSPI_DUMMY_BYTES_MAX\t\t\t4\n#define CQSPI_DUMMY_CLKS_MAX\t\t\t31\n\n#define CQSPI_STIG_DATA_LEN_MAX\t\t\t8\n\n \n#define CQSPI_REG_CONFIG\t\t\t0x00\n#define CQSPI_REG_CONFIG_ENABLE_MASK\t\tBIT(0)\n#define CQSPI_REG_CONFIG_ENB_DIR_ACC_CTRL\tBIT(7)\n#define CQSPI_REG_CONFIG_DECODE_MASK\t\tBIT(9)\n#define CQSPI_REG_CONFIG_CHIPSELECT_LSB\t\t10\n#define CQSPI_REG_CONFIG_DMA_MASK\t\tBIT(15)\n#define CQSPI_REG_CONFIG_BAUD_LSB\t\t19\n#define CQSPI_REG_CONFIG_DTR_PROTO\t\tBIT(24)\n#define CQSPI_REG_CONFIG_DUAL_OPCODE\t\tBIT(30)\n#define CQSPI_REG_CONFIG_IDLE_LSB\t\t31\n#define CQSPI_REG_CONFIG_CHIPSELECT_MASK\t0xF\n#define CQSPI_REG_CONFIG_BAUD_MASK\t\t0xF\n\n#define CQSPI_REG_RD_INSTR\t\t\t0x04\n#define CQSPI_REG_RD_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB\t8\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_LSB\t16\n#define CQSPI_REG_RD_INSTR_MODE_EN_LSB\t\t20\n#define CQSPI_REG_RD_INSTR_DUMMY_LSB\t\t24\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_DUMMY_MASK\t\t0x1F\n\n#define CQSPI_REG_WR_INSTR\t\t\t0x08\n#define CQSPI_REG_WR_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_WR_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_WR_INSTR_TYPE_DATA_LSB\t16\n\n#define CQSPI_REG_DELAY\t\t\t\t0x0C\n#define CQSPI_REG_DELAY_TSLCH_LSB\t\t0\n#define CQSPI_REG_DELAY_TCHSH_LSB\t\t8\n#define CQSPI_REG_DELAY_TSD2D_LSB\t\t16\n#define CQSPI_REG_DELAY_TSHSL_LSB\t\t24\n#define CQSPI_REG_DELAY_TSLCH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TCHSH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSD2D_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSHSL_MASK\t\t0xFF\n\n#define CQSPI_REG_READCAPTURE\t\t\t0x10\n#define CQSPI_REG_READCAPTURE_BYPASS_LSB\t0\n#define CQSPI_REG_READCAPTURE_DELAY_LSB\t\t1\n#define CQSPI_REG_READCAPTURE_DELAY_MASK\t0xF\n\n#define CQSPI_REG_SIZE\t\t\t\t0x14\n#define CQSPI_REG_SIZE_ADDRESS_LSB\t\t0\n#define CQSPI_REG_SIZE_PAGE_LSB\t\t\t4\n#define CQSPI_REG_SIZE_BLOCK_LSB\t\t16\n#define CQSPI_REG_SIZE_ADDRESS_MASK\t\t0xF\n#define CQSPI_REG_SIZE_PAGE_MASK\t\t0xFFF\n#define CQSPI_REG_SIZE_BLOCK_MASK\t\t0x3F\n\n#define CQSPI_REG_SRAMPARTITION\t\t\t0x18\n#define CQSPI_REG_INDIRECTTRIGGER\t\t0x1C\n\n#define CQSPI_REG_DMA\t\t\t\t0x20\n#define CQSPI_REG_DMA_SINGLE_LSB\t\t0\n#define CQSPI_REG_DMA_BURST_LSB\t\t\t8\n#define CQSPI_REG_DMA_SINGLE_MASK\t\t0xFF\n#define CQSPI_REG_DMA_BURST_MASK\t\t0xFF\n\n#define CQSPI_REG_REMAP\t\t\t\t0x24\n#define CQSPI_REG_MODE_BIT\t\t\t0x28\n\n#define CQSPI_REG_SDRAMLEVEL\t\t\t0x2C\n#define CQSPI_REG_SDRAMLEVEL_RD_LSB\t\t0\n#define CQSPI_REG_SDRAMLEVEL_WR_LSB\t\t16\n#define CQSPI_REG_SDRAMLEVEL_RD_MASK\t\t0xFFFF\n#define CQSPI_REG_SDRAMLEVEL_WR_MASK\t\t0xFFFF\n\n#define CQSPI_REG_WR_COMPLETION_CTRL\t\t0x38\n#define CQSPI_REG_WR_DISABLE_AUTO_POLL\t\tBIT(14)\n\n#define CQSPI_REG_IRQSTATUS\t\t\t0x40\n#define CQSPI_REG_IRQMASK\t\t\t0x44\n\n#define CQSPI_REG_INDIRECTRD\t\t\t0x60\n#define CQSPI_REG_INDIRECTRD_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTRD_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTRD_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTRDWATERMARK\t\t0x64\n#define CQSPI_REG_INDIRECTRDSTARTADDR\t\t0x68\n#define CQSPI_REG_INDIRECTRDBYTES\t\t0x6C\n\n#define CQSPI_REG_CMDCTRL\t\t\t0x90\n#define CQSPI_REG_CMDCTRL_EXECUTE_MASK\t\tBIT(0)\n#define CQSPI_REG_CMDCTRL_INPROGRESS_MASK\tBIT(1)\n#define CQSPI_REG_CMDCTRL_DUMMY_LSB\t\t7\n#define CQSPI_REG_CMDCTRL_WR_BYTES_LSB\t\t12\n#define CQSPI_REG_CMDCTRL_WR_EN_LSB\t\t15\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_LSB\t\t16\n#define CQSPI_REG_CMDCTRL_ADDR_EN_LSB\t\t19\n#define CQSPI_REG_CMDCTRL_RD_BYTES_LSB\t\t20\n#define CQSPI_REG_CMDCTRL_RD_EN_LSB\t\t23\n#define CQSPI_REG_CMDCTRL_OPCODE_LSB\t\t24\n#define CQSPI_REG_CMDCTRL_WR_BYTES_MASK\t\t0x7\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_MASK\t0x3\n#define CQSPI_REG_CMDCTRL_RD_BYTES_MASK\t\t0x7\n#define CQSPI_REG_CMDCTRL_DUMMY_MASK\t\t0x1F\n\n#define CQSPI_REG_INDIRECTWR\t\t\t0x70\n#define CQSPI_REG_INDIRECTWR_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTWR_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTWR_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTWRWATERMARK\t\t0x74\n#define CQSPI_REG_INDIRECTWRSTARTADDR\t\t0x78\n#define CQSPI_REG_INDIRECTWRBYTES\t\t0x7C\n\n#define CQSPI_REG_INDTRIG_ADDRRANGE\t\t0x80\n\n#define CQSPI_REG_CMDADDRESS\t\t\t0x94\n#define CQSPI_REG_CMDREADDATALOWER\t\t0xA0\n#define CQSPI_REG_CMDREADDATAUPPER\t\t0xA4\n#define CQSPI_REG_CMDWRITEDATALOWER\t\t0xA8\n#define CQSPI_REG_CMDWRITEDATAUPPER\t\t0xAC\n\n#define CQSPI_REG_POLLING_STATUS\t\t0xB0\n#define CQSPI_REG_POLLING_STATUS_DUMMY_LSB\t16\n\n#define CQSPI_REG_OP_EXT_LOWER\t\t\t0xE0\n#define CQSPI_REG_OP_EXT_READ_LSB\t\t24\n#define CQSPI_REG_OP_EXT_WRITE_LSB\t\t16\n#define CQSPI_REG_OP_EXT_STIG_LSB\t\t0\n\n#define CQSPI_REG_VERSAL_DMA_SRC_ADDR\t\t0x1000\n\n#define CQSPI_REG_VERSAL_DMA_DST_ADDR\t\t0x1800\n#define CQSPI_REG_VERSAL_DMA_DST_SIZE\t\t0x1804\n\n#define CQSPI_REG_VERSAL_DMA_DST_CTRL\t\t0x180C\n\n#define CQSPI_REG_VERSAL_DMA_DST_I_STS\t\t0x1814\n#define CQSPI_REG_VERSAL_DMA_DST_I_EN\t\t0x1818\n#define CQSPI_REG_VERSAL_DMA_DST_I_DIS\t\t0x181C\n#define CQSPI_REG_VERSAL_DMA_DST_DONE_MASK\tBIT(1)\n\n#define CQSPI_REG_VERSAL_DMA_DST_ADDR_MSB\t0x1828\n\n#define CQSPI_REG_VERSAL_DMA_DST_CTRL_VAL\t0xF43FFA00\n#define CQSPI_REG_VERSAL_ADDRRANGE_WIDTH_VAL\t0x6\n\n \n#define CQSPI_REG_IRQ_MODE_ERR\t\t\tBIT(0)\n#define CQSPI_REG_IRQ_UNDERFLOW\t\t\tBIT(1)\n#define CQSPI_REG_IRQ_IND_COMP\t\t\tBIT(2)\n#define CQSPI_REG_IRQ_IND_RD_REJECT\t\tBIT(3)\n#define CQSPI_REG_IRQ_WR_PROTECTED_ERR\t\tBIT(4)\n#define CQSPI_REG_IRQ_ILLEGAL_AHB_ERR\t\tBIT(5)\n#define CQSPI_REG_IRQ_WATERMARK\t\t\tBIT(6)\n#define CQSPI_REG_IRQ_IND_SRAM_FULL\t\tBIT(12)\n\n#define CQSPI_IRQ_MASK_RD\t\t(CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_SRAM_FULL\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_COMP)\n\n#define CQSPI_IRQ_MASK_WR\t\t(CQSPI_REG_IRQ_IND_COMP\t\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_UNDERFLOW)\n\n#define CQSPI_IRQ_STATUS_MASK\t\t0x1FFFF\n#define CQSPI_DMA_UNALIGN\t\t0x3\n\n#define CQSPI_REG_VERSAL_DMA_VAL\t\t0x602\n\nstatic int cqspi_wait_for_bit(void __iomem *reg, const u32 mask, bool clr)\n{\n\tu32 val;\n\n\treturn readl_relaxed_poll_timeout(reg, val,\n\t\t\t\t\t  (((clr ? ~val : val) & mask) == mask),\n\t\t\t\t\t  10, CQSPI_TIMEOUT_MS * 1000);\n}\n\nstatic bool cqspi_is_idle(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\n\treturn reg & (1UL << CQSPI_REG_CONFIG_IDLE_LSB);\n}\n\nstatic u32 cqspi_get_rd_sram_level(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_SDRAMLEVEL);\n\n\treg >>= CQSPI_REG_SDRAMLEVEL_RD_LSB;\n\treturn reg & CQSPI_REG_SDRAMLEVEL_RD_MASK;\n}\n\nstatic u32 cqspi_get_versal_dma_status(struct cqspi_st *cqspi)\n{\n\tu32 dma_status;\n\n\tdma_status = readl(cqspi->iobase +\n\t\t\t\t\t   CQSPI_REG_VERSAL_DMA_DST_I_STS);\n\twritel(dma_status, cqspi->iobase +\n\t\t   CQSPI_REG_VERSAL_DMA_DST_I_STS);\n\n\treturn dma_status & CQSPI_REG_VERSAL_DMA_DST_DONE_MASK;\n}\n\nstatic irqreturn_t cqspi_irq_handler(int this_irq, void *dev)\n{\n\tstruct cqspi_st *cqspi = dev;\n\tunsigned int irq_status;\n\tstruct device *device = &cqspi->pdev->dev;\n\tconst struct cqspi_driver_platdata *ddata;\n\n\tddata = of_device_get_match_data(device);\n\n\t \n\tirq_status = readl(cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\t \n\twritel(irq_status, cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\tif (cqspi->use_dma_read && ddata && ddata->get_dma_status) {\n\t\tif (ddata->get_dma_status(cqspi)) {\n\t\t\tcomplete(&cqspi->transfer_complete);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\telse if (!cqspi->slow_sram)\n\t\tirq_status &= CQSPI_IRQ_MASK_RD | CQSPI_IRQ_MASK_WR;\n\telse\n\t\tirq_status &= CQSPI_REG_IRQ_WATERMARK | CQSPI_IRQ_MASK_WR;\n\n\tif (irq_status)\n\t\tcomplete(&cqspi->transfer_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int cqspi_calc_rdreg(const struct spi_mem_op *op)\n{\n\tu32 rdreg = 0;\n\n\trdreg |= CQSPI_OP_WIDTH(op->cmd) << CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB;\n\trdreg |= CQSPI_OP_WIDTH(op->addr) << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB;\n\trdreg |= CQSPI_OP_WIDTH(op->data) << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB;\n\n\treturn rdreg;\n}\n\nstatic unsigned int cqspi_calc_dummy(const struct spi_mem_op *op)\n{\n\tunsigned int dummy_clk;\n\n\tif (!op->dummy.nbytes)\n\t\treturn 0;\n\n\tdummy_clk = op->dummy.nbytes * (8 / op->dummy.buswidth);\n\tif (op->cmd.dtr)\n\t\tdummy_clk /= 2;\n\n\treturn dummy_clk;\n}\n\nstatic int cqspi_wait_idle(struct cqspi_st *cqspi)\n{\n\tconst unsigned int poll_idle_retry = 3;\n\tunsigned int count = 0;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\n\twhile (1) {\n\t\t \n\t\tif (cqspi_is_idle(cqspi))\n\t\t\tcount++;\n\t\telse\n\t\t\tcount = 0;\n\n\t\tif (count >= poll_idle_retry)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\t\"QSPI is still busy after %dms timeout.\\n\",\n\t\t\t\tCQSPI_TIMEOUT_MS);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n}\n\nstatic int cqspi_exec_flash_cmd(struct cqspi_st *cqspi, unsigned int reg)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tint ret;\n\n\t \n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\t \n\treg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;\n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\n\t \n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_CMDCTRL,\n\t\t\t\t CQSPI_REG_CMDCTRL_INPROGRESS_MASK, 1);\n\tif (ret) {\n\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\"Flash command execution timed out.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treturn cqspi_wait_idle(cqspi);\n}\n\nstatic int cqspi_setup_opcode_ext(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t  const struct spi_mem_op *op,\n\t\t\t\t  unsigned int shift)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\tu8 ext;\n\n\tif (op->cmd.nbytes != 2)\n\t\treturn -EINVAL;\n\n\t \n\text = op->cmd.opcode & 0xff;\n\n\treg = readl(reg_base + CQSPI_REG_OP_EXT_LOWER);\n\treg &= ~(0xff << shift);\n\treg |= ext << shift;\n\twritel(reg, reg_base + CQSPI_REG_OP_EXT_LOWER);\n\n\treturn 0;\n}\n\nstatic int cqspi_enable_dtr(struct cqspi_flash_pdata *f_pdata,\n\t\t\t    const struct spi_mem_op *op, unsigned int shift)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\tint ret;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\n\t \n\tif (op->cmd.dtr) {\n\t\treg |= CQSPI_REG_CONFIG_DTR_PROTO;\n\t\treg |= CQSPI_REG_CONFIG_DUAL_OPCODE;\n\n\t\t \n\t\tret = cqspi_setup_opcode_ext(f_pdata, op, shift);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treg &= ~CQSPI_REG_CONFIG_DTR_PROTO;\n\t\treg &= ~CQSPI_REG_CONFIG_DUAL_OPCODE;\n\t}\n\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n\n\treturn cqspi_wait_idle(cqspi);\n}\n\nstatic int cqspi_command_read(struct cqspi_flash_pdata *f_pdata,\n\t\t\t      const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu8 *rxbuf = op->data.buf.in;\n\tu8 opcode;\n\tsize_t n_rx = op->data.nbytes;\n\tunsigned int rdreg;\n\tunsigned int reg;\n\tunsigned int dummy_clk;\n\tsize_t read_len;\n\tint status;\n\n\tstatus = cqspi_enable_dtr(f_pdata, op, CQSPI_REG_OP_EXT_STIG_LSB);\n\tif (status)\n\t\treturn status;\n\n\tif (!n_rx || n_rx > CQSPI_STIG_DATA_LEN_MAX || !rxbuf) {\n\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\"Invalid input argument, len %zu rxbuf 0x%p\\n\",\n\t\t\tn_rx, rxbuf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (op->cmd.dtr)\n\t\topcode = op->cmd.opcode >> 8;\n\telse\n\t\topcode = op->cmd.opcode;\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\n\trdreg = cqspi_calc_rdreg(op);\n\twritel(rdreg, reg_base + CQSPI_REG_RD_INSTR);\n\n\tdummy_clk = cqspi_calc_dummy(op);\n\tif (dummy_clk > CQSPI_DUMMY_CLKS_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dummy_clk)\n\t\treg |= (dummy_clk & CQSPI_REG_CMDCTRL_DUMMY_MASK)\n\t\t     << CQSPI_REG_CMDCTRL_DUMMY_LSB;\n\n\treg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);\n\n\t \n\treg |= (((n_rx - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)\n\t\t<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);\n\n\t \n\tif (op->addr.nbytes) {\n\t\treg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);\n\t\treg |= ((op->addr.nbytes - 1) &\n\t\t\tCQSPI_REG_CMDCTRL_ADD_BYTES_MASK)\n\t\t\t<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;\n\n\t\twritel(op->addr.val, reg_base + CQSPI_REG_CMDADDRESS);\n\t}\n\n\tstatus = cqspi_exec_flash_cmd(cqspi, reg);\n\tif (status)\n\t\treturn status;\n\n\treg = readl(reg_base + CQSPI_REG_CMDREADDATALOWER);\n\n\t \n\tread_len = (n_rx > 4) ? 4 : n_rx;\n\tmemcpy(rxbuf, &reg, read_len);\n\trxbuf += read_len;\n\n\tif (n_rx > 4) {\n\t\treg = readl(reg_base + CQSPI_REG_CMDREADDATAUPPER);\n\n\t\tread_len = n_rx - read_len;\n\t\tmemcpy(rxbuf, &reg, read_len);\n\t}\n\n\t \n\twritel(0, reg_base + CQSPI_REG_CMDCTRL);\n\n\treturn 0;\n}\n\nstatic int cqspi_command_write(struct cqspi_flash_pdata *f_pdata,\n\t\t\t       const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu8 opcode;\n\tconst u8 *txbuf = op->data.buf.out;\n\tsize_t n_tx = op->data.nbytes;\n\tunsigned int reg;\n\tunsigned int data;\n\tsize_t write_len;\n\tint ret;\n\n\tret = cqspi_enable_dtr(f_pdata, op, CQSPI_REG_OP_EXT_STIG_LSB);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_tx > CQSPI_STIG_DATA_LEN_MAX || (n_tx && !txbuf)) {\n\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\"Invalid input argument, cmdlen %zu txbuf 0x%p\\n\",\n\t\t\tn_tx, txbuf);\n\t\treturn -EINVAL;\n\t}\n\n\treg = cqspi_calc_rdreg(op);\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\tif (op->cmd.dtr)\n\t\topcode = op->cmd.opcode >> 8;\n\telse\n\t\topcode = op->cmd.opcode;\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\n\tif (op->addr.nbytes) {\n\t\treg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);\n\t\treg |= ((op->addr.nbytes - 1) &\n\t\t\tCQSPI_REG_CMDCTRL_ADD_BYTES_MASK)\n\t\t\t<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;\n\n\t\twritel(op->addr.val, reg_base + CQSPI_REG_CMDADDRESS);\n\t}\n\n\tif (n_tx) {\n\t\treg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);\n\t\treg |= ((n_tx - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)\n\t\t\t<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;\n\t\tdata = 0;\n\t\twrite_len = (n_tx > 4) ? 4 : n_tx;\n\t\tmemcpy(&data, txbuf, write_len);\n\t\ttxbuf += write_len;\n\t\twritel(data, reg_base + CQSPI_REG_CMDWRITEDATALOWER);\n\n\t\tif (n_tx > 4) {\n\t\t\tdata = 0;\n\t\t\twrite_len = n_tx - 4;\n\t\t\tmemcpy(&data, txbuf, write_len);\n\t\t\twritel(data, reg_base + CQSPI_REG_CMDWRITEDATAUPPER);\n\t\t}\n\t}\n\n\tret = cqspi_exec_flash_cmd(cqspi, reg);\n\n\t \n\twritel(0, reg_base + CQSPI_REG_CMDCTRL);\n\n\treturn ret;\n}\n\nstatic int cqspi_read_setup(struct cqspi_flash_pdata *f_pdata,\n\t\t\t    const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int dummy_clk = 0;\n\tunsigned int reg;\n\tint ret;\n\tu8 opcode;\n\n\tret = cqspi_enable_dtr(f_pdata, op, CQSPI_REG_OP_EXT_READ_LSB);\n\tif (ret)\n\t\treturn ret;\n\n\tif (op->cmd.dtr)\n\t\topcode = op->cmd.opcode >> 8;\n\telse\n\t\topcode = op->cmd.opcode;\n\n\treg = opcode << CQSPI_REG_RD_INSTR_OPCODE_LSB;\n\treg |= cqspi_calc_rdreg(op);\n\n\t \n\tdummy_clk = cqspi_calc_dummy(op);\n\n\tif (dummy_clk > CQSPI_DUMMY_CLKS_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dummy_clk)\n\t\treg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)\n\t\t       << CQSPI_REG_RD_INSTR_DUMMY_LSB;\n\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\t \n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (op->addr.nbytes - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_read_execute(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t       u8 *rxbuf, loff_t from_addr,\n\t\t\t\t       const size_t n_rx)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tstruct device *dev = &cqspi->pdev->dev;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tvoid __iomem *ahb_base = cqspi->ahb_base;\n\tunsigned int remaining = n_rx;\n\tunsigned int mod_bytes = n_rx % 4;\n\tunsigned int bytes_to_read = 0;\n\tu8 *rxbuf_end = rxbuf + n_rx;\n\tint ret = 0;\n\n\twritel(from_addr, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTRDBYTES);\n\n\t \n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\t \n\n\tif (!cqspi->slow_sram)\n\t\twritel(CQSPI_IRQ_MASK_RD, reg_base + CQSPI_REG_IRQMASK);\n\telse\n\t\twritel(CQSPI_REG_IRQ_WATERMARK, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTRD_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\n\twhile (remaining > 0) {\n\t\tif (!wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t msecs_to_jiffies(CQSPI_READ_TIMEOUT_MS)))\n\t\t\tret = -ETIMEDOUT;\n\n\t\t \n\t\tif (cqspi->slow_sram)\n\t\t\twritel(0x0, reg_base + CQSPI_REG_IRQMASK);\n\n\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\n\t\tif (ret && bytes_to_read == 0) {\n\t\t\tdev_err(dev, \"Indirect read timeout, no bytes\\n\");\n\t\t\tgoto failrd;\n\t\t}\n\n\t\twhile (bytes_to_read != 0) {\n\t\t\tunsigned int word_remain = round_down(remaining, 4);\n\n\t\t\tbytes_to_read *= cqspi->fifo_width;\n\t\t\tbytes_to_read = bytes_to_read > remaining ?\n\t\t\t\t\tremaining : bytes_to_read;\n\t\t\tbytes_to_read = round_down(bytes_to_read, 4);\n\t\t\t \n\t\t\tif (bytes_to_read) {\n\t\t\t\tioread32_rep(ahb_base, rxbuf,\n\t\t\t\t\t     (bytes_to_read / 4));\n\t\t\t} else if (!word_remain && mod_bytes) {\n\t\t\t\tunsigned int temp = ioread32(ahb_base);\n\n\t\t\t\tbytes_to_read = mod_bytes;\n\t\t\t\tmemcpy(rxbuf, &temp, min((unsigned int)\n\t\t\t\t\t\t\t (rxbuf_end - rxbuf),\n\t\t\t\t\t\t\t bytes_to_read));\n\t\t\t}\n\t\t\trxbuf += bytes_to_read;\n\t\t\tremaining -= bytes_to_read;\n\t\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\t\t}\n\n\t\tif (remaining > 0) {\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t\t\tif (cqspi->slow_sram)\n\t\t\t\twritel(CQSPI_REG_IRQ_WATERMARK, reg_base + CQSPI_REG_IRQMASK);\n\t\t}\n\t}\n\n\t \n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTRD,\n\t\t\t\t CQSPI_REG_INDIRECTRD_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Indirect read completion error (%i)\\n\", ret);\n\t\tgoto failrd;\n\t}\n\n\t \n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t \n\twritel(CQSPI_REG_INDIRECTRD_DONE_MASK, reg_base + CQSPI_REG_INDIRECTRD);\n\n\treturn 0;\n\nfailrd:\n\t \n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t \n\twritel(CQSPI_REG_INDIRECTRD_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\treturn ret;\n}\n\nstatic void cqspi_controller_enable(struct cqspi_st *cqspi, bool enable)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\n\tif (enable)\n\t\treg |= CQSPI_REG_CONFIG_ENABLE_MASK;\n\telse\n\t\treg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;\n\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic int cqspi_versal_indirect_read_dma(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t\t  u_char *rxbuf, loff_t from_addr,\n\t\t\t\t\t  size_t n_rx)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tstruct device *dev = &cqspi->pdev->dev;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu32 reg, bytes_to_dma;\n\tloff_t addr = from_addr;\n\tvoid *buf = rxbuf;\n\tdma_addr_t dma_addr;\n\tu8 bytes_rem;\n\tint ret = 0;\n\n\tbytes_rem = n_rx % 4;\n\tbytes_to_dma = (n_rx - bytes_rem);\n\n\tif (!bytes_to_dma)\n\t\tgoto nondmard;\n\n\tret = zynqmp_pm_ospi_mux_select(cqspi->pd_dev_id, PM_OSPI_MUX_SEL_DMA);\n\tif (ret)\n\t\treturn ret;\n\n\tcqspi_controller_enable(cqspi, 0);\n\n\treg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\treg |= CQSPI_REG_CONFIG_DMA_MASK;\n\twritel(reg, cqspi->iobase + CQSPI_REG_CONFIG);\n\n\tcqspi_controller_enable(cqspi, 1);\n\n\tdma_addr = dma_map_single(dev, rxbuf, bytes_to_dma, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dma_addr)) {\n\t\tdev_err(dev, \"dma mapping failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(from_addr, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);\n\twritel(bytes_to_dma, reg_base + CQSPI_REG_INDIRECTRDBYTES);\n\twritel(CQSPI_REG_VERSAL_ADDRRANGE_WIDTH_VAL,\n\t       reg_base + CQSPI_REG_INDTRIG_ADDRRANGE);\n\n\t \n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\t \n\twritel(CQSPI_REG_VERSAL_DMA_DST_DONE_MASK,\n\t       reg_base + CQSPI_REG_VERSAL_DMA_DST_I_EN);\n\n\t \n\twritel(CQSPI_REG_VERSAL_DMA_VAL, reg_base + CQSPI_REG_DMA);\n\n\t \n\twritel(lower_32_bits(dma_addr),\n\t       reg_base + CQSPI_REG_VERSAL_DMA_DST_ADDR);\n\twritel(upper_32_bits(dma_addr),\n\t       reg_base + CQSPI_REG_VERSAL_DMA_DST_ADDR_MSB);\n\n\t \n\twritel(cqspi->trigger_address, reg_base +\n\t       CQSPI_REG_VERSAL_DMA_SRC_ADDR);\n\n\t \n\twritel(bytes_to_dma, reg_base + CQSPI_REG_VERSAL_DMA_DST_SIZE);\n\n\t \n\twritel(CQSPI_REG_VERSAL_DMA_DST_CTRL_VAL,\n\t       reg_base + CQSPI_REG_VERSAL_DMA_DST_CTRL);\n\n\twritel(CQSPI_REG_INDIRECTRD_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\n\treinit_completion(&cqspi->transfer_complete);\n\n\tif (!wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t msecs_to_jiffies(max_t(size_t, bytes_to_dma, 500)))) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto failrd;\n\t}\n\n\t \n\twritel(0x0, cqspi->iobase + CQSPI_REG_VERSAL_DMA_DST_I_DIS);\n\n\t \n\twritel(CQSPI_REG_INDIRECTRD_DONE_MASK,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTRD);\n\tdma_unmap_single(dev, dma_addr, bytes_to_dma, DMA_FROM_DEVICE);\n\n\tcqspi_controller_enable(cqspi, 0);\n\n\treg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\treg &= ~CQSPI_REG_CONFIG_DMA_MASK;\n\twritel(reg, cqspi->iobase + CQSPI_REG_CONFIG);\n\n\tcqspi_controller_enable(cqspi, 1);\n\n\tret = zynqmp_pm_ospi_mux_select(cqspi->pd_dev_id,\n\t\t\t\t\tPM_OSPI_MUX_SEL_LINEAR);\n\tif (ret)\n\t\treturn ret;\n\nnondmard:\n\tif (bytes_rem) {\n\t\taddr += bytes_to_dma;\n\t\tbuf += bytes_to_dma;\n\t\tret = cqspi_indirect_read_execute(f_pdata, buf, addr,\n\t\t\t\t\t\t  bytes_rem);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nfailrd:\n\t \n\twritel(0x0, reg_base + CQSPI_REG_VERSAL_DMA_DST_I_DIS);\n\n\t \n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\n\tdma_unmap_single(dev, dma_addr, bytes_to_dma, DMA_FROM_DEVICE);\n\n\treg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\treg &= ~CQSPI_REG_CONFIG_DMA_MASK;\n\twritel(reg, cqspi->iobase + CQSPI_REG_CONFIG);\n\n\tzynqmp_pm_ospi_mux_select(cqspi->pd_dev_id, PM_OSPI_MUX_SEL_LINEAR);\n\n\treturn ret;\n}\n\nstatic int cqspi_write_setup(struct cqspi_flash_pdata *f_pdata,\n\t\t\t     const struct spi_mem_op *op)\n{\n\tunsigned int reg;\n\tint ret;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu8 opcode;\n\n\tret = cqspi_enable_dtr(f_pdata, op, CQSPI_REG_OP_EXT_WRITE_LSB);\n\tif (ret)\n\t\treturn ret;\n\n\tif (op->cmd.dtr)\n\t\topcode = op->cmd.opcode >> 8;\n\telse\n\t\topcode = op->cmd.opcode;\n\n\t \n\treg = opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;\n\treg |= CQSPI_OP_WIDTH(op->data) << CQSPI_REG_WR_INSTR_TYPE_DATA_LSB;\n\treg |= CQSPI_OP_WIDTH(op->addr) << CQSPI_REG_WR_INSTR_TYPE_ADDR_LSB;\n\twritel(reg, reg_base + CQSPI_REG_WR_INSTR);\n\treg = cqspi_calc_rdreg(op);\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\t \n\tif (cqspi->wr_completion) {\n\t\treg = readl(reg_base + CQSPI_REG_WR_COMPLETION_CTRL);\n\t\treg |= CQSPI_REG_WR_DISABLE_AUTO_POLL;\n\t\twritel(reg, reg_base + CQSPI_REG_WR_COMPLETION_CTRL);\n\t\t \n\t\tcqspi->use_direct_mode_wr = false;\n\t}\n\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (op->addr.nbytes - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_write_execute(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t\tloff_t to_addr, const u8 *txbuf,\n\t\t\t\t\tconst size_t n_tx)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tstruct device *dev = &cqspi->pdev->dev;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int remaining = n_tx;\n\tunsigned int write_bytes;\n\tint ret;\n\n\twritel(to_addr, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);\n\n\t \n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\twritel(CQSPI_IRQ_MASK_WR, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTWR_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\t \n\tif (cqspi->wr_delay)\n\t\tndelay(cqspi->wr_delay);\n\n\t \n\tif (cqspi->apb_ahb_hazard)\n\t\treadl(reg_base + CQSPI_REG_INDIRECTWR);\n\n\twhile (remaining > 0) {\n\t\tsize_t write_words, mod_bytes;\n\n\t\twrite_bytes = remaining;\n\t\twrite_words = write_bytes / 4;\n\t\tmod_bytes = write_bytes % 4;\n\t\t \n\t\tif (write_words) {\n\t\t\tiowrite32_rep(cqspi->ahb_base, txbuf, write_words);\n\t\t\ttxbuf += (write_words * 4);\n\t\t}\n\t\tif (mod_bytes) {\n\t\t\tunsigned int temp = 0xFFFFFFFF;\n\n\t\t\tmemcpy(&temp, txbuf, mod_bytes);\n\t\t\tiowrite32(temp, cqspi->ahb_base);\n\t\t\ttxbuf += mod_bytes;\n\t\t}\n\n\t\tif (!wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t msecs_to_jiffies(CQSPI_TIMEOUT_MS))) {\n\t\t\tdev_err(dev, \"Indirect write timeout\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto failwr;\n\t\t}\n\n\t\tremaining -= write_bytes;\n\n\t\tif (remaining > 0)\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t}\n\n\t \n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTWR,\n\t\t\t\t CQSPI_REG_INDIRECTWR_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Indirect write completion error (%i)\\n\", ret);\n\t\tgoto failwr;\n\t}\n\n\t \n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t \n\twritel(CQSPI_REG_INDIRECTWR_DONE_MASK, reg_base + CQSPI_REG_INDIRECTWR);\n\n\tcqspi_wait_idle(cqspi);\n\n\treturn 0;\n\nfailwr:\n\t \n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t \n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\treturn ret;\n}\n\nstatic void cqspi_chipselect(struct cqspi_flash_pdata *f_pdata)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int chip_select = f_pdata->cs;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\tif (cqspi->is_decoded_cs) {\n\t\treg |= CQSPI_REG_CONFIG_DECODE_MASK;\n\t} else {\n\t\treg &= ~CQSPI_REG_CONFIG_DECODE_MASK;\n\n\t\t \n\t\tchip_select = 0xF & ~(1 << chip_select);\n\t}\n\n\treg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK\n\t\t << CQSPI_REG_CONFIG_CHIPSELECT_LSB);\n\treg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)\n\t    << CQSPI_REG_CONFIG_CHIPSELECT_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic unsigned int calculate_ticks_for_ns(const unsigned int ref_clk_hz,\n\t\t\t\t\t   const unsigned int ns_val)\n{\n\tunsigned int ticks;\n\n\tticks = ref_clk_hz / 1000;\t \n\tticks = DIV_ROUND_UP(ticks * ns_val, 1000000);\n\n\treturn ticks;\n}\n\nstatic void cqspi_delay(struct cqspi_flash_pdata *f_pdata)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *iobase = cqspi->iobase;\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tunsigned int tshsl, tchsh, tslch, tsd2d;\n\tunsigned int reg;\n\tunsigned int tsclk;\n\n\t \n\ttsclk = DIV_ROUND_UP(ref_clk_hz, cqspi->sclk);\n\n\ttshsl = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tshsl_ns);\n\t \n\tif (tshsl < tsclk)\n\t\ttshsl = tsclk;\n\n\ttchsh = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tchsh_ns);\n\ttslch = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tslch_ns);\n\ttsd2d = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tsd2d_ns);\n\n\treg = (tshsl & CQSPI_REG_DELAY_TSHSL_MASK)\n\t       << CQSPI_REG_DELAY_TSHSL_LSB;\n\treg |= (tchsh & CQSPI_REG_DELAY_TCHSH_MASK)\n\t\t<< CQSPI_REG_DELAY_TCHSH_LSB;\n\treg |= (tslch & CQSPI_REG_DELAY_TSLCH_MASK)\n\t\t<< CQSPI_REG_DELAY_TSLCH_LSB;\n\treg |= (tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)\n\t\t<< CQSPI_REG_DELAY_TSD2D_LSB;\n\twritel(reg, iobase + CQSPI_REG_DELAY);\n}\n\nstatic void cqspi_config_baudrate_div(struct cqspi_st *cqspi)\n{\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu32 reg, div;\n\n\t \n\tdiv = DIV_ROUND_UP(ref_clk_hz, 2 * cqspi->sclk) - 1;\n\n\t \n\tif (div > CQSPI_REG_CONFIG_BAUD_MASK) {\n\t\tdiv = CQSPI_REG_CONFIG_BAUD_MASK;\n\t\tdev_warn(&cqspi->pdev->dev,\n\t\t\t\"Unable to adjust clock <= %d hz. Reduced to %d hz\\n\",\n\t\t\tcqspi->sclk, ref_clk_hz/((div+1)*2));\n\t}\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\treg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);\n\treg |= (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_readdata_capture(struct cqspi_st *cqspi,\n\t\t\t\t   const bool bypass,\n\t\t\t\t   const unsigned int delay)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_READCAPTURE);\n\n\tif (bypass)\n\t\treg |= (1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\telse\n\t\treg &= ~(1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\n\treg &= ~(CQSPI_REG_READCAPTURE_DELAY_MASK\n\t\t << CQSPI_REG_READCAPTURE_DELAY_LSB);\n\n\treg |= (delay & CQSPI_REG_READCAPTURE_DELAY_MASK)\n\t\t<< CQSPI_REG_READCAPTURE_DELAY_LSB;\n\n\twritel(reg, reg_base + CQSPI_REG_READCAPTURE);\n}\n\nstatic void cqspi_configure(struct cqspi_flash_pdata *f_pdata,\n\t\t\t    unsigned long sclk)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tint switch_cs = (cqspi->current_cs != f_pdata->cs);\n\tint switch_ck = (cqspi->sclk != sclk);\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 0);\n\n\t \n\tif (switch_cs) {\n\t\tcqspi->current_cs = f_pdata->cs;\n\t\tcqspi_chipselect(f_pdata);\n\t}\n\n\t \n\tif (switch_ck) {\n\t\tcqspi->sclk = sclk;\n\t\tcqspi_config_baudrate_div(cqspi);\n\t\tcqspi_delay(f_pdata);\n\t\tcqspi_readdata_capture(cqspi, !cqspi->rclk_en,\n\t\t\t\t       f_pdata->read_delay);\n\t}\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic ssize_t cqspi_write(struct cqspi_flash_pdata *f_pdata,\n\t\t\t   const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tloff_t to = op->addr.val;\n\tsize_t len = op->data.nbytes;\n\tconst u_char *buf = op->data.buf.out;\n\tint ret;\n\n\tret = cqspi_write_setup(f_pdata, op);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!op->cmd.dtr && cqspi->use_direct_mode &&\n\t    cqspi->use_direct_mode_wr && ((to + len) <= cqspi->ahb_size)) {\n\t\tmemcpy_toio(cqspi->ahb_base + to, buf, len);\n\t\treturn cqspi_wait_idle(cqspi);\n\t}\n\n\treturn cqspi_indirect_write_execute(f_pdata, to, buf, len);\n}\n\nstatic void cqspi_rx_dma_callback(void *param)\n{\n\tstruct cqspi_st *cqspi = param;\n\n\tcomplete(&cqspi->rx_dma_complete);\n}\n\nstatic int cqspi_direct_read_execute(struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t     u_char *buf, loff_t from, size_t len)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tstruct device *dev = &cqspi->pdev->dev;\n\tenum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tdma_addr_t dma_src = (dma_addr_t)cqspi->mmap_phys_base + from;\n\tint ret = 0;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\tdma_addr_t dma_dst;\n\tstruct device *ddev;\n\n\tif (!cqspi->rx_chan || !virt_addr_valid(buf)) {\n\t\tmemcpy_fromio(buf, cqspi->ahb_base + from, len);\n\t\treturn 0;\n\t}\n\n\tddev = cqspi->rx_chan->device->dev;\n\tdma_dst = dma_map_single(ddev, buf, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ddev, dma_dst)) {\n\t\tdev_err(dev, \"dma mapping failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttx = dmaengine_prep_dma_memcpy(cqspi->rx_chan, dma_dst, dma_src,\n\t\t\t\t       len, flags);\n\tif (!tx) {\n\t\tdev_err(dev, \"device_prep_dma_memcpy error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_unmap;\n\t}\n\n\ttx->callback = cqspi_rx_dma_callback;\n\ttx->callback_param = cqspi;\n\tcookie = tx->tx_submit(tx);\n\treinit_completion(&cqspi->rx_dma_complete);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(dev, \"dma_submit_error %d\\n\", cookie);\n\t\tret = -EIO;\n\t\tgoto err_unmap;\n\t}\n\n\tdma_async_issue_pending(cqspi->rx_chan);\n\tif (!wait_for_completion_timeout(&cqspi->rx_dma_complete,\n\t\t\t\t\t msecs_to_jiffies(max_t(size_t, len, 500)))) {\n\t\tdmaengine_terminate_sync(cqspi->rx_chan);\n\t\tdev_err(dev, \"DMA wait_for_completion_timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_unmap;\n\t}\n\nerr_unmap:\n\tdma_unmap_single(ddev, dma_dst, len, DMA_FROM_DEVICE);\n\n\treturn ret;\n}\n\nstatic ssize_t cqspi_read(struct cqspi_flash_pdata *f_pdata,\n\t\t\t  const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tstruct device *dev = &cqspi->pdev->dev;\n\tconst struct cqspi_driver_platdata *ddata;\n\tloff_t from = op->addr.val;\n\tsize_t len = op->data.nbytes;\n\tu_char *buf = op->data.buf.in;\n\tu64 dma_align = (u64)(uintptr_t)buf;\n\tint ret;\n\n\tddata = of_device_get_match_data(dev);\n\n\tret = cqspi_read_setup(f_pdata, op);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cqspi->use_direct_mode && ((from + len) <= cqspi->ahb_size))\n\t\treturn cqspi_direct_read_execute(f_pdata, buf, from, len);\n\n\tif (cqspi->use_dma_read && ddata && ddata->indirect_read_dma &&\n\t    virt_addr_valid(buf) && ((dma_align & CQSPI_DMA_UNALIGN) == 0))\n\t\treturn ddata->indirect_read_dma(f_pdata, buf, from, len);\n\n\treturn cqspi_indirect_read_execute(f_pdata, buf, from, len);\n}\n\nstatic int cqspi_mem_process(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct cqspi_st *cqspi = spi_controller_get_devdata(mem->spi->controller);\n\tstruct cqspi_flash_pdata *f_pdata;\n\n\tf_pdata = &cqspi->f_pdata[spi_get_chipselect(mem->spi, 0)];\n\tcqspi_configure(f_pdata, mem->spi->max_speed_hz);\n\n\tif (op->data.dir == SPI_MEM_DATA_IN && op->data.buf.in) {\n\t \n\t\tif (!op->addr.nbytes ||\n\t\t    op->data.nbytes <= CQSPI_STIG_DATA_LEN_MAX)\n\t\t\treturn cqspi_command_read(f_pdata, op);\n\n\t\treturn cqspi_read(f_pdata, op);\n\t}\n\n\tif (!op->addr.nbytes || !op->data.buf.out)\n\t\treturn cqspi_command_write(f_pdata, op);\n\n\treturn cqspi_write(f_pdata, op);\n}\n\nstatic int cqspi_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tint ret;\n\n\tret = cqspi_mem_process(mem, op);\n\tif (ret)\n\t\tdev_err(&mem->spi->dev, \"operation failed with %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic bool cqspi_supports_mem_op(struct spi_mem *mem,\n\t\t\t\t  const struct spi_mem_op *op)\n{\n\tbool all_true, all_false;\n\n\t \n\tall_true = op->cmd.dtr &&\n\t\t   (!op->addr.nbytes || op->addr.dtr) &&\n\t\t   (!op->dummy.nbytes || op->dummy.dtr) &&\n\t\t   (!op->data.nbytes || op->data.dtr);\n\n\tall_false = !op->cmd.dtr && !op->addr.dtr && !op->dummy.dtr &&\n\t\t    !op->data.dtr;\n\n\tif (all_true) {\n\t\t \n\t\tif (op->cmd.nbytes && op->cmd.buswidth != 8)\n\t\t\treturn false;\n\t\tif (op->addr.nbytes && op->addr.buswidth != 8)\n\t\t\treturn false;\n\t\tif (op->data.nbytes && op->data.buswidth != 8)\n\t\t\treturn false;\n\t} else if (!all_false) {\n\t\t \n\t\treturn false;\n\t}\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic int cqspi_of_get_flash_pdata(struct platform_device *pdev,\n\t\t\t\t    struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t    struct device_node *np)\n{\n\tif (of_property_read_u32(np, \"cdns,read-delay\", &f_pdata->read_delay)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine read-delay\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tshsl-ns\", &f_pdata->tshsl_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tshsl-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tsd2d-ns\", &f_pdata->tsd2d_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tsd2d-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tchsh-ns\", &f_pdata->tchsh_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tchsh-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tslch-ns\", &f_pdata->tslch_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tslch-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"spi-max-frequency\", &f_pdata->clk_rate)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine spi-max-frequency\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_of_get_pdata(struct cqspi_st *cqspi)\n{\n\tstruct device *dev = &cqspi->pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tu32 id[2];\n\n\tcqspi->is_decoded_cs = of_property_read_bool(np, \"cdns,is-decoded-cs\");\n\n\tif (of_property_read_u32(np, \"cdns,fifo-depth\", &cqspi->fifo_depth)) {\n\t\tdev_err(dev, \"couldn't determine fifo-depth\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,fifo-width\", &cqspi->fifo_width)) {\n\t\tdev_err(dev, \"couldn't determine fifo-width\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,trigger-address\",\n\t\t\t\t &cqspi->trigger_address)) {\n\t\tdev_err(dev, \"couldn't determine trigger-address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"num-cs\", &cqspi->num_chipselect))\n\t\tcqspi->num_chipselect = CQSPI_MAX_CHIPSELECT;\n\n\tcqspi->rclk_en = of_property_read_bool(np, \"cdns,rclk-en\");\n\n\tif (!of_property_read_u32_array(np, \"power-domains\", id,\n\t\t\t\t\tARRAY_SIZE(id)))\n\t\tcqspi->pd_dev_id = id[1];\n\n\treturn 0;\n}\n\nstatic void cqspi_controller_init(struct cqspi_st *cqspi)\n{\n\tu32 reg;\n\n\tcqspi_controller_enable(cqspi, 0);\n\n\t \n\twritel(0, cqspi->iobase + CQSPI_REG_REMAP);\n\n\t \n\twritel(0, cqspi->iobase + CQSPI_REG_IRQMASK);\n\n\t \n\twritel(cqspi->fifo_depth / 2, cqspi->iobase + CQSPI_REG_SRAMPARTITION);\n\n\t \n\twritel(cqspi->trigger_address,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTTRIGGER);\n\n\t \n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 2,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTRDWATERMARK);\n\t \n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 8,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTWRWATERMARK);\n\n\t \n\tif (!cqspi->use_direct_mode) {\n\t\treg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\t\treg &= ~CQSPI_REG_CONFIG_ENB_DIR_ACC_CTRL;\n\t\twritel(reg, cqspi->iobase + CQSPI_REG_CONFIG);\n\t}\n\n\t \n\tif (cqspi->use_dma_read) {\n\t\treg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\t\treg |= CQSPI_REG_CONFIG_DMA_MASK;\n\t\twritel(reg, cqspi->iobase + CQSPI_REG_CONFIG);\n\t}\n\n\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic int cqspi_request_mmap_dma(struct cqspi_st *cqspi)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tcqspi->rx_chan = dma_request_chan_by_mask(&mask);\n\tif (IS_ERR(cqspi->rx_chan)) {\n\t\tint ret = PTR_ERR(cqspi->rx_chan);\n\n\t\tcqspi->rx_chan = NULL;\n\t\treturn dev_err_probe(&cqspi->pdev->dev, ret, \"No Rx DMA available\\n\");\n\t}\n\tinit_completion(&cqspi->rx_dma_complete);\n\n\treturn 0;\n}\n\nstatic const char *cqspi_get_name(struct spi_mem *mem)\n{\n\tstruct cqspi_st *cqspi = spi_controller_get_devdata(mem->spi->controller);\n\tstruct device *dev = &cqspi->pdev->dev;\n\n\treturn devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\", dev_name(dev),\n\t\t\t      spi_get_chipselect(mem->spi, 0));\n}\n\nstatic const struct spi_controller_mem_ops cqspi_mem_ops = {\n\t.exec_op = cqspi_exec_mem_op,\n\t.get_name = cqspi_get_name,\n\t.supports_op = cqspi_supports_mem_op,\n};\n\nstatic const struct spi_controller_mem_caps cqspi_mem_caps = {\n\t.dtr = true,\n};\n\nstatic int cqspi_setup_flash(struct cqspi_st *cqspi)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tunsigned int cs;\n\tint ret;\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tret = of_property_read_u32(np, \"reg\", &cs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cs >= CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tof_node_put(np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_jh7110_clk_init(struct platform_device *pdev, struct cqspi_st *cqspi)\n{\n\tstatic struct clk_bulk_data qspiclk[] = {\n\t\t{ .id = \"apb\" },\n\t\t{ .id = \"ahb\" },\n\t};\n\n\tint ret = 0;\n\n\tret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(qspiclk), qspiclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: failed to get qspi clocks\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tcqspi->clks[CLK_QSPI_APB] = qspiclk[0].clk;\n\tcqspi->clks[CLK_QSPI_AHB] = qspiclk[1].clk;\n\n\tret = clk_prepare_enable(cqspi->clks[CLK_QSPI_APB]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: failed to enable CLK_QSPI_APB\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(cqspi->clks[CLK_QSPI_AHB]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: failed to enable CLK_QSPI_AHB\\n\", __func__);\n\t\tgoto disable_apb_clk;\n\t}\n\n\tcqspi->is_jh7110 = true;\n\n\treturn 0;\n\ndisable_apb_clk:\n\tclk_disable_unprepare(cqspi->clks[CLK_QSPI_APB]);\n\n\treturn ret;\n}\n\nstatic void cqspi_jh7110_disable_clk(struct platform_device *pdev, struct cqspi_st *cqspi)\n{\n\tclk_disable_unprepare(cqspi->clks[CLK_QSPI_AHB]);\n\tclk_disable_unprepare(cqspi->clks[CLK_QSPI_APB]);\n}\nstatic int cqspi_probe(struct platform_device *pdev)\n{\n\tconst struct cqspi_driver_platdata *ddata;\n\tstruct reset_control *rstc, *rstc_ocp, *rstc_ref;\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *host;\n\tstruct resource *res_ahb;\n\tstruct cqspi_st *cqspi;\n\tint ret;\n\tint irq;\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(*cqspi));\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"devm_spi_alloc_host failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thost->mode_bits = SPI_RX_QUAD | SPI_RX_DUAL;\n\thost->mem_ops = &cqspi_mem_ops;\n\thost->mem_caps = &cqspi_mem_caps;\n\thost->dev.of_node = pdev->dev.of_node;\n\n\tcqspi = spi_controller_get_devdata(host);\n\n\tcqspi->pdev = pdev;\n\tcqspi->host = host;\n\tcqspi->is_jh7110 = false;\n\tplatform_set_drvdata(pdev, cqspi);\n\n\t \n\tret = cqspi_of_get_pdata(cqspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot get mandatory OF data.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcqspi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cqspi->clk)) {\n\t\tdev_err(dev, \"Cannot claim QSPI clock.\\n\");\n\t\tret = PTR_ERR(cqspi->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tcqspi->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cqspi->iobase)) {\n\t\tdev_err(dev, \"Cannot remap controller address.\\n\");\n\t\tret = PTR_ERR(cqspi->iobase);\n\t\treturn ret;\n\t}\n\n\t \n\tcqspi->ahb_base = devm_platform_get_and_ioremap_resource(pdev, 1, &res_ahb);\n\tif (IS_ERR(cqspi->ahb_base)) {\n\t\tdev_err(dev, \"Cannot remap AHB address.\\n\");\n\t\tret = PTR_ERR(cqspi->ahb_base);\n\t\treturn ret;\n\t}\n\tcqspi->mmap_phys_base = (dma_addr_t)res_ahb->start;\n\tcqspi->ahb_size = resource_size(res_ahb);\n\n\tinit_completion(&cqspi->transfer_complete);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto probe_pm_failed;\n\n\tret = clk_prepare_enable(cqspi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable QSPI clock.\\n\");\n\t\tgoto probe_clk_failed;\n\t}\n\n\t \n\trstc = devm_reset_control_get_optional_exclusive(dev, \"qspi\");\n\tif (IS_ERR(rstc)) {\n\t\tret = PTR_ERR(rstc);\n\t\tdev_err(dev, \"Cannot get QSPI reset.\\n\");\n\t\tgoto probe_reset_failed;\n\t}\n\n\trstc_ocp = devm_reset_control_get_optional_exclusive(dev, \"qspi-ocp\");\n\tif (IS_ERR(rstc_ocp)) {\n\t\tret = PTR_ERR(rstc_ocp);\n\t\tdev_err(dev, \"Cannot get QSPI OCP reset.\\n\");\n\t\tgoto probe_reset_failed;\n\t}\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"starfive,jh7110-qspi\")) {\n\t\trstc_ref = devm_reset_control_get_optional_exclusive(dev, \"rstc_ref\");\n\t\tif (IS_ERR(rstc_ref)) {\n\t\t\tret = PTR_ERR(rstc_ref);\n\t\t\tdev_err(dev, \"Cannot get QSPI REF reset.\\n\");\n\t\t\tgoto probe_reset_failed;\n\t\t}\n\t\treset_control_assert(rstc_ref);\n\t\treset_control_deassert(rstc_ref);\n\t}\n\n\treset_control_assert(rstc);\n\treset_control_deassert(rstc);\n\n\treset_control_assert(rstc_ocp);\n\treset_control_deassert(rstc_ocp);\n\n\tcqspi->master_ref_clk_hz = clk_get_rate(cqspi->clk);\n\thost->max_speed_hz = cqspi->master_ref_clk_hz;\n\n\t \n\tcqspi->wr_completion = true;\n\n\tddata  = of_device_get_match_data(dev);\n\tif (ddata) {\n\t\tif (ddata->quirks & CQSPI_NEEDS_WR_DELAY)\n\t\t\tcqspi->wr_delay = 50 * DIV_ROUND_UP(NSEC_PER_SEC,\n\t\t\t\t\t\tcqspi->master_ref_clk_hz);\n\t\tif (ddata->hwcaps_mask & CQSPI_SUPPORTS_OCTAL)\n\t\t\thost->mode_bits |= SPI_RX_OCTAL | SPI_TX_OCTAL;\n\t\tif (!(ddata->quirks & CQSPI_DISABLE_DAC_MODE)) {\n\t\t\tcqspi->use_direct_mode = true;\n\t\t\tcqspi->use_direct_mode_wr = true;\n\t\t}\n\t\tif (ddata->quirks & CQSPI_SUPPORT_EXTERNAL_DMA)\n\t\t\tcqspi->use_dma_read = true;\n\t\tif (ddata->quirks & CQSPI_NO_SUPPORT_WR_COMPLETION)\n\t\t\tcqspi->wr_completion = false;\n\t\tif (ddata->quirks & CQSPI_SLOW_SRAM)\n\t\t\tcqspi->slow_sram = true;\n\t\tif (ddata->quirks & CQSPI_NEEDS_APB_AHB_HAZARD_WAR)\n\t\t\tcqspi->apb_ahb_hazard = true;\n\n\t\tif (ddata->jh7110_clk_init) {\n\t\t\tret = cqspi_jh7110_clk_init(pdev, cqspi);\n\t\t\tif (ret)\n\t\t\t\tgoto probe_reset_failed;\n\t\t}\n\n\t\tif (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t\t    \"xlnx,versal-ospi-1.0\")) {\n\t\t\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\t\t\tif (ret)\n\t\t\t\tgoto probe_reset_failed;\n\t\t}\n\t}\n\n\tret = devm_request_irq(dev, irq, cqspi_irq_handler, 0,\n\t\t\t       pdev->name, cqspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request IRQ.\\n\");\n\t\tgoto probe_reset_failed;\n\t}\n\n\tcqspi_wait_idle(cqspi);\n\tcqspi_controller_init(cqspi);\n\tcqspi->current_cs = -1;\n\tcqspi->sclk = 0;\n\n\thost->num_chipselect = cqspi->num_chipselect;\n\n\tret = cqspi_setup_flash(cqspi);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup flash parameters %d\\n\", ret);\n\t\tgoto probe_setup_failed;\n\t}\n\n\tif (cqspi->use_direct_mode) {\n\t\tret = cqspi_request_mmap_dma(cqspi);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto probe_setup_failed;\n\t}\n\n\tret = spi_register_controller(host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register SPI ctlr %d\\n\", ret);\n\t\tgoto probe_setup_failed;\n\t}\n\n\treturn 0;\nprobe_setup_failed:\n\tcqspi_controller_enable(cqspi, 0);\nprobe_reset_failed:\n\tif (cqspi->is_jh7110)\n\t\tcqspi_jh7110_disable_clk(pdev, cqspi);\n\tclk_disable_unprepare(cqspi->clk);\nprobe_clk_failed:\n\tpm_runtime_put_sync(dev);\nprobe_pm_failed:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void cqspi_remove(struct platform_device *pdev)\n{\n\tstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\n\n\tspi_unregister_controller(cqspi->host);\n\tcqspi_controller_enable(cqspi, 0);\n\n\tif (cqspi->rx_chan)\n\t\tdma_release_channel(cqspi->rx_chan);\n\n\tclk_disable_unprepare(cqspi->clk);\n\n\tif (cqspi->is_jh7110)\n\t\tcqspi_jh7110_disable_clk(pdev, cqspi);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int cqspi_suspend(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(host);\n\tcqspi_controller_enable(cqspi, 0);\n\n\tclk_disable_unprepare(cqspi->clk);\n\n\treturn ret;\n}\n\nstatic int cqspi_resume(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(cqspi->clk);\n\tcqspi_wait_idle(cqspi);\n\tcqspi_controller_init(cqspi);\n\n\tcqspi->current_cs = -1;\n\tcqspi->sclk = 0;\n\n\treturn spi_controller_resume(host);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cqspi_dev_pm_ops, cqspi_suspend, cqspi_resume);\n\nstatic const struct cqspi_driver_platdata cdns_qspi = {\n\t.quirks = CQSPI_DISABLE_DAC_MODE,\n};\n\nstatic const struct cqspi_driver_platdata k2g_qspi = {\n\t.quirks = CQSPI_NEEDS_WR_DELAY,\n};\n\nstatic const struct cqspi_driver_platdata am654_ospi = {\n\t.hwcaps_mask = CQSPI_SUPPORTS_OCTAL,\n\t.quirks = CQSPI_NEEDS_WR_DELAY,\n};\n\nstatic const struct cqspi_driver_platdata intel_lgm_qspi = {\n\t.quirks = CQSPI_DISABLE_DAC_MODE,\n};\n\nstatic const struct cqspi_driver_platdata socfpga_qspi = {\n\t.quirks = CQSPI_DISABLE_DAC_MODE\n\t\t\t| CQSPI_NO_SUPPORT_WR_COMPLETION\n\t\t\t| CQSPI_SLOW_SRAM,\n};\n\nstatic const struct cqspi_driver_platdata versal_ospi = {\n\t.hwcaps_mask = CQSPI_SUPPORTS_OCTAL,\n\t.quirks = CQSPI_DISABLE_DAC_MODE | CQSPI_SUPPORT_EXTERNAL_DMA,\n\t.indirect_read_dma = cqspi_versal_indirect_read_dma,\n\t.get_dma_status = cqspi_get_versal_dma_status,\n};\n\nstatic const struct cqspi_driver_platdata jh7110_qspi = {\n\t.quirks = CQSPI_DISABLE_DAC_MODE,\n\t.jh7110_clk_init = cqspi_jh7110_clk_init,\n};\n\nstatic const struct cqspi_driver_platdata pensando_cdns_qspi = {\n\t.quirks = CQSPI_NEEDS_APB_AHB_HAZARD_WAR | CQSPI_DISABLE_DAC_MODE,\n};\n\nstatic const struct of_device_id cqspi_dt_ids[] = {\n\t{\n\t\t.compatible = \"cdns,qspi-nor\",\n\t\t.data = &cdns_qspi,\n\t},\n\t{\n\t\t.compatible = \"ti,k2g-qspi\",\n\t\t.data = &k2g_qspi,\n\t},\n\t{\n\t\t.compatible = \"ti,am654-ospi\",\n\t\t.data = &am654_ospi,\n\t},\n\t{\n\t\t.compatible = \"intel,lgm-qspi\",\n\t\t.data = &intel_lgm_qspi,\n\t},\n\t{\n\t\t.compatible = \"xlnx,versal-ospi-1.0\",\n\t\t.data = &versal_ospi,\n\t},\n\t{\n\t\t.compatible = \"intel,socfpga-qspi\",\n\t\t.data = &socfpga_qspi,\n\t},\n\t{\n\t\t.compatible = \"starfive,jh7110-qspi\",\n\t\t.data = &jh7110_qspi,\n\t},\n\t{\n\t\t.compatible = \"amd,pensando-elba-qspi\",\n\t\t.data = &pensando_cdns_qspi,\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, cqspi_dt_ids);\n\nstatic struct platform_driver cqspi_platform_driver = {\n\t.probe = cqspi_probe,\n\t.remove_new = cqspi_remove,\n\t.driver = {\n\t\t.name = CQSPI_NAME,\n\t\t.pm = &cqspi_dev_pm_ops,\n\t\t.of_match_table = cqspi_dt_ids,\n\t},\n};\n\nmodule_platform_driver(cqspi_platform_driver);\n\nMODULE_DESCRIPTION(\"Cadence QSPI Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" CQSPI_NAME);\nMODULE_AUTHOR(\"Ley Foon Tan <lftan@altera.com>\");\nMODULE_AUTHOR(\"Graham Moore <grmoore@opensource.altera.com>\");\nMODULE_AUTHOR(\"Vadivel Murugan R <vadivel.muruganx.ramuthevar@intel.com>\");\nMODULE_AUTHOR(\"Vignesh Raghavendra <vigneshr@ti.com>\");\nMODULE_AUTHOR(\"Pratyush Yadav <p.yadav@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}