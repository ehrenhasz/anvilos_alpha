{
  "module_name": "atmel-quadspi.c",
  "hash_id": "6f96f4d141c121f0bf3b7395bbb281a3a90ff6e02e2d3849aa259de81a8b00d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/atmel-quadspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define QSPI_CR      0x0000   \n#define QSPI_MR      0x0004   \n#define QSPI_RD      0x0008   \n#define QSPI_TD      0x000c   \n#define QSPI_SR      0x0010   \n#define QSPI_IER     0x0014   \n#define QSPI_IDR     0x0018   \n#define QSPI_IMR     0x001c   \n#define QSPI_SCR     0x0020   \n\n#define QSPI_IAR     0x0030   \n#define QSPI_ICR     0x0034   \n#define QSPI_WICR    0x0034   \n#define QSPI_IFR     0x0038   \n#define QSPI_RICR    0x003C   \n\n#define QSPI_SMR     0x0040   \n#define QSPI_SKR     0x0044   \n\n#define QSPI_WPMR    0x00E4   \n#define QSPI_WPSR    0x00E8   \n\n#define QSPI_VERSION 0x00FC   \n\n\n \n#define QSPI_CR_QSPIEN                  BIT(0)\n#define QSPI_CR_QSPIDIS                 BIT(1)\n#define QSPI_CR_SWRST                   BIT(7)\n#define QSPI_CR_LASTXFER                BIT(24)\n\n \n#define QSPI_MR_SMM                     BIT(0)\n#define QSPI_MR_LLB                     BIT(1)\n#define QSPI_MR_WDRBT                   BIT(2)\n#define QSPI_MR_SMRM                    BIT(3)\n#define QSPI_MR_CSMODE_MASK             GENMASK(5, 4)\n#define QSPI_MR_CSMODE_NOT_RELOADED     (0 << 4)\n#define QSPI_MR_CSMODE_LASTXFER         (1 << 4)\n#define QSPI_MR_CSMODE_SYSTEMATICALLY   (2 << 4)\n#define QSPI_MR_NBBITS_MASK             GENMASK(11, 8)\n#define QSPI_MR_NBBITS(n)               ((((n) - 8) << 8) & QSPI_MR_NBBITS_MASK)\n#define QSPI_MR_DLYBCT_MASK             GENMASK(23, 16)\n#define QSPI_MR_DLYBCT(n)               (((n) << 16) & QSPI_MR_DLYBCT_MASK)\n#define QSPI_MR_DLYCS_MASK              GENMASK(31, 24)\n#define QSPI_MR_DLYCS(n)                (((n) << 24) & QSPI_MR_DLYCS_MASK)\n\n \n#define QSPI_SR_RDRF                    BIT(0)\n#define QSPI_SR_TDRE                    BIT(1)\n#define QSPI_SR_TXEMPTY                 BIT(2)\n#define QSPI_SR_OVRES                   BIT(3)\n#define QSPI_SR_CSR                     BIT(8)\n#define QSPI_SR_CSS                     BIT(9)\n#define QSPI_SR_INSTRE                  BIT(10)\n#define QSPI_SR_QSPIENS                 BIT(24)\n\n#define QSPI_SR_CMD_COMPLETED\t(QSPI_SR_INSTRE | QSPI_SR_CSR)\n\n \n#define QSPI_SCR_CPOL                   BIT(0)\n#define QSPI_SCR_CPHA                   BIT(1)\n#define QSPI_SCR_SCBR_MASK              GENMASK(15, 8)\n#define QSPI_SCR_SCBR(n)                (((n) << 8) & QSPI_SCR_SCBR_MASK)\n#define QSPI_SCR_DLYBS_MASK             GENMASK(23, 16)\n#define QSPI_SCR_DLYBS(n)               (((n) << 16) & QSPI_SCR_DLYBS_MASK)\n\n \n#define QSPI_ICR_INST_MASK              GENMASK(7, 0)\n#define QSPI_ICR_INST(inst)             (((inst) << 0) & QSPI_ICR_INST_MASK)\n#define QSPI_ICR_OPT_MASK               GENMASK(23, 16)\n#define QSPI_ICR_OPT(opt)               (((opt) << 16) & QSPI_ICR_OPT_MASK)\n\n \n#define QSPI_IFR_WIDTH_MASK             GENMASK(2, 0)\n#define QSPI_IFR_WIDTH_SINGLE_BIT_SPI   (0 << 0)\n#define QSPI_IFR_WIDTH_DUAL_OUTPUT      (1 << 0)\n#define QSPI_IFR_WIDTH_QUAD_OUTPUT      (2 << 0)\n#define QSPI_IFR_WIDTH_DUAL_IO          (3 << 0)\n#define QSPI_IFR_WIDTH_QUAD_IO          (4 << 0)\n#define QSPI_IFR_WIDTH_DUAL_CMD         (5 << 0)\n#define QSPI_IFR_WIDTH_QUAD_CMD         (6 << 0)\n#define QSPI_IFR_INSTEN                 BIT(4)\n#define QSPI_IFR_ADDREN                 BIT(5)\n#define QSPI_IFR_OPTEN                  BIT(6)\n#define QSPI_IFR_DATAEN                 BIT(7)\n#define QSPI_IFR_OPTL_MASK              GENMASK(9, 8)\n#define QSPI_IFR_OPTL_1BIT              (0 << 8)\n#define QSPI_IFR_OPTL_2BIT              (1 << 8)\n#define QSPI_IFR_OPTL_4BIT              (2 << 8)\n#define QSPI_IFR_OPTL_8BIT              (3 << 8)\n#define QSPI_IFR_ADDRL                  BIT(10)\n#define QSPI_IFR_TFRTYP_MEM\t\tBIT(12)\n#define QSPI_IFR_SAMA5D2_WRITE_TRSFR\tBIT(13)\n#define QSPI_IFR_CRM                    BIT(14)\n#define QSPI_IFR_NBDUM_MASK             GENMASK(20, 16)\n#define QSPI_IFR_NBDUM(n)               (((n) << 16) & QSPI_IFR_NBDUM_MASK)\n#define QSPI_IFR_APBTFRTYP_READ\t\tBIT(24)\t \n\n \n#define QSPI_SMR_SCREN                  BIT(0)\n#define QSPI_SMR_RVDIS                  BIT(1)\n\n \n#define QSPI_WPMR_WPEN                  BIT(0)\n#define QSPI_WPMR_WPKEY_MASK            GENMASK(31, 8)\n#define QSPI_WPMR_WPKEY(wpkey)          (((wpkey) << 8) & QSPI_WPMR_WPKEY_MASK)\n\n \n#define QSPI_WPSR_WPVS                  BIT(0)\n#define QSPI_WPSR_WPVSRC_MASK           GENMASK(15, 8)\n#define QSPI_WPSR_WPVSRC(src)           (((src) << 8) & QSPI_WPSR_WPVSRC)\n\nstruct atmel_qspi_caps {\n\tbool has_qspick;\n\tbool has_ricr;\n};\n\nstruct atmel_qspi {\n\tvoid __iomem\t\t*regs;\n\tvoid __iomem\t\t*mem;\n\tstruct clk\t\t*pclk;\n\tstruct clk\t\t*qspick;\n\tstruct platform_device\t*pdev;\n\tconst struct atmel_qspi_caps *caps;\n\tresource_size_t\t\tmmap_size;\n\tu32\t\t\tpending;\n\tu32\t\t\tmr;\n\tu32\t\t\tscr;\n\tstruct completion\tcmd_completion;\n};\n\nstruct atmel_qspi_mode {\n\tu8 cmd_buswidth;\n\tu8 addr_buswidth;\n\tu8 data_buswidth;\n\tu32 config;\n};\n\nstatic const struct atmel_qspi_mode atmel_qspi_modes[] = {\n\t{ 1, 1, 1, QSPI_IFR_WIDTH_SINGLE_BIT_SPI },\n\t{ 1, 1, 2, QSPI_IFR_WIDTH_DUAL_OUTPUT },\n\t{ 1, 1, 4, QSPI_IFR_WIDTH_QUAD_OUTPUT },\n\t{ 1, 2, 2, QSPI_IFR_WIDTH_DUAL_IO },\n\t{ 1, 4, 4, QSPI_IFR_WIDTH_QUAD_IO },\n\t{ 2, 2, 2, QSPI_IFR_WIDTH_DUAL_CMD },\n\t{ 4, 4, 4, QSPI_IFR_WIDTH_QUAD_CMD },\n};\n\n#ifdef VERBOSE_DEBUG\nstatic const char *atmel_qspi_reg_name(u32 offset, char *tmp, size_t sz)\n{\n\tswitch (offset) {\n\tcase QSPI_CR:\n\t\treturn \"CR\";\n\tcase QSPI_MR:\n\t\treturn \"MR\";\n\tcase QSPI_RD:\n\t\treturn \"MR\";\n\tcase QSPI_TD:\n\t\treturn \"TD\";\n\tcase QSPI_SR:\n\t\treturn \"SR\";\n\tcase QSPI_IER:\n\t\treturn \"IER\";\n\tcase QSPI_IDR:\n\t\treturn \"IDR\";\n\tcase QSPI_IMR:\n\t\treturn \"IMR\";\n\tcase QSPI_SCR:\n\t\treturn \"SCR\";\n\tcase QSPI_IAR:\n\t\treturn \"IAR\";\n\tcase QSPI_ICR:\n\t\treturn \"ICR/WICR\";\n\tcase QSPI_IFR:\n\t\treturn \"IFR\";\n\tcase QSPI_RICR:\n\t\treturn \"RICR\";\n\tcase QSPI_SMR:\n\t\treturn \"SMR\";\n\tcase QSPI_SKR:\n\t\treturn \"SKR\";\n\tcase QSPI_WPMR:\n\t\treturn \"WPMR\";\n\tcase QSPI_WPSR:\n\t\treturn \"WPSR\";\n\tcase QSPI_VERSION:\n\t\treturn \"VERSION\";\n\tdefault:\n\t\tsnprintf(tmp, sz, \"0x%02x\", offset);\n\t\tbreak;\n\t}\n\n\treturn tmp;\n}\n#endif  \n\nstatic u32 atmel_qspi_read(struct atmel_qspi *aq, u32 offset)\n{\n\tu32 value = readl_relaxed(aq->regs + offset);\n\n#ifdef VERBOSE_DEBUG\n\tchar tmp[8];\n\n\tdev_vdbg(&aq->pdev->dev, \"read 0x%08x from %s\\n\", value,\n\t\t atmel_qspi_reg_name(offset, tmp, sizeof(tmp)));\n#endif  \n\n\treturn value;\n}\n\nstatic void atmel_qspi_write(u32 value, struct atmel_qspi *aq, u32 offset)\n{\n#ifdef VERBOSE_DEBUG\n\tchar tmp[8];\n\n\tdev_vdbg(&aq->pdev->dev, \"write 0x%08x into %s\\n\", value,\n\t\t atmel_qspi_reg_name(offset, tmp, sizeof(tmp)));\n#endif  \n\n\twritel_relaxed(value, aq->regs + offset);\n}\n\nstatic inline bool atmel_qspi_is_compatible(const struct spi_mem_op *op,\n\t\t\t\t\t    const struct atmel_qspi_mode *mode)\n{\n\tif (op->cmd.buswidth != mode->cmd_buswidth)\n\t\treturn false;\n\n\tif (op->addr.nbytes && op->addr.buswidth != mode->addr_buswidth)\n\t\treturn false;\n\n\tif (op->data.nbytes && op->data.buswidth != mode->data_buswidth)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int atmel_qspi_find_mode(const struct spi_mem_op *op)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atmel_qspi_modes); i++)\n\t\tif (atmel_qspi_is_compatible(op, &atmel_qspi_modes[i]))\n\t\t\treturn i;\n\n\treturn -ENOTSUPP;\n}\n\nstatic bool atmel_qspi_supports_op(struct spi_mem *mem,\n\t\t\t\t   const struct spi_mem_op *op)\n{\n\tif (!spi_mem_default_supports_op(mem, op))\n\t\treturn false;\n\n\tif (atmel_qspi_find_mode(op) < 0)\n\t\treturn false;\n\n\t \n\tif (op->addr.nbytes == 2 && op->cmd.buswidth != op->addr.buswidth &&\n\t    op->dummy.nbytes == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int atmel_qspi_set_cfg(struct atmel_qspi *aq,\n\t\t\t      const struct spi_mem_op *op, u32 *offset)\n{\n\tu32 iar, icr, ifr;\n\tu32 dummy_cycles = 0;\n\tint mode;\n\n\tiar = 0;\n\ticr = QSPI_ICR_INST(op->cmd.opcode);\n\tifr = QSPI_IFR_INSTEN;\n\n\tmode = atmel_qspi_find_mode(op);\n\tif (mode < 0)\n\t\treturn mode;\n\tifr |= atmel_qspi_modes[mode].config;\n\n\tif (op->dummy.nbytes)\n\t\tdummy_cycles = op->dummy.nbytes * 8 / op->dummy.buswidth;\n\n\t \n\tif (op->addr.buswidth) {\n\t\tswitch (op->addr.nbytes) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tifr |= QSPI_IFR_OPTEN | QSPI_IFR_OPTL_8BIT;\n\t\t\ticr |= QSPI_ICR_OPT(op->addr.val & 0xff);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (dummy_cycles < 8 / op->addr.buswidth) {\n\t\t\t\tifr &= ~QSPI_IFR_INSTEN;\n\t\t\t\tifr |= QSPI_IFR_ADDREN;\n\t\t\t\tiar = (op->cmd.opcode << 16) |\n\t\t\t\t\t(op->addr.val & 0xffff);\n\t\t\t} else {\n\t\t\t\tifr |= QSPI_IFR_ADDREN;\n\t\t\t\tiar = (op->addr.val << 8) & 0xffffff;\n\t\t\t\tdummy_cycles -= 8 / op->addr.buswidth;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tifr |= QSPI_IFR_ADDREN;\n\t\t\tiar = op->addr.val & 0xffffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tifr |= QSPI_IFR_ADDREN | QSPI_IFR_ADDRL;\n\t\t\tiar = op->addr.val & 0x7ffffff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\t \n\t*offset = iar;\n\n\t \n\tif (dummy_cycles)\n\t\tifr |= QSPI_IFR_NBDUM(dummy_cycles);\n\n\t \n\tif (op->data.nbytes) {\n\t\tifr |= QSPI_IFR_DATAEN;\n\n\t\tif (op->addr.nbytes)\n\t\t\tifr |= QSPI_IFR_TFRTYP_MEM;\n\t}\n\n\t \n\tif (aq->mr != QSPI_MR_SMM) {\n\t\tatmel_qspi_write(QSPI_MR_SMM, aq, QSPI_MR);\n\t\taq->mr = QSPI_MR_SMM;\n\t}\n\n\t \n\t(void)atmel_qspi_read(aq, QSPI_SR);\n\n\t \n\tif (op->addr.nbytes && !op->data.nbytes)\n\t\tatmel_qspi_write(iar, aq, QSPI_IAR);\n\n\tif (aq->caps->has_ricr) {\n\t\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\t\tatmel_qspi_write(icr, aq, QSPI_RICR);\n\t\telse\n\t\t\tatmel_qspi_write(icr, aq, QSPI_WICR);\n\t} else {\n\t\tif (op->data.nbytes && op->data.dir == SPI_MEM_DATA_OUT)\n\t\t\tifr |= QSPI_IFR_SAMA5D2_WRITE_TRSFR;\n\n\t\tatmel_qspi_write(icr, aq, QSPI_ICR);\n\t}\n\n\tatmel_qspi_write(ifr, aq, QSPI_IFR);\n\n\treturn 0;\n}\n\nstatic int atmel_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(mem->spi->controller);\n\tu32 sr, offset;\n\tint err;\n\n\t \n\tif (op->addr.val + op->data.nbytes > aq->mmap_size)\n\t\treturn -ENOTSUPP;\n\n\terr = pm_runtime_resume_and_get(&aq->pdev->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = atmel_qspi_set_cfg(aq, op, &offset);\n\tif (err)\n\t\tgoto pm_runtime_put;\n\n\t \n\tif (op->data.nbytes) {\n\t\t \n\t\t(void)atmel_qspi_read(aq, QSPI_IFR);\n\n\t\t \n\t\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\t\tmemcpy_fromio(op->data.buf.in, aq->mem + offset,\n\t\t\t\t      op->data.nbytes);\n\t\telse\n\t\t\tmemcpy_toio(aq->mem + offset, op->data.buf.out,\n\t\t\t\t    op->data.nbytes);\n\n\t\t \n\t\tatmel_qspi_write(QSPI_CR_LASTXFER, aq, QSPI_CR);\n\t}\n\n\t \n\tsr = atmel_qspi_read(aq, QSPI_SR);\n\tif ((sr & QSPI_SR_CMD_COMPLETED) == QSPI_SR_CMD_COMPLETED)\n\t\tgoto pm_runtime_put;\n\n\t \n\treinit_completion(&aq->cmd_completion);\n\taq->pending = sr & QSPI_SR_CMD_COMPLETED;\n\tatmel_qspi_write(QSPI_SR_CMD_COMPLETED, aq, QSPI_IER);\n\tif (!wait_for_completion_timeout(&aq->cmd_completion,\n\t\t\t\t\t msecs_to_jiffies(1000)))\n\t\terr = -ETIMEDOUT;\n\tatmel_qspi_write(QSPI_SR_CMD_COMPLETED, aq, QSPI_IDR);\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(&aq->pdev->dev);\n\tpm_runtime_put_autosuspend(&aq->pdev->dev);\n\treturn err;\n}\n\nstatic const char *atmel_qspi_get_name(struct spi_mem *spimem)\n{\n\treturn dev_name(spimem->spi->dev.parent);\n}\n\nstatic const struct spi_controller_mem_ops atmel_qspi_mem_ops = {\n\t.supports_op = atmel_qspi_supports_op,\n\t.exec_op = atmel_qspi_exec_op,\n\t.get_name = atmel_qspi_get_name\n};\n\nstatic int atmel_qspi_setup(struct spi_device *spi)\n{\n\tstruct spi_controller *ctrl = spi->controller;\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tunsigned long src_rate;\n\tu32 scbr;\n\tint ret;\n\n\tif (ctrl->busy)\n\t\treturn -EBUSY;\n\n\tif (!spi->max_speed_hz)\n\t\treturn -EINVAL;\n\n\tsrc_rate = clk_get_rate(aq->pclk);\n\tif (!src_rate)\n\t\treturn -EINVAL;\n\n\t \n\tscbr = DIV_ROUND_UP(src_rate, spi->max_speed_hz);\n\tif (scbr > 0)\n\t\tscbr--;\n\n\tret = pm_runtime_resume_and_get(ctrl->dev.parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taq->scr = QSPI_SCR_SCBR(scbr);\n\tatmel_qspi_write(aq->scr, aq, QSPI_SCR);\n\n\tpm_runtime_mark_last_busy(ctrl->dev.parent);\n\tpm_runtime_put_autosuspend(ctrl->dev.parent);\n\n\treturn 0;\n}\n\nstatic int atmel_qspi_set_cs_timing(struct spi_device *spi)\n{\n\tstruct spi_controller *ctrl = spi->controller;\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tunsigned long clk_rate;\n\tu32 cs_setup;\n\tint delay;\n\tint ret;\n\n\tdelay = spi_delay_to_ns(&spi->cs_setup, NULL);\n\tif (delay <= 0)\n\t\treturn delay;\n\n\tclk_rate = clk_get_rate(aq->pclk);\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\tcs_setup = DIV_ROUND_UP((delay * DIV_ROUND_UP(clk_rate, 1000000)),\n\t\t\t\t1000);\n\n\tret = pm_runtime_resume_and_get(ctrl->dev.parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taq->scr |= QSPI_SCR_DLYBS(cs_setup);\n\tatmel_qspi_write(aq->scr, aq, QSPI_SCR);\n\n\tpm_runtime_mark_last_busy(ctrl->dev.parent);\n\tpm_runtime_put_autosuspend(ctrl->dev.parent);\n\n\treturn 0;\n}\n\nstatic void atmel_qspi_init(struct atmel_qspi *aq)\n{\n\t \n\tatmel_qspi_write(QSPI_CR_SWRST, aq, QSPI_CR);\n\n\t \n\tatmel_qspi_write(QSPI_MR_SMM, aq, QSPI_MR);\n\taq->mr = QSPI_MR_SMM;\n\n\t \n\tatmel_qspi_write(QSPI_CR_QSPIEN, aq, QSPI_CR);\n}\n\nstatic irqreturn_t atmel_qspi_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_qspi *aq = dev_id;\n\tu32 status, mask, pending;\n\n\tstatus = atmel_qspi_read(aq, QSPI_SR);\n\tmask = atmel_qspi_read(aq, QSPI_IMR);\n\tpending = status & mask;\n\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\taq->pending |= pending;\n\tif ((aq->pending & QSPI_SR_CMD_COMPLETED) == QSPI_SR_CMD_COMPLETED)\n\t\tcomplete(&aq->cmd_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int atmel_qspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl;\n\tstruct atmel_qspi *aq;\n\tstruct resource *res;\n\tint irq, err = 0;\n\n\tctrl = devm_spi_alloc_host(&pdev->dev, sizeof(*aq));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_DUAL | SPI_TX_QUAD;\n\tctrl->setup = atmel_qspi_setup;\n\tctrl->set_cs_timing = atmel_qspi_set_cs_timing;\n\tctrl->bus_num = -1;\n\tctrl->mem_ops = &atmel_qspi_mem_ops;\n\tctrl->num_chipselect = 1;\n\tctrl->dev.of_node = pdev->dev.of_node;\n\tplatform_set_drvdata(pdev, ctrl);\n\n\taq = spi_controller_get_devdata(ctrl);\n\n\tinit_completion(&aq->cmd_completion);\n\taq->pdev = pdev;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qspi_base\");\n\taq->regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(aq->regs)) {\n\t\tdev_err(&pdev->dev, \"missing registers\\n\");\n\t\treturn PTR_ERR(aq->regs);\n\t}\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qspi_mmap\");\n\taq->mem = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(aq->mem)) {\n\t\tdev_err(&pdev->dev, \"missing AHB memory\\n\");\n\t\treturn PTR_ERR(aq->mem);\n\t}\n\n\taq->mmap_size = resource_size(res);\n\n\t \n\taq->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(aq->pclk))\n\t\taq->pclk = devm_clk_get(&pdev->dev, NULL);\n\n\tif (IS_ERR(aq->pclk)) {\n\t\tdev_err(&pdev->dev, \"missing peripheral clock\\n\");\n\t\treturn PTR_ERR(aq->pclk);\n\t}\n\n\t \n\terr = clk_prepare_enable(aq->pclk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable the peripheral clock\\n\");\n\t\treturn err;\n\t}\n\n\taq->caps = of_device_get_match_data(&pdev->dev);\n\tif (!aq->caps) {\n\t\tdev_err(&pdev->dev, \"Could not retrieve QSPI caps\\n\");\n\t\terr = -EINVAL;\n\t\tgoto disable_pclk;\n\t}\n\n\tif (aq->caps->has_qspick) {\n\t\t \n\t\taq->qspick = devm_clk_get(&pdev->dev, \"qspick\");\n\t\tif (IS_ERR(aq->qspick)) {\n\t\t\tdev_err(&pdev->dev, \"missing system clock\\n\");\n\t\t\terr = PTR_ERR(aq->qspick);\n\t\t\tgoto disable_pclk;\n\t\t}\n\n\t\t \n\t\terr = clk_prepare_enable(aq->qspick);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to enable the QSPI system clock\\n\");\n\t\t\tgoto disable_pclk;\n\t\t}\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto disable_qspick;\n\t}\n\terr = devm_request_irq(&pdev->dev, irq, atmel_qspi_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), aq);\n\tif (err)\n\t\tgoto disable_qspick;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 500);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tatmel_qspi_init(aq);\n\n\terr = spi_register_controller(ctrl);\n\tif (err) {\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_set_suspended(&pdev->dev);\n\t\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\t\tgoto disable_qspick;\n\t}\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\ndisable_qspick:\n\tclk_disable_unprepare(aq->qspick);\ndisable_pclk:\n\tclk_disable_unprepare(aq->pclk);\n\n\treturn err;\n}\n\nstatic void atmel_qspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl = platform_get_drvdata(pdev);\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tspi_unregister_controller(ctrl);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret >= 0) {\n\t\tatmel_qspi_write(QSPI_CR_QSPIDIS, aq, QSPI_CR);\n\t\tclk_disable(aq->qspick);\n\t\tclk_disable(aq->pclk);\n\t} else {\n\t\t \n\t\tdev_warn(&pdev->dev, \"Failed to resume device on remove\\n\");\n\t}\n\n\tclk_unprepare(aq->qspick);\n\tclk_unprepare(aq->pclk);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n}\n\nstatic int __maybe_unused atmel_qspi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tatmel_qspi_write(QSPI_CR_QSPIDIS, aq, QSPI_CR);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_force_suspend(dev);\n\n\tclk_unprepare(aq->qspick);\n\tclk_unprepare(aq->pclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_qspi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tclk_prepare(aq->pclk);\n\tclk_prepare(aq->qspick);\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tatmel_qspi_init(aq);\n\n\tatmel_qspi_write(aq->scr, aq, QSPI_SCR);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_qspi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\n\tclk_disable(aq->qspick);\n\tclk_disable(aq->pclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_qspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct atmel_qspi *aq = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tret = clk_enable(aq->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(aq->qspick);\n\tif (ret)\n\t\tclk_disable(aq->pclk);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops __maybe_unused atmel_qspi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(atmel_qspi_suspend, atmel_qspi_resume)\n\tSET_RUNTIME_PM_OPS(atmel_qspi_runtime_suspend,\n\t\t\t   atmel_qspi_runtime_resume, NULL)\n};\n\nstatic const struct atmel_qspi_caps atmel_sama5d2_qspi_caps = {};\n\nstatic const struct atmel_qspi_caps atmel_sam9x60_qspi_caps = {\n\t.has_qspick = true,\n\t.has_ricr = true,\n};\n\nstatic const struct of_device_id atmel_qspi_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-qspi\",\n\t\t.data = &atmel_sama5d2_qspi_caps,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-qspi\",\n\t\t.data = &atmel_sam9x60_qspi_caps,\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_qspi_dt_ids);\n\nstatic struct platform_driver atmel_qspi_driver = {\n\t.driver = {\n\t\t.name\t= \"atmel_qspi\",\n\t\t.of_match_table\t= atmel_qspi_dt_ids,\n\t\t.pm\t= pm_ptr(&atmel_qspi_pm_ops),\n\t},\n\t.probe\t\t= atmel_qspi_probe,\n\t.remove_new\t= atmel_qspi_remove,\n};\nmodule_platform_driver(atmel_qspi_driver);\n\nMODULE_AUTHOR(\"Cyrille Pitchen <cyrille.pitchen@atmel.com>\");\nMODULE_AUTHOR(\"Piotr Bugalski <bugalski.piotr@gmail.com\");\nMODULE_DESCRIPTION(\"Atmel QSPI Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}