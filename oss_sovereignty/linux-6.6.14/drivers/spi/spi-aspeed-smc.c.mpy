{
  "module_name": "spi-aspeed-smc.c",
  "hash_id": "73679186e8ffd766475be6bfd24ab0b81cb3c4cfbeb0737656233a94dab8d9b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-aspeed-smc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#define DEVICE_NAME \"spi-aspeed-smc\"\n\n \n#define CONFIG_REG\t\t\t0x0\n#define   CONFIG_TYPE_SPI\t\t0x2\n\n \n#define CE_CTRL_REG\t\t\t0x4\n\n \n#define CE0_CTRL_REG\t\t\t0x10\n#define   CTRL_IO_MODE_MASK\t\tGENMASK(30, 28)\n#define   CTRL_IO_SINGLE_DATA\t        0x0\n#define   CTRL_IO_DUAL_DATA\t\tBIT(29)\n#define   CTRL_IO_QUAD_DATA\t\tBIT(30)\n#define   CTRL_COMMAND_SHIFT\t\t16\n#define   CTRL_IO_ADDRESS_4B\t\tBIT(13)\t \n#define   CTRL_IO_DUMMY_SET(dummy)\t\t\t\t\t\\\n\t(((((dummy) >> 2) & 0x1) << 14) | (((dummy) & 0x3) << 6))\n#define   CTRL_FREQ_SEL_SHIFT\t\t8\n#define   CTRL_FREQ_SEL_MASK\t\tGENMASK(11, CTRL_FREQ_SEL_SHIFT)\n#define   CTRL_CE_STOP_ACTIVE\t\tBIT(2)\n#define   CTRL_IO_MODE_CMD_MASK\t\tGENMASK(1, 0)\n#define   CTRL_IO_MODE_NORMAL\t\t0x0\n#define   CTRL_IO_MODE_READ\t\t0x1\n#define   CTRL_IO_MODE_WRITE\t\t0x2\n#define   CTRL_IO_MODE_USER\t\t0x3\n\n#define   CTRL_IO_CMD_MASK\t\t0xf0ff40c3\n\n \n#define CE0_SEGMENT_ADDR_REG\t\t0x30\n\n \n#define CE0_TIMING_COMPENSATION_REG\t0x94\n\nenum aspeed_spi_ctl_reg_value {\n\tASPEED_SPI_BASE,\n\tASPEED_SPI_READ,\n\tASPEED_SPI_WRITE,\n\tASPEED_SPI_MAX,\n};\n\nstruct aspeed_spi;\n\nstruct aspeed_spi_chip {\n\tstruct aspeed_spi\t*aspi;\n\tu32\t\t\t cs;\n\tvoid __iomem\t\t*ctl;\n\tvoid __iomem\t\t*ahb_base;\n\tu32\t\t\t ahb_window_size;\n\tu32\t\t\t ctl_val[ASPEED_SPI_MAX];\n\tu32\t\t\t clk_freq;\n};\n\nstruct aspeed_spi_data {\n\tu32\tctl0;\n\tu32\tmax_cs;\n\tbool\thastype;\n\tu32\tmode_bits;\n\tu32\twe0;\n\tu32\ttiming;\n\tu32\thclk_mask;\n\tu32\thdiv_max;\n\n\tu32 (*segment_start)(struct aspeed_spi *aspi, u32 reg);\n\tu32 (*segment_end)(struct aspeed_spi *aspi, u32 reg);\n\tu32 (*segment_reg)(struct aspeed_spi *aspi, u32 start, u32 end);\n\tint (*calibrate)(struct aspeed_spi_chip *chip, u32 hdiv,\n\t\t\t const u8 *golden_buf, u8 *test_buf);\n};\n\n#define ASPEED_SPI_MAX_NUM_CS\t5\n\nstruct aspeed_spi {\n\tconst struct aspeed_spi_data\t*data;\n\n\tvoid __iomem\t\t*regs;\n\tvoid __iomem\t\t*ahb_base;\n\tu32\t\t\t ahb_base_phy;\n\tu32\t\t\t ahb_window_size;\n\tstruct device\t\t*dev;\n\n\tstruct clk\t\t*clk;\n\tu32\t\t\t clk_freq;\n\n\tstruct aspeed_spi_chip\t chips[ASPEED_SPI_MAX_NUM_CS];\n};\n\nstatic u32 aspeed_spi_get_io_mode(const struct spi_mem_op *op)\n{\n\tswitch (op->data.buswidth) {\n\tcase 1:\n\t\treturn CTRL_IO_SINGLE_DATA;\n\tcase 2:\n\t\treturn CTRL_IO_DUAL_DATA;\n\tcase 4:\n\t\treturn CTRL_IO_QUAD_DATA;\n\tdefault:\n\t\treturn CTRL_IO_SINGLE_DATA;\n\t}\n}\n\nstatic void aspeed_spi_set_io_mode(struct aspeed_spi_chip *chip, u32 io_mode)\n{\n\tu32 ctl;\n\n\tif (io_mode > 0) {\n\t\tctl = readl(chip->ctl) & ~CTRL_IO_MODE_MASK;\n\t\tctl |= io_mode;\n\t\twritel(ctl, chip->ctl);\n\t}\n}\n\nstatic void aspeed_spi_start_user(struct aspeed_spi_chip *chip)\n{\n\tu32 ctl = chip->ctl_val[ASPEED_SPI_BASE];\n\n\tctl |= CTRL_IO_MODE_USER | CTRL_CE_STOP_ACTIVE;\n\twritel(ctl, chip->ctl);\n\n\tctl &= ~CTRL_CE_STOP_ACTIVE;\n\twritel(ctl, chip->ctl);\n}\n\nstatic void aspeed_spi_stop_user(struct aspeed_spi_chip *chip)\n{\n\tu32 ctl = chip->ctl_val[ASPEED_SPI_READ] |\n\t\tCTRL_IO_MODE_USER | CTRL_CE_STOP_ACTIVE;\n\n\twritel(ctl, chip->ctl);\n\n\t \n\twritel(chip->ctl_val[ASPEED_SPI_READ], chip->ctl);\n}\n\nstatic int aspeed_spi_read_from_ahb(void *buf, void __iomem *src, size_t len)\n{\n\tsize_t offset = 0;\n\n\tif (IS_ALIGNED((uintptr_t)src, sizeof(uintptr_t)) &&\n\t    IS_ALIGNED((uintptr_t)buf, sizeof(uintptr_t))) {\n\t\tioread32_rep(src, buf, len >> 2);\n\t\toffset = len & ~0x3;\n\t\tlen -= offset;\n\t}\n\tioread8_rep(src, (u8 *)buf + offset, len);\n\treturn 0;\n}\n\nstatic int aspeed_spi_write_to_ahb(void __iomem *dst, const void *buf, size_t len)\n{\n\tsize_t offset = 0;\n\n\tif (IS_ALIGNED((uintptr_t)dst, sizeof(uintptr_t)) &&\n\t    IS_ALIGNED((uintptr_t)buf, sizeof(uintptr_t))) {\n\t\tiowrite32_rep(dst, buf, len >> 2);\n\t\toffset = len & ~0x3;\n\t\tlen -= offset;\n\t}\n\tiowrite8_rep(dst, (const u8 *)buf + offset, len);\n\treturn 0;\n}\n\nstatic int aspeed_spi_send_cmd_addr(struct aspeed_spi_chip *chip, u8 addr_nbytes,\n\t\t\t\t    u64 offset, u32 opcode)\n{\n\t__be32 temp;\n\tu32 cmdaddr;\n\n\tswitch (addr_nbytes) {\n\tcase 3:\n\t\tcmdaddr = offset & 0xFFFFFF;\n\t\tcmdaddr |= opcode << 24;\n\n\t\ttemp = cpu_to_be32(cmdaddr);\n\t\taspeed_spi_write_to_ahb(chip->ahb_base, &temp, 4);\n\t\tbreak;\n\tcase 4:\n\t\ttemp = cpu_to_be32(offset);\n\t\taspeed_spi_write_to_ahb(chip->ahb_base, &opcode, 1);\n\t\taspeed_spi_write_to_ahb(chip->ahb_base, &temp, 4);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unexpected address width %u\", addr_nbytes);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int aspeed_spi_read_reg(struct aspeed_spi_chip *chip,\n\t\t\t       const struct spi_mem_op *op)\n{\n\taspeed_spi_start_user(chip);\n\taspeed_spi_write_to_ahb(chip->ahb_base, &op->cmd.opcode, 1);\n\taspeed_spi_read_from_ahb(op->data.buf.in,\n\t\t\t\t chip->ahb_base, op->data.nbytes);\n\taspeed_spi_stop_user(chip);\n\treturn 0;\n}\n\nstatic int aspeed_spi_write_reg(struct aspeed_spi_chip *chip,\n\t\t\t\tconst struct spi_mem_op *op)\n{\n\taspeed_spi_start_user(chip);\n\taspeed_spi_write_to_ahb(chip->ahb_base, &op->cmd.opcode, 1);\n\taspeed_spi_write_to_ahb(chip->ahb_base, op->data.buf.out,\n\t\t\t\top->data.nbytes);\n\taspeed_spi_stop_user(chip);\n\treturn 0;\n}\n\nstatic ssize_t aspeed_spi_read_user(struct aspeed_spi_chip *chip,\n\t\t\t\t    const struct spi_mem_op *op,\n\t\t\t\t    u64 offset, size_t len, void *buf)\n{\n\tint io_mode = aspeed_spi_get_io_mode(op);\n\tu8 dummy = 0xFF;\n\tint i;\n\tint ret;\n\n\taspeed_spi_start_user(chip);\n\n\tret = aspeed_spi_send_cmd_addr(chip, op->addr.nbytes, offset, op->cmd.opcode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (op->dummy.buswidth && op->dummy.nbytes) {\n\t\tfor (i = 0; i < op->dummy.nbytes / op->dummy.buswidth; i++)\n\t\t\taspeed_spi_write_to_ahb(chip->ahb_base, &dummy,\tsizeof(dummy));\n\t}\n\n\taspeed_spi_set_io_mode(chip, io_mode);\n\n\taspeed_spi_read_from_ahb(buf, chip->ahb_base, len);\n\taspeed_spi_stop_user(chip);\n\treturn 0;\n}\n\nstatic ssize_t aspeed_spi_write_user(struct aspeed_spi_chip *chip,\n\t\t\t\t     const struct spi_mem_op *op)\n{\n\tint ret;\n\n\taspeed_spi_start_user(chip);\n\tret = aspeed_spi_send_cmd_addr(chip, op->addr.nbytes, op->addr.val, op->cmd.opcode);\n\tif (ret < 0)\n\t\treturn ret;\n\taspeed_spi_write_to_ahb(chip->ahb_base, op->data.buf.out, op->data.nbytes);\n\taspeed_spi_stop_user(chip);\n\treturn 0;\n}\n\n \nstatic bool aspeed_spi_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tif (op->cmd.buswidth > 1)\n\t\treturn false;\n\n\tif (op->addr.nbytes != 0) {\n\t\tif (op->addr.buswidth > 1)\n\t\t\treturn false;\n\t\tif (op->addr.nbytes < 3 || op->addr.nbytes > 4)\n\t\t\treturn false;\n\t}\n\n\tif (op->dummy.nbytes != 0) {\n\t\tif (op->dummy.buswidth > 1 || op->dummy.nbytes > 7)\n\t\t\treturn false;\n\t}\n\n\tif (op->data.nbytes != 0 && op->data.buswidth > 4)\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic const struct aspeed_spi_data ast2400_spi_data;\n\nstatic int do_aspeed_spi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(mem->spi->controller);\n\tstruct aspeed_spi_chip *chip = &aspi->chips[spi_get_chipselect(mem->spi, 0)];\n\tu32 addr_mode, addr_mode_backup;\n\tu32 ctl_val;\n\tint ret = 0;\n\n\tdev_dbg(aspi->dev,\n\t\t\"CE%d %s OP %#x mode:%d.%d.%d.%d naddr:%#x ndummies:%#x len:%#x\",\n\t\tchip->cs, op->data.dir == SPI_MEM_DATA_IN ? \"read\" : \"write\",\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth,\n\t\top->addr.nbytes, op->dummy.nbytes, op->data.nbytes);\n\n\taddr_mode = readl(aspi->regs + CE_CTRL_REG);\n\taddr_mode_backup = addr_mode;\n\n\tctl_val = chip->ctl_val[ASPEED_SPI_BASE];\n\tctl_val &= ~CTRL_IO_CMD_MASK;\n\n\tctl_val |= op->cmd.opcode << CTRL_COMMAND_SHIFT;\n\n\t \n\tif (op->addr.nbytes) {\n\t\tif (op->addr.nbytes == 4)\n\t\t\taddr_mode |= (0x11 << chip->cs);\n\t\telse\n\t\t\taddr_mode &= ~(0x11 << chip->cs);\n\n\t\tif (op->addr.nbytes == 4 && chip->aspi->data == &ast2400_spi_data)\n\t\t\tctl_val |= CTRL_IO_ADDRESS_4B;\n\t}\n\n\tif (op->dummy.nbytes)\n\t\tctl_val |= CTRL_IO_DUMMY_SET(op->dummy.nbytes / op->dummy.buswidth);\n\n\tif (op->data.nbytes)\n\t\tctl_val |= aspeed_spi_get_io_mode(op);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\tctl_val |= CTRL_IO_MODE_WRITE;\n\telse\n\t\tctl_val |= CTRL_IO_MODE_READ;\n\n\tif (addr_mode != addr_mode_backup)\n\t\twritel(addr_mode, aspi->regs + CE_CTRL_REG);\n\twritel(ctl_val, chip->ctl);\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (!op->addr.nbytes)\n\t\t\tret = aspeed_spi_read_reg(chip, op);\n\t\telse\n\t\t\tret = aspeed_spi_read_user(chip, op, op->addr.val,\n\t\t\t\t\t\t   op->data.nbytes, op->data.buf.in);\n\t} else {\n\t\tif (!op->addr.nbytes)\n\t\t\tret = aspeed_spi_write_reg(chip, op);\n\t\telse\n\t\t\tret = aspeed_spi_write_user(chip, op);\n\t}\n\n\t \n\tif (addr_mode != addr_mode_backup)\n\t\twritel(addr_mode_backup, aspi->regs + CE_CTRL_REG);\n\twritel(chip->ctl_val[ASPEED_SPI_READ], chip->ctl);\n\treturn ret;\n}\n\nstatic int aspeed_spi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tint ret;\n\n\tret = do_aspeed_spi_exec_op(mem, op);\n\tif (ret)\n\t\tdev_err(&mem->spi->dev, \"operation failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const char *aspeed_spi_get_name(struct spi_mem *mem)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(mem->spi->controller);\n\tstruct device *dev = aspi->dev;\n\n\treturn devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\", dev_name(dev),\n\t\t\t      spi_get_chipselect(mem->spi, 0));\n}\n\nstruct aspeed_spi_window {\n\tu32 cs;\n\tu32 offset;\n\tu32 size;\n};\n\nstatic void aspeed_spi_get_windows(struct aspeed_spi *aspi,\n\t\t\t\t   struct aspeed_spi_window windows[ASPEED_SPI_MAX_NUM_CS])\n{\n\tconst struct aspeed_spi_data *data = aspi->data;\n\tu32 reg_val;\n\tu32 cs;\n\n\tfor (cs = 0; cs < aspi->data->max_cs; cs++) {\n\t\treg_val = readl(aspi->regs + CE0_SEGMENT_ADDR_REG + cs * 4);\n\t\twindows[cs].cs = cs;\n\t\twindows[cs].size = data->segment_end(aspi, reg_val) -\n\t\t\tdata->segment_start(aspi, reg_val);\n\t\twindows[cs].offset = data->segment_start(aspi, reg_val) - aspi->ahb_base_phy;\n\t\tdev_vdbg(aspi->dev, \"CE%d offset=0x%.8x size=0x%x\\n\", cs,\n\t\t\t windows[cs].offset, windows[cs].size);\n\t}\n}\n\n \nstatic int aspeed_spi_chip_set_default_window(struct aspeed_spi_chip *chip)\n{\n\tstruct aspeed_spi *aspi = chip->aspi;\n\tstruct aspeed_spi_window windows[ASPEED_SPI_MAX_NUM_CS] = { 0 };\n\tstruct aspeed_spi_window *win = &windows[chip->cs];\n\n\t \n\tif (aspi->data == &ast2400_spi_data) {\n\t\twin->offset = 0;\n\t\twin->size = aspi->ahb_window_size;\n\t} else {\n\t\taspeed_spi_get_windows(aspi, windows);\n\t}\n\n\tchip->ahb_base = aspi->ahb_base + win->offset;\n\tchip->ahb_window_size = win->size;\n\n\tdev_dbg(aspi->dev, \"CE%d default window [ 0x%.8x - 0x%.8x ] %dMB\",\n\t\tchip->cs, aspi->ahb_base_phy + win->offset,\n\t\taspi->ahb_base_phy + win->offset + win->size - 1,\n\t\twin->size >> 20);\n\n\treturn chip->ahb_window_size ? 0 : -1;\n}\n\nstatic int aspeed_spi_set_window(struct aspeed_spi *aspi,\n\t\t\t\t const struct aspeed_spi_window *win)\n{\n\tu32 start = aspi->ahb_base_phy + win->offset;\n\tu32 end = start + win->size;\n\tvoid __iomem *seg_reg = aspi->regs + CE0_SEGMENT_ADDR_REG + win->cs * 4;\n\tu32 seg_val_backup = readl(seg_reg);\n\tu32 seg_val = aspi->data->segment_reg(aspi, start, end);\n\n\tif (seg_val == seg_val_backup)\n\t\treturn 0;\n\n\twritel(seg_val, seg_reg);\n\n\t \n\tif (seg_val != readl(seg_reg)) {\n\t\tdev_err(aspi->dev, \"CE%d invalid window [ 0x%.8x - 0x%.8x ] %dMB\",\n\t\t\twin->cs, start, end - 1, win->size >> 20);\n\t\twritel(seg_val_backup, seg_reg);\n\t\treturn -EIO;\n\t}\n\n\tif (win->size)\n\t\tdev_dbg(aspi->dev, \"CE%d new window [ 0x%.8x - 0x%.8x ] %dMB\",\n\t\t\twin->cs, start, end - 1,  win->size >> 20);\n\telse\n\t\tdev_dbg(aspi->dev, \"CE%d window closed\", win->cs);\n\n\treturn 0;\n}\n\n \nstatic const struct aspeed_spi_data ast2500_spi_data;\nstatic const struct aspeed_spi_data ast2600_spi_data;\nstatic const struct aspeed_spi_data ast2600_fmc_data;\n\nstatic int aspeed_spi_chip_adjust_window(struct aspeed_spi_chip *chip,\n\t\t\t\t\t u32 local_offset, u32 size)\n{\n\tstruct aspeed_spi *aspi = chip->aspi;\n\tstruct aspeed_spi_window windows[ASPEED_SPI_MAX_NUM_CS] = { 0 };\n\tstruct aspeed_spi_window *win = &windows[chip->cs];\n\tint ret;\n\n\t \n\tif (aspi->data == &ast2400_spi_data)\n\t\treturn 0;\n\n\t \n\tif (aspi->data == &ast2500_spi_data && chip->cs == 0 && size == SZ_128M) {\n\t\tsize = 120 << 20;\n\t\tdev_info(aspi->dev, \"CE%d window resized to %dMB (AST2500 HW quirk)\",\n\t\t\t chip->cs, size >> 20);\n\t}\n\n\t \n\tif ((aspi->data == &ast2600_spi_data || aspi->data == &ast2600_fmc_data) &&\n\t    size < SZ_2M) {\n\t\tsize = SZ_2M;\n\t\tdev_info(aspi->dev, \"CE%d window resized to %dMB (AST2600 Decoding)\",\n\t\t\t chip->cs, size >> 20);\n\t}\n\n\taspeed_spi_get_windows(aspi, windows);\n\n\t \n\twin->offset += local_offset;\n\twin->size = size;\n\n\tif (win->offset + win->size > aspi->ahb_window_size) {\n\t\twin->size = aspi->ahb_window_size - win->offset;\n\t\tdev_warn(aspi->dev, \"CE%d window resized to %dMB\", chip->cs, win->size >> 20);\n\t}\n\n\tret = aspeed_spi_set_window(aspi, win);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchip->ahb_base = aspi->ahb_base + win->offset;\n\tchip->ahb_window_size = win->size;\n\n\t \n\tif (chip->cs < aspi->data->max_cs - 1) {\n\t\tstruct aspeed_spi_window *next = &windows[chip->cs + 1];\n\n\t\t \n\t\tif ((next->offset + next->size) > (win->offset + win->size))\n\t\t\tnext->size = (next->offset + next->size) - (win->offset + win->size);\n\t\telse\n\t\t\tnext->size = 0;\n\t\tnext->offset = win->offset + win->size;\n\n\t\taspeed_spi_set_window(aspi, next);\n\t}\n\treturn 0;\n}\n\nstatic int aspeed_spi_do_calibration(struct aspeed_spi_chip *chip);\n\nstatic int aspeed_spi_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(desc->mem->spi->controller);\n\tstruct aspeed_spi_chip *chip = &aspi->chips[spi_get_chipselect(desc->mem->spi, 0)];\n\tstruct spi_mem_op *op = &desc->info.op_tmpl;\n\tu32 ctl_val;\n\tint ret = 0;\n\n\tdev_dbg(aspi->dev,\n\t\t\"CE%d %s dirmap [ 0x%.8llx - 0x%.8llx ] OP %#x mode:%d.%d.%d.%d naddr:%#x ndummies:%#x\\n\",\n\t\tchip->cs, op->data.dir == SPI_MEM_DATA_IN ? \"read\" : \"write\",\n\t\tdesc->info.offset, desc->info.offset + desc->info.length,\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth,\n\t\top->addr.nbytes, op->dummy.nbytes);\n\n\tchip->clk_freq = desc->mem->spi->max_speed_hz;\n\n\t \n\tif (op->data.dir != SPI_MEM_DATA_IN)\n\t\treturn -EOPNOTSUPP;\n\n\taspeed_spi_chip_adjust_window(chip, desc->info.offset, desc->info.length);\n\n\tif (desc->info.length > chip->ahb_window_size)\n\t\tdev_warn(aspi->dev, \"CE%d window (%dMB) too small for mapping\",\n\t\t\t chip->cs, chip->ahb_window_size >> 20);\n\n\t \n\tctl_val = readl(chip->ctl) & ~CTRL_IO_CMD_MASK;\n\tctl_val |= aspeed_spi_get_io_mode(op) |\n\t\top->cmd.opcode << CTRL_COMMAND_SHIFT |\n\t\tCTRL_IO_MODE_READ;\n\n\tif (op->dummy.nbytes)\n\t\tctl_val |= CTRL_IO_DUMMY_SET(op->dummy.nbytes / op->dummy.buswidth);\n\n\t \n\tif (op->addr.nbytes) {\n\t\tu32 addr_mode = readl(aspi->regs + CE_CTRL_REG);\n\n\t\tif (op->addr.nbytes == 4)\n\t\t\taddr_mode |= (0x11 << chip->cs);\n\t\telse\n\t\t\taddr_mode &= ~(0x11 << chip->cs);\n\t\twritel(addr_mode, aspi->regs + CE_CTRL_REG);\n\n\t\t \n\t\tif (op->addr.nbytes == 4 && chip->aspi->data == &ast2400_spi_data)\n\t\t\tctl_val |= CTRL_IO_ADDRESS_4B;\n\t}\n\n\t \n\tchip->ctl_val[ASPEED_SPI_READ] = ctl_val;\n\twritel(chip->ctl_val[ASPEED_SPI_READ], chip->ctl);\n\n\tret = aspeed_spi_do_calibration(chip);\n\n\tdev_info(aspi->dev, \"CE%d read buswidth:%d [0x%08x]\\n\",\n\t\t chip->cs, op->data.buswidth, chip->ctl_val[ASPEED_SPI_READ]);\n\n\treturn ret;\n}\n\nstatic ssize_t aspeed_spi_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t      u64 offset, size_t len, void *buf)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(desc->mem->spi->controller);\n\tstruct aspeed_spi_chip *chip = &aspi->chips[spi_get_chipselect(desc->mem->spi, 0)];\n\n\t \n\tif (chip->ahb_window_size < offset + len) {\n\t\tint ret;\n\n\t\tret = aspeed_spi_read_user(chip, &desc->info.op_tmpl, offset, len, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tmemcpy_fromio(buf, chip->ahb_base + offset, len);\n\t}\n\n\treturn len;\n}\n\nstatic const struct spi_controller_mem_ops aspeed_spi_mem_ops = {\n\t.supports_op = aspeed_spi_supports_op,\n\t.exec_op = aspeed_spi_exec_op,\n\t.get_name = aspeed_spi_get_name,\n\t.dirmap_create = aspeed_spi_dirmap_create,\n\t.dirmap_read = aspeed_spi_dirmap_read,\n};\n\nstatic void aspeed_spi_chip_set_type(struct aspeed_spi *aspi, unsigned int cs, int type)\n{\n\tu32 reg;\n\n\treg = readl(aspi->regs + CONFIG_REG);\n\treg &= ~(0x3 << (cs * 2));\n\treg |= type << (cs * 2);\n\twritel(reg, aspi->regs + CONFIG_REG);\n}\n\nstatic void aspeed_spi_chip_enable(struct aspeed_spi *aspi, unsigned int cs, bool enable)\n{\n\tu32 we_bit = BIT(aspi->data->we0 + cs);\n\tu32 reg = readl(aspi->regs + CONFIG_REG);\n\n\tif (enable)\n\t\treg |= we_bit;\n\telse\n\t\treg &= ~we_bit;\n\twritel(reg, aspi->regs + CONFIG_REG);\n}\n\nstatic int aspeed_spi_setup(struct spi_device *spi)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(spi->controller);\n\tconst struct aspeed_spi_data *data = aspi->data;\n\tunsigned int cs = spi_get_chipselect(spi, 0);\n\tstruct aspeed_spi_chip *chip = &aspi->chips[cs];\n\n\tchip->aspi = aspi;\n\tchip->cs = cs;\n\tchip->ctl = aspi->regs + data->ctl0 + cs * 4;\n\n\t \n\tif (data->hastype)\n\t\taspeed_spi_chip_set_type(aspi, cs, CONFIG_TYPE_SPI);\n\n\tif (aspeed_spi_chip_set_default_window(chip) < 0) {\n\t\tdev_warn(aspi->dev, \"CE%d window invalid\", cs);\n\t\treturn -EINVAL;\n\t}\n\n\taspeed_spi_chip_enable(aspi, cs, true);\n\n\tchip->ctl_val[ASPEED_SPI_BASE] = CTRL_CE_STOP_ACTIVE | CTRL_IO_MODE_USER;\n\n\tdev_dbg(aspi->dev, \"CE%d setup done\\n\", cs);\n\treturn 0;\n}\n\nstatic void aspeed_spi_cleanup(struct spi_device *spi)\n{\n\tstruct aspeed_spi *aspi = spi_controller_get_devdata(spi->controller);\n\tunsigned int cs = spi_get_chipselect(spi, 0);\n\n\taspeed_spi_chip_enable(aspi, cs, false);\n\n\tdev_dbg(aspi->dev, \"CE%d cleanup done\\n\", cs);\n}\n\nstatic void aspeed_spi_enable(struct aspeed_spi *aspi, bool enable)\n{\n\tint cs;\n\n\tfor (cs = 0; cs < aspi->data->max_cs; cs++)\n\t\taspeed_spi_chip_enable(aspi, cs, enable);\n}\n\nstatic int aspeed_spi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct aspeed_spi_data *data;\n\tstruct spi_controller *ctlr;\n\tstruct aspeed_spi *aspi;\n\tstruct resource *res;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tctlr = devm_spi_alloc_host(dev, sizeof(*aspi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\taspi = spi_controller_get_devdata(ctlr);\n\tplatform_set_drvdata(pdev, aspi);\n\taspi->data = data;\n\taspi->dev = dev;\n\n\taspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(aspi->regs))\n\t\treturn PTR_ERR(aspi->regs);\n\n\taspi->ahb_base = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\tif (IS_ERR(aspi->ahb_base)) {\n\t\tdev_err(dev, \"missing AHB mapping window\\n\");\n\t\treturn PTR_ERR(aspi->ahb_base);\n\t}\n\n\taspi->ahb_window_size = resource_size(res);\n\taspi->ahb_base_phy = res->start;\n\n\taspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(aspi->clk)) {\n\t\tdev_err(dev, \"missing clock\\n\");\n\t\treturn PTR_ERR(aspi->clk);\n\t}\n\n\taspi->clk_freq = clk_get_rate(aspi->clk);\n\tif (!aspi->clk_freq) {\n\t\tdev_err(dev, \"invalid clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_prepare_enable(aspi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tctlr->mode_bits = SPI_RX_DUAL | SPI_TX_DUAL | data->mode_bits;\n\tctlr->bus_num = pdev->id;\n\tctlr->mem_ops = &aspeed_spi_mem_ops;\n\tctlr->setup = aspeed_spi_setup;\n\tctlr->cleanup = aspeed_spi_cleanup;\n\tctlr->num_chipselect = data->max_cs;\n\tctlr->dev.of_node = dev->of_node;\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller failed\\n\");\n\t\tgoto disable_clk;\n\t}\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(aspi->clk);\n\treturn ret;\n}\n\nstatic void aspeed_spi_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_spi *aspi = platform_get_drvdata(pdev);\n\n\taspeed_spi_enable(aspi, false);\n\tclk_disable_unprepare(aspi->clk);\n}\n\n \n\n \nstatic u32 aspeed_spi_segment_start(struct aspeed_spi *aspi, u32 reg)\n{\n\treturn ((reg >> 16) & 0xFF) << 23;\n}\n\nstatic u32 aspeed_spi_segment_end(struct aspeed_spi *aspi, u32 reg)\n{\n\treturn ((reg >> 24) & 0xFF) << 23;\n}\n\nstatic u32 aspeed_spi_segment_reg(struct aspeed_spi *aspi, u32 start, u32 end)\n{\n\treturn (((start >> 23) & 0xFF) << 16) | (((end >> 23) & 0xFF) << 24);\n}\n\n \n\n#define AST2600_SEG_ADDR_MASK 0x0ff00000\n\nstatic u32 aspeed_spi_segment_ast2600_start(struct aspeed_spi *aspi,\n\t\t\t\t\t    u32 reg)\n{\n\tu32 start_offset = (reg << 16) & AST2600_SEG_ADDR_MASK;\n\n\treturn aspi->ahb_base_phy + start_offset;\n}\n\nstatic u32 aspeed_spi_segment_ast2600_end(struct aspeed_spi *aspi,\n\t\t\t\t\t  u32 reg)\n{\n\tu32 end_offset = reg & AST2600_SEG_ADDR_MASK;\n\n\t \n\tif (!end_offset)\n\t\treturn aspi->ahb_base_phy;\n\n\treturn aspi->ahb_base_phy + end_offset + 0x100000;\n}\n\nstatic u32 aspeed_spi_segment_ast2600_reg(struct aspeed_spi *aspi,\n\t\t\t\t\t  u32 start, u32 end)\n{\n\t \n\tif (start == end)\n\t\treturn 0;\n\n\treturn ((start & AST2600_SEG_ADDR_MASK) >> 16) |\n\t\t((end - 1) & AST2600_SEG_ADDR_MASK);\n}\n\n \n\n#define CALIBRATE_BUF_SIZE SZ_16K\n\nstatic bool aspeed_spi_check_reads(struct aspeed_spi_chip *chip,\n\t\t\t\t   const u8 *golden_buf, u8 *test_buf)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmemcpy_fromio(test_buf, chip->ahb_base, CALIBRATE_BUF_SIZE);\n\t\tif (memcmp(test_buf, golden_buf, CALIBRATE_BUF_SIZE) != 0) {\n#if defined(VERBOSE_DEBUG)\n\t\t\tprint_hex_dump_bytes(DEVICE_NAME \"  fail: \", DUMP_PREFIX_NONE,\n\t\t\t\t\t     test_buf, 0x100);\n#endif\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n#define FREAD_TPASS(i)\t(((i) / 2) | (((i) & 1) ? 0 : 8))\n\n \nstatic int aspeed_spi_calibrate(struct aspeed_spi_chip *chip, u32 hdiv,\n\t\t\t\tconst u8 *golden_buf, u8 *test_buf)\n{\n\tstruct aspeed_spi *aspi = chip->aspi;\n\tconst struct aspeed_spi_data *data = aspi->data;\n\tint i;\n\tint good_pass = -1, pass_count = 0;\n\tu32 shift = (hdiv - 1) << 2;\n\tu32 mask = ~(0xfu << shift);\n\tu32 fread_timing_val = 0;\n\n\t \n\tfor (i = 0; i < 12; i++) {\n\t\tbool pass;\n\n\t\tif (chip->cs == 0) {\n\t\t\tfread_timing_val &= mask;\n\t\t\tfread_timing_val |= FREAD_TPASS(i) << shift;\n\t\t\twritel(fread_timing_val, aspi->regs + data->timing);\n\t\t}\n\t\tpass = aspeed_spi_check_reads(chip, golden_buf, test_buf);\n\t\tdev_dbg(aspi->dev,\n\t\t\t\"  * [%08x] %d HCLK delay, %dns DI delay : %s\",\n\t\t\tfread_timing_val, i / 2, (i & 1) ? 0 : 4,\n\t\t\tpass ? \"PASS\" : \"FAIL\");\n\t\tif (pass) {\n\t\t\tpass_count++;\n\t\t\tif (pass_count == 3) {\n\t\t\t\tgood_pass = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpass_count = 0;\n\t\t}\n\t}\n\n\t \n\tif (good_pass < 0)\n\t\treturn -1;\n\n\t \n\tif (chip->cs == 0) {\n\t\tfread_timing_val &= mask;\n\t\tfread_timing_val |= FREAD_TPASS(good_pass) << shift;\n\t\twritel(fread_timing_val, aspi->regs + data->timing);\n\t}\n\tdev_dbg(aspi->dev, \" * -> good is pass %d [0x%08x]\",\n\t\tgood_pass, fread_timing_val);\n\treturn 0;\n}\n\nstatic bool aspeed_spi_check_calib_data(const u8 *test_buf, u32 size)\n{\n\tconst u32 *tb32 = (const u32 *)test_buf;\n\tu32 i, cnt = 0;\n\n\t \n\tsize >>= 2;\n\tfor (i = 0; i < size; i++) {\n\t\tif (tb32[i] != 0 && tb32[i] != 0xffffffff)\n\t\t\tcnt++;\n\t}\n\treturn cnt >= 64;\n}\n\nstatic const u32 aspeed_spi_hclk_divs[] = {\n\t0xf,  \n\t0x7,  \n\t0xe,  \n\t0x6,  \n\t0xd,  \n};\n\n#define ASPEED_SPI_HCLK_DIV(i) \\\n\t(aspeed_spi_hclk_divs[(i) - 1] << CTRL_FREQ_SEL_SHIFT)\n\nstatic int aspeed_spi_do_calibration(struct aspeed_spi_chip *chip)\n{\n\tstruct aspeed_spi *aspi = chip->aspi;\n\tconst struct aspeed_spi_data *data = aspi->data;\n\tu32 ahb_freq = aspi->clk_freq;\n\tu32 max_freq = chip->clk_freq;\n\tu32 ctl_val;\n\tu8 *golden_buf = NULL;\n\tu8 *test_buf = NULL;\n\tint i, rc, best_div = -1;\n\n\tdev_dbg(aspi->dev, \"calculate timing compensation - AHB freq: %d MHz\",\n\t\tahb_freq / 1000000);\n\n\t \n\tctl_val = chip->ctl_val[ASPEED_SPI_READ] & data->hclk_mask;\n\twritel(ctl_val, chip->ctl);\n\n\ttest_buf = kzalloc(CALIBRATE_BUF_SIZE * 2, GFP_KERNEL);\n\tif (!test_buf)\n\t\treturn -ENOMEM;\n\n\tgolden_buf = test_buf + CALIBRATE_BUF_SIZE;\n\n\tmemcpy_fromio(golden_buf, chip->ahb_base, CALIBRATE_BUF_SIZE);\n\tif (!aspeed_spi_check_calib_data(golden_buf, CALIBRATE_BUF_SIZE)) {\n\t\tdev_info(aspi->dev, \"Calibration area too uniform, using low speed\");\n\t\tgoto no_calib;\n\t}\n\n#if defined(VERBOSE_DEBUG)\n\tprint_hex_dump_bytes(DEVICE_NAME \"  good: \", DUMP_PREFIX_NONE,\n\t\t\t     golden_buf, 0x100);\n#endif\n\n\t \n\tfor (i = ARRAY_SIZE(aspeed_spi_hclk_divs); i > data->hdiv_max - 1; i--) {\n\t\tu32 tv, freq;\n\n\t\tfreq = ahb_freq / i;\n\t\tif (freq > max_freq)\n\t\t\tcontinue;\n\n\t\t \n\t\ttv = chip->ctl_val[ASPEED_SPI_READ] | ASPEED_SPI_HCLK_DIV(i);\n\t\twritel(tv, chip->ctl);\n\t\tdev_dbg(aspi->dev, \"Trying HCLK/%d [%08x] ...\", i, tv);\n\t\trc = data->calibrate(chip, i, golden_buf, test_buf);\n\t\tif (rc == 0)\n\t\t\tbest_div = i;\n\t}\n\n\t \n\tif (best_div < 0) {\n\t\tdev_warn(aspi->dev, \"No good frequency, using dumb slow\");\n\t} else {\n\t\tdev_dbg(aspi->dev, \"Found good read timings at HCLK/%d\", best_div);\n\n\t\t \n\t\tfor (i = 0; i < ASPEED_SPI_MAX; i++)\n\t\t\tchip->ctl_val[i] = (chip->ctl_val[i] & data->hclk_mask) |\n\t\t\t\tASPEED_SPI_HCLK_DIV(best_div);\n\t}\n\nno_calib:\n\twritel(chip->ctl_val[ASPEED_SPI_READ], chip->ctl);\n\tkfree(test_buf);\n\treturn 0;\n}\n\n#define TIMING_DELAY_DI\t\tBIT(3)\n#define TIMING_DELAY_HCYCLE_MAX\t5\n#define TIMING_REG_AST2600(chip)\t\t\t\t\\\n\t((chip)->aspi->regs + (chip)->aspi->data->timing +\t\\\n\t (chip)->cs * 4)\n\nstatic int aspeed_spi_ast2600_calibrate(struct aspeed_spi_chip *chip, u32 hdiv,\n\t\t\t\t\tconst u8 *golden_buf, u8 *test_buf)\n{\n\tstruct aspeed_spi *aspi = chip->aspi;\n\tint hcycle;\n\tu32 shift = (hdiv - 2) << 3;\n\tu32 mask = ~(0xfu << shift);\n\tu32 fread_timing_val = 0;\n\n\tfor (hcycle = 0; hcycle <= TIMING_DELAY_HCYCLE_MAX; hcycle++) {\n\t\tint delay_ns;\n\t\tbool pass = false;\n\n\t\tfread_timing_val &= mask;\n\t\tfread_timing_val |= hcycle << shift;\n\n\t\t \n\t\twritel(fread_timing_val, TIMING_REG_AST2600(chip));\n\t\tpass = aspeed_spi_check_reads(chip, golden_buf, test_buf);\n\t\tdev_dbg(aspi->dev,\n\t\t\t\"  * [%08x] %d HCLK delay, DI delay none : %s\",\n\t\t\tfread_timing_val, hcycle, pass ? \"PASS\" : \"FAIL\");\n\t\tif (pass)\n\t\t\treturn 0;\n\n\t\t \n\t\tfread_timing_val &= mask;\n\t\tfread_timing_val |= (TIMING_DELAY_DI | hcycle) << shift;\n\n\t\tfor (delay_ns = 0; delay_ns < 0x10; delay_ns++) {\n\t\t\tfread_timing_val &= ~(0xf << (4 + shift));\n\t\t\tfread_timing_val |= delay_ns << (4 + shift);\n\n\t\t\twritel(fread_timing_val, TIMING_REG_AST2600(chip));\n\t\t\tpass = aspeed_spi_check_reads(chip, golden_buf, test_buf);\n\t\t\tdev_dbg(aspi->dev,\n\t\t\t\t\"  * [%08x] %d HCLK delay, DI delay %d.%dns : %s\",\n\t\t\t\tfread_timing_val, hcycle, (delay_ns + 1) / 2,\n\t\t\t\t(delay_ns + 1) & 1 ? 5 : 5, pass ? \"PASS\" : \"FAIL\");\n\t\t\t \n\t\t\tif (pass)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn -1;\n}\n\n \nstatic const struct aspeed_spi_data ast2400_fmc_data = {\n\t.max_cs\t       = 5,\n\t.hastype       = true,\n\t.we0\t       = 16,\n\t.ctl0\t       = CE0_CTRL_REG,\n\t.timing\t       = CE0_TIMING_COMPENSATION_REG,\n\t.hclk_mask     = 0xfffff0ff,\n\t.hdiv_max      = 1,\n\t.calibrate     = aspeed_spi_calibrate,\n\t.segment_start = aspeed_spi_segment_start,\n\t.segment_end   = aspeed_spi_segment_end,\n\t.segment_reg   = aspeed_spi_segment_reg,\n};\n\nstatic const struct aspeed_spi_data ast2400_spi_data = {\n\t.max_cs\t       = 1,\n\t.hastype       = false,\n\t.we0\t       = 0,\n\t.ctl0\t       = 0x04,\n\t.timing\t       = 0x14,\n\t.hclk_mask     = 0xfffff0ff,\n\t.hdiv_max      = 1,\n\t.calibrate     = aspeed_spi_calibrate,\n\t \n};\n\nstatic const struct aspeed_spi_data ast2500_fmc_data = {\n\t.max_cs\t       = 3,\n\t.hastype       = true,\n\t.we0\t       = 16,\n\t.ctl0\t       = CE0_CTRL_REG,\n\t.timing\t       = CE0_TIMING_COMPENSATION_REG,\n\t.hclk_mask     = 0xffffd0ff,\n\t.hdiv_max      = 1,\n\t.calibrate     = aspeed_spi_calibrate,\n\t.segment_start = aspeed_spi_segment_start,\n\t.segment_end   = aspeed_spi_segment_end,\n\t.segment_reg   = aspeed_spi_segment_reg,\n};\n\nstatic const struct aspeed_spi_data ast2500_spi_data = {\n\t.max_cs\t       = 2,\n\t.hastype       = false,\n\t.we0\t       = 16,\n\t.ctl0\t       = CE0_CTRL_REG,\n\t.timing\t       = CE0_TIMING_COMPENSATION_REG,\n\t.hclk_mask     = 0xffffd0ff,\n\t.hdiv_max      = 1,\n\t.calibrate     = aspeed_spi_calibrate,\n\t.segment_start = aspeed_spi_segment_start,\n\t.segment_end   = aspeed_spi_segment_end,\n\t.segment_reg   = aspeed_spi_segment_reg,\n};\n\nstatic const struct aspeed_spi_data ast2600_fmc_data = {\n\t.max_cs\t       = 3,\n\t.hastype       = false,\n\t.mode_bits     = SPI_RX_QUAD | SPI_TX_QUAD,\n\t.we0\t       = 16,\n\t.ctl0\t       = CE0_CTRL_REG,\n\t.timing\t       = CE0_TIMING_COMPENSATION_REG,\n\t.hclk_mask     = 0xf0fff0ff,\n\t.hdiv_max      = 2,\n\t.calibrate     = aspeed_spi_ast2600_calibrate,\n\t.segment_start = aspeed_spi_segment_ast2600_start,\n\t.segment_end   = aspeed_spi_segment_ast2600_end,\n\t.segment_reg   = aspeed_spi_segment_ast2600_reg,\n};\n\nstatic const struct aspeed_spi_data ast2600_spi_data = {\n\t.max_cs\t       = 2,\n\t.hastype       = false,\n\t.mode_bits     = SPI_RX_QUAD | SPI_TX_QUAD,\n\t.we0\t       = 16,\n\t.ctl0\t       = CE0_CTRL_REG,\n\t.timing\t       = CE0_TIMING_COMPENSATION_REG,\n\t.hclk_mask     = 0xf0fff0ff,\n\t.hdiv_max      = 2,\n\t.calibrate     = aspeed_spi_ast2600_calibrate,\n\t.segment_start = aspeed_spi_segment_ast2600_start,\n\t.segment_end   = aspeed_spi_segment_ast2600_end,\n\t.segment_reg   = aspeed_spi_segment_ast2600_reg,\n};\n\nstatic const struct of_device_id aspeed_spi_matches[] = {\n\t{ .compatible = \"aspeed,ast2400-fmc\", .data = &ast2400_fmc_data },\n\t{ .compatible = \"aspeed,ast2400-spi\", .data = &ast2400_spi_data },\n\t{ .compatible = \"aspeed,ast2500-fmc\", .data = &ast2500_fmc_data },\n\t{ .compatible = \"aspeed,ast2500-spi\", .data = &ast2500_spi_data },\n\t{ .compatible = \"aspeed,ast2600-fmc\", .data = &ast2600_fmc_data },\n\t{ .compatible = \"aspeed,ast2600-spi\", .data = &ast2600_spi_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, aspeed_spi_matches);\n\nstatic struct platform_driver aspeed_spi_driver = {\n\t.probe\t\t\t= aspeed_spi_probe,\n\t.remove_new\t\t= aspeed_spi_remove,\n\t.driver\t= {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table = aspeed_spi_matches,\n\t}\n};\n\nmodule_platform_driver(aspeed_spi_driver);\n\nMODULE_DESCRIPTION(\"ASPEED Static Memory Controller Driver\");\nMODULE_AUTHOR(\"Chin-Ting Kuo <chin-ting_kuo@aspeedtech.com>\");\nMODULE_AUTHOR(\"Cedric Le Goater <clg@kaod.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}