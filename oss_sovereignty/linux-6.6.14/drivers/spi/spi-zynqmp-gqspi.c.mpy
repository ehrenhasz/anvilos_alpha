{
  "module_name": "spi-zynqmp-gqspi.c",
  "hash_id": "fdbac8488681547247a5cef3f49e26c44b0f345a885f4d4dfa665edb720ac51e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-zynqmp-gqspi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define GQSPI_CONFIG_OFST\t\t0x00000100\n#define GQSPI_ISR_OFST\t\t\t0x00000104\n#define GQSPI_IDR_OFST\t\t\t0x0000010C\n#define GQSPI_IER_OFST\t\t\t0x00000108\n#define GQSPI_IMASK_OFST\t\t0x00000110\n#define GQSPI_EN_OFST\t\t\t0x00000114\n#define GQSPI_TXD_OFST\t\t\t0x0000011C\n#define GQSPI_RXD_OFST\t\t\t0x00000120\n#define GQSPI_TX_THRESHOLD_OFST\t\t0x00000128\n#define GQSPI_RX_THRESHOLD_OFST\t\t0x0000012C\n#define IOU_TAPDLY_BYPASS_OFST\t\t0x0000003C\n#define GQSPI_LPBK_DLY_ADJ_OFST\t\t0x00000138\n#define GQSPI_GEN_FIFO_OFST\t\t0x00000140\n#define GQSPI_SEL_OFST\t\t\t0x00000144\n#define GQSPI_GF_THRESHOLD_OFST\t\t0x00000150\n#define GQSPI_FIFO_CTRL_OFST\t\t0x0000014C\n#define GQSPI_QSPIDMA_DST_CTRL_OFST\t0x0000080C\n#define GQSPI_QSPIDMA_DST_SIZE_OFST\t0x00000804\n#define GQSPI_QSPIDMA_DST_STS_OFST\t0x00000808\n#define GQSPI_QSPIDMA_DST_I_STS_OFST\t0x00000814\n#define GQSPI_QSPIDMA_DST_I_EN_OFST\t0x00000818\n#define GQSPI_QSPIDMA_DST_I_DIS_OFST\t0x0000081C\n#define GQSPI_QSPIDMA_DST_I_MASK_OFST\t0x00000820\n#define GQSPI_QSPIDMA_DST_ADDR_OFST\t0x00000800\n#define GQSPI_QSPIDMA_DST_ADDR_MSB_OFST 0x00000828\n#define GQSPI_DATA_DLY_ADJ_OFST         0x000001F8\n\n \n#define GQSPI_SEL_MASK\t\t\t\t0x00000001\n#define GQSPI_EN_MASK\t\t\t\t0x00000001\n#define GQSPI_LPBK_DLY_ADJ_USE_LPBK_MASK\t0x00000020\n#define GQSPI_ISR_WR_TO_CLR_MASK\t\t0x00000002\n#define GQSPI_IDR_ALL_MASK\t\t\t0x00000FBE\n#define GQSPI_CFG_MODE_EN_MASK\t\t\t0xC0000000\n#define GQSPI_CFG_GEN_FIFO_START_MODE_MASK\t0x20000000\n#define GQSPI_CFG_ENDIAN_MASK\t\t\t0x04000000\n#define GQSPI_CFG_EN_POLL_TO_MASK\t\t0x00100000\n#define GQSPI_CFG_WP_HOLD_MASK\t\t\t0x00080000\n#define GQSPI_CFG_BAUD_RATE_DIV_MASK\t\t0x00000038\n#define GQSPI_CFG_CLK_PHA_MASK\t\t\t0x00000004\n#define GQSPI_CFG_CLK_POL_MASK\t\t\t0x00000002\n#define GQSPI_CFG_START_GEN_FIFO_MASK\t\t0x10000000\n#define GQSPI_GENFIFO_IMM_DATA_MASK\t\t0x000000FF\n#define GQSPI_GENFIFO_DATA_XFER\t\t\t0x00000100\n#define GQSPI_GENFIFO_EXP\t\t\t0x00000200\n#define GQSPI_GENFIFO_MODE_SPI\t\t\t0x00000400\n#define GQSPI_GENFIFO_MODE_DUALSPI\t\t0x00000800\n#define GQSPI_GENFIFO_MODE_QUADSPI\t\t0x00000C00\n#define GQSPI_GENFIFO_MODE_MASK\t\t\t0x00000C00\n#define GQSPI_GENFIFO_CS_LOWER\t\t\t0x00001000\n#define GQSPI_GENFIFO_CS_UPPER\t\t\t0x00002000\n#define GQSPI_GENFIFO_BUS_LOWER\t\t\t0x00004000\n#define GQSPI_GENFIFO_BUS_UPPER\t\t\t0x00008000\n#define GQSPI_GENFIFO_BUS_BOTH\t\t\t0x0000C000\n#define GQSPI_GENFIFO_BUS_MASK\t\t\t0x0000C000\n#define GQSPI_GENFIFO_TX\t\t\t0x00010000\n#define GQSPI_GENFIFO_RX\t\t\t0x00020000\n#define GQSPI_GENFIFO_STRIPE\t\t\t0x00040000\n#define GQSPI_GENFIFO_POLL\t\t\t0x00080000\n#define GQSPI_GENFIFO_EXP_START\t\t\t0x00000100\n#define GQSPI_FIFO_CTRL_RST_RX_FIFO_MASK\t0x00000004\n#define GQSPI_FIFO_CTRL_RST_TX_FIFO_MASK\t0x00000002\n#define GQSPI_FIFO_CTRL_RST_GEN_FIFO_MASK\t0x00000001\n#define GQSPI_ISR_RXEMPTY_MASK\t\t\t0x00000800\n#define GQSPI_ISR_GENFIFOFULL_MASK\t\t0x00000400\n#define GQSPI_ISR_GENFIFONOT_FULL_MASK\t\t0x00000200\n#define GQSPI_ISR_TXEMPTY_MASK\t\t\t0x00000100\n#define GQSPI_ISR_GENFIFOEMPTY_MASK\t\t0x00000080\n#define GQSPI_ISR_RXFULL_MASK\t\t\t0x00000020\n#define GQSPI_ISR_RXNEMPTY_MASK\t\t\t0x00000010\n#define GQSPI_ISR_TXFULL_MASK\t\t\t0x00000008\n#define GQSPI_ISR_TXNOT_FULL_MASK\t\t0x00000004\n#define GQSPI_ISR_POLL_TIME_EXPIRE_MASK\t\t0x00000002\n#define GQSPI_IER_TXNOT_FULL_MASK\t\t0x00000004\n#define GQSPI_IER_RXEMPTY_MASK\t\t\t0x00000800\n#define GQSPI_IER_POLL_TIME_EXPIRE_MASK\t\t0x00000002\n#define GQSPI_IER_RXNEMPTY_MASK\t\t\t0x00000010\n#define GQSPI_IER_GENFIFOEMPTY_MASK\t\t0x00000080\n#define GQSPI_IER_TXEMPTY_MASK\t\t\t0x00000100\n#define GQSPI_QSPIDMA_DST_INTR_ALL_MASK\t\t0x000000FE\n#define GQSPI_QSPIDMA_DST_STS_WTC\t\t0x0000E000\n#define GQSPI_CFG_MODE_EN_DMA_MASK\t\t0x80000000\n#define GQSPI_ISR_IDR_MASK\t\t\t0x00000994\n#define GQSPI_QSPIDMA_DST_I_EN_DONE_MASK\t0x00000002\n#define GQSPI_QSPIDMA_DST_I_STS_DONE_MASK\t0x00000002\n#define GQSPI_IRQ_MASK\t\t\t\t0x00000980\n\n#define GQSPI_CFG_BAUD_RATE_DIV_SHIFT\t\t3\n#define GQSPI_GENFIFO_CS_SETUP\t\t\t0x4\n#define GQSPI_GENFIFO_CS_HOLD\t\t\t0x3\n#define GQSPI_TXD_DEPTH\t\t\t\t64\n#define GQSPI_RX_FIFO_THRESHOLD\t\t\t32\n#define GQSPI_RX_FIFO_FILL\t(GQSPI_RX_FIFO_THRESHOLD * 4)\n#define GQSPI_TX_FIFO_THRESHOLD_RESET_VAL\t32\n#define GQSPI_TX_FIFO_FILL\t(GQSPI_TXD_DEPTH -\\\n\t\t\t\tGQSPI_TX_FIFO_THRESHOLD_RESET_VAL)\n#define GQSPI_GEN_FIFO_THRESHOLD_RESET_VAL\t0X10\n#define GQSPI_QSPIDMA_DST_CTRL_RESET_VAL\t0x803FFA00\n#define GQSPI_SELECT_FLASH_CS_LOWER\t\t0x1\n#define GQSPI_SELECT_FLASH_CS_UPPER\t\t0x2\n#define GQSPI_SELECT_FLASH_CS_BOTH\t\t0x3\n#define GQSPI_SELECT_FLASH_BUS_LOWER\t\t0x1\n#define GQSPI_SELECT_FLASH_BUS_UPPER\t\t0x2\n#define GQSPI_SELECT_FLASH_BUS_BOTH\t\t0x3\n#define GQSPI_BAUD_DIV_MAX\t7\t \n#define GQSPI_BAUD_DIV_SHIFT\t2\t \n#define GQSPI_SELECT_MODE_SPI\t\t0x1\n#define GQSPI_SELECT_MODE_DUALSPI\t0x2\n#define GQSPI_SELECT_MODE_QUADSPI\t0x4\n#define GQSPI_DMA_UNALIGN\t\t0x3\n#define GQSPI_DEFAULT_NUM_CS\t1\t \n\n#define GQSPI_MAX_NUM_CS\t2\t \n\n#define GQSPI_USE_DATA_DLY\t\t0x1\n#define GQSPI_USE_DATA_DLY_SHIFT\t31\n#define GQSPI_DATA_DLY_ADJ_VALUE\t0x2\n#define GQSPI_DATA_DLY_ADJ_SHIFT\t28\n#define GQSPI_LPBK_DLY_ADJ_DLY_1\t0x1\n#define GQSPI_LPBK_DLY_ADJ_DLY_1_SHIFT\t0x3\n#define TAP_DLY_BYPASS_LQSPI_RX_VALUE\t0x1\n#define TAP_DLY_BYPASS_LQSPI_RX_SHIFT\t0x2\n\n \n#define QSPI_QUIRK_HAS_TAPDELAY\t\tBIT(0)\n\n#define GQSPI_FREQ_37_5MHZ\t37500000\n#define GQSPI_FREQ_40MHZ\t40000000\n#define GQSPI_FREQ_100MHZ\t100000000\n#define GQSPI_FREQ_150MHZ\t150000000\n\n#define SPI_AUTOSUSPEND_TIMEOUT\t\t3000\nenum mode_type {GQSPI_MODE_IO, GQSPI_MODE_DMA};\n\n \nstruct qspi_platform_data {\n\tu32 quirks;\n};\n\n \nstruct zynqmp_qspi {\n\tstruct spi_controller *ctlr;\n\tvoid __iomem *regs;\n\tstruct clk *refclk;\n\tstruct clk *pclk;\n\tint irq;\n\tstruct device *dev;\n\tconst void *txbuf;\n\tvoid *rxbuf;\n\tint bytes_to_transfer;\n\tint bytes_to_receive;\n\tu32 genfifocs;\n\tu32 genfifobus;\n\tu32 dma_rx_bytes;\n\tdma_addr_t dma_addr;\n\tu32 genfifoentry;\n\tenum mode_type mode;\n\tstruct completion data_completion;\n\tstruct mutex op_lock;\n\tu32 speed_hz;\n\tbool has_tapdelay;\n};\n\n \nstatic u32 zynqmp_gqspi_read(struct zynqmp_qspi *xqspi, u32 offset)\n{\n\treturn readl_relaxed(xqspi->regs + offset);\n}\n\n \nstatic inline void zynqmp_gqspi_write(struct zynqmp_qspi *xqspi, u32 offset,\n\t\t\t\t      u32 val)\n{\n\twritel_relaxed(val, (xqspi->regs + offset));\n}\n\n \nstatic void zynqmp_gqspi_selectslave(struct zynqmp_qspi *instanceptr,\n\t\t\t\t     u8 slavecs, u8 slavebus)\n{\n\t \n\n\t \n\tswitch (slavecs) {\n\tcase GQSPI_SELECT_FLASH_CS_BOTH:\n\t\tinstanceptr->genfifocs = GQSPI_GENFIFO_CS_LOWER |\n\t\t\tGQSPI_GENFIFO_CS_UPPER;\n\t\tbreak;\n\tcase GQSPI_SELECT_FLASH_CS_UPPER:\n\t\tinstanceptr->genfifocs = GQSPI_GENFIFO_CS_UPPER;\n\t\tbreak;\n\tcase GQSPI_SELECT_FLASH_CS_LOWER:\n\t\tinstanceptr->genfifocs = GQSPI_GENFIFO_CS_LOWER;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(instanceptr->dev, \"Invalid slave select\\n\");\n\t}\n\n\t \n\tswitch (slavebus) {\n\tcase GQSPI_SELECT_FLASH_BUS_BOTH:\n\t\tinstanceptr->genfifobus = GQSPI_GENFIFO_BUS_LOWER |\n\t\t\tGQSPI_GENFIFO_BUS_UPPER;\n\t\tbreak;\n\tcase GQSPI_SELECT_FLASH_BUS_UPPER:\n\t\tinstanceptr->genfifobus = GQSPI_GENFIFO_BUS_UPPER;\n\t\tbreak;\n\tcase GQSPI_SELECT_FLASH_BUS_LOWER:\n\t\tinstanceptr->genfifobus = GQSPI_GENFIFO_BUS_LOWER;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(instanceptr->dev, \"Invalid slave bus\\n\");\n\t}\n}\n\n \nstatic void zynqmp_qspi_set_tapdelay(struct zynqmp_qspi *xqspi, u32 baudrateval)\n{\n\tu32 tapdlybypass = 0, lpbkdlyadj = 0, datadlyadj = 0, clk_rate;\n\tu32 reqhz = 0;\n\n\tclk_rate = clk_get_rate(xqspi->refclk);\n\treqhz = (clk_rate / (GQSPI_BAUD_DIV_SHIFT << baudrateval));\n\n\tif (!xqspi->has_tapdelay) {\n\t\tif (reqhz <= GQSPI_FREQ_40MHZ) {\n\t\t\tzynqmp_pm_set_tapdelay_bypass(PM_TAPDELAY_QSPI,\n\t\t\t\t\t\t      PM_TAPDELAY_BYPASS_ENABLE);\n\t\t} else if (reqhz <= GQSPI_FREQ_100MHZ) {\n\t\t\tzynqmp_pm_set_tapdelay_bypass(PM_TAPDELAY_QSPI,\n\t\t\t\t\t\t      PM_TAPDELAY_BYPASS_ENABLE);\n\t\t\tlpbkdlyadj |= (GQSPI_LPBK_DLY_ADJ_USE_LPBK_MASK);\n\t\t\tdatadlyadj |= ((GQSPI_USE_DATA_DLY <<\n\t\t\t\t\tGQSPI_USE_DATA_DLY_SHIFT)\n\t\t\t\t\t| (GQSPI_DATA_DLY_ADJ_VALUE <<\n\t\t\t\t\t\tGQSPI_DATA_DLY_ADJ_SHIFT));\n\t\t} else if (reqhz <= GQSPI_FREQ_150MHZ) {\n\t\t\tlpbkdlyadj |= GQSPI_LPBK_DLY_ADJ_USE_LPBK_MASK;\n\t\t}\n\t} else {\n\t\tif (reqhz <= GQSPI_FREQ_37_5MHZ) {\n\t\t\ttapdlybypass |= (TAP_DLY_BYPASS_LQSPI_RX_VALUE <<\n\t\t\t\t\tTAP_DLY_BYPASS_LQSPI_RX_SHIFT);\n\t\t} else if (reqhz <= GQSPI_FREQ_100MHZ) {\n\t\t\ttapdlybypass |= (TAP_DLY_BYPASS_LQSPI_RX_VALUE <<\n\t\t\t\t\tTAP_DLY_BYPASS_LQSPI_RX_SHIFT);\n\t\t\tlpbkdlyadj |= (GQSPI_LPBK_DLY_ADJ_USE_LPBK_MASK);\n\t\t\tdatadlyadj |= (GQSPI_USE_DATA_DLY <<\n\t\t\t\t\tGQSPI_USE_DATA_DLY_SHIFT);\n\t\t} else if (reqhz <= GQSPI_FREQ_150MHZ) {\n\t\t\tlpbkdlyadj |= (GQSPI_LPBK_DLY_ADJ_USE_LPBK_MASK\n\t\t\t\t       | (GQSPI_LPBK_DLY_ADJ_DLY_1 <<\n\t\t\t\t\t       GQSPI_LPBK_DLY_ADJ_DLY_1_SHIFT));\n\t\t}\n\t\tzynqmp_gqspi_write(xqspi,\n\t\t\t\t   IOU_TAPDLY_BYPASS_OFST, tapdlybypass);\n\t}\n\tzynqmp_gqspi_write(xqspi, GQSPI_LPBK_DLY_ADJ_OFST, lpbkdlyadj);\n\tzynqmp_gqspi_write(xqspi, GQSPI_DATA_DLY_ADJ_OFST, datadlyadj);\n}\n\n \nstatic void zynqmp_qspi_init_hw(struct zynqmp_qspi *xqspi)\n{\n\tu32 config_reg, baud_rate_val = 0;\n\tulong clk_rate;\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_SEL_OFST, GQSPI_SEL_MASK);\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_ISR_OFST,\n\t\t\t   zynqmp_gqspi_read(xqspi, GQSPI_ISR_OFST) |\n\t\t\t   GQSPI_ISR_WR_TO_CLR_MASK);\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_I_STS_OFST,\n\t\t\t   zynqmp_gqspi_read(xqspi,\n\t\t\t\t\t     GQSPI_QSPIDMA_DST_I_STS_OFST));\n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_STS_OFST,\n\t\t\t   zynqmp_gqspi_read(xqspi,\n\t\t\t\t\t     GQSPI_QSPIDMA_DST_STS_OFST) |\n\t\t\t\t\t     GQSPI_QSPIDMA_DST_STS_WTC);\n\tzynqmp_gqspi_write(xqspi, GQSPI_IDR_OFST, GQSPI_IDR_ALL_MASK);\n\tzynqmp_gqspi_write(xqspi,\n\t\t\t   GQSPI_QSPIDMA_DST_I_DIS_OFST,\n\t\t\t   GQSPI_QSPIDMA_DST_INTR_ALL_MASK);\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, 0x0);\n\tconfig_reg = zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST);\n\tconfig_reg &= ~GQSPI_CFG_MODE_EN_MASK;\n\t \n\tconfig_reg |= GQSPI_CFG_GEN_FIFO_START_MODE_MASK;\n\t \n\tconfig_reg &= ~GQSPI_CFG_ENDIAN_MASK;\n\t \n\tconfig_reg &= ~GQSPI_CFG_EN_POLL_TO_MASK;\n\t \n\tconfig_reg |= GQSPI_CFG_WP_HOLD_MASK;\n\t \n\tconfig_reg &= ~GQSPI_CFG_BAUD_RATE_DIV_MASK;\n\t \n\tif (xqspi->ctlr->mode_bits & SPI_CPHA)\n\t\tconfig_reg |= GQSPI_CFG_CLK_PHA_MASK;\n\telse\n\t\tconfig_reg &= ~GQSPI_CFG_CLK_PHA_MASK;\n\t \n\tif (xqspi->ctlr->mode_bits & SPI_CPOL)\n\t\tconfig_reg |= GQSPI_CFG_CLK_POL_MASK;\n\telse\n\t\tconfig_reg &= ~GQSPI_CFG_CLK_POL_MASK;\n\n\t \n\tclk_rate = clk_get_rate(xqspi->refclk);\n\twhile ((baud_rate_val < GQSPI_BAUD_DIV_MAX) &&\n\t       (clk_rate /\n\t\t(GQSPI_BAUD_DIV_SHIFT << baud_rate_val)) > xqspi->speed_hz)\n\t\tbaud_rate_val++;\n\n\tconfig_reg &= ~GQSPI_CFG_BAUD_RATE_DIV_MASK;\n\tconfig_reg |= (baud_rate_val << GQSPI_CFG_BAUD_RATE_DIV_SHIFT);\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);\n\n\t \n\tzynqmp_qspi_set_tapdelay(xqspi, baud_rate_val);\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_FIFO_CTRL_OFST,\n\t\t\t   GQSPI_FIFO_CTRL_RST_RX_FIFO_MASK |\n\t\t\t   GQSPI_FIFO_CTRL_RST_TX_FIFO_MASK |\n\t\t\t   GQSPI_FIFO_CTRL_RST_GEN_FIFO_MASK);\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_TX_THRESHOLD_OFST,\n\t\t\t   GQSPI_TX_FIFO_THRESHOLD_RESET_VAL);\n\tzynqmp_gqspi_write(xqspi, GQSPI_RX_THRESHOLD_OFST,\n\t\t\t   GQSPI_RX_FIFO_THRESHOLD);\n\tzynqmp_gqspi_write(xqspi, GQSPI_GF_THRESHOLD_OFST,\n\t\t\t   GQSPI_GEN_FIFO_THRESHOLD_RESET_VAL);\n\tzynqmp_gqspi_selectslave(xqspi,\n\t\t\t\t GQSPI_SELECT_FLASH_CS_LOWER,\n\t\t\t\t GQSPI_SELECT_FLASH_BUS_LOWER);\n\t \n\tzynqmp_gqspi_write(xqspi,\n\t\t\t   GQSPI_QSPIDMA_DST_CTRL_OFST,\n\t\t\t   GQSPI_QSPIDMA_DST_CTRL_RESET_VAL);\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, GQSPI_EN_MASK);\n}\n\n \nstatic void zynqmp_qspi_copy_read_data(struct zynqmp_qspi *xqspi,\n\t\t\t\t       ulong data, u8 size)\n{\n\tmemcpy(xqspi->rxbuf, &data, size);\n\txqspi->rxbuf += size;\n\txqspi->bytes_to_receive -= size;\n}\n\n \nstatic void zynqmp_qspi_chipselect(struct spi_device *qspi, bool is_high)\n{\n\tstruct zynqmp_qspi *xqspi = spi_master_get_devdata(qspi->master);\n\tulong timeout;\n\tu32 genfifoentry = 0, statusreg;\n\n\tgenfifoentry |= GQSPI_GENFIFO_MODE_SPI;\n\n\tif (!is_high) {\n\t\tif (!spi_get_chipselect(qspi, 0)) {\n\t\t\txqspi->genfifobus = GQSPI_GENFIFO_BUS_LOWER;\n\t\t\txqspi->genfifocs = GQSPI_GENFIFO_CS_LOWER;\n\t\t} else {\n\t\t\txqspi->genfifobus = GQSPI_GENFIFO_BUS_UPPER;\n\t\t\txqspi->genfifocs = GQSPI_GENFIFO_CS_UPPER;\n\t\t}\n\t\tgenfifoentry |= xqspi->genfifobus;\n\t\tgenfifoentry |= xqspi->genfifocs;\n\t\tgenfifoentry |= GQSPI_GENFIFO_CS_SETUP;\n\t} else {\n\t\tgenfifoentry |= GQSPI_GENFIFO_CS_HOLD;\n\t}\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST, genfifoentry);\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t   zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST) |\n\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\t \n\tdo {\n\t\tstatusreg = zynqmp_gqspi_read(xqspi, GQSPI_ISR_OFST);\n\n\t\tif ((statusreg & GQSPI_ISR_GENFIFOEMPTY_MASK) &&\n\t\t    (statusreg & GQSPI_ISR_TXEMPTY_MASK))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t} while (!time_after_eq(jiffies, timeout));\n\n\tif (time_after_eq(jiffies, timeout))\n\t\tdev_err(xqspi->dev, \"Chip select timed out\\n\");\n}\n\n \nstatic inline u32 zynqmp_qspi_selectspimode(struct zynqmp_qspi *xqspi,\n\t\t\t\t\t    u8 spimode)\n{\n\tu32 mask = 0;\n\n\tswitch (spimode) {\n\tcase GQSPI_SELECT_MODE_DUALSPI:\n\t\tmask = GQSPI_GENFIFO_MODE_DUALSPI;\n\t\tbreak;\n\tcase GQSPI_SELECT_MODE_QUADSPI:\n\t\tmask = GQSPI_GENFIFO_MODE_QUADSPI;\n\t\tbreak;\n\tcase GQSPI_SELECT_MODE_SPI:\n\t\tmask = GQSPI_GENFIFO_MODE_SPI;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(xqspi->dev, \"Invalid SPI mode\\n\");\n\t}\n\n\treturn mask;\n}\n\n \nstatic int zynqmp_qspi_config_op(struct zynqmp_qspi *xqspi,\n\t\t\t\t struct spi_device *qspi)\n{\n\tulong clk_rate;\n\tu32 config_reg, req_speed_hz, baud_rate_val = 0;\n\n\treq_speed_hz = qspi->max_speed_hz;\n\n\tif (xqspi->speed_hz != req_speed_hz) {\n\t\txqspi->speed_hz = req_speed_hz;\n\n\t\t \n\t\t \n\t\tclk_rate = clk_get_rate(xqspi->refclk);\n\n\t\twhile ((baud_rate_val < GQSPI_BAUD_DIV_MAX) &&\n\t\t       (clk_rate /\n\t\t\t(GQSPI_BAUD_DIV_SHIFT << baud_rate_val)) >\n\t\t       req_speed_hz)\n\t\t\tbaud_rate_val++;\n\n\t\tconfig_reg = zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST);\n\n\t\tconfig_reg &= ~GQSPI_CFG_BAUD_RATE_DIV_MASK;\n\t\tconfig_reg |= (baud_rate_val << GQSPI_CFG_BAUD_RATE_DIV_SHIFT);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);\n\t\tzynqmp_qspi_set_tapdelay(xqspi, baud_rate_val);\n\t}\n\treturn 0;\n}\n\n \nstatic int zynqmp_qspi_setup_op(struct spi_device *qspi)\n{\n\tstruct spi_controller *ctlr = qspi->master;\n\tstruct zynqmp_qspi *xqspi = spi_controller_get_devdata(ctlr);\n\n\tif (ctlr->busy)\n\t\treturn -EBUSY;\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, GQSPI_EN_MASK);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_qspi_filltxfifo(struct zynqmp_qspi *xqspi, int size)\n{\n\tu32 count = 0, intermediate;\n\n\twhile ((xqspi->bytes_to_transfer > 0) && (count < size) && (xqspi->txbuf)) {\n\t\tif (xqspi->bytes_to_transfer >= 4) {\n\t\t\tmemcpy(&intermediate, xqspi->txbuf, 4);\n\t\t\txqspi->txbuf += 4;\n\t\t\txqspi->bytes_to_transfer -= 4;\n\t\t\tcount += 4;\n\t\t} else {\n\t\t\tmemcpy(&intermediate, xqspi->txbuf,\n\t\t\t       xqspi->bytes_to_transfer);\n\t\t\txqspi->txbuf += xqspi->bytes_to_transfer;\n\t\t\txqspi->bytes_to_transfer = 0;\n\t\t\tcount += xqspi->bytes_to_transfer;\n\t\t}\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_TXD_OFST, intermediate);\n\t}\n}\n\n \nstatic void zynqmp_qspi_readrxfifo(struct zynqmp_qspi *xqspi, u32 size)\n{\n\tulong data;\n\tint count = 0;\n\n\twhile ((count < size) && (xqspi->bytes_to_receive > 0)) {\n\t\tif (xqspi->bytes_to_receive >= 4) {\n\t\t\t(*(u32 *)xqspi->rxbuf) =\n\t\t\tzynqmp_gqspi_read(xqspi, GQSPI_RXD_OFST);\n\t\t\txqspi->rxbuf += 4;\n\t\t\txqspi->bytes_to_receive -= 4;\n\t\t\tcount += 4;\n\t\t} else {\n\t\t\tdata = zynqmp_gqspi_read(xqspi, GQSPI_RXD_OFST);\n\t\t\tcount += xqspi->bytes_to_receive;\n\t\t\tzynqmp_qspi_copy_read_data(xqspi, data,\n\t\t\t\t\t\t   xqspi->bytes_to_receive);\n\t\t\txqspi->bytes_to_receive = 0;\n\t\t}\n\t}\n}\n\n \nstatic void zynqmp_qspi_fillgenfifo(struct zynqmp_qspi *xqspi, u8 nbits,\n\t\t\t\t    u32 genfifoentry)\n{\n\tu32 transfer_len = 0;\n\n\tif (xqspi->txbuf) {\n\t\tgenfifoentry &= ~GQSPI_GENFIFO_RX;\n\t\tgenfifoentry |= GQSPI_GENFIFO_DATA_XFER;\n\t\tgenfifoentry |= GQSPI_GENFIFO_TX;\n\t\ttransfer_len = xqspi->bytes_to_transfer;\n\t} else if (xqspi->rxbuf) {\n\t\tgenfifoentry &= ~GQSPI_GENFIFO_TX;\n\t\tgenfifoentry |= GQSPI_GENFIFO_DATA_XFER;\n\t\tgenfifoentry |= GQSPI_GENFIFO_RX;\n\t\tif (xqspi->mode == GQSPI_MODE_DMA)\n\t\t\ttransfer_len = xqspi->dma_rx_bytes;\n\t\telse\n\t\t\ttransfer_len = xqspi->bytes_to_receive;\n\t} else {\n\t\t \n\t\tgenfifoentry &= ~(GQSPI_GENFIFO_TX | GQSPI_GENFIFO_RX);\n\t\tgenfifoentry |= GQSPI_GENFIFO_DATA_XFER;\n\t\ttransfer_len = xqspi->bytes_to_transfer;\n\t}\n\tgenfifoentry |= zynqmp_qspi_selectspimode(xqspi, nbits);\n\txqspi->genfifoentry = genfifoentry;\n\n\tif ((transfer_len) < GQSPI_GENFIFO_IMM_DATA_MASK) {\n\t\tgenfifoentry &= ~GQSPI_GENFIFO_IMM_DATA_MASK;\n\t\tgenfifoentry |= transfer_len;\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST, genfifoentry);\n\t} else {\n\t\tint tempcount = transfer_len;\n\t\tu32 exponent = 8;\t \n\t\tu8 imm_data = tempcount & 0xFF;\n\n\t\ttempcount &= ~(tempcount & 0xFF);\n\t\t \n\t\tif (tempcount != 0) {\n\t\t\t \n\t\t\tgenfifoentry |= GQSPI_GENFIFO_EXP;\n\t\t\twhile (tempcount != 0) {\n\t\t\t\tif (tempcount & GQSPI_GENFIFO_EXP_START) {\n\t\t\t\t\tgenfifoentry &=\n\t\t\t\t\t\t~GQSPI_GENFIFO_IMM_DATA_MASK;\n\t\t\t\t\tgenfifoentry |= exponent;\n\t\t\t\t\tzynqmp_gqspi_write(xqspi,\n\t\t\t\t\t\t\t   GQSPI_GEN_FIFO_OFST,\n\t\t\t\t\t\t\t   genfifoentry);\n\t\t\t\t}\n\t\t\t\ttempcount = tempcount >> 1;\n\t\t\t\texponent++;\n\t\t\t}\n\t\t}\n\t\tif (imm_data != 0) {\n\t\t\tgenfifoentry &= ~GQSPI_GENFIFO_EXP;\n\t\t\tgenfifoentry &= ~GQSPI_GENFIFO_IMM_DATA_MASK;\n\t\t\tgenfifoentry |= (u8)(imm_data & 0xFF);\n\t\t\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST,\n\t\t\t\t\t   genfifoentry);\n\t\t}\n\t}\n\tif (xqspi->mode == GQSPI_MODE_IO && xqspi->rxbuf) {\n\t\t \n\t\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST, 0x0);\n\t}\n}\n\n \nstatic void zynqmp_process_dma_irq(struct zynqmp_qspi *xqspi)\n{\n\tu32 config_reg, genfifoentry;\n\n\tdma_unmap_single(xqspi->dev, xqspi->dma_addr,\n\t\t\t xqspi->dma_rx_bytes, DMA_FROM_DEVICE);\n\txqspi->rxbuf += xqspi->dma_rx_bytes;\n\txqspi->bytes_to_receive -= xqspi->dma_rx_bytes;\n\txqspi->dma_rx_bytes = 0;\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_I_DIS_OFST,\n\t\t\t   GQSPI_QSPIDMA_DST_I_EN_DONE_MASK);\n\n\tif (xqspi->bytes_to_receive > 0) {\n\t\t \n\t\tconfig_reg = zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST);\n\t\tconfig_reg &= ~GQSPI_CFG_MODE_EN_MASK;\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);\n\n\t\t \n\t\tgenfifoentry = xqspi->genfifoentry;\n\t\tgenfifoentry |= xqspi->bytes_to_receive;\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST, genfifoentry);\n\n\t\t \n\t\tzynqmp_gqspi_write(xqspi, GQSPI_GEN_FIFO_OFST, 0x0);\n\n\t\t \n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t   (zynqmp_gqspi_read(xqspi,\n\t\t\t\t\t\t      GQSPI_CONFIG_OFST) |\n\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK));\n\n\t\t \n\t\tzynqmp_gqspi_write(xqspi, GQSPI_IER_OFST,\n\t\t\t\t   GQSPI_IER_GENFIFOEMPTY_MASK |\n\t\t\t\t   GQSPI_IER_RXNEMPTY_MASK |\n\t\t\t\t   GQSPI_IER_RXEMPTY_MASK);\n\t}\n}\n\n \nstatic irqreturn_t zynqmp_qspi_irq(int irq, void *dev_id)\n{\n\tstruct zynqmp_qspi *xqspi = (struct zynqmp_qspi *)dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 status, mask, dma_status = 0;\n\n\tstatus = zynqmp_gqspi_read(xqspi, GQSPI_ISR_OFST);\n\tzynqmp_gqspi_write(xqspi, GQSPI_ISR_OFST, status);\n\tmask = (status & ~(zynqmp_gqspi_read(xqspi, GQSPI_IMASK_OFST)));\n\n\t \n\tif (xqspi->mode == GQSPI_MODE_DMA) {\n\t\tdma_status =\n\t\t\tzynqmp_gqspi_read(xqspi, GQSPI_QSPIDMA_DST_I_STS_OFST);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_I_STS_OFST,\n\t\t\t\t   dma_status);\n\t}\n\n\tif (mask & GQSPI_ISR_TXNOT_FULL_MASK) {\n\t\tzynqmp_qspi_filltxfifo(xqspi, GQSPI_TX_FIFO_FILL);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (dma_status & GQSPI_QSPIDMA_DST_I_STS_DONE_MASK) {\n\t\tzynqmp_process_dma_irq(xqspi);\n\t\tret = IRQ_HANDLED;\n\t} else if (!(mask & GQSPI_IER_RXEMPTY_MASK) &&\n\t\t\t(mask & GQSPI_IER_GENFIFOEMPTY_MASK)) {\n\t\tzynqmp_qspi_readrxfifo(xqspi, GQSPI_RX_FIFO_FILL);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (xqspi->bytes_to_receive == 0 && xqspi->bytes_to_transfer == 0 &&\n\t    ((status & GQSPI_IRQ_MASK) == GQSPI_IRQ_MASK)) {\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_IDR_OFST, GQSPI_ISR_IDR_MASK);\n\t\tcomplete(&xqspi->data_completion);\n\t\tret = IRQ_HANDLED;\n\t}\n\treturn ret;\n}\n\n \nstatic int zynqmp_qspi_setuprxdma(struct zynqmp_qspi *xqspi)\n{\n\tu32 rx_bytes, rx_rem, config_reg;\n\tdma_addr_t addr;\n\tu64 dma_align =  (u64)(uintptr_t)xqspi->rxbuf;\n\n\tif (xqspi->bytes_to_receive < 8 ||\n\t    ((dma_align & GQSPI_DMA_UNALIGN) != 0x0)) {\n\t\t \n\t\tconfig_reg = zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST);\n\t\tconfig_reg &= ~GQSPI_CFG_MODE_EN_MASK;\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);\n\t\txqspi->mode = GQSPI_MODE_IO;\n\t\txqspi->dma_rx_bytes = 0;\n\t\treturn 0;\n\t}\n\n\trx_rem = xqspi->bytes_to_receive % 4;\n\trx_bytes = (xqspi->bytes_to_receive - rx_rem);\n\n\taddr = dma_map_single(xqspi->dev, (void *)xqspi->rxbuf,\n\t\t\t      rx_bytes, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(xqspi->dev, addr)) {\n\t\tdev_err(xqspi->dev, \"ERR:rxdma:memory not mapped\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\txqspi->dma_rx_bytes = rx_bytes;\n\txqspi->dma_addr = addr;\n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_ADDR_OFST,\n\t\t\t   (u32)(addr & 0xffffffff));\n\taddr = ((addr >> 16) >> 16);\n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_ADDR_MSB_OFST,\n\t\t\t   ((u32)addr) & 0xfff);\n\n\t \n\tconfig_reg = zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST);\n\tconfig_reg &= ~GQSPI_CFG_MODE_EN_MASK;\n\tconfig_reg |= GQSPI_CFG_MODE_EN_DMA_MASK;\n\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);\n\n\t \n\txqspi->mode = GQSPI_MODE_DMA;\n\n\t \n\tzynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_SIZE_OFST, rx_bytes);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_qspi_write_op(struct zynqmp_qspi *xqspi, u8 tx_nbits,\n\t\t\t\t u32 genfifoentry)\n{\n\tu32 config_reg;\n\n\tzynqmp_qspi_fillgenfifo(xqspi, tx_nbits, genfifoentry);\n\tzynqmp_qspi_filltxfifo(xqspi, GQSPI_TXD_DEPTH);\n\tif (xqspi->mode == GQSPI_MODE_DMA) {\n\t\tconfig_reg = zynqmp_gqspi_read(xqspi,\n\t\t\t\t\t       GQSPI_CONFIG_OFST);\n\t\tconfig_reg &= ~GQSPI_CFG_MODE_EN_MASK;\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t   config_reg);\n\t\txqspi->mode = GQSPI_MODE_IO;\n\t}\n}\n\n \nstatic int zynqmp_qspi_read_op(struct zynqmp_qspi *xqspi, u8 rx_nbits,\n\t\t\t\tu32 genfifoentry)\n{\n\tint ret;\n\n\tret = zynqmp_qspi_setuprxdma(xqspi);\n\tif (ret)\n\t\treturn ret;\n\tzynqmp_qspi_fillgenfifo(xqspi, rx_nbits, genfifoentry);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_qspi_suspend(struct device *dev)\n{\n\tstruct zynqmp_qspi *xqspi = dev_get_drvdata(dev);\n\tstruct spi_controller *ctlr = xqspi->ctlr;\n\tint ret;\n\n\tret = spi_controller_suspend(ctlr);\n\tif (ret)\n\t\treturn ret;\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, 0x0);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_qspi_resume(struct device *dev)\n{\n\tstruct zynqmp_qspi *xqspi = dev_get_drvdata(dev);\n\tstruct spi_controller *ctlr = xqspi->ctlr;\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, GQSPI_EN_MASK);\n\n\tspi_controller_resume(ctlr);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_runtime_suspend(struct device *dev)\n{\n\tstruct zynqmp_qspi *xqspi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(xqspi->refclk);\n\tclk_disable_unprepare(xqspi->pclk);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_runtime_resume(struct device *dev)\n{\n\tstruct zynqmp_qspi *xqspi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(xqspi->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable APB clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(xqspi->refclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable device clock.\\n\");\n\t\tclk_disable_unprepare(xqspi->pclk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_qspi_exec_op(struct spi_mem *mem,\n\t\t\t       const struct spi_mem_op *op)\n{\n\tstruct zynqmp_qspi *xqspi = spi_controller_get_devdata\n\t\t\t\t    (mem->spi->master);\n\tint err = 0, i;\n\tu32 genfifoentry = 0;\n\tu16 opcode = op->cmd.opcode;\n\tu64 opaddr;\n\n\tdev_dbg(xqspi->dev, \"cmd:%#x mode:%d.%d.%d.%d\\n\",\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth);\n\n\tmutex_lock(&xqspi->op_lock);\n\tzynqmp_qspi_config_op(xqspi, mem->spi);\n\tzynqmp_qspi_chipselect(mem->spi, false);\n\tgenfifoentry |= xqspi->genfifocs;\n\tgenfifoentry |= xqspi->genfifobus;\n\n\tif (op->cmd.opcode) {\n\t\treinit_completion(&xqspi->data_completion);\n\t\txqspi->txbuf = &opcode;\n\t\txqspi->rxbuf = NULL;\n\t\txqspi->bytes_to_transfer = op->cmd.nbytes;\n\t\txqspi->bytes_to_receive = 0;\n\t\tzynqmp_qspi_write_op(xqspi, op->cmd.buswidth, genfifoentry);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t   zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST) |\n\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_IER_OFST,\n\t\t\t\t   GQSPI_IER_GENFIFOEMPTY_MASK |\n\t\t\t\t   GQSPI_IER_TXNOT_FULL_MASK);\n\t\tif (!wait_for_completion_timeout\n\t\t    (&xqspi->data_completion, msecs_to_jiffies(1000))) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto return_err;\n\t\t}\n\t}\n\n\tif (op->addr.nbytes) {\n\t\txqspi->txbuf = &opaddr;\n\t\tfor (i = 0; i < op->addr.nbytes; i++) {\n\t\t\t*(((u8 *)xqspi->txbuf) + i) = op->addr.val >>\n\t\t\t\t\t(8 * (op->addr.nbytes - i - 1));\n\t\t}\n\n\t\treinit_completion(&xqspi->data_completion);\n\t\txqspi->rxbuf = NULL;\n\t\txqspi->bytes_to_transfer = op->addr.nbytes;\n\t\txqspi->bytes_to_receive = 0;\n\t\tzynqmp_qspi_write_op(xqspi, op->addr.buswidth, genfifoentry);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t   zynqmp_gqspi_read(xqspi,\n\t\t\t\t\t\t     GQSPI_CONFIG_OFST) |\n\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_IER_OFST,\n\t\t\t\t   GQSPI_IER_TXEMPTY_MASK |\n\t\t\t\t   GQSPI_IER_GENFIFOEMPTY_MASK |\n\t\t\t\t   GQSPI_IER_TXNOT_FULL_MASK);\n\t\tif (!wait_for_completion_timeout\n\t\t    (&xqspi->data_completion, msecs_to_jiffies(1000))) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto return_err;\n\t\t}\n\t}\n\n\tif (op->dummy.nbytes) {\n\t\txqspi->txbuf = NULL;\n\t\txqspi->rxbuf = NULL;\n\t\t \n\t\txqspi->bytes_to_transfer = op->dummy.nbytes * 8 / op->dummy.buswidth;\n\t\txqspi->bytes_to_receive = 0;\n\t\t \n\t\tzynqmp_qspi_write_op(xqspi, op->data.buswidth,\n\t\t\t\t     genfifoentry);\n\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t   zynqmp_gqspi_read(xqspi, GQSPI_CONFIG_OFST) |\n\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\t}\n\n\tif (op->data.nbytes) {\n\t\treinit_completion(&xqspi->data_completion);\n\t\tif (op->data.dir == SPI_MEM_DATA_OUT) {\n\t\t\txqspi->txbuf = (u8 *)op->data.buf.out;\n\t\t\txqspi->rxbuf = NULL;\n\t\t\txqspi->bytes_to_transfer = op->data.nbytes;\n\t\t\txqspi->bytes_to_receive = 0;\n\t\t\tzynqmp_qspi_write_op(xqspi, op->data.buswidth,\n\t\t\t\t\t     genfifoentry);\n\t\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t\t   zynqmp_gqspi_read\n\t\t\t\t\t   (xqspi, GQSPI_CONFIG_OFST) |\n\t\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\t\t\tzynqmp_gqspi_write(xqspi, GQSPI_IER_OFST,\n\t\t\t\t\t   GQSPI_IER_TXEMPTY_MASK |\n\t\t\t\t\t   GQSPI_IER_GENFIFOEMPTY_MASK |\n\t\t\t\t\t   GQSPI_IER_TXNOT_FULL_MASK);\n\t\t} else {\n\t\t\txqspi->txbuf = NULL;\n\t\t\txqspi->rxbuf = (u8 *)op->data.buf.in;\n\t\t\txqspi->bytes_to_receive = op->data.nbytes;\n\t\t\txqspi->bytes_to_transfer = 0;\n\t\t\terr = zynqmp_qspi_read_op(xqspi, op->data.buswidth,\n\t\t\t\t\t    genfifoentry);\n\t\t\tif (err)\n\t\t\t\tgoto return_err;\n\n\t\t\tzynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST,\n\t\t\t\t\t   zynqmp_gqspi_read\n\t\t\t\t\t   (xqspi, GQSPI_CONFIG_OFST) |\n\t\t\t\t\t   GQSPI_CFG_START_GEN_FIFO_MASK);\n\t\t\tif (xqspi->mode == GQSPI_MODE_DMA) {\n\t\t\t\tzynqmp_gqspi_write\n\t\t\t\t\t(xqspi, GQSPI_QSPIDMA_DST_I_EN_OFST,\n\t\t\t\t\t GQSPI_QSPIDMA_DST_I_EN_DONE_MASK);\n\t\t\t} else {\n\t\t\t\tzynqmp_gqspi_write(xqspi, GQSPI_IER_OFST,\n\t\t\t\t\t\t   GQSPI_IER_GENFIFOEMPTY_MASK |\n\t\t\t\t\t\t   GQSPI_IER_RXNEMPTY_MASK |\n\t\t\t\t\t\t   GQSPI_IER_RXEMPTY_MASK);\n\t\t\t}\n\t\t}\n\t\tif (!wait_for_completion_timeout\n\t\t    (&xqspi->data_completion, msecs_to_jiffies(1000)))\n\t\t\terr = -ETIMEDOUT;\n\t}\n\nreturn_err:\n\n\tzynqmp_qspi_chipselect(mem->spi, true);\n\tmutex_unlock(&xqspi->op_lock);\n\n\treturn err;\n}\n\nstatic const struct dev_pm_ops zynqmp_qspi_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(zynqmp_runtime_suspend,\n\t\t\t   zynqmp_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(zynqmp_qspi_suspend, zynqmp_qspi_resume)\n};\n\nstatic const struct qspi_platform_data versal_qspi_def = {\n\t.quirks = QSPI_QUIRK_HAS_TAPDELAY,\n};\n\nstatic const struct of_device_id zynqmp_qspi_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-qspi-1.0\"},\n\t{ .compatible = \"xlnx,versal-qspi-1.0\", .data = &versal_qspi_def },\n\t{   }\n};\n\nstatic const struct spi_controller_mem_ops zynqmp_qspi_mem_ops = {\n\t.exec_op = zynqmp_qspi_exec_op,\n};\n\n \nstatic int zynqmp_qspi_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct spi_controller *ctlr;\n\tstruct zynqmp_qspi *xqspi;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tu32 num_cs;\n\tconst struct qspi_platform_data *p_data;\n\n\tctlr = spi_alloc_master(&pdev->dev, sizeof(*xqspi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\txqspi = spi_controller_get_devdata(ctlr);\n\txqspi->dev = dev;\n\txqspi->ctlr = ctlr;\n\tplatform_set_drvdata(pdev, xqspi);\n\n\tp_data = of_device_get_match_data(&pdev->dev);\n\tif (p_data && (p_data->quirks & QSPI_QUIRK_HAS_TAPDELAY))\n\t\txqspi->has_tapdelay = true;\n\n\txqspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xqspi->regs)) {\n\t\tret = PTR_ERR(xqspi->regs);\n\t\tgoto remove_master;\n\t}\n\n\txqspi->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(xqspi->pclk)) {\n\t\tdev_err(dev, \"pclk clock not found.\\n\");\n\t\tret = PTR_ERR(xqspi->pclk);\n\t\tgoto remove_master;\n\t}\n\n\txqspi->refclk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\tif (IS_ERR(xqspi->refclk)) {\n\t\tdev_err(dev, \"ref_clk clock not found.\\n\");\n\t\tret = PTR_ERR(xqspi->refclk);\n\t\tgoto remove_master;\n\t}\n\n\tret = clk_prepare_enable(xqspi->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable APB clock.\\n\");\n\t\tgoto remove_master;\n\t}\n\n\tret = clk_prepare_enable(xqspi->refclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable device clock.\\n\");\n\t\tgoto clk_dis_pclk;\n\t}\n\n\tinit_completion(&xqspi->data_completion);\n\n\tmutex_init(&xqspi->op_lock);\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to pm_runtime_get_sync: %d\\n\", ret);\n\t\tgoto clk_dis_all;\n\t}\n\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD |\n\t\tSPI_TX_DUAL | SPI_TX_QUAD;\n\tctlr->max_speed_hz = clk_get_rate(xqspi->refclk) / 2;\n\txqspi->speed_hz = ctlr->max_speed_hz;\n\n\t \n\tzynqmp_qspi_init_hw(xqspi);\n\n\txqspi->irq = platform_get_irq(pdev, 0);\n\tif (xqspi->irq < 0) {\n\t\tret = xqspi->irq;\n\t\tgoto clk_dis_all;\n\t}\n\tret = devm_request_irq(&pdev->dev, xqspi->irq, zynqmp_qspi_irq,\n\t\t\t       0, pdev->name, xqspi);\n\tif (ret != 0) {\n\t\tret = -ENXIO;\n\t\tdev_err(dev, \"request_irq failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(44));\n\tif (ret)\n\t\tgoto clk_dis_all;\n\n\tret = of_property_read_u32(np, \"num-cs\", &num_cs);\n\tif (ret < 0) {\n\t\tctlr->num_chipselect = GQSPI_DEFAULT_NUM_CS;\n\t} else if (num_cs > GQSPI_MAX_NUM_CS) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"only %d chip selects are available\\n\",\n\t\t\tGQSPI_MAX_NUM_CS);\n\t\tgoto clk_dis_all;\n\t} else {\n\t\tctlr->num_chipselect = num_cs;\n\t}\n\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->mem_ops = &zynqmp_qspi_mem_ops;\n\tctlr->setup = zynqmp_qspi_setup_op;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctlr->dev.of_node = np;\n\tctlr->auto_runtime_pm = true;\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller failed\\n\");\n\t\tgoto clk_dis_all;\n\t}\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nclk_dis_all:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tclk_disable_unprepare(xqspi->refclk);\nclk_dis_pclk:\n\tclk_disable_unprepare(xqspi->pclk);\nremove_master:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\n \nstatic void zynqmp_qspi_remove(struct platform_device *pdev)\n{\n\tstruct zynqmp_qspi *xqspi = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tzynqmp_gqspi_write(xqspi, GQSPI_EN_OFST, 0x0);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tclk_disable_unprepare(xqspi->refclk);\n\tclk_disable_unprepare(xqspi->pclk);\n}\n\nMODULE_DEVICE_TABLE(of, zynqmp_qspi_of_match);\n\nstatic struct platform_driver zynqmp_qspi_driver = {\n\t.probe = zynqmp_qspi_probe,\n\t.remove_new = zynqmp_qspi_remove,\n\t.driver = {\n\t\t.name = \"zynqmp-qspi\",\n\t\t.of_match_table = zynqmp_qspi_of_match,\n\t\t.pm = &zynqmp_qspi_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(zynqmp_qspi_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx Zynqmp QSPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}