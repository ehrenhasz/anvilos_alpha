{
  "module_name": "spi-rb4xx.c",
  "hash_id": "66df2b05fbbbc5e29d62452441deb682c06221125406c5938f4233564c266b7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rb4xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n\n#include <asm/mach-ath79/ar71xx_regs.h>\n\nstruct rb4xx_spi {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline u32 rb4xx_read(struct rb4xx_spi *rbspi, u32 reg)\n{\n\treturn __raw_readl(rbspi->base + reg);\n}\n\nstatic inline void rb4xx_write(struct rb4xx_spi *rbspi, u32 reg, u32 value)\n{\n\t__raw_writel(value, rbspi->base + reg);\n}\n\nstatic inline void do_spi_clk(struct rb4xx_spi *rbspi, u32 spi_ioc, int value)\n{\n\tu32 regval;\n\n\tregval = spi_ioc;\n\tif (value & BIT(0))\n\t\tregval |= AR71XX_SPI_IOC_DO;\n\n\trb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval);\n\trb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval | AR71XX_SPI_IOC_CLK);\n}\n\nstatic void do_spi_byte(struct rb4xx_spi *rbspi, u32 spi_ioc, u8 byte)\n{\n\tint i;\n\n\tfor (i = 7; i >= 0; i--)\n\t\tdo_spi_clk(rbspi, spi_ioc, byte >> i);\n}\n\n \nstatic inline void do_spi_clk_two(struct rb4xx_spi *rbspi, u32 spi_ioc,\n\t\t\t\t   u8 value)\n{\n\tu32 regval;\n\n\tregval = spi_ioc;\n\tif (value & BIT(1))\n\t\tregval |= AR71XX_SPI_IOC_DO;\n\tif (value & BIT(0))\n\t\tregval |= AR71XX_SPI_IOC_CS2;\n\n\trb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval);\n\trb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval | AR71XX_SPI_IOC_CLK);\n}\n\n \nstatic void do_spi_byte_two(struct rb4xx_spi *rbspi, u32 spi_ioc, u8 byte)\n{\n\tdo_spi_clk_two(rbspi, spi_ioc, byte >> 6);\n\tdo_spi_clk_two(rbspi, spi_ioc, byte >> 4);\n\tdo_spi_clk_two(rbspi, spi_ioc, byte >> 2);\n\tdo_spi_clk_two(rbspi, spi_ioc, byte >> 0);\n}\n\nstatic void rb4xx_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct rb4xx_spi *rbspi = spi_controller_get_devdata(spi->controller);\n\n\t \n\tif (enable)\n\t\trb4xx_write(rbspi, AR71XX_SPI_REG_IOC,\n\t\t\t    AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1);\n}\n\nstatic int rb4xx_transfer_one(struct spi_controller *host,\n\t\t\t      struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct rb4xx_spi *rbspi = spi_controller_get_devdata(host);\n\tint i;\n\tu32 spi_ioc;\n\tu8 *rx_buf;\n\tconst u8 *tx_buf;\n\n\t \n\tif (spi_get_chipselect(spi, 0) == 2)\n\t\t \n\t\tspi_ioc = AR71XX_SPI_IOC_CS0;\n\telse\n\t\t \n\t\tspi_ioc = AR71XX_SPI_IOC_CS1;\n\n\ttx_buf = t->tx_buf;\n\trx_buf = t->rx_buf;\n\tfor (i = 0; i < t->len; ++i) {\n\t\tif (t->tx_nbits == SPI_NBITS_DUAL)\n\t\t\t \n\t\t\tdo_spi_byte_two(rbspi, spi_ioc, tx_buf[i]);\n\t\telse\n\t\t\tdo_spi_byte(rbspi, spi_ioc, tx_buf[i]);\n\t\tif (!rx_buf)\n\t\t\tcontinue;\n\t\trx_buf[i] = rb4xx_read(rbspi, AR71XX_SPI_REG_RDS);\n\t}\n\tspi_finalize_current_transfer(host);\n\n\treturn 0;\n}\n\nstatic int rb4xx_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *host;\n\tstruct clk *ahb_clk;\n\tstruct rb4xx_spi *rbspi;\n\tint err;\n\tvoid __iomem *spi_base;\n\n\tspi_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spi_base))\n\t\treturn PTR_ERR(spi_base);\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(*rbspi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tahb_clk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(ahb_clk))\n\t\treturn PTR_ERR(ahb_clk);\n\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = 0;\n\thost->num_chipselect = 3;\n\thost->mode_bits = SPI_TX_DUAL;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->flags = SPI_CONTROLLER_MUST_TX;\n\thost->transfer_one = rb4xx_transfer_one;\n\thost->set_cs = rb4xx_set_cs;\n\n\trbspi = spi_controller_get_devdata(host);\n\trbspi->base = spi_base;\n\trbspi->clk = ahb_clk;\n\tplatform_set_drvdata(pdev, rbspi);\n\n\terr = devm_spi_register_controller(&pdev->dev, host);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register SPI host\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(ahb_clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\trb4xx_write(rbspi, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\n\n\treturn 0;\n}\n\nstatic void rb4xx_spi_remove(struct platform_device *pdev)\n{\n\tstruct rb4xx_spi *rbspi = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(rbspi->clk);\n}\n\nstatic const struct of_device_id rb4xx_spi_dt_match[] = {\n\t{ .compatible = \"mikrotik,rb4xx-spi\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rb4xx_spi_dt_match);\n\nstatic struct platform_driver rb4xx_spi_drv = {\n\t.probe = rb4xx_spi_probe,\n\t.remove_new = rb4xx_spi_remove,\n\t.driver = {\n\t\t.name = \"rb4xx-spi\",\n\t\t.of_match_table = of_match_ptr(rb4xx_spi_dt_match),\n\t},\n};\n\nmodule_platform_driver(rb4xx_spi_drv);\n\nMODULE_DESCRIPTION(\"Mikrotik RB4xx SPI controller driver\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org>\");\nMODULE_AUTHOR(\"Bert Vermeulen <bert@biot.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}