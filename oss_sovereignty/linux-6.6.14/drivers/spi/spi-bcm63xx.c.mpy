{
  "module_name": "spi-bcm63xx.c",
  "hash_id": "90a7e066d3220e4873d069b7c8dcfb0707f8552951edcc3b489bdffef229f48d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-bcm63xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n\n \n#define SPI_6348_RSET_SIZE\t\t64\n#define SPI_6348_CMD\t\t\t0x00\t \n#define SPI_6348_INT_STATUS\t\t0x02\n#define SPI_6348_INT_MASK_ST\t\t0x03\n#define SPI_6348_INT_MASK\t\t0x04\n#define SPI_6348_ST\t\t\t0x05\n#define SPI_6348_CLK_CFG\t\t0x06\n#define SPI_6348_FILL_BYTE\t\t0x07\n#define SPI_6348_MSG_TAIL\t\t0x09\n#define SPI_6348_RX_TAIL\t\t0x0b\n#define SPI_6348_MSG_CTL\t\t0x40\t \n#define SPI_6348_MSG_CTL_WIDTH\t\t8\n#define SPI_6348_MSG_DATA\t\t0x41\n#define SPI_6348_MSG_DATA_SIZE\t\t0x3f\n#define SPI_6348_RX_DATA\t\t0x80\n#define SPI_6348_RX_DATA_SIZE\t\t0x3f\n\n \n#define SPI_6358_RSET_SIZE\t\t1804\n#define SPI_6358_MSG_CTL\t\t0x00\t \n#define SPI_6358_MSG_CTL_WIDTH\t\t16\n#define SPI_6358_MSG_DATA\t\t0x02\n#define SPI_6358_MSG_DATA_SIZE\t\t0x21e\n#define SPI_6358_RX_DATA\t\t0x400\n#define SPI_6358_RX_DATA_SIZE\t\t0x220\n#define SPI_6358_CMD\t\t\t0x700\t \n#define SPI_6358_INT_STATUS\t\t0x702\n#define SPI_6358_INT_MASK_ST\t\t0x703\n#define SPI_6358_INT_MASK\t\t0x704\n#define SPI_6358_ST\t\t\t0x705\n#define SPI_6358_CLK_CFG\t\t0x706\n#define SPI_6358_FILL_BYTE\t\t0x707\n#define SPI_6358_MSG_TAIL\t\t0x709\n#define SPI_6358_RX_TAIL\t\t0x70B\n\n \n\n \n#define SPI_FD_RW\t\t\t0x00\n#define SPI_HD_W\t\t\t0x01\n#define SPI_HD_R\t\t\t0x02\n#define SPI_BYTE_CNT_SHIFT\t\t0\n#define SPI_6348_MSG_TYPE_SHIFT\t\t6\n#define SPI_6358_MSG_TYPE_SHIFT\t\t14\n\n \n#define SPI_CMD_NOOP\t\t\t0x00\n#define SPI_CMD_SOFT_RESET\t\t0x01\n#define SPI_CMD_HARD_RESET\t\t0x02\n#define SPI_CMD_START_IMMEDIATE\t\t0x03\n#define SPI_CMD_COMMAND_SHIFT\t\t0\n#define SPI_CMD_COMMAND_MASK\t\t0x000f\n#define SPI_CMD_DEVICE_ID_SHIFT\t\t4\n#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT\t8\n#define SPI_CMD_ONE_BYTE_SHIFT\t\t11\n#define SPI_CMD_ONE_WIRE_SHIFT\t\t12\n#define SPI_DEV_ID_0\t\t\t0\n#define SPI_DEV_ID_1\t\t\t1\n#define SPI_DEV_ID_2\t\t\t2\n#define SPI_DEV_ID_3\t\t\t3\n\n \n#define SPI_INTR_CMD_DONE\t\t0x01\n#define SPI_INTR_RX_OVERFLOW\t\t0x02\n#define SPI_INTR_TX_UNDERFLOW\t\t0x04\n#define SPI_INTR_TX_OVERFLOW\t\t0x08\n#define SPI_INTR_RX_UNDERFLOW\t\t0x10\n#define SPI_INTR_CLEAR_ALL\t\t0x1f\n\n \n#define SPI_RX_EMPTY\t\t\t0x02\n#define SPI_CMD_BUSY\t\t\t0x04\n#define SPI_SERIAL_BUSY\t\t\t0x08\n\n \n#define SPI_CLK_20MHZ\t\t\t0x00\n#define SPI_CLK_0_391MHZ\t\t0x01\n#define SPI_CLK_0_781MHZ\t\t0x02\t \n#define SPI_CLK_1_563MHZ\t\t0x03\n#define SPI_CLK_3_125MHZ\t\t0x04\n#define SPI_CLK_6_250MHZ\t\t0x05\n#define SPI_CLK_12_50MHZ\t\t0x06\n#define SPI_CLK_MASK\t\t\t0x07\n#define SPI_SSOFFTIME_MASK\t\t0x38\n#define SPI_SSOFFTIME_SHIFT\t\t3\n#define SPI_BYTE_SWAP\t\t\t0x80\n\nenum bcm63xx_regs_spi {\n\tSPI_CMD,\n\tSPI_INT_STATUS,\n\tSPI_INT_MASK_ST,\n\tSPI_INT_MASK,\n\tSPI_ST,\n\tSPI_CLK_CFG,\n\tSPI_FILL_BYTE,\n\tSPI_MSG_TAIL,\n\tSPI_RX_TAIL,\n\tSPI_MSG_CTL,\n\tSPI_MSG_DATA,\n\tSPI_RX_DATA,\n\tSPI_MSG_TYPE_SHIFT,\n\tSPI_MSG_CTL_WIDTH,\n\tSPI_MSG_DATA_SIZE,\n};\n\n#define BCM63XX_SPI_MAX_PREPEND\t\t7\n\n#define BCM63XX_SPI_MAX_CS\t\t8\n#define BCM63XX_SPI_BUS_NUM\t\t0\n\nstruct bcm63xx_spi {\n\tstruct completion\tdone;\n\n\tvoid __iomem\t\t*regs;\n\tint\t\t\tirq;\n\n\t \n\tconst unsigned long\t*reg_offsets;\n\tunsigned int\t\tfifo_size;\n\tunsigned int\t\tmsg_type_shift;\n\tunsigned int\t\tmsg_ctl_width;\n\n\t \n\tu8 __iomem\t\t*tx_io;\n\tconst u8 __iomem\t*rx_io;\n\n\tstruct clk\t\t*clk;\n\tstruct platform_device\t*pdev;\n};\n\nstatic inline u8 bcm_spi_readb(struct bcm63xx_spi *bs,\n\t\t\t       unsigned int offset)\n{\n\treturn readb(bs->regs + bs->reg_offsets[offset]);\n}\n\nstatic inline void bcm_spi_writeb(struct bcm63xx_spi *bs,\n\t\t\t\t  u8 value, unsigned int offset)\n{\n\twriteb(value, bs->regs + bs->reg_offsets[offset]);\n}\n\nstatic inline void bcm_spi_writew(struct bcm63xx_spi *bs,\n\t\t\t\t  u16 value, unsigned int offset)\n{\n#ifdef CONFIG_CPU_BIG_ENDIAN\n\tiowrite16be(value, bs->regs + bs->reg_offsets[offset]);\n#else\n\twritew(value, bs->regs + bs->reg_offsets[offset]);\n#endif\n}\n\nstatic const unsigned int bcm63xx_spi_freq_table[SPI_CLK_MASK][2] = {\n\t{ 20000000, SPI_CLK_20MHZ },\n\t{ 12500000, SPI_CLK_12_50MHZ },\n\t{  6250000, SPI_CLK_6_250MHZ },\n\t{  3125000, SPI_CLK_3_125MHZ },\n\t{  1563000, SPI_CLK_1_563MHZ },\n\t{   781000, SPI_CLK_0_781MHZ },\n\t{   391000, SPI_CLK_0_391MHZ }\n};\n\nstatic void bcm63xx_spi_setup_transfer(struct spi_device *spi,\n\t\t\t\t      struct spi_transfer *t)\n{\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(spi->controller);\n\tu8 clk_cfg, reg;\n\tint i;\n\n\t \n\tclk_cfg = SPI_CLK_0_391MHZ;\n\n\t \n\tfor (i = 0; i < SPI_CLK_MASK; i++) {\n\t\tif (t->speed_hz >= bcm63xx_spi_freq_table[i][0]) {\n\t\t\tclk_cfg = bcm63xx_spi_freq_table[i][1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treg = bcm_spi_readb(bs, SPI_CLK_CFG);\n\treg &= ~SPI_CLK_MASK;\n\treg |= clk_cfg;\n\n\tbcm_spi_writeb(bs, reg, SPI_CLK_CFG);\n\tdev_dbg(&spi->dev, \"Setting clock register to %02x (hz %d)\\n\",\n\t\tclk_cfg, t->speed_hz);\n}\n\n \n#define MODEBITS (SPI_CPOL | SPI_CPHA)\n\nstatic int bcm63xx_txrx_bufs(struct spi_device *spi, struct spi_transfer *first,\n\t\t\t\tunsigned int num_transfers)\n{\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(spi->controller);\n\tu16 msg_ctl;\n\tu16 cmd;\n\tunsigned int i, timeout = 0, prepend_len = 0, len = 0;\n\tstruct spi_transfer *t = first;\n\tbool do_rx = false;\n\tbool do_tx = false;\n\n\t \n\tbcm_spi_writeb(bs, 0, SPI_INT_MASK);\n\n\tdev_dbg(&spi->dev, \"txrx: tx %p, rx %p, len %d\\n\",\n\t\tt->tx_buf, t->rx_buf, t->len);\n\n\tif (num_transfers > 1 && t->tx_buf && t->len <= BCM63XX_SPI_MAX_PREPEND)\n\t\tprepend_len = t->len;\n\n\t \n\tfor (i = 0; i < num_transfers; i++) {\n\t\tif (t->tx_buf) {\n\t\t\tdo_tx = true;\n\t\t\tmemcpy_toio(bs->tx_io + len, t->tx_buf, t->len);\n\n\t\t\t \n\t\t\tif (t != first)\n\t\t\t\tprepend_len = 0;\n\t\t}\n\n\t\tif (t->rx_buf) {\n\t\t\tdo_rx = true;\n\t\t\t \n\t\t\tif (t == first)\n\t\t\t\tprepend_len = 0;\n\t\t}\n\n\t\tlen += t->len;\n\n\t\tt = list_entry(t->transfer_list.next, struct spi_transfer,\n\t\t\t       transfer_list);\n\t}\n\n\treinit_completion(&bs->done);\n\n\t \n\tmsg_ctl = (len << SPI_BYTE_CNT_SHIFT);\n\n\tif (do_rx && do_tx && prepend_len == 0)\n\t\tmsg_ctl |= (SPI_FD_RW << bs->msg_type_shift);\n\telse if (do_rx)\n\t\tmsg_ctl |= (SPI_HD_R << bs->msg_type_shift);\n\telse if (do_tx)\n\t\tmsg_ctl |= (SPI_HD_W << bs->msg_type_shift);\n\n\tswitch (bs->msg_ctl_width) {\n\tcase 8:\n\t\tbcm_spi_writeb(bs, msg_ctl, SPI_MSG_CTL);\n\t\tbreak;\n\tcase 16:\n\t\tbcm_spi_writew(bs, msg_ctl, SPI_MSG_CTL);\n\t\tbreak;\n\t}\n\n\t \n\tcmd = SPI_CMD_START_IMMEDIATE;\n\tcmd |= (prepend_len << SPI_CMD_PREPEND_BYTE_CNT_SHIFT);\n\tcmd |= (spi_get_chipselect(spi, 0) << SPI_CMD_DEVICE_ID_SHIFT);\n\tbcm_spi_writew(bs, cmd, SPI_CMD);\n\n\t \n\tbcm_spi_writeb(bs, SPI_INTR_CMD_DONE, SPI_INT_MASK);\n\n\ttimeout = wait_for_completion_timeout(&bs->done, HZ);\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\tif (!do_rx)\n\t\treturn 0;\n\n\tlen = 0;\n\tt = first;\n\t \n\tfor (i = 0; i < num_transfers; i++) {\n\t\tif (t->rx_buf)\n\t\t\tmemcpy_fromio(t->rx_buf, bs->rx_io + len, t->len);\n\n\t\tif (t != first || prepend_len == 0)\n\t\t\tlen += t->len;\n\n\t\tt = list_entry(t->transfer_list.next, struct spi_transfer,\n\t\t\t       transfer_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm63xx_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t\tstruct spi_message *m)\n{\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(host);\n\tstruct spi_transfer *t, *first = NULL;\n\tstruct spi_device *spi = m->spi;\n\tint status = 0;\n\tunsigned int n_transfers = 0, total_len = 0;\n\tbool can_use_prepend = false;\n\n\t \n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (!first)\n\t\t\tfirst = t;\n\n\t\tn_transfers++;\n\t\ttotal_len += t->len;\n\n\t\tif (n_transfers == 2 && !first->rx_buf && !t->tx_buf &&\n\t\t    first->len <= BCM63XX_SPI_MAX_PREPEND)\n\t\t\tcan_use_prepend = true;\n\t\telse if (can_use_prepend && t->tx_buf)\n\t\t\tcan_use_prepend = false;\n\n\t\t \n\t\tif ((can_use_prepend &&\n\t\t     total_len > (bs->fifo_size + BCM63XX_SPI_MAX_PREPEND)) ||\n\t\t    (!can_use_prepend && total_len > bs->fifo_size)) {\n\t\t\tdev_err(&spi->dev, \"unable to do transfers larger than FIFO size (%i > %i)\\n\",\n\t\t\t\ttotal_len, bs->fifo_size);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (t->speed_hz != first->speed_hz) {\n\t\t\tdev_err(&spi->dev, \"unable to change speed between transfers\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (t->delay.value) {\n\t\t\tdev_err(&spi->dev, \"unable to keep CS asserted after transfer\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (t->cs_change ||\n\t\t    list_is_last(&t->transfer_list, &m->transfers)) {\n\t\t\t \n\t\t\tbcm63xx_spi_setup_transfer(spi, first);\n\n\t\t\t \n\t\t\tstatus = bcm63xx_txrx_bufs(spi, first, n_transfers);\n\t\t\tif (status)\n\t\t\t\tgoto exit;\n\n\t\t\tm->actual_length += total_len;\n\n\t\t\tfirst = NULL;\n\t\t\tn_transfers = 0;\n\t\t\ttotal_len = 0;\n\t\t\tcan_use_prepend = false;\n\t\t}\n\t}\nexit:\n\tm->status = status;\n\tspi_finalize_current_message(host);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t bcm63xx_spi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller *host = (struct spi_controller *)dev_id;\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(host);\n\tu8 intr;\n\n\t \n\tintr = bcm_spi_readb(bs, SPI_INT_STATUS);\n\tbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\n\tbcm_spi_writeb(bs, 0, SPI_INT_MASK);\n\n\t \n\tif (intr & SPI_INTR_CMD_DONE)\n\t\tcomplete(&bs->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic size_t bcm63xx_spi_max_length(struct spi_device *spi)\n{\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(spi->controller);\n\n\treturn bs->fifo_size;\n}\n\nstatic const unsigned long bcm6348_spi_reg_offsets[] = {\n\t[SPI_CMD]\t\t= SPI_6348_CMD,\n\t[SPI_INT_STATUS]\t= SPI_6348_INT_STATUS,\n\t[SPI_INT_MASK_ST]\t= SPI_6348_INT_MASK_ST,\n\t[SPI_INT_MASK]\t\t= SPI_6348_INT_MASK,\n\t[SPI_ST]\t\t= SPI_6348_ST,\n\t[SPI_CLK_CFG]\t\t= SPI_6348_CLK_CFG,\n\t[SPI_FILL_BYTE]\t\t= SPI_6348_FILL_BYTE,\n\t[SPI_MSG_TAIL]\t\t= SPI_6348_MSG_TAIL,\n\t[SPI_RX_TAIL]\t\t= SPI_6348_RX_TAIL,\n\t[SPI_MSG_CTL]\t\t= SPI_6348_MSG_CTL,\n\t[SPI_MSG_DATA]\t\t= SPI_6348_MSG_DATA,\n\t[SPI_RX_DATA]\t\t= SPI_6348_RX_DATA,\n\t[SPI_MSG_TYPE_SHIFT]\t= SPI_6348_MSG_TYPE_SHIFT,\n\t[SPI_MSG_CTL_WIDTH]\t= SPI_6348_MSG_CTL_WIDTH,\n\t[SPI_MSG_DATA_SIZE]\t= SPI_6348_MSG_DATA_SIZE,\n};\n\nstatic const unsigned long bcm6358_spi_reg_offsets[] = {\n\t[SPI_CMD]\t\t= SPI_6358_CMD,\n\t[SPI_INT_STATUS]\t= SPI_6358_INT_STATUS,\n\t[SPI_INT_MASK_ST]\t= SPI_6358_INT_MASK_ST,\n\t[SPI_INT_MASK]\t\t= SPI_6358_INT_MASK,\n\t[SPI_ST]\t\t= SPI_6358_ST,\n\t[SPI_CLK_CFG]\t\t= SPI_6358_CLK_CFG,\n\t[SPI_FILL_BYTE]\t\t= SPI_6358_FILL_BYTE,\n\t[SPI_MSG_TAIL]\t\t= SPI_6358_MSG_TAIL,\n\t[SPI_RX_TAIL]\t\t= SPI_6358_RX_TAIL,\n\t[SPI_MSG_CTL]\t\t= SPI_6358_MSG_CTL,\n\t[SPI_MSG_DATA]\t\t= SPI_6358_MSG_DATA,\n\t[SPI_RX_DATA]\t\t= SPI_6358_RX_DATA,\n\t[SPI_MSG_TYPE_SHIFT]\t= SPI_6358_MSG_TYPE_SHIFT,\n\t[SPI_MSG_CTL_WIDTH]\t= SPI_6358_MSG_CTL_WIDTH,\n\t[SPI_MSG_DATA_SIZE]\t= SPI_6358_MSG_DATA_SIZE,\n};\n\nstatic const struct platform_device_id bcm63xx_spi_dev_match[] = {\n\t{\n\t\t.name = \"bcm6348-spi\",\n\t\t.driver_data = (unsigned long)bcm6348_spi_reg_offsets,\n\t},\n\t{\n\t\t.name = \"bcm6358-spi\",\n\t\t.driver_data = (unsigned long)bcm6358_spi_reg_offsets,\n\t},\n\t{\n\t},\n};\n\nstatic const struct of_device_id bcm63xx_spi_of_match[] = {\n\t{ .compatible = \"brcm,bcm6348-spi\", .data = &bcm6348_spi_reg_offsets },\n\t{ .compatible = \"brcm,bcm6358-spi\", .data = &bcm6358_spi_reg_offsets },\n\t{ },\n};\n\nstatic int bcm63xx_spi_probe(struct platform_device *pdev)\n{\n\tstruct resource *r;\n\tconst unsigned long *bcm63xx_spireg;\n\tstruct device *dev = &pdev->dev;\n\tint irq, bus_num;\n\tstruct spi_controller *host;\n\tstruct clk *clk;\n\tstruct bcm63xx_spi *bs;\n\tint ret;\n\tu32 num_cs = BCM63XX_SPI_MAX_CS;\n\tstruct reset_control *reset;\n\n\tif (dev->of_node) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(bcm63xx_spi_of_match, dev->of_node);\n\t\tif (!match)\n\t\t\treturn -EINVAL;\n\t\tbcm63xx_spireg = match->data;\n\n\t\tof_property_read_u32(dev->of_node, \"num-cs\", &num_cs);\n\t\tif (num_cs > BCM63XX_SPI_MAX_CS) {\n\t\t\tdev_warn(dev, \"unsupported number of cs (%i), reducing to 8\\n\",\n\t\t\t\t num_cs);\n\t\t\tnum_cs = BCM63XX_SPI_MAX_CS;\n\t\t}\n\n\t\tbus_num = -1;\n\t} else if (pdev->id_entry->driver_data) {\n\t\tconst struct platform_device_id *match = pdev->id_entry;\n\n\t\tbcm63xx_spireg = (const unsigned long *)match->driver_data;\n\t\tbus_num = BCM63XX_SPI_BUS_NUM;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tclk = devm_clk_get(dev, \"spi\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"no clock for device\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\treset = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\thost = spi_alloc_host(dev, sizeof(*bs));\n\tif (!host) {\n\t\tdev_err(dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbs = spi_controller_get_devdata(host);\n\tinit_completion(&bs->done);\n\n\tplatform_set_drvdata(pdev, host);\n\tbs->pdev = pdev;\n\n\tbs->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(bs->regs)) {\n\t\tret = PTR_ERR(bs->regs);\n\t\tgoto out_err;\n\t}\n\n\tbs->irq = irq;\n\tbs->clk = clk;\n\tbs->reg_offsets = bcm63xx_spireg;\n\tbs->fifo_size = bs->reg_offsets[SPI_MSG_DATA_SIZE];\n\n\tret = devm_request_irq(&pdev->dev, irq, bcm63xx_spi_interrupt, 0,\n\t\t\t       pdev->name, host);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request irq\\n\");\n\t\tgoto out_err;\n\t}\n\n\thost->dev.of_node = dev->of_node;\n\thost->bus_num = bus_num;\n\thost->num_chipselect = num_cs;\n\thost->transfer_one_message = bcm63xx_spi_transfer_one;\n\thost->mode_bits = MODEBITS;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->max_transfer_size = bcm63xx_spi_max_length;\n\thost->max_message_size = bcm63xx_spi_max_length;\n\thost->auto_runtime_pm = true;\n\tbs->msg_type_shift = bs->reg_offsets[SPI_MSG_TYPE_SHIFT];\n\tbs->msg_ctl_width = bs->reg_offsets[SPI_MSG_CTL_WIDTH];\n\tbs->tx_io = (u8 *)(bs->regs + bs->reg_offsets[SPI_MSG_DATA]);\n\tbs->rx_io = (const u8 *)(bs->regs + bs->reg_offsets[SPI_RX_DATA]);\n\n\t \n\tret = clk_prepare_enable(bs->clk);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = reset_control_reset(reset);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to reset device: %d\\n\", ret);\n\t\tgoto out_clk_disable;\n\t}\n\n\tbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tret = devm_spi_register_controller(dev, host);\n\tif (ret) {\n\t\tdev_err(dev, \"spi register failed\\n\");\n\t\tgoto out_pm_disable;\n\t}\n\n\tdev_info(dev, \"at %pr (irq %d, FIFOs size %d)\\n\",\n\t\t r, irq, bs->fifo_size);\n\n\treturn 0;\n\nout_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nout_clk_disable:\n\tclk_disable_unprepare(clk);\nout_err:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic void bcm63xx_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(host);\n\n\t \n\tbcm_spi_writeb(bs, 0, SPI_INT_MASK);\n\n\t \n\tclk_disable_unprepare(bs->clk);\n}\n\nstatic int bcm63xx_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(host);\n\n\tspi_controller_suspend(host);\n\n\tclk_disable_unprepare(bs->clk);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct bcm63xx_spi *bs = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(bs->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_controller_resume(host);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(bcm63xx_spi_pm_ops, bcm63xx_spi_suspend, bcm63xx_spi_resume);\n\nstatic struct platform_driver bcm63xx_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"bcm63xx-spi\",\n\t\t.pm\t= &bcm63xx_spi_pm_ops,\n\t\t.of_match_table = bcm63xx_spi_of_match,\n\t},\n\t.id_table\t= bcm63xx_spi_dev_match,\n\t.probe\t\t= bcm63xx_spi_probe,\n\t.remove_new\t= bcm63xx_spi_remove,\n};\n\nmodule_platform_driver(bcm63xx_spi_driver);\n\nMODULE_ALIAS(\"platform:bcm63xx_spi\");\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_AUTHOR(\"Tanguy Bouzeloc <tanguy.bouzeloc@efixo.com>\");\nMODULE_DESCRIPTION(\"Broadcom BCM63xx SPI Controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}