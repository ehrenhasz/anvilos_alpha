{
  "module_name": "spi-microchip-core.c",
  "hash_id": "75ea9d20c7694dd900eb873bb1631aed5ba2bb670c74ca685ef8b46b091f96b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-microchip-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n#define MAX_LEN\t\t\t\t(0xffff)\n#define MAX_CS\t\t\t\t(8)\n#define DEFAULT_FRAMESIZE\t\t(8)\n#define FIFO_DEPTH\t\t\t(32)\n#define CLK_GEN_MODE1_MAX\t\t(255)\n#define CLK_GEN_MODE0_MAX\t\t(15)\n#define CLK_GEN_MIN\t\t\t(0)\n#define MODE_X_MASK_SHIFT\t\t(24)\n\n#define CONTROL_ENABLE\t\t\tBIT(0)\n#define CONTROL_MASTER\t\t\tBIT(1)\n#define CONTROL_RX_DATA_INT\t\tBIT(4)\n#define CONTROL_TX_DATA_INT\t\tBIT(5)\n#define CONTROL_RX_OVER_INT\t\tBIT(6)\n#define CONTROL_TX_UNDER_INT\t\tBIT(7)\n#define CONTROL_SPO\t\t\tBIT(24)\n#define CONTROL_SPH\t\t\tBIT(25)\n#define CONTROL_SPS\t\t\tBIT(26)\n#define CONTROL_FRAMEURUN\t\tBIT(27)\n#define CONTROL_CLKMODE\t\t\tBIT(28)\n#define CONTROL_BIGFIFO\t\t\tBIT(29)\n#define CONTROL_OENOFF\t\t\tBIT(30)\n#define CONTROL_RESET\t\t\tBIT(31)\n\n#define CONTROL_MODE_MASK\t\tGENMASK(3, 2)\n#define  MOTOROLA_MODE\t\t\t(0)\n#define CONTROL_FRAMECNT_MASK\t\tGENMASK(23, 8)\n#define CONTROL_FRAMECNT_SHIFT\t\t(8)\n\n#define STATUS_ACTIVE\t\t\tBIT(14)\n#define STATUS_SSEL\t\t\tBIT(13)\n#define STATUS_FRAMESTART\t\tBIT(12)\n#define STATUS_TXFIFO_EMPTY_NEXT_READ\tBIT(11)\n#define STATUS_TXFIFO_EMPTY\t\tBIT(10)\n#define STATUS_TXFIFO_FULL_NEXT_WRITE\tBIT(9)\n#define STATUS_TXFIFO_FULL\t\tBIT(8)\n#define STATUS_RXFIFO_EMPTY_NEXT_READ\tBIT(7)\n#define STATUS_RXFIFO_EMPTY\t\tBIT(6)\n#define STATUS_RXFIFO_FULL_NEXT_WRITE\tBIT(5)\n#define STATUS_RXFIFO_FULL\t\tBIT(4)\n#define STATUS_TX_UNDERRUN\t\tBIT(3)\n#define STATUS_RX_OVERFLOW\t\tBIT(2)\n#define STATUS_RXDAT_RXED\t\tBIT(1)\n#define STATUS_TXDAT_SENT\t\tBIT(0)\n\n#define INT_TXDONE\t\t\tBIT(0)\n#define INT_RXRDY\t\t\tBIT(1)\n#define INT_RX_CHANNEL_OVERFLOW\t\tBIT(2)\n#define INT_TX_CHANNEL_UNDERRUN\t\tBIT(3)\n\n#define INT_ENABLE_MASK (CONTROL_RX_DATA_INT | CONTROL_TX_DATA_INT | \\\n\t\t\t CONTROL_RX_OVER_INT | CONTROL_TX_UNDER_INT)\n\n#define REG_CONTROL\t\t(0x00)\n#define REG_FRAME_SIZE\t\t(0x04)\n#define REG_STATUS\t\t(0x08)\n#define REG_INT_CLEAR\t\t(0x0c)\n#define REG_RX_DATA\t\t(0x10)\n#define REG_TX_DATA\t\t(0x14)\n#define REG_CLK_GEN\t\t(0x18)\n#define REG_SLAVE_SELECT\t(0x1c)\n#define  SSEL_MASK\t\tGENMASK(7, 0)\n#define  SSEL_DIRECT\t\tBIT(8)\n#define  SSELOUT_SHIFT\t\t9\n#define  SSELOUT\t\tBIT(SSELOUT_SHIFT)\n#define REG_MIS\t\t\t(0x20)\n#define REG_RIS\t\t\t(0x24)\n#define REG_CONTROL2\t\t(0x28)\n#define REG_COMMAND\t\t(0x2c)\n#define REG_PKTSIZE\t\t(0x30)\n#define REG_CMD_SIZE\t\t(0x34)\n#define REG_HWSTATUS\t\t(0x38)\n#define REG_STAT8\t\t(0x3c)\n#define REG_CTRL2\t\t(0x48)\n#define REG_FRAMESUP\t\t(0x50)\n\nstruct mchp_corespi {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tconst u8 *tx_buf;\n\tu8 *rx_buf;\n\tu32 clk_gen;  \n\tu32 clk_mode;\n\tint irq;\n\tint tx_len;\n\tint rx_len;\n\tint pending;\n};\n\nstatic inline u32 mchp_corespi_read(struct mchp_corespi *spi, unsigned int reg)\n{\n\treturn readl(spi->regs + reg);\n}\n\nstatic inline void mchp_corespi_write(struct mchp_corespi *spi, unsigned int reg, u32 val)\n{\n\twritel(val, spi->regs + reg);\n}\n\nstatic inline void mchp_corespi_disable(struct mchp_corespi *spi)\n{\n\tu32 control = mchp_corespi_read(spi, REG_CONTROL);\n\n\tcontrol &= ~CONTROL_ENABLE;\n\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic inline void mchp_corespi_read_fifo(struct mchp_corespi *spi)\n{\n\tu8 data;\n\tint fifo_max, i = 0;\n\n\tfifo_max = min(spi->rx_len, FIFO_DEPTH);\n\n\twhile ((i < fifo_max) && !(mchp_corespi_read(spi, REG_STATUS) & STATUS_RXFIFO_EMPTY)) {\n\t\tdata = mchp_corespi_read(spi, REG_RX_DATA);\n\n\t\tif (spi->rx_buf)\n\t\t\t*spi->rx_buf++ = data;\n\t\ti++;\n\t}\n\tspi->rx_len -= i;\n\tspi->pending -= i;\n}\n\nstatic void mchp_corespi_enable_ints(struct mchp_corespi *spi)\n{\n\tu32 control, mask = INT_ENABLE_MASK;\n\n\tmchp_corespi_disable(spi);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\n\tcontrol |= mask;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\n\tcontrol |= CONTROL_ENABLE;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic void mchp_corespi_disable_ints(struct mchp_corespi *spi)\n{\n\tu32 control, mask = INT_ENABLE_MASK;\n\n\tmchp_corespi_disable(spi);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tcontrol &= ~mask;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\n\tcontrol |= CONTROL_ENABLE;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic inline void mchp_corespi_set_xfer_size(struct mchp_corespi *spi, int len)\n{\n\tu32 control;\n\tu16 lenpart;\n\n\t \n\tmchp_corespi_disable(spi);\n\n\t \n\tlenpart = len & 0xffff;\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tcontrol &= ~CONTROL_FRAMECNT_MASK;\n\tcontrol |= lenpart << CONTROL_FRAMECNT_SHIFT;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\n\tlenpart = len & 0xffff0000;\n\tmchp_corespi_write(spi, REG_FRAMESUP, lenpart);\n\n\tcontrol |= CONTROL_ENABLE;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic inline void mchp_corespi_write_fifo(struct mchp_corespi *spi)\n{\n\tu8 byte;\n\tint fifo_max, i = 0;\n\n\tfifo_max = min(spi->tx_len, FIFO_DEPTH);\n\tmchp_corespi_set_xfer_size(spi, fifo_max);\n\n\twhile ((i < fifo_max) && !(mchp_corespi_read(spi, REG_STATUS) & STATUS_TXFIFO_FULL)) {\n\t\tbyte = spi->tx_buf ? *spi->tx_buf++ : 0xaa;\n\t\tmchp_corespi_write(spi, REG_TX_DATA, byte);\n\t\ti++;\n\t}\n\n\tspi->tx_len -= i;\n\tspi->pending += i;\n}\n\nstatic inline void mchp_corespi_set_framesize(struct mchp_corespi *spi, int bt)\n{\n\tu32 control;\n\n\t \n\tmchp_corespi_disable(spi);\n\n\tmchp_corespi_write(spi, REG_FRAME_SIZE, bt);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tcontrol |= CONTROL_ENABLE;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic void mchp_corespi_set_cs(struct spi_device *spi, bool disable)\n{\n\tu32 reg;\n\tstruct mchp_corespi *corespi = spi_master_get_devdata(spi->master);\n\n\treg = mchp_corespi_read(corespi, REG_SLAVE_SELECT);\n\treg &= ~BIT(spi_get_chipselect(spi, 0));\n\treg |= !disable << spi_get_chipselect(spi, 0);\n\n\tmchp_corespi_write(corespi, REG_SLAVE_SELECT, reg);\n}\n\nstatic int mchp_corespi_setup(struct spi_device *spi)\n{\n\tstruct mchp_corespi *corespi = spi_master_get_devdata(spi->master);\n\tu32 reg;\n\n\t \n\tif (spi->mode & SPI_CS_HIGH) {\n\t\treg = mchp_corespi_read(corespi, REG_SLAVE_SELECT);\n\t\treg |= BIT(spi_get_chipselect(spi, 0));\n\t\tmchp_corespi_write(corespi, REG_SLAVE_SELECT, reg);\n\t}\n\treturn 0;\n}\n\nstatic void mchp_corespi_init(struct spi_master *master, struct mchp_corespi *spi)\n{\n\tunsigned long clk_hz;\n\tu32 control = mchp_corespi_read(spi, REG_CONTROL);\n\n\tcontrol |= CONTROL_MASTER;\n\n\tcontrol &= ~CONTROL_MODE_MASK;\n\tcontrol |= MOTOROLA_MODE;\n\n\tmchp_corespi_set_framesize(spi, DEFAULT_FRAMESIZE);\n\n\t \n\tclk_hz = clk_get_rate(spi->clk);\n\tmaster->max_speed_hz = clk_hz;\n\n\t \n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tcontrol |= CONTROL_SPS | CONTROL_BIGFIFO;\n\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\n\tmchp_corespi_enable_ints(spi);\n\n\t \n\tmchp_corespi_write(spi, REG_SLAVE_SELECT, SSELOUT | SSEL_DIRECT);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\n\tcontrol &= ~CONTROL_RESET;\n\tcontrol |= CONTROL_ENABLE;\n\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic inline void mchp_corespi_set_clk_gen(struct mchp_corespi *spi)\n{\n\tu32 control;\n\n\tmchp_corespi_disable(spi);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tif (spi->clk_mode)\n\t\tcontrol |= CONTROL_CLKMODE;\n\telse\n\t\tcontrol &= ~CONTROL_CLKMODE;\n\n\tmchp_corespi_write(spi, REG_CLK_GEN, spi->clk_gen);\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\tmchp_corespi_write(spi, REG_CONTROL, control | CONTROL_ENABLE);\n}\n\nstatic inline void mchp_corespi_set_mode(struct mchp_corespi *spi, unsigned int mode)\n{\n\tu32 control, mode_val;\n\n\tswitch (mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\t\tmode_val = 0;\n\t\tbreak;\n\tcase SPI_MODE_1:\n\t\tmode_val = CONTROL_SPH;\n\t\tbreak;\n\tcase SPI_MODE_2:\n\t\tmode_val = CONTROL_SPO;\n\t\tbreak;\n\tcase SPI_MODE_3:\n\t\tmode_val = CONTROL_SPH | CONTROL_SPO;\n\t\tbreak;\n\t}\n\n\t \n\tmchp_corespi_disable(spi);\n\n\tcontrol = mchp_corespi_read(spi, REG_CONTROL);\n\tcontrol &= ~(SPI_MODE_X_MASK << MODE_X_MASK_SHIFT);\n\tcontrol |= mode_val;\n\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n\n\tcontrol |= CONTROL_ENABLE;\n\tmchp_corespi_write(spi, REG_CONTROL, control);\n}\n\nstatic irqreturn_t mchp_corespi_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_master *master = dev_id;\n\tstruct mchp_corespi *spi = spi_master_get_devdata(master);\n\tu32 intfield = mchp_corespi_read(spi, REG_MIS) & 0xf;\n\tbool finalise = false;\n\n\t \n\tif (intfield == 0)\n\t\treturn IRQ_NONE;\n\n\tif (intfield & INT_TXDONE) {\n\t\tmchp_corespi_write(spi, REG_INT_CLEAR, INT_TXDONE);\n\n\t\tif (spi->rx_len)\n\t\t\tmchp_corespi_read_fifo(spi);\n\n\t\tif (spi->tx_len)\n\t\t\tmchp_corespi_write_fifo(spi);\n\n\t\tif (!spi->rx_len)\n\t\t\tfinalise = true;\n\t}\n\n\tif (intfield & INT_RXRDY)\n\t\tmchp_corespi_write(spi, REG_INT_CLEAR, INT_RXRDY);\n\n\tif (intfield & INT_RX_CHANNEL_OVERFLOW) {\n\t\tmchp_corespi_write(spi, REG_INT_CLEAR, INT_RX_CHANNEL_OVERFLOW);\n\t\tfinalise = true;\n\t\tdev_err(&master->dev,\n\t\t\t\"%s: RX OVERFLOW: rxlen: %d, txlen: %d\\n\", __func__,\n\t\t\tspi->rx_len, spi->tx_len);\n\t}\n\n\tif (intfield & INT_TX_CHANNEL_UNDERRUN) {\n\t\tmchp_corespi_write(spi, REG_INT_CLEAR, INT_TX_CHANNEL_UNDERRUN);\n\t\tfinalise = true;\n\t\tdev_err(&master->dev,\n\t\t\t\"%s: TX UNDERFLOW: rxlen: %d, txlen: %d\\n\", __func__,\n\t\t\tspi->rx_len, spi->tx_len);\n\t}\n\n\tif (finalise)\n\t\tspi_finalize_current_transfer(master);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mchp_corespi_calculate_clkgen(struct mchp_corespi *spi,\n\t\t\t\t\t unsigned long target_hz)\n{\n\tunsigned long clk_hz, spi_hz, clk_gen;\n\n\tclk_hz = clk_get_rate(spi->clk);\n\tif (!clk_hz)\n\t\treturn -EINVAL;\n\tspi_hz = min(target_hz, clk_hz);\n\n\t \n\tclk_gen = DIV_ROUND_UP(clk_hz, 2 * spi_hz) - 1;\n\tif (clk_gen > CLK_GEN_MODE1_MAX || clk_gen <= CLK_GEN_MIN) {\n\t\tclk_gen = DIV_ROUND_UP(clk_hz, spi_hz);\n\t\tclk_gen = fls(clk_gen) - 1;\n\n\t\tif (clk_gen > CLK_GEN_MODE0_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tspi->clk_mode = 0;\n\t} else {\n\t\tspi->clk_mode = 1;\n\t}\n\n\tspi->clk_gen = clk_gen;\n\treturn 0;\n}\n\nstatic int mchp_corespi_transfer_one(struct spi_master *master,\n\t\t\t\t     struct spi_device *spi_dev,\n\t\t\t\t     struct spi_transfer *xfer)\n{\n\tstruct mchp_corespi *spi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = mchp_corespi_calculate_clkgen(spi, (unsigned long)xfer->speed_hz);\n\tif (ret) {\n\t\tdev_err(&master->dev, \"failed to set clk_gen for target %u Hz\\n\", xfer->speed_hz);\n\t\treturn ret;\n\t}\n\n\tmchp_corespi_set_clk_gen(spi);\n\n\tspi->tx_buf = xfer->tx_buf;\n\tspi->rx_buf = xfer->rx_buf;\n\tspi->tx_len = xfer->len;\n\tspi->rx_len = xfer->len;\n\tspi->pending = 0;\n\n\tmchp_corespi_set_xfer_size(spi, (spi->tx_len > FIFO_DEPTH)\n\t\t\t\t   ? FIFO_DEPTH : spi->tx_len);\n\n\tif (spi->tx_len)\n\t\tmchp_corespi_write_fifo(spi);\n\treturn 1;\n}\n\nstatic int mchp_corespi_prepare_message(struct spi_master *master,\n\t\t\t\t\tstruct spi_message *msg)\n{\n\tstruct spi_device *spi_dev = msg->spi;\n\tstruct mchp_corespi *spi = spi_master_get_devdata(master);\n\n\tmchp_corespi_set_framesize(spi, DEFAULT_FRAMESIZE);\n\tmchp_corespi_set_mode(spi, spi_dev->mode);\n\n\treturn 0;\n}\n\nstatic int mchp_corespi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct mchp_corespi *spi;\n\tstruct resource *res;\n\tu32 num_cs;\n\tint ret = 0;\n\n\tmaster = devm_spi_alloc_master(&pdev->dev, sizeof(*spi));\n\tif (!master)\n\t\treturn dev_err_probe(&pdev->dev, -ENOMEM,\n\t\t\t\t     \"unable to allocate master for SPI controller\\n\");\n\n\tplatform_set_drvdata(pdev, master);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"num-cs\", &num_cs))\n\t\tnum_cs = MAX_CS;\n\n\tmaster->num_chipselect = num_cs;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tmaster->setup = mchp_corespi_setup;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->transfer_one = mchp_corespi_transfer_one;\n\tmaster->prepare_message = mchp_corespi_prepare_message;\n\tmaster->set_cs = mchp_corespi_set_cs;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\n\tspi = spi_master_get_devdata(master);\n\n\tspi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(spi->regs))\n\t\treturn PTR_ERR(spi->regs);\n\n\tspi->irq = platform_get_irq(pdev, 0);\n\tif (spi->irq < 0)\n\t\treturn spi->irq;\n\n\tret = devm_request_irq(&pdev->dev, spi->irq, mchp_corespi_interrupt,\n\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), master);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"could not request irq\\n\");\n\n\tspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(spi->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(spi->clk),\n\t\t\t\t     \"could not get clk\\n\");\n\n\tret = clk_prepare_enable(spi->clk);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to enable clock\\n\");\n\n\tmchp_corespi_init(master, spi);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tmchp_corespi_disable(spi);\n\t\tclk_disable_unprepare(spi->clk);\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"unable to register master for SPI controller\\n\");\n\t}\n\n\tdev_info(&pdev->dev, \"Registered SPI controller %d\\n\", master->bus_num);\n\n\treturn 0;\n}\n\nstatic void mchp_corespi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master  = platform_get_drvdata(pdev);\n\tstruct mchp_corespi *spi = spi_master_get_devdata(master);\n\n\tmchp_corespi_disable_ints(spi);\n\tclk_disable_unprepare(spi->clk);\n\tmchp_corespi_disable(spi);\n}\n\n#define MICROCHIP_SPI_PM_OPS (NULL)\n\n \n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id mchp_corespi_dt_ids[] = {\n\t{ .compatible = \"microchip,mpfs-spi\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_corespi_dt_ids);\n#endif\n\nstatic struct platform_driver mchp_corespi_driver = {\n\t.probe = mchp_corespi_probe,\n\t.driver = {\n\t\t.name = \"microchip-corespi\",\n\t\t.pm = MICROCHIP_SPI_PM_OPS,\n\t\t.of_match_table = of_match_ptr(mchp_corespi_dt_ids),\n\t},\n\t.remove_new = mchp_corespi_remove,\n};\nmodule_platform_driver(mchp_corespi_driver);\nMODULE_DESCRIPTION(\"Microchip coreSPI SPI controller driver\");\nMODULE_AUTHOR(\"Daire McNamara <daire.mcnamara@microchip.com>\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}