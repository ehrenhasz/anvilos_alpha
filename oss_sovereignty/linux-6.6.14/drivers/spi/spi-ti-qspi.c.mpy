{
  "module_name": "spi-ti-qspi.c",
  "hash_id": "5ae9c910e391dee3dc8570241f33ea69ddfcf0c82f95f4a4f26036cbac73228c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-ti-qspi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/omap-dma.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\nstruct ti_qspi_regs {\n\tu32 clkctrl;\n};\n\nstruct ti_qspi {\n\tstruct completion\ttransfer_complete;\n\n\t \n\tstruct mutex            list_lock;\n\n\tstruct spi_master\t*master;\n\tvoid __iomem            *base;\n\tvoid __iomem            *mmap_base;\n\tsize_t\t\t\tmmap_size;\n\tstruct regmap\t\t*ctrl_base;\n\tunsigned int\t\tctrl_reg;\n\tstruct clk\t\t*fclk;\n\tstruct device           *dev;\n\n\tstruct ti_qspi_regs     ctx_reg;\n\n\tdma_addr_t\t\tmmap_phys_base;\n\tdma_addr_t\t\trx_bb_dma_addr;\n\tvoid\t\t\t*rx_bb_addr;\n\tstruct dma_chan\t\t*rx_chan;\n\n\tu32 cmd;\n\tu32 dc;\n\n\tbool mmap_enabled;\n\tint current_cs;\n};\n\n#define QSPI_PID\t\t\t(0x0)\n#define QSPI_SYSCONFIG\t\t\t(0x10)\n#define QSPI_SPI_CLOCK_CNTRL_REG\t(0x40)\n#define QSPI_SPI_DC_REG\t\t\t(0x44)\n#define QSPI_SPI_CMD_REG\t\t(0x48)\n#define QSPI_SPI_STATUS_REG\t\t(0x4c)\n#define QSPI_SPI_DATA_REG\t\t(0x50)\n#define QSPI_SPI_SETUP_REG(n)\t\t((0x54 + 4 * n))\n#define QSPI_SPI_SWITCH_REG\t\t(0x64)\n#define QSPI_SPI_DATA_REG_1\t\t(0x68)\n#define QSPI_SPI_DATA_REG_2\t\t(0x6c)\n#define QSPI_SPI_DATA_REG_3\t\t(0x70)\n\n#define QSPI_COMPLETION_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n \n#define QSPI_CLK_EN\t\t\t(1 << 31)\n#define QSPI_CLK_DIV_MAX\t\t0xffff\n\n \n#define QSPI_EN_CS(n)\t\t\t(n << 28)\n#define QSPI_WLEN(n)\t\t\t((n - 1) << 19)\n#define QSPI_3_PIN\t\t\t(1 << 18)\n#define QSPI_RD_SNGL\t\t\t(1 << 16)\n#define QSPI_WR_SNGL\t\t\t(2 << 16)\n#define QSPI_RD_DUAL\t\t\t(3 << 16)\n#define QSPI_RD_QUAD\t\t\t(7 << 16)\n#define QSPI_INVAL\t\t\t(4 << 16)\n#define QSPI_FLEN(n)\t\t\t((n - 1) << 0)\n#define QSPI_WLEN_MAX_BITS\t\t128\n#define QSPI_WLEN_MAX_BYTES\t\t16\n#define QSPI_WLEN_MASK\t\t\tQSPI_WLEN(QSPI_WLEN_MAX_BITS)\n\n \n#define BUSY\t\t\t\t0x01\n#define WC\t\t\t\t0x02\n\n \n#define QSPI_DD(m, n)\t\t\t(m << (3 + n * 8))\n#define QSPI_CKPHA(n)\t\t\t(1 << (2 + n * 8))\n#define QSPI_CSPOL(n)\t\t\t(1 << (1 + n * 8))\n#define QSPI_CKPOL(n)\t\t\t(1 << (n * 8))\n\n#define\tQSPI_FRAME\t\t\t4096\n\n#define QSPI_AUTOSUSPEND_TIMEOUT         2000\n\n#define MEM_CS_EN(n)\t\t\t((n + 1) << 8)\n#define MEM_CS_MASK\t\t\t(7 << 8)\n\n#define MM_SWITCH\t\t\t0x1\n\n#define QSPI_SETUP_RD_NORMAL\t\t(0x0 << 12)\n#define QSPI_SETUP_RD_DUAL\t\t(0x1 << 12)\n#define QSPI_SETUP_RD_QUAD\t\t(0x3 << 12)\n#define QSPI_SETUP_ADDR_SHIFT\t\t8\n#define QSPI_SETUP_DUMMY_SHIFT\t\t10\n\n#define QSPI_DMA_BUFFER_SIZE            SZ_64K\n\nstatic inline unsigned long ti_qspi_read(struct ti_qspi *qspi,\n\t\tunsigned long reg)\n{\n\treturn readl(qspi->base + reg);\n}\n\nstatic inline void ti_qspi_write(struct ti_qspi *qspi,\n\t\tunsigned long val, unsigned long reg)\n{\n\twritel(val, qspi->base + reg);\n}\n\nstatic int ti_qspi_setup(struct spi_device *spi)\n{\n\tstruct ti_qspi\t*qspi = spi_master_get_devdata(spi->master);\n\tint ret;\n\n\tif (spi->master->busy) {\n\t\tdev_dbg(qspi->dev, \"master busy doing other transfers\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!qspi->master->max_speed_hz) {\n\t\tdev_err(qspi->dev, \"spi max frequency not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspi->max_speed_hz = min(spi->max_speed_hz, qspi->master->max_speed_hz);\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(qspi->dev, \"pm_runtime_get_sync() failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tret = pm_runtime_put_autosuspend(qspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(qspi->dev, \"pm_runtime_put_autosuspend() failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ti_qspi_setup_clk(struct ti_qspi *qspi, u32 speed_hz)\n{\n\tstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\n\tint clk_div;\n\tu32 clk_ctrl_reg, clk_rate, clk_ctrl_new;\n\n\tclk_rate = clk_get_rate(qspi->fclk);\n\tclk_div = DIV_ROUND_UP(clk_rate, speed_hz) - 1;\n\tclk_div = clamp(clk_div, 0, QSPI_CLK_DIV_MAX);\n\tdev_dbg(qspi->dev, \"hz: %d, clock divider %d\\n\", speed_hz, clk_div);\n\n\tpm_runtime_resume_and_get(qspi->dev);\n\n\tclk_ctrl_new = QSPI_CLK_EN | clk_div;\n\tif (ctx_reg->clkctrl != clk_ctrl_new) {\n\t\tclk_ctrl_reg = ti_qspi_read(qspi, QSPI_SPI_CLOCK_CNTRL_REG);\n\n\t\tclk_ctrl_reg &= ~QSPI_CLK_EN;\n\n\t\t \n\t\tti_qspi_write(qspi, clk_ctrl_reg, QSPI_SPI_CLOCK_CNTRL_REG);\n\n\t\t \n\t\tti_qspi_write(qspi, clk_ctrl_new, QSPI_SPI_CLOCK_CNTRL_REG);\n\t\tctx_reg->clkctrl = clk_ctrl_new;\n\t}\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n}\n\nstatic void ti_qspi_restore_ctx(struct ti_qspi *qspi)\n{\n\tstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\n\n\tti_qspi_write(qspi, ctx_reg->clkctrl, QSPI_SPI_CLOCK_CNTRL_REG);\n}\n\nstatic inline u32 qspi_is_busy(struct ti_qspi *qspi)\n{\n\tu32 stat;\n\tunsigned long timeout = jiffies + QSPI_COMPLETION_TIMEOUT;\n\n\tstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\n\twhile ((stat & BUSY) && time_after(timeout, jiffies)) {\n\t\tcpu_relax();\n\t\tstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\n\t}\n\n\tWARN(stat & BUSY, \"qspi busy\\n\");\n\treturn stat & BUSY;\n}\n\nstatic inline int ti_qspi_poll_wc(struct ti_qspi *qspi)\n{\n\tu32 stat;\n\tunsigned long timeout = jiffies + QSPI_COMPLETION_TIMEOUT;\n\n\tdo {\n\t\tstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\n\t\tif (stat & WC)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (time_after(timeout, jiffies));\n\n\tstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\n\tif (stat & WC)\n\t\treturn 0;\n\treturn  -ETIMEDOUT;\n}\n\nstatic int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t,\n\t\t\t  int count)\n{\n\tint wlen, xfer_len;\n\tunsigned int cmd;\n\tconst u8 *txbuf;\n\tu32 data;\n\n\ttxbuf = t->tx_buf;\n\tcmd = qspi->cmd | QSPI_WR_SNGL;\n\twlen = t->bits_per_word >> 3;\t \n\txfer_len = wlen;\n\n\twhile (count) {\n\t\tif (qspi_is_busy(qspi))\n\t\t\treturn -EBUSY;\n\n\t\tswitch (wlen) {\n\t\tcase 1:\n\t\t\tdev_dbg(qspi->dev, \"tx cmd %08x dc %08x data %02x\\n\",\n\t\t\t\t\tcmd, qspi->dc, *txbuf);\n\t\t\tif (count >= QSPI_WLEN_MAX_BYTES) {\n\t\t\t\tu32 *txp = (u32 *)txbuf;\n\n\t\t\t\tdata = cpu_to_be32(*txp++);\n\t\t\t\twritel(data, qspi->base +\n\t\t\t\t       QSPI_SPI_DATA_REG_3);\n\t\t\t\tdata = cpu_to_be32(*txp++);\n\t\t\t\twritel(data, qspi->base +\n\t\t\t\t       QSPI_SPI_DATA_REG_2);\n\t\t\t\tdata = cpu_to_be32(*txp++);\n\t\t\t\twritel(data, qspi->base +\n\t\t\t\t       QSPI_SPI_DATA_REG_1);\n\t\t\t\tdata = cpu_to_be32(*txp++);\n\t\t\t\twritel(data, qspi->base +\n\t\t\t\t       QSPI_SPI_DATA_REG);\n\t\t\t\txfer_len = QSPI_WLEN_MAX_BYTES;\n\t\t\t\tcmd |= QSPI_WLEN(QSPI_WLEN_MAX_BITS);\n\t\t\t} else {\n\t\t\t\twriteb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);\n\t\t\t\tcmd = qspi->cmd | QSPI_WR_SNGL;\n\t\t\t\txfer_len = wlen;\n\t\t\t\tcmd |= QSPI_WLEN(wlen);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_dbg(qspi->dev, \"tx cmd %08x dc %08x data %04x\\n\",\n\t\t\t\t\tcmd, qspi->dc, *txbuf);\n\t\t\twritew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdev_dbg(qspi->dev, \"tx cmd %08x dc %08x data %08x\\n\",\n\t\t\t\t\tcmd, qspi->dc, *txbuf);\n\t\t\twritel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\n\t\t\tbreak;\n\t\t}\n\n\t\tti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\n\t\tif (ti_qspi_poll_wc(qspi)) {\n\t\t\tdev_err(qspi->dev, \"write timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\ttxbuf += xfer_len;\n\t\tcount -= xfer_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t,\n\t\t\t int count)\n{\n\tint wlen;\n\tunsigned int cmd;\n\tu32 rx;\n\tu8 rxlen, rx_wlen;\n\tu8 *rxbuf;\n\n\trxbuf = t->rx_buf;\n\tcmd = qspi->cmd;\n\tswitch (t->rx_nbits) {\n\tcase SPI_NBITS_DUAL:\n\t\tcmd |= QSPI_RD_DUAL;\n\t\tbreak;\n\tcase SPI_NBITS_QUAD:\n\t\tcmd |= QSPI_RD_QUAD;\n\t\tbreak;\n\tdefault:\n\t\tcmd |= QSPI_RD_SNGL;\n\t\tbreak;\n\t}\n\twlen = t->bits_per_word >> 3;\t \n\trx_wlen = wlen;\n\n\twhile (count) {\n\t\tdev_dbg(qspi->dev, \"rx cmd %08x dc %08x\\n\", cmd, qspi->dc);\n\t\tif (qspi_is_busy(qspi))\n\t\t\treturn -EBUSY;\n\n\t\tswitch (wlen) {\n\t\tcase 1:\n\t\t\t \n\t\t\tif (count >= QSPI_WLEN_MAX_BYTES) {\n\t\t\t\trxlen = QSPI_WLEN_MAX_BYTES;\n\t\t\t} else {\n\t\t\t\trxlen = min(count, 4);\n\t\t\t}\n\t\t\trx_wlen = rxlen << 3;\n\t\t\tcmd &= ~QSPI_WLEN_MASK;\n\t\t\tcmd |= QSPI_WLEN(rx_wlen);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trxlen = wlen;\n\t\t\tbreak;\n\t\t}\n\n\t\tti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\n\t\tif (ti_qspi_poll_wc(qspi)) {\n\t\t\tdev_err(qspi->dev, \"read timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tswitch (wlen) {\n\t\tcase 1:\n\t\t\t \n\t\t\tif (count >= QSPI_WLEN_MAX_BYTES) {\n\t\t\t\tu32 *rxp = (u32 *) rxbuf;\n\t\t\t\trx = readl(qspi->base + QSPI_SPI_DATA_REG_3);\n\t\t\t\t*rxp++ = be32_to_cpu(rx);\n\t\t\t\trx = readl(qspi->base + QSPI_SPI_DATA_REG_2);\n\t\t\t\t*rxp++ = be32_to_cpu(rx);\n\t\t\t\trx = readl(qspi->base + QSPI_SPI_DATA_REG_1);\n\t\t\t\t*rxp++ = be32_to_cpu(rx);\n\t\t\t\trx = readl(qspi->base + QSPI_SPI_DATA_REG);\n\t\t\t\t*rxp++ = be32_to_cpu(rx);\n\t\t\t} else {\n\t\t\t\tu8 *rxp = rxbuf;\n\t\t\t\trx = readl(qspi->base + QSPI_SPI_DATA_REG);\n\t\t\t\tif (rx_wlen >= 8)\n\t\t\t\t\t*rxp++ = rx >> (rx_wlen - 8);\n\t\t\t\tif (rx_wlen >= 16)\n\t\t\t\t\t*rxp++ = rx >> (rx_wlen - 16);\n\t\t\t\tif (rx_wlen >= 24)\n\t\t\t\t\t*rxp++ = rx >> (rx_wlen - 24);\n\t\t\t\tif (rx_wlen >= 32)\n\t\t\t\t\t*rxp++ = rx;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);\n\t\t\tbreak;\n\t\t}\n\t\trxbuf += rxlen;\n\t\tcount -= rxlen;\n\t}\n\n\treturn 0;\n}\n\nstatic int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t,\n\t\t\t     int count)\n{\n\tint ret;\n\n\tif (t->tx_buf) {\n\t\tret = qspi_write_msg(qspi, t, count);\n\t\tif (ret) {\n\t\t\tdev_dbg(qspi->dev, \"Error while writing\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (t->rx_buf) {\n\t\tret = qspi_read_msg(qspi, t, count);\n\t\tif (ret) {\n\t\t\tdev_dbg(qspi->dev, \"Error while reading\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ti_qspi_dma_callback(void *param)\n{\n\tstruct ti_qspi *qspi = param;\n\n\tcomplete(&qspi->transfer_complete);\n}\n\nstatic int ti_qspi_dma_xfer(struct ti_qspi *qspi, dma_addr_t dma_dst,\n\t\t\t    dma_addr_t dma_src, size_t len)\n{\n\tstruct dma_chan *chan = qspi->rx_chan;\n\tdma_cookie_t cookie;\n\tenum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tstruct dma_async_tx_descriptor *tx;\n\tint ret;\n\tunsigned long time_left;\n\n\ttx = dmaengine_prep_dma_memcpy(chan, dma_dst, dma_src, len, flags);\n\tif (!tx) {\n\t\tdev_err(qspi->dev, \"device_prep_dma_memcpy error\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttx->callback = ti_qspi_dma_callback;\n\ttx->callback_param = qspi;\n\tcookie = tx->tx_submit(tx);\n\treinit_completion(&qspi->transfer_complete);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(qspi->dev, \"dma_submit_error %d\\n\", cookie);\n\t\treturn -EIO;\n\t}\n\n\tdma_async_issue_pending(chan);\n\ttime_left = wait_for_completion_timeout(&qspi->transfer_complete,\n\t\t\t\t\t  msecs_to_jiffies(len));\n\tif (time_left == 0) {\n\t\tdmaengine_terminate_sync(chan);\n\t\tdev_err(qspi->dev, \"DMA wait_for_completion_timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_qspi_dma_bounce_buffer(struct ti_qspi *qspi, loff_t offs,\n\t\t\t\t     void *to, size_t readsize)\n{\n\tdma_addr_t dma_src = qspi->mmap_phys_base + offs;\n\tint ret = 0;\n\n\t \n\twhile (readsize != 0) {\n\t\tsize_t xfer_len = min_t(size_t, QSPI_DMA_BUFFER_SIZE,\n\t\t\t\t\treadsize);\n\n\t\tret = ti_qspi_dma_xfer(qspi, qspi->rx_bb_dma_addr,\n\t\t\t\t       dma_src, xfer_len);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tmemcpy(to, qspi->rx_bb_addr, xfer_len);\n\t\treadsize -= xfer_len;\n\t\tdma_src += xfer_len;\n\t\tto += xfer_len;\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_qspi_dma_xfer_sg(struct ti_qspi *qspi, struct sg_table rx_sg,\n\t\t\t       loff_t from)\n{\n\tstruct scatterlist *sg;\n\tdma_addr_t dma_src = qspi->mmap_phys_base + from;\n\tdma_addr_t dma_dst;\n\tint i, len, ret;\n\n\tfor_each_sg(rx_sg.sgl, sg, rx_sg.nents, i) {\n\t\tdma_dst = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\t\tret = ti_qspi_dma_xfer(qspi, dma_dst, dma_src, len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdma_src += len;\n\t}\n\n\treturn 0;\n}\n\nstatic void ti_qspi_enable_memory_map(struct spi_device *spi)\n{\n\tstruct ti_qspi  *qspi = spi_master_get_devdata(spi->master);\n\n\tti_qspi_write(qspi, MM_SWITCH, QSPI_SPI_SWITCH_REG);\n\tif (qspi->ctrl_base) {\n\t\tregmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,\n\t\t\t\t   MEM_CS_MASK,\n\t\t\t\t   MEM_CS_EN(spi_get_chipselect(spi, 0)));\n\t}\n\tqspi->mmap_enabled = true;\n\tqspi->current_cs = spi_get_chipselect(spi, 0);\n}\n\nstatic void ti_qspi_disable_memory_map(struct spi_device *spi)\n{\n\tstruct ti_qspi  *qspi = spi_master_get_devdata(spi->master);\n\n\tti_qspi_write(qspi, 0, QSPI_SPI_SWITCH_REG);\n\tif (qspi->ctrl_base)\n\t\tregmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,\n\t\t\t\t   MEM_CS_MASK, 0);\n\tqspi->mmap_enabled = false;\n\tqspi->current_cs = -1;\n}\n\nstatic void ti_qspi_setup_mmap_read(struct spi_device *spi, u8 opcode,\n\t\t\t\t    u8 data_nbits, u8 addr_width,\n\t\t\t\t    u8 dummy_bytes)\n{\n\tstruct ti_qspi  *qspi = spi_master_get_devdata(spi->master);\n\tu32 memval = opcode;\n\n\tswitch (data_nbits) {\n\tcase SPI_NBITS_QUAD:\n\t\tmemval |= QSPI_SETUP_RD_QUAD;\n\t\tbreak;\n\tcase SPI_NBITS_DUAL:\n\t\tmemval |= QSPI_SETUP_RD_DUAL;\n\t\tbreak;\n\tdefault:\n\t\tmemval |= QSPI_SETUP_RD_NORMAL;\n\t\tbreak;\n\t}\n\tmemval |= ((addr_width - 1) << QSPI_SETUP_ADDR_SHIFT |\n\t\t   dummy_bytes << QSPI_SETUP_DUMMY_SHIFT);\n\tti_qspi_write(qspi, memval,\n\t\t      QSPI_SPI_SETUP_REG(spi_get_chipselect(spi, 0)));\n}\n\nstatic int ti_qspi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct ti_qspi *qspi = spi_controller_get_devdata(mem->spi->master);\n\tsize_t max_len;\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tif (op->addr.val < qspi->mmap_size) {\n\t\t\t \n\t\t\tif (op->addr.val + op->data.nbytes > qspi->mmap_size) {\n\t\t\t\tmax_len = qspi->mmap_size - op->addr.val;\n\t\t\t\top->data.nbytes = min((size_t) op->data.nbytes,\n\t\t\t\t\t\t      max_len);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmax_len = QSPI_FRAME;\n\t\t\tmax_len -= 1 + op->addr.nbytes + op->dummy.nbytes;\n\t\t\top->data.nbytes = min((size_t) op->data.nbytes,\n\t\t\t\t\t      max_len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_qspi_exec_mem_op(struct spi_mem *mem,\n\t\t\t       const struct spi_mem_op *op)\n{\n\tstruct ti_qspi *qspi = spi_master_get_devdata(mem->spi->master);\n\tu32 from = 0;\n\tint ret = 0;\n\n\t \n\tif (!op->data.nbytes || op->data.dir != SPI_MEM_DATA_IN ||\n\t    !op->addr.nbytes || op->addr.nbytes > 4)\n\t\treturn -ENOTSUPP;\n\n\t \n\tfrom = op->addr.val;\n\tif (from + op->data.nbytes > qspi->mmap_size)\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&qspi->list_lock);\n\n\tif (!qspi->mmap_enabled || qspi->current_cs != spi_get_chipselect(mem->spi, 0)) {\n\t\tti_qspi_setup_clk(qspi, mem->spi->max_speed_hz);\n\t\tti_qspi_enable_memory_map(mem->spi);\n\t}\n\tti_qspi_setup_mmap_read(mem->spi, op->cmd.opcode, op->data.buswidth,\n\t\t\t\top->addr.nbytes, op->dummy.nbytes);\n\n\tif (qspi->rx_chan) {\n\t\tstruct sg_table sgt;\n\n\t\tif (virt_addr_valid(op->data.buf.in) &&\n\t\t    !spi_controller_dma_map_mem_op_data(mem->spi->master, op,\n\t\t\t\t\t\t\t&sgt)) {\n\t\t\tret = ti_qspi_dma_xfer_sg(qspi, sgt, from);\n\t\t\tspi_controller_dma_unmap_mem_op_data(mem->spi->master,\n\t\t\t\t\t\t\t     op, &sgt);\n\t\t} else {\n\t\t\tret = ti_qspi_dma_bounce_buffer(qspi, from,\n\t\t\t\t\t\t\top->data.buf.in,\n\t\t\t\t\t\t\top->data.nbytes);\n\t\t}\n\t} else {\n\t\tmemcpy_fromio(op->data.buf.in, qspi->mmap_base + from,\n\t\t\t      op->data.nbytes);\n\t}\n\n\tmutex_unlock(&qspi->list_lock);\n\n\treturn ret;\n}\n\nstatic const struct spi_controller_mem_ops ti_qspi_mem_ops = {\n\t.exec_op = ti_qspi_exec_mem_op,\n\t.adjust_op_size = ti_qspi_adjust_op_size,\n};\n\nstatic int ti_qspi_start_transfer_one(struct spi_master *master,\n\t\tstruct spi_message *m)\n{\n\tstruct ti_qspi *qspi = spi_master_get_devdata(master);\n\tstruct spi_device *spi = m->spi;\n\tstruct spi_transfer *t;\n\tint status = 0, ret;\n\tunsigned int frame_len_words, transfer_len_words;\n\tint wlen;\n\n\t \n\tqspi->dc = 0;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tqspi->dc |= QSPI_CKPHA(spi_get_chipselect(spi, 0));\n\tif (spi->mode & SPI_CPOL)\n\t\tqspi->dc |= QSPI_CKPOL(spi_get_chipselect(spi, 0));\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tqspi->dc |= QSPI_CSPOL(spi_get_chipselect(spi, 0));\n\n\tframe_len_words = 0;\n\tlist_for_each_entry(t, &m->transfers, transfer_list)\n\t\tframe_len_words += t->len / (t->bits_per_word >> 3);\n\tframe_len_words = min_t(unsigned int, frame_len_words, QSPI_FRAME);\n\n\t \n\tqspi->cmd = 0;\n\tqspi->cmd |= QSPI_EN_CS(spi_get_chipselect(spi, 0));\n\tqspi->cmd |= QSPI_FLEN(frame_len_words);\n\n\tti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);\n\n\tmutex_lock(&qspi->list_lock);\n\n\tif (qspi->mmap_enabled)\n\t\tti_qspi_disable_memory_map(spi);\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tqspi->cmd = ((qspi->cmd & ~QSPI_WLEN_MASK) |\n\t\t\t     QSPI_WLEN(t->bits_per_word));\n\n\t\twlen = t->bits_per_word >> 3;\n\t\ttransfer_len_words = min(t->len / wlen, frame_len_words);\n\n\t\tti_qspi_setup_clk(qspi, t->speed_hz);\n\t\tret = qspi_transfer_msg(qspi, t, transfer_len_words * wlen);\n\t\tif (ret) {\n\t\t\tdev_dbg(qspi->dev, \"transfer message failed\\n\");\n\t\t\tmutex_unlock(&qspi->list_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tm->actual_length += transfer_len_words * wlen;\n\t\tframe_len_words -= transfer_len_words;\n\t\tif (frame_len_words == 0)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&qspi->list_lock);\n\n\tti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);\n\tm->status = status;\n\tspi_finalize_current_message(master);\n\n\treturn status;\n}\n\nstatic int ti_qspi_runtime_resume(struct device *dev)\n{\n\tstruct ti_qspi      *qspi;\n\n\tqspi = dev_get_drvdata(dev);\n\tti_qspi_restore_ctx(qspi);\n\n\treturn 0;\n}\n\nstatic void ti_qspi_dma_cleanup(struct ti_qspi *qspi)\n{\n\tif (qspi->rx_bb_addr)\n\t\tdma_free_coherent(qspi->dev, QSPI_DMA_BUFFER_SIZE,\n\t\t\t\t  qspi->rx_bb_addr,\n\t\t\t\t  qspi->rx_bb_dma_addr);\n\n\tif (qspi->rx_chan)\n\t\tdma_release_channel(qspi->rx_chan);\n}\n\nstatic const struct of_device_id ti_qspi_match[] = {\n\t{.compatible = \"ti,dra7xxx-qspi\" },\n\t{.compatible = \"ti,am4372-qspi\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_qspi_match);\n\nstatic int ti_qspi_probe(struct platform_device *pdev)\n{\n\tstruct  ti_qspi *qspi;\n\tstruct spi_master *master;\n\tstruct resource         *r, *res_mmap;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 max_freq;\n\tint ret = 0, num_cs, irq;\n\tdma_cap_mask_t mask;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*qspi));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD;\n\n\tmaster->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\tmaster->setup = ti_qspi_setup;\n\tmaster->auto_runtime_pm = true;\n\tmaster->transfer_one_message = ti_qspi_start_transfer_one;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |\n\t\t\t\t     SPI_BPW_MASK(8);\n\tmaster->mem_ops = &ti_qspi_mem_ops;\n\n\tif (!of_property_read_u32(np, \"num-cs\", &num_cs))\n\t\tmaster->num_chipselect = num_cs;\n\n\tqspi = spi_master_get_devdata(master);\n\tqspi->master = master;\n\tqspi->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, qspi);\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qspi_base\");\n\tif (r == NULL) {\n\t\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (r == NULL) {\n\t\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_master;\n\t\t}\n\t}\n\n\tres_mmap = platform_get_resource_byname(pdev,\n\t\t\tIORESOURCE_MEM, \"qspi_mmap\");\n\tif (res_mmap == NULL) {\n\t\tres_mmap = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\tif (res_mmap == NULL) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"memory mapped resource not required\\n\");\n\t\t}\n\t}\n\n\tif (res_mmap)\n\t\tqspi->mmap_size = resource_size(res_mmap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto free_master;\n\t}\n\n\tmutex_init(&qspi->list_lock);\n\n\tqspi->base = devm_ioremap_resource(&pdev->dev, r);\n\tif (IS_ERR(qspi->base)) {\n\t\tret = PTR_ERR(qspi->base);\n\t\tgoto free_master;\n\t}\n\n\n\tif (of_property_read_bool(np, \"syscon-chipselects\")) {\n\t\tqspi->ctrl_base =\n\t\tsyscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\"syscon-chipselects\");\n\t\tif (IS_ERR(qspi->ctrl_base)) {\n\t\t\tret = PTR_ERR(qspi->ctrl_base);\n\t\t\tgoto free_master;\n\t\t}\n\t\tret = of_property_read_u32_index(np,\n\t\t\t\t\t\t \"syscon-chipselects\",\n\t\t\t\t\t\t 1, &qspi->ctrl_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"couldn't get ctrl_mod reg index\\n\");\n\t\t\tgoto free_master;\n\t\t}\n\t}\n\n\tqspi->fclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(qspi->fclk)) {\n\t\tret = PTR_ERR(qspi->fclk);\n\t\tdev_err(&pdev->dev, \"could not get clk: %d\\n\", ret);\n\t}\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, QSPI_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_enable(&pdev->dev);\n\n\tif (!of_property_read_u32(np, \"spi-max-frequency\", &max_freq))\n\t\tmaster->max_speed_hz = max_freq;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tqspi->rx_chan = dma_request_chan_by_mask(&mask);\n\tif (IS_ERR(qspi->rx_chan)) {\n\t\tdev_err(qspi->dev,\n\t\t\t\"No Rx DMA available, trying mmap mode\\n\");\n\t\tqspi->rx_chan = NULL;\n\t\tret = 0;\n\t\tgoto no_dma;\n\t}\n\tqspi->rx_bb_addr = dma_alloc_coherent(qspi->dev,\n\t\t\t\t\t      QSPI_DMA_BUFFER_SIZE,\n\t\t\t\t\t      &qspi->rx_bb_dma_addr,\n\t\t\t\t\t      GFP_KERNEL | GFP_DMA);\n\tif (!qspi->rx_bb_addr) {\n\t\tdev_err(qspi->dev,\n\t\t\t\"dma_alloc_coherent failed, using PIO mode\\n\");\n\t\tdma_release_channel(qspi->rx_chan);\n\t\tgoto no_dma;\n\t}\n\tmaster->dma_rx = qspi->rx_chan;\n\tinit_completion(&qspi->transfer_complete);\n\tif (res_mmap)\n\t\tqspi->mmap_phys_base = (dma_addr_t)res_mmap->start;\n\nno_dma:\n\tif (!qspi->rx_chan && res_mmap) {\n\t\tqspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);\n\t\tif (IS_ERR(qspi->mmap_base)) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"mmap failed with error %ld using PIO mode\\n\",\n\t\t\t\t PTR_ERR(qspi->mmap_base));\n\t\t\tqspi->mmap_base = NULL;\n\t\t\tmaster->mem_ops = NULL;\n\t\t}\n\t}\n\tqspi->mmap_enabled = false;\n\tqspi->current_cs = -1;\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (!ret)\n\t\treturn 0;\n\n\tti_qspi_dma_cleanup(qspi);\n\n\tpm_runtime_disable(&pdev->dev);\nfree_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic int ti_qspi_remove(struct platform_device *pdev)\n{\n\tstruct ti_qspi *qspi = platform_get_drvdata(pdev);\n\tint rc;\n\n\trc = spi_master_suspend(qspi->master);\n\tif (rc)\n\t\treturn rc;\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tti_qspi_dma_cleanup(qspi);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ti_qspi_pm_ops = {\n\t.runtime_resume = ti_qspi_runtime_resume,\n};\n\nstatic struct platform_driver ti_qspi_driver = {\n\t.probe\t= ti_qspi_probe,\n\t.remove = ti_qspi_remove,\n\t.driver = {\n\t\t.name\t= \"ti-qspi\",\n\t\t.pm =   &ti_qspi_pm_ops,\n\t\t.of_match_table = ti_qspi_match,\n\t}\n};\n\nmodule_platform_driver(ti_qspi_driver);\n\nMODULE_AUTHOR(\"Sourav Poddar <sourav.poddar@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI QSPI controller driver\");\nMODULE_ALIAS(\"platform:ti-qspi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}