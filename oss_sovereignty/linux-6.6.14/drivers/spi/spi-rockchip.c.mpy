{
  "module_name": "spi-rockchip.c",
  "hash_id": "8122927604c129e81dea55656a01149c6f78d277a2e16a42e02f3385f3ba81d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n\n#define DRIVER_NAME \"rockchip-spi\"\n\n#define ROCKCHIP_SPI_CLR_BITS(reg, bits) \\\n\t\twritel_relaxed(readl_relaxed(reg) & ~(bits), reg)\n#define ROCKCHIP_SPI_SET_BITS(reg, bits) \\\n\t\twritel_relaxed(readl_relaxed(reg) | (bits), reg)\n\n \n#define ROCKCHIP_SPI_CTRLR0\t\t\t0x0000\n#define ROCKCHIP_SPI_CTRLR1\t\t\t0x0004\n#define ROCKCHIP_SPI_SSIENR\t\t\t0x0008\n#define ROCKCHIP_SPI_SER\t\t\t0x000c\n#define ROCKCHIP_SPI_BAUDR\t\t\t0x0010\n#define ROCKCHIP_SPI_TXFTLR\t\t\t0x0014\n#define ROCKCHIP_SPI_RXFTLR\t\t\t0x0018\n#define ROCKCHIP_SPI_TXFLR\t\t\t0x001c\n#define ROCKCHIP_SPI_RXFLR\t\t\t0x0020\n#define ROCKCHIP_SPI_SR\t\t\t\t0x0024\n#define ROCKCHIP_SPI_IPR\t\t\t0x0028\n#define ROCKCHIP_SPI_IMR\t\t\t0x002c\n#define ROCKCHIP_SPI_ISR\t\t\t0x0030\n#define ROCKCHIP_SPI_RISR\t\t\t0x0034\n#define ROCKCHIP_SPI_ICR\t\t\t0x0038\n#define ROCKCHIP_SPI_DMACR\t\t\t0x003c\n#define ROCKCHIP_SPI_DMATDLR\t\t\t0x0040\n#define ROCKCHIP_SPI_DMARDLR\t\t\t0x0044\n#define ROCKCHIP_SPI_VERSION\t\t\t0x0048\n#define ROCKCHIP_SPI_TXDR\t\t\t0x0400\n#define ROCKCHIP_SPI_RXDR\t\t\t0x0800\n\n \n#define CR0_DFS_OFFSET\t\t\t\t0\n#define CR0_DFS_4BIT\t\t\t\t0x0\n#define CR0_DFS_8BIT\t\t\t\t0x1\n#define CR0_DFS_16BIT\t\t\t\t0x2\n\n#define CR0_CFS_OFFSET\t\t\t\t2\n\n#define CR0_SCPH_OFFSET\t\t\t\t6\n\n#define CR0_SCPOL_OFFSET\t\t\t7\n\n#define CR0_CSM_OFFSET\t\t\t\t8\n#define CR0_CSM_KEEP\t\t\t\t0x0\n \n#define CR0_CSM_HALF\t\t\t\t0X1\n \n#define CR0_CSM_ONE\t\t\t\t\t0x2\n\n \n#define CR0_SSD_OFFSET\t\t\t\t10\n \n#define CR0_SSD_HALF\t\t\t\t0x0\n \n#define CR0_SSD_ONE\t\t\t\t\t0x1\n\n#define CR0_EM_OFFSET\t\t\t\t11\n#define CR0_EM_LITTLE\t\t\t\t0x0\n#define CR0_EM_BIG\t\t\t\t\t0x1\n\n#define CR0_FBM_OFFSET\t\t\t\t12\n#define CR0_FBM_MSB\t\t\t\t\t0x0\n#define CR0_FBM_LSB\t\t\t\t\t0x1\n\n#define CR0_BHT_OFFSET\t\t\t\t13\n#define CR0_BHT_16BIT\t\t\t\t0x0\n#define CR0_BHT_8BIT\t\t\t\t0x1\n\n#define CR0_RSD_OFFSET\t\t\t\t14\n#define CR0_RSD_MAX\t\t\t\t0x3\n\n#define CR0_FRF_OFFSET\t\t\t\t16\n#define CR0_FRF_SPI\t\t\t\t\t0x0\n#define CR0_FRF_SSP\t\t\t\t\t0x1\n#define CR0_FRF_MICROWIRE\t\t\t0x2\n\n#define CR0_XFM_OFFSET\t\t\t\t18\n#define CR0_XFM_MASK\t\t\t\t(0x03 << SPI_XFM_OFFSET)\n#define CR0_XFM_TR\t\t\t\t\t0x0\n#define CR0_XFM_TO\t\t\t\t\t0x1\n#define CR0_XFM_RO\t\t\t\t\t0x2\n\n#define CR0_OPM_OFFSET\t\t\t\t20\n#define CR0_OPM_HOST\t\t\t\t0x0\n#define CR0_OPM_TARGET\t\t\t\t0x1\n\n#define CR0_SOI_OFFSET\t\t\t\t23\n\n#define CR0_MTM_OFFSET\t\t\t\t0x21\n\n \n#define SER_MASK\t\t\t\t\t0x3\n\n \n#define BAUDR_SCKDV_MIN\t\t\t\t2\n#define BAUDR_SCKDV_MAX\t\t\t\t65534\n\n \n#define SR_MASK\t\t\t\t\t\t0x3f\n#define SR_BUSY\t\t\t\t\t\t(1 << 0)\n#define SR_TF_FULL\t\t\t\t\t(1 << 1)\n#define SR_TF_EMPTY\t\t\t\t\t(1 << 2)\n#define SR_RF_EMPTY\t\t\t\t\t(1 << 3)\n#define SR_RF_FULL\t\t\t\t\t(1 << 4)\n#define SR_TARGET_TX_BUSY\t\t\t\t(1 << 5)\n\n \n#define INT_MASK\t\t\t\t\t0x1f\n#define INT_TF_EMPTY\t\t\t\t(1 << 0)\n#define INT_TF_OVERFLOW\t\t\t\t(1 << 1)\n#define INT_RF_UNDERFLOW\t\t\t(1 << 2)\n#define INT_RF_OVERFLOW\t\t\t\t(1 << 3)\n#define INT_RF_FULL\t\t\t\t(1 << 4)\n#define INT_CS_INACTIVE\t\t\t\t(1 << 6)\n\n \n#define ICR_MASK\t\t\t\t\t0x0f\n#define ICR_ALL\t\t\t\t\t\t(1 << 0)\n#define ICR_RF_UNDERFLOW\t\t\t(1 << 1)\n#define ICR_RF_OVERFLOW\t\t\t\t(1 << 2)\n#define ICR_TF_OVERFLOW\t\t\t\t(1 << 3)\n\n \n#define RF_DMA_EN\t\t\t\t\t(1 << 0)\n#define TF_DMA_EN\t\t\t\t\t(1 << 1)\n\n \n#define RXDMA\t\t\t\t\t(1 << 0)\n#define TXDMA\t\t\t\t\t(1 << 1)\n\n \n#define MAX_SCLK_OUT\t\t\t\t50000000U\n\n \n#define ROCKCHIP_SPI_MAX_TRANLEN\t\t0xffff\n\n \n#define ROCKCHIP_SPI_MAX_CS_NUM\t\t\t4\n#define ROCKCHIP_SPI_VER2_TYPE1\t\t\t0x05EC0002\n#define ROCKCHIP_SPI_VER2_TYPE2\t\t\t0x00110002\n\n#define ROCKCHIP_AUTOSUSPEND_TIMEOUT\t\t2000\n\nstruct rockchip_spi {\n\tstruct device *dev;\n\n\tstruct clk *spiclk;\n\tstruct clk *apb_pclk;\n\n\tvoid __iomem *regs;\n\tdma_addr_t dma_addr_rx;\n\tdma_addr_t dma_addr_tx;\n\n\tconst void *tx;\n\tvoid *rx;\n\tunsigned int tx_left;\n\tunsigned int rx_left;\n\n\tatomic_t state;\n\n\t \n\tu32 fifo_len;\n\t \n\tu32 freq;\n\n\tu8 n_bytes;\n\tu8 rsd;\n\n\tbool cs_asserted[ROCKCHIP_SPI_MAX_CS_NUM];\n\n\tbool target_abort;\n\tbool cs_inactive;  \n\tbool cs_high_supported;  \n\n\tstruct spi_transfer *xfer;  \n};\n\nstatic inline void spi_enable_chip(struct rockchip_spi *rs, bool enable)\n{\n\twritel_relaxed((enable ? 1U : 0U), rs->regs + ROCKCHIP_SPI_SSIENR);\n}\n\nstatic inline void wait_for_tx_idle(struct rockchip_spi *rs, bool target_mode)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(5);\n\n\tdo {\n\t\tif (target_mode) {\n\t\t\tif (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_TARGET_TX_BUSY) &&\n\t\t\t    !((readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY)))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY))\n\t\t\t\treturn;\n\t\t}\n\t} while (!time_after(jiffies, timeout));\n\n\tdev_warn(rs->dev, \"spi controller is in busy state!\\n\");\n}\n\nstatic u32 get_fifo_len(struct rockchip_spi *rs)\n{\n\tu32 ver;\n\n\tver = readl_relaxed(rs->regs + ROCKCHIP_SPI_VERSION);\n\n\tswitch (ver) {\n\tcase ROCKCHIP_SPI_VER2_TYPE1:\n\tcase ROCKCHIP_SPI_VER2_TYPE2:\n\t\treturn 64;\n\tdefault:\n\t\treturn 32;\n\t}\n}\n\nstatic void rockchip_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct spi_controller *ctlr = spi->controller;\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tbool cs_asserted = spi->mode & SPI_CS_HIGH ? enable : !enable;\n\n\t \n\tif (cs_asserted == rs->cs_asserted[spi_get_chipselect(spi, 0)])\n\t\treturn;\n\n\tif (cs_asserted) {\n\t\t \n\t\tpm_runtime_get_sync(rs->dev);\n\n\t\tif (spi_get_csgpiod(spi, 0))\n\t\t\tROCKCHIP_SPI_SET_BITS(rs->regs + ROCKCHIP_SPI_SER, 1);\n\t\telse\n\t\t\tROCKCHIP_SPI_SET_BITS(rs->regs + ROCKCHIP_SPI_SER,\n\t\t\t\t\t      BIT(spi_get_chipselect(spi, 0)));\n\t} else {\n\t\tif (spi_get_csgpiod(spi, 0))\n\t\t\tROCKCHIP_SPI_CLR_BITS(rs->regs + ROCKCHIP_SPI_SER, 1);\n\t\telse\n\t\t\tROCKCHIP_SPI_CLR_BITS(rs->regs + ROCKCHIP_SPI_SER,\n\t\t\t\t\t      BIT(spi_get_chipselect(spi, 0)));\n\n\t\t \n\t\tpm_runtime_put(rs->dev);\n\t}\n\n\trs->cs_asserted[spi_get_chipselect(spi, 0)] = cs_asserted;\n}\n\nstatic void rockchip_spi_handle_err(struct spi_controller *ctlr,\n\t\t\t\t    struct spi_message *msg)\n{\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\t \n\tspi_enable_chip(rs, false);\n\n\t \n\twritel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);\n\twritel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);\n\n\tif (atomic_read(&rs->state) & TXDMA)\n\t\tdmaengine_terminate_async(ctlr->dma_tx);\n\n\tif (atomic_read(&rs->state) & RXDMA)\n\t\tdmaengine_terminate_async(ctlr->dma_rx);\n}\n\nstatic void rockchip_spi_pio_writer(struct rockchip_spi *rs)\n{\n\tu32 tx_free = rs->fifo_len - readl_relaxed(rs->regs + ROCKCHIP_SPI_TXFLR);\n\tu32 words = min(rs->tx_left, tx_free);\n\n\trs->tx_left -= words;\n\tfor (; words; words--) {\n\t\tu32 txw;\n\n\t\tif (rs->n_bytes == 1)\n\t\t\ttxw = *(u8 *)rs->tx;\n\t\telse\n\t\t\ttxw = *(u16 *)rs->tx;\n\n\t\twritel_relaxed(txw, rs->regs + ROCKCHIP_SPI_TXDR);\n\t\trs->tx += rs->n_bytes;\n\t}\n}\n\nstatic void rockchip_spi_pio_reader(struct rockchip_spi *rs)\n{\n\tu32 words = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFLR);\n\tu32 rx_left = (rs->rx_left > words) ? rs->rx_left - words : 0;\n\n\t \n\tif (rx_left) {\n\t\tu32 ftl = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFTLR) + 1;\n\n\t\tif (rx_left < ftl) {\n\t\t\trx_left = ftl;\n\t\t\twords = rs->rx_left - rx_left;\n\t\t}\n\t}\n\n\trs->rx_left = rx_left;\n\tfor (; words; words--) {\n\t\tu32 rxw = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXDR);\n\n\t\tif (!rs->rx)\n\t\t\tcontinue;\n\n\t\tif (rs->n_bytes == 1)\n\t\t\t*(u8 *)rs->rx = (u8)rxw;\n\t\telse\n\t\t\t*(u16 *)rs->rx = (u16)rxw;\n\t\trs->rx += rs->n_bytes;\n\t}\n}\n\nstatic irqreturn_t rockchip_spi_isr(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctlr = dev_id;\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\t \n\tif (rs->cs_inactive && readl_relaxed(rs->regs + ROCKCHIP_SPI_IMR) & INT_CS_INACTIVE) {\n\t\tctlr->target_abort(ctlr);\n\t\twritel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);\n\t\twritel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (rs->tx_left)\n\t\trockchip_spi_pio_writer(rs);\n\n\trockchip_spi_pio_reader(rs);\n\tif (!rs->rx_left) {\n\t\tspi_enable_chip(rs, false);\n\t\twritel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);\n\t\twritel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);\n\t\tspi_finalize_current_transfer(ctlr);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rockchip_spi_prepare_irq(struct rockchip_spi *rs,\n\t\t\t\t    struct spi_controller *ctlr,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\trs->tx = xfer->tx_buf;\n\trs->rx = xfer->rx_buf;\n\trs->tx_left = rs->tx ? xfer->len / rs->n_bytes : 0;\n\trs->rx_left = xfer->len / rs->n_bytes;\n\n\twritel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);\n\n\tspi_enable_chip(rs, true);\n\n\tif (rs->tx_left)\n\t\trockchip_spi_pio_writer(rs);\n\n\tif (rs->cs_inactive)\n\t\twritel_relaxed(INT_RF_FULL | INT_CS_INACTIVE, rs->regs + ROCKCHIP_SPI_IMR);\n\telse\n\t\twritel_relaxed(INT_RF_FULL, rs->regs + ROCKCHIP_SPI_IMR);\n\n\t \n\treturn 1;\n}\n\nstatic void rockchip_spi_dma_rxcb(void *data)\n{\n\tstruct spi_controller *ctlr = data;\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tint state = atomic_fetch_andnot(RXDMA, &rs->state);\n\n\tif (state & TXDMA && !rs->target_abort)\n\t\treturn;\n\n\tif (rs->cs_inactive)\n\t\twritel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);\n\n\tspi_enable_chip(rs, false);\n\tspi_finalize_current_transfer(ctlr);\n}\n\nstatic void rockchip_spi_dma_txcb(void *data)\n{\n\tstruct spi_controller *ctlr = data;\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tint state = atomic_fetch_andnot(TXDMA, &rs->state);\n\n\tif (state & RXDMA && !rs->target_abort)\n\t\treturn;\n\n\t \n\twait_for_tx_idle(rs, ctlr->target);\n\n\tspi_enable_chip(rs, false);\n\tspi_finalize_current_transfer(ctlr);\n}\n\nstatic u32 rockchip_spi_calc_burst_size(u32 data_len)\n{\n\tu32 i;\n\n\t \n\tfor (i = 1; i < 8; i <<= 1) {\n\t\tif (data_len & i)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic int rockchip_spi_prepare_dma(struct rockchip_spi *rs,\n\t\tstruct spi_controller *ctlr, struct spi_transfer *xfer)\n{\n\tstruct dma_async_tx_descriptor *rxdesc, *txdesc;\n\n\tatomic_set(&rs->state, 0);\n\n\trs->tx = xfer->tx_buf;\n\trs->rx = xfer->rx_buf;\n\n\trxdesc = NULL;\n\tif (xfer->rx_buf) {\n\t\tstruct dma_slave_config rxconf = {\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_addr = rs->dma_addr_rx,\n\t\t\t.src_addr_width = rs->n_bytes,\n\t\t\t.src_maxburst = rockchip_spi_calc_burst_size(xfer->len / rs->n_bytes),\n\t\t};\n\n\t\tdmaengine_slave_config(ctlr->dma_rx, &rxconf);\n\n\t\trxdesc = dmaengine_prep_slave_sg(\n\t\t\t\tctlr->dma_rx,\n\t\t\t\txfer->rx_sg.sgl, xfer->rx_sg.nents,\n\t\t\t\tDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\n\t\tif (!rxdesc)\n\t\t\treturn -EINVAL;\n\n\t\trxdesc->callback = rockchip_spi_dma_rxcb;\n\t\trxdesc->callback_param = ctlr;\n\t}\n\n\ttxdesc = NULL;\n\tif (xfer->tx_buf) {\n\t\tstruct dma_slave_config txconf = {\n\t\t\t.direction = DMA_MEM_TO_DEV,\n\t\t\t.dst_addr = rs->dma_addr_tx,\n\t\t\t.dst_addr_width = rs->n_bytes,\n\t\t\t.dst_maxburst = rs->fifo_len / 4,\n\t\t};\n\n\t\tdmaengine_slave_config(ctlr->dma_tx, &txconf);\n\n\t\ttxdesc = dmaengine_prep_slave_sg(\n\t\t\t\tctlr->dma_tx,\n\t\t\t\txfer->tx_sg.sgl, xfer->tx_sg.nents,\n\t\t\t\tDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\n\t\tif (!txdesc) {\n\t\t\tif (rxdesc)\n\t\t\t\tdmaengine_terminate_sync(ctlr->dma_rx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttxdesc->callback = rockchip_spi_dma_txcb;\n\t\ttxdesc->callback_param = ctlr;\n\t}\n\n\t \n\tif (rxdesc) {\n\t\tatomic_or(RXDMA, &rs->state);\n\t\tctlr->dma_rx->cookie = dmaengine_submit(rxdesc);\n\t\tdma_async_issue_pending(ctlr->dma_rx);\n\t}\n\n\tif (rs->cs_inactive)\n\t\twritel_relaxed(INT_CS_INACTIVE, rs->regs + ROCKCHIP_SPI_IMR);\n\n\tspi_enable_chip(rs, true);\n\n\tif (txdesc) {\n\t\tatomic_or(TXDMA, &rs->state);\n\t\tdmaengine_submit(txdesc);\n\t\tdma_async_issue_pending(ctlr->dma_tx);\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int rockchip_spi_config(struct rockchip_spi *rs,\n\t\tstruct spi_device *spi, struct spi_transfer *xfer,\n\t\tbool use_dma, bool target_mode)\n{\n\tu32 cr0 = CR0_FRF_SPI  << CR0_FRF_OFFSET\n\t\t| CR0_BHT_8BIT << CR0_BHT_OFFSET\n\t\t| CR0_SSD_ONE  << CR0_SSD_OFFSET\n\t\t| CR0_EM_BIG   << CR0_EM_OFFSET;\n\tu32 cr1;\n\tu32 dmacr = 0;\n\n\tif (target_mode)\n\t\tcr0 |= CR0_OPM_TARGET << CR0_OPM_OFFSET;\n\trs->target_abort = false;\n\n\tcr0 |= rs->rsd << CR0_RSD_OFFSET;\n\tcr0 |= (spi->mode & 0x3U) << CR0_SCPH_OFFSET;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tcr0 |= CR0_FBM_LSB << CR0_FBM_OFFSET;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tcr0 |= BIT(spi_get_chipselect(spi, 0)) << CR0_SOI_OFFSET;\n\n\tif (xfer->rx_buf && xfer->tx_buf)\n\t\tcr0 |= CR0_XFM_TR << CR0_XFM_OFFSET;\n\telse if (xfer->rx_buf)\n\t\tcr0 |= CR0_XFM_RO << CR0_XFM_OFFSET;\n\telse if (use_dma)\n\t\tcr0 |= CR0_XFM_TO << CR0_XFM_OFFSET;\n\n\tswitch (xfer->bits_per_word) {\n\tcase 4:\n\t\tcr0 |= CR0_DFS_4BIT << CR0_DFS_OFFSET;\n\t\tcr1 = xfer->len - 1;\n\t\tbreak;\n\tcase 8:\n\t\tcr0 |= CR0_DFS_8BIT << CR0_DFS_OFFSET;\n\t\tcr1 = xfer->len - 1;\n\t\tbreak;\n\tcase 16:\n\t\tcr0 |= CR0_DFS_16BIT << CR0_DFS_OFFSET;\n\t\tcr1 = xfer->len / 2 - 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(rs->dev, \"unknown bits per word: %d\\n\",\n\t\t\txfer->bits_per_word);\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_dma) {\n\t\tif (xfer->tx_buf)\n\t\t\tdmacr |= TF_DMA_EN;\n\t\tif (xfer->rx_buf)\n\t\t\tdmacr |= RF_DMA_EN;\n\t}\n\n\twritel_relaxed(cr0, rs->regs + ROCKCHIP_SPI_CTRLR0);\n\twritel_relaxed(cr1, rs->regs + ROCKCHIP_SPI_CTRLR1);\n\n\t \n\tif ((xfer->len / rs->n_bytes) < rs->fifo_len)\n\t\twritel_relaxed(xfer->len / rs->n_bytes - 1, rs->regs + ROCKCHIP_SPI_RXFTLR);\n\telse\n\t\twritel_relaxed(rs->fifo_len / 2 - 1, rs->regs + ROCKCHIP_SPI_RXFTLR);\n\n\twritel_relaxed(rs->fifo_len / 2 - 1, rs->regs + ROCKCHIP_SPI_DMATDLR);\n\twritel_relaxed(rockchip_spi_calc_burst_size(xfer->len / rs->n_bytes) - 1,\n\t\t       rs->regs + ROCKCHIP_SPI_DMARDLR);\n\twritel_relaxed(dmacr, rs->regs + ROCKCHIP_SPI_DMACR);\n\n\t \n\twritel_relaxed(2 * DIV_ROUND_UP(rs->freq, 2 * xfer->speed_hz),\n\t\t\trs->regs + ROCKCHIP_SPI_BAUDR);\n\n\treturn 0;\n}\n\nstatic size_t rockchip_spi_max_transfer_size(struct spi_device *spi)\n{\n\treturn ROCKCHIP_SPI_MAX_TRANLEN;\n}\n\nstatic int rockchip_spi_target_abort(struct spi_controller *ctlr)\n{\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tu32 rx_fifo_left;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\t \n\tif (atomic_read(&rs->state) & RXDMA) {\n\t\tdmaengine_pause(ctlr->dma_rx);\n\t\tstatus = dmaengine_tx_status(ctlr->dma_rx, ctlr->dma_rx->cookie, &state);\n\t\tif (status == DMA_ERROR) {\n\t\t\trs->rx = rs->xfer->rx_buf;\n\t\t\trs->xfer->len = 0;\n\t\t\trx_fifo_left = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFLR);\n\t\t\tfor (; rx_fifo_left; rx_fifo_left--)\n\t\t\t\treadl_relaxed(rs->regs + ROCKCHIP_SPI_RXDR);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\trs->rx += rs->xfer->len - rs->n_bytes * state.residue;\n\t\t}\n\t}\n\n\t \n\tif (rs->rx) {\n\t\trx_fifo_left = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXFLR);\n\t\tfor (; rx_fifo_left; rx_fifo_left--) {\n\t\t\tu32 rxw = readl_relaxed(rs->regs + ROCKCHIP_SPI_RXDR);\n\n\t\t\tif (rs->n_bytes == 1)\n\t\t\t\t*(u8 *)rs->rx = (u8)rxw;\n\t\t\telse\n\t\t\t\t*(u16 *)rs->rx = (u16)rxw;\n\t\t\trs->rx += rs->n_bytes;\n\t\t}\n\t\trs->xfer->len = (unsigned int)(rs->rx - rs->xfer->rx_buf);\n\t}\n\nout:\n\tif (atomic_read(&rs->state) & RXDMA)\n\t\tdmaengine_terminate_sync(ctlr->dma_rx);\n\tif (atomic_read(&rs->state) & TXDMA)\n\t\tdmaengine_terminate_sync(ctlr->dma_tx);\n\tatomic_set(&rs->state, 0);\n\tspi_enable_chip(rs, false);\n\trs->target_abort = true;\n\tspi_finalize_current_transfer(ctlr);\n\n\treturn 0;\n}\n\nstatic int rockchip_spi_transfer_one(\n\t\tstruct spi_controller *ctlr,\n\t\tstruct spi_device *spi,\n\t\tstruct spi_transfer *xfer)\n{\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tint ret;\n\tbool use_dma;\n\n\t \n\tif (!xfer->len) {\n\t\tspi_finalize_current_transfer(ctlr);\n\t\treturn 1;\n\t}\n\n\tWARN_ON(readl_relaxed(rs->regs + ROCKCHIP_SPI_SSIENR) &&\n\t\t(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY));\n\n\tif (!xfer->tx_buf && !xfer->rx_buf) {\n\t\tdev_err(rs->dev, \"No buffer for transfer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xfer->len > ROCKCHIP_SPI_MAX_TRANLEN) {\n\t\tdev_err(rs->dev, \"Transfer is too long (%d)\\n\", xfer->len);\n\t\treturn -EINVAL;\n\t}\n\n\trs->n_bytes = xfer->bits_per_word <= 8 ? 1 : 2;\n\trs->xfer = xfer;\n\tuse_dma = ctlr->can_dma ? ctlr->can_dma(ctlr, spi, xfer) : false;\n\n\tret = rockchip_spi_config(rs, spi, xfer, use_dma, ctlr->target);\n\tif (ret)\n\t\treturn ret;\n\n\tif (use_dma)\n\t\treturn rockchip_spi_prepare_dma(rs, ctlr, xfer);\n\n\treturn rockchip_spi_prepare_irq(rs, ctlr, xfer);\n}\n\nstatic bool rockchip_spi_can_dma(struct spi_controller *ctlr,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *xfer)\n{\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\tunsigned int bytes_per_word = xfer->bits_per_word <= 8 ? 1 : 2;\n\n\t \n\treturn xfer->len / bytes_per_word >= rs->fifo_len;\n}\n\nstatic int rockchip_spi_setup(struct spi_device *spi)\n{\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(spi->controller);\n\tu32 cr0;\n\n\tif (!spi_get_csgpiod(spi, 0) && (spi->mode & SPI_CS_HIGH) && !rs->cs_high_supported) {\n\t\tdev_warn(&spi->dev, \"setup: non GPIO CS can't be active-high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(rs->dev);\n\n\tcr0 = readl_relaxed(rs->regs + ROCKCHIP_SPI_CTRLR0);\n\n\tcr0 &= ~(0x3 << CR0_SCPH_OFFSET);\n\tcr0 |= ((spi->mode & 0x3) << CR0_SCPH_OFFSET);\n\tif (spi->mode & SPI_CS_HIGH && spi_get_chipselect(spi, 0) <= 1)\n\t\tcr0 |= BIT(spi_get_chipselect(spi, 0)) << CR0_SOI_OFFSET;\n\telse if (spi_get_chipselect(spi, 0) <= 1)\n\t\tcr0 &= ~(BIT(spi_get_chipselect(spi, 0)) << CR0_SOI_OFFSET);\n\n\twritel_relaxed(cr0, rs->regs + ROCKCHIP_SPI_CTRLR0);\n\n\tpm_runtime_put(rs->dev);\n\n\treturn 0;\n}\n\nstatic int rockchip_spi_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct rockchip_spi *rs;\n\tstruct spi_controller *ctlr;\n\tstruct resource *mem;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 rsd_nsecs, num_cs;\n\tbool target_mode;\n\n\ttarget_mode = of_property_read_bool(np, \"spi-slave\");\n\n\tif (target_mode)\n\t\tctlr = spi_alloc_target(&pdev->dev,\n\t\t\t\tsizeof(struct rockchip_spi));\n\telse\n\t\tctlr = spi_alloc_host(&pdev->dev,\n\t\t\t\tsizeof(struct rockchip_spi));\n\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\trs = spi_controller_get_devdata(ctlr);\n\n\t \n\trs->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(rs->regs)) {\n\t\tret =  PTR_ERR(rs->regs);\n\t\tgoto err_put_ctlr;\n\t}\n\n\trs->apb_pclk = devm_clk_get(&pdev->dev, \"apb_pclk\");\n\tif (IS_ERR(rs->apb_pclk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get apb_pclk\\n\");\n\t\tret = PTR_ERR(rs->apb_pclk);\n\t\tgoto err_put_ctlr;\n\t}\n\n\trs->spiclk = devm_clk_get(&pdev->dev, \"spiclk\");\n\tif (IS_ERR(rs->spiclk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get spi_pclk\\n\");\n\t\tret = PTR_ERR(rs->spiclk);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tret = clk_prepare_enable(rs->apb_pclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable apb_pclk\\n\");\n\t\tgoto err_put_ctlr;\n\t}\n\n\tret = clk_prepare_enable(rs->spiclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable spi_clk\\n\");\n\t\tgoto err_disable_apbclk;\n\t}\n\n\tspi_enable_chip(rs, false);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_disable_spiclk;\n\n\tret = devm_request_threaded_irq(&pdev->dev, ret, rockchip_spi_isr, NULL,\n\t\t\tIRQF_ONESHOT, dev_name(&pdev->dev), ctlr);\n\tif (ret)\n\t\tgoto err_disable_spiclk;\n\n\trs->dev = &pdev->dev;\n\trs->freq = clk_get_rate(rs->spiclk);\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"rx-sample-delay-ns\",\n\t\t\t\t  &rsd_nsecs)) {\n\t\t \n\t\tu32 rsd = DIV_ROUND_CLOSEST(rsd_nsecs * (rs->freq >> 8),\n\t\t\t\t1000000000 >> 8);\n\t\tif (!rsd) {\n\t\t\tdev_warn(rs->dev, \"%u Hz are too slow to express %u ns delay\\n\",\n\t\t\t\t\trs->freq, rsd_nsecs);\n\t\t} else if (rsd > CR0_RSD_MAX) {\n\t\t\trsd = CR0_RSD_MAX;\n\t\t\tdev_warn(rs->dev, \"%u Hz are too fast to express %u ns delay, clamping at %u ns\\n\",\n\t\t\t\t\trs->freq, rsd_nsecs,\n\t\t\t\t\tCR0_RSD_MAX * 1000000000U / rs->freq);\n\t\t}\n\t\trs->rsd = rsd;\n\t}\n\n\trs->fifo_len = get_fifo_len(rs);\n\tif (!rs->fifo_len) {\n\t\tdev_err(&pdev->dev, \"Failed to get fifo length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_disable_spiclk;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, ROCKCHIP_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tctlr->auto_runtime_pm = true;\n\tctlr->bus_num = pdev->id;\n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP | SPI_LSB_FIRST;\n\tif (target_mode) {\n\t\tctlr->mode_bits |= SPI_NO_CS;\n\t\tctlr->target_abort = rockchip_spi_target_abort;\n\t} else {\n\t\tctlr->flags = SPI_CONTROLLER_GPIO_SS;\n\t\tctlr->max_native_cs = ROCKCHIP_SPI_MAX_CS_NUM;\n\t\t \n\t\tif (of_property_read_u32(np, \"num-cs\", &num_cs))\n\t\t\tnum_cs = 1;\n\t\tctlr->num_chipselect = num_cs;\n\t\tctlr->use_gpio_descriptors = true;\n\t}\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->bits_per_word_mask = SPI_BPW_MASK(16) | SPI_BPW_MASK(8) | SPI_BPW_MASK(4);\n\tctlr->min_speed_hz = rs->freq / BAUDR_SCKDV_MAX;\n\tctlr->max_speed_hz = min(rs->freq / BAUDR_SCKDV_MIN, MAX_SCLK_OUT);\n\n\tctlr->setup = rockchip_spi_setup;\n\tctlr->set_cs = rockchip_spi_set_cs;\n\tctlr->transfer_one = rockchip_spi_transfer_one;\n\tctlr->max_transfer_size = rockchip_spi_max_transfer_size;\n\tctlr->handle_err = rockchip_spi_handle_err;\n\n\tctlr->dma_tx = dma_request_chan(rs->dev, \"tx\");\n\tif (IS_ERR(ctlr->dma_tx)) {\n\t\t \n\t\tif (PTR_ERR(ctlr->dma_tx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_disable_pm_runtime;\n\t\t}\n\t\tdev_warn(rs->dev, \"Failed to request TX DMA channel\\n\");\n\t\tctlr->dma_tx = NULL;\n\t}\n\n\tctlr->dma_rx = dma_request_chan(rs->dev, \"rx\");\n\tif (IS_ERR(ctlr->dma_rx)) {\n\t\tif (PTR_ERR(ctlr->dma_rx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_free_dma_tx;\n\t\t}\n\t\tdev_warn(rs->dev, \"Failed to request RX DMA channel\\n\");\n\t\tctlr->dma_rx = NULL;\n\t}\n\n\tif (ctlr->dma_tx && ctlr->dma_rx) {\n\t\trs->dma_addr_tx = mem->start + ROCKCHIP_SPI_TXDR;\n\t\trs->dma_addr_rx = mem->start + ROCKCHIP_SPI_RXDR;\n\t\tctlr->can_dma = rockchip_spi_can_dma;\n\t}\n\n\tswitch (readl_relaxed(rs->regs + ROCKCHIP_SPI_VERSION)) {\n\tcase ROCKCHIP_SPI_VER2_TYPE2:\n\t\trs->cs_high_supported = true;\n\t\tctlr->mode_bits |= SPI_CS_HIGH;\n\t\tif (ctlr->can_dma && target_mode)\n\t\t\trs->cs_inactive = true;\n\t\telse\n\t\t\trs->cs_inactive = false;\n\t\tbreak;\n\tdefault:\n\t\trs->cs_inactive = false;\n\t\tbreak;\n\t}\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register controller\\n\");\n\t\tgoto err_free_dma_rx;\n\t}\n\n\treturn 0;\n\nerr_free_dma_rx:\n\tif (ctlr->dma_rx)\n\t\tdma_release_channel(ctlr->dma_rx);\nerr_free_dma_tx:\n\tif (ctlr->dma_tx)\n\t\tdma_release_channel(ctlr->dma_tx);\nerr_disable_pm_runtime:\n\tpm_runtime_disable(&pdev->dev);\nerr_disable_spiclk:\n\tclk_disable_unprepare(rs->spiclk);\nerr_disable_apbclk:\n\tclk_disable_unprepare(rs->apb_pclk);\nerr_put_ctlr:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic void rockchip_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = spi_controller_get(platform_get_drvdata(pdev));\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tclk_disable_unprepare(rs->spiclk);\n\tclk_disable_unprepare(rs->apb_pclk);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tif (ctlr->dma_tx)\n\t\tdma_release_channel(ctlr->dma_tx);\n\tif (ctlr->dma_rx)\n\t\tdma_release_channel(ctlr->dma_rx);\n\n\tspi_controller_put(ctlr);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rockchip_spi_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\tret = spi_controller_suspend(ctlr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tclk_disable_unprepare(rs->spiclk);\n\tclk_disable_unprepare(rs->apb_pclk);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int rockchip_spi_resume(struct device *dev)\n{\n\tint ret;\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = clk_prepare_enable(rs->apb_pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(rs->spiclk);\n\tif (ret < 0)\n\t\tclk_disable_unprepare(rs->apb_pclk);\n\n\tret = spi_controller_resume(ctlr);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(rs->spiclk);\n\t\tclk_disable_unprepare(rs->apb_pclk);\n\t}\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int rockchip_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\tclk_disable_unprepare(rs->spiclk);\n\tclk_disable_unprepare(rs->apb_pclk);\n\n\treturn 0;\n}\n\nstatic int rockchip_spi_runtime_resume(struct device *dev)\n{\n\tint ret;\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct rockchip_spi *rs = spi_controller_get_devdata(ctlr);\n\n\tret = clk_prepare_enable(rs->apb_pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(rs->spiclk);\n\tif (ret < 0)\n\t\tclk_disable_unprepare(rs->apb_pclk);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops rockchip_spi_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(rockchip_spi_suspend, rockchip_spi_resume)\n\tSET_RUNTIME_PM_OPS(rockchip_spi_runtime_suspend,\n\t\t\t   rockchip_spi_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id rockchip_spi_dt_match[] = {\n\t{ .compatible = \"rockchip,px30-spi\", },\n\t{ .compatible = \"rockchip,rk3036-spi\", },\n\t{ .compatible = \"rockchip,rk3066-spi\", },\n\t{ .compatible = \"rockchip,rk3188-spi\", },\n\t{ .compatible = \"rockchip,rk3228-spi\", },\n\t{ .compatible = \"rockchip,rk3288-spi\", },\n\t{ .compatible = \"rockchip,rk3308-spi\", },\n\t{ .compatible = \"rockchip,rk3328-spi\", },\n\t{ .compatible = \"rockchip,rk3368-spi\", },\n\t{ .compatible = \"rockchip,rk3399-spi\", },\n\t{ .compatible = \"rockchip,rv1108-spi\", },\n\t{ .compatible = \"rockchip,rv1126-spi\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rockchip_spi_dt_match);\n\nstatic struct platform_driver rockchip_spi_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm = &rockchip_spi_pm,\n\t\t.of_match_table = of_match_ptr(rockchip_spi_dt_match),\n\t},\n\t.probe = rockchip_spi_probe,\n\t.remove_new = rockchip_spi_remove,\n};\n\nmodule_platform_driver(rockchip_spi_driver);\n\nMODULE_AUTHOR(\"Addy Ke <addy.ke@rock-chips.com>\");\nMODULE_DESCRIPTION(\"ROCKCHIP SPI Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}