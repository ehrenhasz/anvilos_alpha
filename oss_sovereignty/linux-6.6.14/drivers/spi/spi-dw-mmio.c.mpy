{
  "module_name": "spi-dw-mmio.c",
  "hash_id": "d4f83ccd6e10af99daf7b097e88691a3fe66a46e1508e8957fedf8987de2eeb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-dw-mmio.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/scatterlist.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/acpi.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include \"spi-dw.h\"\n\n#define DRIVER_NAME \"dw_spi_mmio\"\n\nstruct dw_spi_mmio {\n\tstruct dw_spi  dws;\n\tstruct clk     *clk;\n\tstruct clk     *pclk;\n\tvoid           *priv;\n\tstruct reset_control *rstc;\n};\n\n#define MSCC_CPU_SYSTEM_CTRL_GENERAL_CTRL\t0x24\n#define OCELOT_IF_SI_OWNER_OFFSET\t\t4\n#define JAGUAR2_IF_SI_OWNER_OFFSET\t\t6\n#define MSCC_IF_SI_OWNER_MASK\t\t\tGENMASK(1, 0)\n#define MSCC_IF_SI_OWNER_SISL\t\t\t0\n#define MSCC_IF_SI_OWNER_SIBM\t\t\t1\n#define MSCC_IF_SI_OWNER_SIMC\t\t\t2\n\n#define MSCC_SPI_MST_SW_MODE\t\t\t0x14\n#define MSCC_SPI_MST_SW_MODE_SW_PIN_CTRL_MODE\tBIT(13)\n#define MSCC_SPI_MST_SW_MODE_SW_SPI_CS(x)\t(x << 5)\n\n#define SPARX5_FORCE_ENA\t\t\t0xa4\n#define SPARX5_FORCE_VAL\t\t\t0xa8\n\nstruct dw_spi_mscc {\n\tstruct regmap       *syscon;\n\tvoid __iomem        *spi_mst;  \n};\n\n \n#define ELBA_SPICS_REG\t\t\t0x2468\n#define ELBA_SPICS_OFFSET(cs)\t\t((cs) << 1)\n#define ELBA_SPICS_MASK(cs)\t\t(GENMASK(1, 0) << ELBA_SPICS_OFFSET(cs))\n#define ELBA_SPICS_SET(cs, val)\t\t\\\n\t\t((((val) << 1) | BIT(0)) << ELBA_SPICS_OFFSET(cs))\n\n \nstatic void dw_spi_mscc_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\tstruct dw_spi_mmio *dwsmmio = container_of(dws, struct dw_spi_mmio, dws);\n\tstruct dw_spi_mscc *dwsmscc = dwsmmio->priv;\n\tu32 cs = spi_get_chipselect(spi, 0);\n\n\tif (cs < 4) {\n\t\tu32 sw_mode = MSCC_SPI_MST_SW_MODE_SW_PIN_CTRL_MODE;\n\n\t\tif (!enable)\n\t\t\tsw_mode |= MSCC_SPI_MST_SW_MODE_SW_SPI_CS(BIT(cs));\n\n\t\twritel(sw_mode, dwsmscc->spi_mst + MSCC_SPI_MST_SW_MODE);\n\t}\n\n\tdw_spi_set_cs(spi, enable);\n}\n\nstatic int dw_spi_mscc_init(struct platform_device *pdev,\n\t\t\t    struct dw_spi_mmio *dwsmmio,\n\t\t\t    const char *cpu_syscon, u32 if_si_owner_offset)\n{\n\tstruct dw_spi_mscc *dwsmscc;\n\n\tdwsmscc = devm_kzalloc(&pdev->dev, sizeof(*dwsmscc), GFP_KERNEL);\n\tif (!dwsmscc)\n\t\treturn -ENOMEM;\n\n\tdwsmscc->spi_mst = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(dwsmscc->spi_mst)) {\n\t\tdev_err(&pdev->dev, \"SPI_MST region map failed\\n\");\n\t\treturn PTR_ERR(dwsmscc->spi_mst);\n\t}\n\n\tdwsmscc->syscon = syscon_regmap_lookup_by_compatible(cpu_syscon);\n\tif (IS_ERR(dwsmscc->syscon))\n\t\treturn PTR_ERR(dwsmscc->syscon);\n\n\t \n\twritel(0, dwsmscc->spi_mst + MSCC_SPI_MST_SW_MODE);\n\n\t \n\tregmap_update_bits(dwsmscc->syscon, MSCC_CPU_SYSTEM_CTRL_GENERAL_CTRL,\n\t\t\t   MSCC_IF_SI_OWNER_MASK << if_si_owner_offset,\n\t\t\t   MSCC_IF_SI_OWNER_SIMC << if_si_owner_offset);\n\n\tdwsmmio->dws.set_cs = dw_spi_mscc_set_cs;\n\tdwsmmio->priv = dwsmscc;\n\n\treturn 0;\n}\n\nstatic int dw_spi_mscc_ocelot_init(struct platform_device *pdev,\n\t\t\t\t   struct dw_spi_mmio *dwsmmio)\n{\n\treturn dw_spi_mscc_init(pdev, dwsmmio, \"mscc,ocelot-cpu-syscon\",\n\t\t\t\tOCELOT_IF_SI_OWNER_OFFSET);\n}\n\nstatic int dw_spi_mscc_jaguar2_init(struct platform_device *pdev,\n\t\t\t\t    struct dw_spi_mmio *dwsmmio)\n{\n\treturn dw_spi_mscc_init(pdev, dwsmmio, \"mscc,jaguar2-cpu-syscon\",\n\t\t\t\tJAGUAR2_IF_SI_OWNER_OFFSET);\n}\n\n \nstatic void dw_spi_sparx5_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\tstruct dw_spi_mmio *dwsmmio = container_of(dws, struct dw_spi_mmio, dws);\n\tstruct dw_spi_mscc *dwsmscc = dwsmmio->priv;\n\tu8 cs = spi_get_chipselect(spi, 0);\n\n\tif (!enable) {\n\t\t \n\t\tregmap_write(dwsmscc->syscon, SPARX5_FORCE_ENA, 1);\n\t\t \n\t\tregmap_write(dwsmscc->syscon, SPARX5_FORCE_VAL, ~BIT(cs));\n\t\t \n\t\tusleep_range(1, 5);\n\t} else {\n\t\t \n\t\tregmap_write(dwsmscc->syscon, SPARX5_FORCE_VAL, ~0);\n\t\t \n\t\tusleep_range(1, 5);\n\t\t \n\t\tregmap_write(dwsmscc->syscon, SPARX5_FORCE_ENA, 0);\n\t}\n\n\tdw_spi_set_cs(spi, enable);\n}\n\nstatic int dw_spi_mscc_sparx5_init(struct platform_device *pdev,\n\t\t\t\t   struct dw_spi_mmio *dwsmmio)\n{\n\tconst char *syscon_name = \"microchip,sparx5-cpu-syscon\";\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_spi_mscc *dwsmscc;\n\n\tif (!IS_ENABLED(CONFIG_SPI_MUX)) {\n\t\tdev_err(dev, \"This driver needs CONFIG_SPI_MUX\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdwsmscc = devm_kzalloc(dev, sizeof(*dwsmscc), GFP_KERNEL);\n\tif (!dwsmscc)\n\t\treturn -ENOMEM;\n\n\tdwsmscc->syscon =\n\t\tsyscon_regmap_lookup_by_compatible(syscon_name);\n\tif (IS_ERR(dwsmscc->syscon)) {\n\t\tdev_err(dev, \"No syscon map %s\\n\", syscon_name);\n\t\treturn PTR_ERR(dwsmscc->syscon);\n\t}\n\n\tdwsmmio->dws.set_cs = dw_spi_sparx5_set_cs;\n\tdwsmmio->priv = dwsmscc;\n\n\treturn 0;\n}\n\nstatic int dw_spi_alpine_init(struct platform_device *pdev,\n\t\t\t      struct dw_spi_mmio *dwsmmio)\n{\n\tdwsmmio->dws.caps = DW_SPI_CAP_CS_OVERRIDE;\n\n\treturn 0;\n}\n\nstatic int dw_spi_pssi_init(struct platform_device *pdev,\n\t\t\t    struct dw_spi_mmio *dwsmmio)\n{\n\tdw_spi_dma_setup_generic(&dwsmmio->dws);\n\n\treturn 0;\n}\n\nstatic int dw_spi_hssi_init(struct platform_device *pdev,\n\t\t\t    struct dw_spi_mmio *dwsmmio)\n{\n\tdwsmmio->dws.ip = DW_HSSI_ID;\n\n\tdw_spi_dma_setup_generic(&dwsmmio->dws);\n\n\treturn 0;\n}\n\nstatic int dw_spi_intel_init(struct platform_device *pdev,\n\t\t\t     struct dw_spi_mmio *dwsmmio)\n{\n\tdwsmmio->dws.ip = DW_HSSI_ID;\n\n\treturn 0;\n}\n\n \nstatic int dw_spi_mountevans_imc_init(struct platform_device *pdev,\n\t\t\t\t      struct dw_spi_mmio *dwsmmio)\n{\n\t \n\tdwsmmio->dws.fifo_len = 31;\n\n\treturn 0;\n}\n\nstatic int dw_spi_canaan_k210_init(struct platform_device *pdev,\n\t\t\t\t   struct dw_spi_mmio *dwsmmio)\n{\n\t \n\tdwsmmio->dws.fifo_len = 31;\n\n\treturn 0;\n}\n\nstatic void dw_spi_elba_override_cs(struct regmap *syscon, int cs, int enable)\n{\n\tregmap_update_bits(syscon, ELBA_SPICS_REG, ELBA_SPICS_MASK(cs),\n\t\t\t   ELBA_SPICS_SET(cs, enable));\n}\n\nstatic void dw_spi_elba_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct dw_spi *dws = spi_controller_get_devdata(spi->controller);\n\tstruct dw_spi_mmio *dwsmmio = container_of(dws, struct dw_spi_mmio, dws);\n\tstruct regmap *syscon = dwsmmio->priv;\n\tu8 cs;\n\n\tcs = spi_get_chipselect(spi, 0);\n\tif (cs < 2)\n\t\tdw_spi_elba_override_cs(syscon, spi_get_chipselect(spi, 0), enable);\n\n\t \n\tspi_set_chipselect(spi, 0, 0);\n\tdw_spi_set_cs(spi, enable);\n\tspi_set_chipselect(spi, 0, cs);\n}\n\nstatic int dw_spi_elba_init(struct platform_device *pdev,\n\t\t\t    struct dw_spi_mmio *dwsmmio)\n{\n\tstruct regmap *syscon;\n\n\tsyscon = syscon_regmap_lookup_by_phandle(dev_of_node(&pdev->dev),\n\t\t\t\t\t\t \"amd,pensando-elba-syscon\");\n\tif (IS_ERR(syscon))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(syscon),\n\t\t\t\t     \"syscon regmap lookup failed\\n\");\n\n\tdwsmmio->priv = syscon;\n\tdwsmmio->dws.set_cs = dw_spi_elba_set_cs;\n\n\treturn 0;\n}\n\nstatic int dw_spi_mmio_probe(struct platform_device *pdev)\n{\n\tint (*init_func)(struct platform_device *pdev,\n\t\t\t struct dw_spi_mmio *dwsmmio);\n\tstruct dw_spi_mmio *dwsmmio;\n\tstruct resource *mem;\n\tstruct dw_spi *dws;\n\tint ret;\n\tint num_cs;\n\n\tdwsmmio = devm_kzalloc(&pdev->dev, sizeof(struct dw_spi_mmio),\n\t\t\tGFP_KERNEL);\n\tif (!dwsmmio)\n\t\treturn -ENOMEM;\n\n\tdws = &dwsmmio->dws;\n\n\t \n\tdws->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(dws->regs))\n\t\treturn PTR_ERR(dws->regs);\n\n\tdws->paddr = mem->start;\n\n\tdws->irq = platform_get_irq(pdev, 0);\n\tif (dws->irq < 0)\n\t\treturn dws->irq;  \n\n\tdwsmmio->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dwsmmio->clk))\n\t\treturn PTR_ERR(dwsmmio->clk);\n\tret = clk_prepare_enable(dwsmmio->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdwsmmio->pclk = devm_clk_get_optional(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dwsmmio->pclk)) {\n\t\tret = PTR_ERR(dwsmmio->pclk);\n\t\tgoto out_clk;\n\t}\n\tret = clk_prepare_enable(dwsmmio->pclk);\n\tif (ret)\n\t\tgoto out_clk;\n\n\t \n\tdwsmmio->rstc = devm_reset_control_get_optional_exclusive(&pdev->dev, \"spi\");\n\tif (IS_ERR(dwsmmio->rstc)) {\n\t\tret = PTR_ERR(dwsmmio->rstc);\n\t\tgoto out_clk;\n\t}\n\treset_control_deassert(dwsmmio->rstc);\n\n\tdws->bus_num = pdev->id;\n\n\tdws->max_freq = clk_get_rate(dwsmmio->clk);\n\n\tif (device_property_read_u32(&pdev->dev, \"reg-io-width\",\n\t\t\t\t     &dws->reg_io_width))\n\t\tdws->reg_io_width = 4;\n\n\tnum_cs = 4;\n\n\tdevice_property_read_u32(&pdev->dev, \"num-cs\", &num_cs);\n\n\tdws->num_cs = num_cs;\n\n\tinit_func = device_get_match_data(&pdev->dev);\n\tif (init_func) {\n\t\tret = init_func(pdev, dwsmmio);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = dw_spi_add_host(&pdev->dev, dws);\n\tif (ret)\n\t\tgoto out;\n\n\tplatform_set_drvdata(pdev, dwsmmio);\n\treturn 0;\n\nout:\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(dwsmmio->pclk);\nout_clk:\n\tclk_disable_unprepare(dwsmmio->clk);\n\treset_control_assert(dwsmmio->rstc);\n\n\treturn ret;\n}\n\nstatic void dw_spi_mmio_remove(struct platform_device *pdev)\n{\n\tstruct dw_spi_mmio *dwsmmio = platform_get_drvdata(pdev);\n\n\tdw_spi_remove_host(&dwsmmio->dws);\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(dwsmmio->pclk);\n\tclk_disable_unprepare(dwsmmio->clk);\n\treset_control_assert(dwsmmio->rstc);\n}\n\nstatic const struct of_device_id dw_spi_mmio_of_match[] = {\n\t{ .compatible = \"snps,dw-apb-ssi\", .data = dw_spi_pssi_init},\n\t{ .compatible = \"mscc,ocelot-spi\", .data = dw_spi_mscc_ocelot_init},\n\t{ .compatible = \"mscc,jaguar2-spi\", .data = dw_spi_mscc_jaguar2_init},\n\t{ .compatible = \"amazon,alpine-dw-apb-ssi\", .data = dw_spi_alpine_init},\n\t{ .compatible = \"renesas,rzn1-spi\", .data = dw_spi_pssi_init},\n\t{ .compatible = \"snps,dwc-ssi-1.01a\", .data = dw_spi_hssi_init},\n\t{ .compatible = \"intel,keembay-ssi\", .data = dw_spi_intel_init},\n\t{ .compatible = \"intel,thunderbay-ssi\", .data = dw_spi_intel_init},\n\t{\n\t\t.compatible = \"intel,mountevans-imc-ssi\",\n\t\t.data = dw_spi_mountevans_imc_init,\n\t},\n\t{ .compatible = \"microchip,sparx5-spi\", dw_spi_mscc_sparx5_init},\n\t{ .compatible = \"canaan,k210-spi\", dw_spi_canaan_k210_init},\n\t{ .compatible = \"amd,pensando-elba-spi\", .data = dw_spi_elba_init},\n\t{  }\n};\nMODULE_DEVICE_TABLE(of, dw_spi_mmio_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id dw_spi_mmio_acpi_match[] = {\n\t{\"HISI0173\", (kernel_ulong_t)dw_spi_pssi_init},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, dw_spi_mmio_acpi_match);\n#endif\n\nstatic struct platform_driver dw_spi_mmio_driver = {\n\t.probe\t\t= dw_spi_mmio_probe,\n\t.remove_new\t= dw_spi_mmio_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = dw_spi_mmio_of_match,\n\t\t.acpi_match_table = ACPI_PTR(dw_spi_mmio_acpi_match),\n\t},\n};\nmodule_platform_driver(dw_spi_mmio_driver);\n\nMODULE_AUTHOR(\"Jean-Hugues Deschenes <jean-hugues.deschenes@octasic.com>\");\nMODULE_DESCRIPTION(\"Memory-mapped I/O interface driver for DW SPI Core\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SPI_DW_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}