{
  "module_name": "spi-atmel.c",
  "hash_id": "2c2a3e8aabee3562374b13b5f14ad5b81830cd0477a55e3a6ba17c6ba811d9bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-atmel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/io.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/iopoll.h>\n#include <trace/events/spi.h>\n\n \n#define SPI_CR\t\t\t\t\t0x0000\n#define SPI_MR\t\t\t\t\t0x0004\n#define SPI_RDR\t\t\t\t\t0x0008\n#define SPI_TDR\t\t\t\t\t0x000c\n#define SPI_SR\t\t\t\t\t0x0010\n#define SPI_IER\t\t\t\t\t0x0014\n#define SPI_IDR\t\t\t\t\t0x0018\n#define SPI_IMR\t\t\t\t\t0x001c\n#define SPI_CSR0\t\t\t\t0x0030\n#define SPI_CSR1\t\t\t\t0x0034\n#define SPI_CSR2\t\t\t\t0x0038\n#define SPI_CSR3\t\t\t\t0x003c\n#define SPI_FMR\t\t\t\t\t0x0040\n#define SPI_FLR\t\t\t\t\t0x0044\n#define SPI_VERSION\t\t\t\t0x00fc\n#define SPI_RPR\t\t\t\t\t0x0100\n#define SPI_RCR\t\t\t\t\t0x0104\n#define SPI_TPR\t\t\t\t\t0x0108\n#define SPI_TCR\t\t\t\t\t0x010c\n#define SPI_RNPR\t\t\t\t0x0110\n#define SPI_RNCR\t\t\t\t0x0114\n#define SPI_TNPR\t\t\t\t0x0118\n#define SPI_TNCR\t\t\t\t0x011c\n#define SPI_PTCR\t\t\t\t0x0120\n#define SPI_PTSR\t\t\t\t0x0124\n\n \n#define SPI_SPIEN_OFFSET\t\t\t0\n#define SPI_SPIEN_SIZE\t\t\t\t1\n#define SPI_SPIDIS_OFFSET\t\t\t1\n#define SPI_SPIDIS_SIZE\t\t\t\t1\n#define SPI_SWRST_OFFSET\t\t\t7\n#define SPI_SWRST_SIZE\t\t\t\t1\n#define SPI_LASTXFER_OFFSET\t\t\t24\n#define SPI_LASTXFER_SIZE\t\t\t1\n#define SPI_TXFCLR_OFFSET\t\t\t16\n#define SPI_TXFCLR_SIZE\t\t\t\t1\n#define SPI_RXFCLR_OFFSET\t\t\t17\n#define SPI_RXFCLR_SIZE\t\t\t\t1\n#define SPI_FIFOEN_OFFSET\t\t\t30\n#define SPI_FIFOEN_SIZE\t\t\t\t1\n#define SPI_FIFODIS_OFFSET\t\t\t31\n#define SPI_FIFODIS_SIZE\t\t\t1\n\n \n#define SPI_MSTR_OFFSET\t\t\t\t0\n#define SPI_MSTR_SIZE\t\t\t\t1\n#define SPI_PS_OFFSET\t\t\t\t1\n#define SPI_PS_SIZE\t\t\t\t1\n#define SPI_PCSDEC_OFFSET\t\t\t2\n#define SPI_PCSDEC_SIZE\t\t\t\t1\n#define SPI_FDIV_OFFSET\t\t\t\t3\n#define SPI_FDIV_SIZE\t\t\t\t1\n#define SPI_MODFDIS_OFFSET\t\t\t4\n#define SPI_MODFDIS_SIZE\t\t\t1\n#define SPI_WDRBT_OFFSET\t\t\t5\n#define SPI_WDRBT_SIZE\t\t\t\t1\n#define SPI_LLB_OFFSET\t\t\t\t7\n#define SPI_LLB_SIZE\t\t\t\t1\n#define SPI_PCS_OFFSET\t\t\t\t16\n#define SPI_PCS_SIZE\t\t\t\t4\n#define SPI_DLYBCS_OFFSET\t\t\t24\n#define SPI_DLYBCS_SIZE\t\t\t\t8\n\n \n#define SPI_RD_OFFSET\t\t\t\t0\n#define SPI_RD_SIZE\t\t\t\t16\n\n \n#define SPI_TD_OFFSET\t\t\t\t0\n#define SPI_TD_SIZE\t\t\t\t16\n\n \n#define SPI_RDRF_OFFSET\t\t\t\t0\n#define SPI_RDRF_SIZE\t\t\t\t1\n#define SPI_TDRE_OFFSET\t\t\t\t1\n#define SPI_TDRE_SIZE\t\t\t\t1\n#define SPI_MODF_OFFSET\t\t\t\t2\n#define SPI_MODF_SIZE\t\t\t\t1\n#define SPI_OVRES_OFFSET\t\t\t3\n#define SPI_OVRES_SIZE\t\t\t\t1\n#define SPI_ENDRX_OFFSET\t\t\t4\n#define SPI_ENDRX_SIZE\t\t\t\t1\n#define SPI_ENDTX_OFFSET\t\t\t5\n#define SPI_ENDTX_SIZE\t\t\t\t1\n#define SPI_RXBUFF_OFFSET\t\t\t6\n#define SPI_RXBUFF_SIZE\t\t\t\t1\n#define SPI_TXBUFE_OFFSET\t\t\t7\n#define SPI_TXBUFE_SIZE\t\t\t\t1\n#define SPI_NSSR_OFFSET\t\t\t\t8\n#define SPI_NSSR_SIZE\t\t\t\t1\n#define SPI_TXEMPTY_OFFSET\t\t\t9\n#define SPI_TXEMPTY_SIZE\t\t\t1\n#define SPI_SPIENS_OFFSET\t\t\t16\n#define SPI_SPIENS_SIZE\t\t\t\t1\n#define SPI_TXFEF_OFFSET\t\t\t24\n#define SPI_TXFEF_SIZE\t\t\t\t1\n#define SPI_TXFFF_OFFSET\t\t\t25\n#define SPI_TXFFF_SIZE\t\t\t\t1\n#define SPI_TXFTHF_OFFSET\t\t\t26\n#define SPI_TXFTHF_SIZE\t\t\t\t1\n#define SPI_RXFEF_OFFSET\t\t\t27\n#define SPI_RXFEF_SIZE\t\t\t\t1\n#define SPI_RXFFF_OFFSET\t\t\t28\n#define SPI_RXFFF_SIZE\t\t\t\t1\n#define SPI_RXFTHF_OFFSET\t\t\t29\n#define SPI_RXFTHF_SIZE\t\t\t\t1\n#define SPI_TXFPTEF_OFFSET\t\t\t30\n#define SPI_TXFPTEF_SIZE\t\t\t1\n#define SPI_RXFPTEF_OFFSET\t\t\t31\n#define SPI_RXFPTEF_SIZE\t\t\t1\n\n \n#define SPI_CPOL_OFFSET\t\t\t\t0\n#define SPI_CPOL_SIZE\t\t\t\t1\n#define SPI_NCPHA_OFFSET\t\t\t1\n#define SPI_NCPHA_SIZE\t\t\t\t1\n#define SPI_CSAAT_OFFSET\t\t\t3\n#define SPI_CSAAT_SIZE\t\t\t\t1\n#define SPI_BITS_OFFSET\t\t\t\t4\n#define SPI_BITS_SIZE\t\t\t\t4\n#define SPI_SCBR_OFFSET\t\t\t\t8\n#define SPI_SCBR_SIZE\t\t\t\t8\n#define SPI_DLYBS_OFFSET\t\t\t16\n#define SPI_DLYBS_SIZE\t\t\t\t8\n#define SPI_DLYBCT_OFFSET\t\t\t24\n#define SPI_DLYBCT_SIZE\t\t\t\t8\n\n \n#define SPI_RXCTR_OFFSET\t\t\t0\n#define SPI_RXCTR_SIZE\t\t\t\t16\n\n \n#define SPI_TXCTR_OFFSET\t\t\t0\n#define SPI_TXCTR_SIZE\t\t\t\t16\n\n \n#define SPI_RXNCR_OFFSET\t\t\t0\n#define SPI_RXNCR_SIZE\t\t\t\t16\n\n \n#define SPI_TXNCR_OFFSET\t\t\t0\n#define SPI_TXNCR_SIZE\t\t\t\t16\n\n \n#define SPI_RXTEN_OFFSET\t\t\t0\n#define SPI_RXTEN_SIZE\t\t\t\t1\n#define SPI_RXTDIS_OFFSET\t\t\t1\n#define SPI_RXTDIS_SIZE\t\t\t\t1\n#define SPI_TXTEN_OFFSET\t\t\t8\n#define SPI_TXTEN_SIZE\t\t\t\t1\n#define SPI_TXTDIS_OFFSET\t\t\t9\n#define SPI_TXTDIS_SIZE\t\t\t\t1\n\n \n#define SPI_TXRDYM_OFFSET\t\t\t0\n#define SPI_TXRDYM_SIZE\t\t\t\t2\n#define SPI_RXRDYM_OFFSET\t\t\t4\n#define SPI_RXRDYM_SIZE\t\t\t\t2\n#define SPI_TXFTHRES_OFFSET\t\t\t16\n#define SPI_TXFTHRES_SIZE\t\t\t6\n#define SPI_RXFTHRES_OFFSET\t\t\t24\n#define SPI_RXFTHRES_SIZE\t\t\t6\n\n \n#define SPI_TXFL_OFFSET\t\t\t\t0\n#define SPI_TXFL_SIZE\t\t\t\t6\n#define SPI_RXFL_OFFSET\t\t\t\t16\n#define SPI_RXFL_SIZE\t\t\t\t6\n\n \n#define SPI_BITS_8_BPT\t\t\t\t0\n#define SPI_BITS_9_BPT\t\t\t\t1\n#define SPI_BITS_10_BPT\t\t\t\t2\n#define SPI_BITS_11_BPT\t\t\t\t3\n#define SPI_BITS_12_BPT\t\t\t\t4\n#define SPI_BITS_13_BPT\t\t\t\t5\n#define SPI_BITS_14_BPT\t\t\t\t6\n#define SPI_BITS_15_BPT\t\t\t\t7\n#define SPI_BITS_16_BPT\t\t\t\t8\n#define SPI_ONE_DATA\t\t\t\t0\n#define SPI_TWO_DATA\t\t\t\t1\n#define SPI_FOUR_DATA\t\t\t\t2\n\n \n#define SPI_BIT(name) \\\n\t(1 << SPI_##name##_OFFSET)\n#define SPI_BF(name, value) \\\n\t(((value) & ((1 << SPI_##name##_SIZE) - 1)) << SPI_##name##_OFFSET)\n#define SPI_BFEXT(name, value) \\\n\t(((value) >> SPI_##name##_OFFSET) & ((1 << SPI_##name##_SIZE) - 1))\n#define SPI_BFINS(name, value, old) \\\n\t(((old) & ~(((1 << SPI_##name##_SIZE) - 1) << SPI_##name##_OFFSET)) \\\n\t  | SPI_BF(name, value))\n\n \n#define spi_readl(port, reg) \\\n\treadl_relaxed((port)->regs + SPI_##reg)\n#define spi_writel(port, reg, value) \\\n\twritel_relaxed((value), (port)->regs + SPI_##reg)\n#define spi_writew(port, reg, value) \\\n\twritew_relaxed((value), (port)->regs + SPI_##reg)\n\n \n#define DMA_MIN_BYTES\t16\n\n#define SPI_DMA_MIN_TIMEOUT\t(msecs_to_jiffies(1000))\n#define SPI_DMA_TIMEOUT_PER_10K\t(msecs_to_jiffies(4))\n\n#define AUTOSUSPEND_TIMEOUT\t2000\n\nstruct atmel_spi_caps {\n\tbool\tis_spi2;\n\tbool\thas_wdrbt;\n\tbool\thas_dma_support;\n\tbool\thas_pdc_support;\n};\n\n \nstruct atmel_spi {\n\tspinlock_t\t\tlock;\n\tunsigned long\t\tflags;\n\n\tphys_addr_t\t\tphybase;\n\tvoid __iomem\t\t*regs;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tstruct platform_device\t*pdev;\n\tunsigned long\t\tspi_clk;\n\n\tstruct spi_transfer\t*current_transfer;\n\tint\t\t\tcurrent_remaining_bytes;\n\tint\t\t\tdone_status;\n\tdma_addr_t\t\tdma_addr_rx_bbuf;\n\tdma_addr_t\t\tdma_addr_tx_bbuf;\n\tvoid\t\t\t*addr_rx_bbuf;\n\tvoid\t\t\t*addr_tx_bbuf;\n\n\tstruct completion\txfer_completion;\n\n\tstruct atmel_spi_caps\tcaps;\n\n\tbool\t\t\tuse_dma;\n\tbool\t\t\tuse_pdc;\n\n\tbool\t\t\tkeep_cs;\n\n\tu32\t\t\tfifo_size;\n\tbool\t\t\tlast_polarity;\n\tu8\t\t\tnative_cs_free;\n\tu8\t\t\tnative_cs_for_gpio;\n};\n\n \nstruct atmel_spi_device {\n\tu32\t\t\tcsr;\n};\n\n#define SPI_MAX_DMA_XFER\t65535  \n#define INVALID_DMA_ADDRESS\t0xffffffff\n\n \n#define DUMMY_MSG_FREQUENCY\t0x02\n \n#define DUMMY_MSG\t\t0xAA\n\n \nstatic bool atmel_spi_is_v2(struct atmel_spi *as)\n{\n\treturn as->caps.is_spi2;\n}\n\n \nstatic void atmel_spi_send_dummy(struct atmel_spi *as, struct spi_device *spi, int chip_select)\n{\n\tu32 status;\n\tu32 csr;\n\n\t \n\tcsr = spi_readl(as, CSR0 + 4 * chip_select);\n\tcsr = SPI_BFINS(SCBR, DUMMY_MSG_FREQUENCY, csr);\n\tspi_writel(as, CSR0 + 4 * chip_select, csr);\n\n\t \n\tspi_readl(as, RDR);\n\twhile (spi_readl(as, SR) & SPI_BIT(RDRF)) {\n\t\tspi_readl(as, RDR);\n\t\tcpu_relax();\n\t}\n\n\tspi_writel(as, TDR, DUMMY_MSG);\n\n\treadl_poll_timeout_atomic(as->regs + SPI_SR, status,\n\t\t\t\t  (status & SPI_BIT(TXEMPTY)), 1, 1000);\n}\n\n\n \nstatic void cs_activate(struct atmel_spi *as, struct spi_device *spi)\n{\n\tstruct atmel_spi_device *asd = spi->controller_state;\n\tbool new_polarity;\n\tint chip_select;\n\tu32 mr;\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tchip_select = as->native_cs_for_gpio;\n\telse\n\t\tchip_select = spi_get_chipselect(spi, 0);\n\n\tif (atmel_spi_is_v2(as)) {\n\t\tspi_writel(as, CSR0 + 4 * chip_select, asd->csr);\n\t\t \n\t\tspi_writel(as, CSR0, asd->csr);\n\t\tif (as->caps.has_wdrbt) {\n\t\t\tspi_writel(as, MR,\n\t\t\t\t\tSPI_BF(PCS, ~(0x01 << chip_select))\n\t\t\t\t\t| SPI_BIT(WDRBT)\n\t\t\t\t\t| SPI_BIT(MODFDIS)\n\t\t\t\t\t| SPI_BIT(MSTR));\n\t\t} else {\n\t\t\tspi_writel(as, MR,\n\t\t\t\t\tSPI_BF(PCS, ~(0x01 << chip_select))\n\t\t\t\t\t| SPI_BIT(MODFDIS)\n\t\t\t\t\t| SPI_BIT(MSTR));\n\t\t}\n\n\t\tmr = spi_readl(as, MR);\n\n\t\t \n\t\tif (spi_get_csgpiod(spi, 0)) {\n\t\t\tnew_polarity = (asd->csr & SPI_BIT(CPOL)) != 0;\n\t\t\tif (new_polarity != as->last_polarity) {\n\t\t\t\t \n\t\t\t\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), 0);\n\t\t\t\tatmel_spi_send_dummy(as, spi, chip_select);\n\t\t\t\tas->last_polarity = new_polarity;\n\t\t\t\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;\n\t\tint i;\n\t\tu32 csr;\n\n\t\t \n\t\tfor (i = 0; i < spi->controller->num_chipselect; i++) {\n\t\t\tcsr = spi_readl(as, CSR0 + 4 * i);\n\t\t\tif ((csr ^ cpol) & SPI_BIT(CPOL))\n\t\t\t\tspi_writel(as, CSR0 + 4 * i,\n\t\t\t\t\t\tcsr ^ SPI_BIT(CPOL));\n\t\t}\n\n\t\tmr = spi_readl(as, MR);\n\t\tmr = SPI_BFINS(PCS, ~(1 << chip_select), mr);\n\t\tspi_writel(as, MR, mr);\n\t}\n\n\tdev_dbg(&spi->dev, \"activate NPCS, mr %08x\\n\", mr);\n}\n\nstatic void cs_deactivate(struct atmel_spi *as, struct spi_device *spi)\n{\n\tint chip_select;\n\tu32 mr;\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tchip_select = as->native_cs_for_gpio;\n\telse\n\t\tchip_select = spi_get_chipselect(spi, 0);\n\n\t \n\tmr = spi_readl(as, MR);\n\tif (~SPI_BFEXT(PCS, mr) & (1 << chip_select)) {\n\t\tmr = SPI_BFINS(PCS, 0xf, mr);\n\t\tspi_writel(as, MR, mr);\n\t}\n\n\tdev_dbg(&spi->dev, \"DEactivate NPCS, mr %08x\\n\", mr);\n\n\tif (!spi_get_csgpiod(spi, 0))\n\t\tspi_writel(as, CR, SPI_BIT(LASTXFER));\n}\n\nstatic void atmel_spi_lock(struct atmel_spi *as) __acquires(&as->lock)\n{\n\tspin_lock_irqsave(&as->lock, as->flags);\n}\n\nstatic void atmel_spi_unlock(struct atmel_spi *as) __releases(&as->lock)\n{\n\tspin_unlock_irqrestore(&as->lock, as->flags);\n}\n\nstatic inline bool atmel_spi_is_vmalloc_xfer(struct spi_transfer *xfer)\n{\n\treturn is_vmalloc_addr(xfer->tx_buf) || is_vmalloc_addr(xfer->rx_buf);\n}\n\nstatic inline bool atmel_spi_use_dma(struct atmel_spi *as,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\treturn as->use_dma && xfer->len >= DMA_MIN_BYTES;\n}\n\nstatic bool atmel_spi_can_dma(struct spi_controller *host,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\n\tif (IS_ENABLED(CONFIG_SOC_SAM_V4_V5))\n\t\treturn atmel_spi_use_dma(as, xfer) &&\n\t\t\t!atmel_spi_is_vmalloc_xfer(xfer);\n\telse\n\t\treturn atmel_spi_use_dma(as, xfer);\n\n}\n\nstatic int atmel_spi_dma_slave_config(struct atmel_spi *as, u8 bits_per_word)\n{\n\tstruct spi_controller *host = platform_get_drvdata(as->pdev);\n\tstruct dma_slave_config\tslave_config;\n\tint err = 0;\n\n\tif (bits_per_word > 8) {\n\t\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t} else {\n\t\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t}\n\n\tslave_config.dst_addr = (dma_addr_t)as->phybase + SPI_TDR;\n\tslave_config.src_addr = (dma_addr_t)as->phybase + SPI_RDR;\n\tslave_config.src_maxburst = 1;\n\tslave_config.dst_maxburst = 1;\n\tslave_config.device_fc = false;\n\n\t \n\tif (dmaengine_slave_config(host->dma_tx, &slave_config)) {\n\t\tdev_err(&as->pdev->dev,\n\t\t\t\"failed to configure tx dma channel\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tif (dmaengine_slave_config(host->dma_rx, &slave_config)) {\n\t\tdev_err(&as->pdev->dev,\n\t\t\t\"failed to configure rx dma channel\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int atmel_spi_configure_dma(struct spi_controller *host,\n\t\t\t\t   struct atmel_spi *as)\n{\n\tstruct device *dev = &as->pdev->dev;\n\tint err;\n\n\thost->dma_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\terr = PTR_ERR(host->dma_tx);\n\t\tdev_dbg(dev, \"No TX DMA channel, DMA is disabled\\n\");\n\t\tgoto error_clear;\n\t}\n\n\thost->dma_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(host->dma_rx)) {\n\t\terr = PTR_ERR(host->dma_rx);\n\t\t \n\t\tdev_dbg(dev, \"No RX DMA channel, DMA is disabled\\n\");\n\t\tgoto error;\n\t}\n\n\terr = atmel_spi_dma_slave_config(as, 8);\n\tif (err)\n\t\tgoto error;\n\n\tdev_info(&as->pdev->dev,\n\t\t\t\"Using %s (tx) and %s (rx) for DMA transfers\\n\",\n\t\t\tdma_chan_name(host->dma_tx),\n\t\t\tdma_chan_name(host->dma_rx));\n\n\treturn 0;\nerror:\n\tif (!IS_ERR(host->dma_rx))\n\t\tdma_release_channel(host->dma_rx);\n\tif (!IS_ERR(host->dma_tx))\n\t\tdma_release_channel(host->dma_tx);\nerror_clear:\n\thost->dma_tx = host->dma_rx = NULL;\n\treturn err;\n}\n\nstatic void atmel_spi_stop_dma(struct spi_controller *host)\n{\n\tif (host->dma_rx)\n\t\tdmaengine_terminate_all(host->dma_rx);\n\tif (host->dma_tx)\n\t\tdmaengine_terminate_all(host->dma_tx);\n}\n\nstatic void atmel_spi_release_dma(struct spi_controller *host)\n{\n\tif (host->dma_rx) {\n\t\tdma_release_channel(host->dma_rx);\n\t\thost->dma_rx = NULL;\n\t}\n\tif (host->dma_tx) {\n\t\tdma_release_channel(host->dma_tx);\n\t\thost->dma_tx = NULL;\n\t}\n}\n\n \nstatic void dma_callback(void *data)\n{\n\tstruct spi_controller\t*host = data;\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\n\tif (is_vmalloc_addr(as->current_transfer->rx_buf) &&\n\t    IS_ENABLED(CONFIG_SOC_SAM_V4_V5)) {\n\t\tmemcpy(as->current_transfer->rx_buf, as->addr_rx_bbuf,\n\t\t       as->current_transfer->len);\n\t}\n\tcomplete(&as->xfer_completion);\n}\n\n \nstatic void atmel_spi_next_xfer_single(struct spi_controller *host,\n\t\t\t\t       struct spi_transfer *xfer)\n{\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\tunsigned long xfer_pos = xfer->len - as->current_remaining_bytes;\n\n\tdev_vdbg(host->dev.parent, \"atmel_spi_next_xfer_pio\\n\");\n\n\t \n\tspi_readl(as, RDR);\n\twhile (spi_readl(as, SR) & SPI_BIT(RDRF)) {\n\t\tspi_readl(as, RDR);\n\t\tcpu_relax();\n\t}\n\n\tif (xfer->bits_per_word > 8)\n\t\tspi_writel(as, TDR, *(u16 *)(xfer->tx_buf + xfer_pos));\n\telse\n\t\tspi_writel(as, TDR, *(u8 *)(xfer->tx_buf + xfer_pos));\n\n\tdev_dbg(host->dev.parent,\n\t\t\"  start pio xfer %p: len %u tx %p rx %p bitpw %d\\n\",\n\t\txfer, xfer->len, xfer->tx_buf, xfer->rx_buf,\n\t\txfer->bits_per_word);\n\n\t \n\tspi_writel(as, IER, SPI_BIT(RDRF) | SPI_BIT(OVRES));\n}\n\n \nstatic void atmel_spi_next_xfer_fifo(struct spi_controller *host,\n\t\t\t\t     struct spi_transfer *xfer)\n{\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\tu32 current_remaining_data, num_data;\n\tu32 offset = xfer->len - as->current_remaining_bytes;\n\tconst u16 *words = (const u16 *)((u8 *)xfer->tx_buf + offset);\n\tconst u8  *bytes = (const u8  *)((u8 *)xfer->tx_buf + offset);\n\tu16 td0, td1;\n\tu32 fifomr;\n\n\tdev_vdbg(host->dev.parent, \"atmel_spi_next_xfer_fifo\\n\");\n\n\t \n\tcurrent_remaining_data = ((xfer->bits_per_word > 8) ?\n\t\t\t\t  ((u32)as->current_remaining_bytes >> 1) :\n\t\t\t\t  (u32)as->current_remaining_bytes);\n\tnum_data = min(current_remaining_data, as->fifo_size);\n\n\t \n\tspi_writel(as, CR, SPI_BIT(RXFCLR) | SPI_BIT(TXFCLR));\n\twhile (spi_readl(as, FLR))\n\t\tcpu_relax();\n\n\t \n\tfifomr = spi_readl(as, FMR);\n\tspi_writel(as, FMR, SPI_BFINS(RXFTHRES, num_data, fifomr));\n\n\t \n\t(void)spi_readl(as, SR);\n\n\t \n\twhile (num_data >= 2) {\n\t\tif (xfer->bits_per_word > 8) {\n\t\t\ttd0 = *words++;\n\t\t\ttd1 = *words++;\n\t\t} else {\n\t\t\ttd0 = *bytes++;\n\t\t\ttd1 = *bytes++;\n\t\t}\n\n\t\tspi_writel(as, TDR, (td1 << 16) | td0);\n\t\tnum_data -= 2;\n\t}\n\n\tif (num_data) {\n\t\tif (xfer->bits_per_word > 8)\n\t\t\ttd0 = *words++;\n\t\telse\n\t\t\ttd0 = *bytes++;\n\n\t\tspi_writew(as, TDR, td0);\n\t\tnum_data--;\n\t}\n\n\tdev_dbg(host->dev.parent,\n\t\t\"  start fifo xfer %p: len %u tx %p rx %p bitpw %d\\n\",\n\t\txfer, xfer->len, xfer->tx_buf, xfer->rx_buf,\n\t\txfer->bits_per_word);\n\n\t \n\tspi_writel(as, IER, SPI_BIT(RXFTHF) | SPI_BIT(OVRES));\n}\n\n \nstatic void atmel_spi_next_xfer_pio(struct spi_controller *host,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\n\tif (as->fifo_size)\n\t\tatmel_spi_next_xfer_fifo(host, xfer);\n\telse\n\t\tatmel_spi_next_xfer_single(host, xfer);\n}\n\n \nstatic int atmel_spi_next_xfer_dma_submit(struct spi_controller *host,\n\t\t\t\tstruct spi_transfer *xfer,\n\t\t\t\tu32 *plen)\n{\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\tstruct dma_chan\t\t*rxchan = host->dma_rx;\n\tstruct dma_chan\t\t*txchan = host->dma_tx;\n\tstruct dma_async_tx_descriptor *rxdesc;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tdma_cookie_t\t\tcookie;\n\n\tdev_vdbg(host->dev.parent, \"atmel_spi_next_xfer_dma_submit\\n\");\n\n\t \n\tif (!rxchan || !txchan)\n\t\treturn -ENODEV;\n\n\n\t*plen = xfer->len;\n\n\tif (atmel_spi_dma_slave_config(as, xfer->bits_per_word))\n\t\tgoto err_exit;\n\n\t \n\tif (atmel_spi_is_vmalloc_xfer(xfer) &&\n\t    IS_ENABLED(CONFIG_SOC_SAM_V4_V5)) {\n\t\trxdesc = dmaengine_prep_slave_single(rxchan,\n\t\t\t\t\t\t     as->dma_addr_rx_bbuf,\n\t\t\t\t\t\t     xfer->len,\n\t\t\t\t\t\t     DMA_DEV_TO_MEM,\n\t\t\t\t\t\t     DMA_PREP_INTERRUPT |\n\t\t\t\t\t\t     DMA_CTRL_ACK);\n\t} else {\n\t\trxdesc = dmaengine_prep_slave_sg(rxchan,\n\t\t\t\t\t\t xfer->rx_sg.sgl,\n\t\t\t\t\t\t xfer->rx_sg.nents,\n\t\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT |\n\t\t\t\t\t\t DMA_CTRL_ACK);\n\t}\n\tif (!rxdesc)\n\t\tgoto err_dma;\n\n\tif (atmel_spi_is_vmalloc_xfer(xfer) &&\n\t    IS_ENABLED(CONFIG_SOC_SAM_V4_V5)) {\n\t\tmemcpy(as->addr_tx_bbuf, xfer->tx_buf, xfer->len);\n\t\ttxdesc = dmaengine_prep_slave_single(txchan,\n\t\t\t\t\t\t     as->dma_addr_tx_bbuf,\n\t\t\t\t\t\t     xfer->len, DMA_MEM_TO_DEV,\n\t\t\t\t\t\t     DMA_PREP_INTERRUPT |\n\t\t\t\t\t\t     DMA_CTRL_ACK);\n\t} else {\n\t\ttxdesc = dmaengine_prep_slave_sg(txchan,\n\t\t\t\t\t\t xfer->tx_sg.sgl,\n\t\t\t\t\t\t xfer->tx_sg.nents,\n\t\t\t\t\t\t DMA_MEM_TO_DEV,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT |\n\t\t\t\t\t\t DMA_CTRL_ACK);\n\t}\n\tif (!txdesc)\n\t\tgoto err_dma;\n\n\tdev_dbg(host->dev.parent,\n\t\t\"  start dma xfer %p: len %u tx %p/%08llx rx %p/%08llx\\n\",\n\t\txfer, xfer->len, xfer->tx_buf, (unsigned long long)xfer->tx_dma,\n\t\txfer->rx_buf, (unsigned long long)xfer->rx_dma);\n\n\t \n\tspi_writel(as, IER, SPI_BIT(OVRES));\n\n\t \n\trxdesc->callback = dma_callback;\n\trxdesc->callback_param = host;\n\n\t \n\tcookie = rxdesc->tx_submit(rxdesc);\n\tif (dma_submit_error(cookie))\n\t\tgoto err_dma;\n\tcookie = txdesc->tx_submit(txdesc);\n\tif (dma_submit_error(cookie))\n\t\tgoto err_dma;\n\trxchan->device->device_issue_pending(rxchan);\n\ttxchan->device->device_issue_pending(txchan);\n\n\treturn 0;\n\nerr_dma:\n\tspi_writel(as, IDR, SPI_BIT(OVRES));\n\tatmel_spi_stop_dma(host);\nerr_exit:\n\treturn -ENOMEM;\n}\n\nstatic void atmel_spi_next_xfer_data(struct spi_controller *host,\n\t\t\t\tstruct spi_transfer *xfer,\n\t\t\t\tdma_addr_t *tx_dma,\n\t\t\t\tdma_addr_t *rx_dma,\n\t\t\t\tu32 *plen)\n{\n\t*rx_dma = xfer->rx_dma + xfer->len - *plen;\n\t*tx_dma = xfer->tx_dma + xfer->len - *plen;\n\tif (*plen > host->max_dma_len)\n\t\t*plen = host->max_dma_len;\n}\n\nstatic int atmel_spi_set_xfer_speed(struct atmel_spi *as,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tu32\t\t\tscbr, csr;\n\tunsigned long\t\tbus_hz;\n\tint chip_select;\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tchip_select = as->native_cs_for_gpio;\n\telse\n\t\tchip_select = spi_get_chipselect(spi, 0);\n\n\t \n\tbus_hz = as->spi_clk;\n\tif (!atmel_spi_is_v2(as))\n\t\tbus_hz /= 2;\n\n\t \n\tscbr = DIV_ROUND_UP(bus_hz, xfer->speed_hz);\n\n\t \n\tif (scbr >= (1 << SPI_SCBR_SIZE)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"setup: %d Hz too slow, scbr %u; min %ld Hz\\n\",\n\t\t\txfer->speed_hz, scbr, bus_hz/255);\n\t\treturn -EINVAL;\n\t}\n\tif (scbr == 0) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"setup: %d Hz too high, scbr %u; max %ld Hz\\n\",\n\t\t\txfer->speed_hz, scbr, bus_hz);\n\t\treturn -EINVAL;\n\t}\n\tcsr = spi_readl(as, CSR0 + 4 * chip_select);\n\tcsr = SPI_BFINS(SCBR, scbr, csr);\n\tspi_writel(as, CSR0 + 4 * chip_select, csr);\n\txfer->effective_speed_hz = bus_hz / scbr;\n\n\treturn 0;\n}\n\n \nstatic void atmel_spi_pdc_next_xfer(struct spi_controller *host,\n\t\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\tu32\t\t\tlen;\n\tdma_addr_t\t\ttx_dma, rx_dma;\n\n\tspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\n\n\tlen = as->current_remaining_bytes;\n\tatmel_spi_next_xfer_data(host, xfer, &tx_dma, &rx_dma, &len);\n\tas->current_remaining_bytes -= len;\n\n\tspi_writel(as, RPR, rx_dma);\n\tspi_writel(as, TPR, tx_dma);\n\n\tif (xfer->bits_per_word > 8)\n\t\tlen >>= 1;\n\tspi_writel(as, RCR, len);\n\tspi_writel(as, TCR, len);\n\n\tdev_dbg(&host->dev,\n\t\t\"  start xfer %p: len %u tx %p/%08llx rx %p/%08llx\\n\",\n\t\txfer, xfer->len, xfer->tx_buf,\n\t\t(unsigned long long)xfer->tx_dma, xfer->rx_buf,\n\t\t(unsigned long long)xfer->rx_dma);\n\n\tif (as->current_remaining_bytes) {\n\t\tlen = as->current_remaining_bytes;\n\t\tatmel_spi_next_xfer_data(host, xfer, &tx_dma, &rx_dma, &len);\n\t\tas->current_remaining_bytes -= len;\n\n\t\tspi_writel(as, RNPR, rx_dma);\n\t\tspi_writel(as, TNPR, tx_dma);\n\n\t\tif (xfer->bits_per_word > 8)\n\t\t\tlen >>= 1;\n\t\tspi_writel(as, RNCR, len);\n\t\tspi_writel(as, TNCR, len);\n\n\t\tdev_dbg(&host->dev,\n\t\t\t\"  next xfer %p: len %u tx %p/%08llx rx %p/%08llx\\n\",\n\t\t\txfer, xfer->len, xfer->tx_buf,\n\t\t\t(unsigned long long)xfer->tx_dma, xfer->rx_buf,\n\t\t\t(unsigned long long)xfer->rx_dma);\n\t}\n\n\t \n\tspi_writel(as, IER, SPI_BIT(RXBUFF) | SPI_BIT(OVRES));\n\tspi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));\n}\n\n \nstatic int\natmel_spi_dma_map_xfer(struct atmel_spi *as, struct spi_transfer *xfer)\n{\n\tstruct device\t*dev = &as->pdev->dev;\n\n\txfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;\n\tif (xfer->tx_buf) {\n\t\t \n\t\tvoid *nonconst_tx = (void *)xfer->tx_buf;\n\n\t\txfer->tx_dma = dma_map_single(dev,\n\t\t\t\tnonconst_tx, xfer->len,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->tx_dma))\n\t\t\treturn -ENOMEM;\n\t}\n\tif (xfer->rx_buf) {\n\t\txfer->rx_dma = dma_map_single(dev,\n\t\t\t\txfer->rx_buf, xfer->len,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, xfer->rx_dma)) {\n\t\t\tif (xfer->tx_buf)\n\t\t\t\tdma_unmap_single(dev,\n\t\t\t\t\t\txfer->tx_dma, xfer->len,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void atmel_spi_dma_unmap_xfer(struct spi_controller *host,\n\t\t\t\t     struct spi_transfer *xfer)\n{\n\tif (xfer->tx_dma != INVALID_DMA_ADDRESS)\n\t\tdma_unmap_single(host->dev.parent, xfer->tx_dma,\n\t\t\t\t xfer->len, DMA_TO_DEVICE);\n\tif (xfer->rx_dma != INVALID_DMA_ADDRESS)\n\t\tdma_unmap_single(host->dev.parent, xfer->rx_dma,\n\t\t\t\t xfer->len, DMA_FROM_DEVICE);\n}\n\nstatic void atmel_spi_disable_pdc_transfer(struct atmel_spi *as)\n{\n\tspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\n}\n\nstatic void\natmel_spi_pump_single_data(struct atmel_spi *as, struct spi_transfer *xfer)\n{\n\tu8\t\t*rxp;\n\tu16\t\t*rxp16;\n\tunsigned long\txfer_pos = xfer->len - as->current_remaining_bytes;\n\n\tif (xfer->bits_per_word > 8) {\n\t\trxp16 = (u16 *)(((u8 *)xfer->rx_buf) + xfer_pos);\n\t\t*rxp16 = spi_readl(as, RDR);\n\t} else {\n\t\trxp = ((u8 *)xfer->rx_buf) + xfer_pos;\n\t\t*rxp = spi_readl(as, RDR);\n\t}\n\tif (xfer->bits_per_word > 8) {\n\t\tif (as->current_remaining_bytes > 2)\n\t\t\tas->current_remaining_bytes -= 2;\n\t\telse\n\t\t\tas->current_remaining_bytes = 0;\n\t} else {\n\t\tas->current_remaining_bytes--;\n\t}\n}\n\nstatic void\natmel_spi_pump_fifo_data(struct atmel_spi *as, struct spi_transfer *xfer)\n{\n\tu32 fifolr = spi_readl(as, FLR);\n\tu32 num_bytes, num_data = SPI_BFEXT(RXFL, fifolr);\n\tu32 offset = xfer->len - as->current_remaining_bytes;\n\tu16 *words = (u16 *)((u8 *)xfer->rx_buf + offset);\n\tu8  *bytes = (u8  *)((u8 *)xfer->rx_buf + offset);\n\tu16 rd;  \n\n\t \n\tnum_bytes = ((xfer->bits_per_word > 8) ?\n\t\t     (num_data << 1) :\n\t\t     num_data);\n\n\tif (as->current_remaining_bytes > num_bytes)\n\t\tas->current_remaining_bytes -= num_bytes;\n\telse\n\t\tas->current_remaining_bytes = 0;\n\n\t \n\tif (xfer->bits_per_word > 8)\n\t\tas->current_remaining_bytes &= ~0x1;\n\n\t \n\twhile (num_data) {\n\t\trd = spi_readl(as, RDR);\n\t\tif (xfer->bits_per_word > 8)\n\t\t\t*words++ = rd;\n\t\telse\n\t\t\t*bytes++ = rd;\n\t\tnum_data--;\n\t}\n}\n\n \nstatic void\natmel_spi_pump_pio_data(struct atmel_spi *as, struct spi_transfer *xfer)\n{\n\tif (as->fifo_size)\n\t\tatmel_spi_pump_fifo_data(as, xfer);\n\telse\n\t\tatmel_spi_pump_single_data(as, xfer);\n}\n\n \nstatic irqreturn_t\natmel_spi_pio_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller\t*host = dev_id;\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\tu32\t\t\tstatus, pending, imr;\n\tstruct spi_transfer\t*xfer;\n\tint\t\t\tret = IRQ_NONE;\n\n\timr = spi_readl(as, IMR);\n\tstatus = spi_readl(as, SR);\n\tpending = status & imr;\n\n\tif (pending & SPI_BIT(OVRES)) {\n\t\tret = IRQ_HANDLED;\n\t\tspi_writel(as, IDR, SPI_BIT(OVRES));\n\t\tdev_warn(host->dev.parent, \"overrun\\n\");\n\n\t\t \n\t\tas->done_status = -EIO;\n\t\tsmp_wmb();\n\n\t\t \n\t\tspi_readl(as, SR);\n\n\t\tcomplete(&as->xfer_completion);\n\n\t} else if (pending & (SPI_BIT(RDRF) | SPI_BIT(RXFTHF))) {\n\t\tatmel_spi_lock(as);\n\n\t\tif (as->current_remaining_bytes) {\n\t\t\tret = IRQ_HANDLED;\n\t\t\txfer = as->current_transfer;\n\t\t\tatmel_spi_pump_pio_data(as, xfer);\n\t\t\tif (!as->current_remaining_bytes)\n\t\t\t\tspi_writel(as, IDR, pending);\n\n\t\t\tcomplete(&as->xfer_completion);\n\t\t}\n\n\t\tatmel_spi_unlock(as);\n\t} else {\n\t\tWARN_ONCE(pending, \"IRQ not handled, pending = %x\\n\", pending);\n\t\tret = IRQ_HANDLED;\n\t\tspi_writel(as, IDR, pending);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t\natmel_spi_pdc_interrupt(int irq, void *dev_id)\n{\n\tstruct spi_controller\t*host = dev_id;\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\tu32\t\t\tstatus, pending, imr;\n\tint\t\t\tret = IRQ_NONE;\n\n\timr = spi_readl(as, IMR);\n\tstatus = spi_readl(as, SR);\n\tpending = status & imr;\n\n\tif (pending & SPI_BIT(OVRES)) {\n\n\t\tret = IRQ_HANDLED;\n\n\t\tspi_writel(as, IDR, (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX)\n\t\t\t\t     | SPI_BIT(OVRES)));\n\n\t\t \n\t\tspi_readl(as, SR);\n\n\t\tas->done_status = -EIO;\n\n\t\tcomplete(&as->xfer_completion);\n\n\t} else if (pending & (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX))) {\n\t\tret = IRQ_HANDLED;\n\n\t\tspi_writel(as, IDR, pending);\n\n\t\tcomplete(&as->xfer_completion);\n\t}\n\n\treturn ret;\n}\n\nstatic int atmel_word_delay_csr(struct spi_device *spi, struct atmel_spi *as)\n{\n\tstruct spi_delay *delay = &spi->word_delay;\n\tu32 value = delay->value;\n\n\tswitch (delay->unit) {\n\tcase SPI_DELAY_UNIT_NSECS:\n\t\tvalue /= 1000;\n\t\tbreak;\n\tcase SPI_DELAY_UNIT_USECS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn (as->spi_clk / 1000000 * value) >> 5;\n}\n\nstatic void initialize_native_cs_for_gpio(struct atmel_spi *as)\n{\n\tint i;\n\tstruct spi_controller *host = platform_get_drvdata(as->pdev);\n\n\tif (!as->native_cs_free)\n\t\treturn;  \n\n\tif (!host->cs_gpiods)\n\t\treturn;  \n\n\t \n\tif (atmel_spi_is_v2(as))\n\t\ti = 0;\n\telse\n\t\ti = 1;\n\n\tfor (; i < 4; i++)\n\t\tif (host->cs_gpiods[i])\n\t\t\tas->native_cs_free |= BIT(i);\n\n\tif (as->native_cs_free)\n\t\tas->native_cs_for_gpio = ffs(as->native_cs_free);\n}\n\nstatic int atmel_spi_setup(struct spi_device *spi)\n{\n\tstruct atmel_spi\t*as;\n\tstruct atmel_spi_device\t*asd;\n\tu32\t\t\tcsr;\n\tunsigned int\t\tbits = spi->bits_per_word;\n\tint chip_select;\n\tint\t\t\tword_delay_csr;\n\n\tas = spi_controller_get_devdata(spi->controller);\n\n\t \n\tif (!spi_get_csgpiod(spi, 0) && (spi->mode & SPI_CS_HIGH)) {\n\t\tdev_warn(&spi->dev, \"setup: non GPIO CS can't be active-high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinitialize_native_cs_for_gpio(as);\n\n\tif (spi_get_csgpiod(spi, 0) && as->native_cs_free) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"No native CS available to support this GPIO CS\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tchip_select = as->native_cs_for_gpio;\n\telse\n\t\tchip_select = spi_get_chipselect(spi, 0);\n\n\tcsr = SPI_BF(BITS, bits - 8);\n\tif (spi->mode & SPI_CPOL)\n\t\tcsr |= SPI_BIT(CPOL);\n\tif (!(spi->mode & SPI_CPHA))\n\t\tcsr |= SPI_BIT(NCPHA);\n\n\tif (!spi_get_csgpiod(spi, 0))\n\t\tcsr |= SPI_BIT(CSAAT);\n\tcsr |= SPI_BF(DLYBS, 0);\n\n\tword_delay_csr = atmel_word_delay_csr(spi, as);\n\tif (word_delay_csr < 0)\n\t\treturn word_delay_csr;\n\n\t \n\tcsr |= SPI_BF(DLYBCT, word_delay_csr);\n\n\tasd = spi->controller_state;\n\tif (!asd) {\n\t\tasd = kzalloc(sizeof(struct atmel_spi_device), GFP_KERNEL);\n\t\tif (!asd)\n\t\t\treturn -ENOMEM;\n\n\t\tspi->controller_state = asd;\n\t}\n\n\tasd->csr = csr;\n\n\tdev_dbg(&spi->dev,\n\t\t\"setup: bpw %u mode 0x%x -> csr%d %08x\\n\",\n\t\tbits, spi->mode, spi_get_chipselect(spi, 0), csr);\n\n\tif (!atmel_spi_is_v2(as))\n\t\tspi_writel(as, CSR0 + 4 * chip_select, csr);\n\n\treturn 0;\n}\n\nstatic void atmel_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct atmel_spi *as = spi_controller_get_devdata(spi->controller);\n\t \n\tenable = (!!(spi->mode & SPI_CS_HIGH) == enable);\n\n\tif (enable) {\n\t\tcs_activate(as, spi);\n\t} else {\n\t\tcs_deactivate(as, spi);\n\t}\n\n}\n\nstatic int atmel_spi_one_transfer(struct spi_controller *host,\n\t\t\t\t\tstruct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct atmel_spi\t*as;\n\tu8\t\t\tbits;\n\tu32\t\t\tlen;\n\tstruct atmel_spi_device\t*asd;\n\tint\t\t\ttimeout;\n\tint\t\t\tret;\n\tunsigned int\t\tdma_timeout;\n\tlong\t\t\tret_timeout;\n\n\tas = spi_controller_get_devdata(host);\n\n\tasd = spi->controller_state;\n\tbits = (asd->csr >> 4) & 0xf;\n\tif (bits != xfer->bits_per_word - 8) {\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"you can't yet change bits_per_word in transfers\\n\");\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\t \n\tif ((!host->cur_msg->is_dma_mapped)\n\t\t&& as->use_pdc) {\n\t\tif (atmel_spi_dma_map_xfer(as, xfer) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tatmel_spi_set_xfer_speed(as, spi, xfer);\n\n\tas->done_status = 0;\n\tas->current_transfer = xfer;\n\tas->current_remaining_bytes = xfer->len;\n\twhile (as->current_remaining_bytes) {\n\t\treinit_completion(&as->xfer_completion);\n\n\t\tif (as->use_pdc) {\n\t\t\tatmel_spi_lock(as);\n\t\t\tatmel_spi_pdc_next_xfer(host, xfer);\n\t\t\tatmel_spi_unlock(as);\n\t\t} else if (atmel_spi_use_dma(as, xfer)) {\n\t\t\tlen = as->current_remaining_bytes;\n\t\t\tret = atmel_spi_next_xfer_dma_submit(host,\n\t\t\t\t\t\t\t\txfer, &len);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"unable to use DMA, fallback to PIO\\n\");\n\t\t\t\tas->done_status = ret;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tas->current_remaining_bytes -= len;\n\t\t\t\tif (as->current_remaining_bytes < 0)\n\t\t\t\t\tas->current_remaining_bytes = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tatmel_spi_lock(as);\n\t\t\tatmel_spi_next_xfer_pio(host, xfer);\n\t\t\tatmel_spi_unlock(as);\n\t\t}\n\n\t\tdma_timeout = msecs_to_jiffies(spi_controller_xfer_timeout(host, xfer));\n\t\tret_timeout = wait_for_completion_timeout(&as->xfer_completion, dma_timeout);\n\t\tif (!ret_timeout) {\n\t\t\tdev_err(&spi->dev, \"spi transfer timeout\\n\");\n\t\t\tas->done_status = -EIO;\n\t\t}\n\n\t\tif (as->done_status)\n\t\t\tbreak;\n\t}\n\n\tif (as->done_status) {\n\t\tif (as->use_pdc) {\n\t\t\tdev_warn(host->dev.parent,\n\t\t\t\t\"overrun (%u/%u remaining)\\n\",\n\t\t\t\tspi_readl(as, TCR), spi_readl(as, RCR));\n\n\t\t\t \n\t\t\tspi_writel(as, RNCR, 0);\n\t\t\tspi_writel(as, TNCR, 0);\n\t\t\tspi_writel(as, RCR, 0);\n\t\t\tspi_writel(as, TCR, 0);\n\t\t\tfor (timeout = 1000; timeout; timeout--)\n\t\t\t\tif (spi_readl(as, SR) & SPI_BIT(TXEMPTY))\n\t\t\t\t\tbreak;\n\t\t\tif (!timeout)\n\t\t\t\tdev_warn(host->dev.parent,\n\t\t\t\t\t \"timeout waiting for TXEMPTY\");\n\t\t\twhile (spi_readl(as, SR) & SPI_BIT(RDRF))\n\t\t\t\tspi_readl(as, RDR);\n\n\t\t\t \n\t\t\tspi_readl(as, SR);\n\n\t\t} else if (atmel_spi_use_dma(as, xfer)) {\n\t\t\tatmel_spi_stop_dma(host);\n\t\t}\n\t}\n\n\tif (!host->cur_msg->is_dma_mapped\n\t\t&& as->use_pdc)\n\t\tatmel_spi_dma_unmap_xfer(host, xfer);\n\n\tif (as->use_pdc)\n\t\tatmel_spi_disable_pdc_transfer(as);\n\n\treturn as->done_status;\n}\n\nstatic void atmel_spi_cleanup(struct spi_device *spi)\n{\n\tstruct atmel_spi_device\t*asd = spi->controller_state;\n\n\tif (!asd)\n\t\treturn;\n\n\tspi->controller_state = NULL;\n\tkfree(asd);\n}\n\nstatic inline unsigned int atmel_get_version(struct atmel_spi *as)\n{\n\treturn spi_readl(as, VERSION) & 0x00000fff;\n}\n\nstatic void atmel_get_caps(struct atmel_spi *as)\n{\n\tunsigned int version;\n\n\tversion = atmel_get_version(as);\n\n\tas->caps.is_spi2 = version > 0x121;\n\tas->caps.has_wdrbt = version >= 0x210;\n\tas->caps.has_dma_support = version >= 0x212;\n\tas->caps.has_pdc_support = version < 0x212;\n}\n\nstatic void atmel_spi_init(struct atmel_spi *as)\n{\n\tspi_writel(as, CR, SPI_BIT(SWRST));\n\tspi_writel(as, CR, SPI_BIT(SWRST));  \n\n\t \n\tif (as->fifo_size)\n\t\tspi_writel(as, CR, SPI_BIT(FIFOEN));\n\n\tif (as->caps.has_wdrbt) {\n\t\tspi_writel(as, MR, SPI_BIT(WDRBT) | SPI_BIT(MODFDIS)\n\t\t\t\t| SPI_BIT(MSTR));\n\t} else {\n\t\tspi_writel(as, MR, SPI_BIT(MSTR) | SPI_BIT(MODFDIS));\n\t}\n\n\tif (as->use_pdc)\n\t\tspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\n\tspi_writel(as, CR, SPI_BIT(SPIEN));\n}\n\nstatic int atmel_spi_probe(struct platform_device *pdev)\n{\n\tstruct resource\t\t*regs;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tint\t\t\tret;\n\tstruct spi_controller\t*host;\n\tstruct atmel_spi\t*as;\n\n\t \n\tpinctrl_pm_select_default_state(&pdev->dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tclk = devm_clk_get(&pdev->dev, \"spi_clk\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\t \n\thost = spi_alloc_host(&pdev->dev, sizeof(*as));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\thost->use_gpio_descriptors = true;\n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = pdev->id;\n\thost->num_chipselect = 4;\n\thost->setup = atmel_spi_setup;\n\thost->flags = (SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX |\n\t\t\tSPI_CONTROLLER_GPIO_SS);\n\thost->transfer_one = atmel_spi_one_transfer;\n\thost->set_cs = atmel_spi_set_cs;\n\thost->cleanup = atmel_spi_cleanup;\n\thost->auto_runtime_pm = true;\n\thost->max_dma_len = SPI_MAX_DMA_XFER;\n\thost->can_dma = atmel_spi_can_dma;\n\tplatform_set_drvdata(pdev, host);\n\n\tas = spi_controller_get_devdata(host);\n\n\tspin_lock_init(&as->lock);\n\n\tas->pdev = pdev;\n\tas->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(as->regs)) {\n\t\tret = PTR_ERR(as->regs);\n\t\tgoto out_unmap_regs;\n\t}\n\tas->phybase = regs->start;\n\tas->irq = irq;\n\tas->clk = clk;\n\n\tinit_completion(&as->xfer_completion);\n\n\tatmel_get_caps(as);\n\n\tas->use_dma = false;\n\tas->use_pdc = false;\n\tif (as->caps.has_dma_support) {\n\t\tret = atmel_spi_configure_dma(host, as);\n\t\tif (ret == 0) {\n\t\t\tas->use_dma = true;\n\t\t} else if (ret == -EPROBE_DEFER) {\n\t\t\tgoto out_unmap_regs;\n\t\t}\n\t} else if (as->caps.has_pdc_support) {\n\t\tas->use_pdc = true;\n\t}\n\n\tif (IS_ENABLED(CONFIG_SOC_SAM_V4_V5)) {\n\t\tas->addr_rx_bbuf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t      SPI_MAX_DMA_XFER,\n\t\t\t\t\t\t      &as->dma_addr_rx_bbuf,\n\t\t\t\t\t\t      GFP_KERNEL | GFP_DMA);\n\t\tif (!as->addr_rx_bbuf) {\n\t\t\tas->use_dma = false;\n\t\t} else {\n\t\t\tas->addr_tx_bbuf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tSPI_MAX_DMA_XFER,\n\t\t\t\t\t&as->dma_addr_tx_bbuf,\n\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\t\t\tif (!as->addr_tx_bbuf) {\n\t\t\t\tas->use_dma = false;\n\t\t\t\tdma_free_coherent(&pdev->dev, SPI_MAX_DMA_XFER,\n\t\t\t\t\t\t  as->addr_rx_bbuf,\n\t\t\t\t\t\t  as->dma_addr_rx_bbuf);\n\t\t\t}\n\t\t}\n\t\tif (!as->use_dma)\n\t\t\tdev_info(host->dev.parent,\n\t\t\t\t \"  can not allocate dma coherent memory\\n\");\n\t}\n\n\tif (as->caps.has_dma_support && !as->use_dma)\n\t\tdev_info(&pdev->dev, \"Atmel SPI Controller using PIO only\\n\");\n\n\tif (as->use_pdc) {\n\t\tret = devm_request_irq(&pdev->dev, irq, atmel_spi_pdc_interrupt,\n\t\t\t\t\t0, dev_name(&pdev->dev), host);\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, irq, atmel_spi_pio_interrupt,\n\t\t\t\t\t0, dev_name(&pdev->dev), host);\n\t}\n\tif (ret)\n\t\tgoto out_unmap_regs;\n\n\t \n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tas->spi_clk = clk_get_rate(clk);\n\n\tas->fifo_size = 0;\n\tif (!of_property_read_u32(pdev->dev.of_node, \"atmel,fifo-size\",\n\t\t\t\t  &as->fifo_size)) {\n\t\tdev_info(&pdev->dev, \"Using FIFO (%u data)\\n\", as->fifo_size);\n\t}\n\n\tatmel_spi_init(as);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\t \n\tdev_info(&pdev->dev, \"Atmel SPI Controller version 0x%x at 0x%08lx (irq %d)\\n\",\n\t\t\tatmel_get_version(as), (unsigned long)regs->start,\n\t\t\tirq);\n\n\treturn 0;\n\nout_free_dma:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tif (as->use_dma)\n\t\tatmel_spi_release_dma(host);\n\n\tspi_writel(as, CR, SPI_BIT(SWRST));\n\tspi_writel(as, CR, SPI_BIT(SWRST));  \n\tclk_disable_unprepare(clk);\nout_free_irq:\nout_unmap_regs:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic void atmel_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller\t*host = platform_get_drvdata(pdev);\n\tstruct atmel_spi\t*as = spi_controller_get_devdata(host);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\tif (as->use_dma) {\n\t\tatmel_spi_stop_dma(host);\n\t\tatmel_spi_release_dma(host);\n\t\tif (IS_ENABLED(CONFIG_SOC_SAM_V4_V5)) {\n\t\t\tdma_free_coherent(&pdev->dev, SPI_MAX_DMA_XFER,\n\t\t\t\t\t  as->addr_tx_bbuf,\n\t\t\t\t\t  as->dma_addr_tx_bbuf);\n\t\t\tdma_free_coherent(&pdev->dev, SPI_MAX_DMA_XFER,\n\t\t\t\t\t  as->addr_rx_bbuf,\n\t\t\t\t\t  as->dma_addr_rx_bbuf);\n\t\t}\n\t}\n\n\tspin_lock_irq(&as->lock);\n\tspi_writel(as, CR, SPI_BIT(SWRST));\n\tspi_writel(as, CR, SPI_BIT(SWRST));  \n\tspi_readl(as, SR);\n\tspin_unlock_irq(&as->lock);\n\n\tclk_disable_unprepare(as->clk);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int atmel_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\n\tclk_disable_unprepare(as->clk);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int atmel_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn clk_prepare_enable(as->clk);\n}\n\nstatic int atmel_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tatmel_spi_runtime_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int atmel_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct atmel_spi *as = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(as->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tatmel_spi_init(as);\n\n\tclk_disable_unprepare(as->clk);\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = atmel_spi_runtime_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn spi_controller_resume(host);\n}\n\nstatic const struct dev_pm_ops atmel_spi_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(atmel_spi_suspend, atmel_spi_resume)\n\tRUNTIME_PM_OPS(atmel_spi_runtime_suspend,\n\t\t       atmel_spi_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id atmel_spi_dt_ids[] = {\n\t{ .compatible = \"atmel,at91rm9200-spi\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_spi_dt_ids);\n\nstatic struct platform_driver atmel_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_spi\",\n\t\t.pm\t= pm_ptr(&atmel_spi_pm_ops),\n\t\t.of_match_table\t= atmel_spi_dt_ids,\n\t},\n\t.probe\t\t= atmel_spi_probe,\n\t.remove_new\t= atmel_spi_remove,\n};\nmodule_platform_driver(atmel_spi_driver);\n\nMODULE_DESCRIPTION(\"Atmel AT32/AT91 SPI Controller driver\");\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:atmel_spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}