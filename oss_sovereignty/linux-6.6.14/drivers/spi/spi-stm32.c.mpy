{
  "module_name": "spi-stm32.c",
  "hash_id": "f5283702b40b5b5878c3f4352b5c3b0ac3f0b17b2c02c8e2df4faec41ca0dd35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-stm32.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n\n#define DRIVER_NAME \"spi_stm32\"\n\n \n#define STM32F4_SPI_CR1\t\t\t0x00\n#define STM32F4_SPI_CR2\t\t\t0x04\n#define STM32F4_SPI_SR\t\t\t0x08\n#define STM32F4_SPI_DR\t\t\t0x0C\n#define STM32F4_SPI_I2SCFGR\t\t0x1C\n\n \n#define STM32F4_SPI_CR1_CPHA\t\tBIT(0)\n#define STM32F4_SPI_CR1_CPOL\t\tBIT(1)\n#define STM32F4_SPI_CR1_MSTR\t\tBIT(2)\n#define STM32F4_SPI_CR1_BR_SHIFT\t3\n#define STM32F4_SPI_CR1_BR\t\tGENMASK(5, 3)\n#define STM32F4_SPI_CR1_SPE\t\tBIT(6)\n#define STM32F4_SPI_CR1_LSBFRST\t\tBIT(7)\n#define STM32F4_SPI_CR1_SSI\t\tBIT(8)\n#define STM32F4_SPI_CR1_SSM\t\tBIT(9)\n#define STM32F4_SPI_CR1_RXONLY\t\tBIT(10)\n#define STM32F4_SPI_CR1_DFF\t\tBIT(11)\n#define STM32F4_SPI_CR1_CRCNEXT\t\tBIT(12)\n#define STM32F4_SPI_CR1_CRCEN\t\tBIT(13)\n#define STM32F4_SPI_CR1_BIDIOE\t\tBIT(14)\n#define STM32F4_SPI_CR1_BIDIMODE\tBIT(15)\n#define STM32F4_SPI_CR1_BR_MIN\t\t0\n#define STM32F4_SPI_CR1_BR_MAX\t\t(GENMASK(5, 3) >> 3)\n\n \n#define STM32F4_SPI_CR2_RXDMAEN\t\tBIT(0)\n#define STM32F4_SPI_CR2_TXDMAEN\t\tBIT(1)\n#define STM32F4_SPI_CR2_SSOE\t\tBIT(2)\n#define STM32F4_SPI_CR2_FRF\t\tBIT(4)\n#define STM32F4_SPI_CR2_ERRIE\t\tBIT(5)\n#define STM32F4_SPI_CR2_RXNEIE\t\tBIT(6)\n#define STM32F4_SPI_CR2_TXEIE\t\tBIT(7)\n\n \n#define STM32F4_SPI_SR_RXNE\t\tBIT(0)\n#define STM32F4_SPI_SR_TXE\t\tBIT(1)\n#define STM32F4_SPI_SR_CHSIDE\t\tBIT(2)\n#define STM32F4_SPI_SR_UDR\t\tBIT(3)\n#define STM32F4_SPI_SR_CRCERR\t\tBIT(4)\n#define STM32F4_SPI_SR_MODF\t\tBIT(5)\n#define STM32F4_SPI_SR_OVR\t\tBIT(6)\n#define STM32F4_SPI_SR_BSY\t\tBIT(7)\n#define STM32F4_SPI_SR_FRE\t\tBIT(8)\n\n \n#define STM32F4_SPI_I2SCFGR_I2SMOD\tBIT(11)\n\n \n#define STM32F4_SPI_BR_DIV_MIN\t\t(2 << STM32F4_SPI_CR1_BR_MIN)\n#define STM32F4_SPI_BR_DIV_MAX\t\t(2 << STM32F4_SPI_CR1_BR_MAX)\n\n \n#define STM32H7_SPI_CR1\t\t\t0x00\n#define STM32H7_SPI_CR2\t\t\t0x04\n#define STM32H7_SPI_CFG1\t\t0x08\n#define STM32H7_SPI_CFG2\t\t0x0C\n#define STM32H7_SPI_IER\t\t\t0x10\n#define STM32H7_SPI_SR\t\t\t0x14\n#define STM32H7_SPI_IFCR\t\t0x18\n#define STM32H7_SPI_TXDR\t\t0x20\n#define STM32H7_SPI_RXDR\t\t0x30\n#define STM32H7_SPI_I2SCFGR\t\t0x50\n\n \n#define STM32H7_SPI_CR1_SPE\t\tBIT(0)\n#define STM32H7_SPI_CR1_MASRX\t\tBIT(8)\n#define STM32H7_SPI_CR1_CSTART\t\tBIT(9)\n#define STM32H7_SPI_CR1_CSUSP\t\tBIT(10)\n#define STM32H7_SPI_CR1_HDDIR\t\tBIT(11)\n#define STM32H7_SPI_CR1_SSI\t\tBIT(12)\n\n \n#define STM32H7_SPI_CR2_TSIZE\t\tGENMASK(15, 0)\n#define STM32H7_SPI_TSIZE_MAX\t\tGENMASK(15, 0)\n\n \n#define STM32H7_SPI_CFG1_DSIZE\t\tGENMASK(4, 0)\n#define STM32H7_SPI_CFG1_FTHLV\t\tGENMASK(8, 5)\n#define STM32H7_SPI_CFG1_RXDMAEN\tBIT(14)\n#define STM32H7_SPI_CFG1_TXDMAEN\tBIT(15)\n#define STM32H7_SPI_CFG1_MBR\t\tGENMASK(30, 28)\n#define STM32H7_SPI_CFG1_MBR_SHIFT\t28\n#define STM32H7_SPI_CFG1_MBR_MIN\t0\n#define STM32H7_SPI_CFG1_MBR_MAX\t(GENMASK(30, 28) >> 28)\n\n \n#define STM32H7_SPI_CFG2_MIDI\t\tGENMASK(7, 4)\n#define STM32H7_SPI_CFG2_COMM\t\tGENMASK(18, 17)\n#define STM32H7_SPI_CFG2_SP\t\tGENMASK(21, 19)\n#define STM32H7_SPI_CFG2_MASTER\t\tBIT(22)\n#define STM32H7_SPI_CFG2_LSBFRST\tBIT(23)\n#define STM32H7_SPI_CFG2_CPHA\t\tBIT(24)\n#define STM32H7_SPI_CFG2_CPOL\t\tBIT(25)\n#define STM32H7_SPI_CFG2_SSM\t\tBIT(26)\n#define STM32H7_SPI_CFG2_SSIOP\t\tBIT(28)\n#define STM32H7_SPI_CFG2_AFCNTR\t\tBIT(31)\n\n \n#define STM32H7_SPI_IER_RXPIE\t\tBIT(0)\n#define STM32H7_SPI_IER_TXPIE\t\tBIT(1)\n#define STM32H7_SPI_IER_DXPIE\t\tBIT(2)\n#define STM32H7_SPI_IER_EOTIE\t\tBIT(3)\n#define STM32H7_SPI_IER_TXTFIE\t\tBIT(4)\n#define STM32H7_SPI_IER_OVRIE\t\tBIT(6)\n#define STM32H7_SPI_IER_MODFIE\t\tBIT(9)\n#define STM32H7_SPI_IER_ALL\t\tGENMASK(10, 0)\n\n \n#define STM32H7_SPI_SR_RXP\t\tBIT(0)\n#define STM32H7_SPI_SR_TXP\t\tBIT(1)\n#define STM32H7_SPI_SR_EOT\t\tBIT(3)\n#define STM32H7_SPI_SR_OVR\t\tBIT(6)\n#define STM32H7_SPI_SR_MODF\t\tBIT(9)\n#define STM32H7_SPI_SR_SUSP\t\tBIT(11)\n#define STM32H7_SPI_SR_RXPLVL\t\tGENMASK(14, 13)\n#define STM32H7_SPI_SR_RXWNE\t\tBIT(15)\n\n \n#define STM32H7_SPI_IFCR_ALL\t\tGENMASK(11, 3)\n\n \n#define STM32H7_SPI_I2SCFGR_I2SMOD\tBIT(0)\n\n \n#define STM32H7_SPI_MBR_DIV_MIN\t\t(2 << STM32H7_SPI_CFG1_MBR_MIN)\n#define STM32H7_SPI_MBR_DIV_MAX\t\t(2 << STM32H7_SPI_CFG1_MBR_MAX)\n\n \n#define STM32H7_SPI_FULL_DUPLEX\t\t0\n#define STM32H7_SPI_SIMPLEX_TX\t\t1\n#define STM32H7_SPI_SIMPLEX_RX\t\t2\n#define STM32H7_SPI_HALF_DUPLEX\t\t3\n\n \n#define SPI_FULL_DUPLEX\t\t0\n#define SPI_SIMPLEX_TX\t\t1\n#define SPI_SIMPLEX_RX\t\t2\n#define SPI_3WIRE_TX\t\t3\n#define SPI_3WIRE_RX\t\t4\n\n#define STM32_SPI_AUTOSUSPEND_DELAY\t\t1\t \n\n \n#define SPI_DMA_MIN_BYTES\t16\n\n \n#define STM32_SPI_MASTER_MODE(stm32_spi) (!(stm32_spi)->device_mode)\n#define STM32_SPI_DEVICE_MODE(stm32_spi) ((stm32_spi)->device_mode)\n\n \nstruct stm32_spi_reg {\n\tint reg;\n\tint mask;\n\tint shift;\n};\n\n \nstruct stm32_spi_regspec {\n\tconst struct stm32_spi_reg en;\n\tconst struct stm32_spi_reg dma_rx_en;\n\tconst struct stm32_spi_reg dma_tx_en;\n\tconst struct stm32_spi_reg cpol;\n\tconst struct stm32_spi_reg cpha;\n\tconst struct stm32_spi_reg lsb_first;\n\tconst struct stm32_spi_reg cs_high;\n\tconst struct stm32_spi_reg br;\n\tconst struct stm32_spi_reg rx;\n\tconst struct stm32_spi_reg tx;\n};\n\nstruct stm32_spi;\n\n \nstruct stm32_spi_cfg {\n\tconst struct stm32_spi_regspec *regs;\n\tint (*get_fifo_size)(struct stm32_spi *spi);\n\tint (*get_bpw_mask)(struct stm32_spi *spi);\n\tvoid (*disable)(struct stm32_spi *spi);\n\tint (*config)(struct stm32_spi *spi);\n\tvoid (*set_bpw)(struct stm32_spi *spi);\n\tint (*set_mode)(struct stm32_spi *spi, unsigned int comm_type);\n\tvoid (*set_data_idleness)(struct stm32_spi *spi, u32 length);\n\tint (*set_number_of_data)(struct stm32_spi *spi, u32 length);\n\tvoid (*transfer_one_dma_start)(struct stm32_spi *spi);\n\tvoid (*dma_rx_cb)(void *data);\n\tvoid (*dma_tx_cb)(void *data);\n\tint (*transfer_one_irq)(struct stm32_spi *spi);\n\tirqreturn_t (*irq_handler_event)(int irq, void *dev_id);\n\tirqreturn_t (*irq_handler_thread)(int irq, void *dev_id);\n\tunsigned int baud_rate_div_min;\n\tunsigned int baud_rate_div_max;\n\tbool has_fifo;\n\tbool has_device_mode;\n\tu16 flags;\n};\n\n \nstruct stm32_spi {\n\tstruct device *dev;\n\tstruct spi_controller *ctrl;\n\tconst struct stm32_spi_cfg *cfg;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tu32 clk_rate;\n\tspinlock_t lock;  \n\tint irq;\n\tunsigned int fifo_size;\n\n\tunsigned int cur_midi;\n\tunsigned int cur_speed;\n\tunsigned int cur_half_period;\n\tunsigned int cur_bpw;\n\tunsigned int cur_fthlv;\n\tunsigned int cur_comm;\n\tunsigned int cur_xferlen;\n\tbool cur_usedma;\n\n\tconst void *tx_buf;\n\tvoid *rx_buf;\n\tint tx_len;\n\tint rx_len;\n\tstruct dma_chan *dma_tx;\n\tstruct dma_chan *dma_rx;\n\tdma_addr_t phys_addr;\n\n\tbool device_mode;\n};\n\nstatic const struct stm32_spi_regspec stm32f4_spi_regspec = {\n\t.en = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_SPE },\n\n\t.dma_rx_en = { STM32F4_SPI_CR2, STM32F4_SPI_CR2_RXDMAEN },\n\t.dma_tx_en = { STM32F4_SPI_CR2, STM32F4_SPI_CR2_TXDMAEN },\n\n\t.cpol = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPOL },\n\t.cpha = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPHA },\n\t.lsb_first = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_LSBFRST },\n\t.cs_high = {},\n\t.br = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_BR, STM32F4_SPI_CR1_BR_SHIFT },\n\n\t.rx = { STM32F4_SPI_DR },\n\t.tx = { STM32F4_SPI_DR },\n};\n\nstatic const struct stm32_spi_regspec stm32h7_spi_regspec = {\n\t \n\t.en = { STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE },\n\n\t.dma_rx_en = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_RXDMAEN },\n\t.dma_tx_en = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_TXDMAEN },\n\n\t.cpol = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPOL },\n\t.cpha = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPHA },\n\t.lsb_first = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_LSBFRST },\n\t.cs_high = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_SSIOP },\n\t.br = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_MBR,\n\t\tSTM32H7_SPI_CFG1_MBR_SHIFT },\n\n\t.rx = { STM32H7_SPI_RXDR },\n\t.tx = { STM32H7_SPI_TXDR },\n};\n\nstatic inline void stm32_spi_set_bits(struct stm32_spi *spi,\n\t\t\t\t      u32 offset, u32 bits)\n{\n\twritel_relaxed(readl_relaxed(spi->base + offset) | bits,\n\t\t       spi->base + offset);\n}\n\nstatic inline void stm32_spi_clr_bits(struct stm32_spi *spi,\n\t\t\t\t      u32 offset, u32 bits)\n{\n\twritel_relaxed(readl_relaxed(spi->base + offset) & ~bits,\n\t\t       spi->base + offset);\n}\n\n \nstatic int stm32h7_spi_get_fifo_size(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 count = 0;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tstm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);\n\n\twhile (readl_relaxed(spi->base + STM32H7_SPI_SR) & STM32H7_SPI_SR_TXP)\n\t\twriteb_relaxed(++count, spi->base + STM32H7_SPI_TXDR);\n\n\tstm32_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\tdev_dbg(spi->dev, \"%d x 8-bit fifo size\\n\", count);\n\n\treturn count;\n}\n\n \nstatic int stm32f4_spi_get_bpw_mask(struct stm32_spi *spi)\n{\n\tdev_dbg(spi->dev, \"8-bit or 16-bit data frame supported\\n\");\n\treturn SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n}\n\n \nstatic int stm32h7_spi_get_bpw_mask(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 cfg1, max_bpw;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\t \n\tstm32_spi_set_bits(spi, STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_DSIZE);\n\n\tcfg1 = readl_relaxed(spi->base + STM32H7_SPI_CFG1);\n\tmax_bpw = FIELD_GET(STM32H7_SPI_CFG1_DSIZE, cfg1) + 1;\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\tdev_dbg(spi->dev, \"%d-bit maximum data frame\\n\", max_bpw);\n\n\treturn SPI_BPW_RANGE_MASK(4, max_bpw);\n}\n\n \nstatic int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz,\n\t\t\t\t u32 min_div, u32 max_div)\n{\n\tu32 div, mbrdiv;\n\n\t \n\tdiv = DIV_ROUND_CLOSEST(spi->clk_rate & ~0x1, speed_hz);\n\n\t \n\tif ((div < min_div) || (div > max_div))\n\t\treturn -EINVAL;\n\n\t \n\tif (div & (div - 1))\n\t\tmbrdiv = fls(div);\n\telse\n\t\tmbrdiv = fls(div) - 1;\n\n\tspi->cur_speed = spi->clk_rate / (1 << mbrdiv);\n\n\tspi->cur_half_period = DIV_ROUND_CLOSEST(USEC_PER_SEC, 2 * spi->cur_speed);\n\n\treturn mbrdiv - 1;\n}\n\n \nstatic u32 stm32h7_spi_prepare_fthlv(struct stm32_spi *spi, u32 xfer_len)\n{\n\tu32 packet, bpw;\n\n\t \n\tpacket = clamp(xfer_len, 1U, spi->fifo_size / 2);\n\n\t \n\tbpw = DIV_ROUND_UP(spi->cur_bpw, 8);\n\treturn DIV_ROUND_UP(packet, bpw);\n}\n\n \nstatic void stm32f4_spi_write_tx(struct stm32_spi *spi)\n{\n\tif ((spi->tx_len > 0) && (readl_relaxed(spi->base + STM32F4_SPI_SR) &\n\t\t\t\t  STM32F4_SPI_SR_TXE)) {\n\t\tu32 offs = spi->cur_xferlen - spi->tx_len;\n\n\t\tif (spi->cur_bpw == 16) {\n\t\t\tconst u16 *tx_buf16 = (const u16 *)(spi->tx_buf + offs);\n\n\t\t\twritew_relaxed(*tx_buf16, spi->base + STM32F4_SPI_DR);\n\t\t\tspi->tx_len -= sizeof(u16);\n\t\t} else {\n\t\t\tconst u8 *tx_buf8 = (const u8 *)(spi->tx_buf + offs);\n\n\t\t\twriteb_relaxed(*tx_buf8, spi->base + STM32F4_SPI_DR);\n\t\t\tspi->tx_len -= sizeof(u8);\n\t\t}\n\t}\n\n\tdev_dbg(spi->dev, \"%s: %d bytes left\\n\", __func__, spi->tx_len);\n}\n\n \nstatic void stm32h7_spi_write_txfifo(struct stm32_spi *spi)\n{\n\twhile ((spi->tx_len > 0) &&\n\t\t       (readl_relaxed(spi->base + STM32H7_SPI_SR) &\n\t\t\tSTM32H7_SPI_SR_TXP)) {\n\t\tu32 offs = spi->cur_xferlen - spi->tx_len;\n\n\t\tif (spi->tx_len >= sizeof(u32)) {\n\t\t\tconst u32 *tx_buf32 = (const u32 *)(spi->tx_buf + offs);\n\n\t\t\twritel_relaxed(*tx_buf32, spi->base + STM32H7_SPI_TXDR);\n\t\t\tspi->tx_len -= sizeof(u32);\n\t\t} else if (spi->tx_len >= sizeof(u16)) {\n\t\t\tconst u16 *tx_buf16 = (const u16 *)(spi->tx_buf + offs);\n\n\t\t\twritew_relaxed(*tx_buf16, spi->base + STM32H7_SPI_TXDR);\n\t\t\tspi->tx_len -= sizeof(u16);\n\t\t} else {\n\t\t\tconst u8 *tx_buf8 = (const u8 *)(spi->tx_buf + offs);\n\n\t\t\twriteb_relaxed(*tx_buf8, spi->base + STM32H7_SPI_TXDR);\n\t\t\tspi->tx_len -= sizeof(u8);\n\t\t}\n\t}\n\n\tdev_dbg(spi->dev, \"%s: %d bytes left\\n\", __func__, spi->tx_len);\n}\n\n \nstatic void stm32f4_spi_read_rx(struct stm32_spi *spi)\n{\n\tif ((spi->rx_len > 0) && (readl_relaxed(spi->base + STM32F4_SPI_SR) &\n\t\t\t\t  STM32F4_SPI_SR_RXNE)) {\n\t\tu32 offs = spi->cur_xferlen - spi->rx_len;\n\n\t\tif (spi->cur_bpw == 16) {\n\t\t\tu16 *rx_buf16 = (u16 *)(spi->rx_buf + offs);\n\n\t\t\t*rx_buf16 = readw_relaxed(spi->base + STM32F4_SPI_DR);\n\t\t\tspi->rx_len -= sizeof(u16);\n\t\t} else {\n\t\t\tu8 *rx_buf8 = (u8 *)(spi->rx_buf + offs);\n\n\t\t\t*rx_buf8 = readb_relaxed(spi->base + STM32F4_SPI_DR);\n\t\t\tspi->rx_len -= sizeof(u8);\n\t\t}\n\t}\n\n\tdev_dbg(spi->dev, \"%s: %d bytes left\\n\", __func__, spi->rx_len);\n}\n\n \nstatic void stm32h7_spi_read_rxfifo(struct stm32_spi *spi)\n{\n\tu32 sr = readl_relaxed(spi->base + STM32H7_SPI_SR);\n\tu32 rxplvl = FIELD_GET(STM32H7_SPI_SR_RXPLVL, sr);\n\n\twhile ((spi->rx_len > 0) &&\n\t       ((sr & STM32H7_SPI_SR_RXP) ||\n\t\t((sr & STM32H7_SPI_SR_EOT) &&\n\t\t ((sr & STM32H7_SPI_SR_RXWNE) || (rxplvl > 0))))) {\n\t\tu32 offs = spi->cur_xferlen - spi->rx_len;\n\n\t\tif ((spi->rx_len >= sizeof(u32)) ||\n\t\t    (sr & STM32H7_SPI_SR_RXWNE)) {\n\t\t\tu32 *rx_buf32 = (u32 *)(spi->rx_buf + offs);\n\n\t\t\t*rx_buf32 = readl_relaxed(spi->base + STM32H7_SPI_RXDR);\n\t\t\tspi->rx_len -= sizeof(u32);\n\t\t} else if ((spi->rx_len >= sizeof(u16)) ||\n\t\t\t   (!(sr & STM32H7_SPI_SR_RXWNE) &&\n\t\t\t    (rxplvl >= 2 || spi->cur_bpw > 8))) {\n\t\t\tu16 *rx_buf16 = (u16 *)(spi->rx_buf + offs);\n\n\t\t\t*rx_buf16 = readw_relaxed(spi->base + STM32H7_SPI_RXDR);\n\t\t\tspi->rx_len -= sizeof(u16);\n\t\t} else {\n\t\t\tu8 *rx_buf8 = (u8 *)(spi->rx_buf + offs);\n\n\t\t\t*rx_buf8 = readb_relaxed(spi->base + STM32H7_SPI_RXDR);\n\t\t\tspi->rx_len -= sizeof(u8);\n\t\t}\n\n\t\tsr = readl_relaxed(spi->base + STM32H7_SPI_SR);\n\t\trxplvl = FIELD_GET(STM32H7_SPI_SR_RXPLVL, sr);\n\t}\n\n\tdev_dbg(spi->dev, \"%s: %d bytes left (sr=%08x)\\n\",\n\t\t__func__, spi->rx_len, sr);\n}\n\n \nstatic void stm32_spi_enable(struct stm32_spi *spi)\n{\n\tdev_dbg(spi->dev, \"enable controller\\n\");\n\n\tstm32_spi_set_bits(spi, spi->cfg->regs->en.reg,\n\t\t\t   spi->cfg->regs->en.mask);\n}\n\n \nstatic void stm32f4_spi_disable(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 sr;\n\n\tdev_dbg(spi->dev, \"disable controller\\n\");\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tif (!(readl_relaxed(spi->base + STM32F4_SPI_CR1) &\n\t      STM32F4_SPI_CR1_SPE)) {\n\t\tspin_unlock_irqrestore(&spi->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR2, STM32F4_SPI_CR2_TXEIE |\n\t\t\t\t\t\t STM32F4_SPI_CR2_RXNEIE |\n\t\t\t\t\t\t STM32F4_SPI_CR2_ERRIE);\n\n\t \n\tif (readl_relaxed_poll_timeout_atomic(spi->base + STM32F4_SPI_SR,\n\t\t\t\t\t      sr, !(sr & STM32F4_SPI_SR_BSY),\n\t\t\t\t\t      10, 100000) < 0) {\n\t\tdev_warn(spi->dev, \"disabling condition timeout\\n\");\n\t}\n\n\tif (spi->cur_usedma && spi->dma_tx)\n\t\tdmaengine_terminate_async(spi->dma_tx);\n\tif (spi->cur_usedma && spi->dma_rx)\n\t\tdmaengine_terminate_async(spi->dma_rx);\n\n\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_SPE);\n\n\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR2, STM32F4_SPI_CR2_TXDMAEN |\n\t\t\t\t\t\t STM32F4_SPI_CR2_RXDMAEN);\n\n\t \n\treadl_relaxed(spi->base + STM32F4_SPI_DR);\n\treadl_relaxed(spi->base + STM32F4_SPI_SR);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n}\n\n \nstatic void stm32h7_spi_disable(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 cr1;\n\n\tdev_dbg(spi->dev, \"disable controller\\n\");\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tcr1 = readl_relaxed(spi->base + STM32H7_SPI_CR1);\n\n\tif (!(cr1 & STM32H7_SPI_CR1_SPE)) {\n\t\tspin_unlock_irqrestore(&spi->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (spi->cur_half_period)\n\t\tudelay(spi->cur_half_period);\n\n\tif (spi->cur_usedma && spi->dma_tx)\n\t\tdmaengine_terminate_async(spi->dma_tx);\n\tif (spi->cur_usedma && spi->dma_rx)\n\t\tdmaengine_terminate_async(spi->dma_rx);\n\n\tstm32_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);\n\n\tstm32_spi_clr_bits(spi, STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_TXDMAEN |\n\t\t\t\t\t\tSTM32H7_SPI_CFG1_RXDMAEN);\n\n\t \n\twritel_relaxed(0, spi->base + STM32H7_SPI_IER);\n\twritel_relaxed(STM32H7_SPI_IFCR_ALL, spi->base + STM32H7_SPI_IFCR);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n}\n\n \nstatic bool stm32_spi_can_dma(struct spi_controller *ctrl,\n\t\t\t      struct spi_device *spi_dev,\n\t\t\t      struct spi_transfer *transfer)\n{\n\tunsigned int dma_size;\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\n\tif (spi->cfg->has_fifo)\n\t\tdma_size = spi->fifo_size;\n\telse\n\t\tdma_size = SPI_DMA_MIN_BYTES;\n\n\tdev_dbg(spi->dev, \"%s: %s\\n\", __func__,\n\t\t(transfer->len > dma_size) ? \"true\" : \"false\");\n\n\treturn (transfer->len > dma_size);\n}\n\n \nstatic irqreturn_t stm32f4_spi_irq_event(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctrl = dev_id;\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tu32 sr, mask = 0;\n\tbool end = false;\n\n\tspin_lock(&spi->lock);\n\n\tsr = readl_relaxed(spi->base + STM32F4_SPI_SR);\n\t \n\tsr &= ~STM32F4_SPI_SR_BSY;\n\n\tif (!spi->cur_usedma && (spi->cur_comm == SPI_SIMPLEX_TX ||\n\t\t\t\t spi->cur_comm == SPI_3WIRE_TX)) {\n\t\t \n\t\tsr &= ~(STM32F4_SPI_SR_OVR | STM32F4_SPI_SR_RXNE);\n\t\tmask |= STM32F4_SPI_SR_TXE;\n\t}\n\n\tif (!spi->cur_usedma && (spi->cur_comm == SPI_FULL_DUPLEX ||\n\t\t\t\tspi->cur_comm == SPI_SIMPLEX_RX ||\n\t\t\t\tspi->cur_comm == SPI_3WIRE_RX)) {\n\t\t \n\t\tsr &= ~STM32F4_SPI_SR_TXE;\n\t\tmask |= STM32F4_SPI_SR_RXNE | STM32F4_SPI_SR_OVR;\n\t}\n\n\tif (!(sr & mask)) {\n\t\tdev_dbg(spi->dev, \"spurious IT (sr=0x%08x)\\n\", sr);\n\t\tspin_unlock(&spi->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (sr & STM32F4_SPI_SR_OVR) {\n\t\tdev_warn(spi->dev, \"Overrun: received value discarded\\n\");\n\n\t\t \n\t\treadl_relaxed(spi->base + STM32F4_SPI_DR);\n\t\treadl_relaxed(spi->base + STM32F4_SPI_SR);\n\n\t\t \n\t\tend = true;\n\t\tgoto end_irq;\n\t}\n\n\tif (sr & STM32F4_SPI_SR_TXE) {\n\t\tif (spi->tx_buf)\n\t\t\tstm32f4_spi_write_tx(spi);\n\t\tif (spi->tx_len == 0)\n\t\t\tend = true;\n\t}\n\n\tif (sr & STM32F4_SPI_SR_RXNE) {\n\t\tstm32f4_spi_read_rx(spi);\n\t\tif (spi->rx_len == 0)\n\t\t\tend = true;\n\t\telse if (spi->tx_buf) \n\t\t\tstm32f4_spi_write_tx(spi);\n\t}\n\nend_irq:\n\tif (end) {\n\t\t \n\t\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR2,\n\t\t\t\t\tSTM32F4_SPI_CR2_TXEIE |\n\t\t\t\t\tSTM32F4_SPI_CR2_RXNEIE |\n\t\t\t\t\tSTM32F4_SPI_CR2_ERRIE);\n\t\tspin_unlock(&spi->lock);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\tspin_unlock(&spi->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t stm32f4_spi_irq_thread(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctrl = dev_id;\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\n\tspi_finalize_current_transfer(ctrl);\n\tstm32f4_spi_disable(spi);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)\n{\n\tstruct spi_controller *ctrl = dev_id;\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tu32 sr, ier, mask;\n\tunsigned long flags;\n\tbool end = false;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tsr = readl_relaxed(spi->base + STM32H7_SPI_SR);\n\tier = readl_relaxed(spi->base + STM32H7_SPI_IER);\n\n\tmask = ier;\n\t \n\n\tmask |= STM32H7_SPI_SR_SUSP;\n\t \n\tif ((spi->cur_comm == SPI_FULL_DUPLEX) && !spi->cur_usedma)\n\t\tmask |= STM32H7_SPI_SR_TXP | STM32H7_SPI_SR_RXP;\n\n\tif (!(sr & mask)) {\n\t\tdev_warn(spi->dev, \"spurious IT (sr=0x%08x, ier=0x%08x)\\n\",\n\t\t\t sr, ier);\n\t\tspin_unlock_irqrestore(&spi->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (sr & STM32H7_SPI_SR_SUSP) {\n\t\tstatic DEFINE_RATELIMIT_STATE(rs,\n\t\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL * 10,\n\t\t\t\t\t      1);\n\t\tratelimit_set_flags(&rs, RATELIMIT_MSG_ON_RELEASE);\n\t\tif (__ratelimit(&rs))\n\t\t\tdev_dbg_ratelimited(spi->dev, \"Communication suspended\\n\");\n\t\tif (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))\n\t\t\tstm32h7_spi_read_rxfifo(spi);\n\t\t \n\t\tif (spi->cur_usedma)\n\t\t\tend = true;\n\t}\n\n\tif (sr & STM32H7_SPI_SR_MODF) {\n\t\tdev_warn(spi->dev, \"Mode fault: transfer aborted\\n\");\n\t\tend = true;\n\t}\n\n\tif (sr & STM32H7_SPI_SR_OVR) {\n\t\tdev_err(spi->dev, \"Overrun: RX data lost\\n\");\n\t\tend = true;\n\t}\n\n\tif (sr & STM32H7_SPI_SR_EOT) {\n\t\tif (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))\n\t\t\tstm32h7_spi_read_rxfifo(spi);\n\t\tif (!spi->cur_usedma ||\n\t\t    (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX))\n\t\t\tend = true;\n\t}\n\n\tif (sr & STM32H7_SPI_SR_TXP)\n\t\tif (!spi->cur_usedma && (spi->tx_buf && (spi->tx_len > 0)))\n\t\t\tstm32h7_spi_write_txfifo(spi);\n\n\tif (sr & STM32H7_SPI_SR_RXP)\n\t\tif (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))\n\t\t\tstm32h7_spi_read_rxfifo(spi);\n\n\twritel_relaxed(sr & mask, spi->base + STM32H7_SPI_IFCR);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\tif (end) {\n\t\tstm32h7_spi_disable(spi);\n\t\tspi_finalize_current_transfer(ctrl);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int stm32_spi_prepare_msg(struct spi_controller *ctrl,\n\t\t\t\t struct spi_message *msg)\n{\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tstruct spi_device *spi_dev = msg->spi;\n\tstruct device_node *np = spi_dev->dev.of_node;\n\tunsigned long flags;\n\tu32 clrb = 0, setb = 0;\n\n\t \n\tspi->cur_midi = 0;\n\tif (np && !of_property_read_u32(np, \"st,spi-midi-ns\", &spi->cur_midi))\n\t\tdev_dbg(spi->dev, \"%dns inter-data idleness\\n\", spi->cur_midi);\n\n\tif (spi_dev->mode & SPI_CPOL)\n\t\tsetb |= spi->cfg->regs->cpol.mask;\n\telse\n\t\tclrb |= spi->cfg->regs->cpol.mask;\n\n\tif (spi_dev->mode & SPI_CPHA)\n\t\tsetb |= spi->cfg->regs->cpha.mask;\n\telse\n\t\tclrb |= spi->cfg->regs->cpha.mask;\n\n\tif (spi_dev->mode & SPI_LSB_FIRST)\n\t\tsetb |= spi->cfg->regs->lsb_first.mask;\n\telse\n\t\tclrb |= spi->cfg->regs->lsb_first.mask;\n\n\tif (STM32_SPI_DEVICE_MODE(spi) && spi_dev->mode & SPI_CS_HIGH)\n\t\tsetb |= spi->cfg->regs->cs_high.mask;\n\telse\n\t\tclrb |= spi->cfg->regs->cs_high.mask;\n\n\tdev_dbg(spi->dev, \"cpol=%d cpha=%d lsb_first=%d cs_high=%d\\n\",\n\t\t!!(spi_dev->mode & SPI_CPOL),\n\t\t!!(spi_dev->mode & SPI_CPHA),\n\t\t!!(spi_dev->mode & SPI_LSB_FIRST),\n\t\t!!(spi_dev->mode & SPI_CS_HIGH));\n\n\t \n\tif (spi->cfg->set_number_of_data) {\n\t\tint ret;\n\n\t\tret = spi_split_transfers_maxwords(ctrl, msg,\n\t\t\t\t\t\t   STM32H7_SPI_TSIZE_MAX,\n\t\t\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\t \n\tif (clrb || setb)\n\t\twritel_relaxed(\n\t\t\t(readl_relaxed(spi->base + spi->cfg->regs->cpol.reg) &\n\t\t\t ~clrb) | setb,\n\t\t\tspi->base + spi->cfg->regs->cpol.reg);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void stm32f4_spi_dma_tx_cb(void *data)\n{\n\tstruct stm32_spi *spi = data;\n\n\tif (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX) {\n\t\tspi_finalize_current_transfer(spi->ctrl);\n\t\tstm32f4_spi_disable(spi);\n\t}\n}\n\n \nstatic void stm32_spi_dma_rx_cb(void *data)\n{\n\tstruct stm32_spi *spi = data;\n\n\tspi_finalize_current_transfer(spi->ctrl);\n\tspi->cfg->disable(spi);\n}\n\n \nstatic void stm32_spi_dma_config(struct stm32_spi *spi,\n\t\t\t\t struct dma_slave_config *dma_conf,\n\t\t\t\t enum dma_transfer_direction dir)\n{\n\tenum dma_slave_buswidth buswidth;\n\tu32 maxburst;\n\n\tif (spi->cur_bpw <= 8)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\telse if (spi->cur_bpw <= 16)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tif (spi->cfg->has_fifo) {\n\t\t \n\t\tif (spi->cur_fthlv == 2)\n\t\t\tmaxburst = 1;\n\t\telse\n\t\t\tmaxburst = spi->cur_fthlv;\n\t} else {\n\t\tmaxburst = 1;\n\t}\n\n\tmemset(dma_conf, 0, sizeof(struct dma_slave_config));\n\tdma_conf->direction = dir;\n\tif (dma_conf->direction == DMA_DEV_TO_MEM) {  \n\t\tdma_conf->src_addr = spi->phys_addr + spi->cfg->regs->rx.reg;\n\t\tdma_conf->src_addr_width = buswidth;\n\t\tdma_conf->src_maxburst = maxburst;\n\n\t\tdev_dbg(spi->dev, \"Rx DMA config buswidth=%d, maxburst=%d\\n\",\n\t\t\tbuswidth, maxburst);\n\t} else if (dma_conf->direction == DMA_MEM_TO_DEV) {  \n\t\tdma_conf->dst_addr = spi->phys_addr + spi->cfg->regs->tx.reg;\n\t\tdma_conf->dst_addr_width = buswidth;\n\t\tdma_conf->dst_maxburst = maxburst;\n\n\t\tdev_dbg(spi->dev, \"Tx DMA config buswidth=%d, maxburst=%d\\n\",\n\t\t\tbuswidth, maxburst);\n\t}\n}\n\n \nstatic int stm32f4_spi_transfer_one_irq(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 cr2 = 0;\n\n\t \n\tif (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX) {\n\t\tcr2 |= STM32F4_SPI_CR2_TXEIE;\n\t} else if (spi->cur_comm == SPI_FULL_DUPLEX ||\n\t\t\t\tspi->cur_comm == SPI_SIMPLEX_RX ||\n\t\t\t\tspi->cur_comm == SPI_3WIRE_RX) {\n\t\t \n\t\tcr2 |= STM32F4_SPI_CR2_RXNEIE | STM32F4_SPI_CR2_ERRIE;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tstm32_spi_set_bits(spi, STM32F4_SPI_CR2, cr2);\n\n\tstm32_spi_enable(spi);\n\n\t \n\tif (spi->tx_buf)\n\t\tstm32f4_spi_write_tx(spi);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 1;\n}\n\n \nstatic int stm32h7_spi_transfer_one_irq(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 ier = 0;\n\n\t \n\tif (spi->tx_buf && spi->rx_buf)\t \n\t\tier |= STM32H7_SPI_IER_DXPIE;\n\telse if (spi->tx_buf)\t\t \n\t\tier |= STM32H7_SPI_IER_TXPIE;\n\telse if (spi->rx_buf)\t\t \n\t\tier |= STM32H7_SPI_IER_RXPIE;\n\n\t \n\tier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE |\n\t       STM32H7_SPI_IER_OVRIE | STM32H7_SPI_IER_MODFIE;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tstm32_spi_enable(spi);\n\n\t \n\tif (spi->tx_buf)\n\t\tstm32h7_spi_write_txfifo(spi);\n\n\tif (STM32_SPI_MASTER_MODE(spi))\n\t\tstm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);\n\n\twritel_relaxed(ier, spi->base + STM32H7_SPI_IER);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 1;\n}\n\n \nstatic void stm32f4_spi_transfer_one_dma_start(struct stm32_spi *spi)\n{\n\t \n\tif (spi->cur_comm == SPI_SIMPLEX_RX || spi->cur_comm == SPI_3WIRE_RX ||\n\t    spi->cur_comm == SPI_FULL_DUPLEX) {\n\t\t \n\t\tstm32_spi_set_bits(spi, STM32F4_SPI_CR2, STM32F4_SPI_CR2_ERRIE);\n\t}\n\n\tstm32_spi_enable(spi);\n}\n\n \nstatic void stm32h7_spi_transfer_one_dma_start(struct stm32_spi *spi)\n{\n\tuint32_t ier = STM32H7_SPI_IER_OVRIE | STM32H7_SPI_IER_MODFIE;\n\n\t \n\tif (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX)\n\t\tier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE;\n\n\tstm32_spi_set_bits(spi, STM32H7_SPI_IER, ier);\n\n\tstm32_spi_enable(spi);\n\n\tif (STM32_SPI_MASTER_MODE(spi))\n\t\tstm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);\n}\n\n \nstatic int stm32_spi_transfer_one_dma(struct stm32_spi *spi,\n\t\t\t\t      struct spi_transfer *xfer)\n{\n\tstruct dma_slave_config tx_dma_conf, rx_dma_conf;\n\tstruct dma_async_tx_descriptor *tx_dma_desc, *rx_dma_desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\trx_dma_desc = NULL;\n\tif (spi->rx_buf && spi->dma_rx) {\n\t\tstm32_spi_dma_config(spi, &rx_dma_conf, DMA_DEV_TO_MEM);\n\t\tdmaengine_slave_config(spi->dma_rx, &rx_dma_conf);\n\n\t\t \n\t\tstm32_spi_set_bits(spi, spi->cfg->regs->dma_rx_en.reg,\n\t\t\t\t   spi->cfg->regs->dma_rx_en.mask);\n\n\t\trx_dma_desc = dmaengine_prep_slave_sg(\n\t\t\t\t\tspi->dma_rx, xfer->rx_sg.sgl,\n\t\t\t\t\txfer->rx_sg.nents,\n\t\t\t\t\trx_dma_conf.direction,\n\t\t\t\t\tDMA_PREP_INTERRUPT);\n\t}\n\n\ttx_dma_desc = NULL;\n\tif (spi->tx_buf && spi->dma_tx) {\n\t\tstm32_spi_dma_config(spi, &tx_dma_conf, DMA_MEM_TO_DEV);\n\t\tdmaengine_slave_config(spi->dma_tx, &tx_dma_conf);\n\n\t\ttx_dma_desc = dmaengine_prep_slave_sg(\n\t\t\t\t\tspi->dma_tx, xfer->tx_sg.sgl,\n\t\t\t\t\txfer->tx_sg.nents,\n\t\t\t\t\ttx_dma_conf.direction,\n\t\t\t\t\tDMA_PREP_INTERRUPT);\n\t}\n\n\tif ((spi->tx_buf && spi->dma_tx && !tx_dma_desc) ||\n\t    (spi->rx_buf && spi->dma_rx && !rx_dma_desc))\n\t\tgoto dma_desc_error;\n\n\tif (spi->cur_comm == SPI_FULL_DUPLEX && (!tx_dma_desc || !rx_dma_desc))\n\t\tgoto dma_desc_error;\n\n\tif (rx_dma_desc) {\n\t\trx_dma_desc->callback = spi->cfg->dma_rx_cb;\n\t\trx_dma_desc->callback_param = spi;\n\n\t\tif (dma_submit_error(dmaengine_submit(rx_dma_desc))) {\n\t\t\tdev_err(spi->dev, \"Rx DMA submit failed\\n\");\n\t\t\tgoto dma_desc_error;\n\t\t}\n\t\t \n\t\tdma_async_issue_pending(spi->dma_rx);\n\t}\n\n\tif (tx_dma_desc) {\n\t\tif (spi->cur_comm == SPI_SIMPLEX_TX ||\n\t\t    spi->cur_comm == SPI_3WIRE_TX) {\n\t\t\ttx_dma_desc->callback = spi->cfg->dma_tx_cb;\n\t\t\ttx_dma_desc->callback_param = spi;\n\t\t}\n\n\t\tif (dma_submit_error(dmaengine_submit(tx_dma_desc))) {\n\t\t\tdev_err(spi->dev, \"Tx DMA submit failed\\n\");\n\t\t\tgoto dma_submit_error;\n\t\t}\n\t\t \n\t\tdma_async_issue_pending(spi->dma_tx);\n\n\t\t \n\t\tstm32_spi_set_bits(spi, spi->cfg->regs->dma_tx_en.reg,\n\t\t\t\t   spi->cfg->regs->dma_tx_en.mask);\n\t}\n\n\tspi->cfg->transfer_one_dma_start(spi);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 1;\n\ndma_submit_error:\n\tif (spi->dma_rx)\n\t\tdmaengine_terminate_sync(spi->dma_rx);\n\ndma_desc_error:\n\tstm32_spi_clr_bits(spi, spi->cfg->regs->dma_rx_en.reg,\n\t\t\t   spi->cfg->regs->dma_rx_en.mask);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\tdev_info(spi->dev, \"DMA issue: fall back to irq transfer\\n\");\n\n\tspi->cur_usedma = false;\n\treturn spi->cfg->transfer_one_irq(spi);\n}\n\n \nstatic void stm32f4_spi_set_bpw(struct stm32_spi *spi)\n{\n\tif (spi->cur_bpw == 16)\n\t\tstm32_spi_set_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_DFF);\n\telse\n\t\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_DFF);\n}\n\n \nstatic void stm32h7_spi_set_bpw(struct stm32_spi *spi)\n{\n\tu32 bpw, fthlv;\n\tu32 cfg1_clrb = 0, cfg1_setb = 0;\n\n\tbpw = spi->cur_bpw - 1;\n\n\tcfg1_clrb |= STM32H7_SPI_CFG1_DSIZE;\n\tcfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_DSIZE, bpw);\n\n\tspi->cur_fthlv = stm32h7_spi_prepare_fthlv(spi, spi->cur_xferlen);\n\tfthlv = spi->cur_fthlv - 1;\n\n\tcfg1_clrb |= STM32H7_SPI_CFG1_FTHLV;\n\tcfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_FTHLV, fthlv);\n\n\twritel_relaxed(\n\t\t(readl_relaxed(spi->base + STM32H7_SPI_CFG1) &\n\t\t ~cfg1_clrb) | cfg1_setb,\n\t\tspi->base + STM32H7_SPI_CFG1);\n}\n\n \nstatic void stm32_spi_set_mbr(struct stm32_spi *spi, u32 mbrdiv)\n{\n\tu32 clrb = 0, setb = 0;\n\n\tclrb |= spi->cfg->regs->br.mask;\n\tsetb |= (mbrdiv << spi->cfg->regs->br.shift) & spi->cfg->regs->br.mask;\n\n\twritel_relaxed((readl_relaxed(spi->base + spi->cfg->regs->br.reg) &\n\t\t\t~clrb) | setb,\n\t\t       spi->base + spi->cfg->regs->br.reg);\n}\n\n \nstatic unsigned int stm32_spi_communication_type(struct spi_device *spi_dev,\n\t\t\t\t\t\t struct spi_transfer *transfer)\n{\n\tunsigned int type = SPI_FULL_DUPLEX;\n\n\tif (spi_dev->mode & SPI_3WIRE) {  \n\t\t \n\t\tif (!transfer->tx_buf)\n\t\t\ttype = SPI_3WIRE_RX;\n\t\telse\n\t\t\ttype = SPI_3WIRE_TX;\n\t} else {\n\t\tif (!transfer->tx_buf)\n\t\t\ttype = SPI_SIMPLEX_RX;\n\t\telse if (!transfer->rx_buf)\n\t\t\ttype = SPI_SIMPLEX_TX;\n\t}\n\n\treturn type;\n}\n\n \nstatic int stm32f4_spi_set_mode(struct stm32_spi *spi, unsigned int comm_type)\n{\n\tif (comm_type == SPI_3WIRE_TX || comm_type == SPI_SIMPLEX_TX) {\n\t\tstm32_spi_set_bits(spi, STM32F4_SPI_CR1,\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIMODE |\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIOE);\n\t} else if (comm_type == SPI_FULL_DUPLEX ||\n\t\t\t\tcomm_type == SPI_SIMPLEX_RX) {\n\t\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR1,\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIMODE |\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIOE);\n\t} else if (comm_type == SPI_3WIRE_RX) {\n\t\tstm32_spi_set_bits(spi, STM32F4_SPI_CR1,\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIMODE);\n\t\tstm32_spi_clr_bits(spi, STM32F4_SPI_CR1,\n\t\t\t\t\tSTM32F4_SPI_CR1_BIDIOE);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int stm32h7_spi_set_mode(struct stm32_spi *spi, unsigned int comm_type)\n{\n\tu32 mode;\n\tu32 cfg2_clrb = 0, cfg2_setb = 0;\n\n\tif (comm_type == SPI_3WIRE_RX) {\n\t\tmode = STM32H7_SPI_HALF_DUPLEX;\n\t\tstm32_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_HDDIR);\n\t} else if (comm_type == SPI_3WIRE_TX) {\n\t\tmode = STM32H7_SPI_HALF_DUPLEX;\n\t\tstm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_HDDIR);\n\t} else if (comm_type == SPI_SIMPLEX_RX) {\n\t\tmode = STM32H7_SPI_SIMPLEX_RX;\n\t} else if (comm_type == SPI_SIMPLEX_TX) {\n\t\tmode = STM32H7_SPI_SIMPLEX_TX;\n\t} else {\n\t\tmode = STM32H7_SPI_FULL_DUPLEX;\n\t}\n\n\tcfg2_clrb |= STM32H7_SPI_CFG2_COMM;\n\tcfg2_setb |= FIELD_PREP(STM32H7_SPI_CFG2_COMM, mode);\n\n\twritel_relaxed(\n\t\t(readl_relaxed(spi->base + STM32H7_SPI_CFG2) &\n\t\t ~cfg2_clrb) | cfg2_setb,\n\t\tspi->base + STM32H7_SPI_CFG2);\n\n\treturn 0;\n}\n\n \nstatic void stm32h7_spi_data_idleness(struct stm32_spi *spi, u32 len)\n{\n\tu32 cfg2_clrb = 0, cfg2_setb = 0;\n\n\tcfg2_clrb |= STM32H7_SPI_CFG2_MIDI;\n\tif ((len > 1) && (spi->cur_midi > 0)) {\n\t\tu32 sck_period_ns = DIV_ROUND_UP(NSEC_PER_SEC, spi->cur_speed);\n\t\tu32 midi = min_t(u32,\n\t\t\t\t DIV_ROUND_UP(spi->cur_midi, sck_period_ns),\n\t\t\t\t FIELD_GET(STM32H7_SPI_CFG2_MIDI,\n\t\t\t\t STM32H7_SPI_CFG2_MIDI));\n\n\n\t\tdev_dbg(spi->dev, \"period=%dns, midi=%d(=%dns)\\n\",\n\t\t\tsck_period_ns, midi, midi * sck_period_ns);\n\t\tcfg2_setb |= FIELD_PREP(STM32H7_SPI_CFG2_MIDI, midi);\n\t}\n\n\twritel_relaxed((readl_relaxed(spi->base + STM32H7_SPI_CFG2) &\n\t\t\t~cfg2_clrb) | cfg2_setb,\n\t\t       spi->base + STM32H7_SPI_CFG2);\n}\n\n \nstatic int stm32h7_spi_number_of_data(struct stm32_spi *spi, u32 nb_words)\n{\n\tif (nb_words <= STM32H7_SPI_TSIZE_MAX) {\n\t\twritel_relaxed(FIELD_PREP(STM32H7_SPI_CR2_TSIZE, nb_words),\n\t\t\t       spi->base + STM32H7_SPI_CR2);\n\t} else {\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int stm32_spi_transfer_one_setup(struct stm32_spi *spi,\n\t\t\t\t\tstruct spi_device *spi_dev,\n\t\t\t\t\tstruct spi_transfer *transfer)\n{\n\tunsigned long flags;\n\tunsigned int comm_type;\n\tint nb_words, ret = 0;\n\tint mbr;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\tspi->cur_xferlen = transfer->len;\n\n\tspi->cur_bpw = transfer->bits_per_word;\n\tspi->cfg->set_bpw(spi);\n\n\t \n\tif (STM32_SPI_MASTER_MODE(spi)) {\n\t\tmbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz,\n\t\t\t\t\t    spi->cfg->baud_rate_div_min,\n\t\t\t\t\t    spi->cfg->baud_rate_div_max);\n\t\tif (mbr < 0) {\n\t\t\tret = mbr;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttransfer->speed_hz = spi->cur_speed;\n\t\tstm32_spi_set_mbr(spi, mbr);\n\t}\n\n\tcomm_type = stm32_spi_communication_type(spi_dev, transfer);\n\tret = spi->cfg->set_mode(spi, comm_type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tspi->cur_comm = comm_type;\n\n\tif (STM32_SPI_MASTER_MODE(spi) && spi->cfg->set_data_idleness)\n\t\tspi->cfg->set_data_idleness(spi, transfer->len);\n\n\tif (spi->cur_bpw <= 8)\n\t\tnb_words = transfer->len;\n\telse if (spi->cur_bpw <= 16)\n\t\tnb_words = DIV_ROUND_UP(transfer->len * 8, 16);\n\telse\n\t\tnb_words = DIV_ROUND_UP(transfer->len * 8, 32);\n\n\tif (spi->cfg->set_number_of_data) {\n\t\tret = spi->cfg->set_number_of_data(spi, nb_words);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tdev_dbg(spi->dev, \"transfer communication mode set to %d\\n\",\n\t\tspi->cur_comm);\n\tdev_dbg(spi->dev,\n\t\t\"data frame of %d-bit, data packet of %d data frames\\n\",\n\t\tspi->cur_bpw, spi->cur_fthlv);\n\tif (STM32_SPI_MASTER_MODE(spi))\n\t\tdev_dbg(spi->dev, \"speed set to %dHz\\n\", spi->cur_speed);\n\tdev_dbg(spi->dev, \"transfer of %d bytes (%d data frames)\\n\",\n\t\tspi->cur_xferlen, nb_words);\n\tdev_dbg(spi->dev, \"dma %s\\n\",\n\t\t(spi->cur_usedma) ? \"enabled\" : \"disabled\");\n\nout:\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int stm32_spi_transfer_one(struct spi_controller *ctrl,\n\t\t\t\t  struct spi_device *spi_dev,\n\t\t\t\t  struct spi_transfer *transfer)\n{\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tspi->tx_buf = transfer->tx_buf;\n\tspi->rx_buf = transfer->rx_buf;\n\tspi->tx_len = spi->tx_buf ? transfer->len : 0;\n\tspi->rx_len = spi->rx_buf ? transfer->len : 0;\n\n\tspi->cur_usedma = (ctrl->can_dma &&\n\t\t\t   ctrl->can_dma(ctrl, spi_dev, transfer));\n\n\tret = stm32_spi_transfer_one_setup(spi, spi_dev, transfer);\n\tif (ret) {\n\t\tdev_err(spi->dev, \"SPI transfer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (spi->cur_usedma)\n\t\treturn stm32_spi_transfer_one_dma(spi, transfer);\n\telse\n\t\treturn spi->cfg->transfer_one_irq(spi);\n}\n\n \nstatic int stm32_spi_unprepare_msg(struct spi_controller *ctrl,\n\t\t\t\t   struct spi_message *msg)\n{\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\n\tspi->cfg->disable(spi);\n\n\treturn 0;\n}\n\n \nstatic int stm32f4_spi_config(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\t \n\tstm32_spi_clr_bits(spi, STM32F4_SPI_I2SCFGR,\n\t\t\t   STM32F4_SPI_I2SCFGR_I2SMOD);\n\n\t \n\tstm32_spi_set_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_SSI |\n\t\t\t\t\t\t STM32F4_SPI_CR1_BIDIOE |\n\t\t\t\t\t\t STM32F4_SPI_CR1_MSTR |\n\t\t\t\t\t\t STM32F4_SPI_CR1_SSM);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int stm32h7_spi_config(struct stm32_spi *spi)\n{\n\tunsigned long flags;\n\tu32 cr1 = 0, cfg2 = 0;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\n\t \n\tstm32_spi_clr_bits(spi, STM32H7_SPI_I2SCFGR,\n\t\t\t   STM32H7_SPI_I2SCFGR_I2SMOD);\n\n\tif (STM32_SPI_DEVICE_MODE(spi)) {\n\t\t \n\t\tcfg2 &= ~STM32H7_SPI_CFG2_SSM;\n\t} else {\n\t\t \n\t\tcr1 |= STM32H7_SPI_CR1_HDDIR | STM32H7_SPI_CR1_MASRX | STM32H7_SPI_CR1_SSI;\n\n\t\t \n\t\tcfg2 |= STM32H7_SPI_CFG2_MASTER | STM32H7_SPI_CFG2_SSM | STM32H7_SPI_CFG2_AFCNTR;\n\t}\n\n\tstm32_spi_set_bits(spi, STM32H7_SPI_CR1, cr1);\n\tstm32_spi_set_bits(spi, STM32H7_SPI_CFG2, cfg2);\n\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct stm32_spi_cfg stm32f4_spi_cfg = {\n\t.regs = &stm32f4_spi_regspec,\n\t.get_bpw_mask = stm32f4_spi_get_bpw_mask,\n\t.disable = stm32f4_spi_disable,\n\t.config = stm32f4_spi_config,\n\t.set_bpw = stm32f4_spi_set_bpw,\n\t.set_mode = stm32f4_spi_set_mode,\n\t.transfer_one_dma_start = stm32f4_spi_transfer_one_dma_start,\n\t.dma_tx_cb = stm32f4_spi_dma_tx_cb,\n\t.dma_rx_cb = stm32_spi_dma_rx_cb,\n\t.transfer_one_irq = stm32f4_spi_transfer_one_irq,\n\t.irq_handler_event = stm32f4_spi_irq_event,\n\t.irq_handler_thread = stm32f4_spi_irq_thread,\n\t.baud_rate_div_min = STM32F4_SPI_BR_DIV_MIN,\n\t.baud_rate_div_max = STM32F4_SPI_BR_DIV_MAX,\n\t.has_fifo = false,\n\t.has_device_mode = false,\n\t.flags = SPI_CONTROLLER_MUST_TX,\n};\n\nstatic const struct stm32_spi_cfg stm32h7_spi_cfg = {\n\t.regs = &stm32h7_spi_regspec,\n\t.get_fifo_size = stm32h7_spi_get_fifo_size,\n\t.get_bpw_mask = stm32h7_spi_get_bpw_mask,\n\t.disable = stm32h7_spi_disable,\n\t.config = stm32h7_spi_config,\n\t.set_bpw = stm32h7_spi_set_bpw,\n\t.set_mode = stm32h7_spi_set_mode,\n\t.set_data_idleness = stm32h7_spi_data_idleness,\n\t.set_number_of_data = stm32h7_spi_number_of_data,\n\t.transfer_one_dma_start = stm32h7_spi_transfer_one_dma_start,\n\t.dma_rx_cb = stm32_spi_dma_rx_cb,\n\t \n\t.transfer_one_irq = stm32h7_spi_transfer_one_irq,\n\t.irq_handler_thread = stm32h7_spi_irq_thread,\n\t.baud_rate_div_min = STM32H7_SPI_MBR_DIV_MIN,\n\t.baud_rate_div_max = STM32H7_SPI_MBR_DIV_MAX,\n\t.has_fifo = true,\n\t.has_device_mode = true,\n};\n\nstatic const struct of_device_id stm32_spi_of_match[] = {\n\t{ .compatible = \"st,stm32h7-spi\", .data = (void *)&stm32h7_spi_cfg },\n\t{ .compatible = \"st,stm32f4-spi\", .data = (void *)&stm32f4_spi_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_spi_of_match);\n\nstatic int stm32h7_spi_device_abort(struct spi_controller *ctrl)\n{\n\tspi_finalize_current_transfer(ctrl);\n\treturn 0;\n}\n\nstatic int stm32_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl;\n\tstruct stm32_spi *spi;\n\tstruct resource *res;\n\tstruct reset_control *rst;\n\tstruct device_node *np = pdev->dev.of_node;\n\tbool device_mode;\n\tint ret;\n\tconst struct stm32_spi_cfg *cfg = of_device_get_match_data(&pdev->dev);\n\n\tdevice_mode = of_property_read_bool(np, \"spi-slave\");\n\tif (!cfg->has_device_mode && device_mode) {\n\t\tdev_err(&pdev->dev, \"spi-slave not supported\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (device_mode)\n\t\tctrl = devm_spi_alloc_slave(&pdev->dev, sizeof(struct stm32_spi));\n\telse\n\t\tctrl = devm_spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));\n\tif (!ctrl) {\n\t\tdev_err(&pdev->dev, \"spi controller allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, ctrl);\n\n\tspi = spi_controller_get_devdata(ctrl);\n\tspi->dev = &pdev->dev;\n\tspi->ctrl = ctrl;\n\tspi->device_mode = device_mode;\n\tspin_lock_init(&spi->lock);\n\n\tspi->cfg = cfg;\n\n\tspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(spi->base))\n\t\treturn PTR_ERR(spi->base);\n\n\tspi->phys_addr = (dma_addr_t)res->start;\n\n\tspi->irq = platform_get_irq(pdev, 0);\n\tif (spi->irq <= 0)\n\t\treturn spi->irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, spi->irq,\n\t\t\t\t\tspi->cfg->irq_handler_event,\n\t\t\t\t\tspi->cfg->irq_handler_thread,\n\t\t\t\t\tIRQF_ONESHOT, pdev->name, ctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq%d request failed: %d\\n\", spi->irq,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(spi->clk)) {\n\t\tret = PTR_ERR(spi->clk);\n\t\tdev_err(&pdev->dev, \"clk get failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(spi->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clk enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tspi->clk_rate = clk_get_rate(spi->clk);\n\tif (!spi->clk_rate) {\n\t\tdev_err(&pdev->dev, \"clk rate = 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\trst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (rst) {\n\t\tif (IS_ERR(rst)) {\n\t\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t\t    \"failed to get reset\\n\");\n\t\t\tgoto err_clk_disable;\n\t\t}\n\n\t\treset_control_assert(rst);\n\t\tudelay(2);\n\t\treset_control_deassert(rst);\n\t}\n\n\tif (spi->cfg->has_fifo)\n\t\tspi->fifo_size = spi->cfg->get_fifo_size(spi);\n\n\tret = spi->cfg->config(spi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"controller configuration failed: %d\\n\",\n\t\t\tret);\n\t\tgoto err_clk_disable;\n\t}\n\n\tctrl->dev.of_node = pdev->dev.of_node;\n\tctrl->auto_runtime_pm = true;\n\tctrl->bus_num = pdev->id;\n\tctrl->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |\n\t\t\t  SPI_3WIRE;\n\tctrl->bits_per_word_mask = spi->cfg->get_bpw_mask(spi);\n\tctrl->max_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_min;\n\tctrl->min_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_max;\n\tctrl->use_gpio_descriptors = true;\n\tctrl->prepare_message = stm32_spi_prepare_msg;\n\tctrl->transfer_one = stm32_spi_transfer_one;\n\tctrl->unprepare_message = stm32_spi_unprepare_msg;\n\tctrl->flags = spi->cfg->flags;\n\tif (STM32_SPI_DEVICE_MODE(spi))\n\t\tctrl->slave_abort = stm32h7_spi_device_abort;\n\n\tspi->dma_tx = dma_request_chan(spi->dev, \"tx\");\n\tif (IS_ERR(spi->dma_tx)) {\n\t\tret = PTR_ERR(spi->dma_tx);\n\t\tspi->dma_tx = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_clk_disable;\n\n\t\tdev_warn(&pdev->dev, \"failed to request tx dma channel\\n\");\n\t} else {\n\t\tctrl->dma_tx = spi->dma_tx;\n\t}\n\n\tspi->dma_rx = dma_request_chan(spi->dev, \"rx\");\n\tif (IS_ERR(spi->dma_rx)) {\n\t\tret = PTR_ERR(spi->dma_rx);\n\t\tspi->dma_rx = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_dma_release;\n\n\t\tdev_warn(&pdev->dev, \"failed to request rx dma channel\\n\");\n\t} else {\n\t\tctrl->dma_rx = spi->dma_rx;\n\t}\n\n\tif (spi->dma_tx || spi->dma_rx)\n\t\tctrl->can_dma = stm32_spi_can_dma;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t STM32_SPI_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = spi_register_controller(ctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spi controller registration failed: %d\\n\",\n\t\t\tret);\n\t\tgoto err_pm_disable;\n\t}\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tdev_info(&pdev->dev, \"driver initialized (%s mode)\\n\",\n\t\t STM32_SPI_MASTER_MODE(spi) ? \"master\" : \"device\");\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\nerr_dma_release:\n\tif (spi->dma_tx)\n\t\tdma_release_channel(spi->dma_tx);\n\tif (spi->dma_rx)\n\t\tdma_release_channel(spi->dma_rx);\nerr_clk_disable:\n\tclk_disable_unprepare(spi->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl = platform_get_drvdata(pdev);\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tspi_unregister_controller(ctrl);\n\tspi->cfg->disable(spi);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\tif (ctrl->dma_tx)\n\t\tdma_release_channel(ctrl->dma_tx);\n\tif (ctrl->dma_rx)\n\t\tdma_release_channel(ctrl->dma_rx);\n\n\tclk_disable_unprepare(spi->clk);\n\n\n\tpinctrl_pm_select_sleep_state(&pdev->dev);\n}\n\nstatic int __maybe_unused stm32_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\n\tclk_disable_unprepare(spi->clk);\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int __maybe_unused stm32_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(spi->clk);\n}\n\nstatic int __maybe_unused stm32_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused stm32_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctrl = dev_get_drvdata(dev);\n\tstruct stm32_spi *spi = spi_controller_get_devdata(ctrl);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_controller_resume(ctrl);\n\tif (ret) {\n\t\tclk_disable_unprepare(spi->clk);\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to power device:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi->cfg->config(spi);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops stm32_spi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_spi_suspend, stm32_spi_resume)\n\tSET_RUNTIME_PM_OPS(stm32_spi_runtime_suspend,\n\t\t\t   stm32_spi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver stm32_spi_driver = {\n\t.probe = stm32_spi_probe,\n\t.remove_new = stm32_spi_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &stm32_spi_pm_ops,\n\t\t.of_match_table = stm32_spi_of_match,\n\t},\n};\n\nmodule_platform_driver(stm32_spi_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 SPI Controller driver\");\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}