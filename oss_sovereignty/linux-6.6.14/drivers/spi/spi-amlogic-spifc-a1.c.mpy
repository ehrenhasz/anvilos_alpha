{
  "module_name": "spi-amlogic-spifc-a1.c",
  "hash_id": "36075e65e51d51f9f61cc5b969c3706868150ddc3f82e2644136001ac6d4cfab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-amlogic-spifc-a1.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/types.h>\n\n#define SPIFC_A1_AHB_CTRL_REG\t\t0x0\n#define SPIFC_A1_AHB_BUS_EN\t\tBIT(31)\n\n#define SPIFC_A1_USER_CTRL0_REG\t\t0x200\n#define SPIFC_A1_USER_REQUEST_ENABLE\tBIT(31)\n#define SPIFC_A1_USER_REQUEST_FINISH\tBIT(30)\n#define SPIFC_A1_USER_DATA_UPDATED\tBIT(0)\n\n#define SPIFC_A1_USER_CTRL1_REG\t\t0x204\n#define SPIFC_A1_USER_CMD_ENABLE\tBIT(30)\n#define SPIFC_A1_USER_CMD_MODE\t\tGENMASK(29, 28)\n#define SPIFC_A1_USER_CMD_CODE\t\tGENMASK(27, 20)\n#define SPIFC_A1_USER_ADDR_ENABLE\tBIT(19)\n#define SPIFC_A1_USER_ADDR_MODE\t\tGENMASK(18, 17)\n#define SPIFC_A1_USER_ADDR_BYTES\tGENMASK(16, 15)\n#define SPIFC_A1_USER_DOUT_ENABLE\tBIT(14)\n#define SPIFC_A1_USER_DOUT_MODE\t\tGENMASK(11, 10)\n#define SPIFC_A1_USER_DOUT_BYTES\tGENMASK(9, 0)\n\n#define SPIFC_A1_USER_CTRL2_REG\t\t0x208\n#define SPIFC_A1_USER_DUMMY_ENABLE\tBIT(31)\n#define SPIFC_A1_USER_DUMMY_MODE\tGENMASK(30, 29)\n#define SPIFC_A1_USER_DUMMY_CLK_SYCLES\tGENMASK(28, 23)\n\n#define SPIFC_A1_USER_CTRL3_REG\t\t0x20c\n#define SPIFC_A1_USER_DIN_ENABLE\tBIT(31)\n#define SPIFC_A1_USER_DIN_MODE\t\tGENMASK(28, 27)\n#define SPIFC_A1_USER_DIN_BYTES\t\tGENMASK(25, 16)\n\n#define SPIFC_A1_USER_ADDR_REG\t\t0x210\n\n#define SPIFC_A1_AHB_REQ_CTRL_REG\t0x214\n#define SPIFC_A1_AHB_REQ_ENABLE\t\tBIT(31)\n\n#define SPIFC_A1_ACTIMING0_REG\t\t(0x0088 << 2)\n#define SPIFC_A1_TSLCH\t\t\tGENMASK(31, 30)\n#define SPIFC_A1_TCLSH\t\t\tGENMASK(29, 28)\n#define SPIFC_A1_TSHWL\t\t\tGENMASK(20, 16)\n#define SPIFC_A1_TSHSL2\t\t\tGENMASK(15, 12)\n#define SPIFC_A1_TSHSL1\t\t\tGENMASK(11, 8)\n#define SPIFC_A1_TWHSL\t\t\tGENMASK(7, 0)\n\n#define SPIFC_A1_DBUF_CTRL_REG\t\t0x240\n#define SPIFC_A1_DBUF_DIR\t\tBIT(31)\n#define SPIFC_A1_DBUF_AUTO_UPDATE_ADDR\tBIT(30)\n#define SPIFC_A1_DBUF_ADDR\t\tGENMASK(7, 0)\n\n#define SPIFC_A1_DBUF_DATA_REG\t\t0x244\n\n#define SPIFC_A1_USER_DBUF_ADDR_REG\t0x248\n\n#define SPIFC_A1_BUFFER_SIZE\t\t512U\n\n#define SPIFC_A1_MAX_HZ\t\t\t200000000\n#define SPIFC_A1_MIN_HZ\t\t\t1000000\n\n#define SPIFC_A1_USER_CMD(op) ( \\\n\tSPIFC_A1_USER_CMD_ENABLE | \\\n\tFIELD_PREP(SPIFC_A1_USER_CMD_CODE, (op)->cmd.opcode) | \\\n\tFIELD_PREP(SPIFC_A1_USER_CMD_MODE, ilog2((op)->cmd.buswidth)))\n\n#define SPIFC_A1_USER_ADDR(op) ( \\\n\tSPIFC_A1_USER_ADDR_ENABLE | \\\n\tFIELD_PREP(SPIFC_A1_USER_ADDR_MODE, ilog2((op)->addr.buswidth)) | \\\n\tFIELD_PREP(SPIFC_A1_USER_ADDR_BYTES, (op)->addr.nbytes - 1))\n\n#define SPIFC_A1_USER_DUMMY(op) ( \\\n\tSPIFC_A1_USER_DUMMY_ENABLE | \\\n\tFIELD_PREP(SPIFC_A1_USER_DUMMY_MODE, ilog2((op)->dummy.buswidth)) | \\\n\tFIELD_PREP(SPIFC_A1_USER_DUMMY_CLK_SYCLES, (op)->dummy.nbytes << 3))\n\n#define SPIFC_A1_TSLCH_VAL\tFIELD_PREP(SPIFC_A1_TSLCH, 1)\n#define SPIFC_A1_TCLSH_VAL\tFIELD_PREP(SPIFC_A1_TCLSH, 1)\n#define SPIFC_A1_TSHWL_VAL\tFIELD_PREP(SPIFC_A1_TSHWL, 7)\n#define SPIFC_A1_TSHSL2_VAL\tFIELD_PREP(SPIFC_A1_TSHSL2, 7)\n#define SPIFC_A1_TSHSL1_VAL\tFIELD_PREP(SPIFC_A1_TSHSL1, 7)\n#define SPIFC_A1_TWHSL_VAL\tFIELD_PREP(SPIFC_A1_TWHSL, 2)\n#define SPIFC_A1_ACTIMING0_VAL\t(SPIFC_A1_TSLCH_VAL | SPIFC_A1_TCLSH_VAL | \\\n\t\t\t\t SPIFC_A1_TSHWL_VAL | SPIFC_A1_TSHSL2_VAL | \\\n\t\t\t\t SPIFC_A1_TSHSL1_VAL | SPIFC_A1_TWHSL_VAL)\n\nstruct amlogic_spifc_a1 {\n\tstruct spi_controller *ctrl;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tu32 curr_speed_hz;\n};\n\nstatic int amlogic_spifc_a1_request(struct amlogic_spifc_a1 *spifc, bool read)\n{\n\tu32 mask = SPIFC_A1_USER_REQUEST_FINISH |\n\t\t   (read ? SPIFC_A1_USER_DATA_UPDATED : 0);\n\tu32 val;\n\n\twritel(SPIFC_A1_USER_REQUEST_ENABLE,\n\t       spifc->base + SPIFC_A1_USER_CTRL0_REG);\n\n\treturn readl_poll_timeout(spifc->base + SPIFC_A1_USER_CTRL0_REG,\n\t\t\t\t  val, (val & mask) == mask, 0,\n\t\t\t\t  200 * USEC_PER_MSEC);\n}\n\nstatic void amlogic_spifc_a1_drain_buffer(struct amlogic_spifc_a1 *spifc,\n\t\t\t\t\t  char *buf, u32 len)\n{\n\tu32 data;\n\tconst u32 count = len / sizeof(data);\n\tconst u32 pad = len % sizeof(data);\n\n\twritel(SPIFC_A1_DBUF_AUTO_UPDATE_ADDR,\n\t       spifc->base + SPIFC_A1_DBUF_CTRL_REG);\n\tioread32_rep(spifc->base + SPIFC_A1_DBUF_DATA_REG, buf, count);\n\n\tif (pad) {\n\t\tdata = readl(spifc->base + SPIFC_A1_DBUF_DATA_REG);\n\t\tmemcpy(buf + len - pad, &data, pad);\n\t}\n}\n\nstatic void amlogic_spifc_a1_fill_buffer(struct amlogic_spifc_a1 *spifc,\n\t\t\t\t\t const char *buf, u32 len)\n{\n\tu32 data;\n\tconst u32 count = len / sizeof(data);\n\tconst u32 pad = len % sizeof(data);\n\n\twritel(SPIFC_A1_DBUF_DIR | SPIFC_A1_DBUF_AUTO_UPDATE_ADDR,\n\t       spifc->base + SPIFC_A1_DBUF_CTRL_REG);\n\tiowrite32_rep(spifc->base + SPIFC_A1_DBUF_DATA_REG, buf, count);\n\n\tif (pad) {\n\t\tmemcpy(&data, buf + len - pad, pad);\n\t\twritel(data, spifc->base + SPIFC_A1_DBUF_DATA_REG);\n\t}\n}\n\nstatic void amlogic_spifc_a1_user_init(struct amlogic_spifc_a1 *spifc)\n{\n\twritel(0, spifc->base + SPIFC_A1_USER_CTRL0_REG);\n\twritel(0, spifc->base + SPIFC_A1_USER_CTRL1_REG);\n\twritel(0, spifc->base + SPIFC_A1_USER_CTRL2_REG);\n\twritel(0, spifc->base + SPIFC_A1_USER_CTRL3_REG);\n}\n\nstatic void amlogic_spifc_a1_set_cmd(struct amlogic_spifc_a1 *spifc,\n\t\t\t\t     u32 cmd_cfg)\n{\n\tu32 val;\n\n\tval = readl(spifc->base + SPIFC_A1_USER_CTRL1_REG);\n\tval &= ~(SPIFC_A1_USER_CMD_MODE | SPIFC_A1_USER_CMD_CODE);\n\tval |= cmd_cfg;\n\twritel(val, spifc->base + SPIFC_A1_USER_CTRL1_REG);\n}\n\nstatic void amlogic_spifc_a1_set_addr(struct amlogic_spifc_a1 *spifc, u32 addr,\n\t\t\t\t      u32 addr_cfg)\n{\n\tu32 val;\n\n\twritel(addr, spifc->base + SPIFC_A1_USER_ADDR_REG);\n\n\tval = readl(spifc->base + SPIFC_A1_USER_CTRL1_REG);\n\tval &= ~(SPIFC_A1_USER_ADDR_MODE | SPIFC_A1_USER_ADDR_BYTES);\n\tval |= addr_cfg;\n\twritel(val, spifc->base + SPIFC_A1_USER_CTRL1_REG);\n}\n\nstatic void amlogic_spifc_a1_set_dummy(struct amlogic_spifc_a1 *spifc,\n\t\t\t\t       u32 dummy_cfg)\n{\n\tu32 val = readl(spifc->base + SPIFC_A1_USER_CTRL2_REG);\n\n\tval &= ~(SPIFC_A1_USER_DUMMY_MODE | SPIFC_A1_USER_DUMMY_CLK_SYCLES);\n\tval |= dummy_cfg;\n\twritel(val, spifc->base + SPIFC_A1_USER_CTRL2_REG);\n}\n\nstatic int amlogic_spifc_a1_read(struct amlogic_spifc_a1 *spifc, void *buf,\n\t\t\t\t u32 size, u32 mode)\n{\n\tu32 val = readl(spifc->base + SPIFC_A1_USER_CTRL3_REG);\n\tint ret;\n\n\tval &= ~(SPIFC_A1_USER_DIN_MODE | SPIFC_A1_USER_DIN_BYTES);\n\tval |= SPIFC_A1_USER_DIN_ENABLE;\n\tval |= FIELD_PREP(SPIFC_A1_USER_DIN_MODE, mode);\n\tval |= FIELD_PREP(SPIFC_A1_USER_DIN_BYTES, size);\n\twritel(val, spifc->base + SPIFC_A1_USER_CTRL3_REG);\n\n\tret = amlogic_spifc_a1_request(spifc, true);\n\tif (!ret)\n\t\tamlogic_spifc_a1_drain_buffer(spifc, buf, size);\n\n\treturn ret;\n}\n\nstatic int amlogic_spifc_a1_write(struct amlogic_spifc_a1 *spifc,\n\t\t\t\t  const void *buf, u32 size, u32 mode)\n{\n\tu32 val;\n\n\tamlogic_spifc_a1_fill_buffer(spifc, buf, size);\n\n\tval = readl(spifc->base + SPIFC_A1_USER_CTRL1_REG);\n\tval &= ~(SPIFC_A1_USER_DOUT_MODE | SPIFC_A1_USER_DOUT_BYTES);\n\tval |= FIELD_PREP(SPIFC_A1_USER_DOUT_MODE, mode);\n\tval |= FIELD_PREP(SPIFC_A1_USER_DOUT_BYTES, size);\n\tval |= SPIFC_A1_USER_DOUT_ENABLE;\n\twritel(val, spifc->base + SPIFC_A1_USER_CTRL1_REG);\n\n\treturn amlogic_spifc_a1_request(spifc, false);\n}\n\nstatic int amlogic_spifc_a1_set_freq(struct amlogic_spifc_a1 *spifc, u32 freq)\n{\n\tint ret;\n\n\tif (freq == spifc->curr_speed_hz)\n\t\treturn 0;\n\n\tret = clk_set_rate(spifc->clk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tspifc->curr_speed_hz = freq;\n\treturn 0;\n}\n\nstatic int amlogic_spifc_a1_exec_op(struct spi_mem *mem,\n\t\t\t\t    const struct spi_mem_op *op)\n{\n\tstruct amlogic_spifc_a1 *spifc =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tsize_t data_size = op->data.nbytes;\n\tint ret;\n\n\tret = amlogic_spifc_a1_set_freq(spifc, mem->spi->max_speed_hz);\n\tif (ret)\n\t\treturn ret;\n\n\tamlogic_spifc_a1_user_init(spifc);\n\tamlogic_spifc_a1_set_cmd(spifc, SPIFC_A1_USER_CMD(op));\n\n\tif (op->addr.nbytes)\n\t\tamlogic_spifc_a1_set_addr(spifc, op->addr.val,\n\t\t\t\t\t  SPIFC_A1_USER_ADDR(op));\n\n\tif (op->dummy.nbytes)\n\t\tamlogic_spifc_a1_set_dummy(spifc, SPIFC_A1_USER_DUMMY(op));\n\n\tif (data_size) {\n\t\tu32 mode = ilog2(op->data.buswidth);\n\n\t\twritel(0, spifc->base + SPIFC_A1_USER_DBUF_ADDR_REG);\n\n\t\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\t\tret = amlogic_spifc_a1_read(spifc, op->data.buf.in,\n\t\t\t\t\t\t    data_size, mode);\n\t\telse\n\t\t\tret = amlogic_spifc_a1_write(spifc, op->data.buf.out,\n\t\t\t\t\t\t     data_size, mode);\n\t} else {\n\t\tret = amlogic_spifc_a1_request(spifc, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int amlogic_spifc_a1_adjust_op_size(struct spi_mem *mem,\n\t\t\t\t\t   struct spi_mem_op *op)\n{\n\top->data.nbytes = min(op->data.nbytes, SPIFC_A1_BUFFER_SIZE);\n\treturn 0;\n}\n\nstatic void amlogic_spifc_a1_hw_init(struct amlogic_spifc_a1 *spifc)\n{\n\tu32 regv;\n\n\tregv = readl(spifc->base + SPIFC_A1_AHB_REQ_CTRL_REG);\n\tregv &= ~(SPIFC_A1_AHB_REQ_ENABLE);\n\twritel(regv, spifc->base + SPIFC_A1_AHB_REQ_CTRL_REG);\n\n\tregv = readl(spifc->base + SPIFC_A1_AHB_CTRL_REG);\n\tregv &= ~(SPIFC_A1_AHB_BUS_EN);\n\twritel(regv, spifc->base + SPIFC_A1_AHB_CTRL_REG);\n\n\twritel(SPIFC_A1_ACTIMING0_VAL, spifc->base + SPIFC_A1_ACTIMING0_REG);\n\n\twritel(0, spifc->base + SPIFC_A1_USER_DBUF_ADDR_REG);\n}\n\nstatic const struct spi_controller_mem_ops amlogic_spifc_a1_mem_ops = {\n\t.exec_op = amlogic_spifc_a1_exec_op,\n\t.adjust_op_size = amlogic_spifc_a1_adjust_op_size,\n};\n\nstatic int amlogic_spifc_a1_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctrl;\n\tstruct amlogic_spifc_a1 *spifc;\n\tint ret;\n\n\tctrl = devm_spi_alloc_host(&pdev->dev, sizeof(*spifc));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tspifc = spi_controller_get_devdata(ctrl);\n\tplatform_set_drvdata(pdev, spifc);\n\n\tspifc->dev = &pdev->dev;\n\tspifc->ctrl = ctrl;\n\n\tspifc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spifc->base))\n\t\treturn PTR_ERR(spifc->base);\n\n\tspifc->clk = devm_clk_get_enabled(spifc->dev, NULL);\n\tif (IS_ERR(spifc->clk))\n\t\treturn dev_err_probe(spifc->dev, PTR_ERR(spifc->clk),\n\t\t\t\t     \"unable to get clock\\n\");\n\n\tamlogic_spifc_a1_hw_init(spifc);\n\n\tpm_runtime_set_autosuspend_delay(spifc->dev, 500);\n\tpm_runtime_use_autosuspend(spifc->dev);\n\tdevm_pm_runtime_enable(spifc->dev);\n\n\tctrl->num_chipselect = 1;\n\tctrl->dev.of_node = pdev->dev.of_node;\n\tctrl->bits_per_word_mask = SPI_BPW_MASK(8);\n\tctrl->auto_runtime_pm = true;\n\tctrl->mem_ops = &amlogic_spifc_a1_mem_ops;\n\tctrl->min_speed_hz = SPIFC_A1_MIN_HZ;\n\tctrl->max_speed_hz = SPIFC_A1_MAX_HZ;\n\tctrl->mode_bits = (SPI_RX_DUAL | SPI_TX_DUAL |\n\t\t\t   SPI_RX_QUAD | SPI_TX_QUAD);\n\n\tret = devm_spi_register_controller(spifc->dev, ctrl);\n\tif (ret)\n\t\treturn dev_err_probe(spifc->dev, ret,\n\t\t\t\t     \"failed to register spi controller\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int amlogic_spifc_a1_suspend(struct device *dev)\n{\n\tstruct amlogic_spifc_a1 *spifc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(spifc->ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tclk_disable_unprepare(spifc->clk);\n\n\treturn 0;\n}\n\nstatic int amlogic_spifc_a1_resume(struct device *dev)\n{\n\tstruct amlogic_spifc_a1 *spifc = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = clk_prepare_enable(spifc->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tamlogic_spifc_a1_hw_init(spifc);\n\n\tret = spi_controller_resume(spifc->ctrl);\n\tif (ret)\n\t\tclk_disable_unprepare(spifc->clk);\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int amlogic_spifc_a1_runtime_suspend(struct device *dev)\n{\n\tstruct amlogic_spifc_a1 *spifc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(spifc->clk);\n\n\treturn 0;\n}\n\nstatic int amlogic_spifc_a1_runtime_resume(struct device *dev)\n{\n\tstruct amlogic_spifc_a1 *spifc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(spifc->clk);\n\tif (!ret)\n\t\tamlogic_spifc_a1_hw_init(spifc);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct dev_pm_ops amlogic_spifc_a1_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(amlogic_spifc_a1_suspend,\n\t\t\t\tamlogic_spifc_a1_resume)\n\tSET_RUNTIME_PM_OPS(amlogic_spifc_a1_runtime_suspend,\n\t\t\t   amlogic_spifc_a1_runtime_resume,\n\t\t\t   NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id amlogic_spifc_a1_dt_match[] = {\n\t{ .compatible = \"amlogic,a1-spifc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, amlogic_spifc_a1_dt_match);\n#endif  \n\nstatic struct platform_driver amlogic_spifc_a1_driver = {\n\t.probe\t= amlogic_spifc_a1_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"amlogic-spifc-a1\",\n\t\t.of_match_table\t= of_match_ptr(amlogic_spifc_a1_dt_match),\n\t\t.pm\t\t= &amlogic_spifc_a1_pm_ops,\n\t},\n};\nmodule_platform_driver(amlogic_spifc_a1_driver);\n\nMODULE_AUTHOR(\"Martin Kurbanov <mmkurbanov@sberdevices.ru>\");\nMODULE_DESCRIPTION(\"Amlogic A1 SPIFC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}