{
  "module_name": "spi-omap2-mcspi.c",
  "hash_id": "22cdc567fa2ea0d6c4f6af002008a8ab84096ce36850ee5c652e0696b1e268d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-omap2-mcspi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/gcd.h>\n\n#include <linux/spi/spi.h>\n\n#include <linux/platform_data/spi-omap2-mcspi.h>\n\n#define OMAP2_MCSPI_MAX_FREQ\t\t48000000\n#define OMAP2_MCSPI_MAX_DIVIDER\t\t4096\n#define OMAP2_MCSPI_MAX_FIFODEPTH\t64\n#define OMAP2_MCSPI_MAX_FIFOWCNT\t0xFFFF\n#define SPI_AUTOSUSPEND_TIMEOUT\t\t2000\n\n#define OMAP2_MCSPI_REVISION\t\t0x00\n#define OMAP2_MCSPI_SYSSTATUS\t\t0x14\n#define OMAP2_MCSPI_IRQSTATUS\t\t0x18\n#define OMAP2_MCSPI_IRQENABLE\t\t0x1c\n#define OMAP2_MCSPI_WAKEUPENABLE\t0x20\n#define OMAP2_MCSPI_SYST\t\t0x24\n#define OMAP2_MCSPI_MODULCTRL\t\t0x28\n#define OMAP2_MCSPI_XFERLEVEL\t\t0x7c\n\n \n#define OMAP2_MCSPI_CHCONF0\t\t0x2c\n#define OMAP2_MCSPI_CHSTAT0\t\t0x30\n#define OMAP2_MCSPI_CHCTRL0\t\t0x34\n#define OMAP2_MCSPI_TX0\t\t\t0x38\n#define OMAP2_MCSPI_RX0\t\t\t0x3c\n\n \n#define OMAP2_MCSPI_IRQSTATUS_EOW\tBIT(17)\n\n#define OMAP2_MCSPI_MODULCTRL_SINGLE\tBIT(0)\n#define OMAP2_MCSPI_MODULCTRL_MS\tBIT(2)\n#define OMAP2_MCSPI_MODULCTRL_STEST\tBIT(3)\n\n#define OMAP2_MCSPI_CHCONF_PHA\t\tBIT(0)\n#define OMAP2_MCSPI_CHCONF_POL\t\tBIT(1)\n#define OMAP2_MCSPI_CHCONF_CLKD_MASK\t(0x0f << 2)\n#define OMAP2_MCSPI_CHCONF_EPOL\t\tBIT(6)\n#define OMAP2_MCSPI_CHCONF_WL_MASK\t(0x1f << 7)\n#define OMAP2_MCSPI_CHCONF_TRM_RX_ONLY\tBIT(12)\n#define OMAP2_MCSPI_CHCONF_TRM_TX_ONLY\tBIT(13)\n#define OMAP2_MCSPI_CHCONF_TRM_MASK\t(0x03 << 12)\n#define OMAP2_MCSPI_CHCONF_DMAW\t\tBIT(14)\n#define OMAP2_MCSPI_CHCONF_DMAR\t\tBIT(15)\n#define OMAP2_MCSPI_CHCONF_DPE0\t\tBIT(16)\n#define OMAP2_MCSPI_CHCONF_DPE1\t\tBIT(17)\n#define OMAP2_MCSPI_CHCONF_IS\t\tBIT(18)\n#define OMAP2_MCSPI_CHCONF_TURBO\tBIT(19)\n#define OMAP2_MCSPI_CHCONF_FORCE\tBIT(20)\n#define OMAP2_MCSPI_CHCONF_FFET\t\tBIT(27)\n#define OMAP2_MCSPI_CHCONF_FFER\t\tBIT(28)\n#define OMAP2_MCSPI_CHCONF_CLKG\t\tBIT(29)\n\n#define OMAP2_MCSPI_CHSTAT_RXS\t\tBIT(0)\n#define OMAP2_MCSPI_CHSTAT_TXS\t\tBIT(1)\n#define OMAP2_MCSPI_CHSTAT_EOT\t\tBIT(2)\n#define OMAP2_MCSPI_CHSTAT_TXFFE\tBIT(3)\n\n#define OMAP2_MCSPI_CHCTRL_EN\t\tBIT(0)\n#define OMAP2_MCSPI_CHCTRL_EXTCLK_MASK\t(0xff << 8)\n\n#define OMAP2_MCSPI_WAKEUPENABLE_WKEN\tBIT(0)\n\n \nstruct omap2_mcspi_dma {\n\tstruct dma_chan *dma_tx;\n\tstruct dma_chan *dma_rx;\n\n\tstruct completion dma_tx_completion;\n\tstruct completion dma_rx_completion;\n\n\tchar dma_rx_ch_name[14];\n\tchar dma_tx_ch_name[14];\n};\n\n \n#define DMA_MIN_BYTES\t\t\t160\n\n\n \nstruct omap2_mcspi_regs {\n\tu32 modulctrl;\n\tu32 wakeupenable;\n\tstruct list_head cs;\n};\n\nstruct omap2_mcspi {\n\tstruct completion\ttxdone;\n\tstruct spi_controller\t*ctlr;\n\t \n\tvoid __iomem\t\t*base;\n\tunsigned long\t\tphys;\n\t \n\tstruct omap2_mcspi_dma\t*dma_channels;\n\tstruct device\t\t*dev;\n\tstruct omap2_mcspi_regs ctx;\n\tstruct clk\t\t*ref_clk;\n\tint\t\t\tfifo_depth;\n\tbool\t\t\ttarget_aborted;\n\tunsigned int\t\tpin_dir:1;\n\tsize_t\t\t\tmax_xfer_len;\n\tu32\t\t\tref_clk_hz;\n};\n\nstruct omap2_mcspi_cs {\n\tvoid __iomem\t\t*base;\n\tunsigned long\t\tphys;\n\tint\t\t\tword_len;\n\tu16\t\t\tmode;\n\tstruct list_head\tnode;\n\t \n\tu32\t\t\tchconf0, chctrl0;\n};\n\nstatic inline void mcspi_write_reg(struct spi_controller *ctlr,\n\t\tint idx, u32 val)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\n\twritel_relaxed(val, mcspi->base + idx);\n}\n\nstatic inline u32 mcspi_read_reg(struct spi_controller *ctlr, int idx)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\n\treturn readl_relaxed(mcspi->base + idx);\n}\n\nstatic inline void mcspi_write_cs_reg(const struct spi_device *spi,\n\t\tint idx, u32 val)\n{\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\n\twritel_relaxed(val, cs->base +  idx);\n}\n\nstatic inline u32 mcspi_read_cs_reg(const struct spi_device *spi, int idx)\n{\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\n\treturn readl_relaxed(cs->base + idx);\n}\n\nstatic inline u32 mcspi_cached_chconf0(const struct spi_device *spi)\n{\n\tstruct omap2_mcspi_cs *cs = spi->controller_state;\n\n\treturn cs->chconf0;\n}\n\nstatic inline void mcspi_write_chconf0(const struct spi_device *spi, u32 val)\n{\n\tstruct omap2_mcspi_cs *cs = spi->controller_state;\n\n\tcs->chconf0 = val;\n\tmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, val);\n\tmcspi_read_cs_reg(spi, OMAP2_MCSPI_CHCONF0);\n}\n\nstatic inline int mcspi_bytes_per_word(int word_len)\n{\n\tif (word_len <= 8)\n\t\treturn 1;\n\telse if (word_len <= 16)\n\t\treturn 2;\n\telse  \n\t\treturn 4;\n}\n\nstatic void omap2_mcspi_set_dma_req(const struct spi_device *spi,\n\t\tint is_read, int enable)\n{\n\tu32 l, rw;\n\n\tl = mcspi_cached_chconf0(spi);\n\n\tif (is_read)  \n\t\trw = OMAP2_MCSPI_CHCONF_DMAR;\n\telse\n\t\trw = OMAP2_MCSPI_CHCONF_DMAW;\n\n\tif (enable)\n\t\tl |= rw;\n\telse\n\t\tl &= ~rw;\n\n\tmcspi_write_chconf0(spi, l);\n}\n\nstatic void omap2_mcspi_set_enable(const struct spi_device *spi, int enable)\n{\n\tstruct omap2_mcspi_cs *cs = spi->controller_state;\n\tu32 l;\n\n\tl = cs->chctrl0;\n\tif (enable)\n\t\tl |= OMAP2_MCSPI_CHCTRL_EN;\n\telse\n\t\tl &= ~OMAP2_MCSPI_CHCTRL_EN;\n\tcs->chctrl0 = l;\n\tmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);\n\t \n\tmcspi_read_cs_reg(spi, OMAP2_MCSPI_CHCTRL0);\n}\n\nstatic void omap2_mcspi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(spi->controller);\n\tu32 l;\n\n\t \n\tif (spi->mode & SPI_CS_HIGH)\n\t\tenable = !enable;\n\n\tif (spi->controller_state) {\n\t\tint err = pm_runtime_resume_and_get(mcspi->dev);\n\t\tif (err < 0) {\n\t\t\tdev_err(mcspi->dev, \"failed to get sync: %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\n\t\tl = mcspi_cached_chconf0(spi);\n\n\t\tif (enable)\n\t\t\tl &= ~OMAP2_MCSPI_CHCONF_FORCE;\n\t\telse\n\t\t\tl |= OMAP2_MCSPI_CHCONF_FORCE;\n\n\t\tmcspi_write_chconf0(spi, l);\n\n\t\tpm_runtime_mark_last_busy(mcspi->dev);\n\t\tpm_runtime_put_autosuspend(mcspi->dev);\n\t}\n}\n\nstatic void omap2_mcspi_set_mode(struct spi_controller *ctlr)\n{\n\tstruct omap2_mcspi\t*mcspi = spi_controller_get_devdata(ctlr);\n\tstruct omap2_mcspi_regs\t*ctx = &mcspi->ctx;\n\tu32 l;\n\n\t \n\tl = mcspi_read_reg(ctlr, OMAP2_MCSPI_MODULCTRL);\n\tl &= ~(OMAP2_MCSPI_MODULCTRL_STEST);\n\tif (spi_controller_is_target(ctlr)) {\n\t\tl |= (OMAP2_MCSPI_MODULCTRL_MS);\n\t} else {\n\t\tl &= ~(OMAP2_MCSPI_MODULCTRL_MS);\n\t\tl |= OMAP2_MCSPI_MODULCTRL_SINGLE;\n\t}\n\tmcspi_write_reg(ctlr, OMAP2_MCSPI_MODULCTRL, l);\n\n\tctx->modulctrl = l;\n}\n\nstatic void omap2_mcspi_set_fifo(const struct spi_device *spi,\n\t\t\t\tstruct spi_transfer *t, int enable)\n{\n\tstruct spi_controller *ctlr = spi->controller;\n\tstruct omap2_mcspi_cs *cs = spi->controller_state;\n\tstruct omap2_mcspi *mcspi;\n\tunsigned int wcnt;\n\tint max_fifo_depth, bytes_per_word;\n\tu32 chconf, xferlevel;\n\n\tmcspi = spi_controller_get_devdata(ctlr);\n\n\tchconf = mcspi_cached_chconf0(spi);\n\tif (enable) {\n\t\tbytes_per_word = mcspi_bytes_per_word(cs->word_len);\n\t\tif (t->len % bytes_per_word != 0)\n\t\t\tgoto disable_fifo;\n\n\t\tif (t->rx_buf != NULL && t->tx_buf != NULL)\n\t\t\tmax_fifo_depth = OMAP2_MCSPI_MAX_FIFODEPTH / 2;\n\t\telse\n\t\t\tmax_fifo_depth = OMAP2_MCSPI_MAX_FIFODEPTH;\n\n\t\twcnt = t->len / bytes_per_word;\n\t\tif (wcnt > OMAP2_MCSPI_MAX_FIFOWCNT)\n\t\t\tgoto disable_fifo;\n\n\t\txferlevel = wcnt << 16;\n\t\tif (t->rx_buf != NULL) {\n\t\t\tchconf |= OMAP2_MCSPI_CHCONF_FFER;\n\t\t\txferlevel |= (bytes_per_word - 1) << 8;\n\t\t}\n\n\t\tif (t->tx_buf != NULL) {\n\t\t\tchconf |= OMAP2_MCSPI_CHCONF_FFET;\n\t\t\txferlevel |= bytes_per_word - 1;\n\t\t}\n\n\t\tmcspi_write_reg(ctlr, OMAP2_MCSPI_XFERLEVEL, xferlevel);\n\t\tmcspi_write_chconf0(spi, chconf);\n\t\tmcspi->fifo_depth = max_fifo_depth;\n\n\t\treturn;\n\t}\n\ndisable_fifo:\n\tif (t->rx_buf != NULL)\n\t\tchconf &= ~OMAP2_MCSPI_CHCONF_FFER;\n\n\tif (t->tx_buf != NULL)\n\t\tchconf &= ~OMAP2_MCSPI_CHCONF_FFET;\n\n\tmcspi_write_chconf0(spi, chconf);\n\tmcspi->fifo_depth = 0;\n}\n\nstatic int mcspi_wait_for_reg_bit(void __iomem *reg, unsigned long bit)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (!(readl_relaxed(reg) & bit)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tif (!(readl_relaxed(reg) & bit))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nstatic int mcspi_wait_for_completion(struct  omap2_mcspi *mcspi,\n\t\t\t\t     struct completion *x)\n{\n\tif (spi_controller_is_target(mcspi->ctlr)) {\n\t\tif (wait_for_completion_interruptible(x) ||\n\t\t    mcspi->target_aborted)\n\t\t\treturn -EINTR;\n\t} else {\n\t\twait_for_completion(x);\n\t}\n\n\treturn 0;\n}\n\nstatic void omap2_mcspi_rx_callback(void *data)\n{\n\tstruct spi_device *spi = data;\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(spi->controller);\n\tstruct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\t \n\tomap2_mcspi_set_dma_req(spi, 1, 0);\n\n\tcomplete(&mcspi_dma->dma_rx_completion);\n}\n\nstatic void omap2_mcspi_tx_callback(void *data)\n{\n\tstruct spi_device *spi = data;\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(spi->controller);\n\tstruct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\t \n\tomap2_mcspi_set_dma_req(spi, 0, 0);\n\n\tcomplete(&mcspi_dma->dma_tx_completion);\n}\n\nstatic void omap2_mcspi_tx_dma(struct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer,\n\t\t\t\tstruct dma_slave_config cfg)\n{\n\tstruct omap2_mcspi\t*mcspi;\n\tstruct omap2_mcspi_dma  *mcspi_dma;\n\tstruct dma_async_tx_descriptor *tx;\n\n\tmcspi = spi_controller_get_devdata(spi->controller);\n\tmcspi_dma = &mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\tdmaengine_slave_config(mcspi_dma->dma_tx, &cfg);\n\n\ttx = dmaengine_prep_slave_sg(mcspi_dma->dma_tx, xfer->tx_sg.sgl,\n\t\t\t\t     xfer->tx_sg.nents,\n\t\t\t\t     DMA_MEM_TO_DEV,\n\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (tx) {\n\t\ttx->callback = omap2_mcspi_tx_callback;\n\t\ttx->callback_param = spi;\n\t\tdmaengine_submit(tx);\n\t} else {\n\t\t \n\t}\n\tdma_async_issue_pending(mcspi_dma->dma_tx);\n\tomap2_mcspi_set_dma_req(spi, 0, 1);\n}\n\nstatic unsigned\nomap2_mcspi_rx_dma(struct spi_device *spi, struct spi_transfer *xfer,\n\t\t\t\tstruct dma_slave_config cfg,\n\t\t\t\tunsigned es)\n{\n\tstruct omap2_mcspi\t*mcspi;\n\tstruct omap2_mcspi_dma  *mcspi_dma;\n\tunsigned int\t\tcount, transfer_reduction = 0;\n\tstruct scatterlist\t*sg_out[2];\n\tint\t\t\tnb_sizes = 0, out_mapped_nents[2], ret, x;\n\tsize_t\t\t\tsizes[2];\n\tu32\t\t\tl;\n\tint\t\t\telements = 0;\n\tint\t\t\tword_len, element_count;\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\tvoid __iomem\t\t*chstat_reg = cs->base + OMAP2_MCSPI_CHSTAT0;\n\tstruct dma_async_tx_descriptor *tx;\n\n\tmcspi = spi_controller_get_devdata(spi->controller);\n\tmcspi_dma = &mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\tcount = xfer->len;\n\n\t \n\tif (mcspi->fifo_depth == 0)\n\t\ttransfer_reduction = es;\n\n\tword_len = cs->word_len;\n\tl = mcspi_cached_chconf0(spi);\n\n\tif (word_len <= 8)\n\t\telement_count = count;\n\telse if (word_len <= 16)\n\t\telement_count = count >> 1;\n\telse  \n\t\telement_count = count >> 2;\n\n\n\tdmaengine_slave_config(mcspi_dma->dma_rx, &cfg);\n\n\t \n\tif ((l & OMAP2_MCSPI_CHCONF_TURBO) && mcspi->fifo_depth == 0)\n\t\ttransfer_reduction += es;\n\n\tif (transfer_reduction) {\n\t\t \n\t\tsizes[0] = count - transfer_reduction;\n\t\tsizes[1] = transfer_reduction;\n\t\tnb_sizes = 2;\n\t} else {\n\t\t \n\t\tsizes[0] = count;\n\t\tnb_sizes = 1;\n\t}\n\n\tret = sg_split(xfer->rx_sg.sgl, xfer->rx_sg.nents, 0, nb_sizes,\n\t\t       sizes, sg_out, out_mapped_nents, GFP_KERNEL);\n\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"sg_split failed\\n\");\n\t\treturn 0;\n\t}\n\n\ttx = dmaengine_prep_slave_sg(mcspi_dma->dma_rx, sg_out[0],\n\t\t\t\t     out_mapped_nents[0], DMA_DEV_TO_MEM,\n\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (tx) {\n\t\ttx->callback = omap2_mcspi_rx_callback;\n\t\ttx->callback_param = spi;\n\t\tdmaengine_submit(tx);\n\t} else {\n\t\t \n\t}\n\n\tdma_async_issue_pending(mcspi_dma->dma_rx);\n\tomap2_mcspi_set_dma_req(spi, 1, 1);\n\n\tret = mcspi_wait_for_completion(mcspi, &mcspi_dma->dma_rx_completion);\n\tif (ret || mcspi->target_aborted) {\n\t\tdmaengine_terminate_sync(mcspi_dma->dma_rx);\n\t\tomap2_mcspi_set_dma_req(spi, 1, 0);\n\t\treturn 0;\n\t}\n\n\tfor (x = 0; x < nb_sizes; x++)\n\t\tkfree(sg_out[x]);\n\n\tif (mcspi->fifo_depth > 0)\n\t\treturn count;\n\n\t \n\tomap2_mcspi_set_enable(spi, 0);\n\n\telements = element_count - 1;\n\n\tif (l & OMAP2_MCSPI_CHCONF_TURBO) {\n\t\telements--;\n\n\t\tif (!mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t    OMAP2_MCSPI_CHSTAT_RXS)) {\n\t\t\tu32 w;\n\n\t\t\tw = mcspi_read_cs_reg(spi, OMAP2_MCSPI_RX0);\n\t\t\tif (word_len <= 8)\n\t\t\t\t((u8 *)xfer->rx_buf)[elements++] = w;\n\t\t\telse if (word_len <= 16)\n\t\t\t\t((u16 *)xfer->rx_buf)[elements++] = w;\n\t\t\telse  \n\t\t\t\t((u32 *)xfer->rx_buf)[elements++] = w;\n\t\t} else {\n\t\t\tint bytes_per_word = mcspi_bytes_per_word(word_len);\n\t\t\tdev_err(&spi->dev, \"DMA RX penultimate word empty\\n\");\n\t\t\tcount -= (bytes_per_word << 1);\n\t\t\tomap2_mcspi_set_enable(spi, 1);\n\t\t\treturn count;\n\t\t}\n\t}\n\tif (!mcspi_wait_for_reg_bit(chstat_reg, OMAP2_MCSPI_CHSTAT_RXS)) {\n\t\tu32 w;\n\n\t\tw = mcspi_read_cs_reg(spi, OMAP2_MCSPI_RX0);\n\t\tif (word_len <= 8)\n\t\t\t((u8 *)xfer->rx_buf)[elements] = w;\n\t\telse if (word_len <= 16)\n\t\t\t((u16 *)xfer->rx_buf)[elements] = w;\n\t\telse  \n\t\t\t((u32 *)xfer->rx_buf)[elements] = w;\n\t} else {\n\t\tdev_err(&spi->dev, \"DMA RX last word empty\\n\");\n\t\tcount -= mcspi_bytes_per_word(word_len);\n\t}\n\tomap2_mcspi_set_enable(spi, 1);\n\treturn count;\n}\n\nstatic unsigned\nomap2_mcspi_txrx_dma(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct omap2_mcspi\t*mcspi;\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\tstruct omap2_mcspi_dma  *mcspi_dma;\n\tunsigned int\t\tcount;\n\tu8\t\t\t*rx;\n\tconst u8\t\t*tx;\n\tstruct dma_slave_config\tcfg;\n\tenum dma_slave_buswidth width;\n\tunsigned es;\n\tvoid __iomem\t\t*chstat_reg;\n\tvoid __iomem            *irqstat_reg;\n\tint\t\t\twait_res;\n\n\tmcspi = spi_controller_get_devdata(spi->controller);\n\tmcspi_dma = &mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\tif (cs->word_len <= 8) {\n\t\twidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tes = 1;\n\t} else if (cs->word_len <= 16) {\n\t\twidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tes = 2;\n\t} else {\n\t\twidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tes = 4;\n\t}\n\n\tcount = xfer->len;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.src_addr = cs->phys + OMAP2_MCSPI_RX0;\n\tcfg.dst_addr = cs->phys + OMAP2_MCSPI_TX0;\n\tcfg.src_addr_width = width;\n\tcfg.dst_addr_width = width;\n\tcfg.src_maxburst = 1;\n\tcfg.dst_maxburst = 1;\n\n\trx = xfer->rx_buf;\n\ttx = xfer->tx_buf;\n\n\tmcspi->target_aborted = false;\n\treinit_completion(&mcspi_dma->dma_tx_completion);\n\treinit_completion(&mcspi_dma->dma_rx_completion);\n\treinit_completion(&mcspi->txdone);\n\tif (tx) {\n\t\t \n\t\tif (spi_controller_is_target(spi->controller))\n\t\t\tmcspi_write_reg(spi->controller,\n\t\t\t\t\tOMAP2_MCSPI_IRQENABLE,\n\t\t\t\t\tOMAP2_MCSPI_IRQSTATUS_EOW);\n\t\tomap2_mcspi_tx_dma(spi, xfer, cfg);\n\t}\n\n\tif (rx != NULL)\n\t\tcount = omap2_mcspi_rx_dma(spi, xfer, cfg, es);\n\n\tif (tx != NULL) {\n\t\tint ret;\n\n\t\tret = mcspi_wait_for_completion(mcspi, &mcspi_dma->dma_tx_completion);\n\t\tif (ret || mcspi->target_aborted) {\n\t\t\tdmaengine_terminate_sync(mcspi_dma->dma_tx);\n\t\t\tomap2_mcspi_set_dma_req(spi, 0, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (spi_controller_is_target(mcspi->ctlr)) {\n\t\t\tret = mcspi_wait_for_completion(mcspi, &mcspi->txdone);\n\t\t\tif (ret || mcspi->target_aborted)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (mcspi->fifo_depth > 0) {\n\t\t\tirqstat_reg = mcspi->base + OMAP2_MCSPI_IRQSTATUS;\n\n\t\t\tif (mcspi_wait_for_reg_bit(irqstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_IRQSTATUS_EOW) < 0)\n\t\t\t\tdev_err(&spi->dev, \"EOW timed out\\n\");\n\n\t\t\tmcspi_write_reg(mcspi->ctlr, OMAP2_MCSPI_IRQSTATUS,\n\t\t\t\t\tOMAP2_MCSPI_IRQSTATUS_EOW);\n\t\t}\n\n\t\t \n\t\tif (rx == NULL) {\n\t\t\tchstat_reg = cs->base + OMAP2_MCSPI_CHSTAT0;\n\t\t\tif (mcspi->fifo_depth > 0) {\n\t\t\t\twait_res = mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_TXFFE);\n\t\t\t\tif (wait_res < 0)\n\t\t\t\t\tdev_err(&spi->dev, \"TXFFE timed out\\n\");\n\t\t\t} else {\n\t\t\t\twait_res = mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_TXS);\n\t\t\t\tif (wait_res < 0)\n\t\t\t\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\t\t}\n\t\t\tif (wait_res >= 0 &&\n\t\t\t\t(mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\tOMAP2_MCSPI_CHSTAT_EOT) < 0))\n\t\t\t\tdev_err(&spi->dev, \"EOT timed out\\n\");\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic unsigned\nomap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\tunsigned int\t\tcount, c;\n\tu32\t\t\tl;\n\tvoid __iomem\t\t*base = cs->base;\n\tvoid __iomem\t\t*tx_reg;\n\tvoid __iomem\t\t*rx_reg;\n\tvoid __iomem\t\t*chstat_reg;\n\tint\t\t\tword_len;\n\n\tcount = xfer->len;\n\tc = count;\n\tword_len = cs->word_len;\n\n\tl = mcspi_cached_chconf0(spi);\n\n\t \n\ttx_reg\t\t= base + OMAP2_MCSPI_TX0;\n\trx_reg\t\t= base + OMAP2_MCSPI_RX0;\n\tchstat_reg\t= base + OMAP2_MCSPI_CHSTAT0;\n\n\tif (c < (word_len>>3))\n\t\treturn 0;\n\n\tif (word_len <= 8) {\n\t\tu8\t\t*rx;\n\t\tconst u8\t*tx;\n\n\t\trx = xfer->rx_buf;\n\t\ttx = xfer->tx_buf;\n\n\t\tdo {\n\t\t\tc -= 1;\n\t\t\tif (tx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_TXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tdev_vdbg(&spi->dev, \"write-%d %02x\\n\",\n\t\t\t\t\t\tword_len, *tx);\n\t\t\t\twritel_relaxed(*tx++, tx_reg);\n\t\t\t}\n\t\t\tif (rx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"RXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (c == 1 && tx == NULL &&\n\t\t\t\t    (l & OMAP2_MCSPI_CHCONF_TURBO)) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %02x\\n\",\n\t\t\t\t\t\t    word_len, *(rx - 1));\n\t\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\t\t\"RXS timed out\\n\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t} else if (c == 0 && tx == NULL) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t}\n\n\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %02x\\n\",\n\t\t\t\t\t\tword_len, *(rx - 1));\n\t\t\t}\n\t\t\t \n\t\t\tspi_delay_exec(&xfer->word_delay, xfer);\n\t\t} while (c);\n\t} else if (word_len <= 16) {\n\t\tu16\t\t*rx;\n\t\tconst u16\t*tx;\n\n\t\trx = xfer->rx_buf;\n\t\ttx = xfer->tx_buf;\n\t\tdo {\n\t\t\tc -= 2;\n\t\t\tif (tx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_TXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tdev_vdbg(&spi->dev, \"write-%d %04x\\n\",\n\t\t\t\t\t\tword_len, *tx);\n\t\t\t\twritel_relaxed(*tx++, tx_reg);\n\t\t\t}\n\t\t\tif (rx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"RXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (c == 2 && tx == NULL &&\n\t\t\t\t    (l & OMAP2_MCSPI_CHCONF_TURBO)) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %04x\\n\",\n\t\t\t\t\t\t    word_len, *(rx - 1));\n\t\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\t\t\"RXS timed out\\n\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t} else if (c == 0 && tx == NULL) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t}\n\n\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %04x\\n\",\n\t\t\t\t\t\tword_len, *(rx - 1));\n\t\t\t}\n\t\t\t \n\t\t\tspi_delay_exec(&xfer->word_delay, xfer);\n\t\t} while (c >= 2);\n\t} else if (word_len <= 32) {\n\t\tu32\t\t*rx;\n\t\tconst u32\t*tx;\n\n\t\trx = xfer->rx_buf;\n\t\ttx = xfer->tx_buf;\n\t\tdo {\n\t\t\tc -= 4;\n\t\t\tif (tx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_TXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tdev_vdbg(&spi->dev, \"write-%d %08x\\n\",\n\t\t\t\t\t\tword_len, *tx);\n\t\t\t\twritel_relaxed(*tx++, tx_reg);\n\t\t\t}\n\t\t\tif (rx != NULL) {\n\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\tdev_err(&spi->dev, \"RXS timed out\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (c == 4 && tx == NULL &&\n\t\t\t\t    (l & OMAP2_MCSPI_CHCONF_TURBO)) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %08x\\n\",\n\t\t\t\t\t\t    word_len, *(rx - 1));\n\t\t\t\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\t\t\tOMAP2_MCSPI_CHSTAT_RXS) < 0) {\n\t\t\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\t\t\"RXS timed out\\n\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tc = 0;\n\t\t\t\t} else if (c == 0 && tx == NULL) {\n\t\t\t\t\tomap2_mcspi_set_enable(spi, 0);\n\t\t\t\t}\n\n\t\t\t\t*rx++ = readl_relaxed(rx_reg);\n\t\t\t\tdev_vdbg(&spi->dev, \"read-%d %08x\\n\",\n\t\t\t\t\t\tword_len, *(rx - 1));\n\t\t\t}\n\t\t\t \n\t\t\tspi_delay_exec(&xfer->word_delay, xfer);\n\t\t} while (c >= 4);\n\t}\n\n\t \n\tif (xfer->rx_buf == NULL) {\n\t\tif (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\tOMAP2_MCSPI_CHSTAT_TXS) < 0) {\n\t\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\t} else if (mcspi_wait_for_reg_bit(chstat_reg,\n\t\t\t\tOMAP2_MCSPI_CHSTAT_EOT) < 0)\n\t\t\tdev_err(&spi->dev, \"EOT timed out\\n\");\n\n\t\t \n\t\tomap2_mcspi_set_enable(spi, 0);\n\t}\nout:\n\tomap2_mcspi_set_enable(spi, 1);\n\treturn count - c;\n}\n\nstatic u32 omap2_mcspi_calc_divisor(u32 speed_hz, u32 ref_clk_hz)\n{\n\tu32 div;\n\n\tfor (div = 0; div < 15; div++)\n\t\tif (speed_hz >= (ref_clk_hz >> div))\n\t\t\treturn div;\n\n\treturn 15;\n}\n\n \nstatic int omap2_mcspi_setup_transfer(struct spi_device *spi,\n\t\tstruct spi_transfer *t)\n{\n\tstruct omap2_mcspi_cs *cs = spi->controller_state;\n\tstruct omap2_mcspi *mcspi;\n\tu32 ref_clk_hz, l = 0, clkd = 0, div, extclk = 0, clkg = 0;\n\tu8 word_len = spi->bits_per_word;\n\tu32 speed_hz = spi->max_speed_hz;\n\n\tmcspi = spi_controller_get_devdata(spi->controller);\n\n\tif (t != NULL && t->bits_per_word)\n\t\tword_len = t->bits_per_word;\n\n\tcs->word_len = word_len;\n\n\tif (t && t->speed_hz)\n\t\tspeed_hz = t->speed_hz;\n\n\tref_clk_hz = mcspi->ref_clk_hz;\n\tspeed_hz = min_t(u32, speed_hz, ref_clk_hz);\n\tif (speed_hz < (ref_clk_hz / OMAP2_MCSPI_MAX_DIVIDER)) {\n\t\tclkd = omap2_mcspi_calc_divisor(speed_hz, ref_clk_hz);\n\t\tspeed_hz = ref_clk_hz >> clkd;\n\t\tclkg = 0;\n\t} else {\n\t\tdiv = (ref_clk_hz + speed_hz - 1) / speed_hz;\n\t\tspeed_hz = ref_clk_hz / div;\n\t\tclkd = (div - 1) & 0xf;\n\t\textclk = (div - 1) >> 4;\n\t\tclkg = OMAP2_MCSPI_CHCONF_CLKG;\n\t}\n\n\tl = mcspi_cached_chconf0(spi);\n\n\t \n\tif (mcspi->pin_dir == MCSPI_PINDIR_D0_IN_D1_OUT) {\n\t\tl &= ~OMAP2_MCSPI_CHCONF_IS;\n\t\tl &= ~OMAP2_MCSPI_CHCONF_DPE1;\n\t\tl |= OMAP2_MCSPI_CHCONF_DPE0;\n\t} else {\n\t\tl |= OMAP2_MCSPI_CHCONF_IS;\n\t\tl |= OMAP2_MCSPI_CHCONF_DPE1;\n\t\tl &= ~OMAP2_MCSPI_CHCONF_DPE0;\n\t}\n\n\t \n\tl &= ~OMAP2_MCSPI_CHCONF_WL_MASK;\n\tl |= (word_len - 1) << 7;\n\n\t \n\tif (!(spi->mode & SPI_CS_HIGH))\n\t\tl |= OMAP2_MCSPI_CHCONF_EPOL;\t \n\telse\n\t\tl &= ~OMAP2_MCSPI_CHCONF_EPOL;\n\n\t \n\tl &= ~OMAP2_MCSPI_CHCONF_CLKD_MASK;\n\tl |= clkd << 2;\n\n\t \n\tl &= ~OMAP2_MCSPI_CHCONF_CLKG;\n\tl |= clkg;\n\tif (clkg) {\n\t\tcs->chctrl0 &= ~OMAP2_MCSPI_CHCTRL_EXTCLK_MASK;\n\t\tcs->chctrl0 |= extclk << 8;\n\t\tmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);\n\t}\n\n\t \n\tif (spi->mode & SPI_CPOL)\n\t\tl |= OMAP2_MCSPI_CHCONF_POL;\n\telse\n\t\tl &= ~OMAP2_MCSPI_CHCONF_POL;\n\tif (spi->mode & SPI_CPHA)\n\t\tl |= OMAP2_MCSPI_CHCONF_PHA;\n\telse\n\t\tl &= ~OMAP2_MCSPI_CHCONF_PHA;\n\n\tmcspi_write_chconf0(spi, l);\n\n\tcs->mode = spi->mode;\n\n\tdev_dbg(&spi->dev, \"setup: speed %d, sample %s edge, clk %s\\n\",\n\t\t\tspeed_hz,\n\t\t\t(spi->mode & SPI_CPHA) ? \"trailing\" : \"leading\",\n\t\t\t(spi->mode & SPI_CPOL) ? \"inverted\" : \"normal\");\n\n\treturn 0;\n}\n\n \nstatic int omap2_mcspi_request_dma(struct omap2_mcspi *mcspi,\n\t\t\t\t   struct omap2_mcspi_dma *mcspi_dma)\n{\n\tint ret = 0;\n\n\tmcspi_dma->dma_rx = dma_request_chan(mcspi->dev,\n\t\t\t\t\t     mcspi_dma->dma_rx_ch_name);\n\tif (IS_ERR(mcspi_dma->dma_rx)) {\n\t\tret = PTR_ERR(mcspi_dma->dma_rx);\n\t\tmcspi_dma->dma_rx = NULL;\n\t\tgoto no_dma;\n\t}\n\n\tmcspi_dma->dma_tx = dma_request_chan(mcspi->dev,\n\t\t\t\t\t     mcspi_dma->dma_tx_ch_name);\n\tif (IS_ERR(mcspi_dma->dma_tx)) {\n\t\tret = PTR_ERR(mcspi_dma->dma_tx);\n\t\tmcspi_dma->dma_tx = NULL;\n\t\tdma_release_channel(mcspi_dma->dma_rx);\n\t\tmcspi_dma->dma_rx = NULL;\n\t}\n\n\tinit_completion(&mcspi_dma->dma_rx_completion);\n\tinit_completion(&mcspi_dma->dma_tx_completion);\n\nno_dma:\n\treturn ret;\n}\n\nstatic void omap2_mcspi_release_dma(struct spi_controller *ctlr)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\tstruct omap2_mcspi_dma\t*mcspi_dma;\n\tint i;\n\n\tfor (i = 0; i < ctlr->num_chipselect; i++) {\n\t\tmcspi_dma = &mcspi->dma_channels[i];\n\n\t\tif (mcspi_dma->dma_rx) {\n\t\t\tdma_release_channel(mcspi_dma->dma_rx);\n\t\t\tmcspi_dma->dma_rx = NULL;\n\t\t}\n\t\tif (mcspi_dma->dma_tx) {\n\t\t\tdma_release_channel(mcspi_dma->dma_tx);\n\t\t\tmcspi_dma->dma_tx = NULL;\n\t\t}\n\t}\n}\n\nstatic void omap2_mcspi_cleanup(struct spi_device *spi)\n{\n\tstruct omap2_mcspi_cs\t*cs;\n\n\tif (spi->controller_state) {\n\t\t \n\t\tcs = spi->controller_state;\n\t\tlist_del(&cs->node);\n\n\t\tkfree(cs);\n\t}\n}\n\nstatic int omap2_mcspi_setup(struct spi_device *spi)\n{\n\tbool\t\t\tinitial_setup = false;\n\tint\t\t\tret;\n\tstruct omap2_mcspi\t*mcspi = spi_controller_get_devdata(spi->controller);\n\tstruct omap2_mcspi_regs\t*ctx = &mcspi->ctx;\n\tstruct omap2_mcspi_cs\t*cs = spi->controller_state;\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tcs->base = mcspi->base + spi_get_chipselect(spi, 0) * 0x14;\n\t\tcs->phys = mcspi->phys + spi_get_chipselect(spi, 0) * 0x14;\n\t\tcs->mode = 0;\n\t\tcs->chconf0 = 0;\n\t\tcs->chctrl0 = 0;\n\t\tspi->controller_state = cs;\n\t\t \n\t\tlist_add_tail(&cs->node, &ctx->cs);\n\t\tinitial_setup = true;\n\t}\n\n\tret = pm_runtime_resume_and_get(mcspi->dev);\n\tif (ret < 0) {\n\t\tif (initial_setup)\n\t\t\tomap2_mcspi_cleanup(spi);\n\n\t\treturn ret;\n\t}\n\n\tret = omap2_mcspi_setup_transfer(spi, NULL);\n\tif (ret && initial_setup)\n\t\tomap2_mcspi_cleanup(spi);\n\n\tpm_runtime_mark_last_busy(mcspi->dev);\n\tpm_runtime_put_autosuspend(mcspi->dev);\n\n\treturn ret;\n}\n\nstatic irqreturn_t omap2_mcspi_irq_handler(int irq, void *data)\n{\n\tstruct omap2_mcspi *mcspi = data;\n\tu32 irqstat;\n\n\tirqstat\t= mcspi_read_reg(mcspi->ctlr, OMAP2_MCSPI_IRQSTATUS);\n\tif (!irqstat)\n\t\treturn IRQ_NONE;\n\n\t \n\tmcspi_write_reg(mcspi->ctlr, OMAP2_MCSPI_IRQENABLE, 0);\n\tif (irqstat & OMAP2_MCSPI_IRQSTATUS_EOW)\n\t\tcomplete(&mcspi->txdone);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int omap2_mcspi_target_abort(struct spi_controller *ctlr)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\tstruct omap2_mcspi_dma *mcspi_dma = mcspi->dma_channels;\n\n\tmcspi->target_aborted = true;\n\tcomplete(&mcspi_dma->dma_rx_completion);\n\tcomplete(&mcspi_dma->dma_tx_completion);\n\tcomplete(&mcspi->txdone);\n\n\treturn 0;\n}\n\nstatic int omap2_mcspi_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *t)\n{\n\n\t \n\n\tstruct omap2_mcspi\t\t*mcspi;\n\tstruct omap2_mcspi_dma\t\t*mcspi_dma;\n\tstruct omap2_mcspi_cs\t\t*cs;\n\tstruct omap2_mcspi_device_config *cd;\n\tint\t\t\t\tpar_override = 0;\n\tint\t\t\t\tstatus = 0;\n\tu32\t\t\t\tchconf;\n\n\tmcspi = spi_controller_get_devdata(ctlr);\n\tmcspi_dma = mcspi->dma_channels + spi_get_chipselect(spi, 0);\n\tcs = spi->controller_state;\n\tcd = spi->controller_data;\n\n\t \n\tif (spi->mode != cs->mode)\n\t\tpar_override = 1;\n\n\tomap2_mcspi_set_enable(spi, 0);\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tomap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH);\n\n\tif (par_override ||\n\t    (t->speed_hz != spi->max_speed_hz) ||\n\t    (t->bits_per_word != spi->bits_per_word)) {\n\t\tpar_override = 1;\n\t\tstatus = omap2_mcspi_setup_transfer(spi, t);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t\tif (t->speed_hz == spi->max_speed_hz &&\n\t\t    t->bits_per_word == spi->bits_per_word)\n\t\t\tpar_override = 0;\n\t}\n\tif (cd && cd->cs_per_word) {\n\t\tchconf = mcspi->ctx.modulctrl;\n\t\tchconf &= ~OMAP2_MCSPI_MODULCTRL_SINGLE;\n\t\tmcspi_write_reg(ctlr, OMAP2_MCSPI_MODULCTRL, chconf);\n\t\tmcspi->ctx.modulctrl =\n\t\t\tmcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);\n\t}\n\n\tchconf = mcspi_cached_chconf0(spi);\n\tchconf &= ~OMAP2_MCSPI_CHCONF_TRM_MASK;\n\tchconf &= ~OMAP2_MCSPI_CHCONF_TURBO;\n\n\tif (t->tx_buf == NULL)\n\t\tchconf |= OMAP2_MCSPI_CHCONF_TRM_RX_ONLY;\n\telse if (t->rx_buf == NULL)\n\t\tchconf |= OMAP2_MCSPI_CHCONF_TRM_TX_ONLY;\n\n\tif (cd && cd->turbo_mode && t->tx_buf == NULL) {\n\t\t \n\t\tif (t->len > ((cs->word_len + 7) >> 3))\n\t\t\tchconf |= OMAP2_MCSPI_CHCONF_TURBO;\n\t}\n\n\tmcspi_write_chconf0(spi, chconf);\n\n\tif (t->len) {\n\t\tunsigned\tcount;\n\n\t\tif ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&\n\t\t    ctlr->cur_msg_mapped &&\n\t\t    ctlr->can_dma(ctlr, spi, t))\n\t\t\tomap2_mcspi_set_fifo(spi, t, 1);\n\n\t\tomap2_mcspi_set_enable(spi, 1);\n\n\t\t \n\t\tif (t->tx_buf == NULL)\n\t\t\twritel_relaxed(0, cs->base\n\t\t\t\t\t+ OMAP2_MCSPI_TX0);\n\n\t\tif ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&\n\t\t    ctlr->cur_msg_mapped &&\n\t\t    ctlr->can_dma(ctlr, spi, t))\n\t\t\tcount = omap2_mcspi_txrx_dma(spi, t);\n\t\telse\n\t\t\tcount = omap2_mcspi_txrx_pio(spi, t);\n\n\t\tif (count != t->len) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tomap2_mcspi_set_enable(spi, 0);\n\n\tif (mcspi->fifo_depth > 0)\n\t\tomap2_mcspi_set_fifo(spi, t, 0);\n\nout:\n\t \n\tif (par_override) {\n\t\tpar_override = 0;\n\t\tstatus = omap2_mcspi_setup_transfer(spi, NULL);\n\t}\n\n\tif (cd && cd->cs_per_word) {\n\t\tchconf = mcspi->ctx.modulctrl;\n\t\tchconf |= OMAP2_MCSPI_MODULCTRL_SINGLE;\n\t\tmcspi_write_reg(ctlr, OMAP2_MCSPI_MODULCTRL, chconf);\n\t\tmcspi->ctx.modulctrl =\n\t\t\tmcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);\n\t}\n\n\tomap2_mcspi_set_enable(spi, 0);\n\n\tif (spi_get_csgpiod(spi, 0))\n\t\tomap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH));\n\n\tif (mcspi->fifo_depth > 0 && t)\n\t\tomap2_mcspi_set_fifo(spi, t, 0);\n\n\treturn status;\n}\n\nstatic int omap2_mcspi_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t       struct spi_message *msg)\n{\n\tstruct omap2_mcspi\t*mcspi = spi_controller_get_devdata(ctlr);\n\tstruct omap2_mcspi_regs\t*ctx = &mcspi->ctx;\n\tstruct omap2_mcspi_cs\t*cs;\n\n\t \n\tlist_for_each_entry(cs, &ctx->cs, node) {\n\t\tif (msg->spi->controller_state == cs)\n\t\t\tcontinue;\n\n\t\tif ((cs->chconf0 & OMAP2_MCSPI_CHCONF_FORCE)) {\n\t\t\tcs->chconf0 &= ~OMAP2_MCSPI_CHCONF_FORCE;\n\t\t\twritel_relaxed(cs->chconf0,\n\t\t\t\t\tcs->base + OMAP2_MCSPI_CHCONF0);\n\t\t\treadl_relaxed(cs->base + OMAP2_MCSPI_CHCONF0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool omap2_mcspi_can_dma(struct spi_controller *ctlr,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *xfer)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(spi->controller);\n\tstruct omap2_mcspi_dma *mcspi_dma =\n\t\t&mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\tif (!mcspi_dma->dma_rx || !mcspi_dma->dma_tx)\n\t\treturn false;\n\n\tif (spi_controller_is_target(ctlr))\n\t\treturn true;\n\n\tctlr->dma_rx = mcspi_dma->dma_rx;\n\tctlr->dma_tx = mcspi_dma->dma_tx;\n\n\treturn (xfer->len >= DMA_MIN_BYTES);\n}\n\nstatic size_t omap2_mcspi_max_xfer_size(struct spi_device *spi)\n{\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(spi->controller);\n\tstruct omap2_mcspi_dma *mcspi_dma =\n\t\t&mcspi->dma_channels[spi_get_chipselect(spi, 0)];\n\n\tif (mcspi->max_xfer_len && mcspi_dma->dma_rx)\n\t\treturn mcspi->max_xfer_len;\n\n\treturn SIZE_MAX;\n}\n\nstatic int omap2_mcspi_controller_setup(struct omap2_mcspi *mcspi)\n{\n\tstruct spi_controller\t*ctlr = mcspi->ctlr;\n\tstruct omap2_mcspi_regs\t*ctx = &mcspi->ctx;\n\tint\t\t\tret = 0;\n\n\tret = pm_runtime_resume_and_get(mcspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmcspi_write_reg(ctlr, OMAP2_MCSPI_WAKEUPENABLE,\n\t\t\tOMAP2_MCSPI_WAKEUPENABLE_WKEN);\n\tctx->wakeupenable = OMAP2_MCSPI_WAKEUPENABLE_WKEN;\n\n\tomap2_mcspi_set_mode(ctlr);\n\tpm_runtime_mark_last_busy(mcspi->dev);\n\tpm_runtime_put_autosuspend(mcspi->dev);\n\treturn 0;\n}\n\nstatic int omap_mcspi_runtime_suspend(struct device *dev)\n{\n\tint error;\n\n\terror = pinctrl_pm_select_idle_state(dev);\n\tif (error)\n\t\tdev_warn(dev, \"%s: failed to set pins: %i\\n\", __func__, error);\n\n\treturn 0;\n}\n\n \nstatic int omap_mcspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\tstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\n\tstruct omap2_mcspi_cs *cs;\n\tint error;\n\n\terror = pinctrl_pm_select_default_state(dev);\n\tif (error)\n\t\tdev_warn(dev, \"%s: failed to set pins: %i\\n\", __func__, error);\n\n\t \n\tmcspi_write_reg(ctlr, OMAP2_MCSPI_MODULCTRL, ctx->modulctrl);\n\tmcspi_write_reg(ctlr, OMAP2_MCSPI_WAKEUPENABLE, ctx->wakeupenable);\n\n\tlist_for_each_entry(cs, &ctx->cs, node) {\n\t\t \n\t\tif ((cs->chconf0 & OMAP2_MCSPI_CHCONF_FORCE) == 0) {\n\t\t\tcs->chconf0 |= OMAP2_MCSPI_CHCONF_FORCE;\n\t\t\twritel_relaxed(cs->chconf0,\n\t\t\t\t       cs->base + OMAP2_MCSPI_CHCONF0);\n\t\t\tcs->chconf0 &= ~OMAP2_MCSPI_CHCONF_FORCE;\n\t\t\twritel_relaxed(cs->chconf0,\n\t\t\t\t       cs->base + OMAP2_MCSPI_CHCONF0);\n\t\t} else {\n\t\t\twritel_relaxed(cs->chconf0,\n\t\t\t\t       cs->base + OMAP2_MCSPI_CHCONF0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct omap2_mcspi_platform_config omap2_pdata = {\n\t.regs_offset = 0,\n};\n\nstatic struct omap2_mcspi_platform_config omap4_pdata = {\n\t.regs_offset = OMAP4_MCSPI_REG_OFFSET,\n};\n\nstatic struct omap2_mcspi_platform_config am654_pdata = {\n\t.regs_offset = OMAP4_MCSPI_REG_OFFSET,\n\t.max_xfer_len = SZ_4K - 1,\n};\n\nstatic const struct of_device_id omap_mcspi_of_match[] = {\n\t{\n\t\t.compatible = \"ti,omap2-mcspi\",\n\t\t.data = &omap2_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4-mcspi\",\n\t\t.data = &omap4_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am654-mcspi\",\n\t\t.data = &am654_pdata,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap_mcspi_of_match);\n\nstatic int omap2_mcspi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller\t*ctlr;\n\tconst struct omap2_mcspi_platform_config *pdata;\n\tstruct omap2_mcspi\t*mcspi;\n\tstruct resource\t\t*r;\n\tint\t\t\tstatus = 0, i;\n\tu32\t\t\tregs_offset = 0;\n\tstruct device_node\t*node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\n\tif (of_property_read_bool(node, \"spi-slave\"))\n\t\tctlr = spi_alloc_target(&pdev->dev, sizeof(*mcspi));\n\telse\n\t\tctlr = spi_alloc_host(&pdev->dev, sizeof(*mcspi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\t \n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tctlr->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\tctlr->setup = omap2_mcspi_setup;\n\tctlr->auto_runtime_pm = true;\n\tctlr->prepare_message = omap2_mcspi_prepare_message;\n\tctlr->can_dma = omap2_mcspi_can_dma;\n\tctlr->transfer_one = omap2_mcspi_transfer_one;\n\tctlr->set_cs = omap2_mcspi_set_cs;\n\tctlr->cleanup = omap2_mcspi_cleanup;\n\tctlr->target_abort = omap2_mcspi_target_abort;\n\tctlr->dev.of_node = node;\n\tctlr->use_gpio_descriptors = true;\n\n\tplatform_set_drvdata(pdev, ctlr);\n\n\tmcspi = spi_controller_get_devdata(ctlr);\n\tmcspi->ctlr = ctlr;\n\n\tmatch = of_match_device(omap_mcspi_of_match, &pdev->dev);\n\tif (match) {\n\t\tu32 num_cs = 1;  \n\t\tpdata = match->data;\n\n\t\tof_property_read_u32(node, \"ti,spi-num-cs\", &num_cs);\n\t\tctlr->num_chipselect = num_cs;\n\t\tif (of_property_read_bool(node, \"ti,pindir-d0-out-d1-in\"))\n\t\t\tmcspi->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;\n\t} else {\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tctlr->num_chipselect = pdata->num_cs;\n\t\tmcspi->pin_dir = pdata->pin_dir;\n\t}\n\tregs_offset = pdata->regs_offset;\n\tif (pdata->max_xfer_len) {\n\t\tmcspi->max_xfer_len = pdata->max_xfer_len;\n\t\tctlr->max_transfer_size = omap2_mcspi_max_xfer_size;\n\t}\n\n\tmcspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(mcspi->base)) {\n\t\tstatus = PTR_ERR(mcspi->base);\n\t\tgoto free_ctlr;\n\t}\n\tmcspi->phys = r->start + regs_offset;\n\tmcspi->base += regs_offset;\n\n\tmcspi->dev = &pdev->dev;\n\n\tINIT_LIST_HEAD(&mcspi->ctx.cs);\n\n\tmcspi->dma_channels = devm_kcalloc(&pdev->dev, ctlr->num_chipselect,\n\t\t\t\t\t   sizeof(struct omap2_mcspi_dma),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (mcspi->dma_channels == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free_ctlr;\n\t}\n\n\tfor (i = 0; i < ctlr->num_chipselect; i++) {\n\t\tsprintf(mcspi->dma_channels[i].dma_rx_ch_name, \"rx%d\", i);\n\t\tsprintf(mcspi->dma_channels[i].dma_tx_ch_name, \"tx%d\", i);\n\n\t\tstatus = omap2_mcspi_request_dma(mcspi,\n\t\t\t\t\t\t &mcspi->dma_channels[i]);\n\t\tif (status == -EPROBE_DEFER)\n\t\t\tgoto free_ctlr;\n\t}\n\n\tstatus = platform_get_irq(pdev, 0);\n\tif (status < 0)\n\t\tgoto free_ctlr;\n\tinit_completion(&mcspi->txdone);\n\tstatus = devm_request_irq(&pdev->dev, status,\n\t\t\t\t  omap2_mcspi_irq_handler, 0, pdev->name,\n\t\t\t\t  mcspi);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Cannot request IRQ\");\n\t\tgoto free_ctlr;\n\t}\n\n\tmcspi->ref_clk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (mcspi->ref_clk)\n\t\tmcspi->ref_clk_hz = clk_get_rate(mcspi->ref_clk);\n\telse\n\t\tmcspi->ref_clk_hz = OMAP2_MCSPI_MAX_FREQ;\n\tctlr->max_speed_hz = mcspi->ref_clk_hz;\n\tctlr->min_speed_hz = mcspi->ref_clk_hz >> 15;\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_enable(&pdev->dev);\n\n\tstatus = omap2_mcspi_controller_setup(mcspi);\n\tif (status < 0)\n\t\tgoto disable_pm;\n\n\tstatus = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (status < 0)\n\t\tgoto disable_pm;\n\n\treturn status;\n\ndisable_pm:\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\nfree_ctlr:\n\tomap2_mcspi_release_dma(ctlr);\n\tspi_controller_put(ctlr);\n\treturn status;\n}\n\nstatic void omap2_mcspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr = platform_get_drvdata(pdev);\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\n\tomap2_mcspi_release_dma(ctlr);\n\n\tpm_runtime_dont_use_autosuspend(mcspi->dev);\n\tpm_runtime_put_sync(mcspi->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n \nMODULE_ALIAS(\"platform:omap2_mcspi\");\n\nstatic int __maybe_unused omap2_mcspi_suspend(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\tint error;\n\n\terror = pinctrl_pm_select_sleep_state(dev);\n\tif (error)\n\t\tdev_warn(mcspi->dev, \"%s: failed to set pins: %i\\n\",\n\t\t\t __func__, error);\n\n\terror = spi_controller_suspend(ctlr);\n\tif (error)\n\t\tdev_warn(mcspi->dev, \"%s: controller suspend failed: %i\\n\",\n\t\t\t __func__, error);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused omap2_mcspi_resume(struct device *dev)\n{\n\tstruct spi_controller *ctlr = dev_get_drvdata(dev);\n\tstruct omap2_mcspi *mcspi = spi_controller_get_devdata(ctlr);\n\tint error;\n\n\terror = spi_controller_resume(ctlr);\n\tif (error)\n\t\tdev_warn(mcspi->dev, \"%s: controller resume failed: %i\\n\",\n\t\t\t __func__, error);\n\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic const struct dev_pm_ops omap2_mcspi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(omap2_mcspi_suspend,\n\t\t\t\tomap2_mcspi_resume)\n\t.runtime_suspend\t= omap_mcspi_runtime_suspend,\n\t.runtime_resume\t\t= omap_mcspi_runtime_resume,\n};\n\nstatic struct platform_driver omap2_mcspi_driver = {\n\t.driver = {\n\t\t.name =\t\t\"omap2_mcspi\",\n\t\t.pm =\t\t&omap2_mcspi_pm_ops,\n\t\t.of_match_table = omap_mcspi_of_match,\n\t},\n\t.probe =\tomap2_mcspi_probe,\n\t.remove_new =\tomap2_mcspi_remove,\n};\n\nmodule_platform_driver(omap2_mcspi_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}