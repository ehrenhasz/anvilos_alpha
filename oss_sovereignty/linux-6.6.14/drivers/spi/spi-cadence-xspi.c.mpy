{
  "module_name": "spi-cadence-xspi.c",
  "hash_id": "8aee2d11957db05c9fba01f8dfb0afc550cae1001c2e366072940a4cc87bfadf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-cadence-xspi.c",
  "human_readable_source": "\n\n\n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n#include <linux/bitfield.h>\n#include <linux/limits.h>\n#include <linux/log2.h>\n\n#define CDNS_XSPI_MAGIC_NUM_VALUE\t0x6522\n#define CDNS_XSPI_MAX_BANKS\t\t8\n#define CDNS_XSPI_NAME\t\t\t\"cadence-xspi\"\n\n \n\n \n#define CDNS_XSPI_CCP_PHY_DQ_TIMING\t\t0x0000\n\n \n#define CDNS_XSPI_CCP_PHY_DQS_TIMING\t\t0x0004\n\n \n#define CDNS_XSPI_CCP_PHY_GATE_LPBCK_CTRL\t0x0008\n\n \n#define CDNS_XSPI_CCP_PHY_DLL_SLAVE_CTRL\t0x0010\n\n \n#define CDNS_XSPI_DLL_PHY_CTRL\t\t\t0x1034\n\n \n#define CDNS_XSPI_CMD_REG_0\t\t\t0x0000\n#define CDNS_XSPI_CMD_REG_1\t\t\t0x0004\n#define CDNS_XSPI_CMD_REG_2\t\t\t0x0008\n#define CDNS_XSPI_CMD_REG_3\t\t\t0x000C\n#define CDNS_XSPI_CMD_REG_4\t\t\t0x0010\n#define CDNS_XSPI_CMD_REG_5\t\t\t0x0014\n\n \n#define CDNS_XSPI_CMD_STATUS_REG\t\t0x0044\n\n \n#define CDNS_XSPI_CTRL_STATUS_REG\t\t0x0100\n#define CDNS_XSPI_INIT_COMPLETED\t\tBIT(16)\n#define CDNS_XSPI_INIT_LEGACY\t\t\tBIT(9)\n#define CDNS_XSPI_INIT_FAIL\t\t\tBIT(8)\n#define CDNS_XSPI_CTRL_BUSY\t\t\tBIT(7)\n\n \n#define CDNS_XSPI_INTR_STATUS_REG\t\t0x0110\n#define CDNS_XSPI_STIG_DONE\t\t\tBIT(23)\n#define CDNS_XSPI_SDMA_ERROR\t\t\tBIT(22)\n#define CDNS_XSPI_SDMA_TRIGGER\t\t\tBIT(21)\n#define CDNS_XSPI_CMD_IGNRD_EN\t\t\tBIT(20)\n#define CDNS_XSPI_DDMA_TERR_EN\t\t\tBIT(18)\n#define CDNS_XSPI_CDMA_TREE_EN\t\t\tBIT(17)\n#define CDNS_XSPI_CTRL_IDLE_EN\t\t\tBIT(16)\n\n#define CDNS_XSPI_TRD_COMP_INTR_STATUS\t\t0x0120\n#define CDNS_XSPI_TRD_ERR_INTR_STATUS\t\t0x0130\n#define CDNS_XSPI_TRD_ERR_INTR_EN\t\t0x0134\n\n \n#define CDNS_XSPI_INTR_ENABLE_REG\t\t0x0114\n#define CDNS_XSPI_INTR_EN\t\t\tBIT(31)\n#define CDNS_XSPI_STIG_DONE_EN\t\t\tBIT(23)\n#define CDNS_XSPI_SDMA_ERROR_EN\t\t\tBIT(22)\n#define CDNS_XSPI_SDMA_TRIGGER_EN\t\tBIT(21)\n\n#define CDNS_XSPI_INTR_MASK (CDNS_XSPI_INTR_EN | \\\n\tCDNS_XSPI_STIG_DONE_EN  | \\\n\tCDNS_XSPI_SDMA_ERROR_EN | \\\n\tCDNS_XSPI_SDMA_TRIGGER_EN)\n\n \n#define CDNS_XSPI_CTRL_CONFIG_REG\t\t0x0230\n#define CDNS_XSPI_CTRL_WORK_MODE\t\tGENMASK(6, 5)\n\n#define CDNS_XSPI_WORK_MODE_DIRECT\t\t0\n#define CDNS_XSPI_WORK_MODE_STIG\t\t1\n#define CDNS_XSPI_WORK_MODE_ACMD\t\t3\n\n \n#define CDNS_XSPI_SDMA_SIZE_REG\t\t\t0x0240\n#define CDNS_XSPI_SDMA_TRD_INFO_REG\t\t0x0244\n#define CDNS_XSPI_SDMA_DIR\t\t\tBIT(8)\n\n \n#define CDNS_XSPI_CTRL_FEATURES_REG\t\t0x0F04\n#define CDNS_XSPI_NUM_BANKS\t\t\tGENMASK(25, 24)\n#define CDNS_XSPI_DMA_DATA_WIDTH\t\tBIT(21)\n#define CDNS_XSPI_NUM_THREADS\t\t\tGENMASK(3, 0)\n\n \n#define CDNS_XSPI_CTRL_VERSION_REG\t\t0x0F00\n#define CDNS_XSPI_MAGIC_NUM\t\t\tGENMASK(31, 16)\n#define CDNS_XSPI_CTRL_REV\t\t\tGENMASK(7, 0)\n\n \n#define CDNS_XSPI_CMD_INSTR_TYPE\t\tGENMASK(6, 0)\n#define CDNS_XSPI_CMD_P1_R1_ADDR0\t\tGENMASK(31, 24)\n#define CDNS_XSPI_CMD_P1_R2_ADDR1\t\tGENMASK(7, 0)\n#define CDNS_XSPI_CMD_P1_R2_ADDR2\t\tGENMASK(15, 8)\n#define CDNS_XSPI_CMD_P1_R2_ADDR3\t\tGENMASK(23, 16)\n#define CDNS_XSPI_CMD_P1_R2_ADDR4\t\tGENMASK(31, 24)\n#define CDNS_XSPI_CMD_P1_R3_ADDR5\t\tGENMASK(7, 0)\n#define CDNS_XSPI_CMD_P1_R3_CMD\t\t\tGENMASK(23, 16)\n#define CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES\tGENMASK(30, 28)\n#define CDNS_XSPI_CMD_P1_R4_ADDR_IOS\t\tGENMASK(1, 0)\n#define CDNS_XSPI_CMD_P1_R4_CMD_IOS\t\tGENMASK(9, 8)\n#define CDNS_XSPI_CMD_P1_R4_BANK\t\tGENMASK(14, 12)\n\n \n#define CDNS_XSPI_CMD_DSEQ_R2_DCNT_L\t\tGENMASK(31, 16)\n#define CDNS_XSPI_CMD_DSEQ_R3_DCNT_H\t\tGENMASK(15, 0)\n#define CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY\tGENMASK(25, 20)\n#define CDNS_XSPI_CMD_DSEQ_R4_BANK\t\tGENMASK(14, 12)\n#define CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS\t\tGENMASK(9, 8)\n#define CDNS_XSPI_CMD_DSEQ_R4_DIR\t\tBIT(4)\n\n \n#define CDNS_XSPI_CMD_STATUS_COMPLETED\t\tBIT(15)\n#define CDNS_XSPI_CMD_STATUS_FAILED\t\tBIT(14)\n#define CDNS_XSPI_CMD_STATUS_DQS_ERROR\t\tBIT(3)\n#define CDNS_XSPI_CMD_STATUS_CRC_ERROR\t\tBIT(2)\n#define CDNS_XSPI_CMD_STATUS_BUS_ERROR\t\tBIT(1)\n#define CDNS_XSPI_CMD_STATUS_INV_SEQ_ERROR\tBIT(0)\n\n#define CDNS_XSPI_STIG_DONE_FLAG\t\tBIT(0)\n#define CDNS_XSPI_TRD_STATUS\t\t\t0x0104\n\n \n#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_1(op, data_phase) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, (data_phase) ? \\\n\t\tCDNS_XSPI_STIG_INSTR_TYPE_1 : CDNS_XSPI_STIG_INSTR_TYPE_0) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R1_ADDR0, (op)->addr.val & 0xff))\n\n#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_2(op) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR1, ((op)->addr.val >> 8)  & 0xFF) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR2, ((op)->addr.val >> 16) & 0xFF) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR3, ((op)->addr.val >> 24) & 0xFF) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R2_ADDR4, ((op)->addr.val >> 32) & 0xFF))\n\n#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_3(op) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R3_ADDR5, ((op)->addr.val >> 40) & 0xFF) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R3_CMD, (op)->cmd.opcode) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R3_NUM_ADDR_BYTES, (op)->addr.nbytes))\n\n#define CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_4(op, chipsel) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R4_ADDR_IOS, ilog2((op)->addr.buswidth)) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R4_CMD_IOS, ilog2((op)->cmd.buswidth)) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_P1_R4_BANK, chipsel))\n\n#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_1(op) \\\n\tFIELD_PREP(CDNS_XSPI_CMD_INSTR_TYPE, CDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ)\n\n#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_2(op) \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R2_DCNT_L, (op)->data.nbytes & 0xFFFF)\n\n#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_3(op) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_DCNT_H, \\\n\t\t((op)->data.nbytes >> 16) & 0xffff) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R3_NUM_OF_DUMMY, \\\n\t\t  (op)->dummy.buswidth != 0 ? \\\n\t\t  (((op)->dummy.nbytes * 8) / (op)->dummy.buswidth) : \\\n\t\t  0))\n\n#define CDNS_XSPI_CMD_FLD_DSEQ_CMD_4(op, chipsel) ( \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_BANK, chipsel) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DATA_IOS, \\\n\t\tilog2((op)->data.buswidth)) | \\\n\tFIELD_PREP(CDNS_XSPI_CMD_DSEQ_R4_DIR, \\\n\t\t((op)->data.dir == SPI_MEM_DATA_IN) ? \\\n\t\tCDNS_XSPI_STIG_CMD_DIR_READ : CDNS_XSPI_STIG_CMD_DIR_WRITE))\n\nenum cdns_xspi_stig_instr_type {\n\tCDNS_XSPI_STIG_INSTR_TYPE_0,\n\tCDNS_XSPI_STIG_INSTR_TYPE_1,\n\tCDNS_XSPI_STIG_INSTR_TYPE_DATA_SEQ = 127,\n};\n\nenum cdns_xspi_sdma_dir {\n\tCDNS_XSPI_SDMA_DIR_READ,\n\tCDNS_XSPI_SDMA_DIR_WRITE,\n};\n\nenum cdns_xspi_stig_cmd_dir {\n\tCDNS_XSPI_STIG_CMD_DIR_READ,\n\tCDNS_XSPI_STIG_CMD_DIR_WRITE,\n};\n\nstruct cdns_xspi_dev {\n\tstruct platform_device *pdev;\n\tstruct device *dev;\n\n\tvoid __iomem *iobase;\n\tvoid __iomem *auxbase;\n\tvoid __iomem *sdmabase;\n\n\tint irq;\n\tint cur_cs;\n\tunsigned int sdmasize;\n\n\tstruct completion cmd_complete;\n\tstruct completion auto_cmd_complete;\n\tstruct completion sdma_complete;\n\tbool sdma_error;\n\n\tvoid *in_buffer;\n\tconst void *out_buffer;\n\n\tu8 hw_num_banks;\n};\n\nstatic int cdns_xspi_wait_for_controller_idle(struct cdns_xspi_dev *cdns_xspi)\n{\n\tu32 ctrl_stat;\n\n\treturn readl_relaxed_poll_timeout(cdns_xspi->iobase +\n\t\t\t\t\t  CDNS_XSPI_CTRL_STATUS_REG,\n\t\t\t\t\t  ctrl_stat,\n\t\t\t\t\t  ((ctrl_stat &\n\t\t\t\t\t    CDNS_XSPI_CTRL_BUSY) == 0),\n\t\t\t\t\t  100, 1000);\n}\n\nstatic void cdns_xspi_trigger_command(struct cdns_xspi_dev *cdns_xspi,\n\t\t\t\t      u32 cmd_regs[6])\n{\n\twritel(cmd_regs[5], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_5);\n\twritel(cmd_regs[4], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_4);\n\twritel(cmd_regs[3], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_3);\n\twritel(cmd_regs[2], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_2);\n\twritel(cmd_regs[1], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_1);\n\twritel(cmd_regs[0], cdns_xspi->iobase + CDNS_XSPI_CMD_REG_0);\n}\n\nstatic int cdns_xspi_check_command_status(struct cdns_xspi_dev *cdns_xspi)\n{\n\tint ret = 0;\n\tu32 cmd_status = readl(cdns_xspi->iobase + CDNS_XSPI_CMD_STATUS_REG);\n\n\tif (cmd_status & CDNS_XSPI_CMD_STATUS_COMPLETED) {\n\t\tif ((cmd_status & CDNS_XSPI_CMD_STATUS_FAILED) != 0) {\n\t\t\tif (cmd_status & CDNS_XSPI_CMD_STATUS_DQS_ERROR) {\n\t\t\t\tdev_err(cdns_xspi->dev,\n\t\t\t\t\t\"Incorrect DQS pulses detected\\n\");\n\t\t\t\tret = -EPROTO;\n\t\t\t}\n\t\t\tif (cmd_status & CDNS_XSPI_CMD_STATUS_CRC_ERROR) {\n\t\t\t\tdev_err(cdns_xspi->dev,\n\t\t\t\t\t\"CRC error received\\n\");\n\t\t\t\tret = -EPROTO;\n\t\t\t}\n\t\t\tif (cmd_status & CDNS_XSPI_CMD_STATUS_BUS_ERROR) {\n\t\t\t\tdev_err(cdns_xspi->dev,\n\t\t\t\t\t\"Error resp on system DMA interface\\n\");\n\t\t\t\tret = -EPROTO;\n\t\t\t}\n\t\t\tif (cmd_status & CDNS_XSPI_CMD_STATUS_INV_SEQ_ERROR) {\n\t\t\t\tdev_err(cdns_xspi->dev,\n\t\t\t\t\t\"Invalid command sequence detected\\n\");\n\t\t\t\tret = -EPROTO;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(cdns_xspi->dev, \"Fatal err - command not completed\\n\");\n\t\tret = -EPROTO;\n\t}\n\n\treturn ret;\n}\n\nstatic void cdns_xspi_set_interrupts(struct cdns_xspi_dev *cdns_xspi,\n\t\t\t\t     bool enabled)\n{\n\tu32 intr_enable;\n\n\tintr_enable = readl(cdns_xspi->iobase + CDNS_XSPI_INTR_ENABLE_REG);\n\tif (enabled)\n\t\tintr_enable |= CDNS_XSPI_INTR_MASK;\n\telse\n\t\tintr_enable &= ~CDNS_XSPI_INTR_MASK;\n\twritel(intr_enable, cdns_xspi->iobase + CDNS_XSPI_INTR_ENABLE_REG);\n}\n\nstatic int cdns_xspi_controller_init(struct cdns_xspi_dev *cdns_xspi)\n{\n\tu32 ctrl_ver;\n\tu32 ctrl_features;\n\tu16 hw_magic_num;\n\n\tctrl_ver = readl(cdns_xspi->iobase + CDNS_XSPI_CTRL_VERSION_REG);\n\thw_magic_num = FIELD_GET(CDNS_XSPI_MAGIC_NUM, ctrl_ver);\n\tif (hw_magic_num != CDNS_XSPI_MAGIC_NUM_VALUE) {\n\t\tdev_err(cdns_xspi->dev,\n\t\t\t\"Incorrect XSPI magic number: %x, expected: %x\\n\",\n\t\t\thw_magic_num, CDNS_XSPI_MAGIC_NUM_VALUE);\n\t\treturn -EIO;\n\t}\n\n\tctrl_features = readl(cdns_xspi->iobase + CDNS_XSPI_CTRL_FEATURES_REG);\n\tcdns_xspi->hw_num_banks = FIELD_GET(CDNS_XSPI_NUM_BANKS, ctrl_features);\n\tcdns_xspi_set_interrupts(cdns_xspi, false);\n\n\treturn 0;\n}\n\nstatic void cdns_xspi_sdma_handle(struct cdns_xspi_dev *cdns_xspi)\n{\n\tu32 sdma_size, sdma_trd_info;\n\tu8 sdma_dir;\n\n\tsdma_size = readl(cdns_xspi->iobase + CDNS_XSPI_SDMA_SIZE_REG);\n\tsdma_trd_info = readl(cdns_xspi->iobase + CDNS_XSPI_SDMA_TRD_INFO_REG);\n\tsdma_dir = FIELD_GET(CDNS_XSPI_SDMA_DIR, sdma_trd_info);\n\n\tswitch (sdma_dir) {\n\tcase CDNS_XSPI_SDMA_DIR_READ:\n\t\tioread8_rep(cdns_xspi->sdmabase,\n\t\t\t    cdns_xspi->in_buffer, sdma_size);\n\t\tbreak;\n\n\tcase CDNS_XSPI_SDMA_DIR_WRITE:\n\t\tiowrite8_rep(cdns_xspi->sdmabase,\n\t\t\t     cdns_xspi->out_buffer, sdma_size);\n\t\tbreak;\n\t}\n}\n\nstatic int cdns_xspi_send_stig_command(struct cdns_xspi_dev *cdns_xspi,\n\t\t\t\t       const struct spi_mem_op *op,\n\t\t\t\t       bool data_phase)\n{\n\tu32 cmd_regs[6];\n\tu32 cmd_status;\n\tint ret;\n\n\tret = cdns_xspi_wait_for_controller_idle(cdns_xspi);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\twritel(FIELD_PREP(CDNS_XSPI_CTRL_WORK_MODE, CDNS_XSPI_WORK_MODE_STIG),\n\t       cdns_xspi->iobase + CDNS_XSPI_CTRL_CONFIG_REG);\n\n\tcdns_xspi_set_interrupts(cdns_xspi, true);\n\tcdns_xspi->sdma_error = false;\n\n\tmemset(cmd_regs, 0, sizeof(cmd_regs));\n\tcmd_regs[1] = CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_1(op, data_phase);\n\tcmd_regs[2] = CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_2(op);\n\tcmd_regs[3] = CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_3(op);\n\tcmd_regs[4] = CDNS_XSPI_CMD_FLD_P1_INSTR_CMD_4(op,\n\t\t\t\t\t\t       cdns_xspi->cur_cs);\n\n\tcdns_xspi_trigger_command(cdns_xspi, cmd_regs);\n\n\tif (data_phase) {\n\t\tcmd_regs[0] = CDNS_XSPI_STIG_DONE_FLAG;\n\t\tcmd_regs[1] = CDNS_XSPI_CMD_FLD_DSEQ_CMD_1(op);\n\t\tcmd_regs[2] = CDNS_XSPI_CMD_FLD_DSEQ_CMD_2(op);\n\t\tcmd_regs[3] = CDNS_XSPI_CMD_FLD_DSEQ_CMD_3(op);\n\t\tcmd_regs[4] = CDNS_XSPI_CMD_FLD_DSEQ_CMD_4(op,\n\t\t\t\t\t\t\t   cdns_xspi->cur_cs);\n\n\t\tcdns_xspi->in_buffer = op->data.buf.in;\n\t\tcdns_xspi->out_buffer = op->data.buf.out;\n\n\t\tcdns_xspi_trigger_command(cdns_xspi, cmd_regs);\n\n\t\twait_for_completion(&cdns_xspi->sdma_complete);\n\t\tif (cdns_xspi->sdma_error) {\n\t\t\tcdns_xspi_set_interrupts(cdns_xspi, false);\n\t\t\treturn -EIO;\n\t\t}\n\t\tcdns_xspi_sdma_handle(cdns_xspi);\n\t}\n\n\twait_for_completion(&cdns_xspi->cmd_complete);\n\tcdns_xspi_set_interrupts(cdns_xspi, false);\n\n\tcmd_status = cdns_xspi_check_command_status(cdns_xspi);\n\tif (cmd_status)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic int cdns_xspi_mem_op(struct cdns_xspi_dev *cdns_xspi,\n\t\t\t    struct spi_mem *mem,\n\t\t\t    const struct spi_mem_op *op)\n{\n\tenum spi_mem_data_dir dir = op->data.dir;\n\n\tif (cdns_xspi->cur_cs != spi_get_chipselect(mem->spi, 0))\n\t\tcdns_xspi->cur_cs = spi_get_chipselect(mem->spi, 0);\n\n\treturn cdns_xspi_send_stig_command(cdns_xspi, op,\n\t\t\t\t\t   (dir != SPI_MEM_NO_DATA));\n}\n\nstatic int cdns_xspi_mem_op_execute(struct spi_mem *mem,\n\t\t\t\t    const struct spi_mem_op *op)\n{\n\tstruct cdns_xspi_dev *cdns_xspi =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\tint ret = 0;\n\n\tret = cdns_xspi_mem_op(cdns_xspi, mem, op);\n\n\treturn ret;\n}\n\nstatic int cdns_xspi_adjust_mem_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct cdns_xspi_dev *cdns_xspi =\n\t\tspi_controller_get_devdata(mem->spi->controller);\n\n\top->data.nbytes = clamp_val(op->data.nbytes, 0, cdns_xspi->sdmasize);\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops cadence_xspi_mem_ops = {\n\t.exec_op = cdns_xspi_mem_op_execute,\n\t.adjust_op_size = cdns_xspi_adjust_mem_op_size,\n};\n\nstatic irqreturn_t cdns_xspi_irq_handler(int this_irq, void *dev)\n{\n\tstruct cdns_xspi_dev *cdns_xspi = dev;\n\tu32 irq_status;\n\tirqreturn_t result = IRQ_NONE;\n\n\tirq_status = readl(cdns_xspi->iobase + CDNS_XSPI_INTR_STATUS_REG);\n\twritel(irq_status, cdns_xspi->iobase + CDNS_XSPI_INTR_STATUS_REG);\n\n\tif (irq_status &\n\t    (CDNS_XSPI_SDMA_ERROR | CDNS_XSPI_SDMA_TRIGGER |\n\t     CDNS_XSPI_STIG_DONE)) {\n\t\tif (irq_status & CDNS_XSPI_SDMA_ERROR) {\n\t\t\tdev_err(cdns_xspi->dev,\n\t\t\t\t\"Slave DMA transaction error\\n\");\n\t\t\tcdns_xspi->sdma_error = true;\n\t\t\tcomplete(&cdns_xspi->sdma_complete);\n\t\t}\n\n\t\tif (irq_status & CDNS_XSPI_SDMA_TRIGGER)\n\t\t\tcomplete(&cdns_xspi->sdma_complete);\n\n\t\tif (irq_status & CDNS_XSPI_STIG_DONE)\n\t\t\tcomplete(&cdns_xspi->cmd_complete);\n\n\t\tresult = IRQ_HANDLED;\n\t}\n\n\tirq_status = readl(cdns_xspi->iobase + CDNS_XSPI_TRD_COMP_INTR_STATUS);\n\tif (irq_status) {\n\t\twritel(irq_status,\n\t\t       cdns_xspi->iobase + CDNS_XSPI_TRD_COMP_INTR_STATUS);\n\n\t\tcomplete(&cdns_xspi->auto_cmd_complete);\n\n\t\tresult = IRQ_HANDLED;\n\t}\n\n\treturn result;\n}\n\nstatic int cdns_xspi_of_get_plat_data(struct platform_device *pdev)\n{\n\tstruct device_node *node_prop = pdev->dev.of_node;\n\tstruct device_node *node_child;\n\tunsigned int cs;\n\n\tfor_each_child_of_node(node_prop, node_child) {\n\t\tif (!of_device_is_available(node_child))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(node_child, \"reg\", &cs)) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get memory chip select\\n\");\n\t\t\tof_node_put(node_child);\n\t\t\treturn -ENXIO;\n\t\t} else if (cs >= CDNS_XSPI_MAX_BANKS) {\n\t\t\tdev_err(&pdev->dev, \"reg (cs) parameter value too large\\n\");\n\t\t\tof_node_put(node_child);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cdns_xspi_print_phy_config(struct cdns_xspi_dev *cdns_xspi)\n{\n\tstruct device *dev = cdns_xspi->dev;\n\n\tdev_info(dev, \"PHY configuration\\n\");\n\tdev_info(dev, \"   * xspi_dll_phy_ctrl: %08x\\n\",\n\t\t readl(cdns_xspi->iobase + CDNS_XSPI_DLL_PHY_CTRL));\n\tdev_info(dev, \"   * phy_dq_timing: %08x\\n\",\n\t\t readl(cdns_xspi->auxbase + CDNS_XSPI_CCP_PHY_DQ_TIMING));\n\tdev_info(dev, \"   * phy_dqs_timing: %08x\\n\",\n\t\t readl(cdns_xspi->auxbase + CDNS_XSPI_CCP_PHY_DQS_TIMING));\n\tdev_info(dev, \"   * phy_gate_loopback_ctrl: %08x\\n\",\n\t\t readl(cdns_xspi->auxbase + CDNS_XSPI_CCP_PHY_GATE_LPBCK_CTRL));\n\tdev_info(dev, \"   * phy_dll_slave_ctrl: %08x\\n\",\n\t\t readl(cdns_xspi->auxbase + CDNS_XSPI_CCP_PHY_DLL_SLAVE_CTRL));\n}\n\nstatic int cdns_xspi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *host = NULL;\n\tstruct cdns_xspi_dev *cdns_xspi = NULL;\n\tstruct resource *res;\n\tint ret;\n\n\thost = devm_spi_alloc_host(dev, sizeof(*cdns_xspi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->mode_bits = SPI_3WIRE | SPI_TX_DUAL  | SPI_TX_QUAD  |\n\t\tSPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_OCTAL | SPI_RX_OCTAL |\n\t\tSPI_MODE_0  | SPI_MODE_3;\n\n\thost->mem_ops = &cadence_xspi_mem_ops;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = -1;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tcdns_xspi = spi_controller_get_devdata(host);\n\tcdns_xspi->pdev = pdev;\n\tcdns_xspi->dev = &pdev->dev;\n\tcdns_xspi->cur_cs = 0;\n\n\tinit_completion(&cdns_xspi->cmd_complete);\n\tinit_completion(&cdns_xspi->auto_cmd_complete);\n\tinit_completion(&cdns_xspi->sdma_complete);\n\n\tret = cdns_xspi_of_get_plat_data(pdev);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tcdns_xspi->iobase = devm_platform_ioremap_resource_byname(pdev, \"io\");\n\tif (IS_ERR(cdns_xspi->iobase)) {\n\t\tdev_err(dev, \"Failed to remap controller base address\\n\");\n\t\treturn PTR_ERR(cdns_xspi->iobase);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"sdma\");\n\tcdns_xspi->sdmabase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(cdns_xspi->sdmabase))\n\t\treturn PTR_ERR(cdns_xspi->sdmabase);\n\tcdns_xspi->sdmasize = resource_size(res);\n\n\tcdns_xspi->auxbase = devm_platform_ioremap_resource_byname(pdev, \"aux\");\n\tif (IS_ERR(cdns_xspi->auxbase)) {\n\t\tdev_err(dev, \"Failed to remap AUX address\\n\");\n\t\treturn PTR_ERR(cdns_xspi->auxbase);\n\t}\n\n\tcdns_xspi->irq = platform_get_irq(pdev, 0);\n\tif (cdns_xspi->irq < 0)\n\t\treturn -ENXIO;\n\n\tret = devm_request_irq(dev, cdns_xspi->irq, cdns_xspi_irq_handler,\n\t\t\t       IRQF_SHARED, pdev->name, cdns_xspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", cdns_xspi->irq);\n\t\treturn ret;\n\t}\n\n\tcdns_xspi_print_phy_config(cdns_xspi);\n\n\tret = cdns_xspi_controller_init(cdns_xspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize controller\\n\");\n\t\treturn ret;\n\t}\n\n\thost->num_chipselect = 1 << cdns_xspi->hw_num_banks;\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register SPI host\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"Successfully registered SPI host\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cdns_xspi_of_match[] = {\n\t{\n\t\t.compatible = \"cdns,xspi-nor\",\n\t},\n\t{  }\n};\nMODULE_DEVICE_TABLE(of, cdns_xspi_of_match);\n\nstatic struct platform_driver cdns_xspi_platform_driver = {\n\t.probe          = cdns_xspi_probe,\n\t.remove         = NULL,\n\t.driver = {\n\t\t.name = CDNS_XSPI_NAME,\n\t\t.of_match_table = cdns_xspi_of_match,\n\t},\n};\n\nmodule_platform_driver(cdns_xspi_platform_driver);\n\nMODULE_DESCRIPTION(\"Cadence XSPI Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" CDNS_XSPI_NAME);\nMODULE_AUTHOR(\"Konrad Kociolek <konrad@cadence.com>\");\nMODULE_AUTHOR(\"Jayshri Pawar <jpawar@cadence.com>\");\nMODULE_AUTHOR(\"Parshuram Thombare <pthombar@cadence.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}