{
  "module_name": "spi-falcon.c",
  "hash_id": "21b4b8f5441f0144112375da78ee764a1541455ace155d5ffeb43966af993926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-falcon.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\n#include <lantiq_soc.h>\n\n#define DRV_NAME\t\t\"sflash-falcon\"\n\n#define FALCON_SPI_XFER_BEGIN\t(1 << 0)\n#define FALCON_SPI_XFER_END\t(1 << 1)\n\n \n#define BUSRCON0\t\t0x00000010\n \n#define BUSWCON0\t\t0x00000018\n \n#define SFCON\t\t\t0x00000080\n \n#define SFTIME\t\t\t0x00000084\n \n#define SFSTAT\t\t\t0x00000088\n \n#define SFCMD\t\t\t0x0000008C\n \n#define SFADDR\t\t\t0x00000090\n \n#define SFDATA\t\t\t0x00000094\n \n#define SFIO\t\t\t0x00000098\n \n#define EBUCC\t\t\t0x000000C4\n\n \n#define SFCMD_DUMLEN_OFFSET\t16\n#define SFCMD_DUMLEN_MASK\t0x000F0000\n \n#define SFCMD_CS_OFFSET\t\t24\n#define SFCMD_CS_MASK\t\t0x07000000\n \n#define SFCMD_ALEN_OFFSET\t20\n#define SFCMD_ALEN_MASK\t\t0x00700000\n \n#define SFTIME_SCKR_POS_OFFSET\t8\n#define SFTIME_SCKR_POS_MASK\t0x00000F00\n \n#define SFTIME_SCK_PER_OFFSET\t0\n#define SFTIME_SCK_PER_MASK\t0x0000000F\n \n#define SFTIME_SCKF_POS_OFFSET\t12\n#define SFTIME_SCKF_POS_MASK\t0x0000F000\n \n#define SFCON_DEV_SIZE_A23_0\t0x03000000\n#define SFCON_DEV_SIZE_MASK\t0x0F000000\n \n#define SFTIME_RD_POS_MASK\t0x000F0000\n \n#define SFIO_UNUSED_WD_MASK\t0x0000000F\n \n#define SFCMD_OPC_MASK\t\t0x000000FF\n \n#define SFCMD_DIR_WRITE\t\t0x00000100\n \n#define SFCMD_DLEN_OFFSET\t9\n \n#define SFSTAT_CMD_ERR\t\t0x20000000\n \n#define SFSTAT_CMD_PEND\t\t0x00400000\n \n#define EBUCC_EBUDIV_SELF100\t0x00000001\n \n#define BUSRCON0_AGEN_SERIAL_FLASH\t0xF0000000\n \n#define BUSRCON0_PORTW_8_BIT_MUX\t0x00000000\n \n#define BUSWCON0_AGEN_SERIAL_FLASH\t0xF0000000\n \n#define SFCMD_KEEP_CS_KEEP_SELECTED\t0x00008000\n\n#define CLOCK_100M\t100000000\n#define CLOCK_50M\t50000000\n\nstruct falcon_sflash {\n\tu32 sfcmd;  \n\tstruct spi_controller *host;\n};\n\nint falcon_sflash_xfer(struct spi_device *spi, struct spi_transfer *t,\n\t\tunsigned long flags)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct falcon_sflash *priv = spi_controller_get_devdata(spi->controller);\n\tconst u8 *txp = t->tx_buf;\n\tu8 *rxp = t->rx_buf;\n\tunsigned int bytelen = ((8 * t->len + 7) / 8);\n\tunsigned int len, alen, dumlen;\n\tu32 val;\n\tenum {\n\t\tstate_init,\n\t\tstate_command_prepare,\n\t\tstate_write,\n\t\tstate_read,\n\t\tstate_disable_cs,\n\t\tstate_end\n\t} state = state_init;\n\n\tdo {\n\t\tswitch (state) {\n\t\tcase state_init:  \n\t\t{\n\t\t\t \n\t\t\tif (flags & FALCON_SPI_XFER_BEGIN) {\n\t\t\t\tif (!txp) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"BEGIN without tx data!\\n\");\n\t\t\t\t\treturn -ENODATA;\n\t\t\t\t}\n\t\t\t\t \n\n\t\t\t\tpriv->sfcmd = ((spi_get_chipselect(spi, 0)\n\t\t\t\t\t\t<< SFCMD_CS_OFFSET)\n\t\t\t\t\t       & SFCMD_CS_MASK);\n\t\t\t\tpriv->sfcmd |= SFCMD_KEEP_CS_KEEP_SELECTED;\n\t\t\t\tpriv->sfcmd |= *txp;\n\t\t\t\ttxp++;\n\t\t\t\tbytelen--;\n\t\t\t\tif (bytelen) {\n\t\t\t\t\t \n\t\t\t\t\tstate = state_command_prepare;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdev_dbg(dev, \"write cmd %02X\\n\",\n\t\t\t\t\t\tpriv->sfcmd & SFCMD_OPC_MASK);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (txp && bytelen) {\n\t\t\t\tstate = state_write;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (rxp && bytelen) {\n\t\t\t\tstate = state_read;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (flags & FALCON_SPI_XFER_END)\n\t\t\t\tstate = state_disable_cs;\n\t\t\telse\n\t\t\t\tstate = state_end;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tcase state_command_prepare:\n\t\t{\n\t\t\t \n\t\t\tval = 0;\n\t\t\talen = 0;\n\t\t\tdumlen = 0;\n\t\t\twhile (bytelen > 0) {\n\t\t\t\tif (alen < 3) {\n\t\t\t\t\tval = (val << 8) | (*txp++);\n\t\t\t\t\talen++;\n\t\t\t\t} else if ((dumlen < 15) && (*txp == 0)) {\n\t\t\t\t\t \n\t\t\t\t\tdumlen++;\n\t\t\t\t\ttxp++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbytelen--;\n\t\t\t}\n\t\t\tpriv->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);\n\t\t\tpriv->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |\n\t\t\t\t\t (dumlen << SFCMD_DUMLEN_OFFSET);\n\t\t\tif (alen > 0)\n\t\t\t\tltq_ebu_w32(val, SFADDR);\n\n\t\t\tdev_dbg(dev, \"wr %02X, alen=%d (addr=%06X) dlen=%d\\n\",\n\t\t\t\tpriv->sfcmd & SFCMD_OPC_MASK,\n\t\t\t\talen, val, dumlen);\n\n\t\t\tif (bytelen > 0) {\n\t\t\t\t \n\t\t\t\tstate = state_write;\n\t\t\t} else if (flags & FALCON_SPI_XFER_END) {\n\t\t\t\t \n\t\t\t\tstate = state_disable_cs;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstate = state_end;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase state_write:\n\t\t{\n\t\t\t \n\t\t\tpriv->sfcmd |= SFCMD_DIR_WRITE;\n\t\t\tlen = 0;\n\t\t\tval = 0;\n\t\t\tdo {\n\t\t\t\tif (bytelen--)\n\t\t\t\t\tval |= (*txp++) << (8 * len++);\n\t\t\t\tif ((flags & FALCON_SPI_XFER_END)\n\t\t\t\t    && (bytelen == 0)) {\n\t\t\t\t\tpriv->sfcmd &=\n\t\t\t\t\t\t~SFCMD_KEEP_CS_KEEP_SELECTED;\n\t\t\t\t}\n\t\t\t\tif ((len == 4) || (bytelen == 0)) {\n\t\t\t\t\tltq_ebu_w32(val, SFDATA);\n\t\t\t\t\tltq_ebu_w32(priv->sfcmd\n\t\t\t\t\t\t| (len<<SFCMD_DLEN_OFFSET),\n\t\t\t\t\t\tSFCMD);\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tval = 0;\n\t\t\t\t\tpriv->sfcmd &= ~(SFCMD_ALEN_MASK\n\t\t\t\t\t\t\t | SFCMD_DUMLEN_MASK);\n\t\t\t\t}\n\t\t\t} while (bytelen);\n\t\t\tstate = state_end;\n\t\t\tbreak;\n\t\t}\n\t\tcase state_read:\n\t\t{\n\t\t\t \n\t\t\tpriv->sfcmd &= ~SFCMD_DIR_WRITE;\n\t\t\tdo {\n\t\t\t\tif ((flags & FALCON_SPI_XFER_END)\n\t\t\t\t    && (bytelen <= 4)) {\n\t\t\t\t\tpriv->sfcmd &=\n\t\t\t\t\t\t~SFCMD_KEEP_CS_KEEP_SELECTED;\n\t\t\t\t}\n\t\t\t\tlen = (bytelen > 4) ? 4 : bytelen;\n\t\t\t\tbytelen -= len;\n\t\t\t\tltq_ebu_w32(priv->sfcmd\n\t\t\t\t\t| (len << SFCMD_DLEN_OFFSET), SFCMD);\n\t\t\t\tpriv->sfcmd &= ~(SFCMD_ALEN_MASK\n\t\t\t\t\t\t | SFCMD_DUMLEN_MASK);\n\t\t\t\tdo {\n\t\t\t\t\tval = ltq_ebu_r32(SFSTAT);\n\t\t\t\t\tif (val & SFSTAT_CMD_ERR) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdev_err(dev, \"SFSTAT: CMD_ERR\");\n\t\t\t\t\t\tdev_err(dev, \" (%x)\\n\", val);\n\t\t\t\t\t\tltq_ebu_w32(SFSTAT_CMD_ERR,\n\t\t\t\t\t\t\tSFSTAT);\n\t\t\t\t\t\treturn -EBADE;\n\t\t\t\t\t}\n\t\t\t\t} while (val & SFSTAT_CMD_PEND);\n\t\t\t\tval = ltq_ebu_r32(SFDATA);\n\t\t\t\tdo {\n\t\t\t\t\t*rxp = (val & 0xFF);\n\t\t\t\t\trxp++;\n\t\t\t\t\tval >>= 8;\n\t\t\t\t\tlen--;\n\t\t\t\t} while (len);\n\t\t\t} while (bytelen);\n\t\t\tstate = state_end;\n\t\t\tbreak;\n\t\t}\n\t\tcase state_disable_cs:\n\t\t{\n\t\t\tpriv->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;\n\t\t\tltq_ebu_w32(priv->sfcmd | (0 << SFCMD_DLEN_OFFSET),\n\t\t\t\tSFCMD);\n\t\t\tval = ltq_ebu_r32(SFSTAT);\n\t\t\tif (val & SFSTAT_CMD_ERR) {\n\t\t\t\t \n\t\t\t\tdev_err(dev, \"SFSTAT: CMD_ERR (%x)\\n\", val);\n\t\t\t\tltq_ebu_w32(SFSTAT_CMD_ERR, SFSTAT);\n\t\t\t\treturn -EBADE;\n\t\t\t}\n\t\t\tstate = state_end;\n\t\t\tbreak;\n\t\t}\n\t\tcase state_end:\n\t\t\tbreak;\n\t\t}\n\t} while (state != state_end);\n\n\treturn 0;\n}\n\nstatic int falcon_sflash_setup(struct spi_device *spi)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ebu_lock, flags);\n\n\tif (spi->max_speed_hz >= CLOCK_100M) {\n\t\t \n\t\tltq_sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, EBUCC);\n\t\ti = 1;  \n\t} else {\n\t\t \n\t\tltq_sys1_w32_mask(EBUCC_EBUDIV_SELF100, 0, EBUCC);\n\n\t\t \n\t\tfor (i = 1; i < 7; i++) {\n\t\t\tif (CLOCK_50M / i <= spi->max_speed_hz)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK\n\t\t     | SFTIME_SCKR_POS_MASK\n\t\t     | SFTIME_SCK_PER_MASK,\n\t\t     (i << SFTIME_SCKR_POS_OFFSET)\n\t\t     | (i << (SFTIME_SCK_PER_OFFSET + 1)),\n\t\t     SFTIME);\n\n\t \n\tltq_ebu_w32((SFIO_UNUSED_WD_MASK & (0x8 | 0x4)), SFIO);\n\n\tltq_ebu_w32(BUSRCON0_AGEN_SERIAL_FLASH | BUSRCON0_PORTW_8_BIT_MUX,\n\t\t\tBUSRCON0);\n\tltq_ebu_w32(BUSWCON0_AGEN_SERIAL_FLASH, BUSWCON0);\n\t \n\tltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);\n\n\tspin_unlock_irqrestore(&ebu_lock, flags);\n\n\treturn 0;\n}\n\nstatic int falcon_sflash_xfer_one(struct spi_controller *host,\n\t\t\t\t\tstruct spi_message *m)\n{\n\tstruct falcon_sflash *priv = spi_controller_get_devdata(host);\n\tstruct spi_transfer *t;\n\tunsigned long spi_flags;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tpriv->sfcmd = 0;\n\tm->actual_length = 0;\n\n\tspi_flags = FALCON_SPI_XFER_BEGIN;\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (list_is_last(&t->transfer_list, &m->transfers))\n\t\t\tspi_flags |= FALCON_SPI_XFER_END;\n\n\t\tspin_lock_irqsave(&ebu_lock, flags);\n\t\tret = falcon_sflash_xfer(m->spi, t, spi_flags);\n\t\tspin_unlock_irqrestore(&ebu_lock, flags);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tm->actual_length += t->len;\n\n\t\tWARN_ON(t->delay.value || t->cs_change);\n\t\tspi_flags = 0;\n\t}\n\n\tm->status = ret;\n\tspi_finalize_current_message(host);\n\n\treturn 0;\n}\n\nstatic int falcon_sflash_probe(struct platform_device *pdev)\n{\n\tstruct falcon_sflash *priv;\n\tstruct spi_controller *host;\n\tint ret;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*priv));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tpriv = spi_controller_get_devdata(host);\n\tpriv->host = host;\n\n\thost->mode_bits = SPI_MODE_3;\n\thost->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\thost->setup = falcon_sflash_setup;\n\thost->transfer_one_message = falcon_sflash_xfer_one;\n\thost->dev.of_node = pdev->dev.of_node;\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret)\n\t\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic const struct of_device_id falcon_sflash_match[] = {\n\t{ .compatible = \"lantiq,sflash-falcon\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, falcon_sflash_match);\n\nstatic struct platform_driver falcon_sflash_driver = {\n\t.probe\t= falcon_sflash_probe,\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = falcon_sflash_match,\n\t}\n};\n\nmodule_platform_driver(falcon_sflash_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Lantiq Falcon SPI/SFLASH controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}