{
  "module_name": "spi-au1550.c",
  "hash_id": "1b1e0f0f57e9ffcecf785e0e4fc754413c8059df64a450909483d018db5ddba8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-au1550.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/dma-mapping.h>\n#include <linux/completion.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_psc.h>\n#include <asm/mach-au1x00/au1xxx_dbdma.h>\n\n#include <asm/mach-au1x00/au1550_spi.h>\n\nstatic unsigned int usedma = 1;\nmodule_param(usedma, uint, 0644);\n\n \n\n\n#define AU1550_SPI_DBDMA_DESCRIPTORS 1\n#define AU1550_SPI_DMA_RXTMP_MINSIZE 2048U\n\nstruct au1550_spi {\n\tstruct spi_bitbang bitbang;\n\n\tvolatile psc_spi_t __iomem *regs;\n\tint irq;\n\n\tunsigned int len;\n\tunsigned int tx_count;\n\tunsigned int rx_count;\n\tconst u8 *tx;\n\tu8 *rx;\n\n\tvoid (*rx_word)(struct au1550_spi *hw);\n\tvoid (*tx_word)(struct au1550_spi *hw);\n\tint (*txrx_bufs)(struct spi_device *spi, struct spi_transfer *t);\n\tirqreturn_t (*irq_callback)(struct au1550_spi *hw);\n\n\tstruct completion host_done;\n\n\tunsigned int usedma;\n\tu32 dma_tx_id;\n\tu32 dma_rx_id;\n\tu32 dma_tx_ch;\n\tu32 dma_rx_ch;\n\n\tu8 *dma_rx_tmpbuf;\n\tunsigned int dma_rx_tmpbuf_size;\n\tu32 dma_rx_tmpbuf_addr;\n\n\tstruct spi_controller *host;\n\tstruct device *dev;\n\tstruct au1550_spi_info *pdata;\n\tstruct resource *ioarea;\n};\n\n\n \nstatic dbdev_tab_t au1550_spi_mem_dbdev = {\n\t.dev_id\t\t\t= DBDMA_MEM_CHAN,\n\t.dev_flags\t\t= DEV_FLAGS_ANYUSE|DEV_FLAGS_SYNC,\n\t.dev_tsize\t\t= 0,\n\t.dev_devwidth\t\t= 8,\n\t.dev_physaddr\t\t= 0x00000000,\n\t.dev_intlevel\t\t= 0,\n\t.dev_intpolarity\t= 0\n};\n\nstatic int ddma_memid;\t \n\nstatic void au1550_spi_bits_handlers_set(struct au1550_spi *hw, int bpw);\n\n\n \nstatic u32 au1550_spi_baudcfg(struct au1550_spi *hw, unsigned int speed_hz)\n{\n\tu32 mainclk_hz = hw->pdata->mainclk_hz;\n\tu32 div, brg;\n\n\tfor (div = 0; div < 4; div++) {\n\t\tbrg = mainclk_hz / speed_hz / (4 << div);\n\t\t \n\t\tif (brg < (4 + 1)) {\n\t\t\tbrg = (4 + 1);\t \n\t\t\tbreak;\t\t \n\t\t}\n\t\tif (brg <= (63 + 1))\n\t\t\tbreak;\t\t \n\t}\n\tif (div == 4) {\n\t\tdiv = 3;\t\t \n\t\tbrg = (63 + 1);\t\t \n\t}\n\tbrg--;\n\treturn PSC_SPICFG_SET_BAUD(brg) | PSC_SPICFG_SET_DIV(div);\n}\n\nstatic inline void au1550_spi_mask_ack_all(struct au1550_spi *hw)\n{\n\thw->regs->psc_spimsk =\n\t\t  PSC_SPIMSK_MM | PSC_SPIMSK_RR | PSC_SPIMSK_RO\n\t\t| PSC_SPIMSK_RU | PSC_SPIMSK_TR | PSC_SPIMSK_TO\n\t\t| PSC_SPIMSK_TU | PSC_SPIMSK_SD | PSC_SPIMSK_MD;\n\twmb();  \n\n\thw->regs->psc_spievent =\n\t\t  PSC_SPIEVNT_MM | PSC_SPIEVNT_RR | PSC_SPIEVNT_RO\n\t\t| PSC_SPIEVNT_RU | PSC_SPIEVNT_TR | PSC_SPIEVNT_TO\n\t\t| PSC_SPIEVNT_TU | PSC_SPIEVNT_SD | PSC_SPIEVNT_MD;\n\twmb();  \n}\n\nstatic void au1550_spi_reset_fifos(struct au1550_spi *hw)\n{\n\tu32 pcr;\n\n\thw->regs->psc_spipcr = PSC_SPIPCR_RC | PSC_SPIPCR_TC;\n\twmb();  \n\tdo {\n\t\tpcr = hw->regs->psc_spipcr;\n\t\twmb();  \n\t} while (pcr != 0);\n}\n\n \nstatic void au1550_spi_chipsel(struct spi_device *spi, int value)\n{\n\tstruct au1550_spi *hw = spi_controller_get_devdata(spi->controller);\n\tunsigned int cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;\n\tu32 cfg, stat;\n\n\tswitch (value) {\n\tcase BITBANG_CS_INACTIVE:\n\t\tif (hw->pdata->deactivate_cs)\n\t\t\thw->pdata->deactivate_cs(hw->pdata, spi_get_chipselect(spi, 0),\n\t\t\t\t\tcspol);\n\t\tbreak;\n\n\tcase BITBANG_CS_ACTIVE:\n\t\tau1550_spi_bits_handlers_set(hw, spi->bits_per_word);\n\n\t\tcfg = hw->regs->psc_spicfg;\n\t\twmb();  \n\t\thw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;\n\t\twmb();  \n\n\t\tif (spi->mode & SPI_CPOL)\n\t\t\tcfg |= PSC_SPICFG_BI;\n\t\telse\n\t\t\tcfg &= ~PSC_SPICFG_BI;\n\t\tif (spi->mode & SPI_CPHA)\n\t\t\tcfg &= ~PSC_SPICFG_CDE;\n\t\telse\n\t\t\tcfg |= PSC_SPICFG_CDE;\n\n\t\tif (spi->mode & SPI_LSB_FIRST)\n\t\t\tcfg |= PSC_SPICFG_MLF;\n\t\telse\n\t\t\tcfg &= ~PSC_SPICFG_MLF;\n\n\t\tif (hw->usedma && spi->bits_per_word <= 8)\n\t\t\tcfg &= ~PSC_SPICFG_DD_DISABLE;\n\t\telse\n\t\t\tcfg |= PSC_SPICFG_DD_DISABLE;\n\t\tcfg = PSC_SPICFG_CLR_LEN(cfg);\n\t\tcfg |= PSC_SPICFG_SET_LEN(spi->bits_per_word);\n\n\t\tcfg = PSC_SPICFG_CLR_BAUD(cfg);\n\t\tcfg &= ~PSC_SPICFG_SET_DIV(3);\n\t\tcfg |= au1550_spi_baudcfg(hw, spi->max_speed_hz);\n\n\t\thw->regs->psc_spicfg = cfg | PSC_SPICFG_DE_ENABLE;\n\t\twmb();  \n\t\tdo {\n\t\t\tstat = hw->regs->psc_spistat;\n\t\t\twmb();  \n\t\t} while ((stat & PSC_SPISTAT_DR) == 0);\n\n\t\tif (hw->pdata->activate_cs)\n\t\t\thw->pdata->activate_cs(hw->pdata, spi_get_chipselect(spi, 0),\n\t\t\t\t\tcspol);\n\t\tbreak;\n\t}\n}\n\nstatic int au1550_spi_setupxfer(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct au1550_spi *hw = spi_controller_get_devdata(spi->controller);\n\tunsigned int bpw, hz;\n\tu32 cfg, stat;\n\n\tif (t) {\n\t\tbpw = t->bits_per_word;\n\t\thz = t->speed_hz;\n\t} else {\n\t\tbpw = spi->bits_per_word;\n\t\thz = spi->max_speed_hz;\n\t}\n\n\tif (!hz)\n\t\treturn -EINVAL;\n\n\tau1550_spi_bits_handlers_set(hw, spi->bits_per_word);\n\n\tcfg = hw->regs->psc_spicfg;\n\twmb();  \n\thw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;\n\twmb();  \n\n\tif (hw->usedma && bpw <= 8)\n\t\tcfg &= ~PSC_SPICFG_DD_DISABLE;\n\telse\n\t\tcfg |= PSC_SPICFG_DD_DISABLE;\n\tcfg = PSC_SPICFG_CLR_LEN(cfg);\n\tcfg |= PSC_SPICFG_SET_LEN(bpw);\n\n\tcfg = PSC_SPICFG_CLR_BAUD(cfg);\n\tcfg &= ~PSC_SPICFG_SET_DIV(3);\n\tcfg |= au1550_spi_baudcfg(hw, hz);\n\n\thw->regs->psc_spicfg = cfg;\n\twmb();  \n\n\tif (cfg & PSC_SPICFG_DE_ENABLE) {\n\t\tdo {\n\t\t\tstat = hw->regs->psc_spistat;\n\t\t\twmb();  \n\t\t} while ((stat & PSC_SPISTAT_DR) == 0);\n\t}\n\n\tau1550_spi_reset_fifos(hw);\n\tau1550_spi_mask_ack_all(hw);\n\treturn 0;\n}\n\n \nstatic int au1550_spi_dma_rxtmp_alloc(struct au1550_spi *hw, unsigned int size)\n{\n\thw->dma_rx_tmpbuf = kmalloc(size, GFP_KERNEL);\n\tif (!hw->dma_rx_tmpbuf)\n\t\treturn -ENOMEM;\n\thw->dma_rx_tmpbuf_size = size;\n\thw->dma_rx_tmpbuf_addr = dma_map_single(hw->dev, hw->dma_rx_tmpbuf,\n\t\t\tsize, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(hw->dev, hw->dma_rx_tmpbuf_addr)) {\n\t\tkfree(hw->dma_rx_tmpbuf);\n\t\thw->dma_rx_tmpbuf = 0;\n\t\thw->dma_rx_tmpbuf_size = 0;\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic void au1550_spi_dma_rxtmp_free(struct au1550_spi *hw)\n{\n\tdma_unmap_single(hw->dev, hw->dma_rx_tmpbuf_addr,\n\t\t\thw->dma_rx_tmpbuf_size, DMA_FROM_DEVICE);\n\tkfree(hw->dma_rx_tmpbuf);\n\thw->dma_rx_tmpbuf = 0;\n\thw->dma_rx_tmpbuf_size = 0;\n}\n\nstatic int au1550_spi_dma_txrxb(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct au1550_spi *hw = spi_controller_get_devdata(spi->controller);\n\tdma_addr_t dma_tx_addr;\n\tdma_addr_t dma_rx_addr;\n\tu32 res;\n\n\thw->len = t->len;\n\thw->tx_count = 0;\n\thw->rx_count = 0;\n\n\thw->tx = t->tx_buf;\n\thw->rx = t->rx_buf;\n\tdma_tx_addr = t->tx_dma;\n\tdma_rx_addr = t->rx_dma;\n\n\t \n\tif (t->tx_buf) {\n\t\tif (t->tx_dma == 0) {\t \n\t\t\tdma_tx_addr = dma_map_single(hw->dev,\n\t\t\t\t\t(void *)t->tx_buf,\n\t\t\t\t\tt->len, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(hw->dev, dma_tx_addr))\n\t\t\t\tdev_err(hw->dev, \"tx dma map error\\n\");\n\t\t}\n\t}\n\n\tif (t->rx_buf) {\n\t\tif (t->rx_dma == 0) {\t \n\t\t\tdma_rx_addr = dma_map_single(hw->dev,\n\t\t\t\t\t(void *)t->rx_buf,\n\t\t\t\t\tt->len, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(hw->dev, dma_rx_addr))\n\t\t\t\tdev_err(hw->dev, \"rx dma map error\\n\");\n\t\t}\n\t} else {\n\t\tif (t->len > hw->dma_rx_tmpbuf_size) {\n\t\t\tint ret;\n\n\t\t\tau1550_spi_dma_rxtmp_free(hw);\n\t\t\tret = au1550_spi_dma_rxtmp_alloc(hw, max(t->len,\n\t\t\t\t\tAU1550_SPI_DMA_RXTMP_MINSIZE));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\thw->rx = hw->dma_rx_tmpbuf;\n\t\tdma_rx_addr = hw->dma_rx_tmpbuf_addr;\n\t\tdma_sync_single_for_device(hw->dev, dma_rx_addr,\n\t\t\tt->len, DMA_FROM_DEVICE);\n\t}\n\n\tif (!t->tx_buf) {\n\t\tdma_sync_single_for_device(hw->dev, dma_rx_addr,\n\t\t\t\tt->len, DMA_BIDIRECTIONAL);\n\t\thw->tx = hw->rx;\n\t}\n\n\t \n\tres = au1xxx_dbdma_put_dest(hw->dma_rx_ch, virt_to_phys(hw->rx),\n\t\t\t\t    t->len, DDMA_FLAGS_IE);\n\tif (!res)\n\t\tdev_err(hw->dev, \"rx dma put dest error\\n\");\n\n\tres = au1xxx_dbdma_put_source(hw->dma_tx_ch, virt_to_phys(hw->tx),\n\t\t\t\t      t->len, DDMA_FLAGS_IE);\n\tif (!res)\n\t\tdev_err(hw->dev, \"tx dma put source error\\n\");\n\n\tau1xxx_dbdma_start(hw->dma_rx_ch);\n\tau1xxx_dbdma_start(hw->dma_tx_ch);\n\n\t \n\thw->regs->psc_spimsk = PSC_SPIMSK_SD;\n\twmb();  \n\n\t \n\thw->regs->psc_spipcr = PSC_SPIPCR_MS;\n\twmb();  \n\n\twait_for_completion(&hw->host_done);\n\n\tau1xxx_dbdma_stop(hw->dma_tx_ch);\n\tau1xxx_dbdma_stop(hw->dma_rx_ch);\n\n\tif (!t->rx_buf) {\n\t\t \n\t\tdma_sync_single_for_cpu(hw->dev, dma_rx_addr, t->len,\n\t\t\tDMA_FROM_DEVICE);\n\t}\n\t \n\tif (t->rx_buf && t->rx_dma == 0)\n\t\tdma_unmap_single(hw->dev, dma_rx_addr, t->len,\n\t\t\tDMA_FROM_DEVICE);\n\tif (t->tx_buf && t->tx_dma == 0)\n\t\tdma_unmap_single(hw->dev, dma_tx_addr, t->len,\n\t\t\tDMA_TO_DEVICE);\n\n\treturn min(hw->rx_count, hw->tx_count);\n}\n\nstatic irqreturn_t au1550_spi_dma_irq_callback(struct au1550_spi *hw)\n{\n\tu32 stat, evnt;\n\n\tstat = hw->regs->psc_spistat;\n\tevnt = hw->regs->psc_spievent;\n\twmb();  \n\tif ((stat & PSC_SPISTAT_DI) == 0) {\n\t\tdev_err(hw->dev, \"Unexpected IRQ!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif ((evnt & (PSC_SPIEVNT_MM | PSC_SPIEVNT_RO\n\t\t\t\t| PSC_SPIEVNT_RU | PSC_SPIEVNT_TO\n\t\t\t\t| PSC_SPIEVNT_TU | PSC_SPIEVNT_SD))\n\t\t\t!= 0) {\n\t\t \n\t\tau1550_spi_mask_ack_all(hw);\n\t\tau1xxx_dbdma_stop(hw->dma_rx_ch);\n\t\tau1xxx_dbdma_stop(hw->dma_tx_ch);\n\n\t\t \n\t\thw->rx_count = hw->len - au1xxx_get_dma_residue(hw->dma_rx_ch);\n\t\thw->tx_count = hw->len - au1xxx_get_dma_residue(hw->dma_tx_ch);\n\n\t\tau1xxx_dbdma_reset(hw->dma_rx_ch);\n\t\tau1xxx_dbdma_reset(hw->dma_tx_ch);\n\t\tau1550_spi_reset_fifos(hw);\n\n\t\tif (evnt == PSC_SPIEVNT_RO)\n\t\t\tdev_err(hw->dev,\n\t\t\t\t\"dma transfer: receive FIFO overflow!\\n\");\n\t\telse\n\t\t\tdev_err(hw->dev,\n\t\t\t\t\"dma transfer: unexpected SPI error (event=0x%x stat=0x%x)!\\n\",\n\t\t\t\tevnt, stat);\n\n\t\tcomplete(&hw->host_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif ((evnt & PSC_SPIEVNT_MD) != 0) {\n\t\t \n\t\tau1550_spi_mask_ack_all(hw);\n\t\thw->rx_count = hw->len;\n\t\thw->tx_count = hw->len;\n\t\tcomplete(&hw->host_done);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\n \n#define AU1550_SPI_RX_WORD(size, mask)\t\t\t\t\t\\\nstatic void au1550_spi_rx_word_##size(struct au1550_spi *hw)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 fifoword = hw->regs->psc_spitxrx & (u32)(mask);\t\t\\\n\twmb();  \t\t\t\t\t\\\n\tif (hw->rx) {\t\t\t\t\t\t\t\\\n\t\t*(u##size *)hw->rx = (u##size)fifoword;\t\t\t\\\n\t\thw->rx += (size) / 8;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\thw->rx_count += (size) / 8;\t\t\t\t\t\\\n}\n\n#define AU1550_SPI_TX_WORD(size, mask)\t\t\t\t\t\\\nstatic void au1550_spi_tx_word_##size(struct au1550_spi *hw)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 fifoword = 0;\t\t\t\t\t\t\\\n\tif (hw->tx) {\t\t\t\t\t\t\t\\\n\t\tfifoword = *(u##size *)hw->tx & (u32)(mask);\t\t\\\n\t\thw->tx += (size) / 8;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\thw->tx_count += (size) / 8;\t\t\t\t\t\\\n\tif (hw->tx_count >= hw->len)\t\t\t\t\t\\\n\t\tfifoword |= PSC_SPITXRX_LC;\t\t\t\t\\\n\thw->regs->psc_spitxrx = fifoword;\t\t\t\t\\\n\twmb();  \t\t\t\t\t\\\n}\n\nAU1550_SPI_RX_WORD(8, 0xff)\nAU1550_SPI_RX_WORD(16, 0xffff)\nAU1550_SPI_RX_WORD(32, 0xffffff)\nAU1550_SPI_TX_WORD(8, 0xff)\nAU1550_SPI_TX_WORD(16, 0xffff)\nAU1550_SPI_TX_WORD(32, 0xffffff)\n\nstatic int au1550_spi_pio_txrxb(struct spi_device *spi, struct spi_transfer *t)\n{\n\tu32 stat, mask;\n\tstruct au1550_spi *hw = spi_controller_get_devdata(spi->controller);\n\n\thw->tx = t->tx_buf;\n\thw->rx = t->rx_buf;\n\thw->len = t->len;\n\thw->tx_count = 0;\n\thw->rx_count = 0;\n\n\t \n\tmask = PSC_SPIMSK_SD;\n\n\t \n\twhile (hw->tx_count < hw->len) {\n\n\t\thw->tx_word(hw);\n\n\t\tif (hw->tx_count >= hw->len) {\n\t\t\t \n\t\t\tmask |= PSC_SPIMSK_TR;\n\t\t}\n\n\t\tstat = hw->regs->psc_spistat;\n\t\twmb();  \n\t\tif (stat & PSC_SPISTAT_TF)\n\t\t\tbreak;\n\t}\n\n\t \n\thw->regs->psc_spimsk = mask;\n\twmb();  \n\n\t \n\thw->regs->psc_spipcr = PSC_SPIPCR_MS;\n\twmb();  \n\n\twait_for_completion(&hw->host_done);\n\n\treturn min(hw->rx_count, hw->tx_count);\n}\n\nstatic irqreturn_t au1550_spi_pio_irq_callback(struct au1550_spi *hw)\n{\n\tint busy;\n\tu32 stat, evnt;\n\n\tstat = hw->regs->psc_spistat;\n\tevnt = hw->regs->psc_spievent;\n\twmb();  \n\tif ((stat & PSC_SPISTAT_DI) == 0) {\n\t\tdev_err(hw->dev, \"Unexpected IRQ!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif ((evnt & (PSC_SPIEVNT_MM | PSC_SPIEVNT_RO\n\t\t\t\t| PSC_SPIEVNT_RU | PSC_SPIEVNT_TO\n\t\t\t\t| PSC_SPIEVNT_SD))\n\t\t\t!= 0) {\n\t\t \n\t\tau1550_spi_mask_ack_all(hw);\n\t\tau1550_spi_reset_fifos(hw);\n\t\tdev_err(hw->dev,\n\t\t\t\"pio transfer: unexpected SPI error (event=0x%x stat=0x%x)!\\n\",\n\t\t\tevnt, stat);\n\t\tcomplete(&hw->host_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tdo {\n\t\tbusy = 0;\n\t\tstat = hw->regs->psc_spistat;\n\t\twmb();  \n\n\t\t \n\t\tif (!(stat & PSC_SPISTAT_RE) && hw->rx_count < hw->len) {\n\t\t\thw->rx_word(hw);\n\t\t\tbusy = 1;\n\n\t\t\tif (!(stat & PSC_SPISTAT_TF) && hw->tx_count < hw->len)\n\t\t\t\thw->tx_word(hw);\n\t\t}\n\t} while (busy);\n\n\thw->regs->psc_spievent = PSC_SPIEVNT_RR | PSC_SPIEVNT_TR;\n\twmb();  \n\n\t \n\tif (evnt & PSC_SPIEVNT_TU) {\n\t\thw->regs->psc_spievent = PSC_SPIEVNT_TU | PSC_SPIEVNT_MD;\n\t\twmb();  \n\t\thw->regs->psc_spipcr = PSC_SPIPCR_MS;\n\t\twmb();  \n\t}\n\n\tif (hw->rx_count >= hw->len) {\n\t\t \n\t\tau1550_spi_mask_ack_all(hw);\n\t\tcomplete(&hw->host_done);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int au1550_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct au1550_spi *hw = spi_controller_get_devdata(spi->controller);\n\n\treturn hw->txrx_bufs(spi, t);\n}\n\nstatic irqreturn_t au1550_spi_irq(int irq, void *dev)\n{\n\tstruct au1550_spi *hw = dev;\n\n\treturn hw->irq_callback(hw);\n}\n\nstatic void au1550_spi_bits_handlers_set(struct au1550_spi *hw, int bpw)\n{\n\tif (bpw <= 8) {\n\t\tif (hw->usedma) {\n\t\t\thw->txrx_bufs = &au1550_spi_dma_txrxb;\n\t\t\thw->irq_callback = &au1550_spi_dma_irq_callback;\n\t\t} else {\n\t\t\thw->rx_word = &au1550_spi_rx_word_8;\n\t\t\thw->tx_word = &au1550_spi_tx_word_8;\n\t\t\thw->txrx_bufs = &au1550_spi_pio_txrxb;\n\t\t\thw->irq_callback = &au1550_spi_pio_irq_callback;\n\t\t}\n\t} else if (bpw <= 16) {\n\t\thw->rx_word = &au1550_spi_rx_word_16;\n\t\thw->tx_word = &au1550_spi_tx_word_16;\n\t\thw->txrx_bufs = &au1550_spi_pio_txrxb;\n\t\thw->irq_callback = &au1550_spi_pio_irq_callback;\n\t} else {\n\t\thw->rx_word = &au1550_spi_rx_word_32;\n\t\thw->tx_word = &au1550_spi_tx_word_32;\n\t\thw->txrx_bufs = &au1550_spi_pio_txrxb;\n\t\thw->irq_callback = &au1550_spi_pio_irq_callback;\n\t}\n}\n\nstatic void au1550_spi_setup_psc_as_spi(struct au1550_spi *hw)\n{\n\tu32 stat, cfg;\n\n\t \n\thw->regs->psc_ctrl = PSC_CTRL_DISABLE;\n\twmb();  \n\thw->regs->psc_sel = PSC_SEL_PS_SPIMODE;\n\twmb();  \n\n\thw->regs->psc_spicfg = 0;\n\twmb();  \n\n\thw->regs->psc_ctrl = PSC_CTRL_ENABLE;\n\twmb();  \n\n\tdo {\n\t\tstat = hw->regs->psc_spistat;\n\t\twmb();  \n\t} while ((stat & PSC_SPISTAT_SR) == 0);\n\n\n\tcfg = hw->usedma ? 0 : PSC_SPICFG_DD_DISABLE;\n\tcfg |= PSC_SPICFG_SET_LEN(8);\n\tcfg |= PSC_SPICFG_RT_FIFO8 | PSC_SPICFG_TT_FIFO8;\n\t \n\tcfg |= PSC_SPICFG_SET_BAUD(4) | PSC_SPICFG_SET_DIV(0);\n\n#ifdef AU1550_SPI_DEBUG_LOOPBACK\n\tcfg |= PSC_SPICFG_LB;\n#endif\n\n\thw->regs->psc_spicfg = cfg;\n\twmb();  \n\n\tau1550_spi_mask_ack_all(hw);\n\n\thw->regs->psc_spicfg |= PSC_SPICFG_DE_ENABLE;\n\twmb();  \n\n\tdo {\n\t\tstat = hw->regs->psc_spistat;\n\t\twmb();  \n\t} while ((stat & PSC_SPISTAT_DR) == 0);\n\n\tau1550_spi_reset_fifos(hw);\n}\n\n\nstatic int au1550_spi_probe(struct platform_device *pdev)\n{\n\tstruct au1550_spi *hw;\n\tstruct spi_controller *host;\n\tstruct resource *r;\n\tint err = 0;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(struct au1550_spi));\n\tif (host == NULL) {\n\t\tdev_err(&pdev->dev, \"No memory for spi_controller\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_nomem;\n\t}\n\n\t \n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 24);\n\n\thw = spi_controller_get_devdata(host);\n\n\thw->host = host;\n\thw->pdata = dev_get_platdata(&pdev->dev);\n\thw->dev = &pdev->dev;\n\n\tif (hw->pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"No platform data supplied\\n\");\n\t\terr = -ENOENT;\n\t\tgoto err_no_pdata;\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"no IRQ\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_no_iores;\n\t}\n\thw->irq = r->start;\n\n\thw->usedma = 0;\n\tr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (r) {\n\t\thw->dma_tx_id = r->start;\n\t\tr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\t\tif (r) {\n\t\t\thw->dma_rx_id = r->start;\n\t\t\tif (usedma && ddma_memid) {\n\t\t\t\tif (pdev->dev.dma_mask == NULL)\n\t\t\t\t\tdev_warn(&pdev->dev, \"no dma mask\\n\");\n\t\t\t\telse\n\t\t\t\t\thw->usedma = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"no mmio resource\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_no_iores;\n\t}\n\n\thw->ioarea = request_mem_region(r->start, sizeof(psc_spi_t),\n\t\t\t\t\tpdev->name);\n\tif (!hw->ioarea) {\n\t\tdev_err(&pdev->dev, \"Cannot reserve iomem region\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_no_iores;\n\t}\n\n\thw->regs = (psc_spi_t __iomem *)ioremap(r->start, sizeof(psc_spi_t));\n\tif (!hw->regs) {\n\t\tdev_err(&pdev->dev, \"cannot ioremap\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tplatform_set_drvdata(pdev, hw);\n\n\tinit_completion(&hw->host_done);\n\n\thw->bitbang.master = hw->host;\n\thw->bitbang.setup_transfer = au1550_spi_setupxfer;\n\thw->bitbang.chipselect = au1550_spi_chipsel;\n\thw->bitbang.txrx_bufs = au1550_spi_txrx_bufs;\n\n\tif (hw->usedma) {\n\t\thw->dma_tx_ch = au1xxx_dbdma_chan_alloc(ddma_memid,\n\t\t\thw->dma_tx_id, NULL, (void *)hw);\n\t\tif (hw->dma_tx_ch == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot allocate tx dma channel\\n\");\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_no_txdma;\n\t\t}\n\t\tau1xxx_dbdma_set_devwidth(hw->dma_tx_ch, 8);\n\t\tif (au1xxx_dbdma_ring_alloc(hw->dma_tx_ch,\n\t\t\tAU1550_SPI_DBDMA_DESCRIPTORS) == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot allocate tx dma descriptors\\n\");\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_no_txdma_descr;\n\t\t}\n\n\n\t\thw->dma_rx_ch = au1xxx_dbdma_chan_alloc(hw->dma_rx_id,\n\t\t\tddma_memid, NULL, (void *)hw);\n\t\tif (hw->dma_rx_ch == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot allocate rx dma channel\\n\");\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_no_rxdma;\n\t\t}\n\t\tau1xxx_dbdma_set_devwidth(hw->dma_rx_ch, 8);\n\t\tif (au1xxx_dbdma_ring_alloc(hw->dma_rx_ch,\n\t\t\tAU1550_SPI_DBDMA_DESCRIPTORS) == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot allocate rx dma descriptors\\n\");\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_no_rxdma_descr;\n\t\t}\n\n\t\terr = au1550_spi_dma_rxtmp_alloc(hw,\n\t\t\tAU1550_SPI_DMA_RXTMP_MINSIZE);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot allocate initial rx dma tmp buffer\\n\");\n\t\t\tgoto err_dma_rxtmp_alloc;\n\t\t}\n\t}\n\n\tau1550_spi_bits_handlers_set(hw, 8);\n\n\terr = request_irq(hw->irq, au1550_spi_irq, 0, pdev->name, hw);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot claim IRQ\\n\");\n\t\tgoto err_no_irq;\n\t}\n\n\thost->bus_num = pdev->id;\n\thost->num_chipselect = hw->pdata->num_chipselect;\n\n\t \n\t{\n\t\tint min_div = (2 << 0) * (2 * (4 + 1));\n\t\tint max_div = (2 << 3) * (2 * (63 + 1));\n\n\t\thost->max_speed_hz = hw->pdata->mainclk_hz / min_div;\n\t\thost->min_speed_hz =\n\t\t\t\thw->pdata->mainclk_hz / (max_div + 1) + 1;\n\t}\n\n\tau1550_spi_setup_psc_as_spi(hw);\n\n\terr = spi_bitbang_start(&hw->bitbang);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register SPI host\\n\");\n\t\tgoto err_register;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t\"spi host registered: bus_num=%d num_chipselect=%d\\n\",\n\t\thost->bus_num, host->num_chipselect);\n\n\treturn 0;\n\nerr_register:\n\tfree_irq(hw->irq, hw);\n\nerr_no_irq:\n\tau1550_spi_dma_rxtmp_free(hw);\n\nerr_dma_rxtmp_alloc:\nerr_no_rxdma_descr:\n\tif (hw->usedma)\n\t\tau1xxx_dbdma_chan_free(hw->dma_rx_ch);\n\nerr_no_rxdma:\nerr_no_txdma_descr:\n\tif (hw->usedma)\n\t\tau1xxx_dbdma_chan_free(hw->dma_tx_ch);\n\nerr_no_txdma:\n\tiounmap((void __iomem *)hw->regs);\n\nerr_ioremap:\n\trelease_mem_region(r->start, sizeof(psc_spi_t));\n\nerr_no_iores:\nerr_no_pdata:\n\tspi_controller_put(hw->host);\n\nerr_nomem:\n\treturn err;\n}\n\nstatic void au1550_spi_remove(struct platform_device *pdev)\n{\n\tstruct au1550_spi *hw = platform_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"spi host remove: bus_num=%d\\n\",\n\t\thw->host->bus_num);\n\n\tspi_bitbang_stop(&hw->bitbang);\n\tfree_irq(hw->irq, hw);\n\tiounmap((void __iomem *)hw->regs);\n\trelease_mem_region(hw->ioarea->start, sizeof(psc_spi_t));\n\n\tif (hw->usedma) {\n\t\tau1550_spi_dma_rxtmp_free(hw);\n\t\tau1xxx_dbdma_chan_free(hw->dma_rx_ch);\n\t\tau1xxx_dbdma_chan_free(hw->dma_tx_ch);\n\t}\n\n\tspi_controller_put(hw->host);\n}\n\n \nMODULE_ALIAS(\"platform:au1550-spi\");\n\nstatic struct platform_driver au1550_spi_drv = {\n\t.probe = au1550_spi_probe,\n\t.remove_new = au1550_spi_remove,\n\t.driver = {\n\t\t.name = \"au1550-spi\",\n\t},\n};\n\nstatic int __init au1550_spi_init(void)\n{\n\t \n\tswitch (alchemy_get_cputype()) {\n\tcase ALCHEMY_CPU_AU1550:\n\tcase ALCHEMY_CPU_AU1200:\n\tcase ALCHEMY_CPU_AU1300:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (usedma) {\n\t\tddma_memid = au1xxx_ddma_add_device(&au1550_spi_mem_dbdev);\n\t\tif (!ddma_memid)\n\t\t\tprintk(KERN_ERR \"au1550-spi: cannot add memory dbdma device\\n\");\n\t}\n\treturn platform_driver_register(&au1550_spi_drv);\n}\nmodule_init(au1550_spi_init);\n\nstatic void __exit au1550_spi_exit(void)\n{\n\tif (usedma && ddma_memid)\n\t\tau1xxx_ddma_del_device(ddma_memid);\n\tplatform_driver_unregister(&au1550_spi_drv);\n}\nmodule_exit(au1550_spi_exit);\n\nMODULE_DESCRIPTION(\"Au1550 PSC SPI Driver\");\nMODULE_AUTHOR(\"Jan Nikitenko <jan.nikitenko@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}