{
  "module_name": "spi-fsi.c",
  "hash_id": "da45758d6ad5af761ea1d3ad2a1741a2fce1cf3c5134e83edd4179474fa9d854",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsi.c",
  "human_readable_source": "\n\n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/fsi.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n#define FSI_ENGID_SPI\t\t\t0x23\n#define FSI_MBOX_ROOT_CTRL_8\t\t0x2860\n#define  FSI_MBOX_ROOT_CTRL_8_SPI_MUX\t 0xf0000000\n\n#define FSI2SPI_DATA0\t\t\t0x00\n#define FSI2SPI_DATA1\t\t\t0x04\n#define FSI2SPI_CMD\t\t\t0x08\n#define  FSI2SPI_CMD_WRITE\t\t BIT(31)\n#define FSI2SPI_RESET\t\t\t0x18\n#define FSI2SPI_STATUS\t\t\t0x1c\n#define  FSI2SPI_STATUS_ANY_ERROR\t BIT(31)\n#define FSI2SPI_IRQ\t\t\t0x20\n\n#define SPI_FSI_BASE\t\t\t0x70000\n#define SPI_FSI_TIMEOUT_MS\t\t1000\n#define SPI_FSI_MAX_RX_SIZE\t\t8\n#define SPI_FSI_MAX_TX_SIZE\t\t40\n\n#define SPI_FSI_ERROR\t\t\t0x0\n#define SPI_FSI_COUNTER_CFG\t\t0x1\n#define SPI_FSI_CFG1\t\t\t0x2\n#define SPI_FSI_CLOCK_CFG\t\t0x3\n#define  SPI_FSI_CLOCK_CFG_MM_ENABLE\t BIT_ULL(32)\n#define  SPI_FSI_CLOCK_CFG_ECC_DISABLE\t (BIT_ULL(35) | BIT_ULL(33))\n#define  SPI_FSI_CLOCK_CFG_RESET1\t (BIT_ULL(36) | BIT_ULL(38))\n#define  SPI_FSI_CLOCK_CFG_RESET2\t (BIT_ULL(37) | BIT_ULL(39))\n#define  SPI_FSI_CLOCK_CFG_MODE\t\t (BIT_ULL(41) | BIT_ULL(42))\n#define  SPI_FSI_CLOCK_CFG_SCK_RECV_DEL\t GENMASK_ULL(51, 44)\n#define   SPI_FSI_CLOCK_CFG_SCK_NO_DEL\t  BIT_ULL(51)\n#define  SPI_FSI_CLOCK_CFG_SCK_DIV\t GENMASK_ULL(63, 52)\n#define SPI_FSI_MMAP\t\t\t0x4\n#define SPI_FSI_DATA_TX\t\t\t0x5\n#define SPI_FSI_DATA_RX\t\t\t0x6\n#define SPI_FSI_SEQUENCE\t\t0x7\n#define  SPI_FSI_SEQUENCE_STOP\t\t 0x00\n#define  SPI_FSI_SEQUENCE_SEL_SLAVE(x)\t (0x10 | ((x) & 0xf))\n#define  SPI_FSI_SEQUENCE_SHIFT_OUT(x)\t (0x30 | ((x) & 0xf))\n#define  SPI_FSI_SEQUENCE_SHIFT_IN(x)\t (0x40 | ((x) & 0xf))\n#define  SPI_FSI_SEQUENCE_COPY_DATA_TX\t 0xc0\n#define  SPI_FSI_SEQUENCE_BRANCH(x)\t (0xe0 | ((x) & 0xf))\n#define SPI_FSI_STATUS\t\t\t0x8\n#define  SPI_FSI_STATUS_ERROR\t\t \\\n\t(GENMASK_ULL(31, 21) | GENMASK_ULL(15, 12))\n#define  SPI_FSI_STATUS_SEQ_STATE\t GENMASK_ULL(55, 48)\n#define   SPI_FSI_STATUS_SEQ_STATE_IDLE\t  BIT_ULL(48)\n#define  SPI_FSI_STATUS_TDR_UNDERRUN\t BIT_ULL(57)\n#define  SPI_FSI_STATUS_TDR_OVERRUN\t BIT_ULL(58)\n#define  SPI_FSI_STATUS_TDR_FULL\t BIT_ULL(59)\n#define  SPI_FSI_STATUS_RDR_UNDERRUN\t BIT_ULL(61)\n#define  SPI_FSI_STATUS_RDR_OVERRUN\t BIT_ULL(62)\n#define  SPI_FSI_STATUS_RDR_FULL\t BIT_ULL(63)\n#define  SPI_FSI_STATUS_ANY_ERROR\t \\\n\t(SPI_FSI_STATUS_ERROR | \\\n\t SPI_FSI_STATUS_TDR_OVERRUN | SPI_FSI_STATUS_RDR_UNDERRUN | \\\n\t SPI_FSI_STATUS_RDR_OVERRUN)\n#define SPI_FSI_PORT_CTRL\t\t0x9\n\nstruct fsi2spi {\n\tstruct fsi_device *fsi;  \n\tstruct mutex lock;  \n};\n\nstruct fsi_spi {\n\tstruct device *dev;\t \n\tstruct fsi2spi *bridge;  \n\tu32 base;\n};\n\nstruct fsi_spi_sequence {\n\tint bit;\n\tu64 data;\n};\n\nstatic int fsi_spi_check_mux(struct fsi_device *fsi, struct device *dev)\n{\n\tint rc;\n\tu32 root_ctrl_8;\n\t__be32 root_ctrl_8_be;\n\n\trc = fsi_slave_read(fsi->slave, FSI_MBOX_ROOT_CTRL_8, &root_ctrl_8_be,\n\t\t\t    sizeof(root_ctrl_8_be));\n\tif (rc)\n\t\treturn rc;\n\n\troot_ctrl_8 = be32_to_cpu(root_ctrl_8_be);\n\tdev_dbg(dev, \"Root control register 8: %08x\\n\", root_ctrl_8);\n\tif ((root_ctrl_8 & FSI_MBOX_ROOT_CTRL_8_SPI_MUX) ==\n\t     FSI_MBOX_ROOT_CTRL_8_SPI_MUX)\n\t\treturn 0;\n\n\treturn -ENOLINK;\n}\n\nstatic int fsi_spi_check_status(struct fsi_spi *ctx)\n{\n\tint rc;\n\tu32 sts;\n\t__be32 sts_be;\n\n\trc = fsi_device_read(ctx->bridge->fsi, FSI2SPI_STATUS, &sts_be,\n\t\t\t     sizeof(sts_be));\n\tif (rc)\n\t\treturn rc;\n\n\tsts = be32_to_cpu(sts_be);\n\tif (sts & FSI2SPI_STATUS_ANY_ERROR) {\n\t\tdev_err(ctx->dev, \"Error with FSI2SPI interface: %08x.\\n\", sts);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_spi_read_reg(struct fsi_spi *ctx, u32 offset, u64 *value)\n{\n\tint rc = 0;\n\t__be32 cmd_be;\n\t__be32 data_be;\n\tu32 cmd = offset + ctx->base;\n\tstruct fsi2spi *bridge = ctx->bridge;\n\n\t*value = 0ULL;\n\n\tif (cmd & FSI2SPI_CMD_WRITE)\n\t\treturn -EINVAL;\n\n\trc = mutex_lock_interruptible(&bridge->lock);\n\tif (rc)\n\t\treturn rc;\n\n\tcmd_be = cpu_to_be32(cmd);\n\trc = fsi_device_write(bridge->fsi, FSI2SPI_CMD, &cmd_be,\n\t\t\t      sizeof(cmd_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\trc = fsi_spi_check_status(ctx);\n\tif (rc)\n\t\tgoto unlock;\n\n\trc = fsi_device_read(bridge->fsi, FSI2SPI_DATA0, &data_be,\n\t\t\t     sizeof(data_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\t*value |= (u64)be32_to_cpu(data_be) << 32;\n\n\trc = fsi_device_read(bridge->fsi, FSI2SPI_DATA1, &data_be,\n\t\t\t     sizeof(data_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\t*value |= (u64)be32_to_cpu(data_be);\n\tdev_dbg(ctx->dev, \"Read %02x[%016llx].\\n\", offset, *value);\n\nunlock:\n\tmutex_unlock(&bridge->lock);\n\treturn rc;\n}\n\nstatic int fsi_spi_write_reg(struct fsi_spi *ctx, u32 offset, u64 value)\n{\n\tint rc = 0;\n\t__be32 cmd_be;\n\t__be32 data_be;\n\tu32 cmd = offset + ctx->base;\n\tstruct fsi2spi *bridge = ctx->bridge;\n\n\tif (cmd & FSI2SPI_CMD_WRITE)\n\t\treturn -EINVAL;\n\n\trc = mutex_lock_interruptible(&bridge->lock);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(ctx->dev, \"Write %02x[%016llx].\\n\", offset, value);\n\n\tdata_be = cpu_to_be32(upper_32_bits(value));\n\trc = fsi_device_write(bridge->fsi, FSI2SPI_DATA0, &data_be,\n\t\t\t      sizeof(data_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\tdata_be = cpu_to_be32(lower_32_bits(value));\n\trc = fsi_device_write(bridge->fsi, FSI2SPI_DATA1, &data_be,\n\t\t\t      sizeof(data_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\tcmd_be = cpu_to_be32(cmd | FSI2SPI_CMD_WRITE);\n\trc = fsi_device_write(bridge->fsi, FSI2SPI_CMD, &cmd_be,\n\t\t\t      sizeof(cmd_be));\n\tif (rc)\n\t\tgoto unlock;\n\n\trc = fsi_spi_check_status(ctx);\n\nunlock:\n\tmutex_unlock(&bridge->lock);\n\treturn rc;\n}\n\nstatic int fsi_spi_data_in(u64 in, u8 *rx, int len)\n{\n\tint i;\n\tint num_bytes = min(len, 8);\n\n\tfor (i = 0; i < num_bytes; ++i)\n\t\trx[i] = (u8)(in >> (8 * ((num_bytes - 1) - i)));\n\n\treturn num_bytes;\n}\n\nstatic int fsi_spi_data_out(u64 *out, const u8 *tx, int len)\n{\n\tint i;\n\tint num_bytes = min(len, 8);\n\tu8 *out_bytes = (u8 *)out;\n\n\t \n\t*out = 0ULL;\n\n\tfor (i = 0; i < num_bytes; ++i)\n\t\tout_bytes[8 - (i + 1)] = tx[i];\n\n\treturn num_bytes;\n}\n\nstatic int fsi_spi_reset(struct fsi_spi *ctx)\n{\n\tint rc;\n\n\tdev_dbg(ctx->dev, \"Resetting SPI controller.\\n\");\n\n\trc = fsi_spi_write_reg(ctx, SPI_FSI_CLOCK_CFG,\n\t\t\t       SPI_FSI_CLOCK_CFG_RESET1);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_spi_write_reg(ctx, SPI_FSI_CLOCK_CFG,\n\t\t\t       SPI_FSI_CLOCK_CFG_RESET2);\n\tif (rc)\n\t\treturn rc;\n\n\treturn fsi_spi_write_reg(ctx, SPI_FSI_STATUS, 0ULL);\n}\n\nstatic int fsi_spi_status(struct fsi_spi *ctx, u64 *status, const char *dir)\n{\n\tint rc = fsi_spi_read_reg(ctx, SPI_FSI_STATUS, status);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (*status & SPI_FSI_STATUS_ANY_ERROR) {\n\t\tdev_err(ctx->dev, \"%s error: %016llx\\n\", dir, *status);\n\n\t\trc = fsi_spi_reset(ctx);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void fsi_spi_sequence_add(struct fsi_spi_sequence *seq, u8 val)\n{\n\t \n\tseq->data |= (u64)val << seq->bit;\n\tseq->bit -= 8;\n}\n\nstatic void fsi_spi_sequence_init(struct fsi_spi_sequence *seq)\n{\n\tseq->bit = 56;\n\tseq->data = 0ULL;\n}\n\nstatic int fsi_spi_transfer_data(struct fsi_spi *ctx,\n\t\t\t\t struct spi_transfer *transfer)\n{\n\tint loops;\n\tint rc = 0;\n\tunsigned long end;\n\tu64 status = 0ULL;\n\n\tif (transfer->tx_buf) {\n\t\tint nb;\n\t\tint sent = 0;\n\t\tu64 out = 0ULL;\n\t\tconst u8 *tx = transfer->tx_buf;\n\n\t\twhile (transfer->len > sent) {\n\t\t\tnb = fsi_spi_data_out(&out, &tx[sent],\n\t\t\t\t\t      (int)transfer->len - sent);\n\n\t\t\trc = fsi_spi_write_reg(ctx, SPI_FSI_DATA_TX, out);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tloops = 0;\n\t\t\tend = jiffies + msecs_to_jiffies(SPI_FSI_TIMEOUT_MS);\n\t\t\tdo {\n\t\t\t\tif (loops++ && time_after(jiffies, end))\n\t\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\t\trc = fsi_spi_status(ctx, &status, \"TX\");\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} while (status & SPI_FSI_STATUS_TDR_FULL);\n\n\t\t\tsent += nb;\n\t\t}\n\t} else if (transfer->rx_buf) {\n\t\tint recv = 0;\n\t\tu64 in = 0ULL;\n\t\tu8 *rx = transfer->rx_buf;\n\n\t\twhile (transfer->len > recv) {\n\t\t\tloops = 0;\n\t\t\tend = jiffies + msecs_to_jiffies(SPI_FSI_TIMEOUT_MS);\n\t\t\tdo {\n\t\t\t\tif (loops++ && time_after(jiffies, end))\n\t\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\t\trc = fsi_spi_status(ctx, &status, \"RX\");\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} while (!(status & SPI_FSI_STATUS_RDR_FULL));\n\n\t\t\trc = fsi_spi_read_reg(ctx, SPI_FSI_DATA_RX, &in);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\trecv += fsi_spi_data_in(in, &rx[recv],\n\t\t\t\t\t\t(int)transfer->len - recv);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_spi_transfer_init(struct fsi_spi *ctx)\n{\n\tint loops = 0;\n\tint rc;\n\tbool reset = false;\n\tunsigned long end;\n\tu64 seq_state;\n\tu64 clock_cfg = 0ULL;\n\tu64 status = 0ULL;\n\tu64 wanted_clock_cfg = SPI_FSI_CLOCK_CFG_ECC_DISABLE |\n\t\tSPI_FSI_CLOCK_CFG_SCK_NO_DEL |\n\t\tFIELD_PREP(SPI_FSI_CLOCK_CFG_SCK_DIV, 19);\n\n\tend = jiffies + msecs_to_jiffies(SPI_FSI_TIMEOUT_MS);\n\tdo {\n\t\tif (loops++ && time_after(jiffies, end))\n\t\t\treturn -ETIMEDOUT;\n\n\t\trc = fsi_spi_read_reg(ctx, SPI_FSI_STATUS, &status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tseq_state = status & SPI_FSI_STATUS_SEQ_STATE;\n\n\t\tif (status & (SPI_FSI_STATUS_ANY_ERROR |\n\t\t\t      SPI_FSI_STATUS_TDR_FULL |\n\t\t\t      SPI_FSI_STATUS_RDR_FULL)) {\n\t\t\tif (reset) {\n\t\t\t\tdev_err(ctx->dev,\n\t\t\t\t\t\"Initialization error: %08llx\\n\",\n\t\t\t\t\tstatus);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\trc = fsi_spi_reset(ctx);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\treset = true;\n\t\t\tcontinue;\n\t\t}\n\t} while (seq_state && (seq_state != SPI_FSI_STATUS_SEQ_STATE_IDLE));\n\n\trc = fsi_spi_write_reg(ctx, SPI_FSI_COUNTER_CFG, 0ULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_spi_read_reg(ctx, SPI_FSI_CLOCK_CFG, &clock_cfg);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((clock_cfg & (SPI_FSI_CLOCK_CFG_MM_ENABLE |\n\t\t\t  SPI_FSI_CLOCK_CFG_ECC_DISABLE |\n\t\t\t  SPI_FSI_CLOCK_CFG_MODE |\n\t\t\t  SPI_FSI_CLOCK_CFG_SCK_RECV_DEL |\n\t\t\t  SPI_FSI_CLOCK_CFG_SCK_DIV)) != wanted_clock_cfg)\n\t\trc = fsi_spi_write_reg(ctx, SPI_FSI_CLOCK_CFG,\n\t\t\t\t       wanted_clock_cfg);\n\n\treturn rc;\n}\n\nstatic int fsi_spi_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t\tstruct spi_message *mesg)\n{\n\tint rc;\n\tu8 seq_slave = SPI_FSI_SEQUENCE_SEL_SLAVE(spi_get_chipselect(mesg->spi, 0) + 1);\n\tunsigned int len;\n\tstruct spi_transfer *transfer;\n\tstruct fsi_spi *ctx = spi_controller_get_devdata(ctlr);\n\n\trc = fsi_spi_check_mux(ctx->bridge->fsi, ctx->dev);\n\tif (rc)\n\t\tgoto error;\n\n\tlist_for_each_entry(transfer, &mesg->transfers, transfer_list) {\n\t\tstruct fsi_spi_sequence seq;\n\t\tstruct spi_transfer *next = NULL;\n\n\t\t \n\t\tif (!transfer->tx_buf || transfer->len > SPI_FSI_MAX_TX_SIZE) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tdev_dbg(ctx->dev, \"Start tx of %d bytes.\\n\", transfer->len);\n\n\t\trc = fsi_spi_transfer_init(ctx);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\tfsi_spi_sequence_init(&seq);\n\t\tfsi_spi_sequence_add(&seq, seq_slave);\n\n\t\tlen = transfer->len;\n\t\twhile (len > 8) {\n\t\t\tfsi_spi_sequence_add(&seq,\n\t\t\t\t\t     SPI_FSI_SEQUENCE_SHIFT_OUT(8));\n\t\t\tlen -= 8;\n\t\t}\n\t\tfsi_spi_sequence_add(&seq, SPI_FSI_SEQUENCE_SHIFT_OUT(len));\n\n\t\tif (!list_is_last(&transfer->transfer_list,\n\t\t\t\t  &mesg->transfers)) {\n\t\t\tnext = list_next_entry(transfer, transfer_list);\n\n\t\t\t \n\t\t\tif (next->rx_buf) {\n\t\t\t\tu8 shift;\n\n\t\t\t\tif (next->len > SPI_FSI_MAX_RX_SIZE) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tdev_dbg(ctx->dev, \"Sequence rx of %d bytes.\\n\",\n\t\t\t\t\tnext->len);\n\n\t\t\t\tshift = SPI_FSI_SEQUENCE_SHIFT_IN(next->len);\n\t\t\t\tfsi_spi_sequence_add(&seq, shift);\n\t\t\t} else {\n\t\t\t\tnext = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfsi_spi_sequence_add(&seq, SPI_FSI_SEQUENCE_SEL_SLAVE(0));\n\n\t\trc = fsi_spi_write_reg(ctx, SPI_FSI_SEQUENCE, seq.data);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trc = fsi_spi_transfer_data(ctx, transfer);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\tif (next) {\n\t\t\trc = fsi_spi_transfer_data(ctx, next);\n\t\t\tif (rc)\n\t\t\t\tgoto error;\n\n\t\t\ttransfer = next;\n\t\t}\n\t}\n\nerror:\n\tmesg->status = rc;\n\tspi_finalize_current_message(ctlr);\n\n\treturn rc;\n}\n\nstatic size_t fsi_spi_max_transfer_size(struct spi_device *spi)\n{\n\treturn SPI_FSI_MAX_RX_SIZE;\n}\n\nstatic int fsi_spi_probe(struct device *dev)\n{\n\tint rc;\n\tstruct device_node *np;\n\tint num_controllers_registered = 0;\n\tstruct fsi2spi *bridge;\n\tstruct fsi_device *fsi = to_fsi_dev(dev);\n\n\trc = fsi_spi_check_mux(fsi, dev);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\tbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->fsi = fsi;\n\tmutex_init(&bridge->lock);\n\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tu32 base;\n\t\tstruct fsi_spi *ctx;\n\t\tstruct spi_controller *ctlr;\n\n\t\tif (of_property_read_u32(np, \"reg\", &base))\n\t\t\tcontinue;\n\n\t\tctlr = spi_alloc_host(dev, sizeof(*ctx));\n\t\tif (!ctlr) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tctlr->dev.of_node = np;\n\t\tctlr->num_chipselect = of_get_available_child_count(np) ?: 1;\n\t\tctlr->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\t\tctlr->max_transfer_size = fsi_spi_max_transfer_size;\n\t\tctlr->transfer_one_message = fsi_spi_transfer_one_message;\n\n\t\tctx = spi_controller_get_devdata(ctlr);\n\t\tctx->dev = &ctlr->dev;\n\t\tctx->bridge = bridge;\n\t\tctx->base = base + SPI_FSI_BASE;\n\n\t\trc = devm_spi_register_controller(dev, ctlr);\n\t\tif (rc)\n\t\t\tspi_controller_put(ctlr);\n\t\telse\n\t\t\tnum_controllers_registered++;\n\t}\n\n\tif (!num_controllers_registered)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct fsi_device_id fsi_spi_ids[] = {\n\t{ FSI_ENGID_SPI, FSI_VERSION_ANY },\n\t{ }\n};\nMODULE_DEVICE_TABLE(fsi, fsi_spi_ids);\n\nstatic struct fsi_driver fsi_spi_driver = {\n\t.id_table = fsi_spi_ids,\n\t.drv = {\n\t\t.name = \"spi-fsi\",\n\t\t.bus = &fsi_bus_type,\n\t\t.probe = fsi_spi_probe,\n\t},\n};\nmodule_fsi_driver(fsi_spi_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"FSI attached SPI controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}