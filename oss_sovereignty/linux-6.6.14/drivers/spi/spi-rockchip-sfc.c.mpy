{
  "module_name": "spi-rockchip-sfc.c",
  "hash_id": "9c1fcc465aba4c2410ebddb0daae7e08138c491e8c14feef79a924f633f39db0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-rockchip-sfc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define SFC_CTRL\t\t\t0x0\n#define  SFC_CTRL_PHASE_SEL_NEGETIVE\tBIT(1)\n#define  SFC_CTRL_CMD_BITS_SHIFT\t8\n#define  SFC_CTRL_ADDR_BITS_SHIFT\t10\n#define  SFC_CTRL_DATA_BITS_SHIFT\t12\n\n \n#define SFC_IMR\t\t\t\t0x4\n#define  SFC_IMR_RX_FULL\t\tBIT(0)\n#define  SFC_IMR_RX_UFLOW\t\tBIT(1)\n#define  SFC_IMR_TX_OFLOW\t\tBIT(2)\n#define  SFC_IMR_TX_EMPTY\t\tBIT(3)\n#define  SFC_IMR_TRAN_FINISH\t\tBIT(4)\n#define  SFC_IMR_BUS_ERR\t\tBIT(5)\n#define  SFC_IMR_NSPI_ERR\t\tBIT(6)\n#define  SFC_IMR_DMA\t\t\tBIT(7)\n\n \n#define SFC_ICLR\t\t\t0x8\n#define  SFC_ICLR_RX_FULL\t\tBIT(0)\n#define  SFC_ICLR_RX_UFLOW\t\tBIT(1)\n#define  SFC_ICLR_TX_OFLOW\t\tBIT(2)\n#define  SFC_ICLR_TX_EMPTY\t\tBIT(3)\n#define  SFC_ICLR_TRAN_FINISH\t\tBIT(4)\n#define  SFC_ICLR_BUS_ERR\t\tBIT(5)\n#define  SFC_ICLR_NSPI_ERR\t\tBIT(6)\n#define  SFC_ICLR_DMA\t\t\tBIT(7)\n\n \n#define SFC_FTLR\t\t\t0xc\n#define  SFC_FTLR_TX_SHIFT\t\t0\n#define  SFC_FTLR_TX_MASK\t\t0x1f\n#define  SFC_FTLR_RX_SHIFT\t\t8\n#define  SFC_FTLR_RX_MASK\t\t0x1f\n\n \n#define SFC_RCVR\t\t\t0x10\n#define  SFC_RCVR_RESET\t\t\tBIT(0)\n\n \n#define SFC_AX\t\t\t\t0x14\n\n \n#define SFC_ABIT\t\t\t0x18\n\n \n#define SFC_ISR\t\t\t\t0x1c\n#define  SFC_ISR_RX_FULL_SHIFT\t\tBIT(0)\n#define  SFC_ISR_RX_UFLOW_SHIFT\t\tBIT(1)\n#define  SFC_ISR_TX_OFLOW_SHIFT\t\tBIT(2)\n#define  SFC_ISR_TX_EMPTY_SHIFT\t\tBIT(3)\n#define  SFC_ISR_TX_FINISH_SHIFT\tBIT(4)\n#define  SFC_ISR_BUS_ERR_SHIFT\t\tBIT(5)\n#define  SFC_ISR_NSPI_ERR_SHIFT\t\tBIT(6)\n#define  SFC_ISR_DMA_SHIFT\t\tBIT(7)\n\n \n#define SFC_FSR\t\t\t\t0x20\n#define  SFC_FSR_TX_IS_FULL\t\tBIT(0)\n#define  SFC_FSR_TX_IS_EMPTY\t\tBIT(1)\n#define  SFC_FSR_RX_IS_EMPTY\t\tBIT(2)\n#define  SFC_FSR_RX_IS_FULL\t\tBIT(3)\n#define  SFC_FSR_TXLV_MASK\t\tGENMASK(12, 8)\n#define  SFC_FSR_TXLV_SHIFT\t\t8\n#define  SFC_FSR_RXLV_MASK\t\tGENMASK(20, 16)\n#define  SFC_FSR_RXLV_SHIFT\t\t16\n\n \n#define SFC_SR\t\t\t\t0x24\n#define  SFC_SR_IS_IDLE\t\t\t0x0\n#define  SFC_SR_IS_BUSY\t\t\t0x1\n\n \n#define SFC_RISR\t\t\t0x28\n#define  SFC_RISR_RX_FULL\t\tBIT(0)\n#define  SFC_RISR_RX_UNDERFLOW\t\tBIT(1)\n#define  SFC_RISR_TX_OVERFLOW\t\tBIT(2)\n#define  SFC_RISR_TX_EMPTY\t\tBIT(3)\n#define  SFC_RISR_TRAN_FINISH\t\tBIT(4)\n#define  SFC_RISR_BUS_ERR\t\tBIT(5)\n#define  SFC_RISR_NSPI_ERR\t\tBIT(6)\n#define  SFC_RISR_DMA\t\t\tBIT(7)\n\n \n#define SFC_VER\t\t\t\t0x2C\n#define  SFC_VER_3\t\t\t0x3\n#define  SFC_VER_4\t\t\t0x4\n#define  SFC_VER_5\t\t\t0x5\n\n \n#define SFC_DLL_CTRL0\t\t\t0x3C\n#define SFC_DLL_CTRL0_SCLK_SMP_DLL\tBIT(15)\n#define SFC_DLL_CTRL0_DLL_MAX_VER4\t0xFFU\n#define SFC_DLL_CTRL0_DLL_MAX_VER5\t0x1FFU\n\n \n#define SFC_DMA_TRIGGER\t\t\t0x80\n#define SFC_DMA_TRIGGER_START\t\t1\n\n \n#define SFC_DMA_ADDR\t\t\t0x84\n\n \n#define SFC_LEN_CTRL\t\t\t0x88\n#define SFC_LEN_CTRL_TRB_SEL\t\t1\n#define SFC_LEN_EXT\t\t\t0x8C\n\n \n#define SFC_CMD\t\t\t\t0x100\n#define  SFC_CMD_IDX_SHIFT\t\t0\n#define  SFC_CMD_DUMMY_SHIFT\t\t8\n#define  SFC_CMD_DIR_SHIFT\t\t12\n#define  SFC_CMD_DIR_RD\t\t\t0\n#define  SFC_CMD_DIR_WR\t\t\t1\n#define  SFC_CMD_ADDR_SHIFT\t\t14\n#define  SFC_CMD_ADDR_0BITS\t\t0\n#define  SFC_CMD_ADDR_24BITS\t\t1\n#define  SFC_CMD_ADDR_32BITS\t\t2\n#define  SFC_CMD_ADDR_XBITS\t\t3\n#define  SFC_CMD_TRAN_BYTES_SHIFT\t16\n#define  SFC_CMD_CS_SHIFT\t\t30\n\n \n#define SFC_ADDR\t\t\t0x104\n\n \n#define SFC_DATA\t\t\t0x108\n\n \n#define SFC_MAX_CHIPSELECT_NUM\t\t4\n\n \n#define SFC_MAX_IOSIZE_VER3\t\t(512 * 31)\n\n \n#define SFC_DMA_TRANS_THRETHOLD\t\t(0x40)\n\n \n#define SFC_MAX_SPEED\t\t(150 * 1000 * 1000)\n\nstruct rockchip_sfc {\n\tstruct device *dev;\n\tvoid __iomem *regbase;\n\tstruct clk *hclk;\n\tstruct clk *clk;\n\tu32 frequency;\n\t \n\tvoid *buffer;\n\tdma_addr_t dma_buffer;\n\tstruct completion cp;\n\tbool use_dma;\n\tu32 max_iosize;\n\tu16 version;\n};\n\nstatic int rockchip_sfc_reset(struct rockchip_sfc *sfc)\n{\n\tint err;\n\tu32 status;\n\n\twritel_relaxed(SFC_RCVR_RESET, sfc->regbase + SFC_RCVR);\n\n\terr = readl_poll_timeout(sfc->regbase + SFC_RCVR, status,\n\t\t\t\t !(status & SFC_RCVR_RESET), 20,\n\t\t\t\t jiffies_to_usecs(HZ));\n\tif (err)\n\t\tdev_err(sfc->dev, \"SFC reset never finished\\n\");\n\n\t \n\twritel_relaxed(0xFFFFFFFF, sfc->regbase + SFC_ICLR);\n\n\tdev_dbg(sfc->dev, \"reset\\n\");\n\n\treturn err;\n}\n\nstatic u16 rockchip_sfc_get_version(struct rockchip_sfc *sfc)\n{\n\treturn  (u16)(readl(sfc->regbase + SFC_VER) & 0xffff);\n}\n\nstatic u32 rockchip_sfc_get_max_iosize(struct rockchip_sfc *sfc)\n{\n\treturn SFC_MAX_IOSIZE_VER3;\n}\n\nstatic void rockchip_sfc_irq_unmask(struct rockchip_sfc *sfc, u32 mask)\n{\n\tu32 reg;\n\n\t \n\treg = readl(sfc->regbase + SFC_IMR);\n\treg &= ~mask;\n\twritel(reg, sfc->regbase + SFC_IMR);\n}\n\nstatic void rockchip_sfc_irq_mask(struct rockchip_sfc *sfc, u32 mask)\n{\n\tu32 reg;\n\n\t \n\treg = readl(sfc->regbase + SFC_IMR);\n\treg |= mask;\n\twritel(reg, sfc->regbase + SFC_IMR);\n}\n\nstatic int rockchip_sfc_init(struct rockchip_sfc *sfc)\n{\n\twritel(0, sfc->regbase + SFC_CTRL);\n\twritel(0xFFFFFFFF, sfc->regbase + SFC_ICLR);\n\trockchip_sfc_irq_mask(sfc, 0xFFFFFFFF);\n\tif (rockchip_sfc_get_version(sfc) >= SFC_VER_4)\n\t\twritel(SFC_LEN_CTRL_TRB_SEL, sfc->regbase + SFC_LEN_CTRL);\n\n\treturn 0;\n}\n\nstatic int rockchip_sfc_wait_txfifo_ready(struct rockchip_sfc *sfc, u32 timeout_us)\n{\n\tint ret = 0;\n\tu32 status;\n\n\tret = readl_poll_timeout(sfc->regbase + SFC_FSR, status,\n\t\t\t\t status & SFC_FSR_TXLV_MASK, 0,\n\t\t\t\t timeout_us);\n\tif (ret) {\n\t\tdev_dbg(sfc->dev, \"sfc wait tx fifo timeout\\n\");\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn (status & SFC_FSR_TXLV_MASK) >> SFC_FSR_TXLV_SHIFT;\n}\n\nstatic int rockchip_sfc_wait_rxfifo_ready(struct rockchip_sfc *sfc, u32 timeout_us)\n{\n\tint ret = 0;\n\tu32 status;\n\n\tret = readl_poll_timeout(sfc->regbase + SFC_FSR, status,\n\t\t\t\t status & SFC_FSR_RXLV_MASK, 0,\n\t\t\t\t timeout_us);\n\tif (ret) {\n\t\tdev_dbg(sfc->dev, \"sfc wait rx fifo timeout\\n\");\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn (status & SFC_FSR_RXLV_MASK) >> SFC_FSR_RXLV_SHIFT;\n}\n\nstatic void rockchip_sfc_adjust_op_work(struct spi_mem_op *op)\n{\n\tif (unlikely(op->dummy.nbytes && !op->addr.nbytes)) {\n\t\t \n\t\top->addr.nbytes = op->dummy.nbytes;\n\t\top->addr.buswidth = op->dummy.buswidth;\n\t\top->addr.val = 0xFFFFFFFFF;\n\n\t\top->dummy.nbytes = 0;\n\t}\n}\n\nstatic int rockchip_sfc_xfer_setup(struct rockchip_sfc *sfc,\n\t\t\t\t   struct spi_mem *mem,\n\t\t\t\t   const struct spi_mem_op *op,\n\t\t\t\t   u32 len)\n{\n\tu32 ctrl = 0, cmd = 0;\n\n\t \n\tcmd = op->cmd.opcode;\n\tctrl |= ((op->cmd.buswidth >> 1) << SFC_CTRL_CMD_BITS_SHIFT);\n\n\t \n\tif (op->addr.nbytes) {\n\t\tif (op->addr.nbytes == 4) {\n\t\t\tcmd |= SFC_CMD_ADDR_32BITS << SFC_CMD_ADDR_SHIFT;\n\t\t} else if (op->addr.nbytes == 3) {\n\t\t\tcmd |= SFC_CMD_ADDR_24BITS << SFC_CMD_ADDR_SHIFT;\n\t\t} else {\n\t\t\tcmd |= SFC_CMD_ADDR_XBITS << SFC_CMD_ADDR_SHIFT;\n\t\t\twritel(op->addr.nbytes * 8 - 1, sfc->regbase + SFC_ABIT);\n\t\t}\n\n\t\tctrl |= ((op->addr.buswidth >> 1) << SFC_CTRL_ADDR_BITS_SHIFT);\n\t}\n\n\t \n\tif (op->dummy.nbytes) {\n\t\tif (op->dummy.buswidth == 4)\n\t\t\tcmd |= op->dummy.nbytes * 2 << SFC_CMD_DUMMY_SHIFT;\n\t\telse if (op->dummy.buswidth == 2)\n\t\t\tcmd |= op->dummy.nbytes * 4 << SFC_CMD_DUMMY_SHIFT;\n\t\telse\n\t\t\tcmd |= op->dummy.nbytes * 8 << SFC_CMD_DUMMY_SHIFT;\n\t}\n\n\t \n\tif (sfc->version >= SFC_VER_4)  \n\t\twritel(len, sfc->regbase + SFC_LEN_EXT);\n\telse\n\t\tcmd |= len << SFC_CMD_TRAN_BYTES_SHIFT;\n\tif (len) {\n\t\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\t\tcmd |= SFC_CMD_DIR_WR << SFC_CMD_DIR_SHIFT;\n\n\t\tctrl |= ((op->data.buswidth >> 1) << SFC_CTRL_DATA_BITS_SHIFT);\n\t}\n\tif (!len && op->addr.nbytes)\n\t\tcmd |= SFC_CMD_DIR_WR << SFC_CMD_DIR_SHIFT;\n\n\t \n\tctrl |= SFC_CTRL_PHASE_SEL_NEGETIVE;\n\tcmd |= spi_get_chipselect(mem->spi, 0) << SFC_CMD_CS_SHIFT;\n\n\tdev_dbg(sfc->dev, \"sfc addr.nbytes=%x(x%d) dummy.nbytes=%x(x%d)\\n\",\n\t\top->addr.nbytes, op->addr.buswidth,\n\t\top->dummy.nbytes, op->dummy.buswidth);\n\tdev_dbg(sfc->dev, \"sfc ctrl=%x cmd=%x addr=%llx len=%x\\n\",\n\t\tctrl, cmd, op->addr.val, len);\n\n\twritel(ctrl, sfc->regbase + SFC_CTRL);\n\twritel(cmd, sfc->regbase + SFC_CMD);\n\tif (op->addr.nbytes)\n\t\twritel(op->addr.val, sfc->regbase + SFC_ADDR);\n\n\treturn 0;\n}\n\nstatic int rockchip_sfc_write_fifo(struct rockchip_sfc *sfc, const u8 *buf, int len)\n{\n\tu8 bytes = len & 0x3;\n\tu32 dwords;\n\tint tx_level;\n\tu32 write_words;\n\tu32 tmp = 0;\n\n\tdwords = len >> 2;\n\twhile (dwords) {\n\t\ttx_level = rockchip_sfc_wait_txfifo_ready(sfc, 1000);\n\t\tif (tx_level < 0)\n\t\t\treturn tx_level;\n\t\twrite_words = min_t(u32, tx_level, dwords);\n\t\tiowrite32_rep(sfc->regbase + SFC_DATA, buf, write_words);\n\t\tbuf += write_words << 2;\n\t\tdwords -= write_words;\n\t}\n\n\t \n\tif (bytes) {\n\t\ttx_level = rockchip_sfc_wait_txfifo_ready(sfc, 1000);\n\t\tif (tx_level < 0)\n\t\t\treturn tx_level;\n\t\tmemcpy(&tmp, buf, bytes);\n\t\twritel(tmp, sfc->regbase + SFC_DATA);\n\t}\n\n\treturn len;\n}\n\nstatic int rockchip_sfc_read_fifo(struct rockchip_sfc *sfc, u8 *buf, int len)\n{\n\tu8 bytes = len & 0x3;\n\tu32 dwords;\n\tu8 read_words;\n\tint rx_level;\n\tint tmp;\n\n\t \n\tdwords = len >> 2;\n\twhile (dwords) {\n\t\trx_level = rockchip_sfc_wait_rxfifo_ready(sfc, 1000);\n\t\tif (rx_level < 0)\n\t\t\treturn rx_level;\n\t\tread_words = min_t(u32, rx_level, dwords);\n\t\tioread32_rep(sfc->regbase + SFC_DATA, buf, read_words);\n\t\tbuf += read_words << 2;\n\t\tdwords -= read_words;\n\t}\n\n\t \n\tif (bytes) {\n\t\trx_level = rockchip_sfc_wait_rxfifo_ready(sfc, 1000);\n\t\tif (rx_level < 0)\n\t\t\treturn rx_level;\n\t\ttmp = readl(sfc->regbase + SFC_DATA);\n\t\tmemcpy(buf, &tmp, bytes);\n\t}\n\n\treturn len;\n}\n\nstatic int rockchip_sfc_fifo_transfer_dma(struct rockchip_sfc *sfc, dma_addr_t dma_buf, size_t len)\n{\n\twritel(0xFFFFFFFF, sfc->regbase + SFC_ICLR);\n\twritel((u32)dma_buf, sfc->regbase + SFC_DMA_ADDR);\n\twritel(SFC_DMA_TRIGGER_START, sfc->regbase + SFC_DMA_TRIGGER);\n\n\treturn len;\n}\n\nstatic int rockchip_sfc_xfer_data_poll(struct rockchip_sfc *sfc,\n\t\t\t\t       const struct spi_mem_op *op, u32 len)\n{\n\tdev_dbg(sfc->dev, \"sfc xfer_poll len=%x\\n\", len);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\treturn rockchip_sfc_write_fifo(sfc, op->data.buf.out, len);\n\telse\n\t\treturn rockchip_sfc_read_fifo(sfc, op->data.buf.in, len);\n}\n\nstatic int rockchip_sfc_xfer_data_dma(struct rockchip_sfc *sfc,\n\t\t\t\t      const struct spi_mem_op *op, u32 len)\n{\n\tint ret;\n\n\tdev_dbg(sfc->dev, \"sfc xfer_dma len=%x\\n\", len);\n\n\tif (op->data.dir == SPI_MEM_DATA_OUT)\n\t\tmemcpy(sfc->buffer, op->data.buf.out, len);\n\n\tret = rockchip_sfc_fifo_transfer_dma(sfc, sfc->dma_buffer, len);\n\tif (!wait_for_completion_timeout(&sfc->cp, msecs_to_jiffies(2000))) {\n\t\tdev_err(sfc->dev, \"DMA wait for transfer finish timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\trockchip_sfc_irq_mask(sfc, SFC_IMR_DMA);\n\tif (op->data.dir == SPI_MEM_DATA_IN)\n\t\tmemcpy(op->data.buf.in, sfc->buffer, len);\n\n\treturn ret;\n}\n\nstatic int rockchip_sfc_xfer_done(struct rockchip_sfc *sfc, u32 timeout_us)\n{\n\tint ret = 0;\n\tu32 status;\n\n\tret = readl_poll_timeout(sfc->regbase + SFC_SR, status,\n\t\t\t\t !(status & SFC_SR_IS_BUSY),\n\t\t\t\t 20, timeout_us);\n\tif (ret) {\n\t\tdev_err(sfc->dev, \"wait sfc idle timeout\\n\");\n\t\trockchip_sfc_reset(sfc);\n\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_sfc_exec_mem_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct rockchip_sfc *sfc = spi_controller_get_devdata(mem->spi->controller);\n\tu32 len = op->data.nbytes;\n\tint ret;\n\n\tif (unlikely(mem->spi->max_speed_hz != sfc->frequency)) {\n\t\tret = clk_set_rate(sfc->clk, mem->spi->max_speed_hz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsfc->frequency = mem->spi->max_speed_hz;\n\t\tdev_dbg(sfc->dev, \"set_freq=%dHz real_freq=%ldHz\\n\",\n\t\t\tsfc->frequency, clk_get_rate(sfc->clk));\n\t}\n\n\trockchip_sfc_adjust_op_work((struct spi_mem_op *)op);\n\trockchip_sfc_xfer_setup(sfc, mem, op, len);\n\tif (len) {\n\t\tif (likely(sfc->use_dma) && len >= SFC_DMA_TRANS_THRETHOLD) {\n\t\t\tinit_completion(&sfc->cp);\n\t\t\trockchip_sfc_irq_unmask(sfc, SFC_IMR_DMA);\n\t\t\tret = rockchip_sfc_xfer_data_dma(sfc, op, len);\n\t\t} else {\n\t\t\tret = rockchip_sfc_xfer_data_poll(sfc, op, len);\n\t\t}\n\n\t\tif (ret != len) {\n\t\t\tdev_err(sfc->dev, \"xfer data failed ret %d dir %d\\n\", ret, op->data.dir);\n\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn rockchip_sfc_xfer_done(sfc, 100000);\n}\n\nstatic int rockchip_sfc_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\tstruct rockchip_sfc *sfc = spi_controller_get_devdata(mem->spi->controller);\n\n\top->data.nbytes = min(op->data.nbytes, sfc->max_iosize);\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops rockchip_sfc_mem_ops = {\n\t.exec_op = rockchip_sfc_exec_mem_op,\n\t.adjust_op_size = rockchip_sfc_adjust_op_size,\n};\n\nstatic irqreturn_t rockchip_sfc_irq_handler(int irq, void *dev_id)\n{\n\tstruct rockchip_sfc *sfc = dev_id;\n\tu32 reg;\n\n\treg = readl(sfc->regbase + SFC_RISR);\n\n\t \n\twritel_relaxed(reg, sfc->regbase + SFC_ICLR);\n\n\tif (reg & SFC_RISR_DMA) {\n\t\tcomplete(&sfc->cp);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int rockchip_sfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *host;\n\tstruct rockchip_sfc *sfc;\n\tint ret;\n\n\thost = devm_spi_alloc_host(&pdev->dev, sizeof(*sfc));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->flags = SPI_CONTROLLER_HALF_DUPLEX;\n\thost->mem_ops = &rockchip_sfc_mem_ops;\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->mode_bits = SPI_TX_QUAD | SPI_TX_DUAL | SPI_RX_QUAD | SPI_RX_DUAL;\n\thost->max_speed_hz = SFC_MAX_SPEED;\n\thost->num_chipselect = SFC_MAX_CHIPSELECT_NUM;\n\n\tsfc = spi_controller_get_devdata(host);\n\tsfc->dev = dev;\n\n\tsfc->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sfc->regbase))\n\t\treturn PTR_ERR(sfc->regbase);\n\n\tsfc->clk = devm_clk_get(&pdev->dev, \"clk_sfc\");\n\tif (IS_ERR(sfc->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get sfc interface clk\\n\");\n\t\treturn PTR_ERR(sfc->clk);\n\t}\n\n\tsfc->hclk = devm_clk_get(&pdev->dev, \"hclk_sfc\");\n\tif (IS_ERR(sfc->hclk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get sfc ahb clk\\n\");\n\t\treturn PTR_ERR(sfc->hclk);\n\t}\n\n\tsfc->use_dma = !of_property_read_bool(sfc->dev->of_node,\n\t\t\t\t\t      \"rockchip,sfc-no-dma\");\n\n\tif (sfc->use_dma) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Unable to set dma mask\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsfc->buffer = dmam_alloc_coherent(dev, SFC_MAX_IOSIZE_VER3,\n\t\t\t\t\t\t  &sfc->dma_buffer,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!sfc->buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = clk_prepare_enable(sfc->hclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to enable ahb clk\\n\");\n\t\tgoto err_hclk;\n\t}\n\n\tret = clk_prepare_enable(sfc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to enable interface clk\\n\");\n\t\tgoto err_clk;\n\t}\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_irq;\n\n\tret = devm_request_irq(dev, ret, rockchip_sfc_irq_handler,\n\t\t\t       0, pdev->name, sfc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request irq\\n\");\n\n\t\tgoto err_irq;\n\t}\n\n\tret = rockchip_sfc_init(sfc);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tsfc->max_iosize = rockchip_sfc_get_max_iosize(sfc);\n\tsfc->version = rockchip_sfc_get_version(sfc);\n\n\tret = spi_register_controller(host);\n\tif (ret)\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\tclk_disable_unprepare(sfc->clk);\nerr_clk:\n\tclk_disable_unprepare(sfc->hclk);\nerr_hclk:\n\treturn ret;\n}\n\nstatic void rockchip_sfc_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct rockchip_sfc *sfc = platform_get_drvdata(pdev);\n\n\tspi_unregister_controller(host);\n\n\tclk_disable_unprepare(sfc->clk);\n\tclk_disable_unprepare(sfc->hclk);\n}\n\nstatic const struct of_device_id rockchip_sfc_dt_ids[] = {\n\t{ .compatible = \"rockchip,sfc\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rockchip_sfc_dt_ids);\n\nstatic struct platform_driver rockchip_sfc_driver = {\n\t.driver = {\n\t\t.name\t= \"rockchip-sfc\",\n\t\t.of_match_table = rockchip_sfc_dt_ids,\n\t},\n\t.probe\t= rockchip_sfc_probe,\n\t.remove_new = rockchip_sfc_remove,\n};\nmodule_platform_driver(rockchip_sfc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Rockchip Serial Flash Controller Driver\");\nMODULE_AUTHOR(\"Shawn Lin <shawn.lin@rock-chips.com>\");\nMODULE_AUTHOR(\"Chris Morgan <macromorgan@hotmail.com>\");\nMODULE_AUTHOR(\"Jon Lin <Jon.lin@rock-chips.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}