{
  "module_name": "spi-sn-f-ospi.c",
  "hash_id": "b9ef39a1c0f03c368415d4addf9b9fbb7db479360e2a315dc5e4cf00e3ee006f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sn-f-ospi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n \n#define OSPI_PROT_CTL_INDIR\t\t\t0x00\n#define   OSPI_PROT_MODE_DATA_MASK\t\tGENMASK(31, 30)\n#define   OSPI_PROT_MODE_ALT_MASK\t\tGENMASK(29, 28)\n#define   OSPI_PROT_MODE_ADDR_MASK\t\tGENMASK(27, 26)\n#define   OSPI_PROT_MODE_CODE_MASK\t\tGENMASK(25, 24)\n#define     OSPI_PROT_MODE_SINGLE\t\t0\n#define     OSPI_PROT_MODE_DUAL\t\t\t1\n#define     OSPI_PROT_MODE_QUAD\t\t\t2\n#define     OSPI_PROT_MODE_OCTAL\t\t3\n#define   OSPI_PROT_DATA_RATE_DATA\t\tBIT(23)\n#define   OSPI_PROT_DATA_RATE_ALT\t\tBIT(22)\n#define   OSPI_PROT_DATA_RATE_ADDR\t\tBIT(21)\n#define   OSPI_PROT_DATA_RATE_CODE\t\tBIT(20)\n#define     OSPI_PROT_SDR\t\t\t0\n#define     OSPI_PROT_DDR\t\t\t1\n#define   OSPI_PROT_BIT_POS_DATA\t\tBIT(19)\n#define   OSPI_PROT_BIT_POS_ALT\t\t\tBIT(18)\n#define   OSPI_PROT_BIT_POS_ADDR\t\tBIT(17)\n#define   OSPI_PROT_BIT_POS_CODE\t\tBIT(16)\n#define   OSPI_PROT_SAMP_EDGE\t\t\tBIT(12)\n#define   OSPI_PROT_DATA_UNIT_MASK\t\tGENMASK(11, 10)\n#define     OSPI_PROT_DATA_UNIT_1B\t\t0\n#define     OSPI_PROT_DATA_UNIT_2B\t\t1\n#define     OSPI_PROT_DATA_UNIT_4B\t\t3\n#define   OSPI_PROT_TRANS_DIR_WRITE\t\tBIT(9)\n#define   OSPI_PROT_DATA_EN\t\t\tBIT(8)\n#define   OSPI_PROT_ALT_SIZE_MASK\t\tGENMASK(7, 5)\n#define   OSPI_PROT_ADDR_SIZE_MASK\t\tGENMASK(4, 2)\n#define   OSPI_PROT_CODE_SIZE_MASK\t\tGENMASK(1, 0)\n\n#define OSPI_CLK_CTL\t\t\t\t0x10\n#define   OSPI_CLK_CTL_BOOT_INT_CLK_EN\t\tBIT(16)\n#define   OSPI_CLK_CTL_PHA\t\t\tBIT(12)\n#define     OSPI_CLK_CTL_PHA_180\t\t0\n#define     OSPI_CLK_CTL_PHA_90\t\t\t1\n#define   OSPI_CLK_CTL_DIV\t\t\tGENMASK(9, 8)\n#define     OSPI_CLK_CTL_DIV_1\t\t\t0\n#define     OSPI_CLK_CTL_DIV_2\t\t\t1\n#define     OSPI_CLK_CTL_DIV_4\t\t\t2\n#define     OSPI_CLK_CTL_DIV_8\t\t\t3\n#define   OSPI_CLK_CTL_INT_CLK_EN\t\tBIT(0)\n\n#define OSPI_CS_CTL1\t\t\t\t0x14\n#define OSPI_CS_CTL2\t\t\t\t0x18\n#define OSPI_SSEL\t\t\t\t0x20\n#define OSPI_CMD_IDX_INDIR\t\t\t0x40\n#define OSPI_ADDR\t\t\t\t0x50\n#define OSPI_ALT_INDIR\t\t\t\t0x60\n#define OSPI_DMY_INDIR\t\t\t\t0x70\n#define OSPI_DAT\t\t\t\t0x80\n#define OSPI_DAT_SWP_INDIR\t\t\t0x90\n\n#define OSPI_DAT_SIZE_INDIR\t\t\t0xA0\n#define   OSPI_DAT_SIZE_EN\t\t\tBIT(15)\n#define   OSPI_DAT_SIZE_MASK\t\t\tGENMASK(10, 0)\n#define   OSPI_DAT_SIZE_MAX\t\t\t(OSPI_DAT_SIZE_MASK + 1)\n\n#define OSPI_TRANS_CTL\t\t\t\t0xC0\n#define   OSPI_TRANS_CTL_STOP_REQ\t\tBIT(1)\t \n#define   OSPI_TRANS_CTL_START_REQ\t\tBIT(0)\t \n\n#define OSPI_ACC_MODE\t\t\t\t0xC4\n#define   OSPI_ACC_MODE_BOOT_DISABLE\t\tBIT(0)\n\n#define OSPI_SWRST\t\t\t\t0xD0\n#define   OSPI_SWRST_INDIR_WRITE_FIFO\t\tBIT(9)\t \n#define   OSPI_SWRST_INDIR_READ_FIFO\t\tBIT(8)\t \n\n#define OSPI_STAT\t\t\t\t0xE0\n#define   OSPI_STAT_IS_AXI_WRITING\t\tBIT(10)\n#define   OSPI_STAT_IS_AXI_READING\t\tBIT(9)\n#define   OSPI_STAT_IS_SPI_INT_CLK_STOP\t\tBIT(4)\n#define   OSPI_STAT_IS_SPI_IDLE\t\t\tBIT(3)\n\n#define OSPI_IRQ\t\t\t\t0xF0\n#define   OSPI_IRQ_CS_DEASSERT\t\t\tBIT(8)\n#define   OSPI_IRQ_WRITE_BUF_READY\t\tBIT(2)\n#define   OSPI_IRQ_READ_BUF_READY\t\tBIT(1)\n#define   OSPI_IRQ_CS_TRANS_COMP\t\tBIT(0)\n#define   OSPI_IRQ_ALL\t\t\t\t\\\n\t\t(OSPI_IRQ_CS_DEASSERT | OSPI_IRQ_WRITE_BUF_READY \\\n\t\t | OSPI_IRQ_READ_BUF_READY | OSPI_IRQ_CS_TRANS_COMP)\n\n#define OSPI_IRQ_STAT_EN\t\t\t0xF4\n#define OSPI_IRQ_SIG_EN\t\t\t\t0xF8\n\n \n#define OSPI_NUM_CS\t\t\t\t4\n#define OSPI_DUMMY_CYCLE_MAX\t\t\t255\n#define OSPI_WAIT_MAX_MSEC\t\t\t100\n\nstruct f_ospi {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct mutex mlock;\n};\n\nstatic u32 f_ospi_get_dummy_cycle(const struct spi_mem_op *op)\n{\n\treturn (op->dummy.nbytes * 8) / op->dummy.buswidth;\n}\n\nstatic void f_ospi_clear_irq(struct f_ospi *ospi)\n{\n\twritel(OSPI_IRQ_CS_DEASSERT | OSPI_IRQ_CS_TRANS_COMP,\n\t       ospi->base + OSPI_IRQ);\n}\n\nstatic void f_ospi_enable_irq_status(struct f_ospi *ospi, u32 irq_bits)\n{\n\tu32 val;\n\n\tval = readl(ospi->base + OSPI_IRQ_STAT_EN);\n\tval |= irq_bits;\n\twritel(val, ospi->base + OSPI_IRQ_STAT_EN);\n}\n\nstatic void f_ospi_disable_irq_status(struct f_ospi *ospi, u32 irq_bits)\n{\n\tu32 val;\n\n\tval = readl(ospi->base + OSPI_IRQ_STAT_EN);\n\tval &= ~irq_bits;\n\twritel(val, ospi->base + OSPI_IRQ_STAT_EN);\n}\n\nstatic void f_ospi_disable_irq_output(struct f_ospi *ospi, u32 irq_bits)\n{\n\tu32 val;\n\n\tval = readl(ospi->base + OSPI_IRQ_SIG_EN);\n\tval &= ~irq_bits;\n\twritel(val, ospi->base + OSPI_IRQ_SIG_EN);\n}\n\nstatic int f_ospi_prepare_config(struct f_ospi *ospi)\n{\n\tu32 val, stat0, stat1;\n\n\t \n\tval = readl(ospi->base + OSPI_CLK_CTL);\n\tval &= ~(OSPI_CLK_CTL_BOOT_INT_CLK_EN | OSPI_CLK_CTL_INT_CLK_EN);\n\twritel(val, ospi->base + OSPI_CLK_CTL);\n\n\t \n\tstat0 = OSPI_STAT_IS_AXI_WRITING | OSPI_STAT_IS_AXI_READING;\n\tstat1 = OSPI_STAT_IS_SPI_IDLE | OSPI_STAT_IS_SPI_INT_CLK_STOP;\n\n\treturn readl_poll_timeout(ospi->base + OSPI_STAT,\n\t\t\t\t  val, (val & (stat0 | stat1)) == stat1,\n\t\t\t\t  0, OSPI_WAIT_MAX_MSEC);\n}\n\nstatic int f_ospi_unprepare_config(struct f_ospi *ospi)\n{\n\tu32 val;\n\n\t \n\tval = readl(ospi->base + OSPI_CLK_CTL);\n\tval |= OSPI_CLK_CTL_BOOT_INT_CLK_EN | OSPI_CLK_CTL_INT_CLK_EN;\n\twritel(val, ospi->base + OSPI_CLK_CTL);\n\n\t \n\treturn readl_poll_timeout(ospi->base + OSPI_STAT,\n\t\t\t\t  val, !(val & OSPI_STAT_IS_SPI_INT_CLK_STOP),\n\t\t\t\t  0, OSPI_WAIT_MAX_MSEC);\n}\n\nstatic void f_ospi_config_clk(struct f_ospi *ospi, u32 device_hz)\n{\n\tlong rate_hz = clk_get_rate(ospi->clk);\n\tu32 div = DIV_ROUND_UP(rate_hz, device_hz);\n\tu32 div_reg;\n\tu32 val;\n\n\tif (rate_hz < device_hz) {\n\t\tdev_warn(ospi->dev, \"Device frequency too large: %d\\n\",\n\t\t\t device_hz);\n\t\tdiv_reg = OSPI_CLK_CTL_DIV_1;\n\t} else {\n\t\tif (div == 1) {\n\t\t\tdiv_reg = OSPI_CLK_CTL_DIV_1;\n\t\t} else if (div == 2) {\n\t\t\tdiv_reg = OSPI_CLK_CTL_DIV_2;\n\t\t} else if (div <= 4) {\n\t\t\tdiv_reg = OSPI_CLK_CTL_DIV_4;\n\t\t} else if (div <= 8) {\n\t\t\tdiv_reg = OSPI_CLK_CTL_DIV_8;\n\t\t} else {\n\t\t\tdev_warn(ospi->dev, \"Device frequency too small: %d\\n\",\n\t\t\t\t device_hz);\n\t\t\tdiv_reg = OSPI_CLK_CTL_DIV_8;\n\t\t}\n\t}\n\n\t \n\tval = readl(ospi->base + OSPI_CLK_CTL);\n\n\tval &= ~(OSPI_CLK_CTL_PHA | OSPI_CLK_CTL_DIV);\n\tval |= FIELD_PREP(OSPI_CLK_CTL_PHA, OSPI_CLK_CTL_PHA_180)\n\t     | FIELD_PREP(OSPI_CLK_CTL_DIV, div_reg);\n\n\twritel(val, ospi->base + OSPI_CLK_CTL);\n}\n\nstatic void f_ospi_config_dll(struct f_ospi *ospi)\n{\n\t \n}\n\nstatic u8 f_ospi_get_mode(struct f_ospi *ospi, int width, int data_size)\n{\n\tu8 mode = OSPI_PROT_MODE_SINGLE;\n\n\tswitch (width) {\n\tcase 1:\n\t\tmode = OSPI_PROT_MODE_SINGLE;\n\t\tbreak;\n\tcase 2:\n\t\tmode = OSPI_PROT_MODE_DUAL;\n\t\tbreak;\n\tcase 4:\n\t\tmode = OSPI_PROT_MODE_QUAD;\n\t\tbreak;\n\tcase 8:\n\t\tmode = OSPI_PROT_MODE_OCTAL;\n\t\tbreak;\n\tdefault:\n\t\tif (data_size)\n\t\t\tdev_err(ospi->dev, \"Invalid buswidth: %d\\n\", width);\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic void f_ospi_config_indir_protocol(struct f_ospi *ospi,\n\t\t\t\t\t struct spi_mem *mem,\n\t\t\t\t\t const struct spi_mem_op *op)\n{\n\tstruct spi_device *spi = mem->spi;\n\tu8 mode;\n\tu32 prot = 0, val;\n\tint unit;\n\n\t \n\twritel(BIT(spi_get_chipselect(spi, 0)), ospi->base + OSPI_SSEL);\n\n\tmode = f_ospi_get_mode(ospi, op->cmd.buswidth, 1);\n\tprot |= FIELD_PREP(OSPI_PROT_MODE_CODE_MASK, mode);\n\n\tmode = f_ospi_get_mode(ospi, op->addr.buswidth, op->addr.nbytes);\n\tprot |= FIELD_PREP(OSPI_PROT_MODE_ADDR_MASK, mode);\n\n\tmode = f_ospi_get_mode(ospi, op->data.buswidth, op->data.nbytes);\n\tprot |= FIELD_PREP(OSPI_PROT_MODE_DATA_MASK, mode);\n\n\tprot |= FIELD_PREP(OSPI_PROT_DATA_RATE_DATA, OSPI_PROT_SDR);\n\tprot |= FIELD_PREP(OSPI_PROT_DATA_RATE_ALT,  OSPI_PROT_SDR);\n\tprot |= FIELD_PREP(OSPI_PROT_DATA_RATE_ADDR, OSPI_PROT_SDR);\n\tprot |= FIELD_PREP(OSPI_PROT_DATA_RATE_CODE, OSPI_PROT_SDR);\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tprot |= OSPI_PROT_BIT_POS_DATA | OSPI_PROT_BIT_POS_ALT\n\t\t      | OSPI_PROT_BIT_POS_ADDR | OSPI_PROT_BIT_POS_CODE;\n\n\tif (spi->mode & SPI_CPHA)\n\t\tprot |= OSPI_PROT_SAMP_EDGE;\n\n\t \n\tswitch (op->data.nbytes & 0x3) {\n\tcase 0:\n\t\tunit = OSPI_PROT_DATA_UNIT_4B;\n\t\tval = 0;\n\t\tbreak;\n\tcase 2:\n\t\tunit = OSPI_PROT_DATA_UNIT_2B;\n\t\tval = OSPI_DAT_SIZE_EN | (op->data.nbytes - 1);\n\t\tbreak;\n\tdefault:\n\t\tunit = OSPI_PROT_DATA_UNIT_1B;\n\t\tval = OSPI_DAT_SIZE_EN | (op->data.nbytes - 1);\n\t\tbreak;\n\t}\n\tprot |= FIELD_PREP(OSPI_PROT_DATA_UNIT_MASK, unit);\n\n\tswitch (op->data.dir) {\n\tcase SPI_MEM_DATA_IN:\n\t\tprot |= OSPI_PROT_DATA_EN;\n\t\tbreak;\n\n\tcase SPI_MEM_DATA_OUT:\n\t\tprot |= OSPI_PROT_TRANS_DIR_WRITE | OSPI_PROT_DATA_EN;\n\t\tbreak;\n\n\tcase SPI_MEM_NO_DATA:\n\t\tprot |= OSPI_PROT_TRANS_DIR_WRITE;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(ospi->dev, \"Unsupported direction\");\n\t\tbreak;\n\t}\n\n\tprot |= FIELD_PREP(OSPI_PROT_ADDR_SIZE_MASK, op->addr.nbytes);\n\tprot |= FIELD_PREP(OSPI_PROT_CODE_SIZE_MASK, 1);\t \n\n\twritel(prot, ospi->base + OSPI_PROT_CTL_INDIR);\n\twritel(val, ospi->base + OSPI_DAT_SIZE_INDIR);\n}\n\nstatic int f_ospi_indir_prepare_op(struct f_ospi *ospi, struct spi_mem *mem,\n\t\t\t\t   const struct spi_mem_op *op)\n{\n\tstruct spi_device *spi = mem->spi;\n\tu32 irq_stat_en;\n\tint ret;\n\n\tret = f_ospi_prepare_config(ospi);\n\tif (ret)\n\t\treturn ret;\n\n\tf_ospi_config_clk(ospi, spi->max_speed_hz);\n\n\tf_ospi_config_indir_protocol(ospi, mem, op);\n\n\twritel(f_ospi_get_dummy_cycle(op), ospi->base + OSPI_DMY_INDIR);\n\twritel(op->addr.val, ospi->base + OSPI_ADDR);\n\twritel(op->cmd.opcode, ospi->base + OSPI_CMD_IDX_INDIR);\n\n\tf_ospi_clear_irq(ospi);\n\n\tswitch (op->data.dir) {\n\tcase SPI_MEM_DATA_IN:\n\t\tirq_stat_en = OSPI_IRQ_READ_BUF_READY | OSPI_IRQ_CS_TRANS_COMP;\n\t\tbreak;\n\n\tcase SPI_MEM_DATA_OUT:\n\t\tirq_stat_en = OSPI_IRQ_WRITE_BUF_READY | OSPI_IRQ_CS_TRANS_COMP;\n\t\tbreak;\n\n\tcase SPI_MEM_NO_DATA:\n\t\tirq_stat_en = OSPI_IRQ_CS_TRANS_COMP;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(ospi->dev, \"Unsupported direction\");\n\t\tirq_stat_en = 0;\n\t}\n\n\tf_ospi_disable_irq_status(ospi, ~irq_stat_en);\n\tf_ospi_enable_irq_status(ospi, irq_stat_en);\n\n\treturn f_ospi_unprepare_config(ospi);\n}\n\nstatic void f_ospi_indir_start_xfer(struct f_ospi *ospi)\n{\n\t \n\twritel(OSPI_TRANS_CTL_START_REQ, ospi->base + OSPI_TRANS_CTL);\n}\n\nstatic void f_ospi_indir_stop_xfer(struct f_ospi *ospi)\n{\n\t \n\twritel(OSPI_TRANS_CTL_STOP_REQ, ospi->base + OSPI_TRANS_CTL);\n}\n\nstatic int f_ospi_indir_wait_xfer_complete(struct f_ospi *ospi)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(ospi->base + OSPI_IRQ, val,\n\t\t\t\t  val & OSPI_IRQ_CS_TRANS_COMP,\n\t\t\t\t  0, OSPI_WAIT_MAX_MSEC);\n}\n\nstatic int f_ospi_indir_read(struct f_ospi *ospi, struct spi_mem *mem,\n\t\t\t     const struct spi_mem_op *op)\n{\n\tu8 *buf = op->data.buf.in;\n\tu32 val;\n\tint i, ret;\n\n\tmutex_lock(&ospi->mlock);\n\n\t \n\tret = f_ospi_indir_prepare_op(ospi, mem, op);\n\tif (ret)\n\t\tgoto out;\n\n\tf_ospi_indir_start_xfer(ospi);\n\n\t \n\tfor (i = 0; i < op->data.nbytes; i++) {\n\t\tret = readl_poll_timeout(ospi->base + OSPI_IRQ, val,\n\t\t\t\t\t val & OSPI_IRQ_READ_BUF_READY,\n\t\t\t\t\t 0, OSPI_WAIT_MAX_MSEC);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbuf[i] = readl(ospi->base + OSPI_DAT) & 0xFF;\n\t}\n\n\t \n\tif (!(readl(ospi->base + OSPI_DAT_SIZE_INDIR) & OSPI_DAT_SIZE_EN))\n\t\tf_ospi_indir_stop_xfer(ospi);\n\n\t \n\tret = f_ospi_indir_wait_xfer_complete(ospi);\n\tif (ret)\n\t\tgoto out;\n\n\twritel(OSPI_IRQ_CS_TRANS_COMP, ospi->base + OSPI_IRQ);\n\n\t \n\tif (readl(ospi->base + OSPI_DAT_SIZE_INDIR) & OSPI_DAT_SIZE_EN)\n\t\tgoto out;\n\n\t \n\twritel(OSPI_SWRST_INDIR_READ_FIFO, ospi->base + OSPI_SWRST);\n\n\tret = readl_poll_timeout(ospi->base + OSPI_SWRST, val,\n\t\t\t\t !(val & OSPI_SWRST_INDIR_READ_FIFO),\n\t\t\t\t 0, OSPI_WAIT_MAX_MSEC);\nout:\n\tmutex_unlock(&ospi->mlock);\n\n\treturn ret;\n}\n\nstatic int f_ospi_indir_write(struct f_ospi *ospi, struct spi_mem *mem,\n\t\t\t      const struct spi_mem_op *op)\n{\n\tu8 *buf = (u8 *)op->data.buf.out;\n\tu32 val;\n\tint i, ret;\n\n\tmutex_lock(&ospi->mlock);\n\n\t \n\tret = f_ospi_indir_prepare_op(ospi, mem, op);\n\tif (ret)\n\t\tgoto out;\n\n\tf_ospi_indir_start_xfer(ospi);\n\n\tif (!(readl(ospi->base + OSPI_PROT_CTL_INDIR) & OSPI_PROT_DATA_EN))\n\t\tgoto nodata;\n\n\t \n\tfor (i = 0; i < op->data.nbytes; i++) {\n\t\tret = readl_poll_timeout(ospi->base + OSPI_IRQ, val,\n\t\t\t\t\t val & OSPI_IRQ_WRITE_BUF_READY,\n\t\t\t\t\t 0, OSPI_WAIT_MAX_MSEC);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\twritel(buf[i], ospi->base + OSPI_DAT);\n\t}\n\n\t \n\tif (!(readl(ospi->base + OSPI_DAT_SIZE_INDIR) & OSPI_DAT_SIZE_EN))\n\t\tf_ospi_indir_stop_xfer(ospi);\n\nnodata:\n\t \n\tret = f_ospi_indir_wait_xfer_complete(ospi);\n\tif (ret)\n\t\tgoto out;\n\n\twritel(OSPI_IRQ_CS_TRANS_COMP, ospi->base + OSPI_IRQ);\nout:\n\tmutex_unlock(&ospi->mlock);\n\n\treturn ret;\n}\n\nstatic int f_ospi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct f_ospi *ospi = spi_controller_get_devdata(mem->spi->controller);\n\tint err = 0;\n\n\tswitch (op->data.dir) {\n\tcase SPI_MEM_DATA_IN:\n\t\terr = f_ospi_indir_read(ospi, mem, op);\n\t\tbreak;\n\n\tcase SPI_MEM_DATA_OUT:\n\t\tfallthrough;\n\tcase SPI_MEM_NO_DATA:\n\t\terr = f_ospi_indir_write(ospi, mem, op);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(ospi->dev, \"Unsupported direction\");\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic bool f_ospi_supports_op_width(struct spi_mem *mem,\n\t\t\t\t     const struct spi_mem_op *op)\n{\n\tstatic const u8 width_available[] = { 0, 1, 2, 4, 8 };\n\tu8 width_op[] = { op->cmd.buswidth, op->addr.buswidth,\n\t\t\t  op->dummy.buswidth, op->data.buswidth };\n\tbool is_match_found;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(width_op); i++) {\n\t\tis_match_found = false;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(width_available); j++) {\n\t\t\tif (width_op[i] == width_available[j]) {\n\t\t\t\tis_match_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_match_found)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool f_ospi_supports_op(struct spi_mem *mem,\n\t\t\t       const struct spi_mem_op *op)\n{\n\tif (f_ospi_get_dummy_cycle(op) > OSPI_DUMMY_CYCLE_MAX)\n\t\treturn false;\n\n\tif (op->addr.nbytes > 4)\n\t\treturn false;\n\n\tif (!f_ospi_supports_op_width(mem, op))\n\t\treturn false;\n\n\treturn spi_mem_default_supports_op(mem, op);\n}\n\nstatic int f_ospi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)\n{\n\top->data.nbytes = min_t(int, op->data.nbytes, OSPI_DAT_SIZE_MAX);\n\n\treturn 0;\n}\n\nstatic const struct spi_controller_mem_ops f_ospi_mem_ops = {\n\t.adjust_op_size = f_ospi_adjust_op_size,\n\t.supports_op = f_ospi_supports_op,\n\t.exec_op = f_ospi_exec_op,\n};\n\nstatic int f_ospi_init(struct f_ospi *ospi)\n{\n\tint ret;\n\n\tret = f_ospi_prepare_config(ospi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(OSPI_ACC_MODE_BOOT_DISABLE, ospi->base + OSPI_ACC_MODE);\n\n\tf_ospi_config_dll(ospi);\n\n\t \n\tf_ospi_clear_irq(ospi);\n\tf_ospi_disable_irq_status(ospi, OSPI_IRQ_ALL);\n\tf_ospi_disable_irq_output(ospi, OSPI_IRQ_ALL);\n\n\treturn f_ospi_unprepare_config(ospi);\n}\n\nstatic int f_ospi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tstruct device *dev = &pdev->dev;\n\tstruct f_ospi *ospi;\n\tu32 num_cs = OSPI_NUM_CS;\n\tint ret;\n\n\tctlr = spi_alloc_host(dev, sizeof(*ospi));\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tctlr->mode_bits = SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL\n\t\t| SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL\n\t\t| SPI_MODE_0 | SPI_MODE_1 | SPI_LSB_FIRST;\n\tctlr->mem_ops = &f_ospi_mem_ops;\n\tctlr->bus_num = -1;\n\tof_property_read_u32(dev->of_node, \"num-cs\", &num_cs);\n\tif (num_cs > OSPI_NUM_CS) {\n\t\tdev_err(dev, \"num-cs too large: %d\\n\", num_cs);\n\t\treturn -ENOMEM;\n\t}\n\tctlr->num_chipselect = num_cs;\n\tctlr->dev.of_node = dev->of_node;\n\n\tospi = spi_controller_get_devdata(ctlr);\n\tospi->dev = dev;\n\n\tplatform_set_drvdata(pdev, ospi);\n\n\tospi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ospi->base)) {\n\t\tret = PTR_ERR(ospi->base);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tospi->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(ospi->clk)) {\n\t\tret = PTR_ERR(ospi->clk);\n\t\tgoto err_put_ctlr;\n\t}\n\n\tmutex_init(&ospi->mlock);\n\n\tret = f_ospi_init(ospi);\n\tif (ret)\n\t\tgoto err_destroy_mutex;\n\n\tret = devm_spi_register_controller(dev, ctlr);\n\tif (ret)\n\t\tgoto err_destroy_mutex;\n\n\treturn 0;\n\nerr_destroy_mutex:\n\tmutex_destroy(&ospi->mlock);\n\nerr_put_ctlr:\n\tspi_controller_put(ctlr);\n\n\treturn ret;\n}\n\nstatic void f_ospi_remove(struct platform_device *pdev)\n{\n\tstruct f_ospi *ospi = platform_get_drvdata(pdev);\n\n\tmutex_destroy(&ospi->mlock);\n}\n\nstatic const struct of_device_id f_ospi_dt_ids[] = {\n\t{ .compatible = \"socionext,f-ospi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, f_ospi_dt_ids);\n\nstatic struct platform_driver f_ospi_driver = {\n\t.driver = {\n\t\t.name = \"socionext,f-ospi\",\n\t\t.of_match_table = f_ospi_dt_ids,\n\t},\n\t.probe = f_ospi_probe,\n\t.remove_new = f_ospi_remove,\n};\nmodule_platform_driver(f_ospi_driver);\n\nMODULE_DESCRIPTION(\"Socionext F_OSPI controller driver\");\nMODULE_AUTHOR(\"Socionext Inc.\");\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}