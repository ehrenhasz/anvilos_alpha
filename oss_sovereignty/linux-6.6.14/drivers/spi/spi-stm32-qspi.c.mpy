{
  "module_name": "spi-stm32-qspi.c",
  "hash_id": "92dd1016b9beac1445953580878ae7a2312338eef61e9b8295e40548def668fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-stm32-qspi.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n#include <linux/spi/spi-mem.h>\n\n#define QSPI_CR\t\t\t0x00\n#define CR_EN\t\t\tBIT(0)\n#define CR_ABORT\t\tBIT(1)\n#define CR_DMAEN\t\tBIT(2)\n#define CR_TCEN\t\t\tBIT(3)\n#define CR_SSHIFT\t\tBIT(4)\n#define CR_DFM\t\t\tBIT(6)\n#define CR_FSEL\t\t\tBIT(7)\n#define CR_FTHRES_SHIFT\t\t8\n#define CR_TEIE\t\t\tBIT(16)\n#define CR_TCIE\t\t\tBIT(17)\n#define CR_FTIE\t\t\tBIT(18)\n#define CR_SMIE\t\t\tBIT(19)\n#define CR_TOIE\t\t\tBIT(20)\n#define CR_APMS\t\t\tBIT(22)\n#define CR_PRESC_MASK\t\tGENMASK(31, 24)\n\n#define QSPI_DCR\t\t0x04\n#define DCR_FSIZE_MASK\t\tGENMASK(20, 16)\n\n#define QSPI_SR\t\t\t0x08\n#define SR_TEF\t\t\tBIT(0)\n#define SR_TCF\t\t\tBIT(1)\n#define SR_FTF\t\t\tBIT(2)\n#define SR_SMF\t\t\tBIT(3)\n#define SR_TOF\t\t\tBIT(4)\n#define SR_BUSY\t\t\tBIT(5)\n#define SR_FLEVEL_MASK\t\tGENMASK(13, 8)\n\n#define QSPI_FCR\t\t0x0c\n#define FCR_CTEF\t\tBIT(0)\n#define FCR_CTCF\t\tBIT(1)\n#define FCR_CSMF\t\tBIT(3)\n\n#define QSPI_DLR\t\t0x10\n\n#define QSPI_CCR\t\t0x14\n#define CCR_INST_MASK\t\tGENMASK(7, 0)\n#define CCR_IMODE_MASK\t\tGENMASK(9, 8)\n#define CCR_ADMODE_MASK\t\tGENMASK(11, 10)\n#define CCR_ADSIZE_MASK\t\tGENMASK(13, 12)\n#define CCR_DCYC_MASK\t\tGENMASK(22, 18)\n#define CCR_DMODE_MASK\t\tGENMASK(25, 24)\n#define CCR_FMODE_MASK\t\tGENMASK(27, 26)\n#define CCR_FMODE_INDW\t\t(0U << 26)\n#define CCR_FMODE_INDR\t\t(1U << 26)\n#define CCR_FMODE_APM\t\t(2U << 26)\n#define CCR_FMODE_MM\t\t(3U << 26)\n#define CCR_BUSWIDTH_0\t\t0x0\n#define CCR_BUSWIDTH_1\t\t0x1\n#define CCR_BUSWIDTH_2\t\t0x2\n#define CCR_BUSWIDTH_4\t\t0x3\n\n#define QSPI_AR\t\t\t0x18\n#define QSPI_ABR\t\t0x1c\n#define QSPI_DR\t\t\t0x20\n#define QSPI_PSMKR\t\t0x24\n#define QSPI_PSMAR\t\t0x28\n#define QSPI_PIR\t\t0x2c\n#define QSPI_LPTR\t\t0x30\n\n#define STM32_QSPI_MAX_MMAP_SZ\tSZ_256M\n#define STM32_QSPI_MAX_NORCHIP\t2\n\n#define STM32_FIFO_TIMEOUT_US 30000\n#define STM32_BUSY_TIMEOUT_US 100000\n#define STM32_ABT_TIMEOUT_US 100000\n#define STM32_COMP_TIMEOUT_MS 1000\n#define STM32_AUTOSUSPEND_DELAY -1\n\nstruct stm32_qspi_flash {\n\tu32 cs;\n\tu32 presc;\n};\n\nstruct stm32_qspi {\n\tstruct device *dev;\n\tstruct spi_controller *ctrl;\n\tphys_addr_t phys_base;\n\tvoid __iomem *io_base;\n\tvoid __iomem *mm_base;\n\tresource_size_t mm_size;\n\tstruct clk *clk;\n\tu32 clk_rate;\n\tstruct stm32_qspi_flash flash[STM32_QSPI_MAX_NORCHIP];\n\tstruct completion data_completion;\n\tstruct completion match_completion;\n\tu32 fmode;\n\n\tstruct dma_chan *dma_chtx;\n\tstruct dma_chan *dma_chrx;\n\tstruct completion dma_completion;\n\n\tu32 cr_reg;\n\tu32 dcr_reg;\n\tunsigned long status_timeout;\n\n\t \n\tstruct mutex lock;\n};\n\nstatic irqreturn_t stm32_qspi_irq(int irq, void *dev_id)\n{\n\tstruct stm32_qspi *qspi = (struct stm32_qspi *)dev_id;\n\tu32 cr, sr;\n\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR);\n\tsr = readl_relaxed(qspi->io_base + QSPI_SR);\n\n\tif (cr & CR_SMIE && sr & SR_SMF) {\n\t\t \n\t\tcr &= ~CR_SMIE;\n\t\twritel_relaxed(cr, qspi->io_base + QSPI_CR);\n\t\tcomplete(&qspi->match_completion);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (sr & (SR_TEF | SR_TCF)) {\n\t\t \n\t\tcr &= ~CR_TCIE & ~CR_TEIE;\n\t\twritel_relaxed(cr, qspi->io_base + QSPI_CR);\n\t\tcomplete(&qspi->data_completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stm32_qspi_read_fifo(u8 *val, void __iomem *addr)\n{\n\t*val = readb_relaxed(addr);\n}\n\nstatic void stm32_qspi_write_fifo(u8 *val, void __iomem *addr)\n{\n\twriteb_relaxed(*val, addr);\n}\n\nstatic int stm32_qspi_tx_poll(struct stm32_qspi *qspi,\n\t\t\t      const struct spi_mem_op *op)\n{\n\tvoid (*tx_fifo)(u8 *val, void __iomem *addr);\n\tu32 len = op->data.nbytes, sr;\n\tu8 *buf;\n\tint ret;\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\ttx_fifo = stm32_qspi_read_fifo;\n\t\tbuf = op->data.buf.in;\n\n\t} else {\n\t\ttx_fifo = stm32_qspi_write_fifo;\n\t\tbuf = (u8 *)op->data.buf.out;\n\t}\n\n\twhile (len--) {\n\t\tret = readl_relaxed_poll_timeout_atomic(qspi->io_base + QSPI_SR,\n\t\t\t\t\t\t\tsr, (sr & SR_FTF), 1,\n\t\t\t\t\t\t\tSTM32_FIFO_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qspi->dev, \"fifo timeout (len:%d stat:%#x)\\n\",\n\t\t\t\tlen, sr);\n\t\t\treturn ret;\n\t\t}\n\t\ttx_fifo(buf++, qspi->io_base + QSPI_DR);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_qspi_tx_mm(struct stm32_qspi *qspi,\n\t\t\t    const struct spi_mem_op *op)\n{\n\tmemcpy_fromio(op->data.buf.in, qspi->mm_base + op->addr.val,\n\t\t      op->data.nbytes);\n\treturn 0;\n}\n\nstatic void stm32_qspi_dma_callback(void *arg)\n{\n\tstruct completion *dma_completion = arg;\n\n\tcomplete(dma_completion);\n}\n\nstatic int stm32_qspi_tx_dma(struct stm32_qspi *qspi,\n\t\t\t     const struct spi_mem_op *op)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tenum dma_transfer_direction dma_dir;\n\tstruct dma_chan *dma_ch;\n\tstruct sg_table sgt;\n\tdma_cookie_t cookie;\n\tu32 cr, t_out;\n\tint err;\n\n\tif (op->data.dir == SPI_MEM_DATA_IN) {\n\t\tdma_dir = DMA_DEV_TO_MEM;\n\t\tdma_ch = qspi->dma_chrx;\n\t} else {\n\t\tdma_dir = DMA_MEM_TO_DEV;\n\t\tdma_ch = qspi->dma_chtx;\n\t}\n\n\t \n\terr = spi_controller_dma_map_mem_op_data(qspi->ctrl, op, &sgt);\n\tif (err)\n\t\treturn err;\n\n\tdesc = dmaengine_prep_slave_sg(dma_ch, sgt.sgl, sgt.nents,\n\t\t\t\t       dma_dir, DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR);\n\n\treinit_completion(&qspi->dma_completion);\n\tdesc->callback = stm32_qspi_dma_callback;\n\tdesc->callback_param = &qspi->dma_completion;\n\tcookie = dmaengine_submit(desc);\n\terr = dma_submit_error(cookie);\n\tif (err)\n\t\tgoto out;\n\n\tdma_async_issue_pending(dma_ch);\n\n\twritel_relaxed(cr | CR_DMAEN, qspi->io_base + QSPI_CR);\n\n\tt_out = sgt.nents * STM32_COMP_TIMEOUT_MS;\n\tif (!wait_for_completion_timeout(&qspi->dma_completion,\n\t\t\t\t\t msecs_to_jiffies(t_out)))\n\t\terr = -ETIMEDOUT;\n\n\tif (err)\n\t\tdmaengine_terminate_all(dma_ch);\n\nout:\n\twritel_relaxed(cr & ~CR_DMAEN, qspi->io_base + QSPI_CR);\nout_unmap:\n\tspi_controller_dma_unmap_mem_op_data(qspi->ctrl, op, &sgt);\n\n\treturn err;\n}\n\nstatic int stm32_qspi_tx(struct stm32_qspi *qspi, const struct spi_mem_op *op)\n{\n\tif (!op->data.nbytes)\n\t\treturn 0;\n\n\tif (qspi->fmode == CCR_FMODE_MM)\n\t\treturn stm32_qspi_tx_mm(qspi, op);\n\telse if (((op->data.dir == SPI_MEM_DATA_IN && qspi->dma_chrx) ||\n\t\t (op->data.dir == SPI_MEM_DATA_OUT && qspi->dma_chtx)) &&\n\t\t  op->data.nbytes > 4)\n\t\tif (!stm32_qspi_tx_dma(qspi, op))\n\t\t\treturn 0;\n\n\treturn stm32_qspi_tx_poll(qspi, op);\n}\n\nstatic int stm32_qspi_wait_nobusy(struct stm32_qspi *qspi)\n{\n\tu32 sr;\n\n\treturn readl_relaxed_poll_timeout_atomic(qspi->io_base + QSPI_SR, sr,\n\t\t\t\t\t\t !(sr & SR_BUSY), 1,\n\t\t\t\t\t\t STM32_BUSY_TIMEOUT_US);\n}\n\nstatic int stm32_qspi_wait_cmd(struct stm32_qspi *qspi)\n{\n\tu32 cr, sr;\n\tint err = 0;\n\n\tif ((readl_relaxed(qspi->io_base + QSPI_SR) & SR_TCF) ||\n\t    qspi->fmode == CCR_FMODE_APM)\n\t\tgoto out;\n\n\treinit_completion(&qspi->data_completion);\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR);\n\twritel_relaxed(cr | CR_TCIE | CR_TEIE, qspi->io_base + QSPI_CR);\n\n\tif (!wait_for_completion_timeout(&qspi->data_completion,\n\t\t\t\tmsecs_to_jiffies(STM32_COMP_TIMEOUT_MS))) {\n\t\terr = -ETIMEDOUT;\n\t} else {\n\t\tsr = readl_relaxed(qspi->io_base + QSPI_SR);\n\t\tif (sr & SR_TEF)\n\t\t\terr = -EIO;\n\t}\n\nout:\n\t \n\twritel_relaxed(FCR_CTCF | FCR_CTEF, qspi->io_base + QSPI_FCR);\n\tif (!err)\n\t\terr = stm32_qspi_wait_nobusy(qspi);\n\n\treturn err;\n}\n\nstatic int stm32_qspi_wait_poll_status(struct stm32_qspi *qspi)\n{\n\tu32 cr;\n\n\treinit_completion(&qspi->match_completion);\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR);\n\twritel_relaxed(cr | CR_SMIE, qspi->io_base + QSPI_CR);\n\n\tif (!wait_for_completion_timeout(&qspi->match_completion,\n\t\t\t\tmsecs_to_jiffies(qspi->status_timeout)))\n\t\treturn -ETIMEDOUT;\n\n\twritel_relaxed(FCR_CSMF, qspi->io_base + QSPI_FCR);\n\n\treturn 0;\n}\n\nstatic int stm32_qspi_get_mode(u8 buswidth)\n{\n\tif (buswidth == 4)\n\t\treturn CCR_BUSWIDTH_4;\n\n\treturn buswidth;\n}\n\nstatic int stm32_qspi_send(struct spi_device *spi, const struct spi_mem_op *op)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(spi->master);\n\tstruct stm32_qspi_flash *flash = &qspi->flash[spi_get_chipselect(spi, 0)];\n\tu32 ccr, cr;\n\tint timeout, err = 0, err_poll_status = 0;\n\n\tdev_dbg(qspi->dev, \"cmd:%#x mode:%d.%d.%d.%d addr:%#llx len:%#x\\n\",\n\t\top->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,\n\t\top->dummy.buswidth, op->data.buswidth,\n\t\top->addr.val, op->data.nbytes);\n\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR);\n\tcr &= ~CR_PRESC_MASK & ~CR_FSEL;\n\tcr |= FIELD_PREP(CR_PRESC_MASK, flash->presc);\n\tcr |= FIELD_PREP(CR_FSEL, flash->cs);\n\twritel_relaxed(cr, qspi->io_base + QSPI_CR);\n\n\tif (op->data.nbytes)\n\t\twritel_relaxed(op->data.nbytes - 1,\n\t\t\t       qspi->io_base + QSPI_DLR);\n\n\tccr = qspi->fmode;\n\tccr |= FIELD_PREP(CCR_INST_MASK, op->cmd.opcode);\n\tccr |= FIELD_PREP(CCR_IMODE_MASK,\n\t\t\t  stm32_qspi_get_mode(op->cmd.buswidth));\n\n\tif (op->addr.nbytes) {\n\t\tccr |= FIELD_PREP(CCR_ADMODE_MASK,\n\t\t\t\t  stm32_qspi_get_mode(op->addr.buswidth));\n\t\tccr |= FIELD_PREP(CCR_ADSIZE_MASK, op->addr.nbytes - 1);\n\t}\n\n\tif (op->dummy.nbytes)\n\t\tccr |= FIELD_PREP(CCR_DCYC_MASK,\n\t\t\t\t  op->dummy.nbytes * 8 / op->dummy.buswidth);\n\n\tif (op->data.nbytes) {\n\t\tccr |= FIELD_PREP(CCR_DMODE_MASK,\n\t\t\t\t  stm32_qspi_get_mode(op->data.buswidth));\n\t}\n\n\twritel_relaxed(ccr, qspi->io_base + QSPI_CCR);\n\n\tif (op->addr.nbytes && qspi->fmode != CCR_FMODE_MM)\n\t\twritel_relaxed(op->addr.val, qspi->io_base + QSPI_AR);\n\n\tif (qspi->fmode == CCR_FMODE_APM)\n\t\terr_poll_status = stm32_qspi_wait_poll_status(qspi);\n\n\terr = stm32_qspi_tx(qspi, op);\n\n\t \n\tif (err || err_poll_status || qspi->fmode == CCR_FMODE_MM)\n\t\tgoto abort;\n\n\t \n\terr = stm32_qspi_wait_cmd(qspi);\n\tif (err)\n\t\tgoto abort;\n\n\treturn 0;\n\nabort:\n\tcr = readl_relaxed(qspi->io_base + QSPI_CR) | CR_ABORT;\n\twritel_relaxed(cr, qspi->io_base + QSPI_CR);\n\n\t \n\ttimeout = readl_relaxed_poll_timeout_atomic(qspi->io_base + QSPI_CR,\n\t\t\t\t\t\t    cr, !(cr & CR_ABORT), 1,\n\t\t\t\t\t\t    STM32_ABT_TIMEOUT_US);\n\n\twritel_relaxed(FCR_CTCF | FCR_CSMF, qspi->io_base + QSPI_FCR);\n\n\tif (err || err_poll_status || timeout)\n\t\tdev_err(qspi->dev, \"%s err:%d err_poll_status:%d abort timeout:%d\\n\",\n\t\t\t__func__, err, err_poll_status, timeout);\n\n\treturn err;\n}\n\nstatic int stm32_qspi_poll_status(struct spi_mem *mem, const struct spi_mem_op *op,\n\t\t\t\t  u16 mask, u16 match,\n\t\t\t\t  unsigned long initial_delay_us,\n\t\t\t\t  unsigned long polling_rate_us,\n\t\t\t\t  unsigned long timeout_ms)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(mem->spi->master);\n\tint ret;\n\n\tif (!spi_mem_supports_op(mem, op))\n\t\treturn -EOPNOTSUPP;\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&qspi->lock);\n\n\twritel_relaxed(mask, qspi->io_base + QSPI_PSMKR);\n\twritel_relaxed(match, qspi->io_base + QSPI_PSMAR);\n\tqspi->fmode = CCR_FMODE_APM;\n\tqspi->status_timeout = timeout_ms;\n\n\tret = stm32_qspi_send(mem->spi, op);\n\tmutex_unlock(&qspi->lock);\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(mem->spi->master);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&qspi->lock);\n\tif (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes)\n\t\tqspi->fmode = CCR_FMODE_INDR;\n\telse\n\t\tqspi->fmode = CCR_FMODE_INDW;\n\n\tret = stm32_qspi_send(mem->spi, op);\n\tmutex_unlock(&qspi->lock);\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_qspi_dirmap_create(struct spi_mem_dirmap_desc *desc)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(desc->mem->spi->master);\n\n\tif (desc->info.op_tmpl.data.dir == SPI_MEM_DATA_OUT)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!qspi->mm_base && desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!qspi->mm_size)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic ssize_t stm32_qspi_dirmap_read(struct spi_mem_dirmap_desc *desc,\n\t\t\t\t      u64 offs, size_t len, void *buf)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(desc->mem->spi->master);\n\tstruct spi_mem_op op;\n\tu32 addr_max;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&qspi->lock);\n\t \n\tmemcpy(&op, &desc->info.op_tmpl, sizeof(struct spi_mem_op));\n\tdev_dbg(qspi->dev, \"%s len = 0x%zx offs = 0x%llx buf = 0x%p\\n\", __func__, len, offs, buf);\n\n\top.data.nbytes = len;\n\top.addr.val = desc->info.offset + offs;\n\top.data.buf.in = buf;\n\n\taddr_max = op.addr.val + op.data.nbytes + 1;\n\tif (addr_max < qspi->mm_size && op.addr.buswidth)\n\t\tqspi->fmode = CCR_FMODE_MM;\n\telse\n\t\tqspi->fmode = CCR_FMODE_INDR;\n\n\tret = stm32_qspi_send(desc->mem->spi, &op);\n\tmutex_unlock(&qspi->lock);\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n\n\treturn ret ?: len;\n}\n\nstatic int stm32_qspi_transfer_one_message(struct spi_controller *ctrl,\n\t\t\t\t\t   struct spi_message *msg)\n{\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(ctrl);\n\tstruct spi_transfer *transfer;\n\tstruct spi_device *spi = msg->spi;\n\tstruct spi_mem_op op;\n\tint ret = 0;\n\n\tif (!spi_get_csgpiod(spi, 0))\n\t\treturn -EOPNOTSUPP;\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&qspi->lock);\n\n\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), true);\n\n\tlist_for_each_entry(transfer, &msg->transfers, transfer_list) {\n\t\tu8 dummy_bytes = 0;\n\n\t\tmemset(&op, 0, sizeof(op));\n\n\t\tdev_dbg(qspi->dev, \"tx_buf:%p tx_nbits:%d rx_buf:%p rx_nbits:%d len:%d dummy_data:%d\\n\",\n\t\t\ttransfer->tx_buf, transfer->tx_nbits,\n\t\t\ttransfer->rx_buf, transfer->rx_nbits,\n\t\t\ttransfer->len, transfer->dummy_data);\n\n\t\t \n\t\tif (transfer->dummy_data) {\n\t\t\top.dummy.buswidth = transfer->tx_nbits;\n\t\t\top.dummy.nbytes = transfer->len;\n\t\t\tdummy_bytes = transfer->len;\n\n\t\t\t \n\t\t\tif (list_is_last(&transfer->transfer_list, &msg->transfers)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto end_of_transfer;\n\t\t\t}\n\n\t\t\ttransfer = list_next_entry(transfer, transfer_list);\n\t\t}\n\n\t\top.data.nbytes = transfer->len;\n\n\t\tif (transfer->rx_buf) {\n\t\t\tqspi->fmode = CCR_FMODE_INDR;\n\t\t\top.data.buswidth = transfer->rx_nbits;\n\t\t\top.data.dir = SPI_MEM_DATA_IN;\n\t\t\top.data.buf.in = transfer->rx_buf;\n\t\t} else {\n\t\t\tqspi->fmode = CCR_FMODE_INDW;\n\t\t\top.data.buswidth = transfer->tx_nbits;\n\t\t\top.data.dir = SPI_MEM_DATA_OUT;\n\t\t\top.data.buf.out = transfer->tx_buf;\n\t\t}\n\n\t\tret = stm32_qspi_send(spi, &op);\n\t\tif (ret)\n\t\t\tgoto end_of_transfer;\n\n\t\tmsg->actual_length += transfer->len + dummy_bytes;\n\t}\n\nend_of_transfer:\n\tgpiod_set_value_cansleep(spi_get_csgpiod(spi, 0), false);\n\n\tmutex_unlock(&qspi->lock);\n\n\tmsg->status = ret;\n\tspi_finalize_current_message(ctrl);\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_qspi_setup(struct spi_device *spi)\n{\n\tstruct spi_controller *ctrl = spi->master;\n\tstruct stm32_qspi *qspi = spi_controller_get_devdata(ctrl);\n\tstruct stm32_qspi_flash *flash;\n\tu32 presc, mode;\n\tint ret;\n\n\tif (ctrl->busy)\n\t\treturn -EBUSY;\n\n\tif (!spi->max_speed_hz)\n\t\treturn -EINVAL;\n\n\tmode = spi->mode & (SPI_TX_OCTAL | SPI_RX_OCTAL);\n\tif ((mode == SPI_TX_OCTAL || mode == SPI_RX_OCTAL) ||\n\t    ((mode == (SPI_TX_OCTAL | SPI_RX_OCTAL)) &&\n\t    gpiod_count(qspi->dev, \"cs\") == -ENOENT)) {\n\t\tdev_err(qspi->dev, \"spi-rx-bus-width\\\\/spi-tx-bus-width\\\\/cs-gpios\\n\");\n\t\tdev_err(qspi->dev, \"configuration not supported\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tret = pm_runtime_resume_and_get(qspi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpresc = DIV_ROUND_UP(qspi->clk_rate, spi->max_speed_hz) - 1;\n\n\tflash = &qspi->flash[spi_get_chipselect(spi, 0)];\n\tflash->cs = spi_get_chipselect(spi, 0);\n\tflash->presc = presc;\n\n\tmutex_lock(&qspi->lock);\n\tqspi->cr_reg = CR_APMS | 3 << CR_FTHRES_SHIFT | CR_SSHIFT | CR_EN;\n\n\t \n\tif (mode == (SPI_TX_OCTAL | SPI_RX_OCTAL)) {\n\t\tqspi->cr_reg |= CR_DFM;\n\t\tdev_dbg(qspi->dev, \"Dual flash mode enable\");\n\t}\n\n\twritel_relaxed(qspi->cr_reg, qspi->io_base + QSPI_CR);\n\n\t \n\tqspi->dcr_reg = DCR_FSIZE_MASK;\n\twritel_relaxed(qspi->dcr_reg, qspi->io_base + QSPI_DCR);\n\tmutex_unlock(&qspi->lock);\n\n\tpm_runtime_mark_last_busy(qspi->dev);\n\tpm_runtime_put_autosuspend(qspi->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_qspi_dma_setup(struct stm32_qspi *qspi)\n{\n\tstruct dma_slave_config dma_cfg;\n\tstruct device *dev = qspi->dev;\n\tint ret = 0;\n\n\tmemset(&dma_cfg, 0, sizeof(dma_cfg));\n\n\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_cfg.src_addr = qspi->phys_base + QSPI_DR;\n\tdma_cfg.dst_addr = qspi->phys_base + QSPI_DR;\n\tdma_cfg.src_maxburst = 4;\n\tdma_cfg.dst_maxburst = 4;\n\n\tqspi->dma_chrx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(qspi->dma_chrx)) {\n\t\tret = PTR_ERR(qspi->dma_chrx);\n\t\tqspi->dma_chrx = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto out;\n\t} else {\n\t\tif (dmaengine_slave_config(qspi->dma_chrx, &dma_cfg)) {\n\t\t\tdev_err(dev, \"dma rx config failed\\n\");\n\t\t\tdma_release_channel(qspi->dma_chrx);\n\t\t\tqspi->dma_chrx = NULL;\n\t\t}\n\t}\n\n\tqspi->dma_chtx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(qspi->dma_chtx)) {\n\t\tret = PTR_ERR(qspi->dma_chtx);\n\t\tqspi->dma_chtx = NULL;\n\t} else {\n\t\tif (dmaengine_slave_config(qspi->dma_chtx, &dma_cfg)) {\n\t\t\tdev_err(dev, \"dma tx config failed\\n\");\n\t\t\tdma_release_channel(qspi->dma_chtx);\n\t\t\tqspi->dma_chtx = NULL;\n\t\t}\n\t}\n\nout:\n\tinit_completion(&qspi->dma_completion);\n\n\tif (ret != -EPROBE_DEFER)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void stm32_qspi_dma_free(struct stm32_qspi *qspi)\n{\n\tif (qspi->dma_chtx)\n\t\tdma_release_channel(qspi->dma_chtx);\n\tif (qspi->dma_chrx)\n\t\tdma_release_channel(qspi->dma_chrx);\n}\n\n \nstatic const struct spi_controller_mem_ops stm32_qspi_mem_ops = {\n\t.exec_op\t= stm32_qspi_exec_op,\n\t.dirmap_create\t= stm32_qspi_dirmap_create,\n\t.dirmap_read\t= stm32_qspi_dirmap_read,\n\t.poll_status\t= stm32_qspi_poll_status,\n};\n\nstatic int stm32_qspi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_controller *ctrl;\n\tstruct reset_control *rstc;\n\tstruct stm32_qspi *qspi;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tctrl = devm_spi_alloc_master(dev, sizeof(*qspi));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tqspi = spi_controller_get_devdata(ctrl);\n\tqspi->ctrl = ctrl;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qspi\");\n\tqspi->io_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(qspi->io_base))\n\t\treturn PTR_ERR(qspi->io_base);\n\n\tqspi->phys_base = res->start;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qspi_mm\");\n\tqspi->mm_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(qspi->mm_base))\n\t\treturn PTR_ERR(qspi->mm_base);\n\n\tqspi->mm_size = resource_size(res);\n\tif (qspi->mm_size > STM32_QSPI_MAX_MMAP_SZ)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, stm32_qspi_irq, 0,\n\t\t\t       dev_name(dev), qspi);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_completion(&qspi->data_completion);\n\tinit_completion(&qspi->match_completion);\n\n\tqspi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(qspi->clk))\n\t\treturn PTR_ERR(qspi->clk);\n\n\tqspi->clk_rate = clk_get_rate(qspi->clk);\n\tif (!qspi->clk_rate)\n\t\treturn -EINVAL;\n\n\tret = clk_prepare_enable(qspi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\trstc = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rstc)) {\n\t\tret = PTR_ERR(rstc);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_clk_disable;\n\t} else {\n\t\treset_control_assert(rstc);\n\t\tudelay(2);\n\t\treset_control_deassert(rstc);\n\t}\n\n\tqspi->dev = dev;\n\tplatform_set_drvdata(pdev, qspi);\n\tret = stm32_qspi_dma_setup(qspi);\n\tif (ret)\n\t\tgoto err_dma_free;\n\n\tmutex_init(&qspi->lock);\n\n\tctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD | SPI_TX_OCTAL\n\t\t| SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_OCTAL;\n\tctrl->setup = stm32_qspi_setup;\n\tctrl->bus_num = -1;\n\tctrl->mem_ops = &stm32_qspi_mem_ops;\n\tctrl->use_gpio_descriptors = true;\n\tctrl->transfer_one_message = stm32_qspi_transfer_one_message;\n\tctrl->num_chipselect = STM32_QSPI_MAX_NORCHIP;\n\tctrl->dev.of_node = dev->of_node;\n\n\tpm_runtime_set_autosuspend_delay(dev, STM32_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_noresume(dev);\n\n\tret = spi_register_master(ctrl);\n\tif (ret)\n\t\tgoto err_pm_runtime_free;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_pm_runtime_free:\n\tpm_runtime_get_sync(qspi->dev);\n\t \n\twritel_relaxed(0, qspi->io_base + QSPI_CR);\n\tmutex_destroy(&qspi->lock);\n\tpm_runtime_put_noidle(qspi->dev);\n\tpm_runtime_disable(qspi->dev);\n\tpm_runtime_set_suspended(qspi->dev);\n\tpm_runtime_dont_use_autosuspend(qspi->dev);\nerr_dma_free:\n\tstm32_qspi_dma_free(qspi);\nerr_clk_disable:\n\tclk_disable_unprepare(qspi->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_qspi_remove(struct platform_device *pdev)\n{\n\tstruct stm32_qspi *qspi = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(qspi->dev);\n\tspi_unregister_master(qspi->ctrl);\n\t \n\twritel_relaxed(0, qspi->io_base + QSPI_CR);\n\tstm32_qspi_dma_free(qspi);\n\tmutex_destroy(&qspi->lock);\n\tpm_runtime_put_noidle(qspi->dev);\n\tpm_runtime_disable(qspi->dev);\n\tpm_runtime_set_suspended(qspi->dev);\n\tpm_runtime_dont_use_autosuspend(qspi->dev);\n\tclk_disable_unprepare(qspi->clk);\n}\n\nstatic int __maybe_unused stm32_qspi_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_qspi *qspi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(qspi->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_qspi_runtime_resume(struct device *dev)\n{\n\tstruct stm32_qspi *qspi = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(qspi->clk);\n}\n\nstatic int __maybe_unused stm32_qspi_suspend(struct device *dev)\n{\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused stm32_qspi_resume(struct device *dev)\n{\n\tstruct stm32_qspi *qspi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel_relaxed(qspi->cr_reg, qspi->io_base + QSPI_CR);\n\twritel_relaxed(qspi->dcr_reg, qspi->io_base + QSPI_DCR);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops stm32_qspi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(stm32_qspi_runtime_suspend,\n\t\t\t   stm32_qspi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_qspi_suspend, stm32_qspi_resume)\n};\n\nstatic const struct of_device_id stm32_qspi_match[] = {\n\t{.compatible = \"st,stm32f469-qspi\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_qspi_match);\n\nstatic struct platform_driver stm32_qspi_driver = {\n\t.probe\t= stm32_qspi_probe,\n\t.remove_new = stm32_qspi_remove,\n\t.driver\t= {\n\t\t.name = \"stm32-qspi\",\n\t\t.of_match_table = stm32_qspi_match,\n\t\t.pm = &stm32_qspi_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_qspi_driver);\n\nMODULE_AUTHOR(\"Ludovic Barre <ludovic.barre@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 quad spi driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}