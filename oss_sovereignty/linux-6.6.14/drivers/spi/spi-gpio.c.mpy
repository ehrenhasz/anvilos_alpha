{
  "module_name": "spi-gpio.c",
  "hash_id": "8b5a7ce84a9be01cc503c3ecfbda3d45423ab27b5c6c5b21a53182ff97bcb5ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-gpio.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/spi_gpio.h>\n\n\n \n\nstruct spi_gpio {\n\tstruct spi_bitbang\t\tbitbang;\n\tstruct gpio_desc\t\t*sck;\n\tstruct gpio_desc\t\t*miso;\n\tstruct gpio_desc\t\t*mosi;\n\tstruct gpio_desc\t\t**cs_gpios;\n};\n\n \n\n \n\n#ifndef DRIVER_NAME\n#define DRIVER_NAME\t\"spi_gpio\"\n\n#define GENERIC_BITBANG\t \n\n#endif\n\n \n\nstatic inline struct spi_gpio *__pure\nspi_to_spi_gpio(const struct spi_device *spi)\n{\n\tconst struct spi_bitbang\t*bang;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\n\tbang = spi_controller_get_devdata(spi->controller);\n\tspi_gpio = container_of(bang, struct spi_gpio, bitbang);\n\treturn spi_gpio;\n}\n\n \nstatic inline void setsck(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->sck, is_on);\n}\n\nstatic inline void setmosi(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->mosi, is_on);\n}\n\nstatic inline int getmiso(const struct spi_device *spi)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tif (spi->mode & SPI_3WIRE)\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->mosi);\n\telse\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->miso);\n}\n\n \n#define spidelay(nsecs)\tdo {} while (0)\n\n#include \"spi-bitbang-txrx.h\"\n\n \n\nstatic u32 spi_gpio_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha0(spi, nsecs, 0, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha1(spi, nsecs, 0, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha0(spi, nsecs, 1, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha1(spi, nsecs, 1, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n \n\nstatic u32 spi_gpio_spec_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->controller->flags;\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha0(spi, nsecs, 0, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->controller->flags;\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha1(spi, nsecs, 0, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->controller->flags;\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha0(spi, nsecs, 1, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->controller->flags;\n\tif (unlikely(spi->mode & SPI_LSB_FIRST))\n\t\treturn bitbang_txrx_le_cpha1(spi, nsecs, 1, flags, word, bits);\n\telse\n\t\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n \n\nstatic void spi_gpio_chipselect(struct spi_device *spi, int is_active)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\t \n\tif (is_active)\n\t\tgpiod_set_value_cansleep(spi_gpio->sck, spi->mode & SPI_CPOL);\n\n\t \n\tif (spi_gpio->cs_gpios) {\n\t\tstruct gpio_desc *cs = spi_gpio->cs_gpios[spi_get_chipselect(spi, 0)];\n\n\t\t \n\t\tgpiod_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);\n\t}\n}\n\nstatic int spi_gpio_setup(struct spi_device *spi)\n{\n\tstruct gpio_desc\t*cs;\n\tint\t\t\tstatus = 0;\n\tstruct spi_gpio\t\t*spi_gpio = spi_to_spi_gpio(spi);\n\n\t \n\tif (spi_gpio->cs_gpios) {\n\t\tcs = spi_gpio->cs_gpios[spi_get_chipselect(spi, 0)];\n\t\tif (!spi->controller_state && cs)\n\t\t\tstatus = gpiod_direction_output(cs,\n\t\t\t\t\t\t  !(spi->mode & SPI_CS_HIGH));\n\t}\n\n\tif (!status)\n\t\tstatus = spi_bitbang_setup(spi);\n\n\treturn status;\n}\n\nstatic int spi_gpio_set_direction(struct spi_device *spi, bool output)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\tint ret;\n\n\tif (output)\n\t\treturn gpiod_direction_output(spi_gpio->mosi, 1);\n\n\t \n\tif (spi->mode & SPI_3WIRE) {\n\t\tret = gpiod_direction_input(spi_gpio->mosi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tif (spi->mode & SPI_3WIRE_HIZ) {\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !(spi->mode & SPI_CPOL));\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !!(spi->mode & SPI_CPOL));\n\t}\n\treturn 0;\n}\n\nstatic void spi_gpio_cleanup(struct spi_device *spi)\n{\n\tspi_bitbang_cleanup(spi);\n}\n\n \nstatic int spi_gpio_request(struct device *dev, struct spi_gpio *spi_gpio)\n{\n\tspi_gpio->mosi = devm_gpiod_get_optional(dev, \"mosi\", GPIOD_OUT_LOW);\n\tif (IS_ERR(spi_gpio->mosi))\n\t\treturn PTR_ERR(spi_gpio->mosi);\n\n\tspi_gpio->miso = devm_gpiod_get_optional(dev, \"miso\", GPIOD_IN);\n\tif (IS_ERR(spi_gpio->miso))\n\t\treturn PTR_ERR(spi_gpio->miso);\n\n\tspi_gpio->sck = devm_gpiod_get(dev, \"sck\", GPIOD_OUT_LOW);\n\treturn PTR_ERR_OR_ZERO(spi_gpio->sck);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spi_gpio_dt_ids[] = {\n\t{ .compatible = \"spi-gpio\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spi_gpio_dt_ids);\n\nstatic int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t     struct spi_controller *host)\n{\n\thost->dev.of_node = pdev->dev.of_node;\n\thost->use_gpio_descriptors = true;\n\n\treturn 0;\n}\n#else\nstatic inline int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t\t    struct spi_controller *host)\n{\n\treturn 0;\n}\n#endif\n\nstatic int spi_gpio_probe_pdata(struct platform_device *pdev,\n\t\t\t\tstruct spi_controller *host)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tstruct spi_gpio *spi_gpio = spi_controller_get_devdata(host);\n\tint i;\n\n#ifdef GENERIC_BITBANG\n\tif (!pdata || !pdata->num_chipselect)\n\t\treturn -ENODEV;\n#endif\n\t \n\thost->num_chipselect = pdata->num_chipselect ?: 1;\n\n\tspi_gpio->cs_gpios = devm_kcalloc(dev, host->num_chipselect,\n\t\t\t\t\t  sizeof(*spi_gpio->cs_gpios),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!spi_gpio->cs_gpios)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < host->num_chipselect; i++) {\n\t\tspi_gpio->cs_gpios[i] = devm_gpiod_get_index(dev, \"cs\", i,\n\t\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(spi_gpio->cs_gpios[i]))\n\t\t\treturn PTR_ERR(spi_gpio->cs_gpios[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_gpio_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tstatus;\n\tstruct spi_controller\t\t*host;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct spi_bitbang\t\t*bb;\n\n\thost = devm_spi_alloc_host(dev, sizeof(*spi_gpio));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tif (pdev->dev.of_node)\n\t\tstatus = spi_gpio_probe_dt(pdev, host);\n\telse\n\t\tstatus = spi_gpio_probe_pdata(pdev, host);\n\n\tif (status)\n\t\treturn status;\n\n\tspi_gpio = spi_controller_get_devdata(host);\n\n\tstatus = spi_gpio_request(dev, spi_gpio);\n\tif (status)\n\t\treturn status;\n\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\thost->mode_bits = SPI_3WIRE | SPI_3WIRE_HIZ | SPI_CPHA | SPI_CPOL |\n\t\t\t    SPI_CS_HIGH | SPI_LSB_FIRST;\n\tif (!spi_gpio->mosi) {\n\t\t \n\t\thost->flags = SPI_CONTROLLER_NO_TX;\n\t}\n\n\thost->bus_num = pdev->id;\n\thost->setup = spi_gpio_setup;\n\thost->cleanup = spi_gpio_cleanup;\n\n\tbb = &spi_gpio->bitbang;\n\tbb->master = host;\n\t \n\thost->flags |= SPI_CONTROLLER_GPIO_SS;\n\tbb->chipselect = spi_gpio_chipselect;\n\tbb->set_line_direction = spi_gpio_set_direction;\n\n\tif (host->flags & SPI_CONTROLLER_NO_TX) {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\n\t} else {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\n\t}\n\tbb->setup_transfer = spi_bitbang_setup_transfer;\n\n\tstatus = spi_bitbang_init(&spi_gpio->bitbang);\n\tif (status)\n\t\treturn status;\n\n\treturn devm_spi_register_controller(&pdev->dev, host);\n}\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n\nstatic struct platform_driver spi_gpio_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(spi_gpio_dt_ids),\n\t},\n\t.probe\t\t= spi_gpio_probe,\n};\nmodule_platform_driver(spi_gpio_driver);\n\nMODULE_DESCRIPTION(\"SPI host driver using generic bitbanged GPIO \");\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}