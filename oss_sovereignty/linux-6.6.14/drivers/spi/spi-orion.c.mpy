{
  "module_name": "spi-orion.c",
  "hash_id": "f77ff836ff411946c164b14faec9c562f1bffd55405c0b4dbc22542481303388",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-orion.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk.h>\n#include <linux/sizes.h>\n#include <asm/unaligned.h>\n\n#define DRIVER_NAME\t\t\t\"orion_spi\"\n\n \n#define SPI_AUTOSUSPEND_TIMEOUT\t\t200\n\n \n#define ORION_NUM_CHIPSELECTS\t\t8\n\n#define ORION_SPI_WAIT_RDY_MAX_LOOP\t2000  \n\n#define ORION_SPI_IF_CTRL_REG\t\t0x00\n#define ORION_SPI_IF_CONFIG_REG\t\t0x04\n#define ORION_SPI_IF_RXLSBF\t\tBIT(14)\n#define ORION_SPI_IF_TXLSBF\t\tBIT(13)\n#define ORION_SPI_DATA_OUT_REG\t\t0x08\n#define ORION_SPI_DATA_IN_REG\t\t0x0c\n#define ORION_SPI_INT_CAUSE_REG\t\t0x10\n#define ORION_SPI_TIMING_PARAMS_REG\t0x18\n\n \n#define SPI_DIRECT_WRITE_CONFIG_REG\t0x20\n\n#define ORION_SPI_TMISO_SAMPLE_MASK\t(0x3 << 6)\n#define ORION_SPI_TMISO_SAMPLE_1\t(1 << 6)\n#define ORION_SPI_TMISO_SAMPLE_2\t(2 << 6)\n\n#define ORION_SPI_MODE_CPOL\t\t(1 << 11)\n#define ORION_SPI_MODE_CPHA\t\t(1 << 12)\n#define ORION_SPI_IF_8_16_BIT_MODE\t(1 << 5)\n#define ORION_SPI_CLK_PRESCALE_MASK\t0x1F\n#define ARMADA_SPI_CLK_PRESCALE_MASK\t0xDF\n#define ORION_SPI_MODE_MASK\t\t(ORION_SPI_MODE_CPOL | \\\n\t\t\t\t\t ORION_SPI_MODE_CPHA)\n#define ORION_SPI_CS_MASK\t0x1C\n#define ORION_SPI_CS_SHIFT\t2\n#define ORION_SPI_CS(cs)\t((cs << ORION_SPI_CS_SHIFT) & \\\n\t\t\t\t\tORION_SPI_CS_MASK)\n\nenum orion_spi_type {\n\tORION_SPI,\n\tARMADA_SPI,\n};\n\nstruct orion_spi_dev {\n\tenum orion_spi_type\ttyp;\n\t \n\tunsigned long\t\tmax_hz;\n\tunsigned int\t\tmin_divisor;\n\tunsigned int\t\tmax_divisor;\n\tu32\t\t\tprescale_mask;\n\tbool\t\t\tis_errata_50mhz_ac;\n};\n\nstruct orion_direct_acc {\n\tvoid __iomem\t\t*vaddr;\n\tu32\t\t\tsize;\n};\n\nstruct orion_child_options {\n\tstruct orion_direct_acc direct_access;\n};\n\nstruct orion_spi {\n\tstruct spi_controller\t*host;\n\tvoid __iomem\t\t*base;\n\tstruct clk              *clk;\n\tstruct clk              *axi_clk;\n\tconst struct orion_spi_dev *devdata;\n\tstruct device\t\t*dev;\n\n\tstruct orion_child_options\tchild[ORION_NUM_CHIPSELECTS];\n};\n\n#ifdef CONFIG_PM\nstatic int orion_spi_runtime_suspend(struct device *dev);\nstatic int orion_spi_runtime_resume(struct device *dev);\n#endif\n\nstatic inline void __iomem *spi_reg(struct orion_spi *orion_spi, u32 reg)\n{\n\treturn orion_spi->base + reg;\n}\n\nstatic inline void\norion_spi_setbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\n{\n\tvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\n\tu32 val;\n\n\tval = readl(reg_addr);\n\tval |= mask;\n\twritel(val, reg_addr);\n}\n\nstatic inline void\norion_spi_clrbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\n{\n\tvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\n\tu32 val;\n\n\tval = readl(reg_addr);\n\tval &= ~mask;\n\twritel(val, reg_addr);\n}\n\nstatic int orion_spi_baudrate_set(struct spi_device *spi, unsigned int speed)\n{\n\tu32 tclk_hz;\n\tu32 rate;\n\tu32 prescale;\n\tu32 reg;\n\tstruct orion_spi *orion_spi;\n\tconst struct orion_spi_dev *devdata;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\tdevdata = orion_spi->devdata;\n\n\ttclk_hz = clk_get_rate(orion_spi->clk);\n\n\tif (devdata->typ == ARMADA_SPI) {\n\t\t \n\n\t\t \n\t\tunsigned divider = DIV_ROUND_UP(tclk_hz, speed);\n\t\tunsigned spr, sppr;\n\n\t\tif (divider < 16) {\n\t\t\t \n\t\t\tspr = divider;\n\t\t\tsppr = 0;\n\n\t\t} else {\n\t\t\tunsigned two_pow_sppr;\n\t\t\t \n\t\t\tsppr = fls(divider) - 4;\n\n\t\t\t \n\t\t\ttwo_pow_sppr = 1 << sppr;\n\t\t\tdivider = (divider + two_pow_sppr - 1) & -two_pow_sppr;\n\n\t\t\t \n\t\t\tsppr = fls(divider) - 4;\n\t\t\tspr = divider >> sppr;\n\n\t\t\t \n\t\t\tif (sppr > 7)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprescale = ((sppr & 0x6) << 5) | ((sppr & 0x1) << 4) | spr;\n\t} else {\n\t\t \n\t\trate = DIV_ROUND_UP(tclk_hz, speed);\n\t\trate = roundup(rate, 2);\n\n\t\t \n\t\tif (rate > 30)\n\t\t\treturn -EINVAL;\n\n\t\tif (rate < 4)\n\t\t\trate = 4;\n\n\t\t \n\t\tprescale = 0x10 + rate/2;\n\t}\n\n\treg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\n\treg = ((reg & ~devdata->prescale_mask) | prescale);\n\twritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\n\n\treturn 0;\n}\n\nstatic void\norion_spi_mode_set(struct spi_device *spi)\n{\n\tu32 reg;\n\tstruct orion_spi *orion_spi;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\n\treg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\n\treg &= ~ORION_SPI_MODE_MASK;\n\tif (spi->mode & SPI_CPOL)\n\t\treg |= ORION_SPI_MODE_CPOL;\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= ORION_SPI_MODE_CPHA;\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\treg |= ORION_SPI_IF_RXLSBF | ORION_SPI_IF_TXLSBF;\n\telse\n\t\treg &= ~(ORION_SPI_IF_RXLSBF | ORION_SPI_IF_TXLSBF);\n\n\twritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\n}\n\nstatic void\norion_spi_50mhz_ac_timing_erratum(struct spi_device *spi, unsigned int speed)\n{\n\tu32 reg;\n\tstruct orion_spi *orion_spi;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\n\t \n\treg = readl(spi_reg(orion_spi, ORION_SPI_TIMING_PARAMS_REG));\n\treg &= ~ORION_SPI_TMISO_SAMPLE_MASK;\n\n\tif (clk_get_rate(orion_spi->clk) == 250000000 &&\n\t\t\tspeed == 50000000 && spi->mode & SPI_CPOL &&\n\t\t\tspi->mode & SPI_CPHA)\n\t\treg |= ORION_SPI_TMISO_SAMPLE_2;\n\telse\n\t\treg |= ORION_SPI_TMISO_SAMPLE_1;  \n\n\twritel(reg, spi_reg(orion_spi, ORION_SPI_TIMING_PARAMS_REG));\n}\n\n \nstatic int\norion_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct orion_spi *orion_spi;\n\tunsigned int speed = spi->max_speed_hz;\n\tunsigned int bits_per_word = spi->bits_per_word;\n\tint\trc;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\n\tif ((t != NULL) && t->speed_hz)\n\t\tspeed = t->speed_hz;\n\n\tif ((t != NULL) && t->bits_per_word)\n\t\tbits_per_word = t->bits_per_word;\n\n\torion_spi_mode_set(spi);\n\n\tif (orion_spi->devdata->is_errata_50mhz_ac)\n\t\torion_spi_50mhz_ac_timing_erratum(spi, speed);\n\n\trc = orion_spi_baudrate_set(spi, speed);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bits_per_word == 16)\n\t\torion_spi_setbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\n\t\t\t\t  ORION_SPI_IF_8_16_BIT_MODE);\n\telse\n\t\torion_spi_clrbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\n\t\t\t\t  ORION_SPI_IF_8_16_BIT_MODE);\n\n\treturn 0;\n}\n\nstatic void orion_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct orion_spi *orion_spi;\n\tvoid __iomem *ctrl_reg;\n\tu32 val;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\tctrl_reg = spi_reg(orion_spi, ORION_SPI_IF_CTRL_REG);\n\n\tval = readl(ctrl_reg);\n\n\t \n\tval &= ~(ORION_SPI_CS_MASK | 0x1);\n\n\t \n\tval |= ORION_SPI_CS(spi_get_chipselect(spi, 0));\n\n\t \n\tif (!enable)\n\t\tval |= 0x1;\n\n\t \n\twritel(val, ctrl_reg);\n}\n\nstatic inline int orion_spi_wait_till_ready(struct orion_spi *orion_spi)\n{\n\tint i;\n\n\tfor (i = 0; i < ORION_SPI_WAIT_RDY_MAX_LOOP; i++) {\n\t\tif (readl(spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG)))\n\t\t\treturn 1;\n\n\t\tudelay(1);\n\t}\n\n\treturn -1;\n}\n\nstatic inline int\norion_spi_write_read_8bit(struct spi_device *spi,\n\t\t\t  const u8 **tx_buf, u8 **rx_buf)\n{\n\tvoid __iomem *tx_reg, *rx_reg, *int_reg;\n\tstruct orion_spi *orion_spi;\n\tbool cs_single_byte;\n\n\tcs_single_byte = spi->mode & SPI_CS_WORD;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\n\tif (cs_single_byte)\n\t\torion_spi_set_cs(spi, 0);\n\n\ttx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\n\trx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\n\tint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\n\n\t \n\twritel(0x0, int_reg);\n\n\tif (tx_buf && *tx_buf)\n\t\twritel(*(*tx_buf)++, tx_reg);\n\telse\n\t\twritel(0, tx_reg);\n\n\tif (orion_spi_wait_till_ready(orion_spi) < 0) {\n\t\tif (cs_single_byte) {\n\t\t\torion_spi_set_cs(spi, 1);\n\t\t\t \n\t\t\tudelay(4);\n\t\t}\n\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rx_buf && *rx_buf)\n\t\t*(*rx_buf)++ = readl(rx_reg);\n\n\tif (cs_single_byte) {\n\t\torion_spi_set_cs(spi, 1);\n\t\t \n\t\tudelay(4);\n\t}\n\n\treturn 1;\n}\n\nstatic inline int\norion_spi_write_read_16bit(struct spi_device *spi,\n\t\t\t   const u16 **tx_buf, u16 **rx_buf)\n{\n\tvoid __iomem *tx_reg, *rx_reg, *int_reg;\n\tstruct orion_spi *orion_spi;\n\n\tif (spi->mode & SPI_CS_WORD) {\n\t\tdev_err(&spi->dev, \"SPI_CS_WORD is only supported for 8 bit words\\n\");\n\t\treturn -1;\n\t}\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\ttx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\n\trx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\n\tint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\n\n\t \n\twritel(0x0, int_reg);\n\n\tif (tx_buf && *tx_buf)\n\t\twritel(__cpu_to_le16(get_unaligned((*tx_buf)++)), tx_reg);\n\telse\n\t\twritel(0, tx_reg);\n\n\tif (orion_spi_wait_till_ready(orion_spi) < 0) {\n\t\tdev_err(&spi->dev, \"TXS timed out\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rx_buf && *rx_buf)\n\t\tput_unaligned(__le16_to_cpu(readl(rx_reg)), (*rx_buf)++);\n\n\treturn 1;\n}\n\nstatic unsigned int\norion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)\n{\n\tunsigned int count;\n\tint word_len;\n\tstruct orion_spi *orion_spi;\n\tint cs = spi_get_chipselect(spi, 0);\n\tvoid __iomem *vaddr;\n\n\tword_len = spi->bits_per_word;\n\tcount = xfer->len;\n\n\torion_spi = spi_controller_get_devdata(spi->controller);\n\n\t \n\tvaddr = orion_spi->child[cs].direct_access.vaddr;\n\n\tif (vaddr && xfer->tx_buf && word_len == 8 && (spi->mode & SPI_CS_WORD) == 0) {\n\t\tunsigned int cnt = count / 4;\n\t\tunsigned int rem = count % 4;\n\n\t\t \n\t\tiowrite32_rep(vaddr, xfer->tx_buf, cnt);\n\t\tif (rem) {\n\t\t\tu32 *buf = (u32 *)xfer->tx_buf;\n\n\t\t\tiowrite8_rep(vaddr, &buf[cnt], rem);\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tif (word_len == 8) {\n\t\tconst u8 *tx = xfer->tx_buf;\n\t\tu8 *rx = xfer->rx_buf;\n\n\t\tdo {\n\t\t\tif (orion_spi_write_read_8bit(spi, &tx, &rx) < 0)\n\t\t\t\tgoto out;\n\t\t\tcount--;\n\t\t\tspi_delay_exec(&xfer->word_delay, xfer);\n\t\t} while (count);\n\t} else if (word_len == 16) {\n\t\tconst u16 *tx = xfer->tx_buf;\n\t\tu16 *rx = xfer->rx_buf;\n\n\t\tdo {\n\t\t\tif (orion_spi_write_read_16bit(spi, &tx, &rx) < 0)\n\t\t\t\tgoto out;\n\t\t\tcount -= 2;\n\t\t\tspi_delay_exec(&xfer->word_delay, xfer);\n\t\t} while (count);\n\t}\n\nout:\n\treturn xfer->len - count;\n}\n\nstatic int orion_spi_transfer_one(struct spi_controller *host,\n\t\t\t\t\tstruct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *t)\n{\n\tint status = 0;\n\n\tstatus = orion_spi_setup_transfer(spi, t);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (t->len)\n\t\torion_spi_write_read(spi, t);\n\n\treturn status;\n}\n\nstatic int orion_spi_setup(struct spi_device *spi)\n{\n\tint ret;\n#ifdef CONFIG_PM\n\tstruct orion_spi *orion_spi = spi_controller_get_devdata(spi->controller);\n\tstruct device *dev = orion_spi->dev;\n\n\torion_spi_runtime_resume(dev);\n#endif\n\n\tret = orion_spi_setup_transfer(spi, NULL);\n\n#ifdef CONFIG_PM\n\torion_spi_runtime_suspend(dev);\n#endif\n\n\treturn ret;\n}\n\nstatic int orion_spi_reset(struct orion_spi *orion_spi)\n{\n\t \n\torion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\n\n\t \n\twritel(0, spi_reg(orion_spi, SPI_DIRECT_WRITE_CONFIG_REG));\n\n\treturn 0;\n}\n\nstatic const struct orion_spi_dev orion_spi_dev_data = {\n\t.typ = ORION_SPI,\n\t.min_divisor = 4,\n\t.max_divisor = 30,\n\t.prescale_mask = ORION_SPI_CLK_PRESCALE_MASK,\n};\n\nstatic const struct orion_spi_dev armada_370_spi_dev_data = {\n\t.typ = ARMADA_SPI,\n\t.min_divisor = 4,\n\t.max_divisor = 1920,\n\t.max_hz = 50000000,\n\t.prescale_mask = ARMADA_SPI_CLK_PRESCALE_MASK,\n};\n\nstatic const struct orion_spi_dev armada_xp_spi_dev_data = {\n\t.typ = ARMADA_SPI,\n\t.max_hz = 50000000,\n\t.max_divisor = 1920,\n\t.prescale_mask = ARMADA_SPI_CLK_PRESCALE_MASK,\n};\n\nstatic const struct orion_spi_dev armada_375_spi_dev_data = {\n\t.typ = ARMADA_SPI,\n\t.min_divisor = 15,\n\t.max_divisor = 1920,\n\t.prescale_mask = ARMADA_SPI_CLK_PRESCALE_MASK,\n};\n\nstatic const struct orion_spi_dev armada_380_spi_dev_data = {\n\t.typ = ARMADA_SPI,\n\t.max_hz = 50000000,\n\t.max_divisor = 1920,\n\t.prescale_mask = ARMADA_SPI_CLK_PRESCALE_MASK,\n\t.is_errata_50mhz_ac = true,\n};\n\nstatic const struct of_device_id orion_spi_of_match_table[] = {\n\t{\n\t\t.compatible = \"marvell,orion-spi\",\n\t\t.data = &orion_spi_dev_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-370-spi\",\n\t\t.data = &armada_370_spi_dev_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-375-spi\",\n\t\t.data = &armada_375_spi_dev_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-380-spi\",\n\t\t.data = &armada_380_spi_dev_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-390-spi\",\n\t\t.data = &armada_xp_spi_dev_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-xp-spi\",\n\t\t.data = &armada_xp_spi_dev_data,\n\t},\n\n\t{}\n};\nMODULE_DEVICE_TABLE(of, orion_spi_of_match_table);\n\nstatic int orion_spi_probe(struct platform_device *pdev)\n{\n\tconst struct orion_spi_dev *devdata;\n\tstruct spi_controller *host;\n\tstruct orion_spi *spi;\n\tstruct resource *r;\n\tunsigned long tclk_hz;\n\tint status = 0;\n\tstruct device_node *np;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(*spi));\n\tif (host == NULL) {\n\t\tdev_dbg(&pdev->dev, \"host allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pdev->id != -1)\n\t\thost->bus_num = pdev->id;\n\tif (pdev->dev.of_node) {\n\t\tu32 cell_index;\n\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"cell-index\",\n\t\t\t\t\t  &cell_index))\n\t\t\thost->bus_num = cell_index;\n\t}\n\n\t \n\thost->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST | SPI_CS_WORD;\n\thost->set_cs = orion_spi_set_cs;\n\thost->transfer_one = orion_spi_transfer_one;\n\thost->num_chipselect = ORION_NUM_CHIPSELECTS;\n\thost->setup = orion_spi_setup;\n\thost->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n\thost->auto_runtime_pm = true;\n\thost->use_gpio_descriptors = true;\n\thost->flags = SPI_CONTROLLER_GPIO_SS;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tspi = spi_controller_get_devdata(host);\n\tspi->host = host;\n\tspi->dev = &pdev->dev;\n\n\tdevdata = device_get_match_data(&pdev->dev);\n\tdevdata = devdata ? devdata : &orion_spi_dev_data;\n\tspi->devdata = devdata;\n\n\tspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(spi->clk)) {\n\t\tstatus = PTR_ERR(spi->clk);\n\t\tgoto out;\n\t}\n\n\tstatus = clk_prepare_enable(spi->clk);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tspi->axi_clk = devm_clk_get(&pdev->dev, \"axi\");\n\tif (PTR_ERR(spi->axi_clk) == -EPROBE_DEFER) {\n\t\tstatus = -EPROBE_DEFER;\n\t\tgoto out_rel_clk;\n\t}\n\tif (!IS_ERR(spi->axi_clk))\n\t\tclk_prepare_enable(spi->axi_clk);\n\n\ttclk_hz = clk_get_rate(spi->clk);\n\n\t \n\tif (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t\t\"marvell,armada-370-spi\"))\n\t\thost->max_speed_hz = min(devdata->max_hz,\n\t\t\t\tDIV_ROUND_UP(tclk_hz, devdata->min_divisor));\n\telse if (devdata->min_divisor)\n\t\thost->max_speed_hz =\n\t\t\tDIV_ROUND_UP(tclk_hz, devdata->min_divisor);\n\telse\n\t\thost->max_speed_hz = devdata->max_hz;\n\thost->min_speed_hz = DIV_ROUND_UP(tclk_hz, devdata->max_divisor);\n\n\tspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(spi->base)) {\n\t\tstatus = PTR_ERR(spi->base);\n\t\tgoto out_rel_axi_clk;\n\t}\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, np) {\n\t\tstruct orion_direct_acc *dir_acc;\n\t\tu32 cs;\n\n\t\t \n\t\tstatus = of_property_read_u32(np, \"reg\", &cs);\n\t\tif (status) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%pOF has no valid 'reg' property (%d)\\n\",\n\t\t\t\tnp, status);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstatus = of_address_to_resource(pdev->dev.of_node, cs + 1, r);\n\t\tif (status)\n\t\t\tcontinue;\n\n\t\t \n\t\tdir_acc = &spi->child[cs].direct_access;\n\t\tdir_acc->vaddr = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);\n\t\tif (!dir_acc->vaddr) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tof_node_put(np);\n\t\t\tgoto out_rel_axi_clk;\n\t\t}\n\t\tdir_acc->size = PAGE_SIZE;\n\n\t\tdev_info(&pdev->dev, \"CS%d configured for direct access\\n\", cs);\n\t}\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_enable(&pdev->dev);\n\n\tstatus = orion_spi_reset(spi);\n\tif (status < 0)\n\t\tgoto out_rel_pm;\n\n\thost->dev.of_node = pdev->dev.of_node;\n\tstatus = spi_register_controller(host);\n\tif (status < 0)\n\t\tgoto out_rel_pm;\n\n\treturn status;\n\nout_rel_pm:\n\tpm_runtime_disable(&pdev->dev);\nout_rel_axi_clk:\n\tclk_disable_unprepare(spi->axi_clk);\nout_rel_clk:\n\tclk_disable_unprepare(spi->clk);\nout:\n\tspi_controller_put(host);\n\treturn status;\n}\n\n\nstatic void orion_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct orion_spi *spi = spi_controller_get_devdata(host);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tclk_disable_unprepare(spi->axi_clk);\n\tclk_disable_unprepare(spi->clk);\n\n\tspi_unregister_controller(host);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n\n#ifdef CONFIG_PM\nstatic int orion_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct orion_spi *spi = spi_controller_get_devdata(host);\n\n\tclk_disable_unprepare(spi->axi_clk);\n\tclk_disable_unprepare(spi->clk);\n\treturn 0;\n}\n\nstatic int orion_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct orion_spi *spi = spi_controller_get_devdata(host);\n\n\tif (!IS_ERR(spi->axi_clk))\n\t\tclk_prepare_enable(spi->axi_clk);\n\treturn clk_prepare_enable(spi->clk);\n}\n#endif\n\nstatic const struct dev_pm_ops orion_spi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(orion_spi_runtime_suspend,\n\t\t\t   orion_spi_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver orion_spi_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &orion_spi_pm_ops,\n\t\t.of_match_table = of_match_ptr(orion_spi_of_match_table),\n\t},\n\t.probe\t\t= orion_spi_probe,\n\t.remove_new\t= orion_spi_remove,\n};\n\nmodule_platform_driver(orion_spi_driver);\n\nMODULE_DESCRIPTION(\"Orion SPI driver\");\nMODULE_AUTHOR(\"Shadi Ammouri <shadi@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}