{
  "module_name": "spi-sifive.c",
  "hash_id": "5ec3c89a696aa38ce6cd519fa416bf976c98a4734a6a193926c922347317b506",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sifive.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n\n#define SIFIVE_SPI_DRIVER_NAME           \"sifive_spi\"\n\n#define SIFIVE_SPI_MAX_CS                32\n#define SIFIVE_SPI_DEFAULT_DEPTH         8\n#define SIFIVE_SPI_DEFAULT_MAX_BITS      8\n\n \n#define SIFIVE_SPI_REG_SCKDIV            0x00  \n#define SIFIVE_SPI_REG_SCKMODE           0x04  \n#define SIFIVE_SPI_REG_CSID              0x10  \n#define SIFIVE_SPI_REG_CSDEF             0x14  \n#define SIFIVE_SPI_REG_CSMODE            0x18  \n#define SIFIVE_SPI_REG_DELAY0            0x28  \n#define SIFIVE_SPI_REG_DELAY1            0x2c  \n#define SIFIVE_SPI_REG_FMT               0x40  \n#define SIFIVE_SPI_REG_TXDATA            0x48  \n#define SIFIVE_SPI_REG_RXDATA            0x4c  \n#define SIFIVE_SPI_REG_TXMARK            0x50  \n#define SIFIVE_SPI_REG_RXMARK            0x54  \n#define SIFIVE_SPI_REG_FCTRL             0x60  \n#define SIFIVE_SPI_REG_FFMT              0x64  \n#define SIFIVE_SPI_REG_IE                0x70  \n#define SIFIVE_SPI_REG_IP                0x74  \n\n \n#define SIFIVE_SPI_SCKDIV_DIV_MASK       0xfffU\n\n \n#define SIFIVE_SPI_SCKMODE_PHA           BIT(0)\n#define SIFIVE_SPI_SCKMODE_POL           BIT(1)\n#define SIFIVE_SPI_SCKMODE_MODE_MASK     (SIFIVE_SPI_SCKMODE_PHA | \\\n\t\t\t\t\t  SIFIVE_SPI_SCKMODE_POL)\n\n \n#define SIFIVE_SPI_CSMODE_MODE_AUTO      0U\n#define SIFIVE_SPI_CSMODE_MODE_HOLD      2U\n#define SIFIVE_SPI_CSMODE_MODE_OFF       3U\n\n \n#define SIFIVE_SPI_DELAY0_CSSCK(x)       ((u32)(x))\n#define SIFIVE_SPI_DELAY0_CSSCK_MASK     0xffU\n#define SIFIVE_SPI_DELAY0_SCKCS(x)       ((u32)(x) << 16)\n#define SIFIVE_SPI_DELAY0_SCKCS_MASK     (0xffU << 16)\n\n \n#define SIFIVE_SPI_DELAY1_INTERCS(x)     ((u32)(x))\n#define SIFIVE_SPI_DELAY1_INTERCS_MASK   0xffU\n#define SIFIVE_SPI_DELAY1_INTERXFR(x)    ((u32)(x) << 16)\n#define SIFIVE_SPI_DELAY1_INTERXFR_MASK  (0xffU << 16)\n\n \n#define SIFIVE_SPI_FMT_PROTO_SINGLE      0U\n#define SIFIVE_SPI_FMT_PROTO_DUAL        1U\n#define SIFIVE_SPI_FMT_PROTO_QUAD        2U\n#define SIFIVE_SPI_FMT_PROTO_MASK        3U\n#define SIFIVE_SPI_FMT_ENDIAN            BIT(2)\n#define SIFIVE_SPI_FMT_DIR               BIT(3)\n#define SIFIVE_SPI_FMT_LEN(x)            ((u32)(x) << 16)\n#define SIFIVE_SPI_FMT_LEN_MASK          (0xfU << 16)\n\n \n#define SIFIVE_SPI_TXDATA_DATA_MASK      0xffU\n#define SIFIVE_SPI_TXDATA_FULL           BIT(31)\n\n \n#define SIFIVE_SPI_RXDATA_DATA_MASK      0xffU\n#define SIFIVE_SPI_RXDATA_EMPTY          BIT(31)\n\n \n#define SIFIVE_SPI_IP_TXWM               BIT(0)\n#define SIFIVE_SPI_IP_RXWM               BIT(1)\n\nstruct sifive_spi {\n\tvoid __iomem      *regs;         \n\tstruct clk        *clk;          \n\tunsigned int      fifo_depth;    \n\tu32               cs_inactive;   \n\tstruct completion done;          \n};\n\nstatic void sifive_spi_write(struct sifive_spi *spi, int offset, u32 value)\n{\n\tiowrite32(value, spi->regs + offset);\n}\n\nstatic u32 sifive_spi_read(struct sifive_spi *spi, int offset)\n{\n\treturn ioread32(spi->regs + offset);\n}\n\nstatic void sifive_spi_init(struct sifive_spi *spi)\n{\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_IE, 0);\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_TXMARK, 1);\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_RXMARK, 0);\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_DELAY0,\n\t\t\t SIFIVE_SPI_DELAY0_CSSCK(1) |\n\t\t\t SIFIVE_SPI_DELAY0_SCKCS(1));\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_DELAY1,\n\t\t\t SIFIVE_SPI_DELAY1_INTERCS(1) |\n\t\t\t SIFIVE_SPI_DELAY1_INTERXFR(0));\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_FCTRL, 0);\n}\n\nstatic int\nsifive_spi_prepare_message(struct spi_controller *host, struct spi_message *msg)\n{\n\tstruct sifive_spi *spi = spi_controller_get_devdata(host);\n\tstruct spi_device *device = msg->spi;\n\n\t \n\tif (device->mode & SPI_CS_HIGH)\n\t\tspi->cs_inactive &= ~BIT(spi_get_chipselect(device, 0));\n\telse\n\t\tspi->cs_inactive |= BIT(spi_get_chipselect(device, 0));\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_CSDEF, spi->cs_inactive);\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_CSID, spi_get_chipselect(device, 0));\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_SCKMODE,\n\t\t\t device->mode & SIFIVE_SPI_SCKMODE_MODE_MASK);\n\n\treturn 0;\n}\n\nstatic void sifive_spi_set_cs(struct spi_device *device, bool is_high)\n{\n\tstruct sifive_spi *spi = spi_controller_get_devdata(device->controller);\n\n\t \n\tif (device->mode & SPI_CS_HIGH)\n\t\tis_high = !is_high;\n\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_CSMODE, is_high ?\n\t\t\t SIFIVE_SPI_CSMODE_MODE_AUTO :\n\t\t\t SIFIVE_SPI_CSMODE_MODE_HOLD);\n}\n\nstatic int\nsifive_spi_prep_transfer(struct sifive_spi *spi, struct spi_device *device,\n\t\t\t struct spi_transfer *t)\n{\n\tu32 cr;\n\tunsigned int mode;\n\n\t \n\tcr = DIV_ROUND_UP(clk_get_rate(spi->clk) >> 1, t->speed_hz) - 1;\n\tcr &= SIFIVE_SPI_SCKDIV_DIV_MASK;\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_SCKDIV, cr);\n\n\tmode = max_t(unsigned int, t->rx_nbits, t->tx_nbits);\n\n\t \n\tcr = SIFIVE_SPI_FMT_LEN(t->bits_per_word);\n\tswitch (mode) {\n\tcase SPI_NBITS_QUAD:\n\t\tcr |= SIFIVE_SPI_FMT_PROTO_QUAD;\n\t\tbreak;\n\tcase SPI_NBITS_DUAL:\n\t\tcr |= SIFIVE_SPI_FMT_PROTO_DUAL;\n\t\tbreak;\n\tdefault:\n\t\tcr |= SIFIVE_SPI_FMT_PROTO_SINGLE;\n\t\tbreak;\n\t}\n\tif (device->mode & SPI_LSB_FIRST)\n\t\tcr |= SIFIVE_SPI_FMT_ENDIAN;\n\tif (!t->rx_buf)\n\t\tcr |= SIFIVE_SPI_FMT_DIR;\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_FMT, cr);\n\n\t \n\treturn 1600000 * spi->fifo_depth <= t->speed_hz * mode;\n}\n\nstatic irqreturn_t sifive_spi_irq(int irq, void *dev_id)\n{\n\tstruct sifive_spi *spi = dev_id;\n\tu32 ip = sifive_spi_read(spi, SIFIVE_SPI_REG_IP);\n\n\tif (ip & (SIFIVE_SPI_IP_TXWM | SIFIVE_SPI_IP_RXWM)) {\n\t\t \n\t\tsifive_spi_write(spi, SIFIVE_SPI_REG_IE, 0);\n\t\tcomplete(&spi->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void sifive_spi_wait(struct sifive_spi *spi, u32 bit, int poll)\n{\n\tif (poll) {\n\t\tu32 cr;\n\n\t\tdo {\n\t\t\tcr = sifive_spi_read(spi, SIFIVE_SPI_REG_IP);\n\t\t} while (!(cr & bit));\n\t} else {\n\t\treinit_completion(&spi->done);\n\t\tsifive_spi_write(spi, SIFIVE_SPI_REG_IE, bit);\n\t\twait_for_completion(&spi->done);\n\t}\n}\n\nstatic void sifive_spi_tx(struct sifive_spi *spi, const u8 *tx_ptr)\n{\n\tWARN_ON_ONCE((sifive_spi_read(spi, SIFIVE_SPI_REG_TXDATA)\n\t\t\t\t& SIFIVE_SPI_TXDATA_FULL) != 0);\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_TXDATA,\n\t\t\t *tx_ptr & SIFIVE_SPI_TXDATA_DATA_MASK);\n}\n\nstatic void sifive_spi_rx(struct sifive_spi *spi, u8 *rx_ptr)\n{\n\tu32 data = sifive_spi_read(spi, SIFIVE_SPI_REG_RXDATA);\n\n\tWARN_ON_ONCE((data & SIFIVE_SPI_RXDATA_EMPTY) != 0);\n\t*rx_ptr = data & SIFIVE_SPI_RXDATA_DATA_MASK;\n}\n\nstatic int\nsifive_spi_transfer_one(struct spi_controller *host, struct spi_device *device,\n\t\t\tstruct spi_transfer *t)\n{\n\tstruct sifive_spi *spi = spi_controller_get_devdata(host);\n\tint poll = sifive_spi_prep_transfer(spi, device, t);\n\tconst u8 *tx_ptr = t->tx_buf;\n\tu8 *rx_ptr = t->rx_buf;\n\tunsigned int remaining_words = t->len;\n\n\twhile (remaining_words) {\n\t\tunsigned int n_words = min(remaining_words, spi->fifo_depth);\n\t\tunsigned int i;\n\n\t\t \n\t\tfor (i = 0; i < n_words; i++)\n\t\t\tsifive_spi_tx(spi, tx_ptr++);\n\n\t\tif (rx_ptr) {\n\t\t\t \n\t\t\tsifive_spi_write(spi, SIFIVE_SPI_REG_RXMARK,\n\t\t\t\t\t n_words - 1);\n\t\t\tsifive_spi_wait(spi, SIFIVE_SPI_IP_RXWM, poll);\n\n\t\t\t \n\t\t\tfor (i = 0; i < n_words; i++)\n\t\t\t\tsifive_spi_rx(spi, rx_ptr++);\n\t\t} else {\n\t\t\t \n\t\t\tsifive_spi_wait(spi, SIFIVE_SPI_IP_TXWM, poll);\n\t\t}\n\n\t\tremaining_words -= n_words;\n\t}\n\n\treturn 0;\n}\n\nstatic int sifive_spi_probe(struct platform_device *pdev)\n{\n\tstruct sifive_spi *spi;\n\tint ret, irq, num_cs;\n\tu32 cs_bits, max_bits_per_word;\n\tstruct spi_controller *host;\n\n\thost = spi_alloc_host(&pdev->dev, sizeof(struct sifive_spi));\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspi = spi_controller_get_devdata(host);\n\tinit_completion(&spi->done);\n\tplatform_set_drvdata(pdev, host);\n\n\tspi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spi->regs)) {\n\t\tret = PTR_ERR(spi->regs);\n\t\tgoto put_host;\n\t}\n\n\tspi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(spi->clk)) {\n\t\tdev_err(&pdev->dev, \"Unable to find bus clock\\n\");\n\t\tret = PTR_ERR(spi->clk);\n\t\tgoto put_host;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto put_host;\n\t}\n\n\t \n\tret =\n\t  of_property_read_u32(pdev->dev.of_node, \"sifive,fifo-depth\",\n\t\t\t       &spi->fifo_depth);\n\tif (ret < 0)\n\t\tspi->fifo_depth = SIFIVE_SPI_DEFAULT_DEPTH;\n\n\tret =\n\t  of_property_read_u32(pdev->dev.of_node, \"sifive,max-bits-per-word\",\n\t\t\t       &max_bits_per_word);\n\n\tif (!ret && max_bits_per_word < 8) {\n\t\tdev_err(&pdev->dev, \"Only 8bit SPI words supported by the driver\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_host;\n\t}\n\n\t \n\tret = clk_prepare_enable(spi->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable bus clock\\n\");\n\t\tgoto put_host;\n\t}\n\n\t \n\tspi->cs_inactive = sifive_spi_read(spi, SIFIVE_SPI_REG_CSDEF);\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_CSDEF, 0xffffffffU);\n\tcs_bits = sifive_spi_read(spi, SIFIVE_SPI_REG_CSDEF);\n\tsifive_spi_write(spi, SIFIVE_SPI_REG_CSDEF, spi->cs_inactive);\n\tif (!cs_bits) {\n\t\tdev_err(&pdev->dev, \"Could not auto probe CS lines\\n\");\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\tnum_cs = ilog2(cs_bits) + 1;\n\tif (num_cs > SIFIVE_SPI_MAX_CS) {\n\t\tdev_err(&pdev->dev, \"Invalid number of spi targets\\n\");\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\t \n\thost->dev.of_node = pdev->dev.of_node;\n\thost->bus_num = pdev->id;\n\thost->num_chipselect = num_cs;\n\thost->mode_bits = SPI_CPHA | SPI_CPOL\n\t\t\t  | SPI_CS_HIGH | SPI_LSB_FIRST\n\t\t\t  | SPI_TX_DUAL | SPI_TX_QUAD\n\t\t\t  | SPI_RX_DUAL | SPI_RX_QUAD;\n\t \n\thost->bits_per_word_mask = SPI_BPW_MASK(8);\n\thost->flags = SPI_CONTROLLER_MUST_TX | SPI_CONTROLLER_GPIO_SS;\n\thost->prepare_message = sifive_spi_prepare_message;\n\thost->set_cs = sifive_spi_set_cs;\n\thost->transfer_one = sifive_spi_transfer_one;\n\n\tpdev->dev.dma_mask = NULL;\n\t \n\tsifive_spi_init(spi);\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq, sifive_spi_irq, 0,\n\t\t\t       dev_name(&pdev->dev), spi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to bind to interrupt\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\tdev_info(&pdev->dev, \"mapped; irq=%d, cs=%d\\n\",\n\t\t irq, host->num_chipselect);\n\n\tret = devm_spi_register_controller(&pdev->dev, host);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_host failed\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(spi->clk);\nput_host:\n\tspi_controller_put(host);\n\n\treturn ret;\n}\n\nstatic void sifive_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct sifive_spi *spi = spi_controller_get_devdata(host);\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_IE, 0);\n\tclk_disable_unprepare(spi->clk);\n}\n\nstatic int sifive_spi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct sifive_spi *spi = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsifive_spi_write(spi, SIFIVE_SPI_REG_IE, 0);\n\n\tclk_disable_unprepare(spi->clk);\n\n\treturn ret;\n}\n\nstatic int sifive_spi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct sifive_spi *spi = spi_controller_get_devdata(host);\n\tint ret;\n\n\tret = clk_prepare_enable(spi->clk);\n\tif (ret)\n\t\treturn ret;\n\tret = spi_controller_resume(host);\n\tif (ret)\n\t\tclk_disable_unprepare(spi->clk);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sifive_spi_pm_ops,\n\t\t\t\tsifive_spi_suspend, sifive_spi_resume);\n\n\nstatic const struct of_device_id sifive_spi_of_match[] = {\n\t{ .compatible = \"sifive,spi0\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sifive_spi_of_match);\n\nstatic struct platform_driver sifive_spi_driver = {\n\t.probe = sifive_spi_probe,\n\t.remove_new = sifive_spi_remove,\n\t.driver = {\n\t\t.name = SIFIVE_SPI_DRIVER_NAME,\n\t\t.pm = &sifive_spi_pm_ops,\n\t\t.of_match_table = sifive_spi_of_match,\n\t},\n};\nmodule_platform_driver(sifive_spi_driver);\n\nMODULE_AUTHOR(\"SiFive, Inc. <sifive@sifive.com>\");\nMODULE_DESCRIPTION(\"SiFive SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}