{
  "module_name": "spi-sprd.c",
  "hash_id": "cd3e179333ac855c6dd38cefd34022b5db49a47f2d21864edfccc595cb0f76ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sprd.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma/sprd-dma.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n\n#define SPRD_SPI_TXD\t\t\t0x0\n#define SPRD_SPI_CLKD\t\t\t0x4\n#define SPRD_SPI_CTL0\t\t\t0x8\n#define SPRD_SPI_CTL1\t\t\t0xc\n#define SPRD_SPI_CTL2\t\t\t0x10\n#define SPRD_SPI_CTL3\t\t\t0x14\n#define SPRD_SPI_CTL4\t\t\t0x18\n#define SPRD_SPI_CTL5\t\t\t0x1c\n#define SPRD_SPI_INT_EN\t\t\t0x20\n#define SPRD_SPI_INT_CLR\t\t0x24\n#define SPRD_SPI_INT_RAW_STS\t\t0x28\n#define SPRD_SPI_INT_MASK_STS\t\t0x2c\n#define SPRD_SPI_STS1\t\t\t0x30\n#define SPRD_SPI_STS2\t\t\t0x34\n#define SPRD_SPI_DSP_WAIT\t\t0x38\n#define SPRD_SPI_STS3\t\t\t0x3c\n#define SPRD_SPI_CTL6\t\t\t0x40\n#define SPRD_SPI_STS4\t\t\t0x44\n#define SPRD_SPI_FIFO_RST\t\t0x48\n#define SPRD_SPI_CTL7\t\t\t0x4c\n#define SPRD_SPI_STS5\t\t\t0x50\n#define SPRD_SPI_CTL8\t\t\t0x54\n#define SPRD_SPI_CTL9\t\t\t0x58\n#define SPRD_SPI_CTL10\t\t\t0x5c\n#define SPRD_SPI_CTL11\t\t\t0x60\n#define SPRD_SPI_CTL12\t\t\t0x64\n#define SPRD_SPI_STS6\t\t\t0x68\n#define SPRD_SPI_STS7\t\t\t0x6c\n#define SPRD_SPI_STS8\t\t\t0x70\n#define SPRD_SPI_STS9\t\t\t0x74\n\n \n#define SPRD_SPI_SCK_REV\t\tBIT(13)\n#define SPRD_SPI_NG_TX\t\t\tBIT(1)\n#define SPRD_SPI_NG_RX\t\t\tBIT(0)\n#define SPRD_SPI_CHNL_LEN_MASK\t\tGENMASK(4, 0)\n#define SPRD_SPI_CSN_MASK\t\tGENMASK(11, 8)\n#define SPRD_SPI_CS0_VALID\t\tBIT(8)\n\n \n#define SPRD_SPI_TX_END_INT_EN\t\tBIT(8)\n#define SPRD_SPI_RX_END_INT_EN\t\tBIT(9)\n\n \n#define SPRD_SPI_TX_END_RAW\t\tBIT(8)\n#define SPRD_SPI_RX_END_RAW\t\tBIT(9)\n\n \n#define SPRD_SPI_TX_END_CLR\t\tBIT(8)\n#define SPRD_SPI_RX_END_CLR\t\tBIT(9)\n\n \n#define SPRD_SPI_MASK_RX_END\t\tBIT(9)\n#define SPRD_SPI_MASK_TX_END\t\tBIT(8)\n\n \n#define SPRD_SPI_TX_BUSY\t\tBIT(8)\n\n \n#define SPRD_SPI_RX_MODE\t\tBIT(12)\n#define SPRD_SPI_TX_MODE\t\tBIT(13)\n#define SPRD_SPI_RTX_MD_MASK\t\tGENMASK(13, 12)\n\n \n#define SPRD_SPI_DMA_EN\t\t\tBIT(6)\n\n \n#define SPRD_SPI_START_RX\t\tBIT(9)\n#define SPRD_SPI_ONLY_RECV_MASK\t\tGENMASK(8, 0)\n\n \n#define SPRD_SPI_RX_END_INT_CLR\t\tBIT(9)\n#define SPRD_SPI_TX_END_INT_CLR\t\tBIT(8)\n\n \n#define SPRD_SPI_RX_END_IRQ\t\tBIT(9)\n#define SPRD_SPI_TX_END_IRQ\t\tBIT(8)\n\n \n#define SPRD_SPI_SW_RX_REQ\t\tBIT(0)\n#define SPRD_SPI_SW_TX_REQ\t\tBIT(1)\n\n \n#define SPRD_SPI_DATA_LINE2_EN\t\tBIT(15)\n#define SPRD_SPI_MODE_MASK\t\tGENMASK(5, 3)\n#define SPRD_SPI_MODE_OFFSET\t\t3\n#define SPRD_SPI_3WIRE_MODE\t\t4\n#define SPRD_SPI_4WIRE_MODE\t\t0\n\n \n#define SPRD_SPI_TX_MAX_LEN_MASK\tGENMASK(19, 0)\n#define SPRD_SPI_TX_LEN_H_MASK\t\tGENMASK(3, 0)\n#define SPRD_SPI_TX_LEN_H_OFFSET\t16\n\n \n#define SPRD_SPI_TX_LEN_L_MASK\t\tGENMASK(15, 0)\n\n \n#define SPRD_SPI_RX_MAX_LEN_MASK\tGENMASK(19, 0)\n#define SPRD_SPI_RX_LEN_H_MASK\t\tGENMASK(3, 0)\n#define SPRD_SPI_RX_LEN_H_OFFSET\t16\n\n \n#define SPRD_SPI_RX_LEN_L_MASK\t\tGENMASK(15, 0)\n\n \n#define SPRD_SPI_MIN_DELAY_CYCLE\t14\n#define SPRD_SPI_MAX_DELAY_CYCLE\t130\n\n#define SPRD_SPI_FIFO_SIZE\t\t32\n#define SPRD_SPI_CHIP_CS_NUM\t\t0x4\n#define SPRD_SPI_CHNL_LEN\t\t2\n#define SPRD_SPI_DEFAULT_SOURCE\t\t26000000\n#define SPRD_SPI_MAX_SPEED_HZ\t\t48000000\n#define SPRD_SPI_AUTOSUSPEND_DELAY\t100\n#define SPRD_SPI_DMA_STEP\t\t8\n\nenum sprd_spi_dma_channel {\n\tSPRD_SPI_RX,\n\tSPRD_SPI_TX,\n\tSPRD_SPI_MAX,\n};\n\nstruct sprd_spi_dma {\n\tbool enable;\n\tstruct dma_chan *dma_chan[SPRD_SPI_MAX];\n\tenum dma_slave_buswidth width;\n\tu32 fragmens_len;\n\tu32 rx_len;\n};\n\nstruct sprd_spi {\n\tvoid __iomem *base;\n\tphys_addr_t phy_base;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tint irq;\n\tu32 src_clk;\n\tu32 hw_mode;\n\tu32 trans_len;\n\tu32 trans_mode;\n\tu32 word_delay;\n\tu32 hw_speed_hz;\n\tu32 len;\n\tint status;\n\tstruct sprd_spi_dma dma;\n\tstruct completion xfer_completion;\n\tconst void *tx_buf;\n\tvoid *rx_buf;\n\tint (*read_bufs)(struct sprd_spi *ss, u32 len);\n\tint (*write_bufs)(struct sprd_spi *ss, u32 len);\n};\n\nstatic u32 sprd_spi_transfer_max_timeout(struct sprd_spi *ss,\n\t\t\t\t\t struct spi_transfer *t)\n{\n\t \n\tu32 size = t->bits_per_word * SPRD_SPI_FIFO_SIZE;\n\tu32 bit_time_us = DIV_ROUND_UP(USEC_PER_SEC, ss->hw_speed_hz);\n\tu32 total_time_us = size * bit_time_us;\n\t \n\tu32 interval_cycle = SPRD_SPI_FIFO_SIZE * ss->word_delay;\n\tu32 interval_time_us = DIV_ROUND_UP(interval_cycle * USEC_PER_SEC,\n\t\t\t\t\t    ss->src_clk);\n\n\treturn total_time_us + interval_time_us;\n}\n\nstatic int sprd_spi_wait_for_tx_end(struct sprd_spi *ss, struct spi_transfer *t)\n{\n\tu32 val, us;\n\tint ret;\n\n\tus = sprd_spi_transfer_max_timeout(ss, t);\n\tret = readl_relaxed_poll_timeout(ss->base + SPRD_SPI_INT_RAW_STS, val,\n\t\t\t\t\t val & SPRD_SPI_TX_END_IRQ, 0, us);\n\tif (ret) {\n\t\tdev_err(ss->dev, \"SPI error, spi send timeout!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = readl_relaxed_poll_timeout(ss->base + SPRD_SPI_STS2, val,\n\t\t\t\t\t !(val & SPRD_SPI_TX_BUSY), 0, us);\n\tif (ret) {\n\t\tdev_err(ss->dev, \"SPI error, spi busy timeout!\\n\");\n\t\treturn ret;\n\t}\n\n\twritel_relaxed(SPRD_SPI_TX_END_INT_CLR, ss->base + SPRD_SPI_INT_CLR);\n\n\treturn 0;\n}\n\nstatic int sprd_spi_wait_for_rx_end(struct sprd_spi *ss, struct spi_transfer *t)\n{\n\tu32 val, us;\n\tint ret;\n\n\tus = sprd_spi_transfer_max_timeout(ss, t);\n\tret = readl_relaxed_poll_timeout(ss->base + SPRD_SPI_INT_RAW_STS, val,\n\t\t\t\t\t val & SPRD_SPI_RX_END_IRQ, 0, us);\n\tif (ret) {\n\t\tdev_err(ss->dev, \"SPI error, spi rx timeout!\\n\");\n\t\treturn ret;\n\t}\n\n\twritel_relaxed(SPRD_SPI_RX_END_INT_CLR, ss->base + SPRD_SPI_INT_CLR);\n\n\treturn 0;\n}\n\nstatic void sprd_spi_tx_req(struct sprd_spi *ss)\n{\n\twritel_relaxed(SPRD_SPI_SW_TX_REQ, ss->base + SPRD_SPI_CTL12);\n}\n\nstatic void sprd_spi_rx_req(struct sprd_spi *ss)\n{\n\twritel_relaxed(SPRD_SPI_SW_RX_REQ, ss->base + SPRD_SPI_CTL12);\n}\n\nstatic void sprd_spi_enter_idle(struct sprd_spi *ss)\n{\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_CTL1);\n\n\tval &= ~SPRD_SPI_RTX_MD_MASK;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL1);\n}\n\nstatic void sprd_spi_set_transfer_bits(struct sprd_spi *ss, u32 bits)\n{\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_CTL0);\n\n\t \n\tval &= ~(SPRD_SPI_CHNL_LEN_MASK << SPRD_SPI_CHNL_LEN);\n\tval |= bits << SPRD_SPI_CHNL_LEN;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL0);\n}\n\nstatic void sprd_spi_set_tx_length(struct sprd_spi *ss, u32 length)\n{\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_CTL8);\n\n\tlength &= SPRD_SPI_TX_MAX_LEN_MASK;\n\tval &= ~SPRD_SPI_TX_LEN_H_MASK;\n\tval |= length >> SPRD_SPI_TX_LEN_H_OFFSET;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL8);\n\n\tval = length & SPRD_SPI_TX_LEN_L_MASK;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL9);\n}\n\nstatic void sprd_spi_set_rx_length(struct sprd_spi *ss, u32 length)\n{\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_CTL10);\n\n\tlength &= SPRD_SPI_RX_MAX_LEN_MASK;\n\tval &= ~SPRD_SPI_RX_LEN_H_MASK;\n\tval |= length >> SPRD_SPI_RX_LEN_H_OFFSET;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL10);\n\n\tval = length & SPRD_SPI_RX_LEN_L_MASK;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL11);\n}\n\nstatic void sprd_spi_chipselect(struct spi_device *sdev, bool cs)\n{\n\tstruct spi_controller *sctlr = sdev->controller;\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sctlr);\n\tu32 val;\n\n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL0);\n\t \n\tif (!cs) {\n\t\tval &= ~SPRD_SPI_CS0_VALID;\n\t\twritel_relaxed(val, ss->base + SPRD_SPI_CTL0);\n\t} else {\n\t\tval |= SPRD_SPI_CSN_MASK;\n\t\twritel_relaxed(val, ss->base + SPRD_SPI_CTL0);\n\t}\n}\n\nstatic int sprd_spi_write_only_receive(struct sprd_spi *ss, u32 len)\n{\n\tu32 val;\n\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL4);\n\tval &= ~(SPRD_SPI_START_RX | SPRD_SPI_ONLY_RECV_MASK);\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL4);\n\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL4);\n\tval |= len & SPRD_SPI_ONLY_RECV_MASK;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL4);\n\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL4);\n\tval |= SPRD_SPI_START_RX;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL4);\n\n\treturn len;\n}\n\nstatic int sprd_spi_write_bufs_u8(struct sprd_spi *ss, u32 len)\n{\n\tu8 *tx_p = (u8 *)ss->tx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twriteb_relaxed(tx_p[i], ss->base + SPRD_SPI_TXD);\n\n\tss->tx_buf += i;\n\treturn i;\n}\n\nstatic int sprd_spi_write_bufs_u16(struct sprd_spi *ss, u32 len)\n{\n\tu16 *tx_p = (u16 *)ss->tx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twritew_relaxed(tx_p[i], ss->base + SPRD_SPI_TXD);\n\n\tss->tx_buf += i << 1;\n\treturn i << 1;\n}\n\nstatic int sprd_spi_write_bufs_u32(struct sprd_spi *ss, u32 len)\n{\n\tu32 *tx_p = (u32 *)ss->tx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twritel_relaxed(tx_p[i], ss->base + SPRD_SPI_TXD);\n\n\tss->tx_buf += i << 2;\n\treturn i << 2;\n}\n\nstatic int sprd_spi_read_bufs_u8(struct sprd_spi *ss, u32 len)\n{\n\tu8 *rx_p = (u8 *)ss->rx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\trx_p[i] = readb_relaxed(ss->base + SPRD_SPI_TXD);\n\n\tss->rx_buf += i;\n\treturn i;\n}\n\nstatic int sprd_spi_read_bufs_u16(struct sprd_spi *ss, u32 len)\n{\n\tu16 *rx_p = (u16 *)ss->rx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\trx_p[i] = readw_relaxed(ss->base + SPRD_SPI_TXD);\n\n\tss->rx_buf += i << 1;\n\treturn i << 1;\n}\n\nstatic int sprd_spi_read_bufs_u32(struct sprd_spi *ss, u32 len)\n{\n\tu32 *rx_p = (u32 *)ss->rx_buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\trx_p[i] = readl_relaxed(ss->base + SPRD_SPI_TXD);\n\n\tss->rx_buf += i << 2;\n\treturn i << 2;\n}\n\nstatic int sprd_spi_txrx_bufs(struct spi_device *sdev, struct spi_transfer *t)\n{\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sdev->controller);\n\tu32 trans_len = ss->trans_len, len;\n\tint ret, write_size = 0, read_size = 0;\n\n\twhile (trans_len) {\n\t\tlen = trans_len > SPRD_SPI_FIFO_SIZE ? SPRD_SPI_FIFO_SIZE :\n\t\t\ttrans_len;\n\t\tif (ss->trans_mode & SPRD_SPI_TX_MODE) {\n\t\t\tsprd_spi_set_tx_length(ss, len);\n\t\t\twrite_size += ss->write_bufs(ss, len);\n\n\t\t\t \n\t\t\tif (ss->hw_mode & SPI_3WIRE || ss->hw_mode & SPI_TX_DUAL)\n\t\t\t\tsprd_spi_tx_req(ss);\n\n\t\t\tret = sprd_spi_wait_for_tx_end(ss, t);\n\t\t} else {\n\t\t\tsprd_spi_set_rx_length(ss, len);\n\n\t\t\t \n\t\t\tif (ss->hw_mode & SPI_3WIRE || ss->hw_mode & SPI_TX_DUAL)\n\t\t\t\tsprd_spi_rx_req(ss);\n\t\t\telse\n\t\t\t\twrite_size += ss->write_bufs(ss, len);\n\n\t\t\tret = sprd_spi_wait_for_rx_end(ss, t);\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto complete;\n\n\t\tif (ss->trans_mode & SPRD_SPI_RX_MODE)\n\t\t\tread_size += ss->read_bufs(ss, len);\n\n\t\ttrans_len -= len;\n\t}\n\n\tif (ss->trans_mode & SPRD_SPI_TX_MODE)\n\t\tret = write_size;\n\telse\n\t\tret = read_size;\ncomplete:\n\tsprd_spi_enter_idle(ss);\n\n\treturn ret;\n}\n\nstatic void sprd_spi_irq_enable(struct sprd_spi *ss)\n{\n\tu32 val;\n\n\t \n\twritel_relaxed(SPRD_SPI_TX_END_CLR | SPRD_SPI_RX_END_CLR,\n\t\tss->base + SPRD_SPI_INT_CLR);\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_INT_EN);\n\twritel_relaxed(val | SPRD_SPI_TX_END_INT_EN |\n\t\t       SPRD_SPI_RX_END_INT_EN,\n\t\t       ss->base + SPRD_SPI_INT_EN);\n}\n\nstatic void sprd_spi_irq_disable(struct sprd_spi *ss)\n{\n\twritel_relaxed(0, ss->base + SPRD_SPI_INT_EN);\n}\n\nstatic void sprd_spi_dma_enable(struct sprd_spi *ss, bool enable)\n{\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_CTL2);\n\n\tif (enable)\n\t\tval |= SPRD_SPI_DMA_EN;\n\telse\n\t\tval &= ~SPRD_SPI_DMA_EN;\n\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL2);\n}\n\nstatic int sprd_spi_dma_submit(struct dma_chan *dma_chan,\n\t\t\t       struct dma_slave_config *c,\n\t\t\t       struct sg_table *sg,\n\t\t\t       enum dma_transfer_direction dir)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tunsigned long flags;\n\tint ret;\n\n\tret = dmaengine_slave_config(dma_chan, c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tflags = SPRD_DMA_FLAGS(SPRD_DMA_CHN_MODE_NONE, SPRD_DMA_NO_TRG,\n\t\t\t       SPRD_DMA_FRAG_REQ, SPRD_DMA_TRANS_INT);\n\tdesc = dmaengine_prep_slave_sg(dma_chan, sg->sgl, sg->nents, dir, flags);\n\tif (!desc)\n\t\treturn  -ENODEV;\n\n\tcookie = dmaengine_submit(desc);\n\tif (dma_submit_error(cookie))\n\t\treturn dma_submit_error(cookie);\n\n\tdma_async_issue_pending(dma_chan);\n\n\treturn 0;\n}\n\nstatic int sprd_spi_dma_rx_config(struct sprd_spi *ss, struct spi_transfer *t)\n{\n\tstruct dma_chan *dma_chan = ss->dma.dma_chan[SPRD_SPI_RX];\n\tstruct dma_slave_config config = {\n\t\t.src_addr = ss->phy_base,\n\t\t.src_addr_width = ss->dma.width,\n\t\t.dst_addr_width = ss->dma.width,\n\t\t.dst_maxburst = ss->dma.fragmens_len,\n\t};\n\tint ret;\n\n\tret = sprd_spi_dma_submit(dma_chan, &config, &t->rx_sg, DMA_DEV_TO_MEM);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ss->dma.rx_len;\n}\n\nstatic int sprd_spi_dma_tx_config(struct sprd_spi *ss, struct spi_transfer *t)\n{\n\tstruct dma_chan *dma_chan = ss->dma.dma_chan[SPRD_SPI_TX];\n\tstruct dma_slave_config config = {\n\t\t.dst_addr = ss->phy_base,\n\t\t.src_addr_width = ss->dma.width,\n\t\t.dst_addr_width = ss->dma.width,\n\t\t.src_maxburst = ss->dma.fragmens_len,\n\t};\n\tint ret;\n\n\tret = sprd_spi_dma_submit(dma_chan, &config, &t->tx_sg, DMA_MEM_TO_DEV);\n\tif (ret)\n\t\treturn ret;\n\n\treturn t->len;\n}\n\nstatic int sprd_spi_dma_request(struct sprd_spi *ss)\n{\n\tss->dma.dma_chan[SPRD_SPI_RX] = dma_request_chan(ss->dev, \"rx_chn\");\n\tif (IS_ERR_OR_NULL(ss->dma.dma_chan[SPRD_SPI_RX]))\n\t\treturn dev_err_probe(ss->dev, PTR_ERR(ss->dma.dma_chan[SPRD_SPI_RX]),\n\t\t\t\t     \"request RX DMA channel failed!\\n\");\n\n\tss->dma.dma_chan[SPRD_SPI_TX]  = dma_request_chan(ss->dev, \"tx_chn\");\n\tif (IS_ERR_OR_NULL(ss->dma.dma_chan[SPRD_SPI_TX])) {\n\t\tdma_release_channel(ss->dma.dma_chan[SPRD_SPI_RX]);\n\t\treturn dev_err_probe(ss->dev, PTR_ERR(ss->dma.dma_chan[SPRD_SPI_TX]),\n\t\t\t\t     \"request TX DMA channel failed!\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_spi_dma_release(struct sprd_spi *ss)\n{\n\tif (ss->dma.dma_chan[SPRD_SPI_RX])\n\t\tdma_release_channel(ss->dma.dma_chan[SPRD_SPI_RX]);\n\n\tif (ss->dma.dma_chan[SPRD_SPI_TX])\n\t\tdma_release_channel(ss->dma.dma_chan[SPRD_SPI_TX]);\n}\n\nstatic int sprd_spi_dma_txrx_bufs(struct spi_device *sdev,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct sprd_spi *ss = spi_master_get_devdata(sdev->master);\n\tu32 trans_len = ss->trans_len;\n\tint ret, write_size = 0;\n\n\treinit_completion(&ss->xfer_completion);\n\tsprd_spi_irq_enable(ss);\n\tif (ss->trans_mode & SPRD_SPI_TX_MODE) {\n\t\twrite_size = sprd_spi_dma_tx_config(ss, t);\n\t\tsprd_spi_set_tx_length(ss, trans_len);\n\n\t\t \n\t\tif (ss->hw_mode & SPI_3WIRE || ss->hw_mode & SPI_TX_DUAL)\n\t\t\tsprd_spi_tx_req(ss);\n\t} else {\n\t\tsprd_spi_set_rx_length(ss, trans_len);\n\n\t\t \n\t\tif (ss->hw_mode & SPI_3WIRE || ss->hw_mode & SPI_TX_DUAL)\n\t\t\tsprd_spi_rx_req(ss);\n\t\telse\n\t\t\twrite_size = ss->write_bufs(ss, trans_len);\n\t}\n\n\tif (write_size < 0) {\n\t\tret = write_size;\n\t\tdev_err(ss->dev, \"failed to write, ret = %d\\n\", ret);\n\t\tgoto trans_complete;\n\t}\n\n\tif (ss->trans_mode & SPRD_SPI_RX_MODE) {\n\t\t \n\t\tss->dma.rx_len = t->len > ss->dma.fragmens_len ?\n\t\t\t(t->len - t->len % ss->dma.fragmens_len) :\n\t\t\t t->len;\n\t\tret = sprd_spi_dma_rx_config(ss, t);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&sdev->dev,\n\t\t\t\t\"failed to configure rx DMA, ret = %d\\n\", ret);\n\t\t\tgoto trans_complete;\n\t\t}\n\t}\n\n\tsprd_spi_dma_enable(ss, true);\n\twait_for_completion(&(ss->xfer_completion));\n\n\tif (ss->trans_mode & SPRD_SPI_TX_MODE)\n\t\tret = write_size;\n\telse\n\t\tret = ss->dma.rx_len;\n\ntrans_complete:\n\tsprd_spi_dma_enable(ss, false);\n\tsprd_spi_enter_idle(ss);\n\tsprd_spi_irq_disable(ss);\n\n\treturn ret;\n}\n\nstatic void sprd_spi_set_speed(struct sprd_spi *ss, u32 speed_hz)\n{\n\t \n\tu32 clk_div = DIV_ROUND_UP(ss->src_clk, speed_hz << 1) - 1;\n\n\t \n\tss->hw_speed_hz = (ss->src_clk >> 1) / (clk_div + 1);\n\twritel_relaxed(clk_div, ss->base + SPRD_SPI_CLKD);\n}\n\nstatic int sprd_spi_init_hw(struct sprd_spi *ss, struct spi_transfer *t)\n{\n\tstruct spi_delay *d = &t->word_delay;\n\tu16 word_delay, interval;\n\tu32 val;\n\n\tif (d->unit != SPI_DELAY_UNIT_SCK)\n\t\treturn -EINVAL;\n\n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL0);\n\tval &= ~(SPRD_SPI_SCK_REV | SPRD_SPI_NG_TX | SPRD_SPI_NG_RX);\n\t \n\tval |= ss->hw_mode & SPI_CPHA ? SPRD_SPI_NG_RX : SPRD_SPI_NG_TX;\n\tval |= ss->hw_mode & SPI_CPOL ? SPRD_SPI_SCK_REV : 0;\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL0);\n\n\t \n\tword_delay = clamp_t(u16, d->value, SPRD_SPI_MIN_DELAY_CYCLE,\n\t\t\t     SPRD_SPI_MAX_DELAY_CYCLE);\n\tinterval = DIV_ROUND_UP(word_delay - 10, 4);\n\tss->word_delay = interval * 4 + 10;\n\twritel_relaxed(interval, ss->base + SPRD_SPI_CTL5);\n\n\t \n\twritel_relaxed(1, ss->base + SPRD_SPI_FIFO_RST);\n\twritel_relaxed(0, ss->base + SPRD_SPI_FIFO_RST);\n\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL7);\n\tval &= ~SPRD_SPI_MODE_MASK;\n\n\tif (ss->hw_mode & SPI_3WIRE)\n\t\tval |= SPRD_SPI_3WIRE_MODE << SPRD_SPI_MODE_OFFSET;\n\telse\n\t\tval |= SPRD_SPI_4WIRE_MODE << SPRD_SPI_MODE_OFFSET;\n\n\tif (ss->hw_mode & SPI_TX_DUAL)\n\t\tval |= SPRD_SPI_DATA_LINE2_EN;\n\telse\n\t\tval &= ~SPRD_SPI_DATA_LINE2_EN;\n\n\twritel_relaxed(val, ss->base + SPRD_SPI_CTL7);\n\n\treturn 0;\n}\n\nstatic int sprd_spi_setup_transfer(struct spi_device *sdev,\n\t\t\t\t   struct spi_transfer *t)\n{\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sdev->controller);\n\tu8 bits_per_word = t->bits_per_word;\n\tu32 val, mode = 0;\n\tint ret;\n\n\tss->len = t->len;\n\tss->tx_buf = t->tx_buf;\n\tss->rx_buf = t->rx_buf;\n\n\tss->hw_mode = sdev->mode;\n\tret = sprd_spi_init_hw(ss, t);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsprd_spi_set_speed(ss, t->speed_hz);\n\tsprd_spi_set_transfer_bits(ss, bits_per_word);\n\n\tif (bits_per_word > 16)\n\t\tbits_per_word = round_up(bits_per_word, 16);\n\telse\n\t\tbits_per_word = round_up(bits_per_word, 8);\n\n\tswitch (bits_per_word) {\n\tcase 8:\n\t\tss->trans_len = t->len;\n\t\tss->read_bufs = sprd_spi_read_bufs_u8;\n\t\tss->write_bufs = sprd_spi_write_bufs_u8;\n\t\tss->dma.width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tss->dma.fragmens_len = SPRD_SPI_DMA_STEP;\n\t\tbreak;\n\tcase 16:\n\t\tss->trans_len = t->len >> 1;\n\t\tss->read_bufs = sprd_spi_read_bufs_u16;\n\t\tss->write_bufs = sprd_spi_write_bufs_u16;\n\t\tss->dma.width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tss->dma.fragmens_len = SPRD_SPI_DMA_STEP << 1;\n\t\tbreak;\n\tcase 32:\n\t\tss->trans_len = t->len >> 2;\n\t\tss->read_bufs = sprd_spi_read_bufs_u32;\n\t\tss->write_bufs = sprd_spi_write_bufs_u32;\n\t\tss->dma.width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tss->dma.fragmens_len = SPRD_SPI_DMA_STEP << 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = readl_relaxed(ss->base + SPRD_SPI_CTL1);\n\tval &= ~SPRD_SPI_RTX_MD_MASK;\n\tif (t->tx_buf)\n\t\tmode |= SPRD_SPI_TX_MODE;\n\tif (t->rx_buf)\n\t\tmode |= SPRD_SPI_RX_MODE;\n\n\twritel_relaxed(val | mode, ss->base + SPRD_SPI_CTL1);\n\n\tss->trans_mode = mode;\n\n\t \n\tif (ss->trans_mode == SPRD_SPI_RX_MODE)\n\t\tss->write_bufs = sprd_spi_write_only_receive;\n\n\treturn 0;\n}\n\nstatic int sprd_spi_transfer_one(struct spi_controller *sctlr,\n\t\t\t\t struct spi_device *sdev,\n\t\t\t\t struct spi_transfer *t)\n{\n\tint ret;\n\n\tret = sprd_spi_setup_transfer(sdev, t);\n\tif (ret)\n\t\tgoto setup_err;\n\n\tif (sctlr->can_dma(sctlr, sdev, t))\n\t\tret = sprd_spi_dma_txrx_bufs(sdev, t);\n\telse\n\t\tret = sprd_spi_txrx_bufs(sdev, t);\n\n\tif (ret == t->len)\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EREMOTEIO;\n\nsetup_err:\n\tspi_finalize_current_transfer(sctlr);\n\n\treturn ret;\n}\n\nstatic irqreturn_t sprd_spi_handle_irq(int irq, void *data)\n{\n\tstruct sprd_spi *ss = (struct sprd_spi *)data;\n\tu32 val = readl_relaxed(ss->base + SPRD_SPI_INT_MASK_STS);\n\n\tif (val & SPRD_SPI_MASK_TX_END) {\n\t\twritel_relaxed(SPRD_SPI_TX_END_CLR, ss->base + SPRD_SPI_INT_CLR);\n\t\tif (!(ss->trans_mode & SPRD_SPI_RX_MODE))\n\t\t\tcomplete(&ss->xfer_completion);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (val & SPRD_SPI_MASK_RX_END) {\n\t\twritel_relaxed(SPRD_SPI_RX_END_CLR, ss->base + SPRD_SPI_INT_CLR);\n\t\tif (ss->dma.rx_len < ss->len) {\n\t\t\tss->rx_buf += ss->dma.rx_len;\n\t\t\tss->dma.rx_len +=\n\t\t\t\tss->read_bufs(ss, ss->len - ss->dma.rx_len);\n\t\t}\n\t\tcomplete(&ss->xfer_completion);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int sprd_spi_irq_init(struct platform_device *pdev, struct sprd_spi *ss)\n{\n\tint ret;\n\n\tss->irq = platform_get_irq(pdev, 0);\n\tif (ss->irq < 0)\n\t\treturn ss->irq;\n\n\tret = devm_request_irq(&pdev->dev, ss->irq, sprd_spi_handle_irq,\n\t\t\t\t0, pdev->name, ss);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to request spi irq %d, ret = %d\\n\",\n\t\t\tss->irq, ret);\n\n\treturn ret;\n}\n\nstatic int sprd_spi_clk_init(struct platform_device *pdev, struct sprd_spi *ss)\n{\n\tstruct clk *clk_spi, *clk_parent;\n\n\tclk_spi = devm_clk_get(&pdev->dev, \"spi\");\n\tif (IS_ERR(clk_spi)) {\n\t\tdev_warn(&pdev->dev, \"can't get the spi clock\\n\");\n\t\tclk_spi = NULL;\n\t}\n\n\tclk_parent = devm_clk_get(&pdev->dev, \"source\");\n\tif (IS_ERR(clk_parent)) {\n\t\tdev_warn(&pdev->dev, \"can't get the source clock\\n\");\n\t\tclk_parent = NULL;\n\t}\n\n\tss->clk = devm_clk_get(&pdev->dev, \"enable\");\n\tif (IS_ERR(ss->clk)) {\n\t\tdev_err(&pdev->dev, \"can't get the enable clock\\n\");\n\t\treturn PTR_ERR(ss->clk);\n\t}\n\n\tif (!clk_set_parent(clk_spi, clk_parent))\n\t\tss->src_clk = clk_get_rate(clk_spi);\n\telse\n\t\tss->src_clk = SPRD_SPI_DEFAULT_SOURCE;\n\n\treturn 0;\n}\n\nstatic bool sprd_spi_can_dma(struct spi_controller *sctlr,\n\t\t\t     struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sctlr);\n\n\treturn ss->dma.enable && (t->len > SPRD_SPI_FIFO_SIZE);\n}\n\nstatic int sprd_spi_dma_init(struct platform_device *pdev, struct sprd_spi *ss)\n{\n\tint ret;\n\n\tret = sprd_spi_dma_request(ss);\n\tif (ret) {\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"failed to request dma, enter no dma mode, ret = %d\\n\",\n\t\t\t ret);\n\n\t\treturn 0;\n\t}\n\n\tss->dma.enable = true;\n\n\treturn 0;\n}\n\nstatic int sprd_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *sctlr;\n\tstruct resource *res;\n\tstruct sprd_spi *ss;\n\tint ret;\n\n\tpdev->id = of_alias_get_id(pdev->dev.of_node, \"spi\");\n\tsctlr = spi_alloc_master(&pdev->dev, sizeof(*ss));\n\tif (!sctlr)\n\t\treturn -ENOMEM;\n\n\tss = spi_controller_get_devdata(sctlr);\n\tss->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ss->base)) {\n\t\tret = PTR_ERR(ss->base);\n\t\tgoto free_controller;\n\t}\n\n\tss->phy_base = res->start;\n\tss->dev = &pdev->dev;\n\tsctlr->dev.of_node = pdev->dev.of_node;\n\tsctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_3WIRE | SPI_TX_DUAL;\n\tsctlr->bus_num = pdev->id;\n\tsctlr->set_cs = sprd_spi_chipselect;\n\tsctlr->transfer_one = sprd_spi_transfer_one;\n\tsctlr->can_dma = sprd_spi_can_dma;\n\tsctlr->auto_runtime_pm = true;\n\tsctlr->max_speed_hz = min_t(u32, ss->src_clk >> 1,\n\t\t\t\t    SPRD_SPI_MAX_SPEED_HZ);\n\n\tinit_completion(&ss->xfer_completion);\n\tplatform_set_drvdata(pdev, sctlr);\n\tret = sprd_spi_clk_init(pdev, ss);\n\tif (ret)\n\t\tgoto free_controller;\n\n\tret = sprd_spi_irq_init(pdev, ss);\n\tif (ret)\n\t\tgoto free_controller;\n\n\tret = sprd_spi_dma_init(pdev, ss);\n\tif (ret)\n\t\tgoto free_controller;\n\n\tret = clk_prepare_enable(ss->clk);\n\tif (ret)\n\t\tgoto release_dma;\n\n\tret = pm_runtime_set_active(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto disable_clk;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t SPRD_SPI_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to resume SPI controller\\n\");\n\t\tgoto err_rpm_put;\n\t}\n\n\tret = devm_spi_register_controller(&pdev->dev, sctlr);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\ndisable_clk:\n\tclk_disable_unprepare(ss->clk);\nrelease_dma:\n\tsprd_spi_dma_release(ss);\nfree_controller:\n\tspi_controller_put(sctlr);\n\n\treturn ret;\n}\n\nstatic void sprd_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *sctlr = platform_get_drvdata(pdev);\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sctlr);\n\tint ret;\n\n\tret = pm_runtime_get_sync(ss->dev);\n\tif (ret < 0)\n\t\tdev_err(ss->dev, \"failed to resume SPI controller\\n\");\n\n\tspi_controller_suspend(sctlr);\n\n\tif (ret >= 0) {\n\t\tif (ss->dma.enable)\n\t\t\tsprd_spi_dma_release(ss);\n\t\tclk_disable_unprepare(ss->clk);\n\t}\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused sprd_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *sctlr = dev_get_drvdata(dev);\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sctlr);\n\n\tif (ss->dma.enable)\n\t\tsprd_spi_dma_release(ss);\n\n\tclk_disable_unprepare(ss->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sprd_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *sctlr = dev_get_drvdata(dev);\n\tstruct sprd_spi *ss = spi_controller_get_devdata(sctlr);\n\tint ret;\n\n\tret = clk_prepare_enable(ss->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ss->dma.enable)\n\t\treturn 0;\n\n\tret = sprd_spi_dma_request(ss);\n\tif (ret)\n\t\tclk_disable_unprepare(ss->clk);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sprd_spi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sprd_spi_runtime_suspend,\n\t\t\t   sprd_spi_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id sprd_spi_of_match[] = {\n\t{ .compatible = \"sprd,sc9860-spi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sprd_spi_of_match);\n\nstatic struct platform_driver sprd_spi_driver = {\n\t.driver = {\n\t\t.name = \"sprd-spi\",\n\t\t.of_match_table = sprd_spi_of_match,\n\t\t.pm = &sprd_spi_pm_ops,\n\t},\n\t.probe = sprd_spi_probe,\n\t.remove_new = sprd_spi_remove,\n};\n\nmodule_platform_driver(sprd_spi_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum SPI Controller driver\");\nMODULE_AUTHOR(\"Lanqing Liu <lanqing.liu@spreadtrum.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}