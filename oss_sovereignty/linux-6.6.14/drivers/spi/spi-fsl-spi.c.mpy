{
  "module_name": "spi-fsl-spi.c",
  "hash_id": "1df47f2a873f5ca2edf653ab35bd010077b0e8cdd7bcf6275140c3960f0d56bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-spi.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fsl_devices.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/types.h>\n\n#ifdef CONFIG_FSL_SOC\n#include <sysdev/fsl_soc.h>\n#endif\n\n \n#define IMMR_SPI_CS_OFFSET 0x14c\n#define SPI_BOOT_SEL_BIT   0x80000000\n\n#include \"spi-fsl-lib.h\"\n#include \"spi-fsl-cpm.h\"\n#include \"spi-fsl-spi.h\"\n\n#define TYPE_FSL\t0\n#define TYPE_GRLIB\t1\n\nstruct fsl_spi_match_data {\n\tint type;\n};\n\nstatic struct fsl_spi_match_data of_fsl_spi_fsl_config = {\n\t.type = TYPE_FSL,\n};\n\nstatic struct fsl_spi_match_data of_fsl_spi_grlib_config = {\n\t.type = TYPE_GRLIB,\n};\n\nstatic const struct of_device_id of_fsl_spi_match[] = {\n\t{\n\t\t.compatible = \"fsl,spi\",\n\t\t.data = &of_fsl_spi_fsl_config,\n\t},\n\t{\n\t\t.compatible = \"aeroflexgaisler,spictrl\",\n\t\t.data = &of_fsl_spi_grlib_config,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_fsl_spi_match);\n\nstatic int fsl_spi_get_type(struct device *dev)\n{\n\tconst struct of_device_id *match;\n\n\tif (dev->of_node) {\n\t\tmatch = of_match_node(of_fsl_spi_match, dev->of_node);\n\t\tif (match && match->data)\n\t\t\treturn ((struct fsl_spi_match_data *)match->data)->type;\n\t}\n\treturn TYPE_FSL;\n}\n\nstatic void fsl_spi_change_mode(struct spi_device *spi)\n{\n\tstruct mpc8xxx_spi *mspi = spi_controller_get_devdata(spi->controller);\n\tstruct spi_mpc8xxx_cs *cs = spi->controller_state;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\t__be32 __iomem *mode = &reg_base->mode;\n\tunsigned long flags;\n\n\tif (cs->hw_mode == mpc8xxx_spi_read_reg(mode))\n\t\treturn;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tmpc8xxx_spi_write_reg(mode, cs->hw_mode & ~SPMODE_ENABLE);\n\n\t \n\tif (mspi->flags & SPI_CPM_MODE) {\n\t\tfsl_spi_cpm_reinit_txrx(mspi);\n\t}\n\tmpc8xxx_spi_write_reg(mode, cs->hw_mode);\n\tlocal_irq_restore(flags);\n}\n\nstatic void fsl_spi_qe_cpu_set_shifts(u32 *rx_shift, u32 *tx_shift,\n\t\t\t\t      int bits_per_word, int msb_first)\n{\n\t*rx_shift = 0;\n\t*tx_shift = 0;\n\tif (msb_first) {\n\t\tif (bits_per_word <= 8) {\n\t\t\t*rx_shift = 16;\n\t\t\t*tx_shift = 24;\n\t\t} else if (bits_per_word <= 16) {\n\t\t\t*rx_shift = 16;\n\t\t\t*tx_shift = 16;\n\t\t}\n\t} else {\n\t\tif (bits_per_word <= 8)\n\t\t\t*rx_shift = 8;\n\t}\n}\n\nstatic void fsl_spi_grlib_set_shifts(u32 *rx_shift, u32 *tx_shift,\n\t\t\t\t     int bits_per_word, int msb_first)\n{\n\t*rx_shift = 0;\n\t*tx_shift = 0;\n\tif (bits_per_word <= 16) {\n\t\tif (msb_first) {\n\t\t\t*rx_shift = 16;  \n\t\t\t*tx_shift = 32 - bits_per_word;  \n\t\t} else {\n\t\t\t*rx_shift = 16 - bits_per_word;  \n\t\t}\n\t}\n}\n\nstatic void mspi_apply_cpu_mode_quirks(struct spi_mpc8xxx_cs *cs,\n\t\t\t\t       struct spi_device *spi,\n\t\t\t\t       struct mpc8xxx_spi *mpc8xxx_spi,\n\t\t\t\t       int bits_per_word)\n{\n\tcs->rx_shift = 0;\n\tcs->tx_shift = 0;\n\tif (bits_per_word <= 8) {\n\t\tcs->get_rx = mpc8xxx_spi_rx_buf_u8;\n\t\tcs->get_tx = mpc8xxx_spi_tx_buf_u8;\n\t} else if (bits_per_word <= 16) {\n\t\tcs->get_rx = mpc8xxx_spi_rx_buf_u16;\n\t\tcs->get_tx = mpc8xxx_spi_tx_buf_u16;\n\t} else if (bits_per_word <= 32) {\n\t\tcs->get_rx = mpc8xxx_spi_rx_buf_u32;\n\t\tcs->get_tx = mpc8xxx_spi_tx_buf_u32;\n\t}\n\n\tif (mpc8xxx_spi->set_shifts)\n\t\tmpc8xxx_spi->set_shifts(&cs->rx_shift, &cs->tx_shift,\n\t\t\t\t\tbits_per_word,\n\t\t\t\t\t!(spi->mode & SPI_LSB_FIRST));\n\n\tmpc8xxx_spi->rx_shift = cs->rx_shift;\n\tmpc8xxx_spi->tx_shift = cs->tx_shift;\n\tmpc8xxx_spi->get_rx = cs->get_rx;\n\tmpc8xxx_spi->get_tx = cs->get_tx;\n}\n\nstatic int fsl_spi_setup_transfer(struct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *t)\n{\n\tstruct mpc8xxx_spi *mpc8xxx_spi;\n\tint bits_per_word = 0;\n\tu8 pm;\n\tu32 hz = 0;\n\tstruct spi_mpc8xxx_cs\t*cs = spi->controller_state;\n\n\tmpc8xxx_spi = spi_controller_get_devdata(spi->controller);\n\n\tif (t) {\n\t\tbits_per_word = t->bits_per_word;\n\t\thz = t->speed_hz;\n\t}\n\n\t \n\tif (!bits_per_word)\n\t\tbits_per_word = spi->bits_per_word;\n\n\tif (!hz)\n\t\thz = spi->max_speed_hz;\n\n\tif (!(mpc8xxx_spi->flags & SPI_CPM_MODE))\n\t\tmspi_apply_cpu_mode_quirks(cs, spi, mpc8xxx_spi, bits_per_word);\n\n\tif (bits_per_word == 32)\n\t\tbits_per_word = 0;\n\telse\n\t\tbits_per_word = bits_per_word - 1;\n\n\t \n\tcs->hw_mode &= ~(SPMODE_LEN(0xF) | SPMODE_DIV16\n\t\t\t\t  | SPMODE_PM(0xF));\n\n\tcs->hw_mode |= SPMODE_LEN(bits_per_word);\n\n\tif ((mpc8xxx_spi->spibrg / hz) > 64) {\n\t\tcs->hw_mode |= SPMODE_DIV16;\n\t\tpm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;\n\t\tWARN_ONCE(pm > 16,\n\t\t\t  \"%s: Requested speed is too low: %d Hz. Will use %d Hz instead.\\n\",\n\t\t\t  dev_name(&spi->dev), hz, mpc8xxx_spi->spibrg / 1024);\n\t\tif (pm > 16)\n\t\t\tpm = 16;\n\t} else {\n\t\tpm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;\n\t}\n\tif (pm)\n\t\tpm--;\n\n\tcs->hw_mode |= SPMODE_PM(pm);\n\n\tfsl_spi_change_mode(spi);\n\treturn 0;\n}\n\nstatic int fsl_spi_cpu_bufs(struct mpc8xxx_spi *mspi,\n\t\t\t\tstruct spi_transfer *t, unsigned int len)\n{\n\tu32 word;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\tmspi->count = len;\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);\n\n\t \n\tword = mspi->get_tx(mspi);\n\tmpc8xxx_spi_write_reg(&reg_base->transmit, word);\n\n\treturn 0;\n}\n\nstatic int fsl_spi_bufs(struct spi_device *spi, struct spi_transfer *t,\n\t\t\t    bool is_dma_mapped)\n{\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(spi->controller);\n\tstruct fsl_spi_reg __iomem *reg_base;\n\tunsigned int len = t->len;\n\tu8 bits_per_word;\n\tint ret;\n\n\treg_base = mpc8xxx_spi->reg_base;\n\tbits_per_word = spi->bits_per_word;\n\tif (t->bits_per_word)\n\t\tbits_per_word = t->bits_per_word;\n\n\tif (bits_per_word > 8)\n\t\tlen /= 2;\n\tif (bits_per_word > 16)\n\t\tlen /= 2;\n\n\tmpc8xxx_spi->tx = t->tx_buf;\n\tmpc8xxx_spi->rx = t->rx_buf;\n\n\treinit_completion(&mpc8xxx_spi->done);\n\n\tif (mpc8xxx_spi->flags & SPI_CPM_MODE)\n\t\tret = fsl_spi_cpm_bufs(mpc8xxx_spi, t, is_dma_mapped);\n\telse\n\t\tret = fsl_spi_cpu_bufs(mpc8xxx_spi, t, len);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&mpc8xxx_spi->done);\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->mask, 0);\n\n\tif (mpc8xxx_spi->flags & SPI_CPM_MODE)\n\t\tfsl_spi_cpm_bufs_complete(mpc8xxx_spi);\n\n\treturn mpc8xxx_spi->count;\n}\n\nstatic int fsl_spi_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t   struct spi_message *m)\n{\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(ctlr);\n\tstruct spi_transfer *t;\n\tstruct spi_transfer *first;\n\n\tfirst = list_first_entry(&m->transfers, struct spi_transfer,\n\t\t\t\t transfer_list);\n\n\t \n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (t->speed_hz != first->speed_hz) {\n\t\t\tdev_err(&m->spi->dev,\n\t\t\t\t\"speed_hz cannot change during message.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(mpc8xxx_spi->flags & SPI_CPM_MODE)) {\n\t\t\tif (t->len < 256 || t->bits_per_word != 8)\n\t\t\t\tcontinue;\n\t\t\tif ((t->len & 3) == 0)\n\t\t\t\tt->bits_per_word = 32;\n\t\t\telse if ((t->len & 1) == 0)\n\t\t\t\tt->bits_per_word = 16;\n\t\t} else {\n\t\t\t \n\t\t\tif (m->spi->mode & SPI_LSB_FIRST && t->bits_per_word > 8)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (t->bits_per_word == 16 || t->bits_per_word == 32)\n\t\t\t\tt->bits_per_word = 8;  \n\t\t\tif (t->bits_per_word == 8 && t->len >= 256 &&\n\t\t\t    (mpc8xxx_spi->flags & SPI_CPM1))\n\t\t\t\tt->bits_per_word = 16;\n\t\t}\n\t}\n\treturn fsl_spi_setup_transfer(m->spi, first);\n}\n\nstatic int fsl_spi_transfer_one(struct spi_controller *controller,\n\t\t\t\tstruct spi_device *spi,\n\t\t\t\tstruct spi_transfer *t)\n{\n\tint status;\n\n\tstatus = fsl_spi_setup_transfer(spi, t);\n\tif (status < 0)\n\t\treturn status;\n\tif (t->len)\n\t\tstatus = fsl_spi_bufs(spi, t, !!t->tx_dma || !!t->rx_dma);\n\tif (status > 0)\n\t\treturn -EMSGSIZE;\n\n\treturn status;\n}\n\nstatic int fsl_spi_unprepare_message(struct spi_controller *controller,\n\t\t\t\t     struct spi_message *msg)\n{\n\treturn fsl_spi_setup_transfer(msg->spi, NULL);\n}\n\nstatic int fsl_spi_setup(struct spi_device *spi)\n{\n\tstruct mpc8xxx_spi *mpc8xxx_spi;\n\tstruct fsl_spi_reg __iomem *reg_base;\n\tbool initial_setup = false;\n\tint retval;\n\tu32 hw_mode;\n\tstruct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);\n\n\tif (!spi->max_speed_hz)\n\t\treturn -EINVAL;\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tspi_set_ctldata(spi, cs);\n\t\tinitial_setup = true;\n\t}\n\tmpc8xxx_spi = spi_controller_get_devdata(spi->controller);\n\n\treg_base = mpc8xxx_spi->reg_base;\n\n\thw_mode = cs->hw_mode;  \n\tcs->hw_mode = mpc8xxx_spi_read_reg(&reg_base->mode);\n\t \n\tcs->hw_mode &= ~(SPMODE_CP_BEGIN_EDGECLK | SPMODE_CI_INACTIVEHIGH\n\t\t\t | SPMODE_REV | SPMODE_LOOP);\n\n\tif (spi->mode & SPI_CPHA)\n\t\tcs->hw_mode |= SPMODE_CP_BEGIN_EDGECLK;\n\tif (spi->mode & SPI_CPOL)\n\t\tcs->hw_mode |= SPMODE_CI_INACTIVEHIGH;\n\tif (!(spi->mode & SPI_LSB_FIRST))\n\t\tcs->hw_mode |= SPMODE_REV;\n\tif (spi->mode & SPI_LOOP)\n\t\tcs->hw_mode |= SPMODE_LOOP;\n\n\tretval = fsl_spi_setup_transfer(spi, NULL);\n\tif (retval < 0) {\n\t\tcs->hw_mode = hw_mode;  \n\t\tif (initial_setup)\n\t\t\tkfree(cs);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_spi_cleanup(struct spi_device *spi)\n{\n\tstruct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);\n\n\tkfree(cs);\n\tspi_set_ctldata(spi, NULL);\n}\n\nstatic void fsl_spi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)\n{\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\t \n\tif (events & SPIE_NE) {\n\t\tu32 rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);\n\n\t\tif (mspi->rx)\n\t\t\tmspi->get_rx(rx_data, mspi);\n\t}\n\n\tif ((events & SPIE_NF) == 0)\n\t\t \n\t\twhile (((events =\n\t\t\tmpc8xxx_spi_read_reg(&reg_base->event)) &\n\t\t\t\t\t\tSPIE_NF) == 0)\n\t\t\tcpu_relax();\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->event, events);\n\n\tmspi->count -= 1;\n\tif (mspi->count) {\n\t\tu32 word = mspi->get_tx(mspi);\n\n\t\tmpc8xxx_spi_write_reg(&reg_base->transmit, word);\n\t} else {\n\t\tcomplete(&mspi->done);\n\t}\n}\n\nstatic irqreturn_t fsl_spi_irq(s32 irq, void *context_data)\n{\n\tstruct mpc8xxx_spi *mspi = context_data;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 events;\n\tstruct fsl_spi_reg __iomem *reg_base = mspi->reg_base;\n\n\t \n\tevents = mpc8xxx_spi_read_reg(&reg_base->event);\n\tif (events)\n\t\tret = IRQ_HANDLED;\n\n\tdev_dbg(mspi->dev, \"%s: events %x\\n\", __func__, events);\n\n\tif (mspi->flags & SPI_CPM_MODE)\n\t\tfsl_spi_cpm_irq(mspi, events);\n\telse\n\t\tfsl_spi_cpu_irq(mspi, events);\n\n\treturn ret;\n}\n\nstatic void fsl_spi_grlib_cs_control(struct spi_device *spi, bool on)\n{\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(spi->controller);\n\tstruct fsl_spi_reg __iomem *reg_base = mpc8xxx_spi->reg_base;\n\tu32 slvsel;\n\tu16 cs = spi_get_chipselect(spi, 0);\n\n\tif (cs < mpc8xxx_spi->native_chipselects) {\n\t\tslvsel = mpc8xxx_spi_read_reg(&reg_base->slvsel);\n\t\tslvsel = on ? (slvsel | (1 << cs)) : (slvsel & ~(1 << cs));\n\t\tmpc8xxx_spi_write_reg(&reg_base->slvsel, slvsel);\n\t}\n}\n\nstatic void fsl_spi_grlib_probe(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(host);\n\tstruct fsl_spi_reg __iomem *reg_base = mpc8xxx_spi->reg_base;\n\tint mbits;\n\tu32 capabilities;\n\n\tcapabilities = mpc8xxx_spi_read_reg(&reg_base->cap);\n\n\tmpc8xxx_spi->set_shifts = fsl_spi_grlib_set_shifts;\n\tmbits = SPCAP_MAXWLEN(capabilities);\n\tif (mbits)\n\t\tmpc8xxx_spi->max_bits_per_word = mbits + 1;\n\n\tmpc8xxx_spi->native_chipselects = 0;\n\tif (SPCAP_SSEN(capabilities)) {\n\t\tmpc8xxx_spi->native_chipselects = SPCAP_SSSZ(capabilities);\n\t\tmpc8xxx_spi_write_reg(&reg_base->slvsel, 0xffffffff);\n\t}\n\thost->num_chipselect = mpc8xxx_spi->native_chipselects;\n\thost->set_cs = fsl_spi_grlib_cs_control;\n}\n\nstatic void fsl_spi_cs_control(struct spi_device *spi, bool on)\n{\n\tstruct device *dev = spi->dev.parent->parent;\n\tstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\n\tstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\n\n\tif (WARN_ON_ONCE(!pinfo->immr_spi_cs))\n\t\treturn;\n\tiowrite32be(on ? 0 : SPI_BOOT_SEL_BIT, pinfo->immr_spi_cs);\n}\n\nstatic struct spi_controller *fsl_spi_probe(struct device *dev,\n\t\tstruct resource *mem, unsigned int irq)\n{\n\tstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\n\tstruct spi_controller *host;\n\tstruct mpc8xxx_spi *mpc8xxx_spi;\n\tstruct fsl_spi_reg __iomem *reg_base;\n\tu32 regval;\n\tint ret = 0;\n\n\thost = spi_alloc_host(dev, sizeof(struct mpc8xxx_spi));\n\tif (host == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev_set_drvdata(dev, host);\n\n\tmpc8xxx_spi_probe(dev, mem, irq);\n\n\thost->setup = fsl_spi_setup;\n\thost->cleanup = fsl_spi_cleanup;\n\thost->prepare_message = fsl_spi_prepare_message;\n\thost->transfer_one = fsl_spi_transfer_one;\n\thost->unprepare_message = fsl_spi_unprepare_message;\n\thost->use_gpio_descriptors = true;\n\thost->set_cs = fsl_spi_cs_control;\n\n\tmpc8xxx_spi = spi_controller_get_devdata(host);\n\tmpc8xxx_spi->max_bits_per_word = 32;\n\tmpc8xxx_spi->type = fsl_spi_get_type(dev);\n\n\tret = fsl_spi_cpm_init(mpc8xxx_spi);\n\tif (ret)\n\t\tgoto err_cpm_init;\n\n\tmpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(mpc8xxx_spi->reg_base)) {\n\t\tret = PTR_ERR(mpc8xxx_spi->reg_base);\n\t\tgoto err_probe;\n\t}\n\n\tif (mpc8xxx_spi->type == TYPE_GRLIB)\n\t\tfsl_spi_grlib_probe(dev);\n\n\tif (mpc8xxx_spi->flags & SPI_CPM_MODE)\n\t\thost->bits_per_word_mask =\n\t\t\t(SPI_BPW_RANGE_MASK(4, 8) | SPI_BPW_MASK(16) | SPI_BPW_MASK(32));\n\telse\n\t\thost->bits_per_word_mask =\n\t\t\t(SPI_BPW_RANGE_MASK(4, 16) | SPI_BPW_MASK(32));\n\n\thost->bits_per_word_mask &=\n\t\tSPI_BPW_RANGE_MASK(1, mpc8xxx_spi->max_bits_per_word);\n\n\tif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)\n\t\tmpc8xxx_spi->set_shifts = fsl_spi_qe_cpu_set_shifts;\n\n\tif (mpc8xxx_spi->set_shifts)\n\t\t \n\t\tmpc8xxx_spi->set_shifts(&mpc8xxx_spi->rx_shift,\n\t\t\t\t\t&mpc8xxx_spi->tx_shift, 8, 1);\n\n\t \n\tret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_spi_irq,\n\t\t\t       0, \"fsl_spi\", mpc8xxx_spi);\n\n\tif (ret != 0)\n\t\tgoto err_probe;\n\n\treg_base = mpc8xxx_spi->reg_base;\n\n\t \n\tmpc8xxx_spi_write_reg(&reg_base->mode, 0);\n\tmpc8xxx_spi_write_reg(&reg_base->mask, 0);\n\tmpc8xxx_spi_write_reg(&reg_base->command, 0);\n\tmpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);\n\n\t \n\tregval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;\n\tif (mpc8xxx_spi->max_bits_per_word < 8) {\n\t\tregval &= ~SPMODE_LEN(0xF);\n\t\tregval |= SPMODE_LEN(mpc8xxx_spi->max_bits_per_word - 1);\n\t}\n\tif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)\n\t\tregval |= SPMODE_OP;\n\n\tmpc8xxx_spi_write_reg(&reg_base->mode, regval);\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret < 0)\n\t\tgoto err_probe;\n\n\tdev_info(dev, \"at 0x%p (irq = %d), %s mode\\n\", reg_base,\n\t\t mpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));\n\n\treturn host;\n\nerr_probe:\n\tfsl_spi_cpm_free(mpc8xxx_spi);\nerr_cpm_init:\n\tspi_controller_put(host);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic int of_fsl_spi_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct spi_controller *host;\n\tstruct resource mem;\n\tint irq, type;\n\tint ret;\n\tbool spisel_boot = false;\n#if IS_ENABLED(CONFIG_FSL_SOC)\n\tstruct mpc8xxx_spi_probe_info *pinfo = NULL;\n#endif\n\n\n\tret = of_mpc8xxx_spi_probe(ofdev);\n\tif (ret)\n\t\treturn ret;\n\n\ttype = fsl_spi_get_type(&ofdev->dev);\n\tif (type == TYPE_FSL) {\n\t\tstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\n#if IS_ENABLED(CONFIG_FSL_SOC)\n\t\tpinfo = to_of_pinfo(pdata);\n\n\t\tspisel_boot = of_property_read_bool(np, \"fsl,spisel_boot\");\n\t\tif (spisel_boot) {\n\t\t\tpinfo->immr_spi_cs = ioremap(get_immrbase() + IMMR_SPI_CS_OFFSET, 4);\n\t\t\tif (!pinfo->immr_spi_cs)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n#endif\n\t\t \n\t\tret = gpiod_count(dev, \"cs\");\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\tif (ret == 0 && !spisel_boot)\n\t\t\tpdata->max_chipselect = 1;\n\t\telse\n\t\t\tpdata->max_chipselect = ret + spisel_boot;\n\t}\n\n\tret = of_address_to_resource(np, 0, &mem);\n\tif (ret)\n\t\tgoto unmap_out;\n\n\tirq = platform_get_irq(ofdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto unmap_out;\n\t}\n\n\thost = fsl_spi_probe(dev, &mem, irq);\n\n\treturn PTR_ERR_OR_ZERO(host);\n\nunmap_out:\n#if IS_ENABLED(CONFIG_FSL_SOC)\n\tif (spisel_boot)\n\t\tiounmap(pinfo->immr_spi_cs);\n#endif\n\treturn ret;\n}\n\nstatic void of_fsl_spi_remove(struct platform_device *ofdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(ofdev);\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(host);\n\n\tfsl_spi_cpm_free(mpc8xxx_spi);\n}\n\nstatic struct platform_driver of_fsl_spi_driver = {\n\t.driver = {\n\t\t.name = \"fsl_spi\",\n\t\t.of_match_table = of_fsl_spi_match,\n\t},\n\t.probe\t\t= of_fsl_spi_probe,\n\t.remove_new\t= of_fsl_spi_remove,\n};\n\n#ifdef CONFIG_MPC832x_RDB\n \nstatic int plat_mpc8xxx_spi_probe(struct platform_device *pdev)\n{\n\tstruct resource *mem;\n\tint irq;\n\tstruct spi_controller *host;\n\n\tif (!dev_get_platdata(&pdev->dev))\n\t\treturn -EINVAL;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = fsl_spi_probe(&pdev->dev, mem, irq);\n\treturn PTR_ERR_OR_ZERO(host);\n}\n\nstatic void plat_mpc8xxx_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *host = platform_get_drvdata(pdev);\n\tstruct mpc8xxx_spi *mpc8xxx_spi = spi_controller_get_devdata(host);\n\n\tfsl_spi_cpm_free(mpc8xxx_spi);\n}\n\nMODULE_ALIAS(\"platform:mpc8xxx_spi\");\nstatic struct platform_driver mpc8xxx_spi_driver = {\n\t.probe = plat_mpc8xxx_spi_probe,\n\t.remove_new = plat_mpc8xxx_spi_remove,\n\t.driver = {\n\t\t.name = \"mpc8xxx_spi\",\n\t},\n};\n\nstatic bool legacy_driver_failed;\n\nstatic void __init legacy_driver_register(void)\n{\n\tlegacy_driver_failed = platform_driver_register(&mpc8xxx_spi_driver);\n}\n\nstatic void __exit legacy_driver_unregister(void)\n{\n\tif (legacy_driver_failed)\n\t\treturn;\n\tplatform_driver_unregister(&mpc8xxx_spi_driver);\n}\n#else\nstatic void __init legacy_driver_register(void) {}\nstatic void __exit legacy_driver_unregister(void) {}\n#endif  \n\nstatic int __init fsl_spi_init(void)\n{\n\tlegacy_driver_register();\n\treturn platform_driver_register(&of_fsl_spi_driver);\n}\nmodule_init(fsl_spi_init);\n\nstatic void __exit fsl_spi_exit(void)\n{\n\tplatform_driver_unregister(&of_fsl_spi_driver);\n\tlegacy_driver_unregister();\n}\nmodule_exit(fsl_spi_exit);\n\nMODULE_AUTHOR(\"Kumar Gala\");\nMODULE_DESCRIPTION(\"Simple Freescale SPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}