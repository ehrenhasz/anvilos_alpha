{
  "module_name": "spi-sh-msiof.c",
  "hash_id": "2d73221c47db65dac63807419ff70df7e0556e99da6010dce3dc4939ba4484f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sh-msiof.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sh_dma.h>\n\n#include <linux/spi/sh_msiof.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n#define SH_MSIOF_FLAG_FIXED_DTDL_200\tBIT(0)\n\nstruct sh_msiof_chipdata {\n\tu32 bits_per_word_mask;\n\tu16 tx_fifo_size;\n\tu16 rx_fifo_size;\n\tu16 ctlr_flags;\n\tu16 min_div_pow;\n\tu32 flags;\n};\n\nstruct sh_msiof_spi_priv {\n\tstruct spi_controller *ctlr;\n\tvoid __iomem *mapbase;\n\tstruct clk *clk;\n\tstruct platform_device *pdev;\n\tstruct sh_msiof_spi_info *info;\n\tstruct completion done;\n\tstruct completion done_txdma;\n\tunsigned int tx_fifo_size;\n\tunsigned int rx_fifo_size;\n\tunsigned int min_div_pow;\n\tvoid *tx_dma_page;\n\tvoid *rx_dma_page;\n\tdma_addr_t tx_dma_addr;\n\tdma_addr_t rx_dma_addr;\n\tbool native_cs_inited;\n\tbool native_cs_high;\n\tbool target_aborted;\n};\n\n#define MAX_SS\t3\t \n\n#define SITMDR1\t0x00\t \n#define SITMDR2\t0x04\t \n#define SITMDR3\t0x08\t \n#define SIRMDR1\t0x10\t \n#define SIRMDR2\t0x14\t \n#define SIRMDR3\t0x18\t \n#define SITSCR\t0x20\t \n#define SIRSCR\t0x22\t \n#define SICTR\t0x28\t \n#define SIFCTR\t0x30\t \n#define SISTR\t0x40\t \n#define SIIER\t0x44\t \n#define SITDR1\t0x48\t \n#define SITDR2\t0x4c\t \n#define SITFDR\t0x50\t \n#define SIRDR1\t0x58\t \n#define SIRDR2\t0x5c\t \n#define SIRFDR\t0x60\t \n\n \n#define SIMDR1_TRMD\t\tBIT(31)\t\t \n#define SIMDR1_SYNCMD_MASK\tGENMASK(29, 28)\t \n#define SIMDR1_SYNCMD_SPI\t(2 << 28)\t \n#define SIMDR1_SYNCMD_LR\t(3 << 28)\t \n#define SIMDR1_SYNCAC_SHIFT\t25\t\t \n#define SIMDR1_BITLSB_SHIFT\t24\t\t \n#define SIMDR1_DTDL_SHIFT\t20\t\t \n#define SIMDR1_SYNCDL_SHIFT\t16\t\t \n#define SIMDR1_FLD_MASK\t\tGENMASK(3, 2)\t \n#define SIMDR1_FLD_SHIFT\t2\n#define SIMDR1_XXSTP\t\tBIT(0)\t\t \n \n#define SITMDR1_PCON\t\tBIT(30)\t\t \n#define SITMDR1_SYNCCH_MASK\tGENMASK(27, 26)\t \n#define SITMDR1_SYNCCH_SHIFT\t26\t\t \n\n \n#define SIMDR2_BITLEN1(i)\t(((i) - 1) << 24)  \n#define SIMDR2_WDLEN1(i)\t(((i) - 1) << 16)  \n#define SIMDR2_GRPMASK1\t\tBIT(0)\t\t \n\n \n#define SISCR_BRPS_MASK\t\tGENMASK(12, 8)\t \n#define SISCR_BRPS(i)\t\t(((i) - 1) << 8)\n#define SISCR_BRDV_MASK\t\tGENMASK(2, 0)\t \n#define SISCR_BRDV_DIV_2\t0\n#define SISCR_BRDV_DIV_4\t1\n#define SISCR_BRDV_DIV_8\t2\n#define SISCR_BRDV_DIV_16\t3\n#define SISCR_BRDV_DIV_32\t4\n#define SISCR_BRDV_DIV_1\t7\n\n \n#define SICTR_TSCKIZ_MASK\tGENMASK(31, 30)\t \n#define SICTR_TSCKIZ_SCK\tBIT(31)\t\t \n#define SICTR_TSCKIZ_POL_SHIFT\t30\t\t \n#define SICTR_RSCKIZ_MASK\tGENMASK(29, 28)  \n#define SICTR_RSCKIZ_SCK\tBIT(29)\t\t \n#define SICTR_RSCKIZ_POL_SHIFT\t28\t\t \n#define SICTR_TEDG_SHIFT\t27\t\t \n#define SICTR_REDG_SHIFT\t26\t\t \n#define SICTR_TXDIZ_MASK\tGENMASK(23, 22)\t \n#define SICTR_TXDIZ_LOW\t\t(0 << 22)\t \n#define SICTR_TXDIZ_HIGH\t(1 << 22)\t \n#define SICTR_TXDIZ_HIZ\t\t(2 << 22)\t \n#define SICTR_TSCKE\t\tBIT(15)\t\t \n#define SICTR_TFSE\t\tBIT(14)\t\t \n#define SICTR_TXE\t\tBIT(9)\t\t \n#define SICTR_RXE\t\tBIT(8)\t\t \n#define SICTR_TXRST\t\tBIT(1)\t\t \n#define SICTR_RXRST\t\tBIT(0)\t\t \n\n \n#define SIFCTR_TFWM_MASK\tGENMASK(31, 29)\t \n#define SIFCTR_TFWM_64\t\t(0 << 29)\t \n#define SIFCTR_TFWM_32\t\t(1 << 29)\t \n#define SIFCTR_TFWM_24\t\t(2 << 29)\t \n#define SIFCTR_TFWM_16\t\t(3 << 29)\t \n#define SIFCTR_TFWM_12\t\t(4 << 29)\t \n#define SIFCTR_TFWM_8\t\t(5 << 29)\t \n#define SIFCTR_TFWM_4\t\t(6 << 29)\t \n#define SIFCTR_TFWM_1\t\t(7 << 29)\t \n#define SIFCTR_TFUA_MASK\tGENMASK(26, 20)  \n#define SIFCTR_TFUA_SHIFT\t20\n#define SIFCTR_TFUA(i)\t\t((i) << SIFCTR_TFUA_SHIFT)\n#define SIFCTR_RFWM_MASK\tGENMASK(15, 13)\t \n#define SIFCTR_RFWM_1\t\t(0 << 13)\t \n#define SIFCTR_RFWM_4\t\t(1 << 13)\t \n#define SIFCTR_RFWM_8\t\t(2 << 13)\t \n#define SIFCTR_RFWM_16\t\t(3 << 13)\t \n#define SIFCTR_RFWM_32\t\t(4 << 13)\t \n#define SIFCTR_RFWM_64\t\t(5 << 13)\t \n#define SIFCTR_RFWM_128\t\t(6 << 13)\t \n#define SIFCTR_RFWM_256\t\t(7 << 13)\t \n#define SIFCTR_RFUA_MASK\tGENMASK(12, 4)\t \n#define SIFCTR_RFUA_SHIFT\t4\n#define SIFCTR_RFUA(i)\t\t((i) << SIFCTR_RFUA_SHIFT)\n\n \n#define SISTR_TFEMP\t\tBIT(29)  \n#define SISTR_TDREQ\t\tBIT(28)  \n#define SISTR_TEOF\t\tBIT(23)  \n#define SISTR_TFSERR\t\tBIT(21)  \n#define SISTR_TFOVF\t\tBIT(20)  \n#define SISTR_TFUDF\t\tBIT(19)  \n#define SISTR_RFFUL\t\tBIT(13)  \n#define SISTR_RDREQ\t\tBIT(12)  \n#define SISTR_REOF\t\tBIT(7)   \n#define SISTR_RFSERR\t\tBIT(5)   \n#define SISTR_RFUDF\t\tBIT(4)   \n#define SISTR_RFOVF\t\tBIT(3)   \n\n \n#define SIIER_TDMAE\t\tBIT(31)  \n#define SIIER_TFEMPE\t\tBIT(29)  \n#define SIIER_TDREQE\t\tBIT(28)  \n#define SIIER_TEOFE\t\tBIT(23)  \n#define SIIER_TFSERRE\t\tBIT(21)  \n#define SIIER_TFOVFE\t\tBIT(20)  \n#define SIIER_TFUDFE\t\tBIT(19)  \n#define SIIER_RDMAE\t\tBIT(15)  \n#define SIIER_RFFULE\t\tBIT(13)  \n#define SIIER_RDREQE\t\tBIT(12)  \n#define SIIER_REOFE\t\tBIT(7)   \n#define SIIER_RFSERRE\t\tBIT(5)   \n#define SIIER_RFUDFE\t\tBIT(4)   \n#define SIIER_RFOVFE\t\tBIT(3)   \n\n\nstatic u32 sh_msiof_read(struct sh_msiof_spi_priv *p, int reg_offs)\n{\n\tswitch (reg_offs) {\n\tcase SITSCR:\n\tcase SIRSCR:\n\t\treturn ioread16(p->mapbase + reg_offs);\n\tdefault:\n\t\treturn ioread32(p->mapbase + reg_offs);\n\t}\n}\n\nstatic void sh_msiof_write(struct sh_msiof_spi_priv *p, int reg_offs,\n\t\t\t   u32 value)\n{\n\tswitch (reg_offs) {\n\tcase SITSCR:\n\tcase SIRSCR:\n\t\tiowrite16(value, p->mapbase + reg_offs);\n\t\tbreak;\n\tdefault:\n\t\tiowrite32(value, p->mapbase + reg_offs);\n\t\tbreak;\n\t}\n}\n\nstatic int sh_msiof_modify_ctr_wait(struct sh_msiof_spi_priv *p,\n\t\t\t\t    u32 clr, u32 set)\n{\n\tu32 mask = clr | set;\n\tu32 data;\n\n\tdata = sh_msiof_read(p, SICTR);\n\tdata &= ~clr;\n\tdata |= set;\n\tsh_msiof_write(p, SICTR, data);\n\n\treturn readl_poll_timeout_atomic(p->mapbase + SICTR, data,\n\t\t\t\t\t (data & mask) == set, 1, 100);\n}\n\nstatic irqreturn_t sh_msiof_spi_irq(int irq, void *data)\n{\n\tstruct sh_msiof_spi_priv *p = data;\n\n\t \n\tsh_msiof_write(p, SIIER, 0);\n\tcomplete(&p->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sh_msiof_spi_reset_regs(struct sh_msiof_spi_priv *p)\n{\n\tu32 mask = SICTR_TXRST | SICTR_RXRST;\n\tu32 data;\n\n\tdata = sh_msiof_read(p, SICTR);\n\tdata |= mask;\n\tsh_msiof_write(p, SICTR, data);\n\n\treadl_poll_timeout_atomic(p->mapbase + SICTR, data, !(data & mask), 1,\n\t\t\t\t  100);\n}\n\nstatic const u32 sh_msiof_spi_div_array[] = {\n\tSISCR_BRDV_DIV_1, SISCR_BRDV_DIV_2, SISCR_BRDV_DIV_4,\n\tSISCR_BRDV_DIV_8, SISCR_BRDV_DIV_16, SISCR_BRDV_DIV_32,\n};\n\nstatic void sh_msiof_spi_set_clk_regs(struct sh_msiof_spi_priv *p,\n\t\t\t\t      struct spi_transfer *t)\n{\n\tunsigned long parent_rate = clk_get_rate(p->clk);\n\tunsigned int div_pow = p->min_div_pow;\n\tu32 spi_hz = t->speed_hz;\n\tunsigned long div;\n\tu32 brps, scr;\n\n\tif (!spi_hz || !parent_rate) {\n\t\tWARN(1, \"Invalid clock rate parameters %lu and %u\\n\",\n\t\t     parent_rate, spi_hz);\n\t\treturn;\n\t}\n\n\tdiv = DIV_ROUND_UP(parent_rate, spi_hz);\n\tif (div <= 1024) {\n\t\t \n\t\tif (!div_pow && div <= 32 && div > 2)\n\t\t\tdiv_pow = 1;\n\n\t\tif (div_pow)\n\t\t\tbrps = (div + 1) >> div_pow;\n\t\telse\n\t\t\tbrps = div;\n\n\t\tfor (; brps > 32; div_pow++)\n\t\t\tbrps = (brps + 1) >> 1;\n\t} else {\n\t\t \n\t\tdev_err(&p->pdev->dev,\n\t\t\t\"Requested SPI transfer rate %d is too low\\n\", spi_hz);\n\t\tdiv_pow = 5;\n\t\tbrps = 32;\n\t}\n\n\tt->effective_speed_hz = parent_rate / (brps << div_pow);\n\n\tscr = sh_msiof_spi_div_array[div_pow] | SISCR_BRPS(brps);\n\tsh_msiof_write(p, SITSCR, scr);\n\tif (!(p->ctlr->flags & SPI_CONTROLLER_MUST_TX))\n\t\tsh_msiof_write(p, SIRSCR, scr);\n}\n\nstatic u32 sh_msiof_get_delay_bit(u32 dtdl_or_syncdl)\n{\n\t \n\tif (dtdl_or_syncdl % 100)\n\t\treturn dtdl_or_syncdl / 100 + 5;\n\telse\n\t\treturn dtdl_or_syncdl / 100;\n}\n\nstatic u32 sh_msiof_spi_get_dtdl_and_syncdl(struct sh_msiof_spi_priv *p)\n{\n\tu32 val;\n\n\tif (!p->info)\n\t\treturn 0;\n\n\t \n\tif (p->info->dtdl > 200 || p->info->syncdl > 300) {\n\t\tdev_warn(&p->pdev->dev, \"DTDL or SYNCDL is too large\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif ((p->info->dtdl + p->info->syncdl) % 100) {\n\t\tdev_warn(&p->pdev->dev, \"the sum of DTDL/SYNCDL is not good\\n\");\n\t\treturn 0;\n\t}\n\n\tval = sh_msiof_get_delay_bit(p->info->dtdl) << SIMDR1_DTDL_SHIFT;\n\tval |= sh_msiof_get_delay_bit(p->info->syncdl) << SIMDR1_SYNCDL_SHIFT;\n\n\treturn val;\n}\n\nstatic void sh_msiof_spi_set_pin_regs(struct sh_msiof_spi_priv *p, u32 ss,\n\t\t\t\t      u32 cpol, u32 cpha,\n\t\t\t\t      u32 tx_hi_z, u32 lsb_first, u32 cs_high)\n{\n\tu32 tmp;\n\tint edge;\n\n\t \n\ttmp = SIMDR1_SYNCMD_SPI | 1 << SIMDR1_FLD_SHIFT | SIMDR1_XXSTP;\n\ttmp |= !cs_high << SIMDR1_SYNCAC_SHIFT;\n\ttmp |= lsb_first << SIMDR1_BITLSB_SHIFT;\n\ttmp |= sh_msiof_spi_get_dtdl_and_syncdl(p);\n\tif (spi_controller_is_target(p->ctlr)) {\n\t\tsh_msiof_write(p, SITMDR1, tmp | SITMDR1_PCON);\n\t} else {\n\t\tsh_msiof_write(p, SITMDR1,\n\t\t\t       tmp | SIMDR1_TRMD | SITMDR1_PCON |\n\t\t\t       (ss < MAX_SS ? ss : 0) << SITMDR1_SYNCCH_SHIFT);\n\t}\n\tif (p->ctlr->flags & SPI_CONTROLLER_MUST_TX) {\n\t\t \n\t\ttmp &= ~0x0000ffff;\n\t}\n\tsh_msiof_write(p, SIRMDR1, tmp);\n\n\ttmp = 0;\n\ttmp |= SICTR_TSCKIZ_SCK | cpol << SICTR_TSCKIZ_POL_SHIFT;\n\ttmp |= SICTR_RSCKIZ_SCK | cpol << SICTR_RSCKIZ_POL_SHIFT;\n\n\tedge = cpol ^ !cpha;\n\n\ttmp |= edge << SICTR_TEDG_SHIFT;\n\ttmp |= edge << SICTR_REDG_SHIFT;\n\ttmp |= tx_hi_z ? SICTR_TXDIZ_HIZ : SICTR_TXDIZ_LOW;\n\tsh_msiof_write(p, SICTR, tmp);\n}\n\nstatic void sh_msiof_spi_set_mode_regs(struct sh_msiof_spi_priv *p,\n\t\t\t\t       const void *tx_buf, void *rx_buf,\n\t\t\t\t       u32 bits, u32 words)\n{\n\tu32 dr2 = SIMDR2_BITLEN1(bits) | SIMDR2_WDLEN1(words);\n\n\tif (tx_buf || (p->ctlr->flags & SPI_CONTROLLER_MUST_TX))\n\t\tsh_msiof_write(p, SITMDR2, dr2);\n\telse\n\t\tsh_msiof_write(p, SITMDR2, dr2 | SIMDR2_GRPMASK1);\n\n\tif (rx_buf)\n\t\tsh_msiof_write(p, SIRMDR2, dr2);\n}\n\nstatic void sh_msiof_reset_str(struct sh_msiof_spi_priv *p)\n{\n\tsh_msiof_write(p, SISTR,\n\t\t       sh_msiof_read(p, SISTR) & ~(SISTR_TDREQ | SISTR_RDREQ));\n}\n\nstatic void sh_msiof_spi_write_fifo_8(struct sh_msiof_spi_priv *p,\n\t\t\t\t      const void *tx_buf, int words, int fs)\n{\n\tconst u8 *buf_8 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, buf_8[k] << fs);\n}\n\nstatic void sh_msiof_spi_write_fifo_16(struct sh_msiof_spi_priv *p,\n\t\t\t\t       const void *tx_buf, int words, int fs)\n{\n\tconst u16 *buf_16 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, buf_16[k] << fs);\n}\n\nstatic void sh_msiof_spi_write_fifo_16u(struct sh_msiof_spi_priv *p,\n\t\t\t\t\tconst void *tx_buf, int words, int fs)\n{\n\tconst u16 *buf_16 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, get_unaligned(&buf_16[k]) << fs);\n}\n\nstatic void sh_msiof_spi_write_fifo_32(struct sh_msiof_spi_priv *p,\n\t\t\t\t       const void *tx_buf, int words, int fs)\n{\n\tconst u32 *buf_32 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, buf_32[k] << fs);\n}\n\nstatic void sh_msiof_spi_write_fifo_32u(struct sh_msiof_spi_priv *p,\n\t\t\t\t\tconst void *tx_buf, int words, int fs)\n{\n\tconst u32 *buf_32 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, get_unaligned(&buf_32[k]) << fs);\n}\n\nstatic void sh_msiof_spi_write_fifo_s32(struct sh_msiof_spi_priv *p,\n\t\t\t\t\tconst void *tx_buf, int words, int fs)\n{\n\tconst u32 *buf_32 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, swab32(buf_32[k] << fs));\n}\n\nstatic void sh_msiof_spi_write_fifo_s32u(struct sh_msiof_spi_priv *p,\n\t\t\t\t\t const void *tx_buf, int words, int fs)\n{\n\tconst u32 *buf_32 = tx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tsh_msiof_write(p, SITFDR, swab32(get_unaligned(&buf_32[k]) << fs));\n}\n\nstatic void sh_msiof_spi_read_fifo_8(struct sh_msiof_spi_priv *p,\n\t\t\t\t     void *rx_buf, int words, int fs)\n{\n\tu8 *buf_8 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tbuf_8[k] = sh_msiof_read(p, SIRFDR) >> fs;\n}\n\nstatic void sh_msiof_spi_read_fifo_16(struct sh_msiof_spi_priv *p,\n\t\t\t\t      void *rx_buf, int words, int fs)\n{\n\tu16 *buf_16 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tbuf_16[k] = sh_msiof_read(p, SIRFDR) >> fs;\n}\n\nstatic void sh_msiof_spi_read_fifo_16u(struct sh_msiof_spi_priv *p,\n\t\t\t\t       void *rx_buf, int words, int fs)\n{\n\tu16 *buf_16 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tput_unaligned(sh_msiof_read(p, SIRFDR) >> fs, &buf_16[k]);\n}\n\nstatic void sh_msiof_spi_read_fifo_32(struct sh_msiof_spi_priv *p,\n\t\t\t\t      void *rx_buf, int words, int fs)\n{\n\tu32 *buf_32 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tbuf_32[k] = sh_msiof_read(p, SIRFDR) >> fs;\n}\n\nstatic void sh_msiof_spi_read_fifo_32u(struct sh_msiof_spi_priv *p,\n\t\t\t\t       void *rx_buf, int words, int fs)\n{\n\tu32 *buf_32 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tput_unaligned(sh_msiof_read(p, SIRFDR) >> fs, &buf_32[k]);\n}\n\nstatic void sh_msiof_spi_read_fifo_s32(struct sh_msiof_spi_priv *p,\n\t\t\t\t       void *rx_buf, int words, int fs)\n{\n\tu32 *buf_32 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tbuf_32[k] = swab32(sh_msiof_read(p, SIRFDR) >> fs);\n}\n\nstatic void sh_msiof_spi_read_fifo_s32u(struct sh_msiof_spi_priv *p,\n\t\t\t\t       void *rx_buf, int words, int fs)\n{\n\tu32 *buf_32 = rx_buf;\n\tint k;\n\n\tfor (k = 0; k < words; k++)\n\t\tput_unaligned(swab32(sh_msiof_read(p, SIRFDR) >> fs), &buf_32[k]);\n}\n\nstatic int sh_msiof_spi_setup(struct spi_device *spi)\n{\n\tstruct sh_msiof_spi_priv *p =\n\t\tspi_controller_get_devdata(spi->controller);\n\tu32 clr, set, tmp;\n\n\tif (spi_get_csgpiod(spi, 0) || spi_controller_is_target(p->ctlr))\n\t\treturn 0;\n\n\tif (p->native_cs_inited &&\n\t    (p->native_cs_high == !!(spi->mode & SPI_CS_HIGH)))\n\t\treturn 0;\n\n\t \n\tclr = SIMDR1_SYNCMD_MASK;\n\tset = SIMDR1_SYNCMD_SPI;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tclr |= BIT(SIMDR1_SYNCAC_SHIFT);\n\telse\n\t\tset |= BIT(SIMDR1_SYNCAC_SHIFT);\n\tpm_runtime_get_sync(&p->pdev->dev);\n\ttmp = sh_msiof_read(p, SITMDR1) & ~clr;\n\tsh_msiof_write(p, SITMDR1, tmp | set | SIMDR1_TRMD | SITMDR1_PCON);\n\ttmp = sh_msiof_read(p, SIRMDR1) & ~clr;\n\tsh_msiof_write(p, SIRMDR1, tmp | set);\n\tpm_runtime_put(&p->pdev->dev);\n\tp->native_cs_high = spi->mode & SPI_CS_HIGH;\n\tp->native_cs_inited = true;\n\treturn 0;\n}\n\nstatic int sh_msiof_prepare_message(struct spi_controller *ctlr,\n\t\t\t\t    struct spi_message *msg)\n{\n\tstruct sh_msiof_spi_priv *p = spi_controller_get_devdata(ctlr);\n\tconst struct spi_device *spi = msg->spi;\n\tu32 ss, cs_high;\n\n\t \n\tif (spi_get_csgpiod(spi, 0)) {\n\t\tss = ctlr->unused_native_cs;\n\t\tcs_high = p->native_cs_high;\n\t} else {\n\t\tss = spi_get_chipselect(spi, 0);\n\t\tcs_high = !!(spi->mode & SPI_CS_HIGH);\n\t}\n\tsh_msiof_spi_set_pin_regs(p, ss, !!(spi->mode & SPI_CPOL),\n\t\t\t\t  !!(spi->mode & SPI_CPHA),\n\t\t\t\t  !!(spi->mode & SPI_3WIRE),\n\t\t\t\t  !!(spi->mode & SPI_LSB_FIRST), cs_high);\n\treturn 0;\n}\n\nstatic int sh_msiof_spi_start(struct sh_msiof_spi_priv *p, void *rx_buf)\n{\n\tbool target = spi_controller_is_target(p->ctlr);\n\tint ret = 0;\n\n\t \n\tif (!target)\n\t\tret = sh_msiof_modify_ctr_wait(p, 0, SICTR_TSCKE);\n\tif (rx_buf && !ret)\n\t\tret = sh_msiof_modify_ctr_wait(p, 0, SICTR_RXE);\n\tif (!ret)\n\t\tret = sh_msiof_modify_ctr_wait(p, 0, SICTR_TXE);\n\n\t \n\tif (!ret && !target)\n\t\tret = sh_msiof_modify_ctr_wait(p, 0, SICTR_TFSE);\n\n\treturn ret;\n}\n\nstatic int sh_msiof_spi_stop(struct sh_msiof_spi_priv *p, void *rx_buf)\n{\n\tbool target = spi_controller_is_target(p->ctlr);\n\tint ret = 0;\n\n\t \n\tif (!target)\n\t\tret = sh_msiof_modify_ctr_wait(p, SICTR_TFSE, 0);\n\tif (!ret)\n\t\tret = sh_msiof_modify_ctr_wait(p, SICTR_TXE, 0);\n\tif (rx_buf && !ret)\n\t\tret = sh_msiof_modify_ctr_wait(p, SICTR_RXE, 0);\n\tif (!ret && !target)\n\t\tret = sh_msiof_modify_ctr_wait(p, SICTR_TSCKE, 0);\n\n\treturn ret;\n}\n\nstatic int sh_msiof_target_abort(struct spi_controller *ctlr)\n{\n\tstruct sh_msiof_spi_priv *p = spi_controller_get_devdata(ctlr);\n\n\tp->target_aborted = true;\n\tcomplete(&p->done);\n\tcomplete(&p->done_txdma);\n\treturn 0;\n}\n\nstatic int sh_msiof_wait_for_completion(struct sh_msiof_spi_priv *p,\n\t\t\t\t\tstruct completion *x)\n{\n\tif (spi_controller_is_target(p->ctlr)) {\n\t\tif (wait_for_completion_interruptible(x) ||\n\t\t    p->target_aborted) {\n\t\t\tdev_dbg(&p->pdev->dev, \"interrupted\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t} else {\n\t\tif (!wait_for_completion_timeout(x, HZ)) {\n\t\t\tdev_err(&p->pdev->dev, \"timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_msiof_spi_txrx_once(struct sh_msiof_spi_priv *p,\n\t\t\t\t  void (*tx_fifo)(struct sh_msiof_spi_priv *,\n\t\t\t\t\t\t  const void *, int, int),\n\t\t\t\t  void (*rx_fifo)(struct sh_msiof_spi_priv *,\n\t\t\t\t\t\t  void *, int, int),\n\t\t\t\t  const void *tx_buf, void *rx_buf,\n\t\t\t\t  int words, int bits)\n{\n\tint fifo_shift;\n\tint ret;\n\n\t \n\tif (tx_buf)\n\t\twords = min_t(int, words, p->tx_fifo_size);\n\tif (rx_buf)\n\t\twords = min_t(int, words, p->rx_fifo_size);\n\n\t \n\tfifo_shift = 32 - bits;\n\n\t \n\tsh_msiof_write(p, SIFCTR, 0);\n\n\t \n\tsh_msiof_spi_set_mode_regs(p, tx_buf, rx_buf, bits, words);\n\tsh_msiof_write(p, SIIER, SIIER_TEOFE | SIIER_REOFE);\n\n\t \n\tif (tx_buf)\n\t\ttx_fifo(p, tx_buf, words, fifo_shift);\n\n\treinit_completion(&p->done);\n\tp->target_aborted = false;\n\n\tret = sh_msiof_spi_start(p, rx_buf);\n\tif (ret) {\n\t\tdev_err(&p->pdev->dev, \"failed to start hardware\\n\");\n\t\tgoto stop_ier;\n\t}\n\n\t \n\tret = sh_msiof_wait_for_completion(p, &p->done);\n\tif (ret)\n\t\tgoto stop_reset;\n\n\t \n\tif (rx_buf)\n\t\trx_fifo(p, rx_buf, words, fifo_shift);\n\n\t \n\tsh_msiof_reset_str(p);\n\n\tret = sh_msiof_spi_stop(p, rx_buf);\n\tif (ret) {\n\t\tdev_err(&p->pdev->dev, \"failed to shut down hardware\\n\");\n\t\treturn ret;\n\t}\n\n\treturn words;\n\nstop_reset:\n\tsh_msiof_reset_str(p);\n\tsh_msiof_spi_stop(p, rx_buf);\nstop_ier:\n\tsh_msiof_write(p, SIIER, 0);\n\treturn ret;\n}\n\nstatic void sh_msiof_dma_complete(void *arg)\n{\n\tcomplete(arg);\n}\n\nstatic int sh_msiof_dma_once(struct sh_msiof_spi_priv *p, const void *tx,\n\t\t\t     void *rx, unsigned int len)\n{\n\tu32 ier_bits = 0;\n\tstruct dma_async_tx_descriptor *desc_tx = NULL, *desc_rx = NULL;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\t \n\tif (rx) {\n\t\tier_bits |= SIIER_RDREQE | SIIER_RDMAE;\n\t\tdesc_rx = dmaengine_prep_slave_single(p->ctlr->dma_rx,\n\t\t\t\t\tp->rx_dma_addr, len, DMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc_rx)\n\t\t\treturn -EAGAIN;\n\n\t\tdesc_rx->callback = sh_msiof_dma_complete;\n\t\tdesc_rx->callback_param = &p->done;\n\t\tcookie = dmaengine_submit(desc_rx);\n\t\tif (dma_submit_error(cookie))\n\t\t\treturn cookie;\n\t}\n\n\tif (tx) {\n\t\tier_bits |= SIIER_TDREQE | SIIER_TDMAE;\n\t\tdma_sync_single_for_device(p->ctlr->dma_tx->device->dev,\n\t\t\t\t\t   p->tx_dma_addr, len, DMA_TO_DEVICE);\n\t\tdesc_tx = dmaengine_prep_slave_single(p->ctlr->dma_tx,\n\t\t\t\t\tp->tx_dma_addr, len, DMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc_tx) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto no_dma_tx;\n\t\t}\n\n\t\tdesc_tx->callback = sh_msiof_dma_complete;\n\t\tdesc_tx->callback_param = &p->done_txdma;\n\t\tcookie = dmaengine_submit(desc_tx);\n\t\tif (dma_submit_error(cookie)) {\n\t\t\tret = cookie;\n\t\t\tgoto no_dma_tx;\n\t\t}\n\t}\n\n\t \n\tsh_msiof_write(p, SIFCTR, SIFCTR_TFWM_1 | SIFCTR_RFWM_1);\n\n\t \n\tsh_msiof_spi_set_mode_regs(p, tx, rx, 32, len / 4);\n\n\tsh_msiof_write(p, SIIER, ier_bits);\n\n\treinit_completion(&p->done);\n\tif (tx)\n\t\treinit_completion(&p->done_txdma);\n\tp->target_aborted = false;\n\n\t \n\tif (rx)\n\t\tdma_async_issue_pending(p->ctlr->dma_rx);\n\tif (tx)\n\t\tdma_async_issue_pending(p->ctlr->dma_tx);\n\n\tret = sh_msiof_spi_start(p, rx);\n\tif (ret) {\n\t\tdev_err(&p->pdev->dev, \"failed to start hardware\\n\");\n\t\tgoto stop_dma;\n\t}\n\n\tif (tx) {\n\t\t \n\t\tret = sh_msiof_wait_for_completion(p, &p->done_txdma);\n\t\tif (ret)\n\t\t\tgoto stop_reset;\n\t}\n\n\tif (rx) {\n\t\t \n\t\tret = sh_msiof_wait_for_completion(p, &p->done);\n\t\tif (ret)\n\t\t\tgoto stop_reset;\n\n\t\tsh_msiof_write(p, SIIER, 0);\n\t} else {\n\t\t \n\t\tsh_msiof_write(p, SIIER, SIIER_TEOFE);\n\t\tret = sh_msiof_wait_for_completion(p, &p->done);\n\t\tif (ret)\n\t\t\tgoto stop_reset;\n\t}\n\n\t \n\tsh_msiof_reset_str(p);\n\n\tret = sh_msiof_spi_stop(p, rx);\n\tif (ret) {\n\t\tdev_err(&p->pdev->dev, \"failed to shut down hardware\\n\");\n\t\treturn ret;\n\t}\n\n\tif (rx)\n\t\tdma_sync_single_for_cpu(p->ctlr->dma_rx->device->dev,\n\t\t\t\t\tp->rx_dma_addr, len, DMA_FROM_DEVICE);\n\n\treturn 0;\n\nstop_reset:\n\tsh_msiof_reset_str(p);\n\tsh_msiof_spi_stop(p, rx);\nstop_dma:\n\tif (tx)\n\t\tdmaengine_terminate_sync(p->ctlr->dma_tx);\nno_dma_tx:\n\tif (rx)\n\t\tdmaengine_terminate_sync(p->ctlr->dma_rx);\n\tsh_msiof_write(p, SIIER, 0);\n\treturn ret;\n}\n\nstatic void copy_bswap32(u32 *dst, const u32 *src, unsigned int words)\n{\n\t \n\tif ((unsigned long)src & 3) {\n\t\twhile (words--) {\n\t\t\t*dst++ = swab32(get_unaligned(src));\n\t\t\tsrc++;\n\t\t}\n\t} else if ((unsigned long)dst & 3) {\n\t\twhile (words--) {\n\t\t\tput_unaligned(swab32(*src++), dst);\n\t\t\tdst++;\n\t\t}\n\t} else {\n\t\twhile (words--)\n\t\t\t*dst++ = swab32(*src++);\n\t}\n}\n\nstatic void copy_wswap32(u32 *dst, const u32 *src, unsigned int words)\n{\n\t \n\tif ((unsigned long)src & 3) {\n\t\twhile (words--) {\n\t\t\t*dst++ = swahw32(get_unaligned(src));\n\t\t\tsrc++;\n\t\t}\n\t} else if ((unsigned long)dst & 3) {\n\t\twhile (words--) {\n\t\t\tput_unaligned(swahw32(*src++), dst);\n\t\t\tdst++;\n\t\t}\n\t} else {\n\t\twhile (words--)\n\t\t\t*dst++ = swahw32(*src++);\n\t}\n}\n\nstatic void copy_plain32(u32 *dst, const u32 *src, unsigned int words)\n{\n\tmemcpy(dst, src, words * 4);\n}\n\nstatic int sh_msiof_transfer_one(struct spi_controller *ctlr,\n\t\t\t\t struct spi_device *spi,\n\t\t\t\t struct spi_transfer *t)\n{\n\tstruct sh_msiof_spi_priv *p = spi_controller_get_devdata(ctlr);\n\tvoid (*copy32)(u32 *, const u32 *, unsigned int);\n\tvoid (*tx_fifo)(struct sh_msiof_spi_priv *, const void *, int, int);\n\tvoid (*rx_fifo)(struct sh_msiof_spi_priv *, void *, int, int);\n\tconst void *tx_buf = t->tx_buf;\n\tvoid *rx_buf = t->rx_buf;\n\tunsigned int len = t->len;\n\tunsigned int bits = t->bits_per_word;\n\tunsigned int bytes_per_word;\n\tunsigned int words;\n\tint n;\n\tbool swab;\n\tint ret;\n\n\t \n\tsh_msiof_spi_reset_regs(p);\n\n\t \n\tif (!spi_controller_is_target(p->ctlr))\n\t\tsh_msiof_spi_set_clk_regs(p, t);\n\n\twhile (ctlr->dma_tx && len > 15) {\n\t\t \n\t\tunsigned int l = 0;\n\n\t\tif (tx_buf)\n\t\t\tl = min(round_down(len, 4), p->tx_fifo_size * 4);\n\t\tif (rx_buf)\n\t\t\tl = min(round_down(len, 4), p->rx_fifo_size * 4);\n\n\t\tif (bits <= 8) {\n\t\t\tcopy32 = copy_bswap32;\n\t\t} else if (bits <= 16) {\n\t\t\tcopy32 = copy_wswap32;\n\t\t} else {\n\t\t\tcopy32 = copy_plain32;\n\t\t}\n\n\t\tif (tx_buf)\n\t\t\tcopy32(p->tx_dma_page, tx_buf, l / 4);\n\n\t\tret = sh_msiof_dma_once(p, tx_buf, rx_buf, l);\n\t\tif (ret == -EAGAIN) {\n\t\t\tdev_warn_once(&p->pdev->dev,\n\t\t\t\t\"DMA not available, falling back to PIO\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rx_buf) {\n\t\t\tcopy32(rx_buf, p->rx_dma_page, l / 4);\n\t\t\trx_buf += l;\n\t\t}\n\t\tif (tx_buf)\n\t\t\ttx_buf += l;\n\n\t\tlen -= l;\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\tif (bits <= 8 && len > 15) {\n\t\tbits = 32;\n\t\tswab = true;\n\t} else {\n\t\tswab = false;\n\t}\n\n\t \n\tif (bits <= 8) {\n\t\tbytes_per_word = 1;\n\t\ttx_fifo = sh_msiof_spi_write_fifo_8;\n\t\trx_fifo = sh_msiof_spi_read_fifo_8;\n\t} else if (bits <= 16) {\n\t\tbytes_per_word = 2;\n\t\tif ((unsigned long)tx_buf & 0x01)\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_16u;\n\t\telse\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_16;\n\n\t\tif ((unsigned long)rx_buf & 0x01)\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_16u;\n\t\telse\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_16;\n\t} else if (swab) {\n\t\tbytes_per_word = 4;\n\t\tif ((unsigned long)tx_buf & 0x03)\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_s32u;\n\t\telse\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_s32;\n\n\t\tif ((unsigned long)rx_buf & 0x03)\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_s32u;\n\t\telse\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_s32;\n\t} else {\n\t\tbytes_per_word = 4;\n\t\tif ((unsigned long)tx_buf & 0x03)\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_32u;\n\t\telse\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_32;\n\n\t\tif ((unsigned long)rx_buf & 0x03)\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_32u;\n\t\telse\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_32;\n\t}\n\n\t \n\twords = len / bytes_per_word;\n\n\twhile (words > 0) {\n\t\tn = sh_msiof_spi_txrx_once(p, tx_fifo, rx_fifo, tx_buf, rx_buf,\n\t\t\t\t\t   words, bits);\n\t\tif (n < 0)\n\t\t\treturn n;\n\n\t\tif (tx_buf)\n\t\t\ttx_buf += n * bytes_per_word;\n\t\tif (rx_buf)\n\t\t\trx_buf += n * bytes_per_word;\n\t\twords -= n;\n\n\t\tif (words == 0 && (len % bytes_per_word)) {\n\t\t\twords = len % bytes_per_word;\n\t\t\tbits = t->bits_per_word;\n\t\t\tbytes_per_word = 1;\n\t\t\ttx_fifo = sh_msiof_spi_write_fifo_8;\n\t\t\trx_fifo = sh_msiof_spi_read_fifo_8;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct sh_msiof_chipdata sh_data = {\n\t.bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32),\n\t.tx_fifo_size = 64,\n\t.rx_fifo_size = 64,\n\t.ctlr_flags = 0,\n\t.min_div_pow = 0,\n};\n\nstatic const struct sh_msiof_chipdata rcar_gen2_data = {\n\t.bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\n\t\t\t      SPI_BPW_MASK(24) | SPI_BPW_MASK(32),\n\t.tx_fifo_size = 64,\n\t.rx_fifo_size = 64,\n\t.ctlr_flags = SPI_CONTROLLER_MUST_TX,\n\t.min_div_pow = 0,\n};\n\nstatic const struct sh_msiof_chipdata rcar_gen3_data = {\n\t.bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\n\t\t\t      SPI_BPW_MASK(24) | SPI_BPW_MASK(32),\n\t.tx_fifo_size = 64,\n\t.rx_fifo_size = 64,\n\t.ctlr_flags = SPI_CONTROLLER_MUST_TX,\n\t.min_div_pow = 1,\n};\n\nstatic const struct sh_msiof_chipdata rcar_r8a7795_data = {\n\t.bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\n\t\t\t      SPI_BPW_MASK(24) | SPI_BPW_MASK(32),\n\t.tx_fifo_size = 64,\n\t.rx_fifo_size = 64,\n\t.ctlr_flags = SPI_CONTROLLER_MUST_TX,\n\t.min_div_pow = 1,\n\t.flags = SH_MSIOF_FLAG_FIXED_DTDL_200,\n};\n\nstatic const struct of_device_id sh_msiof_match[] __maybe_unused = {\n\t{ .compatible = \"renesas,sh-mobile-msiof\", .data = &sh_data },\n\t{ .compatible = \"renesas,msiof-r8a7743\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7745\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7790\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7791\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7792\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7793\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7794\",   .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,rcar-gen2-msiof\", .data = &rcar_gen2_data },\n\t{ .compatible = \"renesas,msiof-r8a7795\",   .data = &rcar_r8a7795_data },\n\t{ .compatible = \"renesas,msiof-r8a7796\",   .data = &rcar_gen3_data },\n\t{ .compatible = \"renesas,rcar-gen3-msiof\", .data = &rcar_gen3_data },\n\t{ .compatible = \"renesas,rcar-gen4-msiof\", .data = &rcar_gen3_data },\n\t{ .compatible = \"renesas,sh-msiof\",        .data = &sh_data },  \n\t{},\n};\nMODULE_DEVICE_TABLE(of, sh_msiof_match);\n\n#ifdef CONFIG_OF\nstatic struct sh_msiof_spi_info *sh_msiof_spi_parse_dt(struct device *dev)\n{\n\tstruct sh_msiof_spi_info *info;\n\tstruct device_node *np = dev->of_node;\n\tu32 num_cs = 1;\n\n\tinfo = devm_kzalloc(dev, sizeof(struct sh_msiof_spi_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->mode = of_property_read_bool(np, \"spi-slave\") ? MSIOF_SPI_TARGET\n\t\t\t\t\t\t\t    : MSIOF_SPI_HOST;\n\n\t \n\tif (info->mode == MSIOF_SPI_HOST)\n\t\tof_property_read_u32(np, \"num-cs\", &num_cs);\n\tof_property_read_u32(np, \"renesas,tx-fifo-size\",\n\t\t\t\t\t&info->tx_fifo_override);\n\tof_property_read_u32(np, \"renesas,rx-fifo-size\",\n\t\t\t\t\t&info->rx_fifo_override);\n\tof_property_read_u32(np, \"renesas,dtdl\", &info->dtdl);\n\tof_property_read_u32(np, \"renesas,syncdl\", &info->syncdl);\n\n\tinfo->num_chipselect = num_cs;\n\n\treturn info;\n}\n#else\nstatic struct sh_msiof_spi_info *sh_msiof_spi_parse_dt(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic struct dma_chan *sh_msiof_request_dma_chan(struct device *dev,\n\tenum dma_transfer_direction dir, unsigned int id, dma_addr_t port_addr)\n{\n\tdma_cap_mask_t mask;\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tchan = dma_request_slave_channel_compat(mask, shdma_chan_filter,\n\t\t\t\t(void *)(unsigned long)id, dev,\n\t\t\t\tdir == DMA_MEM_TO_DEV ? \"tx\" : \"rx\");\n\tif (!chan) {\n\t\tdev_warn(dev, \"dma_request_slave_channel_compat failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.direction = dir;\n\tif (dir == DMA_MEM_TO_DEV) {\n\t\tcfg.dst_addr = port_addr;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t} else {\n\t\tcfg.src_addr = port_addr;\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t}\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret) {\n\t\tdev_warn(dev, \"dmaengine_slave_config failed %d\\n\", ret);\n\t\tdma_release_channel(chan);\n\t\treturn NULL;\n\t}\n\n\treturn chan;\n}\n\nstatic int sh_msiof_request_dma(struct sh_msiof_spi_priv *p)\n{\n\tstruct platform_device *pdev = p->pdev;\n\tstruct device *dev = &pdev->dev;\n\tconst struct sh_msiof_spi_info *info = p->info;\n\tunsigned int dma_tx_id, dma_rx_id;\n\tconst struct resource *res;\n\tstruct spi_controller *ctlr;\n\tstruct device *tx_dev, *rx_dev;\n\n\tif (dev->of_node) {\n\t\t \n\t\tdma_tx_id = 0;\n\t\tdma_rx_id = 0;\n\t} else if (info && info->dma_tx_id && info->dma_rx_id) {\n\t\tdma_tx_id = info->dma_tx_id;\n\t\tdma_rx_id = info->dma_rx_id;\n\t} else {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tctlr = p->ctlr;\n\tctlr->dma_tx = sh_msiof_request_dma_chan(dev, DMA_MEM_TO_DEV,\n\t\t\t\t\t\t dma_tx_id, res->start + SITFDR);\n\tif (!ctlr->dma_tx)\n\t\treturn -ENODEV;\n\n\tctlr->dma_rx = sh_msiof_request_dma_chan(dev, DMA_DEV_TO_MEM,\n\t\t\t\t\t\t dma_rx_id, res->start + SIRFDR);\n\tif (!ctlr->dma_rx)\n\t\tgoto free_tx_chan;\n\n\tp->tx_dma_page = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!p->tx_dma_page)\n\t\tgoto free_rx_chan;\n\n\tp->rx_dma_page = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!p->rx_dma_page)\n\t\tgoto free_tx_page;\n\n\ttx_dev = ctlr->dma_tx->device->dev;\n\tp->tx_dma_addr = dma_map_single(tx_dev, p->tx_dma_page, PAGE_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(tx_dev, p->tx_dma_addr))\n\t\tgoto free_rx_page;\n\n\trx_dev = ctlr->dma_rx->device->dev;\n\tp->rx_dma_addr = dma_map_single(rx_dev, p->rx_dma_page, PAGE_SIZE,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(rx_dev, p->rx_dma_addr))\n\t\tgoto unmap_tx_page;\n\n\tdev_info(dev, \"DMA available\");\n\treturn 0;\n\nunmap_tx_page:\n\tdma_unmap_single(tx_dev, p->tx_dma_addr, PAGE_SIZE, DMA_TO_DEVICE);\nfree_rx_page:\n\tfree_page((unsigned long)p->rx_dma_page);\nfree_tx_page:\n\tfree_page((unsigned long)p->tx_dma_page);\nfree_rx_chan:\n\tdma_release_channel(ctlr->dma_rx);\nfree_tx_chan:\n\tdma_release_channel(ctlr->dma_tx);\n\tctlr->dma_tx = NULL;\n\treturn -ENODEV;\n}\n\nstatic void sh_msiof_release_dma(struct sh_msiof_spi_priv *p)\n{\n\tstruct spi_controller *ctlr = p->ctlr;\n\n\tif (!ctlr->dma_tx)\n\t\treturn;\n\n\tdma_unmap_single(ctlr->dma_rx->device->dev, p->rx_dma_addr, PAGE_SIZE,\n\t\t\t DMA_FROM_DEVICE);\n\tdma_unmap_single(ctlr->dma_tx->device->dev, p->tx_dma_addr, PAGE_SIZE,\n\t\t\t DMA_TO_DEVICE);\n\tfree_page((unsigned long)p->rx_dma_page);\n\tfree_page((unsigned long)p->tx_dma_page);\n\tdma_release_channel(ctlr->dma_rx);\n\tdma_release_channel(ctlr->dma_tx);\n}\n\nstatic int sh_msiof_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_controller *ctlr;\n\tconst struct sh_msiof_chipdata *chipdata;\n\tstruct sh_msiof_spi_info *info;\n\tstruct sh_msiof_spi_priv *p;\n\tunsigned long clksrc;\n\tint i;\n\tint ret;\n\n\tchipdata = of_device_get_match_data(&pdev->dev);\n\tif (chipdata) {\n\t\tinfo = sh_msiof_spi_parse_dt(&pdev->dev);\n\t} else {\n\t\tchipdata = (const void *)pdev->id_entry->driver_data;\n\t\tinfo = dev_get_platdata(&pdev->dev);\n\t}\n\n\tif (!info) {\n\t\tdev_err(&pdev->dev, \"failed to obtain device info\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (chipdata->flags & SH_MSIOF_FLAG_FIXED_DTDL_200)\n\t\tinfo->dtdl = 200;\n\n\tif (info->mode == MSIOF_SPI_TARGET)\n\t\tctlr = spi_alloc_target(&pdev->dev,\n\t\t\t\t        sizeof(struct sh_msiof_spi_priv));\n\telse\n\t\tctlr = spi_alloc_host(&pdev->dev,\n\t\t\t\t      sizeof(struct sh_msiof_spi_priv));\n\tif (ctlr == NULL)\n\t\treturn -ENOMEM;\n\n\tp = spi_controller_get_devdata(ctlr);\n\n\tplatform_set_drvdata(pdev, p);\n\tp->ctlr = ctlr;\n\tp->info = info;\n\tp->min_div_pow = chipdata->min_div_pow;\n\n\tinit_completion(&p->done);\n\tinit_completion(&p->done_txdma);\n\n\tp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(p->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\tret = PTR_ERR(p->clk);\n\t\tgoto err1;\n\t}\n\n\ti = platform_get_irq(pdev, 0);\n\tif (i < 0) {\n\t\tret = i;\n\t\tgoto err1;\n\t}\n\n\tp->mapbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->mapbase)) {\n\t\tret = PTR_ERR(p->mapbase);\n\t\tgoto err1;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, i, sh_msiof_spi_irq, 0,\n\t\t\t       dev_name(&pdev->dev), p);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to request irq\\n\");\n\t\tgoto err1;\n\t}\n\n\tp->pdev = pdev;\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tp->tx_fifo_size = chipdata->tx_fifo_size;\n\tp->rx_fifo_size = chipdata->rx_fifo_size;\n\tif (p->info->tx_fifo_override)\n\t\tp->tx_fifo_size = p->info->tx_fifo_override;\n\tif (p->info->rx_fifo_override)\n\t\tp->rx_fifo_size = p->info->rx_fifo_override;\n\n\t \n\tctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tctlr->mode_bits |= SPI_LSB_FIRST | SPI_3WIRE;\n\tclksrc = clk_get_rate(p->clk);\n\tctlr->min_speed_hz = DIV_ROUND_UP(clksrc, 1024);\n\tctlr->max_speed_hz = DIV_ROUND_UP(clksrc, 1 << p->min_div_pow);\n\tctlr->flags = chipdata->ctlr_flags;\n\tctlr->bus_num = pdev->id;\n\tctlr->num_chipselect = p->info->num_chipselect;\n\tctlr->dev.of_node = pdev->dev.of_node;\n\tctlr->setup = sh_msiof_spi_setup;\n\tctlr->prepare_message = sh_msiof_prepare_message;\n\tctlr->target_abort = sh_msiof_target_abort;\n\tctlr->bits_per_word_mask = chipdata->bits_per_word_mask;\n\tctlr->auto_runtime_pm = true;\n\tctlr->transfer_one = sh_msiof_transfer_one;\n\tctlr->use_gpio_descriptors = true;\n\tctlr->max_native_cs = MAX_SS;\n\n\tret = sh_msiof_request_dma(p);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"DMA not available, using PIO\\n\");\n\n\tret = devm_spi_register_controller(&pdev->dev, ctlr);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"devm_spi_register_controller error.\\n\");\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\n err2:\n\tsh_msiof_release_dma(p);\n\tpm_runtime_disable(&pdev->dev);\n err1:\n\tspi_controller_put(ctlr);\n\treturn ret;\n}\n\nstatic void sh_msiof_spi_remove(struct platform_device *pdev)\n{\n\tstruct sh_msiof_spi_priv *p = platform_get_drvdata(pdev);\n\n\tsh_msiof_release_dma(p);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct platform_device_id spi_driver_ids[] = {\n\t{ \"spi_sh_msiof\",\t(kernel_ulong_t)&sh_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, spi_driver_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sh_msiof_spi_suspend(struct device *dev)\n{\n\tstruct sh_msiof_spi_priv *p = dev_get_drvdata(dev);\n\n\treturn spi_controller_suspend(p->ctlr);\n}\n\nstatic int sh_msiof_spi_resume(struct device *dev)\n{\n\tstruct sh_msiof_spi_priv *p = dev_get_drvdata(dev);\n\n\treturn spi_controller_resume(p->ctlr);\n}\n\nstatic SIMPLE_DEV_PM_OPS(sh_msiof_spi_pm_ops, sh_msiof_spi_suspend,\n\t\t\t sh_msiof_spi_resume);\n#define DEV_PM_OPS\t(&sh_msiof_spi_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic struct platform_driver sh_msiof_spi_drv = {\n\t.probe\t\t= sh_msiof_spi_probe,\n\t.remove_new\t= sh_msiof_spi_remove,\n\t.id_table\t= spi_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t\t= \"spi_sh_msiof\",\n\t\t.pm\t\t= DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(sh_msiof_match),\n\t},\n};\nmodule_platform_driver(sh_msiof_spi_drv);\n\nMODULE_DESCRIPTION(\"SuperH MSIOF SPI Controller Interface Driver\");\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}