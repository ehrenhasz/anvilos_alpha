{
  "module_name": "spi-pl022.c",
  "hash_id": "0d62c0e6613f98535866765903cb11a424d1395fc99479354faa3559a8340006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-pl022.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/amba/bus.h>\n#include <linux/amba/pl022.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n\n \n#define SSP_WRITE_BITS(reg, val, mask, sb) \\\n ((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))\n\n \n#define GEN_MASK_BITS(val, mask, sb) \\\n (((val)<<(sb)) & (mask))\n\n#define DRIVE_TX\t\t0\n#define DO_NOT_DRIVE_TX\t\t1\n\n#define DO_NOT_QUEUE_DMA\t0\n#define QUEUE_DMA\t\t1\n\n#define RX_TRANSFER\t\t1\n#define TX_TRANSFER\t\t2\n\n \n#define SSP_CR0(r)\t(r + 0x000)\n#define SSP_CR1(r)\t(r + 0x004)\n#define SSP_DR(r)\t(r + 0x008)\n#define SSP_SR(r)\t(r + 0x00C)\n#define SSP_CPSR(r)\t(r + 0x010)\n#define SSP_IMSC(r)\t(r + 0x014)\n#define SSP_RIS(r)\t(r + 0x018)\n#define SSP_MIS(r)\t(r + 0x01C)\n#define SSP_ICR(r)\t(r + 0x020)\n#define SSP_DMACR(r)\t(r + 0x024)\n#define SSP_CSR(r)\t(r + 0x030)  \n#define SSP_ITCR(r)\t(r + 0x080)\n#define SSP_ITIP(r)\t(r + 0x084)\n#define SSP_ITOP(r)\t(r + 0x088)\n#define SSP_TDR(r)\t(r + 0x08C)\n\n#define SSP_PID0(r)\t(r + 0xFE0)\n#define SSP_PID1(r)\t(r + 0xFE4)\n#define SSP_PID2(r)\t(r + 0xFE8)\n#define SSP_PID3(r)\t(r + 0xFEC)\n\n#define SSP_CID0(r)\t(r + 0xFF0)\n#define SSP_CID1(r)\t(r + 0xFF4)\n#define SSP_CID2(r)\t(r + 0xFF8)\n#define SSP_CID3(r)\t(r + 0xFFC)\n\n \n#define SSP_CR0_MASK_DSS\t(0x0FUL << 0)\n#define SSP_CR0_MASK_FRF\t(0x3UL << 4)\n#define SSP_CR0_MASK_SPO\t(0x1UL << 6)\n#define SSP_CR0_MASK_SPH\t(0x1UL << 7)\n#define SSP_CR0_MASK_SCR\t(0xFFUL << 8)\n\n \n#define SSP_CR0_MASK_DSS_ST\t(0x1FUL << 0)\n#define SSP_CR0_MASK_HALFDUP_ST\t(0x1UL << 5)\n#define SSP_CR0_MASK_CSS_ST\t(0x1FUL << 16)\n#define SSP_CR0_MASK_FRF_ST\t(0x3UL << 21)\n\n \n#define SSP_CR1_MASK_LBM\t(0x1UL << 0)\n#define SSP_CR1_MASK_SSE\t(0x1UL << 1)\n#define SSP_CR1_MASK_MS\t\t(0x1UL << 2)\n#define SSP_CR1_MASK_SOD\t(0x1UL << 3)\n\n \n#define SSP_CR1_MASK_RENDN_ST\t(0x1UL << 4)\n#define SSP_CR1_MASK_TENDN_ST\t(0x1UL << 5)\n#define SSP_CR1_MASK_MWAIT_ST\t(0x1UL << 6)\n#define SSP_CR1_MASK_RXIFLSEL_ST (0x7UL << 7)\n#define SSP_CR1_MASK_TXIFLSEL_ST (0x7UL << 10)\n \n#define SSP_CR1_MASK_FBCLKDEL_ST (0x7UL << 13)\n\n \n#define SSP_SR_MASK_TFE\t\t(0x1UL << 0)  \n#define SSP_SR_MASK_TNF\t\t(0x1UL << 1)  \n#define SSP_SR_MASK_RNE\t\t(0x1UL << 2)  \n#define SSP_SR_MASK_RFF\t\t(0x1UL << 3)  \n#define SSP_SR_MASK_BSY\t\t(0x1UL << 4)  \n\n \n#define SSP_CPSR_MASK_CPSDVSR\t(0xFFUL << 0)\n\n \n#define SSP_IMSC_MASK_RORIM (0x1UL << 0)  \n#define SSP_IMSC_MASK_RTIM  (0x1UL << 1)  \n#define SSP_IMSC_MASK_RXIM  (0x1UL << 2)  \n#define SSP_IMSC_MASK_TXIM  (0x1UL << 3)  \n\n \n \n#define SSP_RIS_MASK_RORRIS\t\t(0x1UL << 0)\n \n#define SSP_RIS_MASK_RTRIS\t\t(0x1UL << 1)\n \n#define SSP_RIS_MASK_RXRIS\t\t(0x1UL << 2)\n \n#define SSP_RIS_MASK_TXRIS\t\t(0x1UL << 3)\n\n \n \n#define SSP_MIS_MASK_RORMIS\t\t(0x1UL << 0)\n \n#define SSP_MIS_MASK_RTMIS\t\t(0x1UL << 1)\n \n#define SSP_MIS_MASK_RXMIS\t\t(0x1UL << 2)\n \n#define SSP_MIS_MASK_TXMIS\t\t(0x1UL << 3)\n\n \n \n#define SSP_ICR_MASK_RORIC\t\t(0x1UL << 0)\n \n#define SSP_ICR_MASK_RTIC\t\t(0x1UL << 1)\n\n \n \n#define SSP_DMACR_MASK_RXDMAE\t\t(0x1UL << 0)\n \n#define SSP_DMACR_MASK_TXDMAE\t\t(0x1UL << 1)\n\n \n#define SSP_CSR_CSVALUE_MASK\t\t(0x1FUL << 0)\n\n \n#define SSP_ITCR_MASK_ITEN\t\t(0x1UL << 0)\n#define SSP_ITCR_MASK_TESTFIFO\t\t(0x1UL << 1)\n\n \n#define ITIP_MASK_SSPRXD\t\t (0x1UL << 0)\n#define ITIP_MASK_SSPFSSIN\t\t (0x1UL << 1)\n#define ITIP_MASK_SSPCLKIN\t\t (0x1UL << 2)\n#define ITIP_MASK_RXDMAC\t\t (0x1UL << 3)\n#define ITIP_MASK_TXDMAC\t\t (0x1UL << 4)\n#define ITIP_MASK_SSPTXDIN\t\t (0x1UL << 5)\n\n \n#define ITOP_MASK_SSPTXD\t\t (0x1UL << 0)\n#define ITOP_MASK_SSPFSSOUT\t\t (0x1UL << 1)\n#define ITOP_MASK_SSPCLKOUT\t\t (0x1UL << 2)\n#define ITOP_MASK_SSPOEn\t\t (0x1UL << 3)\n#define ITOP_MASK_SSPCTLOEn\t\t (0x1UL << 4)\n#define ITOP_MASK_RORINTR\t\t (0x1UL << 5)\n#define ITOP_MASK_RTINTR\t\t (0x1UL << 6)\n#define ITOP_MASK_RXINTR\t\t (0x1UL << 7)\n#define ITOP_MASK_TXINTR\t\t (0x1UL << 8)\n#define ITOP_MASK_INTR\t\t\t (0x1UL << 9)\n#define ITOP_MASK_RXDMABREQ\t\t (0x1UL << 10)\n#define ITOP_MASK_RXDMASREQ\t\t (0x1UL << 11)\n#define ITOP_MASK_TXDMABREQ\t\t (0x1UL << 12)\n#define ITOP_MASK_TXDMASREQ\t\t (0x1UL << 13)\n\n \n#define TDR_MASK_TESTDATA\t\t(0xFFFFFFFF)\n\n \n#define STATE_START\t\t\t((void *) 0)\n#define STATE_RUNNING\t\t\t((void *) 1)\n#define STATE_DONE\t\t\t((void *) 2)\n#define STATE_ERROR\t\t\t((void *) -1)\n#define STATE_TIMEOUT\t\t\t((void *) -2)\n\n \n#define SSP_DISABLED\t\t\t(0)\n#define SSP_ENABLED\t\t\t(1)\n\n \n#define SSP_DMA_DISABLED\t\t(0)\n#define SSP_DMA_ENABLED\t\t\t(1)\n\n \n#define SSP_DEFAULT_CLKRATE 0x2\n#define SSP_DEFAULT_PRESCALE 0x40\n\n \n#define CPSDVR_MIN 0x02\n#define CPSDVR_MAX 0xFE\n#define SCR_MIN 0x00\n#define SCR_MAX 0xFF\n\n \n#define DEFAULT_SSP_REG_IMSC  0x0UL\n#define DISABLE_ALL_INTERRUPTS DEFAULT_SSP_REG_IMSC\n#define ENABLE_ALL_INTERRUPTS ( \\\n\tSSP_IMSC_MASK_RORIM | \\\n\tSSP_IMSC_MASK_RTIM | \\\n\tSSP_IMSC_MASK_RXIM | \\\n\tSSP_IMSC_MASK_TXIM \\\n)\n\n#define CLEAR_ALL_INTERRUPTS  0x3\n\n#define SPI_POLLING_TIMEOUT 1000\n\n \nenum ssp_reading {\n\tREADING_NULL,\n\tREADING_U8,\n\tREADING_U16,\n\tREADING_U32\n};\n\n \nenum ssp_writing {\n\tWRITING_NULL,\n\tWRITING_U8,\n\tWRITING_U16,\n\tWRITING_U32\n};\n\n \nstruct vendor_data {\n\tint fifodepth;\n\tint max_bpw;\n\tbool unidir;\n\tbool extended_cr;\n\tbool pl023;\n\tbool loopback;\n\tbool internal_cs_ctrl;\n};\n\n \nstruct pl022 {\n\tstruct amba_device\t\t*adev;\n\tstruct vendor_data\t\t*vendor;\n\tresource_size_t\t\t\tphybase;\n\tvoid __iomem\t\t\t*virtbase;\n\tstruct clk\t\t\t*clk;\n\tstruct spi_controller\t\t*host;\n\tstruct pl022_ssp_controller\t*host_info;\n\t \n\tstruct tasklet_struct\t\tpump_transfers;\n\tstruct spi_message\t\t*cur_msg;\n\tstruct spi_transfer\t\t*cur_transfer;\n\tstruct chip_data\t\t*cur_chip;\n\tbool\t\t\t\tnext_msg_cs_active;\n\tvoid\t\t\t\t*tx;\n\tvoid\t\t\t\t*tx_end;\n\tvoid\t\t\t\t*rx;\n\tvoid\t\t\t\t*rx_end;\n\tenum ssp_reading\t\tread;\n\tenum ssp_writing\t\twrite;\n\tu32\t\t\t\texp_fifo_level;\n\tenum ssp_rx_level_trig\t\trx_lev_trig;\n\tenum ssp_tx_level_trig\t\ttx_lev_trig;\n\t \n#ifdef CONFIG_DMA_ENGINE\n\tstruct dma_chan\t\t\t*dma_rx_channel;\n\tstruct dma_chan\t\t\t*dma_tx_channel;\n\tstruct sg_table\t\t\tsgt_rx;\n\tstruct sg_table\t\t\tsgt_tx;\n\tchar\t\t\t\t*dummypage;\n\tbool\t\t\t\tdma_running;\n#endif\n\tint cur_cs;\n\tstruct gpio_desc *cur_gpiod;\n};\n\n \nstruct chip_data {\n\tu32 cr0;\n\tu16 cr1;\n\tu16 dmacr;\n\tu16 cpsr;\n\tu8 n_bytes;\n\tbool enable_dma;\n\tenum ssp_reading read;\n\tenum ssp_writing write;\n\tint xfer_type;\n};\n\n \nstatic void internal_cs_control(struct pl022 *pl022, u32 command)\n{\n\tu32 tmp;\n\n\ttmp = readw(SSP_CSR(pl022->virtbase));\n\tif (command == SSP_CHIP_SELECT)\n\t\ttmp &= ~BIT(pl022->cur_cs);\n\telse\n\t\ttmp |= BIT(pl022->cur_cs);\n\twritew(tmp, SSP_CSR(pl022->virtbase));\n}\n\nstatic void pl022_cs_control(struct pl022 *pl022, u32 command)\n{\n\tif (pl022->vendor->internal_cs_ctrl)\n\t\tinternal_cs_control(pl022, command);\n\telse if (pl022->cur_gpiod)\n\t\t \n\t\tgpiod_set_value(pl022->cur_gpiod, !command);\n}\n\n \nstatic void giveback(struct pl022 *pl022)\n{\n\tstruct spi_transfer *last_transfer;\n\tpl022->next_msg_cs_active = false;\n\n\tlast_transfer = list_last_entry(&pl022->cur_msg->transfers,\n\t\t\t\t\tstruct spi_transfer, transfer_list);\n\n\t \n\t \n\tspi_transfer_delay_exec(last_transfer);\n\n\tif (!last_transfer->cs_change) {\n\t\tstruct spi_message *next_msg;\n\n\t\t \n\t\t \n\t\tnext_msg = spi_get_next_queued_message(pl022->host);\n\n\t\t \n\t\tif (next_msg && next_msg->spi != pl022->cur_msg->spi)\n\t\t\tnext_msg = NULL;\n\t\tif (!next_msg || pl022->cur_msg->state == STATE_ERROR)\n\t\t\tpl022_cs_control(pl022, SSP_CHIP_DESELECT);\n\t\telse\n\t\t\tpl022->next_msg_cs_active = true;\n\n\t}\n\n\tpl022->cur_msg = NULL;\n\tpl022->cur_transfer = NULL;\n\tpl022->cur_chip = NULL;\n\n\t \n\twritew((readw(SSP_CR1(pl022->virtbase)) &\n\t\t(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\n\n\tspi_finalize_current_message(pl022->host);\n}\n\n \nstatic int flush(struct pl022 *pl022)\n{\n\tunsigned long limit = loops_per_jiffy << 1;\n\n\tdev_dbg(&pl022->adev->dev, \"flush\\n\");\n\tdo {\n\t\twhile (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\n\t\t\treadw(SSP_DR(pl022->virtbase));\n\t} while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_BSY) && limit--);\n\n\tpl022->exp_fifo_level = 0;\n\n\treturn limit;\n}\n\n \nstatic void restore_state(struct pl022 *pl022)\n{\n\tstruct chip_data *chip = pl022->cur_chip;\n\n\tif (pl022->vendor->extended_cr)\n\t\twritel(chip->cr0, SSP_CR0(pl022->virtbase));\n\telse\n\t\twritew(chip->cr0, SSP_CR0(pl022->virtbase));\n\twritew(chip->cr1, SSP_CR1(pl022->virtbase));\n\twritew(chip->dmacr, SSP_DMACR(pl022->virtbase));\n\twritew(chip->cpsr, SSP_CPSR(pl022->virtbase));\n\twritew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));\n\twritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\n}\n\n \n#define DEFAULT_SSP_REG_CR0 ( \\\n\tGEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS, 0)\t| \\\n\tGEN_MASK_BITS(SSP_INTERFACE_MOTOROLA_SPI, SSP_CR0_MASK_FRF, 4) | \\\n\tGEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \\\n\tGEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \\\n\tGEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) \\\n)\n\n \n#define DEFAULT_SSP_REG_CR0_ST ( \\\n\tGEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)\t| \\\n\tGEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, SSP_CR0_MASK_HALFDUP_ST, 5) | \\\n\tGEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \\\n\tGEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \\\n\tGEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) | \\\n\tGEN_MASK_BITS(SSP_BITS_8, SSP_CR0_MASK_CSS_ST, 16)\t| \\\n\tGEN_MASK_BITS(SSP_INTERFACE_MOTOROLA_SPI, SSP_CR0_MASK_FRF_ST, 21) \\\n)\n\n \n#define DEFAULT_SSP_REG_CR0_ST_PL023 ( \\\n\tGEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)\t| \\\n\tGEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \\\n\tGEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \\\n\tGEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) \\\n)\n\n#define DEFAULT_SSP_REG_CR1 ( \\\n\tGEN_MASK_BITS(LOOPBACK_DISABLED, SSP_CR1_MASK_LBM, 0) | \\\n\tGEN_MASK_BITS(SSP_DISABLED, SSP_CR1_MASK_SSE, 1) | \\\n\tGEN_MASK_BITS(SSP_MASTER, SSP_CR1_MASK_MS, 2) | \\\n\tGEN_MASK_BITS(DO_NOT_DRIVE_TX, SSP_CR1_MASK_SOD, 3) \\\n)\n\n \n#define DEFAULT_SSP_REG_CR1_ST ( \\\n\tDEFAULT_SSP_REG_CR1 | \\\n\tGEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \\\n\tGEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \\\n\tGEN_MASK_BITS(SSP_MWIRE_WAIT_ZERO, SSP_CR1_MASK_MWAIT_ST, 6) |\\\n\tGEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \\\n\tGEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) \\\n)\n\n \n#define DEFAULT_SSP_REG_CR1_ST_PL023 ( \\\n\tGEN_MASK_BITS(SSP_DISABLED, SSP_CR1_MASK_SSE, 1) | \\\n\tGEN_MASK_BITS(SSP_MASTER, SSP_CR1_MASK_MS, 2) | \\\n\tGEN_MASK_BITS(DO_NOT_DRIVE_TX, SSP_CR1_MASK_SOD, 3) | \\\n\tGEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \\\n\tGEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \\\n\tGEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \\\n\tGEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) | \\\n\tGEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \\\n)\n\n#define DEFAULT_SSP_REG_CPSR ( \\\n\tGEN_MASK_BITS(SSP_DEFAULT_PRESCALE, SSP_CPSR_MASK_CPSDVSR, 0) \\\n)\n\n#define DEFAULT_SSP_REG_DMACR (\\\n\tGEN_MASK_BITS(SSP_DMA_DISABLED, SSP_DMACR_MASK_RXDMAE, 0) | \\\n\tGEN_MASK_BITS(SSP_DMA_DISABLED, SSP_DMACR_MASK_TXDMAE, 1) \\\n)\n\n \nstatic void load_ssp_default_config(struct pl022 *pl022)\n{\n\tif (pl022->vendor->pl023) {\n\t\twritel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));\n\t\twritew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));\n\t} else if (pl022->vendor->extended_cr) {\n\t\twritel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));\n\t\twritew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));\n\t} else {\n\t\twritew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));\n\t\twritew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));\n\t}\n\twritew(DEFAULT_SSP_REG_DMACR, SSP_DMACR(pl022->virtbase));\n\twritew(DEFAULT_SSP_REG_CPSR, SSP_CPSR(pl022->virtbase));\n\twritew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));\n\twritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\n}\n\n \nstatic void readwriter(struct pl022 *pl022)\n{\n\n\t \n\tdev_dbg(&pl022->adev->dev,\n\t\t\"%s, rx: %p, rxend: %p, tx: %p, txend: %p\\n\",\n\t\t__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);\n\n\t \n\twhile ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\n\t       && (pl022->rx < pl022->rx_end)) {\n\t\tswitch (pl022->read) {\n\t\tcase READING_NULL:\n\t\t\treadw(SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\tcase READING_U8:\n\t\t\t*(u8 *) (pl022->rx) =\n\t\t\t\treadw(SSP_DR(pl022->virtbase)) & 0xFFU;\n\t\t\tbreak;\n\t\tcase READING_U16:\n\t\t\t*(u16 *) (pl022->rx) =\n\t\t\t\t(u16) readw(SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\tcase READING_U32:\n\t\t\t*(u32 *) (pl022->rx) =\n\t\t\t\treadl(SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\t}\n\t\tpl022->rx += (pl022->cur_chip->n_bytes);\n\t\tpl022->exp_fifo_level--;\n\t}\n\t \n\twhile ((pl022->exp_fifo_level < pl022->vendor->fifodepth)\n\t       && (pl022->tx < pl022->tx_end)) {\n\t\tswitch (pl022->write) {\n\t\tcase WRITING_NULL:\n\t\t\twritew(0x0, SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\tcase WRITING_U8:\n\t\t\twritew(*(u8 *) (pl022->tx), SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\tcase WRITING_U16:\n\t\t\twritew((*(u16 *) (pl022->tx)), SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\tcase WRITING_U32:\n\t\t\twritel(*(u32 *) (pl022->tx), SSP_DR(pl022->virtbase));\n\t\t\tbreak;\n\t\t}\n\t\tpl022->tx += (pl022->cur_chip->n_bytes);\n\t\tpl022->exp_fifo_level++;\n\t\t \n\t\twhile ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\n\t\t       && (pl022->rx < pl022->rx_end)) {\n\t\t\tswitch (pl022->read) {\n\t\t\tcase READING_NULL:\n\t\t\t\treadw(SSP_DR(pl022->virtbase));\n\t\t\t\tbreak;\n\t\t\tcase READING_U8:\n\t\t\t\t*(u8 *) (pl022->rx) =\n\t\t\t\t\treadw(SSP_DR(pl022->virtbase)) & 0xFFU;\n\t\t\t\tbreak;\n\t\t\tcase READING_U16:\n\t\t\t\t*(u16 *) (pl022->rx) =\n\t\t\t\t\t(u16) readw(SSP_DR(pl022->virtbase));\n\t\t\t\tbreak;\n\t\t\tcase READING_U32:\n\t\t\t\t*(u32 *) (pl022->rx) =\n\t\t\t\t\treadl(SSP_DR(pl022->virtbase));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpl022->rx += (pl022->cur_chip->n_bytes);\n\t\t\tpl022->exp_fifo_level--;\n\t\t}\n\t}\n\t \n}\n\n \nstatic void *next_transfer(struct pl022 *pl022)\n{\n\tstruct spi_message *msg = pl022->cur_msg;\n\tstruct spi_transfer *trans = pl022->cur_transfer;\n\n\t \n\tif (trans->transfer_list.next != &msg->transfers) {\n\t\tpl022->cur_transfer =\n\t\t    list_entry(trans->transfer_list.next,\n\t\t\t       struct spi_transfer, transfer_list);\n\t\treturn STATE_RUNNING;\n\t}\n\treturn STATE_DONE;\n}\n\n \n#ifdef CONFIG_DMA_ENGINE\nstatic void unmap_free_dma_scatter(struct pl022 *pl022)\n{\n\t \n\tdma_unmap_sg(pl022->dma_tx_channel->device->dev, pl022->sgt_tx.sgl,\n\t\t     pl022->sgt_tx.nents, DMA_TO_DEVICE);\n\tdma_unmap_sg(pl022->dma_rx_channel->device->dev, pl022->sgt_rx.sgl,\n\t\t     pl022->sgt_rx.nents, DMA_FROM_DEVICE);\n\tsg_free_table(&pl022->sgt_rx);\n\tsg_free_table(&pl022->sgt_tx);\n}\n\nstatic void dma_callback(void *data)\n{\n\tstruct pl022 *pl022 = data;\n\tstruct spi_message *msg = pl022->cur_msg;\n\n\tBUG_ON(!pl022->sgt_rx.sgl);\n\n#ifdef VERBOSE_DEBUG\n\t \n\t{\n\t\tstruct scatterlist *sg;\n\t\tunsigned int i;\n\n\t\tdma_sync_sg_for_cpu(&pl022->adev->dev,\n\t\t\t\t    pl022->sgt_rx.sgl,\n\t\t\t\t    pl022->sgt_rx.nents,\n\t\t\t\t    DMA_FROM_DEVICE);\n\n\t\tfor_each_sg(pl022->sgt_rx.sgl, sg, pl022->sgt_rx.nents, i) {\n\t\t\tdev_dbg(&pl022->adev->dev, \"SPI RX SG ENTRY: %d\", i);\n\t\t\tprint_hex_dump(KERN_ERR, \"SPI RX: \",\n\t\t\t\t       DUMP_PREFIX_OFFSET,\n\t\t\t\t       16,\n\t\t\t\t       1,\n\t\t\t\t       sg_virt(sg),\n\t\t\t\t       sg_dma_len(sg),\n\t\t\t\t       1);\n\t\t}\n\t\tfor_each_sg(pl022->sgt_tx.sgl, sg, pl022->sgt_tx.nents, i) {\n\t\t\tdev_dbg(&pl022->adev->dev, \"SPI TX SG ENTRY: %d\", i);\n\t\t\tprint_hex_dump(KERN_ERR, \"SPI TX: \",\n\t\t\t\t       DUMP_PREFIX_OFFSET,\n\t\t\t\t       16,\n\t\t\t\t       1,\n\t\t\t\t       sg_virt(sg),\n\t\t\t\t       sg_dma_len(sg),\n\t\t\t\t       1);\n\t\t}\n\t}\n#endif\n\n\tunmap_free_dma_scatter(pl022);\n\n\t \n\tmsg->actual_length += pl022->cur_transfer->len;\n\t \n\tmsg->state = next_transfer(pl022);\n\tif (msg->state != STATE_DONE && pl022->cur_transfer->cs_change)\n\t\tpl022_cs_control(pl022, SSP_CHIP_DESELECT);\n\ttasklet_schedule(&pl022->pump_transfers);\n}\n\nstatic void setup_dma_scatter(struct pl022 *pl022,\n\t\t\t      void *buffer,\n\t\t\t      unsigned int length,\n\t\t\t      struct sg_table *sgtab)\n{\n\tstruct scatterlist *sg;\n\tint bytesleft = length;\n\tvoid *bufp = buffer;\n\tint mapbytes;\n\tint i;\n\n\tif (buffer) {\n\t\tfor_each_sg(sgtab->sgl, sg, sgtab->nents, i) {\n\t\t\t \n\t\t\tif (bytesleft < (PAGE_SIZE - offset_in_page(bufp)))\n\t\t\t\tmapbytes = bytesleft;\n\t\t\telse\n\t\t\t\tmapbytes = PAGE_SIZE - offset_in_page(bufp);\n\t\t\tsg_set_page(sg, virt_to_page(bufp),\n\t\t\t\t    mapbytes, offset_in_page(bufp));\n\t\t\tbufp += mapbytes;\n\t\t\tbytesleft -= mapbytes;\n\t\t\tdev_dbg(&pl022->adev->dev,\n\t\t\t\t\"set RX/TX target page @ %p, %d bytes, %d left\\n\",\n\t\t\t\tbufp, mapbytes, bytesleft);\n\t\t}\n\t} else {\n\t\t \n\t\tfor_each_sg(sgtab->sgl, sg, sgtab->nents, i) {\n\t\t\tif (bytesleft < PAGE_SIZE)\n\t\t\t\tmapbytes = bytesleft;\n\t\t\telse\n\t\t\t\tmapbytes = PAGE_SIZE;\n\t\t\tsg_set_page(sg, virt_to_page(pl022->dummypage),\n\t\t\t\t    mapbytes, 0);\n\t\t\tbytesleft -= mapbytes;\n\t\t\tdev_dbg(&pl022->adev->dev,\n\t\t\t\t\"set RX/TX to dummy page %d bytes, %d left\\n\",\n\t\t\t\tmapbytes, bytesleft);\n\n\t\t}\n\t}\n\tBUG_ON(bytesleft);\n}\n\n \nstatic int configure_dma(struct pl022 *pl022)\n{\n\tstruct dma_slave_config rx_conf = {\n\t\t.src_addr = SSP_DR(pl022->phybase),\n\t\t.direction = DMA_DEV_TO_MEM,\n\t\t.device_fc = false,\n\t};\n\tstruct dma_slave_config tx_conf = {\n\t\t.dst_addr = SSP_DR(pl022->phybase),\n\t\t.direction = DMA_MEM_TO_DEV,\n\t\t.device_fc = false,\n\t};\n\tunsigned int pages;\n\tint ret;\n\tint rx_sglen, tx_sglen;\n\tstruct dma_chan *rxchan = pl022->dma_rx_channel;\n\tstruct dma_chan *txchan = pl022->dma_tx_channel;\n\tstruct dma_async_tx_descriptor *rxdesc;\n\tstruct dma_async_tx_descriptor *txdesc;\n\n\t \n\tif (!rxchan || !txchan)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (pl022->rx_lev_trig) {\n\tcase SSP_RX_1_OR_MORE_ELEM:\n\t\trx_conf.src_maxburst = 1;\n\t\tbreak;\n\tcase SSP_RX_4_OR_MORE_ELEM:\n\t\trx_conf.src_maxburst = 4;\n\t\tbreak;\n\tcase SSP_RX_8_OR_MORE_ELEM:\n\t\trx_conf.src_maxburst = 8;\n\t\tbreak;\n\tcase SSP_RX_16_OR_MORE_ELEM:\n\t\trx_conf.src_maxburst = 16;\n\t\tbreak;\n\tcase SSP_RX_32_OR_MORE_ELEM:\n\t\trx_conf.src_maxburst = 32;\n\t\tbreak;\n\tdefault:\n\t\trx_conf.src_maxburst = pl022->vendor->fifodepth >> 1;\n\t\tbreak;\n\t}\n\n\tswitch (pl022->tx_lev_trig) {\n\tcase SSP_TX_1_OR_MORE_EMPTY_LOC:\n\t\ttx_conf.dst_maxburst = 1;\n\t\tbreak;\n\tcase SSP_TX_4_OR_MORE_EMPTY_LOC:\n\t\ttx_conf.dst_maxburst = 4;\n\t\tbreak;\n\tcase SSP_TX_8_OR_MORE_EMPTY_LOC:\n\t\ttx_conf.dst_maxburst = 8;\n\t\tbreak;\n\tcase SSP_TX_16_OR_MORE_EMPTY_LOC:\n\t\ttx_conf.dst_maxburst = 16;\n\t\tbreak;\n\tcase SSP_TX_32_OR_MORE_EMPTY_LOC:\n\t\ttx_conf.dst_maxburst = 32;\n\t\tbreak;\n\tdefault:\n\t\ttx_conf.dst_maxburst = pl022->vendor->fifodepth >> 1;\n\t\tbreak;\n\t}\n\n\tswitch (pl022->read) {\n\tcase READING_NULL:\n\t\t \n\t\trx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\t\tbreak;\n\tcase READING_U8:\n\t\trx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tcase READING_U16:\n\t\trx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase READING_U32:\n\t\trx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\t}\n\n\tswitch (pl022->write) {\n\tcase WRITING_NULL:\n\t\t \n\t\ttx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\t\tbreak;\n\tcase WRITING_U8:\n\t\ttx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tcase WRITING_U16:\n\t\ttx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase WRITING_U32:\n\t\ttx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\t}\n\n\t \n\tif (rx_conf.src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\trx_conf.src_addr_width = tx_conf.dst_addr_width;\n\tif (tx_conf.dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\ttx_conf.dst_addr_width = rx_conf.src_addr_width;\n\tBUG_ON(rx_conf.src_addr_width != tx_conf.dst_addr_width);\n\n\tdmaengine_slave_config(rxchan, &rx_conf);\n\tdmaengine_slave_config(txchan, &tx_conf);\n\n\t \n\tpages = DIV_ROUND_UP(pl022->cur_transfer->len, PAGE_SIZE);\n\tdev_dbg(&pl022->adev->dev, \"using %d pages for transfer\\n\", pages);\n\n\tret = sg_alloc_table(&pl022->sgt_rx, pages, GFP_ATOMIC);\n\tif (ret)\n\t\tgoto err_alloc_rx_sg;\n\n\tret = sg_alloc_table(&pl022->sgt_tx, pages, GFP_ATOMIC);\n\tif (ret)\n\t\tgoto err_alloc_tx_sg;\n\n\t \n\tsetup_dma_scatter(pl022, pl022->rx,\n\t\t\t  pl022->cur_transfer->len, &pl022->sgt_rx);\n\tsetup_dma_scatter(pl022, pl022->tx,\n\t\t\t  pl022->cur_transfer->len, &pl022->sgt_tx);\n\n\t \n\trx_sglen = dma_map_sg(rxchan->device->dev, pl022->sgt_rx.sgl,\n\t\t\t   pl022->sgt_rx.nents, DMA_FROM_DEVICE);\n\tif (!rx_sglen)\n\t\tgoto err_rx_sgmap;\n\n\ttx_sglen = dma_map_sg(txchan->device->dev, pl022->sgt_tx.sgl,\n\t\t\t   pl022->sgt_tx.nents, DMA_TO_DEVICE);\n\tif (!tx_sglen)\n\t\tgoto err_tx_sgmap;\n\n\t \n\trxdesc = dmaengine_prep_slave_sg(rxchan,\n\t\t\t\t      pl022->sgt_rx.sgl,\n\t\t\t\t      rx_sglen,\n\t\t\t\t      DMA_DEV_TO_MEM,\n\t\t\t\t      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!rxdesc)\n\t\tgoto err_rxdesc;\n\n\ttxdesc = dmaengine_prep_slave_sg(txchan,\n\t\t\t\t      pl022->sgt_tx.sgl,\n\t\t\t\t      tx_sglen,\n\t\t\t\t      DMA_MEM_TO_DEV,\n\t\t\t\t      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!txdesc)\n\t\tgoto err_txdesc;\n\n\t \n\trxdesc->callback = dma_callback;\n\trxdesc->callback_param = pl022;\n\n\t \n\tdmaengine_submit(rxdesc);\n\tdmaengine_submit(txdesc);\n\tdma_async_issue_pending(rxchan);\n\tdma_async_issue_pending(txchan);\n\tpl022->dma_running = true;\n\n\treturn 0;\n\nerr_txdesc:\n\tdmaengine_terminate_all(txchan);\nerr_rxdesc:\n\tdmaengine_terminate_all(rxchan);\n\tdma_unmap_sg(txchan->device->dev, pl022->sgt_tx.sgl,\n\t\t     pl022->sgt_tx.nents, DMA_TO_DEVICE);\nerr_tx_sgmap:\n\tdma_unmap_sg(rxchan->device->dev, pl022->sgt_rx.sgl,\n\t\t     pl022->sgt_rx.nents, DMA_FROM_DEVICE);\nerr_rx_sgmap:\n\tsg_free_table(&pl022->sgt_tx);\nerr_alloc_tx_sg:\n\tsg_free_table(&pl022->sgt_rx);\nerr_alloc_rx_sg:\n\treturn -ENOMEM;\n}\n\nstatic int pl022_dma_probe(struct pl022 *pl022)\n{\n\tdma_cap_mask_t mask;\n\n\t \n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\t \n\tpl022->dma_rx_channel = dma_request_channel(mask,\n\t\t\t\t\t    pl022->host_info->dma_filter,\n\t\t\t\t\t    pl022->host_info->dma_rx_param);\n\tif (!pl022->dma_rx_channel) {\n\t\tdev_dbg(&pl022->adev->dev, \"no RX DMA channel!\\n\");\n\t\tgoto err_no_rxchan;\n\t}\n\n\tpl022->dma_tx_channel = dma_request_channel(mask,\n\t\t\t\t\t    pl022->host_info->dma_filter,\n\t\t\t\t\t    pl022->host_info->dma_tx_param);\n\tif (!pl022->dma_tx_channel) {\n\t\tdev_dbg(&pl022->adev->dev, \"no TX DMA channel!\\n\");\n\t\tgoto err_no_txchan;\n\t}\n\n\tpl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!pl022->dummypage)\n\t\tgoto err_no_dummypage;\n\n\tdev_info(&pl022->adev->dev, \"setup for DMA on RX %s, TX %s\\n\",\n\t\t dma_chan_name(pl022->dma_rx_channel),\n\t\t dma_chan_name(pl022->dma_tx_channel));\n\n\treturn 0;\n\nerr_no_dummypage:\n\tdma_release_channel(pl022->dma_tx_channel);\nerr_no_txchan:\n\tdma_release_channel(pl022->dma_rx_channel);\n\tpl022->dma_rx_channel = NULL;\nerr_no_rxchan:\n\tdev_err(&pl022->adev->dev,\n\t\t\t\"Failed to work in dma mode, work without dma!\\n\");\n\treturn -ENODEV;\n}\n\nstatic int pl022_dma_autoprobe(struct pl022 *pl022)\n{\n\tstruct device *dev = &pl022->adev->dev;\n\tstruct dma_chan *chan;\n\tint err;\n\n\t \n\tchan = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(chan)) {\n\t\terr = PTR_ERR(chan);\n\t\tgoto err_no_rxchan;\n\t}\n\n\tpl022->dma_rx_channel = chan;\n\n\tchan = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(chan)) {\n\t\terr = PTR_ERR(chan);\n\t\tgoto err_no_txchan;\n\t}\n\n\tpl022->dma_tx_channel = chan;\n\n\tpl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!pl022->dummypage) {\n\t\terr = -ENOMEM;\n\t\tgoto err_no_dummypage;\n\t}\n\n\treturn 0;\n\nerr_no_dummypage:\n\tdma_release_channel(pl022->dma_tx_channel);\n\tpl022->dma_tx_channel = NULL;\nerr_no_txchan:\n\tdma_release_channel(pl022->dma_rx_channel);\n\tpl022->dma_rx_channel = NULL;\nerr_no_rxchan:\n\treturn err;\n}\n\nstatic void terminate_dma(struct pl022 *pl022)\n{\n\tstruct dma_chan *rxchan = pl022->dma_rx_channel;\n\tstruct dma_chan *txchan = pl022->dma_tx_channel;\n\n\tdmaengine_terminate_all(rxchan);\n\tdmaengine_terminate_all(txchan);\n\tunmap_free_dma_scatter(pl022);\n\tpl022->dma_running = false;\n}\n\nstatic void pl022_dma_remove(struct pl022 *pl022)\n{\n\tif (pl022->dma_running)\n\t\tterminate_dma(pl022);\n\tif (pl022->dma_tx_channel)\n\t\tdma_release_channel(pl022->dma_tx_channel);\n\tif (pl022->dma_rx_channel)\n\t\tdma_release_channel(pl022->dma_rx_channel);\n\tkfree(pl022->dummypage);\n}\n\n#else\nstatic inline int configure_dma(struct pl022 *pl022)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int pl022_dma_autoprobe(struct pl022 *pl022)\n{\n\treturn 0;\n}\n\nstatic inline int pl022_dma_probe(struct pl022 *pl022)\n{\n\treturn 0;\n}\n\nstatic inline void pl022_dma_remove(struct pl022 *pl022)\n{\n}\n#endif\n\n \nstatic irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct pl022 *pl022 = dev_id;\n\tstruct spi_message *msg = pl022->cur_msg;\n\tu16 irq_status = 0;\n\n\tif (unlikely(!msg)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"bad message state in interrupt handler\");\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tirq_status = readw(SSP_MIS(pl022->virtbase));\n\n\tif (unlikely(!irq_status))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (unlikely(irq_status & SSP_MIS_MASK_RORMIS)) {\n\t\t \n\t\tdev_err(&pl022->adev->dev, \"FIFO overrun\\n\");\n\t\tif (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RFF)\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\t\"RXFIFO is full\\n\");\n\n\t\t \n\t\twritew(DISABLE_ALL_INTERRUPTS,\n\t\t       SSP_IMSC(pl022->virtbase));\n\t\twritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\n\t\twritew((readw(SSP_CR1(pl022->virtbase)) &\n\t\t\t(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\n\t\tmsg->state = STATE_ERROR;\n\n\t\t \n\t\ttasklet_schedule(&pl022->pump_transfers);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treadwriter(pl022);\n\n\tif (pl022->tx == pl022->tx_end) {\n\t\t \n\t\twritew((readw(SSP_IMSC(pl022->virtbase)) &\n\t\t       ~SSP_IMSC_MASK_TXIM) | SSP_IMSC_MASK_RXIM,\n\t\t       SSP_IMSC(pl022->virtbase));\n\t}\n\n\t \n\tif (pl022->rx >= pl022->rx_end) {\n\t\twritew(DISABLE_ALL_INTERRUPTS,\n\t\t       SSP_IMSC(pl022->virtbase));\n\t\twritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\n\t\tif (unlikely(pl022->rx > pl022->rx_end)) {\n\t\t\tdev_warn(&pl022->adev->dev, \"read %u surplus \"\n\t\t\t\t \"bytes (did you request an odd \"\n\t\t\t\t \"number of bytes on a 16bit bus?)\\n\",\n\t\t\t\t (u32) (pl022->rx - pl022->rx_end));\n\t\t}\n\t\t \n\t\tmsg->actual_length += pl022->cur_transfer->len;\n\t\t \n\t\tmsg->state = next_transfer(pl022);\n\t\tif (msg->state != STATE_DONE && pl022->cur_transfer->cs_change)\n\t\t\tpl022_cs_control(pl022, SSP_CHIP_DESELECT);\n\t\ttasklet_schedule(&pl022->pump_transfers);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int set_up_next_transfer(struct pl022 *pl022,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tint residue;\n\n\t \n\tresidue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;\n\tif (unlikely(residue != 0)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"message of %u bytes to transmit but the current \"\n\t\t\t\"chip bus has a data width of %u bytes!\\n\",\n\t\t\tpl022->cur_transfer->len,\n\t\t\tpl022->cur_chip->n_bytes);\n\t\tdev_err(&pl022->adev->dev, \"skipping this message\\n\");\n\t\treturn -EIO;\n\t}\n\tpl022->tx = (void *)transfer->tx_buf;\n\tpl022->tx_end = pl022->tx + pl022->cur_transfer->len;\n\tpl022->rx = (void *)transfer->rx_buf;\n\tpl022->rx_end = pl022->rx + pl022->cur_transfer->len;\n\tpl022->write =\n\t    pl022->tx ? pl022->cur_chip->write : WRITING_NULL;\n\tpl022->read = pl022->rx ? pl022->cur_chip->read : READING_NULL;\n\treturn 0;\n}\n\n \nstatic void pump_transfers(unsigned long data)\n{\n\tstruct pl022 *pl022 = (struct pl022 *) data;\n\tstruct spi_message *message = NULL;\n\tstruct spi_transfer *transfer = NULL;\n\tstruct spi_transfer *previous = NULL;\n\n\t \n\tmessage = pl022->cur_msg;\n\ttransfer = pl022->cur_transfer;\n\n\t \n\tif (message->state == STATE_ERROR) {\n\t\tmessage->status = -EIO;\n\t\tgiveback(pl022);\n\t\treturn;\n\t}\n\n\t \n\tif (message->state == STATE_DONE) {\n\t\tmessage->status = 0;\n\t\tgiveback(pl022);\n\t\treturn;\n\t}\n\n\t \n\tif (message->state == STATE_RUNNING) {\n\t\tprevious = list_entry(transfer->transfer_list.prev,\n\t\t\t\t\tstruct spi_transfer,\n\t\t\t\t\ttransfer_list);\n\t\t \n\t\tspi_transfer_delay_exec(previous);\n\n\t\t \n\t\tif (previous->cs_change)\n\t\t\tpl022_cs_control(pl022, SSP_CHIP_SELECT);\n\t} else {\n\t\t \n\t\tmessage->state = STATE_RUNNING;\n\t}\n\n\tif (set_up_next_transfer(pl022, transfer)) {\n\t\tmessage->state = STATE_ERROR;\n\t\tmessage->status = -EIO;\n\t\tgiveback(pl022);\n\t\treturn;\n\t}\n\t \n\tflush(pl022);\n\n\tif (pl022->cur_chip->enable_dma) {\n\t\tif (configure_dma(pl022)) {\n\t\t\tdev_dbg(&pl022->adev->dev,\n\t\t\t\t\"configuration of DMA failed, fall back to interrupt mode\\n\");\n\t\t\tgoto err_config_dma;\n\t\t}\n\t\treturn;\n\t}\n\nerr_config_dma:\n\t \n\twritew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(pl022->virtbase));\n}\n\nstatic void do_interrupt_dma_transfer(struct pl022 *pl022)\n{\n\t \n\tu32 irqflags = (u32)(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM);\n\n\t \n\tif (!pl022->next_msg_cs_active)\n\t\tpl022_cs_control(pl022, SSP_CHIP_SELECT);\n\n\tif (set_up_next_transfer(pl022, pl022->cur_transfer)) {\n\t\t \n\t\tpl022->cur_msg->state = STATE_ERROR;\n\t\tpl022->cur_msg->status = -EIO;\n\t\tgiveback(pl022);\n\t\treturn;\n\t}\n\t \n\tif (pl022->cur_chip->enable_dma) {\n\t\t \n\t\tif (configure_dma(pl022)) {\n\t\t\tdev_dbg(&pl022->adev->dev,\n\t\t\t\t\"configuration of DMA failed, fall back to interrupt mode\\n\");\n\t\t\tgoto err_config_dma;\n\t\t}\n\t\t \n\t\tirqflags = DISABLE_ALL_INTERRUPTS;\n\t}\nerr_config_dma:\n\t \n\twritew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),\n\t       SSP_CR1(pl022->virtbase));\n\twritew(irqflags, SSP_IMSC(pl022->virtbase));\n}\n\nstatic void print_current_status(struct pl022 *pl022)\n{\n\tu32 read_cr0;\n\tu16 read_cr1, read_dmacr, read_sr;\n\n\tif (pl022->vendor->extended_cr)\n\t\tread_cr0 = readl(SSP_CR0(pl022->virtbase));\n\telse\n\t\tread_cr0 = readw(SSP_CR0(pl022->virtbase));\n\tread_cr1 = readw(SSP_CR1(pl022->virtbase));\n\tread_dmacr = readw(SSP_DMACR(pl022->virtbase));\n\tread_sr = readw(SSP_SR(pl022->virtbase));\n\n\tdev_warn(&pl022->adev->dev, \"spi-pl022 CR0: %x\\n\", read_cr0);\n\tdev_warn(&pl022->adev->dev, \"spi-pl022 CR1: %x\\n\", read_cr1);\n\tdev_warn(&pl022->adev->dev, \"spi-pl022 DMACR: %x\\n\", read_dmacr);\n\tdev_warn(&pl022->adev->dev, \"spi-pl022 SR: %x\\n\", read_sr);\n\tdev_warn(&pl022->adev->dev,\n\t\t\t\"spi-pl022 exp_fifo_level/fifodepth: %u/%d\\n\",\n\t\t\tpl022->exp_fifo_level,\n\t\t\tpl022->vendor->fifodepth);\n\n}\n\nstatic void do_polling_transfer(struct pl022 *pl022)\n{\n\tstruct spi_message *message = NULL;\n\tstruct spi_transfer *transfer = NULL;\n\tstruct spi_transfer *previous = NULL;\n\tunsigned long time, timeout;\n\n\tmessage = pl022->cur_msg;\n\n\twhile (message->state != STATE_DONE) {\n\t\t \n\t\tif (message->state == STATE_ERROR)\n\t\t\tbreak;\n\t\ttransfer = pl022->cur_transfer;\n\n\t\t \n\t\tif (message->state == STATE_RUNNING) {\n\t\t\tprevious =\n\t\t\t    list_entry(transfer->transfer_list.prev,\n\t\t\t\t       struct spi_transfer, transfer_list);\n\t\t\tspi_transfer_delay_exec(previous);\n\t\t\tif (previous->cs_change)\n\t\t\t\tpl022_cs_control(pl022, SSP_CHIP_SELECT);\n\t\t} else {\n\t\t\t \n\t\t\tmessage->state = STATE_RUNNING;\n\t\t\tif (!pl022->next_msg_cs_active)\n\t\t\t\tpl022_cs_control(pl022, SSP_CHIP_SELECT);\n\t\t}\n\n\t\t \n\t\tif (set_up_next_transfer(pl022, transfer)) {\n\t\t\t \n\t\t\tmessage->state = STATE_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tflush(pl022);\n\t\twritew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),\n\t\t       SSP_CR1(pl022->virtbase));\n\n\t\tdev_dbg(&pl022->adev->dev, \"polling transfer ongoing ...\\n\");\n\n\t\ttimeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);\n\t\twhile (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {\n\t\t\ttime = jiffies;\n\t\t\treadwriter(pl022);\n\t\t\tif (time_after(time, timeout)) {\n\t\t\t\tdev_warn(&pl022->adev->dev,\n\t\t\t\t\"%s: timeout!\\n\", __func__);\n\t\t\t\tmessage->state = STATE_TIMEOUT;\n\t\t\t\tprint_current_status(pl022);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t \n\t\tmessage->actual_length += pl022->cur_transfer->len;\n\t\t \n\t\tmessage->state = next_transfer(pl022);\n\t\tif (message->state != STATE_DONE\n\t\t    && pl022->cur_transfer->cs_change)\n\t\t\tpl022_cs_control(pl022, SSP_CHIP_DESELECT);\n\t}\nout:\n\t \n\tif (message->state == STATE_DONE)\n\t\tmessage->status = 0;\n\telse if (message->state == STATE_TIMEOUT)\n\t\tmessage->status = -EAGAIN;\n\telse\n\t\tmessage->status = -EIO;\n\n\tgiveback(pl022);\n\treturn;\n}\n\nstatic int pl022_transfer_one_message(struct spi_controller *host,\n\t\t\t\t      struct spi_message *msg)\n{\n\tstruct pl022 *pl022 = spi_controller_get_devdata(host);\n\n\t \n\tpl022->cur_msg = msg;\n\tmsg->state = STATE_START;\n\n\tpl022->cur_transfer = list_entry(msg->transfers.next,\n\t\t\t\t\t struct spi_transfer, transfer_list);\n\n\t \n\tpl022->cur_chip = spi_get_ctldata(msg->spi);\n\tpl022->cur_cs = spi_get_chipselect(msg->spi, 0);\n\t \n\tpl022->cur_gpiod = spi_get_csgpiod(msg->spi, 0);\n\n\trestore_state(pl022);\n\tflush(pl022);\n\n\tif (pl022->cur_chip->xfer_type == POLLING_TRANSFER)\n\t\tdo_polling_transfer(pl022);\n\telse\n\t\tdo_interrupt_dma_transfer(pl022);\n\n\treturn 0;\n}\n\nstatic int pl022_unprepare_transfer_hardware(struct spi_controller *host)\n{\n\tstruct pl022 *pl022 = spi_controller_get_devdata(host);\n\n\t \n\twritew((readw(SSP_CR1(pl022->virtbase)) &\n\t\t(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\n\n\treturn 0;\n}\n\nstatic int verify_controller_parameters(struct pl022 *pl022,\n\t\t\t\tstruct pl022_config_chip const *chip_info)\n{\n\tif ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)\n\t    || (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"interface is configured incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&\n\t    (!pl022->vendor->unidir)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"unidirectional mode not supported in this \"\n\t\t\t\"hardware version\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((chip_info->hierarchy != SSP_MASTER)\n\t    && (chip_info->hierarchy != SSP_SLAVE)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"hierarchy is configured incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((chip_info->com_mode != INTERRUPT_TRANSFER)\n\t    && (chip_info->com_mode != DMA_TRANSFER)\n\t    && (chip_info->com_mode != POLLING_TRANSFER)) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"Communication mode is configured incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (chip_info->rx_lev_trig) {\n\tcase SSP_RX_1_OR_MORE_ELEM:\n\tcase SSP_RX_4_OR_MORE_ELEM:\n\tcase SSP_RX_8_OR_MORE_ELEM:\n\t\t \n\t\tbreak;\n\tcase SSP_RX_16_OR_MORE_ELEM:\n\t\tif (pl022->vendor->fifodepth < 16) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"RX FIFO Trigger Level is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SSP_RX_32_OR_MORE_ELEM:\n\t\tif (pl022->vendor->fifodepth < 32) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"RX FIFO Trigger Level is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"RX FIFO Trigger Level is configured incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (chip_info->tx_lev_trig) {\n\tcase SSP_TX_1_OR_MORE_EMPTY_LOC:\n\tcase SSP_TX_4_OR_MORE_EMPTY_LOC:\n\tcase SSP_TX_8_OR_MORE_EMPTY_LOC:\n\t\t \n\t\tbreak;\n\tcase SSP_TX_16_OR_MORE_EMPTY_LOC:\n\t\tif (pl022->vendor->fifodepth < 16) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"TX FIFO Trigger Level is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SSP_TX_32_OR_MORE_EMPTY_LOC:\n\t\tif (pl022->vendor->fifodepth < 32) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"TX FIFO Trigger Level is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"TX FIFO Trigger Level is configured incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {\n\t\tif ((chip_info->ctrl_len < SSP_BITS_4)\n\t\t    || (chip_info->ctrl_len > SSP_BITS_32)) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\t\"CTRL LEN is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)\n\t\t    && (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {\n\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\t\"Wait State is configured incorrectly\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (pl022->vendor->extended_cr) {\n\t\t\tif ((chip_info->duplex !=\n\t\t\t     SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)\n\t\t\t    && (chip_info->duplex !=\n\t\t\t\tSSP_MICROWIRE_CHANNEL_HALF_DUPLEX)) {\n\t\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\t\t\"Microwire duplex mode is configured incorrectly\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX) {\n\t\t\t\tdev_err(&pl022->adev->dev,\n\t\t\t\t\t\"Microwire half duplex mode requested,\"\n\t\t\t\t\t\" but this is only available in the\"\n\t\t\t\t\t\" ST version of PL022\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline u32 spi_rate(u32 rate, u16 cpsdvsr, u16 scr)\n{\n\treturn rate / (cpsdvsr * (1 + scr));\n}\n\nstatic int calculate_effective_freq(struct pl022 *pl022, int freq, struct\n\t\t\t\t    ssp_clock_params * clk_freq)\n{\n\t \n\tu16 cpsdvsr = CPSDVR_MIN, scr = SCR_MIN;\n\tu32 rate, max_tclk, min_tclk, best_freq = 0, best_cpsdvsr = 0,\n\t\tbest_scr = 0, tmp, found = 0;\n\n\trate = clk_get_rate(pl022->clk);\n\t \n\tmax_tclk = spi_rate(rate, CPSDVR_MIN, SCR_MIN);\n\t \n\tmin_tclk = spi_rate(rate, CPSDVR_MAX, SCR_MAX);\n\n\tif (freq > max_tclk)\n\t\tdev_warn(&pl022->adev->dev,\n\t\t\t\"Max speed that can be programmed is %d Hz, you requested %d\\n\",\n\t\t\tmax_tclk, freq);\n\n\tif (freq < min_tclk) {\n\t\tdev_err(&pl022->adev->dev,\n\t\t\t\"Requested frequency: %d Hz is less than minimum possible %d Hz\\n\",\n\t\t\tfreq, min_tclk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile ((cpsdvsr <= CPSDVR_MAX) && !found) {\n\t\twhile (scr <= SCR_MAX) {\n\t\t\ttmp = spi_rate(rate, cpsdvsr, scr);\n\n\t\t\tif (tmp > freq) {\n\t\t\t\t \n\t\t\t\tscr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tmp > best_freq) {\n\t\t\t\tbest_freq = tmp;\n\t\t\t\tbest_cpsdvsr = cpsdvsr;\n\t\t\t\tbest_scr = scr;\n\n\t\t\t\tif (tmp == freq)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tcpsdvsr += 2;\n\t\tscr = SCR_MIN;\n\t}\n\n\tWARN(!best_freq, \"pl022: Matching cpsdvsr and scr not found for %d Hz rate \\n\",\n\t\t\tfreq);\n\n\tclk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);\n\tclk_freq->scr = (u8) (best_scr & 0xFF);\n\tdev_dbg(&pl022->adev->dev,\n\t\t\"SSP Target Frequency is: %u, Effective Frequency is %u\\n\",\n\t\tfreq, best_freq);\n\tdev_dbg(&pl022->adev->dev, \"SSP cpsdvsr = %d, scr = %d\\n\",\n\t\tclk_freq->cpsdvsr, clk_freq->scr);\n\n\treturn 0;\n}\n\n \nstatic const struct pl022_config_chip pl022_default_chip_info = {\n\t.com_mode = INTERRUPT_TRANSFER,\n\t.iface = SSP_INTERFACE_MOTOROLA_SPI,\n\t.hierarchy = SSP_MASTER,\n\t.slave_tx_disable = DO_NOT_DRIVE_TX,\n\t.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,\n\t.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,\n\t.ctrl_len = SSP_BITS_8,\n\t.wait_state = SSP_MWIRE_WAIT_ZERO,\n\t.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,\n};\n\n \nstatic int pl022_setup(struct spi_device *spi)\n{\n\tstruct pl022_config_chip const *chip_info;\n\tstruct pl022_config_chip chip_info_dt;\n\tstruct chip_data *chip;\n\tstruct ssp_clock_params clk_freq = { .cpsdvsr = 0, .scr = 0};\n\tint status = 0;\n\tstruct pl022 *pl022 = spi_controller_get_devdata(spi->controller);\n\tunsigned int bits = spi->bits_per_word;\n\tu32 tmp;\n\tstruct device_node *np = spi->dev.of_node;\n\n\tif (!spi->max_speed_hz)\n\t\treturn -EINVAL;\n\n\t \n\tchip = spi_get_ctldata(spi);\n\n\tif (chip == NULL) {\n\t\tchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"allocated memory for controller's runtime state\\n\");\n\t}\n\n\t \n\tchip_info = spi->controller_data;\n\n\tif (chip_info == NULL) {\n\t\tif (np) {\n\t\t\tchip_info_dt = pl022_default_chip_info;\n\n\t\t\tchip_info_dt.hierarchy = SSP_MASTER;\n\t\t\tof_property_read_u32(np, \"pl022,interface\",\n\t\t\t\t&chip_info_dt.iface);\n\t\t\tof_property_read_u32(np, \"pl022,com-mode\",\n\t\t\t\t&chip_info_dt.com_mode);\n\t\t\tof_property_read_u32(np, \"pl022,rx-level-trig\",\n\t\t\t\t&chip_info_dt.rx_lev_trig);\n\t\t\tof_property_read_u32(np, \"pl022,tx-level-trig\",\n\t\t\t\t&chip_info_dt.tx_lev_trig);\n\t\t\tof_property_read_u32(np, \"pl022,ctrl-len\",\n\t\t\t\t&chip_info_dt.ctrl_len);\n\t\t\tof_property_read_u32(np, \"pl022,wait-state\",\n\t\t\t\t&chip_info_dt.wait_state);\n\t\t\tof_property_read_u32(np, \"pl022,duplex\",\n\t\t\t\t&chip_info_dt.duplex);\n\n\t\t\tchip_info = &chip_info_dt;\n\t\t} else {\n\t\t\tchip_info = &pl022_default_chip_info;\n\t\t\t \n\t\t\tdev_dbg(&spi->dev,\n\t\t\t\t\"using default controller_data settings\\n\");\n\t\t}\n\t} else\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"using user supplied controller_data settings\\n\");\n\n\t \n\tif ((0 == chip_info->clk_freq.cpsdvsr)\n\t    && (0 == chip_info->clk_freq.scr)) {\n\t\tstatus = calculate_effective_freq(pl022,\n\t\t\t\t\t\t  spi->max_speed_hz,\n\t\t\t\t\t\t  &clk_freq);\n\t\tif (status < 0)\n\t\t\tgoto err_config_params;\n\t} else {\n\t\tmemcpy(&clk_freq, &chip_info->clk_freq, sizeof(clk_freq));\n\t\tif ((clk_freq.cpsdvsr % 2) != 0)\n\t\t\tclk_freq.cpsdvsr =\n\t\t\t\tclk_freq.cpsdvsr - 1;\n\t}\n\tif ((clk_freq.cpsdvsr < CPSDVR_MIN)\n\t    || (clk_freq.cpsdvsr > CPSDVR_MAX)) {\n\t\tstatus = -EINVAL;\n\t\tdev_err(&spi->dev,\n\t\t\t\"cpsdvsr is configured incorrectly\\n\");\n\t\tgoto err_config_params;\n\t}\n\n\tstatus = verify_controller_parameters(pl022, chip_info);\n\tif (status) {\n\t\tdev_err(&spi->dev, \"controller data is incorrect\");\n\t\tgoto err_config_params;\n\t}\n\n\tpl022->rx_lev_trig = chip_info->rx_lev_trig;\n\tpl022->tx_lev_trig = chip_info->tx_lev_trig;\n\n\t \n\tchip->xfer_type = chip_info->com_mode;\n\n\t \n\tif ((bits <= 3) || (bits > pl022->vendor->max_bpw)) {\n\t\tstatus = -ENOTSUPP;\n\t\tdev_err(&spi->dev, \"illegal data size for this controller!\\n\");\n\t\tdev_err(&spi->dev, \"This controller can only handle 4 <= n <= %d bit words\\n\",\n\t\t\t\tpl022->vendor->max_bpw);\n\t\tgoto err_config_params;\n\t} else if (bits <= 8) {\n\t\tdev_dbg(&spi->dev, \"4 <= n <=8 bits per word\\n\");\n\t\tchip->n_bytes = 1;\n\t\tchip->read = READING_U8;\n\t\tchip->write = WRITING_U8;\n\t} else if (bits <= 16) {\n\t\tdev_dbg(&spi->dev, \"9 <= n <= 16 bits per word\\n\");\n\t\tchip->n_bytes = 2;\n\t\tchip->read = READING_U16;\n\t\tchip->write = WRITING_U16;\n\t} else {\n\t\tdev_dbg(&spi->dev, \"17 <= n <= 32 bits per word\\n\");\n\t\tchip->n_bytes = 4;\n\t\tchip->read = READING_U32;\n\t\tchip->write = WRITING_U32;\n\t}\n\n\t \n\tchip->cr0 = 0;\n\tchip->cr1 = 0;\n\tchip->dmacr = 0;\n\tchip->cpsr = 0;\n\tif ((chip_info->com_mode == DMA_TRANSFER)\n\t    && ((pl022->host_info)->enable_dma)) {\n\t\tchip->enable_dma = true;\n\t\tdev_dbg(&spi->dev, \"DMA mode set in controller state\\n\");\n\t\tSSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,\n\t\t\t       SSP_DMACR_MASK_RXDMAE, 0);\n\t\tSSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,\n\t\t\t       SSP_DMACR_MASK_TXDMAE, 1);\n\t} else {\n\t\tchip->enable_dma = false;\n\t\tdev_dbg(&spi->dev, \"DMA mode NOT set in controller state\\n\");\n\t\tSSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,\n\t\t\t       SSP_DMACR_MASK_RXDMAE, 0);\n\t\tSSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,\n\t\t\t       SSP_DMACR_MASK_TXDMAE, 1);\n\t}\n\n\tchip->cpsr = clk_freq.cpsdvsr;\n\n\t \n\tif (pl022->vendor->extended_cr) {\n\t\tu32 etx;\n\n\t\tif (pl022->vendor->pl023) {\n\t\t\t \n\t\t\tSSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,\n\t\t\t\t       SSP_CR1_MASK_FBCLKDEL_ST, 13);\n\t\t} else {\n\t\t\t \n\t\t\tSSP_WRITE_BITS(chip->cr0, chip_info->duplex,\n\t\t\t\t       SSP_CR0_MASK_HALFDUP_ST, 5);\n\t\t\tSSP_WRITE_BITS(chip->cr0, chip_info->ctrl_len,\n\t\t\t\t       SSP_CR0_MASK_CSS_ST, 16);\n\t\t\tSSP_WRITE_BITS(chip->cr0, chip_info->iface,\n\t\t\t\t       SSP_CR0_MASK_FRF_ST, 21);\n\t\t\tSSP_WRITE_BITS(chip->cr1, chip_info->wait_state,\n\t\t\t\t       SSP_CR1_MASK_MWAIT_ST, 6);\n\t\t}\n\t\tSSP_WRITE_BITS(chip->cr0, bits - 1,\n\t\t\t       SSP_CR0_MASK_DSS_ST, 0);\n\n\t\tif (spi->mode & SPI_LSB_FIRST) {\n\t\t\ttmp = SSP_RX_LSB;\n\t\t\tetx = SSP_TX_LSB;\n\t\t} else {\n\t\t\ttmp = SSP_RX_MSB;\n\t\t\tetx = SSP_TX_MSB;\n\t\t}\n\t\tSSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_RENDN_ST, 4);\n\t\tSSP_WRITE_BITS(chip->cr1, etx, SSP_CR1_MASK_TENDN_ST, 5);\n\t\tSSP_WRITE_BITS(chip->cr1, chip_info->rx_lev_trig,\n\t\t\t       SSP_CR1_MASK_RXIFLSEL_ST, 7);\n\t\tSSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,\n\t\t\t       SSP_CR1_MASK_TXIFLSEL_ST, 10);\n\t} else {\n\t\tSSP_WRITE_BITS(chip->cr0, bits - 1,\n\t\t\t       SSP_CR0_MASK_DSS, 0);\n\t\tSSP_WRITE_BITS(chip->cr0, chip_info->iface,\n\t\t\t       SSP_CR0_MASK_FRF, 4);\n\t}\n\n\t \n\tif (spi->mode & SPI_CPOL)\n\t\ttmp = SSP_CLK_POL_IDLE_HIGH;\n\telse\n\t\ttmp = SSP_CLK_POL_IDLE_LOW;\n\tSSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);\n\n\tif (spi->mode & SPI_CPHA)\n\t\ttmp = SSP_CLK_SECOND_EDGE;\n\telse\n\t\ttmp = SSP_CLK_FIRST_EDGE;\n\tSSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);\n\n\tSSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);\n\t \n\tif (pl022->vendor->loopback) {\n\t\tif (spi->mode & SPI_LOOP)\n\t\t\ttmp = LOOPBACK_ENABLED;\n\t\telse\n\t\t\ttmp = LOOPBACK_DISABLED;\n\t\tSSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_LBM, 0);\n\t}\n\tSSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);\n\tSSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);\n\tSSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,\n\t\t3);\n\n\t \n\tspi_set_ctldata(spi, chip);\n\treturn status;\n err_config_params:\n\tspi_set_ctldata(spi, NULL);\n\tkfree(chip);\n\treturn status;\n}\n\n \nstatic void pl022_cleanup(struct spi_device *spi)\n{\n\tstruct chip_data *chip = spi_get_ctldata(spi);\n\n\tspi_set_ctldata(spi, NULL);\n\tkfree(chip);\n}\n\nstatic struct pl022_ssp_controller *\npl022_platform_data_dt_get(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct pl022_ssp_controller *pd;\n\n\tif (!np) {\n\t\tdev_err(dev, \"no dt node defined\\n\");\n\t\treturn NULL;\n\t}\n\n\tpd = devm_kzalloc(dev, sizeof(struct pl022_ssp_controller), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\n\tpd->bus_id = -1;\n\tof_property_read_u32(np, \"pl022,autosuspend-delay\",\n\t\t\t     &pd->autosuspend_delay);\n\tpd->rt = of_property_read_bool(np, \"pl022,rt\");\n\n\treturn pd;\n}\n\nstatic int pl022_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct pl022_ssp_controller *platform_info =\n\t\t\tdev_get_platdata(&adev->dev);\n\tstruct spi_controller *host;\n\tstruct pl022 *pl022 = NULL;\t \n\tint status = 0;\n\n\tdev_info(&adev->dev,\n\t\t \"ARM PL022 driver, device ID: 0x%08x\\n\", adev->periphid);\n\tif (!platform_info && IS_ENABLED(CONFIG_OF))\n\t\tplatform_info = pl022_platform_data_dt_get(dev);\n\n\tif (!platform_info) {\n\t\tdev_err(dev, \"probe: no platform data defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thost = spi_alloc_host(dev, sizeof(struct pl022));\n\tif (host == NULL) {\n\t\tdev_err(&adev->dev, \"probe - cannot alloc SPI host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpl022 = spi_controller_get_devdata(host);\n\tpl022->host = host;\n\tpl022->host_info = platform_info;\n\tpl022->adev = adev;\n\tpl022->vendor = id->data;\n\n\t \n\thost->bus_num = platform_info->bus_id;\n\thost->cleanup = pl022_cleanup;\n\thost->setup = pl022_setup;\n\thost->auto_runtime_pm = true;\n\thost->transfer_one_message = pl022_transfer_one_message;\n\thost->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;\n\thost->rt = platform_info->rt;\n\thost->dev.of_node = dev->of_node;\n\thost->use_gpio_descriptors = true;\n\n\t \n\thost->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\n\tif (pl022->vendor->extended_cr)\n\t\thost->mode_bits |= SPI_LSB_FIRST;\n\n\tdev_dbg(&adev->dev, \"BUSNO: %d\\n\", host->bus_num);\n\n\tstatus = amba_request_regions(adev, NULL);\n\tif (status)\n\t\tgoto err_no_ioregion;\n\n\tpl022->phybase = adev->res.start;\n\tpl022->virtbase = devm_ioremap(dev, adev->res.start,\n\t\t\t\t       resource_size(&adev->res));\n\tif (pl022->virtbase == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_no_ioremap;\n\t}\n\tdev_info(&adev->dev, \"mapped registers from %pa to %p\\n\",\n\t\t&adev->res.start, pl022->virtbase);\n\n\tpl022->clk = devm_clk_get(&adev->dev, NULL);\n\tif (IS_ERR(pl022->clk)) {\n\t\tstatus = PTR_ERR(pl022->clk);\n\t\tdev_err(&adev->dev, \"could not retrieve SSP/SPI bus clock\\n\");\n\t\tgoto err_no_clk;\n\t}\n\n\tstatus = clk_prepare_enable(pl022->clk);\n\tif (status) {\n\t\tdev_err(&adev->dev, \"could not enable SSP/SPI bus clock\\n\");\n\t\tgoto err_no_clk_en;\n\t}\n\n\t \n\ttasklet_init(&pl022->pump_transfers, pump_transfers,\n\t\t     (unsigned long)pl022);\n\n\t \n\twritew((readw(SSP_CR1(pl022->virtbase)) & (~SSP_CR1_MASK_SSE)),\n\t       SSP_CR1(pl022->virtbase));\n\tload_ssp_default_config(pl022);\n\n\tstatus = devm_request_irq(dev, adev->irq[0], pl022_interrupt_handler,\n\t\t\t\t  0, \"pl022\", pl022);\n\tif (status < 0) {\n\t\tdev_err(&adev->dev, \"probe - cannot get IRQ (%d)\\n\", status);\n\t\tgoto err_no_irq;\n\t}\n\n\t \n\tstatus = pl022_dma_autoprobe(pl022);\n\tif (status == -EPROBE_DEFER) {\n\t\tdev_dbg(dev, \"deferring probe to get DMA channel\\n\");\n\t\tgoto err_no_irq;\n\t}\n\n\t \n\tif (status == 0)\n\t\tplatform_info->enable_dma = 1;\n\telse if (platform_info->enable_dma) {\n\t\tstatus = pl022_dma_probe(pl022);\n\t\tif (status != 0)\n\t\t\tplatform_info->enable_dma = 0;\n\t}\n\n\t \n\tamba_set_drvdata(adev, pl022);\n\tstatus = devm_spi_register_controller(&adev->dev, host);\n\tif (status != 0) {\n\t\tdev_err_probe(&adev->dev, status,\n\t\t\t      \"problem registering spi host\\n\");\n\t\tgoto err_spi_register;\n\t}\n\tdev_dbg(dev, \"probe succeeded\\n\");\n\n\t \n\tif (platform_info->autosuspend_delay > 0) {\n\t\tdev_info(&adev->dev,\n\t\t\t\"will use autosuspend for runtime pm, delay %dms\\n\",\n\t\t\tplatform_info->autosuspend_delay);\n\t\tpm_runtime_set_autosuspend_delay(dev,\n\t\t\tplatform_info->autosuspend_delay);\n\t\tpm_runtime_use_autosuspend(dev);\n\t}\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\n err_spi_register:\n\tif (platform_info->enable_dma)\n\t\tpl022_dma_remove(pl022);\n err_no_irq:\n\tclk_disable_unprepare(pl022->clk);\n err_no_clk_en:\n err_no_clk:\n err_no_ioremap:\n\tamba_release_regions(adev);\n err_no_ioregion:\n\tspi_controller_put(host);\n\treturn status;\n}\n\nstatic void\npl022_remove(struct amba_device *adev)\n{\n\tstruct pl022 *pl022 = amba_get_drvdata(adev);\n\n\tif (!pl022)\n\t\treturn;\n\n\t \n\tpm_runtime_get_noresume(&adev->dev);\n\n\tload_ssp_default_config(pl022);\n\tif (pl022->host_info->enable_dma)\n\t\tpl022_dma_remove(pl022);\n\n\tclk_disable_unprepare(pl022->clk);\n\tamba_release_regions(adev);\n\ttasklet_disable(&pl022->pump_transfers);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pl022_suspend(struct device *dev)\n{\n\tstruct pl022 *pl022 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(pl022->host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret) {\n\t\tspi_controller_resume(pl022->host);\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\tdev_dbg(dev, \"suspended\\n\");\n\treturn 0;\n}\n\nstatic int pl022_resume(struct device *dev)\n{\n\tstruct pl022 *pl022 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\tdev_err(dev, \"problem resuming\\n\");\n\n\t \n\tret = spi_controller_resume(pl022->host);\n\tif (!ret)\n\t\tdev_dbg(dev, \"resumed\\n\");\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int pl022_runtime_suspend(struct device *dev)\n{\n\tstruct pl022 *pl022 = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(pl022->clk);\n\tpinctrl_pm_select_idle_state(dev);\n\n\treturn 0;\n}\n\nstatic int pl022_runtime_resume(struct device *dev)\n{\n\tstruct pl022 *pl022 = dev_get_drvdata(dev);\n\n\tpinctrl_pm_select_default_state(dev);\n\tclk_prepare_enable(pl022->clk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops pl022_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pl022_suspend, pl022_resume)\n\tSET_RUNTIME_PM_OPS(pl022_runtime_suspend, pl022_runtime_resume, NULL)\n};\n\nstatic struct vendor_data vendor_arm = {\n\t.fifodepth = 8,\n\t.max_bpw = 16,\n\t.unidir = false,\n\t.extended_cr = false,\n\t.pl023 = false,\n\t.loopback = true,\n\t.internal_cs_ctrl = false,\n};\n\nstatic struct vendor_data vendor_st = {\n\t.fifodepth = 32,\n\t.max_bpw = 32,\n\t.unidir = false,\n\t.extended_cr = true,\n\t.pl023 = false,\n\t.loopback = true,\n\t.internal_cs_ctrl = false,\n};\n\nstatic struct vendor_data vendor_st_pl023 = {\n\t.fifodepth = 32,\n\t.max_bpw = 32,\n\t.unidir = false,\n\t.extended_cr = true,\n\t.pl023 = true,\n\t.loopback = false,\n\t.internal_cs_ctrl = false,\n};\n\nstatic struct vendor_data vendor_lsi = {\n\t.fifodepth = 8,\n\t.max_bpw = 16,\n\t.unidir = false,\n\t.extended_cr = false,\n\t.pl023 = false,\n\t.loopback = true,\n\t.internal_cs_ctrl = true,\n};\n\nstatic const struct amba_id pl022_ids[] = {\n\t{\n\t\t \n\t\t.id\t= 0x00041022,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_arm,\n\t},\n\t{\n\t\t \n\t\t.id\t= 0x01080022,\n\t\t.mask\t= 0xffffffff,\n\t\t.data\t= &vendor_st,\n\t},\n\t{\n\t\t \n\t\t.id\t= 0x00080023,\n\t\t.mask\t= 0xffffffff,\n\t\t.data\t= &vendor_st_pl023,\n\t},\n\t{\n\t\t \n\t\t.id\t= 0x000b6022,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_lsi,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl022_ids);\n\nstatic struct amba_driver pl022_driver = {\n\t.drv = {\n\t\t.name\t= \"ssp-pl022\",\n\t\t.pm\t= &pl022_dev_pm_ops,\n\t},\n\t.id_table\t= pl022_ids,\n\t.probe\t\t= pl022_probe,\n\t.remove\t\t= pl022_remove,\n};\n\nstatic int __init pl022_init(void)\n{\n\treturn amba_driver_register(&pl022_driver);\n}\nsubsys_initcall(pl022_init);\n\nstatic void __exit pl022_exit(void)\n{\n\tamba_driver_unregister(&pl022_driver);\n}\nmodule_exit(pl022_exit);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@stericsson.com>\");\nMODULE_DESCRIPTION(\"PL022 SSP Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}