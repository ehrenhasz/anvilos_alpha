{
  "module_name": "spi-tegra114.c",
  "hash_id": "68a6762f5a79fa8b11e9a9b601168603891dee52cecab6075e920d7e16a7b142",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-tegra114.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/spi/spi.h>\n\n#define SPI_COMMAND1\t\t\t\t0x000\n#define SPI_BIT_LENGTH(x)\t\t\t(((x) & 0x1f) << 0)\n#define SPI_PACKED\t\t\t\t(1 << 5)\n#define SPI_TX_EN\t\t\t\t(1 << 11)\n#define SPI_RX_EN\t\t\t\t(1 << 12)\n#define SPI_BOTH_EN_BYTE\t\t\t(1 << 13)\n#define SPI_BOTH_EN_BIT\t\t\t\t(1 << 14)\n#define SPI_LSBYTE_FE\t\t\t\t(1 << 15)\n#define SPI_LSBIT_FE\t\t\t\t(1 << 16)\n#define SPI_BIDIROE\t\t\t\t(1 << 17)\n#define SPI_IDLE_SDA_DRIVE_LOW\t\t\t(0 << 18)\n#define SPI_IDLE_SDA_DRIVE_HIGH\t\t\t(1 << 18)\n#define SPI_IDLE_SDA_PULL_LOW\t\t\t(2 << 18)\n#define SPI_IDLE_SDA_PULL_HIGH\t\t\t(3 << 18)\n#define SPI_IDLE_SDA_MASK\t\t\t(3 << 18)\n#define SPI_CS_SW_VAL\t\t\t\t(1 << 20)\n#define SPI_CS_SW_HW\t\t\t\t(1 << 21)\n \n\t\t\t\t\t\t \n#define SPI_CS_POL_INACTIVE(n)\t\t\t(1 << (22 + (n)))\n#define SPI_CS_POL_INACTIVE_MASK\t\t(0xF << 22)\n\n#define SPI_CS_SEL_0\t\t\t\t(0 << 26)\n#define SPI_CS_SEL_1\t\t\t\t(1 << 26)\n#define SPI_CS_SEL_2\t\t\t\t(2 << 26)\n#define SPI_CS_SEL_3\t\t\t\t(3 << 26)\n#define SPI_CS_SEL_MASK\t\t\t\t(3 << 26)\n#define SPI_CS_SEL(x)\t\t\t\t(((x) & 0x3) << 26)\n#define SPI_CONTROL_MODE_0\t\t\t(0 << 28)\n#define SPI_CONTROL_MODE_1\t\t\t(1 << 28)\n#define SPI_CONTROL_MODE_2\t\t\t(2 << 28)\n#define SPI_CONTROL_MODE_3\t\t\t(3 << 28)\n#define SPI_CONTROL_MODE_MASK\t\t\t(3 << 28)\n#define SPI_MODE_SEL(x)\t\t\t\t(((x) & 0x3) << 28)\n#define SPI_M_S\t\t\t\t\t(1 << 30)\n#define SPI_PIO\t\t\t\t\t(1 << 31)\n\n#define SPI_COMMAND2\t\t\t\t0x004\n#define SPI_TX_TAP_DELAY(x)\t\t\t(((x) & 0x3F) << 6)\n#define SPI_RX_TAP_DELAY(x)\t\t\t(((x) & 0x3F) << 0)\n\n#define SPI_CS_TIMING1\t\t\t\t0x008\n#define SPI_SETUP_HOLD(setup, hold)\t\t(((setup) << 4) | (hold))\n#define SPI_CS_SETUP_HOLD(reg, cs, val)\t\t\t\\\n\t\t((((val) & 0xFFu) << ((cs) * 8)) |\t\\\n\t\t((reg) & ~(0xFFu << ((cs) * 8))))\n\n#define SPI_CS_TIMING2\t\t\t\t0x00C\n#define CYCLES_BETWEEN_PACKETS_0(x)\t\t(((x) & 0x1F) << 0)\n#define CS_ACTIVE_BETWEEN_PACKETS_0\t\t(1 << 5)\n#define CYCLES_BETWEEN_PACKETS_1(x)\t\t(((x) & 0x1F) << 8)\n#define CS_ACTIVE_BETWEEN_PACKETS_1\t\t(1 << 13)\n#define CYCLES_BETWEEN_PACKETS_2(x)\t\t(((x) & 0x1F) << 16)\n#define CS_ACTIVE_BETWEEN_PACKETS_2\t\t(1 << 21)\n#define CYCLES_BETWEEN_PACKETS_3(x)\t\t(((x) & 0x1F) << 24)\n#define CS_ACTIVE_BETWEEN_PACKETS_3\t\t(1 << 29)\n#define SPI_SET_CS_ACTIVE_BETWEEN_PACKETS(reg, cs, val)\t\t\\\n\t\t(reg = (((val) & 0x1) << ((cs) * 8 + 5)) |\t\\\n\t\t\t((reg) & ~(1 << ((cs) * 8 + 5))))\n#define SPI_SET_CYCLES_BETWEEN_PACKETS(reg, cs, val)\t\t\\\n\t\t(reg = (((val) & 0x1F) << ((cs) * 8)) |\t\t\\\n\t\t\t((reg) & ~(0x1F << ((cs) * 8))))\n#define MAX_SETUP_HOLD_CYCLES\t\t\t16\n#define MAX_INACTIVE_CYCLES\t\t\t32\n\n#define SPI_TRANS_STATUS\t\t\t0x010\n#define SPI_BLK_CNT(val)\t\t\t(((val) >> 0) & 0xFFFF)\n#define SPI_SLV_IDLE_COUNT(val)\t\t\t(((val) >> 16) & 0xFF)\n#define SPI_RDY\t\t\t\t\t(1 << 30)\n\n#define SPI_FIFO_STATUS\t\t\t\t0x014\n#define SPI_RX_FIFO_EMPTY\t\t\t(1 << 0)\n#define SPI_RX_FIFO_FULL\t\t\t(1 << 1)\n#define SPI_TX_FIFO_EMPTY\t\t\t(1 << 2)\n#define SPI_TX_FIFO_FULL\t\t\t(1 << 3)\n#define SPI_RX_FIFO_UNF\t\t\t\t(1 << 4)\n#define SPI_RX_FIFO_OVF\t\t\t\t(1 << 5)\n#define SPI_TX_FIFO_UNF\t\t\t\t(1 << 6)\n#define SPI_TX_FIFO_OVF\t\t\t\t(1 << 7)\n#define SPI_ERR\t\t\t\t\t(1 << 8)\n#define SPI_TX_FIFO_FLUSH\t\t\t(1 << 14)\n#define SPI_RX_FIFO_FLUSH\t\t\t(1 << 15)\n#define SPI_TX_FIFO_EMPTY_COUNT(val)\t\t(((val) >> 16) & 0x7F)\n#define SPI_RX_FIFO_FULL_COUNT(val)\t\t(((val) >> 23) & 0x7F)\n#define SPI_FRAME_END\t\t\t\t(1 << 30)\n#define SPI_CS_INACTIVE\t\t\t\t(1 << 31)\n\n#define SPI_FIFO_ERROR\t\t\t\t(SPI_RX_FIFO_UNF | \\\n\t\t\tSPI_RX_FIFO_OVF | SPI_TX_FIFO_UNF | SPI_TX_FIFO_OVF)\n#define SPI_FIFO_EMPTY\t\t\t(SPI_RX_FIFO_EMPTY | SPI_TX_FIFO_EMPTY)\n\n#define SPI_TX_DATA\t\t\t\t0x018\n#define SPI_RX_DATA\t\t\t\t0x01C\n\n#define SPI_DMA_CTL\t\t\t\t0x020\n#define SPI_TX_TRIG_1\t\t\t\t(0 << 15)\n#define SPI_TX_TRIG_4\t\t\t\t(1 << 15)\n#define SPI_TX_TRIG_8\t\t\t\t(2 << 15)\n#define SPI_TX_TRIG_16\t\t\t\t(3 << 15)\n#define SPI_TX_TRIG_MASK\t\t\t(3 << 15)\n#define SPI_RX_TRIG_1\t\t\t\t(0 << 19)\n#define SPI_RX_TRIG_4\t\t\t\t(1 << 19)\n#define SPI_RX_TRIG_8\t\t\t\t(2 << 19)\n#define SPI_RX_TRIG_16\t\t\t\t(3 << 19)\n#define SPI_RX_TRIG_MASK\t\t\t(3 << 19)\n#define SPI_IE_TX\t\t\t\t(1 << 28)\n#define SPI_IE_RX\t\t\t\t(1 << 29)\n#define SPI_CONT\t\t\t\t(1 << 30)\n#define SPI_DMA\t\t\t\t\t(1 << 31)\n#define SPI_DMA_EN\t\t\t\tSPI_DMA\n\n#define SPI_DMA_BLK\t\t\t\t0x024\n#define SPI_DMA_BLK_SET(x)\t\t\t(((x) & 0xFFFF) << 0)\n\n#define SPI_TX_FIFO\t\t\t\t0x108\n#define SPI_RX_FIFO\t\t\t\t0x188\n#define SPI_INTR_MASK\t\t\t\t0x18c\n#define SPI_INTR_ALL_MASK\t\t\t(0x1fUL << 25)\n#define MAX_CHIP_SELECT\t\t\t\t4\n#define SPI_FIFO_DEPTH\t\t\t\t64\n#define DATA_DIR_TX\t\t\t\t(1 << 0)\n#define DATA_DIR_RX\t\t\t\t(1 << 1)\n\n#define SPI_DMA_TIMEOUT\t\t\t\t(msecs_to_jiffies(1000))\n#define DEFAULT_SPI_DMA_BUF_LEN\t\t\t(16*1024)\n#define TX_FIFO_EMPTY_COUNT_MAX\t\t\tSPI_TX_FIFO_EMPTY_COUNT(0x40)\n#define RX_FIFO_FULL_COUNT_ZERO\t\t\tSPI_RX_FIFO_FULL_COUNT(0)\n#define MAX_HOLD_CYCLES\t\t\t\t16\n#define SPI_DEFAULT_SPEED\t\t\t25000000\n\nstruct tegra_spi_soc_data {\n\tbool has_intr_mask_reg;\n};\n\nstruct tegra_spi_client_data {\n\tint tx_clk_tap_delay;\n\tint rx_clk_tap_delay;\n};\n\nstruct tegra_spi_data {\n\tstruct device\t\t\t\t*dev;\n\tstruct spi_master\t\t\t*master;\n\tspinlock_t\t\t\t\tlock;\n\n\tstruct clk\t\t\t\t*clk;\n\tstruct reset_control\t\t\t*rst;\n\tvoid __iomem\t\t\t\t*base;\n\tphys_addr_t\t\t\t\tphys;\n\tunsigned\t\t\t\tirq;\n\tu32\t\t\t\t\tcur_speed;\n\n\tstruct spi_device\t\t\t*cur_spi;\n\tstruct spi_device\t\t\t*cs_control;\n\tunsigned\t\t\t\tcur_pos;\n\tunsigned\t\t\t\twords_per_32bit;\n\tunsigned\t\t\t\tbytes_per_word;\n\tunsigned\t\t\t\tcurr_dma_words;\n\tunsigned\t\t\t\tcur_direction;\n\n\tunsigned\t\t\t\tcur_rx_pos;\n\tunsigned\t\t\t\tcur_tx_pos;\n\n\tunsigned\t\t\t\tdma_buf_size;\n\tunsigned\t\t\t\tmax_buf_size;\n\tbool\t\t\t\t\tis_curr_dma_xfer;\n\tbool\t\t\t\t\tuse_hw_based_cs;\n\n\tstruct completion\t\t\trx_dma_complete;\n\tstruct completion\t\t\ttx_dma_complete;\n\n\tu32\t\t\t\t\ttx_status;\n\tu32\t\t\t\t\trx_status;\n\tu32\t\t\t\t\tstatus_reg;\n\tbool\t\t\t\t\tis_packed;\n\n\tu32\t\t\t\t\tcommand1_reg;\n\tu32\t\t\t\t\tdma_control_reg;\n\tu32\t\t\t\t\tdef_command1_reg;\n\tu32\t\t\t\t\tdef_command2_reg;\n\tu32\t\t\t\t\tspi_cs_timing1;\n\tu32\t\t\t\t\tspi_cs_timing2;\n\tu8\t\t\t\t\tlast_used_cs;\n\n\tstruct completion\t\t\txfer_completion;\n\tstruct spi_transfer\t\t\t*curr_xfer;\n\tstruct dma_chan\t\t\t\t*rx_dma_chan;\n\tu32\t\t\t\t\t*rx_dma_buf;\n\tdma_addr_t\t\t\t\trx_dma_phys;\n\tstruct dma_async_tx_descriptor\t\t*rx_dma_desc;\n\n\tstruct dma_chan\t\t\t\t*tx_dma_chan;\n\tu32\t\t\t\t\t*tx_dma_buf;\n\tdma_addr_t\t\t\t\ttx_dma_phys;\n\tstruct dma_async_tx_descriptor\t\t*tx_dma_desc;\n\tconst struct tegra_spi_soc_data\t\t*soc_data;\n};\n\nstatic int tegra_spi_runtime_suspend(struct device *dev);\nstatic int tegra_spi_runtime_resume(struct device *dev);\n\nstatic inline u32 tegra_spi_readl(struct tegra_spi_data *tspi,\n\t\tunsigned long reg)\n{\n\treturn readl(tspi->base + reg);\n}\n\nstatic inline void tegra_spi_writel(struct tegra_spi_data *tspi,\n\t\tu32 val, unsigned long reg)\n{\n\twritel(val, tspi->base + reg);\n\n\t \n\tif (reg != SPI_TX_FIFO)\n\t\treadl(tspi->base + SPI_COMMAND1);\n}\n\nstatic void tegra_spi_clear_status(struct tegra_spi_data *tspi)\n{\n\tu32 val;\n\n\t \n\tval = tegra_spi_readl(tspi, SPI_TRANS_STATUS);\n\ttegra_spi_writel(tspi, val, SPI_TRANS_STATUS);\n\n\t \n\tval = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\tif (val & SPI_ERR)\n\t\ttegra_spi_writel(tspi, SPI_ERR | SPI_FIFO_ERROR,\n\t\t\t\tSPI_FIFO_STATUS);\n}\n\nstatic unsigned tegra_spi_calculate_curr_xfer_param(\n\tstruct spi_device *spi, struct tegra_spi_data *tspi,\n\tstruct spi_transfer *t)\n{\n\tunsigned remain_len = t->len - tspi->cur_pos;\n\tunsigned max_word;\n\tunsigned bits_per_word = t->bits_per_word;\n\tunsigned max_len;\n\tunsigned total_fifo_words;\n\n\ttspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);\n\n\tif ((bits_per_word == 8 || bits_per_word == 16 ||\n\t     bits_per_word == 32) && t->len > 3) {\n\t\ttspi->is_packed = true;\n\t\ttspi->words_per_32bit = 32/bits_per_word;\n\t} else {\n\t\ttspi->is_packed = false;\n\t\ttspi->words_per_32bit = 1;\n\t}\n\n\tif (tspi->is_packed) {\n\t\tmax_len = min(remain_len, tspi->max_buf_size);\n\t\ttspi->curr_dma_words = max_len/tspi->bytes_per_word;\n\t\ttotal_fifo_words = (max_len + 3) / 4;\n\t} else {\n\t\tmax_word = (remain_len - 1) / tspi->bytes_per_word + 1;\n\t\tmax_word = min(max_word, tspi->max_buf_size/4);\n\t\ttspi->curr_dma_words = max_word;\n\t\ttotal_fifo_words = max_word;\n\t}\n\treturn total_fifo_words;\n}\n\nstatic unsigned tegra_spi_fill_tx_fifo_from_client_txbuf(\n\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tunsigned nbytes;\n\tunsigned tx_empty_count;\n\tu32 fifo_status;\n\tunsigned max_n_32bit;\n\tunsigned i, count;\n\tunsigned int written_words;\n\tunsigned fifo_words_left;\n\tu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\n\n\tfifo_status = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\ttx_empty_count = SPI_TX_FIFO_EMPTY_COUNT(fifo_status);\n\n\tif (tspi->is_packed) {\n\t\tfifo_words_left = tx_empty_count * tspi->words_per_32bit;\n\t\twritten_words = min(fifo_words_left, tspi->curr_dma_words);\n\t\tnbytes = written_words * tspi->bytes_per_word;\n\t\tmax_n_32bit = DIV_ROUND_UP(nbytes, 4);\n\t\tfor (count = 0; count < max_n_32bit; count++) {\n\t\t\tu32 x = 0;\n\n\t\t\tfor (i = 0; (i < 4) && nbytes; i++, nbytes--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttegra_spi_writel(tspi, x, SPI_TX_FIFO);\n\t\t}\n\n\t\ttspi->cur_tx_pos += written_words * tspi->bytes_per_word;\n\t} else {\n\t\tunsigned int write_bytes;\n\t\tmax_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);\n\t\twritten_words = max_n_32bit;\n\t\tnbytes = written_words * tspi->bytes_per_word;\n\t\tif (nbytes > t->len - tspi->cur_pos)\n\t\t\tnbytes = t->len - tspi->cur_pos;\n\t\twrite_bytes = nbytes;\n\t\tfor (count = 0; count < max_n_32bit; count++) {\n\t\t\tu32 x = 0;\n\n\t\t\tfor (i = 0; nbytes && (i < tspi->bytes_per_word);\n\t\t\t\t\t\t\ti++, nbytes--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttegra_spi_writel(tspi, x, SPI_TX_FIFO);\n\t\t}\n\n\t\ttspi->cur_tx_pos += write_bytes;\n\t}\n\n\treturn written_words;\n}\n\nstatic unsigned int tegra_spi_read_rx_fifo_to_client_rxbuf(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tunsigned rx_full_count;\n\tu32 fifo_status;\n\tunsigned i, count;\n\tunsigned int read_words = 0;\n\tunsigned len;\n\tu8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;\n\n\tfifo_status = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\trx_full_count = SPI_RX_FIFO_FULL_COUNT(fifo_status);\n\tif (tspi->is_packed) {\n\t\tlen = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tfor (count = 0; count < rx_full_count; count++) {\n\t\t\tu32 x = tegra_spi_readl(tspi, SPI_RX_FIFO);\n\n\t\t\tfor (i = 0; len && (i < 4); i++, len--)\n\t\t\t\t*rx_buf++ = (x >> i*8) & 0xFF;\n\t\t}\n\t\tread_words += tspi->curr_dma_words;\n\t\ttspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\t} else {\n\t\tu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\n\t\tu8 bytes_per_word = tspi->bytes_per_word;\n\t\tunsigned int read_bytes;\n\n\t\tlen = rx_full_count * bytes_per_word;\n\t\tif (len > t->len - tspi->cur_pos)\n\t\t\tlen = t->len - tspi->cur_pos;\n\t\tread_bytes = len;\n\t\tfor (count = 0; count < rx_full_count; count++) {\n\t\t\tu32 x = tegra_spi_readl(tspi, SPI_RX_FIFO) & rx_mask;\n\n\t\t\tfor (i = 0; len && (i < bytes_per_word); i++, len--)\n\t\t\t\t*rx_buf++ = (x >> (i*8)) & 0xFF;\n\t\t}\n\t\tread_words += rx_full_count;\n\t\ttspi->cur_rx_pos += read_bytes;\n\t}\n\n\treturn read_words;\n}\n\nstatic void tegra_spi_copy_client_txbuf_to_spi_txbuf(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\t \n\tdma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_TO_DEVICE);\n\n\tif (tspi->is_packed) {\n\t\tunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\n\n\t\tmemcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);\n\t\ttspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\t} else {\n\t\tunsigned int i;\n\t\tunsigned int count;\n\t\tu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\n\t\tunsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tunsigned int write_bytes;\n\n\t\tif (consume > t->len - tspi->cur_pos)\n\t\t\tconsume = t->len - tspi->cur_pos;\n\t\twrite_bytes = consume;\n\t\tfor (count = 0; count < tspi->curr_dma_words; count++) {\n\t\t\tu32 x = 0;\n\n\t\t\tfor (i = 0; consume && (i < tspi->bytes_per_word);\n\t\t\t\t\t\t\ti++, consume--)\n\t\t\t\tx |= (u32)(*tx_buf++) << (i * 8);\n\t\t\ttspi->tx_dma_buf[count] = x;\n\t\t}\n\n\t\ttspi->cur_tx_pos += write_bytes;\n\t}\n\n\t \n\tdma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_TO_DEVICE);\n}\n\nstatic void tegra_spi_copy_spi_rxbuf_to_client_rxbuf(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\t \n\tdma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,\n\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\n\tif (tspi->is_packed) {\n\t\tunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\n\n\t\tmemcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);\n\t\ttspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\n\t} else {\n\t\tunsigned int i;\n\t\tunsigned int count;\n\t\tunsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;\n\t\tu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\n\t\tunsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;\n\t\tunsigned int read_bytes;\n\n\t\tif (consume > t->len - tspi->cur_pos)\n\t\t\tconsume = t->len - tspi->cur_pos;\n\t\tread_bytes = consume;\n\t\tfor (count = 0; count < tspi->curr_dma_words; count++) {\n\t\t\tu32 x = tspi->rx_dma_buf[count] & rx_mask;\n\n\t\t\tfor (i = 0; consume && (i < tspi->bytes_per_word);\n\t\t\t\t\t\t\ti++, consume--)\n\t\t\t\t*rx_buf++ = (x >> (i*8)) & 0xFF;\n\t\t}\n\n\t\ttspi->cur_rx_pos += read_bytes;\n\t}\n\n\t \n\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n}\n\nstatic void tegra_spi_dma_complete(void *args)\n{\n\tstruct completion *dma_complete = args;\n\n\tcomplete(dma_complete);\n}\n\nstatic int tegra_spi_start_tx_dma(struct tegra_spi_data *tspi, int len)\n{\n\treinit_completion(&tspi->tx_dma_complete);\n\ttspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,\n\t\t\t\ttspi->tx_dma_phys, len, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT |  DMA_CTRL_ACK);\n\tif (!tspi->tx_dma_desc) {\n\t\tdev_err(tspi->dev, \"Not able to get desc for Tx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttspi->tx_dma_desc->callback = tegra_spi_dma_complete;\n\ttspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;\n\n\tdmaengine_submit(tspi->tx_dma_desc);\n\tdma_async_issue_pending(tspi->tx_dma_chan);\n\treturn 0;\n}\n\nstatic int tegra_spi_start_rx_dma(struct tegra_spi_data *tspi, int len)\n{\n\treinit_completion(&tspi->rx_dma_complete);\n\ttspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,\n\t\t\t\ttspi->rx_dma_phys, len, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT |  DMA_CTRL_ACK);\n\tif (!tspi->rx_dma_desc) {\n\t\tdev_err(tspi->dev, \"Not able to get desc for Rx\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttspi->rx_dma_desc->callback = tegra_spi_dma_complete;\n\ttspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;\n\n\tdmaengine_submit(tspi->rx_dma_desc);\n\tdma_async_issue_pending(tspi->rx_dma_chan);\n\treturn 0;\n}\n\nstatic int tegra_spi_flush_fifos(struct tegra_spi_data *tspi)\n{\n\tunsigned long timeout = jiffies + HZ;\n\tu32 status;\n\n\tstatus = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\tif ((status & SPI_FIFO_EMPTY) != SPI_FIFO_EMPTY) {\n\t\tstatus |= SPI_RX_FIFO_FLUSH | SPI_TX_FIFO_FLUSH;\n\t\ttegra_spi_writel(tspi, status, SPI_FIFO_STATUS);\n\t\twhile ((status & SPI_FIFO_EMPTY) != SPI_FIFO_EMPTY) {\n\t\t\tstatus = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(tspi->dev,\n\t\t\t\t\t\"timeout waiting for fifo flush\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_spi_start_dma_based_transfer(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned int len;\n\tint ret = 0;\n\tu8 dma_burst;\n\tstruct dma_slave_config dma_sconfig = {0};\n\n\tval = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);\n\ttegra_spi_writel(tspi, val, SPI_DMA_BLK);\n\n\tif (tspi->is_packed)\n\t\tlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\n\t\t\t\t\t4) * 4;\n\telse\n\t\tlen = tspi->curr_dma_words * 4;\n\n\t \n\tif (len & 0xF) {\n\t\tval |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;\n\t\tdma_burst = 1;\n\t} else if (((len) >> 4) & 0x1) {\n\t\tval |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;\n\t\tdma_burst = 4;\n\t} else {\n\t\tval |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;\n\t\tdma_burst = 8;\n\t}\n\n\tif (!tspi->soc_data->has_intr_mask_reg) {\n\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\tval |= SPI_IE_TX;\n\n\t\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\t\tval |= SPI_IE_RX;\n\t}\n\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\tdma_sconfig.device_fc = true;\n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\tdma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;\n\t\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.dst_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->tx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);\n\t\tret = tegra_spi_start_tx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting tx dma failed, err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\tdma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;\n\t\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.src_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->rx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\n\t\tret = tegra_spi_start_rx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting rx dma failed, err %d\\n\", ret);\n\t\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ttspi->is_curr_dma_xfer = true;\n\ttspi->dma_control_reg = val;\n\n\tval |= SPI_DMA_EN;\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\treturn ret;\n}\n\nstatic int tegra_spi_start_cpu_based_transfer(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned cur_words;\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\tcur_words = tegra_spi_fill_tx_fifo_from_client_txbuf(tspi, t);\n\telse\n\t\tcur_words = tspi->curr_dma_words;\n\n\tval = SPI_DMA_BLK_SET(cur_words - 1);\n\ttegra_spi_writel(tspi, val, SPI_DMA_BLK);\n\n\tval = 0;\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\tval |= SPI_IE_TX;\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\tval |= SPI_IE_RX;\n\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\ttspi->is_curr_dma_xfer = false;\n\n\tval = tspi->command1_reg;\n\tval |= SPI_PIO;\n\ttegra_spi_writel(tspi, val, SPI_COMMAND1);\n\treturn 0;\n}\n\nstatic int tegra_spi_init_dma_param(struct tegra_spi_data *tspi,\n\t\t\tbool dma_to_memory)\n{\n\tstruct dma_chan *dma_chan;\n\tu32 *dma_buf;\n\tdma_addr_t dma_phys;\n\n\tdma_chan = dma_request_chan(tspi->dev, dma_to_memory ? \"rx\" : \"tx\");\n\tif (IS_ERR(dma_chan))\n\t\treturn dev_err_probe(tspi->dev, PTR_ERR(dma_chan),\n\t\t\t\t     \"Dma channel is not available\\n\");\n\n\tdma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,\n\t\t\t\t&dma_phys, GFP_KERNEL);\n\tif (!dma_buf) {\n\t\tdev_err(tspi->dev, \" Not able to allocate the dma buffer\\n\");\n\t\tdma_release_channel(dma_chan);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (dma_to_memory) {\n\t\ttspi->rx_dma_chan = dma_chan;\n\t\ttspi->rx_dma_buf = dma_buf;\n\t\ttspi->rx_dma_phys = dma_phys;\n\t} else {\n\t\ttspi->tx_dma_chan = dma_chan;\n\t\ttspi->tx_dma_buf = dma_buf;\n\t\ttspi->tx_dma_phys = dma_phys;\n\t}\n\treturn 0;\n}\n\nstatic void tegra_spi_deinit_dma_param(struct tegra_spi_data *tspi,\n\tbool dma_to_memory)\n{\n\tu32 *dma_buf;\n\tdma_addr_t dma_phys;\n\tstruct dma_chan *dma_chan;\n\n\tif (dma_to_memory) {\n\t\tdma_buf = tspi->rx_dma_buf;\n\t\tdma_chan = tspi->rx_dma_chan;\n\t\tdma_phys = tspi->rx_dma_phys;\n\t\ttspi->rx_dma_chan = NULL;\n\t\ttspi->rx_dma_buf = NULL;\n\t} else {\n\t\tdma_buf = tspi->tx_dma_buf;\n\t\tdma_chan = tspi->tx_dma_chan;\n\t\tdma_phys = tspi->tx_dma_phys;\n\t\ttspi->tx_dma_buf = NULL;\n\t\ttspi->tx_dma_chan = NULL;\n\t}\n\tif (!dma_chan)\n\t\treturn;\n\n\tdma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\n\tdma_release_channel(dma_chan);\n}\n\nstatic int tegra_spi_set_hw_cs_timing(struct spi_device *spi)\n{\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\n\tstruct spi_delay *setup = &spi->cs_setup;\n\tstruct spi_delay *hold = &spi->cs_hold;\n\tstruct spi_delay *inactive = &spi->cs_inactive;\n\tu8 setup_dly, hold_dly;\n\tu32 setup_hold;\n\tu32 spi_cs_timing;\n\tu32 inactive_cycles;\n\tu8 cs_state;\n\n\tif (setup->unit != SPI_DELAY_UNIT_SCK ||\n\t    hold->unit != SPI_DELAY_UNIT_SCK ||\n\t    inactive->unit != SPI_DELAY_UNIT_SCK) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Invalid delay unit %d, should be SPI_DELAY_UNIT_SCK\\n\",\n\t\t\tSPI_DELAY_UNIT_SCK);\n\t\treturn -EINVAL;\n\t}\n\n\tsetup_dly = min_t(u8, setup->value, MAX_SETUP_HOLD_CYCLES);\n\thold_dly = min_t(u8, hold->value, MAX_SETUP_HOLD_CYCLES);\n\tif (setup_dly && hold_dly) {\n\t\tsetup_hold = SPI_SETUP_HOLD(setup_dly - 1, hold_dly - 1);\n\t\tspi_cs_timing = SPI_CS_SETUP_HOLD(tspi->spi_cs_timing1,\n\t\t\t\t\t\t  spi_get_chipselect(spi, 0),\n\t\t\t\t\t\t  setup_hold);\n\t\tif (tspi->spi_cs_timing1 != spi_cs_timing) {\n\t\t\ttspi->spi_cs_timing1 = spi_cs_timing;\n\t\t\ttegra_spi_writel(tspi, spi_cs_timing, SPI_CS_TIMING1);\n\t\t}\n\t}\n\n\tinactive_cycles = min_t(u8, inactive->value, MAX_INACTIVE_CYCLES);\n\tif (inactive_cycles)\n\t\tinactive_cycles--;\n\tcs_state = inactive_cycles ? 0 : 1;\n\tspi_cs_timing = tspi->spi_cs_timing2;\n\tSPI_SET_CS_ACTIVE_BETWEEN_PACKETS(spi_cs_timing, spi_get_chipselect(spi, 0),\n\t\t\t\t\t  cs_state);\n\tSPI_SET_CYCLES_BETWEEN_PACKETS(spi_cs_timing, spi_get_chipselect(spi, 0),\n\t\t\t\t       inactive_cycles);\n\tif (tspi->spi_cs_timing2 != spi_cs_timing) {\n\t\ttspi->spi_cs_timing2 = spi_cs_timing;\n\t\ttegra_spi_writel(tspi, spi_cs_timing, SPI_CS_TIMING2);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 tegra_spi_setup_transfer_one(struct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *t,\n\t\t\t\t\tbool is_first_of_msg,\n\t\t\t\t\tbool is_single_xfer)\n{\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\n\tstruct tegra_spi_client_data *cdata = spi->controller_data;\n\tu32 speed = t->speed_hz;\n\tu8 bits_per_word = t->bits_per_word;\n\tu32 command1, command2;\n\tint req_mode;\n\tu32 tx_tap = 0, rx_tap = 0;\n\n\tif (speed != tspi->cur_speed) {\n\t\tclk_set_rate(tspi->clk, speed);\n\t\ttspi->cur_speed = speed;\n\t}\n\n\ttspi->cur_spi = spi;\n\ttspi->cur_pos = 0;\n\ttspi->cur_rx_pos = 0;\n\ttspi->cur_tx_pos = 0;\n\ttspi->curr_xfer = t;\n\n\tif (is_first_of_msg) {\n\t\ttegra_spi_clear_status(tspi);\n\n\t\tcommand1 = tspi->def_command1_reg;\n\t\tcommand1 |= SPI_BIT_LENGTH(bits_per_word - 1);\n\n\t\tcommand1 &= ~SPI_CONTROL_MODE_MASK;\n\t\treq_mode = spi->mode & 0x3;\n\t\tif (req_mode == SPI_MODE_0)\n\t\t\tcommand1 |= SPI_CONTROL_MODE_0;\n\t\telse if (req_mode == SPI_MODE_1)\n\t\t\tcommand1 |= SPI_CONTROL_MODE_1;\n\t\telse if (req_mode == SPI_MODE_2)\n\t\t\tcommand1 |= SPI_CONTROL_MODE_2;\n\t\telse if (req_mode == SPI_MODE_3)\n\t\t\tcommand1 |= SPI_CONTROL_MODE_3;\n\n\t\tif (spi->mode & SPI_LSB_FIRST)\n\t\t\tcommand1 |= SPI_LSBIT_FE;\n\t\telse\n\t\t\tcommand1 &= ~SPI_LSBIT_FE;\n\n\t\tif (spi->mode & SPI_3WIRE)\n\t\t\tcommand1 |= SPI_BIDIROE;\n\t\telse\n\t\t\tcommand1 &= ~SPI_BIDIROE;\n\n\t\tif (tspi->cs_control) {\n\t\t\tif (tspi->cs_control != spi)\n\t\t\t\ttegra_spi_writel(tspi, command1, SPI_COMMAND1);\n\t\t\ttspi->cs_control = NULL;\n\t\t} else\n\t\t\ttegra_spi_writel(tspi, command1, SPI_COMMAND1);\n\n\t\t \n\t\tif (spi_get_csgpiod(spi, 0))\n\t\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 1);\n\n\t\tif (is_single_xfer && !(t->cs_change)) {\n\t\t\ttspi->use_hw_based_cs = true;\n\t\t\tcommand1 &= ~(SPI_CS_SW_HW | SPI_CS_SW_VAL);\n\t\t} else {\n\t\t\ttspi->use_hw_based_cs = false;\n\t\t\tcommand1 |= SPI_CS_SW_HW;\n\t\t\tif (spi->mode & SPI_CS_HIGH)\n\t\t\t\tcommand1 |= SPI_CS_SW_VAL;\n\t\t\telse\n\t\t\t\tcommand1 &= ~SPI_CS_SW_VAL;\n\t\t}\n\n\t\tif (tspi->last_used_cs != spi_get_chipselect(spi, 0)) {\n\t\t\tif (cdata && cdata->tx_clk_tap_delay)\n\t\t\t\ttx_tap = cdata->tx_clk_tap_delay;\n\t\t\tif (cdata && cdata->rx_clk_tap_delay)\n\t\t\t\trx_tap = cdata->rx_clk_tap_delay;\n\t\t\tcommand2 = SPI_TX_TAP_DELAY(tx_tap) |\n\t\t\t\t   SPI_RX_TAP_DELAY(rx_tap);\n\t\t\tif (command2 != tspi->def_command2_reg)\n\t\t\t\ttegra_spi_writel(tspi, command2, SPI_COMMAND2);\n\t\t\ttspi->last_used_cs = spi_get_chipselect(spi, 0);\n\t\t}\n\n\t} else {\n\t\tcommand1 = tspi->command1_reg;\n\t\tcommand1 &= ~SPI_BIT_LENGTH(~0);\n\t\tcommand1 |= SPI_BIT_LENGTH(bits_per_word - 1);\n\t}\n\n\treturn command1;\n}\n\nstatic int tegra_spi_start_transfer_one(struct spi_device *spi,\n\t\tstruct spi_transfer *t, u32 command1)\n{\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\n\tunsigned total_fifo_words;\n\tint ret;\n\n\ttotal_fifo_words = tegra_spi_calculate_curr_xfer_param(spi, tspi, t);\n\n\tif (t->rx_nbits == SPI_NBITS_DUAL || t->tx_nbits == SPI_NBITS_DUAL)\n\t\tcommand1 |= SPI_BOTH_EN_BIT;\n\telse\n\t\tcommand1 &= ~SPI_BOTH_EN_BIT;\n\n\tif (tspi->is_packed)\n\t\tcommand1 |= SPI_PACKED;\n\telse\n\t\tcommand1 &= ~SPI_PACKED;\n\n\tcommand1 &= ~(SPI_CS_SEL_MASK | SPI_TX_EN | SPI_RX_EN);\n\ttspi->cur_direction = 0;\n\tif (t->rx_buf) {\n\t\tcommand1 |= SPI_RX_EN;\n\t\ttspi->cur_direction |= DATA_DIR_RX;\n\t}\n\tif (t->tx_buf) {\n\t\tcommand1 |= SPI_TX_EN;\n\t\ttspi->cur_direction |= DATA_DIR_TX;\n\t}\n\tcommand1 |= SPI_CS_SEL(spi_get_chipselect(spi, 0));\n\ttegra_spi_writel(tspi, command1, SPI_COMMAND1);\n\ttspi->command1_reg = command1;\n\n\tdev_dbg(tspi->dev, \"The def 0x%x and written 0x%x\\n\",\n\t\ttspi->def_command1_reg, (unsigned)command1);\n\n\tret = tegra_spi_flush_fifos(tspi);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (total_fifo_words > SPI_FIFO_DEPTH)\n\t\tret = tegra_spi_start_dma_based_transfer(tspi, t);\n\telse\n\t\tret = tegra_spi_start_cpu_based_transfer(tspi, t);\n\treturn ret;\n}\n\nstatic struct tegra_spi_client_data\n\t*tegra_spi_parse_cdata_dt(struct spi_device *spi)\n{\n\tstruct tegra_spi_client_data *cdata;\n\tstruct device_node *slave_np;\n\n\tslave_np = spi->dev.of_node;\n\tif (!slave_np) {\n\t\tdev_dbg(&spi->dev, \"device node not found\\n\");\n\t\treturn NULL;\n\t}\n\n\tcdata = kzalloc(sizeof(*cdata), GFP_KERNEL);\n\tif (!cdata)\n\t\treturn NULL;\n\n\tof_property_read_u32(slave_np, \"nvidia,tx-clk-tap-delay\",\n\t\t\t     &cdata->tx_clk_tap_delay);\n\tof_property_read_u32(slave_np, \"nvidia,rx-clk-tap-delay\",\n\t\t\t     &cdata->rx_clk_tap_delay);\n\treturn cdata;\n}\n\nstatic void tegra_spi_cleanup(struct spi_device *spi)\n{\n\tstruct tegra_spi_client_data *cdata = spi->controller_data;\n\n\tspi->controller_data = NULL;\n\tif (spi->dev.of_node)\n\t\tkfree(cdata);\n}\n\nstatic int tegra_spi_setup(struct spi_device *spi)\n{\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\n\tstruct tegra_spi_client_data *cdata = spi->controller_data;\n\tu32 val;\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"setup %d bpw, %scpol, %scpha, %dHz\\n\",\n\t\tspi->bits_per_word,\n\t\tspi->mode & SPI_CPOL ? \"\" : \"~\",\n\t\tspi->mode & SPI_CPHA ? \"\" : \"~\",\n\t\tspi->max_speed_hz);\n\n\tif (!cdata) {\n\t\tcdata = tegra_spi_parse_cdata_dt(spi);\n\t\tspi->controller_data = cdata;\n\t}\n\n\tret = pm_runtime_resume_and_get(tspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(tspi->dev, \"pm runtime failed, e = %d\\n\", ret);\n\t\tif (cdata)\n\t\t\ttegra_spi_cleanup(spi);\n\t\treturn ret;\n\t}\n\n\tif (tspi->soc_data->has_intr_mask_reg) {\n\t\tval = tegra_spi_readl(tspi, SPI_INTR_MASK);\n\t\tval &= ~SPI_INTR_ALL_MASK;\n\t\ttegra_spi_writel(tspi, val, SPI_INTR_MASK);\n\t}\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\t \n\tif (spi_get_csgpiod(spi, 0))\n\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 0);\n\n\tval = tspi->def_command1_reg;\n\tif (spi->mode & SPI_CS_HIGH)\n\t\tval &= ~SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));\n\telse\n\t\tval |= SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));\n\ttspi->def_command1_reg = val;\n\ttegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\n\tpm_runtime_put(tspi->dev);\n\treturn 0;\n}\n\nstatic void tegra_spi_transfer_end(struct spi_device *spi)\n{\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\n\tint cs_val = (spi->mode & SPI_CS_HIGH) ? 0 : 1;\n\n\t \n\tif (spi_get_csgpiod(spi, 0))\n\t\tgpiod_set_value(spi_get_csgpiod(spi, 0), 0);\n\n\tif (!tspi->use_hw_based_cs) {\n\t\tif (cs_val)\n\t\t\ttspi->command1_reg |= SPI_CS_SW_VAL;\n\t\telse\n\t\t\ttspi->command1_reg &= ~SPI_CS_SW_VAL;\n\t\ttegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);\n\t}\n\n\ttegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);\n}\n\nstatic void tegra_spi_dump_regs(struct tegra_spi_data *tspi)\n{\n\tdev_dbg(tspi->dev, \"============ SPI REGISTER DUMP ============\\n\");\n\tdev_dbg(tspi->dev, \"Command1:    0x%08x | Command2:    0x%08x\\n\",\n\t\ttegra_spi_readl(tspi, SPI_COMMAND1),\n\t\ttegra_spi_readl(tspi, SPI_COMMAND2));\n\tdev_dbg(tspi->dev, \"DMA_CTL:     0x%08x | DMA_BLK:     0x%08x\\n\",\n\t\ttegra_spi_readl(tspi, SPI_DMA_CTL),\n\t\ttegra_spi_readl(tspi, SPI_DMA_BLK));\n\tdev_dbg(tspi->dev, \"TRANS_STAT:  0x%08x | FIFO_STATUS: 0x%08x\\n\",\n\t\ttegra_spi_readl(tspi, SPI_TRANS_STATUS),\n\t\ttegra_spi_readl(tspi, SPI_FIFO_STATUS));\n}\n\nstatic int tegra_spi_transfer_one_message(struct spi_master *master,\n\t\t\tstruct spi_message *msg)\n{\n\tbool is_first_msg = true;\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\n\tstruct spi_transfer *xfer;\n\tstruct spi_device *spi = msg->spi;\n\tint ret;\n\tbool skip = false;\n\tint single_xfer;\n\n\tmsg->status = 0;\n\tmsg->actual_length = 0;\n\n\tsingle_xfer = list_is_singular(&msg->transfers);\n\tlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\n\t\tu32 cmd1;\n\n\t\treinit_completion(&tspi->xfer_completion);\n\n\t\tcmd1 = tegra_spi_setup_transfer_one(spi, xfer, is_first_msg,\n\t\t\t\t\t\t    single_xfer);\n\n\t\tif (!xfer->len) {\n\t\t\tret = 0;\n\t\t\tskip = true;\n\t\t\tgoto complete_xfer;\n\t\t}\n\n\t\tret = tegra_spi_start_transfer_one(spi, xfer, cmd1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"spi can not start transfer, err %d\\n\", ret);\n\t\t\tgoto complete_xfer;\n\t\t}\n\n\t\tis_first_msg = false;\n\t\tret = wait_for_completion_timeout(&tspi->xfer_completion,\n\t\t\t\t\t\tSPI_DMA_TIMEOUT);\n\t\tif (WARN_ON(ret == 0)) {\n\t\t\tdev_err(tspi->dev, \"spi transfer timeout\\n\");\n\t\t\tif (tspi->is_curr_dma_xfer &&\n\t\t\t    (tspi->cur_direction & DATA_DIR_TX))\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\tif (tspi->is_curr_dma_xfer &&\n\t\t\t    (tspi->cur_direction & DATA_DIR_RX))\n\t\t\t\tdmaengine_terminate_all(tspi->rx_dma_chan);\n\t\t\tret = -EIO;\n\t\t\ttegra_spi_dump_regs(tspi);\n\t\t\ttegra_spi_flush_fifos(tspi);\n\t\t\treset_control_assert(tspi->rst);\n\t\t\tudelay(2);\n\t\t\treset_control_deassert(tspi->rst);\n\t\t\ttspi->last_used_cs = master->num_chipselect + 1;\n\t\t\tgoto complete_xfer;\n\t\t}\n\n\t\tif (tspi->tx_status ||  tspi->rx_status) {\n\t\t\tdev_err(tspi->dev, \"Error in Transfer\\n\");\n\t\t\tret = -EIO;\n\t\t\ttegra_spi_dump_regs(tspi);\n\t\t\tgoto complete_xfer;\n\t\t}\n\t\tmsg->actual_length += xfer->len;\n\ncomplete_xfer:\n\t\tif (ret < 0 || skip) {\n\t\t\ttegra_spi_transfer_end(spi);\n\t\t\tspi_transfer_delay_exec(xfer);\n\t\t\tgoto exit;\n\t\t} else if (list_is_last(&xfer->transfer_list,\n\t\t\t\t\t&msg->transfers)) {\n\t\t\tif (xfer->cs_change)\n\t\t\t\ttspi->cs_control = spi;\n\t\t\telse {\n\t\t\t\ttegra_spi_transfer_end(spi);\n\t\t\t\tspi_transfer_delay_exec(xfer);\n\t\t\t}\n\t\t} else if (xfer->cs_change) {\n\t\t\ttegra_spi_transfer_end(spi);\n\t\t\tspi_transfer_delay_exec(xfer);\n\t\t}\n\n\t}\n\tret = 0;\nexit:\n\tmsg->status = ret;\n\tspi_finalize_current_message(master);\n\treturn ret;\n}\n\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_spi_data *tspi)\n{\n\tstruct spi_transfer *t = tspi->curr_xfer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\tif (tspi->tx_status ||  tspi->rx_status) {\n\t\tdev_err(tspi->dev, \"CpuXfer ERROR bit set 0x%x\\n\",\n\t\t\ttspi->status_reg);\n\t\tdev_err(tspi->dev, \"CpuXfer 0x%08x:0x%08x\\n\",\n\t\t\ttspi->command1_reg, tspi->dma_control_reg);\n\t\ttegra_spi_dump_regs(tspi);\n\t\ttegra_spi_flush_fifos(tspi);\n\t\tcomplete(&tspi->xfer_completion);\n\t\tspin_unlock_irqrestore(&tspi->lock, flags);\n\t\treset_control_assert(tspi->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(tspi->rst);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttegra_spi_read_rx_fifo_to_client_rxbuf(tspi, t);\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->cur_pos = tspi->cur_tx_pos;\n\telse\n\t\ttspi->cur_pos = tspi->cur_rx_pos;\n\n\tif (tspi->cur_pos == t->len) {\n\t\tcomplete(&tspi->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\ttegra_spi_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);\n\ttegra_spi_start_cpu_based_transfer(tspi, t);\nexit:\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t handle_dma_based_xfer(struct tegra_spi_data *tspi)\n{\n\tstruct spi_transfer *t = tspi->curr_xfer;\n\tlong wait_status;\n\tint err = 0;\n\tunsigned total_fifo_words;\n\tunsigned long flags;\n\n\t \n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\tif (tspi->tx_status) {\n\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\terr += 1;\n\t\t} else {\n\t\t\twait_status = wait_for_completion_interruptible_timeout(\n\t\t\t\t&tspi->tx_dma_complete, SPI_DMA_TIMEOUT);\n\t\t\tif (wait_status <= 0) {\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\t\tdev_err(tspi->dev, \"TxDma Xfer failed\\n\");\n\t\t\t\terr += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\tif (tspi->rx_status) {\n\t\t\tdmaengine_terminate_all(tspi->rx_dma_chan);\n\t\t\terr += 2;\n\t\t} else {\n\t\t\twait_status = wait_for_completion_interruptible_timeout(\n\t\t\t\t&tspi->rx_dma_complete, SPI_DMA_TIMEOUT);\n\t\t\tif (wait_status <= 0) {\n\t\t\t\tdmaengine_terminate_all(tspi->rx_dma_chan);\n\t\t\t\tdev_err(tspi->dev, \"RxDma Xfer failed\\n\");\n\t\t\t\terr += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&tspi->lock, flags);\n\tif (err) {\n\t\tdev_err(tspi->dev, \"DmaXfer: ERROR bit set 0x%x\\n\",\n\t\t\ttspi->status_reg);\n\t\tdev_err(tspi->dev, \"DmaXfer 0x%08x:0x%08x\\n\",\n\t\t\ttspi->command1_reg, tspi->dma_control_reg);\n\t\ttegra_spi_dump_regs(tspi);\n\t\ttegra_spi_flush_fifos(tspi);\n\t\tcomplete(&tspi->xfer_completion);\n\t\tspin_unlock_irqrestore(&tspi->lock, flags);\n\t\treset_control_assert(tspi->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(tspi->rst);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttegra_spi_copy_spi_rxbuf_to_client_rxbuf(tspi, t);\n\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->cur_pos = tspi->cur_tx_pos;\n\telse\n\t\ttspi->cur_pos = tspi->cur_rx_pos;\n\n\tif (tspi->cur_pos == t->len) {\n\t\tcomplete(&tspi->xfer_completion);\n\t\tgoto exit;\n\t}\n\n\t \n\ttotal_fifo_words = tegra_spi_calculate_curr_xfer_param(tspi->cur_spi,\n\t\t\t\t\t\t\ttspi, t);\n\tif (total_fifo_words > SPI_FIFO_DEPTH)\n\t\terr = tegra_spi_start_dma_based_transfer(tspi, t);\n\telse\n\t\terr = tegra_spi_start_cpu_based_transfer(tspi, t);\n\nexit:\n\tspin_unlock_irqrestore(&tspi->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_spi_isr_thread(int irq, void *context_data)\n{\n\tstruct tegra_spi_data *tspi = context_data;\n\n\tif (!tspi->is_curr_dma_xfer)\n\t\treturn handle_cpu_based_xfer(tspi);\n\treturn handle_dma_based_xfer(tspi);\n}\n\nstatic irqreturn_t tegra_spi_isr(int irq, void *context_data)\n{\n\tstruct tegra_spi_data *tspi = context_data;\n\n\ttspi->status_reg = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\n\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\ttspi->tx_status = tspi->status_reg &\n\t\t\t\t\t(SPI_TX_FIFO_UNF | SPI_TX_FIFO_OVF);\n\n\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\ttspi->rx_status = tspi->status_reg &\n\t\t\t\t\t(SPI_RX_FIFO_OVF | SPI_RX_FIFO_UNF);\n\ttegra_spi_clear_status(tspi);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic struct tegra_spi_soc_data tegra114_spi_soc_data = {\n\t.has_intr_mask_reg = false,\n};\n\nstatic struct tegra_spi_soc_data tegra124_spi_soc_data = {\n\t.has_intr_mask_reg = false,\n};\n\nstatic struct tegra_spi_soc_data tegra210_spi_soc_data = {\n\t.has_intr_mask_reg = true,\n};\n\nstatic const struct of_device_id tegra_spi_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra114-spi\",\n\t\t.data\t    = &tegra114_spi_soc_data,\n\t}, {\n\t\t.compatible = \"nvidia,tegra124-spi\",\n\t\t.data\t    = &tegra124_spi_soc_data,\n\t}, {\n\t\t.compatible = \"nvidia,tegra210-spi\",\n\t\t.data\t    = &tegra210_spi_soc_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_spi_of_match);\n\nstatic int tegra_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master\t*master;\n\tstruct tegra_spi_data\t*tspi;\n\tstruct resource\t\t*r;\n\tint ret, spi_irq;\n\tint bus_num;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(*tspi));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"master allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, master);\n\ttspi = spi_master_get_devdata(master);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"spi-max-frequency\",\n\t\t\t\t &master->max_speed_hz))\n\t\tmaster->max_speed_hz = 25000000;  \n\n\t \n\tmaster->use_gpio_descriptors = true;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST |\n\t\t\t    SPI_TX_DUAL | SPI_RX_DUAL | SPI_3WIRE;\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\n\tmaster->setup = tegra_spi_setup;\n\tmaster->cleanup = tegra_spi_cleanup;\n\tmaster->transfer_one_message = tegra_spi_transfer_one_message;\n\tmaster->set_cs_timing = tegra_spi_set_hw_cs_timing;\n\tmaster->num_chipselect = MAX_CHIP_SELECT;\n\tmaster->auto_runtime_pm = true;\n\tbus_num = of_alias_get_id(pdev->dev.of_node, \"spi\");\n\tif (bus_num >= 0)\n\t\tmaster->bus_num = bus_num;\n\n\ttspi->master = master;\n\ttspi->dev = &pdev->dev;\n\tspin_lock_init(&tspi->lock);\n\n\ttspi->soc_data = of_device_get_match_data(&pdev->dev);\n\tif (!tspi->soc_data) {\n\t\tdev_err(&pdev->dev, \"unsupported tegra\\n\");\n\t\tret = -ENODEV;\n\t\tgoto exit_free_master;\n\t}\n\n\ttspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(tspi->base)) {\n\t\tret = PTR_ERR(tspi->base);\n\t\tgoto exit_free_master;\n\t}\n\ttspi->phys = r->start;\n\n\tspi_irq = platform_get_irq(pdev, 0);\n\tif (spi_irq < 0) {\n\t\tret = spi_irq;\n\t\tgoto exit_free_master;\n\t}\n\ttspi->irq = spi_irq;\n\n\ttspi->clk = devm_clk_get(&pdev->dev, \"spi\");\n\tif (IS_ERR(tspi->clk)) {\n\t\tdev_err(&pdev->dev, \"can not get clock\\n\");\n\t\tret = PTR_ERR(tspi->clk);\n\t\tgoto exit_free_master;\n\t}\n\n\ttspi->rst = devm_reset_control_get_exclusive(&pdev->dev, \"spi\");\n\tif (IS_ERR(tspi->rst)) {\n\t\tdev_err(&pdev->dev, \"can not get reset\\n\");\n\t\tret = PTR_ERR(tspi->rst);\n\t\tgoto exit_free_master;\n\t}\n\n\ttspi->max_buf_size = SPI_FIFO_DEPTH << 2;\n\ttspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;\n\n\tret = tegra_spi_init_dma_param(tspi, true);\n\tif (ret < 0)\n\t\tgoto exit_free_master;\n\tret = tegra_spi_init_dma_param(tspi, false);\n\tif (ret < 0)\n\t\tgoto exit_rx_dma_free;\n\ttspi->max_buf_size = tspi->dma_buf_size;\n\tinit_completion(&tspi->tx_dma_complete);\n\tinit_completion(&tspi->rx_dma_complete);\n\n\tinit_completion(&tspi->xfer_completion);\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = tegra_spi_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto exit_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pm runtime get failed, e = %d\\n\", ret);\n\t\tgoto exit_pm_disable;\n\t}\n\n\treset_control_assert(tspi->rst);\n\tudelay(2);\n\treset_control_deassert(tspi->rst);\n\ttspi->def_command1_reg  = SPI_M_S;\n\ttegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);\n\ttspi->spi_cs_timing1 = tegra_spi_readl(tspi, SPI_CS_TIMING1);\n\ttspi->spi_cs_timing2 = tegra_spi_readl(tspi, SPI_CS_TIMING2);\n\ttspi->def_command2_reg = tegra_spi_readl(tspi, SPI_COMMAND2);\n\ttspi->last_used_cs = master->num_chipselect + 1;\n\tpm_runtime_put(&pdev->dev);\n\tret = request_threaded_irq(tspi->irq, tegra_spi_isr,\n\t\t\t\t   tegra_spi_isr_thread, IRQF_ONESHOT,\n\t\t\t\t   dev_name(&pdev->dev), tspi);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register ISR for IRQ %d\\n\",\n\t\t\ttspi->irq);\n\t\tgoto exit_pm_disable;\n\t}\n\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can not register to master err %d\\n\", ret);\n\t\tgoto exit_free_irq;\n\t}\n\treturn ret;\n\nexit_free_irq:\n\tfree_irq(spi_irq, tspi);\nexit_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ttegra_spi_runtime_suspend(&pdev->dev);\n\ttegra_spi_deinit_dma_param(tspi, false);\nexit_rx_dma_free:\n\ttegra_spi_deinit_dma_param(tspi, true);\nexit_free_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void tegra_spi_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct tegra_spi_data\t*tspi = spi_master_get_devdata(master);\n\n\tfree_irq(tspi->irq, tspi);\n\n\tif (tspi->tx_dma_chan)\n\t\ttegra_spi_deinit_dma_param(tspi, false);\n\n\tif (tspi->rx_dma_chan)\n\t\ttegra_spi_deinit_dma_param(tspi, true);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ttegra_spi_runtime_suspend(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_spi_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\n\treturn spi_master_suspend(master);\n}\n\nstatic int tegra_spi_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm runtime failed, e = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ttegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);\n\ttegra_spi_writel(tspi, tspi->def_command2_reg, SPI_COMMAND2);\n\ttspi->last_used_cs = master->num_chipselect + 1;\n\tpm_runtime_put(dev);\n\n\treturn spi_master_resume(master);\n}\n#endif\n\nstatic int tegra_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\n\n\t \n\ttegra_spi_readl(tspi, SPI_COMMAND1);\n\n\tclk_disable_unprepare(tspi->clk);\n\treturn 0;\n}\n\nstatic int tegra_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(tspi->clk);\n\tif (ret < 0) {\n\t\tdev_err(tspi->dev, \"clk_prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_spi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_spi_runtime_suspend,\n\t\ttegra_spi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_spi_suspend, tegra_spi_resume)\n};\nstatic struct platform_driver tegra_spi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"spi-tegra114\",\n\t\t.pm\t\t= &tegra_spi_pm_ops,\n\t\t.of_match_table\t= tegra_spi_of_match,\n\t},\n\t.probe =\ttegra_spi_probe,\n\t.remove_new =\ttegra_spi_remove,\n};\nmodule_platform_driver(tegra_spi_driver);\n\nMODULE_ALIAS(\"platform:spi-tegra114\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra114 SPI Controller Driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}