{
  "module_name": "spi-sun4i.c",
  "hash_id": "9fb09998fc43be62f12b235535f31d2ab6d347eb723d0c967dde0d297d314137",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-sun4i.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/spi/spi.h>\n\n#define SUN4I_FIFO_DEPTH\t\t64\n\n#define SUN4I_RXDATA_REG\t\t0x00\n\n#define SUN4I_TXDATA_REG\t\t0x04\n\n#define SUN4I_CTL_REG\t\t\t0x08\n#define SUN4I_CTL_ENABLE\t\t\tBIT(0)\n#define SUN4I_CTL_MASTER\t\t\tBIT(1)\n#define SUN4I_CTL_CPHA\t\t\t\tBIT(2)\n#define SUN4I_CTL_CPOL\t\t\t\tBIT(3)\n#define SUN4I_CTL_CS_ACTIVE_LOW\t\t\tBIT(4)\n#define SUN4I_CTL_LMTF\t\t\t\tBIT(6)\n#define SUN4I_CTL_TF_RST\t\t\tBIT(8)\n#define SUN4I_CTL_RF_RST\t\t\tBIT(9)\n#define SUN4I_CTL_XCH\t\t\t\tBIT(10)\n#define SUN4I_CTL_CS_MASK\t\t\t0x3000\n#define SUN4I_CTL_CS(cs)\t\t\t(((cs) << 12) & SUN4I_CTL_CS_MASK)\n#define SUN4I_CTL_DHB\t\t\t\tBIT(15)\n#define SUN4I_CTL_CS_MANUAL\t\t\tBIT(16)\n#define SUN4I_CTL_CS_LEVEL\t\t\tBIT(17)\n#define SUN4I_CTL_TP\t\t\t\tBIT(18)\n\n#define SUN4I_INT_CTL_REG\t\t0x0c\n#define SUN4I_INT_CTL_RF_F34\t\t\tBIT(4)\n#define SUN4I_INT_CTL_TF_E34\t\t\tBIT(12)\n#define SUN4I_INT_CTL_TC\t\t\tBIT(16)\n\n#define SUN4I_INT_STA_REG\t\t0x10\n\n#define SUN4I_DMA_CTL_REG\t\t0x14\n\n#define SUN4I_WAIT_REG\t\t\t0x18\n\n#define SUN4I_CLK_CTL_REG\t\t0x1c\n#define SUN4I_CLK_CTL_CDR2_MASK\t\t\t0xff\n#define SUN4I_CLK_CTL_CDR2(div)\t\t\t((div) & SUN4I_CLK_CTL_CDR2_MASK)\n#define SUN4I_CLK_CTL_CDR1_MASK\t\t\t0xf\n#define SUN4I_CLK_CTL_CDR1(div)\t\t\t(((div) & SUN4I_CLK_CTL_CDR1_MASK) << 8)\n#define SUN4I_CLK_CTL_DRS\t\t\tBIT(12)\n\n#define SUN4I_MAX_XFER_SIZE\t\t\t0xffffff\n\n#define SUN4I_BURST_CNT_REG\t\t0x20\n#define SUN4I_BURST_CNT(cnt)\t\t\t((cnt) & SUN4I_MAX_XFER_SIZE)\n\n#define SUN4I_XMIT_CNT_REG\t\t0x24\n#define SUN4I_XMIT_CNT(cnt)\t\t\t((cnt) & SUN4I_MAX_XFER_SIZE)\n\n\n#define SUN4I_FIFO_STA_REG\t\t0x28\n#define SUN4I_FIFO_STA_RF_CNT_MASK\t\t0x7f\n#define SUN4I_FIFO_STA_RF_CNT_BITS\t\t0\n#define SUN4I_FIFO_STA_TF_CNT_MASK\t\t0x7f\n#define SUN4I_FIFO_STA_TF_CNT_BITS\t\t16\n\nstruct sun4i_spi {\n\tstruct spi_master\t*master;\n\tvoid __iomem\t\t*base_addr;\n\tstruct clk\t\t*hclk;\n\tstruct clk\t\t*mclk;\n\n\tstruct completion\tdone;\n\n\tconst u8\t\t*tx_buf;\n\tu8\t\t\t*rx_buf;\n\tint\t\t\tlen;\n};\n\nstatic inline u32 sun4i_spi_read(struct sun4i_spi *sspi, u32 reg)\n{\n\treturn readl(sspi->base_addr + reg);\n}\n\nstatic inline void sun4i_spi_write(struct sun4i_spi *sspi, u32 reg, u32 value)\n{\n\twritel(value, sspi->base_addr + reg);\n}\n\nstatic inline u32 sun4i_spi_get_tx_fifo_count(struct sun4i_spi *sspi)\n{\n\tu32 reg = sun4i_spi_read(sspi, SUN4I_FIFO_STA_REG);\n\n\treg >>= SUN4I_FIFO_STA_TF_CNT_BITS;\n\n\treturn reg & SUN4I_FIFO_STA_TF_CNT_MASK;\n}\n\nstatic inline void sun4i_spi_enable_interrupt(struct sun4i_spi *sspi, u32 mask)\n{\n\tu32 reg = sun4i_spi_read(sspi, SUN4I_INT_CTL_REG);\n\n\treg |= mask;\n\tsun4i_spi_write(sspi, SUN4I_INT_CTL_REG, reg);\n}\n\nstatic inline void sun4i_spi_disable_interrupt(struct sun4i_spi *sspi, u32 mask)\n{\n\tu32 reg = sun4i_spi_read(sspi, SUN4I_INT_CTL_REG);\n\n\treg &= ~mask;\n\tsun4i_spi_write(sspi, SUN4I_INT_CTL_REG, reg);\n}\n\nstatic inline void sun4i_spi_drain_fifo(struct sun4i_spi *sspi, int len)\n{\n\tu32 reg, cnt;\n\tu8 byte;\n\n\t \n\treg = sun4i_spi_read(sspi, SUN4I_FIFO_STA_REG);\n\treg &= SUN4I_FIFO_STA_RF_CNT_MASK;\n\tcnt = reg >> SUN4I_FIFO_STA_RF_CNT_BITS;\n\n\tif (len > cnt)\n\t\tlen = cnt;\n\n\twhile (len--) {\n\t\tbyte = readb(sspi->base_addr + SUN4I_RXDATA_REG);\n\t\tif (sspi->rx_buf)\n\t\t\t*sspi->rx_buf++ = byte;\n\t}\n}\n\nstatic inline void sun4i_spi_fill_fifo(struct sun4i_spi *sspi, int len)\n{\n\tu32 cnt;\n\tu8 byte;\n\n\t \n\tcnt = SUN4I_FIFO_DEPTH - sun4i_spi_get_tx_fifo_count(sspi);\n\n\tlen = min3(len, (int)cnt, sspi->len);\n\n\twhile (len--) {\n\t\tbyte = sspi->tx_buf ? *sspi->tx_buf++ : 0;\n\t\twriteb(byte, sspi->base_addr + SUN4I_TXDATA_REG);\n\t\tsspi->len--;\n\t}\n}\n\nstatic void sun4i_spi_set_cs(struct spi_device *spi, bool enable)\n{\n\tstruct sun4i_spi *sspi = spi_master_get_devdata(spi->master);\n\tu32 reg;\n\n\treg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\n\n\treg &= ~SUN4I_CTL_CS_MASK;\n\treg |= SUN4I_CTL_CS(spi_get_chipselect(spi, 0));\n\n\t \n\treg |= SUN4I_CTL_CS_MANUAL;\n\n\tif (enable)\n\t\treg |= SUN4I_CTL_CS_LEVEL;\n\telse\n\t\treg &= ~SUN4I_CTL_CS_LEVEL;\n\n\t \n\tif (spi->mode & SPI_CS_HIGH)\n\t\treg &= ~SUN4I_CTL_CS_ACTIVE_LOW;\n\telse\n\t\treg |= SUN4I_CTL_CS_ACTIVE_LOW;\n\n\tsun4i_spi_write(sspi, SUN4I_CTL_REG, reg);\n}\n\nstatic size_t sun4i_spi_max_transfer_size(struct spi_device *spi)\n{\n\treturn SUN4I_MAX_XFER_SIZE - 1;\n}\n\nstatic int sun4i_spi_transfer_one(struct spi_master *master,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *tfr)\n{\n\tstruct sun4i_spi *sspi = spi_master_get_devdata(master);\n\tunsigned int mclk_rate, div, timeout;\n\tunsigned int start, end, tx_time;\n\tunsigned int tx_len = 0;\n\tint ret = 0;\n\tu32 reg;\n\n\t \n\tif (tfr->len > SUN4I_MAX_XFER_SIZE)\n\t\treturn -EMSGSIZE;\n\n\tif (tfr->tx_buf && tfr->len >= SUN4I_MAX_XFER_SIZE)\n\t\treturn -EMSGSIZE;\n\n\treinit_completion(&sspi->done);\n\tsspi->tx_buf = tfr->tx_buf;\n\tsspi->rx_buf = tfr->rx_buf;\n\tsspi->len = tfr->len;\n\n\t \n\tsun4i_spi_write(sspi, SUN4I_INT_STA_REG, ~0);\n\n\n\treg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\n\n\t \n\tsun4i_spi_write(sspi, SUN4I_CTL_REG,\n\t\t\treg | SUN4I_CTL_RF_RST | SUN4I_CTL_TF_RST);\n\n\t \n\tif (spi->mode & SPI_CPOL)\n\t\treg |= SUN4I_CTL_CPOL;\n\telse\n\t\treg &= ~SUN4I_CTL_CPOL;\n\n\tif (spi->mode & SPI_CPHA)\n\t\treg |= SUN4I_CTL_CPHA;\n\telse\n\t\treg &= ~SUN4I_CTL_CPHA;\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\treg |= SUN4I_CTL_LMTF;\n\telse\n\t\treg &= ~SUN4I_CTL_LMTF;\n\n\n\t \n\tif (sspi->rx_buf)\n\t\treg &= ~SUN4I_CTL_DHB;\n\telse\n\t\treg |= SUN4I_CTL_DHB;\n\n\tsun4i_spi_write(sspi, SUN4I_CTL_REG, reg);\n\n\t \n\tmclk_rate = clk_get_rate(sspi->mclk);\n\tif (mclk_rate < (2 * tfr->speed_hz)) {\n\t\tclk_set_rate(sspi->mclk, 2 * tfr->speed_hz);\n\t\tmclk_rate = clk_get_rate(sspi->mclk);\n\t}\n\n\t \n\tdiv = mclk_rate / (2 * tfr->speed_hz);\n\tif (div <= (SUN4I_CLK_CTL_CDR2_MASK + 1)) {\n\t\tif (div > 0)\n\t\t\tdiv--;\n\n\t\treg = SUN4I_CLK_CTL_CDR2(div) | SUN4I_CLK_CTL_DRS;\n\t} else {\n\t\tdiv = ilog2(mclk_rate) - ilog2(tfr->speed_hz);\n\t\treg = SUN4I_CLK_CTL_CDR1(div);\n\t}\n\n\tsun4i_spi_write(sspi, SUN4I_CLK_CTL_REG, reg);\n\n\t \n\tif (sspi->tx_buf)\n\t\ttx_len = tfr->len;\n\n\t \n\tsun4i_spi_write(sspi, SUN4I_BURST_CNT_REG, SUN4I_BURST_CNT(tfr->len));\n\tsun4i_spi_write(sspi, SUN4I_XMIT_CNT_REG, SUN4I_XMIT_CNT(tx_len));\n\n\t \n\tsun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH - 1);\n\n\t \n\tsun4i_spi_enable_interrupt(sspi, SUN4I_INT_CTL_TC |\n\t\t\t\t\t SUN4I_INT_CTL_RF_F34);\n\t \n\tif (tx_len > SUN4I_FIFO_DEPTH)\n\t\tsun4i_spi_enable_interrupt(sspi, SUN4I_INT_CTL_TF_E34);\n\n\t \n\treg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\n\tsun4i_spi_write(sspi, SUN4I_CTL_REG, reg | SUN4I_CTL_XCH);\n\n\ttx_time = max(tfr->len * 8 * 2 / (tfr->speed_hz / 1000), 100U);\n\tstart = jiffies;\n\ttimeout = wait_for_completion_timeout(&sspi->done,\n\t\t\t\t\t      msecs_to_jiffies(tx_time));\n\tend = jiffies;\n\tif (!timeout) {\n\t\tdev_warn(&master->dev,\n\t\t\t \"%s: timeout transferring %u bytes@%iHz for %i(%i)ms\",\n\t\t\t dev_name(&spi->dev), tfr->len, tfr->speed_hz,\n\t\t\t jiffies_to_msecs(end - start), tx_time);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\nout:\n\tsun4i_spi_write(sspi, SUN4I_INT_CTL_REG, 0);\n\n\treturn ret;\n}\n\nstatic irqreturn_t sun4i_spi_handler(int irq, void *dev_id)\n{\n\tstruct sun4i_spi *sspi = dev_id;\n\tu32 status = sun4i_spi_read(sspi, SUN4I_INT_STA_REG);\n\n\t \n\tif (status & SUN4I_INT_CTL_TC) {\n\t\tsun4i_spi_write(sspi, SUN4I_INT_STA_REG, SUN4I_INT_CTL_TC);\n\t\tsun4i_spi_drain_fifo(sspi, SUN4I_FIFO_DEPTH);\n\t\tcomplete(&sspi->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & SUN4I_INT_CTL_RF_F34) {\n\t\tsun4i_spi_drain_fifo(sspi, SUN4I_FIFO_DEPTH);\n\t\t \n\t\tsun4i_spi_write(sspi, SUN4I_INT_STA_REG, SUN4I_INT_CTL_RF_F34);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & SUN4I_INT_CTL_TF_E34) {\n\t\tsun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH);\n\n\t\tif (!sspi->len)\n\t\t\t \n\t\t\tsun4i_spi_disable_interrupt(sspi, SUN4I_INT_CTL_TF_E34);\n\n\t\t \n\t\tsun4i_spi_write(sspi, SUN4I_INT_STA_REG, SUN4I_INT_CTL_TF_E34);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int sun4i_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct sun4i_spi *sspi = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = clk_prepare_enable(sspi->hclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't enable AHB clock\\n\");\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(sspi->mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't enable module clock\\n\");\n\t\tgoto err;\n\t}\n\n\tsun4i_spi_write(sspi, SUN4I_CTL_REG,\n\t\t\tSUN4I_CTL_ENABLE | SUN4I_CTL_MASTER | SUN4I_CTL_TP);\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(sspi->hclk);\nout:\n\treturn ret;\n}\n\nstatic int sun4i_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct sun4i_spi *sspi = spi_master_get_devdata(master);\n\n\tclk_disable_unprepare(sspi->mclk);\n\tclk_disable_unprepare(sspi->hclk);\n\n\treturn 0;\n}\n\nstatic int sun4i_spi_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct sun4i_spi *sspi;\n\tint ret = 0, irq;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(struct sun4i_spi));\n\tif (!master) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate SPI Master\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, master);\n\tsspi = spi_master_get_devdata(master);\n\n\tsspi->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sspi->base_addr)) {\n\t\tret = PTR_ERR(sspi->base_addr);\n\t\tgoto err_free_master;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENXIO;\n\t\tgoto err_free_master;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, sun4i_spi_handler,\n\t\t\t       0, \"sun4i-spi\", sspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request IRQ\\n\");\n\t\tgoto err_free_master;\n\t}\n\n\tsspi->master = master;\n\tmaster->max_speed_hz = 100 * 1000 * 1000;\n\tmaster->min_speed_hz = 3 * 1000;\n\tmaster->set_cs = sun4i_spi_set_cs;\n\tmaster->transfer_one = sun4i_spi_transfer_one;\n\tmaster->num_chipselect = 4;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->auto_runtime_pm = true;\n\tmaster->max_transfer_size = sun4i_spi_max_transfer_size;\n\n\tsspi->hclk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(sspi->hclk)) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire AHB clock\\n\");\n\t\tret = PTR_ERR(sspi->hclk);\n\t\tgoto err_free_master;\n\t}\n\n\tsspi->mclk = devm_clk_get(&pdev->dev, \"mod\");\n\tif (IS_ERR(sspi->mclk)) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire module clock\\n\");\n\t\tret = PTR_ERR(sspi->mclk);\n\t\tgoto err_free_master;\n\t}\n\n\tinit_completion(&sspi->done);\n\n\t \n\tret = sun4i_spi_runtime_resume(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't resume the device\\n\");\n\t\tgoto err_free_master;\n\t}\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_idle(&pdev->dev);\n\n\tret = devm_spi_register_master(&pdev->dev, master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register SPI master\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tsun4i_spi_runtime_suspend(&pdev->dev);\nerr_free_master:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void sun4i_spi_remove(struct platform_device *pdev)\n{\n\tpm_runtime_force_suspend(&pdev->dev);\n}\n\nstatic const struct of_device_id sun4i_spi_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sun4i_spi_match);\n\nstatic const struct dev_pm_ops sun4i_spi_pm_ops = {\n\t.runtime_resume\t\t= sun4i_spi_runtime_resume,\n\t.runtime_suspend\t= sun4i_spi_runtime_suspend,\n};\n\nstatic struct platform_driver sun4i_spi_driver = {\n\t.probe\t= sun4i_spi_probe,\n\t.remove_new = sun4i_spi_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"sun4i-spi\",\n\t\t.of_match_table\t= sun4i_spi_match,\n\t\t.pm\t\t= &sun4i_spi_pm_ops,\n\t},\n};\nmodule_platform_driver(sun4i_spi_driver);\n\nMODULE_AUTHOR(\"Pan Nan <pannan@allwinnertech.com>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A1X/A20 SPI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}