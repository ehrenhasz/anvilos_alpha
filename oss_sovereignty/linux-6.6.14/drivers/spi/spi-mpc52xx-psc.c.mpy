{
  "module_name": "spi-mpc52xx-psc.c",
  "hash_id": "5257aa7a0897cfb4e868ab0d38e3feeb2831bdc9df3a7019caaeef082051bb00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-mpc52xx-psc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n\n#include <asm/mpc52xx.h>\n#include <asm/mpc52xx_psc.h>\n\n#define MCLK 20000000  \n\nstruct mpc52xx_psc_spi {\n\t \n\tstruct mpc52xx_psc __iomem *psc;\n\tstruct mpc52xx_psc_fifo __iomem *fifo;\n\tint irq;\n\tu8 bits_per_word;\n\n\tstruct completion done;\n};\n\n \nstruct mpc52xx_psc_spi_cs {\n\tint bits_per_word;\n\tint speed_hz;\n};\n\n \nstatic int mpc52xx_psc_spi_transfer_setup(struct spi_device *spi,\n\t\tstruct spi_transfer *t)\n{\n\tstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\n\n\tcs->speed_hz = (t && t->speed_hz)\n\t\t\t? t->speed_hz : spi->max_speed_hz;\n\tcs->bits_per_word = (t && t->bits_per_word)\n\t\t\t? t->bits_per_word : spi->bits_per_word;\n\tcs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;\n\treturn 0;\n}\n\nstatic void mpc52xx_psc_spi_activate_cs(struct spi_device *spi)\n{\n\tstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\n\tstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\n\tstruct mpc52xx_psc __iomem *psc = mps->psc;\n\tu32 sicr;\n\tu16 ccr;\n\n\tsicr = in_be32(&psc->sicr);\n\n\t \n\tif (spi->mode & SPI_CPHA)\n\t\tsicr |= 0x00001000;\n\telse\n\t\tsicr &= ~0x00001000;\n\tif (spi->mode & SPI_CPOL)\n\t\tsicr |= 0x00002000;\n\telse\n\t\tsicr &= ~0x00002000;\n\n\tif (spi->mode & SPI_LSB_FIRST)\n\t\tsicr |= 0x10000000;\n\telse\n\t\tsicr &= ~0x10000000;\n\tout_be32(&psc->sicr, sicr);\n\n\t \n\tccr = in_be16((u16 __iomem *)&psc->ccr);\n\tccr &= 0xFF00;\n\tif (cs->speed_hz)\n\t\tccr |= (MCLK / cs->speed_hz - 1) & 0xFF;\n\telse  \n\t\tccr |= (MCLK / 1000000 - 1) & 0xFF;\n\tout_be16((u16 __iomem *)&psc->ccr, ccr);\n\tmps->bits_per_word = cs->bits_per_word;\n}\n\n#define MPC52xx_PSC_BUFSIZE (MPC52xx_PSC_RFNUM_MASK + 1)\n \n#define MPC52xx_PSC_RFALARM (MPC52xx_PSC_BUFSIZE * 20 / 100)\n\nstatic int mpc52xx_psc_spi_transfer_rxtx(struct spi_device *spi,\n\t\t\t\t\t\tstruct spi_transfer *t)\n{\n\tstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\n\tstruct mpc52xx_psc __iomem *psc = mps->psc;\n\tstruct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;\n\tunsigned rb = 0;\t \n\tunsigned sb = 0;\t \n\tunsigned char *rx_buf = (unsigned char *)t->rx_buf;\n\tunsigned char *tx_buf = (unsigned char *)t->tx_buf;\n\tunsigned rfalarm;\n\tunsigned send_at_once = MPC52xx_PSC_BUFSIZE;\n\tunsigned recv_at_once;\n\tint last_block = 0;\n\n\tif (!t->tx_buf && !t->rx_buf && t->len)\n\t\treturn -EINVAL;\n\n\t \n\tout_8(&psc->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\n\twhile (rb < t->len) {\n\t\tif (t->len - rb > MPC52xx_PSC_BUFSIZE) {\n\t\t\trfalarm = MPC52xx_PSC_RFALARM;\n\t\t\tlast_block = 0;\n\t\t} else {\n\t\t\tsend_at_once = t->len - sb;\n\t\t\trfalarm = MPC52xx_PSC_BUFSIZE - (t->len - rb);\n\t\t\tlast_block = 1;\n\t\t}\n\n\t\tdev_dbg(&spi->dev, \"send %d bytes...\\n\", send_at_once);\n\t\tfor (; send_at_once; sb++, send_at_once--) {\n\t\t\t \n\t\t\tif (send_at_once == 1 && last_block)\n\t\t\t\tout_8(&psc->ircr2, 0x01);\n\n\t\t\tif (tx_buf)\n\t\t\t\tout_8(&psc->mpc52xx_psc_buffer_8, tx_buf[sb]);\n\t\t\telse\n\t\t\t\tout_8(&psc->mpc52xx_psc_buffer_8, 0);\n\t\t}\n\n\n\t\t \n\t\tout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\n\t\tif (t->len - rb == 1) {\n\t\t\tout_8(&psc->mode, 0);\n\t\t} else {\n\t\t\tout_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);\n\t\t\tout_be16(&fifo->rfalarm, rfalarm);\n\t\t}\n\t\tout_be16(&psc->mpc52xx_psc_imr, MPC52xx_PSC_IMR_RXRDY);\n\t\twait_for_completion(&mps->done);\n\t\trecv_at_once = in_be16(&fifo->rfnum);\n\t\tdev_dbg(&spi->dev, \"%d bytes received\\n\", recv_at_once);\n\n\t\tsend_at_once = recv_at_once;\n\t\tif (rx_buf) {\n\t\t\tfor (; recv_at_once; rb++, recv_at_once--)\n\t\t\t\trx_buf[rb] = in_8(&psc->mpc52xx_psc_buffer_8);\n\t\t} else {\n\t\t\tfor (; recv_at_once; rb++, recv_at_once--)\n\t\t\t\tin_8(&psc->mpc52xx_psc_buffer_8);\n\t\t}\n\t}\n\t \n\tout_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\n\n\treturn 0;\n}\n\nint mpc52xx_psc_spi_transfer_one_message(struct spi_controller *ctlr,\n\t\t\t\t\t struct spi_message *m)\n{\n\tstruct spi_device *spi;\n\tstruct spi_transfer *t = NULL;\n\tunsigned cs_change;\n\tint status;\n\n\tspi = m->spi;\n\tcs_change = 1;\n\tstatus = 0;\n\tlist_for_each_entry (t, &m->transfers, transfer_list) {\n\t\tif (t->bits_per_word || t->speed_hz) {\n\t\t\tstatus = mpc52xx_psc_spi_transfer_setup(spi, t);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cs_change)\n\t\t\tmpc52xx_psc_spi_activate_cs(spi);\n\t\tcs_change = t->cs_change;\n\n\t\tstatus = mpc52xx_psc_spi_transfer_rxtx(spi, t);\n\t\tif (status)\n\t\t\tbreak;\n\t\tm->actual_length += t->len;\n\n\t\tspi_transfer_delay_exec(t);\n\t}\n\n\tm->status = status;\n\n\tmpc52xx_psc_spi_transfer_setup(spi, NULL);\n\n\tspi_finalize_current_message(ctlr);\n\n\treturn 0;\n}\n\nstatic int mpc52xx_psc_spi_setup(struct spi_device *spi)\n{\n\tstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\n\n\tif (spi->bits_per_word%8)\n\t\treturn -EINVAL;\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tspi->controller_state = cs;\n\t}\n\n\tcs->bits_per_word = spi->bits_per_word;\n\tcs->speed_hz = spi->max_speed_hz;\n\n\treturn 0;\n}\n\nstatic void mpc52xx_psc_spi_cleanup(struct spi_device *spi)\n{\n\tkfree(spi->controller_state);\n}\n\nstatic int mpc52xx_psc_spi_port_config(int psc_id, struct mpc52xx_psc_spi *mps)\n{\n\tstruct mpc52xx_psc __iomem *psc = mps->psc;\n\tstruct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;\n\tu32 mclken_div;\n\tint ret;\n\n\t \n\tmclken_div = 512000000 / MCLK;\n\tret = mpc52xx_set_psc_clkdiv(psc_id, mclken_div);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tout_8(&psc->command, MPC52xx_PSC_RST_RX);\n\tout_8(&psc->command, MPC52xx_PSC_RST_TX);\n\tout_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\n\n\t \n\tout_be16(&psc->mpc52xx_psc_imr, 0);\n\tout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\n\tout_8(&fifo->rfcntl, 0);\n\tout_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);\n\n\t \n\t \n\tout_be32(&psc->sicr, 0x0180C800);\n\tout_be16((u16 __iomem *)&psc->ccr, 0x070F);  \n\n\t \n\tout_8(&psc->ctur, 0x00);\n\tout_8(&psc->ctlr, 0x84);\n\n\tmps->bits_per_word = 8;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mpc52xx_psc_spi_isr(int irq, void *dev_id)\n{\n\tstruct mpc52xx_psc_spi *mps = (struct mpc52xx_psc_spi *)dev_id;\n\tstruct mpc52xx_psc __iomem *psc = mps->psc;\n\n\t \n\tif (in_be16(&psc->mpc52xx_psc_isr) & MPC52xx_PSC_IMR_RXRDY) {\n\t\tout_be16(&psc->mpc52xx_psc_imr, 0);\n\t\tcomplete(&mps->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int mpc52xx_psc_spi_of_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mpc52xx_psc_spi *mps;\n\tstruct spi_master *master;\n\tu32 bus_num;\n\tint ret;\n\n\tmaster = devm_spi_alloc_master(dev, sizeof(*mps));\n\tif (master == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, master);\n\tmps = spi_master_get_devdata(master);\n\n\t \n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\n\n\tret = device_property_read_u32(dev, \"cell-index\", &bus_num);\n\tif (ret || bus_num > 5)\n\t\treturn dev_err_probe(dev, ret ? : -EINVAL, \"Invalid cell-index property\\n\");\n\tmaster->bus_num = bus_num + 1;\n\n\tmaster->num_chipselect = 255;\n\tmaster->setup = mpc52xx_psc_spi_setup;\n\tmaster->transfer_one_message = mpc52xx_psc_spi_transfer_one_message;\n\tmaster->cleanup = mpc52xx_psc_spi_cleanup;\n\n\tdevice_set_node(&master->dev, dev_fwnode(dev));\n\n\tmps->psc = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(mps->psc))\n\t\treturn dev_err_probe(dev, PTR_ERR(mps->psc), \"could not ioremap I/O port range\\n\");\n\n\t \n\tmps->fifo = ((void __iomem *)mps->psc) + sizeof(struct mpc52xx_psc);\n\n\tmps->irq = platform_get_irq(pdev, 0);\n\tif (mps->irq < 0)\n\t\treturn mps->irq;\n\n\tret = devm_request_irq(dev, mps->irq, mpc52xx_psc_spi_isr, 0,\n\t\t\t       \"mpc52xx-psc-spi\", mps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mpc52xx_psc_spi_port_config(master->bus_num, mps);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"can't configure PSC! Is it capable of SPI?\\n\");\n\n\tinit_completion(&mps->done);\n\n\treturn devm_spi_register_master(dev, master);\n}\n\nstatic const struct of_device_id mpc52xx_psc_spi_of_match[] = {\n\t{ .compatible = \"fsl,mpc5200-psc-spi\", },\n\t{ .compatible = \"mpc5200-psc-spi\", },  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, mpc52xx_psc_spi_of_match);\n\nstatic struct platform_driver mpc52xx_psc_spi_of_driver = {\n\t.probe = mpc52xx_psc_spi_of_probe,\n\t.driver = {\n\t\t.name = \"mpc52xx-psc-spi\",\n\t\t.of_match_table = mpc52xx_psc_spi_of_match,\n\t},\n};\nmodule_platform_driver(mpc52xx_psc_spi_of_driver);\n\nMODULE_AUTHOR(\"Dragos Carp\");\nMODULE_DESCRIPTION(\"MPC52xx PSC SPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}