{
  "module_name": "spi-meson-spifc.c",
  "hash_id": "6a43f3af668820f91b5c3c038304f3b680fead8ae8c864137b89da65dece2bfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-meson-spifc.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n\n \n#define REG_CMD\t\t\t0x00\n#define REG_ADDR\t\t0x04\n#define REG_CTRL\t\t0x08\n#define REG_CTRL1\t\t0x0c\n#define REG_STATUS\t\t0x10\n#define REG_CTRL2\t\t0x14\n#define REG_CLOCK\t\t0x18\n#define REG_USER\t\t0x1c\n#define REG_USER1\t\t0x20\n#define REG_USER2\t\t0x24\n#define REG_USER3\t\t0x28\n#define REG_USER4\t\t0x2c\n#define REG_SLAVE\t\t0x30\n#define REG_SLAVE1\t\t0x34\n#define REG_SLAVE2\t\t0x38\n#define REG_SLAVE3\t\t0x3c\n#define REG_C0\t\t\t0x40\n#define REG_B8\t\t\t0x60\n#define REG_MAX\t\t\t0x7c\n\n \n#define CMD_USER\t\tBIT(18)\n#define CTRL_ENABLE_AHB\t\tBIT(17)\n#define CLOCK_SOURCE\t\tBIT(31)\n#define CLOCK_DIV_SHIFT\t\t12\n#define CLOCK_DIV_MASK\t\t(0x3f << CLOCK_DIV_SHIFT)\n#define CLOCK_CNT_HIGH_SHIFT\t6\n#define CLOCK_CNT_HIGH_MASK\t(0x3f << CLOCK_CNT_HIGH_SHIFT)\n#define CLOCK_CNT_LOW_SHIFT\t0\n#define CLOCK_CNT_LOW_MASK\t(0x3f << CLOCK_CNT_LOW_SHIFT)\n#define USER_DIN_EN_MS\t\tBIT(0)\n#define USER_CMP_MODE\t\tBIT(2)\n#define USER_UC_DOUT_SEL\tBIT(27)\n#define USER_UC_DIN_SEL\t\tBIT(28)\n#define USER_UC_MASK\t\t((BIT(5) - 1) << 27)\n#define USER1_BN_UC_DOUT_SHIFT\t17\n#define USER1_BN_UC_DOUT_MASK\t(0xff << 16)\n#define USER1_BN_UC_DIN_SHIFT\t8\n#define USER1_BN_UC_DIN_MASK\t(0xff << 8)\n#define USER4_CS_ACT\t\tBIT(30)\n#define SLAVE_TRST_DONE\t\tBIT(4)\n#define SLAVE_OP_MODE\t\tBIT(30)\n#define SLAVE_SW_RST\t\tBIT(31)\n\n#define SPIFC_BUFFER_SIZE\t64\n\n \nstruct meson_spifc {\n\tstruct spi_master *master;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct device *dev;\n};\n\nstatic const struct regmap_config spifc_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = REG_MAX,\n};\n\n \nstatic int meson_spifc_wait_ready(struct meson_spifc *spifc)\n{\n\tunsigned long deadline = jiffies + msecs_to_jiffies(5);\n\tu32 data;\n\n\tdo {\n\t\tregmap_read(spifc->regmap, REG_SLAVE, &data);\n\t\tif (data & SLAVE_TRST_DONE)\n\t\t\treturn 0;\n\t\tcond_resched();\n\t} while (!time_after(jiffies, deadline));\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void meson_spifc_drain_buffer(struct meson_spifc *spifc, u8 *buf,\n\t\t\t\t     int len)\n{\n\tu32 data;\n\tint i = 0;\n\n\twhile (i < len) {\n\t\tregmap_read(spifc->regmap, REG_C0 + i, &data);\n\n\t\tif (len - i >= 4) {\n\t\t\t*((u32 *)buf) = data;\n\t\t\tbuf += 4;\n\t\t} else {\n\t\t\tmemcpy(buf, &data, len - i);\n\t\t\tbreak;\n\t\t}\n\t\ti += 4;\n\t}\n}\n\n \nstatic void meson_spifc_fill_buffer(struct meson_spifc *spifc, const u8 *buf,\n\t\t\t\t    int len)\n{\n\tu32 data;\n\tint i = 0;\n\n\twhile (i < len) {\n\t\tif (len - i >= 4)\n\t\t\tdata = *(u32 *)buf;\n\t\telse\n\t\t\tmemcpy(&data, buf, len - i);\n\n\t\tregmap_write(spifc->regmap, REG_C0 + i, data);\n\n\t\tbuf += 4;\n\t\ti += 4;\n\t}\n}\n\n \nstatic void meson_spifc_setup_speed(struct meson_spifc *spifc, u32 speed)\n{\n\tunsigned long parent, value;\n\tint n;\n\n\tparent = clk_get_rate(spifc->clk);\n\tn = max_t(int, parent / speed - 1, 1);\n\n\tdev_dbg(spifc->dev, \"parent %lu, speed %u, n %d\\n\", parent,\n\t\tspeed, n);\n\n\tvalue = (n << CLOCK_DIV_SHIFT) & CLOCK_DIV_MASK;\n\tvalue |= (n << CLOCK_CNT_LOW_SHIFT) & CLOCK_CNT_LOW_MASK;\n\tvalue |= (((n + 1) / 2 - 1) << CLOCK_CNT_HIGH_SHIFT) &\n\t\tCLOCK_CNT_HIGH_MASK;\n\n\tregmap_write(spifc->regmap, REG_CLOCK, value);\n}\n\n \nstatic int meson_spifc_txrx(struct meson_spifc *spifc,\n\t\t\t    struct spi_transfer *xfer,\n\t\t\t    int offset, int len, bool last_xfer,\n\t\t\t    bool last_chunk)\n{\n\tbool keep_cs = true;\n\tint ret;\n\n\tif (xfer->tx_buf)\n\t\tmeson_spifc_fill_buffer(spifc, xfer->tx_buf + offset, len);\n\n\t \n\tregmap_update_bits(spifc->regmap, REG_USER, USER_UC_MASK,\n\t\t\t   USER_UC_DOUT_SEL);\n\tregmap_write(spifc->regmap, REG_USER1,\n\t\t     (8 * len - 1) << USER1_BN_UC_DOUT_SHIFT);\n\n\t \n\tregmap_update_bits(spifc->regmap, REG_USER, USER_DIN_EN_MS,\n\t\t\t   USER_DIN_EN_MS);\n\n\tif (last_chunk) {\n\t\tif (last_xfer)\n\t\t\tkeep_cs = xfer->cs_change;\n\t\telse\n\t\t\tkeep_cs = !xfer->cs_change;\n\t}\n\n\tregmap_update_bits(spifc->regmap, REG_USER4, USER4_CS_ACT,\n\t\t\t   keep_cs ? USER4_CS_ACT : 0);\n\n\t \n\tregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_TRST_DONE, 0);\n\t \n\tregmap_update_bits(spifc->regmap, REG_CMD, CMD_USER, CMD_USER);\n\n\tret = meson_spifc_wait_ready(spifc);\n\n\tif (!ret && xfer->rx_buf)\n\t\tmeson_spifc_drain_buffer(spifc, xfer->rx_buf + offset, len);\n\n\treturn ret;\n}\n\n \nstatic int meson_spifc_transfer_one(struct spi_master *master,\n\t\t\t\t    struct spi_device *spi,\n\t\t\t\t    struct spi_transfer *xfer)\n{\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\tint len, done = 0, ret = 0;\n\n\tmeson_spifc_setup_speed(spifc, xfer->speed_hz);\n\n\tregmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB, 0);\n\n\twhile (done < xfer->len && !ret) {\n\t\tlen = min_t(int, xfer->len - done, SPIFC_BUFFER_SIZE);\n\t\tret = meson_spifc_txrx(spifc, xfer, done, len,\n\t\t\t\t       spi_transfer_is_last(master, xfer),\n\t\t\t\t       done + len >= xfer->len);\n\t\tdone += len;\n\t}\n\n\tregmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB,\n\t\t\t   CTRL_ENABLE_AHB);\n\n\treturn ret;\n}\n\n \nstatic void meson_spifc_hw_init(struct meson_spifc *spifc)\n{\n\t \n\tregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_SW_RST,\n\t\t\t   SLAVE_SW_RST);\n\t \n\tregmap_update_bits(spifc->regmap, REG_USER, USER_CMP_MODE, 0);\n\t \n\tregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_OP_MODE, 0);\n}\n\nstatic int meson_spifc_probe(struct platform_device *pdev)\n{\n\tstruct spi_master *master;\n\tstruct meson_spifc *spifc;\n\tvoid __iomem *base;\n\tunsigned int rate;\n\tint ret = 0;\n\n\tmaster = spi_alloc_master(&pdev->dev, sizeof(struct meson_spifc));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tspifc = spi_master_get_devdata(master);\n\tspifc->dev = &pdev->dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto out_err;\n\t}\n\n\tspifc->regmap = devm_regmap_init_mmio(spifc->dev, base,\n\t\t\t\t\t      &spifc_regmap_config);\n\tif (IS_ERR(spifc->regmap)) {\n\t\tret = PTR_ERR(spifc->regmap);\n\t\tgoto out_err;\n\t}\n\n\tspifc->clk = devm_clk_get(spifc->dev, NULL);\n\tif (IS_ERR(spifc->clk)) {\n\t\tdev_err(spifc->dev, \"missing clock\\n\");\n\t\tret = PTR_ERR(spifc->clk);\n\t\tgoto out_err;\n\t}\n\n\tret = clk_prepare_enable(spifc->clk);\n\tif (ret) {\n\t\tdev_err(spifc->dev, \"can't prepare clock\\n\");\n\t\tgoto out_err;\n\t}\n\n\trate = clk_get_rate(spifc->clk);\n\n\tmaster->num_chipselect = 1;\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8);\n\tmaster->auto_runtime_pm = true;\n\tmaster->transfer_one = meson_spifc_transfer_one;\n\tmaster->min_speed_hz = rate >> 6;\n\tmaster->max_speed_hz = rate >> 1;\n\n\tmeson_spifc_hw_init(spifc);\n\n\tpm_runtime_set_active(spifc->dev);\n\tpm_runtime_enable(spifc->dev);\n\n\tret = devm_spi_register_master(spifc->dev, master);\n\tif (ret) {\n\t\tdev_err(spifc->dev, \"failed to register spi master\\n\");\n\t\tgoto out_clk;\n\t}\n\n\treturn 0;\nout_clk:\n\tclk_disable_unprepare(spifc->clk);\n\tpm_runtime_disable(spifc->dev);\nout_err:\n\tspi_master_put(master);\n\treturn ret;\n}\n\nstatic void meson_spifc_remove(struct platform_device *pdev)\n{\n\tstruct spi_master *master = platform_get_drvdata(pdev);\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tclk_disable_unprepare(spifc->clk);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int meson_spifc_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\tint ret;\n\n\tret = spi_master_suspend(master);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tclk_disable_unprepare(spifc->clk);\n\n\treturn 0;\n}\n\nstatic int meson_spifc_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\tint ret;\n\n\tif (!pm_runtime_suspended(dev)) {\n\t\tret = clk_prepare_enable(spifc->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmeson_spifc_hw_init(spifc);\n\n\tret = spi_master_resume(master);\n\tif (ret)\n\t\tclk_disable_unprepare(spifc->clk);\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int meson_spifc_runtime_suspend(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\n\tclk_disable_unprepare(spifc->clk);\n\n\treturn 0;\n}\n\nstatic int meson_spifc_runtime_resume(struct device *dev)\n{\n\tstruct spi_master *master = dev_get_drvdata(dev);\n\tstruct meson_spifc *spifc = spi_master_get_devdata(master);\n\n\treturn clk_prepare_enable(spifc->clk);\n}\n#endif  \n\nstatic const struct dev_pm_ops meson_spifc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(meson_spifc_suspend, meson_spifc_resume)\n\tSET_RUNTIME_PM_OPS(meson_spifc_runtime_suspend,\n\t\t\t   meson_spifc_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id meson_spifc_dt_match[] = {\n\t{ .compatible = \"amlogic,meson6-spifc\", },\n\t{ .compatible = \"amlogic,meson-gxbb-spifc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, meson_spifc_dt_match);\n\nstatic struct platform_driver meson_spifc_driver = {\n\t.probe\t= meson_spifc_probe,\n\t.remove_new = meson_spifc_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"meson-spifc\",\n\t\t.of_match_table\t= of_match_ptr(meson_spifc_dt_match),\n\t\t.pm\t\t= &meson_spifc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(meson_spifc_driver);\n\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson SPIFC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}