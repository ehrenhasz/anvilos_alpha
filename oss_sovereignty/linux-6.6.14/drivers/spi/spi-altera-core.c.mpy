{
  "module_name": "spi-altera-core.c",
  "hash_id": "edc62025e7570cd8df8776399390729e3d89be06644f5f44caa50c5cc31a1f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-altera-core.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/altera.h>\n#include <linux/spi/spi.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#define DRV_NAME \"spi_altera\"\n\n#define ALTERA_SPI_RXDATA\t0\n#define ALTERA_SPI_TXDATA\t4\n#define ALTERA_SPI_STATUS\t8\n#define ALTERA_SPI_CONTROL\t12\n#define ALTERA_SPI_TARGET_SEL\t20\n\n#define ALTERA_SPI_STATUS_ROE_MSK\t0x8\n#define ALTERA_SPI_STATUS_TOE_MSK\t0x10\n#define ALTERA_SPI_STATUS_TMT_MSK\t0x20\n#define ALTERA_SPI_STATUS_TRDY_MSK\t0x40\n#define ALTERA_SPI_STATUS_RRDY_MSK\t0x80\n#define ALTERA_SPI_STATUS_E_MSK\t\t0x100\n\n#define ALTERA_SPI_CONTROL_IROE_MSK\t0x8\n#define ALTERA_SPI_CONTROL_ITOE_MSK\t0x10\n#define ALTERA_SPI_CONTROL_ITRDY_MSK\t0x40\n#define ALTERA_SPI_CONTROL_IRRDY_MSK\t0x80\n#define ALTERA_SPI_CONTROL_IE_MSK\t0x100\n#define ALTERA_SPI_CONTROL_SSO_MSK\t0x400\n\nstatic int altr_spi_writel(struct altera_spi *hw, unsigned int reg,\n\t\t\t   unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_write(hw->regmap, hw->regoff + reg, val);\n\tif (ret)\n\t\tdev_err(hw->dev, \"fail to write reg 0x%x val 0x%x: %d\\n\",\n\t\t\treg, val, ret);\n\n\treturn ret;\n}\n\nstatic int altr_spi_readl(struct altera_spi *hw, unsigned int reg,\n\t\t\t  unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(hw->regmap, hw->regoff + reg, val);\n\tif (ret)\n\t\tdev_err(hw->dev, \"fail to read reg 0x%x: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic inline struct altera_spi *altera_spi_to_hw(struct spi_device *sdev)\n{\n\treturn spi_controller_get_devdata(sdev->controller);\n}\n\nstatic void altera_spi_set_cs(struct spi_device *spi, bool is_high)\n{\n\tstruct altera_spi *hw = altera_spi_to_hw(spi);\n\n\tif (is_high) {\n\t\thw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;\n\t\taltr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);\n\t\taltr_spi_writel(hw, ALTERA_SPI_TARGET_SEL, 0);\n\t} else {\n\t\taltr_spi_writel(hw, ALTERA_SPI_TARGET_SEL,\n\t\t\t\tBIT(spi_get_chipselect(spi, 0)));\n\t\thw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;\n\t\taltr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);\n\t}\n}\n\nstatic void altera_spi_tx_word(struct altera_spi *hw)\n{\n\tunsigned int txd = 0;\n\n\tif (hw->tx) {\n\t\tswitch (hw->bytes_per_word) {\n\t\tcase 1:\n\t\t\ttxd = hw->tx[hw->count];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttxd = (hw->tx[hw->count * 2]\n\t\t\t\t| (hw->tx[hw->count * 2 + 1] << 8));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttxd = (hw->tx[hw->count * 4]\n\t\t\t\t| (hw->tx[hw->count * 4 + 1] << 8)\n\t\t\t\t| (hw->tx[hw->count * 4 + 2] << 16)\n\t\t\t\t| (hw->tx[hw->count * 4 + 3] << 24));\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\taltr_spi_writel(hw, ALTERA_SPI_TXDATA, txd);\n}\n\nstatic void altera_spi_rx_word(struct altera_spi *hw)\n{\n\tunsigned int rxd;\n\n\taltr_spi_readl(hw, ALTERA_SPI_RXDATA, &rxd);\n\tif (hw->rx) {\n\t\tswitch (hw->bytes_per_word) {\n\t\tcase 1:\n\t\t\thw->rx[hw->count] = rxd;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\thw->rx[hw->count * 2] = rxd;\n\t\t\thw->rx[hw->count * 2 + 1] = rxd >> 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\thw->rx[hw->count * 4] = rxd;\n\t\t\thw->rx[hw->count * 4 + 1] = rxd >> 8;\n\t\t\thw->rx[hw->count * 4 + 2] = rxd >> 16;\n\t\t\thw->rx[hw->count * 4 + 3] = rxd >> 24;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\thw->count++;\n}\n\nstatic int altera_spi_txrx(struct spi_controller *host,\n\tstruct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct altera_spi *hw = spi_controller_get_devdata(host);\n\tu32 val;\n\n\thw->tx = t->tx_buf;\n\thw->rx = t->rx_buf;\n\thw->count = 0;\n\thw->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);\n\thw->len = t->len / hw->bytes_per_word;\n\n\tif (hw->irq >= 0) {\n\t\t \n\t\thw->imr |= ALTERA_SPI_CONTROL_IRRDY_MSK;\n\t\taltr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);\n\n\t\t \n\t\taltera_spi_tx_word(hw);\n\n\t\treturn 1;\n\t}\n\n\twhile (hw->count < hw->len) {\n\t\taltera_spi_tx_word(hw);\n\n\t\tfor (;;) {\n\t\t\taltr_spi_readl(hw, ALTERA_SPI_STATUS, &val);\n\t\t\tif (val & ALTERA_SPI_STATUS_RRDY_MSK)\n\t\t\t\tbreak;\n\n\t\t\tcpu_relax();\n\t\t}\n\n\t\taltera_spi_rx_word(hw);\n\t}\n\tspi_finalize_current_transfer(host);\n\n\treturn 0;\n}\n\nirqreturn_t altera_spi_irq(int irq, void *dev)\n{\n\tstruct spi_controller *host = dev;\n\tstruct altera_spi *hw = spi_controller_get_devdata(host);\n\n\taltera_spi_rx_word(hw);\n\n\tif (hw->count < hw->len) {\n\t\taltera_spi_tx_word(hw);\n\t} else {\n\t\t \n\t\thw->imr &= ~ALTERA_SPI_CONTROL_IRRDY_MSK;\n\t\taltr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);\n\n\t\tspi_finalize_current_transfer(host);\n\t}\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(altera_spi_irq);\n\nvoid altera_spi_init_host(struct spi_controller *host)\n{\n\tstruct altera_spi *hw = spi_controller_get_devdata(host);\n\tu32 val;\n\n\thost->transfer_one = altera_spi_txrx;\n\thost->set_cs = altera_spi_set_cs;\n\n\t \n\thw->imr = 0;\t\t \n\taltr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);\n\taltr_spi_writel(hw, ALTERA_SPI_STATUS, 0);\t \n\taltr_spi_readl(hw, ALTERA_SPI_STATUS, &val);\n\tif (val & ALTERA_SPI_STATUS_RRDY_MSK)\n\t\taltr_spi_readl(hw, ALTERA_SPI_RXDATA, &val);  \n}\nEXPORT_SYMBOL_GPL(altera_spi_init_host);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}