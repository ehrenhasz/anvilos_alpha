{
  "module_name": "spi-fsl-espi.c",
  "hash_id": "7fd86a0dae775374c091240baa05ee524bab9afde9c3ebba9201b6d19a44560b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-fsl-espi.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fsl_devices.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/pm_runtime.h>\n#include <sysdev/fsl_soc.h>\n\n \n#define ESPI_SPMODE\t0x00\t \n#define ESPI_SPIE\t0x04\t \n#define ESPI_SPIM\t0x08\t \n#define ESPI_SPCOM\t0x0c\t \n#define ESPI_SPITF\t0x10\t \n#define ESPI_SPIRF\t0x14\t \n#define ESPI_SPMODE0\t0x20\t \n\n#define ESPI_SPMODEx(x)\t(ESPI_SPMODE0 + (x) * 4)\n\n \n#define SPMODE_ENABLE\t\tBIT(31)\n#define SPMODE_LOOP\t\tBIT(30)\n#define SPMODE_TXTHR(x)\t\t((x) << 8)\n#define SPMODE_RXTHR(x)\t\t((x) << 0)\n\n \n#define CSMODE_CI_INACTIVEHIGH\tBIT(31)\n#define CSMODE_CP_BEGIN_EDGECLK\tBIT(30)\n#define CSMODE_REV\t\tBIT(29)\n#define CSMODE_DIV16\t\tBIT(28)\n#define CSMODE_PM(x)\t\t((x) << 24)\n#define CSMODE_POL_1\t\tBIT(20)\n#define CSMODE_LEN(x)\t\t((x) << 16)\n#define CSMODE_BEF(x)\t\t((x) << 12)\n#define CSMODE_AFT(x)\t\t((x) << 8)\n#define CSMODE_CG(x)\t\t((x) << 3)\n\n#define FSL_ESPI_FIFO_SIZE\t32\n#define FSL_ESPI_RXTHR\t\t15\n\n \n#define SPMODE_INIT_VAL (SPMODE_TXTHR(4) | SPMODE_RXTHR(FSL_ESPI_RXTHR))\n#define CSMODE_INIT_VAL (CSMODE_POL_1 | CSMODE_BEF(0) \\\n\t\t| CSMODE_AFT(0) | CSMODE_CG(1))\n\n \n#define SPIE_RXCNT(reg)     ((reg >> 24) & 0x3F)\n#define SPIE_TXCNT(reg)     ((reg >> 16) & 0x3F)\n#define\tSPIE_TXE\t\tBIT(15)\t \n#define\tSPIE_DON\t\tBIT(14)\t \n#define\tSPIE_RXT\t\tBIT(13)\t \n#define\tSPIE_RXF\t\tBIT(12)\t \n#define\tSPIE_TXT\t\tBIT(11)\t \n#define\tSPIE_RNE\t\tBIT(9)\t \n#define\tSPIE_TNF\t\tBIT(8)\t \n\n \n#define\tSPIM_TXE\t\tBIT(15)\t \n#define\tSPIM_DON\t\tBIT(14)\t \n#define\tSPIM_RXT\t\tBIT(13)\t \n#define\tSPIM_RXF\t\tBIT(12)\t \n#define\tSPIM_TXT\t\tBIT(11)\t \n#define\tSPIM_RNE\t\tBIT(9)\t \n#define\tSPIM_TNF\t\tBIT(8)\t \n\n \n#define SPCOM_CS(x)\t\t((x) << 30)\n#define SPCOM_DO\t\tBIT(28)  \n#define SPCOM_TO\t\tBIT(27)  \n#define SPCOM_RXSKIP(x)\t\t((x) << 16)\n#define SPCOM_TRANLEN(x)\t((x) << 0)\n\n#define\tSPCOM_TRANLEN_MAX\t0x10000\t \n\n#define AUTOSUSPEND_TIMEOUT 2000\n\nstruct fsl_espi {\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\n\tstruct list_head *m_transfers;\n\tstruct spi_transfer *tx_t;\n\tunsigned int tx_pos;\n\tbool tx_done;\n\tstruct spi_transfer *rx_t;\n\tunsigned int rx_pos;\n\tbool rx_done;\n\n\tbool swab;\n\tunsigned int rxskip;\n\n\tspinlock_t lock;\n\n\tu32 spibrg;              \n\n\tstruct completion done;\n};\n\nstruct fsl_espi_cs {\n\tu32 hw_mode;\n};\n\nstatic inline u32 fsl_espi_read_reg(struct fsl_espi *espi, int offset)\n{\n\treturn ioread32be(espi->reg_base + offset);\n}\n\nstatic inline u16 fsl_espi_read_reg16(struct fsl_espi *espi, int offset)\n{\n\treturn ioread16be(espi->reg_base + offset);\n}\n\nstatic inline u8 fsl_espi_read_reg8(struct fsl_espi *espi, int offset)\n{\n\treturn ioread8(espi->reg_base + offset);\n}\n\nstatic inline void fsl_espi_write_reg(struct fsl_espi *espi, int offset,\n\t\t\t\t      u32 val)\n{\n\tiowrite32be(val, espi->reg_base + offset);\n}\n\nstatic inline void fsl_espi_write_reg16(struct fsl_espi *espi, int offset,\n\t\t\t\t\tu16 val)\n{\n\tiowrite16be(val, espi->reg_base + offset);\n}\n\nstatic inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,\n\t\t\t\t       u8 val)\n{\n\tiowrite8(val, espi->reg_base + offset);\n}\n\nstatic int fsl_espi_check_message(struct spi_message *m)\n{\n\tstruct fsl_espi *espi = spi_controller_get_devdata(m->spi->controller);\n\tstruct spi_transfer *t, *first;\n\n\tif (m->frame_length > SPCOM_TRANLEN_MAX) {\n\t\tdev_err(espi->dev, \"message too long, size is %u bytes\\n\",\n\t\t\tm->frame_length);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tfirst = list_first_entry(&m->transfers, struct spi_transfer,\n\t\t\t\t transfer_list);\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (first->bits_per_word != t->bits_per_word ||\n\t\t    first->speed_hz != t->speed_hz) {\n\t\t\tdev_err(espi->dev, \"bits_per_word/speed_hz should be the same for all transfers\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!(m->spi->mode & SPI_LSB_FIRST) && first->bits_per_word != 8 &&\n\t    first->bits_per_word != 16) {\n\t\tdev_err(espi->dev,\n\t\t\t\"MSB-first transfer not supported for wordsize %u\\n\",\n\t\t\tfirst->bits_per_word);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int fsl_espi_check_rxskip_mode(struct spi_message *m)\n{\n\tstruct spi_transfer *t;\n\tunsigned int i = 0, rxskip = 0;\n\n\t \n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tif (i == 0) {\n\t\t\tif (!t->tx_buf || t->rx_buf ||\n\t\t\t    t->len > FSL_ESPI_FIFO_SIZE)\n\t\t\t\treturn 0;\n\t\t\trxskip = t->len;\n\t\t} else if (i == 1) {\n\t\t\tif (t->tx_buf || !t->rx_buf)\n\t\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i == 2 ? rxskip : 0;\n}\n\nstatic void fsl_espi_fill_tx_fifo(struct fsl_espi *espi, u32 events)\n{\n\tu32 tx_fifo_avail;\n\tunsigned int tx_left;\n\tconst void *tx_buf;\n\n\t \n\ttx_fifo_avail = events ? SPIE_TXCNT(events) :  FSL_ESPI_FIFO_SIZE;\nstart:\n\ttx_left = espi->tx_t->len - espi->tx_pos;\n\ttx_buf = espi->tx_t->tx_buf;\n\twhile (tx_fifo_avail >= min(4U, tx_left) && tx_left) {\n\t\tif (tx_left >= 4) {\n\t\t\tif (!tx_buf)\n\t\t\t\tfsl_espi_write_reg(espi, ESPI_SPITF, 0);\n\t\t\telse if (espi->swab)\n\t\t\t\tfsl_espi_write_reg(espi, ESPI_SPITF,\n\t\t\t\t\tswahb32p(tx_buf + espi->tx_pos));\n\t\t\telse\n\t\t\t\tfsl_espi_write_reg(espi, ESPI_SPITF,\n\t\t\t\t\t*(u32 *)(tx_buf + espi->tx_pos));\n\t\t\tespi->tx_pos += 4;\n\t\t\ttx_left -= 4;\n\t\t\ttx_fifo_avail -= 4;\n\t\t} else if (tx_left >= 2 && tx_buf && espi->swab) {\n\t\t\tfsl_espi_write_reg16(espi, ESPI_SPITF,\n\t\t\t\t\tswab16p(tx_buf + espi->tx_pos));\n\t\t\tespi->tx_pos += 2;\n\t\t\ttx_left -= 2;\n\t\t\ttx_fifo_avail -= 2;\n\t\t} else {\n\t\t\tif (!tx_buf)\n\t\t\t\tfsl_espi_write_reg8(espi, ESPI_SPITF, 0);\n\t\t\telse\n\t\t\t\tfsl_espi_write_reg8(espi, ESPI_SPITF,\n\t\t\t\t\t*(u8 *)(tx_buf + espi->tx_pos));\n\t\t\tespi->tx_pos += 1;\n\t\t\ttx_left -= 1;\n\t\t\ttx_fifo_avail -= 1;\n\t\t}\n\t}\n\n\tif (!tx_left) {\n\t\t \n\t\tif (list_is_last(&espi->tx_t->transfer_list,\n\t\t    espi->m_transfers) || espi->rxskip) {\n\t\t\tespi->tx_done = true;\n\t\t\treturn;\n\t\t}\n\t\tespi->tx_t = list_next_entry(espi->tx_t, transfer_list);\n\t\tespi->tx_pos = 0;\n\t\t \n\t\tif (tx_fifo_avail)\n\t\t\tgoto start;\n\t}\n}\n\nstatic void fsl_espi_read_rx_fifo(struct fsl_espi *espi, u32 events)\n{\n\tu32 rx_fifo_avail = SPIE_RXCNT(events);\n\tunsigned int rx_left;\n\tvoid *rx_buf;\n\nstart:\n\trx_left = espi->rx_t->len - espi->rx_pos;\n\trx_buf = espi->rx_t->rx_buf;\n\twhile (rx_fifo_avail >= min(4U, rx_left) && rx_left) {\n\t\tif (rx_left >= 4) {\n\t\t\tu32 val = fsl_espi_read_reg(espi, ESPI_SPIRF);\n\n\t\t\tif (rx_buf && espi->swab)\n\t\t\t\t*(u32 *)(rx_buf + espi->rx_pos) = swahb32(val);\n\t\t\telse if (rx_buf)\n\t\t\t\t*(u32 *)(rx_buf + espi->rx_pos) = val;\n\t\t\tespi->rx_pos += 4;\n\t\t\trx_left -= 4;\n\t\t\trx_fifo_avail -= 4;\n\t\t} else if (rx_left >= 2 && rx_buf && espi->swab) {\n\t\t\tu16 val = fsl_espi_read_reg16(espi, ESPI_SPIRF);\n\n\t\t\t*(u16 *)(rx_buf + espi->rx_pos) = swab16(val);\n\t\t\tespi->rx_pos += 2;\n\t\t\trx_left -= 2;\n\t\t\trx_fifo_avail -= 2;\n\t\t} else {\n\t\t\tu8 val = fsl_espi_read_reg8(espi, ESPI_SPIRF);\n\n\t\t\tif (rx_buf)\n\t\t\t\t*(u8 *)(rx_buf + espi->rx_pos) = val;\n\t\t\tespi->rx_pos += 1;\n\t\t\trx_left -= 1;\n\t\t\trx_fifo_avail -= 1;\n\t\t}\n\t}\n\n\tif (!rx_left) {\n\t\tif (list_is_last(&espi->rx_t->transfer_list,\n\t\t    espi->m_transfers)) {\n\t\t\tespi->rx_done = true;\n\t\t\treturn;\n\t\t}\n\t\tespi->rx_t = list_next_entry(espi->rx_t, transfer_list);\n\t\tespi->rx_pos = 0;\n\t\t \n\t\tif (rx_fifo_avail)\n\t\t\tgoto start;\n\t}\n}\n\nstatic void fsl_espi_setup_transfer(struct spi_device *spi,\n\t\t\t\t\tstruct spi_transfer *t)\n{\n\tstruct fsl_espi *espi = spi_controller_get_devdata(spi->controller);\n\tint bits_per_word = t ? t->bits_per_word : spi->bits_per_word;\n\tu32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;\n\tstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\n\tu32 hw_mode_old = cs->hw_mode;\n\n\t \n\tcs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));\n\n\tcs->hw_mode |= CSMODE_LEN(bits_per_word - 1);\n\n\tpm = DIV_ROUND_UP(espi->spibrg, hz * 4) - 1;\n\n\tif (pm > 15) {\n\t\tcs->hw_mode |= CSMODE_DIV16;\n\t\tpm = DIV_ROUND_UP(espi->spibrg, hz * 16 * 4) - 1;\n\t}\n\n\tcs->hw_mode |= CSMODE_PM(pm);\n\n\t \n\tif (cs->hw_mode != hw_mode_old)\n\t\tfsl_espi_write_reg(espi, ESPI_SPMODEx(spi_get_chipselect(spi, 0)),\n\t\t\t\t   cs->hw_mode);\n}\n\nstatic int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)\n{\n\tstruct fsl_espi *espi = spi_controller_get_devdata(spi->controller);\n\tunsigned int rx_len = t->len;\n\tu32 mask, spcom;\n\tint ret;\n\n\treinit_completion(&espi->done);\n\n\t \n\tspcom = SPCOM_CS(spi_get_chipselect(spi, 0));\n\tspcom |= SPCOM_TRANLEN(t->len - 1);\n\n\t \n\tif (espi->rxskip) {\n\t\tspcom |= SPCOM_RXSKIP(espi->rxskip);\n\t\trx_len = t->len - espi->rxskip;\n\t\tif (t->rx_nbits == SPI_NBITS_DUAL)\n\t\t\tspcom |= SPCOM_DO;\n\t}\n\n\tfsl_espi_write_reg(espi, ESPI_SPCOM, spcom);\n\n\t \n\tmask = SPIM_DON;\n\tif (rx_len > FSL_ESPI_FIFO_SIZE)\n\t\tmask |= SPIM_RXT;\n\tfsl_espi_write_reg(espi, ESPI_SPIM, mask);\n\n\t \n\tspin_lock_irq(&espi->lock);\n\tfsl_espi_fill_tx_fifo(espi, 0);\n\tspin_unlock_irq(&espi->lock);\n\n\t \n\tret = wait_for_completion_timeout(&espi->done, 2 * HZ);\n\tif (ret == 0)\n\t\tdev_err(espi->dev, \"Transfer timed out!\\n\");\n\n\t \n\tfsl_espi_write_reg(espi, ESPI_SPIM, 0);\n\n\treturn ret == 0 ? -ETIMEDOUT : 0;\n}\n\nstatic int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)\n{\n\tstruct fsl_espi *espi = spi_controller_get_devdata(m->spi->controller);\n\tstruct spi_device *spi = m->spi;\n\tint ret;\n\n\t \n\tespi->swab = spi->mode & SPI_LSB_FIRST && trans->bits_per_word > 8;\n\n\tespi->m_transfers = &m->transfers;\n\tespi->tx_t = list_first_entry(&m->transfers, struct spi_transfer,\n\t\t\t\t      transfer_list);\n\tespi->tx_pos = 0;\n\tespi->tx_done = false;\n\tespi->rx_t = list_first_entry(&m->transfers, struct spi_transfer,\n\t\t\t\t      transfer_list);\n\tespi->rx_pos = 0;\n\tespi->rx_done = false;\n\n\tespi->rxskip = fsl_espi_check_rxskip_mode(m);\n\tif (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {\n\t\tdev_err(espi->dev, \"Dual output mode requires RXSKIP mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (espi->rxskip)\n\t\tespi->rx_t = list_next_entry(espi->rx_t, transfer_list);\n\n\tfsl_espi_setup_transfer(spi, trans);\n\n\tret = fsl_espi_bufs(spi, trans);\n\n\tspi_transfer_delay_exec(trans);\n\n\treturn ret;\n}\n\nstatic int fsl_espi_do_one_msg(struct spi_controller *host,\n\t\t\t       struct spi_message *m)\n{\n\tunsigned int rx_nbits = 0, delay_nsecs = 0;\n\tstruct spi_transfer *t, trans = {};\n\tint ret;\n\n\tret = fsl_espi_check_message(m);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tunsigned int delay = spi_delay_to_ns(&t->delay, t);\n\n\t\tif (delay > delay_nsecs)\n\t\t\tdelay_nsecs = delay;\n\t\tif (t->rx_nbits > rx_nbits)\n\t\t\trx_nbits = t->rx_nbits;\n\t}\n\n\tt = list_first_entry(&m->transfers, struct spi_transfer,\n\t\t\t     transfer_list);\n\n\ttrans.len = m->frame_length;\n\ttrans.speed_hz = t->speed_hz;\n\ttrans.bits_per_word = t->bits_per_word;\n\ttrans.delay.value = delay_nsecs;\n\ttrans.delay.unit = SPI_DELAY_UNIT_NSECS;\n\ttrans.rx_nbits = rx_nbits;\n\n\tif (trans.len)\n\t\tret = fsl_espi_trans(m, &trans);\n\n\tm->actual_length = ret ? 0 : trans.len;\nout:\n\tif (m->status == -EINPROGRESS)\n\t\tm->status = ret;\n\n\tspi_finalize_current_message(host);\n\n\treturn ret;\n}\n\nstatic int fsl_espi_setup(struct spi_device *spi)\n{\n\tstruct fsl_espi *espi;\n\tu32 loop_mode;\n\tstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\n\n\tif (!cs) {\n\t\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\t\tif (!cs)\n\t\t\treturn -ENOMEM;\n\t\tspi_set_ctldata(spi, cs);\n\t}\n\n\tespi = spi_controller_get_devdata(spi->controller);\n\n\tpm_runtime_get_sync(espi->dev);\n\n\tcs->hw_mode = fsl_espi_read_reg(espi, ESPI_SPMODEx(spi_get_chipselect(spi, 0)));\n\t \n\tcs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH\n\t\t\t | CSMODE_REV);\n\n\tif (spi->mode & SPI_CPHA)\n\t\tcs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;\n\tif (spi->mode & SPI_CPOL)\n\t\tcs->hw_mode |= CSMODE_CI_INACTIVEHIGH;\n\tif (!(spi->mode & SPI_LSB_FIRST))\n\t\tcs->hw_mode |= CSMODE_REV;\n\n\t \n\tloop_mode = fsl_espi_read_reg(espi, ESPI_SPMODE);\n\tloop_mode &= ~SPMODE_LOOP;\n\tif (spi->mode & SPI_LOOP)\n\t\tloop_mode |= SPMODE_LOOP;\n\tfsl_espi_write_reg(espi, ESPI_SPMODE, loop_mode);\n\n\tfsl_espi_setup_transfer(spi, NULL);\n\n\tpm_runtime_mark_last_busy(espi->dev);\n\tpm_runtime_put_autosuspend(espi->dev);\n\n\treturn 0;\n}\n\nstatic void fsl_espi_cleanup(struct spi_device *spi)\n{\n\tstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\n\n\tkfree(cs);\n\tspi_set_ctldata(spi, NULL);\n}\n\nstatic void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)\n{\n\tif (!espi->rx_done)\n\t\tfsl_espi_read_rx_fifo(espi, events);\n\n\tif (!espi->tx_done)\n\t\tfsl_espi_fill_tx_fifo(espi, events);\n\n\tif (!espi->tx_done || !espi->rx_done)\n\t\treturn;\n\n\t \n\tevents = fsl_espi_read_reg(espi, ESPI_SPIE);\n\n\tif (!(events & SPIE_DON))\n\t\tdev_err(espi->dev,\n\t\t\t\"Transfer done but SPIE_DON isn't set!\\n\");\n\n\tif (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE) {\n\t\tdev_err(espi->dev, \"Transfer done but rx/tx fifo's aren't empty!\\n\");\n\t\tdev_err(espi->dev, \"SPIE_RXCNT = %d, SPIE_TXCNT = %d\\n\",\n\t\t\tSPIE_RXCNT(events), SPIE_TXCNT(events));\n\t}\n\n\tcomplete(&espi->done);\n}\n\nstatic irqreturn_t fsl_espi_irq(s32 irq, void *context_data)\n{\n\tstruct fsl_espi *espi = context_data;\n\tu32 events, mask;\n\n\tspin_lock(&espi->lock);\n\n\t \n\tevents = fsl_espi_read_reg(espi, ESPI_SPIE);\n\tmask = fsl_espi_read_reg(espi, ESPI_SPIM);\n\tif (!(events & mask)) {\n\t\tspin_unlock(&espi->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_vdbg(espi->dev, \"%s: events %x\\n\", __func__, events);\n\n\tfsl_espi_cpu_irq(espi, events);\n\n\t \n\tfsl_espi_write_reg(espi, ESPI_SPIE, events);\n\n\tspin_unlock(&espi->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_espi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct fsl_espi *espi = spi_controller_get_devdata(host);\n\tu32 regval;\n\n\tregval = fsl_espi_read_reg(espi, ESPI_SPMODE);\n\tregval &= ~SPMODE_ENABLE;\n\tfsl_espi_write_reg(espi, ESPI_SPMODE, regval);\n\n\treturn 0;\n}\n\nstatic int fsl_espi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct fsl_espi *espi = spi_controller_get_devdata(host);\n\tu32 regval;\n\n\tregval = fsl_espi_read_reg(espi, ESPI_SPMODE);\n\tregval |= SPMODE_ENABLE;\n\tfsl_espi_write_reg(espi, ESPI_SPMODE, regval);\n\n\treturn 0;\n}\n#endif\n\nstatic size_t fsl_espi_max_message_size(struct spi_device *spi)\n{\n\treturn SPCOM_TRANLEN_MAX;\n}\n\nstatic void fsl_espi_init_regs(struct device *dev, bool initial)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tstruct fsl_espi *espi = spi_controller_get_devdata(host);\n\tstruct device_node *nc;\n\tu32 csmode, cs, prop;\n\tint ret;\n\n\t \n\tfsl_espi_write_reg(espi, ESPI_SPMODE, 0);\n\tfsl_espi_write_reg(espi, ESPI_SPIM, 0);\n\tfsl_espi_write_reg(espi, ESPI_SPCOM, 0);\n\tfsl_espi_write_reg(espi, ESPI_SPIE, 0xffffffff);\n\n\t \n\tfor_each_available_child_of_node(host->dev.of_node, nc) {\n\t\t \n\t\tret = of_property_read_u32(nc, \"reg\", &cs);\n\t\tif (ret || cs >= host->num_chipselect)\n\t\t\tcontinue;\n\n\t\tcsmode = CSMODE_INIT_VAL;\n\n\t\t \n\t\tret = of_property_read_u32(nc, \"fsl,csbef\", &prop);\n\t\tif (!ret) {\n\t\t\tcsmode &= ~(CSMODE_BEF(0xf));\n\t\t\tcsmode |= CSMODE_BEF(prop);\n\t\t}\n\n\t\t \n\t\tret = of_property_read_u32(nc, \"fsl,csaft\", &prop);\n\t\tif (!ret) {\n\t\t\tcsmode &= ~(CSMODE_AFT(0xf));\n\t\t\tcsmode |= CSMODE_AFT(prop);\n\t\t}\n\n\t\tfsl_espi_write_reg(espi, ESPI_SPMODEx(cs), csmode);\n\n\t\tif (initial)\n\t\t\tdev_info(dev, \"cs=%u, init_csmode=0x%x\\n\", cs, csmode);\n\t}\n\n\t \n\tfsl_espi_write_reg(espi, ESPI_SPMODE, SPMODE_INIT_VAL | SPMODE_ENABLE);\n}\n\nstatic int fsl_espi_probe(struct device *dev, struct resource *mem,\n\t\t\t  unsigned int irq, unsigned int num_cs)\n{\n\tstruct spi_controller *host;\n\tstruct fsl_espi *espi;\n\tint ret;\n\n\thost = spi_alloc_host(dev, sizeof(struct fsl_espi));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, host);\n\n\thost->mode_bits = SPI_RX_DUAL | SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |\n\t\t\t  SPI_LSB_FIRST | SPI_LOOP;\n\thost->dev.of_node = dev->of_node;\n\thost->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\n\thost->setup = fsl_espi_setup;\n\thost->cleanup = fsl_espi_cleanup;\n\thost->transfer_one_message = fsl_espi_do_one_msg;\n\thost->auto_runtime_pm = true;\n\thost->max_message_size = fsl_espi_max_message_size;\n\thost->num_chipselect = num_cs;\n\n\tespi = spi_controller_get_devdata(host);\n\tspin_lock_init(&espi->lock);\n\n\tespi->dev = dev;\n\tespi->spibrg = fsl_get_sys_freq();\n\tif (espi->spibrg == -1) {\n\t\tdev_err(dev, \"Can't get sys frequency!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_probe;\n\t}\n\t \n\thost->min_speed_hz = DIV_ROUND_UP(espi->spibrg, 4 * 16 * 16);\n\thost->max_speed_hz = DIV_ROUND_UP(espi->spibrg, 4);\n\n\tinit_completion(&espi->done);\n\n\tespi->reg_base = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(espi->reg_base)) {\n\t\tret = PTR_ERR(espi->reg_base);\n\t\tgoto err_probe;\n\t}\n\n\t \n\tret = devm_request_irq(dev, irq, fsl_espi_irq, 0, \"fsl_espi\", espi);\n\tif (ret)\n\t\tgoto err_probe;\n\n\tfsl_espi_init_regs(dev, true);\n\n\tpm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tret = devm_spi_register_controller(dev, host);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tdev_info(dev, \"irq = %u\\n\", irq);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\nerr_probe:\n\tspi_controller_put(host);\n\treturn ret;\n}\n\nstatic int of_fsl_espi_get_chipselects(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 num_cs;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"fsl,espi-num-chipselects\", &num_cs);\n\tif (ret) {\n\t\tdev_err(dev, \"No 'fsl,espi-num-chipselects' property\\n\");\n\t\treturn 0;\n\t}\n\n\treturn num_cs;\n}\n\nstatic int of_fsl_espi_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct resource mem;\n\tunsigned int irq, num_cs;\n\tint ret;\n\n\tif (of_property_read_bool(np, \"mode\")) {\n\t\tdev_err(dev, \"mode property is not supported on ESPI!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_cs = of_fsl_espi_get_chipselects(dev);\n\tif (!num_cs)\n\t\treturn -EINVAL;\n\n\tret = of_address_to_resource(np, 0, &mem);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\treturn fsl_espi_probe(dev, &mem, irq, num_cs);\n}\n\nstatic void of_fsl_espi_remove(struct platform_device *dev)\n{\n\tpm_runtime_disable(&dev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int of_fsl_espi_suspend(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = spi_controller_suspend(host);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int of_fsl_espi_resume(struct device *dev)\n{\n\tstruct spi_controller *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tfsl_espi_init_regs(dev, false);\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn spi_controller_resume(host);\n}\n#endif  \n\nstatic const struct dev_pm_ops espi_pm = {\n\tSET_RUNTIME_PM_OPS(fsl_espi_runtime_suspend,\n\t\t\t   fsl_espi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(of_fsl_espi_suspend, of_fsl_espi_resume)\n};\n\nstatic const struct of_device_id of_fsl_espi_match[] = {\n\t{ .compatible = \"fsl,mpc8536-espi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_fsl_espi_match);\n\nstatic struct platform_driver fsl_espi_driver = {\n\t.driver = {\n\t\t.name = \"fsl_espi\",\n\t\t.of_match_table = of_fsl_espi_match,\n\t\t.pm = &espi_pm,\n\t},\n\t.probe\t\t= of_fsl_espi_probe,\n\t.remove_new\t= of_fsl_espi_remove,\n};\nmodule_platform_driver(fsl_espi_driver);\n\nMODULE_AUTHOR(\"Mingkai Hu\");\nMODULE_DESCRIPTION(\"Enhanced Freescale SPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}