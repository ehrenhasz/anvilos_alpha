{
  "module_name": "spi-topcliff-pch.c",
  "hash_id": "bacdde5ac11df832085686200836360b505070514fa32bcf82e59d4b6499e235",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spi/spi-topcliff-pch.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/spi/spidev.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n\n#include <linux/dmaengine.h>\n#include <linux/pch_dma.h>\n\n \n#define PCH_SPCR\t\t0x00\t \n#define PCH_SPBRR\t\t0x04\t \n#define PCH_SPSR\t\t0x08\t \n#define PCH_SPDWR\t\t0x0C\t \n#define PCH_SPDRR\t\t0x10\t \n#define PCH_SSNXCR\t\t0x18\t \n#define PCH_SRST\t\t0x1C\t \n#define PCH_ADDRESS_SIZE\t0x20\n\n#define PCH_SPSR_TFD\t\t0x000007C0\n#define PCH_SPSR_RFD\t\t0x0000F800\n\n#define PCH_READABLE(x)\t\t(((x) & PCH_SPSR_RFD)>>11)\n#define PCH_WRITABLE(x)\t\t(((x) & PCH_SPSR_TFD)>>6)\n\n#define PCH_RX_THOLD\t\t7\n#define PCH_RX_THOLD_MAX\t15\n\n#define PCH_TX_THOLD\t\t2\n\n#define PCH_MAX_BAUDRATE\t5000000\n#define PCH_MAX_FIFO_DEPTH\t16\n\n#define STATUS_RUNNING\t\t1\n#define STATUS_EXITING\t\t2\n#define PCH_SLEEP_TIME\t\t10\n\n#define SSN_LOW\t\t\t0x02U\n#define SSN_HIGH\t\t0x03U\n#define SSN_NO_CONTROL\t\t0x00U\n#define PCH_MAX_CS\t\t0xFF\n#define PCI_DEVICE_ID_GE_SPI\t0x8816\n\n#define SPCR_SPE_BIT\t\t(1 << 0)\n#define SPCR_MSTR_BIT\t\t(1 << 1)\n#define SPCR_LSBF_BIT\t\t(1 << 4)\n#define SPCR_CPHA_BIT\t\t(1 << 5)\n#define SPCR_CPOL_BIT\t\t(1 << 6)\n#define SPCR_TFIE_BIT\t\t(1 << 8)\n#define SPCR_RFIE_BIT\t\t(1 << 9)\n#define SPCR_FIE_BIT\t\t(1 << 10)\n#define SPCR_ORIE_BIT\t\t(1 << 11)\n#define SPCR_MDFIE_BIT\t\t(1 << 12)\n#define SPCR_FICLR_BIT\t\t(1 << 24)\n#define SPSR_TFI_BIT\t\t(1 << 0)\n#define SPSR_RFI_BIT\t\t(1 << 1)\n#define SPSR_FI_BIT\t\t(1 << 2)\n#define SPSR_ORF_BIT\t\t(1 << 3)\n#define SPBRR_SIZE_BIT\t\t(1 << 10)\n\n#define PCH_ALL\t\t\t(SPCR_TFIE_BIT|SPCR_RFIE_BIT|SPCR_FIE_BIT|\\\n\t\t\t\tSPCR_ORIE_BIT|SPCR_MDFIE_BIT)\n\n#define SPCR_RFIC_FIELD\t\t20\n#define SPCR_TFIC_FIELD\t\t16\n\n#define MASK_SPBRR_SPBR_BITS\t((1 << 10) - 1)\n#define MASK_RFIC_SPCR_BITS\t(0xf << SPCR_RFIC_FIELD)\n#define MASK_TFIC_SPCR_BITS\t(0xf << SPCR_TFIC_FIELD)\n\n#define PCH_CLOCK_HZ\t\t50000000\n#define PCH_MAX_SPBR\t\t1023\n\n \n#define PCI_DEVICE_ID_ML7213_SPI\t0x802c\n#define PCI_DEVICE_ID_ML7223_SPI\t0x800F\n#define PCI_DEVICE_ID_ML7831_SPI\t0x8816\n\n \n#define PCH_SPI_MAX_DEV\t\t\t2\n\n#define PCH_BUF_SIZE\t\t4096\n#define PCH_DMA_TRANS_SIZE\t12\n\nstatic int use_dma = 1;\n\nstruct pch_spi_dma_ctrl {\n\tstruct pci_dev\t\t*dma_dev;\n\tstruct dma_async_tx_descriptor\t*desc_tx;\n\tstruct dma_async_tx_descriptor\t*desc_rx;\n\tstruct pch_dma_slave\t\tparam_tx;\n\tstruct pch_dma_slave\t\tparam_rx;\n\tstruct dma_chan\t\t*chan_tx;\n\tstruct dma_chan\t\t*chan_rx;\n\tstruct scatterlist\t\t*sg_tx_p;\n\tstruct scatterlist\t\t*sg_rx_p;\n\tstruct scatterlist\t\tsg_tx;\n\tstruct scatterlist\t\tsg_rx;\n\tint\t\t\t\tnent;\n\tvoid\t\t\t\t*tx_buf_virt;\n\tvoid\t\t\t\t*rx_buf_virt;\n\tdma_addr_t\t\t\ttx_buf_dma;\n\tdma_addr_t\t\t\trx_buf_dma;\n};\n \nstruct pch_spi_data {\n\tvoid __iomem *io_remap_addr;\n\tunsigned long io_base_addr;\n\tstruct spi_master *master;\n\tstruct work_struct work;\n\twait_queue_head_t wait;\n\tu8 transfer_complete;\n\tu8 bcurrent_msg_processing;\n\tspinlock_t lock;\n\tstruct list_head queue;\n\tu8 status;\n\tu32 bpw_len;\n\tu8 transfer_active;\n\tu32 tx_index;\n\tu32 rx_index;\n\tu16 *pkt_tx_buff;\n\tu16 *pkt_rx_buff;\n\tu8 n_curnt_chip;\n\tstruct spi_device *current_chip;\n\tstruct spi_message *current_msg;\n\tstruct spi_transfer *cur_trans;\n\tstruct pch_spi_board_data *board_dat;\n\tstruct platform_device\t*plat_dev;\n\tint ch;\n\tstruct pch_spi_dma_ctrl dma;\n\tint use_dma;\n\tu8 irq_reg_sts;\n\tint save_total_len;\n};\n\n \nstruct pch_spi_board_data {\n\tstruct pci_dev *pdev;\n\tu8 suspend_sts;\n\tint num;\n};\n\nstruct pch_pd_dev_save {\n\tint num;\n\tstruct platform_device *pd_save[PCH_SPI_MAX_DEV];\n\tstruct pch_spi_board_data *board_dat;\n};\n\nstatic const struct pci_device_id pch_spi_pcidev_id[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_GE_SPI),    1, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7213_SPI), 2, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7223_SPI), 1, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7831_SPI), 1, },\n\t{ }\n};\n\n \nstatic inline void pch_spi_writereg(struct spi_master *master, int idx, u32 val)\n{\n\tstruct pch_spi_data *data = spi_master_get_devdata(master);\n\tiowrite32(val, (data->io_remap_addr + idx));\n}\n\n \nstatic inline u32 pch_spi_readreg(struct spi_master *master, int idx)\n{\n\tstruct pch_spi_data *data = spi_master_get_devdata(master);\n\treturn ioread32(data->io_remap_addr + idx);\n}\n\nstatic inline void pch_spi_setclr_reg(struct spi_master *master, int idx,\n\t\t\t\t      u32 set, u32 clr)\n{\n\tu32 tmp = pch_spi_readreg(master, idx);\n\ttmp = (tmp & ~clr) | set;\n\tpch_spi_writereg(master, idx, tmp);\n}\n\nstatic void pch_spi_set_master_mode(struct spi_master *master)\n{\n\tpch_spi_setclr_reg(master, PCH_SPCR, SPCR_MSTR_BIT, 0);\n}\n\n \nstatic void pch_spi_clear_fifo(struct spi_master *master)\n{\n\tpch_spi_setclr_reg(master, PCH_SPCR, SPCR_FICLR_BIT, 0);\n\tpch_spi_setclr_reg(master, PCH_SPCR, 0, SPCR_FICLR_BIT);\n}\n\nstatic void pch_spi_handler_sub(struct pch_spi_data *data, u32 reg_spsr_val,\n\t\t\t\tvoid __iomem *io_remap_addr)\n{\n\tu32 n_read, tx_index, rx_index, bpw_len;\n\tu16 *pkt_rx_buffer, *pkt_tx_buff;\n\tint read_cnt;\n\tu32 reg_spcr_val;\n\tvoid __iomem *spsr;\n\tvoid __iomem *spdrr;\n\tvoid __iomem *spdwr;\n\n\tspsr = io_remap_addr + PCH_SPSR;\n\tiowrite32(reg_spsr_val, spsr);\n\n\tif (data->transfer_active) {\n\t\trx_index = data->rx_index;\n\t\ttx_index = data->tx_index;\n\t\tbpw_len = data->bpw_len;\n\t\tpkt_rx_buffer = data->pkt_rx_buff;\n\t\tpkt_tx_buff = data->pkt_tx_buff;\n\n\t\tspdrr = io_remap_addr + PCH_SPDRR;\n\t\tspdwr = io_remap_addr + PCH_SPDWR;\n\n\t\tn_read = PCH_READABLE(reg_spsr_val);\n\n\t\tfor (read_cnt = 0; (read_cnt < n_read); read_cnt++) {\n\t\t\tpkt_rx_buffer[rx_index++] = ioread32(spdrr);\n\t\t\tif (tx_index < bpw_len)\n\t\t\t\tiowrite32(pkt_tx_buff[tx_index++], spdwr);\n\t\t}\n\n\t\t \n\t\tif ((bpw_len - rx_index) <= PCH_MAX_FIFO_DEPTH) {\n\t\t\treg_spcr_val = ioread32(io_remap_addr + PCH_SPCR);\n\t\t\treg_spcr_val &= ~SPCR_RFIE_BIT;  \n\n\t\t\t \n\t\t\treg_spcr_val &= ~MASK_RFIC_SPCR_BITS;\n\t\t\treg_spcr_val |= (PCH_RX_THOLD_MAX << SPCR_RFIC_FIELD);\n\n\t\t\tiowrite32(reg_spcr_val, (io_remap_addr + PCH_SPCR));\n\t\t}\n\n\t\t \n\t\tdata->tx_index = tx_index;\n\t\tdata->rx_index = rx_index;\n\n\t\t \n\t\tif (reg_spsr_val & SPSR_FI_BIT) {\n\t\t\tif ((tx_index == bpw_len) && (rx_index == tx_index)) {\n\t\t\t\t \n\t\t\t\tpch_spi_setclr_reg(data->master, PCH_SPCR, 0,\n\t\t\t\t\t\t   PCH_ALL);\n\n\t\t\t\t \n\t\t\t\tdata->transfer_complete = true;\n\t\t\t\tdata->transfer_active = false;\n\t\t\t\twake_up(&data->wait);\n\t\t\t} else {\n\t\t\t\tdev_vdbg(&data->master->dev,\n\t\t\t\t\t\"%s : Transfer is not completed\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t pch_spi_handler(int irq, void *dev_id)\n{\n\tu32 reg_spsr_val;\n\tvoid __iomem *spsr;\n\tvoid __iomem *io_remap_addr;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct pch_spi_data *data = dev_id;\n\tstruct pch_spi_board_data *board_dat = data->board_dat;\n\n\tif (board_dat->suspend_sts) {\n\t\tdev_dbg(&board_dat->pdev->dev,\n\t\t\t\"%s returning due to suspend\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\tio_remap_addr = data->io_remap_addr;\n\tspsr = io_remap_addr + PCH_SPSR;\n\n\treg_spsr_val = ioread32(spsr);\n\n\tif (reg_spsr_val & SPSR_ORF_BIT) {\n\t\tdev_err(&board_dat->pdev->dev, \"%s Over run error\\n\", __func__);\n\t\tif (data->current_msg->complete) {\n\t\t\tdata->transfer_complete = true;\n\t\t\tdata->current_msg->status = -EIO;\n\t\t\tdata->current_msg->complete(data->current_msg->context);\n\t\t\tdata->bcurrent_msg_processing = false;\n\t\t\tdata->current_msg = NULL;\n\t\t\tdata->cur_trans = NULL;\n\t\t}\n\t}\n\n\tif (data->use_dma)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (reg_spsr_val & (SPSR_FI_BIT | SPSR_RFI_BIT)) {\n\t\tpch_spi_handler_sub(data, reg_spsr_val, io_remap_addr);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tdev_dbg(&board_dat->pdev->dev, \"%s EXIT return value=%d\\n\",\n\t\t__func__, ret);\n\n\treturn ret;\n}\n\n \nstatic void pch_spi_set_baud_rate(struct spi_master *master, u32 speed_hz)\n{\n\tu32 n_spbr = PCH_CLOCK_HZ / (speed_hz * 2);\n\n\t \n\tif (n_spbr > PCH_MAX_SPBR)\n\t\tn_spbr = PCH_MAX_SPBR;\n\n\tpch_spi_setclr_reg(master, PCH_SPBRR, n_spbr, MASK_SPBRR_SPBR_BITS);\n}\n\n \nstatic void pch_spi_set_bits_per_word(struct spi_master *master,\n\t\t\t\t      u8 bits_per_word)\n{\n\tif (bits_per_word == 8)\n\t\tpch_spi_setclr_reg(master, PCH_SPBRR, 0, SPBRR_SIZE_BIT);\n\telse\n\t\tpch_spi_setclr_reg(master, PCH_SPBRR, SPBRR_SIZE_BIT, 0);\n}\n\n \nstatic void pch_spi_setup_transfer(struct spi_device *spi)\n{\n\tu32 flags = 0;\n\n\tdev_dbg(&spi->dev, \"%s SPBRR content =%x setting baud rate=%d\\n\",\n\t\t__func__, pch_spi_readreg(spi->master, PCH_SPBRR),\n\t\tspi->max_speed_hz);\n\tpch_spi_set_baud_rate(spi->master, spi->max_speed_hz);\n\n\t \n\tpch_spi_set_bits_per_word(spi->master, spi->bits_per_word);\n\n\tif (!(spi->mode & SPI_LSB_FIRST))\n\t\tflags |= SPCR_LSBF_BIT;\n\tif (spi->mode & SPI_CPOL)\n\t\tflags |= SPCR_CPOL_BIT;\n\tif (spi->mode & SPI_CPHA)\n\t\tflags |= SPCR_CPHA_BIT;\n\tpch_spi_setclr_reg(spi->master, PCH_SPCR, flags,\n\t\t\t   (SPCR_LSBF_BIT | SPCR_CPOL_BIT | SPCR_CPHA_BIT));\n\n\t \n\tpch_spi_clear_fifo(spi->master);\n}\n\n \nstatic void pch_spi_reset(struct spi_master *master)\n{\n\t \n\tpch_spi_writereg(master, PCH_SRST, 0x1);\n\n\t \n\tpch_spi_writereg(master, PCH_SRST, 0x0);\n}\n\nstatic int pch_spi_transfer(struct spi_device *pspi, struct spi_message *pmsg)\n{\n\tstruct pch_spi_data *data = spi_master_get_devdata(pspi->master);\n\tint retval;\n\tunsigned long flags;\n\n\t \n\tif (data->status == STATUS_EXITING) {\n\t\tdev_err(&pspi->dev, \"%s status = STATUS_EXITING.\\n\", __func__);\n\t\tretval = -ESHUTDOWN;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (data->board_dat->suspend_sts) {\n\t\tdev_err(&pspi->dev, \"%s suspend; returning EINVAL\\n\", __func__);\n\t\tretval = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tpmsg->actual_length = 0;\n\tdev_dbg(&pspi->dev, \"%s - pmsg->status =%d\\n\", __func__, pmsg->status);\n\n\tpmsg->status = -EINPROGRESS;\n\tspin_lock_irqsave(&data->lock, flags);\n\t \n\tlist_add_tail(&pmsg->queue, &data->queue);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tdev_dbg(&pspi->dev, \"%s - Invoked list_add_tail\\n\", __func__);\n\n\tschedule_work(&data->work);\n\tdev_dbg(&pspi->dev, \"%s - Invoked queue work\\n\", __func__);\n\n\tretval = 0;\n\nerr_out:\n\tdev_dbg(&pspi->dev, \"%s RETURN=%d\\n\", __func__, retval);\n\treturn retval;\n}\n\nstatic inline void pch_spi_select_chip(struct pch_spi_data *data,\n\t\t\t\t       struct spi_device *pspi)\n{\n\tif (data->current_chip != NULL) {\n\t\tif (spi_get_chipselect(pspi, 0) != data->n_curnt_chip) {\n\t\t\tdev_dbg(&pspi->dev, \"%s : different slave\\n\", __func__);\n\t\t\tdata->current_chip = NULL;\n\t\t}\n\t}\n\n\tdata->current_chip = pspi;\n\n\tdata->n_curnt_chip = spi_get_chipselect(data->current_chip, 0);\n\n\tdev_dbg(&pspi->dev, \"%s :Invoking pch_spi_setup_transfer\\n\", __func__);\n\tpch_spi_setup_transfer(pspi);\n}\n\nstatic void pch_spi_set_tx(struct pch_spi_data *data, int *bpw)\n{\n\tint size;\n\tu32 n_writes;\n\tint j;\n\tstruct spi_message *pmsg, *tmp;\n\tconst u8 *tx_buf;\n\tconst u16 *tx_sbuf;\n\n\t \n\tif (data->cur_trans->speed_hz) {\n\t\tdev_dbg(&data->master->dev, \"%s:setting baud rate\\n\", __func__);\n\t\tpch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);\n\t}\n\n\t \n\tif (data->cur_trans->bits_per_word &&\n\t    (data->current_msg->spi->bits_per_word != data->cur_trans->bits_per_word)) {\n\t\tdev_dbg(&data->master->dev, \"%s:set bits per word\\n\", __func__);\n\t\tpch_spi_set_bits_per_word(data->master,\n\t\t\t\t\t  data->cur_trans->bits_per_word);\n\t\t*bpw = data->cur_trans->bits_per_word;\n\t} else {\n\t\t*bpw = data->current_msg->spi->bits_per_word;\n\t}\n\n\t \n\tdata->tx_index = 0;\n\tdata->rx_index = 0;\n\n\tdata->bpw_len = data->cur_trans->len / (*bpw / 8);\n\n\t \n\tsize = data->cur_trans->len * sizeof(*data->pkt_tx_buff);\n\n\t \n\tdata->pkt_tx_buff = kzalloc(size, GFP_KERNEL);\n\tif (data->pkt_tx_buff != NULL) {\n\t\tdata->pkt_rx_buff = kzalloc(size, GFP_KERNEL);\n\t\tif (!data->pkt_rx_buff) {\n\t\t\tkfree(data->pkt_tx_buff);\n\t\t\tdata->pkt_tx_buff = NULL;\n\t\t}\n\t}\n\n\tif (!data->pkt_rx_buff) {\n\t\t \n\t\tlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\n\t\t\tpmsg->status = -ENOMEM;\n\n\t\t\tif (pmsg->complete)\n\t\t\t\tpmsg->complete(pmsg->context);\n\n\t\t\t \n\t\t\tlist_del_init(&pmsg->queue);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (data->cur_trans->tx_buf != NULL) {\n\t\tif (*bpw == 8) {\n\t\t\ttx_buf = data->cur_trans->tx_buf;\n\t\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t\tdata->pkt_tx_buff[j] = *tx_buf++;\n\t\t} else {\n\t\t\ttx_sbuf = data->cur_trans->tx_buf;\n\t\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t\tdata->pkt_tx_buff[j] = *tx_sbuf++;\n\t\t}\n\t}\n\n\t \n\tn_writes = data->bpw_len;\n\tif (n_writes > PCH_MAX_FIFO_DEPTH)\n\t\tn_writes = PCH_MAX_FIFO_DEPTH;\n\n\tdev_dbg(&data->master->dev,\n\t\t\"\\n%s:Pulling down SSN low - writing 0x2 to SSNXCR\\n\",\n\t\t__func__);\n\tpch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);\n\n\tfor (j = 0; j < n_writes; j++)\n\t\tpch_spi_writereg(data->master, PCH_SPDWR, data->pkt_tx_buff[j]);\n\n\t \n\tdata->tx_index = j;\n\n\t \n\tdata->transfer_complete = false;\n\tdata->transfer_active = true;\n}\n\nstatic void pch_spi_nomore_transfer(struct pch_spi_data *data)\n{\n\tstruct spi_message *pmsg, *tmp;\n\tdev_dbg(&data->master->dev, \"%s called\\n\", __func__);\n\t \n\tdata->current_msg->status = 0;\n\n\tif (data->current_msg->complete) {\n\t\tdev_dbg(&data->master->dev,\n\t\t\t\"%s:Invoking callback of SPI core\\n\", __func__);\n\t\tdata->current_msg->complete(data->current_msg->context);\n\t}\n\n\t \n\tdata->bcurrent_msg_processing = false;\n\n\tdev_dbg(&data->master->dev,\n\t\t\"%s:data->bcurrent_msg_processing = false\\n\", __func__);\n\n\tdata->current_msg = NULL;\n\tdata->cur_trans = NULL;\n\n\t \n\tif ((list_empty(&data->queue) == 0) &&\n\t    (!data->board_dat->suspend_sts) &&\n\t    (data->status != STATUS_EXITING)) {\n\t\t \n\t\tdev_dbg(&data->master->dev, \"%s:Invoke queue_work\\n\", __func__);\n\t\tschedule_work(&data->work);\n\t} else if (data->board_dat->suspend_sts ||\n\t\t   data->status == STATUS_EXITING) {\n\t\tdev_dbg(&data->master->dev,\n\t\t\t\"%s suspend/remove initiated, flushing queue\\n\",\n\t\t\t__func__);\n\t\tlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\n\t\t\tpmsg->status = -EIO;\n\n\t\t\tif (pmsg->complete)\n\t\t\t\tpmsg->complete(pmsg->context);\n\n\t\t\t \n\t\t\tlist_del_init(&pmsg->queue);\n\t\t}\n\t}\n}\n\nstatic void pch_spi_set_ir(struct pch_spi_data *data)\n{\n\t \n\tif ((data->bpw_len) > PCH_MAX_FIFO_DEPTH)\n\t\t \n\t\tpch_spi_setclr_reg(data->master, PCH_SPCR,\n\t\t\t\t   PCH_RX_THOLD << SPCR_RFIC_FIELD |\n\t\t\t\t   SPCR_FIE_BIT | SPCR_RFIE_BIT |\n\t\t\t\t   SPCR_ORIE_BIT | SPCR_SPE_BIT,\n\t\t\t\t   MASK_RFIC_SPCR_BITS | PCH_ALL);\n\telse\n\t\t \n\t\tpch_spi_setclr_reg(data->master, PCH_SPCR,\n\t\t\t\t   PCH_RX_THOLD_MAX << SPCR_RFIC_FIELD |\n\t\t\t\t   SPCR_FIE_BIT | SPCR_ORIE_BIT |\n\t\t\t\t   SPCR_SPE_BIT,\n\t\t\t\t   MASK_RFIC_SPCR_BITS | PCH_ALL);\n\n\t \n\tdev_dbg(&data->master->dev,\n\t\t\"%s:waiting for transfer to get over\\n\", __func__);\n\n\twait_event_interruptible(data->wait, data->transfer_complete);\n\n\t \n\tpch_spi_writereg(data->master, PCH_SPSR,\n\t\t\t pch_spi_readreg(data->master, PCH_SPSR));\n\t \n\tpch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL | SPCR_SPE_BIT);\n\t \n\tpch_spi_clear_fifo(data->master);\n}\n\nstatic void pch_spi_copy_rx_data(struct pch_spi_data *data, int bpw)\n{\n\tint j;\n\tu8 *rx_buf;\n\tu16 *rx_sbuf;\n\n\t \n\tif (!data->cur_trans->rx_buf)\n\t\treturn;\n\n\tif (bpw == 8) {\n\t\trx_buf = data->cur_trans->rx_buf;\n\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t*rx_buf++ = data->pkt_rx_buff[j] & 0xFF;\n\t} else {\n\t\trx_sbuf = data->cur_trans->rx_buf;\n\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t*rx_sbuf++ = data->pkt_rx_buff[j];\n\t}\n}\n\nstatic void pch_spi_copy_rx_data_for_dma(struct pch_spi_data *data, int bpw)\n{\n\tint j;\n\tu8 *rx_buf;\n\tu16 *rx_sbuf;\n\tconst u8 *rx_dma_buf;\n\tconst u16 *rx_dma_sbuf;\n\n\t \n\tif (!data->cur_trans->rx_buf)\n\t\treturn;\n\n\tif (bpw == 8) {\n\t\trx_buf = data->cur_trans->rx_buf;\n\t\trx_dma_buf = data->dma.rx_buf_virt;\n\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t*rx_buf++ = *rx_dma_buf++ & 0xFF;\n\t\tdata->cur_trans->rx_buf = rx_buf;\n\t} else {\n\t\trx_sbuf = data->cur_trans->rx_buf;\n\t\trx_dma_sbuf = data->dma.rx_buf_virt;\n\t\tfor (j = 0; j < data->bpw_len; j++)\n\t\t\t*rx_sbuf++ = *rx_dma_sbuf++;\n\t\tdata->cur_trans->rx_buf = rx_sbuf;\n\t}\n}\n\nstatic int pch_spi_start_transfer(struct pch_spi_data *data)\n{\n\tstruct pch_spi_dma_ctrl *dma;\n\tunsigned long flags;\n\tint rtn;\n\n\tdma = &data->dma;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\t \n\tpch_spi_setclr_reg(data->master, PCH_SPCR, SPCR_SPE_BIT, PCH_ALL);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tdev_dbg(&data->master->dev,\n\t\t\"%s:waiting for transfer to get over\\n\", __func__);\n\trtn = wait_event_interruptible_timeout(data->wait,\n\t\t\t\t\t       data->transfer_complete,\n\t\t\t\t\t       msecs_to_jiffies(2 * HZ));\n\tif (!rtn)\n\t\tdev_err(&data->master->dev,\n\t\t\t\"%s wait-event timeout\\n\", __func__);\n\n\tdma_sync_sg_for_cpu(&data->master->dev, dma->sg_rx_p, dma->nent,\n\t\t\t    DMA_FROM_DEVICE);\n\n\tdma_sync_sg_for_cpu(&data->master->dev, dma->sg_tx_p, dma->nent,\n\t\t\t    DMA_FROM_DEVICE);\n\tmemset(data->dma.tx_buf_virt, 0, PAGE_SIZE);\n\n\tasync_tx_ack(dma->desc_rx);\n\tasync_tx_ack(dma->desc_tx);\n\tkfree(dma->sg_tx_p);\n\tkfree(dma->sg_rx_p);\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\t \n\tpch_spi_setclr_reg(data->master, PCH_SPCR, 0,\n\t\t\t   MASK_RFIC_SPCR_BITS | MASK_TFIC_SPCR_BITS | PCH_ALL |\n\t\t\t   SPCR_SPE_BIT);\n\t \n\tpch_spi_writereg(data->master, PCH_SPSR,\n\t\t\t pch_spi_readreg(data->master, PCH_SPSR));\n\t \n\tpch_spi_clear_fifo(data->master);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\treturn rtn;\n}\n\nstatic void pch_dma_rx_complete(void *arg)\n{\n\tstruct pch_spi_data *data = arg;\n\n\t \n\tdata->transfer_complete = true;\n\twake_up_interruptible(&data->wait);\n}\n\nstatic bool pch_spi_filter(struct dma_chan *chan, void *slave)\n{\n\tstruct pch_dma_slave *param = slave;\n\n\tif ((chan->chan_id == param->chan_id) &&\n\t    (param->dma_dev == chan->device->dev)) {\n\t\tchan->private = param;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nstatic void pch_spi_request_dma(struct pch_spi_data *data, int bpw)\n{\n\tdma_cap_mask_t mask;\n\tstruct dma_chan *chan;\n\tstruct pci_dev *dma_dev;\n\tstruct pch_dma_slave *param;\n\tstruct pch_spi_dma_ctrl *dma;\n\tunsigned int width;\n\n\tif (bpw == 8)\n\t\twidth = PCH_DMA_WIDTH_1_BYTE;\n\telse\n\t\twidth = PCH_DMA_WIDTH_2_BYTES;\n\n\tdma = &data->dma;\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\tdma_dev = pci_get_slot(data->board_dat->pdev->bus,\n\t\t\tPCI_DEVFN(PCI_SLOT(data->board_dat->pdev->devfn), 0));\n\n\t \n\tparam = &dma->param_tx;\n\tparam->dma_dev = &dma_dev->dev;\n\tparam->chan_id = data->ch * 2;  \n\tparam->tx_reg = data->io_base_addr + PCH_SPDWR;\n\tparam->width = width;\n\tchan = dma_request_channel(mask, pch_spi_filter, param);\n\tif (!chan) {\n\t\tdev_err(&data->master->dev,\n\t\t\t\"ERROR: dma_request_channel FAILS(Tx)\\n\");\n\t\tgoto out;\n\t}\n\tdma->chan_tx = chan;\n\n\t \n\tparam = &dma->param_rx;\n\tparam->dma_dev = &dma_dev->dev;\n\tparam->chan_id = data->ch * 2 + 1;  \n\tparam->rx_reg = data->io_base_addr + PCH_SPDRR;\n\tparam->width = width;\n\tchan = dma_request_channel(mask, pch_spi_filter, param);\n\tif (!chan) {\n\t\tdev_err(&data->master->dev,\n\t\t\t\"ERROR: dma_request_channel FAILS(Rx)\\n\");\n\t\tdma_release_channel(dma->chan_tx);\n\t\tdma->chan_tx = NULL;\n\t\tgoto out;\n\t}\n\tdma->chan_rx = chan;\n\n\tdma->dma_dev = dma_dev;\n\treturn;\nout:\n\tpci_dev_put(dma_dev);\n\tdata->use_dma = 0;\n}\n\nstatic void pch_spi_release_dma(struct pch_spi_data *data)\n{\n\tstruct pch_spi_dma_ctrl *dma;\n\n\tdma = &data->dma;\n\tif (dma->chan_tx) {\n\t\tdma_release_channel(dma->chan_tx);\n\t\tdma->chan_tx = NULL;\n\t}\n\tif (dma->chan_rx) {\n\t\tdma_release_channel(dma->chan_rx);\n\t\tdma->chan_rx = NULL;\n\t}\n\n\tpci_dev_put(dma->dma_dev);\n}\n\nstatic void pch_spi_handle_dma(struct pch_spi_data *data, int *bpw)\n{\n\tconst u8 *tx_buf;\n\tconst u16 *tx_sbuf;\n\tu8 *tx_dma_buf;\n\tu16 *tx_dma_sbuf;\n\tstruct scatterlist *sg;\n\tstruct dma_async_tx_descriptor *desc_tx;\n\tstruct dma_async_tx_descriptor *desc_rx;\n\tint num;\n\tint i;\n\tint size;\n\tint rem;\n\tint head;\n\tunsigned long flags;\n\tstruct pch_spi_dma_ctrl *dma;\n\n\tdma = &data->dma;\n\n\t \n\tif (data->cur_trans->speed_hz) {\n\t\tdev_dbg(&data->master->dev, \"%s:setting baud rate\\n\", __func__);\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tpch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\t \n\tif (data->cur_trans->bits_per_word &&\n\t    (data->current_msg->spi->bits_per_word !=\n\t     data->cur_trans->bits_per_word)) {\n\t\tdev_dbg(&data->master->dev, \"%s:set bits per word\\n\", __func__);\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tpch_spi_set_bits_per_word(data->master,\n\t\t\t\t\t  data->cur_trans->bits_per_word);\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\t*bpw = data->cur_trans->bits_per_word;\n\t} else {\n\t\t*bpw = data->current_msg->spi->bits_per_word;\n\t}\n\tdata->bpw_len = data->cur_trans->len / (*bpw / 8);\n\n\tif (data->bpw_len > PCH_BUF_SIZE) {\n\t\tdata->bpw_len = PCH_BUF_SIZE;\n\t\tdata->cur_trans->len -= PCH_BUF_SIZE;\n\t}\n\n\t \n\tif (data->cur_trans->tx_buf != NULL) {\n\t\tif (*bpw == 8) {\n\t\t\ttx_buf = data->cur_trans->tx_buf;\n\t\t\ttx_dma_buf = dma->tx_buf_virt;\n\t\t\tfor (i = 0; i < data->bpw_len; i++)\n\t\t\t\t*tx_dma_buf++ = *tx_buf++;\n\t\t} else {\n\t\t\ttx_sbuf = data->cur_trans->tx_buf;\n\t\t\ttx_dma_sbuf = dma->tx_buf_virt;\n\t\t\tfor (i = 0; i < data->bpw_len; i++)\n\t\t\t\t*tx_dma_sbuf++ = *tx_sbuf++;\n\t\t}\n\t}\n\n\t \n\tif (data->bpw_len > PCH_DMA_TRANS_SIZE) {\n\t\tif (data->bpw_len % PCH_DMA_TRANS_SIZE) {\n\t\t\tnum = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;\n\t\t\trem = data->bpw_len % PCH_DMA_TRANS_SIZE;\n\t\t} else {\n\t\t\tnum = data->bpw_len / PCH_DMA_TRANS_SIZE;\n\t\t\trem = PCH_DMA_TRANS_SIZE;\n\t\t}\n\t\tsize = PCH_DMA_TRANS_SIZE;\n\t} else {\n\t\tnum = 1;\n\t\tsize = data->bpw_len;\n\t\trem = data->bpw_len;\n\t}\n\tdev_dbg(&data->master->dev, \"%s num=%d size=%d rem=%d\\n\",\n\t\t__func__, num, size, rem);\n\tspin_lock_irqsave(&data->lock, flags);\n\n\t \n\tpch_spi_setclr_reg(data->master, PCH_SPCR,\n\t\t\t   ((size - 1) << SPCR_RFIC_FIELD) |\n\t\t\t   (PCH_TX_THOLD << SPCR_TFIC_FIELD),\n\t\t\t   MASK_RFIC_SPCR_BITS | MASK_TFIC_SPCR_BITS);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tdma->sg_rx_p = kmalloc_array(num, sizeof(*dma->sg_rx_p), GFP_ATOMIC);\n\tif (!dma->sg_rx_p)\n\t\treturn;\n\n\tsg_init_table(dma->sg_rx_p, num);  \n\t \n\tsg = dma->sg_rx_p;\n\tfor (i = 0; i < num; i++, sg++) {\n\t\tif (i == (num - 2)) {\n\t\t\tsg->offset = size * i;\n\t\t\tsg->offset = sg->offset * (*bpw / 8);\n\t\t\tsg_set_page(sg, virt_to_page(dma->rx_buf_virt), rem,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = rem;\n\t\t} else if (i == (num - 1)) {\n\t\t\tsg->offset = size * (i - 1) + rem;\n\t\t\tsg->offset = sg->offset * (*bpw / 8);\n\t\t\tsg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = size;\n\t\t} else {\n\t\t\tsg->offset = size * i;\n\t\t\tsg->offset = sg->offset * (*bpw / 8);\n\t\t\tsg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = size;\n\t\t}\n\t\tsg_dma_address(sg) = dma->rx_buf_dma + sg->offset;\n\t}\n\tsg = dma->sg_rx_p;\n\tdesc_rx = dmaengine_prep_slave_sg(dma->chan_rx, sg,\n\t\t\t\t\tnum, DMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx) {\n\t\tdev_err(&data->master->dev,\n\t\t\t\"%s:dmaengine_prep_slave_sg Failed\\n\", __func__);\n\t\treturn;\n\t}\n\tdma_sync_sg_for_device(&data->master->dev, sg, num, DMA_FROM_DEVICE);\n\tdesc_rx->callback = pch_dma_rx_complete;\n\tdesc_rx->callback_param = data;\n\tdma->nent = num;\n\tdma->desc_rx = desc_rx;\n\n\t \n\tif (data->bpw_len > PCH_MAX_FIFO_DEPTH) {\n\t\thead = PCH_MAX_FIFO_DEPTH - PCH_DMA_TRANS_SIZE;\n\t\tif (data->bpw_len % PCH_DMA_TRANS_SIZE > 4) {\n\t\t\tnum = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;\n\t\t\trem = data->bpw_len % PCH_DMA_TRANS_SIZE - head;\n\t\t} else {\n\t\t\tnum = data->bpw_len / PCH_DMA_TRANS_SIZE;\n\t\t\trem = data->bpw_len % PCH_DMA_TRANS_SIZE +\n\t\t\t      PCH_DMA_TRANS_SIZE - head;\n\t\t}\n\t\tsize = PCH_DMA_TRANS_SIZE;\n\t} else {\n\t\tnum = 1;\n\t\tsize = data->bpw_len;\n\t\trem = data->bpw_len;\n\t\thead = 0;\n\t}\n\n\tdma->sg_tx_p = kmalloc_array(num, sizeof(*dma->sg_tx_p), GFP_ATOMIC);\n\tif (!dma->sg_tx_p)\n\t\treturn;\n\n\tsg_init_table(dma->sg_tx_p, num);  \n\t \n\tsg = dma->sg_tx_p;\n\tfor (i = 0; i < num; i++, sg++) {\n\t\tif (i == 0) {\n\t\t\tsg->offset = 0;\n\t\t\tsg_set_page(sg, virt_to_page(dma->tx_buf_virt), size + head,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = size + head;\n\t\t} else if (i == (num - 1)) {\n\t\t\tsg->offset = head + size * i;\n\t\t\tsg->offset = sg->offset * (*bpw / 8);\n\t\t\tsg_set_page(sg, virt_to_page(dma->tx_buf_virt), rem,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = rem;\n\t\t} else {\n\t\t\tsg->offset = head + size * i;\n\t\t\tsg->offset = sg->offset * (*bpw / 8);\n\t\t\tsg_set_page(sg, virt_to_page(dma->tx_buf_virt), size,\n\t\t\t\t    sg->offset);\n\t\t\tsg_dma_len(sg) = size;\n\t\t}\n\t\tsg_dma_address(sg) = dma->tx_buf_dma + sg->offset;\n\t}\n\tsg = dma->sg_tx_p;\n\tdesc_tx = dmaengine_prep_slave_sg(dma->chan_tx,\n\t\t\t\t\tsg, num, DMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tdev_err(&data->master->dev,\n\t\t\t\"%s:dmaengine_prep_slave_sg Failed\\n\", __func__);\n\t\treturn;\n\t}\n\tdma_sync_sg_for_device(&data->master->dev, sg, num, DMA_TO_DEVICE);\n\tdesc_tx->callback = NULL;\n\tdesc_tx->callback_param = data;\n\tdma->nent = num;\n\tdma->desc_tx = desc_tx;\n\n\tdev_dbg(&data->master->dev, \"%s:Pulling down SSN low - writing 0x2 to SSNXCR\\n\", __func__);\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tpch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);\n\tdesc_rx->tx_submit(desc_rx);\n\tdesc_tx->tx_submit(desc_tx);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tdata->transfer_complete = false;\n}\n\nstatic void pch_spi_process_messages(struct work_struct *pwork)\n{\n\tstruct spi_message *pmsg, *tmp;\n\tstruct pch_spi_data *data;\n\tint bpw;\n\n\tdata = container_of(pwork, struct pch_spi_data, work);\n\tdev_dbg(&data->master->dev, \"%s data initialized\\n\", __func__);\n\n\tspin_lock(&data->lock);\n\t \n\tif (data->board_dat->suspend_sts || (data->status == STATUS_EXITING)) {\n\t\tdev_dbg(&data->master->dev,\n\t\t\t\"%s suspend/remove initiated, flushing queue\\n\", __func__);\n\t\tlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\n\t\t\tpmsg->status = -EIO;\n\n\t\t\tif (pmsg->complete) {\n\t\t\t\tspin_unlock(&data->lock);\n\t\t\t\tpmsg->complete(pmsg->context);\n\t\t\t\tspin_lock(&data->lock);\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_del_init(&pmsg->queue);\n\t\t}\n\n\t\tspin_unlock(&data->lock);\n\t\treturn;\n\t}\n\n\tdata->bcurrent_msg_processing = true;\n\tdev_dbg(&data->master->dev,\n\t\t\"%s Set data->bcurrent_msg_processing= true\\n\", __func__);\n\n\t \n\tdata->current_msg = list_entry(data->queue.next, struct spi_message,\n\t\t\t\t\tqueue);\n\n\tlist_del_init(&data->current_msg->queue);\n\n\tdata->current_msg->status = 0;\n\n\tpch_spi_select_chip(data, data->current_msg->spi);\n\n\tspin_unlock(&data->lock);\n\n\tif (data->use_dma)\n\t\tpch_spi_request_dma(data,\n\t\t\t\t    data->current_msg->spi->bits_per_word);\n\tpch_spi_writereg(data->master, PCH_SSNXCR, SSN_NO_CONTROL);\n\tdo {\n\t\tint cnt;\n\t\t \n\t\tspin_lock(&data->lock);\n\t\tif (data->cur_trans == NULL) {\n\t\t\tdata->cur_trans =\n\t\t\t\tlist_entry(data->current_msg->transfers.next,\n\t\t\t\t\t   struct spi_transfer, transfer_list);\n\t\t\tdev_dbg(&data->master->dev,\n\t\t\t\t\"%s :Getting 1st transfer message\\n\",\n\t\t\t\t__func__);\n\t\t} else {\n\t\t\tdata->cur_trans =\n\t\t\t\tlist_entry(data->cur_trans->transfer_list.next,\n\t\t\t\t\t   struct spi_transfer, transfer_list);\n\t\t\tdev_dbg(&data->master->dev,\n\t\t\t\t\"%s :Getting next transfer message\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t\tspin_unlock(&data->lock);\n\n\t\tif (!data->cur_trans->len)\n\t\t\tgoto out;\n\t\tcnt = (data->cur_trans->len - 1) / PCH_BUF_SIZE + 1;\n\t\tdata->save_total_len = data->cur_trans->len;\n\t\tif (data->use_dma) {\n\t\t\tint i;\n\t\t\tchar *save_rx_buf = data->cur_trans->rx_buf;\n\n\t\t\tfor (i = 0; i < cnt; i++) {\n\t\t\t\tpch_spi_handle_dma(data, &bpw);\n\t\t\t\tif (!pch_spi_start_transfer(data)) {\n\t\t\t\t\tdata->transfer_complete = true;\n\t\t\t\t\tdata->current_msg->status = -EIO;\n\t\t\t\t\tdata->current_msg->complete\n\t\t\t\t\t\t   (data->current_msg->context);\n\t\t\t\t\tdata->bcurrent_msg_processing = false;\n\t\t\t\t\tdata->current_msg = NULL;\n\t\t\t\t\tdata->cur_trans = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tpch_spi_copy_rx_data_for_dma(data, bpw);\n\t\t\t}\n\t\t\tdata->cur_trans->rx_buf = save_rx_buf;\n\t\t} else {\n\t\t\tpch_spi_set_tx(data, &bpw);\n\t\t\tpch_spi_set_ir(data);\n\t\t\tpch_spi_copy_rx_data(data, bpw);\n\t\t\tkfree(data->pkt_rx_buff);\n\t\t\tdata->pkt_rx_buff = NULL;\n\t\t\tkfree(data->pkt_tx_buff);\n\t\t\tdata->pkt_tx_buff = NULL;\n\t\t}\n\t\t \n\t\tdata->cur_trans->len = data->save_total_len;\n\t\tdata->current_msg->actual_length += data->cur_trans->len;\n\n\t\tdev_dbg(&data->master->dev,\n\t\t\t\"%s:data->current_msg->actual_length=%d\\n\",\n\t\t\t__func__, data->current_msg->actual_length);\n\n\t\tspi_transfer_delay_exec(data->cur_trans);\n\n\t\tspin_lock(&data->lock);\n\n\t\t \n\t\tif ((data->cur_trans->transfer_list.next) ==\n\t\t    &(data->current_msg->transfers)) {\n\t\t\tpch_spi_nomore_transfer(data);\n\t\t}\n\n\t\tspin_unlock(&data->lock);\n\n\t} while (data->cur_trans != NULL);\n\nout:\n\tpch_spi_writereg(data->master, PCH_SSNXCR, SSN_HIGH);\n\tif (data->use_dma)\n\t\tpch_spi_release_dma(data);\n}\n\nstatic void pch_spi_free_resources(struct pch_spi_board_data *board_dat,\n\t\t\t\t   struct pch_spi_data *data)\n{\n\tdev_dbg(&board_dat->pdev->dev, \"%s ENTRY\\n\", __func__);\n\n\tflush_work(&data->work);\n}\n\nstatic int pch_spi_get_resources(struct pch_spi_board_data *board_dat,\n\t\t\t\t struct pch_spi_data *data)\n{\n\tdev_dbg(&board_dat->pdev->dev, \"%s ENTRY\\n\", __func__);\n\n\t \n\tpch_spi_reset(data->master);\n\tdev_dbg(&board_dat->pdev->dev,\n\t\t\"%s pch_spi_reset invoked successfully\\n\", __func__);\n\n\tdev_dbg(&board_dat->pdev->dev, \"%s data->irq_reg_sts=true\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic void pch_free_dma_buf(struct pch_spi_board_data *board_dat,\n\t\t\t     struct pch_spi_data *data)\n{\n\tstruct pch_spi_dma_ctrl *dma;\n\n\tdma = &data->dma;\n\tif (dma->tx_buf_dma)\n\t\tdma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,\n\t\t\t\t  dma->tx_buf_virt, dma->tx_buf_dma);\n\tif (dma->rx_buf_dma)\n\t\tdma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,\n\t\t\t\t  dma->rx_buf_virt, dma->rx_buf_dma);\n}\n\nstatic int pch_alloc_dma_buf(struct pch_spi_board_data *board_dat,\n\t\t\t      struct pch_spi_data *data)\n{\n\tstruct pch_spi_dma_ctrl *dma;\n\tint ret;\n\n\tdma = &data->dma;\n\tret = 0;\n\t \n\tdma->tx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,\n\t\t\t\tPCH_BUF_SIZE, &dma->tx_buf_dma, GFP_KERNEL);\n\tif (!dma->tx_buf_virt)\n\t\tret = -ENOMEM;\n\n\t \n\tdma->rx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,\n\t\t\t\tPCH_BUF_SIZE, &dma->rx_buf_dma, GFP_KERNEL);\n\tif (!dma->rx_buf_virt)\n\t\tret = -ENOMEM;\n\n\treturn ret;\n}\n\nstatic int pch_spi_pd_probe(struct platform_device *plat_dev)\n{\n\tint ret;\n\tstruct spi_master *master;\n\tstruct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);\n\tstruct pch_spi_data *data;\n\n\tdev_dbg(&plat_dev->dev, \"%s:debug\\n\", __func__);\n\n\tmaster = spi_alloc_master(&board_dat->pdev->dev,\n\t\t\t\t  sizeof(struct pch_spi_data));\n\tif (!master) {\n\t\tdev_err(&plat_dev->dev, \"spi_alloc_master[%d] failed.\\n\",\n\t\t\tplat_dev->id);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = spi_master_get_devdata(master);\n\tdata->master = master;\n\n\tplatform_set_drvdata(plat_dev, data);\n\n\t \n\tdata->io_base_addr = pci_resource_start(board_dat->pdev, 1) +\n\t\t\t\t\t PCH_ADDRESS_SIZE * plat_dev->id;\n\tdata->io_remap_addr = pci_iomap(board_dat->pdev, 1, 0);\n\tif (!data->io_remap_addr) {\n\t\tdev_err(&plat_dev->dev, \"%s pci_iomap failed\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_iomap;\n\t}\n\tdata->io_remap_addr += PCH_ADDRESS_SIZE * plat_dev->id;\n\n\tdev_dbg(&plat_dev->dev, \"[ch%d] remap_addr=%p\\n\",\n\t\tplat_dev->id, data->io_remap_addr);\n\n\t \n\tmaster->num_chipselect = PCH_MAX_CS;\n\tmaster->transfer = pch_spi_transfer;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n\tmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n\tmaster->max_speed_hz = PCH_MAX_BAUDRATE;\n\tmaster->flags = SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX;\n\n\tdata->board_dat = board_dat;\n\tdata->plat_dev = plat_dev;\n\tdata->n_curnt_chip = 255;\n\tdata->status = STATUS_RUNNING;\n\tdata->ch = plat_dev->id;\n\tdata->use_dma = use_dma;\n\n\tINIT_LIST_HEAD(&data->queue);\n\tspin_lock_init(&data->lock);\n\tINIT_WORK(&data->work, pch_spi_process_messages);\n\tinit_waitqueue_head(&data->wait);\n\n\tret = pch_spi_get_resources(board_dat, data);\n\tif (ret) {\n\t\tdev_err(&plat_dev->dev, \"%s fail(retval=%d)\\n\", __func__, ret);\n\t\tgoto err_spi_get_resources;\n\t}\n\n\tret = request_irq(board_dat->pdev->irq, pch_spi_handler,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, data);\n\tif (ret) {\n\t\tdev_err(&plat_dev->dev,\n\t\t\t\"%s request_irq failed\\n\", __func__);\n\t\tgoto err_request_irq;\n\t}\n\tdata->irq_reg_sts = true;\n\n\tpch_spi_set_master_mode(master);\n\n\tif (use_dma) {\n\t\tdev_info(&plat_dev->dev, \"Use DMA for data transfers\\n\");\n\t\tret = pch_alloc_dma_buf(board_dat, data);\n\t\tif (ret)\n\t\t\tgoto err_spi_register_master;\n\t}\n\n\tret = spi_register_master(master);\n\tif (ret != 0) {\n\t\tdev_err(&plat_dev->dev,\n\t\t\t\"%s spi_register_master FAILED\\n\", __func__);\n\t\tgoto err_spi_register_master;\n\t}\n\n\treturn 0;\n\nerr_spi_register_master:\n\tpch_free_dma_buf(board_dat, data);\n\tfree_irq(board_dat->pdev->irq, data);\nerr_request_irq:\n\tpch_spi_free_resources(board_dat, data);\nerr_spi_get_resources:\n\tpci_iounmap(board_dat->pdev, data->io_remap_addr);\nerr_pci_iomap:\n\tspi_master_put(master);\n\n\treturn ret;\n}\n\nstatic void pch_spi_pd_remove(struct platform_device *plat_dev)\n{\n\tstruct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);\n\tstruct pch_spi_data *data = platform_get_drvdata(plat_dev);\n\tint count;\n\tunsigned long flags;\n\n\tdev_dbg(&plat_dev->dev, \"%s:[ch%d] irq=%d\\n\",\n\t\t__func__, plat_dev->id, board_dat->pdev->irq);\n\n\tif (use_dma)\n\t\tpch_free_dma_buf(board_dat, data);\n\n\t \n\tcount = 500;\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status = STATUS_EXITING;\n\twhile ((list_empty(&data->queue) == 0) && --count) {\n\t\tdev_dbg(&board_dat->pdev->dev, \"%s :queue not empty\\n\",\n\t\t\t__func__);\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\tmsleep(PCH_SLEEP_TIME);\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tpch_spi_free_resources(board_dat, data);\n\t \n\tif (data->irq_reg_sts) {\n\t\t \n\t\tpch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);\n\t\tdata->irq_reg_sts = false;\n\t\tfree_irq(board_dat->pdev->irq, data);\n\t}\n\n\tpci_iounmap(board_dat->pdev, data->io_remap_addr);\n\tspi_unregister_master(data->master);\n}\n#ifdef CONFIG_PM\nstatic int pch_spi_pd_suspend(struct platform_device *pd_dev,\n\t\t\t      pm_message_t state)\n{\n\tu8 count;\n\tstruct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);\n\tstruct pch_spi_data *data = platform_get_drvdata(pd_dev);\n\n\tdev_dbg(&pd_dev->dev, \"%s ENTRY\\n\", __func__);\n\n\tif (!board_dat) {\n\t\tdev_err(&pd_dev->dev,\n\t\t\t\"%s pci_get_drvdata returned NULL\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tcount = 255;\n\twhile ((--count) > 0) {\n\t\tif (!(data->bcurrent_msg_processing))\n\t\t\tbreak;\n\t\tmsleep(PCH_SLEEP_TIME);\n\t}\n\n\t \n\tif (data->irq_reg_sts) {\n\t\t \n\t\tpch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);\n\t\tpch_spi_reset(data->master);\n\t\tfree_irq(board_dat->pdev->irq, data);\n\n\t\tdata->irq_reg_sts = false;\n\t\tdev_dbg(&pd_dev->dev,\n\t\t\t\"%s free_irq invoked successfully.\\n\", __func__);\n\t}\n\n\treturn 0;\n}\n\nstatic int pch_spi_pd_resume(struct platform_device *pd_dev)\n{\n\tstruct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);\n\tstruct pch_spi_data *data = platform_get_drvdata(pd_dev);\n\tint retval;\n\n\tif (!board_dat) {\n\t\tdev_err(&pd_dev->dev,\n\t\t\t\"%s pci_get_drvdata returned NULL\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!data->irq_reg_sts) {\n\t\t \n\t\tretval = request_irq(board_dat->pdev->irq, pch_spi_handler,\n\t\t\t\t     IRQF_SHARED, KBUILD_MODNAME, data);\n\t\tif (retval < 0) {\n\t\t\tdev_err(&pd_dev->dev,\n\t\t\t\t\"%s request_irq failed\\n\", __func__);\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\tpch_spi_reset(data->master);\n\t\tpch_spi_set_master_mode(data->master);\n\t\tdata->irq_reg_sts = true;\n\t}\n\treturn 0;\n}\n#else\n#define pch_spi_pd_suspend NULL\n#define pch_spi_pd_resume NULL\n#endif\n\nstatic struct platform_driver pch_spi_pd_driver = {\n\t.driver = {\n\t\t.name = \"pch-spi\",\n\t},\n\t.probe = pch_spi_pd_probe,\n\t.remove_new = pch_spi_pd_remove,\n\t.suspend = pch_spi_pd_suspend,\n\t.resume = pch_spi_pd_resume\n};\n\nstatic int pch_spi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct pch_spi_board_data *board_dat;\n\tstruct platform_device *pd_dev = NULL;\n\tint retval;\n\tint i;\n\tstruct pch_pd_dev_save *pd_dev_save;\n\n\tpd_dev_save = kzalloc(sizeof(*pd_dev_save), GFP_KERNEL);\n\tif (!pd_dev_save)\n\t\treturn -ENOMEM;\n\n\tboard_dat = kzalloc(sizeof(*board_dat), GFP_KERNEL);\n\tif (!board_dat) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_no_mem;\n\t}\n\n\tretval = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"%s request_region failed\\n\", __func__);\n\t\tgoto pci_request_regions;\n\t}\n\n\tboard_dat->pdev = pdev;\n\tboard_dat->num = id->driver_data;\n\tpd_dev_save->num = id->driver_data;\n\tpd_dev_save->board_dat = board_dat;\n\n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"%s pci_enable_device failed\\n\", __func__);\n\t\tgoto pci_enable_device;\n\t}\n\n\tfor (i = 0; i < board_dat->num; i++) {\n\t\tpd_dev = platform_device_alloc(\"pch-spi\", i);\n\t\tif (!pd_dev) {\n\t\t\tdev_err(&pdev->dev, \"platform_device_alloc failed\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_platform_device;\n\t\t}\n\t\tpd_dev_save->pd_save[i] = pd_dev;\n\t\tpd_dev->dev.parent = &pdev->dev;\n\n\t\tretval = platform_device_add_data(pd_dev, board_dat,\n\t\t\t\t\t\t  sizeof(*board_dat));\n\t\tif (retval) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"platform_device_add_data failed\\n\");\n\t\t\tplatform_device_put(pd_dev);\n\t\t\tgoto err_platform_device;\n\t\t}\n\n\t\tretval = platform_device_add(pd_dev);\n\t\tif (retval) {\n\t\t\tdev_err(&pdev->dev, \"platform_device_add failed\\n\");\n\t\t\tplatform_device_put(pd_dev);\n\t\t\tgoto err_platform_device;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, pd_dev_save);\n\n\treturn 0;\n\nerr_platform_device:\n\twhile (--i >= 0)\n\t\tplatform_device_unregister(pd_dev_save->pd_save[i]);\n\tpci_disable_device(pdev);\npci_enable_device:\n\tpci_release_regions(pdev);\npci_request_regions:\n\tkfree(board_dat);\nerr_no_mem:\n\tkfree(pd_dev_save);\n\n\treturn retval;\n}\n\nstatic void pch_spi_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct pch_pd_dev_save *pd_dev_save = pci_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s ENTRY:pdev=%p\\n\", __func__, pdev);\n\n\tfor (i = 0; i < pd_dev_save->num; i++)\n\t\tplatform_device_unregister(pd_dev_save->pd_save[i]);\n\n\tpci_disable_device(pdev);\n\tpci_release_regions(pdev);\n\tkfree(pd_dev_save->board_dat);\n\tkfree(pd_dev_save);\n}\n\nstatic int __maybe_unused pch_spi_suspend(struct device *dev)\n{\n\tstruct pch_pd_dev_save *pd_dev_save = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s ENTRY\\n\", __func__);\n\n\tpd_dev_save->board_dat->suspend_sts = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_spi_resume(struct device *dev)\n{\n\tstruct pch_pd_dev_save *pd_dev_save = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s ENTRY\\n\", __func__);\n\n\t \n\tpd_dev_save->board_dat->suspend_sts = false;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pch_spi_pm_ops, pch_spi_suspend, pch_spi_resume);\n\nstatic struct pci_driver pch_spi_pcidev_driver = {\n\t.name = \"pch_spi\",\n\t.id_table = pch_spi_pcidev_id,\n\t.probe = pch_spi_probe,\n\t.remove = pch_spi_remove,\n\t.driver.pm = &pch_spi_pm_ops,\n};\n\nstatic int __init pch_spi_init(void)\n{\n\tint ret;\n\tret = platform_driver_register(&pch_spi_pd_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_register_driver(&pch_spi_pcidev_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&pch_spi_pd_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(pch_spi_init);\n\nstatic void __exit pch_spi_exit(void)\n{\n\tpci_unregister_driver(&pch_spi_pcidev_driver);\n\tplatform_driver_unregister(&pch_spi_pd_driver);\n}\nmodule_exit(pch_spi_exit);\n\nmodule_param(use_dma, int, 0644);\nMODULE_PARM_DESC(use_dma,\n\t\t \"to use DMA for data transfers pass 1 else 0; default 1\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel EG20T PCH/LAPIS Semiconductor ML7xxx IOH SPI Driver\");\nMODULE_DEVICE_TABLE(pci, pch_spi_pcidev_id);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}