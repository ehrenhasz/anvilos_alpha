{
  "module_name": "hv_util.c",
  "hash_id": "f44335f87c633380b0ea4499a70baddc40d7ffbe887bb3702ab77392895cb4a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_util.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/reboot.h>\n#include <linux/hyperv.h>\n#include <linux/clockchips.h>\n#include <linux/ptp_clock_kernel.h>\n#include <asm/mshyperv.h>\n\n#include \"hyperv_vmbus.h\"\n\n#define SD_MAJOR\t3\n#define SD_MINOR\t0\n#define SD_MINOR_1\t1\n#define SD_MINOR_2\t2\n#define SD_VERSION_3_1\t(SD_MAJOR << 16 | SD_MINOR_1)\n#define SD_VERSION_3_2\t(SD_MAJOR << 16 | SD_MINOR_2)\n#define SD_VERSION\t(SD_MAJOR << 16 | SD_MINOR)\n\n#define SD_MAJOR_1\t1\n#define SD_VERSION_1\t(SD_MAJOR_1 << 16 | SD_MINOR)\n\n#define TS_MAJOR\t4\n#define TS_MINOR\t0\n#define TS_VERSION\t(TS_MAJOR << 16 | TS_MINOR)\n\n#define TS_MAJOR_1\t1\n#define TS_VERSION_1\t(TS_MAJOR_1 << 16 | TS_MINOR)\n\n#define TS_MAJOR_3\t3\n#define TS_VERSION_3\t(TS_MAJOR_3 << 16 | TS_MINOR)\n\n#define HB_MAJOR\t3\n#define HB_MINOR\t0\n#define HB_VERSION\t(HB_MAJOR << 16 | HB_MINOR)\n\n#define HB_MAJOR_1\t1\n#define HB_VERSION_1\t(HB_MAJOR_1 << 16 | HB_MINOR)\n\nstatic int sd_srv_version;\nstatic int ts_srv_version;\nstatic int hb_srv_version;\n\n#define SD_VER_COUNT 4\nstatic const int sd_versions[] = {\n\tSD_VERSION_3_2,\n\tSD_VERSION_3_1,\n\tSD_VERSION,\n\tSD_VERSION_1\n};\n\n#define TS_VER_COUNT 3\nstatic const int ts_versions[] = {\n\tTS_VERSION,\n\tTS_VERSION_3,\n\tTS_VERSION_1\n};\n\n#define HB_VER_COUNT 2\nstatic const int hb_versions[] = {\n\tHB_VERSION,\n\tHB_VERSION_1\n};\n\n#define FW_VER_COUNT 2\nstatic const int fw_versions[] = {\n\tUTIL_FW_VERSION,\n\tUTIL_WS2K8_FW_VERSION\n};\n\n \nstruct hibernate_work_context {\n\tstruct work_struct work;\n\tstruct hv_device *dev;\n};\n\nstatic struct hibernate_work_context hibernate_context;\nstatic bool hibernation_supported;\n\nstatic void send_hibernate_uevent(struct work_struct *work)\n{\n\tchar *uevent_env[2] = { \"EVENT=hibernate\", NULL };\n\tstruct hibernate_work_context *ctx;\n\n\tctx = container_of(work, struct hibernate_work_context, work);\n\n\tkobject_uevent_env(&ctx->dev->device.kobj, KOBJ_CHANGE, uevent_env);\n\n\tpr_info(\"Sent hibernation uevent\\n\");\n}\n\nstatic int hv_shutdown_init(struct hv_util_service *srv)\n{\n\tstruct vmbus_channel *channel = srv->channel;\n\n\tINIT_WORK(&hibernate_context.work, send_hibernate_uevent);\n\thibernate_context.dev = channel->device_obj;\n\n\thibernation_supported = hv_is_hibernation_supported();\n\n\treturn 0;\n}\n\nstatic void shutdown_onchannelcallback(void *context);\nstatic struct hv_util_service util_shutdown = {\n\t.util_cb = shutdown_onchannelcallback,\n\t.util_init = hv_shutdown_init,\n};\n\nstatic int hv_timesync_init(struct hv_util_service *srv);\nstatic int hv_timesync_pre_suspend(void);\nstatic void hv_timesync_deinit(void);\n\nstatic void timesync_onchannelcallback(void *context);\nstatic struct hv_util_service util_timesynch = {\n\t.util_cb = timesync_onchannelcallback,\n\t.util_init = hv_timesync_init,\n\t.util_pre_suspend = hv_timesync_pre_suspend,\n\t.util_deinit = hv_timesync_deinit,\n};\n\nstatic void heartbeat_onchannelcallback(void *context);\nstatic struct hv_util_service util_heartbeat = {\n\t.util_cb = heartbeat_onchannelcallback,\n};\n\nstatic struct hv_util_service util_kvp = {\n\t.util_cb = hv_kvp_onchannelcallback,\n\t.util_init = hv_kvp_init,\n\t.util_pre_suspend = hv_kvp_pre_suspend,\n\t.util_pre_resume = hv_kvp_pre_resume,\n\t.util_deinit = hv_kvp_deinit,\n};\n\nstatic struct hv_util_service util_vss = {\n\t.util_cb = hv_vss_onchannelcallback,\n\t.util_init = hv_vss_init,\n\t.util_pre_suspend = hv_vss_pre_suspend,\n\t.util_pre_resume = hv_vss_pre_resume,\n\t.util_deinit = hv_vss_deinit,\n};\n\nstatic struct hv_util_service util_fcopy = {\n\t.util_cb = hv_fcopy_onchannelcallback,\n\t.util_init = hv_fcopy_init,\n\t.util_pre_suspend = hv_fcopy_pre_suspend,\n\t.util_pre_resume = hv_fcopy_pre_resume,\n\t.util_deinit = hv_fcopy_deinit,\n};\n\nstatic void perform_shutdown(struct work_struct *dummy)\n{\n\torderly_poweroff(true);\n}\n\nstatic void perform_restart(struct work_struct *dummy)\n{\n\torderly_reboot();\n}\n\n \nstatic DECLARE_WORK(shutdown_work, perform_shutdown);\n\n \nstatic DECLARE_WORK(restart_work, perform_restart);\n\nstatic void shutdown_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tstruct work_struct *work = NULL;\n\tu32 recvlen;\n\tu64 requestid;\n\tu8  *shut_txf_buf = util_shutdown.recv_buffer;\n\n\tstruct shutdown_msg_data *shutdown_msg;\n\n\tstruct icmsg_hdr *icmsghdrp;\n\n\tif (vmbus_recvpacket(channel, shut_txf_buf, HV_HYP_PAGE_SIZE, &recvlen, &requestid)) {\n\t\tpr_err_ratelimited(\"Shutdown request received. Could not read into shut txf buf\\n\");\n\t\treturn;\n\t}\n\n\tif (!recvlen)\n\t\treturn;\n\n\t \n\tif (recvlen < ICMSG_HDR) {\n\t\tpr_err_ratelimited(\"Shutdown request received. Packet length too small: %d\\n\",\n\t\t\t\t   recvlen);\n\t\treturn;\n\t}\n\n\ticmsghdrp = (struct icmsg_hdr *)&shut_txf_buf[sizeof(struct vmbuspipe_hdr)];\n\n\tif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\tif (vmbus_prep_negotiate_resp(icmsghdrp,\n\t\t\t\tshut_txf_buf, recvlen,\n\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\tsd_versions, SD_VER_COUNT,\n\t\t\t\tNULL, &sd_srv_version)) {\n\t\t\tpr_info(\"Shutdown IC version %d.%d\\n\",\n\t\t\t\tsd_srv_version >> 16,\n\t\t\t\tsd_srv_version & 0xFFFF);\n\t\t}\n\t} else if (icmsghdrp->icmsgtype == ICMSGTYPE_SHUTDOWN) {\n\t\t \n\t\tif (recvlen < ICMSG_HDR + sizeof(struct shutdown_msg_data)) {\n\t\t\tpr_err_ratelimited(\"Invalid shutdown msg data. Packet length too small: %u\\n\",\n\t\t\t\t\t   recvlen);\n\t\t\treturn;\n\t\t}\n\n\t\tshutdown_msg = (struct shutdown_msg_data *)&shut_txf_buf[ICMSG_HDR];\n\n\t\t \n\t\tswitch (shutdown_msg->flags) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\ticmsghdrp->status = HV_S_OK;\n\t\t\twork = &shutdown_work;\n\t\t\tpr_info(\"Shutdown request received - graceful shutdown initiated\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\ticmsghdrp->status = HV_S_OK;\n\t\t\twork = &restart_work;\n\t\t\tpr_info(\"Restart request received - graceful restart initiated\\n\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tpr_info(\"Hibernation request received\\n\");\n\t\t\ticmsghdrp->status = hibernation_supported ?\n\t\t\t\tHV_S_OK : HV_E_FAIL;\n\t\t\tif (hibernation_supported)\n\t\t\t\twork = &hibernate_context.work;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\t\t\tpr_info(\"Shutdown request received - Invalid request\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tpr_err_ratelimited(\"Shutdown request received. Invalid msg type: %d\\n\",\n\t\t\t\t   icmsghdrp->icmsgtype);\n\t}\n\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\n\t\t| ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, shut_txf_buf,\n\t\t\t recvlen, requestid,\n\t\t\t VM_PKT_DATA_INBAND, 0);\n\n\tif (work)\n\t\tschedule_work(work);\n}\n\n \nstatic struct work_struct adj_time_work;\n\n \nstatic struct {\n\tu64\t\t\t\thost_time;\n\tu64\t\t\t\tref_time;\n\tspinlock_t\t\t\tlock;\n} host_ts;\n\nstatic inline u64 reftime_to_ns(u64 reftime)\n{\n\treturn (reftime - WLTIMEDELTA) * 100;\n}\n\n \nstatic const u64 HOST_TIMESYNC_DELAY_THRESH = 600 * (u64)NSEC_PER_SEC;\n\nstatic int hv_get_adj_host_time(struct timespec64 *ts)\n{\n\tu64 newtime, reftime, timediff_adj;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&host_ts.lock, flags);\n\treftime = hv_read_reference_counter();\n\n\t \n\ttimediff_adj = reftime - host_ts.ref_time;\n\tif (timediff_adj * 100 > HOST_TIMESYNC_DELAY_THRESH) {\n\t\tpr_warn_once(\"TIMESYNC IC: Stale time stamp, %llu nsecs old\\n\",\n\t\t\t     (timediff_adj * 100));\n\t\tret = -ESTALE;\n\t}\n\n\tnewtime = host_ts.host_time + timediff_adj;\n\t*ts = ns_to_timespec64(reftime_to_ns(newtime));\n\tspin_unlock_irqrestore(&host_ts.lock, flags);\n\n\treturn ret;\n}\n\nstatic void hv_set_host_time(struct work_struct *work)\n{\n\n\tstruct timespec64 ts;\n\n\tif (!hv_get_adj_host_time(&ts))\n\t\tdo_settimeofday64(&ts);\n}\n\n \nstatic inline void adj_guesttime(u64 hosttime, u64 reftime, u8 adj_flags)\n{\n\tunsigned long flags;\n\tu64 cur_reftime;\n\n\t \n\tspin_lock_irqsave(&host_ts.lock, flags);\n\n\tcur_reftime = hv_read_reference_counter();\n\thost_ts.host_time = hosttime;\n\thost_ts.ref_time = cur_reftime;\n\n\t \n\thost_ts.host_time += (cur_reftime - reftime);\n\n\tspin_unlock_irqrestore(&host_ts.lock, flags);\n\n\t \n\tif (adj_flags & ICTIMESYNCFLAG_SYNC)\n\t\tschedule_work(&adj_time_work);\n}\n\n \nstatic void timesync_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tu32 recvlen;\n\tu64 requestid;\n\tstruct icmsg_hdr *icmsghdrp;\n\tstruct ictimesync_data *timedatap;\n\tstruct ictimesync_ref_data *refdata;\n\tu8 *time_txf_buf = util_timesynch.recv_buffer;\n\n\t \n\twhile (1) {\n\t\tint ret = vmbus_recvpacket(channel, time_txf_buf,\n\t\t\t\t\t   HV_HYP_PAGE_SIZE, &recvlen,\n\t\t\t\t\t   &requestid);\n\t\tif (ret) {\n\t\t\tpr_err_ratelimited(\"TimeSync IC pkt recv failed (Err: %d)\\n\",\n\t\t\t\t\t   ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!recvlen)\n\t\t\tbreak;\n\n\t\t \n\t\tif (recvlen < ICMSG_HDR) {\n\t\t\tpr_err_ratelimited(\"Timesync request received. Packet length too small: %d\\n\",\n\t\t\t\t\t   recvlen);\n\t\t\tbreak;\n\t\t}\n\n\t\ticmsghdrp = (struct icmsg_hdr *)&time_txf_buf[\n\t\t\t\tsizeof(struct vmbuspipe_hdr)];\n\n\t\tif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\t\tif (vmbus_prep_negotiate_resp(icmsghdrp,\n\t\t\t\t\t\ttime_txf_buf, recvlen,\n\t\t\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\t\t\tts_versions, TS_VER_COUNT,\n\t\t\t\t\t\tNULL, &ts_srv_version)) {\n\t\t\t\tpr_info(\"TimeSync IC version %d.%d\\n\",\n\t\t\t\t\tts_srv_version >> 16,\n\t\t\t\t\tts_srv_version & 0xFFFF);\n\t\t\t}\n\t\t} else if (icmsghdrp->icmsgtype == ICMSGTYPE_TIMESYNC) {\n\t\t\tif (ts_srv_version > TS_VERSION_3) {\n\t\t\t\t \n\t\t\t\tif (recvlen < ICMSG_HDR + sizeof(struct ictimesync_ref_data)) {\n\t\t\t\t\tpr_err_ratelimited(\"Invalid ictimesync ref data. Length too small: %u\\n\",\n\t\t\t\t\t\t\t   recvlen);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trefdata = (struct ictimesync_ref_data *)&time_txf_buf[ICMSG_HDR];\n\n\t\t\t\tadj_guesttime(refdata->parenttime,\n\t\t\t\t\t\trefdata->vmreferencetime,\n\t\t\t\t\t\trefdata->flags);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (recvlen < ICMSG_HDR + sizeof(struct ictimesync_data)) {\n\t\t\t\t\tpr_err_ratelimited(\"Invalid ictimesync data. Length too small: %u\\n\",\n\t\t\t\t\t\t\t   recvlen);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttimedatap = (struct ictimesync_data *)&time_txf_buf[ICMSG_HDR];\n\n\t\t\t\tadj_guesttime(timedatap->parenttime,\n\t\t\t\t\t      hv_read_reference_counter(),\n\t\t\t\t\t      timedatap->flags);\n\t\t\t}\n\t\t} else {\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\t\t\tpr_err_ratelimited(\"Timesync request received. Invalid msg type: %d\\n\",\n\t\t\t\t\t   icmsghdrp->icmsgtype);\n\t\t}\n\n\t\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\n\t\t\t| ICMSGHDRFLAG_RESPONSE;\n\n\t\tvmbus_sendpacket(channel, time_txf_buf,\n\t\t\t\t recvlen, requestid,\n\t\t\t\t VM_PKT_DATA_INBAND, 0);\n\t}\n}\n\n \nstatic void heartbeat_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tu32 recvlen;\n\tu64 requestid;\n\tstruct icmsg_hdr *icmsghdrp;\n\tstruct heartbeat_msg_data *heartbeat_msg;\n\tu8 *hbeat_txf_buf = util_heartbeat.recv_buffer;\n\n\twhile (1) {\n\n\t\tif (vmbus_recvpacket(channel, hbeat_txf_buf, HV_HYP_PAGE_SIZE,\n\t\t\t\t     &recvlen, &requestid)) {\n\t\t\tpr_err_ratelimited(\"Heartbeat request received. Could not read into hbeat txf buf\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!recvlen)\n\t\t\tbreak;\n\n\t\t \n\t\tif (recvlen < ICMSG_HDR) {\n\t\t\tpr_err_ratelimited(\"Heartbeat request received. Packet length too small: %d\\n\",\n\t\t\t\t\t   recvlen);\n\t\t\tbreak;\n\t\t}\n\n\t\ticmsghdrp = (struct icmsg_hdr *)&hbeat_txf_buf[\n\t\t\t\tsizeof(struct vmbuspipe_hdr)];\n\n\t\tif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\t\tif (vmbus_prep_negotiate_resp(icmsghdrp,\n\t\t\t\t\thbeat_txf_buf, recvlen,\n\t\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\t\thb_versions, HB_VER_COUNT,\n\t\t\t\t\tNULL, &hb_srv_version)) {\n\n\t\t\t\tpr_info(\"Heartbeat IC version %d.%d\\n\",\n\t\t\t\t\thb_srv_version >> 16,\n\t\t\t\t\thb_srv_version & 0xFFFF);\n\t\t\t}\n\t\t} else if (icmsghdrp->icmsgtype == ICMSGTYPE_HEARTBEAT) {\n\t\t\t \n\t\t\tif (recvlen < ICMSG_HDR + sizeof(u64)) {\n\t\t\t\tpr_err_ratelimited(\"Invalid heartbeat msg data. Length too small: %u\\n\",\n\t\t\t\t\t\t   recvlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\theartbeat_msg = (struct heartbeat_msg_data *)&hbeat_txf_buf[ICMSG_HDR];\n\n\t\t\theartbeat_msg->seq_num += 1;\n\t\t} else {\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\t\t\tpr_err_ratelimited(\"Heartbeat request received. Invalid msg type: %d\\n\",\n\t\t\t\t\t   icmsghdrp->icmsgtype);\n\t\t}\n\n\t\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\n\t\t\t| ICMSGHDRFLAG_RESPONSE;\n\n\t\tvmbus_sendpacket(channel, hbeat_txf_buf,\n\t\t\t\t recvlen, requestid,\n\t\t\t\t VM_PKT_DATA_INBAND, 0);\n\t}\n}\n\n#define HV_UTIL_RING_SEND_SIZE VMBUS_RING_SIZE(3 * HV_HYP_PAGE_SIZE)\n#define HV_UTIL_RING_RECV_SIZE VMBUS_RING_SIZE(3 * HV_HYP_PAGE_SIZE)\n\nstatic int util_probe(struct hv_device *dev,\n\t\t\tconst struct hv_vmbus_device_id *dev_id)\n{\n\tstruct hv_util_service *srv =\n\t\t(struct hv_util_service *)dev_id->driver_data;\n\tint ret;\n\n\tsrv->recv_buffer = kmalloc(HV_HYP_PAGE_SIZE * 4, GFP_KERNEL);\n\tif (!srv->recv_buffer)\n\t\treturn -ENOMEM;\n\tsrv->channel = dev->channel;\n\tif (srv->util_init) {\n\t\tret = srv->util_init(srv);\n\t\tif (ret) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto error1;\n\t\t}\n\t}\n\n\t \n\tset_channel_read_mode(dev->channel, HV_CALL_DIRECT);\n\n\thv_set_drvdata(dev, srv);\n\n\tret = vmbus_open(dev->channel, HV_UTIL_RING_SEND_SIZE,\n\t\t\t HV_UTIL_RING_RECV_SIZE, NULL, 0, srv->util_cb,\n\t\t\t dev->channel);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tif (srv->util_deinit)\n\t\tsrv->util_deinit();\nerror1:\n\tkfree(srv->recv_buffer);\n\treturn ret;\n}\n\nstatic void util_remove(struct hv_device *dev)\n{\n\tstruct hv_util_service *srv = hv_get_drvdata(dev);\n\n\tif (srv->util_deinit)\n\t\tsrv->util_deinit();\n\tvmbus_close(dev->channel);\n\tkfree(srv->recv_buffer);\n}\n\n \nstatic int util_suspend(struct hv_device *dev)\n{\n\tstruct hv_util_service *srv = hv_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (srv->util_pre_suspend) {\n\t\tret = srv->util_pre_suspend();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvmbus_close(dev->channel);\n\n\treturn 0;\n}\n\nstatic int util_resume(struct hv_device *dev)\n{\n\tstruct hv_util_service *srv = hv_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (srv->util_pre_resume) {\n\t\tret = srv->util_pre_resume();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = vmbus_open(dev->channel, HV_UTIL_RING_SEND_SIZE,\n\t\t\t HV_UTIL_RING_RECV_SIZE, NULL, 0, srv->util_cb,\n\t\t\t dev->channel);\n\treturn ret;\n}\n\nstatic const struct hv_vmbus_device_id id_table[] = {\n\t \n\t{ HV_SHUTDOWN_GUID,\n\t  .driver_data = (unsigned long)&util_shutdown\n\t},\n\t \n\t{ HV_TS_GUID,\n\t  .driver_data = (unsigned long)&util_timesynch\n\t},\n\t \n\t{ HV_HEART_BEAT_GUID,\n\t  .driver_data = (unsigned long)&util_heartbeat\n\t},\n\t \n\t{ HV_KVP_GUID,\n\t  .driver_data = (unsigned long)&util_kvp\n\t},\n\t \n\t{ HV_VSS_GUID,\n\t  .driver_data = (unsigned long)&util_vss\n\t},\n\t \n\t{ HV_FCOPY_GUID,\n\t  .driver_data = (unsigned long)&util_fcopy\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(vmbus, id_table);\n\n \nstatic  struct hv_driver util_drv = {\n\t.name = \"hv_utils\",\n\t.id_table = id_table,\n\t.probe =  util_probe,\n\t.remove =  util_remove,\n\t.suspend = util_suspend,\n\t.resume =  util_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int hv_ptp_enable(struct ptp_clock_info *info,\n\t\t\t struct ptp_clock_request *request, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hv_ptp_settime(struct ptp_clock_info *p, const struct timespec64 *ts)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hv_ptp_adjfine(struct ptp_clock_info *ptp, long delta)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic int hv_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hv_ptp_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\treturn hv_get_adj_host_time(ts);\n}\n\nstatic struct ptp_clock_info ptp_hyperv_info = {\n\t.name\t\t= \"hyperv\",\n\t.enable         = hv_ptp_enable,\n\t.adjtime        = hv_ptp_adjtime,\n\t.adjfine        = hv_ptp_adjfine,\n\t.gettime64      = hv_ptp_gettime,\n\t.settime64      = hv_ptp_settime,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct ptp_clock *hv_ptp_clock;\n\nstatic int hv_timesync_init(struct hv_util_service *srv)\n{\n\tspin_lock_init(&host_ts.lock);\n\n\tINIT_WORK(&adj_time_work, hv_set_host_time);\n\n\t \n\thv_ptp_clock = ptp_clock_register(&ptp_hyperv_info, NULL);\n\tif (IS_ERR_OR_NULL(hv_ptp_clock)) {\n\t\tpr_err(\"cannot register PTP clock: %d\\n\",\n\t\t       PTR_ERR_OR_ZERO(hv_ptp_clock));\n\t\thv_ptp_clock = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hv_timesync_cancel_work(void)\n{\n\tcancel_work_sync(&adj_time_work);\n}\n\nstatic int hv_timesync_pre_suspend(void)\n{\n\thv_timesync_cancel_work();\n\treturn 0;\n}\n\nstatic void hv_timesync_deinit(void)\n{\n\tif (hv_ptp_clock)\n\t\tptp_clock_unregister(hv_ptp_clock);\n\n\thv_timesync_cancel_work();\n}\n\nstatic int __init init_hyperv_utils(void)\n{\n\tpr_info(\"Registering HyperV Utility Driver\\n\");\n\n\treturn vmbus_driver_register(&util_drv);\n}\n\nstatic void exit_hyperv_utils(void)\n{\n\tpr_info(\"De-Registered HyperV Utility Driver\\n\");\n\n\tvmbus_driver_unregister(&util_drv);\n}\n\nmodule_init(init_hyperv_utils);\nmodule_exit(exit_hyperv_utils);\n\nMODULE_DESCRIPTION(\"Hyper-V Utilities\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}