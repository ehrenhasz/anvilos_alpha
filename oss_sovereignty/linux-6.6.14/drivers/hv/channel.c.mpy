{
  "module_name": "channel.c",
  "hash_id": "0f8064b2d423d16384c6ee4ffc8ff1059d46ae19ebc59a9e9ff1aecd4e036d0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/channel.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/hyperv.h>\n#include <linux/uio.h>\n#include <linux/interrupt.h>\n#include <linux/set_memory.h>\n#include <asm/page.h>\n#include <asm/mshyperv.h>\n\n#include \"hyperv_vmbus.h\"\n\n \nstatic inline u32 hv_gpadl_size(enum hv_gpadl_type type, u32 size)\n{\n\tswitch (type) {\n\tcase HV_GPADL_BUFFER:\n\t\treturn size;\n\tcase HV_GPADL_RING:\n\t\t \n\t\tBUG_ON(size % PAGE_SIZE);\n\t\t \n\t\treturn size - 2 * (PAGE_SIZE - HV_HYP_PAGE_SIZE);\n\t}\n\tBUG();\n\treturn 0;\n}\n\n \nstatic inline u32 hv_ring_gpadl_send_hvpgoffset(u32 offset)\n{\n\n\t \n\treturn (offset - (PAGE_SIZE - HV_HYP_PAGE_SIZE)) >> HV_HYP_PAGE_SHIFT;\n}\n\n \nstatic inline u64 hv_gpadl_hvpfn(enum hv_gpadl_type type, void *kbuffer,\n\t\t\t\t u32 size, u32 send_offset, int i)\n{\n\tint send_idx = hv_ring_gpadl_send_hvpgoffset(send_offset);\n\tunsigned long delta = 0UL;\n\n\tswitch (type) {\n\tcase HV_GPADL_BUFFER:\n\t\tbreak;\n\tcase HV_GPADL_RING:\n\t\tif (i == 0)\n\t\t\tdelta = 0;\n\t\telse if (i <= send_idx)\n\t\t\tdelta = PAGE_SIZE - HV_HYP_PAGE_SIZE;\n\t\telse\n\t\t\tdelta = 2 * (PAGE_SIZE - HV_HYP_PAGE_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn virt_to_hvpfn(kbuffer + delta + (HV_HYP_PAGE_SIZE * i));\n}\n\n \nvoid vmbus_setevent(struct vmbus_channel *channel)\n{\n\tstruct hv_monitor_page *monitorpage;\n\n\ttrace_vmbus_setevent(channel);\n\n\t \n\tif (channel->offermsg.monitor_allocated && !channel->low_latency) {\n\t\tvmbus_send_interrupt(channel->offermsg.child_relid);\n\n\t\t \n\t\tmonitorpage = vmbus_connection.monitor_pages[1];\n\n\t\tsync_set_bit(channel->monitor_bit,\n\t\t\t(unsigned long *)&monitorpage->trigger_group\n\t\t\t\t\t[channel->monitor_grp].pending);\n\n\t} else {\n\t\tvmbus_set_event(channel);\n\t}\n}\nEXPORT_SYMBOL_GPL(vmbus_setevent);\n\n \nvoid vmbus_free_ring(struct vmbus_channel *channel)\n{\n\thv_ringbuffer_cleanup(&channel->outbound);\n\thv_ringbuffer_cleanup(&channel->inbound);\n\n\tif (channel->ringbuffer_page) {\n\t\t__free_pages(channel->ringbuffer_page,\n\t\t\t     get_order(channel->ringbuffer_pagecount\n\t\t\t\t       << PAGE_SHIFT));\n\t\tchannel->ringbuffer_page = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(vmbus_free_ring);\n\n \nint vmbus_alloc_ring(struct vmbus_channel *newchannel,\n\t\t     u32 send_size, u32 recv_size)\n{\n\tstruct page *page;\n\tint order;\n\n\tif (send_size % PAGE_SIZE || recv_size % PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\torder = get_order(send_size + recv_size);\n\tpage = alloc_pages_node(cpu_to_node(newchannel->target_cpu),\n\t\t\t\tGFP_KERNEL|__GFP_ZERO, order);\n\n\tif (!page)\n\t\tpage = alloc_pages(GFP_KERNEL|__GFP_ZERO, order);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tnewchannel->ringbuffer_page = page;\n\tnewchannel->ringbuffer_pagecount = (send_size + recv_size) >> PAGE_SHIFT;\n\tnewchannel->ringbuffer_send_offset = send_size >> PAGE_SHIFT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vmbus_alloc_ring);\n\n \nint vmbus_send_tl_connect_request(const guid_t *shv_guest_servie_id,\n\t\t\t\t  const guid_t *shv_host_servie_id)\n{\n\tstruct vmbus_channel_tl_connect_request conn_msg;\n\tint ret;\n\n\tmemset(&conn_msg, 0, sizeof(conn_msg));\n\tconn_msg.header.msgtype = CHANNELMSG_TL_CONNECT_REQUEST;\n\tconn_msg.guest_endpoint_id = *shv_guest_servie_id;\n\tconn_msg.host_service_id = *shv_host_servie_id;\n\n\tret = vmbus_post_msg(&conn_msg, sizeof(conn_msg), true);\n\n\ttrace_vmbus_send_tl_connect_request(&conn_msg, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vmbus_send_tl_connect_request);\n\nstatic int send_modifychannel_without_ack(struct vmbus_channel *channel, u32 target_vp)\n{\n\tstruct vmbus_channel_modifychannel msg;\n\tint ret;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.header.msgtype = CHANNELMSG_MODIFYCHANNEL;\n\tmsg.child_relid = channel->offermsg.child_relid;\n\tmsg.target_vp = target_vp;\n\n\tret = vmbus_post_msg(&msg, sizeof(msg), true);\n\ttrace_vmbus_send_modifychannel(&msg, ret);\n\n\treturn ret;\n}\n\nstatic int send_modifychannel_with_ack(struct vmbus_channel *channel, u32 target_vp)\n{\n\tstruct vmbus_channel_modifychannel *msg;\n\tstruct vmbus_channel_msginfo *info;\n\tunsigned long flags;\n\tint ret;\n\n\tinfo = kzalloc(sizeof(struct vmbus_channel_msginfo) +\n\t\t\t\tsizeof(struct vmbus_channel_modifychannel),\n\t\t       GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&info->waitevent);\n\tinfo->waiting_channel = channel;\n\n\tmsg = (struct vmbus_channel_modifychannel *)info->msg;\n\tmsg->header.msgtype = CHANNELMSG_MODIFYCHANNEL;\n\tmsg->child_relid = channel->offermsg.child_relid;\n\tmsg->target_vp = target_vp;\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&info->msglistentry, &vmbus_connection.chn_msg_list);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tret = vmbus_post_msg(msg, sizeof(*msg), true);\n\ttrace_vmbus_send_modifychannel(msg, ret);\n\tif (ret != 0) {\n\t\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\t\tlist_del(&info->msglistentry);\n\t\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\t\tgoto free_info;\n\t}\n\n\t \n\tmutex_unlock(&vmbus_connection.channel_mutex);\n\twait_for_completion(&info->waitevent);\n\tmutex_lock(&vmbus_connection.channel_mutex);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (info->response.modify_response.status)\n\t\tret = -EAGAIN;\n\nfree_info:\n\tkfree(info);\n\treturn ret;\n}\n\n \nint vmbus_send_modifychannel(struct vmbus_channel *channel, u32 target_vp)\n{\n\tif (vmbus_proto_version >= VERSION_WIN10_V5_3)\n\t\treturn send_modifychannel_with_ack(channel, target_vp);\n\treturn send_modifychannel_without_ack(channel, target_vp);\n}\nEXPORT_SYMBOL_GPL(vmbus_send_modifychannel);\n\n \nstatic int create_gpadl_header(enum hv_gpadl_type type, void *kbuffer,\n\t\t\t       u32 size, u32 send_offset,\n\t\t\t       struct vmbus_channel_msginfo **msginfo)\n{\n\tint i;\n\tint pagecount;\n\tstruct vmbus_channel_gpadl_header *gpadl_header;\n\tstruct vmbus_channel_gpadl_body *gpadl_body;\n\tstruct vmbus_channel_msginfo *msgheader;\n\tstruct vmbus_channel_msginfo *msgbody = NULL;\n\tu32 msgsize;\n\n\tint pfnsum, pfncount, pfnleft, pfncurr, pfnsize;\n\n\tpagecount = hv_gpadl_size(type, size) >> HV_HYP_PAGE_SHIFT;\n\n\t \n\tpfnsize = MAX_SIZE_CHANNEL_MESSAGE -\n\t\t  sizeof(struct vmbus_channel_gpadl_header) -\n\t\t  sizeof(struct gpa_range);\n\tpfncount = pfnsize / sizeof(u64);\n\n\tif (pagecount > pfncount) {\n\t\t \n\t\t \n\t\tmsgsize = sizeof(struct vmbus_channel_msginfo) +\n\t\t\t  sizeof(struct vmbus_channel_gpadl_header) +\n\t\t\t  sizeof(struct gpa_range) + pfncount * sizeof(u64);\n\t\tmsgheader =  kzalloc(msgsize, GFP_KERNEL);\n\t\tif (!msgheader)\n\t\t\tgoto nomem;\n\n\t\tINIT_LIST_HEAD(&msgheader->submsglist);\n\t\tmsgheader->msgsize = msgsize;\n\n\t\tgpadl_header = (struct vmbus_channel_gpadl_header *)\n\t\t\tmsgheader->msg;\n\t\tgpadl_header->rangecount = 1;\n\t\tgpadl_header->range_buflen = sizeof(struct gpa_range) +\n\t\t\t\t\t pagecount * sizeof(u64);\n\t\tgpadl_header->range[0].byte_offset = 0;\n\t\tgpadl_header->range[0].byte_count = hv_gpadl_size(type, size);\n\t\tfor (i = 0; i < pfncount; i++)\n\t\t\tgpadl_header->range[0].pfn_array[i] = hv_gpadl_hvpfn(\n\t\t\t\ttype, kbuffer, size, send_offset, i);\n\t\t*msginfo = msgheader;\n\n\t\tpfnsum = pfncount;\n\t\tpfnleft = pagecount - pfncount;\n\n\t\t \n\t\tpfnsize = MAX_SIZE_CHANNEL_MESSAGE -\n\t\t\t  sizeof(struct vmbus_channel_gpadl_body);\n\t\tpfncount = pfnsize / sizeof(u64);\n\n\t\t \n\t\twhile (pfnleft) {\n\t\t\tif (pfnleft > pfncount)\n\t\t\t\tpfncurr = pfncount;\n\t\t\telse\n\t\t\t\tpfncurr = pfnleft;\n\n\t\t\tmsgsize = sizeof(struct vmbus_channel_msginfo) +\n\t\t\t\t  sizeof(struct vmbus_channel_gpadl_body) +\n\t\t\t\t  pfncurr * sizeof(u64);\n\t\t\tmsgbody = kzalloc(msgsize, GFP_KERNEL);\n\n\t\t\tif (!msgbody) {\n\t\t\t\tstruct vmbus_channel_msginfo *pos = NULL;\n\t\t\t\tstruct vmbus_channel_msginfo *tmp = NULL;\n\t\t\t\t \n\t\t\t\tlist_for_each_entry_safe(pos, tmp,\n\t\t\t\t\t&msgheader->submsglist,\n\t\t\t\t\tmsglistentry) {\n\n\t\t\t\t\tlist_del(&pos->msglistentry);\n\t\t\t\t\tkfree(pos);\n\t\t\t\t}\n\n\t\t\t\tgoto nomem;\n\t\t\t}\n\n\t\t\tmsgbody->msgsize = msgsize;\n\t\t\tgpadl_body =\n\t\t\t\t(struct vmbus_channel_gpadl_body *)msgbody->msg;\n\n\t\t\t \n\t\t\tfor (i = 0; i < pfncurr; i++)\n\t\t\t\tgpadl_body->pfn[i] = hv_gpadl_hvpfn(type,\n\t\t\t\t\tkbuffer, size, send_offset, pfnsum + i);\n\n\t\t\t \n\t\t\tlist_add_tail(&msgbody->msglistentry,\n\t\t\t\t      &msgheader->submsglist);\n\t\t\tpfnsum += pfncurr;\n\t\t\tpfnleft -= pfncurr;\n\t\t}\n\t} else {\n\t\t \n\t\tmsgsize = sizeof(struct vmbus_channel_msginfo) +\n\t\t\t  sizeof(struct vmbus_channel_gpadl_header) +\n\t\t\t  sizeof(struct gpa_range) + pagecount * sizeof(u64);\n\t\tmsgheader = kzalloc(msgsize, GFP_KERNEL);\n\t\tif (msgheader == NULL)\n\t\t\tgoto nomem;\n\n\t\tINIT_LIST_HEAD(&msgheader->submsglist);\n\t\tmsgheader->msgsize = msgsize;\n\n\t\tgpadl_header = (struct vmbus_channel_gpadl_header *)\n\t\t\tmsgheader->msg;\n\t\tgpadl_header->rangecount = 1;\n\t\tgpadl_header->range_buflen = sizeof(struct gpa_range) +\n\t\t\t\t\t pagecount * sizeof(u64);\n\t\tgpadl_header->range[0].byte_offset = 0;\n\t\tgpadl_header->range[0].byte_count = hv_gpadl_size(type, size);\n\t\tfor (i = 0; i < pagecount; i++)\n\t\t\tgpadl_header->range[0].pfn_array[i] = hv_gpadl_hvpfn(\n\t\t\t\ttype, kbuffer, size, send_offset, i);\n\n\t\t*msginfo = msgheader;\n\t}\n\n\treturn 0;\nnomem:\n\tkfree(msgheader);\n\tkfree(msgbody);\n\treturn -ENOMEM;\n}\n\n \nstatic int __vmbus_establish_gpadl(struct vmbus_channel *channel,\n\t\t\t\t   enum hv_gpadl_type type, void *kbuffer,\n\t\t\t\t   u32 size, u32 send_offset,\n\t\t\t\t   struct vmbus_gpadl *gpadl)\n{\n\tstruct vmbus_channel_gpadl_header *gpadlmsg;\n\tstruct vmbus_channel_gpadl_body *gpadl_body;\n\tstruct vmbus_channel_msginfo *msginfo = NULL;\n\tstruct vmbus_channel_msginfo *submsginfo, *tmp;\n\tstruct list_head *curr;\n\tu32 next_gpadl_handle;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tnext_gpadl_handle =\n\t\t(atomic_inc_return(&vmbus_connection.next_gpadl_handle) - 1);\n\n\tret = create_gpadl_header(type, kbuffer, size, send_offset, &msginfo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = set_memory_decrypted((unsigned long)kbuffer,\n\t\t\t\t   PFN_UP(size));\n\tif (ret) {\n\t\tdev_warn(&channel->device_obj->device,\n\t\t\t \"Failed to set host visibility for new GPADL %d.\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&msginfo->waitevent);\n\tmsginfo->waiting_channel = channel;\n\n\tgpadlmsg = (struct vmbus_channel_gpadl_header *)msginfo->msg;\n\tgpadlmsg->header.msgtype = CHANNELMSG_GPADL_HEADER;\n\tgpadlmsg->child_relid = channel->offermsg.child_relid;\n\tgpadlmsg->gpadl = next_gpadl_handle;\n\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&msginfo->msglistentry,\n\t\t      &vmbus_connection.chn_msg_list);\n\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (channel->rescind) {\n\t\tret = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\n\tret = vmbus_post_msg(gpadlmsg, msginfo->msgsize -\n\t\t\t     sizeof(*msginfo), true);\n\n\ttrace_vmbus_establish_gpadl_header(gpadlmsg, ret);\n\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\tlist_for_each(curr, &msginfo->submsglist) {\n\t\tsubmsginfo = (struct vmbus_channel_msginfo *)curr;\n\t\tgpadl_body =\n\t\t\t(struct vmbus_channel_gpadl_body *)submsginfo->msg;\n\n\t\tgpadl_body->header.msgtype =\n\t\t\tCHANNELMSG_GPADL_BODY;\n\t\tgpadl_body->gpadl = next_gpadl_handle;\n\n\t\tret = vmbus_post_msg(gpadl_body,\n\t\t\t\t     submsginfo->msgsize - sizeof(*submsginfo),\n\t\t\t\t     true);\n\n\t\ttrace_vmbus_establish_gpadl_body(gpadl_body, ret);\n\n\t\tif (ret != 0)\n\t\t\tgoto cleanup;\n\n\t}\n\twait_for_completion(&msginfo->waitevent);\n\n\tif (msginfo->response.gpadl_created.creation_status != 0) {\n\t\tpr_err(\"Failed to establish GPADL: err = 0x%x\\n\",\n\t\t       msginfo->response.gpadl_created.creation_status);\n\n\t\tret = -EDQUOT;\n\t\tgoto cleanup;\n\t}\n\n\tif (channel->rescind) {\n\t\tret = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tgpadl->gpadl_handle = gpadlmsg->gpadl;\n\tgpadl->buffer = kbuffer;\n\tgpadl->size = size;\n\n\ncleanup:\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&msginfo->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\tlist_for_each_entry_safe(submsginfo, tmp, &msginfo->submsglist,\n\t\t\t\t msglistentry) {\n\t\tkfree(submsginfo);\n\t}\n\n\tkfree(msginfo);\n\n\tif (ret)\n\t\tset_memory_encrypted((unsigned long)kbuffer,\n\t\t\t\t     PFN_UP(size));\n\n\treturn ret;\n}\n\n \nint vmbus_establish_gpadl(struct vmbus_channel *channel, void *kbuffer,\n\t\t\t  u32 size, struct vmbus_gpadl *gpadl)\n{\n\treturn __vmbus_establish_gpadl(channel, HV_GPADL_BUFFER, kbuffer, size,\n\t\t\t\t       0U, gpadl);\n}\nEXPORT_SYMBOL_GPL(vmbus_establish_gpadl);\n\n \nstatic u64 *request_arr_init(u32 size)\n{\n\tint i;\n\tu64 *req_arr;\n\n\treq_arr = kcalloc(size, sizeof(u64), GFP_KERNEL);\n\tif (!req_arr)\n\t\treturn NULL;\n\n\tfor (i = 0; i < size - 1; i++)\n\t\treq_arr[i] = i + 1;\n\n\t \n\treq_arr[i] = U64_MAX;\n\n\treturn req_arr;\n}\n\n \nstatic int vmbus_alloc_requestor(struct vmbus_requestor *rqstor, u32 size)\n{\n\tu64 *rqst_arr;\n\tunsigned long *bitmap;\n\n\trqst_arr = request_arr_init(size);\n\tif (!rqst_arr)\n\t\treturn -ENOMEM;\n\n\tbitmap = bitmap_zalloc(size, GFP_KERNEL);\n\tif (!bitmap) {\n\t\tkfree(rqst_arr);\n\t\treturn -ENOMEM;\n\t}\n\n\trqstor->req_arr = rqst_arr;\n\trqstor->req_bitmap = bitmap;\n\trqstor->size = size;\n\trqstor->next_request_id = 0;\n\tspin_lock_init(&rqstor->req_lock);\n\n\treturn 0;\n}\n\n \nstatic void vmbus_free_requestor(struct vmbus_requestor *rqstor)\n{\n\tkfree(rqstor->req_arr);\n\tbitmap_free(rqstor->req_bitmap);\n}\n\nstatic int __vmbus_open(struct vmbus_channel *newchannel,\n\t\t       void *userdata, u32 userdatalen,\n\t\t       void (*onchannelcallback)(void *context), void *context)\n{\n\tstruct vmbus_channel_open_channel *open_msg;\n\tstruct vmbus_channel_msginfo *open_info = NULL;\n\tstruct page *page = newchannel->ringbuffer_page;\n\tu32 send_pages, recv_pages;\n\tunsigned long flags;\n\tint err;\n\n\tif (userdatalen > MAX_USER_DEFINED_BYTES)\n\t\treturn -EINVAL;\n\n\tsend_pages = newchannel->ringbuffer_send_offset;\n\trecv_pages = newchannel->ringbuffer_pagecount - send_pages;\n\n\tif (newchannel->state != CHANNEL_OPEN_STATE)\n\t\treturn -EINVAL;\n\n\t \n\tif (newchannel->rqstor_size) {\n\t\tif (vmbus_alloc_requestor(&newchannel->requestor, newchannel->rqstor_size))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnewchannel->state = CHANNEL_OPENING_STATE;\n\tnewchannel->onchannel_callback = onchannelcallback;\n\tnewchannel->channel_callback_context = context;\n\n\tif (!newchannel->max_pkt_size)\n\t\tnewchannel->max_pkt_size = VMBUS_DEFAULT_MAX_PKT_SIZE;\n\n\t \n\tnewchannel->ringbuffer_gpadlhandle.gpadl_handle = 0;\n\n\terr = __vmbus_establish_gpadl(newchannel, HV_GPADL_RING,\n\t\t\t\t      page_address(newchannel->ringbuffer_page),\n\t\t\t\t      (send_pages + recv_pages) << PAGE_SHIFT,\n\t\t\t\t      newchannel->ringbuffer_send_offset << PAGE_SHIFT,\n\t\t\t\t      &newchannel->ringbuffer_gpadlhandle);\n\tif (err)\n\t\tgoto error_clean_ring;\n\n\terr = hv_ringbuffer_init(&newchannel->outbound,\n\t\t\t\t page, send_pages, 0);\n\tif (err)\n\t\tgoto error_free_gpadl;\n\n\terr = hv_ringbuffer_init(&newchannel->inbound, &page[send_pages],\n\t\t\t\t recv_pages, newchannel->max_pkt_size);\n\tif (err)\n\t\tgoto error_free_gpadl;\n\n\t \n\topen_info = kzalloc(sizeof(*open_info) +\n\t\t\t   sizeof(struct vmbus_channel_open_channel),\n\t\t\t   GFP_KERNEL);\n\tif (!open_info) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_gpadl;\n\t}\n\n\tinit_completion(&open_info->waitevent);\n\topen_info->waiting_channel = newchannel;\n\n\topen_msg = (struct vmbus_channel_open_channel *)open_info->msg;\n\topen_msg->header.msgtype = CHANNELMSG_OPENCHANNEL;\n\topen_msg->openid = newchannel->offermsg.child_relid;\n\topen_msg->child_relid = newchannel->offermsg.child_relid;\n\topen_msg->ringbuffer_gpadlhandle\n\t\t= newchannel->ringbuffer_gpadlhandle.gpadl_handle;\n\t \n\topen_msg->downstream_ringbuffer_pageoffset =\n\t\thv_ring_gpadl_send_hvpgoffset(send_pages << PAGE_SHIFT);\n\topen_msg->target_vp = hv_cpu_number_to_vp_number(newchannel->target_cpu);\n\n\tif (userdatalen)\n\t\tmemcpy(open_msg->userdata, userdata, userdatalen);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&open_info->msglistentry,\n\t\t      &vmbus_connection.chn_msg_list);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (newchannel->rescind) {\n\t\terr = -ENODEV;\n\t\tgoto error_clean_msglist;\n\t}\n\n\terr = vmbus_post_msg(open_msg,\n\t\t\t     sizeof(struct vmbus_channel_open_channel), true);\n\n\ttrace_vmbus_open(open_msg, err);\n\n\tif (err != 0)\n\t\tgoto error_clean_msglist;\n\n\twait_for_completion(&open_info->waitevent);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&open_info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (newchannel->rescind) {\n\t\terr = -ENODEV;\n\t\tgoto error_free_info;\n\t}\n\n\tif (open_info->response.open_result.status) {\n\t\terr = -EAGAIN;\n\t\tgoto error_free_info;\n\t}\n\n\tnewchannel->state = CHANNEL_OPENED_STATE;\n\tkfree(open_info);\n\treturn 0;\n\nerror_clean_msglist:\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&open_info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\nerror_free_info:\n\tkfree(open_info);\nerror_free_gpadl:\n\tvmbus_teardown_gpadl(newchannel, &newchannel->ringbuffer_gpadlhandle);\nerror_clean_ring:\n\thv_ringbuffer_cleanup(&newchannel->outbound);\n\thv_ringbuffer_cleanup(&newchannel->inbound);\n\tvmbus_free_requestor(&newchannel->requestor);\n\tnewchannel->state = CHANNEL_OPEN_STATE;\n\treturn err;\n}\n\n \nint vmbus_connect_ring(struct vmbus_channel *newchannel,\n\t\t       void (*onchannelcallback)(void *context), void *context)\n{\n\treturn  __vmbus_open(newchannel, NULL, 0, onchannelcallback, context);\n}\nEXPORT_SYMBOL_GPL(vmbus_connect_ring);\n\n \nint vmbus_open(struct vmbus_channel *newchannel,\n\t       u32 send_ringbuffer_size, u32 recv_ringbuffer_size,\n\t       void *userdata, u32 userdatalen,\n\t       void (*onchannelcallback)(void *context), void *context)\n{\n\tint err;\n\n\terr = vmbus_alloc_ring(newchannel, send_ringbuffer_size,\n\t\t\t       recv_ringbuffer_size);\n\tif (err)\n\t\treturn err;\n\n\terr = __vmbus_open(newchannel, userdata, userdatalen,\n\t\t\t   onchannelcallback, context);\n\tif (err)\n\t\tvmbus_free_ring(newchannel);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vmbus_open);\n\n \nint vmbus_teardown_gpadl(struct vmbus_channel *channel, struct vmbus_gpadl *gpadl)\n{\n\tstruct vmbus_channel_gpadl_teardown *msg;\n\tstruct vmbus_channel_msginfo *info;\n\tunsigned long flags;\n\tint ret;\n\n\tinfo = kzalloc(sizeof(*info) +\n\t\t       sizeof(struct vmbus_channel_gpadl_teardown), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&info->waitevent);\n\tinfo->waiting_channel = channel;\n\n\tmsg = (struct vmbus_channel_gpadl_teardown *)info->msg;\n\n\tmsg->header.msgtype = CHANNELMSG_GPADL_TEARDOWN;\n\tmsg->child_relid = channel->offermsg.child_relid;\n\tmsg->gpadl = gpadl->gpadl_handle;\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&info->msglistentry,\n\t\t      &vmbus_connection.chn_msg_list);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (channel->rescind)\n\t\tgoto post_msg_err;\n\n\tret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_gpadl_teardown),\n\t\t\t     true);\n\n\ttrace_vmbus_teardown_gpadl(msg, ret);\n\n\tif (ret)\n\t\tgoto post_msg_err;\n\n\twait_for_completion(&info->waitevent);\n\n\tgpadl->gpadl_handle = 0;\n\npost_msg_err:\n\t \n\tif (channel->rescind)\n\t\tret = 0;\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tkfree(info);\n\n\tret = set_memory_encrypted((unsigned long)gpadl->buffer,\n\t\t\t\t   PFN_UP(gpadl->size));\n\tif (ret)\n\t\tpr_warn(\"Fail to set mem host visibility in GPADL teardown %d.\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vmbus_teardown_gpadl);\n\nvoid vmbus_reset_channel_cb(struct vmbus_channel *channel)\n{\n\tunsigned long flags;\n\n\t \n\ttasklet_disable(&channel->callback_event);\n\n\t \n\tspin_lock_irqsave(&channel->sched_lock, flags);\n\tchannel->onchannel_callback = NULL;\n\tspin_unlock_irqrestore(&channel->sched_lock, flags);\n\n\tchannel->sc_creation_callback = NULL;\n\n\t \n\ttasklet_enable(&channel->callback_event);\n}\n\nstatic int vmbus_close_internal(struct vmbus_channel *channel)\n{\n\tstruct vmbus_channel_close_channel *msg;\n\tint ret;\n\n\tvmbus_reset_channel_cb(channel);\n\n\t \n\tif (channel->state != CHANNEL_OPENED_STATE)\n\t\treturn -EINVAL;\n\n\tchannel->state = CHANNEL_OPEN_STATE;\n\n\t \n\n\tmsg = &channel->close_msg.msg;\n\n\tmsg->header.msgtype = CHANNELMSG_CLOSECHANNEL;\n\tmsg->child_relid = channel->offermsg.child_relid;\n\n\tret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel),\n\t\t\t     true);\n\n\ttrace_vmbus_close_internal(msg, ret);\n\n\tif (ret) {\n\t\tpr_err(\"Close failed: close post msg return is %d\\n\", ret);\n\t\t \n\t}\n\n\t \n\telse if (channel->ringbuffer_gpadlhandle.gpadl_handle) {\n\t\tret = vmbus_teardown_gpadl(channel, &channel->ringbuffer_gpadlhandle);\n\t\tif (ret) {\n\t\t\tpr_err(\"Close failed: teardown gpadl return %d\\n\", ret);\n\t\t\t \n\t\t}\n\t}\n\n\tif (!ret)\n\t\tvmbus_free_requestor(&channel->requestor);\n\n\treturn ret;\n}\n\n \nint vmbus_disconnect_ring(struct vmbus_channel *channel)\n{\n\tstruct vmbus_channel *cur_channel, *tmp;\n\tint ret;\n\n\tif (channel->primary_channel != NULL)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe(cur_channel, tmp, &channel->sc_list, sc_list) {\n\t\tif (cur_channel->rescind)\n\t\t\twait_for_completion(&cur_channel->rescind_event);\n\n\t\tmutex_lock(&vmbus_connection.channel_mutex);\n\t\tif (vmbus_close_internal(cur_channel) == 0) {\n\t\t\tvmbus_free_ring(cur_channel);\n\n\t\t\tif (cur_channel->rescind)\n\t\t\t\thv_process_channel_removal(cur_channel);\n\t\t}\n\t\tmutex_unlock(&vmbus_connection.channel_mutex);\n\t}\n\n\t \n\tmutex_lock(&vmbus_connection.channel_mutex);\n\tret = vmbus_close_internal(channel);\n\tmutex_unlock(&vmbus_connection.channel_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vmbus_disconnect_ring);\n\n \nvoid vmbus_close(struct vmbus_channel *channel)\n{\n\tif (vmbus_disconnect_ring(channel) == 0)\n\t\tvmbus_free_ring(channel);\n}\nEXPORT_SYMBOL_GPL(vmbus_close);\n\n \nint vmbus_sendpacket_getid(struct vmbus_channel *channel, void *buffer,\n\t\t\t   u32 bufferlen, u64 requestid, u64 *trans_id,\n\t\t\t   enum vmbus_packet_type type, u32 flags)\n{\n\tstruct vmpacket_descriptor desc;\n\tu32 packetlen = sizeof(struct vmpacket_descriptor) + bufferlen;\n\tu32 packetlen_aligned = ALIGN(packetlen, sizeof(u64));\n\tstruct kvec bufferlist[3];\n\tu64 aligned_data = 0;\n\tint num_vecs = ((bufferlen != 0) ? 3 : 1);\n\n\n\t \n\tdesc.type = type;  \n\tdesc.flags = flags;  \n\t \n\tdesc.offset8 = sizeof(struct vmpacket_descriptor) >> 3;\n\tdesc.len8 = (u16)(packetlen_aligned >> 3);\n\tdesc.trans_id = VMBUS_RQST_ERROR;  \n\n\tbufferlist[0].iov_base = &desc;\n\tbufferlist[0].iov_len = sizeof(struct vmpacket_descriptor);\n\tbufferlist[1].iov_base = buffer;\n\tbufferlist[1].iov_len = bufferlen;\n\tbufferlist[2].iov_base = &aligned_data;\n\tbufferlist[2].iov_len = (packetlen_aligned - packetlen);\n\n\treturn hv_ringbuffer_write(channel, bufferlist, num_vecs, requestid, trans_id);\n}\nEXPORT_SYMBOL(vmbus_sendpacket_getid);\n\n \nint vmbus_sendpacket(struct vmbus_channel *channel, void *buffer,\n\t\t     u32 bufferlen, u64 requestid,\n\t\t     enum vmbus_packet_type type, u32 flags)\n{\n\treturn vmbus_sendpacket_getid(channel, buffer, bufferlen,\n\t\t\t\t      requestid, NULL, type, flags);\n}\nEXPORT_SYMBOL(vmbus_sendpacket);\n\n \nint vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,\n\t\t\t\tstruct hv_page_buffer pagebuffers[],\n\t\t\t\tu32 pagecount, void *buffer, u32 bufferlen,\n\t\t\t\tu64 requestid)\n{\n\tint i;\n\tstruct vmbus_channel_packet_page_buffer desc;\n\tu32 descsize;\n\tu32 packetlen;\n\tu32 packetlen_aligned;\n\tstruct kvec bufferlist[3];\n\tu64 aligned_data = 0;\n\n\tif (pagecount > MAX_PAGE_BUFFER_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tdescsize = sizeof(struct vmbus_channel_packet_page_buffer) -\n\t\t\t  ((MAX_PAGE_BUFFER_COUNT - pagecount) *\n\t\t\t  sizeof(struct hv_page_buffer));\n\tpacketlen = descsize + bufferlen;\n\tpacketlen_aligned = ALIGN(packetlen, sizeof(u64));\n\n\t \n\tdesc.type = VM_PKT_DATA_USING_GPA_DIRECT;\n\tdesc.flags = VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED;\n\tdesc.dataoffset8 = descsize >> 3;  \n\tdesc.length8 = (u16)(packetlen_aligned >> 3);\n\tdesc.transactionid = VMBUS_RQST_ERROR;  \n\tdesc.reserved = 0;\n\tdesc.rangecount = pagecount;\n\n\tfor (i = 0; i < pagecount; i++) {\n\t\tdesc.range[i].len = pagebuffers[i].len;\n\t\tdesc.range[i].offset = pagebuffers[i].offset;\n\t\tdesc.range[i].pfn\t = pagebuffers[i].pfn;\n\t}\n\n\tbufferlist[0].iov_base = &desc;\n\tbufferlist[0].iov_len = descsize;\n\tbufferlist[1].iov_base = buffer;\n\tbufferlist[1].iov_len = bufferlen;\n\tbufferlist[2].iov_base = &aligned_data;\n\tbufferlist[2].iov_len = (packetlen_aligned - packetlen);\n\n\treturn hv_ringbuffer_write(channel, bufferlist, 3, requestid, NULL);\n}\nEXPORT_SYMBOL_GPL(vmbus_sendpacket_pagebuffer);\n\n \nint vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,\n\t\t\t      struct vmbus_packet_mpb_array *desc,\n\t\t\t      u32 desc_size,\n\t\t\t      void *buffer, u32 bufferlen, u64 requestid)\n{\n\tu32 packetlen;\n\tu32 packetlen_aligned;\n\tstruct kvec bufferlist[3];\n\tu64 aligned_data = 0;\n\n\tpacketlen = desc_size + bufferlen;\n\tpacketlen_aligned = ALIGN(packetlen, sizeof(u64));\n\n\t \n\tdesc->type = VM_PKT_DATA_USING_GPA_DIRECT;\n\tdesc->flags = VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED;\n\tdesc->dataoffset8 = desc_size >> 3;  \n\tdesc->length8 = (u16)(packetlen_aligned >> 3);\n\tdesc->transactionid = VMBUS_RQST_ERROR;  \n\tdesc->reserved = 0;\n\tdesc->rangecount = 1;\n\n\tbufferlist[0].iov_base = desc;\n\tbufferlist[0].iov_len = desc_size;\n\tbufferlist[1].iov_base = buffer;\n\tbufferlist[1].iov_len = bufferlen;\n\tbufferlist[2].iov_base = &aligned_data;\n\tbufferlist[2].iov_len = (packetlen_aligned - packetlen);\n\n\treturn hv_ringbuffer_write(channel, bufferlist, 3, requestid, NULL);\n}\nEXPORT_SYMBOL_GPL(vmbus_sendpacket_mpb_desc);\n\n \nstatic inline int\n__vmbus_recvpacket(struct vmbus_channel *channel, void *buffer,\n\t\t   u32 bufferlen, u32 *buffer_actual_len, u64 *requestid,\n\t\t   bool raw)\n{\n\treturn hv_ringbuffer_read(channel, buffer, bufferlen,\n\t\t\t\t  buffer_actual_len, requestid, raw);\n\n}\n\nint vmbus_recvpacket(struct vmbus_channel *channel, void *buffer,\n\t\t     u32 bufferlen, u32 *buffer_actual_len,\n\t\t     u64 *requestid)\n{\n\treturn __vmbus_recvpacket(channel, buffer, bufferlen,\n\t\t\t\t  buffer_actual_len, requestid, false);\n}\nEXPORT_SYMBOL(vmbus_recvpacket);\n\n \nint vmbus_recvpacket_raw(struct vmbus_channel *channel, void *buffer,\n\t\t\t      u32 bufferlen, u32 *buffer_actual_len,\n\t\t\t      u64 *requestid)\n{\n\treturn __vmbus_recvpacket(channel, buffer, bufferlen,\n\t\t\t\t  buffer_actual_len, requestid, true);\n}\nEXPORT_SYMBOL_GPL(vmbus_recvpacket_raw);\n\n \nu64 vmbus_next_request_id(struct vmbus_channel *channel, u64 rqst_addr)\n{\n\tstruct vmbus_requestor *rqstor = &channel->requestor;\n\tunsigned long flags;\n\tu64 current_id;\n\n\t \n\tif (!channel->rqstor_size)\n\t\treturn VMBUS_NO_RQSTOR;\n\n\tlock_requestor(channel, flags);\n\tcurrent_id = rqstor->next_request_id;\n\n\t \n\tif (current_id >= rqstor->size) {\n\t\tunlock_requestor(channel, flags);\n\t\treturn VMBUS_RQST_ERROR;\n\t}\n\n\trqstor->next_request_id = rqstor->req_arr[current_id];\n\trqstor->req_arr[current_id] = rqst_addr;\n\n\t \n\tbitmap_set(rqstor->req_bitmap, current_id, 1);\n\n\tunlock_requestor(channel, flags);\n\n\t \n\treturn current_id + 1;\n}\nEXPORT_SYMBOL_GPL(vmbus_next_request_id);\n\n \nu64 __vmbus_request_addr_match(struct vmbus_channel *channel, u64 trans_id,\n\t\t\t       u64 rqst_addr)\n{\n\tstruct vmbus_requestor *rqstor = &channel->requestor;\n\tu64 req_addr;\n\n\t \n\tif (!channel->rqstor_size)\n\t\treturn VMBUS_NO_RQSTOR;\n\n\t \n\tif (!trans_id)\n\t\treturn VMBUS_RQST_ERROR;\n\n\t \n\ttrans_id--;\n\n\t \n\tif (trans_id >= rqstor->size || !test_bit(trans_id, rqstor->req_bitmap))\n\t\treturn VMBUS_RQST_ERROR;\n\n\treq_addr = rqstor->req_arr[trans_id];\n\tif (rqst_addr == VMBUS_RQST_ADDR_ANY || req_addr == rqst_addr) {\n\t\trqstor->req_arr[trans_id] = rqstor->next_request_id;\n\t\trqstor->next_request_id = trans_id;\n\n\t\t \n\t\tbitmap_clear(rqstor->req_bitmap, trans_id, 1);\n\t}\n\n\treturn req_addr;\n}\nEXPORT_SYMBOL_GPL(__vmbus_request_addr_match);\n\n \nu64 vmbus_request_addr_match(struct vmbus_channel *channel, u64 trans_id,\n\t\t\t     u64 rqst_addr)\n{\n\tunsigned long flags;\n\tu64 req_addr;\n\n\tlock_requestor(channel, flags);\n\treq_addr = __vmbus_request_addr_match(channel, trans_id, rqst_addr);\n\tunlock_requestor(channel, flags);\n\n\treturn req_addr;\n}\nEXPORT_SYMBOL_GPL(vmbus_request_addr_match);\n\n \nu64 vmbus_request_addr(struct vmbus_channel *channel, u64 trans_id)\n{\n\treturn vmbus_request_addr_match(channel, trans_id, VMBUS_RQST_ADDR_ANY);\n}\nEXPORT_SYMBOL_GPL(vmbus_request_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}