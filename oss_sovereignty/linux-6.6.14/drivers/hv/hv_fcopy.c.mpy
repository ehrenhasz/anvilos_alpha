{
  "module_name": "hv_fcopy.c",
  "hash_id": "4c3a427472fcf8b22f9fa8366b610ce4d32e07f47b06def619639f8b505e9241",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_fcopy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/nls.h>\n#include <linux/workqueue.h>\n#include <linux/hyperv.h>\n#include <linux/sched.h>\n#include <asm/hyperv-tlfs.h>\n\n#include \"hyperv_vmbus.h\"\n#include \"hv_utils_transport.h\"\n\n#define WIN8_SRV_MAJOR\t\t1\n#define WIN8_SRV_MINOR\t\t1\n#define WIN8_SRV_VERSION\t(WIN8_SRV_MAJOR << 16 | WIN8_SRV_MINOR)\n\n#define FCOPY_VER_COUNT 1\nstatic const int fcopy_versions[] = {\n\tWIN8_SRV_VERSION\n};\n\n#define FW_VER_COUNT 1\nstatic const int fw_versions[] = {\n\tUTIL_FW_VERSION\n};\n\n \n\nstatic struct {\n\tint state;    \n\tint recv_len;  \n\tstruct hv_fcopy_hdr  *fcopy_msg;  \n\tstruct vmbus_channel *recv_channel;  \n\tu64 recv_req_id;  \n} fcopy_transaction;\n\nstatic void fcopy_respond_to_host(int error);\nstatic void fcopy_send_data(struct work_struct *dummy);\nstatic void fcopy_timeout_func(struct work_struct *dummy);\nstatic DECLARE_DELAYED_WORK(fcopy_timeout_work, fcopy_timeout_func);\nstatic DECLARE_WORK(fcopy_send_work, fcopy_send_data);\nstatic const char fcopy_devname[] = \"vmbus/hv_fcopy\";\nstatic u8 *recv_buffer;\nstatic struct hvutil_transport *hvt;\n \nstatic int dm_reg_value;\n\nstatic void fcopy_poll_wrapper(void *channel)\n{\n\t \n\tfcopy_transaction.state = HVUTIL_READY;\n\ttasklet_schedule(&((struct vmbus_channel *)channel)->callback_event);\n}\n\nstatic void fcopy_timeout_func(struct work_struct *dummy)\n{\n\t \n\tfcopy_respond_to_host(HV_E_FAIL);\n\thv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);\n}\n\nstatic void fcopy_register_done(void)\n{\n\tpr_debug(\"FCP: userspace daemon registered\\n\");\n\thv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);\n}\n\nstatic int fcopy_handle_handshake(u32 version)\n{\n\tu32 our_ver = FCOPY_CURRENT_VERSION;\n\n\tswitch (version) {\n\tcase FCOPY_VERSION_0:\n\t\t \n\t\tdm_reg_value = version;\n\t\tbreak;\n\tcase FCOPY_VERSION_1:\n\t\t \n\t\tif (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver),\n\t\t    fcopy_register_done))\n\t\t\treturn -EFAULT;\n\t\tdm_reg_value = version;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"FCP: userspace daemon ver. %d connected\\n\", version);\n\treturn 0;\n}\n\nstatic void fcopy_send_data(struct work_struct *dummy)\n{\n\tstruct hv_start_fcopy *smsg_out = NULL;\n\tint operation = fcopy_transaction.fcopy_msg->operation;\n\tstruct hv_start_fcopy *smsg_in;\n\tvoid *out_src;\n\tint rc, out_len;\n\n\t \n\n\tswitch (operation) {\n\tcase START_FILE_COPY:\n\t\tout_len = sizeof(struct hv_start_fcopy);\n\t\tsmsg_out = kzalloc(sizeof(*smsg_out), GFP_KERNEL);\n\t\tif (!smsg_out)\n\t\t\treturn;\n\n\t\tsmsg_out->hdr.operation = operation;\n\t\tsmsg_in = (struct hv_start_fcopy *)fcopy_transaction.fcopy_msg;\n\n\t\tutf16s_to_utf8s((wchar_t *)smsg_in->file_name, W_MAX_PATH,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)&smsg_out->file_name, W_MAX_PATH - 1);\n\n\t\tutf16s_to_utf8s((wchar_t *)smsg_in->path_name, W_MAX_PATH,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)&smsg_out->path_name, W_MAX_PATH - 1);\n\n\t\tsmsg_out->copy_flags = smsg_in->copy_flags;\n\t\tsmsg_out->file_size = smsg_in->file_size;\n\t\tout_src = smsg_out;\n\t\tbreak;\n\n\tcase WRITE_TO_FILE:\n\t\tout_src = fcopy_transaction.fcopy_msg;\n\t\tout_len = sizeof(struct hv_do_fcopy);\n\t\tbreak;\n\tdefault:\n\t\tout_src = fcopy_transaction.fcopy_msg;\n\t\tout_len = fcopy_transaction.recv_len;\n\t\tbreak;\n\t}\n\n\tfcopy_transaction.state = HVUTIL_USERSPACE_REQ;\n\trc = hvutil_transport_send(hvt, out_src, out_len, NULL);\n\tif (rc) {\n\t\tpr_debug(\"FCP: failed to communicate to the daemon: %d\\n\", rc);\n\t\tif (cancel_delayed_work_sync(&fcopy_timeout_work)) {\n\t\t\tfcopy_respond_to_host(HV_E_FAIL);\n\t\t\tfcopy_transaction.state = HVUTIL_READY;\n\t\t}\n\t}\n\tkfree(smsg_out);\n}\n\n \n\nstatic void\nfcopy_respond_to_host(int error)\n{\n\tstruct icmsg_hdr *icmsghdr;\n\tu32 buf_len;\n\tstruct vmbus_channel *channel;\n\tu64 req_id;\n\n\t \n\n\tbuf_len = fcopy_transaction.recv_len;\n\tchannel = fcopy_transaction.recv_channel;\n\treq_id = fcopy_transaction.recv_req_id;\n\n\ticmsghdr = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (channel->onchannel_callback == NULL)\n\t\t \n\t\treturn;\n\n\ticmsghdr->status = error;\n\ticmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}\n\nvoid hv_fcopy_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tu32 recvlen;\n\tu64 requestid;\n\tstruct hv_fcopy_hdr *fcopy_msg;\n\tstruct icmsg_hdr *icmsghdr;\n\tint fcopy_srv_version;\n\n\tif (fcopy_transaction.state > HVUTIL_READY)\n\t\treturn;\n\n\tif (vmbus_recvpacket(channel, recv_buffer, HV_HYP_PAGE_SIZE * 2, &recvlen, &requestid)) {\n\t\tpr_err_ratelimited(\"Fcopy request received. Could not read into recv buf\\n\");\n\t\treturn;\n\t}\n\n\tif (!recvlen)\n\t\treturn;\n\n\t \n\tif (recvlen < ICMSG_HDR) {\n\t\tpr_err_ratelimited(\"Fcopy request received. Packet length too small: %d\\n\",\n\t\t\t\t   recvlen);\n\t\treturn;\n\t}\n\n\ticmsghdr = (struct icmsg_hdr *)&recv_buffer[\n\t\t\tsizeof(struct vmbuspipe_hdr)];\n\n\tif (icmsghdr->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\tif (vmbus_prep_negotiate_resp(icmsghdr,\n\t\t\t\trecv_buffer, recvlen,\n\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\tfcopy_versions, FCOPY_VER_COUNT,\n\t\t\t\tNULL, &fcopy_srv_version)) {\n\n\t\t\tpr_info(\"FCopy IC version %d.%d\\n\",\n\t\t\t\tfcopy_srv_version >> 16,\n\t\t\t\tfcopy_srv_version & 0xFFFF);\n\t\t}\n\t} else if (icmsghdr->icmsgtype == ICMSGTYPE_FCOPY) {\n\t\t \n\t\tif (recvlen < ICMSG_HDR + sizeof(struct hv_fcopy_hdr)) {\n\t\t\tpr_err_ratelimited(\"Invalid Fcopy hdr. Packet length too small: %u\\n\",\n\t\t\t\t\t   recvlen);\n\t\t\treturn;\n\t\t}\n\t\tfcopy_msg = (struct hv_fcopy_hdr *)&recv_buffer[ICMSG_HDR];\n\n\t\t \n\n\t\tfcopy_transaction.recv_len = recvlen;\n\t\tfcopy_transaction.recv_req_id = requestid;\n\t\tfcopy_transaction.fcopy_msg = fcopy_msg;\n\n\t\tif (fcopy_transaction.state < HVUTIL_READY) {\n\t\t\t \n\t\t\tfcopy_respond_to_host(HV_E_FAIL);\n\t\t\treturn;\n\t\t}\n\t\tfcopy_transaction.state = HVUTIL_HOSTMSG_RECEIVED;\n\n\t\t \n\t\tschedule_work(&fcopy_send_work);\n\t\tschedule_delayed_work(&fcopy_timeout_work,\n\t\t\t\t      HV_UTIL_TIMEOUT * HZ);\n\t\treturn;\n\t} else {\n\t\tpr_err_ratelimited(\"Fcopy request received. Invalid msg type: %d\\n\",\n\t\t\t\t   icmsghdr->icmsgtype);\n\t\treturn;\n\t}\n\ticmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, recvlen, requestid,\n\t\t\tVM_PKT_DATA_INBAND, 0);\n}\n\n \nstatic int fcopy_on_msg(void *msg, int len)\n{\n\tint *val = (int *)msg;\n\n\tif (len != sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (fcopy_transaction.state == HVUTIL_DEVICE_INIT)\n\t\treturn fcopy_handle_handshake(*val);\n\n\tif (fcopy_transaction.state != HVUTIL_USERSPACE_REQ)\n\t\treturn -EINVAL;\n\n\t \n\tif (cancel_delayed_work_sync(&fcopy_timeout_work)) {\n\t\tfcopy_transaction.state = HVUTIL_USERSPACE_RECV;\n\t\tfcopy_respond_to_host(*val);\n\t\thv_poll_channel(fcopy_transaction.recv_channel,\n\t\t\t\tfcopy_poll_wrapper);\n\t}\n\n\treturn 0;\n}\n\nstatic void fcopy_on_reset(void)\n{\n\t \n\tfcopy_transaction.state = HVUTIL_DEVICE_INIT;\n\n\tif (cancel_delayed_work_sync(&fcopy_timeout_work))\n\t\tfcopy_respond_to_host(HV_E_FAIL);\n}\n\nint hv_fcopy_init(struct hv_util_service *srv)\n{\n\trecv_buffer = srv->recv_buffer;\n\tfcopy_transaction.recv_channel = srv->channel;\n\tfcopy_transaction.recv_channel->max_pkt_size = HV_HYP_PAGE_SIZE * 2;\n\n\t \n\tfcopy_transaction.state = HVUTIL_DEVICE_INIT;\n\n\thvt = hvutil_transport_init(fcopy_devname, 0, 0,\n\t\t\t\t    fcopy_on_msg, fcopy_on_reset);\n\tif (!hvt)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void hv_fcopy_cancel_work(void)\n{\n\tcancel_delayed_work_sync(&fcopy_timeout_work);\n\tcancel_work_sync(&fcopy_send_work);\n}\n\nint hv_fcopy_pre_suspend(void)\n{\n\tstruct vmbus_channel *channel = fcopy_transaction.recv_channel;\n\tstruct hv_fcopy_hdr *fcopy_msg;\n\n\t \n\tfcopy_msg = kzalloc(sizeof(*fcopy_msg), GFP_KERNEL);\n\tif (!fcopy_msg)\n\t\treturn -ENOMEM;\n\n\ttasklet_disable(&channel->callback_event);\n\n\tfcopy_msg->operation = CANCEL_FCOPY;\n\n\thv_fcopy_cancel_work();\n\n\t \n\thvutil_transport_send(hvt, fcopy_msg, sizeof(*fcopy_msg), NULL);\n\n\tkfree(fcopy_msg);\n\n\tfcopy_transaction.state = HVUTIL_READY;\n\n\t \n\treturn 0;\n}\n\nint hv_fcopy_pre_resume(void)\n{\n\tstruct vmbus_channel *channel = fcopy_transaction.recv_channel;\n\n\ttasklet_enable(&channel->callback_event);\n\n\treturn 0;\n}\n\nvoid hv_fcopy_deinit(void)\n{\n\tfcopy_transaction.state = HVUTIL_DEVICE_DYING;\n\n\thv_fcopy_cancel_work();\n\n\thvutil_transport_destroy(hvt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}