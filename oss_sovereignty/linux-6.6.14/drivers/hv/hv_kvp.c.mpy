{
  "module_name": "hv_kvp.c",
  "hash_id": "fd63735f5d17daebf2e6962e18bf91f5d0578f9688cbfcbb1166f65787342c0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_kvp.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/net.h>\n#include <linux/nls.h>\n#include <linux/connector.h>\n#include <linux/workqueue.h>\n#include <linux/hyperv.h>\n#include <asm/hyperv-tlfs.h>\n\n#include \"hyperv_vmbus.h\"\n#include \"hv_utils_transport.h\"\n\n \n#define WS2008_SRV_MAJOR\t1\n#define WS2008_SRV_MINOR\t0\n#define WS2008_SRV_VERSION     (WS2008_SRV_MAJOR << 16 | WS2008_SRV_MINOR)\n\n#define WIN7_SRV_MAJOR   3\n#define WIN7_SRV_MINOR   0\n#define WIN7_SRV_VERSION     (WIN7_SRV_MAJOR << 16 | WIN7_SRV_MINOR)\n\n#define WIN8_SRV_MAJOR   4\n#define WIN8_SRV_MINOR   0\n#define WIN8_SRV_VERSION     (WIN8_SRV_MAJOR << 16 | WIN8_SRV_MINOR)\n\n#define KVP_VER_COUNT 3\nstatic const int kvp_versions[] = {\n\tWIN8_SRV_VERSION,\n\tWIN7_SRV_VERSION,\n\tWS2008_SRV_VERSION\n};\n\n#define FW_VER_COUNT 2\nstatic const int fw_versions[] = {\n\tUTIL_FW_VERSION,\n\tUTIL_WS2K8_FW_VERSION\n};\n\n \n\nstatic struct {\n\tint state;    \n\tint recv_len;  \n\tstruct hv_kvp_msg  *kvp_msg;  \n\tstruct vmbus_channel *recv_channel;  \n\tu64 recv_req_id;  \n} kvp_transaction;\n\n \nstatic int dm_reg_value;\n\nstatic void kvp_send_key(struct work_struct *dummy);\n\n\nstatic void kvp_respond_to_host(struct hv_kvp_msg *msg, int error);\nstatic void kvp_timeout_func(struct work_struct *dummy);\nstatic void kvp_host_handshake_func(struct work_struct *dummy);\nstatic void kvp_register(int);\n\nstatic DECLARE_DELAYED_WORK(kvp_timeout_work, kvp_timeout_func);\nstatic DECLARE_DELAYED_WORK(kvp_host_handshake_work, kvp_host_handshake_func);\nstatic DECLARE_WORK(kvp_sendkey_work, kvp_send_key);\n\nstatic const char kvp_devname[] = \"vmbus/hv_kvp\";\nstatic u8 *recv_buffer;\nstatic struct hvutil_transport *hvt;\n \n#define HV_DRV_VERSION           \"3.1\"\n\nstatic void kvp_poll_wrapper(void *channel)\n{\n\t \n\tkvp_transaction.state = HVUTIL_READY;\n\ttasklet_schedule(&((struct vmbus_channel *)channel)->callback_event);\n}\n\nstatic void kvp_register_done(void)\n{\n\t \n\tpr_debug(\"KVP: userspace daemon registered\\n\");\n\tcancel_delayed_work_sync(&kvp_host_handshake_work);\n\thv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);\n}\n\nstatic void\nkvp_register(int reg_value)\n{\n\n\tstruct hv_kvp_msg *kvp_msg;\n\tchar *version;\n\n\tkvp_msg = kzalloc(sizeof(*kvp_msg), GFP_KERNEL);\n\n\tif (kvp_msg) {\n\t\tversion = kvp_msg->body.kvp_register.version;\n\t\tkvp_msg->kvp_hdr.operation = reg_value;\n\t\tstrcpy(version, HV_DRV_VERSION);\n\n\t\thvutil_transport_send(hvt, kvp_msg, sizeof(*kvp_msg),\n\t\t\t\t      kvp_register_done);\n\t\tkfree(kvp_msg);\n\t}\n}\n\nstatic void kvp_timeout_func(struct work_struct *dummy)\n{\n\t \n\tkvp_respond_to_host(NULL, HV_E_FAIL);\n\n\thv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);\n}\n\nstatic void kvp_host_handshake_func(struct work_struct *dummy)\n{\n\ttasklet_schedule(&kvp_transaction.recv_channel->callback_event);\n}\n\nstatic int kvp_handle_handshake(struct hv_kvp_msg *msg)\n{\n\tswitch (msg->kvp_hdr.operation) {\n\tcase KVP_OP_REGISTER:\n\t\tdm_reg_value = KVP_OP_REGISTER;\n\t\tpr_info(\"KVP: IP injection functionality not available\\n\");\n\t\tpr_info(\"KVP: Upgrade the KVP daemon\\n\");\n\t\tbreak;\n\tcase KVP_OP_REGISTER1:\n\t\tdm_reg_value = KVP_OP_REGISTER1;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"KVP: incompatible daemon\\n\");\n\t\tpr_info(\"KVP: KVP version: %d, Daemon version: %d\\n\",\n\t\t\tKVP_OP_REGISTER1, msg->kvp_hdr.operation);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpr_debug(\"KVP: userspace daemon ver. %d connected\\n\",\n\t\t msg->kvp_hdr.operation);\n\tkvp_register(dm_reg_value);\n\n\treturn 0;\n}\n\n\n \n\nstatic int kvp_on_msg(void *msg, int len)\n{\n\tstruct hv_kvp_msg *message = (struct hv_kvp_msg *)msg;\n\tstruct hv_kvp_msg_enumerate *data;\n\tint\terror = 0;\n\n\tif (len < sizeof(*message))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (kvp_transaction.state < HVUTIL_READY) {\n\t\treturn kvp_handle_handshake(message);\n\t}\n\n\t \n\tif (kvp_transaction.state < HVUTIL_USERSPACE_REQ)\n\t\treturn -EINVAL;\n\n\tkvp_transaction.state = HVUTIL_USERSPACE_RECV;\n\n\t \n\n\tdata = &message->body.kvp_enum_data;\n\n\tswitch (dm_reg_value) {\n\tcase KVP_OP_REGISTER:\n\t\t \n\t\tif (data->data.key[0] == 0)\n\t\t\terror = HV_S_CONT;\n\t\tbreak;\n\n\tcase KVP_OP_REGISTER1:\n\t\t \n\t\terror = message->error;\n\t\tbreak;\n\t}\n\n\t \n\tif (cancel_delayed_work_sync(&kvp_timeout_work)) {\n\t\tkvp_respond_to_host(message, error);\n\t\thv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int process_ob_ipinfo(void *in_msg, void *out_msg, int op)\n{\n\tstruct hv_kvp_msg *in = in_msg;\n\tstruct hv_kvp_ip_msg *out = out_msg;\n\tint len;\n\n\tswitch (op) {\n\tcase KVP_OP_GET_IP_INFO:\n\t\t \n\t\tlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.ip_addr,\n\t\t\t\tstrlen((char *)in->body.kvp_ip_val.ip_addr),\n\t\t\t\tUTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *)out->kvp_ip_val.ip_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.sub_net,\n\t\t\t\tstrlen((char *)in->body.kvp_ip_val.sub_net),\n\t\t\t\tUTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *)out->kvp_ip_val.sub_net,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.gate_way,\n\t\t\t\tstrlen((char *)in->body.kvp_ip_val.gate_way),\n\t\t\t\tUTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *)out->kvp_ip_val.gate_way,\n\t\t\t\tMAX_GATEWAY_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.dns_addr,\n\t\t\t\tstrlen((char *)in->body.kvp_ip_val.dns_addr),\n\t\t\t\tUTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *)out->kvp_ip_val.dns_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.adapter_id,\n\t\t\t\tstrlen((char *)in->body.kvp_ip_val.adapter_id),\n\t\t\t\tUTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *)out->kvp_ip_val.adapter_id,\n\t\t\t\tMAX_ADAPTER_ID_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tout->kvp_ip_val.dhcp_enabled =\n\t\t\tin->body.kvp_ip_val.dhcp_enabled;\n\t\tout->kvp_ip_val.addr_family =\n\t\t\tin->body.kvp_ip_val.addr_family;\n\t}\n\n\treturn 0;\n}\n\nstatic void process_ib_ipinfo(void *in_msg, void *out_msg, int op)\n{\n\tstruct hv_kvp_ip_msg *in = in_msg;\n\tstruct hv_kvp_msg *out = out_msg;\n\n\tswitch (op) {\n\tcase KVP_OP_SET_IP_INFO:\n\t\t \n\t\tutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.ip_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)out->body.kvp_ip_val.ip_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\n\t\tutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.sub_net,\n\t\t\t\tMAX_IP_ADDR_SIZE,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)out->body.kvp_ip_val.sub_net,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\n\t\tutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.gate_way,\n\t\t\t\tMAX_GATEWAY_SIZE,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)out->body.kvp_ip_val.gate_way,\n\t\t\t\tMAX_GATEWAY_SIZE);\n\n\t\tutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.dns_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)out->body.kvp_ip_val.dns_addr,\n\t\t\t\tMAX_IP_ADDR_SIZE);\n\n\t\tout->body.kvp_ip_val.dhcp_enabled = in->kvp_ip_val.dhcp_enabled;\n\n\t\tfallthrough;\n\n\tcase KVP_OP_GET_IP_INFO:\n\t\tutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.adapter_id,\n\t\t\t\tMAX_ADAPTER_ID_SIZE,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t(__u8 *)out->body.kvp_ip_val.adapter_id,\n\t\t\t\tMAX_ADAPTER_ID_SIZE);\n\n\t\tout->body.kvp_ip_val.addr_family = in->kvp_ip_val.addr_family;\n\t}\n}\n\n\n\n\nstatic void\nkvp_send_key(struct work_struct *dummy)\n{\n\tstruct hv_kvp_msg *message;\n\tstruct hv_kvp_msg *in_msg;\n\t__u8 operation = kvp_transaction.kvp_msg->kvp_hdr.operation;\n\t__u8 pool = kvp_transaction.kvp_msg->kvp_hdr.pool;\n\t__u32 val32;\n\t__u64 val64;\n\tint rc;\n\n\t \n\tif (kvp_transaction.state != HVUTIL_HOSTMSG_RECEIVED)\n\t\treturn;\n\n\tmessage = kzalloc(sizeof(*message), GFP_KERNEL);\n\tif (!message)\n\t\treturn;\n\n\tmessage->kvp_hdr.operation = operation;\n\tmessage->kvp_hdr.pool = pool;\n\tin_msg = kvp_transaction.kvp_msg;\n\n\t \n\n\tswitch (message->kvp_hdr.operation) {\n\tcase KVP_OP_SET_IP_INFO:\n\t\tprocess_ib_ipinfo(in_msg, message, KVP_OP_SET_IP_INFO);\n\t\tbreak;\n\tcase KVP_OP_GET_IP_INFO:\n\t\t \n\t\tprocess_ib_ipinfo(in_msg, message, KVP_OP_GET_IP_INFO);\n\t\tbreak;\n\tcase KVP_OP_SET:\n\t\tswitch (in_msg->body.kvp_set.data.value_type) {\n\t\tcase REG_SZ:\n\t\t\t \n\t\t\tmessage->body.kvp_set.data.value_size =\n\t\t\t\tutf16s_to_utf8s(\n\t\t\t\t(wchar_t *)in_msg->body.kvp_set.data.value,\n\t\t\t\tin_msg->body.kvp_set.data.value_size,\n\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\tmessage->body.kvp_set.data.value,\n\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE - 1) + 1;\n\t\t\tbreak;\n\n\t\tcase REG_U32:\n\t\t\t \n\t\t\tval32 = in_msg->body.kvp_set.data.value_u32;\n\t\t\tmessage->body.kvp_set.data.value_size =\n\t\t\t\tsprintf(message->body.kvp_set.data.value,\n\t\t\t\t\t\"%u\", val32) + 1;\n\t\t\tbreak;\n\n\t\tcase REG_U64:\n\t\t\t \n\t\t\tval64 = in_msg->body.kvp_set.data.value_u64;\n\t\t\tmessage->body.kvp_set.data.value_size =\n\t\t\t\tsprintf(message->body.kvp_set.data.value,\n\t\t\t\t\t\"%llu\", val64) + 1;\n\t\t\tbreak;\n\n\t\t}\n\n\t\t \n\t\tmessage->body.kvp_set.data.key_size =\n\t\t\tutf16s_to_utf8s(\n\t\t\t(wchar_t *)in_msg->body.kvp_set.data.key,\n\t\t\tin_msg->body.kvp_set.data.key_size,\n\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\tmessage->body.kvp_set.data.key,\n\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\n\n\t\tbreak;\n\n\tcase KVP_OP_GET:\n\t\tmessage->body.kvp_get.data.key_size =\n\t\t\tutf16s_to_utf8s(\n\t\t\t(wchar_t *)in_msg->body.kvp_get.data.key,\n\t\t\tin_msg->body.kvp_get.data.key_size,\n\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\tmessage->body.kvp_get.data.key,\n\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\n\t\tbreak;\n\n\tcase KVP_OP_DELETE:\n\t\tmessage->body.kvp_delete.key_size =\n\t\t\tutf16s_to_utf8s(\n\t\t\t(wchar_t *)in_msg->body.kvp_delete.key,\n\t\t\tin_msg->body.kvp_delete.key_size,\n\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\tmessage->body.kvp_delete.key,\n\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\n\t\tbreak;\n\n\tcase KVP_OP_ENUMERATE:\n\t\tmessage->body.kvp_enum_data.index =\n\t\t\tin_msg->body.kvp_enum_data.index;\n\t\tbreak;\n\t}\n\n\tkvp_transaction.state = HVUTIL_USERSPACE_REQ;\n\trc = hvutil_transport_send(hvt, message, sizeof(*message), NULL);\n\tif (rc) {\n\t\tpr_debug(\"KVP: failed to communicate to the daemon: %d\\n\", rc);\n\t\tif (cancel_delayed_work_sync(&kvp_timeout_work)) {\n\t\t\tkvp_respond_to_host(message, HV_E_FAIL);\n\t\t\tkvp_transaction.state = HVUTIL_READY;\n\t\t}\n\t}\n\n\tkfree(message);\n}\n\n \n\nstatic void\nkvp_respond_to_host(struct hv_kvp_msg *msg_to_host, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_exchg_msg_value  *kvp_data;\n\tchar\t*key_name;\n\tchar\t*value;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen = 0;\n\tint\tvaluelen = 0;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tint ret;\n\n\t \n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (channel->onchannel_callback == NULL)\n\t\t \n\t\treturn;\n\n\ticmsghdrp->status = error;\n\n\t \n\tif (error) {\n\t\t \n\t\tgoto response_done;\n\t}\n\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\n\tswitch (kvp_transaction.kvp_msg->kvp_hdr.operation) {\n\tcase KVP_OP_GET_IP_INFO:\n\t\tret = process_ob_ipinfo(msg_to_host,\n\t\t\t\t (struct hv_kvp_ip_msg *)kvp_msg,\n\t\t\t\t KVP_OP_GET_IP_INFO);\n\t\tif (ret < 0)\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\n\t\tgoto response_done;\n\tcase KVP_OP_SET_IP_INFO:\n\t\tgoto response_done;\n\tcase KVP_OP_GET:\n\t\tkvp_data = &kvp_msg->body.kvp_get.data;\n\t\tgoto copy_value;\n\n\tcase KVP_OP_SET:\n\tcase KVP_OP_DELETE:\n\t\tgoto response_done;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvp_data = &kvp_msg->body.kvp_enum_data.data;\n\tkey_name = msg_to_host->body.kvp_enum_data.data.key;\n\n\t \n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->key,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);\n\tkvp_data->key_size = 2*(keylen + 1);  \n\ncopy_value:\n\tvalue = msg_to_host->body.kvp_enum_data.data.value;\n\tvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->value,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);\n\tkvp_data->value_size = 2*(valuelen + 1);  \n\n\t \n\tif ((keylen < 0) || (valuelen < 0))\n\t\ticmsghdrp->status = HV_E_FAIL;\n\n\tkvp_data->value_type = REG_SZ;  \n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}\n\n \n\nvoid hv_kvp_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tu32 recvlen;\n\tu64 requestid;\n\n\tstruct hv_kvp_msg *kvp_msg;\n\n\tstruct icmsg_hdr *icmsghdrp;\n\tint kvp_srv_version;\n\tstatic enum {NEGO_NOT_STARTED,\n\t\t     NEGO_IN_PROGRESS,\n\t\t     NEGO_FINISHED} host_negotiatied = NEGO_NOT_STARTED;\n\n\tif (kvp_transaction.state < HVUTIL_READY) {\n\t\t \n\t\tif (host_negotiatied == NEGO_NOT_STARTED) {\n\t\t\thost_negotiatied = NEGO_IN_PROGRESS;\n\t\t\tschedule_delayed_work(&kvp_host_handshake_work,\n\t\t\t\t      HV_UTIL_NEGO_TIMEOUT * HZ);\n\t\t}\n\t\treturn;\n\t}\n\tif (kvp_transaction.state > HVUTIL_READY)\n\t\treturn;\n\n\tif (vmbus_recvpacket(channel, recv_buffer, HV_HYP_PAGE_SIZE * 4, &recvlen, &requestid)) {\n\t\tpr_err_ratelimited(\"KVP request received. Could not read into recv buf\\n\");\n\t\treturn;\n\t}\n\n\tif (!recvlen)\n\t\treturn;\n\n\t \n\tif (recvlen < ICMSG_HDR) {\n\t\tpr_err_ratelimited(\"KVP request received. Packet length too small: %d\\n\",\n\t\t\t\t   recvlen);\n\t\treturn;\n\t}\n\n\ticmsghdrp = (struct icmsg_hdr *)&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\tif (vmbus_prep_negotiate_resp(icmsghdrp,\n\t\t\t\trecv_buffer, recvlen,\n\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\tkvp_versions, KVP_VER_COUNT,\n\t\t\t\tNULL, &kvp_srv_version)) {\n\t\t\tpr_info(\"KVP IC version %d.%d\\n\",\n\t\t\t\tkvp_srv_version >> 16,\n\t\t\t\tkvp_srv_version & 0xFFFF);\n\t\t}\n\t} else if (icmsghdrp->icmsgtype == ICMSGTYPE_KVPEXCHANGE) {\n\t\t \n\t\tkvp_msg = (struct hv_kvp_msg *)&recv_buffer[ICMSG_HDR];\n\n\t\t \n\n\t\tkvp_transaction.recv_len = recvlen;\n\t\tkvp_transaction.recv_req_id = requestid;\n\t\tkvp_transaction.kvp_msg = kvp_msg;\n\n\t\tif (kvp_transaction.state < HVUTIL_READY) {\n\t\t\t \n\t\t\tkvp_respond_to_host(NULL, HV_E_FAIL);\n\t\t\treturn;\n\t\t}\n\t\tkvp_transaction.state = HVUTIL_HOSTMSG_RECEIVED;\n\n\t\t \n\t\tschedule_work(&kvp_sendkey_work);\n\t\tschedule_delayed_work(&kvp_timeout_work,\n\t\t\t\t\tHV_UTIL_TIMEOUT * HZ);\n\n\t\treturn;\n\n\t} else {\n\t\tpr_err_ratelimited(\"KVP request received. Invalid msg type: %d\\n\",\n\t\t\t\t   icmsghdrp->icmsgtype);\n\t\treturn;\n\t}\n\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\n\t\t| ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer,\n\t\t\t recvlen, requestid,\n\t\t\t VM_PKT_DATA_INBAND, 0);\n\n\thost_negotiatied = NEGO_FINISHED;\n\thv_poll_channel(kvp_transaction.recv_channel, kvp_poll_wrapper);\n}\n\nstatic void kvp_on_reset(void)\n{\n\tif (cancel_delayed_work_sync(&kvp_timeout_work))\n\t\tkvp_respond_to_host(NULL, HV_E_FAIL);\n\tkvp_transaction.state = HVUTIL_DEVICE_INIT;\n}\n\nint\nhv_kvp_init(struct hv_util_service *srv)\n{\n\trecv_buffer = srv->recv_buffer;\n\tkvp_transaction.recv_channel = srv->channel;\n\tkvp_transaction.recv_channel->max_pkt_size = HV_HYP_PAGE_SIZE * 4;\n\n\t \n\tkvp_transaction.state = HVUTIL_DEVICE_INIT;\n\n\thvt = hvutil_transport_init(kvp_devname, CN_KVP_IDX, CN_KVP_VAL,\n\t\t\t\t    kvp_on_msg, kvp_on_reset);\n\tif (!hvt)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void hv_kvp_cancel_work(void)\n{\n\tcancel_delayed_work_sync(&kvp_host_handshake_work);\n\tcancel_delayed_work_sync(&kvp_timeout_work);\n\tcancel_work_sync(&kvp_sendkey_work);\n}\n\nint hv_kvp_pre_suspend(void)\n{\n\tstruct vmbus_channel *channel = kvp_transaction.recv_channel;\n\n\ttasklet_disable(&channel->callback_event);\n\n\t \n\thv_kvp_cancel_work();\n\n\t \n\tkvp_transaction.state = HVUTIL_READY;\n\treturn 0;\n}\n\nint hv_kvp_pre_resume(void)\n{\n\tstruct vmbus_channel *channel = kvp_transaction.recv_channel;\n\n\ttasklet_enable(&channel->callback_event);\n\n\treturn 0;\n}\n\nvoid hv_kvp_deinit(void)\n{\n\tkvp_transaction.state = HVUTIL_DEVICE_DYING;\n\n\thv_kvp_cancel_work();\n\n\thvutil_transport_destroy(hvt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}