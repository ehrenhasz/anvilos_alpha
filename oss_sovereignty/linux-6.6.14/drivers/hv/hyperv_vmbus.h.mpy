{
  "module_name": "hyperv_vmbus.h",
  "hash_id": "b51324f604af5f443926ce1012e2214584edc050240c529630df9f46a86891bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hyperv_vmbus.h",
  "human_readable_source": " \n \n\n#ifndef _HYPERV_VMBUS_H\n#define _HYPERV_VMBUS_H\n\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <asm/sync_bitops.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/atomic.h>\n#include <linux/hyperv.h>\n#include <linux/interrupt.h>\n\n#include \"hv_trace.h\"\n\n \n#define HV_UTIL_TIMEOUT 30\n\n \n#define HV_UTIL_NEGO_TIMEOUT 55\n\n\n \nunion hv_monitor_trigger_group {\n\tu64 as_uint64;\n\tstruct {\n\t\tu32 pending;\n\t\tu32 armed;\n\t};\n};\n\nstruct hv_monitor_parameter {\n\tunion hv_connection_id connectionid;\n\tu16 flagnumber;\n\tu16 rsvdz;\n};\n\nunion hv_monitor_trigger_state {\n\tu32 asu32;\n\n\tstruct {\n\t\tu32 group_enable:4;\n\t\tu32 rsvdz:28;\n\t};\n};\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nstruct hv_monitor_page {\n\tunion hv_monitor_trigger_state trigger_state;\n\tu32 rsvdz1;\n\n\tunion hv_monitor_trigger_group trigger_group[4];\n\tu64 rsvdz2[3];\n\n\ts32 next_checktime[4][32];\n\n\tu16 latency[4][32];\n\tu64 rsvdz3[32];\n\n\tstruct hv_monitor_parameter parameter[4][32];\n\n\tu8 rsvdz4[1984];\n};\n\n#define HV_HYPERCALL_PARAM_ALIGN\tsizeof(u64)\n\n \nstruct hv_input_post_message {\n\tunion hv_connection_id connectionid;\n\tu32 reserved;\n\tu32 message_type;\n\tu32 payload_size;\n\tu64 payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];\n};\n\n\nenum {\n\tVMBUS_MESSAGE_CONNECTION_ID\t= 1,\n\tVMBUS_MESSAGE_CONNECTION_ID_4\t= 4,\n\tVMBUS_MESSAGE_PORT_ID\t\t= 1,\n\tVMBUS_EVENT_CONNECTION_ID\t= 2,\n\tVMBUS_EVENT_PORT_ID\t\t= 2,\n\tVMBUS_MONITOR_CONNECTION_ID\t= 3,\n\tVMBUS_MONITOR_PORT_ID\t\t= 3,\n\tVMBUS_MESSAGE_SINT\t\t= 2,\n};\n\n \nstruct hv_per_cpu_context {\n\tvoid *synic_message_page;\n\tvoid *synic_event_page;\n\n\t \n\tvoid *post_msg_page;\n\n\t \n\tstruct tasklet_struct msg_dpc;\n};\n\nstruct hv_context {\n\t \n\tu64 guestid;\n\n\tstruct hv_per_cpu_context __percpu *cpu_context;\n\n\t \n\tstruct cpumask *hv_numa_map;\n};\n\nextern struct hv_context hv_context;\n\n \n\nextern int hv_init(void);\n\nextern int hv_post_message(union hv_connection_id connection_id,\n\t\t\t enum hv_message_type message_type,\n\t\t\t void *payload, size_t payload_size);\n\nextern int hv_synic_alloc(void);\n\nextern void hv_synic_free(void);\n\nextern void hv_synic_enable_regs(unsigned int cpu);\nextern int hv_synic_init(unsigned int cpu);\n\nextern void hv_synic_disable_regs(unsigned int cpu);\nextern int hv_synic_cleanup(unsigned int cpu);\n\n \n\nvoid hv_ringbuffer_pre_init(struct vmbus_channel *channel);\n\nint hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info,\n\t\t       struct page *pages, u32 pagecnt, u32 max_pkt_size);\n\nvoid hv_ringbuffer_cleanup(struct hv_ring_buffer_info *ring_info);\n\nint hv_ringbuffer_write(struct vmbus_channel *channel,\n\t\t\tconst struct kvec *kv_list, u32 kv_count,\n\t\t\tu64 requestid, u64 *trans_id);\n\nint hv_ringbuffer_read(struct vmbus_channel *channel,\n\t\t       void *buffer, u32 buflen, u32 *buffer_actual_len,\n\t\t       u64 *requestid, bool raw);\n\n \n#define MAX_NUM_CHANNELS\t((HV_HYP_PAGE_SIZE >> 1) << 3)\n\n \n#define MAX_NUM_CHANNELS_SUPPORTED\t256\n\n#define MAX_CHANNEL_RELIDS\t\t\t\t\t\\\n\tmax(MAX_NUM_CHANNELS_SUPPORTED, HV_EVENT_FLAGS_COUNT)\n\nenum vmbus_connect_state {\n\tDISCONNECTED,\n\tCONNECTING,\n\tCONNECTED,\n\tDISCONNECTING\n};\n\n#define MAX_SIZE_CHANNEL_MESSAGE\tHV_MESSAGE_PAYLOAD_BYTE_COUNT\n\n \n#define VMBUS_CONNECT_CPU\t0\n\nstruct vmbus_connection {\n\tu32 msg_conn_id;\n\n\tatomic_t offer_in_progress;\n\n\tenum vmbus_connect_state conn_state;\n\n\tatomic_t next_gpadl_handle;\n\n\tstruct completion  unload_event;\n\t \n\tvoid *int_page;\n\tvoid *send_int_page;\n\tvoid *recv_int_page;\n\n\t \n\tstruct hv_monitor_page *monitor_pages[2];\n\tstruct list_head chn_msg_list;\n\tspinlock_t channelmsg_lock;\n\n\t \n\tstruct list_head chn_list;\n\tstruct mutex channel_mutex;\n\n\t \n\tstruct vmbus_channel **channels;\n\n\t \n\tstruct workqueue_struct *work_queue;\n\tstruct workqueue_struct *handle_primary_chan_wq;\n\tstruct workqueue_struct *handle_sub_chan_wq;\n\tstruct workqueue_struct *rescind_work_queue;\n\n\t \n\tbool ignore_any_offer_msg;\n\n\t \n\tatomic_t nr_chan_close_on_suspend;\n\t \n\tstruct completion ready_for_suspend_event;\n\n\t \n\tatomic_t nr_chan_fixup_on_resume;\n\t \n\tstruct completion ready_for_resume_event;\n};\n\n\nstruct vmbus_msginfo {\n\t \n\tstruct list_head msglist_entry;\n\n\t \n\tunsigned char msg[];\n};\n\n\nextern struct vmbus_connection vmbus_connection;\n\nint vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version);\n\nstatic inline void vmbus_send_interrupt(u32 relid)\n{\n\tsync_set_bit(relid, vmbus_connection.send_int_page);\n}\n\nenum vmbus_message_handler_type {\n\t \n\tVMHT_BLOCKING = 0,\n\n\t \n\tVMHT_NON_BLOCKING = 1,\n};\n\nstruct vmbus_channel_message_table_entry {\n\tenum vmbus_channel_message_type message_type;\n\tenum vmbus_message_handler_type handler_type;\n\tvoid (*message_handler)(struct vmbus_channel_message_header *msg);\n\tu32 min_payload_len;\n};\n\nextern const struct vmbus_channel_message_table_entry\n\tchannel_message_table[CHANNELMSG_COUNT];\n\n\n \n\nstruct hv_device *vmbus_device_create(const guid_t *type,\n\t\t\t\t      const guid_t *instance,\n\t\t\t\t      struct vmbus_channel *channel);\n\nint vmbus_device_register(struct hv_device *child_device_obj);\nvoid vmbus_device_unregister(struct hv_device *device_obj);\nint vmbus_add_channel_kobj(struct hv_device *device_obj,\n\t\t\t   struct vmbus_channel *channel);\n\nvoid vmbus_remove_channel_attr_group(struct vmbus_channel *channel);\n\nvoid vmbus_channel_map_relid(struct vmbus_channel *channel);\nvoid vmbus_channel_unmap_relid(struct vmbus_channel *channel);\n\nstruct vmbus_channel *relid2channel(u32 relid);\n\nvoid vmbus_free_channels(void);\n\n \n\nint vmbus_connect(void);\nvoid vmbus_disconnect(void);\n\nint vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep);\n\nvoid vmbus_on_event(unsigned long data);\nvoid vmbus_on_msg_dpc(unsigned long data);\n\nint hv_kvp_init(struct hv_util_service *srv);\nvoid hv_kvp_deinit(void);\nint hv_kvp_pre_suspend(void);\nint hv_kvp_pre_resume(void);\nvoid hv_kvp_onchannelcallback(void *context);\n\nint hv_vss_init(struct hv_util_service *srv);\nvoid hv_vss_deinit(void);\nint hv_vss_pre_suspend(void);\nint hv_vss_pre_resume(void);\nvoid hv_vss_onchannelcallback(void *context);\n\nint hv_fcopy_init(struct hv_util_service *srv);\nvoid hv_fcopy_deinit(void);\nint hv_fcopy_pre_suspend(void);\nint hv_fcopy_pre_resume(void);\nvoid hv_fcopy_onchannelcallback(void *context);\nvoid vmbus_initiate_unload(bool crash);\n\nstatic inline void hv_poll_channel(struct vmbus_channel *channel,\n\t\t\t\t   void (*cb)(void *))\n{\n\tif (!channel)\n\t\treturn;\n\tcb(channel);\n}\n\nenum hvutil_device_state {\n\tHVUTIL_DEVICE_INIT = 0,   \n\tHVUTIL_READY,             \n\tHVUTIL_HOSTMSG_RECEIVED,  \n\tHVUTIL_USERSPACE_REQ,     \n\tHVUTIL_USERSPACE_RECV,    \n\tHVUTIL_DEVICE_DYING,      \n};\n\nenum delay {\n\tINTERRUPT_DELAY = 0,\n\tMESSAGE_DELAY   = 1,\n};\n\nextern const struct vmbus_device vmbus_devs[];\n\nstatic inline bool hv_is_perf_channel(struct vmbus_channel *channel)\n{\n\treturn vmbus_devs[channel->device_id].perf_device;\n}\n\nstatic inline bool hv_is_allocated_cpu(unsigned int cpu)\n{\n\tstruct vmbus_channel *channel, *sc;\n\n\tlockdep_assert_held(&vmbus_connection.channel_mutex);\n\t \n\tlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\n\t\tif (!hv_is_perf_channel(channel))\n\t\t\tcontinue;\n\t\tif (channel->target_cpu == cpu)\n\t\t\treturn true;\n\t\tlist_for_each_entry(sc, &channel->sc_list, sc_list) {\n\t\t\tif (sc->target_cpu == cpu)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic inline void hv_set_allocated_cpu(unsigned int cpu)\n{\n\tcpumask_set_cpu(cpu, &hv_context.hv_numa_map[cpu_to_node(cpu)]);\n}\n\nstatic inline void hv_clear_allocated_cpu(unsigned int cpu)\n{\n\tif (hv_is_allocated_cpu(cpu))\n\t\treturn;\n\tcpumask_clear_cpu(cpu, &hv_context.hv_numa_map[cpu_to_node(cpu)]);\n}\n\nstatic inline void hv_update_allocated_cpus(unsigned int old_cpu,\n\t\t\t\t\t  unsigned int new_cpu)\n{\n\thv_set_allocated_cpu(new_cpu);\n\thv_clear_allocated_cpu(old_cpu);\n}\n\n#ifdef CONFIG_HYPERV_TESTING\n\nint hv_debug_add_dev_dir(struct hv_device *dev);\nvoid hv_debug_rm_dev_dir(struct hv_device *dev);\nvoid hv_debug_rm_all_dir(void);\nint hv_debug_init(void);\nvoid hv_debug_delay_test(struct vmbus_channel *channel, enum delay delay_type);\n\n#else  \n\nstatic inline void hv_debug_rm_dev_dir(struct hv_device *dev) {};\nstatic inline void hv_debug_rm_all_dir(void) {};\nstatic inline void hv_debug_delay_test(struct vmbus_channel *channel,\n\t\t\t\t       enum delay delay_type) {};\nstatic inline int hv_debug_init(void)\n{\n\treturn -1;\n}\n\nstatic inline int hv_debug_add_dev_dir(struct hv_device *dev)\n{\n\treturn -1;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}