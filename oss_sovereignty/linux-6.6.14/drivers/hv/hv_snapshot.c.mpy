{
  "module_name": "hv_snapshot.c",
  "hash_id": "9e0f79e9bcb2fa4693a11248f2c7f29b963980213d03c8824421a1a93df55786",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_snapshot.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/net.h>\n#include <linux/nls.h>\n#include <linux/connector.h>\n#include <linux/workqueue.h>\n#include <linux/hyperv.h>\n#include <asm/hyperv-tlfs.h>\n\n#include \"hyperv_vmbus.h\"\n#include \"hv_utils_transport.h\"\n\n#define VSS_MAJOR  5\n#define VSS_MINOR  0\n#define VSS_VERSION    (VSS_MAJOR << 16 | VSS_MINOR)\n\n#define VSS_VER_COUNT 1\nstatic const int vss_versions[] = {\n\tVSS_VERSION\n};\n\n#define FW_VER_COUNT 1\nstatic const int fw_versions[] = {\n\tUTIL_FW_VERSION\n};\n\n \n#define VSS_MAX_PKT_SIZE (HV_HYP_PAGE_SIZE * 2)\n\n \n#define VSS_FREEZE_TIMEOUT (15 * 60)\n\n \n\nstatic struct {\n\tint state;    \n\tint recv_len;  \n\tstruct vmbus_channel *recv_channel;  \n\tu64 recv_req_id;  \n\tstruct hv_vss_msg  *msg;  \n} vss_transaction;\n\n\nstatic void vss_respond_to_host(int error);\n\n \nstatic int dm_reg_value;\n\nstatic const char vss_devname[] = \"vmbus/hv_vss\";\nstatic __u8 *recv_buffer;\nstatic struct hvutil_transport *hvt;\n\nstatic void vss_timeout_func(struct work_struct *dummy);\nstatic void vss_handle_request(struct work_struct *dummy);\n\nstatic DECLARE_DELAYED_WORK(vss_timeout_work, vss_timeout_func);\nstatic DECLARE_WORK(vss_handle_request_work, vss_handle_request);\n\nstatic void vss_poll_wrapper(void *channel)\n{\n\t \n\tvss_transaction.state = HVUTIL_READY;\n\ttasklet_schedule(&((struct vmbus_channel *)channel)->callback_event);\n}\n\n \n\nstatic void vss_timeout_func(struct work_struct *dummy)\n{\n\t \n\tpr_warn(\"VSS: timeout waiting for daemon to reply\\n\");\n\tvss_respond_to_host(HV_E_FAIL);\n\n\thv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\n}\n\nstatic void vss_register_done(void)\n{\n\thv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\n\tpr_debug(\"VSS: userspace daemon registered\\n\");\n}\n\nstatic int vss_handle_handshake(struct hv_vss_msg *vss_msg)\n{\n\tu32 our_ver = VSS_OP_REGISTER1;\n\n\tswitch (vss_msg->vss_hdr.operation) {\n\tcase VSS_OP_REGISTER:\n\t\t \n\t\tdm_reg_value = VSS_OP_REGISTER;\n\t\tbreak;\n\tcase VSS_OP_REGISTER1:\n\t\t \n\t\tif (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver),\n\t\t\t\t\t  vss_register_done))\n\t\t\treturn -EFAULT;\n\t\tdm_reg_value = VSS_OP_REGISTER1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpr_info(\"VSS: userspace daemon ver. %d connected\\n\", dm_reg_value);\n\treturn 0;\n}\n\nstatic int vss_on_msg(void *msg, int len)\n{\n\tstruct hv_vss_msg *vss_msg = (struct hv_vss_msg *)msg;\n\n\tif (len != sizeof(*vss_msg)) {\n\t\tpr_debug(\"VSS: Message size does not match length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vss_msg->vss_hdr.operation == VSS_OP_REGISTER ||\n\t    vss_msg->vss_hdr.operation == VSS_OP_REGISTER1) {\n\t\t \n\t\tif (vss_transaction.state > HVUTIL_READY) {\n\t\t\tpr_debug(\"VSS: Got unexpected registration request\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn vss_handle_handshake(vss_msg);\n\t} else if (vss_transaction.state == HVUTIL_USERSPACE_REQ) {\n\t\tvss_transaction.state = HVUTIL_USERSPACE_RECV;\n\n\t\tif (vss_msg->vss_hdr.operation == VSS_OP_HOT_BACKUP)\n\t\t\tvss_transaction.msg->vss_cf.flags =\n\t\t\t\tVSS_HBU_NO_AUTO_RECOVERY;\n\n\t\tif (cancel_delayed_work_sync(&vss_timeout_work)) {\n\t\t\tvss_respond_to_host(vss_msg->error);\n\t\t\t \n\t\t\thv_poll_channel(vss_transaction.recv_channel,\n\t\t\t\t\tvss_poll_wrapper);\n\t\t}\n\t} else {\n\t\t \n\t\tpr_debug(\"VSS: Transaction not active\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void vss_send_op(void)\n{\n\tint op = vss_transaction.msg->vss_hdr.operation;\n\tint rc;\n\tstruct hv_vss_msg *vss_msg;\n\n\t \n\tif (vss_transaction.state != HVUTIL_HOSTMSG_RECEIVED) {\n\t\tpr_debug(\"VSS: Unexpected attempt to send to daemon\\n\");\n\t\treturn;\n\t}\n\n\tvss_msg = kzalloc(sizeof(*vss_msg), GFP_KERNEL);\n\tif (!vss_msg)\n\t\treturn;\n\n\tvss_msg->vss_hdr.operation = op;\n\n\tvss_transaction.state = HVUTIL_USERSPACE_REQ;\n\n\tschedule_delayed_work(&vss_timeout_work, op == VSS_OP_FREEZE ?\n\t\t\tVSS_FREEZE_TIMEOUT * HZ : HV_UTIL_TIMEOUT * HZ);\n\n\trc = hvutil_transport_send(hvt, vss_msg, sizeof(*vss_msg), NULL);\n\tif (rc) {\n\t\tpr_warn(\"VSS: failed to communicate to the daemon: %d\\n\", rc);\n\t\tif (cancel_delayed_work_sync(&vss_timeout_work)) {\n\t\t\tvss_respond_to_host(HV_E_FAIL);\n\t\t\tvss_transaction.state = HVUTIL_READY;\n\t\t}\n\t}\n\n\tkfree(vss_msg);\n}\n\nstatic void vss_handle_request(struct work_struct *dummy)\n{\n\tswitch (vss_transaction.msg->vss_hdr.operation) {\n\t \n\tcase VSS_OP_THAW:\n\tcase VSS_OP_FREEZE:\n\tcase VSS_OP_HOT_BACKUP:\n\t\tif (vss_transaction.state < HVUTIL_READY) {\n\t\t\t \n\t\t\tpr_debug(\"VSS: Not ready for request.\\n\");\n\t\t\tvss_respond_to_host(HV_E_FAIL);\n\t\t\treturn;\n\t\t}\n\n\t\tpr_debug(\"VSS: Received request for op code: %d\\n\",\n\t\t\tvss_transaction.msg->vss_hdr.operation);\n\t\tvss_transaction.state = HVUTIL_HOSTMSG_RECEIVED;\n\t\tvss_send_op();\n\t\treturn;\n\tcase VSS_OP_GET_DM_INFO:\n\t\tvss_transaction.msg->dm_info.flags = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvss_respond_to_host(0);\n\thv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\n}\n\n \n\nstatic void\nvss_respond_to_host(int error)\n{\n\tstruct icmsg_hdr *icmsghdrp;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\n\t \n\n\tbuf_len = vss_transaction.recv_len;\n\tchannel = vss_transaction.recv_channel;\n\treq_id = vss_transaction.recv_req_id;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (channel->onchannel_callback == NULL)\n\t\t \n\t\treturn;\n\n\ticmsghdrp->status = error;\n\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\n}\n\n \n\nvoid hv_vss_onchannelcallback(void *context)\n{\n\tstruct vmbus_channel *channel = context;\n\tu32 recvlen;\n\tu64 requestid;\n\tstruct hv_vss_msg *vss_msg;\n\tint vss_srv_version;\n\n\tstruct icmsg_hdr *icmsghdrp;\n\n\tif (vss_transaction.state > HVUTIL_READY)\n\t\treturn;\n\n\tif (vmbus_recvpacket(channel, recv_buffer, VSS_MAX_PKT_SIZE, &recvlen, &requestid)) {\n\t\tpr_err_ratelimited(\"VSS request received. Could not read into recv buf\\n\");\n\t\treturn;\n\t}\n\n\tif (!recvlen)\n\t\treturn;\n\n\t \n\tif (recvlen < ICMSG_HDR) {\n\t\tpr_err_ratelimited(\"VSS request received. Packet length too small: %d\\n\",\n\t\t\t\t   recvlen);\n\t\treturn;\n\t}\n\n\ticmsghdrp = (struct icmsg_hdr *)&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\n\t\tif (vmbus_prep_negotiate_resp(icmsghdrp,\n\t\t\t\trecv_buffer, recvlen,\n\t\t\t\tfw_versions, FW_VER_COUNT,\n\t\t\t\tvss_versions, VSS_VER_COUNT,\n\t\t\t\tNULL, &vss_srv_version)) {\n\n\t\t\tpr_info(\"VSS IC version %d.%d\\n\",\n\t\t\t\tvss_srv_version >> 16,\n\t\t\t\tvss_srv_version & 0xFFFF);\n\t\t}\n\t} else if (icmsghdrp->icmsgtype == ICMSGTYPE_VSS) {\n\t\t \n\t\tif (recvlen < ICMSG_HDR + sizeof(struct hv_vss_msg)) {\n\t\t\tpr_err_ratelimited(\"Invalid VSS msg. Packet length too small: %u\\n\",\n\t\t\t\t\t   recvlen);\n\t\t\treturn;\n\t\t}\n\t\tvss_msg = (struct hv_vss_msg *)&recv_buffer[ICMSG_HDR];\n\n\t\t \n\n\t\tvss_transaction.recv_len = recvlen;\n\t\tvss_transaction.recv_req_id = requestid;\n\t\tvss_transaction.msg = (struct hv_vss_msg *)vss_msg;\n\n\t\tschedule_work(&vss_handle_request_work);\n\t\treturn;\n\t} else {\n\t\tpr_err_ratelimited(\"VSS request received. Invalid msg type: %d\\n\",\n\t\t\t\t   icmsghdrp->icmsgtype);\n\t\treturn;\n\t}\n\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION |\n\t\tICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, recvlen, requestid,\n\t\t\t VM_PKT_DATA_INBAND, 0);\n}\n\nstatic void vss_on_reset(void)\n{\n\tif (cancel_delayed_work_sync(&vss_timeout_work))\n\t\tvss_respond_to_host(HV_E_FAIL);\n\tvss_transaction.state = HVUTIL_DEVICE_INIT;\n}\n\nint\nhv_vss_init(struct hv_util_service *srv)\n{\n\tif (vmbus_proto_version < VERSION_WIN8_1) {\n\t\tpr_warn(\"Integration service 'Backup (volume snapshot)'\"\n\t\t\t\" not supported on this host version.\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\trecv_buffer = srv->recv_buffer;\n\tvss_transaction.recv_channel = srv->channel;\n\tvss_transaction.recv_channel->max_pkt_size = VSS_MAX_PKT_SIZE;\n\n\t \n\tvss_transaction.state = HVUTIL_DEVICE_INIT;\n\n\thvt = hvutil_transport_init(vss_devname, CN_VSS_IDX, CN_VSS_VAL,\n\t\t\t\t    vss_on_msg, vss_on_reset);\n\tif (!hvt) {\n\t\tpr_warn(\"VSS: Failed to initialize transport\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void hv_vss_cancel_work(void)\n{\n\tcancel_delayed_work_sync(&vss_timeout_work);\n\tcancel_work_sync(&vss_handle_request_work);\n}\n\nint hv_vss_pre_suspend(void)\n{\n\tstruct vmbus_channel *channel = vss_transaction.recv_channel;\n\tstruct hv_vss_msg *vss_msg;\n\n\t \n\tvss_msg = kzalloc(sizeof(*vss_msg), GFP_KERNEL);\n\tif (!vss_msg)\n\t\treturn -ENOMEM;\n\n\ttasklet_disable(&channel->callback_event);\n\n\tvss_msg->vss_hdr.operation = VSS_OP_THAW;\n\n\t \n\thv_vss_cancel_work();\n\n\t \n\thvutil_transport_send(hvt, vss_msg, sizeof(*vss_msg), NULL);\n\n\tkfree(vss_msg);\n\n\tvss_transaction.state = HVUTIL_READY;\n\n\t \n\treturn 0;\n}\n\nint hv_vss_pre_resume(void)\n{\n\tstruct vmbus_channel *channel = vss_transaction.recv_channel;\n\n\ttasklet_enable(&channel->callback_event);\n\n\treturn 0;\n}\n\nvoid hv_vss_deinit(void)\n{\n\tvss_transaction.state = HVUTIL_DEVICE_DYING;\n\n\thv_vss_cancel_work();\n\n\thvutil_transport_destroy(hvt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}