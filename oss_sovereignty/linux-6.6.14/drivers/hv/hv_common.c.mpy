{
  "module_name": "hv_common.c",
  "hash_id": "fb41e3542b35798692ec8061e2019caabd41d94d02d0b98b55e7b8be38291501",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_common.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/bitfield.h>\n#include <linux/cpumask.h>\n#include <linux/sched/task_stack.h>\n#include <linux/panic_notifier.h>\n#include <linux/ptrace.h>\n#include <linux/kdebug.h>\n#include <linux/kmsg_dump.h>\n#include <linux/slab.h>\n#include <linux/dma-map-ops.h>\n#include <linux/set_memory.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/mshyperv.h>\n\n \nbool __weak hv_root_partition;\nEXPORT_SYMBOL_GPL(hv_root_partition);\n\nbool __weak hv_nested;\nEXPORT_SYMBOL_GPL(hv_nested);\n\nstruct ms_hyperv_info __weak ms_hyperv;\nEXPORT_SYMBOL_GPL(ms_hyperv);\n\nu32 *hv_vp_index;\nEXPORT_SYMBOL_GPL(hv_vp_index);\n\nu32 hv_max_vp_index;\nEXPORT_SYMBOL_GPL(hv_max_vp_index);\n\nvoid * __percpu *hyperv_pcpu_input_arg;\nEXPORT_SYMBOL_GPL(hyperv_pcpu_input_arg);\n\nvoid * __percpu *hyperv_pcpu_output_arg;\nEXPORT_SYMBOL_GPL(hyperv_pcpu_output_arg);\n\nstatic void hv_kmsg_dump_unregister(void);\n\nstatic struct ctl_table_header *hv_ctl_table_hdr;\n\n \n\nvoid __init hv_common_free(void)\n{\n\tunregister_sysctl_table(hv_ctl_table_hdr);\n\thv_ctl_table_hdr = NULL;\n\n\tif (ms_hyperv.misc_features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE)\n\t\thv_kmsg_dump_unregister();\n\n\tkfree(hv_vp_index);\n\thv_vp_index = NULL;\n\n\tfree_percpu(hyperv_pcpu_output_arg);\n\thyperv_pcpu_output_arg = NULL;\n\n\tfree_percpu(hyperv_pcpu_input_arg);\n\thyperv_pcpu_input_arg = NULL;\n}\n\n \n\nvoid *hv_alloc_hyperv_page(void)\n{\n\tBUILD_BUG_ON(PAGE_SIZE <  HV_HYP_PAGE_SIZE);\n\n\tif (PAGE_SIZE == HV_HYP_PAGE_SIZE)\n\t\treturn (void *)__get_free_page(GFP_KERNEL);\n\telse\n\t\treturn kmalloc(HV_HYP_PAGE_SIZE, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(hv_alloc_hyperv_page);\n\nvoid *hv_alloc_hyperv_zeroed_page(void)\n{\n\tif (PAGE_SIZE == HV_HYP_PAGE_SIZE)\n\t\treturn (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\n\telse\n\t\treturn kzalloc(HV_HYP_PAGE_SIZE, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(hv_alloc_hyperv_zeroed_page);\n\nvoid hv_free_hyperv_page(void *addr)\n{\n\tif (PAGE_SIZE == HV_HYP_PAGE_SIZE)\n\t\tfree_page((unsigned long)addr);\n\telse\n\t\tkfree(addr);\n}\nEXPORT_SYMBOL_GPL(hv_free_hyperv_page);\n\nstatic void *hv_panic_page;\n\n \nstatic int sysctl_record_panic_msg = 1;\n\n \nstatic struct ctl_table hv_ctl_table[] = {\n\t{\n\t\t.procname\t= \"hyperv_record_panic_msg\",\n\t\t.data\t\t= &sysctl_record_panic_msg,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{}\n};\n\nstatic int hv_die_panic_notify_crash(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *args);\n\nstatic struct notifier_block hyperv_die_report_block = {\n\t.notifier_call = hv_die_panic_notify_crash,\n};\n\nstatic struct notifier_block hyperv_panic_report_block = {\n\t.notifier_call = hv_die_panic_notify_crash,\n};\n\n \nstatic int hv_die_panic_notify_crash(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *args)\n{\n\tstruct pt_regs *regs;\n\tbool is_die;\n\n\t \n\tif (self == &hyperv_panic_report_block) {\n\t\tis_die = false;\n\t\tregs = current_pt_regs();\n\t} else {  \n\t\tif (val != DIE_OOPS)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tis_die = true;\n\t\tregs = ((struct die_args *)args)->regs;\n\t}\n\n\t \n\tif (!sysctl_record_panic_msg || !hv_panic_page)\n\t\thyperv_report_panic(regs, val, is_die);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void hv_kmsg_dump(struct kmsg_dumper *dumper,\n\t\t\t enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dump_iter iter;\n\tsize_t bytes_written;\n\n\t \n\tif (reason != KMSG_DUMP_PANIC || !sysctl_record_panic_msg)\n\t\treturn;\n\n\t \n\tkmsg_dump_rewind(&iter);\n\tkmsg_dump_get_buffer(&iter, false, hv_panic_page, HV_HYP_PAGE_SIZE,\n\t\t\t     &bytes_written);\n\tif (!bytes_written)\n\t\treturn;\n\t \n\thv_set_register(HV_REGISTER_CRASH_P0, 0);\n\thv_set_register(HV_REGISTER_CRASH_P1, 0);\n\thv_set_register(HV_REGISTER_CRASH_P2, 0);\n\thv_set_register(HV_REGISTER_CRASH_P3, virt_to_phys(hv_panic_page));\n\thv_set_register(HV_REGISTER_CRASH_P4, bytes_written);\n\n\t \n\thv_set_register(HV_REGISTER_CRASH_CTL,\n\t\t\t(HV_CRASH_CTL_CRASH_NOTIFY |\n\t\t\t HV_CRASH_CTL_CRASH_NOTIFY_MSG));\n}\n\nstatic struct kmsg_dumper hv_kmsg_dumper = {\n\t.dump = hv_kmsg_dump,\n};\n\nstatic void hv_kmsg_dump_unregister(void)\n{\n\tkmsg_dump_unregister(&hv_kmsg_dumper);\n\tunregister_die_notifier(&hyperv_die_report_block);\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &hyperv_panic_report_block);\n\n\thv_free_hyperv_page(hv_panic_page);\n\thv_panic_page = NULL;\n}\n\nstatic void hv_kmsg_dump_register(void)\n{\n\tint ret;\n\n\thv_panic_page = hv_alloc_hyperv_zeroed_page();\n\tif (!hv_panic_page) {\n\t\tpr_err(\"Hyper-V: panic message page memory allocation failed\\n\");\n\t\treturn;\n\t}\n\n\tret = kmsg_dump_register(&hv_kmsg_dumper);\n\tif (ret) {\n\t\tpr_err(\"Hyper-V: kmsg dump register error 0x%x\\n\", ret);\n\t\thv_free_hyperv_page(hv_panic_page);\n\t\thv_panic_page = NULL;\n\t}\n}\n\nint __init hv_common_init(void)\n{\n\tint i;\n\n\tif (hv_is_isolation_supported())\n\t\tsysctl_record_panic_msg = 0;\n\n\t \n\tif (ms_hyperv.misc_features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {\n\t\tu64 hyperv_crash_ctl;\n\n\t\tcrash_kexec_post_notifiers = true;\n\t\tpr_info(\"Hyper-V: enabling crash_kexec_post_notifiers\\n\");\n\n\t\t \n\t\thv_ctl_table_hdr = register_sysctl(\"kernel\", hv_ctl_table);\n\t\tif (!hv_ctl_table_hdr)\n\t\t\tpr_err(\"Hyper-V: sysctl table register error\");\n\n\t\t \n\t\thyperv_crash_ctl = hv_get_register(HV_REGISTER_CRASH_CTL);\n\t\tif (hyperv_crash_ctl & HV_CRASH_CTL_CRASH_NOTIFY_MSG)\n\t\t\thv_kmsg_dump_register();\n\n\t\tregister_die_notifier(&hyperv_die_report_block);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &hyperv_panic_report_block);\n\t}\n\n\t \n\thyperv_pcpu_input_arg = alloc_percpu(void  *);\n\tBUG_ON(!hyperv_pcpu_input_arg);\n\n\t \n\tif (hv_root_partition) {\n\t\thyperv_pcpu_output_arg = alloc_percpu(void *);\n\t\tBUG_ON(!hyperv_pcpu_output_arg);\n\t}\n\n\thv_vp_index = kmalloc_array(num_possible_cpus(), sizeof(*hv_vp_index),\n\t\t\t\t    GFP_KERNEL);\n\tif (!hv_vp_index) {\n\t\thv_common_free();\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < num_possible_cpus(); i++)\n\t\thv_vp_index[i] = VP_INVAL;\n\n\treturn 0;\n}\n\n \n\nint hv_common_cpu_init(unsigned int cpu)\n{\n\tvoid **inputarg, **outputarg;\n\tu64 msr_vp_index;\n\tgfp_t flags;\n\tint pgcount = hv_root_partition ? 2 : 1;\n\tvoid *mem;\n\tint ret;\n\n\t \n\tflags = irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinputarg = (void **)this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\t \n\tif (!*inputarg) {\n\t\tmem = kmalloc(pgcount * HV_HYP_PAGE_SIZE, flags);\n\t\tif (!mem)\n\t\t\treturn -ENOMEM;\n\n\t\tif (hv_root_partition) {\n\t\t\toutputarg = (void **)this_cpu_ptr(hyperv_pcpu_output_arg);\n\t\t\t*outputarg = (char *)mem + HV_HYP_PAGE_SIZE;\n\t\t}\n\n\t\tif (!ms_hyperv.paravisor_present &&\n\t\t    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {\n\t\t\tret = set_memory_decrypted((unsigned long)mem, pgcount);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tmemset(mem, 0x00, pgcount * HV_HYP_PAGE_SIZE);\n\t\t}\n\n\t\t \n\t\t*inputarg = mem;\n\t}\n\n\tmsr_vp_index = hv_get_register(HV_REGISTER_VP_INDEX);\n\n\thv_vp_index[cpu] = msr_vp_index;\n\n\tif (msr_vp_index > hv_max_vp_index)\n\t\thv_max_vp_index = msr_vp_index;\n\n\treturn 0;\n}\n\nint hv_common_cpu_die(unsigned int cpu)\n{\n\t \n\n\treturn 0;\n}\n\n \nbool hv_query_ext_cap(u64 cap_query)\n{\n\t \n\tstatic u64 hv_extended_cap __aligned(8);\n\tstatic bool hv_extended_cap_queried;\n\tu64 status;\n\n\t \n\tif (!(ms_hyperv.priv_high & HV_ENABLE_EXTENDED_HYPERCALLS))\n\t\treturn false;\n\n\t \n\tif (hv_extended_cap_queried)\n\t\treturn hv_extended_cap & cap_query;\n\n\tstatus = hv_do_hypercall(HV_EXT_CALL_QUERY_CAPABILITIES, NULL,\n\t\t\t\t &hv_extended_cap);\n\n\t \n\thv_extended_cap_queried = true;\n\tif (!hv_result_success(status)) {\n\t\tpr_err(\"Hyper-V: Extended query capabilities hypercall failed 0x%llx\\n\",\n\t\t       status);\n\t\treturn false;\n\t}\n\n\treturn hv_extended_cap & cap_query;\n}\nEXPORT_SYMBOL_GPL(hv_query_ext_cap);\n\nvoid hv_setup_dma_ops(struct device *dev, bool coherent)\n{\n\t \n\tarch_setup_dma_ops(dev, 0, 0, NULL, coherent);\n}\nEXPORT_SYMBOL_GPL(hv_setup_dma_ops);\n\nbool hv_is_hibernation_supported(void)\n{\n\treturn !hv_root_partition && acpi_sleep_state_supported(ACPI_STATE_S4);\n}\nEXPORT_SYMBOL_GPL(hv_is_hibernation_supported);\n\n \nstatic u64 __hv_read_ref_counter(void)\n{\n\treturn hv_get_register(HV_REGISTER_TIME_REF_COUNT);\n}\n\nu64 (*hv_read_reference_counter)(void) = __hv_read_ref_counter;\nEXPORT_SYMBOL_GPL(hv_read_reference_counter);\n\n \n\nbool __weak hv_is_isolation_supported(void)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(hv_is_isolation_supported);\n\nbool __weak hv_isolation_type_snp(void)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(hv_isolation_type_snp);\n\nbool __weak hv_isolation_type_tdx(void)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(hv_isolation_type_tdx);\n\nvoid __weak hv_setup_vmbus_handler(void (*handler)(void))\n{\n}\nEXPORT_SYMBOL_GPL(hv_setup_vmbus_handler);\n\nvoid __weak hv_remove_vmbus_handler(void)\n{\n}\nEXPORT_SYMBOL_GPL(hv_remove_vmbus_handler);\n\nvoid __weak hv_setup_kexec_handler(void (*handler)(void))\n{\n}\nEXPORT_SYMBOL_GPL(hv_setup_kexec_handler);\n\nvoid __weak hv_remove_kexec_handler(void)\n{\n}\nEXPORT_SYMBOL_GPL(hv_remove_kexec_handler);\n\nvoid __weak hv_setup_crash_handler(void (*handler)(struct pt_regs *regs))\n{\n}\nEXPORT_SYMBOL_GPL(hv_setup_crash_handler);\n\nvoid __weak hv_remove_crash_handler(void)\n{\n}\nEXPORT_SYMBOL_GPL(hv_remove_crash_handler);\n\nvoid __weak hyperv_cleanup(void)\n{\n}\nEXPORT_SYMBOL_GPL(hyperv_cleanup);\n\nu64 __weak hv_ghcb_hypercall(u64 control, void *input, void *output, u32 input_size)\n{\n\treturn HV_STATUS_INVALID_PARAMETER;\n}\nEXPORT_SYMBOL_GPL(hv_ghcb_hypercall);\n\nu64 __weak hv_tdx_hypercall(u64 control, u64 param1, u64 param2)\n{\n\treturn HV_STATUS_INVALID_PARAMETER;\n}\nEXPORT_SYMBOL_GPL(hv_tdx_hypercall);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}