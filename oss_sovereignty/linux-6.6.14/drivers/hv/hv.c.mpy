{
  "module_name": "hv.c",
  "hash_id": "e55b1308e170789e5a80ddbed53e4a56bfce77c72c7bcd06dd5ad91a48d88fb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/hyperv.h>\n#include <linux/random.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <clocksource/hyperv_timer.h>\n#include <asm/mshyperv.h>\n#include <linux/set_memory.h>\n#include \"hyperv_vmbus.h\"\n\n \nstruct hv_context hv_context;\n\n \nint hv_init(void)\n{\n\thv_context.cpu_context = alloc_percpu(struct hv_per_cpu_context);\n\tif (!hv_context.cpu_context)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nint hv_post_message(union hv_connection_id connection_id,\n\t\t  enum hv_message_type message_type,\n\t\t  void *payload, size_t payload_size)\n{\n\tstruct hv_input_post_message *aligned_msg;\n\tunsigned long flags;\n\tu64 status;\n\n\tif (payload_size > HV_MESSAGE_PAYLOAD_BYTE_COUNT)\n\t\treturn -EMSGSIZE;\n\n\tlocal_irq_save(flags);\n\n\t \n\tif (hv_isolation_type_tdx() && ms_hyperv.paravisor_present)\n\t\taligned_msg = this_cpu_ptr(hv_context.cpu_context)->post_msg_page;\n\telse\n\t\taligned_msg = *this_cpu_ptr(hyperv_pcpu_input_arg);\n\n\taligned_msg->connectionid = connection_id;\n\taligned_msg->reserved = 0;\n\taligned_msg->message_type = message_type;\n\taligned_msg->payload_size = payload_size;\n\tmemcpy((void *)aligned_msg->payload, payload, payload_size);\n\n\tif (ms_hyperv.paravisor_present) {\n\t\tif (hv_isolation_type_tdx())\n\t\t\tstatus = hv_tdx_hypercall(HVCALL_POST_MESSAGE,\n\t\t\t\t\t\t  virt_to_phys(aligned_msg), 0);\n\t\telse if (hv_isolation_type_snp())\n\t\t\tstatus = hv_ghcb_hypercall(HVCALL_POST_MESSAGE,\n\t\t\t\t\t\t   aligned_msg, NULL,\n\t\t\t\t\t\t   sizeof(*aligned_msg));\n\t\telse\n\t\t\tstatus = HV_STATUS_INVALID_PARAMETER;\n\t} else {\n\t\tstatus = hv_do_hypercall(HVCALL_POST_MESSAGE,\n\t\t\t\taligned_msg, NULL);\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn hv_result(status);\n}\n\nint hv_synic_alloc(void)\n{\n\tint cpu, ret = -ENOMEM;\n\tstruct hv_per_cpu_context *hv_cpu;\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\thv_cpu = per_cpu_ptr(hv_context.cpu_context, cpu);\n\t\tmemset(hv_cpu, 0, sizeof(*hv_cpu));\n\t}\n\n\thv_context.hv_numa_map = kcalloc(nr_node_ids, sizeof(struct cpumask),\n\t\t\t\t\t GFP_KERNEL);\n\tif (hv_context.hv_numa_map == NULL) {\n\t\tpr_err(\"Unable to allocate NUMA map\\n\");\n\t\tgoto err;\n\t}\n\n\tfor_each_present_cpu(cpu) {\n\t\thv_cpu = per_cpu_ptr(hv_context.cpu_context, cpu);\n\n\t\ttasklet_init(&hv_cpu->msg_dpc,\n\t\t\t     vmbus_on_msg_dpc, (unsigned long) hv_cpu);\n\n\t\tif (ms_hyperv.paravisor_present && hv_isolation_type_tdx()) {\n\t\t\thv_cpu->post_msg_page = (void *)get_zeroed_page(GFP_ATOMIC);\n\t\t\tif (hv_cpu->post_msg_page == NULL) {\n\t\t\t\tpr_err(\"Unable to allocate post msg page\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = set_memory_decrypted((unsigned long)hv_cpu->post_msg_page, 1);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to decrypt post msg page: %d\\n\", ret);\n\t\t\t\t \n\t\t\t\thv_cpu->post_msg_page = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tmemset(hv_cpu->post_msg_page, 0, PAGE_SIZE);\n\t\t}\n\n\t\t \n\t\tif (!ms_hyperv.paravisor_present && !hv_root_partition) {\n\t\t\thv_cpu->synic_message_page =\n\t\t\t\t(void *)get_zeroed_page(GFP_ATOMIC);\n\t\t\tif (hv_cpu->synic_message_page == NULL) {\n\t\t\t\tpr_err(\"Unable to allocate SYNIC message page\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thv_cpu->synic_event_page =\n\t\t\t\t(void *)get_zeroed_page(GFP_ATOMIC);\n\t\t\tif (hv_cpu->synic_event_page == NULL) {\n\t\t\t\tpr_err(\"Unable to allocate SYNIC event page\\n\");\n\n\t\t\t\tfree_page((unsigned long)hv_cpu->synic_message_page);\n\t\t\t\thv_cpu->synic_message_page = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!ms_hyperv.paravisor_present &&\n\t\t    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {\n\t\t\tret = set_memory_decrypted((unsigned long)\n\t\t\t\thv_cpu->synic_message_page, 1);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to decrypt SYNIC msg page: %d\\n\", ret);\n\t\t\t\thv_cpu->synic_message_page = NULL;\n\n\t\t\t\t \n\t\t\t\tfree_page((unsigned long)hv_cpu->synic_event_page);\n\t\t\t\thv_cpu->synic_event_page = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = set_memory_decrypted((unsigned long)\n\t\t\t\thv_cpu->synic_event_page, 1);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to decrypt SYNIC event page: %d\\n\", ret);\n\t\t\t\thv_cpu->synic_event_page = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tmemset(hv_cpu->synic_message_page, 0, PAGE_SIZE);\n\t\t\tmemset(hv_cpu->synic_event_page, 0, PAGE_SIZE);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\treturn ret;\n}\n\n\nvoid hv_synic_free(void)\n{\n\tint cpu, ret;\n\n\tfor_each_present_cpu(cpu) {\n\t\tstruct hv_per_cpu_context *hv_cpu\n\t\t\t= per_cpu_ptr(hv_context.cpu_context, cpu);\n\n\t\t \n\t\tif (ms_hyperv.paravisor_present && hv_isolation_type_tdx()) {\n\t\t\tif (hv_cpu->post_msg_page) {\n\t\t\t\tret = set_memory_encrypted((unsigned long)\n\t\t\t\t\thv_cpu->post_msg_page, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_err(\"Failed to encrypt post msg page: %d\\n\", ret);\n\t\t\t\t\thv_cpu->post_msg_page = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ms_hyperv.paravisor_present &&\n\t\t    (hv_isolation_type_snp() || hv_isolation_type_tdx())) {\n\t\t\tif (hv_cpu->synic_message_page) {\n\t\t\t\tret = set_memory_encrypted((unsigned long)\n\t\t\t\t\thv_cpu->synic_message_page, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_err(\"Failed to encrypt SYNIC msg page: %d\\n\", ret);\n\t\t\t\t\thv_cpu->synic_message_page = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hv_cpu->synic_event_page) {\n\t\t\t\tret = set_memory_encrypted((unsigned long)\n\t\t\t\t\thv_cpu->synic_event_page, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_err(\"Failed to encrypt SYNIC event page: %d\\n\", ret);\n\t\t\t\t\thv_cpu->synic_event_page = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree_page((unsigned long)hv_cpu->post_msg_page);\n\t\tfree_page((unsigned long)hv_cpu->synic_event_page);\n\t\tfree_page((unsigned long)hv_cpu->synic_message_page);\n\t}\n\n\tkfree(hv_context.hv_numa_map);\n}\n\n \nvoid hv_synic_enable_regs(unsigned int cpu)\n{\n\tstruct hv_per_cpu_context *hv_cpu\n\t\t= per_cpu_ptr(hv_context.cpu_context, cpu);\n\tunion hv_synic_simp simp;\n\tunion hv_synic_siefp siefp;\n\tunion hv_synic_sint shared_sint;\n\tunion hv_synic_scontrol sctrl;\n\n\t \n\tsimp.as_uint64 = hv_get_register(HV_REGISTER_SIMP);\n\tsimp.simp_enabled = 1;\n\n\tif (ms_hyperv.paravisor_present || hv_root_partition) {\n\t\t \n\t\tu64 base = (simp.base_simp_gpa << HV_HYP_PAGE_SHIFT) &\n\t\t\t\t~ms_hyperv.shared_gpa_boundary;\n\t\thv_cpu->synic_message_page\n\t\t\t= (void *)ioremap_cache(base, HV_HYP_PAGE_SIZE);\n\t\tif (!hv_cpu->synic_message_page)\n\t\t\tpr_err(\"Fail to map synic message page.\\n\");\n\t} else {\n\t\tsimp.base_simp_gpa = virt_to_phys(hv_cpu->synic_message_page)\n\t\t\t>> HV_HYP_PAGE_SHIFT;\n\t}\n\n\thv_set_register(HV_REGISTER_SIMP, simp.as_uint64);\n\n\t \n\tsiefp.as_uint64 = hv_get_register(HV_REGISTER_SIEFP);\n\tsiefp.siefp_enabled = 1;\n\n\tif (ms_hyperv.paravisor_present || hv_root_partition) {\n\t\t \n\t\tu64 base = (siefp.base_siefp_gpa << HV_HYP_PAGE_SHIFT) &\n\t\t\t\t~ms_hyperv.shared_gpa_boundary;\n\t\thv_cpu->synic_event_page\n\t\t\t= (void *)ioremap_cache(base, HV_HYP_PAGE_SIZE);\n\t\tif (!hv_cpu->synic_event_page)\n\t\t\tpr_err(\"Fail to map synic event page.\\n\");\n\t} else {\n\t\tsiefp.base_siefp_gpa = virt_to_phys(hv_cpu->synic_event_page)\n\t\t\t>> HV_HYP_PAGE_SHIFT;\n\t}\n\n\thv_set_register(HV_REGISTER_SIEFP, siefp.as_uint64);\n\n\t \n\tif (vmbus_irq != -1)\n\t\tenable_percpu_irq(vmbus_irq, 0);\n\tshared_sint.as_uint64 = hv_get_register(HV_REGISTER_SINT0 +\n\t\t\t\t\tVMBUS_MESSAGE_SINT);\n\n\tshared_sint.vector = vmbus_interrupt;\n\tshared_sint.masked = false;\n\n\t \n#ifdef HV_DEPRECATING_AEOI_RECOMMENDED\n\tshared_sint.auto_eoi =\n\t\t\t!(ms_hyperv.hints & HV_DEPRECATING_AEOI_RECOMMENDED);\n#else\n\tshared_sint.auto_eoi = 0;\n#endif\n\thv_set_register(HV_REGISTER_SINT0 + VMBUS_MESSAGE_SINT,\n\t\t\t\tshared_sint.as_uint64);\n\n\t \n\tsctrl.as_uint64 = hv_get_register(HV_REGISTER_SCONTROL);\n\tsctrl.enable = 1;\n\n\thv_set_register(HV_REGISTER_SCONTROL, sctrl.as_uint64);\n}\n\nint hv_synic_init(unsigned int cpu)\n{\n\thv_synic_enable_regs(cpu);\n\n\thv_stimer_legacy_init(cpu, VMBUS_MESSAGE_SINT);\n\n\treturn 0;\n}\n\n \nvoid hv_synic_disable_regs(unsigned int cpu)\n{\n\tstruct hv_per_cpu_context *hv_cpu\n\t\t= per_cpu_ptr(hv_context.cpu_context, cpu);\n\tunion hv_synic_sint shared_sint;\n\tunion hv_synic_simp simp;\n\tunion hv_synic_siefp siefp;\n\tunion hv_synic_scontrol sctrl;\n\n\tshared_sint.as_uint64 = hv_get_register(HV_REGISTER_SINT0 +\n\t\t\t\t\tVMBUS_MESSAGE_SINT);\n\n\tshared_sint.masked = 1;\n\n\t \n\t \n\thv_set_register(HV_REGISTER_SINT0 + VMBUS_MESSAGE_SINT,\n\t\t\t\tshared_sint.as_uint64);\n\n\tsimp.as_uint64 = hv_get_register(HV_REGISTER_SIMP);\n\t \n\tsimp.simp_enabled = 0;\n\tif (ms_hyperv.paravisor_present || hv_root_partition) {\n\t\tiounmap(hv_cpu->synic_message_page);\n\t\thv_cpu->synic_message_page = NULL;\n\t} else {\n\t\tsimp.base_simp_gpa = 0;\n\t}\n\n\thv_set_register(HV_REGISTER_SIMP, simp.as_uint64);\n\n\tsiefp.as_uint64 = hv_get_register(HV_REGISTER_SIEFP);\n\tsiefp.siefp_enabled = 0;\n\n\tif (ms_hyperv.paravisor_present || hv_root_partition) {\n\t\tiounmap(hv_cpu->synic_event_page);\n\t\thv_cpu->synic_event_page = NULL;\n\t} else {\n\t\tsiefp.base_siefp_gpa = 0;\n\t}\n\n\thv_set_register(HV_REGISTER_SIEFP, siefp.as_uint64);\n\n\t \n\tsctrl.as_uint64 = hv_get_register(HV_REGISTER_SCONTROL);\n\tsctrl.enable = 0;\n\thv_set_register(HV_REGISTER_SCONTROL, sctrl.as_uint64);\n\n\tif (vmbus_irq != -1)\n\t\tdisable_percpu_irq(vmbus_irq);\n}\n\n#define HV_MAX_TRIES 3\n \nstatic bool hv_synic_event_pending(void)\n{\n\tstruct hv_per_cpu_context *hv_cpu = this_cpu_ptr(hv_context.cpu_context);\n\tunion hv_synic_event_flags *event =\n\t\t(union hv_synic_event_flags *)hv_cpu->synic_event_page + VMBUS_MESSAGE_SINT;\n\tunsigned long *recv_int_page = event->flags;  \n\tbool pending;\n\tu32 relid;\n\tint tries = 0;\n\nretry:\n\tpending = false;\n\tfor_each_set_bit(relid, recv_int_page, HV_EVENT_FLAGS_COUNT) {\n\t\t \n\t\tif (relid == 0)\n\t\t\tcontinue;\n\t\tpending = true;\n\t\tbreak;\n\t}\n\tif (pending && tries++ < HV_MAX_TRIES) {\n\t\tusleep_range(10000, 20000);\n\t\tgoto retry;\n\t}\n\treturn pending;\n}\n\nint hv_synic_cleanup(unsigned int cpu)\n{\n\tstruct vmbus_channel *channel, *sc;\n\tbool channel_found = false;\n\n\tif (vmbus_connection.conn_state != CONNECTED)\n\t\tgoto always_cleanup;\n\n\t \n\tif (cpu == VMBUS_CONNECT_CPU)\n\t\treturn -EBUSY;\n\n\t \n\tmutex_lock(&vmbus_connection.channel_mutex);\n\tlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\n\t\tif (channel->target_cpu == cpu) {\n\t\t\tchannel_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tlist_for_each_entry(sc, &channel->sc_list, sc_list) {\n\t\t\tif (sc->target_cpu == cpu) {\n\t\t\t\tchannel_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (channel_found)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&vmbus_connection.channel_mutex);\n\n\tif (channel_found)\n\t\treturn -EBUSY;\n\n\t \n\tif (vmbus_proto_version >= VERSION_WIN10_V4_1 && hv_synic_event_pending())\n\t\treturn -EBUSY;\n\nalways_cleanup:\n\thv_stimer_legacy_cleanup(cpu);\n\n\thv_synic_disable_regs(cpu);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}