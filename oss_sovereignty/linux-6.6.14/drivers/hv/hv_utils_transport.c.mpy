{
  "module_name": "hv_utils_transport.c",
  "hash_id": "e5790fa1c55ed6d27a069719dd04dd27782bd50149458a456833cd463f4dadad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/hv_utils_transport.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n\n#include \"hyperv_vmbus.h\"\n#include \"hv_utils_transport.h\"\n\nstatic DEFINE_SPINLOCK(hvt_list_lock);\nstatic LIST_HEAD(hvt_list);\n\nstatic void hvt_reset(struct hvutil_transport *hvt)\n{\n\tkfree(hvt->outmsg);\n\thvt->outmsg = NULL;\n\thvt->outmsg_len = 0;\n\tif (hvt->on_reset)\n\t\thvt->on_reset();\n}\n\nstatic ssize_t hvt_op_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct hvutil_transport *hvt;\n\tint ret;\n\n\thvt = container_of(file->f_op, struct hvutil_transport, fops);\n\n\tif (wait_event_interruptible(hvt->outmsg_q, hvt->outmsg_len > 0 ||\n\t\t\t\t     hvt->mode != HVUTIL_TRANSPORT_CHARDEV))\n\t\treturn -EINTR;\n\n\tmutex_lock(&hvt->lock);\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_DESTROY) {\n\t\tret = -EBADF;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!hvt->outmsg) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tif (count < hvt->outmsg_len) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!copy_to_user(buf, hvt->outmsg, hvt->outmsg_len))\n\t\tret = hvt->outmsg_len;\n\telse\n\t\tret = -EFAULT;\n\n\tkfree(hvt->outmsg);\n\thvt->outmsg = NULL;\n\thvt->outmsg_len = 0;\n\n\tif (hvt->on_read)\n\t\thvt->on_read();\n\thvt->on_read = NULL;\n\nout_unlock:\n\tmutex_unlock(&hvt->lock);\n\treturn ret;\n}\n\nstatic ssize_t hvt_op_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct hvutil_transport *hvt;\n\tu8 *inmsg;\n\tint ret;\n\n\thvt = container_of(file->f_op, struct hvutil_transport, fops);\n\n\tinmsg = memdup_user(buf, count);\n\tif (IS_ERR(inmsg))\n\t\treturn PTR_ERR(inmsg);\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_DESTROY)\n\t\tret = -EBADF;\n\telse\n\t\tret = hvt->on_msg(inmsg, count);\n\n\tkfree(inmsg);\n\n\treturn ret ? ret : count;\n}\n\nstatic __poll_t hvt_op_poll(struct file *file, poll_table *wait)\n{\n\tstruct hvutil_transport *hvt;\n\n\thvt = container_of(file->f_op, struct hvutil_transport, fops);\n\n\tpoll_wait(file, &hvt->outmsg_q, wait);\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_DESTROY)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tif (hvt->outmsg_len > 0)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\nstatic int hvt_op_open(struct inode *inode, struct file *file)\n{\n\tstruct hvutil_transport *hvt;\n\tint ret = 0;\n\tbool issue_reset = false;\n\n\thvt = container_of(file->f_op, struct hvutil_transport, fops);\n\n\tmutex_lock(&hvt->lock);\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_DESTROY) {\n\t\tret = -EBADF;\n\t} else if (hvt->mode == HVUTIL_TRANSPORT_INIT) {\n\t\t \n\t\thvt->mode = HVUTIL_TRANSPORT_CHARDEV;\n\t}\n\telse if (hvt->mode == HVUTIL_TRANSPORT_NETLINK) {\n\t\t \n\t\tissue_reset = true;\n\t\thvt->mode = HVUTIL_TRANSPORT_CHARDEV;\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\n\tif (issue_reset)\n\t\thvt_reset(hvt);\n\n\tmutex_unlock(&hvt->lock);\n\n\treturn ret;\n}\n\nstatic void hvt_transport_free(struct hvutil_transport *hvt)\n{\n\tmisc_deregister(&hvt->mdev);\n\tkfree(hvt->outmsg);\n\tkfree(hvt);\n}\n\nstatic int hvt_op_release(struct inode *inode, struct file *file)\n{\n\tstruct hvutil_transport *hvt;\n\tint mode_old;\n\n\thvt = container_of(file->f_op, struct hvutil_transport, fops);\n\n\tmutex_lock(&hvt->lock);\n\tmode_old = hvt->mode;\n\tif (hvt->mode != HVUTIL_TRANSPORT_DESTROY)\n\t\thvt->mode = HVUTIL_TRANSPORT_INIT;\n\t \n\thvt_reset(hvt);\n\n\tif (mode_old == HVUTIL_TRANSPORT_DESTROY)\n\t\tcomplete(&hvt->release);\n\n\tmutex_unlock(&hvt->lock);\n\n\treturn 0;\n}\n\nstatic void hvt_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n{\n\tstruct hvutil_transport *hvt, *hvt_found = NULL;\n\n\tspin_lock(&hvt_list_lock);\n\tlist_for_each_entry(hvt, &hvt_list, list) {\n\t\tif (hvt->cn_id.idx == msg->id.idx &&\n\t\t    hvt->cn_id.val == msg->id.val) {\n\t\t\thvt_found = hvt;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hvt_list_lock);\n\tif (!hvt_found) {\n\t\tpr_warn(\"hvt_cn_callback: spurious message received!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&hvt->lock);\n\tif (hvt->mode == HVUTIL_TRANSPORT_INIT)\n\t\thvt->mode = HVUTIL_TRANSPORT_NETLINK;\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_NETLINK)\n\t\thvt_found->on_msg(msg->data, msg->len);\n\telse\n\t\tpr_warn(\"hvt_cn_callback: unexpected netlink message!\\n\");\n\tmutex_unlock(&hvt->lock);\n}\n\nint hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len,\n\t\t\t  void (*on_read_cb)(void))\n{\n\tstruct cn_msg *cn_msg;\n\tint ret = 0;\n\n\tif (hvt->mode == HVUTIL_TRANSPORT_INIT ||\n\t    hvt->mode == HVUTIL_TRANSPORT_DESTROY) {\n\t\treturn -EINVAL;\n\t} else if (hvt->mode == HVUTIL_TRANSPORT_NETLINK) {\n\t\tcn_msg = kzalloc(sizeof(*cn_msg) + len, GFP_ATOMIC);\n\t\tif (!cn_msg)\n\t\t\treturn -ENOMEM;\n\t\tcn_msg->id.idx = hvt->cn_id.idx;\n\t\tcn_msg->id.val = hvt->cn_id.val;\n\t\tcn_msg->len = len;\n\t\tmemcpy(cn_msg->data, msg, len);\n\t\tret = cn_netlink_send(cn_msg, 0, 0, GFP_ATOMIC);\n\t\tkfree(cn_msg);\n\t\t \n\t\tif (on_read_cb)\n\t\t\ton_read_cb();\n\t\treturn ret;\n\t}\n\t \n\tmutex_lock(&hvt->lock);\n\tif (hvt->mode != HVUTIL_TRANSPORT_CHARDEV) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (hvt->outmsg) {\n\t\t \n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\thvt->outmsg = kzalloc(len, GFP_KERNEL);\n\tif (hvt->outmsg) {\n\t\tmemcpy(hvt->outmsg, msg, len);\n\t\thvt->outmsg_len = len;\n\t\thvt->on_read = on_read_cb;\n\t\twake_up_interruptible(&hvt->outmsg_q);\n\t} else\n\t\tret = -ENOMEM;\nout_unlock:\n\tmutex_unlock(&hvt->lock);\n\treturn ret;\n}\n\nstruct hvutil_transport *hvutil_transport_init(const char *name,\n\t\t\t\t\t       u32 cn_idx, u32 cn_val,\n\t\t\t\t\t       int (*on_msg)(void *, int),\n\t\t\t\t\t       void (*on_reset)(void))\n{\n\tstruct hvutil_transport *hvt;\n\n\thvt = kzalloc(sizeof(*hvt), GFP_KERNEL);\n\tif (!hvt)\n\t\treturn NULL;\n\n\thvt->cn_id.idx = cn_idx;\n\thvt->cn_id.val = cn_val;\n\n\thvt->mdev.minor = MISC_DYNAMIC_MINOR;\n\thvt->mdev.name = name;\n\n\thvt->fops.owner = THIS_MODULE;\n\thvt->fops.read = hvt_op_read;\n\thvt->fops.write = hvt_op_write;\n\thvt->fops.poll = hvt_op_poll;\n\thvt->fops.open = hvt_op_open;\n\thvt->fops.release = hvt_op_release;\n\n\thvt->mdev.fops = &hvt->fops;\n\n\tinit_waitqueue_head(&hvt->outmsg_q);\n\tmutex_init(&hvt->lock);\n\tinit_completion(&hvt->release);\n\n\tspin_lock(&hvt_list_lock);\n\tlist_add(&hvt->list, &hvt_list);\n\tspin_unlock(&hvt_list_lock);\n\n\thvt->on_msg = on_msg;\n\thvt->on_reset = on_reset;\n\n\tif (misc_register(&hvt->mdev))\n\t\tgoto err_free_hvt;\n\n\t \n\tif (hvt->cn_id.idx > 0 && hvt->cn_id.val > 0 &&\n\t    cn_add_callback(&hvt->cn_id, name, hvt_cn_callback))\n\t\tgoto err_free_hvt;\n\n\treturn hvt;\n\nerr_free_hvt:\n\tspin_lock(&hvt_list_lock);\n\tlist_del(&hvt->list);\n\tspin_unlock(&hvt_list_lock);\n\tkfree(hvt);\n\treturn NULL;\n}\n\nvoid hvutil_transport_destroy(struct hvutil_transport *hvt)\n{\n\tint mode_old;\n\n\tmutex_lock(&hvt->lock);\n\tmode_old = hvt->mode;\n\thvt->mode = HVUTIL_TRANSPORT_DESTROY;\n\twake_up_interruptible(&hvt->outmsg_q);\n\tmutex_unlock(&hvt->lock);\n\n\t \n\tspin_lock(&hvt_list_lock);\n\tlist_del(&hvt->list);\n\tspin_unlock(&hvt_list_lock);\n\tif (hvt->cn_id.idx > 0 && hvt->cn_id.val > 0)\n\t\tcn_del_callback(&hvt->cn_id);\n\n\tif (mode_old == HVUTIL_TRANSPORT_CHARDEV)\n\t\twait_for_completion(&hvt->release);\n\n\thvt_transport_free(hvt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}