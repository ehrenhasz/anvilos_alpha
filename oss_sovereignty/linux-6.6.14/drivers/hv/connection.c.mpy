{
  "module_name": "connection.c",
  "hash_id": "9c3c3566dc94c7a7fa11c6b886685133e13a8f8f8101ce8f63dbebaed24d209a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hv/connection.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/hyperv.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/set_memory.h>\n#include <asm/mshyperv.h>\n\n#include \"hyperv_vmbus.h\"\n\n\nstruct vmbus_connection vmbus_connection = {\n\t.conn_state\t\t= DISCONNECTED,\n\t.unload_event\t\t= COMPLETION_INITIALIZER(\n\t\t\t\t  vmbus_connection.unload_event),\n\t.next_gpadl_handle\t= ATOMIC_INIT(0xE1E10),\n\n\t.ready_for_suspend_event = COMPLETION_INITIALIZER(\n\t\t\t\t  vmbus_connection.ready_for_suspend_event),\n\t.ready_for_resume_event\t= COMPLETION_INITIALIZER(\n\t\t\t\t  vmbus_connection.ready_for_resume_event),\n};\nEXPORT_SYMBOL_GPL(vmbus_connection);\n\n \n__u32 vmbus_proto_version;\nEXPORT_SYMBOL_GPL(vmbus_proto_version);\n\n \nstatic __u32 vmbus_versions[] = {\n\tVERSION_WIN10_V5_3,\n\tVERSION_WIN10_V5_2,\n\tVERSION_WIN10_V5_1,\n\tVERSION_WIN10_V5,\n\tVERSION_WIN10_V4_1,\n\tVERSION_WIN10,\n\tVERSION_WIN8_1,\n\tVERSION_WIN8\n};\n\n \nstatic uint max_version = VERSION_WIN10_V5_3;\n\nmodule_param(max_version, uint, S_IRUGO);\nMODULE_PARM_DESC(max_version,\n\t\t \"Maximal VMBus protocol version which can be negotiated\");\n\nint vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)\n{\n\tint ret = 0;\n\tstruct vmbus_channel_initiate_contact *msg;\n\tunsigned long flags;\n\n\tinit_completion(&msginfo->waitevent);\n\n\tmsg = (struct vmbus_channel_initiate_contact *)msginfo->msg;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;\n\tmsg->vmbus_version_requested = version;\n\n\t \n\tif (version >= VERSION_WIN10_V5) {\n\t\tmsg->msg_sint = VMBUS_MESSAGE_SINT;\n\t\tmsg->msg_vtl = ms_hyperv.vtl;\n\t\tvmbus_connection.msg_conn_id = VMBUS_MESSAGE_CONNECTION_ID_4;\n\t} else {\n\t\tmsg->interrupt_page = virt_to_phys(vmbus_connection.int_page);\n\t\tvmbus_connection.msg_conn_id = VMBUS_MESSAGE_CONNECTION_ID;\n\t}\n\n\t \n\tmsg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]) |\n\t\t\t\tms_hyperv.shared_gpa_boundary;\n\tmsg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]) |\n\t\t\t\tms_hyperv.shared_gpa_boundary;\n\n\tmsg->target_vcpu = hv_cpu_number_to_vp_number(VMBUS_CONNECT_CPU);\n\n\t \n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&msginfo->msglistentry,\n\t\t      &vmbus_connection.chn_msg_list);\n\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tret = vmbus_post_msg(msg,\n\t\t\t     sizeof(struct vmbus_channel_initiate_contact),\n\t\t\t     true);\n\n\ttrace_vmbus_negotiate_version(msg, ret);\n\n\tif (ret != 0) {\n\t\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\t\tlist_del(&msginfo->msglistentry);\n\t\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,\n\t\t\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t \n\twait_for_completion(&msginfo->waitevent);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&msginfo->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\t \n\tif (msginfo->response.version_response.version_supported) {\n\t\tvmbus_connection.conn_state = CONNECTED;\n\n\t\tif (version >= VERSION_WIN10_V5)\n\t\t\tvmbus_connection.msg_conn_id =\n\t\t\t\tmsginfo->response.version_response.msg_conn_id;\n\t} else {\n\t\treturn -ECONNREFUSED;\n\t}\n\n\treturn ret;\n}\n\n \nint vmbus_connect(void)\n{\n\tstruct vmbus_channel_msginfo *msginfo = NULL;\n\tint i, ret = 0;\n\t__u32 version;\n\n\t \n\tvmbus_connection.conn_state = CONNECTING;\n\tvmbus_connection.work_queue = create_workqueue(\"hv_vmbus_con\");\n\tif (!vmbus_connection.work_queue) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tvmbus_connection.rescind_work_queue =\n\t\tcreate_workqueue(\"hv_vmbus_rescind\");\n\tif (!vmbus_connection.rescind_work_queue) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tvmbus_connection.ignore_any_offer_msg = false;\n\n\tvmbus_connection.handle_primary_chan_wq =\n\t\tcreate_workqueue(\"hv_pri_chan\");\n\tif (!vmbus_connection.handle_primary_chan_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tvmbus_connection.handle_sub_chan_wq =\n\t\tcreate_workqueue(\"hv_sub_chan\");\n\tif (!vmbus_connection.handle_sub_chan_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tINIT_LIST_HEAD(&vmbus_connection.chn_msg_list);\n\tspin_lock_init(&vmbus_connection.channelmsg_lock);\n\n\tINIT_LIST_HEAD(&vmbus_connection.chn_list);\n\tmutex_init(&vmbus_connection.channel_mutex);\n\n\t \n\tvmbus_connection.int_page = hv_alloc_hyperv_zeroed_page();\n\tif (vmbus_connection.int_page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tvmbus_connection.recv_int_page = vmbus_connection.int_page;\n\tvmbus_connection.send_int_page =\n\t\t(void *)((unsigned long)vmbus_connection.int_page +\n\t\t\t(HV_HYP_PAGE_SIZE >> 1));\n\n\t \n\tvmbus_connection.monitor_pages[0] = hv_alloc_hyperv_page();\n\tvmbus_connection.monitor_pages[1] = hv_alloc_hyperv_page();\n\tif ((vmbus_connection.monitor_pages[0] == NULL) ||\n\t    (vmbus_connection.monitor_pages[1] == NULL)) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tret = set_memory_decrypted((unsigned long)\n\t\t\t\tvmbus_connection.monitor_pages[0], 1);\n\tret |= set_memory_decrypted((unsigned long)\n\t\t\t\tvmbus_connection.monitor_pages[1], 1);\n\tif (ret)\n\t\tgoto cleanup;\n\n\t \n\tmemset(vmbus_connection.monitor_pages[0], 0x00, HV_HYP_PAGE_SIZE);\n\tmemset(vmbus_connection.monitor_pages[1], 0x00, HV_HYP_PAGE_SIZE);\n\n\tmsginfo = kzalloc(sizeof(*msginfo) +\n\t\t\t  sizeof(struct vmbus_channel_initiate_contact),\n\t\t\t  GFP_KERNEL);\n\tif (msginfo == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tfor (i = 0; ; i++) {\n\t\tif (i == ARRAY_SIZE(vmbus_versions)) {\n\t\t\tret = -EDOM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tversion = vmbus_versions[i];\n\t\tif (version > max_version)\n\t\t\tcontinue;\n\n\t\tret = vmbus_negotiate_version(msginfo, version);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tgoto cleanup;\n\n\t\tif (vmbus_connection.conn_state == CONNECTED)\n\t\t\tbreak;\n\t}\n\n\tif (hv_is_isolation_supported() && version < VERSION_WIN10_V5_2) {\n\t\tpr_err(\"Invalid VMBus version %d.%d (expected >= %d.%d) from the host supporting isolation\\n\",\n\t\t       version >> 16, version & 0xFFFF, VERSION_WIN10_V5_2 >> 16, VERSION_WIN10_V5_2 & 0xFFFF);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tvmbus_proto_version = version;\n\tpr_info(\"Vmbus version:%d.%d\\n\",\n\t\tversion >> 16, version & 0xFFFF);\n\n\tvmbus_connection.channels = kcalloc(MAX_CHANNEL_RELIDS,\n\t\t\t\t\t    sizeof(struct vmbus_channel *),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (vmbus_connection.channels == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tkfree(msginfo);\n\treturn 0;\n\ncleanup:\n\tpr_err(\"Unable to connect to host\\n\");\n\n\tvmbus_connection.conn_state = DISCONNECTED;\n\tvmbus_disconnect();\n\n\tkfree(msginfo);\n\n\treturn ret;\n}\n\nvoid vmbus_disconnect(void)\n{\n\t \n\tvmbus_initiate_unload(false);\n\n\tif (vmbus_connection.handle_sub_chan_wq)\n\t\tdestroy_workqueue(vmbus_connection.handle_sub_chan_wq);\n\n\tif (vmbus_connection.handle_primary_chan_wq)\n\t\tdestroy_workqueue(vmbus_connection.handle_primary_chan_wq);\n\n\tif (vmbus_connection.rescind_work_queue)\n\t\tdestroy_workqueue(vmbus_connection.rescind_work_queue);\n\n\tif (vmbus_connection.work_queue)\n\t\tdestroy_workqueue(vmbus_connection.work_queue);\n\n\tif (vmbus_connection.int_page) {\n\t\thv_free_hyperv_page(vmbus_connection.int_page);\n\t\tvmbus_connection.int_page = NULL;\n\t}\n\n\tset_memory_encrypted((unsigned long)vmbus_connection.monitor_pages[0], 1);\n\tset_memory_encrypted((unsigned long)vmbus_connection.monitor_pages[1], 1);\n\n\thv_free_hyperv_page(vmbus_connection.monitor_pages[0]);\n\thv_free_hyperv_page(vmbus_connection.monitor_pages[1]);\n\tvmbus_connection.monitor_pages[0] = NULL;\n\tvmbus_connection.monitor_pages[1] = NULL;\n}\n\n \nstruct vmbus_channel *relid2channel(u32 relid)\n{\n\tif (vmbus_connection.channels == NULL) {\n\t\tpr_warn_once(\"relid2channel: relid=%d: No channels mapped!\\n\", relid);\n\t\treturn NULL;\n\t}\n\tif (WARN_ON(relid >= MAX_CHANNEL_RELIDS))\n\t\treturn NULL;\n\treturn READ_ONCE(vmbus_connection.channels[relid]);\n}\n\n \nvoid vmbus_on_event(unsigned long data)\n{\n\tstruct vmbus_channel *channel = (void *) data;\n\tvoid (*callback_fn)(void *context);\n\n\ttrace_vmbus_on_event(channel);\n\n\thv_debug_delay_test(channel, INTERRUPT_DELAY);\n\n\t \n\tcallback_fn = READ_ONCE(channel->onchannel_callback);\n\tif (unlikely(!callback_fn))\n\t\treturn;\n\n\t(*callback_fn)(channel->channel_callback_context);\n\n\tif (channel->callback_mode != HV_CALL_BATCHED)\n\t\treturn;\n\n\tif (likely(hv_end_read(&channel->inbound) == 0))\n\t\treturn;\n\n\thv_begin_read(&channel->inbound);\n\ttasklet_schedule(&channel->callback_event);\n}\n\n \nint vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)\n{\n\tstruct vmbus_channel_message_header *hdr;\n\tunion hv_connection_id conn_id;\n\tint ret = 0;\n\tint retries = 0;\n\tu32 usec = 1;\n\n\tconn_id.asu32 = 0;\n\tconn_id.u.id = vmbus_connection.msg_conn_id;\n\n\t \n\twhile (retries < 100) {\n\t\tret = hv_post_message(conn_id, 1, buffer, buflen);\n\n\t\tswitch (ret) {\n\t\tcase HV_STATUS_INVALID_CONNECTION_ID:\n\t\t\t \n\t\t\thdr = buffer;\n\t\t\tif (hdr->msgtype == CHANNELMSG_INITIATE_CONTACT)\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\tcase HV_STATUS_INSUFFICIENT_MEMORY:\n\t\tcase HV_STATUS_INSUFFICIENT_BUFFERS:\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\tcase HV_STATUS_SUCCESS:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tpr_err(\"hv_post_msg() failed; error code:%d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tretries++;\n\t\tif (can_sleep && usec > 1000)\n\t\t\tmsleep(usec / 1000);\n\t\telse if (usec < MAX_UDELAY_MS * 1000)\n\t\t\tudelay(usec);\n\t\telse\n\t\t\tmdelay(usec / 1000);\n\n\t\tif (retries < 22)\n\t\t\tusec *= 2;\n\t}\n\treturn ret;\n}\n\n \nvoid vmbus_set_event(struct vmbus_channel *channel)\n{\n\tu32 child_relid = channel->offermsg.child_relid;\n\n\tif (!channel->is_dedicated_interrupt)\n\t\tvmbus_send_interrupt(child_relid);\n\n\t++channel->sig_events;\n\n\tif (ms_hyperv.paravisor_present) {\n\t\tif (hv_isolation_type_snp())\n\t\t\thv_ghcb_hypercall(HVCALL_SIGNAL_EVENT, &channel->sig_event,\n\t\t\t\t\t  NULL, sizeof(channel->sig_event));\n\t\telse if (hv_isolation_type_tdx())\n\t\t\thv_tdx_hypercall(HVCALL_SIGNAL_EVENT | HV_HYPERCALL_FAST_BIT,\n\t\t\t\t\t channel->sig_event, 0);\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\t} else {\n\t\thv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);\n\t}\n}\nEXPORT_SYMBOL_GPL(vmbus_set_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}