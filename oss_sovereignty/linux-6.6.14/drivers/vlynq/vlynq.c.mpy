{
  "module_name": "vlynq.c",
  "hash_id": "19af3c69373dc85e8f73f8a3476d85c7857ce84b1dd309b0d6eea8be776e1c59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vlynq/vlynq.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\n#include <linux/vlynq.h>\n\n#define VLYNQ_CTRL_PM_ENABLE\t\t0x80000000\n#define VLYNQ_CTRL_CLOCK_INT\t\t0x00008000\n#define VLYNQ_CTRL_CLOCK_DIV(x)\t\t(((x) & 7) << 16)\n#define VLYNQ_CTRL_INT_LOCAL\t\t0x00004000\n#define VLYNQ_CTRL_INT_ENABLE\t\t0x00002000\n#define VLYNQ_CTRL_INT_VECTOR(x)\t(((x) & 0x1f) << 8)\n#define VLYNQ_CTRL_INT2CFG\t\t0x00000080\n#define VLYNQ_CTRL_RESET\t\t0x00000001\n\n#define VLYNQ_CTRL_CLOCK_MASK          (0x7 << 16)\n\n#define VLYNQ_INT_OFFSET\t\t0x00000014\n#define VLYNQ_REMOTE_OFFSET\t\t0x00000080\n\n#define VLYNQ_STATUS_LINK\t\t0x00000001\n#define VLYNQ_STATUS_LERROR\t\t0x00000080\n#define VLYNQ_STATUS_RERROR\t\t0x00000100\n\n#define VINT_ENABLE\t\t\t0x00000100\n#define VINT_TYPE_EDGE\t\t\t0x00000080\n#define VINT_LEVEL_LOW\t\t\t0x00000040\n#define VINT_VECTOR(x)\t\t\t((x) & 0x1f)\n#define VINT_OFFSET(irq)\t\t(8 * ((irq) % 4))\n\n#define VLYNQ_AUTONEGO_V2\t\t0x00010000\n\nstruct vlynq_regs {\n\tu32 revision;\n\tu32 control;\n\tu32 status;\n\tu32 int_prio;\n\tu32 int_status;\n\tu32 int_pending;\n\tu32 int_ptr;\n\tu32 tx_offset;\n\tstruct vlynq_mapping rx_mapping[4];\n\tu32 chip;\n\tu32 autonego;\n\tu32 unused[6];\n\tu32 int_device[8];\n};\n\n#ifdef CONFIG_VLYNQ_DEBUG\nstatic void vlynq_dump_regs(struct vlynq_device *dev)\n{\n\tint i;\n\n\tprintk(KERN_DEBUG \"VLYNQ local=%p remote=%p\\n\",\n\t\t\tdev->local, dev->remote);\n\tfor (i = 0; i < 32; i++) {\n\t\tprintk(KERN_DEBUG \"VLYNQ: local %d: %08x\\n\",\n\t\t\ti + 1, ((u32 *)dev->local)[i]);\n\t\tprintk(KERN_DEBUG \"VLYNQ: remote %d: %08x\\n\",\n\t\t\ti + 1, ((u32 *)dev->remote)[i]);\n\t}\n}\n\nstatic void vlynq_dump_mem(u32 *base, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < (count + 3) / 4; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tprintk(KERN_DEBUG \"\\nMEM[0x%04x]:\", i * 4);\n\t\tprintk(KERN_DEBUG \" 0x%08x\", *(base + i));\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}\n#endif\n\n \nstatic int vlynq_linked(struct vlynq_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 100; i++)\n\t\tif (readl(&dev->local->status) & VLYNQ_STATUS_LINK)\n\t\t\treturn 1;\n\t\telse\n\t\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic void vlynq_reset(struct vlynq_device *dev)\n{\n\twritel(readl(&dev->local->control) | VLYNQ_CTRL_RESET,\n\t\t\t&dev->local->control);\n\n\t \n\tmsleep(5);\n\n\t \n\twritel(readl(&dev->local->control) & ~VLYNQ_CTRL_RESET,\n\t\t\t&dev->local->control);\n\n\t \n\tmsleep(5);\n}\n\nstatic void vlynq_irq_unmask(struct irq_data *d)\n{\n\tstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\n\tint virq;\n\tu32 val;\n\n\tBUG_ON(!dev);\n\tvirq = d->irq - dev->irq_start;\n\tval = readl(&dev->remote->int_device[virq >> 2]);\n\tval |= (VINT_ENABLE | virq) << VINT_OFFSET(virq);\n\twritel(val, &dev->remote->int_device[virq >> 2]);\n}\n\nstatic void vlynq_irq_mask(struct irq_data *d)\n{\n\tstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\n\tint virq;\n\tu32 val;\n\n\tBUG_ON(!dev);\n\tvirq = d->irq - dev->irq_start;\n\tval = readl(&dev->remote->int_device[virq >> 2]);\n\tval &= ~(VINT_ENABLE << VINT_OFFSET(virq));\n\twritel(val, &dev->remote->int_device[virq >> 2]);\n}\n\nstatic int vlynq_irq_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\n\tint virq;\n\tu32 val;\n\n\tBUG_ON(!dev);\n\tvirq = d->irq - dev->irq_start;\n\tval = readl(&dev->remote->int_device[virq >> 2]);\n\tswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tval |= VINT_TYPE_EDGE << VINT_OFFSET(virq);\n\t\tval &= ~(VINT_LEVEL_LOW << VINT_OFFSET(virq));\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tval &= ~(VINT_TYPE_EDGE << VINT_OFFSET(virq));\n\t\tval &= ~(VINT_LEVEL_LOW << VINT_OFFSET(virq));\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tval &= ~(VINT_TYPE_EDGE << VINT_OFFSET(virq));\n\t\tval |= VINT_LEVEL_LOW << VINT_OFFSET(virq);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(val, &dev->remote->int_device[virq >> 2]);\n\treturn 0;\n}\n\nstatic void vlynq_local_ack(struct irq_data *d)\n{\n\tstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\n\tu32 status = readl(&dev->local->status);\n\n\tpr_debug(\"%s: local status: 0x%08x\\n\",\n\t\t       dev_name(&dev->dev), status);\n\twritel(status, &dev->local->status);\n}\n\nstatic void vlynq_remote_ack(struct irq_data *d)\n{\n\tstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\n\tu32 status = readl(&dev->remote->status);\n\n\tpr_debug(\"%s: remote status: 0x%08x\\n\",\n\t\t       dev_name(&dev->dev), status);\n\twritel(status, &dev->remote->status);\n}\n\nstatic irqreturn_t vlynq_irq(int irq, void *dev_id)\n{\n\tstruct vlynq_device *dev = dev_id;\n\tu32 status;\n\tint virq = 0;\n\n\tstatus = readl(&dev->local->int_status);\n\twritel(status, &dev->local->int_status);\n\n\tif (unlikely(!status))\n\t\tspurious_interrupt();\n\n\twhile (status) {\n\t\tif (status & 1)\n\t\t\tdo_IRQ(dev->irq_start + virq);\n\t\tstatus >>= 1;\n\t\tvirq++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct irq_chip vlynq_irq_chip = {\n\t.name = \"vlynq\",\n\t.irq_unmask = vlynq_irq_unmask,\n\t.irq_mask = vlynq_irq_mask,\n\t.irq_set_type = vlynq_irq_type,\n};\n\nstatic struct irq_chip vlynq_local_chip = {\n\t.name = \"vlynq local error\",\n\t.irq_unmask = vlynq_irq_unmask,\n\t.irq_mask = vlynq_irq_mask,\n\t.irq_ack = vlynq_local_ack,\n};\n\nstatic struct irq_chip vlynq_remote_chip = {\n\t.name = \"vlynq local error\",\n\t.irq_unmask = vlynq_irq_unmask,\n\t.irq_mask = vlynq_irq_mask,\n\t.irq_ack = vlynq_remote_ack,\n};\n\nstatic int vlynq_setup_irq(struct vlynq_device *dev)\n{\n\tu32 val;\n\tint i, virq;\n\n\tif (dev->local_irq == dev->remote_irq) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: local vlynq irq should be different from remote\\n\",\n\t\t       dev_name(&dev->dev));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twritel(readl(&dev->local->status), &dev->local->status);\n\twritel(readl(&dev->remote->status), &dev->remote->status);\n\n\t \n\tval = VLYNQ_CTRL_INT_VECTOR(dev->local_irq);\n\tval |= VLYNQ_CTRL_INT_ENABLE | VLYNQ_CTRL_INT_LOCAL |\n\t\tVLYNQ_CTRL_INT2CFG;\n\tval |= readl(&dev->local->control);\n\twritel(VLYNQ_INT_OFFSET, &dev->local->int_ptr);\n\twritel(val, &dev->local->control);\n\n\tval = VLYNQ_CTRL_INT_VECTOR(dev->remote_irq);\n\tval |= VLYNQ_CTRL_INT_ENABLE;\n\tval |= readl(&dev->remote->control);\n\twritel(VLYNQ_INT_OFFSET, &dev->remote->int_ptr);\n\twritel(val, &dev->remote->int_ptr);\n\twritel(val, &dev->remote->control);\n\n\tfor (i = dev->irq_start; i <= dev->irq_end; i++) {\n\t\tvirq = i - dev->irq_start;\n\t\tif (virq == dev->local_irq) {\n\t\t\tirq_set_chip_and_handler(i, &vlynq_local_chip,\n\t\t\t\t\t\t handle_level_irq);\n\t\t\tirq_set_chip_data(i, dev);\n\t\t} else if (virq == dev->remote_irq) {\n\t\t\tirq_set_chip_and_handler(i, &vlynq_remote_chip,\n\t\t\t\t\t\t handle_level_irq);\n\t\t\tirq_set_chip_data(i, dev);\n\t\t} else {\n\t\t\tirq_set_chip_and_handler(i, &vlynq_irq_chip,\n\t\t\t\t\t\t handle_simple_irq);\n\t\t\tirq_set_chip_data(i, dev);\n\t\t\twritel(0, &dev->remote->int_device[virq >> 2]);\n\t\t}\n\t}\n\n\tif (request_irq(dev->irq, vlynq_irq, IRQF_SHARED, \"vlynq\", dev)) {\n\t\tprintk(KERN_ERR \"%s: request_irq failed\\n\",\n\t\t\t\t\tdev_name(&dev->dev));\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic void vlynq_device_release(struct device *dev)\n{\n\tstruct vlynq_device *vdev = to_vlynq_device(dev);\n\tkfree(vdev);\n}\n\nstatic int vlynq_device_match(struct device *dev,\n\t\t\t      struct device_driver *drv)\n{\n\tstruct vlynq_device *vdev = to_vlynq_device(dev);\n\tstruct vlynq_driver *vdrv = to_vlynq_driver(drv);\n\tstruct vlynq_device_id *ids = vdrv->id_table;\n\n\twhile (ids->id) {\n\t\tif (ids->id == vdev->dev_id) {\n\t\t\tvdev->divisor = ids->divisor;\n\t\t\tvlynq_set_drvdata(vdev, ids);\n\t\t\tprintk(KERN_INFO \"Driver found for VLYNQ \"\n\t\t\t\t\"device: %08x\\n\", vdev->dev_id);\n\t\t\treturn 1;\n\t\t}\n\t\tprintk(KERN_DEBUG \"Not using the %08x VLYNQ device's driver\"\n\t\t\t\" for VLYNQ device: %08x\\n\", ids->id, vdev->dev_id);\n\t\tids++;\n\t}\n\treturn 0;\n}\n\nstatic int vlynq_device_probe(struct device *dev)\n{\n\tstruct vlynq_device *vdev = to_vlynq_device(dev);\n\tstruct vlynq_driver *drv = to_vlynq_driver(dev->driver);\n\tstruct vlynq_device_id *id = vlynq_get_drvdata(vdev);\n\tint result = -ENODEV;\n\n\tif (drv->probe)\n\t\tresult = drv->probe(vdev, id);\n\tif (result)\n\t\tput_device(dev);\n\treturn result;\n}\n\nstatic void vlynq_device_remove(struct device *dev)\n{\n\tstruct vlynq_driver *drv = to_vlynq_driver(dev->driver);\n\n\tif (drv->remove)\n\t\tdrv->remove(to_vlynq_device(dev));\n}\n\nint __vlynq_register_driver(struct vlynq_driver *driver, struct module *owner)\n{\n\tdriver->driver.name = driver->name;\n\tdriver->driver.bus = &vlynq_bus_type;\n\treturn driver_register(&driver->driver);\n}\nEXPORT_SYMBOL(__vlynq_register_driver);\n\nvoid vlynq_unregister_driver(struct vlynq_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL(vlynq_unregister_driver);\n\n \nstatic int __vlynq_try_remote(struct vlynq_device *dev)\n{\n\tint i;\n\n\tvlynq_reset(dev);\n\tfor (i = dev->dev_id ? vlynq_rdiv2 : vlynq_rdiv8; dev->dev_id ?\n\t\t\ti <= vlynq_rdiv8 : i >= vlynq_rdiv2;\n\t\tdev->dev_id ? i++ : i--) {\n\n\t\tif (!vlynq_linked(dev))\n\t\t\tbreak;\n\n\t\twritel((readl(&dev->remote->control) &\n\t\t\t\t~VLYNQ_CTRL_CLOCK_MASK) |\n\t\t\t\tVLYNQ_CTRL_CLOCK_INT |\n\t\t\t\tVLYNQ_CTRL_CLOCK_DIV(i - vlynq_rdiv1),\n\t\t\t\t&dev->remote->control);\n\t\twritel((readl(&dev->local->control)\n\t\t\t\t& ~(VLYNQ_CTRL_CLOCK_INT |\n\t\t\t\tVLYNQ_CTRL_CLOCK_MASK)) |\n\t\t\t\tVLYNQ_CTRL_CLOCK_DIV(i - vlynq_rdiv1),\n\t\t\t\t&dev->local->control);\n\n\t\tif (vlynq_linked(dev)) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: using remote clock divisor %d\\n\",\n\t\t\t\tdev_name(&dev->dev), i - vlynq_rdiv1 + 1);\n\t\t\tdev->divisor = i;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvlynq_reset(dev);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int __vlynq_try_local(struct vlynq_device *dev)\n{\n\tint i;\n\n\tvlynq_reset(dev);\n\n\tfor (i = dev->dev_id ? vlynq_ldiv2 : vlynq_ldiv8; dev->dev_id ?\n\t\t\ti <= vlynq_ldiv8 : i >= vlynq_ldiv2;\n\t\tdev->dev_id ? i++ : i--) {\n\n\t\twritel((readl(&dev->local->control) &\n\t\t\t\t~VLYNQ_CTRL_CLOCK_MASK) |\n\t\t\t\tVLYNQ_CTRL_CLOCK_INT |\n\t\t\t\tVLYNQ_CTRL_CLOCK_DIV(i - vlynq_ldiv1),\n\t\t\t\t&dev->local->control);\n\n\t\tif (vlynq_linked(dev)) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: using local clock divisor %d\\n\",\n\t\t\t\tdev_name(&dev->dev), i - vlynq_ldiv1 + 1);\n\t\t\tdev->divisor = i;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvlynq_reset(dev);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int __vlynq_try_external(struct vlynq_device *dev)\n{\n\tvlynq_reset(dev);\n\tif (!vlynq_linked(dev))\n\t\treturn -ENODEV;\n\n\twritel((readl(&dev->remote->control) &\n\t\t\t~VLYNQ_CTRL_CLOCK_INT),\n\t\t\t&dev->remote->control);\n\n\twritel((readl(&dev->local->control) &\n\t\t\t~VLYNQ_CTRL_CLOCK_INT),\n\t\t\t&dev->local->control);\n\n\tif (vlynq_linked(dev)) {\n\t\tprintk(KERN_DEBUG \"%s: using external clock\\n\",\n\t\t\tdev_name(&dev->dev));\n\t\t\tdev->divisor = vlynq_div_external;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int __vlynq_enable_device(struct vlynq_device *dev)\n{\n\tint result;\n\tstruct plat_vlynq_ops *ops = dev->dev.platform_data;\n\n\tresult = ops->on(dev);\n\tif (result)\n\t\treturn result;\n\n\tswitch (dev->divisor) {\n\tcase vlynq_div_external:\n\tcase vlynq_div_auto:\n\t\t \n\t\tif (vlynq_linked(dev) && readl(&dev->remote->control) &\n\t\t   VLYNQ_CTRL_CLOCK_INT) {\n\t\t\tif (!__vlynq_try_remote(dev) ||\n\t\t\t\t!__vlynq_try_local(dev)  ||\n\t\t\t\t!__vlynq_try_external(dev))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!__vlynq_try_external(dev) ||\n\t\t\t\t!__vlynq_try_local(dev)    ||\n\t\t\t\t!__vlynq_try_remote(dev))\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase vlynq_ldiv1:\n\tcase vlynq_ldiv2:\n\tcase vlynq_ldiv3:\n\tcase vlynq_ldiv4:\n\tcase vlynq_ldiv5:\n\tcase vlynq_ldiv6:\n\tcase vlynq_ldiv7:\n\tcase vlynq_ldiv8:\n\t\twritel(VLYNQ_CTRL_CLOCK_INT |\n\t\t\tVLYNQ_CTRL_CLOCK_DIV(dev->divisor -\n\t\t\tvlynq_ldiv1), &dev->local->control);\n\t\twritel(0, &dev->remote->control);\n\t\tif (vlynq_linked(dev)) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: using local clock divisor %d\\n\",\n\t\t\t\tdev_name(&dev->dev),\n\t\t\t\tdev->divisor - vlynq_ldiv1 + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase vlynq_rdiv1:\n\tcase vlynq_rdiv2:\n\tcase vlynq_rdiv3:\n\tcase vlynq_rdiv4:\n\tcase vlynq_rdiv5:\n\tcase vlynq_rdiv6:\n\tcase vlynq_rdiv7:\n\tcase vlynq_rdiv8:\n\t\twritel(0, &dev->local->control);\n\t\twritel(VLYNQ_CTRL_CLOCK_INT |\n\t\t\tVLYNQ_CTRL_CLOCK_DIV(dev->divisor -\n\t\t\tvlynq_rdiv1), &dev->remote->control);\n\t\tif (vlynq_linked(dev)) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: using remote clock divisor %d\\n\",\n\t\t\t\tdev_name(&dev->dev),\n\t\t\t\tdev->divisor - vlynq_rdiv1 + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tops->off(dev);\n\treturn -ENODEV;\n}\n\nint vlynq_enable_device(struct vlynq_device *dev)\n{\n\tstruct plat_vlynq_ops *ops = dev->dev.platform_data;\n\tint result = -ENODEV;\n\n\tresult = __vlynq_enable_device(dev);\n\tif (result)\n\t\treturn result;\n\n\tresult = vlynq_setup_irq(dev);\n\tif (result)\n\t\tops->off(dev);\n\n\tdev->enabled = !result;\n\treturn result;\n}\nEXPORT_SYMBOL(vlynq_enable_device);\n\n\nvoid vlynq_disable_device(struct vlynq_device *dev)\n{\n\tstruct plat_vlynq_ops *ops = dev->dev.platform_data;\n\n\tdev->enabled = 0;\n\tfree_irq(dev->irq, dev);\n\tops->off(dev);\n}\nEXPORT_SYMBOL(vlynq_disable_device);\n\nint vlynq_set_local_mapping(struct vlynq_device *dev, u32 tx_offset,\n\t\t\t    struct vlynq_mapping *mapping)\n{\n\tint i;\n\n\tif (!dev->enabled)\n\t\treturn -ENXIO;\n\n\twritel(tx_offset, &dev->local->tx_offset);\n\tfor (i = 0; i < 4; i++) {\n\t\twritel(mapping[i].offset, &dev->local->rx_mapping[i].offset);\n\t\twritel(mapping[i].size, &dev->local->rx_mapping[i].size);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(vlynq_set_local_mapping);\n\nint vlynq_set_remote_mapping(struct vlynq_device *dev, u32 tx_offset,\n\t\t\t     struct vlynq_mapping *mapping)\n{\n\tint i;\n\n\tif (!dev->enabled)\n\t\treturn -ENXIO;\n\n\twritel(tx_offset, &dev->remote->tx_offset);\n\tfor (i = 0; i < 4; i++) {\n\t\twritel(mapping[i].offset, &dev->remote->rx_mapping[i].offset);\n\t\twritel(mapping[i].size, &dev->remote->rx_mapping[i].size);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(vlynq_set_remote_mapping);\n\nint vlynq_set_local_irq(struct vlynq_device *dev, int virq)\n{\n\tint irq = dev->irq_start + virq;\n\tif (dev->enabled)\n\t\treturn -EBUSY;\n\n\tif ((irq < dev->irq_start) || (irq > dev->irq_end))\n\t\treturn -EINVAL;\n\n\tif (virq == dev->remote_irq)\n\t\treturn -EINVAL;\n\n\tdev->local_irq = virq;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vlynq_set_local_irq);\n\nint vlynq_set_remote_irq(struct vlynq_device *dev, int virq)\n{\n\tint irq = dev->irq_start + virq;\n\tif (dev->enabled)\n\t\treturn -EBUSY;\n\n\tif ((irq < dev->irq_start) || (irq > dev->irq_end))\n\t\treturn -EINVAL;\n\n\tif (virq == dev->local_irq)\n\t\treturn -EINVAL;\n\n\tdev->remote_irq = virq;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vlynq_set_remote_irq);\n\nstatic int vlynq_probe(struct platform_device *pdev)\n{\n\tstruct vlynq_device *dev;\n\tstruct resource *regs_res, *mem_res, *irq_res;\n\tint len, result;\n\n\tregs_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"regs\");\n\tif (!regs_res)\n\t\treturn -ENODEV;\n\n\tmem_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mem\");\n\tif (!mem_res)\n\t\treturn -ENODEV;\n\n\tirq_res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"devirq\");\n\tif (!irq_res)\n\t\treturn -ENODEV;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tprintk(KERN_ERR\n\t\t       \"vlynq: failed to allocate device structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->id = pdev->id;\n\tdev->dev.bus = &vlynq_bus_type;\n\tdev->dev.parent = &pdev->dev;\n\tdev_set_name(&dev->dev, \"vlynq%d\", dev->id);\n\tdev->dev.platform_data = pdev->dev.platform_data;\n\tdev->dev.release = vlynq_device_release;\n\n\tdev->regs_start = regs_res->start;\n\tdev->regs_end = regs_res->end;\n\tdev->mem_start = mem_res->start;\n\tdev->mem_end = mem_res->end;\n\n\tlen = resource_size(regs_res);\n\tif (!request_mem_region(regs_res->start, len, dev_name(&dev->dev))) {\n\t\tprintk(KERN_ERR \"%s: Can't request vlynq registers\\n\",\n\t\t       dev_name(&dev->dev));\n\t\tresult = -ENXIO;\n\t\tgoto fail_request;\n\t}\n\n\tdev->local = ioremap(regs_res->start, len);\n\tif (!dev->local) {\n\t\tprintk(KERN_ERR \"%s: Can't remap vlynq registers\\n\",\n\t\t       dev_name(&dev->dev));\n\t\tresult = -ENXIO;\n\t\tgoto fail_remap;\n\t}\n\n\tdev->remote = (struct vlynq_regs *)((void *)dev->local +\n\t\t\t\t\t    VLYNQ_REMOTE_OFFSET);\n\n\tdev->irq = platform_get_irq_byname(pdev, \"irq\");\n\tdev->irq_start = irq_res->start;\n\tdev->irq_end = irq_res->end;\n\tdev->local_irq = dev->irq_end - dev->irq_start;\n\tdev->remote_irq = dev->local_irq - 1;\n\n\tif (device_register(&dev->dev))\n\t\tgoto fail_register;\n\tplatform_set_drvdata(pdev, dev);\n\n\tprintk(KERN_INFO \"%s: regs 0x%p, irq %d, mem 0x%p\\n\",\n\t       dev_name(&dev->dev), (void *)dev->regs_start, dev->irq,\n\t       (void *)dev->mem_start);\n\n\tdev->dev_id = 0;\n\tdev->divisor = vlynq_div_auto;\n\tresult = __vlynq_enable_device(dev);\n\tif (result == 0) {\n\t\tdev->dev_id = readl(&dev->remote->chip);\n\t\t((struct plat_vlynq_ops *)(dev->dev.platform_data))->off(dev);\n\t}\n\tif (dev->dev_id)\n\t\tprintk(KERN_INFO \"Found a VLYNQ device: %08x\\n\", dev->dev_id);\n\n\treturn 0;\n\nfail_register:\n\tiounmap(dev->local);\nfail_remap:\nfail_request:\n\trelease_mem_region(regs_res->start, len);\n\tkfree(dev);\n\treturn result;\n}\n\nstatic int vlynq_remove(struct platform_device *pdev)\n{\n\tstruct vlynq_device *dev = platform_get_drvdata(pdev);\n\n\tdevice_unregister(&dev->dev);\n\tiounmap(dev->local);\n\trelease_mem_region(dev->regs_start,\n\t\t\t   dev->regs_end - dev->regs_start + 1);\n\n\tkfree(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver vlynq_platform_driver = {\n\t.driver.name = \"vlynq\",\n\t.probe = vlynq_probe,\n\t.remove = vlynq_remove,\n};\n\nstruct bus_type vlynq_bus_type = {\n\t.name = \"vlynq\",\n\t.match = vlynq_device_match,\n\t.probe = vlynq_device_probe,\n\t.remove = vlynq_device_remove,\n};\nEXPORT_SYMBOL(vlynq_bus_type);\n\nstatic int vlynq_init(void)\n{\n\tint res = 0;\n\n\tres = bus_register(&vlynq_bus_type);\n\tif (res)\n\t\tgoto fail_bus;\n\n\tres = platform_driver_register(&vlynq_platform_driver);\n\tif (res)\n\t\tgoto fail_platform;\n\n\treturn 0;\n\nfail_platform:\n\tbus_unregister(&vlynq_bus_type);\nfail_bus:\n\treturn res;\n}\n\nstatic void vlynq_exit(void)\n{\n\tplatform_driver_unregister(&vlynq_platform_driver);\n\tbus_unregister(&vlynq_bus_type);\n}\n\nmodule_init(vlynq_init);\nmodule_exit(vlynq_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}