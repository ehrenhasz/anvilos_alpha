{
  "module_name": "sunvdc.c",
  "hash_id": "0bd0e7632a4481f1ccf69ab599cb5b6176e602dec0debfbe1b0e1c227d54b952",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/sunvdc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/blk-mq.h>\n#include <linux/hdreg.h>\n#include <linux/cdrom.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/scatterlist.h>\n\n#include <asm/vio.h>\n#include <asm/ldc.h>\n\n#define DRV_MODULE_NAME\t\t\"sunvdc\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_MODULE_VERSION\t\"1.2\"\n#define DRV_MODULE_RELDATE\t\"November 24, 2014\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \".c:v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Sun LDOM virtual disk client driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n#define VDC_TX_RING_SIZE\t512\n#define VDC_DEFAULT_BLK_SIZE\t512\n\n#define MAX_XFER_BLKS\t\t(128 * 1024)\n#define MAX_XFER_SIZE\t\t(MAX_XFER_BLKS / VDC_DEFAULT_BLK_SIZE)\n#define MAX_RING_COOKIES\t((MAX_XFER_BLKS / PAGE_SIZE) + 2)\n\n#define WAITING_FOR_LINK_UP\t0x01\n#define WAITING_FOR_TX_SPACE\t0x02\n#define WAITING_FOR_GEN_CMD\t0x04\n#define WAITING_FOR_ANY\t\t-1\n\n#define\tVDC_MAX_RETRIES\t10\n\nstatic struct workqueue_struct *sunvdc_wq;\n\nstruct vdc_req_entry {\n\tstruct request\t\t*req;\n};\n\nstruct vdc_port {\n\tstruct vio_driver_state\tvio;\n\n\tstruct gendisk\t\t*disk;\n\n\tstruct vdc_completion\t*cmp;\n\n\tu64\t\t\treq_id;\n\tu64\t\t\tseq;\n\tstruct vdc_req_entry\trq_arr[VDC_TX_RING_SIZE];\n\n\tunsigned long\t\tring_cookies;\n\n\tu64\t\t\tmax_xfer_size;\n\tu32\t\t\tvdisk_block_size;\n\tu32\t\t\tdrain;\n\n\tu64\t\t\tldc_timeout;\n\tstruct delayed_work\tldc_reset_timer_work;\n\tstruct work_struct\tldc_reset_work;\n\n\t \n\tu64\t\t\toperations;\n\tu32\t\t\tvdisk_size;\n\tu8\t\t\tvdisk_type;\n\tu8\t\t\tvdisk_mtype;\n\tu32\t\t\tvdisk_phys_blksz;\n\n\tstruct blk_mq_tag_set\ttag_set;\n\n\tchar\t\t\tdisk_name[32];\n};\n\nstatic void vdc_ldc_reset(struct vdc_port *port);\nstatic void vdc_ldc_reset_work(struct work_struct *work);\nstatic void vdc_ldc_reset_timer_work(struct work_struct *work);\n\nstatic inline struct vdc_port *to_vdc_port(struct vio_driver_state *vio)\n{\n\treturn container_of(vio, struct vdc_port, vio);\n}\n\n \nstatic struct vio_version vdc_versions[] = {\n\t{ .major = 1, .minor = 2 },\n\t{ .major = 1, .minor = 1 },\n\t{ .major = 1, .minor = 0 },\n};\n\nstatic inline int vdc_version_supported(struct vdc_port *port,\n\t\t\t\t\tu16 major, u16 minor)\n{\n\treturn port->vio.ver.major == major && port->vio.ver.minor >= minor;\n}\n\n#define VDCBLK_NAME\t\"vdisk\"\nstatic int vdc_major;\n#define PARTITION_SHIFT\t3\n\nstatic inline u32 vdc_tx_dring_avail(struct vio_dring_state *dr)\n{\n\treturn vio_dring_avail(dr, VDC_TX_RING_SIZE);\n}\n\nstatic int vdc_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tsector_t nsect = get_capacity(disk);\n\tsector_t cylinders = nsect;\n\n\tgeo->heads = 0xff;\n\tgeo->sectors = 0x3f;\n\tsector_div(cylinders, geo->heads * geo->sectors);\n\tgeo->cylinders = cylinders;\n\tif ((sector_t)(geo->cylinders + 1) * geo->heads * geo->sectors < nsect)\n\t\tgeo->cylinders = 0xffff;\n\n\treturn 0;\n}\n\n \nstatic int vdc_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t     unsigned command, unsigned long argument)\n{\n\tstruct vdc_port *port = bdev->bd_disk->private_data;\n\tint i;\n\n\tswitch (command) {\n\tcase CDROMMULTISESSION:\n\t\tpr_debug(PFX \"Multisession CDs not supported\\n\");\n\t\tfor (i = 0; i < sizeof(struct cdrom_multisession); i++)\n\t\t\tif (put_user(0, (char __user *)(argument + i)))\n\t\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase CDROM_GET_CAPABILITY:\n\t\tif (!vdc_version_supported(port, 1, 1))\n\t\t\treturn -EINVAL;\n\t\tswitch (port->vdisk_mtype) {\n\t\tcase VD_MEDIA_TYPE_CD:\n\t\tcase VD_MEDIA_TYPE_DVD:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\tpr_debug(PFX \"ioctl %08x not supported\\n\", command);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct block_device_operations vdc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.getgeo\t\t= vdc_getgeo,\n\t.ioctl\t\t= vdc_ioctl,\n\t.compat_ioctl\t= blkdev_compat_ptr_ioctl,\n};\n\nstatic void vdc_blk_queue_start(struct vdc_port *port)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\n\t \n\tif (port->disk && vdc_tx_dring_avail(dr) * 100 / VDC_TX_RING_SIZE >= 50)\n\t\tblk_mq_start_stopped_hw_queues(port->disk->queue, true);\n}\n\nstatic void vdc_finish(struct vio_driver_state *vio, int err, int waiting_for)\n{\n\tif (vio->cmp &&\n\t    (waiting_for == -1 ||\n\t     vio->cmp->waiting_for == waiting_for)) {\n\t\tvio->cmp->err = err;\n\t\tcomplete(&vio->cmp->com);\n\t\tvio->cmp = NULL;\n\t}\n}\n\nstatic void vdc_handshake_complete(struct vio_driver_state *vio)\n{\n\tstruct vdc_port *port = to_vdc_port(vio);\n\n\tcancel_delayed_work(&port->ldc_reset_timer_work);\n\tvdc_finish(vio, 0, WAITING_FOR_LINK_UP);\n\tvdc_blk_queue_start(port);\n}\n\nstatic int vdc_handle_unknown(struct vdc_port *port, void *arg)\n{\n\tstruct vio_msg_tag *pkt = arg;\n\n\tprintk(KERN_ERR PFX \"Received unknown msg [%02x:%02x:%04x:%08x]\\n\",\n\t       pkt->type, pkt->stype, pkt->stype_env, pkt->sid);\n\tprintk(KERN_ERR PFX \"Resetting connection.\\n\");\n\n\tldc_disconnect(port->vio.lp);\n\n\treturn -ECONNRESET;\n}\n\nstatic int vdc_send_attr(struct vio_driver_state *vio)\n{\n\tstruct vdc_port *port = to_vdc_port(vio);\n\tstruct vio_disk_attr_info pkt;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.tag.type = VIO_TYPE_CTRL;\n\tpkt.tag.stype = VIO_SUBTYPE_INFO;\n\tpkt.tag.stype_env = VIO_ATTR_INFO;\n\tpkt.tag.sid = vio_send_sid(vio);\n\n\tpkt.xfer_mode = VIO_DRING_MODE;\n\tpkt.vdisk_block_size = port->vdisk_block_size;\n\tpkt.max_xfer_size = port->max_xfer_size;\n\n\tviodbg(HS, \"SEND ATTR xfer_mode[0x%x] blksz[%u] max_xfer[%llu]\\n\",\n\t       pkt.xfer_mode, pkt.vdisk_block_size, pkt.max_xfer_size);\n\n\treturn vio_ldc_send(&port->vio, &pkt, sizeof(pkt));\n}\n\nstatic int vdc_handle_attr(struct vio_driver_state *vio, void *arg)\n{\n\tstruct vdc_port *port = to_vdc_port(vio);\n\tstruct vio_disk_attr_info *pkt = arg;\n\n\tviodbg(HS, \"GOT ATTR stype[0x%x] ops[%llx] disk_size[%llu] disk_type[%x] \"\n\t       \"mtype[0x%x] xfer_mode[0x%x] blksz[%u] max_xfer[%llu]\\n\",\n\t       pkt->tag.stype, pkt->operations,\n\t       pkt->vdisk_size, pkt->vdisk_type, pkt->vdisk_mtype,\n\t       pkt->xfer_mode, pkt->vdisk_block_size,\n\t       pkt->max_xfer_size);\n\n\tif (pkt->tag.stype == VIO_SUBTYPE_ACK) {\n\t\tswitch (pkt->vdisk_type) {\n\t\tcase VD_DISK_TYPE_DISK:\n\t\tcase VD_DISK_TYPE_SLICE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_ERR PFX \"%s: Bogus vdisk_type 0x%x\\n\",\n\t\t\t       vio->name, pkt->vdisk_type);\n\t\t\treturn -ECONNRESET;\n\t\t}\n\n\t\tif (pkt->vdisk_block_size > port->vdisk_block_size) {\n\t\t\tprintk(KERN_ERR PFX \"%s: BLOCK size increased \"\n\t\t\t       \"%u --> %u\\n\",\n\t\t\t       vio->name,\n\t\t\t       port->vdisk_block_size, pkt->vdisk_block_size);\n\t\t\treturn -ECONNRESET;\n\t\t}\n\n\t\tport->operations = pkt->operations;\n\t\tport->vdisk_type = pkt->vdisk_type;\n\t\tif (vdc_version_supported(port, 1, 1)) {\n\t\t\tport->vdisk_size = pkt->vdisk_size;\n\t\t\tport->vdisk_mtype = pkt->vdisk_mtype;\n\t\t}\n\t\tif (pkt->max_xfer_size < port->max_xfer_size)\n\t\t\tport->max_xfer_size = pkt->max_xfer_size;\n\t\tport->vdisk_block_size = pkt->vdisk_block_size;\n\n\t\tport->vdisk_phys_blksz = VDC_DEFAULT_BLK_SIZE;\n\t\tif (vdc_version_supported(port, 1, 2))\n\t\t\tport->vdisk_phys_blksz = pkt->phys_block_size;\n\n\t\treturn 0;\n\t} else {\n\t\tprintk(KERN_ERR PFX \"%s: Attribute NACK\\n\", vio->name);\n\n\t\treturn -ECONNRESET;\n\t}\n}\n\nstatic void vdc_end_special(struct vdc_port *port, struct vio_disk_desc *desc)\n{\n\tint err = desc->status;\n\n\tvdc_finish(&port->vio, -err, WAITING_FOR_GEN_CMD);\n}\n\nstatic void vdc_end_one(struct vdc_port *port, struct vio_dring_state *dr,\n\t\t\tunsigned int index)\n{\n\tstruct vio_disk_desc *desc = vio_dring_entry(dr, index);\n\tstruct vdc_req_entry *rqe = &port->rq_arr[index];\n\tstruct request *req;\n\n\tif (unlikely(desc->hdr.state != VIO_DESC_DONE))\n\t\treturn;\n\n\tldc_unmap(port->vio.lp, desc->cookies, desc->ncookies);\n\tdesc->hdr.state = VIO_DESC_FREE;\n\tdr->cons = vio_dring_next(dr, index);\n\n\treq = rqe->req;\n\tif (req == NULL) {\n\t\tvdc_end_special(port, desc);\n\t\treturn;\n\t}\n\n\trqe->req = NULL;\n\n\tblk_mq_end_request(req, desc->status ? BLK_STS_IOERR : 0);\n\n\tvdc_blk_queue_start(port);\n}\n\nstatic int vdc_ack(struct vdc_port *port, void *msgbuf)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\tstruct vio_dring_data *pkt = msgbuf;\n\n\tif (unlikely(pkt->dring_ident != dr->ident ||\n\t\t     pkt->start_idx != pkt->end_idx ||\n\t\t     pkt->start_idx >= VDC_TX_RING_SIZE))\n\t\treturn 0;\n\n\tvdc_end_one(port, dr, pkt->start_idx);\n\n\treturn 0;\n}\n\nstatic int vdc_nack(struct vdc_port *port, void *msgbuf)\n{\n\t \n\treturn 0;\n}\n\nstatic void vdc_event(void *arg, int event)\n{\n\tstruct vdc_port *port = arg;\n\tstruct vio_driver_state *vio = &port->vio;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&vio->lock, flags);\n\n\tif (unlikely(event == LDC_EVENT_RESET)) {\n\t\tvio_link_state_change(vio, event);\n\t\tqueue_work(sunvdc_wq, &port->ldc_reset_work);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(event == LDC_EVENT_UP)) {\n\t\tvio_link_state_change(vio, event);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(event != LDC_EVENT_DATA_READY)) {\n\t\tpr_warn(PFX \"Unexpected LDC event %d\\n\", event);\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\twhile (1) {\n\t\tunion {\n\t\t\tstruct vio_msg_tag tag;\n\t\t\tu64 raw[8];\n\t\t} msgbuf;\n\n\t\terr = ldc_read(vio->lp, &msgbuf, sizeof(msgbuf));\n\t\tif (unlikely(err < 0)) {\n\t\t\tif (err == -ECONNRESET)\n\t\t\t\tvio_conn_reset(vio);\n\t\t\tbreak;\n\t\t}\n\t\tif (err == 0)\n\t\t\tbreak;\n\t\tviodbg(DATA, \"TAG [%02x:%02x:%04x:%08x]\\n\",\n\t\t       msgbuf.tag.type,\n\t\t       msgbuf.tag.stype,\n\t\t       msgbuf.tag.stype_env,\n\t\t       msgbuf.tag.sid);\n\t\terr = vio_validate_sid(vio, &msgbuf.tag);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (likely(msgbuf.tag.type == VIO_TYPE_DATA)) {\n\t\t\tif (msgbuf.tag.stype == VIO_SUBTYPE_ACK)\n\t\t\t\terr = vdc_ack(port, &msgbuf);\n\t\t\telse if (msgbuf.tag.stype == VIO_SUBTYPE_NACK)\n\t\t\t\terr = vdc_nack(port, &msgbuf);\n\t\t\telse\n\t\t\t\terr = vdc_handle_unknown(port, &msgbuf);\n\t\t} else if (msgbuf.tag.type == VIO_TYPE_CTRL) {\n\t\t\terr = vio_control_pkt_engine(vio, &msgbuf);\n\t\t} else {\n\t\t\terr = vdc_handle_unknown(port, &msgbuf);\n\t\t}\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tif (err < 0)\n\t\tvdc_finish(&port->vio, err, WAITING_FOR_ANY);\nout:\n\tspin_unlock_irqrestore(&vio->lock, flags);\n}\n\nstatic int __vdc_tx_trigger(struct vdc_port *port)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\tstruct vio_dring_data hdr = {\n\t\t.tag = {\n\t\t\t.type\t\t= VIO_TYPE_DATA,\n\t\t\t.stype\t\t= VIO_SUBTYPE_INFO,\n\t\t\t.stype_env\t= VIO_DRING_DATA,\n\t\t\t.sid\t\t= vio_send_sid(&port->vio),\n\t\t},\n\t\t.dring_ident\t\t= dr->ident,\n\t\t.start_idx\t\t= dr->prod,\n\t\t.end_idx\t\t= dr->prod,\n\t};\n\tint err, delay;\n\tint retries = 0;\n\n\thdr.seq = dr->snd_nxt;\n\tdelay = 1;\n\tdo {\n\t\terr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\n\t\tif (err > 0) {\n\t\t\tdr->snd_nxt++;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(delay);\n\t\tif ((delay <<= 1) > 128)\n\t\t\tdelay = 128;\n\t\tif (retries++ > VDC_MAX_RETRIES)\n\t\t\tbreak;\n\t} while (err == -EAGAIN);\n\n\tif (err == -ENOTCONN)\n\t\tvdc_ldc_reset(port);\n\treturn err;\n}\n\nstatic int __send_request(struct request *req)\n{\n\tstruct vdc_port *port = req->q->disk->private_data;\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\tstruct scatterlist sg[MAX_RING_COOKIES];\n\tstruct vdc_req_entry *rqe;\n\tstruct vio_disk_desc *desc;\n\tunsigned int map_perm;\n\tint nsg, err, i;\n\tu64 len;\n\tu8 op;\n\n\tif (WARN_ON(port->ring_cookies > MAX_RING_COOKIES))\n\t\treturn -EINVAL;\n\n\tmap_perm = LDC_MAP_SHADOW | LDC_MAP_DIRECT | LDC_MAP_IO;\n\n\tif (rq_data_dir(req) == READ) {\n\t\tmap_perm |= LDC_MAP_W;\n\t\top = VD_OP_BREAD;\n\t} else {\n\t\tmap_perm |= LDC_MAP_R;\n\t\top = VD_OP_BWRITE;\n\t}\n\n\tsg_init_table(sg, port->ring_cookies);\n\tnsg = blk_rq_map_sg(req->q, req, sg);\n\n\tlen = 0;\n\tfor (i = 0; i < nsg; i++)\n\t\tlen += sg[i].length;\n\n\tdesc = vio_dring_cur(dr);\n\n\terr = ldc_map_sg(port->vio.lp, sg, nsg,\n\t\t\t desc->cookies, port->ring_cookies,\n\t\t\t map_perm);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"ldc_map_sg() failure, err=%d.\\n\", err);\n\t\treturn err;\n\t}\n\n\trqe = &port->rq_arr[dr->prod];\n\trqe->req = req;\n\n\tdesc->hdr.ack = VIO_ACK_ENABLE;\n\tdesc->req_id = port->req_id;\n\tdesc->operation = op;\n\tif (port->vdisk_type == VD_DISK_TYPE_DISK) {\n\t\tdesc->slice = 0xff;\n\t} else {\n\t\tdesc->slice = 0;\n\t}\n\tdesc->status = ~0;\n\tdesc->offset = (blk_rq_pos(req) << 9) / port->vdisk_block_size;\n\tdesc->size = len;\n\tdesc->ncookies = err;\n\n\t \n\twmb();\n\tdesc->hdr.state = VIO_DESC_READY;\n\n\terr = __vdc_tx_trigger(port);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"vdc_tx_trigger() failure, err=%d\\n\", err);\n\t} else {\n\t\tport->req_id++;\n\t\tdr->prod = vio_dring_next(dr, dr->prod);\n\t}\n\n\treturn err;\n}\n\nstatic blk_status_t vdc_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd)\n{\n\tstruct vdc_port *port = hctx->queue->queuedata;\n\tstruct vio_dring_state *dr;\n\tunsigned long flags;\n\n\tdr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\n\tblk_mq_start_request(bd->rq);\n\n\tspin_lock_irqsave(&port->vio.lock, flags);\n\n\t \n\tif (unlikely(port->drain)) {\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tif (unlikely(vdc_tx_dring_avail(dr) < 1)) {\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\t\tblk_mq_stop_hw_queue(hctx);\n\t\treturn BLK_STS_DEV_RESOURCE;\n\t}\n\n\tif (__send_request(bd->rq) < 0) {\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\treturn BLK_STS_OK;\n}\n\nstatic int generic_request(struct vdc_port *port, u8 op, void *buf, int len)\n{\n\tstruct vio_dring_state *dr;\n\tstruct vio_completion comp;\n\tstruct vio_disk_desc *desc;\n\tunsigned int map_perm;\n\tunsigned long flags;\n\tint op_len, err;\n\tvoid *req_buf;\n\n\tif (!(((u64)1 << (u64)op) & port->operations))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (op) {\n\tcase VD_OP_BREAD:\n\tcase VD_OP_BWRITE:\n\tdefault:\n\t\treturn -EINVAL;\n\n\tcase VD_OP_FLUSH:\n\t\top_len = 0;\n\t\tmap_perm = 0;\n\t\tbreak;\n\n\tcase VD_OP_GET_WCE:\n\t\top_len = sizeof(u32);\n\t\tmap_perm = LDC_MAP_W;\n\t\tbreak;\n\n\tcase VD_OP_SET_WCE:\n\t\top_len = sizeof(u32);\n\t\tmap_perm = LDC_MAP_R;\n\t\tbreak;\n\n\tcase VD_OP_GET_VTOC:\n\t\top_len = sizeof(struct vio_disk_vtoc);\n\t\tmap_perm = LDC_MAP_W;\n\t\tbreak;\n\n\tcase VD_OP_SET_VTOC:\n\t\top_len = sizeof(struct vio_disk_vtoc);\n\t\tmap_perm = LDC_MAP_R;\n\t\tbreak;\n\n\tcase VD_OP_GET_DISKGEOM:\n\t\top_len = sizeof(struct vio_disk_geom);\n\t\tmap_perm = LDC_MAP_W;\n\t\tbreak;\n\n\tcase VD_OP_SET_DISKGEOM:\n\t\top_len = sizeof(struct vio_disk_geom);\n\t\tmap_perm = LDC_MAP_R;\n\t\tbreak;\n\n\tcase VD_OP_SCSICMD:\n\t\top_len = 16;\n\t\tmap_perm = LDC_MAP_RW;\n\t\tbreak;\n\n\tcase VD_OP_GET_DEVID:\n\t\top_len = sizeof(struct vio_disk_devid);\n\t\tmap_perm = LDC_MAP_W;\n\t\tbreak;\n\n\tcase VD_OP_GET_EFI:\n\tcase VD_OP_SET_EFI:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmap_perm |= LDC_MAP_SHADOW | LDC_MAP_DIRECT | LDC_MAP_IO;\n\n\top_len = (op_len + 7) & ~7;\n\treq_buf = kzalloc(op_len, GFP_KERNEL);\n\tif (!req_buf)\n\t\treturn -ENOMEM;\n\n\tif (len > op_len)\n\t\tlen = op_len;\n\n\tif (map_perm & LDC_MAP_R)\n\t\tmemcpy(req_buf, buf, len);\n\n\tspin_lock_irqsave(&port->vio.lock, flags);\n\n\tdr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\n\t \n\tdesc = vio_dring_cur(dr);\n\n\terr = ldc_map_single(port->vio.lp, req_buf, op_len,\n\t\t\t     desc->cookies, port->ring_cookies,\n\t\t\t     map_perm);\n\tif (err < 0) {\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\t\tkfree(req_buf);\n\t\treturn err;\n\t}\n\n\tinit_completion(&comp.com);\n\tcomp.waiting_for = WAITING_FOR_GEN_CMD;\n\tport->vio.cmp = &comp;\n\n\tdesc->hdr.ack = VIO_ACK_ENABLE;\n\tdesc->req_id = port->req_id;\n\tdesc->operation = op;\n\tdesc->slice = 0;\n\tdesc->status = ~0;\n\tdesc->offset = 0;\n\tdesc->size = op_len;\n\tdesc->ncookies = err;\n\n\t \n\twmb();\n\tdesc->hdr.state = VIO_DESC_READY;\n\n\terr = __vdc_tx_trigger(port);\n\tif (err >= 0) {\n\t\tport->req_id++;\n\t\tdr->prod = vio_dring_next(dr, dr->prod);\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\n\t\twait_for_completion(&comp.com);\n\t\terr = comp.err;\n\t} else {\n\t\tport->vio.cmp = NULL;\n\t\tspin_unlock_irqrestore(&port->vio.lock, flags);\n\t}\n\n\tif (map_perm & LDC_MAP_W)\n\t\tmemcpy(buf, req_buf, len);\n\n\tkfree(req_buf);\n\n\treturn err;\n}\n\nstatic int vdc_alloc_tx_ring(struct vdc_port *port)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\tunsigned long len, entry_size;\n\tint ncookies;\n\tvoid *dring;\n\n\tentry_size = sizeof(struct vio_disk_desc) +\n\t\t(sizeof(struct ldc_trans_cookie) * port->ring_cookies);\n\tlen = (VDC_TX_RING_SIZE * entry_size);\n\n\tncookies = VIO_MAX_RING_COOKIES;\n\tdring = ldc_alloc_exp_dring(port->vio.lp, len,\n\t\t\t\t    dr->cookies, &ncookies,\n\t\t\t\t    (LDC_MAP_SHADOW |\n\t\t\t\t     LDC_MAP_DIRECT |\n\t\t\t\t     LDC_MAP_RW));\n\tif (IS_ERR(dring))\n\t\treturn PTR_ERR(dring);\n\n\tdr->base = dring;\n\tdr->entry_size = entry_size;\n\tdr->num_entries = VDC_TX_RING_SIZE;\n\tdr->prod = dr->cons = 0;\n\tdr->pending = VDC_TX_RING_SIZE;\n\tdr->ncookies = ncookies;\n\n\treturn 0;\n}\n\nstatic void vdc_free_tx_ring(struct vdc_port *port)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\n\tif (dr->base) {\n\t\tldc_free_exp_dring(port->vio.lp, dr->base,\n\t\t\t\t   (dr->entry_size * dr->num_entries),\n\t\t\t\t   dr->cookies, dr->ncookies);\n\t\tdr->base = NULL;\n\t\tdr->entry_size = 0;\n\t\tdr->num_entries = 0;\n\t\tdr->pending = 0;\n\t\tdr->ncookies = 0;\n\t}\n}\n\nstatic int vdc_port_up(struct vdc_port *port)\n{\n\tstruct vio_completion comp;\n\n\tinit_completion(&comp.com);\n\tcomp.err = 0;\n\tcomp.waiting_for = WAITING_FOR_LINK_UP;\n\tport->vio.cmp = &comp;\n\n\tvio_port_up(&port->vio);\n\twait_for_completion(&comp.com);\n\treturn comp.err;\n}\n\nstatic void vdc_port_down(struct vdc_port *port)\n{\n\tldc_disconnect(port->vio.lp);\n\tldc_unbind(port->vio.lp);\n\tvdc_free_tx_ring(port);\n\tvio_ldc_free(&port->vio);\n}\n\nstatic const struct blk_mq_ops vdc_mq_ops = {\n\t.queue_rq\t= vdc_queue_rq,\n};\n\nstatic int probe_disk(struct vdc_port *port)\n{\n\tstruct request_queue *q;\n\tstruct gendisk *g;\n\tint err;\n\n\terr = vdc_port_up(port);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (vdc_version_supported(port, 1, 2) && !port->vdisk_phys_blksz)\n\t\treturn -ENODEV;\n\n\tif (vdc_version_supported(port, 1, 1)) {\n\t\t \n\t\tif (port->vdisk_size == -1)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tstruct vio_disk_geom geom;\n\n\t\terr = generic_request(port, VD_OP_GET_DISKGEOM,\n\t\t\t\t      &geom, sizeof(geom));\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR PFX \"VD_OP_GET_DISKGEOM returns \"\n\t\t\t       \"error %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tport->vdisk_size = ((u64)geom.num_cyl *\n\t\t\t\t    (u64)geom.num_hd *\n\t\t\t\t    (u64)geom.num_sec);\n\t}\n\n\terr = blk_mq_alloc_sq_tag_set(&port->tag_set, &vdc_mq_ops,\n\t\t\tVDC_TX_RING_SIZE, BLK_MQ_F_SHOULD_MERGE);\n\tif (err)\n\t\treturn err;\n\n\tg = blk_mq_alloc_disk(&port->tag_set, port);\n\tif (IS_ERR(g)) {\n\t\tprintk(KERN_ERR PFX \"%s: Could not allocate gendisk.\\n\",\n\t\t       port->vio.name);\n\t\terr = PTR_ERR(g);\n\t\tgoto out_free_tag;\n\t}\n\n\tport->disk = g;\n\tq = g->queue;\n\n\t \n\tblk_queue_segment_boundary(q, PAGE_SIZE - 1);\n\tblk_queue_max_segment_size(q, PAGE_SIZE);\n\n\tblk_queue_max_segments(q, port->ring_cookies);\n\tblk_queue_max_hw_sectors(q, port->max_xfer_size);\n\tg->major = vdc_major;\n\tg->first_minor = port->vio.vdev->dev_no << PARTITION_SHIFT;\n\tg->minors = 1 << PARTITION_SHIFT;\n\tstrcpy(g->disk_name, port->disk_name);\n\n\tg->fops = &vdc_fops;\n\tg->queue = q;\n\tg->private_data = port;\n\n\tset_capacity(g, port->vdisk_size);\n\n\tif (vdc_version_supported(port, 1, 1)) {\n\t\tswitch (port->vdisk_mtype) {\n\t\tcase VD_MEDIA_TYPE_CD:\n\t\t\tpr_info(PFX \"Virtual CDROM %s\\n\", port->disk_name);\n\t\t\tg->flags |= GENHD_FL_REMOVABLE;\n\t\t\tset_disk_ro(g, 1);\n\t\t\tbreak;\n\n\t\tcase VD_MEDIA_TYPE_DVD:\n\t\t\tpr_info(PFX \"Virtual DVD %s\\n\", port->disk_name);\n\t\t\tg->flags |= GENHD_FL_REMOVABLE;\n\t\t\tset_disk_ro(g, 1);\n\t\t\tbreak;\n\n\t\tcase VD_MEDIA_TYPE_FIXED:\n\t\t\tpr_info(PFX \"Virtual Hard disk %s\\n\", port->disk_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tblk_queue_physical_block_size(q, port->vdisk_phys_blksz);\n\n\tpr_info(PFX \"%s: %u sectors (%u MB) protocol %d.%d\\n\",\n\t       g->disk_name,\n\t       port->vdisk_size, (port->vdisk_size >> (20 - 9)),\n\t       port->vio.ver.major, port->vio.ver.minor);\n\n\terr = device_add_disk(&port->vio.vdev->dev, g, NULL);\n\tif (err)\n\t\tgoto out_cleanup_disk;\n\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(g);\nout_free_tag:\n\tblk_mq_free_tag_set(&port->tag_set);\n\treturn err;\n}\n\nstatic struct ldc_channel_config vdc_ldc_cfg = {\n\t.event\t\t= vdc_event,\n\t.mtu\t\t= 64,\n\t.mode\t\t= LDC_MODE_UNRELIABLE,\n};\n\nstatic struct vio_driver_ops vdc_vio_ops = {\n\t.send_attr\t\t= vdc_send_attr,\n\t.handle_attr\t\t= vdc_handle_attr,\n\t.handshake_complete\t= vdc_handshake_complete,\n};\n\nstatic void print_version(void)\n{\n\tstatic int version_printed;\n\n\tif (version_printed++ == 0)\n\t\tprintk(KERN_INFO \"%s\", version);\n}\n\nstruct vdc_check_port_data {\n\tint\tdev_no;\n\tchar\t*type;\n};\n\nstatic int vdc_device_probed(struct device *dev, void *arg)\n{\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\tstruct vdc_check_port_data *port_data;\n\n\tport_data = (struct vdc_check_port_data *)arg;\n\n\tif ((vdev->dev_no == port_data->dev_no) &&\n\t    (!(strcmp((char *)&vdev->type, port_data->type))) &&\n\t\tdev_get_drvdata(dev)) {\n\t\t \n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n \nstatic bool vdc_port_mpgroup_check(struct vio_dev *vdev)\n{\n\tstruct vdc_check_port_data port_data;\n\tstruct device *dev;\n\n\tport_data.dev_no = vdev->dev_no;\n\tport_data.type = (char *)&vdev->type;\n\n\tdev = device_find_child(vdev->dev.parent, &port_data,\n\t\t\t\tvdc_device_probed);\n\n\tif (dev)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int vdc_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct mdesc_handle *hp;\n\tstruct vdc_port *port;\n\tint err;\n\tconst u64 *ldc_timeout;\n\n\tprint_version();\n\n\thp = mdesc_grab();\n\tif (!hp)\n\t\treturn -ENODEV;\n\n\terr = -ENODEV;\n\tif ((vdev->dev_no << PARTITION_SHIFT) & ~(u64)MINORMASK) {\n\t\tprintk(KERN_ERR PFX \"Port id [%llu] too large.\\n\",\n\t\t       vdev->dev_no);\n\t\tgoto err_out_release_mdesc;\n\t}\n\n\t \n\tif (vdc_port_mpgroup_check(vdev)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"VIO: Ignoring extra vdisk port %s\",\n\t\t\tdev_name(&vdev->dev));\n\t\tgoto err_out_release_mdesc;\n\t}\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_release_mdesc;\n\t}\n\n\tif (vdev->dev_no >= 26)\n\t\tsnprintf(port->disk_name, sizeof(port->disk_name),\n\t\t\t VDCBLK_NAME \"%c%c\",\n\t\t\t 'a' + ((int)vdev->dev_no / 26) - 1,\n\t\t\t 'a' + ((int)vdev->dev_no % 26));\n\telse\n\t\tsnprintf(port->disk_name, sizeof(port->disk_name),\n\t\t\t VDCBLK_NAME \"%c\", 'a' + ((int)vdev->dev_no % 26));\n\tport->vdisk_size = -1;\n\n\t \n\tldc_timeout = mdesc_get_property(hp, vdev->mp, \"vdc-timeout\", NULL);\n\tport->ldc_timeout = ldc_timeout ? *ldc_timeout : 0;\n\tINIT_DELAYED_WORK(&port->ldc_reset_timer_work, vdc_ldc_reset_timer_work);\n\tINIT_WORK(&port->ldc_reset_work, vdc_ldc_reset_work);\n\n\terr = vio_driver_init(&port->vio, vdev, VDEV_DISK,\n\t\t\t      vdc_versions, ARRAY_SIZE(vdc_versions),\n\t\t\t      &vdc_vio_ops, port->disk_name);\n\tif (err)\n\t\tgoto err_out_free_port;\n\n\tport->vdisk_block_size = VDC_DEFAULT_BLK_SIZE;\n\tport->max_xfer_size = MAX_XFER_SIZE;\n\tport->ring_cookies = MAX_RING_COOKIES;\n\n\terr = vio_ldc_alloc(&port->vio, &vdc_ldc_cfg, port);\n\tif (err)\n\t\tgoto err_out_free_port;\n\n\terr = vdc_alloc_tx_ring(port);\n\tif (err)\n\t\tgoto err_out_free_ldc;\n\n\terr = probe_disk(port);\n\tif (err)\n\t\tgoto err_out_free_tx_ring;\n\n\t \n\tdev_set_drvdata(&vdev->dev, port);\n\n\tmdesc_release(hp);\n\n\treturn 0;\n\nerr_out_free_tx_ring:\n\tvdc_free_tx_ring(port);\n\nerr_out_free_ldc:\n\tvio_ldc_free(&port->vio);\n\nerr_out_free_port:\n\tkfree(port);\n\nerr_out_release_mdesc:\n\tmdesc_release(hp);\n\treturn err;\n}\n\nstatic void vdc_port_remove(struct vio_dev *vdev)\n{\n\tstruct vdc_port *port = dev_get_drvdata(&vdev->dev);\n\n\tif (port) {\n\t\tblk_mq_stop_hw_queues(port->disk->queue);\n\n\t\tflush_work(&port->ldc_reset_work);\n\t\tcancel_delayed_work_sync(&port->ldc_reset_timer_work);\n\t\tdel_timer_sync(&port->vio.timer);\n\n\t\tdel_gendisk(port->disk);\n\t\tput_disk(port->disk);\n\t\tblk_mq_free_tag_set(&port->tag_set);\n\n\t\tvdc_free_tx_ring(port);\n\t\tvio_ldc_free(&port->vio);\n\n\t\tdev_set_drvdata(&vdev->dev, NULL);\n\n\t\tkfree(port);\n\t}\n}\n\nstatic void vdc_requeue_inflight(struct vdc_port *port)\n{\n\tstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\n\tu32 idx;\n\n\tfor (idx = dr->cons; idx != dr->prod; idx = vio_dring_next(dr, idx)) {\n\t\tstruct vio_disk_desc *desc = vio_dring_entry(dr, idx);\n\t\tstruct vdc_req_entry *rqe = &port->rq_arr[idx];\n\t\tstruct request *req;\n\n\t\tldc_unmap(port->vio.lp, desc->cookies, desc->ncookies);\n\t\tdesc->hdr.state = VIO_DESC_FREE;\n\t\tdr->cons = vio_dring_next(dr, idx);\n\n\t\treq = rqe->req;\n\t\tif (req == NULL) {\n\t\t\tvdc_end_special(port, desc);\n\t\t\tcontinue;\n\t\t}\n\n\t\trqe->req = NULL;\n\t\tblk_mq_requeue_request(req, false);\n\t}\n}\n\nstatic void vdc_queue_drain(struct vdc_port *port)\n{\n\tstruct request_queue *q = port->disk->queue;\n\n\t \n\tport->drain = 1;\n\tspin_unlock_irq(&port->vio.lock);\n\n\tblk_mq_freeze_queue(q);\n\tblk_mq_quiesce_queue(q);\n\n\tspin_lock_irq(&port->vio.lock);\n\tport->drain = 0;\n\tblk_mq_unquiesce_queue(q);\n\tblk_mq_unfreeze_queue(q);\n}\n\nstatic void vdc_ldc_reset_timer_work(struct work_struct *work)\n{\n\tstruct vdc_port *port;\n\tstruct vio_driver_state *vio;\n\n\tport = container_of(work, struct vdc_port, ldc_reset_timer_work.work);\n\tvio = &port->vio;\n\n\tspin_lock_irq(&vio->lock);\n\tif (!(port->vio.hs_state & VIO_HS_COMPLETE)) {\n\t\tpr_warn(PFX \"%s ldc down %llu seconds, draining queue\\n\",\n\t\t\tport->disk_name, port->ldc_timeout);\n\t\tvdc_queue_drain(port);\n\t\tvdc_blk_queue_start(port);\n\t}\n\tspin_unlock_irq(&vio->lock);\n}\n\nstatic void vdc_ldc_reset_work(struct work_struct *work)\n{\n\tstruct vdc_port *port;\n\tstruct vio_driver_state *vio;\n\tunsigned long flags;\n\n\tport = container_of(work, struct vdc_port, ldc_reset_work);\n\tvio = &port->vio;\n\n\tspin_lock_irqsave(&vio->lock, flags);\n\tvdc_ldc_reset(port);\n\tspin_unlock_irqrestore(&vio->lock, flags);\n}\n\nstatic void vdc_ldc_reset(struct vdc_port *port)\n{\n\tint err;\n\n\tassert_spin_locked(&port->vio.lock);\n\n\tpr_warn(PFX \"%s ldc link reset\\n\", port->disk_name);\n\tblk_mq_stop_hw_queues(port->disk->queue);\n\tvdc_requeue_inflight(port);\n\tvdc_port_down(port);\n\n\terr = vio_ldc_alloc(&port->vio, &vdc_ldc_cfg, port);\n\tif (err) {\n\t\tpr_err(PFX \"%s vio_ldc_alloc:%d\\n\", port->disk_name, err);\n\t\treturn;\n\t}\n\n\terr = vdc_alloc_tx_ring(port);\n\tif (err) {\n\t\tpr_err(PFX \"%s vio_alloc_tx_ring:%d\\n\", port->disk_name, err);\n\t\tgoto err_free_ldc;\n\t}\n\n\tif (port->ldc_timeout)\n\t\tmod_delayed_work(system_wq, &port->ldc_reset_timer_work,\n\t\t\t  round_jiffies(jiffies + HZ * port->ldc_timeout));\n\tmod_timer(&port->vio.timer, round_jiffies(jiffies + HZ));\n\treturn;\n\nerr_free_ldc:\n\tvio_ldc_free(&port->vio);\n}\n\nstatic const struct vio_device_id vdc_port_match[] = {\n\t{\n\t\t.type = \"vdc-port\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(vio, vdc_port_match);\n\nstatic struct vio_driver vdc_port_driver = {\n\t.id_table\t= vdc_port_match,\n\t.probe\t\t= vdc_port_probe,\n\t.remove\t\t= vdc_port_remove,\n\t.name\t\t= \"vdc_port\",\n};\n\nstatic int __init vdc_init(void)\n{\n\tint err;\n\n\tsunvdc_wq = alloc_workqueue(\"sunvdc\", 0, 0);\n\tif (!sunvdc_wq)\n\t\treturn -ENOMEM;\n\n\terr = register_blkdev(0, VDCBLK_NAME);\n\tif (err < 0)\n\t\tgoto out_free_wq;\n\n\tvdc_major = err;\n\n\terr = vio_register_driver(&vdc_port_driver);\n\tif (err)\n\t\tgoto out_unregister_blkdev;\n\n\treturn 0;\n\nout_unregister_blkdev:\n\tunregister_blkdev(vdc_major, VDCBLK_NAME);\n\tvdc_major = 0;\n\nout_free_wq:\n\tdestroy_workqueue(sunvdc_wq);\n\treturn err;\n}\n\nstatic void __exit vdc_exit(void)\n{\n\tvio_unregister_driver(&vdc_port_driver);\n\tunregister_blkdev(vdc_major, VDCBLK_NAME);\n\tdestroy_workqueue(sunvdc_wq);\n}\n\nmodule_init(vdc_init);\nmodule_exit(vdc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}