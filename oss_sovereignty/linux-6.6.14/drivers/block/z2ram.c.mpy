{
  "module_name": "z2ram.c",
  "hash_id": "09fd2680cc7bb3e0498d731fb09904ffe7b2f8e7908cd5d2df2d5e102ab37f08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/z2ram.c",
  "human_readable_source": " \n\n#define DEVICE_NAME \"Z2RAM\"\n\n#include <linux/major.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/blk-mq.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n\n#include <asm/setup.h>\n#include <asm/amigahw.h>\n\n#include <linux/zorro.h>\n\n#define Z2MINOR_COMBINED      (0)\n#define Z2MINOR_Z2ONLY        (1)\n#define Z2MINOR_CHIPONLY      (2)\n#define Z2MINOR_MEMLIST1      (4)\n#define Z2MINOR_MEMLIST2      (5)\n#define Z2MINOR_MEMLIST3      (6)\n#define Z2MINOR_MEMLIST4      (7)\n#define Z2MINOR_COUNT         (8)\t \n\n#define Z2RAM_CHUNK1024       ( Z2RAM_CHUNKSIZE >> 10 )\n\nstatic DEFINE_MUTEX(z2ram_mutex);\nstatic u_long *z2ram_map = NULL;\nstatic u_long z2ram_size = 0;\nstatic int z2_count = 0;\nstatic int chip_count = 0;\nstatic int list_count = 0;\nstatic int current_device = -1;\n\nstatic DEFINE_SPINLOCK(z2ram_lock);\n\nstatic struct gendisk *z2ram_gendisk[Z2MINOR_COUNT];\n\nstatic blk_status_t z2_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct request *req = bd->rq;\n\tunsigned long start = blk_rq_pos(req) << 9;\n\tunsigned long len = blk_rq_cur_bytes(req);\n\n\tblk_mq_start_request(req);\n\n\tif (start + len > z2ram_size) {\n\t\tpr_err(DEVICE_NAME \": bad access: block=%llu, \"\n\t\t       \"count=%u\\n\",\n\t\t       (unsigned long long)blk_rq_pos(req),\n\t\t       blk_rq_cur_sectors(req));\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tspin_lock_irq(&z2ram_lock);\n\n\twhile (len) {\n\t\tunsigned long addr = start & Z2RAM_CHUNKMASK;\n\t\tunsigned long size = Z2RAM_CHUNKSIZE - addr;\n\t\tvoid *buffer = bio_data(req->bio);\n\n\t\tif (len < size)\n\t\t\tsize = len;\n\t\taddr += z2ram_map[start >> Z2RAM_CHUNKSHIFT];\n\t\tif (rq_data_dir(req) == READ)\n\t\t\tmemcpy(buffer, (char *)addr, size);\n\t\telse\n\t\t\tmemcpy((char *)addr, buffer, size);\n\t\tstart += size;\n\t\tlen -= size;\n\t}\n\n\tspin_unlock_irq(&z2ram_lock);\n\tblk_mq_end_request(req, BLK_STS_OK);\n\treturn BLK_STS_OK;\n}\n\nstatic void get_z2ram(void)\n{\n\tint i;\n\n\tfor (i = 0; i < Z2RAM_SIZE / Z2RAM_CHUNKSIZE; i++) {\n\t\tif (test_bit(i, zorro_unused_z2ram)) {\n\t\t\tz2_count++;\n\t\t\tz2ram_map[z2ram_size++] =\n\t\t\t    (unsigned long)ZTWO_VADDR(Z2RAM_START) +\n\t\t\t    (i << Z2RAM_CHUNKSHIFT);\n\t\t\tclear_bit(i, zorro_unused_z2ram);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic void get_chipram(void)\n{\n\n\twhile (amiga_chip_avail() > (Z2RAM_CHUNKSIZE * 4)) {\n\t\tchip_count++;\n\t\tz2ram_map[z2ram_size] =\n\t\t    (u_long) amiga_chip_alloc(Z2RAM_CHUNKSIZE, \"z2ram\");\n\n\t\tif (z2ram_map[z2ram_size] == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tz2ram_size++;\n\t}\n\n\treturn;\n}\n\nstatic int z2_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint device = disk->first_minor;\n\tint max_z2_map = (Z2RAM_SIZE / Z2RAM_CHUNKSIZE) * sizeof(z2ram_map[0]);\n\tint max_chip_map = (amiga_chip_size / Z2RAM_CHUNKSIZE) *\n\t    sizeof(z2ram_map[0]);\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&z2ram_mutex);\n\tif (current_device != -1 && current_device != device) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tif (current_device == -1) {\n\t\tz2_count = 0;\n\t\tchip_count = 0;\n\t\tlist_count = 0;\n\t\tz2ram_size = 0;\n\n\t\t \n\t\tif (device >= Z2MINOR_MEMLIST1 && device <= Z2MINOR_MEMLIST4) {\n\t\t\tint index = device - Z2MINOR_MEMLIST1 + 1;\n\t\t\tunsigned long size, paddr, vaddr;\n\n\t\t\tif (index >= m68k_realnum_memory) {\n\t\t\t\tprintk(KERN_ERR DEVICE_NAME\n\t\t\t\t       \": no such entry in z2ram_map\\n\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tpaddr = m68k_memory[index].addr;\n\t\t\tsize = m68k_memory[index].size & ~(Z2RAM_CHUNKSIZE - 1);\n\n#ifdef __powerpc__\n\t\t\t \n\t\t\t{\n\t\t\t\tvfree(vmalloc(size));\n\t\t\t}\n\n\t\t\tvaddr = (unsigned long)ioremap_wt(paddr, size);\n\n#else\n\t\t\tvaddr =\n\t\t\t    (unsigned long)z_remap_nocache_nonser(paddr, size);\n#endif\n\t\t\tz2ram_map =\n\t\t\t    kmalloc_array(size / Z2RAM_CHUNKSIZE,\n\t\t\t\t\t  sizeof(z2ram_map[0]), GFP_KERNEL);\n\t\t\tif (z2ram_map == NULL) {\n\t\t\t\tprintk(KERN_ERR DEVICE_NAME\n\t\t\t\t       \": cannot get mem for z2ram_map\\n\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\twhile (size) {\n\t\t\t\tz2ram_map[z2ram_size++] = vaddr;\n\t\t\t\tsize -= Z2RAM_CHUNKSIZE;\n\t\t\t\tvaddr += Z2RAM_CHUNKSIZE;\n\t\t\t\tlist_count++;\n\t\t\t}\n\n\t\t\tif (z2ram_size != 0)\n\t\t\t\tprintk(KERN_INFO DEVICE_NAME\n\t\t\t\t       \": using %iK List Entry %d Memory\\n\",\n\t\t\t\t       list_count * Z2RAM_CHUNK1024, index);\n\t\t} else\n\t\t\tswitch (device) {\n\t\t\tcase Z2MINOR_COMBINED:\n\n\t\t\t\tz2ram_map =\n\t\t\t\t    kmalloc(max_z2_map + max_chip_map,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\t\tif (z2ram_map == NULL) {\n\t\t\t\t\tprintk(KERN_ERR DEVICE_NAME\n\t\t\t\t\t       \": cannot get mem for z2ram_map\\n\");\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\n\t\t\t\tget_z2ram();\n\t\t\t\tget_chipram();\n\n\t\t\t\tif (z2ram_size != 0)\n\t\t\t\t\tprintk(KERN_INFO DEVICE_NAME\n\t\t\t\t\t       \": using %iK Zorro II RAM and %iK Chip RAM (Total %dK)\\n\",\n\t\t\t\t\t       z2_count * Z2RAM_CHUNK1024,\n\t\t\t\t\t       chip_count * Z2RAM_CHUNK1024,\n\t\t\t\t\t       (z2_count +\n\t\t\t\t\t\tchip_count) * Z2RAM_CHUNK1024);\n\n\t\t\t\tbreak;\n\n\t\t\tcase Z2MINOR_Z2ONLY:\n\t\t\t\tz2ram_map = kmalloc(max_z2_map, GFP_KERNEL);\n\t\t\t\tif (!z2ram_map)\n\t\t\t\t\tgoto err_out;\n\n\t\t\t\tget_z2ram();\n\n\t\t\t\tif (z2ram_size != 0)\n\t\t\t\t\tprintk(KERN_INFO DEVICE_NAME\n\t\t\t\t\t       \": using %iK of Zorro II RAM\\n\",\n\t\t\t\t\t       z2_count * Z2RAM_CHUNK1024);\n\n\t\t\t\tbreak;\n\n\t\t\tcase Z2MINOR_CHIPONLY:\n\t\t\t\tz2ram_map = kmalloc(max_chip_map, GFP_KERNEL);\n\t\t\t\tif (!z2ram_map)\n\t\t\t\t\tgoto err_out;\n\n\t\t\t\tget_chipram();\n\n\t\t\t\tif (z2ram_size != 0)\n\t\t\t\t\tprintk(KERN_INFO DEVICE_NAME\n\t\t\t\t\t       \": using %iK Chip RAM\\n\",\n\t\t\t\t\t       chip_count * Z2RAM_CHUNK1024);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto err_out;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (z2ram_size == 0) {\n\t\t\tprintk(KERN_NOTICE DEVICE_NAME\n\t\t\t       \": no unused ZII/Chip RAM found\\n\");\n\t\t\tgoto err_out_kfree;\n\t\t}\n\n\t\tcurrent_device = device;\n\t\tz2ram_size <<= Z2RAM_CHUNKSHIFT;\n\t\tset_capacity(z2ram_gendisk[device], z2ram_size >> 9);\n\t}\n\n\tmutex_unlock(&z2ram_mutex);\n\treturn 0;\n\nerr_out_kfree:\n\tkfree(z2ram_map);\nerr_out:\n\tmutex_unlock(&z2ram_mutex);\n\treturn rc;\n}\n\nstatic void z2_release(struct gendisk *disk)\n{\n\tmutex_lock(&z2ram_mutex);\n\tif (current_device == -1) {\n\t\tmutex_unlock(&z2ram_mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&z2ram_mutex);\n\t \n}\n\nstatic const struct block_device_operations z2_fops = {\n\t.owner = THIS_MODULE,\n\t.open = z2_open,\n\t.release = z2_release,\n};\n\nstatic struct blk_mq_tag_set tag_set;\n\nstatic const struct blk_mq_ops z2_mq_ops = {\n\t.queue_rq = z2_queue_rq,\n};\n\nstatic int z2ram_register_disk(int minor)\n{\n\tstruct gendisk *disk;\n\tint err;\n\n\tdisk = blk_mq_alloc_disk(&tag_set, NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tdisk->major = Z2RAM_MAJOR;\n\tdisk->first_minor = minor;\n\tdisk->minors = 1;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->fops = &z2_fops;\n\tif (minor)\n\t\tsprintf(disk->disk_name, \"z2ram%d\", minor);\n\telse\n\t\tsprintf(disk->disk_name, \"z2ram\");\n\n\tz2ram_gendisk[minor] = disk;\n\terr = add_disk(disk);\n\tif (err)\n\t\tput_disk(disk);\n\treturn err;\n}\n\nstatic int __init z2_init(void)\n{\n\tint ret, i;\n\n\tif (!MACH_IS_AMIGA)\n\t\treturn -ENODEV;\n\n\tif (register_blkdev(Z2RAM_MAJOR, DEVICE_NAME))\n\t\treturn -EBUSY;\n\n\ttag_set.ops = &z2_mq_ops;\n\ttag_set.nr_hw_queues = 1;\n\ttag_set.nr_maps = 1;\n\ttag_set.queue_depth = 16;\n\ttag_set.numa_node = NUMA_NO_NODE;\n\ttag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\tret = blk_mq_alloc_tag_set(&tag_set);\n\tif (ret)\n\t\tgoto out_unregister_blkdev;\n\n\tfor (i = 0; i < Z2MINOR_COUNT; i++) {\n\t\tret = z2ram_register_disk(i);\n\t\tif (ret && i == 0)\n\t\t\tgoto out_free_tagset;\n\t}\n\n\treturn 0;\n\nout_free_tagset:\n\tblk_mq_free_tag_set(&tag_set);\nout_unregister_blkdev:\n\tunregister_blkdev(Z2RAM_MAJOR, DEVICE_NAME);\n\treturn ret;\n}\n\nstatic void __exit z2_exit(void)\n{\n\tint i, j;\n\n\tunregister_blkdev(Z2RAM_MAJOR, DEVICE_NAME);\n\n\tfor (i = 0; i < Z2MINOR_COUNT; i++) {\n\t\tdel_gendisk(z2ram_gendisk[i]);\n\t\tput_disk(z2ram_gendisk[i]);\n\t}\n\tblk_mq_free_tag_set(&tag_set);\n\n\tif (current_device != -1) {\n\t\ti = 0;\n\n\t\tfor (j = 0; j < z2_count; j++) {\n\t\t\tset_bit(i++, zorro_unused_z2ram);\n\t\t}\n\n\t\tfor (j = 0; j < chip_count; j++) {\n\t\t\tif (z2ram_map[i]) {\n\t\t\t\tamiga_chip_free((void *)z2ram_map[i++]);\n\t\t\t}\n\t\t}\n\n\t\tif (z2ram_map != NULL) {\n\t\t\tkfree(z2ram_map);\n\t\t}\n\t}\n\n\treturn;\n}\n\nmodule_init(z2_init);\nmodule_exit(z2_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}