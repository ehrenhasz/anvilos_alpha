{
  "module_name": "swim.c",
  "hash_id": "a7c3f1c6b2d1c77bd28e427484c33f10764110afe1d869ca3745f262c71ffab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/swim.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fd.h>\n#include <linux/slab.h>\n#include <linux/blk-mq.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/hdreg.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n\n#include <asm/mac_via.h>\n\n#define CARDNAME \"swim\"\n\nstruct sector_header {\n\tunsigned char side;\n\tunsigned char track;\n\tunsigned char sector;\n\tunsigned char size;\n\tunsigned char crc0;\n\tunsigned char crc1;\n} __attribute__((packed));\n\n#define DRIVER_VERSION \"Version 0.2 (2008-10-30)\"\n\n#define REG(x)\tunsigned char x, x ## _pad[0x200 - 1];\n\nstruct swim {\n\tREG(write_data)\n\tREG(write_mark)\n\tREG(write_CRC)\n\tREG(write_parameter)\n\tREG(write_phase)\n\tREG(write_setup)\n\tREG(write_mode0)\n\tREG(write_mode1)\n\n\tREG(read_data)\n\tREG(read_mark)\n\tREG(read_error)\n\tREG(read_parameter)\n\tREG(read_phase)\n\tREG(read_setup)\n\tREG(read_status)\n\tREG(read_handshake)\n} __attribute__((packed));\n\n#define swim_write(base, reg, v) \tout_8(&(base)->write_##reg, (v))\n#define swim_read(base, reg)\t\tin_8(&(base)->read_##reg)\n\n \n\nstruct iwm {\n\tREG(ph0L)\n\tREG(ph0H)\n\tREG(ph1L)\n\tREG(ph1H)\n\tREG(ph2L)\n\tREG(ph2H)\n\tREG(ph3L)\n\tREG(ph3H)\n\tREG(mtrOff)\n\tREG(mtrOn)\n\tREG(intDrive)\n\tREG(extDrive)\n\tREG(q6L)\n\tREG(q6H)\n\tREG(q7L)\n\tREG(q7H)\n} __attribute__((packed));\n\n#define iwm_write(base, reg, v) \tout_8(&(base)->reg, (v))\n#define iwm_read(base, reg)\t\tin_8(&(base)->reg)\n\n \n\n#define SEEK_POSITIVE\t0x070\n#define SEEK_NEGATIVE\t0x074\n#define STEP\t\t0x071\n#define MOTOR_ON\t0x072\n#define MOTOR_OFF\t0x076\n#define INDEX\t\t0x073\n#define EJECT\t\t0x077\n#define SETMFM\t\t0x171\n#define SETGCR\t\t0x175\n\n#define RELAX\t\t0x033\n#define LSTRB\t\t0x008\n\n#define CA_MASK\t\t0x077\n\n \n\n#define READ_DATA_0\t0x074\n#define ONEMEG_DRIVE\t0x075\n#define SINGLE_SIDED\t0x076\n#define DRIVE_PRESENT\t0x077\n#define DISK_IN\t\t0x170\n#define WRITE_PROT\t0x171\n#define TRACK_ZERO\t0x172\n#define TACHO\t\t0x173\n#define READ_DATA_1\t0x174\n#define GCR_MODE\t0x175\n#define SEEK_COMPLETE\t0x176\n#define TWOMEG_MEDIA\t0x177\n\n \n\n#define MARK_BYTE\t0x01\n#define CRC_ZERO\t0x02\n#define RDDATA\t\t0x04\n#define SENSE\t\t0x08\n#define MOTEN\t\t0x10\n#define ERROR\t\t0x20\n#define DAT2BYTE\t0x40\n#define DAT1BYTE\t0x80\n\n \n\n#define S_INV_WDATA\t0x01\n#define S_3_5_SELECT\t0x02\n#define S_GCR\t\t0x04\n#define S_FCLK_DIV2\t0x08\n#define S_ERROR_CORR\t0x10\n#define S_IBM_DRIVE\t0x20\n#define S_GCR_WRITE\t0x40\n#define S_TIMEOUT\t0x80\n\n \n\n#define CLFIFO\t\t0x01\n#define ENBL1\t\t0x02\n#define ENBL2\t\t0x04\n#define ACTION\t\t0x08\n#define WRITE_MODE\t0x10\n#define HEDSEL\t\t0x20\n#define MOTON\t\t0x80\n\n \n\nenum drive_location {\n\tINTERNAL_DRIVE = 0x02,\n\tEXTERNAL_DRIVE = 0x04,\n};\n\nenum media_type {\n\tDD_MEDIA,\n\tHD_MEDIA,\n};\n\nstruct floppy_state {\n\n\t \n\n\tenum drive_location location;\t \n\tint\t\t head_number;\t \n\n\t \n\n\tint\t\t disk_in;\n\tint\t\t ejected;\n\tenum media_type\t type;\n\tint\t\t write_protected;\n\n\tint\t\t total_secs;\n\tint\t\t secpercyl;\n\tint\t\t secpertrack;\n\n\t \n\n\tint\t\ttrack;\n\tint\t\tref_count;\n\tbool registered;\n\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set tag_set;\n\n\t \n\n\tstruct swim_priv *swd;\n};\n\nenum motor_action {\n\tOFF,\n\tON,\n};\n\nenum head {\n\tLOWER_HEAD = 0,\n\tUPPER_HEAD = 1,\n};\n\n#define FD_MAX_UNIT\t2\n\nstruct swim_priv {\n\tstruct swim __iomem *base;\n\tspinlock_t lock;\n\tint floppy_count;\n\tstruct floppy_state unit[FD_MAX_UNIT];\n};\n\nextern int swim_read_sector_header(struct swim __iomem *base,\n\t\t\t\t   struct sector_header *header);\nextern int swim_read_sector_data(struct swim __iomem *base,\n\t\t\t\t unsigned char *data);\n\nstatic DEFINE_MUTEX(swim_mutex);\nstatic inline void set_swim_mode(struct swim __iomem *base, int enable)\n{\n\tstruct iwm __iomem *iwm_base;\n\tunsigned long flags;\n\n\tif (!enable) {\n\t\tswim_write(base, mode0, 0xf8);\n\t\treturn;\n\t}\n\n\tiwm_base = (struct iwm __iomem *)base;\n\tlocal_irq_save(flags);\n\n\tiwm_read(iwm_base, q7L);\n\tiwm_read(iwm_base, mtrOff);\n\tiwm_read(iwm_base, q6H);\n\n\tiwm_write(iwm_base, q7H, 0x57);\n\tiwm_write(iwm_base, q7H, 0x17);\n\tiwm_write(iwm_base, q7H, 0x57);\n\tiwm_write(iwm_base, q7H, 0x57);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline int get_swim_mode(struct swim __iomem *base)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tswim_write(base, phase, 0xf5);\n\tif (swim_read(base, phase) != 0xf5)\n\t\tgoto is_iwm;\n\tswim_write(base, phase, 0xf6);\n\tif (swim_read(base, phase) != 0xf6)\n\t\tgoto is_iwm;\n\tswim_write(base, phase, 0xf7);\n\tif (swim_read(base, phase) != 0xf7)\n\t\tgoto is_iwm;\n\tlocal_irq_restore(flags);\n\treturn 1;\nis_iwm:\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\nstatic inline void swim_select(struct swim __iomem *base, int sel)\n{\n\tswim_write(base, phase, RELAX);\n\n\tvia1_set_head(sel & 0x100);\n\n\tswim_write(base, phase, sel & CA_MASK);\n}\n\nstatic inline void swim_action(struct swim __iomem *base, int action)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tswim_select(base, action);\n\tudelay(1);\n\tswim_write(base, phase, (LSTRB<<4) | LSTRB);\n\tudelay(1);\n\tswim_write(base, phase, (LSTRB<<4) | ((~LSTRB) & 0x0F));\n\tudelay(1);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline int swim_readbit(struct swim __iomem *base, int bit)\n{\n\tint stat;\n\n\tswim_select(base, bit);\n\n\tudelay(10);\n\n\tstat = swim_read(base, handshake);\n\n\treturn (stat & SENSE) == 0;\n}\n\nstatic inline void swim_drive(struct swim __iomem *base,\n\t\t\t      enum drive_location location)\n{\n\tif (location == INTERNAL_DRIVE) {\n\t\tswim_write(base, mode0, EXTERNAL_DRIVE);  \n\t\tswim_write(base, mode1, INTERNAL_DRIVE);  \n\t} else if (location == EXTERNAL_DRIVE) {\n\t\tswim_write(base, mode0, INTERNAL_DRIVE);  \n\t\tswim_write(base, mode1, EXTERNAL_DRIVE);  \n\t}\n}\n\nstatic inline void swim_motor(struct swim __iomem *base,\n\t\t\t      enum motor_action action)\n{\n\tif (action == ON) {\n\t\tint i;\n\n\t\tswim_action(base, MOTOR_ON);\n\n\t\tfor (i = 0; i < 2*HZ; i++) {\n\t\t\tswim_select(base, RELAX);\n\t\t\tif (swim_readbit(base, MOTOR_ON))\n\t\t\t\tbreak;\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(1);\n\t\t}\n\t} else if (action == OFF) {\n\t\tswim_action(base, MOTOR_OFF);\n\t\tswim_select(base, RELAX);\n\t}\n}\n\nstatic inline void swim_eject(struct swim __iomem *base)\n{\n\tint i;\n\n\tswim_action(base, EJECT);\n\n\tfor (i = 0; i < 2*HZ; i++) {\n\t\tswim_select(base, RELAX);\n\t\tif (!swim_readbit(base, DISK_IN))\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(1);\n\t}\n\tswim_select(base, RELAX);\n}\n\nstatic inline void swim_head(struct swim __iomem *base, enum head head)\n{\n\t \n\n\tif (head == UPPER_HEAD)\n\t\tswim_select(base, READ_DATA_1);\n\telse if (head == LOWER_HEAD)\n\t\tswim_select(base, READ_DATA_0);\n}\n\nstatic inline int swim_step(struct swim __iomem *base)\n{\n\tint wait;\n\n\tswim_action(base, STEP);\n\n\tfor (wait = 0; wait < HZ; wait++) {\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(1);\n\n\t\tswim_select(base, RELAX);\n\t\tif (!swim_readbit(base, STEP))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic inline int swim_track00(struct swim __iomem *base)\n{\n\tint try;\n\n\tswim_action(base, SEEK_NEGATIVE);\n\n\tfor (try = 0; try < 100; try++) {\n\n\t\tswim_select(base, RELAX);\n\t\tif (swim_readbit(base, TRACK_ZERO))\n\t\t\tbreak;\n\n\t\tif (swim_step(base))\n\t\t\treturn -1;\n\t}\n\n\tif (swim_readbit(base, TRACK_ZERO))\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic inline int swim_seek(struct swim __iomem *base, int step)\n{\n\tif (step == 0)\n\t\treturn 0;\n\n\tif (step < 0) {\n\t\tswim_action(base, SEEK_NEGATIVE);\n\t\tstep = -step;\n\t} else\n\t\tswim_action(base, SEEK_POSITIVE);\n\n\tfor ( ; step > 0; step--) {\n\t\tif (swim_step(base))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int swim_track(struct floppy_state *fs,  int track)\n{\n\tstruct swim __iomem *base = fs->swd->base;\n\tint ret;\n\n\tret = swim_seek(base, track - fs->track);\n\n\tif (ret == 0)\n\t\tfs->track = track;\n\telse {\n\t\tswim_track00(base);\n\t\tfs->track = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int floppy_eject(struct floppy_state *fs)\n{\n\tstruct swim __iomem *base = fs->swd->base;\n\n\tswim_drive(base, fs->location);\n\tswim_motor(base, OFF);\n\tswim_eject(base);\n\n\tfs->disk_in = 0;\n\tfs->ejected = 1;\n\n\treturn 0;\n}\n\nstatic inline int swim_read_sector(struct floppy_state *fs,\n\t\t\t\t   int side, int track,\n\t\t\t\t   int sector, unsigned char *buffer)\n{\n\tstruct swim __iomem *base = fs->swd->base;\n\tunsigned long flags;\n\tstruct sector_header header;\n\tint ret = -1;\n\tshort i;\n\n\tswim_track(fs, track);\n\n\tswim_write(base, mode1, MOTON);\n\tswim_head(base, side);\n\tswim_write(base, mode0, side);\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; i < 36; i++) {\n\t\tret = swim_read_sector_header(base, &header);\n\t\tif (!ret && (header.sector == sector)) {\n\t\t\t \n\n\t\t\tret = swim_read_sector_data(base, buffer);\n\t\t\tbreak;\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n\n\tswim_write(base, mode0, MOTON);\n\n\tif ((header.side != side)  || (header.track != track) ||\n\t     (header.sector != sector))\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic blk_status_t floppy_read_sectors(struct floppy_state *fs,\n\t\t\t       int req_sector, int sectors_nb,\n\t\t\t       unsigned char *buffer)\n{\n\tstruct swim __iomem *base = fs->swd->base;\n\tint ret;\n\tint side, track, sector;\n\tint i, try;\n\n\n\tswim_drive(base, fs->location);\n\tfor (i = req_sector; i < req_sector + sectors_nb; i++) {\n\t\tint x;\n\t\ttrack = i / fs->secpercyl;\n\t\tx = i % fs->secpercyl;\n\t\tside = x / fs->secpertrack;\n\t\tsector = x % fs->secpertrack + 1;\n\n\t\ttry = 5;\n\t\tdo {\n\t\t\tret = swim_read_sector(fs, side, track, sector,\n\t\t\t\t\t\tbuffer);\n\t\t\tif (try-- == 0)\n\t\t\t\treturn BLK_STS_IOERR;\n\t\t} while (ret != 512);\n\n\t\tbuffer += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic blk_status_t swim_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t  const struct blk_mq_queue_data *bd)\n{\n\tstruct floppy_state *fs = hctx->queue->queuedata;\n\tstruct swim_priv *swd = fs->swd;\n\tstruct request *req = bd->rq;\n\tblk_status_t err;\n\n\tif (!spin_trylock_irq(&swd->lock))\n\t\treturn BLK_STS_DEV_RESOURCE;\n\n\tblk_mq_start_request(req);\n\n\tif (!fs->disk_in || rq_data_dir(req) == WRITE) {\n\t\terr = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\terr = floppy_read_sectors(fs, blk_rq_pos(req),\n\t\t\t\t\t  blk_rq_cur_sectors(req),\n\t\t\t\t\t  bio_data(req->bio));\n\t} while (blk_update_request(req, err, blk_rq_cur_bytes(req)));\n\t__blk_mq_end_request(req, err);\n\n\terr = BLK_STS_OK;\nout:\n\tspin_unlock_irq(&swd->lock);\n\treturn err;\n\n}\n\nstatic struct floppy_struct floppy_type[4] = {\n\t{    0,  0, 0,  0, 0, 0x00, 0x00, 0x00, 0x00, NULL },  \n\t{  720,  9, 1, 80, 0, 0x2A, 0x02, 0xDF, 0x50, NULL },  \n\t{ 1440,  9, 2, 80, 0, 0x2A, 0x02, 0xDF, 0x50, NULL },  \n\t{ 2880, 18, 2, 80, 0, 0x1B, 0x00, 0xCF, 0x6C, NULL },  \n};\n\nstatic int get_floppy_geometry(struct floppy_state *fs, int type,\n\t\t\t       struct floppy_struct **g)\n{\n\tif (type >= ARRAY_SIZE(floppy_type))\n\t\treturn -EINVAL;\n\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse if (fs->type == HD_MEDIA)  \n\t\t*g = &floppy_type[3];\n\telse if (fs->head_number == 2)  \n\t\t*g = &floppy_type[2];\n\telse\n\t\t*g = &floppy_type[1];\n\n\treturn 0;\n}\n\nstatic void setup_medium(struct floppy_state *fs)\n{\n\tstruct swim __iomem *base = fs->swd->base;\n\n\tif (swim_readbit(base, DISK_IN)) {\n\t\tstruct floppy_struct *g;\n\t\tfs->disk_in = 1;\n\t\tfs->write_protected = swim_readbit(base, WRITE_PROT);\n\n\t\tif (swim_track00(base))\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"SWIM: cannot move floppy head to track 0\\n\");\n\n\t\tswim_track00(base);\n\n\t\tfs->type = swim_readbit(base, TWOMEG_MEDIA) ?\n\t\t\tHD_MEDIA : DD_MEDIA;\n\t\tfs->head_number = swim_readbit(base, SINGLE_SIDED) ? 1 : 2;\n\t\tget_floppy_geometry(fs, 0, &g);\n\t\tfs->total_secs = g->size;\n\t\tfs->secpercyl = g->head * g->sect;\n\t\tfs->secpertrack = g->sect;\n\t\tfs->track = 0;\n\t} else {\n\t\tfs->disk_in = 0;\n\t}\n}\n\nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\tstruct swim __iomem *base = fs->swd->base;\n\tint err;\n\n\tif (fs->ref_count == -1 || (fs->ref_count && mode & BLK_OPEN_EXCL))\n\t\treturn -EBUSY;\n\tif (mode & BLK_OPEN_EXCL)\n\t\tfs->ref_count = -1;\n\telse\n\t\tfs->ref_count++;\n\tswim_write(base, setup, S_IBM_DRIVE  | S_FCLK_DIV2);\n\tudelay(10);\n\tswim_drive(base, fs->location);\n\tswim_motor(base, ON);\n\tswim_action(base, SETMFM);\n\tif (fs->ejected)\n\t\tsetup_medium(fs);\n\tif (!fs->disk_in) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tset_capacity(fs->disk, fs->total_secs);\n\n\tif (mode & BLK_OPEN_NDELAY)\n\t\treturn 0;\n\n\tif (mode & (BLK_OPEN_READ | BLK_OPEN_WRITE)) {\n\t\tif (disk_check_media_change(disk) && fs->disk_in)\n\t\t\tfs->ejected = 0;\n\t\tif ((mode & BLK_OPEN_WRITE) && fs->write_protected) {\n\t\t\terr = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tif (fs->ref_count < 0)\n\t\tfs->ref_count = 0;\n\telse if (fs->ref_count > 0)\n\t\t--fs->ref_count;\n\n\tif (fs->ref_count == 0)\n\t\tswim_motor(base, OFF);\n\treturn err;\n}\n\nstatic int floppy_unlocked_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint ret;\n\n\tmutex_lock(&swim_mutex);\n\tret = floppy_open(disk, mode);\n\tmutex_unlock(&swim_mutex);\n\n\treturn ret;\n}\n\nstatic void floppy_release(struct gendisk *disk)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\tstruct swim __iomem *base = fs->swd->base;\n\n\tmutex_lock(&swim_mutex);\n\tif (fs->ref_count < 0)\n\t\tfs->ref_count = 0;\n\telse if (fs->ref_count > 0)\n\t\t--fs->ref_count;\n\n\tif (fs->ref_count == 0)\n\t\tswim_motor(base, OFF);\n\tmutex_unlock(&swim_mutex);\n}\n\nstatic int floppy_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\tunsigned int cmd, unsigned long param)\n{\n\tstruct floppy_state *fs = bdev->bd_disk->private_data;\n\tint err;\n\n\tif ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (fs->ref_count != 1)\n\t\t\treturn -EBUSY;\n\t\tmutex_lock(&swim_mutex);\n\t\terr = floppy_eject(fs);\n\t\tmutex_unlock(&swim_mutex);\n\t\treturn err;\n\n\tcase FDGETPRM:\n\t\tif (copy_to_user((void __user *) param, (void *) &floppy_type,\n\t\t\t\t sizeof(struct floppy_struct)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int floppy_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct floppy_state *fs = bdev->bd_disk->private_data;\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(fs, 0, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\n\treturn 0;\n}\n\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\n\treturn fs->ejected ? DISK_EVENT_MEDIA_CHANGE : 0;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t = THIS_MODULE,\n\t.open\t\t = floppy_unlocked_open,\n\t.release\t = floppy_release,\n\t.ioctl\t\t = floppy_ioctl,\n\t.getgeo\t\t = floppy_getgeo,\n\t.check_events\t = floppy_check_events,\n};\n\nstatic int swim_add_floppy(struct swim_priv *swd, enum drive_location location)\n{\n\tstruct floppy_state *fs = &swd->unit[swd->floppy_count];\n\tstruct swim __iomem *base = swd->base;\n\n\tfs->location = location;\n\n\tswim_drive(base, location);\n\n\tswim_motor(base, OFF);\n\n\tfs->type = HD_MEDIA;\n\tfs->head_number = 2;\n\n\tfs->ref_count = 0;\n\tfs->ejected = 1;\n\n\tswd->floppy_count++;\n\n\treturn 0;\n}\n\nstatic const struct blk_mq_ops swim_mq_ops = {\n\t.queue_rq = swim_queue_rq,\n};\n\nstatic void swim_cleanup_floppy_disk(struct floppy_state *fs)\n{\n\tstruct gendisk *disk = fs->disk;\n\n\tif (!disk)\n\t\treturn;\n\n\tif (fs->registered)\n\t\tdel_gendisk(fs->disk);\n\n\tput_disk(disk);\n\tblk_mq_free_tag_set(&fs->tag_set);\n}\n\nstatic int swim_floppy_init(struct swim_priv *swd)\n{\n\tint err;\n\tint drive;\n\tstruct swim __iomem *base = swd->base;\n\n\t \n\n\tswim_drive(base, INTERNAL_DRIVE);\n\tif (swim_readbit(base, DRIVE_PRESENT) &&\n\t    !swim_readbit(base, ONEMEG_DRIVE))\n\t\tswim_add_floppy(swd, INTERNAL_DRIVE);\n\tswim_drive(base, EXTERNAL_DRIVE);\n\tif (swim_readbit(base, DRIVE_PRESENT) &&\n\t    !swim_readbit(base, ONEMEG_DRIVE))\n\t\tswim_add_floppy(swd, EXTERNAL_DRIVE);\n\n\t \n\n\terr = register_blkdev(FLOPPY_MAJOR, \"fd\");\n\tif (err) {\n\t\tprintk(KERN_ERR \"Unable to get major %d for SWIM floppy\\n\",\n\t\t       FLOPPY_MAJOR);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_lock_init(&swd->lock);\n\n\tfor (drive = 0; drive < swd->floppy_count; drive++) {\n\t\terr = blk_mq_alloc_sq_tag_set(&swd->unit[drive].tag_set,\n\t\t\t\t&swim_mq_ops, 2, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (err)\n\t\t\tgoto exit_put_disks;\n\n\t\tswd->unit[drive].disk =\n\t\t\tblk_mq_alloc_disk(&swd->unit[drive].tag_set,\n\t\t\t\t\t  &swd->unit[drive]);\n\t\tif (IS_ERR(swd->unit[drive].disk)) {\n\t\t\tblk_mq_free_tag_set(&swd->unit[drive].tag_set);\n\t\t\terr = PTR_ERR(swd->unit[drive].disk);\n\t\t\tgoto exit_put_disks;\n\t\t}\n\n\t\tswd->unit[drive].swd = swd;\n\t}\n\n\tfor (drive = 0; drive < swd->floppy_count; drive++) {\n\t\tswd->unit[drive].disk->flags = GENHD_FL_REMOVABLE;\n\t\tswd->unit[drive].disk->major = FLOPPY_MAJOR;\n\t\tswd->unit[drive].disk->first_minor = drive;\n\t\tswd->unit[drive].disk->minors = 1;\n\t\tsprintf(swd->unit[drive].disk->disk_name, \"fd%d\", drive);\n\t\tswd->unit[drive].disk->fops = &floppy_fops;\n\t\tswd->unit[drive].disk->flags |= GENHD_FL_NO_PART;\n\t\tswd->unit[drive].disk->events = DISK_EVENT_MEDIA_CHANGE;\n\t\tswd->unit[drive].disk->private_data = &swd->unit[drive];\n\t\tset_capacity(swd->unit[drive].disk, 2880);\n\t\terr = add_disk(swd->unit[drive].disk);\n\t\tif (err)\n\t\t\tgoto exit_put_disks;\n\t\tswd->unit[drive].registered = true;\n\t}\n\n\treturn 0;\n\nexit_put_disks:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tdo {\n\t\tswim_cleanup_floppy_disk(&swd->unit[drive]);\n\t} while (drive--);\n\treturn err;\n}\n\nstatic int swim_probe(struct platform_device *dev)\n{\n\tstruct resource *res;\n\tstruct swim __iomem *swim_base;\n\tstruct swim_priv *swd;\n\tint ret;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!request_mem_region(res->start, resource_size(res), CARDNAME)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tswim_base = (struct swim __iomem *)res->start;\n\tif (!swim_base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release_io;\n\t}\n\n\t \n\n\tset_swim_mode(swim_base, 1);\n\tif (!get_swim_mode(swim_base)) {\n\t\tprintk(KERN_INFO \"SWIM device not found !\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_release_io;\n\t}\n\n\t \n\n\tswd = kzalloc(sizeof(struct swim_priv), GFP_KERNEL);\n\tif (!swd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release_io;\n\t}\n\tplatform_set_drvdata(dev, swd);\n\n\tswd->base = swim_base;\n\n\tret = swim_floppy_init(swd);\n\tif (ret)\n\t\tgoto out_kfree;\n\n\treturn 0;\n\nout_kfree:\n\tkfree(swd);\nout_release_io:\n\trelease_mem_region(res->start, resource_size(res));\nout:\n\treturn ret;\n}\n\nstatic int swim_remove(struct platform_device *dev)\n{\n\tstruct swim_priv *swd = platform_get_drvdata(dev);\n\tint drive;\n\tstruct resource *res;\n\n\tfor (drive = 0; drive < swd->floppy_count; drive++)\n\t\tswim_cleanup_floppy_disk(&swd->unit[drive]);\n\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\n\t \n\n\tfor (drive = 0; drive < swd->floppy_count; drive++)\n\t\tfloppy_eject(&swd->unit[drive]);\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (res)\n\t\trelease_mem_region(res->start, resource_size(res));\n\n\tkfree(swd);\n\n\treturn 0;\n}\n\nstatic struct platform_driver swim_driver = {\n\t.probe  = swim_probe,\n\t.remove = swim_remove,\n\t.driver   = {\n\t\t.name\t= CARDNAME,\n\t},\n};\n\nstatic int __init swim_init(void)\n{\n\tprintk(KERN_INFO \"SWIM floppy driver %s\\n\", DRIVER_VERSION);\n\n\treturn platform_driver_register(&swim_driver);\n}\nmodule_init(swim_init);\n\nstatic void __exit swim_exit(void)\n{\n\tplatform_driver_unregister(&swim_driver);\n}\nmodule_exit(swim_exit);\n\nMODULE_DESCRIPTION(\"Driver for SWIM floppy controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Laurent Vivier <laurent@lvivier.info>\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}