{
  "module_name": "ps3vram.c",
  "hash_id": "4f52191e7a3a79df67dd69a58a93bdc90342cdf1a523df48a9b2ac8ca71b53a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/ps3vram.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <asm/cell-regs.h>\n#include <asm/firmware.h>\n#include <asm/lv1call.h>\n#include <asm/ps3.h>\n#include <asm/ps3gpu.h>\n\n\n#define DEVICE_NAME\t\t\"ps3vram\"\n\n\n#define XDR_BUF_SIZE (2 * 1024 * 1024)  \n#define XDR_IOIF 0x0c000000\n\n#define FIFO_BASE XDR_IOIF\n#define FIFO_SIZE (64 * 1024)\n\n#define DMA_PAGE_SIZE (4 * 1024)\n\n#define CACHE_PAGE_SIZE (256 * 1024)\n#define CACHE_PAGE_COUNT ((XDR_BUF_SIZE - FIFO_SIZE) / CACHE_PAGE_SIZE)\n\n#define CACHE_OFFSET CACHE_PAGE_SIZE\n#define FIFO_OFFSET 0\n\n#define CTRL_PUT 0x10\n#define CTRL_GET 0x11\n#define CTRL_TOP 0x15\n\n#define UPLOAD_SUBCH\t1\n#define DOWNLOAD_SUBCH\t2\n\n#define NV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN\t0x0000030c\n#define NV_MEMORY_TO_MEMORY_FORMAT_NOTIFY\t0x00000104\n\n#define CACHE_PAGE_PRESENT 1\n#define CACHE_PAGE_DIRTY   2\n\nstruct ps3vram_tag {\n\tunsigned int address;\n\tunsigned int flags;\n};\n\nstruct ps3vram_cache {\n\tunsigned int page_count;\n\tunsigned int page_size;\n\tstruct ps3vram_tag *tags;\n\tunsigned int hit;\n\tunsigned int miss;\n};\n\nstruct ps3vram_priv {\n\tstruct gendisk *gendisk;\n\n\tu64 size;\n\n\tu64 memory_handle;\n\tu64 context_handle;\n\tu32 __iomem *ctrl;\n\tvoid __iomem *reports;\n\tu8 *xdr_buf;\n\n\tu32 *fifo_base;\n\tu32 *fifo_ptr;\n\n\tstruct ps3vram_cache cache;\n\n\tspinlock_t lock;\t \n\tstruct bio_list list;\n};\n\n\nstatic int ps3vram_major;\n\n#define DMA_NOTIFIER_HANDLE_BASE 0x66604200  \n#define DMA_NOTIFIER_OFFSET_BASE 0x1000      \n#define DMA_NOTIFIER_SIZE        0x40\n#define NOTIFIER 7\t \n\nstatic char *size = \"256M\";\nmodule_param(size, charp, 0);\nMODULE_PARM_DESC(size, \"memory size\");\n\nstatic u32 __iomem *ps3vram_get_notifier(void __iomem *reports, int notifier)\n{\n\treturn reports + DMA_NOTIFIER_OFFSET_BASE +\n\t       DMA_NOTIFIER_SIZE * notifier;\n}\n\nstatic void ps3vram_notifier_reset(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tu32 __iomem *notify = ps3vram_get_notifier(priv->reports, NOTIFIER);\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tiowrite32be(0xffffffff, notify + i);\n}\n\nstatic int ps3vram_notifier_wait(struct ps3_system_bus_device *dev,\n\t\t\t\t unsigned int timeout_ms)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tu32 __iomem *notify = ps3vram_get_notifier(priv->reports, NOTIFIER);\n\tunsigned long timeout;\n\n\tfor (timeout = 20; timeout; timeout--) {\n\t\tif (!ioread32be(notify + 3))\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout_ms);\n\n\tdo {\n\t\tif (!ioread32be(notify + 3))\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void ps3vram_init_ring(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tiowrite32be(FIFO_BASE + FIFO_OFFSET, priv->ctrl + CTRL_PUT);\n\tiowrite32be(FIFO_BASE + FIFO_OFFSET, priv->ctrl + CTRL_GET);\n}\n\nstatic int ps3vram_wait_ring(struct ps3_system_bus_device *dev,\n\t\t\t     unsigned int timeout_ms)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tunsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);\n\n\tdo {\n\t\tif (ioread32be(priv->ctrl + CTRL_PUT) == ioread32be(priv->ctrl + CTRL_GET))\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t} while (time_before(jiffies, timeout));\n\n\tdev_warn(&dev->core, \"FIFO timeout (%08x/%08x/%08x)\\n\",\n\t\t ioread32be(priv->ctrl + CTRL_PUT), ioread32be(priv->ctrl + CTRL_GET),\n\t\t ioread32be(priv->ctrl + CTRL_TOP));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void ps3vram_out_ring(struct ps3vram_priv *priv, u32 data)\n{\n\t*(priv->fifo_ptr)++ = data;\n}\n\nstatic void ps3vram_begin_ring(struct ps3vram_priv *priv, u32 chan, u32 tag,\n\t\t\t       u32 size)\n{\n\tps3vram_out_ring(priv, (size << 18) | (chan << 13) | tag);\n}\n\nstatic void ps3vram_rewind_ring(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tint status;\n\n\tps3vram_out_ring(priv, 0x20000000 | (FIFO_BASE + FIFO_OFFSET));\n\n\tiowrite32be(FIFO_BASE + FIFO_OFFSET, priv->ctrl + CTRL_PUT);\n\n\t \n\tstatus = lv1_gpu_fb_blit(priv->context_handle, 0, 0, 0, 0);\n\tif (status)\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_fb_blit failed %d\\n\",\n\t\t\t__func__, status);\n\n\tpriv->fifo_ptr = priv->fifo_base;\n}\n\nstatic void ps3vram_fire_ring(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tint status;\n\n\tmutex_lock(&ps3_gpu_mutex);\n\n\tiowrite32be(FIFO_BASE + FIFO_OFFSET + (priv->fifo_ptr - priv->fifo_base)\n\t\t* sizeof(u32), priv->ctrl + CTRL_PUT);\n\n\t \n\tstatus = lv1_gpu_fb_blit(priv->context_handle, 0, 0, 0, 0);\n\tif (status)\n\t\tdev_err(&dev->core, \"%s: lv1_gpu_fb_blit failed %d\\n\",\n\t\t\t__func__, status);\n\n\tif ((priv->fifo_ptr - priv->fifo_base) * sizeof(u32) >\n\t    FIFO_SIZE - 1024) {\n\t\tdev_dbg(&dev->core, \"FIFO full, rewinding\\n\");\n\t\tps3vram_wait_ring(dev, 200);\n\t\tps3vram_rewind_ring(dev);\n\t}\n\n\tmutex_unlock(&ps3_gpu_mutex);\n}\n\nstatic void ps3vram_bind(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tps3vram_begin_ring(priv, UPLOAD_SUBCH, 0, 1);\n\tps3vram_out_ring(priv, 0x31337303);\n\tps3vram_begin_ring(priv, UPLOAD_SUBCH, 0x180, 3);\n\tps3vram_out_ring(priv, DMA_NOTIFIER_HANDLE_BASE + NOTIFIER);\n\tps3vram_out_ring(priv, 0xfeed0001);\t \n\tps3vram_out_ring(priv, 0xfeed0000);      \n\n\tps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0, 1);\n\tps3vram_out_ring(priv, 0x3137c0de);\n\tps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0x180, 3);\n\tps3vram_out_ring(priv, DMA_NOTIFIER_HANDLE_BASE + NOTIFIER);\n\tps3vram_out_ring(priv, 0xfeed0000);\t \n\tps3vram_out_ring(priv, 0xfeed0001);\t \n\n\tps3vram_fire_ring(dev);\n}\n\nstatic int ps3vram_upload(struct ps3_system_bus_device *dev,\n\t\t\t  unsigned int src_offset, unsigned int dst_offset,\n\t\t\t  int len, int count)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tps3vram_begin_ring(priv, UPLOAD_SUBCH,\n\t\t\t   NV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 8);\n\tps3vram_out_ring(priv, XDR_IOIF + src_offset);\n\tps3vram_out_ring(priv, dst_offset);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, count);\n\tps3vram_out_ring(priv, (1 << 8) | 1);\n\tps3vram_out_ring(priv, 0);\n\n\tps3vram_notifier_reset(dev);\n\tps3vram_begin_ring(priv, UPLOAD_SUBCH,\n\t\t\t   NV_MEMORY_TO_MEMORY_FORMAT_NOTIFY, 1);\n\tps3vram_out_ring(priv, 0);\n\tps3vram_begin_ring(priv, UPLOAD_SUBCH, 0x100, 1);\n\tps3vram_out_ring(priv, 0);\n\tps3vram_fire_ring(dev);\n\tif (ps3vram_notifier_wait(dev, 200) < 0) {\n\t\tdev_warn(&dev->core, \"%s: Notifier timeout\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ps3vram_download(struct ps3_system_bus_device *dev,\n\t\t\t    unsigned int src_offset, unsigned int dst_offset,\n\t\t\t    int len, int count)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tps3vram_begin_ring(priv, DOWNLOAD_SUBCH,\n\t\t\t   NV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 8);\n\tps3vram_out_ring(priv, src_offset);\n\tps3vram_out_ring(priv, XDR_IOIF + dst_offset);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, len);\n\tps3vram_out_ring(priv, count);\n\tps3vram_out_ring(priv, (1 << 8) | 1);\n\tps3vram_out_ring(priv, 0);\n\n\tps3vram_notifier_reset(dev);\n\tps3vram_begin_ring(priv, DOWNLOAD_SUBCH,\n\t\t\t   NV_MEMORY_TO_MEMORY_FORMAT_NOTIFY, 1);\n\tps3vram_out_ring(priv, 0);\n\tps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0x100, 1);\n\tps3vram_out_ring(priv, 0);\n\tps3vram_fire_ring(dev);\n\tif (ps3vram_notifier_wait(dev, 200) < 0) {\n\t\tdev_warn(&dev->core, \"%s: Notifier timeout\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void ps3vram_cache_evict(struct ps3_system_bus_device *dev, int entry)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tstruct ps3vram_cache *cache = &priv->cache;\n\n\tif (!(cache->tags[entry].flags & CACHE_PAGE_DIRTY))\n\t\treturn;\n\n\tdev_dbg(&dev->core, \"Flushing %d: 0x%08x\\n\", entry,\n\t\tcache->tags[entry].address);\n\tif (ps3vram_upload(dev, CACHE_OFFSET + entry * cache->page_size,\n\t\t\t   cache->tags[entry].address, DMA_PAGE_SIZE,\n\t\t\t   cache->page_size / DMA_PAGE_SIZE) < 0) {\n\t\tdev_err(&dev->core,\n\t\t\t\"Failed to upload from 0x%x to \" \"0x%x size 0x%x\\n\",\n\t\t\tentry * cache->page_size, cache->tags[entry].address,\n\t\t\tcache->page_size);\n\t}\n\tcache->tags[entry].flags &= ~CACHE_PAGE_DIRTY;\n}\n\nstatic void ps3vram_cache_load(struct ps3_system_bus_device *dev, int entry,\n\t\t\t       unsigned int address)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tstruct ps3vram_cache *cache = &priv->cache;\n\n\tdev_dbg(&dev->core, \"Fetching %d: 0x%08x\\n\", entry, address);\n\tif (ps3vram_download(dev, address,\n\t\t\t     CACHE_OFFSET + entry * cache->page_size,\n\t\t\t     DMA_PAGE_SIZE,\n\t\t\t     cache->page_size / DMA_PAGE_SIZE) < 0) {\n\t\tdev_err(&dev->core,\n\t\t\t\"Failed to download from 0x%x to 0x%x size 0x%x\\n\",\n\t\t\taddress, entry * cache->page_size, cache->page_size);\n\t}\n\n\tcache->tags[entry].address = address;\n\tcache->tags[entry].flags |= CACHE_PAGE_PRESENT;\n}\n\n\nstatic void ps3vram_cache_flush(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tstruct ps3vram_cache *cache = &priv->cache;\n\tint i;\n\n\tdev_dbg(&dev->core, \"FLUSH\\n\");\n\tfor (i = 0; i < cache->page_count; i++) {\n\t\tps3vram_cache_evict(dev, i);\n\t\tcache->tags[i].flags = 0;\n\t}\n}\n\nstatic unsigned int ps3vram_cache_match(struct ps3_system_bus_device *dev,\n\t\t\t\t\tloff_t address)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tstruct ps3vram_cache *cache = &priv->cache;\n\tunsigned int base;\n\tunsigned int offset;\n\tint i;\n\tstatic int counter;\n\n\toffset = (unsigned int) (address & (cache->page_size - 1));\n\tbase = (unsigned int) (address - offset);\n\n\t \n\tfor (i = 0; i < cache->page_count; i++) {\n\t\tif ((cache->tags[i].flags & CACHE_PAGE_PRESENT) &&\n\t\t    cache->tags[i].address == base) {\n\t\t\tcache->hit++;\n\t\t\tdev_dbg(&dev->core, \"Found entry %d: 0x%08x\\n\", i,\n\t\t\t\tcache->tags[i].address);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t \n\ti = (jiffies + (counter++)) % cache->page_count;\n\tdev_dbg(&dev->core, \"Using entry %d\\n\", i);\n\n\tps3vram_cache_evict(dev, i);\n\tps3vram_cache_load(dev, i, base);\n\n\tcache->miss++;\n\treturn i;\n}\n\nstatic int ps3vram_cache_init(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tpriv->cache.page_count = CACHE_PAGE_COUNT;\n\tpriv->cache.page_size = CACHE_PAGE_SIZE;\n\tpriv->cache.tags = kcalloc(CACHE_PAGE_COUNT,\n\t\t\t\t   sizeof(struct ps3vram_tag),\n\t\t\t\t   GFP_KERNEL);\n\tif (!priv->cache.tags)\n\t\treturn -ENOMEM;\n\n\tdev_info(&dev->core, \"Created ram cache: %d entries, %d KiB each\\n\",\n\t\tCACHE_PAGE_COUNT, CACHE_PAGE_SIZE / 1024);\n\n\treturn 0;\n}\n\nstatic void ps3vram_cache_cleanup(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tps3vram_cache_flush(dev);\n\tkfree(priv->cache.tags);\n}\n\nstatic blk_status_t ps3vram_read(struct ps3_system_bus_device *dev, loff_t from,\n\t\t\tsize_t len, size_t *retlen, u_char *buf)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tunsigned int cached, count;\n\n\tdev_dbg(&dev->core, \"%s: from=0x%08x len=0x%zx\\n\", __func__,\n\t\t(unsigned int)from, len);\n\n\tif (from >= priv->size)\n\t\treturn BLK_STS_IOERR;\n\n\tif (len > priv->size - from)\n\t\tlen = priv->size - from;\n\n\t \n\tcount = len;\n\twhile (count) {\n\t\tunsigned int offset, avail;\n\t\tunsigned int entry;\n\n\t\toffset = (unsigned int) (from & (priv->cache.page_size - 1));\n\t\tavail  = priv->cache.page_size - offset;\n\n\t\tentry = ps3vram_cache_match(dev, from);\n\t\tcached = CACHE_OFFSET + entry * priv->cache.page_size + offset;\n\n\t\tdev_dbg(&dev->core, \"%s: from=%08x cached=%08x offset=%08x \"\n\t\t\t\"avail=%08x count=%08x\\n\", __func__,\n\t\t\t(unsigned int)from, cached, offset, avail, count);\n\n\t\tif (avail > count)\n\t\t\tavail = count;\n\t\tmemcpy(buf, priv->xdr_buf + cached, avail);\n\n\t\tbuf += avail;\n\t\tcount -= avail;\n\t\tfrom += avail;\n\t}\n\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic blk_status_t ps3vram_write(struct ps3_system_bus_device *dev, loff_t to,\n\t\t\t size_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tunsigned int cached, count;\n\n\tif (to >= priv->size)\n\t\treturn BLK_STS_IOERR;\n\n\tif (len > priv->size - to)\n\t\tlen = priv->size - to;\n\n\t \n\tcount = len;\n\twhile (count) {\n\t\tunsigned int offset, avail;\n\t\tunsigned int entry;\n\n\t\toffset = (unsigned int) (to & (priv->cache.page_size - 1));\n\t\tavail  = priv->cache.page_size - offset;\n\n\t\tentry = ps3vram_cache_match(dev, to);\n\t\tcached = CACHE_OFFSET + entry * priv->cache.page_size + offset;\n\n\t\tdev_dbg(&dev->core, \"%s: to=%08x cached=%08x offset=%08x \"\n\t\t\t\"avail=%08x count=%08x\\n\", __func__, (unsigned int)to,\n\t\t\tcached, offset, avail, count);\n\n\t\tif (avail > count)\n\t\t\tavail = count;\n\t\tmemcpy(priv->xdr_buf + cached, buf, avail);\n\n\t\tpriv->cache.tags[entry].flags |= CACHE_PAGE_DIRTY;\n\n\t\tbuf += avail;\n\t\tcount -= avail;\n\t\tto += avail;\n\t}\n\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int ps3vram_proc_show(struct seq_file *m, void *v)\n{\n\tstruct ps3vram_priv *priv = m->private;\n\n\tseq_printf(m, \"hit:%u\\nmiss:%u\\n\", priv->cache.hit, priv->cache.miss);\n\treturn 0;\n}\n\nstatic void ps3vram_proc_init(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_create_single_data(DEVICE_NAME, 0444, NULL,\n\t\t\tps3vram_proc_show, priv);\n\tif (!pde)\n\t\tdev_warn(&dev->core, \"failed to create /proc entry\\n\");\n}\n\nstatic struct bio *ps3vram_do_bio(struct ps3_system_bus_device *dev,\n\t\t\t\t  struct bio *bio)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tint write = bio_data_dir(bio) == WRITE;\n\tconst char *op = write ? \"write\" : \"read\";\n\tloff_t offset = bio->bi_iter.bi_sector << 9;\n\tblk_status_t error = 0;\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tstruct bio *next;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\t \n\t\tchar *ptr = bvec_virt(&bvec);\n\t\tsize_t len = bvec.bv_len, retlen;\n\n\t\tdev_dbg(&dev->core, \"    %s %zu bytes at offset %llu\\n\", op,\n\t\t\tlen, offset);\n\t\tif (write)\n\t\t\terror = ps3vram_write(dev, offset, len, &retlen, ptr);\n\t\telse\n\t\t\terror = ps3vram_read(dev, offset, len, &retlen, ptr);\n\n\t\tif (error) {\n\t\t\tdev_err(&dev->core, \"%s failed\\n\", op);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tdev_err(&dev->core, \"Short %s\\n\", op);\n\t\t\terror = BLK_STS_IOERR;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\tdev_dbg(&dev->core, \"%s completed\\n\", op);\n\nout:\n\tspin_lock_irq(&priv->lock);\n\tbio_list_pop(&priv->list);\n\tnext = bio_list_peek(&priv->list);\n\tspin_unlock_irq(&priv->lock);\n\n\tbio->bi_status = error;\n\tbio_endio(bio);\n\treturn next;\n}\n\nstatic void ps3vram_submit_bio(struct bio *bio)\n{\n\tstruct ps3_system_bus_device *dev = bio->bi_bdev->bd_disk->private_data;\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\tint busy;\n\n\tdev_dbg(&dev->core, \"%s\\n\", __func__);\n\n\tspin_lock_irq(&priv->lock);\n\tbusy = !bio_list_empty(&priv->list);\n\tbio_list_add(&priv->list, bio);\n\tspin_unlock_irq(&priv->lock);\n\n\tif (busy)\n\t\treturn;\n\n\tdo {\n\t\tbio = ps3vram_do_bio(dev, bio);\n\t} while (bio);\n}\n\nstatic const struct block_device_operations ps3vram_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.submit_bio\t= ps3vram_submit_bio,\n};\n\nstatic int ps3vram_probe(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv;\n\tint error, status;\n\tstruct gendisk *gendisk;\n\tu64 ddr_size, ddr_lpar, ctrl_lpar, info_lpar, reports_lpar,\n\t    reports_size, xdr_lpar;\n\tchar *rest;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tspin_lock_init(&priv->lock);\n\tbio_list_init(&priv->list);\n\tps3_system_bus_set_drvdata(dev, priv);\n\n\t \n\tpriv->xdr_buf = (void *)__get_free_pages(GFP_KERNEL,\n\t\tget_order(XDR_BUF_SIZE));\n\tif (priv->xdr_buf == NULL) {\n\t\tdev_err(&dev->core, \"Could not allocate XDR buffer\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto fail_free_priv;\n\t}\n\n\t \n\tpriv->fifo_base = (u32 *) (priv->xdr_buf + FIFO_OFFSET);\n\tpriv->fifo_ptr = priv->fifo_base;\n\n\t \n\tif (ps3_open_hv_device(dev)) {\n\t\tdev_err(&dev->core, \"ps3_open_hv_device failed\\n\");\n\t\terror = -EAGAIN;\n\t\tgoto out_free_xdr_buf;\n\t}\n\n\t \n\tstatus = -1;\n\tddr_size = ALIGN(memparse(size, &rest), 1024*1024);\n\tif (!ddr_size) {\n\t\tdev_err(&dev->core, \"Specified size is too small\\n\");\n\t\terror = -EINVAL;\n\t\tgoto out_close_gpu;\n\t}\n\n\twhile (ddr_size > 0) {\n\t\tstatus = lv1_gpu_memory_allocate(ddr_size, 0, 0, 0, 0,\n\t\t\t\t\t\t &priv->memory_handle,\n\t\t\t\t\t\t &ddr_lpar);\n\t\tif (!status)\n\t\t\tbreak;\n\t\tddr_size -= 1024*1024;\n\t}\n\tif (status) {\n\t\tdev_err(&dev->core, \"lv1_gpu_memory_allocate failed %d\\n\",\n\t\t\tstatus);\n\t\terror = -ENOMEM;\n\t\tgoto out_close_gpu;\n\t}\n\n\t \n\tstatus = lv1_gpu_context_allocate(priv->memory_handle, 0,\n\t\t\t\t\t  &priv->context_handle, &ctrl_lpar,\n\t\t\t\t\t  &info_lpar, &reports_lpar,\n\t\t\t\t\t  &reports_size);\n\tif (status) {\n\t\tdev_err(&dev->core, \"lv1_gpu_context_allocate failed %d\\n\",\n\t\t\tstatus);\n\t\terror = -ENOMEM;\n\t\tgoto out_free_memory;\n\t}\n\n\t \n\txdr_lpar = ps3_mm_phys_to_lpar(__pa(priv->xdr_buf));\n\tstatus = lv1_gpu_context_iomap(priv->context_handle, XDR_IOIF,\n\t\t\t\t       xdr_lpar, XDR_BUF_SIZE,\n\t\t\t\t       CBE_IOPTE_PP_W | CBE_IOPTE_PP_R |\n\t\t\t\t       CBE_IOPTE_M);\n\tif (status) {\n\t\tdev_err(&dev->core, \"lv1_gpu_context_iomap failed %d\\n\",\n\t\t\tstatus);\n\t\terror = -ENOMEM;\n\t\tgoto out_free_context;\n\t}\n\n\tpriv->ctrl = ioremap(ctrl_lpar, 64 * 1024);\n\tif (!priv->ctrl) {\n\t\tdev_err(&dev->core, \"ioremap CTRL failed\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_unmap_context;\n\t}\n\n\tpriv->reports = ioremap(reports_lpar, reports_size);\n\tif (!priv->reports) {\n\t\tdev_err(&dev->core, \"ioremap REPORTS failed\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_unmap_ctrl;\n\t}\n\n\tmutex_lock(&ps3_gpu_mutex);\n\tps3vram_init_ring(dev);\n\tmutex_unlock(&ps3_gpu_mutex);\n\n\tpriv->size = ddr_size;\n\n\tps3vram_bind(dev);\n\n\tmutex_lock(&ps3_gpu_mutex);\n\terror = ps3vram_wait_ring(dev, 100);\n\tmutex_unlock(&ps3_gpu_mutex);\n\tif (error < 0) {\n\t\tdev_err(&dev->core, \"Failed to initialize channels\\n\");\n\t\terror = -ETIMEDOUT;\n\t\tgoto out_unmap_reports;\n\t}\n\n\terror = ps3vram_cache_init(dev);\n\tif (error < 0) {\n\t\tgoto out_unmap_reports;\n\t}\n\n\tps3vram_proc_init(dev);\n\n\tgendisk = blk_alloc_disk(NUMA_NO_NODE);\n\tif (!gendisk) {\n\t\tdev_err(&dev->core, \"blk_alloc_disk failed\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_cache_cleanup;\n\t}\n\n\tpriv->gendisk = gendisk;\n\tgendisk->major = ps3vram_major;\n\tgendisk->minors = 1;\n\tgendisk->flags |= GENHD_FL_NO_PART;\n\tgendisk->fops = &ps3vram_fops;\n\tgendisk->private_data = dev;\n\tstrscpy(gendisk->disk_name, DEVICE_NAME, sizeof(gendisk->disk_name));\n\tset_capacity(gendisk, priv->size >> 9);\n\n\tdev_info(&dev->core, \"%s: Using %llu MiB of GPU memory\\n\",\n\t\t gendisk->disk_name, get_capacity(gendisk) >> 11);\n\n\terror = device_add_disk(&dev->core, gendisk, NULL);\n\tif (error)\n\t\tgoto out_cleanup_disk;\n\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(gendisk);\nout_cache_cleanup:\n\tremove_proc_entry(DEVICE_NAME, NULL);\n\tps3vram_cache_cleanup(dev);\nout_unmap_reports:\n\tiounmap(priv->reports);\nout_unmap_ctrl:\n\tiounmap(priv->ctrl);\nout_unmap_context:\n\tlv1_gpu_context_iomap(priv->context_handle, XDR_IOIF, xdr_lpar,\n\t\t\t      XDR_BUF_SIZE, CBE_IOPTE_M);\nout_free_context:\n\tlv1_gpu_context_free(priv->context_handle);\nout_free_memory:\n\tlv1_gpu_memory_free(priv->memory_handle);\nout_close_gpu:\n\tps3_close_hv_device(dev);\nout_free_xdr_buf:\n\tfree_pages((unsigned long) priv->xdr_buf, get_order(XDR_BUF_SIZE));\nfail_free_priv:\n\tkfree(priv);\n\tps3_system_bus_set_drvdata(dev, NULL);\nfail:\n\treturn error;\n}\n\nstatic void ps3vram_remove(struct ps3_system_bus_device *dev)\n{\n\tstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\n\n\tdel_gendisk(priv->gendisk);\n\tput_disk(priv->gendisk);\n\tremove_proc_entry(DEVICE_NAME, NULL);\n\tps3vram_cache_cleanup(dev);\n\tiounmap(priv->reports);\n\tiounmap(priv->ctrl);\n\tlv1_gpu_context_iomap(priv->context_handle, XDR_IOIF,\n\t\t\t      ps3_mm_phys_to_lpar(__pa(priv->xdr_buf)),\n\t\t\t      XDR_BUF_SIZE, CBE_IOPTE_M);\n\tlv1_gpu_context_free(priv->context_handle);\n\tlv1_gpu_memory_free(priv->memory_handle);\n\tps3_close_hv_device(dev);\n\tfree_pages((unsigned long) priv->xdr_buf, get_order(XDR_BUF_SIZE));\n\tkfree(priv);\n\tps3_system_bus_set_drvdata(dev, NULL);\n}\n\nstatic struct ps3_system_bus_driver ps3vram = {\n\t.match_id\t= PS3_MATCH_ID_GPU,\n\t.match_sub_id\t= PS3_MATCH_SUB_ID_GPU_RAMDISK,\n\t.core.name\t= DEVICE_NAME,\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3vram_probe,\n\t.remove\t\t= ps3vram_remove,\n\t.shutdown\t= ps3vram_remove,\n};\n\n\nstatic int __init ps3vram_init(void)\n{\n\tint error;\n\n\tif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\n\t\treturn -ENODEV;\n\n\terror = register_blkdev(0, DEVICE_NAME);\n\tif (error <= 0) {\n\t\tpr_err(\"%s: register_blkdev failed %d\\n\", DEVICE_NAME, error);\n\t\treturn error;\n\t}\n\tps3vram_major = error;\n\n\tpr_info(\"%s: registered block device major %d\\n\", DEVICE_NAME,\n\t\tps3vram_major);\n\n\terror = ps3_system_bus_driver_register(&ps3vram);\n\tif (error)\n\t\tunregister_blkdev(ps3vram_major, DEVICE_NAME);\n\n\treturn error;\n}\n\nstatic void __exit ps3vram_exit(void)\n{\n\tps3_system_bus_driver_unregister(&ps3vram);\n\tunregister_blkdev(ps3vram_major, DEVICE_NAME);\n}\n\nmodule_init(ps3vram_init);\nmodule_exit(ps3vram_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PS3 Video RAM Storage Driver\");\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_GPU_RAMDISK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}