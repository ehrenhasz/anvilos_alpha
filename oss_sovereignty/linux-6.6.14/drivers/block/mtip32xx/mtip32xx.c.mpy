{
  "module_name": "mtip32xx.c",
  "hash_id": "080b18cb8beea2756bf002618b64a0f055efe97850952a8764d1efcbfbb4efaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/mtip32xx/mtip32xx.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/ata.h>\n#include <linux/delay.h>\n#include <linux/hdreg.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/smp.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/bio.h>\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/kthread.h>\n#include <../drivers/ata/ahci.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/prefetch.h>\n#include <linux/numa.h>\n#include \"mtip32xx.h\"\n\n#define HW_CMD_SLOT_SZ\t\t(MTIP_MAX_COMMAND_SLOTS * 32)\n\n \n#define AHCI_RX_FIS_SZ          0x100\n#define AHCI_RX_FIS_OFFSET      0x0\n#define AHCI_IDFY_SZ            ATA_SECT_SIZE\n#define AHCI_IDFY_OFFSET        0x400\n#define AHCI_SECTBUF_SZ         ATA_SECT_SIZE\n#define AHCI_SECTBUF_OFFSET     0x800\n#define AHCI_SMARTBUF_SZ        ATA_SECT_SIZE\n#define AHCI_SMARTBUF_OFFSET    0xC00\n \n#define BLOCK_DMA_ALLOC_SZ      4096\n\n \n#define AHCI_CMD_SLOT_SZ        sizeof(struct mtip_cmd_hdr)\n#define AHCI_CMD_TBL_SZ         (MTIP_MAX_COMMAND_SLOTS * AHCI_CMD_SLOT_SZ)\n#define AHCI_CMD_TBL_OFFSET     0x0\n\n \n#define AHCI_CMD_TBL_HDR_SZ     0x80\n#define AHCI_CMD_TBL_HDR_OFFSET 0x0\n#define AHCI_CMD_TBL_SGL_SZ     (MTIP_MAX_SG * sizeof(struct mtip_cmd_sg))\n#define AHCI_CMD_TBL_SGL_OFFSET AHCI_CMD_TBL_HDR_SZ\n#define CMD_DMA_ALLOC_SZ        (AHCI_CMD_TBL_SGL_SZ + AHCI_CMD_TBL_HDR_SZ)\n\n\n#define HOST_CAP_NZDMA\t\t(1 << 19)\n#define HOST_HSORG\t\t0xFC\n#define HSORG_DISABLE_SLOTGRP_INTR (1<<24)\n#define HSORG_DISABLE_SLOTGRP_PXIS (1<<16)\n#define HSORG_HWREV\t\t0xFF00\n#define HSORG_STYLE\t\t0x8\n#define HSORG_SLOTGROUPS\t0x7\n\n#define PORT_COMMAND_ISSUE\t0x38\n#define PORT_SDBV\t\t0x7C\n\n#define PORT_OFFSET\t\t0x100\n#define PORT_MEM_SIZE\t\t0x80\n\n#define PORT_IRQ_ERR \\\n\t(PORT_IRQ_HBUS_ERR | PORT_IRQ_IF_ERR | PORT_IRQ_CONNECT | \\\n\t PORT_IRQ_PHYRDY | PORT_IRQ_UNK_FIS | PORT_IRQ_BAD_PMP | \\\n\t PORT_IRQ_TF_ERR | PORT_IRQ_HBUS_DATA_ERR | PORT_IRQ_IF_NONFATAL | \\\n\t PORT_IRQ_OVERFLOW)\n#define PORT_IRQ_LEGACY \\\n\t(PORT_IRQ_PIOS_FIS | PORT_IRQ_D2H_REG_FIS)\n#define PORT_IRQ_HANDLED \\\n\t(PORT_IRQ_SDB_FIS | PORT_IRQ_LEGACY | \\\n\t PORT_IRQ_TF_ERR | PORT_IRQ_IF_ERR | \\\n\t PORT_IRQ_CONNECT | PORT_IRQ_PHYRDY)\n#define DEF_PORT_IRQ \\\n\t(PORT_IRQ_ERR | PORT_IRQ_LEGACY | PORT_IRQ_SDB_FIS)\n\n \n#define MTIP_PRODUCT_UNKNOWN\t0x00\n#define MTIP_PRODUCT_ASICFPGA\t0x11\n\n \nstatic int instance;\n\n \nstatic int mtip_major;\nstatic struct dentry *dfs_parent;\n\nstatic u32 cpu_use[NR_CPUS];\n\nstatic DEFINE_IDA(rssd_index_ida);\n\nstatic int mtip_block_initialize(struct driver_data *dd);\n\n#ifdef CONFIG_COMPAT\nstruct mtip_compat_ide_task_request_s {\n\t__u8\t\tio_ports[8];\n\t__u8\t\thob_ports[8];\n\tide_reg_valid_t\tout_flags;\n\tide_reg_valid_t\tin_flags;\n\tint\t\tdata_phase;\n\tint\t\treq_cmd;\n\tcompat_ulong_t\tout_size;\n\tcompat_ulong_t\tin_size;\n};\n#endif\n\n \nstatic bool mtip_check_surprise_removal(struct driver_data *dd)\n{\n\tu16 vendor_id = 0;\n\n\tif (dd->sr)\n\t\treturn true;\n\n        \n\tpci_read_config_word(dd->pdev, 0x00, &vendor_id);\n\tif (vendor_id == 0xFFFF) {\n\t\tdd->sr = true;\n\t\tif (dd->disk)\n\t\t\tblk_mark_disk_dead(dd->disk);\n\t\treturn true;  \n\t}\n\n\treturn false;  \n}\n\nstatic struct mtip_cmd *mtip_cmd_from_tag(struct driver_data *dd,\n\t\t\t\t\t  unsigned int tag)\n{\n\treturn blk_mq_rq_to_pdu(blk_mq_tag_to_rq(dd->tags.tags[0], tag));\n}\n\n \nstatic int mtip_hba_reset(struct driver_data *dd)\n{\n\tunsigned long timeout;\n\n\t \n\twritel(HOST_RESET, dd->mmio + HOST_CTL);\n\n\t \n\treadl(dd->mmio + HOST_CTL);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(10000);\n\tdo {\n\t\tmdelay(10);\n\t\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag))\n\t\t\treturn -1;\n\n\t} while ((readl(dd->mmio + HOST_CTL) & HOST_RESET)\n\t\t && time_before(jiffies, timeout));\n\n\tif (readl(dd->mmio + HOST_CTL) & HOST_RESET)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic inline void mtip_issue_ncq_command(struct mtip_port *port, int tag)\n{\n\tint group = tag >> 5;\n\n\t \n\tspin_lock(&port->cmd_issue_lock[group]);\n\twritel((1 << MTIP_TAG_BIT(tag)),\n\t\t\tport->s_active[MTIP_TAG_INDEX(tag)]);\n\twritel((1 << MTIP_TAG_BIT(tag)),\n\t\t\tport->cmd_issue[MTIP_TAG_INDEX(tag)]);\n\tspin_unlock(&port->cmd_issue_lock[group]);\n}\n\n \nstatic int mtip_enable_fis(struct mtip_port *port, int enable)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(port->mmio + PORT_CMD);\n\tif (enable)\n\t\twritel(tmp | PORT_CMD_FIS_RX, port->mmio + PORT_CMD);\n\telse\n\t\twritel(tmp & ~PORT_CMD_FIS_RX, port->mmio + PORT_CMD);\n\n\t \n\treadl(port->mmio + PORT_CMD);\n\n\treturn (((tmp & PORT_CMD_FIS_RX) == PORT_CMD_FIS_RX));\n}\n\n \nstatic int mtip_enable_engine(struct mtip_port *port, int enable)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(port->mmio + PORT_CMD);\n\tif (enable)\n\t\twritel(tmp | PORT_CMD_START, port->mmio + PORT_CMD);\n\telse\n\t\twritel(tmp & ~PORT_CMD_START, port->mmio + PORT_CMD);\n\n\treadl(port->mmio + PORT_CMD);\n\treturn (((tmp & PORT_CMD_START) == PORT_CMD_START));\n}\n\n \nstatic inline void mtip_start_port(struct mtip_port *port)\n{\n\t \n\tmtip_enable_fis(port, 1);\n\n\t \n\tmtip_enable_engine(port, 1);\n}\n\n \nstatic inline void mtip_deinit_port(struct mtip_port *port)\n{\n\t \n\twritel(0, port->mmio + PORT_IRQ_MASK);\n\n\t \n\tmtip_enable_engine(port, 0);\n\n\t \n\tmtip_enable_fis(port, 0);\n}\n\n \nstatic void mtip_init_port(struct mtip_port *port)\n{\n\tint i;\n\tmtip_deinit_port(port);\n\n\t \n\tif (readl(port->dd->mmio + HOST_CAP) & HOST_CAP_64) {\n\t\twritel((port->command_list_dma >> 16) >> 16,\n\t\t\t port->mmio + PORT_LST_ADDR_HI);\n\t\twritel((port->rxfis_dma >> 16) >> 16,\n\t\t\t port->mmio + PORT_FIS_ADDR_HI);\n\t\tset_bit(MTIP_PF_HOST_CAP_64, &port->flags);\n\t}\n\n\twritel(port->command_list_dma & 0xFFFFFFFF,\n\t\t\tport->mmio + PORT_LST_ADDR);\n\twritel(port->rxfis_dma & 0xFFFFFFFF, port->mmio + PORT_FIS_ADDR);\n\n\t \n\twritel(readl(port->mmio + PORT_SCR_ERR), port->mmio + PORT_SCR_ERR);\n\n\t \n\tfor (i = 0; i < port->dd->slot_groups; i++)\n\t\twritel(0xFFFFFFFF, port->completed[i]);\n\n\t \n\twritel(readl(port->mmio + PORT_IRQ_STAT), port->mmio + PORT_IRQ_STAT);\n\n\t \n\twritel(readl(port->dd->mmio + HOST_IRQ_STAT),\n\t\t\t\t\tport->dd->mmio + HOST_IRQ_STAT);\n\n\t \n\twritel(DEF_PORT_IRQ, port->mmio + PORT_IRQ_MASK);\n}\n\n \nstatic void mtip_restart_port(struct mtip_port *port)\n{\n\tunsigned long timeout;\n\n\t \n\tmtip_enable_engine(port, 0);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile ((readl(port->mmio + PORT_CMD) & PORT_CMD_LIST_ON)\n\t\t && time_before(jiffies, timeout))\n\t\t;\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &port->dd->dd_flag))\n\t\treturn;\n\n\t \n\tif (readl(port->mmio + PORT_CMD) & PORT_CMD_LIST_ON) {\n\t\tdev_warn(&port->dd->pdev->dev,\n\t\t\t\"PxCMD.CR not clear, escalating reset\\n\");\n\n\t\tif (mtip_hba_reset(port->dd))\n\t\t\tdev_err(&port->dd->pdev->dev,\n\t\t\t\t\"HBA reset escalation failed.\\n\");\n\n\t\t \n\t\tmdelay(30);\n\t}\n\n\tdev_warn(&port->dd->pdev->dev, \"Issuing COM reset\\n\");\n\n\t \n\twritel(readl(port->mmio + PORT_SCR_CTL) |\n\t\t\t 1, port->mmio + PORT_SCR_CTL);\n\treadl(port->mmio + PORT_SCR_CTL);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(1);\n\twhile (time_before(jiffies, timeout))\n\t\t;\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &port->dd->dd_flag))\n\t\treturn;\n\n\t \n\twritel(readl(port->mmio + PORT_SCR_CTL) & ~1,\n\t\t\t port->mmio + PORT_SCR_CTL);\n\treadl(port->mmio + PORT_SCR_CTL);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (((readl(port->mmio + PORT_SCR_STAT) & 0x01) == 0)\n\t\t\t && time_before(jiffies, timeout))\n\t\t;\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &port->dd->dd_flag))\n\t\treturn;\n\n\tif ((readl(port->mmio + PORT_SCR_STAT) & 0x01) == 0)\n\t\tdev_warn(&port->dd->pdev->dev,\n\t\t\t\"COM reset failed\\n\");\n\n\tmtip_init_port(port);\n\tmtip_start_port(port);\n\n}\n\nstatic int mtip_device_reset(struct driver_data *dd)\n{\n\tint rv = 0;\n\n\tif (mtip_check_surprise_removal(dd))\n\t\treturn 0;\n\n\tif (mtip_hba_reset(dd) < 0)\n\t\trv = -EFAULT;\n\n\tmdelay(1);\n\tmtip_init_port(dd->port);\n\tmtip_start_port(dd->port);\n\n\t \n\twritel(readl(dd->mmio + HOST_CTL) | HOST_IRQ_EN,\n\t\t\t\t\tdd->mmio + HOST_CTL);\n\treturn rv;\n}\n\n \nstatic void print_tags(struct driver_data *dd,\n\t\t\tchar *msg,\n\t\t\tunsigned long *tagbits,\n\t\t\tint cnt)\n{\n\tunsigned char tagmap[128];\n\tint group, tagmap_len = 0;\n\n\tmemset(tagmap, 0, sizeof(tagmap));\n\tfor (group = SLOTBITS_IN_LONGS; group > 0; group--)\n\t\ttagmap_len += sprintf(tagmap + tagmap_len, \"%016lX \",\n\t\t\t\t\t\ttagbits[group-1]);\n\tdev_warn(&dd->pdev->dev,\n\t\t\t\"%d command(s) %s: tagmap [%s]\", cnt, msg, tagmap);\n}\n\nstatic int mtip_read_log_page(struct mtip_port *port, u8 page, u16 *buffer,\n\t\t\t\tdma_addr_t buffer_dma, unsigned int sectors);\nstatic int mtip_get_smart_attr(struct mtip_port *port, unsigned int id,\n\t\t\t\t\t\tstruct smart_attr *attrib);\n\nstatic void mtip_complete_command(struct mtip_cmd *cmd, blk_status_t status)\n{\n\tstruct request *req = blk_mq_rq_from_pdu(cmd);\n\n\tcmd->status = status;\n\tif (likely(!blk_should_fake_timeout(req->q)))\n\t\tblk_mq_complete_request(req);\n}\n\n \nstatic void mtip_handle_tfe(struct driver_data *dd)\n{\n\tint group, tag, bit, reissue, rv;\n\tstruct mtip_port *port;\n\tstruct mtip_cmd  *cmd;\n\tu32 completed;\n\tstruct host_to_dev_fis *fis;\n\tunsigned long tagaccum[SLOTBITS_IN_LONGS];\n\tunsigned int cmd_cnt = 0;\n\tunsigned char *buf;\n\tchar *fail_reason = NULL;\n\tint fail_all_ncq_write = 0, fail_all_ncq_cmds = 0;\n\n\tdev_warn(&dd->pdev->dev, \"Taskfile error\\n\");\n\n\tport = dd->port;\n\n\tif (test_bit(MTIP_PF_IC_ACTIVE_BIT, &port->flags)) {\n\t\tcmd = mtip_cmd_from_tag(dd, MTIP_TAG_INTERNAL);\n\t\tdbg_printk(MTIP_DRV_NAME \" TFE for the internal command\\n\");\n\t\tmtip_complete_command(cmd, BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\t \n\tmemset(tagaccum, 0, SLOTBITS_IN_LONGS * sizeof(long));\n\n\t \n\tfor (group = 0; group < dd->slot_groups; group++) {\n\t\tcompleted = readl(port->completed[group]);\n\n\t\tdev_warn(&dd->pdev->dev, \"g=%u, comp=%x\\n\", group, completed);\n\n\t\t \n\t\twritel(completed, port->completed[group]);\n\n\t\t \n\t\tfor (bit = 0; bit < 32 && completed; bit++) {\n\t\t\tif (!(completed & (1<<bit)))\n\t\t\t\tcontinue;\n\t\t\ttag = (group << 5) + bit;\n\n\t\t\t \n\t\t\tif (tag == MTIP_TAG_INTERNAL)\n\t\t\t\tcontinue;\n\n\t\t\tcmd = mtip_cmd_from_tag(dd, tag);\n\t\t\tmtip_complete_command(cmd, 0);\n\t\t\tset_bit(tag, tagaccum);\n\t\t\tcmd_cnt++;\n\t\t}\n\t}\n\n\tprint_tags(dd, \"completed (TFE)\", tagaccum, cmd_cnt);\n\n\t \n\tmdelay(20);\n\tmtip_restart_port(port);\n\n\t \n\trv = mtip_read_log_page(dd->port, ATA_LOG_SATA_NCQ,\n\t\t\t\tdd->port->log_buf,\n\t\t\t\tdd->port->log_buf_dma, 1);\n\tif (rv) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Error in READ LOG EXT (10h) command\\n\");\n\t\t \n\t} else {\n\t\tbuf = (unsigned char *)dd->port->log_buf;\n\t\tif (buf[259] & 0x1) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Write protect bit is set.\\n\");\n\t\t\tset_bit(MTIP_DDF_WRITE_PROTECT_BIT, &dd->dd_flag);\n\t\t\tfail_all_ncq_write = 1;\n\t\t\tfail_reason = \"write protect\";\n\t\t}\n\t\tif (buf[288] == 0xF7) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Exceeded Tmax, drive in thermal shutdown.\\n\");\n\t\t\tset_bit(MTIP_DDF_OVER_TEMP_BIT, &dd->dd_flag);\n\t\t\tfail_all_ncq_cmds = 1;\n\t\t\tfail_reason = \"thermal shutdown\";\n\t\t}\n\t\tif (buf[288] == 0xBF) {\n\t\t\tset_bit(MTIP_DDF_REBUILD_FAILED_BIT, &dd->dd_flag);\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Drive indicates rebuild has failed. Secure erase required.\\n\");\n\t\t\tfail_all_ncq_cmds = 1;\n\t\t\tfail_reason = \"rebuild failed\";\n\t\t}\n\t}\n\n\t \n\tmemset(tagaccum, 0, SLOTBITS_IN_LONGS * sizeof(long));\n\n\t \n\tfor (group = 0; group < dd->slot_groups; group++) {\n\t\tfor (bit = 0; bit < 32; bit++) {\n\t\t\treissue = 1;\n\t\t\ttag = (group << 5) + bit;\n\t\t\tcmd = mtip_cmd_from_tag(dd, tag);\n\n\t\t\tfis = (struct host_to_dev_fis *)cmd->command;\n\n\t\t\t \n\t\t\tif (tag == MTIP_TAG_INTERNAL ||\n\t\t\t    fis->command == ATA_CMD_SET_FEATURES)\n\t\t\t\treissue = 0;\n\t\t\telse {\n\t\t\t\tif (fail_all_ncq_cmds ||\n\t\t\t\t\t(fail_all_ncq_write &&\n\t\t\t\t\tfis->command == ATA_CMD_FPDMA_WRITE)) {\n\t\t\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\t\"  Fail: %s w/tag %d [%s].\\n\",\n\t\t\t\t\tfis->command == ATA_CMD_FPDMA_WRITE ?\n\t\t\t\t\t\t\"write\" : \"read\",\n\t\t\t\t\ttag,\n\t\t\t\t\tfail_reason != NULL ?\n\t\t\t\t\t\tfail_reason : \"unknown\");\n\t\t\t\t\tmtip_complete_command(cmd, BLK_STS_MEDIUM);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reissue && (cmd->retries-- > 0)) {\n\n\t\t\t\tset_bit(tag, tagaccum);\n\n\t\t\t\t \n\t\t\t\tmtip_issue_ncq_command(port, tag);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tdev_warn(&port->dd->pdev->dev,\n\t\t\t\t\"retiring tag %d\\n\", tag);\n\n\t\t\tmtip_complete_command(cmd, BLK_STS_IOERR);\n\t\t}\n\t}\n\tprint_tags(dd, \"reissued (TFE)\", tagaccum, cmd_cnt);\n}\n\n \nstatic inline void mtip_workq_sdbfx(struct mtip_port *port, int group,\n\t\t\t\t\t\t\tu32 completed)\n{\n\tstruct driver_data *dd = port->dd;\n\tint tag, bit;\n\tstruct mtip_cmd *command;\n\n\tif (!completed) {\n\t\tWARN_ON_ONCE(!completed);\n\t\treturn;\n\t}\n\t \n\twritel(completed, port->completed[group]);\n\n\t \n\tfor (bit = 0; (bit < 32) && completed; bit++) {\n\t\tif (completed & 0x01) {\n\t\t\ttag = (group << 5) | bit;\n\n\t\t\t \n\t\t\tif (unlikely(tag == MTIP_TAG_INTERNAL))\n\t\t\t\tcontinue;\n\n\t\t\tcommand = mtip_cmd_from_tag(dd, tag);\n\t\t\tmtip_complete_command(command, 0);\n\t\t}\n\t\tcompleted >>= 1;\n\t}\n\n\t \n\tif (atomic_dec_return(&dd->irq_workers_active) == 0)\n\t\twritel(0xffffffff, dd->mmio + HOST_IRQ_STAT);\n}\n\n \nstatic inline void mtip_process_legacy(struct driver_data *dd, u32 port_stat)\n{\n\tstruct mtip_port *port = dd->port;\n\tstruct mtip_cmd *cmd = mtip_cmd_from_tag(dd, MTIP_TAG_INTERNAL);\n\n\tif (test_bit(MTIP_PF_IC_ACTIVE_BIT, &port->flags) && cmd) {\n\t\tint group = MTIP_TAG_INDEX(MTIP_TAG_INTERNAL);\n\t\tint status = readl(port->cmd_issue[group]);\n\n\t\tif (!(status & (1 << MTIP_TAG_BIT(MTIP_TAG_INTERNAL))))\n\t\t\tmtip_complete_command(cmd, 0);\n\t}\n}\n\n \nstatic inline void mtip_process_errors(struct driver_data *dd, u32 port_stat)\n{\n\tif (unlikely(port_stat & PORT_IRQ_CONNECT)) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Clearing PxSERR.DIAG.x\\n\");\n\t\twritel((1 << 26), dd->port->mmio + PORT_SCR_ERR);\n\t}\n\n\tif (unlikely(port_stat & PORT_IRQ_PHYRDY)) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Clearing PxSERR.DIAG.n\\n\");\n\t\twritel((1 << 16), dd->port->mmio + PORT_SCR_ERR);\n\t}\n\n\tif (unlikely(port_stat & ~PORT_IRQ_HANDLED)) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Port stat errors %x unhandled\\n\",\n\t\t\t(port_stat & ~PORT_IRQ_HANDLED));\n\t\tif (mtip_check_surprise_removal(dd))\n\t\t\treturn;\n\t}\n\tif (likely(port_stat & (PORT_IRQ_TF_ERR | PORT_IRQ_IF_ERR))) {\n\t\tset_bit(MTIP_PF_EH_ACTIVE_BIT, &dd->port->flags);\n\t\twake_up_interruptible(&dd->port->svc_wait);\n\t}\n}\n\nstatic inline irqreturn_t mtip_handle_irq(struct driver_data *data)\n{\n\tstruct driver_data *dd = (struct driver_data *) data;\n\tstruct mtip_port *port = dd->port;\n\tu32 hba_stat, port_stat;\n\tint rv = IRQ_NONE;\n\tint do_irq_enable = 1, i, workers;\n\tstruct mtip_work *twork;\n\n\thba_stat = readl(dd->mmio + HOST_IRQ_STAT);\n\tif (hba_stat) {\n\t\trv = IRQ_HANDLED;\n\n\t\t \n\t\tport_stat = readl(port->mmio + PORT_IRQ_STAT);\n\t\tif (unlikely(port_stat == 0xFFFFFFFF)) {\n\t\t\tmtip_check_surprise_removal(dd);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\twritel(port_stat, port->mmio + PORT_IRQ_STAT);\n\n\t\t \n\t\tif (likely(port_stat & PORT_IRQ_SDB_FIS)) {\n\t\t\tdo_irq_enable = 0;\n\t\t\tWARN_ON_ONCE(atomic_read(&dd->irq_workers_active) != 0);\n\n\t\t\t \n\t\t\tfor (i = 0, workers = 0; i < MTIP_MAX_SLOT_GROUPS;\n\t\t\t\t\t\t\t\t\ti++) {\n\t\t\t\ttwork = &dd->work[i];\n\t\t\t\ttwork->completed = readl(port->completed[i]);\n\t\t\t\tif (twork->completed)\n\t\t\t\t\tworkers++;\n\t\t\t}\n\n\t\t\tatomic_set(&dd->irq_workers_active, workers);\n\t\t\tif (workers) {\n\t\t\t\tfor (i = 1; i < MTIP_MAX_SLOT_GROUPS; i++) {\n\t\t\t\t\ttwork = &dd->work[i];\n\t\t\t\t\tif (twork->completed)\n\t\t\t\t\t\tqueue_work_on(\n\t\t\t\t\t\t\ttwork->cpu_binding,\n\t\t\t\t\t\t\tdd->isr_workq,\n\t\t\t\t\t\t\t&twork->work);\n\t\t\t\t}\n\n\t\t\t\tif (likely(dd->work[0].completed))\n\t\t\t\t\tmtip_workq_sdbfx(port, 0,\n\t\t\t\t\t\t\tdd->work[0].completed);\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdo_irq_enable = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(port_stat & PORT_IRQ_ERR)) {\n\t\t\tif (unlikely(mtip_check_surprise_removal(dd))) {\n\t\t\t\t \n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT,\n\t\t\t\t\t\t\t&dd->dd_flag))\n\t\t\t\treturn rv;\n\n\t\t\tmtip_process_errors(dd, port_stat & PORT_IRQ_ERR);\n\t\t}\n\n\t\tif (unlikely(port_stat & PORT_IRQ_LEGACY))\n\t\t\tmtip_process_legacy(dd, port_stat & PORT_IRQ_LEGACY);\n\t}\n\n\t \n\tif (unlikely(do_irq_enable))\n\t\twritel(hba_stat, dd->mmio + HOST_IRQ_STAT);\n\n\treturn rv;\n}\n\n \nstatic irqreturn_t mtip_irq_handler(int irq, void *instance)\n{\n\tstruct driver_data *dd = instance;\n\n\treturn mtip_handle_irq(dd);\n}\n\nstatic void mtip_issue_non_ncq_command(struct mtip_port *port, int tag)\n{\n\twritel(1 << MTIP_TAG_BIT(tag), port->cmd_issue[MTIP_TAG_INDEX(tag)]);\n}\n\nstatic bool mtip_pause_ncq(struct mtip_port *port,\n\t\t\t\tstruct host_to_dev_fis *fis)\n{\n\tunsigned long task_file_data;\n\n\ttask_file_data = readl(port->mmio+PORT_TFDATA);\n\tif ((task_file_data & 1))\n\t\treturn false;\n\n\tif (fis->command == ATA_CMD_SEC_ERASE_PREP) {\n\t\tport->ic_pause_timer = jiffies;\n\t\treturn true;\n\t} else if ((fis->command == ATA_CMD_DOWNLOAD_MICRO) &&\n\t\t\t\t\t(fis->features == 0x03)) {\n\t\tset_bit(MTIP_PF_DM_ACTIVE_BIT, &port->flags);\n\t\tport->ic_pause_timer = jiffies;\n\t\treturn true;\n\t} else if ((fis->command == ATA_CMD_SEC_ERASE_UNIT) ||\n\t\t((fis->command == 0xFC) &&\n\t\t\t(fis->features == 0x27 || fis->features == 0x72 ||\n\t\t\t fis->features == 0x62 || fis->features == 0x26))) {\n\t\tclear_bit(MTIP_DDF_SEC_LOCK_BIT, &port->dd->dd_flag);\n\t\tclear_bit(MTIP_DDF_REBUILD_FAILED_BIT, &port->dd->dd_flag);\n\t\t \n\t\tmtip_restart_port(port);\n\t\tclear_bit(MTIP_PF_SE_ACTIVE_BIT, &port->flags);\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic bool mtip_commands_active(struct mtip_port *port)\n{\n\tunsigned int active;\n\tunsigned int n;\n\n\t \n\tactive = readl(port->s_active[0]) & 0xFFFFFFFE;\n\tfor (n = 1; n < port->dd->slot_groups; n++)\n\t\tactive |= readl(port->s_active[n]);\n\n\treturn active != 0;\n}\n\n \nstatic int mtip_quiesce_io(struct mtip_port *port, unsigned long timeout)\n{\n\tunsigned long to;\n\tbool active = true;\n\n\tblk_mq_quiesce_queue(port->dd->queue);\n\n\tto = jiffies + msecs_to_jiffies(timeout);\n\tdo {\n\t\tif (test_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &port->flags) &&\n\t\t\ttest_bit(MTIP_PF_ISSUE_CMDS_BIT, &port->flags)) {\n\t\t\tmsleep(20);\n\t\t\tcontinue;  \n\t\t}\n\n\t\tmsleep(100);\n\n\t\tif (mtip_check_surprise_removal(port->dd))\n\t\t\tgoto err_fault;\n\n\t\tactive = mtip_commands_active(port);\n\t\tif (!active)\n\t\t\tbreak;\n\t} while (time_before(jiffies, to));\n\n\tblk_mq_unquiesce_queue(port->dd->queue);\n\treturn active ? -EBUSY : 0;\nerr_fault:\n\tblk_mq_unquiesce_queue(port->dd->queue);\n\treturn -EFAULT;\n}\n\nstruct mtip_int_cmd {\n\tint fis_len;\n\tdma_addr_t buffer;\n\tint buf_len;\n\tu32 opts;\n};\n\n \nstatic int mtip_exec_internal_command(struct mtip_port *port,\n\t\t\t\t\tstruct host_to_dev_fis *fis,\n\t\t\t\t\tint fis_len,\n\t\t\t\t\tdma_addr_t buffer,\n\t\t\t\t\tint buf_len,\n\t\t\t\t\tu32 opts,\n\t\t\t\t\tunsigned long timeout)\n{\n\tstruct mtip_cmd *int_cmd;\n\tstruct driver_data *dd = port->dd;\n\tstruct request *rq;\n\tstruct mtip_int_cmd icmd = {\n\t\t.fis_len = fis_len,\n\t\t.buffer = buffer,\n\t\t.buf_len = buf_len,\n\t\t.opts = opts\n\t};\n\tint rv = 0;\n\n\t \n\tif (buffer & 0x00000007) {\n\t\tdev_err(&dd->pdev->dev, \"SG buffer is not 8 byte aligned\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (mtip_check_surprise_removal(dd))\n\t\treturn -EFAULT;\n\n\trq = blk_mq_alloc_request(dd->queue, REQ_OP_DRV_IN, BLK_MQ_REQ_RESERVED);\n\tif (IS_ERR(rq)) {\n\t\tdbg_printk(MTIP_DRV_NAME \"Unable to allocate tag for PIO cmd\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tset_bit(MTIP_PF_IC_ACTIVE_BIT, &port->flags);\n\n\tif (fis->command == ATA_CMD_SEC_ERASE_PREP)\n\t\tset_bit(MTIP_PF_SE_ACTIVE_BIT, &port->flags);\n\n\tclear_bit(MTIP_PF_DM_ACTIVE_BIT, &port->flags);\n\n\tif (fis->command != ATA_CMD_STANDBYNOW1) {\n\t\t \n\t\tif (mtip_quiesce_io(port, MTIP_QUIESCE_IO_TIMEOUT_MS) < 0) {\n\t\t\tdev_warn(&dd->pdev->dev, \"Failed to quiesce IO\\n\");\n\t\t\tblk_mq_free_request(rq);\n\t\t\tclear_bit(MTIP_PF_IC_ACTIVE_BIT, &port->flags);\n\t\t\twake_up_interruptible(&port->svc_wait);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tint_cmd = blk_mq_rq_to_pdu(rq);\n\tint_cmd->icmd = &icmd;\n\tmemcpy(int_cmd->command, fis, fis_len*4);\n\n\trq->timeout = timeout;\n\n\t \n\tblk_execute_rq(rq, true);\n\n\tif (int_cmd->status) {\n\t\tdev_err(&dd->pdev->dev, \"Internal command [%02X] failed %d\\n\",\n\t\t\t\tfis->command, int_cmd->status);\n\t\trv = -EIO;\n\n\t\tif (mtip_check_surprise_removal(dd) ||\n\t\t\ttest_bit(MTIP_DDF_REMOVE_PENDING_BIT,\n\t\t\t\t\t&dd->dd_flag)) {\n\t\t\tdev_err(&dd->pdev->dev,\n\t\t\t\t\"Internal command [%02X] wait returned due to SR\\n\",\n\t\t\t\tfis->command);\n\t\t\trv = -ENXIO;\n\t\t\tgoto exec_ic_exit;\n\t\t}\n\t\tmtip_device_reset(dd);  \n\t\trv = -EAGAIN;\n\t\tgoto exec_ic_exit;\n\t}\n\n\tif (readl(port->cmd_issue[MTIP_TAG_INDEX(MTIP_TAG_INTERNAL)])\n\t\t\t& (1 << MTIP_TAG_BIT(MTIP_TAG_INTERNAL))) {\n\t\trv = -ENXIO;\n\t\tif (!test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag)) {\n\t\t\tmtip_device_reset(dd);\n\t\t\trv = -EAGAIN;\n\t\t}\n\t}\nexec_ic_exit:\n\t \n\tblk_mq_free_request(rq);\n\tclear_bit(MTIP_PF_IC_ACTIVE_BIT, &port->flags);\n\tif (rv >= 0 && mtip_pause_ncq(port, fis)) {\n\t\t \n\t\treturn rv;\n\t}\n\twake_up_interruptible(&port->svc_wait);\n\n\treturn rv;\n}\n\n \nstatic inline void ata_swap_string(u16 *buf, unsigned int len)\n{\n\tint i;\n\tfor (i = 0; i < (len/2); i++)\n\t\tbe16_to_cpus(&buf[i]);\n}\n\nstatic void mtip_set_timeout(struct driver_data *dd,\n\t\t\t\t\tstruct host_to_dev_fis *fis,\n\t\t\t\t\tunsigned int *timeout, u8 erasemode)\n{\n\tswitch (fis->command) {\n\tcase ATA_CMD_DOWNLOAD_MICRO:\n\t\t*timeout = 120000;  \n\t\tbreak;\n\tcase ATA_CMD_SEC_ERASE_UNIT:\n\tcase 0xFC:\n\t\tif (erasemode)\n\t\t\t*timeout = ((*(dd->port->identify + 90) * 2) * 60000);\n\t\telse\n\t\t\t*timeout = ((*(dd->port->identify + 89) * 2) * 60000);\n\t\tbreak;\n\tcase ATA_CMD_STANDBYNOW1:\n\t\t*timeout = 120000;   \n\t\tbreak;\n\tcase 0xF7:\n\tcase 0xFA:\n\t\t*timeout = 60000;   \n\t\tbreak;\n\tcase ATA_CMD_SMART:\n\t\t*timeout = 15000;   \n\t\tbreak;\n\tdefault:\n\t\t*timeout = MTIP_IOCTL_CMD_TIMEOUT_MS;\n\t\tbreak;\n\t}\n}\n\n \nstatic int mtip_get_identify(struct mtip_port *port, void __user *user_buffer)\n{\n\tint rv = 0;\n\tstruct host_to_dev_fis fis;\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &port->dd->dd_flag))\n\t\treturn -EFAULT;\n\n\t \n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= ATA_CMD_ID_ATA;\n\n\t \n\tport->identify_valid = 0;\n\n\t \n\tmemset(port->identify, 0, sizeof(u16) * ATA_ID_WORDS);\n\n\t \n\tif (mtip_exec_internal_command(port,\n\t\t\t\t&fis,\n\t\t\t\t5,\n\t\t\t\tport->identify_dma,\n\t\t\t\tsizeof(u16) * ATA_ID_WORDS,\n\t\t\t\t0,\n\t\t\t\tMTIP_INT_CMD_TIMEOUT_MS)\n\t\t\t\t< 0) {\n\t\trv = -1;\n\t\tgoto out;\n\t}\n\n\t \n#ifdef __LITTLE_ENDIAN\n\tata_swap_string(port->identify + 27, 40);   \n\tata_swap_string(port->identify + 23, 8);    \n\tata_swap_string(port->identify + 10, 20);   \n#else\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ATA_ID_WORDS; i++)\n\t\t\tport->identify[i] = le16_to_cpu(port->identify[i]);\n\t}\n#endif\n\n\t \n\tif (port->identify[128] & 0x4)\n\t\tset_bit(MTIP_DDF_SEC_LOCK_BIT, &port->dd->dd_flag);\n\telse\n\t\tclear_bit(MTIP_DDF_SEC_LOCK_BIT, &port->dd->dd_flag);\n\n\t \n\tport->identify_valid = 1;\n\n\tif (user_buffer) {\n\t\tif (copy_to_user(\n\t\t\tuser_buffer,\n\t\t\tport->identify,\n\t\t\tATA_ID_WORDS * sizeof(u16))) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn rv;\n}\n\n \nstatic int mtip_standby_immediate(struct mtip_port *port)\n{\n\tint rv;\n\tstruct host_to_dev_fis\tfis;\n\tunsigned long __maybe_unused start;\n\tunsigned int timeout;\n\n\t \n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= ATA_CMD_STANDBYNOW1;\n\n\tmtip_set_timeout(port->dd, &fis, &timeout, 0);\n\n\tstart = jiffies;\n\trv = mtip_exec_internal_command(port,\n\t\t\t\t\t&fis,\n\t\t\t\t\t5,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\ttimeout);\n\tdbg_printk(MTIP_DRV_NAME \"Time taken to complete standby cmd: %d ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies - start));\n\tif (rv)\n\t\tdev_warn(&port->dd->pdev->dev,\n\t\t\t\"STANDBY IMMEDIATE command failed.\\n\");\n\n\treturn rv;\n}\n\n \nstatic int mtip_read_log_page(struct mtip_port *port, u8 page, u16 *buffer,\n\t\t\t\tdma_addr_t buffer_dma, unsigned int sectors)\n{\n\tstruct host_to_dev_fis fis;\n\n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= ATA_CMD_READ_LOG_EXT;\n\tfis.sect_count\t= sectors & 0xFF;\n\tfis.sect_cnt_ex\t= (sectors >> 8) & 0xFF;\n\tfis.lba_low\t= page;\n\tfis.lba_mid\t= 0;\n\tfis.device\t= ATA_DEVICE_OBS;\n\n\tmemset(buffer, 0, sectors * ATA_SECT_SIZE);\n\n\treturn mtip_exec_internal_command(port,\n\t\t\t\t\t&fis,\n\t\t\t\t\t5,\n\t\t\t\t\tbuffer_dma,\n\t\t\t\t\tsectors * ATA_SECT_SIZE,\n\t\t\t\t\t0,\n\t\t\t\t\tMTIP_INT_CMD_TIMEOUT_MS);\n}\n\n \nstatic int mtip_get_smart_data(struct mtip_port *port, u8 *buffer,\n\t\t\t\t\tdma_addr_t buffer_dma)\n{\n\tstruct host_to_dev_fis fis;\n\n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= ATA_CMD_SMART;\n\tfis.features\t= 0xD0;\n\tfis.sect_count\t= 1;\n\tfis.lba_mid\t= 0x4F;\n\tfis.lba_hi\t= 0xC2;\n\tfis.device\t= ATA_DEVICE_OBS;\n\n\treturn mtip_exec_internal_command(port,\n\t\t\t\t\t&fis,\n\t\t\t\t\t5,\n\t\t\t\t\tbuffer_dma,\n\t\t\t\t\tATA_SECT_SIZE,\n\t\t\t\t\t0,\n\t\t\t\t\t15000);\n}\n\n \nstatic int mtip_get_smart_attr(struct mtip_port *port, unsigned int id,\n\t\t\t\t\t\tstruct smart_attr *attrib)\n{\n\tint rv, i;\n\tstruct smart_attr *pattr;\n\n\tif (!attrib)\n\t\treturn -EINVAL;\n\n\tif (!port->identify_valid) {\n\t\tdev_warn(&port->dd->pdev->dev, \"IDENTIFY DATA not valid\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (!(port->identify[82] & 0x1)) {\n\t\tdev_warn(&port->dd->pdev->dev, \"SMART not supported\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (!(port->identify[85] & 0x1)) {\n\t\tdev_warn(&port->dd->pdev->dev, \"SMART not enabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tmemset(port->smart_buf, 0, ATA_SECT_SIZE);\n\trv = mtip_get_smart_data(port, port->smart_buf, port->smart_buf_dma);\n\tif (rv) {\n\t\tdev_warn(&port->dd->pdev->dev, \"Failed to ge SMART data\\n\");\n\t\treturn rv;\n\t}\n\n\tpattr = (struct smart_attr *)(port->smart_buf + 2);\n\tfor (i = 0; i < 29; i++, pattr++)\n\t\tif (pattr->attr_id == id) {\n\t\t\tmemcpy(attrib, pattr, sizeof(struct smart_attr));\n\t\t\tbreak;\n\t\t}\n\n\tif (i == 29) {\n\t\tdev_warn(&port->dd->pdev->dev,\n\t\t\t\"Query for invalid SMART attribute ID\\n\");\n\t\trv = -EINVAL;\n\t}\n\n\treturn rv;\n}\n\n \nstatic bool mtip_hw_get_capacity(struct driver_data *dd, sector_t *sectors)\n{\n\tstruct mtip_port *port = dd->port;\n\tu64 total, raw0, raw1, raw2, raw3;\n\traw0 = port->identify[100];\n\traw1 = port->identify[101];\n\traw2 = port->identify[102];\n\traw3 = port->identify[103];\n\ttotal = raw0 | raw1<<16 | raw2<<32 | raw3<<48;\n\t*sectors = total;\n\treturn (bool) !!port->identify_valid;\n}\n\n \nstatic void mtip_dump_identify(struct mtip_port *port)\n{\n\tsector_t sectors;\n\tunsigned short revid;\n\tchar cbuf[42];\n\n\tif (!port->identify_valid)\n\t\treturn;\n\n\tstrscpy(cbuf, (char *)(port->identify + 10), 21);\n\tdev_info(&port->dd->pdev->dev,\n\t\t\"Serial No.: %s\\n\", cbuf);\n\n\tstrscpy(cbuf, (char *)(port->identify + 23), 9);\n\tdev_info(&port->dd->pdev->dev,\n\t\t\"Firmware Ver.: %s\\n\", cbuf);\n\n\tstrscpy(cbuf, (char *)(port->identify + 27), 41);\n\tdev_info(&port->dd->pdev->dev, \"Model: %s\\n\", cbuf);\n\n\tdev_info(&port->dd->pdev->dev, \"Security: %04x %s\\n\",\n\t\tport->identify[128],\n\t\tport->identify[128] & 0x4 ? \"(LOCKED)\" : \"\");\n\n\tif (mtip_hw_get_capacity(port->dd, &sectors))\n\t\tdev_info(&port->dd->pdev->dev,\n\t\t\t\"Capacity: %llu sectors (%llu MB)\\n\",\n\t\t\t (u64)sectors,\n\t\t\t ((u64)sectors) * ATA_SECT_SIZE >> 20);\n\n\tpci_read_config_word(port->dd->pdev, PCI_REVISION_ID, &revid);\n\tswitch (revid & 0xFF) {\n\tcase 0x1:\n\t\tstrscpy(cbuf, \"A0\", 3);\n\t\tbreak;\n\tcase 0x3:\n\t\tstrscpy(cbuf, \"A2\", 3);\n\t\tbreak;\n\tdefault:\n\t\tstrscpy(cbuf, \"?\", 2);\n\t\tbreak;\n\t}\n\tdev_info(&port->dd->pdev->dev,\n\t\t\"Card Type: %s\\n\", cbuf);\n}\n\n \nstatic inline void fill_command_sg(struct driver_data *dd,\n\t\t\t\tstruct mtip_cmd *command,\n\t\t\t\tint nents)\n{\n\tint n;\n\tunsigned int dma_len;\n\tstruct mtip_cmd_sg *command_sg;\n\tstruct scatterlist *sg;\n\n\tcommand_sg = command->command + AHCI_CMD_TBL_HDR_SZ;\n\n\tfor_each_sg(command->sg, sg, nents, n) {\n\t\tdma_len = sg_dma_len(sg);\n\t\tif (dma_len > 0x400000)\n\t\t\tdev_err(&dd->pdev->dev,\n\t\t\t\t\"DMA segment length truncated\\n\");\n\t\tcommand_sg->info = cpu_to_le32((dma_len-1) & 0x3FFFFF);\n\t\tcommand_sg->dba\t=  cpu_to_le32(sg_dma_address(sg));\n\t\tcommand_sg->dba_upper =\n\t\t\tcpu_to_le32((sg_dma_address(sg) >> 16) >> 16);\n\t\tcommand_sg++;\n\t}\n}\n\n \nstatic int exec_drive_task(struct mtip_port *port, u8 *command)\n{\n\tstruct host_to_dev_fis\tfis;\n\tstruct host_to_dev_fis *reply = (port->rxfis + RX_FIS_D2H_REG);\n\tunsigned int to;\n\n\t \n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= command[0];\n\tfis.features\t= command[1];\n\tfis.sect_count\t= command[2];\n\tfis.sector\t= command[3];\n\tfis.cyl_low\t= command[4];\n\tfis.cyl_hi\t= command[5];\n\tfis.device\t= command[6] & ~0x10;  \n\n\tmtip_set_timeout(port->dd, &fis, &to, 0);\n\n\tdbg_printk(MTIP_DRV_NAME \" %s: User Command: cmd %x, feat %x, nsect %x, sect %x, lcyl %x, hcyl %x, sel %x\\n\",\n\t\t__func__,\n\t\tcommand[0],\n\t\tcommand[1],\n\t\tcommand[2],\n\t\tcommand[3],\n\t\tcommand[4],\n\t\tcommand[5],\n\t\tcommand[6]);\n\n\t \n\tif (mtip_exec_internal_command(port,\n\t\t\t\t &fis,\n\t\t\t\t 5,\n\t\t\t\t 0,\n\t\t\t\t 0,\n\t\t\t\t 0,\n\t\t\t\t to) < 0) {\n\t\treturn -1;\n\t}\n\n\tcommand[0] = reply->command;  \n\tcommand[1] = reply->features;  \n\tcommand[4] = reply->cyl_low;\n\tcommand[5] = reply->cyl_hi;\n\n\tdbg_printk(MTIP_DRV_NAME \" %s: Completion Status: stat %x, err %x , cyl_lo %x cyl_hi %x\\n\",\n\t\t__func__,\n\t\tcommand[0],\n\t\tcommand[1],\n\t\tcommand[4],\n\t\tcommand[5]);\n\n\treturn 0;\n}\n\n \nstatic int exec_drive_command(struct mtip_port *port, u8 *command,\n\t\t\t\tvoid __user *user_buffer)\n{\n\tstruct host_to_dev_fis\tfis;\n\tstruct host_to_dev_fis *reply;\n\tu8 *buf = NULL;\n\tdma_addr_t dma_addr = 0;\n\tint rv = 0, xfer_sz = command[3];\n\tunsigned int to;\n\n\tif (xfer_sz) {\n\t\tif (!user_buffer)\n\t\t\treturn -EFAULT;\n\n\t\tbuf = dma_alloc_coherent(&port->dd->pdev->dev,\n\t\t\t\tATA_SECT_SIZE * xfer_sz,\n\t\t\t\t&dma_addr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tdev_err(&port->dd->pdev->dev,\n\t\t\t\t\"Memory allocation failed (%d bytes)\\n\",\n\t\t\t\tATA_SECT_SIZE * xfer_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= command[0];\n\tfis.features\t= command[2];\n\tfis.sect_count\t= command[3];\n\tif (fis.command == ATA_CMD_SMART) {\n\t\tfis.sector\t= command[1];\n\t\tfis.cyl_low\t= 0x4F;\n\t\tfis.cyl_hi\t= 0xC2;\n\t}\n\n\tmtip_set_timeout(port->dd, &fis, &to, 0);\n\n\tif (xfer_sz)\n\t\treply = (port->rxfis + RX_FIS_PIO_SETUP);\n\telse\n\t\treply = (port->rxfis + RX_FIS_D2H_REG);\n\n\tdbg_printk(MTIP_DRV_NAME\n\t\t\" %s: User Command: cmd %x, sect %x, \"\n\t\t\"feat %x, sectcnt %x\\n\",\n\t\t__func__,\n\t\tcommand[0],\n\t\tcommand[1],\n\t\tcommand[2],\n\t\tcommand[3]);\n\n\t \n\tif (mtip_exec_internal_command(port,\n\t\t\t\t&fis,\n\t\t\t\t 5,\n\t\t\t\t (xfer_sz ? dma_addr : 0),\n\t\t\t\t (xfer_sz ? ATA_SECT_SIZE * xfer_sz : 0),\n\t\t\t\t 0,\n\t\t\t\t to)\n\t\t\t\t < 0) {\n\t\trv = -EFAULT;\n\t\tgoto exit_drive_command;\n\t}\n\n\t \n\tcommand[0] = reply->command;  \n\tcommand[1] = reply->features;  \n\tcommand[2] = reply->sect_count;\n\n\tdbg_printk(MTIP_DRV_NAME\n\t\t\" %s: Completion Status: stat %x, \"\n\t\t\"err %x, nsect %x\\n\",\n\t\t__func__,\n\t\tcommand[0],\n\t\tcommand[1],\n\t\tcommand[2]);\n\n\tif (xfer_sz) {\n\t\tif (copy_to_user(user_buffer,\n\t\t\t\t buf,\n\t\t\t\t ATA_SECT_SIZE * command[3])) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto exit_drive_command;\n\t\t}\n\t}\nexit_drive_command:\n\tif (buf)\n\t\tdma_free_coherent(&port->dd->pdev->dev,\n\t\t\t\tATA_SECT_SIZE * xfer_sz, buf, dma_addr);\n\treturn rv;\n}\n\n \nstatic unsigned int implicit_sector(unsigned char command,\n\t\t\t\t    unsigned char features)\n{\n\tunsigned int rv = 0;\n\n\t \n\tswitch (command) {\n\tcase ATA_CMD_SEC_SET_PASS:\n\tcase ATA_CMD_SEC_UNLOCK:\n\tcase ATA_CMD_SEC_ERASE_PREP:\n\tcase ATA_CMD_SEC_ERASE_UNIT:\n\tcase ATA_CMD_SEC_FREEZE_LOCK:\n\tcase ATA_CMD_SEC_DISABLE_PASS:\n\tcase ATA_CMD_PMP_READ:\n\tcase ATA_CMD_PMP_WRITE:\n\t\trv = 1;\n\t\tbreak;\n\tcase ATA_CMD_SET_MAX:\n\t\tif (features == ATA_SET_MAX_UNLOCK)\n\t\t\trv = 1;\n\t\tbreak;\n\tcase ATA_CMD_SMART:\n\t\tif ((features == ATA_SMART_READ_VALUES) ||\n\t\t\t\t(features == ATA_SMART_READ_THRESHOLDS))\n\t\t\trv = 1;\n\t\tbreak;\n\tcase ATA_CMD_CONF_OVERLAY:\n\t\tif ((features == ATA_DCO_IDENTIFY) ||\n\t\t\t\t(features == ATA_DCO_SET))\n\t\t\trv = 1;\n\t\tbreak;\n\t}\n\treturn rv;\n}\n\n \nstatic int exec_drive_taskfile(struct driver_data *dd,\n\t\t\t       void __user *buf,\n\t\t\t       ide_task_request_t *req_task,\n\t\t\t       int outtotal)\n{\n\tstruct host_to_dev_fis\tfis;\n\tstruct host_to_dev_fis *reply;\n\tu8 *outbuf = NULL;\n\tu8 *inbuf = NULL;\n\tdma_addr_t outbuf_dma = 0;\n\tdma_addr_t inbuf_dma = 0;\n\tdma_addr_t dma_buffer = 0;\n\tint err = 0;\n\tunsigned int taskin = 0;\n\tunsigned int taskout = 0;\n\tu8 nsect = 0;\n\tunsigned int timeout;\n\tunsigned int force_single_sector;\n\tunsigned int transfer_size;\n\tunsigned long task_file_data;\n\tint intotal = outtotal + req_task->out_size;\n\tint erasemode = 0;\n\n\ttaskout = req_task->out_size;\n\ttaskin = req_task->in_size;\n\t \n\tif (taskin > 130560 || taskout > 130560)\n\t\treturn -EINVAL;\n\n\tif (taskout) {\n\t\toutbuf = memdup_user(buf + outtotal, taskout);\n\t\tif (IS_ERR(outbuf))\n\t\t\treturn PTR_ERR(outbuf);\n\n\t\toutbuf_dma = dma_map_single(&dd->pdev->dev, outbuf,\n\t\t\t\t\t    taskout, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&dd->pdev->dev, outbuf_dma)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto abort;\n\t\t}\n\t\tdma_buffer = outbuf_dma;\n\t}\n\n\tif (taskin) {\n\t\tinbuf = memdup_user(buf + intotal, taskin);\n\t\tif (IS_ERR(inbuf)) {\n\t\t\terr = PTR_ERR(inbuf);\n\t\t\tinbuf = NULL;\n\t\t\tgoto abort;\n\t\t}\n\t\tinbuf_dma = dma_map_single(&dd->pdev->dev, inbuf,\n\t\t\t\t\t   taskin, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&dd->pdev->dev, inbuf_dma)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto abort;\n\t\t}\n\t\tdma_buffer = inbuf_dma;\n\t}\n\n\t \n\tswitch (req_task->data_phase) {\n\tcase TASKFILE_OUT:\n\t\tnsect = taskout / ATA_SECT_SIZE;\n\t\treply = (dd->port->rxfis + RX_FIS_PIO_SETUP);\n\t\tbreak;\n\tcase TASKFILE_IN:\n\t\treply = (dd->port->rxfis + RX_FIS_PIO_SETUP);\n\t\tbreak;\n\tcase TASKFILE_NO_DATA:\n\t\treply = (dd->port->rxfis + RX_FIS_D2H_REG);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\t \n\tmemset(&fis, 0, sizeof(struct host_to_dev_fis));\n\n\tfis.type\t= 0x27;\n\tfis.opts\t= 1 << 7;\n\tfis.command\t= req_task->io_ports[7];\n\tfis.features\t= req_task->io_ports[1];\n\tfis.sect_count\t= req_task->io_ports[2];\n\tfis.lba_low\t= req_task->io_ports[3];\n\tfis.lba_mid\t= req_task->io_ports[4];\n\tfis.lba_hi\t= req_task->io_ports[5];\n\t  \n\tfis.device\t= req_task->io_ports[6] & ~0x10;\n\n\tif ((req_task->in_flags.all == 0) && (req_task->out_flags.all & 1)) {\n\t\treq_task->in_flags.all\t=\n\t\t\tIDE_TASKFILE_STD_IN_FLAGS |\n\t\t\t(IDE_HOB_STD_IN_FLAGS << 8);\n\t\tfis.lba_low_ex\t\t= req_task->hob_ports[3];\n\t\tfis.lba_mid_ex\t\t= req_task->hob_ports[4];\n\t\tfis.lba_hi_ex\t\t= req_task->hob_ports[5];\n\t\tfis.features_ex\t\t= req_task->hob_ports[1];\n\t\tfis.sect_cnt_ex\t\t= req_task->hob_ports[2];\n\n\t} else {\n\t\treq_task->in_flags.all = IDE_TASKFILE_STD_IN_FLAGS;\n\t}\n\n\tforce_single_sector = implicit_sector(fis.command, fis.features);\n\n\tif ((taskin || taskout) && (!fis.sect_count)) {\n\t\tif (nsect)\n\t\t\tfis.sect_count = nsect;\n\t\telse {\n\t\t\tif (!force_single_sector) {\n\t\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\t\"data movement but \"\n\t\t\t\t\t\"sect_count is 0\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\tdbg_printk(MTIP_DRV_NAME\n\t\t\" %s: cmd %x, feat %x, nsect %x,\"\n\t\t\" sect/lbal %x, lcyl/lbam %x, hcyl/lbah %x,\"\n\t\t\" head/dev %x\\n\",\n\t\t__func__,\n\t\tfis.command,\n\t\tfis.features,\n\t\tfis.sect_count,\n\t\tfis.lba_low,\n\t\tfis.lba_mid,\n\t\tfis.lba_hi,\n\t\tfis.device);\n\n\t \n\tif ((fis.command == ATA_CMD_SEC_ERASE_UNIT) && outbuf &&\n\t\t\t\t\t(outbuf[0] & MTIP_SEC_ERASE_MODE)) {\n\t\terasemode = 1;\n\t}\n\n\tmtip_set_timeout(dd, &fis, &timeout, erasemode);\n\n\t \n\tif (force_single_sector)\n\t\ttransfer_size = ATA_SECT_SIZE;\n\telse\n\t\ttransfer_size = ATA_SECT_SIZE * fis.sect_count;\n\n\t \n\tif (mtip_exec_internal_command(dd->port,\n\t\t\t\t &fis,\n\t\t\t\t 5,\n\t\t\t\t dma_buffer,\n\t\t\t\t transfer_size,\n\t\t\t\t 0,\n\t\t\t\t timeout) < 0) {\n\t\terr = -EIO;\n\t\tgoto abort;\n\t}\n\n\ttask_file_data = readl(dd->port->mmio+PORT_TFDATA);\n\n\tif ((req_task->data_phase == TASKFILE_IN) && !(task_file_data & 1)) {\n\t\treply = dd->port->rxfis + RX_FIS_PIO_SETUP;\n\t\treq_task->io_ports[7] = reply->control;\n\t} else {\n\t\treply = dd->port->rxfis + RX_FIS_D2H_REG;\n\t\treq_task->io_ports[7] = reply->command;\n\t}\n\n\t \n\tif (inbuf_dma)\n\t\tdma_unmap_single(&dd->pdev->dev, inbuf_dma, taskin,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (outbuf_dma)\n\t\tdma_unmap_single(&dd->pdev->dev, outbuf_dma, taskout,\n\t\t\t\t DMA_TO_DEVICE);\n\tinbuf_dma  = 0;\n\toutbuf_dma = 0;\n\n\t \n\treq_task->io_ports[1] = reply->features;\n\treq_task->io_ports[2] = reply->sect_count;\n\treq_task->io_ports[3] = reply->lba_low;\n\treq_task->io_ports[4] = reply->lba_mid;\n\treq_task->io_ports[5] = reply->lba_hi;\n\treq_task->io_ports[6] = reply->device;\n\n\tif (req_task->out_flags.all & 1)  {\n\n\t\treq_task->hob_ports[3] = reply->lba_low_ex;\n\t\treq_task->hob_ports[4] = reply->lba_mid_ex;\n\t\treq_task->hob_ports[5] = reply->lba_hi_ex;\n\t\treq_task->hob_ports[1] = reply->features_ex;\n\t\treq_task->hob_ports[2] = reply->sect_cnt_ex;\n\t}\n\tdbg_printk(MTIP_DRV_NAME\n\t\t\" %s: Completion: stat %x,\"\n\t\t\"err %x, sect_cnt %x, lbalo %x,\"\n\t\t\"lbamid %x, lbahi %x, dev %x\\n\",\n\t\t__func__,\n\t\treq_task->io_ports[7],\n\t\treq_task->io_ports[1],\n\t\treq_task->io_ports[2],\n\t\treq_task->io_ports[3],\n\t\treq_task->io_ports[4],\n\t\treq_task->io_ports[5],\n\t\treq_task->io_ports[6]);\n\n\tif (taskout) {\n\t\tif (copy_to_user(buf + outtotal, outbuf, taskout)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto abort;\n\t\t}\n\t}\n\tif (taskin) {\n\t\tif (copy_to_user(buf + intotal, inbuf, taskin)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto abort;\n\t\t}\n\t}\nabort:\n\tif (inbuf_dma)\n\t\tdma_unmap_single(&dd->pdev->dev, inbuf_dma, taskin,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (outbuf_dma)\n\t\tdma_unmap_single(&dd->pdev->dev, outbuf_dma, taskout,\n\t\t\t\t DMA_TO_DEVICE);\n\tkfree(outbuf);\n\tkfree(inbuf);\n\n\treturn err;\n}\n\n \nstatic int mtip_hw_ioctl(struct driver_data *dd, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase HDIO_GET_IDENTITY:\n\t{\n\t\tif (copy_to_user((void __user *)arg, dd->port->identify,\n\t\t\t\t\t\tsizeof(u16) * ATA_ID_WORDS))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase HDIO_DRIVE_CMD:\n\t{\n\t\tu8 drive_command[4];\n\n\t\t \n\t\tif (copy_from_user(drive_command,\n\t\t\t\t\t (void __user *) arg,\n\t\t\t\t\t sizeof(drive_command)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (exec_drive_command(dd->port,\n\t\t\t\t\t drive_command,\n\t\t\t\t\t (void __user *) (arg+4)))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (copy_to_user((void __user *) arg,\n\t\t\t\t\t drive_command,\n\t\t\t\t\t sizeof(drive_command)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\tcase HDIO_DRIVE_TASK:\n\t{\n\t\tu8 drive_command[7];\n\n\t\t \n\t\tif (copy_from_user(drive_command,\n\t\t\t\t\t (void __user *) arg,\n\t\t\t\t\t sizeof(drive_command)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (exec_drive_task(dd->port, drive_command))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (copy_to_user((void __user *) arg,\n\t\t\t\t\t drive_command,\n\t\t\t\t\t sizeof(drive_command)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\tcase HDIO_DRIVE_TASKFILE: {\n\t\tide_task_request_t req_task;\n\t\tint ret, outtotal;\n\n\t\tif (copy_from_user(&req_task, (void __user *) arg,\n\t\t\t\t\tsizeof(req_task)))\n\t\t\treturn -EFAULT;\n\n\t\touttotal = sizeof(req_task);\n\n\t\tret = exec_drive_taskfile(dd, (void __user *) arg,\n\t\t\t\t\t\t&req_task, outtotal);\n\n\t\tif (copy_to_user((void __user *) arg, &req_task,\n\t\t\t\t\t\t\tsizeof(req_task)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void mtip_hw_submit_io(struct driver_data *dd, struct request *rq,\n\t\t\t      struct mtip_cmd *command,\n\t\t\t      struct blk_mq_hw_ctx *hctx)\n{\n\tstruct mtip_cmd_hdr *hdr =\n\t\tdd->port->command_list + sizeof(struct mtip_cmd_hdr) * rq->tag;\n\tstruct host_to_dev_fis\t*fis;\n\tstruct mtip_port *port = dd->port;\n\tint dma_dir = rq_data_dir(rq) == READ ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tu64 start = blk_rq_pos(rq);\n\tunsigned int nsect = blk_rq_sectors(rq);\n\tunsigned int nents;\n\n\t \n\tnents = blk_rq_map_sg(hctx->queue, rq, command->sg);\n\tnents = dma_map_sg(&dd->pdev->dev, command->sg, nents, dma_dir);\n\n\tprefetch(&port->flags);\n\n\tcommand->scatter_ents = nents;\n\n\t \n\tcommand->retries = MTIP_MAX_RETRIES;\n\n\t \n\tfis = command->command;\n\tfis->type        = 0x27;\n\tfis->opts        = 1 << 7;\n\tif (dma_dir == DMA_FROM_DEVICE)\n\t\tfis->command = ATA_CMD_FPDMA_READ;\n\telse\n\t\tfis->command = ATA_CMD_FPDMA_WRITE;\n\tfis->lba_low     = start & 0xFF;\n\tfis->lba_mid     = (start >> 8) & 0xFF;\n\tfis->lba_hi      = (start >> 16) & 0xFF;\n\tfis->lba_low_ex  = (start >> 24) & 0xFF;\n\tfis->lba_mid_ex  = (start >> 32) & 0xFF;\n\tfis->lba_hi_ex   = (start >> 40) & 0xFF;\n\tfis->device\t = 1 << 6;\n\tfis->features    = nsect & 0xFF;\n\tfis->features_ex = (nsect >> 8) & 0xFF;\n\tfis->sect_count  = ((rq->tag << 3) | (rq->tag >> 5));\n\tfis->sect_cnt_ex = 0;\n\tfis->control     = 0;\n\tfis->res2        = 0;\n\tfis->res3        = 0;\n\tfill_command_sg(dd, command, nents);\n\n\tif (unlikely(command->unaligned))\n\t\tfis->device |= 1 << 7;\n\n\t \n\thdr->ctba = cpu_to_le32(command->command_dma & 0xFFFFFFFF);\n\tif (test_bit(MTIP_PF_HOST_CAP_64, &dd->port->flags))\n\t\thdr->ctbau = cpu_to_le32((command->command_dma >> 16) >> 16);\n\thdr->opts = cpu_to_le32((nents << 16) | 5 | AHCI_CMD_PREFETCH);\n\thdr->byte_count = 0;\n\n\tcommand->direction = dma_dir;\n\n\t \n\tif (unlikely(port->flags & MTIP_PF_PAUSE_IO)) {\n\t\tset_bit(rq->tag, port->cmds_to_issue);\n\t\tset_bit(MTIP_PF_ISSUE_CMDS_BIT, &port->flags);\n\t\treturn;\n\t}\n\n\t \n\tmtip_issue_ncq_command(port, rq->tag);\n}\n\n \nstatic ssize_t mtip_hw_show_status(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct driver_data *dd = dev_to_disk(dev)->private_data;\n\tint size = 0;\n\n\tif (test_bit(MTIP_DDF_OVER_TEMP_BIT, &dd->dd_flag))\n\t\tsize += sprintf(buf, \"%s\", \"thermal_shutdown\\n\");\n\telse if (test_bit(MTIP_DDF_WRITE_PROTECT_BIT, &dd->dd_flag))\n\t\tsize += sprintf(buf, \"%s\", \"write_protect\\n\");\n\telse\n\t\tsize += sprintf(buf, \"%s\", \"online\\n\");\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR(status, 0444, mtip_hw_show_status, NULL);\n\nstatic struct attribute *mtip_disk_attrs[] = {\n\t&dev_attr_status.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mtip_disk_attr_group = {\n\t.attrs = mtip_disk_attrs,\n};\n\nstatic const struct attribute_group *mtip_disk_attr_groups[] = {\n\t&mtip_disk_attr_group,\n\tNULL,\n};\n\nstatic ssize_t mtip_hw_read_registers(struct file *f, char __user *ubuf,\n\t\t\t\t  size_t len, loff_t *offset)\n{\n\tstruct driver_data *dd =  (struct driver_data *)f->private_data;\n\tchar *buf;\n\tu32 group_allocated;\n\tint size = *offset;\n\tint n, rv = 0;\n\n\tif (!len || size)\n\t\treturn 0;\n\n\tbuf = kzalloc(MTIP_DFS_MAX_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsize += sprintf(&buf[size], \"H/ S ACTive      : [ 0x\");\n\n\tfor (n = dd->slot_groups-1; n >= 0; n--)\n\t\tsize += sprintf(&buf[size], \"%08X \",\n\t\t\t\t\t readl(dd->port->s_active[n]));\n\n\tsize += sprintf(&buf[size], \"]\\n\");\n\tsize += sprintf(&buf[size], \"H/ Command Issue : [ 0x\");\n\n\tfor (n = dd->slot_groups-1; n >= 0; n--)\n\t\tsize += sprintf(&buf[size], \"%08X \",\n\t\t\t\t\treadl(dd->port->cmd_issue[n]));\n\n\tsize += sprintf(&buf[size], \"]\\n\");\n\tsize += sprintf(&buf[size], \"H/ Completed     : [ 0x\");\n\n\tfor (n = dd->slot_groups-1; n >= 0; n--)\n\t\tsize += sprintf(&buf[size], \"%08X \",\n\t\t\t\treadl(dd->port->completed[n]));\n\n\tsize += sprintf(&buf[size], \"]\\n\");\n\tsize += sprintf(&buf[size], \"H/ PORT IRQ STAT : [ 0x%08X ]\\n\",\n\t\t\t\treadl(dd->port->mmio + PORT_IRQ_STAT));\n\tsize += sprintf(&buf[size], \"H/ HOST IRQ STAT : [ 0x%08X ]\\n\",\n\t\t\t\treadl(dd->mmio + HOST_IRQ_STAT));\n\tsize += sprintf(&buf[size], \"\\n\");\n\n\tsize += sprintf(&buf[size], \"L/ Commands in Q : [ 0x\");\n\n\tfor (n = dd->slot_groups-1; n >= 0; n--) {\n\t\tif (sizeof(long) > sizeof(u32))\n\t\t\tgroup_allocated =\n\t\t\t\tdd->port->cmds_to_issue[n/2] >> (32*(n&1));\n\t\telse\n\t\t\tgroup_allocated = dd->port->cmds_to_issue[n];\n\t\tsize += sprintf(&buf[size], \"%08X \", group_allocated);\n\t}\n\tsize += sprintf(&buf[size], \"]\\n\");\n\n\t*offset = size <= len ? size : len;\n\tsize = copy_to_user(ubuf, buf, *offset);\n\tif (size)\n\t\trv = -EFAULT;\n\n\tkfree(buf);\n\treturn rv ? rv : *offset;\n}\n\nstatic ssize_t mtip_hw_read_flags(struct file *f, char __user *ubuf,\n\t\t\t\t  size_t len, loff_t *offset)\n{\n\tstruct driver_data *dd =  (struct driver_data *)f->private_data;\n\tchar *buf;\n\tint size = *offset;\n\tint rv = 0;\n\n\tif (!len || size)\n\t\treturn 0;\n\n\tbuf = kzalloc(MTIP_DFS_MAX_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsize += sprintf(&buf[size], \"Flag-port : [ %08lX ]\\n\",\n\t\t\t\t\t\t\tdd->port->flags);\n\tsize += sprintf(&buf[size], \"Flag-dd   : [ %08lX ]\\n\",\n\t\t\t\t\t\t\tdd->dd_flag);\n\n\t*offset = size <= len ? size : len;\n\tsize = copy_to_user(ubuf, buf, *offset);\n\tif (size)\n\t\trv = -EFAULT;\n\n\tkfree(buf);\n\treturn rv ? rv : *offset;\n}\n\nstatic const struct file_operations mtip_regs_fops = {\n\t.owner  = THIS_MODULE,\n\t.open   = simple_open,\n\t.read   = mtip_hw_read_registers,\n\t.llseek = no_llseek,\n};\n\nstatic const struct file_operations mtip_flags_fops = {\n\t.owner  = THIS_MODULE,\n\t.open   = simple_open,\n\t.read   = mtip_hw_read_flags,\n\t.llseek = no_llseek,\n};\n\nstatic int mtip_hw_debugfs_init(struct driver_data *dd)\n{\n\tif (!dfs_parent)\n\t\treturn -1;\n\n\tdd->dfs_node = debugfs_create_dir(dd->disk->disk_name, dfs_parent);\n\tif (IS_ERR_OR_NULL(dd->dfs_node)) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Error creating node %s under debugfs\\n\",\n\t\t\t\t\t\tdd->disk->disk_name);\n\t\tdd->dfs_node = NULL;\n\t\treturn -1;\n\t}\n\n\tdebugfs_create_file(\"flags\", 0444, dd->dfs_node, dd, &mtip_flags_fops);\n\tdebugfs_create_file(\"registers\", 0444, dd->dfs_node, dd,\n\t\t\t    &mtip_regs_fops);\n\n\treturn 0;\n}\n\nstatic void mtip_hw_debugfs_exit(struct driver_data *dd)\n{\n\tdebugfs_remove_recursive(dd->dfs_node);\n}\n\n \nstatic inline void hba_setup(struct driver_data *dd)\n{\n\tu32 hwdata;\n\thwdata = readl(dd->mmio + HOST_HSORG);\n\n\t \n\twritel(hwdata |\n\t\tHSORG_DISABLE_SLOTGRP_INTR |\n\t\tHSORG_DISABLE_SLOTGRP_PXIS,\n\t\tdd->mmio + HOST_HSORG);\n}\n\nstatic int mtip_device_unaligned_constrained(struct driver_data *dd)\n{\n\treturn (dd->pdev->device == P420M_DEVICE_ID ? 1 : 0);\n}\n\n \nstatic void mtip_detect_product(struct driver_data *dd)\n{\n\tu32 hwdata;\n\tunsigned int rev, slotgroups;\n\n\t \n\thwdata = readl(dd->mmio + HOST_HSORG);\n\n\tdd->product_type = MTIP_PRODUCT_UNKNOWN;\n\tdd->slot_groups = 1;\n\n\tif (hwdata & 0x8) {\n\t\tdd->product_type = MTIP_PRODUCT_ASICFPGA;\n\t\trev = (hwdata & HSORG_HWREV) >> 8;\n\t\tslotgroups = (hwdata & HSORG_SLOTGROUPS) + 1;\n\t\tdev_info(&dd->pdev->dev,\n\t\t\t\"ASIC-FPGA design, HS rev 0x%x, \"\n\t\t\t\"%i slot groups [%i slots]\\n\",\n\t\t\t rev,\n\t\t\t slotgroups,\n\t\t\t slotgroups * 32);\n\n\t\tif (slotgroups > MTIP_MAX_SLOT_GROUPS) {\n\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\"Warning: driver only supports \"\n\t\t\t\t\"%i slot groups.\\n\", MTIP_MAX_SLOT_GROUPS);\n\t\t\tslotgroups = MTIP_MAX_SLOT_GROUPS;\n\t\t}\n\t\tdd->slot_groups = slotgroups;\n\t\treturn;\n\t}\n\n\tdev_warn(&dd->pdev->dev, \"Unrecognized product id\\n\");\n}\n\n \nstatic int mtip_ftl_rebuild_poll(struct driver_data *dd)\n{\n\tunsigned long timeout, cnt = 0, start;\n\n\tdev_warn(&dd->pdev->dev,\n\t\t\"FTL rebuild in progress. Polling for completion.\\n\");\n\n\tstart = jiffies;\n\ttimeout = jiffies + msecs_to_jiffies(MTIP_FTL_REBUILD_TIMEOUT_MS);\n\n\tdo {\n\t\tif (unlikely(test_bit(MTIP_DDF_REMOVE_PENDING_BIT,\n\t\t\t\t&dd->dd_flag)))\n\t\t\treturn -EFAULT;\n\t\tif (mtip_check_surprise_removal(dd))\n\t\t\treturn -EFAULT;\n\n\t\tif (mtip_get_identify(dd->port, NULL) < 0)\n\t\t\treturn -EFAULT;\n\n\t\tif (*(dd->port->identify + MTIP_FTL_REBUILD_OFFSET) ==\n\t\t\tMTIP_FTL_REBUILD_MAGIC) {\n\t\t\tssleep(1);\n\t\t\t \n\t\t\tif (cnt++ >= 180) {\n\t\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\"FTL rebuild in progress (%d secs).\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - start) / 1000);\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\"FTL rebuild complete (%d secs).\\n\",\n\t\t\tjiffies_to_msecs(jiffies - start) / 1000);\n\t\t\tmtip_block_initialize(dd);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_before(jiffies, timeout));\n\n\t \n\tdev_err(&dd->pdev->dev,\n\t\t\"Timed out waiting for FTL rebuild to complete (%d secs).\\n\",\n\t\tjiffies_to_msecs(jiffies - start) / 1000);\n\treturn -EFAULT;\n}\n\nstatic void mtip_softirq_done_fn(struct request *rq)\n{\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct driver_data *dd = rq->q->queuedata;\n\n\t \n\tdma_unmap_sg(&dd->pdev->dev, cmd->sg, cmd->scatter_ents,\n\t\t\t\t\t\t\tcmd->direction);\n\n\tif (unlikely(cmd->unaligned))\n\t\tatomic_inc(&dd->port->cmd_slot_unal);\n\n\tblk_mq_end_request(rq, cmd->status);\n}\n\nstatic bool mtip_abort_cmd(struct request *req, void *data)\n{\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(req);\n\tstruct driver_data *dd = data;\n\n\tdbg_printk(MTIP_DRV_NAME \" Aborting request, tag = %d\\n\", req->tag);\n\n\tclear_bit(req->tag, dd->port->cmds_to_issue);\n\tcmd->status = BLK_STS_IOERR;\n\tmtip_softirq_done_fn(req);\n\treturn true;\n}\n\nstatic bool mtip_queue_cmd(struct request *req, void *data)\n{\n\tstruct driver_data *dd = data;\n\n\tset_bit(req->tag, dd->port->cmds_to_issue);\n\tblk_abort_request(req);\n\treturn true;\n}\n\n \n\nstatic int mtip_service_thread(void *data)\n{\n\tstruct driver_data *dd = (struct driver_data *)data;\n\tunsigned long slot, slot_start, slot_wrap, to;\n\tunsigned int num_cmd_slots = dd->slot_groups * 32;\n\tstruct mtip_port *port = dd->port;\n\n\twhile (1) {\n\t\tif (kthread_should_stop() ||\n\t\t\ttest_bit(MTIP_PF_SVC_THD_STOP_BIT, &port->flags))\n\t\t\tgoto st_out;\n\t\tclear_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &port->flags);\n\n\t\t \n\t\twait_event_interruptible(port->svc_wait, (port->flags) &&\n\t\t\t(port->flags & MTIP_PF_SVC_THD_WORK));\n\n\t\tif (kthread_should_stop() ||\n\t\t\ttest_bit(MTIP_PF_SVC_THD_STOP_BIT, &port->flags))\n\t\t\tgoto st_out;\n\n\t\tif (unlikely(test_bit(MTIP_DDF_REMOVE_PENDING_BIT,\n\t\t\t\t&dd->dd_flag)))\n\t\t\tgoto st_out;\n\n\t\tset_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &port->flags);\n\nrestart_eh:\n\t\t \n\t\tif (test_bit(MTIP_PF_EH_ACTIVE_BIT, &port->flags)) {\n\t\t\tmtip_handle_tfe(dd);\n\t\t\tclear_bit(MTIP_PF_EH_ACTIVE_BIT, &port->flags);\n\t\t}\n\n\t\tif (test_bit(MTIP_PF_EH_ACTIVE_BIT, &port->flags))\n\t\t\tgoto restart_eh;\n\n\t\tif (test_bit(MTIP_PF_TO_ACTIVE_BIT, &port->flags)) {\n\t\t\tto = jiffies + msecs_to_jiffies(5000);\n\n\t\t\tdo {\n\t\t\t\tmdelay(100);\n\t\t\t} while (atomic_read(&dd->irq_workers_active) != 0 &&\n\t\t\t\ttime_before(jiffies, to));\n\n\t\t\tif (atomic_read(&dd->irq_workers_active) != 0)\n\t\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\t\"Completion workers still active!\");\n\n\t\t\tblk_mq_quiesce_queue(dd->queue);\n\n\t\t\tblk_mq_tagset_busy_iter(&dd->tags, mtip_queue_cmd, dd);\n\n\t\t\tset_bit(MTIP_PF_ISSUE_CMDS_BIT, &dd->port->flags);\n\n\t\t\tif (mtip_device_reset(dd))\n\t\t\t\tblk_mq_tagset_busy_iter(&dd->tags,\n\t\t\t\t\t\t\tmtip_abort_cmd, dd);\n\n\t\t\tclear_bit(MTIP_PF_TO_ACTIVE_BIT, &dd->port->flags);\n\n\t\t\tblk_mq_unquiesce_queue(dd->queue);\n\t\t}\n\n\t\tif (test_bit(MTIP_PF_ISSUE_CMDS_BIT, &port->flags)) {\n\t\t\tslot = 1;\n\t\t\t \n\t\t\tslot_start = num_cmd_slots;\n\t\t\tslot_wrap = 0;\n\t\t\twhile (1) {\n\t\t\t\tslot = find_next_bit(port->cmds_to_issue,\n\t\t\t\t\t\tnum_cmd_slots, slot);\n\t\t\t\tif (slot_wrap == 1) {\n\t\t\t\t\tif ((slot_start >= slot) ||\n\t\t\t\t\t\t(slot >= num_cmd_slots))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (unlikely(slot_start == num_cmd_slots))\n\t\t\t\t\tslot_start = slot;\n\n\t\t\t\tif (unlikely(slot == num_cmd_slots)) {\n\t\t\t\t\tslot = 1;\n\t\t\t\t\tslot_wrap = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmtip_issue_ncq_command(port, slot);\n\n\t\t\t\tclear_bit(slot, port->cmds_to_issue);\n\t\t\t}\n\n\t\t\tclear_bit(MTIP_PF_ISSUE_CMDS_BIT, &port->flags);\n\t\t}\n\n\t\tif (test_bit(MTIP_PF_REBUILD_BIT, &port->flags)) {\n\t\t\tif (mtip_ftl_rebuild_poll(dd) == 0)\n\t\t\t\tclear_bit(MTIP_PF_REBUILD_BIT, &port->flags);\n\t\t}\n\t}\n\nst_out:\n\treturn 0;\n}\n\n \nstatic void mtip_dma_free(struct driver_data *dd)\n{\n\tstruct mtip_port *port = dd->port;\n\n\tif (port->block1)\n\t\tdma_free_coherent(&dd->pdev->dev, BLOCK_DMA_ALLOC_SZ,\n\t\t\t\t\tport->block1, port->block1_dma);\n\n\tif (port->command_list) {\n\t\tdma_free_coherent(&dd->pdev->dev, AHCI_CMD_TBL_SZ,\n\t\t\t\tport->command_list, port->command_list_dma);\n\t}\n}\n\n \nstatic int mtip_dma_alloc(struct driver_data *dd)\n{\n\tstruct mtip_port *port = dd->port;\n\n\t \n\tport->block1 =\n\t\tdma_alloc_coherent(&dd->pdev->dev, BLOCK_DMA_ALLOC_SZ,\n\t\t\t\t\t&port->block1_dma, GFP_KERNEL);\n\tif (!port->block1)\n\t\treturn -ENOMEM;\n\n\t \n\tport->command_list =\n\t\tdma_alloc_coherent(&dd->pdev->dev, AHCI_CMD_TBL_SZ,\n\t\t\t\t\t&port->command_list_dma, GFP_KERNEL);\n\tif (!port->command_list) {\n\t\tdma_free_coherent(&dd->pdev->dev, BLOCK_DMA_ALLOC_SZ,\n\t\t\t\t\tport->block1, port->block1_dma);\n\t\tport->block1 = NULL;\n\t\tport->block1_dma = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tport->rxfis         = port->block1 + AHCI_RX_FIS_OFFSET;\n\tport->rxfis_dma     = port->block1_dma + AHCI_RX_FIS_OFFSET;\n\tport->identify      = port->block1 + AHCI_IDFY_OFFSET;\n\tport->identify_dma  = port->block1_dma + AHCI_IDFY_OFFSET;\n\tport->log_buf       = port->block1 + AHCI_SECTBUF_OFFSET;\n\tport->log_buf_dma   = port->block1_dma + AHCI_SECTBUF_OFFSET;\n\tport->smart_buf     = port->block1 + AHCI_SMARTBUF_OFFSET;\n\tport->smart_buf_dma = port->block1_dma + AHCI_SMARTBUF_OFFSET;\n\n\treturn 0;\n}\n\nstatic int mtip_hw_get_identify(struct driver_data *dd)\n{\n\tstruct smart_attr attr242;\n\tunsigned char *buf;\n\tint rv;\n\n\tif (mtip_get_identify(dd->port, NULL) < 0)\n\t\treturn -EFAULT;\n\n\tif (*(dd->port->identify + MTIP_FTL_REBUILD_OFFSET) ==\n\t\tMTIP_FTL_REBUILD_MAGIC) {\n\t\tset_bit(MTIP_PF_REBUILD_BIT, &dd->port->flags);\n\t\treturn MTIP_FTL_REBUILD_MAGIC;\n\t}\n\tmtip_dump_identify(dd->port);\n\n\t \n\trv = mtip_read_log_page(dd->port, ATA_LOG_SATA_NCQ,\n\t\t\t\tdd->port->log_buf,\n\t\t\t\tdd->port->log_buf_dma, 1);\n\tif (rv) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Error in READ LOG EXT (10h) command\\n\");\n\t\t \n\t} else {\n\t\tbuf = (unsigned char *)dd->port->log_buf;\n\t\tif (buf[259] & 0x1) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Write protect bit is set.\\n\");\n\t\t\tset_bit(MTIP_DDF_WRITE_PROTECT_BIT, &dd->dd_flag);\n\t\t}\n\t\tif (buf[288] == 0xF7) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Exceeded Tmax, drive in thermal shutdown.\\n\");\n\t\t\tset_bit(MTIP_DDF_OVER_TEMP_BIT, &dd->dd_flag);\n\t\t}\n\t\tif (buf[288] == 0xBF) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Drive indicates rebuild has failed.\\n\");\n\t\t\tset_bit(MTIP_DDF_REBUILD_FAILED_BIT, &dd->dd_flag);\n\t\t}\n\t}\n\n\t \n\tmemset(&attr242, 0, sizeof(struct smart_attr));\n\tif (mtip_get_smart_attr(dd->port, 242, &attr242))\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\"Unable to check write protect progress\\n\");\n\telse\n\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Write protect progress: %u%% (%u blocks)\\n\",\n\t\t\t\tattr242.cur, le32_to_cpu(attr242.data));\n\n\treturn rv;\n}\n\n \nstatic int mtip_hw_init(struct driver_data *dd)\n{\n\tint i;\n\tint rv;\n\tunsigned long timeout, timetaken;\n\n\tdd->mmio = pcim_iomap_table(dd->pdev)[MTIP_ABAR];\n\n\tmtip_detect_product(dd);\n\tif (dd->product_type == MTIP_PRODUCT_UNKNOWN) {\n\t\trv = -EIO;\n\t\tgoto out1;\n\t}\n\n\thba_setup(dd);\n\n\tdd->port = kzalloc_node(sizeof(struct mtip_port), GFP_KERNEL,\n\t\t\t\tdd->numa_node);\n\tif (!dd->port)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < MTIP_MAX_SLOT_GROUPS; i++)\n\t\tdd->work[i].port = dd->port;\n\n\t \n\tif (mtip_device_unaligned_constrained(dd))\n\t\tdd->unal_qdepth = MTIP_MAX_UNALIGNED_SLOTS;\n\telse\n\t\tdd->unal_qdepth = 0;\n\n\tatomic_set(&dd->port->cmd_slot_unal, dd->unal_qdepth);\n\n\t \n\tfor (i = 0; i < MTIP_MAX_SLOT_GROUPS; i++)\n\t\tspin_lock_init(&dd->port->cmd_issue_lock[i]);\n\n\t \n\tdd->port->mmio\t= dd->mmio + PORT_OFFSET;\n\tdd->port->dd\t= dd;\n\n\t \n\trv = mtip_dma_alloc(dd);\n\tif (rv < 0)\n\t\tgoto out1;\n\n\t \n\tfor (i = 0; i < dd->slot_groups; i++) {\n\t\tdd->port->s_active[i] =\n\t\t\tdd->port->mmio + i*0x80 + PORT_SCR_ACT;\n\t\tdd->port->cmd_issue[i] =\n\t\t\tdd->port->mmio + i*0x80 + PORT_COMMAND_ISSUE;\n\t\tdd->port->completed[i] =\n\t\t\tdd->port->mmio + i*0x80 + PORT_SDBV;\n\t}\n\n\ttimetaken = jiffies;\n\ttimeout = jiffies + msecs_to_jiffies(30000);\n\twhile (((readl(dd->port->mmio + PORT_SCR_STAT) & 0x0F) != 0x03) &&\n\t\t time_before(jiffies, timeout)) {\n\t\tmdelay(100);\n\t}\n\tif (unlikely(mtip_check_surprise_removal(dd))) {\n\t\ttimetaken = jiffies - timetaken;\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Surprise removal detected at %u ms\\n\",\n\t\t\tjiffies_to_msecs(timetaken));\n\t\trv = -ENODEV;\n\t\tgoto out2 ;\n\t}\n\tif (unlikely(test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag))) {\n\t\ttimetaken = jiffies - timetaken;\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Removal detected at %u ms\\n\",\n\t\t\tjiffies_to_msecs(timetaken));\n\t\trv = -EFAULT;\n\t\tgoto out2;\n\t}\n\n\t \n\tif (!(readl(dd->mmio + HOST_CAP) & HOST_CAP_NZDMA)) {\n\t\tif (mtip_hba_reset(dd) < 0) {\n\t\t\tdev_err(&dd->pdev->dev,\n\t\t\t\t\"Card did not reset within timeout\\n\");\n\t\t\trv = -EIO;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\t \n\t\twritel(readl(dd->mmio + HOST_IRQ_STAT),\n\t\t\tdd->mmio + HOST_IRQ_STAT);\n\t}\n\n\tmtip_init_port(dd->port);\n\tmtip_start_port(dd->port);\n\n\t \n\trv = request_irq(dd->pdev->irq, mtip_irq_handler, IRQF_SHARED,\n\t\t\t dev_driver_string(&dd->pdev->dev), dd);\n\tif (rv) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Unable to allocate IRQ %d\\n\", dd->pdev->irq);\n\t\tgoto out2;\n\t}\n\tirq_set_affinity_hint(dd->pdev->irq, get_cpu_mask(dd->isr_binding));\n\n\t \n\twritel(readl(dd->mmio + HOST_CTL) | HOST_IRQ_EN,\n\t\t\t\t\tdd->mmio + HOST_CTL);\n\n\tinit_waitqueue_head(&dd->port->svc_wait);\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag)) {\n\t\trv = -EFAULT;\n\t\tgoto out3;\n\t}\n\n\treturn rv;\n\nout3:\n\t \n\twritel(readl(dd->mmio + HOST_CTL) & ~HOST_IRQ_EN,\n\t\t\tdd->mmio + HOST_CTL);\n\n\t \n\tirq_set_affinity_hint(dd->pdev->irq, NULL);\n\tfree_irq(dd->pdev->irq, dd);\n\nout2:\n\tmtip_deinit_port(dd->port);\n\tmtip_dma_free(dd);\n\nout1:\n\t \n\tkfree(dd->port);\n\n\treturn rv;\n}\n\nstatic int mtip_standby_drive(struct driver_data *dd)\n{\n\tint rv = 0;\n\n\tif (dd->sr || !dd->port)\n\t\treturn -ENODEV;\n\t \n\tif (!test_bit(MTIP_PF_REBUILD_BIT, &dd->port->flags) &&\n\t    !test_bit(MTIP_DDF_REBUILD_FAILED_BIT, &dd->dd_flag) &&\n\t    !test_bit(MTIP_DDF_SEC_LOCK_BIT, &dd->dd_flag)) {\n\t\trv = mtip_standby_immediate(dd->port);\n\t\tif (rv)\n\t\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\t\"STANDBY IMMEDIATE failed\\n\");\n\t}\n\treturn rv;\n}\n\n \nstatic int mtip_hw_exit(struct driver_data *dd)\n{\n\tif (!dd->sr) {\n\t\t \n\t\tmtip_deinit_port(dd->port);\n\n\t\t \n\t\twritel(readl(dd->mmio + HOST_CTL) & ~HOST_IRQ_EN,\n\t\t\t\tdd->mmio + HOST_CTL);\n\t}\n\n\t \n\tirq_set_affinity_hint(dd->pdev->irq, NULL);\n\tfree_irq(dd->pdev->irq, dd);\n\tmsleep(1000);\n\n\t \n\tmtip_dma_free(dd);\n\n\t \n\tkfree(dd->port);\n\tdd->port = NULL;\n\n\treturn 0;\n}\n\n \nstatic int mtip_hw_shutdown(struct driver_data *dd)\n{\n\t \n\tmtip_standby_drive(dd);\n\n\treturn 0;\n}\n\n \nstatic int mtip_hw_suspend(struct driver_data *dd)\n{\n\t \n\tif (mtip_standby_drive(dd) != 0) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Failed standby-immediate command\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\twritel(readl(dd->mmio + HOST_CTL) & ~HOST_IRQ_EN,\n\t\t\tdd->mmio + HOST_CTL);\n\tmtip_deinit_port(dd->port);\n\n\treturn 0;\n}\n\n \nstatic int mtip_hw_resume(struct driver_data *dd)\n{\n\t \n\thba_setup(dd);\n\n\t \n\tif (mtip_hba_reset(dd) != 0) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Unable to reset the HBA\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tmtip_init_port(dd->port);\n\tmtip_start_port(dd->port);\n\n\t \n\twritel(readl(dd->mmio + HOST_CTL) | HOST_IRQ_EN,\n\t\t\tdd->mmio + HOST_CTL);\n\n\treturn 0;\n}\n\n \nstatic int rssd_disk_name_format(char *prefix,\n\t\t\t\t int index,\n\t\t\t\t char *buf,\n\t\t\t\t int buflen)\n{\n\tconst int base = 'z' - 'a' + 1;\n\tchar *begin = buf + strlen(prefix);\n\tchar *end = buf + buflen;\n\tchar *p;\n\tint unit;\n\n\tp = end - 1;\n\t*p = '\\0';\n\tunit = base;\n\tdo {\n\t\tif (p == begin)\n\t\t\treturn -EINVAL;\n\t\t*--p = 'a' + (index % unit);\n\t\tindex = (index / unit) - 1;\n\t} while (index >= 0);\n\n\tmemmove(begin, p, end - p);\n\tmemcpy(buf, prefix, strlen(prefix));\n\n\treturn 0;\n}\n\n \nstatic int mtip_block_ioctl(struct block_device *dev,\n\t\t\t    blk_mode_t mode,\n\t\t\t    unsigned cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct driver_data *dd = dev->bd_disk->private_data;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!dd)\n\t\treturn -ENOTTY;\n\n\tif (unlikely(test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag)))\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase BLKFLSBUF:\n\t\treturn -ENOTTY;\n\tdefault:\n\t\treturn mtip_hw_ioctl(dd, cmd, arg);\n\t}\n}\n\n#ifdef CONFIG_COMPAT\n \nstatic int mtip_block_compat_ioctl(struct block_device *dev,\n\t\t\t    blk_mode_t mode,\n\t\t\t    unsigned cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct driver_data *dd = dev->bd_disk->private_data;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!dd)\n\t\treturn -ENOTTY;\n\n\tif (unlikely(test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag)))\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase BLKFLSBUF:\n\t\treturn -ENOTTY;\n\tcase HDIO_DRIVE_TASKFILE: {\n\t\tstruct mtip_compat_ide_task_request_s __user *compat_req_task;\n\t\tide_task_request_t req_task;\n\t\tint compat_tasksize, outtotal, ret;\n\n\t\tcompat_tasksize =\n\t\t\tsizeof(struct mtip_compat_ide_task_request_s);\n\n\t\tcompat_req_task =\n\t\t\t(struct mtip_compat_ide_task_request_s __user *) arg;\n\n\t\tif (copy_from_user(&req_task, (void __user *) arg,\n\t\t\tcompat_tasksize - (2 * sizeof(compat_long_t))))\n\t\t\treturn -EFAULT;\n\n\t\tif (get_user(req_task.out_size, &compat_req_task->out_size))\n\t\t\treturn -EFAULT;\n\n\t\tif (get_user(req_task.in_size, &compat_req_task->in_size))\n\t\t\treturn -EFAULT;\n\n\t\touttotal = sizeof(struct mtip_compat_ide_task_request_s);\n\n\t\tret = exec_drive_taskfile(dd, (void __user *) arg,\n\t\t\t\t\t\t&req_task, outtotal);\n\n\t\tif (copy_to_user((void __user *) arg, &req_task,\n\t\t\t\tcompat_tasksize -\n\t\t\t\t(2 * sizeof(compat_long_t))))\n\t\t\treturn -EFAULT;\n\n\t\tif (put_user(req_task.out_size, &compat_req_task->out_size))\n\t\t\treturn -EFAULT;\n\n\t\tif (put_user(req_task.in_size, &compat_req_task->in_size))\n\t\t\treturn -EFAULT;\n\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn mtip_hw_ioctl(dd, cmd, arg);\n\t}\n}\n#endif\n\n \nstatic int mtip_block_getgeo(struct block_device *dev,\n\t\t\t\tstruct hd_geometry *geo)\n{\n\tstruct driver_data *dd = dev->bd_disk->private_data;\n\tsector_t capacity;\n\n\tif (!dd)\n\t\treturn -ENOTTY;\n\n\tif (!(mtip_hw_get_capacity(dd, &capacity))) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Could not get drive capacity.\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tgeo->heads = 224;\n\tgeo->sectors = 56;\n\tsector_div(capacity, (geo->heads * geo->sectors));\n\tgeo->cylinders = capacity;\n\treturn 0;\n}\n\nstatic void mtip_block_free_disk(struct gendisk *disk)\n{\n\tstruct driver_data *dd = disk->private_data;\n\n\tida_free(&rssd_index_ida, dd->index);\n\tkfree(dd);\n}\n\n \nstatic const struct block_device_operations mtip_block_ops = {\n\t.ioctl\t\t= mtip_block_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= mtip_block_compat_ioctl,\n#endif\n\t.getgeo\t\t= mtip_block_getgeo,\n\t.free_disk\t= mtip_block_free_disk,\n\t.owner\t\t= THIS_MODULE\n};\n\nstatic inline bool is_se_active(struct driver_data *dd)\n{\n\tif (unlikely(test_bit(MTIP_PF_SE_ACTIVE_BIT, &dd->port->flags))) {\n\t\tif (dd->port->ic_pause_timer) {\n\t\t\tunsigned long to = dd->port->ic_pause_timer +\n\t\t\t\t\t\t\tmsecs_to_jiffies(1000);\n\t\t\tif (time_after(jiffies, to)) {\n\t\t\t\tclear_bit(MTIP_PF_SE_ACTIVE_BIT,\n\t\t\t\t\t\t\t&dd->port->flags);\n\t\t\t\tclear_bit(MTIP_DDF_SEC_LOCK_BIT, &dd->dd_flag);\n\t\t\t\tdd->port->ic_pause_timer = 0;\n\t\t\t\twake_up_interruptible(&dd->port->svc_wait);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool is_stopped(struct driver_data *dd, struct request *rq)\n{\n\tif (likely(!(dd->dd_flag & MTIP_DDF_STOP_IO)))\n\t\treturn false;\n\n\tif (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag))\n\t\treturn true;\n\tif (test_bit(MTIP_DDF_OVER_TEMP_BIT, &dd->dd_flag))\n\t\treturn true;\n\tif (test_bit(MTIP_DDF_WRITE_PROTECT_BIT, &dd->dd_flag) &&\n\t    rq_data_dir(rq))\n\t\treturn true;\n\tif (test_bit(MTIP_DDF_SEC_LOCK_BIT, &dd->dd_flag))\n\t\treturn true;\n\tif (test_bit(MTIP_DDF_REBUILD_FAILED_BIT, &dd->dd_flag))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool mtip_check_unal_depth(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t  struct request *rq)\n{\n\tstruct driver_data *dd = hctx->queue->queuedata;\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tif (rq_data_dir(rq) == READ || !dd->unal_qdepth)\n\t\treturn false;\n\n\t \n\tif (blk_rq_sectors(rq) <= 64) {\n\t\tif ((blk_rq_pos(rq) & 7) || (blk_rq_sectors(rq) & 7))\n\t\t\tcmd->unaligned = 1;\n\t}\n\n\tif (cmd->unaligned && atomic_dec_if_positive(&dd->port->cmd_slot_unal) >= 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic blk_status_t mtip_issue_reserved_cmd(struct blk_mq_hw_ctx *hctx,\n\t\tstruct request *rq)\n{\n\tstruct driver_data *dd = hctx->queue->queuedata;\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct mtip_int_cmd *icmd = cmd->icmd;\n\tstruct mtip_cmd_hdr *hdr =\n\t\tdd->port->command_list + sizeof(struct mtip_cmd_hdr) * rq->tag;\n\tstruct mtip_cmd_sg *command_sg;\n\n\tif (mtip_commands_active(dd->port))\n\t\treturn BLK_STS_DEV_RESOURCE;\n\n\thdr->ctba = cpu_to_le32(cmd->command_dma & 0xFFFFFFFF);\n\tif (test_bit(MTIP_PF_HOST_CAP_64, &dd->port->flags))\n\t\thdr->ctbau = cpu_to_le32((cmd->command_dma >> 16) >> 16);\n\t \n\thdr->opts = cpu_to_le32(icmd->opts | icmd->fis_len);\n\tif (icmd->buf_len) {\n\t\tcommand_sg = cmd->command + AHCI_CMD_TBL_HDR_SZ;\n\n\t\tcommand_sg->info = cpu_to_le32((icmd->buf_len-1) & 0x3FFFFF);\n\t\tcommand_sg->dba\t= cpu_to_le32(icmd->buffer & 0xFFFFFFFF);\n\t\tcommand_sg->dba_upper =\n\t\t\tcpu_to_le32((icmd->buffer >> 16) >> 16);\n\n\t\thdr->opts |= cpu_to_le32((1 << 16));\n\t}\n\n\t \n\thdr->byte_count = 0;\n\n\tblk_mq_start_request(rq);\n\tmtip_issue_non_ncq_command(dd->port, rq->tag);\n\treturn 0;\n}\n\nstatic blk_status_t mtip_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t const struct blk_mq_queue_data *bd)\n{\n\tstruct driver_data *dd = hctx->queue->queuedata;\n\tstruct request *rq = bd->rq;\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tif (blk_rq_is_passthrough(rq))\n\t\treturn mtip_issue_reserved_cmd(hctx, rq);\n\n\tif (unlikely(mtip_check_unal_depth(hctx, rq)))\n\t\treturn BLK_STS_DEV_RESOURCE;\n\n\tif (is_se_active(dd) || is_stopped(dd, rq))\n\t\treturn BLK_STS_IOERR;\n\n\tblk_mq_start_request(rq);\n\n\tmtip_hw_submit_io(dd, rq, cmd, hctx);\n\treturn BLK_STS_OK;\n}\n\nstatic void mtip_free_cmd(struct blk_mq_tag_set *set, struct request *rq,\n\t\t\t  unsigned int hctx_idx)\n{\n\tstruct driver_data *dd = set->driver_data;\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tif (!cmd->command)\n\t\treturn;\n\n\tdma_free_coherent(&dd->pdev->dev, CMD_DMA_ALLOC_SZ, cmd->command,\n\t\t\t  cmd->command_dma);\n}\n\nstatic int mtip_init_cmd(struct blk_mq_tag_set *set, struct request *rq,\n\t\t\t unsigned int hctx_idx, unsigned int numa_node)\n{\n\tstruct driver_data *dd = set->driver_data;\n\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tcmd->command = dma_alloc_coherent(&dd->pdev->dev, CMD_DMA_ALLOC_SZ,\n\t\t\t&cmd->command_dma, GFP_KERNEL);\n\tif (!cmd->command)\n\t\treturn -ENOMEM;\n\n\tsg_init_table(cmd->sg, MTIP_MAX_SG);\n\treturn 0;\n}\n\nstatic enum blk_eh_timer_return mtip_cmd_timeout(struct request *req)\n{\n\tstruct driver_data *dd = req->q->queuedata;\n\n\tif (blk_mq_is_reserved_rq(req)) {\n\t\tstruct mtip_cmd *cmd = blk_mq_rq_to_pdu(req);\n\n\t\tcmd->status = BLK_STS_TIMEOUT;\n\t\tblk_mq_complete_request(req);\n\t\treturn BLK_EH_DONE;\n\t}\n\n\tif (test_bit(req->tag, dd->port->cmds_to_issue))\n\t\tgoto exit_handler;\n\n\tif (test_and_set_bit(MTIP_PF_TO_ACTIVE_BIT, &dd->port->flags))\n\t\tgoto exit_handler;\n\n\twake_up_interruptible(&dd->port->svc_wait);\nexit_handler:\n\treturn BLK_EH_RESET_TIMER;\n}\n\nstatic const struct blk_mq_ops mtip_mq_ops = {\n\t.queue_rq\t= mtip_queue_rq,\n\t.init_request\t= mtip_init_cmd,\n\t.exit_request\t= mtip_free_cmd,\n\t.complete\t= mtip_softirq_done_fn,\n\t.timeout        = mtip_cmd_timeout,\n};\n\n \nstatic int mtip_block_initialize(struct driver_data *dd)\n{\n\tint rv = 0, wait_for_rebuild = 0;\n\tsector_t capacity;\n\tunsigned int index = 0;\n\n\tif (dd->disk)\n\t\tgoto skip_create_disk;  \n\n\tif (mtip_hw_init(dd)) {\n\t\trv = -EINVAL;\n\t\tgoto protocol_init_error;\n\t}\n\n\tmemset(&dd->tags, 0, sizeof(dd->tags));\n\tdd->tags.ops = &mtip_mq_ops;\n\tdd->tags.nr_hw_queues = 1;\n\tdd->tags.queue_depth = MTIP_MAX_COMMAND_SLOTS;\n\tdd->tags.reserved_tags = 1;\n\tdd->tags.cmd_size = sizeof(struct mtip_cmd);\n\tdd->tags.numa_node = dd->numa_node;\n\tdd->tags.flags = BLK_MQ_F_SHOULD_MERGE;\n\tdd->tags.driver_data = dd;\n\tdd->tags.timeout = MTIP_NCQ_CMD_TIMEOUT_MS;\n\n\trv = blk_mq_alloc_tag_set(&dd->tags);\n\tif (rv) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Unable to allocate request queue\\n\");\n\t\tgoto block_queue_alloc_tag_error;\n\t}\n\n\tdd->disk = blk_mq_alloc_disk(&dd->tags, dd);\n\tif (IS_ERR(dd->disk)) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Unable to allocate request queue\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto block_queue_alloc_init_error;\n\t}\n\tdd->queue\t\t= dd->disk->queue;\n\n\trv = ida_alloc(&rssd_index_ida, GFP_KERNEL);\n\tif (rv < 0)\n\t\tgoto ida_get_error;\n\tindex = rv;\n\n\trv = rssd_disk_name_format(\"rssd\",\n\t\t\t\tindex,\n\t\t\t\tdd->disk->disk_name,\n\t\t\t\tDISK_NAME_LEN);\n\tif (rv)\n\t\tgoto disk_index_error;\n\n\tdd->disk->major\t\t= dd->major;\n\tdd->disk->first_minor\t= index * MTIP_MAX_MINORS;\n\tdd->disk->minors \t= MTIP_MAX_MINORS;\n\tdd->disk->fops\t\t= &mtip_block_ops;\n\tdd->disk->private_data\t= dd;\n\tdd->index\t\t= index;\n\n\tmtip_hw_debugfs_init(dd);\n\nskip_create_disk:\n\t \n\twait_for_rebuild = mtip_hw_get_identify(dd);\n\tif (wait_for_rebuild < 0) {\n\t\tdev_err(&dd->pdev->dev,\n\t\t\t\"Protocol layer initialization failed\\n\");\n\t\trv = -EINVAL;\n\t\tgoto init_hw_cmds_error;\n\t}\n\n\t \n\tif (wait_for_rebuild == MTIP_FTL_REBUILD_MAGIC)\n\t\tgoto start_service_thread;\n\n\t \n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, dd->queue);\n\tblk_queue_flag_clear(QUEUE_FLAG_ADD_RANDOM, dd->queue);\n\tblk_queue_max_segments(dd->queue, MTIP_MAX_SG);\n\tblk_queue_physical_block_size(dd->queue, 4096);\n\tblk_queue_max_hw_sectors(dd->queue, 0xffff);\n\tblk_queue_max_segment_size(dd->queue, 0x400000);\n\tdma_set_max_seg_size(&dd->pdev->dev, 0x400000);\n\tblk_queue_io_min(dd->queue, 4096);\n\n\t \n\tif (!(mtip_hw_get_capacity(dd, &capacity))) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Could not read drive capacity\\n\");\n\t\trv = -EIO;\n\t\tgoto read_capacity_error;\n\t}\n\tset_capacity(dd->disk, capacity);\n\n\t \n\trv = device_add_disk(&dd->pdev->dev, dd->disk, mtip_disk_attr_groups);\n\tif (rv)\n\t\tgoto read_capacity_error;\n\n\tif (dd->mtip_svc_handler) {\n\t\tset_bit(MTIP_DDF_INIT_DONE_BIT, &dd->dd_flag);\n\t\treturn rv;  \n\t}\n\nstart_service_thread:\n\tdd->mtip_svc_handler = kthread_create_on_node(mtip_service_thread,\n\t\t\t\t\t\tdd, dd->numa_node,\n\t\t\t\t\t\t\"mtip_svc_thd_%02d\", index);\n\n\tif (IS_ERR(dd->mtip_svc_handler)) {\n\t\tdev_err(&dd->pdev->dev, \"service thread failed to start\\n\");\n\t\tdd->mtip_svc_handler = NULL;\n\t\trv = -EFAULT;\n\t\tgoto kthread_run_error;\n\t}\n\twake_up_process(dd->mtip_svc_handler);\n\tif (wait_for_rebuild == MTIP_FTL_REBUILD_MAGIC)\n\t\trv = wait_for_rebuild;\n\n\treturn rv;\n\nkthread_run_error:\n\t \n\tdel_gendisk(dd->disk);\nread_capacity_error:\ninit_hw_cmds_error:\n\tmtip_hw_debugfs_exit(dd);\ndisk_index_error:\n\tida_free(&rssd_index_ida, index);\nida_get_error:\n\tput_disk(dd->disk);\nblock_queue_alloc_init_error:\n\tblk_mq_free_tag_set(&dd->tags);\nblock_queue_alloc_tag_error:\n\tmtip_hw_exit(dd);  \nprotocol_init_error:\n\treturn rv;\n}\n\n \nstatic int mtip_block_shutdown(struct driver_data *dd)\n{\n\tmtip_hw_shutdown(dd);\n\n\tdev_info(&dd->pdev->dev,\n\t\t\"Shutting down %s ...\\n\", dd->disk->disk_name);\n\n\tif (test_bit(MTIP_DDF_INIT_DONE_BIT, &dd->dd_flag))\n\t\tdel_gendisk(dd->disk);\n\n\tblk_mq_free_tag_set(&dd->tags);\n\tput_disk(dd->disk);\n\treturn 0;\n}\n\nstatic int mtip_block_suspend(struct driver_data *dd)\n{\n\tdev_info(&dd->pdev->dev,\n\t\t\"Suspending %s ...\\n\", dd->disk->disk_name);\n\tmtip_hw_suspend(dd);\n\treturn 0;\n}\n\nstatic int mtip_block_resume(struct driver_data *dd)\n{\n\tdev_info(&dd->pdev->dev, \"Resuming %s ...\\n\",\n\t\tdd->disk->disk_name);\n\tmtip_hw_resume(dd);\n\treturn 0;\n}\n\nstatic void drop_cpu(int cpu)\n{\n\tcpu_use[cpu]--;\n}\n\nstatic int get_least_used_cpu_on_node(int node)\n{\n\tint cpu, least_used_cpu, least_cnt;\n\tconst struct cpumask *node_mask;\n\n\tnode_mask = cpumask_of_node(node);\n\tleast_used_cpu = cpumask_first(node_mask);\n\tleast_cnt = cpu_use[least_used_cpu];\n\tcpu = least_used_cpu;\n\n\tfor_each_cpu(cpu, node_mask) {\n\t\tif (cpu_use[cpu] < least_cnt) {\n\t\t\tleast_used_cpu = cpu;\n\t\t\tleast_cnt = cpu_use[cpu];\n\t\t}\n\t}\n\tcpu_use[least_used_cpu]++;\n\treturn least_used_cpu;\n}\n\n \nstatic inline int mtip_get_next_rr_node(void)\n{\n\tstatic int next_node = NUMA_NO_NODE;\n\n\tif (next_node == NUMA_NO_NODE) {\n\t\tnext_node = first_online_node;\n\t\treturn next_node;\n\t}\n\n\tnext_node = next_online_node(next_node);\n\tif (next_node == MAX_NUMNODES)\n\t\tnext_node = first_online_node;\n\treturn next_node;\n}\n\nstatic DEFINE_HANDLER(0);\nstatic DEFINE_HANDLER(1);\nstatic DEFINE_HANDLER(2);\nstatic DEFINE_HANDLER(3);\nstatic DEFINE_HANDLER(4);\nstatic DEFINE_HANDLER(5);\nstatic DEFINE_HANDLER(6);\nstatic DEFINE_HANDLER(7);\n\nstatic void mtip_disable_link_opts(struct driver_data *dd, struct pci_dev *pdev)\n{\n\tunsigned short pcie_dev_ctrl;\n\n\tif (pci_is_pcie(pdev)) {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &pcie_dev_ctrl);\n\t\tif (pcie_dev_ctrl & PCI_EXP_DEVCTL_NOSNOOP_EN ||\n\t\t    pcie_dev_ctrl & PCI_EXP_DEVCTL_RELAX_EN) {\n\t\t\tdev_info(&dd->pdev->dev,\n\t\t\t\t\"Disabling ERO/No-Snoop on bridge device %04x:%04x\\n\",\n\t\t\t\t\tpdev->vendor, pdev->device);\n\t\t\tpcie_dev_ctrl &= ~(PCI_EXP_DEVCTL_NOSNOOP_EN |\n\t\t\t\t\t\tPCI_EXP_DEVCTL_RELAX_EN);\n\t\t\tpcie_capability_write_word(pdev, PCI_EXP_DEVCTL,\n\t\t\t\tpcie_dev_ctrl);\n\t\t}\n\t}\n}\n\nstatic void mtip_fix_ero_nosnoop(struct driver_data *dd, struct pci_dev *pdev)\n{\n\t \n\tif (pdev->bus && pdev->bus->self) {\n\t\tif (pdev->bus->self->vendor == PCI_VENDOR_ID_ATI &&\n\t\t    ((pdev->bus->self->device & 0xff00) == 0x5a00)) {\n\t\t\tmtip_disable_link_opts(dd, pdev->bus->self);\n\t\t} else {\n\t\t\t \n\t\t\tstruct pci_dev *parent_dev = pdev->bus->self;\n\t\t\tif (parent_dev->bus &&\n\t\t\t\tparent_dev->bus->parent &&\n\t\t\t\tparent_dev->bus->parent->self &&\n\t\t\t\tparent_dev->bus->parent->self->vendor ==\n\t\t\t\t\t PCI_VENDOR_ID_ATI &&\n\t\t\t\t(parent_dev->bus->parent->self->device &\n\t\t\t\t\t0xff00) == 0x5a00) {\n\t\t\t\tmtip_disable_link_opts(dd,\n\t\t\t\t\tparent_dev->bus->parent->self);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int mtip_pci_probe(struct pci_dev *pdev,\n\t\t\tconst struct pci_device_id *ent)\n{\n\tint rv = 0;\n\tstruct driver_data *dd = NULL;\n\tchar cpu_list[256];\n\tconst struct cpumask *node_mask;\n\tint cpu, i = 0, j = 0;\n\tint my_node = NUMA_NO_NODE;\n\n\t \n\tmy_node = pcibus_to_node(pdev->bus);\n\tif (my_node != NUMA_NO_NODE) {\n\t\tif (!node_online(my_node))\n\t\t\tmy_node = mtip_get_next_rr_node();\n\t} else {\n\t\tdev_info(&pdev->dev, \"Kernel not reporting proximity, choosing a node\\n\");\n\t\tmy_node = mtip_get_next_rr_node();\n\t}\n\tdev_info(&pdev->dev, \"NUMA node %d (closest: %d,%d, probe on %d:%d)\\n\",\n\t\tmy_node, pcibus_to_node(pdev->bus), dev_to_node(&pdev->dev),\n\t\tcpu_to_node(raw_smp_processor_id()), raw_smp_processor_id());\n\n\tdd = kzalloc_node(sizeof(struct driver_data), GFP_KERNEL, my_node);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\t \n\tpci_set_drvdata(pdev, dd);\n\n\trv = pcim_enable_device(pdev);\n\tif (rv < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to enable device\\n\");\n\t\tgoto iomap_err;\n\t}\n\n\t \n\trv = pcim_iomap_regions(pdev, 1 << MTIP_ABAR, MTIP_DRV_NAME);\n\tif (rv < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to map regions\\n\");\n\t\tgoto iomap_err;\n\t}\n\n\trv = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rv) {\n\t\tdev_warn(&pdev->dev, \"64-bit DMA enable failed\\n\");\n\t\tgoto setmask_err;\n\t}\n\n\t \n\tdd->major\t= mtip_major;\n\tdd->instance\t= instance;\n\tdd->pdev\t= pdev;\n\tdd->numa_node\t= my_node;\n\n\tmemset(dd->workq_name, 0, 32);\n\tsnprintf(dd->workq_name, 31, \"mtipq%d\", dd->instance);\n\n\tdd->isr_workq = create_workqueue(dd->workq_name);\n\tif (!dd->isr_workq) {\n\t\tdev_warn(&pdev->dev, \"Can't create wq %d\\n\", dd->instance);\n\t\trv = -ENOMEM;\n\t\tgoto setmask_err;\n\t}\n\n\tmemset(cpu_list, 0, sizeof(cpu_list));\n\n\tnode_mask = cpumask_of_node(dd->numa_node);\n\tif (!cpumask_empty(node_mask)) {\n\t\tfor_each_cpu(cpu, node_mask)\n\t\t{\n\t\t\tsnprintf(&cpu_list[j], 256 - j, \"%d \", cpu);\n\t\t\tj = strlen(cpu_list);\n\t\t}\n\n\t\tdev_info(&pdev->dev, \"Node %d on package %d has %d cpu(s): %s\\n\",\n\t\t\tdd->numa_node,\n\t\t\ttopology_physical_package_id(cpumask_first(node_mask)),\n\t\t\tnr_cpus_node(dd->numa_node),\n\t\t\tcpu_list);\n\t} else\n\t\tdev_dbg(&pdev->dev, \"mtip32xx: node_mask empty\\n\");\n\n\tdd->isr_binding = get_least_used_cpu_on_node(dd->numa_node);\n\tdev_info(&pdev->dev, \"Initial IRQ binding node:cpu %d:%d\\n\",\n\t\tcpu_to_node(dd->isr_binding), dd->isr_binding);\n\n\t \n\tdd->work[0].cpu_binding = dd->isr_binding;\n\tdd->work[1].cpu_binding = get_least_used_cpu_on_node(dd->numa_node);\n\tdd->work[2].cpu_binding = get_least_used_cpu_on_node(dd->numa_node);\n\tdd->work[3].cpu_binding = dd->work[0].cpu_binding;\n\tdd->work[4].cpu_binding = dd->work[1].cpu_binding;\n\tdd->work[5].cpu_binding = dd->work[2].cpu_binding;\n\tdd->work[6].cpu_binding = dd->work[2].cpu_binding;\n\tdd->work[7].cpu_binding = dd->work[1].cpu_binding;\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\tmemset(cpu_list, 0, sizeof(cpu_list));\n\t\tfor (i = 0, j = 0; i < MTIP_MAX_SLOT_GROUPS; i++) {\n\t\t\tif (dd->work[i].cpu_binding == cpu) {\n\t\t\t\tsnprintf(&cpu_list[j], 256 - j, \"%d \", i);\n\t\t\t\tj = strlen(cpu_list);\n\t\t\t}\n\t\t}\n\t\tif (j)\n\t\t\tdev_info(&pdev->dev, \"CPU %d: WQs %s\\n\", cpu, cpu_list);\n\t}\n\n\tINIT_WORK(&dd->work[0].work, mtip_workq_sdbf0);\n\tINIT_WORK(&dd->work[1].work, mtip_workq_sdbf1);\n\tINIT_WORK(&dd->work[2].work, mtip_workq_sdbf2);\n\tINIT_WORK(&dd->work[3].work, mtip_workq_sdbf3);\n\tINIT_WORK(&dd->work[4].work, mtip_workq_sdbf4);\n\tINIT_WORK(&dd->work[5].work, mtip_workq_sdbf5);\n\tINIT_WORK(&dd->work[6].work, mtip_workq_sdbf6);\n\tINIT_WORK(&dd->work[7].work, mtip_workq_sdbf7);\n\n\tpci_set_master(pdev);\n\trv = pci_enable_msi(pdev);\n\tif (rv) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"Unable to enable MSI interrupt.\\n\");\n\t\tgoto msi_initialize_err;\n\t}\n\n\tmtip_fix_ero_nosnoop(dd, pdev);\n\n\t \n\trv = mtip_block_initialize(dd);\n\tif (rv < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to initialize block layer\\n\");\n\t\tgoto block_initialize_err;\n\t}\n\n\t \n\tinstance++;\n\tif (rv != MTIP_FTL_REBUILD_MAGIC)\n\t\tset_bit(MTIP_DDF_INIT_DONE_BIT, &dd->dd_flag);\n\telse\n\t\trv = 0;  \n\n\tgoto done;\n\nblock_initialize_err:\n\tpci_disable_msi(pdev);\n\nmsi_initialize_err:\n\tif (dd->isr_workq) {\n\t\tdestroy_workqueue(dd->isr_workq);\n\t\tdrop_cpu(dd->work[0].cpu_binding);\n\t\tdrop_cpu(dd->work[1].cpu_binding);\n\t\tdrop_cpu(dd->work[2].cpu_binding);\n\t}\nsetmask_err:\n\tpcim_iounmap_regions(pdev, 1 << MTIP_ABAR);\n\niomap_err:\n\tkfree(dd);\n\tpci_set_drvdata(pdev, NULL);\n\treturn rv;\ndone:\n\treturn rv;\n}\n\n \nstatic void mtip_pci_remove(struct pci_dev *pdev)\n{\n\tstruct driver_data *dd = pci_get_drvdata(pdev);\n\tunsigned long to;\n\n\tmtip_check_surprise_removal(dd);\n\tsynchronize_irq(dd->pdev->irq);\n\n\t \n\tto = jiffies + msecs_to_jiffies(4000);\n\tdo {\n\t\tmsleep(20);\n\t} while (atomic_read(&dd->irq_workers_active) != 0 &&\n\t\ttime_before(jiffies, to));\n\n\tif (atomic_read(&dd->irq_workers_active) != 0) {\n\t\tdev_warn(&dd->pdev->dev,\n\t\t\t\"Completion workers still active!\\n\");\n\t}\n\n\tset_bit(MTIP_DDF_REMOVE_PENDING_BIT, &dd->dd_flag);\n\n\tif (test_bit(MTIP_DDF_INIT_DONE_BIT, &dd->dd_flag))\n\t\tdel_gendisk(dd->disk);\n\n\tmtip_hw_debugfs_exit(dd);\n\n\tif (dd->mtip_svc_handler) {\n\t\tset_bit(MTIP_PF_SVC_THD_STOP_BIT, &dd->port->flags);\n\t\twake_up_interruptible(&dd->port->svc_wait);\n\t\tkthread_stop(dd->mtip_svc_handler);\n\t}\n\n\tif (!dd->sr) {\n\t\t \n\t\tif (!mtip_quiesce_io(dd->port, MTIP_QUIESCE_IO_TIMEOUT_MS))\n\t\t\tmtip_standby_drive(dd);\n\t}\n\telse\n\t\tdev_info(&dd->pdev->dev, \"device %s surprise removal\\n\",\n\t\t\t\t\t\tdd->disk->disk_name);\n\n\tblk_mq_free_tag_set(&dd->tags);\n\n\t \n\tmtip_hw_exit(dd);\n\n\tif (dd->isr_workq) {\n\t\tdestroy_workqueue(dd->isr_workq);\n\t\tdrop_cpu(dd->work[0].cpu_binding);\n\t\tdrop_cpu(dd->work[1].cpu_binding);\n\t\tdrop_cpu(dd->work[2].cpu_binding);\n\t}\n\n\tpci_disable_msi(pdev);\n\n\tpcim_iounmap_regions(pdev, 1 << MTIP_ABAR);\n\tpci_set_drvdata(pdev, NULL);\n\n\tput_disk(dd->disk);\n}\n\n \nstatic int __maybe_unused mtip_pci_suspend(struct device *dev)\n{\n\tint rv = 0;\n\tstruct driver_data *dd = dev_get_drvdata(dev);\n\n\tset_bit(MTIP_DDF_RESUME_BIT, &dd->dd_flag);\n\n\t \n\trv = mtip_block_suspend(dd);\n\tif (rv < 0)\n\t\tdev_err(dev, \"Failed to suspend controller\\n\");\n\n\treturn rv;\n}\n\n \nstatic int __maybe_unused mtip_pci_resume(struct device *dev)\n{\n\tint rv = 0;\n\tstruct driver_data *dd = dev_get_drvdata(dev);\n\n\t \n\trv = mtip_block_resume(dd);\n\tif (rv < 0)\n\t\tdev_err(dev, \"Unable to resume\\n\");\n\n\tclear_bit(MTIP_DDF_RESUME_BIT, &dd->dd_flag);\n\n\treturn rv;\n}\n\n \nstatic void mtip_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct driver_data *dd = pci_get_drvdata(pdev);\n\tif (dd)\n\t\tmtip_block_shutdown(dd);\n}\n\n \nstatic const struct pci_device_id mtip_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P320H_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P320M_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P320S_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P325M_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P420H_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P420M_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICRON, P425M_DEVICE_ID) },\n\t{ 0 }\n};\n\nstatic SIMPLE_DEV_PM_OPS(mtip_pci_pm_ops, mtip_pci_suspend, mtip_pci_resume);\n\n \nstatic struct pci_driver mtip_pci_driver = {\n\t.name\t\t\t= MTIP_DRV_NAME,\n\t.id_table\t\t= mtip_pci_tbl,\n\t.probe\t\t\t= mtip_pci_probe,\n\t.remove\t\t\t= mtip_pci_remove,\n\t.driver.pm\t\t= &mtip_pci_pm_ops,\n\t.shutdown\t\t= mtip_pci_shutdown,\n};\n\nMODULE_DEVICE_TABLE(pci, mtip_pci_tbl);\n\n \nstatic int __init mtip_init(void)\n{\n\tint error;\n\n\tpr_info(MTIP_DRV_NAME \" Version \" MTIP_DRV_VERSION \"\\n\");\n\n\t \n\terror = register_blkdev(0, MTIP_DRV_NAME);\n\tif (error <= 0) {\n\t\tpr_err(\"Unable to register block device (%d)\\n\",\n\t\terror);\n\t\treturn -EBUSY;\n\t}\n\tmtip_major = error;\n\n\tdfs_parent = debugfs_create_dir(\"rssd\", NULL);\n\tif (IS_ERR_OR_NULL(dfs_parent)) {\n\t\tpr_warn(\"Error creating debugfs parent\\n\");\n\t\tdfs_parent = NULL;\n\t}\n\n\t \n\terror = pci_register_driver(&mtip_pci_driver);\n\tif (error) {\n\t\tdebugfs_remove(dfs_parent);\n\t\tunregister_blkdev(mtip_major, MTIP_DRV_NAME);\n\t}\n\n\treturn error;\n}\n\n \nstatic void __exit mtip_exit(void)\n{\n\t \n\tunregister_blkdev(mtip_major, MTIP_DRV_NAME);\n\n\t \n\tpci_unregister_driver(&mtip_pci_driver);\n\n\tdebugfs_remove_recursive(dfs_parent);\n}\n\nMODULE_AUTHOR(\"Micron Technology, Inc\");\nMODULE_DESCRIPTION(\"Micron RealSSD PCIe Block Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MTIP_DRV_VERSION);\n\nmodule_init(mtip_init);\nmodule_exit(mtip_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}