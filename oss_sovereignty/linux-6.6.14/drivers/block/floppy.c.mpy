{
  "module_name": "floppy.c",
  "hash_id": "02cd4e08a1ed47124fe39c6d7b1b900be1e0c762bc1701b29b497c52eb0e8ccc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/floppy.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t \n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n \nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t \n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n \nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n \n\nstatic int use_virtual_dma;\n \n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t \n\n \n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t \n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n \n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size)  \n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t \n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t \n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n \n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t \n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t \n\t \n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n \n#define COMMAND\t\t\t0\n#define DR_SELECT\t\t1\n#define TRACK\t\t\t2\n#define HEAD\t\t\t3\n#define SECTOR\t\t\t4\n#define SIZECODE\t\t5\n#define SECT_PER_TRACK\t\t6\n#define GAP\t\t\t7\n#define SIZECODE2\t\t8\n#define NR_RW 9\n\n \n#define F_SIZECODE\t\t2\n#define F_SECT_PER_TRACK\t3\n#define F_GAP\t\t\t4\n#define F_FILL\t\t\t5\n#define NR_F 6\n\n \n#define MAX_DISK_SIZE 4\t\t \n\n \nstatic unsigned char reply_buffer[FD_RAW_REPLY_SIZE];\nstatic int inr;\t\t \n#define ST0\t\t0\n#define ST1\t\t1\n#define ST2\t\t2\n#define ST3\t\t0\t \n#define R_TRACK\t\t3\n#define R_HEAD\t\t4\n#define R_SECTOR\t5\n#define R_SIZECODE\t6\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n \nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t \n} default_drive_params[] = {\n \n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" },  \n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" },  \n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" },  \n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" },  \n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" },  \n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" }  \n \n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct gendisk *opened_disk[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n \n \nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t \n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  },  \n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t \n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t \n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t \n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t \n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t \n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t \n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t \n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t \n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" },  \n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" },  \n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t \n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t \n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t \n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t \n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t \n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t \n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t \n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" },  \n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  },  \n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" },  \n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" },  \n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" },  \n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" },  \n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" },  \n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" },  \n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" },  \n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" },  \n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" },  \n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t \n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" },  \n};\n\nstatic struct gendisk *disks[N_DRIVE][ARRAY_SIZE(floppy_type)];\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n \nstatic struct floppy_struct *current_type[N_DRIVE];\n\n \nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n \nstatic int probing;\n\n \n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n \nstatic int floppy_errors;\n\n \nstatic struct format_descr format_req;\n\n \n\n \nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t \n\tvoid (*redo)(void);\t \n\tvoid (*error)(void);\t \n\tdone_f done;\t\t \n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n \nstatic void reset_fdc(void);\nstatic int floppy_revalidate(struct gendisk *disk);\n\n \n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n \nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n \nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int current_fdc;\t\t\t \n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t \nstatic unsigned char in_sector_offset;\t \n\nstatic inline unsigned char fdc_inb(int fdc, int reg)\n{\n\treturn fd_inb(fdc_state[fdc].address, reg);\n}\n\nstatic inline void fdc_outb(unsigned char value, int fdc, int reg)\n{\n\tfd_outb(value, fdc_state[fdc].address, reg);\n}\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(drive_state[drive].fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n \n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (drive_params[current_drive].flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif  \n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t \n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = drive_params[drive].timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (drive_params[drive].flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n \n\n \n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, drive_state[drive].select_date + drive_params[drive].select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))) ||\n\t    (fdc_state[fdc].dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)fdc_state[fdc].dor);\n\t}\n\n\tdebug_dcl(drive_params[drive].flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(drive_params[drive].flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(drive_params[drive].flags, \"disk change line=%x\\n\",\n\t\t  fdc_inb(fdc, FD_DIR) & 0x80);\n\tdebug_dcl(drive_params[drive].flags, \"flags=%lx\\n\",\n\t\t  drive_state[drive].flags);\n\n\tif (drive_params[drive].flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\tif ((fdc_inb(fdc, FD_DIR) ^ drive_params[drive].flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\t\t\t\t \n\n\t\tif (drive_state[drive].maxblock)\t \n\t\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\n\t\t \n\t\tif (drive_state[drive].keep_data >= 0) {\n\t\t\tif ((drive_params[drive].flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tdrive_state[drive].last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (fdc_state[fdc].address == -1)\n\t\treturn -1;\n\n\tolddor = fdc_state[fdc].dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tfdc_state[fdc].dor = newdor;\n\t\tfdc_outb(newdor, fdc, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdrive_state[drive].select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(int fdc, int drive)\n{\n\tif (drive_params[drive].select_delay)\n\t\treturn;\n\tfdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(drive)),\n\t\t fdc, FD_DOR);\n\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\tdrive_state[drive].select_date = jiffies;\n}\n\n \nstatic void reset_fdc_info(int fdc, int mode)\n{\n\tint drive;\n\n\tfdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;\n\tfdc_state[fdc].need_configure = 1;\n\tfdc_state[fdc].perp_mode = 1;\n\tfdc_state[fdc].rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc &&\n\t\t    (mode || drive_state[drive].track != NEED_1_RECAL))\n\t\t\tdrive_state[drive].track = NEED_2_RECAL;\n}\n\n \nstatic void set_fdc(int drive)\n{\n\tunsigned int fdc;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tpr_info(\"bad drive value %d\\n\", drive);\n\t\treturn;\n\t}\n\n\tfdc = FDC(drive);\n\tif (fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (fdc_state[fdc].rawcmd == 2)\n\t\treset_fdc_info(fdc, 1);\n\tif (fdc_inb(fdc, FD_STATUS) != STATUS_READY)\n\t\tfdc_state[fdc].reset = 1;\n\n\tcurrent_drive = drive;\n\tcurrent_fdc = fdc;\n}\n\n \nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n \nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n \nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n \nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t \n\tif (drive_params[drive].rps) {\n\t\tdelta = jiffies - drive_state[drive].first_read_date + HZ -\n\t\t    drive_params[drive].spindown_offset;\n\t\tdelta = ((delta * drive_params[drive].rps) % HZ) / drive_params[drive].rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + drive_params[drive].spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n \nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (drive_params[current_drive].select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)\n\t\t\tcontinue;\t \n\t\tset_fdc(drive);\n\t\tif (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t \n\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n \nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n \nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\t \n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tprint_hex_dump(KERN_INFO, \"zero dma transfer size: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       raw_cmd->fullcmd, raw_cmd->cmd_count, false);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE,\n\t\t\t fdc_state[current_fdc].address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = fdc_state[current_fdc].address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(int fdc);\n\n \nstatic int wait_til_ready(int fdc)\n{\n\tint status;\n\tint counter;\n\n\tif (fdc_state[fdc].reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fdc_inb(fdc, FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n \nstatic int output_byte(int fdc, char byte)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfdc_outb(byte, fdc, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tfdc_state[fdc].reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy(fdc);\n\t}\n\treturn -1;\n}\n\n \nstatic int result(int fdc)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < FD_RAW_REPLY_SIZE; i++) {\n\t\tstatus = wait_til_ready(fdc);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fdc_inb(fdc, FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n \nstatic int need_more_output(int fdc)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result(fdc);\n}\n\n \nstatic void perpendicular_mode(int fdc)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\t\t\t \n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (fdc_state[fdc].perp_mode == perp_mode)\n\t\treturn;\n\tif (fdc_state[fdc].version >= FDC_82077_ORIG) {\n\t\toutput_byte(fdc, FD_PERPENDICULAR);\n\t\toutput_byte(fdc, perp_mode);\n\t\tfdc_state[fdc].perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t \n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(int fdc)\n{\n\t \n\toutput_byte(fdc, FD_CONFIGURE);\n\tif (need_more_output(fdc) != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(fdc, 0);\n\toutput_byte(fdc, 0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(fdc, 0);     \n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n \nstatic void fdc_specify(int fdc, int drive)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (fdc_state[fdc].need_configure &&\n\t    fdc_state[fdc].version >= FDC_82072A) {\n\t\tfdc_configure(fdc);\n\t\tfdc_state[fdc].need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (fdc_state[fdc].version >= FDC_82078) {\n\t\t\t \n\t\t\toutput_byte(fdc, FD_DRIVESPEC);\n\t\t\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\t\t\toutput_byte(fdc, UNIT(drive));\n\t\t\t\toutput_byte(fdc, 0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (fdc_state[fdc].version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t \n\t\thut_max_code = 0x0;\t \n\t}\n\n\t \n\tsrt = 16 - DIV_ROUND_UP(drive_params[drive].srt * scale_dtr / 1000,\n\t\t\t\tNOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(drive_params[drive].hlt * scale_dtr / 2,\n\t\t\t   NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(drive_params[drive].hut * scale_dtr / 16,\n\t\t\t   NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t \n\tif (fdc_state[fdc].spec1 != spec1 ||\n\t    fdc_state[fdc].spec2 != spec2) {\n\t\t \n\t\toutput_byte(fdc, FD_SPECIFY);\n\t\toutput_byte(fdc, fdc_state[fdc].spec1 = spec1);\n\t\toutput_byte(fdc, fdc_state[fdc].spec2 = spec2);\n\t}\n}\t\t\t\t \n\n \nstatic int fdc_dtr(void)\n{\n\t \n\tif ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)\n\t\treturn 0;\n\n\t \n\tfdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);\n\n\t \n\tfdc_state[current_fdc].dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t \n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\treply_buffer[R_TRACK], reply_buffer[R_HEAD],\n\t\treply_buffer[R_SECTOR],\n\t\treply_buffer[R_SIZECODE]);\n}\t\t\t\t \n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (reply_buffer[ST0] & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (reply_buffer[ST2] & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (reply_buffer[ST1] & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((reply_buffer[ST1] & (ST1_MAM | ST1_ND)) ||\n\t\t   (reply_buffer[ST2] & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (reply_buffer[ST2] & ST2_WC) {\t \n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (reply_buffer[ST2] & ST2_BC) {\t \n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\treply_buffer[ST0], reply_buffer[ST1],\n\t\t\treply_buffer[ST2]);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n \nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tswitch (reply_buffer[ST0] & ST0_INTR) {\n\tcase 0x40:\t\t \n\t\tif (reply_buffer[ST1] & ST1_EOC)\n\t\t\treturn 0;\t \n\t\tbad = 1;\n\t\tif (reply_buffer[ST1] & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (reply_buffer[ST1] & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t\t&drive_state[current_drive].flags);\n\t\t} else if (reply_buffer[ST1] & ST1_OR) {\n\t\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (floppy_errors >= drive_params[current_drive].max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (reply_buffer[ST2] & ST2_WC || reply_buffer[ST2] & ST2_BC)\n\t\t\t \n\t\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t \n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t \n\t\treturn 0;\n\t}\n}\n\n \nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;\n\t\t \n\t\tif (time_after(ready_date, jiffies + drive_params[current_drive].select_delay)) {\n\t\t\tready_date -= drive_params[current_drive].select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t \n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(current_fdc, raw_cmd->fullcmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result(current_fdc);\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n \nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (reply_buffer[ST0] & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track >= 0 &&\n\t    drive_state[current_drive].track != reply_buffer[ST1] &&\n\t    !blind_seek) {\n\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(drive_params[current_drive].flags, \"jiffies=%lu\\n\",\n\t\t\t  jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t  &drive_state[current_drive].flags);\n\t\t\t\t\t \n\t\tdrive_state[current_drive].select_date = jiffies;\n\t}\n\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void check_wp(int fdc, int drive)\n{\n\tif (test_bit(FD_VERIFY_BIT, &drive_state[drive].flags)) {\n\t\t\t\t\t \n\t\toutput_byte(fdc, FD_GETSTATUS);\n\t\toutput_byte(fdc, UNIT(drive));\n\t\tif (result(fdc) != 1) {\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t  &drive_state[drive].flags);\n\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(drive_params[drive].flags, \"wp=%x\\n\",\n\t\t\t  reply_buffer[ST3] & 0x40);\n\t\tif (!(reply_buffer[ST3] & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t \n\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t&drive_state[current_drive].flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (drive_state[current_drive].track <= NO_TRACK || drive_state[current_drive].track == raw_cmd->track)) {\n\t\t \n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp(current_fdc, current_drive);\n\t\tif (raw_cmd->track != drive_state[current_drive].track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(current_fdc, FD_SEEK);\n\toutput_byte(current_fdc, UNIT(current_drive));\n\tif (output_byte(current_fdc, track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (reply_buffer[ST0] & ST0_ECE) {\n\t\tswitch (drive_state[current_drive].track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t \n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t \n\t\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tdrive_state[current_drive].select_date = jiffies;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t \n\t\t\tdrive_state[current_drive].track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n \nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {\n\t\t \n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", current_fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tfdc_state[current_fdc].reset = 0;\n\t \n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result(current_fdc);\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(current_fdc, FD_SENSEI);\n\t\t\tinr = result(current_fdc);\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((reply_buffer[ST0] & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(current_fdc, FD_RECALIBRATE);\n\tif (output_byte(current_fdc, UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n \nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult(current_fdc);\t\t \n\tif (fdc_state[current_fdc].reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t \n\t}\n\tcont->redo();\n}\n\n \nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tfdc_state[current_fdc].reset = 0;\n\treset_fdc_info(current_fdc, 0);\n\n\t \n\t \n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (fdc_state[current_fdc].version >= FDC_82072A)\n\t\tfdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3),\n\t\t\t current_fdc, FD_STATUS);\n\telse {\n\t\tfdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(int fdc)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fdc_inb(fdc, FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy(current_fdc);\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t \n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tfdc_state[current_fdc].reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t \n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n \nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t \n\t\t\tdrive_state[current_drive].first_read_date = 0;\n\t\t\t \n\t\t\tdrive_state[current_drive].spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t \n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(current_fdc, mask, data);\n\n\t \n\treturn fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !drive_params[current_drive].select_delay)\n\t\ttwaddle(current_fdc, current_drive);\t \n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode(current_fdc);\n\t\tfdc_specify(current_fdc, current_drive);  \n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify(current_fdc, current_drive);\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_drive, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\tfloppy_ready();\n}\n\n \n \n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\n \nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n \n\nstatic int next_valid_format(int drive)\n{\n\tint probed_format;\n\n\tprobed_format = drive_state[drive].probed_format;\n\twhile (1) {\n\t\tif (probed_format >= FD_AUTODETECT_SIZE ||\n\t\t    !drive_params[drive].autodetect[probed_format]) {\n\t\t\tdrive_state[drive].probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[drive_params[drive].autodetect[probed_format]].sect) {\n\t\t\tdrive_state[drive].probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tdrive_state[current_drive].probed_format++;\n\t\tif (!next_valid_format(current_drive))\n\t\t\treturn;\n\t}\n\terr_count = ++floppy_errors;\n\tINFBOUND(write_errors[current_drive].badness, err_count);\n\tif (err_count > drive_params[current_drive].max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > drive_params[current_drive].max_errors.reset)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (err_count > drive_params[current_drive].max_errors.recal)\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(drive_state[drive].fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n \nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\traw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];\n\traw_cmd->cmd[F_GAP] = _floppy->fmt_gap;\n\traw_cmd->cmd[F_FILL] = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\tif (!raw_cmd->cmd[F_SECT_PER_TRACK])\n\t\treturn;\n\n\t \n\thead_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;\n\n\t \n\ttrack_shift = 2 * head_shift + 3;\n\n\t \n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\t \n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t \n\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = raw_cmd->cmd[F_SIZECODE];\n\t}\n\t \n\tfor (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\tif (here[n].sect) {\t \n\t\t\t++n;\n\t\t\tif (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {\n\t\t\t\tn -= raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > drive_params[current_drive].tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tcont = &format_cont;\n\tfloppy_errors = 0;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n \n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->q->disk->private_data;\n\n\t \n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t \n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n \nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t \n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(drive_state[current_drive].maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tdrive_state[current_drive].maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t \n\t\t\twrite_errors[current_drive].write_errors++;\n\t\t\tif (write_errors[current_drive].write_errors == 1) {\n\t\t\t\twrite_errors[current_drive].first_error_sector = blk_rq_pos(req);\n\t\t\t\twrite_errors[current_drive].first_error_generation = drive_state[current_drive].generation;\n\t\t\t}\n\t\t\twrite_errors[current_drive].last_error_sector = blk_rq_pos(req);\n\t\t\twrite_errors[current_drive].last_error_generation = drive_state[current_drive].generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n \nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (reply_buffer[R_HEAD] >= 2) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!drive_state[current_drive].first_read_date)\n\t\tdrive_state[current_drive].first_read_date = jiffies;\n\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\n\tif (reply_buffer[ST1] & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (raw_cmd->cmd[COMMAND] & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((reply_buffer[R_TRACK] - raw_cmd->cmd[TRACK]) * heads +\n\t\t       reply_buffer[R_HEAD] - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] +\n\t\t      reply_buffer[R_SECTOR] - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", reply_buffer[R_SECTOR],\n\t\t\traw_cmd->cmd[SECTOR]);\n\t\tpr_info(\"rh=%d h=%d\\n\", reply_buffer[R_HEAD],\n\t\t\traw_cmd->cmd[HEAD]);\n\t\tpr_info(\"rt=%d t=%d\\n\", reply_buffer[R_TRACK],\n\t\t\traw_cmd->cmd[TRACK]);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\traw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) != FD_READ) {\n\t\t \n\t\tcont->done(1);\n\t} else {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n \nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t \n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t \n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n \nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t \n\tstruct bio_vec bv;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tmemcpy_to_bvec(&bv, dma_buffer);\n\t\telse\n\t\t\tmemcpy_from_bvec(dma_buffer, &bv);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n \nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\traw_cmd->cmd[COMMAND] &= ~0x80;\t \n\n\t\thard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);\n\t\tend_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;\n\t\tif (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, raw_cmd->cmd[SECT_PER_TRACK]);\n\t\t\treturn;\n\t\t}\n\t\traw_cmd->cmd[SECT_PER_TRACK] = end_sector;\n\t\t\t\t\t \n\t}\n}\n\n \n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->q->disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\traw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\traw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t \n\tif ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\traw_cmd->cmd[SIZECODE] = 2;\n\t} else\n\t\traw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) &&\n\t    (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (raw_cmd->cmd[SIZECODE])\n\t\traw_cmd->cmd[SIZECODE2] = 0xff;\n\telse\n\t\traw_cmd->cmd[SIZECODE2] = 0x80;\n\traw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);\n\traw_cmd->cmd[GAP] = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\traw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];\n\traw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) +\n\t    FD_SECTBASE(_floppy);\n\n\t \n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\traw_cmd->cmd[SECTOR]--;\n\n\t\t \n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\traw_cmd->cmd[SIZECODE]--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\traw_cmd->cmd[SECTOR]++;\n\t\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;\n\t} else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t \n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t \n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\tmax_size = max_sector;\t \n\n\t \n\tif (buffer_track != raw_cmd->track ||\t \n\t    buffer_drive != current_drive ||\t \n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(raw_cmd->cmd[COMMAND]) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t \n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t \n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t \n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t       floppy_track_buffer) >> 9),\n\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, raw_cmd->cmd[SIZECODE]);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\traw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR],\n\t\t\traw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t    current_count_sectors < 0 ||\n\t    raw_cmd->length < 0 ||\n\t    raw_cmd->kernel_data + raw_cmd->length >\n\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\tcurrent_count_sectors);\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tpr_info(\"read\\n\");\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\tpr_info(\"write\\n\");\n\t\treturn 0;\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tfloppy_errors = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->q->disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_drive, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t \n\t\tif (!probing) {\n\t\t\tdrive_state[current_drive].probed_format = 0;\n\t\t\tif (next_valid_format(current_drive)) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];\n\t} else\n\t\tprobing = 0;\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags))\n\t\ttwaddle(current_fdc, current_drive);\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\n \nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (__force unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t \n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t \n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n \n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\n \nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tfdc_state[current_fdc].reset = 1;\n\tif (fdc_state[current_fdc].reset) {\n\t\t \n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n \nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (drive_params[drive].native_format)\n\t\t\tfloppy = floppy_type + drive_params[drive].native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n#ifdef CONFIG_BLK_DEV_FD_RAWCMD\n\n \nstatic void raw_cmd_done(int flag)\n{\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > FD_RAW_REPLY_SIZE)\n\t\t\traw_cmd->reply_count = 0;\n\t\tmemcpy(raw_cmd->reply, reply_buffer, raw_cmd->reply_count);\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\n#define MAX_LEN (1UL << MAX_ORDER << PAGE_SHIFT)\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > FD_RAW_CMD_FULLSIZE)\n\t\treturn -EINVAL;\n\n\tmemset(ptr->reply, 0, FD_RAW_REPLY_SIZE);\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0 || ptr->length > MAX_LEN)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (fdc_state[current_fdc].rawcmd <= 1)\n\t\tfdc_state[current_fdc].rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != current_fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (drive_state[drive].fd_ref > 1) {\n\t\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (drive_state[drive].fd_ref) {\n\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && fdc_state[current_fdc].reset)\n\t\tret = -EIO;\n\n\tdrive_state[current_drive].track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n#else  \n\nstatic int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#endif\n\nstatic int invalidate_drive(struct gendisk *disk)\n{\n\t \n\tset_bit((long)disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tif (disk_check_media_change(disk))\n\t\tfloppy_revalidate(disk);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t \n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t     \n\t    (int)(g->sect * g->head) <= 0 ||\n\t     \n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > drive_params[drive].tracks >> STRETCH(g) ||\n\t     \n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct gendisk *disk = opened_disk[cnt];\n\n\t\t\tif (!disk || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\tdisk_force_media_change(disk);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t \n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tdrive_state[current_drive].keep_data = -1;\n\t\telse\n\t\t\tdrive_state[current_drive].keep_data = 1;\n\t\t \n\t\tif (drive_state[current_drive].maxblock > user_params[drive].sect ||\n\t\t    drive_state[current_drive].maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev->bd_disk);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic bool valid_floppy_drive_params(const short autodetect[FD_AUTODETECT_SIZE],\n\t\tint native_format)\n{\n\tsize_t floppy_type_size = ARRAY_SIZE(floppy_type);\n\tsize_t i = 0;\n\n\tfor (i = 0; i < FD_AUTODETECT_SIZE; ++i) {\n\t\tif (autodetect[i] < 0 ||\n\t\t    autodetect[i] >= floppy_type_size)\n\t\t\treturn false;\n\t}\n\n\tif (native_format < 0 || native_format >= floppy_type_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t \n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t \n\tconst void *outparam;\t \n\n\t \n\tif (cmd == CDROMEJECT ||\t \n\t    cmd == 0x6470) {\t\t \n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t \n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (((cmd & 0x40) &&\n\t     !(mode & (BLK_OPEN_WRITE | BLK_OPEN_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t \n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\t \n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t \n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tdrive_state[drive].keep_data = 0;\n\t\treturn invalidate_drive(bdev->bd_disk);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tdrive_params[drive].flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tdrive_params[drive].flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = drive_state[drive].flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev->bd_disk);\n\tcase FDSETEMSGTRESH:\n\t\tdrive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &drive_params[drive].max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tdrive_params[drive].max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\tif (!valid_floppy_drive_params(inparam.dp.autodetect,\n\t\t\t\tinparam.dp.native_format))\n\t\t\treturn -EINVAL;\n\t\tdrive_params[drive] = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = &drive_params[drive];\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\tfallthrough;\n\tcase FDGETDRVSTAT:\n\t\toutparam = &drive_state[drive];\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = &fdc_state[FDC(drive)];\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = &write_errors[drive];\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\treturn floppy_raw_cmd_ioctl(type, drive, cmd, (void __user *)param);\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle(current_fdc, current_drive);\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[FD_AUTODETECT_SIZE];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (BLK_OPEN_WRITE | BLK_OPEN_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(drive_state[drive].fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(drive_state[drive].fd_device),\n\t\t\t\t  &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tif (!valid_floppy_drive_params(v.autodetect, v.native_format))\n\t\treturn -EINVAL;\n\tmutex_lock(&floppy_mutex);\n\tdrive_params[drive].cmos = v.cmos;\n\tdrive_params[drive].max_dtr = v.max_dtr;\n\tdrive_params[drive].hlt = v.hlt;\n\tdrive_params[drive].hut = v.hut;\n\tdrive_params[drive].srt = v.srt;\n\tdrive_params[drive].spinup = v.spinup;\n\tdrive_params[drive].spindown = v.spindown;\n\tdrive_params[drive].spindown_offset = v.spindown_offset;\n\tdrive_params[drive].select_delay = v.select_delay;\n\tdrive_params[drive].rps = v.rps;\n\tdrive_params[drive].tracks = v.tracks;\n\tdrive_params[drive].timeout = v.timeout;\n\tdrive_params[drive].interleave_sect = v.interleave_sect;\n\tdrive_params[drive].max_errors = v.max_errors;\n\tdrive_params[drive].flags = v.flags;\n\tdrive_params[drive].read_track = v.read_track;\n\tmemcpy(drive_params[drive].autodetect, v.autodetect,\n\t       sizeof(v.autodetect));\n\tdrive_params[drive].checkfreq = v.checkfreq;\n\tdrive_params[drive].native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = drive_params[drive].cmos;\n\tv.max_dtr = drive_params[drive].max_dtr;\n\tv.hlt = drive_params[drive].hlt;\n\tv.hut = drive_params[drive].hut;\n\tv.srt = drive_params[drive].srt;\n\tv.spinup = drive_params[drive].spinup;\n\tv.spindown = drive_params[drive].spindown;\n\tv.spindown_offset = drive_params[drive].spindown_offset;\n\tv.select_delay = drive_params[drive].select_delay;\n\tv.rps = drive_params[drive].rps;\n\tv.tracks = drive_params[drive].tracks;\n\tv.timeout = drive_params[drive].timeout;\n\tv.interleave_sect = drive_params[drive].interleave_sect;\n\tv.max_errors = drive_params[drive].max_errors;\n\tv.flags = drive_params[drive].flags;\n\tv.read_track = drive_params[drive].read_track;\n\tmemcpy(v.autodetect, drive_params[drive].autodetect,\n\t       sizeof(v.autodetect));\n\tv.checkfreq = drive_params[drive].checkfreq;\n\tv.native_format = drive_params[drive].native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = drive_state[drive].spinup_date;\n\tv.select_date = drive_state[drive].select_date;\n\tv.first_read_date = drive_state[drive].first_read_date;\n\tv.probed_format = drive_state[drive].probed_format;\n\tv.track = drive_state[drive].track;\n\tv.maxblock = drive_state[drive].maxblock;\n\tv.maxtrack = drive_state[drive].maxtrack;\n\tv.generation = drive_state[drive].generation;\n\tv.keep_data = drive_state[drive].keep_data;\n\tv.fd_ref = drive_state[drive].fd_ref;\n\tv.fd_device = drive_state[drive].fd_device;\n\tv.last_checked = drive_state[drive].last_checked;\n\tv.dmabuf = (uintptr_t) drive_state[drive].dmabuf;\n\tv.bufblocks = drive_state[drive].bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = fdc_state[FDC(drive)];\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = write_errors[drive];\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase CDROMEJECT:  \n\tcase 0x6470:\t  \n\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t \n\tdrive = 0;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY1_TYPE;\n\n\t \n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = drive_params[drive].cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\tdrive_params[drive] = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!drive_state[drive].fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tdrive_state[drive].fd_ref = 0;\n\t}\n\tif (!drive_state[drive].fd_ref)\n\t\topened_disk[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n \nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = drive_state[drive].fd_device;\n\tif (opened_disk[drive] && opened_disk[drive] != disk)\n\t\tgoto out2;\n\n\tif (!drive_state[drive].fd_ref && (drive_params[drive].flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t}\n\n\tdrive_state[drive].fd_ref++;\n\n\topened_disk[drive] = disk;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t \n\t\tif ((drive_params[drive].cmos == 6) || (drive_params[drive].cmos == 5))\n\t\t\ttry = 64;\t \n\t\telse\n\t\t\ttry = 32;\t \n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t \n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = disk->first_minor;\n\tdrive_state[drive].fd_device = new_dev;\n\tset_capacity(disks[drive][ITYPE(new_dev)], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (fdc_state[FDC(drive)].rawcmd == 1)\n\t\tfdc_state[FDC(drive)].rawcmd = 2;\n\tif (!(mode & BLK_OPEN_NDELAY)) {\n\t\tif (mode & (BLK_OPEN_READ | BLK_OPEN_WRITE)) {\n\t\t\tdrive_state[drive].last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t\t\tif (disk_check_media_change(disk))\n\t\t\t\tfloppy_revalidate(disk);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & BLK_OPEN_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tdrive_state[drive].fd_ref--;\n\n\tif (!drive_state[drive].fd_ref)\n\t\topened_disk[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n \nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, drive_state[drive].last_checked + drive_params[drive].checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n \n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, bdev, &bio_vec, 1, REQ_OP_READ);\n\t__bio_add_page(&bio, page, block_size(bdev), 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n \nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &drive_state[drive].flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t \n\t\t\treturn 0;\n\t\t}\n\t\tdrive_state[drive].maxblock = 0;\n\t\tdrive_state[drive].maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tif (cf)\n\t\t\tdrive_state[drive].generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t \n\t\t\tres = __floppy_read_block_0(opened_disk[drive]->part0,\n\t\t\t\t\t\t    drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n \n\n \n \nstatic char __init get_fdc_version(int fdc)\n{\n\tint r;\n\n\toutput_byte(fdc, FD_DUMPREGS);\t \n\tif (fdc_state[fdc].reset)\n\t\treturn FDC_NONE;\n\tr = result(fdc);\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t \n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t \n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure(fdc)) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t \n\t}\n\n\toutput_byte(fdc, FD_PERPENDICULAR);\n\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\toutput_byte(fdc, 0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t \n\t}\n\n\toutput_byte(fdc, FD_UNLOCK);\n\tr = result(fdc);\n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t \n\t}\n\tif ((r != 1) || (reply_buffer[ST0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(fdc, FD_PARTID);\n\tr = result(fdc);\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[ST0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t \n\t}\n\tswitch (reply_buffer[ST0] >> 5) {\n\tcase 0x0:\n\t\t \n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[ST0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t \n\n \n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tdrive_params[current_drive].cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0},  \n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t \n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/admin-guide/blockdev/floppy.rst\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", drive_params[drive].cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\tint saved_drive;\n\n\tsaved_drive = current_drive;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tuser_reset_fdc(REVDRIVE(fdc, 0), FD_RESET_ALWAYS, false);\n\tset_fdc(saved_drive);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\nstatic bool registered[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int floppy_alloc_disk(unsigned int drive, unsigned int type)\n{\n\tstruct gendisk *disk;\n\n\tdisk = blk_mq_alloc_disk(&tag_sets[drive], NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tblk_queue_max_hw_sectors(disk->queue, 64);\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = TOMINOR(drive) | (type << 2);\n\tdisk->minors = 1;\n\tdisk->fops = &floppy_fops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tif (type)\n\t\tsprintf(disk->disk_name, \"fd%d_type%d\", drive, type);\n\telse\n\t\tsprintf(disk->disk_name, \"fd%d\", drive);\n\t \n\tdisk->private_data = (void *)(long)drive;\n\tdisk->flags |= GENHD_FL_REMOVABLE;\n\n\tdisks[drive][type] = disk;\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(floppy_probe_lock);\n\nstatic void floppy_probe(dev_t dev)\n{\n\tunsigned int drive = (MINOR(dev) & 3) | ((MINOR(dev) & 0x80) >> 5);\n\tunsigned int type = (MINOR(dev) >> 2) & 0x1f;\n\n\tif (drive >= N_DRIVE || !floppy_available(drive) ||\n\t    type >= ARRAY_SIZE(floppy_type))\n\t\treturn;\n\n\tmutex_lock(&floppy_probe_lock);\n\tif (disks[drive][type])\n\t\tgoto out;\n\tif (floppy_alloc_disk(drive, type))\n\t\tgoto out;\n\tif (add_disk(disks[drive][type]))\n\t\tgoto cleanup_disk;\nout:\n\tmutex_unlock(&floppy_probe_lock);\n\treturn;\n\ncleanup_disk:\n\tput_disk(disks[drive][type]);\n\tdisks[drive][type] = NULL;\n\tmutex_unlock(&floppy_probe_lock);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&tag_sets[drive], 0, sizeof(tag_sets[drive]));\n\t\ttag_sets[drive].ops = &floppy_mq_ops;\n\t\ttag_sets[drive].nr_hw_queues = 1;\n\t\ttag_sets[drive].nr_maps = 1;\n\t\ttag_sets[drive].queue_depth = 2;\n\t\ttag_sets[drive].numa_node = NUMA_NO_NODE;\n\t\ttag_sets[drive].flags = BLK_MQ_F_SHOULD_MERGE;\n\t\terr = blk_mq_alloc_tag_set(&tag_sets[drive]);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\terr = floppy_alloc_disk(drive, 0);\n\t\tif (err) {\n\t\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t\t\tgoto out_put_disk;\n\t\t}\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = __register_blkdev(FLOPPY_MAJOR, \"fd\", floppy_probe);\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tmemset(&fdc_state[i], 0, sizeof(*fdc_state));\n\t\tfdc_state[i].dtr = -1;\n\t\tfdc_state[i].dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t \n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tfdc_state[i].version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_driver;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tcurrent_fdc = 0;\t \n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_driver;\n\t}\n\n\t \n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&drive_state[drive], 0, sizeof(drive_state[drive]));\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tdrive_state[drive].fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t \n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc_state[i].driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tfdc_state[i].track[unit] = 0;\n\t\tif (fdc_state[i].address == -1)\n\t\t\tcontinue;\n\t\tfdc_state[i].rawcmd = 2;\n\t\tif (user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false)) {\n\t\t\t \n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tfdc_state[i].version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfdc_state[i].version = get_fdc_version(i);\n\t\tif (fdc_state[i].version == FDC_NONE) {\n\t\t\t \n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 &&\n\t\t    fdc_state[i].version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t \n\t\tuser_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false);\n\t}\n\tcurrent_fdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\tregistered[drive] = true;\n\n\t\terr = device_add_disk(&floppy_device[drive].dev,\n\t\t\t\t      disks[drive][0], NULL);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive][0]);\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_driver:\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive][0])\n\t\t\tbreak;\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\tput_disk(disks[drive][0]);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t \n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t \n\t{ 4, 2 },\n\t \n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(fdc_state[fdc].address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(fdc_state[fdc].address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       fdc_state[fdc].address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tint fdc;\n\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t \n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\treset_fdc_info(fdc, 1);\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t\t}\n\t}\n\n\tset_dor(0, ~0, 8);\t \n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t \n\tcurrent_fdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tcurrent_fdc = 0;\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfloppy_release_regions(fdc);\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive, i;\n\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\t\tif (disks[drive][i])\n\t\t\t\t\tdel_gendisk(disks[drive][i]);\n\t\t\t}\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\tif (disks[drive][i])\n\t\t\t\tput_disk(disks[drive][i]);\n\t\t}\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t \n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}