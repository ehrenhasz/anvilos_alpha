{
  "module_name": "brd.c",
  "hash_id": "c0af7945623e728526c97069721f8371479810d6fc2f2e20434a1520586c7761",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/brd.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/initrd.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/major.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/xarray.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/debugfs.h>\n\n#include <linux/uaccess.h>\n\n \nstruct brd_device {\n\tint\t\t\tbrd_number;\n\tstruct gendisk\t\t*brd_disk;\n\tstruct list_head\tbrd_list;\n\n\t \n\tstruct xarray\t        brd_pages;\n\tu64\t\t\tbrd_nr_pages;\n};\n\n \nstatic struct page *brd_lookup_page(struct brd_device *brd, sector_t sector)\n{\n\tpgoff_t idx;\n\tstruct page *page;\n\n\tidx = sector >> PAGE_SECTORS_SHIFT;  \n\tpage = xa_load(&brd->brd_pages, idx);\n\n\tBUG_ON(page && page->index != idx);\n\n\treturn page;\n}\n\n \nstatic int brd_insert_page(struct brd_device *brd, sector_t sector, gfp_t gfp)\n{\n\tpgoff_t idx;\n\tstruct page *page, *cur;\n\tint ret = 0;\n\n\tpage = brd_lookup_page(brd, sector);\n\tif (page)\n\t\treturn 0;\n\n\tpage = alloc_page(gfp | __GFP_ZERO | __GFP_HIGHMEM);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\txa_lock(&brd->brd_pages);\n\n\tidx = sector >> PAGE_SECTORS_SHIFT;\n\tpage->index = idx;\n\n\tcur = __xa_cmpxchg(&brd->brd_pages, idx, NULL, page, gfp);\n\n\tif (unlikely(cur)) {\n\t\t__free_page(page);\n\t\tret = xa_err(cur);\n\t\tif (!ret && (cur->index != idx))\n\t\t\tret = -EIO;\n\t} else {\n\t\tbrd->brd_nr_pages++;\n\t}\n\n\txa_unlock(&brd->brd_pages);\n\n\treturn ret;\n}\n\n \nstatic void brd_free_pages(struct brd_device *brd)\n{\n\tstruct page *page;\n\tpgoff_t idx;\n\n\txa_for_each(&brd->brd_pages, idx, page) {\n\t\t__free_page(page);\n\t\tcond_resched();\n\t}\n\n\txa_destroy(&brd->brd_pages);\n}\n\n \nstatic int copy_to_brd_setup(struct brd_device *brd, sector_t sector, size_t n,\n\t\t\t     gfp_t gfp)\n{\n\tunsigned int offset = (sector & (PAGE_SECTORS-1)) << SECTOR_SHIFT;\n\tsize_t copy;\n\tint ret;\n\n\tcopy = min_t(size_t, n, PAGE_SIZE - offset);\n\tret = brd_insert_page(brd, sector, gfp);\n\tif (ret)\n\t\treturn ret;\n\tif (copy < n) {\n\t\tsector += copy >> SECTOR_SHIFT;\n\t\tret = brd_insert_page(brd, sector, gfp);\n\t}\n\treturn ret;\n}\n\n \nstatic void copy_to_brd(struct brd_device *brd, const void *src,\n\t\t\tsector_t sector, size_t n)\n{\n\tstruct page *page;\n\tvoid *dst;\n\tunsigned int offset = (sector & (PAGE_SECTORS-1)) << SECTOR_SHIFT;\n\tsize_t copy;\n\n\tcopy = min_t(size_t, n, PAGE_SIZE - offset);\n\tpage = brd_lookup_page(brd, sector);\n\tBUG_ON(!page);\n\n\tdst = kmap_atomic(page);\n\tmemcpy(dst + offset, src, copy);\n\tkunmap_atomic(dst);\n\n\tif (copy < n) {\n\t\tsrc += copy;\n\t\tsector += copy >> SECTOR_SHIFT;\n\t\tcopy = n - copy;\n\t\tpage = brd_lookup_page(brd, sector);\n\t\tBUG_ON(!page);\n\n\t\tdst = kmap_atomic(page);\n\t\tmemcpy(dst, src, copy);\n\t\tkunmap_atomic(dst);\n\t}\n}\n\n \nstatic void copy_from_brd(void *dst, struct brd_device *brd,\n\t\t\tsector_t sector, size_t n)\n{\n\tstruct page *page;\n\tvoid *src;\n\tunsigned int offset = (sector & (PAGE_SECTORS-1)) << SECTOR_SHIFT;\n\tsize_t copy;\n\n\tcopy = min_t(size_t, n, PAGE_SIZE - offset);\n\tpage = brd_lookup_page(brd, sector);\n\tif (page) {\n\t\tsrc = kmap_atomic(page);\n\t\tmemcpy(dst, src + offset, copy);\n\t\tkunmap_atomic(src);\n\t} else\n\t\tmemset(dst, 0, copy);\n\n\tif (copy < n) {\n\t\tdst += copy;\n\t\tsector += copy >> SECTOR_SHIFT;\n\t\tcopy = n - copy;\n\t\tpage = brd_lookup_page(brd, sector);\n\t\tif (page) {\n\t\t\tsrc = kmap_atomic(page);\n\t\t\tmemcpy(dst, src, copy);\n\t\t\tkunmap_atomic(src);\n\t\t} else\n\t\t\tmemset(dst, 0, copy);\n\t}\n}\n\n \nstatic int brd_do_bvec(struct brd_device *brd, struct page *page,\n\t\t\tunsigned int len, unsigned int off, blk_opf_t opf,\n\t\t\tsector_t sector)\n{\n\tvoid *mem;\n\tint err = 0;\n\n\tif (op_is_write(opf)) {\n\t\t \n\t\tgfp_t gfp = opf & REQ_NOWAIT ? GFP_NOWAIT : GFP_NOIO;\n\n\t\terr = copy_to_brd_setup(brd, sector, len, gfp);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmem = kmap_atomic(page);\n\tif (!op_is_write(opf)) {\n\t\tcopy_from_brd(mem + off, brd, sector, len);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tflush_dcache_page(page);\n\t\tcopy_to_brd(brd, mem + off, sector, len);\n\t}\n\tkunmap_atomic(mem);\n\nout:\n\treturn err;\n}\n\nstatic void brd_submit_bio(struct bio *bio)\n{\n\tstruct brd_device *brd = bio->bi_bdev->bd_disk->private_data;\n\tsector_t sector = bio->bi_iter.bi_sector;\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tunsigned int len = bvec.bv_len;\n\t\tint err;\n\n\t\t \n\t\tWARN_ON_ONCE((bvec.bv_offset & (SECTOR_SIZE - 1)) ||\n\t\t\t\t(len & (SECTOR_SIZE - 1)));\n\n\t\terr = brd_do_bvec(brd, bvec.bv_page, len, bvec.bv_offset,\n\t\t\t\t  bio->bi_opf, sector);\n\t\tif (err) {\n\t\t\tif (err == -ENOMEM && bio->bi_opf & REQ_NOWAIT) {\n\t\t\t\tbio_wouldblock_error(bio);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbio_io_error(bio);\n\t\t\treturn;\n\t\t}\n\t\tsector += len >> SECTOR_SHIFT;\n\t}\n\n\tbio_endio(bio);\n}\n\nstatic const struct block_device_operations brd_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.submit_bio =\t\tbrd_submit_bio,\n};\n\n \nstatic int rd_nr = CONFIG_BLK_DEV_RAM_COUNT;\nmodule_param(rd_nr, int, 0444);\nMODULE_PARM_DESC(rd_nr, \"Maximum number of brd devices\");\n\nunsigned long rd_size = CONFIG_BLK_DEV_RAM_SIZE;\nmodule_param(rd_size, ulong, 0444);\nMODULE_PARM_DESC(rd_size, \"Size of each RAM disk in kbytes.\");\n\nstatic int max_part = 1;\nmodule_param(max_part, int, 0444);\nMODULE_PARM_DESC(max_part, \"Num Minors to reserve between devices\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(RAMDISK_MAJOR);\nMODULE_ALIAS(\"rd\");\n\n#ifndef MODULE\n \nstatic int __init ramdisk_size(char *str)\n{\n\trd_size = simple_strtol(str, NULL, 0);\n\treturn 1;\n}\n__setup(\"ramdisk_size=\", ramdisk_size);\n#endif\n\n \nstatic LIST_HEAD(brd_devices);\nstatic struct dentry *brd_debugfs_dir;\n\nstatic int brd_alloc(int i)\n{\n\tstruct brd_device *brd;\n\tstruct gendisk *disk;\n\tchar buf[DISK_NAME_LEN];\n\tint err = -ENOMEM;\n\n\tlist_for_each_entry(brd, &brd_devices, brd_list)\n\t\tif (brd->brd_number == i)\n\t\t\treturn -EEXIST;\n\tbrd = kzalloc(sizeof(*brd), GFP_KERNEL);\n\tif (!brd)\n\t\treturn -ENOMEM;\n\tbrd->brd_number\t\t= i;\n\tlist_add_tail(&brd->brd_list, &brd_devices);\n\n\txa_init(&brd->brd_pages);\n\n\tsnprintf(buf, DISK_NAME_LEN, \"ram%d\", i);\n\tif (!IS_ERR_OR_NULL(brd_debugfs_dir))\n\t\tdebugfs_create_u64(buf, 0444, brd_debugfs_dir,\n\t\t\t\t&brd->brd_nr_pages);\n\n\tdisk = brd->brd_disk = blk_alloc_disk(NUMA_NO_NODE);\n\tif (!disk)\n\t\tgoto out_free_dev;\n\n\tdisk->major\t\t= RAMDISK_MAJOR;\n\tdisk->first_minor\t= i * max_part;\n\tdisk->minors\t\t= max_part;\n\tdisk->fops\t\t= &brd_fops;\n\tdisk->private_data\t= brd;\n\tstrscpy(disk->disk_name, buf, DISK_NAME_LEN);\n\tset_capacity(disk, rd_size * 2);\n\t\n\t \n\tblk_queue_physical_block_size(disk->queue, PAGE_SIZE);\n\n\t \n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, disk->queue);\n\tblk_queue_flag_set(QUEUE_FLAG_SYNCHRONOUS, disk->queue);\n\tblk_queue_flag_set(QUEUE_FLAG_NOWAIT, disk->queue);\n\terr = add_disk(disk);\n\tif (err)\n\t\tgoto out_cleanup_disk;\n\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(disk);\nout_free_dev:\n\tlist_del(&brd->brd_list);\n\tkfree(brd);\n\treturn err;\n}\n\nstatic void brd_probe(dev_t dev)\n{\n\tbrd_alloc(MINOR(dev) / max_part);\n}\n\nstatic void brd_cleanup(void)\n{\n\tstruct brd_device *brd, *next;\n\n\tdebugfs_remove_recursive(brd_debugfs_dir);\n\n\tlist_for_each_entry_safe(brd, next, &brd_devices, brd_list) {\n\t\tdel_gendisk(brd->brd_disk);\n\t\tput_disk(brd->brd_disk);\n\t\tbrd_free_pages(brd);\n\t\tlist_del(&brd->brd_list);\n\t\tkfree(brd);\n\t}\n}\n\nstatic inline void brd_check_and_reset_par(void)\n{\n\tif (unlikely(!max_part))\n\t\tmax_part = 1;\n\n\t \n\tif ((1U << MINORBITS) % max_part != 0)\n\t\tmax_part = 1UL << fls(max_part);\n\n\tif (max_part > DISK_MAX_PARTS) {\n\t\tpr_info(\"brd: max_part can't be larger than %d, reset max_part = %d.\\n\",\n\t\t\tDISK_MAX_PARTS, DISK_MAX_PARTS);\n\t\tmax_part = DISK_MAX_PARTS;\n\t}\n}\n\nstatic int __init brd_init(void)\n{\n\tint err, i;\n\n\tbrd_check_and_reset_par();\n\n\tbrd_debugfs_dir = debugfs_create_dir(\"ramdisk_pages\", NULL);\n\n\tfor (i = 0; i < rd_nr; i++) {\n\t\terr = brd_alloc(i);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\t \n\n\tif (__register_blkdev(RAMDISK_MAJOR, \"ramdisk\", brd_probe)) {\n\t\terr = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tpr_info(\"brd: module loaded\\n\");\n\treturn 0;\n\nout_free:\n\tbrd_cleanup();\n\n\tpr_info(\"brd: module NOT loaded !!!\\n\");\n\treturn err;\n}\n\nstatic void __exit brd_exit(void)\n{\n\n\tunregister_blkdev(RAMDISK_MAJOR, \"ramdisk\");\n\tbrd_cleanup();\n\n\tpr_info(\"brd: module unloaded\\n\");\n}\n\nmodule_init(brd_init);\nmodule_exit(brd_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}