{
  "module_name": "ublk_drv.c",
  "hash_id": "5a16c4e2b4147b79b1c1bbbbf8246f390478c9e4a8bda0d10289bcfae35bef78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/ublk_drv.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/wait.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/mutex.h>\n#include <linux/writeback.h>\n#include <linux/completion.h>\n#include <linux/highmem.h>\n#include <linux/sysfs.h>\n#include <linux/miscdevice.h>\n#include <linux/falloc.h>\n#include <linux/uio.h>\n#include <linux/ioprio.h>\n#include <linux/sched/mm.h>\n#include <linux/uaccess.h>\n#include <linux/cdev.h>\n#include <linux/io_uring.h>\n#include <linux/blk-mq.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <asm/page.h>\n#include <linux/task_work.h>\n#include <linux/namei.h>\n#include <linux/kref.h>\n#include <uapi/linux/ublk_cmd.h>\n\n#define UBLK_MINORS\t\t(1U << MINORBITS)\n\n \n#define UBLK_F_ALL (UBLK_F_SUPPORT_ZERO_COPY \\\n\t\t| UBLK_F_URING_CMD_COMP_IN_TASK \\\n\t\t| UBLK_F_NEED_GET_DATA \\\n\t\t| UBLK_F_USER_RECOVERY \\\n\t\t| UBLK_F_USER_RECOVERY_REISSUE \\\n\t\t| UBLK_F_UNPRIVILEGED_DEV \\\n\t\t| UBLK_F_CMD_IOCTL_ENCODE \\\n\t\t| UBLK_F_USER_COPY \\\n\t\t| UBLK_F_ZONED)\n\n \n#define UBLK_PARAM_TYPE_ALL                                \\\n\t(UBLK_PARAM_TYPE_BASIC | UBLK_PARAM_TYPE_DISCARD | \\\n\t UBLK_PARAM_TYPE_DEVT | UBLK_PARAM_TYPE_ZONED)\n\nstruct ublk_rq_data {\n\tstruct llist_node node;\n\n\tstruct kref ref;\n\t__u64 sector;\n\t__u32 operation;\n\t__u32 nr_zones;\n};\n\nstruct ublk_uring_cmd_pdu {\n\tstruct ublk_queue *ubq;\n};\n\n \n#define UBLK_IO_FLAG_ACTIVE\t0x01\n\n \n#define UBLK_IO_FLAG_OWNED_BY_SRV 0x02\n\n \n#define UBLK_IO_FLAG_ABORTED 0x04\n\n \n#define UBLK_IO_FLAG_NEED_GET_DATA 0x08\n\nstruct ublk_io {\n\t \n\t__u64\taddr;\n\tunsigned int flags;\n\tint res;\n\n\tstruct io_uring_cmd *cmd;\n};\n\nstruct ublk_queue {\n\tint q_id;\n\tint q_depth;\n\n\tunsigned long flags;\n\tstruct task_struct\t*ubq_daemon;\n\tchar *io_cmd_buf;\n\n\tstruct llist_head\tio_cmds;\n\n\tunsigned long io_addr;\t \n\tunsigned int max_io_sz;\n\tbool force_abort;\n\tbool timeout;\n\tunsigned short nr_io_ready;\t \n\tstruct ublk_device *dev;\n\tstruct ublk_io ios[];\n};\n\n#define UBLK_DAEMON_MONITOR_PERIOD\t(5 * HZ)\n\nstruct ublk_device {\n\tstruct gendisk\t\t*ub_disk;\n\n\tchar\t*__queues;\n\n\tunsigned int\tqueue_size;\n\tstruct ublksrv_ctrl_dev_info\tdev_info;\n\n\tstruct blk_mq_tag_set\ttag_set;\n\n\tstruct cdev\t\tcdev;\n\tstruct device\t\tcdev_dev;\n\n#define UB_STATE_OPEN\t\t0\n#define UB_STATE_USED\t\t1\n#define UB_STATE_DELETED\t2\n\tunsigned long\t\tstate;\n\tint\t\t\tub_number;\n\n\tstruct mutex\t\tmutex;\n\n\tspinlock_t\t\tmm_lock;\n\tstruct mm_struct\t*mm;\n\n\tstruct ublk_params\tparams;\n\n\tstruct completion\tcompletion;\n\tunsigned int\t\tnr_queues_ready;\n\tunsigned int\t\tnr_privileged_daemon;\n\n\t \n\tstruct delayed_work\tmonitor_work;\n\tstruct work_struct\tquiesce_work;\n\tstruct work_struct\tstop_work;\n};\n\n \nstruct ublk_params_header {\n\t__u32\tlen;\n\t__u32\ttypes;\n};\n\nstatic inline unsigned int ublk_req_build_flags(struct request *req);\nstatic inline struct ublksrv_io_desc *ublk_get_iod(struct ublk_queue *ubq,\n\t\t\t\t\t\t   int tag);\n\nstatic inline bool ublk_dev_is_user_copy(const struct ublk_device *ub)\n{\n\treturn ub->dev_info.flags & UBLK_F_USER_COPY;\n}\n\nstatic inline bool ublk_dev_is_zoned(const struct ublk_device *ub)\n{\n\treturn ub->dev_info.flags & UBLK_F_ZONED;\n}\n\nstatic inline bool ublk_queue_is_zoned(struct ublk_queue *ubq)\n{\n\treturn ubq->flags & UBLK_F_ZONED;\n}\n\n#ifdef CONFIG_BLK_DEV_ZONED\n\nstatic int ublk_get_nr_zones(const struct ublk_device *ub)\n{\n\tconst struct ublk_param_basic *p = &ub->params.basic;\n\n\t \n\treturn p->dev_sectors >> ilog2(p->chunk_sectors);\n}\n\nstatic int ublk_revalidate_disk_zones(struct ublk_device *ub)\n{\n\treturn blk_revalidate_disk_zones(ub->ub_disk, NULL);\n}\n\nstatic int ublk_dev_param_zoned_validate(const struct ublk_device *ub)\n{\n\tconst struct ublk_param_zoned *p = &ub->params.zoned;\n\tint nr_zones;\n\n\tif (!ublk_dev_is_zoned(ub))\n\t\treturn -EINVAL;\n\n\tif (!p->max_zone_append_sectors)\n\t\treturn -EINVAL;\n\n\tnr_zones = ublk_get_nr_zones(ub);\n\n\tif (p->max_active_zones > nr_zones)\n\t\treturn -EINVAL;\n\n\tif (p->max_open_zones > nr_zones)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ublk_dev_param_zoned_apply(struct ublk_device *ub)\n{\n\tconst struct ublk_param_zoned *p = &ub->params.zoned;\n\n\tdisk_set_zoned(ub->ub_disk, BLK_ZONED_HM);\n\tblk_queue_flag_set(QUEUE_FLAG_ZONE_RESETALL, ub->ub_disk->queue);\n\tblk_queue_required_elevator_features(ub->ub_disk->queue,\n\t\t\t\t\t     ELEVATOR_F_ZBD_SEQ_WRITE);\n\tdisk_set_max_active_zones(ub->ub_disk, p->max_active_zones);\n\tdisk_set_max_open_zones(ub->ub_disk, p->max_open_zones);\n\tblk_queue_max_zone_append_sectors(ub->ub_disk->queue, p->max_zone_append_sectors);\n\n\tub->ub_disk->nr_zones = ublk_get_nr_zones(ub);\n\n\treturn 0;\n}\n\n \nstatic void *ublk_alloc_report_buffer(struct ublk_device *ublk,\n\t\t\t\t      unsigned int nr_zones, size_t *buflen)\n{\n\tstruct request_queue *q = ublk->ub_disk->queue;\n\tsize_t bufsize;\n\tvoid *buf;\n\n\tnr_zones = min_t(unsigned int, nr_zones,\n\t\t\t ublk->ub_disk->nr_zones);\n\n\tbufsize = nr_zones * sizeof(struct blk_zone);\n\tbufsize =\n\t\tmin_t(size_t, bufsize, queue_max_hw_sectors(q) << SECTOR_SHIFT);\n\n\twhile (bufsize >= sizeof(struct blk_zone)) {\n\t\tbuf = kvmalloc(bufsize, GFP_KERNEL | __GFP_NORETRY);\n\t\tif (buf) {\n\t\t\t*buflen = bufsize;\n\t\t\treturn buf;\n\t\t}\n\t\tbufsize >>= 1;\n\t}\n\n\t*buflen = 0;\n\treturn NULL;\n}\n\nstatic int ublk_report_zones(struct gendisk *disk, sector_t sector,\n\t\t      unsigned int nr_zones, report_zones_cb cb, void *data)\n{\n\tstruct ublk_device *ub = disk->private_data;\n\tunsigned int zone_size_sectors = disk->queue->limits.chunk_sectors;\n\tunsigned int first_zone = sector >> ilog2(zone_size_sectors);\n\tunsigned int done_zones = 0;\n\tunsigned int max_zones_per_request;\n\tint ret;\n\tstruct blk_zone *buffer;\n\tsize_t buffer_length;\n\n\tnr_zones = min_t(unsigned int, ub->ub_disk->nr_zones - first_zone,\n\t\t\t nr_zones);\n\n\tbuffer = ublk_alloc_report_buffer(ub, nr_zones, &buffer_length);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmax_zones_per_request = buffer_length / sizeof(struct blk_zone);\n\n\twhile (done_zones < nr_zones) {\n\t\tunsigned int remaining_zones = nr_zones - done_zones;\n\t\tunsigned int zones_in_request =\n\t\t\tmin_t(unsigned int, remaining_zones, max_zones_per_request);\n\t\tstruct request *req;\n\t\tstruct ublk_rq_data *pdu;\n\t\tblk_status_t status;\n\n\t\tmemset(buffer, 0, buffer_length);\n\n\t\treq = blk_mq_alloc_request(disk->queue, REQ_OP_DRV_IN, 0);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpdu = blk_mq_rq_to_pdu(req);\n\t\tpdu->operation = UBLK_IO_OP_REPORT_ZONES;\n\t\tpdu->sector = sector;\n\t\tpdu->nr_zones = zones_in_request;\n\n\t\tret = blk_rq_map_kern(disk->queue, req, buffer, buffer_length,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret) {\n\t\t\tblk_mq_free_request(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = blk_execute_rq(req, 0);\n\t\tret = blk_status_to_errno(status);\n\t\tblk_mq_free_request(req);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tfor (unsigned int i = 0; i < zones_in_request; i++) {\n\t\t\tstruct blk_zone *zone = buffer + i;\n\n\t\t\t \n\t\t\tif (!zone->len)\n\t\t\t\tbreak;\n\n\t\t\tret = cb(zone, i, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tdone_zones++;\n\t\t\tsector += zone_size_sectors;\n\n\t\t}\n\t}\n\n\tret = done_zones;\n\nout:\n\tkvfree(buffer);\n\treturn ret;\n}\n\nstatic blk_status_t ublk_setup_iod_zoned(struct ublk_queue *ubq,\n\t\t\t\t\t struct request *req)\n{\n\tstruct ublksrv_io_desc *iod = ublk_get_iod(ubq, req->tag);\n\tstruct ublk_io *io = &ubq->ios[req->tag];\n\tstruct ublk_rq_data *pdu = blk_mq_rq_to_pdu(req);\n\tu32 ublk_op;\n\n\tswitch (req_op(req)) {\n\tcase REQ_OP_ZONE_OPEN:\n\t\tublk_op = UBLK_IO_OP_ZONE_OPEN;\n\t\tbreak;\n\tcase REQ_OP_ZONE_CLOSE:\n\t\tublk_op = UBLK_IO_OP_ZONE_CLOSE;\n\t\tbreak;\n\tcase REQ_OP_ZONE_FINISH:\n\t\tublk_op = UBLK_IO_OP_ZONE_FINISH;\n\t\tbreak;\n\tcase REQ_OP_ZONE_RESET:\n\t\tublk_op = UBLK_IO_OP_ZONE_RESET;\n\t\tbreak;\n\tcase REQ_OP_ZONE_APPEND:\n\t\tublk_op = UBLK_IO_OP_ZONE_APPEND;\n\t\tbreak;\n\tcase REQ_OP_ZONE_RESET_ALL:\n\t\tublk_op = UBLK_IO_OP_ZONE_RESET_ALL;\n\t\tbreak;\n\tcase REQ_OP_DRV_IN:\n\t\tublk_op = pdu->operation;\n\t\tswitch (ublk_op) {\n\t\tcase UBLK_IO_OP_REPORT_ZONES:\n\t\t\tiod->op_flags = ublk_op | ublk_req_build_flags(req);\n\t\t\tiod->nr_zones = pdu->nr_zones;\n\t\t\tiod->start_sector = pdu->sector;\n\t\t\treturn BLK_STS_OK;\n\t\tdefault:\n\t\t\treturn BLK_STS_IOERR;\n\t\t}\n\tcase REQ_OP_DRV_OUT:\n\t\t \n\t\treturn BLK_STS_NOTSUPP;\n\tdefault:\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tiod->op_flags = ublk_op | ublk_req_build_flags(req);\n\tiod->nr_sectors = blk_rq_sectors(req);\n\tiod->start_sector = blk_rq_pos(req);\n\tiod->addr = io->addr;\n\n\treturn BLK_STS_OK;\n}\n\n#else\n\n#define ublk_report_zones (NULL)\n\nstatic int ublk_dev_param_zoned_validate(const struct ublk_device *ub)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ublk_dev_param_zoned_apply(struct ublk_device *ub)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ublk_revalidate_disk_zones(struct ublk_device *ub)\n{\n\treturn 0;\n}\n\nstatic blk_status_t ublk_setup_iod_zoned(struct ublk_queue *ubq,\n\t\t\t\t\t struct request *req)\n{\n\treturn BLK_STS_NOTSUPP;\n}\n\n#endif\n\nstatic inline void __ublk_complete_rq(struct request *req);\nstatic void ublk_complete_rq(struct kref *ref);\n\nstatic dev_t ublk_chr_devt;\nstatic const struct class ublk_chr_class = {\n\t.name = \"ublk-char\",\n};\n\nstatic DEFINE_IDR(ublk_index_idr);\nstatic DEFINE_SPINLOCK(ublk_idr_lock);\nstatic wait_queue_head_t ublk_idr_wq;\t \n\nstatic DEFINE_MUTEX(ublk_ctl_mutex);\n\n \nstatic unsigned int ublks_max = 64;\nstatic unsigned int ublks_added;\t \n\nstatic struct miscdevice ublk_misc;\n\nstatic inline unsigned ublk_pos_to_hwq(loff_t pos)\n{\n\treturn ((pos - UBLKSRV_IO_BUF_OFFSET) >> UBLK_QID_OFF) &\n\t\tUBLK_QID_BITS_MASK;\n}\n\nstatic inline unsigned ublk_pos_to_buf_off(loff_t pos)\n{\n\treturn (pos - UBLKSRV_IO_BUF_OFFSET) & UBLK_IO_BUF_BITS_MASK;\n}\n\nstatic inline unsigned ublk_pos_to_tag(loff_t pos)\n{\n\treturn ((pos - UBLKSRV_IO_BUF_OFFSET) >> UBLK_TAG_OFF) &\n\t\tUBLK_TAG_BITS_MASK;\n}\n\nstatic void ublk_dev_param_basic_apply(struct ublk_device *ub)\n{\n\tstruct request_queue *q = ub->ub_disk->queue;\n\tconst struct ublk_param_basic *p = &ub->params.basic;\n\n\tblk_queue_logical_block_size(q, 1 << p->logical_bs_shift);\n\tblk_queue_physical_block_size(q, 1 << p->physical_bs_shift);\n\tblk_queue_io_min(q, 1 << p->io_min_shift);\n\tblk_queue_io_opt(q, 1 << p->io_opt_shift);\n\n\tblk_queue_write_cache(q, p->attrs & UBLK_ATTR_VOLATILE_CACHE,\n\t\t\tp->attrs & UBLK_ATTR_FUA);\n\tif (p->attrs & UBLK_ATTR_ROTATIONAL)\n\t\tblk_queue_flag_clear(QUEUE_FLAG_NONROT, q);\n\telse\n\t\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\n\tblk_queue_max_hw_sectors(q, p->max_sectors);\n\tblk_queue_chunk_sectors(q, p->chunk_sectors);\n\tblk_queue_virt_boundary(q, p->virt_boundary_mask);\n\n\tif (p->attrs & UBLK_ATTR_READ_ONLY)\n\t\tset_disk_ro(ub->ub_disk, true);\n\n\tset_capacity(ub->ub_disk, p->dev_sectors);\n}\n\nstatic void ublk_dev_param_discard_apply(struct ublk_device *ub)\n{\n\tstruct request_queue *q = ub->ub_disk->queue;\n\tconst struct ublk_param_discard *p = &ub->params.discard;\n\n\tq->limits.discard_alignment = p->discard_alignment;\n\tq->limits.discard_granularity = p->discard_granularity;\n\tblk_queue_max_discard_sectors(q, p->max_discard_sectors);\n\tblk_queue_max_write_zeroes_sectors(q,\n\t\t\tp->max_write_zeroes_sectors);\n\tblk_queue_max_discard_segments(q, p->max_discard_segments);\n}\n\nstatic int ublk_validate_params(const struct ublk_device *ub)\n{\n\t \n\tif (ub->params.types & UBLK_PARAM_TYPE_BASIC) {\n\t\tconst struct ublk_param_basic *p = &ub->params.basic;\n\n\t\tif (p->logical_bs_shift > PAGE_SHIFT || p->logical_bs_shift < 9)\n\t\t\treturn -EINVAL;\n\n\t\tif (p->logical_bs_shift > p->physical_bs_shift)\n\t\t\treturn -EINVAL;\n\n\t\tif (p->max_sectors > (ub->dev_info.max_io_buf_bytes >> 9))\n\t\t\treturn -EINVAL;\n\n\t\tif (ublk_dev_is_zoned(ub) && !p->chunk_sectors)\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (ub->params.types & UBLK_PARAM_TYPE_DISCARD) {\n\t\tconst struct ublk_param_discard *p = &ub->params.discard;\n\n\t\t \n\t\tif (p->max_discard_sectors && p->max_discard_segments != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (!p->discard_granularity)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ub->params.types & UBLK_PARAM_TYPE_DEVT)\n\t\treturn -EINVAL;\n\n\tif (ub->params.types & UBLK_PARAM_TYPE_ZONED)\n\t\treturn ublk_dev_param_zoned_validate(ub);\n\telse if (ublk_dev_is_zoned(ub))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ublk_apply_params(struct ublk_device *ub)\n{\n\tif (!(ub->params.types & UBLK_PARAM_TYPE_BASIC))\n\t\treturn -EINVAL;\n\n\tublk_dev_param_basic_apply(ub);\n\n\tif (ub->params.types & UBLK_PARAM_TYPE_DISCARD)\n\t\tublk_dev_param_discard_apply(ub);\n\n\tif (ub->params.types & UBLK_PARAM_TYPE_ZONED)\n\t\treturn ublk_dev_param_zoned_apply(ub);\n\n\treturn 0;\n}\n\nstatic inline bool ublk_support_user_copy(const struct ublk_queue *ubq)\n{\n\treturn ubq->flags & UBLK_F_USER_COPY;\n}\n\nstatic inline bool ublk_need_req_ref(const struct ublk_queue *ubq)\n{\n\t \n\treturn ublk_support_user_copy(ubq);\n}\n\nstatic inline void ublk_init_req_ref(const struct ublk_queue *ubq,\n\t\tstruct request *req)\n{\n\tif (ublk_need_req_ref(ubq)) {\n\t\tstruct ublk_rq_data *data = blk_mq_rq_to_pdu(req);\n\n\t\tkref_init(&data->ref);\n\t}\n}\n\nstatic inline bool ublk_get_req_ref(const struct ublk_queue *ubq,\n\t\tstruct request *req)\n{\n\tif (ublk_need_req_ref(ubq)) {\n\t\tstruct ublk_rq_data *data = blk_mq_rq_to_pdu(req);\n\n\t\treturn kref_get_unless_zero(&data->ref);\n\t}\n\n\treturn true;\n}\n\nstatic inline void ublk_put_req_ref(const struct ublk_queue *ubq,\n\t\tstruct request *req)\n{\n\tif (ublk_need_req_ref(ubq)) {\n\t\tstruct ublk_rq_data *data = blk_mq_rq_to_pdu(req);\n\n\t\tkref_put(&data->ref, ublk_complete_rq);\n\t} else {\n\t\t__ublk_complete_rq(req);\n\t}\n}\n\nstatic inline bool ublk_need_get_data(const struct ublk_queue *ubq)\n{\n\treturn ubq->flags & UBLK_F_NEED_GET_DATA;\n}\n\nstatic struct ublk_device *ublk_get_device(struct ublk_device *ub)\n{\n\tif (kobject_get_unless_zero(&ub->cdev_dev.kobj))\n\t\treturn ub;\n\treturn NULL;\n}\n\nstatic void ublk_put_device(struct ublk_device *ub)\n{\n\tput_device(&ub->cdev_dev);\n}\n\nstatic inline struct ublk_queue *ublk_get_queue(struct ublk_device *dev,\n\t\tint qid)\n{\n       return (struct ublk_queue *)&(dev->__queues[qid * dev->queue_size]);\n}\n\nstatic inline bool ublk_rq_has_data(const struct request *rq)\n{\n\treturn bio_has_data(rq->bio);\n}\n\nstatic inline struct ublksrv_io_desc *ublk_get_iod(struct ublk_queue *ubq,\n\t\tint tag)\n{\n\treturn (struct ublksrv_io_desc *)\n\t\t&(ubq->io_cmd_buf[tag * sizeof(struct ublksrv_io_desc)]);\n}\n\nstatic inline char *ublk_queue_cmd_buf(struct ublk_device *ub, int q_id)\n{\n\treturn ublk_get_queue(ub, q_id)->io_cmd_buf;\n}\n\nstatic inline int ublk_queue_cmd_buf_size(struct ublk_device *ub, int q_id)\n{\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, q_id);\n\n\treturn round_up(ubq->q_depth * sizeof(struct ublksrv_io_desc),\n\t\t\tPAGE_SIZE);\n}\n\nstatic inline bool ublk_queue_can_use_recovery_reissue(\n\t\tstruct ublk_queue *ubq)\n{\n\treturn (ubq->flags & UBLK_F_USER_RECOVERY) &&\n\t\t\t(ubq->flags & UBLK_F_USER_RECOVERY_REISSUE);\n}\n\nstatic inline bool ublk_queue_can_use_recovery(\n\t\tstruct ublk_queue *ubq)\n{\n\treturn ubq->flags & UBLK_F_USER_RECOVERY;\n}\n\nstatic inline bool ublk_can_use_recovery(struct ublk_device *ub)\n{\n\treturn ub->dev_info.flags & UBLK_F_USER_RECOVERY;\n}\n\nstatic void ublk_free_disk(struct gendisk *disk)\n{\n\tstruct ublk_device *ub = disk->private_data;\n\n\tclear_bit(UB_STATE_USED, &ub->state);\n\tput_device(&ub->cdev_dev);\n}\n\nstatic void ublk_store_owner_uid_gid(unsigned int *owner_uid,\n\t\tunsigned int *owner_gid)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tcurrent_uid_gid(&uid, &gid);\n\n\t*owner_uid = from_kuid(&init_user_ns, uid);\n\t*owner_gid = from_kgid(&init_user_ns, gid);\n}\n\nstatic int ublk_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct ublk_device *ub = disk->private_data;\n\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\t \n\tif (ub->dev_info.flags & UBLK_F_UNPRIVILEGED_DEV) {\n\t\tunsigned int curr_uid, curr_gid;\n\n\t\tublk_store_owner_uid_gid(&curr_uid, &curr_gid);\n\n\t\tif (curr_uid != ub->dev_info.owner_uid || curr_gid !=\n\t\t\t\tub->dev_info.owner_gid)\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct block_device_operations ub_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tublk_open,\n\t.free_disk =\tublk_free_disk,\n\t.report_zones =\tublk_report_zones,\n};\n\n#define UBLK_MAX_PIN_PAGES\t32\n\nstruct ublk_io_iter {\n\tstruct page *pages[UBLK_MAX_PIN_PAGES];\n\tstruct bio *bio;\n\tstruct bvec_iter iter;\n};\n\n \nstatic void ublk_copy_io_pages(struct ublk_io_iter *data,\n\t\tsize_t total, size_t pg_off, int dir)\n{\n\tunsigned done = 0;\n\tunsigned pg_idx = 0;\n\n\twhile (done < total) {\n\t\tstruct bio_vec bv = bio_iter_iovec(data->bio, data->iter);\n\t\tunsigned int bytes = min3(bv.bv_len, (unsigned)total - done,\n\t\t\t\t(unsigned)(PAGE_SIZE - pg_off));\n\t\tvoid *bv_buf = bvec_kmap_local(&bv);\n\t\tvoid *pg_buf = kmap_local_page(data->pages[pg_idx]);\n\n\t\tif (dir == ITER_DEST)\n\t\t\tmemcpy(pg_buf + pg_off, bv_buf, bytes);\n\t\telse\n\t\t\tmemcpy(bv_buf, pg_buf + pg_off, bytes);\n\n\t\tkunmap_local(pg_buf);\n\t\tkunmap_local(bv_buf);\n\n\t\t \n\t\tpg_off += bytes;\n\t\tif (pg_off == PAGE_SIZE) {\n\t\t\tpg_idx += 1;\n\t\t\tpg_off = 0;\n\t\t}\n\n\t\tdone += bytes;\n\n\t\t \n\t\tbio_advance_iter_single(data->bio, &data->iter, bytes);\n\t\tif (!data->iter.bi_size) {\n\t\t\tdata->bio = data->bio->bi_next;\n\t\t\tif (data->bio == NULL)\n\t\t\t\tbreak;\n\t\t\tdata->iter = data->bio->bi_iter;\n\t\t}\n\t}\n}\n\nstatic bool ublk_advance_io_iter(const struct request *req,\n\t\tstruct ublk_io_iter *iter, unsigned int offset)\n{\n\tstruct bio *bio = req->bio;\n\n\tfor_each_bio(bio) {\n\t\tif (bio->bi_iter.bi_size > offset) {\n\t\t\titer->bio = bio;\n\t\t\titer->iter = bio->bi_iter;\n\t\t\tbio_advance_iter(iter->bio, &iter->iter, offset);\n\t\t\treturn true;\n\t\t}\n\t\toffset -= bio->bi_iter.bi_size;\n\t}\n\treturn false;\n}\n\n \nstatic size_t ublk_copy_user_pages(const struct request *req,\n\t\tunsigned offset, struct iov_iter *uiter, int dir)\n{\n\tstruct ublk_io_iter iter;\n\tsize_t done = 0;\n\n\tif (!ublk_advance_io_iter(req, &iter, offset))\n\t\treturn 0;\n\n\twhile (iov_iter_count(uiter) && iter.bio) {\n\t\tunsigned nr_pages;\n\t\tssize_t len;\n\t\tsize_t off;\n\t\tint i;\n\n\t\tlen = iov_iter_get_pages2(uiter, iter.pages,\n\t\t\t\tiov_iter_count(uiter),\n\t\t\t\tUBLK_MAX_PIN_PAGES, &off);\n\t\tif (len <= 0)\n\t\t\treturn done;\n\n\t\tublk_copy_io_pages(&iter, len, off, dir);\n\t\tnr_pages = DIV_ROUND_UP(len + off, PAGE_SIZE);\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (dir == ITER_DEST)\n\t\t\t\tset_page_dirty(iter.pages[i]);\n\t\t\tput_page(iter.pages[i]);\n\t\t}\n\t\tdone += len;\n\t}\n\n\treturn done;\n}\n\nstatic inline bool ublk_need_map_req(const struct request *req)\n{\n\treturn ublk_rq_has_data(req) && req_op(req) == REQ_OP_WRITE;\n}\n\nstatic inline bool ublk_need_unmap_req(const struct request *req)\n{\n\treturn ublk_rq_has_data(req) &&\n\t       (req_op(req) == REQ_OP_READ || req_op(req) == REQ_OP_DRV_IN);\n}\n\nstatic int ublk_map_io(const struct ublk_queue *ubq, const struct request *req,\n\t\tstruct ublk_io *io)\n{\n\tconst unsigned int rq_bytes = blk_rq_bytes(req);\n\n\tif (ublk_support_user_copy(ubq))\n\t\treturn rq_bytes;\n\n\t \n\tif (ublk_need_map_req(req)) {\n\t\tstruct iov_iter iter;\n\t\tstruct iovec iov;\n\t\tconst int dir = ITER_DEST;\n\n\t\timport_single_range(dir, u64_to_user_ptr(io->addr), rq_bytes,\n\t\t\t\t&iov, &iter);\n\n\t\treturn ublk_copy_user_pages(req, 0, &iter, dir);\n\t}\n\treturn rq_bytes;\n}\n\nstatic int ublk_unmap_io(const struct ublk_queue *ubq,\n\t\tconst struct request *req,\n\t\tstruct ublk_io *io)\n{\n\tconst unsigned int rq_bytes = blk_rq_bytes(req);\n\n\tif (ublk_support_user_copy(ubq))\n\t\treturn rq_bytes;\n\n\tif (ublk_need_unmap_req(req)) {\n\t\tstruct iov_iter iter;\n\t\tstruct iovec iov;\n\t\tconst int dir = ITER_SOURCE;\n\n\t\tWARN_ON_ONCE(io->res > rq_bytes);\n\n\t\timport_single_range(dir, u64_to_user_ptr(io->addr), io->res,\n\t\t\t\t&iov, &iter);\n\t\treturn ublk_copy_user_pages(req, 0, &iter, dir);\n\t}\n\treturn rq_bytes;\n}\n\nstatic inline unsigned int ublk_req_build_flags(struct request *req)\n{\n\tunsigned flags = 0;\n\n\tif (req->cmd_flags & REQ_FAILFAST_DEV)\n\t\tflags |= UBLK_IO_F_FAILFAST_DEV;\n\n\tif (req->cmd_flags & REQ_FAILFAST_TRANSPORT)\n\t\tflags |= UBLK_IO_F_FAILFAST_TRANSPORT;\n\n\tif (req->cmd_flags & REQ_FAILFAST_DRIVER)\n\t\tflags |= UBLK_IO_F_FAILFAST_DRIVER;\n\n\tif (req->cmd_flags & REQ_META)\n\t\tflags |= UBLK_IO_F_META;\n\n\tif (req->cmd_flags & REQ_FUA)\n\t\tflags |= UBLK_IO_F_FUA;\n\n\tif (req->cmd_flags & REQ_NOUNMAP)\n\t\tflags |= UBLK_IO_F_NOUNMAP;\n\n\tif (req->cmd_flags & REQ_SWAP)\n\t\tflags |= UBLK_IO_F_SWAP;\n\n\treturn flags;\n}\n\nstatic blk_status_t ublk_setup_iod(struct ublk_queue *ubq, struct request *req)\n{\n\tstruct ublksrv_io_desc *iod = ublk_get_iod(ubq, req->tag);\n\tstruct ublk_io *io = &ubq->ios[req->tag];\n\tenum req_op op = req_op(req);\n\tu32 ublk_op;\n\n\tif (!ublk_queue_is_zoned(ubq) &&\n\t    (op_is_zone_mgmt(op) || op == REQ_OP_ZONE_APPEND))\n\t\treturn BLK_STS_IOERR;\n\n\tswitch (req_op(req)) {\n\tcase REQ_OP_READ:\n\t\tublk_op = UBLK_IO_OP_READ;\n\t\tbreak;\n\tcase REQ_OP_WRITE:\n\t\tublk_op = UBLK_IO_OP_WRITE;\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\tublk_op = UBLK_IO_OP_FLUSH;\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\tublk_op = UBLK_IO_OP_DISCARD;\n\t\tbreak;\n\tcase REQ_OP_WRITE_ZEROES:\n\t\tublk_op = UBLK_IO_OP_WRITE_ZEROES;\n\t\tbreak;\n\tdefault:\n\t\tif (ublk_queue_is_zoned(ubq))\n\t\t\treturn ublk_setup_iod_zoned(ubq, req);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\t \n\tiod->op_flags = ublk_op | ublk_req_build_flags(req);\n\tiod->nr_sectors = blk_rq_sectors(req);\n\tiod->start_sector = blk_rq_pos(req);\n\tiod->addr = io->addr;\n\n\treturn BLK_STS_OK;\n}\n\nstatic inline struct ublk_uring_cmd_pdu *ublk_get_uring_cmd_pdu(\n\t\tstruct io_uring_cmd *ioucmd)\n{\n\treturn (struct ublk_uring_cmd_pdu *)&ioucmd->pdu;\n}\n\nstatic inline bool ubq_daemon_is_dying(struct ublk_queue *ubq)\n{\n\treturn ubq->ubq_daemon->flags & PF_EXITING;\n}\n\n \nstatic inline void __ublk_complete_rq(struct request *req)\n{\n\tstruct ublk_queue *ubq = req->mq_hctx->driver_data;\n\tstruct ublk_io *io = &ubq->ios[req->tag];\n\tunsigned int unmapped_bytes;\n\tblk_status_t res = BLK_STS_OK;\n\n\t \n\tif (io->flags & UBLK_IO_FLAG_ABORTED) {\n\t\tres = BLK_STS_IOERR;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!io->res && req_op(req) == REQ_OP_READ)\n\t\tio->res = -EIO;\n\n\tif (io->res < 0) {\n\t\tres = errno_to_blk_status(io->res);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (req_op(req) != REQ_OP_READ && req_op(req) != REQ_OP_WRITE &&\n\t    req_op(req) != REQ_OP_DRV_IN)\n\t\tgoto exit;\n\n\t \n\tunmapped_bytes = ublk_unmap_io(ubq, req, io);\n\n\t \n\tif (unlikely(unmapped_bytes < io->res))\n\t\tio->res = unmapped_bytes;\n\n\tif (blk_update_request(req, BLK_STS_OK, io->res))\n\t\tblk_mq_requeue_request(req, true);\n\telse\n\t\t__blk_mq_end_request(req, BLK_STS_OK);\n\n\treturn;\nexit:\n\tblk_mq_end_request(req, res);\n}\n\nstatic void ublk_complete_rq(struct kref *ref)\n{\n\tstruct ublk_rq_data *data = container_of(ref, struct ublk_rq_data,\n\t\t\tref);\n\tstruct request *req = blk_mq_rq_from_pdu(data);\n\n\t__ublk_complete_rq(req);\n}\n\n \nstatic void __ublk_fail_req(struct ublk_queue *ubq, struct ublk_io *io,\n\t\tstruct request *req)\n{\n\tWARN_ON_ONCE(io->flags & UBLK_IO_FLAG_ACTIVE);\n\n\tif (!(io->flags & UBLK_IO_FLAG_ABORTED)) {\n\t\tio->flags |= UBLK_IO_FLAG_ABORTED;\n\t\tif (ublk_queue_can_use_recovery_reissue(ubq))\n\t\t\tblk_mq_requeue_request(req, false);\n\t\telse\n\t\t\tublk_put_req_ref(ubq, req);\n\t}\n}\n\nstatic void ubq_complete_io_cmd(struct ublk_io *io, int res,\n\t\t\t\tunsigned issue_flags)\n{\n\t \n\tio->flags |= UBLK_IO_FLAG_OWNED_BY_SRV;\n\n\t \n\tio->flags &= ~UBLK_IO_FLAG_ACTIVE;\n\n\t \n\tio_uring_cmd_done(io->cmd, res, 0, issue_flags);\n}\n\n#define UBLK_REQUEUE_DELAY_MS\t3\n\nstatic inline void __ublk_abort_rq(struct ublk_queue *ubq,\n\t\tstruct request *rq)\n{\n\t \n\tif (ublk_queue_can_use_recovery(ubq))\n\t\tblk_mq_requeue_request(rq, false);\n\telse\n\t\tblk_mq_end_request(rq, BLK_STS_IOERR);\n\n\tmod_delayed_work(system_wq, &ubq->dev->monitor_work, 0);\n}\n\nstatic inline void __ublk_rq_task_work(struct request *req,\n\t\t\t\t       unsigned issue_flags)\n{\n\tstruct ublk_queue *ubq = req->mq_hctx->driver_data;\n\tint tag = req->tag;\n\tstruct ublk_io *io = &ubq->ios[tag];\n\tunsigned int mapped_bytes;\n\n\tpr_devel(\"%s: complete: op %d, qid %d tag %d io_flags %x addr %llx\\n\",\n\t\t\t__func__, io->cmd->cmd_op, ubq->q_id, req->tag, io->flags,\n\t\t\tublk_get_iod(ubq, req->tag)->addr);\n\n\t \n\tif (unlikely(current != ubq->ubq_daemon || current->flags & PF_EXITING)) {\n\t\t__ublk_abort_rq(ubq, req);\n\t\treturn;\n\t}\n\n\tif (ublk_need_get_data(ubq) && ublk_need_map_req(req)) {\n\t\t \n\t\tif (!(io->flags & UBLK_IO_FLAG_NEED_GET_DATA)) {\n\t\t\tio->flags |= UBLK_IO_FLAG_NEED_GET_DATA;\n\t\t\tpr_devel(\"%s: need get data. op %d, qid %d tag %d io_flags %x\\n\",\n\t\t\t\t\t__func__, io->cmd->cmd_op, ubq->q_id,\n\t\t\t\t\treq->tag, io->flags);\n\t\t\tubq_complete_io_cmd(io, UBLK_IO_RES_NEED_GET_DATA, issue_flags);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tio->flags &= ~UBLK_IO_FLAG_NEED_GET_DATA;\n\t\t \n\t\tublk_get_iod(ubq, req->tag)->addr = io->addr;\n\t\tpr_devel(\"%s: update iod->addr: op %d, qid %d tag %d io_flags %x addr %llx\\n\",\n\t\t\t\t__func__, io->cmd->cmd_op, ubq->q_id, req->tag, io->flags,\n\t\t\t\tublk_get_iod(ubq, req->tag)->addr);\n\t}\n\n\tmapped_bytes = ublk_map_io(ubq, req, io);\n\n\t \n\tif (unlikely(mapped_bytes != blk_rq_bytes(req))) {\n\t\t \n\t\tif (unlikely(!mapped_bytes)) {\n\t\t\tblk_mq_requeue_request(req, false);\n\t\t\tblk_mq_delay_kick_requeue_list(req->q,\n\t\t\t\t\tUBLK_REQUEUE_DELAY_MS);\n\t\t\treturn;\n\t\t}\n\n\t\tublk_get_iod(ubq, req->tag)->nr_sectors =\n\t\t\tmapped_bytes >> 9;\n\t}\n\n\tublk_init_req_ref(ubq, req);\n\tubq_complete_io_cmd(io, UBLK_IO_RES_OK, issue_flags);\n}\n\nstatic inline void ublk_forward_io_cmds(struct ublk_queue *ubq,\n\t\t\t\t\tunsigned issue_flags)\n{\n\tstruct llist_node *io_cmds = llist_del_all(&ubq->io_cmds);\n\tstruct ublk_rq_data *data, *tmp;\n\n\tio_cmds = llist_reverse_order(io_cmds);\n\tllist_for_each_entry_safe(data, tmp, io_cmds, node)\n\t\t__ublk_rq_task_work(blk_mq_rq_from_pdu(data), issue_flags);\n}\n\nstatic inline void ublk_abort_io_cmds(struct ublk_queue *ubq)\n{\n\tstruct llist_node *io_cmds = llist_del_all(&ubq->io_cmds);\n\tstruct ublk_rq_data *data, *tmp;\n\n\tllist_for_each_entry_safe(data, tmp, io_cmds, node)\n\t\t__ublk_abort_rq(ubq, blk_mq_rq_from_pdu(data));\n}\n\nstatic void ublk_rq_task_work_cb(struct io_uring_cmd *cmd, unsigned issue_flags)\n{\n\tstruct ublk_uring_cmd_pdu *pdu = ublk_get_uring_cmd_pdu(cmd);\n\tstruct ublk_queue *ubq = pdu->ubq;\n\n\tublk_forward_io_cmds(ubq, issue_flags);\n}\n\nstatic void ublk_queue_cmd(struct ublk_queue *ubq, struct request *rq)\n{\n\tstruct ublk_rq_data *data = blk_mq_rq_to_pdu(rq);\n\tstruct ublk_io *io;\n\n\tif (!llist_add(&data->node, &ubq->io_cmds))\n\t\treturn;\n\n\tio = &ubq->ios[rq->tag];\n\t \n\tif (unlikely(io->flags & UBLK_IO_FLAG_ABORTED)) {\n\t\tublk_abort_io_cmds(ubq);\n\t} else {\n\t\tstruct io_uring_cmd *cmd = io->cmd;\n\t\tstruct ublk_uring_cmd_pdu *pdu = ublk_get_uring_cmd_pdu(cmd);\n\n\t\tpdu->ubq = ubq;\n\t\tio_uring_cmd_complete_in_task(cmd, ublk_rq_task_work_cb);\n\t}\n}\n\nstatic enum blk_eh_timer_return ublk_timeout(struct request *rq)\n{\n\tstruct ublk_queue *ubq = rq->mq_hctx->driver_data;\n\n\tif (ubq->flags & UBLK_F_UNPRIVILEGED_DEV) {\n\t\tif (!ubq->timeout) {\n\t\t\tsend_sig(SIGKILL, ubq->ubq_daemon, 0);\n\t\t\tubq->timeout = true;\n\t\t}\n\n\t\treturn BLK_EH_DONE;\n\t}\n\n\treturn BLK_EH_RESET_TIMER;\n}\n\nstatic blk_status_t ublk_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct ublk_queue *ubq = hctx->driver_data;\n\tstruct request *rq = bd->rq;\n\tblk_status_t res;\n\n\t \n\tres = ublk_setup_iod(ubq, rq);\n\tif (unlikely(res != BLK_STS_OK))\n\t\treturn BLK_STS_IOERR;\n\n\t \n\tif (ublk_queue_can_use_recovery(ubq) && unlikely(ubq->force_abort))\n\t\treturn BLK_STS_IOERR;\n\n\tblk_mq_start_request(bd->rq);\n\n\tif (unlikely(ubq_daemon_is_dying(ubq))) {\n\t\t__ublk_abort_rq(ubq, rq);\n\t\treturn BLK_STS_OK;\n\t}\n\n\tublk_queue_cmd(ubq, rq);\n\n\treturn BLK_STS_OK;\n}\n\nstatic int ublk_init_hctx(struct blk_mq_hw_ctx *hctx, void *driver_data,\n\t\tunsigned int hctx_idx)\n{\n\tstruct ublk_device *ub = driver_data;\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, hctx->queue_num);\n\n\thctx->driver_data = ubq;\n\treturn 0;\n}\n\nstatic const struct blk_mq_ops ublk_mq_ops = {\n\t.queue_rq       = ublk_queue_rq,\n\t.init_hctx\t= ublk_init_hctx,\n\t.timeout\t= ublk_timeout,\n};\n\nstatic int ublk_ch_open(struct inode *inode, struct file *filp)\n{\n\tstruct ublk_device *ub = container_of(inode->i_cdev,\n\t\t\tstruct ublk_device, cdev);\n\n\tif (test_and_set_bit(UB_STATE_OPEN, &ub->state))\n\t\treturn -EBUSY;\n\tfilp->private_data = ub;\n\treturn 0;\n}\n\nstatic int ublk_ch_release(struct inode *inode, struct file *filp)\n{\n\tstruct ublk_device *ub = filp->private_data;\n\n\tclear_bit(UB_STATE_OPEN, &ub->state);\n\treturn 0;\n}\n\n \nstatic int ublk_ch_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct ublk_device *ub = filp->private_data;\n\tsize_t sz = vma->vm_end - vma->vm_start;\n\tunsigned max_sz = UBLK_MAX_QUEUE_DEPTH * sizeof(struct ublksrv_io_desc);\n\tunsigned long pfn, end, phys_off = vma->vm_pgoff << PAGE_SHIFT;\n\tint q_id, ret = 0;\n\n\tspin_lock(&ub->mm_lock);\n\tif (!ub->mm)\n\t\tub->mm = current->mm;\n\tif (current->mm != ub->mm)\n\t\tret = -EINVAL;\n\tspin_unlock(&ub->mm_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\n\tend = UBLKSRV_CMD_BUF_OFFSET + ub->dev_info.nr_hw_queues * max_sz;\n\tif (phys_off < UBLKSRV_CMD_BUF_OFFSET || phys_off >= end)\n\t\treturn -EINVAL;\n\n\tq_id = (phys_off - UBLKSRV_CMD_BUF_OFFSET) / max_sz;\n\tpr_devel(\"%s: qid %d, pid %d, addr %lx pg_off %lx sz %lu\\n\",\n\t\t\t__func__, q_id, current->pid, vma->vm_start,\n\t\t\tphys_off, (unsigned long)sz);\n\n\tif (sz != ublk_queue_cmd_buf_size(ub, q_id))\n\t\treturn -EINVAL;\n\n\tpfn = virt_to_phys(ublk_queue_cmd_buf(ub, q_id)) >> PAGE_SHIFT;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn, sz, vma->vm_page_prot);\n}\n\nstatic void ublk_commit_completion(struct ublk_device *ub,\n\t\tconst struct ublksrv_io_cmd *ub_cmd)\n{\n\tu32 qid = ub_cmd->q_id, tag = ub_cmd->tag;\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, qid);\n\tstruct ublk_io *io = &ubq->ios[tag];\n\tstruct request *req;\n\n\t \n\tio->flags &= ~UBLK_IO_FLAG_OWNED_BY_SRV;\n\tio->res = ub_cmd->result;\n\n\t \n\treq = blk_mq_tag_to_rq(ub->tag_set.tags[qid], tag);\n\tif (WARN_ON_ONCE(unlikely(!req)))\n\t\treturn;\n\n\tif (req_op(req) == REQ_OP_ZONE_APPEND)\n\t\treq->__sector = ub_cmd->zone_append_lba;\n\n\tif (likely(!blk_should_fake_timeout(req->q)))\n\t\tublk_put_req_ref(ubq, req);\n}\n\n \nstatic void ublk_abort_queue(struct ublk_device *ub, struct ublk_queue *ubq)\n{\n\tint i;\n\n\tif (!ublk_get_device(ub))\n\t\treturn;\n\n\tfor (i = 0; i < ubq->q_depth; i++) {\n\t\tstruct ublk_io *io = &ubq->ios[i];\n\n\t\tif (!(io->flags & UBLK_IO_FLAG_ACTIVE)) {\n\t\t\tstruct request *rq;\n\n\t\t\t \n\t\t\trq = blk_mq_tag_to_rq(ub->tag_set.tags[ubq->q_id], i);\n\t\t\tif (rq)\n\t\t\t\t__ublk_fail_req(ubq, io, rq);\n\t\t}\n\t}\n\tublk_put_device(ub);\n}\n\nstatic void ublk_daemon_monitor_work(struct work_struct *work)\n{\n\tstruct ublk_device *ub =\n\t\tcontainer_of(work, struct ublk_device, monitor_work.work);\n\tint i;\n\n\tfor (i = 0; i < ub->dev_info.nr_hw_queues; i++) {\n\t\tstruct ublk_queue *ubq = ublk_get_queue(ub, i);\n\n\t\tif (ubq_daemon_is_dying(ubq)) {\n\t\t\tif (ublk_queue_can_use_recovery(ubq))\n\t\t\t\tschedule_work(&ub->quiesce_work);\n\t\t\telse\n\t\t\t\tschedule_work(&ub->stop_work);\n\n\t\t\t \n\t\t\tublk_abort_queue(ub, ubq);\n\t\t}\n\t}\n\n\t \n\tif (ub->dev_info.state == UBLK_S_DEV_LIVE)\n\t\tschedule_delayed_work(&ub->monitor_work,\n\t\t\t\tUBLK_DAEMON_MONITOR_PERIOD);\n}\n\nstatic inline bool ublk_queue_ready(struct ublk_queue *ubq)\n{\n\treturn ubq->nr_io_ready == ubq->q_depth;\n}\n\nstatic void ublk_cmd_cancel_cb(struct io_uring_cmd *cmd, unsigned issue_flags)\n{\n\tio_uring_cmd_done(cmd, UBLK_IO_RES_ABORT, 0, issue_flags);\n}\n\nstatic void ublk_cancel_queue(struct ublk_queue *ubq)\n{\n\tint i;\n\n\tif (!ublk_queue_ready(ubq))\n\t\treturn;\n\n\tfor (i = 0; i < ubq->q_depth; i++) {\n\t\tstruct ublk_io *io = &ubq->ios[i];\n\n\t\tif (io->flags & UBLK_IO_FLAG_ACTIVE)\n\t\t\tio_uring_cmd_complete_in_task(io->cmd,\n\t\t\t\t\t\t      ublk_cmd_cancel_cb);\n\t}\n\n\t \n\tubq->nr_io_ready = 0;\n}\n\n \nstatic void ublk_cancel_dev(struct ublk_device *ub)\n{\n\tint i;\n\n\tfor (i = 0; i < ub->dev_info.nr_hw_queues; i++)\n\t\tublk_cancel_queue(ublk_get_queue(ub, i));\n}\n\nstatic bool ublk_check_inflight_rq(struct request *rq, void *data)\n{\n\tbool *idle = data;\n\n\tif (blk_mq_request_started(rq)) {\n\t\t*idle = false;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void ublk_wait_tagset_rqs_idle(struct ublk_device *ub)\n{\n\tbool idle;\n\n\tWARN_ON_ONCE(!blk_queue_quiesced(ub->ub_disk->queue));\n\twhile (true) {\n\t\tidle = true;\n\t\tblk_mq_tagset_busy_iter(&ub->tag_set,\n\t\t\t\tublk_check_inflight_rq, &idle);\n\t\tif (idle)\n\t\t\tbreak;\n\t\tmsleep(UBLK_REQUEUE_DELAY_MS);\n\t}\n}\n\nstatic void __ublk_quiesce_dev(struct ublk_device *ub)\n{\n\tpr_devel(\"%s: quiesce ub: dev_id %d state %s\\n\",\n\t\t\t__func__, ub->dev_info.dev_id,\n\t\t\tub->dev_info.state == UBLK_S_DEV_LIVE ?\n\t\t\t\"LIVE\" : \"QUIESCED\");\n\tblk_mq_quiesce_queue(ub->ub_disk->queue);\n\tublk_wait_tagset_rqs_idle(ub);\n\tub->dev_info.state = UBLK_S_DEV_QUIESCED;\n\tublk_cancel_dev(ub);\n\t \n\tcancel_delayed_work_sync(&ub->monitor_work);\n}\n\nstatic void ublk_quiesce_work_fn(struct work_struct *work)\n{\n\tstruct ublk_device *ub =\n\t\tcontainer_of(work, struct ublk_device, quiesce_work);\n\n\tmutex_lock(&ub->mutex);\n\tif (ub->dev_info.state != UBLK_S_DEV_LIVE)\n\t\tgoto unlock;\n\t__ublk_quiesce_dev(ub);\n unlock:\n\tmutex_unlock(&ub->mutex);\n}\n\nstatic void ublk_unquiesce_dev(struct ublk_device *ub)\n{\n\tint i;\n\n\tpr_devel(\"%s: unquiesce ub: dev_id %d state %s\\n\",\n\t\t\t__func__, ub->dev_info.dev_id,\n\t\t\tub->dev_info.state == UBLK_S_DEV_LIVE ?\n\t\t\t\"LIVE\" : \"QUIESCED\");\n\t \n\tfor (i = 0; i < ub->dev_info.nr_hw_queues; i++)\n\t\tublk_get_queue(ub, i)->force_abort = true;\n\n\tblk_mq_unquiesce_queue(ub->ub_disk->queue);\n\t \n\tblk_mq_kick_requeue_list(ub->ub_disk->queue);\n}\n\nstatic void ublk_stop_dev(struct ublk_device *ub)\n{\n\tmutex_lock(&ub->mutex);\n\tif (ub->dev_info.state == UBLK_S_DEV_DEAD)\n\t\tgoto unlock;\n\tif (ublk_can_use_recovery(ub)) {\n\t\tif (ub->dev_info.state == UBLK_S_DEV_LIVE)\n\t\t\t__ublk_quiesce_dev(ub);\n\t\tublk_unquiesce_dev(ub);\n\t}\n\tdel_gendisk(ub->ub_disk);\n\tub->dev_info.state = UBLK_S_DEV_DEAD;\n\tub->dev_info.ublksrv_pid = -1;\n\tput_disk(ub->ub_disk);\n\tub->ub_disk = NULL;\n unlock:\n\tublk_cancel_dev(ub);\n\tmutex_unlock(&ub->mutex);\n\tcancel_delayed_work_sync(&ub->monitor_work);\n}\n\n \nstatic void ublk_mark_io_ready(struct ublk_device *ub, struct ublk_queue *ubq)\n{\n\tmutex_lock(&ub->mutex);\n\tubq->nr_io_ready++;\n\tif (ublk_queue_ready(ubq)) {\n\t\tubq->ubq_daemon = current;\n\t\tget_task_struct(ubq->ubq_daemon);\n\t\tub->nr_queues_ready++;\n\n\t\tif (capable(CAP_SYS_ADMIN))\n\t\t\tub->nr_privileged_daemon++;\n\t}\n\tif (ub->nr_queues_ready == ub->dev_info.nr_hw_queues)\n\t\tcomplete_all(&ub->completion);\n\tmutex_unlock(&ub->mutex);\n}\n\nstatic void ublk_handle_need_get_data(struct ublk_device *ub, int q_id,\n\t\tint tag)\n{\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, q_id);\n\tstruct request *req = blk_mq_tag_to_rq(ub->tag_set.tags[q_id], tag);\n\n\tublk_queue_cmd(ubq, req);\n}\n\nstatic inline int ublk_check_cmd_op(u32 cmd_op)\n{\n\tu32 ioc_type = _IOC_TYPE(cmd_op);\n\n\tif (!IS_ENABLED(CONFIG_BLKDEV_UBLK_LEGACY_OPCODES) && ioc_type != 'u')\n\t\treturn -EOPNOTSUPP;\n\n\tif (ioc_type != 'u' && ioc_type != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic inline void ublk_fill_io_cmd(struct ublk_io *io,\n\t\tstruct io_uring_cmd *cmd, unsigned long buf_addr)\n{\n\tio->cmd = cmd;\n\tio->flags |= UBLK_IO_FLAG_ACTIVE;\n\tio->addr = buf_addr;\n}\n\nstatic int __ublk_ch_uring_cmd(struct io_uring_cmd *cmd,\n\t\t\t       unsigned int issue_flags,\n\t\t\t       const struct ublksrv_io_cmd *ub_cmd)\n{\n\tstruct ublk_device *ub = cmd->file->private_data;\n\tstruct ublk_queue *ubq;\n\tstruct ublk_io *io;\n\tu32 cmd_op = cmd->cmd_op;\n\tunsigned tag = ub_cmd->tag;\n\tint ret = -EINVAL;\n\tstruct request *req;\n\n\tpr_devel(\"%s: received: cmd op %d queue %d tag %d result %d\\n\",\n\t\t\t__func__, cmd->cmd_op, ub_cmd->q_id, tag,\n\t\t\tub_cmd->result);\n\n\tif (ub_cmd->q_id >= ub->dev_info.nr_hw_queues)\n\t\tgoto out;\n\n\tubq = ublk_get_queue(ub, ub_cmd->q_id);\n\tif (!ubq || ub_cmd->q_id != ubq->q_id)\n\t\tgoto out;\n\n\tif (ubq->ubq_daemon && ubq->ubq_daemon != current)\n\t\tgoto out;\n\n\tif (tag >= ubq->q_depth)\n\t\tgoto out;\n\n\tio = &ubq->ios[tag];\n\n\t \n\tif (io->flags & UBLK_IO_FLAG_ACTIVE) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((!!(io->flags & UBLK_IO_FLAG_NEED_GET_DATA))\n\t\t\t^ (_IOC_NR(cmd_op) == UBLK_IO_NEED_GET_DATA))\n\t\tgoto out;\n\n\tret = ublk_check_cmd_op(cmd_op);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tswitch (_IOC_NR(cmd_op)) {\n\tcase UBLK_IO_FETCH_REQ:\n\t\t \n\t\tif (ublk_queue_ready(ubq)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (io->flags & UBLK_IO_FLAG_OWNED_BY_SRV)\n\t\t\tgoto out;\n\n\t\tif (!ublk_support_user_copy(ubq)) {\n\t\t\t \n\t\t\tif (!ub_cmd->addr && !ublk_need_get_data(ubq))\n\t\t\t\tgoto out;\n\t\t} else if (ub_cmd->addr) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tublk_fill_io_cmd(io, cmd, ub_cmd->addr);\n\t\tublk_mark_io_ready(ub, ubq);\n\t\tbreak;\n\tcase UBLK_IO_COMMIT_AND_FETCH_REQ:\n\t\treq = blk_mq_tag_to_rq(ub->tag_set.tags[ub_cmd->q_id], tag);\n\n\t\tif (!(io->flags & UBLK_IO_FLAG_OWNED_BY_SRV))\n\t\t\tgoto out;\n\n\t\tif (!ublk_support_user_copy(ubq)) {\n\t\t\t \n\t\t\tif (!ub_cmd->addr && (!ublk_need_get_data(ubq) ||\n\t\t\t\t\t\treq_op(req) == REQ_OP_READ))\n\t\t\t\tgoto out;\n\t\t} else if (req_op(req) != REQ_OP_ZONE_APPEND && ub_cmd->addr) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tublk_fill_io_cmd(io, cmd, ub_cmd->addr);\n\t\tublk_commit_completion(ub, ub_cmd);\n\t\tbreak;\n\tcase UBLK_IO_NEED_GET_DATA:\n\t\tif (!(io->flags & UBLK_IO_FLAG_OWNED_BY_SRV))\n\t\t\tgoto out;\n\t\tublk_fill_io_cmd(io, cmd, ub_cmd->addr);\n\t\tublk_handle_need_get_data(ub, ub_cmd->q_id, ub_cmd->tag);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\treturn -EIOCBQUEUED;\n\n out:\n\tio_uring_cmd_done(cmd, ret, 0, issue_flags);\n\tpr_devel(\"%s: complete: cmd op %d, tag %d ret %x io_flags %x\\n\",\n\t\t\t__func__, cmd_op, tag, ret, io->flags);\n\treturn -EIOCBQUEUED;\n}\n\nstatic inline struct request *__ublk_check_and_get_req(struct ublk_device *ub,\n\t\tstruct ublk_queue *ubq, int tag, size_t offset)\n{\n\tstruct request *req;\n\n\tif (!ublk_need_req_ref(ubq))\n\t\treturn NULL;\n\n\treq = blk_mq_tag_to_rq(ub->tag_set.tags[ubq->q_id], tag);\n\tif (!req)\n\t\treturn NULL;\n\n\tif (!ublk_get_req_ref(ubq, req))\n\t\treturn NULL;\n\n\tif (unlikely(!blk_mq_request_started(req) || req->tag != tag))\n\t\tgoto fail_put;\n\n\tif (!ublk_rq_has_data(req))\n\t\tgoto fail_put;\n\n\tif (offset > blk_rq_bytes(req))\n\t\tgoto fail_put;\n\n\treturn req;\nfail_put:\n\tublk_put_req_ref(ubq, req);\n\treturn NULL;\n}\n\nstatic int ublk_ch_uring_cmd(struct io_uring_cmd *cmd, unsigned int issue_flags)\n{\n\t \n\tconst struct ublksrv_io_cmd *ub_src = io_uring_sqe_cmd(cmd->sqe);\n\tconst struct ublksrv_io_cmd ub_cmd = {\n\t\t.q_id = READ_ONCE(ub_src->q_id),\n\t\t.tag = READ_ONCE(ub_src->tag),\n\t\t.result = READ_ONCE(ub_src->result),\n\t\t.addr = READ_ONCE(ub_src->addr)\n\t};\n\n\treturn __ublk_ch_uring_cmd(cmd, issue_flags, &ub_cmd);\n}\n\nstatic inline bool ublk_check_ubuf_dir(const struct request *req,\n\t\tint ubuf_dir)\n{\n\t \n\tif ((req_op(req) == REQ_OP_READ || req_op(req) == REQ_OP_DRV_IN) &&\n\t    ubuf_dir == ITER_SOURCE)\n\t\treturn true;\n\n\t \n\tif ((req_op(req) == REQ_OP_WRITE ||\n\t     req_op(req) == REQ_OP_ZONE_APPEND) &&\n\t    ubuf_dir == ITER_DEST)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct request *ublk_check_and_get_req(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, size_t *off, int dir)\n{\n\tstruct ublk_device *ub = iocb->ki_filp->private_data;\n\tstruct ublk_queue *ubq;\n\tstruct request *req;\n\tsize_t buf_off;\n\tu16 tag, q_id;\n\n\tif (!ub)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (!user_backed_iter(iter))\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (ub->dev_info.state == UBLK_S_DEV_DEAD)\n\t\treturn ERR_PTR(-EACCES);\n\n\ttag = ublk_pos_to_tag(iocb->ki_pos);\n\tq_id = ublk_pos_to_hwq(iocb->ki_pos);\n\tbuf_off = ublk_pos_to_buf_off(iocb->ki_pos);\n\n\tif (q_id >= ub->dev_info.nr_hw_queues)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tubq = ublk_get_queue(ub, q_id);\n\tif (!ubq)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tag >= ubq->q_depth)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treq = __ublk_check_and_get_req(ub, ubq, tag, buf_off);\n\tif (!req)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!req->mq_hctx || !req->mq_hctx->driver_data)\n\t\tgoto fail;\n\n\tif (!ublk_check_ubuf_dir(req, dir))\n\t\tgoto fail;\n\n\t*off = buf_off;\n\treturn req;\nfail:\n\tublk_put_req_ref(ubq, req);\n\treturn ERR_PTR(-EACCES);\n}\n\nstatic ssize_t ublk_ch_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct ublk_queue *ubq;\n\tstruct request *req;\n\tsize_t buf_off;\n\tsize_t ret;\n\n\treq = ublk_check_and_get_req(iocb, to, &buf_off, ITER_DEST);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = ublk_copy_user_pages(req, buf_off, to, ITER_DEST);\n\tubq = req->mq_hctx->driver_data;\n\tublk_put_req_ref(ubq, req);\n\n\treturn ret;\n}\n\nstatic ssize_t ublk_ch_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct ublk_queue *ubq;\n\tstruct request *req;\n\tsize_t buf_off;\n\tsize_t ret;\n\n\treq = ublk_check_and_get_req(iocb, from, &buf_off, ITER_SOURCE);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = ublk_copy_user_pages(req, buf_off, from, ITER_SOURCE);\n\tubq = req->mq_hctx->driver_data;\n\tublk_put_req_ref(ubq, req);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ublk_ch_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ublk_ch_open,\n\t.release = ublk_ch_release,\n\t.llseek = no_llseek,\n\t.read_iter = ublk_ch_read_iter,\n\t.write_iter = ublk_ch_write_iter,\n\t.uring_cmd = ublk_ch_uring_cmd,\n\t.mmap = ublk_ch_mmap,\n};\n\nstatic void ublk_deinit_queue(struct ublk_device *ub, int q_id)\n{\n\tint size = ublk_queue_cmd_buf_size(ub, q_id);\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, q_id);\n\n\tif (ubq->ubq_daemon)\n\t\tput_task_struct(ubq->ubq_daemon);\n\tif (ubq->io_cmd_buf)\n\t\tfree_pages((unsigned long)ubq->io_cmd_buf, get_order(size));\n}\n\nstatic int ublk_init_queue(struct ublk_device *ub, int q_id)\n{\n\tstruct ublk_queue *ubq = ublk_get_queue(ub, q_id);\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO;\n\tvoid *ptr;\n\tint size;\n\n\tubq->flags = ub->dev_info.flags;\n\tubq->q_id = q_id;\n\tubq->q_depth = ub->dev_info.queue_depth;\n\tsize = ublk_queue_cmd_buf_size(ub, q_id);\n\n\tptr = (void *) __get_free_pages(gfp_flags, get_order(size));\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tubq->io_cmd_buf = ptr;\n\tubq->dev = ub;\n\treturn 0;\n}\n\nstatic void ublk_deinit_queues(struct ublk_device *ub)\n{\n\tint nr_queues = ub->dev_info.nr_hw_queues;\n\tint i;\n\n\tif (!ub->__queues)\n\t\treturn;\n\n\tfor (i = 0; i < nr_queues; i++)\n\t\tublk_deinit_queue(ub, i);\n\tkfree(ub->__queues);\n}\n\nstatic int ublk_init_queues(struct ublk_device *ub)\n{\n\tint nr_queues = ub->dev_info.nr_hw_queues;\n\tint depth = ub->dev_info.queue_depth;\n\tint ubq_size = sizeof(struct ublk_queue) + depth * sizeof(struct ublk_io);\n\tint i, ret = -ENOMEM;\n\n\tub->queue_size = ubq_size;\n\tub->__queues = kcalloc(nr_queues, ubq_size, GFP_KERNEL);\n\tif (!ub->__queues)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_queues; i++) {\n\t\tif (ublk_init_queue(ub, i))\n\t\t\tgoto fail;\n\t}\n\n\tinit_completion(&ub->completion);\n\treturn 0;\n\n fail:\n\tublk_deinit_queues(ub);\n\treturn ret;\n}\n\nstatic int ublk_alloc_dev_number(struct ublk_device *ub, int idx)\n{\n\tint i = idx;\n\tint err;\n\n\tspin_lock(&ublk_idr_lock);\n\t \n\tif (i >= 0) {\n\t\terr = idr_alloc(&ublk_index_idr, ub, i, i + 1, GFP_NOWAIT);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&ublk_index_idr, ub, 0, 0, GFP_NOWAIT);\n\t}\n\tspin_unlock(&ublk_idr_lock);\n\n\tif (err >= 0)\n\t\tub->ub_number = err;\n\n\treturn err;\n}\n\nstatic void ublk_free_dev_number(struct ublk_device *ub)\n{\n\tspin_lock(&ublk_idr_lock);\n\tidr_remove(&ublk_index_idr, ub->ub_number);\n\twake_up_all(&ublk_idr_wq);\n\tspin_unlock(&ublk_idr_lock);\n}\n\nstatic void ublk_cdev_rel(struct device *dev)\n{\n\tstruct ublk_device *ub = container_of(dev, struct ublk_device, cdev_dev);\n\n\tblk_mq_free_tag_set(&ub->tag_set);\n\tublk_deinit_queues(ub);\n\tublk_free_dev_number(ub);\n\tmutex_destroy(&ub->mutex);\n\tkfree(ub);\n}\n\nstatic int ublk_add_chdev(struct ublk_device *ub)\n{\n\tstruct device *dev = &ub->cdev_dev;\n\tint minor = ub->ub_number;\n\tint ret;\n\n\tdev->parent = ublk_misc.this_device;\n\tdev->devt = MKDEV(MAJOR(ublk_chr_devt), minor);\n\tdev->class = &ublk_chr_class;\n\tdev->release = ublk_cdev_rel;\n\tdevice_initialize(dev);\n\n\tret = dev_set_name(dev, \"ublkc%d\", minor);\n\tif (ret)\n\t\tgoto fail;\n\n\tcdev_init(&ub->cdev, &ublk_ch_fops);\n\tret = cdev_device_add(&ub->cdev, dev);\n\tif (ret)\n\t\tgoto fail;\n\n\tublks_added++;\n\treturn 0;\n fail:\n\tput_device(dev);\n\treturn ret;\n}\n\nstatic void ublk_stop_work_fn(struct work_struct *work)\n{\n\tstruct ublk_device *ub =\n\t\tcontainer_of(work, struct ublk_device, stop_work);\n\n\tublk_stop_dev(ub);\n}\n\n \nstatic void ublk_align_max_io_size(struct ublk_device *ub)\n{\n\tunsigned int max_io_bytes = ub->dev_info.max_io_buf_bytes;\n\n\tub->dev_info.max_io_buf_bytes =\n\t\tround_down(max_io_bytes, PAGE_SIZE);\n}\n\nstatic int ublk_add_tag_set(struct ublk_device *ub)\n{\n\tub->tag_set.ops = &ublk_mq_ops;\n\tub->tag_set.nr_hw_queues = ub->dev_info.nr_hw_queues;\n\tub->tag_set.queue_depth = ub->dev_info.queue_depth;\n\tub->tag_set.numa_node = NUMA_NO_NODE;\n\tub->tag_set.cmd_size = sizeof(struct ublk_rq_data);\n\tub->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\tub->tag_set.driver_data = ub;\n\treturn blk_mq_alloc_tag_set(&ub->tag_set);\n}\n\nstatic void ublk_remove(struct ublk_device *ub)\n{\n\tublk_stop_dev(ub);\n\tcancel_work_sync(&ub->stop_work);\n\tcancel_work_sync(&ub->quiesce_work);\n\tcdev_device_del(&ub->cdev, &ub->cdev_dev);\n\tput_device(&ub->cdev_dev);\n\tublks_added--;\n}\n\nstatic struct ublk_device *ublk_get_device_from_id(int idx)\n{\n\tstruct ublk_device *ub = NULL;\n\n\tif (idx < 0)\n\t\treturn NULL;\n\n\tspin_lock(&ublk_idr_lock);\n\tub = idr_find(&ublk_index_idr, idx);\n\tif (ub)\n\t\tub = ublk_get_device(ub);\n\tspin_unlock(&ublk_idr_lock);\n\n\treturn ub;\n}\n\nstatic int ublk_ctrl_start_dev(struct ublk_device *ub, struct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tint ublksrv_pid = (int)header->data[0];\n\tstruct gendisk *disk;\n\tint ret = -EINVAL;\n\n\tif (ublksrv_pid <= 0)\n\t\treturn -EINVAL;\n\n\tif (wait_for_completion_interruptible(&ub->completion) != 0)\n\t\treturn -EINTR;\n\n\tschedule_delayed_work(&ub->monitor_work, UBLK_DAEMON_MONITOR_PERIOD);\n\n\tmutex_lock(&ub->mutex);\n\tif (ub->dev_info.state == UBLK_S_DEV_LIVE ||\n\t    test_bit(UB_STATE_USED, &ub->state)) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tdisk = blk_mq_alloc_disk(&ub->tag_set, NULL);\n\tif (IS_ERR(disk)) {\n\t\tret = PTR_ERR(disk);\n\t\tgoto out_unlock;\n\t}\n\tsprintf(disk->disk_name, \"ublkb%d\", ub->ub_number);\n\tdisk->fops = &ub_fops;\n\tdisk->private_data = ub;\n\n\tub->dev_info.ublksrv_pid = ublksrv_pid;\n\tub->ub_disk = disk;\n\n\tret = ublk_apply_params(ub);\n\tif (ret)\n\t\tgoto out_put_disk;\n\n\t \n\tif (ub->nr_privileged_daemon != ub->nr_queues_ready)\n\t\tset_bit(GD_SUPPRESS_PART_SCAN, &disk->state);\n\n\tget_device(&ub->cdev_dev);\n\tub->dev_info.state = UBLK_S_DEV_LIVE;\n\n\tif (ublk_dev_is_zoned(ub)) {\n\t\tret = ublk_revalidate_disk_zones(ub);\n\t\tif (ret)\n\t\t\tgoto out_put_cdev;\n\t}\n\n\tret = add_disk(disk);\n\tif (ret)\n\t\tgoto out_put_cdev;\n\n\tset_bit(UB_STATE_USED, &ub->state);\n\nout_put_cdev:\n\tif (ret) {\n\t\tub->dev_info.state = UBLK_S_DEV_DEAD;\n\t\tublk_put_device(ub);\n\t}\nout_put_disk:\n\tif (ret)\n\t\tput_disk(disk);\nout_unlock:\n\tmutex_unlock(&ub->mutex);\n\treturn ret;\n}\n\nstatic int ublk_ctrl_get_queue_affinity(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tcpumask_var_t cpumask;\n\tunsigned long queue;\n\tunsigned int retlen;\n\tunsigned int i;\n\tint ret;\n\n\tif (header->len * BITS_PER_BYTE < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (header->len & (sizeof(unsigned long)-1))\n\t\treturn -EINVAL;\n\tif (!header->addr)\n\t\treturn -EINVAL;\n\n\tqueue = header->data[0];\n\tif (queue >= ub->dev_info.nr_hw_queues)\n\t\treturn -EINVAL;\n\n\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\tif (ub->tag_set.map[HCTX_TYPE_DEFAULT].mq_map[i] == queue)\n\t\t\tcpumask_set_cpu(i, cpumask);\n\t}\n\n\tret = -EFAULT;\n\tretlen = min_t(unsigned short, header->len, cpumask_size());\n\tif (copy_to_user(argp, cpumask, retlen))\n\t\tgoto out_free_cpumask;\n\tif (retlen != header->len &&\n\t    clear_user(argp + retlen, header->len - retlen))\n\t\tgoto out_free_cpumask;\n\n\tret = 0;\nout_free_cpumask:\n\tfree_cpumask_var(cpumask);\n\treturn ret;\n}\n\nstatic inline void ublk_dump_dev_info(struct ublksrv_ctrl_dev_info *info)\n{\n\tpr_devel(\"%s: dev id %d flags %llx\\n\", __func__,\n\t\t\tinfo->dev_id, info->flags);\n\tpr_devel(\"\\t nr_hw_queues %d queue_depth %d\\n\",\n\t\t\tinfo->nr_hw_queues, info->queue_depth);\n}\n\nstatic int ublk_ctrl_add_dev(struct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tstruct ublksrv_ctrl_dev_info info;\n\tstruct ublk_device *ub;\n\tint ret = -EINVAL;\n\n\tif (header->len < sizeof(info) || !header->addr)\n\t\treturn -EINVAL;\n\tif (header->queue_id != (u16)-1) {\n\t\tpr_warn(\"%s: queue_id is wrong %x\\n\",\n\t\t\t__func__, header->queue_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&info, argp, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (capable(CAP_SYS_ADMIN))\n\t\tinfo.flags &= ~UBLK_F_UNPRIVILEGED_DEV;\n\telse if (!(info.flags & UBLK_F_UNPRIVILEGED_DEV))\n\t\treturn -EPERM;\n\n\t \n\tif (info.flags & UBLK_F_UNPRIVILEGED_DEV)\n\t\tinfo.flags &= ~(UBLK_F_USER_RECOVERY_REISSUE |\n\t\t\t\tUBLK_F_USER_RECOVERY);\n\n\t \n\tublk_store_owner_uid_gid(&info.owner_uid, &info.owner_gid);\n\n\tif (header->dev_id != info.dev_id) {\n\t\tpr_warn(\"%s: dev id not match %u %u\\n\",\n\t\t\t__func__, header->dev_id, info.dev_id);\n\t\treturn -EINVAL;\n\t}\n\n\tublk_dump_dev_info(&info);\n\n\tret = mutex_lock_killable(&ublk_ctl_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EACCES;\n\tif (ublks_added >= ublks_max)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tub = kzalloc(sizeof(*ub), GFP_KERNEL);\n\tif (!ub)\n\t\tgoto out_unlock;\n\tmutex_init(&ub->mutex);\n\tspin_lock_init(&ub->mm_lock);\n\tINIT_WORK(&ub->quiesce_work, ublk_quiesce_work_fn);\n\tINIT_WORK(&ub->stop_work, ublk_stop_work_fn);\n\tINIT_DELAYED_WORK(&ub->monitor_work, ublk_daemon_monitor_work);\n\n\tret = ublk_alloc_dev_number(ub, header->dev_id);\n\tif (ret < 0)\n\t\tgoto out_free_ub;\n\n\tmemcpy(&ub->dev_info, &info, sizeof(info));\n\n\t \n\tub->dev_info.dev_id = ub->ub_number;\n\n\t \n\tub->dev_info.flags &= UBLK_F_ALL;\n\n\tub->dev_info.flags |= UBLK_F_CMD_IOCTL_ENCODE |\n\t\tUBLK_F_URING_CMD_COMP_IN_TASK;\n\n\t \n\tif (ublk_dev_is_user_copy(ub))\n\t\tub->dev_info.flags &= ~UBLK_F_NEED_GET_DATA;\n\n\t \n\tif (ublk_dev_is_zoned(ub) &&\n\t    (!IS_ENABLED(CONFIG_BLK_DEV_ZONED) || !ublk_dev_is_user_copy(ub))) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_dev_number;\n\t}\n\n\t \n\tub->dev_info.flags &= ~UBLK_F_SUPPORT_ZERO_COPY;\n\n\tub->dev_info.nr_hw_queues = min_t(unsigned int,\n\t\t\tub->dev_info.nr_hw_queues, nr_cpu_ids);\n\tublk_align_max_io_size(ub);\n\n\tret = ublk_init_queues(ub);\n\tif (ret)\n\t\tgoto out_free_dev_number;\n\n\tret = ublk_add_tag_set(ub);\n\tif (ret)\n\t\tgoto out_deinit_queues;\n\n\tret = -EFAULT;\n\tif (copy_to_user(argp, &ub->dev_info, sizeof(info)))\n\t\tgoto out_free_tag_set;\n\n\t \n\tret = ublk_add_chdev(ub);\n\tgoto out_unlock;\n\nout_free_tag_set:\n\tblk_mq_free_tag_set(&ub->tag_set);\nout_deinit_queues:\n\tublk_deinit_queues(ub);\nout_free_dev_number:\n\tublk_free_dev_number(ub);\nout_free_ub:\n\tmutex_destroy(&ub->mutex);\n\tkfree(ub);\nout_unlock:\n\tmutex_unlock(&ublk_ctl_mutex);\n\treturn ret;\n}\n\nstatic inline bool ublk_idr_freed(int id)\n{\n\tvoid *ptr;\n\n\tspin_lock(&ublk_idr_lock);\n\tptr = idr_find(&ublk_index_idr, id);\n\tspin_unlock(&ublk_idr_lock);\n\n\treturn ptr == NULL;\n}\n\nstatic int ublk_ctrl_del_dev(struct ublk_device **p_ub)\n{\n\tstruct ublk_device *ub = *p_ub;\n\tint idx = ub->ub_number;\n\tint ret;\n\n\tret = mutex_lock_killable(&ublk_ctl_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!test_bit(UB_STATE_DELETED, &ub->state)) {\n\t\tublk_remove(ub);\n\t\tset_bit(UB_STATE_DELETED, &ub->state);\n\t}\n\n\t \n\t*p_ub = NULL;\n\tublk_put_device(ub);\n\tmutex_unlock(&ublk_ctl_mutex);\n\n\t \n\tif (wait_event_interruptible(ublk_idr_wq, ublk_idr_freed(idx)))\n\t\treturn -EINTR;\n\treturn 0;\n}\n\nstatic inline void ublk_ctrl_cmd_dump(struct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\n\tpr_devel(\"%s: cmd_op %x, dev id %d qid %d data %llx buf %llx len %u\\n\",\n\t\t\t__func__, cmd->cmd_op, header->dev_id, header->queue_id,\n\t\t\theader->data[0], header->addr, header->len);\n}\n\nstatic int ublk_ctrl_stop_dev(struct ublk_device *ub)\n{\n\tublk_stop_dev(ub);\n\tcancel_work_sync(&ub->stop_work);\n\tcancel_work_sync(&ub->quiesce_work);\n\n\treturn 0;\n}\n\nstatic int ublk_ctrl_get_dev_info(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\n\tif (header->len < sizeof(struct ublksrv_ctrl_dev_info) || !header->addr)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(argp, &ub->dev_info, sizeof(ub->dev_info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic void ublk_ctrl_fill_params_devt(struct ublk_device *ub)\n{\n\tub->params.devt.char_major = MAJOR(ub->cdev_dev.devt);\n\tub->params.devt.char_minor = MINOR(ub->cdev_dev.devt);\n\n\tif (ub->ub_disk) {\n\t\tub->params.devt.disk_major = MAJOR(disk_devt(ub->ub_disk));\n\t\tub->params.devt.disk_minor = MINOR(disk_devt(ub->ub_disk));\n\t} else {\n\t\tub->params.devt.disk_major = 0;\n\t\tub->params.devt.disk_minor = 0;\n\t}\n\tub->params.types |= UBLK_PARAM_TYPE_DEVT;\n}\n\nstatic int ublk_ctrl_get_params(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tstruct ublk_params_header ph;\n\tint ret;\n\n\tif (header->len <= sizeof(ph) || !header->addr)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&ph, argp, sizeof(ph)))\n\t\treturn -EFAULT;\n\n\tif (ph.len > header->len || !ph.len)\n\t\treturn -EINVAL;\n\n\tif (ph.len > sizeof(struct ublk_params))\n\t\tph.len = sizeof(struct ublk_params);\n\n\tmutex_lock(&ub->mutex);\n\tublk_ctrl_fill_params_devt(ub);\n\tif (copy_to_user(argp, &ub->params, ph.len))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n\tmutex_unlock(&ub->mutex);\n\n\treturn ret;\n}\n\nstatic int ublk_ctrl_set_params(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tstruct ublk_params_header ph;\n\tint ret = -EFAULT;\n\n\tif (header->len <= sizeof(ph) || !header->addr)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&ph, argp, sizeof(ph)))\n\t\treturn -EFAULT;\n\n\tif (ph.len > header->len || !ph.len || !ph.types)\n\t\treturn -EINVAL;\n\n\tif (ph.len > sizeof(struct ublk_params))\n\t\tph.len = sizeof(struct ublk_params);\n\n\t \n\tmutex_lock(&ub->mutex);\n\tif (ub->dev_info.state == UBLK_S_DEV_LIVE) {\n\t\tret = -EACCES;\n\t} else if (copy_from_user(&ub->params, argp, ph.len)) {\n\t\tret = -EFAULT;\n\t} else {\n\t\t \n\t\tub->params.types &= UBLK_PARAM_TYPE_ALL;\n\t\tret = ublk_validate_params(ub);\n\t\tif (ret)\n\t\t\tub->params.types = 0;\n\t}\n\tmutex_unlock(&ub->mutex);\n\n\treturn ret;\n}\n\nstatic void ublk_queue_reinit(struct ublk_device *ub, struct ublk_queue *ubq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!(ubq->ubq_daemon && ubq_daemon_is_dying(ubq)));\n\t \n\tWARN_ON_ONCE(ubq->nr_io_ready);\n\t \n\tput_task_struct(ubq->ubq_daemon);\n\t \n\tubq->ubq_daemon = NULL;\n\tubq->timeout = false;\n\n\tfor (i = 0; i < ubq->q_depth; i++) {\n\t\tstruct ublk_io *io = &ubq->ios[i];\n\n\t\t \n\t\tio->flags = 0;\n\t\tio->cmd = NULL;\n\t\tio->addr = 0;\n\t}\n}\n\nstatic int ublk_ctrl_start_recovery(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tint ret = -EINVAL;\n\tint i;\n\n\tmutex_lock(&ub->mutex);\n\tif (!ublk_can_use_recovery(ub))\n\t\tgoto out_unlock;\n\t \n\tif (test_bit(UB_STATE_OPEN, &ub->state) ||\n\t\t\tub->dev_info.state != UBLK_S_DEV_QUIESCED) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tpr_devel(\"%s: start recovery for dev id %d.\\n\", __func__, header->dev_id);\n\tfor (i = 0; i < ub->dev_info.nr_hw_queues; i++)\n\t\tublk_queue_reinit(ub, ublk_get_queue(ub, i));\n\t \n\tub->mm = NULL;\n\tub->nr_queues_ready = 0;\n\tub->nr_privileged_daemon = 0;\n\tinit_completion(&ub->completion);\n\tret = 0;\n out_unlock:\n\tmutex_unlock(&ub->mutex);\n\treturn ret;\n}\n\nstatic int ublk_ctrl_end_recovery(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tint ublksrv_pid = (int)header->data[0];\n\tint ret = -EINVAL;\n\n\tpr_devel(\"%s: Waiting for new ubq_daemons(nr: %d) are ready, dev id %d...\\n\",\n\t\t\t__func__, ub->dev_info.nr_hw_queues, header->dev_id);\n\t \n\tif (wait_for_completion_interruptible(&ub->completion))\n\t\treturn -EINTR;\n\n\tpr_devel(\"%s: All new ubq_daemons(nr: %d) are ready, dev id %d\\n\",\n\t\t\t__func__, ub->dev_info.nr_hw_queues, header->dev_id);\n\n\tmutex_lock(&ub->mutex);\n\tif (!ublk_can_use_recovery(ub))\n\t\tgoto out_unlock;\n\n\tif (ub->dev_info.state != UBLK_S_DEV_QUIESCED) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tub->dev_info.ublksrv_pid = ublksrv_pid;\n\tpr_devel(\"%s: new ublksrv_pid %d, dev id %d\\n\",\n\t\t\t__func__, ublksrv_pid, header->dev_id);\n\tblk_mq_unquiesce_queue(ub->ub_disk->queue);\n\tpr_devel(\"%s: queue unquiesced, dev id %d.\\n\",\n\t\t\t__func__, header->dev_id);\n\tblk_mq_kick_requeue_list(ub->ub_disk->queue);\n\tub->dev_info.state = UBLK_S_DEV_LIVE;\n\tschedule_delayed_work(&ub->monitor_work, UBLK_DAEMON_MONITOR_PERIOD);\n\tret = 0;\n out_unlock:\n\tmutex_unlock(&ub->mutex);\n\treturn ret;\n}\n\nstatic int ublk_ctrl_get_features(struct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tu64 features = UBLK_F_ALL & ~UBLK_F_SUPPORT_ZERO_COPY;\n\n\tif (header->len != UBLK_FEATURES_LEN || !header->addr)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(argp, &features, UBLK_FEATURES_LEN))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ublk_char_dev_permission(struct ublk_device *ub,\n\t\tconst char *dev_path, int mask)\n{\n\tint err;\n\tstruct path path;\n\tstruct kstat stat;\n\n\terr = kern_path(dev_path, LOOKUP_FOLLOW, &path);\n\tif (err)\n\t\treturn err;\n\n\terr = vfs_getattr(&path, &stat, STATX_TYPE, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tgoto exit;\n\n\terr = -EPERM;\n\tif (stat.rdev != ub->cdev_dev.devt || !S_ISCHR(stat.mode))\n\t\tgoto exit;\n\n\terr = inode_permission(&nop_mnt_idmap,\n\t\t\td_backing_inode(path.dentry), mask);\nexit:\n\tpath_put(&path);\n\treturn err;\n}\n\nstatic int ublk_ctrl_uring_cmd_permission(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tstruct ublksrv_ctrl_cmd *header = (struct ublksrv_ctrl_cmd *)io_uring_sqe_cmd(cmd->sqe);\n\tbool unprivileged = ub->dev_info.flags & UBLK_F_UNPRIVILEGED_DEV;\n\tvoid __user *argp = (void __user *)(unsigned long)header->addr;\n\tchar *dev_path = NULL;\n\tint ret = 0;\n\tint mask;\n\n\tif (!unprivileged) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\t \n\t\tif (_IOC_NR(cmd->cmd_op) != UBLK_CMD_GET_DEV_INFO2)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!header->dev_path_len || header->dev_path_len > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tif (header->len < header->dev_path_len)\n\t\treturn -EINVAL;\n\n\tdev_path = memdup_user_nul(argp, header->dev_path_len);\n\tif (IS_ERR(dev_path))\n\t\treturn PTR_ERR(dev_path);\n\n\tret = -EINVAL;\n\tswitch (_IOC_NR(cmd->cmd_op)) {\n\tcase UBLK_CMD_GET_DEV_INFO:\n\tcase UBLK_CMD_GET_DEV_INFO2:\n\tcase UBLK_CMD_GET_QUEUE_AFFINITY:\n\tcase UBLK_CMD_GET_PARAMS:\n\tcase (_IOC_NR(UBLK_U_CMD_GET_FEATURES)):\n\t\tmask = MAY_READ;\n\t\tbreak;\n\tcase UBLK_CMD_START_DEV:\n\tcase UBLK_CMD_STOP_DEV:\n\tcase UBLK_CMD_ADD_DEV:\n\tcase UBLK_CMD_DEL_DEV:\n\tcase UBLK_CMD_SET_PARAMS:\n\tcase UBLK_CMD_START_USER_RECOVERY:\n\tcase UBLK_CMD_END_USER_RECOVERY:\n\t\tmask = MAY_READ | MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tret = ublk_char_dev_permission(ub, dev_path, mask);\n\tif (!ret) {\n\t\theader->len -= header->dev_path_len;\n\t\theader->addr += header->dev_path_len;\n\t}\n\tpr_devel(\"%s: dev id %d cmd_op %x uid %d gid %d path %s ret %d\\n\",\n\t\t\t__func__, ub->ub_number, cmd->cmd_op,\n\t\t\tub->dev_info.owner_uid, ub->dev_info.owner_gid,\n\t\t\tdev_path, ret);\nexit:\n\tkfree(dev_path);\n\treturn ret;\n}\n\nstatic int ublk_ctrl_uring_cmd(struct io_uring_cmd *cmd,\n\t\tunsigned int issue_flags)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tstruct ublk_device *ub = NULL;\n\tu32 cmd_op = cmd->cmd_op;\n\tint ret = -EINVAL;\n\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tublk_ctrl_cmd_dump(cmd);\n\n\tif (!(issue_flags & IO_URING_F_SQE128))\n\t\tgoto out;\n\n\tret = ublk_check_cmd_op(cmd_op);\n\tif (ret)\n\t\tgoto out;\n\n\tif (cmd_op == UBLK_U_CMD_GET_FEATURES) {\n\t\tret = ublk_ctrl_get_features(cmd);\n\t\tgoto out;\n\t}\n\n\tif (_IOC_NR(cmd_op) != UBLK_CMD_ADD_DEV) {\n\t\tret = -ENODEV;\n\t\tub = ublk_get_device_from_id(header->dev_id);\n\t\tif (!ub)\n\t\t\tgoto out;\n\n\t\tret = ublk_ctrl_uring_cmd_permission(ub, cmd);\n\t\tif (ret)\n\t\t\tgoto put_dev;\n\t}\n\n\tswitch (_IOC_NR(cmd_op)) {\n\tcase UBLK_CMD_START_DEV:\n\t\tret = ublk_ctrl_start_dev(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_STOP_DEV:\n\t\tret = ublk_ctrl_stop_dev(ub);\n\t\tbreak;\n\tcase UBLK_CMD_GET_DEV_INFO:\n\tcase UBLK_CMD_GET_DEV_INFO2:\n\t\tret = ublk_ctrl_get_dev_info(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_ADD_DEV:\n\t\tret = ublk_ctrl_add_dev(cmd);\n\t\tbreak;\n\tcase UBLK_CMD_DEL_DEV:\n\t\tret = ublk_ctrl_del_dev(&ub);\n\t\tbreak;\n\tcase UBLK_CMD_GET_QUEUE_AFFINITY:\n\t\tret = ublk_ctrl_get_queue_affinity(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_GET_PARAMS:\n\t\tret = ublk_ctrl_get_params(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_SET_PARAMS:\n\t\tret = ublk_ctrl_set_params(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_START_USER_RECOVERY:\n\t\tret = ublk_ctrl_start_recovery(ub, cmd);\n\t\tbreak;\n\tcase UBLK_CMD_END_USER_RECOVERY:\n\t\tret = ublk_ctrl_end_recovery(ub, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n put_dev:\n\tif (ub)\n\t\tublk_put_device(ub);\n out:\n\tio_uring_cmd_done(cmd, ret, 0, issue_flags);\n\tpr_devel(\"%s: cmd done ret %d cmd_op %x, dev id %d qid %d\\n\",\n\t\t\t__func__, ret, cmd->cmd_op, header->dev_id, header->queue_id);\n\treturn -EIOCBQUEUED;\n}\n\nstatic const struct file_operations ublk_ctl_fops = {\n\t.open\t\t= nonseekable_open,\n\t.uring_cmd      = ublk_ctrl_uring_cmd,\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice ublk_misc = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ublk-control\",\n\t.fops\t\t= &ublk_ctl_fops,\n};\n\nstatic int __init ublk_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON((u64)UBLKSRV_IO_BUF_OFFSET +\n\t\t\tUBLKSRV_IO_BUF_TOTAL_SIZE < UBLKSRV_IO_BUF_OFFSET);\n\n\tinit_waitqueue_head(&ublk_idr_wq);\n\n\tret = misc_register(&ublk_misc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_chrdev_region(&ublk_chr_devt, 0, UBLK_MINORS, \"ublk-char\");\n\tif (ret)\n\t\tgoto unregister_mis;\n\n\tret = class_register(&ublk_chr_class);\n\tif (ret)\n\t\tgoto free_chrdev_region;\n\n\treturn 0;\n\nfree_chrdev_region:\n\tunregister_chrdev_region(ublk_chr_devt, UBLK_MINORS);\nunregister_mis:\n\tmisc_deregister(&ublk_misc);\n\treturn ret;\n}\n\nstatic void __exit ublk_exit(void)\n{\n\tstruct ublk_device *ub;\n\tint id;\n\n\tidr_for_each_entry(&ublk_index_idr, ub, id)\n\t\tublk_remove(ub);\n\n\tclass_unregister(&ublk_chr_class);\n\tmisc_deregister(&ublk_misc);\n\n\tidr_destroy(&ublk_index_idr);\n\tunregister_chrdev_region(ublk_chr_devt, UBLK_MINORS);\n}\n\nmodule_init(ublk_init);\nmodule_exit(ublk_exit);\n\nmodule_param(ublks_max, int, 0444);\nMODULE_PARM_DESC(ublks_max, \"max number of ublk devices allowed to add(default: 64)\");\n\nMODULE_AUTHOR(\"Ming Lei <ming.lei@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}