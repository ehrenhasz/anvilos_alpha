{
  "module_name": "drbd_state.c",
  "hash_id": "2e6eaf07b3651ed181fbbb770b5db408b1584cdda6a5a84266256e43e028155d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_state.c",
  "human_readable_source": "\n \n\n#include <linux/drbd_limits.h>\n#include \"drbd_int.h\"\n#include \"drbd_protocol.h\"\n#include \"drbd_req.h\"\n#include \"drbd_state_change.h\"\n\nstruct after_state_chg_work {\n\tstruct drbd_work w;\n\tstruct drbd_device *device;\n\tunion drbd_state os;\n\tunion drbd_state ns;\n\tenum chg_state_flags flags;\n\tstruct completion *done;\n\tstruct drbd_state_change *state_change;\n};\n\nenum sanitize_state_warnings {\n\tNO_WARNING,\n\tABORTED_ONLINE_VERIFY,\n\tABORTED_RESYNC,\n\tCONNECTION_LOST_NEGOTIATING,\n\tIMPLICITLY_UPGRADED_DISK,\n\tIMPLICITLY_UPGRADED_PDSK,\n};\n\nstatic void count_objects(struct drbd_resource *resource,\n\t\t\t  unsigned int *n_devices,\n\t\t\t  unsigned int *n_connections)\n{\n\tstruct drbd_device *device;\n\tstruct drbd_connection *connection;\n\tint vnr;\n\n\t*n_devices = 0;\n\t*n_connections = 0;\n\n\tidr_for_each_entry(&resource->devices, device, vnr)\n\t\t(*n_devices)++;\n\tfor_each_connection(connection, resource)\n\t\t(*n_connections)++;\n}\n\nstatic struct drbd_state_change *alloc_state_change(unsigned int n_devices, unsigned int n_connections, gfp_t gfp)\n{\n\tstruct drbd_state_change *state_change;\n\tunsigned int size, n;\n\n\tsize = sizeof(struct drbd_state_change) +\n\t       n_devices * sizeof(struct drbd_device_state_change) +\n\t       n_connections * sizeof(struct drbd_connection_state_change) +\n\t       n_devices * n_connections * sizeof(struct drbd_peer_device_state_change);\n\tstate_change = kmalloc(size, gfp);\n\tif (!state_change)\n\t\treturn NULL;\n\tstate_change->n_devices = n_devices;\n\tstate_change->n_connections = n_connections;\n\tstate_change->devices = (void *)(state_change + 1);\n\tstate_change->connections = (void *)&state_change->devices[n_devices];\n\tstate_change->peer_devices = (void *)&state_change->connections[n_connections];\n\tstate_change->resource->resource = NULL;\n\tfor (n = 0; n < n_devices; n++)\n\t\tstate_change->devices[n].device = NULL;\n\tfor (n = 0; n < n_connections; n++)\n\t\tstate_change->connections[n].connection = NULL;\n\treturn state_change;\n}\n\nstruct drbd_state_change *remember_old_state(struct drbd_resource *resource, gfp_t gfp)\n{\n\tstruct drbd_state_change *state_change;\n\tstruct drbd_device *device;\n\tunsigned int n_devices;\n\tstruct drbd_connection *connection;\n\tunsigned int n_connections;\n\tint vnr;\n\n\tstruct drbd_device_state_change *device_state_change;\n\tstruct drbd_peer_device_state_change *peer_device_state_change;\n\tstruct drbd_connection_state_change *connection_state_change;\n\n\t \n\tcount_objects(resource, &n_devices, &n_connections);\n\tstate_change = alloc_state_change(n_devices, n_connections, gfp);\n\tif (!state_change)\n\t\treturn NULL;\n\n\tkref_get(&resource->kref);\n\tstate_change->resource->resource = resource;\n\tstate_change->resource->role[OLD] =\n\t\tconn_highest_role(first_connection(resource));\n\tstate_change->resource->susp[OLD] = resource->susp;\n\tstate_change->resource->susp_nod[OLD] = resource->susp_nod;\n\tstate_change->resource->susp_fen[OLD] = resource->susp_fen;\n\n\tconnection_state_change = state_change->connections;\n\tfor_each_connection(connection, resource) {\n\t\tkref_get(&connection->kref);\n\t\tconnection_state_change->connection = connection;\n\t\tconnection_state_change->cstate[OLD] =\n\t\t\tconnection->cstate;\n\t\tconnection_state_change->peer_role[OLD] =\n\t\t\tconn_highest_peer(connection);\n\t\tconnection_state_change++;\n\t}\n\n\tdevice_state_change = state_change->devices;\n\tpeer_device_state_change = state_change->peer_devices;\n\tidr_for_each_entry(&resource->devices, device, vnr) {\n\t\tkref_get(&device->kref);\n\t\tdevice_state_change->device = device;\n\t\tdevice_state_change->disk_state[OLD] = device->state.disk;\n\n\t\t \n\t\tfor_each_connection(connection, resource) {\n\t\t\tstruct drbd_peer_device *peer_device;\n\n\t\t\tpeer_device = conn_peer_device(connection, device->vnr);\n\t\t\tpeer_device_state_change->peer_device = peer_device;\n\t\t\tpeer_device_state_change->disk_state[OLD] =\n\t\t\t\tdevice->state.pdsk;\n\t\t\tpeer_device_state_change->repl_state[OLD] =\n\t\t\t\tmax_t(enum drbd_conns,\n\t\t\t\t      C_WF_REPORT_PARAMS, device->state.conn);\n\t\t\tpeer_device_state_change->resync_susp_user[OLD] =\n\t\t\t\tdevice->state.user_isp;\n\t\t\tpeer_device_state_change->resync_susp_peer[OLD] =\n\t\t\t\tdevice->state.peer_isp;\n\t\t\tpeer_device_state_change->resync_susp_dependency[OLD] =\n\t\t\t\tdevice->state.aftr_isp;\n\t\t\tpeer_device_state_change++;\n\t\t}\n\t\tdevice_state_change++;\n\t}\n\n\treturn state_change;\n}\n\nstatic void remember_new_state(struct drbd_state_change *state_change)\n{\n\tstruct drbd_resource_state_change *resource_state_change;\n\tstruct drbd_resource *resource;\n\tunsigned int n;\n\n\tif (!state_change)\n\t\treturn;\n\n\tresource_state_change = &state_change->resource[0];\n\tresource = resource_state_change->resource;\n\n\tresource_state_change->role[NEW] =\n\t\tconn_highest_role(first_connection(resource));\n\tresource_state_change->susp[NEW] = resource->susp;\n\tresource_state_change->susp_nod[NEW] = resource->susp_nod;\n\tresource_state_change->susp_fen[NEW] = resource->susp_fen;\n\n\tfor (n = 0; n < state_change->n_devices; n++) {\n\t\tstruct drbd_device_state_change *device_state_change =\n\t\t\t&state_change->devices[n];\n\t\tstruct drbd_device *device = device_state_change->device;\n\n\t\tdevice_state_change->disk_state[NEW] = device->state.disk;\n\t}\n\n\tfor (n = 0; n < state_change->n_connections; n++) {\n\t\tstruct drbd_connection_state_change *connection_state_change =\n\t\t\t&state_change->connections[n];\n\t\tstruct drbd_connection *connection =\n\t\t\tconnection_state_change->connection;\n\n\t\tconnection_state_change->cstate[NEW] = connection->cstate;\n\t\tconnection_state_change->peer_role[NEW] =\n\t\t\tconn_highest_peer(connection);\n\t}\n\n\tfor (n = 0; n < state_change->n_devices * state_change->n_connections; n++) {\n\t\tstruct drbd_peer_device_state_change *peer_device_state_change =\n\t\t\t&state_change->peer_devices[n];\n\t\tstruct drbd_device *device =\n\t\t\tpeer_device_state_change->peer_device->device;\n\t\tunion drbd_dev_state state = device->state;\n\n\t\tpeer_device_state_change->disk_state[NEW] = state.pdsk;\n\t\tpeer_device_state_change->repl_state[NEW] =\n\t\t\tmax_t(enum drbd_conns, C_WF_REPORT_PARAMS, state.conn);\n\t\tpeer_device_state_change->resync_susp_user[NEW] =\n\t\t\tstate.user_isp;\n\t\tpeer_device_state_change->resync_susp_peer[NEW] =\n\t\t\tstate.peer_isp;\n\t\tpeer_device_state_change->resync_susp_dependency[NEW] =\n\t\t\tstate.aftr_isp;\n\t}\n}\n\nvoid copy_old_to_new_state_change(struct drbd_state_change *state_change)\n{\n\tstruct drbd_resource_state_change *resource_state_change = &state_change->resource[0];\n\tunsigned int n_device, n_connection, n_peer_device, n_peer_devices;\n\n#define OLD_TO_NEW(x) \\\n\t(x[NEW] = x[OLD])\n\n\tOLD_TO_NEW(resource_state_change->role);\n\tOLD_TO_NEW(resource_state_change->susp);\n\tOLD_TO_NEW(resource_state_change->susp_nod);\n\tOLD_TO_NEW(resource_state_change->susp_fen);\n\n\tfor (n_connection = 0; n_connection < state_change->n_connections; n_connection++) {\n\t\tstruct drbd_connection_state_change *connection_state_change =\n\t\t\t\t&state_change->connections[n_connection];\n\n\t\tOLD_TO_NEW(connection_state_change->peer_role);\n\t\tOLD_TO_NEW(connection_state_change->cstate);\n\t}\n\n\tfor (n_device = 0; n_device < state_change->n_devices; n_device++) {\n\t\tstruct drbd_device_state_change *device_state_change =\n\t\t\t&state_change->devices[n_device];\n\n\t\tOLD_TO_NEW(device_state_change->disk_state);\n\t}\n\n\tn_peer_devices = state_change->n_devices * state_change->n_connections;\n\tfor (n_peer_device = 0; n_peer_device < n_peer_devices; n_peer_device++) {\n\t\tstruct drbd_peer_device_state_change *p =\n\t\t\t&state_change->peer_devices[n_peer_device];\n\n\t\tOLD_TO_NEW(p->disk_state);\n\t\tOLD_TO_NEW(p->repl_state);\n\t\tOLD_TO_NEW(p->resync_susp_user);\n\t\tOLD_TO_NEW(p->resync_susp_peer);\n\t\tOLD_TO_NEW(p->resync_susp_dependency);\n\t}\n\n#undef OLD_TO_NEW\n}\n\nvoid forget_state_change(struct drbd_state_change *state_change)\n{\n\tunsigned int n;\n\n\tif (!state_change)\n\t\treturn;\n\n\tif (state_change->resource->resource)\n\t\tkref_put(&state_change->resource->resource->kref, drbd_destroy_resource);\n\tfor (n = 0; n < state_change->n_devices; n++) {\n\t\tstruct drbd_device *device = state_change->devices[n].device;\n\n\t\tif (device)\n\t\t\tkref_put(&device->kref, drbd_destroy_device);\n\t}\n\tfor (n = 0; n < state_change->n_connections; n++) {\n\t\tstruct drbd_connection *connection =\n\t\t\tstate_change->connections[n].connection;\n\n\t\tif (connection)\n\t\t\tkref_put(&connection->kref, drbd_destroy_connection);\n\t}\n\tkfree(state_change);\n}\n\nstatic int w_after_state_ch(struct drbd_work *w, int unused);\nstatic void after_state_ch(struct drbd_device *device, union drbd_state os,\n\t\t\t   union drbd_state ns, enum chg_state_flags flags,\n\t\t\t   struct drbd_state_change *);\nstatic enum drbd_state_rv is_valid_state(struct drbd_device *, union drbd_state);\nstatic enum drbd_state_rv is_valid_soft_transition(union drbd_state, union drbd_state, struct drbd_connection *);\nstatic enum drbd_state_rv is_valid_transition(union drbd_state os, union drbd_state ns);\nstatic union drbd_state sanitize_state(struct drbd_device *device, union drbd_state os,\n\t\t\t\t       union drbd_state ns, enum sanitize_state_warnings *warn);\n\nstatic inline bool is_susp(union drbd_state s)\n{\n        return s.susp || s.susp_nod || s.susp_fen;\n}\n\nbool conn_all_vols_unconf(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tbool rv = true;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tif (device->state.disk != D_DISKLESS ||\n\t\t    device->state.conn != C_STANDALONE ||\n\t\t    device->state.role != R_SECONDARY) {\n\t\t\trv = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\n \nstatic enum drbd_role max_role(enum drbd_role role1, enum drbd_role role2)\n{\n\tif (role1 == R_PRIMARY || role2 == R_PRIMARY)\n\t\treturn R_PRIMARY;\n\tif (role1 == R_SECONDARY || role2 == R_SECONDARY)\n\t\treturn R_SECONDARY;\n\treturn R_UNKNOWN;\n}\n\nstatic enum drbd_role min_role(enum drbd_role role1, enum drbd_role role2)\n{\n\tif (role1 == R_UNKNOWN || role2 == R_UNKNOWN)\n\t\treturn R_UNKNOWN;\n\tif (role1 == R_SECONDARY || role2 == R_SECONDARY)\n\t\treturn R_SECONDARY;\n\treturn R_PRIMARY;\n}\n\nenum drbd_role conn_highest_role(struct drbd_connection *connection)\n{\n\tenum drbd_role role = R_SECONDARY;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\trole = max_role(role, device->state.role);\n\t}\n\trcu_read_unlock();\n\n\treturn role;\n}\n\nenum drbd_role conn_highest_peer(struct drbd_connection *connection)\n{\n\tenum drbd_role peer = R_UNKNOWN;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tpeer = max_role(peer, device->state.peer);\n\t}\n\trcu_read_unlock();\n\n\treturn peer;\n}\n\nenum drbd_disk_state conn_highest_disk(struct drbd_connection *connection)\n{\n\tenum drbd_disk_state disk_state = D_DISKLESS;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tdisk_state = max_t(enum drbd_disk_state, disk_state, device->state.disk);\n\t}\n\trcu_read_unlock();\n\n\treturn disk_state;\n}\n\nenum drbd_disk_state conn_lowest_disk(struct drbd_connection *connection)\n{\n\tenum drbd_disk_state disk_state = D_MASK;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tdisk_state = min_t(enum drbd_disk_state, disk_state, device->state.disk);\n\t}\n\trcu_read_unlock();\n\n\treturn disk_state;\n}\n\nenum drbd_disk_state conn_highest_pdsk(struct drbd_connection *connection)\n{\n\tenum drbd_disk_state disk_state = D_DISKLESS;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tdisk_state = max_t(enum drbd_disk_state, disk_state, device->state.pdsk);\n\t}\n\trcu_read_unlock();\n\n\treturn disk_state;\n}\n\nenum drbd_conns conn_lowest_conn(struct drbd_connection *connection)\n{\n\tenum drbd_conns conn = C_MASK;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tconn = min_t(enum drbd_conns, conn, device->state.conn);\n\t}\n\trcu_read_unlock();\n\n\treturn conn;\n}\n\nstatic bool no_peer_wf_report_params(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\tbool rv = true;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\tif (peer_device->device->state.conn == C_WF_REPORT_PARAMS) {\n\t\t\trv = false;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\nstatic void wake_up_all_devices(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\twake_up(&peer_device->device->state_wait);\n\trcu_read_unlock();\n\n}\n\n\n \nstatic int cl_wide_st_chg(struct drbd_device *device,\n\t\t\t  union drbd_state os, union drbd_state ns)\n{\n\treturn (os.conn >= C_CONNECTED && ns.conn >= C_CONNECTED &&\n\t\t ((os.role != R_PRIMARY && ns.role == R_PRIMARY) ||\n\t\t  (os.conn != C_STARTING_SYNC_T && ns.conn == C_STARTING_SYNC_T) ||\n\t\t  (os.conn != C_STARTING_SYNC_S && ns.conn == C_STARTING_SYNC_S) ||\n\t\t  (os.disk != D_FAILED && ns.disk == D_FAILED))) ||\n\t\t(os.conn >= C_CONNECTED && ns.conn == C_DISCONNECTING) ||\n\t\t(os.conn == C_CONNECTED && ns.conn == C_VERIFY_S) ||\n\t\t(os.conn == C_CONNECTED && ns.conn == C_WF_REPORT_PARAMS);\n}\n\nstatic union drbd_state\napply_mask_val(union drbd_state os, union drbd_state mask, union drbd_state val)\n{\n\tunion drbd_state ns;\n\tns.i = (os.i & ~mask.i) | val.i;\n\treturn ns;\n}\n\nenum drbd_state_rv\ndrbd_change_state(struct drbd_device *device, enum chg_state_flags f,\n\t\t  union drbd_state mask, union drbd_state val)\n{\n\tunsigned long flags;\n\tunion drbd_state ns;\n\tenum drbd_state_rv rv;\n\n\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\tns = apply_mask_val(drbd_read_state(device), mask, val);\n\trv = _drbd_set_state(device, ns, f, NULL);\n\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\n\treturn rv;\n}\n\n \nvoid drbd_force_state(struct drbd_device *device,\n\tunion drbd_state mask, union drbd_state val)\n{\n\tdrbd_change_state(device, CS_HARD, mask, val);\n}\n\nstatic enum drbd_state_rv\n_req_st_cond(struct drbd_device *device, union drbd_state mask,\n\t     union drbd_state val)\n{\n\tunion drbd_state os, ns;\n\tunsigned long flags;\n\tenum drbd_state_rv rv;\n\n\tif (test_and_clear_bit(CL_ST_CHG_SUCCESS, &device->flags))\n\t\treturn SS_CW_SUCCESS;\n\n\tif (test_and_clear_bit(CL_ST_CHG_FAIL, &device->flags))\n\t\treturn SS_CW_FAILED_BY_PEER;\n\n\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\tos = drbd_read_state(device);\n\tns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\n\trv = is_valid_transition(os, ns);\n\tif (rv >= SS_SUCCESS)\n\t\trv = SS_UNKNOWN_ERROR;   \n\n\tif (!cl_wide_st_chg(device, os, ns))\n\t\trv = SS_CW_NO_NEED;\n\tif (rv == SS_UNKNOWN_ERROR) {\n\t\trv = is_valid_state(device, ns);\n\t\tif (rv >= SS_SUCCESS) {\n\t\t\trv = is_valid_soft_transition(os, ns, first_peer_device(device)->connection);\n\t\t\tif (rv >= SS_SUCCESS)\n\t\t\t\trv = SS_UNKNOWN_ERROR;  \n\t\t}\n\t}\n\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\n\treturn rv;\n}\n\n \nstatic enum drbd_state_rv\ndrbd_req_state(struct drbd_device *device, union drbd_state mask,\n\t       union drbd_state val, enum chg_state_flags f)\n{\n\tstruct completion done;\n\tunsigned long flags;\n\tunion drbd_state os, ns;\n\tenum drbd_state_rv rv;\n\tvoid *buffer = NULL;\n\n\tinit_completion(&done);\n\n\tif (f & CS_SERIALIZE)\n\t\tmutex_lock(device->state_mutex);\n\tif (f & CS_INHIBIT_MD_IO)\n\t\tbuffer = drbd_md_get_buffer(device, __func__);\n\n\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\tos = drbd_read_state(device);\n\tns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\n\trv = is_valid_transition(os, ns);\n\tif (rv < SS_SUCCESS) {\n\t\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\t\tgoto abort;\n\t}\n\n\tif (cl_wide_st_chg(device, os, ns)) {\n\t\trv = is_valid_state(device, ns);\n\t\tif (rv == SS_SUCCESS)\n\t\t\trv = is_valid_soft_transition(os, ns, first_peer_device(device)->connection);\n\t\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\n\t\tif (rv < SS_SUCCESS) {\n\t\t\tif (f & CS_VERBOSE)\n\t\t\t\tprint_st_err(device, os, ns, rv);\n\t\t\tgoto abort;\n\t\t}\n\n\t\tif (drbd_send_state_req(first_peer_device(device), mask, val)) {\n\t\t\trv = SS_CW_FAILED_BY_PEER;\n\t\t\tif (f & CS_VERBOSE)\n\t\t\t\tprint_st_err(device, os, ns, rv);\n\t\t\tgoto abort;\n\t\t}\n\n\t\twait_event(device->state_wait,\n\t\t\t(rv = _req_st_cond(device, mask, val)));\n\n\t\tif (rv < SS_SUCCESS) {\n\t\t\tif (f & CS_VERBOSE)\n\t\t\t\tprint_st_err(device, os, ns, rv);\n\t\t\tgoto abort;\n\t\t}\n\t\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\t\tns = apply_mask_val(drbd_read_state(device), mask, val);\n\t\trv = _drbd_set_state(device, ns, f, &done);\n\t} else {\n\t\trv = _drbd_set_state(device, ns, f, &done);\n\t}\n\n\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\n\tif (f & CS_WAIT_COMPLETE && rv == SS_SUCCESS) {\n\t\tD_ASSERT(device, current != first_peer_device(device)->connection->worker.task);\n\t\twait_for_completion(&done);\n\t}\n\nabort:\n\tif (buffer)\n\t\tdrbd_md_put_buffer(device);\n\tif (f & CS_SERIALIZE)\n\t\tmutex_unlock(device->state_mutex);\n\n\treturn rv;\n}\n\n \nenum drbd_state_rv\n_drbd_request_state(struct drbd_device *device, union drbd_state mask,\n\t\t    union drbd_state val, enum chg_state_flags f)\n{\n\tenum drbd_state_rv rv;\n\n\twait_event(device->state_wait,\n\t\t   (rv = drbd_req_state(device, mask, val, f)) != SS_IN_TRANSIENT_STATE);\n\n\treturn rv;\n}\n\n \nstatic enum drbd_state_rv\nrequest_detach(struct drbd_device *device)\n{\n\treturn drbd_req_state(device, NS(disk, D_FAILED),\n\t\t\tCS_VERBOSE | CS_ORDERED | CS_INHIBIT_MD_IO);\n}\n\nint drbd_request_detach_interruptible(struct drbd_device *device)\n{\n\tint ret, rv;\n\n\tdrbd_suspend_io(device);  \n\twait_event_interruptible(device->state_wait,\n\t\t(rv = request_detach(device)) != SS_IN_TRANSIENT_STATE);\n\tdrbd_resume_io(device);\n\n\tret = wait_event_interruptible(device->misc_wait,\n\t\t\tdevice->state.disk != D_FAILED);\n\n\tif (rv == SS_IS_DISKLESS)\n\t\trv = SS_NOTHING_TO_DO;\n\tif (ret)\n\t\trv = ERR_INTR;\n\n\treturn rv;\n}\n\nenum drbd_state_rv\n_drbd_request_state_holding_state_mutex(struct drbd_device *device, union drbd_state mask,\n\t\t    union drbd_state val, enum chg_state_flags f)\n{\n\tenum drbd_state_rv rv;\n\n\tBUG_ON(f & CS_SERIALIZE);\n\n\twait_event_cmd(device->state_wait,\n\t\t       (rv = drbd_req_state(device, mask, val, f)) != SS_IN_TRANSIENT_STATE,\n\t\t       mutex_unlock(device->state_mutex),\n\t\t       mutex_lock(device->state_mutex));\n\n\treturn rv;\n}\n\nstatic void print_st(struct drbd_device *device, const char *name, union drbd_state ns)\n{\n\tdrbd_err(device, \" %s = { cs:%s ro:%s/%s ds:%s/%s %c%c%c%c%c%c }\\n\",\n\t    name,\n\t    drbd_conn_str(ns.conn),\n\t    drbd_role_str(ns.role),\n\t    drbd_role_str(ns.peer),\n\t    drbd_disk_str(ns.disk),\n\t    drbd_disk_str(ns.pdsk),\n\t    is_susp(ns) ? 's' : 'r',\n\t    ns.aftr_isp ? 'a' : '-',\n\t    ns.peer_isp ? 'p' : '-',\n\t    ns.user_isp ? 'u' : '-',\n\t    ns.susp_fen ? 'F' : '-',\n\t    ns.susp_nod ? 'N' : '-'\n\t    );\n}\n\nvoid print_st_err(struct drbd_device *device, union drbd_state os,\n\t          union drbd_state ns, enum drbd_state_rv err)\n{\n\tif (err == SS_IN_TRANSIENT_STATE)\n\t\treturn;\n\tdrbd_err(device, \"State change failed: %s\\n\", drbd_set_st_err_str(err));\n\tprint_st(device, \" state\", os);\n\tprint_st(device, \"wanted\", ns);\n}\n\nstatic long print_state_change(char *pb, union drbd_state os, union drbd_state ns,\n\t\t\t       enum chg_state_flags flags)\n{\n\tchar *pbp;\n\tpbp = pb;\n\t*pbp = 0;\n\n\tif (ns.role != os.role && flags & CS_DC_ROLE)\n\t\tpbp += sprintf(pbp, \"role( %s -> %s ) \",\n\t\t\t       drbd_role_str(os.role),\n\t\t\t       drbd_role_str(ns.role));\n\tif (ns.peer != os.peer && flags & CS_DC_PEER)\n\t\tpbp += sprintf(pbp, \"peer( %s -> %s ) \",\n\t\t\t       drbd_role_str(os.peer),\n\t\t\t       drbd_role_str(ns.peer));\n\tif (ns.conn != os.conn && flags & CS_DC_CONN)\n\t\tpbp += sprintf(pbp, \"conn( %s -> %s ) \",\n\t\t\t       drbd_conn_str(os.conn),\n\t\t\t       drbd_conn_str(ns.conn));\n\tif (ns.disk != os.disk && flags & CS_DC_DISK)\n\t\tpbp += sprintf(pbp, \"disk( %s -> %s ) \",\n\t\t\t       drbd_disk_str(os.disk),\n\t\t\t       drbd_disk_str(ns.disk));\n\tif (ns.pdsk != os.pdsk && flags & CS_DC_PDSK)\n\t\tpbp += sprintf(pbp, \"pdsk( %s -> %s ) \",\n\t\t\t       drbd_disk_str(os.pdsk),\n\t\t\t       drbd_disk_str(ns.pdsk));\n\n\treturn pbp - pb;\n}\n\nstatic void drbd_pr_state_change(struct drbd_device *device, union drbd_state os, union drbd_state ns,\n\t\t\t\t enum chg_state_flags flags)\n{\n\tchar pb[300];\n\tchar *pbp = pb;\n\n\tpbp += print_state_change(pbp, os, ns, flags ^ CS_DC_MASK);\n\n\tif (ns.aftr_isp != os.aftr_isp)\n\t\tpbp += sprintf(pbp, \"aftr_isp( %d -> %d ) \",\n\t\t\t       os.aftr_isp,\n\t\t\t       ns.aftr_isp);\n\tif (ns.peer_isp != os.peer_isp)\n\t\tpbp += sprintf(pbp, \"peer_isp( %d -> %d ) \",\n\t\t\t       os.peer_isp,\n\t\t\t       ns.peer_isp);\n\tif (ns.user_isp != os.user_isp)\n\t\tpbp += sprintf(pbp, \"user_isp( %d -> %d ) \",\n\t\t\t       os.user_isp,\n\t\t\t       ns.user_isp);\n\n\tif (pbp != pb)\n\t\tdrbd_info(device, \"%s\\n\", pb);\n}\n\nstatic void conn_pr_state_change(struct drbd_connection *connection, union drbd_state os, union drbd_state ns,\n\t\t\t\t enum chg_state_flags flags)\n{\n\tchar pb[300];\n\tchar *pbp = pb;\n\n\tpbp += print_state_change(pbp, os, ns, flags);\n\n\tif (is_susp(ns) != is_susp(os) && flags & CS_DC_SUSP)\n\t\tpbp += sprintf(pbp, \"susp( %d -> %d ) \",\n\t\t\t       is_susp(os),\n\t\t\t       is_susp(ns));\n\n\tif (pbp != pb)\n\t\tdrbd_info(connection, \"%s\\n\", pb);\n}\n\n\n \nstatic enum drbd_state_rv\nis_valid_state(struct drbd_device *device, union drbd_state ns)\n{\n\t \n\n\tenum drbd_fencing_p fp;\n\tenum drbd_state_rv rv = SS_SUCCESS;\n\tstruct net_conf *nc;\n\n\trcu_read_lock();\n\tfp = FP_DONT_CARE;\n\tif (get_ldev(device)) {\n\t\tfp = rcu_dereference(device->ldev->disk_conf)->fencing;\n\t\tput_ldev(device);\n\t}\n\n\tnc = rcu_dereference(first_peer_device(device)->connection->net_conf);\n\tif (nc) {\n\t\tif (!nc->two_primaries && ns.role == R_PRIMARY) {\n\t\t\tif (ns.peer == R_PRIMARY)\n\t\t\t\trv = SS_TWO_PRIMARIES;\n\t\t\telse if (conn_highest_peer(first_peer_device(device)->connection) == R_PRIMARY)\n\t\t\t\trv = SS_O_VOL_PEER_PRI;\n\t\t}\n\t}\n\n\tif (rv <= 0)\n\t\tgoto out;  \n\telse if (ns.role == R_SECONDARY && device->open_cnt)\n\t\trv = SS_DEVICE_IN_USE;\n\n\telse if (ns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.disk < D_UP_TO_DATE)\n\t\trv = SS_NO_UP_TO_DATE_DISK;\n\n\telse if (fp >= FP_RESOURCE &&\n\t\t ns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.pdsk >= D_UNKNOWN)\n\t\trv = SS_PRIMARY_NOP;\n\n\telse if (ns.role == R_PRIMARY && ns.disk <= D_INCONSISTENT && ns.pdsk <= D_INCONSISTENT)\n\t\trv = SS_NO_UP_TO_DATE_DISK;\n\n\telse if (ns.conn > C_CONNECTED && ns.disk < D_INCONSISTENT)\n\t\trv = SS_NO_LOCAL_DISK;\n\n\telse if (ns.conn > C_CONNECTED && ns.pdsk < D_INCONSISTENT)\n\t\trv = SS_NO_REMOTE_DISK;\n\n\telse if (ns.conn > C_CONNECTED && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE)\n\t\trv = SS_NO_UP_TO_DATE_DISK;\n\n\telse if ((ns.conn == C_CONNECTED ||\n\t\t  ns.conn == C_WF_BITMAP_S ||\n\t\t  ns.conn == C_SYNC_SOURCE ||\n\t\t  ns.conn == C_PAUSED_SYNC_S) &&\n\t\t  ns.disk == D_OUTDATED)\n\t\trv = SS_CONNECTED_OUTDATES;\n\n\telse if ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\n\t\t (nc->verify_alg[0] == 0))\n\t\trv = SS_NO_VERIFY_ALG;\n\n\telse if ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\n\t\t  first_peer_device(device)->connection->agreed_pro_version < 88)\n\t\trv = SS_NOT_SUPPORTED;\n\n\telse if (ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE)\n\t\trv = SS_NO_UP_TO_DATE_DISK;\n\n\telse if ((ns.conn == C_STARTING_SYNC_S || ns.conn == C_STARTING_SYNC_T) &&\n                 ns.pdsk == D_UNKNOWN)\n\t\trv = SS_NEED_CONNECTION;\n\n\telse if (ns.conn >= C_CONNECTED && ns.pdsk == D_UNKNOWN)\n\t\trv = SS_CONNECTED_OUTDATES;\n\nout:\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\n \nstatic enum drbd_state_rv\nis_valid_soft_transition(union drbd_state os, union drbd_state ns, struct drbd_connection *connection)\n{\n\tenum drbd_state_rv rv = SS_SUCCESS;\n\n\tif ((ns.conn == C_STARTING_SYNC_T || ns.conn == C_STARTING_SYNC_S) &&\n\t    os.conn > C_CONNECTED)\n\t\trv = SS_RESYNC_RUNNING;\n\n\tif (ns.conn == C_DISCONNECTING && os.conn == C_STANDALONE)\n\t\trv = SS_ALREADY_STANDALONE;\n\n\tif (ns.disk > D_ATTACHING && os.disk == D_DISKLESS)\n\t\trv = SS_IS_DISKLESS;\n\n\tif (ns.conn == C_WF_CONNECTION && os.conn < C_UNCONNECTED)\n\t\trv = SS_NO_NET_CONFIG;\n\n\tif (ns.disk == D_OUTDATED && os.disk < D_OUTDATED && os.disk != D_ATTACHING)\n\t\trv = SS_LOWER_THAN_OUTDATED;\n\n\tif (ns.conn == C_DISCONNECTING && os.conn == C_UNCONNECTED)\n\t\trv = SS_IN_TRANSIENT_STATE;\n\n\t \n\tif (test_bit(STATE_SENT, &connection->flags) &&\n\t    !((ns.conn == C_WF_REPORT_PARAMS && os.conn == C_WF_CONNECTION) ||\n\t      (ns.conn >= C_CONNECTED && os.conn == C_WF_REPORT_PARAMS)))\n\t\trv = SS_IN_TRANSIENT_STATE;\n\n\t \n\tif (os.role != R_PRIMARY && ns.role == R_PRIMARY\n\t\t&& ns.pdsk == D_UP_TO_DATE\n\t\t&& ns.disk != D_UP_TO_DATE && ns.disk != D_DISKLESS\n\t\t&& (ns.conn <= C_WF_SYNC_UUID || ns.conn != os.conn))\n\t\t\trv = SS_IN_TRANSIENT_STATE;\n\n\tif ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) && os.conn < C_CONNECTED)\n\t\trv = SS_NEED_CONNECTION;\n\n\tif ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\n\t    ns.conn != os.conn && os.conn > C_CONNECTED)\n\t\trv = SS_RESYNC_RUNNING;\n\n\tif ((ns.conn == C_STARTING_SYNC_S || ns.conn == C_STARTING_SYNC_T) &&\n\t    os.conn < C_CONNECTED)\n\t\trv = SS_NEED_CONNECTION;\n\n\tif ((ns.conn == C_SYNC_TARGET || ns.conn == C_SYNC_SOURCE)\n\t    && os.conn < C_WF_REPORT_PARAMS)\n\t\trv = SS_NEED_CONNECTION;  \n\n\tif (ns.conn == C_DISCONNECTING && ns.pdsk == D_OUTDATED &&\n\t    os.conn < C_CONNECTED && os.pdsk > D_OUTDATED)\n\t\trv = SS_OUTDATE_WO_CONN;\n\n\treturn rv;\n}\n\nstatic enum drbd_state_rv\nis_valid_conn_transition(enum drbd_conns oc, enum drbd_conns nc)\n{\n\t \n\tif (oc == nc)\n\t\treturn SS_NOTHING_TO_DO;\n\n\t \n\tif (oc == C_STANDALONE && nc == C_DISCONNECTING)\n\t\treturn SS_ALREADY_STANDALONE;\n\n\t \n\tif (oc == C_STANDALONE && nc != C_UNCONNECTED)\n\t\treturn SS_NEED_CONNECTION;\n\n\t \n\tif (oc < C_WF_REPORT_PARAMS && nc >= C_CONNECTED)\n\t\treturn SS_NEED_CONNECTION;\n\n\t \n\tif (oc >= C_TIMEOUT && oc <= C_TEAR_DOWN && nc != C_UNCONNECTED && nc != C_DISCONNECTING)\n\t\treturn SS_IN_TRANSIENT_STATE;\n\n\t \n\tif (oc == C_DISCONNECTING && nc != C_STANDALONE)\n\t\treturn SS_IN_TRANSIENT_STATE;\n\n\treturn SS_SUCCESS;\n}\n\n\n \nstatic enum drbd_state_rv\nis_valid_transition(union drbd_state os, union drbd_state ns)\n{\n\tenum drbd_state_rv rv;\n\n\trv = is_valid_conn_transition(os.conn, ns.conn);\n\n\t \n\tif (ns.disk == D_FAILED && os.disk == D_DISKLESS)\n\t\trv = SS_IS_DISKLESS;\n\n\treturn rv;\n}\n\nstatic void print_sanitize_warnings(struct drbd_device *device, enum sanitize_state_warnings warn)\n{\n\tstatic const char *msg_table[] = {\n\t\t[NO_WARNING] = \"\",\n\t\t[ABORTED_ONLINE_VERIFY] = \"Online-verify aborted.\",\n\t\t[ABORTED_RESYNC] = \"Resync aborted.\",\n\t\t[CONNECTION_LOST_NEGOTIATING] = \"Connection lost while negotiating, no data!\",\n\t\t[IMPLICITLY_UPGRADED_DISK] = \"Implicitly upgraded disk\",\n\t\t[IMPLICITLY_UPGRADED_PDSK] = \"Implicitly upgraded pdsk\",\n\t};\n\n\tif (warn != NO_WARNING)\n\t\tdrbd_warn(device, \"%s\\n\", msg_table[warn]);\n}\n\n \nstatic union drbd_state sanitize_state(struct drbd_device *device, union drbd_state os,\n\t\t\t\t       union drbd_state ns, enum sanitize_state_warnings *warn)\n{\n\tenum drbd_fencing_p fp;\n\tenum drbd_disk_state disk_min, disk_max, pdsk_min, pdsk_max;\n\n\tif (warn)\n\t\t*warn = NO_WARNING;\n\n\tfp = FP_DONT_CARE;\n\tif (get_ldev(device)) {\n\t\trcu_read_lock();\n\t\tfp = rcu_dereference(device->ldev->disk_conf)->fencing;\n\t\trcu_read_unlock();\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (ns.conn < C_CONNECTED) {\n\t\tns.peer_isp = 0;\n\t\tns.peer = R_UNKNOWN;\n\t\tif (ns.pdsk > D_UNKNOWN || ns.pdsk < D_INCONSISTENT)\n\t\t\tns.pdsk = D_UNKNOWN;\n\t}\n\n\t \n\tif (ns.conn == C_STANDALONE && ns.disk == D_DISKLESS && ns.role == R_SECONDARY)\n\t\tns.aftr_isp = 0;\n\n\t \n\t \n\tif (ns.conn > C_CONNECTED && (ns.disk <= D_FAILED || ns.pdsk <= D_FAILED)) {\n\t\tif (warn)\n\t\t\t*warn = ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T ?\n\t\t\t\tABORTED_ONLINE_VERIFY : ABORTED_RESYNC;\n\t\tns.conn = C_CONNECTED;\n\t}\n\n\t \n\tif (ns.conn < C_CONNECTED && ns.disk == D_NEGOTIATING &&\n\t    get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\tif (device->ed_uuid == device->ldev->md.uuid[UI_CURRENT]) {\n\t\t\tns.disk = device->new_state_tmp.disk;\n\t\t\tns.pdsk = device->new_state_tmp.pdsk;\n\t\t} else {\n\t\t\tif (warn)\n\t\t\t\t*warn = CONNECTION_LOST_NEGOTIATING;\n\t\t\tns.disk = D_DISKLESS;\n\t\t\tns.pdsk = D_UNKNOWN;\n\t\t}\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (ns.conn >= C_CONNECTED && ns.conn < C_AHEAD) {\n\t\tif (ns.disk == D_CONSISTENT || ns.disk == D_OUTDATED)\n\t\t\tns.disk = D_UP_TO_DATE;\n\t\tif (ns.pdsk == D_CONSISTENT || ns.pdsk == D_OUTDATED)\n\t\t\tns.pdsk = D_UP_TO_DATE;\n\t}\n\n\t \n\tdisk_min = D_DISKLESS;\n\tdisk_max = D_UP_TO_DATE;\n\tpdsk_min = D_INCONSISTENT;\n\tpdsk_max = D_UNKNOWN;\n\tswitch ((enum drbd_conns)ns.conn) {\n\tcase C_WF_BITMAP_T:\n\tcase C_PAUSED_SYNC_T:\n\tcase C_STARTING_SYNC_T:\n\tcase C_WF_SYNC_UUID:\n\tcase C_BEHIND:\n\t\tdisk_min = D_INCONSISTENT;\n\t\tdisk_max = D_OUTDATED;\n\t\tpdsk_min = D_UP_TO_DATE;\n\t\tpdsk_max = D_UP_TO_DATE;\n\t\tbreak;\n\tcase C_VERIFY_S:\n\tcase C_VERIFY_T:\n\t\tdisk_min = D_UP_TO_DATE;\n\t\tdisk_max = D_UP_TO_DATE;\n\t\tpdsk_min = D_UP_TO_DATE;\n\t\tpdsk_max = D_UP_TO_DATE;\n\t\tbreak;\n\tcase C_CONNECTED:\n\t\tdisk_min = D_DISKLESS;\n\t\tdisk_max = D_UP_TO_DATE;\n\t\tpdsk_min = D_DISKLESS;\n\t\tpdsk_max = D_UP_TO_DATE;\n\t\tbreak;\n\tcase C_WF_BITMAP_S:\n\tcase C_PAUSED_SYNC_S:\n\tcase C_STARTING_SYNC_S:\n\tcase C_AHEAD:\n\t\tdisk_min = D_UP_TO_DATE;\n\t\tdisk_max = D_UP_TO_DATE;\n\t\tpdsk_min = D_INCONSISTENT;\n\t\tpdsk_max = D_CONSISTENT;  \n\t\tbreak;\n\tcase C_SYNC_TARGET:\n\t\tdisk_min = D_INCONSISTENT;\n\t\tdisk_max = D_INCONSISTENT;\n\t\tpdsk_min = D_UP_TO_DATE;\n\t\tpdsk_max = D_UP_TO_DATE;\n\t\tbreak;\n\tcase C_SYNC_SOURCE:\n\t\tdisk_min = D_UP_TO_DATE;\n\t\tdisk_max = D_UP_TO_DATE;\n\t\tpdsk_min = D_INCONSISTENT;\n\t\tpdsk_max = D_INCONSISTENT;\n\t\tbreak;\n\tcase C_STANDALONE:\n\tcase C_DISCONNECTING:\n\tcase C_UNCONNECTED:\n\tcase C_TIMEOUT:\n\tcase C_BROKEN_PIPE:\n\tcase C_NETWORK_FAILURE:\n\tcase C_PROTOCOL_ERROR:\n\tcase C_TEAR_DOWN:\n\tcase C_WF_CONNECTION:\n\tcase C_WF_REPORT_PARAMS:\n\tcase C_MASK:\n\t\tbreak;\n\t}\n\tif (ns.disk > disk_max)\n\t\tns.disk = disk_max;\n\n\tif (ns.disk < disk_min) {\n\t\tif (warn)\n\t\t\t*warn = IMPLICITLY_UPGRADED_DISK;\n\t\tns.disk = disk_min;\n\t}\n\tif (ns.pdsk > pdsk_max)\n\t\tns.pdsk = pdsk_max;\n\n\tif (ns.pdsk < pdsk_min) {\n\t\tif (warn)\n\t\t\t*warn = IMPLICITLY_UPGRADED_PDSK;\n\t\tns.pdsk = pdsk_min;\n\t}\n\n\tif (fp == FP_STONITH &&\n\t    (ns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.pdsk > D_OUTDATED) &&\n\t    !(os.role == R_PRIMARY && os.conn < C_CONNECTED && os.pdsk > D_OUTDATED))\n\t\tns.susp_fen = 1;  \n\n\tif (device->resource->res_opts.on_no_data == OND_SUSPEND_IO &&\n\t    (ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE) &&\n\t    !(os.role == R_PRIMARY && os.disk < D_UP_TO_DATE && os.pdsk < D_UP_TO_DATE))\n\t\tns.susp_nod = 1;  \n\n\tif (ns.aftr_isp || ns.peer_isp || ns.user_isp) {\n\t\tif (ns.conn == C_SYNC_SOURCE)\n\t\t\tns.conn = C_PAUSED_SYNC_S;\n\t\tif (ns.conn == C_SYNC_TARGET)\n\t\t\tns.conn = C_PAUSED_SYNC_T;\n\t} else {\n\t\tif (ns.conn == C_PAUSED_SYNC_S)\n\t\t\tns.conn = C_SYNC_SOURCE;\n\t\tif (ns.conn == C_PAUSED_SYNC_T)\n\t\t\tns.conn = C_SYNC_TARGET;\n\t}\n\n\treturn ns;\n}\n\nvoid drbd_resume_al(struct drbd_device *device)\n{\n\tif (test_and_clear_bit(AL_SUSPENDED, &device->flags))\n\t\tdrbd_info(device, \"Resumed AL updates\\n\");\n}\n\n \nstatic void set_ov_position(struct drbd_peer_device *peer_device, enum drbd_conns cs)\n{\n\tstruct drbd_device *device = peer_device->device;\n\n\tif (peer_device->connection->agreed_pro_version < 90)\n\t\tdevice->ov_start_sector = 0;\n\tdevice->rs_total = drbd_bm_bits(device);\n\tdevice->ov_position = 0;\n\tif (cs == C_VERIFY_T) {\n\t\t \n\t\tdevice->ov_start_sector = ~(sector_t)0;\n\t} else {\n\t\tunsigned long bit = BM_SECT_TO_BIT(device->ov_start_sector);\n\t\tif (bit >= device->rs_total) {\n\t\t\tdevice->ov_start_sector =\n\t\t\t\tBM_BIT_TO_SECT(device->rs_total - 1);\n\t\t\tdevice->rs_total = 1;\n\t\t} else\n\t\t\tdevice->rs_total -= bit;\n\t\tdevice->ov_position = device->ov_start_sector;\n\t}\n\tdevice->ov_left = device->rs_total;\n}\n\n \nenum drbd_state_rv\n_drbd_set_state(struct drbd_device *device, union drbd_state ns,\n\t        enum chg_state_flags flags, struct completion *done)\n{\n\tstruct drbd_peer_device *peer_device = first_peer_device(device);\n\tstruct drbd_connection *connection = peer_device ? peer_device->connection : NULL;\n\tunion drbd_state os;\n\tenum drbd_state_rv rv = SS_SUCCESS;\n\tenum sanitize_state_warnings ssw;\n\tstruct after_state_chg_work *ascw;\n\tstruct drbd_state_change *state_change;\n\n\tos = drbd_read_state(device);\n\n\tns = sanitize_state(device, os, ns, &ssw);\n\tif (ns.i == os.i)\n\t\treturn SS_NOTHING_TO_DO;\n\n\trv = is_valid_transition(os, ns);\n\tif (rv < SS_SUCCESS)\n\t\treturn rv;\n\n\tif (!(flags & CS_HARD)) {\n\t\t \n\t\t \n\n\t\trv = is_valid_state(device, ns);\n\t\tif (rv < SS_SUCCESS) {\n\t\t\t \n\n\t\t\tif (is_valid_state(device, os) == rv)\n\t\t\t\trv = is_valid_soft_transition(os, ns, connection);\n\t\t} else\n\t\t\trv = is_valid_soft_transition(os, ns, connection);\n\t}\n\n\tif (rv < SS_SUCCESS) {\n\t\tif (flags & CS_VERBOSE)\n\t\t\tprint_st_err(device, os, ns, rv);\n\t\treturn rv;\n\t}\n\n\tprint_sanitize_warnings(device, ssw);\n\n\tdrbd_pr_state_change(device, os, ns, flags);\n\n\t \n\tif (!(flags & CS_DC_SUSP))\n\t\tconn_pr_state_change(connection, os, ns,\n\t\t\t\t     (flags & ~CS_DC_MASK) | CS_DC_SUSP);\n\n\t \n\tif ((os.disk != D_FAILED && ns.disk == D_FAILED) ||\n\t    (os.disk != D_DISKLESS && ns.disk == D_DISKLESS))\n\t\tatomic_inc(&device->local_cnt);\n\n\tif (!is_sync_state(os.conn) && is_sync_state(ns.conn))\n\t\tclear_bit(RS_DONE, &device->flags);\n\n\t \n\tstate_change = remember_old_state(device->resource, GFP_ATOMIC);\n\n\t \n\tsmp_wmb();\n\tdevice->state.i = ns.i;\n\tdevice->resource->susp = ns.susp;\n\tdevice->resource->susp_nod = ns.susp_nod;\n\tdevice->resource->susp_fen = ns.susp_fen;\n\tsmp_wmb();\n\n\tremember_new_state(state_change);\n\n\t \n\tif (drbd_should_do_remote((union drbd_dev_state)os.i) !=\n\t    drbd_should_do_remote((union drbd_dev_state)ns.i))\n\t\tstart_new_tl_epoch(connection);\n\n\tif (os.disk == D_ATTACHING && ns.disk >= D_NEGOTIATING)\n\t\tdrbd_print_uuids(device, \"attached to UUIDs\");\n\n\t \n\tif (os.conn == C_WF_REPORT_PARAMS && ns.conn != C_WF_REPORT_PARAMS &&\n\t    no_peer_wf_report_params(connection)) {\n\t\tclear_bit(STATE_SENT, &connection->flags);\n\t\twake_up_all_devices(connection);\n\t}\n\n\twake_up(&device->misc_wait);\n\twake_up(&device->state_wait);\n\twake_up(&connection->ping_wait);\n\n\t \n\tif ((os.conn == C_VERIFY_S || os.conn == C_VERIFY_T) &&\n\t    ns.conn <= C_CONNECTED) {\n\t\tdevice->ov_start_sector =\n\t\t\tBM_BIT_TO_SECT(drbd_bm_bits(device) - device->ov_left);\n\t\tif (device->ov_left)\n\t\t\tdrbd_info(device, \"Online Verify reached sector %llu\\n\",\n\t\t\t\t(unsigned long long)device->ov_start_sector);\n\t}\n\n\tif ((os.conn == C_PAUSED_SYNC_T || os.conn == C_PAUSED_SYNC_S) &&\n\t    (ns.conn == C_SYNC_TARGET  || ns.conn == C_SYNC_SOURCE)) {\n\t\tdrbd_info(device, \"Syncer continues.\\n\");\n\t\tdevice->rs_paused += (long)jiffies\n\t\t\t\t  -(long)device->rs_mark_time[device->rs_last_mark];\n\t\tif (ns.conn == C_SYNC_TARGET)\n\t\t\tmod_timer(&device->resync_timer, jiffies);\n\t}\n\n\tif ((os.conn == C_SYNC_TARGET  || os.conn == C_SYNC_SOURCE) &&\n\t    (ns.conn == C_PAUSED_SYNC_T || ns.conn == C_PAUSED_SYNC_S)) {\n\t\tdrbd_info(device, \"Resync suspended\\n\");\n\t\tdevice->rs_mark_time[device->rs_last_mark] = jiffies;\n\t}\n\n\tif (os.conn == C_CONNECTED &&\n\t    (ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T)) {\n\t\tunsigned long now = jiffies;\n\t\tint i;\n\n\t\tset_ov_position(peer_device, ns.conn);\n\t\tdevice->rs_start = now;\n\t\tdevice->rs_last_sect_ev = 0;\n\t\tdevice->ov_last_oos_size = 0;\n\t\tdevice->ov_last_oos_start = 0;\n\n\t\tfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\n\t\t\tdevice->rs_mark_left[i] = device->ov_left;\n\t\t\tdevice->rs_mark_time[i] = now;\n\t\t}\n\n\t\tdrbd_rs_controller_reset(peer_device);\n\n\t\tif (ns.conn == C_VERIFY_S) {\n\t\t\tdrbd_info(device, \"Starting Online Verify from sector %llu\\n\",\n\t\t\t\t\t(unsigned long long)device->ov_position);\n\t\t\tmod_timer(&device->resync_timer, jiffies);\n\t\t}\n\t}\n\n\tif (get_ldev(device)) {\n\t\tu32 mdf = device->ldev->md.flags & ~(MDF_CONSISTENT|MDF_PRIMARY_IND|\n\t\t\t\t\t\t MDF_CONNECTED_IND|MDF_WAS_UP_TO_DATE|\n\t\t\t\t\t\t MDF_PEER_OUT_DATED|MDF_CRASHED_PRIMARY);\n\n\t\tmdf &= ~MDF_AL_CLEAN;\n\t\tif (test_bit(CRASHED_PRIMARY, &device->flags))\n\t\t\tmdf |= MDF_CRASHED_PRIMARY;\n\t\tif (device->state.role == R_PRIMARY ||\n\t\t    (device->state.pdsk < D_INCONSISTENT && device->state.peer == R_PRIMARY))\n\t\t\tmdf |= MDF_PRIMARY_IND;\n\t\tif (device->state.conn > C_WF_REPORT_PARAMS)\n\t\t\tmdf |= MDF_CONNECTED_IND;\n\t\tif (device->state.disk > D_INCONSISTENT)\n\t\t\tmdf |= MDF_CONSISTENT;\n\t\tif (device->state.disk > D_OUTDATED)\n\t\t\tmdf |= MDF_WAS_UP_TO_DATE;\n\t\tif (device->state.pdsk <= D_OUTDATED && device->state.pdsk >= D_INCONSISTENT)\n\t\t\tmdf |= MDF_PEER_OUT_DATED;\n\t\tif (mdf != device->ldev->md.flags) {\n\t\t\tdevice->ldev->md.flags = mdf;\n\t\t\tdrbd_md_mark_dirty(device);\n\t\t}\n\t\tif (os.disk < D_CONSISTENT && ns.disk >= D_CONSISTENT)\n\t\t\tdrbd_set_ed_uuid(device, device->ldev->md.uuid[UI_CURRENT]);\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (os.disk == D_INCONSISTENT && os.pdsk == D_INCONSISTENT &&\n\t    os.peer == R_SECONDARY && ns.peer == R_PRIMARY)\n\t\tset_bit(CONSIDER_RESYNC, &device->flags);\n\n\t \n\tif (os.conn != C_DISCONNECTING && ns.conn == C_DISCONNECTING)\n\t\tdrbd_thread_stop_nowait(&connection->receiver);\n\n\t \n\tif (os.conn != C_STANDALONE && ns.conn == C_STANDALONE)\n\t\tdrbd_thread_stop_nowait(&connection->receiver);\n\n\t \n\tif (os.conn > C_WF_CONNECTION &&\n\t    ns.conn <= C_TEAR_DOWN && ns.conn >= C_TIMEOUT)\n\t\tdrbd_thread_restart_nowait(&connection->receiver);\n\n\t \n\tif (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED) {\n\t\tdrbd_resume_al(device);\n\t\tconnection->connect_cnt++;\n\t}\n\n\t \n\tif ((os.disk == D_ATTACHING || os.disk == D_NEGOTIATING) &&\n\t    ns.disk > D_NEGOTIATING)\n\t\tdevice->last_reattach_jif = jiffies;\n\n\tascw = kmalloc(sizeof(*ascw), GFP_ATOMIC);\n\tif (ascw) {\n\t\tascw->os = os;\n\t\tascw->ns = ns;\n\t\tascw->flags = flags;\n\t\tascw->w.cb = w_after_state_ch;\n\t\tascw->device = device;\n\t\tascw->done = done;\n\t\tascw->state_change = state_change;\n\t\tdrbd_queue_work(&connection->sender_work,\n\t\t\t\t&ascw->w);\n\t} else {\n\t\tdrbd_err(device, \"Could not kmalloc an ascw\\n\");\n\t}\n\n\treturn rv;\n}\n\nstatic int w_after_state_ch(struct drbd_work *w, int unused)\n{\n\tstruct after_state_chg_work *ascw =\n\t\tcontainer_of(w, struct after_state_chg_work, w);\n\tstruct drbd_device *device = ascw->device;\n\n\tafter_state_ch(device, ascw->os, ascw->ns, ascw->flags, ascw->state_change);\n\tforget_state_change(ascw->state_change);\n\tif (ascw->flags & CS_WAIT_COMPLETE)\n\t\tcomplete(ascw->done);\n\tkfree(ascw);\n\n\treturn 0;\n}\n\nstatic void abw_start_sync(struct drbd_device *device, int rv)\n{\n\tif (rv) {\n\t\tdrbd_err(device, \"Writing the bitmap failed not starting resync.\\n\");\n\t\t_drbd_request_state(device, NS(conn, C_CONNECTED), CS_VERBOSE);\n\t\treturn;\n\t}\n\n\tswitch (device->state.conn) {\n\tcase C_STARTING_SYNC_T:\n\t\t_drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\n\t\tbreak;\n\tcase C_STARTING_SYNC_S:\n\t\tdrbd_start_resync(device, C_SYNC_SOURCE);\n\t\tbreak;\n\t}\n}\n\nint drbd_bitmap_io_from_worker(struct drbd_device *device,\n\t\tint (*io_fn)(struct drbd_device *, struct drbd_peer_device *),\n\t\tchar *why, enum bm_flag flags,\n\t\tstruct drbd_peer_device *peer_device)\n{\n\tint rv;\n\n\tD_ASSERT(device, current == first_peer_device(device)->connection->worker.task);\n\n\t \n\tatomic_inc(&device->suspend_cnt);\n\n\tdrbd_bm_lock(device, why, flags);\n\trv = io_fn(device, peer_device);\n\tdrbd_bm_unlock(device);\n\n\tdrbd_resume_io(device);\n\n\treturn rv;\n}\n\nint notify_resource_state_change(struct sk_buff *skb,\n\t\t\t\t  unsigned int seq,\n\t\t\t\t  struct drbd_resource_state_change *resource_state_change,\n\t\t\t\t  enum drbd_notification_type type)\n{\n\tstruct drbd_resource *resource = resource_state_change->resource;\n\tstruct resource_info resource_info = {\n\t\t.res_role = resource_state_change->role[NEW],\n\t\t.res_susp = resource_state_change->susp[NEW],\n\t\t.res_susp_nod = resource_state_change->susp_nod[NEW],\n\t\t.res_susp_fen = resource_state_change->susp_fen[NEW],\n\t};\n\n\treturn notify_resource_state(skb, seq, resource, &resource_info, type);\n}\n\nint notify_connection_state_change(struct sk_buff *skb,\n\t\t\t\t    unsigned int seq,\n\t\t\t\t    struct drbd_connection_state_change *connection_state_change,\n\t\t\t\t    enum drbd_notification_type type)\n{\n\tstruct drbd_connection *connection = connection_state_change->connection;\n\tstruct connection_info connection_info = {\n\t\t.conn_connection_state = connection_state_change->cstate[NEW],\n\t\t.conn_role = connection_state_change->peer_role[NEW],\n\t};\n\n\treturn notify_connection_state(skb, seq, connection, &connection_info, type);\n}\n\nint notify_device_state_change(struct sk_buff *skb,\n\t\t\t\tunsigned int seq,\n\t\t\t\tstruct drbd_device_state_change *device_state_change,\n\t\t\t\tenum drbd_notification_type type)\n{\n\tstruct drbd_device *device = device_state_change->device;\n\tstruct device_info device_info = {\n\t\t.dev_disk_state = device_state_change->disk_state[NEW],\n\t};\n\n\treturn notify_device_state(skb, seq, device, &device_info, type);\n}\n\nint notify_peer_device_state_change(struct sk_buff *skb,\n\t\t\t\t     unsigned int seq,\n\t\t\t\t     struct drbd_peer_device_state_change *p,\n\t\t\t\t     enum drbd_notification_type type)\n{\n\tstruct drbd_peer_device *peer_device = p->peer_device;\n\tstruct peer_device_info peer_device_info = {\n\t\t.peer_repl_state = p->repl_state[NEW],\n\t\t.peer_disk_state = p->disk_state[NEW],\n\t\t.peer_resync_susp_user = p->resync_susp_user[NEW],\n\t\t.peer_resync_susp_peer = p->resync_susp_peer[NEW],\n\t\t.peer_resync_susp_dependency = p->resync_susp_dependency[NEW],\n\t};\n\n\treturn notify_peer_device_state(skb, seq, peer_device, &peer_device_info, type);\n}\n\nstatic void broadcast_state_change(struct drbd_state_change *state_change)\n{\n\tstruct drbd_resource_state_change *resource_state_change = &state_change->resource[0];\n\tbool resource_state_has_changed;\n\tunsigned int n_device, n_connection, n_peer_device, n_peer_devices;\n\tint (*last_func)(struct sk_buff *, unsigned int, void *,\n\t\t\t  enum drbd_notification_type) = NULL;\n\tvoid *last_arg = NULL;\n\n#define HAS_CHANGED(state) ((state)[OLD] != (state)[NEW])\n#define FINAL_STATE_CHANGE(type) \\\n\t({ if (last_func) \\\n\t\tlast_func(NULL, 0, last_arg, type); \\\n\t})\n#define REMEMBER_STATE_CHANGE(func, arg, type) \\\n\t({ FINAL_STATE_CHANGE(type | NOTIFY_CONTINUES); \\\n\t   last_func = (typeof(last_func))func; \\\n\t   last_arg = arg; \\\n\t })\n\n\tmutex_lock(&notification_mutex);\n\n\tresource_state_has_changed =\n\t    HAS_CHANGED(resource_state_change->role) ||\n\t    HAS_CHANGED(resource_state_change->susp) ||\n\t    HAS_CHANGED(resource_state_change->susp_nod) ||\n\t    HAS_CHANGED(resource_state_change->susp_fen);\n\n\tif (resource_state_has_changed)\n\t\tREMEMBER_STATE_CHANGE(notify_resource_state_change,\n\t\t\t\t      resource_state_change, NOTIFY_CHANGE);\n\n\tfor (n_connection = 0; n_connection < state_change->n_connections; n_connection++) {\n\t\tstruct drbd_connection_state_change *connection_state_change =\n\t\t\t\t&state_change->connections[n_connection];\n\n\t\tif (HAS_CHANGED(connection_state_change->peer_role) ||\n\t\t    HAS_CHANGED(connection_state_change->cstate))\n\t\t\tREMEMBER_STATE_CHANGE(notify_connection_state_change,\n\t\t\t\t\t      connection_state_change, NOTIFY_CHANGE);\n\t}\n\n\tfor (n_device = 0; n_device < state_change->n_devices; n_device++) {\n\t\tstruct drbd_device_state_change *device_state_change =\n\t\t\t&state_change->devices[n_device];\n\n\t\tif (HAS_CHANGED(device_state_change->disk_state))\n\t\t\tREMEMBER_STATE_CHANGE(notify_device_state_change,\n\t\t\t\t\t      device_state_change, NOTIFY_CHANGE);\n\t}\n\n\tn_peer_devices = state_change->n_devices * state_change->n_connections;\n\tfor (n_peer_device = 0; n_peer_device < n_peer_devices; n_peer_device++) {\n\t\tstruct drbd_peer_device_state_change *p =\n\t\t\t&state_change->peer_devices[n_peer_device];\n\n\t\tif (HAS_CHANGED(p->disk_state) ||\n\t\t    HAS_CHANGED(p->repl_state) ||\n\t\t    HAS_CHANGED(p->resync_susp_user) ||\n\t\t    HAS_CHANGED(p->resync_susp_peer) ||\n\t\t    HAS_CHANGED(p->resync_susp_dependency))\n\t\t\tREMEMBER_STATE_CHANGE(notify_peer_device_state_change,\n\t\t\t\t\t      p, NOTIFY_CHANGE);\n\t}\n\n\tFINAL_STATE_CHANGE(NOTIFY_CHANGE);\n\tmutex_unlock(&notification_mutex);\n\n#undef HAS_CHANGED\n#undef FINAL_STATE_CHANGE\n#undef REMEMBER_STATE_CHANGE\n}\n\n \nstatic bool lost_contact_to_peer_data(enum drbd_disk_state os, enum drbd_disk_state ns)\n{\n\tif ((os >= D_INCONSISTENT && os != D_UNKNOWN && os != D_OUTDATED)\n\t&&  (ns < D_INCONSISTENT || ns == D_UNKNOWN || ns == D_OUTDATED))\n\t\treturn true;\n\n\t \n\tif (os == D_UNKNOWN\n\t&&  (ns == D_DISKLESS || ns == D_FAILED || ns == D_OUTDATED))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void after_state_ch(struct drbd_device *device, union drbd_state os,\n\t\t\t   union drbd_state ns, enum chg_state_flags flags,\n\t\t\t   struct drbd_state_change *state_change)\n{\n\tstruct drbd_resource *resource = device->resource;\n\tstruct drbd_peer_device *peer_device = first_peer_device(device);\n\tstruct drbd_connection *connection = peer_device ? peer_device->connection : NULL;\n\tstruct sib_info sib;\n\n\tbroadcast_state_change(state_change);\n\n\tsib.sib_reason = SIB_STATE_CHANGE;\n\tsib.os = os;\n\tsib.ns = ns;\n\n\tif ((os.disk != D_UP_TO_DATE || os.pdsk != D_UP_TO_DATE)\n\t&&  (ns.disk == D_UP_TO_DATE && ns.pdsk == D_UP_TO_DATE)) {\n\t\tclear_bit(CRASHED_PRIMARY, &device->flags);\n\t\tif (device->p_uuid)\n\t\t\tdevice->p_uuid[UI_FLAGS] &= ~((u64)2);\n\t}\n\n\t \n\tdrbd_bcast_event(device, &sib);\n\n\tif (!(os.role == R_PRIMARY && os.disk < D_UP_TO_DATE && os.pdsk < D_UP_TO_DATE) &&\n\t    (ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE))\n\t\tdrbd_khelper(device, \"pri-on-incon-degr\");\n\n\t \n\n\tif (ns.susp_nod) {\n\t\tenum drbd_req_event what = NOTHING;\n\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tif (os.conn < C_CONNECTED && conn_lowest_conn(connection) >= C_CONNECTED)\n\t\t\twhat = RESEND;\n\n\t\tif ((os.disk == D_ATTACHING || os.disk == D_NEGOTIATING) &&\n\t\t    conn_lowest_disk(connection) == D_UP_TO_DATE)\n\t\t\twhat = RESTART_FROZEN_DISK_IO;\n\n\t\tif (resource->susp_nod && what != NOTHING) {\n\t\t\t_tl_restart(connection, what);\n\t\t\t_conn_request_state(connection,\n\t\t\t\t\t    (union drbd_state) { { .susp_nod = 1 } },\n\t\t\t\t\t    (union drbd_state) { { .susp_nod = 0 } },\n\t\t\t\t\t    CS_VERBOSE);\n\t\t}\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t}\n\n\tif (ns.susp_fen) {\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tif (resource->susp_fen && conn_lowest_conn(connection) >= C_CONNECTED) {\n\t\t\t \n\t\t\tstruct drbd_peer_device *peer_device;\n\t\t\tint vnr;\n\n\t\t\trcu_read_lock();\n\t\t\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\t\t\tclear_bit(NEW_CUR_UUID, &peer_device->device->flags);\n\t\t\trcu_read_unlock();\n\n\t\t\t \n\t\t\t_tl_restart(connection, RESEND);\n\t\t\t_conn_request_state(connection,\n\t\t\t\t\t    (union drbd_state) { { .susp_fen = 1 } },\n\t\t\t\t\t    (union drbd_state) { { .susp_fen = 0 } },\n\t\t\t\t\t    CS_VERBOSE);\n\t\t}\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t}\n\n\t \n\tif ((os.conn != C_SYNC_SOURCE && os.conn != C_PAUSED_SYNC_S) &&\n\t    (ns.conn == C_SYNC_SOURCE || ns.conn == C_PAUSED_SYNC_S) &&\n\t    connection->agreed_pro_version >= 96 && get_ldev(device)) {\n\t\tdrbd_gen_and_send_sync_uuid(peer_device);\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (os.pdsk == D_DISKLESS &&\n\t    ns.pdsk > D_DISKLESS && ns.pdsk != D_UNKNOWN) {       \n\t\t \n\t\tdevice->rs_total = 0;\n\t\tdevice->rs_failed = 0;\n\t\tatomic_set(&device->rs_pending_cnt, 0);\n\t\tdrbd_rs_cancel_all(device);\n\n\t\tdrbd_send_uuids(peer_device);\n\t\tdrbd_send_state(peer_device, ns);\n\t}\n\t \n\tif (os.conn != C_WF_BITMAP_S && ns.conn == C_WF_BITMAP_S &&\n\t    device->state.conn == C_WF_BITMAP_S)\n\t\tdrbd_queue_bitmap_io(device, &drbd_send_bitmap, NULL,\n\t\t\t\t\"send_bitmap (WFBitMapS)\",\n\t\t\t\tBM_LOCKED_TEST_ALLOWED, peer_device);\n\n\t \n\tif (lost_contact_to_peer_data(os.pdsk, ns.pdsk)) {\n\t\tif (get_ldev(device)) {\n\t\t\tif ((ns.role == R_PRIMARY || ns.peer == R_PRIMARY) &&\n\t\t\t    device->ldev->md.uuid[UI_BITMAP] == 0 && ns.disk >= D_UP_TO_DATE) {\n\t\t\t\tif (drbd_suspended(device)) {\n\t\t\t\t\tset_bit(NEW_CUR_UUID, &device->flags);\n\t\t\t\t} else {\n\t\t\t\t\tdrbd_uuid_new_current(device);\n\t\t\t\t\tdrbd_send_uuids(peer_device);\n\t\t\t\t}\n\t\t\t}\n\t\t\tput_ldev(device);\n\t\t}\n\t}\n\n\tif (ns.pdsk < D_INCONSISTENT && get_ldev(device)) {\n\t\tif (os.peer != R_PRIMARY && ns.peer == R_PRIMARY &&\n\t\t    device->ldev->md.uuid[UI_BITMAP] == 0 && ns.disk >= D_UP_TO_DATE) {\n\t\t\tdrbd_uuid_new_current(device);\n\t\t\tdrbd_send_uuids(peer_device);\n\t\t}\n\t\t \n\t\tif (os.peer == R_PRIMARY && ns.peer == R_SECONDARY)\n\t\t\t \n\t\t\tdrbd_bitmap_io_from_worker(device, &drbd_bm_write,\n\t\t\t\t\"demote diskless peer\", BM_LOCKED_SET_ALLOWED, peer_device);\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (os.role == R_PRIMARY && ns.role == R_SECONDARY &&\n\t\tdevice->state.conn <= C_CONNECTED && get_ldev(device)) {\n\t\t \n\t\tdrbd_bitmap_io_from_worker(device, &drbd_bm_write,\n\t\t\t\t\"demote\", BM_LOCKED_TEST_ALLOWED, peer_device);\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (ns.conn >= C_CONNECTED &&\n\t    os.disk == D_ATTACHING && ns.disk == D_NEGOTIATING) {\n\t\tdrbd_send_sizes(peer_device, 0, 0);   \n\t\tdrbd_send_uuids(peer_device);\n\t\tdrbd_send_state(peer_device, ns);\n\t}\n\n\t \n\tif (ns.conn >= C_CONNECTED &&\n\t     ((os.aftr_isp != ns.aftr_isp) ||\n\t      (os.user_isp != ns.user_isp)))\n\t\tdrbd_send_state(peer_device, ns);\n\n\t \n\tif ((!os.aftr_isp && !os.peer_isp && !os.user_isp) &&\n\t    (ns.aftr_isp || ns.peer_isp || ns.user_isp))\n\t\tsuspend_other_sg(device);\n\n\t \n\tif (os.conn == C_WF_REPORT_PARAMS && ns.conn >= C_CONNECTED)\n\t\tdrbd_send_state(peer_device, ns);\n\n\tif (os.conn != C_AHEAD && ns.conn == C_AHEAD)\n\t\tdrbd_send_state(peer_device, ns);\n\n\t \n\tif ((os.conn != C_STARTING_SYNC_T && ns.conn == C_STARTING_SYNC_T) ||\n\t    (os.conn != C_STARTING_SYNC_S && ns.conn == C_STARTING_SYNC_S))\n\t\t \n\t\tdrbd_queue_bitmap_io(device,\n\t\t\t&drbd_bmio_set_n_write, &abw_start_sync,\n\t\t\t\"set_n_write from StartingSync\", BM_LOCKED_TEST_ALLOWED,\n\t\t\tpeer_device);\n\n\t \n\tif (os.disk != D_FAILED && ns.disk == D_FAILED) {\n\t\tenum drbd_io_error_p eh = EP_PASS_ON;\n\t\tint was_io_error = 0;\n\t\t \n\t\tif (device->ldev) {\n\t\t\trcu_read_lock();\n\t\t\teh = rcu_dereference(device->ldev->disk_conf)->on_io_error;\n\t\t\trcu_read_unlock();\n\n\t\t\twas_io_error = test_and_clear_bit(WAS_IO_ERROR, &device->flags);\n\n\t\t\t \n\t\t\tif (was_io_error && eh == EP_CALL_HELPER)\n\t\t\t\tdrbd_khelper(device, \"local-io-error\");\n\n\t\t\t \n\t\t\tif (test_and_clear_bit(FORCE_DETACH, &device->flags))\n\t\t\t\ttl_abort_disk_io(device);\n\n\t\t\t \n\t\t\tif (device->state.disk != D_FAILED)\n\t\t\t\tdrbd_err(device,\n\t\t\t\t\t\"ASSERT FAILED: disk is %s during detach\\n\",\n\t\t\t\t\tdrbd_disk_str(device->state.disk));\n\n\t\t\tif (ns.conn >= C_CONNECTED)\n\t\t\t\tdrbd_send_state(peer_device, ns);\n\n\t\t\tdrbd_rs_cancel_all(device);\n\n\t\t\t \n\t\t\tdrbd_md_sync(device);\n\t\t}\n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (os.disk != D_DISKLESS && ns.disk == D_DISKLESS) {\n\t\t \n\t\tif (device->state.disk != D_DISKLESS)\n\t\t\tdrbd_err(device,\n\t\t\t\t \"ASSERT FAILED: disk is %s while going diskless\\n\",\n\t\t\t\t drbd_disk_str(device->state.disk));\n\n\t\tif (ns.conn >= C_CONNECTED)\n\t\t\tdrbd_send_state(peer_device, ns);\n\t\t \n\t\tput_ldev(device);\n\t}\n\n\t \n\tif (os.disk == D_UP_TO_DATE && ns.disk == D_INCONSISTENT && ns.conn >= C_CONNECTED)\n\t\tdrbd_send_state(peer_device, ns);\n\n\t \n\tif (ns.disk > D_NEGOTIATING && ns.pdsk > D_NEGOTIATING &&\n\t    test_and_clear_bit(RESYNC_AFTER_NEG, &device->flags)) {\n\t\tif (ns.conn == C_CONNECTED)\n\t\t\tresync_after_online_grow(device);\n\t}\n\n\t \n\tif ((os.conn > C_CONNECTED && ns.conn <= C_CONNECTED) ||\n\t    (os.peer_isp && !ns.peer_isp) ||\n\t    (os.user_isp && !ns.user_isp))\n\t\tresume_next_sg(device);\n\n\t \n\tif (os.disk < D_UP_TO_DATE && os.conn >= C_SYNC_SOURCE && ns.conn == C_CONNECTED)\n\t\tdrbd_send_state(peer_device, ns);\n\n\t \n\tif (os.conn == C_VERIFY_S && ns.conn == C_CONNECTED\n\t&& verify_can_do_stop_sector(device))\n\t\tdrbd_send_state(peer_device, ns);\n\n\t \n\tif ((os.conn > C_CONNECTED && os.conn < C_AHEAD) &&\n\t    (ns.conn == C_CONNECTED || ns.conn >= C_AHEAD) && get_ldev(device)) {\n\t\tdrbd_queue_bitmap_io(device, &drbd_bm_write_copy_pages, NULL,\n\t\t\t\"write from resync_finished\", BM_LOCKED_CHANGE_ALLOWED,\n\t\t\tpeer_device);\n\t\tput_ldev(device);\n\t}\n\n\tif (ns.disk == D_DISKLESS &&\n\t    ns.conn == C_STANDALONE &&\n\t    ns.role == R_SECONDARY) {\n\t\tif (os.aftr_isp != ns.aftr_isp)\n\t\t\tresume_next_sg(device);\n\t}\n\n\tdrbd_md_sync(device);\n}\n\nstruct after_conn_state_chg_work {\n\tstruct drbd_work w;\n\tenum drbd_conns oc;\n\tunion drbd_state ns_min;\n\tunion drbd_state ns_max;  \n\tenum chg_state_flags flags;\n\tstruct drbd_connection *connection;\n\tstruct drbd_state_change *state_change;\n};\n\nstatic int w_after_conn_state_ch(struct drbd_work *w, int unused)\n{\n\tstruct after_conn_state_chg_work *acscw =\n\t\tcontainer_of(w, struct after_conn_state_chg_work, w);\n\tstruct drbd_connection *connection = acscw->connection;\n\tenum drbd_conns oc = acscw->oc;\n\tunion drbd_state ns_max = acscw->ns_max;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\tbroadcast_state_change(acscw->state_change);\n\tforget_state_change(acscw->state_change);\n\tkfree(acscw);\n\n\t \n\tif (oc == C_STANDALONE && ns_max.conn == C_UNCONNECTED)\n\t\tdrbd_thread_start(&connection->receiver);\n\n\tif (oc == C_DISCONNECTING && ns_max.conn == C_STANDALONE) {\n\t\tstruct net_conf *old_conf;\n\n\t\tmutex_lock(&notification_mutex);\n\t\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\t\tnotify_peer_device_state(NULL, 0, peer_device, NULL,\n\t\t\t\t\t\t NOTIFY_DESTROY | NOTIFY_CONTINUES);\n\t\tnotify_connection_state(NULL, 0, connection, NULL, NOTIFY_DESTROY);\n\t\tmutex_unlock(&notification_mutex);\n\n\t\tmutex_lock(&connection->resource->conf_update);\n\t\told_conf = connection->net_conf;\n\t\tconnection->my_addr_len = 0;\n\t\tconnection->peer_addr_len = 0;\n\t\tRCU_INIT_POINTER(connection->net_conf, NULL);\n\t\tconn_free_crypto(connection);\n\t\tmutex_unlock(&connection->resource->conf_update);\n\n\t\tkvfree_rcu_mightsleep(old_conf);\n\t}\n\n\tif (ns_max.susp_fen) {\n\t\t \n\t\tif (ns_max.pdsk <= D_OUTDATED) {\n\t\t\trcu_read_lock();\n\t\t\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\t\t\tstruct drbd_device *device = peer_device->device;\n\t\t\t\tif (test_bit(NEW_CUR_UUID, &device->flags)) {\n\t\t\t\t\tdrbd_uuid_new_current(device);\n\t\t\t\t\tclear_bit(NEW_CUR_UUID, &device->flags);\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tspin_lock_irq(&connection->resource->req_lock);\n\t\t\t_tl_restart(connection, CONNECTION_LOST_WHILE_PENDING);\n\t\t\t_conn_request_state(connection,\n\t\t\t\t\t    (union drbd_state) { { .susp_fen = 1 } },\n\t\t\t\t\t    (union drbd_state) { { .susp_fen = 0 } },\n\t\t\t\t\t    CS_VERBOSE);\n\t\t\tspin_unlock_irq(&connection->resource->req_lock);\n\t\t}\n\t}\n\tconn_md_sync(connection);\n\tkref_put(&connection->kref, drbd_destroy_connection);\n\n\treturn 0;\n}\n\nstatic void conn_old_common_state(struct drbd_connection *connection, union drbd_state *pcs, enum chg_state_flags *pf)\n{\n\tenum chg_state_flags flags = ~0;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr, first_vol = 1;\n\tunion drbd_dev_state os, cs = {\n\t\t{ .role = R_SECONDARY,\n\t\t  .peer = R_UNKNOWN,\n\t\t  .conn = connection->cstate,\n\t\t  .disk = D_DISKLESS,\n\t\t  .pdsk = D_UNKNOWN,\n\t\t} };\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tos = device->state;\n\n\t\tif (first_vol) {\n\t\t\tcs = os;\n\t\t\tfirst_vol = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cs.role != os.role)\n\t\t\tflags &= ~CS_DC_ROLE;\n\n\t\tif (cs.peer != os.peer)\n\t\t\tflags &= ~CS_DC_PEER;\n\n\t\tif (cs.conn != os.conn)\n\t\t\tflags &= ~CS_DC_CONN;\n\n\t\tif (cs.disk != os.disk)\n\t\t\tflags &= ~CS_DC_DISK;\n\n\t\tif (cs.pdsk != os.pdsk)\n\t\t\tflags &= ~CS_DC_PDSK;\n\t}\n\trcu_read_unlock();\n\n\t*pf |= CS_DC_MASK;\n\t*pf &= flags;\n\t(*pcs).i = cs.i;\n}\n\nstatic enum drbd_state_rv\nconn_is_valid_transition(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t\t\t enum chg_state_flags flags)\n{\n\tenum drbd_state_rv rv = SS_SUCCESS;\n\tunion drbd_state ns, os;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tos = drbd_read_state(device);\n\t\tns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\n\n\t\tif (flags & CS_IGN_OUTD_FAIL && ns.disk == D_OUTDATED && os.disk < D_OUTDATED)\n\t\t\tns.disk = os.disk;\n\n\t\tif (ns.i == os.i)\n\t\t\tcontinue;\n\n\t\trv = is_valid_transition(os, ns);\n\n\t\tif (rv >= SS_SUCCESS && !(flags & CS_HARD)) {\n\t\t\trv = is_valid_state(device, ns);\n\t\t\tif (rv < SS_SUCCESS) {\n\t\t\t\tif (is_valid_state(device, os) == rv)\n\t\t\t\t\trv = is_valid_soft_transition(os, ns, connection);\n\t\t\t} else\n\t\t\t\trv = is_valid_soft_transition(os, ns, connection);\n\t\t}\n\n\t\tif (rv < SS_SUCCESS) {\n\t\t\tif (flags & CS_VERBOSE)\n\t\t\t\tprint_st_err(device, os, ns, rv);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\nstatic void\nconn_set_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t       union drbd_state *pns_min, union drbd_state *pns_max, enum chg_state_flags flags)\n{\n\tunion drbd_state ns, os, ns_max = { };\n\tunion drbd_state ns_min = {\n\t\t{ .role = R_MASK,\n\t\t  .peer = R_MASK,\n\t\t  .conn = val.conn,\n\t\t  .disk = D_MASK,\n\t\t  .pdsk = D_MASK\n\t\t} };\n\tstruct drbd_peer_device *peer_device;\n\tenum drbd_state_rv rv;\n\tint vnr, number_of_volumes = 0;\n\n\tif (mask.conn == C_MASK) {\n\t\t \n\t\tif (connection->cstate != C_WF_REPORT_PARAMS && val.conn == C_WF_REPORT_PARAMS)\n\t\t\tconnection->last_reconnect_jif = jiffies;\n\n\t\tconnection->cstate = val.conn;\n\t}\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tnumber_of_volumes++;\n\t\tos = drbd_read_state(device);\n\t\tns = apply_mask_val(os, mask, val);\n\t\tns = sanitize_state(device, os, ns, NULL);\n\n\t\tif (flags & CS_IGN_OUTD_FAIL && ns.disk == D_OUTDATED && os.disk < D_OUTDATED)\n\t\t\tns.disk = os.disk;\n\n\t\trv = _drbd_set_state(device, ns, flags, NULL);\n\t\tBUG_ON(rv < SS_SUCCESS);\n\t\tns.i = device->state.i;\n\t\tns_max.role = max_role(ns.role, ns_max.role);\n\t\tns_max.peer = max_role(ns.peer, ns_max.peer);\n\t\tns_max.conn = max_t(enum drbd_conns, ns.conn, ns_max.conn);\n\t\tns_max.disk = max_t(enum drbd_disk_state, ns.disk, ns_max.disk);\n\t\tns_max.pdsk = max_t(enum drbd_disk_state, ns.pdsk, ns_max.pdsk);\n\n\t\tns_min.role = min_role(ns.role, ns_min.role);\n\t\tns_min.peer = min_role(ns.peer, ns_min.peer);\n\t\tns_min.conn = min_t(enum drbd_conns, ns.conn, ns_min.conn);\n\t\tns_min.disk = min_t(enum drbd_disk_state, ns.disk, ns_min.disk);\n\t\tns_min.pdsk = min_t(enum drbd_disk_state, ns.pdsk, ns_min.pdsk);\n\t}\n\trcu_read_unlock();\n\n\tif (number_of_volumes == 0) {\n\t\tns_min = ns_max = (union drbd_state) { {\n\t\t\t\t.role = R_SECONDARY,\n\t\t\t\t.peer = R_UNKNOWN,\n\t\t\t\t.conn = val.conn,\n\t\t\t\t.disk = D_DISKLESS,\n\t\t\t\t.pdsk = D_UNKNOWN\n\t\t\t} };\n\t}\n\n\tns_min.susp = ns_max.susp = connection->resource->susp;\n\tns_min.susp_nod = ns_max.susp_nod = connection->resource->susp_nod;\n\tns_min.susp_fen = ns_max.susp_fen = connection->resource->susp_fen;\n\n\t*pns_min = ns_min;\n\t*pns_max = ns_max;\n}\n\nstatic enum drbd_state_rv\n_conn_rq_cond(struct drbd_connection *connection, union drbd_state mask, union drbd_state val)\n{\n\tenum drbd_state_rv err, rv = SS_UNKNOWN_ERROR;  ;\n\n\tif (test_and_clear_bit(CONN_WD_ST_CHG_OKAY, &connection->flags))\n\t\trv = SS_CW_SUCCESS;\n\n\tif (test_and_clear_bit(CONN_WD_ST_CHG_FAIL, &connection->flags))\n\t\trv = SS_CW_FAILED_BY_PEER;\n\n\terr = conn_is_valid_transition(connection, mask, val, 0);\n\tif (err == SS_SUCCESS && connection->cstate == C_WF_REPORT_PARAMS)\n\t\treturn rv;\n\n\treturn err;\n}\n\nenum drbd_state_rv\n_conn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t\t    enum chg_state_flags flags)\n{\n\tenum drbd_state_rv rv = SS_SUCCESS;\n\tstruct after_conn_state_chg_work *acscw;\n\tenum drbd_conns oc = connection->cstate;\n\tunion drbd_state ns_max, ns_min, os;\n\tbool have_mutex = false;\n\tstruct drbd_state_change *state_change;\n\n\tif (mask.conn) {\n\t\trv = is_valid_conn_transition(oc, val.conn);\n\t\tif (rv < SS_SUCCESS)\n\t\t\tgoto abort;\n\t}\n\n\trv = conn_is_valid_transition(connection, mask, val, flags);\n\tif (rv < SS_SUCCESS)\n\t\tgoto abort;\n\n\tif (oc == C_WF_REPORT_PARAMS && val.conn == C_DISCONNECTING &&\n\t    !(flags & (CS_LOCAL_ONLY | CS_HARD))) {\n\n\t\t \n\t\tspin_unlock_irq(&connection->resource->req_lock);\n\t\tmutex_lock(&connection->cstate_mutex);\n\t\thave_mutex = true;\n\n\t\tset_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\n\t\tif (conn_send_state_req(connection, mask, val)) {\n\t\t\t \n\t\t\tclear_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\n\t\t\trv = SS_CW_FAILED_BY_PEER;\n\t\t\t \n\t\t\tgoto abort_unlocked;\n\t\t}\n\n\t\tif (val.conn == C_DISCONNECTING)\n\t\t\tset_bit(DISCONNECT_SENT, &connection->flags);\n\n\t\t \n\t\tspin_lock_irq(&connection->resource->req_lock);\n\t\twait_event_lock_irq(connection->ping_wait,\n\t\t\t\t(rv = _conn_rq_cond(connection, mask, val)),\n\t\t\t\tconnection->resource->req_lock);\n\t\tclear_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\n\t\tif (rv < SS_SUCCESS)\n\t\t\tgoto abort;\n\t}\n\n\tstate_change = remember_old_state(connection->resource, GFP_ATOMIC);\n\tconn_old_common_state(connection, &os, &flags);\n\tflags |= CS_DC_SUSP;\n\tconn_set_state(connection, mask, val, &ns_min, &ns_max, flags);\n\tconn_pr_state_change(connection, os, ns_max, flags);\n\tremember_new_state(state_change);\n\n\tacscw = kmalloc(sizeof(*acscw), GFP_ATOMIC);\n\tif (acscw) {\n\t\tacscw->oc = os.conn;\n\t\tacscw->ns_min = ns_min;\n\t\tacscw->ns_max = ns_max;\n\t\tacscw->flags = flags;\n\t\tacscw->w.cb = w_after_conn_state_ch;\n\t\tkref_get(&connection->kref);\n\t\tacscw->connection = connection;\n\t\tacscw->state_change = state_change;\n\t\tdrbd_queue_work(&connection->sender_work, &acscw->w);\n\t} else {\n\t\tdrbd_err(connection, \"Could not kmalloc an acscw\\n\");\n\t}\n\n abort:\n\tif (have_mutex) {\n\t\t \n\t\tspin_unlock_irq(&connection->resource->req_lock);\n abort_unlocked:\n\t\tmutex_unlock(&connection->cstate_mutex);\n\t\tspin_lock_irq(&connection->resource->req_lock);\n\t}\n\tif (rv < SS_SUCCESS && flags & CS_VERBOSE) {\n\t\tdrbd_err(connection, \"State change failed: %s\\n\", drbd_set_st_err_str(rv));\n\t\tdrbd_err(connection, \" mask = 0x%x val = 0x%x\\n\", mask.i, val.i);\n\t\tdrbd_err(connection, \" old_conn:%s wanted_conn:%s\\n\", drbd_conn_str(oc), drbd_conn_str(val.conn));\n\t}\n\treturn rv;\n}\n\nenum drbd_state_rv\nconn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t\t   enum chg_state_flags flags)\n{\n\tenum drbd_state_rv rv;\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\trv = _conn_request_state(connection, mask, val, flags);\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\treturn rv;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}