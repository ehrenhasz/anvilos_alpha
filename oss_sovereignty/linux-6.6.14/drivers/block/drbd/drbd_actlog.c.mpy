{
  "module_name": "drbd_actlog.c",
  "hash_id": "02c7d8ce1851d4d6ed69de3680eab06c08243f3a5b3c4b47d27130da67b8eeb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_actlog.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/crc32c.h>\n#include <linux/drbd.h>\n#include <linux/drbd_limits.h>\n#include \"drbd_int.h\"\n\n\nenum al_transaction_types {\n\tAL_TR_UPDATE = 0,\n\tAL_TR_INITIALIZED = 0xffff\n};\n \nstruct __packed al_transaction_on_disk {\n\t \n\t__be32\tmagic;\n\n\t \n\t__be32\ttr_number;\n\n\t \n\t__be32\tcrc32c;\n\n\t \n\t__be16\ttransaction_type;\n\n\t \n\n\t \n\t__be16\tn_updates;\n\n\t \n\t__be16\tcontext_size;\n\n\t \n\t__be16\tcontext_start_slot_nr;\n\n\t \n\t__be32\t__reserved[4];\n\n\t \n\n\t \n\t__be16\tupdate_slot_nr[AL_UPDATES_PER_TRANSACTION];\n\n\t \n\t__be32\tupdate_extent_nr[AL_UPDATES_PER_TRANSACTION];\n\n\t \n\n\t \n\t__be32\tcontext[AL_CONTEXT_PER_TRANSACTION];\n};\n\nvoid *drbd_md_get_buffer(struct drbd_device *device, const char *intent)\n{\n\tint r;\n\n\twait_event(device->misc_wait,\n\t\t   (r = atomic_cmpxchg(&device->md_io.in_use, 0, 1)) == 0 ||\n\t\t   device->state.disk <= D_FAILED);\n\n\tif (r)\n\t\treturn NULL;\n\n\tdevice->md_io.current_use = intent;\n\tdevice->md_io.start_jif = jiffies;\n\tdevice->md_io.submit_jif = device->md_io.start_jif - 1;\n\treturn page_address(device->md_io.page);\n}\n\nvoid drbd_md_put_buffer(struct drbd_device *device)\n{\n\tif (atomic_dec_and_test(&device->md_io.in_use))\n\t\twake_up(&device->misc_wait);\n}\n\nvoid wait_until_done_or_force_detached(struct drbd_device *device, struct drbd_backing_dev *bdev,\n\t\t\t\t     unsigned int *done)\n{\n\tlong dt;\n\n\trcu_read_lock();\n\tdt = rcu_dereference(bdev->disk_conf)->disk_timeout;\n\trcu_read_unlock();\n\tdt = dt * HZ / 10;\n\tif (dt == 0)\n\t\tdt = MAX_SCHEDULE_TIMEOUT;\n\n\tdt = wait_event_timeout(device->misc_wait,\n\t\t\t*done || test_bit(FORCE_DETACH, &device->flags), dt);\n\tif (dt == 0) {\n\t\tdrbd_err(device, \"meta-data IO operation timed out\\n\");\n\t\tdrbd_chk_io_error(device, 1, DRBD_FORCE_DETACH);\n\t}\n}\n\nstatic int _drbd_md_sync_page_io(struct drbd_device *device,\n\t\t\t\t struct drbd_backing_dev *bdev,\n\t\t\t\t sector_t sector, enum req_op op)\n{\n\tstruct bio *bio;\n\t \n\tconst int size = 4096;\n\tint err;\n\tblk_opf_t op_flags = 0;\n\n\tdevice->md_io.done = 0;\n\tdevice->md_io.error = -ENODEV;\n\n\tif ((op == REQ_OP_WRITE) && !test_bit(MD_NO_FUA, &device->flags))\n\t\top_flags |= REQ_FUA | REQ_PREFLUSH;\n\top_flags |= REQ_SYNC;\n\n\tbio = bio_alloc_bioset(bdev->md_bdev, 1, op | op_flags, GFP_NOIO,\n\t\t\t       &drbd_md_io_bio_set);\n\tbio->bi_iter.bi_sector = sector;\n\terr = -EIO;\n\tif (bio_add_page(bio, device->md_io.page, size, 0) != size)\n\t\tgoto out;\n\tbio->bi_private = device;\n\tbio->bi_end_io = drbd_md_endio;\n\n\tif (op != REQ_OP_WRITE && device->state.disk == D_DISKLESS && device->ldev == NULL)\n\t\t \n\t\t;\n\telse if (!get_ldev_if_state(device, D_ATTACHING)) {\n\t\t \n\t\tdrbd_err(device, \"ASSERT FAILED: get_ldev_if_state() == 1 in _drbd_md_sync_page_io()\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tbio_get(bio);  \n\tatomic_inc(&device->md_io.in_use);  \n\tdevice->md_io.submit_jif = jiffies;\n\tif (drbd_insert_fault(device, (op == REQ_OP_WRITE) ? DRBD_FAULT_MD_WR : DRBD_FAULT_MD_RD))\n\t\tbio_io_error(bio);\n\telse\n\t\tsubmit_bio(bio);\n\twait_until_done_or_force_detached(device, bdev, &device->md_io.done);\n\tif (!bio->bi_status)\n\t\terr = device->md_io.error;\n\n out:\n\tbio_put(bio);\n\treturn err;\n}\n\nint drbd_md_sync_page_io(struct drbd_device *device, struct drbd_backing_dev *bdev,\n\t\t\t sector_t sector, enum req_op op)\n{\n\tint err;\n\tD_ASSERT(device, atomic_read(&device->md_io.in_use) == 1);\n\n\tBUG_ON(!bdev->md_bdev);\n\n\tdynamic_drbd_dbg(device, \"meta_data io: %s [%d]:%s(,%llus,%s) %pS\\n\",\n\t     current->comm, current->pid, __func__,\n\t     (unsigned long long)sector, (op == REQ_OP_WRITE) ? \"WRITE\" : \"READ\",\n\t     (void*)_RET_IP_ );\n\n\tif (sector < drbd_md_first_sector(bdev) ||\n\t    sector + 7 > drbd_md_last_sector(bdev))\n\t\tdrbd_alert(device, \"%s [%d]:%s(,%llus,%s) out of range md access!\\n\",\n\t\t     current->comm, current->pid, __func__,\n\t\t     (unsigned long long)sector,\n\t\t     (op == REQ_OP_WRITE) ? \"WRITE\" : \"READ\");\n\n\terr = _drbd_md_sync_page_io(device, bdev, sector, op);\n\tif (err) {\n\t\tdrbd_err(device, \"drbd_md_sync_page_io(,%llus,%s) failed with error %d\\n\",\n\t\t    (unsigned long long)sector,\n\t\t    (op == REQ_OP_WRITE) ? \"WRITE\" : \"READ\", err);\n\t}\n\treturn err;\n}\n\nstatic struct bm_extent *find_active_resync_extent(struct drbd_device *device, unsigned int enr)\n{\n\tstruct lc_element *tmp;\n\ttmp = lc_find(device->resync, enr/AL_EXT_PER_BM_SECT);\n\tif (unlikely(tmp != NULL)) {\n\t\tstruct bm_extent  *bm_ext = lc_entry(tmp, struct bm_extent, lce);\n\t\tif (test_bit(BME_NO_WRITES, &bm_ext->flags))\n\t\t\treturn bm_ext;\n\t}\n\treturn NULL;\n}\n\nstatic struct lc_element *_al_get(struct drbd_device *device, unsigned int enr, bool nonblock)\n{\n\tstruct lc_element *al_ext;\n\tstruct bm_extent *bm_ext;\n\tint wake;\n\n\tspin_lock_irq(&device->al_lock);\n\tbm_ext = find_active_resync_extent(device, enr);\n\tif (bm_ext) {\n\t\twake = !test_and_set_bit(BME_PRIORITY, &bm_ext->flags);\n\t\tspin_unlock_irq(&device->al_lock);\n\t\tif (wake)\n\t\t\twake_up(&device->al_wait);\n\t\treturn NULL;\n\t}\n\tif (nonblock)\n\t\tal_ext = lc_try_get(device->act_log, enr);\n\telse\n\t\tal_ext = lc_get(device->act_log, enr);\n\tspin_unlock_irq(&device->al_lock);\n\treturn al_ext;\n}\n\nbool drbd_al_begin_io_fastpath(struct drbd_device *device, struct drbd_interval *i)\n{\n\t \n\tunsigned first = i->sector >> (AL_EXTENT_SHIFT-9);\n\tunsigned last = i->size == 0 ? first : (i->sector + (i->size >> 9) - 1) >> (AL_EXTENT_SHIFT-9);\n\n\tD_ASSERT(device, first <= last);\n\tD_ASSERT(device, atomic_read(&device->local_cnt) > 0);\n\n\t \n\tif (first != last)\n\t\treturn false;\n\n\treturn _al_get(device, first, true);\n}\n\nbool drbd_al_begin_io_prepare(struct drbd_device *device, struct drbd_interval *i)\n{\n\t \n\tunsigned first = i->sector >> (AL_EXTENT_SHIFT-9);\n\tunsigned last = i->size == 0 ? first : (i->sector + (i->size >> 9) - 1) >> (AL_EXTENT_SHIFT-9);\n\tunsigned enr;\n\tbool need_transaction = false;\n\n\tD_ASSERT(device, first <= last);\n\tD_ASSERT(device, atomic_read(&device->local_cnt) > 0);\n\n\tfor (enr = first; enr <= last; enr++) {\n\t\tstruct lc_element *al_ext;\n\t\twait_event(device->al_wait,\n\t\t\t\t(al_ext = _al_get(device, enr, false)) != NULL);\n\t\tif (al_ext->lc_number != enr)\n\t\t\tneed_transaction = true;\n\t}\n\treturn need_transaction;\n}\n\n#if (PAGE_SHIFT + 3) < (AL_EXTENT_SHIFT - BM_BLOCK_SHIFT)\n \n# error FIXME\n#endif\n\nstatic unsigned int al_extent_to_bm_page(unsigned int al_enr)\n{\n\treturn al_enr >>\n\t\t \n\t\t((PAGE_SHIFT + 3) -\n\t\t \n\t\t (AL_EXTENT_SHIFT - BM_BLOCK_SHIFT));\n}\n\nstatic sector_t al_tr_number_to_on_disk_sector(struct drbd_device *device)\n{\n\tconst unsigned int stripes = device->ldev->md.al_stripes;\n\tconst unsigned int stripe_size_4kB = device->ldev->md.al_stripe_size_4k;\n\n\t \n\tunsigned int t = device->al_tr_number % (device->ldev->md.al_size_4k);\n\n\t \n\tt = ((t % stripes) * stripe_size_4kB) + t/stripes;\n\n\t \n\tt *= 8;\n\n\t \n\treturn device->ldev->md.md_offset + device->ldev->md.al_offset + t;\n}\n\nstatic int __al_write_transaction(struct drbd_device *device, struct al_transaction_on_disk *buffer)\n{\n\tstruct lc_element *e;\n\tsector_t sector;\n\tint i, mx;\n\tunsigned extent_nr;\n\tunsigned crc = 0;\n\tint err = 0;\n\n\tmemset(buffer, 0, sizeof(*buffer));\n\tbuffer->magic = cpu_to_be32(DRBD_AL_MAGIC);\n\tbuffer->tr_number = cpu_to_be32(device->al_tr_number);\n\n\ti = 0;\n\n\tdrbd_bm_reset_al_hints(device);\n\n\t \n\tspin_lock_irq(&device->al_lock);\n\tlist_for_each_entry(e, &device->act_log->to_be_changed, list) {\n\t\tif (i == AL_UPDATES_PER_TRANSACTION) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer->update_slot_nr[i] = cpu_to_be16(e->lc_index);\n\t\tbuffer->update_extent_nr[i] = cpu_to_be32(e->lc_new_number);\n\t\tif (e->lc_number != LC_FREE)\n\t\t\tdrbd_bm_mark_for_writeout(device,\n\t\t\t\t\tal_extent_to_bm_page(e->lc_number));\n\t\ti++;\n\t}\n\tspin_unlock_irq(&device->al_lock);\n\tBUG_ON(i > AL_UPDATES_PER_TRANSACTION);\n\n\tbuffer->n_updates = cpu_to_be16(i);\n\tfor ( ; i < AL_UPDATES_PER_TRANSACTION; i++) {\n\t\tbuffer->update_slot_nr[i] = cpu_to_be16(-1);\n\t\tbuffer->update_extent_nr[i] = cpu_to_be32(LC_FREE);\n\t}\n\n\tbuffer->context_size = cpu_to_be16(device->act_log->nr_elements);\n\tbuffer->context_start_slot_nr = cpu_to_be16(device->al_tr_cycle);\n\n\tmx = min_t(int, AL_CONTEXT_PER_TRANSACTION,\n\t\t   device->act_log->nr_elements - device->al_tr_cycle);\n\tfor (i = 0; i < mx; i++) {\n\t\tunsigned idx = device->al_tr_cycle + i;\n\t\textent_nr = lc_element_by_index(device->act_log, idx)->lc_number;\n\t\tbuffer->context[i] = cpu_to_be32(extent_nr);\n\t}\n\tfor (; i < AL_CONTEXT_PER_TRANSACTION; i++)\n\t\tbuffer->context[i] = cpu_to_be32(LC_FREE);\n\n\tdevice->al_tr_cycle += AL_CONTEXT_PER_TRANSACTION;\n\tif (device->al_tr_cycle >= device->act_log->nr_elements)\n\t\tdevice->al_tr_cycle = 0;\n\n\tsector = al_tr_number_to_on_disk_sector(device);\n\n\tcrc = crc32c(0, buffer, 4096);\n\tbuffer->crc32c = cpu_to_be32(crc);\n\n\tif (drbd_bm_write_hinted(device))\n\t\terr = -EIO;\n\telse {\n\t\tbool write_al_updates;\n\t\trcu_read_lock();\n\t\twrite_al_updates = rcu_dereference(device->ldev->disk_conf)->al_updates;\n\t\trcu_read_unlock();\n\t\tif (write_al_updates) {\n\t\t\tif (drbd_md_sync_page_io(device, device->ldev, sector, REQ_OP_WRITE)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tdrbd_chk_io_error(device, 1, DRBD_META_IO_ERROR);\n\t\t\t} else {\n\t\t\t\tdevice->al_tr_number++;\n\t\t\t\tdevice->al_writ_cnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int al_write_transaction(struct drbd_device *device)\n{\n\tstruct al_transaction_on_disk *buffer;\n\tint err;\n\n\tif (!get_ldev(device)) {\n\t\tdrbd_err(device, \"disk is %s, cannot start al transaction\\n\",\n\t\t\tdrbd_disk_str(device->state.disk));\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (device->state.disk < D_INCONSISTENT) {\n\t\tdrbd_err(device,\n\t\t\t\"disk is %s, cannot write al transaction\\n\",\n\t\t\tdrbd_disk_str(device->state.disk));\n\t\tput_ldev(device);\n\t\treturn -EIO;\n\t}\n\n\t \n\tbuffer = drbd_md_get_buffer(device, __func__);\n\tif (!buffer) {\n\t\tdrbd_err(device, \"disk failed while waiting for md_io buffer\\n\");\n\t\tput_ldev(device);\n\t\treturn -ENODEV;\n\t}\n\n\terr = __al_write_transaction(device, buffer);\n\n\tdrbd_md_put_buffer(device);\n\tput_ldev(device);\n\n\treturn err;\n}\n\n\nvoid drbd_al_begin_io_commit(struct drbd_device *device)\n{\n\tbool locked = false;\n\n\t \n\twait_event(device->al_wait,\n\t\t\tdevice->act_log->pending_changes == 0 ||\n\t\t\t(locked = lc_try_lock_for_transaction(device->act_log)));\n\n\tif (locked) {\n\t\t \n\t\tif (device->act_log->pending_changes) {\n\t\t\tbool write_al_updates;\n\n\t\t\trcu_read_lock();\n\t\t\twrite_al_updates = rcu_dereference(device->ldev->disk_conf)->al_updates;\n\t\t\trcu_read_unlock();\n\n\t\t\tif (write_al_updates)\n\t\t\t\tal_write_transaction(device);\n\t\t\tspin_lock_irq(&device->al_lock);\n\t\t\t \n\t\t\tlc_committed(device->act_log);\n\t\t\tspin_unlock_irq(&device->al_lock);\n\t\t}\n\t\tlc_unlock(device->act_log);\n\t\twake_up(&device->al_wait);\n\t}\n}\n\n \nvoid drbd_al_begin_io(struct drbd_device *device, struct drbd_interval *i)\n{\n\tif (drbd_al_begin_io_prepare(device, i))\n\t\tdrbd_al_begin_io_commit(device);\n}\n\nint drbd_al_begin_io_nonblock(struct drbd_device *device, struct drbd_interval *i)\n{\n\tstruct lru_cache *al = device->act_log;\n\t \n\tunsigned first = i->sector >> (AL_EXTENT_SHIFT-9);\n\tunsigned last = i->size == 0 ? first : (i->sector + (i->size >> 9) - 1) >> (AL_EXTENT_SHIFT-9);\n\tunsigned nr_al_extents;\n\tunsigned available_update_slots;\n\tunsigned enr;\n\n\tD_ASSERT(device, first <= last);\n\n\tnr_al_extents = 1 + last - first;  \n\tavailable_update_slots = min(al->nr_elements - al->used,\n\t\t\t\tal->max_pending_changes - al->pending_changes);\n\n\t \n\tif (available_update_slots < nr_al_extents) {\n\t\t \n\t\tif (!al->pending_changes)\n\t\t\t__set_bit(__LC_STARVING, &device->act_log->flags);\n\t\treturn -ENOBUFS;\n\t}\n\n\t \n\tfor (enr = first; enr <= last; enr++) {\n\t\tstruct lc_element *tmp;\n\t\ttmp = lc_find(device->resync, enr/AL_EXT_PER_BM_SECT);\n\t\tif (unlikely(tmp != NULL)) {\n\t\t\tstruct bm_extent  *bm_ext = lc_entry(tmp, struct bm_extent, lce);\n\t\t\tif (test_bit(BME_NO_WRITES, &bm_ext->flags)) {\n\t\t\t\tif (!test_and_set_bit(BME_PRIORITY, &bm_ext->flags))\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\treturn -EWOULDBLOCK;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (enr = first; enr <= last; enr++) {\n\t\tstruct lc_element *al_ext;\n\t\tal_ext = lc_get_cumulative(device->act_log, enr);\n\t\tif (!al_ext)\n\t\t\tdrbd_info(device, \"LOGIC BUG for enr=%u\\n\", enr);\n\t}\n\treturn 0;\n}\n\nvoid drbd_al_complete_io(struct drbd_device *device, struct drbd_interval *i)\n{\n\t \n\tunsigned first = i->sector >> (AL_EXTENT_SHIFT-9);\n\tunsigned last = i->size == 0 ? first : (i->sector + (i->size >> 9) - 1) >> (AL_EXTENT_SHIFT-9);\n\tunsigned enr;\n\tstruct lc_element *extent;\n\tunsigned long flags;\n\n\tD_ASSERT(device, first <= last);\n\tspin_lock_irqsave(&device->al_lock, flags);\n\n\tfor (enr = first; enr <= last; enr++) {\n\t\textent = lc_find(device->act_log, enr);\n\t\tif (!extent) {\n\t\t\tdrbd_err(device, \"al_complete_io() called on inactive extent %u\\n\", enr);\n\t\t\tcontinue;\n\t\t}\n\t\tlc_put(device->act_log, extent);\n\t}\n\tspin_unlock_irqrestore(&device->al_lock, flags);\n\twake_up(&device->al_wait);\n}\n\nstatic int _try_lc_del(struct drbd_device *device, struct lc_element *al_ext)\n{\n\tint rv;\n\n\tspin_lock_irq(&device->al_lock);\n\trv = (al_ext->refcnt == 0);\n\tif (likely(rv))\n\t\tlc_del(device->act_log, al_ext);\n\tspin_unlock_irq(&device->al_lock);\n\n\treturn rv;\n}\n\n \nvoid drbd_al_shrink(struct drbd_device *device)\n{\n\tstruct lc_element *al_ext;\n\tint i;\n\n\tD_ASSERT(device, test_bit(__LC_LOCKED, &device->act_log->flags));\n\n\tfor (i = 0; i < device->act_log->nr_elements; i++) {\n\t\tal_ext = lc_element_by_index(device->act_log, i);\n\t\tif (al_ext->lc_number == LC_FREE)\n\t\t\tcontinue;\n\t\twait_event(device->al_wait, _try_lc_del(device, al_ext));\n\t}\n\n\twake_up(&device->al_wait);\n}\n\nint drbd_al_initialize(struct drbd_device *device, void *buffer)\n{\n\tstruct al_transaction_on_disk *al = buffer;\n\tstruct drbd_md *md = &device->ldev->md;\n\tint al_size_4k = md->al_stripes * md->al_stripe_size_4k;\n\tint i;\n\n\t__al_write_transaction(device, al);\n\t \n\tspin_lock_irq(&device->al_lock);\n\tlc_committed(device->act_log);\n\tspin_unlock_irq(&device->al_lock);\n\n\t \n\tfor (i = 1; i < al_size_4k; i++) {\n\t\tint err = __al_write_transaction(device, al);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic const char *drbd_change_sync_fname[] = {\n\t[RECORD_RS_FAILED] = \"drbd_rs_failed_io\",\n\t[SET_IN_SYNC] = \"drbd_set_in_sync\",\n\t[SET_OUT_OF_SYNC] = \"drbd_set_out_of_sync\"\n};\n\n \nstatic bool update_rs_extent(struct drbd_device *device,\n\t\tunsigned int enr, int count,\n\t\tenum update_sync_bits_mode mode)\n{\n\tstruct lc_element *e;\n\n\tD_ASSERT(device, atomic_read(&device->local_cnt));\n\n\t \n\tif (mode == SET_OUT_OF_SYNC)\n\t\te = lc_find(device->resync, enr);\n\telse\n\t\te = lc_get(device->resync, enr);\n\tif (e) {\n\t\tstruct bm_extent *ext = lc_entry(e, struct bm_extent, lce);\n\t\tif (ext->lce.lc_number == enr) {\n\t\t\tif (mode == SET_IN_SYNC)\n\t\t\t\text->rs_left -= count;\n\t\t\telse if (mode == SET_OUT_OF_SYNC)\n\t\t\t\text->rs_left += count;\n\t\t\telse\n\t\t\t\text->rs_failed += count;\n\t\t\tif (ext->rs_left < ext->rs_failed) {\n\t\t\t\tdrbd_warn(device, \"BAD! enr=%u rs_left=%d \"\n\t\t\t\t    \"rs_failed=%d count=%d cstate=%s\\n\",\n\t\t\t\t     ext->lce.lc_number, ext->rs_left,\n\t\t\t\t     ext->rs_failed, count,\n\t\t\t\t     drbd_conn_str(device->state.conn));\n\n\t\t\t\t \n\t\t\t\text->rs_left = drbd_bm_e_weight(device, enr);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tint rs_left = drbd_bm_e_weight(device, enr);\n\t\t\tif (ext->flags != 0) {\n\t\t\t\tdrbd_warn(device, \"changing resync lce: %d[%u;%02lx]\"\n\t\t\t\t     \" -> %d[%u;00]\\n\",\n\t\t\t\t     ext->lce.lc_number, ext->rs_left,\n\t\t\t\t     ext->flags, enr, rs_left);\n\t\t\t\text->flags = 0;\n\t\t\t}\n\t\t\tif (ext->rs_failed) {\n\t\t\t\tdrbd_warn(device, \"Kicking resync_lru element enr=%u \"\n\t\t\t\t     \"out with rs_failed=%d\\n\",\n\t\t\t\t     ext->lce.lc_number, ext->rs_failed);\n\t\t\t}\n\t\t\text->rs_left = rs_left;\n\t\t\text->rs_failed = (mode == RECORD_RS_FAILED) ? count : 0;\n\t\t\t \n\t\t\tlc_committed(device->resync);\n\t\t}\n\t\tif (mode != SET_OUT_OF_SYNC)\n\t\t\tlc_put(device->resync, &ext->lce);\n\t\t \n\n\t\tif (ext->rs_left <= ext->rs_failed) {\n\t\t\text->rs_failed = 0;\n\t\t\treturn true;\n\t\t}\n\t} else if (mode != SET_OUT_OF_SYNC) {\n\t\t \n\t\tdrbd_err(device, \"lc_get() failed! locked=%d/%d flags=%lu\\n\",\n\t\t    device->resync_locked,\n\t\t    device->resync->nr_elements,\n\t\t    device->resync->flags);\n\t}\n\treturn false;\n}\n\nvoid drbd_advance_rs_marks(struct drbd_peer_device *peer_device, unsigned long still_to_go)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned long now = jiffies;\n\tunsigned long last = device->rs_mark_time[device->rs_last_mark];\n\tint next = (device->rs_last_mark + 1) % DRBD_SYNC_MARKS;\n\tif (time_after_eq(now, last + DRBD_SYNC_MARK_STEP)) {\n\t\tif (device->rs_mark_left[device->rs_last_mark] != still_to_go &&\n\t\t    device->state.conn != C_PAUSED_SYNC_T &&\n\t\t    device->state.conn != C_PAUSED_SYNC_S) {\n\t\t\tdevice->rs_mark_time[next] = now;\n\t\t\tdevice->rs_mark_left[next] = still_to_go;\n\t\t\tdevice->rs_last_mark = next;\n\t\t}\n\t}\n}\n\n \nstatic bool lazy_bitmap_update_due(struct drbd_device *device)\n{\n\treturn time_after(jiffies, device->rs_last_bcast + 2*HZ);\n}\n\nstatic void maybe_schedule_on_disk_bitmap_update(struct drbd_device *device, bool rs_done)\n{\n\tif (rs_done) {\n\t\tstruct drbd_connection *connection = first_peer_device(device)->connection;\n\t\tif (connection->agreed_pro_version <= 95 ||\n\t\t    is_sync_target_state(device->state.conn))\n\t\t\tset_bit(RS_DONE, &device->flags);\n\t\t\t \n\n\t\t \n\t} else if (!lazy_bitmap_update_due(device))\n\t\treturn;\n\n\tdrbd_device_post_work(device, RS_PROGRESS);\n}\n\nstatic int update_sync_bits(struct drbd_device *device,\n\t\tunsigned long sbnr, unsigned long ebnr,\n\t\tenum update_sync_bits_mode mode)\n{\n\t \n\tunsigned long flags;\n\tunsigned long count = 0;\n\tunsigned int cleared = 0;\n\twhile (sbnr <= ebnr) {\n\t\t \n\t\tunsigned long tbnr = min(ebnr, sbnr | BM_BLOCKS_PER_BM_EXT_MASK);\n\t\tunsigned long c;\n\n\t\tif (mode == RECORD_RS_FAILED)\n\t\t\t \n\t\t\tc = drbd_bm_count_bits(device, sbnr, tbnr);\n\t\telse if (mode == SET_IN_SYNC)\n\t\t\tc = drbd_bm_clear_bits(device, sbnr, tbnr);\n\t\telse  \n\t\t\tc = drbd_bm_set_bits(device, sbnr, tbnr);\n\n\t\tif (c) {\n\t\t\tspin_lock_irqsave(&device->al_lock, flags);\n\t\t\tcleared += update_rs_extent(device, BM_BIT_TO_EXT(sbnr), c, mode);\n\t\t\tspin_unlock_irqrestore(&device->al_lock, flags);\n\t\t\tcount += c;\n\t\t}\n\t\tsbnr = tbnr + 1;\n\t}\n\tif (count) {\n\t\tif (mode == SET_IN_SYNC) {\n\t\t\tunsigned long still_to_go = drbd_bm_total_weight(device);\n\t\t\tbool rs_is_done = (still_to_go <= device->rs_failed);\n\t\t\tdrbd_advance_rs_marks(first_peer_device(device), still_to_go);\n\t\t\tif (cleared || rs_is_done)\n\t\t\t\tmaybe_schedule_on_disk_bitmap_update(device, rs_is_done);\n\t\t} else if (mode == RECORD_RS_FAILED)\n\t\t\tdevice->rs_failed += count;\n\t\twake_up(&device->al_wait);\n\t}\n\treturn count;\n}\n\nstatic bool plausible_request_size(int size)\n{\n\treturn size > 0\n\t\t&& size <= DRBD_MAX_BATCH_BIO_SIZE\n\t\t&& IS_ALIGNED(size, 512);\n}\n\n \nint __drbd_change_sync(struct drbd_peer_device *peer_device, sector_t sector, int size,\n\t\tenum update_sync_bits_mode mode)\n{\n\t \n\tstruct drbd_device *device = peer_device->device;\n\tunsigned long sbnr, ebnr, lbnr;\n\tunsigned long count = 0;\n\tsector_t esector, nr_sectors;\n\n\t \n\tif ((mode == SET_OUT_OF_SYNC) && size == 0)\n\t\treturn 0;\n\n\tif (!plausible_request_size(size)) {\n\t\tdrbd_err(device, \"%s: sector=%llus size=%d nonsense!\\n\",\n\t\t\t\tdrbd_change_sync_fname[mode],\n\t\t\t\t(unsigned long long)sector, size);\n\t\treturn 0;\n\t}\n\n\tif (!get_ldev(device))\n\t\treturn 0;  \n\n\tnr_sectors = get_capacity(device->vdisk);\n\tesector = sector + (size >> 9) - 1;\n\n\tif (!expect(device, sector < nr_sectors))\n\t\tgoto out;\n\tif (!expect(device, esector < nr_sectors))\n\t\tesector = nr_sectors - 1;\n\n\tlbnr = BM_SECT_TO_BIT(nr_sectors-1);\n\n\tif (mode == SET_IN_SYNC) {\n\t\t \n\t\tif (unlikely(esector < BM_SECT_PER_BIT-1))\n\t\t\tgoto out;\n\t\tif (unlikely(esector == (nr_sectors-1)))\n\t\t\tebnr = lbnr;\n\t\telse\n\t\t\tebnr = BM_SECT_TO_BIT(esector - (BM_SECT_PER_BIT-1));\n\t\tsbnr = BM_SECT_TO_BIT(sector + BM_SECT_PER_BIT-1);\n\t} else {\n\t\t \n\t\tsbnr = BM_SECT_TO_BIT(sector);\n\t\tebnr = BM_SECT_TO_BIT(esector);\n\t}\n\n\tcount = update_sync_bits(device, sbnr, ebnr, mode);\nout:\n\tput_ldev(device);\n\treturn count;\n}\n\nstatic\nstruct bm_extent *_bme_get(struct drbd_device *device, unsigned int enr)\n{\n\tstruct lc_element *e;\n\tstruct bm_extent *bm_ext;\n\tint wakeup = 0;\n\tunsigned long rs_flags;\n\n\tspin_lock_irq(&device->al_lock);\n\tif (device->resync_locked > device->resync->nr_elements/2) {\n\t\tspin_unlock_irq(&device->al_lock);\n\t\treturn NULL;\n\t}\n\te = lc_get(device->resync, enr);\n\tbm_ext = e ? lc_entry(e, struct bm_extent, lce) : NULL;\n\tif (bm_ext) {\n\t\tif (bm_ext->lce.lc_number != enr) {\n\t\t\tbm_ext->rs_left = drbd_bm_e_weight(device, enr);\n\t\t\tbm_ext->rs_failed = 0;\n\t\t\tlc_committed(device->resync);\n\t\t\twakeup = 1;\n\t\t}\n\t\tif (bm_ext->lce.refcnt == 1)\n\t\t\tdevice->resync_locked++;\n\t\tset_bit(BME_NO_WRITES, &bm_ext->flags);\n\t}\n\trs_flags = device->resync->flags;\n\tspin_unlock_irq(&device->al_lock);\n\tif (wakeup)\n\t\twake_up(&device->al_wait);\n\n\tif (!bm_ext) {\n\t\tif (rs_flags & LC_STARVING)\n\t\t\tdrbd_warn(device, \"Have to wait for element\"\n\t\t\t     \" (resync LRU too small?)\\n\");\n\t\tBUG_ON(rs_flags & LC_LOCKED);\n\t}\n\n\treturn bm_ext;\n}\n\nstatic int _is_in_al(struct drbd_device *device, unsigned int enr)\n{\n\tint rv;\n\n\tspin_lock_irq(&device->al_lock);\n\trv = lc_is_used(device->act_log, enr);\n\tspin_unlock_irq(&device->al_lock);\n\n\treturn rv;\n}\n\n \nint drbd_rs_begin_io(struct drbd_device *device, sector_t sector)\n{\n\tunsigned int enr = BM_SECT_TO_EXT(sector);\n\tstruct bm_extent *bm_ext;\n\tint i, sig;\n\tbool sa;\n\nretry:\n\tsig = wait_event_interruptible(device->al_wait,\n\t\t\t(bm_ext = _bme_get(device, enr)));\n\tif (sig)\n\t\treturn -EINTR;\n\n\tif (test_bit(BME_LOCKED, &bm_ext->flags))\n\t\treturn 0;\n\n\t \n\tsa = drbd_rs_c_min_rate_throttle(device);\n\n\tfor (i = 0; i < AL_EXT_PER_BM_SECT; i++) {\n\t\tsig = wait_event_interruptible(device->al_wait,\n\t\t\t\t\t       !_is_in_al(device, enr * AL_EXT_PER_BM_SECT + i) ||\n\t\t\t\t\t       (sa && test_bit(BME_PRIORITY, &bm_ext->flags)));\n\n\t\tif (sig || (sa && test_bit(BME_PRIORITY, &bm_ext->flags))) {\n\t\t\tspin_lock_irq(&device->al_lock);\n\t\t\tif (lc_put(device->resync, &bm_ext->lce) == 0) {\n\t\t\t\tbm_ext->flags = 0;  \n\t\t\t\tdevice->resync_locked--;\n\t\t\t\twake_up(&device->al_wait);\n\t\t\t}\n\t\t\tspin_unlock_irq(&device->al_lock);\n\t\t\tif (sig)\n\t\t\t\treturn -EINTR;\n\t\t\tif (schedule_timeout_interruptible(HZ/10))\n\t\t\t\treturn -EINTR;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tset_bit(BME_LOCKED, &bm_ext->flags);\n\treturn 0;\n}\n\n \nint drbd_try_rs_begin_io(struct drbd_peer_device *peer_device, sector_t sector)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned int enr = BM_SECT_TO_EXT(sector);\n\tconst unsigned int al_enr = enr*AL_EXT_PER_BM_SECT;\n\tstruct lc_element *e;\n\tstruct bm_extent *bm_ext;\n\tint i;\n\tbool throttle = drbd_rs_should_slow_down(peer_device, sector, true);\n\n\t \n\n\tif (throttle && device->resync_wenr != enr)\n\t\treturn -EAGAIN;\n\n\tspin_lock_irq(&device->al_lock);\n\tif (device->resync_wenr != LC_FREE && device->resync_wenr != enr) {\n\t\t \n\t\te = lc_find(device->resync, device->resync_wenr);\n\t\tbm_ext = e ? lc_entry(e, struct bm_extent, lce) : NULL;\n\t\tif (bm_ext) {\n\t\t\tD_ASSERT(device, !test_bit(BME_LOCKED, &bm_ext->flags));\n\t\t\tD_ASSERT(device, test_bit(BME_NO_WRITES, &bm_ext->flags));\n\t\t\tclear_bit(BME_NO_WRITES, &bm_ext->flags);\n\t\t\tdevice->resync_wenr = LC_FREE;\n\t\t\tif (lc_put(device->resync, &bm_ext->lce) == 0) {\n\t\t\t\tbm_ext->flags = 0;\n\t\t\t\tdevice->resync_locked--;\n\t\t\t}\n\t\t\twake_up(&device->al_wait);\n\t\t} else {\n\t\t\tdrbd_alert(device, \"LOGIC BUG\\n\");\n\t\t}\n\t}\n\t \n\te = lc_try_get(device->resync, enr);\n\tbm_ext = e ? lc_entry(e, struct bm_extent, lce) : NULL;\n\tif (bm_ext) {\n\t\tif (test_bit(BME_LOCKED, &bm_ext->flags))\n\t\t\tgoto proceed;\n\t\tif (!test_and_set_bit(BME_NO_WRITES, &bm_ext->flags)) {\n\t\t\tdevice->resync_locked++;\n\t\t} else {\n\t\t\t \n\t\t\tbm_ext->lce.refcnt--;\n\t\t\tD_ASSERT(device, bm_ext->lce.refcnt > 0);\n\t\t}\n\t\tgoto check_al;\n\t} else {\n\t\t \n\t\tif (device->resync_locked > device->resync->nr_elements-3)\n\t\t\tgoto try_again;\n\t\t \n\t\te = lc_get(device->resync, enr);\n\t\tbm_ext = e ? lc_entry(e, struct bm_extent, lce) : NULL;\n\t\tif (!bm_ext) {\n\t\t\tconst unsigned long rs_flags = device->resync->flags;\n\t\t\tif (rs_flags & LC_STARVING)\n\t\t\t\tdrbd_warn(device, \"Have to wait for element\"\n\t\t\t\t     \" (resync LRU too small?)\\n\");\n\t\t\tBUG_ON(rs_flags & LC_LOCKED);\n\t\t\tgoto try_again;\n\t\t}\n\t\tif (bm_ext->lce.lc_number != enr) {\n\t\t\tbm_ext->rs_left = drbd_bm_e_weight(device, enr);\n\t\t\tbm_ext->rs_failed = 0;\n\t\t\tlc_committed(device->resync);\n\t\t\twake_up(&device->al_wait);\n\t\t\tD_ASSERT(device, test_bit(BME_LOCKED, &bm_ext->flags) == 0);\n\t\t}\n\t\tset_bit(BME_NO_WRITES, &bm_ext->flags);\n\t\tD_ASSERT(device, bm_ext->lce.refcnt == 1);\n\t\tdevice->resync_locked++;\n\t\tgoto check_al;\n\t}\ncheck_al:\n\tfor (i = 0; i < AL_EXT_PER_BM_SECT; i++) {\n\t\tif (lc_is_used(device->act_log, al_enr+i))\n\t\t\tgoto try_again;\n\t}\n\tset_bit(BME_LOCKED, &bm_ext->flags);\nproceed:\n\tdevice->resync_wenr = LC_FREE;\n\tspin_unlock_irq(&device->al_lock);\n\treturn 0;\n\ntry_again:\n\tif (bm_ext) {\n\t\tif (throttle) {\n\t\t\tD_ASSERT(device, !test_bit(BME_LOCKED, &bm_ext->flags));\n\t\t\tD_ASSERT(device, test_bit(BME_NO_WRITES, &bm_ext->flags));\n\t\t\tclear_bit(BME_NO_WRITES, &bm_ext->flags);\n\t\t\tdevice->resync_wenr = LC_FREE;\n\t\t\tif (lc_put(device->resync, &bm_ext->lce) == 0) {\n\t\t\t\tbm_ext->flags = 0;\n\t\t\t\tdevice->resync_locked--;\n\t\t\t}\n\t\t\twake_up(&device->al_wait);\n\t\t} else\n\t\t\tdevice->resync_wenr = enr;\n\t}\n\tspin_unlock_irq(&device->al_lock);\n\treturn -EAGAIN;\n}\n\nvoid drbd_rs_complete_io(struct drbd_device *device, sector_t sector)\n{\n\tunsigned int enr = BM_SECT_TO_EXT(sector);\n\tstruct lc_element *e;\n\tstruct bm_extent *bm_ext;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device->al_lock, flags);\n\te = lc_find(device->resync, enr);\n\tbm_ext = e ? lc_entry(e, struct bm_extent, lce) : NULL;\n\tif (!bm_ext) {\n\t\tspin_unlock_irqrestore(&device->al_lock, flags);\n\t\tif (drbd_ratelimit())\n\t\t\tdrbd_err(device, \"drbd_rs_complete_io() called, but extent not found\\n\");\n\t\treturn;\n\t}\n\n\tif (bm_ext->lce.refcnt == 0) {\n\t\tspin_unlock_irqrestore(&device->al_lock, flags);\n\t\tdrbd_err(device, \"drbd_rs_complete_io(,%llu [=%u]) called, \"\n\t\t    \"but refcnt is 0!?\\n\",\n\t\t    (unsigned long long)sector, enr);\n\t\treturn;\n\t}\n\n\tif (lc_put(device->resync, &bm_ext->lce) == 0) {\n\t\tbm_ext->flags = 0;  \n\t\tdevice->resync_locked--;\n\t\twake_up(&device->al_wait);\n\t}\n\n\tspin_unlock_irqrestore(&device->al_lock, flags);\n}\n\n \nvoid drbd_rs_cancel_all(struct drbd_device *device)\n{\n\tspin_lock_irq(&device->al_lock);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {  \n\t\tlc_reset(device->resync);\n\t\tput_ldev(device);\n\t}\n\tdevice->resync_locked = 0;\n\tdevice->resync_wenr = LC_FREE;\n\tspin_unlock_irq(&device->al_lock);\n\twake_up(&device->al_wait);\n}\n\n \nint drbd_rs_del_all(struct drbd_device *device)\n{\n\tstruct lc_element *e;\n\tstruct bm_extent *bm_ext;\n\tint i;\n\n\tspin_lock_irq(&device->al_lock);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {\n\t\t \n\t\tfor (i = 0; i < device->resync->nr_elements; i++) {\n\t\t\te = lc_element_by_index(device->resync, i);\n\t\t\tbm_ext = lc_entry(e, struct bm_extent, lce);\n\t\t\tif (bm_ext->lce.lc_number == LC_FREE)\n\t\t\t\tcontinue;\n\t\t\tif (bm_ext->lce.lc_number == device->resync_wenr) {\n\t\t\t\tdrbd_info(device, \"dropping %u in drbd_rs_del_all, apparently\"\n\t\t\t\t     \" got 'synced' by application io\\n\",\n\t\t\t\t     device->resync_wenr);\n\t\t\t\tD_ASSERT(device, !test_bit(BME_LOCKED, &bm_ext->flags));\n\t\t\t\tD_ASSERT(device, test_bit(BME_NO_WRITES, &bm_ext->flags));\n\t\t\t\tclear_bit(BME_NO_WRITES, &bm_ext->flags);\n\t\t\t\tdevice->resync_wenr = LC_FREE;\n\t\t\t\tlc_put(device->resync, &bm_ext->lce);\n\t\t\t}\n\t\t\tif (bm_ext->lce.refcnt != 0) {\n\t\t\t\tdrbd_info(device, \"Retrying drbd_rs_del_all() later. \"\n\t\t\t\t     \"refcnt=%d\\n\", bm_ext->lce.refcnt);\n\t\t\t\tput_ldev(device);\n\t\t\t\tspin_unlock_irq(&device->al_lock);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tD_ASSERT(device, !test_bit(BME_LOCKED, &bm_ext->flags));\n\t\t\tD_ASSERT(device, !test_bit(BME_NO_WRITES, &bm_ext->flags));\n\t\t\tlc_del(device->resync, &bm_ext->lce);\n\t\t}\n\t\tD_ASSERT(device, device->resync->used == 0);\n\t\tput_ldev(device);\n\t}\n\tspin_unlock_irq(&device->al_lock);\n\twake_up(&device->al_wait);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}