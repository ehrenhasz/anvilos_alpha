{
  "module_name": "drbd_main.c",
  "hash_id": "f3f8e908064dbb52f2c0c4c009421e6cc5b7c4174a51dd62cefeadc5c7a036fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/drbd.h>\n#include <linux/uaccess.h>\n#include <asm/types.h>\n#include <net/sock.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/mm_inline.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/unistd.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n\n#include <linux/drbd_limits.h>\n#include \"drbd_int.h\"\n#include \"drbd_protocol.h\"\n#include \"drbd_req.h\"  \n#include \"drbd_vli.h\"\n#include \"drbd_debugfs.h\"\n\nstatic DEFINE_MUTEX(drbd_main_mutex);\nstatic int drbd_open(struct gendisk *disk, blk_mode_t mode);\nstatic void drbd_release(struct gendisk *gd);\nstatic void md_sync_timer_fn(struct timer_list *t);\nstatic int w_bitmap_io(struct drbd_work *w, int unused);\n\nMODULE_AUTHOR(\"Philipp Reisner <phil@linbit.com>, \"\n\t      \"Lars Ellenberg <lars@linbit.com>\");\nMODULE_DESCRIPTION(\"drbd - Distributed Replicated Block Device v\" REL_VERSION);\nMODULE_VERSION(REL_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_PARM_DESC(minor_count, \"Approximate number of drbd devices (\"\n\t\t __stringify(DRBD_MINOR_COUNT_MIN) \"-\" __stringify(DRBD_MINOR_COUNT_MAX) \")\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(DRBD_MAJOR);\n\n#include <linux/moduleparam.h>\n \n\n#ifdef CONFIG_DRBD_FAULT_INJECTION\nint drbd_enable_faults;\nint drbd_fault_rate;\nstatic int drbd_fault_count;\nstatic int drbd_fault_devs;\n \nmodule_param_named(enable_faults, drbd_enable_faults, int, 0664);\n \nmodule_param_named(fault_rate, drbd_fault_rate, int, 0664);\n \nmodule_param_named(fault_count, drbd_fault_count, int, 0664);\n \nmodule_param_named(fault_devs, drbd_fault_devs, int, 0644);\n#endif\n\n \nstatic bool drbd_allow_oos;  \nstatic bool drbd_disable_sendpage;\nMODULE_PARM_DESC(allow_oos, \"DONT USE!\");\nmodule_param_named(allow_oos, drbd_allow_oos, bool, 0);\nmodule_param_named(disable_sendpage, drbd_disable_sendpage, bool, 0644);\n\n \nint drbd_proc_details;  \nmodule_param_named(proc_details, drbd_proc_details, int, 0644);\n \nunsigned int drbd_minor_count = DRBD_MINOR_COUNT_DEF;\n \nchar drbd_usermode_helper[80] = \"/sbin/drbdadm\";\nmodule_param_named(minor_count, drbd_minor_count, uint, 0444);\nmodule_param_string(usermode_helper, drbd_usermode_helper, sizeof(drbd_usermode_helper), 0644);\n\n \nstruct idr drbd_devices;\nstruct list_head drbd_resources;\nstruct mutex resources_mutex;\n\nstruct kmem_cache *drbd_request_cache;\nstruct kmem_cache *drbd_ee_cache;\t \nstruct kmem_cache *drbd_bm_ext_cache;\t \nstruct kmem_cache *drbd_al_ext_cache;\t \nmempool_t drbd_request_mempool;\nmempool_t drbd_ee_mempool;\nmempool_t drbd_md_io_page_pool;\nstruct bio_set drbd_md_io_bio_set;\nstruct bio_set drbd_io_bio_set;\n\n \nstruct page *drbd_pp_pool;\nDEFINE_SPINLOCK(drbd_pp_lock);\nint          drbd_pp_vacant;\nwait_queue_head_t drbd_pp_wait;\n\nDEFINE_RATELIMIT_STATE(drbd_ratelimit_state, 5 * HZ, 5);\n\nstatic const struct block_device_operations drbd_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.submit_bio\t= drbd_submit_bio,\n\t.open\t\t= drbd_open,\n\t.release\t= drbd_release,\n};\n\n#ifdef __CHECKER__\n \nint _get_ldev_if_state(struct drbd_device *device, enum drbd_disk_state mins)\n{\n\tint io_allowed;\n\n\tatomic_inc(&device->local_cnt);\n\tio_allowed = (device->state.disk >= mins);\n\tif (!io_allowed) {\n\t\tif (atomic_dec_and_test(&device->local_cnt))\n\t\t\twake_up(&device->misc_wait);\n\t}\n\treturn io_allowed;\n}\n\n#endif\n\n \nvoid tl_release(struct drbd_connection *connection, unsigned int barrier_nr,\n\t\tunsigned int set_size)\n{\n\tstruct drbd_request *r;\n\tstruct drbd_request *req = NULL, *tmp = NULL;\n\tint expect_epoch = 0;\n\tint expect_size = 0;\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\n\t \n\tlist_for_each_entry(r, &connection->transfer_log, tl_requests) {\n\t\tconst unsigned s = r->rq_state;\n\t\tif (!req) {\n\t\t\tif (!(s & RQ_WRITE))\n\t\t\t\tcontinue;\n\t\t\tif (!(s & RQ_NET_MASK))\n\t\t\t\tcontinue;\n\t\t\tif (s & RQ_NET_DONE)\n\t\t\t\tcontinue;\n\t\t\treq = r;\n\t\t\texpect_epoch = req->epoch;\n\t\t\texpect_size ++;\n\t\t} else {\n\t\t\tif (r->epoch != expect_epoch)\n\t\t\t\tbreak;\n\t\t\tif (!(s & RQ_WRITE))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\t \n\t\t\texpect_size++;\n\t\t}\n\t}\n\n\t \n\tif (req == NULL) {\n\t\tdrbd_err(connection, \"BAD! BarrierAck #%u received, but no epoch in tl!?\\n\",\n\t\t\t barrier_nr);\n\t\tgoto bail;\n\t}\n\tif (expect_epoch != barrier_nr) {\n\t\tdrbd_err(connection, \"BAD! BarrierAck #%u received, expected #%u!\\n\",\n\t\t\t barrier_nr, expect_epoch);\n\t\tgoto bail;\n\t}\n\n\tif (expect_size != set_size) {\n\t\tdrbd_err(connection, \"BAD! BarrierAck #%u received with n_writes=%u, expected n_writes=%u!\\n\",\n\t\t\t barrier_nr, set_size, expect_size);\n\t\tgoto bail;\n\t}\n\n\t \n\t \n\tlist_for_each_entry(req, &connection->transfer_log, tl_requests)\n\t\tif (req->epoch == expect_epoch) {\n\t\t\ttmp = req;\n\t\t\tbreak;\n\t\t}\n\treq = list_prepare_entry(tmp, &connection->transfer_log, tl_requests);\n\tlist_for_each_entry_safe_from(req, r, &connection->transfer_log, tl_requests) {\n\t\tstruct drbd_peer_device *peer_device;\n\t\tif (req->epoch != expect_epoch)\n\t\t\tbreak;\n\t\tpeer_device = conn_peer_device(connection, req->device->vnr);\n\t\t_req_mod(req, BARRIER_ACKED, peer_device);\n\t}\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\treturn;\n\nbail:\n\tspin_unlock_irq(&connection->resource->req_lock);\n\tconn_request_state(connection, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\n}\n\n\n \n \nvoid _tl_restart(struct drbd_connection *connection, enum drbd_req_event what)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_request *req, *r;\n\n\tlist_for_each_entry_safe(req, r, &connection->transfer_log, tl_requests) {\n\t\tpeer_device = conn_peer_device(connection, req->device->vnr);\n\t\t_req_mod(req, what, peer_device);\n\t}\n}\n\nvoid tl_restart(struct drbd_connection *connection, enum drbd_req_event what)\n{\n\tspin_lock_irq(&connection->resource->req_lock);\n\t_tl_restart(connection, what);\n\tspin_unlock_irq(&connection->resource->req_lock);\n}\n\n \nvoid tl_clear(struct drbd_connection *connection)\n{\n\ttl_restart(connection, CONNECTION_LOST_WHILE_PENDING);\n}\n\n \nvoid tl_abort_disk_io(struct drbd_device *device)\n{\n\tstruct drbd_connection *connection = first_peer_device(device)->connection;\n\tstruct drbd_request *req, *r;\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\tlist_for_each_entry_safe(req, r, &connection->transfer_log, tl_requests) {\n\t\tif (!(req->rq_state & RQ_LOCAL_PENDING))\n\t\t\tcontinue;\n\t\tif (req->device != device)\n\t\t\tcontinue;\n\t\t_req_mod(req, ABORT_DISK_IO, NULL);\n\t}\n\tspin_unlock_irq(&connection->resource->req_lock);\n}\n\nstatic int drbd_thread_setup(void *arg)\n{\n\tstruct drbd_thread *thi = (struct drbd_thread *) arg;\n\tstruct drbd_resource *resource = thi->resource;\n\tunsigned long flags;\n\tint retval;\n\n\tsnprintf(current->comm, sizeof(current->comm), \"drbd_%c_%s\",\n\t\t thi->name[0],\n\t\t resource->name);\n\n\tallow_kernel_signal(DRBD_SIGKILL);\n\tallow_kernel_signal(SIGXCPU);\nrestart:\n\tretval = thi->function(thi);\n\n\tspin_lock_irqsave(&thi->t_lock, flags);\n\n\t \n\n\tif (thi->t_state == RESTARTING) {\n\t\tdrbd_info(resource, \"Restarting %s thread\\n\", thi->name);\n\t\tthi->t_state = RUNNING;\n\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\tgoto restart;\n\t}\n\n\tthi->task = NULL;\n\tthi->t_state = NONE;\n\tsmp_mb();\n\tcomplete_all(&thi->stop);\n\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\n\tdrbd_info(resource, \"Terminating %s\\n\", current->comm);\n\n\t \n\n\tif (thi->connection)\n\t\tkref_put(&thi->connection->kref, drbd_destroy_connection);\n\tkref_put(&resource->kref, drbd_destroy_resource);\n\tmodule_put(THIS_MODULE);\n\treturn retval;\n}\n\nstatic void drbd_thread_init(struct drbd_resource *resource, struct drbd_thread *thi,\n\t\t\t     int (*func) (struct drbd_thread *), const char *name)\n{\n\tspin_lock_init(&thi->t_lock);\n\tthi->task    = NULL;\n\tthi->t_state = NONE;\n\tthi->function = func;\n\tthi->resource = resource;\n\tthi->connection = NULL;\n\tthi->name = name;\n}\n\nint drbd_thread_start(struct drbd_thread *thi)\n{\n\tstruct drbd_resource *resource = thi->resource;\n\tstruct task_struct *nt;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&thi->t_lock, flags);\n\n\tswitch (thi->t_state) {\n\tcase NONE:\n\t\tdrbd_info(resource, \"Starting %s thread (from %s [%d])\\n\",\n\t\t\t thi->name, current->comm, current->pid);\n\n\t\t \n\t\tif (!try_module_get(THIS_MODULE)) {\n\t\t\tdrbd_err(resource, \"Failed to get module reference in drbd_thread_start\\n\");\n\t\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\t\treturn false;\n\t\t}\n\n\t\tkref_get(&resource->kref);\n\t\tif (thi->connection)\n\t\t\tkref_get(&thi->connection->kref);\n\n\t\tinit_completion(&thi->stop);\n\t\tthi->reset_cpu_mask = 1;\n\t\tthi->t_state = RUNNING;\n\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\tflush_signals(current);  \n\n\t\tnt = kthread_create(drbd_thread_setup, (void *) thi,\n\t\t\t\t    \"drbd_%c_%s\", thi->name[0], thi->resource->name);\n\n\t\tif (IS_ERR(nt)) {\n\t\t\tdrbd_err(resource, \"Couldn't start thread\\n\");\n\n\t\t\tif (thi->connection)\n\t\t\t\tkref_put(&thi->connection->kref, drbd_destroy_connection);\n\t\t\tkref_put(&resource->kref, drbd_destroy_resource);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\treturn false;\n\t\t}\n\t\tspin_lock_irqsave(&thi->t_lock, flags);\n\t\tthi->task = nt;\n\t\tthi->t_state = RUNNING;\n\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\twake_up_process(nt);\n\t\tbreak;\n\tcase EXITING:\n\t\tthi->t_state = RESTARTING;\n\t\tdrbd_info(resource, \"Restarting %s thread (from %s [%d])\\n\",\n\t\t\t\tthi->name, current->comm, current->pid);\n\t\tfallthrough;\n\tcase RUNNING:\n\tcase RESTARTING:\n\tdefault:\n\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n\nvoid _drbd_thread_stop(struct drbd_thread *thi, int restart, int wait)\n{\n\tunsigned long flags;\n\n\tenum drbd_thread_state ns = restart ? RESTARTING : EXITING;\n\n\t \n\tspin_lock_irqsave(&thi->t_lock, flags);\n\n\tif (thi->t_state == NONE) {\n\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\tif (restart)\n\t\t\tdrbd_thread_start(thi);\n\t\treturn;\n\t}\n\n\tif (thi->t_state != ns) {\n\t\tif (thi->task == NULL) {\n\t\t\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tthi->t_state = ns;\n\t\tsmp_mb();\n\t\tinit_completion(&thi->stop);\n\t\tif (thi->task != current)\n\t\t\tsend_sig(DRBD_SIGKILL, thi->task, 1);\n\t}\n\n\tspin_unlock_irqrestore(&thi->t_lock, flags);\n\n\tif (wait)\n\t\twait_for_completion(&thi->stop);\n}\n\nint conn_lowest_minor(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr = 0, minor = -1;\n\n\trcu_read_lock();\n\tpeer_device = idr_get_next(&connection->peer_devices, &vnr);\n\tif (peer_device)\n\t\tminor = device_to_minor(peer_device->device);\n\trcu_read_unlock();\n\n\treturn minor;\n}\n\n#ifdef CONFIG_SMP\n \nstatic void drbd_calc_cpu_mask(cpumask_var_t *cpu_mask)\n{\n\tunsigned int *resources_per_cpu, min_index = ~0;\n\n\tresources_per_cpu = kcalloc(nr_cpu_ids, sizeof(*resources_per_cpu),\n\t\t\t\t    GFP_KERNEL);\n\tif (resources_per_cpu) {\n\t\tstruct drbd_resource *resource;\n\t\tunsigned int cpu, min = ~0;\n\n\t\trcu_read_lock();\n\t\tfor_each_resource_rcu(resource, &drbd_resources) {\n\t\t\tfor_each_cpu(cpu, resource->cpu_mask)\n\t\t\t\tresources_per_cpu[cpu]++;\n\t\t}\n\t\trcu_read_unlock();\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (resources_per_cpu[cpu] < min) {\n\t\t\t\tmin = resources_per_cpu[cpu];\n\t\t\t\tmin_index = cpu;\n\t\t\t}\n\t\t}\n\t\tkfree(resources_per_cpu);\n\t}\n\tif (min_index == ~0) {\n\t\tcpumask_setall(*cpu_mask);\n\t\treturn;\n\t}\n\tcpumask_set_cpu(min_index, *cpu_mask);\n}\n\n \nvoid drbd_thread_current_set_cpu(struct drbd_thread *thi)\n{\n\tstruct drbd_resource *resource = thi->resource;\n\tstruct task_struct *p = current;\n\n\tif (!thi->reset_cpu_mask)\n\t\treturn;\n\tthi->reset_cpu_mask = 0;\n\tset_cpus_allowed_ptr(p, resource->cpu_mask);\n}\n#else\n#define drbd_calc_cpu_mask(A) ({})\n#endif\n\n \nunsigned int drbd_header_size(struct drbd_connection *connection)\n{\n\tif (connection->agreed_pro_version >= 100) {\n\t\tBUILD_BUG_ON(!IS_ALIGNED(sizeof(struct p_header100), 8));\n\t\treturn sizeof(struct p_header100);\n\t} else {\n\t\tBUILD_BUG_ON(sizeof(struct p_header80) !=\n\t\t\t     sizeof(struct p_header95));\n\t\tBUILD_BUG_ON(!IS_ALIGNED(sizeof(struct p_header80), 8));\n\t\treturn sizeof(struct p_header80);\n\t}\n}\n\nstatic unsigned int prepare_header80(struct p_header80 *h, enum drbd_packet cmd, int size)\n{\n\th->magic   = cpu_to_be32(DRBD_MAGIC);\n\th->command = cpu_to_be16(cmd);\n\th->length  = cpu_to_be16(size);\n\treturn sizeof(struct p_header80);\n}\n\nstatic unsigned int prepare_header95(struct p_header95 *h, enum drbd_packet cmd, int size)\n{\n\th->magic   = cpu_to_be16(DRBD_MAGIC_BIG);\n\th->command = cpu_to_be16(cmd);\n\th->length = cpu_to_be32(size);\n\treturn sizeof(struct p_header95);\n}\n\nstatic unsigned int prepare_header100(struct p_header100 *h, enum drbd_packet cmd,\n\t\t\t\t      int size, int vnr)\n{\n\th->magic = cpu_to_be32(DRBD_MAGIC_100);\n\th->volume = cpu_to_be16(vnr);\n\th->command = cpu_to_be16(cmd);\n\th->length = cpu_to_be32(size);\n\th->pad = 0;\n\treturn sizeof(struct p_header100);\n}\n\nstatic unsigned int prepare_header(struct drbd_connection *connection, int vnr,\n\t\t\t\t   void *buffer, enum drbd_packet cmd, int size)\n{\n\tif (connection->agreed_pro_version >= 100)\n\t\treturn prepare_header100(buffer, cmd, size, vnr);\n\telse if (connection->agreed_pro_version >= 95 &&\n\t\t size > DRBD_MAX_SIZE_H80_PACKET)\n\t\treturn prepare_header95(buffer, cmd, size);\n\telse\n\t\treturn prepare_header80(buffer, cmd, size);\n}\n\nstatic void *__conn_prepare_command(struct drbd_connection *connection,\n\t\t\t\t    struct drbd_socket *sock)\n{\n\tif (!sock->socket)\n\t\treturn NULL;\n\treturn sock->sbuf + drbd_header_size(connection);\n}\n\nvoid *conn_prepare_command(struct drbd_connection *connection, struct drbd_socket *sock)\n{\n\tvoid *p;\n\n\tmutex_lock(&sock->mutex);\n\tp = __conn_prepare_command(connection, sock);\n\tif (!p)\n\t\tmutex_unlock(&sock->mutex);\n\n\treturn p;\n}\n\nvoid *drbd_prepare_command(struct drbd_peer_device *peer_device, struct drbd_socket *sock)\n{\n\treturn conn_prepare_command(peer_device->connection, sock);\n}\n\nstatic int __send_command(struct drbd_connection *connection, int vnr,\n\t\t\t  struct drbd_socket *sock, enum drbd_packet cmd,\n\t\t\t  unsigned int header_size, void *data,\n\t\t\t  unsigned int size)\n{\n\tint msg_flags;\n\tint err;\n\n\t \n\tmsg_flags = data ? MSG_MORE : 0;\n\n\theader_size += prepare_header(connection, vnr, sock->sbuf, cmd,\n\t\t\t\t      header_size + size);\n\terr = drbd_send_all(connection, sock->socket, sock->sbuf, header_size,\n\t\t\t    msg_flags);\n\tif (data && !err)\n\t\terr = drbd_send_all(connection, sock->socket, data, size, 0);\n\t \n\tif (!err && (cmd == P_PING || cmd == P_PING_ACK))\n\t\ttcp_sock_set_nodelay(sock->socket->sk);\n\n\treturn err;\n}\n\nstatic int __conn_send_command(struct drbd_connection *connection, struct drbd_socket *sock,\n\t\t\t       enum drbd_packet cmd, unsigned int header_size,\n\t\t\t       void *data, unsigned int size)\n{\n\treturn __send_command(connection, 0, sock, cmd, header_size, data, size);\n}\n\nint conn_send_command(struct drbd_connection *connection, struct drbd_socket *sock,\n\t\t      enum drbd_packet cmd, unsigned int header_size,\n\t\t      void *data, unsigned int size)\n{\n\tint err;\n\n\terr = __conn_send_command(connection, sock, cmd, header_size, data, size);\n\tmutex_unlock(&sock->mutex);\n\treturn err;\n}\n\nint drbd_send_command(struct drbd_peer_device *peer_device, struct drbd_socket *sock,\n\t\t      enum drbd_packet cmd, unsigned int header_size,\n\t\t      void *data, unsigned int size)\n{\n\tint err;\n\n\terr = __send_command(peer_device->connection, peer_device->device->vnr,\n\t\t\t     sock, cmd, header_size, data, size);\n\tmutex_unlock(&sock->mutex);\n\treturn err;\n}\n\nint drbd_send_ping(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\n\tsock = &connection->meta;\n\tif (!conn_prepare_command(connection, sock))\n\t\treturn -EIO;\n\treturn conn_send_command(connection, sock, P_PING, 0, NULL, 0);\n}\n\nint drbd_send_ping_ack(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\n\tsock = &connection->meta;\n\tif (!conn_prepare_command(connection, sock))\n\t\treturn -EIO;\n\treturn conn_send_command(connection, sock, P_PING_ACK, 0, NULL, 0);\n}\n\nint drbd_send_sync_param(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_rs_param_95 *p;\n\tint size;\n\tconst int apv = peer_device->connection->agreed_pro_version;\n\tenum drbd_packet cmd;\n\tstruct net_conf *nc;\n\tstruct disk_conf *dc;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\n\tsize = apv <= 87 ? sizeof(struct p_rs_param)\n\t\t: apv == 88 ? sizeof(struct p_rs_param)\n\t\t\t+ strlen(nc->verify_alg) + 1\n\t\t: apv <= 94 ? sizeof(struct p_rs_param_89)\n\t\t:   sizeof(struct p_rs_param_95);\n\n\tcmd = apv >= 89 ? P_SYNC_PARAM89 : P_SYNC_PARAM;\n\n\t \n\tBUILD_BUG_ON(sizeof(p->algs) != 2 * SHARED_SECRET_MAX);\n\tmemset(&p->algs, 0, sizeof(p->algs));\n\n\tif (get_ldev(peer_device->device)) {\n\t\tdc = rcu_dereference(peer_device->device->ldev->disk_conf);\n\t\tp->resync_rate = cpu_to_be32(dc->resync_rate);\n\t\tp->c_plan_ahead = cpu_to_be32(dc->c_plan_ahead);\n\t\tp->c_delay_target = cpu_to_be32(dc->c_delay_target);\n\t\tp->c_fill_target = cpu_to_be32(dc->c_fill_target);\n\t\tp->c_max_rate = cpu_to_be32(dc->c_max_rate);\n\t\tput_ldev(peer_device->device);\n\t} else {\n\t\tp->resync_rate = cpu_to_be32(DRBD_RESYNC_RATE_DEF);\n\t\tp->c_plan_ahead = cpu_to_be32(DRBD_C_PLAN_AHEAD_DEF);\n\t\tp->c_delay_target = cpu_to_be32(DRBD_C_DELAY_TARGET_DEF);\n\t\tp->c_fill_target = cpu_to_be32(DRBD_C_FILL_TARGET_DEF);\n\t\tp->c_max_rate = cpu_to_be32(DRBD_C_MAX_RATE_DEF);\n\t}\n\n\tif (apv >= 88)\n\t\tstrcpy(p->verify_alg, nc->verify_alg);\n\tif (apv >= 89)\n\t\tstrcpy(p->csums_alg, nc->csums_alg);\n\trcu_read_unlock();\n\n\treturn drbd_send_command(peer_device, sock, cmd, size, NULL, 0);\n}\n\nint __drbd_send_protocol(struct drbd_connection *connection, enum drbd_packet cmd)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_protocol *p;\n\tstruct net_conf *nc;\n\tint size, cf;\n\n\tsock = &connection->data;\n\tp = __conn_prepare_command(connection, sock);\n\tif (!p)\n\t\treturn -EIO;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\n\tif (nc->tentative && connection->agreed_pro_version < 92) {\n\t\trcu_read_unlock();\n\t\tdrbd_err(connection, \"--dry-run is not supported by peer\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsize = sizeof(*p);\n\tif (connection->agreed_pro_version >= 87)\n\t\tsize += strlen(nc->integrity_alg) + 1;\n\n\tp->protocol      = cpu_to_be32(nc->wire_protocol);\n\tp->after_sb_0p   = cpu_to_be32(nc->after_sb_0p);\n\tp->after_sb_1p   = cpu_to_be32(nc->after_sb_1p);\n\tp->after_sb_2p   = cpu_to_be32(nc->after_sb_2p);\n\tp->two_primaries = cpu_to_be32(nc->two_primaries);\n\tcf = 0;\n\tif (nc->discard_my_data)\n\t\tcf |= CF_DISCARD_MY_DATA;\n\tif (nc->tentative)\n\t\tcf |= CF_DRY_RUN;\n\tp->conn_flags    = cpu_to_be32(cf);\n\n\tif (connection->agreed_pro_version >= 87)\n\t\tstrcpy(p->integrity_alg, nc->integrity_alg);\n\trcu_read_unlock();\n\n\treturn __conn_send_command(connection, sock, cmd, size, NULL, 0);\n}\n\nint drbd_send_protocol(struct drbd_connection *connection)\n{\n\tint err;\n\n\tmutex_lock(&connection->data.mutex);\n\terr = __drbd_send_protocol(connection, P_PROTOCOL);\n\tmutex_unlock(&connection->data.mutex);\n\n\treturn err;\n}\n\nstatic int _drbd_send_uuids(struct drbd_peer_device *peer_device, u64 uuid_flags)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock;\n\tstruct p_uuids *p;\n\tint i;\n\n\tif (!get_ldev_if_state(device, D_NEGOTIATING))\n\t\treturn 0;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p) {\n\t\tput_ldev(device);\n\t\treturn -EIO;\n\t}\n\tspin_lock_irq(&device->ldev->md.uuid_lock);\n\tfor (i = UI_CURRENT; i < UI_SIZE; i++)\n\t\tp->uuid[i] = cpu_to_be64(device->ldev->md.uuid[i]);\n\tspin_unlock_irq(&device->ldev->md.uuid_lock);\n\n\tdevice->comm_bm_set = drbd_bm_total_weight(device);\n\tp->uuid[UI_SIZE] = cpu_to_be64(device->comm_bm_set);\n\trcu_read_lock();\n\tuuid_flags |= rcu_dereference(peer_device->connection->net_conf)->discard_my_data ? 1 : 0;\n\trcu_read_unlock();\n\tuuid_flags |= test_bit(CRASHED_PRIMARY, &device->flags) ? 2 : 0;\n\tuuid_flags |= device->new_state_tmp.disk == D_INCONSISTENT ? 4 : 0;\n\tp->uuid[UI_FLAGS] = cpu_to_be64(uuid_flags);\n\n\tput_ldev(device);\n\treturn drbd_send_command(peer_device, sock, P_UUIDS, sizeof(*p), NULL, 0);\n}\n\nint drbd_send_uuids(struct drbd_peer_device *peer_device)\n{\n\treturn _drbd_send_uuids(peer_device, 0);\n}\n\nint drbd_send_uuids_skip_initial_sync(struct drbd_peer_device *peer_device)\n{\n\treturn _drbd_send_uuids(peer_device, 8);\n}\n\nvoid drbd_print_uuids(struct drbd_device *device, const char *text)\n{\n\tif (get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\tu64 *uuid = device->ldev->md.uuid;\n\t\tdrbd_info(device, \"%s %016llX:%016llX:%016llX:%016llX\\n\",\n\t\t     text,\n\t\t     (unsigned long long)uuid[UI_CURRENT],\n\t\t     (unsigned long long)uuid[UI_BITMAP],\n\t\t     (unsigned long long)uuid[UI_HISTORY_START],\n\t\t     (unsigned long long)uuid[UI_HISTORY_END]);\n\t\tput_ldev(device);\n\t} else {\n\t\tdrbd_info(device, \"%s effective data uuid: %016llX\\n\",\n\t\t\t\ttext,\n\t\t\t\t(unsigned long long)device->ed_uuid);\n\t}\n}\n\nvoid drbd_gen_and_send_sync_uuid(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock;\n\tstruct p_rs_uuid *p;\n\tu64 uuid;\n\n\tD_ASSERT(device, device->state.disk == D_UP_TO_DATE);\n\n\tuuid = device->ldev->md.uuid[UI_BITMAP];\n\tif (uuid && uuid != UUID_JUST_CREATED)\n\t\tuuid = uuid + UUID_NEW_BM_OFFSET;\n\telse\n\t\tget_random_bytes(&uuid, sizeof(u64));\n\tdrbd_uuid_set(device, UI_BITMAP, uuid);\n\tdrbd_print_uuids(device, \"updated sync UUID\");\n\tdrbd_md_sync(device);\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (p) {\n\t\tp->uuid = cpu_to_be64(uuid);\n\t\tdrbd_send_command(peer_device, sock, P_SYNC_UUID, sizeof(*p), NULL, 0);\n\t}\n}\n\nint drbd_send_sizes(struct drbd_peer_device *peer_device, int trigger_reply, enum dds_flags flags)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock;\n\tstruct p_sizes *p;\n\tsector_t d_size, u_size;\n\tint q_order_type;\n\tunsigned int max_bio_size;\n\tunsigned int packet_size;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\n\tpacket_size = sizeof(*p);\n\tif (peer_device->connection->agreed_features & DRBD_FF_WSAME)\n\t\tpacket_size += sizeof(p->qlim[0]);\n\n\tmemset(p, 0, packet_size);\n\tif (get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\tstruct block_device *bdev = device->ldev->backing_bdev;\n\t\tstruct request_queue *q = bdev_get_queue(bdev);\n\n\t\td_size = drbd_get_max_capacity(device->ldev);\n\t\trcu_read_lock();\n\t\tu_size = rcu_dereference(device->ldev->disk_conf)->disk_size;\n\t\trcu_read_unlock();\n\t\tq_order_type = drbd_queue_order_type(device);\n\t\tmax_bio_size = queue_max_hw_sectors(q) << 9;\n\t\tmax_bio_size = min(max_bio_size, DRBD_MAX_BIO_SIZE);\n\t\tp->qlim->physical_block_size =\n\t\t\tcpu_to_be32(bdev_physical_block_size(bdev));\n\t\tp->qlim->logical_block_size =\n\t\t\tcpu_to_be32(bdev_logical_block_size(bdev));\n\t\tp->qlim->alignment_offset =\n\t\t\tcpu_to_be32(bdev_alignment_offset(bdev));\n\t\tp->qlim->io_min = cpu_to_be32(bdev_io_min(bdev));\n\t\tp->qlim->io_opt = cpu_to_be32(bdev_io_opt(bdev));\n\t\tp->qlim->discard_enabled = !!bdev_max_discard_sectors(bdev);\n\t\tput_ldev(device);\n\t} else {\n\t\tstruct request_queue *q = device->rq_queue;\n\n\t\tp->qlim->physical_block_size =\n\t\t\tcpu_to_be32(queue_physical_block_size(q));\n\t\tp->qlim->logical_block_size =\n\t\t\tcpu_to_be32(queue_logical_block_size(q));\n\t\tp->qlim->alignment_offset = 0;\n\t\tp->qlim->io_min = cpu_to_be32(queue_io_min(q));\n\t\tp->qlim->io_opt = cpu_to_be32(queue_io_opt(q));\n\t\tp->qlim->discard_enabled = 0;\n\n\t\td_size = 0;\n\t\tu_size = 0;\n\t\tq_order_type = QUEUE_ORDERED_NONE;\n\t\tmax_bio_size = DRBD_MAX_BIO_SIZE;  \n\t}\n\n\tif (peer_device->connection->agreed_pro_version <= 94)\n\t\tmax_bio_size = min(max_bio_size, DRBD_MAX_SIZE_H80_PACKET);\n\telse if (peer_device->connection->agreed_pro_version < 100)\n\t\tmax_bio_size = min(max_bio_size, DRBD_MAX_BIO_SIZE_P95);\n\n\tp->d_size = cpu_to_be64(d_size);\n\tp->u_size = cpu_to_be64(u_size);\n\tif (trigger_reply)\n\t\tp->c_size = 0;\n\telse\n\t\tp->c_size = cpu_to_be64(get_capacity(device->vdisk));\n\tp->max_bio_size = cpu_to_be32(max_bio_size);\n\tp->queue_order_type = cpu_to_be16(q_order_type);\n\tp->dds_flags = cpu_to_be16(flags);\n\n\treturn drbd_send_command(peer_device, sock, P_SIZES, packet_size, NULL, 0);\n}\n\n \nint drbd_send_current_state(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_state *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->state = cpu_to_be32(peer_device->device->state.i);  \n\treturn drbd_send_command(peer_device, sock, P_STATE, sizeof(*p), NULL, 0);\n}\n\n \nint drbd_send_state(struct drbd_peer_device *peer_device, union drbd_state state)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_state *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->state = cpu_to_be32(state.i);  \n\treturn drbd_send_command(peer_device, sock, P_STATE, sizeof(*p), NULL, 0);\n}\n\nint drbd_send_state_req(struct drbd_peer_device *peer_device, union drbd_state mask, union drbd_state val)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_req_state *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->mask = cpu_to_be32(mask.i);\n\tp->val = cpu_to_be32(val.i);\n\treturn drbd_send_command(peer_device, sock, P_STATE_CHG_REQ, sizeof(*p), NULL, 0);\n}\n\nint conn_send_state_req(struct drbd_connection *connection, union drbd_state mask, union drbd_state val)\n{\n\tenum drbd_packet cmd;\n\tstruct drbd_socket *sock;\n\tstruct p_req_state *p;\n\n\tcmd = connection->agreed_pro_version < 100 ? P_STATE_CHG_REQ : P_CONN_ST_CHG_REQ;\n\tsock = &connection->data;\n\tp = conn_prepare_command(connection, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->mask = cpu_to_be32(mask.i);\n\tp->val = cpu_to_be32(val.i);\n\treturn conn_send_command(connection, sock, cmd, sizeof(*p), NULL, 0);\n}\n\nvoid drbd_send_sr_reply(struct drbd_peer_device *peer_device, enum drbd_state_rv retcode)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_req_state_reply *p;\n\n\tsock = &peer_device->connection->meta;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (p) {\n\t\tp->retcode = cpu_to_be32(retcode);\n\t\tdrbd_send_command(peer_device, sock, P_STATE_CHG_REPLY, sizeof(*p), NULL, 0);\n\t}\n}\n\nvoid conn_send_sr_reply(struct drbd_connection *connection, enum drbd_state_rv retcode)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_req_state_reply *p;\n\tenum drbd_packet cmd = connection->agreed_pro_version < 100 ? P_STATE_CHG_REPLY : P_CONN_ST_CHG_REPLY;\n\n\tsock = &connection->meta;\n\tp = conn_prepare_command(connection, sock);\n\tif (p) {\n\t\tp->retcode = cpu_to_be32(retcode);\n\t\tconn_send_command(connection, sock, cmd, sizeof(*p), NULL, 0);\n\t}\n}\n\nstatic void dcbp_set_code(struct p_compressed_bm *p, enum drbd_bitmap_code code)\n{\n\tBUG_ON(code & ~0xf);\n\tp->encoding = (p->encoding & ~0xf) | code;\n}\n\nstatic void dcbp_set_start(struct p_compressed_bm *p, int set)\n{\n\tp->encoding = (p->encoding & ~0x80) | (set ? 0x80 : 0);\n}\n\nstatic void dcbp_set_pad_bits(struct p_compressed_bm *p, int n)\n{\n\tBUG_ON(n & ~0x7);\n\tp->encoding = (p->encoding & (~0x7 << 4)) | (n << 4);\n}\n\nstatic int fill_bitmap_rle_bits(struct drbd_device *device,\n\t\t\t struct p_compressed_bm *p,\n\t\t\t unsigned int size,\n\t\t\t struct bm_xfer_ctx *c)\n{\n\tstruct bitstream bs;\n\tunsigned long plain_bits;\n\tunsigned long tmp;\n\tunsigned long rl;\n\tunsigned len;\n\tunsigned toggle;\n\tint bits, use_rle;\n\n\t \n\trcu_read_lock();\n\tuse_rle = rcu_dereference(first_peer_device(device)->connection->net_conf)->use_rle;\n\trcu_read_unlock();\n\tif (!use_rle || first_peer_device(device)->connection->agreed_pro_version < 90)\n\t\treturn 0;\n\n\tif (c->bit_offset >= c->bm_bits)\n\t\treturn 0;  \n\n\t \n\tbitstream_init(&bs, p->code, size, 0);\n\tmemset(p->code, 0, size);\n\t \n\tplain_bits = 0;\n\n\t \n\ttoggle = 2;\n\n\t \n\tdo {\n\t\ttmp = (toggle == 0) ? _drbd_bm_find_next_zero(device, c->bit_offset)\n\t\t\t\t    : _drbd_bm_find_next(device, c->bit_offset);\n\t\tif (tmp == -1UL)\n\t\t\ttmp = c->bm_bits;\n\t\trl = tmp - c->bit_offset;\n\n\t\tif (toggle == 2) {  \n\t\t\tif (rl == 0) {\n\t\t\t\t \n\t\t\t\tdcbp_set_start(p, 1);\n\t\t\t\t \n\t\t\t\ttoggle = !toggle;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdcbp_set_start(p, 0);\n\t\t}\n\n\t\t \n\t\tif (rl == 0) {\n\t\t\tdrbd_err(device, \"unexpected zero runlength while encoding bitmap \"\n\t\t\t    \"t:%u bo:%lu\\n\", toggle, c->bit_offset);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbits = vli_encode_bits(&bs, rl);\n\t\tif (bits == -ENOBUFS)  \n\t\t\tbreak;\n\t\tif (bits <= 0) {\n\t\t\tdrbd_err(device, \"error while encoding bitmap: %d\\n\", bits);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttoggle = !toggle;\n\t\tplain_bits += rl;\n\t\tc->bit_offset = tmp;\n\t} while (c->bit_offset < c->bm_bits);\n\n\tlen = bs.cur.b - p->code + !!bs.cur.bit;\n\n\tif (plain_bits < (len << 3)) {\n\t\t \n\t\tc->bit_offset -= plain_bits;\n\t\tbm_xfer_ctx_bit_to_word_offset(c);\n\t\tc->bit_offset = c->word_offset * BITS_PER_LONG;\n\t\treturn 0;\n\t}\n\n\t \n\tbm_xfer_ctx_bit_to_word_offset(c);\n\n\t \n\tdcbp_set_pad_bits(p, (8 - bs.cur.bit) & 0x7);\n\n\treturn len;\n}\n\n \nstatic int\nsend_bitmap_rle_or_plain(struct drbd_peer_device *peer_device, struct bm_xfer_ctx *c)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock = &peer_device->connection->data;\n\tunsigned int header_size = drbd_header_size(peer_device->connection);\n\tstruct p_compressed_bm *p = sock->sbuf + header_size;\n\tint len, err;\n\n\tlen = fill_bitmap_rle_bits(device, p,\n\t\t\tDRBD_SOCKET_BUFFER_SIZE - header_size - sizeof(*p), c);\n\tif (len < 0)\n\t\treturn -EIO;\n\n\tif (len) {\n\t\tdcbp_set_code(p, RLE_VLI_Bits);\n\t\terr = __send_command(peer_device->connection, device->vnr, sock,\n\t\t\t\t     P_COMPRESSED_BITMAP, sizeof(*p) + len,\n\t\t\t\t     NULL, 0);\n\t\tc->packets[0]++;\n\t\tc->bytes[0] += header_size + sizeof(*p) + len;\n\n\t\tif (c->bit_offset >= c->bm_bits)\n\t\t\tlen = 0;  \n\t} else {\n\t\t \n\t\tunsigned int data_size;\n\t\tunsigned long num_words;\n\t\tunsigned long *p = sock->sbuf + header_size;\n\n\t\tdata_size = DRBD_SOCKET_BUFFER_SIZE - header_size;\n\t\tnum_words = min_t(size_t, data_size / sizeof(*p),\n\t\t\t\t  c->bm_words - c->word_offset);\n\t\tlen = num_words * sizeof(*p);\n\t\tif (len)\n\t\t\tdrbd_bm_get_lel(device, c->word_offset, num_words, p);\n\t\terr = __send_command(peer_device->connection, device->vnr, sock, P_BITMAP,\n\t\t\t\t     len, NULL, 0);\n\t\tc->word_offset += num_words;\n\t\tc->bit_offset = c->word_offset * BITS_PER_LONG;\n\n\t\tc->packets[1]++;\n\t\tc->bytes[1] += header_size + len;\n\n\t\tif (c->bit_offset > c->bm_bits)\n\t\t\tc->bit_offset = c->bm_bits;\n\t}\n\tif (!err) {\n\t\tif (len == 0) {\n\t\t\tINFO_bm_xfer_stats(peer_device, \"send\", c);\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 1;\n\t}\n\treturn -EIO;\n}\n\n \nstatic int _drbd_send_bitmap(struct drbd_device *device,\n\t\t\t    struct drbd_peer_device *peer_device)\n{\n\tstruct bm_xfer_ctx c;\n\tint err;\n\n\tif (!expect(device, device->bitmap))\n\t\treturn false;\n\n\tif (get_ldev(device)) {\n\t\tif (drbd_md_test_flag(device->ldev, MDF_FULL_SYNC)) {\n\t\t\tdrbd_info(device, \"Writing the whole bitmap, MDF_FullSync was set.\\n\");\n\t\t\tdrbd_bm_set_all(device);\n\t\t\tif (drbd_bm_write(device, peer_device)) {\n\t\t\t\t \n\t\t\t\tdrbd_err(device, \"Failed to write bitmap to disk!\\n\");\n\t\t\t} else {\n\t\t\t\tdrbd_md_clear_flag(device, MDF_FULL_SYNC);\n\t\t\t\tdrbd_md_sync(device);\n\t\t\t}\n\t\t}\n\t\tput_ldev(device);\n\t}\n\n\tc = (struct bm_xfer_ctx) {\n\t\t.bm_bits = drbd_bm_bits(device),\n\t\t.bm_words = drbd_bm_words(device),\n\t};\n\n\tdo {\n\t\terr = send_bitmap_rle_or_plain(peer_device, &c);\n\t} while (err > 0);\n\n\treturn err == 0;\n}\n\nint drbd_send_bitmap(struct drbd_device *device, struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_socket *sock = &peer_device->connection->data;\n\tint err = -1;\n\n\tmutex_lock(&sock->mutex);\n\tif (sock->socket)\n\t\terr = !_drbd_send_bitmap(device, peer_device);\n\tmutex_unlock(&sock->mutex);\n\treturn err;\n}\n\nvoid drbd_send_b_ack(struct drbd_connection *connection, u32 barrier_nr, u32 set_size)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_barrier_ack *p;\n\n\tif (connection->cstate < C_WF_REPORT_PARAMS)\n\t\treturn;\n\n\tsock = &connection->meta;\n\tp = conn_prepare_command(connection, sock);\n\tif (!p)\n\t\treturn;\n\tp->barrier = barrier_nr;\n\tp->set_size = cpu_to_be32(set_size);\n\tconn_send_command(connection, sock, P_BARRIER_ACK, sizeof(*p), NULL, 0);\n}\n\n \nstatic int _drbd_send_ack(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t\t  u64 sector, u32 blksize, u64 block_id)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_ack *p;\n\n\tif (peer_device->device->state.conn < C_CONNECTED)\n\t\treturn -EIO;\n\n\tsock = &peer_device->connection->meta;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = sector;\n\tp->block_id = block_id;\n\tp->blksize = blksize;\n\tp->seq_num = cpu_to_be32(atomic_inc_return(&peer_device->device->packet_seq));\n\treturn drbd_send_command(peer_device, sock, cmd, sizeof(*p), NULL, 0);\n}\n\n \nvoid drbd_send_ack_dp(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t      struct p_data *dp, int data_size)\n{\n\tif (peer_device->connection->peer_integrity_tfm)\n\t\tdata_size -= crypto_shash_digestsize(peer_device->connection->peer_integrity_tfm);\n\t_drbd_send_ack(peer_device, cmd, dp->sector, cpu_to_be32(data_size),\n\t\t       dp->block_id);\n}\n\nvoid drbd_send_ack_rp(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t      struct p_block_req *rp)\n{\n\t_drbd_send_ack(peer_device, cmd, rp->sector, rp->blksize, rp->block_id);\n}\n\n \nint drbd_send_ack(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t  struct drbd_peer_request *peer_req)\n{\n\treturn _drbd_send_ack(peer_device, cmd,\n\t\t\t      cpu_to_be64(peer_req->i.sector),\n\t\t\t      cpu_to_be32(peer_req->i.size),\n\t\t\t      peer_req->block_id);\n}\n\n \nint drbd_send_ack_ex(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t     sector_t sector, int blksize, u64 block_id)\n{\n\treturn _drbd_send_ack(peer_device, cmd,\n\t\t\t      cpu_to_be64(sector),\n\t\t\t      cpu_to_be32(blksize),\n\t\t\t      cpu_to_be64(block_id));\n}\n\nint drbd_send_rs_deallocated(struct drbd_peer_device *peer_device,\n\t\t\t     struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_desc *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(peer_req->i.sector);\n\tp->blksize = cpu_to_be32(peer_req->i.size);\n\tp->pad = 0;\n\treturn drbd_send_command(peer_device, sock, P_RS_DEALLOCATED, sizeof(*p), NULL, 0);\n}\n\nint drbd_send_drequest(struct drbd_peer_device *peer_device, int cmd,\n\t\t       sector_t sector, int size, u64 block_id)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_req *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(sector);\n\tp->block_id = block_id;\n\tp->blksize = cpu_to_be32(size);\n\treturn drbd_send_command(peer_device, sock, cmd, sizeof(*p), NULL, 0);\n}\n\nint drbd_send_drequest_csum(struct drbd_peer_device *peer_device, sector_t sector, int size,\n\t\t\t    void *digest, int digest_size, enum drbd_packet cmd)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_req *p;\n\n\t \n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(sector);\n\tp->block_id = ID_SYNCER  ;\n\tp->blksize = cpu_to_be32(size);\n\treturn drbd_send_command(peer_device, sock, cmd, sizeof(*p), digest, digest_size);\n}\n\nint drbd_send_ov_request(struct drbd_peer_device *peer_device, sector_t sector, int size)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_req *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(sector);\n\tp->block_id = ID_SYNCER  ;\n\tp->blksize = cpu_to_be32(size);\n\treturn drbd_send_command(peer_device, sock, P_OV_REQUEST, sizeof(*p), NULL, 0);\n}\n\n \nstatic int we_should_drop_the_connection(struct drbd_connection *connection, struct socket *sock)\n{\n\tint drop_it;\n\t \n\n\tdrop_it =   connection->meta.socket == sock\n\t\t|| !connection->ack_receiver.task\n\t\t|| get_t_state(&connection->ack_receiver) != RUNNING\n\t\t|| connection->cstate < C_WF_REPORT_PARAMS;\n\n\tif (drop_it)\n\t\treturn true;\n\n\tdrop_it = !--connection->ko_count;\n\tif (!drop_it) {\n\t\tdrbd_err(connection, \"[%s/%d] sock_sendmsg time expired, ko = %u\\n\",\n\t\t\t current->comm, current->pid, connection->ko_count);\n\t\trequest_ping(connection);\n\t}\n\n\treturn drop_it;  ;\n}\n\nstatic void drbd_update_congested(struct drbd_connection *connection)\n{\n\tstruct sock *sk = connection->data.socket->sk;\n\tif (sk->sk_wmem_queued > sk->sk_sndbuf * 4 / 5)\n\t\tset_bit(NET_CONGESTED, &connection->flags);\n}\n\n \nstatic int _drbd_no_send_page(struct drbd_peer_device *peer_device, struct page *page,\n\t\t\t      int offset, size_t size, unsigned msg_flags)\n{\n\tstruct socket *socket;\n\tvoid *addr;\n\tint err;\n\n\tsocket = peer_device->connection->data.socket;\n\taddr = kmap(page) + offset;\n\terr = drbd_send_all(peer_device->connection, socket, addr, size, msg_flags);\n\tkunmap(page);\n\tif (!err)\n\t\tpeer_device->device->send_cnt += size >> 9;\n\treturn err;\n}\n\nstatic int _drbd_send_page(struct drbd_peer_device *peer_device, struct page *page,\n\t\t    int offset, size_t size, unsigned msg_flags)\n{\n\tstruct socket *socket = peer_device->connection->data.socket;\n\tstruct msghdr msg = { .msg_flags = msg_flags, };\n\tstruct bio_vec bvec;\n\tint len = size;\n\tint err = -EIO;\n\n\t \n\tif (!drbd_disable_sendpage && sendpage_ok(page))\n\t\tmsg.msg_flags |= MSG_NOSIGNAL | MSG_SPLICE_PAGES;\n\n\tdrbd_update_congested(peer_device->connection);\n\tdo {\n\t\tint sent;\n\n\t\tbvec_set_page(&bvec, page, len, offset);\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bvec, 1, len);\n\n\t\tsent = sock_sendmsg(socket, &msg);\n\t\tif (sent <= 0) {\n\t\t\tif (sent == -EAGAIN) {\n\t\t\t\tif (we_should_drop_the_connection(peer_device->connection, socket))\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdrbd_warn(peer_device->device, \"%s: size=%d len=%d sent=%d\\n\",\n\t\t\t     __func__, (int)size, len, sent);\n\t\t\tif (sent < 0)\n\t\t\t\terr = sent;\n\t\t\tbreak;\n\t\t}\n\t\tlen    -= sent;\n\t\toffset += sent;\n\t} while (len > 0  );\n\tclear_bit(NET_CONGESTED, &peer_device->connection->flags);\n\n\tif (len == 0) {\n\t\terr = 0;\n\t\tpeer_device->device->send_cnt += size >> 9;\n\t}\n\treturn err;\n}\n\nstatic int _drbd_send_bio(struct drbd_peer_device *peer_device, struct bio *bio)\n{\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\n\t \n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tint err;\n\n\t\terr = _drbd_no_send_page(peer_device, bvec.bv_page,\n\t\t\t\t\t bvec.bv_offset, bvec.bv_len,\n\t\t\t\t\t bio_iter_last(bvec, iter)\n\t\t\t\t\t ? 0 : MSG_MORE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int _drbd_send_zc_bio(struct drbd_peer_device *peer_device, struct bio *bio)\n{\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\n\t \n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tint err;\n\n\t\terr = _drbd_send_page(peer_device, bvec.bv_page,\n\t\t\t\t      bvec.bv_offset, bvec.bv_len,\n\t\t\t\t      bio_iter_last(bvec, iter) ? 0 : MSG_MORE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int _drbd_send_zc_ee(struct drbd_peer_device *peer_device,\n\t\t\t    struct drbd_peer_request *peer_req)\n{\n\tstruct page *page = peer_req->pages;\n\tunsigned len = peer_req->i.size;\n\tint err;\n\n\t \n\tpage_chain_for_each(page) {\n\t\tunsigned l = min_t(unsigned, len, PAGE_SIZE);\n\n\t\terr = _drbd_send_page(peer_device, page, 0, l,\n\t\t\t\t      page_chain_next(page) ? MSG_MORE : 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlen -= l;\n\t}\n\treturn 0;\n}\n\nstatic u32 bio_flags_to_wire(struct drbd_connection *connection,\n\t\t\t     struct bio *bio)\n{\n\tif (connection->agreed_pro_version >= 95)\n\t\treturn  (bio->bi_opf & REQ_SYNC ? DP_RW_SYNC : 0) |\n\t\t\t(bio->bi_opf & REQ_FUA ? DP_FUA : 0) |\n\t\t\t(bio->bi_opf & REQ_PREFLUSH ? DP_FLUSH : 0) |\n\t\t\t(bio_op(bio) == REQ_OP_DISCARD ? DP_DISCARD : 0) |\n\t\t\t(bio_op(bio) == REQ_OP_WRITE_ZEROES ?\n\t\t\t  ((connection->agreed_features & DRBD_FF_WZEROES) ?\n\t\t\t   (DP_ZEROES |(!(bio->bi_opf & REQ_NOUNMAP) ? DP_DISCARD : 0))\n\t\t\t   : DP_DISCARD)\n\t\t\t: 0);\n\telse\n\t\treturn bio->bi_opf & REQ_SYNC ? DP_RW_SYNC : 0;\n}\n\n \nint drbd_send_dblock(struct drbd_peer_device *peer_device, struct drbd_request *req)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock;\n\tstruct p_data *p;\n\tvoid *digest_out;\n\tunsigned int dp_flags = 0;\n\tint digest_size;\n\tint err;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tdigest_size = peer_device->connection->integrity_tfm ?\n\t\t      crypto_shash_digestsize(peer_device->connection->integrity_tfm) : 0;\n\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(req->i.sector);\n\tp->block_id = (unsigned long)req;\n\tp->seq_num = cpu_to_be32(atomic_inc_return(&device->packet_seq));\n\tdp_flags = bio_flags_to_wire(peer_device->connection, req->master_bio);\n\tif (device->state.conn >= C_SYNC_SOURCE &&\n\t    device->state.conn <= C_PAUSED_SYNC_T)\n\t\tdp_flags |= DP_MAY_SET_IN_SYNC;\n\tif (peer_device->connection->agreed_pro_version >= 100) {\n\t\tif (req->rq_state & RQ_EXP_RECEIVE_ACK)\n\t\t\tdp_flags |= DP_SEND_RECEIVE_ACK;\n\t\t \n\t\tif (req->rq_state & RQ_EXP_WRITE_ACK\n\t\t|| (dp_flags & DP_MAY_SET_IN_SYNC))\n\t\t\tdp_flags |= DP_SEND_WRITE_ACK;\n\t}\n\tp->dp_flags = cpu_to_be32(dp_flags);\n\n\tif (dp_flags & (DP_DISCARD|DP_ZEROES)) {\n\t\tenum drbd_packet cmd = (dp_flags & DP_ZEROES) ? P_ZEROES : P_TRIM;\n\t\tstruct p_trim *t = (struct p_trim*)p;\n\t\tt->size = cpu_to_be32(req->i.size);\n\t\terr = __send_command(peer_device->connection, device->vnr, sock, cmd, sizeof(*t), NULL, 0);\n\t\tgoto out;\n\t}\n\tdigest_out = p + 1;\n\n\t \n\tif (digest_size)\n\t\tdrbd_csum_bio(peer_device->connection->integrity_tfm, req->master_bio, digest_out);\n\terr = __send_command(peer_device->connection, device->vnr, sock, P_DATA,\n\t\t\t     sizeof(*p) + digest_size, NULL, req->i.size);\n\tif (!err) {\n\t\t \n\t\tif (!(req->rq_state & (RQ_EXP_RECEIVE_ACK | RQ_EXP_WRITE_ACK)) || digest_size)\n\t\t\terr = _drbd_send_bio(peer_device, req->master_bio);\n\t\telse\n\t\t\terr = _drbd_send_zc_bio(peer_device, req->master_bio);\n\n\t\t \n\t\tif (digest_size > 0 && digest_size <= 64) {\n\t\t\t \n\t\t\tunsigned char digest[64];\n\t\t\tdrbd_csum_bio(peer_device->connection->integrity_tfm, req->master_bio, digest);\n\t\t\tif (memcmp(p + 1, digest, digest_size)) {\n\t\t\t\tdrbd_warn(device,\n\t\t\t\t\t\"Digest mismatch, buffer modified by upper layers during write: %llus +%u\\n\",\n\t\t\t\t\t(unsigned long long)req->i.sector, req->i.size);\n\t\t\t}\n\t\t}  \n\t}\nout:\n\tmutex_unlock(&sock->mutex);   \n\n\treturn err;\n}\n\n \nint drbd_send_block(struct drbd_peer_device *peer_device, enum drbd_packet cmd,\n\t\t    struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_socket *sock;\n\tstruct p_data *p;\n\tint err;\n\tint digest_size;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\n\tdigest_size = peer_device->connection->integrity_tfm ?\n\t\t      crypto_shash_digestsize(peer_device->connection->integrity_tfm) : 0;\n\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(peer_req->i.sector);\n\tp->block_id = peer_req->block_id;\n\tp->seq_num = 0;   \n\tp->dp_flags = 0;\n\tif (digest_size)\n\t\tdrbd_csum_ee(peer_device->connection->integrity_tfm, peer_req, p + 1);\n\terr = __send_command(peer_device->connection, device->vnr, sock, cmd, sizeof(*p) + digest_size, NULL, peer_req->i.size);\n\tif (!err)\n\t\terr = _drbd_send_zc_ee(peer_device, peer_req);\n\tmutex_unlock(&sock->mutex);   \n\n\treturn err;\n}\n\nint drbd_send_out_of_sync(struct drbd_peer_device *peer_device, struct drbd_request *req)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_block_desc *p;\n\n\tsock = &peer_device->connection->data;\n\tp = drbd_prepare_command(peer_device, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tp->sector = cpu_to_be64(req->i.sector);\n\tp->blksize = cpu_to_be32(req->i.size);\n\treturn drbd_send_command(peer_device, sock, P_OUT_OF_SYNC, sizeof(*p), NULL, 0);\n}\n\n \n\n \nint drbd_send(struct drbd_connection *connection, struct socket *sock,\n\t      void *buf, size_t size, unsigned msg_flags)\n{\n\tstruct kvec iov = {.iov_base = buf, .iov_len = size};\n\tstruct msghdr msg = {.msg_flags = msg_flags | MSG_NOSIGNAL};\n\tint rv, sent = 0;\n\n\tif (!sock)\n\t\treturn -EBADR;\n\n\t \n\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, &iov, 1, size);\n\n\tif (sock == connection->data.socket) {\n\t\trcu_read_lock();\n\t\tconnection->ko_count = rcu_dereference(connection->net_conf)->ko_count;\n\t\trcu_read_unlock();\n\t\tdrbd_update_congested(connection);\n\t}\n\tdo {\n\t\trv = sock_sendmsg(sock, &msg);\n\t\tif (rv == -EAGAIN) {\n\t\t\tif (we_should_drop_the_connection(connection, sock))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (rv == -EINTR) {\n\t\t\tflush_signals(current);\n\t\t\trv = 0;\n\t\t}\n\t\tif (rv < 0)\n\t\t\tbreak;\n\t\tsent += rv;\n\t} while (sent < size);\n\n\tif (sock == connection->data.socket)\n\t\tclear_bit(NET_CONGESTED, &connection->flags);\n\n\tif (rv <= 0) {\n\t\tif (rv != -EAGAIN) {\n\t\t\tdrbd_err(connection, \"%s_sendmsg returned %d\\n\",\n\t\t\t\t sock == connection->meta.socket ? \"msock\" : \"sock\",\n\t\t\t\t rv);\n\t\t\tconn_request_state(connection, NS(conn, C_BROKEN_PIPE), CS_HARD);\n\t\t} else\n\t\t\tconn_request_state(connection, NS(conn, C_TIMEOUT), CS_HARD);\n\t}\n\n\treturn sent;\n}\n\n \nint drbd_send_all(struct drbd_connection *connection, struct socket *sock, void *buffer,\n\t\t  size_t size, unsigned msg_flags)\n{\n\tint err;\n\n\terr = drbd_send(connection, sock, buffer, size, msg_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (err != size)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int drbd_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct drbd_device *device = disk->private_data;\n\tunsigned long flags;\n\tint rv = 0;\n\n\tmutex_lock(&drbd_main_mutex);\n\tspin_lock_irqsave(&device->resource->req_lock, flags);\n\t \n\n\tif (device->state.role != R_PRIMARY) {\n\t\tif (mode & BLK_OPEN_WRITE)\n\t\t\trv = -EROFS;\n\t\telse if (!drbd_allow_oos)\n\t\t\trv = -EMEDIUMTYPE;\n\t}\n\n\tif (!rv)\n\t\tdevice->open_cnt++;\n\tspin_unlock_irqrestore(&device->resource->req_lock, flags);\n\tmutex_unlock(&drbd_main_mutex);\n\n\treturn rv;\n}\n\nstatic void drbd_release(struct gendisk *gd)\n{\n\tstruct drbd_device *device = gd->private_data;\n\n\tmutex_lock(&drbd_main_mutex);\n\tdevice->open_cnt--;\n\tmutex_unlock(&drbd_main_mutex);\n}\n\n \nvoid drbd_queue_unplug(struct drbd_device *device)\n{\n\tif (device->state.pdsk >= D_INCONSISTENT && device->state.conn >= C_CONNECTED) {\n\t\tD_ASSERT(device, device->state.role == R_PRIMARY);\n\t\tif (test_and_clear_bit(UNPLUG_REMOTE, &device->flags)) {\n\t\t\tdrbd_queue_work_if_unqueued(\n\t\t\t\t&first_peer_device(device)->connection->sender_work,\n\t\t\t\t&device->unplug_work);\n\t\t}\n\t}\n}\n\nstatic void drbd_set_defaults(struct drbd_device *device)\n{\n\t \n\tdevice->state = (union drbd_dev_state) {\n\t\t{ .role = R_SECONDARY,\n\t\t  .peer = R_UNKNOWN,\n\t\t  .conn = C_STANDALONE,\n\t\t  .disk = D_DISKLESS,\n\t\t  .pdsk = D_UNKNOWN,\n\t\t} };\n}\n\nvoid drbd_init_set_defaults(struct drbd_device *device)\n{\n\t \n\n\tdrbd_set_defaults(device);\n\n\tatomic_set(&device->ap_bio_cnt, 0);\n\tatomic_set(&device->ap_actlog_cnt, 0);\n\tatomic_set(&device->ap_pending_cnt, 0);\n\tatomic_set(&device->rs_pending_cnt, 0);\n\tatomic_set(&device->unacked_cnt, 0);\n\tatomic_set(&device->local_cnt, 0);\n\tatomic_set(&device->pp_in_use_by_net, 0);\n\tatomic_set(&device->rs_sect_in, 0);\n\tatomic_set(&device->rs_sect_ev, 0);\n\tatomic_set(&device->ap_in_flight, 0);\n\tatomic_set(&device->md_io.in_use, 0);\n\n\tmutex_init(&device->own_state_mutex);\n\tdevice->state_mutex = &device->own_state_mutex;\n\n\tspin_lock_init(&device->al_lock);\n\tspin_lock_init(&device->peer_seq_lock);\n\n\tINIT_LIST_HEAD(&device->active_ee);\n\tINIT_LIST_HEAD(&device->sync_ee);\n\tINIT_LIST_HEAD(&device->done_ee);\n\tINIT_LIST_HEAD(&device->read_ee);\n\tINIT_LIST_HEAD(&device->net_ee);\n\tINIT_LIST_HEAD(&device->resync_reads);\n\tINIT_LIST_HEAD(&device->resync_work.list);\n\tINIT_LIST_HEAD(&device->unplug_work.list);\n\tINIT_LIST_HEAD(&device->bm_io_work.w.list);\n\tINIT_LIST_HEAD(&device->pending_master_completion[0]);\n\tINIT_LIST_HEAD(&device->pending_master_completion[1]);\n\tINIT_LIST_HEAD(&device->pending_completion[0]);\n\tINIT_LIST_HEAD(&device->pending_completion[1]);\n\n\tdevice->resync_work.cb  = w_resync_timer;\n\tdevice->unplug_work.cb  = w_send_write_hint;\n\tdevice->bm_io_work.w.cb = w_bitmap_io;\n\n\ttimer_setup(&device->resync_timer, resync_timer_fn, 0);\n\ttimer_setup(&device->md_sync_timer, md_sync_timer_fn, 0);\n\ttimer_setup(&device->start_resync_timer, start_resync_timer_fn, 0);\n\ttimer_setup(&device->request_timer, request_timer_fn, 0);\n\n\tinit_waitqueue_head(&device->misc_wait);\n\tinit_waitqueue_head(&device->state_wait);\n\tinit_waitqueue_head(&device->ee_wait);\n\tinit_waitqueue_head(&device->al_wait);\n\tinit_waitqueue_head(&device->seq_wait);\n\n\tdevice->resync_wenr = LC_FREE;\n\tdevice->peer_max_bio_size = DRBD_MAX_BIO_SIZE_SAFE;\n\tdevice->local_max_bio_size = DRBD_MAX_BIO_SIZE_SAFE;\n}\n\nvoid drbd_set_my_capacity(struct drbd_device *device, sector_t size)\n{\n\tchar ppb[10];\n\n\tset_capacity_and_notify(device->vdisk, size);\n\n\tdrbd_info(device, \"size = %s (%llu KB)\\n\",\n\t\tppsize(ppb, size>>1), (unsigned long long)size>>1);\n}\n\nvoid drbd_device_cleanup(struct drbd_device *device)\n{\n\tint i;\n\tif (first_peer_device(device)->connection->receiver.t_state != NONE)\n\t\tdrbd_err(device, \"ASSERT FAILED: receiver t_state == %d expected 0.\\n\",\n\t\t\t\tfirst_peer_device(device)->connection->receiver.t_state);\n\n\tdevice->al_writ_cnt  =\n\tdevice->bm_writ_cnt  =\n\tdevice->read_cnt     =\n\tdevice->recv_cnt     =\n\tdevice->send_cnt     =\n\tdevice->writ_cnt     =\n\tdevice->p_size       =\n\tdevice->rs_start     =\n\tdevice->rs_total     =\n\tdevice->rs_failed    = 0;\n\tdevice->rs_last_events = 0;\n\tdevice->rs_last_sect_ev = 0;\n\tfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\n\t\tdevice->rs_mark_left[i] = 0;\n\t\tdevice->rs_mark_time[i] = 0;\n\t}\n\tD_ASSERT(device, first_peer_device(device)->connection->net_conf == NULL);\n\n\tset_capacity_and_notify(device->vdisk, 0);\n\tif (device->bitmap) {\n\t\t \n\t\tdrbd_bm_resize(device, 0, 1);\n\t\tdrbd_bm_cleanup(device);\n\t}\n\n\tdrbd_backing_dev_free(device, device->ldev);\n\tdevice->ldev = NULL;\n\n\tclear_bit(AL_SUSPENDED, &device->flags);\n\n\tD_ASSERT(device, list_empty(&device->active_ee));\n\tD_ASSERT(device, list_empty(&device->sync_ee));\n\tD_ASSERT(device, list_empty(&device->done_ee));\n\tD_ASSERT(device, list_empty(&device->read_ee));\n\tD_ASSERT(device, list_empty(&device->net_ee));\n\tD_ASSERT(device, list_empty(&device->resync_reads));\n\tD_ASSERT(device, list_empty(&first_peer_device(device)->connection->sender_work.q));\n\tD_ASSERT(device, list_empty(&device->resync_work.list));\n\tD_ASSERT(device, list_empty(&device->unplug_work.list));\n\n\tdrbd_set_defaults(device);\n}\n\n\nstatic void drbd_destroy_mempools(void)\n{\n\tstruct page *page;\n\n\twhile (drbd_pp_pool) {\n\t\tpage = drbd_pp_pool;\n\t\tdrbd_pp_pool = (struct page *)page_private(page);\n\t\t__free_page(page);\n\t\tdrbd_pp_vacant--;\n\t}\n\n\t \n\n\tbioset_exit(&drbd_io_bio_set);\n\tbioset_exit(&drbd_md_io_bio_set);\n\tmempool_exit(&drbd_md_io_page_pool);\n\tmempool_exit(&drbd_ee_mempool);\n\tmempool_exit(&drbd_request_mempool);\n\tkmem_cache_destroy(drbd_ee_cache);\n\tkmem_cache_destroy(drbd_request_cache);\n\tkmem_cache_destroy(drbd_bm_ext_cache);\n\tkmem_cache_destroy(drbd_al_ext_cache);\n\n\tdrbd_ee_cache        = NULL;\n\tdrbd_request_cache   = NULL;\n\tdrbd_bm_ext_cache    = NULL;\n\tdrbd_al_ext_cache    = NULL;\n\n\treturn;\n}\n\nstatic int drbd_create_mempools(void)\n{\n\tstruct page *page;\n\tconst int number = (DRBD_MAX_BIO_SIZE/PAGE_SIZE) * drbd_minor_count;\n\tint i, ret;\n\n\t \n\tdrbd_request_cache = kmem_cache_create(\n\t\t\"drbd_req\", sizeof(struct drbd_request), 0, 0, NULL);\n\tif (drbd_request_cache == NULL)\n\t\tgoto Enomem;\n\n\tdrbd_ee_cache = kmem_cache_create(\n\t\t\"drbd_ee\", sizeof(struct drbd_peer_request), 0, 0, NULL);\n\tif (drbd_ee_cache == NULL)\n\t\tgoto Enomem;\n\n\tdrbd_bm_ext_cache = kmem_cache_create(\n\t\t\"drbd_bm\", sizeof(struct bm_extent), 0, 0, NULL);\n\tif (drbd_bm_ext_cache == NULL)\n\t\tgoto Enomem;\n\n\tdrbd_al_ext_cache = kmem_cache_create(\n\t\t\"drbd_al\", sizeof(struct lc_element), 0, 0, NULL);\n\tif (drbd_al_ext_cache == NULL)\n\t\tgoto Enomem;\n\n\t \n\tret = bioset_init(&drbd_io_bio_set, BIO_POOL_SIZE, 0, 0);\n\tif (ret)\n\t\tgoto Enomem;\n\n\tret = bioset_init(&drbd_md_io_bio_set, DRBD_MIN_POOL_PAGES, 0,\n\t\t\t  BIOSET_NEED_BVECS);\n\tif (ret)\n\t\tgoto Enomem;\n\n\tret = mempool_init_page_pool(&drbd_md_io_page_pool, DRBD_MIN_POOL_PAGES, 0);\n\tif (ret)\n\t\tgoto Enomem;\n\n\tret = mempool_init_slab_pool(&drbd_request_mempool, number,\n\t\t\t\t     drbd_request_cache);\n\tif (ret)\n\t\tgoto Enomem;\n\n\tret = mempool_init_slab_pool(&drbd_ee_mempool, number, drbd_ee_cache);\n\tif (ret)\n\t\tgoto Enomem;\n\n\tfor (i = 0; i < number; i++) {\n\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\tif (!page)\n\t\t\tgoto Enomem;\n\t\tset_page_private(page, (unsigned long)drbd_pp_pool);\n\t\tdrbd_pp_pool = page;\n\t}\n\tdrbd_pp_vacant = number;\n\n\treturn 0;\n\nEnomem:\n\tdrbd_destroy_mempools();  \n\treturn -ENOMEM;\n}\n\nstatic void drbd_release_all_peer_reqs(struct drbd_device *device)\n{\n\tint rr;\n\n\trr = drbd_free_peer_reqs(device, &device->active_ee);\n\tif (rr)\n\t\tdrbd_err(device, \"%d EEs in active list found!\\n\", rr);\n\n\trr = drbd_free_peer_reqs(device, &device->sync_ee);\n\tif (rr)\n\t\tdrbd_err(device, \"%d EEs in sync list found!\\n\", rr);\n\n\trr = drbd_free_peer_reqs(device, &device->read_ee);\n\tif (rr)\n\t\tdrbd_err(device, \"%d EEs in read list found!\\n\", rr);\n\n\trr = drbd_free_peer_reqs(device, &device->done_ee);\n\tif (rr)\n\t\tdrbd_err(device, \"%d EEs in done list found!\\n\", rr);\n\n\trr = drbd_free_peer_reqs(device, &device->net_ee);\n\tif (rr)\n\t\tdrbd_err(device, \"%d EEs in net list found!\\n\", rr);\n}\n\n \nvoid drbd_destroy_device(struct kref *kref)\n{\n\tstruct drbd_device *device = container_of(kref, struct drbd_device, kref);\n\tstruct drbd_resource *resource = device->resource;\n\tstruct drbd_peer_device *peer_device, *tmp_peer_device;\n\n\ttimer_shutdown_sync(&device->request_timer);\n\n\t \n\tD_ASSERT(device, device->open_cnt == 0);\n\t \n\n\t \n\n\tdrbd_backing_dev_free(device, device->ldev);\n\tdevice->ldev = NULL;\n\n\tdrbd_release_all_peer_reqs(device);\n\n\tlc_destroy(device->act_log);\n\tlc_destroy(device->resync);\n\n\tkfree(device->p_uuid);\n\t \n\n\tif (device->bitmap)  \n\t\tdrbd_bm_cleanup(device);\n\t__free_page(device->md_io.page);\n\tput_disk(device->vdisk);\n\tkfree(device->rs_plan_s);\n\n\t \n\tfor_each_peer_device_safe(peer_device, tmp_peer_device, device) {\n\t\tkref_put(&peer_device->connection->kref, drbd_destroy_connection);\n\t\tkfree(peer_device);\n\t}\n\tif (device->submit.wq)\n\t\tdestroy_workqueue(device->submit.wq);\n\tkfree(device);\n\tkref_put(&resource->kref, drbd_destroy_resource);\n}\n\n \nstatic struct retry_worker {\n\tstruct workqueue_struct *wq;\n\tstruct work_struct worker;\n\n\tspinlock_t lock;\n\tstruct list_head writes;\n} retry;\n\nstatic void do_retry(struct work_struct *ws)\n{\n\tstruct retry_worker *retry = container_of(ws, struct retry_worker, worker);\n\tLIST_HEAD(writes);\n\tstruct drbd_request *req, *tmp;\n\n\tspin_lock_irq(&retry->lock);\n\tlist_splice_init(&retry->writes, &writes);\n\tspin_unlock_irq(&retry->lock);\n\n\tlist_for_each_entry_safe(req, tmp, &writes, tl_requests) {\n\t\tstruct drbd_device *device = req->device;\n\t\tstruct bio *bio = req->master_bio;\n\t\tbool expected;\n\n\t\texpected =\n\t\t\texpect(device, atomic_read(&req->completion_ref) == 0) &&\n\t\t\texpect(device, req->rq_state & RQ_POSTPONED) &&\n\t\t\texpect(device, (req->rq_state & RQ_LOCAL_PENDING) == 0 ||\n\t\t\t\t(req->rq_state & RQ_LOCAL_ABORTED) != 0);\n\n\t\tif (!expected)\n\t\t\tdrbd_err(device, \"req=%p completion_ref=%d rq_state=%x\\n\",\n\t\t\t\treq, atomic_read(&req->completion_ref),\n\t\t\t\treq->rq_state);\n\n\t\t \n\t\tkref_put(&req->kref, drbd_req_destroy);\n\n\t\t \n\n\t\t \n\t\tinc_ap_bio(device);\n\t\t__drbd_make_request(device, bio);\n\t}\n}\n\n \nvoid drbd_restart_request(struct drbd_request *req)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&retry.lock, flags);\n\tlist_move_tail(&req->tl_requests, &retry.writes);\n\tspin_unlock_irqrestore(&retry.lock, flags);\n\n\t \n\tdec_ap_bio(req->device);\n\n\tqueue_work(retry.wq, &retry.worker);\n}\n\nvoid drbd_destroy_resource(struct kref *kref)\n{\n\tstruct drbd_resource *resource =\n\t\tcontainer_of(kref, struct drbd_resource, kref);\n\n\tidr_destroy(&resource->devices);\n\tfree_cpumask_var(resource->cpu_mask);\n\tkfree(resource->name);\n\tkfree(resource);\n}\n\nvoid drbd_free_resource(struct drbd_resource *resource)\n{\n\tstruct drbd_connection *connection, *tmp;\n\n\tfor_each_connection_safe(connection, tmp, resource) {\n\t\tlist_del(&connection->connections);\n\t\tdrbd_debugfs_connection_cleanup(connection);\n\t\tkref_put(&connection->kref, drbd_destroy_connection);\n\t}\n\tdrbd_debugfs_resource_cleanup(resource);\n\tkref_put(&resource->kref, drbd_destroy_resource);\n}\n\nstatic void drbd_cleanup(void)\n{\n\tunsigned int i;\n\tstruct drbd_device *device;\n\tstruct drbd_resource *resource, *tmp;\n\n\t \n\tif (drbd_proc)\n\t\tremove_proc_entry(\"drbd\", NULL);\n\n\tif (retry.wq)\n\t\tdestroy_workqueue(retry.wq);\n\n\tdrbd_genl_unregister();\n\n\tidr_for_each_entry(&drbd_devices, device, i)\n\t\tdrbd_delete_device(device);\n\n\t \n\tfor_each_resource_safe(resource, tmp, &drbd_resources) {\n\t\tlist_del(&resource->resources);\n\t\tdrbd_free_resource(resource);\n\t}\n\n\tdrbd_debugfs_cleanup();\n\n\tdrbd_destroy_mempools();\n\tunregister_blkdev(DRBD_MAJOR, \"drbd\");\n\n\tidr_destroy(&drbd_devices);\n\n\tpr_info(\"module cleanup done.\\n\");\n}\n\nstatic void drbd_init_workqueue(struct drbd_work_queue* wq)\n{\n\tspin_lock_init(&wq->q_lock);\n\tINIT_LIST_HEAD(&wq->q);\n\tinit_waitqueue_head(&wq->q_wait);\n}\n\nstruct completion_work {\n\tstruct drbd_work w;\n\tstruct completion done;\n};\n\nstatic int w_complete(struct drbd_work *w, int cancel)\n{\n\tstruct completion_work *completion_work =\n\t\tcontainer_of(w, struct completion_work, w);\n\n\tcomplete(&completion_work->done);\n\treturn 0;\n}\n\nvoid drbd_flush_workqueue(struct drbd_work_queue *work_queue)\n{\n\tstruct completion_work completion_work;\n\n\tcompletion_work.w.cb = w_complete;\n\tinit_completion(&completion_work.done);\n\tdrbd_queue_work(work_queue, &completion_work.w);\n\twait_for_completion(&completion_work.done);\n}\n\nstruct drbd_resource *drbd_find_resource(const char *name)\n{\n\tstruct drbd_resource *resource;\n\n\tif (!name || !name[0])\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfor_each_resource_rcu(resource, &drbd_resources) {\n\t\tif (!strcmp(resource->name, name)) {\n\t\t\tkref_get(&resource->kref);\n\t\t\tgoto found;\n\t\t}\n\t}\n\tresource = NULL;\nfound:\n\trcu_read_unlock();\n\treturn resource;\n}\n\nstruct drbd_connection *conn_get_by_addrs(void *my_addr, int my_addr_len,\n\t\t\t\t     void *peer_addr, int peer_addr_len)\n{\n\tstruct drbd_resource *resource;\n\tstruct drbd_connection *connection;\n\n\trcu_read_lock();\n\tfor_each_resource_rcu(resource, &drbd_resources) {\n\t\tfor_each_connection_rcu(connection, resource) {\n\t\t\tif (connection->my_addr_len == my_addr_len &&\n\t\t\t    connection->peer_addr_len == peer_addr_len &&\n\t\t\t    !memcmp(&connection->my_addr, my_addr, my_addr_len) &&\n\t\t\t    !memcmp(&connection->peer_addr, peer_addr, peer_addr_len)) {\n\t\t\t\tkref_get(&connection->kref);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\tconnection = NULL;\nfound:\n\trcu_read_unlock();\n\treturn connection;\n}\n\nstatic int drbd_alloc_socket(struct drbd_socket *socket)\n{\n\tsocket->rbuf = (void *) __get_free_page(GFP_KERNEL);\n\tif (!socket->rbuf)\n\t\treturn -ENOMEM;\n\tsocket->sbuf = (void *) __get_free_page(GFP_KERNEL);\n\tif (!socket->sbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void drbd_free_socket(struct drbd_socket *socket)\n{\n\tfree_page((unsigned long) socket->sbuf);\n\tfree_page((unsigned long) socket->rbuf);\n}\n\nvoid conn_free_crypto(struct drbd_connection *connection)\n{\n\tdrbd_free_sock(connection);\n\n\tcrypto_free_shash(connection->csums_tfm);\n\tcrypto_free_shash(connection->verify_tfm);\n\tcrypto_free_shash(connection->cram_hmac_tfm);\n\tcrypto_free_shash(connection->integrity_tfm);\n\tcrypto_free_shash(connection->peer_integrity_tfm);\n\tkfree(connection->int_dig_in);\n\tkfree(connection->int_dig_vv);\n\n\tconnection->csums_tfm = NULL;\n\tconnection->verify_tfm = NULL;\n\tconnection->cram_hmac_tfm = NULL;\n\tconnection->integrity_tfm = NULL;\n\tconnection->peer_integrity_tfm = NULL;\n\tconnection->int_dig_in = NULL;\n\tconnection->int_dig_vv = NULL;\n}\n\nint set_resource_options(struct drbd_resource *resource, struct res_opts *res_opts)\n{\n\tstruct drbd_connection *connection;\n\tcpumask_var_t new_cpu_mask;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tif (nr_cpu_ids > 1 && res_opts->cpu_mask[0] != 0) {\n\t\terr = bitmap_parse(res_opts->cpu_mask, DRBD_CPU_MASK_SIZE,\n\t\t\t\t   cpumask_bits(new_cpu_mask), nr_cpu_ids);\n\t\tif (err == -EOVERFLOW) {\n\t\t\t \n\t\t\tcpumask_var_t tmp_cpu_mask;\n\t\t\tif (zalloc_cpumask_var(&tmp_cpu_mask, GFP_KERNEL)) {\n\t\t\t\tcpumask_setall(tmp_cpu_mask);\n\t\t\t\tcpumask_and(new_cpu_mask, new_cpu_mask, tmp_cpu_mask);\n\t\t\t\tdrbd_warn(resource, \"Overflow in bitmap_parse(%.12s%s), truncating to %u bits\\n\",\n\t\t\t\t\tres_opts->cpu_mask,\n\t\t\t\t\tstrlen(res_opts->cpu_mask) > 12 ? \"...\" : \"\",\n\t\t\t\t\tnr_cpu_ids);\n\t\t\t\tfree_cpumask_var(tmp_cpu_mask);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t}\n\t\tif (err) {\n\t\t\tdrbd_warn(resource, \"bitmap_parse() failed with %d\\n\", err);\n\t\t\t \n\t\t\tgoto fail;\n\t\t}\n\t}\n\tresource->res_opts = *res_opts;\n\tif (cpumask_empty(new_cpu_mask))\n\t\tdrbd_calc_cpu_mask(&new_cpu_mask);\n\tif (!cpumask_equal(resource->cpu_mask, new_cpu_mask)) {\n\t\tcpumask_copy(resource->cpu_mask, new_cpu_mask);\n\t\tfor_each_connection_rcu(connection, resource) {\n\t\t\tconnection->receiver.reset_cpu_mask = 1;\n\t\t\tconnection->ack_receiver.reset_cpu_mask = 1;\n\t\t\tconnection->worker.reset_cpu_mask = 1;\n\t\t}\n\t}\n\terr = 0;\n\nfail:\n\tfree_cpumask_var(new_cpu_mask);\n\treturn err;\n\n}\n\nstruct drbd_resource *drbd_create_resource(const char *name)\n{\n\tstruct drbd_resource *resource;\n\n\tresource = kzalloc(sizeof(struct drbd_resource), GFP_KERNEL);\n\tif (!resource)\n\t\tgoto fail;\n\tresource->name = kstrdup(name, GFP_KERNEL);\n\tif (!resource->name)\n\t\tgoto fail_free_resource;\n\tif (!zalloc_cpumask_var(&resource->cpu_mask, GFP_KERNEL))\n\t\tgoto fail_free_name;\n\tkref_init(&resource->kref);\n\tidr_init(&resource->devices);\n\tINIT_LIST_HEAD(&resource->connections);\n\tresource->write_ordering = WO_BDEV_FLUSH;\n\tlist_add_tail_rcu(&resource->resources, &drbd_resources);\n\tmutex_init(&resource->conf_update);\n\tmutex_init(&resource->adm_mutex);\n\tspin_lock_init(&resource->req_lock);\n\tdrbd_debugfs_resource_add(resource);\n\treturn resource;\n\nfail_free_name:\n\tkfree(resource->name);\nfail_free_resource:\n\tkfree(resource);\nfail:\n\treturn NULL;\n}\n\n \nstruct drbd_connection *conn_create(const char *name, struct res_opts *res_opts)\n{\n\tstruct drbd_resource *resource;\n\tstruct drbd_connection *connection;\n\n\tconnection = kzalloc(sizeof(struct drbd_connection), GFP_KERNEL);\n\tif (!connection)\n\t\treturn NULL;\n\n\tif (drbd_alloc_socket(&connection->data))\n\t\tgoto fail;\n\tif (drbd_alloc_socket(&connection->meta))\n\t\tgoto fail;\n\n\tconnection->current_epoch = kzalloc(sizeof(struct drbd_epoch), GFP_KERNEL);\n\tif (!connection->current_epoch)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&connection->transfer_log);\n\n\tINIT_LIST_HEAD(&connection->current_epoch->list);\n\tconnection->epochs = 1;\n\tspin_lock_init(&connection->epoch_lock);\n\n\tconnection->send.seen_any_write_yet = false;\n\tconnection->send.current_epoch_nr = 0;\n\tconnection->send.current_epoch_writes = 0;\n\n\tresource = drbd_create_resource(name);\n\tif (!resource)\n\t\tgoto fail;\n\n\tconnection->cstate = C_STANDALONE;\n\tmutex_init(&connection->cstate_mutex);\n\tinit_waitqueue_head(&connection->ping_wait);\n\tidr_init(&connection->peer_devices);\n\n\tdrbd_init_workqueue(&connection->sender_work);\n\tmutex_init(&connection->data.mutex);\n\tmutex_init(&connection->meta.mutex);\n\n\tdrbd_thread_init(resource, &connection->receiver, drbd_receiver, \"receiver\");\n\tconnection->receiver.connection = connection;\n\tdrbd_thread_init(resource, &connection->worker, drbd_worker, \"worker\");\n\tconnection->worker.connection = connection;\n\tdrbd_thread_init(resource, &connection->ack_receiver, drbd_ack_receiver, \"ack_recv\");\n\tconnection->ack_receiver.connection = connection;\n\n\tkref_init(&connection->kref);\n\n\tconnection->resource = resource;\n\n\tif (set_resource_options(resource, res_opts))\n\t\tgoto fail_resource;\n\n\tkref_get(&resource->kref);\n\tlist_add_tail_rcu(&connection->connections, &resource->connections);\n\tdrbd_debugfs_connection_add(connection);\n\treturn connection;\n\nfail_resource:\n\tlist_del(&resource->resources);\n\tdrbd_free_resource(resource);\nfail:\n\tkfree(connection->current_epoch);\n\tdrbd_free_socket(&connection->meta);\n\tdrbd_free_socket(&connection->data);\n\tkfree(connection);\n\treturn NULL;\n}\n\nvoid drbd_destroy_connection(struct kref *kref)\n{\n\tstruct drbd_connection *connection = container_of(kref, struct drbd_connection, kref);\n\tstruct drbd_resource *resource = connection->resource;\n\n\tif (atomic_read(&connection->current_epoch->epoch_size) !=  0)\n\t\tdrbd_err(connection, \"epoch_size:%d\\n\", atomic_read(&connection->current_epoch->epoch_size));\n\tkfree(connection->current_epoch);\n\n\tidr_destroy(&connection->peer_devices);\n\n\tdrbd_free_socket(&connection->meta);\n\tdrbd_free_socket(&connection->data);\n\tkfree(connection->int_dig_in);\n\tkfree(connection->int_dig_vv);\n\tkfree(connection);\n\tkref_put(&resource->kref, drbd_destroy_resource);\n}\n\nstatic int init_submitter(struct drbd_device *device)\n{\n\t \n\tdevice->submit.wq =\n\t\talloc_ordered_workqueue(\"drbd%u_submit\", WQ_MEM_RECLAIM, device->minor);\n\tif (!device->submit.wq)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&device->submit.worker, do_submit);\n\tINIT_LIST_HEAD(&device->submit.writes);\n\treturn 0;\n}\n\nenum drbd_ret_code drbd_create_device(struct drbd_config_context *adm_ctx, unsigned int minor)\n{\n\tstruct drbd_resource *resource = adm_ctx->resource;\n\tstruct drbd_connection *connection, *n;\n\tstruct drbd_device *device;\n\tstruct drbd_peer_device *peer_device, *tmp_peer_device;\n\tstruct gendisk *disk;\n\tint id;\n\tint vnr = adm_ctx->volume;\n\tenum drbd_ret_code err = ERR_NOMEM;\n\n\tdevice = minor_to_device(minor);\n\tif (device)\n\t\treturn ERR_MINOR_OR_VOLUME_EXISTS;\n\n\t \n\tdevice = kzalloc(sizeof(struct drbd_device), GFP_KERNEL);\n\tif (!device)\n\t\treturn ERR_NOMEM;\n\tkref_init(&device->kref);\n\n\tkref_get(&resource->kref);\n\tdevice->resource = resource;\n\tdevice->minor = minor;\n\tdevice->vnr = vnr;\n\n\tdrbd_init_set_defaults(device);\n\n\tdisk = blk_alloc_disk(NUMA_NO_NODE);\n\tif (!disk)\n\t\tgoto out_no_disk;\n\n\tdevice->vdisk = disk;\n\tdevice->rq_queue = disk->queue;\n\n\tset_disk_ro(disk, true);\n\n\tdisk->major = DRBD_MAJOR;\n\tdisk->first_minor = minor;\n\tdisk->minors = 1;\n\tdisk->fops = &drbd_ops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tsprintf(disk->disk_name, \"drbd%d\", minor);\n\tdisk->private_data = device;\n\n\tblk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, disk->queue);\n\tblk_queue_write_cache(disk->queue, true, true);\n\t \n\tblk_queue_max_hw_sectors(disk->queue, DRBD_MAX_BIO_SIZE_SAFE >> 8);\n\n\tdevice->md_io.page = alloc_page(GFP_KERNEL);\n\tif (!device->md_io.page)\n\t\tgoto out_no_io_page;\n\n\tif (drbd_bm_init(device))\n\t\tgoto out_no_bitmap;\n\tdevice->read_requests = RB_ROOT;\n\tdevice->write_requests = RB_ROOT;\n\n\tid = idr_alloc(&drbd_devices, device, minor, minor + 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tif (id == -ENOSPC)\n\t\t\terr = ERR_MINOR_OR_VOLUME_EXISTS;\n\t\tgoto out_no_minor_idr;\n\t}\n\tkref_get(&device->kref);\n\n\tid = idr_alloc(&resource->devices, device, vnr, vnr + 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tif (id == -ENOSPC)\n\t\t\terr = ERR_MINOR_OR_VOLUME_EXISTS;\n\t\tgoto out_idr_remove_minor;\n\t}\n\tkref_get(&device->kref);\n\n\tINIT_LIST_HEAD(&device->peer_devices);\n\tINIT_LIST_HEAD(&device->pending_bitmap_io);\n\tfor_each_connection(connection, resource) {\n\t\tpeer_device = kzalloc(sizeof(struct drbd_peer_device), GFP_KERNEL);\n\t\tif (!peer_device)\n\t\t\tgoto out_idr_remove_from_resource;\n\t\tpeer_device->connection = connection;\n\t\tpeer_device->device = device;\n\n\t\tlist_add(&peer_device->peer_devices, &device->peer_devices);\n\t\tkref_get(&device->kref);\n\n\t\tid = idr_alloc(&connection->peer_devices, peer_device, vnr, vnr + 1, GFP_KERNEL);\n\t\tif (id < 0) {\n\t\t\tif (id == -ENOSPC)\n\t\t\t\terr = ERR_INVALID_REQUEST;\n\t\t\tgoto out_idr_remove_from_resource;\n\t\t}\n\t\tkref_get(&connection->kref);\n\t\tINIT_WORK(&peer_device->send_acks_work, drbd_send_acks_wf);\n\t}\n\n\tif (init_submitter(device)) {\n\t\terr = ERR_NOMEM;\n\t\tgoto out_idr_remove_from_resource;\n\t}\n\n\terr = add_disk(disk);\n\tif (err)\n\t\tgoto out_destroy_workqueue;\n\n\t \n\tdevice->state.conn = first_connection(resource)->cstate;\n\tif (device->state.conn == C_WF_REPORT_PARAMS) {\n\t\tfor_each_peer_device(peer_device, device)\n\t\t\tdrbd_connected(peer_device);\n\t}\n\t \n\tfor_each_peer_device(peer_device, device)\n\t\tdrbd_debugfs_peer_device_add(peer_device);\n\tdrbd_debugfs_device_add(device);\n\treturn NO_ERROR;\n\nout_destroy_workqueue:\n\tdestroy_workqueue(device->submit.wq);\nout_idr_remove_from_resource:\n\tfor_each_connection_safe(connection, n, resource) {\n\t\tpeer_device = idr_remove(&connection->peer_devices, vnr);\n\t\tif (peer_device)\n\t\t\tkref_put(&connection->kref, drbd_destroy_connection);\n\t}\n\tfor_each_peer_device_safe(peer_device, tmp_peer_device, device) {\n\t\tlist_del(&peer_device->peer_devices);\n\t\tkfree(peer_device);\n\t}\n\tidr_remove(&resource->devices, vnr);\nout_idr_remove_minor:\n\tidr_remove(&drbd_devices, minor);\n\tsynchronize_rcu();\nout_no_minor_idr:\n\tdrbd_bm_cleanup(device);\nout_no_bitmap:\n\t__free_page(device->md_io.page);\nout_no_io_page:\n\tput_disk(disk);\nout_no_disk:\n\tkref_put(&resource->kref, drbd_destroy_resource);\n\tkfree(device);\n\treturn err;\n}\n\nvoid drbd_delete_device(struct drbd_device *device)\n{\n\tstruct drbd_resource *resource = device->resource;\n\tstruct drbd_connection *connection;\n\tstruct drbd_peer_device *peer_device;\n\n\t \n\tfor_each_peer_device(peer_device, device)\n\t\tdrbd_debugfs_peer_device_cleanup(peer_device);\n\tdrbd_debugfs_device_cleanup(device);\n\tfor_each_connection(connection, resource) {\n\t\tidr_remove(&connection->peer_devices, device->vnr);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t}\n\tidr_remove(&resource->devices, device->vnr);\n\tkref_put(&device->kref, drbd_destroy_device);\n\tidr_remove(&drbd_devices, device_to_minor(device));\n\tkref_put(&device->kref, drbd_destroy_device);\n\tdel_gendisk(device->vdisk);\n\tsynchronize_rcu();\n\tkref_put(&device->kref, drbd_destroy_device);\n}\n\nstatic int __init drbd_init(void)\n{\n\tint err;\n\n\tif (drbd_minor_count < DRBD_MINOR_COUNT_MIN || drbd_minor_count > DRBD_MINOR_COUNT_MAX) {\n\t\tpr_err(\"invalid minor_count (%d)\\n\", drbd_minor_count);\n#ifdef MODULE\n\t\treturn -EINVAL;\n#else\n\t\tdrbd_minor_count = DRBD_MINOR_COUNT_DEF;\n#endif\n\t}\n\n\terr = register_blkdev(DRBD_MAJOR, \"drbd\");\n\tif (err) {\n\t\tpr_err(\"unable to register block device major %d\\n\",\n\t\t       DRBD_MAJOR);\n\t\treturn err;\n\t}\n\n\t \n\tinit_waitqueue_head(&drbd_pp_wait);\n\n\tdrbd_proc = NULL;  \n\tidr_init(&drbd_devices);\n\n\tmutex_init(&resources_mutex);\n\tINIT_LIST_HEAD(&drbd_resources);\n\n\terr = drbd_genl_register();\n\tif (err) {\n\t\tpr_err(\"unable to register generic netlink family\\n\");\n\t\tgoto fail;\n\t}\n\n\terr = drbd_create_mempools();\n\tif (err)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tdrbd_proc = proc_create_single(\"drbd\", S_IFREG | 0444 , NULL, drbd_seq_show);\n\tif (!drbd_proc)\t{\n\t\tpr_err(\"unable to register proc file\\n\");\n\t\tgoto fail;\n\t}\n\n\tretry.wq = create_singlethread_workqueue(\"drbd-reissue\");\n\tif (!retry.wq) {\n\t\tpr_err(\"unable to create retry workqueue\\n\");\n\t\tgoto fail;\n\t}\n\tINIT_WORK(&retry.worker, do_retry);\n\tspin_lock_init(&retry.lock);\n\tINIT_LIST_HEAD(&retry.writes);\n\n\tdrbd_debugfs_init();\n\n\tpr_info(\"initialized. \"\n\t       \"Version: \" REL_VERSION \" (api:%d/proto:%d-%d)\\n\",\n\t       GENL_MAGIC_VERSION, PRO_VERSION_MIN, PRO_VERSION_MAX);\n\tpr_info(\"%s\\n\", drbd_buildtag());\n\tpr_info(\"registered as block device major %d\\n\", DRBD_MAJOR);\n\treturn 0;  \n\nfail:\n\tdrbd_cleanup();\n\tif (err == -ENOMEM)\n\t\tpr_err(\"ran out of memory\\n\");\n\telse\n\t\tpr_err(\"initialization failure\\n\");\n\treturn err;\n}\n\nstatic void drbd_free_one_sock(struct drbd_socket *ds)\n{\n\tstruct socket *s;\n\tmutex_lock(&ds->mutex);\n\ts = ds->socket;\n\tds->socket = NULL;\n\tmutex_unlock(&ds->mutex);\n\tif (s) {\n\t\t \n\t\tsynchronize_rcu();\n\t\tkernel_sock_shutdown(s, SHUT_RDWR);\n\t\tsock_release(s);\n\t}\n}\n\nvoid drbd_free_sock(struct drbd_connection *connection)\n{\n\tif (connection->data.socket)\n\t\tdrbd_free_one_sock(&connection->data);\n\tif (connection->meta.socket)\n\t\tdrbd_free_one_sock(&connection->meta);\n}\n\n \n\nvoid conn_md_sync(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_md_sync(device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\n \nstruct meta_data_on_disk {\n\tu64 la_size_sect;       \n\tu64 uuid[UI_SIZE];    \n\tu64 device_uuid;\n\tu64 reserved_u64_1;\n\tu32 flags;              \n\tu32 magic;\n\tu32 md_size_sect;\n\tu32 al_offset;          \n\tu32 al_nr_extents;      \n\t       \n\tu32 bm_offset;          \n\tu32 bm_bytes_per_bit;   \n\tu32 la_peer_max_bio_size;    \n\n\t \n\tu32 al_stripes;\n\tu32 al_stripe_size_4k;\n\n\tu8 reserved_u8[4096 - (7*8 + 10*4)];\n} __packed;\n\n\n\nvoid drbd_md_write(struct drbd_device *device, void *b)\n{\n\tstruct meta_data_on_disk *buffer = b;\n\tsector_t sector;\n\tint i;\n\n\tmemset(buffer, 0, sizeof(*buffer));\n\n\tbuffer->la_size_sect = cpu_to_be64(get_capacity(device->vdisk));\n\tfor (i = UI_CURRENT; i < UI_SIZE; i++)\n\t\tbuffer->uuid[i] = cpu_to_be64(device->ldev->md.uuid[i]);\n\tbuffer->flags = cpu_to_be32(device->ldev->md.flags);\n\tbuffer->magic = cpu_to_be32(DRBD_MD_MAGIC_84_UNCLEAN);\n\n\tbuffer->md_size_sect  = cpu_to_be32(device->ldev->md.md_size_sect);\n\tbuffer->al_offset     = cpu_to_be32(device->ldev->md.al_offset);\n\tbuffer->al_nr_extents = cpu_to_be32(device->act_log->nr_elements);\n\tbuffer->bm_bytes_per_bit = cpu_to_be32(BM_BLOCK_SIZE);\n\tbuffer->device_uuid = cpu_to_be64(device->ldev->md.device_uuid);\n\n\tbuffer->bm_offset = cpu_to_be32(device->ldev->md.bm_offset);\n\tbuffer->la_peer_max_bio_size = cpu_to_be32(device->peer_max_bio_size);\n\n\tbuffer->al_stripes = cpu_to_be32(device->ldev->md.al_stripes);\n\tbuffer->al_stripe_size_4k = cpu_to_be32(device->ldev->md.al_stripe_size_4k);\n\n\tD_ASSERT(device, drbd_md_ss(device->ldev) == device->ldev->md.md_offset);\n\tsector = device->ldev->md.md_offset;\n\n\tif (drbd_md_sync_page_io(device, device->ldev, sector, REQ_OP_WRITE)) {\n\t\t \n\t\tdrbd_err(device, \"meta data update failed!\\n\");\n\t\tdrbd_chk_io_error(device, 1, DRBD_META_IO_ERROR);\n\t}\n}\n\n \nvoid drbd_md_sync(struct drbd_device *device)\n{\n\tstruct meta_data_on_disk *buffer;\n\n\t \n\tBUILD_BUG_ON(UI_SIZE != 4);\n\tBUILD_BUG_ON(sizeof(struct meta_data_on_disk) != 4096);\n\n\tdel_timer(&device->md_sync_timer);\n\t \n\tif (!test_and_clear_bit(MD_DIRTY, &device->flags))\n\t\treturn;\n\n\t \n\tif (!get_ldev_if_state(device, D_FAILED))\n\t\treturn;\n\n\tbuffer = drbd_md_get_buffer(device, __func__);\n\tif (!buffer)\n\t\tgoto out;\n\n\tdrbd_md_write(device, buffer);\n\n\t \n\tdevice->ldev->md.la_size_sect = get_capacity(device->vdisk);\n\n\tdrbd_md_put_buffer(device);\nout:\n\tput_ldev(device);\n}\n\nstatic int check_activity_log_stripe_size(struct drbd_device *device,\n\t\tstruct meta_data_on_disk *on_disk,\n\t\tstruct drbd_md *in_core)\n{\n\tu32 al_stripes = be32_to_cpu(on_disk->al_stripes);\n\tu32 al_stripe_size_4k = be32_to_cpu(on_disk->al_stripe_size_4k);\n\tu64 al_size_4k;\n\n\t \n\tif (al_stripes == 0 && al_stripe_size_4k == 0) {\n\t\tal_stripes = 1;\n\t\tal_stripe_size_4k = MD_32kB_SECT/8;\n\t}\n\n\t \n\n\t \n\tif (al_stripes == 0 || al_stripe_size_4k == 0)\n\t\tgoto err;\n\n\tal_size_4k = (u64)al_stripes * al_stripe_size_4k;\n\n\t \n\tif (al_size_4k > (16 * 1024 * 1024/4))\n\t\tgoto err;\n\n\t \n\tif (al_size_4k < MD_32kB_SECT/8)\n\t\tgoto err;\n\n\tin_core->al_stripe_size_4k = al_stripe_size_4k;\n\tin_core->al_stripes = al_stripes;\n\tin_core->al_size_4k = al_size_4k;\n\n\treturn 0;\nerr:\n\tdrbd_err(device, \"invalid activity log striping: al_stripes=%u, al_stripe_size_4k=%u\\n\",\n\t\t\tal_stripes, al_stripe_size_4k);\n\treturn -EINVAL;\n}\n\nstatic int check_offsets_and_sizes(struct drbd_device *device, struct drbd_backing_dev *bdev)\n{\n\tsector_t capacity = drbd_get_capacity(bdev->md_bdev);\n\tstruct drbd_md *in_core = &bdev->md;\n\ts32 on_disk_al_sect;\n\ts32 on_disk_bm_sect;\n\n\t \n\tif (in_core->al_offset < 0) {\n\t\tif (in_core->bm_offset > in_core->al_offset)\n\t\t\tgoto err;\n\t\ton_disk_al_sect = -in_core->al_offset;\n\t\ton_disk_bm_sect = in_core->al_offset - in_core->bm_offset;\n\t} else {\n\t\tif (in_core->al_offset != MD_4kB_SECT)\n\t\t\tgoto err;\n\t\tif (in_core->bm_offset < in_core->al_offset + in_core->al_size_4k * MD_4kB_SECT)\n\t\t\tgoto err;\n\n\t\ton_disk_al_sect = in_core->bm_offset - MD_4kB_SECT;\n\t\ton_disk_bm_sect = in_core->md_size_sect - in_core->bm_offset;\n\t}\n\n\t \n\tif (in_core->meta_dev_idx >= 0) {\n\t\tif (in_core->md_size_sect != MD_128MB_SECT\n\t\t||  in_core->al_offset != MD_4kB_SECT\n\t\t||  in_core->bm_offset != MD_4kB_SECT + MD_32kB_SECT\n\t\t||  in_core->al_stripes != 1\n\t\t||  in_core->al_stripe_size_4k != MD_32kB_SECT/8)\n\t\t\tgoto err;\n\t}\n\n\tif (capacity < in_core->md_size_sect)\n\t\tgoto err;\n\tif (capacity - in_core->md_size_sect < drbd_md_first_sector(bdev))\n\t\tgoto err;\n\n\t \n\tif ((on_disk_al_sect & 7) || (on_disk_al_sect < MD_32kB_SECT))\n\t\tgoto err;\n\n\t \n\tif (on_disk_al_sect != in_core->al_size_4k * MD_4kB_SECT)\n\t\tgoto err;\n\n\t \n\tif (in_core->bm_offset & 7)\n\t\tgoto err;\n\n\t \n\n\t \n\tif (on_disk_bm_sect < (in_core->la_size_sect+7)/MD_4kB_SECT/8/512)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdrbd_err(device, \"meta data offsets don't make sense: idx=%d \"\n\t\t\t\"al_s=%u, al_sz4k=%u, al_offset=%d, bm_offset=%d, \"\n\t\t\t\"md_size_sect=%u, la_size=%llu, md_capacity=%llu\\n\",\n\t\t\tin_core->meta_dev_idx,\n\t\t\tin_core->al_stripes, in_core->al_stripe_size_4k,\n\t\t\tin_core->al_offset, in_core->bm_offset, in_core->md_size_sect,\n\t\t\t(unsigned long long)in_core->la_size_sect,\n\t\t\t(unsigned long long)capacity);\n\n\treturn -EINVAL;\n}\n\n\n \nint drbd_md_read(struct drbd_device *device, struct drbd_backing_dev *bdev)\n{\n\tstruct meta_data_on_disk *buffer;\n\tu32 magic, flags;\n\tint i, rv = NO_ERROR;\n\n\tif (device->state.disk != D_DISKLESS)\n\t\treturn ERR_DISK_CONFIGURED;\n\n\tbuffer = drbd_md_get_buffer(device, __func__);\n\tif (!buffer)\n\t\treturn ERR_NOMEM;\n\n\t \n\tbdev->md.meta_dev_idx = bdev->disk_conf->meta_dev_idx;\n\tbdev->md.md_offset = drbd_md_ss(bdev);\n\t \n\tbdev->md.md_size_sect = 8;\n\n\tif (drbd_md_sync_page_io(device, bdev, bdev->md.md_offset,\n\t\t\t\t REQ_OP_READ)) {\n\t\t \n\t\tdrbd_err(device, \"Error while reading metadata.\\n\");\n\t\trv = ERR_IO_MD_DISK;\n\t\tgoto err;\n\t}\n\n\tmagic = be32_to_cpu(buffer->magic);\n\tflags = be32_to_cpu(buffer->flags);\n\tif (magic == DRBD_MD_MAGIC_84_UNCLEAN ||\n\t    (magic == DRBD_MD_MAGIC_08 && !(flags & MDF_AL_CLEAN))) {\n\t\t\t \n\t\tdrbd_err(device, \"Found unclean meta data. Did you \\\"drbdadm apply-al\\\"?\\n\");\n\t\trv = ERR_MD_UNCLEAN;\n\t\tgoto err;\n\t}\n\n\trv = ERR_MD_INVALID;\n\tif (magic != DRBD_MD_MAGIC_08) {\n\t\tif (magic == DRBD_MD_MAGIC_07)\n\t\t\tdrbd_err(device, \"Found old (0.7) meta data magic. Did you \\\"drbdadm create-md\\\"?\\n\");\n\t\telse\n\t\t\tdrbd_err(device, \"Meta data magic not found. Did you \\\"drbdadm create-md\\\"?\\n\");\n\t\tgoto err;\n\t}\n\n\tif (be32_to_cpu(buffer->bm_bytes_per_bit) != BM_BLOCK_SIZE) {\n\t\tdrbd_err(device, \"unexpected bm_bytes_per_bit: %u (expected %u)\\n\",\n\t\t    be32_to_cpu(buffer->bm_bytes_per_bit), BM_BLOCK_SIZE);\n\t\tgoto err;\n\t}\n\n\n\t \n\tbdev->md.la_size_sect = be64_to_cpu(buffer->la_size_sect);\n\tfor (i = UI_CURRENT; i < UI_SIZE; i++)\n\t\tbdev->md.uuid[i] = be64_to_cpu(buffer->uuid[i]);\n\tbdev->md.flags = be32_to_cpu(buffer->flags);\n\tbdev->md.device_uuid = be64_to_cpu(buffer->device_uuid);\n\n\tbdev->md.md_size_sect = be32_to_cpu(buffer->md_size_sect);\n\tbdev->md.al_offset = be32_to_cpu(buffer->al_offset);\n\tbdev->md.bm_offset = be32_to_cpu(buffer->bm_offset);\n\n\tif (check_activity_log_stripe_size(device, buffer, &bdev->md))\n\t\tgoto err;\n\tif (check_offsets_and_sizes(device, bdev))\n\t\tgoto err;\n\n\tif (be32_to_cpu(buffer->bm_offset) != bdev->md.bm_offset) {\n\t\tdrbd_err(device, \"unexpected bm_offset: %d (expected %d)\\n\",\n\t\t    be32_to_cpu(buffer->bm_offset), bdev->md.bm_offset);\n\t\tgoto err;\n\t}\n\tif (be32_to_cpu(buffer->md_size_sect) != bdev->md.md_size_sect) {\n\t\tdrbd_err(device, \"unexpected md_size: %u (expected %u)\\n\",\n\t\t    be32_to_cpu(buffer->md_size_sect), bdev->md.md_size_sect);\n\t\tgoto err;\n\t}\n\n\trv = NO_ERROR;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tif (device->state.conn < C_CONNECTED) {\n\t\tunsigned int peer;\n\t\tpeer = be32_to_cpu(buffer->la_peer_max_bio_size);\n\t\tpeer = max(peer, DRBD_MAX_BIO_SIZE_SAFE);\n\t\tdevice->peer_max_bio_size = peer;\n\t}\n\tspin_unlock_irq(&device->resource->req_lock);\n\n err:\n\tdrbd_md_put_buffer(device);\n\n\treturn rv;\n}\n\n \nvoid drbd_md_mark_dirty(struct drbd_device *device)\n{\n\tif (!test_and_set_bit(MD_DIRTY, &device->flags))\n\t\tmod_timer(&device->md_sync_timer, jiffies + 5*HZ);\n}\n\nvoid drbd_uuid_move_history(struct drbd_device *device) __must_hold(local)\n{\n\tint i;\n\n\tfor (i = UI_HISTORY_START; i < UI_HISTORY_END; i++)\n\t\tdevice->ldev->md.uuid[i+1] = device->ldev->md.uuid[i];\n}\n\nvoid __drbd_uuid_set(struct drbd_device *device, int idx, u64 val) __must_hold(local)\n{\n\tif (idx == UI_CURRENT) {\n\t\tif (device->state.role == R_PRIMARY)\n\t\t\tval |= 1;\n\t\telse\n\t\t\tval &= ~((u64)1);\n\n\t\tdrbd_set_ed_uuid(device, val);\n\t}\n\n\tdevice->ldev->md.uuid[idx] = val;\n\tdrbd_md_mark_dirty(device);\n}\n\nvoid _drbd_uuid_set(struct drbd_device *device, int idx, u64 val) __must_hold(local)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&device->ldev->md.uuid_lock, flags);\n\t__drbd_uuid_set(device, idx, val);\n\tspin_unlock_irqrestore(&device->ldev->md.uuid_lock, flags);\n}\n\nvoid drbd_uuid_set(struct drbd_device *device, int idx, u64 val) __must_hold(local)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&device->ldev->md.uuid_lock, flags);\n\tif (device->ldev->md.uuid[idx]) {\n\t\tdrbd_uuid_move_history(device);\n\t\tdevice->ldev->md.uuid[UI_HISTORY_START] = device->ldev->md.uuid[idx];\n\t}\n\t__drbd_uuid_set(device, idx, val);\n\tspin_unlock_irqrestore(&device->ldev->md.uuid_lock, flags);\n}\n\n \nvoid drbd_uuid_new_current(struct drbd_device *device) __must_hold(local)\n{\n\tu64 val;\n\tunsigned long long bm_uuid;\n\n\tget_random_bytes(&val, sizeof(u64));\n\n\tspin_lock_irq(&device->ldev->md.uuid_lock);\n\tbm_uuid = device->ldev->md.uuid[UI_BITMAP];\n\n\tif (bm_uuid)\n\t\tdrbd_warn(device, \"bm UUID was already set: %llX\\n\", bm_uuid);\n\n\tdevice->ldev->md.uuid[UI_BITMAP] = device->ldev->md.uuid[UI_CURRENT];\n\t__drbd_uuid_set(device, UI_CURRENT, val);\n\tspin_unlock_irq(&device->ldev->md.uuid_lock);\n\n\tdrbd_print_uuids(device, \"new current UUID\");\n\t \n\tdrbd_md_sync(device);\n}\n\nvoid drbd_uuid_set_bm(struct drbd_device *device, u64 val) __must_hold(local)\n{\n\tunsigned long flags;\n\tif (device->ldev->md.uuid[UI_BITMAP] == 0 && val == 0)\n\t\treturn;\n\n\tspin_lock_irqsave(&device->ldev->md.uuid_lock, flags);\n\tif (val == 0) {\n\t\tdrbd_uuid_move_history(device);\n\t\tdevice->ldev->md.uuid[UI_HISTORY_START] = device->ldev->md.uuid[UI_BITMAP];\n\t\tdevice->ldev->md.uuid[UI_BITMAP] = 0;\n\t} else {\n\t\tunsigned long long bm_uuid = device->ldev->md.uuid[UI_BITMAP];\n\t\tif (bm_uuid)\n\t\t\tdrbd_warn(device, \"bm UUID was already set: %llX\\n\", bm_uuid);\n\n\t\tdevice->ldev->md.uuid[UI_BITMAP] = val & ~((u64)1);\n\t}\n\tspin_unlock_irqrestore(&device->ldev->md.uuid_lock, flags);\n\n\tdrbd_md_mark_dirty(device);\n}\n\n \nint drbd_bmio_set_n_write(struct drbd_device *device,\n\t\t\t  struct drbd_peer_device *peer_device) __must_hold(local)\n\n{\n\tint rv = -EIO;\n\n\tdrbd_md_set_flag(device, MDF_FULL_SYNC);\n\tdrbd_md_sync(device);\n\tdrbd_bm_set_all(device);\n\n\trv = drbd_bm_write(device, peer_device);\n\n\tif (!rv) {\n\t\tdrbd_md_clear_flag(device, MDF_FULL_SYNC);\n\t\tdrbd_md_sync(device);\n\t}\n\n\treturn rv;\n}\n\n \nint drbd_bmio_clear_n_write(struct drbd_device *device,\n\t\t\t  struct drbd_peer_device *peer_device) __must_hold(local)\n\n{\n\tdrbd_resume_al(device);\n\tdrbd_bm_clear_all(device);\n\treturn drbd_bm_write(device, peer_device);\n}\n\nstatic int w_bitmap_io(struct drbd_work *w, int unused)\n{\n\tstruct drbd_device *device =\n\t\tcontainer_of(w, struct drbd_device, bm_io_work.w);\n\tstruct bm_io_work *work = &device->bm_io_work;\n\tint rv = -EIO;\n\n\tif (work->flags != BM_LOCKED_CHANGE_ALLOWED) {\n\t\tint cnt = atomic_read(&device->ap_bio_cnt);\n\t\tif (cnt)\n\t\t\tdrbd_err(device, \"FIXME: ap_bio_cnt %d, expected 0; queued for '%s'\\n\",\n\t\t\t\t\tcnt, work->why);\n\t}\n\n\tif (get_ldev(device)) {\n\t\tdrbd_bm_lock(device, work->why, work->flags);\n\t\trv = work->io_fn(device, work->peer_device);\n\t\tdrbd_bm_unlock(device);\n\t\tput_ldev(device);\n\t}\n\n\tclear_bit_unlock(BITMAP_IO, &device->flags);\n\twake_up(&device->misc_wait);\n\n\tif (work->done)\n\t\twork->done(device, rv);\n\n\tclear_bit(BITMAP_IO_QUEUED, &device->flags);\n\twork->why = NULL;\n\twork->flags = 0;\n\n\treturn 0;\n}\n\n \nvoid drbd_queue_bitmap_io(struct drbd_device *device,\n\t\t\t  int (*io_fn)(struct drbd_device *, struct drbd_peer_device *),\n\t\t\t  void (*done)(struct drbd_device *, int),\n\t\t\t  char *why, enum bm_flag flags,\n\t\t\t  struct drbd_peer_device *peer_device)\n{\n\tD_ASSERT(device, current == peer_device->connection->worker.task);\n\n\tD_ASSERT(device, !test_bit(BITMAP_IO_QUEUED, &device->flags));\n\tD_ASSERT(device, !test_bit(BITMAP_IO, &device->flags));\n\tD_ASSERT(device, list_empty(&device->bm_io_work.w.list));\n\tif (device->bm_io_work.why)\n\t\tdrbd_err(device, \"FIXME going to queue '%s' but '%s' still pending?\\n\",\n\t\t\twhy, device->bm_io_work.why);\n\n\tdevice->bm_io_work.peer_device = peer_device;\n\tdevice->bm_io_work.io_fn = io_fn;\n\tdevice->bm_io_work.done = done;\n\tdevice->bm_io_work.why = why;\n\tdevice->bm_io_work.flags = flags;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tset_bit(BITMAP_IO, &device->flags);\n\t \n\tif (flags == BM_LOCKED_CHANGE_ALLOWED || atomic_read(&device->ap_bio_cnt) == 0) {\n\t\tif (!test_and_set_bit(BITMAP_IO_QUEUED, &device->flags))\n\t\t\tdrbd_queue_work(&peer_device->connection->sender_work,\n\t\t\t\t\t&device->bm_io_work.w);\n\t}\n\tspin_unlock_irq(&device->resource->req_lock);\n}\n\n \nint drbd_bitmap_io(struct drbd_device *device,\n\t\tint (*io_fn)(struct drbd_device *, struct drbd_peer_device *),\n\t\tchar *why, enum bm_flag flags,\n\t\tstruct drbd_peer_device *peer_device)\n{\n\t \n\tconst bool do_suspend_io = flags & (BM_DONT_CLEAR|BM_DONT_SET|BM_DONT_TEST);\n\tint rv;\n\n\tD_ASSERT(device, current != first_peer_device(device)->connection->worker.task);\n\n\tif (do_suspend_io)\n\t\tdrbd_suspend_io(device);\n\n\tdrbd_bm_lock(device, why, flags);\n\trv = io_fn(device, peer_device);\n\tdrbd_bm_unlock(device);\n\n\tif (do_suspend_io)\n\t\tdrbd_resume_io(device);\n\n\treturn rv;\n}\n\nvoid drbd_md_set_flag(struct drbd_device *device, int flag) __must_hold(local)\n{\n\tif ((device->ldev->md.flags & flag) != flag) {\n\t\tdrbd_md_mark_dirty(device);\n\t\tdevice->ldev->md.flags |= flag;\n\t}\n}\n\nvoid drbd_md_clear_flag(struct drbd_device *device, int flag) __must_hold(local)\n{\n\tif ((device->ldev->md.flags & flag) != 0) {\n\t\tdrbd_md_mark_dirty(device);\n\t\tdevice->ldev->md.flags &= ~flag;\n\t}\n}\nint drbd_md_test_flag(struct drbd_backing_dev *bdev, int flag)\n{\n\treturn (bdev->md.flags & flag) != 0;\n}\n\nstatic void md_sync_timer_fn(struct timer_list *t)\n{\n\tstruct drbd_device *device = from_timer(device, t, md_sync_timer);\n\tdrbd_device_post_work(device, MD_SYNC);\n}\n\nconst char *cmdname(enum drbd_packet cmd)\n{\n\t \n\tstatic const char *cmdnames[] = {\n\n\t\t[P_DATA]\t        = \"Data\",\n\t\t[P_DATA_REPLY]\t        = \"DataReply\",\n\t\t[P_RS_DATA_REPLY]\t= \"RSDataReply\",\n\t\t[P_BARRIER]\t        = \"Barrier\",\n\t\t[P_BITMAP]\t        = \"ReportBitMap\",\n\t\t[P_BECOME_SYNC_TARGET]  = \"BecomeSyncTarget\",\n\t\t[P_BECOME_SYNC_SOURCE]  = \"BecomeSyncSource\",\n\t\t[P_UNPLUG_REMOTE]\t= \"UnplugRemote\",\n\t\t[P_DATA_REQUEST]\t= \"DataRequest\",\n\t\t[P_RS_DATA_REQUEST]     = \"RSDataRequest\",\n\t\t[P_SYNC_PARAM]\t        = \"SyncParam\",\n\t\t[P_PROTOCOL]            = \"ReportProtocol\",\n\t\t[P_UUIDS]\t        = \"ReportUUIDs\",\n\t\t[P_SIZES]\t        = \"ReportSizes\",\n\t\t[P_STATE]\t        = \"ReportState\",\n\t\t[P_SYNC_UUID]           = \"ReportSyncUUID\",\n\t\t[P_AUTH_CHALLENGE]      = \"AuthChallenge\",\n\t\t[P_AUTH_RESPONSE]\t= \"AuthResponse\",\n\t\t[P_STATE_CHG_REQ]       = \"StateChgRequest\",\n\t\t[P_PING]\t\t= \"Ping\",\n\t\t[P_PING_ACK]\t        = \"PingAck\",\n\t\t[P_RECV_ACK]\t        = \"RecvAck\",\n\t\t[P_WRITE_ACK]\t        = \"WriteAck\",\n\t\t[P_RS_WRITE_ACK]\t= \"RSWriteAck\",\n\t\t[P_SUPERSEDED]          = \"Superseded\",\n\t\t[P_NEG_ACK]\t        = \"NegAck\",\n\t\t[P_NEG_DREPLY]\t        = \"NegDReply\",\n\t\t[P_NEG_RS_DREPLY]\t= \"NegRSDReply\",\n\t\t[P_BARRIER_ACK]\t        = \"BarrierAck\",\n\t\t[P_STATE_CHG_REPLY]     = \"StateChgReply\",\n\t\t[P_OV_REQUEST]          = \"OVRequest\",\n\t\t[P_OV_REPLY]            = \"OVReply\",\n\t\t[P_OV_RESULT]           = \"OVResult\",\n\t\t[P_CSUM_RS_REQUEST]     = \"CsumRSRequest\",\n\t\t[P_RS_IS_IN_SYNC]\t= \"CsumRSIsInSync\",\n\t\t[P_SYNC_PARAM89]\t= \"SyncParam89\",\n\t\t[P_COMPRESSED_BITMAP]   = \"CBitmap\",\n\t\t[P_DELAY_PROBE]         = \"DelayProbe\",\n\t\t[P_OUT_OF_SYNC]\t\t= \"OutOfSync\",\n\t\t[P_RS_CANCEL]\t\t= \"RSCancel\",\n\t\t[P_CONN_ST_CHG_REQ]\t= \"conn_st_chg_req\",\n\t\t[P_CONN_ST_CHG_REPLY]\t= \"conn_st_chg_reply\",\n\t\t[P_PROTOCOL_UPDATE]\t= \"protocol_update\",\n\t\t[P_TRIM]\t        = \"Trim\",\n\t\t[P_RS_THIN_REQ]         = \"rs_thin_req\",\n\t\t[P_RS_DEALLOCATED]      = \"rs_deallocated\",\n\t\t[P_WSAME]\t        = \"WriteSame\",\n\t\t[P_ZEROES]\t\t= \"Zeroes\",\n\n\t\t \n\t};\n\n\t \n\tif (cmd == P_INITIAL_META)\n\t\treturn \"InitialMeta\";\n\tif (cmd == P_INITIAL_DATA)\n\t\treturn \"InitialData\";\n\tif (cmd == P_CONNECTION_FEATURES)\n\t\treturn \"ConnectionFeatures\";\n\tif (cmd >= ARRAY_SIZE(cmdnames))\n\t\treturn \"Unknown\";\n\treturn cmdnames[cmd];\n}\n\n \nint drbd_wait_misc(struct drbd_device *device, struct drbd_interval *i)\n{\n\tstruct net_conf *nc;\n\tDEFINE_WAIT(wait);\n\tlong timeout;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(first_peer_device(device)->connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -ETIMEDOUT;\n\t}\n\ttimeout = nc->ko_count ? nc->timeout * HZ / 10 * nc->ko_count : MAX_SCHEDULE_TIMEOUT;\n\trcu_read_unlock();\n\n\t \n\ti->waiting = true;\n\tprepare_to_wait(&device->misc_wait, &wait, TASK_INTERRUPTIBLE);\n\tspin_unlock_irq(&device->resource->req_lock);\n\ttimeout = schedule_timeout(timeout);\n\tfinish_wait(&device->misc_wait, &wait);\n\tspin_lock_irq(&device->resource->req_lock);\n\tif (!timeout || device->state.conn < C_CONNECTED)\n\t\treturn -ETIMEDOUT;\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nvoid lock_all_resources(void)\n{\n\tstruct drbd_resource *resource;\n\tint __maybe_unused i = 0;\n\n\tmutex_lock(&resources_mutex);\n\tlocal_irq_disable();\n\tfor_each_resource(resource, &drbd_resources)\n\t\tspin_lock_nested(&resource->req_lock, i++);\n}\n\nvoid unlock_all_resources(void)\n{\n\tstruct drbd_resource *resource;\n\n\tfor_each_resource(resource, &drbd_resources)\n\t\tspin_unlock(&resource->req_lock);\n\tlocal_irq_enable();\n\tmutex_unlock(&resources_mutex);\n}\n\n#ifdef CONFIG_DRBD_FAULT_INJECTION\n \nstruct fault_random_state {\n\tunsigned long state;\n\tunsigned long count;\n};\n\n#define FAULT_RANDOM_MULT 39916801   \n#define FAULT_RANDOM_ADD\t479001701  \n#define FAULT_RANDOM_REFRESH 10000\n\n \nstatic unsigned long\n_drbd_fault_random(struct fault_random_state *rsp)\n{\n\tlong refresh;\n\n\tif (!rsp->count--) {\n\t\tget_random_bytes(&refresh, sizeof(refresh));\n\t\trsp->state += refresh;\n\t\trsp->count = FAULT_RANDOM_REFRESH;\n\t}\n\trsp->state = rsp->state * FAULT_RANDOM_MULT + FAULT_RANDOM_ADD;\n\treturn swahw32(rsp->state);\n}\n\nstatic char *\n_drbd_fault_str(unsigned int type) {\n\tstatic char *_faults[] = {\n\t\t[DRBD_FAULT_MD_WR] = \"Meta-data write\",\n\t\t[DRBD_FAULT_MD_RD] = \"Meta-data read\",\n\t\t[DRBD_FAULT_RS_WR] = \"Resync write\",\n\t\t[DRBD_FAULT_RS_RD] = \"Resync read\",\n\t\t[DRBD_FAULT_DT_WR] = \"Data write\",\n\t\t[DRBD_FAULT_DT_RD] = \"Data read\",\n\t\t[DRBD_FAULT_DT_RA] = \"Data read ahead\",\n\t\t[DRBD_FAULT_BM_ALLOC] = \"BM allocation\",\n\t\t[DRBD_FAULT_AL_EE] = \"EE allocation\",\n\t\t[DRBD_FAULT_RECEIVE] = \"receive data corruption\",\n\t};\n\n\treturn (type < DRBD_FAULT_MAX) ? _faults[type] : \"**Unknown**\";\n}\n\nunsigned int\n_drbd_insert_fault(struct drbd_device *device, unsigned int type)\n{\n\tstatic struct fault_random_state rrs = {0, 0};\n\n\tunsigned int ret = (\n\t\t(drbd_fault_devs == 0 ||\n\t\t\t((1 << device_to_minor(device)) & drbd_fault_devs) != 0) &&\n\t\t(((_drbd_fault_random(&rrs) % 100) + 1) <= drbd_fault_rate));\n\n\tif (ret) {\n\t\tdrbd_fault_count++;\n\n\t\tif (drbd_ratelimit())\n\t\t\tdrbd_warn(device, \"***Simulating %s failure\\n\",\n\t\t\t\t_drbd_fault_str(type));\n\t}\n\n\treturn ret;\n}\n#endif\n\nmodule_init(drbd_init)\nmodule_exit(drbd_cleanup)\n\nEXPORT_SYMBOL(drbd_conn_str);\nEXPORT_SYMBOL(drbd_role_str);\nEXPORT_SYMBOL(drbd_disk_str);\nEXPORT_SYMBOL(drbd_set_st_err_str);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}