{
  "module_name": "drbd_state.h",
  "hash_id": "b5586164d95c2db111695ee94d393a4c7356e44ba1527c381c620da6e4dacc56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_state.h",
  "human_readable_source": " \n#ifndef DRBD_STATE_H\n#define DRBD_STATE_H\n\nstruct drbd_device;\nstruct drbd_connection;\n\n \n#define role_MASK R_MASK\n#define peer_MASK R_MASK\n#define disk_MASK D_MASK\n#define pdsk_MASK D_MASK\n#define conn_MASK C_MASK\n#define susp_MASK 1\n#define user_isp_MASK 1\n#define aftr_isp_MASK 1\n#define susp_nod_MASK 1\n#define susp_fen_MASK 1\n\n#define NS(T, S) \\\n\t({ union drbd_state mask; mask.i = 0; mask.T = T##_MASK; mask; }), \\\n\t({ union drbd_state val; val.i = 0; val.T = (S); val; })\n#define NS2(T1, S1, T2, S2) \\\n\t({ union drbd_state mask; mask.i = 0; mask.T1 = T1##_MASK; \\\n\t  mask.T2 = T2##_MASK; mask; }), \\\n\t({ union drbd_state val; val.i = 0; val.T1 = (S1); \\\n\t  val.T2 = (S2); val; })\n#define NS3(T1, S1, T2, S2, T3, S3) \\\n\t({ union drbd_state mask; mask.i = 0; mask.T1 = T1##_MASK; \\\n\t  mask.T2 = T2##_MASK; mask.T3 = T3##_MASK; mask; }), \\\n\t({ union drbd_state val;  val.i = 0; val.T1 = (S1); \\\n\t  val.T2 = (S2); val.T3 = (S3); val; })\n\n#define _NS(D, T, S) \\\n\tD, ({ union drbd_state __ns; __ns = drbd_read_state(D); __ns.T = (S); __ns; })\n#define _NS2(D, T1, S1, T2, S2) \\\n\tD, ({ union drbd_state __ns; __ns = drbd_read_state(D); __ns.T1 = (S1); \\\n\t__ns.T2 = (S2); __ns; })\n#define _NS3(D, T1, S1, T2, S2, T3, S3) \\\n\tD, ({ union drbd_state __ns; __ns = drbd_read_state(D); __ns.T1 = (S1); \\\n\t__ns.T2 = (S2); __ns.T3 = (S3); __ns; })\n\nenum chg_state_flags {\n\tCS_HARD\t         = 1 << 0,\n\tCS_VERBOSE       = 1 << 1,\n\tCS_WAIT_COMPLETE = 1 << 2,\n\tCS_SERIALIZE     = 1 << 3,\n\tCS_ORDERED       = CS_WAIT_COMPLETE + CS_SERIALIZE,\n\tCS_LOCAL_ONLY    = 1 << 4,  \n\tCS_DC_ROLE       = 1 << 5,  \n\tCS_DC_PEER       = 1 << 6,\n\tCS_DC_CONN       = 1 << 7,\n\tCS_DC_DISK       = 1 << 8,\n\tCS_DC_PDSK       = 1 << 9,\n\tCS_DC_SUSP       = 1 << 10,\n\tCS_DC_MASK       = CS_DC_ROLE + CS_DC_PEER + CS_DC_CONN + CS_DC_DISK + CS_DC_PDSK,\n\tCS_IGN_OUTD_FAIL = 1 << 11,\n\n\t \n\tCS_INHIBIT_MD_IO = 1 << 12,\n};\n\n \nunion drbd_dev_state {\n\tstruct {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t\tunsigned role:2 ;    \n\t\tunsigned peer:2 ;    \n\t\tunsigned conn:5 ;    \n\t\tunsigned disk:4 ;    \n\t\tunsigned pdsk:4 ;    \n\t\tunsigned _unused:1 ;\n\t\tunsigned aftr_isp:1 ;  \n\t\tunsigned peer_isp:1 ;\n\t\tunsigned user_isp:1 ;\n\t\tunsigned _pad:11;    \n#elif defined(__BIG_ENDIAN_BITFIELD)\n\t\tunsigned _pad:11;\n\t\tunsigned user_isp:1 ;\n\t\tunsigned peer_isp:1 ;\n\t\tunsigned aftr_isp:1 ;  \n\t\tunsigned _unused:1 ;\n\t\tunsigned pdsk:4 ;    \n\t\tunsigned disk:4 ;    \n\t\tunsigned conn:5 ;    \n\t\tunsigned peer:2 ;    \n\t\tunsigned role:2 ;    \n#else\n# error \"this endianess is not supported\"\n#endif\n\t};\n\tunsigned int i;\n};\n\nextern enum drbd_state_rv drbd_change_state(struct drbd_device *device,\n\t\t\t\t\t    enum chg_state_flags f,\n\t\t\t\t\t    union drbd_state mask,\n\t\t\t\t\t    union drbd_state val);\nextern void drbd_force_state(struct drbd_device *, union drbd_state,\n\t\t\tunion drbd_state);\nextern enum drbd_state_rv _drbd_request_state(struct drbd_device *,\n\t\t\t\t\t      union drbd_state,\n\t\t\t\t\t      union drbd_state,\n\t\t\t\t\t      enum chg_state_flags);\n\nextern enum drbd_state_rv\n_drbd_request_state_holding_state_mutex(struct drbd_device *, union drbd_state,\n\t\t\t\t\tunion drbd_state, enum chg_state_flags);\n\nextern enum drbd_state_rv _drbd_set_state(struct drbd_device *, union drbd_state,\n\t\t\t\t\t  enum chg_state_flags,\n\t\t\t\t\t  struct completion *done);\nextern void print_st_err(struct drbd_device *, union drbd_state,\n\t\t\tunion drbd_state, enum drbd_state_rv);\n\nenum drbd_state_rv\n_conn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t\t    enum chg_state_flags flags);\n\nenum drbd_state_rv\nconn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\n\t\t   enum chg_state_flags flags);\n\nextern void drbd_resume_al(struct drbd_device *device);\nextern bool conn_all_vols_unconf(struct drbd_connection *connection);\n\n \nstatic inline int drbd_request_state(struct drbd_device *device,\n\t\t\t\t     union drbd_state mask,\n\t\t\t\t     union drbd_state val)\n{\n\treturn _drbd_request_state(device, mask, val, CS_VERBOSE + CS_ORDERED);\n}\n\n \nint drbd_request_detach_interruptible(struct drbd_device *device);\n\nenum drbd_role conn_highest_role(struct drbd_connection *connection);\nenum drbd_role conn_highest_peer(struct drbd_connection *connection);\nenum drbd_disk_state conn_highest_disk(struct drbd_connection *connection);\nenum drbd_disk_state conn_lowest_disk(struct drbd_connection *connection);\nenum drbd_disk_state conn_highest_pdsk(struct drbd_connection *connection);\nenum drbd_conns conn_lowest_conn(struct drbd_connection *connection);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}