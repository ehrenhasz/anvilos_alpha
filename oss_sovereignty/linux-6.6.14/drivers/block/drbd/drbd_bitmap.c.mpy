{
  "module_name": "drbd_bitmap.c",
  "hash_id": "c51c607df4d9cc20a99d4283b0900902d936e87bc52397b0abb3d35143b22818",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_bitmap.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/drbd.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n\n#include \"drbd_int.h\"\n\n\n \n\n\n \n\n \nstruct drbd_bitmap {\n\tstruct page **bm_pages;\n\tspinlock_t bm_lock;\n\n\t \n\tunsigned int n_bitmap_hints;\n\tunsigned int al_bitmap_hints[AL_UPDATES_PER_TRANSACTION];\n\n\t \n\n\tunsigned long bm_set;        \n\tunsigned long bm_bits;\n\tsize_t   bm_words;\n\tsize_t   bm_number_of_pages;\n\tsector_t bm_dev_capacity;\n\tstruct mutex bm_change;  \n\n\twait_queue_head_t bm_io_wait;  \n\n\tenum bm_flag bm_flags;\n\n\t \n\tchar          *bm_why;\n\tstruct task_struct *bm_task;\n};\n\n#define bm_print_lock_info(m) __bm_print_lock_info(m, __func__)\nstatic void __bm_print_lock_info(struct drbd_device *device, const char *func)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!drbd_ratelimit())\n\t\treturn;\n\tdrbd_err(device, \"FIXME %s[%d] in %s, bitmap locked for '%s' by %s[%d]\\n\",\n\t\t current->comm, task_pid_nr(current),\n\t\t func, b->bm_why ?: \"?\",\n\t\t b->bm_task->comm, task_pid_nr(b->bm_task));\n}\n\nvoid drbd_bm_lock(struct drbd_device *device, char *why, enum bm_flag flags)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tint trylock_failed;\n\n\tif (!b) {\n\t\tdrbd_err(device, \"FIXME no bitmap in drbd_bm_lock!?\\n\");\n\t\treturn;\n\t}\n\n\ttrylock_failed = !mutex_trylock(&b->bm_change);\n\n\tif (trylock_failed) {\n\t\tdrbd_warn(device, \"%s[%d] going to '%s' but bitmap already locked for '%s' by %s[%d]\\n\",\n\t\t\t  current->comm, task_pid_nr(current),\n\t\t\t  why, b->bm_why ?: \"?\",\n\t\t\t  b->bm_task->comm, task_pid_nr(b->bm_task));\n\t\tmutex_lock(&b->bm_change);\n\t}\n\tif (BM_LOCKED_MASK & b->bm_flags)\n\t\tdrbd_err(device, \"FIXME bitmap already locked in bm_lock\\n\");\n\tb->bm_flags |= flags & BM_LOCKED_MASK;\n\n\tb->bm_why  = why;\n\tb->bm_task = current;\n}\n\nvoid drbd_bm_unlock(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!b) {\n\t\tdrbd_err(device, \"FIXME no bitmap in drbd_bm_unlock!?\\n\");\n\t\treturn;\n\t}\n\n\tif (!(BM_LOCKED_MASK & device->bitmap->bm_flags))\n\t\tdrbd_err(device, \"FIXME bitmap not locked in bm_unlock\\n\");\n\n\tb->bm_flags &= ~BM_LOCKED_MASK;\n\tb->bm_why  = NULL;\n\tb->bm_task = NULL;\n\tmutex_unlock(&b->bm_change);\n}\n\n \n \n#define BM_PAGE_IDX_MASK\t((1UL<<24)-1)\n \n#define BM_PAGE_IO_LOCK\t\t31\n \n#define BM_PAGE_IO_ERROR\t30\n \n#define BM_PAGE_NEED_WRITEOUT\t29\n \n#define BM_PAGE_LAZY_WRITEOUT\t28\n \n#define BM_PAGE_HINT_WRITEOUT\t27\n\n \nstatic void bm_store_page_idx(struct page *page, unsigned long idx)\n{\n\tBUG_ON(0 != (idx & ~BM_PAGE_IDX_MASK));\n\tset_page_private(page, idx);\n}\n\nstatic unsigned long bm_page_to_idx(struct page *page)\n{\n\treturn page_private(page) & BM_PAGE_IDX_MASK;\n}\n\n \nstatic void bm_page_lock_io(struct drbd_device *device, int page_nr)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tvoid *addr = &page_private(b->bm_pages[page_nr]);\n\twait_event(b->bm_io_wait, !test_and_set_bit(BM_PAGE_IO_LOCK, addr));\n}\n\nstatic void bm_page_unlock_io(struct drbd_device *device, int page_nr)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tvoid *addr = &page_private(b->bm_pages[page_nr]);\n\tclear_bit_unlock(BM_PAGE_IO_LOCK, addr);\n\twake_up(&device->bitmap->bm_io_wait);\n}\n\n \nstatic void bm_set_page_unchanged(struct page *page)\n{\n\t \n\tclear_bit(BM_PAGE_NEED_WRITEOUT, &page_private(page));\n\tclear_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\n}\n\nstatic void bm_set_page_need_writeout(struct page *page)\n{\n\tset_bit(BM_PAGE_NEED_WRITEOUT, &page_private(page));\n}\n\nvoid drbd_bm_reset_al_hints(struct drbd_device *device)\n{\n\tdevice->bitmap->n_bitmap_hints = 0;\n}\n\n \nvoid drbd_bm_mark_for_writeout(struct drbd_device *device, int page_nr)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tstruct page *page;\n\tif (page_nr >= device->bitmap->bm_number_of_pages) {\n\t\tdrbd_warn(device, \"BAD: page_nr: %u, number_of_pages: %u\\n\",\n\t\t\t page_nr, (int)device->bitmap->bm_number_of_pages);\n\t\treturn;\n\t}\n\tpage = device->bitmap->bm_pages[page_nr];\n\tBUG_ON(b->n_bitmap_hints >= ARRAY_SIZE(b->al_bitmap_hints));\n\tif (!test_and_set_bit(BM_PAGE_HINT_WRITEOUT, &page_private(page)))\n\t\tb->al_bitmap_hints[b->n_bitmap_hints++] = page_nr;\n}\n\nstatic int bm_test_page_unchanged(struct page *page)\n{\n\tvolatile const unsigned long *addr = &page_private(page);\n\treturn (*addr & ((1UL<<BM_PAGE_NEED_WRITEOUT)|(1UL<<BM_PAGE_LAZY_WRITEOUT))) == 0;\n}\n\nstatic void bm_set_page_io_err(struct page *page)\n{\n\tset_bit(BM_PAGE_IO_ERROR, &page_private(page));\n}\n\nstatic void bm_clear_page_io_err(struct page *page)\n{\n\tclear_bit(BM_PAGE_IO_ERROR, &page_private(page));\n}\n\nstatic void bm_set_page_lazy_writeout(struct page *page)\n{\n\tset_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\n}\n\nstatic int bm_test_page_lazy_writeout(struct page *page)\n{\n\treturn test_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\n}\n\n \nstatic unsigned int bm_word_to_page_idx(struct drbd_bitmap *b, unsigned long long_nr)\n{\n\t \n\tunsigned int page_nr = long_nr >> (PAGE_SHIFT - LN2_BPL + 3);\n\tBUG_ON(page_nr >= b->bm_number_of_pages);\n\treturn page_nr;\n}\n\nstatic unsigned int bm_bit_to_page_idx(struct drbd_bitmap *b, u64 bitnr)\n{\n\t \n\tunsigned int page_nr = bitnr >> (PAGE_SHIFT + 3);\n\tBUG_ON(page_nr >= b->bm_number_of_pages);\n\treturn page_nr;\n}\n\nstatic unsigned long *__bm_map_pidx(struct drbd_bitmap *b, unsigned int idx)\n{\n\tstruct page *page = b->bm_pages[idx];\n\treturn (unsigned long *) kmap_atomic(page);\n}\n\nstatic unsigned long *bm_map_pidx(struct drbd_bitmap *b, unsigned int idx)\n{\n\treturn __bm_map_pidx(b, idx);\n}\n\nstatic void __bm_unmap(unsigned long *p_addr)\n{\n\tkunmap_atomic(p_addr);\n};\n\nstatic void bm_unmap(unsigned long *p_addr)\n{\n\treturn __bm_unmap(p_addr);\n}\n\n \n#define S2W(s)\t((s)<<(BM_EXT_SHIFT-BM_BLOCK_SHIFT-LN2_BPL))\n \n#define MLPP(X) ((X) & ((PAGE_SIZE/sizeof(long))-1))\n\n \n#define LWPP (PAGE_SIZE/sizeof(long))\n\n \n\n\nstatic void bm_free_pages(struct page **pages, unsigned long number)\n{\n\tunsigned long i;\n\tif (!pages)\n\t\treturn;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (!pages[i]) {\n\t\t\tpr_alert(\"bm_free_pages tried to free a NULL pointer; i=%lu n=%lu\\n\",\n\t\t\t\t i, number);\n\t\t\tcontinue;\n\t\t}\n\t\t__free_page(pages[i]);\n\t\tpages[i] = NULL;\n\t}\n}\n\nstatic inline void bm_vk_free(void *ptr)\n{\n\tkvfree(ptr);\n}\n\n \nstatic struct page **bm_realloc_pages(struct drbd_bitmap *b, unsigned long want)\n{\n\tstruct page **old_pages = b->bm_pages;\n\tstruct page **new_pages, *page;\n\tunsigned int i, bytes;\n\tunsigned long have = b->bm_number_of_pages;\n\n\tBUG_ON(have == 0 && old_pages != NULL);\n\tBUG_ON(have != 0 && old_pages == NULL);\n\n\tif (have == want)\n\t\treturn old_pages;\n\n\t \n\tbytes = sizeof(struct page *)*want;\n\tnew_pages = kzalloc(bytes, GFP_NOIO | __GFP_NOWARN);\n\tif (!new_pages) {\n\t\tnew_pages = __vmalloc(bytes, GFP_NOIO | __GFP_ZERO);\n\t\tif (!new_pages)\n\t\t\treturn NULL;\n\t}\n\n\tif (want >= have) {\n\t\tfor (i = 0; i < have; i++)\n\t\t\tnew_pages[i] = old_pages[i];\n\t\tfor (; i < want; i++) {\n\t\t\tpage = alloc_page(GFP_NOIO | __GFP_HIGHMEM);\n\t\t\tif (!page) {\n\t\t\t\tbm_free_pages(new_pages + have, i - have);\n\t\t\t\tbm_vk_free(new_pages);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t \n\t\t\tbm_store_page_idx(page, i);\n\t\t\tnew_pages[i] = page;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < want; i++)\n\t\t\tnew_pages[i] = old_pages[i];\n\t\t \n\t}\n\n\treturn new_pages;\n}\n\n \nint drbd_bm_init(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tWARN_ON(b != NULL);\n\tb = kzalloc(sizeof(struct drbd_bitmap), GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&b->bm_lock);\n\tmutex_init(&b->bm_change);\n\tinit_waitqueue_head(&b->bm_io_wait);\n\n\tdevice->bitmap = b;\n\n\treturn 0;\n}\n\nsector_t drbd_bm_capacity(struct drbd_device *device)\n{\n\tif (!expect(device, device->bitmap))\n\t\treturn 0;\n\treturn device->bitmap->bm_dev_capacity;\n}\n\n \nvoid drbd_bm_cleanup(struct drbd_device *device)\n{\n\tif (!expect(device, device->bitmap))\n\t\treturn;\n\tbm_free_pages(device->bitmap->bm_pages, device->bitmap->bm_number_of_pages);\n\tbm_vk_free(device->bitmap->bm_pages);\n\tkfree(device->bitmap);\n\tdevice->bitmap = NULL;\n}\n\n \n#ifndef BITS_PER_PAGE\n#define BITS_PER_PAGE\t\t(1UL << (PAGE_SHIFT + 3))\n#define BITS_PER_PAGE_MASK\t(BITS_PER_PAGE - 1)\n#else\n# if BITS_PER_PAGE != (1UL << (PAGE_SHIFT + 3))\n#  error \"ambiguous BITS_PER_PAGE\"\n# endif\n#endif\n#define BITS_PER_LONG_MASK\t(BITS_PER_LONG - 1)\nstatic int bm_clear_surplus(struct drbd_bitmap *b)\n{\n\tunsigned long mask;\n\tunsigned long *p_addr, *bm;\n\tint tmp;\n\tint cleared = 0;\n\n\t \n\ttmp = (b->bm_bits & BITS_PER_PAGE_MASK);\n\t \n\tmask = (1UL << (tmp & BITS_PER_LONG_MASK)) -1;\n\t \n\tmask = cpu_to_lel(mask);\n\n\tp_addr = bm_map_pidx(b, b->bm_number_of_pages - 1);\n\tbm = p_addr + (tmp/BITS_PER_LONG);\n\tif (mask) {\n\t\t \n\t\tcleared = hweight_long(*bm & ~mask);\n\t\t*bm &= mask;\n\t\tbm++;\n\t}\n\n\tif (BITS_PER_LONG == 32 && ((bm - p_addr) & 1) == 1) {\n\t\t \n\t\tcleared += hweight_long(*bm);\n\t\t*bm = 0;\n\t}\n\tbm_unmap(p_addr);\n\treturn cleared;\n}\n\nstatic void bm_set_surplus(struct drbd_bitmap *b)\n{\n\tunsigned long mask;\n\tunsigned long *p_addr, *bm;\n\tint tmp;\n\n\t \n\ttmp = (b->bm_bits & BITS_PER_PAGE_MASK);\n\t \n\tmask = (1UL << (tmp & BITS_PER_LONG_MASK)) -1;\n\t \n\tmask = cpu_to_lel(mask);\n\n\tp_addr = bm_map_pidx(b, b->bm_number_of_pages - 1);\n\tbm = p_addr + (tmp/BITS_PER_LONG);\n\tif (mask) {\n\t\t \n\t\t*bm |= ~mask;\n\t\tbm++;\n\t}\n\n\tif (BITS_PER_LONG == 32 && ((bm - p_addr) & 1) == 1) {\n\t\t \n\t\t*bm = ~0UL;\n\t}\n\tbm_unmap(p_addr);\n}\n\n \nstatic unsigned long bm_count_bits(struct drbd_bitmap *b)\n{\n\tunsigned long *p_addr;\n\tunsigned long bits = 0;\n\tunsigned long mask = (1UL << (b->bm_bits & BITS_PER_LONG_MASK)) -1;\n\tint idx, last_word;\n\n\t \n\tfor (idx = 0; idx < b->bm_number_of_pages - 1; idx++) {\n\t\tp_addr = __bm_map_pidx(b, idx);\n\t\tbits += bitmap_weight(p_addr, BITS_PER_PAGE);\n\t\t__bm_unmap(p_addr);\n\t\tcond_resched();\n\t}\n\t \n\tlast_word = ((b->bm_bits - 1) & BITS_PER_PAGE_MASK) >> LN2_BPL;\n\tp_addr = __bm_map_pidx(b, idx);\n\tbits += bitmap_weight(p_addr, last_word * BITS_PER_LONG);\n\tp_addr[last_word] &= cpu_to_lel(mask);\n\tbits += hweight_long(p_addr[last_word]);\n\t \n\tif (BITS_PER_LONG == 32 && (last_word & 1) == 0)\n\t\tp_addr[last_word+1] = 0;\n\t__bm_unmap(p_addr);\n\treturn bits;\n}\n\n \nstatic void bm_memset(struct drbd_bitmap *b, size_t offset, int c, size_t len)\n{\n\tunsigned long *p_addr, *bm;\n\tunsigned int idx;\n\tsize_t do_now, end;\n\n\tend = offset + len;\n\n\tif (end > b->bm_words) {\n\t\tpr_alert(\"bm_memset end > bm_words\\n\");\n\t\treturn;\n\t}\n\n\twhile (offset < end) {\n\t\tdo_now = min_t(size_t, ALIGN(offset + 1, LWPP), end) - offset;\n\t\tidx = bm_word_to_page_idx(b, offset);\n\t\tp_addr = bm_map_pidx(b, idx);\n\t\tbm = p_addr + MLPP(offset);\n\t\tif (bm+do_now > p_addr + LWPP) {\n\t\t\tpr_alert(\"BUG BUG BUG! p_addr:%p bm:%p do_now:%d\\n\",\n\t\t\t       p_addr, bm, (int)do_now);\n\t\t} else\n\t\t\tmemset(bm, c, do_now * sizeof(long));\n\t\tbm_unmap(p_addr);\n\t\tbm_set_page_need_writeout(b->bm_pages[idx]);\n\t\toffset += do_now;\n\t}\n}\n\n \nstatic u64 drbd_md_on_disk_bits(struct drbd_backing_dev *ldev)\n{\n\tu64 bitmap_sectors;\n\tif (ldev->md.al_offset == 8)\n\t\tbitmap_sectors = ldev->md.md_size_sect - ldev->md.bm_offset;\n\telse\n\t\tbitmap_sectors = ldev->md.al_offset - ldev->md.bm_offset;\n\treturn bitmap_sectors << (9 + 3);\n}\n\n \nint drbd_bm_resize(struct drbd_device *device, sector_t capacity, int set_new_bits)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long bits, words, owords, obits;\n\tunsigned long want, have, onpages;  \n\tstruct page **npages, **opages = NULL;\n\tint err = 0;\n\tbool growing;\n\n\tif (!expect(device, b))\n\t\treturn -ENOMEM;\n\n\tdrbd_bm_lock(device, \"resize\", BM_LOCKED_MASK);\n\n\tdrbd_info(device, \"drbd_bm_resize called with capacity == %llu\\n\",\n\t\t\t(unsigned long long)capacity);\n\n\tif (capacity == b->bm_dev_capacity)\n\t\tgoto out;\n\n\tif (capacity == 0) {\n\t\tspin_lock_irq(&b->bm_lock);\n\t\topages = b->bm_pages;\n\t\tonpages = b->bm_number_of_pages;\n\t\towords = b->bm_words;\n\t\tb->bm_pages = NULL;\n\t\tb->bm_number_of_pages =\n\t\tb->bm_set   =\n\t\tb->bm_bits  =\n\t\tb->bm_words =\n\t\tb->bm_dev_capacity = 0;\n\t\tspin_unlock_irq(&b->bm_lock);\n\t\tbm_free_pages(opages, onpages);\n\t\tbm_vk_free(opages);\n\t\tgoto out;\n\t}\n\tbits  = BM_SECT_TO_BIT(ALIGN(capacity, BM_SECT_PER_BIT));\n\n\t \n\twords = ALIGN(bits, 64) >> LN2_BPL;\n\n\tif (get_ldev(device)) {\n\t\tu64 bits_on_disk = drbd_md_on_disk_bits(device->ldev);\n\t\tput_ldev(device);\n\t\tif (bits > bits_on_disk) {\n\t\t\tdrbd_info(device, \"bits = %lu\\n\", bits);\n\t\t\tdrbd_info(device, \"bits_on_disk = %llu\\n\", bits_on_disk);\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twant = PFN_UP(words*sizeof(long));\n\thave = b->bm_number_of_pages;\n\tif (want == have) {\n\t\tD_ASSERT(device, b->bm_pages != NULL);\n\t\tnpages = b->bm_pages;\n\t} else {\n\t\tif (drbd_insert_fault(device, DRBD_FAULT_BM_ALLOC))\n\t\t\tnpages = NULL;\n\t\telse\n\t\t\tnpages = bm_realloc_pages(b, want);\n\t}\n\n\tif (!npages) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&b->bm_lock);\n\topages = b->bm_pages;\n\towords = b->bm_words;\n\tobits  = b->bm_bits;\n\n\tgrowing = bits > obits;\n\tif (opages && growing && set_new_bits)\n\t\tbm_set_surplus(b);\n\n\tb->bm_pages = npages;\n\tb->bm_number_of_pages = want;\n\tb->bm_bits  = bits;\n\tb->bm_words = words;\n\tb->bm_dev_capacity = capacity;\n\n\tif (growing) {\n\t\tif (set_new_bits) {\n\t\t\tbm_memset(b, owords, 0xff, words-owords);\n\t\t\tb->bm_set += bits - obits;\n\t\t} else\n\t\t\tbm_memset(b, owords, 0x00, words-owords);\n\n\t}\n\n\tif (want < have) {\n\t\t \n\t\tbm_free_pages(opages + want, have - want);\n\t}\n\n\t(void)bm_clear_surplus(b);\n\n\tspin_unlock_irq(&b->bm_lock);\n\tif (opages != npages)\n\t\tbm_vk_free(opages);\n\tif (!growing)\n\t\tb->bm_set = bm_count_bits(b);\n\tdrbd_info(device, \"resync bitmap: bits=%lu words=%lu pages=%lu\\n\", bits, words, want);\n\n out:\n\tdrbd_bm_unlock(device);\n\treturn err;\n}\n\n \nunsigned long _drbd_bm_total_weight(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long s;\n\tunsigned long flags;\n\n\tif (!expect(device, b))\n\t\treturn 0;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&b->bm_lock, flags);\n\ts = b->bm_set;\n\tspin_unlock_irqrestore(&b->bm_lock, flags);\n\n\treturn s;\n}\n\nunsigned long drbd_bm_total_weight(struct drbd_device *device)\n{\n\tunsigned long s;\n\t \n\tif (!get_ldev_if_state(device, D_NEGOTIATING))\n\t\treturn 0;\n\ts = _drbd_bm_total_weight(device);\n\tput_ldev(device);\n\treturn s;\n}\n\nsize_t drbd_bm_words(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!expect(device, b))\n\t\treturn 0;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 0;\n\n\treturn b->bm_words;\n}\n\nunsigned long drbd_bm_bits(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!expect(device, b))\n\t\treturn 0;\n\n\treturn b->bm_bits;\n}\n\n \nvoid drbd_bm_merge_lel(struct drbd_device *device, size_t offset, size_t number,\n\t\t\tunsigned long *buffer)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr, *bm;\n\tunsigned long word, bits;\n\tunsigned int idx;\n\tsize_t end, do_now;\n\n\tend = offset + number;\n\n\tif (!expect(device, b))\n\t\treturn;\n\tif (!expect(device, b->bm_pages))\n\t\treturn;\n\tif (number == 0)\n\t\treturn;\n\tWARN_ON(offset >= b->bm_words);\n\tWARN_ON(end    >  b->bm_words);\n\n\tspin_lock_irq(&b->bm_lock);\n\twhile (offset < end) {\n\t\tdo_now = min_t(size_t, ALIGN(offset+1, LWPP), end) - offset;\n\t\tidx = bm_word_to_page_idx(b, offset);\n\t\tp_addr = bm_map_pidx(b, idx);\n\t\tbm = p_addr + MLPP(offset);\n\t\toffset += do_now;\n\t\twhile (do_now--) {\n\t\t\tbits = hweight_long(*bm);\n\t\t\tword = *bm | *buffer++;\n\t\t\t*bm++ = word;\n\t\t\tb->bm_set += hweight_long(word) - bits;\n\t\t}\n\t\tbm_unmap(p_addr);\n\t\tbm_set_page_need_writeout(b->bm_pages[idx]);\n\t}\n\t \n\tif (end == b->bm_words)\n\t\tb->bm_set -= bm_clear_surplus(b);\n\tspin_unlock_irq(&b->bm_lock);\n}\n\n \nvoid drbd_bm_get_lel(struct drbd_device *device, size_t offset, size_t number,\n\t\t     unsigned long *buffer)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr, *bm;\n\tsize_t end, do_now;\n\n\tend = offset + number;\n\n\tif (!expect(device, b))\n\t\treturn;\n\tif (!expect(device, b->bm_pages))\n\t\treturn;\n\n\tspin_lock_irq(&b->bm_lock);\n\tif ((offset >= b->bm_words) ||\n\t    (end    >  b->bm_words) ||\n\t    (number <= 0))\n\t\tdrbd_err(device, \"offset=%lu number=%lu bm_words=%lu\\n\",\n\t\t\t(unsigned long)\toffset,\n\t\t\t(unsigned long)\tnumber,\n\t\t\t(unsigned long) b->bm_words);\n\telse {\n\t\twhile (offset < end) {\n\t\t\tdo_now = min_t(size_t, ALIGN(offset+1, LWPP), end) - offset;\n\t\t\tp_addr = bm_map_pidx(b, bm_word_to_page_idx(b, offset));\n\t\t\tbm = p_addr + MLPP(offset);\n\t\t\toffset += do_now;\n\t\t\twhile (do_now--)\n\t\t\t\t*buffer++ = *bm++;\n\t\t\tbm_unmap(p_addr);\n\t\t}\n\t}\n\tspin_unlock_irq(&b->bm_lock);\n}\n\n \nvoid drbd_bm_set_all(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!expect(device, b))\n\t\treturn;\n\tif (!expect(device, b->bm_pages))\n\t\treturn;\n\n\tspin_lock_irq(&b->bm_lock);\n\tbm_memset(b, 0, 0xff, b->bm_words);\n\t(void)bm_clear_surplus(b);\n\tb->bm_set = b->bm_bits;\n\tspin_unlock_irq(&b->bm_lock);\n}\n\n \nvoid drbd_bm_clear_all(struct drbd_device *device)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tif (!expect(device, b))\n\t\treturn;\n\tif (!expect(device, b->bm_pages))\n\t\treturn;\n\n\tspin_lock_irq(&b->bm_lock);\n\tbm_memset(b, 0, 0, b->bm_words);\n\tb->bm_set = 0;\n\tspin_unlock_irq(&b->bm_lock);\n}\n\nstatic void drbd_bm_aio_ctx_destroy(struct kref *kref)\n{\n\tstruct drbd_bm_aio_ctx *ctx = container_of(kref, struct drbd_bm_aio_ctx, kref);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->device->resource->req_lock, flags);\n\tlist_del(&ctx->list);\n\tspin_unlock_irqrestore(&ctx->device->resource->req_lock, flags);\n\tput_ldev(ctx->device);\n\tkfree(ctx);\n}\n\n \nstatic void drbd_bm_endio(struct bio *bio)\n{\n\tstruct drbd_bm_aio_ctx *ctx = bio->bi_private;\n\tstruct drbd_device *device = ctx->device;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned int idx = bm_page_to_idx(bio_first_page_all(bio));\n\n\tif ((ctx->flags & BM_AIO_COPY_PAGES) == 0 &&\n\t    !bm_test_page_unchanged(b->bm_pages[idx]))\n\t\tdrbd_warn(device, \"bitmap page idx %u changed during IO!\\n\", idx);\n\n\tif (bio->bi_status) {\n\t\t \n\t\tctx->error = blk_status_to_errno(bio->bi_status);\n\t\tbm_set_page_io_err(b->bm_pages[idx]);\n\t\t \n\t\tif (drbd_ratelimit())\n\t\t\tdrbd_err(device, \"IO ERROR %d on bitmap page idx %u\\n\",\n\t\t\t\t\tbio->bi_status, idx);\n\t} else {\n\t\tbm_clear_page_io_err(b->bm_pages[idx]);\n\t\tdynamic_drbd_dbg(device, \"bitmap page idx %u completed\\n\", idx);\n\t}\n\n\tbm_page_unlock_io(device, idx);\n\n\tif (ctx->flags & BM_AIO_COPY_PAGES)\n\t\tmempool_free(bio->bi_io_vec[0].bv_page, &drbd_md_io_page_pool);\n\n\tbio_put(bio);\n\n\tif (atomic_dec_and_test(&ctx->in_flight)) {\n\t\tctx->done = 1;\n\t\twake_up(&device->misc_wait);\n\t\tkref_put(&ctx->kref, &drbd_bm_aio_ctx_destroy);\n\t}\n}\n\n \nstatic inline sector_t drbd_md_last_bitmap_sector(struct drbd_backing_dev *bdev)\n{\n\tswitch (bdev->md.meta_dev_idx) {\n\tcase DRBD_MD_INDEX_INTERNAL:\n\tcase DRBD_MD_INDEX_FLEX_INT:\n\t\treturn bdev->md.md_offset + bdev->md.al_offset -1;\n\tcase DRBD_MD_INDEX_FLEX_EXT:\n\tdefault:\n\t\treturn bdev->md.md_offset + bdev->md.md_size_sect -1;\n\t}\n}\n\nstatic void bm_page_io_async(struct drbd_bm_aio_ctx *ctx, int page_nr) __must_hold(local)\n{\n\tstruct drbd_device *device = ctx->device;\n\tenum req_op op = ctx->flags & BM_AIO_READ ? REQ_OP_READ : REQ_OP_WRITE;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tstruct bio *bio;\n\tstruct page *page;\n\tsector_t last_bm_sect;\n\tsector_t first_bm_sect;\n\tsector_t on_disk_sector;\n\tunsigned int len;\n\n\tfirst_bm_sect = device->ldev->md.md_offset + device->ldev->md.bm_offset;\n\ton_disk_sector = first_bm_sect + (((sector_t)page_nr) << (PAGE_SHIFT-SECTOR_SHIFT));\n\n\t \n\tlast_bm_sect = drbd_md_last_bitmap_sector(device->ldev);\n\tif (first_bm_sect <= on_disk_sector && last_bm_sect >= on_disk_sector) {\n\t\tsector_t len_sect = last_bm_sect - on_disk_sector + 1;\n\t\tif (len_sect < PAGE_SIZE/SECTOR_SIZE)\n\t\t\tlen = (unsigned int)len_sect*SECTOR_SIZE;\n\t\telse\n\t\t\tlen = PAGE_SIZE;\n\t} else {\n\t\tif (drbd_ratelimit()) {\n\t\t\tdrbd_err(device, \"Invalid offset during on-disk bitmap access: \"\n\t\t\t\t \"page idx %u, sector %llu\\n\", page_nr, on_disk_sector);\n\t\t}\n\t\tctx->error = -EIO;\n\t\tbm_set_page_io_err(b->bm_pages[page_nr]);\n\t\tif (atomic_dec_and_test(&ctx->in_flight)) {\n\t\t\tctx->done = 1;\n\t\t\twake_up(&device->misc_wait);\n\t\t\tkref_put(&ctx->kref, &drbd_bm_aio_ctx_destroy);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tbm_page_lock_io(device, page_nr);\n\t \n\tbm_set_page_unchanged(b->bm_pages[page_nr]);\n\n\tif (ctx->flags & BM_AIO_COPY_PAGES) {\n\t\tpage = mempool_alloc(&drbd_md_io_page_pool,\n\t\t\t\tGFP_NOIO | __GFP_HIGHMEM);\n\t\tcopy_highpage(page, b->bm_pages[page_nr]);\n\t\tbm_store_page_idx(page, page_nr);\n\t} else\n\t\tpage = b->bm_pages[page_nr];\n\tbio = bio_alloc_bioset(device->ldev->md_bdev, 1, op, GFP_NOIO,\n\t\t\t&drbd_md_io_bio_set);\n\tbio->bi_iter.bi_sector = on_disk_sector;\n\t__bio_add_page(bio, page, len, 0);\n\tbio->bi_private = ctx;\n\tbio->bi_end_io = drbd_bm_endio;\n\n\tif (drbd_insert_fault(device, (op == REQ_OP_WRITE) ? DRBD_FAULT_MD_WR : DRBD_FAULT_MD_RD)) {\n\t\tbio_io_error(bio);\n\t} else {\n\t\tsubmit_bio(bio);\n\t\t \n\t\tatomic_add(len >> 9, &device->rs_sect_ev);\n\t}\n}\n\n \nstatic int bm_rw(struct drbd_device *device, const unsigned int flags, unsigned lazy_writeout_upper_idx) __must_hold(local)\n{\n\tstruct drbd_bm_aio_ctx *ctx;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned int num_pages, i, count = 0;\n\tunsigned long now;\n\tchar ppb[10];\n\tint err = 0;\n\n\t \n\n\tctx = kmalloc(sizeof(struct drbd_bm_aio_ctx), GFP_NOIO);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t*ctx = (struct drbd_bm_aio_ctx) {\n\t\t.device = device,\n\t\t.start_jif = jiffies,\n\t\t.in_flight = ATOMIC_INIT(1),\n\t\t.done = 0,\n\t\t.flags = flags,\n\t\t.error = 0,\n\t\t.kref = KREF_INIT(2),\n\t};\n\n\tif (!get_ldev_if_state(device, D_ATTACHING)) {   \n\t\tdrbd_err(device, \"ASSERT FAILED: get_ldev_if_state() == 1 in bm_rw()\\n\");\n\t\tkfree(ctx);\n\t\treturn -ENODEV;\n\t}\n\t \n\n\tif (0 == (ctx->flags & ~BM_AIO_READ))\n\t\tWARN_ON(!(BM_LOCKED_MASK & b->bm_flags));\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_add_tail(&ctx->list, &device->pending_bitmap_io);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tnum_pages = b->bm_number_of_pages;\n\n\tnow = jiffies;\n\n\t \n\n\tif (flags & BM_AIO_READ) {\n\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\tatomic_inc(&ctx->in_flight);\n\t\t\tbm_page_io_async(ctx, i);\n\t\t\t++count;\n\t\t\tcond_resched();\n\t\t}\n\t} else if (flags & BM_AIO_WRITE_HINTED) {\n\t\t \n\t\tunsigned int hint;\n\t\tfor (hint = 0; hint < b->n_bitmap_hints; hint++) {\n\t\t\ti = b->al_bitmap_hints[hint];\n\t\t\tif (i >= num_pages)  \n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!test_and_clear_bit(BM_PAGE_HINT_WRITEOUT,\n\t\t\t    &page_private(b->bm_pages[i])))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (bm_test_page_unchanged(b->bm_pages[i]))\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&ctx->in_flight);\n\t\t\tbm_page_io_async(ctx, i);\n\t\t\t++count;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t \n\t\t\tif (lazy_writeout_upper_idx && i == lazy_writeout_upper_idx)\n\t\t\t\tbreak;\n\t\t\tif (!(flags & BM_AIO_WRITE_ALL_PAGES) &&\n\t\t\t    bm_test_page_unchanged(b->bm_pages[i])) {\n\t\t\t\tdynamic_drbd_dbg(device, \"skipped bm write for idx %u\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (lazy_writeout_upper_idx &&\n\t\t\t    !bm_test_page_lazy_writeout(b->bm_pages[i])) {\n\t\t\t\tdynamic_drbd_dbg(device, \"skipped bm lazy write for idx %u\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&ctx->in_flight);\n\t\t\tbm_page_io_async(ctx, i);\n\t\t\t++count;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\t \n\tif (!atomic_dec_and_test(&ctx->in_flight))\n\t\twait_until_done_or_force_detached(device, device->ldev, &ctx->done);\n\telse\n\t\tkref_put(&ctx->kref, &drbd_bm_aio_ctx_destroy);\n\n\t \n\tif (flags == 0) {\n\t\tunsigned int ms = jiffies_to_msecs(jiffies - now);\n\t\tif (ms > 5) {\n\t\t\tdrbd_info(device, \"bitmap %s of %u pages took %u ms\\n\",\n\t\t\t\t (flags & BM_AIO_READ) ? \"READ\" : \"WRITE\",\n\t\t\t\t count, ms);\n\t\t}\n\t}\n\n\tif (ctx->error) {\n\t\tdrbd_alert(device, \"we had at least one MD IO ERROR during bitmap IO\\n\");\n\t\tdrbd_chk_io_error(device, 1, DRBD_META_IO_ERROR);\n\t\terr = -EIO;  \n\t}\n\n\tif (atomic_read(&ctx->in_flight))\n\t\terr = -EIO;  \n\n\tnow = jiffies;\n\tif (flags & BM_AIO_READ) {\n\t\tb->bm_set = bm_count_bits(b);\n\t\tdrbd_info(device, \"recounting of set bits took additional %lu jiffies\\n\",\n\t\t     jiffies - now);\n\t}\n\tnow = b->bm_set;\n\n\tif ((flags & ~BM_AIO_READ) == 0)\n\t\tdrbd_info(device, \"%s (%lu bits) marked out-of-sync by on disk bit-map.\\n\",\n\t\t     ppsize(ppb, now << (BM_BLOCK_SHIFT-10)), now);\n\n\tkref_put(&ctx->kref, &drbd_bm_aio_ctx_destroy);\n\treturn err;\n}\n\n \nint drbd_bm_read(struct drbd_device *device,\n\t\t struct drbd_peer_device *peer_device) __must_hold(local)\n\n{\n\treturn bm_rw(device, BM_AIO_READ, 0);\n}\n\n \nint drbd_bm_write(struct drbd_device *device,\n\t\t struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\treturn bm_rw(device, 0, 0);\n}\n\n \nint drbd_bm_write_all(struct drbd_device *device,\n\t\tstruct drbd_peer_device *peer_device) __must_hold(local)\n{\n\treturn bm_rw(device, BM_AIO_WRITE_ALL_PAGES, 0);\n}\n\n \nint drbd_bm_write_lazy(struct drbd_device *device, unsigned upper_idx) __must_hold(local)\n{\n\treturn bm_rw(device, BM_AIO_COPY_PAGES, upper_idx);\n}\n\n \nint drbd_bm_write_copy_pages(struct drbd_device *device,\n\t\tstruct drbd_peer_device *peer_device) __must_hold(local)\n{\n\treturn bm_rw(device, BM_AIO_COPY_PAGES, 0);\n}\n\n \nint drbd_bm_write_hinted(struct drbd_device *device) __must_hold(local)\n{\n\treturn bm_rw(device, BM_AIO_WRITE_HINTED | BM_AIO_COPY_PAGES, 0);\n}\n\n \nstatic unsigned long __bm_find_next(struct drbd_device *device, unsigned long bm_fo,\n\tconst int find_zero_bit)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr;\n\tunsigned long bit_offset;\n\tunsigned i;\n\n\n\tif (bm_fo > b->bm_bits) {\n\t\tdrbd_err(device, \"bm_fo=%lu bm_bits=%lu\\n\", bm_fo, b->bm_bits);\n\t\tbm_fo = DRBD_END_OF_BITMAP;\n\t} else {\n\t\twhile (bm_fo < b->bm_bits) {\n\t\t\t \n\t\t\tbit_offset = bm_fo & ~BITS_PER_PAGE_MASK;\n\t\t\tp_addr = __bm_map_pidx(b, bm_bit_to_page_idx(b, bm_fo));\n\n\t\t\tif (find_zero_bit)\n\t\t\t\ti = find_next_zero_bit_le(p_addr,\n\t\t\t\t\t\tPAGE_SIZE*8, bm_fo & BITS_PER_PAGE_MASK);\n\t\t\telse\n\t\t\t\ti = find_next_bit_le(p_addr,\n\t\t\t\t\t\tPAGE_SIZE*8, bm_fo & BITS_PER_PAGE_MASK);\n\n\t\t\t__bm_unmap(p_addr);\n\t\t\tif (i < PAGE_SIZE*8) {\n\t\t\t\tbm_fo = bit_offset + i;\n\t\t\t\tif (bm_fo >= b->bm_bits)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbm_fo = bit_offset + PAGE_SIZE*8;\n\t\t}\n\t\tbm_fo = DRBD_END_OF_BITMAP;\n\t}\n found:\n\treturn bm_fo;\n}\n\nstatic unsigned long bm_find_next(struct drbd_device *device,\n\tunsigned long bm_fo, const int find_zero_bit)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long i = DRBD_END_OF_BITMAP;\n\n\tif (!expect(device, b))\n\t\treturn i;\n\tif (!expect(device, b->bm_pages))\n\t\treturn i;\n\n\tspin_lock_irq(&b->bm_lock);\n\tif (BM_DONT_TEST & b->bm_flags)\n\t\tbm_print_lock_info(device);\n\n\ti = __bm_find_next(device, bm_fo, find_zero_bit);\n\n\tspin_unlock_irq(&b->bm_lock);\n\treturn i;\n}\n\nunsigned long drbd_bm_find_next(struct drbd_device *device, unsigned long bm_fo)\n{\n\treturn bm_find_next(device, bm_fo, 0);\n}\n\n#if 0\n \nunsigned long drbd_bm_find_next_zero(struct drbd_device *device, unsigned long bm_fo)\n{\n\treturn bm_find_next(device, bm_fo, 1);\n}\n#endif\n\n \nunsigned long _drbd_bm_find_next(struct drbd_device *device, unsigned long bm_fo)\n{\n\t \n\treturn __bm_find_next(device, bm_fo, 0);\n}\n\nunsigned long _drbd_bm_find_next_zero(struct drbd_device *device, unsigned long bm_fo)\n{\n\t \n\treturn __bm_find_next(device, bm_fo, 1);\n}\n\n \nstatic int __bm_change_bits_to(struct drbd_device *device, const unsigned long s,\n\tunsigned long e, int val)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr = NULL;\n\tunsigned long bitnr;\n\tunsigned int last_page_nr = -1U;\n\tint c = 0;\n\tint changed_total = 0;\n\n\tif (e >= b->bm_bits) {\n\t\tdrbd_err(device, \"ASSERT FAILED: bit_s=%lu bit_e=%lu bm_bits=%lu\\n\",\n\t\t\t\ts, e, b->bm_bits);\n\t\te = b->bm_bits ? b->bm_bits -1 : 0;\n\t}\n\tfor (bitnr = s; bitnr <= e; bitnr++) {\n\t\tunsigned int page_nr = bm_bit_to_page_idx(b, bitnr);\n\t\tif (page_nr != last_page_nr) {\n\t\t\tif (p_addr)\n\t\t\t\t__bm_unmap(p_addr);\n\t\t\tif (c < 0)\n\t\t\t\tbm_set_page_lazy_writeout(b->bm_pages[last_page_nr]);\n\t\t\telse if (c > 0)\n\t\t\t\tbm_set_page_need_writeout(b->bm_pages[last_page_nr]);\n\t\t\tchanged_total += c;\n\t\t\tc = 0;\n\t\t\tp_addr = __bm_map_pidx(b, page_nr);\n\t\t\tlast_page_nr = page_nr;\n\t\t}\n\t\tif (val)\n\t\t\tc += (0 == __test_and_set_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr));\n\t\telse\n\t\t\tc -= (0 != __test_and_clear_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr));\n\t}\n\tif (p_addr)\n\t\t__bm_unmap(p_addr);\n\tif (c < 0)\n\t\tbm_set_page_lazy_writeout(b->bm_pages[last_page_nr]);\n\telse if (c > 0)\n\t\tbm_set_page_need_writeout(b->bm_pages[last_page_nr]);\n\tchanged_total += c;\n\tb->bm_set += changed_total;\n\treturn changed_total;\n}\n\n \nstatic int bm_change_bits_to(struct drbd_device *device, const unsigned long s,\n\tconst unsigned long e, int val)\n{\n\tunsigned long flags;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tint c = 0;\n\n\tif (!expect(device, b))\n\t\treturn 1;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&b->bm_lock, flags);\n\tif ((val ? BM_DONT_SET : BM_DONT_CLEAR) & b->bm_flags)\n\t\tbm_print_lock_info(device);\n\n\tc = __bm_change_bits_to(device, s, e, val);\n\n\tspin_unlock_irqrestore(&b->bm_lock, flags);\n\treturn c;\n}\n\n \nint drbd_bm_set_bits(struct drbd_device *device, const unsigned long s, const unsigned long e)\n{\n\treturn bm_change_bits_to(device, s, e, 1);\n}\n\n \nint drbd_bm_clear_bits(struct drbd_device *device, const unsigned long s, const unsigned long e)\n{\n\treturn -bm_change_bits_to(device, s, e, 0);\n}\n\n \nstatic inline void bm_set_full_words_within_one_page(struct drbd_bitmap *b,\n\t\tint page_nr, int first_word, int last_word)\n{\n\tint i;\n\tint bits;\n\tint changed = 0;\n\tunsigned long *paddr = kmap_atomic(b->bm_pages[page_nr]);\n\n\t \n\tfor (i = first_word; i < last_word; i++) {\n\t\tbits = hweight_long(paddr[i]);\n\t\tpaddr[i] = ~0UL;\n\t\tchanged += BITS_PER_LONG - bits;\n\t}\n\tkunmap_atomic(paddr);\n\tif (changed) {\n\t\t \n\t\tbm_set_page_lazy_writeout(b->bm_pages[page_nr]);\n\t\tb->bm_set += changed;\n\t}\n}\n\n \nvoid _drbd_bm_set_bits(struct drbd_device *device, const unsigned long s, const unsigned long e)\n{\n\t \n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long sl = ALIGN(s,BITS_PER_LONG);\n\tunsigned long el = (e+1) & ~((unsigned long)BITS_PER_LONG-1);\n\tint first_page;\n\tint last_page;\n\tint page_nr;\n\tint first_word;\n\tint last_word;\n\n\tif (e - s <= 3*BITS_PER_LONG) {\n\t\t \n\t\tspin_lock_irq(&b->bm_lock);\n\t\t__bm_change_bits_to(device, s, e, 1);\n\t\tspin_unlock_irq(&b->bm_lock);\n\t\treturn;\n\t}\n\n\t \n\n\tspin_lock_irq(&b->bm_lock);\n\n\t \n\tif (sl)\n\t\t__bm_change_bits_to(device, s, sl-1, 1);\n\n\tfirst_page = sl >> (3 + PAGE_SHIFT);\n\tlast_page = el >> (3 + PAGE_SHIFT);\n\n\t \n\t \n\tfirst_word = MLPP(sl >> LN2_BPL);\n\tlast_word = LWPP;\n\n\t \n\tfor (page_nr = first_page; page_nr < last_page; page_nr++) {\n\t\tbm_set_full_words_within_one_page(device->bitmap, page_nr, first_word, last_word);\n\t\tspin_unlock_irq(&b->bm_lock);\n\t\tcond_resched();\n\t\tfirst_word = 0;\n\t\tspin_lock_irq(&b->bm_lock);\n\t}\n\t \n\tlast_word = MLPP(el >> LN2_BPL);\n\n\t \n\tif (last_word)\n\t\tbm_set_full_words_within_one_page(device->bitmap, last_page, first_word, last_word);\n\n\t \n\tif (el <= e)\n\t\t__bm_change_bits_to(device, el, e, 1);\n\tspin_unlock_irq(&b->bm_lock);\n}\n\n \nint drbd_bm_test_bit(struct drbd_device *device, const unsigned long bitnr)\n{\n\tunsigned long flags;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr;\n\tint i;\n\n\tif (!expect(device, b))\n\t\treturn 0;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&b->bm_lock, flags);\n\tif (BM_DONT_TEST & b->bm_flags)\n\t\tbm_print_lock_info(device);\n\tif (bitnr < b->bm_bits) {\n\t\tp_addr = bm_map_pidx(b, bm_bit_to_page_idx(b, bitnr));\n\t\ti = test_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr) ? 1 : 0;\n\t\tbm_unmap(p_addr);\n\t} else if (bitnr == b->bm_bits) {\n\t\ti = -1;\n\t} else {  \n\t\tdrbd_err(device, \"bitnr=%lu > bm_bits=%lu\\n\", bitnr, b->bm_bits);\n\t\ti = 0;\n\t}\n\n\tspin_unlock_irqrestore(&b->bm_lock, flags);\n\treturn i;\n}\n\n \nint drbd_bm_count_bits(struct drbd_device *device, const unsigned long s, const unsigned long e)\n{\n\tunsigned long flags;\n\tstruct drbd_bitmap *b = device->bitmap;\n\tunsigned long *p_addr = NULL;\n\tunsigned long bitnr;\n\tunsigned int page_nr = -1U;\n\tint c = 0;\n\n\t \n\tif (!expect(device, b))\n\t\treturn 1;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 1;\n\n\tspin_lock_irqsave(&b->bm_lock, flags);\n\tif (BM_DONT_TEST & b->bm_flags)\n\t\tbm_print_lock_info(device);\n\tfor (bitnr = s; bitnr <= e; bitnr++) {\n\t\tunsigned int idx = bm_bit_to_page_idx(b, bitnr);\n\t\tif (page_nr != idx) {\n\t\t\tpage_nr = idx;\n\t\t\tif (p_addr)\n\t\t\t\tbm_unmap(p_addr);\n\t\t\tp_addr = bm_map_pidx(b, idx);\n\t\t}\n\t\tif (expect(device, bitnr < b->bm_bits))\n\t\t\tc += (0 != test_bit_le(bitnr - (page_nr << (PAGE_SHIFT+3)), p_addr));\n\t\telse\n\t\t\tdrbd_err(device, \"bitnr=%lu bm_bits=%lu\\n\", bitnr, b->bm_bits);\n\t}\n\tif (p_addr)\n\t\tbm_unmap(p_addr);\n\tspin_unlock_irqrestore(&b->bm_lock, flags);\n\treturn c;\n}\n\n\n \nint drbd_bm_e_weight(struct drbd_device *device, unsigned long enr)\n{\n\tstruct drbd_bitmap *b = device->bitmap;\n\tint count, s, e;\n\tunsigned long flags;\n\tunsigned long *p_addr, *bm;\n\n\tif (!expect(device, b))\n\t\treturn 0;\n\tif (!expect(device, b->bm_pages))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&b->bm_lock, flags);\n\tif (BM_DONT_TEST & b->bm_flags)\n\t\tbm_print_lock_info(device);\n\n\ts = S2W(enr);\n\te = min((size_t)S2W(enr+1), b->bm_words);\n\tcount = 0;\n\tif (s < b->bm_words) {\n\t\tint n = e-s;\n\t\tp_addr = bm_map_pidx(b, bm_word_to_page_idx(b, s));\n\t\tbm = p_addr + MLPP(s);\n\t\tcount += bitmap_weight(bm, n * BITS_PER_LONG);\n\t\tbm_unmap(p_addr);\n\t} else {\n\t\tdrbd_err(device, \"start offset (%d) too large in drbd_bm_e_weight\\n\", s);\n\t}\n\tspin_unlock_irqrestore(&b->bm_lock, flags);\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}