{
  "module_name": "drbd_receiver.c",
  "hash_id": "9e7b10b297ab7115fce582e24eae43ec8830a5fe0e31db91bf30e3b8bb7fdd4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_receiver.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n\n#include <linux/uaccess.h>\n#include <net/sock.h>\n\n#include <linux/drbd.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/in.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/mm_inline.h>\n#include <linux/slab.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/pkt_sched.h>\n#include <linux/unistd.h>\n#include <linux/vmalloc.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/scatterlist.h>\n#include <linux/part_stat.h>\n#include \"drbd_int.h\"\n#include \"drbd_protocol.h\"\n#include \"drbd_req.h\"\n#include \"drbd_vli.h\"\n\n#define PRO_FEATURES (DRBD_FF_TRIM|DRBD_FF_THIN_RESYNC|DRBD_FF_WSAME|DRBD_FF_WZEROES)\n\nstruct packet_info {\n\tenum drbd_packet cmd;\n\tunsigned int size;\n\tunsigned int vnr;\n\tvoid *data;\n};\n\nenum finish_epoch {\n\tFE_STILL_LIVE,\n\tFE_DESTROYED,\n\tFE_RECYCLED,\n};\n\nstatic int drbd_do_features(struct drbd_connection *connection);\nstatic int drbd_do_auth(struct drbd_connection *connection);\nstatic int drbd_disconnected(struct drbd_peer_device *);\nstatic void conn_wait_active_ee_empty(struct drbd_connection *connection);\nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_connection *, struct drbd_epoch *, enum epoch_event);\nstatic int e_end_block(struct drbd_work *, int);\n\n\n#define GFP_TRY\t(__GFP_HIGHMEM | __GFP_NOWARN)\n\n \n\n \nstatic struct page *page_chain_del(struct page **head, int n)\n{\n\tstruct page *page;\n\tstruct page *tmp;\n\n\tBUG_ON(!n);\n\tBUG_ON(!head);\n\n\tpage = *head;\n\n\tif (!page)\n\t\treturn NULL;\n\n\twhile (page) {\n\t\ttmp = page_chain_next(page);\n\t\tif (--n == 0)\n\t\t\tbreak;  \n\t\tif (tmp == NULL)\n\t\t\t \n\t\t\treturn NULL;\n\t\tpage = tmp;\n\t}\n\n\t \n\tset_page_private(page, 0);\n\t \n\tpage = *head;\n\t*head = tmp;\n\treturn page;\n}\n\n \nstatic struct page *page_chain_tail(struct page *page, int *len)\n{\n\tstruct page *tmp;\n\tint i = 1;\n\twhile ((tmp = page_chain_next(page))) {\n\t\t++i;\n\t\tpage = tmp;\n\t}\n\tif (len)\n\t\t*len = i;\n\treturn page;\n}\n\nstatic int page_chain_free(struct page *page)\n{\n\tstruct page *tmp;\n\tint i = 0;\n\tpage_chain_for_each_safe(page, tmp) {\n\t\tput_page(page);\n\t\t++i;\n\t}\n\treturn i;\n}\n\nstatic void page_chain_add(struct page **head,\n\t\tstruct page *chain_first, struct page *chain_last)\n{\n#if 1\n\tstruct page *tmp;\n\ttmp = page_chain_tail(chain_first, NULL);\n\tBUG_ON(tmp != chain_last);\n#endif\n\n\t \n\tset_page_private(chain_last, (unsigned long)*head);\n\t*head = chain_first;\n}\n\nstatic struct page *__drbd_alloc_pages(struct drbd_device *device,\n\t\t\t\t       unsigned int number)\n{\n\tstruct page *page = NULL;\n\tstruct page *tmp = NULL;\n\tunsigned int i = 0;\n\n\t \n\tif (drbd_pp_vacant >= number) {\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage = page_chain_del(&drbd_pp_pool, number);\n\t\tif (page)\n\t\t\tdrbd_pp_vacant -= number;\n\t\tspin_unlock(&drbd_pp_lock);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\t \n\tfor (i = 0; i < number; i++) {\n\t\ttmp = alloc_page(GFP_TRY);\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tset_page_private(tmp, (unsigned long)page);\n\t\tpage = tmp;\n\t}\n\n\tif (i == number)\n\t\treturn page;\n\n\t \n\tif (page) {\n\t\ttmp = page_chain_tail(page, NULL);\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage_chain_add(&drbd_pp_pool, page, tmp);\n\t\tdrbd_pp_vacant += i;\n\t\tspin_unlock(&drbd_pp_lock);\n\t}\n\treturn NULL;\n}\n\nstatic void reclaim_finished_net_peer_reqs(struct drbd_device *device,\n\t\t\t\t\t   struct list_head *to_be_freed)\n{\n\tstruct drbd_peer_request *peer_req, *tmp;\n\n\t \n\n\tlist_for_each_entry_safe(peer_req, tmp, &device->net_ee, w.list) {\n\t\tif (drbd_peer_req_has_active_page(peer_req))\n\t\t\tbreak;\n\t\tlist_move(&peer_req->w.list, to_be_freed);\n\t}\n}\n\nstatic void drbd_reclaim_net_peer_reqs(struct drbd_device *device)\n{\n\tLIST_HEAD(reclaimed);\n\tstruct drbd_peer_request *peer_req, *t;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treclaim_finished_net_peer_reqs(device, &reclaimed);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\n\t\tdrbd_free_net_peer_req(device, peer_req);\n}\n\nstatic void conn_reclaim_net_peer_reqs(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tif (!atomic_read(&device->pp_in_use_by_net))\n\t\t\tcontinue;\n\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\n \nstruct page *drbd_alloc_pages(struct drbd_peer_device *peer_device, unsigned int number,\n\t\t\t      bool retry)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct page *page = NULL;\n\tstruct net_conf *nc;\n\tDEFINE_WAIT(wait);\n\tunsigned int mxb;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\tmxb = nc ? nc->max_buffers : 1000000;\n\trcu_read_unlock();\n\n\tif (atomic_read(&device->pp_in_use) < mxb)\n\t\tpage = __drbd_alloc_pages(device, number);\n\n\t \n\tif (page && atomic_read(&device->pp_in_use_by_net) > 512)\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\n\twhile (page == NULL) {\n\t\tprepare_to_wait(&drbd_pp_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\n\t\tif (atomic_read(&device->pp_in_use) < mxb) {\n\t\t\tpage = __drbd_alloc_pages(device, number);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!retry)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\tdrbd_warn(device, \"drbd_alloc_pages interrupted!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (schedule_timeout(HZ/10) == 0)\n\t\t\tmxb = UINT_MAX;\n\t}\n\tfinish_wait(&drbd_pp_wait, &wait);\n\n\tif (page)\n\t\tatomic_add(number, &device->pp_in_use);\n\treturn page;\n}\n\n \nstatic void drbd_free_pages(struct drbd_device *device, struct page *page, int is_net)\n{\n\tatomic_t *a = is_net ? &device->pp_in_use_by_net : &device->pp_in_use;\n\tint i;\n\n\tif (page == NULL)\n\t\treturn;\n\n\tif (drbd_pp_vacant > (DRBD_MAX_BIO_SIZE/PAGE_SIZE) * drbd_minor_count)\n\t\ti = page_chain_free(page);\n\telse {\n\t\tstruct page *tmp;\n\t\ttmp = page_chain_tail(page, &i);\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage_chain_add(&drbd_pp_pool, page, tmp);\n\t\tdrbd_pp_vacant += i;\n\t\tspin_unlock(&drbd_pp_lock);\n\t}\n\ti = atomic_sub_return(i, a);\n\tif (i < 0)\n\t\tdrbd_warn(device, \"ASSERTION FAILED: %s: %d < 0\\n\",\n\t\t\tis_net ? \"pp_in_use_by_net\" : \"pp_in_use\", i);\n\twake_up(&drbd_pp_wait);\n}\n\n \n\n \nstruct drbd_peer_request *\ndrbd_alloc_peer_req(struct drbd_peer_device *peer_device, u64 id, sector_t sector,\n\t\t    unsigned int request_size, unsigned int payload_size, gfp_t gfp_mask) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_peer_request *peer_req;\n\tstruct page *page = NULL;\n\tunsigned int nr_pages = PFN_UP(payload_size);\n\n\tif (drbd_insert_fault(device, DRBD_FAULT_AL_EE))\n\t\treturn NULL;\n\n\tpeer_req = mempool_alloc(&drbd_ee_mempool, gfp_mask & ~__GFP_HIGHMEM);\n\tif (!peer_req) {\n\t\tif (!(gfp_mask & __GFP_NOWARN))\n\t\t\tdrbd_err(device, \"%s: allocation failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (nr_pages) {\n\t\tpage = drbd_alloc_pages(peer_device, nr_pages,\n\t\t\t\t\tgfpflags_allow_blocking(gfp_mask));\n\t\tif (!page)\n\t\t\tgoto fail;\n\t}\n\n\tmemset(peer_req, 0, sizeof(*peer_req));\n\tINIT_LIST_HEAD(&peer_req->w.list);\n\tdrbd_clear_interval(&peer_req->i);\n\tpeer_req->i.size = request_size;\n\tpeer_req->i.sector = sector;\n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->peer_device = peer_device;\n\tpeer_req->pages = page;\n\t \n\tpeer_req->block_id = id;\n\n\treturn peer_req;\n\n fail:\n\tmempool_free(peer_req, &drbd_ee_mempool);\n\treturn NULL;\n}\n\nvoid __drbd_free_peer_req(struct drbd_device *device, struct drbd_peer_request *peer_req,\n\t\t       int is_net)\n{\n\tmight_sleep();\n\tif (peer_req->flags & EE_HAS_DIGEST)\n\t\tkfree(peer_req->digest);\n\tdrbd_free_pages(device, peer_req->pages, is_net);\n\tD_ASSERT(device, atomic_read(&peer_req->pending_bios) == 0);\n\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\tif (!expect(device, !(peer_req->flags & EE_CALL_AL_COMPLETE_IO))) {\n\t\tpeer_req->flags &= ~EE_CALL_AL_COMPLETE_IO;\n\t\tdrbd_al_complete_io(device, &peer_req->i);\n\t}\n\tmempool_free(peer_req, &drbd_ee_mempool);\n}\n\nint drbd_free_peer_reqs(struct drbd_device *device, struct list_head *list)\n{\n\tLIST_HEAD(work_list);\n\tstruct drbd_peer_request *peer_req, *t;\n\tint count = 0;\n\tint is_net = list == &device->net_ee;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_splice_init(list, &work_list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\n\t\t__drbd_free_peer_req(device, peer_req, is_net);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n \nstatic int drbd_finish_peer_reqs(struct drbd_device *device)\n{\n\tLIST_HEAD(work_list);\n\tLIST_HEAD(reclaimed);\n\tstruct drbd_peer_request *peer_req, *t;\n\tint err = 0;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treclaim_finished_net_peer_reqs(device, &reclaimed);\n\tlist_splice_init(&device->done_ee, &work_list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\n\t\tdrbd_free_net_peer_req(device, peer_req);\n\n\t \n\tlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\n\t\tint err2;\n\n\t\t \n\t\terr2 = peer_req->w.cb(&peer_req->w, !!err);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tdrbd_free_peer_req(device, peer_req);\n\t}\n\twake_up(&device->ee_wait);\n\n\treturn err;\n}\n\nstatic void _drbd_wait_ee_list_empty(struct drbd_device *device,\n\t\t\t\t     struct list_head *head)\n{\n\tDEFINE_WAIT(wait);\n\n\t \n\twhile (!list_empty(head)) {\n\t\tprepare_to_wait(&device->ee_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tio_schedule();\n\t\tfinish_wait(&device->ee_wait, &wait);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t}\n}\n\nstatic void drbd_wait_ee_list_empty(struct drbd_device *device,\n\t\t\t\t    struct list_head *head)\n{\n\tspin_lock_irq(&device->resource->req_lock);\n\t_drbd_wait_ee_list_empty(device, head);\n\tspin_unlock_irq(&device->resource->req_lock);\n}\n\nstatic int drbd_recv_short(struct socket *sock, void *buf, size_t size, int flags)\n{\n\tstruct kvec iov = {\n\t\t.iov_base = buf,\n\t\t.iov_len = size,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_flags = (flags ? flags : MSG_WAITALL | MSG_NOSIGNAL)\n\t};\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, size);\n\treturn sock_recvmsg(sock, &msg, msg.msg_flags);\n}\n\nstatic int drbd_recv(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint rv;\n\n\trv = drbd_recv_short(connection->data.socket, buf, size, 0);\n\n\tif (rv < 0) {\n\t\tif (rv == -ECONNRESET)\n\t\t\tdrbd_info(connection, \"sock was reset by peer\\n\");\n\t\telse if (rv != -ERESTARTSYS)\n\t\t\tdrbd_err(connection, \"sock_recvmsg returned %d\\n\", rv);\n\t} else if (rv == 0) {\n\t\tif (test_bit(DISCONNECT_SENT, &connection->flags)) {\n\t\t\tlong t;\n\t\t\trcu_read_lock();\n\t\t\tt = rcu_dereference(connection->net_conf)->ping_timeo * HZ/10;\n\t\t\trcu_read_unlock();\n\n\t\t\tt = wait_event_timeout(connection->ping_wait, connection->cstate < C_WF_REPORT_PARAMS, t);\n\n\t\t\tif (t)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdrbd_info(connection, \"sock was shut down by peer\\n\");\n\t}\n\n\tif (rv != size)\n\t\tconn_request_state(connection, NS(conn, C_BROKEN_PIPE), CS_HARD);\n\nout:\n\treturn rv;\n}\n\nstatic int drbd_recv_all(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint err;\n\n\terr = drbd_recv(connection, buf, size);\n\tif (err != size) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t} else\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int drbd_recv_all_warn(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint err;\n\n\terr = drbd_recv_all(connection, buf, size);\n\tif (err && !signal_pending(current))\n\t\tdrbd_warn(connection, \"short read (expected size %d)\\n\", (int)size);\n\treturn err;\n}\n\n \nstatic void drbd_setbufsize(struct socket *sock, unsigned int snd,\n\t\tunsigned int rcv)\n{\n\t \n\tif (snd) {\n\t\tsock->sk->sk_sndbuf = snd;\n\t\tsock->sk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t}\n\tif (rcv) {\n\t\tsock->sk->sk_rcvbuf = rcv;\n\t\tsock->sk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t}\n}\n\nstatic struct socket *drbd_try_connect(struct drbd_connection *connection)\n{\n\tconst char *what;\n\tstruct socket *sock;\n\tstruct sockaddr_in6 src_in6;\n\tstruct sockaddr_in6 peer_in6;\n\tstruct net_conf *nc;\n\tint err, peer_addr_len, my_addr_len;\n\tint sndbuf_size, rcvbuf_size, connect_int;\n\tint disconnect_on_error = 1;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tsndbuf_size = nc->sndbuf_size;\n\trcvbuf_size = nc->rcvbuf_size;\n\tconnect_int = nc->connect_int;\n\trcu_read_unlock();\n\n\tmy_addr_len = min_t(int, connection->my_addr_len, sizeof(src_in6));\n\tmemcpy(&src_in6, &connection->my_addr, my_addr_len);\n\n\tif (((struct sockaddr *)&connection->my_addr)->sa_family == AF_INET6)\n\t\tsrc_in6.sin6_port = 0;\n\telse\n\t\t((struct sockaddr_in *)&src_in6)->sin_port = 0;  \n\n\tpeer_addr_len = min_t(int, connection->peer_addr_len, sizeof(src_in6));\n\tmemcpy(&peer_in6, &connection->peer_addr, peer_addr_len);\n\n\twhat = \"sock_create_kern\";\n\terr = sock_create_kern(&init_net, ((struct sockaddr *)&src_in6)->sa_family,\n\t\t\t       SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (err < 0) {\n\t\tsock = NULL;\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_rcvtimeo =\n\tsock->sk->sk_sndtimeo = connect_int * HZ;\n\tdrbd_setbufsize(sock, sndbuf_size, rcvbuf_size);\n\n        \n\twhat = \"bind before connect\";\n\terr = sock->ops->bind(sock, (struct sockaddr *) &src_in6, my_addr_len);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tdisconnect_on_error = 0;\n\twhat = \"connect\";\n\terr = sock->ops->connect(sock, (struct sockaddr *) &peer_in6, peer_addr_len, 0);\n\nout:\n\tif (err < 0) {\n\t\tif (sock) {\n\t\t\tsock_release(sock);\n\t\t\tsock = NULL;\n\t\t}\n\t\tswitch (-err) {\n\t\t\t \n\t\tcase ETIMEDOUT: case EAGAIN: case EINPROGRESS:\n\t\tcase EINTR: case ERESTARTSYS:\n\t\t\t \n\t\tcase ECONNREFUSED: case ENETUNREACH:\n\t\tcase EHOSTDOWN:    case EHOSTUNREACH:\n\t\t\tdisconnect_on_error = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrbd_err(connection, \"%s failed, err = %d\\n\", what, err);\n\t\t}\n\t\tif (disconnect_on_error)\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t}\n\n\treturn sock;\n}\n\nstruct accept_wait_data {\n\tstruct drbd_connection *connection;\n\tstruct socket *s_listen;\n\tstruct completion door_bell;\n\tvoid (*original_sk_state_change)(struct sock *sk);\n\n};\n\nstatic void drbd_incoming_connection(struct sock *sk)\n{\n\tstruct accept_wait_data *ad = sk->sk_user_data;\n\tvoid (*state_change)(struct sock *sk);\n\n\tstate_change = ad->original_sk_state_change;\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tcomplete(&ad->door_bell);\n\tstate_change(sk);\n}\n\nstatic int prepare_listen_socket(struct drbd_connection *connection, struct accept_wait_data *ad)\n{\n\tint err, sndbuf_size, rcvbuf_size, my_addr_len;\n\tstruct sockaddr_in6 my_addr;\n\tstruct socket *s_listen;\n\tstruct net_conf *nc;\n\tconst char *what;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EIO;\n\t}\n\tsndbuf_size = nc->sndbuf_size;\n\trcvbuf_size = nc->rcvbuf_size;\n\trcu_read_unlock();\n\n\tmy_addr_len = min_t(int, connection->my_addr_len, sizeof(struct sockaddr_in6));\n\tmemcpy(&my_addr, &connection->my_addr, my_addr_len);\n\n\twhat = \"sock_create_kern\";\n\terr = sock_create_kern(&init_net, ((struct sockaddr *)&my_addr)->sa_family,\n\t\t\t       SOCK_STREAM, IPPROTO_TCP, &s_listen);\n\tif (err) {\n\t\ts_listen = NULL;\n\t\tgoto out;\n\t}\n\n\ts_listen->sk->sk_reuse = SK_CAN_REUSE;  \n\tdrbd_setbufsize(s_listen, sndbuf_size, rcvbuf_size);\n\n\twhat = \"bind before listen\";\n\terr = s_listen->ops->bind(s_listen, (struct sockaddr *)&my_addr, my_addr_len);\n\tif (err < 0)\n\t\tgoto out;\n\n\tad->s_listen = s_listen;\n\twrite_lock_bh(&s_listen->sk->sk_callback_lock);\n\tad->original_sk_state_change = s_listen->sk->sk_state_change;\n\ts_listen->sk->sk_state_change = drbd_incoming_connection;\n\ts_listen->sk->sk_user_data = ad;\n\twrite_unlock_bh(&s_listen->sk->sk_callback_lock);\n\n\twhat = \"listen\";\n\terr = s_listen->ops->listen(s_listen, 5);\n\tif (err < 0)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (s_listen)\n\t\tsock_release(s_listen);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\n\t\t\tdrbd_err(connection, \"%s failed, err = %d\\n\", what, err);\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic void unregister_state_change(struct sock *sk, struct accept_wait_data *ad)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_state_change = ad->original_sk_state_change;\n\tsk->sk_user_data = NULL;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic struct socket *drbd_wait_for_connect(struct drbd_connection *connection, struct accept_wait_data *ad)\n{\n\tint timeo, connect_int, err = 0;\n\tstruct socket *s_estab = NULL;\n\tstruct net_conf *nc;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tconnect_int = nc->connect_int;\n\trcu_read_unlock();\n\n\ttimeo = connect_int * HZ;\n\t \n\ttimeo += get_random_u32_below(2) ? timeo / 7 : -timeo / 7;\n\n\terr = wait_for_completion_interruptible_timeout(&ad->door_bell, timeo);\n\tif (err <= 0)\n\t\treturn NULL;\n\n\terr = kernel_accept(ad->s_listen, &s_estab, 0);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\n\t\t\tdrbd_err(connection, \"accept failed, err = %d\\n\", err);\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t}\n\n\tif (s_estab)\n\t\tunregister_state_change(s_estab->sk, ad);\n\n\treturn s_estab;\n}\n\nstatic int decode_header(struct drbd_connection *, void *, struct packet_info *);\n\nstatic int send_first_packet(struct drbd_connection *connection, struct drbd_socket *sock,\n\t\t\t     enum drbd_packet cmd)\n{\n\tif (!conn_prepare_command(connection, sock))\n\t\treturn -EIO;\n\treturn conn_send_command(connection, sock, cmd, 0, NULL, 0);\n}\n\nstatic int receive_first_packet(struct drbd_connection *connection, struct socket *sock)\n{\n\tunsigned int header_size = drbd_header_size(connection);\n\tstruct packet_info pi;\n\tstruct net_conf *nc;\n\tint err;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EIO;\n\t}\n\tsock->sk->sk_rcvtimeo = nc->ping_timeo * 4 * HZ / 10;\n\trcu_read_unlock();\n\n\terr = drbd_recv_short(sock, connection->data.rbuf, header_size, 0);\n\tif (err != header_size) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\terr = decode_header(connection, connection->data.rbuf, &pi);\n\tif (err)\n\t\treturn err;\n\treturn pi.cmd;\n}\n\n \nstatic bool drbd_socket_okay(struct socket **sock)\n{\n\tint rr;\n\tchar tb[4];\n\n\tif (!*sock)\n\t\treturn false;\n\n\trr = drbd_recv_short(*sock, tb, 4, MSG_DONTWAIT | MSG_PEEK);\n\n\tif (rr > 0 || rr == -EAGAIN) {\n\t\treturn true;\n\t} else {\n\t\tsock_release(*sock);\n\t\t*sock = NULL;\n\t\treturn false;\n\t}\n}\n\nstatic bool connection_established(struct drbd_connection *connection,\n\t\t\t\t   struct socket **sock1,\n\t\t\t\t   struct socket **sock2)\n{\n\tstruct net_conf *nc;\n\tint timeout;\n\tbool ok;\n\n\tif (!*sock1 || !*sock2)\n\t\treturn false;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\ttimeout = (nc->sock_check_timeo ?: nc->ping_timeo) * HZ / 10;\n\trcu_read_unlock();\n\tschedule_timeout_interruptible(timeout);\n\n\tok = drbd_socket_okay(sock1);\n\tok = drbd_socket_okay(sock2) && ok;\n\n\treturn ok;\n}\n\n \nint drbd_connected(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint err;\n\n\tatomic_set(&device->packet_seq, 0);\n\tdevice->peer_seq = 0;\n\n\tdevice->state_mutex = peer_device->connection->agreed_pro_version < 100 ?\n\t\t&peer_device->connection->cstate_mutex :\n\t\t&device->own_state_mutex;\n\n\terr = drbd_send_sync_param(peer_device);\n\tif (!err)\n\t\terr = drbd_send_sizes(peer_device, 0, 0);\n\tif (!err)\n\t\terr = drbd_send_uuids(peer_device);\n\tif (!err)\n\t\terr = drbd_send_current_state(peer_device);\n\tclear_bit(USE_DEGR_WFC_T, &device->flags);\n\tclear_bit(RESIZE_PENDING, &device->flags);\n\tatomic_set(&device->ap_in_flight, 0);\n\tmod_timer(&device->request_timer, jiffies + HZ);  \n\treturn err;\n}\n\n \nstatic int conn_connect(struct drbd_connection *connection)\n{\n\tstruct drbd_socket sock, msock;\n\tstruct drbd_peer_device *peer_device;\n\tstruct net_conf *nc;\n\tint vnr, timeout, h;\n\tbool discard_my_data, ok;\n\tenum drbd_state_rv rv;\n\tstruct accept_wait_data ad = {\n\t\t.connection = connection,\n\t\t.door_bell = COMPLETION_INITIALIZER_ONSTACK(ad.door_bell),\n\t};\n\n\tclear_bit(DISCONNECT_SENT, &connection->flags);\n\tif (conn_request_state(connection, NS(conn, C_WF_CONNECTION), CS_VERBOSE) < SS_SUCCESS)\n\t\treturn -2;\n\n\tmutex_init(&sock.mutex);\n\tsock.sbuf = connection->data.sbuf;\n\tsock.rbuf = connection->data.rbuf;\n\tsock.socket = NULL;\n\tmutex_init(&msock.mutex);\n\tmsock.sbuf = connection->meta.sbuf;\n\tmsock.rbuf = connection->meta.rbuf;\n\tmsock.socket = NULL;\n\n\t \n\tconnection->agreed_pro_version = 80;\n\n\tif (prepare_listen_socket(connection, &ad))\n\t\treturn 0;\n\n\tdo {\n\t\tstruct socket *s;\n\n\t\ts = drbd_try_connect(connection);\n\t\tif (s) {\n\t\t\tif (!sock.socket) {\n\t\t\t\tsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &sock, P_INITIAL_DATA);\n\t\t\t} else if (!msock.socket) {\n\t\t\t\tclear_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\t\tmsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &msock, P_INITIAL_META);\n\t\t\t} else {\n\t\t\t\tdrbd_err(connection, \"Logic error in conn_connect()\\n\");\n\t\t\t\tgoto out_release_sockets;\n\t\t\t}\n\t\t}\n\n\t\tif (connection_established(connection, &sock.socket, &msock.socket))\n\t\t\tbreak;\n\nretry:\n\t\ts = drbd_wait_for_connect(connection, &ad);\n\t\tif (s) {\n\t\t\tint fp = receive_first_packet(connection, s);\n\t\t\tdrbd_socket_okay(&sock.socket);\n\t\t\tdrbd_socket_okay(&msock.socket);\n\t\t\tswitch (fp) {\n\t\t\tcase P_INITIAL_DATA:\n\t\t\t\tif (sock.socket) {\n\t\t\t\t\tdrbd_warn(connection, \"initial packet S crossed\\n\");\n\t\t\t\t\tsock_release(sock.socket);\n\t\t\t\t\tsock.socket = s;\n\t\t\t\t\tgoto randomize;\n\t\t\t\t}\n\t\t\t\tsock.socket = s;\n\t\t\t\tbreak;\n\t\t\tcase P_INITIAL_META:\n\t\t\t\tset_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\t\tif (msock.socket) {\n\t\t\t\t\tdrbd_warn(connection, \"initial packet M crossed\\n\");\n\t\t\t\t\tsock_release(msock.socket);\n\t\t\t\t\tmsock.socket = s;\n\t\t\t\t\tgoto randomize;\n\t\t\t\t}\n\t\t\t\tmsock.socket = s;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdrbd_warn(connection, \"Error receiving initial packet\\n\");\n\t\t\t\tsock_release(s);\nrandomize:\n\t\t\t\tif (get_random_u32_below(2))\n\t\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tif (connection->cstate <= C_DISCONNECTING)\n\t\t\tgoto out_release_sockets;\n\t\tif (signal_pending(current)) {\n\t\t\tflush_signals(current);\n\t\t\tsmp_rmb();\n\t\t\tif (get_t_state(&connection->receiver) == EXITING)\n\t\t\t\tgoto out_release_sockets;\n\t\t}\n\n\t\tok = connection_established(connection, &sock.socket, &msock.socket);\n\t} while (!ok);\n\n\tif (ad.s_listen)\n\t\tsock_release(ad.s_listen);\n\n\tsock.socket->sk->sk_reuse = SK_CAN_REUSE;  \n\tmsock.socket->sk->sk_reuse = SK_CAN_REUSE;  \n\n\tsock.socket->sk->sk_allocation = GFP_NOIO;\n\tmsock.socket->sk->sk_allocation = GFP_NOIO;\n\n\tsock.socket->sk->sk_use_task_frag = false;\n\tmsock.socket->sk->sk_use_task_frag = false;\n\n\tsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE_BULK;\n\tmsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE;\n\n\t \n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\n\tsock.socket->sk->sk_sndtimeo =\n\tsock.socket->sk->sk_rcvtimeo = nc->ping_timeo*4*HZ/10;\n\n\tmsock.socket->sk->sk_rcvtimeo = nc->ping_int*HZ;\n\ttimeout = nc->timeout * HZ / 10;\n\tdiscard_my_data = nc->discard_my_data;\n\trcu_read_unlock();\n\n\tmsock.socket->sk->sk_sndtimeo = timeout;\n\n\t \n\ttcp_sock_set_nodelay(sock.socket->sk);\n\ttcp_sock_set_nodelay(msock.socket->sk);\n\n\tconnection->data.socket = sock.socket;\n\tconnection->meta.socket = msock.socket;\n\tconnection->last_received = jiffies;\n\n\th = drbd_do_features(connection);\n\tif (h <= 0)\n\t\treturn h;\n\n\tif (connection->cram_hmac_tfm) {\n\t\t \n\t\tswitch (drbd_do_auth(connection)) {\n\t\tcase -1:\n\t\t\tdrbd_err(connection, \"Authentication of peer failed\\n\");\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tdrbd_err(connection, \"Authentication of peer failed, trying again.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tconnection->data.socket->sk->sk_sndtimeo = timeout;\n\tconnection->data.socket->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\n\n\tif (drbd_send_protocol(connection) == -EOPNOTSUPP)\n\t\treturn -1;\n\n\t \n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\tmutex_lock(peer_device->device->state_mutex);\n\n\t \n\tspin_lock_irq(&connection->resource->req_lock);\n\tset_bit(STATE_SENT, &connection->flags);\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\tmutex_unlock(peer_device->device->state_mutex);\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\n\t\tif (discard_my_data)\n\t\t\tset_bit(DISCARD_MY_DATA, &device->flags);\n\t\telse\n\t\t\tclear_bit(DISCARD_MY_DATA, &device->flags);\n\n\t\tdrbd_connected(peer_device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\trv = conn_request_state(connection, NS(conn, C_WF_REPORT_PARAMS), CS_VERBOSE);\n\tif (rv < SS_SUCCESS || connection->cstate != C_WF_REPORT_PARAMS) {\n\t\tclear_bit(STATE_SENT, &connection->flags);\n\t\treturn 0;\n\t}\n\n\tdrbd_thread_start(&connection->ack_receiver);\n\t \n\tconnection->ack_sender =\n\t\talloc_ordered_workqueue(\"drbd_as_%s\", WQ_MEM_RECLAIM, connection->resource->name);\n\tif (!connection->ack_sender) {\n\t\tdrbd_err(connection, \"Failed to create workqueue ack_sender\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&connection->resource->conf_update);\n\t \n\tconnection->net_conf->discard_my_data = 0;\n\tmutex_unlock(&connection->resource->conf_update);\n\n\treturn h;\n\nout_release_sockets:\n\tif (ad.s_listen)\n\t\tsock_release(ad.s_listen);\n\tif (sock.socket)\n\t\tsock_release(sock.socket);\n\tif (msock.socket)\n\t\tsock_release(msock.socket);\n\treturn -1;\n}\n\nstatic int decode_header(struct drbd_connection *connection, void *header, struct packet_info *pi)\n{\n\tunsigned int header_size = drbd_header_size(connection);\n\n\tif (header_size == sizeof(struct p_header100) &&\n\t    *(__be32 *)header == cpu_to_be32(DRBD_MAGIC_100)) {\n\t\tstruct p_header100 *h = header;\n\t\tif (h->pad != 0) {\n\t\t\tdrbd_err(connection, \"Header padding is not zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpi->vnr = be16_to_cpu(h->volume);\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be32_to_cpu(h->length);\n\t} else if (header_size == sizeof(struct p_header95) &&\n\t\t   *(__be16 *)header == cpu_to_be16(DRBD_MAGIC_BIG)) {\n\t\tstruct p_header95 *h = header;\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be32_to_cpu(h->length);\n\t\tpi->vnr = 0;\n\t} else if (header_size == sizeof(struct p_header80) &&\n\t\t   *(__be32 *)header == cpu_to_be32(DRBD_MAGIC)) {\n\t\tstruct p_header80 *h = header;\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be16_to_cpu(h->length);\n\t\tpi->vnr = 0;\n\t} else {\n\t\tdrbd_err(connection, \"Wrong magic value 0x%08x in protocol version %d\\n\",\n\t\t\t be32_to_cpu(*(__be32 *)header),\n\t\t\t connection->agreed_pro_version);\n\t\treturn -EINVAL;\n\t}\n\tpi->data = header + header_size;\n\treturn 0;\n}\n\nstatic void drbd_unplug_all_devices(struct drbd_connection *connection)\n{\n\tif (current->plug == &connection->receiver_plug) {\n\t\tblk_finish_plug(&connection->receiver_plug);\n\t\tblk_start_plug(&connection->receiver_plug);\n\t}  \n}\n\nstatic int drbd_recv_header(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tint err;\n\n\terr = drbd_recv_all_warn(connection, buffer, drbd_header_size(connection));\n\tif (err)\n\t\treturn err;\n\n\terr = decode_header(connection, buffer, pi);\n\tconnection->last_received = jiffies;\n\n\treturn err;\n}\n\nstatic int drbd_recv_header_maybe_unplug(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tunsigned int size = drbd_header_size(connection);\n\tint err;\n\n\terr = drbd_recv_short(connection->data.socket, buffer, size, MSG_NOSIGNAL|MSG_DONTWAIT);\n\tif (err != size) {\n\t\t \n\t\tif (err == -EAGAIN) {\n\t\t\ttcp_sock_set_quickack(connection->data.socket->sk, 2);\n\t\t\tdrbd_unplug_all_devices(connection);\n\t\t}\n\t\tif (err > 0) {\n\t\t\tbuffer += err;\n\t\t\tsize -= err;\n\t\t}\n\t\terr = drbd_recv_all_warn(connection, buffer, size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = decode_header(connection, connection->data.rbuf, pi);\n\tconnection->last_received = jiffies;\n\n\treturn err;\n}\n \nstruct issue_flush_context {\n\tatomic_t pending;\n\tint error;\n\tstruct completion done;\n};\nstruct one_flush_context {\n\tstruct drbd_device *device;\n\tstruct issue_flush_context *ctx;\n};\n\nstatic void one_flush_endio(struct bio *bio)\n{\n\tstruct one_flush_context *octx = bio->bi_private;\n\tstruct drbd_device *device = octx->device;\n\tstruct issue_flush_context *ctx = octx->ctx;\n\n\tif (bio->bi_status) {\n\t\tctx->error = blk_status_to_errno(bio->bi_status);\n\t\tdrbd_info(device, \"local disk FLUSH FAILED with status %d\\n\", bio->bi_status);\n\t}\n\tkfree(octx);\n\tbio_put(bio);\n\n\tclear_bit(FLUSH_PENDING, &device->flags);\n\tput_ldev(device);\n\tkref_put(&device->kref, drbd_destroy_device);\n\n\tif (atomic_dec_and_test(&ctx->pending))\n\t\tcomplete(&ctx->done);\n}\n\nstatic void submit_one_flush(struct drbd_device *device, struct issue_flush_context *ctx)\n{\n\tstruct bio *bio = bio_alloc(device->ldev->backing_bdev, 0,\n\t\t\t\t    REQ_OP_WRITE | REQ_PREFLUSH, GFP_NOIO);\n\tstruct one_flush_context *octx = kmalloc(sizeof(*octx), GFP_NOIO);\n\n\tif (!octx) {\n\t\tdrbd_warn(device, \"Could not allocate a octx, CANNOT ISSUE FLUSH\\n\");\n\t\t \n\t\tbio_put(bio);\n\n\t\tctx->error = -ENOMEM;\n\t\tput_ldev(device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\treturn;\n\t}\n\n\toctx->device = device;\n\toctx->ctx = ctx;\n\tbio->bi_private = octx;\n\tbio->bi_end_io = one_flush_endio;\n\n\tdevice->flush_jif = jiffies;\n\tset_bit(FLUSH_PENDING, &device->flags);\n\tatomic_inc(&ctx->pending);\n\tsubmit_bio(bio);\n}\n\nstatic void drbd_flush(struct drbd_connection *connection)\n{\n\tif (connection->resource->write_ordering >= WO_BDEV_FLUSH) {\n\t\tstruct drbd_peer_device *peer_device;\n\t\tstruct issue_flush_context ctx;\n\t\tint vnr;\n\n\t\tatomic_set(&ctx.pending, 1);\n\t\tctx.error = 0;\n\t\tinit_completion(&ctx.done);\n\n\t\trcu_read_lock();\n\t\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\t\tstruct drbd_device *device = peer_device->device;\n\n\t\t\tif (!get_ldev(device))\n\t\t\t\tcontinue;\n\t\t\tkref_get(&device->kref);\n\t\t\trcu_read_unlock();\n\n\t\t\tsubmit_one_flush(device, &ctx);\n\n\t\t\trcu_read_lock();\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (!atomic_dec_and_test(&ctx.pending))\n\t\t\twait_for_completion(&ctx.done);\n\n\t\tif (ctx.error) {\n\t\t\t \n\t\t\t \n\t\t\tdrbd_bump_write_ordering(connection->resource, NULL, WO_DRAIN_IO);\n\t\t}\n\t}\n}\n\n \nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_connection *connection,\n\t\t\t\t\t       struct drbd_epoch *epoch,\n\t\t\t\t\t       enum epoch_event ev)\n{\n\tint epoch_size;\n\tstruct drbd_epoch *next_epoch;\n\tenum finish_epoch rv = FE_STILL_LIVE;\n\n\tspin_lock(&connection->epoch_lock);\n\tdo {\n\t\tnext_epoch = NULL;\n\n\t\tepoch_size = atomic_read(&epoch->epoch_size);\n\n\t\tswitch (ev & ~EV_CLEANUP) {\n\t\tcase EV_PUT:\n\t\t\tatomic_dec(&epoch->active);\n\t\t\tbreak;\n\t\tcase EV_GOT_BARRIER_NR:\n\t\t\tset_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags);\n\t\t\tbreak;\n\t\tcase EV_BECAME_LAST:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (epoch_size != 0 &&\n\t\t    atomic_read(&epoch->active) == 0 &&\n\t\t    (test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags) || ev & EV_CLEANUP)) {\n\t\t\tif (!(ev & EV_CLEANUP)) {\n\t\t\t\tspin_unlock(&connection->epoch_lock);\n\t\t\t\tdrbd_send_b_ack(epoch->connection, epoch->barrier_nr, epoch_size);\n\t\t\t\tspin_lock(&connection->epoch_lock);\n\t\t\t}\n#if 0\n\t\t\t \n\t\t\tif (test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags))\n\t\t\t\tdec_unacked(epoch->connection);\n#endif\n\n\t\t\tif (connection->current_epoch != epoch) {\n\t\t\t\tnext_epoch = list_entry(epoch->list.next, struct drbd_epoch, list);\n\t\t\t\tlist_del(&epoch->list);\n\t\t\t\tev = EV_BECAME_LAST | (ev & EV_CLEANUP);\n\t\t\t\tconnection->epochs--;\n\t\t\t\tkfree(epoch);\n\n\t\t\t\tif (rv == FE_STILL_LIVE)\n\t\t\t\t\trv = FE_DESTROYED;\n\t\t\t} else {\n\t\t\t\tepoch->flags = 0;\n\t\t\t\tatomic_set(&epoch->epoch_size, 0);\n\t\t\t\t \n\t\t\t\tif (rv == FE_STILL_LIVE)\n\t\t\t\t\trv = FE_RECYCLED;\n\t\t\t}\n\t\t}\n\n\t\tif (!next_epoch)\n\t\t\tbreak;\n\n\t\tepoch = next_epoch;\n\t} while (1);\n\n\tspin_unlock(&connection->epoch_lock);\n\n\treturn rv;\n}\n\nstatic enum write_ordering_e\nmax_allowed_wo(struct drbd_backing_dev *bdev, enum write_ordering_e wo)\n{\n\tstruct disk_conf *dc;\n\n\tdc = rcu_dereference(bdev->disk_conf);\n\n\tif (wo == WO_BDEV_FLUSH && !dc->disk_flushes)\n\t\two = WO_DRAIN_IO;\n\tif (wo == WO_DRAIN_IO && !dc->disk_drain)\n\t\two = WO_NONE;\n\n\treturn wo;\n}\n\n \nvoid drbd_bump_write_ordering(struct drbd_resource *resource, struct drbd_backing_dev *bdev,\n\t\t\t      enum write_ordering_e wo)\n{\n\tstruct drbd_device *device;\n\tenum write_ordering_e pwo;\n\tint vnr;\n\tstatic char *write_ordering_str[] = {\n\t\t[WO_NONE] = \"none\",\n\t\t[WO_DRAIN_IO] = \"drain\",\n\t\t[WO_BDEV_FLUSH] = \"flush\",\n\t};\n\n\tpwo = resource->write_ordering;\n\tif (wo != WO_BDEV_FLUSH)\n\t\two = min(pwo, wo);\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, vnr) {\n\t\tif (get_ldev(device)) {\n\t\t\two = max_allowed_wo(device->ldev, wo);\n\t\t\tif (device->ldev == bdev)\n\t\t\t\tbdev = NULL;\n\t\t\tput_ldev(device);\n\t\t}\n\t}\n\n\tif (bdev)\n\t\two = max_allowed_wo(bdev, wo);\n\n\trcu_read_unlock();\n\n\tresource->write_ordering = wo;\n\tif (pwo != resource->write_ordering || wo == WO_BDEV_FLUSH)\n\t\tdrbd_info(resource, \"Method to ensure write ordering: %s\\n\", write_ordering_str[resource->write_ordering]);\n}\n\n \n \nint drbd_issue_discard_or_zero_out(struct drbd_device *device, sector_t start, unsigned int nr_sectors, int flags)\n{\n\tstruct block_device *bdev = device->ldev->backing_bdev;\n\tsector_t tmp, nr;\n\tunsigned int max_discard_sectors, granularity;\n\tint alignment;\n\tint err = 0;\n\n\tif ((flags & EE_ZEROOUT) || !(flags & EE_TRIM))\n\t\tgoto zero_out;\n\n\t \n\tgranularity = max(bdev_discard_granularity(bdev) >> 9, 1U);\n\talignment = (bdev_discard_alignment(bdev) >> 9) % granularity;\n\n\tmax_discard_sectors = min(bdev_max_discard_sectors(bdev), (1U << 22));\n\tmax_discard_sectors -= max_discard_sectors % granularity;\n\tif (unlikely(!max_discard_sectors))\n\t\tgoto zero_out;\n\n\tif (nr_sectors < granularity)\n\t\tgoto zero_out;\n\n\ttmp = start;\n\tif (sector_div(tmp, granularity) != alignment) {\n\t\tif (nr_sectors < 2*granularity)\n\t\t\tgoto zero_out;\n\t\t \n\t\ttmp = start + granularity - alignment;\n\t\ttmp = start + granularity - sector_div(tmp, granularity);\n\n\t\tnr = tmp - start;\n\t\t \n\t\terr |= blkdev_issue_zeroout(bdev, start, nr, GFP_NOIO, 0);\n\t\tnr_sectors -= nr;\n\t\tstart = tmp;\n\t}\n\twhile (nr_sectors >= max_discard_sectors) {\n\t\terr |= blkdev_issue_discard(bdev, start, max_discard_sectors,\n\t\t\t\t\t    GFP_NOIO);\n\t\tnr_sectors -= max_discard_sectors;\n\t\tstart += max_discard_sectors;\n\t}\n\tif (nr_sectors) {\n\t\t \n\t\tnr = nr_sectors;\n\t\tnr -= (unsigned int)nr % granularity;\n\t\tif (nr) {\n\t\t\terr |= blkdev_issue_discard(bdev, start, nr, GFP_NOIO);\n\t\t\tnr_sectors -= nr;\n\t\t\tstart += nr;\n\t\t}\n\t}\n zero_out:\n\tif (nr_sectors) {\n\t\terr |= blkdev_issue_zeroout(bdev, start, nr_sectors, GFP_NOIO,\n\t\t\t\t(flags & EE_TRIM) ? 0 : BLKDEV_ZERO_NOUNMAP);\n\t}\n\treturn err != 0;\n}\n\nstatic bool can_do_reliable_discards(struct drbd_device *device)\n{\n\tstruct disk_conf *dc;\n\tbool can_do;\n\n\tif (!bdev_max_discard_sectors(device->ldev->backing_bdev))\n\t\treturn false;\n\n\trcu_read_lock();\n\tdc = rcu_dereference(device->ldev->disk_conf);\n\tcan_do = dc->discard_zeroes_if_aligned;\n\trcu_read_unlock();\n\treturn can_do;\n}\n\nstatic void drbd_issue_peer_discard_or_zero_out(struct drbd_device *device, struct drbd_peer_request *peer_req)\n{\n\t \n\tif (!can_do_reliable_discards(device))\n\t\tpeer_req->flags |= EE_ZEROOUT;\n\n\tif (drbd_issue_discard_or_zero_out(device, peer_req->i.sector,\n\t    peer_req->i.size >> 9, peer_req->flags & (EE_ZEROOUT|EE_TRIM)))\n\t\tpeer_req->flags |= EE_WAS_ERROR;\n\tdrbd_endio_write_sec_final(peer_req);\n}\n\nstatic int peer_request_fault_type(struct drbd_peer_request *peer_req)\n{\n\tif (peer_req_op(peer_req) == REQ_OP_READ) {\n\t\treturn peer_req->flags & EE_APPLICATION ?\n\t\t\tDRBD_FAULT_DT_RD : DRBD_FAULT_RS_RD;\n\t} else {\n\t\treturn peer_req->flags & EE_APPLICATION ?\n\t\t\tDRBD_FAULT_DT_WR : DRBD_FAULT_RS_WR;\n\t}\n}\n\n \n \nint drbd_submit_peer_request(struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_device *device = peer_req->peer_device->device;\n\tstruct bio *bios = NULL;\n\tstruct bio *bio;\n\tstruct page *page = peer_req->pages;\n\tsector_t sector = peer_req->i.sector;\n\tunsigned int data_size = peer_req->i.size;\n\tunsigned int n_bios = 0;\n\tunsigned int nr_pages = PFN_UP(data_size);\n\n\t \n\tif (peer_req->flags & (EE_TRIM | EE_ZEROOUT)) {\n\t\t \n\t\tconn_wait_active_ee_empty(peer_req->peer_device->connection);\n\t\t \n\t\tpeer_req->submit_jif = jiffies;\n\t\tpeer_req->flags |= EE_SUBMITTED;\n\n\t\t \n\t\tif (list_empty(&peer_req->w.list)) {\n\t\t\tspin_lock_irq(&device->resource->req_lock);\n\t\t\tlist_add_tail(&peer_req->w.list, &device->active_ee);\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\t}\n\n\t\tdrbd_issue_peer_discard_or_zero_out(device, peer_req);\n\t\treturn 0;\n\t}\n\n\t \nnext_bio:\n\t \n\tif (!(peer_req_op(peer_req) == REQ_OP_WRITE ||\n\t\t\t\tpeer_req_op(peer_req) == REQ_OP_READ)) {\n\t\tdrbd_err(device, \"Invalid bio op received: 0x%x\\n\", peer_req->opf);\n\t\treturn -EINVAL;\n\t}\n\n\tbio = bio_alloc(device->ldev->backing_bdev, nr_pages, peer_req->opf, GFP_NOIO);\n\t \n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_private = peer_req;\n\tbio->bi_end_io = drbd_peer_request_endio;\n\n\tbio->bi_next = bios;\n\tbios = bio;\n\t++n_bios;\n\n\tpage_chain_for_each(page) {\n\t\tunsigned len = min_t(unsigned, data_size, PAGE_SIZE);\n\t\tif (!bio_add_page(bio, page, len, 0))\n\t\t\tgoto next_bio;\n\t\tdata_size -= len;\n\t\tsector += len >> 9;\n\t\t--nr_pages;\n\t}\n\tD_ASSERT(device, data_size == 0);\n\tD_ASSERT(device, page == NULL);\n\n\tatomic_set(&peer_req->pending_bios, n_bios);\n\t \n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->flags |= EE_SUBMITTED;\n\tdo {\n\t\tbio = bios;\n\t\tbios = bios->bi_next;\n\t\tbio->bi_next = NULL;\n\n\t\tdrbd_submit_bio_noacct(device, peer_request_fault_type(peer_req), bio);\n\t} while (bios);\n\treturn 0;\n}\n\nstatic void drbd_remove_epoch_entry_interval(struct drbd_device *device,\n\t\t\t\t\t     struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_interval *i = &peer_req->i;\n\n\tdrbd_remove_interval(&device->write_requests, i);\n\tdrbd_clear_interval(i);\n\n\t \n\tif (i->waiting)\n\t\twake_up(&device->misc_wait);\n}\n\nstatic void conn_wait_active_ee_empty(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_wait_ee_list_empty(device, &device->active_ee);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\nstatic int receive_Barrier(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tint rv;\n\tstruct p_barrier *p = pi->data;\n\tstruct drbd_epoch *epoch;\n\n\t \n\tconnection->current_epoch->barrier_nr = p->barrier;\n\tconnection->current_epoch->connection = connection;\n\trv = drbd_may_finish_epoch(connection, connection->current_epoch, EV_GOT_BARRIER_NR);\n\n\t \n\tswitch (connection->resource->write_ordering) {\n\tcase WO_NONE:\n\t\tif (rv == FE_RECYCLED)\n\t\t\treturn 0;\n\n\t\t \n\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\n\t\tif (epoch)\n\t\t\tbreak;\n\t\telse\n\t\t\tdrbd_warn(connection, \"Allocation of an epoch failed, slowing down\\n\");\n\t\tfallthrough;\n\n\tcase WO_BDEV_FLUSH:\n\tcase WO_DRAIN_IO:\n\t\tconn_wait_active_ee_empty(connection);\n\t\tdrbd_flush(connection);\n\n\t\tif (atomic_read(&connection->current_epoch->epoch_size)) {\n\t\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\n\t\t\tif (epoch)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tdrbd_err(connection, \"Strangeness in connection->write_ordering %d\\n\",\n\t\t\t connection->resource->write_ordering);\n\t\treturn -EIO;\n\t}\n\n\tepoch->flags = 0;\n\tatomic_set(&epoch->epoch_size, 0);\n\tatomic_set(&epoch->active, 0);\n\n\tspin_lock(&connection->epoch_lock);\n\tif (atomic_read(&connection->current_epoch->epoch_size)) {\n\t\tlist_add(&epoch->list, &connection->current_epoch->list);\n\t\tconnection->current_epoch = epoch;\n\t\tconnection->epochs++;\n\t} else {\n\t\t \n\t\tkfree(epoch);\n\t}\n\tspin_unlock(&connection->epoch_lock);\n\n\treturn 0;\n}\n\n \nstatic void drbd_csum_ee_size(struct crypto_shash *h,\n\t\t\t      struct drbd_peer_request *r, void *d,\n\t\t\t      unsigned int payload_size)\n{\n\tunsigned int tmp = r->i.size;\n\tr->i.size = payload_size;\n\tdrbd_csum_ee(h, r, d);\n\tr->i.size = tmp;\n}\n\n \nstatic struct drbd_peer_request *\nread_in_block(struct drbd_peer_device *peer_device, u64 id, sector_t sector,\n\t      struct packet_info *pi) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tconst sector_t capacity = get_capacity(device->vdisk);\n\tstruct drbd_peer_request *peer_req;\n\tstruct page *page;\n\tint digest_size, err;\n\tunsigned int data_size = pi->size, ds;\n\tvoid *dig_in = peer_device->connection->int_dig_in;\n\tvoid *dig_vv = peer_device->connection->int_dig_vv;\n\tunsigned long *data;\n\tstruct p_trim *trim = (pi->cmd == P_TRIM) ? pi->data : NULL;\n\tstruct p_trim *zeroes = (pi->cmd == P_ZEROES) ? pi->data : NULL;\n\n\tdigest_size = 0;\n\tif (!trim && peer_device->connection->peer_integrity_tfm) {\n\t\tdigest_size = crypto_shash_digestsize(peer_device->connection->peer_integrity_tfm);\n\t\t \n\t\terr = drbd_recv_all_warn(peer_device->connection, dig_in, digest_size);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tdata_size -= digest_size;\n\t}\n\n\t \n\tds = data_size;\n\tif (trim) {\n\t\tif (!expect(peer_device, data_size == 0))\n\t\t\treturn NULL;\n\t\tds = be32_to_cpu(trim->size);\n\t} else if (zeroes) {\n\t\tif (!expect(peer_device, data_size == 0))\n\t\t\treturn NULL;\n\t\tds = be32_to_cpu(zeroes->size);\n\t}\n\n\tif (!expect(peer_device, IS_ALIGNED(ds, 512)))\n\t\treturn NULL;\n\tif (trim || zeroes) {\n\t\tif (!expect(peer_device, ds <= (DRBD_MAX_BBIO_SECTORS << 9)))\n\t\t\treturn NULL;\n\t} else if (!expect(peer_device, ds <= DRBD_MAX_BIO_SIZE))\n\t\treturn NULL;\n\n\t \n\tif (sector + (ds>>9) > capacity) {\n\t\tdrbd_err(device, \"request from peer beyond end of local disk: \"\n\t\t\t\"capacity: %llus < sector: %llus + size: %u\\n\",\n\t\t\t(unsigned long long)capacity,\n\t\t\t(unsigned long long)sector, ds);\n\t\treturn NULL;\n\t}\n\n\t \n\tpeer_req = drbd_alloc_peer_req(peer_device, id, sector, ds, data_size, GFP_NOIO);\n\tif (!peer_req)\n\t\treturn NULL;\n\n\tpeer_req->flags |= EE_WRITE;\n\tif (trim) {\n\t\tpeer_req->flags |= EE_TRIM;\n\t\treturn peer_req;\n\t}\n\tif (zeroes) {\n\t\tpeer_req->flags |= EE_ZEROOUT;\n\t\treturn peer_req;\n\t}\n\n\t \n\tds = data_size;\n\tpage = peer_req->pages;\n\tpage_chain_for_each(page) {\n\t\tunsigned len = min_t(int, ds, PAGE_SIZE);\n\t\tdata = kmap(page);\n\t\terr = drbd_recv_all_warn(peer_device->connection, data, len);\n\t\tif (drbd_insert_fault(device, DRBD_FAULT_RECEIVE)) {\n\t\t\tdrbd_err(device, \"Fault injection: Corrupting data on receive\\n\");\n\t\t\tdata[0] = data[0] ^ (unsigned long)-1;\n\t\t}\n\t\tkunmap(page);\n\t\tif (err) {\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\treturn NULL;\n\t\t}\n\t\tds -= len;\n\t}\n\n\tif (digest_size) {\n\t\tdrbd_csum_ee_size(peer_device->connection->peer_integrity_tfm, peer_req, dig_vv, data_size);\n\t\tif (memcmp(dig_in, dig_vv, digest_size)) {\n\t\t\tdrbd_err(device, \"Digest integrity check FAILED: %llus +%u\\n\",\n\t\t\t\t(unsigned long long)sector, data_size);\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tdevice->recv_cnt += data_size >> 9;\n\treturn peer_req;\n}\n\n \nstatic int drbd_drain_block(struct drbd_peer_device *peer_device, int data_size)\n{\n\tstruct page *page;\n\tint err = 0;\n\tvoid *data;\n\n\tif (!data_size)\n\t\treturn 0;\n\n\tpage = drbd_alloc_pages(peer_device, 1, 1);\n\n\tdata = kmap(page);\n\twhile (data_size) {\n\t\tunsigned int len = min_t(int, data_size, PAGE_SIZE);\n\n\t\terr = drbd_recv_all_warn(peer_device->connection, data, len);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdata_size -= len;\n\t}\n\tkunmap(page);\n\tdrbd_free_pages(peer_device->device, page, 0);\n\treturn err;\n}\n\nstatic int recv_dless_read(struct drbd_peer_device *peer_device, struct drbd_request *req,\n\t\t\t   sector_t sector, int data_size)\n{\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tstruct bio *bio;\n\tint digest_size, err, expect;\n\tvoid *dig_in = peer_device->connection->int_dig_in;\n\tvoid *dig_vv = peer_device->connection->int_dig_vv;\n\n\tdigest_size = 0;\n\tif (peer_device->connection->peer_integrity_tfm) {\n\t\tdigest_size = crypto_shash_digestsize(peer_device->connection->peer_integrity_tfm);\n\t\terr = drbd_recv_all_warn(peer_device->connection, dig_in, digest_size);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata_size -= digest_size;\n\t}\n\n\t \n\tpeer_device->device->recv_cnt += data_size>>9;\n\n\tbio = req->master_bio;\n\tD_ASSERT(peer_device->device, sector == bio->bi_iter.bi_sector);\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tvoid *mapped = bvec_kmap_local(&bvec);\n\t\texpect = min_t(int, data_size, bvec.bv_len);\n\t\terr = drbd_recv_all_warn(peer_device->connection, mapped, expect);\n\t\tkunmap_local(mapped);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata_size -= expect;\n\t}\n\n\tif (digest_size) {\n\t\tdrbd_csum_bio(peer_device->connection->peer_integrity_tfm, bio, dig_vv);\n\t\tif (memcmp(dig_in, dig_vv, digest_size)) {\n\t\t\tdrbd_err(peer_device, \"Digest integrity check FAILED. Broken NICs?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tD_ASSERT(peer_device->device, data_size == 0);\n\treturn 0;\n}\n\n \nstatic int e_end_resync_block(struct drbd_work *w, int unused)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tstruct drbd_device *device = peer_device->device;\n\tsector_t sector = peer_req->i.sector;\n\tint err;\n\n\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\n\tif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\n\t\tdrbd_set_in_sync(peer_device, sector, peer_req->i.size);\n\t\terr = drbd_send_ack(peer_device, P_RS_WRITE_ACK, peer_req);\n\t} else {\n\t\t \n\t\tdrbd_rs_failed_io(peer_device, sector, peer_req->i.size);\n\n\t\terr  = drbd_send_ack(peer_device, P_NEG_ACK, peer_req);\n\t}\n\tdec_unacked(device);\n\n\treturn err;\n}\n\nstatic int recv_resync_read(struct drbd_peer_device *peer_device, sector_t sector,\n\t\t\t    struct packet_info *pi) __releases(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_peer_request *peer_req;\n\n\tpeer_req = read_in_block(peer_device, ID_SYNCER, sector, pi);\n\tif (!peer_req)\n\t\tgoto fail;\n\n\tdec_rs_pending(peer_device);\n\n\tinc_unacked(device);\n\t \n\n\tpeer_req->w.cb = e_end_resync_block;\n\tpeer_req->opf = REQ_OP_WRITE;\n\tpeer_req->submit_jif = jiffies;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_add_tail(&peer_req->w.list, &device->sync_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tatomic_add(pi->size >> 9, &device->rs_sect_ev);\n\tif (drbd_submit_peer_request(peer_req) == 0)\n\t\treturn 0;\n\n\t \n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tdrbd_free_peer_req(device, peer_req);\nfail:\n\tput_ldev(device);\n\treturn -EIO;\n}\n\nstatic struct drbd_request *\nfind_request(struct drbd_device *device, struct rb_root *root, u64 id,\n\t     sector_t sector, bool missing_ok, const char *func)\n{\n\tstruct drbd_request *req;\n\n\t \n\treq = (struct drbd_request *)(unsigned long)id;\n\tif (drbd_contains_interval(root, sector, &req->i) && req->i.local)\n\t\treturn req;\n\tif (!missing_ok) {\n\t\tdrbd_err(device, \"%s: failed to find request 0x%lx, sector %llus\\n\", func,\n\t\t\t(unsigned long)id, (unsigned long long)sector);\n\t}\n\treturn NULL;\n}\n\nstatic int receive_DataReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct drbd_request *req;\n\tsector_t sector;\n\tint err;\n\tstruct p_data *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treq = find_request(device, &device->read_requests, p->block_id, sector, false, __func__);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (unlikely(!req))\n\t\treturn -EIO;\n\n\terr = recv_dless_read(peer_device, req, sector, pi->size);\n\tif (!err)\n\t\treq_mod(req, DATA_RECEIVED, peer_device);\n\t \n\n\treturn err;\n}\n\nstatic int receive_RSDataReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint err;\n\tstruct p_data *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tD_ASSERT(device, p->block_id == ID_SYNCER);\n\n\tif (get_ldev(device)) {\n\t\t \n\t\terr = recv_resync_read(peer_device, sector, pi);\n\t} else {\n\t\tif (drbd_ratelimit())\n\t\t\tdrbd_err(device, \"Can not write resync data to local disk.\\n\");\n\n\t\terr = drbd_drain_block(peer_device, pi->size);\n\n\t\tdrbd_send_ack_dp(peer_device, P_NEG_ACK, p, pi->size);\n\t}\n\n\tatomic_add(pi->size >> 9, &device->rs_sect_in);\n\n\treturn err;\n}\n\nstatic void restart_conflicting_writes(struct drbd_device *device,\n\t\t\t\t       sector_t sector, int size)\n{\n\tstruct drbd_interval *i;\n\tstruct drbd_request *req;\n\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (req->rq_state & RQ_LOCAL_PENDING ||\n\t\t    !(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\t \n\t\t__req_mod(req, CONFLICT_RESOLVED, NULL, NULL);\n\t}\n}\n\n \nstatic int e_end_block(struct drbd_work *w, int cancel)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tstruct drbd_device *device = peer_device->device;\n\tsector_t sector = peer_req->i.sector;\n\tint err = 0, pcmd;\n\n\tif (peer_req->flags & EE_SEND_WRITE_ACK) {\n\t\tif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\n\t\t\tpcmd = (device->state.conn >= C_SYNC_SOURCE &&\n\t\t\t\tdevice->state.conn <= C_PAUSED_SYNC_T &&\n\t\t\t\tpeer_req->flags & EE_MAY_SET_IN_SYNC) ?\n\t\t\t\tP_RS_WRITE_ACK : P_WRITE_ACK;\n\t\t\terr = drbd_send_ack(peer_device, pcmd, peer_req);\n\t\t\tif (pcmd == P_RS_WRITE_ACK)\n\t\t\t\tdrbd_set_in_sync(peer_device, sector, peer_req->i.size);\n\t\t} else {\n\t\t\terr = drbd_send_ack(peer_device, P_NEG_ACK, peer_req);\n\t\t\t \n\t\t}\n\t\tdec_unacked(device);\n\t}\n\n\t \n\tif (peer_req->flags & EE_IN_INTERVAL_TREE) {\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tD_ASSERT(device, !drbd_interval_empty(&peer_req->i));\n\t\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\t\tif (peer_req->flags & EE_RESTART_REQUESTS)\n\t\t\trestart_conflicting_writes(device, sector, peer_req->i.size);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t} else\n\t\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\n\tdrbd_may_finish_epoch(peer_device->connection, peer_req->epoch, EV_PUT + (cancel ? EV_CLEANUP : 0));\n\n\treturn err;\n}\n\nstatic int e_send_ack(struct drbd_work *w, enum drbd_packet ack)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tint err;\n\n\terr = drbd_send_ack(peer_device, ack, peer_req);\n\tdec_unacked(peer_device->device);\n\n\treturn err;\n}\n\nstatic int e_send_superseded(struct drbd_work *w, int unused)\n{\n\treturn e_send_ack(w, P_SUPERSEDED);\n}\n\nstatic int e_send_retry_write(struct drbd_work *w, int unused)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_connection *connection = peer_req->peer_device->connection;\n\n\treturn e_send_ack(w, connection->agreed_pro_version >= 100 ?\n\t\t\t     P_RETRY_WRITE : P_SUPERSEDED);\n}\n\nstatic bool seq_greater(u32 a, u32 b)\n{\n\t \n\treturn (s32)a - (s32)b > 0;\n}\n\nstatic u32 seq_max(u32 a, u32 b)\n{\n\treturn seq_greater(a, b) ? a : b;\n}\n\nstatic void update_peer_seq(struct drbd_peer_device *peer_device, unsigned int peer_seq)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned int newest_peer_seq;\n\n\tif (test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)) {\n\t\tspin_lock(&device->peer_seq_lock);\n\t\tnewest_peer_seq = seq_max(device->peer_seq, peer_seq);\n\t\tdevice->peer_seq = newest_peer_seq;\n\t\tspin_unlock(&device->peer_seq_lock);\n\t\t \n\t\tif (peer_seq == newest_peer_seq)\n\t\t\twake_up(&device->seq_wait);\n\t}\n}\n\nstatic inline int overlaps(sector_t s1, int l1, sector_t s2, int l2)\n{\n\treturn !((s1 + (l1>>9) <= s2) || (s1 >= s2 + (l2>>9)));\n}\n\n \nstatic bool overlapping_resync_write(struct drbd_device *device, struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_peer_request *rs_req;\n\tbool rv = false;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_for_each_entry(rs_req, &device->sync_ee, w.list) {\n\t\tif (overlaps(peer_req->i.sector, peer_req->i.size,\n\t\t\t     rs_req->i.sector, rs_req->i.size)) {\n\t\t\trv = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\treturn rv;\n}\n\n \nstatic int wait_for_and_update_peer_seq(struct drbd_peer_device *peer_device, const u32 peer_seq)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tDEFINE_WAIT(wait);\n\tlong timeout;\n\tint ret = 0, tp;\n\n\tif (!test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags))\n\t\treturn 0;\n\n\tspin_lock(&device->peer_seq_lock);\n\tfor (;;) {\n\t\tif (!seq_greater(peer_seq - 1, device->peer_seq)) {\n\t\t\tdevice->peer_seq = seq_max(device->peer_seq, peer_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\trcu_read_lock();\n\t\ttp = rcu_dereference(peer_device->connection->net_conf)->two_primaries;\n\t\trcu_read_unlock();\n\n\t\tif (!tp)\n\t\t\tbreak;\n\n\t\t \n\t\tprepare_to_wait(&device->seq_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_unlock(&device->peer_seq_lock);\n\t\trcu_read_lock();\n\t\ttimeout = rcu_dereference(peer_device->connection->net_conf)->ping_timeo*HZ/10;\n\t\trcu_read_unlock();\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock(&device->peer_seq_lock);\n\t\tif (!timeout) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tdrbd_err(device, \"Timed out waiting for missing ack packets; disconnecting\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&device->peer_seq_lock);\n\tfinish_wait(&device->seq_wait, &wait);\n\treturn ret;\n}\n\nstatic enum req_op wire_flags_to_bio_op(u32 dpf)\n{\n\tif (dpf & DP_ZEROES)\n\t\treturn REQ_OP_WRITE_ZEROES;\n\tif (dpf & DP_DISCARD)\n\t\treturn REQ_OP_DISCARD;\n\telse\n\t\treturn REQ_OP_WRITE;\n}\n\n \nstatic blk_opf_t wire_flags_to_bio(struct drbd_connection *connection, u32 dpf)\n{\n\treturn wire_flags_to_bio_op(dpf) |\n\t\t(dpf & DP_RW_SYNC ? REQ_SYNC : 0) |\n\t\t(dpf & DP_FUA ? REQ_FUA : 0) |\n\t\t(dpf & DP_FLUSH ? REQ_PREFLUSH : 0);\n}\n\nstatic void fail_postponed_requests(struct drbd_device *device, sector_t sector,\n\t\t\t\t    unsigned int size)\n{\n\tstruct drbd_peer_device *peer_device = first_peer_device(device);\n\tstruct drbd_interval *i;\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tstruct drbd_request *req;\n\t\tstruct bio_and_error m;\n\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (!(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\treq->rq_state &= ~RQ_POSTPONED;\n\t\t__req_mod(req, NEG_ACKED, peer_device, &m);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tif (m.bio)\n\t\t\tcomplete_master_bio(device, &m);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tgoto repeat;\n\t}\n}\n\nstatic int handle_write_conflicts(struct drbd_device *device,\n\t\t\t\t  struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_connection *connection = peer_req->peer_device->connection;\n\tbool resolve_conflicts = test_bit(RESOLVE_CONFLICTS, &connection->flags);\n\tsector_t sector = peer_req->i.sector;\n\tconst unsigned int size = peer_req->i.size;\n\tstruct drbd_interval *i;\n\tbool equal;\n\tint err;\n\n\t \n\tdrbd_insert_interval(&device->write_requests, &peer_req->i);\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tif (i == &peer_req->i)\n\t\t\tcontinue;\n\t\tif (i->completed)\n\t\t\tcontinue;\n\n\t\tif (!i->local) {\n\t\t\t \n\t\t\terr = drbd_wait_misc(device, i);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tequal = i->sector == sector && i->size == size;\n\t\tif (resolve_conflicts) {\n\t\t\t \n\t\t\tbool superseded = i->sector <= sector && i->sector +\n\t\t\t\t       (i->size >> 9) >= sector + (size >> 9);\n\n\t\t\tif (!equal)\n\t\t\t\tdrbd_alert(device, \"Concurrent writes detected: \"\n\t\t\t\t\t       \"local=%llus +%u, remote=%llus +%u, \"\n\t\t\t\t\t       \"assuming %s came first\\n\",\n\t\t\t\t\t  (unsigned long long)i->sector, i->size,\n\t\t\t\t\t  (unsigned long long)sector, size,\n\t\t\t\t\t  superseded ? \"local\" : \"remote\");\n\n\t\t\tpeer_req->w.cb = superseded ? e_send_superseded :\n\t\t\t\t\t\t   e_send_retry_write;\n\t\t\tlist_add_tail(&peer_req->w.list, &device->done_ee);\n\t\t\tqueue_work(connection->ack_sender, &peer_req->peer_device->send_acks_work);\n\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct drbd_request *req =\n\t\t\t\tcontainer_of(i, struct drbd_request, i);\n\n\t\t\tif (!equal)\n\t\t\t\tdrbd_alert(device, \"Concurrent writes detected: \"\n\t\t\t\t\t       \"local=%llus +%u, remote=%llus +%u\\n\",\n\t\t\t\t\t  (unsigned long long)i->sector, i->size,\n\t\t\t\t\t  (unsigned long long)sector, size);\n\n\t\t\tif (req->rq_state & RQ_LOCAL_PENDING ||\n\t\t\t    !(req->rq_state & RQ_POSTPONED)) {\n\t\t\t\t \n\t\t\t\terr = drbd_wait_misc(device, &req->i);\n\t\t\t\tif (err) {\n\t\t\t\t\t_conn_request_state(connection, NS(conn, C_TIMEOUT), CS_HARD);\n\t\t\t\t\tfail_postponed_requests(device, sector, size);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t \n\t\t\tpeer_req->flags |= EE_RESTART_REQUESTS;\n\t\t}\n\t}\n\terr = 0;\n\n    out:\n\tif (err)\n\t\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\treturn err;\n}\n\n \nstatic int receive_Data(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct net_conf *nc;\n\tsector_t sector;\n\tstruct drbd_peer_request *peer_req;\n\tstruct p_data *p = pi->data;\n\tu32 peer_seq = be32_to_cpu(p->seq_num);\n\tu32 dp_flags;\n\tint err, tp;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tif (!get_ldev(device)) {\n\t\tint err2;\n\n\t\terr = wait_for_and_update_peer_seq(peer_device, peer_seq);\n\t\tdrbd_send_ack_dp(peer_device, P_NEG_ACK, p, pi->size);\n\t\tatomic_inc(&connection->current_epoch->epoch_size);\n\t\terr2 = drbd_drain_block(peer_device, pi->size);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\treturn err;\n\t}\n\n\t \n\n\tsector = be64_to_cpu(p->sector);\n\tpeer_req = read_in_block(peer_device, p->block_id, sector, pi);\n\tif (!peer_req) {\n\t\tput_ldev(device);\n\t\treturn -EIO;\n\t}\n\n\tpeer_req->w.cb = e_end_block;\n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->flags |= EE_APPLICATION;\n\n\tdp_flags = be32_to_cpu(p->dp_flags);\n\tpeer_req->opf = wire_flags_to_bio(connection, dp_flags);\n\tif (pi->cmd == P_TRIM) {\n\t\tD_ASSERT(peer_device, peer_req->i.size > 0);\n\t\tD_ASSERT(peer_device, peer_req_op(peer_req) == REQ_OP_DISCARD);\n\t\tD_ASSERT(peer_device, peer_req->pages == NULL);\n\t\t \n\t\tif (0 == (connection->agreed_features & DRBD_FF_WZEROES))\n\t\t\tpeer_req->flags |= EE_ZEROOUT;\n\t} else if (pi->cmd == P_ZEROES) {\n\t\tD_ASSERT(peer_device, peer_req->i.size > 0);\n\t\tD_ASSERT(peer_device, peer_req_op(peer_req) == REQ_OP_WRITE_ZEROES);\n\t\tD_ASSERT(peer_device, peer_req->pages == NULL);\n\t\t \n\t\tif (dp_flags & DP_DISCARD)\n\t\t\tpeer_req->flags |= EE_TRIM;\n\t} else if (peer_req->pages == NULL) {\n\t\tD_ASSERT(device, peer_req->i.size == 0);\n\t\tD_ASSERT(device, dp_flags & DP_FLUSH);\n\t}\n\n\tif (dp_flags & DP_MAY_SET_IN_SYNC)\n\t\tpeer_req->flags |= EE_MAY_SET_IN_SYNC;\n\n\tspin_lock(&connection->epoch_lock);\n\tpeer_req->epoch = connection->current_epoch;\n\tatomic_inc(&peer_req->epoch->epoch_size);\n\tatomic_inc(&peer_req->epoch->active);\n\tspin_unlock(&connection->epoch_lock);\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\ttp = nc->two_primaries;\n\tif (peer_device->connection->agreed_pro_version < 100) {\n\t\tswitch (nc->wire_protocol) {\n\t\tcase DRBD_PROT_C:\n\t\t\tdp_flags |= DP_SEND_WRITE_ACK;\n\t\t\tbreak;\n\t\tcase DRBD_PROT_B:\n\t\t\tdp_flags |= DP_SEND_RECEIVE_ACK;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (dp_flags & DP_SEND_WRITE_ACK) {\n\t\tpeer_req->flags |= EE_SEND_WRITE_ACK;\n\t\tinc_unacked(device);\n\t\t \n\t}\n\n\tif (dp_flags & DP_SEND_RECEIVE_ACK) {\n\t\t \n\t\tdrbd_send_ack(peer_device, P_RECV_ACK, peer_req);\n\t}\n\n\tif (tp) {\n\t\t \n\t\tD_ASSERT(device, dp_flags & DP_SEND_WRITE_ACK);\n\t\tpeer_req->flags |= EE_IN_INTERVAL_TREE;\n\t\terr = wait_for_and_update_peer_seq(peer_device, peer_seq);\n\t\tif (err)\n\t\t\tgoto out_interrupted;\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\terr = handle_write_conflicts(device, peer_req);\n\t\tif (err) {\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tput_ldev(device);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto out_interrupted;\n\t\t}\n\t} else {\n\t\tupdate_peer_seq(peer_device, peer_seq);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t}\n\t \n\tif ((peer_req->flags & (EE_TRIM | EE_ZEROOUT)) == 0)\n\t\tlist_add_tail(&peer_req->w.list, &device->active_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (device->state.conn == C_SYNC_TARGET)\n\t\twait_event(device->ee_wait, !overlapping_resync_write(device, peer_req));\n\n\tif (device->state.pdsk < D_INCONSISTENT) {\n\t\t \n\t\tdrbd_set_out_of_sync(peer_device, peer_req->i.sector, peer_req->i.size);\n\t\tpeer_req->flags &= ~EE_MAY_SET_IN_SYNC;\n\t\tdrbd_al_begin_io(device, &peer_req->i);\n\t\tpeer_req->flags |= EE_CALL_AL_COMPLETE_IO;\n\t}\n\n\terr = drbd_submit_peer_request(peer_req);\n\tif (!err)\n\t\treturn 0;\n\n\t \n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (peer_req->flags & EE_CALL_AL_COMPLETE_IO) {\n\t\tpeer_req->flags &= ~EE_CALL_AL_COMPLETE_IO;\n\t\tdrbd_al_complete_io(device, &peer_req->i);\n\t}\n\nout_interrupted:\n\tdrbd_may_finish_epoch(connection, peer_req->epoch, EV_PUT | EV_CLEANUP);\n\tput_ldev(device);\n\tdrbd_free_peer_req(device, peer_req);\n\treturn err;\n}\n\n \nbool drbd_rs_should_slow_down(struct drbd_peer_device *peer_device, sector_t sector,\n\t\tbool throttle_if_app_is_waiting)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct lc_element *tmp;\n\tbool throttle = drbd_rs_c_min_rate_throttle(device);\n\n\tif (!throttle || throttle_if_app_is_waiting)\n\t\treturn throttle;\n\n\tspin_lock_irq(&device->al_lock);\n\ttmp = lc_find(device->resync, BM_SECT_TO_EXT(sector));\n\tif (tmp) {\n\t\tstruct bm_extent *bm_ext = lc_entry(tmp, struct bm_extent, lce);\n\t\tif (test_bit(BME_PRIORITY, &bm_ext->flags))\n\t\t\tthrottle = false;\n\t\t \n\t}\n\tspin_unlock_irq(&device->al_lock);\n\n\treturn throttle;\n}\n\nbool drbd_rs_c_min_rate_throttle(struct drbd_device *device)\n{\n\tstruct gendisk *disk = device->ldev->backing_bdev->bd_disk;\n\tunsigned long db, dt, dbdt;\n\tunsigned int c_min_rate;\n\tint curr_events;\n\n\trcu_read_lock();\n\tc_min_rate = rcu_dereference(device->ldev->disk_conf)->c_min_rate;\n\trcu_read_unlock();\n\n\t \n\tif (c_min_rate == 0)\n\t\treturn false;\n\n\tcurr_events = (int)part_stat_read_accum(disk->part0, sectors) -\n\t\t\tatomic_read(&device->rs_sect_ev);\n\n\tif (atomic_read(&device->ap_actlog_cnt)\n\t    || curr_events - device->rs_last_events > 64) {\n\t\tunsigned long rs_left;\n\t\tint i;\n\n\t\tdevice->rs_last_events = curr_events;\n\n\t\t \n\t\ti = (device->rs_last_mark + DRBD_SYNC_MARKS-1) % DRBD_SYNC_MARKS;\n\n\t\tif (device->state.conn == C_VERIFY_S || device->state.conn == C_VERIFY_T)\n\t\t\trs_left = device->ov_left;\n\t\telse\n\t\t\trs_left = drbd_bm_total_weight(device) - device->rs_failed;\n\n\t\tdt = ((long)jiffies - (long)device->rs_mark_time[i]) / HZ;\n\t\tif (!dt)\n\t\t\tdt++;\n\t\tdb = device->rs_mark_left[i] - rs_left;\n\t\tdbdt = Bit2KB(db/dt);\n\n\t\tif (dbdt > c_min_rate)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int receive_DataRequest(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tsector_t capacity;\n\tstruct drbd_peer_request *peer_req;\n\tstruct digest_info *di = NULL;\n\tint size, verb;\n\tstruct p_block_req *p =\tpi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\tcapacity = get_capacity(device->vdisk);\n\n\tsector = be64_to_cpu(p->sector);\n\tsize   = be32_to_cpu(p->blksize);\n\n\tif (size <= 0 || !IS_ALIGNED(size, 512) || size > DRBD_MAX_BIO_SIZE) {\n\t\tdrbd_err(device, \"%s:%d: sector: %llus, size: %u\\n\", __FILE__, __LINE__,\n\t\t\t\t(unsigned long long)sector, size);\n\t\treturn -EINVAL;\n\t}\n\tif (sector + (size>>9) > capacity) {\n\t\tdrbd_err(device, \"%s:%d: sector: %llus, size: %u\\n\", __FILE__, __LINE__,\n\t\t\t\t(unsigned long long)sector, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!get_ldev_if_state(device, D_UP_TO_DATE)) {\n\t\tverb = 1;\n\t\tswitch (pi->cmd) {\n\t\tcase P_DATA_REQUEST:\n\t\t\tdrbd_send_ack_rp(peer_device, P_NEG_DREPLY, p);\n\t\t\tbreak;\n\t\tcase P_RS_THIN_REQ:\n\t\tcase P_RS_DATA_REQUEST:\n\t\tcase P_CSUM_RS_REQUEST:\n\t\tcase P_OV_REQUEST:\n\t\t\tdrbd_send_ack_rp(peer_device, P_NEG_RS_DREPLY , p);\n\t\t\tbreak;\n\t\tcase P_OV_REPLY:\n\t\t\tverb = 0;\n\t\t\tdec_rs_pending(peer_device);\n\t\t\tdrbd_send_ack_ex(peer_device, P_OV_RESULT, sector, size, ID_IN_SYNC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (verb && drbd_ratelimit())\n\t\t\tdrbd_err(device, \"Can not satisfy peer's read request, \"\n\t\t\t    \"no local data.\\n\");\n\n\t\t \n\t\treturn drbd_drain_block(peer_device, pi->size);\n\t}\n\n\t \n\tpeer_req = drbd_alloc_peer_req(peer_device, p->block_id, sector, size,\n\t\t\tsize, GFP_NOIO);\n\tif (!peer_req) {\n\t\tput_ldev(device);\n\t\treturn -ENOMEM;\n\t}\n\tpeer_req->opf = REQ_OP_READ;\n\n\tswitch (pi->cmd) {\n\tcase P_DATA_REQUEST:\n\t\tpeer_req->w.cb = w_e_end_data_req;\n\t\t \n\t\tpeer_req->flags |= EE_APPLICATION;\n\t\tgoto submit;\n\n\tcase P_RS_THIN_REQ:\n\t\t \n\t\tpeer_req->flags |= EE_RS_THIN_REQ;\n\t\tfallthrough;\n\tcase P_RS_DATA_REQUEST:\n\t\tpeer_req->w.cb = w_e_end_rsdata_req;\n\t\t \n\t\tdevice->bm_resync_fo = BM_SECT_TO_BIT(sector);\n\t\tbreak;\n\n\tcase P_OV_REPLY:\n\tcase P_CSUM_RS_REQUEST:\n\t\tdi = kmalloc(sizeof(*di) + pi->size, GFP_NOIO);\n\t\tif (!di)\n\t\t\tgoto out_free_e;\n\n\t\tdi->digest_size = pi->size;\n\t\tdi->digest = (((char *)di)+sizeof(struct digest_info));\n\n\t\tpeer_req->digest = di;\n\t\tpeer_req->flags |= EE_HAS_DIGEST;\n\n\t\tif (drbd_recv_all(peer_device->connection, di->digest, pi->size))\n\t\t\tgoto out_free_e;\n\n\t\tif (pi->cmd == P_CSUM_RS_REQUEST) {\n\t\t\tD_ASSERT(device, peer_device->connection->agreed_pro_version >= 89);\n\t\t\tpeer_req->w.cb = w_e_end_csum_rs_req;\n\t\t\t \n\t\t\tdevice->bm_resync_fo = BM_SECT_TO_BIT(sector);\n\t\t\t \n\t\t\tdevice->use_csums = true;\n\t\t} else if (pi->cmd == P_OV_REPLY) {\n\t\t\t \n\t\t\tatomic_add(size >> 9, &device->rs_sect_in);\n\t\t\tpeer_req->w.cb = w_e_end_ov_reply;\n\t\t\tdec_rs_pending(peer_device);\n\t\t\t \n\t\t\tgoto submit_for_resync;\n\t\t}\n\t\tbreak;\n\n\tcase P_OV_REQUEST:\n\t\tif (device->ov_start_sector == ~(sector_t)0 &&\n\t\t    peer_device->connection->agreed_pro_version >= 90) {\n\t\t\tunsigned long now = jiffies;\n\t\t\tint i;\n\t\t\tdevice->ov_start_sector = sector;\n\t\t\tdevice->ov_position = sector;\n\t\t\tdevice->ov_left = drbd_bm_bits(device) - BM_SECT_TO_BIT(sector);\n\t\t\tdevice->rs_total = device->ov_left;\n\t\t\tfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\n\t\t\t\tdevice->rs_mark_left[i] = device->ov_left;\n\t\t\t\tdevice->rs_mark_time[i] = now;\n\t\t\t}\n\t\t\tdrbd_info(device, \"Online Verify start sector: %llu\\n\",\n\t\t\t\t\t(unsigned long long)sector);\n\t\t}\n\t\tpeer_req->w.cb = w_e_end_ov_req;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\n\t \n\n\t \n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_add_tail(&peer_req->w.list, &device->read_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tupdate_receiver_timing_details(connection, drbd_rs_should_slow_down);\n\tif (device->state.peer != R_PRIMARY\n\t&& drbd_rs_should_slow_down(peer_device, sector, false))\n\t\tschedule_timeout_uninterruptible(HZ/10);\n\tupdate_receiver_timing_details(connection, drbd_rs_begin_io);\n\tif (drbd_rs_begin_io(device, sector))\n\t\tgoto out_free_e;\n\nsubmit_for_resync:\n\tatomic_add(size >> 9, &device->rs_sect_ev);\n\nsubmit:\n\tupdate_receiver_timing_details(connection, drbd_submit_peer_request);\n\tinc_unacked(device);\n\tif (drbd_submit_peer_request(peer_req) == 0)\n\t\treturn 0;\n\n\t \n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\nout_free_e:\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\t \n\n\tput_ldev(device);\n\tdrbd_free_peer_req(device, peer_req);\n\treturn -EIO;\n}\n\n \nstatic int drbd_asb_recover_0p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint self, peer, rv = -100;\n\tunsigned long ch_self, ch_peer;\n\tenum drbd_after_sb_p after_sb_0p;\n\n\tself = device->ldev->md.uuid[UI_BITMAP] & 1;\n\tpeer = device->p_uuid[UI_BITMAP] & 1;\n\n\tch_peer = device->p_uuid[UI_SIZE];\n\tch_self = device->comm_bm_set;\n\n\trcu_read_lock();\n\tafter_sb_0p = rcu_dereference(peer_device->connection->net_conf)->after_sb_0p;\n\trcu_read_unlock();\n\tswitch (after_sb_0p) {\n\tcase ASB_CONSENSUS:\n\tcase ASB_DISCARD_SECONDARY:\n\tcase ASB_CALL_HELPER:\n\tcase ASB_VIOLENTLY:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\t\tif (self == 0 && peer == 1) {\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (self == 1 && peer == 0) {\n\t\t\trv =  1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase ASB_DISCARD_OLDER_PRI:\n\t\tif (self == 0 && peer == 1) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (self == 1 && peer == 0) {\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tdrbd_warn(device, \"Discard younger/older primary did not find a decision\\n\"\n\t\t     \"Using discard-least-changes instead\\n\");\n\t\tfallthrough;\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tif (ch_peer == 0 && ch_self == 0) {\n\t\t\trv = test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)\n\t\t\t\t? -1 : 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (ch_peer == 0) { rv =  1; break; }\n\t\t\tif (ch_self == 0) { rv = -1; break; }\n\t\t}\n\t\tif (after_sb_0p == ASB_DISCARD_ZERO_CHG)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ASB_DISCARD_LEAST_CHG:\n\t\tif\t(ch_self < ch_peer)\n\t\t\trv = -1;\n\t\telse if (ch_self > ch_peer)\n\t\t\trv =  1;\n\t\telse  \n\t\t      \n\t\t\trv = test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)\n\t\t\t\t? -1 : 1;\n\t\tbreak;\n\tcase ASB_DISCARD_LOCAL:\n\t\trv = -1;\n\t\tbreak;\n\tcase ASB_DISCARD_REMOTE:\n\t\trv =  1;\n\t}\n\n\treturn rv;\n}\n\n \nstatic int drbd_asb_recover_1p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint hg, rv = -100;\n\tenum drbd_after_sb_p after_sb_1p;\n\n\trcu_read_lock();\n\tafter_sb_1p = rcu_dereference(peer_device->connection->net_conf)->after_sb_1p;\n\trcu_read_unlock();\n\tswitch (after_sb_1p) {\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\tcase ASB_DISCARD_OLDER_PRI:\n\tcase ASB_DISCARD_LEAST_CHG:\n\tcase ASB_DISCARD_LOCAL:\n\tcase ASB_DISCARD_REMOTE:\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_CONSENSUS:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1 && device->state.role == R_SECONDARY)\n\t\t\trv = hg;\n\t\tif (hg == 1  && device->state.role == R_PRIMARY)\n\t\t\trv = hg;\n\t\tbreak;\n\tcase ASB_VIOLENTLY:\n\t\trv = drbd_asb_recover_0p(peer_device);\n\t\tbreak;\n\tcase ASB_DISCARD_SECONDARY:\n\t\treturn device->state.role == R_PRIMARY ? 1 : -1;\n\tcase ASB_CALL_HELPER:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1 && device->state.role == R_PRIMARY) {\n\t\t\tenum drbd_state_rv rv2;\n\n\t\t\t  \n\t\t\trv2 = drbd_change_state(device, CS_VERBOSE, NS(role, R_SECONDARY));\n\t\t\tif (rv2 != SS_SUCCESS) {\n\t\t\t\tdrbd_khelper(device, \"pri-lost-after-sb\");\n\t\t\t} else {\n\t\t\t\tdrbd_warn(device, \"Successfully gave up primary role.\\n\");\n\t\t\t\trv = hg;\n\t\t\t}\n\t\t} else\n\t\t\trv = hg;\n\t}\n\n\treturn rv;\n}\n\n \nstatic int drbd_asb_recover_2p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint hg, rv = -100;\n\tenum drbd_after_sb_p after_sb_2p;\n\n\trcu_read_lock();\n\tafter_sb_2p = rcu_dereference(peer_device->connection->net_conf)->after_sb_2p;\n\trcu_read_unlock();\n\tswitch (after_sb_2p) {\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\tcase ASB_DISCARD_OLDER_PRI:\n\tcase ASB_DISCARD_LEAST_CHG:\n\tcase ASB_DISCARD_LOCAL:\n\tcase ASB_DISCARD_REMOTE:\n\tcase ASB_CONSENSUS:\n\tcase ASB_DISCARD_SECONDARY:\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_VIOLENTLY:\n\t\trv = drbd_asb_recover_0p(peer_device);\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_CALL_HELPER:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1) {\n\t\t\tenum drbd_state_rv rv2;\n\n\t\t\t  \n\t\t\trv2 = drbd_change_state(device, CS_VERBOSE, NS(role, R_SECONDARY));\n\t\t\tif (rv2 != SS_SUCCESS) {\n\t\t\t\tdrbd_khelper(device, \"pri-lost-after-sb\");\n\t\t\t} else {\n\t\t\t\tdrbd_warn(device, \"Successfully gave up primary role.\\n\");\n\t\t\t\trv = hg;\n\t\t\t}\n\t\t} else\n\t\t\trv = hg;\n\t}\n\n\treturn rv;\n}\n\nstatic void drbd_uuid_dump(struct drbd_device *device, char *text, u64 *uuid,\n\t\t\t   u64 bits, u64 flags)\n{\n\tif (!uuid) {\n\t\tdrbd_info(device, \"%s uuid info vanished while I was looking!\\n\", text);\n\t\treturn;\n\t}\n\tdrbd_info(device, \"%s %016llX:%016llX:%016llX:%016llX bits:%llu flags:%llX\\n\",\n\t     text,\n\t     (unsigned long long)uuid[UI_CURRENT],\n\t     (unsigned long long)uuid[UI_BITMAP],\n\t     (unsigned long long)uuid[UI_HISTORY_START],\n\t     (unsigned long long)uuid[UI_HISTORY_END],\n\t     (unsigned long long)bits,\n\t     (unsigned long long)flags);\n}\n\n \n\nstatic int drbd_uuid_compare(struct drbd_peer_device *const peer_device,\n\t\tenum drbd_role const peer_role, int *rule_nr) __must_hold(local)\n{\n\tstruct drbd_connection *const connection = peer_device->connection;\n\tstruct drbd_device *device = peer_device->device;\n\tu64 self, peer;\n\tint i, j;\n\n\tself = device->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\n\t*rule_nr = 10;\n\tif (self == UUID_JUST_CREATED && peer == UUID_JUST_CREATED)\n\t\treturn 0;\n\n\t*rule_nr = 20;\n\tif ((self == UUID_JUST_CREATED || self == (u64)0) &&\n\t     peer != UUID_JUST_CREATED)\n\t\treturn -2;\n\n\t*rule_nr = 30;\n\tif (self != UUID_JUST_CREATED &&\n\t    (peer == UUID_JUST_CREATED || peer == (u64)0))\n\t\treturn 2;\n\n\tif (self == peer) {\n\t\tint rct, dc;  \n\n\t\tif (device->p_uuid[UI_BITMAP] == (u64)0 && device->ldev->md.uuid[UI_BITMAP] != (u64)0) {\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tif ((device->ldev->md.uuid[UI_BITMAP] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START] & ~((u64)1)) &&\n\t\t\t    (device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START + 1] & ~((u64)1))) {\n\t\t\t\tdrbd_info(device, \"was SyncSource, missed the resync finished event, corrected myself:\\n\");\n\t\t\t\tdrbd_uuid_move_history(device);\n\t\t\t\tdevice->ldev->md.uuid[UI_HISTORY_START] = device->ldev->md.uuid[UI_BITMAP];\n\t\t\t\tdevice->ldev->md.uuid[UI_BITMAP] = 0;\n\n\t\t\t\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid,\n\t\t\t\t\t       device->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(device) : 0, 0);\n\t\t\t\t*rule_nr = 34;\n\t\t\t} else {\n\t\t\t\tdrbd_info(device, \"was SyncSource (peer failed to write sync_uuid)\\n\");\n\t\t\t\t*rule_nr = 36;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (device->ldev->md.uuid[UI_BITMAP] == (u64)0 && device->p_uuid[UI_BITMAP] != (u64)0) {\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tif ((device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (device->p_uuid[UI_BITMAP] & ~((u64)1)) &&\n\t\t\t    (device->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START] & ~((u64)1))) {\n\t\t\t\tdrbd_info(device, \"was SyncTarget, peer missed the resync finished event, corrected peer:\\n\");\n\n\t\t\t\tdevice->p_uuid[UI_HISTORY_START + 1] = device->p_uuid[UI_HISTORY_START];\n\t\t\t\tdevice->p_uuid[UI_HISTORY_START] = device->p_uuid[UI_BITMAP];\n\t\t\t\tdevice->p_uuid[UI_BITMAP] = 0UL;\n\n\t\t\t\tdrbd_uuid_dump(device, \"peer\", device->p_uuid, device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\t\t\t\t*rule_nr = 35;\n\t\t\t} else {\n\t\t\t\tdrbd_info(device, \"was SyncTarget (failed to write sync_uuid)\\n\");\n\t\t\t\t*rule_nr = 37;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\trct = (test_bit(CRASHED_PRIMARY, &device->flags) ? 1 : 0) +\n\t\t\t(device->p_uuid[UI_FLAGS] & 2);\n\t\t \n\t\t*rule_nr = 40;\n\n\t\t \n\t\tif (rct == 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (device->state.role == R_PRIMARY || peer_role == R_PRIMARY) {\n\t\t\t*rule_nr = 41;\n\t\t\tif (!(connection->agreed_features & DRBD_FF_WSAME)) {\n\t\t\t\tdrbd_warn(peer_device, \"Equivalent unrotated UUIDs, but current primary present.\\n\");\n\t\t\t\treturn -(0x10000 | PRO_VERSION_MAX | (DRBD_FF_WSAME << 8));\n\t\t\t}\n\t\t\tif (device->state.role == R_PRIMARY && peer_role == R_PRIMARY) {\n\t\t\t\t \n\t\t\t\tdrbd_err(peer_device, \"Equivalent unrotated UUIDs, but both are primary. Can not resolve this.\\n\");\n\t\t\t\treturn -100;\n\t\t\t}\n\t\t\tif (device->state.role == R_PRIMARY)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tswitch (rct) {\n\t\tcase 0:   return 0;  \n\t\tcase 1:   return 1;\n\t\tcase 2:   return -1;\n\t\tcase 3:  \n\t\t\tdc = test_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\treturn dc ? -1 : 1;\n\t\t}\n\t}\n\n\t*rule_nr = 50;\n\tpeer = device->p_uuid[UI_BITMAP] & ~((u64)1);\n\tif (self == peer)\n\t\treturn -1;\n\n\t*rule_nr = 51;\n\tpeer = device->p_uuid[UI_HISTORY_START] & ~((u64)1);\n\tif (self == peer) {\n\t\tif (connection->agreed_pro_version < 96 ?\n\t\t    (device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) ==\n\t\t    (device->p_uuid[UI_HISTORY_START + 1] & ~((u64)1)) :\n\t\t    peer + UUID_NEW_BM_OFFSET == (device->p_uuid[UI_BITMAP] & ~((u64)1))) {\n\t\t\t \n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tdevice->p_uuid[UI_BITMAP] = device->p_uuid[UI_HISTORY_START];\n\t\t\tdevice->p_uuid[UI_HISTORY_START] = device->p_uuid[UI_HISTORY_START + 1];\n\n\t\t\tdrbd_info(device, \"Lost last syncUUID packet, corrected:\\n\");\n\t\t\tdrbd_uuid_dump(device, \"peer\", device->p_uuid, device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t*rule_nr = 60;\n\tself = device->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tpeer = device->p_uuid[i] & ~((u64)1);\n\t\tif (self == peer)\n\t\t\treturn -2;\n\t}\n\n\t*rule_nr = 70;\n\tself = device->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\tif (self == peer)\n\t\treturn 1;\n\n\t*rule_nr = 71;\n\tself = device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1);\n\tif (self == peer) {\n\t\tif (connection->agreed_pro_version < 96 ?\n\t\t    (device->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) ==\n\t\t    (device->p_uuid[UI_HISTORY_START] & ~((u64)1)) :\n\t\t    self + UUID_NEW_BM_OFFSET == (device->ldev->md.uuid[UI_BITMAP] & ~((u64)1))) {\n\t\t\t \n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\t__drbd_uuid_set(device, UI_BITMAP, device->ldev->md.uuid[UI_HISTORY_START]);\n\t\t\t__drbd_uuid_set(device, UI_HISTORY_START, device->ldev->md.uuid[UI_HISTORY_START + 1]);\n\n\t\t\tdrbd_info(device, \"Last syncUUID did not get through, corrected:\\n\");\n\t\t\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid,\n\t\t\t\t       device->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(device) : 0, 0);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\t*rule_nr = 80;\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tself = device->ldev->md.uuid[i] & ~((u64)1);\n\t\tif (self == peer)\n\t\t\treturn 2;\n\t}\n\n\t*rule_nr = 90;\n\tself = device->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\n\tpeer = device->p_uuid[UI_BITMAP] & ~((u64)1);\n\tif (self == peer && self != ((u64)0))\n\t\treturn 100;\n\n\t*rule_nr = 100;\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tself = device->ldev->md.uuid[i] & ~((u64)1);\n\t\tfor (j = UI_HISTORY_START; j <= UI_HISTORY_END; j++) {\n\t\t\tpeer = device->p_uuid[j] & ~((u64)1);\n\t\t\tif (self == peer)\n\t\t\t\treturn -100;\n\t\t}\n\t}\n\n\treturn -1000;\n}\n\n \nstatic enum drbd_conns drbd_sync_handshake(struct drbd_peer_device *peer_device,\n\t\t\t\t\t   enum drbd_role peer_role,\n\t\t\t\t\t   enum drbd_disk_state peer_disk) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tenum drbd_conns rv = C_MASK;\n\tenum drbd_disk_state mydisk;\n\tstruct net_conf *nc;\n\tint hg, rule_nr, rr_conflict, tentative, always_asbp;\n\n\tmydisk = device->state.disk;\n\tif (mydisk == D_NEGOTIATING)\n\t\tmydisk = device->new_state_tmp.disk;\n\n\tdrbd_info(device, \"drbd_sync_handshake:\\n\");\n\n\tspin_lock_irq(&device->ldev->md.uuid_lock);\n\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid, device->comm_bm_set, 0);\n\tdrbd_uuid_dump(device, \"peer\", device->p_uuid,\n\t\t       device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\n\thg = drbd_uuid_compare(peer_device, peer_role, &rule_nr);\n\tspin_unlock_irq(&device->ldev->md.uuid_lock);\n\n\tdrbd_info(device, \"uuid_compare()=%d by rule %d\\n\", hg, rule_nr);\n\n\tif (hg == -1000) {\n\t\tdrbd_alert(device, \"Unrelated data, aborting!\\n\");\n\t\treturn C_MASK;\n\t}\n\tif (hg < -0x10000) {\n\t\tint proto, fflags;\n\t\thg = -hg;\n\t\tproto = hg & 0xff;\n\t\tfflags = (hg >> 8) & 0xff;\n\t\tdrbd_alert(device, \"To resolve this both sides have to support at least protocol %d and feature flags 0x%x\\n\",\n\t\t\t\t\tproto, fflags);\n\t\treturn C_MASK;\n\t}\n\tif (hg < -1000) {\n\t\tdrbd_alert(device, \"To resolve this both sides have to support at least protocol %d\\n\", -hg - 1000);\n\t\treturn C_MASK;\n\t}\n\n\tif    ((mydisk == D_INCONSISTENT && peer_disk > D_INCONSISTENT) ||\n\t    (peer_disk == D_INCONSISTENT && mydisk    > D_INCONSISTENT)) {\n\t\tint f = (hg == -100) || abs(hg) == 2;\n\t\thg = mydisk > D_INCONSISTENT ? 1 : -1;\n\t\tif (f)\n\t\t\thg = hg*2;\n\t\tdrbd_info(device, \"Becoming sync %s due to disk states.\\n\",\n\t\t     hg > 0 ? \"source\" : \"target\");\n\t}\n\n\tif (abs(hg) == 100)\n\t\tdrbd_khelper(device, \"initial-split-brain\");\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\talways_asbp = nc->always_asbp;\n\trr_conflict = nc->rr_conflict;\n\ttentative = nc->tentative;\n\trcu_read_unlock();\n\n\tif (hg == 100 || (hg == -100 && always_asbp)) {\n\t\tint pcount = (device->state.role == R_PRIMARY)\n\t\t\t   + (peer_role == R_PRIMARY);\n\t\tint forced = (hg == -100);\n\n\t\tswitch (pcount) {\n\t\tcase 0:\n\t\t\thg = drbd_asb_recover_0p(peer_device);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thg = drbd_asb_recover_1p(peer_device);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\thg = drbd_asb_recover_2p(peer_device);\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(hg) < 100) {\n\t\t\tdrbd_warn(device, \"Split-Brain detected, %d primaries, \"\n\t\t\t     \"automatically solved. Sync from %s node\\n\",\n\t\t\t     pcount, (hg < 0) ? \"peer\" : \"this\");\n\t\t\tif (forced) {\n\t\t\t\tdrbd_warn(device, \"Doing a full sync, since\"\n\t\t\t\t     \" UUIDs where ambiguous.\\n\");\n\t\t\t\thg = hg*2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hg == -100) {\n\t\tif (test_bit(DISCARD_MY_DATA, &device->flags) && !(device->p_uuid[UI_FLAGS]&1))\n\t\t\thg = -1;\n\t\tif (!test_bit(DISCARD_MY_DATA, &device->flags) && (device->p_uuid[UI_FLAGS]&1))\n\t\t\thg = 1;\n\n\t\tif (abs(hg) < 100)\n\t\t\tdrbd_warn(device, \"Split-Brain detected, manually solved. \"\n\t\t\t     \"Sync from %s node\\n\",\n\t\t\t     (hg < 0) ? \"peer\" : \"this\");\n\t}\n\n\tif (hg == -100) {\n\t\t \n\t\tdrbd_alert(device, \"Split-Brain detected but unresolved, dropping connection!\\n\");\n\t\tdrbd_khelper(device, \"split-brain\");\n\t\treturn C_MASK;\n\t}\n\n\tif (hg > 0 && mydisk <= D_INCONSISTENT) {\n\t\tdrbd_err(device, \"I shall become SyncSource, but I am inconsistent!\\n\");\n\t\treturn C_MASK;\n\t}\n\n\tif (hg < 0 &&  \n\t    device->state.role == R_PRIMARY && device->state.disk >= D_CONSISTENT) {\n\t\tswitch (rr_conflict) {\n\t\tcase ASB_CALL_HELPER:\n\t\t\tdrbd_khelper(device, \"pri-lost\");\n\t\t\tfallthrough;\n\t\tcase ASB_DISCONNECT:\n\t\t\tdrbd_err(device, \"I shall become SyncTarget, but I am primary!\\n\");\n\t\t\treturn C_MASK;\n\t\tcase ASB_VIOLENTLY:\n\t\t\tdrbd_warn(device, \"Becoming SyncTarget, violating the stable-data\"\n\t\t\t     \"assumption\\n\");\n\t\t}\n\t}\n\n\tif (tentative || test_bit(CONN_DRY_RUN, &peer_device->connection->flags)) {\n\t\tif (hg == 0)\n\t\t\tdrbd_info(device, \"dry-run connect: No resync, would become Connected immediately.\\n\");\n\t\telse\n\t\t\tdrbd_info(device, \"dry-run connect: Would become %s, doing a %s resync.\",\n\t\t\t\t drbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET),\n\t\t\t\t abs(hg) >= 2 ? \"full\" : \"bit-map based\");\n\t\treturn C_MASK;\n\t}\n\n\tif (abs(hg) >= 2) {\n\t\tdrbd_info(device, \"Writing the whole bitmap, full sync required after drbd_sync_handshake.\\n\");\n\t\tif (drbd_bitmap_io(device, &drbd_bmio_set_n_write, \"set_n_write from sync_handshake\",\n\t\t\t\t\tBM_LOCKED_SET_ALLOWED, NULL))\n\t\t\treturn C_MASK;\n\t}\n\n\tif (hg > 0) {  \n\t\trv = C_WF_BITMAP_S;\n\t} else if (hg < 0) {  \n\t\trv = C_WF_BITMAP_T;\n\t} else {\n\t\trv = C_CONNECTED;\n\t\tif (drbd_bm_total_weight(device)) {\n\t\t\tdrbd_info(device, \"No resync, but %lu bits in bitmap!\\n\",\n\t\t\t     drbd_bm_total_weight(device));\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic enum drbd_after_sb_p convert_after_sb(enum drbd_after_sb_p peer)\n{\n\t \n\tif (peer == ASB_DISCARD_REMOTE)\n\t\treturn ASB_DISCARD_LOCAL;\n\n\t \n\tif (peer == ASB_DISCARD_LOCAL)\n\t\treturn ASB_DISCARD_REMOTE;\n\n\t \n\treturn peer;\n}\n\nstatic int receive_protocol(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_protocol *p = pi->data;\n\tenum drbd_after_sb_p p_after_sb_0p, p_after_sb_1p, p_after_sb_2p;\n\tint p_proto, p_discard_my_data, p_two_primaries, cf;\n\tstruct net_conf *nc, *old_net_conf, *new_net_conf = NULL;\n\tchar integrity_alg[SHARED_SECRET_MAX] = \"\";\n\tstruct crypto_shash *peer_integrity_tfm = NULL;\n\tvoid *int_dig_in = NULL, *int_dig_vv = NULL;\n\n\tp_proto\t\t= be32_to_cpu(p->protocol);\n\tp_after_sb_0p\t= be32_to_cpu(p->after_sb_0p);\n\tp_after_sb_1p\t= be32_to_cpu(p->after_sb_1p);\n\tp_after_sb_2p\t= be32_to_cpu(p->after_sb_2p);\n\tp_two_primaries = be32_to_cpu(p->two_primaries);\n\tcf\t\t= be32_to_cpu(p->conn_flags);\n\tp_discard_my_data = cf & CF_DISCARD_MY_DATA;\n\n\tif (connection->agreed_pro_version >= 87) {\n\t\tint err;\n\n\t\tif (pi->size > sizeof(integrity_alg))\n\t\t\treturn -EIO;\n\t\terr = drbd_recv_all(connection, integrity_alg, pi->size);\n\t\tif (err)\n\t\t\treturn err;\n\t\tintegrity_alg[SHARED_SECRET_MAX - 1] = 0;\n\t}\n\n\tif (pi->cmd != P_PROTOCOL_UPDATE) {\n\t\tclear_bit(CONN_DRY_RUN, &connection->flags);\n\n\t\tif (cf & CF_DRY_RUN)\n\t\t\tset_bit(CONN_DRY_RUN, &connection->flags);\n\n\t\trcu_read_lock();\n\t\tnc = rcu_dereference(connection->net_conf);\n\n\t\tif (p_proto != nc->wire_protocol) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"protocol\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_0p) != nc->after_sb_0p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-0pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_1p) != nc->after_sb_1p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-1pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_2p) != nc->after_sb_2p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-2pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (p_discard_my_data && nc->discard_my_data) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"discard-my-data\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (p_two_primaries != nc->two_primaries) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"allow-two-primaries\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (strcmp(integrity_alg, nc->integrity_alg)) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"data-integrity-alg\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\trcu_read_unlock();\n\t}\n\n\tif (integrity_alg[0]) {\n\t\tint hash_size;\n\n\t\t \n\n\t\tpeer_integrity_tfm = crypto_alloc_shash(integrity_alg, 0, 0);\n\t\tif (IS_ERR(peer_integrity_tfm)) {\n\t\t\tpeer_integrity_tfm = NULL;\n\t\t\tdrbd_err(connection, \"peer data-integrity-alg %s not supported\\n\",\n\t\t\t\t integrity_alg);\n\t\t\tgoto disconnect;\n\t\t}\n\n\t\thash_size = crypto_shash_digestsize(peer_integrity_tfm);\n\t\tint_dig_in = kmalloc(hash_size, GFP_KERNEL);\n\t\tint_dig_vv = kmalloc(hash_size, GFP_KERNEL);\n\t\tif (!(int_dig_in && int_dig_vv)) {\n\t\t\tdrbd_err(connection, \"Allocation of buffers for data integrity checking failed\\n\");\n\t\t\tgoto disconnect;\n\t\t}\n\t}\n\n\tnew_net_conf = kmalloc(sizeof(struct net_conf), GFP_KERNEL);\n\tif (!new_net_conf)\n\t\tgoto disconnect;\n\n\tmutex_lock(&connection->data.mutex);\n\tmutex_lock(&connection->resource->conf_update);\n\told_net_conf = connection->net_conf;\n\t*new_net_conf = *old_net_conf;\n\n\tnew_net_conf->wire_protocol = p_proto;\n\tnew_net_conf->after_sb_0p = convert_after_sb(p_after_sb_0p);\n\tnew_net_conf->after_sb_1p = convert_after_sb(p_after_sb_1p);\n\tnew_net_conf->after_sb_2p = convert_after_sb(p_after_sb_2p);\n\tnew_net_conf->two_primaries = p_two_primaries;\n\n\trcu_assign_pointer(connection->net_conf, new_net_conf);\n\tmutex_unlock(&connection->resource->conf_update);\n\tmutex_unlock(&connection->data.mutex);\n\n\tcrypto_free_shash(connection->peer_integrity_tfm);\n\tkfree(connection->int_dig_in);\n\tkfree(connection->int_dig_vv);\n\tconnection->peer_integrity_tfm = peer_integrity_tfm;\n\tconnection->int_dig_in = int_dig_in;\n\tconnection->int_dig_vv = int_dig_vv;\n\n\tif (strcmp(old_net_conf->integrity_alg, integrity_alg))\n\t\tdrbd_info(connection, \"peer data-integrity-alg: %s\\n\",\n\t\t\t  integrity_alg[0] ? integrity_alg : \"(none)\");\n\n\tkvfree_rcu_mightsleep(old_net_conf);\n\treturn 0;\n\ndisconnect_rcu_unlock:\n\trcu_read_unlock();\ndisconnect:\n\tcrypto_free_shash(peer_integrity_tfm);\n\tkfree(int_dig_in);\n\tkfree(int_dig_vv);\n\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\treturn -EIO;\n}\n\n \nstatic struct crypto_shash *drbd_crypto_alloc_digest_safe(\n\t\tconst struct drbd_device *device,\n\t\tconst char *alg, const char *name)\n{\n\tstruct crypto_shash *tfm;\n\n\tif (!alg[0])\n\t\treturn NULL;\n\n\ttfm = crypto_alloc_shash(alg, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tdrbd_err(device, \"Can not allocate \\\"%s\\\" as %s (reason: %ld)\\n\",\n\t\t\talg, name, PTR_ERR(tfm));\n\t\treturn tfm;\n\t}\n\treturn tfm;\n}\n\nstatic int ignore_remaining_packet(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tint size = pi->size;\n\n\twhile (size) {\n\t\tint s = min_t(int, size, DRBD_SOCKET_BUFFER_SIZE);\n\t\ts = drbd_recv(connection, buffer, s);\n\t\tif (s <= 0) {\n\t\t\tif (s < 0)\n\t\t\t\treturn s;\n\t\t\tbreak;\n\t\t}\n\t\tsize -= s;\n\t}\n\tif (size)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int config_unknown_volume(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tdrbd_warn(connection, \"%s packet received for volume %u, which is not configured locally\\n\",\n\t\t  cmdname(pi->cmd), pi->vnr);\n\treturn ignore_remaining_packet(connection, pi);\n}\n\nstatic int receive_SyncParam(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_rs_param_95 *p;\n\tunsigned int header_size, data_size, exp_max_sz;\n\tstruct crypto_shash *verify_tfm = NULL;\n\tstruct crypto_shash *csums_tfm = NULL;\n\tstruct net_conf *old_net_conf, *new_net_conf = NULL;\n\tstruct disk_conf *old_disk_conf = NULL, *new_disk_conf = NULL;\n\tconst int apv = connection->agreed_pro_version;\n\tstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\n\tunsigned int fifo_size = 0;\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\texp_max_sz  = apv <= 87 ? sizeof(struct p_rs_param)\n\t\t    : apv == 88 ? sizeof(struct p_rs_param)\n\t\t\t\t\t+ SHARED_SECRET_MAX\n\t\t    : apv <= 94 ? sizeof(struct p_rs_param_89)\n\t\t    :   sizeof(struct p_rs_param_95);\n\n\tif (pi->size > exp_max_sz) {\n\t\tdrbd_err(device, \"SyncParam packet too long: received %u, expected <= %u bytes\\n\",\n\t\t    pi->size, exp_max_sz);\n\t\treturn -EIO;\n\t}\n\n\tif (apv <= 88) {\n\t\theader_size = sizeof(struct p_rs_param);\n\t\tdata_size = pi->size - header_size;\n\t} else if (apv <= 94) {\n\t\theader_size = sizeof(struct p_rs_param_89);\n\t\tdata_size = pi->size - header_size;\n\t\tD_ASSERT(device, data_size == 0);\n\t} else {\n\t\theader_size = sizeof(struct p_rs_param_95);\n\t\tdata_size = pi->size - header_size;\n\t\tD_ASSERT(device, data_size == 0);\n\t}\n\n\t \n\tp = pi->data;\n\tBUILD_BUG_ON(sizeof(p->algs) != 2 * SHARED_SECRET_MAX);\n\tmemset(&p->algs, 0, sizeof(p->algs));\n\n\terr = drbd_recv_all(peer_device->connection, p, header_size);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&connection->resource->conf_update);\n\told_net_conf = peer_device->connection->net_conf;\n\tif (get_ldev(device)) {\n\t\tnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\n\t\tif (!new_disk_conf) {\n\t\t\tput_ldev(device);\n\t\t\tmutex_unlock(&connection->resource->conf_update);\n\t\t\tdrbd_err(device, \"Allocation of new disk_conf failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\told_disk_conf = device->ldev->disk_conf;\n\t\t*new_disk_conf = *old_disk_conf;\n\n\t\tnew_disk_conf->resync_rate = be32_to_cpu(p->resync_rate);\n\t}\n\n\tif (apv >= 88) {\n\t\tif (apv == 88) {\n\t\t\tif (data_size > SHARED_SECRET_MAX || data_size == 0) {\n\t\t\t\tdrbd_err(device, \"verify-alg of wrong size, \"\n\t\t\t\t\t\"peer wants %u, accepting only up to %u byte\\n\",\n\t\t\t\t\tdata_size, SHARED_SECRET_MAX);\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\n\t\t\terr = drbd_recv_all(peer_device->connection, p->verify_alg, data_size);\n\t\t\tif (err)\n\t\t\t\tgoto reconnect;\n\t\t\t \n\t\t\t \n\t\t\tD_ASSERT(device, p->verify_alg[data_size-1] == 0);\n\t\t\tp->verify_alg[data_size-1] = 0;\n\n\t\t} else   {\n\t\t\t \n\t\t\t \n\t\t\tD_ASSERT(device, p->verify_alg[SHARED_SECRET_MAX-1] == 0);\n\t\t\tD_ASSERT(device, p->csums_alg[SHARED_SECRET_MAX-1] == 0);\n\t\t\tp->verify_alg[SHARED_SECRET_MAX-1] = 0;\n\t\t\tp->csums_alg[SHARED_SECRET_MAX-1] = 0;\n\t\t}\n\n\t\tif (strcmp(old_net_conf->verify_alg, p->verify_alg)) {\n\t\t\tif (device->state.conn == C_WF_REPORT_PARAMS) {\n\t\t\t\tdrbd_err(device, \"Different verify-alg settings. me=\\\"%s\\\" peer=\\\"%s\\\"\\n\",\n\t\t\t\t    old_net_conf->verify_alg, p->verify_alg);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\tverify_tfm = drbd_crypto_alloc_digest_safe(device,\n\t\t\t\t\tp->verify_alg, \"verify-alg\");\n\t\t\tif (IS_ERR(verify_tfm)) {\n\t\t\t\tverify_tfm = NULL;\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t}\n\n\t\tif (apv >= 89 && strcmp(old_net_conf->csums_alg, p->csums_alg)) {\n\t\t\tif (device->state.conn == C_WF_REPORT_PARAMS) {\n\t\t\t\tdrbd_err(device, \"Different csums-alg settings. me=\\\"%s\\\" peer=\\\"%s\\\"\\n\",\n\t\t\t\t    old_net_conf->csums_alg, p->csums_alg);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\tcsums_tfm = drbd_crypto_alloc_digest_safe(device,\n\t\t\t\t\tp->csums_alg, \"csums-alg\");\n\t\t\tif (IS_ERR(csums_tfm)) {\n\t\t\t\tcsums_tfm = NULL;\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t}\n\n\t\tif (apv > 94 && new_disk_conf) {\n\t\t\tnew_disk_conf->c_plan_ahead = be32_to_cpu(p->c_plan_ahead);\n\t\t\tnew_disk_conf->c_delay_target = be32_to_cpu(p->c_delay_target);\n\t\t\tnew_disk_conf->c_fill_target = be32_to_cpu(p->c_fill_target);\n\t\t\tnew_disk_conf->c_max_rate = be32_to_cpu(p->c_max_rate);\n\n\t\t\tfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\n\t\t\tif (fifo_size != device->rs_plan_s->size) {\n\t\t\t\tnew_plan = fifo_alloc(fifo_size);\n\t\t\t\tif (!new_plan) {\n\t\t\t\t\tdrbd_err(device, \"kmalloc of fifo_buffer failed\");\n\t\t\t\t\tput_ldev(device);\n\t\t\t\t\tgoto disconnect;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (verify_tfm || csums_tfm) {\n\t\t\tnew_net_conf = kzalloc(sizeof(struct net_conf), GFP_KERNEL);\n\t\t\tif (!new_net_conf)\n\t\t\t\tgoto disconnect;\n\n\t\t\t*new_net_conf = *old_net_conf;\n\n\t\t\tif (verify_tfm) {\n\t\t\t\tstrcpy(new_net_conf->verify_alg, p->verify_alg);\n\t\t\t\tnew_net_conf->verify_alg_len = strlen(p->verify_alg) + 1;\n\t\t\t\tcrypto_free_shash(peer_device->connection->verify_tfm);\n\t\t\t\tpeer_device->connection->verify_tfm = verify_tfm;\n\t\t\t\tdrbd_info(device, \"using verify-alg: \\\"%s\\\"\\n\", p->verify_alg);\n\t\t\t}\n\t\t\tif (csums_tfm) {\n\t\t\t\tstrcpy(new_net_conf->csums_alg, p->csums_alg);\n\t\t\t\tnew_net_conf->csums_alg_len = strlen(p->csums_alg) + 1;\n\t\t\t\tcrypto_free_shash(peer_device->connection->csums_tfm);\n\t\t\t\tpeer_device->connection->csums_tfm = csums_tfm;\n\t\t\t\tdrbd_info(device, \"using csums-alg: \\\"%s\\\"\\n\", p->csums_alg);\n\t\t\t}\n\t\t\trcu_assign_pointer(connection->net_conf, new_net_conf);\n\t\t}\n\t}\n\n\tif (new_disk_conf) {\n\t\trcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\n\t\tput_ldev(device);\n\t}\n\n\tif (new_plan) {\n\t\told_plan = device->rs_plan_s;\n\t\trcu_assign_pointer(device->rs_plan_s, new_plan);\n\t}\n\n\tmutex_unlock(&connection->resource->conf_update);\n\tsynchronize_rcu();\n\tif (new_net_conf)\n\t\tkfree(old_net_conf);\n\tkfree(old_disk_conf);\n\tkfree(old_plan);\n\n\treturn 0;\n\nreconnect:\n\tif (new_disk_conf) {\n\t\tput_ldev(device);\n\t\tkfree(new_disk_conf);\n\t}\n\tmutex_unlock(&connection->resource->conf_update);\n\treturn -EIO;\n\ndisconnect:\n\tkfree(new_plan);\n\tif (new_disk_conf) {\n\t\tput_ldev(device);\n\t\tkfree(new_disk_conf);\n\t}\n\tmutex_unlock(&connection->resource->conf_update);\n\t \n\tcrypto_free_shash(csums_tfm);\n\t \n\tcrypto_free_shash(verify_tfm);\n\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\treturn -EIO;\n}\n\n \nstatic void warn_if_differ_considerably(struct drbd_device *device,\n\tconst char *s, sector_t a, sector_t b)\n{\n\tsector_t d;\n\tif (a == 0 || b == 0)\n\t\treturn;\n\td = (a > b) ? (a - b) : (b - a);\n\tif (d > (a>>3) || d > (b>>3))\n\t\tdrbd_warn(device, \"Considerable difference in %s: %llus vs. %llus\\n\", s,\n\t\t     (unsigned long long)a, (unsigned long long)b);\n}\n\nstatic int receive_sizes(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_sizes *p = pi->data;\n\tstruct o_qlim *o = (connection->agreed_features & DRBD_FF_WSAME) ? p->qlim : NULL;\n\tenum determine_dev_size dd = DS_UNCHANGED;\n\tsector_t p_size, p_usize, p_csize, my_usize;\n\tsector_t new_size, cur_size;\n\tint ldsc = 0;  \n\tenum dds_flags ddsf;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\tcur_size = get_capacity(device->vdisk);\n\n\tp_size = be64_to_cpu(p->d_size);\n\tp_usize = be64_to_cpu(p->u_size);\n\tp_csize = be64_to_cpu(p->c_size);\n\n\t \n\tdevice->p_size = p_size;\n\n\tif (get_ldev(device)) {\n\t\trcu_read_lock();\n\t\tmy_usize = rcu_dereference(device->ldev->disk_conf)->disk_size;\n\t\trcu_read_unlock();\n\n\t\twarn_if_differ_considerably(device, \"lower level device sizes\",\n\t\t\t   p_size, drbd_get_max_capacity(device->ldev));\n\t\twarn_if_differ_considerably(device, \"user requested size\",\n\t\t\t\t\t    p_usize, my_usize);\n\n\t\t \n\t\tif (device->state.conn == C_WF_REPORT_PARAMS)\n\t\t\tp_usize = min_not_zero(my_usize, p_usize);\n\n\t\t \n\t\tnew_size = drbd_new_dev_size(device, device->ldev, p_usize, 0);\n\t\tif (new_size < cur_size &&\n\t\t    device->state.disk >= D_OUTDATED &&\n\t\t    (device->state.conn < C_CONNECTED || device->state.pdsk == D_DISKLESS)) {\n\t\t\tdrbd_err(device, \"The peer's disk size is too small! (%llu < %llu sectors)\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\tput_ldev(device);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (my_usize != p_usize) {\n\t\t\tstruct disk_conf *old_disk_conf, *new_disk_conf = NULL;\n\n\t\t\tnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\n\t\t\tif (!new_disk_conf) {\n\t\t\t\tput_ldev(device);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tmutex_lock(&connection->resource->conf_update);\n\t\t\told_disk_conf = device->ldev->disk_conf;\n\t\t\t*new_disk_conf = *old_disk_conf;\n\t\t\tnew_disk_conf->disk_size = p_usize;\n\n\t\t\trcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\n\t\t\tmutex_unlock(&connection->resource->conf_update);\n\t\t\tkvfree_rcu_mightsleep(old_disk_conf);\n\n\t\t\tdrbd_info(device, \"Peer sets u_size to %lu sectors (old: %lu)\\n\",\n\t\t\t\t (unsigned long)p_usize, (unsigned long)my_usize);\n\t\t}\n\n\t\tput_ldev(device);\n\t}\n\n\tdevice->peer_max_bio_size = be32_to_cpu(p->max_bio_size);\n\t \n\n\tddsf = be16_to_cpu(p->dds_flags);\n\tif (get_ldev(device)) {\n\t\tdrbd_reconsider_queue_parameters(device, device->ldev, o);\n\t\tdd = drbd_determine_dev_size(device, ddsf, NULL);\n\t\tput_ldev(device);\n\t\tif (dd == DS_ERROR)\n\t\t\treturn -EIO;\n\t\tdrbd_md_sync(device);\n\t} else {\n\t\t \n\t\tsector_t new_size = p_csize ?: p_usize ?: p_size;\n\t\tdrbd_reconsider_queue_parameters(device, NULL, o);\n\t\tif (new_size == 0) {\n\t\t\t \n\t\t} else if (new_size == cur_size) {\n\t\t\t \n\t\t} else if (cur_size != 0 && p_size == 0) {\n\t\t\tdrbd_warn(device, \"Ignored diskless peer device size (peer:%llu != me:%llu sectors)!\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t} else if (new_size < cur_size && device->state.role == R_PRIMARY) {\n\t\t\tdrbd_err(device, \"The peer's device size is too small! (%llu < %llu sectors); demote me first!\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\treturn -EIO;\n\t\t} else {\n\t\t\t \n\t\t\tdrbd_set_my_capacity(device, new_size);\n\t\t}\n\t}\n\n\tif (get_ldev(device)) {\n\t\tif (device->ldev->known_size != drbd_get_capacity(device->ldev->backing_bdev)) {\n\t\t\tdevice->ldev->known_size = drbd_get_capacity(device->ldev->backing_bdev);\n\t\t\tldsc = 1;\n\t\t}\n\n\t\tput_ldev(device);\n\t}\n\n\tif (device->state.conn > C_WF_REPORT_PARAMS) {\n\t\tif (be64_to_cpu(p->c_size) != get_capacity(device->vdisk) ||\n\t\t    ldsc) {\n\t\t\t \n\t\t\tdrbd_send_sizes(peer_device, 0, ddsf);\n\t\t}\n\t\tif (test_and_clear_bit(RESIZE_PENDING, &device->flags) ||\n\t\t    (dd == DS_GREW && device->state.conn == C_CONNECTED)) {\n\t\t\tif (device->state.pdsk >= D_INCONSISTENT &&\n\t\t\t    device->state.disk >= D_INCONSISTENT) {\n\t\t\t\tif (ddsf & DDSF_NO_RESYNC)\n\t\t\t\t\tdrbd_info(device, \"Resync of new storage suppressed with --assume-clean\\n\");\n\t\t\t\telse\n\t\t\t\t\tresync_after_online_grow(device);\n\t\t\t} else\n\t\t\t\tset_bit(RESYNC_AFTER_NEG, &device->flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int receive_uuids(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_uuids *p = pi->data;\n\tu64 *p_uuid;\n\tint i, updated_uuids = 0;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\tp_uuid = kmalloc_array(UI_EXTENDED_SIZE, sizeof(*p_uuid), GFP_NOIO);\n\tif (!p_uuid)\n\t\treturn false;\n\n\tfor (i = UI_CURRENT; i < UI_EXTENDED_SIZE; i++)\n\t\tp_uuid[i] = be64_to_cpu(p->uuid[i]);\n\n\tkfree(device->p_uuid);\n\tdevice->p_uuid = p_uuid;\n\n\tif ((device->state.conn < C_CONNECTED || device->state.pdsk == D_DISKLESS) &&\n\t    device->state.disk < D_INCONSISTENT &&\n\t    device->state.role == R_PRIMARY &&\n\t    (device->ed_uuid & ~((u64)1)) != (p_uuid[UI_CURRENT] & ~((u64)1))) {\n\t\tdrbd_err(device, \"Can only connect to data with current UUID=%016llX\\n\",\n\t\t    (unsigned long long)device->ed_uuid);\n\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\treturn -EIO;\n\t}\n\n\tif (get_ldev(device)) {\n\t\tint skip_initial_sync =\n\t\t\tdevice->state.conn == C_CONNECTED &&\n\t\t\tpeer_device->connection->agreed_pro_version >= 90 &&\n\t\t\tdevice->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED &&\n\t\t\t(p_uuid[UI_FLAGS] & 8);\n\t\tif (skip_initial_sync) {\n\t\t\tdrbd_info(device, \"Accepted new current UUID, preparing to skip initial sync\\n\");\n\t\t\tdrbd_bitmap_io(device, &drbd_bmio_clear_n_write,\n\t\t\t\t\t\"clear_n_write from receive_uuids\",\n\t\t\t\t\tBM_LOCKED_TEST_ALLOWED, NULL);\n\t\t\t_drbd_uuid_set(device, UI_CURRENT, p_uuid[UI_CURRENT]);\n\t\t\t_drbd_uuid_set(device, UI_BITMAP, 0);\n\t\t\t_drbd_set_state(_NS2(device, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\n\t\t\t\t\tCS_VERBOSE, NULL);\n\t\t\tdrbd_md_sync(device);\n\t\t\tupdated_uuids = 1;\n\t\t}\n\t\tput_ldev(device);\n\t} else if (device->state.disk < D_INCONSISTENT &&\n\t\t   device->state.role == R_PRIMARY) {\n\t\t \n\t\tupdated_uuids = drbd_set_ed_uuid(device, p_uuid[UI_CURRENT]);\n\t}\n\n\t \n\tmutex_lock(device->state_mutex);\n\tmutex_unlock(device->state_mutex);\n\tif (device->state.conn >= C_CONNECTED && device->state.disk < D_INCONSISTENT)\n\t\tupdated_uuids |= drbd_set_ed_uuid(device, p_uuid[UI_CURRENT]);\n\n\tif (updated_uuids)\n\t\tdrbd_print_uuids(device, \"receiver updated UUIDs to\");\n\n\treturn 0;\n}\n\n \nstatic union drbd_state convert_state(union drbd_state ps)\n{\n\tunion drbd_state ms;\n\n\tstatic enum drbd_conns c_tab[] = {\n\t\t[C_WF_REPORT_PARAMS] = C_WF_REPORT_PARAMS,\n\t\t[C_CONNECTED] = C_CONNECTED,\n\n\t\t[C_STARTING_SYNC_S] = C_STARTING_SYNC_T,\n\t\t[C_STARTING_SYNC_T] = C_STARTING_SYNC_S,\n\t\t[C_DISCONNECTING] = C_TEAR_DOWN,  \n\t\t[C_VERIFY_S]       = C_VERIFY_T,\n\t\t[C_MASK]   = C_MASK,\n\t};\n\n\tms.i = ps.i;\n\n\tms.conn = c_tab[ps.conn];\n\tms.peer = ps.role;\n\tms.role = ps.peer;\n\tms.pdsk = ps.disk;\n\tms.disk = ps.pdsk;\n\tms.peer_isp = (ps.aftr_isp | ps.user_isp);\n\n\treturn ms;\n}\n\nstatic int receive_req_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_req_state *p = pi->data;\n\tunion drbd_state mask, val;\n\tenum drbd_state_rv rv;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tmask.i = be32_to_cpu(p->mask);\n\tval.i = be32_to_cpu(p->val);\n\n\tif (test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags) &&\n\t    mutex_is_locked(device->state_mutex)) {\n\t\tdrbd_send_sr_reply(peer_device, SS_CONCURRENT_ST_CHG);\n\t\treturn 0;\n\t}\n\n\tmask = convert_state(mask);\n\tval = convert_state(val);\n\n\trv = drbd_change_state(device, CS_VERBOSE, mask, val);\n\tdrbd_send_sr_reply(peer_device, rv);\n\n\tdrbd_md_sync(device);\n\n\treturn 0;\n}\n\nstatic int receive_req_conn_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_req_state *p = pi->data;\n\tunion drbd_state mask, val;\n\tenum drbd_state_rv rv;\n\n\tmask.i = be32_to_cpu(p->mask);\n\tval.i = be32_to_cpu(p->val);\n\n\tif (test_bit(RESOLVE_CONFLICTS, &connection->flags) &&\n\t    mutex_is_locked(&connection->cstate_mutex)) {\n\t\tconn_send_sr_reply(connection, SS_CONCURRENT_ST_CHG);\n\t\treturn 0;\n\t}\n\n\tmask = convert_state(mask);\n\tval = convert_state(val);\n\n\trv = conn_request_state(connection, mask, val, CS_VERBOSE | CS_LOCAL_ONLY | CS_IGN_OUTD_FAIL);\n\tconn_send_sr_reply(connection, rv);\n\n\treturn 0;\n}\n\nstatic int receive_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_state *p = pi->data;\n\tunion drbd_state os, ns, peer_state;\n\tenum drbd_disk_state real_peer_disk;\n\tenum chg_state_flags cs_flags;\n\tint rv;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\tpeer_state.i = be32_to_cpu(p->state);\n\n\treal_peer_disk = peer_state.disk;\n\tif (peer_state.disk == D_NEGOTIATING) {\n\t\treal_peer_disk = device->p_uuid[UI_FLAGS] & 4 ? D_INCONSISTENT : D_CONSISTENT;\n\t\tdrbd_info(device, \"real peer disk state = %s\\n\", drbd_disk_str(real_peer_disk));\n\t}\n\n\tspin_lock_irq(&device->resource->req_lock);\n retry:\n\tos = ns = drbd_read_state(device);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\t \n\tif (os.conn <= C_TEAR_DOWN)\n\t\treturn -ECONNRESET;\n\n\t \n\tif ((os.pdsk == D_INCONSISTENT || os.pdsk == D_CONSISTENT) &&\n\t    real_peer_disk == D_UP_TO_DATE &&\n\t    os.conn > C_CONNECTED && os.disk == D_UP_TO_DATE) {\n\t\t \n\t\tif (peer_state.conn > C_CONNECTED &&\n\t\t    peer_state.conn < C_SYNC_SOURCE)\n\t\t\treal_peer_disk = D_INCONSISTENT;\n\n\t\t \n\t\telse if (os.conn >= C_SYNC_SOURCE &&\n\t\t\t peer_state.conn == C_CONNECTED) {\n\t\t\tif (drbd_bm_total_weight(device) <= device->rs_failed)\n\t\t\t\tdrbd_resync_finished(peer_device);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (os.conn == C_VERIFY_T && os.disk == D_UP_TO_DATE &&\n\t    peer_state.conn == C_CONNECTED && real_peer_disk == D_UP_TO_DATE) {\n\t\tov_out_of_sync_print(peer_device);\n\t\tdrbd_resync_finished(peer_device);\n\t\treturn 0;\n\t}\n\n\t \n\tif (os.pdsk == D_UP_TO_DATE && real_peer_disk == D_INCONSISTENT &&\n\t    os.conn == C_CONNECTED && peer_state.conn > C_SYNC_SOURCE)\n\t\treal_peer_disk = D_UP_TO_DATE;\n\n\tif (ns.conn == C_WF_REPORT_PARAMS)\n\t\tns.conn = C_CONNECTED;\n\n\tif (peer_state.conn == C_AHEAD)\n\t\tns.conn = C_BEHIND;\n\n\t \n\n\tif (device->p_uuid && peer_state.disk >= D_NEGOTIATING &&\n\t    get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\tint cr;  \n\n\t\t \n\t\tcr  = (os.conn < C_CONNECTED);\n\t\t \n\t\tcr |= (os.conn == C_CONNECTED &&\n\t\t       (peer_state.disk == D_NEGOTIATING ||\n\t\t\tos.disk == D_NEGOTIATING));\n\t\t \n\t\tcr |= test_bit(CONSIDER_RESYNC, &device->flags);\n\t\t \n\t\tcr |= (os.conn == C_CONNECTED &&\n\t\t\t\t(peer_state.conn >= C_STARTING_SYNC_S &&\n\t\t\t\t peer_state.conn <= C_WF_BITMAP_T));\n\n\t\tif (cr)\n\t\t\tns.conn = drbd_sync_handshake(peer_device, peer_state.role, real_peer_disk);\n\n\t\tput_ldev(device);\n\t\tif (ns.conn == C_MASK) {\n\t\t\tns.conn = C_CONNECTED;\n\t\t\tif (device->state.disk == D_NEGOTIATING) {\n\t\t\t\tdrbd_force_state(device, NS(disk, D_FAILED));\n\t\t\t} else if (peer_state.disk == D_NEGOTIATING) {\n\t\t\t\tdrbd_err(device, \"Disk attach process on the peer node was aborted.\\n\");\n\t\t\t\tpeer_state.disk = D_DISKLESS;\n\t\t\t\treal_peer_disk = D_DISKLESS;\n\t\t\t} else {\n\t\t\t\tif (test_and_clear_bit(CONN_DRY_RUN, &peer_device->connection->flags))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tD_ASSERT(device, os.conn == C_WF_REPORT_PARAMS);\n\t\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tif (os.i != drbd_read_state(device).i)\n\t\tgoto retry;\n\tclear_bit(CONSIDER_RESYNC, &device->flags);\n\tns.peer = peer_state.role;\n\tns.pdsk = real_peer_disk;\n\tns.peer_isp = (peer_state.aftr_isp | peer_state.user_isp);\n\tif ((ns.conn == C_CONNECTED || ns.conn == C_WF_BITMAP_S) && ns.disk == D_NEGOTIATING)\n\t\tns.disk = device->new_state_tmp.disk;\n\tcs_flags = CS_VERBOSE + (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED ? 0 : CS_HARD);\n\tif (ns.pdsk == D_CONSISTENT && drbd_suspended(device) && ns.conn == C_CONNECTED && os.conn < C_CONNECTED &&\n\t    test_bit(NEW_CUR_UUID, &device->flags)) {\n\t\t \n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tdrbd_err(device, \"Aborting Connect, can not thaw IO with an only Consistent peer\\n\");\n\t\ttl_clear(peer_device->connection);\n\t\tdrbd_uuid_new_current(device);\n\t\tclear_bit(NEW_CUR_UUID, &device->flags);\n\t\tconn_request_state(peer_device->connection, NS2(conn, C_PROTOCOL_ERROR, susp, 0), CS_HARD);\n\t\treturn -EIO;\n\t}\n\trv = _drbd_set_state(device, ns, cs_flags, NULL);\n\tns = drbd_read_state(device);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (rv < SS_SUCCESS) {\n\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\treturn -EIO;\n\t}\n\n\tif (os.conn > C_WF_REPORT_PARAMS) {\n\t\tif (ns.conn > C_CONNECTED && peer_state.conn <= C_CONNECTED &&\n\t\t    peer_state.disk != D_NEGOTIATING ) {\n\t\t\t \n\t\t\t \n\t\t\tdrbd_send_uuids(peer_device);\n\t\t\tdrbd_send_current_state(peer_device);\n\t\t}\n\t}\n\n\tclear_bit(DISCARD_MY_DATA, &device->flags);\n\n\tdrbd_md_sync(device);  \n\n\treturn 0;\n}\n\nstatic int receive_sync_uuid(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_rs_uuid *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\twait_event(device->misc_wait,\n\t\t   device->state.conn == C_WF_SYNC_UUID ||\n\t\t   device->state.conn == C_BEHIND ||\n\t\t   device->state.conn < C_CONNECTED ||\n\t\t   device->state.disk < D_NEGOTIATING);\n\n\t \n\n\t \n\tif (get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\t_drbd_uuid_set(device, UI_CURRENT, be64_to_cpu(p->uuid));\n\t\t_drbd_uuid_set(device, UI_BITMAP, 0UL);\n\n\t\tdrbd_print_uuids(device, \"updated sync uuid\");\n\t\tdrbd_start_resync(device, C_SYNC_TARGET);\n\n\t\tput_ldev(device);\n\t} else\n\t\tdrbd_err(device, \"Ignoring SyncUUID packet!\\n\");\n\n\treturn 0;\n}\n\n \nstatic int\nreceive_bitmap_plain(struct drbd_peer_device *peer_device, unsigned int size,\n\t\t     unsigned long *p, struct bm_xfer_ctx *c)\n{\n\tunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE -\n\t\t\t\t drbd_header_size(peer_device->connection);\n\tunsigned int num_words = min_t(size_t, data_size / sizeof(*p),\n\t\t\t\t       c->bm_words - c->word_offset);\n\tunsigned int want = num_words * sizeof(*p);\n\tint err;\n\n\tif (want != size) {\n\t\tdrbd_err(peer_device, \"%s:want (%u) != size (%u)\\n\", __func__, want, size);\n\t\treturn -EIO;\n\t}\n\tif (want == 0)\n\t\treturn 0;\n\terr = drbd_recv_all(peer_device->connection, p, want);\n\tif (err)\n\t\treturn err;\n\n\tdrbd_bm_merge_lel(peer_device->device, c->word_offset, num_words, p);\n\n\tc->word_offset += num_words;\n\tc->bit_offset = c->word_offset * BITS_PER_LONG;\n\tif (c->bit_offset > c->bm_bits)\n\t\tc->bit_offset = c->bm_bits;\n\n\treturn 1;\n}\n\nstatic enum drbd_bitmap_code dcbp_get_code(struct p_compressed_bm *p)\n{\n\treturn (enum drbd_bitmap_code)(p->encoding & 0x0f);\n}\n\nstatic int dcbp_get_start(struct p_compressed_bm *p)\n{\n\treturn (p->encoding & 0x80) != 0;\n}\n\nstatic int dcbp_get_pad_bits(struct p_compressed_bm *p)\n{\n\treturn (p->encoding >> 4) & 0x7;\n}\n\n \nstatic int\nrecv_bm_rle_bits(struct drbd_peer_device *peer_device,\n\t\tstruct p_compressed_bm *p,\n\t\t struct bm_xfer_ctx *c,\n\t\t unsigned int len)\n{\n\tstruct bitstream bs;\n\tu64 look_ahead;\n\tu64 rl;\n\tu64 tmp;\n\tunsigned long s = c->bit_offset;\n\tunsigned long e;\n\tint toggle = dcbp_get_start(p);\n\tint have;\n\tint bits;\n\n\tbitstream_init(&bs, p->code, len, dcbp_get_pad_bits(p));\n\n\tbits = bitstream_get_bits(&bs, &look_ahead, 64);\n\tif (bits < 0)\n\t\treturn -EIO;\n\n\tfor (have = bits; have > 0; s += rl, toggle = !toggle) {\n\t\tbits = vli_decode_bits(&rl, look_ahead);\n\t\tif (bits <= 0)\n\t\t\treturn -EIO;\n\n\t\tif (toggle) {\n\t\t\te = s + rl -1;\n\t\t\tif (e >= c->bm_bits) {\n\t\t\t\tdrbd_err(peer_device, \"bitmap overflow (e:%lu) while decoding bm RLE packet\\n\", e);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\t_drbd_bm_set_bits(peer_device->device, s, e);\n\t\t}\n\n\t\tif (have < bits) {\n\t\t\tdrbd_err(peer_device, \"bitmap decoding error: h:%d b:%d la:0x%08llx l:%u/%u\\n\",\n\t\t\t\thave, bits, look_ahead,\n\t\t\t\t(unsigned int)(bs.cur.b - p->code),\n\t\t\t\t(unsigned int)bs.buf_len);\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tif (likely(bits < 64))\n\t\t\tlook_ahead >>= bits;\n\t\telse\n\t\t\tlook_ahead = 0;\n\t\thave -= bits;\n\n\t\tbits = bitstream_get_bits(&bs, &tmp, 64 - have);\n\t\tif (bits < 0)\n\t\t\treturn -EIO;\n\t\tlook_ahead |= tmp << have;\n\t\thave += bits;\n\t}\n\n\tc->bit_offset = s;\n\tbm_xfer_ctx_bit_to_word_offset(c);\n\n\treturn (s != c->bm_bits);\n}\n\n \nstatic int\ndecode_bitmap_c(struct drbd_peer_device *peer_device,\n\t\tstruct p_compressed_bm *p,\n\t\tstruct bm_xfer_ctx *c,\n\t\tunsigned int len)\n{\n\tif (dcbp_get_code(p) == RLE_VLI_Bits)\n\t\treturn recv_bm_rle_bits(peer_device, p, c, len - sizeof(*p));\n\n\t \n\n\tdrbd_err(peer_device, \"receive_bitmap_c: unknown encoding %u\\n\", p->encoding);\n\tconn_request_state(peer_device->connection, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\n\treturn -EIO;\n}\n\nvoid INFO_bm_xfer_stats(struct drbd_peer_device *peer_device,\n\t\tconst char *direction, struct bm_xfer_ctx *c)\n{\n\t \n\tunsigned int header_size = drbd_header_size(peer_device->connection);\n\tunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE - header_size;\n\tunsigned int plain =\n\t\theader_size * (DIV_ROUND_UP(c->bm_words, data_size) + 1) +\n\t\tc->bm_words * sizeof(unsigned long);\n\tunsigned int total = c->bytes[0] + c->bytes[1];\n\tunsigned int r;\n\n\t \n\tif (total == 0)\n\t\treturn;\n\n\t \n\tif (total >= plain)\n\t\treturn;\n\n\t \n\tr = (total > UINT_MAX/1000) ? (total / (plain/1000))\n\t\t                    : (1000 * total / plain);\n\n\tif (r > 1000)\n\t\tr = 1000;\n\n\tr = 1000 - r;\n\tdrbd_info(peer_device, \"%s bitmap stats [Bytes(packets)]: plain %u(%u), RLE %u(%u), \"\n\t     \"total %u; compression: %u.%u%%\\n\",\n\t\t\tdirection,\n\t\t\tc->bytes[1], c->packets[1],\n\t\t\tc->bytes[0], c->packets[0],\n\t\t\ttotal, r/10, r % 10);\n}\n\n \nstatic int receive_bitmap(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct bm_xfer_ctx c;\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tdrbd_bm_lock(device, \"receive bitmap\", BM_LOCKED_SET_ALLOWED);\n\t \n\n\tc = (struct bm_xfer_ctx) {\n\t\t.bm_bits = drbd_bm_bits(device),\n\t\t.bm_words = drbd_bm_words(device),\n\t};\n\n\tfor(;;) {\n\t\tif (pi->cmd == P_BITMAP)\n\t\t\terr = receive_bitmap_plain(peer_device, pi->size, pi->data, &c);\n\t\telse if (pi->cmd == P_COMPRESSED_BITMAP) {\n\t\t\t \n\t\t\tstruct p_compressed_bm *p = pi->data;\n\n\t\t\tif (pi->size > DRBD_SOCKET_BUFFER_SIZE - drbd_header_size(connection)) {\n\t\t\t\tdrbd_err(device, \"ReportCBitmap packet too large\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (pi->size <= sizeof(*p)) {\n\t\t\t\tdrbd_err(device, \"ReportCBitmap packet too small (l:%u)\\n\", pi->size);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = drbd_recv_all(peer_device->connection, p, pi->size);\n\t\t\tif (err)\n\t\t\t       goto out;\n\t\t\terr = decode_bitmap_c(peer_device, p, &c, pi->size);\n\t\t} else {\n\t\t\tdrbd_warn(device, \"receive_bitmap: cmd neither ReportBitMap nor ReportCBitMap (is 0x%x)\", pi->cmd);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tc.packets[pi->cmd == P_BITMAP]++;\n\t\tc.bytes[pi->cmd == P_BITMAP] += drbd_header_size(connection) + pi->size;\n\n\t\tif (err <= 0) {\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\terr = drbd_recv_header(peer_device->connection, pi);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tINFO_bm_xfer_stats(peer_device, \"receive\", &c);\n\n\tif (device->state.conn == C_WF_BITMAP_T) {\n\t\tenum drbd_state_rv rv;\n\n\t\terr = drbd_send_bitmap(device, peer_device);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t \n\t\trv = _drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\n\t\tD_ASSERT(device, rv == SS_SUCCESS);\n\t} else if (device->state.conn != C_WF_BITMAP_S) {\n\t\t \n\t\tdrbd_info(device, \"unexpected cstate (%s) in receive_bitmap\\n\",\n\t\t    drbd_conn_str(device->state.conn));\n\t}\n\terr = 0;\n\n out:\n\tdrbd_bm_unlock(device);\n\tif (!err && device->state.conn == C_WF_BITMAP_S)\n\t\tdrbd_start_resync(device, C_SYNC_SOURCE);\n\treturn err;\n}\n\nstatic int receive_skip(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tdrbd_warn(connection, \"skipping unknown optional packet type %d, l: %d!\\n\",\n\t\t pi->cmd, pi->size);\n\n\treturn ignore_remaining_packet(connection, pi);\n}\n\nstatic int receive_UnplugRemote(struct drbd_connection *connection, struct packet_info *pi)\n{\n\t \n\ttcp_sock_set_quickack(connection->data.socket->sk, 2);\n\treturn 0;\n}\n\nstatic int receive_out_of_sync(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_desc *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tswitch (device->state.conn) {\n\tcase C_WF_SYNC_UUID:\n\tcase C_WF_BITMAP_T:\n\tcase C_BEHIND:\n\t\t\tbreak;\n\tdefault:\n\t\tdrbd_err(device, \"ASSERT FAILED cstate = %s, expected: WFSyncUUID|WFBitMapT|Behind\\n\",\n\t\t\t\tdrbd_conn_str(device->state.conn));\n\t}\n\n\tdrbd_set_out_of_sync(peer_device, be64_to_cpu(p->sector), be32_to_cpu(p->blksize));\n\n\treturn 0;\n}\n\nstatic int receive_rs_deallocated(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct p_block_desc *p = pi->data;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint size, err = 0;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tdec_rs_pending(peer_device);\n\n\tif (get_ldev(device)) {\n\t\tstruct drbd_peer_request *peer_req;\n\n\t\tpeer_req = drbd_alloc_peer_req(peer_device, ID_SYNCER, sector,\n\t\t\t\t\t       size, 0, GFP_NOIO);\n\t\tif (!peer_req) {\n\t\t\tput_ldev(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpeer_req->w.cb = e_end_resync_block;\n\t\tpeer_req->opf = REQ_OP_DISCARD;\n\t\tpeer_req->submit_jif = jiffies;\n\t\tpeer_req->flags |= EE_TRIM;\n\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tlist_add_tail(&peer_req->w.list, &device->sync_ee);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\n\t\tatomic_add(pi->size >> 9, &device->rs_sect_ev);\n\t\terr = drbd_submit_peer_request(peer_req);\n\n\t\tif (err) {\n\t\t\tspin_lock_irq(&device->resource->req_lock);\n\t\t\tlist_del(&peer_req->w.list);\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\tput_ldev(device);\n\t\t\terr = 0;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tinc_unacked(device);\n\n\t\t \n\t} else {\n\tfail:\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tdrbd_send_ack_ex(peer_device, P_NEG_ACK, sector, size, ID_SYNCER);\n\t}\n\n\tatomic_add(size >> 9, &device->rs_sect_in);\n\n\treturn err;\n}\n\nstruct data_cmd {\n\tint expect_payload;\n\tunsigned int pkt_size;\n\tint (*fn)(struct drbd_connection *, struct packet_info *);\n};\n\nstatic struct data_cmd drbd_cmd_handler[] = {\n\t[P_DATA]\t    = { 1, sizeof(struct p_data), receive_Data },\n\t[P_DATA_REPLY]\t    = { 1, sizeof(struct p_data), receive_DataReply },\n\t[P_RS_DATA_REPLY]   = { 1, sizeof(struct p_data), receive_RSDataReply } ,\n\t[P_BARRIER]\t    = { 0, sizeof(struct p_barrier), receive_Barrier } ,\n\t[P_BITMAP]\t    = { 1, 0, receive_bitmap } ,\n\t[P_COMPRESSED_BITMAP] = { 1, 0, receive_bitmap } ,\n\t[P_UNPLUG_REMOTE]   = { 0, 0, receive_UnplugRemote },\n\t[P_DATA_REQUEST]    = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_RS_DATA_REQUEST] = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_SYNC_PARAM]\t    = { 1, 0, receive_SyncParam },\n\t[P_SYNC_PARAM89]    = { 1, 0, receive_SyncParam },\n\t[P_PROTOCOL]        = { 1, sizeof(struct p_protocol), receive_protocol },\n\t[P_UUIDS]\t    = { 0, sizeof(struct p_uuids), receive_uuids },\n\t[P_SIZES]\t    = { 0, sizeof(struct p_sizes), receive_sizes },\n\t[P_STATE]\t    = { 0, sizeof(struct p_state), receive_state },\n\t[P_STATE_CHG_REQ]   = { 0, sizeof(struct p_req_state), receive_req_state },\n\t[P_SYNC_UUID]       = { 0, sizeof(struct p_rs_uuid), receive_sync_uuid },\n\t[P_OV_REQUEST]      = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_OV_REPLY]        = { 1, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_CSUM_RS_REQUEST] = { 1, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_RS_THIN_REQ]     = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_DELAY_PROBE]     = { 0, sizeof(struct p_delay_probe93), receive_skip },\n\t[P_OUT_OF_SYNC]     = { 0, sizeof(struct p_block_desc), receive_out_of_sync },\n\t[P_CONN_ST_CHG_REQ] = { 0, sizeof(struct p_req_state), receive_req_conn_state },\n\t[P_PROTOCOL_UPDATE] = { 1, sizeof(struct p_protocol), receive_protocol },\n\t[P_TRIM]\t    = { 0, sizeof(struct p_trim), receive_Data },\n\t[P_ZEROES]\t    = { 0, sizeof(struct p_trim), receive_Data },\n\t[P_RS_DEALLOCATED]  = { 0, sizeof(struct p_block_desc), receive_rs_deallocated },\n};\n\nstatic void drbdd(struct drbd_connection *connection)\n{\n\tstruct packet_info pi;\n\tsize_t shs;  \n\tint err;\n\n\twhile (get_t_state(&connection->receiver) == RUNNING) {\n\t\tstruct data_cmd const *cmd;\n\n\t\tdrbd_thread_current_set_cpu(&connection->receiver);\n\t\tupdate_receiver_timing_details(connection, drbd_recv_header_maybe_unplug);\n\t\tif (drbd_recv_header_maybe_unplug(connection, &pi))\n\t\t\tgoto err_out;\n\n\t\tcmd = &drbd_cmd_handler[pi.cmd];\n\t\tif (unlikely(pi.cmd >= ARRAY_SIZE(drbd_cmd_handler) || !cmd->fn)) {\n\t\t\tdrbd_err(connection, \"Unexpected data packet %s (0x%04x)\",\n\t\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tshs = cmd->pkt_size;\n\t\tif (pi.cmd == P_SIZES && connection->agreed_features & DRBD_FF_WSAME)\n\t\t\tshs += sizeof(struct o_qlim);\n\t\tif (pi.size > shs && !cmd->expect_payload) {\n\t\t\tdrbd_err(connection, \"No payload expected %s l:%d\\n\",\n\t\t\t\t cmdname(pi.cmd), pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (pi.size < shs) {\n\t\t\tdrbd_err(connection, \"%s: unexpected packet size, expected:%d received:%d\\n\",\n\t\t\t\t cmdname(pi.cmd), (int)shs, pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (shs) {\n\t\t\tupdate_receiver_timing_details(connection, drbd_recv_all_warn);\n\t\t\terr = drbd_recv_all_warn(connection, pi.data, shs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tpi.size -= shs;\n\t\t}\n\n\t\tupdate_receiver_timing_details(connection, cmd->fn);\n\t\terr = cmd->fn(connection, &pi);\n\t\tif (err) {\n\t\t\tdrbd_err(connection, \"error receiving %s, e: %d l: %d!\\n\",\n\t\t\t\t cmdname(pi.cmd), err, pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\treturn;\n\n    err_out:\n\tconn_request_state(connection, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\n}\n\nstatic void conn_disconnect(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tenum drbd_conns oc;\n\tint vnr;\n\n\tif (connection->cstate == C_STANDALONE)\n\t\treturn;\n\n\t \n\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\n\t \n\tdrbd_thread_stop(&connection->ack_receiver);\n\tif (connection->ack_sender) {\n\t\tdestroy_workqueue(connection->ack_sender);\n\t\tconnection->ack_sender = NULL;\n\t}\n\tdrbd_free_sock(connection);\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_disconnected(peer_device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\tif (!list_empty(&connection->current_epoch->list))\n\t\tdrbd_err(connection, \"ASSERTION FAILED: connection->current_epoch->list not empty\\n\");\n\t \n\tatomic_set(&connection->current_epoch->epoch_size, 0);\n\tconnection->send.seen_any_write_yet = false;\n\n\tdrbd_info(connection, \"Connection closed\\n\");\n\n\tif (conn_highest_role(connection) == R_PRIMARY && conn_highest_pdsk(connection) >= D_UNKNOWN)\n\t\tconn_try_outdate_peer_async(connection);\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\toc = connection->cstate;\n\tif (oc >= C_UNCONNECTED)\n\t\t_conn_request_state(connection, NS(conn, C_UNCONNECTED), CS_VERBOSE);\n\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\tif (oc == C_DISCONNECTING)\n\t\tconn_request_state(connection, NS(conn, C_STANDALONE), CS_VERBOSE | CS_HARD);\n}\n\nstatic int drbd_disconnected(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned int i;\n\n\t \n\tspin_lock_irq(&device->resource->req_lock);\n\t_drbd_wait_ee_list_empty(device, &device->active_ee);\n\t_drbd_wait_ee_list_empty(device, &device->sync_ee);\n\t_drbd_wait_ee_list_empty(device, &device->read_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\t \n\tdrbd_rs_cancel_all(device);\n\tdevice->rs_total = 0;\n\tdevice->rs_failed = 0;\n\tatomic_set(&device->rs_pending_cnt, 0);\n\twake_up(&device->misc_wait);\n\n\tdel_timer_sync(&device->resync_timer);\n\tresync_timer_fn(&device->resync_timer);\n\n\t \n\tdrbd_flush_workqueue(&peer_device->connection->sender_work);\n\n\tdrbd_finish_peer_reqs(device);\n\n\t \n\tdrbd_flush_workqueue(&peer_device->connection->sender_work);\n\n\t \n\tdrbd_rs_cancel_all(device);\n\n\tkfree(device->p_uuid);\n\tdevice->p_uuid = NULL;\n\n\tif (!drbd_suspended(device))\n\t\ttl_clear(peer_device->connection);\n\n\tdrbd_md_sync(device);\n\n\tif (get_ldev(device)) {\n\t\tdrbd_bitmap_io(device, &drbd_bm_write_copy_pages,\n\t\t\t\t\"write from disconnected\", BM_LOCKED_CHANGE_ALLOWED, NULL);\n\t\tput_ldev(device);\n\t}\n\n\t \n\ti = drbd_free_peer_reqs(device, &device->net_ee);\n\tif (i)\n\t\tdrbd_info(device, \"net_ee not empty, killed %u entries\\n\", i);\n\ti = atomic_read(&device->pp_in_use_by_net);\n\tif (i)\n\t\tdrbd_info(device, \"pp_in_use_by_net = %d, expected 0\\n\", i);\n\ti = atomic_read(&device->pp_in_use);\n\tif (i)\n\t\tdrbd_info(device, \"pp_in_use = %d, expected 0\\n\", i);\n\n\tD_ASSERT(device, list_empty(&device->read_ee));\n\tD_ASSERT(device, list_empty(&device->active_ee));\n\tD_ASSERT(device, list_empty(&device->sync_ee));\n\tD_ASSERT(device, list_empty(&device->done_ee));\n\n\treturn 0;\n}\n\n \nstatic int drbd_send_features(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_connection_features *p;\n\n\tsock = &connection->data;\n\tp = conn_prepare_command(connection, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tmemset(p, 0, sizeof(*p));\n\tp->protocol_min = cpu_to_be32(PRO_VERSION_MIN);\n\tp->protocol_max = cpu_to_be32(PRO_VERSION_MAX);\n\tp->feature_flags = cpu_to_be32(PRO_FEATURES);\n\treturn conn_send_command(connection, sock, P_CONNECTION_FEATURES, sizeof(*p), NULL, 0);\n}\n\n \nstatic int drbd_do_features(struct drbd_connection *connection)\n{\n\t \n\tstruct p_connection_features *p;\n\tconst int expect = sizeof(struct p_connection_features);\n\tstruct packet_info pi;\n\tint err;\n\n\terr = drbd_send_features(connection);\n\tif (err)\n\t\treturn 0;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err)\n\t\treturn 0;\n\n\tif (pi.cmd != P_CONNECTION_FEATURES) {\n\t\tdrbd_err(connection, \"expected ConnectionFeatures packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\treturn -1;\n\t}\n\n\tif (pi.size != expect) {\n\t\tdrbd_err(connection, \"expected ConnectionFeatures length: %u, received: %u\\n\",\n\t\t     expect, pi.size);\n\t\treturn -1;\n\t}\n\n\tp = pi.data;\n\terr = drbd_recv_all_warn(connection, p, expect);\n\tif (err)\n\t\treturn 0;\n\n\tp->protocol_min = be32_to_cpu(p->protocol_min);\n\tp->protocol_max = be32_to_cpu(p->protocol_max);\n\tif (p->protocol_max == 0)\n\t\tp->protocol_max = p->protocol_min;\n\n\tif (PRO_VERSION_MAX < p->protocol_min ||\n\t    PRO_VERSION_MIN > p->protocol_max)\n\t\tgoto incompat;\n\n\tconnection->agreed_pro_version = min_t(int, PRO_VERSION_MAX, p->protocol_max);\n\tconnection->agreed_features = PRO_FEATURES & be32_to_cpu(p->feature_flags);\n\n\tdrbd_info(connection, \"Handshake successful: \"\n\t     \"Agreed network protocol version %d\\n\", connection->agreed_pro_version);\n\n\tdrbd_info(connection, \"Feature flags enabled on protocol level: 0x%x%s%s%s%s.\\n\",\n\t\t  connection->agreed_features,\n\t\t  connection->agreed_features & DRBD_FF_TRIM ? \" TRIM\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_THIN_RESYNC ? \" THIN_RESYNC\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_WSAME ? \" WRITE_SAME\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_WZEROES ? \" WRITE_ZEROES\" :\n\t\t  connection->agreed_features ? \"\" : \" none\");\n\n\treturn 1;\n\n incompat:\n\tdrbd_err(connection, \"incompatible DRBD dialects: \"\n\t    \"I support %d-%d, peer supports %d-%d\\n\",\n\t    PRO_VERSION_MIN, PRO_VERSION_MAX,\n\t    p->protocol_min, p->protocol_max);\n\treturn -1;\n}\n\n#if !defined(CONFIG_CRYPTO_HMAC) && !defined(CONFIG_CRYPTO_HMAC_MODULE)\nstatic int drbd_do_auth(struct drbd_connection *connection)\n{\n\tdrbd_err(connection, \"This kernel was build without CONFIG_CRYPTO_HMAC.\\n\");\n\tdrbd_err(connection, \"You need to disable 'cram-hmac-alg' in drbd.conf.\\n\");\n\treturn -1;\n}\n#else\n#define CHALLENGE_LEN 64\n\n \n\nstatic int drbd_do_auth(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\tchar my_challenge[CHALLENGE_LEN];   \n\tchar *response = NULL;\n\tchar *right_response = NULL;\n\tchar *peers_ch = NULL;\n\tunsigned int key_len;\n\tchar secret[SHARED_SECRET_MAX];  \n\tunsigned int resp_size;\n\tstruct shash_desc *desc;\n\tstruct packet_info pi;\n\tstruct net_conf *nc;\n\tint err, rv;\n\n\t \n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tkey_len = strlen(nc->shared_secret);\n\tmemcpy(secret, nc->shared_secret, key_len);\n\trcu_read_unlock();\n\n\tdesc = kmalloc(sizeof(struct shash_desc) +\n\t\t       crypto_shash_descsize(connection->cram_hmac_tfm),\n\t\t       GFP_KERNEL);\n\tif (!desc) {\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\tdesc->tfm = connection->cram_hmac_tfm;\n\n\trv = crypto_shash_setkey(connection->cram_hmac_tfm, (u8 *)secret, key_len);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_shash_setkey() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tget_random_bytes(my_challenge, CHALLENGE_LEN);\n\n\tsock = &connection->data;\n\tif (!conn_prepare_command(connection, sock)) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\trv = !conn_send_command(connection, sock, P_AUTH_CHALLENGE, 0,\n\t\t\t\tmy_challenge, CHALLENGE_LEN);\n\tif (!rv)\n\t\tgoto fail;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.cmd != P_AUTH_CHALLENGE) {\n\t\tdrbd_err(connection, \"expected AuthChallenge packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size > CHALLENGE_LEN * 2) {\n\t\tdrbd_err(connection, \"expected AuthChallenge payload too big.\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size < CHALLENGE_LEN) {\n\t\tdrbd_err(connection, \"AuthChallenge payload too small.\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tpeers_ch = kmalloc(pi.size, GFP_NOIO);\n\tif (!peers_ch) {\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\terr = drbd_recv_all_warn(connection, peers_ch, pi.size);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (!memcmp(my_challenge, peers_ch, CHALLENGE_LEN)) {\n\t\tdrbd_err(connection, \"Peer presented the same challenge!\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tresp_size = crypto_shash_digestsize(connection->cram_hmac_tfm);\n\tresponse = kmalloc(resp_size, GFP_NOIO);\n\tif (!response) {\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = crypto_shash_digest(desc, peers_ch, pi.size, response);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_hash_digest() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (!conn_prepare_command(connection, sock)) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\trv = !conn_send_command(connection, sock, P_AUTH_RESPONSE, 0,\n\t\t\t\tresponse, resp_size);\n\tif (!rv)\n\t\tgoto fail;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.cmd != P_AUTH_RESPONSE) {\n\t\tdrbd_err(connection, \"expected AuthResponse packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size != resp_size) {\n\t\tdrbd_err(connection, \"expected AuthResponse payload of wrong size\\n\");\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\terr = drbd_recv_all_warn(connection, response , resp_size);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tright_response = kmalloc(resp_size, GFP_NOIO);\n\tif (!right_response) {\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = crypto_shash_digest(desc, my_challenge, CHALLENGE_LEN,\n\t\t\t\t right_response);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_hash_digest() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = !memcmp(response, right_response, resp_size);\n\n\tif (rv)\n\t\tdrbd_info(connection, \"Peer authenticated using %d bytes HMAC\\n\",\n\t\t     resp_size);\n\telse\n\t\trv = -1;\n\n fail:\n\tkfree(peers_ch);\n\tkfree(response);\n\tkfree(right_response);\n\tif (desc) {\n\t\tshash_desc_zero(desc);\n\t\tkfree(desc);\n\t}\n\n\treturn rv;\n}\n#endif\n\nint drbd_receiver(struct drbd_thread *thi)\n{\n\tstruct drbd_connection *connection = thi->connection;\n\tint h;\n\n\tdrbd_info(connection, \"receiver (re)started\\n\");\n\n\tdo {\n\t\th = conn_connect(connection);\n\t\tif (h == 0) {\n\t\t\tconn_disconnect(connection);\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\t}\n\t\tif (h == -1) {\n\t\t\tdrbd_warn(connection, \"Discarding network configuration.\\n\");\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t} while (h == 0);\n\n\tif (h > 0) {\n\t\tblk_start_plug(&connection->receiver_plug);\n\t\tdrbdd(connection);\n\t\tblk_finish_plug(&connection->receiver_plug);\n\t}\n\n\tconn_disconnect(connection);\n\n\tdrbd_info(connection, \"receiver terminated\\n\");\n\treturn 0;\n}\n\n \n\nstatic int got_conn_RqSReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_req_state_reply *p = pi->data;\n\tint retcode = be32_to_cpu(p->retcode);\n\n\tif (retcode >= SS_SUCCESS) {\n\t\tset_bit(CONN_WD_ST_CHG_OKAY, &connection->flags);\n\t} else {\n\t\tset_bit(CONN_WD_ST_CHG_FAIL, &connection->flags);\n\t\tdrbd_err(connection, \"Requested state change failed by peer: %s (%d)\\n\",\n\t\t\t drbd_set_st_err_str(retcode), retcode);\n\t}\n\twake_up(&connection->ping_wait);\n\n\treturn 0;\n}\n\nstatic int got_RqSReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_req_state_reply *p = pi->data;\n\tint retcode = be32_to_cpu(p->retcode);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tif (test_bit(CONN_WD_ST_CHG_REQ, &connection->flags)) {\n\t\tD_ASSERT(device, connection->agreed_pro_version < 100);\n\t\treturn got_conn_RqSReply(connection, pi);\n\t}\n\n\tif (retcode >= SS_SUCCESS) {\n\t\tset_bit(CL_ST_CHG_SUCCESS, &device->flags);\n\t} else {\n\t\tset_bit(CL_ST_CHG_FAIL, &device->flags);\n\t\tdrbd_err(device, \"Requested state change failed by peer: %s (%d)\\n\",\n\t\t\tdrbd_set_st_err_str(retcode), retcode);\n\t}\n\twake_up(&device->state_wait);\n\n\treturn 0;\n}\n\nstatic int got_Ping(struct drbd_connection *connection, struct packet_info *pi)\n{\n\treturn drbd_send_ping_ack(connection);\n\n}\n\nstatic int got_PingAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\t \n\tconnection->meta.socket->sk->sk_rcvtimeo = connection->net_conf->ping_int*HZ;\n\tif (!test_and_set_bit(GOT_PING_ACK, &connection->flags))\n\t\twake_up(&connection->ping_wait);\n\n\treturn 0;\n}\n\nstatic int got_IsInSync(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint blksize = be32_to_cpu(p->blksize);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tD_ASSERT(device, peer_device->connection->agreed_pro_version >= 89);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (get_ldev(device)) {\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tdrbd_set_in_sync(peer_device, sector, blksize);\n\t\t \n\t\tdevice->rs_same_csum += (blksize >> BM_BLOCK_SHIFT);\n\t\tput_ldev(device);\n\t}\n\tdec_rs_pending(peer_device);\n\tatomic_add(blksize >> 9, &device->rs_sect_in);\n\n\treturn 0;\n}\n\nstatic int\nvalidate_req_change_req_state(struct drbd_peer_device *peer_device, u64 id, sector_t sector,\n\t\t\t      struct rb_root *root, const char *func,\n\t\t\t      enum drbd_req_event what, bool missing_ok)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_request *req;\n\tstruct bio_and_error m;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treq = find_request(device, root, id, sector, missing_ok, func);\n\tif (unlikely(!req)) {\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\treturn -EIO;\n\t}\n\t__req_mod(req, what, peer_device, &m);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (m.bio)\n\t\tcomplete_master_bio(device, &m);\n\treturn 0;\n}\n\nstatic int got_BlockAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint blksize = be32_to_cpu(p->blksize);\n\tenum drbd_req_event what;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (p->block_id == ID_SYNCER) {\n\t\tdrbd_set_in_sync(peer_device, sector, blksize);\n\t\tdec_rs_pending(peer_device);\n\t\treturn 0;\n\t}\n\tswitch (pi->cmd) {\n\tcase P_RS_WRITE_ACK:\n\t\twhat = WRITE_ACKED_BY_PEER_AND_SIS;\n\t\tbreak;\n\tcase P_WRITE_ACK:\n\t\twhat = WRITE_ACKED_BY_PEER;\n\t\tbreak;\n\tcase P_RECV_ACK:\n\t\twhat = RECV_ACKED_BY_PEER;\n\t\tbreak;\n\tcase P_SUPERSEDED:\n\t\twhat = CONFLICT_RESOLVED;\n\t\tbreak;\n\tcase P_RETRY_WRITE:\n\t\twhat = POSTPONE_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn validate_req_change_req_state(peer_device, p->block_id, sector,\n\t\t\t\t\t     &device->write_requests, __func__,\n\t\t\t\t\t     what, false);\n}\n\nstatic int got_NegAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint size = be32_to_cpu(p->blksize);\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (p->block_id == ID_SYNCER) {\n\t\tdec_rs_pending(peer_device);\n\t\tdrbd_rs_failed_io(peer_device, sector, size);\n\t\treturn 0;\n\t}\n\n\terr = validate_req_change_req_state(peer_device, p->block_id, sector,\n\t\t\t\t\t    &device->write_requests, __func__,\n\t\t\t\t\t    NEG_ACKED, true);\n\tif (err) {\n\t\t \n\t\t \n\t\tdrbd_set_out_of_sync(peer_device, sector, size);\n\t}\n\treturn 0;\n}\n\nstatic int got_NegDReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tdrbd_err(device, \"Got NegDReply; Sector %llus, len %u.\\n\",\n\t    (unsigned long long)sector, be32_to_cpu(p->blksize));\n\n\treturn validate_req_change_req_state(peer_device, p->block_id, sector,\n\t\t\t\t\t     &device->read_requests, __func__,\n\t\t\t\t\t     NEG_ACKED, false);\n}\n\nstatic int got_NegRSDReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint size;\n\tstruct p_block_ack *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tdec_rs_pending(peer_device);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tswitch (pi->cmd) {\n\t\tcase P_NEG_RS_DREPLY:\n\t\t\tdrbd_rs_failed_io(peer_device, sector, size);\n\t\t\tbreak;\n\t\tcase P_RS_CANCEL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tput_ldev(device);\n\t}\n\n\treturn 0;\n}\n\nstatic int got_BarrierAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_barrier_ack *p = pi->data;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\ttl_release(connection, p->barrier, be32_to_cpu(p->set_size));\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\n\t\tif (device->state.conn == C_AHEAD &&\n\t\t    atomic_read(&device->ap_in_flight) == 0 &&\n\t\t    !test_and_set_bit(AHEAD_TO_SYNC_SOURCE, &device->flags)) {\n\t\t\tdevice->start_resync_timer.expires = jiffies + HZ;\n\t\t\tadd_timer(&device->start_resync_timer);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int got_OVResult(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tstruct drbd_device_work *dw;\n\tsector_t sector;\n\tint size;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (be64_to_cpu(p->block_id) == ID_OUT_OF_SYNC)\n\t\tdrbd_ov_out_of_sync_found(peer_device, sector, size);\n\telse\n\t\tov_out_of_sync_print(peer_device);\n\n\tif (!get_ldev(device))\n\t\treturn 0;\n\n\tdrbd_rs_complete_io(device, sector);\n\tdec_rs_pending(peer_device);\n\n\t--device->ov_left;\n\n\t \n\tif ((device->ov_left & 0x200) == 0x200)\n\t\tdrbd_advance_rs_marks(peer_device, device->ov_left);\n\n\tif (device->ov_left == 0) {\n\t\tdw = kmalloc(sizeof(*dw), GFP_NOIO);\n\t\tif (dw) {\n\t\t\tdw->w.cb = w_ov_finished;\n\t\t\tdw->device = device;\n\t\t\tdrbd_queue_work(&peer_device->connection->sender_work, &dw->w);\n\t\t} else {\n\t\t\tdrbd_err(device, \"kmalloc(dw) failed.\");\n\t\t\tov_out_of_sync_print(peer_device);\n\t\t\tdrbd_resync_finished(peer_device);\n\t\t}\n\t}\n\tput_ldev(device);\n\treturn 0;\n}\n\nstatic int got_skip(struct drbd_connection *connection, struct packet_info *pi)\n{\n\treturn 0;\n}\n\nstruct meta_sock_cmd {\n\tsize_t pkt_size;\n\tint (*fn)(struct drbd_connection *connection, struct packet_info *);\n};\n\nstatic void set_rcvtimeo(struct drbd_connection *connection, bool ping_timeout)\n{\n\tlong t;\n\tstruct net_conf *nc;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tt = ping_timeout ? nc->ping_timeo : nc->ping_int;\n\trcu_read_unlock();\n\n\tt *= HZ;\n\tif (ping_timeout)\n\t\tt /= 10;\n\n\tconnection->meta.socket->sk->sk_rcvtimeo = t;\n}\n\nstatic void set_ping_timeout(struct drbd_connection *connection)\n{\n\tset_rcvtimeo(connection, 1);\n}\n\nstatic void set_idle_timeout(struct drbd_connection *connection)\n{\n\tset_rcvtimeo(connection, 0);\n}\n\nstatic struct meta_sock_cmd ack_receiver_tbl[] = {\n\t[P_PING]\t    = { 0, got_Ping },\n\t[P_PING_ACK]\t    = { 0, got_PingAck },\n\t[P_RECV_ACK]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_WRITE_ACK]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_RS_WRITE_ACK]    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_SUPERSEDED]   = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_NEG_ACK]\t    = { sizeof(struct p_block_ack), got_NegAck },\n\t[P_NEG_DREPLY]\t    = { sizeof(struct p_block_ack), got_NegDReply },\n\t[P_NEG_RS_DREPLY]   = { sizeof(struct p_block_ack), got_NegRSDReply },\n\t[P_OV_RESULT]\t    = { sizeof(struct p_block_ack), got_OVResult },\n\t[P_BARRIER_ACK]\t    = { sizeof(struct p_barrier_ack), got_BarrierAck },\n\t[P_STATE_CHG_REPLY] = { sizeof(struct p_req_state_reply), got_RqSReply },\n\t[P_RS_IS_IN_SYNC]   = { sizeof(struct p_block_ack), got_IsInSync },\n\t[P_DELAY_PROBE]     = { sizeof(struct p_delay_probe93), got_skip },\n\t[P_RS_CANCEL]       = { sizeof(struct p_block_ack), got_NegRSDReply },\n\t[P_CONN_ST_CHG_REPLY]={ sizeof(struct p_req_state_reply), got_conn_RqSReply },\n\t[P_RETRY_WRITE]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n};\n\nint drbd_ack_receiver(struct drbd_thread *thi)\n{\n\tstruct drbd_connection *connection = thi->connection;\n\tstruct meta_sock_cmd *cmd = NULL;\n\tstruct packet_info pi;\n\tunsigned long pre_recv_jif;\n\tint rv;\n\tvoid *buf    = connection->meta.rbuf;\n\tint received = 0;\n\tunsigned int header_size = drbd_header_size(connection);\n\tint expect   = header_size;\n\tbool ping_timeout_active = false;\n\n\tsched_set_fifo_low(current);\n\n\twhile (get_t_state(thi) == RUNNING) {\n\t\tdrbd_thread_current_set_cpu(thi);\n\n\t\tconn_reclaim_net_peer_reqs(connection);\n\n\t\tif (test_and_clear_bit(SEND_PING, &connection->flags)) {\n\t\t\tif (drbd_send_ping(connection)) {\n\t\t\t\tdrbd_err(connection, \"drbd_send_ping has failed\\n\");\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t\tset_ping_timeout(connection);\n\t\t\tping_timeout_active = true;\n\t\t}\n\n\t\tpre_recv_jif = jiffies;\n\t\trv = drbd_recv_short(connection->meta.socket, buf, expect-received, 0);\n\n\t\t \n\t\tif (likely(rv > 0)) {\n\t\t\treceived += rv;\n\t\t\tbuf\t += rv;\n\t\t} else if (rv == 0) {\n\t\t\tif (test_bit(DISCONNECT_SENT, &connection->flags)) {\n\t\t\t\tlong t;\n\t\t\t\trcu_read_lock();\n\t\t\t\tt = rcu_dereference(connection->net_conf)->ping_timeo * HZ/10;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tt = wait_event_timeout(connection->ping_wait,\n\t\t\t\t\t\t       connection->cstate < C_WF_REPORT_PARAMS,\n\t\t\t\t\t\t       t);\n\t\t\t\tif (t)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdrbd_err(connection, \"meta connection shut down by peer.\\n\");\n\t\t\tgoto reconnect;\n\t\t} else if (rv == -EAGAIN) {\n\t\t\t \n\t\t\tif (time_after(connection->last_received, pre_recv_jif))\n\t\t\t\tcontinue;\n\t\t\tif (ping_timeout_active) {\n\t\t\t\tdrbd_err(connection, \"PingAck did not arrive in time.\\n\");\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t\tset_bit(SEND_PING, &connection->flags);\n\t\t\tcontinue;\n\t\t} else if (rv == -EINTR) {\n\t\t\t \n\t\t\tflush_signals(current);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdrbd_err(connection, \"sock_recvmsg returned %d\\n\", rv);\n\t\t\tgoto reconnect;\n\t\t}\n\n\t\tif (received == expect && cmd == NULL) {\n\t\t\tif (decode_header(connection, connection->meta.rbuf, &pi))\n\t\t\t\tgoto reconnect;\n\t\t\tcmd = &ack_receiver_tbl[pi.cmd];\n\t\t\tif (pi.cmd >= ARRAY_SIZE(ack_receiver_tbl) || !cmd->fn) {\n\t\t\t\tdrbd_err(connection, \"Unexpected meta packet %s (0x%04x)\\n\",\n\t\t\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\texpect = header_size + cmd->pkt_size;\n\t\t\tif (pi.size != expect - header_size) {\n\t\t\t\tdrbd_err(connection, \"Wrong packet size on meta (c: %d, l: %d)\\n\",\n\t\t\t\t\tpi.cmd, pi.size);\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t}\n\t\tif (received == expect) {\n\t\t\tbool err;\n\n\t\t\terr = cmd->fn(connection, &pi);\n\t\t\tif (err) {\n\t\t\t\tdrbd_err(connection, \"%ps failed\\n\", cmd->fn);\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\n\t\t\tconnection->last_received = jiffies;\n\n\t\t\tif (cmd == &ack_receiver_tbl[P_PING_ACK]) {\n\t\t\t\tset_idle_timeout(connection);\n\t\t\t\tping_timeout_active = false;\n\t\t\t}\n\n\t\t\tbuf\t = connection->meta.rbuf;\n\t\t\treceived = 0;\n\t\t\texpect\t = header_size;\n\t\t\tcmd\t = NULL;\n\t\t}\n\t}\n\n\tif (0) {\nreconnect:\n\t\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\t\tconn_md_sync(connection);\n\t}\n\tif (0) {\ndisconnect:\n\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t}\n\n\tdrbd_info(connection, \"ack_receiver terminated\\n\");\n\n\treturn 0;\n}\n\nvoid drbd_send_acks_wf(struct work_struct *ws)\n{\n\tstruct drbd_peer_device *peer_device =\n\t\tcontainer_of(ws, struct drbd_peer_device, send_acks_work);\n\tstruct drbd_connection *connection = peer_device->connection;\n\tstruct drbd_device *device = peer_device->device;\n\tstruct net_conf *nc;\n\tint tcp_cork, err;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\ttcp_cork = nc->tcp_cork;\n\trcu_read_unlock();\n\n\tif (tcp_cork)\n\t\ttcp_sock_set_cork(connection->meta.socket->sk, true);\n\n\terr = drbd_finish_peer_reqs(device);\n\tkref_put(&device->kref, drbd_destroy_device);\n\t \n\n\tif (err) {\n\t\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\t\treturn;\n\t}\n\n\tif (tcp_cork)\n\t\ttcp_sock_set_cork(connection->meta.socket->sk, false);\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}