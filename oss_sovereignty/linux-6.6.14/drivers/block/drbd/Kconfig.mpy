{
  "module_name": "Kconfig",
  "hash_id": "3b671b0c4e1beb0d74238b79459a9592fd13ade1a2bb5b7da4120b0500933895",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# DRBD device driver configuration\n#\n\ncomment \"DRBD disabled because PROC_FS or INET not selected\"\n\tdepends on PROC_FS='n' || INET='n'\n\nconfig BLK_DEV_DRBD\n\ttristate \"DRBD Distributed Replicated Block Device support\"\n\tdepends on PROC_FS && INET\n\tselect LRU_CACHE\n\tselect LIBCRC32C\n\thelp\n\n\t  NOTE: In order to authenticate connections you have to select\n\t  CRYPTO_HMAC and a hash function as well.\n\n\t  DRBD is a shared-nothing, synchronously replicated block device. It\n\t  is designed to serve as a building block for high availability\n\t  clusters and in this context, is a \"drop-in\" replacement for shared\n\t  storage. Simplistically, you could see it as a network RAID 1.\n\n\t  Each minor device has a role, which can be 'primary' or 'secondary'.\n\t  On the node with the primary device the application is supposed to\n\t  run and to access the device (/dev/drbdX). Every write is sent to\n\t  the local 'lower level block device' and, across the network, to the\n\t  node with the device in 'secondary' state.  The secondary device\n\t  simply writes the data to its lower level block device.\n\n\t  DRBD can also be used in dual-Primary mode (device writable on both\n\t  nodes), which means it can exhibit shared disk semantics in a\n\t  shared-nothing cluster.  Needless to say, on top of dual-Primary\n\t  DRBD utilizing a cluster file system is necessary to maintain for\n\t  cache coherency.\n\n\t  For automatic failover you need a cluster manager (e.g. heartbeat).\n\t  See also: https://www.drbd.org/, http://www.linux-ha.org\n\n\t  If unsure, say N.\n\nconfig DRBD_FAULT_INJECTION\n\tbool \"DRBD fault injection\"\n\tdepends on BLK_DEV_DRBD\n\thelp\n\n\t  Say Y here if you want to simulate IO errors, in order to test DRBD's\n\t  behavior.\n\n\t  The actual simulation of IO errors is done by writing 3 values to\n\t  /sys/module/drbd/parameters/\n\n\t  enable_faults: bitmask of...\n\t  1\tmeta data write\n\t  2               read\n\t  4\tresync data write\n\t  8\t            read\n\t  16\tdata write\n\t  32\tdata read\n\t  64\tread ahead\n\t  128\tkmalloc of bitmap\n\t  256\tallocation of peer_requests\n\t  512\tinsert data corruption on receiving side\n\n\t  fault_devs: bitmask of minor numbers\n\t  fault_rate: frequency in percent\n\n\t  Example: Simulate data write errors on /dev/drbd0 with a probability of 5%.\n\t\techo 16 > /sys/module/drbd/parameters/enable_faults\n\t\techo 1 > /sys/module/drbd/parameters/fault_devs\n\t\techo 5 > /sys/module/drbd/parameters/fault_rate\n\n\t  If unsure, say N.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}