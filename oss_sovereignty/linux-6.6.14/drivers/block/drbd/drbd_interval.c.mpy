{
  "module_name": "drbd_interval.c",
  "hash_id": "b4c2a9dcd22e0e32a8c7484777a33d6f93306f659e609e11c99158b7c6b35b97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_interval.c",
  "human_readable_source": "\n#include <asm/bug.h>\n#include <linux/rbtree_augmented.h>\n#include \"drbd_interval.h\"\n\n \nstatic inline\nsector_t interval_end(struct rb_node *node)\n{\n\tstruct drbd_interval *this = rb_entry(node, struct drbd_interval, rb);\n\treturn this->end;\n}\n\n#define NODE_END(node) ((node)->sector + ((node)->size >> 9))\n\nRB_DECLARE_CALLBACKS_MAX(static, augment_callbacks,\n\t\t\t struct drbd_interval, rb, sector_t, end, NODE_END);\n\n \nbool\ndrbd_insert_interval(struct rb_root *root, struct drbd_interval *this)\n{\n\tstruct rb_node **new = &root->rb_node, *parent = NULL;\n\tsector_t this_end = this->sector + (this->size >> 9);\n\n\tBUG_ON(!IS_ALIGNED(this->size, 512));\n\n\twhile (*new) {\n\t\tstruct drbd_interval *here =\n\t\t\trb_entry(*new, struct drbd_interval, rb);\n\n\t\tparent = *new;\n\t\tif (here->end < this_end)\n\t\t\there->end = this_end;\n\t\tif (this->sector < here->sector)\n\t\t\tnew = &(*new)->rb_left;\n\t\telse if (this->sector > here->sector)\n\t\t\tnew = &(*new)->rb_right;\n\t\telse if (this < here)\n\t\t\tnew = &(*new)->rb_left;\n\t\telse if (this > here)\n\t\t\tnew = &(*new)->rb_right;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tthis->end = this_end;\n\trb_link_node(&this->rb, parent, new);\n\trb_insert_augmented(&this->rb, root, &augment_callbacks);\n\treturn true;\n}\n\n \nbool\ndrbd_contains_interval(struct rb_root *root, sector_t sector,\n\t\t       struct drbd_interval *interval)\n{\n\tstruct rb_node *node = root->rb_node;\n\n\twhile (node) {\n\t\tstruct drbd_interval *here =\n\t\t\trb_entry(node, struct drbd_interval, rb);\n\n\t\tif (sector < here->sector)\n\t\t\tnode = node->rb_left;\n\t\telse if (sector > here->sector)\n\t\t\tnode = node->rb_right;\n\t\telse if (interval < here)\n\t\t\tnode = node->rb_left;\n\t\telse if (interval > here)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid\ndrbd_remove_interval(struct rb_root *root, struct drbd_interval *this)\n{\n\t \n\tif (drbd_interval_empty(this))\n\t\treturn;\n\n\trb_erase_augmented(&this->rb, root, &augment_callbacks);\n}\n\n \nstruct drbd_interval *\ndrbd_find_overlap(struct rb_root *root, sector_t sector, unsigned int size)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct drbd_interval *overlap = NULL;\n\tsector_t end = sector + (size >> 9);\n\n\tBUG_ON(!IS_ALIGNED(size, 512));\n\n\twhile (node) {\n\t\tstruct drbd_interval *here =\n\t\t\trb_entry(node, struct drbd_interval, rb);\n\n\t\tif (node->rb_left &&\n\t\t    sector < interval_end(node->rb_left)) {\n\t\t\t \n\t\t\tnode = node->rb_left;\n\t\t} else if (here->sector < end &&\n\t\t\t   sector < here->sector + (here->size >> 9)) {\n\t\t\toverlap = here;\n\t\t\tbreak;\n\t\t} else if (sector >= here->sector) {\n\t\t\t \n\t\t\tnode = node->rb_right;\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn overlap;\n}\n\nstruct drbd_interval *\ndrbd_next_overlap(struct drbd_interval *i, sector_t sector, unsigned int size)\n{\n\tsector_t end = sector + (size >> 9);\n\tstruct rb_node *node;\n\n\tfor (;;) {\n\t\tnode = rb_next(&i->rb);\n\t\tif (!node)\n\t\t\treturn NULL;\n\t\ti = rb_entry(node, struct drbd_interval, rb);\n\t\tif (i->sector >= end)\n\t\t\treturn NULL;\n\t\tif (sector < i->sector + (i->size >> 9))\n\t\t\treturn i;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}