{
  "module_name": "drbd_debugfs.c",
  "hash_id": "20f7485f5407371818cd0ccffad313b5d15c92c6102f9081f72206f5b519ee26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/drbd/drbd_debugfs.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"drbd debugfs: \" fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/stat.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n\n#include \"drbd_int.h\"\n#include \"drbd_req.h\"\n#include \"drbd_debugfs.h\"\n\n\n \n\nstatic struct dentry *drbd_debugfs_root;\nstatic struct dentry *drbd_debugfs_version;\nstatic struct dentry *drbd_debugfs_resources;\nstatic struct dentry *drbd_debugfs_minors;\n\nstatic void seq_print_age_or_dash(struct seq_file *m, bool valid, unsigned long dt)\n{\n\tif (valid)\n\t\tseq_printf(m, \"\\t%d\", jiffies_to_msecs(dt));\n\telse\n\t\tseq_printf(m, \"\\t-\");\n}\n\nstatic void __seq_print_rq_state_bit(struct seq_file *m,\n\tbool is_set, char *sep, const char *set_name, const char *unset_name)\n{\n\tif (is_set && set_name) {\n\t\tseq_putc(m, *sep);\n\t\tseq_puts(m, set_name);\n\t\t*sep = '|';\n\t} else if (!is_set && unset_name) {\n\t\tseq_putc(m, *sep);\n\t\tseq_puts(m, unset_name);\n\t\t*sep = '|';\n\t}\n}\n\nstatic void seq_print_rq_state_bit(struct seq_file *m,\n\tbool is_set, char *sep, const char *set_name)\n{\n\t__seq_print_rq_state_bit(m, is_set, sep, set_name, NULL);\n}\n\n \nstatic void seq_print_request_state(struct seq_file *m, struct drbd_request *req)\n{\n\tunsigned int s = req->rq_state;\n\tchar sep = ' ';\n\tseq_printf(m, \"\\t0x%08x\", s);\n\tseq_printf(m, \"\\tmaster: %s\", req->master_bio ? \"pending\" : \"completed\");\n\n\t \n\tseq_puts(m, \"\\tlocal:\");\n\tseq_print_rq_state_bit(m, s & RQ_IN_ACT_LOG, &sep, \"in-AL\");\n\tseq_print_rq_state_bit(m, s & RQ_POSTPONED, &sep, \"postponed\");\n\tseq_print_rq_state_bit(m, s & RQ_COMPLETION_SUSP, &sep, \"suspended\");\n\tsep = ' ';\n\tseq_print_rq_state_bit(m, s & RQ_LOCAL_PENDING, &sep, \"pending\");\n\tseq_print_rq_state_bit(m, s & RQ_LOCAL_COMPLETED, &sep, \"completed\");\n\tseq_print_rq_state_bit(m, s & RQ_LOCAL_ABORTED, &sep, \"aborted\");\n\tseq_print_rq_state_bit(m, s & RQ_LOCAL_OK, &sep, \"ok\");\n\tif (sep == ' ')\n\t\tseq_puts(m, \" -\");\n\n\t \n\tseq_printf(m, \"\\tnet:\");\n\tsep = ' ';\n\tseq_print_rq_state_bit(m, s & RQ_NET_PENDING, &sep, \"pending\");\n\tseq_print_rq_state_bit(m, s & RQ_NET_QUEUED, &sep, \"queued\");\n\tseq_print_rq_state_bit(m, s & RQ_NET_SENT, &sep, \"sent\");\n\tseq_print_rq_state_bit(m, s & RQ_NET_DONE, &sep, \"done\");\n\tseq_print_rq_state_bit(m, s & RQ_NET_SIS, &sep, \"sis\");\n\tseq_print_rq_state_bit(m, s & RQ_NET_OK, &sep, \"ok\");\n\tif (sep == ' ')\n\t\tseq_puts(m, \" -\");\n\n\tseq_printf(m, \" :\");\n\tsep = ' ';\n\tseq_print_rq_state_bit(m, s & RQ_EXP_RECEIVE_ACK, &sep, \"B\");\n\tseq_print_rq_state_bit(m, s & RQ_EXP_WRITE_ACK, &sep, \"C\");\n\tseq_print_rq_state_bit(m, s & RQ_EXP_BARR_ACK, &sep, \"barr\");\n\tif (sep == ' ')\n\t\tseq_puts(m, \" -\");\n\tseq_printf(m, \"\\n\");\n}\n\nstatic void seq_print_one_request(struct seq_file *m, struct drbd_request *req, unsigned long now)\n{\n\t \n\tunsigned int s = req->rq_state;\n\n#define RQ_HDR_1 \"epoch\\tsector\\tsize\\trw\"\n\tseq_printf(m, \"0x%x\\t%llu\\t%u\\t%s\",\n\t\treq->epoch,\n\t\t(unsigned long long)req->i.sector, req->i.size >> 9,\n\t\t(s & RQ_WRITE) ? \"W\" : \"R\");\n\n#define RQ_HDR_2 \"\\tstart\\tin AL\\tsubmit\"\n\tseq_printf(m, \"\\t%d\", jiffies_to_msecs(now - req->start_jif));\n\tseq_print_age_or_dash(m, s & RQ_IN_ACT_LOG, now - req->in_actlog_jif);\n\tseq_print_age_or_dash(m, s & RQ_LOCAL_PENDING, now - req->pre_submit_jif);\n\n#define RQ_HDR_3 \"\\tsent\\tacked\\tdone\"\n\tseq_print_age_or_dash(m, s & RQ_NET_SENT, now - req->pre_send_jif);\n\tseq_print_age_or_dash(m, (s & RQ_NET_SENT) && !(s & RQ_NET_PENDING), now - req->acked_jif);\n\tseq_print_age_or_dash(m, s & RQ_NET_DONE, now - req->net_done_jif);\n\n#define RQ_HDR_4 \"\\tstate\\n\"\n\tseq_print_request_state(m, req);\n}\n#define RQ_HDR RQ_HDR_1 RQ_HDR_2 RQ_HDR_3 RQ_HDR_4\n\nstatic void seq_print_minor_vnr_req(struct seq_file *m, struct drbd_request *req, unsigned long now)\n{\n\tseq_printf(m, \"%u\\t%u\\t\", req->device->minor, req->device->vnr);\n\tseq_print_one_request(m, req, now);\n}\n\nstatic void seq_print_resource_pending_meta_io(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\n{\n\tstruct drbd_device *device;\n\tunsigned int i;\n\n\tseq_puts(m, \"minor\\tvnr\\tstart\\tsubmit\\tintent\\n\");\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, i) {\n\t\tstruct drbd_md_io tmp;\n\t\t \n\t\ttmp = device->md_io;\n\t\tif (atomic_read(&tmp.in_use)) {\n\t\t\tseq_printf(m, \"%u\\t%u\\t%d\\t\",\n\t\t\t\tdevice->minor, device->vnr,\n\t\t\t\tjiffies_to_msecs(now - tmp.start_jif));\n\t\t\tif (time_before(tmp.submit_jif, tmp.start_jif))\n\t\t\t\tseq_puts(m, \"-\\t\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"%d\\t\", jiffies_to_msecs(now - tmp.submit_jif));\n\t\t\tseq_printf(m, \"%s\\n\", tmp.current_use);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void seq_print_waiting_for_AL(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\n{\n\tstruct drbd_device *device;\n\tunsigned int i;\n\n\tseq_puts(m, \"minor\\tvnr\\tage\\t#waiting\\n\");\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, i) {\n\t\tunsigned long jif;\n\t\tstruct drbd_request *req;\n\t\tint n = atomic_read(&device->ap_actlog_cnt);\n\t\tif (n) {\n\t\t\tspin_lock_irq(&device->resource->req_lock);\n\t\t\treq = list_first_entry_or_null(&device->pending_master_completion[1],\n\t\t\t\tstruct drbd_request, req_pending_master_completion);\n\t\t\t \n\t\t\tif (req && !(req->rq_state & RQ_IN_ACT_LOG))\n\t\t\t\tjif = req->start_jif;\n\t\t\telse\n\t\t\t\treq = NULL;\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\t}\n\t\tif (n) {\n\t\t\tseq_printf(m, \"%u\\t%u\\t\", device->minor, device->vnr);\n\t\t\tif (req)\n\t\t\t\tseq_printf(m, \"%u\\t\", jiffies_to_msecs(now - jif));\n\t\t\telse\n\t\t\t\tseq_puts(m, \"-\\t\");\n\t\t\tseq_printf(m, \"%u\\n\", n);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void seq_print_device_bitmap_io(struct seq_file *m, struct drbd_device *device, unsigned long now)\n{\n\tstruct drbd_bm_aio_ctx *ctx;\n\tunsigned long start_jif;\n\tunsigned int in_flight;\n\tunsigned int flags;\n\tspin_lock_irq(&device->resource->req_lock);\n\tctx = list_first_entry_or_null(&device->pending_bitmap_io, struct drbd_bm_aio_ctx, list);\n\tif (ctx && ctx->done)\n\t\tctx = NULL;\n\tif (ctx) {\n\t\tstart_jif = ctx->start_jif;\n\t\tin_flight = atomic_read(&ctx->in_flight);\n\t\tflags = ctx->flags;\n\t}\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (ctx) {\n\t\tseq_printf(m, \"%u\\t%u\\t%c\\t%u\\t%u\\n\",\n\t\t\tdevice->minor, device->vnr,\n\t\t\t(flags & BM_AIO_READ) ? 'R' : 'W',\n\t\t\tjiffies_to_msecs(now - start_jif),\n\t\t\tin_flight);\n\t}\n}\n\nstatic void seq_print_resource_pending_bitmap_io(struct seq_file *m, struct drbd_resource *resource, unsigned long now)\n{\n\tstruct drbd_device *device;\n\tunsigned int i;\n\n\tseq_puts(m, \"minor\\tvnr\\trw\\tage\\t#in-flight\\n\");\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, i) {\n\t\tseq_print_device_bitmap_io(m, device, now);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void seq_print_peer_request_flags(struct seq_file *m, struct drbd_peer_request *peer_req)\n{\n\tunsigned long f = peer_req->flags;\n\tchar sep = ' ';\n\n\t__seq_print_rq_state_bit(m, f & EE_SUBMITTED, &sep, \"submitted\", \"preparing\");\n\t__seq_print_rq_state_bit(m, f & EE_APPLICATION, &sep, \"application\", \"internal\");\n\tseq_print_rq_state_bit(m, f & EE_CALL_AL_COMPLETE_IO, &sep, \"in-AL\");\n\tseq_print_rq_state_bit(m, f & EE_SEND_WRITE_ACK, &sep, \"C\");\n\tseq_print_rq_state_bit(m, f & EE_MAY_SET_IN_SYNC, &sep, \"set-in-sync\");\n\tseq_print_rq_state_bit(m, f & EE_TRIM, &sep, \"trim\");\n\tseq_print_rq_state_bit(m, f & EE_ZEROOUT, &sep, \"zero-out\");\n\tseq_print_rq_state_bit(m, f & EE_WRITE_SAME, &sep, \"write-same\");\n\tseq_putc(m, '\\n');\n}\n\nstatic void seq_print_peer_request(struct seq_file *m,\n\tstruct drbd_device *device, struct list_head *lh,\n\tunsigned long now)\n{\n\tbool reported_preparing = false;\n\tstruct drbd_peer_request *peer_req;\n\tlist_for_each_entry(peer_req, lh, w.list) {\n\t\tif (reported_preparing && !(peer_req->flags & EE_SUBMITTED))\n\t\t\tcontinue;\n\n\t\tif (device)\n\t\t\tseq_printf(m, \"%u\\t%u\\t\", device->minor, device->vnr);\n\n\t\tseq_printf(m, \"%llu\\t%u\\t%c\\t%u\\t\",\n\t\t\t(unsigned long long)peer_req->i.sector, peer_req->i.size >> 9,\n\t\t\t(peer_req->flags & EE_WRITE) ? 'W' : 'R',\n\t\t\tjiffies_to_msecs(now - peer_req->submit_jif));\n\t\tseq_print_peer_request_flags(m, peer_req);\n\t\tif (peer_req->flags & EE_SUBMITTED)\n\t\t\tbreak;\n\t\telse\n\t\t\treported_preparing = true;\n\t}\n}\n\nstatic void seq_print_device_peer_requests(struct seq_file *m,\n\tstruct drbd_device *device, unsigned long now)\n{\n\tseq_puts(m, \"minor\\tvnr\\tsector\\tsize\\trw\\tage\\tflags\\n\");\n\tspin_lock_irq(&device->resource->req_lock);\n\tseq_print_peer_request(m, device, &device->active_ee, now);\n\tseq_print_peer_request(m, device, &device->read_ee, now);\n\tseq_print_peer_request(m, device, &device->sync_ee, now);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (test_bit(FLUSH_PENDING, &device->flags)) {\n\t\tseq_printf(m, \"%u\\t%u\\t-\\t-\\tF\\t%u\\tflush\\n\",\n\t\t\tdevice->minor, device->vnr,\n\t\t\tjiffies_to_msecs(now - device->flush_jif));\n\t}\n}\n\nstatic void seq_print_resource_pending_peer_requests(struct seq_file *m,\n\tstruct drbd_resource *resource, unsigned long now)\n{\n\tstruct drbd_device *device;\n\tunsigned int i;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, i) {\n\t\tseq_print_device_peer_requests(m, device, now);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void seq_print_resource_transfer_log_summary(struct seq_file *m,\n\tstruct drbd_resource *resource,\n\tstruct drbd_connection *connection,\n\tunsigned long now)\n{\n\tstruct drbd_request *req;\n\tunsigned int count = 0;\n\tunsigned int show_state = 0;\n\n\tseq_puts(m, \"n\\tdevice\\tvnr\\t\" RQ_HDR);\n\tspin_lock_irq(&resource->req_lock);\n\tlist_for_each_entry(req, &connection->transfer_log, tl_requests) {\n\t\tunsigned int tmp = 0;\n\t\tunsigned int s;\n\t\t++count;\n\n\t\t \n\t\tif (!(count & 0x1ff)) {\n\t\t\tstruct drbd_request *req_next;\n\t\t\tkref_get(&req->kref);\n\t\t\tspin_unlock_irq(&resource->req_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irq(&resource->req_lock);\n\t\t\treq_next = list_next_entry(req, tl_requests);\n\t\t\tif (kref_put(&req->kref, drbd_req_destroy))\n\t\t\t\treq = req_next;\n\t\t\tif (&req->tl_requests == &connection->transfer_log)\n\t\t\t\tbreak;\n\t\t}\n\n\t\ts = req->rq_state;\n\n\t\t \n\t\tif (req->master_bio == NULL)\n\t\t\ttmp |= 1;\n\t\tif ((s & RQ_LOCAL_MASK) && (s & RQ_LOCAL_PENDING))\n\t\t\ttmp |= 2;\n\t\tif (s & RQ_NET_MASK) {\n\t\t\tif (!(s & RQ_NET_SENT))\n\t\t\t\ttmp |= 4;\n\t\t\tif (s & RQ_NET_PENDING)\n\t\t\t\ttmp |= 8;\n\t\t\tif (!(s & RQ_NET_DONE))\n\t\t\t\ttmp |= 16;\n\t\t}\n\t\tif ((tmp & show_state) == tmp)\n\t\t\tcontinue;\n\t\tshow_state |= tmp;\n\t\tseq_printf(m, \"%u\\t\", count);\n\t\tseq_print_minor_vnr_req(m, req, now);\n\t\tif (show_state == 0x1f)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irq(&resource->req_lock);\n}\n\n \nstatic int in_flight_summary_show(struct seq_file *m, void *pos)\n{\n\tstruct drbd_resource *resource = m->private;\n\tstruct drbd_connection *connection;\n\tunsigned long jif = jiffies;\n\n\tconnection = first_connection(resource);\n\t \n\tif (!connection || !kref_get_unless_zero(&connection->kref))\n\t\treturn -ESTALE;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tseq_puts(m, \"oldest bitmap IO\\n\");\n\tseq_print_resource_pending_bitmap_io(m, resource, jif);\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"meta data IO\\n\");\n\tseq_print_resource_pending_meta_io(m, resource, jif);\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"socket buffer stats\\n\");\n\t \n\trcu_read_lock();\n\tif (connection->data.socket) {\n\t\t \n\t\tstruct tcp_sock *tp = tcp_sk(connection->data.socket->sk);\n\t\tint answ = tp->rcv_nxt - tp->copied_seq;\n\t\tseq_printf(m, \"unread receive buffer: %u Byte\\n\", answ);\n\t\t \n\t\tansw = tp->write_seq - tp->snd_una;\n\t\tseq_printf(m, \"unacked send buffer: %u Byte\\n\", answ);\n\t}\n\trcu_read_unlock();\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"oldest peer requests\\n\");\n\tseq_print_resource_pending_peer_requests(m, resource, jif);\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"application requests waiting for activity log\\n\");\n\tseq_print_waiting_for_AL(m, resource, jif);\n\tseq_putc(m, '\\n');\n\n\tseq_puts(m, \"oldest application requests\\n\");\n\tseq_print_resource_transfer_log_summary(m, resource, connection, jif);\n\tseq_putc(m, '\\n');\n\n\tjif = jiffies - jif;\n\tif (jif)\n\t\tseq_printf(m, \"generated in %d ms\\n\", jiffies_to_msecs(jif));\n\tkref_put(&connection->kref, drbd_destroy_connection);\n\treturn 0;\n}\n\n \nstatic int drbd_single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\t                void *data, struct kref *kref,\n\t\t\t\tvoid (*release)(struct kref *))\n{\n\tstruct dentry *parent;\n\tint ret = -ESTALE;\n\n\t \n\tparent = file->f_path.dentry->d_parent;\n\t \n\tinode_lock(d_inode(parent));\n\t \n\tif (simple_positive(file->f_path.dentry)\n\t&& kref_get_unless_zero(kref))\n\t\tret = 0;\n\tinode_unlock(d_inode(parent));\n\tif (!ret) {\n\t\tret = single_open(file, show, data);\n\t\tif (ret)\n\t\t\tkref_put(kref, release);\n\t}\n\treturn ret;\n}\n\nstatic int in_flight_summary_open(struct inode *inode, struct file *file)\n{\n\tstruct drbd_resource *resource = inode->i_private;\n\treturn drbd_single_open(file, in_flight_summary_show, resource,\n\t\t\t\t&resource->kref, drbd_destroy_resource);\n}\n\nstatic int in_flight_summary_release(struct inode *inode, struct file *file)\n{\n\tstruct drbd_resource *resource = inode->i_private;\n\tkref_put(&resource->kref, drbd_destroy_resource);\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations in_flight_summary_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= in_flight_summary_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= in_flight_summary_release,\n};\n\nvoid drbd_debugfs_resource_add(struct drbd_resource *resource)\n{\n\tstruct dentry *dentry;\n\n\tdentry = debugfs_create_dir(resource->name, drbd_debugfs_resources);\n\tresource->debugfs_res = dentry;\n\n\tdentry = debugfs_create_dir(\"volumes\", resource->debugfs_res);\n\tresource->debugfs_res_volumes = dentry;\n\n\tdentry = debugfs_create_dir(\"connections\", resource->debugfs_res);\n\tresource->debugfs_res_connections = dentry;\n\n\tdentry = debugfs_create_file(\"in_flight_summary\", 0440,\n\t\t\t\t     resource->debugfs_res, resource,\n\t\t\t\t     &in_flight_summary_fops);\n\tresource->debugfs_res_in_flight_summary = dentry;\n}\n\nstatic void drbd_debugfs_remove(struct dentry **dp)\n{\n\tdebugfs_remove(*dp);\n\t*dp = NULL;\n}\n\nvoid drbd_debugfs_resource_cleanup(struct drbd_resource *resource)\n{\n\t \n\tdrbd_debugfs_remove(&resource->debugfs_res_in_flight_summary);\n\tdrbd_debugfs_remove(&resource->debugfs_res_connections);\n\tdrbd_debugfs_remove(&resource->debugfs_res_volumes);\n\tdrbd_debugfs_remove(&resource->debugfs_res);\n}\n\nstatic void seq_print_one_timing_detail(struct seq_file *m,\n\tconst struct drbd_thread_timing_details *tdp,\n\tunsigned long now)\n{\n\tstruct drbd_thread_timing_details td;\n\t \n\tdo {\n\t\ttd = *tdp;\n\t} while (td.cb_nr != tdp->cb_nr);\n\tif (!td.cb_addr)\n\t\treturn;\n\tseq_printf(m, \"%u\\t%d\\t%s:%u\\t%ps\\n\",\n\t\t\ttd.cb_nr,\n\t\t\tjiffies_to_msecs(now - td.start_jif),\n\t\t\ttd.caller_fn, td.line,\n\t\t\ttd.cb_addr);\n}\n\nstatic void seq_print_timing_details(struct seq_file *m,\n\t\tconst char *title,\n\t\tunsigned int cb_nr, struct drbd_thread_timing_details *tdp, unsigned long now)\n{\n\tunsigned int start_idx;\n\tunsigned int i;\n\n\tseq_printf(m, \"%s\\n\", title);\n\t \n\tstart_idx = cb_nr % DRBD_THREAD_DETAILS_HIST;\n\tfor (i = start_idx; i < DRBD_THREAD_DETAILS_HIST; i++)\n\t\tseq_print_one_timing_detail(m, tdp+i, now);\n\tfor (i = 0; i < start_idx; i++)\n\t\tseq_print_one_timing_detail(m, tdp+i, now);\n}\n\nstatic int callback_history_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_connection *connection = m->private;\n\tunsigned long jif = jiffies;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tseq_puts(m, \"n\\tage\\tcallsite\\tfn\\n\");\n\tseq_print_timing_details(m, \"worker\", connection->w_cb_nr, connection->w_timing_details, jif);\n\tseq_print_timing_details(m, \"receiver\", connection->r_cb_nr, connection->r_timing_details, jif);\n\treturn 0;\n}\n\nstatic int callback_history_open(struct inode *inode, struct file *file)\n{\n\tstruct drbd_connection *connection = inode->i_private;\n\treturn drbd_single_open(file, callback_history_show, connection,\n\t\t\t\t&connection->kref, drbd_destroy_connection);\n}\n\nstatic int callback_history_release(struct inode *inode, struct file *file)\n{\n\tstruct drbd_connection *connection = inode->i_private;\n\tkref_put(&connection->kref, drbd_destroy_connection);\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations connection_callback_history_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= callback_history_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= callback_history_release,\n};\n\nstatic int connection_oldest_requests_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_connection *connection = m->private;\n\tunsigned long now = jiffies;\n\tstruct drbd_request *r1, *r2;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\tr1 = connection->req_next;\n\tif (r1)\n\t\tseq_print_minor_vnr_req(m, r1, now);\n\tr2 = connection->req_ack_pending;\n\tif (r2 && r2 != r1) {\n\t\tr1 = r2;\n\t\tseq_print_minor_vnr_req(m, r1, now);\n\t}\n\tr2 = connection->req_not_net_done;\n\tif (r2 && r2 != r1)\n\t\tseq_print_minor_vnr_req(m, r2, now);\n\tspin_unlock_irq(&connection->resource->req_lock);\n\treturn 0;\n}\n\nstatic int connection_oldest_requests_open(struct inode *inode, struct file *file)\n{\n\tstruct drbd_connection *connection = inode->i_private;\n\treturn drbd_single_open(file, connection_oldest_requests_show, connection,\n\t\t\t\t&connection->kref, drbd_destroy_connection);\n}\n\nstatic int connection_oldest_requests_release(struct inode *inode, struct file *file)\n{\n\tstruct drbd_connection *connection = inode->i_private;\n\tkref_put(&connection->kref, drbd_destroy_connection);\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations connection_oldest_requests_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= connection_oldest_requests_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= connection_oldest_requests_release,\n};\n\nvoid drbd_debugfs_connection_add(struct drbd_connection *connection)\n{\n\tstruct dentry *conns_dir = connection->resource->debugfs_res_connections;\n\tstruct dentry *dentry;\n\n\t \n\tdentry = debugfs_create_dir(\"peer\", conns_dir);\n\tconnection->debugfs_conn = dentry;\n\n\tdentry = debugfs_create_file(\"callback_history\", 0440,\n\t\t\t\t     connection->debugfs_conn, connection,\n\t\t\t\t     &connection_callback_history_fops);\n\tconnection->debugfs_conn_callback_history = dentry;\n\n\tdentry = debugfs_create_file(\"oldest_requests\", 0440,\n\t\t\t\t     connection->debugfs_conn, connection,\n\t\t\t\t     &connection_oldest_requests_fops);\n\tconnection->debugfs_conn_oldest_requests = dentry;\n}\n\nvoid drbd_debugfs_connection_cleanup(struct drbd_connection *connection)\n{\n\tdrbd_debugfs_remove(&connection->debugfs_conn_callback_history);\n\tdrbd_debugfs_remove(&connection->debugfs_conn_oldest_requests);\n\tdrbd_debugfs_remove(&connection->debugfs_conn);\n}\n\nstatic void resync_dump_detail(struct seq_file *m, struct lc_element *e)\n{\n       struct bm_extent *bme = lc_entry(e, struct bm_extent, lce);\n\n       seq_printf(m, \"%5d %s %s %s\", bme->rs_left,\n\t\t  test_bit(BME_NO_WRITES, &bme->flags) ? \"NO_WRITES\" : \"---------\",\n\t\t  test_bit(BME_LOCKED, &bme->flags) ? \"LOCKED\" : \"------\",\n\t\t  test_bit(BME_PRIORITY, &bme->flags) ? \"PRIORITY\" : \"--------\"\n\t\t  );\n}\n\nstatic int device_resync_extents_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_device *device = m->private;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {\n\t\tlc_seq_printf_stats(m, device->resync);\n\t\tlc_seq_dump_details(m, device->resync, \"rs_left flags\", resync_dump_detail);\n\t\tput_ldev(device);\n\t}\n\treturn 0;\n}\n\nstatic int device_act_log_extents_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_device *device = m->private;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {\n\t\tlc_seq_printf_stats(m, device->act_log);\n\t\tlc_seq_dump_details(m, device->act_log, \"\", NULL);\n\t\tput_ldev(device);\n\t}\n\treturn 0;\n}\n\nstatic int device_oldest_requests_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_device *device = m->private;\n\tstruct drbd_resource *resource = device->resource;\n\tunsigned long now = jiffies;\n\tstruct drbd_request *r1, *r2;\n\tint i;\n\n\t \n\tseq_printf(m, \"v: %u\\n\\n\", 0);\n\n\tseq_puts(m, RQ_HDR);\n\tspin_lock_irq(&resource->req_lock);\n\t \n\tfor (i = 1; i >= 0; --i) {\n\t\tr1 = list_first_entry_or_null(&device->pending_master_completion[i],\n\t\t\tstruct drbd_request, req_pending_master_completion);\n\t\tr2 = list_first_entry_or_null(&device->pending_completion[i],\n\t\t\tstruct drbd_request, req_pending_local);\n\t\tif (r1)\n\t\t\tseq_print_one_request(m, r1, now);\n\t\tif (r2 && r2 != r1)\n\t\t\tseq_print_one_request(m, r2, now);\n\t}\n\tspin_unlock_irq(&resource->req_lock);\n\treturn 0;\n}\n\nstatic int device_data_gen_id_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_device *device = m->private;\n\tstruct drbd_md *md;\n\tenum drbd_uuid_index idx;\n\n\tif (!get_ldev_if_state(device, D_FAILED))\n\t\treturn -ENODEV;\n\n\tmd = &device->ldev->md;\n\tspin_lock_irq(&md->uuid_lock);\n\tfor (idx = UI_CURRENT; idx <= UI_HISTORY_END; idx++) {\n\t\tseq_printf(m, \"0x%016llX\\n\", md->uuid[idx]);\n\t}\n\tspin_unlock_irq(&md->uuid_lock);\n\tput_ldev(device);\n\treturn 0;\n}\n\nstatic int device_ed_gen_id_show(struct seq_file *m, void *ignored)\n{\n\tstruct drbd_device *device = m->private;\n\tseq_printf(m, \"0x%016llX\\n\", (unsigned long long)device->ed_uuid);\n\treturn 0;\n}\n\n#define drbd_debugfs_device_attr(name)\t\t\t\t\t\t\\\nstatic int device_ ## name ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct drbd_device *device = inode->i_private;\t\t\t\t\\\n\treturn drbd_single_open(file, device_ ## name ## _show, device,\t\t\\\n\t\t\t\t&device->kref, drbd_destroy_device);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic int device_ ## name ## _release(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct drbd_device *device = inode->i_private;\t\t\t\t\\\n\tkref_put(&device->kref, drbd_destroy_device);\t\t\t\t\\\n\treturn single_release(inode, file);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations device_ ## name ## _fops = {\t\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t\t\\\n\t.open\t\t= device_ ## name ## _open,\t\t\t\t\\\n\t.read\t\t= seq_read,\t\t\t\t\t\t\\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t\t\\\n\t.release\t= device_ ## name ## _release,\t\t\t\t\\\n};\n\ndrbd_debugfs_device_attr(oldest_requests)\ndrbd_debugfs_device_attr(act_log_extents)\ndrbd_debugfs_device_attr(resync_extents)\ndrbd_debugfs_device_attr(data_gen_id)\ndrbd_debugfs_device_attr(ed_gen_id)\n\nvoid drbd_debugfs_device_add(struct drbd_device *device)\n{\n\tstruct dentry *vols_dir = device->resource->debugfs_res_volumes;\n\tchar minor_buf[8];  \n\tchar vnr_buf[8];    \n\tchar *slink_name = NULL;\n\n\tstruct dentry *dentry;\n\tif (!vols_dir || !drbd_debugfs_minors)\n\t\treturn;\n\n\tsnprintf(vnr_buf, sizeof(vnr_buf), \"%u\", device->vnr);\n\tdentry = debugfs_create_dir(vnr_buf, vols_dir);\n\tdevice->debugfs_vol = dentry;\n\n\tsnprintf(minor_buf, sizeof(minor_buf), \"%u\", device->minor);\n\tslink_name = kasprintf(GFP_KERNEL, \"../resources/%s/volumes/%u\",\n\t\t\tdevice->resource->name, device->vnr);\n\tif (!slink_name)\n\t\tgoto fail;\n\tdentry = debugfs_create_symlink(minor_buf, drbd_debugfs_minors, slink_name);\n\tdevice->debugfs_minor = dentry;\n\tkfree(slink_name);\n\tslink_name = NULL;\n\n#define DCF(name)\tdo {\t\t\t\t\t\\\n\tdentry = debugfs_create_file(#name, 0440,\t\\\n\t\t\tdevice->debugfs_vol, device,\t\t\\\n\t\t\t&device_ ## name ## _fops);\t\t\\\n\tdevice->debugfs_vol_ ## name = dentry;\t\t\t\\\n\t} while (0)\n\n\tDCF(oldest_requests);\n\tDCF(act_log_extents);\n\tDCF(resync_extents);\n\tDCF(data_gen_id);\n\tDCF(ed_gen_id);\n#undef DCF\n\treturn;\n\nfail:\n\tdrbd_debugfs_device_cleanup(device);\n\tdrbd_err(device, \"failed to create debugfs entries\\n\");\n}\n\nvoid drbd_debugfs_device_cleanup(struct drbd_device *device)\n{\n\tdrbd_debugfs_remove(&device->debugfs_minor);\n\tdrbd_debugfs_remove(&device->debugfs_vol_oldest_requests);\n\tdrbd_debugfs_remove(&device->debugfs_vol_act_log_extents);\n\tdrbd_debugfs_remove(&device->debugfs_vol_resync_extents);\n\tdrbd_debugfs_remove(&device->debugfs_vol_data_gen_id);\n\tdrbd_debugfs_remove(&device->debugfs_vol_ed_gen_id);\n\tdrbd_debugfs_remove(&device->debugfs_vol);\n}\n\nvoid drbd_debugfs_peer_device_add(struct drbd_peer_device *peer_device)\n{\n\tstruct dentry *conn_dir = peer_device->connection->debugfs_conn;\n\tstruct dentry *dentry;\n\tchar vnr_buf[8];\n\n\tsnprintf(vnr_buf, sizeof(vnr_buf), \"%u\", peer_device->device->vnr);\n\tdentry = debugfs_create_dir(vnr_buf, conn_dir);\n\tpeer_device->debugfs_peer_dev = dentry;\n}\n\nvoid drbd_debugfs_peer_device_cleanup(struct drbd_peer_device *peer_device)\n{\n\tdrbd_debugfs_remove(&peer_device->debugfs_peer_dev);\n}\n\nstatic int drbd_version_show(struct seq_file *m, void *ignored)\n{\n\tseq_printf(m, \"# %s\\n\", drbd_buildtag());\n\tseq_printf(m, \"VERSION=%s\\n\", REL_VERSION);\n\tseq_printf(m, \"API_VERSION=%u\\n\", GENL_MAGIC_VERSION);\n\tseq_printf(m, \"PRO_VERSION_MIN=%u\\n\", PRO_VERSION_MIN);\n\tseq_printf(m, \"PRO_VERSION_MAX=%u\\n\", PRO_VERSION_MAX);\n\treturn 0;\n}\n\nstatic int drbd_version_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, drbd_version_show, NULL);\n}\n\nstatic const struct file_operations drbd_version_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drbd_version_open,\n\t.llseek = seq_lseek,\n\t.read = seq_read,\n\t.release = single_release,\n};\n\n \nvoid drbd_debugfs_cleanup(void)\n{\n\tdrbd_debugfs_remove(&drbd_debugfs_resources);\n\tdrbd_debugfs_remove(&drbd_debugfs_minors);\n\tdrbd_debugfs_remove(&drbd_debugfs_version);\n\tdrbd_debugfs_remove(&drbd_debugfs_root);\n}\n\nvoid __init drbd_debugfs_init(void)\n{\n\tstruct dentry *dentry;\n\n\tdentry = debugfs_create_dir(\"drbd\", NULL);\n\tdrbd_debugfs_root = dentry;\n\n\tdentry = debugfs_create_file(\"version\", 0444, drbd_debugfs_root, NULL, &drbd_version_fops);\n\tdrbd_debugfs_version = dentry;\n\n\tdentry = debugfs_create_dir(\"resources\", drbd_debugfs_root);\n\tdrbd_debugfs_resources = dentry;\n\n\tdentry = debugfs_create_dir(\"minors\", drbd_debugfs_root);\n\tdrbd_debugfs_minors = dentry;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}