{
  "module_name": "ataflop.c",
  "hash_id": "276c71c983afca16eb194c9e0336b203ffb329069cf9e1948bdd2ea407ee85f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/ataflop.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/fd.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/blk-mq.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/wait.h>\n\n#include <asm/atariints.h>\n#include <asm/atari_stdma.h>\n#include <asm/atari_stram.h>\n\n#define\tFD_MAX_UNITS 2\n\n#undef DEBUG\n\nstatic DEFINE_MUTEX(ataflop_mutex);\nstatic struct request *fd_request;\n\n \n\n \n\n#define FDCSELREG_STP   (0x80)    \n#define FDCSELREG_TRA   (0x82)    \n#define FDCSELREG_SEC   (0x84)    \n#define FDCSELREG_DTA   (0x86)    \n\n \n\n#define FDCREG_CMD\t\t0\n#define FDCREG_STATUS\t0\n#define FDCREG_TRACK\t2\n#define FDCREG_SECTOR\t4\n#define FDCREG_DATA\t\t6\n\n \n\n#define FDCCMD_RESTORE  (0x00)    \n#define FDCCMD_SEEK     (0x10)    \n#define FDCCMD_STEP     (0x20)    \n#define FDCCMD_STIN     (0x40)    \n#define FDCCMD_STOT     (0x60)    \n#define FDCCMD_RDSEC    (0x80)    \n#define FDCCMD_WRSEC    (0xa0)    \n#define FDCCMD_RDADR    (0xc0)    \n#define FDCCMD_RDTRA    (0xe0)    \n#define FDCCMD_WRTRA    (0xf0)    \n#define FDCCMD_FORCI    (0xd0)    \n\n \n\n#define FDCCMDADD_SR6   (0x00)    \n#define FDCCMDADD_SR12  (0x01)\n#define FDCCMDADD_SR2   (0x02)\n#define FDCCMDADD_SR3   (0x03)\n#define FDCCMDADD_V     (0x04)    \n#define FDCCMDADD_H     (0x08)    \n#define FDCCMDADD_U     (0x10)    \n#define FDCCMDADD_M     (0x10)    \n#define FDCCMDADD_E     (0x04)    \n#define FDCCMDADD_P     (0x02)    \n#define FDCCMDADD_A0    (0x01)    \n\n \n\n#define\tFDCSTAT_MOTORON\t(0x80)    \n#define\tFDCSTAT_WPROT\t(0x40)    \n#define\tFDCSTAT_SPINUP\t(0x20)    \n#define\tFDCSTAT_DELDAM\t(0x20)    \n#define\tFDCSTAT_RECNF\t(0x10)    \n#define\tFDCSTAT_CRC\t\t(0x08)    \n#define\tFDCSTAT_TR00\t(0x04)    \n#define\tFDCSTAT_LOST\t(0x04)    \n#define\tFDCSTAT_IDX\t\t(0x02)    \n#define\tFDCSTAT_DRQ\t\t(0x02)    \n#define\tFDCSTAT_BUSY\t(0x01)    \n\n\n \n#define DSKSIDE     (0x01)\n\n#define DSKDRVNONE  (0x06)\n#define DSKDRV0     (0x02)\n#define DSKDRV1     (0x04)\n\n \n#define\tFDCSTEP_6\t0x00\n#define\tFDCSTEP_12\t0x01\n#define\tFDCSTEP_2\t0x02\n#define\tFDCSTEP_3\t0x03\n\nstruct atari_format_descr {\n\tint track;\t\t \n\tint head;\t\t \n\tint sect_offset;\t \n};\n\n \nstatic struct atari_disk_type {\n\tconst char\t*name;\n\tunsigned\tspt;\t\t \n\tunsigned\tblocks;\t\t \n\tunsigned\tfdc_speed;\t \n\tunsigned \tstretch;\t \n} atari_disk_type[] = {\n\t{ \"d360\",  9, 720, 0, 0},\t \n\t{ \"D360\",  9, 720, 0, 1},\t \n\t{ \"D720\",  9,1440, 0, 0},\t \n\t{ \"D820\", 10,1640, 0, 0},\t \n \n#define\tMAX_TYPE_DD 3\n\t{ \"h1200\",15,2400, 3, 0},\t \n\t{ \"H1440\",18,2880, 3, 0},\t \n\t{ \"H1640\",20,3280, 3, 0},\t \n \n#define\tMAX_TYPE_HD 6\n\t{ \"E2880\",36,5760, 3, 0},\t \n\t{ \"E3280\",40,6560, 3, 0},\t \n \n#define\tMAX_TYPE_ED 8\n \n\t{ \"H1680\",21,3360, 3, 0},\t \n\t{ \"h410\",10,820, 0, 1},\t\t \n\t{ \"h1476\",18,2952, 3, 0},\t \n\t{ \"H1722\",21,3444, 3, 0},\t \n\t{ \"h420\",10,840, 0, 1},\t\t \n\t{ \"H830\",10,1660, 0, 0},\t \n\t{ \"h1494\",18,2952, 3, 0},\t \n\t{ \"H1743\",21,3486, 3, 0},\t \n\t{ \"h880\",11,1760, 0, 0},\t \n\t{ \"D1040\",13,2080, 0, 0},\t \n\t{ \"D1120\",14,2240, 0, 0},\t \n\t{ \"h1600\",20,3200, 3, 0},\t \n\t{ \"H1760\",22,3520, 3, 0},\t \n\t{ \"H1920\",24,3840, 3, 0},\t \n\t{ \"E3200\",40,6400, 3, 0},\t \n\t{ \"E3520\",44,7040, 3, 0},\t \n\t{ \"E3840\",48,7680, 3, 0},\t \n\t{ \"H1840\",23,3680, 3, 0},\t \n\t{ \"D800\",10,1600, 0, 0},\t \n};\n\nstatic int StartDiskType[] = {\n\tMAX_TYPE_DD,\n\tMAX_TYPE_HD,\n\tMAX_TYPE_ED\n};\n\n#define\tTYPE_DD\t\t0\n#define\tTYPE_HD\t\t1\n#define\tTYPE_ED\t\t2\n\nstatic int DriveType = TYPE_HD;\n\nstatic DEFINE_SPINLOCK(ataflop_lock);\n\n \nstatic struct {\n\tint \t index;\n\tunsigned drive_types;\n} minor2disktype[] = {\n\t{  0, TYPE_DD },\t \n\t{  4, TYPE_HD },\t \n\t{  1, TYPE_DD },\t \n\t{  2, TYPE_DD },\t \n\t{  1, TYPE_DD },\t \n\t{  2, TYPE_DD },\t \n\t{  5, TYPE_HD },\t \n\t{  7, TYPE_ED },\t \n \n\t{  8, TYPE_ED },\t \n\t{  5, TYPE_HD },\t \n\t{  9, TYPE_HD },\t \n\t{ 10, TYPE_DD },\t \n\t{  3, TYPE_DD },\t \n\t{ 11, TYPE_HD },\t \n\t{ 12, TYPE_HD },\t \n\t{ 13, TYPE_DD },\t \n\t{ 14, TYPE_DD },\t \n\t{ 15, TYPE_HD },\t \n\t{ 16, TYPE_HD },\t \n\t{ 17, TYPE_DD },\t \n\t{ 18, TYPE_DD },\t \n\t{ 19, TYPE_DD },\t \n\t{ 20, TYPE_HD },\t \n\t{ 21, TYPE_HD },\t \n\t{ 22, TYPE_HD },\t \n\t{ 23, TYPE_ED },\t \n\t{ 24, TYPE_ED },\t \n\t{ 25, TYPE_ED },\t \n\t{ 26, TYPE_HD },\t \n\t{ 27, TYPE_DD },\t \n\t{  6, TYPE_HD },\t \n};\n\n#define NUM_DISK_MINORS ARRAY_SIZE(minor2disktype)\n\n \n#define MAX_DISK_SIZE 3280\n\n \nstatic struct atari_disk_type user_params[FD_MAX_UNITS];\n\n \nstatic struct atari_disk_type default_params[FD_MAX_UNITS];\n\n \nstatic struct atari_floppy_struct {\n\tint connected;\t\t\t\t \n\tint autoprobe;\t\t\t\t \n\n\tstruct atari_disk_type\t*disktype;\t \n\n\tint track;\t\t \n\tunsigned int steprate;\t \n\tunsigned int wpstat;\t \n\tint flags;\t\t \n\tstruct gendisk *disk[NUM_DISK_MINORS];\n\tbool registered[NUM_DISK_MINORS];\n\tint ref;\n\tint type;\n\tstruct blk_mq_tag_set tag_set;\n\tint error_count;\n} unit[FD_MAX_UNITS];\n\n#define\tUD\tunit[drive]\n#define\tUDT\tunit[drive].disktype\n#define\tSUD\tunit[SelectedDrive]\n#define\tSUDT\tunit[SelectedDrive].disktype\n\n\n#define FDC_READ(reg) ({\t\t\t\\\n     \t\t\\\n    unsigned short __val;\t\t\t\\\n     \t\t\\\n    dma_wd.dma_mode_status = 0x80 | (reg);\t\\\n    udelay(25);\t\t\t\t\t\\\n    __val = dma_wd.fdc_acces_seccount;\t\t\\\n    MFPDELAY();\t\t\t\t\t\\\n     \t\t\\\n    __val & 0xff;\t\t\t\t\\\n})\n\n#define FDC_WRITE(reg,val)\t\t\t\\\n    do {\t\t\t\t\t\\\n\t \t\t\\\n\t \t\t\\\n\tdma_wd.dma_mode_status = 0x80 | (reg);\t\\\n\tudelay(25);\t\t\t\t\\\n\tdma_wd.fdc_acces_seccount = (val);\t\\\n\tMFPDELAY();\t\t\t\t\\\n         \t\\\n    } while(0)\n\n\n \n\nstatic int MaxSectors[] = {\n\t11, 22, 44\n};\nstatic int BufferSize[] = {\n\t15*512, 30*512, 60*512\n};\n\n#define\tBUFFER_SIZE\t(BufferSize[DriveType])\n\nunsigned char *DMABuffer;\t\t\t   \nstatic unsigned long PhysDMABuffer;    \n\nstatic int UseTrackbuffer = -1;\t\t   \nmodule_param(UseTrackbuffer, int, 0);\n\nunsigned char *TrackBuffer;\t\t\t   \nstatic unsigned long PhysTrackBuffer;  \nstatic int BufferDrive, BufferSide, BufferTrack;\nstatic int read_track;\t\t \n\n#define\tSECTOR_BUFFER(sec)\t(TrackBuffer + ((sec)-1)*512)\n#define\tIS_BUFFERED(drive,side,track) \\\n    (BufferDrive == (drive) && BufferSide == (side) && BufferTrack == (track))\n\n \nstatic int SelectedDrive = 0;\nstatic int ReqCmd, ReqBlock;\nstatic int ReqSide, ReqTrack, ReqSector, ReqCnt;\nstatic int HeadSettleFlag = 0;\nstatic unsigned char *ReqData, *ReqBuffer;\nstatic int MotorOn = 0, MotorOffTrys;\nstatic int IsFormatting = 0, FormatError;\n\nstatic int UserSteprate[FD_MAX_UNITS] = { -1, -1 };\nmodule_param_array(UserSteprate, int, NULL, 0);\n\nstatic DECLARE_COMPLETION(format_wait);\n\nstatic unsigned long changed_floppies = 0xff, fake_change = 0;\n#define\tCHECK_CHANGE_DELAY\tHZ/2\n\n#define\tFD_MOTOR_OFF_DELAY\t(3*HZ)\n#define\tFD_MOTOR_OFF_MAXTRY\t(10*20)\n\n#define FLOPPY_TIMEOUT\t\t(6*HZ)\n#define RECALIBRATE_ERRORS\t4\t \n#define MAX_ERRORS\t\t8\t \n\n\n \nstatic int Probing = 0;\n\n \nstatic int NeedSeek = 0;\n\n\n#ifdef DEBUG\n#define DPRINT(a)\tprintk a\n#else\n#define DPRINT(a)\n#endif\n\n \n\nstatic void fd_select_side( int side );\nstatic void fd_select_drive( int drive );\nstatic void fd_deselect( void );\nstatic void fd_motor_off_timer(struct timer_list *unused);\nstatic void check_change(struct timer_list *unused);\nstatic irqreturn_t floppy_irq (int irq, void *dummy);\nstatic void fd_error( void );\nstatic int do_format(int drive, int type, struct atari_format_descr *desc);\nstatic void do_fd_action( int drive );\nstatic void fd_calibrate( void );\nstatic void fd_calibrate_done( int status );\nstatic void fd_seek( void );\nstatic void fd_seek_done( int status );\nstatic void fd_rwsec( void );\nstatic void fd_readtrack_check(struct timer_list *unused);\nstatic void fd_rwsec_done( int status );\nstatic void fd_rwsec_done1(int status);\nstatic void fd_writetrack( void );\nstatic void fd_writetrack_done( int status );\nstatic void fd_times_out(struct timer_list *unused);\nstatic void finish_fdc( void );\nstatic void finish_fdc_done( int dummy );\nstatic void setup_req_params( int drive );\nstatic int fd_locked_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned int cmd, unsigned long param);\nstatic void fd_probe( int drive );\nstatic int fd_test_drive_present( int drive );\nstatic void config_types( void );\nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode);\nstatic void floppy_release(struct gendisk *disk);\n\n \n\nstatic DEFINE_TIMER(motor_off_timer, fd_motor_off_timer);\nstatic DEFINE_TIMER(readtrack_timer, fd_readtrack_check);\nstatic DEFINE_TIMER(timeout_timer, fd_times_out);\nstatic DEFINE_TIMER(fd_timer, check_change);\n\t\nstatic void fd_end_request_cur(blk_status_t err)\n{\n\tDPRINT((\"fd_end_request_cur(), bytes %d of %d\\n\",\n\t\tblk_rq_cur_bytes(fd_request),\n\t\tblk_rq_bytes(fd_request)));\n\n\tif (!blk_update_request(fd_request, err,\n\t\t\t\tblk_rq_cur_bytes(fd_request))) {\n\t\tDPRINT((\"calling __blk_mq_end_request()\\n\"));\n\t\t__blk_mq_end_request(fd_request, err);\n\t\tfd_request = NULL;\n\t} else {\n\t\t \n\t\tDPRINT((\"calling blk_mq_requeue_request()\\n\"));\n\t\tblk_mq_requeue_request(fd_request, true);\n\t\tfd_request = NULL;\n\t}\n}\n\nstatic inline void start_motor_off_timer(void)\n{\n\tmod_timer(&motor_off_timer, jiffies + FD_MOTOR_OFF_DELAY);\n\tMotorOffTrys = 0;\n}\n\nstatic inline void start_check_change_timer( void )\n{\n\tmod_timer(&fd_timer, jiffies + CHECK_CHANGE_DELAY);\n}\n\nstatic inline void start_timeout(void)\n{\n\tmod_timer(&timeout_timer, jiffies + FLOPPY_TIMEOUT);\n}\n\nstatic inline void stop_timeout(void)\n{\n\tdel_timer(&timeout_timer);\n}\n\n \n\nstatic void fd_select_side( int side )\n{\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n  \n\tsound_ym.rd_data_reg_sel = 14;  \n\tsound_ym.wd_data = (side == 0) ? sound_ym.rd_data_reg_sel | 0x01 :\n\t                                 sound_ym.rd_data_reg_sel & 0xfe;\n\n\tlocal_irq_restore(flags);\n}\n\n\n \n\nstatic void fd_select_drive( int drive )\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n  \n\tif (drive == SelectedDrive)\n\t  return;\n\n\t \n\tlocal_irq_save(flags);\n\tsound_ym.rd_data_reg_sel = 14;  \n\ttmp = sound_ym.rd_data_reg_sel;\n\tsound_ym.wd_data = (tmp | DSKDRVNONE) & ~(drive == 0 ? DSKDRV0 : DSKDRV1);\n\tatari_dont_touch_floppy_select = 1;\n\tlocal_irq_restore(flags);\n\n\t \n\tFDC_WRITE( FDCREG_TRACK, UD.track );\n\tudelay(25);\n\n\t \n\tif (UDT)\n\t\tif (ATARIHW_PRESENT(FDCSPEED))\n\t\t\tdma_wd.fdc_speed = UDT->fdc_speed;\n\t\n\tSelectedDrive = drive;\n}\n\n\n \n\nstatic void fd_deselect( void )\n{\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tatari_dont_touch_floppy_select = 0;\n\tsound_ym.rd_data_reg_sel=14;\t \n\tsound_ym.wd_data = (sound_ym.rd_data_reg_sel |\n\t\t\t    (MACH_IS_FALCON ? 3 : 7));  \n\t \n\tSelectedDrive = -1;\n\tlocal_irq_restore(flags);\n}\n\n\n \n\nstatic void fd_motor_off_timer(struct timer_list *unused)\n{\n\tunsigned char status;\n\n\tif (SelectedDrive < 0)\n\t\t \n\t\treturn;\n\n\tif (stdma_islocked())\n\t\tgoto retry;\n\n\tstatus = FDC_READ( FDCREG_STATUS );\n\n\tif (!(status & 0x80)) {\n\t\t \n\t\tMotorOn = 0;\n\t\tfd_deselect();\n\t\treturn;\n\t}\n\t \n\n  retry:\n\t \n\tmod_timer(&motor_off_timer,\n\t\t  jiffies + (MotorOffTrys++ < FD_MOTOR_OFF_MAXTRY ? HZ/20 : HZ/2));\n}\n\n\n \n\nstatic void check_change(struct timer_list *unused)\n{\n\tstatic int    drive = 0;\n\n\tunsigned long flags;\n\tunsigned char old_porta;\n\tint\t\t\t  stat;\n\n\tif (++drive > 1 || !UD.connected)\n\t\tdrive = 0;\n\n\t \n\tlocal_irq_save(flags);\n\n\tif (!stdma_islocked()) {\n\t\tsound_ym.rd_data_reg_sel = 14;\n\t\told_porta = sound_ym.rd_data_reg_sel;\n\t\tsound_ym.wd_data = (old_porta | DSKDRVNONE) &\n\t\t\t               ~(drive == 0 ? DSKDRV0 : DSKDRV1);\n\t\tstat = !!(FDC_READ( FDCREG_STATUS ) & FDCSTAT_WPROT);\n\t\tsound_ym.wd_data = old_porta;\n\n\t\tif (stat != UD.wpstat) {\n\t\t\tDPRINT(( \"wpstat[%d] = %d\\n\", drive, stat ));\n\t\t\tUD.wpstat = stat;\n\t\t\tset_bit (drive, &changed_floppies);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n\n\tstart_check_change_timer();\n}\n\n \n \n\nstatic inline void set_head_settle_flag(void)\n{\n\tHeadSettleFlag = FDCCMDADD_E;\n}\n\nstatic inline int get_head_settle_flag(void)\n{\n\tint\ttmp = HeadSettleFlag;\n\tHeadSettleFlag = 0;\n\treturn( tmp );\n}\n\nstatic inline void copy_buffer(void *from, void *to)\n{\n\tulong *p1 = (ulong *)from, *p2 = (ulong *)to;\n\tint cnt;\n\n\tfor (cnt = 512/4; cnt; cnt--)\n\t\t*p2++ = *p1++;\n}\n\n \n\nstatic void (*FloppyIRQHandler)( int status ) = NULL;\n\nstatic irqreturn_t floppy_irq (int irq, void *dummy)\n{\n\tunsigned char status;\n\tvoid (*handler)( int );\n\n\thandler = xchg(&FloppyIRQHandler, NULL);\n\n\tif (handler) {\n\t\tnop();\n\t\tstatus = FDC_READ( FDCREG_STATUS );\n\t\tDPRINT((\"FDC irq, status = %02x handler = %08lx\\n\",status,(unsigned long)handler));\n\t\thandler( status );\n\t}\n\telse {\n\t\tDPRINT((\"FDC irq, no handler\\n\"));\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic void fd_error( void )\n{\n\tif (IsFormatting) {\n\t\tIsFormatting = 0;\n\t\tFormatError = 1;\n\t\tcomplete(&format_wait);\n\t\treturn;\n\t}\n\n\tif (!fd_request)\n\t\treturn;\n\n\tunit[SelectedDrive].error_count++;\n\tif (unit[SelectedDrive].error_count >= MAX_ERRORS) {\n\t\tprintk(KERN_ERR \"fd%d: too many errors.\\n\", SelectedDrive );\n\t\tfd_end_request_cur(BLK_STS_IOERR);\n\t\tfinish_fdc();\n\t\treturn;\n\t}\n\telse if (unit[SelectedDrive].error_count == RECALIBRATE_ERRORS) {\n\t\tprintk(KERN_WARNING \"fd%d: recalibrating\\n\", SelectedDrive );\n\t\tif (SelectedDrive != -1)\n\t\t\tSUD.track = -1;\n\t}\n\t \n\tatari_disable_irq( IRQ_MFP_FDC );\n\n\tsetup_req_params( SelectedDrive );\n\tdo_fd_action( SelectedDrive );\n\n\tatari_enable_irq( IRQ_MFP_FDC );\n}\n\n\n\n#define\tSET_IRQ_HANDLER(proc) do { FloppyIRQHandler = (proc); } while(0)\n\n\n \n\n#define FILL(n,val)\t\t\\\n    do {\t\t\t\\\n\tmemset( p, val, n );\t\\\n\tp += n;\t\t\t\\\n    } while(0)\n\nstatic int do_format(int drive, int type, struct atari_format_descr *desc)\n{\n\tstruct request_queue *q;\n\tunsigned char\t*p;\n\tint sect, nsect;\n\tunsigned long\tflags;\n\tint ret;\n\n\tif (type) {\n\t\ttype--;\n\t\tif (type >= NUM_DISK_MINORS ||\n\t\t    minor2disktype[type].drive_types > DriveType) {\n\t\t\tfinish_fdc();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tq = unit[drive].disk[type]->queue;\n\tblk_mq_freeze_queue(q);\n\tblk_mq_quiesce_queue(q);\n\n\tlocal_irq_save(flags);\n\tstdma_lock(floppy_irq, NULL);\n\tatari_turnon_irq( IRQ_MFP_FDC );  \n\tlocal_irq_restore(flags);\n\n\tif (type) {\n\t\ttype = minor2disktype[type].index;\n\t\tUDT = &atari_disk_type[type];\n\t}\n\n\tif (!UDT || desc->track >= UDT->blocks/UDT->spt/2 || desc->head >= 2) {\n\t\tfinish_fdc();\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnsect = UDT->spt;\n\tp = TrackBuffer;\n\t \n\tBufferDrive = -1;\n\t \n\tdel_timer( &motor_off_timer );\n\n\tFILL( 60 * (nsect / 9), 0x4e );\n\tfor( sect = 0; sect < nsect; ++sect ) {\n\t\tFILL( 12, 0 );\n\t\tFILL( 3, 0xf5 );\n\t\t*p++ = 0xfe;\n\t\t*p++ = desc->track;\n\t\t*p++ = desc->head;\n\t\t*p++ = (nsect + sect - desc->sect_offset) % nsect + 1;\n\t\t*p++ = 2;\n\t\t*p++ = 0xf7;\n\t\tFILL( 22, 0x4e );\n\t\tFILL( 12, 0 );\n\t\tFILL( 3, 0xf5 );\n\t\t*p++ = 0xfb;\n\t\tFILL( 512, 0xe5 );\n\t\t*p++ = 0xf7;\n\t\tFILL( 40, 0x4e );\n\t}\n\tFILL( TrackBuffer+BUFFER_SIZE-p, 0x4e );\n\n\tIsFormatting = 1;\n\tFormatError = 0;\n\tReqTrack = desc->track;\n\tReqSide  = desc->head;\n\tdo_fd_action( drive );\n\n\twait_for_completion(&format_wait);\n\n\tfinish_fdc();\n\tret = FormatError ? -EIO : 0;\nout:\n\tblk_mq_unquiesce_queue(q);\n\tblk_mq_unfreeze_queue(q);\n\treturn ret;\n}\n\n\n \n\nstatic void do_fd_action( int drive )\n{\n\tDPRINT((\"do_fd_action\\n\"));\n\t\n\tif (UseTrackbuffer && !IsFormatting) {\n\trepeat:\n\t    if (IS_BUFFERED( drive, ReqSide, ReqTrack )) {\n\t\tif (ReqCmd == READ) {\n\t\t    copy_buffer( SECTOR_BUFFER(ReqSector), ReqData );\n\t\t    if (++ReqCnt < blk_rq_cur_sectors(fd_request)) {\n\t\t\t \n\t\t\tsetup_req_params( drive );\n\t\t\tgoto repeat;\n\t\t    }\n\t\t    else {\n\t\t\t \n\t\t\tfd_end_request_cur(BLK_STS_OK);\n\t\t\tfinish_fdc();\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t     \n\t\t    copy_buffer( ReqData, SECTOR_BUFFER(ReqSector) );\n\t\t}\n\t    }\n\t}\n\n\tif (SelectedDrive != drive)\n\t\tfd_select_drive( drive );\n    \n\tif (UD.track == -1)\n\t\tfd_calibrate();\n\telse if (UD.track != ReqTrack << UDT->stretch)\n\t\tfd_seek();\n\telse if (IsFormatting)\n\t\tfd_writetrack();\n\telse\n\t\tfd_rwsec();\n}\n\n\n \n\nstatic void fd_calibrate( void )\n{\n\tif (SUD.track >= 0) {\n\t\tfd_calibrate_done( 0 );\n\t\treturn;\n\t}\n\n\tif (ATARIHW_PRESENT(FDCSPEED))\n\t\tdma_wd.fdc_speed = 0;    \n\tDPRINT((\"fd_calibrate\\n\"));\n\tSET_IRQ_HANDLER( fd_calibrate_done );\n\t \n\tFDC_WRITE( FDCREG_CMD, FDCCMD_RESTORE | SUD.steprate );\n\n\tNeedSeek = 1;\n\tMotorOn = 1;\n\tstart_timeout();\n\t \n}\n\n\nstatic void fd_calibrate_done( int status )\n{\n\tDPRINT((\"fd_calibrate_done()\\n\"));\n\tstop_timeout();\n    \n\t \n\tif (ATARIHW_PRESENT(FDCSPEED))\n\t\tdma_wd.fdc_speed = SUDT->fdc_speed;\n\tif (status & FDCSTAT_RECNF) {\n\t\tprintk(KERN_ERR \"fd%d: restore failed\\n\", SelectedDrive );\n\t\tfd_error();\n\t}\n\telse {\n\t\tSUD.track = 0;\n\t\tfd_seek();\n\t}\n}\n  \n  \n \n  \nstatic void fd_seek( void )\n{\n\tif (SUD.track == ReqTrack << SUDT->stretch) {\n\t\tfd_seek_done( 0 );\n\t\treturn;\n\t}\n\n\tif (ATARIHW_PRESENT(FDCSPEED)) {\n\t\tdma_wd.fdc_speed = 0;\t \n\t\tMFPDELAY();\n\t}\n\n\tDPRINT((\"fd_seek() to track %d\\n\",ReqTrack));\n\tFDC_WRITE( FDCREG_DATA, ReqTrack << SUDT->stretch);\n\tudelay(25);\n\tSET_IRQ_HANDLER( fd_seek_done );\n\tFDC_WRITE( FDCREG_CMD, FDCCMD_SEEK | SUD.steprate );\n\n\tMotorOn = 1;\n\tset_head_settle_flag();\n\tstart_timeout();\n\t \n}\n\n\nstatic void fd_seek_done( int status )\n{\n\tDPRINT((\"fd_seek_done()\\n\"));\n\tstop_timeout();\n\t\n\t \n\tif (ATARIHW_PRESENT(FDCSPEED))\n\t\tdma_wd.fdc_speed = SUDT->fdc_speed;\n\tif (status & FDCSTAT_RECNF) {\n\t\tprintk(KERN_ERR \"fd%d: seek error (to track %d)\\n\",\n\t\t\t\tSelectedDrive, ReqTrack );\n\t\t \n\t\tSUD.track = -1;\n\t\tfd_error();\n\t}\n\telse {\n\t\tSUD.track = ReqTrack << SUDT->stretch;\n\t\tNeedSeek = 0;\n\t\tif (IsFormatting)\n\t\t\tfd_writetrack();\n\t\telse\n\t\t\tfd_rwsec();\n\t}\n}\n\n\n \n\nstatic int MultReadInProgress = 0;\n\n\nstatic void fd_rwsec( void )\n{\n\tunsigned long paddr, flags;\n\tunsigned int  rwflag, old_motoron;\n\tunsigned int track;\n\t\n\tDPRINT((\"fd_rwsec(), Sec=%d, Access=%c\\n\",ReqSector, ReqCmd == WRITE ? 'w' : 'r' ));\n\tif (ReqCmd == WRITE) {\n\t\tif (ATARIHW_PRESENT(EXTD_DMA)) {\n\t\t\tpaddr = virt_to_phys(ReqData);\n\t\t}\n\t\telse {\n\t\t\tcopy_buffer( ReqData, DMABuffer );\n\t\t\tpaddr = PhysDMABuffer;\n\t\t}\n\t\tdma_cache_maintenance( paddr, 512, 1 );\n\t\trwflag = 0x100;\n\t}\n\telse {\n\t\tif (read_track)\n\t\t\tpaddr = PhysTrackBuffer;\n\t\telse\n\t\t\tpaddr = ATARIHW_PRESENT(EXTD_DMA) ? \n\t\t\t\tvirt_to_phys(ReqData) : PhysDMABuffer;\n\t\trwflag = 0;\n\t}\n\n\tfd_select_side( ReqSide );\n  \n\t \n\tFDC_WRITE( FDCREG_SECTOR, read_track ? 1 : ReqSector );\n\tMFPDELAY();\n\t \n\tif (SUDT->stretch) {\n\t\ttrack = FDC_READ( FDCREG_TRACK);\n\t\tMFPDELAY();\n\t\tFDC_WRITE( FDCREG_TRACK, track >> SUDT->stretch);\n\t}\n\tudelay(25);\n  \n\t \n\tlocal_irq_save(flags);\n\tdma_wd.dma_lo = (unsigned char)paddr;\n\tMFPDELAY();\n\tpaddr >>= 8;\n\tdma_wd.dma_md = (unsigned char)paddr;\n\tMFPDELAY();\n\tpaddr >>= 8;\n\tif (ATARIHW_PRESENT(EXTD_DMA))\n\t\tst_dma_ext_dmahi = (unsigned short)paddr;\n\telse\n\t\tdma_wd.dma_hi = (unsigned char)paddr;\n\tMFPDELAY();\n\tlocal_irq_restore(flags);\n  \n\t   \n\tdma_wd.dma_mode_status = 0x90 | rwflag;  \n\tMFPDELAY();\n\tdma_wd.dma_mode_status = 0x90 | (rwflag ^ 0x100);  \n\tMFPDELAY();\n\tdma_wd.dma_mode_status = 0x90 | rwflag;\n\tMFPDELAY();\n  \n\t \n\tdma_wd.fdc_acces_seccount = read_track ? SUDT->spt : 1;\n  \n\tudelay(25);  \n  \n\t \n\tdma_wd.dma_mode_status = FDCSELREG_STP | rwflag;\n\tudelay(25);\n\tSET_IRQ_HANDLER( fd_rwsec_done );\n\tdma_wd.fdc_acces_seccount =\n\t  (get_head_settle_flag() |\n\t   (rwflag ? FDCCMD_WRSEC : (FDCCMD_RDSEC | (read_track ? FDCCMDADD_M : 0))));\n\n\told_motoron = MotorOn;\n\tMotorOn = 1;\n\tNeedSeek = 1;\n\t \n\n\tif (read_track) {\n\t\t \n\t\tMultReadInProgress = 1;\n\t\tmod_timer(&readtrack_timer,\n\t\t\t   \n\t\t\t  jiffies + HZ/5 + (old_motoron ? 0 : HZ));\n\t}\n\tstart_timeout();\n}\n\n    \nstatic void fd_readtrack_check(struct timer_list *unused)\n{\n\tunsigned long flags, addr, addr2;\n\n\tlocal_irq_save(flags);\n\n\tif (!MultReadInProgress) {\n\t\t \n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\n\t \n\t \n\taddr = 0;\n\tdo {\n\t\taddr2 = addr;\n\t\taddr = dma_wd.dma_lo & 0xff;\n\t\tMFPDELAY();\n\t\taddr |= (dma_wd.dma_md & 0xff) << 8;\n\t\tMFPDELAY();\n\t\tif (ATARIHW_PRESENT( EXTD_DMA ))\n\t\t\taddr |= (st_dma_ext_dmahi & 0xffff) << 16;\n\t\telse\n\t\t\taddr |= (dma_wd.dma_hi & 0xff) << 16;\n\t\tMFPDELAY();\n\t} while(addr != addr2);\n  \n\tif (addr >= PhysTrackBuffer + SUDT->spt*512) {\n\t\t \n\t\tSET_IRQ_HANDLER( NULL );\n\t\tMultReadInProgress = 0;\n\t\tlocal_irq_restore(flags);\n\t\tDPRINT((\"fd_readtrack_check(): done\\n\"));\n\t\tFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\n\t\tudelay(25);\n\n\t\t \n\t\tfd_rwsec_done1(0);\n\t}\n\telse {\n\t\t \n\t\tlocal_irq_restore(flags);\n\t\tDPRINT((\"fd_readtrack_check(): not yet finished\\n\"));\n\t\tmod_timer(&readtrack_timer, jiffies + HZ/5/10);\n\t}\n}\n\n\nstatic void fd_rwsec_done( int status )\n{\n\tDPRINT((\"fd_rwsec_done()\\n\"));\n\n\tif (read_track) {\n\t\tdel_timer(&readtrack_timer);\n\t\tif (!MultReadInProgress)\n\t\t\treturn;\n\t\tMultReadInProgress = 0;\n\t}\n\tfd_rwsec_done1(status);\n}\n\nstatic void fd_rwsec_done1(int status)\n{\n\tunsigned int track;\n\n\tstop_timeout();\n\t\n\t \n\tif (SUDT->stretch) {\n\t\ttrack = FDC_READ( FDCREG_TRACK);\n\t\tMFPDELAY();\n\t\tFDC_WRITE( FDCREG_TRACK, track << SUDT->stretch);\n\t}\n\n\tif (!UseTrackbuffer) {\n\t\tdma_wd.dma_mode_status = 0x90;\n\t\tMFPDELAY();\n\t\tif (!(dma_wd.dma_mode_status & 0x01)) {\n\t\t\tprintk(KERN_ERR \"fd%d: DMA error\\n\", SelectedDrive );\n\t\t\tgoto err_end;\n\t\t}\n\t}\n\tMFPDELAY();\n\n\tif (ReqCmd == WRITE && (status & FDCSTAT_WPROT)) {\n\t\tprintk(KERN_NOTICE \"fd%d: is write protected\\n\", SelectedDrive );\n\t\tgoto err_end;\n\t}\t\n\tif ((status & FDCSTAT_RECNF) &&\n\t     \n\t    !(read_track && FDC_READ(FDCREG_SECTOR) > SUDT->spt)) {\n\t\tif (Probing) {\n\t\t\tif (SUDT > atari_disk_type) {\n\t\t\t    if (SUDT[-1].blocks > ReqBlock) {\n\t\t\t\t \n\t\t\t\tSUDT--;\n\t\t\t\tset_capacity(unit[SelectedDrive].disk[0],\n\t\t\t\t\t\t\tSUDT->blocks);\n\t\t\t    } else\n\t\t\t\tProbing = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (SUD.flags & FTD_MSG)\n\t\t\t\t\tprintk(KERN_INFO \"fd%d: Auto-detected floppy type %s\\n\",\n\t\t\t\t\t       SelectedDrive, SUDT->name );\n\t\t\t\tProbing=0;\n\t\t\t}\n\t\t} else {\t\n \n\t\t\tif (SUD.autoprobe) {\n\t\t\t\tSUDT = atari_disk_type + StartDiskType[DriveType];\n\t\t\t\tset_capacity(unit[SelectedDrive].disk[0],\n\t\t\t\t\t\t\tSUDT->blocks);\n\t\t\t\tProbing = 1;\n\t\t\t}\n\t\t}\n\t\tif (Probing) {\n\t\t\tif (ATARIHW_PRESENT(FDCSPEED)) {\n\t\t\t\tdma_wd.fdc_speed = SUDT->fdc_speed;\n\t\t\t\tMFPDELAY();\n\t\t\t}\n\t\t\tsetup_req_params( SelectedDrive );\n\t\t\tBufferDrive = -1;\n\t\t\tdo_fd_action( SelectedDrive );\n\t\t\treturn;\n\t\t}\n\n\t\tprintk(KERN_ERR \"fd%d: sector %d not found (side %d, track %d)\\n\",\n\t\t       SelectedDrive, FDC_READ (FDCREG_SECTOR), ReqSide, ReqTrack );\n\t\tgoto err_end;\n\t}\n\tif (status & FDCSTAT_CRC) {\n\t\tprintk(KERN_ERR \"fd%d: CRC error (side %d, track %d, sector %d)\\n\",\n\t\t       SelectedDrive, ReqSide, ReqTrack, FDC_READ (FDCREG_SECTOR) );\n\t\tgoto err_end;\n\t}\n\tif (status & FDCSTAT_LOST) {\n\t\tprintk(KERN_ERR \"fd%d: lost data (side %d, track %d, sector %d)\\n\",\n\t\t       SelectedDrive, ReqSide, ReqTrack, FDC_READ (FDCREG_SECTOR) );\n\t\tgoto err_end;\n\t}\n\n\tProbing = 0;\n\t\n\tif (ReqCmd == READ) {\n\t\tif (!read_track) {\n\t\t\tvoid *addr;\n\t\t\taddr = ATARIHW_PRESENT( EXTD_DMA ) ? ReqData : DMABuffer;\n\t\t\tdma_cache_maintenance( virt_to_phys(addr), 512, 0 );\n\t\t\tif (!ATARIHW_PRESENT( EXTD_DMA ))\n\t\t\t\tcopy_buffer (addr, ReqData);\n\t\t} else {\n\t\t\tdma_cache_maintenance( PhysTrackBuffer, MaxSectors[DriveType] * 512, 0 );\n\t\t\tBufferDrive = SelectedDrive;\n\t\t\tBufferSide  = ReqSide;\n\t\t\tBufferTrack = ReqTrack;\n\t\t\tcopy_buffer (SECTOR_BUFFER (ReqSector), ReqData);\n\t\t}\n\t}\n  \n\tif (++ReqCnt < blk_rq_cur_sectors(fd_request)) {\n\t\t \n\t\tsetup_req_params( SelectedDrive );\n\t\tdo_fd_action( SelectedDrive );\n\t}\n\telse {\n\t\t \n\t\tfd_end_request_cur(BLK_STS_OK);\n\t\tfinish_fdc();\n\t}\n\treturn;\n  \n  err_end:\n\tBufferDrive = -1;\n\tfd_error();\n}\n\n\nstatic void fd_writetrack( void )\n{\n\tunsigned long paddr, flags;\n\tunsigned int track;\n\t\n\tDPRINT((\"fd_writetrack() Tr=%d Si=%d\\n\", ReqTrack, ReqSide ));\n\n\tpaddr = PhysTrackBuffer;\n\tdma_cache_maintenance( paddr, BUFFER_SIZE, 1 );\n\n\tfd_select_side( ReqSide );\n  \n\t \n\tif (SUDT->stretch) {\n\t\ttrack = FDC_READ( FDCREG_TRACK);\n\t\tMFPDELAY();\n\t\tFDC_WRITE(FDCREG_TRACK,track >> SUDT->stretch);\n\t}\n\tudelay(40);\n  \n\t \n\tlocal_irq_save(flags);\n\tdma_wd.dma_lo = (unsigned char)paddr;\n\tMFPDELAY();\n\tpaddr >>= 8;\n\tdma_wd.dma_md = (unsigned char)paddr;\n\tMFPDELAY();\n\tpaddr >>= 8;\n\tif (ATARIHW_PRESENT( EXTD_DMA ))\n\t\tst_dma_ext_dmahi = (unsigned short)paddr;\n\telse\n\t\tdma_wd.dma_hi = (unsigned char)paddr;\n\tMFPDELAY();\n\tlocal_irq_restore(flags);\n  \n\t   \n\tdma_wd.dma_mode_status = 0x190;  \n\tMFPDELAY();\n\tdma_wd.dma_mode_status = 0x90;  \n\tMFPDELAY();\n\tdma_wd.dma_mode_status = 0x190;\n\tMFPDELAY();\n  \n\t \n\tdma_wd.fdc_acces_seccount = BUFFER_SIZE/512;\n\tudelay(40);  \n  \n\t \n\tdma_wd.dma_mode_status = FDCSELREG_STP | 0x100;\n\tudelay(40);\n\tSET_IRQ_HANDLER( fd_writetrack_done );\n\tdma_wd.fdc_acces_seccount = FDCCMD_WRTRA | get_head_settle_flag(); \n\n\tMotorOn = 1;\n\tstart_timeout();\n\t \n}\n\n\nstatic void fd_writetrack_done( int status )\n{\n\tDPRINT((\"fd_writetrack_done()\\n\"));\n\n\tstop_timeout();\n\n\tif (status & FDCSTAT_WPROT) {\n\t\tprintk(KERN_NOTICE \"fd%d: is write protected\\n\", SelectedDrive );\n\t\tgoto err_end;\n\t}\t\n\tif (status & FDCSTAT_LOST) {\n\t\tprintk(KERN_ERR \"fd%d: lost data (side %d, track %d)\\n\",\n\t\t\t\tSelectedDrive, ReqSide, ReqTrack );\n\t\tgoto err_end;\n\t}\n\n\tcomplete(&format_wait);\n\treturn;\n\n  err_end:\n\tfd_error();\n}\n\nstatic void fd_times_out(struct timer_list *unused)\n{\n\tatari_disable_irq( IRQ_MFP_FDC );\n\tif (!FloppyIRQHandler) goto end;  \n\n\tSET_IRQ_HANDLER( NULL );\n\t \n\tif (UseTrackbuffer)\n\t\tdel_timer( &readtrack_timer );\n\tFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\n\tudelay( 25 );\n\t\n\tprintk(KERN_ERR \"floppy timeout\\n\" );\n\tfd_error();\n  end:\n\tatari_enable_irq( IRQ_MFP_FDC );\n}\n\n\n \n\nstatic void finish_fdc( void )\n{\n\tif (!NeedSeek || !stdma_is_locked_by(floppy_irq)) {\n\t\tfinish_fdc_done( 0 );\n\t}\n\telse {\n\t\tDPRINT((\"finish_fdc: dummy seek started\\n\"));\n\t\tFDC_WRITE (FDCREG_DATA, SUD.track);\n\t\tSET_IRQ_HANDLER( finish_fdc_done );\n\t\tFDC_WRITE (FDCREG_CMD, FDCCMD_SEEK);\n\t\tMotorOn = 1;\n\t\tstart_timeout();\n\t\t \n\t  }\n}\n\n\nstatic void finish_fdc_done( int dummy )\n{\n\tunsigned long flags;\n\n\tDPRINT((\"finish_fdc_done entered\\n\"));\n\tstop_timeout();\n\tNeedSeek = 0;\n\n\tif (timer_pending(&fd_timer) && time_before(fd_timer.expires, jiffies + 5))\n\t\t \n\t\tmod_timer(&fd_timer, jiffies + 5);\n\telse\n\t\tstart_check_change_timer();\n\tstart_motor_off_timer();\n\n\tlocal_irq_save(flags);\n\tif (stdma_is_locked_by(floppy_irq))\n\t\tstdma_release();\n\tlocal_irq_restore(flags);\n\n\tDPRINT((\"finish_fdc() finished\\n\"));\n}\n\n \n\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tstruct atari_floppy_struct *p = disk->private_data;\n\tunsigned int drive = p - unit;\n\tif (test_bit (drive, &fake_change)) {\n\t\t \n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t}\n\tif (test_bit (drive, &changed_floppies)) {\n\t\t \n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t}\n\tif (UD.wpstat) {\n\t\t \n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tstruct atari_floppy_struct *p = disk->private_data;\n\tunsigned int drive = p - unit;\n\n\tif (test_bit(drive, &changed_floppies) ||\n\t    test_bit(drive, &fake_change) || !p->disktype) {\n\t\tif (UD.flags & FTD_MSG)\n\t\t\tprintk(KERN_ERR \"floppy: clear format %p!\\n\", UDT);\n\t\tBufferDrive = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(drive, &changed_floppies);\n\t\t \n\t\tif (default_params[drive].blocks == 0)\n\t\t\tUDT = NULL;\n\t\telse\n\t\t\tUDT = &default_params[drive];\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic void setup_req_params( int drive )\n{\n\tint block = ReqBlock + ReqCnt;\n\n\tReqTrack = block / UDT->spt;\n\tReqSector = block - ReqTrack * UDT->spt + 1;\n\tReqSide = ReqTrack & 1;\n\tReqTrack >>= 1;\n\tReqData = ReqBuffer + 512 * ReqCnt;\n\n\tif (UseTrackbuffer)\n\t\tread_track = (ReqCmd == READ && unit[drive].error_count == 0);\n\telse\n\t\tread_track = 0;\n\n\tDPRINT((\"Request params: Si=%d Tr=%d Se=%d Data=%08lx\\n\",ReqSide,\n\t\t\tReqTrack, ReqSector, (unsigned long)ReqData ));\n}\n\nstatic blk_status_t ataflop_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t     const struct blk_mq_queue_data *bd)\n{\n\tstruct atari_floppy_struct *floppy = bd->rq->q->disk->private_data;\n\tint drive = floppy - unit;\n\tint type = floppy->type;\n\n\tDPRINT((\"Queue request: drive %d type %d sectors %d of %d last %d\\n\",\n\t\tdrive, type, blk_rq_cur_sectors(bd->rq),\n\t\tblk_rq_sectors(bd->rq), bd->last));\n\n\tspin_lock_irq(&ataflop_lock);\n\tif (fd_request) {\n\t\tspin_unlock_irq(&ataflop_lock);\n\t\treturn BLK_STS_DEV_RESOURCE;\n\t}\n\tif (!stdma_try_lock(floppy_irq, NULL))  {\n\t\tspin_unlock_irq(&ataflop_lock);\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\tfd_request = bd->rq;\n\tunit[drive].error_count = 0;\n\tblk_mq_start_request(fd_request);\n\n\tatari_disable_irq( IRQ_MFP_FDC );\n\n\tIsFormatting = 0;\n\n\tif (!UD.connected) {\n\t\t \n\t\tprintk(KERN_ERR \"Unknown Device: fd%d\\n\", drive );\n\t\tfd_end_request_cur(BLK_STS_IOERR);\n\t\tstdma_release();\n\t\tgoto out;\n\t}\n\t\t\n\tif (type == 0) {\n\t\tif (!UDT) {\n\t\t\tProbing = 1;\n\t\t\tUDT = atari_disk_type + StartDiskType[DriveType];\n\t\t\tset_capacity(bd->rq->q->disk, UDT->blocks);\n\t\t\tUD.autoprobe = 1;\n\t\t}\n\t} \n\telse {\n\t\t \n\t\tif (--type >= NUM_DISK_MINORS) {\n\t\t\tprintk(KERN_WARNING \"fd%d: invalid disk format\", drive );\n\t\t\tfd_end_request_cur(BLK_STS_IOERR);\n\t\t\tstdma_release();\n\t\t\tgoto out;\n\t\t}\n\t\tif (minor2disktype[type].drive_types > DriveType)  {\n\t\t\tprintk(KERN_WARNING \"fd%d: unsupported disk format\", drive );\n\t\t\tfd_end_request_cur(BLK_STS_IOERR);\n\t\t\tstdma_release();\n\t\t\tgoto out;\n\t\t}\n\t\ttype = minor2disktype[type].index;\n\t\tUDT = &atari_disk_type[type];\n\t\tset_capacity(bd->rq->q->disk, UDT->blocks);\n\t\tUD.autoprobe = 0;\n\t}\n\n\t \n\tdel_timer( &motor_off_timer );\n\t\t\n\tReqCnt = 0;\n\tReqCmd = rq_data_dir(fd_request);\n\tReqBlock = blk_rq_pos(fd_request);\n\tReqBuffer = bio_data(fd_request->bio);\n\tsetup_req_params( drive );\n\tdo_fd_action( drive );\n\n\tatari_enable_irq( IRQ_MFP_FDC );\n\nout:\n\tspin_unlock_irq(&ataflop_lock);\n\treturn BLK_STS_OK;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t    unsigned int cmd, unsigned long param)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct atari_floppy_struct *floppy = disk->private_data;\n\tint drive = floppy - unit;\n\tint type = floppy->type;\n\tstruct atari_format_descr fmt_desc;\n\tstruct atari_disk_type *dtp;\n\tstruct floppy_struct getprm;\n\tint settype;\n\tstruct floppy_struct setprm;\n\tvoid __user *argp = (void __user *)param;\n\n\tswitch (cmd) {\n\tcase FDGETPRM:\n\t\tif (type) {\n\t\t\tif (--type >= NUM_DISK_MINORS)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (minor2disktype[type].drive_types > DriveType)\n\t\t\t\treturn -ENODEV;\n\t\t\ttype = minor2disktype[type].index;\n\t\t\tdtp = &atari_disk_type[type];\n\t\t\tif (UD.flags & FTD_MSG)\n\t\t\t    printk (KERN_ERR \"floppy%d: found dtp %p name %s!\\n\",\n\t\t\t        drive, dtp, dtp->name);\n\t\t}\n\t\telse {\n\t\t\tif (!UDT)\n\t\t\t\treturn -ENXIO;\n\t\t\telse\n\t\t\t\tdtp = UDT;\n\t\t}\n\t\tmemset((void *)&getprm, 0, sizeof(getprm));\n\t\tgetprm.size = dtp->blocks;\n\t\tgetprm.sect = dtp->spt;\n\t\tgetprm.head = 2;\n\t\tgetprm.track = dtp->blocks/dtp->spt/2;\n\t\tgetprm.stretch = dtp->stretch;\n\t\tif (copy_to_user(argp, &getprm, sizeof(getprm)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tswitch (cmd) {\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t         \n\n\t\t \n\t\tif (floppy->ref != 1 && floppy->ref != -1)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&setprm, argp, sizeof(setprm)))\n\t\t\treturn -EFAULT;\n\t\t \n\n\t\tif (floppy_check_events(disk, 0))\n\t\t        floppy_revalidate(disk);\n\n\t\tif (UD.flags & FTD_MSG)\n\t\t    printk (KERN_INFO \"floppy%d: setting size %d spt %d str %d!\\n\",\n\t\t\tdrive, setprm.size, setprm.sect, setprm.stretch);\n\n\t\t \n\t\tif (type) {\n\t\t         \n\t\t\tfinish_fdc();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\tfor (settype = 0; settype < NUM_DISK_MINORS; settype++) {\n\t\t\tint setidx = 0;\n\t\t\tif (minor2disktype[settype].drive_types > DriveType) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsetidx = minor2disktype[settype].index;\n\t\t\tdtp = &atari_disk_type[setidx];\n\n\t\t\t \n\t\t\tif (   dtp->blocks  == setprm.size \n\t\t\t    && dtp->spt     == setprm.sect\n\t\t\t    && dtp->stretch == setprm.stretch ) {\n\t\t\t\tif (UD.flags & FTD_MSG)\n\t\t\t\t    printk (KERN_INFO \"floppy%d: setting %s %p!\\n\",\n\t\t\t\t        drive, dtp->name, dtp);\n\t\t\t\tUDT = dtp;\n\t\t\t\tset_capacity(disk, UDT->blocks);\n\n\t\t\t\tif (cmd == FDDEFPRM) {\n\t\t\t\t   \n\t\t\t\t  default_params[drive].name    = dtp->name;\n\t\t\t\t  default_params[drive].spt     = dtp->spt;\n\t\t\t\t  default_params[drive].blocks  = dtp->blocks;\n\t\t\t\t  default_params[drive].fdc_speed = dtp->fdc_speed;\n\t\t\t\t  default_params[drive].stretch = dtp->stretch;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\n\t       \tif (cmd == FDDEFPRM) {\n\t\t\t \n\t\t\tdtp = &default_params[drive];\n\t\t} else\n\t\t\t \n\t\t\tdtp = &user_params[drive];\n\n\t\tdtp->name   = \"user format\";\n\t\tdtp->blocks = setprm.size;\n\t\tdtp->spt    = setprm.sect;\n\t\tif (setprm.sect > 14) \n\t\t\tdtp->fdc_speed = 3;\n\t\telse\n\t\t\tdtp->fdc_speed = 0;\n\t\tdtp->stretch = setprm.stretch;\n\n\t\tif (UD.flags & FTD_MSG)\n\t\t\tprintk (KERN_INFO \"floppy%d: blk %d spt %d str %d!\\n\",\n\t\t\t\tdrive, dtp->blocks, dtp->spt, dtp->stretch);\n\n\t\t \n\t\tif (setprm.track != dtp->blocks/dtp->spt/2 ||\n\t\t    setprm.head != 2) {\n\t\t\tfinish_fdc();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tUDT = dtp;\n\t\tset_capacity(disk, UDT->blocks);\n\n\t\treturn 0;\n\tcase FDMSGON:\n\t\tUD.flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tUD.flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDSETEMSGTRESH:\n\t\treturn -EINVAL;\n\tcase FDFMTBEG:\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (floppy->ref != 1 && floppy->ref != -1)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&fmt_desc, argp, sizeof(fmt_desc)))\n\t\t\treturn -EFAULT;\n\t\treturn do_format(drive, type, &fmt_desc);\n\tcase FDCLRPRM:\n\t\tUDT = NULL;\n\t\t \n\t\tdefault_params[drive].blocks  = 0;\n\t\tset_capacity(disk, MAX_DISK_SIZE * 2);\n\t\tfallthrough;\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\t \n\t\tBufferDrive = -1;\n\t\tset_bit(drive, &fake_change);\n\t\tif (disk_check_media_change(disk))\n\t\t\tfloppy_revalidate(disk);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fd_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&ataflop_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, arg);\n\tmutex_unlock(&ataflop_mutex);\n\n\treturn ret;\n}\n\n \n\nstatic void __init fd_probe( int drive )\n{\n\tUD.connected = 0;\n\tUDT  = NULL;\n\n\tif (!fd_test_drive_present( drive ))\n\t\treturn;\n\n\tUD.connected = 1;\n\tUD.track     = 0;\n\tswitch( UserSteprate[drive] ) {\n\tcase 2:\n\t\tUD.steprate = FDCSTEP_2;\n\t\tbreak;\n\tcase 3:\n\t\tUD.steprate = FDCSTEP_3;\n\t\tbreak;\n\tcase 6:\n\t\tUD.steprate = FDCSTEP_6;\n\t\tbreak;\n\tcase 12:\n\t\tUD.steprate = FDCSTEP_12;\n\t\tbreak;\n\tdefault:  \n\t\tif (ATARIHW_PRESENT( FDCSPEED ) || MACH_IS_MEDUSA)\n\t\t\tUD.steprate = FDCSTEP_3;\n\t\telse\n\t\t\tUD.steprate = FDCSTEP_6;\n\t\tbreak;\n\t}\n\tMotorOn = 1;\t \n}\n\n\n \n\nstatic int __init fd_test_drive_present( int drive )\n{\n\tunsigned long timeout;\n\tunsigned char status;\n\tint ok;\n\t\n\tif (drive >= (MACH_IS_FALCON ? 1 : 2)) return( 0 );\n\tfd_select_drive( drive );\n\n\t \n\tatari_turnoff_irq( IRQ_MFP_FDC );\n\tFDC_WRITE (FDCREG_TRACK, 0xff00);\n\tFDC_WRITE( FDCREG_CMD, FDCCMD_RESTORE | FDCCMDADD_H | FDCSTEP_6 );\n\n\ttimeout = jiffies + 2*HZ+HZ/2;\n\twhile (time_before(jiffies, timeout))\n\t\tif (!(st_mfp.par_dt_reg & 0x20))\n\t\t\tbreak;\n\n\tstatus = FDC_READ( FDCREG_STATUS );\n\tok = (status & FDCSTAT_TR00) != 0;\n\n\t \n\tFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\n\tudelay(500);\n\tstatus = FDC_READ( FDCREG_STATUS );\n\tudelay(20);\n\n\tif (ok) {\n\t\t \n\t\tFDC_WRITE( FDCREG_DATA, 0 );\n\t\tFDC_WRITE( FDCREG_CMD, FDCCMD_SEEK );\n\t\twhile( st_mfp.par_dt_reg & 0x20 )\n\t\t\t;\n\t\tstatus = FDC_READ( FDCREG_STATUS );\n\t}\n\n\tatari_turnon_irq( IRQ_MFP_FDC );\n\treturn( ok );\n}\n\n\n \n\nstatic void __init config_types( void )\n{\n\tint drive, cnt = 0;\n\n\t \n\tif (ATARIHW_PRESENT(FDCSPEED))\n\t\tdma_wd.fdc_speed = 0;\n\n\tprintk(KERN_INFO \"Probing floppy drive(s):\\n\");\n\tfor( drive = 0; drive < FD_MAX_UNITS; drive++ ) {\n\t\tfd_probe( drive );\n\t\tif (UD.connected) {\n\t\t\tprintk(KERN_INFO \"fd%d\\n\", drive);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tif (FDC_READ( FDCREG_STATUS ) & FDCSTAT_BUSY) {\n\t\t \n\t\tFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\n\t\tudelay(500);\n\t\tFDC_READ( FDCREG_STATUS );\n\t\tudelay(20);\n\t}\n\t\n\tif (cnt > 0) {\n\t\tstart_motor_off_timer();\n\t\tif (cnt == 1) fd_select_drive( 0 );\n\t\tstart_check_change_timer();\n\t}\n}\n\n \n\nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct atari_floppy_struct *p = disk->private_data;\n\tint type = disk->first_minor >> 2;\n\n\tDPRINT((\"fd_open: type=%d\\n\",type));\n\tif (p->ref && p->type != type)\n\t\treturn -EBUSY;\n\n\tif (p->ref == -1 || (p->ref && mode & BLK_OPEN_EXCL))\n\t\treturn -EBUSY;\n\tif (mode & BLK_OPEN_EXCL)\n\t\tp->ref = -1;\n\telse\n\t\tp->ref++;\n\n\tp->type = type;\n\n\tif (mode & BLK_OPEN_NDELAY)\n\t\treturn 0;\n\n\tif (mode & (BLK_OPEN_READ | BLK_OPEN_WRITE)) {\n\t\tif (disk_check_media_change(disk))\n\t\t\tfloppy_revalidate(disk);\n\t\tif (mode & BLK_OPEN_WRITE) {\n\t\t\tif (p->wpstat) {\n\t\t\t\tif (p->ref < 0)\n\t\t\t\t\tp->ref = 0;\n\t\t\t\telse\n\t\t\t\t\tp->ref--;\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int floppy_unlocked_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint ret;\n\n\tmutex_lock(&ataflop_mutex);\n\tret = floppy_open(disk, mode);\n\tmutex_unlock(&ataflop_mutex);\n\n\treturn ret;\n}\n\nstatic void floppy_release(struct gendisk *disk)\n{\n\tstruct atari_floppy_struct *p = disk->private_data;\n\tmutex_lock(&ataflop_mutex);\n\tif (p->ref < 0)\n\t\tp->ref = 0;\n\telse if (!p->ref--) {\n\t\tprintk(KERN_ERR \"floppy_release with fd_ref == 0\");\n\t\tp->ref = 0;\n\t}\n\tmutex_unlock(&ataflop_mutex);\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= floppy_unlocked_open,\n\t.release\t= floppy_release,\n\t.ioctl\t\t= fd_ioctl,\n\t.check_events\t= floppy_check_events,\n};\n\nstatic const struct blk_mq_ops ataflop_mq_ops = {\n\t.queue_rq = ataflop_queue_rq,\n};\n\nstatic int ataflop_alloc_disk(unsigned int drive, unsigned int type)\n{\n\tstruct gendisk *disk;\n\n\tdisk = blk_mq_alloc_disk(&unit[drive].tag_set, NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = drive + (type << 2);\n\tdisk->minors = 1;\n\tsprintf(disk->disk_name, \"fd%d\", drive);\n\tdisk->fops = &floppy_fops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tdisk->private_data = &unit[drive];\n\tset_capacity(disk, MAX_DISK_SIZE * 2);\n\n\tunit[drive].disk[type] = disk;\n\treturn 0;\n}\n\nstatic void ataflop_probe(dev_t dev)\n{\n\tint drive = MINOR(dev) & 3;\n\tint type  = MINOR(dev) >> 2;\n\n\tif (type)\n\t\ttype--;\n\n\tif (drive >= FD_MAX_UNITS || type >= NUM_DISK_MINORS)\n\t\treturn;\n\tif (unit[drive].disk[type])\n\t\treturn;\n\tif (ataflop_alloc_disk(drive, type))\n\t\treturn;\n\tif (add_disk(unit[drive].disk[type]))\n\t\tgoto cleanup_disk;\n\tunit[drive].registered[type] = true;\n\treturn;\n\ncleanup_disk:\n\tput_disk(unit[drive].disk[type]);\n\tunit[drive].disk[type] = NULL;\n}\n\nstatic void atari_floppy_cleanup(void)\n{\n\tint i;\n\tint type;\n\n\tfor (i = 0; i < FD_MAX_UNITS; i++) {\n\t\tfor (type = 0; type < NUM_DISK_MINORS; type++) {\n\t\t\tif (!unit[i].disk[type])\n\t\t\t\tcontinue;\n\t\t\tdel_gendisk(unit[i].disk[type]);\n\t\t\tput_disk(unit[i].disk[type]);\n\t\t}\n\t\tblk_mq_free_tag_set(&unit[i].tag_set);\n\t}\n\n\tdel_timer_sync(&fd_timer);\n\tatari_stram_free(DMABuffer);\n}\n\nstatic void atari_cleanup_floppy_disk(struct atari_floppy_struct *fs)\n{\n\tint type;\n\n\tfor (type = 0; type < NUM_DISK_MINORS; type++) {\n\t\tif (!fs->disk[type])\n\t\t\tcontinue;\n\t\tif (fs->registered[type])\n\t\t\tdel_gendisk(fs->disk[type]);\n\t\tput_disk(fs->disk[type]);\n\t}\n\tblk_mq_free_tag_set(&fs->tag_set);\n}\n\nstatic int __init atari_floppy_init (void)\n{\n\tint i;\n\tint ret;\n\n\tif (!MACH_IS_ATARI)\n\t\t \n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < FD_MAX_UNITS; i++) {\n\t\tmemset(&unit[i].tag_set, 0, sizeof(unit[i].tag_set));\n\t\tunit[i].tag_set.ops = &ataflop_mq_ops;\n\t\tunit[i].tag_set.nr_hw_queues = 1;\n\t\tunit[i].tag_set.nr_maps = 1;\n\t\tunit[i].tag_set.queue_depth = 2;\n\t\tunit[i].tag_set.numa_node = NUMA_NO_NODE;\n\t\tunit[i].tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\t\tret = blk_mq_alloc_tag_set(&unit[i].tag_set);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = ataflop_alloc_disk(i, 0);\n\t\tif (ret) {\n\t\t\tblk_mq_free_tag_set(&unit[i].tag_set);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (UseTrackbuffer < 0)\n\t\t \n\t\tUseTrackbuffer = !MACH_IS_MEDUSA;\n\n\t \n\tSelectedDrive = -1;\n\tBufferDrive = -1;\n\n\tDMABuffer = atari_stram_alloc(BUFFER_SIZE+512, \"ataflop\");\n\tif (!DMABuffer) {\n\t\tprintk(KERN_ERR \"atari_floppy_init: cannot get dma buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tTrackBuffer = DMABuffer + 512;\n\tPhysDMABuffer = atari_stram_to_phys(DMABuffer);\n\tPhysTrackBuffer = virt_to_phys(TrackBuffer);\n\tBufferDrive = BufferSide = BufferTrack = -1;\n\n\tfor (i = 0; i < FD_MAX_UNITS; i++) {\n\t\tunit[i].track = -1;\n\t\tunit[i].flags = 0;\n\t\tret = add_disk(unit[i].disk[0]);\n\t\tif (ret)\n\t\t\tgoto err_out_dma;\n\t\tunit[i].registered[0] = true;\n\t}\n\n\tprintk(KERN_INFO \"Atari floppy driver: max. %cD, %strack buffering\\n\",\n\t       DriveType == 0 ? 'D' : DriveType == 1 ? 'H' : 'E',\n\t       UseTrackbuffer ? \"\" : \"no \");\n\tconfig_types();\n\n\tret = __register_blkdev(FLOPPY_MAJOR, \"fd\", ataflop_probe);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"atari_floppy_init: cannot register block device\\n\");\n\t\tatari_floppy_cleanup();\n\t}\n\treturn ret;\n\nerr_out_dma:\n\tatari_stram_free(DMABuffer);\nerr:\n\twhile (--i >= 0)\n\t\tatari_cleanup_floppy_disk(&unit[i]);\n\n\treturn ret;\n}\n\n#ifndef MODULE\nstatic int __init atari_floppy_setup(char *str)\n{\n\tint ints[3 + FD_MAX_UNITS];\n\tint i;\n\n\tif (!MACH_IS_ATARI)\n\t\treturn 0;\n\n\tstr = get_options(str, 3 + FD_MAX_UNITS, ints);\n\t\n\tif (ints[0] < 1) {\n\t\tprintk(KERN_ERR \"ataflop_setup: no arguments!\\n\" );\n\t\treturn 0;\n\t}\n\telse if (ints[0] > 2+FD_MAX_UNITS) {\n\t\tprintk(KERN_ERR \"ataflop_setup: too many arguments\\n\" );\n\t}\n\n\tif (ints[1] < 0 || ints[1] > 2)\n\t\tprintk(KERN_ERR \"ataflop_setup: bad drive type\\n\" );\n\telse\n\t\tDriveType = ints[1];\n\n\tif (ints[0] >= 2)\n\t\tUseTrackbuffer = (ints[2] > 0);\n\n\tfor( i = 3; i <= ints[0] && i-3 < FD_MAX_UNITS; ++i ) {\n\t\tif (ints[i] != 2 && ints[i] != 3 && ints[i] != 6 && ints[i] != 12)\n\t\t\tprintk(KERN_ERR \"ataflop_setup: bad steprate\\n\" );\n\t\telse\n\t\t\tUserSteprate[i-3] = ints[i];\n\t}\n\treturn 1;\n}\n\n__setup(\"floppy=\", atari_floppy_setup);\n#endif\n\nstatic void __exit atari_floppy_exit(void)\n{\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tatari_floppy_cleanup();\n}\n\nmodule_init(atari_floppy_init)\nmodule_exit(atari_floppy_exit)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}