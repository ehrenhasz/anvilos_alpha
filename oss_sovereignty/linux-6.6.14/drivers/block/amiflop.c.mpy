{
  "module_name": "amiflop.c",
  "hash_id": "aacd97f5c63d51d9b6e32dfd755d1dea30fe97e6ed762e5f4c73418a0c2e4e77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/amiflop.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/blk-mq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <asm/setup.h>\n#include <linux/uaccess.h>\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/irq.h>\n\n#undef DEBUG  \n\n#define RAW_IOCTL\n#ifdef RAW_IOCTL\n#define IOCTL_RAW_TRACK 0x5254524B   \n#endif\n\n \n\n \n\n#define DSKRDY      (0x1<<5)         \n#define DSKTRACK0   (0x1<<4)         \n#define DSKPROT     (0x1<<3)         \n#define DSKCHANGE   (0x1<<2)         \n\n \n\n#define DSKMOTOR    (0x1<<7)         \n#define DSKSEL3     (0x1<<6)         \n#define DSKSEL2     (0x1<<5)         \n#define DSKSEL1     (0x1<<4)         \n#define DSKSEL0     (0x1<<3)         \n#define DSKSIDE     (0x1<<2)         \n#define DSKDIREC    (0x1<<1)         \n#define DSKSTEP     (0x1)            \n\n \n\n#define DSKBYT      (1<<15)          \n#define DMAON       (1<<14)          \n#define DISKWRITE   (1<<13)          \n#define WORDEQUAL   (1<<12)          \n \n\n \n\n#ifndef SETCLR\n#define ADK_SETCLR      (1<<15)      \n#endif\n#define ADK_PRECOMP1    (1<<14)      \n#define ADK_PRECOMP0    (1<<13)      \n#define ADK_MFMPREC     (1<<12)      \n#define ADK_WORDSYNC    (1<<10)      \n#define ADK_MSBSYNC     (1<<9)       \n#define ADK_FAST        (1<<8)       \n\n \n\n#define DSKLEN_DMAEN    (1<<15)\n#define DSKLEN_WRITE    (1<<14)\n\n \n\n#define DSKINDEX    (0x1<<4)         \n\n \n\n#define MFM_SYNC    0x4489           \n\n \n#define FD_RECALIBRATE\t\t0x07\t \n#define FD_SEEK\t\t\t0x0F\t \n#define FD_READ\t\t\t0xE6\t \n#define FD_WRITE\t\t0xC5\t \n#define FD_SENSEI\t\t0x08\t \n#define FD_SPECIFY\t\t0x03\t \n#define FD_FORMAT\t\t0x4D\t \n#define FD_VERSION\t\t0x10\t \n#define FD_CONFIGURE\t\t0x13\t \n#define FD_PERPENDICULAR\t0x12\t \n\n#define FD_MAX_UNITS    4\t \n#define FLOPPY_MAX_SECTORS\t22\t \n\nstruct fd_data_type {\n\tchar *name;\t\t \n\tint sects;\t\t \n\tint (*read_fkt)(int);\t \n\tvoid (*write_fkt)(int);\t \n};\n\nstruct fd_drive_type {\n\tunsigned long code;\t\t \n\tchar *name;\t\t\t \n\tunsigned int tracks;\t \n\tunsigned int heads;\t\t \n\tunsigned int read_size;\t \n\tunsigned int write_size;\t \n\tunsigned int sect_mult;\t \n\tunsigned int precomp1;\t \n\tunsigned int precomp2;\t \n\tunsigned int step_delay;\t \n\tunsigned int settle_time;\t \n\tunsigned int side_time;\t \n};\n\nstruct amiga_floppy_struct {\n\tstruct fd_drive_type *type;\t \n\tstruct fd_data_type *dtype;\t \n\tint track;\t\t\t \n\tunsigned char *trackbuf;\t \n\n\tint blocks;\t\t\t \n\n\tint changed;\t\t\t \n\tint disk;\t\t\t \n\tint motor;\t\t\t \n\tint busy;\t\t\t \n\tint dirty;\t\t\t \n\tint status;\t\t\t \n\tstruct gendisk *gendisk[2];\n\tstruct blk_mq_tag_set tag_set;\n};\n\n \n#define FD_OK\t\t0\t \n#define FD_ERROR\t-1\t \n#define FD_NOUNIT\t1\t \n#define FD_UNITBUSY\t2\t \n#define FD_NOTACTIVE\t3\t \n#define FD_NOTREADY\t4\t \n\n#define MFM_NOSYNC\t1\n#define MFM_HEADER\t2\n#define MFM_DATA\t3\n#define MFM_TRACK\t4\n\n \n#define FD_NODRIVE\t0x00000000   \n#define FD_DD_3 \t0xffffffff   \n#define FD_HD_3 \t0x55555555   \n#define FD_DD_5 \t0xaaaaaaaa   \n\nstatic DEFINE_MUTEX(amiflop_mutex);\nstatic unsigned long int fd_def_df0 = FD_DD_3;      \n\nmodule_param(fd_def_df0, ulong, 0);\nMODULE_LICENSE(\"GPL\");\n\n \n#define MOTOR_ON\t(ciab.prb &= ~DSKMOTOR)\n#define MOTOR_OFF\t(ciab.prb |= DSKMOTOR)\n#define SELECT(mask)    (ciab.prb &= ~mask)\n#define DESELECT(mask)  (ciab.prb |= mask)\n#define SELMASK(drive)  (1 << (3 + (drive & 3)))\n\nstatic struct fd_drive_type drive_types[] = {\n \n \n{ FD_DD_3,\t\"DD 3.5\",  80, 2, 14716, 13630, 1, 80,161, 3, 18, 1},\n{ FD_HD_3,\t\"HD 3.5\",  80, 2, 28344, 27258, 2, 80,161, 3, 18, 1},\n{ FD_DD_5,\t\"DD 5.25\", 40, 2, 14716, 13630, 1, 40, 81, 6, 30, 2},\n{ FD_NODRIVE, \"No Drive\", 0, 0,     0,     0, 0,  0,  0,  0,  0, 0}\n};\nstatic int num_dr_types = ARRAY_SIZE(drive_types);\n\nstatic int amiga_read(int), dos_read(int);\nstatic void amiga_write(int), dos_write(int);\nstatic struct fd_data_type data_types[] = {\n\t{ \"Amiga\", 11 , amiga_read, amiga_write},\n\t{ \"MS-Dos\", 9, dos_read, dos_write}\n};\n\n \nstatic struct amiga_floppy_struct unit[FD_MAX_UNITS];\n\nstatic struct timer_list flush_track_timer[FD_MAX_UNITS];\nstatic struct timer_list post_write_timer;\nstatic unsigned long post_write_timer_drive;\nstatic struct timer_list motor_on_timer;\nstatic struct timer_list motor_off_timer[FD_MAX_UNITS];\nstatic int on_attempts;\n\n \n \nstatic volatile int fdc_busy = -1;\nstatic volatile int fdc_nested;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\n \nstatic DECLARE_COMPLETION(motor_on_completion);\n\nstatic volatile int selected = -1;\t \n\nstatic int writepending;\nstatic int writefromint;\nstatic char *raw_buf;\n\nstatic DEFINE_SPINLOCK(amiflop_lock);\n\n#define RAW_BUF_SIZE 30000   \n\n \nstatic volatile char block_flag;\nstatic DECLARE_WAIT_QUEUE_HEAD(wait_fd_block);\n\n \nstatic unsigned char mfmencode[16]={\n\t0x2a, 0x29, 0x24, 0x25, 0x12, 0x11, 0x14, 0x15,\n\t0x4a, 0x49, 0x44, 0x45, 0x52, 0x51, 0x54, 0x55\n};\nstatic unsigned char mfmdecode[128];\n\n \nstatic DECLARE_COMPLETION(ms_wait_completion);\n#define MS_TICKS ((amiga_eclock+50)/1000)\n\n \n#define MAX_ERRORS 12\n\n#define custom amiga_custom\n\n \nstatic int fd_ref[4] = { 0,0,0,0 };\nstatic int fd_device[4] = { 0, 0, 0, 0 };\n\n \n\n \n\nstatic irqreturn_t ms_isr(int irq, void *dummy)\n{\n\tcomplete(&ms_wait_completion);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ms_delay(int ms)\n{\n\tint ticks;\n\tstatic DEFINE_MUTEX(mutex);\n\n\tif (ms > 0) {\n\t\tmutex_lock(&mutex);\n\t\tticks = MS_TICKS*ms-1;\n\t\tciaa.tblo=ticks%256;\n\t\tciaa.tbhi=ticks/256;\n\t\tciaa.crb=0x19;  \n\t\twait_for_completion(&ms_wait_completion);\n\t\tmutex_unlock(&mutex);\n\t}\n}\n\n \n\n \nstatic inline int try_fdc(int drive)\n{\n\tdrive &= 3;\n\treturn ((fdc_busy < 0) || (fdc_busy == drive));\n}\n\nstatic void get_fdc(int drive)\n{\n\tunsigned long flags;\n\n\tdrive &= 3;\n#ifdef DEBUG\n\tprintk(\"get_fdc: drive %d  fdc_busy %d  fdc_nested %d\\n\",drive,fdc_busy,fdc_nested);\n#endif\n\tlocal_irq_save(flags);\n\twait_event(fdc_wait, try_fdc(drive));\n\tfdc_busy = drive;\n\tfdc_nested++;\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void rel_fdc(void)\n{\n#ifdef DEBUG\n\tif (fdc_nested == 0)\n\t\tprintk(\"fd: unmatched rel_fdc\\n\");\n\tprintk(\"rel_fdc: fdc_busy %d fdc_nested %d\\n\",fdc_busy,fdc_nested);\n#endif\n\tfdc_nested--;\n\tif (fdc_nested == 0) {\n\t\tfdc_busy = -1;\n\t\twake_up(&fdc_wait);\n\t}\n}\n\nstatic void fd_select (int drive)\n{\n\tunsigned char prb = ~0;\n\n\tdrive&=3;\n#ifdef DEBUG\n\tprintk(\"selecting %d\\n\",drive);\n#endif\n\tif (drive == selected)\n\t\treturn;\n\tget_fdc(drive);\n\tselected = drive;\n\n\tif (unit[drive].track % 2 != 0)\n\t\tprb &= ~DSKSIDE;\n\tif (unit[drive].motor == 1)\n\t\tprb &= ~DSKMOTOR;\n\tciab.prb |= (SELMASK(0)|SELMASK(1)|SELMASK(2)|SELMASK(3));\n\tciab.prb = prb;\n\tprb &= ~SELMASK(drive);\n\tciab.prb = prb;\n\trel_fdc();\n}\n\nstatic void fd_deselect (int drive)\n{\n\tunsigned char prb;\n\tunsigned long flags;\n\n\tdrive&=3;\n#ifdef DEBUG\n\tprintk(\"deselecting %d\\n\",drive);\n#endif\n\tif (drive != selected) {\n\t\tprintk(KERN_WARNING \"Deselecting drive %d while %d was selected!\\n\",drive,selected);\n\t\treturn;\n\t}\n\n\tget_fdc(drive);\n\tlocal_irq_save(flags);\n\n\tselected = -1;\n\n\tprb = ciab.prb;\n\tprb |= (SELMASK(0)|SELMASK(1)|SELMASK(2)|SELMASK(3));\n\tciab.prb = prb;\n\n\tlocal_irq_restore (flags);\n\trel_fdc();\n\n}\n\nstatic void motor_on_callback(struct timer_list *unused)\n{\n\tif (!(ciaa.pra & DSKRDY) || --on_attempts == 0) {\n\t\tcomplete_all(&motor_on_completion);\n\t} else {\n\t\tmotor_on_timer.expires = jiffies + HZ/10;\n\t\tadd_timer(&motor_on_timer);\n\t}\n}\n\nstatic int fd_motor_on(int nr)\n{\n\tnr &= 3;\n\n\tdel_timer(motor_off_timer + nr);\n\n\tif (!unit[nr].motor) {\n\t\tunit[nr].motor = 1;\n\t\tfd_select(nr);\n\n\t\treinit_completion(&motor_on_completion);\n\t\tmod_timer(&motor_on_timer, jiffies + HZ/2);\n\n\t\ton_attempts = 10;\n\t\twait_for_completion(&motor_on_completion);\n\t\tfd_deselect(nr);\n\t}\n\n\tif (on_attempts == 0) {\n\t\ton_attempts = -1;\n#if 0\n\t\tprintk (KERN_ERR \"motor_on failed, turning motor off\\n\");\n\t\tfd_motor_off (motor_off_timer + nr);\n\t\treturn 0;\n#else\n\t\tprintk (KERN_WARNING \"DSKRDY not set after 1.5 seconds - assuming drive is spinning notwithstanding\\n\");\n#endif\n\t}\n\n\treturn 1;\n}\n\nstatic void fd_motor_off(struct timer_list *timer)\n{\n\tunsigned long drive = ((unsigned long)timer -\n\t\t\t       (unsigned long)&motor_off_timer[0]) /\n\t\t\t\t\tsizeof(motor_off_timer[0]);\n\n\tdrive&=3;\n\tif (!try_fdc(drive)) {\n\t\t \n\t\ttimer->expires = jiffies + 1;\n\t\tadd_timer(timer);\n\t\treturn;\n\t}\n\tunit[drive].motor = 0;\n\tfd_select(drive);\n\tudelay (1);\n\tfd_deselect(drive);\n}\n\nstatic void floppy_off (unsigned int nr)\n{\n\tint drive;\n\n\tdrive = nr & 3;\n\tmod_timer(motor_off_timer + drive, jiffies + 3*HZ);\n}\n\nstatic int fd_calibrate(int drive)\n{\n\tunsigned char prb;\n\tint n;\n\n\tdrive &= 3;\n\tget_fdc(drive);\n\tif (!fd_motor_on (drive))\n\t\treturn 0;\n\tfd_select (drive);\n\tprb = ciab.prb;\n\tprb |= DSKSIDE;\n\tprb &= ~DSKDIREC;\n\tciab.prb = prb;\n\tfor (n = unit[drive].type->tracks/2; n != 0; --n) {\n\t\tif (ciaa.pra & DSKTRACK0)\n\t\t\tbreak;\n\t\tprb &= ~DSKSTEP;\n\t\tciab.prb = prb;\n\t\tprb |= DSKSTEP;\n\t\tudelay (2);\n\t\tciab.prb = prb;\n\t\tms_delay(unit[drive].type->step_delay);\n\t}\n\tms_delay (unit[drive].type->settle_time);\n\tprb |= DSKDIREC;\n\tn = unit[drive].type->tracks + 20;\n\tfor (;;) {\n\t\tprb &= ~DSKSTEP;\n\t\tciab.prb = prb;\n\t\tprb |= DSKSTEP;\n\t\tudelay (2);\n\t\tciab.prb = prb;\n\t\tms_delay(unit[drive].type->step_delay + 1);\n\t\tif ((ciaa.pra & DSKTRACK0) == 0)\n\t\t\tbreak;\n\t\tif (--n == 0) {\n\t\t\tprintk (KERN_ERR \"fd%d: calibrate failed, turning motor off\\n\", drive);\n\t\t\tfd_motor_off (motor_off_timer + drive);\n\t\t\tunit[drive].track = -1;\n\t\t\trel_fdc();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tunit[drive].track = 0;\n\tms_delay(unit[drive].type->settle_time);\n\n\trel_fdc();\n\tfd_deselect(drive);\n\treturn 1;\n}\n\nstatic int fd_seek(int drive, int track)\n{\n\tunsigned char prb;\n\tint cnt;\n\n#ifdef DEBUG\n\tprintk(\"seeking drive %d to track %d\\n\",drive,track);\n#endif\n\tdrive &= 3;\n\tget_fdc(drive);\n\tif (unit[drive].track == track) {\n\t\trel_fdc();\n\t\treturn 1;\n\t}\n\tif (!fd_motor_on(drive)) {\n\t\trel_fdc();\n\t\treturn 0;\n\t}\n\tif (unit[drive].track < 0 && !fd_calibrate(drive)) {\n\t\trel_fdc();\n\t\treturn 0;\n\t}\n\n\tfd_select (drive);\n\tcnt = unit[drive].track/2 - track/2;\n\tprb = ciab.prb;\n\tprb |= DSKSIDE | DSKDIREC;\n\tif (track % 2 != 0)\n\t\tprb &= ~DSKSIDE;\n\tif (cnt < 0) {\n\t\tcnt = - cnt;\n\t\tprb &= ~DSKDIREC;\n\t}\n\tciab.prb = prb;\n\tif (track % 2 != unit[drive].track % 2)\n\t\tms_delay (unit[drive].type->side_time);\n\tunit[drive].track = track;\n\tif (cnt == 0) {\n\t\trel_fdc();\n\t\tfd_deselect(drive);\n\t\treturn 1;\n\t}\n\tdo {\n\t\tprb &= ~DSKSTEP;\n\t\tciab.prb = prb;\n\t\tprb |= DSKSTEP;\n\t\tudelay (1);\n\t\tciab.prb = prb;\n\t\tms_delay (unit[drive].type->step_delay);\n\t} while (--cnt != 0);\n\tms_delay (unit[drive].type->settle_time);\n\n\trel_fdc();\n\tfd_deselect(drive);\n\treturn 1;\n}\n\nstatic unsigned long fd_get_drive_id(int drive)\n{\n\tint i;\n\tulong id = 0;\n\n  \tdrive&=3;\n  \tget_fdc(drive);\n\t \n\tMOTOR_ON;\n\tudelay(2);\n\tSELECT(SELMASK(drive));\n\tudelay(2);\n\tDESELECT(SELMASK(drive));\n\tudelay(2);\n\tMOTOR_OFF;\n\tudelay(2);\n\tSELECT(SELMASK(drive));\n\tudelay(2);\n\tDESELECT(SELMASK(drive));\n\tudelay(2);\n\n\t \n\tfor (i=0; i<32; i++) {\n\t\tSELECT(SELMASK(drive));\n\t\tudelay(2);\n\n\t\t \n\t\tid <<= 1;\n\t\tid |= (ciaa.pra & DSKRDY) ? 0 : 1;\t \n\n\t\tDESELECT(SELMASK(drive));\n\t}\n\n\trel_fdc();\n\n         \n        if(drive == 0 && id == FD_NODRIVE)\n\t{\n                id = fd_def_df0;\n                printk(KERN_NOTICE \"fd: drive 0 didn't identify, setting default %08lx\\n\", (ulong)fd_def_df0);\n\t}\n\t \n\treturn (id);\n}\n\nstatic irqreturn_t fd_block_done(int irq, void *dummy)\n{\n\tif (block_flag)\n\t\tcustom.dsklen = 0x4000;\n\n\tif (block_flag == 2) {  \n\t\twritepending = 2;\n\t\tpost_write_timer.expires = jiffies + 1;  \n\t\tpost_write_timer_drive = selected;\n\t\tadd_timer(&post_write_timer);\n\t}\n\telse {                 \n\t\tblock_flag = 0;\n\t\twake_up (&wait_fd_block);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void raw_read(int drive)\n{\n\tdrive&=3;\n\tget_fdc(drive);\n\twait_event(wait_fd_block, !block_flag);\n\tfd_select(drive);\n\t \n\tcustom.adkcon = ADK_MSBSYNC;\n\tcustom.adkcon = ADK_SETCLR|ADK_WORDSYNC|ADK_FAST;\n\n\tcustom.dsksync = MFM_SYNC;\n\n\tcustom.dsklen = 0;\n\tcustom.dskptr = (u_char *)ZTWO_PADDR((u_char *)raw_buf);\n\tcustom.dsklen = unit[drive].type->read_size/sizeof(short) | DSKLEN_DMAEN;\n\tcustom.dsklen = unit[drive].type->read_size/sizeof(short) | DSKLEN_DMAEN;\n\n\tblock_flag = 1;\n\n\twait_event(wait_fd_block, !block_flag);\n\n\tcustom.dsklen = 0;\n\tfd_deselect(drive);\n\trel_fdc();\n}\n\nstatic int raw_write(int drive)\n{\n\tushort adk;\n\n\tdrive&=3;\n\tget_fdc(drive);  \n\tif ((ciaa.pra & DSKPROT) == 0) {\n\t\trel_fdc();\n\t\treturn 0;\n\t}\n\twait_event(wait_fd_block, !block_flag);\n\tfd_select(drive);\n\t \n\tcustom.adkcon = ADK_PRECOMP1|ADK_PRECOMP0|ADK_WORDSYNC|ADK_MSBSYNC;\n\t \n\tadk = ADK_SETCLR|ADK_FAST;\n\tif ((ulong)unit[drive].track >= unit[drive].type->precomp2)\n\t\tadk |= ADK_PRECOMP1;\n\telse if ((ulong)unit[drive].track >= unit[drive].type->precomp1)\n\t\tadk |= ADK_PRECOMP0;\n\tcustom.adkcon = adk;\n\n\tcustom.dsklen = DSKLEN_WRITE;\n\tcustom.dskptr = (u_char *)ZTWO_PADDR((u_char *)raw_buf);\n\tcustom.dsklen = unit[drive].type->write_size/sizeof(short) | DSKLEN_DMAEN|DSKLEN_WRITE;\n\tcustom.dsklen = unit[drive].type->write_size/sizeof(short) | DSKLEN_DMAEN|DSKLEN_WRITE;\n\n\tblock_flag = 2;\n\treturn 1;\n}\n\n \nstatic void post_write (unsigned long drive)\n{\n#ifdef DEBUG\n\tprintk(\"post_write for drive %ld\\n\",drive);\n#endif\n\tdrive &= 3;\n\tcustom.dsklen = 0;\n\tblock_flag = 0;\n\twritepending = 0;\n\twritefromint = 0;\n\tunit[drive].dirty = 0;\n\twake_up(&wait_fd_block);\n\tfd_deselect(drive);\n\trel_fdc();  \n}\n\nstatic void post_write_callback(struct timer_list *timer)\n{\n\tpost_write(post_write_timer_drive);\n}\n\n \n\nstatic unsigned long scan_sync(unsigned long raw, unsigned long end)\n{\n\tushort *ptr = (ushort *)raw, *endp = (ushort *)end;\n\n\twhile (ptr < endp && *ptr++ != 0x4489)\n\t\t;\n\tif (ptr < endp) {\n\t\twhile (*ptr == 0x4489 && ptr < endp)\n\t\t\tptr++;\n\t\treturn (ulong)ptr;\n\t}\n\treturn 0;\n}\n\nstatic inline unsigned long checksum(unsigned long *addr, int len)\n{\n\tunsigned long csum = 0;\n\n\tlen /= sizeof(*addr);\n\twhile (len-- > 0)\n\t\tcsum ^= *addr++;\n\tcsum = ((csum>>1) & 0x55555555)  ^  (csum & 0x55555555);\n\n\treturn csum;\n}\n\nstatic unsigned long decode (unsigned long *data, unsigned long *raw,\n\t\t\t     int len)\n{\n\tulong *odd, *even;\n\n\t \n\tlen >>= 2;\n\todd = raw;\n\teven = odd + len;\n\n\t \n\traw += len * 2;\n\n\tdo {\n\t\t*data++ = ((*odd++ & 0x55555555) << 1) | (*even++ & 0x55555555);\n\t} while (--len != 0);\n\n\treturn (ulong)raw;\n}\n\nstruct header {\n\tunsigned char magic;\n\tunsigned char track;\n\tunsigned char sect;\n\tunsigned char ord;\n\tunsigned char labels[16];\n\tunsigned long hdrchk;\n\tunsigned long datachk;\n};\n\nstatic int amiga_read(int drive)\n{\n\tunsigned long raw;\n\tunsigned long end;\n\tint scnt;\n\tunsigned long csum;\n\tstruct header hdr;\n\n\tdrive&=3;\n\traw = (long) raw_buf;\n\tend = raw + unit[drive].type->read_size;\n\n\tfor (scnt = 0;scnt < unit[drive].dtype->sects * unit[drive].type->sect_mult; scnt++) {\n\t\tif (!(raw = scan_sync(raw, end))) {\n\t\t\tprintk (KERN_INFO \"can't find sync for sector %d\\n\", scnt);\n\t\t\treturn MFM_NOSYNC;\n\t\t}\n\n\t\traw = decode ((ulong *)&hdr.magic, (ulong *)raw, 4);\n\t\traw = decode ((ulong *)&hdr.labels, (ulong *)raw, 16);\n\t\traw = decode ((ulong *)&hdr.hdrchk, (ulong *)raw, 4);\n\t\traw = decode ((ulong *)&hdr.datachk, (ulong *)raw, 4);\n\t\tcsum = checksum((ulong *)&hdr,\n\t\t\t\t(char *)&hdr.hdrchk-(char *)&hdr);\n\n#ifdef DEBUG\n\t\tprintk (\"(%x,%d,%d,%d) (%lx,%lx,%lx,%lx) %lx %lx\\n\",\n\t\t\thdr.magic, hdr.track, hdr.sect, hdr.ord,\n\t\t\t*(ulong *)&hdr.labels[0], *(ulong *)&hdr.labels[4],\n\t\t\t*(ulong *)&hdr.labels[8], *(ulong *)&hdr.labels[12],\n\t\t\thdr.hdrchk, hdr.datachk);\n#endif\n\n\t\tif (hdr.hdrchk != csum) {\n\t\t\tprintk(KERN_INFO \"MFM_HEADER: %08lx,%08lx\\n\", hdr.hdrchk, csum);\n\t\t\treturn MFM_HEADER;\n\t\t}\n\n\t\t \n\t\tif (hdr.track != unit[drive].track) {\n\t\t\tprintk(KERN_INFO \"MFM_TRACK: %d, %d\\n\", hdr.track, unit[drive].track);\n\t\t\treturn MFM_TRACK;\n\t\t}\n\n\t\traw = decode ((ulong *)(unit[drive].trackbuf + hdr.sect*512),\n\t\t\t      (ulong *)raw, 512);\n\t\tcsum = checksum((ulong *)(unit[drive].trackbuf + hdr.sect*512), 512);\n\n\t\tif (hdr.datachk != csum) {\n\t\t\tprintk(KERN_INFO \"MFM_DATA: (%x:%d:%d:%d) sc=%d %lx, %lx\\n\",\n\t\t\t       hdr.magic, hdr.track, hdr.sect, hdr.ord, scnt,\n\t\t\t       hdr.datachk, csum);\n\t\t\tprintk (KERN_INFO \"data=(%lx,%lx,%lx,%lx)\\n\",\n\t\t\t\t((ulong *)(unit[drive].trackbuf+hdr.sect*512))[0],\n\t\t\t\t((ulong *)(unit[drive].trackbuf+hdr.sect*512))[1],\n\t\t\t\t((ulong *)(unit[drive].trackbuf+hdr.sect*512))[2],\n\t\t\t\t((ulong *)(unit[drive].trackbuf+hdr.sect*512))[3]);\n\t\t\treturn MFM_DATA;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void encode(unsigned long data, unsigned long *dest)\n{\n\tunsigned long data2;\n\n\tdata &= 0x55555555;\n\tdata2 = data ^ 0x55555555;\n\tdata |= ((data2 >> 1) | 0x80000000) & (data2 << 1);\n\n\tif (*(dest - 1) & 0x00000001)\n\t\tdata &= 0x7FFFFFFF;\n\n\t*dest = data;\n}\n\nstatic void encode_block(unsigned long *dest, unsigned long *src, int len)\n{\n\tint cnt, to_cnt = 0;\n\tunsigned long data;\n\n\t \n\tfor (cnt = 0; cnt < len / 4; cnt++) {\n\t\tdata = src[cnt] >> 1;\n\t\tencode(data, dest + to_cnt++);\n\t}\n\n\t \n\tfor (cnt = 0; cnt < len / 4; cnt++) {\n\t\tdata = src[cnt];\n\t\tencode(data, dest + to_cnt++);\n\t}\n}\n\nstatic unsigned long *putsec(int disk, unsigned long *raw, int cnt)\n{\n\tstruct header hdr;\n\tint i;\n\n\tdisk&=3;\n\t*raw = (raw[-1]&1) ? 0x2AAAAAAA : 0xAAAAAAAA;\n\traw++;\n\t*raw++ = 0x44894489;\n\n\thdr.magic = 0xFF;\n\thdr.track = unit[disk].track;\n\thdr.sect = cnt;\n\thdr.ord = unit[disk].dtype->sects * unit[disk].type->sect_mult - cnt;\n\tfor (i = 0; i < 16; i++)\n\t\thdr.labels[i] = 0;\n\thdr.hdrchk = checksum((ulong *)&hdr,\n\t\t\t      (char *)&hdr.hdrchk-(char *)&hdr);\n\thdr.datachk = checksum((ulong *)(unit[disk].trackbuf+cnt*512), 512);\n\n\tencode_block(raw, (ulong *)&hdr.magic, 4);\n\traw += 2;\n\tencode_block(raw, (ulong *)&hdr.labels, 16);\n\traw += 8;\n\tencode_block(raw, (ulong *)&hdr.hdrchk, 4);\n\traw += 2;\n\tencode_block(raw, (ulong *)&hdr.datachk, 4);\n\traw += 2;\n\tencode_block(raw, (ulong *)(unit[disk].trackbuf+cnt*512), 512);\n\traw += 256;\n\n\treturn raw;\n}\n\nstatic void amiga_write(int disk)\n{\n\tunsigned int cnt;\n\tunsigned long *ptr = (unsigned long *)raw_buf;\n\n\tdisk&=3;\n\t \n\tfor (cnt = 0; cnt < 415 * unit[disk].type->sect_mult; cnt++)\n\t\t*ptr++ = 0xaaaaaaaa;\n\n\t \n\tfor (cnt = 0; cnt < unit[disk].dtype->sects * unit[disk].type->sect_mult; cnt++)\n\t\tptr = putsec (disk, ptr, cnt);\n\t*(ushort *)ptr = (ptr[-1]&1) ? 0x2AA8 : 0xAAA8;\n}\n\n\nstruct dos_header {\n\tunsigned char track,    \n\t\tside,     \n\t\tsec,      \n\t\tlen_desc; \n\tunsigned short crc;      \n\tunsigned char gap1[22];      \n};\n\n \n\n \n\nstatic ushort dos_crc(void * data_a3, int data_d0, int data_d1, int data_d3)\n{\n\tstatic unsigned char CRCTable1[] = {\n\t\t0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x81,0x91,0xa1,0xb1,0xc1,0xd1,0xe1,0xf1,\n\t\t0x12,0x02,0x32,0x22,0x52,0x42,0x72,0x62,0x93,0x83,0xb3,0xa3,0xd3,0xc3,0xf3,0xe3,\n\t\t0x24,0x34,0x04,0x14,0x64,0x74,0x44,0x54,0xa5,0xb5,0x85,0x95,0xe5,0xf5,0xc5,0xd5,\n\t\t0x36,0x26,0x16,0x06,0x76,0x66,0x56,0x46,0xb7,0xa7,0x97,0x87,0xf7,0xe7,0xd7,0xc7,\n\t\t0x48,0x58,0x68,0x78,0x08,0x18,0x28,0x38,0xc9,0xd9,0xe9,0xf9,0x89,0x99,0xa9,0xb9,\n\t\t0x5a,0x4a,0x7a,0x6a,0x1a,0x0a,0x3a,0x2a,0xdb,0xcb,0xfb,0xeb,0x9b,0x8b,0xbb,0xab,\n\t\t0x6c,0x7c,0x4c,0x5c,0x2c,0x3c,0x0c,0x1c,0xed,0xfd,0xcd,0xdd,0xad,0xbd,0x8d,0x9d,\n\t\t0x7e,0x6e,0x5e,0x4e,0x3e,0x2e,0x1e,0x0e,0xff,0xef,0xdf,0xcf,0xbf,0xaf,0x9f,0x8f,\n\t\t0x91,0x81,0xb1,0xa1,0xd1,0xc1,0xf1,0xe1,0x10,0x00,0x30,0x20,0x50,0x40,0x70,0x60,\n\t\t0x83,0x93,0xa3,0xb3,0xc3,0xd3,0xe3,0xf3,0x02,0x12,0x22,0x32,0x42,0x52,0x62,0x72,\n\t\t0xb5,0xa5,0x95,0x85,0xf5,0xe5,0xd5,0xc5,0x34,0x24,0x14,0x04,0x74,0x64,0x54,0x44,\n\t\t0xa7,0xb7,0x87,0x97,0xe7,0xf7,0xc7,0xd7,0x26,0x36,0x06,0x16,0x66,0x76,0x46,0x56,\n\t\t0xd9,0xc9,0xf9,0xe9,0x99,0x89,0xb9,0xa9,0x58,0x48,0x78,0x68,0x18,0x08,0x38,0x28,\n\t\t0xcb,0xdb,0xeb,0xfb,0x8b,0x9b,0xab,0xbb,0x4a,0x5a,0x6a,0x7a,0x0a,0x1a,0x2a,0x3a,\n\t\t0xfd,0xed,0xdd,0xcd,0xbd,0xad,0x9d,0x8d,0x7c,0x6c,0x5c,0x4c,0x3c,0x2c,0x1c,0x0c,\n\t\t0xef,0xff,0xcf,0xdf,0xaf,0xbf,0x8f,0x9f,0x6e,0x7e,0x4e,0x5e,0x2e,0x3e,0x0e,0x1e\n\t};\n\n\tstatic unsigned char CRCTable2[] = {\n\t\t0x00,0x21,0x42,0x63,0x84,0xa5,0xc6,0xe7,0x08,0x29,0x4a,0x6b,0x8c,0xad,0xce,0xef,\n\t\t0x31,0x10,0x73,0x52,0xb5,0x94,0xf7,0xd6,0x39,0x18,0x7b,0x5a,0xbd,0x9c,0xff,0xde,\n\t\t0x62,0x43,0x20,0x01,0xe6,0xc7,0xa4,0x85,0x6a,0x4b,0x28,0x09,0xee,0xcf,0xac,0x8d,\n\t\t0x53,0x72,0x11,0x30,0xd7,0xf6,0x95,0xb4,0x5b,0x7a,0x19,0x38,0xdf,0xfe,0x9d,0xbc,\n\t\t0xc4,0xe5,0x86,0xa7,0x40,0x61,0x02,0x23,0xcc,0xed,0x8e,0xaf,0x48,0x69,0x0a,0x2b,\n\t\t0xf5,0xd4,0xb7,0x96,0x71,0x50,0x33,0x12,0xfd,0xdc,0xbf,0x9e,0x79,0x58,0x3b,0x1a,\n\t\t0xa6,0x87,0xe4,0xc5,0x22,0x03,0x60,0x41,0xae,0x8f,0xec,0xcd,0x2a,0x0b,0x68,0x49,\n\t\t0x97,0xb6,0xd5,0xf4,0x13,0x32,0x51,0x70,0x9f,0xbe,0xdd,0xfc,0x1b,0x3a,0x59,0x78,\n\t\t0x88,0xa9,0xca,0xeb,0x0c,0x2d,0x4e,0x6f,0x80,0xa1,0xc2,0xe3,0x04,0x25,0x46,0x67,\n\t\t0xb9,0x98,0xfb,0xda,0x3d,0x1c,0x7f,0x5e,0xb1,0x90,0xf3,0xd2,0x35,0x14,0x77,0x56,\n\t\t0xea,0xcb,0xa8,0x89,0x6e,0x4f,0x2c,0x0d,0xe2,0xc3,0xa0,0x81,0x66,0x47,0x24,0x05,\n\t\t0xdb,0xfa,0x99,0xb8,0x5f,0x7e,0x1d,0x3c,0xd3,0xf2,0x91,0xb0,0x57,0x76,0x15,0x34,\n\t\t0x4c,0x6d,0x0e,0x2f,0xc8,0xe9,0x8a,0xab,0x44,0x65,0x06,0x27,0xc0,0xe1,0x82,0xa3,\n\t\t0x7d,0x5c,0x3f,0x1e,0xf9,0xd8,0xbb,0x9a,0x75,0x54,0x37,0x16,0xf1,0xd0,0xb3,0x92,\n\t\t0x2e,0x0f,0x6c,0x4d,0xaa,0x8b,0xe8,0xc9,0x26,0x07,0x64,0x45,0xa2,0x83,0xe0,0xc1,\n\t\t0x1f,0x3e,0x5d,0x7c,0x9b,0xba,0xd9,0xf8,0x17,0x36,0x55,0x74,0x93,0xb2,0xd1,0xf0\n\t};\n\n \n\tregister int i;\n\tregister unsigned char *CRCT1, *CRCT2, *data, c, crch, crcl;\n\n\tCRCT1=CRCTable1;\n\tCRCT2=CRCTable2;\n\tdata=data_a3;\n\tcrcl=data_d1;\n\tcrch=data_d0;\n\tfor (i=data_d3; i>=0; i--) {\n\t\tc = (*data++) ^ crch;\n\t\tcrch = CRCT1[c] ^ crcl;\n\t\tcrcl = CRCT2[c];\n\t}\n\treturn (crch<<8)|crcl;\n}\n\nstatic inline ushort dos_hdr_crc (struct dos_header *hdr)\n{\n\treturn dos_crc(&(hdr->track), 0xb2, 0x30, 3);  \n}\n\nstatic inline ushort dos_data_crc(unsigned char *data)\n{\n\treturn dos_crc(data, 0xe2, 0x95 ,511);  \n}\n\nstatic inline unsigned char dos_decode_byte(ushort word)\n{\n\tregister ushort w2;\n\tregister unsigned char byte;\n\tregister unsigned char *dec = mfmdecode;\n\n\tw2=word;\n\tw2>>=8;\n\tw2&=127;\n\tbyte = dec[w2];\n\tbyte <<= 4;\n\tw2 = word & 127;\n\tbyte |= dec[w2];\n\treturn byte;\n}\n\nstatic unsigned long dos_decode(unsigned char *data, unsigned short *raw, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\t*data++=dos_decode_byte(*raw++);\n\treturn ((ulong)raw);\n}\n\n#ifdef DEBUG\nstatic void dbg(unsigned long ptr)\n{\n\tprintk(\"raw data @%08lx: %08lx, %08lx ,%08lx, %08lx\\n\", ptr,\n\t       ((ulong *)ptr)[0], ((ulong *)ptr)[1],\n\t       ((ulong *)ptr)[2], ((ulong *)ptr)[3]);\n}\n#endif\n\nstatic int dos_read(int drive)\n{\n\tunsigned long end;\n\tunsigned long raw;\n\tint scnt;\n\tunsigned short crc,data_crc[2];\n\tstruct dos_header hdr;\n\n\tdrive&=3;\n\traw = (long) raw_buf;\n\tend = raw + unit[drive].type->read_size;\n\n\tfor (scnt=0; scnt < unit[drive].dtype->sects * unit[drive].type->sect_mult; scnt++) {\n\t\tdo {  \n\t\t\tif (!(raw = scan_sync (raw, end))) {\n\t\t\t\tprintk(KERN_INFO \"dos_read: no hdr sync on \"\n\t\t\t\t       \"track %d, unit %d for sector %d\\n\",\n\t\t\t\t       unit[drive].track,drive,scnt);\n\t\t\t\treturn MFM_NOSYNC;\n\t\t\t}\n#ifdef DEBUG\n\t\t\tdbg(raw);\n#endif\n\t\t} while (*((ushort *)raw)!=0x5554);  \n\t\traw+=2;  \n\t\traw = dos_decode((unsigned char *)&hdr,(ushort *) raw,8);\n\t\tcrc = dos_hdr_crc(&hdr);\n\n#ifdef DEBUG\n\t\tprintk(\"(%3d,%d,%2d,%d) %x\\n\", hdr.track, hdr.side,\n\t\t       hdr.sec, hdr.len_desc, hdr.crc);\n#endif\n\n\t\tif (crc != hdr.crc) {\n\t\t\tprintk(KERN_INFO \"dos_read: MFM_HEADER %04x,%04x\\n\",\n\t\t\t       hdr.crc, crc);\n\t\t\treturn MFM_HEADER;\n\t\t}\n\t\tif (hdr.track != unit[drive].track/unit[drive].type->heads) {\n\t\t\tprintk(KERN_INFO \"dos_read: MFM_TRACK %d, %d\\n\",\n\t\t\t       hdr.track,\n\t\t\t       unit[drive].track/unit[drive].type->heads);\n\t\t\treturn MFM_TRACK;\n\t\t}\n\n\t\tif (hdr.side != unit[drive].track%unit[drive].type->heads) {\n\t\t\tprintk(KERN_INFO \"dos_read: MFM_SIDE %d, %d\\n\",\n\t\t\t       hdr.side,\n\t\t\t       unit[drive].track%unit[drive].type->heads);\n\t\t\treturn MFM_TRACK;\n\t\t}\n\n\t\tif (hdr.len_desc != 2) {\n\t\t\tprintk(KERN_INFO \"dos_read: unknown sector len \"\n\t\t\t       \"descriptor %d\\n\", hdr.len_desc);\n\t\t\treturn MFM_DATA;\n\t\t}\n#ifdef DEBUG\n\t\tprintk(\"hdr accepted\\n\");\n#endif\n\t\tif (!(raw = scan_sync (raw, end))) {\n\t\t\tprintk(KERN_INFO \"dos_read: no data sync on track \"\n\t\t\t       \"%d, unit %d for sector%d, disk sector %d\\n\",\n\t\t\t       unit[drive].track, drive, scnt, hdr.sec);\n\t\t\treturn MFM_NOSYNC;\n\t\t}\n#ifdef DEBUG\n\t\tdbg(raw);\n#endif\n\n\t\tif (*((ushort *)raw)!=0x5545) {\n\t\t\tprintk(KERN_INFO \"dos_read: no data mark after \"\n\t\t\t       \"sync (%d,%d,%d,%d) sc=%d\\n\",\n\t\t\t       hdr.track,hdr.side,hdr.sec,hdr.len_desc,scnt);\n\t\t\treturn MFM_NOSYNC;\n\t\t}\n\n\t\traw+=2;   \n\t\traw = dos_decode((unsigned char *)(unit[drive].trackbuf + (hdr.sec - 1) * 512), (ushort *) raw, 512);\n\t\traw = dos_decode((unsigned char  *)data_crc,(ushort *) raw,4);\n\t\tcrc = dos_data_crc(unit[drive].trackbuf + (hdr.sec - 1) * 512);\n\n\t\tif (crc != data_crc[0]) {\n\t\t\tprintk(KERN_INFO \"dos_read: MFM_DATA (%d,%d,%d,%d) \"\n\t\t\t       \"sc=%d, %x %x\\n\", hdr.track, hdr.side,\n\t\t\t       hdr.sec, hdr.len_desc, scnt,data_crc[0], crc);\n\t\t\tprintk(KERN_INFO \"data=(%lx,%lx,%lx,%lx,...)\\n\",\n\t\t\t       ((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[0],\n\t\t\t       ((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[1],\n\t\t\t       ((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[2],\n\t\t\t       ((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[3]);\n\t\t\treturn MFM_DATA;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline ushort dos_encode_byte(unsigned char byte)\n{\n\tregister unsigned char *enc, b2, b1;\n\tregister ushort word;\n\n\tenc=mfmencode;\n\tb1=byte;\n\tb2=b1>>4;\n\tb1&=15;\n\tword=enc[b2] <<8 | enc [b1];\n\treturn (word|((word&(256|64)) ? 0: 128));\n}\n\nstatic void dos_encode_block(ushort *dest, unsigned char *src, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\t*dest=dos_encode_byte(*src++);\n\t\t*dest|=((dest[-1]&1)||(*dest&0x4000))? 0: 0x8000;\n\t\tdest++;\n\t}\n}\n\nstatic unsigned long *ms_putsec(int drive, unsigned long *raw, int cnt)\n{\n\tstatic struct dos_header hdr={0,0,0,2,0,\n\t  {78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78}};\n\tint i;\n\tstatic ushort crc[2]={0,0x4e4e};\n\n\tdrive&=3;\n \n \n\tfor(i=0;i<6;i++)\n\t\t*raw++=0xaaaaaaaa;\n \n\t*raw++=0x44894489;\n\t*raw++=0x44895554;\n\n \n\thdr.track=unit[drive].track/unit[drive].type->heads;\n\thdr.side=unit[drive].track%unit[drive].type->heads;\n\thdr.sec=cnt+1;\n\thdr.crc=dos_hdr_crc(&hdr);\n\n \n\tdos_encode_block((ushort *)raw,(unsigned char *) &hdr.track,28);\n\traw+=14;\n\n \n\tfor(i=0;i<6;i++)\n\t\t*raw++=0xaaaaaaaa;\n\n \n\t*raw++=0x44894489;\n\t*raw++=0x44895545;\n\n \n\tdos_encode_block((ushort *)raw,\n\t\t\t (unsigned char *)unit[drive].trackbuf+cnt*512,512);\n\traw+=256;\n\n \n\tcrc[0]=dos_data_crc(unit[drive].trackbuf+cnt*512);\n\tdos_encode_block((ushort *) raw,(unsigned char *)crc,4);\n\traw+=2;\n\n \n\tfor(i=0;i<38;i++)\n\t\t*raw++=0x92549254;\n\n\treturn raw;  \n}\n\nstatic void dos_write(int disk)\n{\n\tint cnt;\n\tunsigned long raw = (unsigned long) raw_buf;\n\tunsigned long *ptr=(unsigned long *)raw;\n\n\tdisk&=3;\n \n\tfor (cnt=0;cnt<425;cnt++)\n\t\t*ptr++=0x92549254;\n\n \n\tif (unit[disk].type->sect_mult==2)   \n\t\tfor(cnt=0;cnt<473;cnt++)\n\t\t\t*ptr++=0x92549254;\n\n \n\tfor (cnt=0;cnt<20;cnt++)\n\t\t*ptr++=0x92549254;\n\tfor (cnt=0;cnt<6;cnt++)\n\t\t*ptr++=0xaaaaaaaa;\n\t*ptr++=0x52245224;\n\t*ptr++=0x52245552;\n\tfor (cnt=0;cnt<20;cnt++)\n\t\t*ptr++=0x92549254;\n\n \n\tfor(cnt = 0; cnt < unit[disk].dtype->sects * unit[disk].type->sect_mult; cnt++)\n\t\tptr=ms_putsec(disk,ptr,cnt);\n\n\t*(ushort *)ptr = 0xaaa8;  \n}\n\n \n\n \nstatic void flush_track_callback(struct timer_list *timer)\n{\n\tunsigned long nr = ((unsigned long)timer -\n\t\t\t       (unsigned long)&flush_track_timer[0]) /\n\t\t\t\t\tsizeof(flush_track_timer[0]);\n\n\tnr&=3;\n\twritefromint = 1;\n\tif (!try_fdc(nr)) {\n\t\t \n\t\tflush_track_timer[nr].expires = jiffies + 1;\n\t\tadd_timer(flush_track_timer + nr);\n\t\treturn;\n\t}\n\tget_fdc(nr);\n\t(*unit[nr].dtype->write_fkt)(nr);\n\tif (!raw_write(nr)) {\n\t\tprintk (KERN_NOTICE \"floppy disk write protected\\n\");\n\t\twritefromint = 0;\n\t\twritepending = 0;\n\t}\n\trel_fdc();\n}\n\nstatic int non_int_flush_track (unsigned long nr)\n{\n\tunsigned long flags;\n\n\tnr&=3;\n\twritefromint = 0;\n\tdel_timer(&post_write_timer);\n\tget_fdc(nr);\n\tif (!fd_motor_on(nr)) {\n\t\twritepending = 0;\n\t\trel_fdc();\n\t\treturn 0;\n\t}\n\tlocal_irq_save(flags);\n\tif (writepending != 2) {\n\t\tlocal_irq_restore(flags);\n\t\t(*unit[nr].dtype->write_fkt)(nr);\n\t\tif (!raw_write(nr)) {\n\t\t\tprintk (KERN_NOTICE \"floppy disk write protected \"\n\t\t\t\t\"in write!\\n\");\n\t\t\twritepending = 0;\n\t\t\treturn 0;\n\t\t}\n\t\twait_event(wait_fd_block, block_flag != 2);\n\t}\n\telse {\n\t\tlocal_irq_restore(flags);\n\t\tms_delay(2);  \n\t\tpost_write(nr);\n\t}\n\trel_fdc();\n\treturn 1;\n}\n\nstatic int get_track(int drive, int track)\n{\n\tint error, errcnt;\n\n\tdrive&=3;\n\tif (unit[drive].track == track)\n\t\treturn 0;\n\tget_fdc(drive);\n\tif (!fd_motor_on(drive)) {\n\t\trel_fdc();\n\t\treturn -1;\n\t}\n\n\tif (unit[drive].dirty == 1) {\n\t\tdel_timer (flush_track_timer + drive);\n\t\tnon_int_flush_track (drive);\n\t}\n\terrcnt = 0;\n\twhile (errcnt < MAX_ERRORS) {\n\t\tif (!fd_seek(drive, track))\n\t\t\treturn -1;\n\t\traw_read(drive);\n\t\terror = (*unit[drive].dtype->read_fkt)(drive);\n\t\tif (error == 0) {\n\t\t\trel_fdc();\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tunit[drive].track = -1;\n\t\terrcnt++;\n\t}\n\trel_fdc();\n\treturn -1;\n}\n\nstatic blk_status_t amiflop_rw_cur_segment(struct amiga_floppy_struct *floppy,\n\t\t\t\t\t   struct request *rq)\n{\n\tint drive = floppy - unit;\n\tunsigned int cnt, block, track, sector;\n\tchar *data;\n\n\tfor (cnt = 0; cnt < blk_rq_cur_sectors(rq); cnt++) {\n#ifdef DEBUG\n\t\tprintk(\"fd: sector %ld + %d requested for %s\\n\",\n\t\t       blk_rq_pos(rq), cnt,\n\t\t       (rq_data_dir(rq) == READ) ? \"read\" : \"write\");\n#endif\n\t\tblock = blk_rq_pos(rq) + cnt;\n\t\ttrack = block / (floppy->dtype->sects * floppy->type->sect_mult);\n\t\tsector = block % (floppy->dtype->sects * floppy->type->sect_mult);\n\t\tdata = bio_data(rq->bio) + 512 * cnt;\n#ifdef DEBUG\n\t\tprintk(\"access to track %d, sector %d, with buffer at \"\n\t\t       \"0x%08lx\\n\", track, sector, data);\n#endif\n\n\t\tif (get_track(drive, track) == -1)\n\t\t\treturn BLK_STS_IOERR;\n\n\t\tif (rq_data_dir(rq) == READ) {\n\t\t\tmemcpy(data, floppy->trackbuf + sector * 512, 512);\n\t\t} else {\n\t\t\tmemcpy(floppy->trackbuf + sector * 512, data, 512);\n\n\t\t\t \n\t\t\tif (!fd_motor_on(drive))\n\t\t\t\treturn BLK_STS_IOERR;\n\t\t\t \n\t\t\tfloppy->dirty = 1;\n\t\t         \n\t\t\tmod_timer (flush_track_timer + drive, jiffies + 1);\n\t\t}\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t amiflop_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t     const struct blk_mq_queue_data *bd)\n{\n\tstruct request *rq = bd->rq;\n\tstruct amiga_floppy_struct *floppy = rq->q->disk->private_data;\n\tblk_status_t err;\n\n\tif (!spin_trylock_irq(&amiflop_lock))\n\t\treturn BLK_STS_DEV_RESOURCE;\n\n\tblk_mq_start_request(rq);\n\n\tdo {\n\t\terr = amiflop_rw_cur_segment(floppy, rq);\n\t} while (blk_update_request(rq, err, blk_rq_cur_bytes(rq)));\n\tblk_mq_end_request(rq, err);\n\n\tspin_unlock_irq(&amiflop_lock);\n\treturn BLK_STS_OK;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = MINOR(bdev->bd_dev) & 3;\n\n\tgeo->heads = unit[drive].type->heads;\n\tgeo->sectors = unit[drive].dtype->sects * unit[drive].type->sect_mult;\n\tgeo->cylinders = unit[drive].type->tracks;\n\treturn 0;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t    unsigned int cmd, unsigned long param)\n{\n\tstruct amiga_floppy_struct *p = bdev->bd_disk->private_data;\n\tint drive = p - unit;\n\tstatic struct floppy_struct getprm;\n\tvoid __user *argp = (void __user *)param;\n\n\tswitch(cmd){\n\tcase FDFMTBEG:\n\t\tget_fdc(drive);\n\t\tif (fd_ref[drive] > 1) {\n\t\t\trel_fdc();\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (fd_motor_on(drive) == 0) {\n\t\t\trel_fdc();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (fd_calibrate(drive) == 0) {\n\t\t\trel_fdc();\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tfloppy_off(drive);\n\t\trel_fdc();\n\t\tbreak;\n\tcase FDFMTTRK:\n\t\tif (param < p->type->tracks * p->type->heads)\n\t\t{\n\t\t\tget_fdc(drive);\n\t\t\tif (fd_seek(drive,param) != 0){\n\t\t\t\tmemset(p->trackbuf, FD_FILL_BYTE,\n\t\t\t\t       p->dtype->sects * p->type->sect_mult * 512);\n\t\t\t\tnon_int_flush_track(drive);\n\t\t\t}\n\t\t\tfloppy_off(drive);\n\t\t\trel_fdc();\n\t\t}\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FDFMTEND:\n\t\tfloppy_off(drive);\n\t\tinvalidate_bdev(bdev);\n\t\tbreak;\n\tcase FDGETPRM:\n\t\tmemset((void *)&getprm, 0, sizeof (getprm));\n\t\tgetprm.track=p->type->tracks;\n\t\tgetprm.head=p->type->heads;\n\t\tgetprm.sect=p->dtype->sects * p->type->sect_mult;\n\t\tgetprm.size=p->blocks;\n\t\tif (copy_to_user(argp, &getprm, sizeof(struct floppy_struct)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn -EINVAL;\n\tcase FDFLUSH:  \n\t\tdel_timer (flush_track_timer + drive);\n\t\tnon_int_flush_track(drive);\n\t\tbreak;\n#ifdef RAW_IOCTL\n\tcase IOCTL_RAW_TRACK:\n\t\tif (copy_to_user(argp, raw_buf, p->type->read_size))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn p->type->read_size;\n#endif\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&amiflop_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&amiflop_mutex);\n\n\treturn ret;\n}\n\nstatic void fd_probe(int dev)\n{\n\tunsigned long code;\n\tint type;\n\tint drive;\n\n\tdrive = dev & 3;\n\tcode = fd_get_drive_id(drive);\n\n\t \n\tfor (type = 0; type < num_dr_types; type++)\n\t\tif (drive_types[type].code == code)\n\t\t\tbreak;\n\n\tif (type >= num_dr_types) {\n\t\tprintk(KERN_WARNING \"fd_probe: unsupported drive type \"\n\t\t       \"%08lx found\\n\", code);\n\t\tunit[drive].type = &drive_types[num_dr_types-1];  \n\t\treturn;\n\t}\n\n\tunit[drive].type = drive_types + type;\n\tunit[drive].track = -1;\n\n\tunit[drive].disk = -1;\n\tunit[drive].motor = 0;\n\tunit[drive].busy = 0;\n\tunit[drive].status = -1;\n}\n\n \nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint drive = disk->first_minor & 3;\n\tint system = (disk->first_minor & 4) >> 2;\n\tint old_dev;\n\tunsigned long flags;\n\n\tmutex_lock(&amiflop_mutex);\n\told_dev = fd_device[drive];\n\n\tif (fd_ref[drive] && old_dev != system) {\n\t\tmutex_unlock(&amiflop_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tif (unit[drive].type->code == FD_NODRIVE) {\n\t\tmutex_unlock(&amiflop_mutex);\n\t\treturn -ENXIO;\n\t}\n\tif (mode & (BLK_OPEN_READ | BLK_OPEN_WRITE)) {\n\t\tdisk_check_media_change(disk);\n\t\tif (mode & BLK_OPEN_WRITE) {\n\t\t\tint wrprot;\n\n\t\t\tget_fdc(drive);\n\t\t\tfd_select (drive);\n\t\t\twrprot = !(ciaa.pra & DSKPROT);\n\t\t\tfd_deselect (drive);\n\t\t\trel_fdc();\n\n\t\t\tif (wrprot) {\n\t\t\t\tmutex_unlock(&amiflop_mutex);\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t}\n\t}\n\tlocal_irq_save(flags);\n\tfd_ref[drive]++;\n\tfd_device[drive] = system;\n\tlocal_irq_restore(flags);\n\n\tunit[drive].dtype=&data_types[system];\n\tunit[drive].blocks=unit[drive].type->heads*unit[drive].type->tracks*\n\t\tdata_types[system].sects*unit[drive].type->sect_mult;\n\tset_capacity(unit[drive].gendisk[system], unit[drive].blocks);\n\n\tprintk(KERN_INFO \"fd%d: accessing %s-disk with %s-layout\\n\",drive,\n\t       unit[drive].type->name, data_types[system].name);\n\n\tmutex_unlock(&amiflop_mutex);\n\treturn 0;\n}\n\nstatic void floppy_release(struct gendisk *disk)\n{\n\tstruct amiga_floppy_struct *p = disk->private_data;\n\tint drive = p - unit;\n\n\tmutex_lock(&amiflop_mutex);\n\tif (unit[drive].dirty == 1) {\n\t\tdel_timer (flush_track_timer + drive);\n\t\tnon_int_flush_track (drive);\n\t}\n  \n\tif (!fd_ref[drive]--) {\n\t\tprintk(KERN_CRIT \"floppy_release with fd_ref == 0\");\n\t\tfd_ref[drive] = 0;\n\t}\n#ifdef MODULE\n\tfloppy_off (drive);\n#endif\n\tmutex_unlock(&amiflop_mutex);\n}\n\n \nstatic unsigned amiga_check_events(struct gendisk *disk, unsigned int clearing)\n{\n\tstruct amiga_floppy_struct *p = disk->private_data;\n\tint drive = p - unit;\n\tint changed;\n\tstatic int first_time = 1;\n\n\tif (first_time)\n\t\tchanged = first_time--;\n\telse {\n\t\tget_fdc(drive);\n\t\tfd_select (drive);\n\t\tchanged = !(ciaa.pra & DSKCHANGE);\n\t\tfd_deselect (drive);\n\t\trel_fdc();\n\t}\n\n\tif (changed) {\n\t\tfd_probe(drive);\n\t\tp->track = -1;\n\t\tp->dirty = 0;\n\t\twritepending = 0;  \n\t\twritefromint = 0;\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t}\n\treturn 0;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= floppy_open,\n\t.release\t= floppy_release,\n\t.ioctl\t\t= fd_ioctl,\n\t.getgeo\t\t= fd_getgeo,\n\t.check_events\t= amiga_check_events,\n};\n\nstatic const struct blk_mq_ops amiflop_mq_ops = {\n\t.queue_rq = amiflop_queue_rq,\n};\n\nstatic int fd_alloc_disk(int drive, int system)\n{\n\tstruct gendisk *disk;\n\tint err;\n\n\tdisk = blk_mq_alloc_disk(&unit[drive].tag_set, NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = drive + system;\n\tdisk->minors = 1;\n\tdisk->fops = &floppy_fops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tif (system)\n\t\tsprintf(disk->disk_name, \"fd%d_msdos\", drive);\n\telse\n\t\tsprintf(disk->disk_name, \"fd%d\", drive);\n\tdisk->private_data = &unit[drive];\n\tset_capacity(disk, 880 * 2);\n\n\tunit[drive].gendisk[system] = disk;\n\terr = add_disk(disk);\n\tif (err)\n\t\tput_disk(disk);\n\treturn err;\n}\n\nstatic int fd_alloc_drive(int drive)\n{\n\tunit[drive].trackbuf = kmalloc(FLOPPY_MAX_SECTORS * 512, GFP_KERNEL);\n\tif (!unit[drive].trackbuf)\n\t\tgoto out;\n\n\tmemset(&unit[drive].tag_set, 0, sizeof(unit[drive].tag_set));\n\tunit[drive].tag_set.ops = &amiflop_mq_ops;\n\tunit[drive].tag_set.nr_hw_queues = 1;\n\tunit[drive].tag_set.nr_maps = 1;\n\tunit[drive].tag_set.queue_depth = 2;\n\tunit[drive].tag_set.numa_node = NUMA_NO_NODE;\n\tunit[drive].tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\tif (blk_mq_alloc_tag_set(&unit[drive].tag_set))\n\t\tgoto out_cleanup_trackbuf;\n\n\tpr_cont(\" fd%d\", drive);\n\n\tif (fd_alloc_disk(drive, 0) || fd_alloc_disk(drive, 1))\n\t\tgoto out_cleanup_tagset;\n\treturn 0;\n\nout_cleanup_tagset:\n\tblk_mq_free_tag_set(&unit[drive].tag_set);\nout_cleanup_trackbuf:\n\tkfree(unit[drive].trackbuf);\nout:\n\tunit[drive].type->code = FD_NODRIVE;\n\treturn -ENOMEM;\n}\n\nstatic int __init fd_probe_drives(void)\n{\n\tint drive,drives,nomem;\n\n\tpr_info(\"FD: probing units\\nfound\");\n\tdrives=0;\n\tnomem=0;\n\tfor(drive=0;drive<FD_MAX_UNITS;drive++) {\n\t\tfd_probe(drive);\n\t\tif (unit[drive].type->code == FD_NODRIVE)\n\t\t\tcontinue;\n\n\t\tif (fd_alloc_drive(drive) < 0) {\n\t\t\tpr_cont(\" no mem for fd%d\", drive);\n\t\t\tnomem = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tdrives++;\n\t}\n\tif ((drives > 0) || (nomem == 0)) {\n\t\tif (drives == 0)\n\t\t\tpr_cont(\" no drives\");\n\t\tpr_cont(\"\\n\");\n\t\treturn drives;\n\t}\n\tpr_cont(\"\\n\");\n\treturn -ENOMEM;\n}\n \nstatic int __init amiga_floppy_probe(struct platform_device *pdev)\n{\n\tint i, ret;\n\n\tif (register_blkdev(FLOPPY_MAJOR,\"fd\"))\n\t\treturn -EBUSY;\n\n\tret = -ENOMEM;\n\traw_buf = amiga_chip_alloc(RAW_BUF_SIZE, \"Floppy\");\n\tif (!raw_buf) {\n\t\tprintk(\"fd: cannot get chip mem buffer\\n\");\n\t\tgoto out_blkdev;\n\t}\n\n\tret = -EBUSY;\n\tif (request_irq(IRQ_AMIGA_DSKBLK, fd_block_done, 0, \"floppy_dma\", NULL)) {\n\t\tprintk(\"fd: cannot get irq for dma\\n\");\n\t\tgoto out_irq;\n\t}\n\n\tif (request_irq(IRQ_AMIGA_CIAA_TB, ms_isr, 0, \"floppy_timer\", NULL)) {\n\t\tprintk(\"fd: cannot get irq for timer\\n\");\n\t\tgoto out_irq2;\n\t}\n\n\tret = -ENODEV;\n\tif (fd_probe_drives() < 1)  \n\t\tgoto out_probe;\n\n\t \n\ttimer_setup(&motor_on_timer, motor_on_callback, 0);\n\tmotor_on_timer.expires = 0;\n\tfor (i = 0; i < FD_MAX_UNITS; i++) {\n\t\ttimer_setup(&motor_off_timer[i], fd_motor_off, 0);\n\t\tmotor_off_timer[i].expires = 0;\n\t\ttimer_setup(&flush_track_timer[i], flush_track_callback, 0);\n\t\tflush_track_timer[i].expires = 0;\n\n\t\tunit[i].track = -1;\n\t}\n\n\ttimer_setup(&post_write_timer, post_write_callback, 0);\n\tpost_write_timer.expires = 0;\n  \n\tfor (i = 0; i < 128; i++)\n\t\tmfmdecode[i]=255;\n\tfor (i = 0; i < 16; i++)\n\t\tmfmdecode[mfmencode[i]]=i;\n\n\t \n\tcustom.dmacon = DMAF_SETCLR | DMAF_DISK;\n\n\t \n\tciaa.crb = 8;  \n\treturn 0;\n\nout_probe:\n\tfree_irq(IRQ_AMIGA_CIAA_TB, NULL);\nout_irq2:\n\tfree_irq(IRQ_AMIGA_DSKBLK, NULL);\nout_irq:\n\tamiga_chip_free(raw_buf);\nout_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR,\"fd\");\n\treturn ret;\n}\n\nstatic struct platform_driver amiga_floppy_driver = {\n\t.driver   = {\n\t\t.name\t= \"amiga-floppy\",\n\t},\n};\n\nstatic int __init amiga_floppy_init(void)\n{\n\treturn platform_driver_probe(&amiga_floppy_driver, amiga_floppy_probe);\n}\n\nmodule_init(amiga_floppy_init);\n\n#ifndef MODULE\nstatic int __init amiga_floppy_setup (char *str)\n{\n\tint n;\n\tif (!MACH_IS_AMIGA)\n\t\treturn 0;\n\tif (!get_option(&str, &n))\n\t\treturn 0;\n\tprintk (KERN_INFO \"amiflop: Setting default df0 to %x\\n\", n);\n\tfd_def_df0 = n;\n\treturn 1;\n}\n\n__setup(\"floppy=\", amiga_floppy_setup);\n#endif\n\nMODULE_ALIAS(\"platform:amiga-floppy\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}