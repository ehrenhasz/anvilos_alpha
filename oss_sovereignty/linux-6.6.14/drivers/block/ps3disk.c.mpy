{
  "module_name": "ps3disk.c",
  "hash_id": "7a585d5f235328db3a48b12ad270b9e7763ed3b814ab89c30204896be23de1cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/ps3disk.c",
  "human_readable_source": "\n \n\n#include <linux/ata.h>\n#include <linux/blk-mq.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <asm/lv1call.h>\n#include <asm/ps3stor.h>\n#include <asm/firmware.h>\n\n\n#define DEVICE_NAME\t\t\"ps3disk\"\n\n#define BOUNCE_SIZE\t\t(64*1024)\n\n#define PS3DISK_MAX_DISKS\t16\n#define PS3DISK_MINORS\t\t16\n\n\n#define PS3DISK_NAME\t\t\"ps3d%c\"\n\n\nstruct ps3disk_private {\n\tspinlock_t lock;\t\t \n\tstruct blk_mq_tag_set tag_set;\n\tstruct gendisk *gendisk;\n\tunsigned int blocking_factor;\n\tstruct request *req;\n\tu64 raw_capacity;\n\tunsigned char model[ATA_ID_PROD_LEN+1];\n};\n\n\n#define LV1_STORAGE_SEND_ATA_COMMAND\t(2)\n#define LV1_STORAGE_ATA_HDDOUT\t\t(0x23)\n\nstruct lv1_ata_cmnd_block {\n\tu16\tfeatures;\n\tu16\tsector_count;\n\tu16\tLBA_low;\n\tu16\tLBA_mid;\n\tu16\tLBA_high;\n\tu8\tdevice;\n\tu8\tcommand;\n\tu32\tis_ext;\n\tu32\tproto;\n\tu32\tin_out;\n\tu32\tsize;\n\tu64\tbuffer;\n\tu32\targlen;\n};\n\nenum lv1_ata_proto {\n\tNON_DATA_PROTO     = 0,\n\tPIO_DATA_IN_PROTO  = 1,\n\tPIO_DATA_OUT_PROTO = 2,\n\tDMA_PROTO = 3\n};\n\nenum lv1_ata_in_out {\n\tDIR_WRITE = 0,\t\t\t \n\tDIR_READ = 1\t\t\t \n};\n\nstatic int ps3disk_major;\n\n\nstatic const struct block_device_operations ps3disk_fops = {\n\t.owner\t\t= THIS_MODULE,\n};\n\n\nstatic void ps3disk_scatter_gather(struct ps3_storage_device *dev,\n\t\t\t\t   struct request *req, int gather)\n{\n\tunsigned int offset = 0;\n\tstruct req_iterator iter;\n\tstruct bio_vec bvec;\n\n\trq_for_each_segment(bvec, req, iter) {\n\t\tif (gather)\n\t\t\tmemcpy_from_bvec(dev->bounce_buf + offset, &bvec);\n\t\telse\n\t\t\tmemcpy_to_bvec(&bvec, dev->bounce_buf + offset);\n\t}\n}\n\nstatic blk_status_t ps3disk_submit_request_sg(struct ps3_storage_device *dev,\n\t\t\t\t\t      struct request *req)\n{\n\tstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tint write = rq_data_dir(req), res;\n\tconst char *op = write ? \"write\" : \"read\";\n\tu64 start_sector, sectors;\n\tunsigned int region_id = dev->regions[dev->region_idx].id;\n\n#ifdef DEBUG\n\tunsigned int n = 0;\n\tstruct bio_vec bv;\n\tstruct req_iterator iter;\n\n\trq_for_each_segment(bv, req, iter)\n\t\tn++;\n\tdev_dbg(&dev->sbd.core,\n\t\t\"%s:%u: %s req has %u bvecs for %u sectors\\n\",\n\t\t__func__, __LINE__, op, n, blk_rq_sectors(req));\n#endif\n\n\tstart_sector = blk_rq_pos(req) * priv->blocking_factor;\n\tsectors = blk_rq_sectors(req) * priv->blocking_factor;\n\tdev_dbg(&dev->sbd.core, \"%s:%u: %s %llu sectors starting at %llu\\n\",\n\t\t__func__, __LINE__, op, sectors, start_sector);\n\n\tif (write) {\n\t\tps3disk_scatter_gather(dev, req, 1);\n\n\t\tres = lv1_storage_write(dev->sbd.dev_id, region_id,\n\t\t\t\t\tstart_sector, sectors, 0,\n\t\t\t\t\tdev->bounce_lpar, &dev->tag);\n\t} else {\n\t\tres = lv1_storage_read(dev->sbd.dev_id, region_id,\n\t\t\t\t       start_sector, sectors, 0,\n\t\t\t\t       dev->bounce_lpar, &dev->tag);\n\t}\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: %s failed %d\\n\", __func__,\n\t\t\t__LINE__, op, res);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tpriv->req = req;\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t ps3disk_submit_flush_request(struct ps3_storage_device *dev,\n\t\t\t\t\t\t struct request *req)\n{\n\tstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tu64 res;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: flush request\\n\", __func__, __LINE__);\n\n\tres = lv1_storage_send_device_command(dev->sbd.dev_id,\n\t\t\t\t\t      LV1_STORAGE_ATA_HDDOUT, 0, 0, 0,\n\t\t\t\t\t      0, &dev->tag);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: sync cache failed 0x%llx\\n\",\n\t\t\t__func__, __LINE__, res);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tpriv->req = req;\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t ps3disk_do_request(struct ps3_storage_device *dev,\n\t\t\t\t       struct request *req)\n{\n\tdev_dbg(&dev->sbd.core, \"%s:%u\\n\", __func__, __LINE__);\n\n\tswitch (req_op(req)) {\n\tcase REQ_OP_FLUSH:\n\t\treturn ps3disk_submit_flush_request(dev, req);\n\tcase REQ_OP_READ:\n\tcase REQ_OP_WRITE:\n\t\treturn ps3disk_submit_request_sg(dev, req);\n\tdefault:\n\t\tblk_dump_rq_flags(req, DEVICE_NAME \" bad request\");\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\nstatic blk_status_t ps3disk_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t     const struct blk_mq_queue_data *bd)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct ps3_storage_device *dev = q->queuedata;\n\tstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tblk_status_t ret;\n\n\tblk_mq_start_request(bd->rq);\n\n\tspin_lock_irq(&priv->lock);\n\tret = ps3disk_do_request(dev, bd->rq);\n\tspin_unlock_irq(&priv->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t ps3disk_interrupt(int irq, void *data)\n{\n\tstruct ps3_storage_device *dev = data;\n\tstruct ps3disk_private *priv;\n\tstruct request *req;\n\tint res, read;\n\tblk_status_t error;\n\tu64 tag, status;\n\tconst char *op;\n\n\tres = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);\n\n\tif (tag != dev->tag)\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: tag mismatch, got %llx, expected %llx\\n\",\n\t\t\t__func__, __LINE__, tag, dev->tag);\n\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: res=%d status=0x%llx\\n\",\n\t\t\t__func__, __LINE__, res, status);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tpriv = ps3_system_bus_get_drvdata(&dev->sbd);\n\treq = priv->req;\n\tif (!req) {\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u non-block layer request completed\\n\", __func__,\n\t\t\t__LINE__);\n\t\tdev->lv1_status = status;\n\t\tcomplete(&dev->done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (req_op(req) == REQ_OP_FLUSH) {\n\t\tread = 0;\n\t\top = \"flush\";\n\t} else {\n\t\tread = !rq_data_dir(req);\n\t\top = read ? \"read\" : \"write\";\n\t}\n\tif (status) {\n\t\tdev_dbg(&dev->sbd.core, \"%s:%u: %s failed 0x%llx\\n\", __func__,\n\t\t\t__LINE__, op, status);\n\t\terror = BLK_STS_IOERR;\n\t} else {\n\t\tdev_dbg(&dev->sbd.core, \"%s:%u: %s completed\\n\", __func__,\n\t\t\t__LINE__, op);\n\t\terror = 0;\n\t\tif (read)\n\t\t\tps3disk_scatter_gather(dev, req, 0);\n\t}\n\n\tspin_lock(&priv->lock);\n\tpriv->req = NULL;\n\tblk_mq_end_request(req, error);\n\tspin_unlock(&priv->lock);\n\n\tblk_mq_run_hw_queues(priv->gendisk->queue, true);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ps3disk_sync_cache(struct ps3_storage_device *dev)\n{\n\tu64 res;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: sync cache\\n\", __func__, __LINE__);\n\n\tres = ps3stor_send_command(dev, LV1_STORAGE_ATA_HDDOUT, 0, 0, 0, 0);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: sync cache failed 0x%llx\\n\",\n\t\t\t__func__, __LINE__, res);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic void swap_buf_le16(u16 *buf, unsigned int buf_words)\n{\n#ifdef __BIG_ENDIAN\n\tunsigned int i;\n\n\tfor (i = 0; i < buf_words; i++)\n\t\tbuf[i] = le16_to_cpu(buf[i]);\n#endif  \n}\n\nstatic u64 ata_id_n_sectors(const u16 *id)\n{\n\tif (ata_id_has_lba(id)) {\n\t\tif (ata_id_has_lba48(id))\n\t\t\treturn ata_id_u64(id, 100);\n\t\telse\n\t\t\treturn ata_id_u32(id, 60);\n\t} else {\n\t\tif (ata_id_current_chs_valid(id))\n\t\t\treturn ata_id_u32(id, 57);\n\t\telse\n\t\t\treturn id[1] * id[3] * id[6];\n\t}\n}\n\nstatic void ata_id_string(const u16 *id, unsigned char *s, unsigned int ofs,\n\t\t\t  unsigned int len)\n{\n\tunsigned int c;\n\n\twhile (len > 0) {\n\t\tc = id[ofs] >> 8;\n\t\t*s = c;\n\t\ts++;\n\n\t\tc = id[ofs] & 0xff;\n\t\t*s = c;\n\t\ts++;\n\n\t\tofs++;\n\t\tlen -= 2;\n\t}\n}\n\nstatic void ata_id_c_string(const u16 *id, unsigned char *s, unsigned int ofs,\n\t\t\t    unsigned int len)\n{\n\tunsigned char *p;\n\n\tWARN_ON(!(len & 1));\n\n\tata_id_string(id, s, ofs, len - 1);\n\n\tp = s + strnlen(s, len - 1);\n\twhile (p > s && p[-1] == ' ')\n\t\tp--;\n\t*p = '\\0';\n}\n\nstatic int ps3disk_identify(struct ps3_storage_device *dev)\n{\n\tstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tstruct lv1_ata_cmnd_block ata_cmnd;\n\tu16 *id = dev->bounce_buf;\n\tu64 res;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: identify disk\\n\", __func__, __LINE__);\n\n\tmemset(&ata_cmnd, 0, sizeof(struct lv1_ata_cmnd_block));\n\tata_cmnd.command = ATA_CMD_ID_ATA;\n\tata_cmnd.sector_count = 1;\n\tata_cmnd.size = ata_cmnd.arglen = ATA_ID_WORDS * 2;\n\tata_cmnd.buffer = dev->bounce_lpar;\n\tata_cmnd.proto = PIO_DATA_IN_PROTO;\n\tata_cmnd.in_out = DIR_READ;\n\n\tres = ps3stor_send_command(dev, LV1_STORAGE_SEND_ATA_COMMAND,\n\t\t\t\t   ps3_mm_phys_to_lpar(__pa(&ata_cmnd)),\n\t\t\t\t   sizeof(ata_cmnd), ata_cmnd.buffer,\n\t\t\t\t   ata_cmnd.arglen);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: identify disk failed 0x%llx\\n\",\n\t\t\t__func__, __LINE__, res);\n\t\treturn -EIO;\n\t}\n\n\tswap_buf_le16(id, ATA_ID_WORDS);\n\n\t \n\tpriv->raw_capacity = ata_id_n_sectors(id);\n\tata_id_c_string(id, priv->model, ATA_ID_PROD, sizeof(priv->model));\n\treturn 0;\n}\n\nstatic unsigned long ps3disk_mask;\n\nstatic DEFINE_MUTEX(ps3disk_mask_mutex);\n\nstatic const struct blk_mq_ops ps3disk_mq_ops = {\n\t.queue_rq\t= ps3disk_queue_rq,\n};\n\nstatic int ps3disk_probe(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\tstruct ps3disk_private *priv;\n\tint error;\n\tunsigned int devidx;\n\tstruct request_queue *queue;\n\tstruct gendisk *gendisk;\n\n\tif (dev->blk_size < 512) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: cannot handle block size %llu\\n\", __func__,\n\t\t\t__LINE__, dev->blk_size);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(PS3DISK_MAX_DISKS > BITS_PER_LONG);\n\tmutex_lock(&ps3disk_mask_mutex);\n\tdevidx = find_first_zero_bit(&ps3disk_mask, PS3DISK_MAX_DISKS);\n\tif (devidx >= PS3DISK_MAX_DISKS) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: Too many disks\\n\", __func__,\n\t\t\t__LINE__);\n\t\tmutex_unlock(&ps3disk_mask_mutex);\n\t\treturn -ENOSPC;\n\t}\n\t__set_bit(devidx, &ps3disk_mask);\n\tmutex_unlock(&ps3disk_mask_mutex);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tps3_system_bus_set_drvdata(_dev, priv);\n\tspin_lock_init(&priv->lock);\n\n\tdev->bounce_size = BOUNCE_SIZE;\n\tdev->bounce_buf = kmalloc(BOUNCE_SIZE, GFP_DMA);\n\tif (!dev->bounce_buf) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_free_priv;\n\t}\n\n\terror = ps3stor_setup(dev, ps3disk_interrupt);\n\tif (error)\n\t\tgoto fail_free_bounce;\n\n\tps3disk_identify(dev);\n\n\terror = blk_mq_alloc_sq_tag_set(&priv->tag_set, &ps3disk_mq_ops, 1,\n\t\t\t\t\tBLK_MQ_F_SHOULD_MERGE);\n\tif (error)\n\t\tgoto fail_teardown;\n\n\tgendisk = blk_mq_alloc_disk(&priv->tag_set, dev);\n\tif (IS_ERR(gendisk)) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: blk_mq_alloc_disk failed\\n\",\n\t\t\t__func__, __LINE__);\n\t\terror = PTR_ERR(gendisk);\n\t\tgoto fail_free_tag_set;\n\t}\n\n\tqueue = gendisk->queue;\n\n\tblk_queue_max_hw_sectors(queue, dev->bounce_size >> 9);\n\tblk_queue_dma_alignment(queue, dev->blk_size-1);\n\tblk_queue_logical_block_size(queue, dev->blk_size);\n\n\tblk_queue_write_cache(queue, true, false);\n\n\tblk_queue_max_segments(queue, -1);\n\tblk_queue_max_segment_size(queue, dev->bounce_size);\n\n\tpriv->gendisk = gendisk;\n\tgendisk->major = ps3disk_major;\n\tgendisk->first_minor = devidx * PS3DISK_MINORS;\n\tgendisk->minors = PS3DISK_MINORS;\n\tgendisk->fops = &ps3disk_fops;\n\tgendisk->private_data = dev;\n\tsnprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,\n\t\t devidx+'a');\n\tpriv->blocking_factor = dev->blk_size >> 9;\n\tset_capacity(gendisk,\n\t\t     dev->regions[dev->region_idx].size*priv->blocking_factor);\n\n\tdev_info(&dev->sbd.core,\n\t\t \"%s is a %s (%llu MiB total, %llu MiB for OtherOS)\\n\",\n\t\t gendisk->disk_name, priv->model, priv->raw_capacity >> 11,\n\t\t get_capacity(gendisk) >> 11);\n\n\terror = device_add_disk(&dev->sbd.core, gendisk, NULL);\n\tif (error)\n\t\tgoto fail_cleanup_disk;\n\n\treturn 0;\nfail_cleanup_disk:\n\tput_disk(gendisk);\nfail_free_tag_set:\n\tblk_mq_free_tag_set(&priv->tag_set);\nfail_teardown:\n\tps3stor_teardown(dev);\nfail_free_bounce:\n\tkfree(dev->bounce_buf);\nfail_free_priv:\n\tkfree(priv);\n\tps3_system_bus_set_drvdata(_dev, NULL);\nfail:\n\tmutex_lock(&ps3disk_mask_mutex);\n\t__clear_bit(devidx, &ps3disk_mask);\n\tmutex_unlock(&ps3disk_mask_mutex);\n\treturn error;\n}\n\nstatic void ps3disk_remove(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\tstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\n\tmutex_lock(&ps3disk_mask_mutex);\n\t__clear_bit(MINOR(disk_devt(priv->gendisk)) / PS3DISK_MINORS,\n\t\t    &ps3disk_mask);\n\tmutex_unlock(&ps3disk_mask_mutex);\n\tdel_gendisk(priv->gendisk);\n\tput_disk(priv->gendisk);\n\tblk_mq_free_tag_set(&priv->tag_set);\n\tdev_notice(&dev->sbd.core, \"Synchronizing disk cache\\n\");\n\tps3disk_sync_cache(dev);\n\tps3stor_teardown(dev);\n\tkfree(dev->bounce_buf);\n\tkfree(priv);\n\tps3_system_bus_set_drvdata(_dev, NULL);\n}\n\nstatic struct ps3_system_bus_driver ps3disk = {\n\t.match_id\t= PS3_MATCH_ID_STOR_DISK,\n\t.core.name\t= DEVICE_NAME,\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3disk_probe,\n\t.remove\t\t= ps3disk_remove,\n\t.shutdown\t= ps3disk_remove,\n};\n\n\nstatic int __init ps3disk_init(void)\n{\n\tint error;\n\n\tif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\n\t\treturn -ENODEV;\n\n\terror = register_blkdev(0, DEVICE_NAME);\n\tif (error <= 0) {\n\t\tprintk(KERN_ERR \"%s:%u: register_blkdev failed %d\\n\", __func__,\n\t\t       __LINE__, error);\n\t\treturn error;\n\t}\n\tps3disk_major = error;\n\n\tpr_info(\"%s:%u: registered block device major %d\\n\", __func__,\n\t\t__LINE__, ps3disk_major);\n\n\terror = ps3_system_bus_driver_register(&ps3disk);\n\tif (error)\n\t\tunregister_blkdev(ps3disk_major, DEVICE_NAME);\n\n\treturn error;\n}\n\nstatic void __exit ps3disk_exit(void)\n{\n\tps3_system_bus_driver_unregister(&ps3disk);\n\tunregister_blkdev(ps3disk_major, DEVICE_NAME);\n}\n\nmodule_init(ps3disk_init);\nmodule_exit(ps3disk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PS3 Disk Storage Driver\");\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_STOR_DISK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}