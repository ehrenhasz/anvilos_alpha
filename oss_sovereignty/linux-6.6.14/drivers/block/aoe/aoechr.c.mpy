{
  "module_name": "aoechr.c",
  "hash_id": "c2a813fbd22f007f97ede9a7ec14a00e801b79e957f48b31664666bb83d250f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/aoe/aoechr.c",
  "human_readable_source": " \n \n\n#include <linux/hdreg.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include \"aoe.h\"\n\nenum {\n\t\n\tMINOR_ERR = 2,\n\tMINOR_DISCOVER,\n\tMINOR_INTERFACES,\n\tMINOR_REVALIDATE,\n\tMINOR_FLUSH,\n\tMSGSZ = 2048,\n\tNMSG = 100,\t\t \n};\n\nstruct aoe_chardev {\n\tulong minor;\n\tchar name[32];\n};\n\nenum { EMFL_VALID = 1 };\n\nstruct ErrMsg {\n\tshort flags;\n\tshort len;\n\tchar *msg;\n};\n\nstatic DEFINE_MUTEX(aoechr_mutex);\n\n \nstatic struct ErrMsg emsgs[NMSG];\nstatic int emsgs_head_idx, emsgs_tail_idx;\nstatic struct completion emsgs_comp;\nstatic spinlock_t emsgs_lock;\nstatic int nblocked_emsgs_readers;\n\nstatic struct aoe_chardev chardevs[] = {\n\t{ MINOR_ERR, \"err\" },\n\t{ MINOR_DISCOVER, \"discover\" },\n\t{ MINOR_INTERFACES, \"interfaces\" },\n\t{ MINOR_REVALIDATE, \"revalidate\" },\n\t{ MINOR_FLUSH, \"flush\" },\n};\n\nstatic char *aoe_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"etherd/%s\", dev_name(dev));\n}\n\nstatic const struct class aoe_class = {\n\t.name = \"aoe\",\n\t.devnode = aoe_devnode,\n};\n\nstatic int\ndiscover(void)\n{\n\taoecmd_cfg(0xffff, 0xff);\n\treturn 0;\n}\n\nstatic int\ninterfaces(const char __user *str, size_t size)\n{\n\tif (set_aoe_iflist(str, size)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"aoe: could not set interface list: too many interfaces\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nrevalidate(const char __user *str, size_t size)\n{\n\tint major, minor, n;\n\tulong flags;\n\tstruct aoedev *d;\n\tstruct sk_buff *skb;\n\tchar buf[16];\n\n\tif (size >= sizeof buf)\n\t\treturn -EINVAL;\n\tbuf[sizeof buf - 1] = '\\0';\n\tif (copy_from_user(buf, str, size))\n\t\treturn -EFAULT;\n\n\tn = sscanf(buf, \"e%d.%d\", &major, &minor);\n\tif (n != 2) {\n\t\tpr_err(\"aoe: invalid device specification %s\\n\", buf);\n\t\treturn -EINVAL;\n\t}\n\td = aoedev_by_aoeaddr(major, minor, 0);\n\tif (!d)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&d->lock, flags);\n\taoecmd_cleanslate(d);\n\taoecmd_cfg(major, minor);\nloop:\n\tskb = aoecmd_ata_id(d);\n\tspin_unlock_irqrestore(&d->lock, flags);\n\t \n\tif (!skb && !msleep_interruptible(250)) {\n\t\tspin_lock_irqsave(&d->lock, flags);\n\t\tgoto loop;\n\t}\n\taoedev_put(d);\n\tif (skb) {\n\t\tstruct sk_buff_head queue;\n\t\t__skb_queue_head_init(&queue);\n\t\t__skb_queue_tail(&queue, skb);\n\t\taoenet_xmit(&queue);\n\t}\n\treturn 0;\n}\n\nvoid\naoechr_error(char *msg)\n{\n\tstruct ErrMsg *em;\n\tchar *mp;\n\tulong flags, n;\n\n\tn = strlen(msg);\n\n\tspin_lock_irqsave(&emsgs_lock, flags);\n\n\tem = emsgs + emsgs_tail_idx;\n\tif ((em->flags & EMFL_VALID)) {\nbail:\t\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\t\treturn;\n\t}\n\n\tmp = kmemdup(msg, n, GFP_ATOMIC);\n\tif (!mp)\n\t\tgoto bail;\n\n\tem->msg = mp;\n\tem->flags |= EMFL_VALID;\n\tem->len = n;\n\n\temsgs_tail_idx++;\n\temsgs_tail_idx %= ARRAY_SIZE(emsgs);\n\n\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\n\tif (nblocked_emsgs_readers)\n\t\tcomplete(&emsgs_comp);\n}\n\nstatic ssize_t\naoechr_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offp)\n{\n\tint ret = -EINVAL;\n\n\tswitch ((unsigned long) filp->private_data) {\n\tdefault:\n\t\tprintk(KERN_INFO \"aoe: can't write to that file.\\n\");\n\t\tbreak;\n\tcase MINOR_DISCOVER:\n\t\tret = discover();\n\t\tbreak;\n\tcase MINOR_INTERFACES:\n\t\tret = interfaces(buf, cnt);\n\t\tbreak;\n\tcase MINOR_REVALIDATE:\n\t\tret = revalidate(buf, cnt);\n\t\tbreak;\n\tcase MINOR_FLUSH:\n\t\tret = aoedev_flush(buf, cnt);\n\t\tbreak;\n\t}\n\tif (ret == 0)\n\t\tret = cnt;\n\treturn ret;\n}\n\nstatic int\naoechr_open(struct inode *inode, struct file *filp)\n{\n\tint n, i;\n\n\tmutex_lock(&aoechr_mutex);\n\tn = iminor(inode);\n\tfilp->private_data = (void *) (unsigned long) n;\n\n\tfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\n\t\tif (chardevs[i].minor == n) {\n\t\t\tmutex_unlock(&aoechr_mutex);\n\t\t\treturn 0;\n\t\t}\n\tmutex_unlock(&aoechr_mutex);\n\treturn -EINVAL;\n}\n\nstatic int\naoechr_rel(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic ssize_t\naoechr_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)\n{\n\tunsigned long n;\n\tchar *mp;\n\tstruct ErrMsg *em;\n\tssize_t len;\n\tulong flags;\n\n\tn = (unsigned long) filp->private_data;\n\tif (n != MINOR_ERR)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&emsgs_lock, flags);\n\n\tfor (;;) {\n\t\tem = emsgs + emsgs_head_idx;\n\t\tif ((em->flags & EMFL_VALID) != 0)\n\t\t\tbreak;\n\t\tif (filp->f_flags & O_NDELAY) {\n\t\t\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tnblocked_emsgs_readers++;\n\n\t\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\n\t\tn = wait_for_completion_interruptible(&emsgs_comp);\n\n\t\tspin_lock_irqsave(&emsgs_lock, flags);\n\n\t\tnblocked_emsgs_readers--;\n\n\t\tif (n) {\n\t\t\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\tif (em->len > cnt) {\n\t\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tmp = em->msg;\n\tlen = em->len;\n\tem->msg = NULL;\n\tem->flags &= ~EMFL_VALID;\n\n\temsgs_head_idx++;\n\temsgs_head_idx %= ARRAY_SIZE(emsgs);\n\n\tspin_unlock_irqrestore(&emsgs_lock, flags);\n\n\tn = copy_to_user(buf, mp, len);\n\tkfree(mp);\n\treturn n == 0 ? len : -EFAULT;\n}\n\nstatic const struct file_operations aoe_fops = {\n\t.write = aoechr_write,\n\t.read = aoechr_read,\n\t.open = aoechr_open,\n\t.release = aoechr_rel,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nint __init\naoechr_init(void)\n{\n\tint n, i;\n\n\tn = register_chrdev(AOE_MAJOR, \"aoechr\", &aoe_fops);\n\tif (n < 0) {\n\t\tprintk(KERN_ERR \"aoe: can't register char device\\n\");\n\t\treturn n;\n\t}\n\tinit_completion(&emsgs_comp);\n\tspin_lock_init(&emsgs_lock);\n\tn = class_register(&aoe_class);\n\tif (n) {\n\t\tunregister_chrdev(AOE_MAJOR, \"aoechr\");\n\t\treturn n;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\n\t\tdevice_create(&aoe_class, NULL,\n\t\t\t      MKDEV(AOE_MAJOR, chardevs[i].minor), NULL,\n\t\t\t      chardevs[i].name);\n\n\treturn 0;\n}\n\nvoid\naoechr_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\n\t\tdevice_destroy(&aoe_class, MKDEV(AOE_MAJOR, chardevs[i].minor));\n\tclass_unregister(&aoe_class);\n\tunregister_chrdev(AOE_MAJOR, \"aoechr\");\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}