{
  "module_name": "aoeblk.c",
  "hash_id": "0b823b83cbfa0e6f9ac6c3af86bca6fd55607c9c6726231b2944cbb97329a751",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/aoe/aoeblk.c",
  "human_readable_source": " \n \n\n#include <linux/kernel.h>\n#include <linux/hdreg.h>\n#include <linux/blk-mq.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/debugfs.h>\n#include <scsi/sg.h>\n#include \"aoe.h\"\n\nstatic DEFINE_MUTEX(aoeblk_mutex);\nstatic struct kmem_cache *buf_pool_cache;\nstatic struct dentry *aoe_debugfs_dir;\n\n \nstatic int aoe_maxsectors;\nmodule_param(aoe_maxsectors, int, 0644);\nMODULE_PARM_DESC(aoe_maxsectors,\n\t\"When nonzero, set the maximum number of sectors per I/O request\");\n\nstatic ssize_t aoedisk_show_state(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tstruct aoedev *d = disk->private_data;\n\n\treturn sysfs_emit(page, \"%s%s\\n\",\n\t\t\t(d->flags & DEVFL_UP) ? \"up\" : \"down\",\n\t\t\t(d->flags & DEVFL_KICKME) ? \",kickme\" :\n\t\t\t(d->nopen && !(d->flags & DEVFL_UP)) ? \",closewait\" : \"\");\n\t \n}\nstatic ssize_t aoedisk_show_mac(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tstruct aoedev *d = disk->private_data;\n\tstruct aoetgt *t = d->targets[0];\n\n\tif (t == NULL)\n\t\treturn sysfs_emit(page, \"none\\n\");\n\treturn sysfs_emit(page, \"%pm\\n\", t->addr);\n}\nstatic ssize_t aoedisk_show_netif(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tstruct aoedev *d = disk->private_data;\n\tstruct net_device *nds[8], **nd, **nnd, **ne;\n\tstruct aoetgt **t, **te;\n\tstruct aoeif *ifp, *e;\n\tchar *p;\n\n\tmemset(nds, 0, sizeof nds);\n\tnd = nds;\n\tne = nd + ARRAY_SIZE(nds);\n\tt = d->targets;\n\tte = t + d->ntargets;\n\tfor (; t < te && *t; t++) {\n\t\tifp = (*t)->ifs;\n\t\te = ifp + NAOEIFS;\n\t\tfor (; ifp < e && ifp->nd; ifp++) {\n\t\t\tfor (nnd = nds; nnd < nd; nnd++)\n\t\t\t\tif (*nnd == ifp->nd)\n\t\t\t\t\tbreak;\n\t\t\tif (nnd == nd && nd != ne)\n\t\t\t\t*nd++ = ifp->nd;\n\t\t}\n\t}\n\n\tne = nd;\n\tnd = nds;\n\tif (*nd == NULL)\n\t\treturn sysfs_emit(page, \"none\\n\");\n\tfor (p = page; nd < ne; nd++)\n\t\tp += scnprintf(p, PAGE_SIZE - (p-page), \"%s%s\",\n\t\t\tp == page ? \"\" : \",\", (*nd)->name);\n\tp += scnprintf(p, PAGE_SIZE - (p-page), \"\\n\");\n\treturn p-page;\n}\n \nstatic ssize_t aoedisk_show_fwver(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tstruct aoedev *d = disk->private_data;\n\n\treturn sysfs_emit(page, \"0x%04x\\n\", (unsigned int) d->fw_ver);\n}\nstatic ssize_t aoedisk_show_payload(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tstruct aoedev *d = disk->private_data;\n\n\treturn sysfs_emit(page, \"%lu\\n\", d->maxbcnt);\n}\n\nstatic int aoe_debugfs_show(struct seq_file *s, void *ignored)\n{\n\tstruct aoedev *d;\n\tstruct aoetgt **t, **te;\n\tstruct aoeif *ifp, *ife;\n\tunsigned long flags;\n\tchar c;\n\n\td = s->private;\n\tseq_printf(s, \"rttavg: %d rttdev: %d\\n\",\n\t\td->rttavg >> RTTSCALE,\n\t\td->rttdev >> RTTDSCALE);\n\tseq_printf(s, \"nskbpool: %d\\n\", skb_queue_len(&d->skbpool));\n\tseq_printf(s, \"kicked: %ld\\n\", d->kicked);\n\tseq_printf(s, \"maxbcnt: %ld\\n\", d->maxbcnt);\n\tseq_printf(s, \"ref: %ld\\n\", d->ref);\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tt = d->targets;\n\tte = t + d->ntargets;\n\tfor (; t < te && *t; t++) {\n\t\tc = '\\t';\n\t\tseq_printf(s, \"falloc: %ld\\n\", (*t)->falloc);\n\t\tseq_printf(s, \"ffree: %p\\n\",\n\t\t\tlist_empty(&(*t)->ffree) ? NULL : (*t)->ffree.next);\n\t\tseq_printf(s, \"%pm:%d:%d:%d\\n\", (*t)->addr, (*t)->nout,\n\t\t\t(*t)->maxout, (*t)->nframes);\n\t\tseq_printf(s, \"\\tssthresh:%d\\n\", (*t)->ssthresh);\n\t\tseq_printf(s, \"\\ttaint:%d\\n\", (*t)->taint);\n\t\tseq_printf(s, \"\\tr:%d\\n\", (*t)->rpkts);\n\t\tseq_printf(s, \"\\tw:%d\\n\", (*t)->wpkts);\n\t\tifp = (*t)->ifs;\n\t\tife = ifp + ARRAY_SIZE((*t)->ifs);\n\t\tfor (; ifp->nd && ifp < ife; ifp++) {\n\t\t\tseq_printf(s, \"%c%s\", c, ifp->nd->name);\n\t\t\tc = ',';\n\t\t}\n\t\tseq_puts(s, \"\\n\");\n\t}\n\tspin_unlock_irqrestore(&d->lock, flags);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(aoe_debugfs);\n\nstatic DEVICE_ATTR(state, 0444, aoedisk_show_state, NULL);\nstatic DEVICE_ATTR(mac, 0444, aoedisk_show_mac, NULL);\nstatic DEVICE_ATTR(netif, 0444, aoedisk_show_netif, NULL);\nstatic struct device_attribute dev_attr_firmware_version = {\n\t.attr = { .name = \"firmware-version\", .mode = 0444 },\n\t.show = aoedisk_show_fwver,\n};\nstatic DEVICE_ATTR(payload, 0444, aoedisk_show_payload, NULL);\n\nstatic struct attribute *aoe_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_mac.attr,\n\t&dev_attr_netif.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_payload.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group aoe_attr_group = {\n\t.attrs = aoe_attrs,\n};\n\nstatic const struct attribute_group *aoe_attr_groups[] = {\n\t&aoe_attr_group,\n\tNULL,\n};\n\nstatic void\naoedisk_add_debugfs(struct aoedev *d)\n{\n\tchar *p;\n\n\tif (aoe_debugfs_dir == NULL)\n\t\treturn;\n\tp = strchr(d->gd->disk_name, '/');\n\tif (p == NULL)\n\t\tp = d->gd->disk_name;\n\telse\n\t\tp++;\n\tBUG_ON(*p == '\\0');\n\td->debugfs = debugfs_create_file(p, 0444, aoe_debugfs_dir, d,\n\t\t\t\t\t &aoe_debugfs_fops);\n}\nvoid\naoedisk_rm_debugfs(struct aoedev *d)\n{\n\tdebugfs_remove(d->debugfs);\n\td->debugfs = NULL;\n}\n\nstatic int\naoeblk_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct aoedev *d = disk->private_data;\n\tulong flags;\n\n\tif (!virt_addr_valid(d)) {\n\t\tpr_crit(\"aoe: invalid device pointer in %s\\n\",\n\t\t\t__func__);\n\t\tWARN_ON(1);\n\t\treturn -ENODEV;\n\t}\n\tif (!(d->flags & DEVFL_UP) || d->flags & DEVFL_TKILL)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&aoeblk_mutex);\n\tspin_lock_irqsave(&d->lock, flags);\n\tif (d->flags & DEVFL_UP && !(d->flags & DEVFL_TKILL)) {\n\t\td->nopen++;\n\t\tspin_unlock_irqrestore(&d->lock, flags);\n\t\tmutex_unlock(&aoeblk_mutex);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&d->lock, flags);\n\tmutex_unlock(&aoeblk_mutex);\n\treturn -ENODEV;\n}\n\nstatic void\naoeblk_release(struct gendisk *disk)\n{\n\tstruct aoedev *d = disk->private_data;\n\tulong flags;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\n\tif (--d->nopen == 0) {\n\t\tspin_unlock_irqrestore(&d->lock, flags);\n\t\taoecmd_cfg(d->aoemajor, d->aoeminor);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nstatic blk_status_t aoeblk_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tstruct aoedev *d = hctx->queue->queuedata;\n\n\tspin_lock_irq(&d->lock);\n\n\tif ((d->flags & DEVFL_UP) == 0) {\n\t\tpr_info_ratelimited(\"aoe: device %ld.%d is not up\\n\",\n\t\t\td->aoemajor, d->aoeminor);\n\t\tspin_unlock_irq(&d->lock);\n\t\tblk_mq_start_request(bd->rq);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tlist_add_tail(&bd->rq->queuelist, &d->rq_list);\n\taoecmd_work(d);\n\tspin_unlock_irq(&d->lock);\n\treturn BLK_STS_OK;\n}\n\nstatic int\naoeblk_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct aoedev *d = bdev->bd_disk->private_data;\n\n\tif ((d->flags & DEVFL_UP) == 0) {\n\t\tprintk(KERN_ERR \"aoe: disk not up\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgeo->cylinders = d->geo.cylinders;\n\tgeo->heads = d->geo.heads;\n\tgeo->sectors = d->geo.sectors;\n\treturn 0;\n}\n\nstatic int\naoeblk_ioctl(struct block_device *bdev, blk_mode_t mode, uint cmd, ulong arg)\n{\n\tstruct aoedev *d;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\td = bdev->bd_disk->private_data;\n\tif ((d->flags & DEVFL_UP) == 0) {\n\t\tpr_err(\"aoe: disk not up\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cmd == HDIO_GET_IDENTITY) {\n\t\tif (!copy_to_user((void __user *) arg, &d->ident,\n\t\t\tsizeof(d->ident)))\n\t\t\treturn 0;\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (cmd != SG_IO)\n\t\tpr_info(\"aoe: unknown ioctl 0x%x\\n\", cmd);\n\n\treturn -ENOTTY;\n}\n\nstatic const struct block_device_operations aoe_bdops = {\n\t.open = aoeblk_open,\n\t.release = aoeblk_release,\n\t.ioctl = aoeblk_ioctl,\n\t.compat_ioctl = blkdev_compat_ptr_ioctl,\n\t.getgeo = aoeblk_getgeo,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct blk_mq_ops aoeblk_mq_ops = {\n\t.queue_rq\t= aoeblk_queue_rq,\n};\n\n \nvoid\naoeblk_gdalloc(void *vp)\n{\n\tstruct aoedev *d = vp;\n\tstruct gendisk *gd;\n\tmempool_t *mp;\n\tstruct blk_mq_tag_set *set;\n\tulong flags;\n\tint late = 0;\n\tint err;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tif (d->flags & DEVFL_GDALLOC\n\t&& !(d->flags & DEVFL_TKILL)\n\t&& !(d->flags & DEVFL_GD_NOW))\n\t\td->flags |= DEVFL_GD_NOW;\n\telse\n\t\tlate = 1;\n\tspin_unlock_irqrestore(&d->lock, flags);\n\tif (late)\n\t\treturn;\n\n\tmp = mempool_create(MIN_BUFS, mempool_alloc_slab, mempool_free_slab,\n\t\tbuf_pool_cache);\n\tif (mp == NULL) {\n\t\tprintk(KERN_ERR \"aoe: cannot allocate bufpool for %ld.%d\\n\",\n\t\t\td->aoemajor, d->aoeminor);\n\t\tgoto err;\n\t}\n\n\tset = &d->tag_set;\n\tset->ops = &aoeblk_mq_ops;\n\tset->cmd_size = sizeof(struct aoe_req);\n\tset->nr_hw_queues = 1;\n\tset->queue_depth = 128;\n\tset->numa_node = NUMA_NO_NODE;\n\tset->flags = BLK_MQ_F_SHOULD_MERGE;\n\terr = blk_mq_alloc_tag_set(set);\n\tif (err) {\n\t\tpr_err(\"aoe: cannot allocate tag set for %ld.%d\\n\",\n\t\t\td->aoemajor, d->aoeminor);\n\t\tgoto err_mempool;\n\t}\n\n\tgd = blk_mq_alloc_disk(set, d);\n\tif (IS_ERR(gd)) {\n\t\tpr_err(\"aoe: cannot allocate block queue for %ld.%d\\n\",\n\t\t\td->aoemajor, d->aoeminor);\n\t\tgoto err_tagset;\n\t}\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tWARN_ON(!(d->flags & DEVFL_GD_NOW));\n\tWARN_ON(!(d->flags & DEVFL_GDALLOC));\n\tWARN_ON(d->flags & DEVFL_TKILL);\n\tWARN_ON(d->gd);\n\tWARN_ON(d->flags & DEVFL_UP);\n\tblk_queue_max_hw_sectors(gd->queue, BLK_DEF_MAX_SECTORS);\n\tblk_queue_io_opt(gd->queue, SZ_2M);\n\td->bufpool = mp;\n\td->blkq = gd->queue;\n\td->gd = gd;\n\tif (aoe_maxsectors)\n\t\tblk_queue_max_hw_sectors(gd->queue, aoe_maxsectors);\n\tgd->major = AOE_MAJOR;\n\tgd->first_minor = d->sysminor;\n\tgd->minors = AOE_PARTITIONS;\n\tgd->fops = &aoe_bdops;\n\tgd->private_data = d;\n\tset_capacity(gd, d->ssize);\n\tsnprintf(gd->disk_name, sizeof gd->disk_name, \"etherd/e%ld.%d\",\n\t\td->aoemajor, d->aoeminor);\n\n\td->flags &= ~DEVFL_GDALLOC;\n\td->flags |= DEVFL_UP;\n\n\tspin_unlock_irqrestore(&d->lock, flags);\n\n\terr = device_add_disk(NULL, gd, aoe_attr_groups);\n\tif (err)\n\t\tgoto out_disk_cleanup;\n\taoedisk_add_debugfs(d);\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tWARN_ON(!(d->flags & DEVFL_GD_NOW));\n\td->flags &= ~DEVFL_GD_NOW;\n\tspin_unlock_irqrestore(&d->lock, flags);\n\treturn;\n\nout_disk_cleanup:\n\tput_disk(gd);\nerr_tagset:\n\tblk_mq_free_tag_set(set);\nerr_mempool:\n\tmempool_destroy(mp);\nerr:\n\tspin_lock_irqsave(&d->lock, flags);\n\td->flags &= ~DEVFL_GD_NOW;\n\tqueue_work(aoe_wq, &d->work);\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nvoid\naoeblk_exit(void)\n{\n\tdebugfs_remove_recursive(aoe_debugfs_dir);\n\taoe_debugfs_dir = NULL;\n\tkmem_cache_destroy(buf_pool_cache);\n}\n\nint __init\naoeblk_init(void)\n{\n\tbuf_pool_cache = kmem_cache_create(\"aoe_bufs\",\n\t\t\t\t\t   sizeof(struct buf),\n\t\t\t\t\t   0, 0, NULL);\n\tif (buf_pool_cache == NULL)\n\t\treturn -ENOMEM;\n\taoe_debugfs_dir = debugfs_create_dir(\"aoe\", NULL);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}