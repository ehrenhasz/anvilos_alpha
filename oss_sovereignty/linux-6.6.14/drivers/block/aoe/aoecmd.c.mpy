{
  "module_name": "aoecmd.c",
  "hash_id": "7bae5f1c6198a1551b8653122a6960e44409f0ea839429f58bed3d5b337e30ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/aoe/aoecmd.c",
  "human_readable_source": " \n \n\n#include <linux/ata.h>\n#include <linux/slab.h>\n#include <linux/hdreg.h>\n#include <linux/blk-mq.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/moduleparam.h>\n#include <linux/workqueue.h>\n#include <linux/kthread.h>\n#include <net/net_namespace.h>\n#include <asm/unaligned.h>\n#include <linux/uio.h>\n#include \"aoe.h\"\n\n#define MAXIOC (8192)\t \n\nstatic void ktcomplete(struct frame *, struct sk_buff *);\nstatic int count_targets(struct aoedev *d, int *untainted);\n\nstatic struct buf *nextbuf(struct aoedev *);\n\nstatic int aoe_deadsecs = 60 * 3;\nmodule_param(aoe_deadsecs, int, 0644);\nMODULE_PARM_DESC(aoe_deadsecs, \"After aoe_deadsecs seconds, give up and fail dev.\");\n\nstatic int aoe_maxout = 64;\nmodule_param(aoe_maxout, int, 0644);\nMODULE_PARM_DESC(aoe_maxout,\n\t\"Only aoe_maxout outstanding packets for every MAC on eX.Y.\");\n\n \nstatic int ncpus;\n\n \nstatic DEFINE_MUTEX(ktio_spawn_lock);\n\nstatic wait_queue_head_t *ktiowq;\nstatic struct ktstate *kts;\n\n \nstruct iocq_ktio {\n\tstruct list_head head;\n\tspinlock_t lock;\n};\nstatic struct iocq_ktio *iocq;\n\nstatic struct page *empty_page;\n\nstatic struct sk_buff *\nnew_skb(ulong len)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len + MAX_HEADER, GFP_ATOMIC);\n\tif (skb) {\n\t\tskb_reserve(skb, MAX_HEADER);\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = __constant_htons(ETH_P_AOE);\n\t\tskb_checksum_none_assert(skb);\n\t}\n\treturn skb;\n}\n\nstatic struct frame *\ngetframe_deferred(struct aoedev *d, u32 tag)\n{\n\tstruct list_head *head, *pos, *nx;\n\tstruct frame *f;\n\n\thead = &d->rexmitq;\n\tlist_for_each_safe(pos, nx, head) {\n\t\tf = list_entry(pos, struct frame, head);\n\t\tif (f->tag == tag) {\n\t\t\tlist_del(pos);\n\t\t\treturn f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct frame *\ngetframe(struct aoedev *d, u32 tag)\n{\n\tstruct frame *f;\n\tstruct list_head *head, *pos, *nx;\n\tu32 n;\n\n\tn = tag % NFACTIVE;\n\thead = &d->factive[n];\n\tlist_for_each_safe(pos, nx, head) {\n\t\tf = list_entry(pos, struct frame, head);\n\t\tif (f->tag == tag) {\n\t\t\tlist_del(pos);\n\t\t\treturn f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nnewtag(struct aoedev *d)\n{\n\tregister ulong n;\n\n\tn = jiffies & 0xffff;\n\treturn n | (++d->lasttag & 0x7fff) << 16;\n}\n\nstatic u32\naoehdr_atainit(struct aoedev *d, struct aoetgt *t, struct aoe_hdr *h)\n{\n\tu32 host_tag = newtag(d);\n\n\tmemcpy(h->src, t->ifp->nd->dev_addr, sizeof h->src);\n\tmemcpy(h->dst, t->addr, sizeof h->dst);\n\th->type = __constant_cpu_to_be16(ETH_P_AOE);\n\th->verfl = AOE_HVER;\n\th->major = cpu_to_be16(d->aoemajor);\n\th->minor = d->aoeminor;\n\th->cmd = AOECMD_ATA;\n\th->tag = cpu_to_be32(host_tag);\n\n\treturn host_tag;\n}\n\nstatic inline void\nput_lba(struct aoe_atahdr *ah, sector_t lba)\n{\n\tah->lba0 = lba;\n\tah->lba1 = lba >>= 8;\n\tah->lba2 = lba >>= 8;\n\tah->lba3 = lba >>= 8;\n\tah->lba4 = lba >>= 8;\n\tah->lba5 = lba >>= 8;\n}\n\nstatic struct aoeif *\nifrotate(struct aoetgt *t)\n{\n\tstruct aoeif *ifp;\n\n\tifp = t->ifp;\n\tifp++;\n\tif (ifp >= &t->ifs[NAOEIFS] || ifp->nd == NULL)\n\t\tifp = t->ifs;\n\tif (ifp->nd == NULL)\n\t\treturn NULL;\n\treturn t->ifp = ifp;\n}\n\nstatic void\nskb_pool_put(struct aoedev *d, struct sk_buff *skb)\n{\n\t__skb_queue_tail(&d->skbpool, skb);\n}\n\nstatic struct sk_buff *\nskb_pool_get(struct aoedev *d)\n{\n\tstruct sk_buff *skb = skb_peek(&d->skbpool);\n\n\tif (skb && atomic_read(&skb_shinfo(skb)->dataref) == 1) {\n\t\t__skb_unlink(skb, &d->skbpool);\n\t\treturn skb;\n\t}\n\tif (skb_queue_len(&d->skbpool) < NSKBPOOLMAX &&\n\t    (skb = new_skb(ETH_ZLEN)))\n\t\treturn skb;\n\n\treturn NULL;\n}\n\nvoid\naoe_freetframe(struct frame *f)\n{\n\tstruct aoetgt *t;\n\n\tt = f->t;\n\tf->buf = NULL;\n\tmemset(&f->iter, 0, sizeof(f->iter));\n\tf->r_skb = NULL;\n\tf->flags = 0;\n\tlist_add(&f->head, &t->ffree);\n}\n\nstatic struct frame *\nnewtframe(struct aoedev *d, struct aoetgt *t)\n{\n\tstruct frame *f;\n\tstruct sk_buff *skb;\n\tstruct list_head *pos;\n\n\tif (list_empty(&t->ffree)) {\n\t\tif (t->falloc >= NSKBPOOLMAX*2)\n\t\t\treturn NULL;\n\t\tf = kcalloc(1, sizeof(*f), GFP_ATOMIC);\n\t\tif (f == NULL)\n\t\t\treturn NULL;\n\t\tt->falloc++;\n\t\tf->t = t;\n\t} else {\n\t\tpos = t->ffree.next;\n\t\tlist_del(pos);\n\t\tf = list_entry(pos, struct frame, head);\n\t}\n\n\tskb = f->skb;\n\tif (skb == NULL) {\n\t\tf->skb = skb = new_skb(ETH_ZLEN);\n\t\tif (!skb) {\nbail:\t\t\taoe_freetframe(f);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (atomic_read(&skb_shinfo(skb)->dataref) != 1) {\n\t\tskb = skb_pool_get(d);\n\t\tif (skb == NULL)\n\t\t\tgoto bail;\n\t\tskb_pool_put(d, f->skb);\n\t\tf->skb = skb;\n\t}\n\n\tskb->truesize -= skb->data_len;\n\tskb_shinfo(skb)->nr_frags = skb->data_len = 0;\n\tskb_trim(skb, 0);\n\treturn f;\n}\n\nstatic struct frame *\nnewframe(struct aoedev *d)\n{\n\tstruct frame *f;\n\tstruct aoetgt *t, **tt;\n\tint totout = 0;\n\tint use_tainted;\n\tint has_untainted;\n\n\tif (!d->targets || !d->targets[0]) {\n\t\tprintk(KERN_ERR \"aoe: NULL TARGETS!\\n\");\n\t\treturn NULL;\n\t}\n\ttt = d->tgt;\t \n\tfor (use_tainted = 0, has_untainted = 0;;) {\n\t\ttt++;\n\t\tif (tt >= &d->targets[d->ntargets] || !*tt)\n\t\t\ttt = d->targets;\n\t\tt = *tt;\n\t\tif (!t->taint) {\n\t\t\thas_untainted = 1;\n\t\t\ttotout += t->nout;\n\t\t}\n\t\tif (t->nout < t->maxout\n\t\t&& (use_tainted || !t->taint)\n\t\t&& t->ifp->nd) {\n\t\t\tf = newtframe(d, t);\n\t\t\tif (f) {\n\t\t\t\tifrotate(t);\n\t\t\t\td->tgt = tt;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\tif (tt == d->tgt) {\t \n\t\t\tif (!use_tainted && !has_untainted)\n\t\t\t\tuse_tainted = 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (totout == 0) {\n\t\td->kicked++;\n\t\td->flags |= DEVFL_KICKME;\n\t}\n\treturn NULL;\n}\n\nstatic void\nskb_fillup(struct sk_buff *skb, struct bio *bio, struct bvec_iter iter)\n{\n\tint frag = 0;\n\tstruct bio_vec bv;\n\n\t__bio_for_each_segment(bv, bio, iter, iter)\n\t\tskb_fill_page_desc(skb, frag++, bv.bv_page,\n\t\t\t\t   bv.bv_offset, bv.bv_len);\n}\n\nstatic void\nfhash(struct frame *f)\n{\n\tstruct aoedev *d = f->t->d;\n\tu32 n;\n\n\tn = f->tag % NFACTIVE;\n\tlist_add_tail(&f->head, &d->factive[n]);\n}\n\nstatic void\nata_rw_frameinit(struct frame *f)\n{\n\tstruct aoetgt *t;\n\tstruct aoe_hdr *h;\n\tstruct aoe_atahdr *ah;\n\tstruct sk_buff *skb;\n\tchar writebit, extbit;\n\n\tskb = f->skb;\n\th = (struct aoe_hdr *) skb_mac_header(skb);\n\tah = (struct aoe_atahdr *) (h + 1);\n\tskb_put(skb, sizeof(*h) + sizeof(*ah));\n\tmemset(h, 0, skb->len);\n\n\twritebit = 0x10;\n\textbit = 0x4;\n\n\tt = f->t;\n\tf->tag = aoehdr_atainit(t->d, t, h);\n\tfhash(f);\n\tt->nout++;\n\tf->waited = 0;\n\tf->waited_total = 0;\n\n\t \n\tah->scnt = f->iter.bi_size >> 9;\n\tput_lba(ah, f->iter.bi_sector);\n\tif (t->d->flags & DEVFL_EXT) {\n\t\tah->aflags |= AOEAFL_EXT;\n\t} else {\n\t\textbit = 0;\n\t\tah->lba3 &= 0x0f;\n\t\tah->lba3 |= 0xe0;\t \n\t}\n\tif (f->buf && bio_data_dir(f->buf->bio) == WRITE) {\n\t\tskb_fillup(skb, f->buf->bio, f->iter);\n\t\tah->aflags |= AOEAFL_WRITE;\n\t\tskb->len += f->iter.bi_size;\n\t\tskb->data_len = f->iter.bi_size;\n\t\tskb->truesize += f->iter.bi_size;\n\t\tt->wpkts++;\n\t} else {\n\t\tt->rpkts++;\n\t\twritebit = 0;\n\t}\n\n\tah->cmdstat = ATA_CMD_PIO_READ | writebit | extbit;\n\tskb->dev = t->ifp->nd;\n}\n\nstatic int\naoecmd_ata_rw(struct aoedev *d)\n{\n\tstruct frame *f;\n\tstruct buf *buf;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head queue;\n\n\tbuf = nextbuf(d);\n\tif (buf == NULL)\n\t\treturn 0;\n\tf = newframe(d);\n\tif (f == NULL)\n\t\treturn 0;\n\n\t \n\tf->buf = buf;\n\tf->iter = buf->iter;\n\tf->iter.bi_size = min_t(unsigned long,\n\t\t\t\td->maxbcnt ?: DEFAULTBCNT,\n\t\t\t\tf->iter.bi_size);\n\tbio_advance_iter(buf->bio, &buf->iter, f->iter.bi_size);\n\n\tif (!buf->iter.bi_size)\n\t\td->ip.buf = NULL;\n\n\t \n\tbuf->nframesout += 1;\n\n\tata_rw_frameinit(f);\n\n\tskb = skb_clone(f->skb, GFP_ATOMIC);\n\tif (skb) {\n\t\tf->sent = ktime_get();\n\t\t__skb_queue_head_init(&queue);\n\t\t__skb_queue_tail(&queue, skb);\n\t\taoenet_xmit(&queue);\n\t}\n\treturn 1;\n}\n\n \nstatic void\naoecmd_cfg_pkts(ushort aoemajor, unsigned char aoeminor, struct sk_buff_head *queue)\n{\n\tstruct aoe_hdr *h;\n\tstruct aoe_cfghdr *ch;\n\tstruct sk_buff *skb;\n\tstruct net_device *ifp;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, ifp) {\n\t\tdev_hold(ifp);\n\t\tif (!is_aoe_netif(ifp))\n\t\t\tgoto cont;\n\n\t\tskb = new_skb(sizeof *h + sizeof *ch);\n\t\tif (skb == NULL) {\n\t\t\tprintk(KERN_INFO \"aoe: skb alloc failure\\n\");\n\t\t\tgoto cont;\n\t\t}\n\t\tskb_put(skb, sizeof *h + sizeof *ch);\n\t\tskb->dev = ifp;\n\t\t__skb_queue_tail(queue, skb);\n\t\th = (struct aoe_hdr *) skb_mac_header(skb);\n\t\tmemset(h, 0, sizeof *h + sizeof *ch);\n\n\t\tmemset(h->dst, 0xff, sizeof h->dst);\n\t\tmemcpy(h->src, ifp->dev_addr, sizeof h->src);\n\t\th->type = __constant_cpu_to_be16(ETH_P_AOE);\n\t\th->verfl = AOE_HVER;\n\t\th->major = cpu_to_be16(aoemajor);\n\t\th->minor = aoeminor;\n\t\th->cmd = AOECMD_CFG;\n\ncont:\n\t\tdev_put(ifp);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nresend(struct aoedev *d, struct frame *f)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head queue;\n\tstruct aoe_hdr *h;\n\tstruct aoetgt *t;\n\tchar buf[128];\n\tu32 n;\n\n\tt = f->t;\n\tn = newtag(d);\n\tskb = f->skb;\n\tif (ifrotate(t) == NULL) {\n\t\t \n\t\tpr_info(\"aoe: resend: no interfaces to rotate to.\\n\");\n\t\tktcomplete(f, NULL);\n\t\treturn;\n\t}\n\th = (struct aoe_hdr *) skb_mac_header(skb);\n\n\tif (!(f->flags & FFL_PROBE)) {\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\"%15s e%ld.%d oldtag=%08x@%08lx newtag=%08x s=%pm d=%pm nout=%d\\n\",\n\t\t\t\"retransmit\", d->aoemajor, d->aoeminor,\n\t\t\tf->tag, jiffies, n,\n\t\t\th->src, h->dst, t->nout);\n\t\taoechr_error(buf);\n\t}\n\n\tf->tag = n;\n\tfhash(f);\n\th->tag = cpu_to_be32(n);\n\tmemcpy(h->dst, t->addr, sizeof h->dst);\n\tmemcpy(h->src, t->ifp->nd->dev_addr, sizeof h->src);\n\n\tskb->dev = t->ifp->nd;\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn;\n\tf->sent = ktime_get();\n\t__skb_queue_head_init(&queue);\n\t__skb_queue_tail(&queue, skb);\n\taoenet_xmit(&queue);\n}\n\nstatic int\ntsince_hr(struct frame *f)\n{\n\tu64 delta = ktime_to_ns(ktime_sub(ktime_get(), f->sent));\n\n\t \n\tif (likely(delta <= UINT_MAX))\n\t\treturn (u32)delta / NSEC_PER_USEC;\n\n\t \n\tif (delta > ((u64)INT_MAX * NSEC_PER_USEC))\n\t\treturn INT_MAX;\n\n\treturn div_u64(delta, NSEC_PER_USEC);\n}\n\nstatic int\ntsince(u32 tag)\n{\n\tint n;\n\n\tn = jiffies & 0xffff;\n\tn -= tag & 0xffff;\n\tif (n < 0)\n\t\tn += 1<<16;\n\treturn jiffies_to_usecs(n + 1);\n}\n\nstatic struct aoeif *\ngetif(struct aoetgt *t, struct net_device *nd)\n{\n\tstruct aoeif *p, *e;\n\n\tp = t->ifs;\n\te = p + NAOEIFS;\n\tfor (; p < e; p++)\n\t\tif (p->nd == nd)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstatic void\nejectif(struct aoetgt *t, struct aoeif *ifp)\n{\n\tstruct aoeif *e;\n\tstruct net_device *nd;\n\tulong n;\n\n\tnd = ifp->nd;\n\te = t->ifs + NAOEIFS - 1;\n\tn = (e - ifp) * sizeof *ifp;\n\tmemmove(ifp, ifp+1, n);\n\te->nd = NULL;\n\tdev_put(nd);\n}\n\nstatic struct frame *\nreassign_frame(struct frame *f)\n{\n\tstruct frame *nf;\n\tstruct sk_buff *skb;\n\n\tnf = newframe(f->t->d);\n\tif (!nf)\n\t\treturn NULL;\n\tif (nf->t == f->t) {\n\t\taoe_freetframe(nf);\n\t\treturn NULL;\n\t}\n\n\tskb = nf->skb;\n\tnf->skb = f->skb;\n\tnf->buf = f->buf;\n\tnf->iter = f->iter;\n\tnf->waited = 0;\n\tnf->waited_total = f->waited_total;\n\tnf->sent = f->sent;\n\tf->skb = skb;\n\n\treturn nf;\n}\n\nstatic void\nprobe(struct aoetgt *t)\n{\n\tstruct aoedev *d;\n\tstruct frame *f;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head queue;\n\tsize_t n, m;\n\tint frag;\n\n\td = t->d;\n\tf = newtframe(d, t);\n\tif (!f) {\n\t\tpr_err(\"%s %pm for e%ld.%d: %s\\n\",\n\t\t\t\"aoe: cannot probe remote address\",\n\t\t\tt->addr,\n\t\t\t(long) d->aoemajor, d->aoeminor,\n\t\t\t\"no frame available\");\n\t\treturn;\n\t}\n\tf->flags |= FFL_PROBE;\n\tifrotate(t);\n\tf->iter.bi_size = t->d->maxbcnt ? t->d->maxbcnt : DEFAULTBCNT;\n\tata_rw_frameinit(f);\n\tskb = f->skb;\n\tfor (frag = 0, n = f->iter.bi_size; n > 0; ++frag, n -= m) {\n\t\tif (n < PAGE_SIZE)\n\t\t\tm = n;\n\t\telse\n\t\t\tm = PAGE_SIZE;\n\t\tskb_fill_page_desc(skb, frag, empty_page, 0, m);\n\t}\n\tskb->len += f->iter.bi_size;\n\tskb->data_len = f->iter.bi_size;\n\tskb->truesize += f->iter.bi_size;\n\n\tskb = skb_clone(f->skb, GFP_ATOMIC);\n\tif (skb) {\n\t\tf->sent = ktime_get();\n\t\t__skb_queue_head_init(&queue);\n\t\t__skb_queue_tail(&queue, skb);\n\t\taoenet_xmit(&queue);\n\t}\n}\n\nstatic long\nrto(struct aoedev *d)\n{\n\tlong t;\n\n\tt = 2 * d->rttavg >> RTTSCALE;\n\tt += 8 * d->rttdev >> RTTDSCALE;\n\tif (t == 0)\n\t\tt = 1;\n\n\treturn t;\n}\n\nstatic void\nrexmit_deferred(struct aoedev *d)\n{\n\tstruct aoetgt *t;\n\tstruct frame *f;\n\tstruct frame *nf;\n\tstruct list_head *pos, *nx, *head;\n\tint since;\n\tint untainted;\n\n\tcount_targets(d, &untainted);\n\n\thead = &d->rexmitq;\n\tlist_for_each_safe(pos, nx, head) {\n\t\tf = list_entry(pos, struct frame, head);\n\t\tt = f->t;\n\t\tif (t->taint) {\n\t\t\tif (!(f->flags & FFL_PROBE)) {\n\t\t\t\tnf = reassign_frame(f);\n\t\t\t\tif (nf) {\n\t\t\t\t\tif (t->nout_probes == 0\n\t\t\t\t\t&& untainted > 0) {\n\t\t\t\t\t\tprobe(t);\n\t\t\t\t\t\tt->nout_probes++;\n\t\t\t\t\t}\n\t\t\t\t\tlist_replace(&f->head, &nf->head);\n\t\t\t\t\tpos = &nf->head;\n\t\t\t\t\taoe_freetframe(f);\n\t\t\t\t\tf = nf;\n\t\t\t\t\tt = f->t;\n\t\t\t\t}\n\t\t\t} else if (untainted < 1) {\n\t\t\t\t \n\t\t\t\tgoto stop_probe;\n\t\t\t} else if (tsince_hr(f) < t->taint * rto(d)) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (f->flags & FFL_PROBE) {\nstop_probe:\t\t \n\t\t\tlist_del(pos);\n\t\t\taoe_freetframe(f);\n\t\t\t \n\t\t\tf->t->d->flags |= DEVFL_KICKME;\n\t\t\tcontinue;\n\t\t}\n\t\tif (t->nout >= t->maxout)\n\t\t\tcontinue;\n\t\tlist_del(pos);\n\t\tt->nout++;\n\t\tif (f->flags & FFL_PROBE)\n\t\t\tt->nout_probes++;\n\t\tsince = tsince_hr(f);\n\t\tf->waited += since;\n\t\tf->waited_total += since;\n\t\tresend(d, f);\n\t}\n}\n\n \nstatic void\nscorn(struct aoetgt *t)\n{\n\tint n;\n\n\tn = t->taint++;\n\tt->taint += t->taint * 2;\n\tif (n > t->taint)\n\t\tt->taint = n;\n\tif (t->taint > MAX_TAINT)\n\t\tt->taint = MAX_TAINT;\n}\n\nstatic int\ncount_targets(struct aoedev *d, int *untainted)\n{\n\tint i, good;\n\n\tfor (i = good = 0; i < d->ntargets && d->targets[i]; ++i)\n\t\tif (d->targets[i]->taint == 0)\n\t\t\tgood++;\n\n\tif (untainted)\n\t\t*untainted = good;\n\treturn i;\n}\n\nstatic void\nrexmit_timer(struct timer_list *timer)\n{\n\tstruct aoedev *d;\n\tstruct aoetgt *t;\n\tstruct aoeif *ifp;\n\tstruct frame *f;\n\tstruct list_head *head, *pos, *nx;\n\tLIST_HEAD(flist);\n\tregister long timeout;\n\tulong flags, n;\n\tint i;\n\tint utgts;\t \n\tint since;\n\n\td = from_timer(d, timer, timer);\n\n\tspin_lock_irqsave(&d->lock, flags);\n\n\t \n\ttimeout = rto(d);\n\n\tutgts = count_targets(d, NULL);\n\n\tif (d->flags & DEVFL_TKILL) {\n\t\tspin_unlock_irqrestore(&d->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < NFACTIVE; i++) {\n\t\thead = &d->factive[i];\n\t\tlist_for_each_safe(pos, nx, head) {\n\t\t\tf = list_entry(pos, struct frame, head);\n\t\t\tif (tsince_hr(f) < timeout)\n\t\t\t\tbreak;\t \n\t\t\t \n\t\t\tlist_move_tail(pos, &flist);\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&flist)) {\n\t\tpos = flist.next;\n\t\tf = list_entry(pos, struct frame, head);\n\t\tsince = tsince_hr(f);\n\t\tn = f->waited_total + since;\n\t\tn /= USEC_PER_SEC;\n\t\tif (aoe_deadsecs\n\t\t&& n > aoe_deadsecs\n\t\t&& !(f->flags & FFL_PROBE)) {\n\t\t\t \n\t\t\tlist_splice(&flist, &d->factive[0]);\n\t\t\taoedev_downdev(d);\n\t\t\tgoto out;\n\t\t}\n\n\t\tt = f->t;\n\t\tn = f->waited + since;\n\t\tn /= USEC_PER_SEC;\n\t\tif (aoe_deadsecs && utgts > 0\n\t\t&& (n > aoe_deadsecs / utgts || n > HARD_SCORN_SECS))\n\t\t\tscorn(t);  \n\n\t\tif (t->maxout != 1) {\n\t\t\tt->ssthresh = t->maxout / 2;\n\t\t\tt->maxout = 1;\n\t\t}\n\n\t\tif (f->flags & FFL_PROBE) {\n\t\t\tt->nout_probes--;\n\t\t} else {\n\t\t\tifp = getif(t, f->skb->dev);\n\t\t\tif (ifp && ++ifp->lost > (t->nframes << 1)\n\t\t\t&& (ifp != t->ifs || t->ifs[1].nd)) {\n\t\t\t\tejectif(t, ifp);\n\t\t\t\tifp = NULL;\n\t\t\t}\n\t\t}\n\t\tlist_move_tail(pos, &d->rexmitq);\n\t\tt->nout--;\n\t}\n\trexmit_deferred(d);\n\nout:\n\tif ((d->flags & DEVFL_KICKME) && d->blkq) {\n\t\td->flags &= ~DEVFL_KICKME;\n\t\tblk_mq_run_hw_queues(d->blkq, true);\n\t}\n\n\td->timer.expires = jiffies + TIMERTICK;\n\tadd_timer(&d->timer);\n\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nstatic void\nbufinit(struct buf *buf, struct request *rq, struct bio *bio)\n{\n\tmemset(buf, 0, sizeof(*buf));\n\tbuf->rq = rq;\n\tbuf->bio = bio;\n\tbuf->iter = bio->bi_iter;\n}\n\nstatic struct buf *\nnextbuf(struct aoedev *d)\n{\n\tstruct request *rq;\n\tstruct request_queue *q;\n\tstruct aoe_req *req;\n\tstruct buf *buf;\n\tstruct bio *bio;\n\n\tq = d->blkq;\n\tif (q == NULL)\n\t\treturn NULL;\t \n\tif (d->ip.buf)\n\t\treturn d->ip.buf;\n\trq = d->ip.rq;\n\tif (rq == NULL) {\n\t\trq = list_first_entry_or_null(&d->rq_list, struct request,\n\t\t\t\t\t\tqueuelist);\n\t\tif (rq == NULL)\n\t\t\treturn NULL;\n\t\tlist_del_init(&rq->queuelist);\n\t\tblk_mq_start_request(rq);\n\t\td->ip.rq = rq;\n\t\td->ip.nxbio = rq->bio;\n\n\t\treq = blk_mq_rq_to_pdu(rq);\n\t\treq->nr_bios = 0;\n\t\t__rq_for_each_bio(bio, rq)\n\t\t\treq->nr_bios++;\n\t}\n\tbuf = mempool_alloc(d->bufpool, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tpr_err(\"aoe: nextbuf: unable to mempool_alloc!\\n\");\n\t\treturn NULL;\n\t}\n\tbio = d->ip.nxbio;\n\tbufinit(buf, rq, bio);\n\tbio = bio->bi_next;\n\td->ip.nxbio = bio;\n\tif (bio == NULL)\n\t\td->ip.rq = NULL;\n\treturn d->ip.buf = buf;\n}\n\n \nvoid\naoecmd_work(struct aoedev *d)\n{\n\trexmit_deferred(d);\n\twhile (aoecmd_ata_rw(d))\n\t\t;\n}\n\n \nvoid\naoecmd_sleepwork(struct work_struct *work)\n{\n\tstruct aoedev *d = container_of(work, struct aoedev, work);\n\n\tif (d->flags & DEVFL_GDALLOC)\n\t\taoeblk_gdalloc(d);\n\n\tif (d->flags & DEVFL_NEWSIZE) {\n\t\tset_capacity_and_notify(d->gd, d->ssize);\n\n\t\tspin_lock_irq(&d->lock);\n\t\td->flags |= DEVFL_UP;\n\t\td->flags &= ~DEVFL_NEWSIZE;\n\t\tspin_unlock_irq(&d->lock);\n\t}\n}\n\nstatic void\nata_ident_fixstring(u16 *id, int ns)\n{\n\tu16 s;\n\n\twhile (ns-- > 0) {\n\t\ts = *id;\n\t\t*id++ = s >> 8 | s << 8;\n\t}\n}\n\nstatic void\nataid_complete(struct aoedev *d, struct aoetgt *t, unsigned char *id)\n{\n\tu64 ssize;\n\tu16 n;\n\n\t \n\tn = get_unaligned_le16(&id[83 << 1]);\n\n\t \n\tn |= get_unaligned_le16(&id[86 << 1]);\n\n\tif (n & (1<<10)) {\t \n\t\td->flags |= DEVFL_EXT;\n\n\t\t \n\t\tssize = get_unaligned_le64(&id[100 << 1]);\n\n\t\t \n\t\td->geo.cylinders = ssize;\n\t\td->geo.cylinders /= (255 * 63);\n\t\td->geo.heads = 255;\n\t\td->geo.sectors = 63;\n\t} else {\n\t\td->flags &= ~DEVFL_EXT;\n\n\t\t \n\t\tssize = get_unaligned_le32(&id[60 << 1]);\n\n\t\t \n\t\td->geo.cylinders = get_unaligned_le16(&id[54 << 1]);\n\t\td->geo.heads = get_unaligned_le16(&id[55 << 1]);\n\t\td->geo.sectors = get_unaligned_le16(&id[56 << 1]);\n\t}\n\n\tata_ident_fixstring((u16 *) &id[10<<1], 10);\t \n\tata_ident_fixstring((u16 *) &id[23<<1], 4);\t \n\tata_ident_fixstring((u16 *) &id[27<<1], 20);\t \n\tmemcpy(d->ident, id, sizeof(d->ident));\n\n\tif (d->ssize != ssize)\n\t\tprintk(KERN_INFO\n\t\t\t\"aoe: %pm e%ld.%d v%04x has %llu sectors\\n\",\n\t\t\tt->addr,\n\t\t\td->aoemajor, d->aoeminor,\n\t\t\td->fw_ver, (long long)ssize);\n\td->ssize = ssize;\n\td->geo.start = 0;\n\tif (d->flags & (DEVFL_GDALLOC|DEVFL_NEWSIZE))\n\t\treturn;\n\tif (d->gd != NULL)\n\t\td->flags |= DEVFL_NEWSIZE;\n\telse\n\t\td->flags |= DEVFL_GDALLOC;\n\tqueue_work(aoe_wq, &d->work);\n}\n\nstatic void\ncalc_rttavg(struct aoedev *d, struct aoetgt *t, int rtt)\n{\n\tregister long n;\n\n\tn = rtt;\n\n\t \n\tn -= d->rttavg >> RTTSCALE;\n\td->rttavg += n;\n\tif (n < 0)\n\t\tn = -n;\n\tn -= d->rttdev >> RTTDSCALE;\n\td->rttdev += n;\n\n\tif (!t || t->maxout >= t->nframes)\n\t\treturn;\n\tif (t->maxout < t->ssthresh)\n\t\tt->maxout += 1;\n\telse if (t->nout == t->maxout && t->next_cwnd-- == 0) {\n\t\tt->maxout += 1;\n\t\tt->next_cwnd = t->maxout;\n\t}\n}\n\nstatic struct aoetgt *\ngettgt(struct aoedev *d, char *addr)\n{\n\tstruct aoetgt **t, **e;\n\n\tt = d->targets;\n\te = t + d->ntargets;\n\tfor (; t < e && *t; t++)\n\t\tif (memcmp((*t)->addr, addr, sizeof((*t)->addr)) == 0)\n\t\t\treturn *t;\n\treturn NULL;\n}\n\nstatic void\nbvcpy(struct sk_buff *skb, struct bio *bio, struct bvec_iter iter, long cnt)\n{\n\tint soff = 0;\n\tstruct bio_vec bv;\n\n\titer.bi_size = cnt;\n\n\t__bio_for_each_segment(bv, bio, iter, iter) {\n\t\tchar *p = bvec_kmap_local(&bv);\n\t\tskb_copy_bits(skb, soff, p, bv.bv_len);\n\t\tkunmap_local(p);\n\t\tsoff += bv.bv_len;\n\t}\n}\n\nvoid\naoe_end_request(struct aoedev *d, struct request *rq, int fastfail)\n{\n\tstruct bio *bio;\n\tint bok;\n\tstruct request_queue *q;\n\tblk_status_t err = BLK_STS_OK;\n\n\tq = d->blkq;\n\tif (rq == d->ip.rq)\n\t\td->ip.rq = NULL;\n\tdo {\n\t\tbio = rq->bio;\n\t\tbok = !fastfail && !bio->bi_status;\n\t\tif (!bok)\n\t\t\terr = BLK_STS_IOERR;\n\t} while (blk_update_request(rq, bok ? BLK_STS_OK : BLK_STS_IOERR, bio->bi_iter.bi_size));\n\n\t__blk_mq_end_request(rq, err);\n\n\t \n\t\tgoto noskb;\n\n\thout = (struct aoe_hdr *) skb_mac_header(f->skb);\n\tahout = (struct aoe_atahdr *) (hout+1);\n\n\thin = (struct aoe_hdr *) skb->data;\n\tskb_pull(skb, sizeof(*hin));\n\tahin = (struct aoe_atahdr *) skb->data;\n\tskb_pull(skb, sizeof(*ahin));\n\tif (ahin->cmdstat & 0xa9) {\t \n\t\tpr_err(\"aoe: ata error cmd=%2.2Xh stat=%2.2Xh from e%ld.%d\\n\",\n\t\t\tahout->cmdstat, ahin->cmdstat,\n\t\t\td->aoemajor, d->aoeminor);\nnoskb:\t\tif (buf)\n\t\t\tbuf->bio->bi_status = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\n\tn = ahout->scnt << 9;\n\tswitch (ahout->cmdstat) {\n\tcase ATA_CMD_PIO_READ:\n\tcase ATA_CMD_PIO_READ_EXT:\n\t\tif (skb->len < n) {\n\t\t\tpr_err(\"%s e%ld.%d.  skb->len=%d need=%ld\\n\",\n\t\t\t\t\"aoe: runt data size in read from\",\n\t\t\t\t(long) d->aoemajor, d->aoeminor,\n\t\t\t       skb->len, n);\n\t\t\tbuf->bio->bi_status = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\t\tif (n > f->iter.bi_size) {\n\t\t\tpr_err_ratelimited(\"%s e%ld.%d.  bytes=%ld need=%u\\n\",\n\t\t\t\t\"aoe: too-large data size in read from\",\n\t\t\t\t(long) d->aoemajor, d->aoeminor,\n\t\t\t\tn, f->iter.bi_size);\n\t\t\tbuf->bio->bi_status = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\t\tbvcpy(skb, f->buf->bio, f->iter, n);\n\t\tfallthrough;\n\tcase ATA_CMD_PIO_WRITE:\n\tcase ATA_CMD_PIO_WRITE_EXT:\n\t\tspin_lock_irq(&d->lock);\n\t\tifp = getif(t, skb->dev);\n\t\tif (ifp)\n\t\t\tifp->lost = 0;\n\t\tspin_unlock_irq(&d->lock);\n\t\tbreak;\n\tcase ATA_CMD_ID_ATA:\n\t\tif (skb->len < 512) {\n\t\t\tpr_info(\"%s e%ld.%d.  skb->len=%d need=512\\n\",\n\t\t\t\t\"aoe: runt data size in ataid from\",\n\t\t\t\t(long) d->aoemajor, d->aoeminor,\n\t\t\t\tskb->len);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb_linearize(skb))\n\t\t\tbreak;\n\t\tspin_lock_irq(&d->lock);\n\t\tataid_complete(d, t, skb->data);\n\t\tspin_unlock_irq(&d->lock);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"aoe: unrecognized ata command %2.2Xh for %d.%d\\n\",\n\t\t\tahout->cmdstat,\n\t\t\tbe16_to_cpu(get_unaligned(&hin->major)),\n\t\t\thin->minor);\n\t}\nout:\n\tspin_lock_irq(&d->lock);\n\tif (t->taint > 0\n\t&& --t->taint > 0\n\t&& t->nout_probes == 0) {\n\t\tcount_targets(d, &untainted);\n\t\tif (untainted > 0) {\n\t\t\tprobe(t);\n\t\t\tt->nout_probes++;\n\t\t}\n\t}\n\n\taoe_freetframe(f);\n\n\tif (buf && --buf->nframesout == 0 && buf->iter.bi_size == 0)\n\t\taoe_end_buf(d, buf);\n\n\tspin_unlock_irq(&d->lock);\n\taoedev_put(d);\n\tdev_kfree_skb(skb);\n}\n\n \nstatic int\nktio(int id)\n{\n\tstruct frame *f;\n\tstruct list_head *pos;\n\tint i;\n\tint actual_id;\n\n\tfor (i = 0; ; ++i) {\n\t\tif (i == MAXIOC)\n\t\t\treturn 1;\n\t\tif (list_empty(&iocq[id].head))\n\t\t\treturn 0;\n\t\tpos = iocq[id].head.next;\n\t\tlist_del(pos);\n\t\tf = list_entry(pos, struct frame, head);\n\t\tspin_unlock_irq(&iocq[id].lock);\n\t\tktiocomplete(f);\n\n\t\t \n\t\tactual_id = f->t->d->aoeminor % ncpus;\n\n\t\tif (!kts[actual_id].active) {\n\t\t\tBUG_ON(id != 0);\n\t\t\tmutex_lock(&ktio_spawn_lock);\n\t\t\tif (!kts[actual_id].active\n\t\t\t\t&& aoe_ktstart(&kts[actual_id]) == 0)\n\t\t\t\tkts[actual_id].active = 1;\n\t\t\tmutex_unlock(&ktio_spawn_lock);\n\t\t}\n\t\tspin_lock_irq(&iocq[id].lock);\n\t}\n}\n\nstatic int\nkthread(void *vp)\n{\n\tstruct ktstate *k;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint more;\n\n\tk = vp;\n\tcurrent->flags |= PF_NOFREEZE;\n\tset_user_nice(current, -10);\n\tcomplete(&k->rendez);\t \n\tdo {\n\t\tspin_lock_irq(k->lock);\n\t\tmore = k->fn(k->id);\n\t\tif (!more) {\n\t\t\tadd_wait_queue(k->waitq, &wait);\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tspin_unlock_irq(k->lock);\n\t\tif (!more) {\n\t\t\tschedule();\n\t\t\tremove_wait_queue(k->waitq, &wait);\n\t\t} else\n\t\t\tcond_resched();\n\t} while (!kthread_should_stop());\n\tcomplete(&k->rendez);\t \n\treturn 0;\n}\n\nvoid\naoe_ktstop(struct ktstate *k)\n{\n\tkthread_stop(k->task);\n\twait_for_completion(&k->rendez);\n}\n\nint\naoe_ktstart(struct ktstate *k)\n{\n\tstruct task_struct *task;\n\n\tinit_completion(&k->rendez);\n\ttask = kthread_run(kthread, k, \"%s\", k->name);\n\tif (task == NULL || IS_ERR(task))\n\t\treturn -ENOMEM;\n\tk->task = task;\n\twait_for_completion(&k->rendez);  \n\tinit_completion(&k->rendez);\t \n\treturn 0;\n}\n\n \nstatic void\nktcomplete(struct frame *f, struct sk_buff *skb)\n{\n\tint id;\n\tulong flags;\n\n\tf->r_skb = skb;\n\tid = f->t->d->aoeminor % ncpus;\n\tspin_lock_irqsave(&iocq[id].lock, flags);\n\tif (!kts[id].active) {\n\t\tspin_unlock_irqrestore(&iocq[id].lock, flags);\n\t\t \n\t\tid = 0;\n\t\tspin_lock_irqsave(&iocq[id].lock, flags);\n\t}\n\tlist_add_tail(&f->head, &iocq[id].head);\n\tspin_unlock_irqrestore(&iocq[id].lock, flags);\n\twake_up(&ktiowq[id]);\n}\n\nstruct sk_buff *\naoecmd_ata_rsp(struct sk_buff *skb)\n{\n\tstruct aoedev *d;\n\tstruct aoe_hdr *h;\n\tstruct frame *f;\n\tu32 n;\n\tulong flags;\n\tchar ebuf[128];\n\tu16 aoemajor;\n\n\th = (struct aoe_hdr *) skb->data;\n\taoemajor = be16_to_cpu(get_unaligned(&h->major));\n\td = aoedev_by_aoeaddr(aoemajor, h->minor, 0);\n\tif (d == NULL) {\n\t\tsnprintf(ebuf, sizeof ebuf, \"aoecmd_ata_rsp: ata response \"\n\t\t\t\"for unknown device %d.%d\\n\",\n\t\t\taoemajor, h->minor);\n\t\taoechr_error(ebuf);\n\t\treturn skb;\n\t}\n\n\tspin_lock_irqsave(&d->lock, flags);\n\n\tn = be32_to_cpu(get_unaligned(&h->tag));\n\tf = getframe(d, n);\n\tif (f) {\n\t\tcalc_rttavg(d, f->t, tsince_hr(f));\n\t\tf->t->nout--;\n\t\tif (f->flags & FFL_PROBE)\n\t\t\tf->t->nout_probes--;\n\t} else {\n\t\tf = getframe_deferred(d, n);\n\t\tif (f) {\n\t\t\tcalc_rttavg(d, NULL, tsince_hr(f));\n\t\t} else {\n\t\t\tcalc_rttavg(d, NULL, tsince(n));\n\t\t\tspin_unlock_irqrestore(&d->lock, flags);\n\t\t\taoedev_put(d);\n\t\t\tsnprintf(ebuf, sizeof(ebuf),\n\t\t\t\t \"%15s e%d.%d    tag=%08x@%08lx s=%pm d=%pm\\n\",\n\t\t\t\t \"unexpected rsp\",\n\t\t\t\t get_unaligned_be16(&h->major),\n\t\t\t\t h->minor,\n\t\t\t\t get_unaligned_be32(&h->tag),\n\t\t\t\t jiffies,\n\t\t\t\t h->src,\n\t\t\t\t h->dst);\n\t\t\taoechr_error(ebuf);\n\t\t\treturn skb;\n\t\t}\n\t}\n\taoecmd_work(d);\n\n\tspin_unlock_irqrestore(&d->lock, flags);\n\n\tktcomplete(f, skb);\n\n\t \n\treturn NULL;\n}\n\nvoid\naoecmd_cfg(ushort aoemajor, unsigned char aoeminor)\n{\n\tstruct sk_buff_head queue;\n\n\t__skb_queue_head_init(&queue);\n\taoecmd_cfg_pkts(aoemajor, aoeminor, &queue);\n\taoenet_xmit(&queue);\n}\n\nstruct sk_buff *\naoecmd_ata_id(struct aoedev *d)\n{\n\tstruct aoe_hdr *h;\n\tstruct aoe_atahdr *ah;\n\tstruct frame *f;\n\tstruct sk_buff *skb;\n\tstruct aoetgt *t;\n\n\tf = newframe(d);\n\tif (f == NULL)\n\t\treturn NULL;\n\n\tt = *d->tgt;\n\n\t \n\tskb = f->skb;\n\th = (struct aoe_hdr *) skb_mac_header(skb);\n\tah = (struct aoe_atahdr *) (h+1);\n\tskb_put(skb, sizeof *h + sizeof *ah);\n\tmemset(h, 0, skb->len);\n\tf->tag = aoehdr_atainit(d, t, h);\n\tfhash(f);\n\tt->nout++;\n\tf->waited = 0;\n\tf->waited_total = 0;\n\n\t \n\tah->scnt = 1;\n\tah->cmdstat = ATA_CMD_ID_ATA;\n\tah->lba3 = 0xa0;\n\n\tskb->dev = t->ifp->nd;\n\n\td->rttavg = RTTAVG_INIT;\n\td->rttdev = RTTDEV_INIT;\n\td->timer.function = rexmit_timer;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (skb)\n\t\tf->sent = ktime_get();\n\n\treturn skb;\n}\n\nstatic struct aoetgt **\ngrow_targets(struct aoedev *d)\n{\n\tulong oldn, newn;\n\tstruct aoetgt **tt;\n\n\toldn = d->ntargets;\n\tnewn = oldn * 2;\n\ttt = kcalloc(newn, sizeof(*d->targets), GFP_ATOMIC);\n\tif (!tt)\n\t\treturn NULL;\n\tmemmove(tt, d->targets, sizeof(*d->targets) * oldn);\n\td->tgt = tt + (d->tgt - d->targets);\n\tkfree(d->targets);\n\td->targets = tt;\n\td->ntargets = newn;\n\n\treturn &d->targets[oldn];\n}\n\nstatic struct aoetgt *\naddtgt(struct aoedev *d, char *addr, ulong nframes)\n{\n\tstruct aoetgt *t, **tt, **te;\n\n\ttt = d->targets;\n\tte = tt + d->ntargets;\n\tfor (; tt < te && *tt; tt++)\n\t\t;\n\n\tif (tt == te) {\n\t\ttt = grow_targets(d);\n\t\tif (!tt)\n\t\t\tgoto nomem;\n\t}\n\tt = kzalloc(sizeof(*t), GFP_ATOMIC);\n\tif (!t)\n\t\tgoto nomem;\n\tt->nframes = nframes;\n\tt->d = d;\n\tmemcpy(t->addr, addr, sizeof t->addr);\n\tt->ifp = t->ifs;\n\taoecmd_wreset(t);\n\tt->maxout = t->nframes / 2;\n\tINIT_LIST_HEAD(&t->ffree);\n\treturn *tt = t;\n\n nomem:\n\tpr_info(\"aoe: cannot allocate memory to add target\\n\");\n\treturn NULL;\n}\n\nstatic void\nsetdbcnt(struct aoedev *d)\n{\n\tstruct aoetgt **t, **e;\n\tint bcnt = 0;\n\n\tt = d->targets;\n\te = t + d->ntargets;\n\tfor (; t < e && *t; t++)\n\t\tif (bcnt == 0 || bcnt > (*t)->minbcnt)\n\t\t\tbcnt = (*t)->minbcnt;\n\tif (bcnt != d->maxbcnt) {\n\t\td->maxbcnt = bcnt;\n\t\tpr_info(\"aoe: e%ld.%d: setting %d byte data frames\\n\",\n\t\t\td->aoemajor, d->aoeminor, bcnt);\n\t}\n}\n\nstatic void\nsetifbcnt(struct aoetgt *t, struct net_device *nd, int bcnt)\n{\n\tstruct aoedev *d;\n\tstruct aoeif *p, *e;\n\tint minbcnt;\n\n\td = t->d;\n\tminbcnt = bcnt;\n\tp = t->ifs;\n\te = p + NAOEIFS;\n\tfor (; p < e; p++) {\n\t\tif (p->nd == NULL)\n\t\t\tbreak;\t\t \n\t\tif (p->nd == nd) {\n\t\t\tp->bcnt = bcnt;\t \n\t\t\tnd = NULL;\n\t\t} else if (minbcnt > p->bcnt)\n\t\t\tminbcnt = p->bcnt;  \n\t}\n\tif (nd) {\n\t\tif (p == e) {\n\t\t\tpr_err(\"aoe: device setifbcnt failure; too many interfaces.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdev_hold(nd);\n\t\tp->nd = nd;\n\t\tp->bcnt = bcnt;\n\t}\n\tt->minbcnt = minbcnt;\n\tsetdbcnt(d);\n}\n\nvoid\naoecmd_cfg_rsp(struct sk_buff *skb)\n{\n\tstruct aoedev *d;\n\tstruct aoe_hdr *h;\n\tstruct aoe_cfghdr *ch;\n\tstruct aoetgt *t;\n\tulong flags, aoemajor;\n\tstruct sk_buff *sl;\n\tstruct sk_buff_head queue;\n\tu16 n;\n\n\tsl = NULL;\n\th = (struct aoe_hdr *) skb_mac_header(skb);\n\tch = (struct aoe_cfghdr *) (h+1);\n\n\t \n\taoemajor = get_unaligned_be16(&h->major);\n\tif (aoemajor == 0xfff) {\n\t\tprintk(KERN_ERR \"aoe: Warning: shelf address is all ones.  \"\n\t\t\t\"Check shelf dip switches.\\n\");\n\t\treturn;\n\t}\n\tif (aoemajor == 0xffff) {\n\t\tpr_info(\"aoe: e%ld.%d: broadcast shelf number invalid\\n\",\n\t\t\taoemajor, (int) h->minor);\n\t\treturn;\n\t}\n\tif (h->minor == 0xff) {\n\t\tpr_info(\"aoe: e%ld.%d: broadcast slot number invalid\\n\",\n\t\t\taoemajor, (int) h->minor);\n\t\treturn;\n\t}\n\n\tn = be16_to_cpu(ch->bufcnt);\n\tif (n > aoe_maxout)\t \n\t\tn = aoe_maxout;\n\n\td = aoedev_by_aoeaddr(aoemajor, h->minor, 1);\n\tif (d == NULL) {\n\t\tpr_info(\"aoe: device allocation failure\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&d->lock, flags);\n\n\tt = gettgt(d, h->src);\n\tif (t) {\n\t\tt->nframes = n;\n\t\tif (n < t->maxout)\n\t\t\taoecmd_wreset(t);\n\t} else {\n\t\tt = addtgt(d, h->src, n);\n\t\tif (!t)\n\t\t\tgoto bail;\n\t}\n\tn = skb->dev->mtu;\n\tn -= sizeof(struct aoe_hdr) + sizeof(struct aoe_atahdr);\n\tn /= 512;\n\tif (n > ch->scnt)\n\t\tn = ch->scnt;\n\tn = n ? n * 512 : DEFAULTBCNT;\n\tsetifbcnt(t, skb->dev, n);\n\n\t \n\tif (d->nopen == 0) {\n\t\td->fw_ver = be16_to_cpu(ch->fwver);\n\t\tsl = aoecmd_ata_id(d);\n\t}\nbail:\n\tspin_unlock_irqrestore(&d->lock, flags);\n\taoedev_put(d);\n\tif (sl) {\n\t\t__skb_queue_head_init(&queue);\n\t\t__skb_queue_tail(&queue, sl);\n\t\taoenet_xmit(&queue);\n\t}\n}\n\nvoid\naoecmd_wreset(struct aoetgt *t)\n{\n\tt->maxout = 1;\n\tt->ssthresh = t->nframes / 2;\n\tt->next_cwnd = t->nframes;\n}\n\nvoid\naoecmd_cleanslate(struct aoedev *d)\n{\n\tstruct aoetgt **t, **te;\n\n\td->rttavg = RTTAVG_INIT;\n\td->rttdev = RTTDEV_INIT;\n\td->maxbcnt = 0;\n\n\tt = d->targets;\n\tte = t + d->ntargets;\n\tfor (; t < te && *t; t++)\n\t\taoecmd_wreset(*t);\n}\n\nvoid\naoe_failbuf(struct aoedev *d, struct buf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\tbuf->iter.bi_size = 0;\n\tbuf->bio->bi_status = BLK_STS_IOERR;\n\tif (buf->nframesout == 0)\n\t\taoe_end_buf(d, buf);\n}\n\nvoid\naoe_flush_iocq(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ncpus; i++) {\n\t\tif (kts[i].active)\n\t\t\taoe_flush_iocq_by_index(i);\n\t}\n}\n\nvoid\naoe_flush_iocq_by_index(int id)\n{\n\tstruct frame *f;\n\tstruct aoedev *d;\n\tLIST_HEAD(flist);\n\tstruct list_head *pos;\n\tstruct sk_buff *skb;\n\tulong flags;\n\n\tspin_lock_irqsave(&iocq[id].lock, flags);\n\tlist_splice_init(&iocq[id].head, &flist);\n\tspin_unlock_irqrestore(&iocq[id].lock, flags);\n\twhile (!list_empty(&flist)) {\n\t\tpos = flist.next;\n\t\tlist_del(pos);\n\t\tf = list_entry(pos, struct frame, head);\n\t\td = f->t->d;\n\t\tskb = f->r_skb;\n\t\tspin_lock_irqsave(&d->lock, flags);\n\t\tif (f->buf) {\n\t\t\tf->buf->nframesout--;\n\t\t\taoe_failbuf(d, f->buf);\n\t\t}\n\t\taoe_freetframe(f);\n\t\tspin_unlock_irqrestore(&d->lock, flags);\n\t\tdev_kfree_skb(skb);\n\t\taoedev_put(d);\n\t}\n}\n\nint __init\naoecmd_init(void)\n{\n\tvoid *p;\n\tint i;\n\tint ret;\n\n\t \n\tp = (void *) get_zeroed_page(GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tempty_page = virt_to_page(p);\n\n\tncpus = num_online_cpus();\n\n\tiocq = kcalloc(ncpus, sizeof(struct iocq_ktio), GFP_KERNEL);\n\tif (!iocq)\n\t\treturn -ENOMEM;\n\n\tkts = kcalloc(ncpus, sizeof(struct ktstate), GFP_KERNEL);\n\tif (!kts) {\n\t\tret = -ENOMEM;\n\t\tgoto kts_fail;\n\t}\n\n\tktiowq = kcalloc(ncpus, sizeof(wait_queue_head_t), GFP_KERNEL);\n\tif (!ktiowq) {\n\t\tret = -ENOMEM;\n\t\tgoto ktiowq_fail;\n\t}\n\n\tfor (i = 0; i < ncpus; i++) {\n\t\tINIT_LIST_HEAD(&iocq[i].head);\n\t\tspin_lock_init(&iocq[i].lock);\n\t\tinit_waitqueue_head(&ktiowq[i]);\n\t\tsnprintf(kts[i].name, sizeof(kts[i].name), \"aoe_ktio%d\", i);\n\t\tkts[i].fn = ktio;\n\t\tkts[i].waitq = &ktiowq[i];\n\t\tkts[i].lock = &iocq[i].lock;\n\t\tkts[i].id = i;\n\t\tkts[i].active = 0;\n\t}\n\tkts[0].active = 1;\n\tif (aoe_ktstart(&kts[0])) {\n\t\tret = -ENOMEM;\n\t\tgoto ktstart_fail;\n\t}\n\treturn 0;\n\nktstart_fail:\n\tkfree(ktiowq);\nktiowq_fail:\n\tkfree(kts);\nkts_fail:\n\tkfree(iocq);\n\n\treturn ret;\n}\n\nvoid\naoecmd_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ncpus; i++)\n\t\tif (kts[i].active)\n\t\t\taoe_ktstop(&kts[i]);\n\n\taoe_flush_iocq();\n\n\t \n\tkfree(iocq);\n\tkfree(kts);\n\tkfree(ktiowq);\n\n\tfree_page((unsigned long) page_address(empty_page));\n\tempty_page = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}