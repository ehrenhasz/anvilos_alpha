{
  "module_name": "aoedev.c",
  "hash_id": "a7d1577151e026df28a3266896eeebfa7b8ac46052cb599625ca07a88e1ecf06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/aoe/aoedev.c",
  "human_readable_source": " \n \n\n#include <linux/hdreg.h>\n#include <linux/blk-mq.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/kdev_t.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include \"aoe.h\"\n\nstatic void freetgt(struct aoedev *d, struct aoetgt *t);\nstatic void skbpoolfree(struct aoedev *d);\n\nstatic int aoe_dyndevs = 1;\nmodule_param(aoe_dyndevs, int, 0644);\nMODULE_PARM_DESC(aoe_dyndevs, \"Use dynamic minor numbers for devices.\");\n\nstatic struct aoedev *devlist;\nstatic DEFINE_SPINLOCK(devlist_lock);\n\n \n#define N_DEVS ((1U<<MINORBITS)/AOE_PARTITIONS)\n\nstatic DEFINE_SPINLOCK(used_minors_lock);\nstatic DECLARE_BITMAP(used_minors, N_DEVS);\n\nstatic int\nminor_get_dyn(ulong *sysminor)\n{\n\tulong flags;\n\tulong n;\n\tint error = 0;\n\n\tspin_lock_irqsave(&used_minors_lock, flags);\n\tn = find_first_zero_bit(used_minors, N_DEVS);\n\tif (n < N_DEVS)\n\t\tset_bit(n, used_minors);\n\telse\n\t\terror = -1;\n\tspin_unlock_irqrestore(&used_minors_lock, flags);\n\n\t*sysminor = n * AOE_PARTITIONS;\n\treturn error;\n}\n\nstatic int\nminor_get_static(ulong *sysminor, ulong aoemaj, int aoemin)\n{\n\tulong flags;\n\tulong n;\n\tint error = 0;\n\tenum {\n\t\t \n\t\tNPERSHELF = 16,\n\t};\n\n\tif (aoemin >= NPERSHELF) {\n\t\tpr_err(\"aoe: %s %d slots per shelf\\n\",\n\t\t\t\"static minor device numbers support only\",\n\t\t\tNPERSHELF);\n\t\terror = -1;\n\t\tgoto out;\n\t}\n\n\tn = aoemaj * NPERSHELF + aoemin;\n\tif (n >= N_DEVS) {\n\t\tpr_err(\"aoe: %s with e%ld.%d\\n\",\n\t\t\t\"cannot use static minor device numbers\",\n\t\t\taoemaj, aoemin);\n\t\terror = -1;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&used_minors_lock, flags);\n\tif (test_bit(n, used_minors)) {\n\t\tpr_err(\"aoe: %s %lu\\n\",\n\t\t\t\"existing device already has static minor number\",\n\t\t\tn);\n\t\terror = -1;\n\t} else\n\t\tset_bit(n, used_minors);\n\tspin_unlock_irqrestore(&used_minors_lock, flags);\n\t*sysminor = n * AOE_PARTITIONS;\nout:\n\treturn error;\n}\n\nstatic int\nminor_get(ulong *sysminor, ulong aoemaj, int aoemin)\n{\n\tif (aoe_dyndevs)\n\t\treturn minor_get_dyn(sysminor);\n\telse\n\t\treturn minor_get_static(sysminor, aoemaj, aoemin);\n}\n\nstatic void\nminor_free(ulong minor)\n{\n\tulong flags;\n\n\tminor /= AOE_PARTITIONS;\n\tBUG_ON(minor >= N_DEVS);\n\n\tspin_lock_irqsave(&used_minors_lock, flags);\n\tBUG_ON(!test_bit(minor, used_minors));\n\tclear_bit(minor, used_minors);\n\tspin_unlock_irqrestore(&used_minors_lock, flags);\n}\n\n \n\nvoid\naoedev_put(struct aoedev *d)\n{\n\tulong flags;\n\n\tspin_lock_irqsave(&devlist_lock, flags);\n\td->ref--;\n\tspin_unlock_irqrestore(&devlist_lock, flags);\n}\n\nstatic void\ndummy_timer(struct timer_list *t)\n{\n\tstruct aoedev *d;\n\n\td = from_timer(d, t, timer);\n\tif (d->flags & DEVFL_TKILL)\n\t\treturn;\n\td->timer.expires = jiffies + HZ;\n\tadd_timer(&d->timer);\n}\n\nstatic void\naoe_failip(struct aoedev *d)\n{\n\tstruct request *rq;\n\tstruct aoe_req *req;\n\tstruct bio *bio;\n\n\taoe_failbuf(d, d->ip.buf);\n\trq = d->ip.rq;\n\tif (rq == NULL)\n\t\treturn;\n\n\treq = blk_mq_rq_to_pdu(rq);\n\twhile ((bio = d->ip.nxbio)) {\n\t\tbio->bi_status = BLK_STS_IOERR;\n\t\td->ip.nxbio = bio->bi_next;\n\t\treq->nr_bios--;\n\t}\n\n\tif (!req->nr_bios)\n\t\taoe_end_request(d, rq, 0);\n}\n\nstatic void\ndowndev_frame(struct list_head *pos)\n{\n\tstruct frame *f;\n\n\tf = list_entry(pos, struct frame, head);\n\tlist_del(pos);\n\tif (f->buf) {\n\t\tf->buf->nframesout--;\n\t\taoe_failbuf(f->t->d, f->buf);\n\t}\n\taoe_freetframe(f);\n}\n\nvoid\naoedev_downdev(struct aoedev *d)\n{\n\tstruct aoetgt *t, **tt, **te;\n\tstruct list_head *head, *pos, *nx;\n\tint i;\n\n\td->flags &= ~DEVFL_UP;\n\n\t \n\tfor (i = 0; i < NFACTIVE; i++) {\n\t\thead = &d->factive[i];\n\t\tlist_for_each_safe(pos, nx, head)\n\t\t\tdowndev_frame(pos);\n\t}\n\thead = &d->rexmitq;\n\tlist_for_each_safe(pos, nx, head)\n\t\tdowndev_frame(pos);\n\n\t \n\ttt = d->targets;\n\tte = tt + d->ntargets;\n\tfor (; tt < te && (t = *tt); tt++) {\n\t\taoecmd_wreset(t);\n\t\tt->nout = 0;\n\t}\n\n\t \n\taoe_failip(d);\n\n\t \n\tif (d->blkq) {\n\t\t \n\t\tblk_mq_freeze_queue(d->blkq);\n\t\tblk_mq_quiesce_queue(d->blkq);\n\t\tblk_mq_unquiesce_queue(d->blkq);\n\t\tblk_mq_unfreeze_queue(d->blkq);\n\t}\n\n\tif (d->gd)\n\t\tset_capacity(d->gd, 0);\n}\n\n \nstatic int\nuser_req(char *s, size_t slen, struct aoedev *d)\n{\n\tconst char *p;\n\tsize_t lim;\n\n\tif (!d->gd)\n\t\treturn 0;\n\tp = kbasename(d->gd->disk_name);\n\tlim = sizeof(d->gd->disk_name);\n\tlim -= p - d->gd->disk_name;\n\tif (slen < lim)\n\t\tlim = slen;\n\n\treturn !strncmp(s, p, lim);\n}\n\nstatic void\nfreedev(struct aoedev *d)\n{\n\tstruct aoetgt **t, **e;\n\tint freeing = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tif (d->flags & DEVFL_TKILL\n\t&& !(d->flags & DEVFL_FREEING)) {\n\t\td->flags |= DEVFL_FREEING;\n\t\tfreeing = 1;\n\t}\n\tspin_unlock_irqrestore(&d->lock, flags);\n\tif (!freeing)\n\t\treturn;\n\n\tdel_timer_sync(&d->timer);\n\tif (d->gd) {\n\t\taoedisk_rm_debugfs(d);\n\t\tdel_gendisk(d->gd);\n\t\tput_disk(d->gd);\n\t\tblk_mq_free_tag_set(&d->tag_set);\n\t}\n\tt = d->targets;\n\te = t + d->ntargets;\n\tfor (; t < e && *t; t++)\n\t\tfreetgt(d, *t);\n\n\tmempool_destroy(d->bufpool);\n\tskbpoolfree(d);\n\tminor_free(d->sysminor);\n\n\tspin_lock_irqsave(&d->lock, flags);\n\td->flags |= DEVFL_FREED;\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nenum flush_parms {\n\tNOT_EXITING = 0,\n\tEXITING = 1,\n};\n\nstatic int\nflush(const char __user *str, size_t cnt, int exiting)\n{\n\tulong flags;\n\tstruct aoedev *d, **dd;\n\tchar buf[16];\n\tint all = 0;\n\tint specified = 0;\t \n\tunsigned int skipflags;\n\n\tskipflags = DEVFL_GDALLOC | DEVFL_NEWSIZE | DEVFL_TKILL;\n\n\tif (!exiting && cnt >= 3) {\n\t\tif (cnt > sizeof buf)\n\t\t\tcnt = sizeof buf;\n\t\tif (copy_from_user(buf, str, cnt))\n\t\t\treturn -EFAULT;\n\t\tall = !strncmp(buf, \"all\", 3);\n\t\tif (!all)\n\t\t\tspecified = 1;\n\t}\n\n\tflush_workqueue(aoe_wq);\n\t \nrestart1:\n\tspin_lock_irqsave(&devlist_lock, flags);\n\tfor (d = devlist; d; d = d->next) {\n\t\tspin_lock(&d->lock);\n\t\tif (d->flags & DEVFL_TKILL)\n\t\t\tgoto cont;\n\n\t\tif (exiting) {\n\t\t\t \n\t\t} else if (specified) {\n\t\t\tif (!user_req(buf, cnt, d))\n\t\t\t\tgoto cont;\n\t\t} else if ((!all && (d->flags & DEVFL_UP))\n\t\t|| d->flags & skipflags\n\t\t|| d->nopen\n\t\t|| d->ref)\n\t\t\tgoto cont;\n\n\t\tspin_unlock(&d->lock);\n\t\tspin_unlock_irqrestore(&devlist_lock, flags);\n\t\taoedev_downdev(d);\n\t\td->flags |= DEVFL_TKILL;\n\t\tgoto restart1;\ncont:\n\t\tspin_unlock(&d->lock);\n\t}\n\tspin_unlock_irqrestore(&devlist_lock, flags);\n\n\t \nrestart2:\n\tspin_lock_irqsave(&devlist_lock, flags);\n\tfor (d = devlist; d; d = d->next) {\n\t\tspin_lock(&d->lock);\n\t\tif (d->flags & DEVFL_TKILL\n\t\t&& !(d->flags & DEVFL_FREEING)) {\n\t\t\tspin_unlock(&d->lock);\n\t\t\tspin_unlock_irqrestore(&devlist_lock, flags);\n\t\t\tfreedev(d);\n\t\t\tgoto restart2;\n\t\t}\n\t\tspin_unlock(&d->lock);\n\t}\n\n\t \n\tfor (dd = &devlist, d = *dd; d; d = *dd) {\n\t\tstruct aoedev *doomed = NULL;\n\n\t\tspin_lock(&d->lock);\n\t\tif (d->flags & DEVFL_FREED) {\n\t\t\t*dd = d->next;\n\t\t\tdoomed = d;\n\t\t} else {\n\t\t\tdd = &d->next;\n\t\t}\n\t\tspin_unlock(&d->lock);\n\t\tif (doomed)\n\t\t\tkfree(doomed->targets);\n\t\tkfree(doomed);\n\t}\n\tspin_unlock_irqrestore(&devlist_lock, flags);\n\n\treturn 0;\n}\n\nint\naoedev_flush(const char __user *str, size_t cnt)\n{\n\treturn flush(str, cnt, NOT_EXITING);\n}\n\n \nstatic void\nskbfree(struct sk_buff *skb)\n{\n\tenum { Sms = 250, Tms = 30 * 1000};\n\tint i = Tms / Sms;\n\n\tif (skb == NULL)\n\t\treturn;\n\twhile (atomic_read(&skb_shinfo(skb)->dataref) != 1 && i-- > 0)\n\t\tmsleep(Sms);\n\tif (i < 0) {\n\t\tprintk(KERN_ERR\n\t\t\t\"aoe: %s holds ref: %s\\n\",\n\t\t\tskb->dev ? skb->dev->name : \"netif\",\n\t\t\t\"cannot free skb -- memory leaked.\");\n\t\treturn;\n\t}\n\tskb->truesize -= skb->data_len;\n\tskb_shinfo(skb)->nr_frags = skb->data_len = 0;\n\tskb_trim(skb, 0);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nskbpoolfree(struct aoedev *d)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&d->skbpool, skb, tmp)\n\t\tskbfree(skb);\n\n\t__skb_queue_head_init(&d->skbpool);\n}\n\n \nstruct aoedev *\naoedev_by_aoeaddr(ulong maj, int min, int do_alloc)\n{\n\tstruct aoedev *d;\n\tint i;\n\tulong flags;\n\tulong sysminor = 0;\n\n\tspin_lock_irqsave(&devlist_lock, flags);\n\n\tfor (d=devlist; d; d=d->next)\n\t\tif (d->aoemajor == maj && d->aoeminor == min) {\n\t\t\tspin_lock(&d->lock);\n\t\t\tif (d->flags & DEVFL_TKILL) {\n\t\t\t\tspin_unlock(&d->lock);\n\t\t\t\td = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td->ref++;\n\t\t\tspin_unlock(&d->lock);\n\t\t\tbreak;\n\t\t}\n\tif (d || !do_alloc || minor_get(&sysminor, maj, min) < 0)\n\t\tgoto out;\n\td = kcalloc(1, sizeof *d, GFP_ATOMIC);\n\tif (!d)\n\t\tgoto out;\n\td->targets = kcalloc(NTARGETS, sizeof(*d->targets), GFP_ATOMIC);\n\tif (!d->targets) {\n\t\tkfree(d);\n\t\td = NULL;\n\t\tgoto out;\n\t}\n\td->ntargets = NTARGETS;\n\tINIT_WORK(&d->work, aoecmd_sleepwork);\n\tspin_lock_init(&d->lock);\n\tINIT_LIST_HEAD(&d->rq_list);\n\tskb_queue_head_init(&d->skbpool);\n\ttimer_setup(&d->timer, dummy_timer, 0);\n\td->timer.expires = jiffies + HZ;\n\tadd_timer(&d->timer);\n\td->bufpool = NULL;\t \n\td->tgt = d->targets;\n\td->ref = 1;\n\tfor (i = 0; i < NFACTIVE; i++)\n\t\tINIT_LIST_HEAD(&d->factive[i]);\n\tINIT_LIST_HEAD(&d->rexmitq);\n\td->sysminor = sysminor;\n\td->aoemajor = maj;\n\td->aoeminor = min;\n\td->rttavg = RTTAVG_INIT;\n\td->rttdev = RTTDEV_INIT;\n\td->next = devlist;\n\tdevlist = d;\n out:\n\tspin_unlock_irqrestore(&devlist_lock, flags);\n\treturn d;\n}\n\nstatic void\nfreetgt(struct aoedev *d, struct aoetgt *t)\n{\n\tstruct frame *f;\n\tstruct list_head *pos, *nx, *head;\n\tstruct aoeif *ifp;\n\n\tfor (ifp = t->ifs; ifp < &t->ifs[NAOEIFS]; ++ifp) {\n\t\tif (!ifp->nd)\n\t\t\tbreak;\n\t\tdev_put(ifp->nd);\n\t}\n\n\thead = &t->ffree;\n\tlist_for_each_safe(pos, nx, head) {\n\t\tlist_del(pos);\n\t\tf = list_entry(pos, struct frame, head);\n\t\tskbfree(f->skb);\n\t\tkfree(f);\n\t}\n\tkfree(t);\n}\n\nvoid\naoedev_exit(void)\n{\n\tflush_workqueue(aoe_wq);\n\tflush(NULL, 0, EXITING);\n}\n\nint __init\naoedev_init(void)\n{\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}