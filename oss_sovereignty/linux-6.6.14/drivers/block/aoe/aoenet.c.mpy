{
  "module_name": "aoenet.c",
  "hash_id": "bbcaf35434c9525f71c7fff0cd351211e1fc5b4419fc710861345a2705b07ad3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/aoe/aoenet.c",
  "human_readable_source": " \n \n\n#include <linux/gfp.h>\n#include <linux/hdreg.h>\n#include <linux/blkdev.h>\n#include <linux/netdevice.h>\n#include <linux/moduleparam.h>\n#include <net/net_namespace.h>\n#include <asm/unaligned.h>\n#include \"aoe.h\"\n\n#define NECODES 5\n\nstatic char *aoe_errlist[] =\n{\n\t\"no such error\",\n\t\"unrecognized command code\",\n\t\"bad argument parameter\",\n\t\"device unavailable\",\n\t\"config string present\",\n\t\"unsupported version\"\n};\n\nenum {\n\tIFLISTSZ = 1024,\n};\n\nstatic char aoe_iflist[IFLISTSZ];\nmodule_param_string(aoe_iflist, aoe_iflist, IFLISTSZ, 0600);\nMODULE_PARM_DESC(aoe_iflist, \"aoe_iflist=dev1[,dev2...]\");\n\nstatic wait_queue_head_t txwq;\nstatic struct ktstate kts;\n\n#ifndef MODULE\nstatic int __init aoe_iflist_setup(char *str)\n{\n\tstrncpy(aoe_iflist, str, IFLISTSZ);\n\taoe_iflist[IFLISTSZ - 1] = '\\0';\n\treturn 1;\n}\n\n__setup(\"aoe_iflist=\", aoe_iflist_setup);\n#endif\n\nstatic spinlock_t txlock;\nstatic struct sk_buff_head skbtxq;\n\n \nstatic int\ntx(int id) __must_hold(&txlock)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *ifp;\n\n\twhile ((skb = skb_dequeue(&skbtxq))) {\n\t\tspin_unlock_irq(&txlock);\n\t\tifp = skb->dev;\n\t\tif (dev_queue_xmit(skb) == NET_XMIT_DROP && net_ratelimit())\n\t\t\tpr_warn(\"aoe: packet could not be sent on %s.  %s\\n\",\n\t\t\t\tifp ? ifp->name : \"netif\",\n\t\t\t\t\"consider increasing tx_queue_len\");\n\t\tspin_lock_irq(&txlock);\n\t}\n\treturn 0;\n}\n\nint\nis_aoe_netif(struct net_device *ifp)\n{\n\tregister char *p, *q;\n\tregister int len;\n\n\tif (aoe_iflist[0] == '\\0')\n\t\treturn 1;\n\n\tp = aoe_iflist + strspn(aoe_iflist, WHITESPACE);\n\tfor (; *p; p = q + strspn(q, WHITESPACE)) {\n\t\tq = p + strcspn(p, WHITESPACE);\n\t\tif (q != p)\n\t\t\tlen = q - p;\n\t\telse\n\t\t\tlen = strlen(p);  \n\n\t\tif (strlen(ifp->name) == len && !strncmp(ifp->name, p, len))\n\t\t\treturn 1;\n\t\tif (q == p)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint\nset_aoe_iflist(const char __user *user_str, size_t size)\n{\n\tif (size >= IFLISTSZ)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(aoe_iflist, user_str, size)) {\n\t\tprintk(KERN_INFO \"aoe: copy from user failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\taoe_iflist[size] = 0x00;\n\treturn 0;\n}\n\nvoid\naoenet_xmit(struct sk_buff_head *queue)\n{\n\tstruct sk_buff *skb, *tmp;\n\tulong flags;\n\n\tskb_queue_walk_safe(queue, skb, tmp) {\n\t\t__skb_unlink(skb, queue);\n\t\tspin_lock_irqsave(&txlock, flags);\n\t\tskb_queue_tail(&skbtxq, skb);\n\t\tspin_unlock_irqrestore(&txlock, flags);\n\t\twake_up(&txwq);\n\t}\n}\n\n \nstatic int\naoenet_rcv(struct sk_buff *skb, struct net_device *ifp, struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct aoe_hdr *h;\n\tstruct aoe_atahdr *ah;\n\tu32 n;\n\tint sn;\n\n\tif (dev_net(ifp) != &init_net)\n\t\tgoto exit;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn 0;\n\tif (!is_aoe_netif(ifp))\n\t\tgoto exit;\n\tskb_push(skb, ETH_HLEN);\t \n\tsn = sizeof(*h) + sizeof(*ah);\n\tif (skb->len >= sn) {\n\t\tsn -= skb_headlen(skb);\n\t\tif (sn > 0 && !__pskb_pull_tail(skb, sn))\n\t\t\tgoto exit;\n\t}\n\th = (struct aoe_hdr *) skb->data;\n\tn = get_unaligned_be32(&h->tag);\n\tif ((h->verfl & AOEFL_RSP) == 0 || (n & 1<<31))\n\t\tgoto exit;\n\n\tif (h->verfl & AOEFL_ERR) {\n\t\tn = h->err;\n\t\tif (n > NECODES)\n\t\t\tn = 0;\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s%d.%d@%s; ecode=%d '%s'\\n\",\n\t\t\t\t\"aoe: error packet from \",\n\t\t\t\tget_unaligned_be16(&h->major),\n\t\t\t\th->minor, skb->dev->name,\n\t\t\t\th->err, aoe_errlist[n]);\n\t\tgoto exit;\n\t}\n\n\tswitch (h->cmd) {\n\tcase AOECMD_ATA:\n\t\t \n\t\tskb = aoecmd_ata_rsp(skb);\n\t\tbreak;\n\tcase AOECMD_CFG:\n\t\taoecmd_cfg_rsp(skb);\n\t\tbreak;\n\tdefault:\n\t\tif (h->cmd >= AOECMD_VEND_MIN)\n\t\t\tbreak;\t \n\t\tpr_info(\"aoe: unknown AoE command type 0x%02x\\n\", h->cmd);\n\t\tbreak;\n\t}\n\n\tif (!skb)\n\t\treturn 0;\nexit:\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct packet_type aoe_pt __read_mostly = {\n\t.type = __constant_htons(ETH_P_AOE),\n\t.func = aoenet_rcv,\n};\n\nint __init\naoenet_init(void)\n{\n\tskb_queue_head_init(&skbtxq);\n\tinit_waitqueue_head(&txwq);\n\tspin_lock_init(&txlock);\n\tkts.lock = &txlock;\n\tkts.fn = tx;\n\tkts.waitq = &txwq;\n\tkts.id = 0;\n\tsnprintf(kts.name, sizeof(kts.name), \"aoe_tx%d\", kts.id);\n\tif (aoe_ktstart(&kts))\n\t\treturn -EAGAIN;\n\tdev_add_pack(&aoe_pt);\n\treturn 0;\n}\n\nvoid\naoenet_exit(void)\n{\n\taoe_ktstop(&kts);\n\tskb_queue_purge(&skbtxq);\n\tdev_remove_pack(&aoe_pt);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}