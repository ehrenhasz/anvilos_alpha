{
  "module_name": "main.c",
  "hash_id": "11ef79bafb2875ce5df195f97d09e676d8dfb2ddf88038522ff1d9c521c6f736",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/null_blk/main.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include \"null_blk.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt)\t\"null_blk: \" fmt\n\n#define FREE_BATCH\t\t16\n\n#define TICKS_PER_SEC\t\t50ULL\n#define TIMER_INTERVAL\t\t(NSEC_PER_SEC / TICKS_PER_SEC)\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\nstatic DECLARE_FAULT_ATTR(null_timeout_attr);\nstatic DECLARE_FAULT_ATTR(null_requeue_attr);\nstatic DECLARE_FAULT_ATTR(null_init_hctx_attr);\n#endif\n\nstatic inline u64 mb_per_tick(int mbps)\n{\n\treturn (1 << 20) / TICKS_PER_SEC * ((u64) mbps);\n}\n\n \nenum nullb_device_flags {\n\tNULLB_DEV_FL_CONFIGURED\t= 0,\n\tNULLB_DEV_FL_UP\t\t= 1,\n\tNULLB_DEV_FL_THROTTLED\t= 2,\n\tNULLB_DEV_FL_CACHE\t= 3,\n};\n\n#define MAP_SZ\t\t((PAGE_SIZE >> SECTOR_SHIFT) + 2)\n \nstruct nullb_page {\n\tstruct page *page;\n\tDECLARE_BITMAP(bitmap, MAP_SZ);\n};\n#define NULLB_PAGE_LOCK (MAP_SZ - 1)\n#define NULLB_PAGE_FREE (MAP_SZ - 2)\n\nstatic LIST_HEAD(nullb_list);\nstatic struct mutex lock;\nstatic int null_major;\nstatic DEFINE_IDA(nullb_indexes);\nstatic struct blk_mq_tag_set tag_set;\n\nenum {\n\tNULL_IRQ_NONE\t\t= 0,\n\tNULL_IRQ_SOFTIRQ\t= 1,\n\tNULL_IRQ_TIMER\t\t= 2,\n};\n\nstatic bool g_virt_boundary = false;\nmodule_param_named(virt_boundary, g_virt_boundary, bool, 0444);\nMODULE_PARM_DESC(virt_boundary, \"Require a virtual boundary for the device. Default: False\");\n\nstatic int g_no_sched;\nmodule_param_named(no_sched, g_no_sched, int, 0444);\nMODULE_PARM_DESC(no_sched, \"No io scheduler\");\n\nstatic int g_submit_queues = 1;\nmodule_param_named(submit_queues, g_submit_queues, int, 0444);\nMODULE_PARM_DESC(submit_queues, \"Number of submission queues\");\n\nstatic int g_poll_queues = 1;\nmodule_param_named(poll_queues, g_poll_queues, int, 0444);\nMODULE_PARM_DESC(poll_queues, \"Number of IOPOLL submission queues\");\n\nstatic int g_home_node = NUMA_NO_NODE;\nmodule_param_named(home_node, g_home_node, int, 0444);\nMODULE_PARM_DESC(home_node, \"Home node for the device\");\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n \nstatic char g_timeout_str[80];\nmodule_param_string(timeout, g_timeout_str, sizeof(g_timeout_str), 0444);\nMODULE_PARM_DESC(timeout, \"Fault injection. timeout=<interval>,<probability>,<space>,<times>\");\n\nstatic char g_requeue_str[80];\nmodule_param_string(requeue, g_requeue_str, sizeof(g_requeue_str), 0444);\nMODULE_PARM_DESC(requeue, \"Fault injection. requeue=<interval>,<probability>,<space>,<times>\");\n\nstatic char g_init_hctx_str[80];\nmodule_param_string(init_hctx, g_init_hctx_str, sizeof(g_init_hctx_str), 0444);\nMODULE_PARM_DESC(init_hctx, \"Fault injection to fail hctx init. init_hctx=<interval>,<probability>,<space>,<times>\");\n#endif\n\nstatic int g_queue_mode = NULL_Q_MQ;\n\nstatic int null_param_store_val(const char *str, int *val, int min, int max)\n{\n\tint ret, new_val;\n\n\tret = kstrtoint(str, 10, &new_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (new_val < min || new_val > max)\n\t\treturn -EINVAL;\n\n\t*val = new_val;\n\treturn 0;\n}\n\nstatic int null_set_queue_mode(const char *str, const struct kernel_param *kp)\n{\n\treturn null_param_store_val(str, &g_queue_mode, NULL_Q_BIO, NULL_Q_MQ);\n}\n\nstatic const struct kernel_param_ops null_queue_mode_param_ops = {\n\t.set\t= null_set_queue_mode,\n\t.get\t= param_get_int,\n};\n\ndevice_param_cb(queue_mode, &null_queue_mode_param_ops, &g_queue_mode, 0444);\nMODULE_PARM_DESC(queue_mode, \"Block interface to use (0=bio,1=rq,2=multiqueue)\");\n\nstatic int g_gb = 250;\nmodule_param_named(gb, g_gb, int, 0444);\nMODULE_PARM_DESC(gb, \"Size in GB\");\n\nstatic int g_bs = 512;\nmodule_param_named(bs, g_bs, int, 0444);\nMODULE_PARM_DESC(bs, \"Block size (in bytes)\");\n\nstatic int g_max_sectors;\nmodule_param_named(max_sectors, g_max_sectors, int, 0444);\nMODULE_PARM_DESC(max_sectors, \"Maximum size of a command (in 512B sectors)\");\n\nstatic unsigned int nr_devices = 1;\nmodule_param(nr_devices, uint, 0444);\nMODULE_PARM_DESC(nr_devices, \"Number of devices to register\");\n\nstatic bool g_blocking;\nmodule_param_named(blocking, g_blocking, bool, 0444);\nMODULE_PARM_DESC(blocking, \"Register as a blocking blk-mq driver device\");\n\nstatic bool shared_tags;\nmodule_param(shared_tags, bool, 0444);\nMODULE_PARM_DESC(shared_tags, \"Share tag set between devices for blk-mq\");\n\nstatic bool g_shared_tag_bitmap;\nmodule_param_named(shared_tag_bitmap, g_shared_tag_bitmap, bool, 0444);\nMODULE_PARM_DESC(shared_tag_bitmap, \"Use shared tag bitmap for all submission queues for blk-mq\");\n\nstatic int g_irqmode = NULL_IRQ_SOFTIRQ;\n\nstatic int null_set_irqmode(const char *str, const struct kernel_param *kp)\n{\n\treturn null_param_store_val(str, &g_irqmode, NULL_IRQ_NONE,\n\t\t\t\t\tNULL_IRQ_TIMER);\n}\n\nstatic const struct kernel_param_ops null_irqmode_param_ops = {\n\t.set\t= null_set_irqmode,\n\t.get\t= param_get_int,\n};\n\ndevice_param_cb(irqmode, &null_irqmode_param_ops, &g_irqmode, 0444);\nMODULE_PARM_DESC(irqmode, \"IRQ completion handler. 0-none, 1-softirq, 2-timer\");\n\nstatic unsigned long g_completion_nsec = 10000;\nmodule_param_named(completion_nsec, g_completion_nsec, ulong, 0444);\nMODULE_PARM_DESC(completion_nsec, \"Time in ns to complete a request in hardware. Default: 10,000ns\");\n\nstatic int g_hw_queue_depth = 64;\nmodule_param_named(hw_queue_depth, g_hw_queue_depth, int, 0444);\nMODULE_PARM_DESC(hw_queue_depth, \"Queue depth for each hardware queue. Default: 64\");\n\nstatic bool g_use_per_node_hctx;\nmodule_param_named(use_per_node_hctx, g_use_per_node_hctx, bool, 0444);\nMODULE_PARM_DESC(use_per_node_hctx, \"Use per-node allocation for hardware context queues. Default: false\");\n\nstatic bool g_memory_backed;\nmodule_param_named(memory_backed, g_memory_backed, bool, 0444);\nMODULE_PARM_DESC(memory_backed, \"Create a memory-backed block device. Default: false\");\n\nstatic bool g_discard;\nmodule_param_named(discard, g_discard, bool, 0444);\nMODULE_PARM_DESC(discard, \"Support discard operations (requires memory-backed null_blk device). Default: false\");\n\nstatic unsigned long g_cache_size;\nmodule_param_named(cache_size, g_cache_size, ulong, 0444);\nMODULE_PARM_DESC(mbps, \"Cache size in MiB for memory-backed device. Default: 0 (none)\");\n\nstatic unsigned int g_mbps;\nmodule_param_named(mbps, g_mbps, uint, 0444);\nMODULE_PARM_DESC(mbps, \"Limit maximum bandwidth (in MiB/s). Default: 0 (no limit)\");\n\nstatic bool g_zoned;\nmodule_param_named(zoned, g_zoned, bool, S_IRUGO);\nMODULE_PARM_DESC(zoned, \"Make device as a host-managed zoned block device. Default: false\");\n\nstatic unsigned long g_zone_size = 256;\nmodule_param_named(zone_size, g_zone_size, ulong, S_IRUGO);\nMODULE_PARM_DESC(zone_size, \"Zone size in MB when block device is zoned. Must be power-of-two: Default: 256\");\n\nstatic unsigned long g_zone_capacity;\nmodule_param_named(zone_capacity, g_zone_capacity, ulong, 0444);\nMODULE_PARM_DESC(zone_capacity, \"Zone capacity in MB when block device is zoned. Can be less than or equal to zone size. Default: Zone size\");\n\nstatic unsigned int g_zone_nr_conv;\nmodule_param_named(zone_nr_conv, g_zone_nr_conv, uint, 0444);\nMODULE_PARM_DESC(zone_nr_conv, \"Number of conventional zones when block device is zoned. Default: 0\");\n\nstatic unsigned int g_zone_max_open;\nmodule_param_named(zone_max_open, g_zone_max_open, uint, 0444);\nMODULE_PARM_DESC(zone_max_open, \"Maximum number of open zones when block device is zoned. Default: 0 (no limit)\");\n\nstatic unsigned int g_zone_max_active;\nmodule_param_named(zone_max_active, g_zone_max_active, uint, 0444);\nMODULE_PARM_DESC(zone_max_active, \"Maximum number of active zones when block device is zoned. Default: 0 (no limit)\");\n\nstatic struct nullb_device *null_alloc_dev(void);\nstatic void null_free_dev(struct nullb_device *dev);\nstatic void null_del_dev(struct nullb *nullb);\nstatic int null_add_dev(struct nullb_device *dev);\nstatic struct nullb *null_find_dev_by_name(const char *name);\nstatic void null_free_device_storage(struct nullb_device *dev, bool is_cache);\n\nstatic inline struct nullb_device *to_nullb_device(struct config_item *item)\n{\n\treturn item ? container_of(to_config_group(item), struct nullb_device, group) : NULL;\n}\n\nstatic inline ssize_t nullb_device_uint_attr_show(unsigned int val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic inline ssize_t nullb_device_ulong_attr_show(unsigned long val,\n\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%lu\\n\", val);\n}\n\nstatic inline ssize_t nullb_device_bool_attr_show(bool val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t nullb_device_uint_attr_store(unsigned int *val,\n\tconst char *page, size_t count)\n{\n\tunsigned int tmp;\n\tint result;\n\n\tresult = kstrtouint(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\nstatic ssize_t nullb_device_ulong_attr_store(unsigned long *val,\n\tconst char *page, size_t count)\n{\n\tint result;\n\tunsigned long tmp;\n\n\tresult = kstrtoul(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\nstatic ssize_t nullb_device_bool_attr_store(bool *val, const char *page,\n\tsize_t count)\n{\n\tbool tmp;\n\tint result;\n\n\tresult = kstrtobool(page,  &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\n \n#define NULLB_DEVICE_ATTR(NAME, TYPE, APPLY)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nnullb_device_##NAME##_show(struct config_item *item, char *page)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn nullb_device_##TYPE##_attr_show(\t\t\t\t\\\n\t\t\t\tto_nullb_device(item)->NAME, page);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nnullb_device_##NAME##_store(struct config_item *item, const char *page,\t\\\n\t\t\t    size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint (*apply_fn)(struct nullb_device *dev, TYPE new_value) = APPLY;\\\n\tstruct nullb_device *dev = to_nullb_device(item);\t\t\\\n\tTYPE new_value = 0;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = nullb_device_##TYPE##_attr_store(&new_value, page, count);\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (apply_fn)\t\t\t\t\t\t\t\\\n\t\tret = apply_fn(dev, new_value);\t\t\t\t\\\n\telse if (test_bit(NULLB_DEV_FL_CONFIGURED, &dev->flags)) \t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tdev->NAME = new_value;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(nullb_device_, NAME);\n\nstatic int nullb_update_nr_hw_queues(struct nullb_device *dev,\n\t\t\t\t     unsigned int submit_queues,\n\t\t\t\t     unsigned int poll_queues)\n\n{\n\tstruct blk_mq_tag_set *set;\n\tint ret, nr_hw_queues;\n\n\tif (!dev->nullb)\n\t\treturn 0;\n\n\t \n\tif (!submit_queues)\n\t\treturn -EINVAL;\n\n\t \n\tif (submit_queues > nr_cpu_ids || poll_queues > g_poll_queues)\n\t\treturn -EINVAL;\n\n\t \n\tdev->prev_submit_queues = dev->submit_queues;\n\tdev->prev_poll_queues = dev->poll_queues;\n\tdev->submit_queues = submit_queues;\n\tdev->poll_queues = poll_queues;\n\n\tset = dev->nullb->tag_set;\n\tnr_hw_queues = submit_queues + poll_queues;\n\tblk_mq_update_nr_hw_queues(set, nr_hw_queues);\n\tret = set->nr_hw_queues == nr_hw_queues ? 0 : -ENOMEM;\n\n\tif (ret) {\n\t\t \n\t\tdev->submit_queues = dev->prev_submit_queues;\n\t\tdev->poll_queues = dev->prev_poll_queues;\n\t}\n\n\treturn ret;\n}\n\nstatic int nullb_apply_submit_queues(struct nullb_device *dev,\n\t\t\t\t     unsigned int submit_queues)\n{\n\treturn nullb_update_nr_hw_queues(dev, submit_queues, dev->poll_queues);\n}\n\nstatic int nullb_apply_poll_queues(struct nullb_device *dev,\n\t\t\t\t   unsigned int poll_queues)\n{\n\treturn nullb_update_nr_hw_queues(dev, dev->submit_queues, poll_queues);\n}\n\nNULLB_DEVICE_ATTR(size, ulong, NULL);\nNULLB_DEVICE_ATTR(completion_nsec, ulong, NULL);\nNULLB_DEVICE_ATTR(submit_queues, uint, nullb_apply_submit_queues);\nNULLB_DEVICE_ATTR(poll_queues, uint, nullb_apply_poll_queues);\nNULLB_DEVICE_ATTR(home_node, uint, NULL);\nNULLB_DEVICE_ATTR(queue_mode, uint, NULL);\nNULLB_DEVICE_ATTR(blocksize, uint, NULL);\nNULLB_DEVICE_ATTR(max_sectors, uint, NULL);\nNULLB_DEVICE_ATTR(irqmode, uint, NULL);\nNULLB_DEVICE_ATTR(hw_queue_depth, uint, NULL);\nNULLB_DEVICE_ATTR(index, uint, NULL);\nNULLB_DEVICE_ATTR(blocking, bool, NULL);\nNULLB_DEVICE_ATTR(use_per_node_hctx, bool, NULL);\nNULLB_DEVICE_ATTR(memory_backed, bool, NULL);\nNULLB_DEVICE_ATTR(discard, bool, NULL);\nNULLB_DEVICE_ATTR(mbps, uint, NULL);\nNULLB_DEVICE_ATTR(cache_size, ulong, NULL);\nNULLB_DEVICE_ATTR(zoned, bool, NULL);\nNULLB_DEVICE_ATTR(zone_size, ulong, NULL);\nNULLB_DEVICE_ATTR(zone_capacity, ulong, NULL);\nNULLB_DEVICE_ATTR(zone_nr_conv, uint, NULL);\nNULLB_DEVICE_ATTR(zone_max_open, uint, NULL);\nNULLB_DEVICE_ATTR(zone_max_active, uint, NULL);\nNULLB_DEVICE_ATTR(virt_boundary, bool, NULL);\nNULLB_DEVICE_ATTR(no_sched, bool, NULL);\nNULLB_DEVICE_ATTR(shared_tag_bitmap, bool, NULL);\n\nstatic ssize_t nullb_device_power_show(struct config_item *item, char *page)\n{\n\treturn nullb_device_bool_attr_show(to_nullb_device(item)->power, page);\n}\n\nstatic ssize_t nullb_device_power_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\tbool newp = false;\n\tssize_t ret;\n\n\tret = nullb_device_bool_attr_store(&newp, page, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!dev->power && newp) {\n\t\tif (test_and_set_bit(NULLB_DEV_FL_UP, &dev->flags))\n\t\t\treturn count;\n\t\tret = null_add_dev(dev);\n\t\tif (ret) {\n\t\t\tclear_bit(NULLB_DEV_FL_UP, &dev->flags);\n\t\t\treturn ret;\n\t\t}\n\n\t\tset_bit(NULLB_DEV_FL_CONFIGURED, &dev->flags);\n\t\tdev->power = newp;\n\t} else if (dev->power && !newp) {\n\t\tif (test_and_clear_bit(NULLB_DEV_FL_UP, &dev->flags)) {\n\t\t\tmutex_lock(&lock);\n\t\t\tdev->power = newp;\n\t\t\tnull_del_dev(dev->nullb);\n\t\t\tmutex_unlock(&lock);\n\t\t}\n\t\tclear_bit(NULLB_DEV_FL_CONFIGURED, &dev->flags);\n\t}\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(nullb_device_, power);\n\nstatic ssize_t nullb_device_badblocks_show(struct config_item *item, char *page)\n{\n\tstruct nullb_device *t_dev = to_nullb_device(item);\n\n\treturn badblocks_show(&t_dev->badblocks, page, 0);\n}\n\nstatic ssize_t nullb_device_badblocks_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nullb_device *t_dev = to_nullb_device(item);\n\tchar *orig, *buf, *tmp;\n\tu64 start, end;\n\tint ret;\n\n\torig = kstrndup(page, count, GFP_KERNEL);\n\tif (!orig)\n\t\treturn -ENOMEM;\n\n\tbuf = strstrip(orig);\n\n\tret = -EINVAL;\n\tif (buf[0] != '+' && buf[0] != '-')\n\t\tgoto out;\n\ttmp = strchr(&buf[1], '-');\n\tif (!tmp)\n\t\tgoto out;\n\t*tmp = '\\0';\n\tret = kstrtoull(buf + 1, 0, &start);\n\tif (ret)\n\t\tgoto out;\n\tret = kstrtoull(tmp + 1, 0, &end);\n\tif (ret)\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (start > end)\n\t\tgoto out;\n\t \n\tcmpxchg(&t_dev->badblocks.shift, -1, 0);\n\tif (buf[0] == '+')\n\t\tret = badblocks_set(&t_dev->badblocks, start,\n\t\t\tend - start + 1, 1);\n\telse\n\t\tret = badblocks_clear(&t_dev->badblocks, start,\n\t\t\tend - start + 1);\n\tif (ret == 0)\n\t\tret = count;\nout:\n\tkfree(orig);\n\treturn ret;\n}\nCONFIGFS_ATTR(nullb_device_, badblocks);\n\nstatic ssize_t nullb_device_zone_readonly_store(struct config_item *item,\n\t\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\n\treturn zone_cond_store(dev, page, count, BLK_ZONE_COND_READONLY);\n}\nCONFIGFS_ATTR_WO(nullb_device_, zone_readonly);\n\nstatic ssize_t nullb_device_zone_offline_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t count)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\n\treturn zone_cond_store(dev, page, count, BLK_ZONE_COND_OFFLINE);\n}\nCONFIGFS_ATTR_WO(nullb_device_, zone_offline);\n\nstatic struct configfs_attribute *nullb_device_attrs[] = {\n\t&nullb_device_attr_size,\n\t&nullb_device_attr_completion_nsec,\n\t&nullb_device_attr_submit_queues,\n\t&nullb_device_attr_poll_queues,\n\t&nullb_device_attr_home_node,\n\t&nullb_device_attr_queue_mode,\n\t&nullb_device_attr_blocksize,\n\t&nullb_device_attr_max_sectors,\n\t&nullb_device_attr_irqmode,\n\t&nullb_device_attr_hw_queue_depth,\n\t&nullb_device_attr_index,\n\t&nullb_device_attr_blocking,\n\t&nullb_device_attr_use_per_node_hctx,\n\t&nullb_device_attr_power,\n\t&nullb_device_attr_memory_backed,\n\t&nullb_device_attr_discard,\n\t&nullb_device_attr_mbps,\n\t&nullb_device_attr_cache_size,\n\t&nullb_device_attr_badblocks,\n\t&nullb_device_attr_zoned,\n\t&nullb_device_attr_zone_size,\n\t&nullb_device_attr_zone_capacity,\n\t&nullb_device_attr_zone_nr_conv,\n\t&nullb_device_attr_zone_max_open,\n\t&nullb_device_attr_zone_max_active,\n\t&nullb_device_attr_zone_readonly,\n\t&nullb_device_attr_zone_offline,\n\t&nullb_device_attr_virt_boundary,\n\t&nullb_device_attr_no_sched,\n\t&nullb_device_attr_shared_tag_bitmap,\n\tNULL,\n};\n\nstatic void nullb_device_release(struct config_item *item)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\n\tnull_free_device_storage(dev, false);\n\tnull_free_dev(dev);\n}\n\nstatic struct configfs_item_operations nullb_device_ops = {\n\t.release\t= nullb_device_release,\n};\n\nstatic const struct config_item_type nullb_device_type = {\n\t.ct_item_ops\t= &nullb_device_ops,\n\t.ct_attrs\t= nullb_device_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n\nstatic void nullb_add_fault_config(struct nullb_device *dev)\n{\n\tfault_config_init(&dev->timeout_config, \"timeout_inject\");\n\tfault_config_init(&dev->requeue_config, \"requeue_inject\");\n\tfault_config_init(&dev->init_hctx_fault_config, \"init_hctx_fault_inject\");\n\n\tconfigfs_add_default_group(&dev->timeout_config.group, &dev->group);\n\tconfigfs_add_default_group(&dev->requeue_config.group, &dev->group);\n\tconfigfs_add_default_group(&dev->init_hctx_fault_config.group, &dev->group);\n}\n\n#else\n\nstatic void nullb_add_fault_config(struct nullb_device *dev)\n{\n}\n\n#endif\n\nstatic struct\nconfig_group *nullb_group_make_group(struct config_group *group, const char *name)\n{\n\tstruct nullb_device *dev;\n\n\tif (null_find_dev_by_name(name))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tdev = null_alloc_dev();\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_group_init_type_name(&dev->group, name, &nullb_device_type);\n\tnullb_add_fault_config(dev);\n\n\treturn &dev->group;\n}\n\nstatic void\nnullb_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\n\tif (test_and_clear_bit(NULLB_DEV_FL_UP, &dev->flags)) {\n\t\tmutex_lock(&lock);\n\t\tdev->power = false;\n\t\tnull_del_dev(dev->nullb);\n\t\tmutex_unlock(&lock);\n\t}\n\n\tconfig_item_put(item);\n}\n\nstatic ssize_t memb_group_features_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE,\n\t\t\t\"badblocks,blocking,blocksize,cache_size,\"\n\t\t\t\"completion_nsec,discard,home_node,hw_queue_depth,\"\n\t\t\t\"irqmode,max_sectors,mbps,memory_backed,no_sched,\"\n\t\t\t\"poll_queues,power,queue_mode,shared_tag_bitmap,size,\"\n\t\t\t\"submit_queues,use_per_node_hctx,virt_boundary,zoned,\"\n\t\t\t\"zone_capacity,zone_max_active,zone_max_open,\"\n\t\t\t\"zone_nr_conv,zone_offline,zone_readonly,zone_size\\n\");\n}\n\nCONFIGFS_ATTR_RO(memb_group_, features);\n\nstatic struct configfs_attribute *nullb_group_attrs[] = {\n\t&memb_group_attr_features,\n\tNULL,\n};\n\nstatic struct configfs_group_operations nullb_group_ops = {\n\t.make_group\t= nullb_group_make_group,\n\t.drop_item\t= nullb_group_drop_item,\n};\n\nstatic const struct config_item_type nullb_group_type = {\n\t.ct_group_ops\t= &nullb_group_ops,\n\t.ct_attrs\t= nullb_group_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem nullb_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"nullb\",\n\t\t\t.ci_type = &nullb_group_type,\n\t\t},\n\t},\n};\n\nstatic inline int null_cache_active(struct nullb *nullb)\n{\n\treturn test_bit(NULLB_DEV_FL_CACHE, &nullb->dev->flags);\n}\n\nstatic struct nullb_device *null_alloc_dev(void)\n{\n\tstruct nullb_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n\tdev->timeout_config.attr = null_timeout_attr;\n\tdev->requeue_config.attr = null_requeue_attr;\n\tdev->init_hctx_fault_config.attr = null_init_hctx_attr;\n#endif\n\n\tINIT_RADIX_TREE(&dev->data, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&dev->cache, GFP_ATOMIC);\n\tif (badblocks_init(&dev->badblocks, 0)) {\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\tdev->size = g_gb * 1024;\n\tdev->completion_nsec = g_completion_nsec;\n\tdev->submit_queues = g_submit_queues;\n\tdev->prev_submit_queues = g_submit_queues;\n\tdev->poll_queues = g_poll_queues;\n\tdev->prev_poll_queues = g_poll_queues;\n\tdev->home_node = g_home_node;\n\tdev->queue_mode = g_queue_mode;\n\tdev->blocksize = g_bs;\n\tdev->max_sectors = g_max_sectors;\n\tdev->irqmode = g_irqmode;\n\tdev->hw_queue_depth = g_hw_queue_depth;\n\tdev->blocking = g_blocking;\n\tdev->memory_backed = g_memory_backed;\n\tdev->discard = g_discard;\n\tdev->cache_size = g_cache_size;\n\tdev->mbps = g_mbps;\n\tdev->use_per_node_hctx = g_use_per_node_hctx;\n\tdev->zoned = g_zoned;\n\tdev->zone_size = g_zone_size;\n\tdev->zone_capacity = g_zone_capacity;\n\tdev->zone_nr_conv = g_zone_nr_conv;\n\tdev->zone_max_open = g_zone_max_open;\n\tdev->zone_max_active = g_zone_max_active;\n\tdev->virt_boundary = g_virt_boundary;\n\tdev->no_sched = g_no_sched;\n\tdev->shared_tag_bitmap = g_shared_tag_bitmap;\n\treturn dev;\n}\n\nstatic void null_free_dev(struct nullb_device *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tnull_free_zoned_dev(dev);\n\tbadblocks_exit(&dev->badblocks);\n\tkfree(dev);\n}\n\nstatic void put_tag(struct nullb_queue *nq, unsigned int tag)\n{\n\tclear_bit_unlock(tag, nq->tag_map);\n\n\tif (waitqueue_active(&nq->wait))\n\t\twake_up(&nq->wait);\n}\n\nstatic unsigned int get_tag(struct nullb_queue *nq)\n{\n\tunsigned int tag;\n\n\tdo {\n\t\ttag = find_first_zero_bit(nq->tag_map, nq->queue_depth);\n\t\tif (tag >= nq->queue_depth)\n\t\t\treturn -1U;\n\t} while (test_and_set_bit_lock(tag, nq->tag_map));\n\n\treturn tag;\n}\n\nstatic void free_cmd(struct nullb_cmd *cmd)\n{\n\tput_tag(cmd->nq, cmd->tag);\n}\n\nstatic enum hrtimer_restart null_cmd_timer_expired(struct hrtimer *timer);\n\nstatic struct nullb_cmd *__alloc_cmd(struct nullb_queue *nq)\n{\n\tstruct nullb_cmd *cmd;\n\tunsigned int tag;\n\n\ttag = get_tag(nq);\n\tif (tag != -1U) {\n\t\tcmd = &nq->cmds[tag];\n\t\tcmd->tag = tag;\n\t\tcmd->error = BLK_STS_OK;\n\t\tcmd->nq = nq;\n\t\tif (nq->dev->irqmode == NULL_IRQ_TIMER) {\n\t\t\thrtimer_init(&cmd->timer, CLOCK_MONOTONIC,\n\t\t\t\t     HRTIMER_MODE_REL);\n\t\t\tcmd->timer.function = null_cmd_timer_expired;\n\t\t}\n\t\treturn cmd;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct nullb_cmd *alloc_cmd(struct nullb_queue *nq, struct bio *bio)\n{\n\tstruct nullb_cmd *cmd;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\t \n\t\tcmd = __alloc_cmd(nq);\n\t\tif (cmd) {\n\t\t\tcmd->bio = bio;\n\t\t\treturn cmd;\n\t\t}\n\t\tprepare_to_wait(&nq->wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tio_schedule();\n\t\tfinish_wait(&nq->wait, &wait);\n\t} while (1);\n}\n\nstatic void end_cmd(struct nullb_cmd *cmd)\n{\n\tint queue_mode = cmd->nq->dev->queue_mode;\n\n\tswitch (queue_mode)  {\n\tcase NULL_Q_MQ:\n\t\tblk_mq_end_request(cmd->rq, cmd->error);\n\t\treturn;\n\tcase NULL_Q_BIO:\n\t\tcmd->bio->bi_status = cmd->error;\n\t\tbio_endio(cmd->bio);\n\t\tbreak;\n\t}\n\n\tfree_cmd(cmd);\n}\n\nstatic enum hrtimer_restart null_cmd_timer_expired(struct hrtimer *timer)\n{\n\tend_cmd(container_of(timer, struct nullb_cmd, timer));\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void null_cmd_end_timer(struct nullb_cmd *cmd)\n{\n\tktime_t kt = cmd->nq->dev->completion_nsec;\n\n\thrtimer_start(&cmd->timer, kt, HRTIMER_MODE_REL);\n}\n\nstatic void null_complete_rq(struct request *rq)\n{\n\tend_cmd(blk_mq_rq_to_pdu(rq));\n}\n\nstatic struct nullb_page *null_alloc_page(void)\n{\n\tstruct nullb_page *t_page;\n\n\tt_page = kmalloc(sizeof(struct nullb_page), GFP_NOIO);\n\tif (!t_page)\n\t\treturn NULL;\n\n\tt_page->page = alloc_pages(GFP_NOIO, 0);\n\tif (!t_page->page) {\n\t\tkfree(t_page);\n\t\treturn NULL;\n\t}\n\n\tmemset(t_page->bitmap, 0, sizeof(t_page->bitmap));\n\treturn t_page;\n}\n\nstatic void null_free_page(struct nullb_page *t_page)\n{\n\t__set_bit(NULLB_PAGE_FREE, t_page->bitmap);\n\tif (test_bit(NULLB_PAGE_LOCK, t_page->bitmap))\n\t\treturn;\n\t__free_page(t_page->page);\n\tkfree(t_page);\n}\n\nstatic bool null_page_empty(struct nullb_page *page)\n{\n\tint size = MAP_SZ - 2;\n\n\treturn find_first_bit(page->bitmap, size) == size;\n}\n\nstatic void null_free_sector(struct nullb *nullb, sector_t sector,\n\tbool is_cache)\n{\n\tunsigned int sector_bit;\n\tu64 idx;\n\tstruct nullb_page *t_page, *ret;\n\tstruct radix_tree_root *root;\n\n\troot = is_cache ? &nullb->dev->cache : &nullb->dev->data;\n\tidx = sector >> PAGE_SECTORS_SHIFT;\n\tsector_bit = (sector & SECTOR_MASK);\n\n\tt_page = radix_tree_lookup(root, idx);\n\tif (t_page) {\n\t\t__clear_bit(sector_bit, t_page->bitmap);\n\n\t\tif (null_page_empty(t_page)) {\n\t\t\tret = radix_tree_delete_item(root, idx, t_page);\n\t\t\tWARN_ON(ret != t_page);\n\t\t\tnull_free_page(ret);\n\t\t\tif (is_cache)\n\t\t\t\tnullb->dev->curr_cache -= PAGE_SIZE;\n\t\t}\n\t}\n}\n\nstatic struct nullb_page *null_radix_tree_insert(struct nullb *nullb, u64 idx,\n\tstruct nullb_page *t_page, bool is_cache)\n{\n\tstruct radix_tree_root *root;\n\n\troot = is_cache ? &nullb->dev->cache : &nullb->dev->data;\n\n\tif (radix_tree_insert(root, idx, t_page)) {\n\t\tnull_free_page(t_page);\n\t\tt_page = radix_tree_lookup(root, idx);\n\t\tWARN_ON(!t_page || t_page->page->index != idx);\n\t} else if (is_cache)\n\t\tnullb->dev->curr_cache += PAGE_SIZE;\n\n\treturn t_page;\n}\n\nstatic void null_free_device_storage(struct nullb_device *dev, bool is_cache)\n{\n\tunsigned long pos = 0;\n\tint nr_pages;\n\tstruct nullb_page *ret, *t_pages[FREE_BATCH];\n\tstruct radix_tree_root *root;\n\n\troot = is_cache ? &dev->cache : &dev->data;\n\n\tdo {\n\t\tint i;\n\n\t\tnr_pages = radix_tree_gang_lookup(root,\n\t\t\t\t(void **)t_pages, pos, FREE_BATCH);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tpos = t_pages[i]->page->index;\n\t\t\tret = radix_tree_delete_item(root, pos, t_pages[i]);\n\t\t\tWARN_ON(ret != t_pages[i]);\n\t\t\tnull_free_page(ret);\n\t\t}\n\n\t\tpos++;\n\t} while (nr_pages == FREE_BATCH);\n\n\tif (is_cache)\n\t\tdev->curr_cache = 0;\n}\n\nstatic struct nullb_page *__null_lookup_page(struct nullb *nullb,\n\tsector_t sector, bool for_write, bool is_cache)\n{\n\tunsigned int sector_bit;\n\tu64 idx;\n\tstruct nullb_page *t_page;\n\tstruct radix_tree_root *root;\n\n\tidx = sector >> PAGE_SECTORS_SHIFT;\n\tsector_bit = (sector & SECTOR_MASK);\n\n\troot = is_cache ? &nullb->dev->cache : &nullb->dev->data;\n\tt_page = radix_tree_lookup(root, idx);\n\tWARN_ON(t_page && t_page->page->index != idx);\n\n\tif (t_page && (for_write || test_bit(sector_bit, t_page->bitmap)))\n\t\treturn t_page;\n\n\treturn NULL;\n}\n\nstatic struct nullb_page *null_lookup_page(struct nullb *nullb,\n\tsector_t sector, bool for_write, bool ignore_cache)\n{\n\tstruct nullb_page *page = NULL;\n\n\tif (!ignore_cache)\n\t\tpage = __null_lookup_page(nullb, sector, for_write, true);\n\tif (page)\n\t\treturn page;\n\treturn __null_lookup_page(nullb, sector, for_write, false);\n}\n\nstatic struct nullb_page *null_insert_page(struct nullb *nullb,\n\t\t\t\t\t   sector_t sector, bool ignore_cache)\n\t__releases(&nullb->lock)\n\t__acquires(&nullb->lock)\n{\n\tu64 idx;\n\tstruct nullb_page *t_page;\n\n\tt_page = null_lookup_page(nullb, sector, true, ignore_cache);\n\tif (t_page)\n\t\treturn t_page;\n\n\tspin_unlock_irq(&nullb->lock);\n\n\tt_page = null_alloc_page();\n\tif (!t_page)\n\t\tgoto out_lock;\n\n\tif (radix_tree_preload(GFP_NOIO))\n\t\tgoto out_freepage;\n\n\tspin_lock_irq(&nullb->lock);\n\tidx = sector >> PAGE_SECTORS_SHIFT;\n\tt_page->page->index = idx;\n\tt_page = null_radix_tree_insert(nullb, idx, t_page, !ignore_cache);\n\tradix_tree_preload_end();\n\n\treturn t_page;\nout_freepage:\n\tnull_free_page(t_page);\nout_lock:\n\tspin_lock_irq(&nullb->lock);\n\treturn null_lookup_page(nullb, sector, true, ignore_cache);\n}\n\nstatic int null_flush_cache_page(struct nullb *nullb, struct nullb_page *c_page)\n{\n\tint i;\n\tunsigned int offset;\n\tu64 idx;\n\tstruct nullb_page *t_page, *ret;\n\tvoid *dst, *src;\n\n\tidx = c_page->page->index;\n\n\tt_page = null_insert_page(nullb, idx << PAGE_SECTORS_SHIFT, true);\n\n\t__clear_bit(NULLB_PAGE_LOCK, c_page->bitmap);\n\tif (test_bit(NULLB_PAGE_FREE, c_page->bitmap)) {\n\t\tnull_free_page(c_page);\n\t\tif (t_page && null_page_empty(t_page)) {\n\t\t\tret = radix_tree_delete_item(&nullb->dev->data,\n\t\t\t\tidx, t_page);\n\t\t\tnull_free_page(t_page);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!t_page)\n\t\treturn -ENOMEM;\n\n\tsrc = kmap_local_page(c_page->page);\n\tdst = kmap_local_page(t_page->page);\n\n\tfor (i = 0; i < PAGE_SECTORS;\n\t\t\ti += (nullb->dev->blocksize >> SECTOR_SHIFT)) {\n\t\tif (test_bit(i, c_page->bitmap)) {\n\t\t\toffset = (i << SECTOR_SHIFT);\n\t\t\tmemcpy(dst + offset, src + offset,\n\t\t\t\tnullb->dev->blocksize);\n\t\t\t__set_bit(i, t_page->bitmap);\n\t\t}\n\t}\n\n\tkunmap_local(dst);\n\tkunmap_local(src);\n\n\tret = radix_tree_delete_item(&nullb->dev->cache, idx, c_page);\n\tnull_free_page(ret);\n\tnullb->dev->curr_cache -= PAGE_SIZE;\n\n\treturn 0;\n}\n\nstatic int null_make_cache_space(struct nullb *nullb, unsigned long n)\n{\n\tint i, err, nr_pages;\n\tstruct nullb_page *c_pages[FREE_BATCH];\n\tunsigned long flushed = 0, one_round;\n\nagain:\n\tif ((nullb->dev->cache_size * 1024 * 1024) >\n\t     nullb->dev->curr_cache + n || nullb->dev->curr_cache == 0)\n\t\treturn 0;\n\n\tnr_pages = radix_tree_gang_lookup(&nullb->dev->cache,\n\t\t\t(void **)c_pages, nullb->cache_flush_pos, FREE_BATCH);\n\t \n\tfor (i = 0; i < nr_pages; i++) {\n\t\tnullb->cache_flush_pos = c_pages[i]->page->index;\n\t\t \n\t\tif (test_bit(NULLB_PAGE_LOCK, c_pages[i]->bitmap))\n\t\t\tc_pages[i] = NULL;\n\t\telse\n\t\t\t__set_bit(NULLB_PAGE_LOCK, c_pages[i]->bitmap);\n\t}\n\n\tone_round = 0;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (c_pages[i] == NULL)\n\t\t\tcontinue;\n\t\terr = null_flush_cache_page(nullb, c_pages[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tone_round++;\n\t}\n\tflushed += one_round << PAGE_SHIFT;\n\n\tif (n > flushed) {\n\t\tif (nr_pages == 0)\n\t\t\tnullb->cache_flush_pos = 0;\n\t\tif (one_round == 0) {\n\t\t\t \n\t\t\tspin_unlock_irq(&nullb->lock);\n\t\t\tspin_lock_irq(&nullb->lock);\n\t\t}\n\t\tgoto again;\n\t}\n\treturn 0;\n}\n\nstatic int copy_to_nullb(struct nullb *nullb, struct page *source,\n\tunsigned int off, sector_t sector, size_t n, bool is_fua)\n{\n\tsize_t temp, count = 0;\n\tunsigned int offset;\n\tstruct nullb_page *t_page;\n\n\twhile (count < n) {\n\t\ttemp = min_t(size_t, nullb->dev->blocksize, n - count);\n\n\t\tif (null_cache_active(nullb) && !is_fua)\n\t\t\tnull_make_cache_space(nullb, PAGE_SIZE);\n\n\t\toffset = (sector & SECTOR_MASK) << SECTOR_SHIFT;\n\t\tt_page = null_insert_page(nullb, sector,\n\t\t\t!null_cache_active(nullb) || is_fua);\n\t\tif (!t_page)\n\t\t\treturn -ENOSPC;\n\n\t\tmemcpy_page(t_page->page, offset, source, off + count, temp);\n\n\t\t__set_bit(sector & SECTOR_MASK, t_page->bitmap);\n\n\t\tif (is_fua)\n\t\t\tnull_free_sector(nullb, sector, true);\n\n\t\tcount += temp;\n\t\tsector += temp >> SECTOR_SHIFT;\n\t}\n\treturn 0;\n}\n\nstatic int copy_from_nullb(struct nullb *nullb, struct page *dest,\n\tunsigned int off, sector_t sector, size_t n)\n{\n\tsize_t temp, count = 0;\n\tunsigned int offset;\n\tstruct nullb_page *t_page;\n\n\twhile (count < n) {\n\t\ttemp = min_t(size_t, nullb->dev->blocksize, n - count);\n\n\t\toffset = (sector & SECTOR_MASK) << SECTOR_SHIFT;\n\t\tt_page = null_lookup_page(nullb, sector, false,\n\t\t\t!null_cache_active(nullb));\n\n\t\tif (t_page)\n\t\t\tmemcpy_page(dest, off + count, t_page->page, offset,\n\t\t\t\t    temp);\n\t\telse\n\t\t\tzero_user(dest, off + count, temp);\n\n\t\tcount += temp;\n\t\tsector += temp >> SECTOR_SHIFT;\n\t}\n\treturn 0;\n}\n\nstatic void nullb_fill_pattern(struct nullb *nullb, struct page *page,\n\t\t\t       unsigned int len, unsigned int off)\n{\n\tmemset_page(page, off, 0xff, len);\n}\n\nblk_status_t null_handle_discard(struct nullb_device *dev,\n\t\t\t\t sector_t sector, sector_t nr_sectors)\n{\n\tstruct nullb *nullb = dev->nullb;\n\tsize_t n = nr_sectors << SECTOR_SHIFT;\n\tsize_t temp;\n\n\tspin_lock_irq(&nullb->lock);\n\twhile (n > 0) {\n\t\ttemp = min_t(size_t, n, dev->blocksize);\n\t\tnull_free_sector(nullb, sector, false);\n\t\tif (null_cache_active(nullb))\n\t\t\tnull_free_sector(nullb, sector, true);\n\t\tsector += temp >> SECTOR_SHIFT;\n\t\tn -= temp;\n\t}\n\tspin_unlock_irq(&nullb->lock);\n\n\treturn BLK_STS_OK;\n}\n\nstatic int null_handle_flush(struct nullb *nullb)\n{\n\tint err;\n\n\tif (!null_cache_active(nullb))\n\t\treturn 0;\n\n\tspin_lock_irq(&nullb->lock);\n\twhile (true) {\n\t\terr = null_make_cache_space(nullb,\n\t\t\tnullb->dev->cache_size * 1024 * 1024);\n\t\tif (err || nullb->dev->curr_cache == 0)\n\t\t\tbreak;\n\t}\n\n\tWARN_ON(!radix_tree_empty(&nullb->dev->cache));\n\tspin_unlock_irq(&nullb->lock);\n\treturn err;\n}\n\nstatic int null_transfer(struct nullb *nullb, struct page *page,\n\tunsigned int len, unsigned int off, bool is_write, sector_t sector,\n\tbool is_fua)\n{\n\tstruct nullb_device *dev = nullb->dev;\n\tunsigned int valid_len = len;\n\tint err = 0;\n\n\tif (!is_write) {\n\t\tif (dev->zoned)\n\t\t\tvalid_len = null_zone_valid_read_len(nullb,\n\t\t\t\tsector, len);\n\n\t\tif (valid_len) {\n\t\t\terr = copy_from_nullb(nullb, page, off,\n\t\t\t\tsector, valid_len);\n\t\t\toff += valid_len;\n\t\t\tlen -= valid_len;\n\t\t}\n\n\t\tif (len)\n\t\t\tnullb_fill_pattern(nullb, page, len, off);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tflush_dcache_page(page);\n\t\terr = copy_to_nullb(nullb, page, off, sector, len, is_fua);\n\t}\n\n\treturn err;\n}\n\nstatic int null_handle_rq(struct nullb_cmd *cmd)\n{\n\tstruct request *rq = cmd->rq;\n\tstruct nullb *nullb = cmd->nq->dev->nullb;\n\tint err;\n\tunsigned int len;\n\tsector_t sector = blk_rq_pos(rq);\n\tstruct req_iterator iter;\n\tstruct bio_vec bvec;\n\n\tspin_lock_irq(&nullb->lock);\n\trq_for_each_segment(bvec, rq, iter) {\n\t\tlen = bvec.bv_len;\n\t\terr = null_transfer(nullb, bvec.bv_page, len, bvec.bv_offset,\n\t\t\t\t     op_is_write(req_op(rq)), sector,\n\t\t\t\t     rq->cmd_flags & REQ_FUA);\n\t\tif (err) {\n\t\t\tspin_unlock_irq(&nullb->lock);\n\t\t\treturn err;\n\t\t}\n\t\tsector += len >> SECTOR_SHIFT;\n\t}\n\tspin_unlock_irq(&nullb->lock);\n\n\treturn 0;\n}\n\nstatic int null_handle_bio(struct nullb_cmd *cmd)\n{\n\tstruct bio *bio = cmd->bio;\n\tstruct nullb *nullb = cmd->nq->dev->nullb;\n\tint err;\n\tunsigned int len;\n\tsector_t sector = bio->bi_iter.bi_sector;\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\n\tspin_lock_irq(&nullb->lock);\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tlen = bvec.bv_len;\n\t\terr = null_transfer(nullb, bvec.bv_page, len, bvec.bv_offset,\n\t\t\t\t     op_is_write(bio_op(bio)), sector,\n\t\t\t\t     bio->bi_opf & REQ_FUA);\n\t\tif (err) {\n\t\t\tspin_unlock_irq(&nullb->lock);\n\t\t\treturn err;\n\t\t}\n\t\tsector += len >> SECTOR_SHIFT;\n\t}\n\tspin_unlock_irq(&nullb->lock);\n\treturn 0;\n}\n\nstatic void null_stop_queue(struct nullb *nullb)\n{\n\tstruct request_queue *q = nullb->q;\n\n\tif (nullb->dev->queue_mode == NULL_Q_MQ)\n\t\tblk_mq_stop_hw_queues(q);\n}\n\nstatic void null_restart_queue_async(struct nullb *nullb)\n{\n\tstruct request_queue *q = nullb->q;\n\n\tif (nullb->dev->queue_mode == NULL_Q_MQ)\n\t\tblk_mq_start_stopped_hw_queues(q, true);\n}\n\nstatic inline blk_status_t null_handle_throttled(struct nullb_cmd *cmd)\n{\n\tstruct nullb_device *dev = cmd->nq->dev;\n\tstruct nullb *nullb = dev->nullb;\n\tblk_status_t sts = BLK_STS_OK;\n\tstruct request *rq = cmd->rq;\n\n\tif (!hrtimer_active(&nullb->bw_timer))\n\t\thrtimer_restart(&nullb->bw_timer);\n\n\tif (atomic_long_sub_return(blk_rq_bytes(rq), &nullb->cur_bytes) < 0) {\n\t\tnull_stop_queue(nullb);\n\t\t \n\t\tif (atomic_long_read(&nullb->cur_bytes) > 0)\n\t\t\tnull_restart_queue_async(nullb);\n\t\t \n\t\tsts = BLK_STS_DEV_RESOURCE;\n\t}\n\treturn sts;\n}\n\nstatic inline blk_status_t null_handle_badblocks(struct nullb_cmd *cmd,\n\t\t\t\t\t\t sector_t sector,\n\t\t\t\t\t\t sector_t nr_sectors)\n{\n\tstruct badblocks *bb = &cmd->nq->dev->badblocks;\n\tsector_t first_bad;\n\tint bad_sectors;\n\n\tif (badblocks_check(bb, sector, nr_sectors, &first_bad, &bad_sectors))\n\t\treturn BLK_STS_IOERR;\n\n\treturn BLK_STS_OK;\n}\n\nstatic inline blk_status_t null_handle_memory_backed(struct nullb_cmd *cmd,\n\t\t\t\t\t\t     enum req_op op,\n\t\t\t\t\t\t     sector_t sector,\n\t\t\t\t\t\t     sector_t nr_sectors)\n{\n\tstruct nullb_device *dev = cmd->nq->dev;\n\tint err;\n\n\tif (op == REQ_OP_DISCARD)\n\t\treturn null_handle_discard(dev, sector, nr_sectors);\n\n\tif (dev->queue_mode == NULL_Q_BIO)\n\t\terr = null_handle_bio(cmd);\n\telse\n\t\terr = null_handle_rq(cmd);\n\n\treturn errno_to_blk_status(err);\n}\n\nstatic void nullb_zero_read_cmd_buffer(struct nullb_cmd *cmd)\n{\n\tstruct nullb_device *dev = cmd->nq->dev;\n\tstruct bio *bio;\n\n\tif (dev->memory_backed)\n\t\treturn;\n\n\tif (dev->queue_mode == NULL_Q_BIO && bio_op(cmd->bio) == REQ_OP_READ) {\n\t\tzero_fill_bio(cmd->bio);\n\t} else if (req_op(cmd->rq) == REQ_OP_READ) {\n\t\t__rq_for_each_bio(bio, cmd->rq)\n\t\t\tzero_fill_bio(bio);\n\t}\n}\n\nstatic inline void nullb_complete_cmd(struct nullb_cmd *cmd)\n{\n\t \n\tif (IS_ENABLED(CONFIG_KMSAN))\n\t\tnullb_zero_read_cmd_buffer(cmd);\n\n\t \n\tswitch (cmd->nq->dev->irqmode) {\n\tcase NULL_IRQ_SOFTIRQ:\n\t\tswitch (cmd->nq->dev->queue_mode) {\n\t\tcase NULL_Q_MQ:\n\t\t\tblk_mq_complete_request(cmd->rq);\n\t\t\tbreak;\n\t\tcase NULL_Q_BIO:\n\t\t\t \n\t\t\tend_cmd(cmd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NULL_IRQ_NONE:\n\t\tend_cmd(cmd);\n\t\tbreak;\n\tcase NULL_IRQ_TIMER:\n\t\tnull_cmd_end_timer(cmd);\n\t\tbreak;\n\t}\n}\n\nblk_status_t null_process_cmd(struct nullb_cmd *cmd, enum req_op op,\n\t\t\t      sector_t sector, unsigned int nr_sectors)\n{\n\tstruct nullb_device *dev = cmd->nq->dev;\n\tblk_status_t ret;\n\n\tif (dev->badblocks.shift != -1) {\n\t\tret = null_handle_badblocks(cmd, sector, nr_sectors);\n\t\tif (ret != BLK_STS_OK)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->memory_backed)\n\t\treturn null_handle_memory_backed(cmd, op, sector, nr_sectors);\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t null_handle_cmd(struct nullb_cmd *cmd, sector_t sector,\n\t\t\t\t    sector_t nr_sectors, enum req_op op)\n{\n\tstruct nullb_device *dev = cmd->nq->dev;\n\tstruct nullb *nullb = dev->nullb;\n\tblk_status_t sts;\n\n\tif (test_bit(NULLB_DEV_FL_THROTTLED, &dev->flags)) {\n\t\tsts = null_handle_throttled(cmd);\n\t\tif (sts != BLK_STS_OK)\n\t\t\treturn sts;\n\t}\n\n\tif (op == REQ_OP_FLUSH) {\n\t\tcmd->error = errno_to_blk_status(null_handle_flush(nullb));\n\t\tgoto out;\n\t}\n\n\tif (dev->zoned)\n\t\tsts = null_process_zoned_cmd(cmd, op, sector, nr_sectors);\n\telse\n\t\tsts = null_process_cmd(cmd, op, sector, nr_sectors);\n\n\t \n\tif (cmd->error == BLK_STS_OK)\n\t\tcmd->error = sts;\n\nout:\n\tnullb_complete_cmd(cmd);\n\treturn BLK_STS_OK;\n}\n\nstatic enum hrtimer_restart nullb_bwtimer_fn(struct hrtimer *timer)\n{\n\tstruct nullb *nullb = container_of(timer, struct nullb, bw_timer);\n\tktime_t timer_interval = ktime_set(0, TIMER_INTERVAL);\n\tunsigned int mbps = nullb->dev->mbps;\n\n\tif (atomic_long_read(&nullb->cur_bytes) == mb_per_tick(mbps))\n\t\treturn HRTIMER_NORESTART;\n\n\tatomic_long_set(&nullb->cur_bytes, mb_per_tick(mbps));\n\tnull_restart_queue_async(nullb);\n\n\thrtimer_forward_now(&nullb->bw_timer, timer_interval);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic void nullb_setup_bwtimer(struct nullb *nullb)\n{\n\tktime_t timer_interval = ktime_set(0, TIMER_INTERVAL);\n\n\thrtimer_init(&nullb->bw_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tnullb->bw_timer.function = nullb_bwtimer_fn;\n\tatomic_long_set(&nullb->cur_bytes, mb_per_tick(nullb->dev->mbps));\n\thrtimer_start(&nullb->bw_timer, timer_interval, HRTIMER_MODE_REL);\n}\n\nstatic struct nullb_queue *nullb_to_queue(struct nullb *nullb)\n{\n\tint index = 0;\n\n\tif (nullb->nr_queues != 1)\n\t\tindex = raw_smp_processor_id() / ((nr_cpu_ids + nullb->nr_queues - 1) / nullb->nr_queues);\n\n\treturn &nullb->queues[index];\n}\n\nstatic void null_submit_bio(struct bio *bio)\n{\n\tsector_t sector = bio->bi_iter.bi_sector;\n\tsector_t nr_sectors = bio_sectors(bio);\n\tstruct nullb *nullb = bio->bi_bdev->bd_disk->private_data;\n\tstruct nullb_queue *nq = nullb_to_queue(nullb);\n\n\tnull_handle_cmd(alloc_cmd(nq, bio), sector, nr_sectors, bio_op(bio));\n}\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n\nstatic bool should_timeout_request(struct request *rq)\n{\n\tstruct nullb_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct nullb_device *dev = cmd->nq->dev;\n\n\treturn should_fail(&dev->timeout_config.attr, 1);\n}\n\nstatic bool should_requeue_request(struct request *rq)\n{\n\tstruct nullb_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct nullb_device *dev = cmd->nq->dev;\n\n\treturn should_fail(&dev->requeue_config.attr, 1);\n}\n\nstatic bool should_init_hctx_fail(struct nullb_device *dev)\n{\n\treturn should_fail(&dev->init_hctx_fault_config.attr, 1);\n}\n\n#else\n\nstatic bool should_timeout_request(struct request *rq)\n{\n\treturn false;\n}\n\nstatic bool should_requeue_request(struct request *rq)\n{\n\treturn false;\n}\n\nstatic bool should_init_hctx_fail(struct nullb_device *dev)\n{\n\treturn false;\n}\n\n#endif\n\nstatic void null_map_queues(struct blk_mq_tag_set *set)\n{\n\tstruct nullb *nullb = set->driver_data;\n\tint i, qoff;\n\tunsigned int submit_queues = g_submit_queues;\n\tunsigned int poll_queues = g_poll_queues;\n\n\tif (nullb) {\n\t\tstruct nullb_device *dev = nullb->dev;\n\n\t\t \n\t\tif (set->nr_hw_queues ==\n\t\t    dev->submit_queues + dev->poll_queues) {\n\t\t\tsubmit_queues = dev->submit_queues;\n\t\t\tpoll_queues = dev->poll_queues;\n\t\t} else if (set->nr_hw_queues ==\n\t\t\t   dev->prev_submit_queues + dev->prev_poll_queues) {\n\t\t\tsubmit_queues = dev->prev_submit_queues;\n\t\t\tpoll_queues = dev->prev_poll_queues;\n\t\t} else {\n\t\t\tpr_warn(\"tag set has unexpected nr_hw_queues: %d\\n\",\n\t\t\t\tset->nr_hw_queues);\n\t\t\tWARN_ON_ONCE(true);\n\t\t\tsubmit_queues = 1;\n\t\t\tpoll_queues = 0;\n\t\t}\n\t}\n\n\tfor (i = 0, qoff = 0; i < set->nr_maps; i++) {\n\t\tstruct blk_mq_queue_map *map = &set->map[i];\n\n\t\tswitch (i) {\n\t\tcase HCTX_TYPE_DEFAULT:\n\t\t\tmap->nr_queues = submit_queues;\n\t\t\tbreak;\n\t\tcase HCTX_TYPE_READ:\n\t\t\tmap->nr_queues = 0;\n\t\t\tcontinue;\n\t\tcase HCTX_TYPE_POLL:\n\t\t\tmap->nr_queues = poll_queues;\n\t\t\tbreak;\n\t\t}\n\t\tmap->queue_offset = qoff;\n\t\tqoff += map->nr_queues;\n\t\tblk_mq_map_queues(map);\n\t}\n}\n\nstatic int null_poll(struct blk_mq_hw_ctx *hctx, struct io_comp_batch *iob)\n{\n\tstruct nullb_queue *nq = hctx->driver_data;\n\tLIST_HEAD(list);\n\tint nr = 0;\n\tstruct request *rq;\n\n\tspin_lock(&nq->poll_lock);\n\tlist_splice_init(&nq->poll_list, &list);\n\tlist_for_each_entry(rq, &list, queuelist)\n\t\tblk_mq_set_request_complete(rq);\n\tspin_unlock(&nq->poll_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tstruct nullb_cmd *cmd;\n\t\tstruct request *req;\n\n\t\treq = list_first_entry(&list, struct request, queuelist);\n\t\tlist_del_init(&req->queuelist);\n\t\tcmd = blk_mq_rq_to_pdu(req);\n\t\tcmd->error = null_process_cmd(cmd, req_op(req), blk_rq_pos(req),\n\t\t\t\t\t\tblk_rq_sectors(req));\n\t\tif (!blk_mq_add_to_batch(req, iob, (__force int) cmd->error,\n\t\t\t\t\tblk_mq_end_request_batch))\n\t\t\tend_cmd(cmd);\n\t\tnr++;\n\t}\n\n\treturn nr;\n}\n\nstatic enum blk_eh_timer_return null_timeout_rq(struct request *rq)\n{\n\tstruct blk_mq_hw_ctx *hctx = rq->mq_hctx;\n\tstruct nullb_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tif (hctx->type == HCTX_TYPE_POLL) {\n\t\tstruct nullb_queue *nq = hctx->driver_data;\n\n\t\tspin_lock(&nq->poll_lock);\n\t\t \n\t\tif (blk_mq_request_completed(rq)) {\n\t\t\tspin_unlock(&nq->poll_lock);\n\t\t\treturn BLK_EH_DONE;\n\t\t}\n\t\tlist_del_init(&rq->queuelist);\n\t\tspin_unlock(&nq->poll_lock);\n\t}\n\n\tpr_info(\"rq %p timed out\\n\", rq);\n\n\t \n\tcmd->error = BLK_STS_TIMEOUT;\n\tif (cmd->fake_timeout || hctx->type == HCTX_TYPE_POLL)\n\t\tblk_mq_complete_request(rq);\n\treturn BLK_EH_DONE;\n}\n\nstatic blk_status_t null_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t  const struct blk_mq_queue_data *bd)\n{\n\tstruct request *rq = bd->rq;\n\tstruct nullb_cmd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct nullb_queue *nq = hctx->driver_data;\n\tsector_t nr_sectors = blk_rq_sectors(rq);\n\tsector_t sector = blk_rq_pos(rq);\n\tconst bool is_poll = hctx->type == HCTX_TYPE_POLL;\n\n\tmight_sleep_if(hctx->flags & BLK_MQ_F_BLOCKING);\n\n\tif (!is_poll && nq->dev->irqmode == NULL_IRQ_TIMER) {\n\t\thrtimer_init(&cmd->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\tcmd->timer.function = null_cmd_timer_expired;\n\t}\n\tcmd->rq = rq;\n\tcmd->error = BLK_STS_OK;\n\tcmd->nq = nq;\n\tcmd->fake_timeout = should_timeout_request(rq) ||\n\t\tblk_should_fake_timeout(rq->q);\n\n\tblk_mq_start_request(rq);\n\n\tif (should_requeue_request(rq)) {\n\t\t \n\t\tnq->requeue_selection++;\n\t\tif (nq->requeue_selection & 1)\n\t\t\treturn BLK_STS_RESOURCE;\n\t\tblk_mq_requeue_request(rq, true);\n\t\treturn BLK_STS_OK;\n\t}\n\n\tif (is_poll) {\n\t\tspin_lock(&nq->poll_lock);\n\t\tlist_add_tail(&rq->queuelist, &nq->poll_list);\n\t\tspin_unlock(&nq->poll_lock);\n\t\treturn BLK_STS_OK;\n\t}\n\tif (cmd->fake_timeout)\n\t\treturn BLK_STS_OK;\n\n\treturn null_handle_cmd(cmd, sector, nr_sectors, req_op(rq));\n}\n\nstatic void cleanup_queue(struct nullb_queue *nq)\n{\n\tbitmap_free(nq->tag_map);\n\tkfree(nq->cmds);\n}\n\nstatic void cleanup_queues(struct nullb *nullb)\n{\n\tint i;\n\n\tfor (i = 0; i < nullb->nr_queues; i++)\n\t\tcleanup_queue(&nullb->queues[i]);\n\n\tkfree(nullb->queues);\n}\n\nstatic void null_exit_hctx(struct blk_mq_hw_ctx *hctx, unsigned int hctx_idx)\n{\n\tstruct nullb_queue *nq = hctx->driver_data;\n\tstruct nullb *nullb = nq->dev->nullb;\n\n\tnullb->nr_queues--;\n}\n\nstatic void null_init_queue(struct nullb *nullb, struct nullb_queue *nq)\n{\n\tinit_waitqueue_head(&nq->wait);\n\tnq->queue_depth = nullb->queue_depth;\n\tnq->dev = nullb->dev;\n\tINIT_LIST_HEAD(&nq->poll_list);\n\tspin_lock_init(&nq->poll_lock);\n}\n\nstatic int null_init_hctx(struct blk_mq_hw_ctx *hctx, void *driver_data,\n\t\t\t  unsigned int hctx_idx)\n{\n\tstruct nullb *nullb = hctx->queue->queuedata;\n\tstruct nullb_queue *nq;\n\n\tif (should_init_hctx_fail(nullb->dev))\n\t\treturn -EFAULT;\n\n\tnq = &nullb->queues[hctx_idx];\n\thctx->driver_data = nq;\n\tnull_init_queue(nullb, nq);\n\tnullb->nr_queues++;\n\n\treturn 0;\n}\n\nstatic const struct blk_mq_ops null_mq_ops = {\n\t.queue_rq       = null_queue_rq,\n\t.complete\t= null_complete_rq,\n\t.timeout\t= null_timeout_rq,\n\t.poll\t\t= null_poll,\n\t.map_queues\t= null_map_queues,\n\t.init_hctx\t= null_init_hctx,\n\t.exit_hctx\t= null_exit_hctx,\n};\n\nstatic void null_del_dev(struct nullb *nullb)\n{\n\tstruct nullb_device *dev;\n\n\tif (!nullb)\n\t\treturn;\n\n\tdev = nullb->dev;\n\n\tida_simple_remove(&nullb_indexes, nullb->index);\n\n\tlist_del_init(&nullb->list);\n\n\tdel_gendisk(nullb->disk);\n\n\tif (test_bit(NULLB_DEV_FL_THROTTLED, &nullb->dev->flags)) {\n\t\thrtimer_cancel(&nullb->bw_timer);\n\t\tatomic_long_set(&nullb->cur_bytes, LONG_MAX);\n\t\tnull_restart_queue_async(nullb);\n\t}\n\n\tput_disk(nullb->disk);\n\tif (dev->queue_mode == NULL_Q_MQ &&\n\t    nullb->tag_set == &nullb->__tag_set)\n\t\tblk_mq_free_tag_set(nullb->tag_set);\n\tcleanup_queues(nullb);\n\tif (null_cache_active(nullb))\n\t\tnull_free_device_storage(nullb->dev, true);\n\tkfree(nullb);\n\tdev->nullb = NULL;\n}\n\nstatic void null_config_discard(struct nullb *nullb)\n{\n\tif (nullb->dev->discard == false)\n\t\treturn;\n\n\tif (!nullb->dev->memory_backed) {\n\t\tnullb->dev->discard = false;\n\t\tpr_info(\"discard option is ignored without memory backing\\n\");\n\t\treturn;\n\t}\n\n\tif (nullb->dev->zoned) {\n\t\tnullb->dev->discard = false;\n\t\tpr_info(\"discard option is ignored in zoned mode\\n\");\n\t\treturn;\n\t}\n\n\tnullb->q->limits.discard_granularity = nullb->dev->blocksize;\n\tblk_queue_max_discard_sectors(nullb->q, UINT_MAX >> 9);\n}\n\nstatic const struct block_device_operations null_bio_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.submit_bio\t= null_submit_bio,\n\t.report_zones\t= null_report_zones,\n};\n\nstatic const struct block_device_operations null_rq_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.report_zones\t= null_report_zones,\n};\n\nstatic int setup_commands(struct nullb_queue *nq)\n{\n\tstruct nullb_cmd *cmd;\n\tint i;\n\n\tnq->cmds = kcalloc(nq->queue_depth, sizeof(*cmd), GFP_KERNEL);\n\tif (!nq->cmds)\n\t\treturn -ENOMEM;\n\n\tnq->tag_map = bitmap_zalloc(nq->queue_depth, GFP_KERNEL);\n\tif (!nq->tag_map) {\n\t\tkfree(nq->cmds);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nq->queue_depth; i++) {\n\t\tcmd = &nq->cmds[i];\n\t\tcmd->tag = -1U;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_queues(struct nullb *nullb)\n{\n\tint nqueues = nr_cpu_ids;\n\n\tif (g_poll_queues)\n\t\tnqueues += g_poll_queues;\n\n\tnullb->queues = kcalloc(nqueues, sizeof(struct nullb_queue),\n\t\t\t\tGFP_KERNEL);\n\tif (!nullb->queues)\n\t\treturn -ENOMEM;\n\n\tnullb->queue_depth = nullb->dev->hw_queue_depth;\n\treturn 0;\n}\n\nstatic int init_driver_queues(struct nullb *nullb)\n{\n\tstruct nullb_queue *nq;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < nullb->dev->submit_queues; i++) {\n\t\tnq = &nullb->queues[i];\n\n\t\tnull_init_queue(nullb, nq);\n\n\t\tret = setup_commands(nq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tnullb->nr_queues++;\n\t}\n\treturn 0;\n}\n\nstatic int null_gendisk_register(struct nullb *nullb)\n{\n\tsector_t size = ((sector_t)nullb->dev->size * SZ_1M) >> SECTOR_SHIFT;\n\tstruct gendisk *disk = nullb->disk;\n\n\tset_capacity(disk, size);\n\n\tdisk->major\t\t= null_major;\n\tdisk->first_minor\t= nullb->index;\n\tdisk->minors\t\t= 1;\n\tif (queue_is_mq(nullb->q))\n\t\tdisk->fops\t\t= &null_rq_ops;\n\telse\n\t\tdisk->fops\t\t= &null_bio_ops;\n\tdisk->private_data\t= nullb;\n\tstrncpy(disk->disk_name, nullb->disk_name, DISK_NAME_LEN);\n\n\tif (nullb->dev->zoned) {\n\t\tint ret = null_register_zoned_dev(nullb);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn add_disk(disk);\n}\n\nstatic int null_init_tag_set(struct nullb *nullb, struct blk_mq_tag_set *set)\n{\n\tunsigned int flags = BLK_MQ_F_SHOULD_MERGE;\n\tint hw_queues, numa_node;\n\tunsigned int queue_depth;\n\tint poll_queues;\n\n\tif (nullb) {\n\t\thw_queues = nullb->dev->submit_queues;\n\t\tpoll_queues = nullb->dev->poll_queues;\n\t\tqueue_depth = nullb->dev->hw_queue_depth;\n\t\tnuma_node = nullb->dev->home_node;\n\t\tif (nullb->dev->no_sched)\n\t\t\tflags |= BLK_MQ_F_NO_SCHED;\n\t\tif (nullb->dev->shared_tag_bitmap)\n\t\t\tflags |= BLK_MQ_F_TAG_HCTX_SHARED;\n\t\tif (nullb->dev->blocking)\n\t\t\tflags |= BLK_MQ_F_BLOCKING;\n\t} else {\n\t\thw_queues = g_submit_queues;\n\t\tpoll_queues = g_poll_queues;\n\t\tqueue_depth = g_hw_queue_depth;\n\t\tnuma_node = g_home_node;\n\t\tif (g_no_sched)\n\t\t\tflags |= BLK_MQ_F_NO_SCHED;\n\t\tif (g_shared_tag_bitmap)\n\t\t\tflags |= BLK_MQ_F_TAG_HCTX_SHARED;\n\t\tif (g_blocking)\n\t\t\tflags |= BLK_MQ_F_BLOCKING;\n\t}\n\n\tset->ops = &null_mq_ops;\n\tset->cmd_size\t= sizeof(struct nullb_cmd);\n\tset->flags = flags;\n\tset->driver_data = nullb;\n\tset->nr_hw_queues = hw_queues;\n\tset->queue_depth = queue_depth;\n\tset->numa_node = numa_node;\n\tif (poll_queues) {\n\t\tset->nr_hw_queues += poll_queues;\n\t\tset->nr_maps = 3;\n\t} else {\n\t\tset->nr_maps = 1;\n\t}\n\n\treturn blk_mq_alloc_tag_set(set);\n}\n\nstatic int null_validate_conf(struct nullb_device *dev)\n{\n\tif (dev->queue_mode == NULL_Q_RQ) {\n\t\tpr_err(\"legacy IO path is no longer available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev->blocksize = round_down(dev->blocksize, 512);\n\tdev->blocksize = clamp_t(unsigned int, dev->blocksize, 512, 4096);\n\n\tif (dev->queue_mode == NULL_Q_MQ && dev->use_per_node_hctx) {\n\t\tif (dev->submit_queues != nr_online_nodes)\n\t\t\tdev->submit_queues = nr_online_nodes;\n\t} else if (dev->submit_queues > nr_cpu_ids)\n\t\tdev->submit_queues = nr_cpu_ids;\n\telse if (dev->submit_queues == 0)\n\t\tdev->submit_queues = 1;\n\tdev->prev_submit_queues = dev->submit_queues;\n\n\tif (dev->poll_queues > g_poll_queues)\n\t\tdev->poll_queues = g_poll_queues;\n\tdev->prev_poll_queues = dev->poll_queues;\n\n\tdev->queue_mode = min_t(unsigned int, dev->queue_mode, NULL_Q_MQ);\n\tdev->irqmode = min_t(unsigned int, dev->irqmode, NULL_IRQ_TIMER);\n\n\t \n\tif (dev->memory_backed)\n\t\tdev->blocking = true;\n\telse  \n\t\tdev->cache_size = 0;\n\tdev->cache_size = min_t(unsigned long, ULONG_MAX / 1024 / 1024,\n\t\t\t\t\t\tdev->cache_size);\n\tdev->mbps = min_t(unsigned int, 1024 * 40, dev->mbps);\n\t \n\tif (dev->queue_mode == NULL_Q_BIO)\n\t\tdev->mbps = 0;\n\n\tif (dev->zoned &&\n\t    (!dev->zone_size || !is_power_of_2(dev->zone_size))) {\n\t\tpr_err(\"zone_size must be power-of-two\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\nstatic bool __null_setup_fault(struct fault_attr *attr, char *str)\n{\n\tif (!str[0])\n\t\treturn true;\n\n\tif (!setup_fault_attr(attr, str))\n\t\treturn false;\n\n\tattr->verbose = 0;\n\treturn true;\n}\n#endif\n\nstatic bool null_setup_fault(void)\n{\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n\tif (!__null_setup_fault(&null_timeout_attr, g_timeout_str))\n\t\treturn false;\n\tif (!__null_setup_fault(&null_requeue_attr, g_requeue_str))\n\t\treturn false;\n\tif (!__null_setup_fault(&null_init_hctx_attr, g_init_hctx_str))\n\t\treturn false;\n#endif\n\treturn true;\n}\n\nstatic int null_add_dev(struct nullb_device *dev)\n{\n\tstruct nullb *nullb;\n\tint rv;\n\n\trv = null_validate_conf(dev);\n\tif (rv)\n\t\treturn rv;\n\n\tnullb = kzalloc_node(sizeof(*nullb), GFP_KERNEL, dev->home_node);\n\tif (!nullb) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnullb->dev = dev;\n\tdev->nullb = nullb;\n\n\tspin_lock_init(&nullb->lock);\n\n\trv = setup_queues(nullb);\n\tif (rv)\n\t\tgoto out_free_nullb;\n\n\tif (dev->queue_mode == NULL_Q_MQ) {\n\t\tif (shared_tags) {\n\t\t\tnullb->tag_set = &tag_set;\n\t\t\trv = 0;\n\t\t} else {\n\t\t\tnullb->tag_set = &nullb->__tag_set;\n\t\t\trv = null_init_tag_set(nullb, nullb->tag_set);\n\t\t}\n\n\t\tif (rv)\n\t\t\tgoto out_cleanup_queues;\n\n\t\tnullb->tag_set->timeout = 5 * HZ;\n\t\tnullb->disk = blk_mq_alloc_disk(nullb->tag_set, nullb);\n\t\tif (IS_ERR(nullb->disk)) {\n\t\t\trv = PTR_ERR(nullb->disk);\n\t\t\tgoto out_cleanup_tags;\n\t\t}\n\t\tnullb->q = nullb->disk->queue;\n\t} else if (dev->queue_mode == NULL_Q_BIO) {\n\t\trv = -ENOMEM;\n\t\tnullb->disk = blk_alloc_disk(nullb->dev->home_node);\n\t\tif (!nullb->disk)\n\t\t\tgoto out_cleanup_queues;\n\n\t\tnullb->q = nullb->disk->queue;\n\t\trv = init_driver_queues(nullb);\n\t\tif (rv)\n\t\t\tgoto out_cleanup_disk;\n\t}\n\n\tif (dev->mbps) {\n\t\tset_bit(NULLB_DEV_FL_THROTTLED, &dev->flags);\n\t\tnullb_setup_bwtimer(nullb);\n\t}\n\n\tif (dev->cache_size > 0) {\n\t\tset_bit(NULLB_DEV_FL_CACHE, &nullb->dev->flags);\n\t\tblk_queue_write_cache(nullb->q, true, true);\n\t}\n\n\tif (dev->zoned) {\n\t\trv = null_init_zoned_dev(dev, nullb->q);\n\t\tif (rv)\n\t\t\tgoto out_cleanup_disk;\n\t}\n\n\tnullb->q->queuedata = nullb;\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, nullb->q);\n\n\tmutex_lock(&lock);\n\trv = ida_simple_get(&nullb_indexes, 0, 0, GFP_KERNEL);\n\tif (rv < 0) {\n\t\tmutex_unlock(&lock);\n\t\tgoto out_cleanup_zone;\n\t}\n\tnullb->index = rv;\n\tdev->index = rv;\n\tmutex_unlock(&lock);\n\n\tblk_queue_logical_block_size(nullb->q, dev->blocksize);\n\tblk_queue_physical_block_size(nullb->q, dev->blocksize);\n\tif (dev->max_sectors)\n\t\tblk_queue_max_hw_sectors(nullb->q, dev->max_sectors);\n\n\tif (dev->virt_boundary)\n\t\tblk_queue_virt_boundary(nullb->q, PAGE_SIZE - 1);\n\n\tnull_config_discard(nullb);\n\n\tif (config_item_name(&dev->group.cg_item)) {\n\t\t \n\t\tsnprintf(nullb->disk_name, sizeof(nullb->disk_name),\n\t\t\t \"%s\", config_item_name(&dev->group.cg_item));\n\t} else {\n\t\tsprintf(nullb->disk_name, \"nullb%d\", nullb->index);\n\t}\n\n\trv = null_gendisk_register(nullb);\n\tif (rv)\n\t\tgoto out_ida_free;\n\n\tmutex_lock(&lock);\n\tlist_add_tail(&nullb->list, &nullb_list);\n\tmutex_unlock(&lock);\n\n\tpr_info(\"disk %s created\\n\", nullb->disk_name);\n\n\treturn 0;\n\nout_ida_free:\n\tida_free(&nullb_indexes, nullb->index);\nout_cleanup_zone:\n\tnull_free_zoned_dev(dev);\nout_cleanup_disk:\n\tput_disk(nullb->disk);\nout_cleanup_tags:\n\tif (dev->queue_mode == NULL_Q_MQ && nullb->tag_set == &nullb->__tag_set)\n\t\tblk_mq_free_tag_set(nullb->tag_set);\nout_cleanup_queues:\n\tcleanup_queues(nullb);\nout_free_nullb:\n\tkfree(nullb);\n\tdev->nullb = NULL;\nout:\n\treturn rv;\n}\n\nstatic struct nullb *null_find_dev_by_name(const char *name)\n{\n\tstruct nullb *nullb = NULL, *nb;\n\n\tmutex_lock(&lock);\n\tlist_for_each_entry(nb, &nullb_list, list) {\n\t\tif (strcmp(nb->disk_name, name) == 0) {\n\t\t\tnullb = nb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&lock);\n\n\treturn nullb;\n}\n\nstatic int null_create_dev(void)\n{\n\tstruct nullb_device *dev;\n\tint ret;\n\n\tdev = null_alloc_dev();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tret = null_add_dev(dev);\n\tif (ret) {\n\t\tnull_free_dev(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void null_destroy_dev(struct nullb *nullb)\n{\n\tstruct nullb_device *dev = nullb->dev;\n\n\tnull_del_dev(nullb);\n\tnull_free_device_storage(dev, false);\n\tnull_free_dev(dev);\n}\n\nstatic int __init null_init(void)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tstruct nullb *nullb;\n\n\tif (g_bs > PAGE_SIZE) {\n\t\tpr_warn(\"invalid block size\\n\");\n\t\tpr_warn(\"defaults block size to %lu\\n\", PAGE_SIZE);\n\t\tg_bs = PAGE_SIZE;\n\t}\n\n\tif (g_home_node != NUMA_NO_NODE && g_home_node >= nr_online_nodes) {\n\t\tpr_err(\"invalid home_node value\\n\");\n\t\tg_home_node = NUMA_NO_NODE;\n\t}\n\n\tif (!null_setup_fault())\n\t\treturn -EINVAL;\n\n\tif (g_queue_mode == NULL_Q_RQ) {\n\t\tpr_err(\"legacy IO path is no longer available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (g_queue_mode == NULL_Q_MQ && g_use_per_node_hctx) {\n\t\tif (g_submit_queues != nr_online_nodes) {\n\t\t\tpr_warn(\"submit_queues param is set to %u.\\n\",\n\t\t\t\tnr_online_nodes);\n\t\t\tg_submit_queues = nr_online_nodes;\n\t\t}\n\t} else if (g_submit_queues > nr_cpu_ids) {\n\t\tg_submit_queues = nr_cpu_ids;\n\t} else if (g_submit_queues <= 0) {\n\t\tg_submit_queues = 1;\n\t}\n\n\tif (g_queue_mode == NULL_Q_MQ && shared_tags) {\n\t\tret = null_init_tag_set(NULL, &tag_set);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tconfig_group_init(&nullb_subsys.su_group);\n\tmutex_init(&nullb_subsys.su_mutex);\n\n\tret = configfs_register_subsystem(&nullb_subsys);\n\tif (ret)\n\t\tgoto err_tagset;\n\n\tmutex_init(&lock);\n\n\tnull_major = register_blkdev(0, \"nullb\");\n\tif (null_major < 0) {\n\t\tret = null_major;\n\t\tgoto err_conf;\n\t}\n\n\tfor (i = 0; i < nr_devices; i++) {\n\t\tret = null_create_dev();\n\t\tif (ret)\n\t\t\tgoto err_dev;\n\t}\n\n\tpr_info(\"module loaded\\n\");\n\treturn 0;\n\nerr_dev:\n\twhile (!list_empty(&nullb_list)) {\n\t\tnullb = list_entry(nullb_list.next, struct nullb, list);\n\t\tnull_destroy_dev(nullb);\n\t}\n\tunregister_blkdev(null_major, \"nullb\");\nerr_conf:\n\tconfigfs_unregister_subsystem(&nullb_subsys);\nerr_tagset:\n\tif (g_queue_mode == NULL_Q_MQ && shared_tags)\n\t\tblk_mq_free_tag_set(&tag_set);\n\treturn ret;\n}\n\nstatic void __exit null_exit(void)\n{\n\tstruct nullb *nullb;\n\n\tconfigfs_unregister_subsystem(&nullb_subsys);\n\n\tunregister_blkdev(null_major, \"nullb\");\n\n\tmutex_lock(&lock);\n\twhile (!list_empty(&nullb_list)) {\n\t\tnullb = list_entry(nullb_list.next, struct nullb, list);\n\t\tnull_destroy_dev(nullb);\n\t}\n\tmutex_unlock(&lock);\n\n\tif (g_queue_mode == NULL_Q_MQ && shared_tags)\n\t\tblk_mq_free_tag_set(&tag_set);\n}\n\nmodule_init(null_init);\nmodule_exit(null_exit);\n\nMODULE_AUTHOR(\"Jens Axboe <axboe@kernel.dk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}