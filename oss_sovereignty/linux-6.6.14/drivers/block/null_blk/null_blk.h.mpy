{
  "module_name": "null_blk.h",
  "hash_id": "5192ae70aeaa20d7d3effdf8352a26e32a694afdfb3a82c41ecdd71c41ccebe7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/null_blk/null_blk.h",
  "human_readable_source": " \n#ifndef __BLK_NULL_BLK_H\n#define __BLK_NULL_BLK_H\n\n#undef pr_fmt\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/blk-mq.h>\n#include <linux/hrtimer.h>\n#include <linux/configfs.h>\n#include <linux/badblocks.h>\n#include <linux/fault-inject.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n\nstruct nullb_cmd {\n\tunion {\n\t\tstruct request *rq;\n\t\tstruct bio *bio;\n\t};\n\tunsigned int tag;\n\tblk_status_t error;\n\tbool fake_timeout;\n\tstruct nullb_queue *nq;\n\tstruct hrtimer timer;\n};\n\nstruct nullb_queue {\n\tunsigned long *tag_map;\n\twait_queue_head_t wait;\n\tunsigned int queue_depth;\n\tstruct nullb_device *dev;\n\tunsigned int requeue_selection;\n\n\tstruct list_head poll_list;\n\tspinlock_t poll_lock;\n\n\tstruct nullb_cmd *cmds;\n};\n\nstruct nullb_zone {\n\t \n\tunion {\n\t\tspinlock_t spinlock;\n\t\tstruct mutex mutex;\n\t};\n\tenum blk_zone_type type;\n\tenum blk_zone_cond cond;\n\tsector_t start;\n\tsector_t wp;\n\tunsigned int len;\n\tunsigned int capacity;\n};\n\n \nenum {\n\tNULL_Q_BIO\t= 0,\n\tNULL_Q_RQ\t= 1,\n\tNULL_Q_MQ\t= 2,\n};\n\nstruct nullb_device {\n\tstruct nullb *nullb;\n\tstruct config_group group;\n#ifdef CONFIG_BLK_DEV_NULL_BLK_FAULT_INJECTION\n\tstruct fault_config timeout_config;\n\tstruct fault_config requeue_config;\n\tstruct fault_config init_hctx_fault_config;\n#endif\n\tstruct radix_tree_root data;  \n\tstruct radix_tree_root cache;  \n\tunsigned long flags;  \n\tunsigned int curr_cache;\n\tstruct badblocks badblocks;\n\n\tunsigned int nr_zones;\n\tunsigned int nr_zones_imp_open;\n\tunsigned int nr_zones_exp_open;\n\tunsigned int nr_zones_closed;\n\tunsigned int imp_close_zone_no;\n\tstruct nullb_zone *zones;\n\tsector_t zone_size_sects;\n\tbool need_zone_res_mgmt;\n\tspinlock_t zone_res_lock;\n\n\tunsigned long size;  \n\tunsigned long completion_nsec;  \n\tunsigned long cache_size;  \n\tunsigned long zone_size;  \n\tunsigned long zone_capacity;  \n\tunsigned int zone_nr_conv;  \n\tunsigned int zone_max_open;  \n\tunsigned int zone_max_active;  \n\tunsigned int submit_queues;  \n\tunsigned int prev_submit_queues;  \n\tunsigned int poll_queues;  \n\tunsigned int prev_poll_queues;  \n\tunsigned int home_node;  \n\tunsigned int queue_mode;  \n\tunsigned int blocksize;  \n\tunsigned int max_sectors;  \n\tunsigned int irqmode;  \n\tunsigned int hw_queue_depth;  \n\tunsigned int index;  \n\tunsigned int mbps;  \n\tbool blocking;  \n\tbool use_per_node_hctx;  \n\tbool power;  \n\tbool memory_backed;  \n\tbool discard;  \n\tbool zoned;  \n\tbool virt_boundary;  \n\tbool no_sched;  \n\tbool shared_tag_bitmap;  \n};\n\nstruct nullb {\n\tstruct nullb_device *dev;\n\tstruct list_head list;\n\tunsigned int index;\n\tstruct request_queue *q;\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set *tag_set;\n\tstruct blk_mq_tag_set __tag_set;\n\tunsigned int queue_depth;\n\tatomic_long_t cur_bytes;\n\tstruct hrtimer bw_timer;\n\tunsigned long cache_flush_pos;\n\tspinlock_t lock;\n\n\tstruct nullb_queue *queues;\n\tunsigned int nr_queues;\n\tchar disk_name[DISK_NAME_LEN];\n};\n\nblk_status_t null_handle_discard(struct nullb_device *dev, sector_t sector,\n\t\t\t\t sector_t nr_sectors);\nblk_status_t null_process_cmd(struct nullb_cmd *cmd, enum req_op op,\n\t\t\t      sector_t sector, unsigned int nr_sectors);\n\n#ifdef CONFIG_BLK_DEV_ZONED\nint null_init_zoned_dev(struct nullb_device *dev, struct request_queue *q);\nint null_register_zoned_dev(struct nullb *nullb);\nvoid null_free_zoned_dev(struct nullb_device *dev);\nint null_report_zones(struct gendisk *disk, sector_t sector,\n\t\t      unsigned int nr_zones, report_zones_cb cb, void *data);\nblk_status_t null_process_zoned_cmd(struct nullb_cmd *cmd, enum req_op op,\n\t\t\t\t    sector_t sector, sector_t nr_sectors);\nsize_t null_zone_valid_read_len(struct nullb *nullb,\n\t\t\t\tsector_t sector, unsigned int len);\nssize_t zone_cond_store(struct nullb_device *dev, const char *page,\n\t\t\tsize_t count, enum blk_zone_cond cond);\n#else\nstatic inline int null_init_zoned_dev(struct nullb_device *dev,\n\t\t\t\t      struct request_queue *q)\n{\n\tpr_err(\"CONFIG_BLK_DEV_ZONED not enabled\\n\");\n\treturn -EINVAL;\n}\nstatic inline int null_register_zoned_dev(struct nullb *nullb)\n{\n\treturn -ENODEV;\n}\nstatic inline void null_free_zoned_dev(struct nullb_device *dev) {}\nstatic inline blk_status_t null_process_zoned_cmd(struct nullb_cmd *cmd,\n\t\t\tenum req_op op, sector_t sector, sector_t nr_sectors)\n{\n\treturn BLK_STS_NOTSUPP;\n}\nstatic inline size_t null_zone_valid_read_len(struct nullb *nullb,\n\t\t\t\t\t      sector_t sector,\n\t\t\t\t\t      unsigned int len)\n{\n\treturn len;\n}\nstatic inline ssize_t zone_cond_store(struct nullb_device *dev,\n\t\t\t\t      const char *page, size_t count,\n\t\t\t\t      enum blk_zone_cond cond)\n{\n\treturn -EOPNOTSUPP;\n}\n#define null_report_zones\tNULL\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}