{
  "module_name": "rnbd-clt-sysfs.c",
  "hash_id": "bb3b68bad55acb04aaafc4caefdf5f8ef1abcdcfdfd39948928965d2ffff8c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/rnbd/rnbd-clt-sysfs.c",
  "human_readable_source": "\n \n\n#undef pr_fmt\n#define pr_fmt(fmt) KBUILD_MODNAME \" L\" __stringify(__LINE__) \": \" fmt\n\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <rdma/ib.h>\n#include <rdma/rdma_cm.h>\n\n#include \"rnbd-clt.h\"\n\nstatic struct device *rnbd_dev;\nstatic const struct class rnbd_dev_class = {\n\t.name = \"rnbd-client\",\n};\nstatic struct kobject *rnbd_devs_kobj;\n\nenum {\n\tRNBD_OPT_ERR\t\t= 0,\n\tRNBD_OPT_DEST_PORT\t= 1 << 0,\n\tRNBD_OPT_PATH\t\t= 1 << 1,\n\tRNBD_OPT_DEV_PATH\t= 1 << 2,\n\tRNBD_OPT_ACCESS_MODE\t= 1 << 3,\n\tRNBD_OPT_SESSNAME\t= 1 << 6,\n\tRNBD_OPT_NR_POLL_QUEUES\t= 1 << 7,\n};\n\nstatic const unsigned int rnbd_opt_mandatory[] = {\n\tRNBD_OPT_DEV_PATH,\n\tRNBD_OPT_SESSNAME,\n};\n\nstatic const match_table_t rnbd_opt_tokens = {\n\t{RNBD_OPT_PATH,\t\t\t\"path=%s\"\t\t},\n\t{RNBD_OPT_DEV_PATH,\t\t\"device_path=%s\"\t},\n\t{RNBD_OPT_DEST_PORT,\t\t\"dest_port=%d\"\t\t},\n\t{RNBD_OPT_ACCESS_MODE,\t\t\"access_mode=%s\"\t},\n\t{RNBD_OPT_SESSNAME,\t\t\"sessname=%s\"\t\t},\n\t{RNBD_OPT_NR_POLL_QUEUES,\t\"nr_poll_queues=%d\"\t},\n\t{RNBD_OPT_ERR,\t\t\tNULL\t\t\t},\n};\n\nstruct rnbd_map_options {\n\tchar *sessname;\n\tstruct rtrs_addr *paths;\n\tsize_t *path_cnt;\n\tchar *pathname;\n\tu16 *dest_port;\n\tenum rnbd_access_mode *access_mode;\n\tu32 *nr_poll_queues;\n};\n\nstatic int rnbd_clt_parse_map_options(const char *buf, size_t max_path_cnt,\n\t\t\t\t       struct rnbd_map_options *opt)\n{\n\tchar *options, *sep_opt;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint opt_mask = 0;\n\tint token;\n\tint ret = -EINVAL;\n\tint nr_poll_queues = 0;\n\tint dest_port = 0;\n\tint p_cnt = 0;\n\tint i;\n\n\toptions = kstrdup(buf, GFP_KERNEL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\tsep_opt = strstrip(options);\n\twhile ((p = strsep(&sep_opt, \" \")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, rnbd_opt_tokens, args);\n\t\topt_mask |= token;\n\n\t\tswitch (token) {\n\t\tcase RNBD_OPT_SESSNAME:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(p) > NAME_MAX) {\n\t\t\t\tpr_err(\"map_device: sessname too long\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tkfree(p);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrscpy(opt->sessname, p, NAME_MAX);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\n\t\tcase RNBD_OPT_PATH:\n\t\t\tif (p_cnt >= max_path_cnt) {\n\t\t\t\tpr_err(\"map_device: too many (> %zu) paths provided\\n\",\n\t\t\t\t       max_path_cnt);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = rtrs_addr_to_sockaddr(p, strlen(p),\n\t\t\t\t\t\t    *opt->dest_port,\n\t\t\t\t\t\t    &opt->paths[p_cnt]);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Can't parse path %s: %d\\n\", p, ret);\n\t\t\t\tkfree(p);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tp_cnt++;\n\n\t\t\tkfree(p);\n\t\t\tbreak;\n\n\t\tcase RNBD_OPT_DEV_PATH:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(p) > NAME_MAX) {\n\t\t\t\tpr_err(\"map_device: Device path too long\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tkfree(p);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrscpy(opt->pathname, p, NAME_MAX);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\n\t\tcase RNBD_OPT_DEST_PORT:\n\t\t\tif (match_int(args, &dest_port) || dest_port < 0 ||\n\t\t\t    dest_port > 65535) {\n\t\t\t\tpr_err(\"bad destination port number parameter '%d'\\n\",\n\t\t\t\t       dest_port);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*opt->dest_port = dest_port;\n\t\t\tbreak;\n\n\t\tcase RNBD_OPT_ACCESS_MODE:\n\t\t\tp = match_strdup(args);\n\t\t\tif (!p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!strcmp(p, \"ro\")) {\n\t\t\t\t*opt->access_mode = RNBD_ACCESS_RO;\n\t\t\t} else if (!strcmp(p, \"rw\")) {\n\t\t\t\t*opt->access_mode = RNBD_ACCESS_RW;\n\t\t\t} else if (!strcmp(p, \"migration\")) {\n\t\t\t\t*opt->access_mode = RNBD_ACCESS_MIGRATION;\n\t\t\t} else {\n\t\t\t\tpr_err(\"map_device: Invalid access_mode: '%s'\\n\",\n\t\t\t\t       p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tkfree(p);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tkfree(p);\n\t\t\tbreak;\n\n\t\tcase RNBD_OPT_NR_POLL_QUEUES:\n\t\t\tif (match_int(args, &nr_poll_queues) || nr_poll_queues < -1 ||\n\t\t\t    nr_poll_queues > (int)nr_cpu_ids) {\n\t\t\t\tpr_err(\"bad nr_poll_queues parameter '%d'\\n\",\n\t\t\t\t       nr_poll_queues);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (nr_poll_queues == -1)\n\t\t\t\tnr_poll_queues = nr_cpu_ids;\n\t\t\t*opt->nr_poll_queues = nr_poll_queues;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"map_device: Unknown parameter or missing value '%s'\\n\",\n\t\t\t       p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rnbd_opt_mandatory); i++) {\n\t\tif ((opt_mask & rnbd_opt_mandatory[i])) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_err(\"map_device: Parameters missing\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t*opt->path_cnt = p_cnt;\n\tkfree(options);\n\treturn ret;\n}\n\nstatic ssize_t state_show(struct kobject *kobj,\n\t\t\t  struct kobj_attribute *attr, char *page)\n{\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\tswitch (dev->dev_state) {\n\tcase DEV_STATE_INIT:\n\t\treturn sysfs_emit(page, \"init\\n\");\n\tcase DEV_STATE_MAPPED:\n\t\t \n\t\treturn sysfs_emit(page, \"open\\n\");\n\tcase DEV_STATE_MAPPED_DISCONNECTED:\n\t\t \n\t\treturn sysfs_emit(page, \"closed\\n\");\n\tcase DEV_STATE_UNMAPPED:\n\t\treturn sysfs_emit(page, \"unmapped\\n\");\n\tdefault:\n\t\treturn sysfs_emit(page, \"unknown\\n\");\n\t}\n}\n\nstatic struct kobj_attribute rnbd_clt_state_attr = __ATTR_RO(state);\n\nstatic ssize_t nr_poll_queues_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *page)\n{\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\treturn sysfs_emit(page, \"%d\\n\", dev->nr_poll_queues);\n}\n\nstatic struct kobj_attribute rnbd_clt_nr_poll_queues =\n\t__ATTR_RO(nr_poll_queues);\n\nstatic ssize_t mapping_path_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *page)\n{\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\treturn sysfs_emit(page, \"%s\\n\", dev->pathname);\n}\n\nstatic struct kobj_attribute rnbd_clt_mapping_path_attr =\n\t__ATTR_RO(mapping_path);\n\nstatic ssize_t access_mode_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\treturn sysfs_emit(page, \"%s\\n\", rnbd_access_modes[dev->access_mode].str);\n}\n\nstatic struct kobj_attribute rnbd_clt_access_mode =\n\t__ATTR_RO(access_mode);\n\nstatic ssize_t rnbd_clt_unmap_dev_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\treturn sysfs_emit(page, \"Usage: echo <normal|force> > %s\\n\",\n\t\t\t  attr->attr.name);\n}\n\nstatic ssize_t rnbd_clt_unmap_dev_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct rnbd_clt_dev *dev;\n\tchar *opt, *options;\n\tbool force;\n\tint err;\n\n\topt = kstrdup(buf, GFP_KERNEL);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\n\toptions = strstrip(opt);\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\tif (sysfs_streq(options, \"normal\")) {\n\t\tforce = false;\n\t} else if (sysfs_streq(options, \"force\")) {\n\t\tforce = true;\n\t} else {\n\t\trnbd_clt_err(dev,\n\t\t\t      \"unmap_device: Invalid value: %s\\n\",\n\t\t\t      options);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trnbd_clt_info(dev, \"Unmapping device, option: %s.\\n\",\n\t\t       force ? \"force\" : \"normal\");\n\n\t \n\tif (!try_module_get(THIS_MODULE)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\terr = rnbd_clt_unmap_device(dev, force, &attr->attr);\n\tif (err) {\n\t\tif (err != -EALREADY)\n\t\t\trnbd_clt_err(dev, \"unmap_device: %d\\n\",  err);\n\t\tgoto module_put;\n\t}\n\n\t \n\n\terr = count;\n\nmodule_put:\n\tmodule_put(THIS_MODULE);\nout:\n\tkfree(opt);\n\n\treturn err;\n}\n\nstatic struct kobj_attribute rnbd_clt_unmap_device_attr =\n\t__ATTR(unmap_device, 0644, rnbd_clt_unmap_dev_show,\n\t       rnbd_clt_unmap_dev_store);\n\nstatic ssize_t rnbd_clt_resize_dev_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *page)\n{\n\treturn sysfs_emit(page, \"Usage: echo <new size in sectors> > %s\\n\",\n\t\t\t  attr->attr.name);\n}\n\nstatic ssize_t rnbd_clt_resize_dev_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\tunsigned long sectors;\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\tret = kstrtoul(buf, 0, &sectors);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rnbd_clt_resize_disk(dev, sectors);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic struct kobj_attribute rnbd_clt_resize_dev_attr =\n\t__ATTR(resize, 0644, rnbd_clt_resize_dev_show,\n\t       rnbd_clt_resize_dev_store);\n\nstatic ssize_t rnbd_clt_remap_dev_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\treturn sysfs_emit(page, \"Usage: echo <1> > %s\\n\", attr->attr.name);\n}\n\nstatic ssize_t rnbd_clt_remap_dev_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct rnbd_clt_dev *dev;\n\tchar *opt, *options;\n\tint err;\n\n\topt = kstrdup(buf, GFP_KERNEL);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\n\toptions = strstrip(opt);\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\tif (!sysfs_streq(options, \"1\")) {\n\t\trnbd_clt_err(dev,\n\t\t\t      \"remap_device: Invalid value: %s\\n\",\n\t\t\t      options);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = rnbd_clt_remap_device(dev);\n\tif (likely(!err))\n\t\terr = count;\n\nout:\n\tkfree(opt);\n\n\treturn err;\n}\n\nstatic struct kobj_attribute rnbd_clt_remap_device_attr =\n\t__ATTR(remap_device, 0644, rnbd_clt_remap_dev_show,\n\t       rnbd_clt_remap_dev_store);\n\nstatic ssize_t session_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    char *page)\n{\n\tstruct rnbd_clt_dev *dev;\n\n\tdev = container_of(kobj, struct rnbd_clt_dev, kobj);\n\n\treturn sysfs_emit(page, \"%s\\n\", dev->sess->sessname);\n}\n\nstatic struct kobj_attribute rnbd_clt_session_attr =\n\t__ATTR_RO(session);\n\nstatic struct attribute *rnbd_dev_attrs[] = {\n\t&rnbd_clt_unmap_device_attr.attr,\n\t&rnbd_clt_resize_dev_attr.attr,\n\t&rnbd_clt_remap_device_attr.attr,\n\t&rnbd_clt_mapping_path_attr.attr,\n\t&rnbd_clt_state_attr.attr,\n\t&rnbd_clt_session_attr.attr,\n\t&rnbd_clt_access_mode.attr,\n\t&rnbd_clt_nr_poll_queues.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(rnbd_dev);\n\nvoid rnbd_clt_remove_dev_symlink(struct rnbd_clt_dev *dev)\n{\n\t \n\tif (dev->blk_symlink_name) {\n\t\tif (try_module_get(THIS_MODULE)) {\n\t\t\tsysfs_remove_link(rnbd_devs_kobj, dev->blk_symlink_name);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t}\n\t\t \n\t\tkfree(dev->blk_symlink_name);\n\t\tdev->blk_symlink_name = NULL;\n\t}\n}\n\nstatic struct kobj_type rnbd_dev_ktype = {\n\t.sysfs_ops      = &kobj_sysfs_ops,\n\t.default_groups = rnbd_dev_groups,\n};\n\nstatic int rnbd_clt_add_dev_kobj(struct rnbd_clt_dev *dev)\n{\n\tint ret;\n\tstruct kobject *gd_kobj = &disk_to_dev(dev->gd)->kobj;\n\n\tret = kobject_init_and_add(&dev->kobj, &rnbd_dev_ktype, gd_kobj, \"%s\",\n\t\t\t\t   \"rnbd\");\n\tif (ret) {\n\t\trnbd_clt_err(dev, \"Failed to create device sysfs dir, err: %d\\n\",\n\t\t\t      ret);\n\t\tkobject_put(&dev->kobj);\n\t}\n\tkobject_uevent(gd_kobj, KOBJ_ONLINE);\n\n\treturn ret;\n}\n\nstatic ssize_t rnbd_clt_map_device_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *page)\n{\n\treturn sysfs_emit(page,\n\t\t\t  \"Usage: echo \\\"[dest_port=server port number] sessname=<name of the rtrs session> path=<[srcaddr@]dstaddr> [path=<[srcaddr@]dstaddr>] device_path=<full path on remote side> [access_mode=<ro|rw|migration>] [nr_poll_queues=<number of queues>]\\\" > %s\\n\\naddr ::= [ ip:<ipv4> | ip:<ipv6> | gid:<gid> ]\\n\",\n\t\t\t attr->attr.name);\n}\n\nstatic int rnbd_clt_get_path_name(struct rnbd_clt_dev *dev, char *buf,\n\t\t\t\t   size_t len)\n{\n\tint ret;\n\tchar pathname[NAME_MAX], *s;\n\n\tstrscpy(pathname, dev->pathname, sizeof(pathname));\n\twhile ((s = strchr(pathname, '/')))\n\t\ts[0] = '!';\n\n\tret = snprintf(buf, len, \"%s@%s\", pathname, dev->sess->sessname);\n\tif (ret >= len)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}\n\nstatic int rnbd_clt_add_dev_symlink(struct rnbd_clt_dev *dev)\n{\n\tstruct kobject *gd_kobj = &disk_to_dev(dev->gd)->kobj;\n\tint ret, len;\n\n\tlen = strlen(dev->pathname) + strlen(dev->sess->sessname) + 2;\n\tdev->blk_symlink_name = kzalloc(len, GFP_KERNEL);\n\tif (!dev->blk_symlink_name) {\n\t\trnbd_clt_err(dev, \"Failed to allocate memory for blk_symlink_name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = rnbd_clt_get_path_name(dev, dev->blk_symlink_name,\n\t\t\t\t      len);\n\tif (ret) {\n\t\trnbd_clt_err(dev, \"Failed to get /sys/block symlink path, err: %d\\n\",\n\t\t\t      ret);\n\t\tgoto out_err;\n\t}\n\n\tret = sysfs_create_link(rnbd_devs_kobj, gd_kobj,\n\t\t\t\tdev->blk_symlink_name);\n\tif (ret) {\n\t\trnbd_clt_err(dev, \"Creating /sys/block symlink failed, err: %d\\n\",\n\t\t\t      ret);\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tkfree(dev->blk_symlink_name);\n\tdev->blk_symlink_name = NULL ;\n\treturn ret;\n}\n\nstatic ssize_t rnbd_clt_map_device_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct rnbd_clt_dev *dev;\n\tstruct rnbd_map_options opt;\n\tint ret;\n\tchar pathname[NAME_MAX];\n\tchar sessname[NAME_MAX];\n\tenum rnbd_access_mode access_mode = RNBD_ACCESS_RW;\n\tu16 port_nr = RTRS_PORT;\n\tu32 nr_poll_queues = 0;\n\n\tstruct sockaddr_storage *addrs;\n\tstruct rtrs_addr paths[6];\n\tsize_t path_cnt;\n\n\topt.sessname = sessname;\n\topt.paths = paths;\n\topt.path_cnt = &path_cnt;\n\topt.pathname = pathname;\n\topt.dest_port = &port_nr;\n\topt.access_mode = &access_mode;\n\topt.nr_poll_queues = &nr_poll_queues;\n\taddrs = kcalloc(ARRAY_SIZE(paths) * 2, sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn -ENOMEM;\n\n\tfor (path_cnt = 0; path_cnt < ARRAY_SIZE(paths); path_cnt++) {\n\t\tpaths[path_cnt].src = &addrs[path_cnt * 2];\n\t\tpaths[path_cnt].dst = &addrs[path_cnt * 2 + 1];\n\t}\n\n\tret = rnbd_clt_parse_map_options(buf, ARRAY_SIZE(paths), &opt);\n\tif (ret)\n\t\tgoto out;\n\n\tpr_info(\"Mapping device %s on session %s, (access_mode: %s, nr_poll_queues: %d)\\n\",\n\t\tpathname, sessname,\n\t\trnbd_access_modes[access_mode].str,\n\t\tnr_poll_queues);\n\n\tdev = rnbd_clt_map_device(sessname, paths, path_cnt, port_nr, pathname,\n\t\t\t\t  access_mode, nr_poll_queues);\n\tif (IS_ERR(dev)) {\n\t\tret = PTR_ERR(dev);\n\t\tgoto out;\n\t}\n\n\tret = rnbd_clt_add_dev_kobj(dev);\n\tif (ret)\n\t\tgoto unmap_dev;\n\n\tret = rnbd_clt_add_dev_symlink(dev);\n\tif (ret)\n\t\tgoto unmap_dev;\n\n\tkfree(addrs);\n\treturn count;\n\nunmap_dev:\n\trnbd_clt_unmap_device(dev, true, NULL);\nout:\n\tkfree(addrs);\n\treturn ret;\n}\n\nstatic struct kobj_attribute rnbd_clt_map_device_attr =\n\t__ATTR(map_device, 0644,\n\t       rnbd_clt_map_device_show, rnbd_clt_map_device_store);\n\nstatic struct attribute *default_attrs[] = {\n\t&rnbd_clt_map_device_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group default_attr_group = {\n\t.attrs = default_attrs,\n};\n\nstatic const struct attribute_group *default_attr_groups[] = {\n\t&default_attr_group,\n\tNULL,\n};\n\nint rnbd_clt_create_sysfs_files(void)\n{\n\tint err;\n\n\terr = class_register(&rnbd_dev_class);\n\tif (err)\n\t\treturn err;\n\n\trnbd_dev = device_create_with_groups(&rnbd_dev_class, NULL,\n\t\t\t\t\t      MKDEV(0, 0), NULL,\n\t\t\t\t\t      default_attr_groups, \"ctl\");\n\tif (IS_ERR(rnbd_dev)) {\n\t\terr = PTR_ERR(rnbd_dev);\n\t\tgoto cls_destroy;\n\t}\n\trnbd_devs_kobj = kobject_create_and_add(\"devices\", &rnbd_dev->kobj);\n\tif (!rnbd_devs_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto dev_destroy;\n\t}\n\n\treturn 0;\n\ndev_destroy:\n\tdevice_destroy(&rnbd_dev_class, MKDEV(0, 0));\ncls_destroy:\n\tclass_unregister(&rnbd_dev_class);\n\n\treturn err;\n}\n\nvoid rnbd_clt_destroy_sysfs_files(void)\n{\n\tsysfs_remove_group(&rnbd_dev->kobj, &default_attr_group);\n\tkobject_del(rnbd_devs_kobj);\n\tkobject_put(rnbd_devs_kobj);\n\tdevice_destroy(&rnbd_dev_class, MKDEV(0, 0));\n\tclass_unregister(&rnbd_dev_class);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}