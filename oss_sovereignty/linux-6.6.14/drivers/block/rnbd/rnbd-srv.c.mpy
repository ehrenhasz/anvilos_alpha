{
  "module_name": "rnbd-srv.c",
  "hash_id": "a03fb0dfafe90830fe556313331947be30a14663bde6e8a13c7cf7a06795f0b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/rnbd/rnbd-srv.c",
  "human_readable_source": "\n \n#undef pr_fmt\n#define pr_fmt(fmt) KBUILD_MODNAME \" L\" __stringify(__LINE__) \": \" fmt\n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\n#include \"rnbd-srv.h\"\n#include \"rnbd-srv-trace.h\"\n\nMODULE_DESCRIPTION(\"RDMA Network Block Device Server\");\nMODULE_LICENSE(\"GPL\");\n\nstatic u16 port_nr = RTRS_PORT;\n\nmodule_param_named(port_nr, port_nr, ushort, 0444);\nMODULE_PARM_DESC(port_nr,\n\t\t \"The port number the server is listening on (default: \"\n\t\t __stringify(RTRS_PORT)\")\");\n\n#define DEFAULT_DEV_SEARCH_PATH \"/\"\n\nstatic char dev_search_path[PATH_MAX] = DEFAULT_DEV_SEARCH_PATH;\n\nstatic int dev_search_path_set(const char *val, const struct kernel_param *kp)\n{\n\tconst char *p = strrchr(val, '\\n') ? : val + strlen(val);\n\n\tif (strlen(val) >= sizeof(dev_search_path))\n\t\treturn -EINVAL;\n\n\tsnprintf(dev_search_path, sizeof(dev_search_path), \"%.*s\",\n\t\t (int)(p - val), val);\n\n\tpr_info(\"dev_search_path changed to '%s'\\n\", dev_search_path);\n\n\treturn 0;\n}\n\nstatic struct kparam_string dev_search_path_kparam_str = {\n\t.maxlen\t= sizeof(dev_search_path),\n\t.string\t= dev_search_path\n};\n\nstatic const struct kernel_param_ops dev_search_path_ops = {\n\t.set\t= dev_search_path_set,\n\t.get\t= param_get_string,\n};\n\nmodule_param_cb(dev_search_path, &dev_search_path_ops,\n\t\t&dev_search_path_kparam_str, 0444);\nMODULE_PARM_DESC(dev_search_path,\n\t\t \"Sets the dev_search_path. When a device is mapped this path is prepended to the device path from the map device operation.  If %SESSNAME% is specified in a path, then device will be searched in a session namespace. (default: \"\n\t\t DEFAULT_DEV_SEARCH_PATH \")\");\n\nstatic DEFINE_MUTEX(sess_lock);\nstatic DEFINE_SPINLOCK(dev_lock);\n\nstatic LIST_HEAD(sess_list);\nstatic LIST_HEAD(dev_list);\n\nstruct rnbd_io_private {\n\tstruct rtrs_srv_op\t\t*id;\n\tstruct rnbd_srv_sess_dev\t*sess_dev;\n};\n\nstatic void rnbd_sess_dev_release(struct kref *kref)\n{\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\n\tsess_dev = container_of(kref, struct rnbd_srv_sess_dev, kref);\n\tcomplete(sess_dev->destroy_comp);\n}\n\nstatic inline void rnbd_put_sess_dev(struct rnbd_srv_sess_dev *sess_dev)\n{\n\tkref_put(&sess_dev->kref, rnbd_sess_dev_release);\n}\n\nstatic struct rnbd_srv_sess_dev *\nrnbd_get_sess_dev(int dev_id, struct rnbd_srv_session *srv_sess)\n{\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tsess_dev = xa_load(&srv_sess->index_idr, dev_id);\n\tif (sess_dev)\n\t\tret = kref_get_unless_zero(&sess_dev->kref);\n\trcu_read_unlock();\n\n\tif (!ret)\n\t\treturn ERR_PTR(-ENXIO);\n\n\treturn sess_dev;\n}\n\nstatic void rnbd_dev_bi_end_io(struct bio *bio)\n{\n\tstruct rnbd_io_private *rnbd_priv = bio->bi_private;\n\tstruct rnbd_srv_sess_dev *sess_dev = rnbd_priv->sess_dev;\n\n\trnbd_put_sess_dev(sess_dev);\n\trtrs_srv_resp_rdma(rnbd_priv->id, blk_status_to_errno(bio->bi_status));\n\n\tkfree(rnbd_priv);\n\tbio_put(bio);\n}\n\nstatic int process_rdma(struct rnbd_srv_session *srv_sess,\n\t\t\tstruct rtrs_srv_op *id, void *data, u32 datalen,\n\t\t\tconst void *usr, size_t usrlen)\n{\n\tconst struct rnbd_msg_io *msg = usr;\n\tstruct rnbd_io_private *priv;\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\tu32 dev_id;\n\tint err;\n\tstruct bio *bio;\n\tshort prio;\n\n\ttrace_process_rdma(srv_sess, msg, id, datalen, usrlen);\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_id = le32_to_cpu(msg->device_id);\n\n\tsess_dev = rnbd_get_sess_dev(dev_id, srv_sess);\n\tif (IS_ERR(sess_dev)) {\n\t\tpr_err_ratelimited(\"Got I/O request on session %s for unknown device id %d\\n\",\n\t\t\t\t   srv_sess->sessname, dev_id);\n\t\terr = -ENOTCONN;\n\t\tgoto err;\n\t}\n\n\tpriv->sess_dev = sess_dev;\n\tpriv->id = id;\n\n\tbio = bio_alloc(sess_dev->bdev, 1,\n\t\t\trnbd_to_bio_flags(le32_to_cpu(msg->rw)), GFP_KERNEL);\n\tif (bio_add_page(bio, virt_to_page(data), datalen,\n\t\t\toffset_in_page(data)) != datalen) {\n\t\trnbd_srv_err(sess_dev, \"Failed to map data to bio\\n\");\n\t\terr = -EINVAL;\n\t\tgoto bio_put;\n\t}\n\n\tbio->bi_end_io = rnbd_dev_bi_end_io;\n\tbio->bi_private = priv;\n\tbio->bi_iter.bi_sector = le64_to_cpu(msg->sector);\n\tbio->bi_iter.bi_size = le32_to_cpu(msg->bi_size);\n\tprio = srv_sess->ver < RNBD_PROTO_VER_MAJOR ||\n\t       usrlen < sizeof(*msg) ? 0 : le16_to_cpu(msg->prio);\n\tbio_set_prio(bio, prio);\n\n\tsubmit_bio(bio);\n\n\treturn 0;\n\nbio_put:\n\tbio_put(bio);\n\trnbd_put_sess_dev(sess_dev);\nerr:\n\tkfree(priv);\n\treturn err;\n}\n\nstatic void destroy_device(struct kref *kref)\n{\n\tstruct rnbd_srv_dev *dev = container_of(kref, struct rnbd_srv_dev, kref);\n\n\tWARN_ONCE(!list_empty(&dev->sess_dev_list),\n\t\t  \"Device %s is being destroyed but still in use!\\n\",\n\t\t  dev->name);\n\n\tspin_lock(&dev_lock);\n\tlist_del(&dev->list);\n\tspin_unlock(&dev_lock);\n\n\tmutex_destroy(&dev->lock);\n\tif (dev->dev_kobj.state_in_sysfs)\n\t\t \n\t\trnbd_srv_destroy_dev_sysfs(dev);\n\telse\n\t\tkfree(dev);\n}\n\nstatic void rnbd_put_srv_dev(struct rnbd_srv_dev *dev)\n{\n\tkref_put(&dev->kref, destroy_device);\n}\n\nvoid rnbd_destroy_sess_dev(struct rnbd_srv_sess_dev *sess_dev, bool keep_id)\n{\n\tDECLARE_COMPLETION_ONSTACK(dc);\n\n\tif (keep_id)\n\t\t \n\t\t \n\t\t \n\t\txa_cmpxchg(&sess_dev->sess->index_idr, sess_dev->device_id,\n\t\t\t   sess_dev, NULL, 0);\n\telse\n\t\txa_erase(&sess_dev->sess->index_idr, sess_dev->device_id);\n\tsynchronize_rcu();\n\n\tsess_dev->destroy_comp = &dc;\n\trnbd_put_sess_dev(sess_dev);\n\twait_for_completion(&dc);  \n\n\tblkdev_put(sess_dev->bdev, NULL);\n\tmutex_lock(&sess_dev->dev->lock);\n\tlist_del(&sess_dev->dev_list);\n\tif (!sess_dev->readonly)\n\t\tsess_dev->dev->open_write_cnt--;\n\tmutex_unlock(&sess_dev->dev->lock);\n\n\trnbd_put_srv_dev(sess_dev->dev);\n\n\trnbd_srv_info(sess_dev, \"Device closed\\n\");\n\tkfree(sess_dev);\n}\n\nstatic void destroy_sess(struct rnbd_srv_session *srv_sess)\n{\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\tunsigned long index;\n\n\tif (xa_empty(&srv_sess->index_idr))\n\t\tgoto out;\n\n\ttrace_destroy_sess(srv_sess);\n\n\tmutex_lock(&srv_sess->lock);\n\txa_for_each(&srv_sess->index_idr, index, sess_dev)\n\t\trnbd_srv_destroy_dev_session_sysfs(sess_dev);\n\tmutex_unlock(&srv_sess->lock);\n\nout:\n\txa_destroy(&srv_sess->index_idr);\n\n\tpr_info(\"RTRS Session %s disconnected\\n\", srv_sess->sessname);\n\n\tmutex_lock(&sess_lock);\n\tlist_del(&srv_sess->list);\n\tmutex_unlock(&sess_lock);\n\n\tmutex_destroy(&srv_sess->lock);\n\tkfree(srv_sess);\n}\n\nstatic int create_sess(struct rtrs_srv_sess *rtrs)\n{\n\tstruct rnbd_srv_session *srv_sess;\n\tchar pathname[NAME_MAX];\n\tint err;\n\n\terr = rtrs_srv_get_path_name(rtrs, pathname, sizeof(pathname));\n\tif (err) {\n\t\tpr_err(\"rtrs_srv_get_path_name(%s): %d\\n\", pathname, err);\n\n\t\treturn err;\n\t}\n\tsrv_sess = kzalloc(sizeof(*srv_sess), GFP_KERNEL);\n\tif (!srv_sess)\n\t\treturn -ENOMEM;\n\n\tsrv_sess->queue_depth = rtrs_srv_get_queue_depth(rtrs);\n\txa_init_flags(&srv_sess->index_idr, XA_FLAGS_ALLOC);\n\tmutex_init(&srv_sess->lock);\n\tmutex_lock(&sess_lock);\n\tlist_add(&srv_sess->list, &sess_list);\n\tmutex_unlock(&sess_lock);\n\n\tsrv_sess->rtrs = rtrs;\n\tstrscpy(srv_sess->sessname, pathname, sizeof(srv_sess->sessname));\n\n\trtrs_srv_set_sess_priv(rtrs, srv_sess);\n\n\ttrace_create_sess(srv_sess);\n\n\treturn 0;\n}\n\nstatic int rnbd_srv_link_ev(struct rtrs_srv_sess *rtrs,\n\t\t\t     enum rtrs_srv_link_ev ev, void *priv)\n{\n\tstruct rnbd_srv_session *srv_sess = priv;\n\n\tswitch (ev) {\n\tcase RTRS_SRV_LINK_EV_CONNECTED:\n\t\treturn create_sess(rtrs);\n\n\tcase RTRS_SRV_LINK_EV_DISCONNECTED:\n\t\tif (WARN_ON_ONCE(!srv_sess))\n\t\t\treturn -EINVAL;\n\n\t\tdestroy_sess(srv_sess);\n\t\treturn 0;\n\n\tdefault:\n\t\tpr_warn(\"Received unknown RTRS session event %d from session %s\\n\",\n\t\t\tev, srv_sess->sessname);\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid rnbd_srv_sess_dev_force_close(struct rnbd_srv_sess_dev *sess_dev,\n\t\t\t\t   struct kobj_attribute *attr)\n{\n\tstruct rnbd_srv_session\t*sess = sess_dev->sess;\n\n\t \n\tif (!mutex_trylock(&sess->lock))\n\t\treturn;\n\n\tsess_dev->keep_id = true;\n\t \n\tsysfs_remove_file_self(&sess_dev->kobj, &attr->attr);\n\trnbd_srv_destroy_dev_session_sysfs(sess_dev);\n\tmutex_unlock(&sess->lock);\n}\n\nstatic void process_msg_close(struct rnbd_srv_session *srv_sess,\n\t\t\t     void *data, size_t datalen, const void *usr,\n\t\t\t     size_t usrlen)\n{\n\tconst struct rnbd_msg_close *close_msg = usr;\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\n\ttrace_process_msg_close(srv_sess, close_msg);\n\n\tsess_dev = rnbd_get_sess_dev(le32_to_cpu(close_msg->device_id),\n\t\t\t\t      srv_sess);\n\tif (IS_ERR(sess_dev))\n\t\treturn;\n\n\trnbd_put_sess_dev(sess_dev);\n\tmutex_lock(&srv_sess->lock);\n\trnbd_srv_destroy_dev_session_sysfs(sess_dev);\n\tmutex_unlock(&srv_sess->lock);\n}\n\nstatic int process_msg_open(struct rnbd_srv_session *srv_sess,\n\t\t\t    const void *msg, size_t len,\n\t\t\t    void *data, size_t datalen);\n\nstatic void process_msg_sess_info(struct rnbd_srv_session *srv_sess,\n\t\t\t\t const void *msg, size_t len,\n\t\t\t\t void *data, size_t datalen);\n\nstatic int rnbd_srv_rdma_ev(void *priv, struct rtrs_srv_op *id,\n\t\t\t    void *data, size_t datalen,\n\t\t\t    const void *usr, size_t usrlen)\n{\n\tstruct rnbd_srv_session *srv_sess = priv;\n\tconst struct rnbd_msg_hdr *hdr = usr;\n\tint ret = 0;\n\tu16 type;\n\n\tif (WARN_ON_ONCE(!srv_sess))\n\t\treturn -ENODEV;\n\n\ttype = le16_to_cpu(hdr->type);\n\n\tswitch (type) {\n\tcase RNBD_MSG_IO:\n\t\treturn process_rdma(srv_sess, id, data, datalen, usr, usrlen);\n\tcase RNBD_MSG_CLOSE:\n\t\tprocess_msg_close(srv_sess, data, datalen, usr, usrlen);\n\t\tbreak;\n\tcase RNBD_MSG_OPEN:\n\t\tret = process_msg_open(srv_sess, usr, usrlen, data, datalen);\n\t\tbreak;\n\tcase RNBD_MSG_SESS_INFO:\n\t\tprocess_msg_sess_info(srv_sess, usr, usrlen, data, datalen);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Received unexpected message type %d from session %s\\n\",\n\t\t\ttype, srv_sess->sessname);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trtrs_srv_resp_rdma(id, ret);\n\treturn 0;\n}\n\nstatic struct rnbd_srv_sess_dev\n*rnbd_sess_dev_alloc(struct rnbd_srv_session *srv_sess)\n{\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\tint error;\n\n\tsess_dev = kzalloc(sizeof(*sess_dev), GFP_KERNEL);\n\tif (!sess_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xa_alloc(&srv_sess->index_idr, &sess_dev->device_id, sess_dev,\n\t\t\t xa_limit_32b, GFP_NOWAIT);\n\tif (error < 0) {\n\t\tpr_warn(\"Allocating idr failed, err: %d\\n\", error);\n\t\tkfree(sess_dev);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn sess_dev;\n}\n\nstatic struct rnbd_srv_dev *rnbd_srv_init_srv_dev(struct block_device *bdev)\n{\n\tstruct rnbd_srv_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsnprintf(dev->name, sizeof(dev->name), \"%pg\", bdev);\n\tkref_init(&dev->kref);\n\tINIT_LIST_HEAD(&dev->sess_dev_list);\n\tmutex_init(&dev->lock);\n\n\treturn dev;\n}\n\nstatic struct rnbd_srv_dev *\nrnbd_srv_find_or_add_srv_dev(struct rnbd_srv_dev *new_dev)\n{\n\tstruct rnbd_srv_dev *dev;\n\n\tspin_lock(&dev_lock);\n\tlist_for_each_entry(dev, &dev_list, list) {\n\t\tif (!strncmp(dev->name, new_dev->name, sizeof(dev->name))) {\n\t\t\tif (!kref_get_unless_zero(&dev->kref))\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&dev_lock);\n\t\t\treturn dev;\n\t\t}\n\t}\n\tlist_add(&new_dev->list, &dev_list);\n\tspin_unlock(&dev_lock);\n\n\treturn new_dev;\n}\n\nstatic int rnbd_srv_check_update_open_perm(struct rnbd_srv_dev *srv_dev,\n\t\t\t\t\t    struct rnbd_srv_session *srv_sess,\n\t\t\t\t\t    enum rnbd_access_mode access_mode)\n{\n\tint ret = 0;\n\n\tmutex_lock(&srv_dev->lock);\n\n\tswitch (access_mode) {\n\tcase RNBD_ACCESS_RO:\n\t\tbreak;\n\tcase RNBD_ACCESS_RW:\n\t\tif (srv_dev->open_write_cnt == 0)  {\n\t\t\tsrv_dev->open_write_cnt++;\n\t\t} else {\n\t\t\tpr_err(\"Mapping device '%s' for session %s with RW permissions failed. Device already opened as 'RW' by %d client(s), access mode %s.\\n\",\n\t\t\t       srv_dev->name, srv_sess->sessname,\n\t\t\t       srv_dev->open_write_cnt,\n\t\t\t       rnbd_access_modes[access_mode].str);\n\t\t\tret = -EPERM;\n\t\t}\n\t\tbreak;\n\tcase RNBD_ACCESS_MIGRATION:\n\t\tif (srv_dev->open_write_cnt < 2) {\n\t\t\tsrv_dev->open_write_cnt++;\n\t\t} else {\n\t\t\tpr_err(\"Mapping device '%s' for session %s with migration permissions failed. Device already opened as 'RW' by %d client(s), access mode %s.\\n\",\n\t\t\t       srv_dev->name, srv_sess->sessname,\n\t\t\t       srv_dev->open_write_cnt,\n\t\t\t       rnbd_access_modes[access_mode].str);\n\t\t\tret = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Received mapping request for device '%s' on session %s with invalid access mode: %d\\n\",\n\t\t       srv_dev->name, srv_sess->sessname, access_mode);\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&srv_dev->lock);\n\n\treturn ret;\n}\n\nstatic struct rnbd_srv_dev *\nrnbd_srv_get_or_create_srv_dev(struct block_device *bdev,\n\t\t\t\tstruct rnbd_srv_session *srv_sess,\n\t\t\t\tenum rnbd_access_mode access_mode)\n{\n\tint ret;\n\tstruct rnbd_srv_dev *new_dev, *dev;\n\n\tnew_dev = rnbd_srv_init_srv_dev(bdev);\n\tif (IS_ERR(new_dev))\n\t\treturn new_dev;\n\n\tdev = rnbd_srv_find_or_add_srv_dev(new_dev);\n\tif (dev != new_dev)\n\t\tkfree(new_dev);\n\n\tret = rnbd_srv_check_update_open_perm(dev, srv_sess, access_mode);\n\tif (ret) {\n\t\trnbd_put_srv_dev(dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn dev;\n}\n\nstatic void rnbd_srv_fill_msg_open_rsp(struct rnbd_msg_open_rsp *rsp,\n\t\t\t\t\tstruct rnbd_srv_sess_dev *sess_dev)\n{\n\tstruct block_device *bdev = sess_dev->bdev;\n\n\trsp->hdr.type = cpu_to_le16(RNBD_MSG_OPEN_RSP);\n\trsp->device_id = cpu_to_le32(sess_dev->device_id);\n\trsp->nsectors = cpu_to_le64(bdev_nr_sectors(bdev));\n\trsp->logical_block_size\t= cpu_to_le16(bdev_logical_block_size(bdev));\n\trsp->physical_block_size = cpu_to_le16(bdev_physical_block_size(bdev));\n\trsp->max_segments = cpu_to_le16(bdev_max_segments(bdev));\n\trsp->max_hw_sectors =\n\t\tcpu_to_le32(queue_max_hw_sectors(bdev_get_queue(bdev)));\n\trsp->max_write_same_sectors = 0;\n\trsp->max_discard_sectors = cpu_to_le32(bdev_max_discard_sectors(bdev));\n\trsp->discard_granularity = cpu_to_le32(bdev_discard_granularity(bdev));\n\trsp->discard_alignment = cpu_to_le32(bdev_discard_alignment(bdev));\n\trsp->secure_discard = cpu_to_le16(bdev_max_secure_erase_sectors(bdev));\n\trsp->cache_policy = 0;\n\tif (bdev_write_cache(bdev))\n\t\trsp->cache_policy |= RNBD_WRITEBACK;\n\tif (bdev_fua(bdev))\n\t\trsp->cache_policy |= RNBD_FUA;\n}\n\nstatic struct rnbd_srv_sess_dev *\nrnbd_srv_create_set_sess_dev(struct rnbd_srv_session *srv_sess,\n\t\t\t      const struct rnbd_msg_open *open_msg,\n\t\t\t      struct block_device *bdev, bool readonly,\n\t\t\t      struct rnbd_srv_dev *srv_dev)\n{\n\tstruct rnbd_srv_sess_dev *sdev = rnbd_sess_dev_alloc(srv_sess);\n\n\tif (IS_ERR(sdev))\n\t\treturn sdev;\n\n\tkref_init(&sdev->kref);\n\n\tstrscpy(sdev->pathname, open_msg->dev_name, sizeof(sdev->pathname));\n\n\tsdev->bdev\t\t= bdev;\n\tsdev->sess\t\t= srv_sess;\n\tsdev->dev\t\t= srv_dev;\n\tsdev->readonly\t\t= readonly;\n\tsdev->access_mode\t= open_msg->access_mode;\n\n\treturn sdev;\n}\n\nstatic char *rnbd_srv_get_full_path(struct rnbd_srv_session *srv_sess,\n\t\t\t\t     const char *dev_name)\n{\n\tchar *full_path;\n\tchar *a, *b;\n\n\tfull_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!full_path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\ta = strnstr(dev_search_path, \"%SESSNAME%\", sizeof(dev_search_path));\n\tif (a) {\n\t\tint len = a - dev_search_path;\n\n\t\tlen = snprintf(full_path, PATH_MAX, \"%.*s/%s/%s\", len,\n\t\t\t       dev_search_path, srv_sess->sessname, dev_name);\n\t\tif (len >= PATH_MAX) {\n\t\t\tpr_err(\"Too long path: %s, %s, %s\\n\",\n\t\t\t       dev_search_path, srv_sess->sessname, dev_name);\n\t\t\tkfree(full_path);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tsnprintf(full_path, PATH_MAX, \"%s/%s\",\n\t\t\t dev_search_path, dev_name);\n\t}\n\n\t \n\ta = strchr(full_path, '/');\n\tb = a;\n\twhile (*b != '\\0') {\n\t\tif (*b == '/' && *a == '/') {\n\t\t\tb++;\n\t\t} else {\n\t\t\ta++;\n\t\t\t*a = *b;\n\t\t\tb++;\n\t\t}\n\t}\n\ta++;\n\t*a = '\\0';\n\n\treturn full_path;\n}\n\nstatic void process_msg_sess_info(struct rnbd_srv_session *srv_sess,\n\t\t\t\t const void *msg, size_t len,\n\t\t\t\t void *data, size_t datalen)\n{\n\tconst struct rnbd_msg_sess_info *sess_info_msg = msg;\n\tstruct rnbd_msg_sess_info_rsp *rsp = data;\n\n\tsrv_sess->ver = min_t(u8, sess_info_msg->ver, RNBD_PROTO_VER_MAJOR);\n\n\ttrace_process_msg_sess_info(srv_sess, sess_info_msg);\n\n\trsp->hdr.type = cpu_to_le16(RNBD_MSG_SESS_INFO_RSP);\n\trsp->ver = srv_sess->ver;\n}\n\n \nstatic struct rnbd_srv_sess_dev *\nfind_srv_sess_dev(struct rnbd_srv_session *srv_sess, const char *dev_name)\n{\n\tstruct rnbd_srv_sess_dev *sess_dev;\n\tunsigned long index;\n\n\tif (xa_empty(&srv_sess->index_idr))\n\t\treturn NULL;\n\n\txa_for_each(&srv_sess->index_idr, index, sess_dev)\n\t\tif (!strcmp(sess_dev->pathname, dev_name))\n\t\t\treturn sess_dev;\n\n\treturn NULL;\n}\n\nstatic int process_msg_open(struct rnbd_srv_session *srv_sess,\n\t\t\t    const void *msg, size_t len,\n\t\t\t    void *data, size_t datalen)\n{\n\tint ret;\n\tstruct rnbd_srv_dev *srv_dev;\n\tstruct rnbd_srv_sess_dev *srv_sess_dev;\n\tconst struct rnbd_msg_open *open_msg = msg;\n\tstruct block_device *bdev;\n\tblk_mode_t open_flags = BLK_OPEN_READ;\n\tchar *full_path;\n\tstruct rnbd_msg_open_rsp *rsp = data;\n\n\ttrace_process_msg_open(srv_sess, open_msg);\n\n\tif (open_msg->access_mode != RNBD_ACCESS_RO)\n\t\topen_flags |= BLK_OPEN_WRITE;\n\n\tmutex_lock(&srv_sess->lock);\n\n\tsrv_sess_dev = find_srv_sess_dev(srv_sess, open_msg->dev_name);\n\tif (srv_sess_dev)\n\t\tgoto fill_response;\n\n\tif ((strlen(dev_search_path) + strlen(open_msg->dev_name))\n\t    >= PATH_MAX) {\n\t\tpr_err(\"Opening device for session %s failed, device path too long. '%s/%s' is longer than PATH_MAX (%d)\\n\",\n\t\t       srv_sess->sessname, dev_search_path, open_msg->dev_name,\n\t\t       PATH_MAX);\n\t\tret = -EINVAL;\n\t\tgoto reject;\n\t}\n\tif (strstr(open_msg->dev_name, \"..\")) {\n\t\tpr_err(\"Opening device for session %s failed, device path %s contains relative path ..\\n\",\n\t\t       srv_sess->sessname, open_msg->dev_name);\n\t\tret = -EINVAL;\n\t\tgoto reject;\n\t}\n\tfull_path = rnbd_srv_get_full_path(srv_sess, open_msg->dev_name);\n\tif (IS_ERR(full_path)) {\n\t\tret = PTR_ERR(full_path);\n\t\tpr_err(\"Opening device '%s' for client %s failed, failed to get device full path, err: %d\\n\",\n\t\t       open_msg->dev_name, srv_sess->sessname, ret);\n\t\tgoto reject;\n\t}\n\n\tbdev = blkdev_get_by_path(full_path, open_flags, NULL, NULL);\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tpr_err(\"Opening device '%s' on session %s failed, failed to open the block device, err: %d\\n\",\n\t\t       full_path, srv_sess->sessname, ret);\n\t\tgoto free_path;\n\t}\n\n\tsrv_dev = rnbd_srv_get_or_create_srv_dev(bdev, srv_sess,\n\t\t\t\t\t\t  open_msg->access_mode);\n\tif (IS_ERR(srv_dev)) {\n\t\tpr_err(\"Opening device '%s' on session %s failed, creating srv_dev failed, err: %ld\\n\",\n\t\t       full_path, srv_sess->sessname, PTR_ERR(srv_dev));\n\t\tret = PTR_ERR(srv_dev);\n\t\tgoto blkdev_put;\n\t}\n\n\tsrv_sess_dev = rnbd_srv_create_set_sess_dev(srv_sess, open_msg, bdev,\n\t\t\t\topen_msg->access_mode == RNBD_ACCESS_RO,\n\t\t\t\tsrv_dev);\n\tif (IS_ERR(srv_sess_dev)) {\n\t\tpr_err(\"Opening device '%s' on session %s failed, creating sess_dev failed, err: %ld\\n\",\n\t\t       full_path, srv_sess->sessname, PTR_ERR(srv_sess_dev));\n\t\tret = PTR_ERR(srv_sess_dev);\n\t\tgoto srv_dev_put;\n\t}\n\n\t \n\tmutex_lock(&srv_dev->lock);\n\tif (!srv_dev->dev_kobj.state_in_sysfs) {\n\t\tret = rnbd_srv_create_dev_sysfs(srv_dev, bdev);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&srv_dev->lock);\n\t\t\trnbd_srv_err(srv_sess_dev,\n\t\t\t\t      \"Opening device failed, failed to create device sysfs files, err: %d\\n\",\n\t\t\t\t      ret);\n\t\t\tgoto free_srv_sess_dev;\n\t\t}\n\t}\n\n\tret = rnbd_srv_create_dev_session_sysfs(srv_sess_dev);\n\tif (ret) {\n\t\tmutex_unlock(&srv_dev->lock);\n\t\trnbd_srv_err(srv_sess_dev,\n\t\t\t      \"Opening device failed, failed to create dev client sysfs files, err: %d\\n\",\n\t\t\t      ret);\n\t\tgoto free_srv_sess_dev;\n\t}\n\n\tlist_add(&srv_sess_dev->dev_list, &srv_dev->sess_dev_list);\n\tmutex_unlock(&srv_dev->lock);\n\n\trnbd_srv_info(srv_sess_dev, \"Opened device '%s'\\n\", srv_dev->name);\n\n\tkfree(full_path);\n\nfill_response:\n\trnbd_srv_fill_msg_open_rsp(rsp, srv_sess_dev);\n\tmutex_unlock(&srv_sess->lock);\n\treturn 0;\n\nfree_srv_sess_dev:\n\txa_erase(&srv_sess->index_idr, srv_sess_dev->device_id);\n\tsynchronize_rcu();\n\tkfree(srv_sess_dev);\nsrv_dev_put:\n\tif (open_msg->access_mode != RNBD_ACCESS_RO) {\n\t\tmutex_lock(&srv_dev->lock);\n\t\tsrv_dev->open_write_cnt--;\n\t\tmutex_unlock(&srv_dev->lock);\n\t}\n\trnbd_put_srv_dev(srv_dev);\nblkdev_put:\n\tblkdev_put(bdev, NULL);\nfree_path:\n\tkfree(full_path);\nreject:\n\tmutex_unlock(&srv_sess->lock);\n\treturn ret;\n}\n\nstatic struct rtrs_srv_ctx *rtrs_ctx;\n\nstatic struct rtrs_srv_ops rtrs_ops;\nstatic int __init rnbd_srv_init_module(void)\n{\n\tint err = 0;\n\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_hdr) != 4);\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_sess_info) != 36);\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_sess_info_rsp) != 36);\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_open) != 264);\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_close) != 8);\n\tBUILD_BUG_ON(sizeof(struct rnbd_msg_open_rsp) != 56);\n\trtrs_ops = (struct rtrs_srv_ops) {\n\t\t.rdma_ev = rnbd_srv_rdma_ev,\n\t\t.link_ev = rnbd_srv_link_ev,\n\t};\n\trtrs_ctx = rtrs_srv_open(&rtrs_ops, port_nr);\n\tif (IS_ERR(rtrs_ctx)) {\n\t\tpr_err(\"rtrs_srv_open(), err: %d\\n\", err);\n\t\treturn PTR_ERR(rtrs_ctx);\n\t}\n\n\terr = rnbd_srv_create_sysfs_files();\n\tif (err) {\n\t\tpr_err(\"rnbd_srv_create_sysfs_files(), err: %d\\n\", err);\n\t\trtrs_srv_close(rtrs_ctx);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit rnbd_srv_cleanup_module(void)\n{\n\trtrs_srv_close(rtrs_ctx);\n\tWARN_ON(!list_empty(&sess_list));\n\trnbd_srv_destroy_sysfs_files();\n}\n\nmodule_init(rnbd_srv_init_module);\nmodule_exit(rnbd_srv_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}