{
  "module_name": "swim3.c",
  "hash_id": "e60744f56f7bc70afb23a048cedb240abcbb05c914d2be8460665072155adb6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/swim3.c",
  "human_readable_source": "\n \n\n \n\n#undef DEBUG\n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/fd.h>\n#include <linux/ioctl.h>\n#include <linux/blk-mq.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/major.h>\n#include <asm/io.h>\n#include <asm/dbdma.h>\n#include <asm/prom.h>\n#include <linux/uaccess.h>\n#include <asm/mediabay.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n\n#define MAX_FLOPPIES\t2\n\nstatic DEFINE_MUTEX(swim3_mutex);\nstatic struct gendisk *disks[MAX_FLOPPIES];\n\nenum swim_state {\n\tidle,\n\tlocating,\n\tseeking,\n\tsettling,\n\tdo_transfer,\n\tjogging,\n\tavailable,\n\trevalidating,\n\tejecting\n};\n\n#define REG(x)\tunsigned char x; char x ## _pad[15];\n\n \nstruct swim3 {\n\tREG(data);\n\tREG(timer);\t\t \n\tREG(error);\n\tREG(mode);\n\tREG(select);\t\t \n\tREG(setup);\n\tREG(control);\t\t \n\tREG(status);\t\t \n\tREG(intr);\n\tREG(nseek);\t\t \n\tREG(ctrack);\t\t \n\tREG(csect);\t\t \n\tREG(gap3);\t\t \n\tREG(sector);\t\t \n\tREG(nsect);\t\t \n\tREG(intr_enable);\n};\n\n#define control_bic\tcontrol\n#define control_bis\tstatus\n\n \n#define CA_MASK\t\t7\n#define LSTRB\t\t8\n\n \n#define DO_SEEK\t\t0x80\n#define FORMAT\t\t0x40\n#define SELECT\t\t0x20\n#define WRITE_SECTORS\t0x10\n#define DO_ACTION\t0x08\n#define DRIVE2_ENABLE\t0x04\n#define DRIVE_ENABLE\t0x02\n#define INTR_ENABLE\t0x01\n\n \n#define FIFO_1BYTE\t0x80\n#define FIFO_2BYTE\t0x40\n#define ERROR\t\t0x20\n#define DATA\t\t0x08\n#define RDDATA\t\t0x04\n#define INTR_PENDING\t0x02\n#define MARK_BYTE\t0x01\n\n \n#define ERROR_INTR\t0x20\n#define DATA_CHANGED\t0x10\n#define TRANSFER_DONE\t0x08\n#define SEEN_SECTOR\t0x04\n#define SEEK_DONE\t0x02\n#define TIMER_DONE\t0x01\n\n \n#define ERR_DATA_CRC\t0x80\n#define ERR_ADDR_CRC\t0x40\n#define ERR_OVERRUN\t0x04\n#define ERR_UNDERRUN\t0x01\n\n \n#define S_SW_RESET\t0x80\n#define S_GCR_WRITE\t0x40\n#define S_IBM_DRIVE\t0x20\n#define S_TEST_MODE\t0x10\n#define S_FCLK_DIV2\t0x08\n#define S_GCR\t\t0x04\n#define S_COPY_PROT\t0x02\n#define S_INV_WDATA\t0x01\n\n \n#define SEEK_POSITIVE\t0\n#define SEEK_NEGATIVE\t4\n#define STEP\t\t1\n#define MOTOR_ON\t2\n#define MOTOR_OFF\t6\n#define INDEX\t\t3\n#define EJECT\t\t7\n#define SETMFM\t\t9\n#define SETGCR\t\t13\n\n \n#define STEP_DIR\t0\n#define STEPPING\t1\n#define MOTOR_ON\t2\n#define RELAX\t\t3\t \n#define READ_DATA_0\t4\n#define ONEMEG_DRIVE\t5\n#define SINGLE_SIDED\t6\t \n#define DRIVE_PRESENT\t7\n#define DISK_IN\t\t8\n#define WRITE_PROT\t9\n#define TRACK_ZERO\t10\n#define TACHO\t\t11\n#define READ_DATA_1\t12\n#define GCR_MODE\t13\n#define SEEK_COMPLETE\t14\n#define TWOMEG_MEDIA\t15\n\n \n#define DATA_ESCAPE\t0x99\n#define GCR_SYNC_EXC\t0x3f\n#define GCR_SYNC_CONV\t0x80\n#define GCR_FIRST_MARK\t0xd5\n#define GCR_SECOND_MARK\t0xaa\n#define GCR_ADDR_MARK\t\"\\xd5\\xaa\\x00\"\n#define GCR_DATA_MARK\t\"\\xd5\\xaa\\x0b\"\n#define GCR_SLIP_BYTE\t\"\\x27\\xaa\"\n#define GCR_SELF_SYNC\t\"\\x3f\\xbf\\x1e\\x34\\x3c\\x3f\"\n\n#define DATA_99\t\t\"\\x99\\x99\"\n#define MFM_ADDR_MARK\t\"\\x99\\xa1\\x99\\xa1\\x99\\xa1\\x99\\xfe\"\n#define MFM_INDEX_MARK\t\"\\x99\\xc2\\x99\\xc2\\x99\\xc2\\x99\\xfc\"\n#define MFM_GAP_LEN\t12\n\nstruct floppy_state {\n\tenum swim_state\tstate;\n\tstruct swim3 __iomem *swim3;\t \n\tstruct dbdma_regs __iomem *dma;\t \n\tint\tswim3_intr;\t \n\tint\tdma_intr;\t \n\tint\tcur_cyl;\t \n\tint\tcur_sector;\t \n\tint\treq_cyl;\t \n\tint\thead;\t\t \n\tint\treq_sector;\t \n\tint\tscount;\t\t \n\tint\tretries;\n\tint\tsettle_time;\n\tint\tsecpercyl;\t \n\tint\tsecpertrack;\n\tint\ttotal_secs;\n\tint\twrite_prot;\t \n\tstruct dbdma_cmd *dma_cmd;\n\tint\tref_count;\n\tint\texpect_cyl;\n\tstruct timer_list timeout;\n\tint\ttimeout_pending;\n\tint\tejected;\n\twait_queue_head_t wait;\n\tint\twanted;\n\tstruct macio_dev *mdev;\n\tchar\tdbdma_cmd_space[5 * sizeof(struct dbdma_cmd)];\n\tint\tindex;\n\tstruct request *cur_req;\n\tstruct blk_mq_tag_set tag_set;\n};\n\n#define swim3_err(fmt, arg...)\tdev_err(&fs->mdev->ofdev.dev, \"[fd%d] \" fmt, fs->index, arg)\n#define swim3_warn(fmt, arg...)\tdev_warn(&fs->mdev->ofdev.dev, \"[fd%d] \" fmt, fs->index, arg)\n#define swim3_info(fmt, arg...)\tdev_info(&fs->mdev->ofdev.dev, \"[fd%d] \" fmt, fs->index, arg)\n\n#ifdef DEBUG\n#define swim3_dbg(fmt, arg...)\tdev_dbg(&fs->mdev->ofdev.dev, \"[fd%d] \" fmt, fs->index, arg)\n#else\n#define swim3_dbg(fmt, arg...)\tdo { } while(0)\n#endif\n\nstatic struct floppy_state floppy_states[MAX_FLOPPIES];\nstatic int floppy_count = 0;\nstatic DEFINE_SPINLOCK(swim3_lock);\n\nstatic unsigned short write_preamble[] = {\n\t0x4e4e, 0x4e4e, 0x4e4e, 0x4e4e, 0x4e4e,\t \n\t0, 0, 0, 0, 0, 0,\t\t\t \n\t0x99a1, 0x99a1, 0x99a1, 0x99fb,\t\t \n\t0x990f\t\t\t\t\t \n};\n\nstatic unsigned short write_postamble[] = {\n\t0x9904,\t\t\t\t\t \n\t0x4e4e, 0x4e4e,\n\t0x9908,\t\t\t\t\t \n\t0, 0, 0, 0, 0, 0\n};\n\nstatic void seek_track(struct floppy_state *fs, int n);\nstatic void act(struct floppy_state *fs);\nstatic void scan_timeout(struct timer_list *t);\nstatic void seek_timeout(struct timer_list *t);\nstatic void settle_timeout(struct timer_list *t);\nstatic void xfer_timeout(struct timer_list *t);\nstatic irqreturn_t swim3_interrupt(int irq, void *dev_id);\n \nstatic int grab_drive(struct floppy_state *fs, enum swim_state state,\n\t\t      int interruptible);\nstatic void release_drive(struct floppy_state *fs);\nstatic int fd_eject(struct floppy_state *fs);\nstatic int floppy_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\tunsigned int cmd, unsigned long param);\nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode);\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing);\nstatic int floppy_revalidate(struct gendisk *disk);\n\nstatic bool swim3_end_request(struct floppy_state *fs, blk_status_t err, unsigned int nr_bytes)\n{\n\tstruct request *req = fs->cur_req;\n\n\tswim3_dbg(\"  end request, err=%d nr_bytes=%d, cur_req=%p\\n\",\n\t\t  err, nr_bytes, req);\n\n\tif (err)\n\t\tnr_bytes = blk_rq_cur_bytes(req);\n\tif (blk_update_request(req, err, nr_bytes))\n\t\treturn true;\n\t__blk_mq_end_request(req, err);\n\tfs->cur_req = NULL;\n\treturn false;\n}\n\nstatic void swim3_select(struct floppy_state *fs, int sel)\n{\n\tstruct swim3 __iomem *sw = fs->swim3;\n\n\tout_8(&sw->select, RELAX);\n\tif (sel & 8)\n\t\tout_8(&sw->control_bis, SELECT);\n\telse\n\t\tout_8(&sw->control_bic, SELECT);\n\tout_8(&sw->select, sel & CA_MASK);\n}\n\nstatic void swim3_action(struct floppy_state *fs, int action)\n{\n\tstruct swim3 __iomem *sw = fs->swim3;\n\n\tswim3_select(fs, action);\n\tudelay(1);\n\tout_8(&sw->select, sw->select | LSTRB);\n\tudelay(2);\n\tout_8(&sw->select, sw->select & ~LSTRB);\n\tudelay(1);\n}\n\nstatic int swim3_readbit(struct floppy_state *fs, int bit)\n{\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tint stat;\n\n\tswim3_select(fs, bit);\n\tudelay(1);\n\tstat = in_8(&sw->status);\n\treturn (stat & DATA) == 0;\n}\n\nstatic blk_status_t swim3_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t   const struct blk_mq_queue_data *bd)\n{\n\tstruct floppy_state *fs = hctx->queue->queuedata;\n\tstruct request *req = bd->rq;\n\tunsigned long x;\n\n\tspin_lock_irq(&swim3_lock);\n\tif (fs->cur_req || fs->state != idle) {\n\t\tspin_unlock_irq(&swim3_lock);\n\t\treturn BLK_STS_DEV_RESOURCE;\n\t}\n\tblk_mq_start_request(req);\n\tfs->cur_req = req;\n\tif (fs->mdev->media_bay &&\n\t    check_media_bay(fs->mdev->media_bay) != MB_FD) {\n\t\tswim3_dbg(\"%s\", \"  media bay absent, dropping req\\n\");\n\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\tgoto out;\n\t}\n\tif (fs->ejected) {\n\t\tswim3_dbg(\"%s\", \"  disk ejected\\n\");\n\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\tgoto out;\n\t}\n\tif (rq_data_dir(req) == WRITE) {\n\t\tif (fs->write_prot < 0)\n\t\t\tfs->write_prot = swim3_readbit(fs, WRITE_PROT);\n\t\tif (fs->write_prot) {\n\t\t\tswim3_dbg(\"%s\", \"  try to write, disk write protected\\n\");\n\t\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfs->req_cyl = ((long)blk_rq_pos(req)) / fs->secpercyl;\n\tx = ((long)blk_rq_pos(req)) % fs->secpercyl;\n\tfs->head = x / fs->secpertrack;\n\tfs->req_sector = x % fs->secpertrack + 1;\n\tfs->state = do_transfer;\n\tfs->retries = 0;\n\n\tact(fs);\n\nout:\n\tspin_unlock_irq(&swim3_lock);\n\treturn BLK_STS_OK;\n}\n\nstatic void set_timeout(struct floppy_state *fs, int nticks,\n\t\t\tvoid (*proc)(struct timer_list *t))\n{\n\tif (fs->timeout_pending)\n\t\tdel_timer(&fs->timeout);\n\tfs->timeout.expires = jiffies + nticks;\n\tfs->timeout.function = proc;\n\tadd_timer(&fs->timeout);\n\tfs->timeout_pending = 1;\n}\n\nstatic inline void scan_track(struct floppy_state *fs)\n{\n\tstruct swim3 __iomem *sw = fs->swim3;\n\n\tswim3_select(fs, READ_DATA_0);\n\tin_8(&sw->intr);\t\t \n\tin_8(&sw->error);\n\tout_8(&sw->intr_enable, SEEN_SECTOR);\n\tout_8(&sw->control_bis, DO_ACTION);\n\t \n\tset_timeout(fs, HZ, scan_timeout);\t \n}\n\nstatic inline void seek_track(struct floppy_state *fs, int n)\n{\n\tstruct swim3 __iomem *sw = fs->swim3;\n\n\tif (n >= 0) {\n\t\tswim3_action(fs, SEEK_POSITIVE);\n\t\tsw->nseek = n;\n\t} else {\n\t\tswim3_action(fs, SEEK_NEGATIVE);\n\t\tsw->nseek = -n;\n\t}\n\tfs->expect_cyl = (fs->cur_cyl >= 0)? fs->cur_cyl + n: -1;\n\tswim3_select(fs, STEP);\n\tin_8(&sw->error);\n\t \n\tout_8(&sw->intr_enable, SEEK_DONE);\n\tout_8(&sw->control_bis, DO_SEEK);\n\tset_timeout(fs, 3*HZ, seek_timeout);\t \n\tfs->settle_time = 0;\n}\n\n \nstatic unsigned long swim3_phys_to_bus(phys_addr_t paddr)\n{\n\treturn paddr + PCI_DRAM_OFFSET;\n}\n\nstatic phys_addr_t swim3_bio_phys(struct bio *bio)\n{\n\treturn page_to_phys(bio_page(bio)) + bio_offset(bio);\n}\n\nstatic inline void init_dma(struct dbdma_cmd *cp, int cmd,\n\t\t\t    phys_addr_t paddr, int count)\n{\n\tcp->req_count = cpu_to_le16(count);\n\tcp->command = cpu_to_le16(cmd);\n\tcp->phy_addr = cpu_to_le32(swim3_phys_to_bus(paddr));\n\tcp->xfer_status = 0;\n}\n\nstatic inline void setup_transfer(struct floppy_state *fs)\n{\n\tint n;\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tstruct dbdma_cmd *cp = fs->dma_cmd;\n\tstruct dbdma_regs __iomem *dr = fs->dma;\n\tstruct request *req = fs->cur_req;\n\n\tif (blk_rq_cur_sectors(req) <= 0) {\n\t\tswim3_warn(\"%s\", \"Transfer 0 sectors ?\\n\");\n\t\treturn;\n\t}\n\tif (rq_data_dir(req) == WRITE)\n\t\tn = 1;\n\telse {\n\t\tn = fs->secpertrack - fs->req_sector + 1;\n\t\tif (n > blk_rq_cur_sectors(req))\n\t\t\tn = blk_rq_cur_sectors(req);\n\t}\n\n\tswim3_dbg(\"  setup xfer at sect %d (of %d) head %d for %d\\n\",\n\t\t  fs->req_sector, fs->secpertrack, fs->head, n);\n\n\tfs->scount = n;\n\tswim3_select(fs, fs->head? READ_DATA_1: READ_DATA_0);\n\tout_8(&sw->sector, fs->req_sector);\n\tout_8(&sw->nsect, n);\n\tout_8(&sw->gap3, 0);\n\tout_le32(&dr->cmdptr, swim3_phys_to_bus(virt_to_phys(cp)));\n\tif (rq_data_dir(req) == WRITE) {\n\t\t \n\t\tinit_dma(cp, OUTPUT_MORE, virt_to_phys(write_preamble),\n\t\t\t sizeof(write_preamble));\n\t\t++cp;\n\t\tinit_dma(cp, OUTPUT_MORE, swim3_bio_phys(req->bio), 512);\n\t\t++cp;\n\t\tinit_dma(cp, OUTPUT_LAST, virt_to_phys(write_postamble),\n\t\t\tsizeof(write_postamble));\n\t} else {\n\t\tinit_dma(cp, INPUT_LAST, swim3_bio_phys(req->bio), n * 512);\n\t}\n\t++cp;\n\tout_le16(&cp->command, DBDMA_STOP);\n\tout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\n\tin_8(&sw->error);\n\tout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\n\tif (rq_data_dir(req) == WRITE)\n\t\tout_8(&sw->control_bis, WRITE_SECTORS);\n\tin_8(&sw->intr);\n\tout_le32(&dr->control, (RUN << 16) | RUN);\n\t \n\tout_8(&sw->intr_enable, TRANSFER_DONE);\n\tout_8(&sw->control_bis, DO_ACTION);\n\tset_timeout(fs, 2*HZ, xfer_timeout);\t \n}\n\nstatic void act(struct floppy_state *fs)\n{\n\tfor (;;) {\n\t\tswim3_dbg(\"  act loop, state=%d, req_cyl=%d, cur_cyl=%d\\n\",\n\t\t\t  fs->state, fs->req_cyl, fs->cur_cyl);\n\n\t\tswitch (fs->state) {\n\t\tcase idle:\n\t\t\treturn;\t\t \n\n\t\tcase locating:\n\t\t\tif (swim3_readbit(fs, TRACK_ZERO)) {\n\t\t\t\tswim3_dbg(\"%s\", \"    locate track 0\\n\");\n\t\t\t\tfs->cur_cyl = 0;\n\t\t\t\tif (fs->req_cyl == 0)\n\t\t\t\t\tfs->state = do_transfer;\n\t\t\t\telse\n\t\t\t\t\tfs->state = seeking;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscan_track(fs);\n\t\t\treturn;\n\n\t\tcase seeking:\n\t\t\tif (fs->cur_cyl < 0) {\n\t\t\t\tfs->expect_cyl = -1;\n\t\t\t\tfs->state = locating;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fs->req_cyl == fs->cur_cyl) {\n\t\t\t\tswim3_warn(\"%s\", \"Whoops, seeking 0\\n\");\n\t\t\t\tfs->state = do_transfer;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseek_track(fs, fs->req_cyl - fs->cur_cyl);\n\t\t\treturn;\n\n\t\tcase settling:\n\t\t\t \n\t\t\tfs->settle_time = (HZ + 32) / 33;\n\t\t\tset_timeout(fs, fs->settle_time, settle_timeout);\n\t\t\treturn;\n\n\t\tcase do_transfer:\n\t\t\tif (fs->cur_cyl != fs->req_cyl) {\n\t\t\t\tif (fs->retries > 5) {\n\t\t\t\t\tswim3_err(\"Wrong cylinder in transfer, want: %d got %d\\n\",\n\t\t\t\t\t\t  fs->req_cyl, fs->cur_cyl);\n\t\t\t\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\t\t\t\tfs->state = idle;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfs->state = seeking;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsetup_transfer(fs);\n\t\t\treturn;\n\n\t\tcase jogging:\n\t\t\tseek_track(fs, -5);\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tswim3_err(\"Unknown state %d\\n\", fs->state);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void scan_timeout(struct timer_list *t)\n{\n\tstruct floppy_state *fs = from_timer(fs, t, timeout);\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tunsigned long flags;\n\n\tswim3_dbg(\"* scan timeout, state=%d\\n\", fs->state);\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tfs->timeout_pending = 0;\n\tout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\n\tout_8(&sw->select, RELAX);\n\tout_8(&sw->intr_enable, 0);\n\tfs->cur_cyl = -1;\n\tif (fs->retries > 5) {\n\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\tfs->state = idle;\n\t} else {\n\t\tfs->state = jogging;\n\t\tact(fs);\n\t}\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n}\n\nstatic void seek_timeout(struct timer_list *t)\n{\n\tstruct floppy_state *fs = from_timer(fs, t, timeout);\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tunsigned long flags;\n\n\tswim3_dbg(\"* seek timeout, state=%d\\n\", fs->state);\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tfs->timeout_pending = 0;\n\tout_8(&sw->control_bic, DO_SEEK);\n\tout_8(&sw->select, RELAX);\n\tout_8(&sw->intr_enable, 0);\n\tswim3_err(\"%s\", \"Seek timeout\\n\");\n\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\tfs->state = idle;\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n}\n\nstatic void settle_timeout(struct timer_list *t)\n{\n\tstruct floppy_state *fs = from_timer(fs, t, timeout);\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tunsigned long flags;\n\n\tswim3_dbg(\"* settle timeout, state=%d\\n\", fs->state);\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tfs->timeout_pending = 0;\n\tif (swim3_readbit(fs, SEEK_COMPLETE)) {\n\t\tout_8(&sw->select, RELAX);\n\t\tfs->state = locating;\n\t\tact(fs);\n\t\tgoto unlock;\n\t}\n\tout_8(&sw->select, RELAX);\n\tif (fs->settle_time < 2*HZ) {\n\t\t++fs->settle_time;\n\t\tset_timeout(fs, 1, settle_timeout);\n\t\tgoto unlock;\n\t}\n\tswim3_err(\"%s\", \"Seek settle timeout\\n\");\n\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\tfs->state = idle;\n unlock:\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n}\n\nstatic void xfer_timeout(struct timer_list *t)\n{\n\tstruct floppy_state *fs = from_timer(fs, t, timeout);\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tstruct dbdma_regs __iomem *dr = fs->dma;\n\tunsigned long flags;\n\tint n;\n\n\tswim3_dbg(\"* xfer timeout, state=%d\\n\", fs->state);\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tfs->timeout_pending = 0;\n\tout_le32(&dr->control, RUN << 16);\n\t \n\tfor (n = 0; (in_le32(&dr->status) & ACTIVE) && n < 1000; n++)\n\t\tudelay(1);\n\tout_8(&sw->intr_enable, 0);\n\tout_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);\n\tout_8(&sw->select, RELAX);\n\tswim3_err(\"Timeout %sing sector %ld\\n\",\n\t       (rq_data_dir(fs->cur_req)==WRITE? \"writ\": \"read\"),\n\t       (long)blk_rq_pos(fs->cur_req));\n\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\tfs->state = idle;\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n}\n\nstatic irqreturn_t swim3_interrupt(int irq, void *dev_id)\n{\n\tstruct floppy_state *fs = (struct floppy_state *) dev_id;\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tint intr, err, n;\n\tint stat, resid;\n\tstruct dbdma_regs __iomem *dr;\n\tstruct dbdma_cmd *cp;\n\tunsigned long flags;\n\tstruct request *req = fs->cur_req;\n\n\tswim3_dbg(\"* interrupt, state=%d\\n\", fs->state);\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tintr = in_8(&sw->intr);\n\terr = (intr & ERROR_INTR)? in_8(&sw->error): 0;\n\tif ((intr & ERROR_INTR) && fs->state != do_transfer)\n\t\tswim3_err(\"Non-transfer error interrupt: state=%d, dir=%x, intr=%x, err=%x\\n\",\n\t\t\t  fs->state, rq_data_dir(req), intr, err);\n\tswitch (fs->state) {\n\tcase locating:\n\t\tif (intr & SEEN_SECTOR) {\n\t\t\tout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\n\t\t\tout_8(&sw->select, RELAX);\n\t\t\tout_8(&sw->intr_enable, 0);\n\t\t\tdel_timer(&fs->timeout);\n\t\t\tfs->timeout_pending = 0;\n\t\t\tif (sw->ctrack == 0xff) {\n\t\t\t\tswim3_err(\"%s\", \"Seen sector but cyl=ff?\\n\");\n\t\t\t\tfs->cur_cyl = -1;\n\t\t\t\tif (fs->retries > 5) {\n\t\t\t\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\t\t\t\tfs->state = idle;\n\t\t\t\t} else {\n\t\t\t\t\tfs->state = jogging;\n\t\t\t\t\tact(fs);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs->cur_cyl = sw->ctrack;\n\t\t\tfs->cur_sector = sw->csect;\n\t\t\tif (fs->expect_cyl != -1 && fs->expect_cyl != fs->cur_cyl)\n\t\t\t\tswim3_err(\"Expected cyl %d, got %d\\n\",\n\t\t\t\t\t  fs->expect_cyl, fs->cur_cyl);\n\t\t\tfs->state = do_transfer;\n\t\t\tact(fs);\n\t\t}\n\t\tbreak;\n\tcase seeking:\n\tcase jogging:\n\t\tif (sw->nseek == 0) {\n\t\t\tout_8(&sw->control_bic, DO_SEEK);\n\t\t\tout_8(&sw->select, RELAX);\n\t\t\tout_8(&sw->intr_enable, 0);\n\t\t\tdel_timer(&fs->timeout);\n\t\t\tfs->timeout_pending = 0;\n\t\t\tif (fs->state == seeking)\n\t\t\t\t++fs->retries;\n\t\t\tfs->state = settling;\n\t\t\tact(fs);\n\t\t}\n\t\tbreak;\n\tcase settling:\n\t\tout_8(&sw->intr_enable, 0);\n\t\tdel_timer(&fs->timeout);\n\t\tfs->timeout_pending = 0;\n\t\tact(fs);\n\t\tbreak;\n\tcase do_transfer:\n\t\tif ((intr & (ERROR_INTR | TRANSFER_DONE)) == 0)\n\t\t\tbreak;\n\t\tout_8(&sw->intr_enable, 0);\n\t\tout_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);\n\t\tout_8(&sw->select, RELAX);\n\t\tdel_timer(&fs->timeout);\n\t\tfs->timeout_pending = 0;\n\t\tdr = fs->dma;\n\t\tcp = fs->dma_cmd;\n\t\tif (rq_data_dir(req) == WRITE)\n\t\t\t++cp;\n\t\t \n\t\tif ((intr & ERROR_INTR) == 0 && cp->xfer_status == 0) {\n\t\t\t \n\t\t\tfor (n = 0; n < 100; ++n) {\n\t\t\t\tif (cp->xfer_status != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t\tbarrier();\n\t\t\t}\n\t\t}\n\t\t \n\t\tout_le32(&dr->control, (RUN | PAUSE) << 16);\n\t\tstat = le16_to_cpu(cp->xfer_status);\n\t\tresid = le16_to_cpu(cp->res_count);\n\t\tif (intr & ERROR_INTR) {\n\t\t\tn = fs->scount - 1 - resid / 512;\n\t\t\tif (n > 0) {\n\t\t\t\tblk_update_request(req, 0, n << 9);\n\t\t\t\tfs->req_sector += n;\n\t\t\t}\n\t\t\tif (fs->retries < 5) {\n\t\t\t\t++fs->retries;\n\t\t\t\tact(fs);\n\t\t\t} else {\n\t\t\t\tswim3_err(\"Error %sing block %ld (err=%x)\\n\",\n\t\t\t\t       rq_data_dir(req) == WRITE? \"writ\": \"read\",\n\t\t\t\t       (long)blk_rq_pos(req), err);\n\t\t\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\t\t\tfs->state = idle;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((stat & ACTIVE) == 0 || resid != 0) {\n\t\t\t\t \n\t\t\t\tswim3_err(\"fd dma error: stat=%x resid=%d\\n\", stat, resid);\n\t\t\t\tswim3_err(\"  state=%d, dir=%x, intr=%x, err=%x\\n\",\n\t\t\t\t\t  fs->state, rq_data_dir(req), intr, err);\n\t\t\t\tswim3_end_request(fs, BLK_STS_IOERR, 0);\n\t\t\t\tfs->state = idle;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs->retries = 0;\n\t\t\tif (swim3_end_request(fs, 0, fs->scount << 9)) {\n\t\t\t\tfs->req_sector += fs->scount;\n\t\t\t\tif (fs->req_sector > fs->secpertrack) {\n\t\t\t\t\tfs->req_sector -= fs->secpertrack;\n\t\t\t\t\tif (++fs->head > 1) {\n\t\t\t\t\t\tfs->head = 0;\n\t\t\t\t\t\t++fs->req_cyl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tact(fs);\n\t\t\t} else\n\t\t\t\tfs->state = idle;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswim3_err(\"Don't know what to do in state %d\\n\", fs->state);\n\t}\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int grab_drive(struct floppy_state *fs, enum swim_state state,\n\t\t      int interruptible)\n{\n\tunsigned long flags;\n\n\tswim3_dbg(\"%s\", \"-> grab drive\\n\");\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tif (fs->state != idle && fs->state != available) {\n\t\t++fs->wanted;\n\t\t \n\t\tif (!interruptible)\n\t\t\twait_event_lock_irq(fs->wait,\n                                        fs->state == available,\n                                        swim3_lock);\n\t\telse if (wait_event_interruptible_lock_irq(fs->wait,\n\t\t\t\t\tfs->state == available,\n\t\t\t\t\tswim3_lock)) {\n\t\t\t--fs->wanted;\n\t\t\tspin_unlock_irqrestore(&swim3_lock, flags);\n\t\t\treturn -EINTR;\n\t\t}\n\t\t--fs->wanted;\n\t}\n\tfs->state = state;\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n\n\treturn 0;\n}\n\nstatic void release_drive(struct floppy_state *fs)\n{\n\tstruct request_queue *q = disks[fs->index]->queue;\n\tunsigned long flags;\n\n\tswim3_dbg(\"%s\", \"-> release drive\\n\");\n\n\tspin_lock_irqsave(&swim3_lock, flags);\n\tfs->state = idle;\n\tspin_unlock_irqrestore(&swim3_lock, flags);\n\n\tblk_mq_freeze_queue(q);\n\tblk_mq_quiesce_queue(q);\n\tblk_mq_unquiesce_queue(q);\n\tblk_mq_unfreeze_queue(q);\n}\n\nstatic int fd_eject(struct floppy_state *fs)\n{\n\tint err, n;\n\n\terr = grab_drive(fs, ejecting, 1);\n\tif (err)\n\t\treturn err;\n\tswim3_action(fs, EJECT);\n\tfor (n = 20; n > 0; --n) {\n\t\tif (signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tswim3_select(fs, RELAX);\n\t\tschedule_timeout_interruptible(1);\n\t\tif (swim3_readbit(fs, DISK_IN) == 0)\n\t\t\tbreak;\n\t}\n\tswim3_select(fs, RELAX);\n\tudelay(150);\n\tfs->ejected = 1;\n\trelease_drive(fs);\n\treturn err;\n}\n\nstatic struct floppy_struct floppy_type =\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,NULL };\t \n\nstatic int floppy_locked_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\tunsigned int cmd, unsigned long param)\n{\n\tstruct floppy_state *fs = bdev->bd_disk->private_data;\n\tint err;\n\t\t\n\tif ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->mdev->media_bay &&\n\t    check_media_bay(fs->mdev->media_bay) != MB_FD)\n\t\treturn -ENXIO;\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (fs->ref_count != 1)\n\t\t\treturn -EBUSY;\n\t\terr = fd_eject(fs);\n\t\treturn err;\n\tcase FDGETPRM:\n\t        if (copy_to_user((void __user *) param, &floppy_type,\n\t\t\t\t sizeof(struct floppy_struct)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int floppy_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\t\t unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&swim3_mutex);\n\tret = floppy_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&swim3_mutex);\n\n\treturn ret;\n}\n\nstatic int floppy_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\tstruct swim3 __iomem *sw = fs->swim3;\n\tint n, err = 0;\n\n\tif (fs->ref_count == 0) {\n\t\tif (fs->mdev->media_bay &&\n\t\t    check_media_bay(fs->mdev->media_bay) != MB_FD)\n\t\t\treturn -ENXIO;\n\t\tout_8(&sw->setup, S_IBM_DRIVE | S_FCLK_DIV2);\n\t\tout_8(&sw->control_bic, 0xff);\n\t\tout_8(&sw->mode, 0x95);\n\t\tudelay(10);\n\t\tout_8(&sw->intr_enable, 0);\n\t\tout_8(&sw->control_bis, DRIVE_ENABLE | INTR_ENABLE);\n\t\tswim3_action(fs, MOTOR_ON);\n\t\tfs->write_prot = -1;\n\t\tfs->cur_cyl = -1;\n\t\tfor (n = 0; n < 2 * HZ; ++n) {\n\t\t\tif (n >= HZ/30 && swim3_readbit(fs, SEEK_COMPLETE))\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswim3_select(fs, RELAX);\n\t\t\tschedule_timeout_interruptible(1);\n\t\t}\n\t\tif (err == 0 && (swim3_readbit(fs, SEEK_COMPLETE) == 0\n\t\t\t\t || swim3_readbit(fs, DISK_IN) == 0))\n\t\t\terr = -ENXIO;\n\t\tswim3_action(fs, SETMFM);\n\t\tswim3_select(fs, RELAX);\n\n\t} else if (fs->ref_count == -1 || mode & BLK_OPEN_EXCL)\n\t\treturn -EBUSY;\n\n\tif (err == 0 && !(mode & BLK_OPEN_NDELAY) &&\n\t    (mode & (BLK_OPEN_READ | BLK_OPEN_WRITE))) {\n\t\tif (disk_check_media_change(disk))\n\t\t\tfloppy_revalidate(disk);\n\t\tif (fs->ejected)\n\t\t\terr = -ENXIO;\n\t}\n\n\tif (err == 0 && (mode & BLK_OPEN_WRITE)) {\n\t\tif (fs->write_prot < 0)\n\t\t\tfs->write_prot = swim3_readbit(fs, WRITE_PROT);\n\t\tif (fs->write_prot)\n\t\t\terr = -EROFS;\n\t}\n\n\tif (err) {\n\t\tif (fs->ref_count == 0) {\n\t\t\tswim3_action(fs, MOTOR_OFF);\n\t\t\tout_8(&sw->control_bic, DRIVE_ENABLE | INTR_ENABLE);\n\t\t\tswim3_select(fs, RELAX);\n\t\t}\n\t\treturn err;\n\t}\n\n\tif (mode & BLK_OPEN_EXCL)\n\t\tfs->ref_count = -1;\n\telse\n\t\t++fs->ref_count;\n\n\treturn 0;\n}\n\nstatic int floppy_unlocked_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint ret;\n\n\tmutex_lock(&swim3_mutex);\n\tret = floppy_open(disk, mode);\n\tmutex_unlock(&swim3_mutex);\n\n\treturn ret;\n}\n\nstatic void floppy_release(struct gendisk *disk)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\tstruct swim3 __iomem *sw = fs->swim3;\n\n\tmutex_lock(&swim3_mutex);\n\tif (fs->ref_count > 0)\n\t\t--fs->ref_count;\n\telse if (fs->ref_count == -1)\n\t\tfs->ref_count = 0;\n\tif (fs->ref_count == 0) {\n\t\tswim3_action(fs, MOTOR_OFF);\n\t\tout_8(&sw->control_bic, 0xff);\n\t\tswim3_select(fs, RELAX);\n\t}\n\tmutex_unlock(&swim3_mutex);\n}\n\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\treturn fs->ejected ? DISK_EVENT_MEDIA_CHANGE : 0;\n}\n\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tstruct floppy_state *fs = disk->private_data;\n\tstruct swim3 __iomem *sw;\n\tint ret, n;\n\n\tif (fs->mdev->media_bay &&\n\t    check_media_bay(fs->mdev->media_bay) != MB_FD)\n\t\treturn -ENXIO;\n\n\tsw = fs->swim3;\n\tgrab_drive(fs, revalidating, 0);\n\tout_8(&sw->intr_enable, 0);\n\tout_8(&sw->control_bis, DRIVE_ENABLE);\n\tswim3_action(fs, MOTOR_ON);\t \n\tfs->write_prot = -1;\n\tfs->cur_cyl = -1;\n\tmdelay(1);\n\tfor (n = HZ; n > 0; --n) {\n\t\tif (swim3_readbit(fs, SEEK_COMPLETE))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tswim3_select(fs, RELAX);\n\t\tschedule_timeout_interruptible(1);\n\t}\n\tret = swim3_readbit(fs, SEEK_COMPLETE) == 0\n\t\t|| swim3_readbit(fs, DISK_IN) == 0;\n\tif (ret)\n\t\tswim3_action(fs, MOTOR_OFF);\n\telse {\n\t\tfs->ejected = 0;\n\t\tswim3_action(fs, SETMFM);\n\t}\n\tswim3_select(fs, RELAX);\n\n\trelease_drive(fs);\n\treturn ret;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.open\t\t= floppy_unlocked_open,\n\t.release\t= floppy_release,\n\t.ioctl\t\t= floppy_ioctl,\n\t.check_events\t= floppy_check_events,\n};\n\nstatic const struct blk_mq_ops swim3_mq_ops = {\n\t.queue_rq = swim3_queue_rq,\n};\n\nstatic void swim3_mb_event(struct macio_dev* mdev, int mb_state)\n{\n\tstruct floppy_state *fs = macio_get_drvdata(mdev);\n\tstruct swim3 __iomem *sw;\n\n\tif (!fs)\n\t\treturn;\n\n\tsw = fs->swim3;\n\n\tif (mb_state != MB_FD)\n\t\treturn;\n\n\t \n\tout_8(&sw->intr_enable, 0);\n\tin_8(&sw->intr);\n\tin_8(&sw->error);\n}\n\nstatic int swim3_add_device(struct macio_dev *mdev, int index)\n{\n\tstruct device_node *swim = mdev->ofdev.dev.of_node;\n\tstruct floppy_state *fs = &floppy_states[index];\n\tint rc = -EBUSY;\n\n\tfs->mdev = mdev;\n\tfs->index = index;\n\n\t \n\tif (macio_resource_count(mdev) < 2) {\n\t\tswim3_err(\"%s\", \"No address in device-tree\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (macio_irq_count(mdev) < 1) {\n\t\tswim3_err(\"%s\", \"No interrupt in device-tree\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (macio_request_resource(mdev, 0, \"swim3 (mmio)\")) {\n\t\tswim3_err(\"%s\", \"Can't request mmio resource\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (macio_request_resource(mdev, 1, \"swim3 (dma)\")) {\n\t\tswim3_err(\"%s\", \"Can't request dma resource\\n\");\n\t\tmacio_release_resource(mdev, 0);\n\t\treturn -EBUSY;\n\t}\n\tdev_set_drvdata(&mdev->ofdev.dev, fs);\n\n\tif (mdev->media_bay == NULL)\n\t\tpmac_call_feature(PMAC_FTR_SWIM3_ENABLE, swim, 0, 1);\n\t\n\tfs->state = idle;\n\tfs->swim3 = (struct swim3 __iomem *)\n\t\tioremap(macio_resource_start(mdev, 0), 0x200);\n\tif (fs->swim3 == NULL) {\n\t\tswim3_err(\"%s\", \"Couldn't map mmio registers\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\tfs->dma = (struct dbdma_regs __iomem *)\n\t\tioremap(macio_resource_start(mdev, 1), 0x200);\n\tif (fs->dma == NULL) {\n\t\tswim3_err(\"%s\", \"Couldn't map dma registers\\n\");\n\t\tiounmap(fs->swim3);\n\t\trc = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\tfs->swim3_intr = macio_irq(mdev, 0);\n\tfs->dma_intr = macio_irq(mdev, 1);\n\tfs->cur_cyl = -1;\n\tfs->cur_sector = -1;\n\tfs->secpercyl = 36;\n\tfs->secpertrack = 18;\n\tfs->total_secs = 2880;\n\tinit_waitqueue_head(&fs->wait);\n\n\tfs->dma_cmd = (struct dbdma_cmd *) DBDMA_ALIGN(fs->dbdma_cmd_space);\n\tmemset(fs->dma_cmd, 0, 2 * sizeof(struct dbdma_cmd));\n\tfs->dma_cmd[1].command = cpu_to_le16(DBDMA_STOP);\n\n\tif (mdev->media_bay == NULL || check_media_bay(mdev->media_bay) == MB_FD)\n\t\tswim3_mb_event(mdev, MB_FD);\n\n\tif (request_irq(fs->swim3_intr, swim3_interrupt, 0, \"SWIM3\", fs)) {\n\t\tswim3_err(\"%s\", \"Couldn't request interrupt\\n\");\n\t\tpmac_call_feature(PMAC_FTR_SWIM3_ENABLE, swim, 0, 0);\n\t\tgoto out_unmap;\n\t}\n\n\ttimer_setup(&fs->timeout, NULL, 0);\n\n\tswim3_info(\"SWIM3 floppy controller %s\\n\",\n\t\tmdev->media_bay ? \"in media bay\" : \"\");\n\n\treturn 0;\n\n out_unmap:\n\tiounmap(fs->dma);\n\tiounmap(fs->swim3);\n\n out_release:\n\tmacio_release_resource(mdev, 0);\n\tmacio_release_resource(mdev, 1);\n\n\treturn rc;\n}\n\nstatic int swim3_attach(struct macio_dev *mdev,\n\t\t\tconst struct of_device_id *match)\n{\n\tstruct floppy_state *fs;\n\tstruct gendisk *disk;\n\tint rc;\n\n\tif (floppy_count >= MAX_FLOPPIES)\n\t\treturn -ENXIO;\n\n\tif (floppy_count == 0) {\n\t\trc = register_blkdev(FLOPPY_MAJOR, \"fd\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tfs = &floppy_states[floppy_count];\n\tmemset(fs, 0, sizeof(*fs));\n\n\trc = blk_mq_alloc_sq_tag_set(&fs->tag_set, &swim3_mq_ops, 2,\n\t\t\tBLK_MQ_F_SHOULD_MERGE);\n\tif (rc)\n\t\tgoto out_unregister;\n\n\tdisk = blk_mq_alloc_disk(&fs->tag_set, fs);\n\tif (IS_ERR(disk)) {\n\t\trc = PTR_ERR(disk);\n\t\tgoto out_free_tag_set;\n\t}\n\n\trc = swim3_add_device(mdev, floppy_count);\n\tif (rc)\n\t\tgoto out_cleanup_disk;\n\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = floppy_count;\n\tdisk->minors = 1;\n\tdisk->fops = &floppy_fops;\n\tdisk->private_data = fs;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tdisk->flags |= GENHD_FL_REMOVABLE | GENHD_FL_NO_PART;\n\tsprintf(disk->disk_name, \"fd%d\", floppy_count);\n\tset_capacity(disk, 2880);\n\trc = add_disk(disk);\n\tif (rc)\n\t\tgoto out_cleanup_disk;\n\n\tdisks[floppy_count++] = disk;\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(disk);\nout_free_tag_set:\n\tblk_mq_free_tag_set(&fs->tag_set);\nout_unregister:\n\tif (floppy_count == 0)\n\t\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\treturn rc;\n}\n\nstatic const struct of_device_id swim3_match[] =\n{\n\t{\n\t.name\t\t= \"swim3\",\n\t},\n\t{\n\t.compatible\t= \"ohare-swim3\"\n\t},\n\t{\n\t.compatible\t= \"swim3\"\n\t},\n\t{   }\n};\n\nstatic struct macio_driver swim3_driver =\n{\n\t.driver = {\n\t\t.name \t\t= \"swim3\",\n\t\t.of_match_table\t= swim3_match,\n\t},\n\t.probe\t\t= swim3_attach,\n#ifdef CONFIG_PMAC_MEDIABAY\n\t.mediabay_event\t= swim3_mb_event,\n#endif\n#if 0\n\t.suspend\t= swim3_suspend,\n\t.resume\t\t= swim3_resume,\n#endif\n};\n\n\nstatic int swim3_init(void)\n{\n\tmacio_register_driver(&swim3_driver);\n\treturn 0;\n}\n\nmodule_init(swim3_init)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul Mackerras\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}