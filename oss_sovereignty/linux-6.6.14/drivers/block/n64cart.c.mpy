{
  "module_name": "n64cart.c",
  "hash_id": "2b5b458c859a0d01cf6881c08af3d86c4c33e2b4a4eabb9577dc0fe5dc30dae6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/n64cart.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\nenum {\n\tPI_DRAM_REG = 0,\n\tPI_CART_REG,\n\tPI_READ_REG,\n\tPI_WRITE_REG,\n\tPI_STATUS_REG,\n};\n\n#define PI_STATUS_DMA_BUSY\t(1 << 0)\n#define PI_STATUS_IO_BUSY\t(1 << 1)\n\n#define CART_DOMAIN\t\t0x10000000\n#define CART_MAX\t\t0x1FFFFFFF\n\n#define MIN_ALIGNMENT\t\t8\n\nstatic u32 __iomem *reg_base;\n\nstatic unsigned int start;\nmodule_param(start, uint, 0);\nMODULE_PARM_DESC(start, \"Start address of the cart block data\");\n\nstatic unsigned int size;\nmodule_param(size, uint, 0);\nMODULE_PARM_DESC(size, \"Size of the cart block data, in bytes\");\n\nstatic void n64cart_write_reg(const u8 reg, const u32 value)\n{\n\twritel(value, reg_base + reg);\n}\n\nstatic u32 n64cart_read_reg(const u8 reg)\n{\n\treturn readl(reg_base + reg);\n}\n\nstatic void n64cart_wait_dma(void)\n{\n\twhile (n64cart_read_reg(PI_STATUS_REG) &\n\t\t(PI_STATUS_DMA_BUSY | PI_STATUS_IO_BUSY))\n\t\tcpu_relax();\n}\n\n \nstatic bool n64cart_do_bvec(struct device *dev, struct bio_vec *bv, u32 pos)\n{\n\tdma_addr_t dma_addr;\n\tconst u32 bstart = pos + start;\n\n\t \n\tWARN_ON_ONCE((bv->bv_offset & (MIN_ALIGNMENT - 1)) ||\n\t\t     (bv->bv_len & (MIN_ALIGNMENT - 1)));\n\n\tdma_addr = dma_map_bvec(dev, bv, DMA_FROM_DEVICE, 0);\n\tif (dma_mapping_error(dev, dma_addr))\n\t\treturn false;\n\n\tn64cart_wait_dma();\n\n\tn64cart_write_reg(PI_DRAM_REG, dma_addr);\n\tn64cart_write_reg(PI_CART_REG, (bstart | CART_DOMAIN) & CART_MAX);\n\tn64cart_write_reg(PI_WRITE_REG, bv->bv_len - 1);\n\n\tn64cart_wait_dma();\n\n\tdma_unmap_page(dev, dma_addr, bv->bv_len, DMA_FROM_DEVICE);\n\treturn true;\n}\n\nstatic void n64cart_submit_bio(struct bio *bio)\n{\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tstruct device *dev = bio->bi_bdev->bd_disk->private_data;\n\tu32 pos = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tif (!n64cart_do_bvec(dev, &bvec, pos)) {\n\t\t\tbio_io_error(bio);\n\t\t\treturn;\n\t\t}\n\t\tpos += bvec.bv_len;\n\t}\n\n\tbio_endio(bio);\n}\n\nstatic const struct block_device_operations n64cart_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.submit_bio\t= n64cart_submit_bio,\n};\n\n \nstatic int __init n64cart_probe(struct platform_device *pdev)\n{\n\tstruct gendisk *disk;\n\tint err = -ENOMEM;\n\n\tif (!start || !size) {\n\t\tpr_err(\"start or size not specified\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (size & 4095) {\n\t\tpr_err(\"size must be a multiple of 4K\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tdisk = blk_alloc_disk(NUMA_NO_NODE);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk->first_minor = 0;\n\tdisk->flags = GENHD_FL_NO_PART;\n\tdisk->fops = &n64cart_fops;\n\tdisk->private_data = &pdev->dev;\n\tstrcpy(disk->disk_name, \"n64cart\");\n\n\tset_capacity(disk, size >> SECTOR_SHIFT);\n\tset_disk_ro(disk, 1);\n\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, disk->queue);\n\tblk_queue_physical_block_size(disk->queue, 4096);\n\tblk_queue_logical_block_size(disk->queue, 4096);\n\n\terr = add_disk(disk);\n\tif (err)\n\t\tgoto out_cleanup_disk;\n\n\tpr_info(\"n64cart: %u kb disk\\n\", size / 1024);\n\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(disk);\nout:\n\treturn err;\n}\n\nstatic struct platform_driver n64cart_driver = {\n\t.driver = {\n\t\t.name = \"n64cart\",\n\t},\n};\n\nstatic int __init n64cart_init(void)\n{\n\treturn platform_driver_probe(&n64cart_driver, n64cart_probe);\n}\n\nmodule_init(n64cart_init);\n\nMODULE_AUTHOR(\"Lauri Kasanen <cand@gmx.com>\");\nMODULE_DESCRIPTION(\"Driver for the N64 cart\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}