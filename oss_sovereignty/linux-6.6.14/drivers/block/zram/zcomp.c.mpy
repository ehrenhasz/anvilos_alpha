{
  "module_name": "zcomp.c",
  "hash_id": "47b1d02d6834b786333f4bb528ac62e6fca681a48fd7e46ab62c4c29d0d2a3dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/block/zram/zcomp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/crypto.h>\n\n#include \"zcomp.h\"\n\nstatic const char * const backends[] = {\n#if IS_ENABLED(CONFIG_CRYPTO_LZO)\n\t\"lzo\",\n\t\"lzo-rle\",\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_LZ4)\n\t\"lz4\",\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_LZ4HC)\n\t\"lz4hc\",\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_842)\n\t\"842\",\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_ZSTD)\n\t\"zstd\",\n#endif\n};\n\nstatic void zcomp_strm_free(struct zcomp_strm *zstrm)\n{\n\tif (!IS_ERR_OR_NULL(zstrm->tfm))\n\t\tcrypto_free_comp(zstrm->tfm);\n\tfree_pages((unsigned long)zstrm->buffer, 1);\n\tzstrm->tfm = NULL;\n\tzstrm->buffer = NULL;\n}\n\n \nstatic int zcomp_strm_init(struct zcomp_strm *zstrm, struct zcomp *comp)\n{\n\tzstrm->tfm = crypto_alloc_comp(comp->name, 0, 0);\n\t \n\tzstrm->buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);\n\tif (IS_ERR_OR_NULL(zstrm->tfm) || !zstrm->buffer) {\n\t\tzcomp_strm_free(zstrm);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nbool zcomp_available_algorithm(const char *comp)\n{\n\t \n\treturn crypto_has_comp(comp, 0, 0) == 1;\n}\n\n \nssize_t zcomp_available_show(const char *comp, char *buf)\n{\n\tbool known_algorithm = false;\n\tssize_t sz = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(backends); i++) {\n\t\tif (!strcmp(comp, backends[i])) {\n\t\t\tknown_algorithm = true;\n\t\t\tsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\n\t\t\t\t\t\"[%s] \", backends[i]);\n\t\t} else {\n\t\t\tsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\n\t\t\t\t\t\"%s \", backends[i]);\n\t\t}\n\t}\n\n\t \n\tif (!known_algorithm && crypto_has_comp(comp, 0, 0) == 1)\n\t\tsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\n\t\t\t\t\"[%s] \", comp);\n\n\tsz += scnprintf(buf + sz, PAGE_SIZE - sz, \"\\n\");\n\treturn sz;\n}\n\nstruct zcomp_strm *zcomp_stream_get(struct zcomp *comp)\n{\n\tlocal_lock(&comp->stream->lock);\n\treturn this_cpu_ptr(comp->stream);\n}\n\nvoid zcomp_stream_put(struct zcomp *comp)\n{\n\tlocal_unlock(&comp->stream->lock);\n}\n\nint zcomp_compress(struct zcomp_strm *zstrm,\n\t\tconst void *src, unsigned int *dst_len)\n{\n\t \n\t*dst_len = PAGE_SIZE * 2;\n\n\treturn crypto_comp_compress(zstrm->tfm,\n\t\t\tsrc, PAGE_SIZE,\n\t\t\tzstrm->buffer, dst_len);\n}\n\nint zcomp_decompress(struct zcomp_strm *zstrm,\n\t\tconst void *src, unsigned int src_len, void *dst)\n{\n\tunsigned int dst_len = PAGE_SIZE;\n\n\treturn crypto_comp_decompress(zstrm->tfm,\n\t\t\tsrc, src_len,\n\t\t\tdst, &dst_len);\n}\n\nint zcomp_cpu_up_prepare(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct zcomp *comp = hlist_entry(node, struct zcomp, node);\n\tstruct zcomp_strm *zstrm;\n\tint ret;\n\n\tzstrm = per_cpu_ptr(comp->stream, cpu);\n\tlocal_lock_init(&zstrm->lock);\n\n\tret = zcomp_strm_init(zstrm, comp);\n\tif (ret)\n\t\tpr_err(\"Can't allocate a compression stream\\n\");\n\treturn ret;\n}\n\nint zcomp_cpu_dead(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct zcomp *comp = hlist_entry(node, struct zcomp, node);\n\tstruct zcomp_strm *zstrm;\n\n\tzstrm = per_cpu_ptr(comp->stream, cpu);\n\tzcomp_strm_free(zstrm);\n\treturn 0;\n}\n\nstatic int zcomp_init(struct zcomp *comp)\n{\n\tint ret;\n\n\tcomp->stream = alloc_percpu(struct zcomp_strm);\n\tif (!comp->stream)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_state_add_instance(CPUHP_ZCOMP_PREPARE, &comp->node);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\treturn 0;\n\ncleanup:\n\tfree_percpu(comp->stream);\n\treturn ret;\n}\n\nvoid zcomp_destroy(struct zcomp *comp)\n{\n\tcpuhp_state_remove_instance(CPUHP_ZCOMP_PREPARE, &comp->node);\n\tfree_percpu(comp->stream);\n\tkfree(comp);\n}\n\n \nstruct zcomp *zcomp_create(const char *alg)\n{\n\tstruct zcomp *comp;\n\tint error;\n\n\t \n\tif (!zcomp_available_algorithm(alg))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcomp = kzalloc(sizeof(struct zcomp), GFP_KERNEL);\n\tif (!comp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcomp->name = alg;\n\terror = zcomp_init(comp);\n\tif (error) {\n\t\tkfree(comp);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn comp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}