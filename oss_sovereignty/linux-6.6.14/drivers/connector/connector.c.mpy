{
  "module_name": "connector.c",
  "hash_id": "6c3cf1eec24a58cf193e76642058ac7db667e8eb06c81bf3328ae7986830481b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/connector/connector.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <linux/moduleparam.h>\n#include <linux/connector.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n\n#include <net/sock.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"Generic userspace <-> kernelspace connector.\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_CONNECTOR);\n\nstatic struct cn_dev cdev;\n\nstatic int cn_already_initialized;\n\n \nint cn_netlink_send_mult(struct cn_msg *msg, u16 len, u32 portid, u32 __group,\n\tgfp_t gfp_mask,\n\tint (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),\n\tvoid *filter_data)\n{\n\tstruct cn_callback_entry *__cbq;\n\tunsigned int size;\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tstruct cn_msg *data;\n\tstruct cn_dev *dev = &cdev;\n\tu32 group = 0;\n\tint found = 0;\n\n\tif (portid || __group) {\n\t\tgroup = __group;\n\t} else {\n\t\tspin_lock_bh(&dev->cbdev->queue_lock);\n\t\tlist_for_each_entry(__cbq, &dev->cbdev->queue_list,\n\t\t\t\t    callback_entry) {\n\t\t\tif (cn_cb_equal(&__cbq->id.id, &msg->id)) {\n\t\t\t\tfound = 1;\n\t\t\t\tgroup = __cbq->group;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&dev->cbdev->queue_lock);\n\n\t\tif (!found)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (!portid && !netlink_has_listeners(dev->nls, group))\n\t\treturn -ESRCH;\n\n\tsize = sizeof(*msg) + len;\n\n\tskb = nlmsg_new(size, gfp_mask);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, 0, msg->seq, NLMSG_DONE, size, 0);\n\tif (!nlh) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tdata = nlmsg_data(nlh);\n\n\tmemcpy(data, msg, size);\n\n\tNETLINK_CB(skb).dst_group = group;\n\n\tif (group)\n\t\treturn netlink_broadcast_filtered(dev->nls, skb, portid, group,\n\t\t\t\t\t\t  gfp_mask, filter,\n\t\t\t\t\t\t  (void *)filter_data);\n\treturn netlink_unicast(dev->nls, skb, portid,\n\t\t\t!gfpflags_allow_blocking(gfp_mask));\n}\nEXPORT_SYMBOL_GPL(cn_netlink_send_mult);\n\n \nint cn_netlink_send(struct cn_msg *msg, u32 portid, u32 __group,\n\tgfp_t gfp_mask)\n{\n\treturn cn_netlink_send_mult(msg, msg->len, portid, __group, gfp_mask,\n\t\t\t\t    NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(cn_netlink_send);\n\n \nstatic int cn_call_callback(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct cn_callback_entry *i, *cbq = NULL;\n\tstruct cn_dev *dev = &cdev;\n\tstruct cn_msg *msg = nlmsg_data(nlmsg_hdr(skb));\n\tstruct netlink_skb_parms *nsp = &NETLINK_CB(skb);\n\tint err = -ENODEV;\n\n\t \n\tnlh = nlmsg_hdr(skb);\n\tif (nlh->nlmsg_len < NLMSG_HDRLEN + sizeof(struct cn_msg) + msg->len)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&dev->cbdev->queue_lock);\n\tlist_for_each_entry(i, &dev->cbdev->queue_list, callback_entry) {\n\t\tif (cn_cb_equal(&i->id.id, &msg->id)) {\n\t\t\trefcount_inc(&i->refcnt);\n\t\t\tcbq = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&dev->cbdev->queue_lock);\n\n\tif (cbq != NULL) {\n\t\tcbq->callback(msg, nsp);\n\t\tkfree_skb(skb);\n\t\tcn_queue_release_callback(cbq);\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\n \nstatic int cn_bind(struct net *net, int group)\n{\n\tunsigned long groups = (unsigned long) group;\n\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn 0;\n\n\tif (test_bit(CN_IDX_PROC - 1, &groups))\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\nstatic void cn_release(struct sock *sk, unsigned long *groups)\n{\n\tif (groups && test_bit(CN_IDX_PROC - 1, groups)) {\n\t\tkfree(sk->sk_user_data);\n\t\tsk->sk_user_data = NULL;\n\t}\n}\n\n \nstatic void cn_rx_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh;\n\tint len, err;\n\n\tif (skb->len >= NLMSG_HDRLEN) {\n\t\tnlh = nlmsg_hdr(skb);\n\t\tlen = nlmsg_len(nlh);\n\n\t\tif (len < (int)sizeof(struct cn_msg) ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    len > CONNECTOR_MAX_MSG_SIZE)\n\t\t\treturn;\n\n\t\terr = cn_call_callback(skb_get(skb));\n\t\tif (err < 0)\n\t\t\tkfree_skb(skb);\n\t}\n}\n\n \nint cn_add_callback(const struct cb_id *id, const char *name,\n\t\t    void (*callback)(struct cn_msg *,\n\t\t\t\t     struct netlink_skb_parms *))\n{\n\tstruct cn_dev *dev = &cdev;\n\n\tif (!cn_already_initialized)\n\t\treturn -EAGAIN;\n\n\treturn cn_queue_add_callback(dev->cbdev, name, id, callback);\n}\nEXPORT_SYMBOL_GPL(cn_add_callback);\n\n \nvoid cn_del_callback(const struct cb_id *id)\n{\n\tstruct cn_dev *dev = &cdev;\n\n\tcn_queue_del_callback(dev->cbdev, id);\n}\nEXPORT_SYMBOL_GPL(cn_del_callback);\n\nstatic int __maybe_unused cn_proc_show(struct seq_file *m, void *v)\n{\n\tstruct cn_queue_dev *dev = cdev.cbdev;\n\tstruct cn_callback_entry *cbq;\n\n\tseq_printf(m, \"Name            ID\\n\");\n\n\tspin_lock_bh(&dev->queue_lock);\n\n\tlist_for_each_entry(cbq, &dev->queue_list, callback_entry) {\n\t\tseq_printf(m, \"%-15s %u:%u\\n\",\n\t\t\t   cbq->id.name,\n\t\t\t   cbq->id.id.idx,\n\t\t\t   cbq->id.id.val);\n\t}\n\n\tspin_unlock_bh(&dev->queue_lock);\n\n\treturn 0;\n}\n\nstatic int cn_init(void)\n{\n\tstruct cn_dev *dev = &cdev;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= CN_NETLINK_USERS + 0xf,\n\t\t.input\t= cn_rx_skb,\n\t\t.flags  = NL_CFG_F_NONROOT_RECV,\n\t\t.bind   = cn_bind,\n\t\t.release = cn_release,\n\t};\n\n\tdev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR, &cfg);\n\tif (!dev->nls)\n\t\treturn -EIO;\n\n\tdev->cbdev = cn_queue_alloc_dev(\"cqueue\", dev->nls);\n\tif (!dev->cbdev) {\n\t\tnetlink_kernel_release(dev->nls);\n\t\treturn -EINVAL;\n\t}\n\n\tcn_already_initialized = 1;\n\n\tproc_create_single(\"connector\", S_IRUGO, init_net.proc_net, cn_proc_show);\n\n\treturn 0;\n}\n\nstatic void cn_fini(void)\n{\n\tstruct cn_dev *dev = &cdev;\n\n\tcn_already_initialized = 0;\n\n\tremove_proc_entry(\"connector\", init_net.proc_net);\n\n\tcn_queue_free_dev(dev->cbdev);\n\tnetlink_kernel_release(dev->nls);\n}\n\nsubsys_initcall(cn_init);\nmodule_exit(cn_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}