{
  "module_name": "cn_queue.c",
  "hash_id": "aefed553c32d82fe5b2fd58a82e0013e2906543be94132d419da6f3222bfab48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/connector/cn_queue.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/suspend.h>\n#include <linux/connector.h>\n#include <linux/delay.h>\n\nstatic struct cn_callback_entry *\ncn_queue_alloc_callback_entry(struct cn_queue_dev *dev, const char *name,\n\t\t\t      const struct cb_id *id,\n\t\t\t      void (*callback)(struct cn_msg *,\n\t\t\t\t\t       struct netlink_skb_parms *))\n{\n\tstruct cn_callback_entry *cbq;\n\n\tcbq = kzalloc(sizeof(*cbq), GFP_KERNEL);\n\tif (!cbq) {\n\t\tpr_err(\"Failed to create new callback queue.\\n\");\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cbq->refcnt, 1);\n\n\tatomic_inc(&dev->refcnt);\n\tcbq->pdev = dev;\n\n\tsnprintf(cbq->id.name, sizeof(cbq->id.name), \"%s\", name);\n\tmemcpy(&cbq->id.id, id, sizeof(struct cb_id));\n\tcbq->callback = callback;\n\treturn cbq;\n}\n\nvoid cn_queue_release_callback(struct cn_callback_entry *cbq)\n{\n\tif (!refcount_dec_and_test(&cbq->refcnt))\n\t\treturn;\n\n\tatomic_dec(&cbq->pdev->refcnt);\n\tkfree(cbq);\n}\n\nint cn_cb_equal(const struct cb_id *i1, const struct cb_id *i2)\n{\n\treturn ((i1->idx == i2->idx) && (i1->val == i2->val));\n}\n\nint cn_queue_add_callback(struct cn_queue_dev *dev, const char *name,\n\t\t\t  const struct cb_id *id,\n\t\t\t  void (*callback)(struct cn_msg *,\n\t\t\t\t\t   struct netlink_skb_parms *))\n{\n\tstruct cn_callback_entry *cbq, *__cbq;\n\tint found = 0;\n\n\tcbq = cn_queue_alloc_callback_entry(dev, name, id, callback);\n\tif (!cbq)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&dev->queue_lock);\n\tlist_for_each_entry(__cbq, &dev->queue_list, callback_entry) {\n\t\tif (cn_cb_equal(&__cbq->id.id, id)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tlist_add_tail(&cbq->callback_entry, &dev->queue_list);\n\tspin_unlock_bh(&dev->queue_lock);\n\n\tif (found) {\n\t\tcn_queue_release_callback(cbq);\n\t\treturn -EINVAL;\n\t}\n\n\tcbq->seq = 0;\n\tcbq->group = cbq->id.id.idx;\n\n\treturn 0;\n}\n\nvoid cn_queue_del_callback(struct cn_queue_dev *dev, const struct cb_id *id)\n{\n\tstruct cn_callback_entry *cbq, *n;\n\tint found = 0;\n\n\tspin_lock_bh(&dev->queue_lock);\n\tlist_for_each_entry_safe(cbq, n, &dev->queue_list, callback_entry) {\n\t\tif (cn_cb_equal(&cbq->id.id, id)) {\n\t\t\tlist_del(&cbq->callback_entry);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&dev->queue_lock);\n\n\tif (found)\n\t\tcn_queue_release_callback(cbq);\n}\n\nstruct cn_queue_dev *cn_queue_alloc_dev(const char *name, struct sock *nls)\n{\n\tstruct cn_queue_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tsnprintf(dev->name, sizeof(dev->name), \"%s\", name);\n\tatomic_set(&dev->refcnt, 0);\n\tINIT_LIST_HEAD(&dev->queue_list);\n\tspin_lock_init(&dev->queue_lock);\n\n\tdev->nls = nls;\n\n\treturn dev;\n}\n\nvoid cn_queue_free_dev(struct cn_queue_dev *dev)\n{\n\tstruct cn_callback_entry *cbq, *n;\n\n\tspin_lock_bh(&dev->queue_lock);\n\tlist_for_each_entry_safe(cbq, n, &dev->queue_list, callback_entry)\n\t\tlist_del(&cbq->callback_entry);\n\tspin_unlock_bh(&dev->queue_lock);\n\n\twhile (atomic_read(&dev->refcnt)) {\n\t\tpr_info(\"Waiting for %s to become free: refcnt=%d.\\n\",\n\t\t       dev->name, atomic_read(&dev->refcnt));\n\t\tmsleep(1000);\n\t}\n\n\tkfree(dev);\n\tdev = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}