{
  "module_name": "cn_proc.c",
  "hash_id": "03340198dd725cc2f567136f39ff48d8c44b516243ccc69128be3017ddc3b5f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/connector/cn_proc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/init.h>\n#include <linux/connector.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/atomic.h>\n#include <linux/pid_namespace.h>\n\n#include <linux/cn_proc.h>\n#include <linux/local_lock.h>\n\n \n#define CN_PROC_MSG_SIZE (sizeof(struct cn_msg) + sizeof(struct proc_event) + 4)\n\n \nstatic inline struct cn_msg *buffer_to_cn_msg(__u8 *buffer)\n{\n\tBUILD_BUG_ON(sizeof(struct cn_msg) != 20);\n\treturn (struct cn_msg *)(buffer + 4);\n}\n\nstatic atomic_t proc_event_num_listeners = ATOMIC_INIT(0);\nstatic struct cb_id cn_proc_event_id = { CN_IDX_PROC, CN_VAL_PROC };\n\n \nstruct local_event {\n\tlocal_lock_t lock;\n\t__u32 count;\n};\nstatic DEFINE_PER_CPU(struct local_event, local_event) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\nstatic int cn_filter(struct sock *dsk, struct sk_buff *skb, void *data)\n{\n\t__u32 what, exit_code, *ptr;\n\tenum proc_cn_mcast_op mc_op;\n\tuintptr_t val;\n\n\tif (!dsk || !dsk->sk_user_data || !data)\n\t\treturn 0;\n\n\tptr = (__u32 *)data;\n\twhat = *ptr++;\n\texit_code = *ptr;\n\tval = ((struct proc_input *)(dsk->sk_user_data))->event_type;\n\tmc_op = ((struct proc_input *)(dsk->sk_user_data))->mcast_op;\n\n\tif (mc_op == PROC_CN_MCAST_IGNORE)\n\t\treturn 1;\n\n\tif ((__u32)val == PROC_EVENT_ALL)\n\t\treturn 0;\n\n\t \n\tif (((__u32)val & PROC_EVENT_NONZERO_EXIT) &&\n\t    (what == PROC_EVENT_EXIT)) {\n\t\tif (exit_code)\n\t\t\treturn 0;\n\t}\n\n\tif ((__u32)val & what)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline void send_msg(struct cn_msg *msg)\n{\n\t__u32 filter_data[2];\n\n\tlocal_lock(&local_event.lock);\n\n\tmsg->seq = __this_cpu_inc_return(local_event.count) - 1;\n\t((struct proc_event *)msg->data)->cpu = smp_processor_id();\n\n\t \n\tfilter_data[0] = ((struct proc_event *)msg->data)->what;\n\tif (filter_data[0] == PROC_EVENT_EXIT) {\n\t\tfilter_data[1] =\n\t\t((struct proc_event *)msg->data)->event_data.exit.exit_code;\n\t} else {\n\t\tfilter_data[1] = 0;\n\t}\n\n\tif (cn_netlink_send_mult(msg, msg->len, 0, CN_IDX_PROC, GFP_NOWAIT,\n\t\t\t     cn_filter, (void *)filter_data) == -ESRCH)\n\t\tatomic_set(&proc_event_num_listeners, 0);\n\n\tlocal_unlock(&local_event.lock);\n}\n\nvoid proc_fork_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\tstruct task_struct *parent;\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_FORK;\n\trcu_read_lock();\n\tparent = rcu_dereference(task->real_parent);\n\tev->event_data.fork.parent_pid = parent->pid;\n\tev->event_data.fork.parent_tgid = parent->tgid;\n\trcu_read_unlock();\n\tev->event_data.fork.child_pid = task->pid;\n\tev->event_data.fork.child_tgid = task->tgid;\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_exec_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_EXEC;\n\tev->event_data.exec.process_pid = task->pid;\n\tev->event_data.exec.process_tgid = task->tgid;\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_id_connector(struct task_struct *task, int which_id)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\tconst struct cred *cred;\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->what = which_id;\n\tev->event_data.id.process_pid = task->pid;\n\tev->event_data.id.process_tgid = task->tgid;\n\trcu_read_lock();\n\tcred = __task_cred(task);\n\tif (which_id == PROC_EVENT_UID) {\n\t\tev->event_data.id.r.ruid = from_kuid_munged(&init_user_ns, cred->uid);\n\t\tev->event_data.id.e.euid = from_kuid_munged(&init_user_ns, cred->euid);\n\t} else if (which_id == PROC_EVENT_GID) {\n\t\tev->event_data.id.r.rgid = from_kgid_munged(&init_user_ns, cred->gid);\n\t\tev->event_data.id.e.egid = from_kgid_munged(&init_user_ns, cred->egid);\n\t} else {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tev->timestamp_ns = ktime_get_ns();\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_sid_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_SID;\n\tev->event_data.sid.process_pid = task->pid;\n\tev->event_data.sid.process_tgid = task->tgid;\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_ptrace_connector(struct task_struct *task, int ptrace_id)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_PTRACE;\n\tev->event_data.ptrace.process_pid  = task->pid;\n\tev->event_data.ptrace.process_tgid = task->tgid;\n\tif (ptrace_id == PTRACE_ATTACH) {\n\t\tev->event_data.ptrace.tracer_pid  = current->pid;\n\t\tev->event_data.ptrace.tracer_tgid = current->tgid;\n\t} else if (ptrace_id == PTRACE_DETACH) {\n\t\tev->event_data.ptrace.tracer_pid  = 0;\n\t\tev->event_data.ptrace.tracer_tgid = 0;\n\t} else\n\t\treturn;\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_comm_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_COMM;\n\tev->event_data.comm.process_pid  = task->pid;\n\tev->event_data.comm.process_tgid = task->tgid;\n\tget_task_comm(ev->event_data.comm.comm, task);\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_coredump_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\tstruct task_struct *parent;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_COREDUMP;\n\tev->event_data.coredump.process_pid = task->pid;\n\tev->event_data.coredump.process_tgid = task->tgid;\n\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tparent = rcu_dereference(task->real_parent);\n\t\tev->event_data.coredump.parent_pid = parent->pid;\n\t\tev->event_data.coredump.parent_tgid = parent->tgid;\n\t}\n\trcu_read_unlock();\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\nvoid proc_exit_connector(struct task_struct *task)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\tstruct task_struct *parent;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tev->timestamp_ns = ktime_get_ns();\n\tev->what = PROC_EVENT_EXIT;\n\tev->event_data.exit.process_pid = task->pid;\n\tev->event_data.exit.process_tgid = task->tgid;\n\tev->event_data.exit.exit_code = task->exit_code;\n\tev->event_data.exit.exit_signal = task->exit_signal;\n\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tparent = rcu_dereference(task->real_parent);\n\t\tev->event_data.exit.parent_pid = parent->pid;\n\t\tev->event_data.exit.parent_tgid = parent->tgid;\n\t}\n\trcu_read_unlock();\n\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = 0;  \n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\n \nstatic void cn_proc_ack(int err, int rcvd_seq, int rcvd_ack)\n{\n\tstruct cn_msg *msg;\n\tstruct proc_event *ev;\n\t__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\n\n\tif (atomic_read(&proc_event_num_listeners) < 1)\n\t\treturn;\n\n\tmsg = buffer_to_cn_msg(buffer);\n\tev = (struct proc_event *)msg->data;\n\tmemset(&ev->event_data, 0, sizeof(ev->event_data));\n\tmsg->seq = rcvd_seq;\n\tev->timestamp_ns = ktime_get_ns();\n\tev->cpu = -1;\n\tev->what = PROC_EVENT_NONE;\n\tev->event_data.ack.err = err;\n\tmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\n\tmsg->ack = rcvd_ack + 1;\n\tmsg->len = sizeof(*ev);\n\tmsg->flags = 0;  \n\tsend_msg(msg);\n}\n\n \nstatic void cn_proc_mcast_ctl(struct cn_msg *msg,\n\t\t\t      struct netlink_skb_parms *nsp)\n{\n\tenum proc_cn_mcast_op mc_op = 0, prev_mc_op = 0;\n\tstruct proc_input *pinput = NULL;\n\tenum proc_cn_event ev_type = 0;\n\tint err = 0, initial = 0;\n\tstruct sock *sk = NULL;\n\n\t \n\tif ((current_user_ns() != &init_user_ns) ||\n\t    !task_is_in_init_pid_ns(current))\n\t\treturn;\n\n\tif (msg->len == sizeof(*pinput)) {\n\t\tpinput = (struct proc_input *)msg->data;\n\t\tmc_op = pinput->mcast_op;\n\t\tev_type = pinput->event_type;\n\t} else if (msg->len == sizeof(mc_op)) {\n\t\tmc_op = *((enum proc_cn_mcast_op *)msg->data);\n\t\tev_type = PROC_EVENT_ALL;\n\t} else {\n\t\treturn;\n\t}\n\n\tev_type = valid_event((enum proc_cn_event)ev_type);\n\n\tif (ev_type == PROC_EVENT_NONE)\n\t\tev_type = PROC_EVENT_ALL;\n\n\tif (nsp->sk) {\n\t\tsk = nsp->sk;\n\t\tif (sk->sk_user_data == NULL) {\n\t\t\tsk->sk_user_data = kzalloc(sizeof(struct proc_input),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (sk->sk_user_data == NULL) {\n\t\t\t\terr = ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinitial = 1;\n\t\t} else {\n\t\t\tprev_mc_op =\n\t\t\t((struct proc_input *)(sk->sk_user_data))->mcast_op;\n\t\t}\n\t\t((struct proc_input *)(sk->sk_user_data))->event_type =\n\t\t\tev_type;\n\t\t((struct proc_input *)(sk->sk_user_data))->mcast_op = mc_op;\n\t}\n\n\tswitch (mc_op) {\n\tcase PROC_CN_MCAST_LISTEN:\n\t\tif (initial || (prev_mc_op != PROC_CN_MCAST_LISTEN))\n\t\t\tatomic_inc(&proc_event_num_listeners);\n\t\tbreak;\n\tcase PROC_CN_MCAST_IGNORE:\n\t\tif (!initial && (prev_mc_op != PROC_CN_MCAST_IGNORE))\n\t\t\tatomic_dec(&proc_event_num_listeners);\n\t\t((struct proc_input *)(sk->sk_user_data))->event_type =\n\t\t\tPROC_EVENT_NONE;\n\t\tbreak;\n\tdefault:\n\t\terr = EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tcn_proc_ack(err, msg->seq, msg->ack);\n}\n\n \nstatic int __init cn_proc_init(void)\n{\n\tint err = cn_add_callback(&cn_proc_event_id,\n\t\t\t\t  \"cn_proc\",\n\t\t\t\t  &cn_proc_mcast_ctl);\n\tif (err) {\n\t\tpr_warn(\"cn_proc failed to register\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\ndevice_initcall(cn_proc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}