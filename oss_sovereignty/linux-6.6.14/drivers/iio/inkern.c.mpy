{
  "module_name": "inkern.c",
  "hash_id": "54284910319e2995ca8f4455a17494a2c452e60f2f7ab3c1bcf3a29940a3048e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/inkern.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/minmax.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/iio-opaque.h>\n#include \"iio_core.h\"\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/consumer.h>\n\nstruct iio_map_internal {\n\tstruct iio_dev *indio_dev;\n\tstruct iio_map *map;\n\tstruct list_head l;\n};\n\nstatic LIST_HEAD(iio_map_list);\nstatic DEFINE_MUTEX(iio_map_list_lock);\n\nstatic int iio_map_array_unregister_locked(struct iio_dev *indio_dev)\n{\n\tint ret = -ENODEV;\n\tstruct iio_map_internal *mapi, *next;\n\n\tlist_for_each_entry_safe(mapi, next, &iio_map_list, l) {\n\t\tif (indio_dev == mapi->indio_dev) {\n\t\t\tlist_del(&mapi->l);\n\t\t\tkfree(mapi);\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint iio_map_array_register(struct iio_dev *indio_dev, struct iio_map *maps)\n{\n\tint i = 0, ret = 0;\n\tstruct iio_map_internal *mapi;\n\n\tif (!maps)\n\t\treturn 0;\n\n\tmutex_lock(&iio_map_list_lock);\n\twhile (maps[i].consumer_dev_name) {\n\t\tmapi = kzalloc(sizeof(*mapi), GFP_KERNEL);\n\t\tif (!mapi) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_ret;\n\t\t}\n\t\tmapi->map = &maps[i];\n\t\tmapi->indio_dev = indio_dev;\n\t\tlist_add_tail(&mapi->l, &iio_map_list);\n\t\ti++;\n\t}\nerror_ret:\n\tif (ret)\n\t\tiio_map_array_unregister_locked(indio_dev);\n\tmutex_unlock(&iio_map_list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_map_array_register);\n\n \nint iio_map_array_unregister(struct iio_dev *indio_dev)\n{\n\tint ret;\n\n\tmutex_lock(&iio_map_list_lock);\n\tret = iio_map_array_unregister_locked(indio_dev);\n\tmutex_unlock(&iio_map_list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_map_array_unregister);\n\nstatic void iio_map_array_unregister_cb(void *indio_dev)\n{\n\tiio_map_array_unregister(indio_dev);\n}\n\nint devm_iio_map_array_register(struct device *dev, struct iio_dev *indio_dev, struct iio_map *maps)\n{\n\tint ret;\n\n\tret = iio_map_array_register(indio_dev, maps);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, iio_map_array_unregister_cb, indio_dev);\n}\nEXPORT_SYMBOL_GPL(devm_iio_map_array_register);\n\nstatic const struct iio_chan_spec\n*iio_chan_spec_from_name(const struct iio_dev *indio_dev, const char *name)\n{\n\tint i;\n\tconst struct iio_chan_spec *chan = NULL;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tif (indio_dev->channels[i].datasheet_name &&\n\t\t    strcmp(name, indio_dev->channels[i].datasheet_name) == 0) {\n\t\t\tchan = &indio_dev->channels[i];\n\t\t\tbreak;\n\t\t}\n\treturn chan;\n}\n\n \nstatic int __fwnode_iio_simple_xlate(struct iio_dev *indio_dev,\n\t\t\t\t     const struct fwnode_reference_args *iiospec)\n{\n\tif (!iiospec->nargs)\n\t\treturn 0;\n\n\tif (iiospec->args[0] >= indio_dev->num_channels) {\n\t\tdev_err(&indio_dev->dev, \"invalid channel index %llu\\n\",\n\t\t\tiiospec->args[0]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn iiospec->args[0];\n}\n\nstatic int __fwnode_iio_channel_get(struct iio_channel *channel,\n\t\t\t\t    struct fwnode_handle *fwnode, int index)\n{\n\tstruct fwnode_reference_args iiospec;\n\tstruct device *idev;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\n\terr = fwnode_property_get_reference_args(fwnode, \"io-channels\",\n\t\t\t\t\t\t \"#io-channel-cells\", 0,\n\t\t\t\t\t\t index, &iiospec);\n\tif (err)\n\t\treturn err;\n\n\tidev = bus_find_device_by_fwnode(&iio_bus_type, iiospec.fwnode);\n\tif (!idev) {\n\t\tfwnode_handle_put(iiospec.fwnode);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tindio_dev = dev_to_iio_dev(idev);\n\tchannel->indio_dev = indio_dev;\n\tif (indio_dev->info->fwnode_xlate)\n\t\tindex = indio_dev->info->fwnode_xlate(indio_dev, &iiospec);\n\telse\n\t\tindex = __fwnode_iio_simple_xlate(indio_dev, &iiospec);\n\tfwnode_handle_put(iiospec.fwnode);\n\tif (index < 0)\n\t\tgoto err_put;\n\tchannel->channel = &indio_dev->channels[index];\n\n\treturn 0;\n\nerr_put:\n\tiio_device_put(indio_dev);\n\treturn index;\n}\n\nstatic struct iio_channel *fwnode_iio_channel_get(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  int index)\n{\n\tstruct iio_channel *channel;\n\tint err;\n\n\tif (index < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = __fwnode_iio_channel_get(channel, fwnode, index);\n\tif (err)\n\t\tgoto err_free_channel;\n\n\treturn channel;\n\nerr_free_channel:\n\tkfree(channel);\n\treturn ERR_PTR(err);\n}\n\nstatic struct iio_channel *\n__fwnode_iio_channel_get_by_name(struct fwnode_handle *fwnode, const char *name)\n{\n\tstruct iio_channel *chan;\n\tint index = 0;\n\n\t \n\tif (name)\n\t\tindex = fwnode_property_match_string(fwnode, \"io-channel-names\",\n\t\t\t\t\t\t     name);\n\n\tchan = fwnode_iio_channel_get(fwnode, index);\n\tif (!IS_ERR(chan) || PTR_ERR(chan) == -EPROBE_DEFER)\n\t\treturn chan;\n\tif (name) {\n\t\tif (index >= 0) {\n\t\t\tpr_err(\"ERROR: could not get IIO channel %pfw:%s(%i)\\n\",\n\t\t\t       fwnode, name, index);\n\t\t\t \n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t \n\t\tif (PTR_ERR(chan) != -EINVAL && PTR_ERR(chan) != -ENOENT)\n\t\t\treturn chan;\n\t} else if (PTR_ERR(chan) != -ENOENT) {\n\t\t \n\t\treturn chan;\n\t}\n\n\t \n\treturn ERR_PTR(-ENODEV);\n}\n\nstruct iio_channel *fwnode_iio_channel_get_by_name(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t   const char *name)\n{\n\tstruct fwnode_handle *parent;\n\tstruct iio_channel *chan;\n\n\t \n\tchan = __fwnode_iio_channel_get_by_name(fwnode, name);\n\tif (!IS_ERR(chan) || PTR_ERR(chan) != -ENODEV)\n\t\treturn chan;\n\n\t \n\tfwnode_for_each_parent_node(fwnode, parent) {\n\t\tif (!fwnode_property_present(parent, \"io-channel-ranges\")) {\n\t\t\tfwnode_handle_put(parent);\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\t}\n\n\t\tchan = __fwnode_iio_channel_get_by_name(fwnode, name);\n\t\tif (!IS_ERR(chan) || PTR_ERR(chan) != -ENODEV) {\n\t\t\tfwnode_handle_put(parent);\n \t\t\treturn chan;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL_GPL(fwnode_iio_channel_get_by_name);\n\nstatic struct iio_channel *fwnode_iio_channel_get_all(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct iio_channel *chans;\n\tint i, mapind, nummaps = 0;\n\tint ret;\n\n\tdo {\n\t\tret = fwnode_property_get_reference_args(fwnode, \"io-channels\",\n\t\t\t\t\t\t\t \"#io-channel-cells\", 0,\n\t\t\t\t\t\t\t nummaps, NULL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (++nummaps);\n\n\tif (nummaps == 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tchans = kcalloc(nummaps + 1, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfor (mapind = 0; mapind < nummaps; mapind++) {\n\t\tret = __fwnode_iio_channel_get(&chans[mapind], fwnode, mapind);\n\t\tif (ret)\n\t\t\tgoto error_free_chans;\n\t}\n\treturn chans;\n\nerror_free_chans:\n\tfor (i = 0; i < mapind; i++)\n\t\tiio_device_put(chans[i].indio_dev);\n\tkfree(chans);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct iio_channel *iio_channel_get_sys(const char *name,\n\t\t\t\t\t       const char *channel_name)\n{\n\tstruct iio_map_internal *c_i = NULL, *c = NULL;\n\tstruct iio_channel *channel;\n\tint err;\n\n\tif (!(name || channel_name))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tmutex_lock(&iio_map_list_lock);\n\tlist_for_each_entry(c_i, &iio_map_list, l) {\n\t\tif ((name && strcmp(name, c_i->map->consumer_dev_name) != 0) ||\n\t\t    (channel_name &&\n\t\t     strcmp(channel_name, c_i->map->consumer_channel) != 0))\n\t\t\tcontinue;\n\t\tc = c_i;\n\t\tiio_device_get(c->indio_dev);\n\t\tbreak;\n\t}\n\tmutex_unlock(&iio_map_list_lock);\n\tif (!c)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel) {\n\t\terr = -ENOMEM;\n\t\tgoto error_no_mem;\n\t}\n\n\tchannel->indio_dev = c->indio_dev;\n\n\tif (c->map->adc_channel_label) {\n\t\tchannel->channel =\n\t\t\tiio_chan_spec_from_name(channel->indio_dev,\n\t\t\t\t\t\tc->map->adc_channel_label);\n\n\t\tif (!channel->channel) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto error_no_chan;\n\t\t}\n\t}\n\n\treturn channel;\n\nerror_no_chan:\n\tkfree(channel);\nerror_no_mem:\n\tiio_device_put(c->indio_dev);\n\treturn ERR_PTR(err);\n}\n\nstruct iio_channel *iio_channel_get(struct device *dev,\n\t\t\t\t    const char *channel_name)\n{\n\tconst char *name = dev ? dev_name(dev) : NULL;\n\tstruct iio_channel *channel;\n\n\tif (dev) {\n\t\tchannel = fwnode_iio_channel_get_by_name(dev_fwnode(dev),\n\t\t\t\t\t\t\t channel_name);\n\t\tif (!IS_ERR(channel) || PTR_ERR(channel) != -ENODEV)\n\t\t\treturn channel;\n\t}\n\n\treturn iio_channel_get_sys(name, channel_name);\n}\nEXPORT_SYMBOL_GPL(iio_channel_get);\n\nvoid iio_channel_release(struct iio_channel *channel)\n{\n\tif (!channel)\n\t\treturn;\n\tiio_device_put(channel->indio_dev);\n\tkfree(channel);\n}\nEXPORT_SYMBOL_GPL(iio_channel_release);\n\nstatic void devm_iio_channel_free(void *iio_channel)\n{\n\tiio_channel_release(iio_channel);\n}\n\nstruct iio_channel *devm_iio_channel_get(struct device *dev,\n\t\t\t\t\t const char *channel_name)\n{\n\tstruct iio_channel *channel;\n\tint ret;\n\n\tchannel = iio_channel_get(dev, channel_name);\n\tif (IS_ERR(channel))\n\t\treturn channel;\n\n\tret = devm_add_action_or_reset(dev, devm_iio_channel_free, channel);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn channel;\n}\nEXPORT_SYMBOL_GPL(devm_iio_channel_get);\n\nstruct iio_channel *devm_fwnode_iio_channel_get_by_name(struct device *dev,\n\t\t\t\t\t\t\tstruct fwnode_handle *fwnode,\n\t\t\t\t\t\t\tconst char *channel_name)\n{\n\tstruct iio_channel *channel;\n\tint ret;\n\n\tchannel = fwnode_iio_channel_get_by_name(fwnode, channel_name);\n\tif (IS_ERR(channel))\n\t\treturn channel;\n\n\tret = devm_add_action_or_reset(dev, devm_iio_channel_free, channel);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn channel;\n}\nEXPORT_SYMBOL_GPL(devm_fwnode_iio_channel_get_by_name);\n\nstruct iio_channel *iio_channel_get_all(struct device *dev)\n{\n\tconst char *name;\n\tstruct iio_channel *chans;\n\tstruct iio_map_internal *c = NULL;\n\tint nummaps = 0;\n\tint mapind = 0;\n\tint i, ret;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tchans = fwnode_iio_channel_get_all(dev);\n\t \n\tif (!IS_ERR(chans) || PTR_ERR(chans) != -ENODEV)\n\t\treturn chans;\n\n\tname = dev_name(dev);\n\n\tmutex_lock(&iio_map_list_lock);\n\t \n\tlist_for_each_entry(c, &iio_map_list, l)\n\t\tif (name && strcmp(name, c->map->consumer_dev_name) != 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\tnummaps++;\n\n\tif (nummaps == 0) {\n\t\tret = -ENODEV;\n\t\tgoto error_ret;\n\t}\n\n\t \n\tchans = kcalloc(nummaps + 1, sizeof(*chans), GFP_KERNEL);\n\tif (!chans) {\n\t\tret = -ENOMEM;\n\t\tgoto error_ret;\n\t}\n\n\t \n\tlist_for_each_entry(c, &iio_map_list, l) {\n\t\tif (name && strcmp(name, c->map->consumer_dev_name) != 0)\n\t\t\tcontinue;\n\t\tchans[mapind].indio_dev = c->indio_dev;\n\t\tchans[mapind].data = c->map->consumer_data;\n\t\tchans[mapind].channel =\n\t\t\tiio_chan_spec_from_name(chans[mapind].indio_dev,\n\t\t\t\t\t\tc->map->adc_channel_label);\n\t\tif (!chans[mapind].channel) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_free_chans;\n\t\t}\n\t\tiio_device_get(chans[mapind].indio_dev);\n\t\tmapind++;\n\t}\n\tif (mapind == 0) {\n\t\tret = -ENODEV;\n\t\tgoto error_free_chans;\n\t}\n\tmutex_unlock(&iio_map_list_lock);\n\n\treturn chans;\n\nerror_free_chans:\n\tfor (i = 0; i < nummaps; i++)\n\t\tiio_device_put(chans[i].indio_dev);\n\tkfree(chans);\nerror_ret:\n\tmutex_unlock(&iio_map_list_lock);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(iio_channel_get_all);\n\nvoid iio_channel_release_all(struct iio_channel *channels)\n{\n\tstruct iio_channel *chan = &channels[0];\n\n\twhile (chan->indio_dev) {\n\t\tiio_device_put(chan->indio_dev);\n\t\tchan++;\n\t}\n\tkfree(channels);\n}\nEXPORT_SYMBOL_GPL(iio_channel_release_all);\n\nstatic void devm_iio_channel_free_all(void *iio_channels)\n{\n\tiio_channel_release_all(iio_channels);\n}\n\nstruct iio_channel *devm_iio_channel_get_all(struct device *dev)\n{\n\tstruct iio_channel *channels;\n\tint ret;\n\n\tchannels = iio_channel_get_all(dev);\n\tif (IS_ERR(channels))\n\t\treturn channels;\n\n\tret = devm_add_action_or_reset(dev, devm_iio_channel_free_all,\n\t\t\t\t       channels);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn channels;\n}\nEXPORT_SYMBOL_GPL(devm_iio_channel_get_all);\n\nstatic int iio_channel_read(struct iio_channel *chan, int *val, int *val2,\n\t\t\t    enum iio_chan_info_enum info)\n{\n\tint unused;\n\tint vals[INDIO_MAX_RAW_ELEMENTS];\n\tint ret;\n\tint val_len = 2;\n\n\tif (!val2)\n\t\tval2 = &unused;\n\n\tif (!iio_channel_has_info(chan->channel, info))\n\t\treturn -EINVAL;\n\n\tif (chan->indio_dev->info->read_raw_multi) {\n\t\tret = chan->indio_dev->info->read_raw_multi(chan->indio_dev,\n\t\t\t\t\tchan->channel, INDIO_MAX_RAW_ELEMENTS,\n\t\t\t\t\tvals, &val_len, info);\n\t\t*val = vals[0];\n\t\t*val2 = vals[1];\n\t} else {\n\t\tret = chan->indio_dev->info->read_raw(chan->indio_dev,\n\t\t\t\t\tchan->channel, val, val2, info);\n\t}\n\n\treturn ret;\n}\n\nint iio_read_channel_raw(struct iio_channel *chan, int *val)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_RAW);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_raw);\n\nint iio_read_channel_average_raw(struct iio_channel *chan, int *val)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_AVERAGE_RAW);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_average_raw);\n\nstatic int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,\n\t\t\t\t\t\t int raw, int *processed,\n\t\t\t\t\t\t unsigned int scale)\n{\n\tint scale_type, scale_val, scale_val2;\n\tint offset_type, offset_val, offset_val2;\n\ts64 raw64 = raw;\n\n\toffset_type = iio_channel_read(chan, &offset_val, &offset_val2,\n\t\t\t\t       IIO_CHAN_INFO_OFFSET);\n\tif (offset_type >= 0) {\n\t\tswitch (offset_type) {\n\t\tcase IIO_VAL_INT:\n\t\t\tbreak;\n\t\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\tcase IIO_VAL_INT_PLUS_NANO:\n\t\t\t \n\t\t\tbreak;\n\t\tcase IIO_VAL_FRACTIONAL:\n\t\t\toffset_val /= offset_val2;\n\t\t\tbreak;\n\t\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\t\toffset_val >>= offset_val2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\traw64 += offset_val;\n\t}\n\n\tscale_type = iio_channel_read(chan, &scale_val, &scale_val2,\n\t\t\t\t      IIO_CHAN_INFO_SCALE);\n\tif (scale_type < 0) {\n\t\t \n\t\t*processed = raw * scale;\n\t\treturn 0;\n\t}\n\n\tswitch (scale_type) {\n\tcase IIO_VAL_INT:\n\t\t*processed = raw64 * scale_val * scale;\n\t\tbreak;\n\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\tif (scale_val2 < 0)\n\t\t\t*processed = -raw64 * scale_val;\n\t\telse\n\t\t\t*processed = raw64 * scale_val;\n\t\t*processed += div_s64(raw64 * (s64)scale_val2 * scale,\n\t\t\t\t      1000000LL);\n\t\tbreak;\n\tcase IIO_VAL_INT_PLUS_NANO:\n\t\tif (scale_val2 < 0)\n\t\t\t*processed = -raw64 * scale_val;\n\t\telse\n\t\t\t*processed = raw64 * scale_val;\n\t\t*processed += div_s64(raw64 * (s64)scale_val2 * scale,\n\t\t\t\t      1000000000LL);\n\t\tbreak;\n\tcase IIO_VAL_FRACTIONAL:\n\t\t*processed = div_s64(raw64 * (s64)scale_val * scale,\n\t\t\t\t     scale_val2);\n\t\tbreak;\n\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\t*processed = (raw64 * (s64)scale_val * scale) >> scale_val2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint iio_convert_raw_to_processed(struct iio_channel *chan, int raw,\n\t\t\t\t int *processed, unsigned int scale)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_convert_raw_to_processed_unlocked(chan, raw, processed,\n\t\t\t\t\t\t    scale);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_convert_raw_to_processed);\n\nint iio_read_channel_attribute(struct iio_channel *chan, int *val, int *val2,\n\t\t\t       enum iio_chan_info_enum attribute)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read(chan, val, val2, attribute);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_attribute);\n\nint iio_read_channel_offset(struct iio_channel *chan, int *val, int *val2)\n{\n\treturn iio_read_channel_attribute(chan, val, val2, IIO_CHAN_INFO_OFFSET);\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_offset);\n\nint iio_read_channel_processed_scale(struct iio_channel *chan, int *val,\n\t\t\t\t     unsigned int scale)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tif (iio_channel_has_info(chan->channel, IIO_CHAN_INFO_PROCESSED)) {\n\t\tret = iio_channel_read(chan, val, NULL,\n\t\t\t\t       IIO_CHAN_INFO_PROCESSED);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t\t*val *= scale;\n\t} else {\n\t\tret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_RAW);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t\tret = iio_convert_raw_to_processed_unlocked(chan, *val, val,\n\t\t\t\t\t\t\t    scale);\n\t}\n\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_processed_scale);\n\nint iio_read_channel_processed(struct iio_channel *chan, int *val)\n{\n\t \n\treturn iio_read_channel_processed_scale(chan, val, 1);\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_processed);\n\nint iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)\n{\n\treturn iio_read_channel_attribute(chan, val, val2, IIO_CHAN_INFO_SCALE);\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_scale);\n\nstatic int iio_channel_read_avail(struct iio_channel *chan,\n\t\t\t\t  const int **vals, int *type, int *length,\n\t\t\t\t  enum iio_chan_info_enum info)\n{\n\tif (!iio_channel_has_available(chan->channel, info))\n\t\treturn -EINVAL;\n\n\treturn chan->indio_dev->info->read_avail(chan->indio_dev, chan->channel,\n\t\t\t\t\t\t vals, type, length, info);\n}\n\nint iio_read_avail_channel_attribute(struct iio_channel *chan,\n\t\t\t\t     const int **vals, int *type, int *length,\n\t\t\t\t     enum iio_chan_info_enum attribute)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read_avail(chan, vals, type, length, attribute);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_avail_channel_attribute);\n\nint iio_read_avail_channel_raw(struct iio_channel *chan,\n\t\t\t       const int **vals, int *length)\n{\n\tint ret;\n\tint type;\n\n\tret = iio_read_avail_channel_attribute(chan, vals, &type, length,\n\t\t\t\t\t       IIO_CHAN_INFO_RAW);\n\n\tif (ret >= 0 && type != IIO_VAL_INT)\n\t\t \n\t\tret = -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_avail_channel_raw);\n\nstatic int iio_channel_read_max(struct iio_channel *chan,\n\t\t\t\tint *val, int *val2, int *type,\n\t\t\t\tenum iio_chan_info_enum info)\n{\n\tconst int *vals;\n\tint length;\n\tint ret;\n\n\tret = iio_channel_read_avail(chan, &vals, type, &length, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase IIO_AVAIL_RANGE:\n\t\tswitch (*type) {\n\t\tcase IIO_VAL_INT:\n\t\t\t*val = vals[2];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*val = vals[4];\n\t\t\tif (val2)\n\t\t\t\t*val2 = vals[5];\n\t\t}\n\t\treturn 0;\n\n\tcase IIO_AVAIL_LIST:\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (*type) {\n\t\tcase IIO_VAL_INT:\n\t\t\t*val = max_array(vals, length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint iio_read_max_channel_raw(struct iio_channel *chan, int *val)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\tint type;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read_max(chan, val, NULL, &type, IIO_CHAN_INFO_RAW);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_max_channel_raw);\n\nstatic int iio_channel_read_min(struct iio_channel *chan,\n\t\t\t\tint *val, int *val2, int *type,\n\t\t\t\tenum iio_chan_info_enum info)\n{\n\tconst int *vals;\n\tint length;\n\tint ret;\n\n\tret = iio_channel_read_avail(chan, &vals, type, &length, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase IIO_AVAIL_RANGE:\n\t\tswitch (*type) {\n\t\tcase IIO_VAL_INT:\n\t\t\t*val = vals[0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*val = vals[0];\n\t\t\tif (val2)\n\t\t\t\t*val2 = vals[1];\n\t\t}\n\t\treturn 0;\n\n\tcase IIO_AVAIL_LIST:\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (*type) {\n\t\tcase IIO_VAL_INT:\n\t\t\t*val = min_array(vals, length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint iio_read_min_channel_raw(struct iio_channel *chan, int *val)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\tint type;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_read_min(chan, val, NULL, &type, IIO_CHAN_INFO_RAW);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_read_min_channel_raw);\n\nint iio_get_channel_type(struct iio_channel *chan, enum iio_chan_type *type)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret = 0;\n\t \n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\t*type = chan->channel->type;\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_get_channel_type);\n\nstatic int iio_channel_write(struct iio_channel *chan, int val, int val2,\n\t\t\t     enum iio_chan_info_enum info)\n{\n\treturn chan->indio_dev->info->write_raw(chan->indio_dev,\n\t\t\t\t\t\tchan->channel, val, val2, info);\n}\n\nint iio_write_channel_attribute(struct iio_channel *chan, int val, int val2,\n\t\t\t\tenum iio_chan_info_enum attribute)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);\n\tint ret;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\tif (!chan->indio_dev->info) {\n\t\tret = -ENODEV;\n\t\tgoto err_unlock;\n\t}\n\n\tret = iio_channel_write(chan, val, val2, attribute);\nerr_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_write_channel_attribute);\n\nint iio_write_channel_raw(struct iio_channel *chan, int val)\n{\n\treturn iio_write_channel_attribute(chan, val, 0, IIO_CHAN_INFO_RAW);\n}\nEXPORT_SYMBOL_GPL(iio_write_channel_raw);\n\nunsigned int iio_get_channel_ext_info_count(struct iio_channel *chan)\n{\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\tunsigned int i = 0;\n\n\tif (!chan->channel->ext_info)\n\t\treturn i;\n\n\tfor (ext_info = chan->channel->ext_info; ext_info->name; ext_info++)\n\t\t++i;\n\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(iio_get_channel_ext_info_count);\n\nstatic const struct iio_chan_spec_ext_info *\niio_lookup_ext_info(const struct iio_channel *chan, const char *attr)\n{\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\tif (!chan->channel->ext_info)\n\t\treturn NULL;\n\n\tfor (ext_info = chan->channel->ext_info; ext_info->name; ++ext_info) {\n\t\tif (!strcmp(attr, ext_info->name))\n\t\t\treturn ext_info;\n\t}\n\n\treturn NULL;\n}\n\nssize_t iio_read_channel_ext_info(struct iio_channel *chan,\n\t\t\t\t  const char *attr, char *buf)\n{\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\text_info = iio_lookup_ext_info(chan, attr);\n\tif (!ext_info)\n\t\treturn -EINVAL;\n\n\treturn ext_info->read(chan->indio_dev, ext_info->private,\n\t\t\t      chan->channel, buf);\n}\nEXPORT_SYMBOL_GPL(iio_read_channel_ext_info);\n\nssize_t iio_write_channel_ext_info(struct iio_channel *chan, const char *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\text_info = iio_lookup_ext_info(chan, attr);\n\tif (!ext_info)\n\t\treturn -EINVAL;\n\n\treturn ext_info->write(chan->indio_dev, ext_info->private,\n\t\t\t       chan->channel, buf, len);\n}\nEXPORT_SYMBOL_GPL(iio_write_channel_ext_info);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}