{
  "module_name": "ad7746.c",
  "hash_id": "8498e3a237fdd0e041f198601cfb98de5ece15337f0cc20fddb7a27756f4e293",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/cdc/ad7746.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/sysfs.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n\n#define AD7746_REG_STATUS\t\t0\n#define AD7746_REG_CAP_DATA_HIGH\t1\n#define AD7746_REG_VT_DATA_HIGH\t\t4\n#define AD7746_REG_CAP_SETUP\t\t7\n#define AD7746_REG_VT_SETUP\t\t8\n#define AD7746_REG_EXC_SETUP\t\t9\n#define AD7746_REG_CFG\t\t\t10\n#define AD7746_REG_CAPDACA\t\t11\n#define AD7746_REG_CAPDACB\t\t12\n#define AD7746_REG_CAP_OFFH\t\t13\n#define AD7746_REG_CAP_GAINH\t\t15\n#define AD7746_REG_VOLT_GAINH\t\t17\n\n \n#define AD7746_STATUS_EXCERR\t\tBIT(3)\n#define AD7746_STATUS_RDY\t\tBIT(2)\n#define AD7746_STATUS_RDYVT\t\tBIT(1)\n#define AD7746_STATUS_RDYCAP\t\tBIT(0)\n\n \n#define AD7746_CAPSETUP_CAPEN\t\tBIT(7)\n#define AD7746_CAPSETUP_CIN2\t\tBIT(6)  \n#define AD7746_CAPSETUP_CAPDIFF\t\tBIT(5)\n#define AD7746_CAPSETUP_CACHOP\t\tBIT(0)\n\n \n#define AD7746_VTSETUP_VTEN\t\tBIT(7)\n#define AD7746_VTSETUP_VTMD_MASK\tGENMASK(6, 5)\n#define AD7746_VTSETUP_VTMD_INT_TEMP\t0\n#define AD7746_VTSETUP_VTMD_EXT_TEMP\t1\n#define AD7746_VTSETUP_VTMD_VDD_MON\t2\n#define AD7746_VTSETUP_VTMD_EXT_VIN\t3\n#define AD7746_VTSETUP_EXTREF\t\tBIT(4)\n#define AD7746_VTSETUP_VTSHORT\t\tBIT(1)\n#define AD7746_VTSETUP_VTCHOP\t\tBIT(0)\n\n \n#define AD7746_EXCSETUP_CLKCTRL\t\tBIT(7)\n#define AD7746_EXCSETUP_EXCON\t\tBIT(6)\n#define AD7746_EXCSETUP_EXCB\t\tBIT(5)\n#define AD7746_EXCSETUP_NEXCB\t\tBIT(4)\n#define AD7746_EXCSETUP_EXCA\t\tBIT(3)\n#define AD7746_EXCSETUP_NEXCA\t\tBIT(2)\n#define AD7746_EXCSETUP_EXCLVL_MASK\tGENMASK(1, 0)\n\n \n#define AD7746_CONF_VTFS_MASK\t\tGENMASK(7, 6)\n#define AD7746_CONF_CAPFS_MASK\t\tGENMASK(5, 3)\n#define AD7746_CONF_MODE_MASK\t\tGENMASK(2, 0)\n#define AD7746_CONF_MODE_IDLE\t\t0\n#define AD7746_CONF_MODE_CONT_CONV\t1\n#define AD7746_CONF_MODE_SINGLE_CONV\t2\n#define AD7746_CONF_MODE_PWRDN\t\t3\n#define AD7746_CONF_MODE_OFFS_CAL\t5\n#define AD7746_CONF_MODE_GAIN_CAL\t6\n\n \n#define AD7746_CAPDAC_DACEN\t\tBIT(7)\n#define AD7746_CAPDAC_DACP_MASK\t\tGENMASK(6, 0)\n\nstruct ad7746_chip_info {\n\tstruct i2c_client *client;\n\tstruct mutex lock;  \n\t \n\tu8\tconfig;\n\tu8\tcap_setup;\n\tu8\tvt_setup;\n\tu8\tcapdac[2][2];\n\ts8\tcapdac_set;\n};\n\nenum ad7746_chan {\n\tVIN,\n\tVIN_VDD,\n\tTEMP_INT,\n\tTEMP_EXT,\n\tCIN1,\n\tCIN1_DIFF,\n\tCIN2,\n\tCIN2_DIFF,\n};\n\nstruct ad7746_chan_info {\n\tu8 addr;\n\tunion {\n\t\tu8 vtmd;\n\t\tstruct {  \n\t\t\tunsigned int cin2 : 1;\n\t\t\tunsigned int capdiff : 1;\n\t\t};\n\t};\n};\n\nstatic const struct ad7746_chan_info ad7746_chan_info[] = {\n\t[VIN] = {\n\t\t.addr = AD7746_REG_VT_DATA_HIGH,\n\t\t.vtmd = AD7746_VTSETUP_VTMD_EXT_VIN,\n\t},\n\t[VIN_VDD] = {\n\t\t.addr = AD7746_REG_VT_DATA_HIGH,\n\t\t.vtmd = AD7746_VTSETUP_VTMD_VDD_MON,\n\t},\n\t[TEMP_INT] = {\n\t\t.addr = AD7746_REG_VT_DATA_HIGH,\n\t\t.vtmd = AD7746_VTSETUP_VTMD_INT_TEMP,\n\t},\n\t[TEMP_EXT] = {\n\t\t.addr = AD7746_REG_VT_DATA_HIGH,\n\t\t.vtmd = AD7746_VTSETUP_VTMD_EXT_TEMP,\n\t},\n\t[CIN1] = {\n\t\t.addr = AD7746_REG_CAP_DATA_HIGH,\n\t},\n\t[CIN1_DIFF] = {\n\t\t.addr =  AD7746_REG_CAP_DATA_HIGH,\n\t\t.capdiff = 1,\n\t},\n\t[CIN2] = {\n\t\t.addr = AD7746_REG_CAP_DATA_HIGH,\n\t\t.cin2 = 1,\n\t},\n\t[CIN2_DIFF] = {\n\t\t.addr = AD7746_REG_CAP_DATA_HIGH,\n\t\t.cin2 = 1,\n\t\t.capdiff = 1,\n\t},\n};\n\nstatic const struct iio_chan_spec ad7746_channels[] = {\n\t[VIN] = {\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = VIN,\n\t},\n\t[VIN_VDD] = {\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.extend_name = \"supply\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = VIN_VDD,\n\t},\n\t[TEMP_INT] = {\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = TEMP_INT,\n\t},\n\t[TEMP_EXT] = {\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = TEMP_EXT,\n\t},\n\t[CIN1] = {\n\t\t.type = IIO_CAPACITANCE,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = CIN1,\n\t},\n\t[CIN1_DIFF] = {\n\t\t.type = IIO_CAPACITANCE,\n\t\t.differential = 1,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.channel2 = 2,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) | BIT(IIO_CHAN_INFO_ZEROPOINT),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = CIN1_DIFF,\n\t},\n\t[CIN2] = {\n\t\t.type = IIO_CAPACITANCE,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = CIN2,\n\t},\n\t[CIN2_DIFF] = {\n\t\t.type = IIO_CAPACITANCE,\n\t\t.differential = 1,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.channel2 = 3,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) | BIT(IIO_CHAN_INFO_ZEROPOINT),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = CIN2_DIFF,\n\t}\n};\n\n \nstatic const unsigned char ad7746_vt_filter_rate_table[][2] = {\n\t{ 50, 20 + 1 }, { 31, 32 + 1 }, { 16, 62 + 1 }, { 8, 122 + 1 },\n};\n\nstatic const unsigned char ad7746_cap_filter_rate_table[][2] = {\n\t{ 91, 11 + 1 }, { 84, 12 + 1 }, { 50, 20 + 1 }, { 26, 38 + 1 },\n\t{ 16, 62 + 1 }, { 13, 77 + 1 }, { 11, 92 + 1 }, { 9, 110 + 1 },\n};\n\nstatic int ad7746_set_capdac(struct ad7746_chip_info *chip, int channel)\n{\n\tint ret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t    AD7746_REG_CAPDACA,\n\t\t\t\t\t    chip->capdac[channel][0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t  AD7746_REG_CAPDACB,\n\t\t\t\t\t  chip->capdac[channel][1]);\n}\n\nstatic int ad7746_select_channel(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan)\n{\n\tstruct ad7746_chip_info *chip = iio_priv(indio_dev);\n\tu8 vt_setup, cap_setup;\n\tint ret, delay, idx;\n\n\tswitch (chan->type) {\n\tcase IIO_CAPACITANCE:\n\t\tcap_setup = FIELD_PREP(AD7746_CAPSETUP_CIN2,\n\t\t\t\t       ad7746_chan_info[chan->address].cin2) |\n\t\t\tFIELD_PREP(AD7746_CAPSETUP_CAPDIFF,\n\t\t\t\t   ad7746_chan_info[chan->address].capdiff) |\n\t\t\tFIELD_PREP(AD7746_CAPSETUP_CAPEN, 1);\n\t\tvt_setup = chip->vt_setup & ~AD7746_VTSETUP_VTEN;\n\t\tidx = FIELD_GET(AD7746_CONF_CAPFS_MASK, chip->config);\n\t\tdelay = ad7746_cap_filter_rate_table[idx][1];\n\n\t\tret = ad7746_set_capdac(chip, chan->channel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->capdac_set = chan->channel;\n\t\tbreak;\n\tcase IIO_VOLTAGE:\n\tcase IIO_TEMP:\n\t\tvt_setup = FIELD_PREP(AD7746_VTSETUP_VTMD_MASK,\n\t\t\t\t      ad7746_chan_info[chan->address].vtmd) |\n\t\t\tFIELD_PREP(AD7746_VTSETUP_VTEN, 1);\n\t\tcap_setup = chip->cap_setup & ~AD7746_CAPSETUP_CAPEN;\n\t\tidx = FIELD_GET(AD7746_CONF_VTFS_MASK, chip->config);\n\t\tdelay = ad7746_cap_filter_rate_table[idx][1];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->cap_setup != cap_setup) {\n\t\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t\tAD7746_REG_CAP_SETUP,\n\t\t\t\t\t\tcap_setup);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->cap_setup = cap_setup;\n\t}\n\n\tif (chip->vt_setup != vt_setup) {\n\t\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t\tAD7746_REG_VT_SETUP,\n\t\t\t\t\t\tvt_setup);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->vt_setup = vt_setup;\n\t}\n\n\treturn delay;\n}\n\nstatic inline ssize_t ad7746_start_calib(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf,\n\t\t\t\t\t size_t len,\n\t\t\t\t\t u8 regval)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7746_chip_info *chip = iio_priv(indio_dev);\n\tint ret, timeout = 10;\n\tbool doit;\n\n\tret = kstrtobool(buf, &doit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!doit)\n\t\treturn 0;\n\n\tmutex_lock(&chip->lock);\n\tregval |= chip->config;\n\tret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG, regval);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tdo {\n\t\tmsleep(20);\n\t\tret = i2c_smbus_read_byte_data(chip->client, AD7746_REG_CFG);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t} while ((ret == regval) && timeout--);\n\n\tmutex_unlock(&chip->lock);\n\n\treturn len;\n\nunlock:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic ssize_t ad7746_start_offset_calib(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tint ret = ad7746_select_channel(indio_dev,\n\t\t\t      &ad7746_channels[to_iio_dev_attr(attr)->address]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad7746_start_calib(dev, attr, buf, len,\n\t\t\t\t  FIELD_PREP(AD7746_CONF_MODE_MASK,\n\t\t\t\t\t     AD7746_CONF_MODE_OFFS_CAL));\n}\n\nstatic ssize_t ad7746_start_gain_calib(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf,\n\t\t\t\t       size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tint ret = ad7746_select_channel(indio_dev,\n\t\t\t      &ad7746_channels[to_iio_dev_attr(attr)->address]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad7746_start_calib(dev, attr, buf, len,\n\t\t\t\t  FIELD_PREP(AD7746_CONF_MODE_MASK,\n\t\t\t\t\t     AD7746_CONF_MODE_GAIN_CAL));\n}\n\nstatic IIO_DEVICE_ATTR(in_capacitance0_calibbias_calibration,\n\t\t       0200, NULL, ad7746_start_offset_calib, CIN1);\nstatic IIO_DEVICE_ATTR(in_capacitance1_calibbias_calibration,\n\t\t       0200, NULL, ad7746_start_offset_calib, CIN2);\nstatic IIO_DEVICE_ATTR(in_capacitance0_calibscale_calibration,\n\t\t       0200, NULL, ad7746_start_gain_calib, CIN1);\nstatic IIO_DEVICE_ATTR(in_capacitance1_calibscale_calibration,\n\t\t       0200, NULL, ad7746_start_gain_calib, CIN2);\nstatic IIO_DEVICE_ATTR(in_voltage0_calibscale_calibration,\n\t\t       0200, NULL, ad7746_start_gain_calib, VIN);\n\nstatic int ad7746_store_cap_filter_rate_setup(struct ad7746_chip_info *chip,\n\t\t\t\t\t      int val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad7746_cap_filter_rate_table); i++)\n\t\tif (val >= ad7746_cap_filter_rate_table[i][0])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(ad7746_cap_filter_rate_table))\n\t\ti = ARRAY_SIZE(ad7746_cap_filter_rate_table) - 1;\n\n\tchip->config &= ~AD7746_CONF_CAPFS_MASK;\n\tchip->config |= FIELD_PREP(AD7746_CONF_CAPFS_MASK, i);\n\n\treturn 0;\n}\n\nstatic int ad7746_store_vt_filter_rate_setup(struct ad7746_chip_info *chip,\n\t\t\t\t\t     int val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad7746_vt_filter_rate_table); i++)\n\t\tif (val >= ad7746_vt_filter_rate_table[i][0])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(ad7746_vt_filter_rate_table))\n\t\ti = ARRAY_SIZE(ad7746_vt_filter_rate_table) - 1;\n\n\tchip->config &= ~AD7746_CONF_VTFS_MASK;\n\tchip->config |= FIELD_PREP(AD7746_CONF_VTFS_MASK, i);\n\n\treturn 0;\n}\n\nstatic struct attribute *ad7746_attributes[] = {\n\t&iio_dev_attr_in_capacitance0_calibbias_calibration.dev_attr.attr,\n\t&iio_dev_attr_in_capacitance0_calibscale_calibration.dev_attr.attr,\n\t&iio_dev_attr_in_capacitance1_calibscale_calibration.dev_attr.attr,\n\t&iio_dev_attr_in_capacitance1_calibbias_calibration.dev_attr.attr,\n\t&iio_dev_attr_in_voltage0_calibscale_calibration.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7746_attribute_group = {\n\t.attrs = ad7746_attributes,\n};\n\nstatic int ad7746_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct ad7746_chip_info *chip = iio_priv(indio_dev);\n\tint ret, reg;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val != 1)\n\t\t\treturn -EINVAL;\n\n\t\tval = (val2 * 1024) / 15625;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_CAPACITANCE:\n\t\t\treg = AD7746_REG_CAP_GAINH;\n\t\t\tbreak;\n\t\tcase IIO_VOLTAGE:\n\t\t\treg = AD7746_REG_VOLT_GAINH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_lock(&chip->lock);\n\t\tret = i2c_smbus_write_word_swapped(chip->client, reg, val);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < 0 || val > 0xFFFF)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&chip->lock);\n\t\tret = i2c_smbus_write_word_swapped(chip->client,\n\t\t\t\t\t\t   AD7746_REG_CAP_OFFH, val);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_OFFSET:\n\tcase IIO_CHAN_INFO_ZEROPOINT:\n\t\tif (val < 0 || val > 43008000)  \n\t\t\treturn -EINVAL;\n\n\t\t \n\n\t\tval /= 338646;\n\t\tmutex_lock(&chip->lock);\n\t\tchip->capdac[chan->channel][chan->differential] = val > 0 ?\n\t\t\tFIELD_PREP(AD7746_CAPDAC_DACP_MASK, val) | AD7746_CAPDAC_DACEN : 0;\n\n\t\tret = ad7746_set_capdac(chip, chan->channel);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&chip->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tchip->capdac_set = chan->channel;\n\t\tmutex_unlock(&chip->lock);\n\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_CAPACITANCE:\n\t\t\tmutex_lock(&chip->lock);\n\t\t\tret = ad7746_store_cap_filter_rate_setup(chip, val);\n\t\t\tmutex_unlock(&chip->lock);\n\t\t\treturn ret;\n\t\tcase IIO_VOLTAGE:\n\t\t\tmutex_lock(&chip->lock);\n\t\t\tret = ad7746_store_vt_filter_rate_setup(chip, val);\n\t\t\tmutex_unlock(&chip->lock);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const int ad7746_v_samp_freq[] = { 50, 31, 16, 8, };\nstatic const int ad7746_cap_samp_freq[] = { 91, 84, 50, 26, 16, 13, 11, 9, };\n\nstatic int ad7746_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, const int **vals,\n\t\t\t     int *type, int *length, long mask)\n{\n\tif (mask != IIO_CHAN_INFO_SAMP_FREQ)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\t*vals = ad7746_v_samp_freq;\n\t\t*length = ARRAY_SIZE(ad7746_v_samp_freq);\n\t\tbreak;\n\tcase IIO_CAPACITANCE:\n\t\t*vals = ad7746_cap_samp_freq;\n\t\t*length = ARRAY_SIZE(ad7746_cap_samp_freq);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*type = IIO_VAL_INT;\n\treturn IIO_AVAIL_LIST;\n}\n\nstatic int ad7746_read_channel(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val)\n{\n\tstruct ad7746_chip_info *chip = iio_priv(indio_dev);\n\tint ret, delay;\n\tu8 data[3];\n\tu8 regval;\n\n\tret = ad7746_select_channel(indio_dev, chan);\n\tif (ret < 0)\n\t\treturn ret;\n\tdelay = ret;\n\n\tregval = chip->config | FIELD_PREP(AD7746_CONF_MODE_MASK,\n\t\t\t\t\t   AD7746_CONF_MODE_SINGLE_CONV);\n\tret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG, regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(delay);\n\t \n\tret = i2c_smbus_read_i2c_block_data(chip->client,\n\t\t\t\t\t    ad7746_chan_info[chan->address].addr,\n\t\t\t\t\t    sizeof(data), data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*val = get_unaligned_be24(data) - 0x800000;\n\n\treturn 0;\n}\n\nstatic int ad7746_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2,\n\t\t\t   long mask)\n{\n\tstruct ad7746_chip_info *chip = iio_priv(indio_dev);\n\tint ret, idx;\n\tu8 reg;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&chip->lock);\n\t\tret = ad7746_read_channel(indio_dev, chan, val);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CAPACITANCE:\n\t\t\treg = AD7746_REG_CAP_GAINH;\n\t\t\tbreak;\n\t\tcase IIO_VOLTAGE:\n\t\t\treg = AD7746_REG_VOLT_GAINH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_lock(&chip->lock);\n\t\tret = i2c_smbus_read_word_swapped(chip->client, reg);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = 1;\n\t\t*val2 = (15625 * ret) / 1024;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tmutex_lock(&chip->lock);\n\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t  AD7746_REG_CAP_OFFH);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\tcase IIO_CHAN_INFO_ZEROPOINT:\n\t\t*val = FIELD_GET(AD7746_CAPDAC_DACP_MASK,\n\t\t\t\t chip->capdac[chan->channel][chan->differential]) * 338646;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CAPACITANCE:\n\t\t\t \n\t\t\t*val =  0;\n\t\t\t*val2 = 488;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_VOLTAGE:\n\t\t\t \n\t\t\t*val = 1170;\n\t\t\tif (chan->channel == 1)\n\t\t\t\t*val *= 6;\n\t\t\t*val2 = 23;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 125;\n\t\t\t*val2 = 8;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CAPACITANCE:\n\t\t\tidx = FIELD_GET(AD7746_CONF_CAPFS_MASK, chip->config);\n\t\t\t*val = ad7746_cap_filter_rate_table[idx][0];\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_VOLTAGE:\n\t\t\tidx = FIELD_GET(AD7746_CONF_VTFS_MASK, chip->config);\n\t\t\t*val = ad7746_vt_filter_rate_table[idx][0];\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ad7746_info = {\n\t.attrs = &ad7746_attribute_group,\n\t.read_raw = ad7746_read_raw,\n\t.read_avail = ad7746_read_avail,\n\t.write_raw = ad7746_write_raw,\n};\n\nstatic int ad7746_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct ad7746_chip_info *chip;\n\tstruct iio_dev *indio_dev;\n\tunsigned char regval = 0;\n\tunsigned int vdd_permille;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tmutex_init(&chip->lock);\n\n\tchip->client = client;\n\tchip->capdac_set = -1;\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ad7746_info;\n\tindio_dev->channels = ad7746_channels;\n\tif (id->driver_data == 7746)\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad7746_channels);\n\telse\n\t\tindio_dev->num_channels =  ARRAY_SIZE(ad7746_channels) - 2;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (device_property_read_bool(dev, \"adi,exca-output-en\")) {\n\t\tif (device_property_read_bool(dev, \"adi,exca-output-invert\"))\n\t\t\tregval |= AD7746_EXCSETUP_NEXCA;\n\t\telse\n\t\t\tregval |= AD7746_EXCSETUP_EXCA;\n\t}\n\n\tif (device_property_read_bool(dev, \"adi,excb-output-en\")) {\n\t\tif (device_property_read_bool(dev, \"adi,excb-output-invert\"))\n\t\t\tregval |= AD7746_EXCSETUP_NEXCB;\n\t\telse\n\t\t\tregval |= AD7746_EXCSETUP_EXCB;\n\t}\n\n\tret = device_property_read_u32(dev, \"adi,excitation-vdd-permille\",\n\t\t\t\t       &vdd_permille);\n\tif (!ret) {\n\t\tswitch (vdd_permille) {\n\t\tcase 125:\n\t\t\tregval |= FIELD_PREP(AD7746_EXCSETUP_EXCLVL_MASK, 0);\n\t\t\tbreak;\n\t\tcase 250:\n\t\t\tregval |= FIELD_PREP(AD7746_EXCSETUP_EXCLVL_MASK, 1);\n\t\t\tbreak;\n\t\tcase 375:\n\t\t\tregval |= FIELD_PREP(AD7746_EXCSETUP_EXCLVL_MASK, 2);\n\t\t\tbreak;\n\t\tcase 500:\n\t\t\tregval |= FIELD_PREP(AD7746_EXCSETUP_EXCLVL_MASK, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_EXC_SETUP,\n\t\t\t\t\tregval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(indio_dev->dev.parent, indio_dev);\n}\n\nstatic const struct i2c_device_id ad7746_id[] = {\n\t{ \"ad7745\", 7745 },\n\t{ \"ad7746\", 7746 },\n\t{ \"ad7747\", 7747 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ad7746_id);\n\nstatic const struct of_device_id ad7746_of_match[] = {\n\t{ .compatible = \"adi,ad7745\" },\n\t{ .compatible = \"adi,ad7746\" },\n\t{ .compatible = \"adi,ad7747\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7746_of_match);\n\nstatic struct i2c_driver ad7746_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ad7746_of_match,\n\t},\n\t.probe = ad7746_probe,\n\t.id_table = ad7746_id,\n};\nmodule_i2c_driver(ad7746_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7746/5/7 capacitive sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}