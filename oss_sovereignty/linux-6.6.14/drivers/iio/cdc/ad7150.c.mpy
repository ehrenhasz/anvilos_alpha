{
  "module_name": "ad7150.c",
  "hash_id": "6f100f3f1899d46208a5e48e1c3513ef0d6903969071a6d8972ac94e93c7de2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/cdc/ad7150.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n#define AD7150_STATUS_REG\t\t0\n#define   AD7150_STATUS_OUT1\t\tBIT(3)\n#define   AD7150_STATUS_OUT2\t\tBIT(5)\n#define AD7150_CH1_DATA_HIGH_REG\t1\n#define AD7150_CH2_DATA_HIGH_REG\t3\n#define AD7150_CH1_AVG_HIGH_REG\t\t5\n#define AD7150_CH2_AVG_HIGH_REG\t\t7\n#define AD7150_CH1_SENSITIVITY_REG\t9\n#define AD7150_CH1_THR_HOLD_H_REG\t9\n#define AD7150_CH1_TIMEOUT_REG\t\t10\n#define   AD7150_CH_TIMEOUT_RECEDING\tGENMASK(3, 0)\n#define   AD7150_CH_TIMEOUT_APPROACHING\tGENMASK(7, 4)\n#define AD7150_CH1_SETUP_REG\t\t11\n#define AD7150_CH2_SENSITIVITY_REG\t12\n#define AD7150_CH2_THR_HOLD_H_REG\t12\n#define AD7150_CH2_TIMEOUT_REG\t\t13\n#define AD7150_CH2_SETUP_REG\t\t14\n#define AD7150_CFG_REG\t\t\t15\n#define   AD7150_CFG_FIX\t\tBIT(7)\n#define   AD7150_CFG_THRESHTYPE_MSK\tGENMASK(6, 5)\n#define   AD7150_CFG_TT_NEG\t\t0x0\n#define   AD7150_CFG_TT_POS\t\t0x1\n#define   AD7150_CFG_TT_IN_WINDOW\t0x2\n#define   AD7150_CFG_TT_OUT_WINDOW\t0x3\n#define AD7150_PD_TIMER_REG\t\t16\n#define AD7150_CH1_CAPDAC_REG\t\t17\n#define AD7150_CH2_CAPDAC_REG\t\t18\n#define AD7150_SN3_REG\t\t\t19\n#define AD7150_SN2_REG\t\t\t20\n#define AD7150_SN1_REG\t\t\t21\n#define AD7150_SN0_REG\t\t\t22\n#define AD7150_ID_REG\t\t\t23\n\nenum {\n\tAD7150,\n\tAD7151,\n};\n\n \nstruct ad7150_chip_info {\n\tstruct i2c_client *client;\n\tu16 threshold[2][2];\n\tu8 thresh_sensitivity[2][2];\n\tu8 thresh_timeout[2][2];\n\tstruct mutex state_lock;\n\tint interrupts[2];\n\tbool int_enabled[2];\n\tenum iio_event_type type;\n\tenum iio_event_direction dir;\n};\n\nstatic const u8 ad7150_addresses[][6] = {\n\t{ AD7150_CH1_DATA_HIGH_REG, AD7150_CH1_AVG_HIGH_REG,\n\t  AD7150_CH1_SETUP_REG, AD7150_CH1_THR_HOLD_H_REG,\n\t  AD7150_CH1_SENSITIVITY_REG, AD7150_CH1_TIMEOUT_REG },\n\t{ AD7150_CH2_DATA_HIGH_REG, AD7150_CH2_AVG_HIGH_REG,\n\t  AD7150_CH2_SETUP_REG, AD7150_CH2_THR_HOLD_H_REG,\n\t  AD7150_CH2_SENSITIVITY_REG, AD7150_CH2_TIMEOUT_REG },\n};\n\nstatic int ad7150_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long mask)\n{\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tint channel = chan->channel;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t  ad7150_addresses[channel][0]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret >> 4;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_AVERAGE_RAW:\n\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t  ad7150_addresses[channel][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 1000;\n\t\t*val2 = 40944 >> 4;  \n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -(12288 >> 4);  \n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t \n\t\t*val = 100;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7150_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tu8 threshtype;\n\tbool thrfixed;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tthreshtype = FIELD_GET(AD7150_CFG_THRESHTYPE_MSK, ret);\n\n\t \n\tthrfixed = FIELD_GET(AD7150_CFG_FIX, ret);\n\n\tswitch (type) {\n\tcase IIO_EV_TYPE_THRESH_ADAPTIVE:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treturn !thrfixed && (threshtype == AD7150_CFG_TT_POS);\n\t\treturn !thrfixed && (threshtype == AD7150_CFG_TT_NEG);\n\tcase IIO_EV_TYPE_THRESH:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treturn thrfixed && (threshtype == AD7150_CFG_TT_POS);\n\t\treturn thrfixed && (threshtype == AD7150_CFG_TT_NEG);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int ad7150_write_event_params(struct iio_dev *indio_dev,\n\t\t\t\t     unsigned int chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tint rising = (dir == IIO_EV_DIR_RISING);\n\n\t \n\tif ((type != chip->type) || (dir != chip->dir))\n\t\treturn 0;\n\n\tswitch (type) {\n\t\t \n\tcase IIO_EV_TYPE_THRESH: {\n\t\tu16 value = chip->threshold[rising][chan];\n\t\treturn i2c_smbus_write_word_swapped(chip->client,\n\t\t\t\t\t\t    ad7150_addresses[chan][3],\n\t\t\t\t\t\t    value);\n\t}\n\tcase IIO_EV_TYPE_THRESH_ADAPTIVE: {\n\t\tint ret;\n\t\tu8 sens, timeout;\n\n\t\tsens = chip->thresh_sensitivity[rising][chan];\n\t\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t\tad7150_addresses[chan][4],\n\t\t\t\t\t\tsens);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\ttimeout = FIELD_PREP(AD7150_CH_TIMEOUT_APPROACHING,\n\t\t\t\t     chip->thresh_timeout[1][chan]);\n\t\ttimeout |= FIELD_PREP(AD7150_CH_TIMEOUT_RECEDING,\n\t\t\t\t      chip->thresh_timeout[0][chan]);\n\t\treturn i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\t\t ad7150_addresses[chan][5],\n\t\t\t\t\t\t timeout);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7150_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir, int state)\n{\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tint ret = 0;\n\n\t \n\tif (!state) {\n\t\tif ((chip->int_enabled[chan->channel]) &&\n\t\t    (type == chip->type) && (dir == chip->dir)) {\n\t\t\tdisable_irq(chip->interrupts[chan->channel]);\n\t\t\tchip->int_enabled[chan->channel] = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&chip->state_lock);\n\tif ((type != chip->type) || (dir != chip->dir)) {\n\t\tint rising = (dir == IIO_EV_DIR_RISING);\n\t\tu8 thresh_type, cfg, fixed;\n\n\t\t \n\t\tdisable_irq(chip->interrupts[0]);\n\t\tdisable_irq(chip->interrupts[1]);\n\n\t\tret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG_REG);\n\t\tif (ret < 0)\n\t\t\tgoto error_ret;\n\n\t\tcfg = ret & ~(AD7150_CFG_THRESHTYPE_MSK | AD7150_CFG_FIX);\n\n\t\tif (type == IIO_EV_TYPE_THRESH_ADAPTIVE)\n\t\t\tfixed = 0;\n\t\telse\n\t\t\tfixed = 1;\n\n\t\tif (rising)\n\t\t\tthresh_type = AD7150_CFG_TT_POS;\n\t\telse\n\t\t\tthresh_type = AD7150_CFG_TT_NEG;\n\n\t\tcfg |= FIELD_PREP(AD7150_CFG_FIX, fixed) |\n\t\t\tFIELD_PREP(AD7150_CFG_THRESHTYPE_MSK, thresh_type);\n\n\t\tret = i2c_smbus_write_byte_data(chip->client, AD7150_CFG_REG,\n\t\t\t\t\t\tcfg);\n\t\tif (ret < 0)\n\t\t\tgoto error_ret;\n\n\t\t \n\t\tchip->type = type;\n\t\tchip->dir = dir;\n\n\t\t \n\t\tret = ad7150_write_event_params(indio_dev, chan->channel, type,\n\t\t\t\t\t\tdir);\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t\t \n\t\tenable_irq(chip->interrupts[0]);\n\t\tenable_irq(chip->interrupts[1]);\n\t}\n\tif (!chip->int_enabled[chan->channel]) {\n\t\tenable_irq(chip->interrupts[chan->channel]);\n\t\tchip->int_enabled[chan->channel] = true;\n\t}\n\nerror_ret:\n\tmutex_unlock(&chip->state_lock);\n\n\treturn ret;\n}\n\nstatic int ad7150_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t   enum iio_event_info info,\n\t\t\t\t   int *val, int *val2)\n{\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tint rising = (dir == IIO_EV_DIR_RISING);\n\n\t \n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (type) {\n\t\tcase IIO_EV_TYPE_THRESH_ADAPTIVE:\n\t\t\t*val = chip->thresh_sensitivity[rising][chan->channel];\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_TYPE_THRESH:\n\t\t\t*val = chip->threshold[rising][chan->channel];\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_TIMEOUT:\n\t\t*val = 0;\n\t\t*val2 = chip->thresh_timeout[rising][chan->channel] * 10000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7150_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int val, int val2)\n{\n\tint ret;\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\tint rising = (dir == IIO_EV_DIR_RISING);\n\n\tmutex_lock(&chip->state_lock);\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (type) {\n\t\tcase IIO_EV_TYPE_THRESH_ADAPTIVE:\n\t\t\tchip->thresh_sensitivity[rising][chan->channel] = val;\n\t\t\tbreak;\n\t\tcase IIO_EV_TYPE_THRESH:\n\t\t\tchip->threshold[rising][chan->channel] = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_ret;\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_TIMEOUT: {\n\t\t \n\t\tint timeout = val2 / 10000;\n\n\t\tif (val != 0 || timeout < 0 || timeout > 15 || val2 % 10000) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_ret;\n\t\t}\n\n\t\tchip->thresh_timeout[rising][chan->channel] = timeout;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error_ret;\n\t}\n\n\t \n\tret = ad7150_write_event_params(indio_dev, chan->channel, type, dir);\n\nerror_ret:\n\tmutex_unlock(&chip->state_lock);\n\treturn ret;\n}\n\nstatic const struct iio_event_spec ad7150_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH_ADAPTIVE,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE) |\n\t\t\tBIT(IIO_EV_INFO_TIMEOUT),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH_ADAPTIVE,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE) |\n\t\t\tBIT(IIO_EV_INFO_TIMEOUT),\n\t},\n};\n\n#define AD7150_CAPACITANCE_CHAN(_chan)\t{\t\t\t\\\n\t\t.type = IIO_CAPACITANCE,\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = _chan,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW),\t\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\\\n\t\t.event_spec = ad7150_events,\t\t\t\\\n\t\t.num_event_specs = ARRAY_SIZE(ad7150_events),\t\\\n\t}\n\n#define AD7150_CAPACITANCE_CHAN_NO_IRQ(_chan)\t{\t\t\\\n\t\t.type = IIO_CAPACITANCE,\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = _chan,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW),\t\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\\\n\t}\n\nstatic const struct iio_chan_spec ad7150_channels[] = {\n\tAD7150_CAPACITANCE_CHAN(0),\n\tAD7150_CAPACITANCE_CHAN(1),\n};\n\nstatic const struct iio_chan_spec ad7150_channels_no_irq[] = {\n\tAD7150_CAPACITANCE_CHAN_NO_IRQ(0),\n\tAD7150_CAPACITANCE_CHAN_NO_IRQ(1),\n};\n\nstatic const struct iio_chan_spec ad7151_channels[] = {\n\tAD7150_CAPACITANCE_CHAN(0),\n};\n\nstatic const struct iio_chan_spec ad7151_channels_no_irq[] = {\n\tAD7150_CAPACITANCE_CHAN_NO_IRQ(0),\n};\n\nstatic irqreturn_t __ad7150_event_handler(void *private, u8 status_mask,\n\t\t\t\t\t  int channel)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ad7150_chip_info *chip = iio_priv(indio_dev);\n\ts64 timestamp = iio_get_time_ns(indio_dev);\n\tint int_status;\n\n\tint_status = i2c_smbus_read_byte_data(chip->client, AD7150_STATUS_REG);\n\tif (int_status < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (!(int_status & status_mask))\n\t\treturn IRQ_HANDLED;\n\n\tiio_push_event(indio_dev,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_CAPACITANCE, channel,\n\t\t\t\t\t    chip->type, chip->dir),\n\t\t       timestamp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ad7150_event_handler_ch1(int irq, void *private)\n{\n\treturn __ad7150_event_handler(private, AD7150_STATUS_OUT1, 0);\n}\n\nstatic irqreturn_t ad7150_event_handler_ch2(int irq, void *private)\n{\n\treturn __ad7150_event_handler(private, AD7150_STATUS_OUT2, 1);\n}\n\nstatic IIO_CONST_ATTR(in_capacitance_thresh_adaptive_timeout_available,\n\t\t      \"[0 0.01 0.15]\");\n\nstatic struct attribute *ad7150_event_attributes[] = {\n\t&iio_const_attr_in_capacitance_thresh_adaptive_timeout_available\n\t.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7150_event_attribute_group = {\n\t.attrs = ad7150_event_attributes,\n\t.name = \"events\",\n};\n\nstatic const struct iio_info ad7150_info = {\n\t.event_attrs = &ad7150_event_attribute_group,\n\t.read_raw = &ad7150_read_raw,\n\t.read_event_config = &ad7150_read_event_config,\n\t.write_event_config = &ad7150_write_event_config,\n\t.read_event_value = &ad7150_read_event_value,\n\t.write_event_value = &ad7150_write_event_value,\n};\n\nstatic const struct iio_info ad7150_info_no_irq = {\n\t.read_raw = &ad7150_read_raw,\n};\n\nstatic int ad7150_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ad7150_chip_info *chip;\n\tstruct iio_dev *indio_dev;\n\tbool use_irq = true;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tmutex_init(&chip->state_lock);\n\tchip->client = client;\n\n\tindio_dev->name = id->name;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_regulator_get_enable(&client->dev, \"vdd\");\n\tif (ret)\n\t\treturn ret;\n\n\tchip->interrupts[0] = fwnode_irq_get(dev_fwnode(&client->dev), 0);\n\tif (chip->interrupts[0] < 0)\n\t\tuse_irq = false;\n\telse if (id->driver_data == AD7150) {\n\t\tchip->interrupts[1] = fwnode_irq_get(dev_fwnode(&client->dev), 1);\n\t\tif (chip->interrupts[1] < 0)\n\t\t\tuse_irq = false;\n\t}\n\tif (use_irq) {\n\t\tirq_set_status_flags(chip->interrupts[0], IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\tchip->interrupts[0],\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&ad7150_event_handler_ch1,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"ad7150_irq1\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tindio_dev->info = &ad7150_info;\n\t\tswitch (id->driver_data) {\n\t\tcase AD7150:\n\t\t\tindio_dev->channels = ad7150_channels;\n\t\t\tindio_dev->num_channels = ARRAY_SIZE(ad7150_channels);\n\t\t\tirq_set_status_flags(chip->interrupts[1], IRQ_NOAUTOEN);\n\t\t\tret = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\t\tchip->interrupts[1],\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&ad7150_event_handler_ch2,\n\t\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"ad7150_irq2\",\n\t\t\t\t\t\t\tindio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase AD7151:\n\t\t\tindio_dev->channels = ad7151_channels;\n\t\t\tindio_dev->num_channels = ARRAY_SIZE(ad7151_channels);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else {\n\t\tindio_dev->info = &ad7150_info_no_irq;\n\t\tswitch (id->driver_data) {\n\t\tcase AD7150:\n\t\t\tindio_dev->channels = ad7150_channels_no_irq;\n\t\t\tindio_dev->num_channels =\n\t\t\t\tARRAY_SIZE(ad7150_channels_no_irq);\n\t\t\tbreak;\n\t\tcase AD7151:\n\t\t\tindio_dev->channels = ad7151_channels_no_irq;\n\t\t\tindio_dev->num_channels =\n\t\t\t\tARRAY_SIZE(ad7151_channels_no_irq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn devm_iio_device_register(indio_dev->dev.parent, indio_dev);\n}\n\nstatic const struct i2c_device_id ad7150_id[] = {\n\t{ \"ad7150\", AD7150 },\n\t{ \"ad7151\", AD7151 },\n\t{ \"ad7156\", AD7150 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, ad7150_id);\n\nstatic const struct of_device_id ad7150_of_match[] = {\n\t{ \"adi,ad7150\" },\n\t{ \"adi,ad7151\" },\n\t{ \"adi,ad7156\" },\n\t{}\n};\nstatic struct i2c_driver ad7150_driver = {\n\t.driver = {\n\t\t.name = \"ad7150\",\n\t\t.of_match_table = ad7150_of_match,\n\t},\n\t.probe = ad7150_probe,\n\t.id_table = ad7150_id,\n};\nmodule_i2c_driver(ad7150_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7150/1/6 capacitive sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}