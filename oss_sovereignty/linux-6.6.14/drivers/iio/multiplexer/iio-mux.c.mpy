{
  "module_name": "iio-mux.c",
  "hash_id": "eb07e2a9daa0c3ca562fc14092d170bd80bc7420d7ed603dea975b346299a6a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/multiplexer/iio-mux.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mux/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\nstruct mux_ext_info_cache {\n\tchar *data;\n\tssize_t size;\n};\n\nstruct mux_child {\n\tstruct mux_ext_info_cache *ext_info_cache;\n};\n\nstruct mux {\n\tint cached_state;\n\tstruct mux_control *control;\n\tstruct iio_channel *parent;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_chan_spec *chan;\n\tstruct iio_chan_spec_ext_info *ext_info;\n\tstruct mux_child *child;\n\tu32 delay_us;\n};\n\nstatic int iio_mux_select(struct mux *mux, int idx)\n{\n\tstruct mux_child *child = &mux->child[idx];\n\tstruct iio_chan_spec const *chan = &mux->chan[idx];\n\tint ret;\n\tint i;\n\n\tret = mux_control_select_delay(mux->control, chan->channel,\n\t\t\t\t       mux->delay_us);\n\tif (ret < 0) {\n\t\tmux->cached_state = -1;\n\t\treturn ret;\n\t}\n\n\tif (mux->cached_state == chan->channel)\n\t\treturn 0;\n\n\tif (chan->ext_info) {\n\t\tfor (i = 0; chan->ext_info[i].name; ++i) {\n\t\t\tconst char *attr = chan->ext_info[i].name;\n\t\t\tstruct mux_ext_info_cache *cache;\n\n\t\t\tcache = &child->ext_info_cache[i];\n\n\t\t\tif (cache->size < 0)\n\t\t\t\tcontinue;\n\n\t\t\tret = iio_write_channel_ext_info(mux->parent, attr,\n\t\t\t\t\t\t\t cache->data,\n\t\t\t\t\t\t\t cache->size);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tmux_control_deselect(mux->control);\n\t\t\t\tmux->cached_state = -1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tmux->cached_state = chan->channel;\n\n\treturn 0;\n}\n\nstatic void iio_mux_deselect(struct mux *mux)\n{\n\tmux_control_deselect(mux->control);\n}\n\nstatic int mux_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct mux *mux = iio_priv(indio_dev);\n\tint idx = chan - mux->chan;\n\tint ret;\n\n\tret = iio_mux_select(mux, idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_read_channel_raw(mux->parent, val);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = iio_read_channel_scale(mux->parent, val, val2);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_mux_deselect(mux);\n\n\treturn ret;\n}\n\nstatic int mux_read_avail(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  const int **vals, int *type, int *length,\n\t\t\t  long mask)\n{\n\tstruct mux *mux = iio_priv(indio_dev);\n\tint idx = chan - mux->chan;\n\tint ret;\n\n\tret = iio_mux_select(mux, idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*type = IIO_VAL_INT;\n\t\tret = iio_read_avail_channel_raw(mux->parent, vals, length);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_mux_deselect(mux);\n\n\treturn ret;\n}\n\nstatic int mux_write_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan,\n\t\t\t int val, int val2, long mask)\n{\n\tstruct mux *mux = iio_priv(indio_dev);\n\tint idx = chan - mux->chan;\n\tint ret;\n\n\tret = iio_mux_select(mux, idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_write_channel_raw(mux->parent, val);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_mux_deselect(mux);\n\n\treturn ret;\n}\n\nstatic const struct iio_info mux_info = {\n\t.read_raw = mux_read_raw,\n\t.read_avail = mux_read_avail,\n\t.write_raw = mux_write_raw,\n};\n\nstatic ssize_t mux_read_ext_info(struct iio_dev *indio_dev, uintptr_t private,\n\t\t\t\t struct iio_chan_spec const *chan, char *buf)\n{\n\tstruct mux *mux = iio_priv(indio_dev);\n\tint idx = chan - mux->chan;\n\tssize_t ret;\n\n\tret = iio_mux_select(mux, idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_read_channel_ext_info(mux->parent,\n\t\t\t\t\tmux->ext_info[private].name,\n\t\t\t\t\tbuf);\n\n\tiio_mux_deselect(mux);\n\n\treturn ret;\n}\n\nstatic ssize_t mux_write_ext_info(struct iio_dev *indio_dev, uintptr_t private,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct mux *mux = iio_priv(indio_dev);\n\tint idx = chan - mux->chan;\n\tchar *new;\n\tssize_t ret;\n\n\tif (len >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = iio_mux_select(mux, idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = devm_kmemdup(dev, buf, len + 1, GFP_KERNEL);\n\tif (!new) {\n\t\tiio_mux_deselect(mux);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew[len] = 0;\n\n\tret = iio_write_channel_ext_info(mux->parent,\n\t\t\t\t\t mux->ext_info[private].name,\n\t\t\t\t\t buf, len);\n\tif (ret < 0) {\n\t\tiio_mux_deselect(mux);\n\t\tdevm_kfree(dev, new);\n\t\treturn ret;\n\t}\n\n\tdevm_kfree(dev, mux->child[idx].ext_info_cache[private].data);\n\tmux->child[idx].ext_info_cache[private].data = new;\n\tmux->child[idx].ext_info_cache[private].size = len;\n\n\tiio_mux_deselect(mux);\n\n\treturn ret;\n}\n\nstatic int mux_configure_channel(struct device *dev, struct mux *mux,\n\t\t\t\t u32 state, const char *label, int idx)\n{\n\tstruct mux_child *child = &mux->child[idx];\n\tstruct iio_chan_spec *chan = &mux->chan[idx];\n\tstruct iio_chan_spec const *pchan = mux->parent->channel;\n\tchar *page = NULL;\n\tint num_ext_info;\n\tint i;\n\tint ret;\n\n\tchan->indexed = 1;\n\tchan->output = pchan->output;\n\tchan->datasheet_name = label;\n\tchan->ext_info = mux->ext_info;\n\n\tret = iio_get_channel_type(mux->parent, &chan->type);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get parent channel type\\n\");\n\t\treturn ret;\n\t}\n\n\tif (iio_channel_has_info(pchan, IIO_CHAN_INFO_RAW))\n\t\tchan->info_mask_separate |= BIT(IIO_CHAN_INFO_RAW);\n\tif (iio_channel_has_info(pchan, IIO_CHAN_INFO_SCALE))\n\t\tchan->info_mask_separate |= BIT(IIO_CHAN_INFO_SCALE);\n\n\tif (iio_channel_has_available(pchan, IIO_CHAN_INFO_RAW))\n\t\tchan->info_mask_separate_available |= BIT(IIO_CHAN_INFO_RAW);\n\n\tif (state >= mux_control_states(mux->control)) {\n\t\tdev_err(dev, \"too many channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan->channel = state;\n\n\tnum_ext_info = iio_get_channel_ext_info_count(mux->parent);\n\tif (num_ext_info) {\n\t\tpage = devm_kzalloc(dev, PAGE_SIZE, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t}\n\tchild->ext_info_cache = devm_kcalloc(dev,\n\t\t\t\t\t     num_ext_info,\n\t\t\t\t\t     sizeof(*child->ext_info_cache),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!child->ext_info_cache)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_ext_info; ++i) {\n\t\tchild->ext_info_cache[i].size = -1;\n\n\t\tif (!pchan->ext_info[i].write)\n\t\t\tcontinue;\n\t\tif (!pchan->ext_info[i].read)\n\t\t\tcontinue;\n\n\t\tret = iio_read_channel_ext_info(mux->parent,\n\t\t\t\t\t\tmux->ext_info[i].name,\n\t\t\t\t\t\tpage);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to get ext_info '%s'\\n\",\n\t\t\t\tpchan->ext_info[i].name);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret >= PAGE_SIZE) {\n\t\t\tdev_err(dev, \"too large ext_info '%s'\\n\",\n\t\t\t\tpchan->ext_info[i].name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchild->ext_info_cache[i].data = devm_kmemdup(dev, page, ret + 1,\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!child->ext_info_cache[i].data)\n\t\t\treturn -ENOMEM;\n\n\t\tchild->ext_info_cache[i].data[ret] = 0;\n\t\tchild->ext_info_cache[i].size = ret;\n\t}\n\n\tif (page)\n\t\tdevm_kfree(dev, page);\n\n\treturn 0;\n}\n\nstatic int mux_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_channel *parent;\n\tstruct mux *mux;\n\tconst char **labels;\n\tint all_children;\n\tint children;\n\tu32 state;\n\tint sizeof_ext_info;\n\tint sizeof_priv;\n\tint i;\n\tint ret;\n\n\tparent = devm_iio_channel_get(dev, \"parent\");\n\tif (IS_ERR(parent))\n\t\treturn dev_err_probe(dev, PTR_ERR(parent),\n\t\t\t\t     \"failed to get parent channel\\n\");\n\n\tsizeof_ext_info = iio_get_channel_ext_info_count(parent);\n\tif (sizeof_ext_info) {\n\t\tsizeof_ext_info += 1;  \n\t\tsizeof_ext_info *= sizeof(*mux->ext_info);\n\t}\n\n\tall_children = device_property_string_array_count(dev, \"channels\");\n\tif (all_children < 0)\n\t\treturn all_children;\n\n\tlabels = devm_kmalloc_array(dev, all_children, sizeof(*labels), GFP_KERNEL);\n\tif (!labels)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_string_array(dev, \"channels\", labels, all_children);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchildren = 0;\n\tfor (state = 0; state < all_children; state++) {\n\t\tif (*labels[state])\n\t\t\tchildren++;\n\t}\n\tif (children <= 0) {\n\t\tdev_err(dev, \"not even a single child\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsizeof_priv = sizeof(*mux);\n\tsizeof_priv += sizeof(*mux->child) * children;\n\tsizeof_priv += sizeof(*mux->chan) * children;\n\tsizeof_priv += sizeof_ext_info;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof_priv);\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tmux = iio_priv(indio_dev);\n\tmux->child = (struct mux_child *)(mux + 1);\n\tmux->chan = (struct iio_chan_spec *)(mux->child + children);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tmux->parent = parent;\n\tmux->cached_state = -1;\n\n\tmux->delay_us = 0;\n\tdevice_property_read_u32(dev, \"settle-time-us\", &mux->delay_us);\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &mux_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mux->chan;\n\tindio_dev->num_channels = children;\n\tif (sizeof_ext_info) {\n\t\tmux->ext_info = devm_kmemdup(dev,\n\t\t\t\t\t     parent->channel->ext_info,\n\t\t\t\t\t     sizeof_ext_info, GFP_KERNEL);\n\t\tif (!mux->ext_info)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; mux->ext_info[i].name; ++i) {\n\t\t\tif (parent->channel->ext_info[i].read)\n\t\t\t\tmux->ext_info[i].read = mux_read_ext_info;\n\t\t\tif (parent->channel->ext_info[i].write)\n\t\t\t\tmux->ext_info[i].write = mux_write_ext_info;\n\t\t\tmux->ext_info[i].private = i;\n\t\t}\n\t}\n\n\tmux->control = devm_mux_control_get(dev, NULL);\n\tif (IS_ERR(mux->control))\n\t\treturn dev_err_probe(dev, PTR_ERR(mux->control),\n\t\t\t\t     \"failed to get control-mux\\n\");\n\n\ti = 0;\n\tfor (state = 0; state < all_children; state++) {\n\t\tif (!*labels[state])\n\t\t\tcontinue;\n\n\t\tret = mux_configure_channel(dev, mux, state, labels[state], i++);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register iio device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mux_match[] = {\n\t{ .compatible = \"io-channel-mux\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mux_match);\n\nstatic struct platform_driver mux_driver = {\n\t.probe = mux_probe,\n\t.driver = {\n\t\t.name = \"iio-mux\",\n\t\t.of_match_table = mux_match,\n\t},\n};\nmodule_platform_driver(mux_driver);\n\nMODULE_DESCRIPTION(\"IIO multiplexer driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}