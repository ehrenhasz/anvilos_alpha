{
  "module_name": "ada4250.c",
  "hash_id": "cb6553df5ea4c061d93393a3c2c384f14d9c0ca098ee378dcef9704280d98a2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/amplifiers/ada4250.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADA4250_REG_GAIN_MUX        0x00\n#define ADA4250_REG_REFBUF_EN       0x01\n#define ADA4250_REG_RESET           0x02\n#define ADA4250_REG_SNSR_CAL_VAL    0x04\n#define ADA4250_REG_SNSR_CAL_CNFG   0x05\n#define ADA4250_REG_DIE_REV         0x18\n#define ADA4250_REG_CHIP_ID         0x19\n\n \n#define ADA4250_GAIN_MUX_MSK        GENMASK(2, 0)\n\n \n#define ADA4250_REFBUF_MSK          BIT(0)\n\n \n#define ADA4250_RESET_MSK           BIT(0)\n\n \n#define ADA4250_CAL_CFG_BIAS_MSK    GENMASK(7, 0)\n\n \n#define ADA4250_BIAS_SET_MSK        GENMASK(3, 2)\n#define ADA4250_RANGE_SET_MSK       GENMASK(1, 0)\n\n \n#define ADA4250_CHIP_ID             0x4250\n#define ADA4250_RANGE1              0\n#define\tADA4250_RANGE4              3\n\n \nenum ada4250_current_bias {\n\tADA4250_BIAS_DISABLED,\n\tADA4250_BIAS_BANDGAP,\n\tADA4250_BIAS_AVDD,\n};\n\nstruct ada4250_state {\n\tstruct spi_device\t*spi;\n\tstruct regmap\t\t*regmap;\n\tstruct regulator\t*reg;\n\t \n\tstruct mutex\t\tlock;\n\tu8\t\t\tbias;\n\tu8\t\t\tgain;\n\tint\t\t\toffset_uv;\n\tbool\t\t\trefbuf_en;\n};\n\n \nstatic const int calibbias_table[] = {0, 1, 2};\n\n \nstatic const int hwgain_table[] = {1, 2, 4, 8, 16, 32, 64, 128};\n\nstatic const struct regmap_config ada4250_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.read_flag_mask = BIT(7),\n\t.max_register = 0x1A,\n};\n\nstatic int ada4250_set_offset_uv(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t int offset_uv)\n{\n\tstruct ada4250_state *st = iio_priv(indio_dev);\n\n\tint i, ret, x[8], max_vos, min_vos, voltage_v, vlsb = 0;\n\tu8 offset_raw, range = ADA4250_RANGE1;\n\tu32 lsb_coeff[6] = {1333, 2301, 4283, 8289, 16311, 31599};\n\n\tif (st->bias == 0 || st->bias == 3)\n\t\treturn -EINVAL;\n\n\tvoltage_v = regulator_get_voltage(st->reg);\n\tvoltage_v = DIV_ROUND_CLOSEST(voltage_v, 1000000);\n\n\tif (st->bias == ADA4250_BIAS_AVDD)\n\t\tx[0] = voltage_v;\n\telse\n\t\tx[0] = 5;\n\n\tx[1] = 126 * (x[0] - 1);\n\n\tfor (i = 0; i < 6; i++)\n\t\tx[i + 2] = DIV_ROUND_CLOSEST(x[1] * 1000, lsb_coeff[i]);\n\n\tif (st->gain == 0)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = ADA4250_RANGE1; i <= ADA4250_RANGE4; i++) {\n\t\tmax_vos = x[st->gain] *  127 * ((1 << (i + 1)) - 1);\n\t\tmin_vos = -1 * max_vos;\n\t\tif (offset_uv > min_vos && offset_uv < max_vos) {\n\t\t\trange = i;\n\t\t\tvlsb = x[st->gain] * ((1 << (i + 1)) - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (vlsb <= 0)\n\t\treturn -EINVAL;\n\n\toffset_raw = DIV_ROUND_CLOSEST(abs(offset_uv), vlsb);\n\n\tmutex_lock(&st->lock);\n\tret = regmap_update_bits(st->regmap, ADA4250_REG_SNSR_CAL_CNFG,\n\t\t\t\t ADA4250_RANGE_SET_MSK,\n\t\t\t\t FIELD_PREP(ADA4250_RANGE_SET_MSK, range));\n\tif (ret)\n\t\tgoto exit;\n\n\tst->offset_uv = offset_raw * vlsb;\n\n\t \n\tif (offset_uv < 0) {\n\t\toffset_raw |= BIT(7);\n\t\tst->offset_uv *= (-1);\n\t}\n\n\tret = regmap_write(st->regmap, ADA4250_REG_SNSR_CAL_VAL, offset_raw);\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ada4250_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct ada4250_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tret = regmap_read(st->regmap, ADA4250_REG_GAIN_MUX, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = BIT(*val);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = st->offset_uv;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_read(st->regmap, ADA4250_REG_SNSR_CAL_CNFG, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = FIELD_GET(ADA4250_BIAS_SET_MSK, *val);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1;\n\t\t*val2 = 1000000;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ada4250_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long info)\n{\n\tstruct ada4250_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tret = regmap_write(st->regmap, ADA4250_REG_GAIN_MUX,\n\t\t\t\t   FIELD_PREP(ADA4250_GAIN_MUX_MSK, ilog2(val)));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst->gain = ilog2(val);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn ada4250_set_offset_uv(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_update_bits(st->regmap, ADA4250_REG_SNSR_CAL_CNFG,\n\t\t\t\t\t ADA4250_BIAS_SET_MSK,\n\t\t\t\t\t FIELD_PREP(ADA4250_BIAS_SET_MSK, val));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst->bias = val;\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ada4250_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*vals = calibbias_table;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(calibbias_table);\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t*vals = hwgain_table;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(hwgain_table);\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ada4250_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int write_val,\n\t\t\t      unsigned int *read_val)\n{\n\tstruct ada4250_state *st = iio_priv(indio_dev);\n\n\tif (read_val)\n\t\treturn regmap_read(st->regmap, reg, read_val);\n\telse\n\t\treturn regmap_write(st->regmap, reg, write_val);\n}\n\nstatic const struct iio_info ada4250_info = {\n\t.read_raw = ada4250_read_raw,\n\t.write_raw = ada4250_write_raw,\n\t.read_avail = &ada4250_read_avail,\n\t.debugfs_reg_access = &ada4250_reg_access,\n};\n\nstatic const struct iio_chan_spec ada4250_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.output = 1,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_HARDWAREGAIN) |\n\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\t\t\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN),\n\t}\n};\n\nstatic void ada4250_reg_disable(void *data)\n{\n\tregulator_disable(data);\n}\n\nstatic int ada4250_init(struct ada4250_state *st)\n{\n\tint ret;\n\tu16 chip_id;\n\tu8 data[2] __aligned(8) = {};\n\tstruct spi_device *spi = st->spi;\n\n\tst->refbuf_en = device_property_read_bool(&spi->dev, \"adi,refbuf-enable\");\n\n\tst->reg = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(st->reg))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->reg),\n\t\t\t\t     \"failed to get the AVDD voltage\\n\");\n\n\tret = regulator_enable(st->reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified AVDD supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ada4250_reg_disable, st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADA4250_REG_RESET,\n\t\t\t   FIELD_PREP(ADA4250_RESET_MSK, 1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(st->regmap, ADA4250_REG_CHIP_ID, data, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_id = get_unaligned_le16(data);\n\n\tif (chip_id != ADA4250_CHIP_ID) {\n\t\tdev_err(&spi->dev, \"Invalid chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(st->regmap, ADA4250_REG_REFBUF_EN,\n\t\t\t    FIELD_PREP(ADA4250_REFBUF_MSK, st->refbuf_en));\n}\n\nstatic int ada4250_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tstruct ada4250_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_spi(spi, &ada4250_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tst = iio_priv(indio_dev);\n\tst->regmap = regmap;\n\tst->spi = spi;\n\n\tindio_dev->info = &ada4250_info;\n\tindio_dev->name = \"ada4250\";\n\tindio_dev->channels = ada4250_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ada4250_channels);\n\n\tmutex_init(&st->lock);\n\n\tret = ada4250_init(st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADA4250 init failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ada4250_id[] = {\n\t{ \"ada4250\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ada4250_id);\n\nstatic const struct of_device_id ada4250_of_match[] = {\n\t{ .compatible = \"adi,ada4250\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ada4250_of_match);\n\nstatic struct spi_driver ada4250_driver = {\n\t.driver = {\n\t\t\t.name = \"ada4250\",\n\t\t\t.of_match_table = ada4250_of_match,\n\t\t},\n\t.probe = ada4250_probe,\n\t.id_table = ada4250_id,\n};\nmodule_spi_driver(ada4250_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices ADA4250\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}