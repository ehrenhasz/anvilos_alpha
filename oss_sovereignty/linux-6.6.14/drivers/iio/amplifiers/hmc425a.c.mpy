{
  "module_name": "hmc425a.c",
  "hash_id": "7dbf658e0e1185a78d2b74bfc00dd683fd7755843f9e9d4995bff5b20acf8456",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/amplifiers/hmc425a.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sysfs.h>\n\nenum hmc425a_type {\n\tID_HMC425A,\n};\n\nstruct hmc425a_chip_info {\n\tconst char\t\t\t*name;\n\tconst struct iio_chan_spec\t*channels;\n\tunsigned int\t\t\tnum_channels;\n\tunsigned int\t\t\tnum_gpios;\n\tint\t\t\t\tgain_min;\n\tint\t\t\t\tgain_max;\n\tint\t\t\t\tdefault_gain;\n};\n\nstruct hmc425a_state {\n\tstruct\tmutex lock;  \n\tstruct\thmc425a_chip_info *chip_info;\n\tstruct\tgpio_descs *gpios;\n\tenum\thmc425a_type type;\n\tu32\tgain;\n};\n\nstatic int hmc425a_write(struct iio_dev *indio_dev, u32 value)\n{\n\tstruct hmc425a_state *st = iio_priv(indio_dev);\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(value));\n\n\tvalues[0] = value;\n\n\tgpiod_set_array_value_cansleep(st->gpios->ndescs, st->gpios->desc,\n\t\t\t\t       NULL, values);\n\treturn 0;\n}\n\nstatic int hmc425a_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long m)\n{\n\tstruct hmc425a_state *st = iio_priv(indio_dev);\n\tint code, gain = 0;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tcode = st->gain;\n\n\t\tswitch (st->type) {\n\t\tcase ID_HMC425A:\n\t\t\tgain = ~code * -500;\n\t\t\tbreak;\n\t\t}\n\n\t\t*val = gain / 1000;\n\t\t*val2 = (gain % 1000) * 1000;\n\n\t\tret = IIO_VAL_INT_PLUS_MICRO_DB;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n};\n\nstatic int hmc425a_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct hmc425a_state *st = iio_priv(indio_dev);\n\tstruct hmc425a_chip_info *inf = st->chip_info;\n\tint code = 0, gain;\n\tint ret;\n\n\tif (val < 0)\n\t\tgain = (val * 1000) - (val2 / 1000);\n\telse\n\t\tgain = (val * 1000) + (val2 / 1000);\n\n\tif (gain > inf->gain_max || gain < inf->gain_min)\n\t\treturn -EINVAL;\n\n\tswitch (st->type) {\n\tcase ID_HMC425A:\n\t\tcode = ~((abs(gain) / 500) & 0x3F);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&st->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tst->gain = code;\n\n\t\tret = hmc425a_write(indio_dev, st->gain);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int hmc425a_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\treturn IIO_VAL_INT_PLUS_MICRO_DB;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info hmc425a_info = {\n\t.read_raw = &hmc425a_read_raw,\n\t.write_raw = &hmc425a_write_raw,\n\t.write_raw_get_fmt = &hmc425a_write_raw_get_fmt,\n};\n\n#define HMC425A_CHAN(_channel)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_HARDWAREGAIN),\t\t\\\n}\n\nstatic const struct iio_chan_spec hmc425a_channels[] = {\n\tHMC425A_CHAN(0),\n};\n\n \nstatic const struct of_device_id hmc425a_of_match[] = {\n\t{ .compatible = \"adi,hmc425a\", .data = (void *)ID_HMC425A },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hmc425a_of_match);\n\nstatic struct hmc425a_chip_info hmc425a_chip_info_tbl[] = {\n\t[ID_HMC425A] = {\n\t\t.name = \"hmc425a\",\n\t\t.channels = hmc425a_channels,\n\t\t.num_channels = ARRAY_SIZE(hmc425a_channels),\n\t\t.num_gpios = 6,\n\t\t.gain_min = -31500,\n\t\t.gain_max = 0,\n\t\t.default_gain = -0x40,  \n\t},\n};\n\nstatic int hmc425a_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct hmc425a_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->type = (uintptr_t)device_get_match_data(&pdev->dev);\n\n\tst->chip_info = &hmc425a_chip_info_tbl[st->type];\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->name = st->chip_info->name;\n\tst->gain = st->chip_info->default_gain;\n\n\tst->gpios = devm_gpiod_get_array(&pdev->dev, \"ctrl\", GPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpios))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(st->gpios),\n\t\t\t\t     \"failed to get gpios\\n\");\n\n\tif (st->gpios->ndescs != st->chip_info->num_gpios) {\n\t\tdev_err(&pdev->dev, \"%d GPIOs needed to operate\\n\",\n\t\t\tst->chip_info->num_gpios);\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_regulator_get_enable(&pdev->dev, \"vcc-supply\");\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&st->lock);\n\n\tindio_dev->info = &hmc425a_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic struct platform_driver hmc425a_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = hmc425a_of_match,\n\t},\n\t.probe = hmc425a_probe,\n};\nmodule_platform_driver(hmc425a_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices HMC425A and similar GPIO control Gain Amplifiers\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}