{
  "module_name": "ad8366.c",
  "hash_id": "c026bc4e5ce4c542176dd6e01242e6afc3eaf1ee44ec13d517d30f5bb315476c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/amplifiers/ad8366.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/bitrev.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\nenum ad8366_type {\n\tID_AD8366,\n\tID_ADA4961,\n\tID_ADL5240,\n\tID_HMC792,\n\tID_HMC1119,\n};\n\nstruct ad8366_info {\n\tint gain_min;\n\tint gain_max;\n};\n\nstruct ad8366_state {\n\tstruct spi_device\t*spi;\n\tstruct regulator\t*reg;\n\tstruct mutex            lock;  \n\tstruct gpio_desc\t*reset_gpio;\n\tunsigned char\t\tch[2];\n\tenum ad8366_type\ttype;\n\tstruct ad8366_info\t*info;\n\t \n\tunsigned char\t\tdata[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic struct ad8366_info ad8366_infos[] = {\n\t[ID_AD8366] = {\n\t\t.gain_min = 4500,\n\t\t.gain_max = 20500,\n\t},\n\t[ID_ADA4961] = {\n\t\t.gain_min = -6000,\n\t\t.gain_max = 15000,\n\t},\n\t[ID_ADL5240] = {\n\t\t.gain_min = -11500,\n\t\t.gain_max = 20000,\n\t},\n\t[ID_HMC792] = {\n\t\t.gain_min = -15750,\n\t\t.gain_max = 0,\n\t},\n\t[ID_HMC1119] = {\n\t\t.gain_min = -31750,\n\t\t.gain_max = 0,\n\t},\n};\n\nstatic int ad8366_write(struct iio_dev *indio_dev,\n\t\t\tunsigned char ch_a, unsigned char ch_b)\n{\n\tstruct ad8366_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (st->type) {\n\tcase ID_AD8366:\n\t\tch_a = bitrev8(ch_a & 0x3F);\n\t\tch_b = bitrev8(ch_b & 0x3F);\n\n\t\tst->data[0] = ch_b >> 4;\n\t\tst->data[1] = (ch_b << 4) | (ch_a >> 2);\n\t\tbreak;\n\tcase ID_ADA4961:\n\t\tst->data[0] = ch_a & 0x1F;\n\t\tbreak;\n\tcase ID_ADL5240:\n\t\tst->data[0] = (ch_a & 0x3F);\n\t\tbreak;\n\tcase ID_HMC792:\n\tcase ID_HMC1119:\n\t\tst->data[0] = ch_a;\n\t\tbreak;\n\t}\n\n\tret = spi_write(st->spi, st->data, indio_dev->num_channels);\n\tif (ret < 0)\n\t\tdev_err(&indio_dev->dev, \"write failed (%d)\", ret);\n\n\treturn ret;\n}\n\nstatic int ad8366_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad8366_state *st = iio_priv(indio_dev);\n\tint ret;\n\tint code, gain = 0;\n\n\tmutex_lock(&st->lock);\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tcode = st->ch[chan->channel];\n\n\t\tswitch (st->type) {\n\t\tcase ID_AD8366:\n\t\t\tgain = code * 253 + 4500;\n\t\t\tbreak;\n\t\tcase ID_ADA4961:\n\t\t\tgain = 15000 - code * 1000;\n\t\t\tbreak;\n\t\tcase ID_ADL5240:\n\t\t\tgain = 20000 - 31500 + code * 500;\n\t\t\tbreak;\n\t\tcase ID_HMC792:\n\t\t\tgain = -1 * code * 500;\n\t\t\tbreak;\n\t\tcase ID_HMC1119:\n\t\t\tgain = -1 * code * 250;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t*val = gain / 1000;\n\t\t*val2 = (gain % 1000) * 1000;\n\n\t\tret = IIO_VAL_INT_PLUS_MICRO_DB;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n};\n\nstatic int ad8366_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct ad8366_state *st = iio_priv(indio_dev);\n\tstruct ad8366_info *inf = st->info;\n\tint code = 0, gain;\n\tint ret;\n\n\t \n\tif (val < 0)\n\t\tgain = (val * 1000) - (val2 / 1000);\n\telse\n\t\tgain = (val * 1000) + (val2 / 1000);\n\n\tif (gain > inf->gain_max || gain < inf->gain_min)\n\t\treturn -EINVAL;\n\n\tswitch (st->type) {\n\tcase ID_AD8366:\n\t\tcode = (gain - 4500) / 253;\n\t\tbreak;\n\tcase ID_ADA4961:\n\t\tcode = (15000 - gain) / 1000;\n\t\tbreak;\n\tcase ID_ADL5240:\n\t\tcode = ((gain - 500 - 20000) / 500) & 0x3F;\n\t\tbreak;\n\tcase ID_HMC792:\n\t\tcode = (abs(gain) / 500) & 0x3F;\n\t\tbreak;\n\tcase ID_HMC1119:\n\t\tcode = (abs(gain) / 250) & 0x7F;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&st->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tst->ch[chan->channel] = code;\n\t\tret = ad8366_write(indio_dev, st->ch[0], st->ch[1]);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad8366_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\treturn IIO_VAL_INT_PLUS_MICRO_DB;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ad8366_info = {\n\t.read_raw = &ad8366_read_raw,\n\t.write_raw = &ad8366_write_raw,\n\t.write_raw_get_fmt = &ad8366_write_raw_get_fmt,\n};\n\n#define AD8366_CHAN(_channel) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_HARDWAREGAIN),\\\n}\n\nstatic const struct iio_chan_spec ad8366_channels[] = {\n\tAD8366_CHAN(0),\n\tAD8366_CHAN(1),\n};\n\nstatic const struct iio_chan_spec ada4961_channels[] = {\n\tAD8366_CHAN(0),\n};\n\nstatic int ad8366_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ad8366_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get(&spi->dev, \"vcc\");\n\tif (!IS_ERR(st->reg)) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, indio_dev);\n\tmutex_init(&st->lock);\n\tst->spi = spi;\n\tst->type = spi_get_device_id(spi)->driver_data;\n\n\tswitch (st->type) {\n\tcase ID_AD8366:\n\t\tindio_dev->channels = ad8366_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad8366_channels);\n\t\tbreak;\n\tcase ID_ADA4961:\n\tcase ID_ADL5240:\n\tcase ID_HMC792:\n\tcase ID_HMC1119:\n\t\tst->reset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(st->reset_gpio)) {\n\t\t\tret = PTR_ERR(st->reset_gpio);\n\t\t\tgoto error_disable_reg;\n\t\t}\n\t\tindio_dev->channels = ada4961_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ada4961_channels);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spi->dev, \"Invalid device ID\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_disable_reg;\n\t}\n\n\tst->info = &ad8366_infos[st->type];\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad8366_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ad8366_write(indio_dev, 0, 0);\n\tif (ret < 0)\n\t\tgoto error_disable_reg;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\treturn 0;\n\nerror_disable_reg:\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n\n\treturn ret;\n}\n\nstatic void ad8366_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad8366_state *st = iio_priv(indio_dev);\n\tstruct regulator *reg = st->reg;\n\n\tiio_device_unregister(indio_dev);\n\n\tif (!IS_ERR(reg))\n\t\tregulator_disable(reg);\n}\n\nstatic const struct spi_device_id ad8366_id[] = {\n\t{\"ad8366\",  ID_AD8366},\n\t{\"ada4961\", ID_ADA4961},\n\t{\"adl5240\", ID_ADL5240},\n\t{\"hmc792a\", ID_HMC792},\n\t{\"hmc1119\", ID_HMC1119},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad8366_id);\n\nstatic struct spi_driver ad8366_driver = {\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t},\n\t.probe\t\t= ad8366_probe,\n\t.remove\t\t= ad8366_remove,\n\t.id_table\t= ad8366_id,\n};\n\nmodule_spi_driver(ad8366_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD8366 and similar Gain Amplifiers\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}