{
  "module_name": "industrialio-hw-consumer.c",
  "hash_id": "2f4aad1da51d4bb1bb1e2cb1618cf85be4b17c7261ee22fee261bc055e535305",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/buffer/industrialio-hw-consumer.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/hw-consumer.h>\n#include <linux/iio/buffer_impl.h>\n\n \nstruct iio_hw_consumer {\n\tstruct list_head buffers;\n\tstruct iio_channel *channels;\n};\n\nstruct hw_consumer_buffer {\n\tstruct list_head head;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_buffer buffer;\n\tlong scan_mask[];\n};\n\nstatic struct hw_consumer_buffer *iio_buffer_to_hw_consumer_buffer(\n\tstruct iio_buffer *buffer)\n{\n\treturn container_of(buffer, struct hw_consumer_buffer, buffer);\n}\n\nstatic void iio_hw_buf_release(struct iio_buffer *buffer)\n{\n\tstruct hw_consumer_buffer *hw_buf =\n\t\tiio_buffer_to_hw_consumer_buffer(buffer);\n\tkfree(hw_buf);\n}\n\nstatic const struct iio_buffer_access_funcs iio_hw_buf_access = {\n\t.release = &iio_hw_buf_release,\n\t.modes = INDIO_BUFFER_HARDWARE,\n};\n\nstatic struct hw_consumer_buffer *iio_hw_consumer_get_buffer(\n\tstruct iio_hw_consumer *hwc, struct iio_dev *indio_dev)\n{\n\tstruct hw_consumer_buffer *buf;\n\n\tlist_for_each_entry(buf, &hwc->buffers, head) {\n\t\tif (buf->indio_dev == indio_dev)\n\t\t\treturn buf;\n\t}\n\n\tbuf = kzalloc(struct_size(buf, scan_mask, BITS_TO_LONGS(indio_dev->masklength)),\n\t\t      GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->buffer.access = &iio_hw_buf_access;\n\tbuf->indio_dev = indio_dev;\n\tbuf->buffer.scan_mask = buf->scan_mask;\n\n\tiio_buffer_init(&buf->buffer);\n\tlist_add_tail(&buf->head, &hwc->buffers);\n\n\treturn buf;\n}\n\n \nstruct iio_hw_consumer *iio_hw_consumer_alloc(struct device *dev)\n{\n\tstruct hw_consumer_buffer *buf;\n\tstruct iio_hw_consumer *hwc;\n\tstruct iio_channel *chan;\n\tint ret;\n\n\thwc = kzalloc(sizeof(*hwc), GFP_KERNEL);\n\tif (!hwc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&hwc->buffers);\n\n\thwc->channels = iio_channel_get_all(dev);\n\tif (IS_ERR(hwc->channels)) {\n\t\tret = PTR_ERR(hwc->channels);\n\t\tgoto err_free_hwc;\n\t}\n\n\tchan = &hwc->channels[0];\n\twhile (chan->indio_dev) {\n\t\tbuf = iio_hw_consumer_get_buffer(hwc, chan->indio_dev);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_buffers;\n\t\t}\n\t\tset_bit(chan->channel->scan_index, buf->buffer.scan_mask);\n\t\tchan++;\n\t}\n\n\treturn hwc;\n\nerr_put_buffers:\n\tlist_for_each_entry(buf, &hwc->buffers, head)\n\t\tiio_buffer_put(&buf->buffer);\n\tiio_channel_release_all(hwc->channels);\nerr_free_hwc:\n\tkfree(hwc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(iio_hw_consumer_alloc);\n\n \nvoid iio_hw_consumer_free(struct iio_hw_consumer *hwc)\n{\n\tstruct hw_consumer_buffer *buf, *n;\n\n\tiio_channel_release_all(hwc->channels);\n\tlist_for_each_entry_safe(buf, n, &hwc->buffers, head)\n\t\tiio_buffer_put(&buf->buffer);\n\tkfree(hwc);\n}\nEXPORT_SYMBOL_GPL(iio_hw_consumer_free);\n\nstatic void devm_iio_hw_consumer_release(void *iio_hwc)\n{\n\tiio_hw_consumer_free(iio_hwc);\n}\n\n \nstruct iio_hw_consumer *devm_iio_hw_consumer_alloc(struct device *dev)\n{\n\tstruct iio_hw_consumer *iio_hwc;\n\tint ret;\n\n\tiio_hwc = iio_hw_consumer_alloc(dev);\n\tif (IS_ERR(iio_hwc))\n\t\treturn iio_hwc;\n\n\tret = devm_add_action_or_reset(dev, devm_iio_hw_consumer_release,\n\t\t\t\t       iio_hwc);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn iio_hwc;\n}\nEXPORT_SYMBOL_GPL(devm_iio_hw_consumer_alloc);\n\n \nint iio_hw_consumer_enable(struct iio_hw_consumer *hwc)\n{\n\tstruct hw_consumer_buffer *buf;\n\tint ret;\n\n\tlist_for_each_entry(buf, &hwc->buffers, head) {\n\t\tret = iio_update_buffers(buf->indio_dev, &buf->buffer, NULL);\n\t\tif (ret)\n\t\t\tgoto err_disable_buffers;\n\t}\n\n\treturn 0;\n\nerr_disable_buffers:\n\tlist_for_each_entry_continue_reverse(buf, &hwc->buffers, head)\n\t\tiio_update_buffers(buf->indio_dev, NULL, &buf->buffer);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_hw_consumer_enable);\n\n \nvoid iio_hw_consumer_disable(struct iio_hw_consumer *hwc)\n{\n\tstruct hw_consumer_buffer *buf;\n\n\tlist_for_each_entry(buf, &hwc->buffers, head)\n\t\tiio_update_buffers(buf->indio_dev, NULL, &buf->buffer);\n}\nEXPORT_SYMBOL_GPL(iio_hw_consumer_disable);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Hardware consumer buffer the IIO framework\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}