{
  "module_name": "industrialio-buffer-cb.c",
  "hash_id": "ad10e8fbd5770cdef732669a3af36d7267348a6febd3b5872dd7b8132e8b2401",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/buffer/industrialio-buffer-cb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer_impl.h>\n#include <linux/iio/consumer.h>\n\nstruct iio_cb_buffer {\n\tstruct iio_buffer buffer;\n\tint (*cb)(const void *data, void *private);\n\tvoid *private;\n\tstruct iio_channel *channels;\n\tstruct iio_dev *indio_dev;\n};\n\nstatic struct iio_cb_buffer *buffer_to_cb_buffer(struct iio_buffer *buffer)\n{\n\treturn container_of(buffer, struct iio_cb_buffer, buffer);\n}\n\nstatic int iio_buffer_cb_store_to(struct iio_buffer *buffer, const void *data)\n{\n\tstruct iio_cb_buffer *cb_buff = buffer_to_cb_buffer(buffer);\n\treturn cb_buff->cb(data, cb_buff->private);\n}\n\nstatic void iio_buffer_cb_release(struct iio_buffer *buffer)\n{\n\tstruct iio_cb_buffer *cb_buff = buffer_to_cb_buffer(buffer);\n\n\tbitmap_free(cb_buff->buffer.scan_mask);\n\tkfree(cb_buff);\n}\n\nstatic const struct iio_buffer_access_funcs iio_cb_access = {\n\t.store_to = &iio_buffer_cb_store_to,\n\t.release = &iio_buffer_cb_release,\n\n\t.modes = INDIO_BUFFER_SOFTWARE | INDIO_BUFFER_TRIGGERED,\n};\n\nstruct iio_cb_buffer *iio_channel_get_all_cb(struct device *dev,\n\t\t\t\t\t     int (*cb)(const void *data,\n\t\t\t\t\t\t       void *private),\n\t\t\t\t\t     void *private)\n{\n\tint ret;\n\tstruct iio_cb_buffer *cb_buff;\n\tstruct iio_channel *chan;\n\n\tif (!cb) {\n\t\tdev_err(dev, \"Invalid arguments: A callback must be provided!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcb_buff = kzalloc(sizeof(*cb_buff), GFP_KERNEL);\n\tif (cb_buff == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiio_buffer_init(&cb_buff->buffer);\n\n\tcb_buff->private = private;\n\tcb_buff->cb = cb;\n\tcb_buff->buffer.access = &iio_cb_access;\n\tINIT_LIST_HEAD(&cb_buff->buffer.demux_list);\n\n\tcb_buff->channels = iio_channel_get_all(dev);\n\tif (IS_ERR(cb_buff->channels)) {\n\t\tret = PTR_ERR(cb_buff->channels);\n\t\tgoto error_free_cb_buff;\n\t}\n\n\tcb_buff->indio_dev = cb_buff->channels[0].indio_dev;\n\tcb_buff->buffer.scan_mask = bitmap_zalloc(cb_buff->indio_dev->masklength,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (cb_buff->buffer.scan_mask == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_release_channels;\n\t}\n\tchan = &cb_buff->channels[0];\n\twhile (chan->indio_dev) {\n\t\tif (chan->indio_dev != cb_buff->indio_dev) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_free_scan_mask;\n\t\t}\n\t\tset_bit(chan->channel->scan_index,\n\t\t\tcb_buff->buffer.scan_mask);\n\t\tchan++;\n\t}\n\n\treturn cb_buff;\n\nerror_free_scan_mask:\n\tbitmap_free(cb_buff->buffer.scan_mask);\nerror_release_channels:\n\tiio_channel_release_all(cb_buff->channels);\nerror_free_cb_buff:\n\tkfree(cb_buff);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(iio_channel_get_all_cb);\n\nint iio_channel_cb_set_buffer_watermark(struct iio_cb_buffer *cb_buff,\n\t\t\t\t\tsize_t watermark)\n{\n\tif (!watermark)\n\t\treturn -EINVAL;\n\tcb_buff->buffer.watermark = watermark;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iio_channel_cb_set_buffer_watermark);\n\nint iio_channel_start_all_cb(struct iio_cb_buffer *cb_buff)\n{\n\treturn iio_update_buffers(cb_buff->indio_dev, &cb_buff->buffer,\n\t\t\t\t  NULL);\n}\nEXPORT_SYMBOL_GPL(iio_channel_start_all_cb);\n\nvoid iio_channel_stop_all_cb(struct iio_cb_buffer *cb_buff)\n{\n\tiio_update_buffers(cb_buff->indio_dev, NULL, &cb_buff->buffer);\n}\nEXPORT_SYMBOL_GPL(iio_channel_stop_all_cb);\n\nvoid iio_channel_release_all_cb(struct iio_cb_buffer *cb_buff)\n{\n\tiio_channel_release_all(cb_buff->channels);\n\tiio_buffer_put(&cb_buff->buffer);\n}\nEXPORT_SYMBOL_GPL(iio_channel_release_all_cb);\n\nstruct iio_channel\n*iio_channel_cb_get_channels(const struct iio_cb_buffer *cb_buffer)\n{\n\treturn cb_buffer->channels;\n}\nEXPORT_SYMBOL_GPL(iio_channel_cb_get_channels);\n\nstruct iio_dev\n*iio_channel_cb_get_iio_dev(const struct iio_cb_buffer *cb_buffer)\n{\n\treturn cb_buffer->indio_dev;\n}\nEXPORT_SYMBOL_GPL(iio_channel_cb_get_iio_dev);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"Industrial I/O callback buffer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}