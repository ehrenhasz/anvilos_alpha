{
  "module_name": "kfifo_buf.c",
  "hash_id": "c1fc4b6d44554002a371a7bb34a6956260c1e607a1c7e24b57e0e779ed1a4803",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/buffer/kfifo_buf.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/workqueue.h>\n#include <linux/kfifo.h>\n#include <linux/mutex.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/buffer_impl.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n\nstruct iio_kfifo {\n\tstruct iio_buffer buffer;\n\tstruct kfifo kf;\n\tstruct mutex user_lock;\n\tint update_needed;\n};\n\n#define iio_to_kfifo(r) container_of(r, struct iio_kfifo, buffer)\n\nstatic inline int __iio_allocate_kfifo(struct iio_kfifo *buf,\n\t\t\tsize_t bytes_per_datum, unsigned int length)\n{\n\tif ((length == 0) || (bytes_per_datum == 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (roundup_pow_of_two(length) > UINT_MAX / bytes_per_datum)\n\t\treturn -EINVAL;\n\n\treturn __kfifo_alloc((struct __kfifo *)&buf->kf, length,\n\t\t\t     bytes_per_datum, GFP_KERNEL);\n}\n\nstatic int iio_request_update_kfifo(struct iio_buffer *r)\n{\n\tint ret = 0;\n\tstruct iio_kfifo *buf = iio_to_kfifo(r);\n\n\tmutex_lock(&buf->user_lock);\n\tif (buf->update_needed) {\n\t\tkfifo_free(&buf->kf);\n\t\tret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,\n\t\t\t\t   buf->buffer.length);\n\t\tif (ret >= 0)\n\t\t\tbuf->update_needed = false;\n\t} else {\n\t\tkfifo_reset_out(&buf->kf);\n\t}\n\tmutex_unlock(&buf->user_lock);\n\n\treturn ret;\n}\n\nstatic int iio_mark_update_needed_kfifo(struct iio_buffer *r)\n{\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\tkf->update_needed = true;\n\treturn 0;\n}\n\nstatic int iio_set_bytes_per_datum_kfifo(struct iio_buffer *r, size_t bpd)\n{\n\tif (r->bytes_per_datum != bpd) {\n\t\tr->bytes_per_datum = bpd;\n\t\tiio_mark_update_needed_kfifo(r);\n\t}\n\treturn 0;\n}\n\nstatic int iio_set_length_kfifo(struct iio_buffer *r, unsigned int length)\n{\n\t \n\tif (length < 2)\n\t\tlength = 2;\n\tif (r->length != length) {\n\t\tr->length = length;\n\t\tiio_mark_update_needed_kfifo(r);\n\t}\n\treturn 0;\n}\n\nstatic int iio_store_to_kfifo(struct iio_buffer *r,\n\t\t\t      const void *data)\n{\n\tint ret;\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\tret = kfifo_in(&kf->kf, data, 1);\n\tif (ret != 1)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int iio_read_kfifo(struct iio_buffer *r, size_t n, char __user *buf)\n{\n\tint ret, copied;\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\n\tif (mutex_lock_interruptible(&kf->user_lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (!kfifo_initialized(&kf->kf) || n < kfifo_esize(&kf->kf))\n\t\tret = -EINVAL;\n\telse\n\t\tret = kfifo_to_user(&kf->kf, buf, n, &copied);\n\tmutex_unlock(&kf->user_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn copied;\n}\n\nstatic size_t iio_kfifo_buf_data_available(struct iio_buffer *r)\n{\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\tsize_t samples;\n\n\tmutex_lock(&kf->user_lock);\n\tsamples = kfifo_len(&kf->kf);\n\tmutex_unlock(&kf->user_lock);\n\n\treturn samples;\n}\n\nstatic void iio_kfifo_buffer_release(struct iio_buffer *buffer)\n{\n\tstruct iio_kfifo *kf = iio_to_kfifo(buffer);\n\n\tmutex_destroy(&kf->user_lock);\n\tkfifo_free(&kf->kf);\n\tkfree(kf);\n}\n\nstatic size_t iio_kfifo_buf_space_available(struct iio_buffer *r)\n{\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\tsize_t avail;\n\n\tmutex_lock(&kf->user_lock);\n\tavail = kfifo_avail(&kf->kf);\n\tmutex_unlock(&kf->user_lock);\n\n\treturn avail;\n}\n\nstatic int iio_kfifo_remove_from(struct iio_buffer *r, void *data)\n{\n\tint ret;\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\n\tif (kfifo_size(&kf->kf) < 1)\n\t\treturn -EBUSY;\n\n\tret = kfifo_out(&kf->kf, data, 1);\n\tif (ret != 1)\n\t\treturn -EBUSY;\n\n\twake_up_interruptible_poll(&r->pollq, EPOLLOUT | EPOLLWRNORM);\n\n\treturn 0;\n}\n\nstatic int iio_kfifo_write(struct iio_buffer *r, size_t n,\n\tconst char __user *buf)\n{\n\tstruct iio_kfifo *kf = iio_to_kfifo(r);\n\tint ret, copied;\n\n\tmutex_lock(&kf->user_lock);\n\tif (!kfifo_initialized(&kf->kf) || n < kfifo_esize(&kf->kf))\n\t\tret = -EINVAL;\n\telse\n\t\tret = kfifo_from_user(&kf->kf, buf, n, &copied);\n\tmutex_unlock(&kf->user_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn copied;\n}\n\nstatic const struct iio_buffer_access_funcs kfifo_access_funcs = {\n\t.store_to = &iio_store_to_kfifo,\n\t.read = &iio_read_kfifo,\n\t.data_available = iio_kfifo_buf_data_available,\n\t.remove_from = &iio_kfifo_remove_from,\n\t.write = &iio_kfifo_write,\n\t.space_available = &iio_kfifo_buf_space_available,\n\t.request_update = &iio_request_update_kfifo,\n\t.set_bytes_per_datum = &iio_set_bytes_per_datum_kfifo,\n\t.set_length = &iio_set_length_kfifo,\n\t.release = &iio_kfifo_buffer_release,\n\n\t.modes = INDIO_BUFFER_SOFTWARE | INDIO_BUFFER_TRIGGERED,\n};\n\nstruct iio_buffer *iio_kfifo_allocate(void)\n{\n\tstruct iio_kfifo *kf;\n\n\tkf = kzalloc(sizeof(*kf), GFP_KERNEL);\n\tif (!kf)\n\t\treturn NULL;\n\n\tkf->update_needed = true;\n\tiio_buffer_init(&kf->buffer);\n\tkf->buffer.access = &kfifo_access_funcs;\n\tkf->buffer.length = 2;\n\tmutex_init(&kf->user_lock);\n\n\treturn &kf->buffer;\n}\nEXPORT_SYMBOL(iio_kfifo_allocate);\n\nvoid iio_kfifo_free(struct iio_buffer *r)\n{\n\tiio_buffer_put(r);\n}\nEXPORT_SYMBOL(iio_kfifo_free);\n\nstatic void devm_iio_kfifo_release(struct device *dev, void *res)\n{\n\tiio_kfifo_free(*(struct iio_buffer **)res);\n}\n\n \nstatic struct iio_buffer *devm_iio_kfifo_allocate(struct device *dev)\n{\n\tstruct iio_buffer **ptr, *r;\n\n\tptr = devres_alloc(devm_iio_kfifo_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\tr = iio_kfifo_allocate();\n\tif (r) {\n\t\t*ptr = r;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn r;\n}\n\n \nint devm_iio_kfifo_buffer_setup_ext(struct device *dev,\n\t\t\t\t    struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_buffer_setup_ops *setup_ops,\n\t\t\t\t    const struct iio_dev_attr **buffer_attrs)\n{\n\tstruct iio_buffer *buffer;\n\n\tbuffer = devm_iio_kfifo_allocate(dev);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tindio_dev->modes |= INDIO_BUFFER_SOFTWARE;\n\tindio_dev->setup_ops = setup_ops;\n\n\tbuffer->attrs = buffer_attrs;\n\n\treturn iio_device_attach_buffer(indio_dev, buffer);\n}\nEXPORT_SYMBOL_GPL(devm_iio_kfifo_buffer_setup_ext);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}