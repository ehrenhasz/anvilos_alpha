{
  "module_name": "dht11.c",
  "hash_id": "a373190134a051647ab5950f2200e4e6f3e980dfe9f5bb1d21d0f0d6c47e85a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/dht11.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/timekeeping.h>\n\n#include <linux/iio/iio.h>\n\n#define DRIVER_NAME\t\"dht11\"\n\n#define DHT11_DATA_VALID_TIME\t2000000000   \n\n#define DHT11_EDGES_PREAMBLE 2\n#define DHT11_BITS_PER_READ 40\n \n#define DHT11_EDGES_PER_READ (2 * DHT11_BITS_PER_READ + \\\n\t\t\t      DHT11_EDGES_PREAMBLE + 1)\n\n \n#define DHT11_START_TRANSMISSION_MIN\t18000   \n#define DHT11_START_TRANSMISSION_MAX\t20000   \n#define DHT11_MIN_TIMERES\t34000   \n#define DHT11_THRESHOLD\t\t49000   \n#define DHT11_AMBIG_LOW\t\t23000   \n#define DHT11_AMBIG_HIGH\t30000   \n\nstruct dht11 {\n\tstruct device\t\t\t*dev;\n\n\tstruct gpio_desc\t\t*gpiod;\n\tint\t\t\t\tirq;\n\n\tstruct completion\t\tcompletion;\n\t \n\tstruct mutex\t\t\tlock;\n\n\ts64\t\t\t\ttimestamp;\n\tint\t\t\t\ttemperature;\n\tint\t\t\t\thumidity;\n\n\t \n\tint\t\t\t\tnum_edges;\n\tstruct {s64 ts; int value; }\tedges[DHT11_EDGES_PER_READ];\n};\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n \nstatic void dht11_edges_print(struct dht11 *dht11)\n{\n\tint i;\n\n\tdev_dbg(dht11->dev, \"%d edges detected:\\n\", dht11->num_edges);\n\tfor (i = 1; i < dht11->num_edges; ++i) {\n\t\tdev_dbg(dht11->dev, \"%d: %lld ns %s\\n\", i,\n\t\t\tdht11->edges[i].ts - dht11->edges[i - 1].ts,\n\t\t\tdht11->edges[i - 1].value ? \"high\" : \"low\");\n\t}\n}\n#endif  \n\nstatic unsigned char dht11_decode_byte(char *bits)\n{\n\tunsigned char ret = 0;\n\tint i;\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tret <<= 1;\n\t\tif (bits[i])\n\t\t\t++ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int dht11_decode(struct dht11 *dht11, int offset)\n{\n\tint i, t;\n\tchar bits[DHT11_BITS_PER_READ];\n\tunsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;\n\n\tfor (i = 0; i < DHT11_BITS_PER_READ; ++i) {\n\t\tt = dht11->edges[offset + 2 * i + 2].ts -\n\t\t\tdht11->edges[offset + 2 * i + 1].ts;\n\t\tif (!dht11->edges[offset + 2 * i + 1].value) {\n\t\t\tdev_dbg(dht11->dev,\n\t\t\t\t\"lost synchronisation at edge %d\\n\",\n\t\t\t\toffset + 2 * i + 1);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbits[i] = t > DHT11_THRESHOLD;\n\t}\n\n\thum_int = dht11_decode_byte(bits);\n\thum_dec = dht11_decode_byte(&bits[8]);\n\ttemp_int = dht11_decode_byte(&bits[16]);\n\ttemp_dec = dht11_decode_byte(&bits[24]);\n\tchecksum = dht11_decode_byte(&bits[32]);\n\n\tif (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum) {\n\t\tdev_dbg(dht11->dev, \"invalid checksum\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdht11->timestamp = ktime_get_boottime_ns();\n\tif (hum_int < 4) {   \n\t\tdht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *\n\t\t\t\t\t((temp_int & 0x80) ? -100 : 100);\n\t\tdht11->humidity = ((hum_int << 8) + hum_dec) * 100;\n\t} else if (temp_dec == 0 && hum_dec == 0) {   \n\t\tdht11->temperature = temp_int * 1000;\n\t\tdht11->humidity = hum_int * 1000;\n\t} else {\n\t\tdev_err(dht11->dev,\n\t\t\t\"Don't know how to decode data: %d %d %d %d\\n\",\n\t\t\thum_int, hum_dec, temp_int, temp_dec);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t dht11_handle_irq(int irq, void *data)\n{\n\tstruct iio_dev *iio = data;\n\tstruct dht11 *dht11 = iio_priv(iio);\n\n\tif (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {\n\t\tdht11->edges[dht11->num_edges].ts = ktime_get_boottime_ns();\n\t\tdht11->edges[dht11->num_edges++].value =\n\t\t\t\t\t\tgpiod_get_value(dht11->gpiod);\n\n\t\tif (dht11->num_edges >= DHT11_EDGES_PER_READ)\n\t\t\tcomplete(&dht11->completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dht11_read_raw(struct iio_dev *iio_dev,\n\t\t\t  const struct iio_chan_spec *chan,\n\t\t\tint *val, int *val2, long m)\n{\n\tstruct dht11 *dht11 = iio_priv(iio_dev);\n\tint ret, timeres, offset;\n\n\tmutex_lock(&dht11->lock);\n\tif (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boottime_ns()) {\n\t\ttimeres = ktime_get_resolution_ns();\n\t\tdev_dbg(dht11->dev, \"current timeresolution: %dns\\n\", timeres);\n\t\tif (timeres > DHT11_MIN_TIMERES) {\n\t\t\tdev_err(dht11->dev, \"timeresolution %dns too low\\n\",\n\t\t\t\ttimeres);\n\t\t\t \n\t\t\tret = -EAGAIN;\n\t\t\tgoto err;\n\t\t}\n\t\tif (timeres > DHT11_AMBIG_LOW && timeres < DHT11_AMBIG_HIGH)\n\t\t\tdev_warn(dht11->dev,\n\t\t\t\t \"timeresolution: %dns - decoding ambiguous\\n\",\n\t\t\t\t timeres);\n\n\t\treinit_completion(&dht11->completion);\n\n\t\tdht11->num_edges = 0;\n\t\tret = gpiod_direction_output(dht11->gpiod, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tusleep_range(DHT11_START_TRANSMISSION_MIN,\n\t\t\t     DHT11_START_TRANSMISSION_MAX);\n\t\tret = gpiod_direction_input(dht11->gpiod);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = request_irq(dht11->irq, dht11_handle_irq,\n\t\t\t\t  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\t  iio_dev->name, iio_dev);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = wait_for_completion_killable_timeout(&dht11->completion,\n\t\t\t\t\t\t\t   HZ);\n\n\t\tfree_irq(dht11->irq, iio_dev);\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\t\tdht11_edges_print(dht11);\n#endif\n\n\t\tif (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {\n\t\t\tdev_err(dht11->dev, \"Only %d signal edges detected\\n\",\n\t\t\t\tdht11->num_edges);\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\toffset = DHT11_EDGES_PREAMBLE +\n\t\t\t\tdht11->num_edges - DHT11_EDGES_PER_READ;\n\t\tfor (; offset >= 0; --offset) {\n\t\t\tret = dht11_decode(dht11, offset);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = IIO_VAL_INT;\n\tif (chan->type == IIO_TEMP)\n\t\t*val = dht11->temperature;\n\telse if (chan->type == IIO_HUMIDITYRELATIVE)\n\t\t*val = dht11->humidity;\n\telse\n\t\tret = -EINVAL;\nerr:\n\tdht11->num_edges = -1;\n\tmutex_unlock(&dht11->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info dht11_iio_info = {\n\t.read_raw\t\t= dht11_read_raw,\n};\n\nstatic const struct iio_chan_spec dht11_chan_spec[] = {\n\t{ .type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), },\n\t{ .type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), }\n};\n\nstatic const struct of_device_id dht11_dt_ids[] = {\n\t{ .compatible = \"dht11\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, dht11_dt_ids);\n\nstatic int dht11_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dht11 *dht11;\n\tstruct iio_dev *iio;\n\n\tiio = devm_iio_device_alloc(dev, sizeof(*dht11));\n\tif (!iio) {\n\t\tdev_err(dev, \"Failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdht11 = iio_priv(iio);\n\tdht11->dev = dev;\n\tdht11->gpiod = devm_gpiod_get(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(dht11->gpiod))\n\t\treturn PTR_ERR(dht11->gpiod);\n\n\tdht11->irq = gpiod_to_irq(dht11->gpiod);\n\tif (dht11->irq < 0) {\n\t\tdev_err(dev, \"GPIO %d has no interrupt\\n\", desc_to_gpio(dht11->gpiod));\n\t\treturn -EINVAL;\n\t}\n\n\tdht11->timestamp = ktime_get_boottime_ns() - DHT11_DATA_VALID_TIME - 1;\n\tdht11->num_edges = -1;\n\n\tplatform_set_drvdata(pdev, iio);\n\n\tinit_completion(&dht11->completion);\n\tmutex_init(&dht11->lock);\n\tiio->name = pdev->name;\n\tiio->info = &dht11_iio_info;\n\tiio->modes = INDIO_DIRECT_MODE;\n\tiio->channels = dht11_chan_spec;\n\tiio->num_channels = ARRAY_SIZE(dht11_chan_spec);\n\n\treturn devm_iio_device_register(dev, iio);\n}\n\nstatic struct platform_driver dht11_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = dht11_dt_ids,\n\t},\n\t.probe  = dht11_probe,\n};\n\nmodule_platform_driver(dht11_driver);\n\nMODULE_AUTHOR(\"Harald Geyer <harald@ccbib.org>\");\nMODULE_DESCRIPTION(\"DHT11 humidity/temperature sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}