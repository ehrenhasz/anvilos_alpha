{
  "module_name": "hdc100x.c",
  "hash_id": "cba7e66cee7b12ed00fc1919b22a45381e6af7f98a0032bb60c46028edc79b59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/hdc100x.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <linux/time.h>\n\n#define HDC100X_REG_TEMP\t\t\t0x00\n#define HDC100X_REG_HUMIDITY\t\t\t0x01\n\n#define HDC100X_REG_CONFIG\t\t\t0x02\n#define HDC100X_REG_CONFIG_ACQ_MODE\t\tBIT(12)\n#define HDC100X_REG_CONFIG_HEATER_EN\t\tBIT(13)\n\nstruct hdc100x_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu16 config;\n\n\t \n\tint adc_int_us[2];\n\t \n\tstruct {\n\t\t__be16 channels[2];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\n \nstatic const int hdc100x_int_time[][3] = {\n\t{ 6350, 3650, 0 },\t \n\t{ 6500, 3850, 2500 },\t \n};\n\n \nstatic const struct {\n\tint shift;\n\tint mask;\n} hdc100x_resolution_shift[2] = {\n\t{  \n\t\t.shift = 10,\n\t\t.mask = 1\n\t},\n\t{  \n\t\t.shift = 8,\n\t\t.mask = 3,\n\t},\n};\n\nstatic IIO_CONST_ATTR(temp_integration_time_available,\n\t\t\"0.00365 0.00635\");\n\nstatic IIO_CONST_ATTR(humidityrelative_integration_time_available,\n\t\t\"0.0025 0.00385 0.0065\");\n\nstatic IIO_CONST_ATTR(out_current_heater_raw_available,\n\t\t\"0 1\");\n\nstatic struct attribute *hdc100x_attributes[] = {\n\t&iio_const_attr_temp_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_humidityrelative_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_out_current_heater_raw_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hdc100x_attribute_group = {\n\t.attrs = hdc100x_attributes,\n};\n\nstatic const struct iio_chan_spec hdc100x_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = HDC100X_REG_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.address = HDC100X_REG_HUMIDITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.extend_name = \"heater\",\n\t\t.output = 1,\n\t\t.scan_index = -1,\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic const unsigned long hdc100x_scan_masks[] = {0x3, 0};\n\nstatic int hdc100x_update_config(struct hdc100x_data *data, int mask, int val)\n{\n\tint tmp = (~mask & data->config) | val;\n\tint ret;\n\n\tret = i2c_smbus_write_word_swapped(data->client,\n\t\t\t\t\t\tHDC100X_REG_CONFIG, tmp);\n\tif (!ret)\n\t\tdata->config = tmp;\n\n\treturn ret;\n}\n\nstatic int hdc100x_set_it_time(struct hdc100x_data *data, int chan, int val2)\n{\n\tint shift = hdc100x_resolution_shift[chan].shift;\n\tint ret = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdc100x_int_time[chan]); i++) {\n\t\tif (val2 && val2 == hdc100x_int_time[chan][i]) {\n\t\t\tret = hdc100x_update_config(data,\n\t\t\t\thdc100x_resolution_shift[chan].mask << shift,\n\t\t\t\ti << shift);\n\t\t\tif (!ret)\n\t\t\t\tdata->adc_int_us[chan] = val2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int hdc100x_get_measurement(struct hdc100x_data *data,\n\t\t\t\t   struct iio_chan_spec const *chan)\n{\n\tstruct i2c_client *client = data->client;\n\tint delay = data->adc_int_us[chan->address] + 1*USEC_PER_MSEC;\n\tint ret;\n\t__be16 val;\n\n\t \n\tret = i2c_smbus_write_byte(client, chan->address);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot start measurement\");\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(delay, delay + 1000);\n\n\t \n\tret = i2c_master_recv(data->client, (char *)&val, sizeof(val));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot read sensor data\\n\");\n\t\treturn ret;\n\t}\n\treturn be16_to_cpu(val);\n}\n\nstatic int hdc100x_get_heater_status(struct hdc100x_data *data)\n{\n\treturn !!(data->config & HDC100X_REG_CONFIG_HEATER_EN);\n}\n\nstatic int hdc100x_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct hdc100x_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tif (chan->type == IIO_CURRENT) {\n\t\t\t*val = hdc100x_get_heater_status(data);\n\t\t\tret = IIO_VAL_INT;\n\t\t} else {\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = hdc100x_get_measurement(data, chan);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tif (ret >= 0) {\n\t\t\t\t*val = ret;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = data->adc_int_us[chan->address];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t*val = 165000;\n\t\t\t*val2 = 65536;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t} else {\n\t\t\t*val = 100000;\n\t\t\t*val2 = 65536;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -15887;\n\t\t*val2 = 515151;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hdc100x_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct hdc100x_data *data = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = hdc100x_set_it_time(data, chan->address, val2);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_CURRENT || val2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = hdc100x_update_config(data, HDC100X_REG_CONFIG_HEATER_EN,\n\t\t\t\t\tval ? HDC100X_REG_CONFIG_HEATER_EN : 0);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hdc100x_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct hdc100x_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tmutex_lock(&data->lock);\n\tret = hdc100x_update_config(data, HDC100X_REG_CONFIG_ACQ_MODE,\n\t\t\t\t    HDC100X_REG_CONFIG_ACQ_MODE);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int hdc100x_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct hdc100x_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = hdc100x_update_config(data, HDC100X_REG_CONFIG_ACQ_MODE, 0);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops hdc_buffer_setup_ops = {\n\t.postenable  = hdc100x_buffer_postenable,\n\t.predisable  = hdc100x_buffer_predisable,\n};\n\nstatic irqreturn_t hdc100x_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct hdc100x_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\tint delay = data->adc_int_us[0] + data->adc_int_us[1] + 2*USEC_PER_MSEC;\n\tint ret;\n\n\t \n\tmutex_lock(&data->lock);\n\tret = i2c_smbus_write_byte(client, HDC100X_REG_TEMP);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot start measurement\\n\");\n\t\tgoto err;\n\t}\n\tusleep_range(delay, delay + 1000);\n\n\tret = i2c_master_recv(client, (u8 *)data->scan.channels, 4);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot read sensor data\\n\");\n\t\tgoto err;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nerr:\n\tmutex_unlock(&data->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info hdc100x_info = {\n\t.read_raw = hdc100x_read_raw,\n\t.write_raw = hdc100x_write_raw,\n\t.attrs = &hdc100x_attribute_group,\n};\n\nstatic int hdc100x_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct hdc100x_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &hdc100x_info;\n\n\tindio_dev->channels = hdc100x_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(hdc100x_channels);\n\tindio_dev->available_scan_masks = hdc100x_scan_masks;\n\n\t \n\thdc100x_set_it_time(data, 0, hdc100x_int_time[0][0]);\n\thdc100x_set_it_time(data, 1, hdc100x_int_time[1][0]);\n\thdc100x_update_config(data, HDC100X_REG_CONFIG_ACQ_MODE, 0);\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev,\n\t\t\t\t\t indio_dev, NULL,\n\t\t\t\t\t hdc100x_trigger_handler,\n\t\t\t\t\t &hdc_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id hdc100x_id[] = {\n\t{ \"hdc100x\", 0 },\n\t{ \"hdc1000\", 0 },\n\t{ \"hdc1008\", 0 },\n\t{ \"hdc1010\", 0 },\n\t{ \"hdc1050\", 0 },\n\t{ \"hdc1080\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, hdc100x_id);\n\nstatic const struct of_device_id hdc100x_dt_ids[] = {\n\t{ .compatible = \"ti,hdc1000\" },\n\t{ .compatible = \"ti,hdc1008\" },\n\t{ .compatible = \"ti,hdc1010\" },\n\t{ .compatible = \"ti,hdc1050\" },\n\t{ .compatible = \"ti,hdc1080\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hdc100x_dt_ids);\n\nstatic const struct acpi_device_id hdc100x_acpi_match[] = {\n\t{ \"TXNW1010\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, hdc100x_acpi_match);\n\nstatic struct i2c_driver hdc100x_driver = {\n\t.driver = {\n\t\t.name\t= \"hdc100x\",\n\t\t.of_match_table = hdc100x_dt_ids,\n\t\t.acpi_match_table = hdc100x_acpi_match,\n\t},\n\t.probe = hdc100x_probe,\n\t.id_table = hdc100x_id,\n};\nmodule_i2c_driver(hdc100x_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"TI HDC100x humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}