{
  "module_name": "si7020.c",
  "hash_id": "6dfdcaddfdaad3db634f71ef383d4cc584c97a0698ea407b015319e89cbc56a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/si7020.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define SI7020CMD_RH_HOLD\t0xE5\n \n#define SI7020CMD_TEMP_HOLD\t0xE3\n \n#define SI7020CMD_RESET\t\t0xFE\n\nstatic int si7020_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct i2c_client **client = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_swapped(*client,\n\t\t\t\t\t\t  chan->type == IIO_TEMP ?\n\t\t\t\t\t\t  SI7020CMD_TEMP_HOLD :\n\t\t\t\t\t\t  SI7020CMD_RH_HOLD);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret >> 2;\n\t\t \n\t\tif (chan->type == IIO_HUMIDITYRELATIVE)\n\t\t\t*val = clamp_val(*val, 786, 13893);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val = 175720;  \n\t\telse\n\t\t\t*val = 125 * 1000;\n\t\t*val2 = 65536 >> 2;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val = -4368;  \n\t\telse\n\t\t\t*val = -786;  \n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec si7020_channels[] = {\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t}\n};\n\nstatic const struct iio_info si7020_info = {\n\t.read_raw = si7020_read_raw,\n};\n\nstatic int si7020_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct i2c_client **data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tret = i2c_smbus_write_byte(client, SI7020CMD_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tmsleep(15);\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\t*data = client;\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &si7020_info;\n\tindio_dev->channels = si7020_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(si7020_channels);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id si7020_id[] = {\n\t{ \"si7020\", 0 },\n\t{ \"th06\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si7020_id);\n\nstatic const struct of_device_id si7020_dt_ids[] = {\n\t{ .compatible = \"silabs,si7020\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, si7020_dt_ids);\n\nstatic struct i2c_driver si7020_driver = {\n\t.driver = {\n\t\t.name = \"si7020\",\n\t\t.of_match_table = si7020_dt_ids,\n\t},\n\t.probe\t\t= si7020_probe,\n\t.id_table\t= si7020_id,\n};\n\nmodule_i2c_driver(si7020_driver);\nMODULE_DESCRIPTION(\"Silicon Labs Si7013/20/21 Relative Humidity and Temperature Sensors\");\nMODULE_AUTHOR(\"David Barksdale <dbarksdale@uplogix.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}