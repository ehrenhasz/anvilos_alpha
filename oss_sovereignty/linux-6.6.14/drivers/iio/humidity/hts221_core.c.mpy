{
  "module_name": "hts221_core.c",
  "hash_id": "4c744772b488e884c9d1d2af8a470bc3405beef9b3d354bd5f3342cd8838316f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/hts221_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/iio/sysfs.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/bitfield.h>\n\n#include \"hts221.h\"\n\n#define HTS221_REG_WHOAMI_ADDR\t\t0x0f\n#define HTS221_REG_WHOAMI_VAL\t\t0xbc\n\n#define HTS221_REG_CNTRL1_ADDR\t\t0x20\n#define HTS221_REG_CNTRL2_ADDR\t\t0x21\n\n#define HTS221_ODR_MASK\t\t\t0x03\n#define HTS221_BDU_MASK\t\t\tBIT(2)\n#define HTS221_ENABLE_MASK\t\tBIT(7)\n\n \n#define HTS221_REG_0RH_CAL_X_H\t\t0x36\n#define HTS221_REG_1RH_CAL_X_H\t\t0x3a\n#define HTS221_REG_0RH_CAL_Y_H\t\t0x30\n#define HTS221_REG_1RH_CAL_Y_H\t\t0x31\n#define HTS221_REG_0T_CAL_X_L\t\t0x3c\n#define HTS221_REG_1T_CAL_X_L\t\t0x3e\n#define HTS221_REG_0T_CAL_Y_H\t\t0x32\n#define HTS221_REG_1T_CAL_Y_H\t\t0x33\n#define HTS221_REG_T1_T0_CAL_Y_H\t0x35\n\nstruct hts221_odr {\n\tu8 hz;\n\tu8 val;\n};\n\n#define HTS221_AVG_DEPTH\t\t8\nstruct hts221_avg {\n\tu8 addr;\n\tu8 mask;\n\tu16 avg_avl[HTS221_AVG_DEPTH];\n};\n\nstatic const struct hts221_odr hts221_odr_table[] = {\n\t{  1, 0x01 },\t \n\t{  7, 0x02 },\t \n\t{ 13, 0x03 },\t \n};\n\nstatic const struct hts221_avg hts221_avg_list[] = {\n\t{\n\t\t.addr = 0x10,\n\t\t.mask = 0x07,\n\t\t.avg_avl = {\n\t\t\t4,  \n\t\t\t8,  \n\t\t\t16,  \n\t\t\t32,  \n\t\t\t64,  \n\t\t\t128,  \n\t\t\t256,  \n\t\t\t512,  \n\t\t},\n\t},\n\t{\n\t\t.addr = 0x10,\n\t\t.mask = 0x38,\n\t\t.avg_avl = {\n\t\t\t2,  \n\t\t\t4,  \n\t\t\t8,  \n\t\t\t16,  \n\t\t\t32,  \n\t\t\t64,  \n\t\t\t128,  \n\t\t\t256,  \n\t\t},\n\t},\n};\n\nstatic const struct iio_chan_spec hts221_channels[] = {\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.address = 0x28,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = 0x2a,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic int hts221_check_whoami(struct hts221_hw *hw)\n{\n\tint err, data;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_WHOAMI_ADDR, &data);\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to read whoami register\\n\");\n\t\treturn err;\n\t}\n\n\tif (data != HTS221_REG_WHOAMI_VAL) {\n\t\tdev_err(hw->dev, \"wrong whoami {%02x vs %02x}\\n\",\n\t\t\tdata, HTS221_REG_WHOAMI_VAL);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int hts221_update_odr(struct hts221_hw *hw, u8 odr)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(hts221_odr_table); i++)\n\t\tif (hts221_odr_table[i].hz == odr)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(hts221_odr_table))\n\t\treturn -EINVAL;\n\n\terr = regmap_update_bits(hw->regmap, HTS221_REG_CNTRL1_ADDR,\n\t\t\t\t HTS221_ODR_MASK,\n\t\t\t\t FIELD_PREP(HTS221_ODR_MASK,\n\t\t\t\t\t    hts221_odr_table[i].val));\n\tif (err < 0)\n\t\treturn err;\n\n\thw->odr = odr;\n\n\treturn 0;\n}\n\nstatic int hts221_update_avg(struct hts221_hw *hw,\n\t\t\t     enum hts221_sensor_type type,\n\t\t\t     u16 val)\n{\n\tconst struct hts221_avg *avg = &hts221_avg_list[type];\n\tint i, err, data;\n\n\tfor (i = 0; i < HTS221_AVG_DEPTH; i++)\n\t\tif (avg->avg_avl[i] == val)\n\t\t\tbreak;\n\n\tif (i == HTS221_AVG_DEPTH)\n\t\treturn -EINVAL;\n\n\tdata = ((i << __ffs(avg->mask)) & avg->mask);\n\terr = regmap_update_bits(hw->regmap, avg->addr,\n\t\t\t\t avg->mask, data);\n\tif (err < 0)\n\t\treturn err;\n\n\thw->sensors[type].cur_avg_idx = i;\n\n\treturn 0;\n}\n\nstatic ssize_t hts221_sysfs_sampling_freq(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tint i;\n\tssize_t len = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(hts221_odr_table); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \",\n\t\t\t\t hts221_odr_table[i].hz);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t\nhts221_sysfs_rh_oversampling_avail(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tconst struct hts221_avg *avg = &hts221_avg_list[HTS221_SENSOR_H];\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(avg->avg_avl); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \",\n\t\t\t\t avg->avg_avl[i]);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t\nhts221_sysfs_temp_oversampling_avail(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tconst struct hts221_avg *avg = &hts221_avg_list[HTS221_SENSOR_T];\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(avg->avg_avl); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \",\n\t\t\t\t avg->avg_avl[i]);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nint hts221_set_enable(struct hts221_hw *hw, bool enable)\n{\n\tint err;\n\n\terr = regmap_update_bits(hw->regmap, HTS221_REG_CNTRL1_ADDR,\n\t\t\t\t HTS221_ENABLE_MASK,\n\t\t\t\t FIELD_PREP(HTS221_ENABLE_MASK, enable));\n\tif (err < 0)\n\t\treturn err;\n\n\thw->enabled = enable;\n\n\treturn 0;\n}\n\nstatic int hts221_parse_temp_caldata(struct hts221_hw *hw)\n{\n\tint err, *slope, *b_gen, cal0, cal1;\n\ts16 cal_x0, cal_x1, cal_y0, cal_y1;\n\t__le16 val;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_0T_CAL_Y_H, &cal0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_T1_T0_CAL_Y_H, &cal1);\n\tif (err < 0)\n\t\treturn err;\n\tcal_y0 = ((cal1 & 0x3) << 8) | cal0;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_1T_CAL_Y_H, &cal0);\n\tif (err < 0)\n\t\treturn err;\n\tcal_y1 = (((cal1 & 0xc) >> 2) << 8) | cal0;\n\n\terr = regmap_bulk_read(hw->regmap, HTS221_REG_0T_CAL_X_L,\n\t\t\t       &val, sizeof(val));\n\tif (err < 0)\n\t\treturn err;\n\tcal_x0 = le16_to_cpu(val);\n\n\terr = regmap_bulk_read(hw->regmap, HTS221_REG_1T_CAL_X_L,\n\t\t\t       &val, sizeof(val));\n\tif (err < 0)\n\t\treturn err;\n\tcal_x1 = le16_to_cpu(val);\n\n\tslope = &hw->sensors[HTS221_SENSOR_T].slope;\n\tb_gen = &hw->sensors[HTS221_SENSOR_T].b_gen;\n\n\t*slope = ((cal_y1 - cal_y0) * 8000) / (cal_x1 - cal_x0);\n\t*b_gen = (((s32)cal_x1 * cal_y0 - (s32)cal_x0 * cal_y1) * 1000) /\n\t\t (cal_x1 - cal_x0);\n\t*b_gen *= 8;\n\n\treturn 0;\n}\n\nstatic int hts221_parse_rh_caldata(struct hts221_hw *hw)\n{\n\tint err, *slope, *b_gen, data;\n\ts16 cal_x0, cal_x1, cal_y0, cal_y1;\n\t__le16 val;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_0RH_CAL_Y_H, &data);\n\tif (err < 0)\n\t\treturn err;\n\tcal_y0 = data;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_1RH_CAL_Y_H, &data);\n\tif (err < 0)\n\t\treturn err;\n\tcal_y1 = data;\n\n\terr = regmap_bulk_read(hw->regmap, HTS221_REG_0RH_CAL_X_H,\n\t\t\t       &val, sizeof(val));\n\tif (err < 0)\n\t\treturn err;\n\tcal_x0 = le16_to_cpu(val);\n\n\terr = regmap_bulk_read(hw->regmap, HTS221_REG_1RH_CAL_X_H,\n\t\t\t       &val, sizeof(val));\n\tif (err < 0)\n\t\treturn err;\n\tcal_x1 = le16_to_cpu(val);\n\n\tslope = &hw->sensors[HTS221_SENSOR_H].slope;\n\tb_gen = &hw->sensors[HTS221_SENSOR_H].b_gen;\n\n\t*slope = ((cal_y1 - cal_y0) * 8000) / (cal_x1 - cal_x0);\n\t*b_gen = (((s32)cal_x1 * cal_y0 - (s32)cal_x0 * cal_y1) * 1000) /\n\t\t (cal_x1 - cal_x0);\n\t*b_gen *= 8;\n\n\treturn 0;\n}\n\nstatic int hts221_get_sensor_scale(struct hts221_hw *hw,\n\t\t\t\t   enum iio_chan_type ch_type,\n\t\t\t\t   int *val, int *val2)\n{\n\ts64 tmp;\n\ts32 rem, div, data;\n\n\tswitch (ch_type) {\n\tcase IIO_HUMIDITYRELATIVE:\n\t\tdata = hw->sensors[HTS221_SENSOR_H].slope;\n\t\tdiv = (1 << 4) * 1000;\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\tdata = hw->sensors[HTS221_SENSOR_T].slope;\n\t\tdiv = (1 << 6) * 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = div_s64(data * 1000000000LL, div);\n\ttmp = div_s64_rem(tmp, 1000000000LL, &rem);\n\n\t*val = tmp;\n\t*val2 = rem;\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int hts221_get_sensor_offset(struct hts221_hw *hw,\n\t\t\t\t    enum iio_chan_type ch_type,\n\t\t\t\t    int *val, int *val2)\n{\n\ts64 tmp;\n\ts32 rem, div, data;\n\n\tswitch (ch_type) {\n\tcase IIO_HUMIDITYRELATIVE:\n\t\tdata = hw->sensors[HTS221_SENSOR_H].b_gen;\n\t\tdiv = hw->sensors[HTS221_SENSOR_H].slope;\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\tdata = hw->sensors[HTS221_SENSOR_T].b_gen;\n\t\tdiv = hw->sensors[HTS221_SENSOR_T].slope;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = div_s64(data * 1000000000LL, div);\n\ttmp = div_s64_rem(tmp, 1000000000LL, &rem);\n\n\t*val = tmp;\n\t*val2 = rem;\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int hts221_read_oneshot(struct hts221_hw *hw, u8 addr, int *val)\n{\n\t__le16 data;\n\tint err;\n\n\terr = hts221_set_enable(hw, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(50);\n\n\terr = regmap_bulk_read(hw->regmap, addr, &data, sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\thts221_set_enable(hw, false);\n\n\t*val = (s16)le16_to_cpu(data);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int hts221_read_raw(struct iio_dev *iio_dev,\n\t\t\t   struct iio_chan_spec const *ch,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = hts221_read_oneshot(hw, ch->address, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = hts221_get_sensor_scale(hw, ch->type, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = hts221_get_sensor_offset(hw, ch->type, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = hw->odr;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO: {\n\t\tu8 idx;\n\t\tconst struct hts221_avg *avg;\n\n\t\tswitch (ch->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tavg = &hts221_avg_list[HTS221_SENSOR_H];\n\t\t\tidx = hw->sensors[HTS221_SENSOR_H].cur_avg_idx;\n\t\t\t*val = avg->avg_avl[idx];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tavg = &hts221_avg_list[HTS221_SENSOR_T];\n\t\t\tidx = hw->sensors[HTS221_SENSOR_T].cur_avg_idx;\n\t\t\t*val = avg->avg_avl[idx];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn ret;\n}\n\nstatic int hts221_write_raw(struct iio_dev *iio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = hts221_update_odr(hw, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tret = hts221_update_avg(hw, HTS221_SENSOR_H, val);\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = hts221_update_avg(hw, HTS221_SENSOR_T, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn ret;\n}\n\nstatic int hts221_validate_trigger(struct iio_dev *iio_dev,\n\t\t\t\t   struct iio_trigger *trig)\n{\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\n\treturn hw->trig == trig ? 0 : -EINVAL;\n}\n\nstatic IIO_DEVICE_ATTR(in_humidity_oversampling_ratio_available, S_IRUGO,\n\t\t       hts221_sysfs_rh_oversampling_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_temp_oversampling_ratio_available, S_IRUGO,\n\t\t       hts221_sysfs_temp_oversampling_avail, NULL, 0);\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(hts221_sysfs_sampling_freq);\n\nstatic struct attribute *hts221_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_humidity_oversampling_ratio_available.dev_attr.attr,\n\t&iio_dev_attr_in_temp_oversampling_ratio_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hts221_attribute_group = {\n\t.attrs = hts221_attributes,\n};\n\nstatic const struct iio_info hts221_info = {\n\t.attrs = &hts221_attribute_group,\n\t.read_raw = hts221_read_raw,\n\t.write_raw = hts221_write_raw,\n\t.validate_trigger = hts221_validate_trigger,\n};\n\nstatic const unsigned long hts221_scan_masks[] = {0x3, 0x0};\n\nstatic int hts221_init_regulators(struct device *dev)\n{\n\tint err;\n\n\terr = devm_regulator_get_enable(dev, \"vdd\");\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to get vdd regulator\\n\");\n\n\tmsleep(50);\n\n\treturn 0;\n}\n\nint hts221_probe(struct device *dev, int irq, const char *name,\n\t\t struct regmap *regmap)\n{\n\tstruct iio_dev *iio_dev;\n\tstruct hts221_hw *hw;\n\tint err;\n\tu8 data;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*hw));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, (void *)iio_dev);\n\n\thw = iio_priv(iio_dev);\n\thw->name = name;\n\thw->dev = dev;\n\thw->irq = irq;\n\thw->regmap = regmap;\n\n\terr = hts221_init_regulators(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = hts221_check_whoami(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->available_scan_masks = hts221_scan_masks;\n\tiio_dev->channels = hts221_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(hts221_channels);\n\tiio_dev->name = HTS221_DEV_NAME;\n\tiio_dev->info = &hts221_info;\n\n\t \n\terr = regmap_update_bits(hw->regmap, HTS221_REG_CNTRL1_ADDR,\n\t\t\t\t HTS221_BDU_MASK,\n\t\t\t\t FIELD_PREP(HTS221_BDU_MASK, 1));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = hts221_update_odr(hw, hts221_odr_table[0].hz);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = hts221_parse_rh_caldata(hw);\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to get rh calibration data\\n\");\n\t\treturn err;\n\t}\n\n\tdata = hts221_avg_list[HTS221_SENSOR_H].avg_avl[3];\n\terr = hts221_update_avg(hw, HTS221_SENSOR_H, data);\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to set rh oversampling ratio\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = hts221_parse_temp_caldata(hw);\n\tif (err < 0) {\n\t\tdev_err(hw->dev,\n\t\t\t\"failed to get temperature calibration data\\n\");\n\t\treturn err;\n\t}\n\n\tdata = hts221_avg_list[HTS221_SENSOR_T].avg_avl[3];\n\terr = hts221_update_avg(hw, HTS221_SENSOR_T, data);\n\tif (err < 0) {\n\t\tdev_err(hw->dev,\n\t\t\t\"failed to set temperature oversampling ratio\\n\");\n\t\treturn err;\n\t}\n\n\tif (hw->irq > 0) {\n\t\terr = hts221_allocate_buffers(iio_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hts221_allocate_trigger(iio_dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(hw->dev, iio_dev);\n}\nEXPORT_SYMBOL_NS(hts221_probe, IIO_HTS221);\n\nstatic int hts221_suspend(struct device *dev)\n{\n\tstruct iio_dev *iio_dev = dev_get_drvdata(dev);\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\n\treturn regmap_update_bits(hw->regmap, HTS221_REG_CNTRL1_ADDR,\n\t\t\t\t  HTS221_ENABLE_MASK,\n\t\t\t\t  FIELD_PREP(HTS221_ENABLE_MASK, false));\n}\n\nstatic int hts221_resume(struct device *dev)\n{\n\tstruct iio_dev *iio_dev = dev_get_drvdata(dev);\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\tint err = 0;\n\n\tif (hw->enabled)\n\t\terr = regmap_update_bits(hw->regmap, HTS221_REG_CNTRL1_ADDR,\n\t\t\t\t\t HTS221_ENABLE_MASK,\n\t\t\t\t\t FIELD_PREP(HTS221_ENABLE_MASK,\n\t\t\t\t\t\t    true));\n\treturn err;\n}\n\nEXPORT_NS_SIMPLE_DEV_PM_OPS(hts221_pm_ops, hts221_suspend, hts221_resume,\n\t\t\t    IIO_HTS221);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo.bianconi@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics hts221 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}