{
  "module_name": "hdc2010.c",
  "hash_id": "84396de61aea5bd31d7cd3c62e488fc65fe5ebce48020ca984da09cd94bf245d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/hdc2010.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define HDC2010_REG_TEMP_LOW\t\t\t0x00\n#define HDC2010_REG_TEMP_HIGH\t\t\t0x01\n#define HDC2010_REG_HUMIDITY_LOW\t\t0x02\n#define HDC2010_REG_HUMIDITY_HIGH\t\t0x03\n#define HDC2010_REG_INTERRUPT_DRDY\t\t0x04\n#define HDC2010_REG_TEMP_MAX\t\t\t0x05\n#define HDC2010_REG_HUMIDITY_MAX\t\t0x06\n#define HDC2010_REG_INTERRUPT_EN\t\t0x07\n#define HDC2010_REG_TEMP_OFFSET_ADJ\t\t0x08\n#define HDC2010_REG_HUMIDITY_OFFSET_ADJ\t\t0x09\n#define HDC2010_REG_TEMP_THR_L\t\t\t0x0a\n#define HDC2010_REG_TEMP_THR_H\t\t\t0x0b\n#define HDC2010_REG_RH_THR_L\t\t\t0x0c\n#define HDC2010_REG_RH_THR_H\t\t\t0x0d\n#define HDC2010_REG_RESET_DRDY_INT_CONF\t\t0x0e\n#define HDC2010_REG_MEASUREMENT_CONF\t\t0x0f\n\n#define HDC2010_MEAS_CONF\t\t\tGENMASK(2, 1)\n#define HDC2010_MEAS_TRIG\t\t\tBIT(0)\n#define HDC2010_HEATER_EN\t\t\tBIT(3)\n#define HDC2010_AMM\t\t\t\tGENMASK(6, 4)\n\nstruct hdc2010_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 measurement_config;\n\tu8 interrupt_config;\n\tu8 drdy_config;\n};\n\nenum hdc2010_addr_groups {\n\tHDC2010_GROUP_TEMP = 0,\n\tHDC2010_GROUP_HUMIDITY,\n};\n\nstruct hdc2010_reg_record {\n\tunsigned long primary;\n\tunsigned long peak;\n};\n\nstatic const struct hdc2010_reg_record hdc2010_reg_translation[] = {\n\t[HDC2010_GROUP_TEMP] = {\n\t\t.primary = HDC2010_REG_TEMP_LOW,\n\t\t.peak = HDC2010_REG_TEMP_MAX,\n\t},\n\t[HDC2010_GROUP_HUMIDITY] = {\n\t\t.primary = HDC2010_REG_HUMIDITY_LOW,\n\t\t.peak = HDC2010_REG_HUMIDITY_MAX,\n\t},\n};\n\nstatic IIO_CONST_ATTR(out_current_heater_raw_available, \"0 1\");\n\nstatic struct attribute *hdc2010_attributes[] = {\n\t&iio_const_attr_out_current_heater_raw_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hdc2010_attribute_group = {\n\t.attrs = hdc2010_attributes,\n};\n\nstatic const struct iio_chan_spec hdc2010_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = HDC2010_GROUP_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_PEAK) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.address = HDC2010_GROUP_HUMIDITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_PEAK) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.extend_name = \"heater\",\n\t\t.output = 1,\n\t},\n};\n\nstatic int hdc2010_update_drdy_config(struct hdc2010_data *data,\n\t\t\t\t\t     char mask, char val)\n{\n\tu8 tmp = (~mask & data->drdy_config) | val;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tHDC2010_REG_RESET_DRDY_INT_CONF, tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->drdy_config = tmp;\n\n\treturn 0;\n}\n\nstatic int hdc2010_get_prim_measurement_word(struct hdc2010_data *data,\n\t\t\t\t\t     struct iio_chan_spec const *chan)\n{\n\tstruct i2c_client *client = data->client;\n\ts32 ret;\n\n\tret = i2c_smbus_read_word_data(client,\n\t\t\thdc2010_reg_translation[chan->address].primary);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Could not read sensor measurement word\\n\");\n\n\treturn ret;\n}\n\nstatic int hdc2010_get_peak_measurement_byte(struct hdc2010_data *data,\n\t\t\t\t\t     struct iio_chan_spec const *chan)\n{\n\tstruct i2c_client *client = data->client;\n\ts32 ret;\n\n\tret = i2c_smbus_read_byte_data(client,\n\t\t\thdc2010_reg_translation[chan->address].peak);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Could not read sensor measurement byte\\n\");\n\n\treturn ret;\n}\n\nstatic int hdc2010_get_heater_status(struct hdc2010_data *data)\n{\n\treturn !!(data->drdy_config & HDC2010_HEATER_EN);\n}\n\nstatic int hdc2010_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct hdc2010_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\n\t\tif (chan->type == IIO_CURRENT) {\n\t\t\t*val = hdc2010_get_heater_status(data);\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&data->lock);\n\t\tret = hdc2010_get_prim_measurement_word(data, chan);\n\t\tmutex_unlock(&data->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\t}\n\tcase IIO_CHAN_INFO_PEAK: {\n\t\tint ret;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&data->lock);\n\t\tret = hdc2010_get_peak_measurement_byte(data, chan);\n\t\tmutex_unlock(&data->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = ret * 256;\n\t\treturn IIO_VAL_INT;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val2 = 65536;\n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val = 165000;\n\t\telse\n\t\t\t*val = 100000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -15887;\n\t\t*val2 = 515151;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hdc2010_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct hdc2010_data *data = iio_priv(indio_dev);\n\tint new, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_CURRENT || val2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (val) {\n\t\tcase 1:\n\t\t\tnew = HDC2010_HEATER_EN;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnew = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_lock(&data->lock);\n\t\tret = hdc2010_update_drdy_config(data, HDC2010_HEATER_EN, new);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info hdc2010_info = {\n\t.read_raw = hdc2010_read_raw,\n\t.write_raw = hdc2010_write_raw,\n\t.attrs = &hdc2010_attribute_group,\n};\n\nstatic int hdc2010_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct hdc2010_data *data;\n\tu8 tmp;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t    I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\t \n\tindio_dev->name = \"hdc2010\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &hdc2010_info;\n\n\tindio_dev->channels = hdc2010_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(hdc2010_channels);\n\n\t \n\tret = hdc2010_update_drdy_config(data, HDC2010_AMM, HDC2010_AMM);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttmp = (data->measurement_config & ~HDC2010_MEAS_CONF) |\n\t\tHDC2010_MEAS_TRIG;\n\n\tret = i2c_smbus_write_byte_data(client, HDC2010_REG_MEASUREMENT_CONF, tmp);\n\tif (ret) {\n\t\tdev_warn(&client->dev, \"Unable to set up measurement\\n\");\n\t\tif (hdc2010_update_drdy_config(data, HDC2010_AMM, 0))\n\t\t\tdev_warn(&client->dev, \"Unable to restore default AMM\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->measurement_config = tmp;\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic void hdc2010_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct hdc2010_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\t \n\tif (hdc2010_update_drdy_config(data, HDC2010_AMM, 0))\n\t\tdev_warn(&client->dev, \"Unable to restore default AMM\\n\");\n}\n\nstatic const struct i2c_device_id hdc2010_id[] = {\n\t{ \"hdc2010\" },\n\t{ \"hdc2080\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, hdc2010_id);\n\nstatic const struct of_device_id hdc2010_dt_ids[] = {\n\t{ .compatible = \"ti,hdc2010\" },\n\t{ .compatible = \"ti,hdc2080\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hdc2010_dt_ids);\n\nstatic struct i2c_driver hdc2010_driver = {\n\t.driver = {\n\t\t.name\t= \"hdc2010\",\n\t\t.of_match_table = hdc2010_dt_ids,\n\t},\n\t.probe = hdc2010_probe,\n\t.remove = hdc2010_remove,\n\t.id_table = hdc2010_id,\n};\nmodule_i2c_driver(hdc2010_driver);\n\nMODULE_AUTHOR(\"Eugene Zaikonnikov <ez@norphonic.com>\");\nMODULE_DESCRIPTION(\"TI HDC2010 humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}