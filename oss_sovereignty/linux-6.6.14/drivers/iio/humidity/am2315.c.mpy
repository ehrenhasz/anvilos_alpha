{
  "module_name": "am2315.c",
  "hash_id": "5f34a17b78dc51b3ba50ad31b1f40fc0f926f548a043887157fcd30c2d00b0ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/am2315.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define AM2315_REG_HUM_MSB\t\t\t0x00\n#define AM2315_REG_HUM_LSB\t\t\t0x01\n#define AM2315_REG_TEMP_MSB\t\t\t0x02\n#define AM2315_REG_TEMP_LSB\t\t\t0x03\n\n#define AM2315_FUNCTION_READ\t\t\t0x03\n#define AM2315_HUM_OFFSET\t\t\t2\n#define AM2315_TEMP_OFFSET\t\t\t4\n#define AM2315_ALL_CHANNEL_MASK\t\t\tGENMASK(1, 0)\n\n#define AM2315_DRIVER_NAME\t\t\t\"am2315\"\n\nstruct am2315_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\t \n\tstruct {\n\t\ts16 chans[2];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\nstruct am2315_sensor_data {\n\ts16 hum_data;\n\ts16 temp_data;\n};\n\nstatic const struct iio_chan_spec am2315_channels[] = {\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\n \nstatic u16 am2315_crc(u8 *data, u8 nr_bytes)\n{\n\tint i;\n\tu16 crc = 0xffff;\n\n\twhile (nr_bytes--) {\n\t\tcrc ^= *data++;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (crc & 0x01) {\n\t\t\t\tcrc >>= 1;\n\t\t\t\tcrc ^= 0xA001;\n\t\t\t} else {\n\t\t\t\tcrc >>= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn crc;\n}\n\n \nstatic void am2315_ping(struct i2c_client *client)\n{\n\ti2c_smbus_read_byte_data(client, AM2315_REG_HUM_MSB);\n}\n\nstatic int am2315_read_data(struct am2315_data *data,\n\t\t\t    struct am2315_sensor_data *sensor_data)\n{\n\tint ret;\n\t \n\tu8 tx_buf[3] = { AM2315_FUNCTION_READ, AM2315_REG_HUM_MSB, 4 };\n\t \n\tu8 rx_buf[8];\n\tu16 crc;\n\n\t \n\tam2315_ping(data->client);\n\n\tmutex_lock(&data->lock);\n\tret = i2c_master_send(data->client, tx_buf, sizeof(tx_buf));\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"failed to send read request\\n\");\n\t\tgoto exit_unlock;\n\t}\n\t \n\tusleep_range(2000, 3000);\n\t \n\tret = i2c_master_recv(data->client, rx_buf, sizeof(rx_buf));\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"failed to read sensor data\\n\");\n\t\tgoto exit_unlock;\n\t}\n\tmutex_unlock(&data->lock);\n\t \n\tcrc = am2315_crc(rx_buf, sizeof(rx_buf) - 2);\n\tif ((crc & 0xff) != rx_buf[6] || (crc >> 8) != rx_buf[7]) {\n\t\tdev_err(&data->client->dev, \"failed to verify sensor data\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsensor_data->hum_data = (rx_buf[AM2315_HUM_OFFSET] << 8) |\n\t\t\t\t rx_buf[AM2315_HUM_OFFSET + 1];\n\tsensor_data->temp_data = (rx_buf[AM2315_TEMP_OFFSET] << 8) |\n\t\t\t\t  rx_buf[AM2315_TEMP_OFFSET + 1];\n\n\treturn ret;\n\nexit_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic irqreturn_t am2315_trigger_handler(int irq, void *p)\n{\n\tint i;\n\tint ret;\n\tint bit;\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct am2315_data *data = iio_priv(indio_dev);\n\tstruct am2315_sensor_data sensor_data;\n\n\tret = am2315_read_data(data, &sensor_data);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmutex_lock(&data->lock);\n\tif (*(indio_dev->active_scan_mask) == AM2315_ALL_CHANNEL_MASK) {\n\t\tdata->scan.chans[0] = sensor_data.hum_data;\n\t\tdata->scan.chans[1] = sensor_data.temp_data;\n\t} else {\n\t\ti = 0;\n\t\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t\t indio_dev->masklength) {\n\t\t\tdata->scan.chans[i] = (bit ? sensor_data.temp_data :\n\t\t\t\t\t       sensor_data.hum_data);\n\t\t\ti++;\n\t\t}\n\t}\n\tmutex_unlock(&data->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int am2315_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct am2315_sensor_data sensor_data;\n\tstruct am2315_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = am2315_read_data(data, &sensor_data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (chan->type == IIO_HUMIDITYRELATIVE) ?\n\t\t\t\tsensor_data.hum_data : sensor_data.temp_data;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 100;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info am2315_info = {\n\t.read_raw\t\t= am2315_read_raw,\n};\n\nstatic int am2315_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct am2315_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &am2315_info;\n\tindio_dev->name = AM2315_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = am2315_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(am2315_channels);\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev,\n\t\t\t\t\tindio_dev, iio_pollfunc_store_time,\n\t\t\t\t\t am2315_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id am2315_i2c_id[] = {\n\t{\"am2315\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, am2315_i2c_id);\n\nstatic struct i2c_driver am2315_driver = {\n\t.driver = {\n\t\t.name = \"am2315\",\n\t},\n\t.probe =        am2315_probe,\n\t.id_table =         am2315_i2c_id,\n};\n\nmodule_i2c_driver(am2315_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"Aosong AM2315 relative humidity and temperature\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}