{
  "module_name": "si7005.c",
  "hash_id": "6188e03c75e8954b4eb7da538dee3c065994eaa0af490b131cc9c3ddd50c8dec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/si7005.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define SI7005_STATUS 0x00\n#define SI7005_DATA 0x01  \n#define SI7005_CONFIG 0x03\n#define SI7005_ID 0x11\n\n#define SI7005_STATUS_NRDY BIT(0)\n#define SI7005_CONFIG_TEMP BIT(4)\n#define SI7005_CONFIG_START BIT(0)\n\n#define SI7005_ID_7005 0x50\n#define SI7005_ID_7015 0xf0\n\nstruct si7005_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 config;\n};\n\nstatic int si7005_read_measurement(struct si7005_data *data, bool temp)\n{\n\tint tries = 50;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(data->client, SI7005_CONFIG,\n\t\tdata->config | SI7005_CONFIG_START |\n\t\t(temp ? SI7005_CONFIG_TEMP : 0));\n\tif (ret < 0)\n\t\tgoto done;\n\n\twhile (tries-- > 0) {\n\t\tmsleep(20);\n\t\tret = i2c_smbus_read_byte_data(data->client, SI7005_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (!(ret & SI7005_STATUS_NRDY))\n\t\t\tbreak;\n\t}\n\tif (tries < 0) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tret = i2c_smbus_read_word_swapped(data->client, SI7005_DATA);\n\ndone:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int si7005_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct si7005_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = si7005_read_measurement(data, chan->type == IIO_TEMP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t*val = 7;\n\t\t\t*val2 = 812500;\n\t\t} else {\n\t\t\t*val = 3;\n\t\t\t*val2 = 906250;\n\t\t}\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val = -50 * 32 * 4;\n\t\telse\n\t\t\t*val = -24 * 16 * 16;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec si7005_channels[] = {\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET),\n\t}\n};\n\nstatic const struct iio_info si7005_info = {\n\t.read_raw = si7005_read_raw,\n};\n\nstatic int si7005_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct si7005_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &si7005_info;\n\n\tindio_dev->channels = si7005_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(si7005_channels);\n\n\tret = i2c_smbus_read_byte_data(client, SI7005_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != SI7005_ID_7005 && ret != SI7005_ID_7015)\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_byte_data(client, SI7005_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->config = ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id si7005_id[] = {\n\t{ \"si7005\", 0 },\n\t{ \"th02\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si7005_id);\n\nstatic struct i2c_driver si7005_driver = {\n\t.driver = {\n\t\t.name\t= \"si7005\",\n\t},\n\t.probe = si7005_probe,\n\t.id_table = si7005_id,\n};\nmodule_i2c_driver(si7005_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Silabs Si7005 humidity and temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}