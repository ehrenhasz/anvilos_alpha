{
  "module_name": "hts221_buffer.c",
  "hash_id": "620959b3ccdc262c6f834663c7e2272d17c752eb99909708a9607f4360d1f507",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/humidity/hts221_buffer.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/buffer.h>\n\n#include <linux/platform_data/st_sensors_pdata.h>\n\n#include \"hts221.h\"\n\n#define HTS221_REG_DRDY_HL_ADDR\t\t0x22\n#define HTS221_REG_DRDY_HL_MASK\t\tBIT(7)\n#define HTS221_REG_DRDY_PP_OD_ADDR\t0x22\n#define HTS221_REG_DRDY_PP_OD_MASK\tBIT(6)\n#define HTS221_REG_DRDY_EN_ADDR\t\t0x22\n#define HTS221_REG_DRDY_EN_MASK\t\tBIT(2)\n#define HTS221_REG_STATUS_ADDR\t\t0x27\n#define HTS221_RH_DRDY_MASK\t\tBIT(1)\n#define HTS221_TEMP_DRDY_MASK\t\tBIT(0)\n\nstatic int hts221_trig_set_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *iio_dev = iio_trigger_get_drvdata(trig);\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\n\treturn regmap_update_bits(hw->regmap, HTS221_REG_DRDY_EN_ADDR,\n\t\t\t\t  HTS221_REG_DRDY_EN_MASK,\n\t\t\t\t  FIELD_PREP(HTS221_REG_DRDY_EN_MASK, state));\n}\n\nstatic const struct iio_trigger_ops hts221_trigger_ops = {\n\t.set_trigger_state = hts221_trig_set_state,\n};\n\nstatic irqreturn_t hts221_trigger_handler_thread(int irq, void *private)\n{\n\tstruct hts221_hw *hw = private;\n\tint err, status;\n\n\terr = regmap_read(hw->regmap, HTS221_REG_STATUS_ADDR, &status);\n\tif (err < 0)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (!(status & HTS221_RH_DRDY_MASK))\n\t\treturn IRQ_NONE;\n\n\tiio_trigger_poll_nested(hw->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nint hts221_allocate_trigger(struct iio_dev *iio_dev)\n{\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\tstruct st_sensors_platform_data *pdata = dev_get_platdata(hw->dev);\n\tbool irq_active_low = false, open_drain = false;\n\tunsigned long irq_type;\n\tint err;\n\n\tirq_type = irqd_get_trigger_type(irq_get_irq_data(hw->irq));\n\n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_HIGH:\n\tcase IRQF_TRIGGER_RISING:\n\t\tbreak;\n\tcase IRQF_TRIGGER_LOW:\n\tcase IRQF_TRIGGER_FALLING:\n\t\tirq_active_low = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(hw->dev,\n\t\t\t \"mode %lx unsupported, using IRQF_TRIGGER_RISING\\n\",\n\t\t\t irq_type);\n\t\tirq_type = IRQF_TRIGGER_RISING;\n\t\tbreak;\n\t}\n\n\terr = regmap_update_bits(hw->regmap, HTS221_REG_DRDY_HL_ADDR,\n\t\t\t\t HTS221_REG_DRDY_HL_MASK,\n\t\t\t\t FIELD_PREP(HTS221_REG_DRDY_HL_MASK,\n\t\t\t\t\t    irq_active_low));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (device_property_read_bool(hw->dev, \"drive-open-drain\") ||\n\t    (pdata && pdata->open_drain)) {\n\t\tirq_type |= IRQF_SHARED;\n\t\topen_drain = true;\n\t}\n\n\terr = regmap_update_bits(hw->regmap, HTS221_REG_DRDY_PP_OD_ADDR,\n\t\t\t\t HTS221_REG_DRDY_PP_OD_MASK,\n\t\t\t\t FIELD_PREP(HTS221_REG_DRDY_PP_OD_MASK,\n\t\t\t\t\t    open_drain));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(hw->dev, hw->irq, NULL,\n\t\t\t\t\thts221_trigger_handler_thread,\n\t\t\t\t\tirq_type | IRQF_ONESHOT,\n\t\t\t\t\thw->name, hw);\n\tif (err) {\n\t\tdev_err(hw->dev, \"failed to request trigger irq %d\\n\",\n\t\t\thw->irq);\n\t\treturn err;\n\t}\n\n\thw->trig = devm_iio_trigger_alloc(hw->dev, \"%s-trigger\",\n\t\t\t\t\t  iio_dev->name);\n\tif (!hw->trig)\n\t\treturn -ENOMEM;\n\n\tiio_trigger_set_drvdata(hw->trig, iio_dev);\n\thw->trig->ops = &hts221_trigger_ops;\n\n\terr = devm_iio_trigger_register(hw->dev, hw->trig);\n\n\tiio_dev->trig = iio_trigger_get(hw->trig);\n\n\treturn err;\n}\n\nstatic int hts221_buffer_preenable(struct iio_dev *iio_dev)\n{\n\treturn hts221_set_enable(iio_priv(iio_dev), true);\n}\n\nstatic int hts221_buffer_postdisable(struct iio_dev *iio_dev)\n{\n\treturn hts221_set_enable(iio_priv(iio_dev), false);\n}\n\nstatic const struct iio_buffer_setup_ops hts221_buffer_ops = {\n\t.preenable = hts221_buffer_preenable,\n\t.postdisable = hts221_buffer_postdisable,\n};\n\nstatic irqreturn_t hts221_buffer_handler_thread(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *iio_dev = pf->indio_dev;\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\tstruct iio_chan_spec const *ch;\n\tint err;\n\n\t \n\tch = &iio_dev->channels[HTS221_SENSOR_H];\n\terr = regmap_bulk_read(hw->regmap, ch->address,\n\t\t\t       &hw->scan.channels[0],\n\t\t\t       sizeof(hw->scan.channels[0]));\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tch = &iio_dev->channels[HTS221_SENSOR_T];\n\terr = regmap_bulk_read(hw->regmap, ch->address,\n\t\t\t       &hw->scan.channels[1],\n\t\t\t       sizeof(hw->scan.channels[1]));\n\tif (err < 0)\n\t\tgoto out;\n\n\tiio_push_to_buffers_with_timestamp(iio_dev, &hw->scan,\n\t\t\t\t\t   iio_get_time_ns(iio_dev));\n\nout:\n\tiio_trigger_notify_done(hw->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nint hts221_allocate_buffers(struct iio_dev *iio_dev)\n{\n\tstruct hts221_hw *hw = iio_priv(iio_dev);\n\treturn devm_iio_triggered_buffer_setup(hw->dev, iio_dev,\n\t\t\t\t\tNULL, hts221_buffer_handler_thread,\n\t\t\t\t\t&hts221_buffer_ops);\n}\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo.bianconi@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics hts221 buffer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}