{
  "module_name": "iio-rescale.c",
  "hash_id": "8570b0252ced528741db2dc9986eae9a892321fc755ad48a4e48f89b2f23671c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/afe/iio-rescale.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gcd.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include <linux/iio/afe/rescale.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/iio.h>\n\nint rescale_process_scale(struct rescale *rescale, int scale_type,\n\t\t\t  int *val, int *val2)\n{\n\ts64 tmp;\n\tint _val, _val2;\n\ts32 rem, rem2;\n\tu32 mult;\n\tu32 neg;\n\n\tswitch (scale_type) {\n\tcase IIO_VAL_INT:\n\t\t*val *= rescale->numerator;\n\t\tif (rescale->denominator == 1)\n\t\t\treturn scale_type;\n\t\t*val2 = rescale->denominator;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_VAL_FRACTIONAL:\n\t\t \n\t\tif (!check_mul_overflow(*val, rescale->numerator, &_val) &&\n\t\t    !check_mul_overflow(*val2, rescale->denominator, &_val2)) {\n\t\t\t*val = _val;\n\t\t\t*val2 = _val2;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t}\n\t\tfallthrough;\n\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\ttmp = (s64)*val * 1000000000LL;\n\t\ttmp = div_s64(tmp, rescale->denominator);\n\t\ttmp *= rescale->numerator;\n\n\t\ttmp = div_s64_rem(tmp, 1000000000LL, &rem);\n\t\t*val = tmp;\n\n\t\tif (!rem)\n\t\t\treturn scale_type;\n\n\t\tif (scale_type == IIO_VAL_FRACTIONAL)\n\t\t\ttmp = *val2;\n\t\telse\n\t\t\ttmp = ULL(1) << *val2;\n\n\t\trem2 = *val % (int)tmp;\n\t\t*val = *val / (int)tmp;\n\n\t\t*val2 = rem / (int)tmp;\n\t\tif (rem2)\n\t\t\t*val2 += div_s64((s64)rem2 * 1000000000LL, tmp);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_VAL_INT_PLUS_NANO:\n\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\tmult = scale_type == IIO_VAL_INT_PLUS_NANO ? 1000000000L : 1000000L;\n\n\t\t \n\t\tneg = *val < 0 || *val2 < 0;\n\n\t\ttmp = (s64)abs(*val) * abs(rescale->numerator);\n\t\t*val = div_s64_rem(tmp, abs(rescale->denominator), &rem);\n\n\t\ttmp = (s64)rem * mult + (s64)abs(*val2) * abs(rescale->numerator);\n\t\ttmp = div_s64(tmp, abs(rescale->denominator));\n\n\t\t*val += div_s64_rem(tmp, mult, val2);\n\n\t\t \n\t\tif (neg ^ ((rescale->numerator < 0) ^ (rescale->denominator < 0))) {\n\t\t\tif (*val)\n\t\t\t\t*val = -*val;\n\t\t\telse\n\t\t\t\t*val2 = -*val2;\n\t\t}\n\n\t\treturn scale_type;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(rescale_process_scale, IIO_RESCALE);\n\nint rescale_process_offset(struct rescale *rescale, int scale_type,\n\t\t\t   int scale, int scale2, int schan_off,\n\t\t\t   int *val, int *val2)\n{\n\ts64 tmp, tmp2;\n\n\tswitch (scale_type) {\n\tcase IIO_VAL_FRACTIONAL:\n\t\ttmp = (s64)rescale->offset * scale2;\n\t\t*val = div_s64(tmp, scale) + schan_off;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_VAL_INT:\n\t\t*val = div_s64(rescale->offset, scale) + schan_off;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\ttmp = (s64)rescale->offset * (1 << scale2);\n\t\t*val = div_s64(tmp, scale) + schan_off;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_VAL_INT_PLUS_NANO:\n\t\ttmp = (s64)rescale->offset * 1000000000LL;\n\t\ttmp2 = ((s64)scale * 1000000000LL) + scale2;\n\t\t*val = div64_s64(tmp, tmp2) + schan_off;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\ttmp = (s64)rescale->offset * 1000000LL;\n\t\ttmp2 = ((s64)scale * 1000000LL) + scale2;\n\t\t*val = div64_s64(tmp, tmp2) + schan_off;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(rescale_process_offset, IIO_RESCALE);\n\nstatic int rescale_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct rescale *rescale = iio_priv(indio_dev);\n\tint scale, scale2;\n\tint schan_off = 0;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (rescale->chan_processed)\n\t\t\t \n\t\t\treturn iio_read_channel_processed(rescale->source, val);\n\t\telse\n\t\t\treturn iio_read_channel_raw(rescale->source, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (rescale->chan_processed) {\n\t\t\t \n\t\t\t*val = 1;\n\t\t\t*val2 = 1;\n\t\t\tret = IIO_VAL_FRACTIONAL;\n\t\t} else {\n\t\t\tret = iio_read_channel_scale(rescale->source, val, val2);\n\t\t}\n\t\treturn rescale_process_scale(rescale, ret, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\tif (rescale->chan_processed) {\n\t\t\t*val = rescale->offset;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\n\t\tif (iio_channel_has_info(rescale->source->channel,\n\t\t\t\t\t IIO_CHAN_INFO_OFFSET)) {\n\t\t\tret = iio_read_channel_offset(rescale->source,\n\t\t\t\t\t\t      &schan_off, NULL);\n\t\t\tif (ret != IIO_VAL_INT)\n\t\t\t\treturn ret < 0 ? ret : -EOPNOTSUPP;\n\t\t}\n\n\t\tif (iio_channel_has_info(rescale->source->channel,\n\t\t\t\t\t IIO_CHAN_INFO_SCALE)) {\n\t\t\tret = iio_read_channel_scale(rescale->source, &scale, &scale2);\n\t\t\treturn rescale_process_offset(rescale, ret, scale, scale2,\n\t\t\t\t\t\t      schan_off, val, val2);\n\t\t}\n\n\t\t \n\t\treturn rescale_process_offset(rescale, IIO_VAL_FRACTIONAL, 1, 1,\n\t\t\t\t\t      schan_off, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rescale_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct rescale *rescale = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*type = IIO_VAL_INT;\n\t\treturn iio_read_avail_channel_raw(rescale->source,\n\t\t\t\t\t\t  vals, length);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info rescale_info = {\n\t.read_raw = rescale_read_raw,\n\t.read_avail = rescale_read_avail,\n};\n\nstatic ssize_t rescale_read_ext_info(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t private,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     char *buf)\n{\n\tstruct rescale *rescale = iio_priv(indio_dev);\n\n\treturn iio_read_channel_ext_info(rescale->source,\n\t\t\t\t\t rescale->ext_info[private].name,\n\t\t\t\t\t buf);\n}\n\nstatic ssize_t rescale_write_ext_info(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct rescale *rescale = iio_priv(indio_dev);\n\n\treturn iio_write_channel_ext_info(rescale->source,\n\t\t\t\t\t  rescale->ext_info[private].name,\n\t\t\t\t\t  buf, len);\n}\n\nstatic int rescale_configure_channel(struct device *dev,\n\t\t\t\t     struct rescale *rescale)\n{\n\tstruct iio_chan_spec *chan = &rescale->chan;\n\tstruct iio_chan_spec const *schan = rescale->source->channel;\n\n\tchan->indexed = 1;\n\tchan->output = schan->output;\n\tchan->ext_info = rescale->ext_info;\n\tchan->type = rescale->cfg->type;\n\n\tif (iio_channel_has_info(schan, IIO_CHAN_INFO_RAW) &&\n\t    (iio_channel_has_info(schan, IIO_CHAN_INFO_SCALE) ||\n\t     iio_channel_has_info(schan, IIO_CHAN_INFO_OFFSET))) {\n\t\tdev_info(dev, \"using raw+scale/offset source channel\\n\");\n\t} else if (iio_channel_has_info(schan, IIO_CHAN_INFO_PROCESSED)) {\n\t\tdev_info(dev, \"using processed channel\\n\");\n\t\trescale->chan_processed = true;\n\t} else {\n\t\tdev_err(dev, \"source channel is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_SCALE);\n\n\tif (rescale->offset)\n\t\tchan->info_mask_separate |= BIT(IIO_CHAN_INFO_OFFSET);\n\n\t \n\tif (iio_channel_has_available(schan, IIO_CHAN_INFO_RAW) &&\n\t    !rescale->chan_processed)\n\t\tchan->info_mask_separate_available |= BIT(IIO_CHAN_INFO_RAW);\n\n\treturn 0;\n}\n\nstatic int rescale_current_sense_amplifier_props(struct device *dev,\n\t\t\t\t\t\t struct rescale *rescale)\n{\n\tu32 sense;\n\tu32 gain_mult = 1;\n\tu32 gain_div = 1;\n\tu32 factor;\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"sense-resistor-micro-ohms\",\n\t\t\t\t       &sense);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read the sense resistance: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_property_read_u32(dev, \"sense-gain-mult\", &gain_mult);\n\tdevice_property_read_u32(dev, \"sense-gain-div\", &gain_div);\n\n\t \n\tfactor = gcd(sense, 1000000);\n\trescale->numerator = 1000000 / factor;\n\trescale->denominator = sense / factor;\n\n\tfactor = gcd(rescale->numerator, gain_mult);\n\trescale->numerator /= factor;\n\trescale->denominator *= gain_mult / factor;\n\n\tfactor = gcd(rescale->denominator, gain_div);\n\trescale->numerator *= gain_div / factor;\n\trescale->denominator /= factor;\n\n\treturn 0;\n}\n\nstatic int rescale_current_sense_shunt_props(struct device *dev,\n\t\t\t\t\t     struct rescale *rescale)\n{\n\tu32 shunt;\n\tu32 factor;\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t       &shunt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read the shunt resistance: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfactor = gcd(shunt, 1000000);\n\trescale->numerator = 1000000 / factor;\n\trescale->denominator = shunt / factor;\n\n\treturn 0;\n}\n\nstatic int rescale_voltage_divider_props(struct device *dev,\n\t\t\t\t\t struct rescale *rescale)\n{\n\tint ret;\n\tu32 factor;\n\n\tret = device_property_read_u32(dev, \"output-ohms\",\n\t\t\t\t       &rescale->denominator);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read output-ohms: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"full-ohms\",\n\t\t\t\t       &rescale->numerator);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read full-ohms: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfactor = gcd(rescale->numerator, rescale->denominator);\n\trescale->numerator /= factor;\n\trescale->denominator /= factor;\n\n\treturn 0;\n}\n\nstatic int rescale_temp_sense_rtd_props(struct device *dev,\n\t\t\t\t\tstruct rescale *rescale)\n{\n\tu32 factor;\n\tu32 alpha;\n\tu32 iexc;\n\tu32 tmp;\n\tint ret;\n\tu32 r0;\n\n\tret = device_property_read_u32(dev, \"excitation-current-microamp\",\n\t\t\t\t       &iexc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read excitation-current-microamp: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"alpha-ppm-per-celsius\", &alpha);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read alpha-ppm-per-celsius: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"r-naught-ohms\", &r0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read r-naught-ohms: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttmp = r0 * iexc * alpha / 1000000;\n\tfactor = gcd(tmp, 1000000);\n\trescale->numerator = 1000000 / factor;\n\trescale->denominator = tmp / factor;\n\n\trescale->offset = -1 * ((r0 * iexc) / 1000);\n\n\treturn 0;\n}\n\nstatic int rescale_temp_transducer_props(struct device *dev,\n\t\t\t\t\t struct rescale *rescale)\n{\n\ts32 offset = 0;\n\ts32 sense = 1;\n\ts32 alpha;\n\tint ret;\n\n\tdevice_property_read_u32(dev, \"sense-offset-millicelsius\", &offset);\n\tdevice_property_read_u32(dev, \"sense-resistor-ohms\", &sense);\n\tret = device_property_read_u32(dev, \"alpha-ppm-per-celsius\", &alpha);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read alpha-ppm-per-celsius: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trescale->numerator = 1000000;\n\trescale->denominator = alpha * sense;\n\n\trescale->offset = div_s64((s64)offset * rescale->denominator,\n\t\t\t\t  rescale->numerator);\n\n\treturn 0;\n}\n\nenum rescale_variant {\n\tCURRENT_SENSE_AMPLIFIER,\n\tCURRENT_SENSE_SHUNT,\n\tVOLTAGE_DIVIDER,\n\tTEMP_SENSE_RTD,\n\tTEMP_TRANSDUCER,\n};\n\nstatic const struct rescale_cfg rescale_cfg[] = {\n\t[CURRENT_SENSE_AMPLIFIER] = {\n\t\t.type = IIO_CURRENT,\n\t\t.props = rescale_current_sense_amplifier_props,\n\t},\n\t[CURRENT_SENSE_SHUNT] = {\n\t\t.type = IIO_CURRENT,\n\t\t.props = rescale_current_sense_shunt_props,\n\t},\n\t[VOLTAGE_DIVIDER] = {\n\t\t.type = IIO_VOLTAGE,\n\t\t.props = rescale_voltage_divider_props,\n\t},\n\t[TEMP_SENSE_RTD] = {\n\t\t.type = IIO_TEMP,\n\t\t.props = rescale_temp_sense_rtd_props,\n\t},\n\t[TEMP_TRANSDUCER] = {\n\t\t.type = IIO_TEMP,\n\t\t.props = rescale_temp_transducer_props,\n\t},\n};\n\nstatic const struct of_device_id rescale_match[] = {\n\t{ .compatible = \"current-sense-amplifier\",\n\t  .data = &rescale_cfg[CURRENT_SENSE_AMPLIFIER], },\n\t{ .compatible = \"current-sense-shunt\",\n\t  .data = &rescale_cfg[CURRENT_SENSE_SHUNT], },\n\t{ .compatible = \"voltage-divider\",\n\t  .data = &rescale_cfg[VOLTAGE_DIVIDER], },\n\t{ .compatible = \"temperature-sense-rtd\",\n\t  .data = &rescale_cfg[TEMP_SENSE_RTD], },\n\t{ .compatible = \"temperature-transducer\",\n\t  .data = &rescale_cfg[TEMP_TRANSDUCER], },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rescale_match);\n\nstatic int rescale_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_channel *source;\n\tstruct rescale *rescale;\n\tint sizeof_ext_info;\n\tint sizeof_priv;\n\tint i;\n\tint ret;\n\n\tsource = devm_iio_channel_get(dev, NULL);\n\tif (IS_ERR(source))\n\t\treturn dev_err_probe(dev, PTR_ERR(source),\n\t\t\t\t     \"failed to get source channel\\n\");\n\n\tsizeof_ext_info = iio_get_channel_ext_info_count(source);\n\tif (sizeof_ext_info) {\n\t\tsizeof_ext_info += 1;  \n\t\tsizeof_ext_info *= sizeof(*rescale->ext_info);\n\t}\n\n\tsizeof_priv = sizeof(*rescale) + sizeof_ext_info;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof_priv);\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\trescale = iio_priv(indio_dev);\n\n\trescale->cfg = device_get_match_data(dev);\n\trescale->numerator = 1;\n\trescale->denominator = 1;\n\trescale->offset = 0;\n\n\tret = rescale->cfg->props(dev, rescale);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!rescale->numerator || !rescale->denominator) {\n\t\tdev_err(dev, \"invalid scaling factor.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\trescale->source = source;\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &rescale_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = &rescale->chan;\n\tindio_dev->num_channels = 1;\n\tif (sizeof_ext_info) {\n\t\trescale->ext_info = devm_kmemdup(dev,\n\t\t\t\t\t\t source->channel->ext_info,\n\t\t\t\t\t\t sizeof_ext_info, GFP_KERNEL);\n\t\tif (!rescale->ext_info)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; rescale->ext_info[i].name; ++i) {\n\t\t\tstruct iio_chan_spec_ext_info *ext_info =\n\t\t\t\t&rescale->ext_info[i];\n\n\t\t\tif (source->channel->ext_info[i].read)\n\t\t\t\text_info->read = rescale_read_ext_info;\n\t\t\tif (source->channel->ext_info[i].write)\n\t\t\t\text_info->write = rescale_write_ext_info;\n\t\t\text_info->private = i;\n\t\t}\n\t}\n\n\tret = rescale_configure_channel(dev, rescale);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct platform_driver rescale_driver = {\n\t.probe = rescale_probe,\n\t.driver = {\n\t\t.name = \"iio-rescale\",\n\t\t.of_match_table = rescale_match,\n\t},\n};\nmodule_platform_driver(rescale_driver);\n\nMODULE_DESCRIPTION(\"IIO rescale driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}