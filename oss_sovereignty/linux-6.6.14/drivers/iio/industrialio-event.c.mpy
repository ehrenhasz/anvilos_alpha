{
  "module_name": "industrialio-event.c",
  "hash_id": "3cd980286c24766fc57748393758d582a4959055c9b8d5af9e02a6acab222b63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/industrialio-event.c",
  "human_readable_source": "\n \n\n#include <linux/anon_inodes.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/iio-opaque.h>\n#include \"iio_core.h\"\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n \nstruct iio_event_interface {\n\twait_queue_head_t\twait;\n\tDECLARE_KFIFO(det_events, struct iio_event_data, 16);\n\n\tstruct list_head\tdev_attr_list;\n\tunsigned long\t\tflags;\n\tstruct attribute_group\tgroup;\n\tstruct mutex\t\tread_lock;\n\tstruct iio_ioctl_handler\tioctl_handler;\n};\n\nbool iio_event_enabled(const struct iio_event_interface *ev_int)\n{\n\treturn !!test_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\n}\n\n \nint iio_push_event(struct iio_dev *indio_dev, u64 ev_code, s64 timestamp)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\tstruct iio_event_data ev;\n\tint copied;\n\n\tif (!ev_int)\n\t\treturn 0;\n\n\t \n\tif (iio_event_enabled(ev_int)) {\n\n\t\tev.id = ev_code;\n\t\tev.timestamp = timestamp;\n\n\t\tcopied = kfifo_put(&ev_int->det_events, ev);\n\t\tif (copied != 0)\n\t\t\twake_up_poll(&ev_int->wait, EPOLLIN);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iio_push_event);\n\n \nstatic __poll_t iio_event_poll(struct file *filep,\n\t\t\t     struct poll_table_struct *wait)\n{\n\tstruct iio_dev *indio_dev = filep->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\t__poll_t events = 0;\n\n\tif (!indio_dev->info)\n\t\treturn events;\n\n\tpoll_wait(filep, &ev_int->wait, wait);\n\n\tif (!kfifo_is_empty(&ev_int->det_events))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic ssize_t iio_event_chrdev_read(struct file *filep,\n\t\t\t\t     char __user *buf,\n\t\t\t\t     size_t count,\n\t\t\t\t     loff_t *f_ps)\n{\n\tstruct iio_dev *indio_dev = filep->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\tunsigned int copied;\n\tint ret;\n\n\tif (!indio_dev->info)\n\t\treturn -ENODEV;\n\n\tif (count < sizeof(struct iio_event_data))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (kfifo_is_empty(&ev_int->det_events)) {\n\t\t\tif (filep->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = wait_event_interruptible(ev_int->wait,\n\t\t\t\t\t!kfifo_is_empty(&ev_int->det_events) ||\n\t\t\t\t\tindio_dev->info == NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (indio_dev->info == NULL)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&ev_int->read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t\tret = kfifo_to_user(&ev_int->det_events, buf, count, &copied);\n\t\tmutex_unlock(&ev_int->read_lock);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (copied == 0 && (filep->f_flags & O_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\n\t} while (copied == 0);\n\n\treturn copied;\n}\n\nstatic int iio_event_chrdev_release(struct inode *inode, struct file *filep)\n{\n\tstruct iio_dev *indio_dev = filep->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\n\tclear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\n\n\tiio_device_put(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations iio_event_chrdev_fileops = {\n\t.read =  iio_event_chrdev_read,\n\t.poll =  iio_event_poll,\n\t.release = iio_event_chrdev_release,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nstatic int iio_event_getfd(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\tint fd;\n\n\tif (ev_int == NULL)\n\t\treturn -ENODEV;\n\n\tfd = mutex_lock_interruptible(&iio_dev_opaque->mlock);\n\tif (fd)\n\t\treturn fd;\n\n\tif (test_and_set_bit(IIO_BUSY_BIT_POS, &ev_int->flags)) {\n\t\tfd = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tiio_device_get(indio_dev);\n\n\tfd = anon_inode_getfd(\"iio:event\", &iio_event_chrdev_fileops,\n\t\t\t\tindio_dev, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tclear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\n\t\tiio_device_put(indio_dev);\n\t} else {\n\t\tkfifo_reset_out(&ev_int->det_events);\n\t}\n\nunlock:\n\tmutex_unlock(&iio_dev_opaque->mlock);\n\treturn fd;\n}\n\nstatic const char * const iio_ev_type_text[] = {\n\t[IIO_EV_TYPE_THRESH] = \"thresh\",\n\t[IIO_EV_TYPE_MAG] = \"mag\",\n\t[IIO_EV_TYPE_ROC] = \"roc\",\n\t[IIO_EV_TYPE_THRESH_ADAPTIVE] = \"thresh_adaptive\",\n\t[IIO_EV_TYPE_MAG_ADAPTIVE] = \"mag_adaptive\",\n\t[IIO_EV_TYPE_CHANGE] = \"change\",\n\t[IIO_EV_TYPE_MAG_REFERENCED] = \"mag_referenced\",\n\t[IIO_EV_TYPE_GESTURE] = \"gesture\",\n};\n\nstatic const char * const iio_ev_dir_text[] = {\n\t[IIO_EV_DIR_EITHER] = \"either\",\n\t[IIO_EV_DIR_RISING] = \"rising\",\n\t[IIO_EV_DIR_FALLING] = \"falling\",\n\t[IIO_EV_DIR_SINGLETAP] = \"singletap\",\n\t[IIO_EV_DIR_DOUBLETAP] = \"doubletap\",\n};\n\nstatic const char * const iio_ev_info_text[] = {\n\t[IIO_EV_INFO_ENABLE] = \"en\",\n\t[IIO_EV_INFO_VALUE] = \"value\",\n\t[IIO_EV_INFO_HYSTERESIS] = \"hysteresis\",\n\t[IIO_EV_INFO_PERIOD] = \"period\",\n\t[IIO_EV_INFO_HIGH_PASS_FILTER_3DB] = \"high_pass_filter_3db\",\n\t[IIO_EV_INFO_LOW_PASS_FILTER_3DB] = \"low_pass_filter_3db\",\n\t[IIO_EV_INFO_TIMEOUT] = \"timeout\",\n\t[IIO_EV_INFO_RESET_TIMEOUT] = \"reset_timeout\",\n\t[IIO_EV_INFO_TAP2_MIN_DELAY] = \"tap2_min_delay\",\n\t[IIO_EV_INFO_RUNNING_PERIOD] = \"runningperiod\",\n\t[IIO_EV_INFO_RUNNING_COUNT] = \"runningcount\",\n};\n\nstatic enum iio_event_direction iio_ev_attr_dir(struct iio_dev_attr *attr)\n{\n\treturn attr->c->event_spec[attr->address & 0xffff].dir;\n}\n\nstatic enum iio_event_type iio_ev_attr_type(struct iio_dev_attr *attr)\n{\n\treturn attr->c->event_spec[attr->address & 0xffff].type;\n}\n\nstatic enum iio_event_info iio_ev_attr_info(struct iio_dev_attr *attr)\n{\n\treturn (attr->address >> 16) & 0xffff;\n}\n\nstatic ssize_t iio_ev_state_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = indio_dev->info->write_event_config(indio_dev,\n\t\tthis_attr->c, iio_ev_attr_type(this_attr),\n\t\tiio_ev_attr_dir(this_attr), val);\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic ssize_t iio_ev_state_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint val;\n\n\tval = indio_dev->info->read_event_config(indio_dev,\n\t\tthis_attr->c, iio_ev_attr_type(this_attr),\n\t\tiio_ev_attr_dir(this_attr));\n\tif (val < 0)\n\t\treturn val;\n\telse\n\t\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t iio_ev_value_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint val, val2, val_arr[2];\n\tint ret;\n\n\tret = indio_dev->info->read_event_value(indio_dev,\n\t\tthis_attr->c, iio_ev_attr_type(this_attr),\n\t\tiio_ev_attr_dir(this_attr), iio_ev_attr_info(this_attr),\n\t\t&val, &val2);\n\tif (ret < 0)\n\t\treturn ret;\n\tval_arr[0] = val;\n\tval_arr[1] = val2;\n\treturn iio_format_value(buf, ret, 2, val_arr);\n}\n\nstatic ssize_t iio_ev_value_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint val, val2;\n\tint ret;\n\n\tif (!indio_dev->info->write_event_value)\n\t\treturn -EINVAL;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &val, &val2);\n\tif (ret)\n\t\treturn ret;\n\tret = indio_dev->info->write_event_value(indio_dev,\n\t\tthis_attr->c, iio_ev_attr_type(this_attr),\n\t\tiio_ev_attr_dir(this_attr), iio_ev_attr_info(this_attr),\n\t\tval, val2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic int iio_device_add_event(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned int spec_index,\n\tenum iio_event_type type, enum iio_event_direction dir,\n\tenum iio_shared_by shared_by, const unsigned long *mask)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tssize_t (*show)(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf);\n\tssize_t (*store)(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len);\n\tunsigned int attrcount = 0;\n\tunsigned int i;\n\tchar *postfix;\n\tint ret;\n\n\tfor_each_set_bit(i, mask, sizeof(*mask)*8) {\n\t\tif (i >= ARRAY_SIZE(iio_ev_info_text))\n\t\t\treturn -EINVAL;\n\t\tif (dir != IIO_EV_DIR_NONE)\n\t\t\tpostfix = kasprintf(GFP_KERNEL, \"%s_%s_%s\",\n\t\t\t\t\tiio_ev_type_text[type],\n\t\t\t\t\tiio_ev_dir_text[dir],\n\t\t\t\t\tiio_ev_info_text[i]);\n\t\telse\n\t\t\tpostfix = kasprintf(GFP_KERNEL, \"%s_%s\",\n\t\t\t\t\tiio_ev_type_text[type],\n\t\t\t\t\tiio_ev_info_text[i]);\n\t\tif (postfix == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i == IIO_EV_INFO_ENABLE) {\n\t\t\tshow = iio_ev_state_show;\n\t\t\tstore = iio_ev_state_store;\n\t\t} else {\n\t\t\tshow = iio_ev_value_show;\n\t\t\tstore = iio_ev_value_store;\n\t\t}\n\n\t\tret = __iio_add_chan_devattr(postfix, chan, show, store,\n\t\t\t (i << 16) | spec_index, shared_by, &indio_dev->dev,\n\t\t\t NULL,\n\t\t\t&iio_dev_opaque->event_interface->dev_attr_list);\n\t\tkfree(postfix);\n\n\t\tif ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))\n\t\t\tcontinue;\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tattrcount++;\n\t}\n\n\treturn attrcount;\n}\n\nstatic int iio_device_add_event_sysfs(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan)\n{\n\tint ret = 0, i, attrcount = 0;\n\tenum iio_event_direction dir;\n\tenum iio_event_type type;\n\n\tfor (i = 0; i < chan->num_event_specs; i++) {\n\t\ttype = chan->event_spec[i].type;\n\t\tdir = chan->event_spec[i].dir;\n\n\t\tret = iio_device_add_event(indio_dev, chan, i, type, dir,\n\t\t\tIIO_SEPARATE, &chan->event_spec[i].mask_separate);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount += ret;\n\n\t\tret = iio_device_add_event(indio_dev, chan, i, type, dir,\n\t\t\tIIO_SHARED_BY_TYPE,\n\t\t\t&chan->event_spec[i].mask_shared_by_type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount += ret;\n\n\t\tret = iio_device_add_event(indio_dev, chan, i, type, dir,\n\t\t\tIIO_SHARED_BY_DIR,\n\t\t\t&chan->event_spec[i].mask_shared_by_dir);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount += ret;\n\n\t\tret = iio_device_add_event(indio_dev, chan, i, type, dir,\n\t\t\tIIO_SHARED_BY_ALL,\n\t\t\t&chan->event_spec[i].mask_shared_by_all);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount += ret;\n\t}\n\tret = attrcount;\n\treturn ret;\n}\n\nstatic inline int __iio_add_event_config_attrs(struct iio_dev *indio_dev)\n{\n\tint j, ret, attrcount = 0;\n\n\t \n\tfor (j = 0; j < indio_dev->num_channels; j++) {\n\t\tret = iio_device_add_event_sysfs(indio_dev,\n\t\t\t\t\t\t &indio_dev->channels[j]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount += ret;\n\t}\n\treturn attrcount;\n}\n\nstatic bool iio_check_for_dynamic_events(struct iio_dev *indio_dev)\n{\n\tint j;\n\n\tfor (j = 0; j < indio_dev->num_channels; j++) {\n\t\tif (indio_dev->channels[j].num_event_specs != 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void iio_setup_ev_int(struct iio_event_interface *ev_int)\n{\n\tINIT_KFIFO(ev_int->det_events);\n\tinit_waitqueue_head(&ev_int->wait);\n\tmutex_init(&ev_int->read_lock);\n}\n\nstatic long iio_event_ioctl(struct iio_dev *indio_dev, struct file *filp,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\tint __user *ip = (int __user *)arg;\n\tint fd;\n\n\tif (cmd == IIO_GET_EVENT_FD_IOCTL) {\n\t\tfd = iio_event_getfd(indio_dev);\n\t\tif (fd < 0)\n\t\t\treturn fd;\n\t\tif (copy_to_user(ip, &fd, sizeof(fd)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn IIO_IOCTL_UNHANDLED;\n}\n\nstatic const char *iio_event_group_name = \"events\";\nint iio_device_register_eventset(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int;\n\tstruct iio_dev_attr *p;\n\tint ret = 0, attrcount_orig = 0, attrcount, attrn;\n\tstruct attribute **attr;\n\n\tif (!(indio_dev->info->event_attrs ||\n\t      iio_check_for_dynamic_events(indio_dev)))\n\t\treturn 0;\n\n\tev_int = kzalloc(sizeof(struct iio_event_interface), GFP_KERNEL);\n\tif (ev_int == NULL)\n\t\treturn -ENOMEM;\n\n\tiio_dev_opaque->event_interface = ev_int;\n\n\tINIT_LIST_HEAD(&ev_int->dev_attr_list);\n\n\tiio_setup_ev_int(ev_int);\n\tif (indio_dev->info->event_attrs != NULL) {\n\t\tattr = indio_dev->info->event_attrs->attrs;\n\t\twhile (*attr++ != NULL)\n\t\t\tattrcount_orig++;\n\t}\n\tattrcount = attrcount_orig;\n\tif (indio_dev->channels) {\n\t\tret = __iio_add_event_config_attrs(indio_dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_free_setup_event_lines;\n\t\tattrcount += ret;\n\t}\n\n\tev_int->group.name = iio_event_group_name;\n\tev_int->group.attrs = kcalloc(attrcount + 1,\n\t\t\t\t      sizeof(ev_int->group.attrs[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (ev_int->group.attrs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_setup_event_lines;\n\t}\n\tif (indio_dev->info->event_attrs)\n\t\tmemcpy(ev_int->group.attrs,\n\t\t       indio_dev->info->event_attrs->attrs,\n\t\t       sizeof(ev_int->group.attrs[0]) * attrcount_orig);\n\tattrn = attrcount_orig;\n\t \n\tlist_for_each_entry(p, &ev_int->dev_attr_list, l)\n\t\tev_int->group.attrs[attrn++] = &p->dev_attr.attr;\n\n\tret = iio_device_register_sysfs_group(indio_dev, &ev_int->group);\n\tif (ret)\n\t\tgoto error_free_group_attrs;\n\n\tev_int->ioctl_handler.ioctl = iio_event_ioctl;\n\tiio_device_ioctl_handler_register(&iio_dev_opaque->indio_dev,\n\t\t\t\t\t  &ev_int->ioctl_handler);\n\n\treturn 0;\n\nerror_free_group_attrs:\n\tkfree(ev_int->group.attrs);\nerror_free_setup_event_lines:\n\tiio_free_chan_devattr_list(&ev_int->dev_attr_list);\n\tkfree(ev_int);\n\tiio_dev_opaque->event_interface = NULL;\n\treturn ret;\n}\n\n \nvoid iio_device_wakeup_eventset(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tif (iio_dev_opaque->event_interface == NULL)\n\t\treturn;\n\twake_up(&iio_dev_opaque->event_interface->wait);\n}\n\nvoid iio_device_unregister_eventset(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\n\tif (ev_int == NULL)\n\t\treturn;\n\n\tiio_device_ioctl_handler_unregister(&ev_int->ioctl_handler);\n\tiio_free_chan_devattr_list(&ev_int->dev_attr_list);\n\tkfree(ev_int->group.attrs);\n\tkfree(ev_int);\n\tiio_dev_opaque->event_interface = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}