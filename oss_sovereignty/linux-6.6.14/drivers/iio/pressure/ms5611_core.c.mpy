{
  "module_name": "ms5611_core.c",
  "hash_id": "3da8aecb4ce514fdaf13a4270b3e5da36859d2c6975db0da09bb3b8ef4ab6e8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/ms5611_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include \"ms5611.h\"\n\n#define MS5611_INIT_OSR(_cmd, _conv_usec, _rate) \\\n\t{ .cmd = _cmd, .conv_usec = _conv_usec, .rate = _rate }\n\nstatic const struct ms5611_osr ms5611_avail_pressure_osr[] = {\n\tMS5611_INIT_OSR(0x40, 600,  256),\n\tMS5611_INIT_OSR(0x42, 1170, 512),\n\tMS5611_INIT_OSR(0x44, 2280, 1024),\n\tMS5611_INIT_OSR(0x46, 4540, 2048),\n\tMS5611_INIT_OSR(0x48, 9040, 4096)\n};\n\nstatic const struct ms5611_osr ms5611_avail_temp_osr[] = {\n\tMS5611_INIT_OSR(0x50, 600,  256),\n\tMS5611_INIT_OSR(0x52, 1170, 512),\n\tMS5611_INIT_OSR(0x54, 2280, 1024),\n\tMS5611_INIT_OSR(0x56, 4540, 2048),\n\tMS5611_INIT_OSR(0x58, 9040, 4096)\n};\n\nstatic const char ms5611_show_osr[] = \"256 512 1024 2048 4096\";\n\nstatic IIO_CONST_ATTR(oversampling_ratio_available, ms5611_show_osr);\n\nstatic struct attribute *ms5611_attributes[] = {\n\t&iio_const_attr_oversampling_ratio_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ms5611_attribute_group = {\n\t.attrs = ms5611_attributes,\n};\n\nstatic bool ms5611_prom_is_valid(u16 *prom, size_t len)\n{\n\tint i, j;\n\tuint16_t crc = 0, crc_orig = prom[7] & 0x000F;\n\n\tprom[7] &= 0xFF00;\n\n\tfor (i = 0; i < len * 2; i++) {\n\t\tif (i % 2 == 1)\n\t\t\tcrc ^= prom[i >> 1] & 0x00FF;\n\t\telse\n\t\t\tcrc ^= prom[i >> 1] >> 8;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (crc & 0x8000)\n\t\t\t\tcrc = (crc << 1) ^ 0x3000;\n\t\t\telse\n\t\t\t\tcrc <<= 1;\n\t\t}\n\t}\n\n\tcrc = (crc >> 12) & 0x000F;\n\n\treturn crc == crc_orig;\n}\n\nstatic int ms5611_read_prom(struct iio_dev *indio_dev)\n{\n\tint ret, i;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\n\tfor (i = 0; i < MS5611_PROM_WORDS_NB; i++) {\n\t\tret = st->read_prom_word(st, i, &st->prom[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"failed to read prom at %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!ms5611_prom_is_valid(st->prom, MS5611_PROM_WORDS_NB)) {\n\t\tdev_err(&indio_dev->dev, \"PROM integrity check failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ms5611_read_temp_and_pressure(struct iio_dev *indio_dev,\n\t\t\t\t\t s32 *temp, s32 *pressure)\n{\n\tint ret;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\n\tret = st->read_adc_temp_and_pressure(st, temp, pressure);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to read temperature and pressure\\n\");\n\t\treturn ret;\n\t}\n\n\treturn st->compensate_temp_and_pressure(st, temp, pressure);\n}\n\nstatic int ms5611_temp_and_pressure_compensate(struct ms5611_state *st,\n\t\t\t\t\t       s32 *temp, s32 *pressure)\n{\n\ts32 t = *temp, p = *pressure;\n\ts64 off, sens, dt;\n\n\tdt = t - (st->prom[5] << 8);\n\toff = ((s64)st->prom[2] << 16) + ((st->prom[4] * dt) >> 7);\n\tsens = ((s64)st->prom[1] << 15) + ((st->prom[3] * dt) >> 8);\n\n\tt = 2000 + ((st->prom[6] * dt) >> 23);\n\tif (t < 2000) {\n\t\ts64 off2, sens2, t2;\n\n\t\tt2 = (dt * dt) >> 31;\n\t\toff2 = (5 * (t - 2000) * (t - 2000)) >> 1;\n\t\tsens2 = off2 >> 1;\n\n\t\tif (t < -1500) {\n\t\t\ts64 tmp = (t + 1500) * (t + 1500);\n\n\t\t\toff2 += 7 * tmp;\n\t\t\tsens2 += (11 * tmp) >> 1;\n\t\t}\n\n\t\tt -= t2;\n\t\toff -= off2;\n\t\tsens -= sens2;\n\t}\n\n\t*temp = t;\n\t*pressure = (((p * sens) >> 21) - off) >> 15;\n\n\treturn 0;\n}\n\nstatic int ms5607_temp_and_pressure_compensate(struct ms5611_state *st,\n\t\t\t\t\t       s32 *temp, s32 *pressure)\n{\n\ts32 t = *temp, p = *pressure;\n\ts64 off, sens, dt;\n\n\tdt = t - (st->prom[5] << 8);\n\toff = ((s64)st->prom[2] << 17) + ((st->prom[4] * dt) >> 6);\n\tsens = ((s64)st->prom[1] << 16) + ((st->prom[3] * dt) >> 7);\n\n\tt = 2000 + ((st->prom[6] * dt) >> 23);\n\tif (t < 2000) {\n\t\ts64 off2, sens2, t2, tmp;\n\n\t\tt2 = (dt * dt) >> 31;\n\t\ttmp = (t - 2000) * (t - 2000);\n\t\toff2 = (61 * tmp) >> 4;\n\t\tsens2 = tmp << 1;\n\n\t\tif (t < -1500) {\n\t\t\ttmp = (t + 1500) * (t + 1500);\n\t\t\toff2 += 15 * tmp;\n\t\t\tsens2 += 8 * tmp;\n\t\t}\n\n\t\tt -= t2;\n\t\toff -= off2;\n\t\tsens -= sens2;\n\t}\n\n\t*temp = t;\n\t*pressure = (((p * sens) >> 21) - off) >> 15;\n\n\treturn 0;\n}\n\nstatic int ms5611_reset(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\n\tret = st->reset(st);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"failed to reset device\\n\");\n\t\treturn ret;\n\t}\n\n\tusleep_range(3000, 4000);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ms5611_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\t \n\tstruct {\n\t\ts32 channels[2];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ms5611_read_temp_and_pressure(indio_dev, &scan.channels[1],\n\t\t\t\t\t    &scan.channels[0]);\n\tmutex_unlock(&st->lock);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ms5611_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tint ret;\n\ts32 temp, pressure;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tmutex_lock(&st->lock);\n\t\tret = ms5611_read_temp_and_pressure(indio_dev,\n\t\t\t\t\t\t    &temp, &pressure);\n\t\tmutex_unlock(&st->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = temp * 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = pressure / 1000;\n\t\t\t*val2 = (pressure % 1000) * 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tif (chan->type != IIO_TEMP && chan->type != IIO_PRESSURE)\n\t\t\tbreak;\n\t\tmutex_lock(&st->lock);\n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val = (int)st->temp_osr->rate;\n\t\telse\n\t\t\t*val = (int)st->pressure_osr->rate;\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct ms5611_osr *ms5611_find_osr(int rate,\n\t\t\t\t\t\tconst struct ms5611_osr *osr,\n\t\t\t\t\t\tsize_t count)\n{\n\tunsigned int r;\n\n\tfor (r = 0; r < count; r++)\n\t\tif ((unsigned short)rate == osr[r].rate)\n\t\t\tbreak;\n\tif (r >= count)\n\t\treturn NULL;\n\treturn &osr[r];\n}\n\nstatic int ms5611_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\tconst struct ms5611_osr *osr = NULL;\n\tint ret;\n\n\tif (mask != IIO_CHAN_INFO_OVERSAMPLING_RATIO)\n\t\treturn -EINVAL;\n\n\tif (chan->type == IIO_TEMP)\n\t\tosr = ms5611_find_osr(val, ms5611_avail_temp_osr,\n\t\t\t\t      ARRAY_SIZE(ms5611_avail_temp_osr));\n\telse if (chan->type == IIO_PRESSURE)\n\t\tosr = ms5611_find_osr(val, ms5611_avail_pressure_osr,\n\t\t\t\t      ARRAY_SIZE(ms5611_avail_pressure_osr));\n\tif (!osr)\n\t\treturn -EINVAL;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (chan->type == IIO_TEMP)\n\t\tst->temp_osr = osr;\n\telse\n\t\tst->pressure_osr = osr;\n\n\tmutex_unlock(&st->lock);\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn 0;\n}\n\nstatic const unsigned long ms5611_scan_masks[] = {0x3, 0};\n\nstatic const struct iio_chan_spec ms5611_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic const struct iio_info ms5611_info = {\n\t.read_raw = &ms5611_read_raw,\n\t.write_raw = &ms5611_write_raw,\n\t.attrs = &ms5611_attribute_group,\n};\n\nstatic int ms5611_init(struct iio_dev *indio_dev)\n{\n\tint ret;\n\n\t \n\tret = devm_regulator_get_enable(indio_dev->dev.parent, \"vdd\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = ms5611_reset(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ms5611_read_prom(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint ms5611_probe(struct iio_dev *indio_dev, struct device *dev,\n\t\t const char *name, int type)\n{\n\tint ret;\n\tstruct ms5611_state *st = iio_priv(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\tswitch (type) {\n\tcase MS5611:\n\t\tst->compensate_temp_and_pressure =\n\t\t\tms5611_temp_and_pressure_compensate;\n\t\tbreak;\n\tcase MS5607:\n\t\tst->compensate_temp_and_pressure =\n\t\t\tms5607_temp_and_pressure_compensate;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tst->temp_osr =\n\t\t&ms5611_avail_temp_osr[ARRAY_SIZE(ms5611_avail_temp_osr) - 1];\n\tst->pressure_osr =\n\t\t&ms5611_avail_pressure_osr[ARRAY_SIZE(ms5611_avail_pressure_osr)\n\t\t\t\t\t   - 1];\n\tindio_dev->name = name;\n\tindio_dev->info = &ms5611_info;\n\tindio_dev->channels = ms5611_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ms5611_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = ms5611_scan_masks;\n\n\tret = ms5611_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t ms5611_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register iio device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms5611_probe, IIO_MS5611);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tduszyns@gmail.com>\");\nMODULE_DESCRIPTION(\"MS5611 core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}