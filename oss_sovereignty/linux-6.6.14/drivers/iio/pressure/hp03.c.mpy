{
  "module_name": "hp03.c",
  "hash_id": "b59d1a8e05dafc3a4cb3fa4a34dd130a77dfcc9f1380e0f7fc43ca77d52249ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/hp03.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"hp03: \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define HP03_EEPROM_ADDR\t\t0x50\n#define HP03_ADC_ADDR\t\t\t0x77\n\n#define HP03_EEPROM_CX_OFFSET\t\t0x10\n#define HP03_EEPROM_AB_OFFSET\t\t0x1e\n#define HP03_EEPROM_CD_OFFSET\t\t0x20\n\n#define HP03_ADC_WRITE_REG\t\t0xff\n#define HP03_ADC_READ_REG\t\t0xfd\n#define HP03_ADC_READ_PRESSURE\t\t0xf0\t \n#define HP03_ADC_READ_TEMP\t\t0xe8\t \n\nstruct hp03_priv {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\n\tstruct gpio_desc\t*xclr_gpio;\n\n\tstruct i2c_client\t*eeprom_client;\n\tstruct regmap\t\t*eeprom_regmap;\n\n\ts32\t\t\tpressure;\t \n\ts32\t\t\ttemp;\t\t \n};\n\nstatic const struct iio_chan_spec hp03_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic bool hp03_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic bool hp03_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic const struct regmap_config hp03_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\n\t.max_register\t= HP03_EEPROM_CD_OFFSET + 1,\n\t.cache_type\t= REGCACHE_RBTREE,\n\n\t.writeable_reg\t= hp03_is_writeable_reg,\n\t.volatile_reg\t= hp03_is_volatile_reg,\n};\n\nstatic int hp03_get_temp_pressure(struct hp03_priv *priv, const u8 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(priv->client, HP03_ADC_WRITE_REG, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(50);\t \n\n\treturn i2c_smbus_read_word_data(priv->client, HP03_ADC_READ_REG);\n}\n\nstatic int hp03_update_temp_pressure(struct hp03_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tu8 coefs[18];\n\tu16 cx_val[7];\n\tint ab_val, d1_val, d2_val, diff_val, dut, off, sens, x;\n\tint i, ret;\n\n\t \n\tret = regmap_bulk_read(priv->eeprom_regmap, HP03_EEPROM_CX_OFFSET,\n\t\t\t       coefs, sizeof(coefs));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read EEPROM (reg=%02x)\\n\",\n\t\t\tHP03_EEPROM_CX_OFFSET);\n\t\treturn ret;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(priv->xclr_gpio, 1);\n\n\tret = hp03_get_temp_pressure(priv, HP03_ADC_READ_PRESSURE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read pressure\\n\");\n\t\tgoto err_adc;\n\t}\n\td1_val = ret;\n\n\tret = hp03_get_temp_pressure(priv, HP03_ADC_READ_TEMP);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read temperature\\n\");\n\t\tgoto err_adc;\n\t}\n\td2_val = ret;\n\n\tgpiod_set_value_cansleep(priv->xclr_gpio, 0);\n\n\t \n\tfor (i = 0; i < 7; i++)\n\t\tcx_val[i] = (coefs[2 * i] << 8) | (coefs[(2 * i) + 1] << 0);\n\td1_val = ((d1_val >> 8) & 0xff) | ((d1_val & 0xff) << 8);\n\td2_val = ((d2_val >> 8) & 0xff) | ((d2_val & 0xff) << 8);\n\n\t \n\tif (d2_val >= cx_val[4])\n\t\tab_val = coefs[14];\t \n\telse\n\t\tab_val = coefs[15];\t \n\n\tdiff_val = d2_val - cx_val[4];\n\tdut = (ab_val * (diff_val >> 7) * (diff_val >> 7)) >> coefs[16];\n\tdut = diff_val - dut;\n\n\toff = (cx_val[1] + (((cx_val[3] - 1024) * dut) >> 14)) * 4;\n\tsens = cx_val[0] + ((cx_val[2] * dut) >> 10);\n\tx = ((sens * (d1_val - 7168)) >> 14) - off;\n\n\tpriv->pressure = ((x * 100) >> 5) + (cx_val[6] * 10);\n\tpriv->temp = 250 + ((dut * cx_val[5]) >> 16) - (dut >> coefs[17]);\n\n\treturn 0;\n\nerr_adc:\n\tgpiod_set_value_cansleep(priv->xclr_gpio, 0);\n\treturn ret;\n}\n\nstatic int hp03_read_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan,\n\t\t\t int *val, int *val2, long mask)\n{\n\tstruct hp03_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = hp03_update_temp_pressure(priv);\n\tmutex_unlock(&priv->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = priv->pressure;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_TEMP:\n\t\t\t*val = priv->temp;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info hp03_info = {\n\t.read_raw\t= &hp03_read_raw,\n};\n\nstatic int hp03_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct hp03_priv *priv;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->client = client;\n\tmutex_init(&priv->lock);\n\n\tindio_dev->name = id->name;\n\tindio_dev->channels = hp03_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(hp03_channels);\n\tindio_dev->info = &hp03_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tpriv->xclr_gpio = devm_gpiod_get_index(dev, \"xclr\", 0, GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->xclr_gpio)) {\n\t\tdev_err(dev, \"Failed to claim XCLR GPIO\\n\");\n\t\tret = PTR_ERR(priv->xclr_gpio);\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->eeprom_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\tHP03_EEPROM_ADDR);\n\tif (IS_ERR(priv->eeprom_client)) {\n\t\tdev_err(dev, \"New EEPROM I2C device failed\\n\");\n\t\treturn PTR_ERR(priv->eeprom_client);\n\t}\n\n\tpriv->eeprom_regmap = devm_regmap_init_i2c(priv->eeprom_client,\n\t\t\t\t\t\t   &hp03_regmap_config);\n\tif (IS_ERR(priv->eeprom_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate EEPROM regmap\\n\");\n\t\treturn PTR_ERR(priv->eeprom_regmap);\n\t}\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IIO device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id hp03_id[] = {\n\t{ \"hp03\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, hp03_id);\n\nstatic const struct of_device_id hp03_of_match[] = {\n\t{ .compatible = \"hoperf,hp03\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, hp03_of_match);\n\nstatic struct i2c_driver hp03_driver = {\n\t.driver = {\n\t\t.name\t= \"hp03\",\n\t\t.of_match_table = hp03_of_match,\n\t},\n\t.probe\t\t= hp03_probe,\n\t.id_table\t= hp03_id,\n};\nmodule_i2c_driver(hp03_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Driver for Hope RF HP03 pressure and temperature sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}