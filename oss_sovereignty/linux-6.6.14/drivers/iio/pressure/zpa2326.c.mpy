{
  "module_name": "zpa2326.c",
  "hash_id": "e69f6dbf4fd5a43e9b3377091cd2bf1d159a183116dfb5838eef482f833d19e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/zpa2326.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <asm/unaligned.h>\n#include \"zpa2326.h\"\n\n \n#define ZPA2326_CONVERSION_JIFFIES (HZ / 5)\n\n \n#define ZPA2326_TPUP_USEC_MIN      (1000)\n#define ZPA2326_TPUP_USEC_MAX      (2000)\n\n \nstruct zpa2326_frequency {\n\tint hz;\n\tu16 odr;\n};\n\n \nstatic const struct zpa2326_frequency zpa2326_sampling_frequencies[] = {\n\t{ .hz = 1,  .odr = 1 << ZPA2326_CTRL_REG3_ODR_SHIFT },\n\t{ .hz = 5,  .odr = 5 << ZPA2326_CTRL_REG3_ODR_SHIFT },\n\t{ .hz = 11, .odr = 6 << ZPA2326_CTRL_REG3_ODR_SHIFT },\n\t{ .hz = 23, .odr = 7 << ZPA2326_CTRL_REG3_ODR_SHIFT },\n};\n\n \nstatic const struct zpa2326_frequency *zpa2326_highest_frequency(void)\n{\n\treturn &zpa2326_sampling_frequencies[\n\t\tARRAY_SIZE(zpa2326_sampling_frequencies) - 1];\n}\n\n \nstruct zpa2326_private {\n\ts64                             timestamp;\n\tstruct regmap                  *regmap;\n\tint                             result;\n\tstruct completion               data_ready;\n\tstruct iio_trigger             *trigger;\n\tbool                            waken;\n\tint                             irq;\n\tconst struct zpa2326_frequency *frequency;\n\tstruct regulator               *vref;\n\tstruct regulator               *vdd;\n};\n\n#define zpa2326_err(idev, fmt, ...)\t\t\t\t\t\\\n\tdev_err(idev->dev.parent, fmt \"\\n\", ##__VA_ARGS__)\n\n#define zpa2326_warn(idev, fmt, ...)\t\t\t\t\t\\\n\tdev_warn(idev->dev.parent, fmt \"\\n\", ##__VA_ARGS__)\n\n#define zpa2326_dbg(idev, fmt, ...)\t\t\t\t\t\\\n\tdev_dbg(idev->dev.parent, fmt \"\\n\", ##__VA_ARGS__)\n\nbool zpa2326_isreg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ZPA2326_REF_P_XL_REG:\n\tcase ZPA2326_REF_P_L_REG:\n\tcase ZPA2326_REF_P_H_REG:\n\tcase ZPA2326_RES_CONF_REG:\n\tcase ZPA2326_CTRL_REG0_REG:\n\tcase ZPA2326_CTRL_REG1_REG:\n\tcase ZPA2326_CTRL_REG2_REG:\n\tcase ZPA2326_CTRL_REG3_REG:\n\tcase ZPA2326_THS_P_LOW_REG:\n\tcase ZPA2326_THS_P_HIGH_REG:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(zpa2326_isreg_writeable, IIO_ZPA2326);\n\nbool zpa2326_isreg_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ZPA2326_REF_P_XL_REG:\n\tcase ZPA2326_REF_P_L_REG:\n\tcase ZPA2326_REF_P_H_REG:\n\tcase ZPA2326_DEVICE_ID_REG:\n\tcase ZPA2326_RES_CONF_REG:\n\tcase ZPA2326_CTRL_REG0_REG:\n\tcase ZPA2326_CTRL_REG1_REG:\n\tcase ZPA2326_CTRL_REG2_REG:\n\tcase ZPA2326_CTRL_REG3_REG:\n\tcase ZPA2326_INT_SOURCE_REG:\n\tcase ZPA2326_THS_P_LOW_REG:\n\tcase ZPA2326_THS_P_HIGH_REG:\n\tcase ZPA2326_STATUS_REG:\n\tcase ZPA2326_PRESS_OUT_XL_REG:\n\tcase ZPA2326_PRESS_OUT_L_REG:\n\tcase ZPA2326_PRESS_OUT_H_REG:\n\tcase ZPA2326_TEMP_OUT_L_REG:\n\tcase ZPA2326_TEMP_OUT_H_REG:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(zpa2326_isreg_readable, IIO_ZPA2326);\n\nbool zpa2326_isreg_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ZPA2326_INT_SOURCE_REG:\n\tcase ZPA2326_PRESS_OUT_H_REG:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(zpa2326_isreg_precious, IIO_ZPA2326);\n\n \nstatic int zpa2326_enable_device(const struct iio_dev *indio_dev)\n{\n\tint err;\n\n\terr = regmap_write(((struct zpa2326_private *)\n\t\t\t    iio_priv(indio_dev))->regmap,\n\t\t\t    ZPA2326_CTRL_REG0_REG, ZPA2326_CTRL_REG0_ENABLE);\n\tif (err) {\n\t\tzpa2326_err(indio_dev, \"failed to enable device (%d)\", err);\n\t\treturn err;\n\t}\n\n\tzpa2326_dbg(indio_dev, \"enabled\");\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_sleep(const struct iio_dev *indio_dev)\n{\n\tint err;\n\n\terr = regmap_write(((struct zpa2326_private *)\n\t\t\t    iio_priv(indio_dev))->regmap,\n\t\t\t    ZPA2326_CTRL_REG0_REG, 0);\n\tif (err) {\n\t\tzpa2326_err(indio_dev, \"failed to sleep (%d)\", err);\n\t\treturn err;\n\t}\n\n\tzpa2326_dbg(indio_dev, \"sleeping\");\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_reset_device(const struct iio_dev *indio_dev)\n{\n\tint err;\n\n\terr = regmap_write(((struct zpa2326_private *)\n\t\t\t    iio_priv(indio_dev))->regmap,\n\t\t\t    ZPA2326_CTRL_REG2_REG, ZPA2326_CTRL_REG2_SWRESET);\n\tif (err) {\n\t\tzpa2326_err(indio_dev, \"failed to reset device (%d)\", err);\n\t\treturn err;\n\t}\n\n\tusleep_range(ZPA2326_TPUP_USEC_MIN, ZPA2326_TPUP_USEC_MAX);\n\n\tzpa2326_dbg(indio_dev, \"reset\");\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_start_oneshot(const struct iio_dev *indio_dev)\n{\n\tint err;\n\n\terr = regmap_write(((struct zpa2326_private *)\n\t\t\t    iio_priv(indio_dev))->regmap,\n\t\t\t    ZPA2326_CTRL_REG0_REG,\n\t\t\t    ZPA2326_CTRL_REG0_ENABLE |\n\t\t\t    ZPA2326_CTRL_REG0_ONE_SHOT);\n\tif (err) {\n\t\tzpa2326_err(indio_dev, \"failed to start one shot cycle (%d)\",\n\t\t\t    err);\n\t\treturn err;\n\t}\n\n\tzpa2326_dbg(indio_dev, \"one shot cycle started\");\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_power_on(const struct iio_dev         *indio_dev,\n\t\t\t    const struct zpa2326_private *private)\n{\n\tint err;\n\n\terr = regulator_enable(private->vref);\n\tif (err)\n\t\treturn err;\n\n\terr = regulator_enable(private->vdd);\n\tif (err)\n\t\tgoto vref;\n\n\tzpa2326_dbg(indio_dev, \"powered on\");\n\n\terr = zpa2326_enable_device(indio_dev);\n\tif (err)\n\t\tgoto vdd;\n\n\terr = zpa2326_reset_device(indio_dev);\n\tif (err)\n\t\tgoto sleep;\n\n\treturn 0;\n\nsleep:\n\tzpa2326_sleep(indio_dev);\nvdd:\n\tregulator_disable(private->vdd);\nvref:\n\tregulator_disable(private->vref);\n\n\tzpa2326_dbg(indio_dev, \"powered off\");\n\n\treturn err;\n}\n\n \nstatic void zpa2326_power_off(const struct iio_dev         *indio_dev,\n\t\t\t      const struct zpa2326_private *private)\n{\n\tregulator_disable(private->vdd);\n\tregulator_disable(private->vref);\n\n\tzpa2326_dbg(indio_dev, \"powered off\");\n}\n\n \nstatic int zpa2326_config_oneshot(const struct iio_dev *indio_dev,\n\t\t\t\t  int                   irq)\n{\n\tstruct regmap                  *regs = ((struct zpa2326_private *)\n\t\t\t\t\t\tiio_priv(indio_dev))->regmap;\n\tconst struct zpa2326_frequency *freq = zpa2326_highest_frequency();\n\tint                             err;\n\n\t \n\terr = regmap_write(regs, ZPA2326_CTRL_REG3_REG, freq->odr);\n\tif (err)\n\t\treturn err;\n\n\tif (irq > 0) {\n\t\t \n\t\terr = regmap_write(regs, ZPA2326_CTRL_REG1_REG,\n\t\t\t\t   (u8)~ZPA2326_CTRL_REG1_MASK_DATA_READY);\n\n\t\tif (err) {\n\t\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\t\"failed to setup one shot mode (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tzpa2326_dbg(indio_dev, \"one shot mode setup @%dHz\", freq->hz);\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_clear_fifo(const struct iio_dev *indio_dev,\n\t\t\t      unsigned int          min_count)\n{\n\tstruct regmap *regs = ((struct zpa2326_private *)\n\t\t\t       iio_priv(indio_dev))->regmap;\n\tint            err;\n\tunsigned int   val;\n\n\tif (!min_count) {\n\t\t \n\t\terr = regmap_read(regs, ZPA2326_STATUS_REG, &val);\n\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tif (val & ZPA2326_STATUS_FIFO_E)\n\t\t\t \n\t\t\treturn 0;\n\t}\n\n\t \n\tdo {\n\t\t \n\t\terr = regmap_read(regs, ZPA2326_PRESS_OUT_H_REG, &val);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tif (min_count) {\n\t\t\t \n\t\t\tmin_count--;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = regmap_read(regs, ZPA2326_STATUS_REG, &val);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t} while (!(val & ZPA2326_STATUS_FIFO_E));\n\n\tzpa2326_dbg(indio_dev, \"FIFO cleared\");\n\n\treturn 0;\n\nerr:\n\tzpa2326_err(indio_dev, \"failed to clear FIFO (%d)\", err);\n\n\treturn err;\n}\n\n \nstatic int zpa2326_dequeue_pressure(const struct iio_dev *indio_dev,\n\t\t\t\t    u32                  *pressure)\n{\n\tstruct regmap *regs = ((struct zpa2326_private *)\n\t\t\t       iio_priv(indio_dev))->regmap;\n\tunsigned int   val;\n\tint            err;\n\tint            cleared = -1;\n\n\terr = regmap_read(regs, ZPA2326_STATUS_REG, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\t*pressure = 0;\n\n\tif (val & ZPA2326_STATUS_P_OR) {\n\t\t \n\t\tzpa2326_warn(indio_dev, \"FIFO overflow\");\n\n\t\terr = regmap_bulk_read(regs, ZPA2326_PRESS_OUT_XL_REG, pressure,\n\t\t\t\t       3);\n\t\tif (err)\n\t\t\treturn err;\n\n#define ZPA2326_FIFO_DEPTH (16U)\n\t\t \n\t\treturn zpa2326_clear_fifo(indio_dev, ZPA2326_FIFO_DEPTH - 1);\n\t}\n\n\t \n\tdo {\n\t\terr = regmap_bulk_read(regs, ZPA2326_PRESS_OUT_XL_REG, pressure,\n\t\t\t\t       3);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = regmap_read(regs, ZPA2326_STATUS_REG, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tcleared++;\n\t} while (!(val & ZPA2326_STATUS_FIFO_E));\n\n\tif (cleared)\n\t\t \n\t\tzpa2326_dbg(indio_dev, \"cleared %d FIFO entries\", cleared);\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_fill_sample_buffer(struct iio_dev               *indio_dev,\n\t\t\t\t      const struct zpa2326_private *private)\n{\n\tstruct {\n\t\tu32 pressure;\n\t\tu16 temperature;\n\t\tu64 timestamp;\n\t}   sample;\n\tint err;\n\n\tif (test_bit(0, indio_dev->active_scan_mask)) {\n\t\t \n\t\terr = zpa2326_dequeue_pressure(indio_dev, &sample.pressure);\n\t\tif (err) {\n\t\t\tzpa2326_warn(indio_dev, \"failed to fetch pressure (%d)\",\n\t\t\t\t     err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (test_bit(1, indio_dev->active_scan_mask)) {\n\t\t \n\t\terr = regmap_bulk_read(private->regmap, ZPA2326_TEMP_OUT_L_REG,\n\t\t\t\t       &sample.temperature, 2);\n\t\tif (err) {\n\t\t\tzpa2326_warn(indio_dev,\n\t\t\t\t     \"failed to fetch temperature (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tzpa2326_dbg(indio_dev, \"filling raw samples buffer\");\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &sample,\n\t\t\t\t\t   private->timestamp);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int zpa2326_runtime_suspend(struct device *parent)\n{\n\tconst struct iio_dev *indio_dev = dev_get_drvdata(parent);\n\n\tif (pm_runtime_autosuspend_expiration(parent))\n\t\t \n\t\treturn -EAGAIN;\n\n\tzpa2326_power_off(indio_dev, iio_priv(indio_dev));\n\n\treturn 0;\n}\n\nstatic int zpa2326_runtime_resume(struct device *parent)\n{\n\tconst struct iio_dev *indio_dev = dev_get_drvdata(parent);\n\n\treturn zpa2326_power_on(indio_dev, iio_priv(indio_dev));\n}\n\nconst struct dev_pm_ops zpa2326_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(zpa2326_runtime_suspend, zpa2326_runtime_resume,\n\t\t\t   NULL)\n};\nEXPORT_SYMBOL_NS_GPL(zpa2326_pm_ops, IIO_ZPA2326);\n\n \nstatic int zpa2326_resume(const struct iio_dev *indio_dev)\n{\n\tint err;\n\n\terr = pm_runtime_get_sync(indio_dev->dev.parent);\n\tif (err < 0) {\n\t\tpm_runtime_put(indio_dev->dev.parent);\n\t\treturn err;\n\t}\n\n\tif (err > 0) {\n\t\t \n\t\tzpa2326_enable_device(indio_dev);\n\t\treturn 1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic void zpa2326_suspend(struct iio_dev *indio_dev)\n{\n\tstruct device *parent = indio_dev->dev.parent;\n\n\tzpa2326_sleep(indio_dev);\n\n\tpm_runtime_mark_last_busy(parent);\n\tpm_runtime_put_autosuspend(parent);\n}\n\nstatic void zpa2326_init_runtime(struct device *parent)\n{\n\tpm_runtime_get_noresume(parent);\n\tpm_runtime_set_active(parent);\n\tpm_runtime_enable(parent);\n\tpm_runtime_set_autosuspend_delay(parent, 1000);\n\tpm_runtime_use_autosuspend(parent);\n\tpm_runtime_mark_last_busy(parent);\n\tpm_runtime_put_autosuspend(parent);\n}\n\nstatic void zpa2326_fini_runtime(struct device *parent)\n{\n\tpm_runtime_disable(parent);\n\tpm_runtime_set_suspended(parent);\n}\n#else  \nstatic int zpa2326_resume(const struct iio_dev *indio_dev)\n{\n\tzpa2326_enable_device(indio_dev);\n\n\treturn 0;\n}\n\nstatic void zpa2326_suspend(struct iio_dev *indio_dev)\n{\n\tzpa2326_sleep(indio_dev);\n}\n\n#define zpa2326_init_runtime(_parent)\n#define zpa2326_fini_runtime(_parent)\n#endif  \n\n \nstatic irqreturn_t zpa2326_handle_irq(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\t \n\t\t((struct zpa2326_private *)\n\t\t iio_priv(indio_dev))->timestamp = iio_get_time_ns(indio_dev);\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t zpa2326_handle_threaded_irq(int irq, void *data)\n{\n\tstruct iio_dev         *indio_dev = data;\n\tstruct zpa2326_private *priv = iio_priv(indio_dev);\n\tunsigned int            val;\n\tbool                    cont;\n\tirqreturn_t             ret = IRQ_NONE;\n\n\t \n\tcont = (iio_buffer_enabled(indio_dev) &&\n\t\tiio_trigger_using_own(indio_dev));\n\n\t \n\tpriv->result = regmap_read(priv->regmap, ZPA2326_INT_SOURCE_REG, &val);\n\tif (priv->result < 0) {\n\t\tif (cont)\n\t\t\treturn IRQ_NONE;\n\n\t\tgoto complete;\n\t}\n\n\t \n\tif (!(val & ZPA2326_INT_SOURCE_DATA_READY)) {\n\t\t \n\t\tzpa2326_warn(indio_dev, \"unexpected interrupt status %02x\",\n\t\t\t     val);\n\n\t\tif (cont)\n\t\t\treturn IRQ_NONE;\n\n\t\tpriv->result = -ENODATA;\n\t\tgoto complete;\n\t}\n\n\t \n\tiio_trigger_poll_nested(priv->trigger);\n\n\tif (cont)\n\t\t \n\t\treturn IRQ_HANDLED;\n\n\tret = IRQ_HANDLED;\n\ncomplete:\n\t \n\tcomplete(&priv->data_ready);\n\n\treturn ret;\n}\n\n \nstatic int zpa2326_wait_oneshot_completion(const struct iio_dev   *indio_dev,\n\t\t\t\t\t   struct zpa2326_private *private)\n{\n\tunsigned int val;\n\tlong     timeout;\n\n\tzpa2326_dbg(indio_dev, \"waiting for one shot completion interrupt\");\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t&private->data_ready, ZPA2326_CONVERSION_JIFFIES);\n\tif (timeout > 0)\n\t\t \n\t\treturn private->result;\n\n\t \n\tregmap_read(private->regmap, ZPA2326_INT_SOURCE_REG, &val);\n\n\tif (!timeout) {\n\t\t \n\t\tzpa2326_warn(indio_dev, \"no one shot interrupt occurred (%ld)\",\n\t\t\t     timeout);\n\t\treturn -ETIME;\n\t}\n\n\tzpa2326_warn(indio_dev, \"wait for one shot interrupt cancelled\");\n\treturn -ERESTARTSYS;\n}\n\nstatic int zpa2326_init_managed_irq(struct device          *parent,\n\t\t\t\t    struct iio_dev         *indio_dev,\n\t\t\t\t    struct zpa2326_private *private,\n\t\t\t\t    int                     irq)\n{\n\tint err;\n\n\tprivate->irq = irq;\n\n\tif (irq <= 0) {\n\t\t \n\t\tdev_info(parent, \"no interrupt found, running in polling mode\");\n\t\treturn 0;\n\t}\n\n\tinit_completion(&private->data_ready);\n\n\t \n\terr = devm_request_threaded_irq(parent, irq, zpa2326_handle_irq,\n\t\t\t\t\tzpa2326_handle_threaded_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(parent), indio_dev);\n\tif (err) {\n\t\tdev_err(parent, \"failed to request interrupt %d (%d)\", irq,\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tdev_info(parent, \"using interrupt %d\", irq);\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_poll_oneshot_completion(const struct iio_dev *indio_dev)\n{\n\tunsigned long  tmout = jiffies + ZPA2326_CONVERSION_JIFFIES;\n\tstruct regmap *regs = ((struct zpa2326_private *)\n\t\t\t       iio_priv(indio_dev))->regmap;\n\tunsigned int   val;\n\tint            err;\n\n\tzpa2326_dbg(indio_dev, \"polling for one shot completion\");\n\n\t \n\tif (msleep_interruptible(100))\n\t\treturn -ERESTARTSYS;\n\n\t \n\twhile (true) {\n\t\terr = regmap_read(regs, ZPA2326_CTRL_REG0_REG, &val);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tif (!(val & ZPA2326_CTRL_REG0_ONE_SHOT))\n\t\t\t \n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, tmout)) {\n\t\t\t \n\t\t\terr = -ETIME;\n\t\t\tgoto err;\n\t\t}\n\n\t\tusleep_range(10000, 20000);\n\t}\n\n\t \n\terr = regmap_read(regs, ZPA2326_STATUS_REG, &val);\n\tif (err < 0)\n\t\tgoto err;\n\n\tif (!(val & ZPA2326_STATUS_P_DA)) {\n\t\t \n\t\terr = -ENODATA;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tzpa2326_warn(indio_dev, \"failed to poll one shot completion (%d)\", err);\n\n\treturn err;\n}\n\n \nstatic int zpa2326_fetch_raw_sample(const struct iio_dev *indio_dev,\n\t\t\t\t    enum iio_chan_type    type,\n\t\t\t\t    int                  *value)\n{\n\tstruct regmap *regs = ((struct zpa2326_private *)\n\t\t\t       iio_priv(indio_dev))->regmap;\n\tint            err;\n\tu8             v[3];\n\n\tswitch (type) {\n\tcase IIO_PRESSURE:\n\t\tzpa2326_dbg(indio_dev, \"fetching raw pressure sample\");\n\n\t\terr = regmap_bulk_read(regs, ZPA2326_PRESS_OUT_XL_REG, v, sizeof(v));\n\t\tif (err) {\n\t\t\tzpa2326_warn(indio_dev, \"failed to fetch pressure (%d)\",\n\t\t\t\t     err);\n\t\t\treturn err;\n\t\t}\n\n\t\t*value = get_unaligned_le24(&v[0]);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_TEMP:\n\t\tzpa2326_dbg(indio_dev, \"fetching raw temperature sample\");\n\n\t\terr = regmap_bulk_read(regs, ZPA2326_TEMP_OUT_L_REG, value, 2);\n\t\tif (err) {\n\t\t\tzpa2326_warn(indio_dev,\n\t\t\t\t     \"failed to fetch temperature (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\t*value = (int)le16_to_cpup((__le16 *)value);\n\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int zpa2326_sample_oneshot(struct iio_dev     *indio_dev,\n\t\t\t\t  enum iio_chan_type  type,\n\t\t\t\t  int                *value)\n{\n\tint                     ret;\n\tstruct zpa2326_private *priv;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zpa2326_resume(indio_dev);\n\tif (ret < 0)\n\t\tgoto release;\n\n\tpriv = iio_priv(indio_dev);\n\n\tif (ret > 0) {\n\t\t \n\t\tif (type == IIO_PRESSURE) {\n\t\t\tret = zpa2326_clear_fifo(indio_dev, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto suspend;\n\t\t}\n\t} else {\n\t\t \n\t\tret = zpa2326_config_oneshot(indio_dev, priv->irq);\n\t\tif (ret)\n\t\t\tgoto suspend;\n\t}\n\n\t \n\tret = zpa2326_start_oneshot(indio_dev);\n\tif (ret)\n\t\tgoto suspend;\n\n\t \n\tif (priv->irq > 0)\n\t\tret = zpa2326_wait_oneshot_completion(indio_dev, priv);\n\telse\n\t\tret = zpa2326_poll_oneshot_completion(indio_dev);\n\n\tif (ret)\n\t\tgoto suspend;\n\n\t \n\tret = zpa2326_fetch_raw_sample(indio_dev, type, value);\n\nsuspend:\n\tzpa2326_suspend(indio_dev);\nrelease:\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t zpa2326_trigger_handler(int irq, void *data)\n{\n\tstruct iio_dev         *indio_dev = ((struct iio_poll_func *)\n\t\t\t\t\t     data)->indio_dev;\n\tstruct zpa2326_private *priv = iio_priv(indio_dev);\n\tbool                    cont;\n\n\t \n\tcont = iio_trigger_using_own(indio_dev);\n\n\tif (!cont) {\n\t\t \n\t\tif (zpa2326_start_oneshot(indio_dev))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (priv->irq <= 0) {\n\t\t\t \n\t\t\tif (zpa2326_poll_oneshot_completion(indio_dev))\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tpriv->timestamp = iio_get_time_ns(indio_dev);\n\t\t} else {\n\t\t\t \n\t\t\tif (zpa2326_wait_oneshot_completion(indio_dev, priv))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tzpa2326_fill_sample_buffer(indio_dev, priv);\n\nout:\n\tif (!cont)\n\t\t \n\t\tzpa2326_sleep(indio_dev);\n\n\t \n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int zpa2326_preenable_buffer(struct iio_dev *indio_dev)\n{\n\tint ret = zpa2326_resume(indio_dev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t((struct zpa2326_private *)\n\t iio_priv(indio_dev))->waken = iio_priv(indio_dev);\n\n\treturn 0;\n}\n\n \nstatic int zpa2326_postenable_buffer(struct iio_dev *indio_dev)\n{\n\tconst struct zpa2326_private *priv = iio_priv(indio_dev);\n\tint                           err;\n\n\tif (!priv->waken) {\n\t\t \n\t\terr = zpa2326_clear_fifo(indio_dev, 0);\n\t\tif (err) {\n\t\t\tzpa2326_err(indio_dev,\n\t\t\t\t    \"failed to enable buffering (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!iio_trigger_using_own(indio_dev) && priv->waken) {\n\t\t \n\t\terr = zpa2326_config_oneshot(indio_dev, priv->irq);\n\t\tif (err) {\n\t\t\tzpa2326_err(indio_dev,\n\t\t\t\t    \"failed to enable buffering (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int zpa2326_postdisable_buffer(struct iio_dev *indio_dev)\n{\n\tzpa2326_suspend(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops zpa2326_buffer_setup_ops = {\n\t.preenable   = zpa2326_preenable_buffer,\n\t.postenable  = zpa2326_postenable_buffer,\n\t.postdisable = zpa2326_postdisable_buffer\n};\n\n \nstatic int zpa2326_set_trigger_state(struct iio_trigger *trig, bool state)\n{\n\tconst struct iio_dev         *indio_dev = dev_get_drvdata(\n\t\t\t\t\t\t\ttrig->dev.parent);\n\tconst struct zpa2326_private *priv = iio_priv(indio_dev);\n\tint                           err;\n\n\tif (!state) {\n\t\t \n\t\tunsigned int val;\n\n\t\t \n\t\tdisable_irq(priv->irq);\n\n\t\t \n\t\terr = regmap_write(priv->regmap, ZPA2326_CTRL_REG3_REG,\n\t\t\t\t   zpa2326_highest_frequency()->odr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_read(priv->regmap, ZPA2326_INT_SOURCE_REG, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tenable_irq(priv->irq);\n\n\t\tzpa2326_dbg(indio_dev, \"continuous mode stopped\");\n\t} else {\n\t\t \n\n\t\tif (priv->waken) {\n\t\t\t \n\t\t\terr = regmap_write(priv->regmap, ZPA2326_CTRL_REG1_REG,\n\t\t\t\t\t   (u8)\n\t\t\t\t\t   ~ZPA2326_CTRL_REG1_MASK_DATA_READY);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = regmap_write(priv->regmap, ZPA2326_CTRL_REG3_REG,\n\t\t\t\t   ZPA2326_CTRL_REG3_ENABLE_MEAS |\n\t\t\t\t   priv->frequency->odr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tzpa2326_dbg(indio_dev, \"continuous mode setup @%dHz\",\n\t\t\t    priv->frequency->hz);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops zpa2326_trigger_ops = {\n\t.set_trigger_state = zpa2326_set_trigger_state,\n};\n\n \nstatic int zpa2326_init_managed_trigger(struct device          *parent,\n\t\t\t\t\tstruct iio_dev         *indio_dev,\n\t\t\t\t\tstruct zpa2326_private *private,\n\t\t\t\t\tint                     irq)\n{\n\tstruct iio_trigger *trigger;\n\tint                 ret;\n\n\tif (irq <= 0)\n\t\treturn 0;\n\n\ttrigger = devm_iio_trigger_alloc(parent, \"%s-dev%d\",\n\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t iio_device_id(indio_dev));\n\tif (!trigger)\n\t\treturn -ENOMEM;\n\n\t \n\ttrigger->ops = &zpa2326_trigger_ops;\n\n\tprivate->trigger = trigger;\n\n\t \n\tret = devm_iio_trigger_register(parent, trigger);\n\tif (ret)\n\t\tdev_err(parent, \"failed to register hardware trigger (%d)\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int zpa2326_get_frequency(const struct iio_dev *indio_dev)\n{\n\treturn ((struct zpa2326_private *)iio_priv(indio_dev))->frequency->hz;\n}\n\nstatic int zpa2326_set_frequency(struct iio_dev *indio_dev, int hz)\n{\n\tstruct zpa2326_private *priv = iio_priv(indio_dev);\n\tint                     freq;\n\tint                     err;\n\n\t \n\tfor (freq = 0; freq < ARRAY_SIZE(zpa2326_sampling_frequencies); freq++)\n\t\tif (zpa2326_sampling_frequencies[freq].hz == hz)\n\t\t\tbreak;\n\tif (freq == ARRAY_SIZE(zpa2326_sampling_frequencies))\n\t\treturn -EINVAL;\n\n\t \n\terr = iio_device_claim_direct_mode(indio_dev);\n\tif (err)\n\t\treturn err;\n\n\tpriv->frequency = &zpa2326_sampling_frequencies[freq];\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn 0;\n}\n\n \nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"1 5 11 23\");\n\nstatic struct attribute *zpa2326_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group zpa2326_attribute_group = {\n\t.attrs = zpa2326_attributes,\n};\n\nstatic int zpa2326_read_raw(struct iio_dev             *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int                        *val,\n\t\t\t    int                        *val2,\n\t\t\t    long                        mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn zpa2326_sample_oneshot(indio_dev, chan->type, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t \n\t\t\t*val = 1;\n\t\t\t*val2 = 64000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 6;\n\t\t\t*val2 = 490000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = -17683000;\n\t\t\t*val2 = 649;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = zpa2326_get_frequency(indio_dev);\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int zpa2326_write_raw(struct iio_dev             *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     int                         val,\n\t\t\t     int                         val2,\n\t\t\t     long                        mask)\n{\n\tif ((mask != IIO_CHAN_INFO_SAMP_FREQ) || val2)\n\t\treturn -EINVAL;\n\n\treturn zpa2326_set_frequency(indio_dev, val);\n}\n\nstatic const struct iio_chan_spec zpa2326_channels[] = {\n\t[0] = {\n\t\t.type                    = IIO_PRESSURE,\n\t\t.scan_index              = 0,\n\t\t.scan_type               = {\n\t\t\t.sign                   = 'u',\n\t\t\t.realbits               = 24,\n\t\t\t.storagebits            = 32,\n\t\t\t.endianness             = IIO_LE,\n\t\t},\n\t\t.info_mask_separate      = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t[1] = {\n\t\t.type                    = IIO_TEMP,\n\t\t.scan_index              = 1,\n\t\t.scan_type               = {\n\t\t\t.sign                   = 's',\n\t\t\t.realbits               = 16,\n\t\t\t.storagebits            = 16,\n\t\t\t.endianness             = IIO_LE,\n\t\t},\n\t\t.info_mask_separate      = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t[2] = IIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic const struct iio_info zpa2326_info = {\n\t.attrs         = &zpa2326_attribute_group,\n\t.read_raw      = zpa2326_read_raw,\n\t.write_raw     = zpa2326_write_raw,\n};\n\nstatic struct iio_dev *zpa2326_create_managed_iiodev(struct device *device,\n\t\t\t\t\t\t     const char    *name,\n\t\t\t\t\t\t     struct regmap *regmap)\n{\n\tstruct iio_dev *indio_dev;\n\n\t \n\tindio_dev = devm_iio_device_alloc(device,\n\t\t\t\t\t  sizeof(struct zpa2326_private));\n\tif (!indio_dev)\n\t\treturn NULL;\n\n\t \n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = zpa2326_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(zpa2326_channels);\n\tindio_dev->name = name;\n\tindio_dev->info = &zpa2326_info;\n\n\treturn indio_dev;\n}\n\nint zpa2326_probe(struct device *parent,\n\t\t  const char    *name,\n\t\t  int            irq,\n\t\t  unsigned int   hwid,\n\t\t  struct regmap *regmap)\n{\n\tstruct iio_dev         *indio_dev;\n\tstruct zpa2326_private *priv;\n\tint                     err;\n\tunsigned int            id;\n\n\tindio_dev = zpa2326_create_managed_iiodev(parent, name, regmap);\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\n\tpriv->vref = devm_regulator_get(parent, \"vref\");\n\tif (IS_ERR(priv->vref))\n\t\treturn PTR_ERR(priv->vref);\n\n\tpriv->vdd = devm_regulator_get(parent, \"vdd\");\n\tif (IS_ERR(priv->vdd))\n\t\treturn PTR_ERR(priv->vdd);\n\n\t \n\tpriv->frequency = zpa2326_highest_frequency();\n\n\t \n\tpriv->regmap = regmap;\n\n\terr = devm_iio_triggered_buffer_setup(parent, indio_dev, NULL,\n\t\t\t\t\t      zpa2326_trigger_handler,\n\t\t\t\t\t      &zpa2326_buffer_setup_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = zpa2326_init_managed_trigger(parent, indio_dev, priv, irq);\n\tif (err)\n\t\treturn err;\n\n\terr = zpa2326_init_managed_irq(parent, indio_dev, priv, irq);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = zpa2326_power_on(indio_dev, priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_read(regmap, ZPA2326_DEVICE_ID_REG, &id);\n\tif (err)\n\t\tgoto sleep;\n\n\tif (id != hwid) {\n\t\tdev_err(parent, \"found device with unexpected id %02x\", id);\n\t\terr = -ENODEV;\n\t\tgoto sleep;\n\t}\n\n\terr = zpa2326_config_oneshot(indio_dev, irq);\n\tif (err)\n\t\tgoto sleep;\n\n\t \n\terr = zpa2326_sleep(indio_dev);\n\tif (err)\n\t\tgoto poweroff;\n\n\tdev_set_drvdata(parent, indio_dev);\n\n\tzpa2326_init_runtime(parent);\n\n\terr = iio_device_register(indio_dev);\n\tif (err) {\n\t\tzpa2326_fini_runtime(parent);\n\t\tgoto poweroff;\n\t}\n\n\treturn 0;\n\nsleep:\n\t \n\tzpa2326_sleep(indio_dev);\npoweroff:\n\tzpa2326_power_off(indio_dev, priv);\n\n\treturn err;\n}\nEXPORT_SYMBOL_NS_GPL(zpa2326_probe, IIO_ZPA2326);\n\nvoid zpa2326_remove(const struct device *parent)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(parent);\n\n\tiio_device_unregister(indio_dev);\n\tzpa2326_fini_runtime(indio_dev->dev.parent);\n\tzpa2326_sleep(indio_dev);\n\tzpa2326_power_off(indio_dev, iio_priv(indio_dev));\n}\nEXPORT_SYMBOL_NS_GPL(zpa2326_remove, IIO_ZPA2326);\n\nMODULE_AUTHOR(\"Gregor Boirie <gregor.boirie@parrot.com>\");\nMODULE_DESCRIPTION(\"Core driver for Murata ZPA2326 pressure sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}