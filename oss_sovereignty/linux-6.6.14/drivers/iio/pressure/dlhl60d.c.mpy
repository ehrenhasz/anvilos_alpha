{
  "module_name": "dlhl60d.c",
  "hash_id": "4c68c0078bd2636aeafb9eeb666d18e0e91a04a95bb262c9207e9d1ec5271e9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/dlhl60d.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <asm/unaligned.h>\n\n \n#define DLH_START_SINGLE    0xAA\n\n \n#define DLH_STATUS_OK       0x40\n\n \n#define DLH_NUM_READ_BYTES  7\n#define DLH_NUM_DATA_BYTES  3\n#define DLH_NUM_PR_BITS     24\n#define DLH_NUM_TEMP_BITS   24\n\n \n#define DLH_SINGLE_DUT_MS   5\n\nenum dhl_ids {\n\tdlhl60d,\n\tdlhl60g,\n};\n\nstruct dlh_info {\n\tu8 osdig;            \n\tunsigned int fss;    \n};\n\nstruct dlh_state {\n\tstruct i2c_client *client;\n\tstruct dlh_info info;\n\tbool use_interrupt;\n\tstruct completion completion;\n\tu8 rx_buf[DLH_NUM_READ_BYTES];\n};\n\nstatic struct dlh_info dlh_info_tbl[] = {\n\t[dlhl60d] = {\n\t\t.osdig = 2,\n\t\t.fss = 120,\n\t},\n\t[dlhl60g] = {\n\t\t.osdig = 10,\n\t\t.fss = 60,\n\t},\n};\n\n\nstatic int dlh_cmd_start_single(struct dlh_state *st)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte(st->client, DLH_START_SINGLE);\n\tif (ret)\n\t\tdev_err(&st->client->dev,\n\t\t\t\"%s: I2C write byte failed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int dlh_cmd_read_data(struct dlh_state *st)\n{\n\tint ret;\n\n\tret = i2c_master_recv(st->client, st->rx_buf, DLH_NUM_READ_BYTES);\n\tif (ret < 0) {\n\t\tdev_err(&st->client->dev,\n\t\t\t\"%s: I2C read block failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (st->rx_buf[0] != DLH_STATUS_OK) {\n\t\tdev_err(&st->client->dev,\n\t\t\t\"%s: invalid status 0x%02x\\n\", __func__, st->rx_buf[0]);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int dlh_start_capture_and_read(struct dlh_state *st)\n{\n\tint ret;\n\n\tif (st->use_interrupt)\n\t\treinit_completion(&st->completion);\n\n\tret = dlh_cmd_start_single(st);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->use_interrupt) {\n\t\tret = wait_for_completion_timeout(&st->completion,\n\t\t\tmsecs_to_jiffies(DLH_SINGLE_DUT_MS));\n\t\tif (!ret) {\n\t\t\tdev_err(&st->client->dev,\n\t\t\t\t\"%s: conversion timed out\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tmdelay(DLH_SINGLE_DUT_MS);\n\t}\n\n\treturn dlh_cmd_read_data(st);\n}\n\nstatic int dlh_read_direct(struct dlh_state *st,\n\tunsigned int *pressure, unsigned int *temperature)\n{\n\tint ret;\n\n\tret = dlh_start_capture_and_read(st);\n\tif (ret)\n\t\treturn ret;\n\n\t*pressure = get_unaligned_be24(&st->rx_buf[1]);\n\t*temperature = get_unaligned_be24(&st->rx_buf[4]);\n\n\treturn 0;\n}\n\nstatic int dlh_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *channel, int *value,\n\tint *value2, long mask)\n{\n\tstruct dlh_state *st = iio_priv(indio_dev);\n\tunsigned int pressure, temperature;\n\tint ret;\n\ts64 tmp;\n\ts32 rem;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = dlh_read_direct(st, &pressure, &temperature);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (channel->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*value = pressure;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase IIO_TEMP:\n\t\t\t*value = temperature;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (channel->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\ttmp = div_s64(125LL * st->info.fss * 24909 * 100,\n\t\t\t\t1 << DLH_NUM_PR_BITS);\n\t\t\ttmp = div_s64_rem(tmp, 1000000000LL, &rem);\n\t\t\t*value = tmp;\n\t\t\t*value2 = rem;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\t\tcase IIO_TEMP:\n\t\t\t*value = 125 * 1000;\n\t\t\t*value2 = DLH_NUM_TEMP_BITS;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (channel->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*value = -125 * st->info.fss * 24909;\n\t\t\t*value2 = 100 * st->info.osdig * 100000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase IIO_TEMP:\n\t\t\t*value = -40 * 1000;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info dlh_info = {\n\t.read_raw = dlh_read_raw,\n};\n\nstatic const struct iio_chan_spec dlh_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.indexed = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type =\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = DLH_NUM_PR_BITS,\n\t\t\t.storagebits = 32,\n\t\t\t.shift = 8,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type =\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = DLH_NUM_TEMP_BITS,\n\t\t\t.storagebits = 32,\n\t\t\t.shift = 8,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t}\n};\n\nstatic irqreturn_t dlh_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct dlh_state *st = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int chn, i = 0;\n\t__be32 tmp_buf[2];\n\n\tret = dlh_start_capture_and_read(st);\n\tif (ret)\n\t\tgoto out;\n\n\tfor_each_set_bit(chn, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tmemcpy(tmp_buf + i,\n\t\t\t&st->rx_buf[1] + chn * DLH_NUM_DATA_BYTES,\n\t\t\tDLH_NUM_DATA_BYTES);\n\t\ti++;\n\t}\n\n\tiio_push_to_buffers(indio_dev, tmp_buf);\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dlh_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct dlh_state *st = iio_priv(indio_dev);\n\n\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n};\n\nstatic int dlh_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct dlh_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\tI2C_FUNC_I2C | I2C_FUNC_SMBUS_WRITE_BYTE)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"adapter doesn't support required i2c functionality\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"failed to allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tst = iio_priv(indio_dev);\n\tst->info = dlh_info_tbl[id->driver_data];\n\tst->client = client;\n\tst->use_interrupt = false;\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &dlh_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels =  dlh_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(dlh_channels);\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\tdlh_interrupt, NULL,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\tid->name, indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to allocate threaded irq\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tst->use_interrupt = true;\n\t\tinit_completion(&st->completion);\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,\n\t\tNULL, &dlh_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to setup iio buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(&client->dev, indio_dev);\n\tif (ret)\n\t\tdev_err(&client->dev, \"failed to register iio device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id dlh_of_match[] = {\n\t{ .compatible = \"asc,dlhl60d\" },\n\t{ .compatible = \"asc,dlhl60g\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dlh_of_match);\n\nstatic const struct i2c_device_id dlh_id[] = {\n\t{ \"dlhl60d\",    dlhl60d },\n\t{ \"dlhl60g\",    dlhl60g },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, dlh_id);\n\nstatic struct i2c_driver dlh_driver = {\n\t.driver = {\n\t\t.name = \"dlhl60d\",\n\t\t.of_match_table = dlh_of_match,\n\t},\n\t.probe = dlh_probe,\n\t.id_table = dlh_id,\n};\nmodule_i2c_driver(dlh_driver);\n\nMODULE_AUTHOR(\"Tomislav Denis <tomislav.denis@avl.com>\");\nMODULE_DESCRIPTION(\"Driver for All Sensors DLH series pressure sensors\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}