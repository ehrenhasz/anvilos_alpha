{
  "module_name": "dps310.c",
  "hash_id": "fcdaf5fea21317aed279709da94a2095686464d0fcd1290865e74cff0706c3b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/dps310.c",
  "human_readable_source": "\n\n \n\n#include <linux/i2c.h>\n#include <linux/limits.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define DPS310_DEV_NAME\t\t\"dps310\"\n\n#define DPS310_PRS_B0\t\t0x00\n#define DPS310_PRS_B1\t\t0x01\n#define DPS310_PRS_B2\t\t0x02\n#define DPS310_TMP_B0\t\t0x03\n#define DPS310_TMP_B1\t\t0x04\n#define DPS310_TMP_B2\t\t0x05\n#define DPS310_PRS_CFG\t\t0x06\n#define  DPS310_PRS_RATE_BITS\tGENMASK(6, 4)\n#define  DPS310_PRS_PRC_BITS\tGENMASK(3, 0)\n#define DPS310_TMP_CFG\t\t0x07\n#define  DPS310_TMP_RATE_BITS\tGENMASK(6, 4)\n#define  DPS310_TMP_PRC_BITS\tGENMASK(3, 0)\n#define  DPS310_TMP_EXT\t\tBIT(7)\n#define DPS310_MEAS_CFG\t\t0x08\n#define  DPS310_MEAS_CTRL_BITS\tGENMASK(2, 0)\n#define   DPS310_PRS_EN\t\tBIT(0)\n#define   DPS310_TEMP_EN\tBIT(1)\n#define   DPS310_BACKGROUND\tBIT(2)\n#define  DPS310_PRS_RDY\t\tBIT(4)\n#define  DPS310_TMP_RDY\t\tBIT(5)\n#define  DPS310_SENSOR_RDY\tBIT(6)\n#define  DPS310_COEF_RDY\tBIT(7)\n#define DPS310_CFG_REG\t\t0x09\n#define  DPS310_INT_HL\t\tBIT(7)\n#define  DPS310_TMP_SHIFT_EN\tBIT(3)\n#define  DPS310_PRS_SHIFT_EN\tBIT(4)\n#define  DPS310_FIFO_EN\t\tBIT(5)\n#define  DPS310_SPI_EN\t\tBIT(6)\n#define DPS310_RESET\t\t0x0c\n#define  DPS310_RESET_MAGIC\t0x09\n#define DPS310_COEF_BASE\t0x10\n\n \n#define DPS310_POLL_SLEEP_US(t)\t\tmin(30000, (t) / 8)\n \n#define DPS310_POLL_TIMEOUT_US(rc)\t((rc) <= 0 ? 1000000 : 1000000 / (rc))\n\n#define DPS310_PRS_BASE\t\tDPS310_PRS_B0\n#define DPS310_TMP_BASE\t\tDPS310_TMP_B0\n\n \nstatic const int scale_factors[] = {\n\t 524288,\n\t1572864,\n\t3670016,\n\t7864320,\n\t 253952,\n\t 516096,\n\t1040384,\n\t2088960,\n};\n\nstruct dps310_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\t \n\n\ts32 c0, c1;\n\ts32 c00, c10, c20, c30, c01, c11, c21;\n\ts32 pressure_raw;\n\ts32 temp_raw;\n\tbool timeout_recovery_failed;\n};\n\nstatic const struct iio_chan_spec dps310_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\tBIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\tBIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n};\n\n \nstatic int dps310_get_coefs(struct dps310_data *data)\n{\n\tint rc;\n\tu8 coef[18];\n\tu32 c0, c1;\n\tu32 c00, c10, c20, c30, c01, c11, c21;\n\n\t \n\trc = regmap_bulk_read(data->regmap, DPS310_COEF_BASE, coef,\n\t\t\t      sizeof(coef));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tc0 = (coef[0] << 4) | (coef[1] >> 4);\n\tdata->c0 = sign_extend32(c0, 11);\n\n\tc1 = ((coef[1] & GENMASK(3, 0)) << 8) | coef[2];\n\tdata->c1 = sign_extend32(c1, 11);\n\n\t \n\tc00 = (coef[3] << 12) | (coef[4] << 4) | (coef[5] >> 4);\n\tdata->c00 = sign_extend32(c00, 19);\n\n\tc10 = ((coef[5] & GENMASK(3, 0)) << 16) | (coef[6] << 8) | coef[7];\n\tdata->c10 = sign_extend32(c10, 19);\n\n\tc01 = (coef[8] << 8) | coef[9];\n\tdata->c01 = sign_extend32(c01, 15);\n\n\tc11 = (coef[10] << 8) | coef[11];\n\tdata->c11 = sign_extend32(c11, 15);\n\n\tc20 = (coef[12] << 8) | coef[13];\n\tdata->c20 = sign_extend32(c20, 15);\n\n\tc21 = (coef[14] << 8) | coef[15];\n\tdata->c21 = sign_extend32(c21, 15);\n\n\tc30 = (coef[16] << 8) | coef[17];\n\tdata->c30 = sign_extend32(c30, 15);\n\n\treturn 0;\n}\n\n \nstatic int dps310_temp_workaround(struct dps310_data *data)\n{\n\tint rc;\n\tint reg;\n\n\trc = regmap_read(data->regmap, 0x32, &reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (reg & BIT(1))\n\t\treturn 0;\n\n\trc = regmap_write(data->regmap, 0x0e, 0xA5);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_write(data->regmap, 0x0f, 0x96);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_write(data->regmap, 0x62, 0x02);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_write(data->regmap, 0x0e, 0x00);\n\tif (rc)\n\t\treturn rc;\n\n\treturn regmap_write(data->regmap, 0x0f, 0x00);\n}\n\nstatic int dps310_startup(struct dps310_data *data)\n{\n\tint rc;\n\tint ready;\n\n\t \n\trc = regmap_write(data->regmap, DPS310_PRS_CFG, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write(data->regmap, DPS310_TMP_CFG, DPS310_TMP_EXT);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write_bits(data->regmap, DPS310_CFG_REG,\n\t\t\t       DPS310_PRS_SHIFT_EN | DPS310_TMP_SHIFT_EN, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write_bits(data->regmap, DPS310_MEAS_CFG,\n\t\t\t       DPS310_MEAS_CTRL_BITS, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write_bits(data->regmap, DPS310_MEAS_CFG,\n\t\t\t       DPS310_MEAS_CTRL_BITS, DPS310_PRS_EN |\n\t\t\t       DPS310_TEMP_EN | DPS310_BACKGROUND);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_read_poll_timeout(data->regmap, DPS310_MEAS_CFG, ready,\n\t\t\t\t      ready & DPS310_COEF_RDY, 10000, 40000);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dps310_get_coefs(data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn dps310_temp_workaround(data);\n}\n\nstatic int dps310_get_pres_precision(struct dps310_data *data)\n{\n\tint rc;\n\tint val;\n\n\trc = regmap_read(data->regmap, DPS310_PRS_CFG, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn BIT(val & GENMASK(2, 0));\n}\n\nstatic int dps310_get_temp_precision(struct dps310_data *data)\n{\n\tint rc;\n\tint val;\n\n\trc = regmap_read(data->regmap, DPS310_TMP_CFG, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\treturn BIT(val & GENMASK(2, 0));\n}\n\n \nstatic int dps310_set_pres_precision(struct dps310_data *data, int val)\n{\n\tint rc;\n\tu8 shift_en;\n\n\tif (val < 0 || val > 128)\n\t\treturn -EINVAL;\n\n\tshift_en = val >= 16 ? DPS310_PRS_SHIFT_EN : 0;\n\trc = regmap_write_bits(data->regmap, DPS310_CFG_REG,\n\t\t\t       DPS310_PRS_SHIFT_EN, shift_en);\n\tif (rc)\n\t\treturn rc;\n\n\treturn regmap_update_bits(data->regmap, DPS310_PRS_CFG,\n\t\t\t\t  DPS310_PRS_PRC_BITS, ilog2(val));\n}\n\n \nstatic int dps310_set_temp_precision(struct dps310_data *data, int val)\n{\n\tint rc;\n\tu8 shift_en;\n\n\tif (val < 0 || val > 128)\n\t\treturn -EINVAL;\n\n\tshift_en = val >= 16 ? DPS310_TMP_SHIFT_EN : 0;\n\trc = regmap_write_bits(data->regmap, DPS310_CFG_REG,\n\t\t\t       DPS310_TMP_SHIFT_EN, shift_en);\n\tif (rc)\n\t\treturn rc;\n\n\treturn regmap_update_bits(data->regmap, DPS310_TMP_CFG,\n\t\t\t\t  DPS310_TMP_PRC_BITS, ilog2(val));\n}\n\n \nstatic int dps310_set_pres_samp_freq(struct dps310_data *data, int freq)\n{\n\tu8 val;\n\n\tif (freq < 0 || freq > 128)\n\t\treturn -EINVAL;\n\n\tval = ilog2(freq) << 4;\n\n\treturn regmap_update_bits(data->regmap, DPS310_PRS_CFG,\n\t\t\t\t  DPS310_PRS_RATE_BITS, val);\n}\n\n \nstatic int dps310_set_temp_samp_freq(struct dps310_data *data, int freq)\n{\n\tu8 val;\n\n\tif (freq < 0 || freq > 128)\n\t\treturn -EINVAL;\n\n\tval = ilog2(freq) << 4;\n\n\treturn regmap_update_bits(data->regmap, DPS310_TMP_CFG,\n\t\t\t\t  DPS310_TMP_RATE_BITS, val);\n}\n\nstatic int dps310_get_pres_samp_freq(struct dps310_data *data)\n{\n\tint rc;\n\tint val;\n\n\trc = regmap_read(data->regmap, DPS310_PRS_CFG, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn BIT((val & DPS310_PRS_RATE_BITS) >> 4);\n}\n\nstatic int dps310_get_temp_samp_freq(struct dps310_data *data)\n{\n\tint rc;\n\tint val;\n\n\trc = regmap_read(data->regmap, DPS310_TMP_CFG, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn BIT((val & DPS310_TMP_RATE_BITS) >> 4);\n}\n\nstatic int dps310_get_pres_k(struct dps310_data *data)\n{\n\tint rc = dps310_get_pres_precision(data);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn scale_factors[ilog2(rc)];\n}\n\nstatic int dps310_get_temp_k(struct dps310_data *data)\n{\n\tint rc = dps310_get_temp_precision(data);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn scale_factors[ilog2(rc)];\n}\n\nstatic int dps310_reset_wait(struct dps310_data *data)\n{\n\tint rc;\n\n\trc = regmap_write(data->regmap, DPS310_RESET, DPS310_RESET_MAGIC);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tusleep_range(15000, 55000);\n\treturn 0;\n}\n\nstatic int dps310_reset_reinit(struct dps310_data *data)\n{\n\tint rc;\n\n\trc = dps310_reset_wait(data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn dps310_startup(data);\n}\n\nstatic int dps310_ready_status(struct dps310_data *data, int ready_bit, int timeout)\n{\n\tint sleep = DPS310_POLL_SLEEP_US(timeout);\n\tint ready;\n\n\treturn regmap_read_poll_timeout(data->regmap, DPS310_MEAS_CFG, ready, ready & ready_bit,\n\t\t\t\t\tsleep, timeout);\n}\n\nstatic int dps310_ready(struct dps310_data *data, int ready_bit, int timeout)\n{\n\tint rc;\n\n\trc = dps310_ready_status(data, ready_bit, timeout);\n\tif (rc) {\n\t\tif (rc == -ETIMEDOUT && !data->timeout_recovery_failed) {\n\t\t\t \n\t\t\tif (dps310_reset_reinit(data)) {\n\t\t\t\tdata->timeout_recovery_failed = true;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (dps310_ready_status(data, ready_bit, timeout))\n\t\t\t\t\tdata->timeout_recovery_failed = true;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tdata->timeout_recovery_failed = false;\n\treturn 0;\n}\n\nstatic int dps310_read_pres_raw(struct dps310_data *data)\n{\n\tint rc;\n\tint rate;\n\tint timeout;\n\ts32 raw;\n\tu8 val[3];\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -EINTR;\n\n\trate = dps310_get_pres_samp_freq(data);\n\ttimeout = DPS310_POLL_TIMEOUT_US(rate);\n\n\t \n\trc = dps310_ready(data, DPS310_PRS_RDY, timeout);\n\tif (rc)\n\t\tgoto done;\n\n\trc = regmap_bulk_read(data->regmap, DPS310_PRS_BASE, val, sizeof(val));\n\tif (rc < 0)\n\t\tgoto done;\n\n\traw = (val[0] << 16) | (val[1] << 8) | val[2];\n\tdata->pressure_raw = sign_extend32(raw, 23);\n\ndone:\n\tmutex_unlock(&data->lock);\n\treturn rc;\n}\n\n \nstatic int dps310_read_temp_ready(struct dps310_data *data)\n{\n\tint rc;\n\tu8 val[3];\n\ts32 raw;\n\n\trc = regmap_bulk_read(data->regmap, DPS310_TMP_BASE, val, sizeof(val));\n\tif (rc < 0)\n\t\treturn rc;\n\n\traw = (val[0] << 16) | (val[1] << 8) | val[2];\n\tdata->temp_raw = sign_extend32(raw, 23);\n\n\treturn 0;\n}\n\nstatic int dps310_read_temp_raw(struct dps310_data *data)\n{\n\tint rc;\n\tint rate;\n\tint timeout;\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -EINTR;\n\n\trate = dps310_get_temp_samp_freq(data);\n\ttimeout = DPS310_POLL_TIMEOUT_US(rate);\n\n\t \n\trc = dps310_ready(data, DPS310_TMP_RDY, timeout);\n\tif (rc)\n\t\tgoto done;\n\n\trc = dps310_read_temp_ready(data);\n\ndone:\n\tmutex_unlock(&data->lock);\n\treturn rc;\n}\n\nstatic bool dps310_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DPS310_PRS_CFG:\n\tcase DPS310_TMP_CFG:\n\tcase DPS310_MEAS_CFG:\n\tcase DPS310_CFG_REG:\n\tcase DPS310_RESET:\n\t \n\tcase 0x0e:\n\tcase 0x0f:\n\tcase 0x62:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool dps310_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DPS310_PRS_B0:\n\tcase DPS310_PRS_B1:\n\tcase DPS310_PRS_B2:\n\tcase DPS310_TMP_B0:\n\tcase DPS310_TMP_B1:\n\tcase DPS310_TMP_B2:\n\tcase DPS310_MEAS_CFG:\n\tcase 0x32:\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int dps310_write_raw(struct iio_dev *iio,\n\t\t\t    struct iio_chan_spec const *chan, int val,\n\t\t\t    int val2, long mask)\n{\n\tint rc;\n\tstruct dps310_data *data = iio_priv(iio);\n\n\tif (mutex_lock_interruptible(&data->lock))\n\t\treturn -EINTR;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\trc = dps310_set_pres_samp_freq(data, val);\n\t\t\tbreak;\n\n\t\tcase IIO_TEMP:\n\t\t\trc = dps310_set_temp_samp_freq(data, val);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\trc = dps310_set_pres_precision(data, val);\n\t\t\tbreak;\n\n\t\tcase IIO_TEMP:\n\t\t\trc = dps310_set_temp_precision(data, val);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn rc;\n}\n\nstatic int dps310_calculate_pressure(struct dps310_data *data)\n{\n\tint i;\n\tint rc;\n\tint t_ready;\n\tint kpi = dps310_get_pres_k(data);\n\tint kti = dps310_get_temp_k(data);\n\ts64 rem = 0ULL;\n\ts64 pressure = 0ULL;\n\ts64 p;\n\ts64 t;\n\ts64 denoms[7];\n\ts64 nums[7];\n\ts64 rems[7];\n\ts64 kp;\n\ts64 kt;\n\n\tif (kpi < 0)\n\t\treturn kpi;\n\n\tif (kti < 0)\n\t\treturn kti;\n\n\tkp = (s64)kpi;\n\tkt = (s64)kti;\n\n\t \n\tif (mutex_trylock(&data->lock)) {\n\t\trc = regmap_read(data->regmap, DPS310_MEAS_CFG, &t_ready);\n\t\tif (rc >= 0 && t_ready & DPS310_TMP_RDY)\n\t\t\tdps310_read_temp_ready(data);\n\n\t\tmutex_unlock(&data->lock);\n\t}\n\n\tp = (s64)data->pressure_raw;\n\tt = (s64)data->temp_raw;\n\n\t \n\tnums[0] = (s64)data->c00;\n\tdenoms[0] = 1LL;\n\tnums[1] = p * (s64)data->c10;\n\tdenoms[1] = kp;\n\tnums[2] = p * p * (s64)data->c20;\n\tdenoms[2] = kp * kp;\n\tnums[3] = p * p * p * (s64)data->c30;\n\tdenoms[3] = kp * kp * kp;\n\tnums[4] = t * (s64)data->c01;\n\tdenoms[4] = kt;\n\tnums[5] = t * p * (s64)data->c11;\n\tdenoms[5] = kp * kt;\n\tnums[6] = t * p * p * (s64)data->c21;\n\tdenoms[6] = kp * kp * kt;\n\n\t \n\tfor (i = 0; i < 7; ++i) {\n\t\tu64 irem;\n\n\t\tif (nums[i] < 0LL) {\n\t\t\tpressure -= div64_u64_rem(-nums[i], denoms[i], &irem);\n\t\t\trems[i] = -irem;\n\t\t} else {\n\t\t\tpressure += div64_u64_rem(nums[i], denoms[i], &irem);\n\t\t\trems[i] = (s64)irem;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 7; ++i)\n\t\trem += div64_s64((s64)rems[i] * 1000000000LL, denoms[i]);\n\n\tpressure += div_s64(rem, 1000000000LL);\n\tif (pressure < 0LL)\n\t\treturn -ERANGE;\n\n\treturn (int)min_t(s64, pressure, INT_MAX);\n}\n\nstatic int dps310_read_pressure(struct dps310_data *data, int *val, int *val2,\n\t\t\t\tlong mask)\n{\n\tint rc;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trc = dps310_get_pres_samp_freq(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\trc = dps310_read_pres_raw(data);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = dps310_calculate_pressure(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\t*val2 = 1000;  \n\t\treturn IIO_VAL_FRACTIONAL;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\trc = dps310_get_pres_precision(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dps310_calculate_temp(struct dps310_data *data)\n{\n\ts64 c0;\n\ts64 t;\n\tint kt = dps310_get_temp_k(data);\n\n\tif (kt < 0)\n\t\treturn kt;\n\n\t \n\tc0 = div_s64((s64)kt * (s64)data->c0, 2);\n\n\t \n\tt = c0 + ((s64)data->temp_raw * (s64)data->c1);\n\n\t \n\treturn (int)div_s64(t * 1000LL, kt);\n}\n\nstatic int dps310_read_temp(struct dps310_data *data, int *val, int *val2,\n\t\t\t    long mask)\n{\n\tint rc;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trc = dps310_get_temp_samp_freq(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\trc = dps310_read_temp_raw(data);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = dps310_calculate_temp(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\trc = dps310_get_temp_precision(data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t*val = rc;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dps310_read_raw(struct iio_dev *iio,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct dps310_data *data = iio_priv(iio);\n\n\tswitch (chan->type) {\n\tcase IIO_PRESSURE:\n\t\treturn dps310_read_pressure(data, val, val2, mask);\n\n\tcase IIO_TEMP:\n\t\treturn dps310_read_temp(data, val, val2, mask);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void dps310_reset(void *action_data)\n{\n\tstruct dps310_data *data = action_data;\n\n\tdps310_reset_wait(data);\n}\n\nstatic const struct regmap_config dps310_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = dps310_is_writeable_reg,\n\t.volatile_reg = dps310_is_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0x62,  \n};\n\nstatic const struct iio_info dps310_info = {\n\t.read_raw = dps310_read_raw,\n\t.write_raw = dps310_write_raw,\n};\n\nstatic int dps310_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct dps310_data *data;\n\tstruct iio_dev *iio;\n\tint rc;\n\n\tiio = devm_iio_device_alloc(&client->dev,  sizeof(*data));\n\tif (!iio)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(iio);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tiio->name = id->name;\n\tiio->channels = dps310_channels;\n\tiio->num_channels = ARRAY_SIZE(dps310_channels);\n\tiio->info = &dps310_info;\n\tiio->modes = INDIO_DIRECT_MODE;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &dps310_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\t \n\trc = devm_add_action_or_reset(&client->dev, dps310_reset, data);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dps310_startup(data);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_iio_device_register(&client->dev, iio);\n\tif (rc)\n\t\treturn rc;\n\n\ti2c_set_clientdata(client, iio);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id dps310_id[] = {\n\t{ DPS310_DEV_NAME, 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, dps310_id);\n\nstatic const struct acpi_device_id dps310_acpi_match[] = {\n\t{ \"IFX3100\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, dps310_acpi_match);\n\nstatic struct i2c_driver dps310_driver = {\n\t.driver = {\n\t\t.name = DPS310_DEV_NAME,\n\t\t.acpi_match_table = dps310_acpi_match,\n\t},\n\t.probe = dps310_probe,\n\t.id_table = dps310_id,\n};\nmodule_i2c_driver(dps310_driver);\n\nMODULE_AUTHOR(\"Joel Stanley <joel@jms.id.au>\");\nMODULE_DESCRIPTION(\"Infineon DPS310 pressure and temperature sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}