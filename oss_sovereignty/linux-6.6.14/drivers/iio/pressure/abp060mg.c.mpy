{
  "module_name": "abp060mg.c",
  "hash_id": "20a22bc7699367d1154068606b3d69d56aab4814c609c68ab9e1365e02c6fccb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/abp060mg.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n\n#define ABP060MG_ERROR_MASK   0xC000\n#define ABP060MG_RESP_TIME_MS 40\n#define ABP060MG_MIN_COUNTS   1638   \n#define ABP060MG_MAX_COUNTS   14745  \n#define ABP060MG_NUM_COUNTS   (ABP060MG_MAX_COUNTS - ABP060MG_MIN_COUNTS)\n\nenum abp_variant {\n\t \n\tABP006KG, ABP010KG, ABP016KG, ABP025KG, ABP040KG, ABP060KG, ABP100KG,\n\tABP160KG, ABP250KG, ABP400KG, ABP600KG, ABP001GG,\n\t \n\tABP006KD, ABP010KD, ABP016KD, ABP025KD, ABP040KD, ABP060KD, ABP100KD,\n\tABP160KD, ABP250KD, ABP400KD,\n\t \n\tABP001PG, ABP005PG, ABP015PG, ABP030PG, ABP060PG, ABP100PG, ABP150PG,\n\t \n\tABP001PD, ABP005PD, ABP015PD, ABP030PD, ABP060PD,\n};\n\nstruct abp_config {\n\tint min;\n\tint max;\n};\n\nstatic struct abp_config abp_config[] = {\n\t \n\t[ABP006KG] = { .min =       0, .max =     6000 },\n\t[ABP010KG] = { .min =       0, .max =    10000 },\n\t[ABP016KG] = { .min =       0, .max =    16000 },\n\t[ABP025KG] = { .min =       0, .max =    25000 },\n\t[ABP040KG] = { .min =       0, .max =    40000 },\n\t[ABP060KG] = { .min =       0, .max =    60000 },\n\t[ABP100KG] = { .min =       0, .max =   100000 },\n\t[ABP160KG] = { .min =       0, .max =   160000 },\n\t[ABP250KG] = { .min =       0, .max =   250000 },\n\t[ABP400KG] = { .min =       0, .max =   400000 },\n\t[ABP600KG] = { .min =       0, .max =   600000 },\n\t[ABP001GG] = { .min =       0, .max =  1000000 },\n\t[ABP006KD] = { .min =   -6000, .max =     6000 },\n\t[ABP010KD] = { .min =  -10000, .max =    10000 },\n\t[ABP016KD] = { .min =  -16000, .max =    16000 },\n\t[ABP025KD] = { .min =  -25000, .max =    25000 },\n\t[ABP040KD] = { .min =  -40000, .max =    40000 },\n\t[ABP060KD] = { .min =  -60000, .max =    60000 },\n\t[ABP100KD] = { .min = -100000, .max =   100000 },\n\t[ABP160KD] = { .min = -160000, .max =   160000 },\n\t[ABP250KD] = { .min = -250000, .max =   250000 },\n\t[ABP400KD] = { .min = -400000, .max =   400000 },\n\t \n\t[ABP001PG] = { .min =       0, .max =     6985 },\n\t[ABP005PG] = { .min =       0, .max =    34474 },\n\t[ABP015PG] = { .min =       0, .max =   103421 },\n\t[ABP030PG] = { .min =       0, .max =   206843 },\n\t[ABP060PG] = { .min =       0, .max =   413686 },\n\t[ABP100PG] = { .min =       0, .max =   689476 },\n\t[ABP150PG] = { .min =       0, .max =  1034214 },\n\t[ABP001PD] = { .min =   -6895, .max =     6895 },\n\t[ABP005PD] = { .min =  -34474, .max =    34474 },\n\t[ABP015PD] = { .min = -103421, .max =   103421 },\n\t[ABP030PD] = { .min = -206843, .max =   206843 },\n\t[ABP060PD] = { .min = -413686, .max =   413686 },\n};\n\nstruct abp_state {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\n\t \n\tint mreq_len;\n\n\t \n\tint scale;\n\tint offset;\n};\n\nstatic const struct iio_chan_spec abp060mg_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic int abp060mg_get_measurement(struct abp_state *state, int *val)\n{\n\tstruct i2c_client *client = state->client;\n\t__be16 buf[2];\n\tu16 pressure;\n\tint ret;\n\n\tbuf[0] = 0;\n\tret = i2c_master_send(client, (u8 *)&buf, state->mreq_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep_interruptible(ABP060MG_RESP_TIME_MS);\n\n\tret = i2c_master_recv(client, (u8 *)&buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpressure = be16_to_cpu(buf[0]);\n\tif (pressure & ABP060MG_ERROR_MASK)\n\t\treturn -EIO;\n\n\tif (pressure < ABP060MG_MIN_COUNTS || pressure > ABP060MG_MAX_COUNTS)\n\t\treturn -EIO;\n\n\t*val = pressure;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int abp060mg_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\tint *val2, long mask)\n{\n\tstruct abp_state *state = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = abp060mg_get_measurement(state, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = state->offset;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = state->scale;\n\t\t*val2 = ABP060MG_NUM_COUNTS * 1000;  \n\t\tret = IIO_VAL_FRACTIONAL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info abp060mg_info = {\n\t.read_raw = abp060mg_read_raw,\n};\n\nstatic void abp060mg_init_device(struct iio_dev *indio_dev, unsigned long id)\n{\n\tstruct abp_state *state = iio_priv(indio_dev);\n\tstruct abp_config *cfg = &abp_config[id];\n\n\tstate->scale = cfg->max - cfg->min;\n\tstate->offset = -ABP060MG_MIN_COUNTS;\n\n\tif (cfg->min < 0)  \n\t\tstate->offset -= ABP060MG_NUM_COUNTS >> 1;\n}\n\nstatic int abp060mg_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct abp_state *state;\n\tunsigned long cfg_id = id->driver_data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tstate = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, state);\n\tstate->client = client;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_QUICK))\n\t\tstate->mreq_len = 1;\n\n\tabp060mg_init_device(indio_dev, cfg_id);\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &abp060mg_info;\n\n\tindio_dev->channels = abp060mg_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(abp060mg_channels);\n\n\tmutex_init(&state->lock);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id abp060mg_id_table[] = {\n\t \n\t \n\t{ \"abp060mg\", ABP006KG }, { \"abp006kg\", ABP006KG },\n\t{ \"abp100mg\", ABP010KG }, { \"abp010kg\", ABP010KG },\n\t{ \"abp160mg\", ABP016KG }, { \"abp016kg\", ABP016KG },\n\t{ \"abp250mg\", ABP025KG }, { \"abp025kg\", ABP025KG },\n\t{ \"abp400mg\", ABP040KG }, { \"abp040kg\", ABP040KG },\n\t{ \"abp600mg\", ABP060KG }, { \"abp060kg\", ABP060KG },\n\t{ \"abp001bg\", ABP100KG }, { \"abp100kg\", ABP100KG },\n\t{ \"abp1_6bg\", ABP160KG }, { \"abp160kg\", ABP160KG },\n\t{ \"abp2_5bg\", ABP250KG }, { \"abp250kg\", ABP250KG },\n\t{ \"abp004bg\", ABP400KG }, { \"abp400kg\", ABP400KG },\n\t{ \"abp006bg\", ABP600KG }, { \"abp600kg\", ABP600KG },\n\t{ \"abp010bg\", ABP001GG }, { \"abp001gg\", ABP001GG },\n\t \n\t{ \"abp060md\", ABP006KD }, { \"abp006kd\", ABP006KD },\n\t{ \"abp100md\", ABP010KD }, { \"abp010kd\", ABP010KD },\n\t{ \"abp160md\", ABP016KD }, { \"abp016kd\", ABP016KD },\n\t{ \"abp250md\", ABP025KD }, { \"abp025kd\", ABP025KD },\n\t{ \"abp400md\", ABP040KD }, { \"abp040kd\", ABP040KD },\n\t{ \"abp600md\", ABP060KD }, { \"abp060kd\", ABP060KD },\n\t{ \"abp001bd\", ABP100KD }, { \"abp100kd\", ABP100KD },\n\t{ \"abp1_6bd\", ABP160KD }, { \"abp160kd\", ABP160KD },\n\t{ \"abp2_5bd\", ABP250KD }, { \"abp250kd\", ABP250KD },\n\t{ \"abp004bd\", ABP400KD }, { \"abp400kd\", ABP400KD },\n\t \n\t \n\t{ \"abp001pg\", ABP001PG },\n\t{ \"abp005pg\", ABP005PG },\n\t{ \"abp015pg\", ABP015PG },\n\t{ \"abp030pg\", ABP030PG },\n\t{ \"abp060pg\", ABP060PG },\n\t{ \"abp100pg\", ABP100PG },\n\t{ \"abp150pg\", ABP150PG },\n\t \n\t{ \"abp001pd\", ABP001PD },\n\t{ \"abp005pd\", ABP005PD },\n\t{ \"abp015pd\", ABP015PD },\n\t{ \"abp030pd\", ABP030PD },\n\t{ \"abp060pd\", ABP060PD },\n\t{   },\n};\nMODULE_DEVICE_TABLE(i2c, abp060mg_id_table);\n\nstatic struct i2c_driver abp060mg_driver = {\n\t.driver = {\n\t\t.name = \"abp060mg\",\n\t},\n\t.probe = abp060mg_probe,\n\t.id_table = abp060mg_id_table,\n};\nmodule_i2c_driver(abp060mg_driver);\n\nMODULE_AUTHOR(\"Marcin Malagowski <mrc@bourne.st>\");\nMODULE_DESCRIPTION(\"Honeywell ABP pressure sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}