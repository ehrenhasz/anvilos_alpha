{
  "module_name": "hp206c.c",
  "hash_id": "b3e07f3b0449806ab7d74924a9a45776ff28be06b7e0fe7b6936d9706b6e5525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/hp206c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/delay.h>\n#include <linux/util_macros.h>\n#include <linux/acpi.h>\n\n#include <asm/unaligned.h>\n\n \n#define HP206C_CMD_SOFT_RST\t0x06\n\n#define HP206C_CMD_ADC_CVT\t0x40\n\n#define HP206C_CMD_ADC_CVT_OSR_4096\t0x00\n#define HP206C_CMD_ADC_CVT_OSR_2048\t0x04\n#define HP206C_CMD_ADC_CVT_OSR_1024\t0x08\n#define HP206C_CMD_ADC_CVT_OSR_512\t0x0c\n#define HP206C_CMD_ADC_CVT_OSR_256\t0x10\n#define HP206C_CMD_ADC_CVT_OSR_128\t0x14\n\n#define HP206C_CMD_ADC_CVT_CHNL_PT\t0x00\n#define HP206C_CMD_ADC_CVT_CHNL_T\t0x02\n\n#define HP206C_CMD_READ_P\t0x30\n#define HP206C_CMD_READ_T\t0x32\n\n#define HP206C_CMD_READ_REG\t0x80\n#define HP206C_CMD_WRITE_REG\t0xc0\n\n#define HP206C_REG_INT_EN\t0x0b\n#define HP206C_REG_INT_CFG\t0x0c\n\n#define HP206C_REG_INT_SRC\t0x0d\n#define HP206C_FLAG_DEV_RDY\t0x40\n\n#define HP206C_REG_PARA\t\t0x0f\n#define HP206C_FLAG_CMPS_EN\t0x80\n\n \n#define HP206C_MAX_DEV_RDY_WAIT_COUNT 20\n#define HP206C_DEV_RDY_WAIT_US    20000\n\nstruct hp206c_data {\n\tstruct mutex mutex;\n\tstruct i2c_client *client;\n\tint temp_osr_index;\n\tint pres_osr_index;\n};\n\nstruct hp206c_osr_setting {\n\tu8 osr_mask;\n\tunsigned int temp_conv_time_us;\n\tunsigned int pres_conv_time_us;\n};\n\n \nstatic const struct hp206c_osr_setting hp206c_osr_settings[] = {\n\t{ HP206C_CMD_ADC_CVT_OSR_4096,\t65600,\t131100\t},\n\t{ HP206C_CMD_ADC_CVT_OSR_2048,\t32800,\t65600\t},\n\t{ HP206C_CMD_ADC_CVT_OSR_1024,\t16400,\t32800\t},\n\t{ HP206C_CMD_ADC_CVT_OSR_512,\t8200,\t16400\t},\n\t{ HP206C_CMD_ADC_CVT_OSR_256,\t4100,\t8200\t},\n\t{ HP206C_CMD_ADC_CVT_OSR_128,\t2100,\t4100\t},\n};\nstatic const int hp206c_osr_rates[] = { 4096, 2048, 1024, 512, 256, 128 };\nstatic const char hp206c_osr_rates_str[] = \"4096 2048 1024 512 256 128\";\n\nstatic inline int hp206c_read_reg(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, HP206C_CMD_READ_REG | reg);\n}\n\nstatic inline int hp206c_write_reg(struct i2c_client *client, u8 reg, u8 val)\n{\n\treturn i2c_smbus_write_byte_data(client,\n\t\t\tHP206C_CMD_WRITE_REG | reg, val);\n}\n\nstatic int hp206c_read_20bit(struct i2c_client *client, u8 cmd)\n{\n\tint ret;\n\tu8 values[3];\n\n\tret = i2c_smbus_read_i2c_block_data(client, cmd, sizeof(values), values);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(values))\n\t\treturn -EIO;\n\treturn get_unaligned_be24(&values[0]) & GENMASK(19, 0);\n}\n\n \nstatic int hp206c_wait_dev_rdy(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tint count = 0;\n\tstruct hp206c_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\twhile (++count <= HP206C_MAX_DEV_RDY_WAIT_COUNT) {\n\t\tret = hp206c_read_reg(client, HP206C_REG_INT_SRC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed READ_REG INT_SRC: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret & HP206C_FLAG_DEV_RDY)\n\t\t\treturn 0;\n\t\tusleep_range(HP206C_DEV_RDY_WAIT_US, HP206C_DEV_RDY_WAIT_US * 3 / 2);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int hp206c_set_compensation(struct i2c_client *client, bool enabled)\n{\n\tint val;\n\n\tval = hp206c_read_reg(client, HP206C_REG_PARA);\n\tif (val < 0)\n\t\treturn val;\n\tif (enabled)\n\t\tval |= HP206C_FLAG_CMPS_EN;\n\telse\n\t\tval &= ~HP206C_FLAG_CMPS_EN;\n\n\treturn hp206c_write_reg(client, HP206C_REG_PARA, val);\n}\n\n \nstatic int hp206c_soft_reset(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct hp206c_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = i2c_smbus_write_byte(client, HP206C_CMD_SOFT_RST);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to reset device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(400, 600);\n\n\tret = hp206c_wait_dev_rdy(indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Device not ready after soft reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hp206c_set_compensation(client, true);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Failed to enable compensation: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hp206c_conv_and_read(struct iio_dev *indio_dev,\n\t\t\t\tu8 conv_cmd, u8 read_cmd,\n\t\t\t\tunsigned int sleep_us)\n{\n\tint ret;\n\tstruct hp206c_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = hp206c_wait_dev_rdy(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"Device not ready: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte(client, conv_cmd);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"Failed convert: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(sleep_us, sleep_us * 3 / 2);\n\n\tret = hp206c_wait_dev_rdy(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"Device not ready: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hp206c_read_20bit(client, read_cmd);\n\tif (ret < 0)\n\t\tdev_err(&indio_dev->dev, \"Failed read: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hp206c_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tint ret;\n\tstruct hp206c_data *data = iio_priv(indio_dev);\n\tconst struct hp206c_osr_setting *osr_setting;\n\tu8 conv_cmd;\n\n\tmutex_lock(&data->mutex);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = hp206c_osr_rates[data->temp_osr_index];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = hp206c_osr_rates[data->pres_osr_index];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tosr_setting = &hp206c_osr_settings[data->temp_osr_index];\n\t\t\tconv_cmd = HP206C_CMD_ADC_CVT |\n\t\t\t\t\tosr_setting->osr_mask |\n\t\t\t\t\tHP206C_CMD_ADC_CVT_CHNL_T;\n\t\t\tret = hp206c_conv_and_read(indio_dev,\n\t\t\t\t\tconv_cmd,\n\t\t\t\t\tHP206C_CMD_READ_T,\n\t\t\t\t\tosr_setting->temp_conv_time_us);\n\t\t\tif (ret >= 0) {\n\t\t\t\t \n\t\t\t\t*val = sign_extend32(ret, 19);\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IIO_PRESSURE:\n\t\t\tosr_setting = &hp206c_osr_settings[data->pres_osr_index];\n\t\t\tconv_cmd = HP206C_CMD_ADC_CVT |\n\t\t\t\t\tosr_setting->osr_mask |\n\t\t\t\t\tHP206C_CMD_ADC_CVT_CHNL_PT;\n\t\t\tret = hp206c_conv_and_read(indio_dev,\n\t\t\t\t\tconv_cmd,\n\t\t\t\t\tHP206C_CMD_READ_P,\n\t\t\t\t\tosr_setting->pres_conv_time_us);\n\t\t\tif (ret >= 0) {\n\t\t\t\t*val = ret;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = 0;\n\t\t\t*val2 = 10000;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int hp206c_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tint ret = 0;\n\tstruct hp206c_data *data = iio_priv(indio_dev);\n\n\tif (mask != IIO_CHAN_INFO_OVERSAMPLING_RATIO)\n\t\treturn -EINVAL;\n\tmutex_lock(&data->mutex);\n\tswitch (chan->type) {\n\tcase IIO_TEMP:\n\t\tdata->temp_osr_index = find_closest_descending(val,\n\t\t\thp206c_osr_rates, ARRAY_SIZE(hp206c_osr_rates));\n\t\tbreak;\n\tcase IIO_PRESSURE:\n\t\tdata->pres_osr_index = find_closest_descending(val,\n\t\t\thp206c_osr_rates, ARRAY_SIZE(hp206c_osr_rates));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic const struct iio_chan_spec hp206c_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t}\n};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(hp206c_osr_rates_str);\n\nstatic struct attribute *hp206c_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hp206c_attribute_group = {\n\t.attrs = hp206c_attributes,\n};\n\nstatic const struct iio_info hp206c_info = {\n\t.attrs = &hp206c_attribute_group,\n\t.read_raw = hp206c_read_raw,\n\t.write_raw = hp206c_write_raw,\n};\n\nstatic int hp206c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct hp206c_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tdev_err(&client->dev, \"Adapter does not support \"\n\t\t\t\t\"all required i2c functionality\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->mutex);\n\n\tindio_dev->info = &hp206c_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = hp206c_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(hp206c_channels);\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\t \n\tret = hp206c_soft_reset(indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to reset on startup: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id hp206c_id[] = {\n\t{\"hp206c\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, hp206c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id hp206c_acpi_match[] = {\n\t{\"HOP206C\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, hp206c_acpi_match);\n#endif\n\nstatic struct i2c_driver hp206c_driver = {\n\t.probe = hp206c_probe,\n\t.id_table = hp206c_id,\n\t.driver = {\n\t\t.name = \"hp206c\",\n\t\t.acpi_match_table = ACPI_PTR(hp206c_acpi_match),\n\t},\n};\n\nmodule_i2c_driver(hp206c_driver);\n\nMODULE_DESCRIPTION(\"HOPERF HP206C precision barometer and altimeter sensor\");\nMODULE_AUTHOR(\"Leonard Crestez <leonard.crestez@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}