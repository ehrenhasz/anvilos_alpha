{
  "module_name": "bmp280-spi.c",
  "hash_id": "599660816b75d195e9cce202db18d770f11c308e76efde47c8c830a341fa2b2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/bmp280-spi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n\n#include \"bmp280.h\"\n\nstatic int bmp280_regmap_spi_write(void *context, const void *data,\n                                   size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tu8 buf[2];\n\n\tmemcpy(buf, data, 2);\n\t \n\tbuf[0] &= ~0x80;\n\n\treturn spi_write_then_read(spi, buf, 2, NULL, 0);\n}\n\nstatic int bmp280_regmap_spi_read(void *context, const void *reg,\n                                  size_t reg_size, void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write_then_read(spi, reg, reg_size, val, val_size);\n}\n\nstatic struct regmap_bus bmp280_regmap_bus = {\n\t.write = bmp280_regmap_spi_write,\n\t.read = bmp280_regmap_spi_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic int bmp280_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tconst struct bmp280_chip_info *chip_info;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"spi_setup failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tchip_info = device_get_match_data(&spi->dev);\n\tif (!chip_info)\n\t\tchip_info = (const struct bmp280_chip_info *) id->driver_data;\n\n\tregmap = devm_regmap_init(&spi->dev,\n\t\t\t\t  &bmp280_regmap_bus,\n\t\t\t\t  &spi->dev,\n\t\t\t\t  chip_info->regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn bmp280_common_probe(&spi->dev,\n\t\t\t\t   regmap,\n\t\t\t\t   chip_info,\n\t\t\t\t   id->name,\n\t\t\t\t   spi->irq);\n}\n\nstatic const struct of_device_id bmp280_of_spi_match[] = {\n\t{ .compatible = \"bosch,bmp085\", .data = &bmp180_chip_info },\n\t{ .compatible = \"bosch,bmp180\", .data = &bmp180_chip_info },\n\t{ .compatible = \"bosch,bmp181\", .data = &bmp180_chip_info },\n\t{ .compatible = \"bosch,bmp280\", .data = &bmp280_chip_info },\n\t{ .compatible = \"bosch,bme280\", .data = &bmp280_chip_info },\n\t{ .compatible = \"bosch,bmp380\", .data = &bmp380_chip_info },\n\t{ .compatible = \"bosch,bmp580\", .data = &bmp580_chip_info },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bmp280_of_spi_match);\n\nstatic const struct spi_device_id bmp280_spi_id[] = {\n\t{ \"bmp180\", (kernel_ulong_t)&bmp180_chip_info },\n\t{ \"bmp181\", (kernel_ulong_t)&bmp180_chip_info },\n\t{ \"bmp280\", (kernel_ulong_t)&bmp280_chip_info },\n\t{ \"bme280\", (kernel_ulong_t)&bmp280_chip_info },\n\t{ \"bmp380\", (kernel_ulong_t)&bmp380_chip_info },\n\t{ \"bmp580\", (kernel_ulong_t)&bmp580_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, bmp280_spi_id);\n\nstatic struct spi_driver bmp280_spi_driver = {\n\t.driver = {\n\t\t.name = \"bmp280\",\n\t\t.of_match_table = bmp280_of_spi_match,\n\t\t.pm = pm_ptr(&bmp280_dev_pm_ops),\n\t},\n\t.id_table = bmp280_spi_id,\n\t.probe = bmp280_spi_probe,\n};\nmodule_spi_driver(bmp280_spi_driver);\n\nMODULE_DESCRIPTION(\"BMP280 SPI bus driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_BMP280);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}