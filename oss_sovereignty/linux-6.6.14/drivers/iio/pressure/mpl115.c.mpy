{
  "module_name": "mpl115.c",
  "hash_id": "d5906a30aa5210a2b487316f864564e9993112d0db191726593e4340b46109b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/mpl115.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n\n#include \"mpl115.h\"\n\n#define MPL115_PADC 0x00  \n#define MPL115_TADC 0x02  \n#define MPL115_A0 0x04  \n#define MPL115_B1 0x06  \n#define MPL115_B2 0x08  \n#define MPL115_C12 0x0a  \n#define MPL115_CONVERT 0x12  \n\nstruct mpl115_data {\n\tstruct device *dev;\n\tstruct mutex lock;\n\ts16 a0;\n\ts16 b1, b2;\n\ts16 c12;\n\tstruct gpio_desc *shutdown;\n\tconst struct mpl115_ops *ops;\n};\n\nstatic int mpl115_request(struct mpl115_data *data)\n{\n\tint ret = data->ops->write(data->dev, MPL115_CONVERT, 0);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(3000, 4000);\n\n\treturn 0;\n}\n\nstatic int mpl115_comp_pressure(struct mpl115_data *data, int *val, int *val2)\n{\n\tint ret;\n\tu16 padc, tadc;\n\tint a1, y1, pcomp;\n\tunsigned kpa;\n\n\tmutex_lock(&data->lock);\n\tret = mpl115_request(data);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = data->ops->read(data->dev, MPL115_PADC);\n\tif (ret < 0)\n\t\tgoto done;\n\tpadc = ret >> 6;\n\n\tret = data->ops->read(data->dev, MPL115_TADC);\n\tif (ret < 0)\n\t\tgoto done;\n\ttadc = ret >> 6;\n\n\t \n\ta1 = data->b1 + ((data->c12 * tadc) >> 11);\n\ty1 = (data->a0 << 10) + a1 * padc;\n\n\t \n\tpcomp = (y1 + ((data->b2 * (int) tadc) >> 1)) >> 9;\n\n\tkpa = pcomp * (115 - 50) / 1023 + (50 << 4);\n\t*val = kpa >> 4;\n\t*val2 = (kpa & 15) * (1000000 >> 4);\ndone:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int mpl115_read_temp(struct mpl115_data *data)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = mpl115_request(data);\n\tif (ret < 0)\n\t\tgoto done;\n\tret = data->ops->read(data->dev, MPL115_TADC);\ndone:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int mpl115_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mpl115_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tpm_runtime_get_sync(data->dev);\n\t\tret = mpl115_comp_pressure(data, val, val2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tpm_runtime_get_sync(data->dev);\n\t\t \n\t\tret = mpl115_read_temp(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\t\t*val = ret >> 6;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -605;\n\t\t*val2 = 750000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = -186;\n\t\t*val2 = 915888;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec mpl115_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type =\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct iio_info mpl115_info = {\n\t.read_raw = &mpl115_read_raw,\n};\n\nint mpl115_probe(struct device *dev, const char *name,\n\t\t\tconst struct mpl115_ops *ops)\n{\n\tstruct mpl115_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = dev;\n\tdata->ops = ops;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &mpl115_info;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mpl115_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mpl115_channels);\n\n\tret = data->ops->init(data->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\tret = data->ops->read(data->dev, MPL115_A0);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->a0 = ret;\n\tret = data->ops->read(data->dev, MPL115_B1);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->b1 = ret;\n\tret = data->ops->read(data->dev, MPL115_B2);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->b2 = ret;\n\tret = data->ops->read(data->dev, MPL115_C12);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->c12 = ret;\n\n\tdata->shutdown = devm_gpiod_get_optional(dev, \"shutdown\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(data->shutdown))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->shutdown),\n\t\t\t\t     \"cannot get shutdown gpio\\n\");\n\n\tif (data->shutdown) {\n\t\t \n\t\tpm_runtime_get_noresume(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\n\t\t \n\t\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\t\tpm_runtime_use_autosuspend(dev);\n\t\tpm_runtime_put(dev);\n\n\t\tdev_dbg(dev, \"low-power mode enabled\");\n\t} else\n\t\tdev_dbg(dev, \"low-power mode disabled\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(mpl115_probe, IIO_MPL115);\n\nstatic int mpl115_runtime_suspend(struct device *dev)\n{\n\tstruct mpl115_data *data = iio_priv(dev_get_drvdata(dev));\n\n\tgpiod_set_value(data->shutdown, 1);\n\n\treturn 0;\n}\n\nstatic int mpl115_runtime_resume(struct device *dev)\n{\n\tstruct mpl115_data *data = iio_priv(dev_get_drvdata(dev));\n\n\tgpiod_set_value(data->shutdown, 0);\n\tusleep_range(5000, 6000);\n\n\treturn 0;\n}\n\nEXPORT_NS_RUNTIME_DEV_PM_OPS(mpl115_dev_pm_ops, mpl115_runtime_suspend,\n\t\t\t  mpl115_runtime_resume, NULL, IIO_MPL115);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Freescale MPL115 pressure/temperature driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}