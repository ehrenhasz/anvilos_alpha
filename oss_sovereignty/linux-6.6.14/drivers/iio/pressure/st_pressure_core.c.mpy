{
  "module_name": "st_pressure_core.c",
  "hash_id": "b55ba9c72d6e5d34dc74a6be2c94f4e54ebf30075b16cae0775355c03b51e62f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/st_pressure_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <asm/unaligned.h>\n\n#include <linux/iio/common/st_sensors.h>\n#include \"st_pressure.h\"\n\n \n\n#define MCELSIUS_PER_CELSIUS\t\t\t1000\n\n \n#define ST_PRESS_LSB_PER_MBAR\t\t\t4096UL\n#define ST_PRESS_KPASCAL_NANO_SCALE\t\t(100000000UL / \\\n\t\t\t\t\t\t ST_PRESS_LSB_PER_MBAR)\n\n \n#define ST_PRESS_LSB_PER_CELSIUS\t\t480UL\n#define ST_PRESS_MILLI_CELSIUS_OFFSET\t\t42500UL\n\n \n#define ST_PRESS_FS_AVL_1100MB\t\t\t1100\n#define ST_PRESS_FS_AVL_1260MB\t\t\t1260\n\n#define ST_PRESS_1_OUT_XL_ADDR\t\t\t0x28\n#define ST_TEMP_1_OUT_L_ADDR\t\t\t0x2b\n\n \n#define ST_PRESS_LPS001WP_LSB_PER_MBAR\t\t16UL\n \n#define ST_PRESS_LPS001WP_LSB_PER_CELSIUS\t64UL\n \n#define ST_PRESS_LPS001WP_FS_AVL_PRESS_GAIN \\\n\t(100000000UL / ST_PRESS_LPS001WP_LSB_PER_MBAR)\n \n#define ST_PRESS_LPS001WP_OUT_L_ADDR\t\t0x28\n#define ST_TEMP_LPS001WP_OUT_L_ADDR\t\t0x2a\n\n \n#define ST_PRESS_LPS25H_OUT_XL_ADDR\t\t0x28\n#define ST_TEMP_LPS25H_OUT_L_ADDR\t\t0x2b\n\n \n#define ST_PRESS_LPS22HB_LSB_PER_CELSIUS\t100UL\n\nstatic const struct iio_chan_spec st_press_1_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.address = ST_PRESS_1_OUT_XL_ADDR,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 24,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ST_TEMP_1_OUT_L_ADDR,\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2)\n};\n\nstatic const struct iio_chan_spec st_press_lps001wp_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.address = ST_PRESS_LPS001WP_OUT_L_ADDR,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ST_TEMP_LPS001WP_OUT_L_ADDR,\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2)\n};\n\nstatic const struct iio_chan_spec st_press_lps22hb_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.address = ST_PRESS_1_OUT_XL_ADDR,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 24,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ST_TEMP_1_OUT_L_ADDR,\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2)\n};\n\nstatic const struct st_sensor_settings st_press_sensors_settings[] = {\n\t{\n\t\t \n\t\t.wai = 0xbb,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS331AP_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_1_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_1_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x70,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 7, .value = 0x05 },\n\t\t\t\t{ .hz = 13, .value = 0x06 },\n\t\t\t\t{ .hz = 25, .value = 0x07 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x80,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x30,\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1260MB,\n\t\t\t\t\t.gain = ST_PRESS_KPASCAL_NANO_SCALE,\n\t\t\t\t\t.gain2 = ST_PRESS_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x04,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = 0x04,\n\t\t\t\t.addr_od = 0x22,\n\t\t\t\t.mask_od = 0x40,\n\t\t\t},\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = 0x20,\n\t\t\t\t.addr_od = 0x22,\n\t\t\t\t.mask_od = 0x40,\n\t\t\t},\n\t\t\t.addr_ihl = 0x22,\n\t\t\t.mask_ihl = 0x80,\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x03,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x20,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t \n\t\t.wai = 0xba,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS001WP_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_lps001wp_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_lps001wp_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x30,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 7, .value = 0x02 },\n\t\t\t\t{ .hz = 13, .value = 0x03 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x40,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1100MB,\n\t\t\t\t\t.gain = ST_PRESS_LPS001WP_FS_AVL_PRESS_GAIN,\n\t\t\t\t\t.gain2 = ST_PRESS_LPS001WP_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x04,\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x20,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t \n\t\t.wai = 0xbd,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS25H_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_1_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_1_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x70,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 7, .value = 0x02 },\n\t\t\t\t{ .hz = 13, .value = 0x03 },\n\t\t\t\t{ .hz = 25, .value = 0x04 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x80,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1260MB,\n\t\t\t\t\t.gain = ST_PRESS_KPASCAL_NANO_SCALE,\n\t\t\t\t\t.gain2 = ST_PRESS_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x04,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x23,\n\t\t\t\t.mask = 0x01,\n\t\t\t\t.addr_od = 0x22,\n\t\t\t\t.mask_od = 0x40,\n\t\t\t},\n\t\t\t.addr_ihl = 0x22,\n\t\t\t.mask_ihl = 0x80,\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x03,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x20,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t \n\t\t.wai = 0xb1,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS22HB_PRESS_DEV_NAME,\n\t\t\t[1] = LPS33HW_PRESS_DEV_NAME,\n\t\t\t[2] = LPS35HW_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_lps22hb_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_lps22hb_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x70,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 10, .value = 0x02 },\n\t\t\t\t{ .hz = 25, .value = 0x03 },\n\t\t\t\t{ .hz = 50, .value = 0x04 },\n\t\t\t\t{ .hz = 75, .value = 0x05 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x70,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1260MB,\n\t\t\t\t\t.gain = ST_PRESS_KPASCAL_NANO_SCALE,\n\t\t\t\t\t.gain2 = ST_PRESS_LPS22HB_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x02,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = 0x04,\n\t\t\t\t.addr_od = 0x12,\n\t\t\t\t.mask_od = 0x40,\n\t\t\t},\n\t\t\t.addr_ihl = 0x12,\n\t\t\t.mask_ihl = 0x80,\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x03,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x10,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t \n\t\t.wai = 0xb3,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS22HH_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_lps22hb_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_lps22hb_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x70,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 10, .value = 0x02 },\n\t\t\t\t{ .hz = 25, .value = 0x03 },\n\t\t\t\t{ .hz = 50, .value = 0x04 },\n\t\t\t\t{ .hz = 75, .value = 0x05 },\n\t\t\t\t{ .hz = 100, .value = 0x06 },\n\t\t\t\t{ .hz = 200, .value = 0x07 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x70,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1260MB,\n\t\t\t\t\t.gain = ST_PRESS_KPASCAL_NANO_SCALE,\n\t\t\t\t\t.gain2 = ST_PRESS_LPS22HB_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = BIT(1),\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(2),\n\t\t\t\t.addr_od = 0x11,\n\t\t\t\t.mask_od = BIT(5),\n\t\t\t},\n\t\t\t.addr_ihl = 0x11,\n\t\t\t.mask_ihl = BIT(6),\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x03,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x10,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t \n\t\t.wai = 0xb4,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LPS22DF_PRESS_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_press_lps22hb_channels,\n\t\t.num_ch = ARRAY_SIZE(st_press_lps22hb_channels),\n\t\t.odr = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x78,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x01 },\n\t\t\t\t{ .hz = 4, .value = 0x02 },\n\t\t\t\t{ .hz = 10, .value = 0x03 },\n\t\t\t\t{ .hz = 25, .value = 0x04 },\n\t\t\t\t{ .hz = 50, .value = 0x05 },\n\t\t\t\t{ .hz = 75, .value = 0x06 },\n\t\t\t\t{ .hz = 100, .value = 0x07 },\n\t\t\t\t{ .hz = 200, .value = 0x08 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x10,\n\t\t\t.mask = 0x78,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t \n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_PRESS_FS_AVL_1260MB,\n\t\t\t\t\t.gain = ST_PRESS_KPASCAL_NANO_SCALE,\n\t\t\t\t\t.gain2 = ST_PRESS_LPS22HB_LSB_PER_CELSIUS,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x11,\n\t\t\t.mask = BIT(3),\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x13,\n\t\t\t\t.mask = BIT(5),\n\t\t\t\t.addr_od = 0x12,\n\t\t\t\t.mask_od = BIT(1),\n\t\t\t},\n\t\t\t.addr_ihl = 0x12,\n\t\t\t.mask_ihl = BIT(3),\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x03,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x0E,\n\t\t\t.value = BIT(5),\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n};\n\nstatic int st_press_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *ch,\n\t\t\t      int val,\n\t\t\t      int val2,\n\t\t\t      long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\treturn st_sensors_set_odr(indio_dev, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int st_press_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *ch, int *val,\n\t\t\t\t\t\t\tint *val2, long mask)\n{\n\tint err;\n\tstruct st_sensor_data *press_data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = st_sensors_read_info_raw(indio_dev, ch, val);\n\t\tif (err < 0)\n\t\t\tgoto read_error;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (ch->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = 0;\n\t\t\t*val2 = press_data->current_fullscale->gain;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = MCELSIUS_PER_CELSIUS;\n\t\t\t*val2 = press_data->current_fullscale->gain2;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto read_error;\n\t\t}\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (ch->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = ST_PRESS_MILLI_CELSIUS_OFFSET *\n\t\t\t       press_data->current_fullscale->gain2;\n\t\t\t*val2 = MCELSIUS_PER_CELSIUS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto read_error;\n\t\t}\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = press_data->odr;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nread_error:\n\treturn err;\n}\n\nstatic ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();\n\nstatic struct attribute *st_press_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_press_attribute_group = {\n\t.attrs = st_press_attributes,\n};\n\nstatic const struct iio_info press_info = {\n\t.attrs = &st_press_attribute_group,\n\t.read_raw = &st_press_read_raw,\n\t.write_raw = &st_press_write_raw,\n\t.debugfs_reg_access = &st_sensors_debugfs_reg_access,\n};\n\n#ifdef CONFIG_IIO_TRIGGER\nstatic const struct iio_trigger_ops st_press_trigger_ops = {\n\t.set_trigger_state = ST_PRESS_TRIGGER_SET_STATE,\n\t.validate_device = st_sensors_validate_device,\n};\n#define ST_PRESS_TRIGGER_OPS (&st_press_trigger_ops)\n#else\n#define ST_PRESS_TRIGGER_OPS NULL\n#endif\n\n \nconst struct st_sensor_settings *st_press_get_settings(const char *name)\n{\n\tint index = st_sensors_get_settings_index(name,\n\t\t\t\t\tst_press_sensors_settings,\n\t\t\t\t\tARRAY_SIZE(st_press_sensors_settings));\n\tif (index < 0)\n\t\treturn NULL;\n\n\treturn &st_press_sensors_settings[index];\n}\nEXPORT_SYMBOL_NS(st_press_get_settings, IIO_ST_SENSORS);\n\nint st_press_common_probe(struct iio_dev *indio_dev)\n{\n\tstruct st_sensor_data *press_data = iio_priv(indio_dev);\n\tstruct device *parent = indio_dev->dev.parent;\n\tstruct st_sensors_platform_data *pdata = dev_get_platdata(parent);\n\tint err;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &press_info;\n\n\terr = st_sensors_verify_id(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpress_data->num_data_channels = press_data->sensor_settings->num_ch - 1;\n\tindio_dev->channels = press_data->sensor_settings->ch;\n\tindio_dev->num_channels = press_data->sensor_settings->num_ch;\n\n\tpress_data->current_fullscale = &press_data->sensor_settings->fs.fs_avl[0];\n\n\tpress_data->odr = press_data->sensor_settings->odr.odr_avl[0].hz;\n\n\t \n\tif (!pdata && (press_data->sensor_settings->drdy_irq.int1.addr ||\n\t\t       press_data->sensor_settings->drdy_irq.int2.addr))\n\t\tpdata =\t(struct st_sensors_platform_data *)&default_press_pdata;\n\n\terr = st_sensors_init_sensor(indio_dev, pdata);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = st_press_allocate_ring(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (press_data->irq > 0) {\n\t\terr = st_sensors_allocate_trigger(indio_dev,\n\t\t\t\t\t\t  ST_PRESS_TRIGGER_OPS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(parent, indio_dev);\n}\nEXPORT_SYMBOL_NS(st_press_common_probe, IIO_ST_SENSORS);\n\nMODULE_AUTHOR(\"Denis Ciocca <denis.ciocca@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics pressures driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ST_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}