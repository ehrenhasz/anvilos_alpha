{
  "module_name": "icp10100.c",
  "hash_id": "11aa3f4317c01d0bb65ad2c7457e7e7d6ab20f7dc04cf1e1cc84ef4ba146f7c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/icp10100.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/crc8.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/regulator/consumer.h>\n#include <linux/iio/iio.h>\n\n#define ICP10100_ID_REG_GET(_reg)\t((_reg) & 0x003F)\n#define ICP10100_ID_REG\t\t\t0x08\n#define ICP10100_RESPONSE_WORD_LENGTH\t3\n#define ICP10100_CRC8_WORD_LENGTH\t2\n#define ICP10100_CRC8_POLYNOMIAL\t0x31\n#define ICP10100_CRC8_INIT\t\t0xFF\n\nenum icp10100_mode {\n\tICP10100_MODE_LP,\t \n\tICP10100_MODE_N,\t \n\tICP10100_MODE_LN,\t \n\tICP10100_MODE_ULN,\t \n\tICP10100_MODE_NB,\n};\n\nstruct icp10100_state {\n\tstruct mutex lock;\n\tstruct i2c_client *client;\n\tstruct regulator *vdd;\n\tenum icp10100_mode mode;\n\tint16_t cal[4];\n};\n\nstruct icp10100_command {\n\t__be16 cmd;\n\tunsigned long wait_us;\n\tunsigned long wait_max_us;\n\tsize_t response_word_nb;\n};\n\nstatic const struct icp10100_command icp10100_cmd_soft_reset = {\n\t.cmd = cpu_to_be16(0x805D),\n\t.wait_us = 170,\n\t.wait_max_us = 200,\n\t.response_word_nb = 0,\n};\n\nstatic const struct icp10100_command icp10100_cmd_read_id = {\n\t.cmd = cpu_to_be16(0xEFC8),\n\t.wait_us = 0,\n\t.response_word_nb = 1,\n};\n\nstatic const struct icp10100_command icp10100_cmd_read_otp = {\n\t.cmd = cpu_to_be16(0xC7F7),\n\t.wait_us = 0,\n\t.response_word_nb = 1,\n};\n\nstatic const struct icp10100_command icp10100_cmd_measure[] = {\n\t[ICP10100_MODE_LP] = {\n\t\t.cmd = cpu_to_be16(0x401A),\n\t\t.wait_us = 1800,\n\t\t.wait_max_us = 2000,\n\t\t.response_word_nb = 3,\n\t},\n\t[ICP10100_MODE_N] = {\n\t\t.cmd = cpu_to_be16(0x48A3),\n\t\t.wait_us = 6300,\n\t\t.wait_max_us = 6500,\n\t\t.response_word_nb = 3,\n\t},\n\t[ICP10100_MODE_LN] = {\n\t\t.cmd = cpu_to_be16(0x5059),\n\t\t.wait_us = 23800,\n\t\t.wait_max_us = 24000,\n\t\t.response_word_nb = 3,\n\t},\n\t[ICP10100_MODE_ULN] = {\n\t\t.cmd = cpu_to_be16(0x58E0),\n\t\t.wait_us = 94500,\n\t\t.wait_max_us = 94700,\n\t\t.response_word_nb = 3,\n\t},\n};\n\nstatic const uint8_t icp10100_switch_mode_otp[] =\n\t{0xC5, 0x95, 0x00, 0x66, 0x9c};\n\nDECLARE_CRC8_TABLE(icp10100_crc8_table);\n\nstatic inline int icp10100_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\n\tret = i2c_transfer(adap, msgs, num);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != num)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int icp10100_send_cmd(struct icp10100_state *st,\n\t\t\t     const struct icp10100_command *cmd,\n\t\t\t     __be16 *buf, size_t buf_len)\n{\n\tsize_t size = cmd->response_word_nb * ICP10100_RESPONSE_WORD_LENGTH;\n\tuint8_t data[16];\n\tuint8_t *ptr;\n\tuint8_t *buf_ptr = (uint8_t *)buf;\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = st->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = (uint8_t *)&cmd->cmd,\n\t\t}, {\n\t\t\t.addr = st->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = size,\n\t\t\t.buf = data,\n\t\t},\n\t};\n\tuint8_t crc;\n\tunsigned int i;\n\tint ret;\n\n\tif (size > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (cmd->response_word_nb > 0 &&\n\t\t\t(buf == NULL || buf_len < (cmd->response_word_nb * 2)))\n\t\treturn -EINVAL;\n\n\tdev_dbg(&st->client->dev, \"sending cmd %#x\\n\", be16_to_cpu(cmd->cmd));\n\n\tif (cmd->response_word_nb > 0 && cmd->wait_us == 0) {\n\t\t \n\t\tret = icp10100_i2c_xfer(st->client->adapter, msgs,\n\t\t\t\t\tARRAY_SIZE(msgs));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = icp10100_i2c_xfer(st->client->adapter, &msgs[0], 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (cmd->wait_us > 0)\n\t\t\tusleep_range(cmd->wait_us, cmd->wait_max_us);\n\t\t \n\t\tif (cmd->response_word_nb > 0) {\n\t\t\tret = icp10100_i2c_xfer(st->client->adapter, &msgs[1], 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < cmd->response_word_nb; ++i) {\n\t\tptr = &data[i * ICP10100_RESPONSE_WORD_LENGTH];\n\t\tcrc = crc8(icp10100_crc8_table, ptr, ICP10100_CRC8_WORD_LENGTH,\n\t\t\t   ICP10100_CRC8_INIT);\n\t\tif (crc != ptr[ICP10100_CRC8_WORD_LENGTH]) {\n\t\t\tdev_err(&st->client->dev, \"crc error recv=%#x calc=%#x\\n\",\n\t\t\t\tptr[ICP10100_CRC8_WORD_LENGTH], crc);\n\t\t\treturn -EIO;\n\t\t}\n\t\t*buf_ptr++ = ptr[0];\n\t\t*buf_ptr++ = ptr[1];\n\t}\n\n\treturn 0;\n}\n\nstatic int icp10100_read_cal_otp(struct icp10100_state *st)\n{\n\t__be16 val;\n\tint i;\n\tint ret;\n\n\t \n\tret = i2c_master_send(st->client, icp10100_switch_mode_otp,\n\t\t\t      ARRAY_SIZE(icp10100_switch_mode_otp));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ARRAY_SIZE(icp10100_switch_mode_otp))\n\t\treturn -EIO;\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tret = icp10100_send_cmd(st, &icp10100_cmd_read_otp,\n\t\t\t\t\t&val, sizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->cal[i] = be16_to_cpu(val);\n\t\tdev_dbg(&st->client->dev, \"cal[%d] = %d\\n\", i, st->cal[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int icp10100_init_chip(struct icp10100_state *st)\n{\n\t__be16 val;\n\tuint16_t id;\n\tint ret;\n\n\t \n\tret = icp10100_send_cmd(st, &icp10100_cmd_read_id, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\tid = ICP10100_ID_REG_GET(be16_to_cpu(val));\n\tif (id != ICP10100_ID_REG) {\n\t\tdev_err(&st->client->dev, \"invalid id %#x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = icp10100_read_cal_otp(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn icp10100_send_cmd(st, &icp10100_cmd_soft_reset, NULL, 0);\n}\n\nstatic int icp10100_get_measures(struct icp10100_state *st,\n\t\t\t\tuint32_t *pressure, uint16_t *temperature)\n{\n\tconst struct icp10100_command *cmd;\n\t__be16 measures[3];\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&st->client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tcmd = &icp10100_cmd_measure[st->mode];\n\tret = icp10100_send_cmd(st, cmd, measures, sizeof(measures));\n\tmutex_unlock(&st->lock);\n\tif (ret)\n\t\tgoto error_measure;\n\n\t*pressure = (be16_to_cpu(measures[0]) << 8) |\n\t\t\t(be16_to_cpu(measures[1]) >> 8);\n\t*temperature = be16_to_cpu(measures[2]);\n\n\tpm_runtime_mark_last_busy(&st->client->dev);\nerror_measure:\n\tpm_runtime_put_autosuspend(&st->client->dev);\n\treturn ret;\n}\n\nstatic uint32_t icp10100_get_pressure(struct icp10100_state *st,\n\t\t\t\t      uint32_t raw_pressure, uint16_t raw_temp)\n{\n\tstatic int32_t p_calib[] = {45000, 80000, 105000};\n\tstatic int32_t lut_lower = 3670016;\n\tstatic int32_t lut_upper = 12058624;\n\tstatic int32_t inv_quadr_factor = 16777216;\n\tstatic int32_t offset_factor = 2048;\n\tint64_t val1, val2;\n\tint32_t p_lut[3];\n\tint32_t t, t_square;\n\tint64_t a, b, c;\n\tuint32_t pressure_mPa;\n\n\tdev_dbg(&st->client->dev, \"raw: pressure = %u, temp = %u\\n\",\n\t\traw_pressure, raw_temp);\n\n\t \n\tt = (int32_t)raw_temp - 32768;\n\tt_square = t * t;\n\tval1 = (int64_t)st->cal[0] * (int64_t)t_square;\n\tp_lut[0] = lut_lower + (int32_t)div_s64(val1, inv_quadr_factor);\n\tval1 = (int64_t)st->cal[1] * (int64_t)t_square;\n\tp_lut[1] = offset_factor * st->cal[3] +\n\t\t\t(int32_t)div_s64(val1, inv_quadr_factor);\n\tval1 = (int64_t)st->cal[2] * (int64_t)t_square;\n\tp_lut[2] = lut_upper + (int32_t)div_s64(val1, inv_quadr_factor);\n\tdev_dbg(&st->client->dev, \"p_lut = [%d, %d, %d]\\n\",\n\t\tp_lut[0], p_lut[1], p_lut[2]);\n\n\t \n\tval1 = (int64_t)p_lut[0] * (int64_t)p_lut[1] *\n\t\t\t(int64_t)(p_calib[0] - p_calib[1]) +\n\t\t(int64_t)p_lut[1] * (int64_t)p_lut[2] *\n\t\t\t(int64_t)(p_calib[1] - p_calib[2]) +\n\t\t(int64_t)p_lut[2] * (int64_t)p_lut[0] *\n\t\t\t(int64_t)(p_calib[2] - p_calib[0]);\n\tval2 = (int64_t)p_lut[2] * (int64_t)(p_calib[0] - p_calib[1]) +\n\t\t(int64_t)p_lut[0] * (int64_t)(p_calib[1] - p_calib[2]) +\n\t\t(int64_t)p_lut[1] * (int64_t)(p_calib[2] - p_calib[0]);\n\tc = div64_s64(val1, val2);\n\tdev_dbg(&st->client->dev, \"val1 = %lld, val2 = %lld, c = %lld\\n\",\n\t\tval1, val2, c);\n\tval1 = (int64_t)p_calib[0] * (int64_t)p_lut[0] -\n\t\t(int64_t)p_calib[1] * (int64_t)p_lut[1] -\n\t\t(int64_t)(p_calib[1] - p_calib[0]) * c;\n\tval2 = (int64_t)p_lut[0] - (int64_t)p_lut[1];\n\ta = div64_s64(val1, val2);\n\tdev_dbg(&st->client->dev, \"val1 = %lld, val2 = %lld, a = %lld\\n\",\n\t\tval1, val2, a);\n\tb = ((int64_t)p_calib[0] - a) * ((int64_t)p_lut[0] + c);\n\tdev_dbg(&st->client->dev, \"b = %lld\\n\", b);\n\n\t \n\tpressure_mPa = 1000LL * a + div64_s64(1000LL * b, c + raw_pressure);\n\n\treturn pressure_mPa;\n}\n\nstatic int icp10100_read_raw_measures(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      int *val, int *val2)\n{\n\tstruct icp10100_state *st = iio_priv(indio_dev);\n\tuint32_t raw_pressure;\n\tuint16_t raw_temp;\n\tuint32_t pressure_mPa;\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icp10100_get_measures(st, &raw_pressure, &raw_temp);\n\tif (ret)\n\t\tgoto error_release;\n\n\tswitch (chan->type) {\n\tcase IIO_PRESSURE:\n\t\tpressure_mPa = icp10100_get_pressure(st, raw_pressure,\n\t\t\t\t\t\t     raw_temp);\n\t\t \n\t\t*val = pressure_mPa / 1000000;\n\t\t*val2 = pressure_mPa % 1000000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\t*val = raw_temp;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerror_release:\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int icp10100_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct icp10100_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\treturn icp10100_read_raw_measures(indio_dev, chan, val, val2);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 2;\n\t\t\t*val2 = 670288;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = -45000;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tmutex_lock(&st->lock);\n\t\t*val = 1 << st->mode;\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int icp10100_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstatic int oversamplings[] = {1, 2, 4, 8};\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*vals = oversamplings;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(oversamplings);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int icp10100_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct icp10100_state *st = iio_priv(indio_dev);\n\tunsigned int mode;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t \n\t\tif (val <= 0 || !is_power_of_2(val))\n\t\t\treturn -EINVAL;\n\t\tmode = ilog2(val);\n\t\tif (mode >= ICP10100_MODE_NB)\n\t\t\treturn -EINVAL;\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&st->lock);\n\t\tst->mode = mode;\n\t\tmutex_unlock(&st->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int icp10100_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info icp10100_info = {\n\t.read_raw = icp10100_read_raw,\n\t.read_avail = icp10100_read_avail,\n\t.write_raw = icp10100_write_raw,\n\t.write_raw_get_fmt = icp10100_write_raw_get_fmt,\n};\n\nstatic const struct iio_chan_spec icp10100_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_all =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n};\n\nstatic int icp10100_enable_regulator(struct icp10100_state *st)\n{\n\tint ret;\n\n\tret = regulator_enable(st->vdd);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic void icp10100_disable_regulator_action(void *data)\n{\n\tstruct icp10100_state *st = data;\n\tint ret;\n\n\tret = regulator_disable(st->vdd);\n\tif (ret)\n\t\tdev_err(&st->client->dev, \"error %d disabling vdd\\n\", ret);\n}\n\nstatic void icp10100_pm_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev);\n}\n\nstatic int icp10100_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct icp10100_state *st;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"plain i2c transactions not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, indio_dev);\n\tindio_dev->name = client->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = icp10100_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(icp10100_channels);\n\tindio_dev->info = &icp10100_info;\n\n\tst = iio_priv(indio_dev);\n\tmutex_init(&st->lock);\n\tst->client = client;\n\tst->mode = ICP10100_MODE_N;\n\n\tst->vdd = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(st->vdd))\n\t\treturn PTR_ERR(st->vdd);\n\n\tret = icp10100_enable_regulator(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t       icp10100_disable_regulator_action, st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcrc8_populate_msb(icp10100_crc8_table, ICP10100_CRC8_POLYNOMIAL);\n\n\tret = icp10100_init_chip(st);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"init chip error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 2000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put(&client->dev);\n\tret = devm_add_action_or_reset(&client->dev, icp10100_pm_disable,\n\t\t\t\t       &client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int icp10100_suspend(struct device *dev)\n{\n\tstruct icp10100_state *st = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = regulator_disable(st->vdd);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int icp10100_resume(struct device *dev)\n{\n\tstruct icp10100_state *st = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = icp10100_enable_regulator(st);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = icp10100_send_cmd(st, &icp10100_cmd_soft_reset, NULL, 0);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(icp10100_pm, icp10100_suspend, icp10100_resume,\n\t\t\t\t NULL);\n\nstatic const struct of_device_id icp10100_of_match[] = {\n\t{\n\t\t.compatible = \"invensense,icp10100\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, icp10100_of_match);\n\nstatic const struct i2c_device_id icp10100_id[] = {\n\t{ \"icp10100\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, icp10100_id);\n\nstatic struct i2c_driver icp10100_driver = {\n\t.driver = {\n\t\t.name = \"icp10100\",\n\t\t.pm = pm_ptr(&icp10100_pm),\n\t\t.of_match_table = icp10100_of_match,\n\t},\n\t.probe = icp10100_probe,\n\t.id_table = icp10100_id,\n};\nmodule_i2c_driver(icp10100_driver);\n\nMODULE_AUTHOR(\"InvenSense, Inc.\");\nMODULE_DESCRIPTION(\"InvenSense icp10100 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}