{
  "module_name": "bmp280-core.c",
  "hash_id": "99cb78735ce68da33c00df2b5de05a357d2594984ef09667da4291185981198e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/bmp280-core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bmp280: \" fmt\n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>  \n#include <linux/completion.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n\n#include <asm/unaligned.h>\n\n#include \"bmp280.h\"\n\n \nenum { AC1, AC2, AC3, AC4, AC5, AC6, B1, B2, MB, MC, MD };\n\n\nenum bmp380_odr {\n\tBMP380_ODR_200HZ,\n\tBMP380_ODR_100HZ,\n\tBMP380_ODR_50HZ,\n\tBMP380_ODR_25HZ,\n\tBMP380_ODR_12_5HZ,\n\tBMP380_ODR_6_25HZ,\n\tBMP380_ODR_3_125HZ,\n\tBMP380_ODR_1_5625HZ,\n\tBMP380_ODR_0_78HZ,\n\tBMP380_ODR_0_39HZ,\n\tBMP380_ODR_0_2HZ,\n\tBMP380_ODR_0_1HZ,\n\tBMP380_ODR_0_05HZ,\n\tBMP380_ODR_0_02HZ,\n\tBMP380_ODR_0_01HZ,\n\tBMP380_ODR_0_006HZ,\n\tBMP380_ODR_0_003HZ,\n\tBMP380_ODR_0_0015HZ,\n};\n\nenum bmp580_odr {\n\tBMP580_ODR_240HZ,\n\tBMP580_ODR_218HZ,\n\tBMP580_ODR_199HZ,\n\tBMP580_ODR_179HZ,\n\tBMP580_ODR_160HZ,\n\tBMP580_ODR_149HZ,\n\tBMP580_ODR_140HZ,\n\tBMP580_ODR_129HZ,\n\tBMP580_ODR_120HZ,\n\tBMP580_ODR_110HZ,\n\tBMP580_ODR_100HZ,\n\tBMP580_ODR_89HZ,\n\tBMP580_ODR_80HZ,\n\tBMP580_ODR_70HZ,\n\tBMP580_ODR_60HZ,\n\tBMP580_ODR_50HZ,\n\tBMP580_ODR_45HZ,\n\tBMP580_ODR_40HZ,\n\tBMP580_ODR_35HZ,\n\tBMP580_ODR_30HZ,\n\tBMP580_ODR_25HZ,\n\tBMP580_ODR_20HZ,\n\tBMP580_ODR_15HZ,\n\tBMP580_ODR_10HZ,\n\tBMP580_ODR_5HZ,\n\tBMP580_ODR_4HZ,\n\tBMP580_ODR_3HZ,\n\tBMP580_ODR_2HZ,\n\tBMP580_ODR_1HZ,\n\tBMP580_ODR_0_5HZ,\n\tBMP580_ODR_0_25HZ,\n\tBMP580_ODR_0_125HZ,\n};\n\n \nenum { T1, T2, T3, P1, P2, P3, P4, P5, P6, P7, P8, P9 };\n\nenum {\n\t \n\tBMP380_T1 = 0,\n\tBMP380_T2 = 2,\n\tBMP380_T3 = 4,\n\t \n\tBMP380_P1 = 5,\n\tBMP380_P2 = 7,\n\tBMP380_P3 = 9,\n\tBMP380_P4 = 10,\n\tBMP380_P5 = 11,\n\tBMP380_P6 = 13,\n\tBMP380_P7 = 15,\n\tBMP380_P8 = 16,\n\tBMP380_P9 = 17,\n\tBMP380_P10 = 19,\n\tBMP380_P11 = 20,\n};\n\nstatic const struct iio_chan_spec bmp280_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n};\n\nstatic const struct iio_chan_spec bmp380_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t},\n};\n\nstatic int bmp280_read_calib(struct bmp280_data *data)\n{\n\tstruct bmp280_calib *calib = &data->calib.bmp280;\n\tint ret;\n\n\n\t \n\tret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_TEMP_START,\n\t\t\t       data->bmp280_cal_buf, sizeof(data->bmp280_cal_buf));\n\tif (ret < 0) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to read temperature and pressure calibration parameters\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tadd_device_randomness(data->bmp280_cal_buf, sizeof(data->bmp280_cal_buf));\n\n\t \n\tcalib->T1 = le16_to_cpu(data->bmp280_cal_buf[T1]);\n\tcalib->T2 = le16_to_cpu(data->bmp280_cal_buf[T2]);\n\tcalib->T3 = le16_to_cpu(data->bmp280_cal_buf[T3]);\n\n\t \n\tcalib->P1 = le16_to_cpu(data->bmp280_cal_buf[P1]);\n\tcalib->P2 = le16_to_cpu(data->bmp280_cal_buf[P2]);\n\tcalib->P3 = le16_to_cpu(data->bmp280_cal_buf[P3]);\n\tcalib->P4 = le16_to_cpu(data->bmp280_cal_buf[P4]);\n\tcalib->P5 = le16_to_cpu(data->bmp280_cal_buf[P5]);\n\tcalib->P6 = le16_to_cpu(data->bmp280_cal_buf[P6]);\n\tcalib->P7 = le16_to_cpu(data->bmp280_cal_buf[P7]);\n\tcalib->P8 = le16_to_cpu(data->bmp280_cal_buf[P8]);\n\tcalib->P9 = le16_to_cpu(data->bmp280_cal_buf[P9]);\n\n\treturn 0;\n}\n\nstatic int bme280_read_calib(struct bmp280_data *data)\n{\n\tstruct bmp280_calib *calib = &data->calib.bmp280;\n\tstruct device *dev = data->dev;\n\tunsigned int tmp;\n\tint ret;\n\n\t \n\tret = bmp280_read_calib(data);\n\tif  (ret < 0) {\n\t\tdev_err(dev, \"failed to read common bmp280 calibration parameters\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tret = regmap_read(data->regmap, BMP280_REG_COMP_H1, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H1 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H1 = tmp;\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H2,\n\t\t\t       &data->le16, sizeof(data->le16));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H2 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H2 = sign_extend32(le16_to_cpu(data->le16), 15);\n\n\tret = regmap_read(data->regmap, BMP280_REG_COMP_H3, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H3 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H3 = tmp;\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H4,\n\t\t\t       &data->be16, sizeof(data->be16));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H4 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H4 = sign_extend32(((be16_to_cpu(data->be16) >> 4) & 0xff0) |\n\t\t\t\t  (be16_to_cpu(data->be16) & 0xf), 11);\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H5,\n\t\t\t       &data->le16, sizeof(data->le16));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H5 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H5 = sign_extend32(FIELD_GET(BMP280_COMP_H5_MASK, le16_to_cpu(data->le16)), 11);\n\n\tret = regmap_read(data->regmap, BMP280_REG_COMP_H6, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read H6 comp value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->H6 = sign_extend32(tmp, 7);\n\n\treturn 0;\n}\n \nstatic u32 bmp280_compensate_humidity(struct bmp280_data *data,\n\t\t\t\t      s32 adc_humidity)\n{\n\tstruct bmp280_calib *calib = &data->calib.bmp280;\n\ts32 var;\n\n\tvar = ((s32)data->t_fine) - (s32)76800;\n\tvar = ((((adc_humidity << 14) - (calib->H4 << 20) - (calib->H5 * var))\n\t\t+ (s32)16384) >> 15) * (((((((var * calib->H6) >> 10)\n\t\t* (((var * (s32)calib->H3) >> 11) + (s32)32768)) >> 10)\n\t\t+ (s32)2097152) * calib->H2 + 8192) >> 14);\n\tvar -= ((((var >> 15) * (var >> 15)) >> 7) * (s32)calib->H1) >> 4;\n\n\tvar = clamp_val(var, 0, 419430400);\n\n\treturn var >> 12;\n};\n\n \nstatic s32 bmp280_compensate_temp(struct bmp280_data *data,\n\t\t\t\t  s32 adc_temp)\n{\n\tstruct bmp280_calib *calib = &data->calib.bmp280;\n\ts32 var1, var2;\n\n\tvar1 = (((adc_temp >> 3) - ((s32)calib->T1 << 1)) *\n\t\t((s32)calib->T2)) >> 11;\n\tvar2 = (((((adc_temp >> 4) - ((s32)calib->T1)) *\n\t\t  ((adc_temp >> 4) - ((s32)calib->T1))) >> 12) *\n\t\t((s32)calib->T3)) >> 14;\n\tdata->t_fine = var1 + var2;\n\n\treturn (data->t_fine * 5 + 128) >> 8;\n}\n\n \nstatic u32 bmp280_compensate_press(struct bmp280_data *data,\n\t\t\t\t   s32 adc_press)\n{\n\tstruct bmp280_calib *calib = &data->calib.bmp280;\n\ts64 var1, var2, p;\n\n\tvar1 = ((s64)data->t_fine) - 128000;\n\tvar2 = var1 * var1 * (s64)calib->P6;\n\tvar2 += (var1 * (s64)calib->P5) << 17;\n\tvar2 += ((s64)calib->P4) << 35;\n\tvar1 = ((var1 * var1 * (s64)calib->P3) >> 8) +\n\t\t((var1 * (s64)calib->P2) << 12);\n\tvar1 = ((((s64)1) << 47) + var1) * ((s64)calib->P1) >> 33;\n\n\tif (var1 == 0)\n\t\treturn 0;\n\n\tp = ((((s64)1048576 - adc_press) << 31) - var2) * 3125;\n\tp = div64_s64(p, var1);\n\tvar1 = (((s64)calib->P9) * (p >> 13) * (p >> 13)) >> 25;\n\tvar2 = ((s64)(calib->P8) * p) >> 19;\n\tp = ((p + var1 + var2) >> 8) + (((s64)calib->P7) << 4);\n\n\treturn (u32)p;\n}\n\nstatic int bmp280_read_temp(struct bmp280_data *data,\n\t\t\t    int *val, int *val2)\n{\n\ts32 adc_temp, comp_temp;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_TEMP_MSB,\n\t\t\t       data->buf, sizeof(data->buf));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read temperature\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_temp = FIELD_GET(BMP280_MEAS_TRIM_MASK, get_unaligned_be24(data->buf));\n\tif (adc_temp == BMP280_TEMP_SKIPPED) {\n\t\t \n\t\tdev_err(data->dev, \"reading temperature skipped\\n\");\n\t\treturn -EIO;\n\t}\n\tcomp_temp = bmp280_compensate_temp(data, adc_temp);\n\n\t \n\tif (val) {\n\t\t*val = comp_temp * 10;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp280_read_press(struct bmp280_data *data,\n\t\t\t     int *val, int *val2)\n{\n\tu32 comp_press;\n\ts32 adc_press;\n\tint ret;\n\n\t \n\tret = bmp280_read_temp(data, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_PRESS_MSB,\n\t\t\t       data->buf, sizeof(data->buf));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read pressure\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_press = FIELD_GET(BMP280_MEAS_TRIM_MASK, get_unaligned_be24(data->buf));\n\tif (adc_press == BMP280_PRESS_SKIPPED) {\n\t\t \n\t\tdev_err(data->dev, \"reading pressure skipped\\n\");\n\t\treturn -EIO;\n\t}\n\tcomp_press = bmp280_compensate_press(data, adc_press);\n\n\t*val = comp_press;\n\t*val2 = 256000;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int bmp280_read_humid(struct bmp280_data *data, int *val, int *val2)\n{\n\tu32 comp_humidity;\n\ts32 adc_humidity;\n\tint ret;\n\n\t \n\tret = bmp280_read_temp(data, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP280_REG_HUMIDITY_MSB,\n\t\t\t       &data->be16, sizeof(data->be16));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read humidity\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_humidity = be16_to_cpu(data->be16);\n\tif (adc_humidity == BMP280_HUMIDITY_SKIPPED) {\n\t\t \n\t\tdev_err(data->dev, \"reading humidity skipped\\n\");\n\t\treturn -EIO;\n\t}\n\tcomp_humidity = bmp280_compensate_humidity(data, adc_humidity);\n\n\t*val = comp_humidity * 1000 / 1024;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmp280_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bmp280_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tpm_runtime_get_sync(data->dev);\n\tmutex_lock(&data->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tret = data->chip_info->read_humid(data, val, val2);\n\t\t\tbreak;\n\t\tcase IIO_PRESSURE:\n\t\t\tret = data->chip_info->read_press(data, val, val2);\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = data->chip_info->read_temp(data, val, val2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\t*val = 1 << data->oversampling_humid;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = 1 << data->oversampling_press;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 1 << data->oversampling_temp;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (!data->chip_info->sampling_freq_avail) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t*val = data->chip_info->sampling_freq_avail[data->sampling_freq][0];\n\t\t*val2 = data->chip_info->sampling_freq_avail[data->sampling_freq][1];\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (!data->chip_info->iir_filter_coeffs_avail) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t*val = (1 << data->iir_filter_coeff) - 1;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\tpm_runtime_mark_last_busy(data->dev);\n\tpm_runtime_put_autosuspend(data->dev);\n\n\treturn ret;\n}\n\nstatic int bmp280_write_oversampling_ratio_humid(struct bmp280_data *data,\n\t\t\t\t\t       int val)\n{\n\tconst int *avail = data->chip_info->oversampling_humid_avail;\n\tconst int n = data->chip_info->num_oversampling_humid_avail;\n\tint ret, prev;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (avail[i] == val) {\n\t\t\tprev = data->oversampling_humid;\n\t\t\tdata->oversampling_humid = ilog2(val);\n\n\t\t\tret = data->chip_info->chip_config(data);\n\t\t\tif (ret) {\n\t\t\t\tdata->oversampling_humid = prev;\n\t\t\t\tdata->chip_info->chip_config(data);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bmp280_write_oversampling_ratio_temp(struct bmp280_data *data,\n\t\t\t\t\t       int val)\n{\n\tconst int *avail = data->chip_info->oversampling_temp_avail;\n\tconst int n = data->chip_info->num_oversampling_temp_avail;\n\tint ret, prev;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (avail[i] == val) {\n\t\t\tprev = data->oversampling_temp;\n\t\t\tdata->oversampling_temp = ilog2(val);\n\n\t\t\tret = data->chip_info->chip_config(data);\n\t\t\tif (ret) {\n\t\t\t\tdata->oversampling_temp = prev;\n\t\t\t\tdata->chip_info->chip_config(data);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bmp280_write_oversampling_ratio_press(struct bmp280_data *data,\n\t\t\t\t\t       int val)\n{\n\tconst int *avail = data->chip_info->oversampling_press_avail;\n\tconst int n = data->chip_info->num_oversampling_press_avail;\n\tint ret, prev;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (avail[i] == val) {\n\t\t\tprev = data->oversampling_press;\n\t\t\tdata->oversampling_press = ilog2(val);\n\n\t\t\tret = data->chip_info->chip_config(data);\n\t\t\tif (ret) {\n\t\t\t\tdata->oversampling_press = prev;\n\t\t\t\tdata->chip_info->chip_config(data);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bmp280_write_sampling_frequency(struct bmp280_data *data,\n\t\t\t\t\t   int val, int val2)\n{\n\tconst int (*avail)[2] = data->chip_info->sampling_freq_avail;\n\tconst int n = data->chip_info->num_sampling_freq_avail;\n\tint ret, prev;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (avail[i][0] == val && avail[i][1] == val2) {\n\t\t\tprev = data->sampling_freq;\n\t\t\tdata->sampling_freq = i;\n\n\t\t\tret = data->chip_info->chip_config(data);\n\t\t\tif (ret) {\n\t\t\t\tdata->sampling_freq = prev;\n\t\t\t\tdata->chip_info->chip_config(data);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bmp280_write_iir_filter_coeffs(struct bmp280_data *data, int val)\n{\n\tconst int *avail = data->chip_info->iir_filter_coeffs_avail;\n\tconst int n = data->chip_info->num_iir_filter_coeffs_avail;\n\tint ret, prev;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (avail[i] - 1  == val) {\n\t\t\tprev = data->iir_filter_coeff;\n\t\t\tdata->iir_filter_coeff = i;\n\n\t\t\tret = data->chip_info->chip_config(data);\n\t\t\tif (ret) {\n\t\t\t\tdata->iir_filter_coeff = prev;\n\t\t\t\tdata->chip_info->chip_config(data);\n\t\t\t\treturn ret;\n\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bmp280_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct bmp280_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\n\t \n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tpm_runtime_get_sync(data->dev);\n\t\tmutex_lock(&data->lock);\n\t\tswitch (chan->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tret = bmp280_write_oversampling_ratio_humid(data, val);\n\t\t\tbreak;\n\t\tcase IIO_PRESSURE:\n\t\t\tret = bmp280_write_oversampling_ratio_press(data, val);\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = bmp280_write_oversampling_ratio_temp(data, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tpm_runtime_get_sync(data->dev);\n\t\tmutex_lock(&data->lock);\n\t\tret = bmp280_write_sampling_frequency(data, val, val2);\n\t\tmutex_unlock(&data->lock);\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tpm_runtime_get_sync(data->dev);\n\t\tmutex_lock(&data->lock);\n\t\tret = bmp280_write_iir_filter_coeffs(data, val);\n\t\tmutex_unlock(&data->lock);\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int bmp280_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tstruct bmp280_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\t*vals = data->chip_info->oversampling_press_avail;\n\t\t\t*length = data->chip_info->num_oversampling_press_avail;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\t*vals = data->chip_info->oversampling_temp_avail;\n\t\t\t*length = data->chip_info->num_oversampling_temp_avail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (const int *)data->chip_info->sampling_freq_avail;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = data->chip_info->num_sampling_freq_avail;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = data->chip_info->iir_filter_coeffs_avail;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = data->chip_info->num_iir_filter_coeffs_avail;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info bmp280_info = {\n\t.read_raw = &bmp280_read_raw,\n\t.read_avail = &bmp280_read_avail,\n\t.write_raw = &bmp280_write_raw,\n};\n\nstatic int bmp280_chip_config(struct bmp280_data *data)\n{\n\tu8 osrs = FIELD_PREP(BMP280_OSRS_TEMP_MASK, data->oversampling_temp + 1) |\n\t\t  FIELD_PREP(BMP280_OSRS_PRESS_MASK, data->oversampling_press + 1);\n\tint ret;\n\n\tret = regmap_write_bits(data->regmap, BMP280_REG_CTRL_MEAS,\n\t\t\t\t BMP280_OSRS_TEMP_MASK |\n\t\t\t\t BMP280_OSRS_PRESS_MASK |\n\t\t\t\t BMP280_MODE_MASK,\n\t\t\t\t osrs | BMP280_MODE_NORMAL);\n\tif (ret < 0) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to write ctrl_meas register\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(data->regmap, BMP280_REG_CONFIG,\n\t\t\t\t BMP280_FILTER_MASK,\n\t\t\t\t BMP280_FILTER_4X);\n\tif (ret < 0) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to write config register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const int bmp280_oversampling_avail[] = { 1, 2, 4, 8, 16 };\n\nconst struct bmp280_chip_info bmp280_chip_info = {\n\t.id_reg = BMP280_REG_ID,\n\t.chip_id = BMP280_CHIP_ID,\n\t.regmap_config = &bmp280_regmap_config,\n\t.start_up_time = 2000,\n\t.channels = bmp280_channels,\n\t.num_channels = 2,\n\n\t.oversampling_temp_avail = bmp280_oversampling_avail,\n\t.num_oversampling_temp_avail = ARRAY_SIZE(bmp280_oversampling_avail),\n\t \n\t.oversampling_temp_default = BMP280_OSRS_TEMP_2X - 1,\n\n\t.oversampling_press_avail = bmp280_oversampling_avail,\n\t.num_oversampling_press_avail = ARRAY_SIZE(bmp280_oversampling_avail),\n\t.oversampling_press_default = BMP280_OSRS_PRESS_16X - 1,\n\n\t.chip_config = bmp280_chip_config,\n\t.read_temp = bmp280_read_temp,\n\t.read_press = bmp280_read_press,\n\t.read_calib = bmp280_read_calib,\n};\nEXPORT_SYMBOL_NS(bmp280_chip_info, IIO_BMP280);\n\nstatic int bme280_chip_config(struct bmp280_data *data)\n{\n\tu8 osrs = FIELD_PREP(BMP280_OSRS_HUMIDITY_MASK, data->oversampling_humid + 1);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMP280_REG_CTRL_HUMIDITY,\n\t\t\t\t  BMP280_OSRS_HUMIDITY_MASK, osrs);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bmp280_chip_config(data);\n}\n\nconst struct bmp280_chip_info bme280_chip_info = {\n\t.id_reg = BMP280_REG_ID,\n\t.chip_id = BME280_CHIP_ID,\n\t.regmap_config = &bmp280_regmap_config,\n\t.start_up_time = 2000,\n\t.channels = bmp280_channels,\n\t.num_channels = 3,\n\n\t.oversampling_temp_avail = bmp280_oversampling_avail,\n\t.num_oversampling_temp_avail = ARRAY_SIZE(bmp280_oversampling_avail),\n\t.oversampling_temp_default = BMP280_OSRS_TEMP_2X - 1,\n\n\t.oversampling_press_avail = bmp280_oversampling_avail,\n\t.num_oversampling_press_avail = ARRAY_SIZE(bmp280_oversampling_avail),\n\t.oversampling_press_default = BMP280_OSRS_PRESS_16X - 1,\n\n\t.oversampling_humid_avail = bmp280_oversampling_avail,\n\t.num_oversampling_humid_avail = ARRAY_SIZE(bmp280_oversampling_avail),\n\t.oversampling_humid_default = BMP280_OSRS_HUMIDITY_16X - 1,\n\n\t.chip_config = bme280_chip_config,\n\t.read_temp = bmp280_read_temp,\n\t.read_press = bmp280_read_press,\n\t.read_humid = bmp280_read_humid,\n\t.read_calib = bme280_read_calib,\n};\nEXPORT_SYMBOL_NS(bme280_chip_info, IIO_BMP280);\n\n \nstatic int bmp380_cmd(struct bmp280_data *data, u8 cmd)\n{\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tret = regmap_read(data->regmap, BMP380_REG_STATUS, &reg);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to read error register\\n\");\n\t\treturn ret;\n\t}\n\tif (!(reg & BMP380_STATUS_CMD_RDY_MASK)) {\n\t\tdev_err(data->dev, \"device is not ready to accept commands\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, BMP380_REG_CMD, cmd);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to send command to device\\n\");\n\t\treturn ret;\n\t}\n\t \n\tusleep_range(data->start_up_time, data->start_up_time + 100);\n\t \n\tret = regmap_read(data->regmap, BMP380_REG_ERROR, &reg);\n\tif (ret) {\n\t\tdev_err(data->dev, \"error reading ERROR reg\\n\");\n\t\treturn ret;\n\t}\n\tif (reg & BMP380_ERR_CMD_MASK) {\n\t\tdev_err(data->dev, \"error processing command 0x%X\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 bmp380_compensate_temp(struct bmp280_data *data, u32 adc_temp)\n{\n\ts64 var1, var2, var3, var4, var5, var6, comp_temp;\n\tstruct bmp380_calib *calib = &data->calib.bmp380;\n\n\tvar1 = ((s64) adc_temp) - (((s64) calib->T1) << 8);\n\tvar2 = var1 * ((s64) calib->T2);\n\tvar3 = var1 * var1;\n\tvar4 = var3 * ((s64) calib->T3);\n\tvar5 = (var2 << 18) + var4;\n\tvar6 = var5 >> 32;\n\tdata->t_fine = (s32) var6;\n\tcomp_temp = (var6 * 25) >> 14;\n\n\tcomp_temp = clamp_val(comp_temp, BMP380_MIN_TEMP, BMP380_MAX_TEMP);\n\treturn (s32) comp_temp;\n}\n\n \nstatic u32 bmp380_compensate_press(struct bmp280_data *data, u32 adc_press)\n{\n\ts64 var1, var2, var3, var4, var5, var6, offset, sensitivity;\n\tstruct bmp380_calib *calib = &data->calib.bmp380;\n\tu32 comp_press;\n\n\tvar1 = (s64)data->t_fine * (s64)data->t_fine;\n\tvar2 = var1 >> 6;\n\tvar3 = (var2 * ((s64) data->t_fine)) >> 8;\n\tvar4 = ((s64)calib->P8 * var3) >> 5;\n\tvar5 = ((s64)calib->P7 * var1) << 4;\n\tvar6 = ((s64)calib->P6 * (s64)data->t_fine) << 22;\n\toffset = ((s64)calib->P5 << 47) + var4 + var5 + var6;\n\tvar2 = ((s64)calib->P4 * var3) >> 5;\n\tvar4 = ((s64)calib->P3 * var1) << 2;\n\tvar5 = ((s64)calib->P2 - ((s64)1 << 14)) *\n\t       ((s64)data->t_fine << 21);\n\tsensitivity = (((s64) calib->P1 - ((s64) 1 << 14)) << 46) +\n\t\t\tvar2 + var4 + var5;\n\tvar1 = (sensitivity >> 24) * (s64)adc_press;\n\tvar2 = (s64)calib->P10 * (s64)data->t_fine;\n\tvar3 = var2 + ((s64)calib->P9 << 16);\n\tvar4 = (var3 * (s64)adc_press) >> 13;\n\n\t \n\tvar5 = ((s64)adc_press * div_s64(var4, 10)) >> 9;\n\tvar5 *= 10;\n\tvar6 = (s64)adc_press * (s64)adc_press;\n\tvar2 = ((s64)calib->P11 * var6) >> 16;\n\tvar3 = (var2 * (s64)adc_press) >> 7;\n\tvar4 = (offset >> 2) + var1 + var5 + var3;\n\tcomp_press = ((u64)var4 * 25) >> 40;\n\n\tcomp_press = clamp_val(comp_press, BMP380_MIN_PRES, BMP380_MAX_PRES);\n\treturn comp_press;\n}\n\nstatic int bmp380_read_temp(struct bmp280_data *data, int *val, int *val2)\n{\n\ts32 comp_temp;\n\tu32 adc_temp;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP380_REG_TEMP_XLSB,\n\t\t\t       data->buf, sizeof(data->buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to read temperature\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_temp = get_unaligned_le24(data->buf);\n\tif (adc_temp == BMP380_TEMP_SKIPPED) {\n\t\tdev_err(data->dev, \"reading temperature skipped\\n\");\n\t\treturn -EIO;\n\t}\n\tcomp_temp = bmp380_compensate_temp(data, adc_temp);\n\n\t \n\tif (val) {\n\t\t \n\t\t*val = comp_temp * 10;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp380_read_press(struct bmp280_data *data, int *val, int *val2)\n{\n\ts32 comp_press;\n\tu32 adc_press;\n\tint ret;\n\n\t \n\tret = bmp380_read_temp(data, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP380_REG_PRESS_XLSB,\n\t\t\t       data->buf, sizeof(data->buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to read pressure\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_press = get_unaligned_le24(data->buf);\n\tif (adc_press == BMP380_PRESS_SKIPPED) {\n\t\tdev_err(data->dev, \"reading pressure skipped\\n\");\n\t\treturn -EIO;\n\t}\n\tcomp_press = bmp380_compensate_press(data, adc_press);\n\n\t*val = comp_press;\n\t \n\t*val2 = 100000;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int bmp380_read_calib(struct bmp280_data *data)\n{\n\tstruct bmp380_calib *calib = &data->calib.bmp380;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(data->regmap, BMP380_REG_CALIB_TEMP_START,\n\t\t\t       data->bmp380_cal_buf, sizeof(data->bmp380_cal_buf));\n\tif (ret) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to read temperature calibration parameters\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tadd_device_randomness(data->bmp380_cal_buf, sizeof(data->bmp380_cal_buf));\n\n\t \n\tcalib->T1 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_T1]);\n\tcalib->T2 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_T2]);\n\tcalib->T3 = data->bmp380_cal_buf[BMP380_T3];\n\tcalib->P1 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_P1]);\n\tcalib->P2 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_P2]);\n\tcalib->P3 = data->bmp380_cal_buf[BMP380_P3];\n\tcalib->P4 = data->bmp380_cal_buf[BMP380_P4];\n\tcalib->P5 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_P5]);\n\tcalib->P6 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_P6]);\n\tcalib->P7 = data->bmp380_cal_buf[BMP380_P7];\n\tcalib->P8 = data->bmp380_cal_buf[BMP380_P8];\n\tcalib->P9 = get_unaligned_le16(&data->bmp380_cal_buf[BMP380_P9]);\n\tcalib->P10 = data->bmp380_cal_buf[BMP380_P10];\n\tcalib->P11 = data->bmp380_cal_buf[BMP380_P11];\n\n\treturn 0;\n}\n\nstatic const int bmp380_odr_table[][2] = {\n\t[BMP380_ODR_200HZ]\t= {200, 0},\n\t[BMP380_ODR_100HZ]\t= {100, 0},\n\t[BMP380_ODR_50HZ]\t= {50, 0},\n\t[BMP380_ODR_25HZ]\t= {25, 0},\n\t[BMP380_ODR_12_5HZ]\t= {12, 500000},\n\t[BMP380_ODR_6_25HZ]\t= {6, 250000},\n\t[BMP380_ODR_3_125HZ]\t= {3, 125000},\n\t[BMP380_ODR_1_5625HZ]\t= {1, 562500},\n\t[BMP380_ODR_0_78HZ]\t= {0, 781250},\n\t[BMP380_ODR_0_39HZ]\t= {0, 390625},\n\t[BMP380_ODR_0_2HZ]\t= {0, 195313},\n\t[BMP380_ODR_0_1HZ]\t= {0, 97656},\n\t[BMP380_ODR_0_05HZ]\t= {0, 48828},\n\t[BMP380_ODR_0_02HZ]\t= {0, 24414},\n\t[BMP380_ODR_0_01HZ]\t= {0, 12207},\n\t[BMP380_ODR_0_006HZ]\t= {0, 6104},\n\t[BMP380_ODR_0_003HZ]\t= {0, 3052},\n\t[BMP380_ODR_0_0015HZ]\t= {0, 1526},\n};\n\nstatic int bmp380_preinit(struct bmp280_data *data)\n{\n\t \n\treturn bmp380_cmd(data, BMP380_CMD_SOFT_RESET);\n}\n\nstatic int bmp380_chip_config(struct bmp280_data *data)\n{\n\tbool change = false, aux;\n\tunsigned int tmp;\n\tu8 osrs;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMP380_REG_POWER_CONTROL,\n\t\t\t\t BMP380_CTRL_SENSORS_MASK,\n\t\t\t\t BMP380_CTRL_SENSORS_PRESS_EN |\n\t\t\t\t BMP380_CTRL_SENSORS_TEMP_EN);\n\tif (ret) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to write operation control register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tosrs = FIELD_PREP(BMP380_OSRS_TEMP_MASK, data->oversampling_temp) |\n\t       FIELD_PREP(BMP380_OSRS_PRESS_MASK, data->oversampling_press);\n\n\tret = regmap_update_bits_check(data->regmap, BMP380_REG_OSR,\n\t\t\t\t       BMP380_OSRS_TEMP_MASK |\n\t\t\t\t       BMP380_OSRS_PRESS_MASK,\n\t\t\t\t       osrs, &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write oversampling register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\t \n\tret = regmap_update_bits_check(data->regmap, BMP380_REG_ODR,\n\t\t\t\t       BMP380_ODRS_MASK, data->sampling_freq, &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write ODR selection register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\t \n\tret = regmap_update_bits_check(data->regmap, BMP380_REG_CONFIG, BMP380_FILTER_MASK,\n\t\t\t\t       FIELD_PREP(BMP380_FILTER_MASK, data->iir_filter_coeff),\n\t\t\t\t       &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write config register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\tif (change) {\n\t\t \n\t\tret = regmap_write_bits(data->regmap, BMP380_REG_POWER_CONTROL,\n\t\t\t\t\tBMP380_MODE_MASK,\n\t\t\t\t\tFIELD_PREP(BMP380_MODE_MASK, BMP380_MODE_SLEEP));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"failed to set sleep mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tusleep_range(2000, 2500);\n\t\tret = regmap_write_bits(data->regmap, BMP380_REG_POWER_CONTROL,\n\t\t\t\t\tBMP380_MODE_MASK,\n\t\t\t\t\tFIELD_PREP(BMP380_MODE_MASK, BMP380_MODE_NORMAL));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"failed to set normal mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tmsleep(80);\n\n\t\t \n\t\tret = regmap_read(data->regmap, BMP380_REG_ERROR, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"failed to read error register\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (tmp & BMP380_ERR_CONF_MASK) {\n\t\t\tdev_warn(data->dev,\n\t\t\t\t\"sensor flagged configuration as incompatible\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const int bmp380_oversampling_avail[] = { 1, 2, 4, 8, 16, 32 };\nstatic const int bmp380_iir_filter_coeffs_avail[] = { 1, 2, 4, 8, 16, 32, 64, 128};\n\nconst struct bmp280_chip_info bmp380_chip_info = {\n\t.id_reg = BMP380_REG_ID,\n\t.chip_id = BMP380_CHIP_ID,\n\t.regmap_config = &bmp380_regmap_config,\n\t.start_up_time = 2000,\n\t.channels = bmp380_channels,\n\t.num_channels = 2,\n\n\t.oversampling_temp_avail = bmp380_oversampling_avail,\n\t.num_oversampling_temp_avail = ARRAY_SIZE(bmp380_oversampling_avail),\n\t.oversampling_temp_default = ilog2(1),\n\n\t.oversampling_press_avail = bmp380_oversampling_avail,\n\t.num_oversampling_press_avail = ARRAY_SIZE(bmp380_oversampling_avail),\n\t.oversampling_press_default = ilog2(4),\n\n\t.sampling_freq_avail = bmp380_odr_table,\n\t.num_sampling_freq_avail = ARRAY_SIZE(bmp380_odr_table) * 2,\n\t.sampling_freq_default = BMP380_ODR_50HZ,\n\n\t.iir_filter_coeffs_avail = bmp380_iir_filter_coeffs_avail,\n\t.num_iir_filter_coeffs_avail = ARRAY_SIZE(bmp380_iir_filter_coeffs_avail),\n\t.iir_filter_coeff_default = 2,\n\n\t.chip_config = bmp380_chip_config,\n\t.read_temp = bmp380_read_temp,\n\t.read_press = bmp380_read_press,\n\t.read_calib = bmp380_read_calib,\n\t.preinit = bmp380_preinit,\n};\nEXPORT_SYMBOL_NS(bmp380_chip_info, IIO_BMP280);\n\nstatic int bmp580_soft_reset(struct bmp280_data *data)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_write(data->regmap, BMP580_REG_CMD, BMP580_CMD_SOFT_RESET);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to send reset command to device\\n\");\n\t\treturn ret;\n\t}\n\tusleep_range(2000, 2500);\n\n\t \n\tret = regmap_read(data->regmap, BMP580_REG_CHIP_ID, &reg);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to reestablish comms after reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(data->regmap, BMP580_REG_INT_STATUS, &reg);\n\tif (ret) {\n\t\tdev_err(data->dev, \"error reading interrupt status register\\n\");\n\t\treturn ret;\n\t}\n\tif (!(reg & BMP580_INT_STATUS_POR_MASK)) {\n\t\tdev_err(data->dev, \"error resetting sensor\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bmp580_nvm_operation(struct bmp280_data *data, bool is_write)\n{\n\tunsigned long timeout, poll;\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tret = regmap_read(data->regmap, BMP580_REG_STATUS, &reg);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to check nvm status\\n\");\n\t\treturn ret;\n\t}\n\tif (!(reg & BMP580_STATUS_NVM_RDY_MASK)) {\n\t\tdev_err(data->dev, \"sensor's nvm is not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, BMP580_REG_CMD, BMP580_CMD_NVM_OP_SEQ_0);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to send nvm operation's first sequence\\n\");\n\t\treturn ret;\n\t}\n\tif (is_write) {\n\t\t \n\t\tret = regmap_write(data->regmap, BMP580_REG_CMD,\n\t\t\t\t   BMP580_CMD_NVM_WRITE_SEQ_1);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"failed to send nvm write sequence\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tpoll = 2000;\n\t\ttimeout = 12000;\n\t} else {\n\t\t \n\t\tret = regmap_write(data->regmap, BMP580_REG_CMD,\n\t\t\t\t   BMP580_CMD_NVM_READ_SEQ_1);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"failed to send nvm read sequence\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tpoll = 50;\n\t\ttimeout = 400;\n\t}\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write command sequence\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(data->regmap, BMP580_REG_STATUS, reg,\n\t\t\t\t       (reg & BMP580_STATUS_NVM_RDY_MASK),\n\t\t\t\t       poll, timeout);\n\tif (ret) {\n\t\tdev_err(data->dev, \"error checking nvm operation status\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((reg & BMP580_STATUS_NVM_ERR_MASK) || (reg & BMP580_STATUS_NVM_CMD_ERR_MASK)) {\n\t\tdev_err(data->dev, \"error processing nvm operation\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int bmp580_read_temp(struct bmp280_data *data, int *val, int *val2)\n{\n\ts32 raw_temp;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP580_REG_TEMP_XLSB, data->buf,\n\t\t\t       sizeof(data->buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to read temperature\\n\");\n\t\treturn ret;\n\t}\n\n\traw_temp = get_unaligned_le24(data->buf);\n\tif (raw_temp == BMP580_TEMP_SKIPPED) {\n\t\tdev_err(data->dev, \"reading temperature skipped\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\t*val = raw_temp * 1000;\n\t*val2 = 16;\n\treturn IIO_VAL_FRACTIONAL_LOG2;\n}\n\nstatic int bmp580_read_press(struct bmp280_data *data, int *val, int *val2)\n{\n\tu32 raw_press;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP580_REG_PRESS_XLSB, data->buf,\n\t\t\t       sizeof(data->buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to read pressure\\n\");\n\t\treturn ret;\n\t}\n\n\traw_press = get_unaligned_le24(data->buf);\n\tif (raw_press == BMP580_PRESS_SKIPPED) {\n\t\tdev_err(data->dev, \"reading pressure skipped\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\t*val = raw_press;\n\t*val2 = 64000;  \n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic const int bmp580_odr_table[][2] = {\n\t[BMP580_ODR_240HZ] =\t{240, 0},\n\t[BMP580_ODR_218HZ] =\t{218, 0},\n\t[BMP580_ODR_199HZ] =\t{199, 0},\n\t[BMP580_ODR_179HZ] =\t{179, 0},\n\t[BMP580_ODR_160HZ] =\t{160, 0},\n\t[BMP580_ODR_149HZ] =\t{149, 0},\n\t[BMP580_ODR_140HZ] =\t{140, 0},\n\t[BMP580_ODR_129HZ] =\t{129, 0},\n\t[BMP580_ODR_120HZ] =\t{120, 0},\n\t[BMP580_ODR_110HZ] =\t{110, 0},\n\t[BMP580_ODR_100HZ] =\t{100, 0},\n\t[BMP580_ODR_89HZ] =\t{89, 0},\n\t[BMP580_ODR_80HZ] =\t{80, 0},\n\t[BMP580_ODR_70HZ] =\t{70, 0},\n\t[BMP580_ODR_60HZ] =\t{60, 0},\n\t[BMP580_ODR_50HZ] =\t{50, 0},\n\t[BMP580_ODR_45HZ] =\t{45, 0},\n\t[BMP580_ODR_40HZ] =\t{40, 0},\n\t[BMP580_ODR_35HZ] =\t{35, 0},\n\t[BMP580_ODR_30HZ] =\t{30, 0},\n\t[BMP580_ODR_25HZ] =\t{25, 0},\n\t[BMP580_ODR_20HZ] =\t{20, 0},\n\t[BMP580_ODR_15HZ] =\t{15, 0},\n\t[BMP580_ODR_10HZ] =\t{10, 0},\n\t[BMP580_ODR_5HZ] =\t{5, 0},\n\t[BMP580_ODR_4HZ] =\t{4, 0},\n\t[BMP580_ODR_3HZ] =\t{3, 0},\n\t[BMP580_ODR_2HZ] =\t{2, 0},\n\t[BMP580_ODR_1HZ] =\t{1, 0},\n\t[BMP580_ODR_0_5HZ] =\t{0, 500000},\n\t[BMP580_ODR_0_25HZ] =\t{0, 250000},\n\t[BMP580_ODR_0_125HZ] =\t{0, 125000},\n};\n\nstatic const int bmp580_nvmem_addrs[] = { 0x20, 0x21, 0x22 };\n\nstatic int bmp580_nvmem_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct bmp280_data *data = priv;\n\tu16 *dst = val;\n\tint ret, addr;\n\n\tpm_runtime_get_sync(data->dev);\n\tmutex_lock(&data->lock);\n\n\t \n\tret = regmap_update_bits(data->regmap, BMP580_REG_ODR_CONFIG,\n\t\t\t\t BMP580_MODE_MASK | BMP580_ODR_DEEPSLEEP_DIS,\n\t\t\t\t BMP580_ODR_DEEPSLEEP_DIS |\n\t\t\t\t FIELD_PREP(BMP580_MODE_MASK, BMP580_MODE_SLEEP));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to change sensor to standby mode\\n\");\n\t\tgoto exit;\n\t}\n\t \n\tusleep_range(2500, 3000);\n\n\twhile (bytes >= sizeof(*dst)) {\n\t\taddr = bmp580_nvmem_addrs[offset / sizeof(*dst)];\n\n\t\tret = regmap_write(data->regmap, BMP580_REG_NVM_ADDR,\n\t\t\t\t   FIELD_PREP(BMP580_NVM_ROW_ADDR_MASK, addr));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error writing nvm address\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = bmp580_nvm_operation(data, false);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = regmap_bulk_read(data->regmap, BMP580_REG_NVM_DATA_LSB, &data->le16,\n\t\t\t\t       sizeof(data->le16));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error reading nvm data regs\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t*dst++ = le16_to_cpu(data->le16);\n\t\tbytes -= sizeof(*dst);\n\t\toffset += sizeof(*dst);\n\t}\nexit:\n\t \n\tdata->chip_info->chip_config(data);\n\tmutex_unlock(&data->lock);\n\tpm_runtime_mark_last_busy(data->dev);\n\tpm_runtime_put_autosuspend(data->dev);\n\treturn ret;\n}\n\nstatic int bmp580_nvmem_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct bmp280_data *data = priv;\n\tu16 *buf = val;\n\tint ret, addr;\n\n\tpm_runtime_get_sync(data->dev);\n\tmutex_lock(&data->lock);\n\n\t \n\tret = regmap_update_bits(data->regmap, BMP580_REG_ODR_CONFIG,\n\t\t\t\t BMP580_MODE_MASK | BMP580_ODR_DEEPSLEEP_DIS,\n\t\t\t\t BMP580_ODR_DEEPSLEEP_DIS |\n\t\t\t\t FIELD_PREP(BMP580_MODE_MASK, BMP580_MODE_SLEEP));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to change sensor to standby mode\\n\");\n\t\tgoto exit;\n\t}\n\t \n\tusleep_range(2500, 3000);\n\n\twhile (bytes >= sizeof(*buf)) {\n\t\taddr = bmp580_nvmem_addrs[offset / sizeof(*buf)];\n\n\t\tret = regmap_write(data->regmap, BMP580_REG_NVM_ADDR, BMP580_NVM_PROG_EN |\n\t\t\t\t   FIELD_PREP(BMP580_NVM_ROW_ADDR_MASK, addr));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error writing nvm address\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tdata->le16 = cpu_to_le16(*buf++);\n\n\t\tret = regmap_bulk_write(data->regmap, BMP580_REG_NVM_DATA_LSB, &data->le16,\n\t\t\t\t\tsizeof(data->le16));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error writing LSB NVM data regs\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = bmp580_nvm_operation(data, true);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = regmap_update_bits(data->regmap, BMP580_REG_NVM_ADDR,\n\t\t\t\t\t BMP580_NVM_PROG_EN, 0);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error resetting nvm write\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbytes -= sizeof(*buf);\n\t\toffset += sizeof(*buf);\n\t}\nexit:\n\t \n\tdata->chip_info->chip_config(data);\n\tmutex_unlock(&data->lock);\n\tpm_runtime_mark_last_busy(data->dev);\n\tpm_runtime_put_autosuspend(data->dev);\n\treturn ret;\n}\n\nstatic int bmp580_preinit(struct bmp280_data *data)\n{\n\tstruct nvmem_config config = {\n\t\t.dev = data->dev,\n\t\t.priv = data,\n\t\t.name = \"bmp580_nvmem\",\n\t\t.word_size = sizeof(u16),\n\t\t.stride = sizeof(u16),\n\t\t.size = 3 * sizeof(u16),\n\t\t.reg_read = bmp580_nvmem_read,\n\t\t.reg_write = bmp580_nvmem_write,\n\t};\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tret = bmp580_soft_reset(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(data->regmap, BMP580_REG_CHIP_ID, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (reg != BMP580_CHIP_ID && reg != BMP580_CHIP_ID_ALT)\n\t\tdev_warn(data->dev, \"preinit: unexpected chip_id\\n\");\n\n\tret = regmap_read(data->regmap, BMP580_REG_STATUS, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(reg & BMP580_STATUS_NVM_RDY_MASK) || (reg & BMP580_STATUS_NVM_ERR_MASK)) {\n\t\tdev_err(data->dev, \"preinit: nvm error on powerup sequence\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\treturn PTR_ERR_OR_ZERO(devm_nvmem_register(config.dev, &config));\n}\n\nstatic int bmp580_chip_config(struct bmp280_data *data)\n{\n\tbool change = false, aux;\n\tunsigned int tmp;\n\tu8 reg_val;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMP580_REG_ODR_CONFIG,\n\t\t\t\t BMP580_MODE_MASK | BMP580_ODR_DEEPSLEEP_DIS,\n\t\t\t\t BMP580_ODR_DEEPSLEEP_DIS |\n\t\t\t\t FIELD_PREP(BMP580_MODE_MASK, BMP580_MODE_SLEEP));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to change sensor to standby mode\\n\");\n\t\treturn ret;\n\t}\n\t \n\tusleep_range(2500, 3000);\n\n\t \n\treg_val = FIELD_PREP(BMP580_DSP_COMP_MASK, BMP580_DSP_PRESS_TEMP_COMP_EN) |\n\t\t  BMP580_DSP_SHDW_IIR_TEMP_EN | BMP580_DSP_SHDW_IIR_PRESS_EN;\n\n\tret = regmap_update_bits(data->regmap, BMP580_REG_DSP_CONFIG,\n\t\t\t\t BMP580_DSP_COMP_MASK |\n\t\t\t\t BMP580_DSP_SHDW_IIR_TEMP_EN |\n\t\t\t\t BMP580_DSP_SHDW_IIR_PRESS_EN, reg_val);\n\n\t \n\treg_val = FIELD_PREP(BMP580_OSR_TEMP_MASK, data->oversampling_temp) |\n\t\t  FIELD_PREP(BMP580_OSR_PRESS_MASK, data->oversampling_press) |\n\t\t  BMP580_OSR_PRESS_EN;\n\n\tret = regmap_update_bits_check(data->regmap, BMP580_REG_OSR_CONFIG,\n\t\t\t\t       BMP580_OSR_TEMP_MASK | BMP580_OSR_PRESS_MASK |\n\t\t\t\t       BMP580_OSR_PRESS_EN,\n\t\t\t\t       reg_val, &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write oversampling register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\t \n\tret = regmap_update_bits_check(data->regmap, BMP580_REG_ODR_CONFIG, BMP580_ODR_MASK,\n\t\t\t\t       FIELD_PREP(BMP580_ODR_MASK, data->sampling_freq),\n\t\t\t\t       &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write ODR configuration register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\t \n\treg_val = FIELD_PREP(BMP580_DSP_IIR_PRESS_MASK, data->iir_filter_coeff) |\n\t\t  FIELD_PREP(BMP580_DSP_IIR_TEMP_MASK, data->iir_filter_coeff);\n\n\tret = regmap_update_bits_check(data->regmap, BMP580_REG_DSP_IIR,\n\t\t\t\t       BMP580_DSP_IIR_PRESS_MASK |\n\t\t\t\t       BMP580_DSP_IIR_TEMP_MASK,\n\t\t\t\t       reg_val, &aux);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to write config register\\n\");\n\t\treturn ret;\n\t}\n\tchange = change || aux;\n\n\t \n\tret = regmap_write_bits(data->regmap, BMP580_REG_ODR_CONFIG,\n\t\t\t\tBMP580_MODE_MASK,\n\t\t\t\tFIELD_PREP(BMP580_MODE_MASK, BMP580_MODE_NORMAL));\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to set normal mode\\n\");\n\t\treturn ret;\n\t}\n\t \n\tusleep_range(3000, 3500);\n\n\tif (change) {\n\t\t \n\t\tret = regmap_read(data->regmap, BMP580_REG_EFF_OSR, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"error reading effective OSR register\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(tmp & BMP580_EFF_OSR_VALID_ODR)) {\n\t\t\tdev_warn(data->dev, \"OSR and ODR incompatible settings detected\\n\");\n\t\t\t \n\t\t\tdata->oversampling_temp = FIELD_GET(BMP580_EFF_OSR_TEMP_MASK, tmp);\n\t\t\tdata->oversampling_press = FIELD_GET(BMP580_EFF_OSR_PRESS_MASK, tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const int bmp580_oversampling_avail[] = { 1, 2, 4, 8, 16, 32, 64, 128 };\n\nconst struct bmp280_chip_info bmp580_chip_info = {\n\t.id_reg = BMP580_REG_CHIP_ID,\n\t.chip_id = BMP580_CHIP_ID,\n\t.regmap_config = &bmp580_regmap_config,\n\t.start_up_time = 2000,\n\t.channels = bmp380_channels,\n\t.num_channels = 2,\n\n\t.oversampling_temp_avail = bmp580_oversampling_avail,\n\t.num_oversampling_temp_avail = ARRAY_SIZE(bmp580_oversampling_avail),\n\t.oversampling_temp_default = ilog2(1),\n\n\t.oversampling_press_avail = bmp580_oversampling_avail,\n\t.num_oversampling_press_avail = ARRAY_SIZE(bmp580_oversampling_avail),\n\t.oversampling_press_default = ilog2(4),\n\n\t.sampling_freq_avail = bmp580_odr_table,\n\t.num_sampling_freq_avail = ARRAY_SIZE(bmp580_odr_table) * 2,\n\t.sampling_freq_default = BMP580_ODR_50HZ,\n\n\t.iir_filter_coeffs_avail = bmp380_iir_filter_coeffs_avail,\n\t.num_iir_filter_coeffs_avail = ARRAY_SIZE(bmp380_iir_filter_coeffs_avail),\n\t.iir_filter_coeff_default = 2,\n\n\t.chip_config = bmp580_chip_config,\n\t.read_temp = bmp580_read_temp,\n\t.read_press = bmp580_read_press,\n\t.preinit = bmp580_preinit,\n};\nEXPORT_SYMBOL_NS(bmp580_chip_info, IIO_BMP280);\n\nstatic int bmp180_measure(struct bmp280_data *data, u8 ctrl_meas)\n{\n\tconst int conversion_time_max[] = { 4500, 7500, 13500, 25500 };\n\tunsigned int delay_us;\n\tunsigned int ctrl;\n\tint ret;\n\n\tif (data->use_eoc)\n\t\treinit_completion(&data->done);\n\n\tret = regmap_write(data->regmap, BMP280_REG_CTRL_MEAS, ctrl_meas);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->use_eoc) {\n\t\t \n\t\tret = wait_for_completion_timeout(&data->done,\n\t\t\t\t\t\t  1 + msecs_to_jiffies(100));\n\t\tif (!ret)\n\t\t\tdev_err(data->dev, \"timeout waiting for completion\\n\");\n\t} else {\n\t\tif (FIELD_GET(BMP180_MEAS_CTRL_MASK, ctrl_meas) == BMP180_MEAS_TEMP)\n\t\t\tdelay_us = 4500;\n\t\telse\n\t\t\tdelay_us =\n\t\t\t\tconversion_time_max[data->oversampling_press];\n\n\t\tusleep_range(delay_us, delay_us + 1000);\n\t}\n\n\tret = regmap_read(data->regmap, BMP280_REG_CTRL_MEAS, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctrl & BMP180_MEAS_SCO)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int bmp180_read_adc_temp(struct bmp280_data *data, int *val)\n{\n\tint ret;\n\n\tret = bmp180_measure(data,\n\t\t\t     FIELD_PREP(BMP180_MEAS_CTRL_MASK, BMP180_MEAS_TEMP) |\n\t\t\t     BMP180_MEAS_SCO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP180_REG_OUT_MSB,\n\t\t\t       &data->be16, sizeof(data->be16));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(data->be16);\n\n\treturn 0;\n}\n\nstatic int bmp180_read_calib(struct bmp280_data *data)\n{\n\tstruct bmp180_calib *calib = &data->calib.bmp180;\n\tint ret;\n\tint i;\n\n\tret = regmap_bulk_read(data->regmap, BMP180_REG_CALIB_START,\n\t\t\t       data->bmp180_cal_buf, sizeof(data->bmp180_cal_buf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->bmp180_cal_buf); i++) {\n\t\tif (data->bmp180_cal_buf[i] == cpu_to_be16(0) ||\n\t\t    data->bmp180_cal_buf[i] == cpu_to_be16(0xffff))\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tadd_device_randomness(data->bmp180_cal_buf, sizeof(data->bmp180_cal_buf));\n\n\tcalib->AC1 = be16_to_cpu(data->bmp180_cal_buf[AC1]);\n\tcalib->AC2 = be16_to_cpu(data->bmp180_cal_buf[AC2]);\n\tcalib->AC3 = be16_to_cpu(data->bmp180_cal_buf[AC3]);\n\tcalib->AC4 = be16_to_cpu(data->bmp180_cal_buf[AC4]);\n\tcalib->AC5 = be16_to_cpu(data->bmp180_cal_buf[AC5]);\n\tcalib->AC6 = be16_to_cpu(data->bmp180_cal_buf[AC6]);\n\tcalib->B1 = be16_to_cpu(data->bmp180_cal_buf[B1]);\n\tcalib->B2 = be16_to_cpu(data->bmp180_cal_buf[B2]);\n\tcalib->MB = be16_to_cpu(data->bmp180_cal_buf[MB]);\n\tcalib->MC = be16_to_cpu(data->bmp180_cal_buf[MC]);\n\tcalib->MD = be16_to_cpu(data->bmp180_cal_buf[MD]);\n\n\treturn 0;\n}\n\n \nstatic s32 bmp180_compensate_temp(struct bmp280_data *data, s32 adc_temp)\n{\n\tstruct bmp180_calib *calib = &data->calib.bmp180;\n\ts32 x1, x2;\n\n\tx1 = ((adc_temp - calib->AC6) * calib->AC5) >> 15;\n\tx2 = (calib->MC << 11) / (x1 + calib->MD);\n\tdata->t_fine = x1 + x2;\n\n\treturn (data->t_fine + 8) >> 4;\n}\n\nstatic int bmp180_read_temp(struct bmp280_data *data, int *val, int *val2)\n{\n\ts32 adc_temp, comp_temp;\n\tint ret;\n\n\tret = bmp180_read_adc_temp(data, &adc_temp);\n\tif (ret)\n\t\treturn ret;\n\n\tcomp_temp = bmp180_compensate_temp(data, adc_temp);\n\n\t \n\tif (val) {\n\t\t*val = comp_temp * 100;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp180_read_adc_press(struct bmp280_data *data, int *val)\n{\n\tu8 oss = data->oversampling_press;\n\tint ret;\n\n\tret = bmp180_measure(data,\n\t\t\t     FIELD_PREP(BMP180_MEAS_CTRL_MASK, BMP180_MEAS_PRESS) |\n\t\t\t     FIELD_PREP(BMP180_OSRS_PRESS_MASK, oss) |\n\t\t\t     BMP180_MEAS_SCO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BMP180_REG_OUT_MSB,\n\t\t\t       data->buf, sizeof(data->buf));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = get_unaligned_be24(data->buf) >> (8 - oss);\n\n\treturn 0;\n}\n\n \nstatic u32 bmp180_compensate_press(struct bmp280_data *data, s32 adc_press)\n{\n\tstruct bmp180_calib *calib = &data->calib.bmp180;\n\ts32 oss = data->oversampling_press;\n\ts32 x1, x2, x3, p;\n\ts32 b3, b6;\n\tu32 b4, b7;\n\n\tb6 = data->t_fine - 4000;\n\tx1 = (calib->B2 * (b6 * b6 >> 12)) >> 11;\n\tx2 = calib->AC2 * b6 >> 11;\n\tx3 = x1 + x2;\n\tb3 = ((((s32)calib->AC1 * 4 + x3) << oss) + 2) / 4;\n\tx1 = calib->AC3 * b6 >> 13;\n\tx2 = (calib->B1 * ((b6 * b6) >> 12)) >> 16;\n\tx3 = (x1 + x2 + 2) >> 2;\n\tb4 = calib->AC4 * (u32)(x3 + 32768) >> 15;\n\tb7 = ((u32)adc_press - b3) * (50000 >> oss);\n\tif (b7 < 0x80000000)\n\t\tp = (b7 * 2) / b4;\n\telse\n\t\tp = (b7 / b4) * 2;\n\n\tx1 = (p >> 8) * (p >> 8);\n\tx1 = (x1 * 3038) >> 16;\n\tx2 = (-7357 * p) >> 16;\n\n\treturn p + ((x1 + x2 + 3791) >> 4);\n}\n\nstatic int bmp180_read_press(struct bmp280_data *data,\n\t\t\t     int *val, int *val2)\n{\n\tu32 comp_press;\n\ts32 adc_press;\n\tint ret;\n\n\t \n\tret = bmp180_read_temp(data, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bmp180_read_adc_press(data, &adc_press);\n\tif (ret)\n\t\treturn ret;\n\n\tcomp_press = bmp180_compensate_press(data, adc_press);\n\n\t*val = comp_press;\n\t*val2 = 1000;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int bmp180_chip_config(struct bmp280_data *data)\n{\n\treturn 0;\n}\n\nstatic const int bmp180_oversampling_temp_avail[] = { 1 };\nstatic const int bmp180_oversampling_press_avail[] = { 1, 2, 4, 8 };\n\nconst struct bmp280_chip_info bmp180_chip_info = {\n\t.id_reg = BMP280_REG_ID,\n\t.chip_id = BMP180_CHIP_ID,\n\t.regmap_config = &bmp180_regmap_config,\n\t.start_up_time = 2000,\n\t.channels = bmp280_channels,\n\t.num_channels = 2,\n\n\t.oversampling_temp_avail = bmp180_oversampling_temp_avail,\n\t.num_oversampling_temp_avail =\n\t\tARRAY_SIZE(bmp180_oversampling_temp_avail),\n\t.oversampling_temp_default = 0,\n\n\t.oversampling_press_avail = bmp180_oversampling_press_avail,\n\t.num_oversampling_press_avail =\n\t\tARRAY_SIZE(bmp180_oversampling_press_avail),\n\t.oversampling_press_default = BMP180_MEAS_PRESS_8X,\n\n\t.chip_config = bmp180_chip_config,\n\t.read_temp = bmp180_read_temp,\n\t.read_press = bmp180_read_press,\n\t.read_calib = bmp180_read_calib,\n};\nEXPORT_SYMBOL_NS(bmp180_chip_info, IIO_BMP280);\n\nstatic irqreturn_t bmp085_eoc_irq(int irq, void *d)\n{\n\tstruct bmp280_data *data = d;\n\n\tcomplete(&data->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bmp085_fetch_eoc_irq(struct device *dev,\n\t\t\t\tconst char *name,\n\t\t\t\tint irq,\n\t\t\t\tstruct bmp280_data *data)\n{\n\tunsigned long irq_trig;\n\tint ret;\n\n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\n\tif (irq_trig != IRQF_TRIGGER_RISING) {\n\t\tdev_err(dev, \"non-rising trigger given for EOC interrupt, trying to enforce it\\n\");\n\t\tirq_trig = IRQF_TRIGGER_RISING;\n\t}\n\n\tinit_completion(&data->done);\n\n\tret = devm_request_threaded_irq(dev,\n\t\t\tirq,\n\t\t\tbmp085_eoc_irq,\n\t\t\tNULL,\n\t\t\tirq_trig,\n\t\t\tname,\n\t\t\tdata);\n\tif (ret) {\n\t\t \n\t\tdev_err(dev, \"unable to request DRDY IRQ\\n\");\n\t\treturn 0;\n\t}\n\n\tdata->use_eoc = true;\n\treturn 0;\n}\n\nstatic void bmp280_pm_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic void bmp280_regulators_disable(void *data)\n{\n\tstruct regulator_bulk_data *supplies = data;\n\n\tregulator_bulk_disable(BMP280_NUM_SUPPLIES, supplies);\n}\n\nint bmp280_common_probe(struct device *dev,\n\t\t\tstruct regmap *regmap,\n\t\t\tconst struct bmp280_chip_info *chip_info,\n\t\t\tconst char *name,\n\t\t\tint irq)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct bmp280_data *data;\n\tstruct gpio_desc *gpiod;\n\tunsigned int chip_id;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tmutex_init(&data->lock);\n\tdata->dev = dev;\n\n\tindio_dev->name = name;\n\tindio_dev->info = &bmp280_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tdata->chip_info = chip_info;\n\n\t \n\tindio_dev->channels = chip_info->channels;\n\tindio_dev->num_channels = chip_info->num_channels;\n\tdata->oversampling_press = chip_info->oversampling_press_default;\n\tdata->oversampling_humid = chip_info->oversampling_humid_default;\n\tdata->oversampling_temp = chip_info->oversampling_temp_default;\n\tdata->iir_filter_coeff = chip_info->iir_filter_coeff_default;\n\tdata->sampling_freq = chip_info->sampling_freq_default;\n\tdata->start_up_time = chip_info->start_up_time;\n\n\t \n\tregulator_bulk_set_supply_names(data->supplies,\n\t\t\t\t\tbmp280_supply_names,\n\t\t\t\t\tBMP280_NUM_SUPPLIES);\n\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      BMP280_NUM_SUPPLIES, data->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(BMP280_NUM_SUPPLIES, data->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, bmp280_regulators_disable,\n\t\t\t\t       data->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(data->start_up_time, data->start_up_time + 100);\n\n\t \n\tgpiod = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\t \n\tif (gpiod) {\n\t\tdev_info(dev, \"release reset\\n\");\n\t\tgpiod_set_value(gpiod, 0);\n\t}\n\n\tdata->regmap = regmap;\n\n\tret = regmap_read(regmap, data->chip_info->id_reg, &chip_id);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (chip_id != data->chip_info->chip_id) {\n\t\tdev_err(dev, \"bad chip id: expected %x got %x\\n\",\n\t\t\tdata->chip_info->chip_id, chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->chip_info->preinit) {\n\t\tret = data->chip_info->preinit(data);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t\t     \"error running preinit tasks\\n\");\n\t}\n\n\tret = data->chip_info->chip_config(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\t \n\n\tif (data->chip_info->read_calib) {\n\t\tret = data->chip_info->read_calib(data);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t\t     \"failed to read calibration coefficients\\n\");\n\t}\n\n\t \n\tif (irq > 0 && (chip_id  == BMP180_CHIP_ID)) {\n\t\tret = bmp085_fetch_eoc_irq(dev, name, irq, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_set_autosuspend_delay(dev, data->start_up_time / 10);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\tret = devm_add_action_or_reset(dev, bmp280_pm_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS(bmp280_common_probe, IIO_BMP280);\n\nstatic int bmp280_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmp280_data *data = iio_priv(indio_dev);\n\n\treturn regulator_bulk_disable(BMP280_NUM_SUPPLIES, data->supplies);\n}\n\nstatic int bmp280_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmp280_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(BMP280_NUM_SUPPLIES, data->supplies);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(data->start_up_time, data->start_up_time + 100);\n\treturn data->chip_info->chip_config(data);\n}\n\nEXPORT_RUNTIME_DEV_PM_OPS(bmp280_dev_pm_ops, bmp280_runtime_suspend,\n\t\t\t  bmp280_runtime_resume, NULL);\n\nMODULE_AUTHOR(\"Vlad Dogaru <vlad.dogaru@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for Bosch Sensortec BMP180/BMP280 pressure and temperature sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}