{
  "module_name": "t5403.c",
  "hash_id": "98c718a371aa77ce85895f806ed8222192e5388f5afcb165335626ea6e229508",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/t5403.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/delay.h>\n\n#define T5403_DATA 0xf5  \n#define T5403_CALIB_DATA 0x8e  \n#define T5403_SLAVE_ADDR 0x88  \n#define T5403_COMMAND 0xf1\n\n \n#define T5403_MODE_SHIFT 3  \n#define T5403_PT BIT(1)  \n#define T5403_SCO BIT(0)  \n\n#define T5403_MODE_LOW 0\n#define T5403_MODE_STANDARD 1\n#define T5403_MODE_HIGH 2\n#define T5403_MODE_ULTRA_HIGH 3\n\n#define T5403_I2C_MASK (~BIT(7))\n#define T5403_I2C_ADDR 0x77\n\nstatic const int t5403_pressure_conv_ms[] = {2, 8, 16, 66};\n\nstruct t5403_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tint mode;\n\t__le16 c[10];\n};\n\n#define T5403_C_U16(i) le16_to_cpu(data->c[(i) - 1])\n#define T5403_C(i) sign_extend32(T5403_C_U16(i), 15)\n\nstatic int t5403_read(struct t5403_data *data, bool pressure)\n{\n\tint wait_time = 3;   \n\n\tint ret = i2c_smbus_write_byte_data(data->client, T5403_COMMAND,\n\t\t(pressure ? (data->mode << T5403_MODE_SHIFT) : T5403_PT) |\n\t\tT5403_SCO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twait_time += pressure ? t5403_pressure_conv_ms[data->mode] : 2;\n\n\tmsleep(wait_time);\n\n\treturn i2c_smbus_read_word_data(data->client, T5403_DATA);\n}\n\nstatic int t5403_comp_pressure(struct t5403_data *data, int *val, int *val2)\n{\n\tint ret;\n\ts16 t_r;\n\tu16 p_r;\n\ts32 S, O, X;\n\n\tmutex_lock(&data->lock);\n\n\tret = t5403_read(data, false);\n\tif (ret < 0)\n\t\tgoto done;\n\tt_r = ret;\n\n\tret = t5403_read(data, true);\n\tif (ret < 0)\n\t\tgoto done;\n\tp_r = ret;\n\n\t \n\tS = T5403_C_U16(3) + (s32) T5403_C_U16(4) * t_r / 0x20000 +\n\t\tT5403_C(5) * t_r / 0x8000 * t_r / 0x80000 +\n\t\tT5403_C(9) * t_r / 0x8000 * t_r / 0x8000 * t_r / 0x10000;\n\n\tO = T5403_C(6) * 0x4000 + T5403_C(7) * t_r / 8 +\n\t\tT5403_C(8) * t_r / 0x8000 * t_r / 16 +\n\t\tT5403_C(9) * t_r / 0x8000 * t_r / 0x10000 * t_r;\n\n\tX = (S * p_r + O) / 0x4000;\n\n\tX += ((X - 75000) * (X - 75000) / 0x10000 - 9537) *\n\t    T5403_C(10) / 0x10000;\n\n\t*val = X / 1000;\n\t*val2 = (X % 1000) * 1000;\n\ndone:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int t5403_comp_temp(struct t5403_data *data, int *val)\n{\n\tint ret;\n\ts16 t_r;\n\n\tmutex_lock(&data->lock);\n\tret = t5403_read(data, false);\n\tif (ret < 0)\n\t\tgoto done;\n\tt_r = ret;\n\n\t \n\t*val = ((s32) T5403_C_U16(1) * t_r / 0x100 +\n\t\t(s32) T5403_C_U16(2) * 0x40) * 1000 / 0x10000;\n\ndone:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int t5403_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct t5403_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\tret = t5403_comp_pressure(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\tret = t5403_comp_temp(data, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t    }\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = t5403_pressure_conv_ms[data->mode] * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int t5403_write_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int val, int val2, long mask)\n{\n\tstruct t5403_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(t5403_pressure_conv_ms); i++)\n\t\t\tif (val2 == t5403_pressure_conv_ms[i] * 1000) {\n\t\t\t\tmutex_lock(&data->lock);\n\t\t\t\tdata->mode = i;\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec t5403_channels[] = {\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t    BIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n};\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.002 0.008 0.016 0.066\");\n\nstatic struct attribute *t5403_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group t5403_attribute_group = {\n\t.attrs = t5403_attributes,\n};\n\nstatic const struct iio_info t5403_info = {\n\t.read_raw = &t5403_read_raw,\n\t.write_raw = &t5403_write_raw,\n\t.attrs = &t5403_attribute_group,\n};\n\nstatic int t5403_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct t5403_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\tret = i2c_smbus_read_byte_data(client, T5403_SLAVE_ADDR);\n\tif (ret < 0)\n\t\treturn ret;\n\tif ((ret & T5403_I2C_MASK) != T5403_I2C_ADDR)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tindio_dev->info = &t5403_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = t5403_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(t5403_channels);\n\n\tdata->mode = T5403_MODE_STANDARD;\n\n\tret = i2c_smbus_read_i2c_block_data(data->client, T5403_CALIB_DATA,\n\t    sizeof(data->c), (u8 *) data->c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id t5403_id[] = {\n\t{ \"t5403\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, t5403_id);\n\nstatic struct i2c_driver t5403_driver = {\n\t.driver = {\n\t\t.name\t= \"t5403\",\n\t},\n\t.probe = t5403_probe,\n\t.id_table = t5403_id,\n};\nmodule_i2c_driver(t5403_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"EPCOS T5403 pressure/temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}