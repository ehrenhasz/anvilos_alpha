{
  "module_name": "ms5637.c",
  "hash_id": "b79f74f7de1d0f689b165d465a6455abea6466652c9c4e3b8c33a7839707f379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/pressure/ms5637.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/mutex.h>\n\n#include \"../common/ms_sensors/ms_sensors_i2c.h\"\n\nstruct ms_tp_data {\n\tconst char *name;\n\tconst struct ms_tp_hw_data *hw;\n};\n\nstatic const int ms5637_samp_freq[6] = { 960, 480, 240, 120, 60, 30 };\n\nstatic ssize_t ms5637_show_samp_freq(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ms_tp_dev *dev_data = iio_priv(indio_dev);\n\tint i, len = 0;\n\n\tfor (i = 0; i <= dev_data->hw->max_res_index; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%u \", ms5637_samp_freq[i]);\n\tsysfs_emit_at(buf, len - 1, \"\\n\");\n\n\treturn len;\n}\n\nstatic int ms5637_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *channel, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tint ret;\n\tint temperature;\n\tunsigned int pressure;\n\tstruct ms_tp_dev *dev_data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = ms_sensors_read_temp_and_pressure(dev_data,\n\t\t\t\t\t\t\t&temperature,\n\t\t\t\t\t\t\t&pressure);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (channel->type) {\n\t\tcase IIO_TEMP:\t \n\t\t\t*val = temperature;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PRESSURE:\t \n\t\t\t*val = pressure / 1000;\n\t\t\t*val2 = (pressure % 1000) * 1000;\n\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = ms5637_samp_freq[dev_data->res_index];\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ms5637_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ms_tp_dev *dev_data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = ARRAY_SIZE(ms5637_samp_freq);\n\t\twhile (i-- > 0)\n\t\t\tif (val == ms5637_samp_freq[i])\n\t\t\t\tbreak;\n\t\tif (i < 0)\n\t\t\treturn -EINVAL;\n\t\tdev_data->res_index = i;\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec ms5637_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t}\n};\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(ms5637_show_samp_freq);\n\nstatic struct attribute *ms5637_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ms5637_attribute_group = {\n\t.attrs = ms5637_attributes,\n};\n\nstatic const struct iio_info ms5637_info = {\n\t.read_raw = ms5637_read_raw,\n\t.write_raw = ms5637_write_raw,\n\t.attrs = &ms5637_attribute_group,\n};\n\nstatic int ms5637_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct ms_tp_data *data;\n\tstruct ms_tp_dev *dev_data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Adapter does not support some i2c transaction\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (id)\n\t\tdata = (const struct ms_tp_data *)id->driver_data;\n\telse\n\t\tdata = device_get_match_data(&client->dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*dev_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_data = iio_priv(indio_dev);\n\tdev_data->client = client;\n\tdev_data->res_index = data->hw->max_res_index;\n\tdev_data->hw = data->hw;\n\tmutex_init(&dev_data->lock);\n\n\tindio_dev->info = &ms5637_info;\n\tindio_dev->name = data->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ms5637_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ms5637_channels);\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tret = ms_sensors_reset(client, 0x1E, 3000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ms_sensors_tp_read_prom(dev_data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct ms_tp_hw_data ms5637_hw_data  = {\n\t.prom_len = 7,\n\t.max_res_index = 5\n};\n\nstatic const struct ms_tp_hw_data ms5803_hw_data  = {\n\t.prom_len = 8,\n\t.max_res_index = 4\n};\n\nstatic const struct ms_tp_data ms5637_data = { .name = \"ms5637\", .hw = &ms5637_hw_data };\n\nstatic const struct ms_tp_data ms5803_data = { .name = \"ms5803\", .hw = &ms5803_hw_data };\n\nstatic const struct ms_tp_data ms5805_data = { .name = \"ms5805\", .hw = &ms5637_hw_data };\n\nstatic const struct ms_tp_data ms5837_data = { .name = \"ms5837\", .hw = &ms5637_hw_data };\n\nstatic const struct ms_tp_data ms8607_data = {\n\t.name = \"ms8607-temppressure\",\n\t.hw = &ms5637_hw_data,\n};\n\nstatic const struct i2c_device_id ms5637_id[] = {\n\t{\"ms5637\", (kernel_ulong_t)&ms5637_data },\n\t{\"ms5805\", (kernel_ulong_t)&ms5805_data },\n\t{\"ms5837\", (kernel_ulong_t)&ms5837_data },\n\t{\"ms8607-temppressure\", (kernel_ulong_t)&ms8607_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ms5637_id);\n\nstatic const struct of_device_id ms5637_of_match[] = {\n\t{ .compatible = \"meas,ms5637\", .data = &ms5637_data },\n\t{ .compatible = \"meas,ms5803\", .data = &ms5803_data },\n\t{ .compatible = \"meas,ms5805\", .data = &ms5805_data },\n\t{ .compatible = \"meas,ms5837\", .data = &ms5837_data },\n\t{ .compatible = \"meas,ms8607-temppressure\", .data = &ms8607_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ms5637_of_match);\n\nstatic struct i2c_driver ms5637_driver = {\n\t.probe = ms5637_probe,\n\t.id_table = ms5637_id,\n\t.driver = {\n\t\t   .name = \"ms5637\",\n\t\t   .of_match_table = ms5637_of_match,\n\t\t   },\n};\n\nmodule_i2c_driver(ms5637_driver);\n\nMODULE_DESCRIPTION(\"Measurement-Specialties ms5637 temperature & pressure driver\");\nMODULE_AUTHOR(\"William Markezana <william.markezana@meas-spec.com>\");\nMODULE_AUTHOR(\"Ludovic Tancerel <ludovic.tancerel@maplehightech.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_MEAS_SPEC_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}