{
  "module_name": "industrialio-sw-device.c",
  "hash_id": "0bc0838dfc54e111a77fe00fad92fa33171e78cb88116f320bbf7c672412c060",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/industrialio-sw-device.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <linux/iio/sw_device.h>\n#include <linux/iio/configfs.h>\n#include <linux/configfs.h>\n\nstatic struct config_group *iio_devices_group;\nstatic const struct config_item_type iio_device_type_group_type;\n\nstatic const struct config_item_type iio_devices_group_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic LIST_HEAD(iio_device_types_list);\nstatic DEFINE_MUTEX(iio_device_types_lock);\n\nstatic\nstruct iio_sw_device_type *__iio_find_sw_device_type(const char *name,\n\t\t\t\t\t\t     unsigned int len)\n{\n\tstruct iio_sw_device_type *d = NULL, *iter;\n\n\tlist_for_each_entry(iter, &iio_device_types_list, list)\n\t\tif (!strcmp(iter->name, name)) {\n\t\t\td = iter;\n\t\t\tbreak;\n\t\t}\n\n\treturn d;\n}\n\nint iio_register_sw_device_type(struct iio_sw_device_type *d)\n{\n\tstruct iio_sw_device_type *iter;\n\tint ret = 0;\n\n\tmutex_lock(&iio_device_types_lock);\n\titer = __iio_find_sw_device_type(d->name, strlen(d->name));\n\tif (iter)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_add_tail(&d->list, &iio_device_types_list);\n\tmutex_unlock(&iio_device_types_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\td->group = configfs_register_default_group(iio_devices_group, d->name,\n\t\t\t\t\t\t&iio_device_type_group_type);\n\tif (IS_ERR(d->group))\n\t\tret = PTR_ERR(d->group);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iio_register_sw_device_type);\n\nvoid iio_unregister_sw_device_type(struct iio_sw_device_type *dt)\n{\n\tstruct iio_sw_device_type *iter;\n\n\tmutex_lock(&iio_device_types_lock);\n\titer = __iio_find_sw_device_type(dt->name, strlen(dt->name));\n\tif (iter)\n\t\tlist_del(&dt->list);\n\tmutex_unlock(&iio_device_types_lock);\n\n\tconfigfs_unregister_default_group(dt->group);\n}\nEXPORT_SYMBOL(iio_unregister_sw_device_type);\n\nstatic\nstruct iio_sw_device_type *iio_get_sw_device_type(const char *name)\n{\n\tstruct iio_sw_device_type *dt;\n\n\tmutex_lock(&iio_device_types_lock);\n\tdt = __iio_find_sw_device_type(name, strlen(name));\n\tif (dt && !try_module_get(dt->owner))\n\t\tdt = NULL;\n\tmutex_unlock(&iio_device_types_lock);\n\n\treturn dt;\n}\n\nstruct iio_sw_device *iio_sw_device_create(const char *type, const char *name)\n{\n\tstruct iio_sw_device *d;\n\tstruct iio_sw_device_type *dt;\n\n\tdt = iio_get_sw_device_type(type);\n\tif (!dt) {\n\t\tpr_err(\"Invalid device type: %s\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\td = dt->ops->probe(name);\n\tif (IS_ERR(d))\n\t\tgoto out_module_put;\n\n\td->device_type = dt;\n\n\treturn d;\nout_module_put:\n\tmodule_put(dt->owner);\n\treturn d;\n}\nEXPORT_SYMBOL(iio_sw_device_create);\n\nvoid iio_sw_device_destroy(struct iio_sw_device *d)\n{\n\tstruct iio_sw_device_type *dt = d->device_type;\n\n\tdt->ops->remove(d);\n\tmodule_put(dt->owner);\n}\nEXPORT_SYMBOL(iio_sw_device_destroy);\n\nstatic struct config_group *device_make_group(struct config_group *group,\n\t\t\t\t\t      const char *name)\n{\n\tstruct iio_sw_device *d;\n\n\td = iio_sw_device_create(group->cg_item.ci_name, name);\n\tif (IS_ERR(d))\n\t\treturn ERR_CAST(d);\n\n\tconfig_item_set_name(&d->group.cg_item, \"%s\", name);\n\n\treturn &d->group;\n}\n\nstatic void device_drop_group(struct config_group *group,\n\t\t\t      struct config_item *item)\n{\n\tstruct iio_sw_device *d = to_iio_sw_device(item);\n\n\tiio_sw_device_destroy(d);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations device_ops = {\n\t.make_group\t= &device_make_group,\n\t.drop_item\t= &device_drop_group,\n};\n\nstatic const struct config_item_type iio_device_type_group_type = {\n\t.ct_group_ops = &device_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic int __init iio_sw_device_init(void)\n{\n\tiio_devices_group =\n\t\tconfigfs_register_default_group(&iio_configfs_subsys.su_group,\n\t\t\t\t\t\t\"devices\",\n\t\t\t\t\t\t&iio_devices_group_type);\n\treturn PTR_ERR_OR_ZERO(iio_devices_group);\n}\nmodule_init(iio_sw_device_init);\n\nstatic void __exit iio_sw_device_exit(void)\n{\n\tconfigfs_unregister_default_group(iio_devices_group);\n}\nmodule_exit(iio_sw_device_exit);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Industrial I/O software devices support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}