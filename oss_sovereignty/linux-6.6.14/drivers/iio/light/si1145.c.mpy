{
  "module_name": "si1145.c",
  "hash_id": "adc296fc96cb882bb92521085ed0715e8ae35b6043b4077e1a12d02de0c7689f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/si1145.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/buffer.h>\n#include <linux/util_macros.h>\n\n#define SI1145_REG_PART_ID\t\t0x00\n#define SI1145_REG_REV_ID\t\t0x01\n#define SI1145_REG_SEQ_ID\t\t0x02\n#define SI1145_REG_INT_CFG\t\t0x03\n#define SI1145_REG_IRQ_ENABLE\t\t0x04\n#define SI1145_REG_IRQ_MODE\t\t0x05\n#define SI1145_REG_HW_KEY\t\t0x07\n#define SI1145_REG_MEAS_RATE\t\t0x08\n#define SI1145_REG_PS_LED21\t\t0x0f\n#define SI1145_REG_PS_LED3\t\t0x10\n#define SI1145_REG_UCOEF1\t\t0x13\n#define SI1145_REG_UCOEF2\t\t0x14\n#define SI1145_REG_UCOEF3\t\t0x15\n#define SI1145_REG_UCOEF4\t\t0x16\n#define SI1145_REG_PARAM_WR\t\t0x17\n#define SI1145_REG_COMMAND\t\t0x18\n#define SI1145_REG_RESPONSE\t\t0x20\n#define SI1145_REG_IRQ_STATUS\t\t0x21\n#define SI1145_REG_ALSVIS_DATA\t\t0x22\n#define SI1145_REG_ALSIR_DATA\t\t0x24\n#define SI1145_REG_PS1_DATA\t\t0x26\n#define SI1145_REG_PS2_DATA\t\t0x28\n#define SI1145_REG_PS3_DATA\t\t0x2a\n#define SI1145_REG_AUX_DATA\t\t0x2c\n#define SI1145_REG_PARAM_RD\t\t0x2e\n#define SI1145_REG_CHIP_STAT\t\t0x30\n\n#define SI1145_UCOEF1_DEFAULT\t\t0x7b\n#define SI1145_UCOEF2_DEFAULT\t\t0x6b\n#define SI1145_UCOEF3_DEFAULT\t\t0x01\n#define SI1145_UCOEF4_DEFAULT\t\t0x00\n\n \n#define SI1145_PS_LED_REG(ch) \\\n\t(((ch) == 2) ? SI1145_REG_PS_LED3 : SI1145_REG_PS_LED21)\n#define SI1145_PS_LED_SHIFT(ch) \\\n\t(((ch) == 1) ? 4 : 0)\n\n \n#define SI1145_PARAM_CHLIST\t\t0x01\n#define SI1145_PARAM_PSLED12_SELECT\t0x02\n#define SI1145_PARAM_PSLED3_SELECT\t0x03\n#define SI1145_PARAM_PS_ENCODING\t0x05\n#define SI1145_PARAM_ALS_ENCODING\t0x06\n#define SI1145_PARAM_PS1_ADC_MUX\t0x07\n#define SI1145_PARAM_PS2_ADC_MUX\t0x08\n#define SI1145_PARAM_PS3_ADC_MUX\t0x09\n#define SI1145_PARAM_PS_ADC_COUNTER\t0x0a\n#define SI1145_PARAM_PS_ADC_GAIN\t0x0b\n#define SI1145_PARAM_PS_ADC_MISC\t0x0c\n#define SI1145_PARAM_ALS_ADC_MUX\t0x0d\n#define SI1145_PARAM_ALSIR_ADC_MUX\t0x0e\n#define SI1145_PARAM_AUX_ADC_MUX\t0x0f\n#define SI1145_PARAM_ALSVIS_ADC_COUNTER\t0x10\n#define SI1145_PARAM_ALSVIS_ADC_GAIN\t0x11\n#define SI1145_PARAM_ALSVIS_ADC_MISC\t0x12\n#define SI1145_PARAM_LED_RECOVERY\t0x1c\n#define SI1145_PARAM_ALSIR_ADC_COUNTER\t0x1d\n#define SI1145_PARAM_ALSIR_ADC_GAIN\t0x1e\n#define SI1145_PARAM_ALSIR_ADC_MISC\t0x1f\n#define SI1145_PARAM_ADC_OFFSET\t\t0x1a\n\n \n#define SI1145_CHLIST_EN_PS1\t\tBIT(0)\n#define SI1145_CHLIST_EN_PS2\t\tBIT(1)\n#define SI1145_CHLIST_EN_PS3\t\tBIT(2)\n#define SI1145_CHLIST_EN_ALSVIS\t\tBIT(4)\n#define SI1145_CHLIST_EN_ALSIR\t\tBIT(5)\n#define SI1145_CHLIST_EN_AUX\t\tBIT(6)\n#define SI1145_CHLIST_EN_UV\t\tBIT(7)\n\n \n#define SI1145_PS_ADC_MODE_NORMAL\tBIT(2)\n \n#define SI1145_ADC_MISC_RANGE\t\tBIT(5)\n\n \n#define SI1145_CMD_NOP\t\t\t0x00\n#define SI1145_CMD_RESET\t\t0x01\n#define SI1145_CMD_PS_FORCE\t\t0x05\n#define SI1145_CMD_ALS_FORCE\t\t0x06\n#define SI1145_CMD_PSALS_FORCE\t\t0x07\n#define SI1145_CMD_PS_PAUSE\t\t0x09\n#define SI1145_CMD_ALS_PAUSE\t\t0x0a\n#define SI1145_CMD_PSALS_PAUSE\t\t0x0b\n#define SI1145_CMD_PS_AUTO\t\t0x0d\n#define SI1145_CMD_ALS_AUTO\t\t0x0e\n#define SI1145_CMD_PSALS_AUTO\t\t0x0f\n#define SI1145_CMD_PARAM_QUERY\t\t0x80\n#define SI1145_CMD_PARAM_SET\t\t0xa0\n\n#define SI1145_RSP_INVALID_SETTING\t0x80\n#define SI1145_RSP_COUNTER_MASK\t\t0x0F\n\n \n#define SI1145_COMMAND_MINSLEEP_MS\t5\n \n#define SI1145_COMMAND_TIMEOUT_MS\t25\n\n \n#define SI1145_INT_CFG_OE\t\tBIT(0)  \n#define SI1145_INT_CFG_MODE\t\tBIT(1)  \n\n \n#define SI1145_MASK_ALL_IE\t\t(BIT(4) | BIT(3) | BIT(2) | BIT(0))\n\n#define SI1145_MUX_TEMP\t\t\t0x65\n#define SI1145_MUX_VDD\t\t\t0x75\n\n \n#define SI1145_LED_CURRENT_45mA\t\t0x04\n\nenum {\n\tSI1132,\n\tSI1141,\n\tSI1142,\n\tSI1143,\n\tSI1145,\n\tSI1146,\n\tSI1147,\n};\n\nstruct si1145_part_info {\n\tu8 part;\n\tconst struct iio_info *iio_info;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tunsigned int num_leds;\n\tbool uncompressed_meas_rate;\n};\n\n \nstruct si1145_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tstruct mutex cmdlock;\n\tint rsp_seq;\n\tconst struct si1145_part_info *part_info;\n\tunsigned long scan_mask;\n\tbool autonomous;\n\tstruct iio_trigger *trig;\n\tint meas_rate;\n\t \n\tu8 buffer[24] __aligned(8);\n};\n\n \nstatic int __si1145_command_reset(struct si1145_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tunsigned long stop_jiffies;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, SI1145_REG_COMMAND,\n\t\t\t\t\t\t      SI1145_CMD_NOP);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(SI1145_COMMAND_MINSLEEP_MS);\n\n\tstop_jiffies = jiffies + SI1145_COMMAND_TIMEOUT_MS * HZ / 1000;\n\twhile (true) {\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       SI1145_REG_RESPONSE);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tif (time_after(jiffies, stop_jiffies)) {\n\t\t\tdev_warn(dev, \"timeout on reset\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(SI1145_COMMAND_MINSLEEP_MS);\n\t}\n}\n\n \nstatic int si1145_command(struct si1145_data *data, u8 cmd)\n{\n\tstruct device *dev = &data->client->dev;\n\tunsigned long stop_jiffies;\n\tint ret;\n\n\tmutex_lock(&data->cmdlock);\n\n\tif (data->rsp_seq < 0) {\n\t\tret = __si1145_command_reset(data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to reset command counter, ret=%d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tdata->rsp_seq = 0;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, SI1145_REG_COMMAND, cmd);\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to write command, ret=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\t \n\tmsleep(SI1145_COMMAND_MINSLEEP_MS);\n\n\tstop_jiffies = jiffies + SI1145_COMMAND_TIMEOUT_MS * HZ / 1000;\n\twhile (true) {\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       SI1145_REG_RESPONSE);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(dev, \"failed to read response, ret=%d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((ret & ~SI1145_RSP_COUNTER_MASK) == 0) {\n\t\t\tif (ret == data->rsp_seq) {\n\t\t\t\tif (time_after(jiffies, stop_jiffies)) {\n\t\t\t\t\tdev_warn(dev, \"timeout on command 0x%02x\\n\",\n\t\t\t\t\t\t cmd);\n\t\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmsleep(SI1145_COMMAND_MINSLEEP_MS);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret == ((data->rsp_seq + 1) &\n\t\t\t\tSI1145_RSP_COUNTER_MASK)) {\n\t\t\t\tdata->rsp_seq = ret;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_warn(dev, \"unexpected response counter %d instead of %d\\n\",\n\t\t\t\t ret, (data->rsp_seq + 1) &\n\t\t\t\t\tSI1145_RSP_COUNTER_MASK);\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tif (ret == SI1145_RSP_INVALID_SETTING) {\n\t\t\t\tdev_warn(dev, \"INVALID_SETTING error on command 0x%02x\\n\",\n\t\t\t\t\t cmd);\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev_dbg(dev, \"overflow, ret=%d, cmd=0x%02x\\n\",\n\t\t\t\t\tret, cmd);\n\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdata->rsp_seq = -1;\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&data->cmdlock);\n\n\treturn ret;\n}\n\nstatic int si1145_param_update(struct si1145_data *data, u8 op, u8 param,\n\t\t\t       u8 value)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\tSI1145_REG_PARAM_WR, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn si1145_command(data, op | (param & 0x1F));\n}\n\nstatic int si1145_param_set(struct si1145_data *data, u8 param, u8 value)\n{\n\treturn si1145_param_update(data, SI1145_CMD_PARAM_SET, param, value);\n}\n\n \nstatic int si1145_param_query(struct si1145_data *data, u8 param)\n{\n\tint ret;\n\n\tret = si1145_command(data, SI1145_CMD_PARAM_QUERY | (param & 0x1F));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_read_byte_data(data->client, SI1145_REG_PARAM_RD);\n}\n\n \nstatic u16 si1145_uncompress(u8 x)\n{\n\tu16 result = 0;\n\tu8 exponent = 0;\n\n\tif (x < 8)\n\t\treturn 0;\n\n\texponent = (x & 0xf0) >> 4;\n\tresult = 0x10 | (x & 0x0f);\n\n\tif (exponent >= 4)\n\t\treturn result << (exponent - 4);\n\treturn result >> (4 - exponent);\n}\n\n \nstatic u8 si1145_compress(u16 x)\n{\n\tu32 exponent = 0;\n\tu32 significand = 0;\n\tu32 tmp = x;\n\n\tif (x == 0x0000)\n\t\treturn 0x00;\n\tif (x == 0x0001)\n\t\treturn 0x08;\n\n\twhile (1) {\n\t\ttmp >>= 1;\n\t\texponent += 1;\n\t\tif (tmp == 1)\n\t\t\tbreak;\n\t}\n\n\tif (exponent < 5) {\n\t\tsignificand = x << (4 - exponent);\n\t\treturn (exponent << 4) | (significand & 0xF);\n\t}\n\n\tsignificand = x >> (exponent - 5);\n\tif (significand & 1) {\n\t\tsignificand += 2;\n\t\tif (significand & 0x0040) {\n\t\t\texponent += 1;\n\t\t\tsignificand >>= 1;\n\t\t}\n\t}\n\n\treturn (exponent << 4) | ((significand >> 1) & 0xF);\n}\n\n \nstatic int si1145_set_meas_rate(struct si1145_data *data, int interval)\n{\n\tif (data->part_info->uncompressed_meas_rate)\n\t\treturn i2c_smbus_write_word_data(data->client,\n\t\t\tSI1145_REG_MEAS_RATE, interval);\n\telse\n\t\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\tSI1145_REG_MEAS_RATE, interval);\n}\n\nstatic int si1145_read_samp_freq(struct si1145_data *data, int *val, int *val2)\n{\n\t*val = 32000;\n\tif (data->part_info->uncompressed_meas_rate)\n\t\t*val2 = data->meas_rate;\n\telse\n\t\t*val2 = si1145_uncompress(data->meas_rate);\n\treturn IIO_VAL_FRACTIONAL;\n}\n\n \nstatic int si1145_store_samp_freq(struct si1145_data *data, int val)\n{\n\tint ret = 0;\n\tint meas_rate;\n\n\tif (val <= 0 || val > 32000)\n\t\treturn -ERANGE;\n\tmeas_rate = 32000 / val;\n\n\tmutex_lock(&data->lock);\n\tif (data->autonomous) {\n\t\tret = si1145_set_meas_rate(data, meas_rate);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (data->part_info->uncompressed_meas_rate)\n\t\tdata->meas_rate = meas_rate;\n\telse\n\t\tdata->meas_rate = si1145_compress(meas_rate);\n\nout:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t si1145_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tint i, j = 0;\n\tint ret;\n\tu8 irq_status = 0;\n\n\tif (!data->autonomous) {\n\t\tret = si1145_command(data, SI1145_CMD_PSALS_FORCE);\n\t\tif (ret < 0 && ret != -EOVERFLOW)\n\t\t\tgoto done;\n\t} else {\n\t\tirq_status = ret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\tSI1145_REG_IRQ_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (!(irq_status & SI1145_MASK_ALL_IE))\n\t\t\tgoto done;\n\t}\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tint run = 1;\n\n\t\twhile (i + run < indio_dev->masklength) {\n\t\t\tif (!test_bit(i + run, indio_dev->active_scan_mask))\n\t\t\t\tbreak;\n\t\t\tif (indio_dev->channels[i + run].address !=\n\t\t\t\tindio_dev->channels[i].address + 2 * run)\n\t\t\t\tbreak;\n\t\t\trun++;\n\t\t}\n\n\t\tret = i2c_smbus_read_i2c_block_data_or_emulated(\n\t\t\t\tdata->client, indio_dev->channels[i].address,\n\t\t\t\tsizeof(u16) * run, &data->buffer[j]);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tj += run * sizeof(u16);\n\t\ti += run - 1;\n\t}\n\n\tif (data->autonomous) {\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_IRQ_STATUS,\n\t\t\t\tirq_status & SI1145_MASK_ALL_IE);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int si1145_set_chlist(struct iio_dev *indio_dev, unsigned long scan_mask)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tu8 reg = 0, mux;\n\tint ret;\n\tint i;\n\n\t \n\tif (data->scan_mask == scan_mask)\n\t\treturn 0;\n\n\tfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\n\t\tswitch (indio_dev->channels[i].address) {\n\t\tcase SI1145_REG_ALSVIS_DATA:\n\t\t\treg |= SI1145_CHLIST_EN_ALSVIS;\n\t\t\tbreak;\n\t\tcase SI1145_REG_ALSIR_DATA:\n\t\t\treg |= SI1145_CHLIST_EN_ALSIR;\n\t\t\tbreak;\n\t\tcase SI1145_REG_PS1_DATA:\n\t\t\treg |= SI1145_CHLIST_EN_PS1;\n\t\t\tbreak;\n\t\tcase SI1145_REG_PS2_DATA:\n\t\t\treg |= SI1145_CHLIST_EN_PS2;\n\t\t\tbreak;\n\t\tcase SI1145_REG_PS3_DATA:\n\t\t\treg |= SI1145_CHLIST_EN_PS3;\n\t\t\tbreak;\n\t\tcase SI1145_REG_AUX_DATA:\n\t\t\tswitch (indio_dev->channels[i].type) {\n\t\t\tcase IIO_UVINDEX:\n\t\t\t\treg |= SI1145_CHLIST_EN_UV;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treg |= SI1145_CHLIST_EN_AUX;\n\t\t\t\tif (indio_dev->channels[i].type == IIO_TEMP)\n\t\t\t\t\tmux = SI1145_MUX_TEMP;\n\t\t\t\telse\n\t\t\t\t\tmux = SI1145_MUX_VDD;\n\t\t\t\tret = si1145_param_set(data,\n\t\t\t\t\tSI1145_PARAM_AUX_ADC_MUX, mux);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdata->scan_mask = scan_mask;\n\tret = si1145_param_set(data, SI1145_PARAM_CHLIST, reg);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int si1145_measure(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tu8 cmd;\n\tint ret;\n\n\tret = si1145_set_chlist(indio_dev, BIT(chan->scan_index));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcmd = (chan->type == IIO_PROXIMITY) ? SI1145_CMD_PS_FORCE :\n\t\tSI1145_CMD_ALS_FORCE;\n\tret = si1145_command(data, cmd);\n\tif (ret < 0 && ret != -EOVERFLOW)\n\t\treturn ret;\n\n\treturn i2c_smbus_read_word_data(data->client, chan->address);\n}\n\n \nstatic const int si1145_proximity_scale_available[] = {\n\t128, 64, 32, 16, 8, 4};\nstatic const int si1145_intensity_scale_available[] = {\n\t128, 64, 32, 16, 8, 4, 2, 1};\nstatic IIO_CONST_ATTR(in_proximity_scale_available,\n\t\"128 64 32 16 8 4\");\nstatic IIO_CONST_ATTR(in_intensity_scale_available,\n\t\"128 64 32 16 8 4 2 1\");\nstatic IIO_CONST_ATTR(in_intensity_ir_scale_available,\n\t\"128 64 32 16 8 4 2 1\");\n\nstatic int si1145_scale_from_adcgain(int regval)\n{\n\treturn 128 >> regval;\n}\n\nstatic int si1145_proximity_adcgain_from_scale(int val, int val2)\n{\n\tval = find_closest_descending(val, si1145_proximity_scale_available,\n\t\t\t\tARRAY_SIZE(si1145_proximity_scale_available));\n\tif (val < 0 || val > 5 || val2 != 0)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\n\nstatic int si1145_intensity_adcgain_from_scale(int val, int val2)\n{\n\tval = find_closest_descending(val, si1145_intensity_scale_available,\n\t\t\t\tARRAY_SIZE(si1145_intensity_scale_available));\n\tif (val < 0 || val > 7 || val2 != 0)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\n\nstatic int si1145_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 reg;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_PROXIMITY:\n\t\tcase IIO_VOLTAGE:\n\t\tcase IIO_TEMP:\n\t\tcase IIO_UVINDEX:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = si1145_measure(indio_dev, chan);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val = ret;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CURRENT:\n\t\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\tSI1145_PS_LED_REG(chan->channel));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val = (ret >> SI1145_PS_LED_SHIFT(chan->channel))\n\t\t\t\t& 0x0f;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\treg = SI1145_PARAM_PS_ADC_GAIN;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tif (chan->channel2 == IIO_MOD_LIGHT_IR)\n\t\t\t\treg = SI1145_PARAM_ALSIR_ADC_GAIN;\n\t\t\telse\n\t\t\t\treg = SI1145_PARAM_ALSVIS_ADC_GAIN;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 28;\n\t\t\t*val2 = 571429;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_UVINDEX:\n\t\t\t*val = 0;\n\t\t\t*val2 = 10000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = si1145_param_query(data, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = si1145_scale_from_adcgain(ret & 0x07);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = -256 - 11136 + 25 * 35;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\t \n\t\t\tret = si1145_param_query(data, SI1145_PARAM_ADC_OFFSET);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = -si1145_uncompress(ret);\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn si1145_read_samp_freq(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si1145_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tu8 reg1, reg2, shift;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tval = si1145_proximity_adcgain_from_scale(val, val2);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t\treg1 = SI1145_PARAM_PS_ADC_GAIN;\n\t\t\treg2 = SI1145_PARAM_PS_ADC_COUNTER;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tval = si1145_intensity_adcgain_from_scale(val, val2);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\t\t\tif (chan->channel2 == IIO_MOD_LIGHT_IR) {\n\t\t\t\treg1 = SI1145_PARAM_ALSIR_ADC_GAIN;\n\t\t\t\treg2 = SI1145_PARAM_ALSIR_ADC_COUNTER;\n\t\t\t} else {\n\t\t\t\treg1 = SI1145_PARAM_ALSVIS_ADC_GAIN;\n\t\t\t\treg2 = SI1145_PARAM_ALSVIS_ADC_COUNTER;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = si1145_param_set(data, reg1, val);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = si1145_param_set(data, reg2, (~val & 0x07) << 4);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_CURRENT)\n\t\t\treturn -EINVAL;\n\n\t\tif (val < 0 || val > 15 || val2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\treg1 = SI1145_PS_LED_REG(chan->channel);\n\t\tshift = SI1145_PS_LED_SHIFT(chan->channel);\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = i2c_smbus_read_byte_data(data->client, reg1);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\tret = i2c_smbus_write_byte_data(data->client, reg1,\n\t\t\t(ret & ~(0x0f << shift)) |\n\t\t\t((val & 0x0f) << shift));\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn si1145_store_samp_freq(data, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define SI1145_ST { \\\n\t.sign = 'u', \\\n\t.realbits = 16, \\\n\t.storagebits = 16, \\\n\t.endianness = IIO_LE, \\\n}\n\n#define SI1145_INTENSITY_CHANNEL(_si) { \\\n\t.type = IIO_INTENSITY, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_ALSVIS_DATA, \\\n}\n\n#define SI1145_INTENSITY_IR_CHANNEL(_si) { \\\n\t.type = IIO_INTENSITY, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_LIGHT_IR, \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_ALSIR_DATA, \\\n}\n\n#define SI1145_TEMP_CHANNEL(_si) { \\\n\t.type = IIO_TEMP, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_AUX_DATA, \\\n}\n\n#define SI1145_UV_CHANNEL(_si) { \\\n\t.type = IIO_UVINDEX, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_AUX_DATA, \\\n}\n\n#define SI1145_PROXIMITY_CHANNEL(_si, _ch) { \\\n\t.type = IIO_PROXIMITY, \\\n\t.indexed = 1, \\\n\t.channel = _ch, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\t    BIT(IIO_CHAN_INFO_OFFSET), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_PS1_DATA + _ch * 2, \\\n}\n\n#define SI1145_VOLTAGE_CHANNEL(_si) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_type = SI1145_ST, \\\n\t.scan_index = _si, \\\n\t.address = SI1145_REG_AUX_DATA, \\\n}\n\n#define SI1145_CURRENT_CHANNEL(_ch) { \\\n\t.type = IIO_CURRENT, \\\n\t.indexed = 1, \\\n\t.channel = _ch, \\\n\t.output = 1, \\\n\t.scan_index = -1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n}\n\nstatic const struct iio_chan_spec si1132_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_TEMP_CHANNEL(2),\n\tSI1145_VOLTAGE_CHANNEL(3),\n\tSI1145_UV_CHANNEL(4),\n\tIIO_CHAN_SOFT_TIMESTAMP(6),\n};\n\nstatic const struct iio_chan_spec si1141_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_PROXIMITY_CHANNEL(2, 0),\n\tSI1145_TEMP_CHANNEL(3),\n\tSI1145_VOLTAGE_CHANNEL(4),\n\tIIO_CHAN_SOFT_TIMESTAMP(5),\n\tSI1145_CURRENT_CHANNEL(0),\n};\n\nstatic const struct iio_chan_spec si1142_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_PROXIMITY_CHANNEL(2, 0),\n\tSI1145_PROXIMITY_CHANNEL(3, 1),\n\tSI1145_TEMP_CHANNEL(4),\n\tSI1145_VOLTAGE_CHANNEL(5),\n\tIIO_CHAN_SOFT_TIMESTAMP(6),\n\tSI1145_CURRENT_CHANNEL(0),\n\tSI1145_CURRENT_CHANNEL(1),\n};\n\nstatic const struct iio_chan_spec si1143_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_PROXIMITY_CHANNEL(2, 0),\n\tSI1145_PROXIMITY_CHANNEL(3, 1),\n\tSI1145_PROXIMITY_CHANNEL(4, 2),\n\tSI1145_TEMP_CHANNEL(5),\n\tSI1145_VOLTAGE_CHANNEL(6),\n\tIIO_CHAN_SOFT_TIMESTAMP(7),\n\tSI1145_CURRENT_CHANNEL(0),\n\tSI1145_CURRENT_CHANNEL(1),\n\tSI1145_CURRENT_CHANNEL(2),\n};\n\nstatic const struct iio_chan_spec si1145_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_PROXIMITY_CHANNEL(2, 0),\n\tSI1145_TEMP_CHANNEL(3),\n\tSI1145_VOLTAGE_CHANNEL(4),\n\tSI1145_UV_CHANNEL(5),\n\tIIO_CHAN_SOFT_TIMESTAMP(6),\n\tSI1145_CURRENT_CHANNEL(0),\n};\n\nstatic const struct iio_chan_spec si1146_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_TEMP_CHANNEL(2),\n\tSI1145_VOLTAGE_CHANNEL(3),\n\tSI1145_UV_CHANNEL(4),\n\tSI1145_PROXIMITY_CHANNEL(5, 0),\n\tSI1145_PROXIMITY_CHANNEL(6, 1),\n\tIIO_CHAN_SOFT_TIMESTAMP(7),\n\tSI1145_CURRENT_CHANNEL(0),\n\tSI1145_CURRENT_CHANNEL(1),\n};\n\nstatic const struct iio_chan_spec si1147_channels[] = {\n\tSI1145_INTENSITY_CHANNEL(0),\n\tSI1145_INTENSITY_IR_CHANNEL(1),\n\tSI1145_PROXIMITY_CHANNEL(2, 0),\n\tSI1145_PROXIMITY_CHANNEL(3, 1),\n\tSI1145_PROXIMITY_CHANNEL(4, 2),\n\tSI1145_TEMP_CHANNEL(5),\n\tSI1145_VOLTAGE_CHANNEL(6),\n\tSI1145_UV_CHANNEL(7),\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n\tSI1145_CURRENT_CHANNEL(0),\n\tSI1145_CURRENT_CHANNEL(1),\n\tSI1145_CURRENT_CHANNEL(2),\n};\n\nstatic struct attribute *si1132_attributes[] = {\n\t&iio_const_attr_in_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_intensity_ir_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute *si114x_attributes[] = {\n\t&iio_const_attr_in_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_intensity_ir_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_proximity_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group si1132_attribute_group = {\n\t.attrs = si1132_attributes,\n};\n\nstatic const struct attribute_group si114x_attribute_group = {\n\t.attrs = si114x_attributes,\n};\n\n\nstatic const struct iio_info si1132_info = {\n\t.read_raw = si1145_read_raw,\n\t.write_raw = si1145_write_raw,\n\t.attrs = &si1132_attribute_group,\n};\n\nstatic const struct iio_info si114x_info = {\n\t.read_raw = si1145_read_raw,\n\t.write_raw = si1145_write_raw,\n\t.attrs = &si114x_attribute_group,\n};\n\n#define SI1145_PART(id, iio_info, chans, leds, uncompressed_meas_rate) \\\n\t{id, iio_info, chans, ARRAY_SIZE(chans), leds, uncompressed_meas_rate}\n\nstatic const struct si1145_part_info si1145_part_info[] = {\n\t[SI1132] = SI1145_PART(0x32, &si1132_info, si1132_channels, 0, true),\n\t[SI1141] = SI1145_PART(0x41, &si114x_info, si1141_channels, 1, false),\n\t[SI1142] = SI1145_PART(0x42, &si114x_info, si1142_channels, 2, false),\n\t[SI1143] = SI1145_PART(0x43, &si114x_info, si1143_channels, 3, false),\n\t[SI1145] = SI1145_PART(0x45, &si114x_info, si1145_channels, 1, true),\n\t[SI1146] = SI1145_PART(0x46, &si114x_info, si1146_channels, 2, true),\n\t[SI1147] = SI1145_PART(0x47, &si114x_info, si1147_channels, 3, true),\n};\n\nstatic int si1145_initialize(struct si1145_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, SI1145_REG_COMMAND,\n\t\t\t\t\tSI1145_CMD_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(SI1145_COMMAND_TIMEOUT_MS);\n\n\t \n\tret = i2c_smbus_write_byte_data(client, SI1145_REG_HW_KEY, 0x17);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(SI1145_COMMAND_TIMEOUT_MS);\n\n\t \n\tret = si1145_set_meas_rate(data, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si1145_store_samp_freq(data, 10);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (data->part_info->num_leds) {\n\tcase 3:\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tSI1145_REG_PS_LED3,\n\t\t\t\t\t\tSI1145_LED_CURRENT_45mA);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tcase 2:\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tSI1145_REG_PS_LED21,\n\t\t\t\t\t\t(SI1145_LED_CURRENT_45mA << 4) |\n\t\t\t\t\t\tSI1145_LED_CURRENT_45mA);\n\t\tbreak;\n\tcase 1:\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tSI1145_REG_PS_LED21,\n\t\t\t\t\t\tSI1145_LED_CURRENT_45mA);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si1145_param_set(data, SI1145_PARAM_PS_ADC_MISC,\n\t\t\t       SI1145_PS_ADC_MODE_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si1145_param_set(data, SI1145_PARAM_PS_ADC_GAIN, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si1145_param_set(data, SI1145_PARAM_PS_ADC_COUNTER, 0x06 << 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_MISC,\n\t\t\t       SI1145_ADC_MISC_RANGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_GAIN, 0x03);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_COUNTER,\n\t\t\t       0x04 << 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_MISC,\n\t\t\t       SI1145_ADC_MISC_RANGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_GAIN, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_COUNTER,\n\t\t\t       0x06 << 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (data->part_info == &si1145_part_info[SI1132] ||\n\t\tdata->part_info == &si1145_part_info[SI1145] ||\n\t\tdata->part_info == &si1145_part_info[SI1146] ||\n\t\tdata->part_info == &si1145_part_info[SI1147]) {\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tSI1145_REG_UCOEF1,\n\t\t\t\t\t\tSI1145_UCOEF1_DEFAULT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_UCOEF2, SI1145_UCOEF2_DEFAULT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_UCOEF3, SI1145_UCOEF3_DEFAULT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_UCOEF4, SI1145_UCOEF4_DEFAULT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int si1145_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = si1145_set_chlist(indio_dev, *indio_dev->active_scan_mask);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic bool si1145_validate_scan_mask(struct iio_dev *indio_dev,\n\t\t\t       const unsigned long *scan_mask)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tunsigned int count = 0;\n\tint i;\n\n\t \n\tfor_each_set_bit(i, scan_mask, data->part_info->num_channels) {\n\t\tif (indio_dev->channels[i].address == SI1145_REG_AUX_DATA)\n\t\t\tcount++;\n\t}\n\n\treturn count <= 1;\n}\n\nstatic const struct iio_buffer_setup_ops si1145_buffer_setup_ops = {\n\t.preenable = si1145_buffer_preenable,\n\t.validate_scan_mask = si1145_validate_scan_mask,\n};\n\n \nstatic int si1145_trigger_set_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tint err = 0, ret;\n\n\tmutex_lock(&data->lock);\n\n\tif (state) {\n\t\tdata->autonomous = true;\n\t\terr = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_INT_CFG, SI1145_INT_CFG_OE);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t\terr = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSI1145_REG_IRQ_ENABLE, SI1145_MASK_ALL_IE);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t\terr = si1145_set_meas_rate(data, data->meas_rate);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t\terr = si1145_command(data, SI1145_CMD_PSALS_AUTO);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t} else {\ndisable:\n\t\t \n\t\tret = si1145_command(data, SI1145_CMD_PSALS_PAUSE);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t\tret = si1145_set_meas_rate(data, 0);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tSI1145_REG_IRQ_ENABLE, 0);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tSI1145_REG_INT_CFG, 0);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t\tdata->autonomous = false;\n\t}\n\n\tmutex_unlock(&data->lock);\n\treturn err;\n}\n\nstatic const struct iio_trigger_ops si1145_trigger_ops = {\n\t.set_trigger_state = si1145_trigger_set_state,\n};\n\nstatic int si1145_probe_trigger(struct iio_dev *indio_dev)\n{\n\tstruct si1145_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\"%s-dev%d\", indio_dev->name, iio_device_id(indio_dev));\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\ttrig->ops = &si1145_trigger_ops;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\tret = devm_request_irq(&client->dev, client->irq,\n\t\t\t  iio_trigger_generic_data_rdy_poll,\n\t\t\t  IRQF_TRIGGER_FALLING,\n\t\t\t  \"si1145_irq\",\n\t\t\t  trig);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"irq request failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_trigger_register(&client->dev, trig);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->trig = trig;\n\tindio_dev->trig = iio_trigger_get(data->trig);\n\n\treturn 0;\n}\n\nstatic int si1145_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct si1145_data *data;\n\tstruct iio_dev *indio_dev;\n\tu8 part_id, rev_id, seq_id;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->part_info = &si1145_part_info[id->driver_data];\n\n\tpart_id = ret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t SI1145_REG_PART_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\trev_id = ret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\tSI1145_REG_REV_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tseq_id = ret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\tSI1145_REG_SEQ_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_info(&client->dev, \"device ID part 0x%02x rev 0x%02x seq 0x%02x\\n\",\n\t\t\tpart_id, rev_id, seq_id);\n\tif (part_id != data->part_info->part) {\n\t\tdev_err(&client->dev, \"part ID mismatch got 0x%02x, expected 0x%02x\\n\",\n\t\t\t\tpart_id, data->part_info->part);\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev->name = id->name;\n\tindio_dev->channels = data->part_info->channels;\n\tindio_dev->num_channels = data->part_info->num_channels;\n\tindio_dev->info = data->part_info->iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tmutex_init(&data->lock);\n\tmutex_init(&data->cmdlock);\n\n\tret = si1145_initialize(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev,\n\t\tindio_dev, NULL,\n\t\tsi1145_trigger_handler, &si1145_buffer_setup_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = si1145_probe_trigger(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_info(&client->dev, \"no irq, using polling\\n\");\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id si1145_ids[] = {\n\t{ \"si1132\", SI1132 },\n\t{ \"si1141\", SI1141 },\n\t{ \"si1142\", SI1142 },\n\t{ \"si1143\", SI1143 },\n\t{ \"si1145\", SI1145 },\n\t{ \"si1146\", SI1146 },\n\t{ \"si1147\", SI1147 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si1145_ids);\n\nstatic struct i2c_driver si1145_driver = {\n\t.driver = {\n\t\t.name   = \"si1145\",\n\t},\n\t.probe = si1145_probe,\n\t.id_table = si1145_ids,\n};\n\nmodule_i2c_driver(si1145_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald-Stadler <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Silabs SI1132 and SI1141/2/3/5/6/7 proximity, ambient light and UV index sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}