{
  "module_name": "acpi-als.c",
  "hash_id": "4b7f8c37cdbb91fb6612a27c81a6c6682215370f8a344d8335de5341c9d2eeef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/acpi-als.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/mutex.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define ACPI_ALS_CLASS\t\t\t\"als\"\n#define ACPI_ALS_DEVICE_NAME\t\t\"acpi-als\"\n#define ACPI_ALS_NOTIFY_ILLUMINANCE\t0x80\n\n \nstatic const struct iio_chan_spec acpi_als_channels[] = {\n\t{\n\t\t.type\t\t= IIO_LIGHT,\n\t\t.scan_type\t= {\n\t\t\t.sign\t\t= 's',\n\t\t\t.realbits\t= 32,\n\t\t\t.storagebits\t= 32,\n\t\t},\n\t\t \n\t\t.info_mask_separate\t= BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t  BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\n \n#define ACPI_ALS_EVT_BUFFER_SIZE\t\t\\\n\t(sizeof(s32) + sizeof(s32) + sizeof(s64))\n\nstruct acpi_als {\n\tstruct acpi_device\t*device;\n\tstruct mutex\t\tlock;\n\tstruct iio_trigger\t*trig;\n\n\ts32 evt_buffer[ACPI_ALS_EVT_BUFFER_SIZE / sizeof(s32)]  __aligned(8);\n};\n\n \n#define ACPI_ALS_ILLUMINANCE\t\"_ALI\"\n#define ACPI_ALS_CHROMATICITY\t\"_ALC\"\n#define ACPI_ALS_COLOR_TEMP\t\"_ALT\"\n#define ACPI_ALS_POLLING\t\"_ALP\"\n#define ACPI_ALS_TABLES\t\t\"_ALR\"\n\nstatic int acpi_als_read_value(struct acpi_als *als, char *prop, s32 *val)\n{\n\tunsigned long long temp_val;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(als->device->handle, prop, NULL,\n\t\t\t\t       &temp_val);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(als->device->handle, prop, status);\n\t\treturn -EIO;\n\t}\n\n\t*val = temp_val;\n\n\treturn 0;\n}\n\nstatic void acpi_als_notify(struct acpi_device *device, u32 event)\n{\n\tstruct iio_dev *indio_dev = acpi_driver_data(device);\n\tstruct acpi_als *als = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev) && iio_trigger_using_own(indio_dev)) {\n\t\tswitch (event) {\n\t\tcase ACPI_ALS_NOTIFY_ILLUMINANCE:\n\t\t\tiio_trigger_poll_nested(als->trig);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_dbg(&device->dev,\n\t\t\t\t\"Unhandled ACPI ALS event (%08x)!\\n\",\n\t\t\t\tevent);\n\t\t}\n\t}\n}\n\nstatic int acpi_als_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct acpi_als *als = iio_priv(indio_dev);\n\ts32 temp_val;\n\tint ret;\n\n\tif ((mask != IIO_CHAN_INFO_PROCESSED) && (mask != IIO_CHAN_INFO_RAW))\n\t\treturn -EINVAL;\n\n\t \n\tif (chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tret = acpi_als_read_value(als, ACPI_ALS_ILLUMINANCE, &temp_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = temp_val;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info acpi_als_info = {\n\t.read_raw\t\t= acpi_als_read_raw,\n};\n\nstatic irqreturn_t acpi_als_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct acpi_als *als = iio_priv(indio_dev);\n\ts32 *buffer = als->evt_buffer;\n\ts32 val;\n\tint ret;\n\n\tmutex_lock(&als->lock);\n\n\tret = acpi_als_read_value(als, ACPI_ALS_ILLUMINANCE, &val);\n\tif (ret < 0)\n\t\tgoto out;\n\t*buffer = val;\n\n\t \n\tif (!pf->timestamp)\n\t\tpf->timestamp = iio_get_time_ns(indio_dev);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, buffer, pf->timestamp);\nout:\n\tmutex_unlock(&als->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int acpi_als_add(struct acpi_device *device)\n{\n\tstruct device *dev = &device->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct acpi_als *als;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*als));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tals = iio_priv(indio_dev);\n\n\tdevice->driver_data = indio_dev;\n\tals->device = device;\n\tmutex_init(&als->lock);\n\n\tindio_dev->name = ACPI_ALS_DEVICE_NAME;\n\tindio_dev->info = &acpi_als_info;\n\tindio_dev->channels = acpi_als_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(acpi_als_channels);\n\n\tals->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\", indio_dev->name,\n\t\t\t\t\t   iio_device_id(indio_dev));\n\tif (!als->trig)\n\t\treturn -ENOMEM;\n\n\tret = devm_iio_trigger_register(dev, als->trig);\n\tif (ret)\n\t\treturn ret;\n\t \n\tindio_dev->trig = iio_trigger_get(als->trig);\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      acpi_als_trigger_handler,\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct acpi_device_id acpi_als_device_ids[] = {\n\t{\"ACPI0008\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, acpi_als_device_ids);\n\nstatic struct acpi_driver acpi_als_driver = {\n\t.name\t= \"acpi_als\",\n\t.class\t= ACPI_ALS_CLASS,\n\t.ids\t= acpi_als_device_ids,\n\t.ops = {\n\t\t.add\t= acpi_als_add,\n\t\t.notify\t= acpi_als_notify,\n\t},\n};\n\nmodule_acpi_driver(acpi_als_driver);\n\nMODULE_AUTHOR(\"Zhang Rui <rui.zhang@intel.com>\");\nMODULE_AUTHOR(\"Martin Liska <marxin.liska@gmail.com>\");\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"ACPI Ambient Light Sensor Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}