{
  "module_name": "stk3310.c",
  "hash_id": "242b2eb8709cb7eb90ed57f55b3d411a95c04f1fa387be5f31eb0bed4cadd982",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/stk3310.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define STK3310_REG_STATE\t\t\t0x00\n#define STK3310_REG_PSCTRL\t\t\t0x01\n#define STK3310_REG_ALSCTRL\t\t\t0x02\n#define STK3310_REG_INT\t\t\t\t0x04\n#define STK3310_REG_THDH_PS\t\t\t0x06\n#define STK3310_REG_THDL_PS\t\t\t0x08\n#define STK3310_REG_FLAG\t\t\t0x10\n#define STK3310_REG_PS_DATA_MSB\t\t\t0x11\n#define STK3310_REG_PS_DATA_LSB\t\t\t0x12\n#define STK3310_REG_ALS_DATA_MSB\t\t0x13\n#define STK3310_REG_ALS_DATA_LSB\t\t0x14\n#define STK3310_REG_ID\t\t\t\t0x3E\n#define STK3310_MAX_REG\t\t\t\t0x80\n\n#define STK3310_STATE_EN_PS\t\t\tBIT(0)\n#define STK3310_STATE_EN_ALS\t\t\tBIT(1)\n#define STK3310_STATE_STANDBY\t\t\t0x00\n\n#define STK3310_CHIP_ID_VAL\t\t\t0x13\n#define STK3311_CHIP_ID_VAL\t\t\t0x1D\n#define STK3311X_CHIP_ID_VAL\t\t\t0x12\n#define STK3335_CHIP_ID_VAL\t\t\t0x51\n#define STK3310_PSINT_EN\t\t\t0x01\n#define STK3310_PS_MAX_VAL\t\t\t0xFFFF\n\n#define STK3310_DRIVER_NAME\t\t\t\"stk3310\"\n#define STK3310_REGMAP_NAME\t\t\t\"stk3310_regmap\"\n#define STK3310_EVENT\t\t\t\t\"stk3310_event\"\n\n#define STK3310_SCALE_AVAILABLE\t\t\t\"6.4 1.6 0.4 0.1\"\n\n#define STK3310_IT_AVAILABLE \\\n\t\"0.000185 0.000370 0.000741 0.001480 0.002960 0.005920 0.011840 \" \\\n\t\"0.023680 0.047360 0.094720 0.189440 0.378880 0.757760 1.515520 \" \\\n\t\"3.031040 6.062080\"\n\n#define STK3310_REGFIELD(name)\t\t\t\t\t\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tdata->reg_##name =\t\t\t\t\t    \\\n\t\t\tdevm_regmap_field_alloc(&client->dev, regmap,\t    \\\n\t\t\t\tstk3310_reg_field_##name);\t\t    \\\n\t\tif (IS_ERR(data->reg_##name)) {\t\t\t\t    \\\n\t\t\tdev_err(&client->dev, \"reg field alloc failed.\\n\"); \\\n\t\t\treturn PTR_ERR(data->reg_##name);\t\t    \\\n\t\t}\t\t\t\t\t\t\t    \\\n\t} while (0)\n\nstatic const struct reg_field stk3310_reg_field_state =\n\t\t\t\tREG_FIELD(STK3310_REG_STATE, 0, 2);\nstatic const struct reg_field stk3310_reg_field_als_gain =\n\t\t\t\tREG_FIELD(STK3310_REG_ALSCTRL, 4, 5);\nstatic const struct reg_field stk3310_reg_field_ps_gain =\n\t\t\t\tREG_FIELD(STK3310_REG_PSCTRL, 4, 5);\nstatic const struct reg_field stk3310_reg_field_als_it =\n\t\t\t\tREG_FIELD(STK3310_REG_ALSCTRL, 0, 3);\nstatic const struct reg_field stk3310_reg_field_ps_it =\n\t\t\t\tREG_FIELD(STK3310_REG_PSCTRL, 0, 3);\nstatic const struct reg_field stk3310_reg_field_int_ps =\n\t\t\t\tREG_FIELD(STK3310_REG_INT, 0, 2);\nstatic const struct reg_field stk3310_reg_field_flag_psint =\n\t\t\t\tREG_FIELD(STK3310_REG_FLAG, 4, 4);\nstatic const struct reg_field stk3310_reg_field_flag_nf =\n\t\t\t\tREG_FIELD(STK3310_REG_FLAG, 0, 0);\n\n \nstatic const int stk3310_ps_max[4] = {\n\tSTK3310_PS_MAX_VAL / 640,\n\tSTK3310_PS_MAX_VAL / 160,\n\tSTK3310_PS_MAX_VAL /  40,\n\tSTK3310_PS_MAX_VAL /  10\n};\n\nstatic const int stk3310_scale_table[][2] = {\n\t{6, 400000}, {1, 600000}, {0, 400000}, {0, 100000}\n};\n\n \nstatic const int stk3310_it_table[][2] = {\n\t{0, 185},\t{0, 370},\t{0, 741},\t{0, 1480},\n\t{0, 2960},\t{0, 5920},\t{0, 11840},\t{0, 23680},\n\t{0, 47360},\t{0, 94720},\t{0, 189440},\t{0, 378880},\n\t{0, 757760},\t{1, 515520},\t{3, 31040},\t{6, 62080},\n};\n\nstruct stk3310_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tbool als_enabled;\n\tbool ps_enabled;\n\tuint32_t ps_near_level;\n\tu64 timestamp;\n\tstruct regmap *regmap;\n\tstruct regmap_field *reg_state;\n\tstruct regmap_field *reg_als_gain;\n\tstruct regmap_field *reg_ps_gain;\n\tstruct regmap_field *reg_als_it;\n\tstruct regmap_field *reg_ps_it;\n\tstruct regmap_field *reg_int_ps;\n\tstruct regmap_field *reg_flag_psint;\n\tstruct regmap_field *reg_flag_nf;\n};\n\nstatic const struct iio_event_spec stk3310_events[] = {\n\t \n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t \n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic ssize_t stk3310_read_near_level(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t priv,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       char *buf)\n{\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->ps_near_level);\n}\n\nstatic const struct iio_chan_spec_ext_info stk3310_ext_info[] = {\n\t{\n\t\t.name = \"nearlevel\",\n\t\t.shared = IIO_SEPARATE,\n\t\t.read = stk3310_read_near_level,\n\t},\n\t{   }\n};\n\nstatic const struct iio_chan_spec stk3310_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.event_spec = stk3310_events,\n\t\t.num_event_specs = ARRAY_SIZE(stk3310_events),\n\t\t.ext_info = stk3310_ext_info,\n\t}\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_scale_available, STK3310_SCALE_AVAILABLE);\n\nstatic IIO_CONST_ATTR(in_proximity_scale_available, STK3310_SCALE_AVAILABLE);\n\nstatic IIO_CONST_ATTR(in_illuminance_integration_time_available,\n\t\t      STK3310_IT_AVAILABLE);\n\nstatic IIO_CONST_ATTR(in_proximity_integration_time_available,\n\t\t      STK3310_IT_AVAILABLE);\n\nstatic struct attribute *stk3310_attributes[] = {\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_proximity_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_in_proximity_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group stk3310_attribute_group = {\n\t.attrs = stk3310_attributes\n};\n\nstatic int stk3310_get_index(const int table[][2], int table_size,\n\t\t\t     int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (val == table[i][0] && val2 == table[i][1])\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stk3310_read_event(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir,\n\t\t\t      enum iio_event_info info,\n\t\t\t      int *val, int *val2)\n{\n\tu8 reg;\n\t__be16 buf;\n\tint ret;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\tif (info != IIO_EV_INFO_VALUE)\n\t\treturn -EINVAL;\n\n\t \n\tif (dir == IIO_EV_DIR_RISING)\n\t\treg = STK3310_REG_THDH_PS;\n\telse if (dir == IIO_EV_DIR_FALLING)\n\t\treg = STK3310_REG_THDL_PS;\n\telse\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_bulk_read(data->regmap, reg, &buf, 2);\n\tmutex_unlock(&data->lock);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"register read failed\\n\");\n\t\treturn ret;\n\t}\n\t*val = be16_to_cpu(buf);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int stk3310_write_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int val, int val2)\n{\n\tu8 reg;\n\t__be16 buf;\n\tint ret;\n\tunsigned int index;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = regmap_field_read(data->reg_ps_gain, &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val < 0 || val > stk3310_ps_max[index])\n\t\treturn -EINVAL;\n\n\tif (dir == IIO_EV_DIR_RISING)\n\t\treg = STK3310_REG_THDH_PS;\n\telse if (dir == IIO_EV_DIR_FALLING)\n\t\treg = STK3310_REG_THDL_PS;\n\telse\n\t\treturn -EINVAL;\n\n\tbuf = cpu_to_be16(val);\n\tret = regmap_bulk_write(data->regmap, reg, &buf, 2);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to set PS threshold!\\n\");\n\n\treturn ret;\n}\n\nstatic int stk3310_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tunsigned int event_val;\n\tint ret;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\tret = regmap_field_read(data->reg_int_ps, &event_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn event_val;\n}\n\nstatic int stk3310_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tint ret;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (state < 0 || state > 7)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&data->lock);\n\tret = regmap_field_write(data->reg_int_ps, state);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to set interrupt mode\\n\");\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int stk3310_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tu8 reg;\n\t__be16 buf;\n\tint ret;\n\tunsigned int index;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\treg = STK3310_REG_ALS_DATA_MSB;\n\t\telse\n\t\t\treg = STK3310_REG_PS_DATA_MSB;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = regmap_bulk_read(data->regmap, reg, &buf, 2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"register read failed\\n\");\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = be16_to_cpu(buf);\n\t\tmutex_unlock(&data->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\tret = regmap_field_read(data->reg_als_it, &index);\n\t\telse\n\t\t\tret = regmap_field_read(data->reg_ps_it, &index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = stk3310_it_table[index][0];\n\t\t*val2 = stk3310_it_table[index][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\tret = regmap_field_read(data->reg_als_gain, &index);\n\t\telse\n\t\t\tret = regmap_field_read(data->reg_ps_gain, &index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = stk3310_scale_table[index][0];\n\t\t*val2 = stk3310_scale_table[index][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stk3310_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tint ret;\n\tint index;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tindex = stk3310_get_index(stk3310_it_table,\n\t\t\t\t\t  ARRAY_SIZE(stk3310_it_table),\n\t\t\t\t\t  val, val2);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->lock);\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\tret = regmap_field_write(data->reg_als_it, index);\n\t\telse\n\t\t\tret = regmap_field_write(data->reg_ps_it, index);\n\t\tif (ret < 0)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"sensor configuration failed\\n\");\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tindex = stk3310_get_index(stk3310_scale_table,\n\t\t\t\t\t  ARRAY_SIZE(stk3310_scale_table),\n\t\t\t\t\t  val, val2);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->lock);\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\tret = regmap_field_write(data->reg_als_gain, index);\n\t\telse\n\t\t\tret = regmap_field_write(data->reg_ps_gain, index);\n\t\tif (ret < 0)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"sensor configuration failed\\n\");\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info stk3310_info = {\n\t.read_raw\t\t= stk3310_read_raw,\n\t.write_raw\t\t= stk3310_write_raw,\n\t.attrs\t\t\t= &stk3310_attribute_group,\n\t.read_event_value\t= stk3310_read_event,\n\t.write_event_value\t= stk3310_write_event,\n\t.read_event_config\t= stk3310_read_event_config,\n\t.write_event_config\t= stk3310_write_event_config,\n};\n\nstatic int stk3310_set_state(struct stk3310_data *data, u8 state)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\n\t \n\tif (state > 7 || state == 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_field_write(data->reg_state, state);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to change sensor state\\n\");\n\t} else if (state != STK3310_STATE_STANDBY) {\n\t\t \n\t\tdata->ps_enabled  = !!(state & STK3310_STATE_EN_PS);\n\t\tdata->als_enabled = !!(state & STK3310_STATE_EN_ALS);\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int stk3310_init(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tint chipid;\n\tu8 state;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = regmap_read(data->regmap, STK3310_REG_ID, &chipid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chipid != STK3310_CHIP_ID_VAL &&\n\t    chipid != STK3311_CHIP_ID_VAL &&\n\t    chipid != STK3311X_CHIP_ID_VAL &&\n\t    chipid != STK3335_CHIP_ID_VAL) {\n\t\tdev_err(&client->dev, \"invalid chip id: 0x%x\\n\", chipid);\n\t\treturn -ENODEV;\n\t}\n\n\tstate = STK3310_STATE_EN_ALS | STK3310_STATE_EN_PS;\n\tret = stk3310_set_state(data, state);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to enable sensor\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_field_write(data->reg_int_ps, STK3310_PSINT_EN);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to enable interrupts!\\n\");\n\n\treturn ret;\n}\n\nstatic bool stk3310_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STK3310_REG_ALS_DATA_MSB:\n\tcase STK3310_REG_ALS_DATA_LSB:\n\tcase STK3310_REG_PS_DATA_LSB:\n\tcase STK3310_REG_PS_DATA_MSB:\n\tcase STK3310_REG_FLAG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config stk3310_regmap_config = {\n\t.name = STK3310_REGMAP_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = STK3310_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = stk3310_is_volatile_reg,\n};\n\nstatic int stk3310_regmap_init(struct stk3310_data *data)\n{\n\tstruct regmap *regmap;\n\tstruct i2c_client *client;\n\n\tclient = data->client;\n\tregmap = devm_regmap_init_i2c(client, &stk3310_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap initialization failed.\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\tdata->regmap = regmap;\n\n\tSTK3310_REGFIELD(state);\n\tSTK3310_REGFIELD(als_gain);\n\tSTK3310_REGFIELD(ps_gain);\n\tSTK3310_REGFIELD(als_it);\n\tSTK3310_REGFIELD(ps_it);\n\tSTK3310_REGFIELD(int_ps);\n\tSTK3310_REGFIELD(flag_psint);\n\tSTK3310_REGFIELD(flag_nf);\n\n\treturn 0;\n}\n\nstatic irqreturn_t stk3310_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\tdata->timestamp = iio_get_time_ns(indio_dev);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t stk3310_irq_event_handler(int irq, void *private)\n{\n\tint ret;\n\tunsigned int dir;\n\tu64 event;\n\n\tstruct iio_dev *indio_dev = private;\n\tstruct stk3310_data *data = iio_priv(indio_dev);\n\n\t \n\tmutex_lock(&data->lock);\n\tret = regmap_field_read(data->reg_flag_nf, &dir);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"register read failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tevent = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1,\n\t\t\t\t     IIO_EV_TYPE_THRESH,\n\t\t\t\t     (dir ? IIO_EV_DIR_FALLING :\n\t\t\t\t\t    IIO_EV_DIR_RISING));\n\tiio_push_event(indio_dev, event, data->timestamp);\n\n\t \n\tret = regmap_field_write(data->reg_flag_psint, 0);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"failed to reset interrupts\\n\");\nout:\n\tmutex_unlock(&data->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stk3310_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct stk3310_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdevice_property_read_u32(&client->dev, \"proximity-near-level\",\n\t\t\t\t &data->ps_near_level);\n\n\tmutex_init(&data->lock);\n\n\tret = stk3310_regmap_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->info = &stk3310_info;\n\tindio_dev->name = STK3310_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = stk3310_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(stk3310_channels);\n\n\tret = stk3310_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tstk3310_irq_handler,\n\t\t\t\t\t\tstk3310_irq_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tSTK3310_EVENT, indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"request irq %d failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto err_standby;\n\t\t}\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"device_register failed\\n\");\n\t\tgoto err_standby;\n\t}\n\n\treturn 0;\n\nerr_standby:\n\tstk3310_set_state(data, STK3310_STATE_STANDBY);\n\treturn ret;\n}\n\nstatic void stk3310_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tstk3310_set_state(iio_priv(indio_dev), STK3310_STATE_STANDBY);\n}\n\nstatic int stk3310_suspend(struct device *dev)\n{\n\tstruct stk3310_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn stk3310_set_state(data, STK3310_STATE_STANDBY);\n}\n\nstatic int stk3310_resume(struct device *dev)\n{\n\tu8 state = 0;\n\tstruct stk3310_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\tif (data->ps_enabled)\n\t\tstate |= STK3310_STATE_EN_PS;\n\tif (data->als_enabled)\n\t\tstate |= STK3310_STATE_EN_ALS;\n\n\treturn stk3310_set_state(data, state);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stk3310_pm_ops, stk3310_suspend,\n\t\t\t\tstk3310_resume);\n\nstatic const struct i2c_device_id stk3310_i2c_id[] = {\n\t{\"STK3310\", 0},\n\t{\"STK3311\", 0},\n\t{\"STK3335\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, stk3310_i2c_id);\n\nstatic const struct acpi_device_id stk3310_acpi_id[] = {\n\t{\"STK3310\", 0},\n\t{\"STK3311\", 0},\n\t{\"STK3335\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, stk3310_acpi_id);\n\nstatic const struct of_device_id stk3310_of_match[] = {\n\t{ .compatible = \"sensortek,stk3310\", },\n\t{ .compatible = \"sensortek,stk3311\", },\n\t{ .compatible = \"sensortek,stk3335\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stk3310_of_match);\n\nstatic struct i2c_driver stk3310_driver = {\n\t.driver = {\n\t\t.name = \"stk3310\",\n\t\t.of_match_table = stk3310_of_match,\n\t\t.pm = pm_sleep_ptr(&stk3310_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(stk3310_acpi_id),\n\t},\n\t.probe =        stk3310_probe,\n\t.remove =           stk3310_remove,\n\t.id_table =         stk3310_i2c_id,\n};\n\nmodule_i2c_driver(stk3310_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"STK3310 Ambient Light and Proximity Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}