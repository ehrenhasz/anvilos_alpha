{
  "module_name": "cm32181.c",
  "hash_id": "db3310be5fef14dfb19b0f95bdfc08482f10f293c5af7e86b7539a60b857b607",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/cm32181.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/regulator/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/init.h>\n\n \n#define CM32181_REG_ADDR_CMD\t\t0x00\n#define CM32181_REG_ADDR_WH\t\t0x01\n#define CM32181_REG_ADDR_WL\t\t0x02\n#define CM32181_REG_ADDR_TEST\t\t0x03\n#define CM32181_REG_ADDR_ALS\t\t0x04\n#define CM32181_REG_ADDR_STATUS\t\t0x06\n#define CM32181_REG_ADDR_ID\t\t0x07\n\n \n#define CM32181_CONF_REG_NUM\t\t4\n\n \n#define CM32181_CMD_ALS_DISABLE\t\tBIT(0)\n#define CM32181_CMD_ALS_INT_EN\t\tBIT(1)\n#define CM32181_CMD_ALS_THRES_WINDOW\tBIT(2)\n\n#define CM32181_CMD_ALS_PERS_SHIFT\t4\n#define CM32181_CMD_ALS_PERS_MASK\t(0x03 << CM32181_CMD_ALS_PERS_SHIFT)\n#define CM32181_CMD_ALS_PERS_DEFAULT\t(0x01 << CM32181_CMD_ALS_PERS_SHIFT)\n\n#define CM32181_CMD_ALS_IT_SHIFT\t6\n#define CM32181_CMD_ALS_IT_MASK\t\t(0x0F << CM32181_CMD_ALS_IT_SHIFT)\n#define CM32181_CMD_ALS_IT_DEFAULT\t(0x00 << CM32181_CMD_ALS_IT_SHIFT)\n\n#define CM32181_CMD_ALS_SM_SHIFT\t11\n#define CM32181_CMD_ALS_SM_MASK\t\t(0x03 << CM32181_CMD_ALS_SM_SHIFT)\n#define CM32181_CMD_ALS_SM_DEFAULT\t(0x01 << CM32181_CMD_ALS_SM_SHIFT)\n\n#define CM32181_LUX_PER_BIT\t\t500\t \n#define CM32181_LUX_PER_BIT_RESOLUTION\t100000\n#define CM32181_LUX_PER_BIT_BASE_IT\t800000\t \n#define CM32181_CALIBSCALE_DEFAULT\t100000\n#define CM32181_CALIBSCALE_RESOLUTION\t100000\n\n#define SMBUS_ALERT_RESPONSE_ADDRESS\t0x0c\n\n \n#define CPM0_REGS_BITMAP\t\t2\n#define CPM0_HEADER_SIZE\t\t3\n\n \n#define CPM1_LUX_PER_BIT\t\t0\n#define CPM1_CALIBSCALE\t\t\t1\n#define CPM1_SIZE\t\t\t3\n\n \nstatic const int cm3218_als_it_bits[] = { 0, 1, 2, 3 };\nstatic const int cm3218_als_it_values[] = { 100000, 200000, 400000, 800000 };\n\n \nstatic const int cm32181_als_it_bits[] = { 12, 8, 0, 1, 2, 3 };\nstatic const int cm32181_als_it_values[] = {\n\t25000, 50000, 100000, 200000, 400000, 800000\n};\n\nstruct cm32181_chip {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct mutex lock;\n\tu16 conf_regs[CM32181_CONF_REG_NUM];\n\tunsigned long init_regs_bitmap;\n\tint calibscale;\n\tint lux_per_bit;\n\tint lux_per_bit_base_it;\n\tint num_als_it;\n\tconst int *als_it_bits;\n\tconst int *als_it_values;\n};\n\nstatic int cm32181_read_als_it(struct cm32181_chip *cm32181, int *val2);\n\n#ifdef CONFIG_ACPI\n \nstatic int cm32181_acpi_get_cpm(struct device *dev, char *obj_name,\n\t\t\t\tu64 *values, int count)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *cpm, *elem;\n\tacpi_handle handle;\n\tacpi_status status;\n\tint i;\n\n\thandle = ACPI_HANDLE(dev);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_object(handle, obj_name, NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"object %s not found\\n\", obj_name);\n\t\treturn -ENODEV;\n\t}\n\n\tcpm = buffer.pointer;\n\tif (cpm->package.count > count)\n\t\tdev_warn(dev, \"%s table contains %u values, only using first %d values\\n\",\n\t\t\t obj_name, cpm->package.count, count);\n\n\tcount = min_t(int, cpm->package.count, count);\n\tfor (i = 0; i < count; i++) {\n\t\telem = &(cpm->package.elements[i]);\n\t\tvalues[i] = elem->integer.value;\n\t}\n\n\tkfree(buffer.pointer);\n\n\treturn count;\n}\n\nstatic void cm32181_acpi_parse_cpm_tables(struct cm32181_chip *cm32181)\n{\n\tu64 vals[CPM0_HEADER_SIZE + CM32181_CONF_REG_NUM];\n\tstruct device *dev = cm32181->dev;\n\tint i, count;\n\n\tcount = cm32181_acpi_get_cpm(dev, \"CPM0\", vals, ARRAY_SIZE(vals));\n\tif (count <= CPM0_HEADER_SIZE)\n\t\treturn;\n\n\tcount -= CPM0_HEADER_SIZE;\n\n\tcm32181->init_regs_bitmap = vals[CPM0_REGS_BITMAP];\n\tcm32181->init_regs_bitmap &= GENMASK(count - 1, 0);\n\tfor_each_set_bit(i, &cm32181->init_regs_bitmap, count)\n\t\tcm32181->conf_regs[i] =\tvals[CPM0_HEADER_SIZE + i];\n\n\tcount = cm32181_acpi_get_cpm(dev, \"CPM1\", vals, ARRAY_SIZE(vals));\n\tif (count != CPM1_SIZE)\n\t\treturn;\n\n\tcm32181->lux_per_bit = vals[CPM1_LUX_PER_BIT];\n\n\t \n\tif (vals[CPM1_CALIBSCALE] == CM32181_CALIBSCALE_DEFAULT)\n\t\treturn;\n\n\tcm32181->calibscale = vals[CPM1_CALIBSCALE];\n\t \n\tcm32181_read_als_it(cm32181, &cm32181->lux_per_bit_base_it);\n}\n#else\nstatic void cm32181_acpi_parse_cpm_tables(struct cm32181_chip *cm32181)\n{\n}\n#endif  \n\n \nstatic int cm32181_reg_init(struct cm32181_chip *cm32181)\n{\n\tstruct i2c_client *client = cm32181->client;\n\tint i;\n\ts32 ret;\n\n\tret = i2c_smbus_read_word_data(client, CM32181_REG_ADDR_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (ret & 0xFF) {\n\tcase 0x18:  \n\t\tcm32181->num_als_it = ARRAY_SIZE(cm3218_als_it_bits);\n\t\tcm32181->als_it_bits = cm3218_als_it_bits;\n\t\tcm32181->als_it_values = cm3218_als_it_values;\n\t\tbreak;\n\tcase 0x81:  \n\tcase 0x82:  \n\t\tcm32181->num_als_it = ARRAY_SIZE(cm32181_als_it_bits);\n\t\tcm32181->als_it_bits = cm32181_als_it_bits;\n\t\tcm32181->als_it_values = cm32181_als_it_values;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcm32181->conf_regs[CM32181_REG_ADDR_CMD] =\n\t\t\tCM32181_CMD_ALS_IT_DEFAULT | CM32181_CMD_ALS_SM_DEFAULT;\n\tcm32181->init_regs_bitmap = BIT(CM32181_REG_ADDR_CMD);\n\tcm32181->calibscale = CM32181_CALIBSCALE_DEFAULT;\n\tcm32181->lux_per_bit = CM32181_LUX_PER_BIT;\n\tcm32181->lux_per_bit_base_it = CM32181_LUX_PER_BIT_BASE_IT;\n\n\tif (ACPI_HANDLE(cm32181->dev))\n\t\tcm32181_acpi_parse_cpm_tables(cm32181);\n\n\t \n\tfor_each_set_bit(i, &cm32181->init_regs_bitmap, CM32181_CONF_REG_NUM) {\n\t\tret = i2c_smbus_write_word_data(client, i,\n\t\t\t\t\t\tcm32181->conf_regs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cm32181_read_als_it(struct cm32181_chip *cm32181, int *val2)\n{\n\tu16 als_it;\n\tint i;\n\n\tals_it = cm32181->conf_regs[CM32181_REG_ADDR_CMD];\n\tals_it &= CM32181_CMD_ALS_IT_MASK;\n\tals_it >>= CM32181_CMD_ALS_IT_SHIFT;\n\tfor (i = 0; i < cm32181->num_als_it; i++) {\n\t\tif (als_it == cm32181->als_it_bits[i]) {\n\t\t\t*val2 = cm32181->als_it_values[i];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int cm32181_write_als_it(struct cm32181_chip *cm32181, int val)\n{\n\tstruct i2c_client *client = cm32181->client;\n\tu16 als_it;\n\tint ret, i, n;\n\n\tn = cm32181->num_als_it;\n\tfor (i = 0; i < n; i++)\n\t\tif (val <= cm32181->als_it_values[i])\n\t\t\tbreak;\n\tif (i >= n)\n\t\ti = n - 1;\n\n\tals_it = cm32181->als_it_bits[i];\n\tals_it <<= CM32181_CMD_ALS_IT_SHIFT;\n\n\tmutex_lock(&cm32181->lock);\n\tcm32181->conf_regs[CM32181_REG_ADDR_CMD] &=\n\t\t~CM32181_CMD_ALS_IT_MASK;\n\tcm32181->conf_regs[CM32181_REG_ADDR_CMD] |=\n\t\tals_it;\n\tret = i2c_smbus_write_word_data(client, CM32181_REG_ADDR_CMD,\n\t\t\tcm32181->conf_regs[CM32181_REG_ADDR_CMD]);\n\tmutex_unlock(&cm32181->lock);\n\n\treturn ret;\n}\n\n \nstatic int cm32181_get_lux(struct cm32181_chip *cm32181)\n{\n\tstruct i2c_client *client = cm32181->client;\n\tint ret;\n\tint als_it;\n\tu64 lux;\n\n\tret = cm32181_read_als_it(cm32181, &als_it);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tlux = cm32181->lux_per_bit;\n\tlux *= cm32181->lux_per_bit_base_it;\n\tlux = div_u64(lux, als_it);\n\n\tret = i2c_smbus_read_word_data(client, CM32181_REG_ADDR_ALS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlux *= ret;\n\tlux *= cm32181->calibscale;\n\tlux = div_u64(lux, CM32181_CALIBSCALE_RESOLUTION);\n\tlux = div_u64(lux, CM32181_LUX_PER_BIT_RESOLUTION);\n\n\tif (lux > 0xFFFF)\n\t\tlux = 0xFFFF;\n\n\treturn lux;\n}\n\nstatic int cm32181_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct cm32181_chip *cm32181 = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = cm32181_get_lux(cm32181);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = cm32181->calibscale;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\tret = cm32181_read_als_it(cm32181, val2);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cm32181_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct cm32181_chip *cm32181 = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tcm32181->calibscale = val;\n\t\treturn val;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tret = cm32181_write_als_it(cm32181, val2);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t cm32181_get_it_available(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct cm32181_chip *cm32181 = iio_priv(dev_to_iio_dev(dev));\n\tint i, n, len;\n\n\tn = cm32181->num_als_it;\n\tfor (i = 0, len = 0; i < n; i++)\n\t\tlen += sprintf(buf + len, \"0.%06u \", cm32181->als_it_values[i]);\n\treturn len + sprintf(buf + len, \"\\n\");\n}\n\nstatic const struct iio_chan_spec cm32181_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t}\n};\n\nstatic IIO_DEVICE_ATTR(in_illuminance_integration_time_available,\n\t\t\tS_IRUGO, cm32181_get_it_available, NULL, 0);\n\nstatic struct attribute *cm32181_attributes[] = {\n\t&iio_dev_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cm32181_attribute_group = {\n\t.attrs = cm32181_attributes\n};\n\nstatic const struct iio_info cm32181_info = {\n\t.read_raw\t\t= &cm32181_read_raw,\n\t.write_raw\t\t= &cm32181_write_raw,\n\t.attrs\t\t\t= &cm32181_attribute_group,\n};\n\nstatic void cm32181_unregister_dummy_client(void *data)\n{\n\tstruct i2c_client *client = data;\n\n\t \n\ti2c_unregister_device(client);\n}\n\nstatic int cm32181_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct cm32181_chip *cm32181;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*cm32181));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\t \n\tif (ACPI_HANDLE(dev) && client->addr == SMBUS_ALERT_RESPONSE_ADDRESS) {\n\t\tstruct i2c_board_info board_info = { .type = \"dummy\" };\n\n\t\ti2c_smbus_read_byte(client);\n\n\t\tclient = i2c_acpi_new_device(dev, 1, &board_info);\n\t\tif (IS_ERR(client))\n\t\t\treturn PTR_ERR(client);\n\n\t\tret = devm_add_action_or_reset(dev, cm32181_unregister_dummy_client, client);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcm32181 = iio_priv(indio_dev);\n\tcm32181->client = client;\n\tcm32181->dev = dev;\n\n\tmutex_init(&cm32181->lock);\n\tindio_dev->channels = cm32181_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cm32181_channels);\n\tindio_dev->info = &cm32181_info;\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = cm32181_reg_init(cm32181);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: register init failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: regist device failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cm32181_suspend(struct device *dev)\n{\n\tstruct cm32181_chip *cm32181 = iio_priv(dev_get_drvdata(dev));\n\tstruct i2c_client *client = cm32181->client;\n\n\treturn i2c_smbus_write_word_data(client, CM32181_REG_ADDR_CMD,\n\t\t\t\t\t CM32181_CMD_ALS_DISABLE);\n}\n\nstatic int cm32181_resume(struct device *dev)\n{\n\tstruct cm32181_chip *cm32181 = iio_priv(dev_get_drvdata(dev));\n\tstruct i2c_client *client = cm32181->client;\n\n\treturn i2c_smbus_write_word_data(client, CM32181_REG_ADDR_CMD,\n\t\t\t\t\t cm32181->conf_regs[CM32181_REG_ADDR_CMD]);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cm32181_pm_ops, cm32181_suspend, cm32181_resume);\n\nstatic const struct of_device_id cm32181_of_match[] = {\n\t{ .compatible = \"capella,cm3218\" },\n\t{ .compatible = \"capella,cm32181\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cm32181_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cm32181_acpi_match[] = {\n\t{ \"CPLM3218\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cm32181_acpi_match);\n#endif\n\nstatic struct i2c_driver cm32181_driver = {\n\t.driver = {\n\t\t.name\t= \"cm32181\",\n\t\t.acpi_match_table = ACPI_PTR(cm32181_acpi_match),\n\t\t.of_match_table = cm32181_of_match,\n\t\t.pm = pm_sleep_ptr(&cm32181_pm_ops),\n\t},\n\t.probe\t\t= cm32181_probe,\n};\n\nmodule_i2c_driver(cm32181_driver);\n\nMODULE_AUTHOR(\"Kevin Tsai <ktsai@capellamicro.com>\");\nMODULE_DESCRIPTION(\"CM32181 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}