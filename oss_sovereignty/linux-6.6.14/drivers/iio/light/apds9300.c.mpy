{
  "module_name": "apds9300.c",
  "hash_id": "eb2fb1bea26853b0b50367300b7a830e688fd0a61bbf74b20d9c4f74ac1cdcc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/apds9300.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n#define APDS9300_DRV_NAME \"apds9300\"\n#define APDS9300_IRQ_NAME \"apds9300_event\"\n\n \n#define APDS9300_CMD\tBIT(7)  \n#define APDS9300_WORD\tBIT(5)  \n#define APDS9300_CLEAR\tBIT(6)  \n\n \n#define APDS9300_CONTROL\t0x00  \n#define APDS9300_THRESHLOWLOW\t0x02  \n#define APDS9300_THRESHHIGHLOW\t0x04  \n#define APDS9300_INTERRUPT\t0x06  \n#define APDS9300_DATA0LOW\t0x0c  \n#define APDS9300_DATA1LOW\t0x0e  \n\n \n#define APDS9300_POWER_ON\t0x03\n#define APDS9300_POWER_OFF\t0x00\n\n \n#define APDS9300_INTR_ENABLE\t0x10\n \n#define APDS9300_THRESH_INTR\t0x01\n\n#define APDS9300_THRESH_MAX\t0xffff  \n\nstruct apds9300_data {\n\tstruct i2c_client *client;\n\tstruct mutex mutex;\n\tint power_state;\n\tint thresh_low;\n\tint thresh_hi;\n\tint intr_en;\n};\n\n \n\n \nstatic const u16 apds9300_lux_ratio[] = {\n\t0, 2, 4, 7, 11, 15, 19, 24, 29, 34, 40, 45, 51, 57, 64, 70, 77, 84, 91,\n\t98, 105, 112, 120, 128, 136, 144, 152, 160, 168, 177, 185, 194, 203,\n\t212, 221, 230, 239, 249, 258, 268, 277, 287, 297, 307, 317, 327, 337,\n\t347, 358, 368, 379, 390, 400,\n};\n\nstatic unsigned long apds9300_calculate_lux(u16 ch0, u16 ch1)\n{\n\tunsigned long lux, tmp;\n\n\t \n\tif (ch0 == 0)\n\t\treturn 0;\n\n\ttmp = DIV_ROUND_UP(ch1 * 100, ch0);\n\tif (tmp <= 52) {\n\t\tlux = 3150 * ch0 - (unsigned long)DIV_ROUND_UP_ULL(ch0\n\t\t\t\t* apds9300_lux_ratio[tmp] * 5930ull, 1000);\n\t} else if (tmp <= 65) {\n\t\tlux = 2290 * ch0 - 2910 * ch1;\n\t} else if (tmp <= 80) {\n\t\tlux = 1570 * ch0 - 1800 * ch1;\n\t} else if (tmp <= 130) {\n\t\tlux = 338 * ch0 - 260 * ch1;\n\t} else {\n\t\tlux = 0;\n\t}\n\n\treturn lux / 100000;\n}\n\nstatic int apds9300_get_adc_val(struct apds9300_data *data, int adc_number)\n{\n\tint ret;\n\tu8 flags = APDS9300_CMD | APDS9300_WORD;\n\n\tif (!data->power_state)\n\t\treturn -EBUSY;\n\n\t \n\tflags |= adc_number ? APDS9300_DATA1LOW : APDS9300_DATA0LOW;\n\n\tret = i2c_smbus_read_word_data(data->client, flags);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev,\n\t\t\t\"failed to read ADC%d value\\n\", adc_number);\n\n\treturn ret;\n}\n\nstatic int apds9300_set_thresh_low(struct apds9300_data *data, int value)\n{\n\tint ret;\n\n\tif (!data->power_state)\n\t\treturn -EBUSY;\n\n\tif (value > APDS9300_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_word_data(data->client, APDS9300_THRESHLOWLOW\n\t\t\t| APDS9300_CMD | APDS9300_WORD, value);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"failed to set thresh_low\\n\");\n\t\treturn ret;\n\t}\n\tdata->thresh_low = value;\n\n\treturn 0;\n}\n\nstatic int apds9300_set_thresh_hi(struct apds9300_data *data, int value)\n{\n\tint ret;\n\n\tif (!data->power_state)\n\t\treturn -EBUSY;\n\n\tif (value > APDS9300_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_word_data(data->client, APDS9300_THRESHHIGHLOW\n\t\t\t| APDS9300_CMD | APDS9300_WORD, value);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"failed to set thresh_hi\\n\");\n\t\treturn ret;\n\t}\n\tdata->thresh_hi = value;\n\n\treturn 0;\n}\n\nstatic int apds9300_set_intr_state(struct apds9300_data *data, int state)\n{\n\tint ret;\n\tu8 cmd;\n\n\tif (!data->power_state)\n\t\treturn -EBUSY;\n\n\tcmd = state ? APDS9300_INTR_ENABLE | APDS9300_THRESH_INTR : 0x00;\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tAPDS9300_INTERRUPT | APDS9300_CMD, cmd);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"failed to set interrupt state %d\\n\", state);\n\t\treturn ret;\n\t}\n\tdata->intr_en = state;\n\n\treturn 0;\n}\n\nstatic int apds9300_set_power_state(struct apds9300_data *data, int state)\n{\n\tint ret;\n\tu8 cmd;\n\n\tcmd = state ? APDS9300_POWER_ON : APDS9300_POWER_OFF;\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tAPDS9300_CONTROL | APDS9300_CMD, cmd);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"failed to set power state %d\\n\", state);\n\t\treturn ret;\n\t}\n\tdata->power_state = state;\n\n\treturn 0;\n}\n\nstatic void apds9300_clear_intr(struct apds9300_data *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte(data->client, APDS9300_CLEAR | APDS9300_CMD);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"failed to clear interrupt\\n\");\n}\n\nstatic int apds9300_chip_init(struct apds9300_data *data)\n{\n\tint ret;\n\n\t \n\tret = apds9300_set_power_state(data, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\t \n\tret = apds9300_set_power_state(data, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\tAPDS9300_CONTROL | APDS9300_CMD);\n\tif (ret != APDS9300_POWER_ON) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\t \n\tret = apds9300_set_intr_state(data, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(&data->client->dev, \"failed to init the chip\\n\");\n\treturn ret;\n}\n\nstatic int apds9300_read_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan, int *val, int *val2,\n\t\tlong mask)\n{\n\tint ch0, ch1, ret = -EINVAL;\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tch0 = apds9300_get_adc_val(data, 0);\n\t\tif (ch0 < 0) {\n\t\t\tret = ch0;\n\t\t\tbreak;\n\t\t}\n\t\tch1 = apds9300_get_adc_val(data, 1);\n\t\tif (ch1 < 0) {\n\t\t\tret = ch1;\n\t\t\tbreak;\n\t\t}\n\t\t*val = apds9300_calculate_lux(ch0, ch1);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_INTENSITY:\n\t\tret = apds9300_get_adc_val(data, chan->channel);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t*val = ret;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int apds9300_read_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint *val, int *val2)\n{\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\t*val = data->thresh_hi;\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\t*val = data->thresh_low;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int apds9300_write_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\t\tint val2)\n{\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tif (dir == IIO_EV_DIR_RISING)\n\t\tret = apds9300_set_thresh_hi(data, val);\n\telse\n\t\tret = apds9300_set_thresh_low(data, val);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int apds9300_read_interrupt_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan,\n\t\tenum iio_event_type type,\n\t\tenum iio_event_direction dir)\n{\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\n\treturn data->intr_en;\n}\n\nstatic int apds9300_write_interrupt_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, int state)\n{\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = apds9300_set_intr_state(data, state);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_info apds9300_info_no_irq = {\n\t.read_raw\t= apds9300_read_raw,\n};\n\nstatic const struct iio_info apds9300_info = {\n\t.read_raw\t\t= apds9300_read_raw,\n\t.read_event_value\t= apds9300_read_thresh,\n\t.write_event_value\t= apds9300_write_thresh,\n\t.read_event_config\t= apds9300_read_interrupt_config,\n\t.write_event_config\t= apds9300_write_interrupt_config,\n};\n\nstatic const struct iio_event_spec apds9300_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec apds9300_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.channel = 0,\n\t\t.indexed = true,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t}, {\n\t\t.type = IIO_INTENSITY,\n\t\t.channel = 0,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.indexed = true,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = apds9300_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(apds9300_event_spec),\n\t}, {\n\t\t.type = IIO_INTENSITY,\n\t\t.channel = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.indexed = true,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t},\n};\n\nstatic irqreturn_t apds9300_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *dev_info = private;\n\tstruct apds9300_data *data = iio_priv(dev_info);\n\n\tiio_push_event(dev_info,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t       iio_get_time_ns(dev_info));\n\n\tapds9300_clear_intr(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apds9300_probe(struct i2c_client *client)\n{\n\tstruct apds9300_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tret = apds9300_chip_init(data);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->channels = apds9300_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(apds9300_channels);\n\tindio_dev->name = APDS9300_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (client->irq)\n\t\tindio_dev->info = &apds9300_info;\n\telse\n\t\tindio_dev->info = &apds9300_info_no_irq;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL, apds9300_interrupt_handler,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\tAPDS9300_IRQ_NAME, indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"irq request error %d\\n\", -ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\t \n\tapds9300_set_power_state(data, 0);\n\treturn ret;\n}\n\nstatic void apds9300_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\t \n\tapds9300_set_intr_state(data, 0);\n\tapds9300_set_power_state(data, 0);\n}\n\nstatic int apds9300_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = apds9300_set_power_state(data, 0);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int apds9300_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct apds9300_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = apds9300_set_power_state(data, 1);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(apds9300_pm_ops, apds9300_suspend,\n\t\t\t\tapds9300_resume);\n\nstatic const struct i2c_device_id apds9300_id[] = {\n\t{ APDS9300_DRV_NAME, 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, apds9300_id);\n\nstatic struct i2c_driver apds9300_driver = {\n\t.driver = {\n\t\t.name\t= APDS9300_DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&apds9300_pm_ops),\n\t},\n\t.probe\t\t= apds9300_probe,\n\t.remove\t\t= apds9300_remove,\n\t.id_table\t= apds9300_id,\n};\n\nmodule_i2c_driver(apds9300_driver);\n\nMODULE_AUTHOR(\"Kravchenko Oleksandr <o.v.kravchenko@globallogic.com>\");\nMODULE_AUTHOR(\"GlobalLogic inc.\");\nMODULE_DESCRIPTION(\"APDS9300 ambient light photo sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}