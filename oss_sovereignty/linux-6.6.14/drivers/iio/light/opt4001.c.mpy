{
  "module_name": "opt4001.c",
  "hash_id": "3e667c67721a0f40513290f56f342afd565c34595eafa22cd01bc4381506fb8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/opt4001.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n \n#define OPT4001_LIGHT1_MSB    0x00\n#define OPT4001_LIGHT1_LSB    0x01\n#define OPT4001_CTRL          0x0A\n#define OPT4001_DEVICE_ID     0x11\n\n \n#define OPT4001_EXPONENT_MASK    GENMASK(15, 12)\n#define OPT4001_MSB_MASK         GENMASK(11, 0)\n#define OPT4001_LSB_MASK         GENMASK(15, 8)\n#define OPT4001_COUNTER_MASK     GENMASK(7, 4)\n#define OPT4001_CRC_MASK         GENMASK(3, 0)\n\n \n#define OPT4001_DEVICE_ID_MASK   GENMASK(11, 0)\n\n \n#define OPT4001_CTRL_QWAKE_MASK          GENMASK(15, 15)\n#define OPT4001_CTRL_RANGE_MASK          GENMASK(13, 10)\n#define OPT4001_CTRL_CONV_TIME_MASK      GENMASK(9, 6)\n#define OPT4001_CTRL_OPER_MODE_MASK      GENMASK(5, 4)\n#define OPT4001_CTRL_LATCH_MASK          GENMASK(3, 3)\n#define OPT4001_CTRL_INT_POL_MASK        GENMASK(2, 2)\n#define OPT4001_CTRL_FAULT_COUNT         GENMASK(0, 1)\n\n \n#define OPT4001_DEVICE_ID_VAL            0x121\n\n \n#define OPT4001_CTRL_OPER_MODE_OFF        0x0\n#define OPT4001_CTRL_OPER_MODE_FORCED     0x1\n#define OPT4001_CTRL_OPER_MODE_ONE_SHOT   0x2\n#define OPT4001_CTRL_OPER_MODE_CONTINUOUS 0x3\n\n \n#define OPT4001_CTRL_CONVERSION_0_6MS   0x0\n#define OPT4001_CTRL_CONVERSION_1MS     0x1\n#define OPT4001_CTRL_CONVERSION_1_8MS   0x2\n#define OPT4001_CTRL_CONVERSION_3_4MS   0x3\n#define OPT4001_CTRL_CONVERSION_6_5MS   0x4\n#define OPT4001_CTRL_CONVERSION_12_7MS  0x5\n#define OPT4001_CTRL_CONVERSION_25MS    0x6\n#define OPT4001_CTRL_CONVERSION_50MS    0x7\n#define OPT4001_CTRL_CONVERSION_100MS   0x8\n#define OPT4001_CTRL_CONVERSION_200MS   0x9\n#define OPT4001_CTRL_CONVERSION_400MS   0xa\n#define OPT4001_CTRL_CONVERSION_800MS   0xb\n\n \n#define OPT4001_CTRL_LIGHT_SCALE_AUTO   12\n\n \n#define OPT4001_DEFAULT_CONVERSION_TIME OPT4001_CTRL_CONVERSION_800MS\n\n \nstruct opt4001_chip_info {\n\tint mul;\n\tint div;\n\tconst char *name;\n};\n\nstruct opt4001_chip {\n\tstruct regmap *regmap;\n\tstruct i2c_client *client;\n\tu8 int_time;\n\tconst struct opt4001_chip_info *chip_info;\n};\n\nstatic const struct opt4001_chip_info opt4001_sot_5x3_info = {\n\t.mul = 4375,\n\t.div = 10000000,\n\t.name = \"opt4001-sot-5x3\"\n};\n\nstatic const struct opt4001_chip_info opt4001_picostar_info = {\n\t.mul = 3125,\n\t.div = 10000000,\n\t.name = \"opt4001-picostar\"\n};\n\nstatic const int opt4001_int_time_available[][2] = {\n\t{ 0,    600 },\n\t{ 0,   1000 },\n\t{ 0,   1800 },\n\t{ 0,   3400 },\n\t{ 0,   6500 },\n\t{ 0,  12700 },\n\t{ 0,  25000 },\n\t{ 0,  50000 },\n\t{ 0, 100000 },\n\t{ 0, 200000 },\n\t{ 0, 400000 },\n\t{ 0, 800000 },\n};\n\n \nstatic const int opt4001_int_time_reg[][2] = {\n\t{    600,  OPT4001_CTRL_CONVERSION_0_6MS  },\n\t{   1000,  OPT4001_CTRL_CONVERSION_1MS    },\n\t{   1800,  OPT4001_CTRL_CONVERSION_1_8MS  },\n\t{   3400,  OPT4001_CTRL_CONVERSION_3_4MS  },\n\t{   6500,  OPT4001_CTRL_CONVERSION_6_5MS  },\n\t{  12700,  OPT4001_CTRL_CONVERSION_12_7MS },\n\t{  25000,  OPT4001_CTRL_CONVERSION_25MS   },\n\t{  50000,  OPT4001_CTRL_CONVERSION_50MS   },\n\t{ 100000,  OPT4001_CTRL_CONVERSION_100MS  },\n\t{ 200000,  OPT4001_CTRL_CONVERSION_200MS  },\n\t{ 400000,  OPT4001_CTRL_CONVERSION_400MS  },\n\t{ 800000,  OPT4001_CTRL_CONVERSION_800MS  },\n};\n\nstatic int opt4001_als_time_to_index(const u32 als_integration_time)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(opt4001_int_time_available); i++) {\n\t\tif (als_integration_time == opt4001_int_time_available[i][1])\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u8 opt4001_calculate_crc(u8 exp, u32 mantissa, u8 count)\n{\n\tu8 crc;\n\n\tcrc = (hweight32(mantissa) + hweight32(exp) + hweight32(count)) % 2;\n\tcrc |= ((hweight32(mantissa & 0xAAAAA) + hweight32(exp & 0xA)\n\t\t + hweight32(count & 0xA)) % 2) << 1;\n\tcrc |= ((hweight32(mantissa & 0x88888) + hweight32(exp & 0x8)\n\t\t + hweight32(count & 0x8)) % 2) << 2;\n\tcrc |= (hweight32(mantissa & 0x80808) % 2) << 3;\n\n\treturn crc;\n}\n\nstatic int opt4001_read_lux_value(struct iio_dev *indio_dev,\n\t\t\t\t  int *val, int *val2)\n{\n\tstruct opt4001_chip *chip = iio_priv(indio_dev);\n\tstruct device *dev = &chip->client->dev;\n\tunsigned int light1;\n\tunsigned int light2;\n\tu16 msb;\n\tu16 lsb;\n\tu8 exp;\n\tu8 count;\n\tu8 crc;\n\tu8 calc_crc;\n\tu64 lux_raw;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, OPT4001_LIGHT1_MSB, &light1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read data bytes\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(chip->regmap, OPT4001_LIGHT1_LSB, &light2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read data bytes\");\n\t\treturn ret;\n\t}\n\n\tcount = FIELD_GET(OPT4001_COUNTER_MASK, light2);\n\texp = FIELD_GET(OPT4001_EXPONENT_MASK, light1);\n\tcrc = FIELD_GET(OPT4001_CRC_MASK, light2);\n\tmsb = FIELD_GET(OPT4001_MSB_MASK, light1);\n\tlsb = FIELD_GET(OPT4001_LSB_MASK, light2);\n\tlux_raw = (msb << 8) + lsb;\n\tcalc_crc = opt4001_calculate_crc(exp, lux_raw, count);\n\tif (calc_crc != crc)\n\t\treturn -EIO;\n\n\tlux_raw = lux_raw << exp;\n\tlux_raw = lux_raw * chip->chip_info->mul;\n\t*val = div_u64_rem(lux_raw, chip->chip_info->div, val2);\n\t*val2 = *val2 * 100;\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int opt4001_set_conf(struct opt4001_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tu16 reg;\n\tint ret;\n\n\treg = FIELD_PREP(OPT4001_CTRL_RANGE_MASK, OPT4001_CTRL_LIGHT_SCALE_AUTO);\n\treg |= FIELD_PREP(OPT4001_CTRL_CONV_TIME_MASK, chip->int_time);\n\treg |= FIELD_PREP(OPT4001_CTRL_OPER_MODE_MASK, OPT4001_CTRL_OPER_MODE_CONTINUOUS);\n\n\tret = regmap_write(chip->regmap, OPT4001_CTRL, reg);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set configuration\\n\");\n\n\treturn ret;\n}\n\nstatic int opt4001_power_down(struct opt4001_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tint ret;\n\tunsigned int reg;\n\n\tret = regmap_read(chip->regmap, OPT4001_DEVICE_ID, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read configuration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg &= ~OPT4001_CTRL_OPER_MODE_MASK;\n\n\tret = regmap_write(chip->regmap, OPT4001_CTRL, reg);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set configuration to power down\\n\");\n\n\treturn ret;\n}\n\nstatic void opt4001_chip_off_action(void *data)\n{\n\tstruct opt4001_chip *chip = data;\n\n\topt4001_power_down(chip);\n}\n\nstatic const struct iio_chan_spec opt4001_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME)\n\t},\n};\n\nstatic int opt4001_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct opt4001_chip *chip = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\treturn opt4001_read_lux_value(indio_dev, val, val2);\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = opt4001_int_time_reg[chip->int_time][0];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opt4001_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct opt4001_chip *chip = iio_priv(indio_dev);\n\tint int_time;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tint_time = opt4001_als_time_to_index(val2);\n\t\tif (int_time < 0)\n\t\t\treturn int_time;\n\t\tchip->int_time = int_time;\n\t\treturn opt4001_set_conf(chip);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opt4001_read_available(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  const int **vals, int *type, int *length,\n\t\t\t\t  long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*length = ARRAY_SIZE(opt4001_int_time_available) * 2;\n\t\t*vals = (const int *)opt4001_int_time_available;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info opt4001_info_no_irq = {\n\t.read_raw = opt4001_read_raw,\n\t.write_raw = opt4001_write_raw,\n\t.read_avail = opt4001_read_available,\n};\n\nstatic int opt4001_load_defaults(struct opt4001_chip *chip)\n{\n\tchip->int_time = OPT4001_DEFAULT_CONVERSION_TIME;\n\n\treturn opt4001_set_conf(chip);\n}\n\nstatic bool opt4001_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase OPT4001_LIGHT1_MSB:\n\tcase OPT4001_LIGHT1_LSB:\n\tcase OPT4001_CTRL:\n\tcase OPT4001_DEVICE_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool opt4001_writable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase OPT4001_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool opt4001_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase OPT4001_LIGHT1_MSB:\n\tcase OPT4001_LIGHT1_LSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config opt4001_regmap_config = {\n\t.name = \"opt4001\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = OPT4001_DEVICE_ID,\n\t.readable_reg = opt4001_readable_reg,\n\t.writeable_reg = opt4001_writable_reg,\n\t.volatile_reg = opt4001_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic int opt4001_probe(struct i2c_client *client)\n{\n\tstruct opt4001_chip *chip;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tuint dev_id;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\n\tret = devm_regulator_get_enable(&client->dev, \"vdd\");\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret, \"Failed to enable vdd supply\\n\");\n\n\tchip->regmap = devm_regmap_init_i2c(client, &opt4001_regmap_config);\n\tif (IS_ERR(chip->regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(chip->regmap),\n\t\t\t\t     \"regmap initialization failed\\n\");\n\tchip->client = client;\n\n\tindio_dev->info = &opt4001_info_no_irq;\n\n\tret = regmap_reinit_cache(chip->regmap, &opt4001_regmap_config);\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"failed to reinit regmap cache\\n\");\n\n\tret = regmap_read(chip->regmap, OPT4001_DEVICE_ID, &dev_id);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\"Failed to read the device ID register\\n\");\n\n\tdev_id = FIELD_GET(OPT4001_DEVICE_ID_MASK, dev_id);\n\tif (dev_id != OPT4001_DEVICE_ID_VAL)\n\t\tdev_warn(&client->dev, \"Device ID: %#04x unknown\\n\", dev_id);\n\n\tchip->chip_info = device_get_match_data(&client->dev);\n\n\tindio_dev->channels = opt4001_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(opt4001_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = chip->chip_info->name;\n\n\tret = opt4001_load_defaults(chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"Failed to set sensor defaults\\n\");\n\n\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\topt4001_chip_off_action,\n\t\t\t\t\tchip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"Failed to setup power off action\\n\");\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\n \nstatic const struct i2c_device_id opt4001_id[] = {\n\t{ \"opt4001-sot-5x3\", (kernel_ulong_t)&opt4001_sot_5x3_info },\n\t{ \"opt4001-picostar\", (kernel_ulong_t)&opt4001_picostar_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, opt4001_id);\n\nstatic const struct of_device_id opt4001_of_match[] = {\n\t{ .compatible = \"ti,opt4001-sot-5x3\", .data = &opt4001_sot_5x3_info},\n\t{ .compatible = \"ti,opt4001-picostar\", .data = &opt4001_picostar_info},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, opt4001_of_match);\n\nstatic struct i2c_driver opt4001_driver = {\n\t.driver = {\n\t\t.name = \"opt4001\",\n\t\t.of_match_table = opt4001_of_match,\n\t},\n\t.probe = opt4001_probe,\n\t.id_table = opt4001_id,\n};\nmodule_i2c_driver(opt4001_driver);\n\nMODULE_AUTHOR(\"Stefan Windfeldt-Prytz <stefan.windfeldt-prytz@axis.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments opt4001 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}