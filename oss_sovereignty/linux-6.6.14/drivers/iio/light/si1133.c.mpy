{
  "module_name": "si1133.c",
  "hash_id": "4fe368a544521a441dd529ff2779fc8076fdd37ff42a19a9673d7783c2a80538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/si1133.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <linux/util_macros.h>\n\n#include <asm/unaligned.h>\n\n#define SI1133_REG_PART_ID\t\t0x00\n#define SI1133_REG_REV_ID\t\t0x01\n#define SI1133_REG_MFR_ID\t\t0x02\n#define SI1133_REG_INFO0\t\t0x03\n#define SI1133_REG_INFO1\t\t0x04\n\n#define SI1133_PART_ID\t\t\t0x33\n\n#define SI1133_REG_HOSTIN0\t\t0x0A\n#define SI1133_REG_COMMAND\t\t0x0B\n#define SI1133_REG_IRQ_ENABLE\t\t0x0F\n#define SI1133_REG_RESPONSE1\t\t0x10\n#define SI1133_REG_RESPONSE0\t\t0x11\n#define SI1133_REG_IRQ_STATUS\t\t0x12\n#define SI1133_REG_MEAS_RATE\t\t0x1A\n\n#define SI1133_IRQ_CHANNEL_ENABLE\t0xF\n\n#define SI1133_CMD_RESET_CTR\t\t0x00\n#define SI1133_CMD_RESET_SW\t\t0x01\n#define SI1133_CMD_FORCE\t\t0x11\n#define SI1133_CMD_START_AUTONOMOUS\t0x13\n#define SI1133_CMD_PARAM_SET\t\t0x80\n#define SI1133_CMD_PARAM_QUERY\t\t0x40\n#define SI1133_CMD_PARAM_MASK\t\t0x3F\n\n#define SI1133_CMD_ERR_MASK\t\tBIT(4)\n#define SI1133_CMD_SEQ_MASK\t\t0xF\n#define SI1133_MAX_CMD_CTR\t\t0xF\n\n#define SI1133_PARAM_REG_CHAN_LIST\t0x01\n#define SI1133_PARAM_REG_ADCCONFIG(x)\t((x) * 4) + 2\n#define SI1133_PARAM_REG_ADCSENS(x)\t((x) * 4) + 3\n#define SI1133_PARAM_REG_ADCPOST(x)\t((x) * 4) + 4\n\n#define SI1133_ADCMUX_MASK 0x1F\n\n#define SI1133_ADCCONFIG_DECIM_RATE(x)\t(x) << 5\n\n#define SI1133_ADCSENS_SCALE_MASK 0x70\n#define SI1133_ADCSENS_SCALE_SHIFT 4\n#define SI1133_ADCSENS_HSIG_MASK BIT(7)\n#define SI1133_ADCSENS_HSIG_SHIFT 7\n#define SI1133_ADCSENS_HW_GAIN_MASK 0xF\n#define SI1133_ADCSENS_NB_MEAS(x)\tfls(x) << SI1133_ADCSENS_SCALE_SHIFT\n\n#define SI1133_ADCPOST_24BIT_EN BIT(6)\n#define SI1133_ADCPOST_POSTSHIFT_BITQTY(x) (x & GENMASK(2, 0)) << 3\n\n#define SI1133_PARAM_ADCMUX_SMALL_IR\t0x0\n#define SI1133_PARAM_ADCMUX_MED_IR\t0x1\n#define SI1133_PARAM_ADCMUX_LARGE_IR\t0x2\n#define SI1133_PARAM_ADCMUX_WHITE\t0xB\n#define SI1133_PARAM_ADCMUX_LARGE_WHITE\t0xD\n#define SI1133_PARAM_ADCMUX_UV\t\t0x18\n#define SI1133_PARAM_ADCMUX_UV_DEEP\t0x19\n\n#define SI1133_ERR_INVALID_CMD\t\t0x0\n#define SI1133_ERR_INVALID_LOCATION_CMD 0x1\n#define SI1133_ERR_SATURATION_ADC_OR_OVERFLOW_ACCUMULATION 0x2\n#define SI1133_ERR_OUTPUT_BUFFER_OVERFLOW 0x3\n\n#define SI1133_COMPLETION_TIMEOUT_MS\t500\n\n#define SI1133_CMD_MINSLEEP_US_LOW\t5000\n#define SI1133_CMD_MINSLEEP_US_HIGH\t7500\n#define SI1133_CMD_TIMEOUT_MS\t\t25\n#define SI1133_CMD_LUX_TIMEOUT_MS\t5000\n#define SI1133_CMD_TIMEOUT_US\t\tSI1133_CMD_TIMEOUT_MS * 1000\n\n#define SI1133_REG_HOSTOUT(x)\t\t(x) + 0x13\n\n#define SI1133_MEASUREMENT_FREQUENCY 1250\n\n#define SI1133_X_ORDER_MASK            0x0070\n#define SI1133_Y_ORDER_MASK            0x0007\n#define si1133_get_x_order(m)          ((m) & SI1133_X_ORDER_MASK) >> 4\n#define si1133_get_y_order(m)          ((m) & SI1133_Y_ORDER_MASK)\n\n#define SI1133_LUX_ADC_MASK\t\t0xE\n#define SI1133_ADC_THRESHOLD\t\t16000\n#define SI1133_INPUT_FRACTION_HIGH\t7\n#define SI1133_INPUT_FRACTION_LOW\t15\n#define SI1133_LUX_OUTPUT_FRACTION\t12\n#define SI1133_LUX_BUFFER_SIZE\t\t9\n#define SI1133_MEASURE_BUFFER_SIZE\t3\n\nstatic const int si1133_scale_available[] = {\n\t1, 2, 4, 8, 16, 32, 64, 128};\n\nstatic IIO_CONST_ATTR(scale_available, \"1 2 4 8 16 32 64 128\");\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.0244 0.0488 0.0975 0.195 0.390 0.780 \"\n\t\t\t\t     \"1.560 3.120 6.24 12.48 25.0 50.0\");\n\n \nenum si1133_int_time {\n\t    _24_4_us = 0,\n\t    _48_8_us = 1,\n\t    _97_5_us = 2,\n\t   _195_0_us = 3,\n\t   _390_0_us = 4,\n\t   _780_0_us = 5,\n\t _1_560_0_us = 6,\n\t _3_120_0_us = 7,\n\t _6_240_0_us = 8,\n\t_12_480_0_us = 9,\n\t_25_ms = 10,\n\t_50_ms = 11,\n};\n\n \nstatic const int si1133_int_time_table[][2] = {\n\t[_24_4_us] = {0, 24400},\n\t[_48_8_us] = {0, 48800},\n\t[_97_5_us] = {0, 97500},\n\t[_195_0_us] = {0, 195000},\n\t[_390_0_us] = {0, 390000},\n\t[_780_0_us] = {0, 780000},\n\t[_1_560_0_us] = {1, 560000},\n\t[_3_120_0_us] = {3, 120000},\n\t[_6_240_0_us] = {6, 240000},\n\t[_12_480_0_us] = {12, 480000},\n\t[_25_ms] = {25, 000000},\n\t[_50_ms] = {50, 000000},\n};\n\nstatic const struct regmap_range si1133_reg_ranges[] = {\n\tregmap_reg_range(0x00, 0x02),\n\tregmap_reg_range(0x0A, 0x0B),\n\tregmap_reg_range(0x0F, 0x0F),\n\tregmap_reg_range(0x10, 0x12),\n\tregmap_reg_range(0x13, 0x2C),\n};\n\nstatic const struct regmap_range si1133_reg_ro_ranges[] = {\n\tregmap_reg_range(0x00, 0x02),\n\tregmap_reg_range(0x10, 0x2C),\n};\n\nstatic const struct regmap_range si1133_precious_ranges[] = {\n\tregmap_reg_range(0x12, 0x12),\n};\n\nstatic const struct regmap_access_table si1133_write_ranges_table = {\n\t.yes_ranges\t= si1133_reg_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(si1133_reg_ranges),\n\t.no_ranges\t= si1133_reg_ro_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(si1133_reg_ro_ranges),\n};\n\nstatic const struct regmap_access_table si1133_read_ranges_table = {\n\t.yes_ranges\t= si1133_reg_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(si1133_reg_ranges),\n};\n\nstatic const struct regmap_access_table si1133_precious_table = {\n\t.yes_ranges\t= si1133_precious_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(si1133_precious_ranges),\n};\n\nstatic const struct regmap_config si1133_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0x2C,\n\n\t.wr_table = &si1133_write_ranges_table,\n\t.rd_table = &si1133_read_ranges_table,\n\n\t.precious_table = &si1133_precious_table,\n};\n\nstruct si1133_data {\n\tstruct regmap *regmap;\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex mutex;\n\n\tint rsp_seq;\n\tu8 scan_mask;\n\tu8 adc_sens[6];\n\tu8 adc_config[6];\n\n\tstruct completion completion;\n};\n\nstruct si1133_coeff {\n\ts16 info;\n\tu16 mag;\n};\n\nstruct si1133_lux_coeff {\n\tstruct si1133_coeff coeff_high[4];\n\tstruct si1133_coeff coeff_low[9];\n};\n\nstatic const struct si1133_lux_coeff lux_coeff = {\n\t{\n\t\t{  0,   209},\n\t\t{ 1665,  93},\n\t\t{ 2064,  65},\n\t\t{-2671, 234}\n\t},\n\t{\n\t\t{    0,     0},\n\t\t{ 1921, 29053},\n\t\t{-1022, 36363},\n\t\t{ 2320, 20789},\n\t\t{ -367, 57909},\n\t\t{-1774, 38240},\n\t\t{ -608, 46775},\n\t\t{-1503, 51831},\n\t\t{-1886, 58928}\n\t}\n};\n\nstatic int si1133_calculate_polynomial_inner(s32 input, u8 fraction, u16 mag,\n\t\t\t\t\t     s8 shift)\n{\n\treturn ((input << fraction) / mag) << shift;\n}\n\nstatic int si1133_calculate_output(s32 x, s32 y, u8 x_order, u8 y_order,\n\t\t\t\t   u8 input_fraction, s8 sign,\n\t\t\t\t   const struct si1133_coeff *coeffs)\n{\n\ts8 shift;\n\tint x1 = 1;\n\tint x2 = 1;\n\tint y1 = 1;\n\tint y2 = 1;\n\n\tshift = ((u16)coeffs->info & 0xFF00) >> 8;\n\tshift ^= 0xFF;\n\tshift += 1;\n\tshift = -shift;\n\n\tif (x_order > 0) {\n\t\tx1 = si1133_calculate_polynomial_inner(x, input_fraction,\n\t\t\t\t\t\t       coeffs->mag, shift);\n\t\tif (x_order > 1)\n\t\t\tx2 = x1;\n\t}\n\n\tif (y_order > 0) {\n\t\ty1 = si1133_calculate_polynomial_inner(y, input_fraction,\n\t\t\t\t\t\t       coeffs->mag, shift);\n\t\tif (y_order > 1)\n\t\t\ty2 = y1;\n\t}\n\n\treturn sign * x1 * x2 * y1 * y2;\n}\n\n \nstatic int si1133_calc_polynomial(s32 x, s32 y, u8 input_fraction, u8 num_coeff,\n\t\t\t\t  const struct si1133_coeff *coeffs)\n{\n\tu8 x_order, y_order;\n\tu8 counter;\n\ts8 sign;\n\tint output = 0;\n\n\tfor (counter = 0; counter < num_coeff; counter++) {\n\t\tif (coeffs->info < 0)\n\t\t\tsign = -1;\n\t\telse\n\t\t\tsign = 1;\n\n\t\tx_order = si1133_get_x_order(coeffs->info);\n\t\ty_order = si1133_get_y_order(coeffs->info);\n\n\t\tif ((x_order == 0) && (y_order == 0))\n\t\t\toutput +=\n\t\t\t       sign * coeffs->mag << SI1133_LUX_OUTPUT_FRACTION;\n\t\telse\n\t\t\toutput += si1133_calculate_output(x, y, x_order,\n\t\t\t\t\t\t\t  y_order,\n\t\t\t\t\t\t\t  input_fraction, sign,\n\t\t\t\t\t\t\t  coeffs);\n\t\tcoeffs++;\n\t}\n\n\treturn abs(output);\n}\n\nstatic int si1133_cmd_reset_sw(struct si1133_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tunsigned int resp;\n\tunsigned long timeout;\n\tint err;\n\n\terr = regmap_write(data->regmap, SI1133_REG_COMMAND,\n\t\t\t   SI1133_CMD_RESET_SW);\n\tif (err)\n\t\treturn err;\n\n\ttimeout = jiffies + msecs_to_jiffies(SI1133_CMD_TIMEOUT_MS);\n\twhile (true) {\n\t\terr = regmap_read(data->regmap, SI1133_REG_RESPONSE0, &resp);\n\t\tif (err == -ENXIO) {\n\t\t\tusleep_range(SI1133_CMD_MINSLEEP_US_LOW,\n\t\t\t\t     SI1133_CMD_MINSLEEP_US_HIGH);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((resp & SI1133_MAX_CMD_CTR) == SI1133_MAX_CMD_CTR)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(dev, \"Timeout on reset ctr resp: %d\\n\", resp);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tif (!err)\n\t\tdata->rsp_seq = SI1133_MAX_CMD_CTR;\n\n\treturn err;\n}\n\nstatic int si1133_parse_response_err(struct device *dev, u32 resp, u8 cmd)\n{\n\tresp &= 0xF;\n\n\tswitch (resp) {\n\tcase SI1133_ERR_OUTPUT_BUFFER_OVERFLOW:\n\t\tdev_warn(dev, \"Output buffer overflow: 0x%02x\\n\", cmd);\n\t\treturn -EOVERFLOW;\n\tcase SI1133_ERR_SATURATION_ADC_OR_OVERFLOW_ACCUMULATION:\n\t\tdev_warn(dev, \"Saturation of the ADC or overflow of accumulation: 0x%02x\\n\",\n\t\t\t cmd);\n\t\treturn -EOVERFLOW;\n\tcase SI1133_ERR_INVALID_LOCATION_CMD:\n\t\tdev_warn(dev,\n\t\t\t \"Parameter access to an invalid location: 0x%02x\\n\",\n\t\t\t cmd);\n\t\treturn -EINVAL;\n\tcase SI1133_ERR_INVALID_CMD:\n\t\tdev_warn(dev, \"Invalid command 0x%02x\\n\", cmd);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown error 0x%02x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si1133_cmd_reset_counter(struct si1133_data *data)\n{\n\tint err = regmap_write(data->regmap, SI1133_REG_COMMAND,\n\t\t\t       SI1133_CMD_RESET_CTR);\n\tif (err)\n\t\treturn err;\n\n\tdata->rsp_seq = 0;\n\n\treturn 0;\n}\n\nstatic int si1133_command(struct si1133_data *data, u8 cmd)\n{\n\tstruct device *dev = &data->client->dev;\n\tu32 resp;\n\tint err;\n\tint expected_seq;\n\n\tmutex_lock(&data->mutex);\n\n\texpected_seq = (data->rsp_seq + 1) & SI1133_MAX_CMD_CTR;\n\n\tif (cmd == SI1133_CMD_FORCE)\n\t\treinit_completion(&data->completion);\n\n\terr = regmap_write(data->regmap, SI1133_REG_COMMAND, cmd);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to write command 0x%02x, ret=%d\\n\", cmd,\n\t\t\t err);\n\t\tgoto out;\n\t}\n\n\tif (cmd == SI1133_CMD_FORCE) {\n\t\t \n\t\tif (!wait_for_completion_timeout(&data->completion,\n\t\t\tmsecs_to_jiffies(SI1133_COMPLETION_TIMEOUT_MS))) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = regmap_read(data->regmap, SI1133_REG_RESPONSE0, &resp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\terr = regmap_read_poll_timeout(data->regmap,\n\t\t\t\t\t       SI1133_REG_RESPONSE0, resp,\n\t\t\t\t\t       (resp & SI1133_CMD_SEQ_MASK) ==\n\t\t\t\t\t       expected_seq ||\n\t\t\t\t\t       (resp & SI1133_CMD_ERR_MASK),\n\t\t\t\t\t       SI1133_CMD_MINSLEEP_US_LOW,\n\t\t\t\t\t       SI1133_CMD_TIMEOUT_MS * 1000);\n\t\tif (err) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Failed to read command 0x%02x, ret=%d\\n\",\n\t\t\t\t cmd, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (resp & SI1133_CMD_ERR_MASK) {\n\t\terr = si1133_parse_response_err(dev, resp, cmd);\n\t\tsi1133_cmd_reset_counter(data);\n\t} else {\n\t\tdata->rsp_seq = expected_seq;\n\t}\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn err;\n}\n\nstatic int si1133_param_set(struct si1133_data *data, u8 param, u32 value)\n{\n\tint err = regmap_write(data->regmap, SI1133_REG_HOSTIN0, value);\n\n\tif (err)\n\t\treturn err;\n\n\treturn si1133_command(data, SI1133_CMD_PARAM_SET |\n\t\t\t      (param & SI1133_CMD_PARAM_MASK));\n}\n\nstatic int si1133_param_query(struct si1133_data *data, u8 param, u32 *result)\n{\n\tint err = si1133_command(data, SI1133_CMD_PARAM_QUERY |\n\t\t\t\t (param & SI1133_CMD_PARAM_MASK));\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_read(data->regmap, SI1133_REG_RESPONSE1, result);\n}\n\n#define SI1133_CHANNEL(_ch, _type) \\\n\t.type = _type, \\\n\t.channel = _ch, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN), \\\n\nstatic const struct iio_chan_spec si1133_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.channel = 0,\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_WHITE, IIO_INTENSITY)\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_LARGE_WHITE, IIO_INTENSITY)\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.extend_name = \"large\",\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_SMALL_IR, IIO_INTENSITY)\n\t\t.extend_name = \"small\",\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_MED_IR, IIO_INTENSITY)\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_LARGE_IR, IIO_INTENSITY)\n\t\t.extend_name = \"large\",\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_UV, IIO_UVINDEX)\n\t},\n\t{\n\t\tSI1133_CHANNEL(SI1133_PARAM_ADCMUX_UV_DEEP, IIO_UVINDEX)\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_DUV,\n\t}\n};\n\nstatic int si1133_get_int_time_index(int milliseconds, int nanoseconds)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(si1133_int_time_table); i++) {\n\t\tif (milliseconds == si1133_int_time_table[i][0] &&\n\t\t    nanoseconds == si1133_int_time_table[i][1])\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int si1133_set_integration_time(struct si1133_data *data, u8 adc,\n\t\t\t\t       int milliseconds, int nanoseconds)\n{\n\tint index;\n\n\tindex = si1133_get_int_time_index(milliseconds, nanoseconds);\n\tif (index < 0)\n\t\treturn index;\n\n\tdata->adc_sens[adc] &= 0xF0;\n\tdata->adc_sens[adc] |= index;\n\n\treturn si1133_param_set(data, SI1133_PARAM_REG_ADCSENS(0),\n\t\t\t\tdata->adc_sens[adc]);\n}\n\nstatic int si1133_set_chlist(struct si1133_data *data, u8 scan_mask)\n{\n\t \n\tif (data->scan_mask == scan_mask)\n\t\treturn 0;\n\n\tdata->scan_mask = scan_mask;\n\n\treturn si1133_param_set(data, SI1133_PARAM_REG_CHAN_LIST, scan_mask);\n}\n\nstatic int si1133_chan_set_adcconfig(struct si1133_data *data, u8 adc,\n\t\t\t\t     u8 adc_config)\n{\n\tint err;\n\n\terr = si1133_param_set(data, SI1133_PARAM_REG_ADCCONFIG(adc),\n\t\t\t       adc_config);\n\tif (err)\n\t\treturn err;\n\n\tdata->adc_config[adc] = adc_config;\n\n\treturn 0;\n}\n\nstatic int si1133_update_adcconfig(struct si1133_data *data, uint8_t adc,\n\t\t\t\t   u8 mask, u8 shift, u8 value)\n{\n\tu32 adc_config;\n\tint err;\n\n\terr = si1133_param_query(data, SI1133_PARAM_REG_ADCCONFIG(adc),\n\t\t\t\t &adc_config);\n\tif (err)\n\t\treturn err;\n\n\tadc_config &= ~mask;\n\tadc_config |= (value << shift);\n\n\treturn si1133_chan_set_adcconfig(data, adc, adc_config);\n}\n\nstatic int si1133_set_adcmux(struct si1133_data *data, u8 adc, u8 mux)\n{\n\tif ((mux & data->adc_config[adc]) == mux)\n\t\treturn 0;  \n\n\treturn si1133_update_adcconfig(data, adc, SI1133_ADCMUX_MASK, 0, mux);\n}\n\nstatic int si1133_force_measurement(struct si1133_data *data)\n{\n\treturn si1133_command(data, SI1133_CMD_FORCE);\n}\n\nstatic int si1133_bulk_read(struct si1133_data *data, u8 start_reg, u8 length,\n\t\t\t    u8 *buffer)\n{\n\tint err;\n\n\terr = si1133_force_measurement(data);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_bulk_read(data->regmap, start_reg, buffer, length);\n}\n\nstatic int si1133_measure(struct si1133_data *data,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val)\n{\n\tint err;\n\n\tu8 buffer[SI1133_MEASURE_BUFFER_SIZE];\n\n\terr = si1133_set_adcmux(data, 0, chan->channel);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = si1133_set_chlist(data, BIT(0));\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_bulk_read(data, SI1133_REG_HOSTOUT(0), sizeof(buffer),\n\t\t\t       buffer);\n\tif (err)\n\t\treturn err;\n\n\t*val = sign_extend32(get_unaligned_be24(&buffer[0]), 23);\n\n\treturn err;\n}\n\nstatic irqreturn_t si1133_threaded_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *iio_dev = private;\n\tstruct si1133_data *data = iio_priv(iio_dev);\n\tu32 irq_status;\n\tint err;\n\n\terr = regmap_read(data->regmap, SI1133_REG_IRQ_STATUS, &irq_status);\n\tif (err) {\n\t\tdev_err_ratelimited(&iio_dev->dev, \"Error reading IRQ\\n\");\n\t\tgoto out;\n\t}\n\n\tif (irq_status != data->scan_mask)\n\t\treturn IRQ_NONE;\n\nout:\n\tcomplete(&data->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int si1133_scale_to_swgain(int scale_integer, int scale_fractional)\n{\n\tscale_integer = find_closest(scale_integer, si1133_scale_available,\n\t\t\t\t     ARRAY_SIZE(si1133_scale_available));\n\tif (scale_integer < 0 ||\n\t    scale_integer > ARRAY_SIZE(si1133_scale_available) ||\n\t    scale_fractional != 0)\n\t\treturn -EINVAL;\n\n\treturn scale_integer;\n}\n\nstatic int si1133_chan_set_adcsens(struct si1133_data *data, u8 adc,\n\t\t\t\t   u8 adc_sens)\n{\n\tint err;\n\n\terr = si1133_param_set(data, SI1133_PARAM_REG_ADCSENS(adc), adc_sens);\n\tif (err)\n\t\treturn err;\n\n\tdata->adc_sens[adc] = adc_sens;\n\n\treturn 0;\n}\n\nstatic int si1133_update_adcsens(struct si1133_data *data, u8 mask,\n\t\t\t\t u8 shift, u8 value)\n{\n\tint err;\n\tu32 adc_sens;\n\n\terr = si1133_param_query(data, SI1133_PARAM_REG_ADCSENS(0),\n\t\t\t\t &adc_sens);\n\tif (err)\n\t\treturn err;\n\n\tadc_sens &= ~mask;\n\tadc_sens |= (value << shift);\n\n\treturn si1133_chan_set_adcsens(data, 0, adc_sens);\n}\n\nstatic int si1133_get_lux(struct si1133_data *data, int *val)\n{\n\tint err;\n\tint lux;\n\ts32 high_vis;\n\ts32 low_vis;\n\ts32 ir;\n\tu8 buffer[SI1133_LUX_BUFFER_SIZE];\n\n\t \n\terr = si1133_set_chlist(data, SI1133_LUX_ADC_MASK);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_bulk_read(data, SI1133_REG_HOSTOUT(0),\n\t\t\t       SI1133_LUX_BUFFER_SIZE, buffer);\n\tif (err)\n\t\treturn err;\n\n\thigh_vis = sign_extend32(get_unaligned_be24(&buffer[0]), 23);\n\n\tlow_vis = sign_extend32(get_unaligned_be24(&buffer[3]), 23);\n\n\tir = sign_extend32(get_unaligned_be24(&buffer[6]), 23);\n\n\tif (high_vis > SI1133_ADC_THRESHOLD || ir > SI1133_ADC_THRESHOLD)\n\t\tlux = si1133_calc_polynomial(high_vis, ir,\n\t\t\t\t\t     SI1133_INPUT_FRACTION_HIGH,\n\t\t\t\t\t     ARRAY_SIZE(lux_coeff.coeff_high),\n\t\t\t\t\t     &lux_coeff.coeff_high[0]);\n\telse\n\t\tlux = si1133_calc_polynomial(low_vis, ir,\n\t\t\t\t\t     SI1133_INPUT_FRACTION_LOW,\n\t\t\t\t\t     ARRAY_SIZE(lux_coeff.coeff_low),\n\t\t\t\t\t     &lux_coeff.coeff_low[0]);\n\n\t*val = lux >> SI1133_LUX_OUTPUT_FRACTION;\n\n\treturn err;\n}\n\nstatic int si1133_read_raw(struct iio_dev *iio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct si1133_data *data = iio_priv(iio_dev);\n\tu8 adc_sens = data->adc_sens[0];\n\tint err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\terr = si1133_get_lux(data, val);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\terr = si1133_measure(data, chan, val);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\tadc_sens &= SI1133_ADCSENS_HW_GAIN_MASK;\n\n\t\t\t*val = si1133_int_time_table[adc_sens][0];\n\t\t\t*val2 = si1133_int_time_table[adc_sens][1];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\tadc_sens &= SI1133_ADCSENS_SCALE_MASK;\n\t\t\tadc_sens >>= SI1133_ADCSENS_SCALE_SHIFT;\n\n\t\t\t*val = BIT(adc_sens);\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\tadc_sens >>= SI1133_ADCSENS_HSIG_SHIFT;\n\n\t\t\t*val = adc_sens;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si1133_write_raw(struct iio_dev *iio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct si1133_data *data = iio_priv(iio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\tval = si1133_scale_to_swgain(val, val2);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\n\t\t\treturn si1133_update_adcsens(data,\n\t\t\t\t\t\t     SI1133_ADCSENS_SCALE_MASK,\n\t\t\t\t\t\t     SI1133_ADCSENS_SCALE_SHIFT,\n\t\t\t\t\t\t     val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn si1133_set_integration_time(data, 0, val, val2);\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\tcase IIO_UVINDEX:\n\t\t\tif (val != 0 && val != 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn si1133_update_adcsens(data,\n\t\t\t\t\t\t     SI1133_ADCSENS_HSIG_MASK,\n\t\t\t\t\t\t     SI1133_ADCSENS_HSIG_SHIFT,\n\t\t\t\t\t\t     val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct attribute *si1133_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group si1133_attribute_group = {\n\t.attrs = si1133_attributes,\n};\n\nstatic const struct iio_info si1133_info = {\n\t.read_raw = si1133_read_raw,\n\t.write_raw = si1133_write_raw,\n\t.attrs = &si1133_attribute_group,\n};\n\n \nstatic int si1133_init_lux_channels(struct si1133_data *data)\n{\n\tint err;\n\n\terr = si1133_chan_set_adcconfig(data, 1,\n\t\t\t\t\tSI1133_ADCCONFIG_DECIM_RATE(1) |\n\t\t\t\t\tSI1133_PARAM_ADCMUX_LARGE_WHITE);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_param_set(data, SI1133_PARAM_REG_ADCPOST(1),\n\t\t\t       SI1133_ADCPOST_24BIT_EN |\n\t\t\t       SI1133_ADCPOST_POSTSHIFT_BITQTY(0));\n\tif (err)\n\t\treturn err;\n\terr = si1133_chan_set_adcsens(data, 1, SI1133_ADCSENS_HSIG_MASK |\n\t\t\t\t      SI1133_ADCSENS_NB_MEAS(64) | _48_8_us);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_chan_set_adcconfig(data, 2,\n\t\t\t\t\tSI1133_ADCCONFIG_DECIM_RATE(1) |\n\t\t\t\t\tSI1133_PARAM_ADCMUX_LARGE_WHITE);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_param_set(data, SI1133_PARAM_REG_ADCPOST(2),\n\t\t\t       SI1133_ADCPOST_24BIT_EN |\n\t\t\t       SI1133_ADCPOST_POSTSHIFT_BITQTY(2));\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_chan_set_adcsens(data, 2, SI1133_ADCSENS_HSIG_MASK |\n\t\t\t\t      SI1133_ADCSENS_NB_MEAS(1) | _3_120_0_us);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_chan_set_adcconfig(data, 3,\n\t\t\t\t\tSI1133_ADCCONFIG_DECIM_RATE(1) |\n\t\t\t\t\tSI1133_PARAM_ADCMUX_MED_IR);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_param_set(data, SI1133_PARAM_REG_ADCPOST(3),\n\t\t\t       SI1133_ADCPOST_24BIT_EN |\n\t\t\t       SI1133_ADCPOST_POSTSHIFT_BITQTY(2));\n\tif (err)\n\t\treturn err;\n\n\treturn  si1133_chan_set_adcsens(data, 3, SI1133_ADCSENS_HSIG_MASK |\n\t\t\t\t\tSI1133_ADCSENS_NB_MEAS(64) | _48_8_us);\n}\n\nstatic int si1133_initialize(struct si1133_data *data)\n{\n\tint err;\n\n\terr = si1133_cmd_reset_sw(data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = si1133_param_set(data, SI1133_REG_MEAS_RATE, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_init_lux_channels(data);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_write(data->regmap, SI1133_REG_IRQ_ENABLE,\n\t\t\t    SI1133_IRQ_CHANNEL_ENABLE);\n}\n\nstatic int si1133_validate_ids(struct iio_dev *iio_dev)\n{\n\tstruct si1133_data *data = iio_priv(iio_dev);\n\n\tunsigned int part_id, rev_id, mfr_id;\n\tint err;\n\n\terr = regmap_read(data->regmap, SI1133_REG_PART_ID, &part_id);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(data->regmap, SI1133_REG_REV_ID, &rev_id);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(data->regmap, SI1133_REG_MFR_ID, &mfr_id);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&iio_dev->dev,\n\t\t \"Device ID part 0x%02x rev 0x%02x mfr 0x%02x\\n\",\n\t\t part_id, rev_id, mfr_id);\n\tif (part_id != SI1133_PART_ID) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Part ID mismatch got 0x%02x, expected 0x%02x\\n\",\n\t\t\tpart_id, SI1133_PART_ID);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int si1133_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct si1133_data *data;\n\tstruct iio_dev *iio_dev;\n\tint err;\n\n\tiio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(iio_dev);\n\n\tinit_completion(&data->completion);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &si1133_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\terr = PTR_ERR(data->regmap);\n\t\tdev_err(&client->dev, \"Failed to initialise regmap: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, iio_dev);\n\tdata->client = client;\n\n\tiio_dev->name = id->name;\n\tiio_dev->channels = si1133_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(si1133_channels);\n\tiio_dev->info = &si1133_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\n\tmutex_init(&data->mutex);\n\n\terr = si1133_validate_ids(iio_dev);\n\tif (err)\n\t\treturn err;\n\n\terr = si1133_initialize(data);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Error when initializing chip: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Required interrupt not provided, cannot proceed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL,\n\t\t\t\t\tsi1133_threaded_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\tclient->name, iio_dev);\n\tif (err) {\n\t\tdev_warn(&client->dev, \"Request irq %d failed: %i\\n\",\n\t\t\t client->irq, err);\n\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, iio_dev);\n}\n\nstatic const struct i2c_device_id si1133_ids[] = {\n\t{ \"si1133\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si1133_ids);\n\nstatic struct i2c_driver si1133_driver = {\n\t.driver = {\n\t    .name   = \"si1133\",\n\t},\n\t.probe = si1133_probe,\n\t.id_table = si1133_ids,\n};\n\nmodule_i2c_driver(si1133_driver);\n\nMODULE_AUTHOR(\"Maxime Roussin-Belanger <maxime.roussinbelanger@gmail.com>\");\nMODULE_DESCRIPTION(\"Silabs SI1133, UV index sensor and ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}