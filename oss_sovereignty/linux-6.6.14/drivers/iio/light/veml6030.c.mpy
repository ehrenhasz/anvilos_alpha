{
  "module_name": "veml6030.c",
  "hash_id": "0ab21f6c64f93f65f943e7b99200e1690094611910f5c8a11948b31f03d7a32d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/veml6030.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n \n#define VEML6030_REG_ALS_CONF   0x00\n#define VEML6030_REG_ALS_WH     0x01\n#define VEML6030_REG_ALS_WL     0x02\n#define VEML6030_REG_ALS_PSM    0x03\n#define VEML6030_REG_ALS_DATA   0x04\n#define VEML6030_REG_WH_DATA    0x05\n#define VEML6030_REG_ALS_INT    0x06\n\n \n#define VEML6030_ALS_IT       GENMASK(9, 6)\n#define VEML6030_PSM          GENMASK(2, 1)\n#define VEML6030_ALS_PERS     GENMASK(5, 4)\n#define VEML6030_ALS_GAIN     GENMASK(12, 11)\n#define VEML6030_PSM_EN       BIT(0)\n#define VEML6030_INT_TH_LOW   BIT(15)\n#define VEML6030_INT_TH_HIGH  BIT(14)\n#define VEML6030_ALS_INT_EN   BIT(1)\n#define VEML6030_ALS_SD       BIT(0)\n\n \nstruct veml6030_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tint cur_resolution;\n\tint cur_gain;\n\tint cur_integration_time;\n};\n\n \nstatic IIO_CONST_ATTR(in_illuminance_integration_time_available,\n\t\t\t\t\"0.025 0.05 0.1 0.2 0.4 0.8\");\n\n \nstatic IIO_CONST_ATTR(in_illuminance_scale_available,\n\t\t\t\t\"0.125 0.25 1.0 2.0\");\n\nstatic struct attribute *veml6030_attributes[] = {\n\t&iio_const_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group veml6030_attr_group = {\n\t.attrs = veml6030_attributes,\n};\n\n \nstatic const char * const period_values[] = {\n\t\t\"0.1 0.2 0.4 0.8\",\n\t\t\"0.2 0.4 0.8 1.6\",\n\t\t\"0.4 0.8 1.6 3.2\",\n\t\t\"0.8 1.6 3.2 6.4\",\n\t\t\"0.05 0.1 0.2 0.4\",\n\t\t\"0.025 0.050 0.1 0.2\"\n};\n\n \nstatic ssize_t in_illuminance_period_available_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint ret, reg, x;\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_CONF, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als conf register %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ((reg >> 6) & 0xF);\n\tswitch (ret) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tx = ret;\n\t\tbreak;\n\tcase 8:\n\t\tx = 4;\n\t\tbreak;\n\tcase 12:\n\t\tx = 5;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", period_values[x]);\n}\n\nstatic IIO_DEVICE_ATTR_RO(in_illuminance_period_available, 0);\n\nstatic struct attribute *veml6030_event_attributes[] = {\n\t&iio_dev_attr_in_illuminance_period_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group veml6030_event_attr_group = {\n\t.attrs = veml6030_event_attributes,\n};\n\nstatic int veml6030_als_pwr_on(struct veml6030_data *data)\n{\n\treturn regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\t\t VEML6030_ALS_SD, 0);\n}\n\nstatic int veml6030_als_shut_down(struct veml6030_data *data)\n{\n\treturn regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\t\t VEML6030_ALS_SD, 1);\n}\n\nstatic void veml6030_als_shut_down_action(void *data)\n{\n\tveml6030_als_shut_down(data);\n}\n\nstatic const struct iio_event_spec veml6030_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_PERIOD) |\n\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n \nenum veml6030_chan {\n\tCH_ALS,\n\tCH_WHITE,\n};\n\nstatic const struct iio_chan_spec veml6030_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.channel = CH_ALS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.event_spec = veml6030_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(veml6030_event_spec),\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.channel = CH_WHITE,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n};\n\nstatic const struct regmap_config veml6030_regmap_config = {\n\t.name = \"veml6030_regmap\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = VEML6030_REG_ALS_INT,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic int veml6030_get_intgrn_tm(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint *val, int *val2)\n{\n\tint ret, reg;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_CONF, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als conf register %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch ((reg >> 6) & 0xF) {\n\tcase 0:\n\t\t*val2 = 100000;\n\t\tbreak;\n\tcase 1:\n\t\t*val2 = 200000;\n\t\tbreak;\n\tcase 2:\n\t\t*val2 = 400000;\n\t\tbreak;\n\tcase 3:\n\t\t*val2 = 800000;\n\t\tbreak;\n\tcase 8:\n\t\t*val2 = 50000;\n\t\tbreak;\n\tcase 12:\n\t\t*val2 = 25000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val = 0;\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int veml6030_set_intgrn_tm(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint val, int val2)\n{\n\tint ret, new_int_time, int_idx;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tswitch (val2) {\n\tcase 25000:\n\t\tnew_int_time = 0x300;\n\t\tint_idx = 5;\n\t\tbreak;\n\tcase 50000:\n\t\tnew_int_time = 0x200;\n\t\tint_idx = 4;\n\t\tbreak;\n\tcase 100000:\n\t\tnew_int_time = 0x00;\n\t\tint_idx = 3;\n\t\tbreak;\n\tcase 200000:\n\t\tnew_int_time = 0x40;\n\t\tint_idx = 2;\n\t\tbreak;\n\tcase 400000:\n\t\tnew_int_time = 0x80;\n\t\tint_idx = 1;\n\t\tbreak;\n\tcase 800000:\n\t\tnew_int_time = 0xC0;\n\t\tint_idx = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\t\t\tVEML6030_ALS_IT, new_int_time);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't update als integration time %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (data->cur_integration_time < int_idx)\n\t\tdata->cur_resolution <<= int_idx - data->cur_integration_time;\n\telse if (data->cur_integration_time > int_idx)\n\t\tdata->cur_resolution >>= data->cur_integration_time - int_idx;\n\n\tdata->cur_integration_time = int_idx;\n\n\treturn ret;\n}\n\nstatic int veml6030_read_persistence(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint *val, int *val2)\n{\n\tint ret, reg, period, x, y;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = veml6030_get_intgrn_tm(indio_dev, &x, &y);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_CONF, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als conf register %d\\n\", ret);\n\t}\n\n\t \n\tperiod = y * (1 << ((reg >> 4) & 0x03));\n\n\t*val = period / 1000000;\n\t*val2 = period % 1000000;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int veml6030_write_persistence(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint val, int val2)\n{\n\tint ret, period, x, y;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = veml6030_get_intgrn_tm(indio_dev, &x, &y);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!val) {\n\t\tperiod = val2 / y;\n\t} else {\n\t\tif ((val == 1) && (val2 == 600000))\n\t\t\tperiod = 1600000 / y;\n\t\telse if ((val == 3) && (val2 == 200000))\n\t\t\tperiod = 3200000 / y;\n\t\telse if ((val == 6) && (val2 == 400000))\n\t\t\tperiod = 6400000 / y;\n\t\telse\n\t\t\tperiod = -1;\n\t}\n\n\tif (period <= 0 || period > 8 || hweight8(period) != 1)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\t\tVEML6030_ALS_PERS, (ffs(period) - 1) << 4);\n\tif (ret)\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't set persistence value %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int veml6030_set_als_gain(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint val, int val2)\n{\n\tint ret, new_gain, gain_idx;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tif (val == 0 && val2 == 125000) {\n\t\tnew_gain = 0x1000;  \n\t\tgain_idx = 3;\n\t} else if (val == 0 && val2 == 250000) {\n\t\tnew_gain = 0x1800;\n\t\tgain_idx = 2;\n\t} else if (val == 1 && val2 == 0) {\n\t\tnew_gain = 0x00;\n\t\tgain_idx = 1;\n\t} else if (val == 2 && val2 == 0) {\n\t\tnew_gain = 0x800;\n\t\tgain_idx = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\t\t\tVEML6030_ALS_GAIN, new_gain);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't set als gain %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (data->cur_gain < gain_idx)\n\t\tdata->cur_resolution <<= gain_idx - data->cur_gain;\n\telse if (data->cur_gain > gain_idx)\n\t\tdata->cur_resolution >>= data->cur_gain - gain_idx;\n\n\tdata->cur_gain = gain_idx;\n\n\treturn ret;\n}\n\nstatic int veml6030_get_als_gain(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint *val, int *val2)\n{\n\tint ret, reg;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_CONF, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als conf register %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch ((reg >> 11) & 0x03) {\n\tcase 0:\n\t\t*val = 1;\n\t\t*val2 = 0;\n\t\tbreak;\n\tcase 1:\n\t\t*val = 2;\n\t\t*val2 = 0;\n\t\tbreak;\n\tcase 2:\n\t\t*val = 0;\n\t\t*val2 = 125000;\n\t\tbreak;\n\tcase 3:\n\t\t*val = 0;\n\t\t*val2 = 250000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int veml6030_read_thresh(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint *val, int *val2, int dir)\n{\n\tint ret, reg;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tif (dir == IIO_EV_DIR_RISING)\n\t\tret = regmap_read(data->regmap, VEML6030_REG_ALS_WH, &reg);\n\telse\n\t\tret = regmap_read(data->regmap, VEML6030_REG_ALS_WL, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als threshold value %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = reg & 0xffff;\n\treturn IIO_VAL_INT;\n}\n\nstatic int veml6030_write_thresh(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint val, int val2, int dir)\n{\n\tint ret;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tif (val > 0xFFFF || val < 0 || val2)\n\t\treturn -EINVAL;\n\n\tif (dir == IIO_EV_DIR_RISING) {\n\t\tret = regmap_write(data->regmap, VEML6030_REG_ALS_WH, val);\n\t\tif (ret)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\t\"can't set high threshold %d\\n\", ret);\n\t} else {\n\t\tret = regmap_write(data->regmap, VEML6030_REG_ALS_WL, val);\n\t\tif (ret)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\t\"can't set low threshold %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int veml6030_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tint ret, reg;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\tstruct regmap *regmap = data->regmap;\n\tstruct device *dev = &data->client->dev;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = regmap_read(regmap, VEML6030_REG_ALS_DATA, &reg);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"can't read als data %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (mask == IIO_CHAN_INFO_PROCESSED) {\n\t\t\t\t*val = (reg * data->cur_resolution) / 10000;\n\t\t\t\t*val2 = (reg * data->cur_resolution) % 10000;\n\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\t}\n\t\t\t*val = reg;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_INTENSITY:\n\t\t\tret = regmap_read(regmap, VEML6030_REG_WH_DATA, &reg);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"can't read white data %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (mask == IIO_CHAN_INFO_PROCESSED) {\n\t\t\t\t*val = (reg * data->cur_resolution) / 10000;\n\t\t\t\t*val2 = (reg * data->cur_resolution) % 10000;\n\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\t}\n\t\t\t*val = reg;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\treturn veml6030_get_intgrn_tm(indio_dev, val, val2);\n\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\treturn veml6030_get_als_gain(indio_dev, val, val2);\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int veml6030_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\treturn veml6030_set_intgrn_tm(indio_dev, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\treturn veml6030_set_als_gain(indio_dev, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int veml6030_read_event_val(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint *val, int *val2)\n{\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn veml6030_read_thresh(indio_dev, val, val2, dir);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\treturn veml6030_read_persistence(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int veml6030_write_event_val(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint val, int val2)\n{\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\treturn veml6030_write_thresh(indio_dev, val, val2, dir);\n\tcase IIO_EV_INFO_PERIOD:\n\t\treturn veml6030_write_persistence(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int veml6030_read_interrupt_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir)\n{\n\tint ret, reg;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_CONF, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als conf register %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (reg & VEML6030_ALS_INT_EN)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int veml6030_write_interrupt_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, int state)\n{\n\tint ret;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tif (state < 0 || state > 1)\n\t\treturn -EINVAL;\n\n\tret = veml6030_als_shut_down(data);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"can't disable als to configure interrupt %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, VEML6030_REG_ALS_CONF,\n\t\t\tVEML6030_ALS_INT_EN | VEML6030_ALS_SD, state << 1);\n\tif (ret)\n\t\tdev_err(&data->client->dev,\n\t\t\t\"can't enable interrupt & poweron als %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct iio_info veml6030_info = {\n\t.read_raw  = veml6030_read_raw,\n\t.write_raw = veml6030_write_raw,\n\t.read_event_value = veml6030_read_event_val,\n\t.write_event_value\t= veml6030_write_event_val,\n\t.read_event_config = veml6030_read_interrupt_config,\n\t.write_event_config\t= veml6030_write_interrupt_config,\n\t.attrs = &veml6030_attr_group,\n\t.event_attrs = &veml6030_event_attr_group,\n};\n\nstatic const struct iio_info veml6030_info_no_irq = {\n\t.read_raw  = veml6030_read_raw,\n\t.write_raw = veml6030_write_raw,\n\t.attrs = &veml6030_attr_group,\n};\n\nstatic irqreturn_t veml6030_event_handler(int irq, void *private)\n{\n\tint ret, reg, evtdir;\n\tstruct iio_dev *indio_dev = private;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_INT, &reg);\n\tif (ret) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\t\"can't read als interrupt register %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (!(reg & (VEML6030_INT_TH_HIGH | VEML6030_INT_TH_LOW)))\n\t\treturn IRQ_NONE;\n\n\tif (reg & VEML6030_INT_TH_HIGH)\n\t\tevtdir = IIO_EV_DIR_RISING;\n\telse\n\t\tevtdir = IIO_EV_DIR_FALLING;\n\n\tiio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_INTENSITY,\n\t\t\t\t\t0, IIO_EV_TYPE_THRESH, evtdir),\n\t\t\t\t\tiio_get_time_ns(indio_dev));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int veml6030_hw_init(struct iio_dev *indio_dev)\n{\n\tint ret, val;\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tret = veml6030_als_shut_down(data);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't shutdown als %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, VEML6030_REG_ALS_CONF, 0x1001);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't setup als configs %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(data->regmap, VEML6030_REG_ALS_PSM,\n\t\t\t\t VEML6030_PSM | VEML6030_PSM_EN, 0x03);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't setup default PSM %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, VEML6030_REG_ALS_WH, 0xFFFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't setup high threshold %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, VEML6030_REG_ALS_WL, 0x0000);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't setup low threshold %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = veml6030_als_pwr_on(data);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"can't poweron als %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(4000, 4002);\n\n\t \n\tret = regmap_read(data->regmap, VEML6030_REG_ALS_INT, &val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"can't clear als interrupt status %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdata->cur_gain = 3;\n\tdata->cur_resolution = 4608;\n\tdata->cur_integration_time = 3;\n\n\treturn ret;\n}\n\nstatic int veml6030_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct veml6030_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c adapter doesn't support plain i2c\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &veml6030_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"can't setup regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->regmap = regmap;\n\n\tindio_dev->name = \"veml6030\";\n\tindio_dev->channels = veml6030_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(veml6030_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, veml6030_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\t\"veml6030\", indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"irq %d request failed\\n\", client->irq);\n\t\t\treturn ret;\n\t\t}\n\t\tindio_dev->info = &veml6030_info;\n\t} else {\n\t\tindio_dev->info = &veml6030_info_no_irq;\n\t}\n\n\tret = veml6030_hw_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\tveml6030_als_shut_down_action, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int veml6030_runtime_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = veml6030_als_shut_down(data);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"can't suspend als %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int veml6030_runtime_resume(struct device *dev)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct veml6030_data *data = iio_priv(indio_dev);\n\n\tret = veml6030_als_pwr_on(data);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"can't resume als %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(veml6030_pm_ops, veml6030_runtime_suspend,\n\t\t\t\t veml6030_runtime_resume, NULL);\n\nstatic const struct of_device_id veml6030_of_match[] = {\n\t{ .compatible = \"vishay,veml6030\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, veml6030_of_match);\n\nstatic const struct i2c_device_id veml6030_id[] = {\n\t{ \"veml6030\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, veml6030_id);\n\nstatic struct i2c_driver veml6030_driver = {\n\t.driver = {\n\t\t.name = \"veml6030\",\n\t\t.of_match_table = veml6030_of_match,\n\t\t.pm = pm_ptr(&veml6030_pm_ops),\n\t},\n\t.probe = veml6030_probe,\n\t.id_table = veml6030_id,\n};\nmodule_i2c_driver(veml6030_driver);\n\nMODULE_AUTHOR(\"Rishi Gupta <gupt21@gmail.com>\");\nMODULE_DESCRIPTION(\"VEML6030 Ambient Light Sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}