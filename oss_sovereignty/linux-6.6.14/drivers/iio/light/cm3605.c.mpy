{
  "module_name": "cm3605.c",
  "hash_id": "d1b50ca1a67122826f369ad109f8c19bcaf842f64ec8273c727e09266d937e85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/cm3605.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/consumer.h>  \n#include <linux/iio/types.h>  \n#include <linux/init.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/math64.h>\n#include <linux/pm.h>\n\n#define CM3605_PROX_CHANNEL 0\n#define CM3605_ALS_CHANNEL 1\n#define CM3605_AOUT_TYP_MAX_MV 1550\n \n#define CM3605_AOUT_MAX_MV 1650\n\n \nstruct cm3605 {\n\tstruct device *dev;\n\tstruct regulator *vdd;\n\tstruct gpio_desc *aset;\n\tstruct iio_channel *aout;\n\ts32 als_max;\n\tenum iio_event_direction dir;\n\tstruct led_trigger *led;\n};\n\nstatic irqreturn_t cm3605_prox_irq(int irq, void *d)\n{\n\tstruct iio_dev *indio_dev = d;\n\tstruct cm3605 *cm3605 = iio_priv(indio_dev);\n\tu64 ev;\n\n\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, CM3605_PROX_CHANNEL,\n\t\t\t\t  IIO_EV_TYPE_THRESH, cm3605->dir);\n\tiio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\n\n\t \n\tif (cm3605->dir == IIO_EV_DIR_RISING)\n\t\tcm3605->dir = IIO_EV_DIR_FALLING;\n\telse\n\t\tcm3605->dir = IIO_EV_DIR_RISING;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cm3605_get_lux(struct cm3605 *cm3605)\n{\n\tint ret, res;\n\ts64 lux;\n\n\tret = iio_read_channel_processed(cm3605->aout, &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(cm3605->dev, \"read %d mV from ADC\\n\", res);\n\n\t \n\tif (res < 30)\n\t\treturn 0;\n\tif (res > CM3605_AOUT_MAX_MV)\n\t\tdev_err(cm3605->dev, \"device out of range\\n\");\n\n\t \n\tlux = res - 30;\n\n\t \n\tlux *= cm3605->als_max;\n\tlux = div64_s64(lux, CM3605_AOUT_TYP_MAX_MV);\n\n\treturn lux;\n}\n\nstatic int cm3605_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct cm3605 *cm3605 = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = cm3605_get_lux(cm3605);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info cm3605_info = {\n\t.read_raw = cm3605_read_raw,\n};\n\nstatic const struct iio_event_spec cm3605_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec cm3605_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.event_spec = cm3605_events,\n\t\t.num_event_specs = ARRAY_SIZE(cm3605_events),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.channel = CM3605_ALS_CHANNEL,\n\t},\n};\n\nstatic int cm3605_probe(struct platform_device *pdev)\n{\n\tstruct cm3605 *cm3605;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tenum iio_chan_type ch_type;\n\tu32 rset;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*cm3605));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tcm3605 = iio_priv(indio_dev);\n\tcm3605->dev = dev;\n\tcm3605->dir = IIO_EV_DIR_FALLING;\n\n\tret = device_property_read_u32(dev, \"capella,aset-resistance-ohms\", &rset);\n\tif (ret) {\n\t\tdev_info(dev, \"no RSET specified, assuming 100K\\n\");\n\t\trset = 100000;\n\t}\n\tswitch (rset) {\n\tcase 50000:\n\t\tcm3605->als_max = 650;\n\t\tbreak;\n\tcase 100000:\n\t\tcm3605->als_max = 300;\n\t\tbreak;\n\tcase 300000:\n\t\tcm3605->als_max = 100;\n\t\tbreak;\n\tcase 600000:\n\t\tcm3605->als_max = 50;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"non-standard resistance\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcm3605->aout = devm_iio_channel_get(dev, \"aout\");\n\tif (IS_ERR(cm3605->aout)) {\n\t\tret = PTR_ERR(cm3605->aout);\n\t\tret = (ret == -ENODEV) ? -EPROBE_DEFER : ret;\n\t\treturn dev_err_probe(dev, ret, \"failed to get AOUT ADC channel\\n\");\n\t}\n\tret = iio_get_channel_type(cm3605->aout, &ch_type);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ch_type != IIO_VOLTAGE) {\n\t\tdev_err(dev, \"wrong type of IIO channel specified for AOUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcm3605->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(cm3605->vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(cm3605->vdd),\n\t\t\t\t     \"failed to get VDD regulator\\n\");\n\n\tret = regulator_enable(cm3605->vdd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tcm3605->aset = devm_gpiod_get(dev, \"aset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(cm3605->aset)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(cm3605->aset), \"no ASET GPIO\\n\");\n\t\tgoto out_disable_vdd;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_disable_aset;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, cm3605_prox_irq,\n\t\t\t\t\tNULL, 0, \"cm3605\", indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\tgoto out_disable_aset;\n\t}\n\n\t \n\tled_trigger_register_simple(\"cm3605\", &cm3605->led);\n\tled_trigger_event(cm3605->led, LED_FULL);\n\n\tindio_dev->info = &cm3605_info;\n\tindio_dev->name = \"cm3605\";\n\tindio_dev->channels = cm3605_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cm3605_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto out_remove_trigger;\n\tdev_info(dev, \"Capella Microsystems CM3605 enabled range 0..%d LUX\\n\",\n\t\t cm3605->als_max);\n\n\treturn 0;\n\nout_remove_trigger:\n\tled_trigger_event(cm3605->led, LED_OFF);\n\tled_trigger_unregister_simple(cm3605->led);\nout_disable_aset:\n\tgpiod_set_value_cansleep(cm3605->aset, 0);\nout_disable_vdd:\n\tregulator_disable(cm3605->vdd);\n\treturn ret;\n}\n\nstatic int cm3605_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct cm3605 *cm3605 = iio_priv(indio_dev);\n\n\tled_trigger_event(cm3605->led, LED_OFF);\n\tled_trigger_unregister_simple(cm3605->led);\n\tgpiod_set_value_cansleep(cm3605->aset, 0);\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(cm3605->vdd);\n\n\treturn 0;\n}\n\nstatic int cm3605_pm_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct cm3605 *cm3605 = iio_priv(indio_dev);\n\n\tled_trigger_event(cm3605->led, LED_OFF);\n\tregulator_disable(cm3605->vdd);\n\n\treturn 0;\n}\n\nstatic int cm3605_pm_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct cm3605 *cm3605 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(cm3605->vdd);\n\tif (ret)\n\t\tdev_err(dev, \"failed to enable regulator in resume path\\n\");\n\tled_trigger_event(cm3605->led, LED_FULL);\n\n\treturn 0;\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cm3605_dev_pm_ops, cm3605_pm_suspend,\n\t\t\t\tcm3605_pm_resume);\n\nstatic const struct of_device_id cm3605_of_match[] = {\n\t{.compatible = \"capella,cm3605\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cm3605_of_match);\n\nstatic struct platform_driver cm3605_driver = {\n\t.driver = {\n\t\t.name = \"cm3605\",\n\t\t.of_match_table = cm3605_of_match,\n\t\t.pm = pm_sleep_ptr(&cm3605_dev_pm_ops),\n\t},\n\t.probe = cm3605_probe,\n\t.remove = cm3605_remove,\n};\nmodule_platform_driver(cm3605_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"CM3605 ambient light and proximity sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}