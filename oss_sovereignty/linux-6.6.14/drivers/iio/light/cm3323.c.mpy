{
  "module_name": "cm3323.c",
  "hash_id": "9ed65d43f16a6c3307e41d3667160278bd0ce88f8a03b34cc4fa262e080b9a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/cm3323.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define CM3323_DRV_NAME \"cm3323\"\n\n#define CM3323_CMD_CONF\t\t0x00\n#define CM3323_CMD_RED_DATA\t0x08\n#define CM3323_CMD_GREEN_DATA\t0x09\n#define CM3323_CMD_BLUE_DATA\t0x0A\n#define CM3323_CMD_CLEAR_DATA\t0x0B\n\n#define CM3323_CONF_SD_BIT\tBIT(0)  \n#define CM3323_CONF_AF_BIT\tBIT(1)  \n#define CM3323_CONF_IT_MASK\tGENMASK(6, 4)\n#define CM3323_CONF_IT_SHIFT\t4\n\n#define CM3323_INT_TIME_AVAILABLE \"0.04 0.08 0.16 0.32 0.64 1.28\"\n\nstatic const struct {\n\tint val;\n\tint val2;\n} cm3323_int_time[] = {\n\t{0, 40000},   \n\t{0, 80000},   \n\t{0, 160000},  \n\t{0, 320000},  \n\t{0, 640000},  \n\t{1, 280000},  \n};\n\nstruct cm3323_data {\n\tstruct i2c_client *client;\n\tu16 reg_conf;\n\tstruct mutex mutex;\n};\n\n#define CM3323_COLOR_CHANNEL(_color, _addr) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = IIO_MOD_LIGHT_##_color, \\\n\t.address = _addr, \\\n}\n\nstatic const struct iio_chan_spec cm3323_channels[] = {\n\tCM3323_COLOR_CHANNEL(RED, CM3323_CMD_RED_DATA),\n\tCM3323_COLOR_CHANNEL(GREEN, CM3323_CMD_GREEN_DATA),\n\tCM3323_COLOR_CHANNEL(BLUE, CM3323_CMD_BLUE_DATA),\n\tCM3323_COLOR_CHANNEL(CLEAR, CM3323_CMD_CLEAR_DATA),\n};\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(CM3323_INT_TIME_AVAILABLE);\n\nstatic struct attribute *cm3323_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cm3323_attribute_group = {\n\t.attrs = cm3323_attributes,\n};\n\nstatic int cm3323_init(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct cm3323_data *data = iio_priv(indio_dev);\n\n\tret = i2c_smbus_read_word_data(data->client, CM3323_CMD_CONF);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_conf\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret &= ~(CM3323_CONF_SD_BIT | CM3323_CONF_AF_BIT);\n\n\tret = i2c_smbus_write_word_data(data->client, CM3323_CMD_CONF, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_conf\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->reg_conf = ret;\n\n\treturn 0;\n}\n\nstatic void cm3323_disable(void *data)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev = data;\n\tstruct cm3323_data *cm_data = iio_priv(indio_dev);\n\n\tret = i2c_smbus_write_word_data(cm_data->client, CM3323_CMD_CONF,\n\t\t\t\t\tCM3323_CONF_SD_BIT);\n\tif (ret < 0)\n\t\tdev_err(&cm_data->client->dev, \"Error writing reg_conf\\n\");\n}\n\nstatic int cm3323_set_it_bits(struct cm3323_data *data, int val, int val2)\n{\n\tint i, ret;\n\tu16 reg_conf;\n\n\tfor (i = 0; i < ARRAY_SIZE(cm3323_int_time); i++) {\n\t\tif (val == cm3323_int_time[i].val &&\n\t\t    val2 == cm3323_int_time[i].val2) {\n\t\t\treg_conf = data->reg_conf & ~CM3323_CONF_IT_MASK;\n\t\t\treg_conf |= i << CM3323_CONF_IT_SHIFT;\n\n\t\t\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t\tCM3323_CMD_CONF,\n\t\t\t\t\t\t\treg_conf);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tdata->reg_conf = reg_conf;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cm3323_get_it_bits(struct cm3323_data *data)\n{\n\tint bits;\n\n\tbits = (data->reg_conf & CM3323_CONF_IT_MASK) >>\n\t\tCM3323_CONF_IT_SHIFT;\n\n\tif (bits >= ARRAY_SIZE(cm3323_int_time))\n\t\treturn -EINVAL;\n\n\treturn bits;\n}\n\nstatic int cm3323_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tint ret;\n\tstruct cm3323_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->mutex);\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = ret;\n\t\tmutex_unlock(&data->mutex);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tmutex_lock(&data->mutex);\n\t\tret = cm3323_get_it_bits(data);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = cm3323_int_time[ret].val;\n\t\t*val2 = cm3323_int_time[ret].val2;\n\t\tmutex_unlock(&data->mutex);\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cm3323_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int val,\n\t\t\t    int val2, long mask)\n{\n\tstruct cm3323_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tmutex_lock(&data->mutex);\n\t\tret = cm3323_set_it_bits(data, val, val2);\n\t\tmutex_unlock(&data->mutex);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info cm3323_info = {\n\t.read_raw\t= cm3323_read_raw,\n\t.write_raw\t= cm3323_write_raw,\n\t.attrs\t\t= &cm3323_attribute_group,\n};\n\nstatic int cm3323_probe(struct i2c_client *client)\n{\n\tstruct cm3323_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->info = &cm3323_info;\n\tindio_dev->name = CM3323_DRV_NAME;\n\tindio_dev->channels = cm3323_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cm3323_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = cm3323_init(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cm3323 chip init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev, cm3323_disable, indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id cm3323_id[] = {\n\t{\"cm3323\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cm3323_id);\n\nstatic const struct of_device_id cm3323_of_match[] = {\n\t{ .compatible = \"capella,cm3323\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cm3323_of_match);\n\nstatic struct i2c_driver cm3323_driver = {\n\t.driver = {\n\t\t.name = CM3323_DRV_NAME,\n\t\t.of_match_table = cm3323_of_match,\n\t},\n\t.probe\t\t= cm3323_probe,\n\t.id_table\t= cm3323_id,\n};\n\nmodule_i2c_driver(cm3323_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Capella CM3323 Color Light Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}