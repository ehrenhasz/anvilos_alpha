{
  "module_name": "opt3001.c",
  "hash_id": "86125b275ea0aba4a94668a9377aaaf862fc310842027bc7b9115b35b9299589",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/opt3001.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define OPT3001_RESULT\t\t0x00\n#define OPT3001_CONFIGURATION\t0x01\n#define OPT3001_LOW_LIMIT\t0x02\n#define OPT3001_HIGH_LIMIT\t0x03\n#define OPT3001_MANUFACTURER_ID\t0x7e\n#define OPT3001_DEVICE_ID\t0x7f\n\n#define OPT3001_CONFIGURATION_RN_MASK\t(0xf << 12)\n#define OPT3001_CONFIGURATION_RN_AUTO\t(0xc << 12)\n\n#define OPT3001_CONFIGURATION_CT\tBIT(11)\n\n#define OPT3001_CONFIGURATION_M_MASK\t(3 << 9)\n#define OPT3001_CONFIGURATION_M_SHUTDOWN (0 << 9)\n#define OPT3001_CONFIGURATION_M_SINGLE\t(1 << 9)\n#define OPT3001_CONFIGURATION_M_CONTINUOUS (2 << 9)  \n\n#define OPT3001_CONFIGURATION_OVF\tBIT(8)\n#define OPT3001_CONFIGURATION_CRF\tBIT(7)\n#define OPT3001_CONFIGURATION_FH\tBIT(6)\n#define OPT3001_CONFIGURATION_FL\tBIT(5)\n#define OPT3001_CONFIGURATION_L\t\tBIT(4)\n#define OPT3001_CONFIGURATION_POL\tBIT(3)\n#define OPT3001_CONFIGURATION_ME\tBIT(2)\n\n#define OPT3001_CONFIGURATION_FC_MASK\t(3 << 0)\n\n \n#define OPT3001_LOW_LIMIT_EOC_ENABLE\t0xc000\n\n#define OPT3001_REG_EXPONENT(n)\t\t((n) >> 12)\n#define OPT3001_REG_MANTISSA(n)\t\t((n) & 0xfff)\n\n#define OPT3001_INT_TIME_LONG\t\t800000\n#define OPT3001_INT_TIME_SHORT\t\t100000\n\n \n#define OPT3001_RESULT_READY_SHORT\t150\n#define OPT3001_RESULT_READY_LONG\t1000\n\nstruct opt3001 {\n\tstruct i2c_client\t*client;\n\tstruct device\t\t*dev;\n\n\tstruct mutex\t\tlock;\n\tbool\t\t\tok_to_ignore_lock;\n\tbool\t\t\tresult_ready;\n\twait_queue_head_t\tresult_ready_queue;\n\tu16\t\t\tresult;\n\n\tu32\t\t\tint_time;\n\tu32\t\t\tmode;\n\n\tu16\t\t\thigh_thresh_mantissa;\n\tu16\t\t\tlow_thresh_mantissa;\n\n\tu8\t\t\thigh_thresh_exp;\n\tu8\t\t\tlow_thresh_exp;\n\n\tbool\t\t\tuse_irq;\n};\n\nstruct opt3001_scale {\n\tint\tval;\n\tint\tval2;\n};\n\nstatic const struct opt3001_scale opt3001_scales[] = {\n\t{\n\t\t.val = 40,\n\t\t.val2 = 950000,\n\t},\n\t{\n\t\t.val = 81,\n\t\t.val2 = 900000,\n\t},\n\t{\n\t\t.val = 163,\n\t\t.val2 = 800000,\n\t},\n\t{\n\t\t.val = 327,\n\t\t.val2 = 600000,\n\t},\n\t{\n\t\t.val = 655,\n\t\t.val2 = 200000,\n\t},\n\t{\n\t\t.val = 1310,\n\t\t.val2 = 400000,\n\t},\n\t{\n\t\t.val = 2620,\n\t\t.val2 = 800000,\n\t},\n\t{\n\t\t.val = 5241,\n\t\t.val2 = 600000,\n\t},\n\t{\n\t\t.val = 10483,\n\t\t.val2 = 200000,\n\t},\n\t{\n\t\t.val = 20966,\n\t\t.val2 = 400000,\n\t},\n\t{\n\t\t.val = 83865,\n\t\t.val2 = 600000,\n\t},\n};\n\nstatic int opt3001_find_scale(const struct opt3001 *opt, int val,\n\t\tint val2, u8 *exponent)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(opt3001_scales); i++) {\n\t\tconst struct opt3001_scale *scale = &opt3001_scales[i];\n\n\t\t \n\t\tif ((val * 1000 + val2 / 1000) <=\n\t\t\t\t(scale->val * 1000 + scale->val2 / 1000)) {\n\t\t\t*exponent = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void opt3001_to_iio_ret(struct opt3001 *opt, u8 exponent,\n\t\tu16 mantissa, int *val, int *val2)\n{\n\tint lux;\n\n\tlux = 10 * (mantissa << exponent);\n\t*val = lux / 1000;\n\t*val2 = (lux - (*val * 1000)) * 1000;\n}\n\nstatic void opt3001_set_mode(struct opt3001 *opt, u16 *reg, u16 mode)\n{\n\t*reg &= ~OPT3001_CONFIGURATION_M_MASK;\n\t*reg |= mode;\n\topt->mode = mode;\n}\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.1 0.8\");\n\nstatic struct attribute *opt3001_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group opt3001_attribute_group = {\n\t.attrs = opt3001_attributes,\n};\n\nstatic const struct iio_event_spec opt3001_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec opt3001_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.event_spec = opt3001_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(opt3001_event_spec),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic int opt3001_get_lux(struct opt3001 *opt, int *val, int *val2)\n{\n\tint ret;\n\tu16 mantissa;\n\tu16 reg;\n\tu8 exponent;\n\tu16 value;\n\tlong timeout;\n\n\tif (opt->use_irq) {\n\t\t \n\t\tret = i2c_smbus_write_word_swapped(opt->client,\n\t\t\t\t\tOPT3001_LOW_LIMIT,\n\t\t\t\t\tOPT3001_LOW_LIMIT_EOC_ENABLE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\t\tOPT3001_LOW_LIMIT);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\topt->ok_to_ignore_lock = true;\n\t}\n\n\t \n\topt->result_ready = false;\n\n\t \n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\tgoto err;\n\t}\n\n\treg = ret;\n\topt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SINGLE);\n\n\tret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\n\t\t\treg);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\tgoto err;\n\t}\n\n\tif (opt->use_irq) {\n\t\t \n\t\tret = wait_event_timeout(opt->result_ready_queue,\n\t\t\t\topt->result_ready,\n\t\t\t\tmsecs_to_jiffies(OPT3001_RESULT_READY_LONG));\n\t\tif (ret == 0)\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\t \n\t\ttimeout = (opt->int_time == OPT3001_INT_TIME_SHORT) ?\n\t\t\tOPT3001_RESULT_READY_SHORT : OPT3001_RESULT_READY_LONG;\n\t\tmsleep(timeout);\n\n\t\t \n\t\tret = i2c_smbus_read_word_swapped(opt->client,\n\t\t\t\t\t\t  OPT3001_CONFIGURATION);\n\t\tif (ret < 0) {\n\t\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!(ret & OPT3001_CONFIGURATION_CRF)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_RESULT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_RESULT);\n\t\t\tgoto err;\n\t\t}\n\t\topt->result = ret;\n\t\topt->result_ready = true;\n\t}\n\nerr:\n\tif (opt->use_irq)\n\t\t \n\t\topt->ok_to_ignore_lock = false;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (opt->use_irq) {\n\t\t \n\t\tvalue = (opt->low_thresh_exp << 12) | opt->low_thresh_mantissa;\n\t\tret = i2c_smbus_write_word_swapped(opt->client,\n\t\t\t\t\t\t   OPT3001_LOW_LIMIT,\n\t\t\t\t\t\t   value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\t\tOPT3001_LOW_LIMIT);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\texponent = OPT3001_REG_EXPONENT(opt->result);\n\tmantissa = OPT3001_REG_MANTISSA(opt->result);\n\n\topt3001_to_iio_ret(opt, exponent, mantissa, val, val2);\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int opt3001_get_int_time(struct opt3001 *opt, int *val, int *val2)\n{\n\t*val = 0;\n\t*val2 = opt->int_time;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int opt3001_set_int_time(struct opt3001 *opt, int time)\n{\n\tint ret;\n\tu16 reg;\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\treturn ret;\n\t}\n\n\treg = ret;\n\n\tswitch (time) {\n\tcase OPT3001_INT_TIME_SHORT:\n\t\treg &= ~OPT3001_CONFIGURATION_CT;\n\t\topt->int_time = OPT3001_INT_TIME_SHORT;\n\t\tbreak;\n\tcase OPT3001_INT_TIME_LONG:\n\t\treg |= OPT3001_CONFIGURATION_CT;\n\t\topt->int_time = OPT3001_INT_TIME_LONG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\n\t\t\treg);\n}\n\nstatic int opt3001_read_raw(struct iio_dev *iio,\n\t\tstruct iio_chan_spec const *chan, int *val, int *val2,\n\t\tlong mask)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\n\tif (opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\n\t\treturn -EBUSY;\n\n\tif (chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&opt->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = opt3001_get_lux(opt, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tret = opt3001_get_int_time(opt, val, val2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&opt->lock);\n\n\treturn ret;\n}\n\nstatic int opt3001_write_raw(struct iio_dev *iio,\n\t\tstruct iio_chan_spec const *chan, int val, int val2,\n\t\tlong mask)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\n\tif (opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\n\t\treturn -EBUSY;\n\n\tif (chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tif (mask != IIO_CHAN_INFO_INT_TIME)\n\t\treturn -EINVAL;\n\n\tif (val != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&opt->lock);\n\tret = opt3001_set_int_time(opt, val2);\n\tmutex_unlock(&opt->lock);\n\n\treturn ret;\n}\n\nstatic int opt3001_read_event_value(struct iio_dev *iio,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint *val, int *val2)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret = IIO_VAL_INT_PLUS_MICRO;\n\n\tmutex_lock(&opt->lock);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\topt3001_to_iio_ret(opt, opt->high_thresh_exp,\n\t\t\t\topt->high_thresh_mantissa, val, val2);\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\topt3001_to_iio_ret(opt, opt->low_thresh_exp,\n\t\t\t\topt->low_thresh_mantissa, val, val2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&opt->lock);\n\n\treturn ret;\n}\n\nstatic int opt3001_write_event_value(struct iio_dev *iio,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint val, int val2)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\n\tu16 mantissa;\n\tu16 value;\n\tu16 reg;\n\n\tu8 exponent;\n\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&opt->lock);\n\n\tret = opt3001_find_scale(opt, val, val2, &exponent);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"can't find scale for %d.%06u\\n\", val, val2);\n\t\tgoto err;\n\t}\n\n\tmantissa = (((val * 1000) + (val2 / 1000)) / 10) >> exponent;\n\tvalue = (exponent << 12) | mantissa;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\treg = OPT3001_HIGH_LIMIT;\n\t\topt->high_thresh_mantissa = mantissa;\n\t\topt->high_thresh_exp = exponent;\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\treg = OPT3001_LOW_LIMIT;\n\t\topt->low_thresh_mantissa = mantissa;\n\t\topt->low_thresh_exp = exponent;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = i2c_smbus_write_word_swapped(opt->client, reg, value);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to write register %02x\\n\", reg);\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&opt->lock);\n\n\treturn ret;\n}\n\nstatic int opt3001_read_event_config(struct iio_dev *iio,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\n\treturn opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS;\n}\n\nstatic int opt3001_write_event_config(struct iio_dev *iio,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, int state)\n{\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\tu16 mode;\n\tu16 reg;\n\n\tif (state && opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\n\t\treturn 0;\n\n\tif (!state && opt->mode == OPT3001_CONFIGURATION_M_SHUTDOWN)\n\t\treturn 0;\n\n\tmutex_lock(&opt->lock);\n\n\tmode = state ? OPT3001_CONFIGURATION_M_CONTINUOUS\n\t\t: OPT3001_CONFIGURATION_M_SHUTDOWN;\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\tgoto err;\n\t}\n\n\treg = ret;\n\topt3001_set_mode(opt, &reg, mode);\n\n\tret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\n\t\t\treg);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&opt->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info opt3001_info = {\n\t.attrs = &opt3001_attribute_group,\n\t.read_raw = opt3001_read_raw,\n\t.write_raw = opt3001_write_raw,\n\t.read_event_value = opt3001_read_event_value,\n\t.write_event_value = opt3001_write_event_value,\n\t.read_event_config = opt3001_read_event_config,\n\t.write_event_config = opt3001_write_event_config,\n};\n\nstatic int opt3001_read_id(struct opt3001 *opt)\n{\n\tchar manufacturer[2];\n\tu16 device_id;\n\tint ret;\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_MANUFACTURER_ID);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_MANUFACTURER_ID);\n\t\treturn ret;\n\t}\n\n\tmanufacturer[0] = ret >> 8;\n\tmanufacturer[1] = ret & 0xff;\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_DEVICE_ID);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_DEVICE_ID);\n\t\treturn ret;\n\t}\n\n\tdevice_id = ret;\n\n\tdev_info(opt->dev, \"Found %c%c OPT%04x\\n\", manufacturer[0],\n\t\t\tmanufacturer[1], device_id);\n\n\treturn 0;\n}\n\nstatic int opt3001_configure(struct opt3001 *opt)\n{\n\tint ret;\n\tu16 reg;\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\treturn ret;\n\t}\n\n\treg = ret;\n\n\t \n\treg &= ~OPT3001_CONFIGURATION_RN_MASK;\n\treg |= OPT3001_CONFIGURATION_RN_AUTO;\n\n\t \n\tif (reg & OPT3001_CONFIGURATION_CT)\n\t\topt->int_time = OPT3001_INT_TIME_LONG;\n\telse\n\t\topt->int_time = OPT3001_INT_TIME_SHORT;\n\n\t \n\topt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SHUTDOWN);\n\n\t \n\treg |= OPT3001_CONFIGURATION_L;\n\treg &= ~OPT3001_CONFIGURATION_POL;\n\treg &= ~OPT3001_CONFIGURATION_ME;\n\treg &= ~OPT3001_CONFIGURATION_FC_MASK;\n\n\tret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\n\t\t\treg);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_LOW_LIMIT);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_LOW_LIMIT);\n\t\treturn ret;\n\t}\n\n\topt->low_thresh_mantissa = OPT3001_REG_MANTISSA(ret);\n\topt->low_thresh_exp = OPT3001_REG_EXPONENT(ret);\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_HIGH_LIMIT);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_HIGH_LIMIT);\n\t\treturn ret;\n\t}\n\n\topt->high_thresh_mantissa = OPT3001_REG_MANTISSA(ret);\n\topt->high_thresh_exp = OPT3001_REG_EXPONENT(ret);\n\n\treturn 0;\n}\n\nstatic irqreturn_t opt3001_irq(int irq, void *_iio)\n{\n\tstruct iio_dev *iio = _iio;\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\tbool wake_result_ready_queue = false;\n\n\tif (!opt->ok_to_ignore_lock)\n\t\tmutex_lock(&opt->lock);\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\tgoto out;\n\t}\n\n\tif ((ret & OPT3001_CONFIGURATION_M_MASK) ==\n\t\t\tOPT3001_CONFIGURATION_M_CONTINUOUS) {\n\t\tif (ret & OPT3001_CONFIGURATION_FH)\n\t\t\tiio_push_event(iio,\n\t\t\t\t\tIIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\tIIO_EV_DIR_RISING),\n\t\t\t\t\tiio_get_time_ns(iio));\n\t\tif (ret & OPT3001_CONFIGURATION_FL)\n\t\t\tiio_push_event(iio,\n\t\t\t\t\tIIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\tIIO_EV_DIR_FALLING),\n\t\t\t\t\tiio_get_time_ns(iio));\n\t} else if (ret & OPT3001_CONFIGURATION_CRF) {\n\t\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_RESULT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\t\tOPT3001_RESULT);\n\t\t\tgoto out;\n\t\t}\n\t\topt->result = ret;\n\t\topt->result_ready = true;\n\t\twake_result_ready_queue = true;\n\t}\n\nout:\n\tif (!opt->ok_to_ignore_lock)\n\t\tmutex_unlock(&opt->lock);\n\n\tif (wake_result_ready_queue)\n\t\twake_up(&opt->result_ready_queue);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int opt3001_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\n\tstruct iio_dev *iio;\n\tstruct opt3001 *opt;\n\tint irq = client->irq;\n\tint ret;\n\n\tiio = devm_iio_device_alloc(dev, sizeof(*opt));\n\tif (!iio)\n\t\treturn -ENOMEM;\n\n\topt = iio_priv(iio);\n\topt->client = client;\n\topt->dev = dev;\n\n\tmutex_init(&opt->lock);\n\tinit_waitqueue_head(&opt->result_ready_queue);\n\ti2c_set_clientdata(client, iio);\n\n\tret = opt3001_read_id(opt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opt3001_configure(opt);\n\tif (ret)\n\t\treturn ret;\n\n\tiio->name = client->name;\n\tiio->channels = opt3001_channels;\n\tiio->num_channels = ARRAY_SIZE(opt3001_channels);\n\tiio->modes = INDIO_DIRECT_MODE;\n\tiio->info = &opt3001_info;\n\n\tret = devm_iio_device_register(dev, iio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register IIO device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (irq > 0) {\n\t\tret = request_threaded_irq(irq, NULL, opt3001_irq,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\"opt3001\", iio);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request IRQ #%d\\n\", irq);\n\t\t\treturn ret;\n\t\t}\n\t\topt->use_irq = true;\n\t} else {\n\t\tdev_dbg(opt->dev, \"enabling interrupt-less operation\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void opt3001_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *iio = i2c_get_clientdata(client);\n\tstruct opt3001 *opt = iio_priv(iio);\n\tint ret;\n\tu16 reg;\n\n\tif (opt->use_irq)\n\t\tfree_irq(client->irq, iio);\n\n\tret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to read register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t\treturn;\n\t}\n\n\treg = ret;\n\topt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SHUTDOWN);\n\n\tret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\n\t\t\treg);\n\tif (ret < 0) {\n\t\tdev_err(opt->dev, \"failed to write register %02x\\n\",\n\t\t\t\tOPT3001_CONFIGURATION);\n\t}\n}\n\nstatic const struct i2c_device_id opt3001_id[] = {\n\t{ \"opt3001\", 0 },\n\t{ }  \n};\nMODULE_DEVICE_TABLE(i2c, opt3001_id);\n\nstatic const struct of_device_id opt3001_of_match[] = {\n\t{ .compatible = \"ti,opt3001\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, opt3001_of_match);\n\nstatic struct i2c_driver opt3001_driver = {\n\t.probe = opt3001_probe,\n\t.remove = opt3001_remove,\n\t.id_table = opt3001_id,\n\n\t.driver = {\n\t\t.name = \"opt3001\",\n\t\t.of_match_table = opt3001_of_match,\n\t},\n};\n\nmodule_i2c_driver(opt3001_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Andreas Dannenberg <dannenberg@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments OPT3001 Light Sensor Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}