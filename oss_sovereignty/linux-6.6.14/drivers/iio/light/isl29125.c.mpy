{
  "module_name": "isl29125.c",
  "hash_id": "a8868397bb4b16dfe4954a8b94eaddfee065e7b87084eff1977040774acd0fb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/isl29125.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define ISL29125_DRV_NAME \"isl29125\"\n\n#define ISL29125_DEVICE_ID 0x00\n#define ISL29125_CONF1 0x01\n#define ISL29125_CONF2 0x02\n#define ISL29125_CONF3 0x03\n#define ISL29125_STATUS 0x08\n#define ISL29125_GREEN_DATA 0x09\n#define ISL29125_RED_DATA 0x0b\n#define ISL29125_BLUE_DATA 0x0d\n\n#define ISL29125_ID 0x7d\n\n#define ISL29125_MODE_MASK GENMASK(2, 0)\n#define ISL29125_MODE_PD 0x0\n#define ISL29125_MODE_G 0x1\n#define ISL29125_MODE_R 0x2\n#define ISL29125_MODE_B 0x3\n#define ISL29125_MODE_RGB 0x5\n\n#define ISL29125_SENSING_RANGE_0 5722    \n#define ISL29125_SENSING_RANGE_1 152590  \n\n#define ISL29125_MODE_RANGE BIT(3)\n\n#define ISL29125_STATUS_CONV BIT(1)\n\nstruct isl29125_data {\n\tstruct i2c_client *client;\n\tu8 conf1;\n\t \n\tstruct {\n\t\tu16 chans[3];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\n#define ISL29125_CHANNEL(_color, _si) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.channel2 = IIO_MOD_LIGHT_##_color, \\\n\t.scan_index = _si, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec isl29125_channels[] = {\n\tISL29125_CHANNEL(GREEN, 0),\n\tISL29125_CHANNEL(RED, 1),\n\tISL29125_CHANNEL(BLUE, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct {\n\tu8 mode, data;\n} isl29125_regs[] = {\n\t{ISL29125_MODE_G, ISL29125_GREEN_DATA},\n\t{ISL29125_MODE_R, ISL29125_RED_DATA},\n\t{ISL29125_MODE_B, ISL29125_BLUE_DATA},\n};\n\nstatic int isl29125_read_data(struct isl29125_data *data, int si)\n{\n\tint tries = 5;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\tdata->conf1 | isl29125_regs[si].mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(101);\n\n\twhile (tries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, ISL29125_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (ret & ISL29125_STATUS_CONV)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\\n\");\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\tret = i2c_smbus_read_word_data(data->client, isl29125_regs[si].data);\n\nfail:\n\ti2c_smbus_write_byte_data(data->client, ISL29125_CONF1, data->conf1);\n\treturn ret;\n}\n\nstatic int isl29125_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct isl29125_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = isl29125_read_data(data, chan->scan_index);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tif (data->conf1 & ISL29125_MODE_RANGE)\n\t\t\t*val2 = ISL29125_SENSING_RANGE_1;  \n\t\telse\n\t\t\t*val2 = ISL29125_SENSING_RANGE_0;  \n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int isl29125_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct isl29125_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tif (val2 == ISL29125_SENSING_RANGE_1)\n\t\t\tdata->conf1 |= ISL29125_MODE_RANGE;\n\t\telse if (val2 == ISL29125_SENSING_RANGE_0)\n\t\t\tdata->conf1 &= ~ISL29125_MODE_RANGE;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\t\tdata->conf1);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t isl29125_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct isl29125_data *data = iio_priv(indio_dev);\n\tint i, j = 0;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tint ret = i2c_smbus_read_word_data(data->client,\n\t\t\tisl29125_regs[i].data);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tdata->scan.chans[j++] = ret;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic IIO_CONST_ATTR(scale_available, \"0.005722 0.152590\");\n\nstatic struct attribute *isl29125_attributes[] = {\n\t&iio_const_attr_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group isl29125_attribute_group = {\n\t.attrs = isl29125_attributes,\n};\n\nstatic const struct iio_info isl29125_info = {\n\t.read_raw = isl29125_read_raw,\n\t.write_raw = isl29125_write_raw,\n\t.attrs = &isl29125_attribute_group,\n};\n\nstatic int isl29125_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct isl29125_data *data = iio_priv(indio_dev);\n\n\tdata->conf1 |= ISL29125_MODE_RGB;\n\treturn i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\tdata->conf1);\n}\n\nstatic int isl29125_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct isl29125_data *data = iio_priv(indio_dev);\n\n\tdata->conf1 &= ~ISL29125_MODE_MASK;\n\tdata->conf1 |= ISL29125_MODE_PD;\n\treturn i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\tdata->conf1);\n}\n\nstatic const struct iio_buffer_setup_ops isl29125_buffer_setup_ops = {\n\t.postenable = isl29125_buffer_postenable,\n\t.predisable = isl29125_buffer_predisable,\n};\n\nstatic int isl29125_probe(struct i2c_client *client)\n{\n\tstruct isl29125_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &isl29125_info;\n\tindio_dev->name = ISL29125_DRV_NAME;\n\tindio_dev->channels = isl29125_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(isl29125_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_read_byte_data(data->client, ISL29125_DEVICE_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ISL29125_ID)\n\t\treturn -ENODEV;\n\n\tdata->conf1 = ISL29125_MODE_PD | ISL29125_MODE_RANGE;\n\tret = i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\tdata->conf1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, ISL29125_STATUS, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\tisl29125_trigger_handler, &isl29125_buffer_setup_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto buffer_cleanup;\n\n\treturn 0;\n\nbuffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\treturn ret;\n}\n\nstatic int isl29125_powerdown(struct isl29125_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\t(data->conf1 & ~ISL29125_MODE_MASK) | ISL29125_MODE_PD);\n}\n\nstatic void isl29125_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tisl29125_powerdown(iio_priv(indio_dev));\n}\n\nstatic int isl29125_suspend(struct device *dev)\n{\n\tstruct isl29125_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\treturn isl29125_powerdown(data);\n}\n\nstatic int isl29125_resume(struct device *dev)\n{\n\tstruct isl29125_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\treturn i2c_smbus_write_byte_data(data->client, ISL29125_CONF1,\n\t\tdata->conf1);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(isl29125_pm_ops, isl29125_suspend,\n\t\t\t\tisl29125_resume);\n\nstatic const struct i2c_device_id isl29125_id[] = {\n\t{ \"isl29125\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, isl29125_id);\n\nstatic struct i2c_driver isl29125_driver = {\n\t.driver = {\n\t\t.name\t= ISL29125_DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&isl29125_pm_ops),\n\t},\n\t.probe\t\t= isl29125_probe,\n\t.remove\t\t= isl29125_remove,\n\t.id_table\t= isl29125_id,\n};\nmodule_i2c_driver(isl29125_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"ISL29125 RGB light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}