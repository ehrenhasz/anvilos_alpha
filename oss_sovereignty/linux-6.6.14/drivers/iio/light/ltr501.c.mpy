{
  "module_name": "ltr501.c",
  "hash_id": "eb3e6dff1b169149178141fbbfed03b57433e608db255632312115304fcce8b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/ltr501.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/events.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define LTR501_DRV_NAME \"ltr501\"\n\n#define LTR501_ALS_CONTR 0x80  \n#define LTR501_PS_CONTR 0x81  \n#define LTR501_PS_MEAS_RATE 0x84  \n#define LTR501_ALS_MEAS_RATE 0x85  \n#define LTR501_PART_ID 0x86\n#define LTR501_MANUFAC_ID 0x87\n#define LTR501_ALS_DATA1 0x88  \n#define LTR501_ALS_DATA1_UPPER 0x89  \n#define LTR501_ALS_DATA0 0x8a  \n#define LTR501_ALS_DATA0_UPPER 0x8b  \n#define LTR501_ALS_PS_STATUS 0x8c\n#define LTR501_PS_DATA 0x8d  \n#define LTR501_PS_DATA_UPPER 0x8e  \n#define LTR501_INTR 0x8f  \n#define LTR501_PS_THRESH_UP 0x90  \n#define LTR501_PS_THRESH_LOW 0x92  \n#define LTR501_ALS_THRESH_UP 0x97  \n#define LTR501_ALS_THRESH_LOW 0x99  \n#define LTR501_INTR_PRST 0x9e  \n#define LTR501_MAX_REG 0x9f\n\n#define LTR501_ALS_CONTR_SW_RESET BIT(2)\n#define LTR501_CONTR_PS_GAIN_MASK (BIT(3) | BIT(2))\n#define LTR501_CONTR_PS_GAIN_SHIFT 2\n#define LTR501_CONTR_ALS_GAIN_MASK BIT(3)\n#define LTR501_CONTR_ACTIVE BIT(1)\n\n#define LTR501_STATUS_ALS_INTR BIT(3)\n#define LTR501_STATUS_ALS_RDY BIT(2)\n#define LTR501_STATUS_PS_INTR BIT(1)\n#define LTR501_STATUS_PS_RDY BIT(0)\n\n#define LTR501_PS_DATA_MASK 0x7ff\n#define LTR501_PS_THRESH_MASK 0x7ff\n#define LTR501_ALS_THRESH_MASK 0xffff\n\n#define LTR501_ALS_DEF_PERIOD 500000\n#define LTR501_PS_DEF_PERIOD 100000\n\n#define LTR501_REGMAP_NAME \"ltr501_regmap\"\n\n#define LTR501_LUX_CONV(vis_coeff, vis_data, ir_coeff, ir_data) \\\n\t\t\t((vis_coeff * vis_data) - (ir_coeff * ir_data))\n\nstatic const int int_time_mapping[] = {100000, 50000, 200000, 400000};\n\nstatic const struct reg_field reg_field_it =\n\t\t\t\tREG_FIELD(LTR501_ALS_MEAS_RATE, 3, 4);\nstatic const struct reg_field reg_field_als_intr =\n\t\t\t\tREG_FIELD(LTR501_INTR, 1, 1);\nstatic const struct reg_field reg_field_ps_intr =\n\t\t\t\tREG_FIELD(LTR501_INTR, 0, 0);\nstatic const struct reg_field reg_field_als_rate =\n\t\t\t\tREG_FIELD(LTR501_ALS_MEAS_RATE, 0, 2);\nstatic const struct reg_field reg_field_ps_rate =\n\t\t\t\tREG_FIELD(LTR501_PS_MEAS_RATE, 0, 3);\nstatic const struct reg_field reg_field_als_prst =\n\t\t\t\tREG_FIELD(LTR501_INTR_PRST, 0, 3);\nstatic const struct reg_field reg_field_ps_prst =\n\t\t\t\tREG_FIELD(LTR501_INTR_PRST, 4, 7);\n\nstruct ltr501_samp_table {\n\tint freq_val;   \n\tint time_val;  \n};\n\n#define LTR501_RESERVED_GAIN -1\n\nenum {\n\tltr501 = 0,\n\tltr559,\n\tltr301,\n\tltr303,\n};\n\nstruct ltr501_gain {\n\tint scale;\n\tint uscale;\n};\n\nstatic const struct ltr501_gain ltr501_als_gain_tbl[] = {\n\t{1, 0},\n\t{0, 5000},\n};\n\nstatic const struct ltr501_gain ltr559_als_gain_tbl[] = {\n\t{1, 0},\n\t{0, 500000},\n\t{0, 250000},\n\t{0, 125000},\n\t{LTR501_RESERVED_GAIN, LTR501_RESERVED_GAIN},\n\t{LTR501_RESERVED_GAIN, LTR501_RESERVED_GAIN},\n\t{0, 20000},\n\t{0, 10000},\n};\n\nstatic const struct ltr501_gain ltr501_ps_gain_tbl[] = {\n\t{1, 0},\n\t{0, 250000},\n\t{0, 125000},\n\t{0, 62500},\n};\n\nstatic const struct ltr501_gain ltr559_ps_gain_tbl[] = {\n\t{0, 62500},  \n\t{0, 31250},  \n\t{0, 15625},  \n\t{0, 15624},\n};\n\nstruct ltr501_chip_info {\n\tu8 partid;\n\tconst struct ltr501_gain *als_gain;\n\tint als_gain_tbl_size;\n\tconst struct ltr501_gain *ps_gain;\n\tint ps_gain_tbl_size;\n\tu8 als_mode_active;\n\tu8 als_gain_mask;\n\tu8 als_gain_shift;\n\tstruct iio_chan_spec const *channels;\n\tconst int no_channels;\n\tconst struct iio_info *info;\n\tconst struct iio_info *info_no_irq;\n};\n\nstruct ltr501_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock_als, lock_ps;\n\tconst struct ltr501_chip_info *chip_info;\n\tu8 als_contr, ps_contr;\n\tint als_period, ps_period;  \n\tstruct regmap *regmap;\n\tstruct regmap_field *reg_it;\n\tstruct regmap_field *reg_als_intr;\n\tstruct regmap_field *reg_ps_intr;\n\tstruct regmap_field *reg_als_rate;\n\tstruct regmap_field *reg_ps_rate;\n\tstruct regmap_field *reg_als_prst;\n\tstruct regmap_field *reg_ps_prst;\n\tuint32_t near_level;\n};\n\nstatic const struct ltr501_samp_table ltr501_als_samp_table[] = {\n\t\t\t{20000000, 50000}, {10000000, 100000},\n\t\t\t{5000000, 200000}, {2000000, 500000},\n\t\t\t{1000000, 1000000}, {500000, 2000000},\n\t\t\t{500000, 2000000}, {500000, 2000000}\n};\n\nstatic const struct ltr501_samp_table ltr501_ps_samp_table[] = {\n\t\t\t{20000000, 50000}, {14285714, 70000},\n\t\t\t{10000000, 100000}, {5000000, 200000},\n\t\t\t{2000000, 500000}, {1000000, 1000000},\n\t\t\t{500000, 2000000}, {500000, 2000000},\n\t\t\t{500000, 2000000}\n};\n\nstatic int ltr501_match_samp_freq(const struct ltr501_samp_table *tab,\n\t\t\t\t\t   int len, int val, int val2)\n{\n\tint i, freq;\n\n\tfreq = val * 1000000 + val2;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (tab[i].freq_val == freq)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_als_read_samp_freq(const struct ltr501_data *data,\n\t\t\t\t     int *val, int *val2)\n{\n\tint ret, i;\n\n\tret = regmap_field_read(data->reg_als_rate, &i);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i < 0 || i >= ARRAY_SIZE(ltr501_als_samp_table))\n\t\treturn -EINVAL;\n\n\t*val = ltr501_als_samp_table[i].freq_val / 1000000;\n\t*val2 = ltr501_als_samp_table[i].freq_val % 1000000;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int ltr501_ps_read_samp_freq(const struct ltr501_data *data,\n\t\t\t\t    int *val, int *val2)\n{\n\tint ret, i;\n\n\tret = regmap_field_read(data->reg_ps_rate, &i);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i < 0 || i >= ARRAY_SIZE(ltr501_ps_samp_table))\n\t\treturn -EINVAL;\n\n\t*val = ltr501_ps_samp_table[i].freq_val / 1000000;\n\t*val2 = ltr501_ps_samp_table[i].freq_val % 1000000;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int ltr501_als_write_samp_freq(struct ltr501_data *data,\n\t\t\t\t      int val, int val2)\n{\n\tint i, ret;\n\n\ti = ltr501_match_samp_freq(ltr501_als_samp_table,\n\t\t\t\t   ARRAY_SIZE(ltr501_als_samp_table),\n\t\t\t\t   val, val2);\n\n\tif (i < 0)\n\t\treturn i;\n\n\tmutex_lock(&data->lock_als);\n\tret = regmap_field_write(data->reg_als_rate, i);\n\tmutex_unlock(&data->lock_als);\n\n\treturn ret;\n}\n\nstatic int ltr501_ps_write_samp_freq(struct ltr501_data *data,\n\t\t\t\t     int val, int val2)\n{\n\tint i, ret;\n\n\ti = ltr501_match_samp_freq(ltr501_ps_samp_table,\n\t\t\t\t   ARRAY_SIZE(ltr501_ps_samp_table),\n\t\t\t\t   val, val2);\n\n\tif (i < 0)\n\t\treturn i;\n\n\tmutex_lock(&data->lock_ps);\n\tret = regmap_field_write(data->reg_ps_rate, i);\n\tmutex_unlock(&data->lock_ps);\n\n\treturn ret;\n}\n\nstatic int ltr501_als_read_samp_period(const struct ltr501_data *data, int *val)\n{\n\tint ret, i;\n\n\tret = regmap_field_read(data->reg_als_rate, &i);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i < 0 || i >= ARRAY_SIZE(ltr501_als_samp_table))\n\t\treturn -EINVAL;\n\n\t*val = ltr501_als_samp_table[i].time_val;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ltr501_ps_read_samp_period(const struct ltr501_data *data, int *val)\n{\n\tint ret, i;\n\n\tret = regmap_field_read(data->reg_ps_rate, &i);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i < 0 || i >= ARRAY_SIZE(ltr501_ps_samp_table))\n\t\treturn -EINVAL;\n\n\t*val = ltr501_ps_samp_table[i].time_val;\n\n\treturn IIO_VAL_INT;\n}\n\n \nstatic unsigned long ltr501_calculate_lux(u16 vis_data, u16 ir_data)\n{\n\tunsigned long ratio, lux;\n\n\tif (vis_data == 0)\n\t\treturn 0;\n\n\t \n\tratio = DIV_ROUND_UP(ir_data * 100, ir_data + vis_data);\n\n\tif (ratio < 45)\n\t\tlux = LTR501_LUX_CONV(1774, vis_data, -1105, ir_data);\n\telse if (ratio >= 45 && ratio < 64)\n\t\tlux = LTR501_LUX_CONV(3772, vis_data, 1336, ir_data);\n\telse if (ratio >= 64 && ratio < 85)\n\t\tlux = LTR501_LUX_CONV(1690, vis_data, 169, ir_data);\n\telse\n\t\tlux = 0;\n\n\treturn lux / 1000;\n}\n\nstatic int ltr501_drdy(const struct ltr501_data *data, u8 drdy_mask)\n{\n\tint tries = 100;\n\tint ret, status;\n\n\twhile (tries--) {\n\t\tret = regmap_read(data->regmap, LTR501_ALS_PS_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif ((status & drdy_mask) == drdy_mask)\n\t\t\treturn 0;\n\t\tmsleep(25);\n\t}\n\n\tdev_err(&data->client->dev, \"ltr501_drdy() failed, data not ready\\n\");\n\treturn -EIO;\n}\n\nstatic int ltr501_set_it_time(struct ltr501_data *data, int it)\n{\n\tint ret, i, index = -1, status;\n\n\tfor (i = 0; i < ARRAY_SIZE(int_time_mapping); i++) {\n\t\tif (int_time_mapping[i] == it) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(data->regmap, LTR501_ALS_CONTR, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & LTR501_CONTR_ALS_GAIN_MASK) {\n\t\t \n\t\tif (index > 1)\n\t\t\treturn -EINVAL;\n\t} else\n\t\t \n\t\tif (index == 1)\n\t\t\treturn -EINVAL;\n\n\treturn regmap_field_write(data->reg_it, index);\n}\n\n \nstatic int ltr501_read_it_time(const struct ltr501_data *data,\n\t\t\t       int *val, int *val2)\n{\n\tint ret, index;\n\n\tret = regmap_field_read(data->reg_it, &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (index < 0 || index >= ARRAY_SIZE(int_time_mapping))\n\t\treturn -EINVAL;\n\n\t*val2 = int_time_mapping[index];\n\t*val = 0;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int ltr501_read_als(const struct ltr501_data *data, __le16 buf[2])\n{\n\tint ret;\n\n\tret = ltr501_drdy(data, LTR501_STATUS_ALS_RDY);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\treturn regmap_bulk_read(data->regmap, LTR501_ALS_DATA1,\n\t\t\t\tbuf, 2 * sizeof(__le16));\n}\n\nstatic int ltr501_read_ps(const struct ltr501_data *data)\n{\n\t__le16 status;\n\tint ret;\n\n\tret = ltr501_drdy(data, LTR501_STATUS_PS_RDY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, LTR501_PS_DATA,\n\t\t\t       &status, sizeof(status));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn le16_to_cpu(status);\n}\n\nstatic int ltr501_read_intr_prst(const struct ltr501_data *data,\n\t\t\t\t enum iio_chan_type type,\n\t\t\t\t int *val2)\n{\n\tint ret, samp_period, prst;\n\n\tswitch (type) {\n\tcase IIO_INTENSITY:\n\t\tret = regmap_field_read(data->reg_als_prst, &prst);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = ltr501_als_read_samp_period(data, &samp_period);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val2 = samp_period * prst;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_PROXIMITY:\n\t\tret = regmap_field_read(data->reg_ps_prst, &prst);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = ltr501_ps_read_samp_period(data, &samp_period);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val2 = samp_period * prst;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_write_intr_prst(struct ltr501_data *data,\n\t\t\t\t  enum iio_chan_type type,\n\t\t\t\t  int val, int val2)\n{\n\tint ret, samp_period, new_val;\n\tunsigned long period;\n\n\tif (val < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\t \n\tperiod = ((val * 1000000) + val2);\n\n\tswitch (type) {\n\tcase IIO_INTENSITY:\n\t\tret = ltr501_als_read_samp_period(data, &samp_period);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (period < samp_period)\n\t\t\treturn -EINVAL;\n\n\t\tnew_val = DIV_ROUND_UP(period, samp_period);\n\t\tif (new_val < 0 || new_val > 0x0f)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock_als);\n\t\tret = regmap_field_write(data->reg_als_prst, new_val);\n\t\tmutex_unlock(&data->lock_als);\n\t\tif (ret >= 0)\n\t\t\tdata->als_period = period;\n\n\t\treturn ret;\n\tcase IIO_PROXIMITY:\n\t\tret = ltr501_ps_read_samp_period(data, &samp_period);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (period < samp_period)\n\t\t\treturn -EINVAL;\n\n\t\tnew_val = DIV_ROUND_UP(period, samp_period);\n\t\tif (new_val < 0 || new_val > 0x0f)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock_ps);\n\t\tret = regmap_field_write(data->reg_ps_prst, new_val);\n\t\tmutex_unlock(&data->lock_ps);\n\t\tif (ret >= 0)\n\t\t\tdata->ps_period = period;\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t ltr501_read_near_level(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t priv,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      char *buf)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->near_level);\n}\n\nstatic const struct iio_chan_spec_ext_info ltr501_ext_info[] = {\n\t{\n\t\t.name = \"nearlevel\",\n\t\t.shared = IIO_SEPARATE,\n\t\t.read = ltr501_read_near_level,\n\t},\n\t{   }\n};\n\nstatic const struct iio_event_spec ltr501_als_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD),\n\t},\n\n};\n\nstatic const struct iio_event_spec ltr501_pxs_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\n#define LTR501_INTENSITY_CHANNEL(_idx, _addr, _mod, _shared, \\\n\t\t\t\t _evspec, _evsize) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.address = (_addr), \\\n\t.channel2 = (_mod), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = (_shared), \\\n\t.scan_index = (_idx), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n\t.event_spec = _evspec,\\\n\t.num_event_specs = _evsize,\\\n}\n\n#define LTR501_LIGHT_CHANNEL() { \\\n\t.type = IIO_LIGHT, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \\\n\t.scan_index = -1, \\\n}\n\nstatic const struct iio_chan_spec ltr501_channels[] = {\n\tLTR501_LIGHT_CHANNEL(),\n\tLTR501_INTENSITY_CHANNEL(0, LTR501_ALS_DATA0, IIO_MOD_LIGHT_BOTH, 0,\n\t\t\t\t ltr501_als_event_spec,\n\t\t\t\t ARRAY_SIZE(ltr501_als_event_spec)),\n\tLTR501_INTENSITY_CHANNEL(1, LTR501_ALS_DATA1, IIO_MOD_LIGHT_IR,\n\t\t\t\t BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t\t\t NULL, 0),\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.address = LTR501_PS_DATA,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 2,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 11,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t\t.event_spec = ltr501_pxs_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(ltr501_pxs_event_spec),\n\t\t.ext_info = ltr501_ext_info,\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_chan_spec ltr301_channels[] = {\n\tLTR501_LIGHT_CHANNEL(),\n\tLTR501_INTENSITY_CHANNEL(0, LTR501_ALS_DATA0, IIO_MOD_LIGHT_BOTH, 0,\n\t\t\t\t ltr501_als_event_spec,\n\t\t\t\t ARRAY_SIZE(ltr501_als_event_spec)),\n\tLTR501_INTENSITY_CHANNEL(1, LTR501_ALS_DATA1, IIO_MOD_LIGHT_IR,\n\t\t\t\t BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t\t\t NULL, 0),\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic int ltr501_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\t__le16 buf[2];\n\tint ret, i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tmutex_lock(&data->lock_als);\n\t\t\tret = ltr501_read_als(data, buf);\n\t\t\tmutex_unlock(&data->lock_als);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ltr501_calculate_lux(le16_to_cpu(buf[1]),\n\t\t\t\t\t\t    le16_to_cpu(buf[0]));\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\tmutex_lock(&data->lock_als);\n\t\t\tret = ltr501_read_als(data, buf);\n\t\t\tmutex_unlock(&data->lock_als);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\t*val = le16_to_cpu(chan->address == LTR501_ALS_DATA1 ?\n\t\t\t\t\t   buf[0] : buf[1]);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tmutex_lock(&data->lock_ps);\n\t\t\tret = ltr501_read_ps(data);\n\t\t\tmutex_unlock(&data->lock_ps);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\t*val = ret & LTR501_PS_DATA_MASK;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\ti = (data->als_contr & data->chip_info->als_gain_mask)\n\t\t\t     >> data->chip_info->als_gain_shift;\n\t\t\t*val = data->chip_info->als_gain[i].scale;\n\t\t\t*val2 = data->chip_info->als_gain[i].uscale;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_PROXIMITY:\n\t\t\ti = (data->ps_contr & LTR501_CONTR_PS_GAIN_MASK) >>\n\t\t\t\tLTR501_CONTR_PS_GAIN_SHIFT;\n\t\t\t*val = data->chip_info->ps_gain[i].scale;\n\t\t\t*val2 = data->chip_info->ps_gain[i].uscale;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\treturn ltr501_read_it_time(data, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\treturn ltr501_als_read_samp_freq(data, val, val2);\n\t\tcase IIO_PROXIMITY:\n\t\t\treturn ltr501_ps_read_samp_freq(data, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ltr501_get_gain_index(const struct ltr501_gain *gain, int size,\n\t\t\t\t int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (val == gain[i].scale && val2 == gain[i].uscale)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int ltr501_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tint i, ret, freq_val, freq_val2;\n\tconst struct ltr501_chip_info *info = data->chip_info;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\ti = ltr501_get_gain_index(info->als_gain,\n\t\t\t\t\t\t  info->als_gain_tbl_size,\n\t\t\t\t\t\t  val, val2);\n\t\t\tif (i < 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->als_contr &= ~info->als_gain_mask;\n\t\t\tdata->als_contr |= i << info->als_gain_shift;\n\n\t\t\tret = regmap_write(data->regmap, LTR501_ALS_CONTR,\n\t\t\t\t\t   data->als_contr);\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\ti = ltr501_get_gain_index(info->ps_gain,\n\t\t\t\t\t\t  info->ps_gain_tbl_size,\n\t\t\t\t\t\t  val, val2);\n\t\t\tif (i < 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->ps_contr &= ~LTR501_CONTR_PS_GAIN_MASK;\n\t\t\tdata->ps_contr |= i << LTR501_CONTR_PS_GAIN_SHIFT;\n\n\t\t\tret = regmap_write(data->regmap, LTR501_PS_CONTR,\n\t\t\t\t\t   data->ps_contr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\tif (val != 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_lock(&data->lock_als);\n\t\t\tret = ltr501_set_it_time(data, val2);\n\t\t\tmutex_unlock(&data->lock_als);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\tret = ltr501_als_read_samp_freq(data, &freq_val,\n\t\t\t\t\t\t\t&freq_val2);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ltr501_als_write_samp_freq(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tret = ltr501_write_intr_prst(data, chan->type,\n\t\t\t\t\t\t     0, data->als_period);\n\n\t\t\tif (ret < 0)\n\t\t\t\tret = ltr501_als_write_samp_freq(data, freq_val,\n\t\t\t\t\t\t\t\t freq_val2);\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = ltr501_ps_read_samp_freq(data, &freq_val,\n\t\t\t\t\t\t       &freq_val2);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ltr501_ps_write_samp_freq(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tret = ltr501_write_intr_prst(data, chan->type,\n\t\t\t\t\t\t     0, data->ps_period);\n\n\t\t\tif (ret < 0)\n\t\t\t\tret = ltr501_ps_write_samp_freq(data, freq_val,\n\t\t\t\t\t\t\t\tfreq_val2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int ltr501_read_thresh(const struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir,\n\t\t\t      enum iio_event_info info,\n\t\t\t      int *val, int *val2)\n{\n\tconst struct ltr501_data *data = iio_priv(indio_dev);\n\tint ret, thresh_data;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t\t       LTR501_ALS_THRESH_UP,\n\t\t\t\t\t       &thresh_data, 2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = thresh_data & LTR501_ALS_THRESH_MASK;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t\t       LTR501_ALS_THRESH_LOW,\n\t\t\t\t\t       &thresh_data, 2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = thresh_data & LTR501_ALS_THRESH_MASK;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_PROXIMITY:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t\t       LTR501_PS_THRESH_UP,\n\t\t\t\t\t       &thresh_data, 2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = thresh_data & LTR501_PS_THRESH_MASK;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t\t       LTR501_PS_THRESH_LOW,\n\t\t\t\t\t       &thresh_data, 2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = thresh_data & LTR501_PS_THRESH_MASK;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_write_thresh(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int val, int val2)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tif (val > LTR501_ALS_THRESH_MASK)\n\t\t\treturn -EINVAL;\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tmutex_lock(&data->lock_als);\n\t\t\tret = regmap_bulk_write(data->regmap,\n\t\t\t\t\t\tLTR501_ALS_THRESH_UP,\n\t\t\t\t\t\t&val, 2);\n\t\t\tmutex_unlock(&data->lock_als);\n\t\t\treturn ret;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tmutex_lock(&data->lock_als);\n\t\t\tret = regmap_bulk_write(data->regmap,\n\t\t\t\t\t\tLTR501_ALS_THRESH_LOW,\n\t\t\t\t\t\t&val, 2);\n\t\t\tmutex_unlock(&data->lock_als);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_PROXIMITY:\n\t\tif (val > LTR501_PS_THRESH_MASK)\n\t\t\treturn -EINVAL;\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tmutex_lock(&data->lock_ps);\n\t\t\tret = regmap_bulk_write(data->regmap,\n\t\t\t\t\t\tLTR501_PS_THRESH_UP,\n\t\t\t\t\t\t&val, 2);\n\t\t\tmutex_unlock(&data->lock_ps);\n\t\t\treturn ret;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tmutex_lock(&data->lock_ps);\n\t\t\tret = regmap_bulk_write(data->regmap,\n\t\t\t\t\t\tLTR501_PS_THRESH_LOW,\n\t\t\t\t\t\t&val, 2);\n\t\t\tmutex_unlock(&data->lock_ps);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_read_event(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     enum iio_event_type type,\n\t\t\t     enum iio_event_direction dir,\n\t\t\t     enum iio_event_info info,\n\t\t\t     int *val, int *val2)\n{\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\treturn ltr501_read_thresh(indio_dev, chan, type, dir,\n\t\t\t\t\t  info, val, val2);\n\tcase IIO_EV_INFO_PERIOD:\n\t\tret = ltr501_read_intr_prst(iio_priv(indio_dev),\n\t\t\t\t\t    chan->type, val2);\n\t\t*val = *val2 / 1000000;\n\t\t*val2 = *val2 % 1000000;\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_write_event(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir,\n\t\t\t      enum iio_event_info info,\n\t\t\t      int val, int val2)\n{\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val2 != 0)\n\t\t\treturn -EINVAL;\n\t\treturn ltr501_write_thresh(indio_dev, chan, type, dir,\n\t\t\t\t\t   info, val, val2);\n\tcase IIO_EV_INFO_PERIOD:\n\t\treturn ltr501_write_intr_prst(iio_priv(indio_dev), chan->type,\n\t\t\t\t\t      val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tint ret, status;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tret = regmap_field_read(data->reg_als_intr, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn status;\n\tcase IIO_PROXIMITY:\n\t\tret = regmap_field_read(data->reg_ps_intr, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn status;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltr501_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir, int state)\n{\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tif (state != 1  && state != 0)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tmutex_lock(&data->lock_als);\n\t\tret = regmap_field_write(data->reg_als_intr, state);\n\t\tmutex_unlock(&data->lock_als);\n\t\treturn ret;\n\tcase IIO_PROXIMITY:\n\t\tmutex_lock(&data->lock_ps);\n\t\tret = regmap_field_write(data->reg_ps_intr, state);\n\t\tmutex_unlock(&data->lock_ps);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t ltr501_show_proximity_scale_avail(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct ltr501_data *data = iio_priv(dev_to_iio_dev(dev));\n\tconst struct ltr501_chip_info *info = data->chip_info;\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < info->ps_gain_tbl_size; i++) {\n\t\tif (info->ps_gain[i].scale == LTR501_RESERVED_GAIN)\n\t\t\tcontinue;\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\t info->ps_gain[i].scale,\n\t\t\t\t info->ps_gain[i].uscale);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t ltr501_show_intensity_scale_avail(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct ltr501_data *data = iio_priv(dev_to_iio_dev(dev));\n\tconst struct ltr501_chip_info *info = data->chip_info;\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < info->als_gain_tbl_size; i++) {\n\t\tif (info->als_gain[i].scale == LTR501_RESERVED_GAIN)\n\t\t\tcontinue;\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\t info->als_gain[i].scale,\n\t\t\t\t info->als_gain[i].uscale);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.05 0.1 0.2 0.4\");\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"20 10 5 2 1 0.5\");\n\nstatic IIO_DEVICE_ATTR(in_proximity_scale_available, S_IRUGO,\n\t\t       ltr501_show_proximity_scale_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_intensity_scale_available, S_IRUGO,\n\t\t       ltr501_show_intensity_scale_avail, NULL, 0);\n\nstatic struct attribute *ltr501_attributes[] = {\n\t&iio_dev_attr_in_proximity_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic struct attribute *ltr301_attributes[] = {\n\t&iio_dev_attr_in_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ltr501_attribute_group = {\n\t.attrs = ltr501_attributes,\n};\n\nstatic const struct attribute_group ltr301_attribute_group = {\n\t.attrs = ltr301_attributes,\n};\n\nstatic const struct iio_info ltr501_info_no_irq = {\n\t.read_raw = ltr501_read_raw,\n\t.write_raw = ltr501_write_raw,\n\t.attrs = &ltr501_attribute_group,\n};\n\nstatic const struct iio_info ltr501_info = {\n\t.read_raw = ltr501_read_raw,\n\t.write_raw = ltr501_write_raw,\n\t.attrs = &ltr501_attribute_group,\n\t.read_event_value\t= &ltr501_read_event,\n\t.write_event_value\t= &ltr501_write_event,\n\t.read_event_config\t= &ltr501_read_event_config,\n\t.write_event_config\t= &ltr501_write_event_config,\n};\n\nstatic const struct iio_info ltr301_info_no_irq = {\n\t.read_raw = ltr501_read_raw,\n\t.write_raw = ltr501_write_raw,\n\t.attrs = &ltr301_attribute_group,\n};\n\nstatic const struct iio_info ltr301_info = {\n\t.read_raw = ltr501_read_raw,\n\t.write_raw = ltr501_write_raw,\n\t.attrs = &ltr301_attribute_group,\n\t.read_event_value\t= &ltr501_read_event,\n\t.write_event_value\t= &ltr501_write_event,\n\t.read_event_config\t= &ltr501_read_event_config,\n\t.write_event_config\t= &ltr501_write_event_config,\n};\n\nstatic const struct ltr501_chip_info ltr501_chip_info_tbl[] = {\n\t[ltr501] = {\n\t\t.partid = 0x08,\n\t\t.als_gain = ltr501_als_gain_tbl,\n\t\t.als_gain_tbl_size = ARRAY_SIZE(ltr501_als_gain_tbl),\n\t\t.ps_gain = ltr501_ps_gain_tbl,\n\t\t.ps_gain_tbl_size = ARRAY_SIZE(ltr501_ps_gain_tbl),\n\t\t.als_mode_active = BIT(0) | BIT(1),\n\t\t.als_gain_mask = BIT(3),\n\t\t.als_gain_shift = 3,\n\t\t.info = &ltr501_info,\n\t\t.info_no_irq = &ltr501_info_no_irq,\n\t\t.channels = ltr501_channels,\n\t\t.no_channels = ARRAY_SIZE(ltr501_channels),\n\t},\n\t[ltr559] = {\n\t\t.partid = 0x09,\n\t\t.als_gain = ltr559_als_gain_tbl,\n\t\t.als_gain_tbl_size = ARRAY_SIZE(ltr559_als_gain_tbl),\n\t\t.ps_gain = ltr559_ps_gain_tbl,\n\t\t.ps_gain_tbl_size = ARRAY_SIZE(ltr559_ps_gain_tbl),\n\t\t.als_mode_active = BIT(0),\n\t\t.als_gain_mask = BIT(2) | BIT(3) | BIT(4),\n\t\t.als_gain_shift = 2,\n\t\t.info = &ltr501_info,\n\t\t.info_no_irq = &ltr501_info_no_irq,\n\t\t.channels = ltr501_channels,\n\t\t.no_channels = ARRAY_SIZE(ltr501_channels),\n\t},\n\t[ltr301] = {\n\t\t.partid = 0x08,\n\t\t.als_gain = ltr501_als_gain_tbl,\n\t\t.als_gain_tbl_size = ARRAY_SIZE(ltr501_als_gain_tbl),\n\t\t.als_mode_active = BIT(0) | BIT(1),\n\t\t.als_gain_mask = BIT(3),\n\t\t.als_gain_shift = 3,\n\t\t.info = &ltr301_info,\n\t\t.info_no_irq = &ltr301_info_no_irq,\n\t\t.channels = ltr301_channels,\n\t\t.no_channels = ARRAY_SIZE(ltr301_channels),\n\t},\n\t[ltr303] = {\n\t\t.partid = 0x0A,\n\t\t.als_gain = ltr559_als_gain_tbl,\n\t\t.als_gain_tbl_size = ARRAY_SIZE(ltr559_als_gain_tbl),\n\t\t.als_mode_active = BIT(0),\n\t\t.als_gain_mask = BIT(2) | BIT(3) | BIT(4),\n\t\t.als_gain_shift = 2,\n\t\t.info = &ltr301_info,\n\t\t.info_no_irq = &ltr301_info_no_irq,\n\t\t.channels = ltr301_channels,\n\t\t.no_channels = ARRAY_SIZE(ltr301_channels),\n\t},\n};\n\nstatic int ltr501_write_contr(struct ltr501_data *data, u8 als_val, u8 ps_val)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, LTR501_ALS_CONTR, als_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(data->regmap, LTR501_PS_CONTR, ps_val);\n}\n\nstatic irqreturn_t ltr501_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tstruct {\n\t\tu16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\t__le16 als_buf[2];\n\tu8 mask = 0;\n\tint j = 0;\n\tint ret, psdata;\n\n\tmemset(&scan, 0, sizeof(scan));\n\n\t \n\tif (test_bit(0, indio_dev->active_scan_mask) ||\n\t    test_bit(1, indio_dev->active_scan_mask))\n\t\tmask |= LTR501_STATUS_ALS_RDY;\n\tif (test_bit(2, indio_dev->active_scan_mask))\n\t\tmask |= LTR501_STATUS_PS_RDY;\n\n\tret = ltr501_drdy(data, mask);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (mask & LTR501_STATUS_ALS_RDY) {\n\t\tret = regmap_bulk_read(data->regmap, LTR501_ALS_DATA1,\n\t\t\t\t       als_buf, sizeof(als_buf));\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (test_bit(0, indio_dev->active_scan_mask))\n\t\t\tscan.channels[j++] = le16_to_cpu(als_buf[1]);\n\t\tif (test_bit(1, indio_dev->active_scan_mask))\n\t\t\tscan.channels[j++] = le16_to_cpu(als_buf[0]);\n\t}\n\n\tif (mask & LTR501_STATUS_PS_RDY) {\n\t\tret = regmap_bulk_read(data->regmap, LTR501_PS_DATA,\n\t\t\t\t       &psdata, 2);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tscan.channels[j++] = psdata & LTR501_PS_DATA_MASK;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ltr501_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ltr501_data *data = iio_priv(indio_dev);\n\tint ret, status;\n\n\tret = regmap_read(data->regmap, LTR501_ALS_PS_STATUS, &status);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"irq read int reg failed\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (status & LTR501_STATUS_ALS_INTR)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\n\tif (status & LTR501_STATUS_PS_INTR)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ltr501_init(struct ltr501_data *data)\n{\n\tint ret, status;\n\n\tret = regmap_read(data->regmap, LTR501_ALS_CONTR, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->als_contr = status | data->chip_info->als_mode_active;\n\n\tret = regmap_read(data->regmap, LTR501_PS_CONTR, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->ps_contr = status | LTR501_CONTR_ACTIVE;\n\n\tret = ltr501_read_intr_prst(data, IIO_INTENSITY, &data->als_period);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ltr501_read_intr_prst(data, IIO_PROXIMITY, &data->ps_period);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ltr501_write_contr(data, data->als_contr, data->ps_contr);\n}\n\nstatic bool ltr501_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTR501_ALS_DATA1:\n\tcase LTR501_ALS_DATA1_UPPER:\n\tcase LTR501_ALS_DATA0:\n\tcase LTR501_ALS_DATA0_UPPER:\n\tcase LTR501_ALS_PS_STATUS:\n\tcase LTR501_PS_DATA:\n\tcase LTR501_PS_DATA_UPPER:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config ltr501_regmap_config = {\n\t.name =  LTR501_REGMAP_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = LTR501_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = ltr501_is_volatile_reg,\n};\n\nstatic int ltr501_powerdown(struct ltr501_data *data)\n{\n\treturn ltr501_write_contr(data, data->als_contr &\n\t\t\t\t  ~data->chip_info->als_mode_active,\n\t\t\t\t  data->ps_contr & ~LTR501_CONTR_ACTIVE);\n}\n\nstatic const char *ltr501_match_acpi_device(struct device *dev, int *chip_idx)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\t*chip_idx = id->driver_data;\n\treturn dev_name(dev);\n}\n\nstatic int ltr501_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstatic const char * const regulator_names[] = { \"vdd\", \"vddio\" };\n\tstruct ltr501_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret, partid, chip_idx = 0;\n\tconst char *name = NULL;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &ltr501_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Regmap initialization failed.\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->regmap = regmap;\n\tmutex_init(&data->lock_als);\n\tmutex_init(&data->lock_ps);\n\n\tret = devm_regulator_bulk_get_enable(&client->dev,\n\t\t\t\t\t     ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"Failed to get regulators\\n\");\n\n\tdata->reg_it = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t       reg_field_it);\n\tif (IS_ERR(data->reg_it)) {\n\t\tdev_err(&client->dev, \"Integ time reg field init failed.\\n\");\n\t\treturn PTR_ERR(data->reg_it);\n\t}\n\n\tdata->reg_als_intr = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t     reg_field_als_intr);\n\tif (IS_ERR(data->reg_als_intr)) {\n\t\tdev_err(&client->dev, \"ALS intr mode reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_als_intr);\n\t}\n\n\tdata->reg_ps_intr = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t    reg_field_ps_intr);\n\tif (IS_ERR(data->reg_ps_intr)) {\n\t\tdev_err(&client->dev, \"PS intr mode reg field init failed.\\n\");\n\t\treturn PTR_ERR(data->reg_ps_intr);\n\t}\n\n\tdata->reg_als_rate = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t     reg_field_als_rate);\n\tif (IS_ERR(data->reg_als_rate)) {\n\t\tdev_err(&client->dev, \"ALS samp rate field init failed.\\n\");\n\t\treturn PTR_ERR(data->reg_als_rate);\n\t}\n\n\tdata->reg_ps_rate = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t    reg_field_ps_rate);\n\tif (IS_ERR(data->reg_ps_rate)) {\n\t\tdev_err(&client->dev, \"PS samp rate field init failed.\\n\");\n\t\treturn PTR_ERR(data->reg_ps_rate);\n\t}\n\n\tdata->reg_als_prst = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t     reg_field_als_prst);\n\tif (IS_ERR(data->reg_als_prst)) {\n\t\tdev_err(&client->dev, \"ALS prst reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_als_prst);\n\t}\n\n\tdata->reg_ps_prst = devm_regmap_field_alloc(&client->dev, regmap,\n\t\t\t\t\t\t    reg_field_ps_prst);\n\tif (IS_ERR(data->reg_ps_prst)) {\n\t\tdev_err(&client->dev, \"PS prst reg field init failed.\\n\");\n\t\treturn PTR_ERR(data->reg_ps_prst);\n\t}\n\n\tret = regmap_read(data->regmap, LTR501_PART_ID, &partid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (id) {\n\t\tname = id->name;\n\t\tchip_idx = id->driver_data;\n\t} else  if (ACPI_HANDLE(&client->dev)) {\n\t\tname = ltr501_match_acpi_device(&client->dev, &chip_idx);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tdata->chip_info = &ltr501_chip_info_tbl[chip_idx];\n\n\tif ((partid >> 4) != data->chip_info->partid)\n\t\treturn -ENODEV;\n\n\tif (device_property_read_u32(&client->dev, \"proximity-near-level\",\n\t\t\t\t     &data->near_level))\n\t\tdata->near_level = 0;\n\n\tindio_dev->info = data->chip_info->info;\n\tindio_dev->channels = data->chip_info->channels;\n\tindio_dev->num_channels = data->chip_info->no_channels;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ltr501_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, ltr501_interrupt_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"ltr501_thresh_event\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"request irq (%d) failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tindio_dev->info = data->chip_info->info_no_irq;\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t ltr501_trigger_handler, NULL);\n\tif (ret)\n\t\tgoto powerdown_on_error;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_unreg_buffer;\n\n\treturn 0;\n\nerror_unreg_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\npowerdown_on_error:\n\tltr501_powerdown(data);\n\treturn ret;\n}\n\nstatic void ltr501_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tltr501_powerdown(iio_priv(indio_dev));\n}\n\nstatic int ltr501_suspend(struct device *dev)\n{\n\tstruct ltr501_data *data = iio_priv(i2c_get_clientdata(\n\t\t\t\t\t    to_i2c_client(dev)));\n\treturn ltr501_powerdown(data);\n}\n\nstatic int ltr501_resume(struct device *dev)\n{\n\tstruct ltr501_data *data = iio_priv(i2c_get_clientdata(\n\t\t\t\t\t    to_i2c_client(dev)));\n\n\treturn ltr501_write_contr(data, data->als_contr,\n\t\tdata->ps_contr);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ltr501_pm_ops, ltr501_suspend, ltr501_resume);\n\nstatic const struct acpi_device_id ltr_acpi_match[] = {\n\t{ \"LTER0501\", ltr501 },\n\t{ \"LTER0559\", ltr559 },\n\t{ \"LTER0301\", ltr301 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ltr_acpi_match);\n\nstatic const struct i2c_device_id ltr501_id[] = {\n\t{ \"ltr501\", ltr501 },\n\t{ \"ltr559\", ltr559 },\n\t{ \"ltr301\", ltr301 },\n\t{ \"ltr303\", ltr303 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltr501_id);\n\nstatic const struct of_device_id ltr501_of_match[] = {\n\t{ .compatible = \"liteon,ltr501\", },\n\t{ .compatible = \"liteon,ltr559\", },\n\t{ .compatible = \"liteon,ltr301\", },\n\t{ .compatible = \"liteon,ltr303\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ltr501_of_match);\n\nstatic struct i2c_driver ltr501_driver = {\n\t.driver = {\n\t\t.name   = LTR501_DRV_NAME,\n\t\t.of_match_table = ltr501_of_match,\n\t\t.pm\t= pm_sleep_ptr(&ltr501_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(ltr_acpi_match),\n\t},\n\t.probe = ltr501_probe,\n\t.remove\t= ltr501_remove,\n\t.id_table = ltr501_id,\n};\n\nmodule_i2c_driver(ltr501_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Lite-On LTR501 ambient light and proximity sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}