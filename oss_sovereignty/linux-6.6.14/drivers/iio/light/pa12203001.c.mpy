{
  "module_name": "pa12203001.c",
  "hash_id": "996f7462c9ad931e1af8f5af11c8ad409c0487a66dddcca4ce790f9cf430fc23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/pa12203001.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#define PA12203001_DRIVER_NAME\t\"pa12203001\"\n\n#define PA12203001_REG_CFG0\t\t0x00\n#define PA12203001_REG_CFG1\t\t0x01\n#define PA12203001_REG_CFG2\t\t0x02\n#define PA12203001_REG_CFG3\t\t0x03\n\n#define PA12203001_REG_ADL\t\t0x0b\n#define PA12203001_REG_PDH\t\t0x0e\n\n#define PA12203001_REG_POFS\t\t0x10\n#define PA12203001_REG_PSET\t\t0x11\n\n#define PA12203001_ALS_EN_MASK\t\tBIT(0)\n#define PA12203001_PX_EN_MASK\t\tBIT(1)\n#define PA12203001_PX_NORMAL_MODE_MASK\t\tGENMASK(7, 6)\n#define PA12203001_AFSR_MASK\t\tGENMASK(5, 4)\n#define PA12203001_AFSR_SHIFT\t\t4\n\n#define PA12203001_PSCAN\t\t\t0x03\n\n \n#define PA12203001_REG_CFG0_DEFAULT\t\t0x30\n\n \n#define PA12203001_REG_CFG1_DEFAULT\t\t0x20\n\n \n#define PA12203001_REG_CFG2_DEFAULT\t\t0xcc\n\n#define PA12203001_REG_CFG3_DEFAULT\t\t0x00\n\n#define PA12203001_SLEEP_DELAY_MS\t\t3000\n\n#define PA12203001_CHIP_ENABLE\t\t0xff\n#define PA12203001_CHIP_DISABLE\t\t0x00\n\n \nstatic const int pa12203001_scales[] = { 7629, 61036, 106813, 473029};\n\nstruct pa12203001_data {\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex lock;\n\n\tbool als_enabled;\n\tbool px_enabled;\n\tbool als_needs_enable;\n\tbool px_needs_enable;\n\n\tstruct regmap *map;\n};\n\nstatic const struct {\n\tu8 reg;\n\tu8 val;\n} regvals[] = {\n\t{PA12203001_REG_CFG0, PA12203001_REG_CFG0_DEFAULT},\n\t{PA12203001_REG_CFG1, PA12203001_REG_CFG1_DEFAULT},\n\t{PA12203001_REG_CFG2, PA12203001_REG_CFG2_DEFAULT},\n\t{PA12203001_REG_CFG3, PA12203001_REG_CFG3_DEFAULT},\n\t{PA12203001_REG_PSET, PA12203001_PSCAN},\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_scale_available,\n\t\t      \"0.007629 0.061036 0.106813 0.473029\");\n\nstatic struct attribute *pa12203001_attrs[] = {\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pa12203001_attr_group = {\n\t.attrs = pa12203001_attrs,\n};\n\nstatic const struct iio_chan_spec pa12203001_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}\n};\n\nstatic const struct regmap_range pa12203001_volatile_regs_ranges[] = {\n\tregmap_reg_range(PA12203001_REG_ADL, PA12203001_REG_ADL + 1),\n\tregmap_reg_range(PA12203001_REG_PDH, PA12203001_REG_PDH),\n};\n\nstatic const struct regmap_access_table pa12203001_volatile_regs = {\n\t.yes_ranges = pa12203001_volatile_regs_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(pa12203001_volatile_regs_ranges),\n};\n\nstatic const struct regmap_config pa12203001_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = PA12203001_REG_PSET,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &pa12203001_volatile_regs,\n};\n\nstatic inline int pa12203001_als_enable(struct pa12203001_data *data, u8 enable)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->map, PA12203001_REG_CFG0,\n\t\t\t\t PA12203001_ALS_EN_MASK, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->als_enabled = !!enable;\n\n\treturn 0;\n}\n\nstatic inline int pa12203001_px_enable(struct pa12203001_data *data, u8 enable)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->map, PA12203001_REG_CFG0,\n\t\t\t\t PA12203001_PX_EN_MASK, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->px_enabled = !!enable;\n\n\treturn 0;\n}\n\nstatic int pa12203001_set_power_state(struct pa12203001_data *data, bool on,\n\t\t\t\t      u8 mask)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (on && (mask & PA12203001_ALS_EN_MASK)) {\n\t\tmutex_lock(&data->lock);\n\t\tif (data->px_enabled) {\n\t\t\tret = pa12203001_als_enable(data,\n\t\t\t\t\t\t    PA12203001_ALS_EN_MASK);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tdata->als_needs_enable = true;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t}\n\n\tif (on && (mask & PA12203001_PX_EN_MASK)) {\n\t\tmutex_lock(&data->lock);\n\t\tif (data->als_enabled) {\n\t\t\tret = pa12203001_px_enable(data, PA12203001_PX_EN_MASK);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tdata->px_needs_enable = true;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t}\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&data->client->dev);\n\n\t} else {\n\t\tpm_runtime_mark_last_busy(&data->client->dev);\n\t\tret = pm_runtime_put_autosuspend(&data->client->dev);\n\t}\n\n\treturn ret;\n\nerr:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n\n#endif\n\treturn 0;\n}\n\nstatic int pa12203001_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan, int *val,\n\t\t\t       int *val2, long mask)\n{\n\tstruct pa12203001_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 dev_mask;\n\tunsigned int reg_byte;\n\t__le16 reg_word;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tdev_mask = PA12203001_ALS_EN_MASK;\n\t\t\tret = pa12203001_set_power_state(data, true, dev_mask);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tret = regmap_bulk_read(data->map, PA12203001_REG_ADL,\n\t\t\t\t\t       &reg_word, 2);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto reg_err;\n\n\t\t\t*val = le16_to_cpu(reg_word);\n\t\t\tret = pa12203001_set_power_state(data, false, dev_mask);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tdev_mask = PA12203001_PX_EN_MASK;\n\t\t\tret = pa12203001_set_power_state(data, true, dev_mask);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = regmap_read(data->map, PA12203001_REG_PDH,\n\t\t\t\t\t  &reg_byte);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto reg_err;\n\n\t\t\t*val = reg_byte;\n\t\t\tret = pa12203001_set_power_state(data, false, dev_mask);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regmap_read(data->map, PA12203001_REG_CFG0, &reg_byte);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = 0;\n\t\treg_byte = (reg_byte & PA12203001_AFSR_MASK);\n\t\t*val2 = pa12203001_scales[reg_byte >> 4];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nreg_err:\n\tpa12203001_set_power_state(data, false, dev_mask);\n\treturn ret;\n}\n\nstatic int pa12203001_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int val,\n\t\t\t\tint val2, long mask)\n{\n\tstruct pa12203001_data *data = iio_priv(indio_dev);\n\tint i, ret, new_val;\n\tunsigned int reg_byte;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regmap_read(data->map, PA12203001_REG_CFG0, &reg_byte);\n\t\tif (val != 0 || ret < 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(pa12203001_scales); i++) {\n\t\t\tif (val2 == pa12203001_scales[i]) {\n\t\t\t\tnew_val = i << PA12203001_AFSR_SHIFT;\n\t\t\t\treturn regmap_update_bits(data->map,\n\t\t\t\t\t\t\t  PA12203001_REG_CFG0,\n\t\t\t\t\t\t\t  PA12203001_AFSR_MASK,\n\t\t\t\t\t\t\t  new_val);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info pa12203001_info = {\n\t.read_raw = pa12203001_read_raw,\n\t.write_raw = pa12203001_write_raw,\n\t.attrs = &pa12203001_attr_group,\n};\n\nstatic int pa12203001_init(struct iio_dev *indio_dev)\n{\n\tstruct pa12203001_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(regvals); i++) {\n\t\tret = regmap_write(data->map, regvals[i].reg, regvals[i].val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pa12203001_power_chip(struct iio_dev *indio_dev, u8 state)\n{\n\tstruct pa12203001_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = pa12203001_als_enable(data, state);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = pa12203001_px_enable(data, state);\n\nout:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int pa12203001_probe(struct i2c_client *client)\n{\n\tstruct pa12203001_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev,\n\t\t\t\t\t  sizeof(struct pa12203001_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tdata->map = devm_regmap_init_i2c(client, &pa12203001_regmap_config);\n\tif (IS_ERR(data->map))\n\t\treturn PTR_ERR(data->map);\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &pa12203001_info;\n\tindio_dev->name = PA12203001_DRIVER_NAME;\n\tindio_dev->channels = pa12203001_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(pa12203001_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = pa12203001_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pa12203001_power_chip(indio_dev, PA12203001_CHIP_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t PA12203001_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tpa12203001_power_chip(indio_dev, PA12203001_CHIP_DISABLE);\n\treturn ret;\n}\n\nstatic void pa12203001_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tret = pa12203001_power_chip(indio_dev, PA12203001_CHIP_DISABLE);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to power down (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\n#if defined(CONFIG_PM_SLEEP) || defined(CONFIG_PM)\nstatic int pa12203001_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn pa12203001_power_chip(indio_dev, PA12203001_CHIP_DISABLE);\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pa12203001_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn pa12203001_power_chip(indio_dev, PA12203001_CHIP_ENABLE);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int pa12203001_runtime_resume(struct device *dev)\n{\n\tstruct pa12203001_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\tmutex_lock(&data->lock);\n\tif (data->als_needs_enable) {\n\t\tpa12203001_als_enable(data, PA12203001_ALS_EN_MASK);\n\t\tdata->als_needs_enable = false;\n\t}\n\tif (data->px_needs_enable) {\n\t\tpa12203001_px_enable(data, PA12203001_PX_EN_MASK);\n\t\tdata->px_needs_enable = false;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops pa12203001_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pa12203001_suspend, pa12203001_resume)\n\tSET_RUNTIME_PM_OPS(pa12203001_suspend, pa12203001_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id pa12203001_acpi_match[] = {\n\t{ \"TXCPA122\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, pa12203001_acpi_match);\n\nstatic const struct i2c_device_id pa12203001_id[] = {\n\t\t{ \"txcpa122\", 0 },\n\t\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, pa12203001_id);\n\nstatic struct i2c_driver pa12203001_driver = {\n\t.driver = {\n\t\t.name = PA12203001_DRIVER_NAME,\n\t\t.pm = &pa12203001_pm_ops,\n\t\t.acpi_match_table = ACPI_PTR(pa12203001_acpi_match),\n\t},\n\t.probe = pa12203001_probe,\n\t.remove = pa12203001_remove,\n\t.id_table = pa12203001_id,\n\n};\nmodule_i2c_driver(pa12203001_driver);\n\nMODULE_AUTHOR(\"Adriana Reus <adriana.reus@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for TXC PA12203001 Proximity and Light Sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}