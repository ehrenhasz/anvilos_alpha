{
  "module_name": "st_uvis25_core.c",
  "hash_id": "df057ee9c340d3e751d295090506105673734e4d021a6bdd4f6fdb002f88f5ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/st_uvis25_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/iio/sysfs.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/buffer.h>\n#include <linux/regmap.h>\n\n#include \"st_uvis25.h\"\n\n#define ST_UVIS25_REG_WHOAMI_ADDR\t0x0f\n#define ST_UVIS25_REG_WHOAMI_VAL\t0xca\n#define ST_UVIS25_REG_CTRL1_ADDR\t0x20\n#define ST_UVIS25_REG_ODR_MASK\t\tBIT(0)\n#define ST_UVIS25_REG_BDU_MASK\t\tBIT(1)\n#define ST_UVIS25_REG_CTRL2_ADDR\t0x21\n#define ST_UVIS25_REG_BOOT_MASK\t\tBIT(7)\n#define ST_UVIS25_REG_CTRL3_ADDR\t0x22\n#define ST_UVIS25_REG_HL_MASK\t\tBIT(7)\n#define ST_UVIS25_REG_STATUS_ADDR\t0x27\n#define ST_UVIS25_REG_UV_DA_MASK\tBIT(0)\n#define ST_UVIS25_REG_OUT_ADDR\t\t0x28\n\nstatic const struct iio_chan_spec st_uvis25_channels[] = {\n\t{\n\t\t.type = IIO_UVINDEX,\n\t\t.address = ST_UVIS25_REG_OUT_ADDR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 8,\n\t\t\t.storagebits = 8,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic int st_uvis25_check_whoami(struct st_uvis25_hw *hw)\n{\n\tint err, data;\n\n\terr = regmap_read(hw->regmap, ST_UVIS25_REG_WHOAMI_ADDR, &data);\n\tif (err < 0) {\n\t\tdev_err(regmap_get_device(hw->regmap),\n\t\t\t\"failed to read whoami register\\n\");\n\t\treturn err;\n\t}\n\n\tif (data != ST_UVIS25_REG_WHOAMI_VAL) {\n\t\tdev_err(regmap_get_device(hw->regmap),\n\t\t\t\"wrong whoami {%02x vs %02x}\\n\",\n\t\t\tdata, ST_UVIS25_REG_WHOAMI_VAL);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_uvis25_set_enable(struct st_uvis25_hw *hw, bool enable)\n{\n\tint err;\n\n\terr = regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL1_ADDR,\n\t\t\t\t ST_UVIS25_REG_ODR_MASK, enable);\n\tif (err < 0)\n\t\treturn err;\n\n\thw->enabled = enable;\n\n\treturn 0;\n}\n\nstatic int st_uvis25_read_oneshot(struct st_uvis25_hw *hw, u8 addr, int *val)\n{\n\tint err;\n\n\terr = st_uvis25_set_enable(hw, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(1500);\n\n\t \n\terr = st_uvis25_set_enable(hw, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_read(hw->regmap, addr, val);\n\n\treturn err < 0 ? err : IIO_VAL_INT;\n}\n\nstatic int st_uvis25_read_raw(struct iio_dev *iio_dev,\n\t\t\t      struct iio_chan_spec const *ch,\n\t\t\t      int *val, int *val2, long mask)\n{\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED: {\n\t\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\n\t\t \n\t\tif (hw->irq > 0)\n\t\t\tdisable_irq(hw->irq);\n\t\tret = st_uvis25_read_oneshot(hw, ch->address, val);\n\t\tif (hw->irq > 0)\n\t\t\tenable_irq(hw->irq);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn ret;\n}\n\nstatic irqreturn_t st_uvis25_trigger_handler_thread(int irq, void *private)\n{\n\tstruct st_uvis25_hw *hw = private;\n\tint err, status;\n\n\terr = regmap_read(hw->regmap, ST_UVIS25_REG_STATUS_ADDR, &status);\n\tif (err < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (!(status & ST_UVIS25_REG_UV_DA_MASK))\n\t\treturn IRQ_NONE;\n\n\tiio_trigger_poll_nested(hw->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int st_uvis25_allocate_trigger(struct iio_dev *iio_dev)\n{\n\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\tstruct device *dev = regmap_get_device(hw->regmap);\n\tbool irq_active_low = false;\n\tunsigned long irq_type;\n\tint err;\n\n\tirq_type = irqd_get_trigger_type(irq_get_irq_data(hw->irq));\n\n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_HIGH:\n\tcase IRQF_TRIGGER_RISING:\n\t\tbreak;\n\tcase IRQF_TRIGGER_LOW:\n\tcase IRQF_TRIGGER_FALLING:\n\t\tirq_active_low = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"mode %lx unsupported\\n\", irq_type);\n\t\treturn -EINVAL;\n\t}\n\n\terr = regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL3_ADDR,\n\t\t\t\t ST_UVIS25_REG_HL_MASK, irq_active_low);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(dev, hw->irq, NULL,\n\t\t\t\t\tst_uvis25_trigger_handler_thread,\n\t\t\t\t\tirq_type | IRQF_ONESHOT,\n\t\t\t\t\tiio_dev->name, hw);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request trigger irq %d\\n\",\n\t\t\thw->irq);\n\t\treturn err;\n\t}\n\n\thw->trig = devm_iio_trigger_alloc(dev, \"%s-trigger\",\n\t\t\t\t\t  iio_dev->name);\n\tif (!hw->trig)\n\t\treturn -ENOMEM;\n\n\tiio_trigger_set_drvdata(hw->trig, iio_dev);\n\n\treturn devm_iio_trigger_register(dev, hw->trig);\n}\n\nstatic int st_uvis25_buffer_preenable(struct iio_dev *iio_dev)\n{\n\treturn st_uvis25_set_enable(iio_priv(iio_dev), true);\n}\n\nstatic int st_uvis25_buffer_postdisable(struct iio_dev *iio_dev)\n{\n\treturn st_uvis25_set_enable(iio_priv(iio_dev), false);\n}\n\nstatic const struct iio_buffer_setup_ops st_uvis25_buffer_ops = {\n\t.preenable = st_uvis25_buffer_preenable,\n\t.postdisable = st_uvis25_buffer_postdisable,\n};\n\nstatic irqreturn_t st_uvis25_buffer_handler_thread(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *iio_dev = pf->indio_dev;\n\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(hw->regmap, ST_UVIS25_REG_OUT_ADDR, &val);\n\tif (err < 0)\n\t\tgoto out;\n\n\thw->scan.chan = val;\n\n\tiio_push_to_buffers_with_timestamp(iio_dev, &hw->scan,\n\t\t\t\t\t   iio_get_time_ns(iio_dev));\n\nout:\n\tiio_trigger_notify_done(hw->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int st_uvis25_allocate_buffer(struct iio_dev *iio_dev)\n{\n\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\n\treturn devm_iio_triggered_buffer_setup(regmap_get_device(hw->regmap),\n\t\t\t\t\t       iio_dev, NULL,\n\t\t\t\t\t       st_uvis25_buffer_handler_thread,\n\t\t\t\t\t       &st_uvis25_buffer_ops);\n}\n\nstatic const struct iio_info st_uvis25_info = {\n\t.read_raw = st_uvis25_read_raw,\n};\n\nstatic int st_uvis25_init_sensor(struct st_uvis25_hw *hw)\n{\n\tint err;\n\n\terr = regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL2_ADDR,\n\t\t\t\t ST_UVIS25_REG_BOOT_MASK, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(2000);\n\n\treturn regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL1_ADDR,\n\t\t\t\t  ST_UVIS25_REG_BDU_MASK, 1);\n}\n\nint st_uvis25_probe(struct device *dev, int irq, struct regmap *regmap)\n{\n\tstruct st_uvis25_hw *hw;\n\tstruct iio_dev *iio_dev;\n\tint err;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*hw));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, (void *)iio_dev);\n\n\thw = iio_priv(iio_dev);\n\thw->irq = irq;\n\thw->regmap = regmap;\n\n\terr = st_uvis25_check_whoami(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->channels = st_uvis25_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(st_uvis25_channels);\n\tiio_dev->name = ST_UVIS25_DEV_NAME;\n\tiio_dev->info = &st_uvis25_info;\n\n\terr = st_uvis25_init_sensor(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (hw->irq > 0) {\n\t\terr = st_uvis25_allocate_buffer(iio_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = st_uvis25_allocate_trigger(iio_dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(dev, iio_dev);\n}\nEXPORT_SYMBOL_NS(st_uvis25_probe, IIO_UVIS25);\n\nstatic int st_uvis25_suspend(struct device *dev)\n{\n\tstruct iio_dev *iio_dev = dev_get_drvdata(dev);\n\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\n\treturn regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL1_ADDR,\n\t\t\t\t  ST_UVIS25_REG_ODR_MASK, 0);\n}\n\nstatic int st_uvis25_resume(struct device *dev)\n{\n\tstruct iio_dev *iio_dev = dev_get_drvdata(dev);\n\tstruct st_uvis25_hw *hw = iio_priv(iio_dev);\n\n\tif (hw->enabled)\n\t\treturn regmap_update_bits(hw->regmap, ST_UVIS25_REG_CTRL1_ADDR,\n\t\t\t\t\t  ST_UVIS25_REG_ODR_MASK, 1);\n\n\treturn 0;\n}\n\nEXPORT_NS_SIMPLE_DEV_PM_OPS(st_uvis25_pm_ops, st_uvis25_suspend, st_uvis25_resume, IIO_UVIS25);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics uvis25 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}