{
  "module_name": "al3010.c",
  "hash_id": "05e72c2c309a7cb6246b987fb271aa0b06413da1b84a4f7cd2c996a80f35bf0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/al3010.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AL3010_DRV_NAME \"al3010\"\n\n#define AL3010_REG_SYSTEM\t\t0x00\n#define AL3010_REG_DATA_LOW\t\t0x0c\n#define AL3010_REG_CONFIG\t\t0x10\n\n#define AL3010_CONFIG_DISABLE\t\t0x00\n#define AL3010_CONFIG_ENABLE\t\t0x01\n\n#define AL3010_GAIN_MASK\t\tGENMASK(6,4)\n\n#define AL3010_SCALE_AVAILABLE \"1.1872 0.2968 0.0742 0.018\"\n\nenum al3xxxx_range {\n\tAL3XXX_RANGE_1,  \n\tAL3XXX_RANGE_2,  \n\tAL3XXX_RANGE_3,  \n\tAL3XXX_RANGE_4   \n};\n\nstatic const int al3010_scales[][2] = {\n\t{0, 1187200}, {0, 296800}, {0, 74200}, {0, 18600}\n};\n\nstruct al3010_data {\n\tstruct i2c_client *client;\n};\n\nstatic const struct iio_chan_spec al3010_channels[] = {\n\t{\n\t\t.type\t= IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t}\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_scale_available, AL3010_SCALE_AVAILABLE);\n\nstatic struct attribute *al3010_attributes[] = {\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group al3010_attribute_group = {\n\t.attrs = al3010_attributes,\n};\n\nstatic int al3010_set_pwr(struct i2c_client *client, bool pwr)\n{\n\tu8 val = pwr ? AL3010_CONFIG_ENABLE : AL3010_CONFIG_DISABLE;\n\treturn i2c_smbus_write_byte_data(client, AL3010_REG_SYSTEM, val);\n}\n\nstatic void al3010_set_pwr_off(void *_data)\n{\n\tstruct al3010_data *data = _data;\n\n\tal3010_set_pwr(data->client, false);\n}\n\nstatic int al3010_init(struct al3010_data *data)\n{\n\tint ret;\n\n\tret = al3010_set_pwr(data->client, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, AL3010_REG_CONFIG,\n\t\t\t\t\tFIELD_PREP(AL3010_GAIN_MASK,\n\t\t\t\t\t\t   AL3XXX_RANGE_3));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int al3010_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct al3010_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t       AL3010_REG_DATA_LOW);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       AL3010_REG_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = FIELD_GET(AL3010_GAIN_MASK, ret);\n\t\t*val = al3010_scales[ret][0];\n\t\t*val2 = al3010_scales[ret][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int al3010_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int val,\n\t\t\t    int val2, long mask)\n{\n\tstruct al3010_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(al3010_scales); i++) {\n\t\t\tif (val != al3010_scales[i][0] ||\n\t\t\t    val2 != al3010_scales[i][1])\n\t\t\t\tcontinue;\n\n\t\t\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tAL3010_REG_CONFIG,\n\t\t\t\t\tFIELD_PREP(AL3010_GAIN_MASK, i));\n\t\t}\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info al3010_info = {\n\t.read_raw\t= al3010_read_raw,\n\t.write_raw\t= al3010_write_raw,\n\t.attrs\t\t= &al3010_attribute_group,\n};\n\nstatic int al3010_probe(struct i2c_client *client)\n{\n\tstruct al3010_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &al3010_info;\n\tindio_dev->name = AL3010_DRV_NAME;\n\tindio_dev->channels = al3010_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(al3010_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = al3010_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"al3010 chip init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\tal3010_set_pwr_off,\n\t\t\t\t\tdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int al3010_suspend(struct device *dev)\n{\n\treturn al3010_set_pwr(to_i2c_client(dev), false);\n}\n\nstatic int al3010_resume(struct device *dev)\n{\n\treturn al3010_set_pwr(to_i2c_client(dev), true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(al3010_pm_ops, al3010_suspend, al3010_resume);\n\nstatic const struct i2c_device_id al3010_id[] = {\n\t{\"al3010\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, al3010_id);\n\nstatic const struct of_device_id al3010_of_match[] = {\n\t{ .compatible = \"dynaimage,al3010\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, al3010_of_match);\n\nstatic struct i2c_driver al3010_driver = {\n\t.driver = {\n\t\t.name = AL3010_DRV_NAME,\n\t\t.of_match_table = al3010_of_match,\n\t\t.pm = pm_sleep_ptr(&al3010_pm_ops),\n\t},\n\t.probe\t\t= al3010_probe,\n\t.id_table\t= al3010_id,\n};\nmodule_i2c_driver(al3010_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@nxp.com>\");\nMODULE_AUTHOR(\"David Heidelberg <david@ixit.cz>\");\nMODULE_DESCRIPTION(\"AL3010 Ambient Light Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}