{
  "module_name": "isl29018.c",
  "hash_id": "a27eea71c6ceb19585de823264ba6797716ca0c39d4371c14f924f7792034e4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/isl29018.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/acpi.h>\n\n#define ISL29018_CONV_TIME_MS\t\t100\n\n#define ISL29018_REG_ADD_COMMAND1\t0x00\n#define ISL29018_CMD1_OPMODE_SHIFT\t5\n#define ISL29018_CMD1_OPMODE_MASK\t(7 << ISL29018_CMD1_OPMODE_SHIFT)\n#define ISL29018_CMD1_OPMODE_POWER_DOWN\t0\n#define ISL29018_CMD1_OPMODE_ALS_ONCE\t1\n#define ISL29018_CMD1_OPMODE_IR_ONCE\t2\n#define ISL29018_CMD1_OPMODE_PROX_ONCE\t3\n\n#define ISL29018_REG_ADD_COMMAND2\t0x01\n#define ISL29018_CMD2_RESOLUTION_SHIFT\t2\n#define ISL29018_CMD2_RESOLUTION_MASK\t(0x3 << ISL29018_CMD2_RESOLUTION_SHIFT)\n\n#define ISL29018_CMD2_RANGE_SHIFT\t0\n#define ISL29018_CMD2_RANGE_MASK\t(0x3 << ISL29018_CMD2_RANGE_SHIFT)\n\n#define ISL29018_CMD2_SCHEME_SHIFT\t7\n#define ISL29018_CMD2_SCHEME_MASK\t(0x1 << ISL29018_CMD2_SCHEME_SHIFT)\n\n#define ISL29018_REG_ADD_DATA_LSB\t0x02\n#define ISL29018_REG_ADD_DATA_MSB\t0x03\n\n#define ISL29018_REG_TEST\t\t0x08\n#define ISL29018_TEST_SHIFT\t\t0\n#define ISL29018_TEST_MASK\t\t(0xFF << ISL29018_TEST_SHIFT)\n\n#define ISL29035_REG_DEVICE_ID\t\t0x0F\n#define ISL29035_DEVICE_ID_SHIFT\t0x03\n#define ISL29035_DEVICE_ID_MASK\t\t(0x7 << ISL29035_DEVICE_ID_SHIFT)\n#define ISL29035_DEVICE_ID\t\t0x5\n#define ISL29035_BOUT_SHIFT\t\t0x07\n#define ISL29035_BOUT_MASK\t\t(0x01 << ISL29035_BOUT_SHIFT)\n\nenum isl29018_int_time {\n\tISL29018_INT_TIME_16,\n\tISL29018_INT_TIME_12,\n\tISL29018_INT_TIME_8,\n\tISL29018_INT_TIME_4,\n};\n\nstatic const unsigned int isl29018_int_utimes[3][4] = {\n\t{90000, 5630, 351, 21},\n\t{90000, 5600, 352, 22},\n\t{105000, 6500, 410, 25},\n};\n\nstatic const struct isl29018_scale {\n\tunsigned int scale;\n\tunsigned int uscale;\n} isl29018_scales[4][4] = {\n\t{ {0, 15258}, {0, 61035}, {0, 244140}, {0, 976562} },\n\t{ {0, 244140}, {0, 976562}, {3, 906250}, {15, 625000} },\n\t{ {3, 906250}, {15, 625000}, {62, 500000}, {250, 0} },\n\t{ {62, 500000}, {250, 0}, {1000, 0}, {4000, 0} }\n};\n\nstruct isl29018_chip {\n\tstruct regmap\t\t*regmap;\n\tstruct mutex\t\tlock;\n\tint\t\t\ttype;\n\tunsigned int\t\tcalibscale;\n\tunsigned int\t\tucalibscale;\n\tunsigned int\t\tint_time;\n\tstruct isl29018_scale\tscale;\n\tint\t\t\tprox_scheme;\n\tbool\t\t\tsuspended;\n\tstruct regulator\t*vcc_reg;\n};\n\nstatic int isl29018_set_integration_time(struct isl29018_chip *chip,\n\t\t\t\t\t unsigned int utime)\n{\n\tunsigned int i;\n\tint ret;\n\tunsigned int int_time, new_int_time;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i) {\n\t\tif (utime == isl29018_int_utimes[chip->type][i]) {\n\t\t\tnew_int_time = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(isl29018_int_utimes[chip->type]))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\n\t\t\t\t ISL29018_CMD2_RESOLUTION_MASK,\n\t\t\t\t i << ISL29018_CMD2_RESOLUTION_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tint_time = chip->int_time;\n\tfor (i = 0; i < ARRAY_SIZE(isl29018_scales[int_time]); ++i) {\n\t\tif (chip->scale.scale == isl29018_scales[int_time][i].scale &&\n\t\t    chip->scale.uscale == isl29018_scales[int_time][i].uscale) {\n\t\t\tchip->scale = isl29018_scales[new_int_time][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tchip->int_time = new_int_time;\n\n\treturn 0;\n}\n\nstatic int isl29018_set_scale(struct isl29018_chip *chip, int scale, int uscale)\n{\n\tunsigned int i;\n\tint ret;\n\tstruct isl29018_scale new_scale;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i) {\n\t\tif (scale == isl29018_scales[chip->int_time][i].scale &&\n\t\t    uscale == isl29018_scales[chip->int_time][i].uscale) {\n\t\t\tnew_scale = isl29018_scales[chip->int_time][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(isl29018_scales[chip->int_time]))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\n\t\t\t\t ISL29018_CMD2_RANGE_MASK,\n\t\t\t\t i << ISL29018_CMD2_RANGE_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->scale = new_scale;\n\n\treturn 0;\n}\n\nstatic int isl29018_read_sensor_input(struct isl29018_chip *chip, int mode)\n{\n\tint status;\n\tunsigned int lsb;\n\tunsigned int msb;\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\n\t \n\tstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1,\n\t\t\t      mode << ISL29018_CMD1_OPMODE_SHIFT);\n\tif (status) {\n\t\tdev_err(dev,\n\t\t\t\"Error in setting operating mode err %d\\n\", status);\n\t\treturn status;\n\t}\n\tmsleep(ISL29018_CONV_TIME_MS);\n\tstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_LSB, &lsb);\n\tif (status < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Error in reading LSB DATA with err %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_MSB, &msb);\n\tif (status < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Error in reading MSB DATA with error %d\\n\", status);\n\t\treturn status;\n\t}\n\tdev_vdbg(dev, \"MSB 0x%x and LSB 0x%x\\n\", msb, lsb);\n\n\treturn (msb << 8) | lsb;\n}\n\nstatic int isl29018_read_lux(struct isl29018_chip *chip, int *lux)\n{\n\tint lux_data;\n\tunsigned int data_x_range;\n\n\tlux_data = isl29018_read_sensor_input(chip,\n\t\t\t\t\t      ISL29018_CMD1_OPMODE_ALS_ONCE);\n\tif (lux_data < 0)\n\t\treturn lux_data;\n\n\tdata_x_range = lux_data * chip->scale.scale +\n\t\t       lux_data * chip->scale.uscale / 1000000;\n\t*lux = data_x_range * chip->calibscale +\n\t       data_x_range * chip->ucalibscale / 1000000;\n\n\treturn 0;\n}\n\nstatic int isl29018_read_ir(struct isl29018_chip *chip, int *ir)\n{\n\tint ir_data;\n\n\tir_data = isl29018_read_sensor_input(chip,\n\t\t\t\t\t     ISL29018_CMD1_OPMODE_IR_ONCE);\n\tif (ir_data < 0)\n\t\treturn ir_data;\n\n\t*ir = ir_data;\n\n\treturn 0;\n}\n\nstatic int isl29018_read_proximity_ir(struct isl29018_chip *chip, int scheme,\n\t\t\t\t      int *near_ir)\n{\n\tint status;\n\tint prox_data = -1;\n\tint ir_data = -1;\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\n\t \n\tstatus = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\n\t\t\t\t    ISL29018_CMD2_SCHEME_MASK,\n\t\t\t\t    scheme << ISL29018_CMD2_SCHEME_SHIFT);\n\tif (status) {\n\t\tdev_err(dev, \"Error in setting operating mode\\n\");\n\t\treturn status;\n\t}\n\n\tprox_data = isl29018_read_sensor_input(chip,\n\t\t\t\t\t       ISL29018_CMD1_OPMODE_PROX_ONCE);\n\tif (prox_data < 0)\n\t\treturn prox_data;\n\n\tif (scheme == 1) {\n\t\t*near_ir = prox_data;\n\t\treturn 0;\n\t}\n\n\tir_data = isl29018_read_sensor_input(chip,\n\t\t\t\t\t     ISL29018_CMD1_OPMODE_IR_ONCE);\n\tif (ir_data < 0)\n\t\treturn ir_data;\n\n\tif (prox_data >= ir_data)\n\t\t*near_ir = prox_data - ir_data;\n\telse\n\t\t*near_ir = 0;\n\n\treturn 0;\n}\n\nstatic ssize_t in_illuminance_scale_available_show\n\t\t\t(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\tunsigned int i;\n\tint len = 0;\n\n\tmutex_lock(&chip->lock);\n\tfor (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i)\n\t\tlen += sprintf(buf + len, \"%d.%06d \",\n\t\t\t       isl29018_scales[chip->int_time][i].scale,\n\t\t\t       isl29018_scales[chip->int_time][i].uscale);\n\tmutex_unlock(&chip->lock);\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t in_illuminance_integration_time_available_show\n\t\t\t(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\tunsigned int i;\n\tint len = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i)\n\t\tlen += sprintf(buf + len, \"0.%06d \",\n\t\t\t       isl29018_int_utimes[chip->type][i]);\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\n \nstatic ssize_t proximity_on_chip_ambient_infrared_suppression_show\n\t\t\t(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\n\t \n\treturn sprintf(buf, \"%d\\n\", chip->prox_scheme);\n}\n\nstatic ssize_t proximity_on_chip_ambient_infrared_suppression_store\n\t\t\t(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\tint val;\n\n\tif (kstrtoint(buf, 10, &val))\n\t\treturn -EINVAL;\n\tif (!(val == 0 || val == 1))\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&chip->lock);\n\tchip->prox_scheme = val;\n\tmutex_unlock(&chip->lock);\n\n\treturn count;\n}\n\nstatic int isl29018_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val,\n\t\t\t      int val2,\n\t\t\t      long mask)\n{\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->suspended) {\n\t\tret = -EBUSY;\n\t\tgoto write_done;\n\t}\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\tchip->calibscale = val;\n\t\t\tchip->ucalibscale = val2;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT && !val)\n\t\t\tret = isl29018_set_integration_time(chip, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\tret = isl29018_set_scale(chip, val, val2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nwrite_done:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int isl29018_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long mask)\n{\n\tint ret = -EINVAL;\n\tstruct isl29018_chip *chip = iio_priv(indio_dev);\n\n\tmutex_lock(&chip->lock);\n\tif (chip->suspended) {\n\t\tret = -EBUSY;\n\t\tgoto read_done;\n\t}\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = isl29018_read_lux(chip, val);\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tret = isl29018_read_ir(chip, val);\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = isl29018_read_proximity_ir(chip,\n\t\t\t\t\t\t\t chip->prox_scheme,\n\t\t\t\t\t\t\t val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret)\n\t\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = 0;\n\t\t\t*val2 = isl29018_int_utimes[chip->type][chip->int_time];\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = chip->scale.scale;\n\t\t\t*val2 = chip->scale.uscale;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = chip->calibscale;\n\t\t\t*val2 = chip->ucalibscale;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nread_done:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\n#define ISL29018_LIGHT_CHANNEL {\t\t\t\t\t\\\n\t.type = IIO_LIGHT,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = 0,\t\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\t\t\\\n\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_INT_TIME),\t\t\t\t\t\\\n}\n\n#define ISL29018_IR_CHANNEL {\t\t\t\t\t\t\\\n\t.type = IIO_INTENSITY,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.channel2 = IIO_MOD_LIGHT_IR,\t\t\t\t\t\\\n}\n\n#define ISL29018_PROXIMITY_CHANNEL {\t\t\t\t\t\\\n\t.type = IIO_PROXIMITY,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n}\n\nstatic const struct iio_chan_spec isl29018_channels[] = {\n\tISL29018_LIGHT_CHANNEL,\n\tISL29018_IR_CHANNEL,\n\tISL29018_PROXIMITY_CHANNEL,\n};\n\nstatic const struct iio_chan_spec isl29023_channels[] = {\n\tISL29018_LIGHT_CHANNEL,\n\tISL29018_IR_CHANNEL,\n};\n\nstatic IIO_DEVICE_ATTR_RO(in_illuminance_integration_time_available, 0);\nstatic IIO_DEVICE_ATTR_RO(in_illuminance_scale_available, 0);\nstatic IIO_DEVICE_ATTR_RW(proximity_on_chip_ambient_infrared_suppression, 0);\n\n#define ISL29018_DEV_ATTR(name) (&iio_dev_attr_##name.dev_attr.attr)\n\nstatic struct attribute *isl29018_attributes[] = {\n\tISL29018_DEV_ATTR(in_illuminance_scale_available),\n\tISL29018_DEV_ATTR(in_illuminance_integration_time_available),\n\tISL29018_DEV_ATTR(proximity_on_chip_ambient_infrared_suppression),\n\tNULL\n};\n\nstatic struct attribute *isl29023_attributes[] = {\n\tISL29018_DEV_ATTR(in_illuminance_scale_available),\n\tISL29018_DEV_ATTR(in_illuminance_integration_time_available),\n\tNULL\n};\n\nstatic const struct attribute_group isl29018_group = {\n\t.attrs = isl29018_attributes,\n};\n\nstatic const struct attribute_group isl29023_group = {\n\t.attrs = isl29023_attributes,\n};\n\nenum {\n\tisl29018,\n\tisl29023,\n\tisl29035,\n};\n\nstatic int isl29018_chip_init(struct isl29018_chip *chip)\n{\n\tint status;\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\n\tif (chip->type == isl29035) {\n\t\tunsigned int id;\n\n\t\tstatus = regmap_read(chip->regmap, ISL29035_REG_DEVICE_ID, &id);\n\t\tif (status < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Error reading ID register with error %d\\n\",\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\tid = (id & ISL29035_DEVICE_ID_MASK) >> ISL29035_DEVICE_ID_SHIFT;\n\n\t\tif (id != ISL29035_DEVICE_ID)\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\tstatus = regmap_update_bits(chip->regmap,\n\t\t\t\t\t    ISL29035_REG_DEVICE_ID,\n\t\t\t\t\t    ISL29035_BOUT_MASK, 0);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = regmap_write(chip->regmap, ISL29018_REG_TEST, 0x0);\n\tif (status < 0) {\n\t\tdev_err(dev, \"Failed to clear isl29018 TEST reg.(%d)\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1, 0);\n\tif (status < 0) {\n\t\tdev_err(dev, \"Failed to clear isl29018 CMD1 reg.(%d)\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tusleep_range(1000, 2000);\t \n\n\t \n\tstatus = isl29018_set_scale(chip, chip->scale.scale,\n\t\t\t\t    chip->scale.uscale);\n\tif (status < 0) {\n\t\tdev_err(dev, \"Init of isl29018 fails\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = isl29018_set_integration_time(chip,\n\t\t\tisl29018_int_utimes[chip->type][chip->int_time]);\n\tif (status < 0)\n\t\tdev_err(dev, \"Init of isl29018 fails\\n\");\n\n\treturn status;\n}\n\nstatic const struct iio_info isl29018_info = {\n\t.attrs = &isl29018_group,\n\t.read_raw = isl29018_read_raw,\n\t.write_raw = isl29018_write_raw,\n};\n\nstatic const struct iio_info isl29023_info = {\n\t.attrs = &isl29023_group,\n\t.read_raw = isl29018_read_raw,\n\t.write_raw = isl29018_write_raw,\n};\n\nstatic bool isl29018_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ISL29018_REG_ADD_DATA_LSB:\n\tcase ISL29018_REG_ADD_DATA_MSB:\n\tcase ISL29018_REG_ADD_COMMAND1:\n\tcase ISL29018_REG_TEST:\n\tcase ISL29035_REG_DEVICE_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config isl29018_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = isl29018_is_volatile_reg,\n\t.max_register = ISL29018_REG_TEST,\n\t.num_reg_defaults_raw = ISL29018_REG_TEST + 1,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_config isl29035_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = isl29018_is_volatile_reg,\n\t.max_register = ISL29035_REG_DEVICE_ID,\n\t.num_reg_defaults_raw = ISL29035_REG_DEVICE_ID + 1,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstruct isl29018_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tconst struct iio_info *indio_info;\n\tconst struct regmap_config *regmap_cfg;\n};\n\nstatic const struct isl29018_chip_info isl29018_chip_info_tbl[] = {\n\t[isl29018] = {\n\t\t.channels = isl29018_channels,\n\t\t.num_channels = ARRAY_SIZE(isl29018_channels),\n\t\t.indio_info = &isl29018_info,\n\t\t.regmap_cfg = &isl29018_regmap_config,\n\t},\n\t[isl29023] = {\n\t\t.channels = isl29023_channels,\n\t\t.num_channels = ARRAY_SIZE(isl29023_channels),\n\t\t.indio_info = &isl29023_info,\n\t\t.regmap_cfg = &isl29018_regmap_config,\n\t},\n\t[isl29035] = {\n\t\t.channels = isl29023_channels,\n\t\t.num_channels = ARRAY_SIZE(isl29023_channels),\n\t\t.indio_info = &isl29023_info,\n\t\t.regmap_cfg = &isl29035_regmap_config,\n\t},\n};\n\nstatic const char *isl29018_match_acpi_device(struct device *dev, int *data)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\n\tif (!id)\n\t\treturn NULL;\n\n\t*data = (int)id->driver_data;\n\n\treturn dev_name(dev);\n}\n\nstatic void isl29018_disable_regulator_action(void *_data)\n{\n\tstruct isl29018_chip *chip = _data;\n\tint err;\n\n\terr = regulator_disable(chip->vcc_reg);\n\tif (err)\n\t\tpr_err(\"failed to disable isl29018's VCC regulator!\\n\");\n}\n\nstatic int isl29018_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct isl29018_chip *chip;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\tconst char *name = NULL;\n\tint dev_id = 0;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tif (id) {\n\t\tname = id->name;\n\t\tdev_id = id->driver_data;\n\t}\n\n\tif (ACPI_HANDLE(&client->dev))\n\t\tname = isl29018_match_acpi_device(&client->dev, &dev_id);\n\n\tmutex_init(&chip->lock);\n\n\tchip->type = dev_id;\n\tchip->calibscale = 1;\n\tchip->ucalibscale = 0;\n\tchip->int_time = ISL29018_INT_TIME_16;\n\tchip->scale = isl29018_scales[chip->int_time][0];\n\tchip->suspended = false;\n\n\tchip->vcc_reg = devm_regulator_get(&client->dev, \"vcc\");\n\tif (IS_ERR(chip->vcc_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(chip->vcc_reg),\n\t\t\t\t     \"failed to get VCC regulator!\\n\");\n\n\terr = regulator_enable(chip->vcc_reg);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to enable VCC regulator!\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(&client->dev, isl29018_disable_regulator_action,\n\t\t\t\t chip);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to setup regulator cleanup action!\\n\");\n\t\treturn err;\n\t}\n\n\tchip->regmap = devm_regmap_init_i2c(client,\n\t\t\t\tisl29018_chip_info_tbl[dev_id].regmap_cfg);\n\tif (IS_ERR(chip->regmap)) {\n\t\terr = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"regmap initialization fails: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = isl29018_chip_init(chip);\n\tif (err)\n\t\treturn err;\n\n\tindio_dev->info = isl29018_chip_info_tbl[dev_id].indio_info;\n\tindio_dev->channels = isl29018_chip_info_tbl[dev_id].channels;\n\tindio_dev->num_channels = isl29018_chip_info_tbl[dev_id].num_channels;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int isl29018_suspend(struct device *dev)\n{\n\tstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\t \n\tchip->suspended = true;\n\tret = regulator_disable(chip->vcc_reg);\n\tif (ret)\n\t\tdev_err(dev, \"failed to disable VCC regulator\\n\");\n\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int isl29018_resume(struct device *dev)\n{\n\tstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\n\tint err;\n\n\tmutex_lock(&chip->lock);\n\n\terr = regulator_enable(chip->vcc_reg);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable VCC regulator\\n\");\n\t\tmutex_unlock(&chip->lock);\n\t\treturn err;\n\t}\n\n\terr = isl29018_chip_init(chip);\n\tif (!err)\n\t\tchip->suspended = false;\n\n\tmutex_unlock(&chip->lock);\n\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(isl29018_pm_ops, isl29018_suspend,\n\t\t\t\tisl29018_resume);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id isl29018_acpi_match[] = {\n\t{\"ISL29018\", isl29018},\n\t{\"ISL29023\", isl29023},\n\t{\"ISL29035\", isl29035},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, isl29018_acpi_match);\n#endif\n\nstatic const struct i2c_device_id isl29018_id[] = {\n\t{\"isl29018\", isl29018},\n\t{\"isl29023\", isl29023},\n\t{\"isl29035\", isl29035},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, isl29018_id);\n\nstatic const struct of_device_id isl29018_of_match[] = {\n\t{ .compatible = \"isil,isl29018\", },\n\t{ .compatible = \"isil,isl29023\", },\n\t{ .compatible = \"isil,isl29035\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, isl29018_of_match);\n\nstatic struct i2c_driver isl29018_driver = {\n\t.driver\t = {\n\t\t\t.name = \"isl29018\",\n\t\t\t.acpi_match_table = ACPI_PTR(isl29018_acpi_match),\n\t\t\t.pm = pm_sleep_ptr(&isl29018_pm_ops),\n\t\t\t.of_match_table = isl29018_of_match,\n\t\t    },\n\t.probe = isl29018_probe,\n\t.id_table = isl29018_id,\n};\nmodule_i2c_driver(isl29018_driver);\n\nMODULE_DESCRIPTION(\"ISL29018 Ambient Light Sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}