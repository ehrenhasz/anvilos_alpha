{
  "module_name": "vcnl4035.c",
  "hash_id": "aa991aa0c77edd88c8c55bdff973f2772cface81179ec1ea19baa6e7760cafb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/vcnl4035.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define VCNL4035_DRV_NAME\t\"vcnl4035\"\n#define VCNL4035_IRQ_NAME\t\"vcnl4035_event\"\n#define VCNL4035_REGMAP_NAME\t\"vcnl4035_regmap\"\n\n \n#define VCNL4035_ALS_CONF\t0x00\n#define VCNL4035_ALS_THDH\t0x01\n#define VCNL4035_ALS_THDL\t0x02\n#define VCNL4035_ALS_DATA\t0x0B\n#define VCNL4035_WHITE_DATA\t0x0C\n#define VCNL4035_INT_FLAG\t0x0D\n#define VCNL4035_DEV_ID\t\t0x0E\n\n \n#define VCNL4035_MODE_ALS_MASK\t\tBIT(0)\n#define VCNL4035_MODE_ALS_WHITE_CHAN\tBIT(8)\n#define VCNL4035_MODE_ALS_INT_MASK\tBIT(1)\n#define VCNL4035_ALS_IT_MASK\t\tGENMASK(7, 5)\n#define VCNL4035_ALS_PERS_MASK\t\tGENMASK(3, 2)\n#define VCNL4035_INT_ALS_IF_H_MASK\tBIT(12)\n#define VCNL4035_INT_ALS_IF_L_MASK\tBIT(13)\n#define VCNL4035_DEV_ID_MASK\t\tGENMASK(7, 0)\n\n \n#define VCNL4035_MODE_ALS_ENABLE\tBIT(0)\n#define VCNL4035_MODE_ALS_DISABLE\t0x00\n#define VCNL4035_MODE_ALS_INT_ENABLE\tBIT(1)\n#define VCNL4035_MODE_ALS_INT_DISABLE\t0\n#define VCNL4035_DEV_ID_VAL\t\t0x80\n#define VCNL4035_ALS_IT_DEFAULT\t\t0x01\n#define VCNL4035_ALS_PERS_DEFAULT\t0x00\n#define VCNL4035_ALS_THDH_DEFAULT\t5000\n#define VCNL4035_ALS_THDL_DEFAULT\t100\n#define VCNL4035_SLEEP_DELAY_MS\t\t2000\n\nstruct vcnl4035_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tunsigned int als_it_val;\n\tunsigned int als_persistence;\n\tunsigned int als_thresh_low;\n\tunsigned int als_thresh_high;\n\tstruct iio_trigger *drdy_trigger0;\n};\n\nstatic inline bool vcnl4035_is_triggered(struct vcnl4035_data *data)\n{\n\tint ret;\n\tint reg;\n\n\tret = regmap_read(data->regmap, VCNL4035_INT_FLAG, &reg);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!(reg &\n\t\t(VCNL4035_INT_ALS_IF_H_MASK | VCNL4035_INT_ALS_IF_L_MASK));\n}\n\nstatic irqreturn_t vcnl4035_drdy_irq_thread(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\n\tif (vcnl4035_is_triggered(data)) {\n\t\tiio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_LIGHT,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\tIIO_EV_DIR_EITHER),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\t\tiio_trigger_poll_nested(data->drdy_trigger0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic irqreturn_t vcnl4035_trigger_consumer_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\t \n\tu8 buffer[ALIGN(sizeof(u16), sizeof(s64)) + sizeof(s64)]  __aligned(8);\n\tint ret;\n\n\tret = regmap_read(data->regmap, VCNL4035_ALS_DATA, (int *)buffer);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Trigger consumer can't read from sensor.\\n\");\n\t\tgoto fail_read;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, buffer,\n\t\t\t\t\tiio_get_time_ns(indio_dev));\n\nfail_read:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vcnl4035_als_drdy_set_state(struct iio_trigger *trigger,\n\t\t\t\t\tbool enable_drdy)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trigger);\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\tint val = enable_drdy ? VCNL4035_MODE_ALS_INT_ENABLE :\n\t\t\t\t\tVCNL4035_MODE_ALS_INT_DISABLE;\n\n\treturn regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t VCNL4035_MODE_ALS_INT_MASK,\n\t\t\t\t val);\n}\n\nstatic const struct iio_trigger_ops vcnl4035_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n\t.set_trigger_state = vcnl4035_als_drdy_set_state,\n};\n\nstatic int vcnl4035_set_pm_runtime_state(struct vcnl4035_data *data, bool on)\n{\n\tint ret;\n\tstruct device *dev = &data->client->dev;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int vcnl4035_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint raw_data;\n\tunsigned int reg;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = vcnl4035_set_pm_runtime_state(data, true);\n\t\tif  (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (!ret) {\n\t\t\tif (chan->channel)\n\t\t\t\treg = VCNL4035_ALS_DATA;\n\t\t\telse\n\t\t\t\treg = VCNL4035_WHITE_DATA;\n\t\t\tret = regmap_read(data->regmap, reg, &raw_data);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tif (!ret) {\n\t\t\t\t*val = raw_data;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t}\n\t\t}\n\t\tvcnl4035_set_pm_runtime_state(data, false);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 50;\n\t\tif (data->als_it_val)\n\t\t\t*val = data->als_it_val * 100;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 64;\n\t\tif (!data->als_it_val)\n\t\t\t*val2 = 1000;\n\t\telse\n\t\t\t*val2 = data->als_it_val * 2 * 1000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4035_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tint ret;\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val <= 0 || val > 800)\n\t\t\treturn -EINVAL;\n\n\t\tret = vcnl4035_set_pm_runtime_state(data, true);\n\t\tif  (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t\t VCNL4035_ALS_IT_MASK,\n\t\t\t\t\t val / 100);\n\t\tif (!ret)\n\t\t\tdata->als_it_val = val / 100;\n\n\t\tvcnl4035_set_pm_runtime_state(data, false);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int vcnl4035_read_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint *val, int *val2)\n{\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t*val = data->als_thresh_high;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*val = data->als_thresh_low;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\t*val = data->als_persistence;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n}\n\nstatic int vcnl4035_write_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\t\tint val2)\n{\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t \n\t\tif (val < 0 || val > 65535)\n\t\t\treturn -EINVAL;\n\t\tif (dir == IIO_EV_DIR_RISING) {\n\t\t\tif (val < data->als_thresh_low)\n\t\t\t\treturn -EINVAL;\n\t\t\tret = regmap_write(data->regmap, VCNL4035_ALS_THDH,\n\t\t\t\t\t   val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdata->als_thresh_high = val;\n\t\t} else {\n\t\t\tif (val > data->als_thresh_high)\n\t\t\t\treturn -EINVAL;\n\t\t\tret = regmap_write(data->regmap, VCNL4035_ALS_THDL,\n\t\t\t\t\t   val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdata->als_thresh_low = val;\n\t\t}\n\t\treturn ret;\n\tcase IIO_EV_INFO_PERIOD:\n\t\t \n\t\tif (val < 0 || val > 8 || hweight8(val) != 1)\n\t\t\treturn -EINVAL;\n\t\tret = regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t\t VCNL4035_ALS_PERS_MASK, val);\n\t\tif (!ret)\n\t\t\tdata->als_persistence = val;\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"50 100 200 400 800\");\n\nstatic struct attribute *vcnl4035_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group vcnl4035_attribute_group = {\n\t.attrs = vcnl4035_attributes,\n};\n\nstatic const struct iio_info vcnl4035_info = {\n\t.read_raw\t\t= vcnl4035_read_raw,\n\t.write_raw\t\t= vcnl4035_write_raw,\n\t.read_event_value\t= vcnl4035_read_thresh,\n\t.write_event_value\t= vcnl4035_write_thresh,\n\t.attrs\t\t\t= &vcnl4035_attribute_group,\n};\n\nstatic const struct iio_event_spec vcnl4035_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\nenum vcnl4035_scan_index_order {\n\tVCNL4035_CHAN_INDEX_LIGHT,\n\tVCNL4035_CHAN_INDEX_WHITE_LED,\n};\n\nstatic const struct iio_buffer_setup_ops iio_triggered_buffer_setup_ops = {\n\t.validate_scan_mask = &iio_validate_scan_mask_onehot,\n};\n\nstatic const struct iio_chan_spec vcnl4035_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.event_spec = vcnl4035_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(vcnl4035_event_spec),\n\t\t.scan_index = VCNL4035_CHAN_INDEX_LIGHT,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.channel = 1,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_index = VCNL4035_CHAN_INDEX_WHITE_LED,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n};\n\nstatic int vcnl4035_set_als_power_state(struct vcnl4035_data *data, u8 status)\n{\n\treturn regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t\tVCNL4035_MODE_ALS_MASK,\n\t\t\t\t\tstatus);\n}\n\nstatic int vcnl4035_init(struct vcnl4035_data *data)\n{\n\tint ret;\n\tint id;\n\n\tret = regmap_read(data->regmap, VCNL4035_DEV_ID, &id);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Failed to read DEV_ID register\\n\");\n\t\treturn ret;\n\t}\n\n\tid = FIELD_GET(VCNL4035_DEV_ID_MASK, id);\n\tif (id != VCNL4035_DEV_ID_VAL) {\n\t\tdev_err(&data->client->dev, \"Wrong id, got %x, expected %x\\n\",\n\t\t\tid, VCNL4035_DEV_ID_VAL);\n\t\treturn -ENODEV;\n\t}\n\n\tret = vcnl4035_set_als_power_state(data, VCNL4035_MODE_ALS_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t VCNL4035_MODE_ALS_WHITE_CHAN,\n\t\t\t\t 1);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"set white channel enable %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t VCNL4035_ALS_IT_MASK,\n\t\t\t\t VCNL4035_ALS_IT_DEFAULT);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"set default ALS IT returned %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdata->als_it_val = VCNL4035_ALS_IT_DEFAULT;\n\n\t \n\tret = regmap_update_bits(data->regmap, VCNL4035_ALS_CONF,\n\t\t\t\t VCNL4035_ALS_PERS_MASK,\n\t\t\t\t VCNL4035_ALS_PERS_DEFAULT);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"set default PERS returned %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdata->als_persistence = VCNL4035_ALS_PERS_DEFAULT;\n\n\t \n\tret = regmap_write(data->regmap, VCNL4035_ALS_THDH,\n\t\t\t\tVCNL4035_ALS_THDH_DEFAULT);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"set default THDH returned %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdata->als_thresh_high = VCNL4035_ALS_THDH_DEFAULT;\n\n\t \n\tret = regmap_write(data->regmap, VCNL4035_ALS_THDL,\n\t\t\t\tVCNL4035_ALS_THDL_DEFAULT);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"set default THDL returned %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdata->als_thresh_low = VCNL4035_ALS_THDL_DEFAULT;\n\n\treturn 0;\n}\n\nstatic bool vcnl4035_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase VCNL4035_ALS_CONF:\n\tcase VCNL4035_DEV_ID:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config vcnl4035_regmap_config = {\n\t.name\t\t= VCNL4035_REGMAP_NAME,\n\t.reg_bits\t= 8,\n\t.val_bits\t= 16,\n\t.max_register\t= VCNL4035_DEV_ID,\n\t.cache_type\t= REGCACHE_RBTREE,\n\t.volatile_reg\t= vcnl4035_is_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic int vcnl4035_probe_trigger(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\n\tdata->drdy_trigger0 = devm_iio_trigger_alloc(\n\t\t\tindio_dev->dev.parent,\n\t\t\t\"%s-dev%d\", indio_dev->name, iio_device_id(indio_dev));\n\tif (!data->drdy_trigger0)\n\t\treturn -ENOMEM;\n\n\tdata->drdy_trigger0->ops = &vcnl4035_trigger_ops;\n\tiio_trigger_set_drvdata(data->drdy_trigger0, indio_dev);\n\tret = devm_iio_trigger_register(indio_dev->dev.parent,\n\t\t\t\t\tdata->drdy_trigger0);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"iio trigger register failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_iio_triggered_buffer_setup(indio_dev->dev.parent, indio_dev,\n\t\t\t\t\tNULL, vcnl4035_trigger_consumer_handler,\n\t\t\t\t\t&iio_triggered_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(&data->client->dev, data->client->irq,\n\t\t\tNULL, vcnl4035_drdy_irq_thread,\n\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\tVCNL4035_IRQ_NAME, indio_dev);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"request irq %d for trigger0 failed\\n\",\n\t\t\t\tdata->client->irq);\n\treturn ret;\n}\n\nstatic int vcnl4035_probe(struct i2c_client *client)\n{\n\tstruct vcnl4035_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &vcnl4035_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap_init failed!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->regmap = regmap;\n\n\tindio_dev->info = &vcnl4035_info;\n\tindio_dev->name = VCNL4035_DRV_NAME;\n\tindio_dev->channels = vcnl4035_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vcnl4035_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = vcnl4035_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"vcnl4035 chip init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (client->irq > 0) {\n\t\tret = vcnl4035_probe_trigger(indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"vcnl4035 unable init trigger\\n\");\n\t\t\tgoto fail_poweroff;\n\t\t}\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto fail_poweroff;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto fail_poweroff;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, VCNL4035_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\treturn 0;\n\nfail_poweroff:\n\tvcnl4035_set_als_power_state(data, VCNL4035_MODE_ALS_DISABLE);\n\treturn ret;\n}\n\nstatic void vcnl4035_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tpm_runtime_dont_use_autosuspend(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tret = vcnl4035_set_als_power_state(iio_priv(indio_dev),\n\t\t\t\t\t   VCNL4035_MODE_ALS_DISABLE);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to put device into standby (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic int vcnl4035_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = vcnl4035_set_als_power_state(data, VCNL4035_MODE_ALS_DISABLE);\n\tregcache_mark_dirty(data->regmap);\n\n\treturn ret;\n}\n\nstatic int vcnl4035_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct vcnl4035_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tregcache_sync(data->regmap);\n\tret = vcnl4035_set_als_power_state(data, VCNL4035_MODE_ALS_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(data->als_it_val * 100);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(vcnl4035_pm_ops, vcnl4035_runtime_suspend,\n\t\t\t\t vcnl4035_runtime_resume, NULL);\n\nstatic const struct i2c_device_id vcnl4035_id[] = {\n\t{ \"vcnl4035\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vcnl4035_id);\n\nstatic const struct of_device_id vcnl4035_of_match[] = {\n\t{ .compatible = \"vishay,vcnl4035\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vcnl4035_of_match);\n\nstatic struct i2c_driver vcnl4035_driver = {\n\t.driver = {\n\t\t.name   = VCNL4035_DRV_NAME,\n\t\t.pm\t= pm_ptr(&vcnl4035_pm_ops),\n\t\t.of_match_table = vcnl4035_of_match,\n\t},\n\t.probe = vcnl4035_probe,\n\t.remove\t= vcnl4035_remove,\n\t.id_table = vcnl4035_id,\n};\n\nmodule_i2c_driver(vcnl4035_driver);\n\nMODULE_AUTHOR(\"Parthiban Nallathambi <pn@denx.de>\");\nMODULE_DESCRIPTION(\"VCNL4035 Ambient Light Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}