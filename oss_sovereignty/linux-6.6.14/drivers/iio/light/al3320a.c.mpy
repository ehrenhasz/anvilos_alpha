{
  "module_name": "al3320a.c",
  "hash_id": "e05902101c109e445dbc55de6f3e906d40d6e3301c0a902a69613947bbc3ff5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/al3320a.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/mod_devicetable.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AL3320A_DRV_NAME \"al3320a\"\n\n#define AL3320A_REG_CONFIG\t\t0x00\n#define AL3320A_REG_STATUS\t\t0x01\n#define AL3320A_REG_INT\t\t\t0x02\n#define AL3320A_REG_WAIT\t\t0x06\n#define AL3320A_REG_CONFIG_RANGE\t0x07\n#define AL3320A_REG_PERSIST\t\t0x08\n#define AL3320A_REG_MEAN_TIME\t\t0x09\n#define AL3320A_REG_ADUMMY\t\t0x0A\n#define AL3320A_REG_DATA_LOW\t\t0x22\n\n#define AL3320A_REG_LOW_THRESH_LOW\t0x30\n#define AL3320A_REG_LOW_THRESH_HIGH\t0x31\n#define AL3320A_REG_HIGH_THRESH_LOW\t0x32\n#define AL3320A_REG_HIGH_THRESH_HIGH\t0x33\n\n#define AL3320A_CONFIG_DISABLE\t\t0x00\n#define AL3320A_CONFIG_ENABLE\t\t0x01\n\n#define AL3320A_GAIN_MASK\t\tGENMASK(2, 1)\n\n \n#define AL3320A_DEFAULT_MEAN_TIME\t4\n#define AL3320A_DEFAULT_WAIT_TIME\t0  \n\n#define AL3320A_SCALE_AVAILABLE \"0.512 0.128 0.032 0.01\"\n\nenum al3320a_range {\n\tAL3320A_RANGE_1,  \n\tAL3320A_RANGE_2,  \n\tAL3320A_RANGE_3,  \n\tAL3320A_RANGE_4   \n};\n\nstatic const int al3320a_scales[][2] = {\n\t{0, 512000}, {0, 128000}, {0, 32000}, {0, 10000}\n};\n\nstruct al3320a_data {\n\tstruct i2c_client *client;\n};\n\nstatic const struct iio_chan_spec al3320a_channels[] = {\n\t{\n\t\t.type\t= IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t}\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_scale_available, AL3320A_SCALE_AVAILABLE);\n\nstatic struct attribute *al3320a_attributes[] = {\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group al3320a_attribute_group = {\n\t.attrs = al3320a_attributes,\n};\n\nstatic int al3320a_set_pwr(struct i2c_client *client, bool pwr)\n{\n\tu8 val = pwr ? AL3320A_CONFIG_ENABLE : AL3320A_CONFIG_DISABLE;\n\treturn i2c_smbus_write_byte_data(client, AL3320A_REG_CONFIG, val);\n}\n\nstatic void al3320a_set_pwr_off(void *_data)\n{\n\tstruct al3320a_data *data = _data;\n\n\tal3320a_set_pwr(data->client, false);\n}\n\nstatic int al3320a_init(struct al3320a_data *data)\n{\n\tint ret;\n\n\tret = al3320a_set_pwr(data->client, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, AL3320A_REG_CONFIG_RANGE,\n\t\t\t\t\tFIELD_PREP(AL3320A_GAIN_MASK,\n\t\t\t\t\t\t   AL3320A_RANGE_3));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, AL3320A_REG_MEAN_TIME,\n\t\t\t\t\tAL3320A_DEFAULT_MEAN_TIME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, AL3320A_REG_WAIT,\n\t\t\t\t\tAL3320A_DEFAULT_WAIT_TIME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int al3320a_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct al3320a_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t       AL3320A_REG_DATA_LOW);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       AL3320A_REG_CONFIG_RANGE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = FIELD_GET(AL3320A_GAIN_MASK, ret);\n\t\t*val = al3320a_scales[ret][0];\n\t\t*val2 = al3320a_scales[ret][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int al3320a_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct al3320a_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(al3320a_scales); i++) {\n\t\t\tif (val != al3320a_scales[i][0] ||\n\t\t\t    val2 != al3320a_scales[i][1])\n\t\t\t\tcontinue;\n\n\t\t\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tAL3320A_REG_CONFIG_RANGE,\n\t\t\t\t\tFIELD_PREP(AL3320A_GAIN_MASK, i));\n\t\t}\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info al3320a_info = {\n\t.read_raw\t= al3320a_read_raw,\n\t.write_raw\t= al3320a_write_raw,\n\t.attrs\t\t= &al3320a_attribute_group,\n};\n\nstatic int al3320a_probe(struct i2c_client *client)\n{\n\tstruct al3320a_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &al3320a_info;\n\tindio_dev->name = AL3320A_DRV_NAME;\n\tindio_dev->channels = al3320a_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(al3320a_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = al3320a_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"al3320a chip init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\tal3320a_set_pwr_off,\n\t\t\t\t\tdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int al3320a_suspend(struct device *dev)\n{\n\treturn al3320a_set_pwr(to_i2c_client(dev), false);\n}\n\nstatic int al3320a_resume(struct device *dev)\n{\n\treturn al3320a_set_pwr(to_i2c_client(dev), true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(al3320a_pm_ops, al3320a_suspend,\n\t\t\t\tal3320a_resume);\n\nstatic const struct i2c_device_id al3320a_id[] = {\n\t{\"al3320a\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, al3320a_id);\n\nstatic const struct of_device_id al3320a_of_match[] = {\n\t{ .compatible = \"dynaimage,al3320a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, al3320a_of_match);\n\nstatic const struct acpi_device_id al3320a_acpi_match[] = {\n\t{\"CALS0001\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, al3320a_acpi_match);\n\nstatic struct i2c_driver al3320a_driver = {\n\t.driver = {\n\t\t.name = AL3320A_DRV_NAME,\n\t\t.of_match_table = al3320a_of_match,\n\t\t.pm = pm_sleep_ptr(&al3320a_pm_ops),\n\t\t.acpi_match_table = al3320a_acpi_match,\n\t},\n\t.probe\t\t= al3320a_probe,\n\t.id_table\t= al3320a_id,\n};\n\nmodule_i2c_driver(al3320a_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"AL3320A Ambient Light Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}