{
  "module_name": "adux1020.c",
  "hash_id": "98b74f93e43ced5238f23febf18cc0e04ade31bacae19d05b69019e24f6835de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/adux1020.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n#define ADUX1020_REGMAP_NAME\t\t\"adux1020_regmap\"\n#define ADUX1020_DRV_NAME\t\t\"adux1020\"\n\n \n#define ADUX1020_REG_CHIP_ID\t\t0x08\n#define ADUX1020_REG_SLAVE_ADDRESS\t0x09\n\n#define ADUX1020_REG_SW_RESET\t\t0x0f\n#define ADUX1020_REG_INT_ENABLE\t\t0x1c\n#define ADUX1020_REG_INT_POLARITY\t0x1d\n#define ADUX1020_REG_PROX_TH_ON1\t0x2a\n#define ADUX1020_REG_PROX_TH_OFF1\t0x2b\n#define\tADUX1020_REG_PROX_TYPE\t\t0x2f\n#define\tADUX1020_REG_TEST_MODES_3\t0x32\n#define\tADUX1020_REG_FORCE_MODE\t\t0x33\n#define\tADUX1020_REG_FREQUENCY\t\t0x40\n#define ADUX1020_REG_LED_CURRENT\t0x41\n#define\tADUX1020_REG_OP_MODE\t\t0x45\n#define\tADUX1020_REG_INT_MASK\t\t0x48\n#define\tADUX1020_REG_INT_STATUS\t\t0x49\n#define\tADUX1020_REG_DATA_BUFFER\t0x60\n\n \n#define ADUX1020_CHIP_ID_MASK\t\tGENMASK(11, 0)\n#define ADUX1020_CHIP_ID\t\t0x03fc\n\n#define ADUX1020_SW_RESET\t\tBIT(1)\n#define ADUX1020_FIFO_FLUSH\t\tBIT(15)\n#define ADUX1020_OP_MODE_MASK\t\tGENMASK(3, 0)\n#define ADUX1020_DATA_OUT_MODE_MASK\tGENMASK(7, 4)\n#define ADUX1020_DATA_OUT_PROX_I\tFIELD_PREP(ADUX1020_DATA_OUT_MODE_MASK, 1)\n\n#define ADUX1020_MODE_INT_MASK\t\tGENMASK(7, 0)\n#define ADUX1020_INT_ENABLE\t\t0x2094\n#define ADUX1020_INT_DISABLE\t\t0x2090\n#define ADUX1020_PROX_INT_ENABLE\t0x00f0\n#define ADUX1020_PROX_ON1_INT\t\tBIT(0)\n#define ADUX1020_PROX_OFF1_INT\t\tBIT(1)\n#define ADUX1020_FIFO_INT_ENABLE\t0x7f\n#define ADUX1020_MODE_INT_DISABLE\t0xff\n#define ADUX1020_MODE_INT_STATUS_MASK\tGENMASK(7, 0)\n#define ADUX1020_FIFO_STATUS_MASK\tGENMASK(15, 8)\n#define ADUX1020_INT_CLEAR\t\t0xff\n#define ADUX1020_PROX_TYPE\t\tBIT(15)\n\n#define ADUX1020_INT_PROX_ON1\t\tBIT(0)\n#define ADUX1020_INT_PROX_OFF1\t\tBIT(1)\n\n#define ADUX1020_FORCE_CLOCK_ON\t\t0x0f4f\n#define ADUX1020_FORCE_CLOCK_RESET\t0x0040\n#define ADUX1020_ACTIVE_4_STATE\t\t0x0008\n\n#define ADUX1020_PROX_FREQ_MASK\t\tGENMASK(7, 4)\n#define ADUX1020_PROX_FREQ(x)\t\tFIELD_PREP(ADUX1020_PROX_FREQ_MASK, x)\n\n#define ADUX1020_LED_CURRENT_MASK\tGENMASK(3, 0)\n#define ADUX1020_LED_PIREF_EN\t\tBIT(12)\n\n \nenum adux1020_op_modes {\n\tADUX1020_MODE_STANDBY,\n\tADUX1020_MODE_PROX_I,\n\tADUX1020_MODE_PROX_XY,\n\tADUX1020_MODE_GEST,\n\tADUX1020_MODE_SAMPLE,\n\tADUX1020_MODE_FORCE = 0x0e,\n\tADUX1020_MODE_IDLE = 0x0f,\n};\n\nstruct adux1020_data {\n\tstruct i2c_client *client;\n\tstruct iio_dev *indio_dev;\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n};\n\nstruct adux1020_mode_data {\n\tu8 bytes;\n\tu8 buf_len;\n\tu16 int_en;\n};\n\nstatic const struct adux1020_mode_data adux1020_modes[] = {\n\t[ADUX1020_MODE_PROX_I] = {\n\t\t.bytes = 2,\n\t\t.buf_len = 1,\n\t\t.int_en = ADUX1020_PROX_INT_ENABLE,\n\t},\n};\n\nstatic const struct regmap_config adux1020_regmap_config = {\n\t.name = ADUX1020_REGMAP_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0x6F,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct reg_sequence adux1020_def_conf[] = {\n\t{ 0x000c, 0x000f },\n\t{ 0x0010, 0x1010 },\n\t{ 0x0011, 0x004c },\n\t{ 0x0012, 0x5f0c },\n\t{ 0x0013, 0xada5 },\n\t{ 0x0014, 0x0080 },\n\t{ 0x0015, 0x0000 },\n\t{ 0x0016, 0x0600 },\n\t{ 0x0017, 0x0000 },\n\t{ 0x0018, 0x2693 },\n\t{ 0x0019, 0x0004 },\n\t{ 0x001a, 0x4280 },\n\t{ 0x001b, 0x0060 },\n\t{ 0x001c, 0x2094 },\n\t{ 0x001d, 0x0020 },\n\t{ 0x001e, 0x0001 },\n\t{ 0x001f, 0x0100 },\n\t{ 0x0020, 0x0320 },\n\t{ 0x0021, 0x0A13 },\n\t{ 0x0022, 0x0320 },\n\t{ 0x0023, 0x0113 },\n\t{ 0x0024, 0x0000 },\n\t{ 0x0025, 0x2412 },\n\t{ 0x0026, 0x2412 },\n\t{ 0x0027, 0x0022 },\n\t{ 0x0028, 0x0000 },\n\t{ 0x0029, 0x0300 },\n\t{ 0x002a, 0x0700 },\n\t{ 0x002b, 0x0600 },\n\t{ 0x002c, 0x6000 },\n\t{ 0x002d, 0x4000 },\n\t{ 0x002e, 0x0000 },\n\t{ 0x002f, 0x0000 },\n\t{ 0x0030, 0x0000 },\n\t{ 0x0031, 0x0000 },\n\t{ 0x0032, 0x0040 },\n\t{ 0x0033, 0x0008 },\n\t{ 0x0034, 0xE400 },\n\t{ 0x0038, 0x8080 },\n\t{ 0x0039, 0x8080 },\n\t{ 0x003a, 0x2000 },\n\t{ 0x003b, 0x1f00 },\n\t{ 0x003c, 0x2000 },\n\t{ 0x003d, 0x2000 },\n\t{ 0x003e, 0x0000 },\n\t{ 0x0040, 0x8069 },\n\t{ 0x0041, 0x1f2f },\n\t{ 0x0042, 0x4000 },\n\t{ 0x0043, 0x0000 },\n\t{ 0x0044, 0x0008 },\n\t{ 0x0046, 0x0000 },\n\t{ 0x0048, 0x00ef },\n\t{ 0x0049, 0x0000 },\n\t{ 0x0045, 0x0000 },\n};\n\nstatic const int adux1020_rates[][2] = {\n\t{ 0, 100000 },\n\t{ 0, 200000 },\n\t{ 0, 500000 },\n\t{ 1, 0 },\n\t{ 2, 0 },\n\t{ 5, 0 },\n\t{ 10, 0 },\n\t{ 20, 0 },\n\t{ 50, 0 },\n\t{ 100, 0 },\n\t{ 190, 0 },\n\t{ 450, 0 },\n\t{ 820, 0 },\n\t{ 1400, 0 },\n};\n\nstatic const int adux1020_led_currents[][2] = {\n\t{ 0, 25000 },\n\t{ 0, 40000 },\n\t{ 0, 55000 },\n\t{ 0, 70000 },\n\t{ 0, 85000 },\n\t{ 0, 100000 },\n\t{ 0, 115000 },\n\t{ 0, 130000 },\n\t{ 0, 145000 },\n\t{ 0, 160000 },\n\t{ 0, 175000 },\n\t{ 0, 190000 },\n\t{ 0, 205000 },\n\t{ 0, 220000 },\n\t{ 0, 235000 },\n\t{ 0, 250000 },\n};\n\nstatic int adux1020_flush_fifo(struct adux1020_data *data)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_FORCE_MODE,\n\t\t\t   ADUX1020_ACTIVE_4_STATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, ADUX1020_REG_OP_MODE,\n\t\t\t\t ADUX1020_OP_MODE_MASK, ADUX1020_MODE_FORCE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, ADUX1020_REG_OP_MODE,\n\t\t\t\t ADUX1020_OP_MODE_MASK, ADUX1020_MODE_IDLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_TEST_MODES_3,\n\t\t\t   ADUX1020_FORCE_CLOCK_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, ADUX1020_REG_INT_STATUS,\n\t\t\t   ADUX1020_FIFO_FLUSH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(data->regmap, ADUX1020_REG_TEST_MODES_3,\n\t\t\t    ADUX1020_FORCE_CLOCK_RESET);\n}\n\nstatic int adux1020_read_fifo(struct adux1020_data *data, u16 *buf, u8 buf_len)\n{\n\tunsigned int regval;\n\tint i, ret;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_TEST_MODES_3,\n\t\t\t   ADUX1020_FORCE_CLOCK_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < buf_len; i++) {\n\t\tret = regmap_read(data->regmap, ADUX1020_REG_DATA_BUFFER,\n\t\t\t\t  &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuf[i] = regval;\n\t}\n\n\t \n\treturn regmap_write(data->regmap, ADUX1020_REG_TEST_MODES_3,\n\t\t\t    ADUX1020_FORCE_CLOCK_RESET);\n}\n\nstatic int adux1020_set_mode(struct adux1020_data *data,\n\t\t\t     enum adux1020_op_modes mode)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_OP_MODE,\n\t\t\t   ADUX1020_MODE_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (mode) {\n\tcase ADUX1020_MODE_PROX_I:\n\t\tret = regmap_update_bits(data->regmap, ADUX1020_REG_OP_MODE,\n\t\t\t\t\t ADUX1020_DATA_OUT_MODE_MASK,\n\t\t\t\t\t ADUX1020_DATA_OUT_PROX_I);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(data->regmap, ADUX1020_REG_OP_MODE,\n\t\t\t\t\t ADUX1020_OP_MODE_MASK,\n\t\t\t\t\t ADUX1020_MODE_PROX_I);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int adux1020_measure(struct adux1020_data *data,\n\t\t\t    enum adux1020_op_modes mode,\n\t\t\t    u16 *val)\n{\n\tunsigned int status;\n\tint ret, tries = 50;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_INT_ENABLE,\n\t\t\t   ADUX1020_INT_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, ADUX1020_REG_INT_MASK,\n\t\t\t\t ADUX1020_MODE_INT_MASK,\n\t\t\t\t adux1020_modes[mode].int_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (tries--) {\n\t\tret = regmap_read(data->regmap, ADUX1020_REG_INT_STATUS,\n\t\t\t\t  &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus &= ADUX1020_FIFO_STATUS_MASK;\n\t\tif (status >= adux1020_modes[mode].bytes)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0)\n\t\treturn -EIO;\n\n\tret = adux1020_read_fifo(data, val, adux1020_modes[mode].buf_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, ADUX1020_REG_INT_STATUS,\n\t\t\t   (~adux1020_modes[mode].int_en));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(data->regmap, ADUX1020_REG_INT_MASK,\n\t\t\t\t  ADUX1020_MODE_INT_MASK,\n\t\t\t\t  ADUX1020_MODE_INT_DISABLE);\n}\n\nstatic int adux1020_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tu16 buf[3];\n\tint ret = -EINVAL;\n\tunsigned int regval;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = adux1020_set_mode(data, ADUX1020_MODE_PROX_I);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tret = adux1020_measure(data, ADUX1020_MODE_PROX_I, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\t*val = buf[0];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CURRENT:\n\t\t\tret = regmap_read(data->regmap,\n\t\t\t\t\t  ADUX1020_REG_LED_CURRENT, &regval);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tregval = regval & ADUX1020_LED_CURRENT_MASK;\n\n\t\t\t*val = adux1020_led_currents[regval][0];\n\t\t\t*val2 = adux1020_led_currents[regval][1];\n\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = regmap_read(data->regmap, ADUX1020_REG_FREQUENCY,\n\t\t\t\t\t  &regval);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tregval = FIELD_GET(ADUX1020_PROX_FREQ_MASK, regval);\n\n\t\t\t*val = adux1020_rates[regval][0];\n\t\t\t*val2 = adux1020_rates[regval][1];\n\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n};\n\nstatic inline int adux1020_find_index(const int array[][2], int count, int val,\n\t\t\t\t      int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (val == array[i][0] && val2 == array[i][1])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int adux1020_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tint i, ret = -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->type == IIO_PROXIMITY) {\n\t\t\ti = adux1020_find_index(adux1020_rates,\n\t\t\t\t\t\tARRAY_SIZE(adux1020_rates),\n\t\t\t\t\t\tval, val2);\n\t\t\tif (i < 0) {\n\t\t\t\tret = i;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t ADUX1020_REG_FREQUENCY,\n\t\t\t\t\t\t ADUX1020_PROX_FREQ_MASK,\n\t\t\t\t\t\t ADUX1020_PROX_FREQ(i));\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->type == IIO_CURRENT) {\n\t\t\ti = adux1020_find_index(adux1020_led_currents,\n\t\t\t\t\tARRAY_SIZE(adux1020_led_currents),\n\t\t\t\t\tval, val2);\n\t\t\tif (i < 0) {\n\t\t\t\tret = i;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t ADUX1020_REG_LED_CURRENT,\n\t\t\t\t\t\t ADUX1020_LED_CURRENT_MASK, i);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int adux1020_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir, int state)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tint ret, mask;\n\n\tmutex_lock(&data->lock);\n\n\tret = regmap_write(data->regmap, ADUX1020_REG_INT_ENABLE,\n\t\t\t   ADUX1020_INT_ENABLE);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = regmap_write(data->regmap, ADUX1020_REG_INT_POLARITY, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tmask = ADUX1020_PROX_ON1_INT;\n\t\telse\n\t\t\tmask = ADUX1020_PROX_OFF1_INT;\n\n\t\tif (state)\n\t\t\tstate = 0;\n\t\telse\n\t\t\tstate = mask;\n\n\t\tret = regmap_update_bits(data->regmap, ADUX1020_REG_INT_MASK,\n\t\t\t\t\t mask, state);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = regmap_update_bits(data->regmap, ADUX1020_REG_PROX_TYPE,\n\t\t\t\t\t ADUX1020_PROX_TYPE,\n\t\t\t\t\t ADUX1020_PROX_TYPE);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = adux1020_set_mode(data, ADUX1020_MODE_PROX_I);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int adux1020_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tint ret, mask;\n\tunsigned int regval;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tmask = ADUX1020_PROX_ON1_INT;\n\t\telse\n\t\t\tmask = ADUX1020_PROX_OFF1_INT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(data->regmap, ADUX1020_REG_INT_MASK, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !(regval & mask);\n}\n\nstatic int adux1020_read_thresh(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info, int *val, int *val2)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tu8 reg;\n\tint ret;\n\tunsigned int regval;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = ADUX1020_REG_PROX_TH_ON1;\n\t\telse\n\t\t\treg = ADUX1020_REG_PROX_TH_OFF1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(data->regmap, reg, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = regval;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int adux1020_write_thresh(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t enum iio_event_info info, int val, int val2)\n{\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tu8 reg;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = ADUX1020_REG_PROX_TH_ON1;\n\t\telse\n\t\t\treg = ADUX1020_REG_PROX_TH_OFF1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (val < 0 || val > 65535)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(data->regmap, reg, val);\n}\n\nstatic const struct iio_event_spec adux1020_proximity_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec adux1020_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.event_spec = adux1020_proximity_event,\n\t\t.num_event_specs = ARRAY_SIZE(adux1020_proximity_event),\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.extend_name = \"led\",\n\t\t.output = 1,\n\t},\n};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\t      \"0.1 0.2 0.5 1 2 5 10 20 50 100 190 450 820 1400\");\n\nstatic struct attribute *adux1020_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adux1020_attribute_group = {\n\t.attrs = adux1020_attributes,\n};\n\nstatic const struct iio_info adux1020_info = {\n\t.attrs = &adux1020_attribute_group,\n\t.read_raw = adux1020_read_raw,\n\t.write_raw = adux1020_write_raw,\n\t.read_event_config = adux1020_read_event_config,\n\t.write_event_config = adux1020_write_event_config,\n\t.read_event_value = adux1020_read_thresh,\n\t.write_event_value = adux1020_write_thresh,\n};\n\nstatic irqreturn_t adux1020_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct adux1020_data *data = iio_priv(indio_dev);\n\tint ret, status;\n\n\tret = regmap_read(data->regmap, ADUX1020_REG_INT_STATUS, &status);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tstatus &= ADUX1020_MODE_INT_STATUS_MASK;\n\n\tif (status & ADUX1020_INT_PROX_ON1) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\tif (status & ADUX1020_INT_PROX_OFF1) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\tregmap_update_bits(data->regmap, ADUX1020_REG_INT_STATUS,\n\t\t\t   ADUX1020_MODE_INT_MASK, ADUX1020_INT_CLEAR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adux1020_chip_init(struct adux1020_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, ADUX1020_REG_CHIP_ID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & ADUX1020_CHIP_ID_MASK) != ADUX1020_CHIP_ID) {\n\t\tdev_err(&client->dev, \"invalid chip id 0x%04x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&client->dev, \"Detected ADUX1020 with chip id: 0x%04x\\n\", val);\n\n\tret = regmap_update_bits(data->regmap, ADUX1020_REG_SW_RESET,\n\t\t\t\t ADUX1020_SW_RESET, ADUX1020_SW_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_multi_reg_write(data->regmap, adux1020_def_conf,\n\t\t\t\t     ARRAY_SIZE(adux1020_def_conf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adux1020_flush_fifo(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, ADUX1020_REG_LED_CURRENT,\n\t\t\t\t ADUX1020_LED_PIREF_EN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(data->regmap, ADUX1020_REG_INT_MASK,\n\t\t\t   ADUX1020_MODE_INT_MASK, ADUX1020_MODE_INT_DISABLE);\n}\n\nstatic int adux1020_probe(struct i2c_client *client)\n{\n\tstruct adux1020_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tindio_dev->info = &adux1020_info;\n\tindio_dev->name = ADUX1020_DRV_NAME;\n\tindio_dev->channels = adux1020_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adux1020_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tdata = iio_priv(indio_dev);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &adux1020_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"regmap initialization failed.\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tdata->client = client;\n\tdata->indio_dev = indio_dev;\n\tmutex_init(&data->lock);\n\n\tret = adux1020_chip_init(data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, adux1020_interrupt_handler,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\tADUX1020_DRV_NAME, indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"irq request error %d\\n\", -ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id adux1020_id[] = {\n\t{ \"adux1020\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, adux1020_id);\n\nstatic const struct of_device_id adux1020_of_match[] = {\n\t{ .compatible = \"adi,adux1020\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adux1020_of_match);\n\nstatic struct i2c_driver adux1020_driver = {\n\t.driver = {\n\t\t.name\t= ADUX1020_DRV_NAME,\n\t\t.of_match_table = adux1020_of_match,\n\t},\n\t.probe\t\t= adux1020_probe,\n\t.id_table\t= adux1020_id,\n};\nmodule_i2c_driver(adux1020_driver);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"ADUX1020 photometric sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}