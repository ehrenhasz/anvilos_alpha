{
  "module_name": "rohm-bu27034.c",
  "hash_id": "3b6e5504e5b64ca89ddb06d11da92e37a9e871dcaf29cfb19b5dcba067001ee7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/rohm-bu27034.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/units.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/iio-gts-helper.h>\n#include <linux/iio/kfifo_buf.h>\n\n#define BU27034_REG_SYSTEM_CONTROL\t0x40\n#define BU27034_MASK_SW_RESET\t\tBIT(7)\n#define BU27034_MASK_PART_ID\t\tGENMASK(5, 0)\n#define BU27034_ID\t\t\t0x19\n#define BU27034_REG_MODE_CONTROL1\t0x41\n#define BU27034_MASK_MEAS_MODE\t\tGENMASK(2, 0)\n\n#define BU27034_REG_MODE_CONTROL2\t0x42\n#define BU27034_MASK_D01_GAIN\t\tGENMASK(7, 3)\n#define BU27034_MASK_D2_GAIN_HI\t\tGENMASK(7, 6)\n#define BU27034_MASK_D2_GAIN_LO\t\tGENMASK(2, 0)\n\n#define BU27034_REG_MODE_CONTROL3\t0x43\n#define BU27034_REG_MODE_CONTROL4\t0x44\n#define BU27034_MASK_MEAS_EN\t\tBIT(0)\n#define BU27034_MASK_VALID\t\tBIT(7)\n#define BU27034_REG_DATA0_LO\t\t0x50\n#define BU27034_REG_DATA1_LO\t\t0x52\n#define BU27034_REG_DATA2_LO\t\t0x54\n#define BU27034_REG_DATA2_HI\t\t0x55\n#define BU27034_REG_MANUFACTURER_ID\t0x92\n#define BU27034_REG_MAX BU27034_REG_MANUFACTURER_ID\n\n \n#define BU27034_MEAS_WAIT_PREMATURE_MS\t5\n#define BU27034_DATA_WAIT_TIME_US\t1000\n#define BU27034_TOTAL_DATA_WAIT_TIME_US (BU27034_MEAS_WAIT_PREMATURE_MS * 1000)\n\n#define BU27034_RETRY_LIMIT 18\n\nenum {\n\tBU27034_CHAN_ALS,\n\tBU27034_CHAN_DATA0,\n\tBU27034_CHAN_DATA1,\n\tBU27034_CHAN_DATA2,\n\tBU27034_NUM_CHANS\n};\n\nstatic const unsigned long bu27034_scan_masks[] = {\n\tGENMASK(BU27034_CHAN_DATA2, BU27034_CHAN_ALS), 0\n};\n\n \n#define BU27034_SCALE_1X\t64\n\n \n#define BU27034_GSEL_1X\t\t0x00  \n#define BU27034_GSEL_4X\t\t0x08  \n#define BU27034_GSEL_16X\t0x0a  \n#define BU27034_GSEL_32X\t0x0b  \n#define BU27034_GSEL_64X\t0x0c  \n#define BU27034_GSEL_256X\t0x18  \n#define BU27034_GSEL_512X\t0x19  \n#define BU27034_GSEL_1024X\t0x1a  \n#define BU27034_GSEL_2048X\t0x1b  \n#define BU27034_GSEL_4096X\t0x1c  \n\n \nstatic const struct iio_gain_sel_pair bu27034_gains[] = {\n\tGAIN_SCALE_GAIN(1, BU27034_GSEL_1X),\n\tGAIN_SCALE_GAIN(4, BU27034_GSEL_4X),\n\tGAIN_SCALE_GAIN(16, BU27034_GSEL_16X),\n\tGAIN_SCALE_GAIN(32, BU27034_GSEL_32X),\n\tGAIN_SCALE_GAIN(64, BU27034_GSEL_64X),\n\tGAIN_SCALE_GAIN(256, BU27034_GSEL_256X),\n\tGAIN_SCALE_GAIN(512, BU27034_GSEL_512X),\n\tGAIN_SCALE_GAIN(1024, BU27034_GSEL_1024X),\n\tGAIN_SCALE_GAIN(2048, BU27034_GSEL_2048X),\n\tGAIN_SCALE_GAIN(4096, BU27034_GSEL_4096X),\n};\n\n \n#define BU27034_MEAS_MODE_100MS\t\t0\n#define BU27034_MEAS_MODE_55MS\t\t1\n#define BU27034_MEAS_MODE_200MS\t\t2\n#define BU27034_MEAS_MODE_400MS\t\t4\n\nstatic const struct iio_itime_sel_mul bu27034_itimes[] = {\n\tGAIN_SCALE_ITIME_US(400000, BU27034_MEAS_MODE_400MS, 8),\n\tGAIN_SCALE_ITIME_US(200000, BU27034_MEAS_MODE_200MS, 4),\n\tGAIN_SCALE_ITIME_US(100000, BU27034_MEAS_MODE_100MS, 2),\n\tGAIN_SCALE_ITIME_US(55000, BU27034_MEAS_MODE_55MS, 1),\n};\n\n#define BU27034_CHAN_DATA(_name, _ch2)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_INTENSITY,\t\t\t\t\t\t\\\n\t.channel = BU27034_CHAN_##_name,\t\t\t\t\\\n\t.channel2 = (_ch2),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME),\t\t\\\n\t.info_mask_shared_by_all_available =\t\t\t\t\\\n\t\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\t\\\n\t.address = BU27034_REG_##_name##_LO,\t\t\t\t\\\n\t.scan_index = BU27034_CHAN_##_name,\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec bu27034_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.channel = BU27034_CHAN_ALS,\n\t\t.scan_index = BU27034_CHAN_ALS,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t \n\tBU27034_CHAN_DATA(DATA0, IIO_MOD_LIGHT_CLEAR),\n\tBU27034_CHAN_DATA(DATA1, IIO_MOD_LIGHT_CLEAR),\n\tBU27034_CHAN_DATA(DATA2, IIO_MOD_LIGHT_IR),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstruct bu27034_data {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\t \n\tstruct mutex mutex;\n\tstruct iio_gts gts;\n\tstruct task_struct *task;\n\t__le16 raw[3];\n\tstruct {\n\t\tu32 mlux;\n\t\t__le16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstruct bu27034_result {\n\tu16 ch0;\n\tu16 ch1;\n\tu16 ch2;\n};\n\nstatic const struct regmap_range bu27034_volatile_ranges[] = {\n\t{\n\t\t.range_min = BU27034_REG_SYSTEM_CONTROL,\n\t\t.range_max = BU27034_REG_SYSTEM_CONTROL,\n\t}, {\n\t\t.range_min = BU27034_REG_MODE_CONTROL4,\n\t\t.range_max = BU27034_REG_MODE_CONTROL4,\n\t}, {\n\t\t.range_min = BU27034_REG_DATA0_LO,\n\t\t.range_max = BU27034_REG_DATA2_HI,\n\t},\n};\n\nstatic const struct regmap_access_table bu27034_volatile_regs = {\n\t.yes_ranges = &bu27034_volatile_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(bu27034_volatile_ranges),\n};\n\nstatic const struct regmap_range bu27034_read_only_ranges[] = {\n\t{\n\t\t.range_min = BU27034_REG_DATA0_LO,\n\t\t.range_max = BU27034_REG_DATA2_HI,\n\t}, {\n\t\t.range_min = BU27034_REG_MANUFACTURER_ID,\n\t\t.range_max = BU27034_REG_MANUFACTURER_ID,\n\t}\n};\n\nstatic const struct regmap_access_table bu27034_ro_regs = {\n\t.no_ranges = &bu27034_read_only_ranges[0],\n\t.n_no_ranges = ARRAY_SIZE(bu27034_read_only_ranges),\n};\n\nstatic const struct regmap_config bu27034_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = BU27034_REG_MAX,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &bu27034_volatile_regs,\n\t.wr_table = &bu27034_ro_regs,\n};\n\nstruct bu27034_gain_check {\n\tint old_gain;\n\tint new_gain;\n\tint chan;\n};\n\nstatic int bu27034_get_gain_sel(struct bu27034_data *data, int chan)\n{\n\tint ret, val;\n\n\tswitch (chan) {\n\tcase BU27034_CHAN_DATA0:\n\tcase BU27034_CHAN_DATA1:\n\t{\n\t\tint reg[] = {\n\t\t\t[BU27034_CHAN_DATA0] = BU27034_REG_MODE_CONTROL2,\n\t\t\t[BU27034_CHAN_DATA1] = BU27034_REG_MODE_CONTROL3,\n\t\t};\n\t\tret = regmap_read(data->regmap, reg[chan], &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn FIELD_GET(BU27034_MASK_D01_GAIN, val);\n\t}\n\tcase BU27034_CHAN_DATA2:\n\t{\n\t\tint d2_lo_bits = fls(BU27034_MASK_D2_GAIN_LO);\n\n\t\tret = regmap_read(data->regmap, BU27034_REG_MODE_CONTROL2, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\treturn FIELD_GET(BU27034_MASK_D2_GAIN_HI, val) << d2_lo_bits |\n\t\t       FIELD_GET(BU27034_MASK_D2_GAIN_LO, val);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bu27034_get_gain(struct bu27034_data *data, int chan, int *gain)\n{\n\tint ret, sel;\n\n\tret = bu27034_get_gain_sel(data, chan);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsel = ret;\n\n\tret = iio_gts_find_gain_by_sel(&data->gts, sel);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"chan %u: unknown gain value 0x%x\\n\", chan,\n\t\t\tsel);\n\n\t\treturn ret;\n\t}\n\n\t*gain = ret;\n\n\treturn 0;\n}\n\nstatic int bu27034_get_int_time(struct bu27034_data *data)\n{\n\tint ret, sel;\n\n\tret = regmap_read(data->regmap, BU27034_REG_MODE_CONTROL1, &sel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iio_gts_find_int_time_by_sel(&data->gts,\n\t\t\t\t\t    sel & BU27034_MASK_MEAS_MODE);\n}\n\nstatic int _bu27034_get_scale(struct bu27034_data *data, int channel, int *val,\n\t\t\t      int *val2)\n{\n\tint gain, ret;\n\n\tret = bu27034_get_gain(data, channel, &gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_get_int_time(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn iio_gts_get_scale(&data->gts, gain, ret, val, val2);\n}\n\nstatic int bu27034_get_scale(struct bu27034_data *data, int channel, int *val,\n\t\t\t      int *val2)\n{\n\tint ret;\n\n\tif (channel == BU27034_CHAN_ALS) {\n\t\t*val = 0;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\tmutex_lock(&data->mutex);\n\tret = _bu27034_get_scale(data, channel, val, val2);\n\tmutex_unlock(&data->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\n \nstatic int bu27034_write_gain_sel(struct bu27034_data *data, int chan, int sel)\n{\n\tstatic const int reg[] = {\n\t\t[BU27034_CHAN_DATA0] = BU27034_REG_MODE_CONTROL2,\n\t\t[BU27034_CHAN_DATA1] = BU27034_REG_MODE_CONTROL3,\n\t};\n\tint mask, val;\n\n\tif (chan != BU27034_CHAN_DATA0 && chan != BU27034_CHAN_DATA1)\n\t\treturn -EINVAL;\n\n\tval = FIELD_PREP(BU27034_MASK_D01_GAIN, sel);\n\n\tmask = BU27034_MASK_D01_GAIN;\n\n\tif (chan == BU27034_CHAN_DATA0) {\n\t\t \n\t\tmask |=  BU27034_MASK_D2_GAIN_LO;\n\n\t\t \n\t\tval |= sel & BU27034_MASK_D2_GAIN_LO;\n\t}\n\n\treturn regmap_update_bits(data->regmap, reg[chan], mask, val);\n}\n\nstatic int bu27034_set_gain(struct bu27034_data *data, int chan, int gain)\n{\n\tint ret;\n\n\t \n\tif (chan != BU27034_CHAN_DATA0 && chan != BU27034_CHAN_DATA1)\n\t\treturn -EINVAL;\n\n\tret = iio_gts_find_sel_by_gain(&data->gts, gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bu27034_write_gain_sel(data, chan, ret);\n}\n\n \nstatic int bu27034_set_int_time(struct bu27034_data *data, int time)\n{\n\tint ret;\n\n\tret = iio_gts_find_sel_by_int_time(&data->gts, time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(data->regmap, BU27034_REG_MODE_CONTROL1,\n\t\t\t\t BU27034_MASK_MEAS_MODE, ret);\n}\n\n \nstatic int bu27034_try_set_int_time(struct bu27034_data *data, int time_us)\n{\n\tstruct bu27034_gain_check gains[] = {\n\t\t{ .chan = BU27034_CHAN_DATA0 },\n\t\t{ .chan = BU27034_CHAN_DATA1 },\n\t};\n\tint numg = ARRAY_SIZE(gains);\n\tint ret, int_time_old, i;\n\n\tmutex_lock(&data->mutex);\n\tret = bu27034_get_int_time(data);\n\tif (ret < 0)\n\t\tgoto unlock_out;\n\n\tint_time_old = ret;\n\n\tif (!iio_gts_valid_time(&data->gts, time_us)) {\n\t\tdev_err(data->dev, \"Unsupported integration time %u\\n\",\n\t\t\ttime_us);\n\t\tret = -EINVAL;\n\n\t\tgoto unlock_out;\n\t}\n\n\tif (time_us == int_time_old) {\n\t\tret = 0;\n\t\tgoto unlock_out;\n\t}\n\n\tfor (i = 0; i < numg; i++) {\n\t\tret = bu27034_get_gain(data, gains[i].chan, &gains[i].old_gain);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\n\t\tret = iio_gts_find_new_gain_by_old_gain_time(&data->gts,\n\t\t\t\t\t\t\t     gains[i].old_gain,\n\t\t\t\t\t\t\t     int_time_old, time_us,\n\t\t\t\t\t\t\t     &gains[i].new_gain);\n\t\tif (ret) {\n\t\t\tint scale1, scale2;\n\t\t\tbool ok;\n\n\t\t\t_bu27034_get_scale(data, gains[i].chan, &scale1, &scale2);\n\t\t\tdev_dbg(data->dev,\n\t\t\t\t\"chan %u, can't support time %u with scale %u %u\\n\",\n\t\t\t\tgains[i].chan, time_us, scale1, scale2);\n\n\t\t\tif (gains[i].new_gain < 0)\n\t\t\t\tgoto unlock_out;\n\n\t\t\t \n\t\t\tret = iio_find_closest_gain_low(&data->gts,\n\t\t\t\t\t\t\tgains[i].new_gain, &ok);\n\n\t\t\tif (!ok)\n\t\t\t\tdev_dbg(data->dev,\n\t\t\t\t\t\"optimal gain out of range for chan %u\\n\",\n\t\t\t\t\tgains[i].chan);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_dbg(data->dev,\n\t\t\t\t\t \"Total gain increase. Risk of saturation\");\n\t\t\t\tret = iio_gts_get_min_gain(&data->gts);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t\tdev_dbg(data->dev, \"chan %u scale changed\\n\",\n\t\t\t\t gains[i].chan);\n\t\t\tgains[i].new_gain = ret;\n\t\t\tdev_dbg(data->dev, \"chan %u new gain %u\\n\",\n\t\t\t\tgains[i].chan, gains[i].new_gain);\n\t\t}\n\t}\n\n\tfor (i = 0; i < numg; i++) {\n\t\tret = bu27034_set_gain(data, gains[i].chan, gains[i].new_gain);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\t}\n\n\tret = bu27034_set_int_time(data, time_us);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bu27034_set_scale(struct bu27034_data *data, int chan,\n\t\t\t    int val, int val2)\n{\n\tint ret, time_sel, gain_sel, i;\n\tbool found = false;\n\n\tif (chan == BU27034_CHAN_DATA2)\n\t\treturn -EINVAL;\n\n\tif (chan == BU27034_CHAN_ALS) {\n\t\tif (val == 0 && val2 == 1000000)\n\t\t\treturn 0;\n\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_read(data->regmap, BU27034_REG_MODE_CONTROL1, &time_sel);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = iio_gts_find_gain_sel_for_scale_using_time(&data->gts, time_sel,\n\t\t\t\t\t\tval, val2, &gain_sel);\n\tif (ret) {\n\t\t \n\t\tstruct bu27034_gain_check gain;\n\t\tint new_time_sel;\n\n\t\t \n\t\tif (chan == BU27034_CHAN_DATA0)\n\t\t\tgain.chan = BU27034_CHAN_DATA1;\n\t\telse if (chan == BU27034_CHAN_DATA1)\n\t\t\tgain.chan = BU27034_CHAN_DATA0;\n\n\t\tret = bu27034_get_gain(data, gain.chan, &gain.old_gain);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\n\t\t \n\t\tfor (i = 0; i < data->gts.num_itime; i++) {\n\t\t\tnew_time_sel = data->gts.itime_table[i].sel;\n\n\t\t\tif (new_time_sel == time_sel)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = iio_gts_find_gain_sel_for_scale_using_time(\n\t\t\t\t&data->gts, new_time_sel, val, val2,\n\t\t\t\t&gain_sel);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = iio_gts_find_new_gain_sel_by_old_gain_time(\n\t\t\t\t&data->gts, gain.old_gain, time_sel,\n\t\t\t\tnew_time_sel, &gain.new_gain);\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdev_dbg(data->dev,\n\t\t\t\t\"Can't set scale maintaining other channels\\n\");\n\t\t\tret = -EINVAL;\n\n\t\t\tgoto unlock_out;\n\t\t}\n\n\t\tret = bu27034_set_gain(data, gain.chan, gain.new_gain);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\n\t\tret = regmap_update_bits(data->regmap, BU27034_REG_MODE_CONTROL1,\n\t\t\t\t  BU27034_MASK_MEAS_MODE, new_time_sel);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\t}\n\n\tret = bu27034_write_gain_sel(data, chan, gain_sel);\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\n \n\nstruct bu27034_lx_coeff {\n\tunsigned int A;\n\tunsigned int B;\n\tunsigned int C;\n\t \n\tbool is_neg[3];\n};\n\nstatic inline u64 gain_mul_div_helper(u64 val, unsigned int gain,\n\t\t\t\t      unsigned int div)\n{\n\t \n\tif (val < GENMASK_ULL(51, 0)) {\n\t\tval *= gain;\n\t\tdo_div(val, div);\n\t} else {\n\t\tdo_div(val, div);\n\t\tval *= gain;\n\t}\n\n\treturn val;\n}\n\nstatic u64 bu27034_fixp_calc_t1_64bit(unsigned int coeff, unsigned int ch0,\n\t\t\t\t      unsigned int ch1, unsigned int gain0,\n\t\t\t\t      unsigned int gain1)\n{\n\tunsigned int helper;\n\tu64 helper64;\n\n\thelper64 = (u64)coeff * (u64)ch1 * (u64)ch1;\n\n\thelper = gain1 * gain1;\n\tif (helper > ch0) {\n\t\tdo_div(helper64, helper);\n\n\t\treturn gain_mul_div_helper(helper64, gain0, ch0);\n\t}\n\n\tdo_div(helper64, ch0);\n\n\treturn gain_mul_div_helper(helper64, gain0, helper);\n\n}\n\nstatic u64 bu27034_fixp_calc_t1(unsigned int coeff, unsigned int ch0,\n\t\t\t\tunsigned int ch1, unsigned int gain0,\n\t\t\t\tunsigned int gain1)\n{\n\tunsigned int helper, tmp;\n\n\t \n\thelper = coeff * ch1 * ch1;\n\ttmp = helper * gain0;\n\n\thelper = ch1 * ch1;\n\n\tif (check_mul_overflow(helper, coeff, &helper))\n\t\treturn bu27034_fixp_calc_t1_64bit(coeff, ch0, ch1, gain0, gain1);\n\n\tif (check_mul_overflow(helper, gain0, &tmp))\n\t\treturn bu27034_fixp_calc_t1_64bit(coeff, ch0, ch1, gain0, gain1);\n\n\treturn tmp / (gain1 * gain1) / ch0;\n\n}\n\nstatic u64 bu27034_fixp_calc_t23(unsigned int coeff, unsigned int ch,\n\t\t\t\t unsigned int gain)\n{\n\tunsigned int helper;\n\tu64 helper64;\n\n\tif (!check_mul_overflow(coeff, ch, &helper))\n\t\treturn helper / gain;\n\n\thelper64 = (u64)coeff * (u64)ch;\n\tdo_div(helper64, gain);\n\n\treturn helper64;\n}\n\nstatic int bu27034_fixp_calc_lx(unsigned int ch0, unsigned int ch1,\n\t\t\t\tunsigned int gain0, unsigned int gain1,\n\t\t\t\tunsigned int meastime, int coeff_idx)\n{\n\tstatic const struct bu27034_lx_coeff coeff[] = {\n\t\t{\n\t\t\t.A = 31265280,\t\t \n\t\t\t.B = 1157400832,\t \n\t\t\t.C = 681982976,\t\t \n\t\t\t.is_neg = {false, false, true},\n\t\t}, {\n\t\t\t.A = 3489024,\t\t \n\t\t\t.B = 137210309,\t\t \n\t\t\t.C = 226606476,\t\t \n\t\t\t \n\t\t}, {\n\t\t\t.A = 453120,\t\t \n\t\t\t.B = 7068160,\t\t \n\t\t\t.C = 374809600,\t\t \n\t\t\t.is_neg = {true, true, false},\n\t\t}\n\t};\n\tconst struct bu27034_lx_coeff *c = &coeff[coeff_idx];\n\tu64 res = 0, terms[3];\n\tint i;\n\n\tif (coeff_idx >= ARRAY_SIZE(coeff))\n\t\treturn -EINVAL;\n\n\tterms[0] = bu27034_fixp_calc_t1(c->A, ch0, ch1, gain0, gain1);\n\tterms[1] = bu27034_fixp_calc_t23(c->B, ch1, gain1);\n\tterms[2] = bu27034_fixp_calc_t23(c->C, ch0, gain0);\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (!c->is_neg[i])\n\t\t\tres += terms[i];\n\n\t \n\tif (!res)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (c->is_neg[i]) {\n\t\t\t \n\t\t\tif (terms[i] >= res)\n\t\t\t\treturn 0;\n\n\t\t\tres -= terms[i];\n\t\t}\n\n\tmeastime *= 10;\n\tdo_div(res, meastime);\n\n\treturn (int) res;\n}\n\nstatic bool bu27034_has_valid_sample(struct bu27034_data *data)\n{\n\tint ret, val;\n\n\tret = regmap_read(data->regmap, BU27034_REG_MODE_CONTROL4, &val);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Read failed %d\\n\", ret);\n\n\t\treturn false;\n\t}\n\n\treturn val & BU27034_MASK_VALID;\n}\n\n \nstatic void bu27034_invalidate_read_data(struct bu27034_data *data)\n{\n\tbu27034_has_valid_sample(data);\n}\n\nstatic int bu27034_read_result(struct bu27034_data *data, int chan, int *res)\n{\n\tint reg[] = {\n\t\t[BU27034_CHAN_DATA0] = BU27034_REG_DATA0_LO,\n\t\t[BU27034_CHAN_DATA1] = BU27034_REG_DATA1_LO,\n\t\t[BU27034_CHAN_DATA2] = BU27034_REG_DATA2_LO,\n\t};\n\tint valid, ret;\n\t__le16 val;\n\n\tret = regmap_read_poll_timeout(data->regmap, BU27034_REG_MODE_CONTROL4,\n\t\t\t\t       valid, (valid & BU27034_MASK_VALID),\n\t\t\t\t       BU27034_DATA_WAIT_TIME_US, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, reg[chan], &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\t*res = le16_to_cpu(val);\n\n\treturn 0;\n}\n\nstatic int bu27034_get_result_unlocked(struct bu27034_data *data, __le16 *res,\n\t\t\t\t       int size)\n{\n\tint ret = 0, retry_cnt = 0;\n\nretry:\n\t \n\tif (bu27034_has_valid_sample(data)) {\n\t\tret = regmap_bulk_read(data->regmap, BU27034_REG_DATA0_LO,\n\t\t\t\t       res, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbu27034_invalidate_read_data(data);\n\t} else {\n\t\t \n\t\tretry_cnt++;\n\n\t\tif (retry_cnt > BU27034_RETRY_LIMIT) {\n\t\t\tdev_err(data->dev, \"No data from sensor\\n\");\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tmsleep(25);\n\n\t\tgoto retry;\n\t}\n\n\treturn ret;\n}\n\nstatic int bu27034_meas_set(struct bu27034_data *data, bool en)\n{\n\tif (en)\n\t\treturn regmap_set_bits(data->regmap, BU27034_REG_MODE_CONTROL4,\n\t\t\t\t       BU27034_MASK_MEAS_EN);\n\n\treturn regmap_clear_bits(data->regmap, BU27034_REG_MODE_CONTROL4,\n\t\t\t\t BU27034_MASK_MEAS_EN);\n}\n\nstatic int bu27034_get_single_result(struct bu27034_data *data, int chan,\n\t\t\t\t     int *val)\n{\n\tint ret;\n\n\tif (chan < BU27034_CHAN_DATA0 || chan > BU27034_CHAN_DATA2)\n\t\treturn -EINVAL;\n\n\tret = bu27034_meas_set(data, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_get_int_time(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(ret / 1000);\n\n\treturn bu27034_read_result(data, chan, val);\n}\n\n \n\nstatic int bu27034_calc_mlux(struct bu27034_data *data, __le16 *res, int *val)\n{\n\tunsigned int gain0, gain1, meastime;\n\tunsigned int d1_d0_ratio_scaled;\n\tu16 ch0, ch1;\n\tu64 helper64;\n\tint ret;\n\n\t \n\t*val = 0;\n\n\tch0 = max_t(u16, 1, le16_to_cpu(res[0]));\n\tch1 = max_t(u16, 1, le16_to_cpu(res[1]));\n\n\tret = bu27034_get_gain(data, BU27034_CHAN_DATA0, &gain0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_get_gain(data, BU27034_CHAN_DATA1, &gain1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_get_int_time(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmeastime = ret;\n\n\td1_d0_ratio_scaled = (unsigned int)ch1 * (unsigned int)gain0 * 100;\n\thelper64 = (u64)ch1 * (u64)gain0 * 100LLU;\n\n\tif (helper64 != d1_d0_ratio_scaled) {\n\t\tunsigned int div = (unsigned int)ch0 * gain1;\n\n\t\tdo_div(helper64, div);\n\t\td1_d0_ratio_scaled = helper64;\n\t} else {\n\t\td1_d0_ratio_scaled /= ch0 * gain1;\n\t}\n\n\tif (d1_d0_ratio_scaled < 87)\n\t\tret = bu27034_fixp_calc_lx(ch0, ch1, gain0, gain1, meastime, 0);\n\telse if (d1_d0_ratio_scaled < 100)\n\t\tret = bu27034_fixp_calc_lx(ch0, ch1, gain0, gain1, meastime, 1);\n\telse\n\t\tret = bu27034_fixp_calc_lx(ch0, ch1, gain0, gain1, meastime, 2);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n\n}\n\nstatic int bu27034_get_mlux(struct bu27034_data *data, int chan, int *val)\n{\n\t__le16 res[3];\n\tint ret;\n\n\tret = bu27034_meas_set(data, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_get_result_unlocked(data, &res[0], sizeof(res));\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_calc_mlux(data, res, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27034_meas_set(data, false);\n\tif (ret)\n\t\tdev_err(data->dev, \"failed to disable measurement\\n\");\n\n\treturn 0;\n}\n\nstatic int bu27034_read_raw(struct iio_dev *idev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bu27034_data *data = iio_priv(idev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = bu27034_get_int_time(data);\n\t\tif (*val2 < 0)\n\t\t\treturn *val2;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn bu27034_get_scale(data, chan->channel, val, val2);\n\n\tcase IIO_CHAN_INFO_RAW:\n\t{\n\t\tint (*result_get)(struct bu27034_data *data, int chan, int *val);\n\n\t\tif (chan->type == IIO_INTENSITY)\n\t\t\tresult_get = bu27034_get_single_result;\n\t\telse if (chan->type == IIO_LIGHT)\n\t\t\tresult_get = bu27034_get_mlux;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = iio_device_claim_direct_mode(idev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->mutex);\n\t\t \n\t\tret = result_get(data, chan->channel, val);\n\n\t\tmutex_unlock(&data->mutex);\n\t\tiio_device_release_direct_mode(idev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bu27034_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bu27034_write_raw(struct iio_dev *idev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct bu27034_data *data = iio_priv(idev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(idev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = bu27034_set_scale(data, chan->channel, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (!val)\n\t\t\tret = bu27034_try_set_int_time(data, val2);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(idev);\n\n\treturn ret;\n}\n\nstatic int bu27034_read_avail(struct iio_dev *idev,\n\t\t\t      struct iio_chan_spec const *chan, const int **vals,\n\t\t\t      int *type, int *length, long mask)\n{\n\tstruct bu27034_data *data = iio_priv(idev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn iio_gts_avail_times(&data->gts, vals, type, length);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn iio_gts_all_avail_scales(&data->gts, vals, type, length);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info bu27034_info = {\n\t.read_raw = &bu27034_read_raw,\n\t.write_raw = &bu27034_write_raw,\n\t.write_raw_get_fmt = &bu27034_write_raw_get_fmt,\n\t.read_avail = &bu27034_read_avail,\n};\n\nstatic int bu27034_chip_init(struct bu27034_data *data)\n{\n\tint ret, sel;\n\n\t \n\tret = regmap_write_bits(data->regmap, BU27034_REG_SYSTEM_CONTROL,\n\t\t\t   BU27034_MASK_SW_RESET, BU27034_MASK_SW_RESET);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Sensor reset failed\\n\");\n\n\tmsleep(1);\n\n\tret = regmap_reinit_cache(data->regmap, &bu27034_regmap);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to reinit reg cache\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(data->regmap, BU27034_REG_MODE_CONTROL1, &sel);\n\tif (ret)\n\t\tdev_err(data->dev, \"reading integration time failed\\n\");\n\n\treturn 0;\n}\n\nstatic int bu27034_wait_for_data(struct bu27034_data *data)\n{\n\tint ret, val;\n\n\tret = regmap_read_poll_timeout(data->regmap, BU27034_REG_MODE_CONTROL4,\n\t\t\t\t       val, val & BU27034_MASK_VALID,\n\t\t\t\t       BU27034_DATA_WAIT_TIME_US,\n\t\t\t\t       BU27034_TOTAL_DATA_WAIT_TIME_US);\n\tif (ret) {\n\t\tdev_err(data->dev, \"data polling %s\\n\",\n\t\t\t!(val & BU27034_MASK_VALID) ? \"timeout\" : \"fail\");\n\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, BU27034_REG_DATA0_LO,\n\t\t\t       &data->scan.channels[0],\n\t\t\t       sizeof(data->scan.channels));\n\tif (ret)\n\t\treturn ret;\n\n\tbu27034_invalidate_read_data(data);\n\n\treturn 0;\n}\n\nstatic int bu27034_buffer_thread(void *arg)\n{\n\tstruct iio_dev *idev = arg;\n\tstruct bu27034_data *data;\n\tint wait_ms;\n\n\tdata = iio_priv(idev);\n\n\twait_ms = bu27034_get_int_time(data);\n\twait_ms /= 1000;\n\n\twait_ms -= BU27034_MEAS_WAIT_PREMATURE_MS;\n\n\twhile (!kthread_should_stop()) {\n\t\tint ret;\n\t\tint64_t tstamp;\n\n\t\tmsleep(wait_ms);\n\t\tret = bu27034_wait_for_data(data);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\ttstamp = iio_get_time_ns(idev);\n\n\t\tif (test_bit(BU27034_CHAN_ALS, idev->active_scan_mask)) {\n\t\t\tint mlux;\n\n\t\t\tret = bu27034_calc_mlux(data, &data->scan.channels[0],\n\t\t\t\t\t       &mlux);\n\t\t\tif (ret)\n\t\t\t\tdev_err(data->dev, \"failed to calculate lux\\n\");\n\n\t\t\t \n\t\t\tdata->scan.mlux = (u32)mlux;\n\t\t}\n\t\tiio_push_to_buffers_with_timestamp(idev, &data->scan, tstamp);\n\t}\n\n\treturn 0;\n}\n\nstatic int bu27034_buffer_enable(struct iio_dev *idev)\n{\n\tstruct bu27034_data *data = iio_priv(idev);\n\tstruct task_struct *task;\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bu27034_meas_set(data, true);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\ttask = kthread_run(bu27034_buffer_thread, idev,\n\t\t\t\t \"bu27034-buffering-%u\",\n\t\t\t\t iio_device_id(idev));\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto unlock_out;\n\t}\n\n\tdata->task = task;\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bu27034_buffer_disable(struct iio_dev *idev)\n{\n\tstruct bu27034_data *data = iio_priv(idev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tif (data->task) {\n\t\tkthread_stop(data->task);\n\t\tdata->task = NULL;\n\t}\n\n\tret = bu27034_meas_set(data, false);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops bu27034_buffer_ops = {\n\t.postenable = &bu27034_buffer_enable,\n\t.predisable = &bu27034_buffer_disable,\n};\n\nstatic int bu27034_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct bu27034_data *data;\n\tstruct regmap *regmap;\n\tstruct iio_dev *idev;\n\tunsigned int part_id, reg;\n\tint ret;\n\n\tregmap = devm_regmap_init_i2c(i2c, &bu27034_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to initialize Regmap\\n\");\n\n\tidev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tret = devm_regulator_get_enable(dev, \"vdd\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulator\\n\");\n\n\tdata = iio_priv(idev);\n\n\tret = regmap_read(regmap, BU27034_REG_SYSTEM_CONTROL, &reg);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to access sensor\\n\");\n\n\tpart_id = FIELD_GET(BU27034_MASK_PART_ID, reg);\n\n\tif (part_id != BU27034_ID)\n\t\tdev_warn(dev, \"unknown device 0x%x\\n\", part_id);\n\n\tret = devm_iio_init_iio_gts(dev, BU27034_SCALE_1X, 0, bu27034_gains,\n\t\t\t\t    ARRAY_SIZE(bu27034_gains), bu27034_itimes,\n\t\t\t\t    ARRAY_SIZE(bu27034_itimes), &data->gts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&data->mutex);\n\tdata->regmap = regmap;\n\tdata->dev = dev;\n\n\tidev->channels = bu27034_channels;\n\tidev->num_channels = ARRAY_SIZE(bu27034_channels);\n\tidev->name = \"bu27034\";\n\tidev->info = &bu27034_info;\n\n\tidev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\tidev->available_scan_masks = bu27034_scan_masks;\n\n\tret = bu27034_chip_init(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_kfifo_buffer_setup(dev, idev, &bu27034_buffer_ops);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"buffer setup failed\\n\");\n\n\tret = devm_iio_device_register(dev, idev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Unable to register iio device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id bu27034_of_match[] = {\n\t{ .compatible = \"rohm,bu27034\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bu27034_of_match);\n\nstatic struct i2c_driver bu27034_i2c_driver = {\n\t.driver = {\n\t\t.name = \"bu27034-als\",\n\t\t.of_match_table = bu27034_of_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = bu27034_probe,\n};\nmodule_i2c_driver(bu27034_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BU27034 ambient light sensor driver\");\nMODULE_IMPORT_NS(IIO_GTS_HELPER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}