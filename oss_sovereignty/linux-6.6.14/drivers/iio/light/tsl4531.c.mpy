{
  "module_name": "tsl4531.c",
  "hash_id": "820d627b70a64148f30e7f06c94c261b3d8ce3724fd827c35db68ec39b0949d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tsl4531.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define TSL4531_DRV_NAME \"tsl4531\"\n\n#define TSL4531_COMMAND BIT(7)\n\n#define TSL4531_CONTROL (TSL4531_COMMAND | 0x00)\n#define TSL4531_CONFIG (TSL4531_COMMAND | 0x01)\n#define TSL4531_DATA (TSL4531_COMMAND | 0x04)\n#define TSL4531_ID (TSL4531_COMMAND | 0x0a)\n\n \n#define TSL4531_MODE_POWERDOWN 0x00\n#define TSL4531_MODE_SINGLE_ADC 0x02\n#define TSL4531_MODE_NORMAL 0x03\n\n \n#define TSL4531_TCNTRL_400MS 0x00\n#define TSL4531_TCNTRL_200MS 0x01\n#define TSL4531_TCNTRL_100MS 0x02\n\n \n#define TSL45311_ID 0x8\n#define TSL45313_ID 0x9\n#define TSL45315_ID 0xa\n#define TSL45317_ID 0xb\n#define TSL4531_ID_SHIFT 4\n\nstruct tsl4531_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tint int_time;\n};\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.1 0.2 0.4\");\n\nstatic struct attribute *tsl4531_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tsl4531_attribute_group = {\n\t.attrs = tsl4531_attributes,\n};\n\nstatic const struct iio_chan_spec tsl4531_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME)\n\t}\n};\n\nstatic int tsl4531_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct tsl4531_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\tTSL4531_DATA);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 1 << data->int_time;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (data->int_time == 0)\n\t\t\t*val2 = 400000;\n\t\telse if (data->int_time == 1)\n\t\t\t*val2 = 200000;\n\t\telse if (data->int_time == 2)\n\t\t\t*val2 = 100000;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\t*val = 0;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl4531_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct tsl4531_data *data = iio_priv(indio_dev);\n\tint int_time, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tif (val2 == 400000)\n\t\t\tint_time = 0;\n\t\telse if (val2 == 200000)\n\t\t\tint_time = 1;\n\t\telse if (val2 == 100000)\n\t\t\tint_time = 2;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->lock);\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tTSL4531_CONFIG, int_time);\n\t\tif (ret >= 0)\n\t\t\tdata->int_time = int_time;\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info tsl4531_info = {\n\t.read_raw = tsl4531_read_raw,\n\t.write_raw = tsl4531_write_raw,\n\t.attrs = &tsl4531_attribute_group,\n};\n\nstatic int tsl4531_check_id(struct i2c_client *client)\n{\n\tint ret = i2c_smbus_read_byte_data(client, TSL4531_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret >> TSL4531_ID_SHIFT) {\n\tcase TSL45311_ID:\n\tcase TSL45313_ID:\n\tcase TSL45315_ID:\n\tcase TSL45317_ID:\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int tsl4531_probe(struct i2c_client *client)\n{\n\tstruct tsl4531_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tret = tsl4531_check_id(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"no TSL4531 sensor\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, TSL4531_CONTROL,\n\t\tTSL4531_MODE_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, TSL4531_CONFIG,\n\t\tTSL4531_TCNTRL_400MS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->info = &tsl4531_info;\n\tindio_dev->channels = tsl4531_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsl4531_channels);\n\tindio_dev->name = TSL4531_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic int tsl4531_powerdown(struct i2c_client *client)\n{\n\treturn i2c_smbus_write_byte_data(client, TSL4531_CONTROL,\n\t\tTSL4531_MODE_POWERDOWN);\n}\n\nstatic void tsl4531_remove(struct i2c_client *client)\n{\n\tiio_device_unregister(i2c_get_clientdata(client));\n\ttsl4531_powerdown(client);\n}\n\nstatic int tsl4531_suspend(struct device *dev)\n{\n\treturn tsl4531_powerdown(to_i2c_client(dev));\n}\n\nstatic int tsl4531_resume(struct device *dev)\n{\n\treturn i2c_smbus_write_byte_data(to_i2c_client(dev), TSL4531_CONTROL,\n\t\tTSL4531_MODE_NORMAL);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tsl4531_pm_ops, tsl4531_suspend,\n\t\t\t\ttsl4531_resume);\n\nstatic const struct i2c_device_id tsl4531_id[] = {\n\t{ \"tsl4531\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tsl4531_id);\n\nstatic struct i2c_driver tsl4531_driver = {\n\t.driver = {\n\t\t.name   = TSL4531_DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&tsl4531_pm_ops),\n\t},\n\t.probe = tsl4531_probe,\n\t.remove = tsl4531_remove,\n\t.id_table = tsl4531_id,\n};\n\nmodule_i2c_driver(tsl4531_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"TAOS TSL4531 ambient light sensors driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}