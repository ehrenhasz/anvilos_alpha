{
  "module_name": "max44000.c",
  "hash_id": "a16b073112727bea4b8a3d741b7cf2cc4e970521d34184474aeb30216cee4393",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/max44000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/acpi.h>\n\n#define MAX44000_DRV_NAME\t\t\"max44000\"\n\n \n#define MAX44000_REG_STATUS\t\t0x00\n#define MAX44000_REG_CFG_MAIN\t\t0x01\n#define MAX44000_REG_CFG_RX\t\t0x02\n#define MAX44000_REG_CFG_TX\t\t0x03\n#define MAX44000_REG_ALS_DATA_HI\t0x04\n#define MAX44000_REG_ALS_DATA_LO\t0x05\n#define MAX44000_REG_PRX_DATA\t\t0x16\n#define MAX44000_REG_ALS_UPTHR_HI\t0x06\n#define MAX44000_REG_ALS_UPTHR_LO\t0x07\n#define MAX44000_REG_ALS_LOTHR_HI\t0x08\n#define MAX44000_REG_ALS_LOTHR_LO\t0x09\n#define MAX44000_REG_PST\t\t0x0a\n#define MAX44000_REG_PRX_IND\t\t0x0b\n#define MAX44000_REG_PRX_THR\t\t0x0c\n#define MAX44000_REG_TRIM_GAIN_GREEN\t0x0f\n#define MAX44000_REG_TRIM_GAIN_IR\t0x10\n\n \n#define MAX44000_CFG_ALSINTE            0x01\n#define MAX44000_CFG_PRXINTE            0x02\n#define MAX44000_CFG_MASK               0x1c\n#define MAX44000_CFG_MODE_SHUTDOWN      0x00\n#define MAX44000_CFG_MODE_ALS_GIR       0x04\n#define MAX44000_CFG_MODE_ALS_G         0x08\n#define MAX44000_CFG_MODE_ALS_IR        0x0c\n#define MAX44000_CFG_MODE_ALS_PRX       0x10\n#define MAX44000_CFG_MODE_PRX           0x14\n#define MAX44000_CFG_TRIM               0x20\n\n \n#define MAX44000_REG_CFG_RX_DEFAULT 0xf0\n\n \n#define MAX44000_CFG_RX_ALSTIM_MASK\t0x0c\n#define MAX44000_CFG_RX_ALSTIM_SHIFT\t2\n#define MAX44000_CFG_RX_ALSPGA_MASK\t0x03\n#define MAX44000_CFG_RX_ALSPGA_SHIFT\t0\n\n \n#define MAX44000_LED_CURRENT_MASK\t0xf\n#define MAX44000_LED_CURRENT_MAX\t11\n#define MAX44000_LED_CURRENT_DEFAULT\t6\n\n#define MAX44000_ALSDATA_OVERFLOW\t0x4000\n\nstruct max44000_data {\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\t \n\tstruct {\n\t\tu16 channels[2];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\n \n#define MAX44000_ALS_TO_LUX_DEFAULT_FRACTION_LOG2 5\n\n \nstatic const int max44000_alspga_shift[] = {0, 2, 4, 7};\n#define MAX44000_ALSPGA_MAX_SHIFT 7\n\n \n#define MAX44000_ALSTIM_SHIFT(alstim) (2 * (alstim))\n\n \nstatic const int max44000_int_time_avail_ns_array[] = {\n\t   100000000,\n\t    25000000,\n\t     6250000,\n\t     1562500,\n};\nstatic const char max44000_int_time_avail_str[] =\n\t\"0.100 \"\n\t\"0.025 \"\n\t\"0.00625 \"\n\t\"0.0015625\";\n\n \nstatic const int max44000_scale_avail_ulux_array[] = {\n\t    31250,\n\t   125000,\n\t   500000,\n\t  4000000,\n};\nstatic const char max44000_scale_avail_str[] =\n\t\"0.03125 \"\n\t\"0.125 \"\n\t\"0.5 \"\n\t \"4\";\n\n#define MAX44000_SCAN_INDEX_ALS 0\n#define MAX44000_SCAN_INDEX_PRX 1\n\nstatic const struct iio_chan_spec max44000_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\t    BIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.scan_index = MAX44000_SCAN_INDEX_ALS,\n\t\t.scan_type = {\n\t\t\t.sign\t\t= 'u',\n\t\t\t.realbits\t= 14,\n\t\t\t.storagebits\t= 16,\n\t\t}\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_index = MAX44000_SCAN_INDEX_PRX,\n\t\t.scan_type = {\n\t\t\t.sign\t\t= 'u',\n\t\t\t.realbits\t= 8,\n\t\t\t.storagebits\t= 16,\n\t\t}\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.extend_name = \"led\",\n\t\t.output = 1,\n\t\t.scan_index = -1,\n\t},\n};\n\nstatic int max44000_read_alstim(struct max44000_data *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MAX44000_REG_CFG_RX, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (val & MAX44000_CFG_RX_ALSTIM_MASK) >> MAX44000_CFG_RX_ALSTIM_SHIFT;\n}\n\nstatic int max44000_write_alstim(struct max44000_data *data, int val)\n{\n\treturn regmap_write_bits(data->regmap, MAX44000_REG_CFG_RX,\n\t\t\t\t MAX44000_CFG_RX_ALSTIM_MASK,\n\t\t\t\t val << MAX44000_CFG_RX_ALSTIM_SHIFT);\n}\n\nstatic int max44000_read_alspga(struct max44000_data *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MAX44000_REG_CFG_RX, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (val & MAX44000_CFG_RX_ALSPGA_MASK) >> MAX44000_CFG_RX_ALSPGA_SHIFT;\n}\n\nstatic int max44000_write_alspga(struct max44000_data *data, int val)\n{\n\treturn regmap_write_bits(data->regmap, MAX44000_REG_CFG_RX,\n\t\t\t\t MAX44000_CFG_RX_ALSPGA_MASK,\n\t\t\t\t val << MAX44000_CFG_RX_ALSPGA_SHIFT);\n}\n\nstatic int max44000_read_alsval(struct max44000_data *data)\n{\n\tu16 regval;\n\t__be16 val;\n\tint alstim, ret;\n\n\tret = regmap_bulk_read(data->regmap, MAX44000_REG_ALS_DATA_HI,\n\t\t\t       &val, sizeof(val));\n\tif (ret < 0)\n\t\treturn ret;\n\talstim = ret = max44000_read_alstim(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = be16_to_cpu(val);\n\n\t \n\tif (regval & MAX44000_ALSDATA_OVERFLOW)\n\t\treturn 0x3FFF;\n\n\treturn regval << MAX44000_ALSTIM_SHIFT(alstim);\n}\n\nstatic int max44000_write_led_current_raw(struct max44000_data *data, int val)\n{\n\t \n\tif (val < 0 || val > MAX44000_LED_CURRENT_MAX)\n\t\treturn -ERANGE;\n\tif (val >= 8)\n\t\tval += 4;\n\treturn regmap_write_bits(data->regmap, MAX44000_REG_CFG_TX,\n\t\t\t\t MAX44000_LED_CURRENT_MASK, val);\n}\n\nstatic int max44000_read_led_current_raw(struct max44000_data *data)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MAX44000_REG_CFG_TX, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\tregval &= MAX44000_LED_CURRENT_MASK;\n\tif (regval >= 8)\n\t\tregval -= 4;\n\treturn regval;\n}\n\nstatic int max44000_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct max44000_data *data = iio_priv(indio_dev);\n\tint alstim, alspga;\n\tunsigned int regval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = max44000_read_alsval(data);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase IIO_PROXIMITY:\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = regmap_read(data->regmap, MAX44000_REG_PRX_DATA, &regval);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = regval;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase IIO_CURRENT:\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = max44000_read_led_current_raw(data);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CURRENT:\n\t\t\t \n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase IIO_LIGHT:\n\t\t\tmutex_lock(&data->lock);\n\t\t\talspga = ret = max44000_read_alspga(data);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\t*val = (1 << MAX44000_ALSPGA_MAX_SHIFT);\n\t\t\t*val2 = MAX44000_ALS_TO_LUX_DEFAULT_FRACTION_LOG2\n\t\t\t\t\t+ MAX44000_ALSPGA_MAX_SHIFT\n\t\t\t\t\t- max44000_alspga_shift[alspga];\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tmutex_lock(&data->lock);\n\t\talstim = ret = max44000_read_alstim(data);\n\t\tmutex_unlock(&data->lock);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = 0;\n\t\t*val2 = max44000_int_time_avail_ns_array[alstim];\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int max44000_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct max44000_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_RAW && chan->type == IIO_CURRENT) {\n\t\tmutex_lock(&data->lock);\n\t\tret = max44000_write_led_current_raw(data, val);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t} else if (mask == IIO_CHAN_INFO_INT_TIME && chan->type == IIO_LIGHT) {\n\t\ts64 valns = val * NSEC_PER_SEC + val2;\n\t\tint alstim = find_closest_descending(valns,\n\t\t\t\tmax44000_int_time_avail_ns_array,\n\t\t\t\tARRAY_SIZE(max44000_int_time_avail_ns_array));\n\t\tmutex_lock(&data->lock);\n\t\tret = max44000_write_alstim(data, alstim);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t} else if (mask == IIO_CHAN_INFO_SCALE && chan->type == IIO_LIGHT) {\n\t\ts64 valus = val * USEC_PER_SEC + val2;\n\t\tint alspga = find_closest(valus,\n\t\t\t\tmax44000_scale_avail_ulux_array,\n\t\t\t\tARRAY_SIZE(max44000_scale_avail_ulux_array));\n\t\tmutex_lock(&data->lock);\n\t\tret = max44000_write_alspga(data, alspga);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int max44000_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      long mask)\n{\n\tif (mask == IIO_CHAN_INFO_INT_TIME && chan->type == IIO_LIGHT)\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\telse if (mask == IIO_CHAN_INFO_SCALE && chan->type == IIO_LIGHT)\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\telse\n\t\treturn IIO_VAL_INT;\n}\n\nstatic IIO_CONST_ATTR(illuminance_integration_time_available, max44000_int_time_avail_str);\nstatic IIO_CONST_ATTR(illuminance_scale_available, max44000_scale_avail_str);\n\nstatic struct attribute *max44000_attributes[] = {\n\t&iio_const_attr_illuminance_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_illuminance_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group max44000_attribute_group = {\n\t.attrs = max44000_attributes,\n};\n\nstatic const struct iio_info max44000_info = {\n\t.read_raw\t\t= max44000_read_raw,\n\t.write_raw\t\t= max44000_write_raw,\n\t.write_raw_get_fmt\t= max44000_write_raw_get_fmt,\n\t.attrs\t\t\t= &max44000_attribute_group,\n};\n\nstatic bool max44000_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX44000_REG_STATUS:\n\tcase MAX44000_REG_CFG_MAIN:\n\tcase MAX44000_REG_CFG_RX:\n\tcase MAX44000_REG_CFG_TX:\n\tcase MAX44000_REG_ALS_DATA_HI:\n\tcase MAX44000_REG_ALS_DATA_LO:\n\tcase MAX44000_REG_PRX_DATA:\n\tcase MAX44000_REG_ALS_UPTHR_HI:\n\tcase MAX44000_REG_ALS_UPTHR_LO:\n\tcase MAX44000_REG_ALS_LOTHR_HI:\n\tcase MAX44000_REG_ALS_LOTHR_LO:\n\tcase MAX44000_REG_PST:\n\tcase MAX44000_REG_PRX_IND:\n\tcase MAX44000_REG_PRX_THR:\n\tcase MAX44000_REG_TRIM_GAIN_GREEN:\n\tcase MAX44000_REG_TRIM_GAIN_IR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max44000_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX44000_REG_CFG_MAIN:\n\tcase MAX44000_REG_CFG_RX:\n\tcase MAX44000_REG_CFG_TX:\n\tcase MAX44000_REG_ALS_UPTHR_HI:\n\tcase MAX44000_REG_ALS_UPTHR_LO:\n\tcase MAX44000_REG_ALS_LOTHR_HI:\n\tcase MAX44000_REG_ALS_LOTHR_LO:\n\tcase MAX44000_REG_PST:\n\tcase MAX44000_REG_PRX_IND:\n\tcase MAX44000_REG_PRX_THR:\n\tcase MAX44000_REG_TRIM_GAIN_GREEN:\n\tcase MAX44000_REG_TRIM_GAIN_IR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max44000_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX44000_REG_STATUS:\n\tcase MAX44000_REG_ALS_DATA_HI:\n\tcase MAX44000_REG_ALS_DATA_LO:\n\tcase MAX44000_REG_PRX_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max44000_precious_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == MAX44000_REG_STATUS;\n}\n\nstatic const struct regmap_config max44000_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\n\t.max_register\t\t= MAX44000_REG_PRX_DATA,\n\t.readable_reg\t\t= max44000_readable_reg,\n\t.writeable_reg\t\t= max44000_writeable_reg,\n\t.volatile_reg\t\t= max44000_volatile_reg,\n\t.precious_reg\t\t= max44000_precious_reg,\n\n\t.use_single_read\t= true,\n\t.use_single_write\t= true,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic irqreturn_t max44000_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct max44000_data *data = iio_priv(indio_dev);\n\tint index = 0;\n\tunsigned int regval;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tif (test_bit(MAX44000_SCAN_INDEX_ALS, indio_dev->active_scan_mask)) {\n\t\tret = max44000_read_alsval(data);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tdata->scan.channels[index++] = ret;\n\t}\n\tif (test_bit(MAX44000_SCAN_INDEX_PRX, indio_dev->active_scan_mask)) {\n\t\tret = regmap_read(data->regmap, MAX44000_REG_PRX_DATA, &regval);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tdata->scan.channels[index] = regval;\n\t}\n\tmutex_unlock(&data->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n\nout_unlock:\n\tmutex_unlock(&data->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int max44000_probe(struct i2c_client *client)\n{\n\tstruct max44000_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret, reg;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = devm_regmap_init_i2c(client, &max44000_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"regmap_init failed!\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tmutex_init(&data->lock);\n\tindio_dev->info = &max44000_info;\n\tindio_dev->name = MAX44000_DRV_NAME;\n\tindio_dev->channels = max44000_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max44000_channels);\n\n\t \n\n\t \n\tret = regmap_write(data->regmap, MAX44000_REG_CFG_RX,\n\t\t\t   MAX44000_REG_CFG_RX_DEFAULT);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to write default CFG_RX: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = max44000_write_led_current_raw(data, MAX44000_LED_CURRENT_DEFAULT);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to write init config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg = MAX44000_CFG_TRIM | MAX44000_CFG_MODE_ALS_PRX;\n\tret = regmap_write(data->regmap, MAX44000_REG_CFG_MAIN, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to write init config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(data->regmap, MAX44000_REG_STATUS, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to read init status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev, NULL,\n\t\t\t\t\t      max44000_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id max44000_id[] = {\n\t{\"max44000\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max44000_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max44000_acpi_match[] = {\n\t{\"MAX44000\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, max44000_acpi_match);\n#endif\n\nstatic struct i2c_driver max44000_driver = {\n\t.driver = {\n\t\t.name\t= MAX44000_DRV_NAME,\n\t\t.acpi_match_table = ACPI_PTR(max44000_acpi_match),\n\t},\n\t.probe\t\t= max44000_probe,\n\t.id_table\t= max44000_id,\n};\n\nmodule_i2c_driver(max44000_driver);\n\nMODULE_AUTHOR(\"Crestez Dan Leonard <leonard.crestez@intel.com>\");\nMODULE_DESCRIPTION(\"MAX44000 Ambient and Infrared Proximity Sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}