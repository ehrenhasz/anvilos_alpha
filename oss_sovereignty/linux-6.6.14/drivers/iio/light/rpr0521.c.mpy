{
  "module_name": "rpr0521.c",
  "hash_id": "7cfc2326b84375681796fd85b483ac564ea97ff959631dd2b7f3943c68c161b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/rpr0521.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/acpi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/pm_runtime.h>\n\n#define RPR0521_REG_SYSTEM_CTRL\t\t0x40\n#define RPR0521_REG_MODE_CTRL\t\t0x41\n#define RPR0521_REG_ALS_CTRL\t\t0x42\n#define RPR0521_REG_PXS_CTRL\t\t0x43\n#define RPR0521_REG_PXS_DATA\t\t0x44  \n#define RPR0521_REG_ALS_DATA0\t\t0x46  \n#define RPR0521_REG_ALS_DATA1\t\t0x48  \n#define RPR0521_REG_INTERRUPT\t\t0x4A\n#define RPR0521_REG_PS_OFFSET_LSB\t0x53\n#define RPR0521_REG_ID\t\t\t0x92\n\n#define RPR0521_MODE_ALS_MASK\t\tBIT(7)\n#define RPR0521_MODE_PXS_MASK\t\tBIT(6)\n#define RPR0521_MODE_MEAS_TIME_MASK\tGENMASK(3, 0)\n#define RPR0521_ALS_DATA0_GAIN_MASK\tGENMASK(5, 4)\n#define RPR0521_ALS_DATA0_GAIN_SHIFT\t4\n#define RPR0521_ALS_DATA1_GAIN_MASK\tGENMASK(3, 2)\n#define RPR0521_ALS_DATA1_GAIN_SHIFT\t2\n#define RPR0521_PXS_GAIN_MASK\t\tGENMASK(5, 4)\n#define RPR0521_PXS_GAIN_SHIFT\t\t4\n#define RPR0521_PXS_PERSISTENCE_MASK\tGENMASK(3, 0)\n#define RPR0521_INTERRUPT_INT_TRIG_PS_MASK\tBIT(0)\n#define RPR0521_INTERRUPT_INT_TRIG_ALS_MASK\tBIT(1)\n#define RPR0521_INTERRUPT_INT_REASSERT_MASK\tBIT(3)\n#define RPR0521_INTERRUPT_ALS_INT_STATUS_MASK\tBIT(6)\n#define RPR0521_INTERRUPT_PS_INT_STATUS_MASK\tBIT(7)\n\n#define RPR0521_MODE_ALS_ENABLE\t\tBIT(7)\n#define RPR0521_MODE_ALS_DISABLE\t0x00\n#define RPR0521_MODE_PXS_ENABLE\t\tBIT(6)\n#define RPR0521_MODE_PXS_DISABLE\t0x00\n#define RPR0521_PXS_PERSISTENCE_DRDY\t0x00\n\n#define RPR0521_INTERRUPT_INT_TRIG_PS_ENABLE\tBIT(0)\n#define RPR0521_INTERRUPT_INT_TRIG_PS_DISABLE\t0x00\n#define RPR0521_INTERRUPT_INT_TRIG_ALS_ENABLE\tBIT(1)\n#define RPR0521_INTERRUPT_INT_TRIG_ALS_DISABLE\t0x00\n#define RPR0521_INTERRUPT_INT_REASSERT_ENABLE\tBIT(3)\n#define RPR0521_INTERRUPT_INT_REASSERT_DISABLE\t0x00\n\n#define RPR0521_MANUFACT_ID\t\t0xE0\n#define RPR0521_DEFAULT_MEAS_TIME\t0x06  \n\n#define RPR0521_DRV_NAME\t\t\"RPR0521\"\n#define RPR0521_IRQ_NAME\t\t\"rpr0521_event\"\n#define RPR0521_REGMAP_NAME\t\t\"rpr0521_regmap\"\n\n#define RPR0521_SLEEP_DELAY_MS\t2000\n\n#define RPR0521_ALS_SCALE_AVAIL \"0.007812 0.015625 0.5 1\"\n#define RPR0521_PXS_SCALE_AVAIL \"0.125 0.5 1\"\n\nstruct rpr0521_gain {\n\tint scale;\n\tint uscale;\n};\n\nstatic const struct rpr0521_gain rpr0521_als_gain[4] = {\n\t{1, 0},\t\t \n\t{0, 500000},\t \n\t{0, 15625},\t \n\t{0, 7812},\t \n};\n\nstatic const struct rpr0521_gain rpr0521_pxs_gain[3] = {\n\t{1, 0},\t\t \n\t{0, 500000},\t \n\t{0, 125000},\t \n};\n\nenum rpr0521_channel {\n\tRPR0521_CHAN_PXS,\n\tRPR0521_CHAN_ALS_DATA0,\n\tRPR0521_CHAN_ALS_DATA1,\n};\n\nstruct rpr0521_reg_desc {\n\tu8 address;\n\tu8 device_mask;\n};\n\nstatic const struct rpr0521_reg_desc rpr0521_data_reg[] = {\n\t[RPR0521_CHAN_PXS]\t= {\n\t\t.address\t= RPR0521_REG_PXS_DATA,\n\t\t.device_mask\t= RPR0521_MODE_PXS_MASK,\n\t},\n\t[RPR0521_CHAN_ALS_DATA0] = {\n\t\t.address\t= RPR0521_REG_ALS_DATA0,\n\t\t.device_mask\t= RPR0521_MODE_ALS_MASK,\n\t},\n\t[RPR0521_CHAN_ALS_DATA1] = {\n\t\t.address\t= RPR0521_REG_ALS_DATA1,\n\t\t.device_mask\t= RPR0521_MODE_ALS_MASK,\n\t},\n};\n\nstatic const struct rpr0521_gain_info {\n\tu8 reg;\n\tu8 mask;\n\tu8 shift;\n\tconst struct rpr0521_gain *gain;\n\tint size;\n} rpr0521_gain[] = {\n\t[RPR0521_CHAN_PXS] = {\n\t\t.reg\t= RPR0521_REG_PXS_CTRL,\n\t\t.mask\t= RPR0521_PXS_GAIN_MASK,\n\t\t.shift\t= RPR0521_PXS_GAIN_SHIFT,\n\t\t.gain\t= rpr0521_pxs_gain,\n\t\t.size\t= ARRAY_SIZE(rpr0521_pxs_gain),\n\t},\n\t[RPR0521_CHAN_ALS_DATA0] = {\n\t\t.reg\t= RPR0521_REG_ALS_CTRL,\n\t\t.mask\t= RPR0521_ALS_DATA0_GAIN_MASK,\n\t\t.shift\t= RPR0521_ALS_DATA0_GAIN_SHIFT,\n\t\t.gain\t= rpr0521_als_gain,\n\t\t.size\t= ARRAY_SIZE(rpr0521_als_gain),\n\t},\n\t[RPR0521_CHAN_ALS_DATA1] = {\n\t\t.reg\t= RPR0521_REG_ALS_CTRL,\n\t\t.mask\t= RPR0521_ALS_DATA1_GAIN_MASK,\n\t\t.shift\t= RPR0521_ALS_DATA1_GAIN_SHIFT,\n\t\t.gain\t= rpr0521_als_gain,\n\t\t.size\t= ARRAY_SIZE(rpr0521_als_gain),\n\t},\n};\n\nstruct rpr0521_samp_freq {\n\tint\tals_hz;\n\tint\tals_uhz;\n\tint\tpxs_hz;\n\tint\tpxs_uhz;\n};\n\nstatic const struct rpr0521_samp_freq rpr0521_samp_freq_i[13] = {\n \n\t{0, 0, 0, 0},\t\t \n\t{0, 0, 100, 0},\t\t \n\t{0, 0, 25, 0},\t\t \n\t{0, 0, 10, 0},\t\t \n\t{0, 0, 2, 500000},\t \n\t{10, 0, 20, 0},\t\t \n\t{10, 0, 10, 0},\t\t \n\t{10, 0, 2, 500000},\t \n\t{2, 500000, 20, 0},\t \n\t{2, 500000, 10, 0},\t \n\t{2, 500000, 0, 0},\t \n\t{2, 500000, 2, 500000},\t \n\t{20, 0, 20, 0}\t \n};\n\nstruct rpr0521_data {\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tbool als_dev_en;\n\tbool pxs_dev_en;\n\n\tstruct iio_trigger *drdy_trigger0;\n\ts64 irq_timestamp;\n\n\t \n\tbool als_ps_need_en;\n\tbool pxs_ps_need_en;\n\tbool als_need_dis;\n\tbool pxs_need_dis;\n\n\tstruct regmap *regmap;\n\n\t \n\tstruct {\n\t\t__le16 channels[3];\n\t\tu8 garbage;\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic IIO_CONST_ATTR(in_intensity_scale_available, RPR0521_ALS_SCALE_AVAIL);\nstatic IIO_CONST_ATTR(in_proximity_scale_available, RPR0521_PXS_SCALE_AVAIL);\n\n \nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"2.5 10\");\n\nstatic struct attribute *rpr0521_attributes[] = {\n\t&iio_const_attr_in_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_proximity_scale_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rpr0521_attribute_group = {\n\t.attrs = rpr0521_attributes,\n};\n\n \nenum rpr0521_scan_index_order {\n\tRPR0521_CHAN_INDEX_PXS,\n\tRPR0521_CHAN_INDEX_BOTH,\n\tRPR0521_CHAN_INDEX_IR,\n};\n\nstatic const unsigned long rpr0521_available_scan_masks[] = {\n\tBIT(RPR0521_CHAN_INDEX_PXS) | BIT(RPR0521_CHAN_INDEX_BOTH) |\n\tBIT(RPR0521_CHAN_INDEX_IR),\n\t0\n};\n\nstatic const struct iio_chan_spec rpr0521_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.address = RPR0521_CHAN_PXS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = RPR0521_CHAN_INDEX_PXS,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.address = RPR0521_CHAN_ALS_DATA0,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = RPR0521_CHAN_INDEX_BOTH,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.address = RPR0521_CHAN_ALS_DATA1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = RPR0521_CHAN_INDEX_IR,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n};\n\nstatic int rpr0521_als_enable(struct rpr0521_data *data, u8 status)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, RPR0521_REG_MODE_CTRL,\n\t\t\t\t RPR0521_MODE_ALS_MASK,\n\t\t\t\t status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & RPR0521_MODE_ALS_MASK)\n\t\tdata->als_dev_en = true;\n\telse\n\t\tdata->als_dev_en = false;\n\n\treturn 0;\n}\n\nstatic int rpr0521_pxs_enable(struct rpr0521_data *data, u8 status)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, RPR0521_REG_MODE_CTRL,\n\t\t\t\t RPR0521_MODE_PXS_MASK,\n\t\t\t\t status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & RPR0521_MODE_PXS_MASK)\n\t\tdata->pxs_dev_en = true;\n\telse\n\t\tdata->pxs_dev_en = false;\n\n\treturn 0;\n}\n\n \nstatic int rpr0521_set_power_state(struct rpr0521_data *data, bool on,\n\t\t\t\t   u8 device_mask)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (device_mask & RPR0521_MODE_ALS_MASK) {\n\t\tdata->als_ps_need_en = on;\n\t\tdata->als_need_dis = !on;\n\t}\n\n\tif (device_mask & RPR0521_MODE_PXS_MASK) {\n\t\tdata->pxs_ps_need_en = on;\n\t\tdata->pxs_need_dis = !on;\n\t}\n\n\t \n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&data->client->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(&data->client->dev);\n\t\tret = pm_runtime_put_autosuspend(&data->client->dev);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Failed: rpr0521_set_power_state for %d, ret %d\\n\",\n\t\t\ton, ret);\n\t\treturn ret;\n\t}\n\n\tif (on) {\n\t\t \n\t\tif (data->als_ps_need_en) {\n\t\t\tret = rpr0521_als_enable(data, RPR0521_MODE_ALS_ENABLE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdata->als_ps_need_en = false;\n\t\t}\n\n\t\tif (data->pxs_ps_need_en) {\n\t\t\tret = rpr0521_pxs_enable(data, RPR0521_MODE_PXS_ENABLE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdata->pxs_ps_need_en = false;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic inline bool rpr0521_is_triggered(struct rpr0521_data *data)\n{\n\tint ret;\n\tint reg;\n\n\tret = regmap_read(data->regmap, RPR0521_REG_INTERRUPT, &reg);\n\tif (ret < 0)\n\t\treturn false;    \n\tif (reg &\n\t    (RPR0521_INTERRUPT_ALS_INT_STATUS_MASK |\n\t    RPR0521_INTERRUPT_PS_INT_STATUS_MASK))\n\t\treturn true;\n\telse\n\t\treturn false;    \n}\n\n \nstatic irqreturn_t rpr0521_drdy_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\n\tdata->irq_timestamp = iio_get_time_ns(indio_dev);\n\t \n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t rpr0521_drdy_irq_thread(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\n\tif (rpr0521_is_triggered(data)) {\n\t\tiio_trigger_poll_nested(data->drdy_trigger0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t rpr0521_trigger_consumer_store_time(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\n\t \n\tif (!iio_trigger_using_own(indio_dev))\n\t\tpf->timestamp = iio_get_time_ns(indio_dev);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t rpr0521_trigger_consumer_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint err;\n\n\t \n\tif (iio_trigger_using_own(indio_dev) && data->irq_timestamp) {\n\t\tpf->timestamp = data->irq_timestamp;\n\t\tdata->irq_timestamp = 0;\n\t}\n\t \n\tif (!pf->timestamp)\n\t\tpf->timestamp = iio_get_time_ns(indio_dev);\n\n\terr = regmap_bulk_read(data->regmap, RPR0521_REG_PXS_DATA,\n\t\tdata->scan.channels,\n\t\t(3 * 2) + 1);\t \n\tif (!err)\n\t\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\t\t   &data->scan, pf->timestamp);\n\telse\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Trigger consumer can't read from sensor.\\n\");\n\tpf->timestamp = 0;\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rpr0521_write_int_enable(struct rpr0521_data *data)\n{\n\tint err;\n\n\t \n\terr = regmap_update_bits(data->regmap, RPR0521_REG_PXS_CTRL,\n\t\tRPR0521_PXS_PERSISTENCE_MASK,\n\t\tRPR0521_PXS_PERSISTENCE_DRDY);\n\tif (err) {\n\t\tdev_err(&data->client->dev, \"PS control reg write fail.\\n\");\n\t\treturn -EBUSY;\n\t\t}\n\n\t \n\terr = regmap_write(data->regmap, RPR0521_REG_INTERRUPT,\n\t\tRPR0521_INTERRUPT_INT_REASSERT_DISABLE |\n\t\tRPR0521_INTERRUPT_INT_TRIG_ALS_DISABLE |\n\t\tRPR0521_INTERRUPT_INT_TRIG_PS_ENABLE\n\t\t);\n\tif (err) {\n\t\tdev_err(&data->client->dev, \"Interrupt setup write fail.\\n\");\n\t\treturn -EBUSY;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int rpr0521_write_int_disable(struct rpr0521_data *data)\n{\n\t \n\treturn regmap_write(data->regmap, RPR0521_REG_INTERRUPT,\n\t\t\t\tRPR0521_INTERRUPT_INT_TRIG_ALS_DISABLE |\n\t\t\t\tRPR0521_INTERRUPT_INT_TRIG_PS_DISABLE\n\t\t\t\t);\n}\n\n \nstatic int rpr0521_pxs_drdy_set_state(struct iio_trigger *trigger,\n\tbool enable_drdy)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trigger);\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint err;\n\n\tif (enable_drdy)\n\t\terr = rpr0521_write_int_enable(data);\n\telse\n\t\terr = rpr0521_write_int_disable(data);\n\tif (err)\n\t\tdev_err(&data->client->dev, \"rpr0521_pxs_drdy_set_state failed\\n\");\n\n\treturn err;\n}\n\nstatic const struct iio_trigger_ops rpr0521_trigger_ops = {\n\t.set_trigger_state = rpr0521_pxs_drdy_set_state,\n\t};\n\n\nstatic int rpr0521_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tint err;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\terr = rpr0521_set_power_state(data, true,\n\t\t(RPR0521_MODE_PXS_MASK | RPR0521_MODE_ALS_MASK));\n\tmutex_unlock(&data->lock);\n\tif (err)\n\t\tdev_err(&data->client->dev, \"_buffer_preenable fail\\n\");\n\n\treturn err;\n}\n\nstatic int rpr0521_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tint err;\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\terr = rpr0521_set_power_state(data, false,\n\t\t(RPR0521_MODE_PXS_MASK | RPR0521_MODE_ALS_MASK));\n\tmutex_unlock(&data->lock);\n\tif (err)\n\t\tdev_err(&data->client->dev, \"_buffer_postdisable fail\\n\");\n\n\treturn err;\n}\n\nstatic const struct iio_buffer_setup_ops rpr0521_buffer_setup_ops = {\n\t.preenable = rpr0521_buffer_preenable,\n\t.postdisable = rpr0521_buffer_postdisable,\n};\n\nstatic int rpr0521_get_gain(struct rpr0521_data *data, int chan,\n\t\t\t    int *val, int *val2)\n{\n\tint ret, reg, idx;\n\n\tret = regmap_read(data->regmap, rpr0521_gain[chan].reg, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tidx = (rpr0521_gain[chan].mask & reg) >> rpr0521_gain[chan].shift;\n\t*val = rpr0521_gain[chan].gain[idx].scale;\n\t*val2 = rpr0521_gain[chan].gain[idx].uscale;\n\n\treturn 0;\n}\n\nstatic int rpr0521_set_gain(struct rpr0521_data *data, int chan,\n\t\t\t    int val, int val2)\n{\n\tint i, idx = -EINVAL;\n\n\t \n\tfor (i = 0; i < rpr0521_gain[chan].size; i++)\n\t\tif (val == rpr0521_gain[chan].gain[i].scale &&\n\t\t    val2 == rpr0521_gain[chan].gain[i].uscale) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\treturn regmap_update_bits(data->regmap, rpr0521_gain[chan].reg,\n\t\t\t\t  rpr0521_gain[chan].mask,\n\t\t\t\t  idx << rpr0521_gain[chan].shift);\n}\n\nstatic int rpr0521_read_samp_freq(struct rpr0521_data *data,\n\t\t\t\tenum iio_chan_type chan_type,\n\t\t\t    int *val, int *val2)\n{\n\tint reg, ret;\n\n\tret = regmap_read(data->regmap, RPR0521_REG_MODE_CTRL, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg &= RPR0521_MODE_MEAS_TIME_MASK;\n\tif (reg >= ARRAY_SIZE(rpr0521_samp_freq_i))\n\t\treturn -EINVAL;\n\n\tswitch (chan_type) {\n\tcase IIO_INTENSITY:\n\t\t*val = rpr0521_samp_freq_i[reg].als_hz;\n\t\t*val2 = rpr0521_samp_freq_i[reg].als_uhz;\n\t\treturn 0;\n\n\tcase IIO_PROXIMITY:\n\t\t*val = rpr0521_samp_freq_i[reg].pxs_hz;\n\t\t*val2 = rpr0521_samp_freq_i[reg].pxs_uhz;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rpr0521_write_samp_freq_common(struct rpr0521_data *data,\n\t\t\t\tenum iio_chan_type chan_type,\n\t\t\t\tint val, int val2)\n{\n\tint i;\n\n\t \n\tswitch (val) {\n\tcase 0:\n\t\ti = 0;\n\t\tbreak;\n\n\tcase 2:\n\t\tif (val2 != 500000)\n\t\t\treturn -EINVAL;\n\n\t\ti = 11;\n\t\tbreak;\n\n\tcase 10:\n\t\ti = 6;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(data->regmap,\n\t\tRPR0521_REG_MODE_CTRL,\n\t\tRPR0521_MODE_MEAS_TIME_MASK,\n\t\ti);\n}\n\nstatic int rpr0521_read_ps_offset(struct rpr0521_data *data, int *offset)\n{\n\tint ret;\n\t__le16 buffer;\n\n\tret = regmap_bulk_read(data->regmap,\n\t\tRPR0521_REG_PS_OFFSET_LSB, &buffer, sizeof(buffer));\n\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Failed to read PS OFFSET register\\n\");\n\t\treturn ret;\n\t}\n\t*offset = le16_to_cpu(buffer);\n\n\treturn ret;\n}\n\nstatic int rpr0521_write_ps_offset(struct rpr0521_data *data, int offset)\n{\n\tint ret;\n\t__le16 buffer;\n\n\tbuffer = cpu_to_le16(offset & 0x3ff);\n\tret = regmap_raw_write(data->regmap,\n\t\tRPR0521_REG_PS_OFFSET_LSB, &buffer, sizeof(buffer));\n\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Failed to write PS OFFSET register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rpr0521_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint busy;\n\tu8 device_mask;\n\t__le16 raw_data;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_INTENSITY && chan->type != IIO_PROXIMITY)\n\t\t\treturn -EINVAL;\n\n\t\tbusy = iio_device_claim_direct_mode(indio_dev);\n\t\tif (busy)\n\t\t\treturn -EBUSY;\n\n\t\tdevice_mask = rpr0521_data_reg[chan->address].device_mask;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_set_power_state(data, true, device_mask);\n\t\tif (ret < 0)\n\t\t\tgoto rpr0521_read_raw_out;\n\n\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t       rpr0521_data_reg[chan->address].address,\n\t\t\t\t       &raw_data, sizeof(raw_data));\n\t\tif (ret < 0) {\n\t\t\trpr0521_set_power_state(data, false, device_mask);\n\t\t\tgoto rpr0521_read_raw_out;\n\t\t}\n\n\t\tret = rpr0521_set_power_state(data, false, device_mask);\n\nrpr0521_read_raw_out:\n\t\tmutex_unlock(&data->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = le16_to_cpu(raw_data);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_get_gain(data, chan->address, val, val2);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_read_samp_freq(data, chan->type, val, val2);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_read_ps_offset(data, val);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rpr0521_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_set_gain(data, chan->address, val, val2);\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_write_samp_freq_common(data, chan->type,\n\t\t\t\t\t\t     val, val2);\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tmutex_lock(&data->lock);\n\t\tret = rpr0521_write_ps_offset(data, val);\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info rpr0521_info = {\n\t.read_raw\t= rpr0521_read_raw,\n\t.write_raw\t= rpr0521_write_raw,\n\t.attrs\t\t= &rpr0521_attribute_group,\n};\n\nstatic int rpr0521_init(struct rpr0521_data *data)\n{\n\tint ret;\n\tint id;\n\n\tret = regmap_read(data->regmap, RPR0521_REG_ID, &id);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Failed to read REG_ID register\\n\");\n\t\treturn ret;\n\t}\n\n\tif (id != RPR0521_MANUFACT_ID) {\n\t\tdev_err(&data->client->dev, \"Wrong id, got %x, expected %x\\n\",\n\t\t\tid, RPR0521_MANUFACT_ID);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, RPR0521_REG_MODE_CTRL,\n\t\t\t\t RPR0521_MODE_MEAS_TIME_MASK,\n\t\t\t\t RPR0521_DEFAULT_MEAS_TIME);\n\tif (ret) {\n\t\tpr_err(\"regmap_update_bits returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n#ifndef CONFIG_PM\n\tret = rpr0521_als_enable(data, RPR0521_MODE_ALS_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rpr0521_pxs_enable(data, RPR0521_MODE_PXS_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tdata->irq_timestamp = 0;\n\n\treturn 0;\n}\n\nstatic int rpr0521_poweroff(struct rpr0521_data *data)\n{\n\tint ret;\n\tint tmp;\n\n\tret = regmap_update_bits(data->regmap, RPR0521_REG_MODE_CTRL,\n\t\t\t\t RPR0521_MODE_ALS_MASK |\n\t\t\t\t RPR0521_MODE_PXS_MASK,\n\t\t\t\t RPR0521_MODE_ALS_DISABLE |\n\t\t\t\t RPR0521_MODE_PXS_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->als_dev_en = false;\n\tdata->pxs_dev_en = false;\n\n\t \n\tret = regmap_read(data->regmap, RPR0521_REG_INTERRUPT, &tmp);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"Failed to reset int pin.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool rpr0521_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RPR0521_REG_MODE_CTRL:\n\tcase RPR0521_REG_ALS_CTRL:\n\tcase RPR0521_REG_PXS_CTRL:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config rpr0521_regmap_config = {\n\t.name\t\t= RPR0521_REGMAP_NAME,\n\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\n\t.max_register\t= RPR0521_REG_ID,\n\t.cache_type\t= REGCACHE_RBTREE,\n\t.volatile_reg\t= rpr0521_is_volatile_reg,\n};\n\nstatic int rpr0521_probe(struct i2c_client *client)\n{\n\tstruct rpr0521_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &rpr0521_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap_init failed!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->regmap = regmap;\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &rpr0521_info;\n\tindio_dev->name = RPR0521_DRV_NAME;\n\tindio_dev->channels = rpr0521_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(rpr0521_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = rpr0521_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"rpr0521 chip init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto err_poweroff;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, RPR0521_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\t \n\n\t \n\tif (client->irq) {\n\t\t \n\t\tdata->drdy_trigger0 = devm_iio_trigger_alloc(\n\t\t\tindio_dev->dev.parent,\n\t\t\t\"%s-dev%d\", indio_dev->name, iio_device_id(indio_dev));\n\t\tif (!data->drdy_trigger0) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_pm_disable;\n\t\t}\n\t\tdata->drdy_trigger0->ops = &rpr0521_trigger_ops;\n\t\tindio_dev->available_scan_masks = rpr0521_available_scan_masks;\n\t\tiio_trigger_set_drvdata(data->drdy_trigger0, indio_dev);\n\n\t\t \n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\trpr0521_drdy_irq_handler, rpr0521_drdy_irq_thread,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\tRPR0521_IRQ_NAME, indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"request irq %d for trigger0 failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto err_pm_disable;\n\t\t\t}\n\n\t\tret = devm_iio_trigger_register(indio_dev->dev.parent,\n\t\t\t\t\t\tdata->drdy_trigger0);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"iio trigger register failed\\n\");\n\t\t\tgoto err_pm_disable;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tret = devm_iio_triggered_buffer_setup(indio_dev->dev.parent,\n\t\t\tindio_dev,\n\t\t\trpr0521_trigger_consumer_store_time,\n\t\t\trpr0521_trigger_consumer_handler,\n\t\t\t&rpr0521_buffer_setup_ops);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\t\tgoto err_pm_disable;\n\t\t}\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_pm_disable;\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\nerr_poweroff:\n\trpr0521_poweroff(data);\n\n\treturn ret;\n}\n\nstatic void rpr0521_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\trpr0521_poweroff(iio_priv(indio_dev));\n}\n\nstatic int rpr0521_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\t \n\tif (!data->als_need_dis)\n\t\tdata->als_ps_need_en = data->als_dev_en;\n\tif (!data->pxs_need_dis)\n\t\tdata->pxs_ps_need_en = data->pxs_dev_en;\n\n\t \n\tret = rpr0521_poweroff(data);\n\tregcache_mark_dirty(data->regmap);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int rpr0521_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct rpr0521_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tregcache_sync(data->regmap);\n\tif (data->als_ps_need_en) {\n\t\tret = rpr0521_als_enable(data, RPR0521_MODE_ALS_ENABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->als_ps_need_en = false;\n\t}\n\n\tif (data->pxs_ps_need_en) {\n\t\tret = rpr0521_pxs_enable(data, RPR0521_MODE_PXS_ENABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->pxs_ps_need_en = false;\n\t}\n\tmsleep(100);\t\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rpr0521_pm_ops = {\n\tRUNTIME_PM_OPS(rpr0521_runtime_suspend, rpr0521_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id rpr0521_acpi_match[] = {\n\t{\"RPR0521\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rpr0521_acpi_match);\n\nstatic const struct i2c_device_id rpr0521_id[] = {\n\t{\"rpr0521\", 0},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, rpr0521_id);\n\nstatic struct i2c_driver rpr0521_driver = {\n\t.driver = {\n\t\t.name\t= RPR0521_DRV_NAME,\n\t\t.pm\t= pm_ptr(&rpr0521_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(rpr0521_acpi_match),\n\t},\n\t.probe\t\t= rpr0521_probe,\n\t.remove\t\t= rpr0521_remove,\n\t.id_table\t= rpr0521_id,\n};\n\nmodule_i2c_driver(rpr0521_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"RPR0521 ROHM Ambient Light and Proximity Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}