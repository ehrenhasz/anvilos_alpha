{
  "module_name": "zopt2201.c",
  "hash_id": "d840c8552b135bab0259d20be5b0d24a736ec0cf748488d3c98e61bdaa8e6148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/zopt2201.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <asm/unaligned.h>\n\n#define ZOPT2201_DRV_NAME \"zopt2201\"\n\n \n#define ZOPT2201_MAIN_CTRL\t\t0x00\n#define ZOPT2201_LS_MEAS_RATE\t\t0x04\n#define ZOPT2201_LS_GAIN\t\t0x05\n#define ZOPT2201_PART_ID\t\t0x06\n#define ZOPT2201_MAIN_STATUS\t\t0x07\n#define ZOPT2201_ALS_DATA\t\t0x0d  \n#define ZOPT2201_UVB_DATA\t\t0x10  \n#define ZOPT2201_UV_COMP_DATA\t\t0x13  \n#define ZOPT2201_COMP_DATA\t\t0x16  \n#define ZOPT2201_INT_CFG\t\t0x19\n#define ZOPT2201_INT_PST\t\t0x1a\n\n#define ZOPT2201_MAIN_CTRL_LS_MODE\tBIT(3)  \n#define ZOPT2201_MAIN_CTRL_LS_EN\tBIT(1)\n\n \n#define ZOPT2201_MEAS_RES_20BIT\t\t0  \n#define ZOPT2201_MEAS_RES_19BIT\t\t1  \n#define ZOPT2201_MEAS_RES_18BIT\t\t2  \n#define ZOPT2201_MEAS_RES_17BIT\t\t3  \n#define ZOPT2201_MEAS_RES_16BIT\t\t4  \n#define ZOPT2201_MEAS_RES_13BIT\t\t5  \n#define ZOPT2201_MEAS_RES_SHIFT\t\t4\n\n \n#define ZOPT2201_MEAS_FREQ_25MS\t\t0\n#define ZOPT2201_MEAS_FREQ_50MS\t\t1\n#define ZOPT2201_MEAS_FREQ_100MS\t2  \n#define ZOPT2201_MEAS_FREQ_200MS\t3\n#define ZOPT2201_MEAS_FREQ_500MS\t4\n#define ZOPT2201_MEAS_FREQ_1000MS\t5\n#define ZOPT2201_MEAS_FREQ_2000MS\t6\n\n \n#define ZOPT2201_LS_GAIN_1\t\t0\n#define ZOPT2201_LS_GAIN_3\t\t1\n#define ZOPT2201_LS_GAIN_6\t\t2\n#define ZOPT2201_LS_GAIN_9\t\t3\n#define ZOPT2201_LS_GAIN_18\t\t4\n\n \n#define ZOPT2201_MAIN_STATUS_POWERON\tBIT(5)\n#define ZOPT2201_MAIN_STATUS_INT\tBIT(4)\n#define ZOPT2201_MAIN_STATUS_DRDY\tBIT(3)\n\n#define ZOPT2201_PART_NUMBER\t\t0xb2\n\nstruct zopt2201_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 gain;\n\tu8 res;\n\tu8 rate;\n};\n\nstatic const struct {\n\tunsigned int gain;  \n\tunsigned int scale;  \n} zopt2201_gain_als[] = {\n\t{  1, 19200000 },\n\t{  3,  6400000 },\n\t{  6,  3200000 },\n\t{  9,  2133333 },\n\t{ 18,  1066666 },\n};\n\nstatic const struct {\n\tunsigned int gain;  \n\tunsigned int scale;  \n} zopt2201_gain_uvb[] = {\n\t{  1, 460800 },\n\t{  3, 153600 },\n\t{  6,  76800 },\n\t{  9,  51200 },\n\t{ 18,  25600 },\n};\n\nstatic const struct {\n\tunsigned int bits;  \n\tunsigned long us;  \n} zopt2201_resolution[] = {\n\t{ 20, 400000 },\n\t{ 19, 200000 },\n\t{ 18, 100000 },\n\t{ 17,  50000 },\n\t{ 16,  25000 },\n\t{ 13,   3125 },\n};\n\nstatic const struct {\n\tunsigned int scale, uscale;  \n\tu8 gain;  \n\tu8 res;  \n} zopt2201_scale_als[] = {\n\t{ 19, 200000, 0, 5 },\n\t{  6, 400000, 1, 5 },\n\t{  3, 200000, 2, 5 },\n\t{  2, 400000, 0, 4 },\n\t{  2, 133333, 3, 5 },\n\t{  1, 200000, 0, 3 },\n\t{  1,  66666, 4, 5 },\n\t{  0, 800000, 1, 4 },\n\t{  0, 600000, 0, 2 },\n\t{  0, 400000, 2, 4 },\n\t{  0, 300000, 0, 1 },\n\t{  0, 266666, 3, 4 },\n\t{  0, 200000, 2, 3 },\n\t{  0, 150000, 0, 0 },\n\t{  0, 133333, 4, 4 },\n\t{  0, 100000, 2, 2 },\n\t{  0,  66666, 4, 3 },\n\t{  0,  50000, 2, 1 },\n\t{  0,  33333, 4, 2 },\n\t{  0,  25000, 2, 0 },\n\t{  0,  16666, 4, 1 },\n\t{  0,   8333, 4, 0 },\n};\n\nstatic const struct {\n\tunsigned int scale, uscale;  \n\tu8 gain;  \n\tu8 res;  \n} zopt2201_scale_uvb[] = {\n\t{ 0, 460800, 0, 5 },\n\t{ 0, 153600, 1, 5 },\n\t{ 0,  76800, 2, 5 },\n\t{ 0,  57600, 0, 4 },\n\t{ 0,  51200, 3, 5 },\n\t{ 0,  28800, 0, 3 },\n\t{ 0,  25600, 4, 5 },\n\t{ 0,  19200, 1, 4 },\n\t{ 0,  14400, 0, 2 },\n\t{ 0,   9600, 2, 4 },\n\t{ 0,   7200, 0, 1 },\n\t{ 0,   6400, 3, 4 },\n\t{ 0,   4800, 2, 3 },\n\t{ 0,   3600, 0, 0 },\n\t{ 0,   3200, 4, 4 },\n\t{ 0,   2400, 2, 2 },\n\t{ 0,   1600, 4, 3 },\n\t{ 0,   1200, 2, 1 },\n\t{ 0,    800, 4, 2 },\n\t{ 0,    600, 2, 0 },\n\t{ 0,    400, 4, 1 },\n\t{ 0,    200, 4, 0 },\n};\n\nstatic int zopt2201_enable_mode(struct zopt2201_data *data, bool uvb_mode)\n{\n\tu8 out = ZOPT2201_MAIN_CTRL_LS_EN;\n\n\tif (uvb_mode)\n\t\tout |= ZOPT2201_MAIN_CTRL_LS_MODE;\n\n\treturn i2c_smbus_write_byte_data(data->client, ZOPT2201_MAIN_CTRL, out);\n}\n\nstatic int zopt2201_read(struct zopt2201_data *data, u8 reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint tries = 10;\n\tu8 buf[3];\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = zopt2201_enable_mode(data, reg == ZOPT2201_UVB_DATA);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\twhile (tries--) {\n\t\tunsigned long t = zopt2201_resolution[data->res].us;\n\n\t\tif (t <= 20000)\n\t\t\tusleep_range(t, t + 1000);\n\t\telse\n\t\t\tmsleep(t / 1000);\n\t\tret = i2c_smbus_read_byte_data(client, ZOPT2201_MAIN_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (ret & ZOPT2201_MAIN_STATUS_DRDY)\n\t\t\tbreak;\n\t}\n\n\tif (tries < 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto fail;\n\t}\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, sizeof(buf), buf);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_smbus_write_byte_data(client, ZOPT2201_MAIN_CTRL, 0x00);\n\tif (ret < 0)\n\t\tgoto fail;\n\tmutex_unlock(&data->lock);\n\n\treturn get_unaligned_le24(&buf[0]);\n\nfail:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic const struct iio_chan_spec zopt2201_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.address = ZOPT2201_ALS_DATA,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_UV,\n\t\t.address = ZOPT2201_UVB_DATA,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n\t{\n\t\t.type = IIO_UVINDEX,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n};\n\nstatic int zopt2201_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct zopt2201_data *data = iio_priv(indio_dev);\n\tu64 tmp;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = zopt2201_read(data, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = zopt2201_read(data, ZOPT2201_UVB_DATA);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret * 18 *\n\t\t\t(1 << (20 - zopt2201_resolution[data->res].bits)) /\n\t\t\tzopt2201_gain_uvb[data->gain].gain;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->address) {\n\t\tcase ZOPT2201_ALS_DATA:\n\t\t\t*val = zopt2201_gain_als[data->gain].scale;\n\t\t\tbreak;\n\t\tcase ZOPT2201_UVB_DATA:\n\t\t\t*val = zopt2201_gain_uvb[data->gain].scale;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*val2 = 1000000;\n\t\t*val2 *= (1 << (zopt2201_resolution[data->res].bits - 13));\n\t\ttmp = div_s64(*val * 1000000ULL, *val2);\n\t\t*val = div_s64_rem(tmp, 1000000, val2);\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = zopt2201_resolution[data->res].us;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int zopt2201_set_resolution(struct zopt2201_data *data, u8 res)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, ZOPT2201_LS_MEAS_RATE,\n\t\t\t\t\t(res << ZOPT2201_MEAS_RES_SHIFT) |\n\t\t\t\t\tdata->rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->res = res;\n\n\treturn 0;\n}\n\nstatic int zopt2201_write_resolution(struct zopt2201_data *data,\n\t\t\t\t     int val, int val2)\n{\n\tint i, ret;\n\n\tif (val != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_resolution); i++)\n\t\tif (val2 == zopt2201_resolution[i].us) {\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = zopt2201_set_resolution(data, i);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int zopt2201_set_gain(struct zopt2201_data *data, u8 gain)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, ZOPT2201_LS_GAIN, gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->gain = gain;\n\n\treturn 0;\n}\n\nstatic int zopt2201_write_scale_als_by_idx(struct zopt2201_data *data, int idx)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = zopt2201_set_resolution(data, zopt2201_scale_als[idx].res);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = zopt2201_set_gain(data, zopt2201_scale_als[idx].gain);\n\nunlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int zopt2201_write_scale_als(struct zopt2201_data *data,\n\t\t\t\t     int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_scale_als); i++)\n\t\tif (val == zopt2201_scale_als[i].scale &&\n\t\t    val2 == zopt2201_scale_als[i].uscale) {\n\t\t\treturn zopt2201_write_scale_als_by_idx(data, i);\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int zopt2201_write_scale_uvb_by_idx(struct zopt2201_data *data, int idx)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = zopt2201_set_resolution(data, zopt2201_scale_als[idx].res);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = zopt2201_set_gain(data, zopt2201_scale_als[idx].gain);\n\nunlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int zopt2201_write_scale_uvb(struct zopt2201_data *data,\n\t\t\t\t     int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_scale_uvb); i++)\n\t\tif (val == zopt2201_scale_uvb[i].scale &&\n\t\t    val2 == zopt2201_scale_uvb[i].uscale)\n\t\t\treturn zopt2201_write_scale_uvb_by_idx(data, i);\n\n\treturn -EINVAL;\n}\n\nstatic int zopt2201_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct zopt2201_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn zopt2201_write_resolution(data, val, val2);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->address) {\n\t\tcase ZOPT2201_ALS_DATA:\n\t\t\treturn zopt2201_write_scale_als(data, val, val2);\n\t\tcase ZOPT2201_UVB_DATA:\n\t\t\treturn zopt2201_write_scale_uvb(data, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t zopt2201_show_int_time_available(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_resolution); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"0.%06lu \",\n\t\t\t\t zopt2201_resolution[i].us);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_INT_TIME_AVAIL(zopt2201_show_int_time_available);\n\nstatic ssize_t zopt2201_show_als_scale_avail(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_scale_als); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06u \",\n\t\t\t\t zopt2201_scale_als[i].scale,\n\t\t\t\t zopt2201_scale_als[i].uscale);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t zopt2201_show_uvb_scale_avail(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zopt2201_scale_uvb); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06u \",\n\t\t\t\t zopt2201_scale_uvb[i].scale,\n\t\t\t\t zopt2201_scale_uvb[i].uscale);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(in_illuminance_scale_available, 0444,\n\t\t       zopt2201_show_als_scale_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_intensity_uv_scale_available, 0444,\n\t\t       zopt2201_show_uvb_scale_avail, NULL, 0);\n\nstatic struct attribute *zopt2201_attributes[] = {\n\t&iio_dev_attr_integration_time_available.dev_attr.attr,\n\t&iio_dev_attr_in_illuminance_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_intensity_uv_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group zopt2201_attribute_group = {\n\t.attrs = zopt2201_attributes,\n};\n\nstatic const struct iio_info zopt2201_info = {\n\t.read_raw = zopt2201_read_raw,\n\t.write_raw = zopt2201_write_raw,\n\t.attrs = &zopt2201_attribute_group,\n};\n\nstatic int zopt2201_probe(struct i2c_client *client)\n{\n\tstruct zopt2201_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\tret = i2c_smbus_read_byte_data(client, ZOPT2201_PART_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ZOPT2201_PART_NUMBER)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &zopt2201_info;\n\tindio_dev->channels = zopt2201_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(zopt2201_channels);\n\tindio_dev->name = ZOPT2201_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tdata->rate = ZOPT2201_MEAS_FREQ_100MS;\n\tret = zopt2201_set_resolution(data, ZOPT2201_MEAS_RES_18BIT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = zopt2201_set_gain(data, ZOPT2201_LS_GAIN_3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id zopt2201_id[] = {\n\t{ \"zopt2201\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, zopt2201_id);\n\nstatic struct i2c_driver zopt2201_driver = {\n\t.driver = {\n\t\t.name   = ZOPT2201_DRV_NAME,\n\t},\n\t.probe = zopt2201_probe,\n\t.id_table = zopt2201_id,\n};\n\nmodule_i2c_driver(zopt2201_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald-Stadler <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"IDT ZOPT2201 ambient light and UV B sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}