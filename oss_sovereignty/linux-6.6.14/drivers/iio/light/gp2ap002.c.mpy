{
  "module_name": "gp2ap002.c",
  "hash_id": "a363691023fdb259f29e19858297b7a28297cf3ceaa34fced9f02042769661bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/gp2ap002.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/consumer.h>  \n#include <linux/iio/types.h>  \n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/bits.h>\n#include <linux/math64.h>\n#include <linux/pm.h>\n\n#define GP2AP002_PROX_CHANNEL 0\n#define GP2AP002_ALS_CHANNEL 1\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n#define GP2AP002_PROX\t\t\t\t0x00\n#define GP2AP002_GAIN\t\t\t\t0x01\n#define GP2AP002_HYS\t\t\t\t0x02\n#define GP2AP002_CYCLE\t\t\t\t0x03\n#define GP2AP002_OPMOD\t\t\t\t0x04\n#define GP2AP002_CON\t\t\t\t0x06\n\n#define GP2AP002_PROX_VO_DETECT\t\t\tBIT(0)\n\n \n#define GP2AP002_GAIN_LED_NORMAL\t\tBIT(3)\n\n \n#define GP2AP002_HYS_HYSD_SHIFT\t\t7\n#define GP2AP002_HYS_HYSD_MASK\t\tBIT(7)\n#define GP2AP002_HYS_HYSC_SHIFT\t\t5\n#define GP2AP002_HYS_HYSC_MASK\t\tGENMASK(6, 5)\n#define GP2AP002_HYS_HYSF_SHIFT\t\t0\n#define GP2AP002_HYS_HYSF_MASK\t\tGENMASK(3, 0)\n#define GP2AP002_HYS_MASK\t\t(GP2AP002_HYS_HYSD_MASK | \\\n\t\t\t\t\t GP2AP002_HYS_HYSC_MASK | \\\n\t\t\t\t\t GP2AP002_HYS_HYSF_MASK)\n\n \n#define GP2AP002_CYCLE_CYCL_SHIFT\t3\n#define GP2AP002_CYCLE_CYCL_MASK\tGENMASK(5, 3)\n\n \n#define GP2AP002_CYCLE_OSC_EFFECTIVE\t0\n#define GP2AP002_CYCLE_OSC_INEFFECTIVE\tBIT(2)\n#define GP2AP002_CYCLE_OSC_MASK\t\tBIT(2)\n\n \n#define GP2AP002_OPMOD_ASD\t\tBIT(4)\n \n#define GP2AP002_OPMOD_SSD_OPERATING\tBIT(0)\n \n#define GP2AP002_OPMOD_VCON_IRQ\t\tBIT(1)\n#define GP2AP002_OPMOD_MASK\t\t(BIT(0) | BIT(1) | BIT(4))\n\n \n#define GP2AP002_CON_OCON_SHIFT\t\t3\n#define GP2AP002_CON_OCON_ENABLE\t(0x0 << GP2AP002_CON_OCON_SHIFT)\n#define GP2AP002_CON_OCON_LOW\t\t(0x2 << GP2AP002_CON_OCON_SHIFT)\n#define GP2AP002_CON_OCON_HIGH\t\t(0x3 << GP2AP002_CON_OCON_SHIFT)\n#define GP2AP002_CON_OCON_MASK\t\t(0x3 << GP2AP002_CON_OCON_SHIFT)\n\n \nstruct gp2ap002 {\n\tstruct regmap *map;\n\tstruct device *dev;\n\tstruct regulator *vdd;\n\tstruct regulator *vio;\n\tstruct iio_channel *alsout;\n\tu8 hys_far;\n\tu8 hys_close;\n\tbool is_gp2ap002s00f;\n\tint irq;\n\tbool enabled;\n};\n\nstatic irqreturn_t gp2ap002_prox_irq(int irq, void *d)\n{\n\tstruct iio_dev *indio_dev = d;\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\tu64 ev;\n\tint val;\n\tint ret;\n\n\tif (!gp2ap002->enabled)\n\t\tgoto err_retrig;\n\n\tret = regmap_read(gp2ap002->map, GP2AP002_PROX, &val);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev, \"error reading proximity\\n\");\n\t\tgoto err_retrig;\n\t}\n\n\tif (val & GP2AP002_PROX_VO_DETECT) {\n\t\t \n\t\tdev_dbg(gp2ap002->dev, \"close\\n\");\n\t\tret = regmap_write(gp2ap002->map, GP2AP002_HYS,\n\t\t\t\t   gp2ap002->hys_far);\n\t\tif (ret)\n\t\t\tdev_err(gp2ap002->dev,\n\t\t\t\t\"error setting up proximity hysteresis\\n\");\n\t\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, GP2AP002_PROX_CHANNEL,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING);\n\t} else {\n\t\t \n\t\tdev_dbg(gp2ap002->dev, \"far\\n\");\n\t\tret = regmap_write(gp2ap002->map, GP2AP002_HYS,\n\t\t\t\t   gp2ap002->hys_close);\n\t\tif (ret)\n\t\t\tdev_err(gp2ap002->dev,\n\t\t\t\t\"error setting up proximity hysteresis\\n\");\n\t\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, GP2AP002_PROX_CHANNEL,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, IIO_EV_DIR_FALLING);\n\t}\n\tiio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\n\n\t \n\tusleep_range(20000, 30000);\n\nerr_retrig:\n\tret = regmap_write(gp2ap002->map, GP2AP002_CON,\n\t\t\t   GP2AP002_CON_OCON_ENABLE);\n\tif (ret)\n\t\tdev_err(gp2ap002->dev, \"error setting up VOUT control\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const u16 gp2ap002_illuminance_table[] = {\n\t0, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 25, 32, 40, 50, 63, 79,\n\t100, 126, 158, 200, 251, 316, 398, 501, 631, 794, 1000, 1259, 1585,\n\t1995, 2512, 3162, 3981, 5012, 6310, 7943, 10000, 12589, 15849, 19953,\n\t25119, 31623, 39811, 50119,\n};\n\nstatic int gp2ap002_get_lux(struct gp2ap002 *gp2ap002)\n{\n\tint ret, res;\n\tu16 lux;\n\n\tret = iio_read_channel_processed(gp2ap002->alsout, &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(gp2ap002->dev, \"read %d mA from ADC\\n\", res);\n\n\t \n\tres = clamp(res, 0, (int)ARRAY_SIZE(gp2ap002_illuminance_table) - 1);\n\tlux = gp2ap002_illuminance_table[res];\n\n\treturn (int)lux;\n}\n\nstatic int gp2ap002_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\tint ret;\n\n\tpm_runtime_get_sync(gp2ap002->dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = gp2ap002_get_lux(gp2ap002);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tpm_runtime_mark_last_busy(gp2ap002->dev);\n\tpm_runtime_put_autosuspend(gp2ap002->dev);\n\n\treturn ret;\n}\n\nstatic int gp2ap002_init(struct gp2ap002 *gp2ap002)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(gp2ap002->map, GP2AP002_GAIN,\n\t\t\t   GP2AP002_GAIN_LED_NORMAL);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev, \"error setting up LED gain\\n\");\n\t\treturn ret;\n\t}\n\tret = regmap_write(gp2ap002->map, GP2AP002_HYS, gp2ap002->hys_far);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev,\n\t\t\t\"error setting up proximity hysteresis\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(gp2ap002->map, GP2AP002_CYCLE,\n\t\t\t   GP2AP002_CYCLE_OSC_INEFFECTIVE);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev,\n\t\t\t\"error setting up internal frequency hopping\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(gp2ap002->map, GP2AP002_OPMOD,\n\t\t\t   GP2AP002_OPMOD_SSD_OPERATING |\n\t\t\t   GP2AP002_OPMOD_VCON_IRQ);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev, \"error setting up operation mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(gp2ap002->map, GP2AP002_CON,\n\t\t\t   GP2AP002_CON_OCON_ENABLE);\n\tif (ret)\n\t\tdev_err(gp2ap002->dev, \"error setting up VOUT control\\n\");\n\n\treturn ret;\n}\n\nstatic int gp2ap002_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\n\t \n\treturn gp2ap002->enabled;\n}\n\nstatic int gp2ap002_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int state)\n{\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\n\tif (state) {\n\t\t \n\t\tpm_runtime_get_sync(gp2ap002->dev);\n\t\tgp2ap002->enabled = true;\n\t} else {\n\t\tpm_runtime_mark_last_busy(gp2ap002->dev);\n\t\tpm_runtime_put_autosuspend(gp2ap002->dev);\n\t\tgp2ap002->enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info gp2ap002_info = {\n\t.read_raw = gp2ap002_read_raw,\n\t.read_event_config = gp2ap002_read_event_config,\n\t.write_event_config = gp2ap002_write_event_config,\n};\n\nstatic const struct iio_event_spec gp2ap002_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec gp2ap002_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.event_spec = gp2ap002_events,\n\t\t.num_event_specs = ARRAY_SIZE(gp2ap002_events),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.channel = GP2AP002_ALS_CHANNEL,\n\t},\n};\n\n \nstatic int gp2ap002_regmap_i2c_read(void *context, unsigned int reg,\n\t\t\t\t    unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = (ret >> 8) & 0xFF;\n\n\treturn 0;\n}\n\nstatic int gp2ap002_regmap_i2c_write(void *context, unsigned int reg,\n\t\t\t\t     unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\treturn i2c_smbus_write_byte_data(i2c, reg, val);\n}\n\nstatic struct regmap_bus gp2ap002_regmap_bus = {\n\t.reg_read = gp2ap002_regmap_i2c_read,\n\t.reg_write = gp2ap002_regmap_i2c_write,\n};\n\nstatic int gp2ap002_probe(struct i2c_client *client)\n{\n\tstruct gp2ap002 *gp2ap002;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &client->dev;\n\tenum iio_chan_type ch_type;\n\tstatic const struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = GP2AP002_CON,\n\t};\n\tstruct regmap *regmap;\n\tint num_chan;\n\tconst char *compat;\n\tu8 val;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*gp2ap002));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(client, indio_dev);\n\n\tgp2ap002 = iio_priv(indio_dev);\n\tgp2ap002->dev = dev;\n\n\t \n\tret = device_property_read_string(dev, \"compatible\", &compat);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot check compatible\\n\");\n\t\treturn ret;\n\t}\n\tgp2ap002->is_gp2ap002s00f = !strcmp(compat, \"sharp,gp2ap002s00f\");\n\n\tregmap = devm_regmap_init(dev, &gp2ap002_regmap_bus, dev, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to register i2c regmap %ld\\n\", PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\tgp2ap002->map = regmap;\n\n\t \n\n\t \n\tret = device_property_read_u8(dev, \"sharp,proximity-far-hysteresis\",\n\t\t\t\t      &val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to obtain proximity far setting\\n\");\n\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"proximity far setting %02x\\n\", val);\n\tgp2ap002->hys_far = val;\n\n\tret = device_property_read_u8(dev, \"sharp,proximity-close-hysteresis\",\n\t\t\t\t      &val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to obtain proximity close setting\\n\");\n\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"proximity close setting %02x\\n\", val);\n\tgp2ap002->hys_close = val;\n\n\t \n\tif (!gp2ap002->is_gp2ap002s00f) {\n\t\tgp2ap002->alsout = devm_iio_channel_get(dev, \"alsout\");\n\t\tif (IS_ERR(gp2ap002->alsout)) {\n\t\t\tret = PTR_ERR(gp2ap002->alsout);\n\t\t\tret = (ret == -ENODEV) ? -EPROBE_DEFER : ret;\n\t\t\treturn dev_err_probe(dev, ret, \"failed to get ALSOUT ADC channel\\n\");\n\t\t}\n\t\tret = iio_get_channel_type(gp2ap002->alsout, &ch_type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ch_type != IIO_CURRENT) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"wrong type of IIO channel specified for ALSOUT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tgp2ap002->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(gp2ap002->vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(gp2ap002->vdd),\n\t\t\t\t     \"failed to get VDD regulator\\n\");\n\n\tgp2ap002->vio = devm_regulator_get(dev, \"vio\");\n\tif (IS_ERR(gp2ap002->vio))\n\t\treturn dev_err_probe(dev, PTR_ERR(gp2ap002->vio),\n\t\t\t\t     \"failed to get VIO regulator\\n\");\n\n\t \n\tret = regulator_set_voltage(gp2ap002->vdd, 2400000, 3600000);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to sett VDD voltage\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regulator_get_voltage(gp2ap002->vdd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get VDD voltage\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_set_voltage(gp2ap002->vio, 1650000, ret);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set VIO voltage\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(gp2ap002->vdd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_enable(gp2ap002->vio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VIO regulator\\n\");\n\t\tgoto out_disable_vdd;\n\t}\n\n\tmsleep(20);\n\n\t \n\tret = gp2ap002_init(gp2ap002);\n\tif (ret) {\n\t\tdev_err(dev, \"initialization failed\\n\");\n\t\tgoto out_disable_vio;\n\t}\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tgp2ap002->enabled = false;\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tgp2ap002_prox_irq, IRQF_ONESHOT,\n\t\t\t\t\t\"gp2ap002\", indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\tgoto out_put_pm;\n\t}\n\tgp2ap002->irq = client->irq;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\tindio_dev->info = &gp2ap002_info;\n\tindio_dev->name = \"gp2ap002\";\n\tindio_dev->channels = gp2ap002_channels;\n\t \n\tnum_chan = ARRAY_SIZE(gp2ap002_channels);\n\tif (gp2ap002->is_gp2ap002s00f)\n\t\tnum_chan--;\n\tindio_dev->num_channels = num_chan;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto out_disable_pm;\n\tdev_dbg(dev, \"Sharp GP2AP002 probed successfully\\n\");\n\n\treturn 0;\n\nout_put_pm:\n\tpm_runtime_put_noidle(dev);\nout_disable_pm:\n\tpm_runtime_disable(dev);\nout_disable_vio:\n\tregulator_disable(gp2ap002->vio);\nout_disable_vdd:\n\tregulator_disable(gp2ap002->vdd);\n\treturn ret;\n}\n\nstatic void gp2ap002_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\tstruct device *dev = &client->dev;\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(gp2ap002->vio);\n\tregulator_disable(gp2ap002->vdd);\n}\n\nstatic int gp2ap002_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tdisable_irq(gp2ap002->irq);\n\n\t \n\tret = regmap_write(gp2ap002->map, GP2AP002_OPMOD, 0x00);\n\tif (ret) {\n\t\tdev_err(gp2ap002->dev, \"error setting up operation mode\\n\");\n\t\treturn ret;\n\t}\n\t \n\tregulator_disable(gp2ap002->vio);\n\tregulator_disable(gp2ap002->vdd);\n\n\treturn 0;\n}\n\nstatic int gp2ap002_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct gp2ap002 *gp2ap002 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(gp2ap002->vdd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD regulator in resume path\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_enable(gp2ap002->vio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VIO regulator in resume path\\n\");\n\t\treturn ret;\n\t}\n\n\tmsleep(20);\n\n\tret = gp2ap002_init(gp2ap002);\n\tif (ret) {\n\t\tdev_err(dev, \"re-initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tenable_irq(gp2ap002->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(gp2ap002_dev_pm_ops, gp2ap002_runtime_suspend,\n\t\t\t\t gp2ap002_runtime_resume, NULL);\n\nstatic const struct i2c_device_id gp2ap002_id_table[] = {\n\t{ \"gp2ap002\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, gp2ap002_id_table);\n\nstatic const struct of_device_id gp2ap002_of_match[] = {\n\t{ .compatible = \"sharp,gp2ap002a00f\" },\n\t{ .compatible = \"sharp,gp2ap002s00f\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gp2ap002_of_match);\n\nstatic struct i2c_driver gp2ap002_driver = {\n\t.driver = {\n\t\t.name = \"gp2ap002\",\n\t\t.of_match_table = gp2ap002_of_match,\n\t\t.pm = pm_ptr(&gp2ap002_dev_pm_ops),\n\t},\n\t.probe = gp2ap002_probe,\n\t.remove = gp2ap002_remove,\n\t.id_table = gp2ap002_id_table,\n};\nmodule_i2c_driver(gp2ap002_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"GP2AP002 ambient light and proximity sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}