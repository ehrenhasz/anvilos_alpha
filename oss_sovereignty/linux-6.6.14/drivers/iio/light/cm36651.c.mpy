{
  "module_name": "cm36651.c",
  "hash_id": "4b8fd40aa8dfa7b2ffce614716096ddcdbefae4834413248928b2513d0bc1303",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/cm36651.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/regulator/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n \n#define CM36651_I2C_ADDR_PS\t\t0x19\n \n#define CM36651_ARA\t\t\t0x0C\n\n \n#define CM36651_CS_CONF1\t\t0x00\n#define CM36651_CS_CONF2\t\t0x01\n#define CM36651_ALS_WH_M\t\t0x02\n#define CM36651_ALS_WH_L\t\t0x03\n#define CM36651_ALS_WL_M\t\t0x04\n#define CM36651_ALS_WL_L\t\t0x05\n#define CM36651_CS_CONF3\t\t0x06\n#define CM36651_CS_CONF_REG_NUM\t\t0x02\n\n \n#define CM36651_PS_CONF1\t\t0x00\n#define CM36651_PS_THD\t\t\t0x01\n#define CM36651_PS_CANC\t\t\t0x02\n#define CM36651_PS_CONF2\t\t0x03\n#define CM36651_PS_REG_NUM\t\t0x04\n\n \n#define CM36651_ALS_ENABLE\t\t0x00\n#define CM36651_ALS_DISABLE\t\t0x01\n#define CM36651_ALS_INT_EN\t\t0x02\n#define CM36651_ALS_THRES\t\t0x04\n\n \n#define CM36651_CS_CONF2_DEFAULT_BIT\t0x08\n\n \n#define CM36651_CS_IT1\t\t\t0x00  \n#define CM36651_CS_IT2\t\t\t0x40  \n#define CM36651_CS_IT3\t\t\t0x80  \n#define CM36651_CS_IT4\t\t\t0xC0  \n\n \n#define CM36651_PS_ENABLE\t\t0x00\n#define CM36651_PS_DISABLE\t\t0x01\n#define CM36651_PS_INT_EN\t\t0x02\n#define CM36651_PS_PERS2\t\t0x04\n#define CM36651_PS_PERS3\t\t0x08\n#define CM36651_PS_PERS4\t\t0x0C\n\n \n#define CM36651_PS_IT1\t\t\t0x00  \n#define CM36651_PS_IT2\t\t\t0x10  \n#define CM36651_PS_IT3\t\t\t0x20  \n#define CM36651_PS_IT4\t\t\t0x30  \n\n \n#define CM36651_PS_DR1\t\t\t0x00  \n#define CM36651_PS_DR2\t\t\t0x40  \n#define CM36651_PS_DR3\t\t\t0x80  \n#define CM36651_PS_DR4\t\t\t0xC0  \n\n \n#define CM36651_PS_INITIAL_THD\t\t0x05\n\n \n#define CM36651_PS_CANC_DEFAULT\t\t0x00\n\n \n#define CM36651_PS_HYS1\t\t\t0x00\n#define CM36651_PS_HYS2\t\t\t0x01\n#define CM36651_PS_SMART_PERS_EN\t0x02\n#define CM36651_PS_DIR_INT\t\t0x04\n#define CM36651_PS_MS\t\t\t0x10\n\n#define CM36651_CS_COLOR_NUM\t\t4\n\n#define CM36651_CLOSE_PROXIMITY\t\t0x32\n#define CM36651_FAR_PROXIMITY\t\t\t0x33\n\n#define CM36651_CS_INT_TIME_AVAIL\t\"0.08 0.16 0.32 0.64\"\n#define CM36651_PS_INT_TIME_AVAIL\t\"0.000320 0.000420 0.000520 0.000640\"\n\nenum cm36651_operation_mode {\n\tCM36651_LIGHT_EN,\n\tCM36651_PROXIMITY_EN,\n\tCM36651_PROXIMITY_EV_EN,\n};\n\nenum cm36651_light_channel_idx {\n\tCM36651_LIGHT_CHANNEL_IDX_RED,\n\tCM36651_LIGHT_CHANNEL_IDX_GREEN,\n\tCM36651_LIGHT_CHANNEL_IDX_BLUE,\n\tCM36651_LIGHT_CHANNEL_IDX_CLEAR,\n};\n\nenum cm36651_command {\n\tCM36651_CMD_READ_RAW_LIGHT,\n\tCM36651_CMD_READ_RAW_PROXIMITY,\n\tCM36651_CMD_PROX_EV_EN,\n\tCM36651_CMD_PROX_EV_DIS,\n};\n\nstatic const u8 cm36651_cs_reg[CM36651_CS_CONF_REG_NUM] = {\n\tCM36651_CS_CONF1,\n\tCM36651_CS_CONF2,\n};\n\nstatic const u8 cm36651_ps_reg[CM36651_PS_REG_NUM] = {\n\tCM36651_PS_CONF1,\n\tCM36651_PS_THD,\n\tCM36651_PS_CANC,\n\tCM36651_PS_CONF2,\n};\n\nstruct cm36651_data {\n\tconst struct cm36651_platform_data *pdata;\n\tstruct i2c_client *client;\n\tstruct i2c_client *ps_client;\n\tstruct i2c_client *ara_client;\n\tstruct mutex lock;\n\tstruct regulator *vled_reg;\n\tunsigned long flags;\n\tint cs_int_time[CM36651_CS_COLOR_NUM];\n\tint ps_int_time;\n\tu8 cs_ctrl_regs[CM36651_CS_CONF_REG_NUM];\n\tu8 ps_ctrl_regs[CM36651_PS_REG_NUM];\n\tu16 color[CM36651_CS_COLOR_NUM];\n};\n\nstatic int cm36651_setup_reg(struct cm36651_data *cm36651)\n{\n\tstruct i2c_client *client = cm36651->client;\n\tstruct i2c_client *ps_client = cm36651->ps_client;\n\tint i, ret;\n\n\t \n\tcm36651->cs_ctrl_regs[CM36651_CS_CONF1] = CM36651_ALS_ENABLE |\n\t\t\t\t\t\t\t     CM36651_ALS_THRES;\n\tcm36651->cs_ctrl_regs[CM36651_CS_CONF2] = CM36651_CS_CONF2_DEFAULT_BIT;\n\n\tfor (i = 0; i < CM36651_CS_CONF_REG_NUM; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, cm36651_cs_reg[i],\n\t\t\t\t\t\t     cm36651->cs_ctrl_regs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tcm36651->ps_ctrl_regs[CM36651_PS_CONF1] = CM36651_PS_ENABLE |\n\t\t\t\t\t\t\t\tCM36651_PS_IT2;\n\tcm36651->ps_ctrl_regs[CM36651_PS_THD] = CM36651_PS_INITIAL_THD;\n\tcm36651->ps_ctrl_regs[CM36651_PS_CANC] = CM36651_PS_CANC_DEFAULT;\n\tcm36651->ps_ctrl_regs[CM36651_PS_CONF2] = CM36651_PS_HYS2 |\n\t\t\t\tCM36651_PS_DIR_INT | CM36651_PS_SMART_PERS_EN;\n\n\tfor (i = 0; i < CM36651_PS_REG_NUM; i++) {\n\t\tret = i2c_smbus_write_byte_data(ps_client, cm36651_ps_reg[i],\n\t\t\t\t\t\t     cm36651->ps_ctrl_regs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\n\t\t\t\t\t\t\t  CM36651_ALS_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(cm36651->ps_client,\n\t\t\t\t\t CM36651_PS_CONF1, CM36651_PS_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cm36651_read_output(struct cm36651_data *cm36651,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val)\n{\n\tstruct i2c_client *client = cm36651->client;\n\tint ret = -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\t*val = i2c_smbus_read_word_data(client, chan->address);\n\t\tif (*val < 0)\n\t\t\treturn ret;\n\n\t\tret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\n\t\t\t\t\t\t\tCM36651_ALS_DISABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\t*val = i2c_smbus_read_byte(cm36651->ps_client);\n\t\tif (*val < 0)\n\t\t\treturn ret;\n\n\t\tif (!test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\n\t\t\tret = i2c_smbus_write_byte_data(cm36651->ps_client,\n\t\t\t\t\tCM36651_PS_CONF1, CM36651_PS_DISABLE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t cm36651_irq_handler(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tstruct i2c_client *client = cm36651->client;\n\tint ev_dir, ret;\n\tu64 ev_code;\n\n\t \n\tret = i2c_smbus_read_byte(cm36651->ara_client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: Data read failed: %d\\n\", __func__, ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\tswitch (ret) {\n\tcase CM36651_CLOSE_PROXIMITY:\n\t\tev_dir = IIO_EV_DIR_RISING;\n\t\tbreak;\n\tcase CM36651_FAR_PROXIMITY:\n\t\tev_dir = IIO_EV_DIR_FALLING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: Data read wrong: %d\\n\", __func__, ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tev_code = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY,\n\t\t\t\tCM36651_CMD_READ_RAW_PROXIMITY,\n\t\t\t\tIIO_EV_TYPE_THRESH, ev_dir);\n\n\tiio_push_event(indio_dev, ev_code, iio_get_time_ns(indio_dev));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cm36651_set_operation_mode(struct cm36651_data *cm36651, int cmd)\n{\n\tstruct i2c_client *client = cm36651->client;\n\tstruct i2c_client *ps_client = cm36651->ps_client;\n\tint ret = -EINVAL;\n\n\tswitch (cmd) {\n\tcase CM36651_CMD_READ_RAW_LIGHT:\n\t\tret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\n\t\t\t\tcm36651->cs_ctrl_regs[CM36651_CS_CONF1]);\n\t\tbreak;\n\tcase CM36651_CMD_READ_RAW_PROXIMITY:\n\t\tif (test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags))\n\t\t\treturn CM36651_PROXIMITY_EV_EN;\n\n\t\tret = i2c_smbus_write_byte_data(ps_client, CM36651_PS_CONF1,\n\t\t\t\tcm36651->ps_ctrl_regs[CM36651_PS_CONF1]);\n\t\tbreak;\n\tcase CM36651_CMD_PROX_EV_EN:\n\t\tif (test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Already proximity event enable state\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tset_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\n\n\t\tret = i2c_smbus_write_byte_data(ps_client,\n\t\t\tcm36651_ps_reg[CM36651_PS_CONF1],\n\t\t\tCM36651_PS_INT_EN | CM36651_PS_PERS2 | CM36651_PS_IT2);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Proximity enable event failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase CM36651_CMD_PROX_EV_DIS:\n\t\tif (!test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Already proximity event disable state\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tclear_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\n\t\tret = i2c_smbus_write_byte_data(ps_client,\n\t\t\t\t\tCM36651_PS_CONF1, CM36651_PS_DISABLE);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Write register failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cm36651_read_channel(struct cm36651_data *cm36651,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val)\n{\n\tstruct i2c_client *client = cm36651->client;\n\tint cmd, ret;\n\n\tif (chan->type == IIO_LIGHT)\n\t\tcmd = CM36651_CMD_READ_RAW_LIGHT;\n\telse if (chan->type == IIO_PROXIMITY)\n\t\tcmd = CM36651_CMD_READ_RAW_PROXIMITY;\n\telse\n\t\treturn -EINVAL;\n\n\tret = cm36651_set_operation_mode(cm36651, cmd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"CM36651 set operation mode failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tmsleep(50);\n\tret = cm36651_read_output(cm36651, chan, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"CM36651 read output failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int cm36651_read_int_time(struct cm36651_data *cm36651,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val2)\n{\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tif (cm36651->cs_int_time[chan->address] == CM36651_CS_IT1)\n\t\t\t*val2 = 80000;\n\t\telse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT2)\n\t\t\t*val2 = 160000;\n\t\telse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT3)\n\t\t\t*val2 = 320000;\n\t\telse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT4)\n\t\t\t*val2 = 640000;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\tif (cm36651->ps_int_time == CM36651_PS_IT1)\n\t\t\t*val2 = 320;\n\t\telse if (cm36651->ps_int_time == CM36651_PS_IT2)\n\t\t\t*val2 = 420;\n\t\telse if (cm36651->ps_int_time == CM36651_PS_IT3)\n\t\t\t*val2 = 520;\n\t\telse if (cm36651->ps_int_time == CM36651_PS_IT4)\n\t\t\t*val2 = 640;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int cm36651_write_int_time(struct cm36651_data *cm36651,\n\t\t\t\tstruct iio_chan_spec const *chan, int val)\n{\n\tstruct i2c_client *client = cm36651->client;\n\tstruct i2c_client *ps_client = cm36651->ps_client;\n\tint int_time, ret;\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tif (val == 80000)\n\t\t\tint_time = CM36651_CS_IT1;\n\t\telse if (val == 160000)\n\t\t\tint_time = CM36651_CS_IT2;\n\t\telse if (val == 320000)\n\t\t\tint_time = CM36651_CS_IT3;\n\t\telse if (val == 640000)\n\t\t\tint_time = CM36651_CS_IT4;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF3,\n\t\t\t\t\t   int_time >> 2 * (chan->address));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"CS integration time write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tcm36651->cs_int_time[chan->address] = int_time;\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\tif (val == 320)\n\t\t\tint_time = CM36651_PS_IT1;\n\t\telse if (val == 420)\n\t\t\tint_time = CM36651_PS_IT2;\n\t\telse if (val == 520)\n\t\t\tint_time = CM36651_PS_IT3;\n\t\telse if (val == 640)\n\t\t\tint_time = CM36651_PS_IT4;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tret = i2c_smbus_write_byte_data(ps_client,\n\t\t\t\t\t\tCM36651_PS_CONF1, int_time);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"PS integration time write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tcm36651->ps_int_time = int_time;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cm36651_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&cm36651->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = cm36651_read_channel(cm36651, chan, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\tret = cm36651_read_int_time(cm36651, chan, val2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&cm36651->lock);\n\n\treturn ret;\n}\n\nstatic int cm36651_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tstruct i2c_client *client = cm36651->client;\n\tint ret = -EINVAL;\n\n\tif (mask == IIO_CHAN_INFO_INT_TIME) {\n\t\tret = cm36651_write_int_time(cm36651, chan, val2);\n\t\tif (ret < 0)\n\t\t\tdev_err(&client->dev, \"Integration time write failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int cm36651_read_prox_thresh(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir,\n\t\t\t\t\tenum iio_event_info info,\n\t\t\t\t\tint *val, int *val2)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\n\t*val = cm36651->ps_ctrl_regs[CM36651_PS_THD];\n\n\treturn 0;\n}\n\nstatic int cm36651_write_prox_thresh(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir,\n\t\t\t\t\tenum iio_event_info info,\n\t\t\t\t\tint val, int val2)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tstruct i2c_client *client = cm36651->client;\n\tint ret;\n\n\tif (val < 3 || val > 255)\n\t\treturn -EINVAL;\n\n\tcm36651->ps_ctrl_regs[CM36651_PS_THD] = val;\n\tret = i2c_smbus_write_byte_data(cm36651->ps_client, CM36651_PS_THD,\n\t\t\t\t\tcm36651->ps_ctrl_regs[CM36651_PS_THD]);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"PS threshold write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cm36651_write_prox_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir,\n\t\t\t\t\tint state)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tint cmd, ret;\n\n\tmutex_lock(&cm36651->lock);\n\n\tcmd = state ? CM36651_CMD_PROX_EV_EN : CM36651_CMD_PROX_EV_DIS;\n\tret = cm36651_set_operation_mode(cm36651, cmd);\n\n\tmutex_unlock(&cm36651->lock);\n\n\treturn ret;\n}\n\nstatic int cm36651_read_prox_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir)\n{\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\tint event_en;\n\n\tmutex_lock(&cm36651->lock);\n\n\tevent_en = test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\n\n\tmutex_unlock(&cm36651->lock);\n\n\treturn event_en;\n}\n\n#define CM36651_LIGHT_CHANNEL(_color, _idx) {\t\t\\\n\t.type = IIO_LIGHT,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\t\\\n\t.address = _idx,\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_LIGHT_##_color,\t\t\\\n}\t\t\t\t\t\t\t\\\n\nstatic const struct iio_event_spec cm36651_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}\n};\n\nstatic const struct iio_chan_spec cm36651_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.event_spec = cm36651_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(cm36651_event_spec),\n\t},\n\tCM36651_LIGHT_CHANNEL(RED, CM36651_LIGHT_CHANNEL_IDX_RED),\n\tCM36651_LIGHT_CHANNEL(GREEN, CM36651_LIGHT_CHANNEL_IDX_GREEN),\n\tCM36651_LIGHT_CHANNEL(BLUE, CM36651_LIGHT_CHANNEL_IDX_BLUE),\n\tCM36651_LIGHT_CHANNEL(CLEAR, CM36651_LIGHT_CHANNEL_IDX_CLEAR),\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_integration_time_available,\n\t\t\t\t\tCM36651_CS_INT_TIME_AVAIL);\nstatic IIO_CONST_ATTR(in_proximity_integration_time_available,\n\t\t\t\t\tCM36651_PS_INT_TIME_AVAIL);\n\nstatic struct attribute *cm36651_attributes[] = {\n\t&iio_const_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_in_proximity_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cm36651_attribute_group = {\n\t.attrs = cm36651_attributes\n};\n\nstatic const struct iio_info cm36651_info = {\n\t.read_raw\t\t= &cm36651_read_raw,\n\t.write_raw\t\t= &cm36651_write_raw,\n\t.read_event_value\t= &cm36651_read_prox_thresh,\n\t.write_event_value\t= &cm36651_write_prox_thresh,\n\t.read_event_config\t= &cm36651_read_prox_event_config,\n\t.write_event_config\t= &cm36651_write_prox_event_config,\n\t.attrs\t\t\t= &cm36651_attribute_group,\n};\n\nstatic int cm36651_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct cm36651_data *cm36651;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*cm36651));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tcm36651 = iio_priv(indio_dev);\n\n\tcm36651->vled_reg = devm_regulator_get(&client->dev, \"vled\");\n\tif (IS_ERR(cm36651->vled_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(cm36651->vled_reg),\n\t\t\t\t     \"get regulator vled failed\\n\");\n\n\tret = regulator_enable(cm36651->vled_reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"enable regulator vled failed\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tcm36651->client = client;\n\tcm36651->ps_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t     CM36651_I2C_ADDR_PS);\n\tif (IS_ERR(cm36651->ps_client)) {\n\t\tdev_err(&client->dev, \"%s: new i2c device failed\\n\", __func__);\n\t\tret = PTR_ERR(cm36651->ps_client);\n\t\tgoto error_disable_reg;\n\t}\n\n\tcm36651->ara_client = i2c_new_dummy_device(client->adapter, CM36651_ARA);\n\tif (IS_ERR(cm36651->ara_client)) {\n\t\tdev_err(&client->dev, \"%s: new i2c device failed\\n\", __func__);\n\t\tret = PTR_ERR(cm36651->ara_client);\n\t\tgoto error_i2c_unregister_ps;\n\t}\n\n\tmutex_init(&cm36651->lock);\n\tindio_dev->channels = cm36651_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cm36651_channels);\n\tindio_dev->info = &cm36651_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = cm36651_setup_reg(cm36651);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: register setup failed\\n\", __func__);\n\t\tgoto error_i2c_unregister_ara;\n\t}\n\n\tret = request_threaded_irq(client->irq, NULL, cm36651_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\t\t\"cm36651\", indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: request irq failed\\n\", __func__);\n\t\tgoto error_i2c_unregister_ara;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: regist device failed\\n\", __func__);\n\t\tgoto error_free_irq;\n\t}\n\n\treturn 0;\n\nerror_free_irq:\n\tfree_irq(client->irq, indio_dev);\nerror_i2c_unregister_ara:\n\ti2c_unregister_device(cm36651->ara_client);\nerror_i2c_unregister_ps:\n\ti2c_unregister_device(cm36651->ps_client);\nerror_disable_reg:\n\tregulator_disable(cm36651->vled_reg);\n\treturn ret;\n}\n\nstatic void cm36651_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct cm36651_data *cm36651 = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(cm36651->vled_reg);\n\tfree_irq(client->irq, indio_dev);\n\ti2c_unregister_device(cm36651->ps_client);\n\ti2c_unregister_device(cm36651->ara_client);\n}\n\nstatic const struct i2c_device_id cm36651_id[] = {\n\t{ \"cm36651\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, cm36651_id);\n\nstatic const struct of_device_id cm36651_of_match[] = {\n\t{ .compatible = \"capella,cm36651\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cm36651_of_match);\n\nstatic struct i2c_driver cm36651_driver = {\n\t.driver = {\n\t\t.name\t= \"cm36651\",\n\t\t.of_match_table = cm36651_of_match,\n\t},\n\t.probe\t\t= cm36651_probe,\n\t.remove\t\t= cm36651_remove,\n\t.id_table\t= cm36651_id,\n};\n\nmodule_i2c_driver(cm36651_driver);\n\nMODULE_AUTHOR(\"Beomho Seo <beomho.seo@samsung.com>\");\nMODULE_DESCRIPTION(\"CM36651 proximity/ambient light sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}