{
  "module_name": "gp2ap020a00f.c",
  "hash_id": "c7d79f13e1f7902cfb424872d1b3ae7e4c249f9737d65d5f04c8e7353c9f13cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/gp2ap020a00f.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define GP2A_I2C_NAME \"gp2ap020a00f\"\n\n \n#define GP2AP020A00F_OP_REG\t0x00  \n#define GP2AP020A00F_ALS_REG\t0x01  \n#define GP2AP020A00F_PS_REG\t0x02  \n#define GP2AP020A00F_LED_REG\t0x03  \n#define GP2AP020A00F_TL_L_REG\t0x04  \n#define GP2AP020A00F_TL_H_REG\t0x05  \n#define GP2AP020A00F_TH_L_REG\t0x06  \n#define GP2AP020A00F_TH_H_REG\t0x07  \n#define GP2AP020A00F_PL_L_REG\t0x08  \n#define GP2AP020A00F_PL_H_REG\t0x09  \n#define GP2AP020A00F_PH_L_REG\t0x0a  \n#define GP2AP020A00F_PH_H_REG\t0x0b  \n#define GP2AP020A00F_D0_L_REG\t0x0c  \n#define GP2AP020A00F_D0_H_REG\t0x0d  \n#define GP2AP020A00F_D1_L_REG\t0x0e  \n#define GP2AP020A00F_D1_H_REG\t0x0f  \n#define GP2AP020A00F_D2_L_REG\t0x10  \n#define GP2AP020A00F_D2_H_REG\t0x11  \n#define GP2AP020A00F_NUM_REGS\t0x12  \n\n \n#define GP2AP020A00F_OP3_MASK\t\t0x80  \n#define GP2AP020A00F_OP3_SHUTDOWN\t0x00\n#define GP2AP020A00F_OP3_OPERATION\t0x80\n#define GP2AP020A00F_OP2_MASK\t\t0x40  \n#define GP2AP020A00F_OP2_AUTO_SHUTDOWN\t0x00\n#define GP2AP020A00F_OP2_CONT_OPERATION\t0x40\n#define GP2AP020A00F_OP_MASK\t\t0x30  \n#define GP2AP020A00F_OP_ALS_AND_PS\t0x00\n#define GP2AP020A00F_OP_ALS\t\t0x10\n#define GP2AP020A00F_OP_PS\t\t0x20\n#define GP2AP020A00F_OP_DEBUG\t\t0x30\n#define GP2AP020A00F_PROX_MASK\t\t0x08  \n#define GP2AP020A00F_PROX_NON_DETECT\t0x00\n#define GP2AP020A00F_PROX_DETECT\t0x08\n#define GP2AP020A00F_FLAG_P\t\t0x04  \n#define GP2AP020A00F_FLAG_A\t\t0x02  \n#define GP2AP020A00F_TYPE_MASK\t\t0x01  \n#define GP2AP020A00F_TYPE_MANUAL_CALC\t0x00\n#define GP2AP020A00F_TYPE_AUTO_CALC\t0x01\n\n \n#define GP2AP020A00F_PRST_MASK\t\t0xc0  \n#define GP2AP020A00F_PRST_ONCE\t\t0x00\n#define GP2AP020A00F_PRST_4_CYCLES\t0x40\n#define GP2AP020A00F_PRST_8_CYCLES\t0x80\n#define GP2AP020A00F_PRST_16_CYCLES\t0xc0\n#define GP2AP020A00F_RES_A_MASK\t\t0x38  \n#define GP2AP020A00F_RES_A_800ms\t0x00\n#define GP2AP020A00F_RES_A_400ms\t0x08\n#define GP2AP020A00F_RES_A_200ms\t0x10\n#define GP2AP020A00F_RES_A_100ms\t0x18\n#define GP2AP020A00F_RES_A_25ms\t\t0x20\n#define GP2AP020A00F_RES_A_6_25ms\t0x28\n#define GP2AP020A00F_RES_A_1_56ms\t0x30\n#define GP2AP020A00F_RES_A_0_39ms\t0x38\n#define GP2AP020A00F_RANGE_A_MASK\t0x07  \n#define GP2AP020A00F_RANGE_A_x1\t\t0x00\n#define GP2AP020A00F_RANGE_A_x2\t\t0x01\n#define GP2AP020A00F_RANGE_A_x4\t\t0x02\n#define GP2AP020A00F_RANGE_A_x8\t\t0x03\n#define GP2AP020A00F_RANGE_A_x16\t0x04\n#define GP2AP020A00F_RANGE_A_x32\t0x05\n#define GP2AP020A00F_RANGE_A_x64\t0x06\n#define GP2AP020A00F_RANGE_A_x128\t0x07\n\n \n#define GP2AP020A00F_ALC_MASK\t\t0x80  \n#define GP2AP020A00F_ALC_ON\t\t0x80\n#define GP2AP020A00F_ALC_OFF\t\t0x00\n#define GP2AP020A00F_INTTYPE_MASK\t0x40  \n#define GP2AP020A00F_INTTYPE_LEVEL\t0x00\n#define GP2AP020A00F_INTTYPE_PULSE\t0x40\n#define GP2AP020A00F_RES_P_MASK\t\t0x38  \n#define GP2AP020A00F_RES_P_800ms_x2\t0x00\n#define GP2AP020A00F_RES_P_400ms_x2\t0x08\n#define GP2AP020A00F_RES_P_200ms_x2\t0x10\n#define GP2AP020A00F_RES_P_100ms_x2\t0x18\n#define GP2AP020A00F_RES_P_25ms_x2\t0x20\n#define GP2AP020A00F_RES_P_6_25ms_x2\t0x28\n#define GP2AP020A00F_RES_P_1_56ms_x2\t0x30\n#define GP2AP020A00F_RES_P_0_39ms_x2\t0x38\n#define GP2AP020A00F_RANGE_P_MASK\t0x07  \n#define GP2AP020A00F_RANGE_P_x1\t\t0x00\n#define GP2AP020A00F_RANGE_P_x2\t\t0x01\n#define GP2AP020A00F_RANGE_P_x4\t\t0x02\n#define GP2AP020A00F_RANGE_P_x8\t\t0x03\n#define GP2AP020A00F_RANGE_P_x16\t0x04\n#define GP2AP020A00F_RANGE_P_x32\t0x05\n#define GP2AP020A00F_RANGE_P_x64\t0x06\n#define GP2AP020A00F_RANGE_P_x128\t0x07\n\n \n#define GP2AP020A00F_INTVAL_MASK\t0xc0  \n#define GP2AP020A00F_INTVAL_0\t\t0x00\n#define GP2AP020A00F_INTVAL_4\t\t0x40\n#define GP2AP020A00F_INTVAL_8\t\t0x80\n#define GP2AP020A00F_INTVAL_16\t\t0xc0\n#define GP2AP020A00F_IS_MASK\t\t0x30  \n#define GP2AP020A00F_IS_13_8mA\t\t0x00\n#define GP2AP020A00F_IS_27_5mA\t\t0x10\n#define GP2AP020A00F_IS_55mA\t\t0x20\n#define GP2AP020A00F_IS_110mA\t\t0x30\n#define GP2AP020A00F_PIN_MASK\t\t0x0c  \n#define GP2AP020A00F_PIN_ALS_OR_PS\t0x00\n#define GP2AP020A00F_PIN_ALS\t\t0x04\n#define GP2AP020A00F_PIN_PS\t\t0x08\n#define GP2AP020A00F_PIN_PS_DETECT\t0x0c\n#define GP2AP020A00F_FREQ_MASK\t\t0x02  \n#define GP2AP020A00F_FREQ_327_5kHz\t0x00\n#define GP2AP020A00F_FREQ_81_8kHz\t0x02\n#define GP2AP020A00F_RST\t\t0x01  \n\n#define GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR\t0\n#define GP2AP020A00F_SCAN_MODE_LIGHT_IR\t\t1\n#define GP2AP020A00F_SCAN_MODE_PROXIMITY\t2\n#define GP2AP020A00F_CHAN_TIMESTAMP\t\t3\n\n#define GP2AP020A00F_DATA_READY_TIMEOUT\t\tmsecs_to_jiffies(1000)\n#define GP2AP020A00F_DATA_REG(chan)\t\t(GP2AP020A00F_D0_L_REG + \\\n\t\t\t\t\t\t\t(chan) * 2)\n#define GP2AP020A00F_THRESH_REG(th_val_id)\t(GP2AP020A00F_TL_L_REG + \\\n\t\t\t\t\t\t\t(th_val_id) * 2)\n#define GP2AP020A00F_THRESH_VAL_ID(reg_addr)\t((reg_addr - 4) / 2)\n\n#define GP2AP020A00F_SUBTRACT_MODE\t0\n#define GP2AP020A00F_ADD_MODE\t\t1\n\n#define GP2AP020A00F_MAX_CHANNELS\t3\n\nenum gp2ap020a00f_opmode {\n\tGP2AP020A00F_OPMODE_READ_RAW_CLEAR,\n\tGP2AP020A00F_OPMODE_READ_RAW_IR,\n\tGP2AP020A00F_OPMODE_READ_RAW_PROXIMITY,\n\tGP2AP020A00F_OPMODE_ALS,\n\tGP2AP020A00F_OPMODE_PS,\n\tGP2AP020A00F_OPMODE_ALS_AND_PS,\n\tGP2AP020A00F_OPMODE_PROX_DETECT,\n\tGP2AP020A00F_OPMODE_SHUTDOWN,\n\tGP2AP020A00F_NUM_OPMODES,\n};\n\nenum gp2ap020a00f_cmd {\n\tGP2AP020A00F_CMD_READ_RAW_CLEAR,\n\tGP2AP020A00F_CMD_READ_RAW_IR,\n\tGP2AP020A00F_CMD_READ_RAW_PROXIMITY,\n\tGP2AP020A00F_CMD_TRIGGER_CLEAR_EN,\n\tGP2AP020A00F_CMD_TRIGGER_CLEAR_DIS,\n\tGP2AP020A00F_CMD_TRIGGER_IR_EN,\n\tGP2AP020A00F_CMD_TRIGGER_IR_DIS,\n\tGP2AP020A00F_CMD_TRIGGER_PROX_EN,\n\tGP2AP020A00F_CMD_TRIGGER_PROX_DIS,\n\tGP2AP020A00F_CMD_ALS_HIGH_EV_EN,\n\tGP2AP020A00F_CMD_ALS_HIGH_EV_DIS,\n\tGP2AP020A00F_CMD_ALS_LOW_EV_EN,\n\tGP2AP020A00F_CMD_ALS_LOW_EV_DIS,\n\tGP2AP020A00F_CMD_PROX_HIGH_EV_EN,\n\tGP2AP020A00F_CMD_PROX_HIGH_EV_DIS,\n\tGP2AP020A00F_CMD_PROX_LOW_EV_EN,\n\tGP2AP020A00F_CMD_PROX_LOW_EV_DIS,\n};\n\nenum gp2ap020a00f_flags {\n\tGP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER,\n\tGP2AP020A00F_FLAG_ALS_IR_TRIGGER,\n\tGP2AP020A00F_FLAG_PROX_TRIGGER,\n\tGP2AP020A00F_FLAG_PROX_RISING_EV,\n\tGP2AP020A00F_FLAG_PROX_FALLING_EV,\n\tGP2AP020A00F_FLAG_ALS_RISING_EV,\n\tGP2AP020A00F_FLAG_ALS_FALLING_EV,\n\tGP2AP020A00F_FLAG_LUX_MODE_HI,\n\tGP2AP020A00F_FLAG_DATA_READY,\n};\n\nenum gp2ap020a00f_thresh_val_id {\n\tGP2AP020A00F_THRESH_TL,\n\tGP2AP020A00F_THRESH_TH,\n\tGP2AP020A00F_THRESH_PL,\n\tGP2AP020A00F_THRESH_PH,\n};\n\nstruct gp2ap020a00f_data {\n\tconst struct gp2ap020a00f_platform_data *pdata;\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tchar *buffer;\n\tstruct regulator *vled_reg;\n\tunsigned long flags;\n\tenum gp2ap020a00f_opmode cur_opmode;\n\tstruct iio_trigger *trig;\n\tstruct regmap *regmap;\n\tunsigned int thresh_val[4];\n\tu8 debug_reg_addr;\n\tstruct irq_work work;\n\twait_queue_head_t data_ready_queue;\n};\n\nstatic const u8 gp2ap020a00f_reg_init_tab[] = {\n\t[GP2AP020A00F_OP_REG] = GP2AP020A00F_OP3_SHUTDOWN,\n\t[GP2AP020A00F_ALS_REG] = GP2AP020A00F_RES_A_25ms |\n\t\t\t\t GP2AP020A00F_RANGE_A_x8,\n\t[GP2AP020A00F_PS_REG] = GP2AP020A00F_ALC_ON |\n\t\t\t\tGP2AP020A00F_RES_P_1_56ms_x2 |\n\t\t\t\tGP2AP020A00F_RANGE_P_x4,\n\t[GP2AP020A00F_LED_REG] = GP2AP020A00F_INTVAL_0 |\n\t\t\t\t GP2AP020A00F_IS_110mA |\n\t\t\t\t GP2AP020A00F_FREQ_327_5kHz,\n\t[GP2AP020A00F_TL_L_REG] = 0,\n\t[GP2AP020A00F_TL_H_REG] = 0,\n\t[GP2AP020A00F_TH_L_REG] = 0,\n\t[GP2AP020A00F_TH_H_REG] = 0,\n\t[GP2AP020A00F_PL_L_REG] = 0,\n\t[GP2AP020A00F_PL_H_REG] = 0,\n\t[GP2AP020A00F_PH_L_REG] = 0,\n\t[GP2AP020A00F_PH_H_REG] = 0,\n};\n\nstatic bool gp2ap020a00f_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase GP2AP020A00F_OP_REG:\n\tcase GP2AP020A00F_D0_L_REG:\n\tcase GP2AP020A00F_D0_H_REG:\n\tcase GP2AP020A00F_D1_L_REG:\n\tcase GP2AP020A00F_D1_H_REG:\n\tcase GP2AP020A00F_D2_L_REG:\n\tcase GP2AP020A00F_D2_H_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config gp2ap020a00f_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = GP2AP020A00F_D2_H_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.volatile_reg = gp2ap020a00f_is_volatile_reg,\n};\n\nstatic const struct gp2ap020a00f_mutable_config_regs {\n\tu8 op_reg;\n\tu8 als_reg;\n\tu8 ps_reg;\n\tu8 led_reg;\n} opmode_regs_settings[GP2AP020A00F_NUM_OPMODES] = {\n\t[GP2AP020A00F_OPMODE_READ_RAW_CLEAR] = {\n\t\tGP2AP020A00F_OP_ALS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_AUTO_CALC,\n\t\tGP2AP020A00F_PRST_ONCE,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_ALS\n\t},\n\t[GP2AP020A00F_OPMODE_READ_RAW_IR] = {\n\t\tGP2AP020A00F_OP_ALS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_MANUAL_CALC,\n\t\tGP2AP020A00F_PRST_ONCE,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_ALS\n\t},\n\t[GP2AP020A00F_OPMODE_READ_RAW_PROXIMITY] = {\n\t\tGP2AP020A00F_OP_PS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_MANUAL_CALC,\n\t\tGP2AP020A00F_PRST_ONCE,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_PS\n\t},\n\t[GP2AP020A00F_OPMODE_PROX_DETECT] = {\n\t\tGP2AP020A00F_OP_PS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_MANUAL_CALC,\n\t\tGP2AP020A00F_PRST_4_CYCLES,\n\t\tGP2AP020A00F_INTTYPE_PULSE,\n\t\tGP2AP020A00F_PIN_PS_DETECT\n\t},\n\t[GP2AP020A00F_OPMODE_ALS] = {\n\t\tGP2AP020A00F_OP_ALS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_AUTO_CALC,\n\t\tGP2AP020A00F_PRST_ONCE,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_ALS\n\t},\n\t[GP2AP020A00F_OPMODE_PS] = {\n\t\tGP2AP020A00F_OP_PS | GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_MANUAL_CALC,\n\t\tGP2AP020A00F_PRST_4_CYCLES,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_PS\n\t},\n\t[GP2AP020A00F_OPMODE_ALS_AND_PS] = {\n\t\tGP2AP020A00F_OP_ALS_AND_PS\n\t\t| GP2AP020A00F_OP2_CONT_OPERATION\n\t\t| GP2AP020A00F_OP3_OPERATION\n\t\t| GP2AP020A00F_TYPE_AUTO_CALC,\n\t\tGP2AP020A00F_PRST_4_CYCLES,\n\t\tGP2AP020A00F_INTTYPE_LEVEL,\n\t\tGP2AP020A00F_PIN_ALS_OR_PS\n\t},\n\t[GP2AP020A00F_OPMODE_SHUTDOWN] = { GP2AP020A00F_OP3_SHUTDOWN, },\n};\n\nstatic int gp2ap020a00f_set_operation_mode(struct gp2ap020a00f_data *data,\n\t\t\t\t\tenum gp2ap020a00f_opmode op)\n{\n\tunsigned int op_reg_val;\n\tint err;\n\n\tif (op != GP2AP020A00F_OPMODE_SHUTDOWN) {\n\t\terr = regmap_read(data->regmap, GP2AP020A00F_OP_REG,\n\t\t\t\t\t&op_reg_val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tif ((opmode_regs_settings[op].op_reg & GP2AP020A00F_OP_MASK) !=\n\t\t    (op_reg_val & GP2AP020A00F_OP_MASK)) {\n\t\t\t \n\t\t\terr = regmap_update_bits(data->regmap,\n\t\t\t\tGP2AP020A00F_OP_REG, GP2AP020A00F_OP3_MASK,\n\t\t\t\tGP2AP020A00F_OP3_SHUTDOWN);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = regmap_update_bits(data->regmap, GP2AP020A00F_ALS_REG,\n\t\t\tGP2AP020A00F_PRST_MASK, opmode_regs_settings[op]\n\t\t\t\t\t\t\t\t.als_reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = regmap_update_bits(data->regmap, GP2AP020A00F_PS_REG,\n\t\t\tGP2AP020A00F_INTTYPE_MASK, opmode_regs_settings[op]\n\t\t\t\t\t\t\t\t.ps_reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = regmap_update_bits(data->regmap, GP2AP020A00F_LED_REG,\n\t\t\tGP2AP020A00F_PIN_MASK, opmode_regs_settings[op]\n\t\t\t\t\t\t\t\t.led_reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = regmap_update_bits(data->regmap,\n\t\t\t\t GP2AP020A00F_OP_REG,\n\t\t\t\t GP2AP020A00F_OP_MASK | GP2AP020A00F_OP2_MASK |\n\t\t\t\t GP2AP020A00F_OP3_MASK | GP2AP020A00F_TYPE_MASK,\n\t\t\t\t opmode_regs_settings[op].op_reg);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata->cur_opmode = op;\n\n\treturn 0;\n}\n\nstatic bool gp2ap020a00f_als_enabled(struct gp2ap020a00f_data *data)\n{\n\treturn test_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags) ||\n\t       test_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags) ||\n\t       test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags) ||\n\t       test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\n}\n\nstatic bool gp2ap020a00f_prox_detect_enabled(struct gp2ap020a00f_data *data)\n{\n\treturn test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags) ||\n\t       test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\n}\n\nstatic int gp2ap020a00f_write_event_threshold(struct gp2ap020a00f_data *data,\n\t\t\t\tenum gp2ap020a00f_thresh_val_id th_val_id,\n\t\t\t\tbool enable)\n{\n\t__le16 thresh_buf = 0;\n\tunsigned int thresh_reg_val;\n\n\tif (!enable)\n\t\tthresh_reg_val = 0;\n\telse if (test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags) &&\n\t\t th_val_id != GP2AP020A00F_THRESH_PL &&\n\t\t th_val_id != GP2AP020A00F_THRESH_PH)\n\t\t \n\t\tthresh_reg_val = data->thresh_val[th_val_id] / 16;\n\telse\n\t\tthresh_reg_val = data->thresh_val[th_val_id] > 16000 ?\n\t\t\t\t\t16000 :\n\t\t\t\t\tdata->thresh_val[th_val_id];\n\n\tthresh_buf = cpu_to_le16(thresh_reg_val);\n\n\treturn regmap_bulk_write(data->regmap,\n\t\t\t\t GP2AP020A00F_THRESH_REG(th_val_id),\n\t\t\t\t (u8 *)&thresh_buf, 2);\n}\n\nstatic int gp2ap020a00f_alter_opmode(struct gp2ap020a00f_data *data,\n\t\t\tenum gp2ap020a00f_opmode diff_mode, int add_sub)\n{\n\tenum gp2ap020a00f_opmode new_mode;\n\n\tif (diff_mode != GP2AP020A00F_OPMODE_ALS &&\n\t    diff_mode != GP2AP020A00F_OPMODE_PS)\n\t\treturn -EINVAL;\n\n\tif (add_sub == GP2AP020A00F_ADD_MODE) {\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_SHUTDOWN)\n\t\t\tnew_mode =  diff_mode;\n\t\telse\n\t\t\tnew_mode = GP2AP020A00F_OPMODE_ALS_AND_PS;\n\t} else {\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_ALS_AND_PS)\n\t\t\tnew_mode = (diff_mode == GP2AP020A00F_OPMODE_ALS) ?\n\t\t\t\t\tGP2AP020A00F_OPMODE_PS :\n\t\t\t\t\tGP2AP020A00F_OPMODE_ALS;\n\t\telse\n\t\t\tnew_mode = GP2AP020A00F_OPMODE_SHUTDOWN;\n\t}\n\n\treturn gp2ap020a00f_set_operation_mode(data, new_mode);\n}\n\nstatic int gp2ap020a00f_exec_cmd(struct gp2ap020a00f_data *data,\n\t\t\t\t\tenum gp2ap020a00f_cmd cmd)\n{\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase GP2AP020A00F_CMD_READ_RAW_CLEAR:\n\t\tif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\n\t\t\treturn -EBUSY;\n\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_READ_RAW_CLEAR);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_READ_RAW_IR:\n\t\tif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\n\t\t\treturn -EBUSY;\n\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_READ_RAW_IR);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_READ_RAW_PROXIMITY:\n\t\tif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\n\t\t\treturn -EBUSY;\n\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_READ_RAW_PROXIMITY);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_CLEAR_EN:\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_als_enabled(data))\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_ADD_MODE);\n\t\tset_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_CLEAR_DIS:\n\t\tclear_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags);\n\t\tif (gp2ap020a00f_als_enabled(data))\n\t\t\tbreak;\n\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_SUBTRACT_MODE);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_IR_EN:\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_als_enabled(data))\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_ADD_MODE);\n\t\tset_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_IR_DIS:\n\t\tclear_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags);\n\t\tif (gp2ap020a00f_als_enabled(data))\n\t\t\tbreak;\n\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_SUBTRACT_MODE);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_PROX_EN:\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\n\t\t\treturn -EBUSY;\n\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_PS,\n\t\t\t\t\t\tGP2AP020A00F_ADD_MODE);\n\t\tset_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_TRIGGER_PROX_DIS:\n\t\tclear_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &data->flags);\n\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_PS,\n\t\t\t\t\t\tGP2AP020A00F_SUBTRACT_MODE);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_ALS_HIGH_EV_EN:\n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_als_enabled(data)) {\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_ADD_MODE);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags);\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TH, true);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_ALS_HIGH_EV_DIS:\n\t\tif (!test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tclear_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags);\n\t\tif (!gp2ap020a00f_als_enabled(data)) {\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_SUBTRACT_MODE);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TH, false);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_ALS_LOW_EV_EN:\n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_als_enabled(data)) {\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_ADD_MODE);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TL, true);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_ALS_LOW_EV_DIS:\n\t\tif (!test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tclear_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\n\t\tif (!gp2ap020a00f_als_enabled(data)) {\n\t\t\terr = gp2ap020a00f_alter_opmode(data,\n\t\t\t\t\t\tGP2AP020A00F_OPMODE_ALS,\n\t\t\t\t\t\tGP2AP020A00F_SUBTRACT_MODE);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TL, false);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_PROX_HIGH_EV_EN:\n\t\tif (test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tif (gp2ap020a00f_als_enabled(data) ||\n\t\t    data->cur_opmode == GP2AP020A00F_OPMODE_PS)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_prox_detect_enabled(data)) {\n\t\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_PROX_DETECT);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags);\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_PH, true);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_PROX_HIGH_EV_DIS:\n\t\tif (!test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tclear_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags);\n\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_SHUTDOWN);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_PH, false);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_PROX_LOW_EV_EN:\n\t\tif (test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tif (gp2ap020a00f_als_enabled(data) ||\n\t\t    data->cur_opmode == GP2AP020A00F_OPMODE_PS)\n\t\t\treturn -EBUSY;\n\t\tif (!gp2ap020a00f_prox_detect_enabled(data)) {\n\t\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_PROX_DETECT);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_PL, true);\n\t\tbreak;\n\tcase GP2AP020A00F_CMD_PROX_LOW_EV_DIS:\n\t\tif (!test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags))\n\t\t\treturn 0;\n\t\tclear_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\n\t\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_SHUTDOWN);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_PL, false);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int wait_conversion_complete_irq(struct gp2ap020a00f_data *data)\n{\n\tint ret;\n\n\tret = wait_event_timeout(data->data_ready_queue,\n\t\t\t\t test_bit(GP2AP020A00F_FLAG_DATA_READY,\n\t\t\t\t\t  &data->flags),\n\t\t\t\t GP2AP020A00F_DATA_READY_TIMEOUT);\n\tclear_bit(GP2AP020A00F_FLAG_DATA_READY, &data->flags);\n\n\treturn ret > 0 ? 0 : -ETIME;\n}\n\nstatic int gp2ap020a00f_read_output(struct gp2ap020a00f_data *data,\n\t\t\t\t\tunsigned int output_reg, int *val)\n{\n\tu8 reg_buf[2];\n\tint err;\n\n\terr = wait_conversion_complete_irq(data);\n\tif (err < 0)\n\t\tdev_dbg(&data->client->dev, \"data ready timeout\\n\");\n\n\terr = regmap_bulk_read(data->regmap, output_reg, reg_buf, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = le16_to_cpup((__le16 *)reg_buf);\n\n\treturn err;\n}\n\nstatic bool gp2ap020a00f_adjust_lux_mode(struct gp2ap020a00f_data *data,\n\t\t\t\t int output_val)\n{\n\tu8 new_range = 0xff;\n\tint err;\n\n\tif (!test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags)) {\n\t\tif (output_val > 16000) {\n\t\t\tset_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags);\n\t\t\tnew_range = GP2AP020A00F_RANGE_A_x128;\n\t\t}\n\t} else {\n\t\tif (output_val < 1000) {\n\t\t\tclear_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags);\n\t\t\tnew_range = GP2AP020A00F_RANGE_A_x8;\n\t\t}\n\t}\n\n\tif (new_range != 0xff) {\n\t\t \n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TH, false);\n\t\tif (err < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Clearing als threshold register failed.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TL, false);\n\t\tif (err < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Clearing als threshold register failed.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\terr = regmap_update_bits(data->regmap,\n\t\t\tGP2AP020A00F_OP_REG,\n\t\t\tGP2AP020A00F_OP3_MASK,\n\t\t\tGP2AP020A00F_OP3_SHUTDOWN);\n\n\t\tif (err < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Shutting down the device failed.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\terr = regmap_update_bits(data->regmap,\n\t\t\tGP2AP020A00F_ALS_REG,\n\t\t\tGP2AP020A00F_RANGE_A_MASK,\n\t\t\tnew_range);\n\n\t\tif (err < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Adjusting device lux mode failed.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\terr = regmap_update_bits(data->regmap,\n\t\t\tGP2AP020A00F_OP_REG,\n\t\t\tGP2AP020A00F_OP3_MASK,\n\t\t\tGP2AP020A00F_OP3_OPERATION);\n\n\t\tif (err < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Powering up the device failed.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags)) {\n\t\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TH, true);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Adjusting als threshold value failed.\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags)) {\n\t\t\terr =  gp2ap020a00f_write_event_threshold(data,\n\t\t\t\t\tGP2AP020A00F_THRESH_TL, true);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Adjusting als threshold value failed.\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void gp2ap020a00f_output_to_lux(struct gp2ap020a00f_data *data,\n\t\t\t\t\t\tint *output_val)\n{\n\tif (test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags))\n\t\t*output_val *= 16;\n}\n\nstatic void gp2ap020a00f_iio_trigger_work(struct irq_work *work)\n{\n\tstruct gp2ap020a00f_data *data =\n\t\tcontainer_of(work, struct gp2ap020a00f_data, work);\n\n\tiio_trigger_poll(data->trig);\n}\n\nstatic irqreturn_t gp2ap020a00f_prox_sensing_handler(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\n\tunsigned int op_reg_val;\n\tint ret;\n\n\t \n\tret = regmap_read(priv->regmap, GP2AP020A00F_OP_REG, &op_reg_val);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (gp2ap020a00f_prox_detect_enabled(priv)) {\n\t\tif (op_reg_val & GP2AP020A00F_PROX_DETECT) {\n\t\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(\n\t\t\t\t    IIO_PROXIMITY,\n\t\t\t\t    GP2AP020A00F_SCAN_MODE_PROXIMITY,\n\t\t\t\t    IIO_EV_TYPE_ROC,\n\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t\t} else {\n\t\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(\n\t\t\t\t    IIO_PROXIMITY,\n\t\t\t\t    GP2AP020A00F_SCAN_MODE_PROXIMITY,\n\t\t\t\t    IIO_EV_TYPE_ROC,\n\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t gp2ap020a00f_thresh_event_handler(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\n\tu8 op_reg_flags, d0_reg_buf[2];\n\tunsigned int output_val, op_reg_val;\n\tint thresh_val_id, ret;\n\n\t \n\tret = regmap_read(priv->regmap, GP2AP020A00F_OP_REG,\n\t\t\t\t\t\t\t&op_reg_val);\n\tif (ret < 0)\n\t\tgoto done;\n\n\top_reg_flags = op_reg_val & (GP2AP020A00F_FLAG_A | GP2AP020A00F_FLAG_P\n\t\t\t\t\t| GP2AP020A00F_PROX_DETECT);\n\n\top_reg_val &= (~GP2AP020A00F_FLAG_A & ~GP2AP020A00F_FLAG_P\n\t\t\t\t\t& ~GP2AP020A00F_PROX_DETECT);\n\n\t \n\tif (priv->cur_opmode != GP2AP020A00F_OPMODE_PROX_DETECT) {\n\t\tret = regmap_write(priv->regmap, GP2AP020A00F_OP_REG,\n\t\t\t\t\t\t\t\top_reg_val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (op_reg_flags & GP2AP020A00F_FLAG_A) {\n\t\t \n\t\tret = regmap_bulk_read(priv->regmap, GP2AP020A00F_D0_L_REG,\n\t\t\t\t\t\t\td0_reg_buf, 2);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\toutput_val = le16_to_cpup((__le16 *)d0_reg_buf);\n\n\t\tif (gp2ap020a00f_adjust_lux_mode(priv, output_val))\n\t\t\tgoto done;\n\n\t\tgp2ap020a00f_output_to_lux(priv, &output_val);\n\n\t\t \n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &priv->flags)) {\n\t\t\tthresh_val_id =\n\t\t\t    GP2AP020A00F_THRESH_VAL_ID(GP2AP020A00F_TH_L_REG);\n\t\t\tif (output_val > priv->thresh_val[thresh_val_id])\n\t\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(\n\t\t\t\t\t    IIO_LIGHT,\n\t\t\t\t\t    GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR,\n\t\t\t\t\t    IIO_MOD_LIGHT_CLEAR,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t}\n\n\t\tif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &priv->flags)) {\n\t\t\tthresh_val_id =\n\t\t\t    GP2AP020A00F_THRESH_VAL_ID(GP2AP020A00F_TL_L_REG);\n\t\t\tif (output_val < priv->thresh_val[thresh_val_id])\n\t\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(\n\t\t\t\t\t    IIO_LIGHT,\n\t\t\t\t\t    GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR,\n\t\t\t\t\t    IIO_MOD_LIGHT_CLEAR,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t}\n\t}\n\n\tif (priv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_CLEAR ||\n\t    priv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_IR ||\n\t    priv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_PROXIMITY) {\n\t\tset_bit(GP2AP020A00F_FLAG_DATA_READY, &priv->flags);\n\t\twake_up(&priv->data_ready_queue);\n\t\tgoto done;\n\t}\n\n\tif (test_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &priv->flags) ||\n\t    test_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &priv->flags) ||\n\t    test_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &priv->flags))\n\t\t \n\t\tirq_work_queue(&priv->work);\n\ndone:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t gp2ap020a00f_trigger_handler(int irq, void *data)\n{\n\tstruct iio_poll_func *pf = data;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\n\tsize_t d_size = 0;\n\tint i, out_val, ret;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tret = regmap_bulk_read(priv->regmap,\n\t\t\t\tGP2AP020A00F_DATA_REG(i),\n\t\t\t\t&priv->buffer[d_size], 2);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tif (i == GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR ||\n\t\t    i == GP2AP020A00F_SCAN_MODE_LIGHT_IR) {\n\t\t\tout_val = le16_to_cpup((__le16 *)&priv->buffer[d_size]);\n\t\t\tgp2ap020a00f_output_to_lux(priv, &out_val);\n\n\t\t\tput_unaligned_le32(out_val, &priv->buffer[d_size]);\n\t\t\td_size += 4;\n\t\t} else {\n\t\t\td_size += 2;\n\t\t}\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, priv->buffer,\n\t\tpf->timestamp);\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u8 gp2ap020a00f_get_thresh_reg(const struct iio_chan_spec *chan,\n\t\t\t\t\t     enum iio_event_direction event_dir)\n{\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (event_dir == IIO_EV_DIR_RISING)\n\t\t\treturn GP2AP020A00F_PH_L_REG;\n\t\telse\n\t\t\treturn GP2AP020A00F_PL_L_REG;\n\tcase IIO_LIGHT:\n\t\tif (event_dir == IIO_EV_DIR_RISING)\n\t\t\treturn GP2AP020A00F_TH_L_REG;\n\t\telse\n\t\t\treturn GP2AP020A00F_TL_L_REG;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int gp2ap020a00f_write_event_val(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir,\n\t\t\t\t\tenum iio_event_info info,\n\t\t\t\t\tint val, int val2)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tbool event_en = false;\n\tu8 thresh_val_id;\n\tu8 thresh_reg_l;\n\tint err = 0;\n\n\tmutex_lock(&data->lock);\n\n\tthresh_reg_l = gp2ap020a00f_get_thresh_reg(chan, dir);\n\tthresh_val_id = GP2AP020A00F_THRESH_VAL_ID(thresh_reg_l);\n\n\tif (thresh_val_id > GP2AP020A00F_THRESH_PH) {\n\t\terr = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\n\tswitch (thresh_reg_l) {\n\tcase GP2AP020A00F_TH_L_REG:\n\t\tevent_en = test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV,\n\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_TL_L_REG:\n\t\tevent_en = test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV,\n\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_PH_L_REG:\n\t\tif (val == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto error_unlock;\n\t\t}\n\t\tevent_en = test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV,\n\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\tcase GP2AP020A00F_PL_L_REG:\n\t\tif (val == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto error_unlock;\n\t\t}\n\t\tevent_en = test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV,\n\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\t}\n\n\tdata->thresh_val[thresh_val_id] = val;\n\terr =  gp2ap020a00f_write_event_threshold(data, thresh_val_id,\n\t\t\t\t\t\t\tevent_en);\nerror_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int gp2ap020a00f_read_event_val(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       enum iio_event_info info,\n\t\t\t\t       int *val, int *val2)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tu8 thresh_reg_l;\n\tint err = IIO_VAL_INT;\n\n\tmutex_lock(&data->lock);\n\n\tthresh_reg_l = gp2ap020a00f_get_thresh_reg(chan, dir);\n\n\tif (thresh_reg_l > GP2AP020A00F_PH_L_REG) {\n\t\terr = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\n\t*val = data->thresh_val[GP2AP020A00F_THRESH_VAL_ID(thresh_reg_l)];\n\nerror_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int gp2ap020a00f_write_prox_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint state)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tenum gp2ap020a00f_cmd cmd_high_ev, cmd_low_ev;\n\tint err;\n\n\tcmd_high_ev = state ? GP2AP020A00F_CMD_PROX_HIGH_EV_EN :\n\t\t\t      GP2AP020A00F_CMD_PROX_HIGH_EV_DIS;\n\tcmd_low_ev = state ? GP2AP020A00F_CMD_PROX_LOW_EV_EN :\n\t\t\t     GP2AP020A00F_CMD_PROX_LOW_EV_DIS;\n\n\t \n\tif (state) {\n\t\tif (data->thresh_val[GP2AP020A00F_THRESH_PL] == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (data->thresh_val[GP2AP020A00F_THRESH_PH] == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = gp2ap020a00f_exec_cmd(data, cmd_high_ev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = gp2ap020a00f_exec_cmd(data, cmd_low_ev);\n\tif (err < 0)\n\t\treturn err;\n\n\tfree_irq(data->client->irq, indio_dev);\n\n\tif (state)\n\t\terr = request_threaded_irq(data->client->irq, NULL,\n\t\t\t\t\t   &gp2ap020a00f_prox_sensing_handler,\n\t\t\t\t\t   IRQF_TRIGGER_RISING |\n\t\t\t\t\t   IRQF_TRIGGER_FALLING |\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   \"gp2ap020a00f_prox_sensing\",\n\t\t\t\t\t   indio_dev);\n\telse {\n\t\terr = request_threaded_irq(data->client->irq, NULL,\n\t\t\t\t\t   &gp2ap020a00f_thresh_event_handler,\n\t\t\t\t\t   IRQF_TRIGGER_FALLING |\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   \"gp2ap020a00f_thresh_event\",\n\t\t\t\t\t   indio_dev);\n\t}\n\n\treturn err;\n}\n\nstatic int gp2ap020a00f_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   enum iio_event_type type,\n\t\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t\t   int state)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tenum gp2ap020a00f_cmd cmd;\n\tint err;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\terr = gp2ap020a00f_write_prox_event_config(indio_dev, state);\n\t\tbreak;\n\tcase IIO_LIGHT:\n\t\tif (dir == IIO_EV_DIR_RISING) {\n\t\t\tcmd = state ? GP2AP020A00F_CMD_ALS_HIGH_EV_EN :\n\t\t\t\t      GP2AP020A00F_CMD_ALS_HIGH_EV_DIS;\n\t\t\terr = gp2ap020a00f_exec_cmd(data, cmd);\n\t\t} else {\n\t\t\tcmd = state ? GP2AP020A00F_CMD_ALS_LOW_EV_EN :\n\t\t\t\t      GP2AP020A00F_CMD_ALS_LOW_EV_DIS;\n\t\t\terr = gp2ap020a00f_exec_cmd(data, cmd);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int gp2ap020a00f_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   enum iio_event_type type,\n\t\t\t\t\t   enum iio_event_direction dir)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tint event_en = 0;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tevent_en = test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV,\n\t\t\t\t\t\t\t\t&data->flags);\n\t\telse\n\t\t\tevent_en = test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV,\n\t\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\tcase IIO_LIGHT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tevent_en = test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV,\n\t\t\t\t\t\t\t\t&data->flags);\n\t\telse\n\t\t\tevent_en = test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV,\n\t\t\t\t\t\t\t\t&data->flags);\n\t\tbreak;\n\tdefault:\n\t\tevent_en = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn event_en;\n}\n\nstatic int gp2ap020a00f_read_channel(struct gp2ap020a00f_data *data,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val)\n{\n\tenum gp2ap020a00f_cmd cmd;\n\tint err;\n\n\tswitch (chan->scan_index) {\n\tcase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\n\t\tcmd = GP2AP020A00F_CMD_READ_RAW_CLEAR;\n\t\tbreak;\n\tcase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\n\t\tcmd = GP2AP020A00F_CMD_READ_RAW_IR;\n\t\tbreak;\n\tcase GP2AP020A00F_SCAN_MODE_PROXIMITY:\n\t\tcmd = GP2AP020A00F_CMD_READ_RAW_PROXIMITY;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = gp2ap020a00f_exec_cmd(data, cmd);\n\tif (err < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"gp2ap020a00f_exec_cmd failed\\n\");\n\t\tgoto error_ret;\n\t}\n\n\terr = gp2ap020a00f_read_output(data, chan->address, val);\n\tif (err < 0)\n\t\tdev_err(&data->client->dev,\n\t\t\t\"gp2ap020a00f_read_output failed\\n\");\n\n\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_SHUTDOWN);\n\tif (err < 0)\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Failed to shut down the device.\\n\");\n\n\tif (cmd == GP2AP020A00F_CMD_READ_RAW_CLEAR ||\n\t    cmd == GP2AP020A00F_CMD_READ_RAW_IR)\n\t\tgp2ap020a00f_output_to_lux(data, val);\n\nerror_ret:\n\treturn err;\n}\n\nstatic int gp2ap020a00f_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2,\n\t\t\t   long mask)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tint err = -EINVAL;\n\n\tif (mask == IIO_CHAN_INFO_RAW) {\n\t\terr = iio_device_claim_direct_mode(indio_dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = gp2ap020a00f_read_channel(data, chan, val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t}\n\treturn err < 0 ? err : IIO_VAL_INT;\n}\n\nstatic const struct iio_event_spec gp2ap020a00f_event_spec_light[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_event_spec gp2ap020a00f_event_spec_prox[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_ROC,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_ROC,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec gp2ap020a00f_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.channel2 = IIO_MOD_LIGHT_CLEAR,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 24,\n\t\t\t.shift = 0,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.scan_index = GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR,\n\t\t.address = GP2AP020A00F_D0_L_REG,\n\t\t.event_spec = gp2ap020a00f_event_spec_light,\n\t\t.num_event_specs = ARRAY_SIZE(gp2ap020a00f_event_spec_light),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 24,\n\t\t\t.shift = 0,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.scan_index = GP2AP020A00F_SCAN_MODE_LIGHT_IR,\n\t\t.address = GP2AP020A00F_D1_L_REG,\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.modified = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.shift = 0,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t\t.scan_index = GP2AP020A00F_SCAN_MODE_PROXIMITY,\n\t\t.address = GP2AP020A00F_D2_L_REG,\n\t\t.event_spec = gp2ap020a00f_event_spec_prox,\n\t\t.num_event_specs = ARRAY_SIZE(gp2ap020a00f_event_spec_prox),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(GP2AP020A00F_CHAN_TIMESTAMP),\n};\n\nstatic const struct iio_info gp2ap020a00f_info = {\n\t.read_raw = &gp2ap020a00f_read_raw,\n\t.read_event_value = &gp2ap020a00f_read_event_val,\n\t.read_event_config = &gp2ap020a00f_read_event_config,\n\t.write_event_value = &gp2ap020a00f_write_event_val,\n\t.write_event_config = &gp2ap020a00f_write_event_config,\n};\n\nstatic int gp2ap020a00f_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tint i, err = 0;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tswitch (i) {\n\t\tcase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_CLEAR_EN);\n\t\t\tbreak;\n\t\tcase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_IR_EN);\n\t\t\tbreak;\n\t\tcase GP2AP020A00F_SCAN_MODE_PROXIMITY:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_PROX_EN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (err < 0)\n\t\tgoto error_unlock;\n\n\tdata->buffer = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\n\tif (!data->buffer)\n\t\terr = -ENOMEM;\n\nerror_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic int gp2ap020a00f_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tint i, err = 0;\n\n\tmutex_lock(&data->lock);\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tswitch (i) {\n\t\tcase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_CLEAR_DIS);\n\t\t\tbreak;\n\t\tcase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_IR_DIS);\n\t\t\tbreak;\n\t\tcase GP2AP020A00F_SCAN_MODE_PROXIMITY:\n\t\t\terr = gp2ap020a00f_exec_cmd(data,\n\t\t\t\t\tGP2AP020A00F_CMD_TRIGGER_PROX_DIS);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (err == 0)\n\t\tkfree(data->buffer);\n\n\tmutex_unlock(&data->lock);\n\n\treturn err;\n}\n\nstatic const struct iio_buffer_setup_ops gp2ap020a00f_buffer_setup_ops = {\n\t.postenable = &gp2ap020a00f_buffer_postenable,\n\t.predisable = &gp2ap020a00f_buffer_predisable,\n};\n\nstatic int gp2ap020a00f_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct gp2ap020a00f_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\n\tdata->vled_reg = devm_regulator_get(&client->dev, \"vled\");\n\tif (IS_ERR(data->vled_reg))\n\t\treturn PTR_ERR(data->vled_reg);\n\n\terr = regulator_enable(data->vled_reg);\n\tif (err)\n\t\treturn err;\n\n\tregmap = devm_regmap_init_i2c(client, &gp2ap020a00f_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Regmap initialization failed.\\n\");\n\t\terr = PTR_ERR(regmap);\n\t\tgoto error_regulator_disable;\n\t}\n\n\t \n\terr = regmap_bulk_write(regmap, GP2AP020A00F_OP_REG,\n\t\t\tgp2ap020a00f_reg_init_tab,\n\t\t\tARRAY_SIZE(gp2ap020a00f_reg_init_tab));\n\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Device initialization failed.\\n\");\n\t\tgoto error_regulator_disable;\n\t}\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata->client = client;\n\tdata->cur_opmode = GP2AP020A00F_OPMODE_SHUTDOWN;\n\tdata->regmap = regmap;\n\tinit_waitqueue_head(&data->data_ready_queue);\n\n\tmutex_init(&data->lock);\n\tindio_dev->channels = gp2ap020a00f_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(gp2ap020a00f_channels);\n\tindio_dev->info = &gp2ap020a00f_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\terr = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\t&gp2ap020a00f_trigger_handler, &gp2ap020a00f_buffer_setup_ops);\n\tif (err < 0)\n\t\tgoto error_regulator_disable;\n\n\t \n\tdata->trig = devm_iio_trigger_alloc(&client->dev, \"%s-trigger\",\n\t\t\t\t\t\t\tindio_dev->name);\n\tif (data->trig == NULL) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&indio_dev->dev, \"Failed to allocate iio trigger.\\n\");\n\t\tgoto error_uninit_buffer;\n\t}\n\n\t \n\terr = request_threaded_irq(client->irq, NULL,\n\t\t\t\t   &gp2ap020a00f_thresh_event_handler,\n\t\t\t\t   IRQF_TRIGGER_FALLING |\n\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t   \"gp2ap020a00f_als_event\",\n\t\t\t\t   indio_dev);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Irq request failed.\\n\");\n\t\tgoto error_uninit_buffer;\n\t}\n\n\tinit_irq_work(&data->work, gp2ap020a00f_iio_trigger_work);\n\n\terr = iio_trigger_register(data->trig);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Failed to register iio trigger.\\n\");\n\t\tgoto error_free_irq;\n\t}\n\n\terr = iio_device_register(indio_dev);\n\tif (err < 0)\n\t\tgoto error_trigger_unregister;\n\n\treturn 0;\n\nerror_trigger_unregister:\n\tiio_trigger_unregister(data->trig);\nerror_free_irq:\n\tfree_irq(client->irq, indio_dev);\nerror_uninit_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerror_regulator_disable:\n\tregulator_disable(data->vled_reg);\n\n\treturn err;\n}\n\nstatic void gp2ap020a00f_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\n\tint err;\n\n\terr = gp2ap020a00f_set_operation_mode(data,\n\t\t\t\t\tGP2AP020A00F_OPMODE_SHUTDOWN);\n\tif (err < 0)\n\t\tdev_err(&indio_dev->dev, \"Failed to power off the device.\\n\");\n\n\tiio_device_unregister(indio_dev);\n\tiio_trigger_unregister(data->trig);\n\tfree_irq(client->irq, indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tregulator_disable(data->vled_reg);\n}\n\nstatic const struct i2c_device_id gp2ap020a00f_id[] = {\n\t{ GP2A_I2C_NAME, 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, gp2ap020a00f_id);\n\nstatic const struct of_device_id gp2ap020a00f_of_match[] = {\n\t{ .compatible = \"sharp,gp2ap020a00f\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gp2ap020a00f_of_match);\n\nstatic struct i2c_driver gp2ap020a00f_driver = {\n\t.driver = {\n\t\t.name\t= GP2A_I2C_NAME,\n\t\t.of_match_table = gp2ap020a00f_of_match,\n\t},\n\t.probe\t\t= gp2ap020a00f_probe,\n\t.remove\t\t= gp2ap020a00f_remove,\n\t.id_table\t= gp2ap020a00f_id,\n};\n\nmodule_i2c_driver(gp2ap020a00f_driver);\n\nMODULE_AUTHOR(\"Jacek Anaszewski <j.anaszewski@samsung.com>\");\nMODULE_DESCRIPTION(\"Sharp GP2AP020A00F Proximity/ALS sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}