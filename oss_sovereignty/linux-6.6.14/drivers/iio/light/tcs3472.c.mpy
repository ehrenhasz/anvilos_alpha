{
  "module_name": "tcs3472.c",
  "hash_id": "7c8f3356e47ef550ddf1d237397d3b0a59cfbfee590d080404f74862ef60848e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tcs3472.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define TCS3472_DRV_NAME \"tcs3472\"\n\n#define TCS3472_COMMAND BIT(7)\n#define TCS3472_AUTO_INCR BIT(5)\n#define TCS3472_SPECIAL_FUNC (BIT(5) | BIT(6))\n\n#define TCS3472_INTR_CLEAR (TCS3472_COMMAND | TCS3472_SPECIAL_FUNC | 0x06)\n\n#define TCS3472_ENABLE (TCS3472_COMMAND | 0x00)\n#define TCS3472_ATIME (TCS3472_COMMAND | 0x01)\n#define TCS3472_WTIME (TCS3472_COMMAND | 0x03)\n#define TCS3472_AILT (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x04)\n#define TCS3472_AIHT (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x06)\n#define TCS3472_PERS (TCS3472_COMMAND | 0x0c)\n#define TCS3472_CONFIG (TCS3472_COMMAND | 0x0d)\n#define TCS3472_CONTROL (TCS3472_COMMAND | 0x0f)\n#define TCS3472_ID (TCS3472_COMMAND | 0x12)\n#define TCS3472_STATUS (TCS3472_COMMAND | 0x13)\n#define TCS3472_CDATA (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x14)\n#define TCS3472_RDATA (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x16)\n#define TCS3472_GDATA (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x18)\n#define TCS3472_BDATA (TCS3472_COMMAND | TCS3472_AUTO_INCR | 0x1a)\n\n#define TCS3472_STATUS_AINT BIT(4)\n#define TCS3472_STATUS_AVALID BIT(0)\n#define TCS3472_ENABLE_AIEN BIT(4)\n#define TCS3472_ENABLE_AEN BIT(1)\n#define TCS3472_ENABLE_PON BIT(0)\n#define TCS3472_CONTROL_AGAIN_MASK (BIT(0) | BIT(1))\n\nstruct tcs3472_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu16 low_thresh;\n\tu16 high_thresh;\n\tu8 enable;\n\tu8 control;\n\tu8 atime;\n\tu8 apers;\n\t \n\tstruct {\n\t\tu16 chans[4];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\nstatic const struct iio_event_spec tcs3472_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\n#define TCS3472_CHANNEL(_color, _si, _addr) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBSCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = IIO_MOD_LIGHT_##_color, \\\n\t.address = _addr, \\\n\t.scan_index = _si, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n\t.event_spec = _si ? NULL : tcs3472_events, \\\n\t.num_event_specs = _si ? 0 : ARRAY_SIZE(tcs3472_events), \\\n}\n\nstatic const int tcs3472_agains[] = { 1, 4, 16, 60 };\n\nstatic const struct iio_chan_spec tcs3472_channels[] = {\n\tTCS3472_CHANNEL(CLEAR, 0, TCS3472_CDATA),\n\tTCS3472_CHANNEL(RED, 1, TCS3472_RDATA),\n\tTCS3472_CHANNEL(GREEN, 2, TCS3472_GDATA),\n\tTCS3472_CHANNEL(BLUE, 3, TCS3472_BDATA),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int tcs3472_req_data(struct tcs3472_data *data)\n{\n\tint tries = 50;\n\tint ret;\n\n\twhile (tries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, TCS3472_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & TCS3472_STATUS_AVALID)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcs3472_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = tcs3472_req_data(data);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = tcs3472_agains[data->control &\n\t\t\tTCS3472_CONTROL_AGAIN_MASK];\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = (256 - data->atime) * 2400;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int tcs3472_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val2 != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(tcs3472_agains); i++) {\n\t\t\tif (val == tcs3472_agains[i]) {\n\t\t\t\tdata->control &= ~TCS3472_CONTROL_AGAIN_MASK;\n\t\t\t\tdata->control |= i;\n\t\t\t\treturn i2c_smbus_write_byte_data(\n\t\t\t\t\tdata->client, TCS3472_CONTROL,\n\t\t\t\t\tdata->control);\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (val2 == (256 - i) * 2400) {\n\t\t\t\tdata->atime = i;\n\t\t\t\treturn i2c_smbus_write_byte_data(\n\t\t\t\t\tdata->client, TCS3472_ATIME,\n\t\t\t\t\tdata->atime);\n\t\t\t}\n\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic const int tcs3472_intr_pers[] = {\n\t0, 1, 2, 3, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60\n};\n\nstatic int tcs3472_read_event(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int *val,\n\tint *val2)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int period;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = (dir == IIO_EV_DIR_RISING) ?\n\t\t\tdata->high_thresh : data->low_thresh;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tperiod = (256 - data->atime) * 2400 *\n\t\t\ttcs3472_intr_pers[data->apers];\n\t\t*val = period / USEC_PER_SEC;\n\t\t*val2 = period % USEC_PER_SEC;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int tcs3472_write_event(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\tint val2)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 command;\n\tint period;\n\tint i;\n\n\tmutex_lock(&data->lock);\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tcommand = TCS3472_AIHT;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tcommand = TCS3472_AILT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tret = i2c_smbus_write_word_data(data->client, command, val);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tdata->high_thresh = val;\n\t\telse\n\t\t\tdata->low_thresh = val;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tperiod = val * USEC_PER_SEC + val2;\n\t\tfor (i = 1; i < ARRAY_SIZE(tcs3472_intr_pers) - 1; i++) {\n\t\t\tif (period <= (256 - data->atime) * 2400 *\n\t\t\t\t\ttcs3472_intr_pers[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tret = i2c_smbus_write_byte_data(data->client, TCS3472_PERS, i);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tdata->apers = i;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nerror:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int tcs3472_read_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = !!(data->enable & TCS3472_ENABLE_AIEN);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int tcs3472_write_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, int state)\n{\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\tu8 enable_old;\n\n\tmutex_lock(&data->lock);\n\n\tenable_old = data->enable;\n\n\tif (state)\n\t\tdata->enable |= TCS3472_ENABLE_AIEN;\n\telse\n\t\tdata->enable &= ~TCS3472_ENABLE_AIEN;\n\n\tif (enable_old != data->enable) {\n\t\tret = i2c_smbus_write_byte_data(data->client, TCS3472_ENABLE,\n\t\t\t\t\t\tdata->enable);\n\t\tif (ret)\n\t\t\tdata->enable = enable_old;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t tcs3472_event_handler(int irq, void *priv)\n{\n\tstruct iio_dev *indio_dev = priv;\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3472_STATUS);\n\tif (ret >= 0 && (ret & TCS3472_STATUS_AINT)) {\n\t\tiio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\tIIO_EV_DIR_EITHER),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\t\ti2c_smbus_read_byte_data(data->client, TCS3472_INTR_CLEAR);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tcs3472_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct tcs3472_data *data = iio_priv(indio_dev);\n\tint i, j = 0;\n\n\tint ret = tcs3472_req_data(data);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\tTCS3472_CDATA + 2*i);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tdata->scan.chans[j++] = ret;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t tcs3472_show_int_time_available(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 1; i <= 256; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"0.%06d \",\n\t\t\t2400 * i);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_CONST_ATTR(calibscale_available, \"1 4 16 60\");\nstatic IIO_DEV_ATTR_INT_TIME_AVAIL(tcs3472_show_int_time_available);\n\nstatic struct attribute *tcs3472_attributes[] = {\n\t&iio_const_attr_calibscale_available.dev_attr.attr,\n\t&iio_dev_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tcs3472_attribute_group = {\n\t.attrs = tcs3472_attributes,\n};\n\nstatic const struct iio_info tcs3472_info = {\n\t.read_raw = tcs3472_read_raw,\n\t.write_raw = tcs3472_write_raw,\n\t.read_event_value = tcs3472_read_event,\n\t.write_event_value = tcs3472_write_event,\n\t.read_event_config = tcs3472_read_event_config,\n\t.write_event_config = tcs3472_write_event_config,\n\t.attrs = &tcs3472_attribute_group,\n};\n\nstatic int tcs3472_probe(struct i2c_client *client)\n{\n\tstruct tcs3472_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &tcs3472_info;\n\tindio_dev->name = TCS3472_DRV_NAME;\n\tindio_dev->channels = tcs3472_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tcs3472_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3472_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0x44)\n\t\tdev_info(&client->dev, \"TCS34721/34725 found\\n\");\n\telse if (ret == 0x4d)\n\t\tdev_info(&client->dev, \"TCS34723/34727 found\\n\");\n\telse\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3472_CONTROL);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->control = ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3472_ATIME);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->atime = ret;\n\n\tret = i2c_smbus_read_word_data(data->client, TCS3472_AILT);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->low_thresh = ret;\n\n\tret = i2c_smbus_read_word_data(data->client, TCS3472_AIHT);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->high_thresh = ret;\n\n\tdata->apers = 1;\n\tret = i2c_smbus_write_byte_data(data->client, TCS3472_PERS,\n\t\t\t\t\tdata->apers);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3472_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->enable = ret | TCS3472_ENABLE_PON | TCS3472_ENABLE_AEN;\n\tdata->enable &= ~TCS3472_ENABLE_AIEN;\n\tret = i2c_smbus_write_byte_data(data->client, TCS3472_ENABLE,\n\t\tdata->enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\ttcs3472_trigger_handler, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = request_threaded_irq(client->irq, NULL,\n\t\t\t\t\t   tcs3472_event_handler,\n\t\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_SHARED |\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   client->name, indio_dev);\n\t\tif (ret)\n\t\t\tgoto buffer_cleanup;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto free_irq;\n\n\treturn 0;\n\nfree_irq:\n\tif (client->irq)\n\t\tfree_irq(client->irq, indio_dev);\nbuffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\treturn ret;\n}\n\nstatic int tcs3472_powerdown(struct tcs3472_data *data)\n{\n\tint ret;\n\tu8 enable_mask = TCS3472_ENABLE_AEN | TCS3472_ENABLE_PON;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(data->client, TCS3472_ENABLE,\n\t\tdata->enable & ~enable_mask);\n\tif (!ret)\n\t\tdata->enable &= ~enable_mask;\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic void tcs3472_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tif (client->irq)\n\t\tfree_irq(client->irq, indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\ttcs3472_powerdown(iio_priv(indio_dev));\n}\n\nstatic int tcs3472_suspend(struct device *dev)\n{\n\tstruct tcs3472_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\treturn tcs3472_powerdown(data);\n}\n\nstatic int tcs3472_resume(struct device *dev)\n{\n\tstruct tcs3472_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\tint ret;\n\tu8 enable_mask = TCS3472_ENABLE_AEN | TCS3472_ENABLE_PON;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(data->client, TCS3472_ENABLE,\n\t\tdata->enable | enable_mask);\n\tif (!ret)\n\t\tdata->enable |= enable_mask;\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tcs3472_pm_ops, tcs3472_suspend,\n\t\t\t\ttcs3472_resume);\n\nstatic const struct i2c_device_id tcs3472_id[] = {\n\t{ \"tcs3472\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tcs3472_id);\n\nstatic struct i2c_driver tcs3472_driver = {\n\t.driver = {\n\t\t.name\t= TCS3472_DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&tcs3472_pm_ops),\n\t},\n\t.probe\t\t= tcs3472_probe,\n\t.remove\t\t= tcs3472_remove,\n\t.id_table\t= tcs3472_id,\n};\nmodule_i2c_driver(tcs3472_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"TCS3472 color light sensors driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}