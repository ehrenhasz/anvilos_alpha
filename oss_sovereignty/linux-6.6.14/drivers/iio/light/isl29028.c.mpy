{
  "module_name": "isl29028.c",
  "hash_id": "42c4ba0be755b500bb623fff3de6800eab69c2607fc2e5c6912c10fe644c3d71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/isl29028.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/pm_runtime.h>\n\n#define ISL29028_CONV_TIME_MS\t\t\t100\n\n#define ISL29028_REG_CONFIGURE\t\t\t0x01\n\n#define ISL29028_CONF_ALS_IR_MODE_ALS\t\t0\n#define ISL29028_CONF_ALS_IR_MODE_IR\t\tBIT(0)\n#define ISL29028_CONF_ALS_IR_MODE_MASK\t\tBIT(0)\n\n#define ISL29028_CONF_ALS_RANGE_LOW_LUX\t\t0\n#define ISL29028_CONF_ALS_RANGE_HIGH_LUX\tBIT(1)\n#define ISL29028_CONF_ALS_RANGE_MASK\t\tBIT(1)\n\n#define ISL29028_CONF_ALS_DIS\t\t\t0\n#define ISL29028_CONF_ALS_EN\t\t\tBIT(2)\n#define ISL29028_CONF_ALS_EN_MASK\t\tBIT(2)\n\n#define ISL29028_CONF_PROX_SLP_SH\t\t4\n#define ISL29028_CONF_PROX_SLP_MASK\t\t(7 << ISL29028_CONF_PROX_SLP_SH)\n\n#define ISL29028_CONF_PROX_EN\t\t\tBIT(7)\n#define ISL29028_CONF_PROX_EN_MASK\t\tBIT(7)\n\n#define ISL29028_REG_INTERRUPT\t\t\t0x02\n\n#define ISL29028_REG_PROX_DATA\t\t\t0x08\n#define ISL29028_REG_ALSIR_L\t\t\t0x09\n#define ISL29028_REG_ALSIR_U\t\t\t0x0A\n\n#define ISL29028_REG_TEST1_MODE\t\t\t0x0E\n#define ISL29028_REG_TEST2_MODE\t\t\t0x0F\n\n#define ISL29028_NUM_REGS\t\t\t(ISL29028_REG_TEST2_MODE + 1)\n\n#define ISL29028_POWER_OFF_DELAY_MS\t\t2000\n\nstruct isl29028_prox_data {\n\tint sampling_int;\n\tint sampling_fract;\n\tint sleep_time;\n};\n\nstatic const struct isl29028_prox_data isl29028_prox_data[] = {\n\t{   1, 250000, 800 },\n\t{   2, 500000, 400 },\n\t{   5,      0, 200 },\n\t{  10,      0, 100 },\n\t{  13, 300000,  75 },\n\t{  20,      0,  50 },\n\t{  80,      0,  13 },  \n\t{ 100,  0,   0 }\n};\n\nenum isl29028_als_ir_mode {\n\tISL29028_MODE_NONE = 0,\n\tISL29028_MODE_ALS,\n\tISL29028_MODE_IR,\n};\n\nstruct isl29028_chip {\n\tstruct mutex\t\t\tlock;\n\tstruct regmap\t\t\t*regmap;\n\tint\t\t\t\tprox_sampling_int;\n\tint\t\t\t\tprox_sampling_frac;\n\tbool\t\t\t\tenable_prox;\n\tint\t\t\t\tlux_scale;\n\tenum isl29028_als_ir_mode\tals_ir_mode;\n};\n\nstatic int isl29028_find_prox_sleep_index(int sampling_int, int sampling_fract)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29028_prox_data); ++i) {\n\t\tif (isl29028_prox_data[i].sampling_int == sampling_int &&\n\t\t    isl29028_prox_data[i].sampling_fract == sampling_fract)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int isl29028_set_proxim_sampling(struct isl29028_chip *chip,\n\t\t\t\t\tint sampling_int, int sampling_fract)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint sleep_index, ret;\n\n\tsleep_index = isl29028_find_prox_sleep_index(sampling_int,\n\t\t\t\t\t\t     sampling_fract);\n\tif (sleep_index < 0)\n\t\treturn sleep_index;\n\n\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t ISL29028_CONF_PROX_SLP_MASK,\n\t\t\t\t sleep_index << ISL29028_CONF_PROX_SLP_SH);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): Error %d setting the proximity sampling\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tchip->prox_sampling_int = sampling_int;\n\tchip->prox_sampling_frac = sampling_fract;\n\n\treturn ret;\n}\n\nstatic int isl29028_enable_proximity(struct isl29028_chip *chip)\n{\n\tint prox_index, ret;\n\n\tret = isl29028_set_proxim_sampling(chip, chip->prox_sampling_int,\n\t\t\t\t\t   chip->prox_sampling_frac);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t ISL29028_CONF_PROX_EN_MASK,\n\t\t\t\t ISL29028_CONF_PROX_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tprox_index = isl29028_find_prox_sleep_index(chip->prox_sampling_int,\n\t\t\t\t\t\t    chip->prox_sampling_frac);\n\tif (prox_index < 0)\n\t\treturn prox_index;\n\n\tmsleep(isl29028_prox_data[prox_index].sleep_time);\n\n\treturn 0;\n}\n\nstatic int isl29028_set_als_scale(struct isl29028_chip *chip, int lux_scale)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint val = (lux_scale == 2000) ? ISL29028_CONF_ALS_RANGE_HIGH_LUX :\n\t\t\t\t\tISL29028_CONF_ALS_RANGE_LOW_LUX;\n\tint ret;\n\n\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t ISL29028_CONF_ALS_RANGE_MASK, val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): Error %d setting the ALS scale\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tchip->lux_scale = lux_scale;\n\n\treturn ret;\n}\n\nstatic int isl29028_set_als_ir_mode(struct isl29028_chip *chip,\n\t\t\t\t    enum isl29028_als_ir_mode mode)\n{\n\tint ret;\n\n\tif (chip->als_ir_mode == mode)\n\t\treturn 0;\n\n\tret = isl29028_set_als_scale(chip, chip->lux_scale);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mode) {\n\tcase ISL29028_MODE_ALS:\n\t\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t\t ISL29028_CONF_ALS_IR_MODE_MASK,\n\t\t\t\t\t ISL29028_CONF_ALS_IR_MODE_ALS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t\t ISL29028_CONF_ALS_RANGE_MASK,\n\t\t\t\t\t ISL29028_CONF_ALS_RANGE_HIGH_LUX);\n\t\tbreak;\n\tcase ISL29028_MODE_IR:\n\t\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t\t ISL29028_CONF_ALS_IR_MODE_MASK,\n\t\t\t\t\t ISL29028_CONF_ALS_IR_MODE_IR);\n\t\tbreak;\n\tcase ISL29028_MODE_NONE:\n\t\treturn regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t\t  ISL29028_CONF_ALS_EN_MASK,\n\t\t\t\t\t  ISL29028_CONF_ALS_DIS);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\n\t\t\t\t ISL29028_CONF_ALS_EN_MASK,\n\t\t\t\t ISL29028_CONF_ALS_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(ISL29028_CONV_TIME_MS);\n\n\tchip->als_ir_mode = mode;\n\n\treturn 0;\n}\n\nstatic int isl29028_read_als_ir(struct isl29028_chip *chip, int *als_ir)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tunsigned int lsb;\n\tunsigned int msb;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_L, &lsb);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"%s(): Error %d reading register ALSIR_L\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_U, &msb);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"%s(): Error %d reading register ALSIR_U\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t*als_ir = ((msb & 0xF) << 8) | (lsb & 0xFF);\n\n\treturn 0;\n}\n\nstatic int isl29028_read_proxim(struct isl29028_chip *chip, int *prox)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tunsigned int data;\n\tint ret;\n\n\tif (!chip->enable_prox) {\n\t\tret = isl29028_enable_proximity(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->enable_prox = true;\n\t}\n\n\tret = regmap_read(chip->regmap, ISL29028_REG_PROX_DATA, &data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): Error %d reading register PROX_DATA\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t*prox = data;\n\n\treturn 0;\n}\n\nstatic int isl29028_als_get(struct isl29028_chip *chip, int *als_data)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret;\n\tint als_ir_data;\n\n\tret = isl29028_set_als_ir_mode(chip, ISL29028_MODE_ALS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): Error %d enabling ALS mode\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = isl29028_read_als_ir(chip, &als_ir_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (chip->lux_scale == 125)\n\t\tals_ir_data = (als_ir_data * 31) / 1000;\n\telse\n\t\tals_ir_data = (als_ir_data * 49) / 100;\n\n\t*als_data = als_ir_data;\n\n\treturn 0;\n}\n\nstatic int isl29028_ir_get(struct isl29028_chip *chip, int *ir_data)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret;\n\n\tret = isl29028_set_als_ir_mode(chip, ISL29028_MODE_IR);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): Error %d enabling IR mode\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn isl29028_read_als_ir(chip, ir_data);\n}\n\nstatic int isl29028_set_pm_runtime_busy(struct isl29028_chip *chip, bool on)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int isl29028_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct isl29028_chip *chip = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret;\n\n\tret = isl29028_set_pm_runtime_busy(chip, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = -EINVAL;\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (mask != IIO_CHAN_INFO_SAMP_FREQ) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s(): proximity: Mask value 0x%08lx is not supported\\n\",\n\t\t\t\t__func__, mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val < 1 || val > 100) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s(): proximity: Sampling frequency %d is not in the range [1:100]\\n\",\n\t\t\t\t__func__, val);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = isl29028_set_proxim_sampling(chip, val, val2);\n\t\tbreak;\n\tcase IIO_LIGHT:\n\t\tif (mask != IIO_CHAN_INFO_SCALE) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s(): light: Mask value 0x%08lx is not supported\\n\",\n\t\t\t\t__func__, mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val != 125 && val != 2000) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s(): light: Lux scale %d is not in the set {125, 2000}\\n\",\n\t\t\t\t__func__, val);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = isl29028_set_als_scale(chip, val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s(): Unsupported channel type %x\\n\",\n\t\t\t__func__, chan->type);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&chip->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = isl29028_set_pm_runtime_busy(chip, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int isl29028_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct isl29028_chip *chip = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret, pm_ret;\n\n\tret = isl29028_set_pm_runtime_busy(chip, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = -EINVAL;\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = isl29028_als_get(chip, val);\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tret = isl29028_ir_get(chip, val);\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = isl29028_read_proxim(chip, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->type != IIO_PROXIMITY)\n\t\t\tbreak;\n\n\t\t*val = chip->prox_sampling_int;\n\t\t*val2 = chip->prox_sampling_frac;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_LIGHT)\n\t\t\tbreak;\n\t\t*val = chip->lux_scale;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s(): mask value 0x%08lx is not supported\\n\",\n\t\t\t__func__, mask);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&chip->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_ret = isl29028_set_pm_runtime_busy(chip, false);\n\tif (pm_ret < 0)\n\t\treturn pm_ret;\n\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR(in_proximity_sampling_frequency_available,\n\t\t\t\t\"1.25 2.5 5 10 13.3 20 80 100\");\nstatic IIO_CONST_ATTR(in_illuminance_scale_available, \"125 2000\");\n\n#define ISL29028_CONST_ATTR(name) (&iio_const_attr_##name.dev_attr.attr)\nstatic struct attribute *isl29028_attributes[] = {\n\tISL29028_CONST_ATTR(in_proximity_sampling_frequency_available),\n\tISL29028_CONST_ATTR(in_illuminance_scale_available),\n\tNULL,\n};\n\nstatic const struct attribute_group isl29108_group = {\n\t.attrs = isl29028_attributes,\n};\n\nstatic const struct iio_chan_spec isl29028_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t}, {\n\t\t.type = IIO_INTENSITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t}\n};\n\nstatic const struct iio_info isl29028_info = {\n\t.attrs = &isl29108_group,\n\t.read_raw = isl29028_read_raw,\n\t.write_raw = isl29028_write_raw,\n};\n\nstatic int isl29028_clear_configure_reg(struct isl29028_chip *chip)\n{\n\tstruct device *dev = regmap_get_device(chip->regmap);\n\tint ret;\n\n\tret = regmap_write(chip->regmap, ISL29028_REG_CONFIGURE, 0x0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"%s(): Error %d clearing the CONFIGURE register\\n\",\n\t\t\t__func__, ret);\n\n\tchip->als_ir_mode = ISL29028_MODE_NONE;\n\tchip->enable_prox = false;\n\n\treturn ret;\n}\n\nstatic bool isl29028_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ISL29028_REG_INTERRUPT:\n\tcase ISL29028_REG_PROX_DATA:\n\tcase ISL29028_REG_ALSIR_L:\n\tcase ISL29028_REG_ALSIR_U:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config isl29028_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = isl29028_is_volatile_reg,\n\t.max_register = ISL29028_NUM_REGS - 1,\n\t.num_reg_defaults_raw = ISL29028_NUM_REGS,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int isl29028_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct isl29028_chip *chip;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tmutex_init(&chip->lock);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &isl29028_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"%s: Error %d initializing regmap\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tchip->enable_prox  = false;\n\tchip->prox_sampling_int = 20;\n\tchip->prox_sampling_frac = 0;\n\tchip->lux_scale = 2000;\n\n\tret = regmap_write(chip->regmap, ISL29028_REG_TEST1_MODE, 0x0);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): Error %d writing to TEST1_MODE register\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(chip->regmap, ISL29028_REG_TEST2_MODE, 0x0);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): Error %d writing to TEST2_MODE register\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = isl29028_clear_configure_reg(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->info = &isl29028_info;\n\tindio_dev->channels = isl29028_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(isl29028_channels);\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t ISL29028_POWER_OFF_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): iio registration failed with error %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void isl29028_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct isl29028_chip *chip = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tisl29028_clear_configure_reg(chip);\n}\n\nstatic int isl29028_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct isl29028_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = isl29028_clear_configure_reg(chip);\n\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int isl29028_resume(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(isl29028_pm_ops, isl29028_suspend,\n\t\t\t\t isl29028_resume, NULL);\n\nstatic const struct i2c_device_id isl29028_id[] = {\n\t{\"isl29028\", 0},\n\t{\"isl29030\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, isl29028_id);\n\nstatic const struct of_device_id isl29028_of_match[] = {\n\t{ .compatible = \"isl,isl29028\", },  \n\t{ .compatible = \"isil,isl29028\", },\n\t{ .compatible = \"isil,isl29030\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, isl29028_of_match);\n\nstatic struct i2c_driver isl29028_driver = {\n\t.driver  = {\n\t\t.name = \"isl29028\",\n\t\t.pm = pm_ptr(&isl29028_pm_ops),\n\t\t.of_match_table = isl29028_of_match,\n\t},\n\t.probe = isl29028_probe,\n\t.remove  = isl29028_remove,\n\t.id_table = isl29028_id,\n};\n\nmodule_i2c_driver(isl29028_driver);\n\nMODULE_DESCRIPTION(\"ISL29028 Ambient Light and Proximity Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}