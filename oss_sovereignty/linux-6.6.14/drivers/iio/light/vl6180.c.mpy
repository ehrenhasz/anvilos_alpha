{
  "module_name": "vl6180.c",
  "hash_id": "c90e5f500d69d2e98111343254f5b74c19e5814424061e45f01555af2d9d8ef2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/vl6180.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/util_macros.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define VL6180_DRV_NAME \"vl6180\"\n\n \n#define VL6180_MODEL_ID\t0x000\n#define VL6180_MODEL_ID_VAL 0xb4\n\n \n#define VL6180_INTR_CONFIG 0x014\n#define VL6180_INTR_CLEAR 0x015\n#define VL6180_OUT_OF_RESET 0x016\n#define VL6180_HOLD 0x017\n#define VL6180_RANGE_START 0x018\n#define VL6180_ALS_START 0x038\n#define VL6180_ALS_GAIN 0x03f\n#define VL6180_ALS_IT 0x040\n\n \n#define VL6180_RANGE_STATUS 0x04d\n#define VL6180_ALS_STATUS 0x04e\n#define VL6180_INTR_STATUS 0x04f\n\n \n#define VL6180_ALS_VALUE 0x050\n#define VL6180_RANGE_VALUE 0x062\n#define VL6180_RANGE_RATE 0x066\n\n \n#define VL6180_MODE_CONT BIT(1)  \n#define VL6180_STARTSTOP BIT(0)  \n\n \n#define VL6180_ALS_READY BIT(5)\n#define VL6180_RANGE_READY BIT(2)\n\n \n#define VL6180_CLEAR_ERROR BIT(2)\n#define VL6180_CLEAR_ALS BIT(1)\n#define VL6180_CLEAR_RANGE BIT(0)\n\n \n#define VL6180_HOLD_ON BIT(0)\n\n \n#define VL6180_ALS_IT_100 0x63  \n\n \n#define VL6180_ALS_GAIN_1 0x46\n#define VL6180_ALS_GAIN_1_25 0x45\n#define VL6180_ALS_GAIN_1_67 0x44\n#define VL6180_ALS_GAIN_2_5 0x43\n#define VL6180_ALS_GAIN_5 0x42\n#define VL6180_ALS_GAIN_10 0x41\n#define VL6180_ALS_GAIN_20 0x40\n#define VL6180_ALS_GAIN_40 0x47\n\nstruct vl6180_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tunsigned int als_gain_milli;\n\tunsigned int als_it_ms;\n};\n\nenum { VL6180_ALS, VL6180_RANGE, VL6180_PROX };\n\n \nstruct vl6180_chan_regs {\n\tu8 drdy_mask;\n\tu16 start_reg, value_reg;\n\tbool word;\n};\n\nstatic const struct vl6180_chan_regs vl6180_chan_regs_table[] = {\n\t[VL6180_ALS] = {\n\t\t.drdy_mask = VL6180_ALS_READY,\n\t\t.start_reg = VL6180_ALS_START,\n\t\t.value_reg = VL6180_ALS_VALUE,\n\t\t.word = true,\n\t},\n\t[VL6180_RANGE] = {\n\t\t.drdy_mask = VL6180_RANGE_READY,\n\t\t.start_reg = VL6180_RANGE_START,\n\t\t.value_reg = VL6180_RANGE_VALUE,\n\t\t.word = false,\n\t},\n\t[VL6180_PROX] = {\n\t\t.drdy_mask = VL6180_RANGE_READY,\n\t\t.start_reg = VL6180_RANGE_START,\n\t\t.value_reg = VL6180_RANGE_RATE,\n\t\t.word = true,\n\t},\n};\n\nstatic int vl6180_read(struct i2c_client *client, u16 cmd, void *databuf,\n\t\t       u8 len)\n{\n\t__be16 cmdbuf = cpu_to_be16(cmd);\n\tstruct i2c_msg msgs[2] = {\n\t\t{ .addr = client->addr, .len = sizeof(cmdbuf), .buf = (u8 *) &cmdbuf },\n\t\t{ .addr = client->addr, .len = len, .buf = databuf,\n\t\t  .flags = I2C_M_RD } };\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed reading register 0x%04x\\n\", cmd);\n\n\treturn ret;\n}\n\nstatic int vl6180_read_byte(struct i2c_client *client, u16 cmd)\n{\n\tu8 data;\n\tint ret;\n\n\tret = vl6180_read(client, cmd, &data, sizeof(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn data;\n}\n\nstatic int vl6180_read_word(struct i2c_client *client, u16 cmd)\n{\n\t__be16 data;\n\tint ret;\n\n\tret = vl6180_read(client, cmd, &data, sizeof(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(data);\n}\n\nstatic int vl6180_write_byte(struct i2c_client *client, u16 cmd, u8 val)\n{\n\tu8 buf[3];\n\tstruct i2c_msg msgs[1] = {\n\t\t{ .addr = client->addr, .len = sizeof(buf), .buf = (u8 *) &buf } };\n\tint ret;\n\n\tbuf[0] = cmd >> 8;\n\tbuf[1] = cmd & 0xff;\n\tbuf[2] = val;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writing register 0x%04x\\n\", cmd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vl6180_write_word(struct i2c_client *client, u16 cmd, u16 val)\n{\n\t__be16 buf[2];\n\tstruct i2c_msg msgs[1] = {\n\t\t{ .addr = client->addr, .len = sizeof(buf), .buf = (u8 *) &buf } };\n\tint ret;\n\n\tbuf[0] = cpu_to_be16(cmd);\n\tbuf[1] = cpu_to_be16(val);\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writing register 0x%04x\\n\", cmd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vl6180_measure(struct vl6180_data *data, int addr)\n{\n\tstruct i2c_client *client = data->client;\n\tint tries = 20, ret;\n\tu16 value;\n\n\tmutex_lock(&data->lock);\n\t \n\tret = vl6180_write_byte(client,\n\t\tvl6180_chan_regs_table[addr].start_reg, VL6180_STARTSTOP);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\twhile (tries--) {\n\t\tret = vl6180_read_byte(client, VL6180_INTR_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\tif (ret & vl6180_chan_regs_table[addr].drdy_mask)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tret = vl6180_chan_regs_table[addr].word ?\n\t\tvl6180_read_word(client, vl6180_chan_regs_table[addr].value_reg) :\n\t\tvl6180_read_byte(client, vl6180_chan_regs_table[addr].value_reg);\n\tif (ret < 0)\n\t\tgoto fail;\n\tvalue = ret;\n\n\t \n\tret = vl6180_write_byte(client, VL6180_INTR_CLEAR,\n\t\tVL6180_CLEAR_ERROR | VL6180_CLEAR_ALS | VL6180_CLEAR_RANGE);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = value;\n\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_chan_spec vl6180_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.address = VL6180_ALS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN),\n\t}, {\n\t\t.type = IIO_DISTANCE,\n\t\t.address = VL6180_RANGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t}, {\n\t\t.type = IIO_PROXIMITY,\n\t\t.address = VL6180_PROX,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}\n};\n\n \nstatic const int vl6180_als_gain_tab[8] = {\n\t1000, 1250, 1670, 2500, 5000, 10000, 20000, 40000\n};\nstatic const u8 vl6180_als_gain_tab_bits[8] = {\n\tVL6180_ALS_GAIN_1,    VL6180_ALS_GAIN_1_25,\n\tVL6180_ALS_GAIN_1_67, VL6180_ALS_GAIN_2_5,\n\tVL6180_ALS_GAIN_5,    VL6180_ALS_GAIN_10,\n\tVL6180_ALS_GAIN_20,   VL6180_ALS_GAIN_40\n};\n\nstatic int vl6180_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct vl6180_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = vl6180_measure(data, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = data->als_it_ms;\n\t\t*val2 = 1000;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\t \n\t\t\t*val = 32000;  \n\t\t\t*val2 = data->als_gain_milli * data->als_it_ms;\n\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase IIO_DISTANCE:\n\t\t\t*val = 0;  \n\t\t\t*val2 = 1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t*val = data->als_gain_milli;\n\t\t*val2 = 1000;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR(als_gain_available, \"1 1.25 1.67 2.5 5 10 20 40\");\n\nstatic struct attribute *vl6180_attributes[] = {\n\t&iio_const_attr_als_gain_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group vl6180_attribute_group = {\n\t.attrs = vl6180_attributes,\n};\n\n \nstatic int vl6180_hold(struct vl6180_data *data, bool hold)\n{\n\treturn vl6180_write_byte(data->client, VL6180_HOLD,\n\t\thold ? VL6180_HOLD_ON : 0);\n}\n\nstatic int vl6180_set_als_gain(struct vl6180_data *data, int val, int val2)\n{\n\tint i, ret, gain;\n\n\tif (val < 1 || val > 40)\n\t\treturn -EINVAL;\n\n\tgain = (val * 1000000 + val2) / 1000;\n\tif (gain < 1 || gain > 40000)\n\t\treturn -EINVAL;\n\n\ti = find_closest(gain, vl6180_als_gain_tab,\n\t\t\t ARRAY_SIZE(vl6180_als_gain_tab));\n\n\tmutex_lock(&data->lock);\n\tret = vl6180_hold(data, true);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = vl6180_write_byte(data->client, VL6180_ALS_GAIN,\n\t\t\t\tvl6180_als_gain_tab_bits[i]);\n\n\tif (ret >= 0)\n\t\tdata->als_gain_milli = vl6180_als_gain_tab[i];\n\nfail:\n\tvl6180_hold(data, false);\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int vl6180_set_it(struct vl6180_data *data, int val, int val2)\n{\n\tint ret, it_ms;\n\n\tit_ms = DIV_ROUND_CLOSEST(val2, 1000);  \n\tif (val != 0 || it_ms < 1 || it_ms > 512)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\tret = vl6180_hold(data, true);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = vl6180_write_word(data->client, VL6180_ALS_IT, it_ms - 1);\n\n\tif (ret >= 0)\n\t\tdata->als_it_ms = it_ms;\n\nfail:\n\tvl6180_hold(data, false);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int vl6180_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct vl6180_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn vl6180_set_it(data, val, val2);\n\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tif (chan->type != IIO_LIGHT)\n\t\t\treturn -EINVAL;\n\n\t\treturn vl6180_set_als_gain(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info vl6180_info = {\n\t.read_raw = vl6180_read_raw,\n\t.write_raw = vl6180_write_raw,\n\t.attrs = &vl6180_attribute_group,\n};\n\nstatic int vl6180_init(struct vl6180_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = vl6180_read_byte(client, VL6180_MODEL_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != VL6180_MODEL_ID_VAL) {\n\t\tdev_err(&client->dev, \"invalid model ID %02x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tret = vl6180_hold(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vl6180_read_byte(client, VL6180_OUT_OF_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret != 0x01)\n\t\tdev_info(&client->dev, \"device is not fresh out of reset\\n\");\n\n\t \n\tret = vl6180_write_byte(client, VL6180_INTR_CONFIG,\n\t\t\t\tVL6180_ALS_READY | VL6180_RANGE_READY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->als_it_ms = 100;\n\tret = vl6180_write_word(client, VL6180_ALS_IT, VL6180_ALS_IT_100);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->als_gain_milli = 1000;\n\tret = vl6180_write_byte(client, VL6180_ALS_GAIN, VL6180_ALS_GAIN_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vl6180_write_byte(client, VL6180_OUT_OF_RESET, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn vl6180_hold(data, false);\n}\n\nstatic int vl6180_probe(struct i2c_client *client)\n{\n\tstruct vl6180_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &vl6180_info;\n\tindio_dev->channels = vl6180_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vl6180_channels);\n\tindio_dev->name = VL6180_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = vl6180_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id vl6180_of_match[] = {\n\t{ .compatible = \"st,vl6180\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, vl6180_of_match);\n\nstatic const struct i2c_device_id vl6180_id[] = {\n\t{ \"vl6180\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vl6180_id);\n\nstatic struct i2c_driver vl6180_driver = {\n\t.driver = {\n\t\t.name   = VL6180_DRV_NAME,\n\t\t.of_match_table = vl6180_of_match,\n\t},\n\t.probe = vl6180_probe,\n\t.id_table = vl6180_id,\n};\n\nmodule_i2c_driver(vl6180_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald-Stadler <pmeerw@pmeerw.net>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannanece23@gmail.com>\");\nMODULE_DESCRIPTION(\"STMicro VL6180 ALS, range and proximity sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}