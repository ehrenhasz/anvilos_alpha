{
  "module_name": "tcs3414.c",
  "hash_id": "78e4b0dead27a6498907ec6bddb38a671823b6caff743e55268cce68496b5214",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tcs3414.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define TCS3414_DRV_NAME \"tcs3414\"\n\n#define TCS3414_COMMAND BIT(7)\n#define TCS3414_COMMAND_WORD (TCS3414_COMMAND | BIT(5))\n\n#define TCS3414_CONTROL (TCS3414_COMMAND | 0x00)\n#define TCS3414_TIMING (TCS3414_COMMAND | 0x01)\n#define TCS3414_ID (TCS3414_COMMAND | 0x04)\n#define TCS3414_GAIN (TCS3414_COMMAND | 0x07)\n#define TCS3414_DATA_GREEN (TCS3414_COMMAND_WORD | 0x10)\n#define TCS3414_DATA_RED (TCS3414_COMMAND_WORD | 0x12)\n#define TCS3414_DATA_BLUE (TCS3414_COMMAND_WORD | 0x14)\n#define TCS3414_DATA_CLEAR (TCS3414_COMMAND_WORD | 0x16)\n\n#define TCS3414_CONTROL_ADC_VALID BIT(4)\n#define TCS3414_CONTROL_ADC_EN BIT(1)\n#define TCS3414_CONTROL_POWER BIT(0)\n\n#define TCS3414_INTEG_MASK GENMASK(1, 0)\n#define TCS3414_INTEG_12MS 0x0\n#define TCS3414_INTEG_100MS 0x1\n#define TCS3414_INTEG_400MS 0x2\n\n#define TCS3414_GAIN_MASK GENMASK(5, 4)\n#define TCS3414_GAIN_SHIFT 4\n\nstruct tcs3414_data {\n\tstruct i2c_client *client;\n\tu8 control;\n\tu8 gain;\n\tu8 timing;\n\t \n\tstruct {\n\t\tu16 chans[4];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\n#define TCS3414_CHANNEL(_color, _si, _addr) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = IIO_MOD_LIGHT_##_color, \\\n\t.address = _addr, \\\n\t.scan_index = _si, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\n \nstatic const int tcs3414_scales[][2] = {\n\t{1, 0}, {0, 250000}, {0, 62500}, {0, 15625}\n};\n\n \nstatic const int tcs3414_times[] = { 12, 100, 400 };\n\nstatic const struct iio_chan_spec tcs3414_channels[] = {\n\tTCS3414_CHANNEL(GREEN, 0, TCS3414_DATA_GREEN),\n\tTCS3414_CHANNEL(RED, 1, TCS3414_DATA_RED),\n\tTCS3414_CHANNEL(BLUE, 2, TCS3414_DATA_BLUE),\n\tTCS3414_CHANNEL(CLEAR, 3, TCS3414_DATA_CLEAR),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int tcs3414_req_data(struct tcs3414_data *data)\n{\n\tint tries = 25;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control | TCS3414_CONTROL_ADC_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (tries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, TCS3414_CONTROL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & TCS3414_CONTROL_ADC_VALID)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcs3414_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct tcs3414_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = tcs3414_req_data(data);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\ti = (data->gain & TCS3414_GAIN_MASK) >> TCS3414_GAIN_SHIFT;\n\t\t*val = tcs3414_scales[i][0];\n\t\t*val2 = tcs3414_scales[i][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = tcs3414_times[data->timing & TCS3414_INTEG_MASK] * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int tcs3414_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct tcs3414_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(tcs3414_scales); i++) {\n\t\t\tif (val == tcs3414_scales[i][0] &&\n\t\t\t\tval2 == tcs3414_scales[i][1]) {\n\t\t\t\tdata->gain &= ~TCS3414_GAIN_MASK;\n\t\t\t\tdata->gain |= i << TCS3414_GAIN_SHIFT;\n\t\t\t\treturn i2c_smbus_write_byte_data(\n\t\t\t\t\tdata->client, TCS3414_GAIN,\n\t\t\t\t\tdata->gain);\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(tcs3414_times); i++) {\n\t\t\tif (val2 == tcs3414_times[i] * 1000) {\n\t\t\t\tdata->timing &= ~TCS3414_INTEG_MASK;\n\t\t\t\tdata->timing |= i;\n\t\t\t\treturn i2c_smbus_write_byte_data(\n\t\t\t\t\tdata->client, TCS3414_TIMING,\n\t\t\t\t\tdata->timing);\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t tcs3414_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct tcs3414_data *data = iio_priv(indio_dev);\n\tint i, j = 0;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tint ret = i2c_smbus_read_word_data(data->client,\n\t\t\tTCS3414_DATA_GREEN + 2*i);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tdata->scan.chans[j++] = ret;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic IIO_CONST_ATTR(scale_available, \"1 0.25 0.0625 0.015625\");\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.012 0.1 0.4\");\n\nstatic struct attribute *tcs3414_attributes[] = {\n\t&iio_const_attr_scale_available.dev_attr.attr,\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tcs3414_attribute_group = {\n\t.attrs = tcs3414_attributes,\n};\n\nstatic const struct iio_info tcs3414_info = {\n\t.read_raw = tcs3414_read_raw,\n\t.write_raw = tcs3414_write_raw,\n\t.attrs = &tcs3414_attribute_group,\n};\n\nstatic int tcs3414_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct tcs3414_data *data = iio_priv(indio_dev);\n\n\tdata->control |= TCS3414_CONTROL_ADC_EN;\n\treturn i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control);\n}\n\nstatic int tcs3414_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct tcs3414_data *data = iio_priv(indio_dev);\n\n\tdata->control &= ~TCS3414_CONTROL_ADC_EN;\n\treturn i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control);\n}\n\nstatic const struct iio_buffer_setup_ops tcs3414_buffer_setup_ops = {\n\t.postenable = tcs3414_buffer_postenable,\n\t.predisable = tcs3414_buffer_predisable,\n};\n\nstatic int tcs3414_powerdown(struct tcs3414_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control & ~(TCS3414_CONTROL_POWER |\n\t\tTCS3414_CONTROL_ADC_EN));\n}\n\nstatic void tcs3414_powerdown_cleanup(void *data)\n{\n\ttcs3414_powerdown(data);\n}\n\nstatic int tcs3414_probe(struct i2c_client *client)\n{\n\tstruct tcs3414_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &tcs3414_info;\n\tindio_dev->name = TCS3414_DRV_NAME;\n\tindio_dev->channels = tcs3414_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tcs3414_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3414_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & 0xf0) {\n\tcase 0x00:\n\t\tdev_info(&client->dev, \"TCS3404 found\\n\");\n\t\tbreak;\n\tcase 0x10:\n\t\tdev_info(&client->dev, \"TCS3413/14/15/16 found\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tdata->control = TCS3414_CONTROL_POWER;\n\tret = i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, tcs3414_powerdown_cleanup,\n\t\t\t\t       data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->timing = TCS3414_INTEG_12MS;  \n\tret = i2c_smbus_write_byte_data(data->client, TCS3414_TIMING,\n\t\tdata->timing);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, TCS3414_GAIN);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->gain = ret;\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev, NULL,\n\t\ttcs3414_trigger_handler, &tcs3414_buffer_setup_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int tcs3414_suspend(struct device *dev)\n{\n\tstruct tcs3414_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\treturn tcs3414_powerdown(data);\n}\n\nstatic int tcs3414_resume(struct device *dev)\n{\n\tstruct tcs3414_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\treturn i2c_smbus_write_byte_data(data->client, TCS3414_CONTROL,\n\t\tdata->control);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tcs3414_pm_ops, tcs3414_suspend,\n\t\t\t\ttcs3414_resume);\n\nstatic const struct i2c_device_id tcs3414_id[] = {\n\t{ \"tcs3414\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tcs3414_id);\n\nstatic struct i2c_driver tcs3414_driver = {\n\t.driver = {\n\t\t.name\t= TCS3414_DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&tcs3414_pm_ops),\n\t},\n\t.probe\t\t= tcs3414_probe,\n\t.id_table\t= tcs3414_id,\n};\nmodule_i2c_driver(tcs3414_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"TCS3414 digital color sensors driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}