{
  "module_name": "apds9960.c",
  "hash_id": "bd5bc26a7e326541bc0b165dc3562ed7ef8405e5b11bcf0cd028885f308920dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/apds9960.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n\n#define APDS9960_REGMAP_NAME\t\"apds9960_regmap\"\n#define APDS9960_DRV_NAME\t\"apds9960\"\n\n#define APDS9960_REG_RAM_START\t0x00\n#define APDS9960_REG_RAM_END\t0x7f\n\n#define APDS9960_REG_ENABLE\t0x80\n#define APDS9960_REG_ATIME\t0x81\n#define APDS9960_REG_WTIME\t0x83\n\n#define APDS9960_REG_AILTL\t0x84\n#define APDS9960_REG_AILTH\t0x85\n#define APDS9960_REG_AIHTL\t0x86\n#define APDS9960_REG_AIHTH\t0x87\n\n#define APDS9960_REG_PILT\t0x89\n#define APDS9960_REG_PIHT\t0x8b\n#define APDS9960_REG_PERS\t0x8c\n\n#define APDS9960_REG_CONFIG_1\t0x8d\n#define APDS9960_REG_PPULSE\t0x8e\n\n#define APDS9960_REG_CONTROL\t0x8f\n#define APDS9960_REG_CONTROL_AGAIN_MASK\t\t0x03\n#define APDS9960_REG_CONTROL_PGAIN_MASK\t\t0x0c\n#define APDS9960_REG_CONTROL_AGAIN_MASK_SHIFT\t0\n#define APDS9960_REG_CONTROL_PGAIN_MASK_SHIFT\t2\n\n#define APDS9960_REG_CONFIG_2\t0x90\n#define APDS9960_REG_ID\t\t0x92\n\n#define APDS9960_REG_STATUS\t0x93\n#define APDS9960_REG_STATUS_PS_INT\tBIT(5)\n#define APDS9960_REG_STATUS_ALS_INT\tBIT(4)\n#define APDS9960_REG_STATUS_GINT\tBIT(2)\n\n#define APDS9960_REG_PDATA\t0x9c\n#define APDS9960_REG_POFFSET_UR\t0x9d\n#define APDS9960_REG_POFFSET_DL 0x9e\n#define APDS9960_REG_CONFIG_3\t0x9f\n\n#define APDS9960_REG_GPENTH\t0xa0\n#define APDS9960_REG_GEXTH\t0xa1\n\n#define APDS9960_REG_GCONF_1\t0xa2\n#define APDS9960_REG_GCONF_1_GFIFO_THRES_MASK\t\t0xc0\n#define APDS9960_REG_GCONF_1_GFIFO_THRES_MASK_SHIFT\t6\n\n#define APDS9960_REG_GCONF_2\t0xa3\n#define APDS9960_REG_GCONF_2_GGAIN_MASK\t\t\t0x60\n#define APDS9960_REG_GCONF_2_GGAIN_MASK_SHIFT\t\t5\n\n#define APDS9960_REG_GOFFSET_U\t0xa4\n#define APDS9960_REG_GOFFSET_D\t0xa5\n#define APDS9960_REG_GPULSE\t0xa6\n#define APDS9960_REG_GOFFSET_L\t0xa7\n#define APDS9960_REG_GOFFSET_R\t0xa9\n#define APDS9960_REG_GCONF_3\t0xaa\n\n#define APDS9960_REG_GCONF_4\t0xab\n#define APDS9960_REG_GFLVL\t0xae\n#define APDS9960_REG_GSTATUS\t0xaf\n\n#define APDS9960_REG_IFORCE\t0xe4\n#define APDS9960_REG_PICLEAR\t0xe5\n#define APDS9960_REG_CICLEAR\t0xe6\n#define APDS9960_REG_AICLEAR\t0xe7\n\n#define APDS9960_DEFAULT_PERS\t0x33\n#define APDS9960_DEFAULT_GPENTH\t0x50\n#define APDS9960_DEFAULT_GEXTH\t0x40\n\n#define APDS9960_MAX_PXS_THRES_VAL\t255\n#define APDS9960_MAX_ALS_THRES_VAL\t0xffff\n#define APDS9960_MAX_INT_TIME_IN_US\t1000000\n\nenum apds9960_als_channel_idx {\n\tIDX_ALS_CLEAR, IDX_ALS_RED, IDX_ALS_GREEN, IDX_ALS_BLUE,\n};\n\n#define APDS9960_REG_ALS_BASE\t0x94\n#define APDS9960_REG_ALS_CHANNEL(_colour) \\\n\t(APDS9960_REG_ALS_BASE + (IDX_ALS_##_colour * 2))\n\nenum apds9960_gesture_channel_idx {\n\tIDX_DIR_UP, IDX_DIR_DOWN, IDX_DIR_LEFT, IDX_DIR_RIGHT,\n};\n\n#define APDS9960_REG_GFIFO_BASE\t0xfc\n#define APDS9960_REG_GFIFO_DIR(_dir) \\\n\t(APDS9960_REG_GFIFO_BASE + IDX_DIR_##_dir)\n\nstruct apds9960_data {\n\tstruct i2c_client *client;\n\tstruct iio_dev *indio_dev;\n\tstruct mutex lock;\n\n\t \n\tstruct regmap *regmap;\n\tstruct regmap_field *reg_int_als;\n\tstruct regmap_field *reg_int_ges;\n\tstruct regmap_field *reg_int_pxs;\n\n\tstruct regmap_field *reg_enable_als;\n\tstruct regmap_field *reg_enable_ges;\n\tstruct regmap_field *reg_enable_pxs;\n\n\t \n\tint als_int;\n\tint pxs_int;\n\tint gesture_mode_running;\n\n\t \n\tint als_gain;\n\tint pxs_gain;\n\n\t \n\tint als_adc_int_us;\n\n\t \n\tu8 buffer[4];  \n};\n\nstatic const struct reg_default apds9960_reg_defaults[] = {\n\t \n\t{ APDS9960_REG_ATIME, 0xff },\n};\n\nstatic const struct regmap_range apds9960_volatile_ranges[] = {\n\tregmap_reg_range(APDS9960_REG_STATUS,\n\t\t\t\tAPDS9960_REG_PDATA),\n\tregmap_reg_range(APDS9960_REG_GFLVL,\n\t\t\t\tAPDS9960_REG_GSTATUS),\n\tregmap_reg_range(APDS9960_REG_GFIFO_DIR(UP),\n\t\t\t\tAPDS9960_REG_GFIFO_DIR(RIGHT)),\n\tregmap_reg_range(APDS9960_REG_IFORCE,\n\t\t\t\tAPDS9960_REG_AICLEAR),\n};\n\nstatic const struct regmap_access_table apds9960_volatile_table = {\n\t.yes_ranges\t= apds9960_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(apds9960_volatile_ranges),\n};\n\nstatic const struct regmap_range apds9960_precious_ranges[] = {\n\tregmap_reg_range(APDS9960_REG_RAM_START, APDS9960_REG_RAM_END),\n};\n\nstatic const struct regmap_access_table apds9960_precious_table = {\n\t.yes_ranges\t= apds9960_precious_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(apds9960_precious_ranges),\n};\n\nstatic const struct regmap_range apds9960_readable_ranges[] = {\n\tregmap_reg_range(APDS9960_REG_ENABLE,\n\t\t\t\tAPDS9960_REG_GSTATUS),\n\tregmap_reg_range(APDS9960_REG_GFIFO_DIR(UP),\n\t\t\t\tAPDS9960_REG_GFIFO_DIR(RIGHT)),\n};\n\nstatic const struct regmap_access_table apds9960_readable_table = {\n\t.yes_ranges\t= apds9960_readable_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(apds9960_readable_ranges),\n};\n\nstatic const struct regmap_range apds9960_writeable_ranges[] = {\n\tregmap_reg_range(APDS9960_REG_ENABLE, APDS9960_REG_CONFIG_2),\n\tregmap_reg_range(APDS9960_REG_POFFSET_UR, APDS9960_REG_GCONF_4),\n\tregmap_reg_range(APDS9960_REG_IFORCE, APDS9960_REG_AICLEAR),\n};\n\nstatic const struct regmap_access_table apds9960_writeable_table = {\n\t.yes_ranges\t= apds9960_writeable_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(apds9960_writeable_ranges),\n};\n\nstatic const struct regmap_config apds9960_regmap_config = {\n\t.name = APDS9960_REGMAP_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\n\t.volatile_table = &apds9960_volatile_table,\n\t.precious_table = &apds9960_precious_table,\n\t.rd_table = &apds9960_readable_table,\n\t.wr_table = &apds9960_writeable_table,\n\n\t.reg_defaults = apds9960_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(apds9960_reg_defaults),\n\t.max_register = APDS9960_REG_GFIFO_DIR(RIGHT),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct iio_event_spec apds9960_pxs_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_event_spec apds9960_als_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n#define APDS9960_GESTURE_CHANNEL(_dir, _si) { \\\n\t.type = IIO_PROXIMITY, \\\n\t.channel = _si + 1, \\\n\t.scan_index = _si, \\\n\t.indexed = 1, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 8, \\\n\t\t.storagebits = 8, \\\n\t}, \\\n}\n\n#define APDS9960_INTENSITY_CHANNEL(_colour) { \\\n\t.type = IIO_INTENSITY, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = IIO_MOD_LIGHT_##_colour, \\\n\t.address = APDS9960_REG_ALS_CHANNEL(_colour), \\\n\t.modified = 1, \\\n\t.scan_index = -1, \\\n}\n\nstatic const unsigned long apds9960_scan_masks[] = {0xf, 0};\n\nstatic const struct iio_chan_spec apds9960_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.address = APDS9960_REG_PDATA,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.channel = 0,\n\t\t.indexed = 0,\n\t\t.scan_index = -1,\n\n\t\t.event_spec = apds9960_pxs_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(apds9960_pxs_event_spec),\n\t},\n\t \n\tAPDS9960_GESTURE_CHANNEL(UP, 0),\n\tAPDS9960_GESTURE_CHANNEL(DOWN, 1),\n\tAPDS9960_GESTURE_CHANNEL(LEFT, 2),\n\tAPDS9960_GESTURE_CHANNEL(RIGHT, 3),\n\t \n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.channel2 = IIO_MOD_LIGHT_CLEAR,\n\t\t.address = APDS9960_REG_ALS_CHANNEL(CLEAR),\n\t\t.modified = 1,\n\t\t.scan_index = -1,\n\n\t\t.event_spec = apds9960_als_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(apds9960_als_event_spec),\n\t},\n\t \n\tAPDS9960_INTENSITY_CHANNEL(RED),\n\tAPDS9960_INTENSITY_CHANNEL(GREEN),\n\tAPDS9960_INTENSITY_CHANNEL(BLUE),\n};\n\n \nstatic const int apds9960_int_time[][2] = {\n\t{ 28000, 246},\n\t{100000, 219},\n\t{200000, 182},\n\t{700000,   0}\n};\n\n \nstatic const int apds9960_pxs_gain_map[] = {1, 2, 4, 8};\nstatic const int apds9960_als_gain_map[] = {1, 4, 16, 64};\n\nstatic IIO_CONST_ATTR(proximity_scale_available, \"1 2 4 8\");\nstatic IIO_CONST_ATTR(intensity_scale_available, \"1 4 16 64\");\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(\"0.028 0.1 0.2 0.7\");\n\nstatic struct attribute *apds9960_attributes[] = {\n\t&iio_const_attr_proximity_scale_available.dev_attr.attr,\n\t&iio_const_attr_intensity_scale_available.dev_attr.attr,\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group apds9960_attribute_group = {\n\t.attrs = apds9960_attributes,\n};\n\nstatic const struct reg_field apds9960_reg_field_int_als =\n\t\t\t\tREG_FIELD(APDS9960_REG_ENABLE, 4, 4);\n\nstatic const struct reg_field apds9960_reg_field_int_ges =\n\t\t\t\tREG_FIELD(APDS9960_REG_GCONF_4, 1, 1);\n\nstatic const struct reg_field apds9960_reg_field_int_pxs =\n\t\t\t\tREG_FIELD(APDS9960_REG_ENABLE, 5, 5);\n\nstatic const struct reg_field apds9960_reg_field_enable_als =\n\t\t\t\tREG_FIELD(APDS9960_REG_ENABLE, 1, 1);\n\nstatic const struct reg_field apds9960_reg_field_enable_ges =\n\t\t\t\tREG_FIELD(APDS9960_REG_ENABLE, 6, 6);\n\nstatic const struct reg_field apds9960_reg_field_enable_pxs =\n\t\t\t\tREG_FIELD(APDS9960_REG_ENABLE, 2, 2);\n\nstatic int apds9960_set_it_time(struct apds9960_data *data, int val2)\n{\n\tint ret = -EINVAL;\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(apds9960_int_time); idx++) {\n\t\tif (apds9960_int_time[idx][0] == val2) {\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = regmap_write(data->regmap, APDS9960_REG_ATIME,\n\t\t\t\t\t\t apds9960_int_time[idx][1]);\n\t\t\tif (!ret)\n\t\t\t\tdata->als_adc_int_us = val2;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int apds9960_set_pxs_gain(struct apds9960_data *data, int val)\n{\n\tint ret = -EINVAL;\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(apds9960_pxs_gain_map); idx++) {\n\t\tif (apds9960_pxs_gain_map[idx] == val) {\n\t\t\t \n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\tAPDS9960_REG_CONTROL,\n\t\t\t\tAPDS9960_REG_CONTROL_PGAIN_MASK,\n\t\t\t\tidx << APDS9960_REG_CONTROL_PGAIN_MASK_SHIFT);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\tAPDS9960_REG_GCONF_2,\n\t\t\t\tAPDS9960_REG_GCONF_2_GGAIN_MASK,\n\t\t\t\tidx << APDS9960_REG_GCONF_2_GGAIN_MASK_SHIFT);\n\t\t\tif (!ret)\n\t\t\t\tdata->pxs_gain = idx;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int apds9960_set_als_gain(struct apds9960_data *data, int val)\n{\n\tint ret = -EINVAL;\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(apds9960_als_gain_map); idx++) {\n\t\tif (apds9960_als_gain_map[idx] == val) {\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\tAPDS9960_REG_CONTROL,\n\t\t\t\t\tAPDS9960_REG_CONTROL_AGAIN_MASK, idx);\n\t\t\tif (!ret)\n\t\t\t\tdata->als_gain = idx;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int apds9960_set_power_state(struct apds9960_data *data, bool on)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret = 0;\n\n\tmutex_lock(&data->lock);\n\n\tif (on) {\n\t\tint suspended;\n\n\t\tsuspended = pm_runtime_suspended(dev);\n\t\tret = pm_runtime_get_sync(dev);\n\n\t\t \n\t\tif (suspended)\n\t\t\tusleep_range(data->als_adc_int_us,\n\t\t\t\t     APDS9960_MAX_INT_TIME_IN_US);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n#else\nstatic int apds9960_set_power_state(struct apds9960_data *data, bool on)\n{\n\treturn 0;\n}\n#endif\n\nstatic int apds9960_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\t__le16 buf;\n\tint ret = -EINVAL;\n\n\tif (data->gesture_mode_running)\n\t\treturn -EBUSY;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tapds9960_set_power_state(data, true);\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = regmap_read(data->regmap, chan->address, val);\n\t\t\tif (!ret)\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tret = regmap_bulk_read(data->regmap, chan->address,\n\t\t\t\t\t       &buf, 2);\n\t\t\tif (!ret) {\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t\t*val = le16_to_cpu(buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tapds9960_set_power_state(data, false);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t \n\t\tmutex_lock(&data->lock);\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\t*val = 0;\n\t\t\t*val2 = data->als_adc_int_us;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&data->lock);\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\t*val = apds9960_pxs_gain_map[data->pxs_gain];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\t*val = apds9960_als_gain_map[data->als_gain];\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\t}\n\n\treturn ret;\n};\n\nstatic int apds9960_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t \n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\tif (val != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn apds9960_set_it_time(data, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val2 != 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\treturn apds9960_set_pxs_gain(data, val);\n\t\tcase IIO_INTENSITY:\n\t\t\treturn apds9960_set_als_gain(data, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int apds9960_get_thres_reg(const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t\t u8 *reg)\n{\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\t*reg = APDS9960_REG_PIHT;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\t*reg = APDS9960_REG_AIHTL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\t*reg = APDS9960_REG_PILT;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\t*reg = APDS9960_REG_AILTL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int apds9960_read_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int *val, int *val2)\n{\n\tu8 reg;\n\t__le16 buf;\n\tint ret = 0;\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\n\tif (info != IIO_EV_INFO_VALUE)\n\t\treturn -EINVAL;\n\n\tret = apds9960_get_thres_reg(chan, dir, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chan->type == IIO_PROXIMITY) {\n\t\tret = regmap_read(data->regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (chan->type == IIO_INTENSITY) {\n\t\tret = regmap_bulk_read(data->regmap, reg, &buf, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = le16_to_cpu(buf);\n\t} else\n\t\treturn -EINVAL;\n\n\t*val2 = 0;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int apds9960_write_event(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tu8 reg;\n\t__le16 buf;\n\tint ret = 0;\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\n\tif (info != IIO_EV_INFO_VALUE)\n\t\treturn -EINVAL;\n\n\tret = apds9960_get_thres_reg(chan, dir, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chan->type == IIO_PROXIMITY) {\n\t\tif (val < 0 || val > APDS9960_MAX_PXS_THRES_VAL)\n\t\t\treturn -EINVAL;\n\t\tret = regmap_write(data->regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (chan->type == IIO_INTENSITY) {\n\t\tif (val < 0 || val > APDS9960_MAX_ALS_THRES_VAL)\n\t\t\treturn -EINVAL;\n\t\tbuf = cpu_to_le16(val);\n\t\tret = regmap_bulk_write(data->regmap, reg, &buf, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int apds9960_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn data->pxs_int;\n\tcase IIO_INTENSITY:\n\t\treturn data->als_int;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int apds9960_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int state)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tstate = !!state;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tif (data->pxs_int == state)\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_field_write(data->reg_int_pxs, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->pxs_int = state;\n\t\tapds9960_set_power_state(data, state);\n\t\tbreak;\n\tcase IIO_INTENSITY:\n\t\tif (data->als_int == state)\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_field_write(data->reg_int_als, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->als_int = state;\n\t\tapds9960_set_power_state(data, state);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info apds9960_info = {\n\t.attrs = &apds9960_attribute_group,\n\t.read_raw = apds9960_read_raw,\n\t.write_raw = apds9960_write_raw,\n\t.read_event_value = apds9960_read_event,\n\t.write_event_value = apds9960_write_event,\n\t.read_event_config = apds9960_read_event_config,\n\t.write_event_config = apds9960_write_event_config,\n\n};\n\nstatic inline int apds9660_fifo_is_empty(struct apds9960_data *data)\n{\n\tint cnt;\n\tint ret;\n\n\tret = regmap_read(data->regmap, APDS9960_REG_GFLVL, &cnt);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cnt;\n}\n\nstatic void apds9960_read_gesture_fifo(struct apds9960_data *data)\n{\n\tint ret, cnt = 0;\n\n\tmutex_lock(&data->lock);\n\tdata->gesture_mode_running = 1;\n\n\twhile (cnt || (cnt = apds9660_fifo_is_empty(data) > 0)) {\n\t\tret = regmap_bulk_read(data->regmap, APDS9960_REG_GFIFO_BASE,\n\t\t\t\t      &data->buffer, 4);\n\n\t\tif (ret)\n\t\t\tgoto err_read;\n\n\t\tiio_push_to_buffers(data->indio_dev, data->buffer);\n\t\tcnt--;\n\t}\n\nerr_read:\n\tdata->gesture_mode_running = 0;\n\tmutex_unlock(&data->lock);\n}\n\nstatic irqreturn_t apds9960_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\tint ret, status;\n\n\tret = regmap_read(data->regmap, APDS9960_REG_STATUS, &status);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"irq status reg read failed\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif ((status & APDS9960_REG_STATUS_ALS_INT) && data->als_int) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t\tregmap_write(data->regmap, APDS9960_REG_CICLEAR, 1);\n\t}\n\n\tif ((status & APDS9960_REG_STATUS_PS_INT) && data->pxs_int) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t\tregmap_write(data->regmap, APDS9960_REG_PICLEAR, 1);\n\t}\n\n\tif (status & APDS9960_REG_STATUS_GINT)\n\t\tapds9960_read_gesture_fifo(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apds9960_set_powermode(struct apds9960_data *data, bool state)\n{\n\treturn regmap_update_bits(data->regmap, APDS9960_REG_ENABLE, 1, state);\n}\n\nstatic int apds9960_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_field_write(data->reg_int_ges, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_write(data->reg_enable_ges, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(&data->client->dev);\n\n\treturn 0;\n}\n\nstatic int apds9960_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_field_write(data->reg_enable_ges, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_write(data->reg_int_ges, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_put_autosuspend(&data->client->dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops apds9960_buffer_setup_ops = {\n\t.postenable = apds9960_buffer_postenable,\n\t.predisable = apds9960_buffer_predisable,\n};\n\nstatic int apds9960_regfield_init(struct apds9960_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct regmap *regmap = data->regmap;\n\n\tdata->reg_int_als = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_int_als);\n\tif (IS_ERR(data->reg_int_als)) {\n\t\tdev_err(dev, \"INT ALS reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_int_als);\n\t}\n\n\tdata->reg_int_ges = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_int_ges);\n\tif (IS_ERR(data->reg_int_ges)) {\n\t\tdev_err(dev, \"INT gesture reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_int_ges);\n\t}\n\n\tdata->reg_int_pxs = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_int_pxs);\n\tif (IS_ERR(data->reg_int_pxs)) {\n\t\tdev_err(dev, \"INT pxs reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_int_pxs);\n\t}\n\n\tdata->reg_enable_als = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_enable_als);\n\tif (IS_ERR(data->reg_enable_als)) {\n\t\tdev_err(dev, \"Enable ALS reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_enable_als);\n\t}\n\n\tdata->reg_enable_ges = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_enable_ges);\n\tif (IS_ERR(data->reg_enable_ges)) {\n\t\tdev_err(dev, \"Enable gesture reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_enable_ges);\n\t}\n\n\tdata->reg_enable_pxs = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\tapds9960_reg_field_enable_pxs);\n\tif (IS_ERR(data->reg_enable_pxs)) {\n\t\tdev_err(dev, \"Enable PXS reg field init failed\\n\");\n\t\treturn PTR_ERR(data->reg_enable_pxs);\n\t}\n\n\treturn 0;\n}\n\nstatic int apds9960_chip_init(struct apds9960_data *data)\n{\n\tint ret;\n\n\t \n\tret = apds9960_set_it_time(data, 28000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_int_ges, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_enable_ges, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_int_pxs, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_enable_pxs, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_int_als, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_field_write(data->reg_enable_als, 1);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(data->regmap, APDS9960_REG_PERS,\n\t\t\t   APDS9960_DEFAULT_PERS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, APDS9960_REG_GCONF_1,\n\t\t\tAPDS9960_REG_GCONF_1_GFIFO_THRES_MASK,\n\t\t\tBIT(0) << APDS9960_REG_GCONF_1_GFIFO_THRES_MASK_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, APDS9960_REG_GPENTH,\n\t\t\t   APDS9960_DEFAULT_GPENTH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, APDS9960_REG_GEXTH,\n\t\t\t   APDS9960_DEFAULT_GEXTH);\n\tif (ret)\n\t\treturn ret;\n\n\treturn apds9960_set_powermode(data, 1);\n}\n\nstatic int apds9960_probe(struct i2c_client *client)\n{\n\tstruct apds9960_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tindio_dev->info = &apds9960_info;\n\tindio_dev->name = APDS9960_DRV_NAME;\n\tindio_dev->channels = apds9960_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(apds9960_channels);\n\tindio_dev->available_scan_masks = apds9960_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_kfifo_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t  &apds9960_buffer_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &apds9960_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"regmap initialization failed.\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tdata->client = client;\n\tdata->indio_dev = indio_dev;\n\tmutex_init(&data->lock);\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 5000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tapds9960_set_power_state(data, true);\n\n\tret = apds9960_regfield_init(data);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tret = apds9960_chip_init(data);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tif (client->irq <= 0) {\n\t\tdev_err(&client->dev, \"no valid irq defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_power_down;\n\t}\n\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, apds9960_interrupt_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\"apds9960_event\",\n\t\t\t\t\tindio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"request irq (%d) failed\\n\", client->irq);\n\t\tgoto error_power_down;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tapds9960_set_power_state(data, false);\n\n\treturn 0;\n\nerror_power_down:\n\tapds9960_set_power_state(data, false);\n\n\treturn ret;\n}\n\nstatic void apds9960_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct apds9960_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tapds9960_set_powermode(data, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int apds9960_runtime_suspend(struct device *dev)\n{\n\tstruct apds9960_data *data =\n\t\t\tiio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn apds9960_set_powermode(data, 0);\n}\n\nstatic int apds9960_runtime_resume(struct device *dev)\n{\n\tstruct apds9960_data *data =\n\t\t\tiio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn apds9960_set_powermode(data, 1);\n}\n#endif\n\nstatic const struct dev_pm_ops apds9960_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(apds9960_runtime_suspend,\n\t\t\t   apds9960_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id apds9960_id[] = {\n\t{ \"apds9960\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, apds9960_id);\n\nstatic const struct acpi_device_id apds9960_acpi_match[] = {\n\t{ \"MSHW0184\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, apds9960_acpi_match);\n\nstatic const struct of_device_id apds9960_of_match[] = {\n\t{ .compatible = \"avago,apds9960\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, apds9960_of_match);\n\nstatic struct i2c_driver apds9960_driver = {\n\t.driver = {\n\t\t.name\t= APDS9960_DRV_NAME,\n\t\t.of_match_table = apds9960_of_match,\n\t\t.pm\t= &apds9960_pm_ops,\n\t\t.acpi_match_table = apds9960_acpi_match,\n\t},\n\t.probe\t\t= apds9960_probe,\n\t.remove\t\t= apds9960_remove,\n\t.id_table\t= apds9960_id,\n};\nmodule_i2c_driver(apds9960_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"APDS9960 Gesture/RGB/ALS/Proximity sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}