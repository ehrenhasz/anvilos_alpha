{
  "module_name": "us5182d.c",
  "hash_id": "cc79308b81c57cb9f42dde20d7d33ec560e65f89fdec011dcc7d4974503062b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/us5182d.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/iio/sysfs.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#define US5182D_REG_CFG0\t\t\t\t0x00\n#define US5182D_CFG0_ONESHOT_EN\t\t\t\tBIT(6)\n#define US5182D_CFG0_SHUTDOWN_EN\t\t\tBIT(7)\n#define US5182D_CFG0_WORD_ENABLE\t\t\tBIT(0)\n#define US5182D_CFG0_PROX\t\t\t\tBIT(3)\n#define US5182D_CFG0_PX_IRQ\t\t\t\tBIT(2)\n\n#define US5182D_REG_CFG1\t\t\t\t0x01\n#define US5182D_CFG1_ALS_RES16\t\t\t\tBIT(4)\n#define US5182D_CFG1_AGAIN_DEFAULT\t\t\t0x00\n\n#define US5182D_REG_CFG2\t\t\t\t0x02\n#define US5182D_CFG2_PX_RES16\t\t\t\tBIT(4)\n#define US5182D_CFG2_PXGAIN_DEFAULT\t\t\tBIT(2)\n\n#define US5182D_REG_CFG3\t\t\t\t0x03\n#define US5182D_CFG3_LED_CURRENT100\t\t\t(BIT(4) | BIT(5))\n#define US5182D_CFG3_INT_SOURCE_PX\t\t\tBIT(3)\n\n#define US5182D_REG_CFG4\t\t\t\t0x10\n\n \n#define US5182D_REG_UDARK_TH\t\t\t0x27\n#define US5182D_REG_DARK_AUTO_EN\t\t0x2b\n#define US5182D_REG_AUTO_LDARK_GAIN\t\t0x29\n#define US5182D_REG_AUTO_HDARK_GAIN\t\t0x2a\n\n \n#define US5182D_REG_PXL_TH\t\t\t0x08\n#define US5182D_REG_PXH_TH\t\t\t0x0a\n\n#define US5182D_REG_PXL_TH_DEFAULT\t\t1000\n#define US5182D_REG_PXH_TH_DEFAULT\t\t30000\n\n#define US5182D_OPMODE_ALS\t\t\t0x01\n#define US5182D_OPMODE_PX\t\t\t0x02\n#define US5182D_OPMODE_SHIFT\t\t\t4\n\n#define US5182D_REG_DARK_AUTO_EN_DEFAULT\t0x80\n#define US5182D_REG_AUTO_LDARK_GAIN_DEFAULT\t0x16\n#define US5182D_REG_AUTO_HDARK_GAIN_DEFAULT\t0x00\n\n#define US5182D_REG_ADL\t\t\t\t0x0c\n#define US5182D_REG_PDL\t\t\t\t0x0e\n\n#define US5182D_REG_MODE_STORE\t\t\t0x21\n#define US5182D_STORE_MODE\t\t\t0x01\n\n#define US5182D_REG_CHIPID\t\t\t0xb2\n\n#define US5182D_OPMODE_MASK\t\t\tGENMASK(5, 4)\n#define US5182D_AGAIN_MASK\t\t\t0x07\n#define US5182D_RESET_CHIP\t\t\t0x01\n\n#define US5182D_CHIPID\t\t\t\t0x26\n#define US5182D_DRV_NAME\t\t\t\"us5182d\"\n\n#define US5182D_GA_RESOLUTION\t\t\t1000\n\n#define US5182D_READ_BYTE\t\t\t1\n#define US5182D_READ_WORD\t\t\t2\n#define US5182D_OPSTORE_SLEEP_TIME\t\t20  \n#define US5182D_SLEEP_MS\t\t\t3000  \n#define US5182D_PXH_TH_DISABLE\t\t\t0xffff\n#define US5182D_PXL_TH_DISABLE\t\t\t0x0000\n\n \nstatic const int us5182d_scales[] = {188500, 107800, 61000, 33600, 19600, 7600,\n\t\t\t\t     3900, 2100};\n\n \nstatic u16 us5182d_dark_ths_vals[] = {170, 200, 512, 512, 800, 2000, 4000,\n\t\t\t\t      8000};\n\nenum mode {\n\tUS5182D_ALS_PX,\n\tUS5182D_ALS_ONLY,\n\tUS5182D_PX_ONLY\n};\n\nenum pmode {\n\tUS5182D_CONTINUOUS,\n\tUS5182D_ONESHOT\n};\n\nstruct us5182d_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\n\t \n\tu32 ga;\n\n\t \n\tu8 lower_dark_gain;\n\tu8 upper_dark_gain;\n\tu16 *us5182d_dark_ths;\n\n\tu16 px_low_th;\n\tu16 px_high_th;\n\n\tint rising_en;\n\tint falling_en;\n\n\tu8 opmode;\n\tu8 power_mode;\n\n\tbool als_enabled;\n\tbool px_enabled;\n\n\tbool default_continuous;\n};\n\nstatic IIO_CONST_ATTR(in_illuminance_scale_available,\n\t\t      \"0.0021 0.0039 0.0076 0.0196 0.0336 0.061 0.1078 0.1885\");\n\nstatic struct attribute *us5182d_attrs[] = {\n\t&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group us5182d_attr_group = {\n\t.attrs = us5182d_attrs,\n};\n\nstatic const struct {\n\tu8 reg;\n\tu8 val;\n} us5182d_regvals[] = {\n\t{US5182D_REG_CFG0, US5182D_CFG0_WORD_ENABLE},\n\t{US5182D_REG_CFG1, US5182D_CFG1_ALS_RES16},\n\t{US5182D_REG_CFG2, (US5182D_CFG2_PX_RES16 |\n\t\t\t    US5182D_CFG2_PXGAIN_DEFAULT)},\n\t{US5182D_REG_CFG3, US5182D_CFG3_LED_CURRENT100 |\n\t\t\t   US5182D_CFG3_INT_SOURCE_PX},\n\t{US5182D_REG_CFG4, 0x00},\n};\n\nstatic const struct iio_event_spec us5182d_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec us5182d_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = us5182d_events,\n\t\t.num_event_specs = ARRAY_SIZE(us5182d_events),\n\t}\n};\n\nstatic int us5182d_oneshot_en(struct us5182d_data *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ret | US5182D_CFG0_ONESHOT_EN;\n\n\treturn i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\n}\n\nstatic int us5182d_set_opmode(struct us5182d_data *data, u8 mode)\n{\n\tint ret;\n\n\tif (mode == data->opmode)\n\t\treturn 0;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ret & ~US5182D_OPMODE_MASK;\n\tret = ret | (mode << US5182D_OPMODE_SHIFT);\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_MODE_STORE,\n\t\t\t\t\tUS5182D_STORE_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->opmode = mode;\n\tmsleep(US5182D_OPSTORE_SLEEP_TIME);\n\n\treturn 0;\n}\n\nstatic int us5182d_als_enable(struct us5182d_data *data)\n{\n\tint ret;\n\tu8 mode;\n\n\tif (data->power_mode == US5182D_ONESHOT) {\n\t\tret = us5182d_set_opmode(data, US5182D_ALS_ONLY);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->px_enabled = false;\n\t}\n\n\tif (data->als_enabled)\n\t\treturn 0;\n\n\tmode = data->px_enabled ? US5182D_ALS_PX : US5182D_ALS_ONLY;\n\n\tret = us5182d_set_opmode(data, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->als_enabled = true;\n\n\treturn 0;\n}\n\nstatic int us5182d_px_enable(struct us5182d_data *data)\n{\n\tint ret;\n\tu8 mode;\n\n\tif (data->power_mode == US5182D_ONESHOT) {\n\t\tret = us5182d_set_opmode(data, US5182D_PX_ONLY);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->als_enabled = false;\n\t}\n\n\tif (data->px_enabled)\n\t\treturn 0;\n\n\tmode = data->als_enabled ? US5182D_ALS_PX : US5182D_PX_ONLY;\n\n\tret = us5182d_set_opmode(data, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->px_enabled = true;\n\n\treturn 0;\n}\n\nstatic int us5182d_get_als(struct us5182d_data *data)\n{\n\tint ret;\n\tunsigned long result;\n\n\tret = us5182d_als_enable(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t       US5182D_REG_ADL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresult = ret * data->ga / US5182D_GA_RESOLUTION;\n\tif (result > 0xffff)\n\t\tresult = 0xffff;\n\n\treturn result;\n}\n\nstatic int us5182d_get_px(struct us5182d_data *data)\n{\n\tint ret;\n\n\tret = us5182d_px_enable(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_read_word_data(data->client,\n\t\t\t\t\tUS5182D_REG_PDL);\n}\n\nstatic int us5182d_shutdown_en(struct us5182d_data *data, u8 state)\n{\n\tint ret;\n\n\tif (data->power_mode == US5182D_ONESHOT)\n\t\treturn 0;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ret & ~US5182D_CFG0_SHUTDOWN_EN;\n\tret = ret | state;\n\n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state & US5182D_CFG0_SHUTDOWN_EN) {\n\t\tdata->als_enabled = false;\n\t\tdata->px_enabled = false;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int us5182d_set_power_state(struct us5182d_data *data, bool on)\n{\n\tint ret;\n\n\tif (data->power_mode == US5182D_ONESHOT)\n\t\treturn 0;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&data->client->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(&data->client->dev);\n\t\tret = pm_runtime_put_autosuspend(&data->client->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int us5182d_read_value(struct us5182d_data *data,\n\t\t\t      struct iio_chan_spec const *chan)\n{\n\tint ret, value;\n\n\tmutex_lock(&data->lock);\n\n\tif (data->power_mode == US5182D_ONESHOT) {\n\t\tret = us5182d_oneshot_en(data);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tret = us5182d_set_power_state(data, true);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tif (chan->type == IIO_LIGHT)\n\t\tret = us5182d_get_als(data);\n\telse\n\t\tret = us5182d_get_px(data);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tvalue = ret;\n\n\tret = us5182d_set_power_state(data, false);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tmutex_unlock(&data->lock);\n\treturn value;\n\nout_poweroff:\n\tus5182d_set_power_state(data, false);\nout_err:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int us5182d_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = us5182d_read_value(data, chan);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = 0;\n\t\t*val2 = us5182d_scales[ret & US5182D_AGAIN_MASK];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int us5182d_update_dark_th(struct us5182d_data *data, int index)\n{\n\t__be16 dark_th = cpu_to_be16(data->us5182d_dark_ths[index]);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_UDARK_TH,\n\t\t\t\t\t((u8 *)&dark_th)[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(data->client, US5182D_REG_UDARK_TH + 1,\n\t\t\t\t\t((u8 *)&dark_th)[1]);\n}\n\n \nstatic int us5182d_apply_scale(struct us5182d_data *data, int index)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ret & (~US5182D_AGAIN_MASK);\n\tret |= index;\n\n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG1, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn us5182d_update_dark_th(data, index);\n}\n\nstatic int us5182d_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret, i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(us5182d_scales); i++)\n\t\t\tif (val2 == us5182d_scales[i]) {\n\t\t\t\tmutex_lock(&data->lock);\n\t\t\t\tret = us5182d_apply_scale(data, i);\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int us5182d_setup_prox(struct iio_dev *indio_dev,\n\t\t\t      enum iio_event_direction dir, u16 val)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\tif (dir == IIO_EV_DIR_FALLING)\n\t\treturn i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t US5182D_REG_PXL_TH, val);\n\telse if (dir == IIO_EV_DIR_RISING)\n\t\treturn i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t US5182D_REG_PXH_TH, val);\n\n\treturn 0;\n}\n\nstatic int us5182d_read_thresh(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int *val,\n\tint *val2)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tmutex_lock(&data->lock);\n\t\t*val = data->px_high_th;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tmutex_lock(&data->lock);\n\t\t*val = data->px_low_th;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int us5182d_write_thresh(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\tint val2)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (val < 0 || val > USHRT_MAX || val2 != 0)\n\t\treturn -EINVAL;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tmutex_lock(&data->lock);\n\t\tif (data->rising_en) {\n\t\t\tret = us5182d_setup_prox(indio_dev, dir, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t\tdata->px_high_th = val;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tmutex_lock(&data->lock);\n\t\tif (data->falling_en) {\n\t\t\tret = us5182d_setup_prox(indio_dev, dir, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t\tdata->px_low_th = val;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\nerr:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int us5182d_read_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tmutex_lock(&data->lock);\n\t\tret = data->rising_en;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tmutex_lock(&data->lock);\n\t\tret = data->falling_en;\n\t\tmutex_unlock(&data->lock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int us5182d_write_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, int state)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu16 new_th;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tif (data->rising_en == state) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_th = US5182D_PXH_TH_DISABLE;\n\t\tif (state) {\n\t\t\tdata->power_mode = US5182D_CONTINUOUS;\n\t\t\tret = us5182d_set_power_state(data, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\tret = us5182d_px_enable(data);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_poweroff;\n\t\t\tnew_th = data->px_high_th;\n\t\t}\n\t\tret = us5182d_setup_prox(indio_dev, dir, new_th);\n\t\tif (ret < 0)\n\t\t\tgoto err_poweroff;\n\t\tdata->rising_en = state;\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tif (data->falling_en == state) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_th =  US5182D_PXL_TH_DISABLE;\n\t\tif (state) {\n\t\t\tdata->power_mode = US5182D_CONTINUOUS;\n\t\t\tret = us5182d_set_power_state(data, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\tret = us5182d_px_enable(data);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_poweroff;\n\t\t\tnew_th = data->px_low_th;\n\t\t}\n\t\tret = us5182d_setup_prox(indio_dev, dir, new_th);\n\t\tif (ret < 0)\n\t\t\tgoto err_poweroff;\n\t\tdata->falling_en = state;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!state) {\n\t\tret = us5182d_set_power_state(data, false);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (!data->falling_en && !data->rising_en && !data->default_continuous)\n\t\tdata->power_mode = US5182D_ONESHOT;\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n\nerr_poweroff:\n\tif (state)\n\t\tus5182d_set_power_state(data, false);\nerr:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info us5182d_info = {\n\t.read_raw = us5182d_read_raw,\n\t.write_raw = us5182d_write_raw,\n\t.attrs = &us5182d_attr_group,\n\t.read_event_value = &us5182d_read_thresh,\n\t.write_event_value = &us5182d_write_thresh,\n\t.read_event_config = &us5182d_read_event_config,\n\t.write_event_config = &us5182d_write_event_config,\n};\n\nstatic int us5182d_reset(struct iio_dev *indio_dev)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\treturn i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG3,\n\t\t\t\t\t US5182D_RESET_CHIP);\n}\n\nstatic int us5182d_init(struct iio_dev *indio_dev)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tret = us5182d_reset(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->opmode = 0;\n\tdata->power_mode = US5182D_CONTINUOUS;\n\tdata->px_low_th = US5182D_REG_PXL_TH_DEFAULT;\n\tdata->px_high_th = US5182D_REG_PXH_TH_DEFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(us5182d_regvals); i++) {\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t\tus5182d_regvals[i].reg,\n\t\t\t\t\t\tus5182d_regvals[i].val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdata->als_enabled = true;\n\tdata->px_enabled = true;\n\n\tif (!data->default_continuous) {\n\t\tret = us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->power_mode = US5182D_ONESHOT;\n\t}\n\n\treturn ret;\n}\n\nstatic void us5182d_get_platform_data(struct iio_dev *indio_dev)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\tif (device_property_read_u32(&data->client->dev, \"upisemi,glass-coef\",\n\t\t\t\t     &data->ga))\n\t\tdata->ga = US5182D_GA_RESOLUTION;\n\tif (device_property_read_u16_array(&data->client->dev,\n\t\t\t\t\t   \"upisemi,dark-ths\",\n\t\t\t\t\t   data->us5182d_dark_ths,\n\t\t\t\t\t   ARRAY_SIZE(us5182d_dark_ths_vals)))\n\t\tdata->us5182d_dark_ths = us5182d_dark_ths_vals;\n\tif (device_property_read_u8(&data->client->dev,\n\t\t\t\t    \"upisemi,upper-dark-gain\",\n\t\t\t\t    &data->upper_dark_gain))\n\t\tdata->upper_dark_gain = US5182D_REG_AUTO_HDARK_GAIN_DEFAULT;\n\tif (device_property_read_u8(&data->client->dev,\n\t\t\t\t    \"upisemi,lower-dark-gain\",\n\t\t\t\t    &data->lower_dark_gain))\n\t\tdata->lower_dark_gain = US5182D_REG_AUTO_LDARK_GAIN_DEFAULT;\n\tdata->default_continuous = device_property_read_bool(&data->client->dev,\n\t\t\t\t\t\t\t     \"upisemi,continuous\");\n}\n\nstatic int  us5182d_dark_gain_config(struct iio_dev *indio_dev)\n{\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = us5182d_update_dark_th(data, US5182D_CFG1_AGAIN_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tUS5182D_REG_AUTO_LDARK_GAIN,\n\t\t\t\t\tdata->lower_dark_gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tUS5182D_REG_AUTO_HDARK_GAIN,\n\t\t\t\t\tdata->upper_dark_gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(data->client, US5182D_REG_DARK_AUTO_EN,\n\t\t\t\t\t US5182D_REG_DARK_AUTO_EN_DEFAULT);\n}\n\nstatic irqreturn_t us5182d_irq_thread_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\tenum iio_event_direction dir;\n\tint ret;\n\tu64 ev;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdir = ret & US5182D_CFG0_PROX ? IIO_EV_DIR_RISING : IIO_EV_DIR_FALLING;\n\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, dir);\n\n\tiio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\n\n\tret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0,\n\t\t\t\t\tret & ~US5182D_CFG0_PX_IRQ);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int us5182d_probe(struct i2c_client *client)\n{\n\tstruct us5182d_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &us5182d_info;\n\tindio_dev->name = US5182D_DRV_NAME;\n\tindio_dev->channels = us5182d_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(us5182d_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CHIPID);\n\tif (ret != US5182D_CHIPID) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Failed to detect US5182 light chip\\n\");\n\t\treturn (ret < 0) ? ret : -ENODEV;\n\t}\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t\tus5182d_irq_thread_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\t\"us5182d-irq\", indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else\n\t\tdev_warn(&client->dev, \"no valid irq found\\n\");\n\n\tus5182d_get_platform_data(indio_dev);\n\tret = us5182d_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = us5182d_dark_gain_config(indio_dev);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tif (data->default_continuous) {\n\t\tret = pm_runtime_set_active(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t US5182D_SLEEP_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tus5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\n\treturn ret;\n\n}\n\nstatic void us5182d_remove(struct i2c_client *client)\n{\n\tstruct us5182d_data *data = iio_priv(i2c_get_clientdata(client));\n\tint ret;\n\n\tiio_device_unregister(i2c_get_clientdata(client));\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tret = us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to shut down (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic int us5182d_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\tif (data->power_mode == US5182D_CONTINUOUS)\n\t\treturn us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\n\n\treturn 0;\n}\n\nstatic int us5182d_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct us5182d_data *data = iio_priv(indio_dev);\n\n\tif (data->power_mode == US5182D_CONTINUOUS)\n\t\treturn us5182d_shutdown_en(data,\n\t\t\t\t\t   ~US5182D_CFG0_SHUTDOWN_EN & 0xff);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops us5182d_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(us5182d_suspend, us5182d_resume)\n\tRUNTIME_PM_OPS(us5182d_suspend, us5182d_resume, NULL)\n};\n\nstatic const struct acpi_device_id us5182d_acpi_match[] = {\n\t{ \"USD5182\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, us5182d_acpi_match);\n\nstatic const struct i2c_device_id us5182d_id[] = {\n\t{ \"usd5182\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, us5182d_id);\n\nstatic const struct of_device_id us5182d_of_match[] = {\n\t{ .compatible = \"upisemi,usd5182\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, us5182d_of_match);\n\nstatic struct i2c_driver us5182d_driver = {\n\t.driver = {\n\t\t.name = US5182D_DRV_NAME,\n\t\t.pm = pm_ptr(&us5182d_pm_ops),\n\t\t.of_match_table = us5182d_of_match,\n\t\t.acpi_match_table = ACPI_PTR(us5182d_acpi_match),\n\t},\n\t.probe = us5182d_probe,\n\t.remove = us5182d_remove,\n\t.id_table = us5182d_id,\n\n};\nmodule_i2c_driver(us5182d_driver);\n\nMODULE_AUTHOR(\"Adriana Reus <adriana.reus@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for us5182d Proximity and Light Sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}