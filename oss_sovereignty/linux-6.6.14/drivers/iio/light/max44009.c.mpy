{
  "module_name": "max44009.c",
  "hash_id": "597bbaa0792d33c41db9298f064dd9a6afc0ece7f4ba3f02b08c1b7898d9f5bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/max44009.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/util_macros.h>\n\n#define MAX44009_DRV_NAME \"max44009\"\n\n \n#define MAX44009_REG_INT_STATUS 0x0\n#define MAX44009_REG_INT_EN 0x1\n#define MAX44009_REG_CFG 0x2\n#define MAX44009_REG_LUX_HI 0x3\n#define MAX44009_REG_LUX_LO 0x4\n#define MAX44009_REG_UPPER_THR 0x5\n#define MAX44009_REG_LOWER_THR 0x6\n#define MAX44009_REG_THR_TIMER 0x7\n\n#define MAX44009_CFG_TIM_MASK GENMASK(2, 0)\n#define MAX44009_CFG_MAN_MODE_MASK BIT(6)\n\n \n#define MAX44009_MAXIMUM_THRESHOLD 7520256\n\n#define MAX44009_THRESH_EXP_MASK (0xf << 4)\n#define MAX44009_THRESH_EXP_RSHIFT 4\n#define MAX44009_THRESH_MANT_LSHIFT 4\n#define MAX44009_THRESH_MANT_MASK 0xf\n\n#define MAX44009_UPPER_THR_MINIMUM 15\n\n \n#define MAX44009_SCALE_NUMERATOR 45\n#define MAX44009_SCALE_DENOMINATOR 1000\n\n \n#define MAX44009_FRACT_MULT 1000000\n\nstatic const u32 max44009_int_time_ns_array[] = {\n\t800000000,\n\t400000000,\n\t200000000,\n\t100000000,\n\t50000000,  \n\t25000000,  \n\t12500000,  \n\t6250000,   \n};\n\nstatic const char max44009_int_time_str[] =\n\t\"0.8 \"\n\t\"0.4 \"\n\t\"0.2 \"\n\t\"0.1 \"\n\t\"0.05 \"\n\t\"0.025 \"\n\t\"0.0125 \"\n\t\"0.00625\";\n\nstruct max44009_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n};\n\nstatic const struct iio_event_spec max44009_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec max44009_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.event_spec = max44009_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(max44009_event_spec),\n\t},\n};\n\nstatic int max44009_read_int_time(struct max44009_data *data)\n{\n\n\tint ret = i2c_smbus_read_byte_data(data->client, MAX44009_REG_CFG);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn max44009_int_time_ns_array[ret & MAX44009_CFG_TIM_MASK];\n}\n\nstatic int max44009_write_int_time(struct max44009_data *data,\n\t\t\t\t   int val, int val2)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret, int_time, config;\n\ts64 ns;\n\n\tns = val * NSEC_PER_SEC + val2;\n\tint_time = find_closest_descending(\n\t\t\tns,\n\t\t\tmax44009_int_time_ns_array,\n\t\t\tARRAY_SIZE(max44009_int_time_ns_array));\n\n\tret = i2c_smbus_read_byte_data(client, MAX44009_REG_CFG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconfig = ret;\n\tconfig &= int_time;\n\n\t \n\tconfig |= MAX44009_CFG_MAN_MODE_MASK;\n\n\treturn i2c_smbus_write_byte_data(client, MAX44009_REG_CFG, config);\n}\n\nstatic int max44009_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan, int val,\n\t\t\t      int val2, long mask)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_INT_TIME && chan->type == IIO_LIGHT) {\n\t\tmutex_lock(&data->lock);\n\t\tret = max44009_write_int_time(data, val, val2);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int max44009_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      long mask)\n{\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int max44009_lux_raw(u8 hi, u8 lo)\n{\n\tint mantissa;\n\tint exponent;\n\n\t \n\tmantissa = ((hi & 0xf) << 4) | (lo & 0xf);\n\n\t \n\texponent = (hi >> 4) & 0xf;\n\n\t \n\texponent = 1 << exponent;\n\n\treturn exponent * mantissa;\n}\n\n#define MAX44009_READ_LUX_XFER_LEN (4)\n\nstatic int max44009_read_lux_raw(struct max44009_data *data)\n{\n\tint ret;\n\tu8 hireg = MAX44009_REG_LUX_HI;\n\tu8 loreg = MAX44009_REG_LUX_LO;\n\tu8 lo = 0;\n\tu8 hi = 0;\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = data->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(hireg),\n\t\t\t.buf = &hireg,\n\t\t},\n\t\t{\n\t\t\t.addr = data->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(hi),\n\t\t\t.buf = &hi,\n\t\t},\n\t\t{\n\t\t\t.addr = data->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(loreg),\n\t\t\t.buf = &loreg,\n\t\t},\n\t\t{\n\t\t\t.addr = data->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(lo),\n\t\t\t.buf = &lo,\n\t\t}\n\t};\n\n\t \n\tret = i2c_transfer(data->client->adapter,\n\t\t\t   msgs, MAX44009_READ_LUX_XFER_LEN);\n\n\tif (ret != MAX44009_READ_LUX_XFER_LEN)\n\t\treturn -EIO;\n\n\treturn max44009_lux_raw(hi, lo);\n}\n\nstatic int max44009_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint lux_raw;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = max44009_read_lux_raw(data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tlux_raw = ret;\n\n\t\t\t*val = lux_raw * MAX44009_SCALE_NUMERATOR;\n\t\t\t*val2 = MAX44009_SCALE_DENOMINATOR;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = max44009_read_int_time(data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*val2 = ret;\n\t\t\t*val = 0;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR(illuminance_integration_time_available,\n\t\t      max44009_int_time_str);\n\nstatic struct attribute *max44009_attributes[] = {\n\t&iio_const_attr_illuminance_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group max44009_attribute_group = {\n\t.attrs = max44009_attributes,\n};\n\nstatic int max44009_threshold_byte_from_fraction(int integral, int fractional)\n{\n\tint mantissa, exp;\n\n\tif ((integral <= 0 && fractional <= 0) ||\n\t     integral > MAX44009_MAXIMUM_THRESHOLD ||\n\t     (integral == MAX44009_MAXIMUM_THRESHOLD && fractional != 0))\n\t\treturn -EINVAL;\n\n\t \n\tmantissa = integral * MAX44009_SCALE_DENOMINATOR;\n\tmantissa /= MAX44009_SCALE_NUMERATOR;\n\n\t \n\tmantissa += fractional / MAX44009_FRACT_MULT *\n\t\t    (MAX44009_SCALE_DENOMINATOR / MAX44009_SCALE_NUMERATOR);\n\n\tfor (exp = 0; mantissa > 0xff; exp++)\n\t\tmantissa >>= 1;\n\n\tmantissa >>= 4;\n\tmantissa &= 0xf;\n\texp <<= 4;\n\n\treturn exp | mantissa;\n}\n\nstatic int max44009_get_thr_reg(enum iio_event_direction dir)\n{\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\treturn MAX44009_REG_UPPER_THR;\n\tcase IIO_EV_DIR_FALLING:\n\t\treturn MAX44009_REG_LOWER_THR;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int max44009_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      enum iio_event_info info,\n\t\t\t\t      int val, int val2)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint reg, threshold;\n\n\tif (info != IIO_EV_INFO_VALUE || chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tthreshold = max44009_threshold_byte_from_fraction(val, val2);\n\tif (threshold < 0)\n\t\treturn threshold;\n\n\treg = max44009_get_thr_reg(dir);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn i2c_smbus_write_byte_data(data->client, reg, threshold);\n}\n\nstatic int max44009_read_threshold(struct iio_dev *indio_dev,\n\t\t\t\t   enum iio_event_direction dir)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint byte, reg;\n\tint mantissa, exponent;\n\n\treg = max44009_get_thr_reg(dir);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tbyte = i2c_smbus_read_byte_data(data->client, reg);\n\tif (byte < 0)\n\t\treturn byte;\n\n\tmantissa = byte & MAX44009_THRESH_MANT_MASK;\n\tmantissa <<= MAX44009_THRESH_MANT_LSHIFT;\n\n\t \n\tif (dir == IIO_EV_DIR_RISING)\n\t\tmantissa += MAX44009_UPPER_THR_MINIMUM;\n\n\t \n\texponent = byte & MAX44009_THRESH_EXP_MASK;\n\texponent >>= MAX44009_THRESH_EXP_RSHIFT;\n\n\treturn (1 << exponent) * mantissa;\n}\n\nstatic int max44009_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int *val, int *val2)\n{\n\tint ret;\n\tint threshold;\n\n\tif (chan->type != IIO_LIGHT || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tret = max44009_read_threshold(indio_dev, dir);\n\tif (ret < 0)\n\t\treturn ret;\n\tthreshold = ret;\n\n\t*val = threshold * MAX44009_SCALE_NUMERATOR;\n\t*val2 = MAX44009_SCALE_DENOMINATOR;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int max44009_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int state)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_LIGHT || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tMAX44009_REG_INT_EN, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t MAX44009_REG_THR_TIMER, 0);\n}\n\nstatic int max44009_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_LIGHT || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_read_byte_data(data->client, MAX44009_REG_INT_EN);\n}\n\nstatic const struct iio_info max44009_info = {\n\t.read_raw = max44009_read_raw,\n\t.write_raw = max44009_write_raw,\n\t.write_raw_get_fmt = max44009_write_raw_get_fmt,\n\t.read_event_value = max44009_read_event_value,\n\t.read_event_config = max44009_read_event_config,\n\t.write_event_value = max44009_write_event_value,\n\t.write_event_config = max44009_write_event_config,\n\t.attrs = &max44009_attribute_group,\n};\n\nstatic irqreturn_t max44009_threaded_irq_handler(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct max44009_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, MAX44009_REG_INT_STATUS);\n\tif (ret) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int max44009_probe(struct i2c_client *client)\n{\n\tstruct max44009_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tindio_dev->info = &max44009_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = MAX44009_DRV_NAME;\n\tindio_dev->channels = max44009_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max44009_channels);\n\tmutex_init(&data->lock);\n\n\t \n\tret = i2c_smbus_read_byte_data(client, MAX44009_REG_CFG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tmax44009_threaded_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\t\t\"max44009_event\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id max44009_of_match[] = {\n\t{ .compatible = \"maxim,max44009\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max44009_of_match);\n\nstatic const struct i2c_device_id max44009_id[] = {\n\t{ \"max44009\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max44009_id);\n\nstatic struct i2c_driver max44009_driver = {\n\t.driver = {\n\t\t.name = MAX44009_DRV_NAME,\n\t\t.of_match_table = max44009_of_match,\n\t},\n\t.probe = max44009_probe,\n\t.id_table = max44009_id,\n};\nmodule_i2c_driver(max44009_driver);\n\nMODULE_AUTHOR(\"Robert Eshleman <bobbyeshleman@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MAX44009 ambient light sensor driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}