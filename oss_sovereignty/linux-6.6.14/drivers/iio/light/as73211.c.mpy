{
  "module_name": "as73211.c",
  "hash_id": "7ea3c5008fe03ac503a3b129131073391019bdfb4609c26e6942f89ce3b8c796",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/as73211.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/units.h>\n\n#define AS73211_DRV_NAME \"as73211\"\n\n \n#define AS73211_REG_OSR    0x0\n#define AS73211_REG_AGEN   0x2\n#define AS73211_REG_CREG1  0x6\n#define AS73211_REG_CREG2  0x7\n#define AS73211_REG_CREG3  0x8\n\n \n#define AS73211_OUT_OSR_STATUS    0\n#define AS73211_OUT_TEMP          1\n#define AS73211_OUT_MRES1         2\n#define AS73211_OUT_MRES2         3\n#define AS73211_OUT_MRES3         4\n\n#define AS73211_OSR_SS            BIT(7)\n#define AS73211_OSR_PD            BIT(6)\n#define AS73211_OSR_SW_RES        BIT(3)\n#define AS73211_OSR_DOS_MASK      GENMASK(2, 0)\n#define AS73211_OSR_DOS_CONFIG    FIELD_PREP(AS73211_OSR_DOS_MASK, 0x2)\n#define AS73211_OSR_DOS_MEASURE   FIELD_PREP(AS73211_OSR_DOS_MASK, 0x3)\n\n#define AS73211_AGEN_DEVID_MASK   GENMASK(7, 4)\n#define AS73211_AGEN_DEVID(x)     FIELD_PREP(AS73211_AGEN_DEVID_MASK, (x))\n#define AS73211_AGEN_MUT_MASK     GENMASK(3, 0)\n#define AS73211_AGEN_MUT(x)       FIELD_PREP(AS73211_AGEN_MUT_MASK, (x))\n\n#define AS73211_CREG1_GAIN_MASK   GENMASK(7, 4)\n#define AS73211_CREG1_GAIN_1      11\n#define AS73211_CREG1_TIME_MASK   GENMASK(3, 0)\n\n#define AS73211_CREG3_CCLK_MASK   GENMASK(1, 0)\n\n#define AS73211_OSR_STATUS_OUTCONVOF  BIT(15)\n#define AS73211_OSR_STATUS_MRESOF     BIT(14)\n#define AS73211_OSR_STATUS_ADCOF      BIT(13)\n#define AS73211_OSR_STATUS_LDATA      BIT(12)\n#define AS73211_OSR_STATUS_NDATA      BIT(11)\n#define AS73211_OSR_STATUS_NOTREADY   BIT(10)\n\n#define AS73211_SAMPLE_FREQ_BASE      1024000\n\n#define AS73211_SAMPLE_TIME_NUM       15\n#define AS73211_SAMPLE_TIME_MAX_MS    BIT(AS73211_SAMPLE_TIME_NUM - 1)\n\n \nstatic const int as73211_samp_freq_avail[] = {\n\tAS73211_SAMPLE_FREQ_BASE * 1,\n\tAS73211_SAMPLE_FREQ_BASE * 2,\n\tAS73211_SAMPLE_FREQ_BASE * 4,\n\tAS73211_SAMPLE_FREQ_BASE * 8,\n};\n\nstatic const int as73211_hardwaregain_avail[] = {\n\t1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048,\n};\n\n \nstruct as73211_data {\n\tstruct i2c_client *client;\n\tu8 osr;\n\tu8 creg1;\n\tu8 creg2;\n\tu8 creg3;\n\tstruct mutex mutex;\n\tstruct completion completion;\n\tint int_time_avail[AS73211_SAMPLE_TIME_NUM * 2];\n};\n\n#define AS73211_COLOR_CHANNEL(_color, _si, _addr) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_type = \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN) | \\\n\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.info_mask_shared_by_type_available = \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN) | \\\n\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = IIO_MOD_##_color, \\\n\t.address = _addr, \\\n\t.scan_index = _si, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_LE, \\\n\t}, \\\n}\n\n#define AS73211_OFFSET_TEMP_INT    (-66)\n#define AS73211_OFFSET_TEMP_MICRO  900000\n#define AS73211_SCALE_TEMP_INT     0\n#define AS73211_SCALE_TEMP_MICRO   50000\n\n#define AS73211_SCALE_X 277071108   \n#define AS73211_SCALE_Y 298384270   \n#define AS73211_SCALE_Z 160241927   \n\n \n#define AS73211_SCAN_INDEX_TEMP 0\n#define AS73211_SCAN_INDEX_X    1\n#define AS73211_SCAN_INDEX_Y    2\n#define AS73211_SCAN_INDEX_Z    3\n#define AS73211_SCAN_INDEX_TS   4\n\n#define AS73211_SCAN_MASK_COLOR ( \\\n\tBIT(AS73211_SCAN_INDEX_X) |   \\\n\tBIT(AS73211_SCAN_INDEX_Y) |   \\\n\tBIT(AS73211_SCAN_INDEX_Z))\n\n#define AS73211_SCAN_MASK_ALL (    \\\n\tBIT(AS73211_SCAN_INDEX_TEMP) | \\\n\tAS73211_SCAN_MASK_COLOR)\n\nstatic const struct iio_chan_spec as73211_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = AS73211_OUT_TEMP,\n\t\t.scan_index = AS73211_SCAN_INDEX_TEMP,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t}\n\t},\n\tAS73211_COLOR_CHANNEL(X, AS73211_SCAN_INDEX_X, AS73211_OUT_MRES1),\n\tAS73211_COLOR_CHANNEL(Y, AS73211_SCAN_INDEX_Y, AS73211_OUT_MRES2),\n\tAS73211_COLOR_CHANNEL(Z, AS73211_SCAN_INDEX_Z, AS73211_OUT_MRES3),\n\tIIO_CHAN_SOFT_TIMESTAMP(AS73211_SCAN_INDEX_TS),\n};\n\nstatic unsigned int as73211_integration_time_1024cyc(struct as73211_data *data)\n{\n\t \n\treturn BIT(FIELD_GET(AS73211_CREG1_TIME_MASK, data->creg1));\n}\n\nstatic unsigned int as73211_integration_time_us(struct as73211_data *data,\n\t\t\t\t\t\t unsigned int integration_time_1024cyc)\n{\n\t \n\treturn BIT(3 - FIELD_GET(AS73211_CREG3_CCLK_MASK, data->creg3)) *\n\t\tintegration_time_1024cyc * 125;\n}\n\nstatic void as73211_integration_time_calc_avail(struct as73211_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->int_time_avail) / 2; i++) {\n\t\tunsigned int time_us = as73211_integration_time_us(data, BIT(i));\n\n\t\tdata->int_time_avail[i * 2 + 0] = time_us / USEC_PER_SEC;\n\t\tdata->int_time_avail[i * 2 + 1] = time_us % USEC_PER_SEC;\n\t}\n}\n\nstatic unsigned int as73211_gain(struct as73211_data *data)\n{\n\t \n\treturn BIT(AS73211_CREG1_GAIN_1 - FIELD_GET(AS73211_CREG1_GAIN_MASK, data->creg1));\n}\n\n \nstatic int as73211_req_data(struct as73211_data *data)\n{\n\tunsigned int time_us = as73211_integration_time_us(data,\n\t\t\t\t\t\t\t    as73211_integration_time_1024cyc(data));\n\tstruct device *dev = &data->client->dev;\n\tunion i2c_smbus_data smbus_data;\n\tu16 osr_status;\n\tint ret;\n\n\tif (data->client->irq)\n\t\treinit_completion(&data->completion);\n\n\t \n\ti2c_lock_bus(data->client->adapter, I2C_LOCK_SEGMENT);\n\n\tdata->osr &= ~AS73211_OSR_DOS_MASK;\n\tdata->osr |= AS73211_OSR_DOS_MEASURE | AS73211_OSR_SS;\n\n\tsmbus_data.byte = data->osr;\n\tret = __i2c_smbus_xfer(data->client->adapter, data->client->addr,\n\t\t\tdata->client->flags, I2C_SMBUS_WRITE,\n\t\t\tAS73211_REG_OSR, I2C_SMBUS_BYTE_DATA, &smbus_data);\n\tif (ret < 0) {\n\t\ti2c_unlock_bus(data->client->adapter, I2C_LOCK_SEGMENT);\n\t\treturn ret;\n\t}\n\n\t \n\tdata->osr &= ~AS73211_OSR_SS;\n\n\t \n\ttime_us += time_us / 3;\n\tif (data->client->irq) {\n\t\tret = wait_for_completion_timeout(&data->completion, usecs_to_jiffies(time_us));\n\t\tif (!ret) {\n\t\t\tdev_err(dev, \"timeout waiting for READY IRQ\\n\");\n\t\t\ti2c_unlock_bus(data->client->adapter, I2C_LOCK_SEGMENT);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\t \n\t\tusleep_range(time_us, 2 * time_us);\n\t}\n\n\ti2c_unlock_bus(data->client->adapter, I2C_LOCK_SEGMENT);\n\n\tret = i2c_smbus_read_word_data(data->client, AS73211_OUT_OSR_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tosr_status = ret;\n\tif (osr_status != (AS73211_OSR_DOS_MEASURE | AS73211_OSR_STATUS_NDATA)) {\n\t\tif (osr_status & AS73211_OSR_SS) {\n\t\t\tdev_err(dev, \"%s() Measurement has not stopped\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tif (osr_status & AS73211_OSR_STATUS_NOTREADY) {\n\t\t\tdev_err(dev, \"%s() Data is not ready\\n\", __func__);\n\t\t\treturn -ENODATA;\n\t\t}\n\t\tif (!(osr_status & AS73211_OSR_STATUS_NDATA)) {\n\t\t\tdev_err(dev, \"%s() No new data available\\n\", __func__);\n\t\t\treturn -ENODATA;\n\t\t}\n\t\tif (osr_status & AS73211_OSR_STATUS_LDATA) {\n\t\t\tdev_err(dev, \"%s() Result buffer overrun\\n\", __func__);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (osr_status & AS73211_OSR_STATUS_ADCOF) {\n\t\t\tdev_err(dev, \"%s() ADC overflow\\n\", __func__);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tif (osr_status & AS73211_OSR_STATUS_MRESOF) {\n\t\t\tdev_err(dev, \"%s() Measurement result overflow\\n\", __func__);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tif (osr_status & AS73211_OSR_STATUS_OUTCONVOF) {\n\t\t\tdev_err(dev, \"%s() Timer overflow\\n\", __func__);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tdev_err(dev, \"%s() Unexpected status value\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int as73211_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = as73211_req_data(data);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = AS73211_OFFSET_TEMP_INT;\n\t\t*val2 = AS73211_OFFSET_TEMP_MICRO;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = AS73211_SCALE_TEMP_INT;\n\t\t\t*val2 = AS73211_SCALE_TEMP_MICRO;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\t\tcase IIO_INTENSITY: {\n\t\t\tunsigned int scale;\n\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_X:\n\t\t\t\tscale = AS73211_SCALE_X;\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_Y:\n\t\t\t\tscale = AS73211_SCALE_Y;\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_Z:\n\t\t\t\tscale = AS73211_SCALE_Z;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscale /= as73211_gain(data);\n\t\t\tscale /= as73211_integration_time_1024cyc(data);\n\t\t\t*val = scale;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}}\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t \n\t\t*val = BIT(FIELD_GET(AS73211_CREG3_CCLK_MASK, data->creg3)) *\n\t\t\tAS73211_SAMPLE_FREQ_BASE;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t*val = as73211_gain(data);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_INT_TIME: {\n\t\tunsigned int time_us;\n\n\t\tmutex_lock(&data->mutex);\n\t\ttime_us = as73211_integration_time_us(data, as73211_integration_time_1024cyc(data));\n\t\tmutex_unlock(&data->mutex);\n\t\t*val = time_us / USEC_PER_SEC;\n\t\t*val2 = time_us % USEC_PER_SEC;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}}\n}\n\nstatic int as73211_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length, long mask)\n{\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*length = ARRAY_SIZE(as73211_samp_freq_avail);\n\t\t*vals = as73211_samp_freq_avail;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t*length = ARRAY_SIZE(as73211_hardwaregain_avail);\n\t\t*vals = as73211_hardwaregain_avail;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*length = ARRAY_SIZE(data->int_time_avail);\n\t\t*vals = data->int_time_avail;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int _as73211_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan __always_unused,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ: {\n\t\tint reg_bits, freq_kHz = val / HZ_PER_KHZ;   \n\n\t\t \n\t\tif (val < 0 || (freq_kHz * HZ_PER_KHZ) != val ||\n\t\t\t\t!is_power_of_2(freq_kHz) || val2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\treg_bits = ilog2(freq_kHz) - 10;\n\t\tif (!FIELD_FIT(AS73211_CREG3_CCLK_MASK, reg_bits))\n\t\t\treturn -EINVAL;\n\n\t\tdata->creg3 &= ~AS73211_CREG3_CCLK_MASK;\n\t\tdata->creg3 |= FIELD_PREP(AS73211_CREG3_CCLK_MASK, reg_bits);\n\t\tas73211_integration_time_calc_avail(data);\n\n\t\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_CREG3, data->creg3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\t}\n\tcase IIO_CHAN_INFO_HARDWAREGAIN: {\n\t\tunsigned int reg_bits;\n\n\t\tif (val < 0 || !is_power_of_2(val) || val2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\treg_bits = AS73211_CREG1_GAIN_1 - ilog2(val);\n\t\tif (!FIELD_FIT(AS73211_CREG1_GAIN_MASK, reg_bits))\n\t\t\treturn -EINVAL;\n\n\t\tdata->creg1 &= ~AS73211_CREG1_GAIN_MASK;\n\t\tdata->creg1 |= FIELD_PREP(AS73211_CREG1_GAIN_MASK, reg_bits);\n\n\t\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_CREG1, data->creg1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\t}\n\tcase IIO_CHAN_INFO_INT_TIME: {\n\t\tint val_us = val * USEC_PER_SEC + val2;\n\t\tint time_ms;\n\t\tint reg_bits;\n\n\t\t \n\t\tint f_samp_1_024mhz = BIT(FIELD_GET(AS73211_CREG3_CCLK_MASK, data->creg3));\n\n\t\t \n\t\ttime_ms = (val_us * f_samp_1_024mhz) / 1000;   \n\t\tif (time_ms < 0 || !is_power_of_2(time_ms) || time_ms > AS73211_SAMPLE_TIME_MAX_MS)\n\t\t\treturn -EINVAL;\n\n\t\treg_bits = ilog2(time_ms);\n\t\tif (!FIELD_FIT(AS73211_CREG1_TIME_MASK, reg_bits))\n\t\t\treturn -EINVAL;   \n\n\t\tdata->creg1 &= ~AS73211_CREG1_TIME_MASK;\n\t\tdata->creg1 |= FIELD_PREP(AS73211_CREG1_TIME_MASK, reg_bits);\n\n\t\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_CREG1, data->creg1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}}\n}\n\nstatic int as73211_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\t \n\tif ((data->osr & AS73211_OSR_DOS_MASK) != AS73211_OSR_DOS_CONFIG) {\n\t\tdata->osr &= ~AS73211_OSR_DOS_MASK;\n\t\tdata->osr |= AS73211_OSR_DOS_CONFIG;\n\n\t\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_OSR, data->osr);\n\t\tif (ret < 0)\n\t\t\tgoto error_release;\n\t}\n\n\tret = _as73211_write_raw(indio_dev, chan, val, val2, mask);\n\nerror_release:\n\tiio_device_release_direct_mode(indio_dev);\nerror_unlock:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic irqreturn_t as73211_ready_handler(int irq __always_unused, void *priv)\n{\n\tstruct as73211_data *data = iio_priv(priv);\n\n\tcomplete(&data->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t as73211_trigger_handler(int irq __always_unused, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\tstruct {\n\t\t__le16 chan[4];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\tint data_result, ret;\n\n\tmutex_lock(&data->mutex);\n\n\tdata_result = as73211_req_data(data);\n\tif (data_result < 0 && data_result != -EOVERFLOW)\n\t\tgoto done;   \n\n\tif (*indio_dev->active_scan_mask == AS73211_SCAN_MASK_ALL) {\n\t\t \n\t\tu8 addr = as73211_channels[0].address;\n\t\tstruct i2c_msg msgs[] = {\n\t\t\t{\n\t\t\t\t.addr = data->client->addr,\n\t\t\t\t.flags = 0,\n\t\t\t\t.len = 1,\n\t\t\t\t.buf = &addr,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = data->client->addr,\n\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t.len = sizeof(scan.chan),\n\t\t\t\t.buf = (u8 *)&scan.chan,\n\t\t\t},\n\t\t};\n\n\t\tret = i2c_transfer(data->client->adapter, msgs, ARRAY_SIZE(msgs));\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t} else {\n\t\t \n\n\t\t \n\t\tret = i2c_master_recv(data->client,\n\t\t\t\t(char *)&scan.chan[1], 3 * sizeof(scan.chan[1]));\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (data_result) {\n\t\t \n\t\tscan.chan[1] = cpu_to_le16(U16_MAX);\n\t\tscan.chan[2] = cpu_to_le16(U16_MAX);\n\t\tscan.chan[3] = cpu_to_le16(U16_MAX);\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan, iio_get_time_ns(indio_dev));\n\ndone:\n\tmutex_unlock(&data->mutex);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info as73211_info = {\n\t.read_raw = as73211_read_raw,\n\t.read_avail = as73211_read_avail,\n\t.write_raw = as73211_write_raw,\n};\n\nstatic int as73211_power(struct iio_dev *indio_dev, bool state)\n{\n\tstruct as73211_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tif (state)\n\t\tdata->osr &= ~AS73211_OSR_PD;\n\telse\n\t\tdata->osr |= AS73211_OSR_PD;\n\n\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_OSR, data->osr);\n\n\tmutex_unlock(&data->mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void as73211_power_disable(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\n\tas73211_power(indio_dev, false);\n}\n\nstatic int as73211_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct as73211_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tmutex_init(&data->mutex);\n\tinit_completion(&data->completion);\n\n\tindio_dev->info = &as73211_info;\n\tindio_dev->name = AS73211_DRV_NAME;\n\tindio_dev->channels = as73211_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(as73211_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_OSR);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->osr = ret;\n\n\t \n\tdata->osr |= AS73211_OSR_SW_RES;\n\tret = i2c_smbus_write_byte_data(data->client, AS73211_REG_OSR, data->osr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_OSR);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->osr = ret;\n\n\t \n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_AGEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif ((ret & AS73211_AGEN_DEVID_MASK) != AS73211_AGEN_DEVID(2) ||\n\t    (ret & AS73211_AGEN_MUT_MASK) != AS73211_AGEN_MUT(1))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_CREG1);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->creg1 = ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_CREG2);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->creg2 = ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, AS73211_REG_CREG3);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->creg3 = ret;\n\tas73211_integration_time_calc_avail(data);\n\n\tret = as73211_power(indio_dev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, as73211_power_disable, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL, as73211_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL,\n\t\t\t\tas73211_ready_handler,\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tclient->name, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic int as73211_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn as73211_power(indio_dev, false);\n}\n\nstatic int as73211_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn as73211_power(indio_dev, true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(as73211_pm_ops, as73211_suspend,\n\t\t\t\tas73211_resume);\n\nstatic const struct of_device_id as73211_of_match[] = {\n\t{ .compatible = \"ams,as73211\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, as73211_of_match);\n\nstatic const struct i2c_device_id as73211_id[] = {\n\t{ \"as73211\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, as73211_id);\n\nstatic struct i2c_driver as73211_driver = {\n\t.driver = {\n\t\t.name           = AS73211_DRV_NAME,\n\t\t.of_match_table = as73211_of_match,\n\t\t.pm             = pm_sleep_ptr(&as73211_pm_ops),\n\t},\n\t.probe      = as73211_probe,\n\t.id_table   = as73211_id,\n};\nmodule_i2c_driver(as73211_driver);\n\nMODULE_AUTHOR(\"Christian Eggers <ceggers@arri.de>\");\nMODULE_DESCRIPTION(\"AS73211 XYZ True Color Sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}