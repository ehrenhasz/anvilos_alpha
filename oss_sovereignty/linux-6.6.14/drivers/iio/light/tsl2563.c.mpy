{
  "module_name": "tsl2563.c",
  "hash_id": "582b1589c63e14a89fd7684589e74cfcd262388f9522d4c5247b5e5a60c2dc2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tsl2563.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/math.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define ADC_FRAC_BITS\t\t14\n\n \n#define FRAC10K(f)\t\t(((f) * BIT(ADC_FRAC_BITS)) / (10000))\n\n \n#define CALIB_FRAC_BITS\t\t10\n \n#define CALIB_BASE_SYSFS\t1000\n\n#define TSL2563_CMD\t\tBIT(7)\n#define TSL2563_CLEARINT\tBIT(6)\n\n#define TSL2563_REG_CTRL\t0x00\n#define TSL2563_REG_TIMING\t0x01\n#define TSL2563_REG_LOW\t\t0x02  \n#define TSL2563_REG_HIGH\t0x04  \n#define TSL2563_REG_INT\t\t0x06\n#define TSL2563_REG_ID\t\t0x0a\n#define TSL2563_REG_DATA0\t0x0c  \n#define TSL2563_REG_DATA1\t0x0e  \n\n#define TSL2563_CMD_POWER_ON\t0x03\n#define TSL2563_CMD_POWER_OFF\t0x00\n#define TSL2563_CTRL_POWER_MASK\tGENMASK(1, 0)\n\n#define TSL2563_TIMING_13MS\t0x00\n#define TSL2563_TIMING_100MS\t0x01\n#define TSL2563_TIMING_400MS\t0x02\n#define TSL2563_TIMING_MASK\tGENMASK(1, 0)\n#define TSL2563_TIMING_GAIN16\t0x10\n#define TSL2563_TIMING_GAIN1\t0x00\n\n#define TSL2563_INT_DISABLED\t0x00\n#define TSL2563_INT_LEVEL\t0x10\n#define TSL2563_INT_MASK\tGENMASK(5, 4)\n#define TSL2563_INT_PERSIST(n)\t((n) & GENMASK(3, 0))\n\nstruct tsl2563_gainlevel_coeff {\n\tu8 gaintime;\n\tu16 min;\n\tu16 max;\n};\n\nstatic const struct tsl2563_gainlevel_coeff tsl2563_gainlevel_table[] = {\n\t{\n\t\t.gaintime\t= TSL2563_TIMING_400MS | TSL2563_TIMING_GAIN16,\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 65534,\n\t}, {\n\t\t.gaintime\t= TSL2563_TIMING_400MS | TSL2563_TIMING_GAIN1,\n\t\t.min\t\t= 2048,\n\t\t.max\t\t= 65534,\n\t}, {\n\t\t.gaintime\t= TSL2563_TIMING_100MS | TSL2563_TIMING_GAIN1,\n\t\t.min\t\t= 4095,\n\t\t.max\t\t= 37177,\n\t}, {\n\t\t.gaintime\t= TSL2563_TIMING_13MS | TSL2563_TIMING_GAIN1,\n\t\t.min\t\t= 3000,\n\t\t.max\t\t= 65535,\n\t},\n};\n\nstruct tsl2563_chip {\n\tstruct mutex\t\tlock;\n\tstruct i2c_client\t*client;\n\tstruct delayed_work\tpoweroff_work;\n\n\t \n\tbool suspended;\n\n\tstruct tsl2563_gainlevel_coeff const *gainlevel;\n\n\tu16\t\t\tlow_thres;\n\tu16\t\t\thigh_thres;\n\tu8\t\t\tintr;\n\tbool\t\t\tint_enabled;\n\n\t \n\tu32\t\t\tcalib0;\n\tu32\t\t\tcalib1;\n\tint\t\t\tcover_comp_gain;\n\n\t \n\tu32\t\t\tdata0;\n\tu32\t\t\tdata1;\n};\n\nstatic int tsl2563_set_power(struct tsl2563_chip *chip, int on)\n{\n\tstruct i2c_client *client = chip->client;\n\tu8 cmd;\n\n\tcmd = on ? TSL2563_CMD_POWER_ON : TSL2563_CMD_POWER_OFF;\n\treturn i2c_smbus_write_byte_data(client,\n\t\t\t\t\t TSL2563_CMD | TSL2563_REG_CTRL, cmd);\n}\n\n \nstatic int tsl2563_get_power(struct tsl2563_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, TSL2563_CMD | TSL2563_REG_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret & TSL2563_CTRL_POWER_MASK) == TSL2563_CMD_POWER_ON;\n}\n\nstatic int tsl2563_configure(struct tsl2563_chip *chip)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\tTSL2563_CMD | TSL2563_REG_TIMING,\n\t\t\tchip->gainlevel->gaintime);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = i2c_smbus_write_word_data(chip->client,\n\t\t\tTSL2563_CMD | TSL2563_REG_HIGH,\n\t\t\tchip->high_thres);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = i2c_smbus_write_word_data(chip->client,\n\t\t\tTSL2563_CMD | TSL2563_REG_LOW,\n\t\t\tchip->low_thres);\n\tif (ret)\n\t\tgoto error_ret;\n \nerror_ret:\n\treturn ret;\n}\n\nstatic void tsl2563_poweroff_work(struct work_struct *work)\n{\n\tstruct tsl2563_chip *chip =\n\t\tcontainer_of(work, struct tsl2563_chip, poweroff_work.work);\n\ttsl2563_set_power(chip, 0);\n}\n\nstatic int tsl2563_detect(struct tsl2563_chip *chip)\n{\n\tint ret;\n\n\tret = tsl2563_set_power(chip, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tsl2563_get_power(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? 0 : -ENODEV;\n}\n\nstatic int tsl2563_read_id(struct tsl2563_chip *chip, u8 *id)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, TSL2563_CMD | TSL2563_REG_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*id = ret;\n\n\treturn 0;\n}\n\nstatic int tsl2563_configure_irq(struct tsl2563_chip *chip, bool enable)\n{\n\tint ret;\n\n\tchip->intr &= ~TSL2563_INT_MASK;\n\tif (enable)\n\t\tchip->intr |= TSL2563_INT_LEVEL;\n\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2563_CMD | TSL2563_REG_INT,\n\t\t\t\t\tchip->intr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->int_enabled = enable;\n\treturn 0;\n}\n\n \nstatic int tsl2563_adc_shiftbits(u8 timing)\n{\n\tint shift = 0;\n\n\tswitch (timing & TSL2563_TIMING_MASK) {\n\tcase TSL2563_TIMING_13MS:\n\t\tshift += 5;\n\t\tbreak;\n\tcase TSL2563_TIMING_100MS:\n\t\tshift += 2;\n\t\tbreak;\n\tcase TSL2563_TIMING_400MS:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!(timing & TSL2563_TIMING_GAIN16))\n\t\tshift += 4;\n\n\treturn shift;\n}\n\n \nstatic u32 tsl2563_normalize_adc(u16 adc, u8 timing)\n{\n\treturn adc << tsl2563_adc_shiftbits(timing);\n}\n\nstatic void tsl2563_wait_adc(struct tsl2563_chip *chip)\n{\n\tunsigned int delay;\n\n\tswitch (chip->gainlevel->gaintime & TSL2563_TIMING_MASK) {\n\tcase TSL2563_TIMING_13MS:\n\t\tdelay = 14;\n\t\tbreak;\n\tcase TSL2563_TIMING_100MS:\n\t\tdelay = 101;\n\t\tbreak;\n\tdefault:\n\t\tdelay = 402;\n\t}\n\t \n\tschedule_timeout_interruptible(msecs_to_jiffies(delay) + 2);\n}\n\nstatic int tsl2563_adjust_gainlevel(struct tsl2563_chip *chip, u16 adc)\n{\n\tstruct i2c_client *client = chip->client;\n\n\tif (adc > chip->gainlevel->max || adc < chip->gainlevel->min) {\n\n\t\t(adc > chip->gainlevel->max) ?\n\t\t\tchip->gainlevel++ : chip->gainlevel--;\n\n\t\ti2c_smbus_write_byte_data(client,\n\t\t\t\t\t  TSL2563_CMD | TSL2563_REG_TIMING,\n\t\t\t\t\t  chip->gainlevel->gaintime);\n\n\t\ttsl2563_wait_adc(chip);\n\t\ttsl2563_wait_adc(chip);\n\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int tsl2563_get_adc(struct tsl2563_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\tu16 adc0, adc1;\n\tint retry = 1;\n\tint ret = 0;\n\n\tif (chip->suspended)\n\t\tgoto out;\n\n\tif (!chip->int_enabled) {\n\t\tcancel_delayed_work_sync(&chip->poweroff_work);\n\n\t\tif (!tsl2563_get_power(chip)) {\n\t\t\tret = tsl2563_set_power(chip, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = tsl2563_configure(chip);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\ttsl2563_wait_adc(chip);\n\t\t}\n\t}\n\n\twhile (retry) {\n\t\tret = i2c_smbus_read_word_data(client,\n\t\t\t\tTSL2563_CMD | TSL2563_REG_DATA0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tadc0 = ret;\n\n\t\tret = i2c_smbus_read_word_data(client,\n\t\t\t\tTSL2563_CMD | TSL2563_REG_DATA1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tadc1 = ret;\n\n\t\tretry = tsl2563_adjust_gainlevel(chip, adc0);\n\t}\n\n\tchip->data0 = tsl2563_normalize_adc(adc0, chip->gainlevel->gaintime);\n\tchip->data1 = tsl2563_normalize_adc(adc1, chip->gainlevel->gaintime);\n\n\tif (!chip->int_enabled)\n\t\tschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic inline int tsl2563_calib_to_sysfs(u32 calib)\n{\n\treturn (int)DIV_ROUND_CLOSEST(calib * CALIB_BASE_SYSFS, BIT(CALIB_FRAC_BITS));\n}\n\nstatic inline u32 tsl2563_calib_from_sysfs(int value)\n{\n\t \n\treturn (((u32) value) << CALIB_FRAC_BITS) / CALIB_BASE_SYSFS;\n}\n\n \n\nstruct tsl2563_lux_coeff {\n\tunsigned long ch_ratio;\n\tunsigned long ch0_coeff;\n\tunsigned long ch1_coeff;\n};\n\nstatic const struct tsl2563_lux_coeff lux_table[] = {\n\t{\n\t\t.ch_ratio\t= FRAC10K(1300),\n\t\t.ch0_coeff\t= FRAC10K(315),\n\t\t.ch1_coeff\t= FRAC10K(262),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(2600),\n\t\t.ch0_coeff\t= FRAC10K(337),\n\t\t.ch1_coeff\t= FRAC10K(430),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(3900),\n\t\t.ch0_coeff\t= FRAC10K(363),\n\t\t.ch1_coeff\t= FRAC10K(529),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(5200),\n\t\t.ch0_coeff\t= FRAC10K(392),\n\t\t.ch1_coeff\t= FRAC10K(605),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(6500),\n\t\t.ch0_coeff\t= FRAC10K(229),\n\t\t.ch1_coeff\t= FRAC10K(291),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(8000),\n\t\t.ch0_coeff\t= FRAC10K(157),\n\t\t.ch1_coeff\t= FRAC10K(180),\n\t}, {\n\t\t.ch_ratio\t= FRAC10K(13000),\n\t\t.ch0_coeff\t= FRAC10K(34),\n\t\t.ch1_coeff\t= FRAC10K(26),\n\t}, {\n\t\t.ch_ratio\t= ULONG_MAX,\n\t\t.ch0_coeff\t= 0,\n\t\t.ch1_coeff\t= 0,\n\t},\n};\n\n \nstatic unsigned int tsl2563_adc_to_lux(u32 adc0, u32 adc1)\n{\n\tconst struct tsl2563_lux_coeff *lp = lux_table;\n\tunsigned long ratio, lux, ch0 = adc0, ch1 = adc1;\n\n\tratio = ch0 ? ((ch1 << ADC_FRAC_BITS) / ch0) : ULONG_MAX;\n\n\twhile (lp->ch_ratio < ratio)\n\t\tlp++;\n\n\tlux = ch0 * lp->ch0_coeff - ch1 * lp->ch1_coeff;\n\n\treturn (unsigned int) (lux >> ADC_FRAC_BITS);\n}\n\n \nstatic u32 tsl2563_calib_adc(u32 adc, u32 calib)\n{\n\tunsigned long scaled = adc;\n\n\tscaled *= calib;\n\tscaled >>= CALIB_FRAC_BITS;\n\n\treturn (u32) scaled;\n}\n\nstatic int tsl2563_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\n\tif (mask != IIO_CHAN_INFO_CALIBSCALE)\n\t\treturn -EINVAL;\n\tif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\n\t\tchip->calib0 = tsl2563_calib_from_sysfs(val);\n\telse if (chan->channel2 == IIO_MOD_LIGHT_IR)\n\t\tchip->calib1 = tsl2563_calib_from_sysfs(val);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tsl2563_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long mask)\n{\n\tint ret = -EINVAL;\n\tu32 calib0, calib1;\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\n\tmutex_lock(&chip->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = tsl2563_get_adc(chip);\n\t\t\tif (ret)\n\t\t\t\tgoto error_ret;\n\t\t\tcalib0 = tsl2563_calib_adc(chip->data0, chip->calib0) *\n\t\t\t\tchip->cover_comp_gain;\n\t\t\tcalib1 = tsl2563_calib_adc(chip->data1, chip->calib1) *\n\t\t\t\tchip->cover_comp_gain;\n\t\t\t*val = tsl2563_adc_to_lux(calib0, calib1);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_INTENSITY:\n\t\t\tret = tsl2563_get_adc(chip);\n\t\t\tif (ret)\n\t\t\t\tgoto error_ret;\n\t\t\tif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\n\t\t\t\t*val = chip->data0;\n\t\t\telse\n\t\t\t\t*val = chip->data1;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\n\t\t\t*val = tsl2563_calib_to_sysfs(chip->calib0);\n\t\telse\n\t\t\t*val = tsl2563_calib_to_sysfs(chip->calib1);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error_ret;\n\t}\n\nerror_ret:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic const struct iio_event_spec tsl2563_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec tsl2563_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.indexed = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.channel = 0,\n\t}, {\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t.event_spec = tsl2563_events,\n\t\t.num_event_specs = ARRAY_SIZE(tsl2563_events),\n\t}, {\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t}\n};\n\nstatic int tsl2563_read_thresh(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int *val,\n\tint *val2)\n{\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\t*val = chip->high_thres;\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\t*val = chip->low_thres;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int tsl2563_write_thresh(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\tint val2)\n{\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tif (dir == IIO_EV_DIR_RISING)\n\t\tret = i2c_smbus_write_word_data(chip->client,\n\t\t\t\t\t\tTSL2563_CMD | TSL2563_REG_HIGH, val);\n\telse\n\t\tret = i2c_smbus_write_word_data(chip->client,\n\t\t\t\t\t\tTSL2563_CMD | TSL2563_REG_LOW, val);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tif (dir == IIO_EV_DIR_RISING)\n\t\tchip->high_thres = val;\n\telse\n\t\tchip->low_thres = val;\n\nerror_ret:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t tsl2563_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *dev_info = private;\n\tstruct tsl2563_chip *chip = iio_priv(dev_info);\n\n\tiio_push_event(dev_info,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY,\n\t\t\t\t\t    0,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t       iio_get_time_ns(dev_info));\n\n\t \n\ti2c_smbus_write_byte(chip->client, TSL2563_CMD | TSL2563_CLEARINT);\n\treturn IRQ_HANDLED;\n}\n\nstatic int tsl2563_write_interrupt_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, int state)\n{\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tif (state && !(chip->intr & TSL2563_INT_MASK)) {\n\t\t \n\t\tcancel_delayed_work_sync(&chip->poweroff_work);\n\t\tif (!tsl2563_get_power(chip)) {\n\t\t\tret = tsl2563_set_power(chip, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = tsl2563_configure(chip);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = tsl2563_configure_irq(chip, true);\n\t}\n\n\tif (!state && (chip->intr & TSL2563_INT_MASK)) {\n\t\tret = tsl2563_configure_irq(chip, false);\n\t\t \n\t\tschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\n\t}\nout:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int tsl2563_read_interrupt_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir)\n{\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2563_CMD | TSL2563_REG_INT);\n\tmutex_unlock(&chip->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & TSL2563_INT_MASK);\n}\n\nstatic const struct iio_info tsl2563_info_no_irq = {\n\t.read_raw = &tsl2563_read_raw,\n\t.write_raw = &tsl2563_write_raw,\n};\n\nstatic const struct iio_info tsl2563_info = {\n\t.read_raw = &tsl2563_read_raw,\n\t.write_raw = &tsl2563_write_raw,\n\t.read_event_value = &tsl2563_read_thresh,\n\t.write_event_value = &tsl2563_write_thresh,\n\t.read_event_config = &tsl2563_read_interrupt_config,\n\t.write_event_config = &tsl2563_write_interrupt_config,\n};\n\nstatic int tsl2563_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct tsl2563_chip *chip;\n\tunsigned long irq_flags;\n\tu8 id = 0;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tchip->client = client;\n\n\terr = tsl2563_detect(chip);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"detect error\\n\");\n\n\terr = tsl2563_read_id(chip, &id);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"read id error\\n\");\n\n\tmutex_init(&chip->lock);\n\n\t \n\tchip->low_thres = 0x0;\n\tchip->high_thres = 0xffff;\n\tchip->gainlevel = tsl2563_gainlevel_table;\n\tchip->intr = TSL2563_INT_PERSIST(4);\n\tchip->calib0 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);\n\tchip->calib1 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);\n\n\tchip->cover_comp_gain = 1;\n\tdevice_property_read_u32(dev, \"amstaos,cover-comp-gain\", &chip->cover_comp_gain);\n\n\tdev_info(dev, \"model %d, rev. %d\\n\", id >> 4, id & 0x0f);\n\tindio_dev->name = client->name;\n\tindio_dev->channels = tsl2563_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsl2563_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (client->irq)\n\t\tindio_dev->info = &tsl2563_info;\n\telse\n\t\tindio_dev->info = &tsl2563_info_no_irq;\n\n\tif (client->irq) {\n\t\tirq_flags = irq_get_trigger_type(client->irq);\n\t\tif (irq_flags == IRQF_TRIGGER_NONE)\n\t\t\tirq_flags = IRQF_TRIGGER_RISING;\n\t\tirq_flags |= IRQF_ONESHOT;\n\n\t\terr = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   &tsl2563_event_handler,\n\t\t\t\t\t   irq_flags,\n\t\t\t\t\t   \"tsl2563_event\",\n\t\t\t\t\t   indio_dev);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err, \"irq request error\\n\");\n\t}\n\n\terr = tsl2563_configure(chip);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"configure error\\n\");\n\n\tINIT_DELAYED_WORK(&chip->poweroff_work, tsl2563_poweroff_work);\n\n\t \n\tschedule_delayed_work(&chip->poweroff_work, 5 * HZ);\n\n\terr = iio_device_register(indio_dev);\n\tif (err) {\n\t\tdev_err_probe(dev, err, \"iio registration error\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tcancel_delayed_work_sync(&chip->poweroff_work);\n\treturn err;\n}\n\nstatic void tsl2563_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tif (!chip->int_enabled)\n\t\tcancel_delayed_work_sync(&chip->poweroff_work);\n\t \n\ttsl2563_configure_irq(chip, false);\n\ttsl2563_set_power(chip, 0);\n}\n\nstatic int tsl2563_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = tsl2563_set_power(chip, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tchip->suspended = true;\n\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic int tsl2563_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2563_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = tsl2563_set_power(chip, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tsl2563_configure(chip);\n\tif (ret)\n\t\tgoto out;\n\n\tchip->suspended = false;\n\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tsl2563_pm_ops, tsl2563_suspend,\n\t\t\t\ttsl2563_resume);\n\nstatic const struct i2c_device_id tsl2563_id[] = {\n\t{ \"tsl2560\", 0 },\n\t{ \"tsl2561\", 1 },\n\t{ \"tsl2562\", 2 },\n\t{ \"tsl2563\", 3 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tsl2563_id);\n\nstatic const struct of_device_id tsl2563_of_match[] = {\n\t{ .compatible = \"amstaos,tsl2560\" },\n\t{ .compatible = \"amstaos,tsl2561\" },\n\t{ .compatible = \"amstaos,tsl2562\" },\n\t{ .compatible = \"amstaos,tsl2563\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tsl2563_of_match);\n\nstatic struct i2c_driver tsl2563_i2c_driver = {\n\t.driver = {\n\t\t.name\t = \"tsl2563\",\n\t\t.of_match_table = tsl2563_of_match,\n\t\t.pm\t= pm_sleep_ptr(&tsl2563_pm_ops),\n\t},\n\t.probe\t\t= tsl2563_probe,\n\t.remove\t\t= tsl2563_remove,\n\t.id_table\t= tsl2563_id,\n};\nmodule_i2c_driver(tsl2563_i2c_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"tsl2563 light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}