{
  "module_name": "tsl2772.c",
  "hash_id": "593ce55bd8e8db0de47164682afb9f7b74e556e342880cf5536670c25cd58e3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tsl2772.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/platform_data/tsl2772.h>\n#include <linux/regulator/consumer.h>\n\n \n#define PROX_STAT_CAL\t\t\t0\n#define PROX_STAT_SAMP\t\t\t1\n#define MAX_SAMPLES_CAL\t\t\t200\n\n \n#define TRITON_ID\t\t\t0x00\n#define SWORDFISH_ID\t\t\t0x30\n#define HALIBUT_ID\t\t\t0x20\n\n \n#define TSL2772_LUX_CALC_OVER_FLOW\t65535\n\n \n\n \n#define TSL2772_MAX_CONFIG_REG\t\t16\n\n \n#define TSL2772_CNTRL\t\t\t0x00\n#define TSL2772_ALS_TIME\t\t0X01\n#define TSL2772_PRX_TIME\t\t0x02\n#define TSL2772_WAIT_TIME\t\t0x03\n#define TSL2772_ALS_MINTHRESHLO\t\t0X04\n#define TSL2772_ALS_MINTHRESHHI\t\t0X05\n#define TSL2772_ALS_MAXTHRESHLO\t\t0X06\n#define TSL2772_ALS_MAXTHRESHHI\t\t0X07\n#define TSL2772_PRX_MINTHRESHLO\t\t0X08\n#define TSL2772_PRX_MINTHRESHHI\t\t0X09\n#define TSL2772_PRX_MAXTHRESHLO\t\t0X0A\n#define TSL2772_PRX_MAXTHRESHHI\t\t0X0B\n#define TSL2772_PERSISTENCE\t\t0x0C\n#define TSL2772_ALS_PRX_CONFIG\t\t0x0D\n#define TSL2772_PRX_COUNT\t\t0x0E\n#define TSL2772_GAIN\t\t\t0x0F\n#define TSL2772_NOTUSED\t\t\t0x10\n#define TSL2772_REVID\t\t\t0x11\n#define TSL2772_CHIPID\t\t\t0x12\n#define TSL2772_STATUS\t\t\t0x13\n#define TSL2772_ALS_CHAN0LO\t\t0x14\n#define TSL2772_ALS_CHAN0HI\t\t0x15\n#define TSL2772_ALS_CHAN1LO\t\t0x16\n#define TSL2772_ALS_CHAN1HI\t\t0x17\n#define TSL2772_PRX_LO\t\t\t0x18\n#define TSL2772_PRX_HI\t\t\t0x19\n\n \n#define TSL2772_CMD_REG\t\t\t0x80\n#define TSL2772_CMD_SPL_FN\t\t0x60\n#define TSL2772_CMD_REPEAT_PROTO\t0x00\n#define TSL2772_CMD_AUTOINC_PROTO\t0x20\n\n#define TSL2772_CMD_PROX_INT_CLR\t0X05\n#define TSL2772_CMD_ALS_INT_CLR\t\t0x06\n#define TSL2772_CMD_PROXALS_INT_CLR\t0X07\n\n \n#define TSL2772_CNTL_ADC_ENBL\t\t0x02\n#define TSL2772_CNTL_PWR_ON\t\t0x01\n\n \n#define TSL2772_STA_ADC_VALID\t\t0x01\n#define TSL2772_STA_PRX_VALID\t\t0x02\n#define TSL2772_STA_ADC_PRX_VALID\t(TSL2772_STA_ADC_VALID | \\\n\t\t\t\t\t TSL2772_STA_PRX_VALID)\n#define TSL2772_STA_ALS_INTR\t\t0x10\n#define TSL2772_STA_PRX_INTR\t\t0x20\n\n \n#define TSL2772_CNTL_REG_CLEAR\t\t0x00\n#define TSL2772_CNTL_PROX_INT_ENBL\t0X20\n#define TSL2772_CNTL_ALS_INT_ENBL\t0X10\n#define TSL2772_CNTL_WAIT_TMR_ENBL\t0X08\n#define TSL2772_CNTL_PROX_DET_ENBL\t0X04\n#define TSL2772_CNTL_PWRON\t\t0x01\n#define TSL2772_CNTL_ALSPON_ENBL\t0x03\n#define TSL2772_CNTL_INTALSPON_ENBL\t0x13\n#define TSL2772_CNTL_PROXPON_ENBL\t0x0F\n#define TSL2772_CNTL_INTPROXPON_ENBL\t0x2F\n\n#define TSL2772_ALS_GAIN_TRIM_MIN\t250\n#define TSL2772_ALS_GAIN_TRIM_MAX\t4000\n\n#define TSL2772_MAX_PROX_LEDS\t\t2\n\n#define TSL2772_BOOT_MIN_SLEEP_TIME\t10000\n#define TSL2772_BOOT_MAX_SLEEP_TIME\t28000\n\n \nenum {\n\ttsl2571,\n\ttsl2671,\n\ttmd2671,\n\ttsl2771,\n\ttmd2771,\n\ttsl2572,\n\ttsl2672,\n\ttmd2672,\n\ttsl2772,\n\ttmd2772,\n\tapds9930,\n};\n\nenum {\n\tTSL2772_CHIP_UNKNOWN = 0,\n\tTSL2772_CHIP_WORKING = 1,\n\tTSL2772_CHIP_SUSPENDED = 2\n};\n\nenum {\n\tTSL2772_SUPPLY_VDD = 0,\n\tTSL2772_SUPPLY_VDDIO = 1,\n\tTSL2772_NUM_SUPPLIES = 2\n};\n\n \nstruct tsl2772_als_info {\n\tu16 als_ch0;\n\tu16 als_ch1;\n\tu16 lux;\n};\n\nstruct tsl2772_chip_info {\n\tint chan_table_elements;\n\tstruct iio_chan_spec channel_with_events[4];\n\tstruct iio_chan_spec channel_without_events[4];\n\tconst struct iio_info *info;\n};\n\nstatic const int tsl2772_led_currents[][2] = {\n\t{ 100000, TSL2772_100_mA },\n\t{  50000, TSL2772_50_mA },\n\t{  25000, TSL2772_25_mA },\n\t{  13000, TSL2772_13_mA },\n\t{      0, 0 }\n};\n\nstruct tsl2772_chip {\n\tkernel_ulong_t id;\n\tstruct mutex prox_mutex;\n\tstruct mutex als_mutex;\n\tstruct i2c_client *client;\n\tstruct regulator_bulk_data supplies[TSL2772_NUM_SUPPLIES];\n\tu16 prox_data;\n\tstruct tsl2772_als_info als_cur_info;\n\tstruct tsl2772_settings settings;\n\tstruct tsl2772_platform_data *pdata;\n\tint als_gain_time_scale;\n\tint als_saturation;\n\tint tsl2772_chip_status;\n\tu8 tsl2772_config[TSL2772_MAX_CONFIG_REG];\n\tconst struct tsl2772_chip_info\t*chip_info;\n\tconst struct iio_info *info;\n\ts64 event_timestamp;\n\t \n\tstruct tsl2772_lux tsl2772_device_lux[TSL2772_MAX_LUX_TABLE_SIZE];\n};\n\n \nstatic const struct tsl2772_lux tsl2x71_lux_table[TSL2772_DEF_LUX_TABLE_SZ] = {\n\t{ 53000, 106000 },\n\t{ 31800,  53000 },\n\t{ 0,          0 },\n};\n\nstatic const struct tsl2772_lux tmd2x71_lux_table[TSL2772_DEF_LUX_TABLE_SZ] = {\n\t{ 24000,  48000 },\n\t{ 14400,  24000 },\n\t{ 0,          0 },\n};\n\nstatic const struct tsl2772_lux tsl2x72_lux_table[TSL2772_DEF_LUX_TABLE_SZ] = {\n\t{ 60000, 112200 },\n\t{ 37800,  60000 },\n\t{     0,      0 },\n};\n\nstatic const struct tsl2772_lux tmd2x72_lux_table[TSL2772_DEF_LUX_TABLE_SZ] = {\n\t{ 20000,  35000 },\n\t{ 12600,  20000 },\n\t{     0,      0 },\n};\n\nstatic const struct tsl2772_lux apds9930_lux_table[TSL2772_DEF_LUX_TABLE_SZ] = {\n\t{ 52000,  96824 },\n\t{ 38792,  67132 },\n\t{     0,      0 },\n};\n\nstatic const struct tsl2772_lux *tsl2772_default_lux_table_group[] = {\n\t[tsl2571] = tsl2x71_lux_table,\n\t[tsl2671] = tsl2x71_lux_table,\n\t[tmd2671] = tmd2x71_lux_table,\n\t[tsl2771] = tsl2x71_lux_table,\n\t[tmd2771] = tmd2x71_lux_table,\n\t[tsl2572] = tsl2x72_lux_table,\n\t[tsl2672] = tsl2x72_lux_table,\n\t[tmd2672] = tmd2x72_lux_table,\n\t[tsl2772] = tsl2x72_lux_table,\n\t[tmd2772] = tmd2x72_lux_table,\n\t[apds9930] = apds9930_lux_table,\n};\n\nstatic const struct tsl2772_settings tsl2772_default_settings = {\n\t.als_time = 255,  \n\t.als_gain = 0,\n\t.prox_time = 255,  \n\t.prox_gain = 0,\n\t.wait_time = 255,\n\t.als_prox_config = 0,\n\t.als_gain_trim = 1000,\n\t.als_cal_target = 150,\n\t.als_persistence = 1,\n\t.als_interrupt_en = false,\n\t.als_thresh_low = 200,\n\t.als_thresh_high = 256,\n\t.prox_persistence = 1,\n\t.prox_interrupt_en = false,\n\t.prox_thres_low  = 0,\n\t.prox_thres_high = 512,\n\t.prox_max_samples_cal = 30,\n\t.prox_pulse_count = 8,\n\t.prox_diode = TSL2772_DIODE1,\n\t.prox_power = TSL2772_100_mA\n};\n\nstatic const s16 tsl2772_als_gain[] = {\n\t1,\n\t8,\n\t16,\n\t120\n};\n\nstatic const s16 tsl2772_prox_gain[] = {\n\t1,\n\t2,\n\t4,\n\t8\n};\n\nstatic const int tsl2772_int_time_avail[][6] = {\n\t[tsl2571] = { 0, 2720, 0, 2720, 0, 696000 },\n\t[tsl2671] = { 0, 2720, 0, 2720, 0, 696000 },\n\t[tmd2671] = { 0, 2720, 0, 2720, 0, 696000 },\n\t[tsl2771] = { 0, 2720, 0, 2720, 0, 696000 },\n\t[tmd2771] = { 0, 2720, 0, 2720, 0, 696000 },\n\t[tsl2572] = { 0, 2730, 0, 2730, 0, 699000 },\n\t[tsl2672] = { 0, 2730, 0, 2730, 0, 699000 },\n\t[tmd2672] = { 0, 2730, 0, 2730, 0, 699000 },\n\t[tsl2772] = { 0, 2730, 0, 2730, 0, 699000 },\n\t[tmd2772] = { 0, 2730, 0, 2730, 0, 699000 },\n\t[apds9930] = { 0, 2730, 0, 2730, 0, 699000 },\n};\n\nstatic int tsl2772_int_calibscale_avail[] = { 1, 8, 16, 120 };\n\nstatic int tsl2772_prox_calibscale_avail[] = { 1, 2, 4, 8 };\n\n \nenum {\n\tALS,\n\tPRX,\n\tALSPRX,\n\tPRX2,\n\tALSPRX2,\n};\n\nstatic const u8 device_channel_config[] = {\n\t[tsl2571] = ALS,\n\t[tsl2671] = PRX,\n\t[tmd2671] = PRX,\n\t[tsl2771] = ALSPRX,\n\t[tmd2771] = ALSPRX,\n\t[tsl2572] = ALS,\n\t[tsl2672] = PRX2,\n\t[tmd2672] = PRX2,\n\t[tsl2772] = ALSPRX2,\n\t[tmd2772] = ALSPRX2,\n\t[apds9930] = ALSPRX2,\n};\n\nstatic int tsl2772_read_status(struct tsl2772_chip *chip)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2772_CMD_REG | TSL2772_STATUS);\n\tif (ret < 0)\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to read STATUS register: %d\\n\", __func__,\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int tsl2772_write_control_reg(struct tsl2772_chip *chip, u8 data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2772_CMD_REG | TSL2772_CNTRL, data);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to write to control register %x: %d\\n\",\n\t\t\t__func__, data, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int tsl2772_read_autoinc_regs(struct tsl2772_chip *chip, int lower_reg,\n\t\t\t\t     int upper_reg)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tret = i2c_smbus_write_byte(chip->client,\n\t\t\t\t   TSL2772_CMD_REG | TSL2772_CMD_AUTOINC_PROTO |\n\t\t\t\t   lower_reg);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to enable auto increment protocol: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2772_CMD_REG | lower_reg);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to read from register %x: %d\\n\", __func__,\n\t\t\tlower_reg, ret);\n\t\treturn ret;\n\t}\n\tbuf[0] = ret;\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2772_CMD_REG | upper_reg);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to read from register %x: %d\\n\", __func__,\n\t\t\tupper_reg, ret);\n\t\treturn ret;\n\t}\n\tbuf[1] = ret;\n\n\tret = i2c_smbus_write_byte(chip->client,\n\t\t\t\t   TSL2772_CMD_REG | TSL2772_CMD_REPEAT_PROTO |\n\t\t\t\t   lower_reg);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to enable repeated byte protocol: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn le16_to_cpup((const __le16 *)&buf[0]);\n}\n\n \nstatic int tsl2772_get_lux(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tstruct tsl2772_lux *p;\n\tint max_lux, ret;\n\tbool overflow;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tif (chip->tsl2772_chip_status != TSL2772_CHIP_WORKING) {\n\t\tdev_err(&chip->client->dev, \"%s: device is not enabled\\n\",\n\t\t\t__func__);\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tret = tsl2772_read_status(chip);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tif (!(ret & TSL2772_STA_ADC_VALID)) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: data not valid yet\\n\", __func__);\n\t\tret = chip->als_cur_info.lux;  \n\t\tgoto out_unlock;\n\t}\n\n\tret = tsl2772_read_autoinc_regs(chip, TSL2772_ALS_CHAN0LO,\n\t\t\t\t\tTSL2772_ALS_CHAN0HI);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tchip->als_cur_info.als_ch0 = ret;\n\n\tret = tsl2772_read_autoinc_regs(chip, TSL2772_ALS_CHAN1LO,\n\t\t\t\t\tTSL2772_ALS_CHAN1HI);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tchip->als_cur_info.als_ch1 = ret;\n\n\tif (chip->als_cur_info.als_ch0 >= chip->als_saturation) {\n\t\tmax_lux = TSL2772_LUX_CALC_OVER_FLOW;\n\t\tgoto update_struct_with_max_lux;\n\t}\n\n\tif (!chip->als_cur_info.als_ch0) {\n\t\t \n\t\tret = chip->als_cur_info.lux;\n\t\tgoto out_unlock;\n\t}\n\n\tmax_lux = 0;\n\toverflow = false;\n\tfor (p = (struct tsl2772_lux *)chip->tsl2772_device_lux; p->ch0 != 0;\n\t     p++) {\n\t\tint lux;\n\n\t\tlux = ((chip->als_cur_info.als_ch0 * p->ch0) -\n\t\t       (chip->als_cur_info.als_ch1 * p->ch1)) /\n\t\t\tchip->als_gain_time_scale;\n\n\t\t \n\t\tlux = (lux * chip->settings.als_gain_trim) / 1000;\n\n\t\tif (lux > TSL2772_LUX_CALC_OVER_FLOW) {\n\t\t\toverflow = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmax_lux = max(max_lux, lux);\n\t}\n\n\tif (overflow && max_lux == 0)\n\t\tmax_lux = TSL2772_LUX_CALC_OVER_FLOW;\n\nupdate_struct_with_max_lux:\n\tchip->als_cur_info.lux = max_lux;\n\tret = max_lux;\n\nout_unlock:\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\n \nstatic int tsl2772_get_prox(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->prox_mutex);\n\n\tret = tsl2772_read_status(chip);\n\tif (ret < 0)\n\t\tgoto prox_poll_err;\n\n\tswitch (chip->id) {\n\tcase tsl2571:\n\tcase tsl2671:\n\tcase tmd2671:\n\tcase tsl2771:\n\tcase tmd2771:\n\t\tif (!(ret & TSL2772_STA_ADC_VALID)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto prox_poll_err;\n\t\t}\n\t\tbreak;\n\tcase tsl2572:\n\tcase tsl2672:\n\tcase tmd2672:\n\tcase tsl2772:\n\tcase tmd2772:\n\tcase apds9930:\n\t\tif (!(ret & TSL2772_STA_PRX_VALID)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto prox_poll_err;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = tsl2772_read_autoinc_regs(chip, TSL2772_PRX_LO, TSL2772_PRX_HI);\n\tif (ret < 0)\n\t\tgoto prox_poll_err;\n\tchip->prox_data = ret;\n\nprox_poll_err:\n\tmutex_unlock(&chip->prox_mutex);\n\n\treturn ret;\n}\n\nstatic int tsl2772_read_prox_led_current(struct tsl2772_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tint ret, tmp, i;\n\n\tret = device_property_read_u32(dev, \"led-max-microamp\", &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; tsl2772_led_currents[i][0] != 0; i++) {\n\t\tif (tmp == tsl2772_led_currents[i][0]) {\n\t\t\tchip->settings.prox_power = tsl2772_led_currents[i][1];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(dev, \"Invalid value %d for led-max-microamp\\n\", tmp);\n\n\treturn -EINVAL;\n}\n\nstatic int tsl2772_read_prox_diodes(struct tsl2772_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tint i, ret, num_leds, prox_diode_mask;\n\tu32 leds[TSL2772_MAX_PROX_LEDS];\n\n\tret = device_property_count_u32(dev, \"amstaos,proximity-diodes\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_leds = ret;\n\tif (num_leds > TSL2772_MAX_PROX_LEDS)\n\t\tnum_leds = TSL2772_MAX_PROX_LEDS;\n\n\tret = device_property_read_u32_array(dev, \"amstaos,proximity-diodes\", leds, num_leds);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Invalid value for amstaos,proximity-diodes: %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tprox_diode_mask = 0;\n\tfor (i = 0; i < num_leds; i++) {\n\t\tif (leds[i] == 0)\n\t\t\tprox_diode_mask |= TSL2772_DIODE0;\n\t\telse if (leds[i] == 1)\n\t\t\tprox_diode_mask |= TSL2772_DIODE1;\n\t\telse {\n\t\t\tdev_err(dev, \"Invalid value %d in amstaos,proximity-diodes.\\n\", leds[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tchip->settings.prox_diode = prox_diode_mask;\n\n\treturn 0;\n}\n\nstatic void tsl2772_parse_dt(struct tsl2772_chip *chip)\n{\n\ttsl2772_read_prox_led_current(chip);\n\ttsl2772_read_prox_diodes(chip);\n}\n\n \nstatic void tsl2772_defaults(struct tsl2772_chip *chip)\n{\n\t \n\tif (chip->pdata && chip->pdata->platform_default_settings)\n\t\tmemcpy(&chip->settings, chip->pdata->platform_default_settings,\n\t\t       sizeof(tsl2772_default_settings));\n\telse\n\t\tmemcpy(&chip->settings, &tsl2772_default_settings,\n\t\t       sizeof(tsl2772_default_settings));\n\n\t \n\tif (chip->pdata && chip->pdata->platform_lux_table[0].ch0 != 0)\n\t\tmemcpy(chip->tsl2772_device_lux,\n\t\t       chip->pdata->platform_lux_table,\n\t\t       sizeof(chip->pdata->platform_lux_table));\n\telse\n\t\tmemcpy(chip->tsl2772_device_lux,\n\t\t       tsl2772_default_lux_table_group[chip->id],\n\t\t       TSL2772_DEFAULT_TABLE_BYTES);\n\n\ttsl2772_parse_dt(chip);\n}\n\n \nstatic int tsl2772_als_calibrate(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret, lux_val;\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2772_CMD_REG | TSL2772_CNTRL);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to read from the CNTRL register\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((ret & (TSL2772_CNTL_ADC_ENBL | TSL2772_CNTL_PWR_ON))\n\t\t\t!= (TSL2772_CNTL_ADC_ENBL | TSL2772_CNTL_PWR_ON)) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: Device is not powered on and/or ADC is not enabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t} else if ((ret & TSL2772_STA_ADC_VALID) != TSL2772_STA_ADC_VALID) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: The two ADC channels have not completed an integration cycle\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\n\tlux_val = tsl2772_get_lux(indio_dev);\n\tif (lux_val < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to get lux\\n\", __func__);\n\t\treturn lux_val;\n\t}\n\tif (lux_val == 0)\n\t\treturn -ERANGE;\n\n\tret = (chip->settings.als_cal_target * chip->settings.als_gain_trim) /\n\t\t\tlux_val;\n\tif (ret < TSL2772_ALS_GAIN_TRIM_MIN || ret > TSL2772_ALS_GAIN_TRIM_MAX)\n\t\treturn -ERANGE;\n\n\tchip->settings.als_gain_trim = ret;\n\n\treturn ret;\n}\n\nstatic void tsl2772_disable_regulators_action(void *_data)\n{\n\tstruct tsl2772_chip *chip = _data;\n\n\tregulator_bulk_disable(ARRAY_SIZE(chip->supplies), chip->supplies);\n}\n\nstatic int tsl2772_chip_on(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret, i, als_count, als_time_us;\n\tu8 *dev_reg, reg_val;\n\n\t \n\tchip->tsl2772_config[TSL2772_ALS_TIME] = chip->settings.als_time;\n\tchip->tsl2772_config[TSL2772_PRX_TIME] = chip->settings.prox_time;\n\tchip->tsl2772_config[TSL2772_WAIT_TIME] = chip->settings.wait_time;\n\tchip->tsl2772_config[TSL2772_ALS_PRX_CONFIG] =\n\t\tchip->settings.als_prox_config;\n\n\tchip->tsl2772_config[TSL2772_ALS_MINTHRESHLO] =\n\t\t(chip->settings.als_thresh_low) & 0xFF;\n\tchip->tsl2772_config[TSL2772_ALS_MINTHRESHHI] =\n\t\t(chip->settings.als_thresh_low >> 8) & 0xFF;\n\tchip->tsl2772_config[TSL2772_ALS_MAXTHRESHLO] =\n\t\t(chip->settings.als_thresh_high) & 0xFF;\n\tchip->tsl2772_config[TSL2772_ALS_MAXTHRESHHI] =\n\t\t(chip->settings.als_thresh_high >> 8) & 0xFF;\n\tchip->tsl2772_config[TSL2772_PERSISTENCE] =\n\t\t(chip->settings.prox_persistence & 0xFF) << 4 |\n\t\t(chip->settings.als_persistence & 0xFF);\n\n\tchip->tsl2772_config[TSL2772_PRX_COUNT] =\n\t\t\tchip->settings.prox_pulse_count;\n\tchip->tsl2772_config[TSL2772_PRX_MINTHRESHLO] =\n\t\t\t(chip->settings.prox_thres_low) & 0xFF;\n\tchip->tsl2772_config[TSL2772_PRX_MINTHRESHHI] =\n\t\t\t(chip->settings.prox_thres_low >> 8) & 0xFF;\n\tchip->tsl2772_config[TSL2772_PRX_MAXTHRESHLO] =\n\t\t\t(chip->settings.prox_thres_high) & 0xFF;\n\tchip->tsl2772_config[TSL2772_PRX_MAXTHRESHHI] =\n\t\t\t(chip->settings.prox_thres_high >> 8) & 0xFF;\n\n\t \n\tif (chip->tsl2772_chip_status == TSL2772_CHIP_WORKING) {\n\t\t \n\t\tdev_info(&chip->client->dev, \"device is already enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tchip->tsl2772_config[TSL2772_GAIN] =\n\t\t(chip->settings.als_gain & 0xFF) |\n\t\t((chip->settings.prox_gain & 0xFF) << 2) |\n\t\t(chip->settings.prox_diode << 4) |\n\t\t(chip->settings.prox_power << 6);\n\n\t \n\tals_count = 256 - chip->settings.als_time;\n\tals_time_us = als_count * tsl2772_int_time_avail[chip->id][3];\n\tchip->als_saturation = als_count * 768;  \n\tchip->als_gain_time_scale = als_time_us *\n\t\ttsl2772_als_gain[chip->settings.als_gain];\n\n\t \n\tret = tsl2772_write_control_reg(chip, TSL2772_CNTL_PWR_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0, dev_reg = chip->tsl2772_config;\n\t\t\ti < TSL2772_MAX_CONFIG_REG; i++) {\n\t\tint reg = TSL2772_CMD_REG + i;\n\n\t\tret = i2c_smbus_write_byte_data(chip->client, reg,\n\t\t\t\t\t\t*dev_reg++);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&chip->client->dev,\n\t\t\t\t\"%s: failed to write to register %x: %d\\n\",\n\t\t\t\t__func__, reg, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tusleep_range(3000, 3500);\n\n\treg_val = TSL2772_CNTL_PWR_ON | TSL2772_CNTL_ADC_ENBL |\n\t\t  TSL2772_CNTL_PROX_DET_ENBL;\n\tif (chip->settings.als_interrupt_en)\n\t\treg_val |= TSL2772_CNTL_ALS_INT_ENBL;\n\tif (chip->settings.prox_interrupt_en)\n\t\treg_val |= TSL2772_CNTL_PROX_INT_ENBL;\n\n\tret = tsl2772_write_control_reg(chip, reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte(chip->client,\n\t\t\t\t   TSL2772_CMD_REG | TSL2772_CMD_SPL_FN |\n\t\t\t\t   TSL2772_CMD_PROXALS_INT_CLR);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to clear interrupt status: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tchip->tsl2772_chip_status = TSL2772_CHIP_WORKING;\n\n\treturn ret;\n}\n\nstatic int tsl2772_chip_off(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\t \n\tchip->tsl2772_chip_status = TSL2772_CHIP_SUSPENDED;\n\treturn tsl2772_write_control_reg(chip, 0x00);\n}\n\nstatic void tsl2772_chip_off_action(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\n\ttsl2772_chip_off(indio_dev);\n}\n\n \nstatic int tsl2772_invoke_change(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint device_status = chip->tsl2772_chip_status;\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\tmutex_lock(&chip->prox_mutex);\n\n\tif (device_status == TSL2772_CHIP_WORKING) {\n\t\tret = tsl2772_chip_off(indio_dev);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = tsl2772_chip_on(indio_dev);\n\nunlock:\n\tmutex_unlock(&chip->prox_mutex);\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic int tsl2772_prox_cal(struct iio_dev *indio_dev)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint prox_history[MAX_SAMPLES_CAL + 1];\n\tint i, ret, mean, max, sample_sum;\n\n\tif (chip->settings.prox_max_samples_cal < 1 ||\n\t    chip->settings.prox_max_samples_cal > MAX_SAMPLES_CAL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < chip->settings.prox_max_samples_cal; i++) {\n\t\tusleep_range(15000, 17500);\n\t\tret = tsl2772_get_prox(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tprox_history[i] = chip->prox_data;\n\t}\n\n\tsample_sum = 0;\n\tmax = INT_MIN;\n\tfor (i = 0; i < chip->settings.prox_max_samples_cal; i++) {\n\t\tsample_sum += prox_history[i];\n\t\tmax = max(max, prox_history[i]);\n\t}\n\tmean = sample_sum / chip->settings.prox_max_samples_cal;\n\n\tchip->settings.prox_thres_high = (max << 1) - mean;\n\n\treturn tsl2772_invoke_change(indio_dev);\n}\n\nstatic int tsl2772_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\t*length = ARRAY_SIZE(tsl2772_int_calibscale_avail);\n\t\t\t*vals = tsl2772_int_calibscale_avail;\n\t\t} else {\n\t\t\t*length = ARRAY_SIZE(tsl2772_prox_calibscale_avail);\n\t\t\t*vals = tsl2772_prox_calibscale_avail;\n\t\t}\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*length = ARRAY_SIZE(tsl2772_int_time_avail[chip->id]);\n\t\t*vals = tsl2772_int_time_avail[chip->id];\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_RANGE;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t in_illuminance0_target_input_show(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct tsl2772_chip *chip = iio_priv(dev_to_iio_dev(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", chip->settings.als_cal_target);\n}\n\nstatic ssize_t in_illuminance0_target_input_store(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tu16 value;\n\tint ret;\n\n\tif (kstrtou16(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tchip->settings.als_cal_target = value;\n\tret = tsl2772_invoke_change(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t in_illuminance0_calibrate_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tbool value;\n\tint ret;\n\n\tif (kstrtobool(buf, &value) || !value)\n\t\treturn -EINVAL;\n\n\tret = tsl2772_als_calibrate(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2772_invoke_change(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t in_illuminance0_lux_table_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct tsl2772_chip *chip = iio_priv(dev_to_iio_dev(dev));\n\tint i = 0;\n\tint offset = 0;\n\n\twhile (i < TSL2772_MAX_LUX_TABLE_SIZE) {\n\t\toffset += scnprintf(buf + offset, PAGE_SIZE - offset, \"%u,%u,\",\n\t\t\tchip->tsl2772_device_lux[i].ch0,\n\t\t\tchip->tsl2772_device_lux[i].ch1);\n\t\tif (chip->tsl2772_device_lux[i].ch0 == 0) {\n\t\t\t \n\t\t\toffset--;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\toffset += scnprintf(buf + offset, PAGE_SIZE - offset, \"\\n\");\n\treturn offset;\n}\n\nstatic ssize_t in_illuminance0_lux_table_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint value[ARRAY_SIZE(chip->tsl2772_device_lux) * 2 + 1];\n\tint n, ret;\n\n\tget_options(buf, ARRAY_SIZE(value), value);\n\n\t \n\tn = value[0];\n\tif ((n % 2) || n < 4 ||\n\t    n > ((ARRAY_SIZE(chip->tsl2772_device_lux) - 1) * 2))\n\t\treturn -EINVAL;\n\n\tif ((value[(n - 1)] | value[n]) != 0)\n\t\treturn -EINVAL;\n\n\tif (chip->tsl2772_chip_status == TSL2772_CHIP_WORKING) {\n\t\tret = tsl2772_chip_off(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmemset(chip->tsl2772_device_lux, 0, sizeof(chip->tsl2772_device_lux));\n\tmemcpy(chip->tsl2772_device_lux, &value[1], (value[0] * 4));\n\n\tret = tsl2772_invoke_change(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t in_proximity0_calibrate_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tbool value;\n\tint ret;\n\n\tif (kstrtobool(buf, &value) || !value)\n\t\treturn -EINVAL;\n\n\tret = tsl2772_prox_cal(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2772_invoke_change(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic int tsl2772_read_interrupt_config(struct iio_dev *indio_dev,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_type type,\n\t\t\t\t\t enum iio_event_direction dir)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\tif (chan->type == IIO_INTENSITY)\n\t\treturn chip->settings.als_interrupt_en;\n\telse\n\t\treturn chip->settings.prox_interrupt_en;\n}\n\nstatic int tsl2772_write_interrupt_config(struct iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t\t  int val)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\tif (chan->type == IIO_INTENSITY)\n\t\tchip->settings.als_interrupt_en = val ? true : false;\n\telse\n\t\tchip->settings.prox_interrupt_en = val ? true : false;\n\n\treturn tsl2772_invoke_change(indio_dev);\n}\n\nstatic int tsl2772_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int val, int val2)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret = -EINVAL, count, persistence;\n\tu8 time;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tchip->settings.als_thresh_high = val;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tchip->settings.als_thresh_low = val;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tchip->settings.prox_thres_high = val;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tchip->settings.prox_thres_low = val;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tif (chan->type == IIO_INTENSITY)\n\t\t\ttime = chip->settings.als_time;\n\t\telse\n\t\t\ttime = chip->settings.prox_time;\n\n\t\tcount = 256 - time;\n\t\tpersistence = ((val * 1000000) + val2) /\n\t\t\t(count * tsl2772_int_time_avail[chip->id][3]);\n\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\t \n\t\t\tif (persistence > 3)\n\t\t\t\tpersistence = (persistence / 5) + 3;\n\n\t\t\tchip->settings.als_persistence = persistence;\n\t\t} else {\n\t\t\tchip->settings.prox_persistence = persistence;\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tsl2772_invoke_change(indio_dev);\n}\n\nstatic int tsl2772_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int *val, int *val2)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint filter_delay, persistence;\n\tu8 time;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\t*val = chip->settings.als_thresh_high;\n\t\t\t\treturn IIO_VAL_INT;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\t*val = chip->settings.als_thresh_low;\n\t\t\t\treturn IIO_VAL_INT;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\t*val = chip->settings.prox_thres_high;\n\t\t\t\treturn IIO_VAL_INT;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\t*val = chip->settings.prox_thres_low;\n\t\t\t\treturn IIO_VAL_INT;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\ttime = chip->settings.als_time;\n\t\t\tpersistence = chip->settings.als_persistence;\n\n\t\t\t \n\t\t\tif (persistence > 3)\n\t\t\t\tpersistence = (persistence - 3) * 5;\n\t\t} else {\n\t\t\ttime = chip->settings.prox_time;\n\t\t\tpersistence = chip->settings.prox_persistence;\n\t\t}\n\n\t\tfilter_delay = persistence * (256 - time) *\n\t\t\ttsl2772_int_time_avail[chip->id][3];\n\n\t\t*val = filter_delay / 1000000;\n\t\t*val2 = filter_delay % 1000000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2772_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long mask)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\ttsl2772_get_lux(indio_dev);\n\t\t\t*val = chip->als_cur_info.lux;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INTENSITY:\n\t\t\ttsl2772_get_lux(indio_dev);\n\t\t\tif (chan->channel == 0)\n\t\t\t\t*val = chip->als_cur_info.als_ch0;\n\t\t\telse\n\t\t\t\t*val = chip->als_cur_info.als_ch1;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PROXIMITY:\n\t\t\ttsl2772_get_prox(indio_dev);\n\t\t\t*val = chip->prox_data;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_LIGHT)\n\t\t\t*val = tsl2772_als_gain[chip->settings.als_gain];\n\t\telse\n\t\t\t*val = tsl2772_prox_gain[chip->settings.prox_gain];\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*val = chip->settings.als_gain_trim;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = (256 - chip->settings.als_time) *\n\t\t\ttsl2772_int_time_avail[chip->id][3];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2772_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val,\n\t\t\t     int val2,\n\t\t\t     long mask)\n{\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_INTENSITY) {\n\t\t\tswitch (val) {\n\t\t\tcase 1:\n\t\t\t\tchip->settings.als_gain = 0;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tchip->settings.als_gain = 1;\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tchip->settings.als_gain = 2;\n\t\t\t\tbreak;\n\t\t\tcase 120:\n\t\t\t\tchip->settings.als_gain = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (val) {\n\t\t\tcase 1:\n\t\t\t\tchip->settings.prox_gain = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tchip->settings.prox_gain = 1;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tchip->settings.prox_gain = 2;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tchip->settings.prox_gain = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < TSL2772_ALS_GAIN_TRIM_MIN ||\n\t\t    val > TSL2772_ALS_GAIN_TRIM_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tchip->settings.als_gain_trim = val;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0 || val2 < tsl2772_int_time_avail[chip->id][1] ||\n\t\t    val2 > tsl2772_int_time_avail[chip->id][5])\n\t\t\treturn -EINVAL;\n\n\t\tchip->settings.als_time = 256 -\n\t\t\t(val2 / tsl2772_int_time_avail[chip->id][3]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn tsl2772_invoke_change(indio_dev);\n}\n\nstatic DEVICE_ATTR_RW(in_illuminance0_target_input);\n\nstatic DEVICE_ATTR_WO(in_illuminance0_calibrate);\n\nstatic DEVICE_ATTR_WO(in_proximity0_calibrate);\n\nstatic DEVICE_ATTR_RW(in_illuminance0_lux_table);\n\n \nstatic int tsl2772_device_id_verif(int id, int target)\n{\n\tswitch (target) {\n\tcase tsl2571:\n\tcase tsl2671:\n\tcase tsl2771:\n\t\treturn (id & 0xf0) == TRITON_ID;\n\tcase tmd2671:\n\tcase tmd2771:\n\t\treturn (id & 0xf0) == HALIBUT_ID;\n\tcase tsl2572:\n\tcase tsl2672:\n\tcase tmd2672:\n\tcase tsl2772:\n\tcase tmd2772:\n\tcase apds9930:\n\t\treturn (id & 0xf0) == SWORDFISH_ID;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t tsl2772_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\ts64 timestamp = iio_get_time_ns(indio_dev);\n\tint ret;\n\n\tret = tsl2772_read_status(chip);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (ret & TSL2772_STA_PRX_INTR) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       timestamp);\n\t}\n\n\tif (ret & TSL2772_STA_ALS_INTR) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       timestamp);\n\t}\n\n\tret = i2c_smbus_write_byte(chip->client,\n\t\t\t\t   TSL2772_CMD_REG | TSL2772_CMD_SPL_FN |\n\t\t\t\t   TSL2772_CMD_PROXALS_INT_CLR);\n\tif (ret < 0)\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to clear interrupt status: %d\\n\",\n\t\t\t__func__, ret);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct attribute *tsl2772_ALS_device_attrs[] = {\n\t&dev_attr_in_illuminance0_target_input.attr,\n\t&dev_attr_in_illuminance0_calibrate.attr,\n\t&dev_attr_in_illuminance0_lux_table.attr,\n\tNULL\n};\n\nstatic struct attribute *tsl2772_PRX_device_attrs[] = {\n\t&dev_attr_in_proximity0_calibrate.attr,\n\tNULL\n};\n\nstatic struct attribute *tsl2772_ALSPRX_device_attrs[] = {\n\t&dev_attr_in_illuminance0_target_input.attr,\n\t&dev_attr_in_illuminance0_calibrate.attr,\n\t&dev_attr_in_illuminance0_lux_table.attr,\n\tNULL\n};\n\nstatic struct attribute *tsl2772_PRX2_device_attrs[] = {\n\t&dev_attr_in_proximity0_calibrate.attr,\n\tNULL\n};\n\nstatic struct attribute *tsl2772_ALSPRX2_device_attrs[] = {\n\t&dev_attr_in_illuminance0_target_input.attr,\n\t&dev_attr_in_illuminance0_calibrate.attr,\n\t&dev_attr_in_illuminance0_lux_table.attr,\n\t&dev_attr_in_proximity0_calibrate.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tsl2772_device_attr_group_tbl[] = {\n\t[ALS] = {\n\t\t.attrs = tsl2772_ALS_device_attrs,\n\t},\n\t[PRX] = {\n\t\t.attrs = tsl2772_PRX_device_attrs,\n\t},\n\t[ALSPRX] = {\n\t\t.attrs = tsl2772_ALSPRX_device_attrs,\n\t},\n\t[PRX2] = {\n\t\t.attrs = tsl2772_PRX2_device_attrs,\n\t},\n\t[ALSPRX2] = {\n\t\t.attrs = tsl2772_ALSPRX2_device_attrs,\n\t},\n};\n\n#define TSL2772_DEVICE_INFO(type)[type] = \\\n\t{ \\\n\t\t.attrs = &tsl2772_device_attr_group_tbl[type], \\\n\t\t.read_raw = &tsl2772_read_raw, \\\n\t\t.read_avail = &tsl2772_read_avail, \\\n\t\t.write_raw = &tsl2772_write_raw, \\\n\t\t.read_event_value = &tsl2772_read_event_value, \\\n\t\t.write_event_value = &tsl2772_write_event_value, \\\n\t\t.read_event_config = &tsl2772_read_interrupt_config, \\\n\t\t.write_event_config = &tsl2772_write_interrupt_config, \\\n\t}\n\nstatic const struct iio_info tsl2772_device_info[] = {\n\tTSL2772_DEVICE_INFO(ALS),\n\tTSL2772_DEVICE_INFO(PRX),\n\tTSL2772_DEVICE_INFO(ALSPRX),\n\tTSL2772_DEVICE_INFO(PRX2),\n\tTSL2772_DEVICE_INFO(ALSPRX2),\n};\n\nstatic const struct iio_event_spec tsl2772_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_PERIOD) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct tsl2772_chip_info tsl2772_chip_info_tbl[] = {\n\t[ALS] = {\n\t\t.channel_with_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t},\n\t\t},\n\t\t.channel_without_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t},\n\t\t},\n\t\t.chan_table_elements = 3,\n\t\t.info = &tsl2772_device_info[ALS],\n\t},\n\t[PRX] = {\n\t\t.channel_with_events = {\n\t\t\t{\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t},\n\t\t},\n\t\t.channel_without_events = {\n\t\t\t{\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t},\n\t\t},\n\t\t.chan_table_elements = 1,\n\t\t.info = &tsl2772_device_info[PRX],\n\t},\n\t[ALSPRX] = {\n\t\t.channel_with_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t}, {\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t},\n\t\t},\n\t\t.channel_without_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t}, {\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t},\n\t\t},\n\t\t.chan_table_elements = 4,\n\t\t.info = &tsl2772_device_info[ALSPRX],\n\t},\n\t[PRX2] = {\n\t\t.channel_with_events = {\n\t\t\t{\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t},\n\t\t},\n\t\t.channel_without_events = {\n\t\t\t{\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t},\n\t\t},\n\t\t.chan_table_elements = 1,\n\t\t.info = &tsl2772_device_info[PRX2],\n\t},\n\t[ALSPRX2] = {\n\t\t.channel_with_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t}, {\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.event_spec = tsl2772_events,\n\t\t\t.num_event_specs = ARRAY_SIZE(tsl2772_events),\n\t\t\t},\n\t\t},\n\t\t.channel_without_events = {\n\t\t\t{\n\t\t\t.type = IIO_LIGHT,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t}, {\n\t\t\t.type = IIO_INTENSITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 1,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t\t}, {\n\t\t\t.type = IIO_PROXIMITY,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t.info_mask_separate_available =\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t\t},\n\t\t},\n\t\t.chan_table_elements = 4,\n\t\t.info = &tsl2772_device_info[ALSPRX2],\n\t},\n};\n\nstatic int tsl2772_probe(struct i2c_client *clientp)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(clientp);\n\tstruct iio_dev *indio_dev;\n\tstruct tsl2772_chip *chip;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&clientp->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tchip->client = clientp;\n\ti2c_set_clientdata(clientp, indio_dev);\n\n\tchip->supplies[TSL2772_SUPPLY_VDD].supply = \"vdd\";\n\tchip->supplies[TSL2772_SUPPLY_VDDIO].supply = \"vddio\";\n\n\tret = devm_regulator_bulk_get(&clientp->dev,\n\t\t\t\t      ARRAY_SIZE(chip->supplies),\n\t\t\t\t      chip->supplies);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&clientp->dev, ret, \"Failed to get regulators\\n\");\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(chip->supplies), chip->supplies);\n\tif (ret < 0) {\n\t\tdev_err(&clientp->dev, \"Failed to enable regulators: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&clientp->dev,\n\t\t\t\t\ttsl2772_disable_regulators_action,\n\t\t\t\t\tchip);\n\tif (ret < 0) {\n\t\tdev_err(&clientp->dev, \"Failed to setup regulator cleanup action %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(TSL2772_BOOT_MIN_SLEEP_TIME, TSL2772_BOOT_MAX_SLEEP_TIME);\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2772_CMD_REG | TSL2772_CHIPID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tsl2772_device_id_verif(ret, id->driver_data) <= 0) {\n\t\tdev_info(&chip->client->dev,\n\t\t\t \"%s: i2c device found does not match expected id\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_smbus_write_byte(clientp, TSL2772_CMD_REG | TSL2772_CNTRL);\n\tif (ret < 0) {\n\t\tdev_err(&clientp->dev,\n\t\t\t\"%s: Failed to write to CMD register: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&chip->als_mutex);\n\tmutex_init(&chip->prox_mutex);\n\n\tchip->tsl2772_chip_status = TSL2772_CHIP_UNKNOWN;\n\tchip->pdata = dev_get_platdata(&clientp->dev);\n\tchip->id = id->driver_data;\n\tchip->chip_info =\n\t\t&tsl2772_chip_info_tbl[device_channel_config[id->driver_data]];\n\n\tindio_dev->info = chip->chip_info->info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = chip->client->name;\n\tindio_dev->num_channels = chip->chip_info->chan_table_elements;\n\n\tif (clientp->irq) {\n\t\tindio_dev->channels = chip->chip_info->channel_with_events;\n\n\t\tret = devm_request_threaded_irq(&clientp->dev, clientp->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&tsl2772_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"TSL2772_event\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&clientp->dev,\n\t\t\t\t\"%s: irq request failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tindio_dev->channels = chip->chip_info->channel_without_events;\n\t}\n\n\ttsl2772_defaults(chip);\n\tret = tsl2772_chip_on(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&clientp->dev,\n\t\t\t\t\ttsl2772_chip_off_action,\n\t\t\t\t\tindio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&clientp->dev, indio_dev);\n}\n\nstatic int tsl2772_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tret = tsl2772_chip_off(indio_dev);\n\tregulator_bulk_disable(ARRAY_SIZE(chip->supplies), chip->supplies);\n\n\treturn ret;\n}\n\nstatic int tsl2772_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2772_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(chip->supplies), chip->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(TSL2772_BOOT_MIN_SLEEP_TIME, TSL2772_BOOT_MAX_SLEEP_TIME);\n\n\treturn tsl2772_chip_on(indio_dev);\n}\n\nstatic const struct i2c_device_id tsl2772_idtable[] = {\n\t{ \"tsl2571\", tsl2571 },\n\t{ \"tsl2671\", tsl2671 },\n\t{ \"tmd2671\", tmd2671 },\n\t{ \"tsl2771\", tsl2771 },\n\t{ \"tmd2771\", tmd2771 },\n\t{ \"tsl2572\", tsl2572 },\n\t{ \"tsl2672\", tsl2672 },\n\t{ \"tmd2672\", tmd2672 },\n\t{ \"tsl2772\", tsl2772 },\n\t{ \"tmd2772\", tmd2772 },\n\t{ \"apds9930\", apds9930 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, tsl2772_idtable);\n\nstatic const struct of_device_id tsl2772_of_match[] = {\n\t{ .compatible = \"amstaos,tsl2571\" },\n\t{ .compatible = \"amstaos,tsl2671\" },\n\t{ .compatible = \"amstaos,tmd2671\" },\n\t{ .compatible = \"amstaos,tsl2771\" },\n\t{ .compatible = \"amstaos,tmd2771\" },\n\t{ .compatible = \"amstaos,tsl2572\" },\n\t{ .compatible = \"amstaos,tsl2672\" },\n\t{ .compatible = \"amstaos,tmd2672\" },\n\t{ .compatible = \"amstaos,tsl2772\" },\n\t{ .compatible = \"amstaos,tmd2772\" },\n\t{ .compatible = \"avago,apds9930\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tsl2772_of_match);\n\nstatic const struct dev_pm_ops tsl2772_pm_ops = {\n\t.suspend = tsl2772_suspend,\n\t.resume  = tsl2772_resume,\n};\n\nstatic struct i2c_driver tsl2772_driver = {\n\t.driver = {\n\t\t.name = \"tsl2772\",\n\t\t.of_match_table = tsl2772_of_match,\n\t\t.pm = &tsl2772_pm_ops,\n\t},\n\t.id_table = tsl2772_idtable,\n\t.probe = tsl2772_probe,\n};\n\nmodule_i2c_driver(tsl2772_driver);\n\nMODULE_AUTHOR(\"J. August Brenner <Jon.Brenner@ams.com>\");\nMODULE_AUTHOR(\"Brian Masney <masneyb@onstation.org>\");\nMODULE_DESCRIPTION(\"TAOS tsl2772 ambient and proximity light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}