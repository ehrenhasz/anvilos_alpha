{
  "module_name": "noa1305.c",
  "hash_id": "3375d814003ac445a1515fddf568a71fdc1d69afedde54d27e905631e37e5f7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/noa1305.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define NOA1305_REG_POWER_CONTROL\t0x0\n#define   NOA1305_POWER_CONTROL_DOWN\t0x00\n#define   NOA1305_POWER_CONTROL_ON\t0x08\n#define NOA1305_REG_RESET\t\t0x1\n#define   NOA1305_RESET_RESET\t\t0x10\n#define NOA1305_REG_INTEGRATION_TIME\t0x2\n#define   NOA1305_INTEGR_TIME_800MS\t0x00\n#define   NOA1305_INTEGR_TIME_400MS\t0x01\n#define   NOA1305_INTEGR_TIME_200MS\t0x02\n#define   NOA1305_INTEGR_TIME_100MS\t0x03\n#define   NOA1305_INTEGR_TIME_50MS\t0x04\n#define   NOA1305_INTEGR_TIME_25MS\t0x05\n#define   NOA1305_INTEGR_TIME_12_5MS\t0x06\n#define   NOA1305_INTEGR_TIME_6_25MS\t0x07\n#define NOA1305_REG_INT_SELECT\t\t0x3\n#define   NOA1305_INT_SEL_ACTIVE_HIGH\t0x01\n#define   NOA1305_INT_SEL_ACTIVE_LOW\t0x02\n#define   NOA1305_INT_SEL_INACTIVE\t0x03\n#define NOA1305_REG_INT_THRESH_LSB\t0x4\n#define NOA1305_REG_INT_THRESH_MSB\t0x5\n#define NOA1305_REG_ALS_DATA_LSB\t0x6\n#define NOA1305_REG_ALS_DATA_MSB\t0x7\n#define NOA1305_REG_DEVICE_ID_LSB\t0x8\n#define NOA1305_REG_DEVICE_ID_MSB\t0x9\n\n#define NOA1305_DEVICE_ID\t0x0519\n#define NOA1305_DRIVER_NAME\t\"noa1305\"\n\nstruct noa1305_priv {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n};\n\nstatic int noa1305_measure(struct noa1305_priv *priv)\n{\n\t__le16 data;\n\tint ret;\n\n\tret = regmap_bulk_read(priv->regmap, NOA1305_REG_ALS_DATA_LSB, &data,\n\t\t\t       2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn le16_to_cpu(data);\n}\n\nstatic int noa1305_scale(struct noa1305_priv *priv, int *val, int *val2)\n{\n\tint data;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, NOA1305_REG_INTEGRATION_TIME, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (data) {\n\tcase NOA1305_INTEGR_TIME_800MS:\n\t\t*val = 100;\n\t\t*val2 = 77 * 8;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_400MS:\n\t\t*val = 100;\n\t\t*val2 = 77 * 4;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_200MS:\n\t\t*val = 100;\n\t\t*val2 = 77 * 2;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_100MS:\n\t\t*val = 100;\n\t\t*val2 = 77;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_50MS:\n\t\t*val = 1000;\n\t\t*val2 = 77 * 5;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_25MS:\n\t\t*val = 10000;\n\t\t*val2 = 77 * 25;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_12_5MS:\n\t\t*val = 100000;\n\t\t*val2 = 77 * 125;\n\t\tbreak;\n\tcase NOA1305_INTEGR_TIME_6_25MS:\n\t\t*val = 1000000;\n\t\t*val2 = 77 * 625;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic const struct iio_chan_spec noa1305_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t}\n};\n\nstatic int noa1305_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tint ret = -EINVAL;\n\tstruct noa1305_priv *priv = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = noa1305_measure(priv);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\treturn noa1305_scale(priv, val, val2);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info noa1305_info = {\n\t.read_raw = noa1305_read_raw,\n};\n\nstatic bool noa1305_writable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NOA1305_REG_POWER_CONTROL:\n\tcase NOA1305_REG_RESET:\n\tcase NOA1305_REG_INTEGRATION_TIME:\n\tcase NOA1305_REG_INT_SELECT:\n\tcase NOA1305_REG_INT_THRESH_LSB:\n\tcase NOA1305_REG_INT_THRESH_MSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config noa1305_regmap_config = {\n\t.name = NOA1305_DRIVER_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = NOA1305_REG_DEVICE_ID_MSB,\n\t.writeable_reg = noa1305_writable_reg,\n};\n\nstatic int noa1305_probe(struct i2c_client *client)\n{\n\tstruct noa1305_priv *priv;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\t__le16 data;\n\tunsigned int dev_id;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &noa1305_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Regmap initialization failed.\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tpriv = iio_priv(indio_dev);\n\n\tret = devm_regulator_get_enable(&client->dev, \"vin\");\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"get regulator vin failed\\n\");\n\n\ti2c_set_clientdata(client, indio_dev);\n\tpriv->client = client;\n\tpriv->regmap = regmap;\n\n\tret = regmap_bulk_read(regmap, NOA1305_REG_DEVICE_ID_LSB, &data, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"ID reading failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_id = le16_to_cpu(data);\n\tif (dev_id != NOA1305_DEVICE_ID) {\n\t\tdev_err(&client->dev, \"Unknown device ID: 0x%x\\n\", dev_id);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_write(regmap, NOA1305_REG_POWER_CONTROL,\n\t\t\t   NOA1305_POWER_CONTROL_ON);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Enabling power control failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(regmap, NOA1305_REG_RESET, NOA1305_RESET_RESET);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Device reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(regmap, NOA1305_REG_INTEGRATION_TIME,\n\t\t\t   NOA1305_INTEGR_TIME_800MS);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Setting integration time failed\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->info = &noa1305_info;\n\tindio_dev->channels = noa1305_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(noa1305_channels);\n\tindio_dev->name = NOA1305_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_device_register(&client->dev, indio_dev);\n\tif (ret)\n\t\tdev_err(&client->dev, \"registering device failed\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id noa1305_of_match[] = {\n\t{ .compatible = \"onnn,noa1305\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, noa1305_of_match);\n\nstatic const struct i2c_device_id noa1305_ids[] = {\n\t{ \"noa1305\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, noa1305_ids);\n\nstatic struct i2c_driver noa1305_driver = {\n\t.driver = {\n\t\t.name\t\t= NOA1305_DRIVER_NAME,\n\t\t.of_match_table\t= noa1305_of_match,\n\t},\n\t.probe\t\t= noa1305_probe,\n\t.id_table\t= noa1305_ids,\n};\n\nmodule_i2c_driver(noa1305_driver);\n\nMODULE_AUTHOR(\"Sergei Miroshnichenko <sergeimir@emcraft.com>\");\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@collabora.com\");\nMODULE_DESCRIPTION(\"ON Semiconductor NOA1305 ambient light sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}