{
  "module_name": "rohm-bu27008.c",
  "hash_id": "e233b41d192a3bad0fec499e9f1e7f55e5e15fdf9e234f47c7f74c81b37f1eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/rohm-bu27008.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/units.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/iio-gts-helper.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define BU27008_REG_SYSTEM_CONTROL\t0x40\n#define BU27008_MASK_SW_RESET\t\tBIT(7)\n#define BU27008_MASK_PART_ID\t\tGENMASK(5, 0)\n#define BU27008_ID\t\t\t0x1a\n#define BU27008_REG_MODE_CONTROL1\t0x41\n#define BU27008_MASK_MEAS_MODE\t\tGENMASK(2, 0)\n#define BU27008_MASK_CHAN_SEL\t\tGENMASK(3, 2)\n\n#define BU27008_REG_MODE_CONTROL2\t0x42\n#define BU27008_MASK_RGBC_GAIN\t\tGENMASK(7, 3)\n#define BU27008_MASK_IR_GAIN_LO\t\tGENMASK(2, 0)\n#define BU27008_SHIFT_IR_GAIN\t\t3\n\n#define BU27008_REG_MODE_CONTROL3\t0x43\n#define BU27008_MASK_VALID\t\tBIT(7)\n#define BU27008_MASK_INT_EN\t\tBIT(1)\n#define BU27008_INT_EN\t\t\tBU27008_MASK_INT_EN\n#define BU27008_INT_DIS\t\t\t0\n#define BU27008_MASK_MEAS_EN\t\tBIT(0)\n#define BU27008_MEAS_EN\t\t\tBIT(0)\n#define BU27008_MEAS_DIS\t\t0\n\n#define BU27008_REG_DATA0_LO\t\t0x50\n#define BU27008_REG_DATA1_LO\t\t0x52\n#define BU27008_REG_DATA2_LO\t\t0x54\n#define BU27008_REG_DATA3_LO\t\t0x56\n#define BU27008_REG_DATA3_HI\t\t0x57\n#define BU27008_REG_MANUFACTURER_ID\t0x92\n#define BU27008_REG_MAX BU27008_REG_MANUFACTURER_ID\n\n \n\n#define BU27010_MASK_SW_RESET\t\tBIT(7)\n#define BU27010_ID\t\t\t0x1b\n#define BU27010_REG_POWER\t\t0x3e\n#define BU27010_MASK_POWER\t\tBIT(0)\n\n#define BU27010_REG_RESET\t\t0x3f\n#define BU27010_MASK_RESET\t\tBIT(0)\n#define BU27010_RESET_RELEASE\t\tBU27010_MASK_RESET\n\n#define BU27010_MASK_MEAS_EN\t\tBIT(1)\n\n#define BU27010_MASK_CHAN_SEL\t\tGENMASK(7, 6)\n#define BU27010_MASK_MEAS_MODE\t\tGENMASK(5, 4)\n#define BU27010_MASK_RGBC_GAIN\t\tGENMASK(3, 0)\n\n#define BU27010_MASK_DATA3_GAIN\t\tGENMASK(7, 6)\n#define BU27010_MASK_DATA2_GAIN\t\tGENMASK(5, 4)\n#define BU27010_MASK_DATA1_GAIN\t\tGENMASK(3, 2)\n#define BU27010_MASK_DATA0_GAIN\t\tGENMASK(1, 0)\n\n#define BU27010_MASK_FLC_MODE\t\tBIT(7)\n#define BU27010_MASK_FLC_GAIN\t\tGENMASK(4, 0)\n\n#define BU27010_REG_MODE_CONTROL4\t0x44\n \n#define BU27010_IRQ_DIS_ALL\t\tGENMASK(1, 0)\n#define BU27010_DRDY_EN\t\t\tBIT(0)\n#define BU27010_MASK_INT_SEL\t\tGENMASK(1, 0)\n\n#define BU27010_REG_MODE_CONTROL5\t0x45\n#define BU27010_MASK_RGB_VALID\t\tBIT(7)\n#define BU27010_MASK_FLC_VALID\t\tBIT(6)\n#define BU27010_MASK_WAIT_EN\t\tBIT(3)\n#define BU27010_MASK_FIFO_EN\t\tBIT(2)\n#define BU27010_MASK_RGB_EN\t\tBIT(1)\n#define BU27010_MASK_FLC_EN\t\tBIT(0)\n\n#define BU27010_REG_DATA_FLICKER_LO\t0x56\n#define BU27010_MASK_DATA_FLICKER_HI\tGENMASK(2, 0)\n#define BU27010_REG_FLICKER_COUNT\t0x5a\n#define BU27010_REG_FIFO_LEVEL_LO\t0x5b\n#define BU27010_MASK_FIFO_LEVEL_HI\tBIT(0)\n#define BU27010_REG_FIFO_DATA_LO\t0x5d\n#define BU27010_REG_FIFO_DATA_HI\t0x5e\n#define BU27010_MASK_FIFO_DATA_HI\tGENMASK(2, 0)\n#define BU27010_REG_MANUFACTURER_ID\t0x92\n#define BU27010_REG_MAX BU27010_REG_MANUFACTURER_ID\n\n \nenum bu27008_chan_type {\n\tBU27008_RED,\n\tBU27008_GREEN,\n\tBU27008_BLUE,\n\tBU27008_CLEAR,\n\tBU27008_IR,\n\tBU27008_NUM_CHANS\n};\n\n \nenum bu27008_chan {\n\tBU27008_DATA0,\n\tBU27008_DATA1,\n\tBU27008_DATA2,\n\tBU27008_DATA3,\n\tBU27008_NUM_HW_CHANS\n};\n\n \n#define ALWAYS_SCANNABLE (BIT(BU27008_RED) | BIT(BU27008_GREEN))\n\n \n#define BU27008_BLUE2_CLEAR3\t\t0x0  \n#define BU27008_CLEAR2_IR3\t\t0x1  \n#define BU27008_BLUE2_IR3\t\t0x2  \n\nstatic const unsigned long bu27008_scan_masks[] = {\n\t \n\tALWAYS_SCANNABLE | BIT(BU27008_BLUE) | BIT(BU27008_CLEAR),\n\t \n\tALWAYS_SCANNABLE | BIT(BU27008_CLEAR) | BIT(BU27008_IR),\n\t \n\tALWAYS_SCANNABLE | BIT(BU27008_BLUE) | BIT(BU27008_IR),\n\t0\n};\n\n \n#define BU27008_SCALE_1X 16\n\n \n#define BU27010_SCALE_1X 64\n\n \n#define BU27008_GSEL_1X\t\t0x00\n#define BU27008_GSEL_4X\t\t0x08\n#define BU27008_GSEL_8X\t\t0x09\n#define BU27008_GSEL_16X\t0x0a\n#define BU27008_GSEL_32X\t0x0b\n#define BU27008_GSEL_64X\t0x0c\n#define BU27008_GSEL_256X\t0x18\n#define BU27008_GSEL_512X\t0x19\n#define BU27008_GSEL_1024X\t0x1a\n\nstatic const struct iio_gain_sel_pair bu27008_gains[] = {\n\tGAIN_SCALE_GAIN(1, BU27008_GSEL_1X),\n\tGAIN_SCALE_GAIN(4, BU27008_GSEL_4X),\n\tGAIN_SCALE_GAIN(8, BU27008_GSEL_8X),\n\tGAIN_SCALE_GAIN(16, BU27008_GSEL_16X),\n\tGAIN_SCALE_GAIN(32, BU27008_GSEL_32X),\n\tGAIN_SCALE_GAIN(64, BU27008_GSEL_64X),\n\tGAIN_SCALE_GAIN(256, BU27008_GSEL_256X),\n\tGAIN_SCALE_GAIN(512, BU27008_GSEL_512X),\n\tGAIN_SCALE_GAIN(1024, BU27008_GSEL_1024X),\n};\n\nstatic const struct iio_gain_sel_pair bu27008_gains_ir[] = {\n\tGAIN_SCALE_GAIN(2, BU27008_GSEL_1X),\n\tGAIN_SCALE_GAIN(4, BU27008_GSEL_4X),\n\tGAIN_SCALE_GAIN(8, BU27008_GSEL_8X),\n\tGAIN_SCALE_GAIN(16, BU27008_GSEL_16X),\n\tGAIN_SCALE_GAIN(32, BU27008_GSEL_32X),\n\tGAIN_SCALE_GAIN(64, BU27008_GSEL_64X),\n\tGAIN_SCALE_GAIN(256, BU27008_GSEL_256X),\n\tGAIN_SCALE_GAIN(512, BU27008_GSEL_512X),\n\tGAIN_SCALE_GAIN(1024, BU27008_GSEL_1024X),\n};\n\n#define BU27010_GSEL_1X\t\t0x00\t \n#define BU27010_GSEL_4X\t\t0x08\t \n#define BU27010_GSEL_16X\t0x09\t \n#define BU27010_GSEL_64X\t0x0e\t \n#define BU27010_GSEL_256X\t0x1e\t \n#define BU27010_GSEL_1024X\t0x2e\t \n#define BU27010_GSEL_4096X\t0x3f\t \n\nstatic const struct iio_gain_sel_pair bu27010_gains[] = {\n\tGAIN_SCALE_GAIN(1, BU27010_GSEL_1X),\n\tGAIN_SCALE_GAIN(4, BU27010_GSEL_4X),\n\tGAIN_SCALE_GAIN(16, BU27010_GSEL_16X),\n\tGAIN_SCALE_GAIN(64, BU27010_GSEL_64X),\n\tGAIN_SCALE_GAIN(256, BU27010_GSEL_256X),\n\tGAIN_SCALE_GAIN(1024, BU27010_GSEL_1024X),\n\tGAIN_SCALE_GAIN(4096, BU27010_GSEL_4096X),\n};\n\nstatic const struct iio_gain_sel_pair bu27010_gains_ir[] = {\n\tGAIN_SCALE_GAIN(2, BU27010_GSEL_1X),\n\tGAIN_SCALE_GAIN(4, BU27010_GSEL_4X),\n\tGAIN_SCALE_GAIN(16, BU27010_GSEL_16X),\n\tGAIN_SCALE_GAIN(64, BU27010_GSEL_64X),\n\tGAIN_SCALE_GAIN(256, BU27010_GSEL_256X),\n\tGAIN_SCALE_GAIN(1024, BU27010_GSEL_1024X),\n\tGAIN_SCALE_GAIN(4096, BU27010_GSEL_4096X),\n};\n\n#define BU27008_MEAS_MODE_100MS\t\t0x00\n#define BU27008_MEAS_MODE_55MS\t\t0x01\n#define BU27008_MEAS_MODE_200MS\t\t0x02\n#define BU27008_MEAS_MODE_400MS\t\t0x04\n\n#define BU27010_MEAS_MODE_100MS\t\t0x00\n#define BU27010_MEAS_MODE_55MS\t\t0x03\n#define BU27010_MEAS_MODE_200MS\t\t0x01\n#define BU27010_MEAS_MODE_400MS\t\t0x02\n\n#define BU27008_MEAS_TIME_MAX_MS\t400\n\nstatic const struct iio_itime_sel_mul bu27008_itimes[] = {\n\tGAIN_SCALE_ITIME_US(400000, BU27008_MEAS_MODE_400MS, 8),\n\tGAIN_SCALE_ITIME_US(200000, BU27008_MEAS_MODE_200MS, 4),\n\tGAIN_SCALE_ITIME_US(100000, BU27008_MEAS_MODE_100MS, 2),\n\tGAIN_SCALE_ITIME_US(55000, BU27008_MEAS_MODE_55MS, 1),\n};\n\nstatic const struct iio_itime_sel_mul bu27010_itimes[] = {\n\tGAIN_SCALE_ITIME_US(400000, BU27010_MEAS_MODE_400MS, 8),\n\tGAIN_SCALE_ITIME_US(200000, BU27010_MEAS_MODE_200MS, 4),\n\tGAIN_SCALE_ITIME_US(100000, BU27010_MEAS_MODE_100MS, 2),\n\tGAIN_SCALE_ITIME_US(55000, BU27010_MEAS_MODE_55MS, 1),\n};\n\n \n#define BU27008_CHAN(color, data, separate_avail)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_INTENSITY,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_LIGHT_##color,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\t\\\n\t.info_mask_separate_available = (separate_avail),\t\t\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME),\t\t\t\\\n\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_INT_TIME),\t\\\n\t.address = BU27008_REG_##data##_LO,\t\t\t\t\t\\\n\t.scan_index = BU27008_##color,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\t\\\n}\n\n \nstatic const struct iio_chan_spec bu27008_channels[] = {\n\tBU27008_CHAN(RED, DATA0, BIT(IIO_CHAN_INFO_SCALE)),\n\tBU27008_CHAN(GREEN, DATA1, BIT(IIO_CHAN_INFO_SCALE)),\n\tBU27008_CHAN(BLUE, DATA2, BIT(IIO_CHAN_INFO_SCALE)),\n\tBU27008_CHAN(CLEAR, DATA2, BIT(IIO_CHAN_INFO_SCALE)),\n\t \n\tBU27008_CHAN(IR, DATA3, 0),\n\tIIO_CHAN_SOFT_TIMESTAMP(BU27008_NUM_CHANS),\n};\n\nstruct bu27008_data;\n\nstruct bu27_chip_data {\n\tconst char *name;\n\tint (*chip_init)(struct bu27008_data *data);\n\tint (*get_gain_sel)(struct bu27008_data *data, int *sel);\n\tint (*write_gain_sel)(struct bu27008_data *data, int sel);\n\tconst struct regmap_config *regmap_cfg;\n\tconst struct iio_gain_sel_pair *gains;\n\tconst struct iio_gain_sel_pair *gains_ir;\n\tconst struct iio_itime_sel_mul *itimes;\n\tint num_gains;\n\tint num_gains_ir;\n\tint num_itimes;\n\tint scale1x;\n\n\tint drdy_en_reg;\n\tint drdy_en_mask;\n\tint meas_en_reg;\n\tint meas_en_mask;\n\tint valid_reg;\n\tint chan_sel_reg;\n\tint chan_sel_mask;\n\tint int_time_mask;\n\tu8 part_id;\n};\n\nstruct bu27008_data {\n\tconst struct bu27_chip_data *cd;\n\tstruct regmap *regmap;\n\tstruct iio_trigger *trig;\n\tstruct device *dev;\n\tstruct iio_gts gts;\n\tstruct iio_gts gts_ir;\n\tint irq;\n\n\t \n\tstruct mutex mutex;\n};\n\nstatic const struct regmap_range bu27008_volatile_ranges[] = {\n\t{\n\t\t.range_min = BU27008_REG_SYSTEM_CONTROL,\t \n\t\t.range_max = BU27008_REG_SYSTEM_CONTROL,\n\t}, {\n\t\t.range_min = BU27008_REG_MODE_CONTROL3,\t\t \n\t\t.range_max = BU27008_REG_MODE_CONTROL3,\n\t}, {\n\t\t.range_min = BU27008_REG_DATA0_LO,\t\t \n\t\t.range_max = BU27008_REG_DATA3_HI,\n\t},\n};\n\nstatic const struct regmap_range bu27010_volatile_ranges[] = {\n\t{\n\t\t.range_min = BU27010_REG_RESET,\t\t\t \n\t\t.range_max = BU27008_REG_SYSTEM_CONTROL,\t \n\t}, {\n\t\t.range_min = BU27010_REG_MODE_CONTROL5,\t\t \n\t\t.range_max = BU27010_REG_MODE_CONTROL5,\n\t}, {\n\t\t.range_min = BU27008_REG_DATA0_LO,\n\t\t.range_max = BU27010_REG_FIFO_DATA_HI,\n\t},\n};\n\nstatic const struct regmap_access_table bu27008_volatile_regs = {\n\t.yes_ranges = &bu27008_volatile_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(bu27008_volatile_ranges),\n};\n\nstatic const struct regmap_access_table bu27010_volatile_regs = {\n\t.yes_ranges = &bu27010_volatile_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(bu27010_volatile_ranges),\n};\n\nstatic const struct regmap_range bu27008_read_only_ranges[] = {\n\t{\n\t\t.range_min = BU27008_REG_DATA0_LO,\n\t\t.range_max = BU27008_REG_DATA3_HI,\n\t}, {\n\t\t.range_min = BU27008_REG_MANUFACTURER_ID,\n\t\t.range_max = BU27008_REG_MANUFACTURER_ID,\n\t},\n};\n\nstatic const struct regmap_range bu27010_read_only_ranges[] = {\n\t{\n\t\t.range_min = BU27008_REG_DATA0_LO,\n\t\t.range_max = BU27010_REG_FIFO_DATA_HI,\n\t}, {\n\t\t.range_min = BU27010_REG_MANUFACTURER_ID,\n\t\t.range_max = BU27010_REG_MANUFACTURER_ID,\n\t}\n};\n\nstatic const struct regmap_access_table bu27008_ro_regs = {\n\t.no_ranges = &bu27008_read_only_ranges[0],\n\t.n_no_ranges = ARRAY_SIZE(bu27008_read_only_ranges),\n};\n\nstatic const struct regmap_access_table bu27010_ro_regs = {\n\t.no_ranges = &bu27010_read_only_ranges[0],\n\t.n_no_ranges = ARRAY_SIZE(bu27010_read_only_ranges),\n};\n\nstatic const struct regmap_config bu27008_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = BU27008_REG_MAX,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &bu27008_volatile_regs,\n\t.wr_table = &bu27008_ro_regs,\n\t \n\t.disable_locking = true,\n};\n\nstatic const struct regmap_config bu27010_regmap = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\n\t.max_register\t= BU27010_REG_MAX,\n\t.cache_type\t= REGCACHE_RBTREE,\n\t.volatile_table = &bu27010_volatile_regs,\n\t.wr_table\t= &bu27010_ro_regs,\n\t.disable_locking = true,\n};\n\nstatic int bu27008_write_gain_sel(struct bu27008_data *data, int sel)\n{\n\tint regval;\n\n\tregval = FIELD_PREP(BU27008_MASK_RGBC_GAIN, sel);\n\n\t \n\tregval |= FIELD_PREP(BU27008_MASK_IR_GAIN_LO, sel);\n\n\treturn regmap_update_bits(data->regmap, BU27008_REG_MODE_CONTROL2,\n\t\t\t\t  BU27008_MASK_RGBC_GAIN, regval);\n}\n\nstatic int bu27010_write_gain_sel(struct bu27008_data *data, int sel)\n{\n\tunsigned int regval;\n\tint ret, chan_selector;\n\n\t \n\tregval = FIELD_PREP(BU27010_MASK_RGBC_GAIN, (sel >> 2));\n\n\tret = regmap_update_bits(data->regmap, BU27008_REG_MODE_CONTROL1,\n\t\t\t\t  BU27010_MASK_RGBC_GAIN, regval);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchan_selector = sel & GENMASK(1, 0);\n\n\tregval = FIELD_PREP(BU27010_MASK_DATA0_GAIN, chan_selector);\n\tregval |= FIELD_PREP(BU27010_MASK_DATA1_GAIN, chan_selector);\n\tregval |= FIELD_PREP(BU27010_MASK_DATA2_GAIN, chan_selector);\n\tregval |= FIELD_PREP(BU27010_MASK_DATA3_GAIN, chan_selector);\n\n\treturn regmap_write(data->regmap, BU27008_REG_MODE_CONTROL2, regval);\n}\n\nstatic int bu27008_get_gain_sel(struct bu27008_data *data, int *sel)\n{\n\tint ret;\n\n\t \n\n\tret = regmap_read(data->regmap, BU27008_REG_MODE_CONTROL2, sel);\n\tif (ret)\n\t\treturn ret;\n\n\t*sel = FIELD_GET(BU27008_MASK_RGBC_GAIN, *sel);\n\n\treturn 0;\n}\n\nstatic int bu27010_get_gain_sel(struct bu27008_data *data, int *sel)\n{\n\tint ret, tmp;\n\n\t \n\tret = regmap_read(data->regmap, BU27008_REG_MODE_CONTROL2, sel);\n\tif (ret)\n\t\treturn ret;\n\n\t*sel = FIELD_GET(BU27010_MASK_DATA0_GAIN, *sel);\n\n\t \n\tret = regmap_read(data->regmap, BU27008_REG_MODE_CONTROL1, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*sel |= FIELD_GET(BU27010_MASK_RGBC_GAIN, tmp) << fls(BU27010_MASK_DATA0_GAIN);\n\n\treturn ret;\n}\n\nstatic int bu27008_chip_init(struct bu27008_data *data)\n{\n\tint ret;\n\n\tret = regmap_write_bits(data->regmap, BU27008_REG_SYSTEM_CONTROL,\n\t\t\t\tBU27008_MASK_SW_RESET, BU27008_MASK_SW_RESET);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Sensor reset failed\\n\");\n\n\t \n\tmsleep(1);\n\n\tret = regmap_reinit_cache(data->regmap, data->cd->regmap_cfg);\n\tif (ret)\n\t\tdev_err(data->dev, \"Failed to reinit reg cache\\n\");\n\n\treturn ret;\n}\n\nstatic int bu27010_chip_init(struct bu27008_data *data)\n{\n\tint ret;\n\n\tret = regmap_write_bits(data->regmap, BU27008_REG_SYSTEM_CONTROL,\n\t\t\t\tBU27010_MASK_SW_RESET, BU27010_MASK_SW_RESET);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Sensor reset failed\\n\");\n\n\tmsleep(1);\n\n\t \n\tret = regmap_write_bits(data->regmap, BU27010_REG_POWER,\n\t\t\t\tBU27010_MASK_POWER, BU27010_MASK_POWER);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Sensor power-on failed\\n\");\n\n\tmsleep(1);\n\n\t \n\tret = regmap_write_bits(data->regmap, BU27010_REG_RESET,\n\t\t\t\tBU27010_MASK_RESET, BU27010_RESET_RELEASE);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Sensor powering failed\\n\");\n\n\tmsleep(1);\n\n\t \n\treturn regmap_clear_bits(data->regmap, BU27010_REG_MODE_CONTROL4,\n\t\t\t\t BU27010_IRQ_DIS_ALL);\n}\n\nstatic const struct bu27_chip_data bu27010_chip = {\n\t.name = \"bu27010\",\n\t.chip_init = bu27010_chip_init,\n\t.get_gain_sel = bu27010_get_gain_sel,\n\t.write_gain_sel = bu27010_write_gain_sel,\n\t.regmap_cfg = &bu27010_regmap,\n\t.gains = &bu27010_gains[0],\n\t.gains_ir = &bu27010_gains_ir[0],\n\t.itimes = &bu27010_itimes[0],\n\t.num_gains = ARRAY_SIZE(bu27010_gains),\n\t.num_gains_ir = ARRAY_SIZE(bu27010_gains_ir),\n\t.num_itimes = ARRAY_SIZE(bu27010_itimes),\n\t.scale1x = BU27010_SCALE_1X,\n\t.drdy_en_reg = BU27010_REG_MODE_CONTROL4,\n\t.drdy_en_mask = BU27010_DRDY_EN,\n\t.meas_en_reg = BU27010_REG_MODE_CONTROL5,\n\t.meas_en_mask = BU27010_MASK_MEAS_EN,\n\t.valid_reg = BU27010_REG_MODE_CONTROL5,\n\t.chan_sel_reg = BU27008_REG_MODE_CONTROL1,\n\t.chan_sel_mask = BU27010_MASK_CHAN_SEL,\n\t.int_time_mask = BU27010_MASK_MEAS_MODE,\n\t.part_id = BU27010_ID,\n};\n\nstatic const struct bu27_chip_data bu27008_chip = {\n\t.name = \"bu27008\",\n\t.chip_init = bu27008_chip_init,\n\t.get_gain_sel = bu27008_get_gain_sel,\n\t.write_gain_sel = bu27008_write_gain_sel,\n\t.regmap_cfg = &bu27008_regmap,\n\t.gains = &bu27008_gains[0],\n\t.gains_ir = &bu27008_gains_ir[0],\n\t.itimes = &bu27008_itimes[0],\n\t.num_gains = ARRAY_SIZE(bu27008_gains),\n\t.num_gains_ir = ARRAY_SIZE(bu27008_gains_ir),\n\t.num_itimes = ARRAY_SIZE(bu27008_itimes),\n\t.scale1x = BU27008_SCALE_1X,\n\t.drdy_en_reg = BU27008_REG_MODE_CONTROL3,\n\t.drdy_en_mask = BU27008_MASK_INT_EN,\n\t.valid_reg = BU27008_REG_MODE_CONTROL3,\n\t.meas_en_reg = BU27008_REG_MODE_CONTROL3,\n\t.meas_en_mask = BU27008_MASK_MEAS_EN,\n\t.chan_sel_reg = BU27008_REG_MODE_CONTROL3,\n\t.chan_sel_mask = BU27008_MASK_CHAN_SEL,\n\t.int_time_mask = BU27008_MASK_MEAS_MODE,\n\t.part_id = BU27008_ID,\n};\n\n#define BU27008_MAX_VALID_RESULT_WAIT_US\t50000\n#define BU27008_VALID_RESULT_WAIT_QUANTA_US\t1000\n\nstatic int bu27008_chan_read_data(struct bu27008_data *data, int reg, int *val)\n{\n\tint ret, valid;\n\t__le16 tmp;\n\n\tret = regmap_read_poll_timeout(data->regmap, data->cd->valid_reg,\n\t\t\t\t       valid, (valid & BU27008_MASK_VALID),\n\t\t\t\t       BU27008_VALID_RESULT_WAIT_QUANTA_US,\n\t\t\t\t       BU27008_MAX_VALID_RESULT_WAIT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, reg, &tmp, sizeof(tmp));\n\tif (ret)\n\t\tdev_err(data->dev, \"Reading channel data failed\\n\");\n\n\t*val = le16_to_cpu(tmp);\n\n\treturn ret;\n}\n\nstatic int bu27008_get_gain(struct bu27008_data *data, struct iio_gts *gts, int *gain)\n{\n\tint ret, sel;\n\n\tret = data->cd->get_gain_sel(data, &sel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_gts_find_gain_by_sel(gts, sel);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"unknown gain value 0x%x\\n\", sel);\n\t\treturn ret;\n\t}\n\n\t*gain = ret;\n\n\treturn 0;\n}\n\nstatic int bu27008_set_gain(struct bu27008_data *data, int gain)\n{\n\tint ret;\n\n\tret = iio_gts_find_sel_by_gain(&data->gts, gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn data->cd->write_gain_sel(data, ret);\n}\n\nstatic int bu27008_get_int_time_sel(struct bu27008_data *data, int *sel)\n{\n\tint ret, val;\n\n\tret = regmap_read(data->regmap, BU27008_REG_MODE_CONTROL1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= data->cd->int_time_mask;\n\tval >>= ffs(data->cd->int_time_mask) - 1;\n\n\t*sel = val;\n\n\treturn 0;\n}\n\nstatic int bu27008_set_int_time_sel(struct bu27008_data *data, int sel)\n{\n\tsel <<= ffs(data->cd->int_time_mask) - 1;\n\n\treturn regmap_update_bits(data->regmap, BU27008_REG_MODE_CONTROL1,\n\t\t\t\t  data->cd->int_time_mask, sel);\n}\n\nstatic int bu27008_get_int_time_us(struct bu27008_data *data)\n{\n\tint ret, sel;\n\n\tret = bu27008_get_int_time_sel(data, &sel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iio_gts_find_int_time_by_sel(&data->gts, sel);\n}\n\nstatic int _bu27008_get_scale(struct bu27008_data *data, bool ir, int *val,\n\t\t\t      int *val2)\n{\n\tstruct iio_gts *gts;\n\tint gain, ret;\n\n\tif (ir)\n\t\tgts = &data->gts_ir;\n\telse\n\t\tgts = &data->gts;\n\n\tret = bu27008_get_gain(data, gts, &gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27008_get_int_time_us(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn iio_gts_get_scale(gts, gain, ret, val, val2);\n}\n\nstatic int bu27008_get_scale(struct bu27008_data *data, bool ir, int *val,\n\t\t\t     int *val2)\n{\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = _bu27008_get_scale(data, ir, val, val2);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bu27008_set_int_time(struct bu27008_data *data, int time)\n{\n\tint ret;\n\n\tret = iio_gts_find_sel_by_int_time(&data->gts, time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bu27008_set_int_time_sel(data, ret);\n}\n\n \nstatic int bu27008_try_set_int_time(struct bu27008_data *data, int int_time_new)\n{\n\tint ret, old_time_sel, new_time_sel,  old_gain, new_gain;\n\n\tmutex_lock(&data->mutex);\n\n\tret = bu27008_get_int_time_sel(data, &old_time_sel);\n\tif (ret < 0)\n\t\tgoto unlock_out;\n\n\tif (!iio_gts_valid_time(&data->gts, int_time_new)) {\n\t\tdev_dbg(data->dev, \"Unsupported integration time %u\\n\",\n\t\t\tint_time_new);\n\n\t\tret = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tnew_time_sel = iio_gts_find_sel_by_int_time(&data->gts, int_time_new);\n\tif (new_time_sel == old_time_sel)\n\t\tgoto unlock_out;\n\n\tret = bu27008_get_gain(data, &data->gts, &old_gain);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = iio_gts_find_new_gain_sel_by_old_gain_time(&data->gts, old_gain,\n\t\t\t\told_time_sel, new_time_sel, &new_gain);\n\tif (ret) {\n\t\tint scale1, scale2;\n\t\tbool ok;\n\n\t\t_bu27008_get_scale(data, false, &scale1, &scale2);\n\t\tdev_dbg(data->dev,\n\t\t\t\"Can't support time %u with current scale %u %u\\n\",\n\t\t\tint_time_new, scale1, scale2);\n\n\t\tif (new_gain < 0)\n\t\t\tgoto unlock_out;\n\n\t\t \n\t\tret = iio_find_closest_gain_low(&data->gts, new_gain, &ok);\n\t\tif (!ok)\n\t\t\tdev_dbg(data->dev, \"optimal gain out of range\\n\");\n\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(data->dev,\n\t\t\t\t \"Total gain increase. Risk of saturation\");\n\t\t\tret = iio_gts_get_min_gain(&data->gts);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto unlock_out;\n\t\t}\n\t\tnew_gain = ret;\n\t\tdev_dbg(data->dev, \"scale changed, new gain %u\\n\", new_gain);\n\t}\n\n\tret = bu27008_set_gain(data, new_gain);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = bu27008_set_int_time(data, int_time_new);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bu27008_meas_set(struct bu27008_data *data, bool enable)\n{\n\tif (enable)\n\t\treturn regmap_set_bits(data->regmap, data->cd->meas_en_reg,\n\t\t\t\t       data->cd->meas_en_mask);\n\treturn regmap_clear_bits(data->regmap, data->cd->meas_en_reg,\n\t\t\t\t data->cd->meas_en_mask);\n}\n\nstatic int bu27008_chan_cfg(struct bu27008_data *data,\n\t\t\t    struct iio_chan_spec const *chan)\n{\n\tint chan_sel;\n\n\tif (chan->scan_index == BU27008_BLUE)\n\t\tchan_sel = BU27008_BLUE2_CLEAR3;\n\telse\n\t\tchan_sel = BU27008_CLEAR2_IR3;\n\n\t \n\tchan_sel <<= ffs(data->cd->chan_sel_mask) - 1;\n\n\treturn regmap_update_bits(data->regmap, data->cd->chan_sel_reg,\n\t\t\t\t  BU27008_MASK_CHAN_SEL, chan_sel);\n}\n\nstatic int bu27008_read_one(struct bu27008_data *data, struct iio_dev *idev,\n\t\t\t    struct iio_chan_spec const *chan, int *val, int *val2)\n{\n\tint ret, int_time;\n\n\tret = bu27008_chan_cfg(data, chan);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27008_meas_set(data, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bu27008_get_int_time_us(data);\n\tif (ret < 0)\n\t\tint_time = BU27008_MEAS_TIME_MAX_MS;\n\telse\n\t\tint_time = ret / USEC_PER_MSEC;\n\n\tmsleep(int_time);\n\n\tret = bu27008_chan_read_data(data, chan->address, val);\n\tif (!ret)\n\t\tret = IIO_VAL_INT;\n\n\tif (bu27008_meas_set(data, false))\n\t\tdev_warn(data->dev, \"measurement disabling failed\\n\");\n\n\treturn ret;\n}\n\nstatic int bu27008_read_raw(struct iio_dev *idev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\tint busy, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tbusy = iio_device_claim_direct_mode(idev);\n\t\tif (busy)\n\t\t\treturn -EBUSY;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = bu27008_read_one(data, idev, chan, val, val2);\n\t\tmutex_unlock(&data->mutex);\n\n\t\tiio_device_release_direct_mode(idev);\n\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = bu27008_get_scale(data, chan->scan_index == BU27008_IR,\n\t\t\t\t\tval, val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tret = bu27008_get_int_time_us(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = 0;\n\t\t*val2 = ret;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int bu27008_try_find_new_time_gain(struct bu27008_data *data, int val,\n\t\t\t\t\t  int val2, int *gain_sel)\n{\n\tint i, ret, new_time_sel;\n\n\tfor (i = 0; i < data->gts.num_itime; i++) {\n\t\tnew_time_sel = data->gts.itime_table[i].sel;\n\t\tret = iio_gts_find_gain_sel_for_scale_using_time(&data->gts,\n\t\t\t\t\tnew_time_sel, val, val2, gain_sel);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\tif (i == data->gts.num_itime) {\n\t\tdev_err(data->dev, \"Can't support scale %u %u\\n\", val, val2);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn bu27008_set_int_time_sel(data, new_time_sel);\n}\n\nstatic int bu27008_set_scale(struct bu27008_data *data,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2)\n{\n\tint ret, gain_sel, time_sel;\n\n\tif (chan->scan_index == BU27008_IR)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\n\tret = bu27008_get_int_time_sel(data, &time_sel);\n\tif (ret < 0)\n\t\tgoto unlock_out;\n\n\tret = iio_gts_find_gain_sel_for_scale_using_time(&data->gts, time_sel,\n\t\t\t\t\t\tval, val2, &gain_sel);\n\tif (ret) {\n\t\tret = bu27008_try_find_new_time_gain(data, val, val2, &gain_sel);\n\t\tif (ret)\n\t\t\tgoto unlock_out;\n\n\t}\n\tret = data->cd->write_gain_sel(data, gain_sel);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bu27008_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bu27008_write_raw(struct iio_dev *idev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\tint ret;\n\n\t \n\tret = iio_device_claim_direct_mode(idev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = bu27008_set_scale(data, chan, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = bu27008_try_set_int_time(data, val2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tiio_device_release_direct_mode(idev);\n\n\treturn ret;\n}\n\nstatic int bu27008_read_avail(struct iio_dev *idev,\n\t\t\t      struct iio_chan_spec const *chan, const int **vals,\n\t\t\t      int *type, int *length, long mask)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn iio_gts_avail_times(&data->gts, vals, type, length);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->channel2 == IIO_MOD_LIGHT_IR)\n\t\t\treturn iio_gts_all_avail_scales(&data->gts_ir, vals,\n\t\t\t\t\t\t\ttype, length);\n\t\treturn iio_gts_all_avail_scales(&data->gts, vals, type, length);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bu27008_update_scan_mode(struct iio_dev *idev,\n\t\t\t\t    const unsigned long *scan_mask)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\tint chan_sel;\n\n\t \n\tif (test_bit(BU27008_BLUE, idev->active_scan_mask)) {\n\t\tif (test_bit(BU27008_CLEAR, idev->active_scan_mask))\n\t\t\tchan_sel = BU27008_BLUE2_CLEAR3;\n\t\telse\n\t\t\tchan_sel = BU27008_BLUE2_IR3;\n\t} else {\n\t\tchan_sel = BU27008_CLEAR2_IR3;\n\t}\n\n\tchan_sel <<= ffs(data->cd->chan_sel_mask) - 1;\n\n\treturn regmap_update_bits(data->regmap, data->cd->chan_sel_reg,\n\t\t\t\t  data->cd->chan_sel_mask, chan_sel);\n}\n\nstatic const struct iio_info bu27008_info = {\n\t.read_raw = &bu27008_read_raw,\n\t.write_raw = &bu27008_write_raw,\n\t.write_raw_get_fmt = &bu27008_write_raw_get_fmt,\n\t.read_avail = &bu27008_read_avail,\n\t.update_scan_mode = bu27008_update_scan_mode,\n\t.validate_trigger = iio_validate_own_trigger,\n};\n\nstatic int bu27008_trigger_set_state(struct iio_trigger *trig, bool state)\n{\n\tstruct bu27008_data *data = iio_trigger_get_drvdata(trig);\n\tint ret;\n\n\n\tif (state)\n\t\tret = regmap_set_bits(data->regmap, data->cd->drdy_en_reg,\n\t\t\t\t      data->cd->drdy_en_mask);\n\telse\n\t\tret = regmap_clear_bits(data->regmap, data->cd->drdy_en_reg,\n\t\t\t\t\tdata->cd->drdy_en_mask);\n\tif (ret)\n\t\tdev_err(data->dev, \"Failed to set trigger state\\n\");\n\n\treturn ret;\n}\n\nstatic void bu27008_trigger_reenable(struct iio_trigger *trig)\n{\n\tstruct bu27008_data *data = iio_trigger_get_drvdata(trig);\n\n\tenable_irq(data->irq);\n}\n\nstatic const struct iio_trigger_ops bu27008_trigger_ops = {\n\t.set_trigger_state = bu27008_trigger_set_state,\n\t.reenable = bu27008_trigger_reenable,\n};\n\nstatic irqreturn_t bu27008_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *idev = pf->indio_dev;\n\tstruct bu27008_data *data = iio_priv(idev);\n\tstruct {\n\t\t__le16 chan[BU27008_NUM_HW_CHANS];\n\t\ts64 ts __aligned(8);\n\t} raw;\n\tint ret, dummy;\n\n\tmemset(&raw, 0, sizeof(raw));\n\n\t \n\tret = regmap_read(data->regmap, data->cd->valid_reg, &dummy);\n\tif (ret < 0)\n\t\tgoto err_read;\n\n\tret = regmap_bulk_read(data->regmap, BU27008_REG_DATA0_LO, &raw.chan,\n\t\t\t       sizeof(raw.chan));\n\tif (ret < 0)\n\t\tgoto err_read;\n\n\tiio_push_to_buffers_with_timestamp(idev, &raw, pf->timestamp);\nerr_read:\n\tiio_trigger_notify_done(idev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bu27008_buffer_preenable(struct iio_dev *idev)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\n\treturn bu27008_meas_set(data, true);\n}\n\nstatic int bu27008_buffer_postdisable(struct iio_dev *idev)\n{\n\tstruct bu27008_data *data = iio_priv(idev);\n\n\treturn bu27008_meas_set(data, false);\n}\n\nstatic const struct iio_buffer_setup_ops bu27008_buffer_ops = {\n\t.preenable = bu27008_buffer_preenable,\n\t.postdisable = bu27008_buffer_postdisable,\n};\n\nstatic irqreturn_t bu27008_data_rdy_poll(int irq, void *private)\n{\n\t \n\tdisable_irq_nosync(irq);\n\tiio_trigger_poll(private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bu27008_setup_trigger(struct bu27008_data *data, struct iio_dev *idev)\n{\n\tstruct iio_trigger *itrig;\n\tchar *name;\n\tint ret;\n\n\tret = devm_iio_triggered_buffer_setup(data->dev, idev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      bu27008_trigger_handler,\n\t\t\t\t\t      &bu27008_buffer_ops);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t     \"iio_triggered_buffer_setup_ext FAIL\\n\");\n\n\titrig = devm_iio_trigger_alloc(data->dev, \"%sdata-rdy-dev%d\",\n\t\t\t\t       idev->name, iio_device_id(idev));\n\tif (!itrig)\n\t\treturn -ENOMEM;\n\n\tdata->trig = itrig;\n\n\titrig->ops = &bu27008_trigger_ops;\n\tiio_trigger_set_drvdata(itrig, data);\n\n\tname = devm_kasprintf(data->dev, GFP_KERNEL, \"%s-bu27008\",\n\t\t\t      dev_name(data->dev));\n\n\tret = devm_request_irq(data->dev, data->irq,\n\t\t\t       &bu27008_data_rdy_poll,\n\t\t\t       0, name, itrig);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Could not request IRQ\\n\");\n\n\tret = devm_iio_trigger_register(data->dev, itrig);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"Trigger registration failed\\n\");\n\n\t \n\tidev->trig = iio_trigger_get(itrig);\n\n\treturn 0;\n}\n\nstatic int bu27008_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct bu27008_data *data;\n\tstruct regmap *regmap;\n\tunsigned int part_id, reg;\n\tstruct iio_dev *idev;\n\tint ret;\n\n\tidev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tret = devm_regulator_get_enable(dev, \"vdd\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulator\\n\");\n\n\tdata = iio_priv(idev);\n\n\tdata->cd = device_get_match_data(&i2c->dev);\n\tif (!data->cd)\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(i2c, data->cd->regmap_cfg);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to initialize Regmap\\n\");\n\n\n\tret = regmap_read(regmap, BU27008_REG_SYSTEM_CONTROL, &reg);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to access sensor\\n\");\n\n\tpart_id = FIELD_GET(BU27008_MASK_PART_ID, reg);\n\n\tif (part_id != data->cd->part_id)\n\t\tdev_warn(dev, \"unknown device 0x%x\\n\", part_id);\n\n\tret = devm_iio_init_iio_gts(dev, data->cd->scale1x, 0, data->cd->gains,\n\t\t\t\t    data->cd->num_gains, data->cd->itimes,\n\t\t\t\t    data->cd->num_itimes, &data->gts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_init_iio_gts(dev, data->cd->scale1x, 0, data->cd->gains_ir,\n\t\t\t\t    data->cd->num_gains_ir, data->cd->itimes,\n\t\t\t\t    data->cd->num_itimes, &data->gts_ir);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&data->mutex);\n\tdata->regmap = regmap;\n\tdata->dev = dev;\n\tdata->irq = i2c->irq;\n\n\tidev->channels = bu27008_channels;\n\tidev->num_channels = ARRAY_SIZE(bu27008_channels);\n\tidev->name = data->cd->name;\n\tidev->info = &bu27008_info;\n\tidev->modes = INDIO_DIRECT_MODE;\n\tidev->available_scan_masks = bu27008_scan_masks;\n\n\tret = data->cd->chip_init(data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (i2c->irq) {\n\t\tret = bu27008_setup_trigger(data, idev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_info(dev, \"No IRQ, buffered mode disabled\\n\");\n\t}\n\n\tret = devm_iio_device_register(dev, idev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Unable to register iio device\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bu27008_of_match[] = {\n\t{ .compatible = \"rohm,bu27008\", .data = &bu27008_chip },\n\t{ .compatible = \"rohm,bu27010\", .data = &bu27010_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bu27008_of_match);\n\nstatic struct i2c_driver bu27008_i2c_driver = {\n\t.driver = {\n\t\t.name = \"bu27008\",\n\t\t.of_match_table = bu27008_of_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = bu27008_probe,\n};\nmodule_i2c_driver(bu27008_i2c_driver);\n\nMODULE_DESCRIPTION(\"ROHM BU27008 and BU27010 colour sensor driver\");\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_GTS_HELPER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}