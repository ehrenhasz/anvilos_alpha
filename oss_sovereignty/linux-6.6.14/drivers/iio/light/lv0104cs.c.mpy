{
  "module_name": "lv0104cs.c",
  "hash_id": "32cc63b0af9c28d75596a91124c766e9b42a7e3384ece07a11397205b1e573f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/lv0104cs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define LV0104CS_REGVAL_MEASURE\t\t0xE0\n#define LV0104CS_REGVAL_SLEEP\t\t0x00\n\n#define LV0104CS_SCALE_0_25X\t\t0\n#define LV0104CS_SCALE_1X\t\t1\n#define LV0104CS_SCALE_2X\t\t2\n#define LV0104CS_SCALE_8X\t\t3\n#define LV0104CS_SCALE_SHIFT\t\t3\n\n#define LV0104CS_INTEG_12_5MS\t\t0\n#define LV0104CS_INTEG_100MS\t\t1\n#define LV0104CS_INTEG_200MS\t\t2\n#define LV0104CS_INTEG_SHIFT\t\t1\n\n#define LV0104CS_CALIBSCALE_UNITY\t31\n\nstruct lv0104cs_private {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 calibscale;\n\tu8 scale;\n\tu8 int_time;\n};\n\nstruct lv0104cs_mapping {\n\tint val;\n\tint val2;\n\tu8 regval;\n};\n\nstatic const struct lv0104cs_mapping lv0104cs_calibscales[] = {\n\t{ 0, 666666, 0x81 },\n\t{ 0, 800000, 0x82 },\n\t{ 0, 857142, 0x83 },\n\t{ 0, 888888, 0x84 },\n\t{ 0, 909090, 0x85 },\n\t{ 0, 923076, 0x86 },\n\t{ 0, 933333, 0x87 },\n\t{ 0, 941176, 0x88 },\n\t{ 0, 947368, 0x89 },\n\t{ 0, 952380, 0x8A },\n\t{ 0, 956521, 0x8B },\n\t{ 0, 960000, 0x8C },\n\t{ 0, 962962, 0x8D },\n\t{ 0, 965517, 0x8E },\n\t{ 0, 967741, 0x8F },\n\t{ 0, 969696, 0x90 },\n\t{ 0, 971428, 0x91 },\n\t{ 0, 972972, 0x92 },\n\t{ 0, 974358, 0x93 },\n\t{ 0, 975609, 0x94 },\n\t{ 0, 976744, 0x95 },\n\t{ 0, 977777, 0x96 },\n\t{ 0, 978723, 0x97 },\n\t{ 0, 979591, 0x98 },\n\t{ 0, 980392, 0x99 },\n\t{ 0, 981132, 0x9A },\n\t{ 0, 981818, 0x9B },\n\t{ 0, 982456, 0x9C },\n\t{ 0, 983050, 0x9D },\n\t{ 0, 983606, 0x9E },\n\t{ 0, 984126, 0x9F },\n\t{ 1, 0, 0x80 },\n\t{ 1, 16129, 0xBF },\n\t{ 1, 16666, 0xBE },\n\t{ 1, 17241, 0xBD },\n\t{ 1, 17857, 0xBC },\n\t{ 1, 18518, 0xBB },\n\t{ 1, 19230, 0xBA },\n\t{ 1, 20000, 0xB9 },\n\t{ 1, 20833, 0xB8 },\n\t{ 1, 21739, 0xB7 },\n\t{ 1, 22727, 0xB6 },\n\t{ 1, 23809, 0xB5 },\n\t{ 1, 24999, 0xB4 },\n\t{ 1, 26315, 0xB3 },\n\t{ 1, 27777, 0xB2 },\n\t{ 1, 29411, 0xB1 },\n\t{ 1, 31250, 0xB0 },\n\t{ 1, 33333, 0xAF },\n\t{ 1, 35714, 0xAE },\n\t{ 1, 38461, 0xAD },\n\t{ 1, 41666, 0xAC },\n\t{ 1, 45454, 0xAB },\n\t{ 1, 50000, 0xAA },\n\t{ 1, 55555, 0xA9 },\n\t{ 1, 62500, 0xA8 },\n\t{ 1, 71428, 0xA7 },\n\t{ 1, 83333, 0xA6 },\n\t{ 1, 100000, 0xA5 },\n\t{ 1, 125000, 0xA4 },\n\t{ 1, 166666, 0xA3 },\n\t{ 1, 250000, 0xA2 },\n\t{ 1, 500000, 0xA1 },\n};\n\nstatic const struct lv0104cs_mapping lv0104cs_scales[] = {\n\t{ 0, 250000, LV0104CS_SCALE_0_25X << LV0104CS_SCALE_SHIFT },\n\t{ 1, 0, LV0104CS_SCALE_1X << LV0104CS_SCALE_SHIFT },\n\t{ 2, 0, LV0104CS_SCALE_2X << LV0104CS_SCALE_SHIFT },\n\t{ 8, 0, LV0104CS_SCALE_8X << LV0104CS_SCALE_SHIFT },\n};\n\nstatic const struct lv0104cs_mapping lv0104cs_int_times[] = {\n\t{ 0, 12500, LV0104CS_INTEG_12_5MS << LV0104CS_INTEG_SHIFT },\n\t{ 0, 100000, LV0104CS_INTEG_100MS << LV0104CS_INTEG_SHIFT },\n\t{ 0, 200000, LV0104CS_INTEG_200MS << LV0104CS_INTEG_SHIFT },\n};\n\nstatic int lv0104cs_write_reg(struct i2c_client *client, u8 regval)\n{\n\tint ret;\n\n\tret = i2c_master_send(client, (char *)&regval, sizeof(regval));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(regval))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int lv0104cs_read_adc(struct i2c_client *client, u16 *adc_output)\n{\n\t__be16 regval;\n\tint ret;\n\n\tret = i2c_master_recv(client, (char *)&regval, sizeof(regval));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(regval))\n\t\treturn -EIO;\n\n\t*adc_output = be16_to_cpu(regval);\n\n\treturn 0;\n}\n\nstatic int lv0104cs_get_lux(struct lv0104cs_private *lv0104cs,\n\t\t\t\tint *val, int *val2)\n{\n\tu8 regval = LV0104CS_REGVAL_MEASURE;\n\tu16 adc_output;\n\tint ret;\n\n\tregval |= lv0104cs_scales[lv0104cs->scale].regval;\n\tregval |= lv0104cs_int_times[lv0104cs->int_time].regval;\n\tret = lv0104cs_write_reg(lv0104cs->client, regval);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (lv0104cs->int_time) {\n\tcase LV0104CS_INTEG_12_5MS:\n\t\tmsleep(50);\n\t\tbreak;\n\n\tcase LV0104CS_INTEG_100MS:\n\t\tmsleep(150);\n\t\tbreak;\n\n\tcase LV0104CS_INTEG_200MS:\n\t\tmsleep(250);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = lv0104cs_read_adc(lv0104cs->client, &adc_output);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lv0104cs_write_reg(lv0104cs->client, LV0104CS_REGVAL_SLEEP);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (lv0104cs->scale) {\n\tcase LV0104CS_SCALE_0_25X:\n\t\t*val = adc_output * 4;\n\t\t*val2 = 0;\n\t\treturn 0;\n\n\tcase LV0104CS_SCALE_1X:\n\t\t*val = adc_output;\n\t\t*val2 = 0;\n\t\treturn 0;\n\n\tcase LV0104CS_SCALE_2X:\n\t\t*val = adc_output / 2;\n\t\t*val2 = (adc_output % 2) * 500000;\n\t\treturn 0;\n\n\tcase LV0104CS_SCALE_8X:\n\t\t*val = adc_output / 8;\n\t\t*val2 = (adc_output % 8) * 125000;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int lv0104cs_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct lv0104cs_private *lv0104cs = iio_priv(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lv0104cs->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = lv0104cs_get_lux(lv0104cs, val, val2);\n\t\tif (ret)\n\t\t\tgoto err_mutex;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = lv0104cs_calibscales[lv0104cs->calibscale].val;\n\t\t*val2 = lv0104cs_calibscales[lv0104cs->calibscale].val2;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = lv0104cs_scales[lv0104cs->scale].val;\n\t\t*val2 = lv0104cs_scales[lv0104cs->scale].val2;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = lv0104cs_int_times[lv0104cs->int_time].val;\n\t\t*val2 = lv0104cs_int_times[lv0104cs->int_time].val2;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nerr_mutex:\n\tmutex_unlock(&lv0104cs->lock);\n\n\treturn ret;\n}\n\nstatic int lv0104cs_set_calibscale(struct lv0104cs_private *lv0104cs,\n\t\t\t\tint val, int val2)\n{\n\tint calibscale = val * 1000000 + val2;\n\tint floor, ceil, mid;\n\tint ret, i, index;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_calibscales) - 1; i++) {\n\t\tfloor = lv0104cs_calibscales[i].val * 1000000\n\t\t\t\t+ lv0104cs_calibscales[i].val2;\n\t\tceil = lv0104cs_calibscales[i + 1].val * 1000000\n\t\t\t\t+ lv0104cs_calibscales[i + 1].val2;\n\t\tmid = (floor + ceil) / 2;\n\n\t\t \n\t\tif (calibscale >= floor && calibscale < mid) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (calibscale >= mid && calibscale <= ceil) {\n\t\t\tindex = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(lv0104cs_calibscales) - 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lv0104cs->lock);\n\n\t \n\tret = lv0104cs_write_reg(lv0104cs->client,\n\t\t\tlv0104cs_calibscales[index].regval);\n\tif (ret)\n\t\tgoto err_mutex;\n\n\tlv0104cs->calibscale = index;\n\nerr_mutex:\n\tmutex_unlock(&lv0104cs->lock);\n\n\treturn ret;\n}\n\nstatic int lv0104cs_set_scale(struct lv0104cs_private *lv0104cs,\n\t\t\t\tint val, int val2)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_scales); i++) {\n\t\tif (val != lv0104cs_scales[i].val)\n\t\t\tcontinue;\n\n\t\tif (val2 == lv0104cs_scales[i].val2)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(lv0104cs_scales))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lv0104cs->lock);\n\tlv0104cs->scale = i;\n\tmutex_unlock(&lv0104cs->lock);\n\n\treturn 0;\n}\n\nstatic int lv0104cs_set_int_time(struct lv0104cs_private *lv0104cs,\n\t\t\t\tint val, int val2)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_int_times); i++) {\n\t\tif (val != lv0104cs_int_times[i].val)\n\t\t\tcontinue;\n\n\t\tif (val2 == lv0104cs_int_times[i].val2)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(lv0104cs_int_times))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lv0104cs->lock);\n\tlv0104cs->int_time = i;\n\tmutex_unlock(&lv0104cs->lock);\n\n\treturn 0;\n}\n\nstatic int lv0104cs_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tstruct lv0104cs_private *lv0104cs = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_LIGHT)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn lv0104cs_set_calibscale(lv0104cs, val, val2);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn lv0104cs_set_scale(lv0104cs, val, val2);\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn lv0104cs_set_int_time(lv0104cs, val, val2);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t lv0104cs_show_calibscale_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_calibscales); i++) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\tlv0104cs_calibscales[i].val,\n\t\t\t\tlv0104cs_calibscales[i].val2);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t lv0104cs_show_scale_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_scales); i++) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\tlv0104cs_scales[i].val,\n\t\t\t\tlv0104cs_scales[i].val2);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t lv0104cs_show_int_time_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lv0104cs_int_times); i++) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\tlv0104cs_int_times[i].val,\n\t\t\t\tlv0104cs_int_times[i].val2);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(calibscale_available, 0444,\n\t\t\t\tlv0104cs_show_calibscale_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(scale_available, 0444,\n\t\t\t\tlv0104cs_show_scale_avail, NULL, 0);\nstatic IIO_DEV_ATTR_INT_TIME_AVAIL(lv0104cs_show_int_time_avail);\n\nstatic struct attribute *lv0104cs_attributes[] = {\n\t&iio_dev_attr_calibscale_available.dev_attr.attr,\n\t&iio_dev_attr_scale_available.dev_attr.attr,\n\t&iio_dev_attr_integration_time_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lv0104cs_attribute_group = {\n\t.attrs = lv0104cs_attributes,\n};\n\nstatic const struct iio_info lv0104cs_info = {\n\t.attrs = &lv0104cs_attribute_group,\n\t.read_raw = &lv0104cs_read_raw,\n\t.write_raw = &lv0104cs_write_raw,\n};\n\nstatic const struct iio_chan_spec lv0104cs_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n};\n\nstatic int lv0104cs_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct lv0104cs_private *lv0104cs;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*lv0104cs));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tlv0104cs = iio_priv(indio_dev);\n\n\ti2c_set_clientdata(client, lv0104cs);\n\tlv0104cs->client = client;\n\n\tmutex_init(&lv0104cs->lock);\n\n\tlv0104cs->calibscale = LV0104CS_CALIBSCALE_UNITY;\n\tlv0104cs->scale = LV0104CS_SCALE_1X;\n\tlv0104cs->int_time = LV0104CS_INTEG_200MS;\n\n\tret = lv0104cs_write_reg(lv0104cs->client,\n\t\t\tlv0104cs_calibscales[LV0104CS_CALIBSCALE_UNITY].regval);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = lv0104cs_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lv0104cs_channels);\n\tindio_dev->name = client->name;\n\tindio_dev->info = &lv0104cs_info;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id lv0104cs_id[] = {\n\t{ \"lv0104cs\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lv0104cs_id);\n\nstatic struct i2c_driver lv0104cs_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"lv0104cs\",\n\t},\n\t.id_table\t= lv0104cs_id,\n\t.probe\t\t= lv0104cs_probe,\n};\nmodule_i2c_driver(lv0104cs_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"LV0104CS Ambient Light Sensor Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}