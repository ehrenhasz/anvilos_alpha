{
  "module_name": "adjd_s311.c",
  "hash_id": "38eee13280df24f592d1a7ed707f15fc195c8a785f0ae4a50ebf10d2f7759f95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/adjd_s311.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/bitmap.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define ADJD_S311_DRV_NAME \"adjd_s311\"\n\n#define ADJD_S311_CTRL\t\t0x00\n#define ADJD_S311_CONFIG\t0x01\n#define ADJD_S311_CAP_RED\t0x06\n#define ADJD_S311_CAP_GREEN\t0x07\n#define ADJD_S311_CAP_BLUE\t0x08\n#define ADJD_S311_CAP_CLEAR\t0x09\n#define ADJD_S311_INT_RED\t0x0a\n#define ADJD_S311_INT_GREEN\t0x0c\n#define ADJD_S311_INT_BLUE\t0x0e\n#define ADJD_S311_INT_CLEAR\t0x10\n#define ADJD_S311_DATA_RED\t0x40\n#define ADJD_S311_DATA_GREEN\t0x42\n#define ADJD_S311_DATA_BLUE\t0x44\n#define ADJD_S311_DATA_CLEAR\t0x46\n#define ADJD_S311_OFFSET_RED\t0x48\n#define ADJD_S311_OFFSET_GREEN\t0x49\n#define ADJD_S311_OFFSET_BLUE\t0x4a\n#define ADJD_S311_OFFSET_CLEAR\t0x4b\n\n#define ADJD_S311_CTRL_GOFS\t0x02\n#define ADJD_S311_CTRL_GSSR\t0x01\n#define ADJD_S311_CAP_MASK\t0x0f\n#define ADJD_S311_INT_MASK\t0x0fff\n#define ADJD_S311_DATA_MASK\t0x03ff\n\nstruct adjd_s311_data {\n\tstruct i2c_client *client;\n\tstruct {\n\t\ts16 chans[4];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nenum adjd_s311_channel_idx {\n\tIDX_RED, IDX_GREEN, IDX_BLUE, IDX_CLEAR\n};\n\n#define ADJD_S311_DATA_REG(chan) (ADJD_S311_DATA_RED + (chan) * 2)\n#define ADJD_S311_INT_REG(chan) (ADJD_S311_INT_RED + (chan) * 2)\n#define ADJD_S311_CAP_REG(chan) (ADJD_S311_CAP_RED + (chan))\n\nstatic int adjd_s311_req_data(struct iio_dev *indio_dev)\n{\n\tstruct adjd_s311_data *data = iio_priv(indio_dev);\n\tint tries = 10;\n\n\tint ret = i2c_smbus_write_byte_data(data->client, ADJD_S311_CTRL,\n\t\tADJD_S311_CTRL_GSSR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (tries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, ADJD_S311_CTRL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(ret & ADJD_S311_CTRL_GSSR))\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"adjd_s311_req_data() failed, data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int adjd_s311_read_data(struct iio_dev *indio_dev, u8 reg, int *val)\n{\n\tstruct adjd_s311_data *data = iio_priv(indio_dev);\n\n\tint ret = adjd_s311_req_data(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_word_data(data->client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret & ADJD_S311_DATA_MASK;\n\n\treturn 0;\n}\n\nstatic irqreturn_t adjd_s311_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adjd_s311_data *data = iio_priv(indio_dev);\n\ts64 time_ns = iio_get_time_ns(indio_dev);\n\tint i, j = 0;\n\n\tint ret = adjd_s311_req_data(indio_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\tADJD_S311_DATA_REG(i));\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tdata->scan.chans[j++] = ret & ADJD_S311_DATA_MASK;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan, time_ns);\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n#define ADJD_S311_CHANNEL(_color, _scan_idx) { \\\n\t.type = IIO_INTENSITY, \\\n\t.modified = 1, \\\n\t.address = (IDX_##_color), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN) | \\\n\t\tBIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.channel2 = (IIO_MOD_LIGHT_##_color), \\\n\t.scan_index = (_scan_idx), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 10, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec adjd_s311_channels[] = {\n\tADJD_S311_CHANNEL(RED, 0),\n\tADJD_S311_CHANNEL(GREEN, 1),\n\tADJD_S311_CHANNEL(BLUE, 2),\n\tADJD_S311_CHANNEL(CLEAR, 3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int adjd_s311_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct adjd_s311_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = adjd_s311_read_data(indio_dev,\n\t\t\tADJD_S311_DATA_REG(chan->address), val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\tADJD_S311_CAP_REG(chan->address));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret & ADJD_S311_CAP_MASK;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\tADJD_S311_INT_REG(chan->address));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = 0;\n\t\t \n\t\t*val2 = ret & ADJD_S311_INT_MASK;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adjd_s311_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct adjd_s311_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tif (val < 0 || val > ADJD_S311_CAP_MASK)\n\t\t\treturn -EINVAL;\n\n\t\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\tADJD_S311_CAP_REG(chan->address), val);\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0 || val2 < 0 || val2 > ADJD_S311_INT_MASK)\n\t\t\treturn -EINVAL;\n\n\t\treturn i2c_smbus_write_word_data(data->client,\n\t\t\tADJD_S311_INT_REG(chan->address), val2);\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info adjd_s311_info = {\n\t.read_raw = adjd_s311_read_raw,\n\t.write_raw = adjd_s311_write_raw,\n};\n\nstatic int adjd_s311_probe(struct i2c_client *client)\n{\n\tstruct adjd_s311_data *data;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &adjd_s311_info;\n\tindio_dev->name = ADJD_S311_DRV_NAME;\n\tindio_dev->channels = adjd_s311_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adjd_s311_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\terr = devm_iio_triggered_buffer_setup(&client->dev, indio_dev, NULL,\n\t\t\t\t\t      adjd_s311_trigger_handler, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id adjd_s311_id[] = {\n\t{ \"adjd_s311\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adjd_s311_id);\n\nstatic struct i2c_driver adjd_s311_driver = {\n\t.driver = {\n\t\t.name\t= ADJD_S311_DRV_NAME,\n\t},\n\t.probe\t\t= adjd_s311_probe,\n\t.id_table\t= adjd_s311_id,\n};\nmodule_i2c_driver(adjd_s311_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"ADJD-S311 color sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}