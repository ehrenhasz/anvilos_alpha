{
  "module_name": "bh1780.c",
  "hash_id": "f11acd862c3061b24f5c8723e1ad346a5e3a03612cbf31f553a7ebd4a5b0e06f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/bh1780.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/bitops.h>\n\n#define BH1780_CMD_BIT\t\tBIT(7)\n#define BH1780_REG_CONTROL\t0x00\n#define BH1780_REG_PARTID\t0x0A\n#define BH1780_REG_MANFID\t0x0B\n#define BH1780_REG_DLOW\t\t0x0C\n#define BH1780_REG_DHIGH\t0x0D\n\n#define BH1780_REVMASK\t\tGENMASK(3,0)\n#define BH1780_POWMASK\t\tGENMASK(1,0)\n#define BH1780_POFF\t\t(0x0)\n#define BH1780_PON\t\t(0x3)\n\n \n#define BH1780_PON_DELAY\t2\n \n#define BH1780_INTERVAL\t\t250\n\nstruct bh1780_data {\n\tstruct i2c_client *client;\n};\n\nstatic int bh1780_write(struct bh1780_data *bh1780, u8 reg, u8 val)\n{\n\tint ret = i2c_smbus_write_byte_data(bh1780->client,\n\t\t\t\t\t    BH1780_CMD_BIT | reg,\n\t\t\t\t\t    val);\n\tif (ret < 0)\n\t\tdev_err(&bh1780->client->dev,\n\t\t\t\"i2c_smbus_write_byte_data failed error \"\n\t\t\t\"%d, register %01x\\n\",\n\t\t\tret, reg);\n\treturn ret;\n}\n\nstatic int bh1780_read(struct bh1780_data *bh1780, u8 reg)\n{\n\tint ret = i2c_smbus_read_byte_data(bh1780->client,\n\t\t\t\t\t   BH1780_CMD_BIT | reg);\n\tif (ret < 0)\n\t\tdev_err(&bh1780->client->dev,\n\t\t\t\"i2c_smbus_read_byte_data failed error \"\n\t\t\t\"%d, register %01x\\n\",\n\t\t\tret, reg);\n\treturn ret;\n}\n\nstatic int bh1780_read_word(struct bh1780_data *bh1780, u8 reg)\n{\n\tint ret = i2c_smbus_read_word_data(bh1780->client,\n\t\t\t\t\t   BH1780_CMD_BIT | reg);\n\tif (ret < 0)\n\t\tdev_err(&bh1780->client->dev,\n\t\t\t\"i2c_smbus_read_word_data failed error \"\n\t\t\t\"%d, register %01x\\n\",\n\t\t\tret, reg);\n\treturn ret;\n}\n\nstatic int bh1780_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg, unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct bh1780_data *bh1780 = iio_priv(indio_dev);\n\tint ret;\n\n\tif (!readval)\n\t\treturn bh1780_write(bh1780, (u8)reg, (u8)writeval);\n\n\tret = bh1780_read(bh1780, (u8)reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*readval = ret;\n\n\treturn 0;\n}\n\nstatic int bh1780_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bh1780_data *bh1780 = iio_priv(indio_dev);\n\tint value;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tpm_runtime_get_sync(&bh1780->client->dev);\n\t\t\tvalue = bh1780_read_word(bh1780, BH1780_REG_DLOW);\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\t\t\tpm_runtime_mark_last_busy(&bh1780->client->dev);\n\t\t\tpm_runtime_put_autosuspend(&bh1780->client->dev);\n\t\t\t*val = value;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\t*val2 = BH1780_INTERVAL * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info bh1780_info = {\n\t.read_raw = bh1780_read_raw,\n\t.debugfs_reg_access = bh1780_debugfs_reg_access,\n};\n\nstatic const struct iio_chan_spec bh1780_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME)\n\t}\n};\n\nstatic int bh1780_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct bh1780_data *bh1780;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct iio_dev *indio_dev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -EIO;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*bh1780));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tbh1780 = iio_priv(indio_dev);\n\tbh1780->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\n\t \n\tret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_PON);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(BH1780_PON_DELAY);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = bh1780_read(bh1780, BH1780_REG_PARTID);\n\tif (ret < 0)\n\t\tgoto out_disable_pm;\n\tdev_info(&client->dev,\n\t\t \"Ambient Light Sensor, Rev : %lu\\n\",\n\t\t (ret & BH1780_REVMASK));\n\n\t \n\tpm_runtime_set_autosuspend_delay(&client->dev, 5000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put(&client->dev);\n\n\tindio_dev->info = &bh1780_info;\n\tindio_dev->name = \"bh1780\";\n\tindio_dev->channels = bh1780_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bh1780_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto out_disable_pm;\n\treturn 0;\n\nout_disable_pm:\n\tpm_runtime_put_noidle(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\treturn ret;\n}\n\nstatic void bh1780_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct bh1780_data *bh1780 = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_get_sync(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_POFF);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to power off (%pe)\\n\",\n\t\t\tERR_PTR(ret));\n}\n\nstatic int bh1780_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct bh1780_data *bh1780 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_POFF);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to runtime suspend\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bh1780_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct bh1780_data *bh1780 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = bh1780_write(bh1780, BH1780_REG_CONTROL, BH1780_PON);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to runtime resume\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(BH1780_PON_DELAY + BH1780_INTERVAL);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(bh1780_dev_pm_ops, bh1780_runtime_suspend,\n\t\t\t\tbh1780_runtime_resume, NULL);\n\nstatic const struct i2c_device_id bh1780_id[] = {\n\t{ \"bh1780\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, bh1780_id);\n\nstatic const struct of_device_id of_bh1780_match[] = {\n\t{ .compatible = \"rohm,bh1780gli\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_bh1780_match);\n\nstatic struct i2c_driver bh1780_driver = {\n\t.probe\t\t= bh1780_probe,\n\t.remove\t\t= bh1780_remove,\n\t.id_table\t= bh1780_id,\n\t.driver = {\n\t\t.name = \"bh1780\",\n\t\t.pm = pm_ptr(&bh1780_dev_pm_ops),\n\t\t.of_match_table = of_bh1780_match,\n\t},\n};\n\nmodule_i2c_driver(bh1780_driver);\n\nMODULE_DESCRIPTION(\"ROHM BH1780GLI Ambient Light Sensor Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}