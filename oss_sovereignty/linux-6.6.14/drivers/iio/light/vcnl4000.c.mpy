{
  "module_name": "vcnl4000.c",
  "hash_id": "41edb87ffed896236d392f60d62a0ec588a2fdf51740079afb4ee473e8b433cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/vcnl4000.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/units.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define VCNL4000_DRV_NAME \"vcnl4000\"\n#define VCNL4000_PROD_ID\t0x01\n#define VCNL4010_PROD_ID\t0x02  \n#define VCNL4040_PROD_ID\t0x86\n#define VCNL4200_PROD_ID\t0x58\n\n#define VCNL4000_COMMAND\t0x80  \n#define VCNL4000_PROD_REV\t0x81  \n#define VCNL4010_PROX_RATE      0x82  \n#define VCNL4000_LED_CURRENT\t0x83  \n#define VCNL4000_AL_PARAM\t0x84  \n#define VCNL4010_ALS_PARAM      0x84  \n#define VCNL4000_AL_RESULT_HI\t0x85  \n#define VCNL4000_AL_RESULT_LO\t0x86  \n#define VCNL4000_PS_RESULT_HI\t0x87  \n#define VCNL4000_PS_RESULT_LO\t0x88  \n#define VCNL4000_PS_MEAS_FREQ\t0x89  \n#define VCNL4010_INT_CTRL\t0x89  \n#define VCNL4000_PS_MOD_ADJ\t0x8a  \n#define VCNL4010_LOW_THR_HI     0x8a  \n#define VCNL4010_LOW_THR_LO     0x8b  \n#define VCNL4010_HIGH_THR_HI    0x8c  \n#define VCNL4010_HIGH_THR_LO    0x8d  \n#define VCNL4010_ISR\t\t0x8e  \n\n#define VCNL4200_AL_CONF\t0x00  \n#define VCNL4200_PS_CONF1\t0x03  \n#define VCNL4200_PS_CONF3\t0x04  \n#define VCNL4040_PS_THDL_LM\t0x06  \n#define VCNL4040_PS_THDH_LM\t0x07  \n#define VCNL4040_ALS_THDL_LM\t0x02  \n#define VCNL4040_ALS_THDH_LM\t0x01  \n#define VCNL4200_PS_DATA\t0x08  \n#define VCNL4200_AL_DATA\t0x09  \n#define VCNL4040_INT_FLAGS\t0x0b  \n#define VCNL4200_INT_FLAGS\t0x0d  \n#define VCNL4200_DEV_ID\t\t0x0e  \n\n#define VCNL4040_DEV_ID\t\t0x0c  \n\n \n#define VCNL4000_AL_RDY\t\tBIT(6)  \n#define VCNL4000_PS_RDY\t\tBIT(5)  \n#define VCNL4000_AL_OD\t\tBIT(4)  \n#define VCNL4000_PS_OD\t\tBIT(3)  \n#define VCNL4000_ALS_EN\t\tBIT(2)  \n#define VCNL4000_PROX_EN\tBIT(1)  \n#define VCNL4000_SELF_TIMED_EN\tBIT(0)  \n\n#define VCNL4040_ALS_CONF_ALS_SHUTDOWN\tBIT(0)\n#define VCNL4040_ALS_CONF_IT\t\tGENMASK(7, 6)  \n#define VCNL4040_ALS_CONF_INT_EN\tBIT(1)  \n#define VCNL4040_ALS_CONF_PERS\tGENMASK(3, 2)  \n#define VCNL4040_PS_CONF1_PS_SHUTDOWN\tBIT(0)\n#define VCNL4040_PS_CONF2_PS_IT\tGENMASK(3, 1)  \n#define VCNL4040_CONF1_PS_PERS\tGENMASK(5, 4)  \n#define VCNL4040_PS_CONF2_PS_INT\tGENMASK(9, 8)  \n#define VCNL4040_PS_CONF3_MPS\t\tGENMASK(6, 5)  \n#define VCNL4040_PS_MS_LED_I\t\tGENMASK(10, 8)  \n#define VCNL4040_PS_IF_AWAY\t\tBIT(8)  \n#define VCNL4040_PS_IF_CLOSE\t\tBIT(9)  \n#define VCNL4040_ALS_RISING\t\tBIT(12)  \n#define VCNL4040_ALS_FALLING\t\tBIT(13)  \n\n \n#define VCNL4010_INT_THR_SEL\tBIT(0)  \n#define VCNL4010_INT_THR_EN\tBIT(1)  \n#define VCNL4010_INT_ALS_EN\tBIT(2)  \n#define VCNL4010_INT_PROX_EN\tBIT(3)  \n\n#define VCNL4010_INT_THR_HIGH\t0  \n#define VCNL4010_INT_THR_LOW\t1  \n#define VCNL4010_INT_ALS\t2  \n#define VCNL4010_INT_PROXIMITY\t3  \n\n#define VCNL4010_INT_THR \\\n\t(BIT(VCNL4010_INT_THR_LOW) | BIT(VCNL4010_INT_THR_HIGH))\n#define VCNL4010_INT_DRDY \\\n\t(BIT(VCNL4010_INT_PROXIMITY) | BIT(VCNL4010_INT_ALS))\n\nstatic const int vcnl4010_prox_sampling_frequency[][2] = {\n\t{1, 950000},\n\t{3, 906250},\n\t{7, 812500},\n\t{16, 625000},\n\t{31, 250000},\n\t{62, 500000},\n\t{125, 0},\n\t{250, 0},\n};\n\nstatic const int vcnl4040_ps_it_times[][2] = {\n\t{0, 100},\n\t{0, 150},\n\t{0, 200},\n\t{0, 250},\n\t{0, 300},\n\t{0, 350},\n\t{0, 400},\n\t{0, 800},\n};\n\nstatic const int vcnl4200_ps_it_times[][2] = {\n\t{0, 96},\n\t{0, 144},\n\t{0, 192},\n\t{0, 384},\n\t{0, 768},\n\t{0, 864},\n};\n\nstatic const int vcnl4040_als_it_times[][2] = {\n\t{0, 80000},\n\t{0, 160000},\n\t{0, 320000},\n\t{0, 640000},\n};\n\nstatic const int vcnl4200_als_it_times[][2] = {\n\t{0, 50000},\n\t{0, 100000},\n\t{0, 200000},\n\t{0, 400000},\n};\n\nstatic const int vcnl4040_ps_calibbias_ua[][2] = {\n\t{0, 50000},\n\t{0, 75000},\n\t{0, 100000},\n\t{0, 120000},\n\t{0, 140000},\n\t{0, 160000},\n\t{0, 180000},\n\t{0, 200000},\n};\n\nstatic const int vcnl4040_als_persistence[] = {1, 2, 4, 8};\nstatic const int vcnl4040_ps_persistence[] = {1, 2, 3, 4};\nstatic const int vcnl4040_ps_oversampling_ratio[] = {1, 2, 4, 8};\n\n#define VCNL4000_SLEEP_DELAY_MS\t2000  \n\nenum vcnl4000_device_ids {\n\tVCNL4000,\n\tVCNL4010,\n\tVCNL4040,\n\tVCNL4200,\n};\n\nstruct vcnl4200_channel {\n\tu8 reg;\n\tktime_t last_measurement;\n\tktime_t sampling_rate;\n\tstruct mutex lock;\n};\n\nstruct vcnl4000_data {\n\tstruct i2c_client *client;\n\tenum vcnl4000_device_ids id;\n\tint rev;\n\tint al_scale;\n\tu8 ps_int;\t\t \n\tu8 als_int;\t\t \n\tconst struct vcnl4000_chip_spec *chip_spec;\n\tstruct mutex vcnl4000_lock;\n\tstruct vcnl4200_channel vcnl4200_al;\n\tstruct vcnl4200_channel vcnl4200_ps;\n\tuint32_t near_level;\n};\n\nstruct vcnl4000_chip_spec {\n\tconst char *prod;\n\tstruct iio_chan_spec const *channels;\n\tconst int num_channels;\n\tconst struct iio_info *info;\n\tconst struct iio_buffer_setup_ops *buffer_setup_ops;\n\tint (*init)(struct vcnl4000_data *data);\n\tint (*measure_light)(struct vcnl4000_data *data, int *val);\n\tint (*measure_proximity)(struct vcnl4000_data *data, int *val);\n\tint (*set_power_state)(struct vcnl4000_data *data, bool on);\n\tirqreturn_t (*irq_thread)(int irq, void *priv);\n\tirqreturn_t (*trig_buffer_func)(int irq, void *priv);\n\n\tu8 int_reg;\n\tconst int(*ps_it_times)[][2];\n\tconst int num_ps_it_times;\n\tconst int(*als_it_times)[][2];\n\tconst int num_als_it_times;\n\tconst unsigned int ulux_step;\n};\n\nstatic const struct i2c_device_id vcnl4000_id[] = {\n\t{ \"vcnl4000\", VCNL4000 },\n\t{ \"vcnl4010\", VCNL4010 },\n\t{ \"vcnl4020\", VCNL4010 },\n\t{ \"vcnl4040\", VCNL4040 },\n\t{ \"vcnl4200\", VCNL4200 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vcnl4000_id);\n\nstatic int vcnl4000_set_power_state(struct vcnl4000_data *data, bool on)\n{\n\t \n\treturn 0;\n}\n\nstatic int vcnl4000_init(struct vcnl4000_data *data)\n{\n\tint ret, prod_id;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4000_PROD_REV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprod_id = ret >> 4;\n\tswitch (prod_id) {\n\tcase VCNL4000_PROD_ID:\n\t\tif (data->id != VCNL4000)\n\t\t\tdev_warn(&data->client->dev,\n\t\t\t\t\t\"wrong device id, use vcnl4000\");\n\t\tbreak;\n\tcase VCNL4010_PROD_ID:\n\t\tif (data->id != VCNL4010)\n\t\t\tdev_warn(&data->client->dev,\n\t\t\t\t\t\"wrong device id, use vcnl4010/4020\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tdata->rev = ret & 0xf;\n\tdata->al_scale = 250000;\n\n\treturn data->chip_spec->set_power_state(data, true);\n};\n\nstatic ssize_t vcnl4000_write_als_enable(struct vcnl4000_data *data, bool en)\n{\n\tint ret;\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (en)\n\t\tret &= ~VCNL4040_ALS_CONF_ALS_SHUTDOWN;\n\telse\n\t\tret |= VCNL4040_ALS_CONF_ALS_SHUTDOWN;\n\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_AL_CONF, ret);\n\nout:\n\tmutex_unlock(&data->vcnl4000_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t vcnl4000_write_ps_enable(struct vcnl4000_data *data, bool en)\n{\n\tint ret;\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (en)\n\t\tret &= ~VCNL4040_PS_CONF1_PS_SHUTDOWN;\n\telse\n\t\tret |= VCNL4040_PS_CONF1_PS_SHUTDOWN;\n\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF1, ret);\n\nout:\n\tmutex_unlock(&data->vcnl4000_lock);\n\n\treturn ret;\n}\n\nstatic int vcnl4200_set_power_state(struct vcnl4000_data *data, bool on)\n{\n\tint ret;\n\n\t \n\tif (!on && (data->ps_int || data->als_int))\n\t\treturn 0;\n\n\tret = vcnl4000_write_als_enable(data, on);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vcnl4000_write_ps_enable(data, on);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (on) {\n\t\t \n\t\tdata->vcnl4200_al.last_measurement = ktime_get();\n\t\tdata->vcnl4200_ps.last_measurement = ktime_get();\n\t}\n\n\treturn 0;\n}\n\nstatic int vcnl4200_init(struct vcnl4000_data *data)\n{\n\tint ret, id;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_DEV_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tid = ret & 0xff;\n\n\tif (id != VCNL4200_PROD_ID) {\n\t\tret = i2c_smbus_read_word_data(data->client, VCNL4040_DEV_ID);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tid = ret & 0xff;\n\n\t\tif (id != VCNL4040_PROD_ID)\n\t\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&data->client->dev, \"device id 0x%x\", id);\n\n\tdata->rev = (ret >> 8) & 0xf;\n\tdata->ps_int = 0;\n\tdata->als_int = 0;\n\n\tdata->vcnl4200_al.reg = VCNL4200_AL_DATA;\n\tdata->vcnl4200_ps.reg = VCNL4200_PS_DATA;\n\tswitch (id) {\n\tcase VCNL4200_PROD_ID:\n\t\t \n\t\tdata->vcnl4200_al.sampling_rate = ktime_set(0, 60000 * 1000);\n\t\t \n\t\tdata->vcnl4200_ps.sampling_rate = ktime_set(0, 5760 * 1000);\n\t\tbreak;\n\tcase VCNL4040_PROD_ID:\n\t\t \n\t\tdata->vcnl4200_al.sampling_rate = ktime_set(0, 96000 * 1000);\n\t\t \n\t\tdata->vcnl4200_ps.sampling_rate = ktime_set(0, 6000 * 1000);\n\t\tbreak;\n\t}\n\tdata->al_scale = data->chip_spec->ulux_step;\n\tmutex_init(&data->vcnl4200_al.lock);\n\tmutex_init(&data->vcnl4200_ps.lock);\n\n\tret = data->chip_spec->set_power_state(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n};\n\nstatic int vcnl4000_read_data(struct vcnl4000_data *data, u8 data_reg, int *val)\n{\n\ts32 ret;\n\n\tret = i2c_smbus_read_word_swapped(data->client, data_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn 0;\n}\n\nstatic int vcnl4000_write_data(struct vcnl4000_data *data, u8 data_reg, int val)\n{\n\tif (val > U16_MAX)\n\t\treturn -ERANGE;\n\n\treturn i2c_smbus_write_word_swapped(data->client, data_reg, val);\n}\n\n\nstatic int vcnl4000_measure(struct vcnl4000_data *data, u8 req_mask,\n\t\t\t\tu8 rdy_mask, u8 data_reg, int *val)\n{\n\tint tries = 20;\n\tint ret;\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4000_COMMAND,\n\t\t\t\t\treq_mask);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\twhile (tries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, VCNL4000_COMMAND);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (ret & rdy_mask)\n\t\t\tbreak;\n\t\tmsleep(20);  \n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"vcnl4000_measure() failed, data not ready\\n\");\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\tret = vcnl4000_read_data(data, data_reg, val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tmutex_unlock(&data->vcnl4000_lock);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic int vcnl4200_measure(struct vcnl4000_data *data,\n\t\tstruct vcnl4200_channel *chan, int *val)\n{\n\tint ret;\n\ts64 delta;\n\tktime_t next_measurement;\n\n\tmutex_lock(&chan->lock);\n\n\tnext_measurement = ktime_add(chan->last_measurement,\n\t\t\tchan->sampling_rate);\n\tdelta = ktime_us_delta(next_measurement, ktime_get());\n\tif (delta > 0)\n\t\tusleep_range(delta, delta + 500);\n\tchan->last_measurement = ktime_get();\n\n\tmutex_unlock(&chan->lock);\n\n\tret = i2c_smbus_read_word_data(data->client, chan->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int vcnl4000_measure_light(struct vcnl4000_data *data, int *val)\n{\n\treturn vcnl4000_measure(data,\n\t\t\tVCNL4000_AL_OD, VCNL4000_AL_RDY,\n\t\t\tVCNL4000_AL_RESULT_HI, val);\n}\n\nstatic int vcnl4200_measure_light(struct vcnl4000_data *data, int *val)\n{\n\treturn vcnl4200_measure(data, &data->vcnl4200_al, val);\n}\n\nstatic int vcnl4000_measure_proximity(struct vcnl4000_data *data, int *val)\n{\n\treturn vcnl4000_measure(data,\n\t\t\tVCNL4000_PS_OD, VCNL4000_PS_RDY,\n\t\t\tVCNL4000_PS_RESULT_HI, val);\n}\n\nstatic int vcnl4200_measure_proximity(struct vcnl4000_data *data, int *val)\n{\n\treturn vcnl4200_measure(data, &data->vcnl4200_ps, val);\n}\n\nstatic int vcnl4010_read_proxy_samp_freq(struct vcnl4000_data *data, int *val,\n\t\t\t\t\t int *val2)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4010_PROX_RATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret >= ARRAY_SIZE(vcnl4010_prox_sampling_frequency))\n\t\treturn -EINVAL;\n\n\t*val = vcnl4010_prox_sampling_frequency[ret][0];\n\t*val2 = vcnl4010_prox_sampling_frequency[ret][1];\n\n\treturn 0;\n}\n\nstatic bool vcnl4010_is_in_periodic_mode(struct vcnl4000_data *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4000_COMMAND);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!(ret & VCNL4000_SELF_TIMED_EN);\n}\n\nstatic int vcnl4000_set_pm_runtime_state(struct vcnl4000_data *data, bool on)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int vcnl4040_read_als_it(struct vcnl4000_data *data, int *val, int *val2)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = FIELD_GET(VCNL4040_ALS_CONF_IT, ret);\n\tif (ret >= data->chip_spec->num_als_it_times)\n\t\treturn -EINVAL;\n\n\t*val = (*data->chip_spec->als_it_times)[ret][0];\n\t*val2 = (*data->chip_spec->als_it_times)[ret][1];\n\n\treturn 0;\n}\n\nstatic ssize_t vcnl4040_write_als_it(struct vcnl4000_data *data, int val)\n{\n\tunsigned int i;\n\tint ret;\n\tu16 regval;\n\n\tfor (i = 0; i < data->chip_spec->num_als_it_times; i++) {\n\t\tif (val == (*data->chip_spec->als_it_times)[i][1])\n\t\t\tbreak;\n\t}\n\n\tif (i == data->chip_spec->num_als_it_times)\n\t\treturn -EINVAL;\n\n\tdata->vcnl4200_al.sampling_rate = ktime_set(0, val * 1200);\n\tdata->al_scale = div_u64(mul_u32_u32(data->chip_spec->ulux_step,\n\t\t\t (*data->chip_spec->als_it_times)[0][1]),\n\t\t\t val);\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tregval = FIELD_PREP(VCNL4040_ALS_CONF_IT, i);\n\tregval |= (ret & ~VCNL4040_ALS_CONF_IT);\n\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\tVCNL4200_AL_CONF,\n\t\t\t\t\tregval);\n\nout_unlock:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic int vcnl4040_read_ps_it(struct vcnl4000_data *data, int *val, int *val2)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = FIELD_GET(VCNL4040_PS_CONF2_PS_IT, ret);\n\n\tif (ret >= data->chip_spec->num_ps_it_times)\n\t\treturn -EINVAL;\n\n\t*val = (*data->chip_spec->ps_it_times)[ret][0];\n\t*val2 = (*data->chip_spec->ps_it_times)[ret][1];\n\n\treturn 0;\n}\n\nstatic ssize_t vcnl4040_write_ps_it(struct vcnl4000_data *data, int val)\n{\n\tunsigned int i;\n\tint ret, index = -1;\n\tu16 regval;\n\n\tfor (i = 0; i < data->chip_spec->num_ps_it_times; i++) {\n\t\tif (val == (*data->chip_spec->ps_it_times)[i][1]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tdata->vcnl4200_ps.sampling_rate = ktime_set(0, val * 60 * NSEC_PER_USEC);\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tregval = (ret & ~VCNL4040_PS_CONF2_PS_IT) |\n\t    FIELD_PREP(VCNL4040_PS_CONF2_PS_IT, index);\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF1,\n\t\t\t\t\tregval);\n\nout:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_read_als_period(struct vcnl4000_data *data, int *val, int *val2)\n{\n\tint ret, ret_pers, it;\n\tint64_t val_c;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret_pers = FIELD_GET(VCNL4040_ALS_CONF_PERS, ret);\n\tif (ret_pers >= ARRAY_SIZE(vcnl4040_als_persistence))\n\t\treturn -EINVAL;\n\n\tit = FIELD_GET(VCNL4040_ALS_CONF_IT, ret);\n\tif (it >= data->chip_spec->num_als_it_times)\n\t\treturn -EINVAL;\n\n\tval_c = mul_u32_u32((*data->chip_spec->als_it_times)[it][1],\n\t\t\t    vcnl4040_als_persistence[ret_pers]);\n\t*val = div_u64_rem(val_c, MICRO, val2);\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic ssize_t vcnl4040_write_als_period(struct vcnl4000_data *data, int val, int val2)\n{\n\tunsigned int i;\n\tint ret, it;\n\tu16 regval;\n\tu64 val_n = mul_u32_u32(val, MICRO) + val2;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tit = FIELD_GET(VCNL4040_ALS_CONF_IT, ret);\n\tif (it >= data->chip_spec->num_als_it_times)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(vcnl4040_als_persistence) - 1; i++) {\n\t\tif (val_n < mul_u32_u32(vcnl4040_als_persistence[i],\n\t\t\t\t\t(*data->chip_spec->als_it_times)[it][1]))\n\t\t\tbreak;\n\t}\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tregval = FIELD_PREP(VCNL4040_ALS_CONF_PERS, i);\n\tregval |= (ret & ~VCNL4040_ALS_CONF_PERS);\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_AL_CONF,\n\t\t\t\t\tregval);\n\nout_unlock:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_read_ps_period(struct vcnl4000_data *data, int *val, int *val2)\n{\n\tint ret, ret_pers, it;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret_pers = FIELD_GET(VCNL4040_CONF1_PS_PERS, ret);\n\tif (ret_pers >= ARRAY_SIZE(vcnl4040_ps_persistence))\n\t\treturn -EINVAL;\n\n\tit = FIELD_GET(VCNL4040_PS_CONF2_PS_IT, ret);\n\tif (it >= data->chip_spec->num_ps_it_times)\n\t\treturn -EINVAL;\n\n\t*val = (*data->chip_spec->ps_it_times)[it][0];\n\t*val2 = (*data->chip_spec->ps_it_times)[it][1] *\n\t\tvcnl4040_ps_persistence[ret_pers];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic ssize_t vcnl4040_write_ps_period(struct vcnl4000_data *data, int val, int val2)\n{\n\tint ret, it, i;\n\tu16 regval;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tit = FIELD_GET(VCNL4040_PS_CONF2_PS_IT, ret);\n\tif (it >= data->chip_spec->num_ps_it_times)\n\t\treturn -EINVAL;\n\n\tif (val > 0)\n\t\ti = ARRAY_SIZE(vcnl4040_ps_persistence) - 1;\n\telse {\n\t\tfor (i = 0; i < ARRAY_SIZE(vcnl4040_ps_persistence) - 1; i++) {\n\t\t\tif (val2 <= vcnl4040_ps_persistence[i] *\n\t\t\t\t\t(*data->chip_spec->ps_it_times)[it][1])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tregval = FIELD_PREP(VCNL4040_CONF1_PS_PERS, i);\n\tregval |= (ret & ~VCNL4040_CONF1_PS_PERS);\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF1,\n\t\t\t\t\tregval);\n\nout_unlock:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_read_ps_oversampling_ratio(struct vcnl4000_data *data, int *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = FIELD_GET(VCNL4040_PS_CONF3_MPS, ret);\n\tif (ret >= ARRAY_SIZE(vcnl4040_ps_oversampling_ratio))\n\t\treturn -EINVAL;\n\n\t*val = vcnl4040_ps_oversampling_ratio[ret];\n\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_write_ps_oversampling_ratio(struct vcnl4000_data *data, int val)\n{\n\tunsigned int i;\n\tint ret;\n\tu16 regval;\n\n\tfor (i = 0; i < ARRAY_SIZE(vcnl4040_ps_oversampling_ratio); i++) {\n\t\tif (val == vcnl4040_ps_oversampling_ratio[i])\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(vcnl4040_ps_oversampling_ratio))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF3);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tregval = FIELD_PREP(VCNL4040_PS_CONF3_MPS, i);\n\tregval |= (ret & ~VCNL4040_PS_CONF3_MPS);\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF3,\n\t\t\t\t\tregval);\n\nout_unlock:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_read_ps_calibbias(struct vcnl4000_data *data, int *val, int *val2)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = FIELD_GET(VCNL4040_PS_MS_LED_I, ret);\n\tif (ret >= ARRAY_SIZE(vcnl4040_ps_calibbias_ua))\n\t\treturn -EINVAL;\n\n\t*val = vcnl4040_ps_calibbias_ua[ret][0];\n\t*val2 = vcnl4040_ps_calibbias_ua[ret][1];\n\n\treturn ret;\n}\n\nstatic ssize_t vcnl4040_write_ps_calibbias(struct vcnl4000_data *data, int val)\n{\n\tunsigned int i;\n\tint ret;\n\tu16 regval;\n\n\tfor (i = 0; i < ARRAY_SIZE(vcnl4040_ps_calibbias_ua); i++) {\n\t\tif (val == vcnl4040_ps_calibbias_ua[i][1])\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(vcnl4040_ps_calibbias_ua))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF3);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tregval = (ret & ~VCNL4040_PS_MS_LED_I);\n\tregval |= FIELD_PREP(VCNL4040_PS_MS_LED_I, i);\n\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF3,\n\t\t\t\t\tregval);\n\nout_unlock:\n\tmutex_unlock(&data->vcnl4000_lock);\n\treturn ret;\n}\n\nstatic int vcnl4000_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = vcnl4000_set_pm_runtime_state(data, true);\n\t\tif  (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = data->chip_spec->measure_light(data, val);\n\t\t\tif (!ret)\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = data->chip_spec->measure_proximity(data, val);\n\t\t\tif (!ret)\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tvcnl4000_set_pm_runtime_state(data, false);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_LIGHT)\n\t\t\treturn -EINVAL;\n\n\t\t*val = 0;\n\t\t*val2 = data->al_scale;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = vcnl4040_read_als_it(data, val, val2);\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = vcnl4040_read_ps_it(data, val, val2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = vcnl4040_read_ps_oversampling_ratio(data, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = vcnl4040_read_ps_calibbias(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4040_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\treturn vcnl4040_write_als_it(data, val2);\n\t\tcase IIO_PROXIMITY:\n\t\t\treturn vcnl4040_write_ps_it(data, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\treturn vcnl4040_write_ps_oversampling_ratio(data, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\treturn vcnl4040_write_ps_calibbias(data, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4040_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\t*vals = (int *)(*data->chip_spec->als_it_times);\n\t\t\t*length = 2 * data->chip_spec->num_als_it_times;\n\t\t\tbreak;\n\t\tcase IIO_PROXIMITY:\n\t\t\t*vals = (int *)(*data->chip_spec->ps_it_times);\n\t\t\t*length = 2 * data->chip_spec->num_ps_it_times;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\t*vals = (int *)vcnl4040_ps_oversampling_ratio;\n\t\t\t*length = ARRAY_SIZE(vcnl4040_ps_oversampling_ratio);\n\t\t\t*type = IIO_VAL_INT;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\t*vals = (int *)vcnl4040_ps_calibbias_ua;\n\t\t\t*length = 2 * ARRAY_SIZE(vcnl4040_ps_calibbias_ua);\n\t\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4010_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (vcnl4010_is_in_periodic_mode(data)) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tret = vcnl4000_read_raw(indio_dev, chan, val, val2,\n\t\t\t\t\t\tmask);\n\t\t}\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = vcnl4010_read_proxy_samp_freq(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4010_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (int *)vcnl4010_prox_sampling_frequency;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = 2 * ARRAY_SIZE(vcnl4010_prox_sampling_frequency);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4010_write_proxy_samp_freq(struct vcnl4000_data *data, int val,\n\t\t\t\t\t  int val2)\n{\n\tunsigned int i;\n\tint index = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(vcnl4010_prox_sampling_frequency); i++) {\n\t\tif (val == vcnl4010_prox_sampling_frequency[i][0] &&\n\t\t    val2 == vcnl4010_prox_sampling_frequency[i][1]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_byte_data(data->client, VCNL4010_PROX_RATE,\n\t\t\t\t\t index);\n}\n\nstatic int vcnl4010_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (vcnl4010_is_in_periodic_mode(data)) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PROXIMITY:\n\t\t\tret = vcnl4010_write_proxy_samp_freq(data, val, val2);\n\t\t\tgoto end;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\nend:\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int vcnl4010_read_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int *val, int *val2)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = vcnl4000_read_data(data, VCNL4010_HIGH_THR_HI,\n\t\t\t\t\t\t val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tret = vcnl4000_read_data(data, VCNL4010_LOW_THR_HI,\n\t\t\t\t\t\t val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4010_write_event(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = vcnl4000_write_data(data, VCNL4010_HIGH_THR_HI,\n\t\t\t\t\t\t  val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tret = vcnl4000_write_data(data, VCNL4010_LOW_THR_HI,\n\t\t\t\t\t\t  val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4040_read_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int *val, int *val2)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\treturn vcnl4040_read_als_period(data, val, val2);\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t\t\t       VCNL4040_ALS_THDH_LM);\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t\t\t       VCNL4040_ALS_THDL_LM);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\treturn vcnl4040_read_ps_period(data, val, val2);\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t\t\t       VCNL4040_PS_THDH_LM);\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t\t\t       VCNL4040_PS_THDL_LM);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = ret;\n\treturn IIO_VAL_INT;\n}\n\nstatic int vcnl4040_write_event(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\treturn vcnl4040_write_als_period(data, val, val2);\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t\t\tVCNL4040_ALS_THDH_LM,\n\t\t\t\t\t\t\t\tval);\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t\t\tVCNL4040_ALS_THDL_LM,\n\t\t\t\t\t\t\t\tval);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\treturn vcnl4040_write_ps_period(data, val, val2);\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tswitch (dir) {\n\t\t\tcase IIO_EV_DIR_RISING:\n\t\t\t\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t\t\tVCNL4040_PS_THDH_LM,\n\t\t\t\t\t\t\t\tval);\n\t\t\t\tbreak;\n\t\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t\tret = i2c_smbus_write_word_data(data->client,\n\t\t\t\t\t\t\t\tVCNL4040_PS_THDL_LM,\n\t\t\t\t\t\t\t\tval);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\treturn IIO_VAL_INT;\n}\n\nstatic bool vcnl4010_is_thr_enabled(struct vcnl4000_data *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4010_INT_CTRL);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!(ret & VCNL4010_INT_THR_EN);\n}\n\nstatic int vcnl4010_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn vcnl4010_is_thr_enabled(data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4010_config_threshold(struct iio_dev *indio_dev, bool state)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint icr;\n\tint command;\n\n\tif (state) {\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tcommand = VCNL4000_SELF_TIMED_EN | VCNL4000_PROX_EN;\n\n\t\t \n\t\ticr = VCNL4010_INT_THR_EN;\n\t} else {\n\t\tif (!vcnl4010_is_thr_enabled(data))\n\t\t\treturn 0;\n\n\t\tcommand = 0;\n\t\ticr = 0;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4000_COMMAND,\n\t\t\t\t\tcommand);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4010_INT_CTRL, icr);\n\nend:\n\tif (state)\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int vcnl4010_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int state)\n{\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn vcnl4010_config_threshold(indio_dev, state);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4040_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tint ret;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->als_int = FIELD_GET(VCNL4040_ALS_CONF_INT_EN, ret);\n\n\t\treturn data->als_int;\n\tcase IIO_PROXIMITY:\n\t\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->ps_int = FIELD_GET(VCNL4040_PS_CONF2_PS_INT, ret);\n\n\t\treturn (dir == IIO_EV_DIR_RISING) ?\n\t\t\tFIELD_GET(VCNL4040_PS_IF_AWAY, ret) :\n\t\t\tFIELD_GET(VCNL4040_PS_IF_CLOSE, ret);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl4040_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir, int state)\n{\n\tint ret = -EINVAL;\n\tu16 val, mask;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->vcnl4000_lock);\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tret = i2c_smbus_read_word_data(data->client, VCNL4200_AL_CONF);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tmask = VCNL4040_ALS_CONF_INT_EN;\n\t\tif (state)\n\t\t\tval = (ret | mask);\n\t\telse\n\t\t\tval = (ret & ~mask);\n\n\t\tdata->als_int = FIELD_GET(VCNL4040_ALS_CONF_INT_EN, val);\n\t\tret = i2c_smbus_write_word_data(data->client, VCNL4200_AL_CONF,\n\t\t\t\t\t\tval);\n\t\tbreak;\n\tcase IIO_PROXIMITY:\n\t\tret = i2c_smbus_read_word_data(data->client, VCNL4200_PS_CONF1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tmask = VCNL4040_PS_IF_AWAY;\n\t\telse\n\t\t\tmask = VCNL4040_PS_IF_CLOSE;\n\n\t\tval = state ? (ret | mask) : (ret & ~mask);\n\n\t\tdata->ps_int = FIELD_GET(VCNL4040_PS_CONF2_PS_INT, val);\n\t\tret = i2c_smbus_write_word_data(data->client, VCNL4200_PS_CONF1,\n\t\t\t\t\t\tval);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&data->vcnl4000_lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t vcnl4040_irq_thread(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(data->client, data->chip_spec->int_reg);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (ret & VCNL4040_PS_IF_CLOSE) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\tif (ret & VCNL4040_PS_IF_AWAY) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\tif (ret & VCNL4040_ALS_FALLING) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\tif (ret & VCNL4040_ALS_RISING) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t vcnl4000_read_near_level(struct iio_dev *indio_dev,\n\t\t\t\t\tuintptr_t priv,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tchar *buf)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%u\\n\", data->near_level);\n}\n\nstatic irqreturn_t vcnl4010_irq_thread(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tunsigned long isr;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4010_ISR);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tisr = ret;\n\n\tif (isr & VCNL4010_INT_THR) {\n\t\tif (test_bit(VCNL4010_INT_THR_LOW, &isr)) {\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_UNMOD_EVENT_CODE(\n\t\t\t\t\t       IIO_PROXIMITY,\n\t\t\t\t\t       1,\n\t\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t\t       IIO_EV_DIR_FALLING),\n\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t}\n\n\t\tif (test_bit(VCNL4010_INT_THR_HIGH, &isr)) {\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_UNMOD_EVENT_CODE(\n\t\t\t\t\t       IIO_PROXIMITY,\n\t\t\t\t\t       1,\n\t\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t\t       IIO_EV_DIR_RISING),\n\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t}\n\n\t\ti2c_smbus_write_byte_data(data->client, VCNL4010_ISR,\n\t\t\t\t\t  isr & VCNL4010_INT_THR);\n\t}\n\n\tif (isr & VCNL4010_INT_DRDY && iio_buffer_enabled(indio_dev))\n\t\tiio_trigger_poll_nested(indio_dev->trig);\n\nend:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t vcnl4010_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tconst unsigned long *active_scan_mask = indio_dev->active_scan_mask;\n\tu16 buffer[8] __aligned(8) = {0};  \n\tbool data_read = false;\n\tunsigned long isr;\n\tint val = 0;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, VCNL4010_ISR);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tisr = ret;\n\n\tif (test_bit(0, active_scan_mask)) {\n\t\tif (test_bit(VCNL4010_INT_PROXIMITY, &isr)) {\n\t\t\tret = vcnl4000_read_data(data,\n\t\t\t\t\t\t VCNL4000_PS_RESULT_HI,\n\t\t\t\t\t\t &val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\n\t\t\tbuffer[0] = val;\n\t\t\tdata_read = true;\n\t\t}\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4010_ISR,\n\t\t\t\t\tisr & VCNL4010_INT_DRDY);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tif (!data_read)\n\t\tgoto end;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, buffer,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nend:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int vcnl4010_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint cmd;\n\n\t \n\tif (vcnl4010_is_in_periodic_mode(data))\n\t\treturn -EBUSY;\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4010_INT_CTRL,\n\t\t\t\t\tVCNL4010_INT_PROX_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcmd = VCNL4000_SELF_TIMED_EN | VCNL4000_PROX_EN;\n\treturn i2c_smbus_write_byte_data(data->client, VCNL4000_COMMAND, cmd);\n}\n\nstatic int vcnl4010_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client, VCNL4010_INT_CTRL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(data->client, VCNL4000_COMMAND, 0);\n}\n\nstatic const struct iio_buffer_setup_ops vcnl4010_buffer_ops = {\n\t.postenable = &vcnl4010_buffer_postenable,\n\t.predisable = &vcnl4010_buffer_predisable,\n};\n\nstatic const struct iio_chan_spec_ext_info vcnl4000_ext_info[] = {\n\t{\n\t\t.name = \"nearlevel\",\n\t\t.shared = IIO_SEPARATE,\n\t\t.read = vcnl4000_read_near_level,\n\t},\n\t{   }\n};\n\nstatic const struct iio_event_spec vcnl4000_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t}\n};\n\nstatic const struct iio_event_spec vcnl4040_als_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) | BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\nstatic const struct iio_event_spec vcnl4040_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\nstatic const struct iio_chan_spec vcnl4000_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t}, {\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.ext_info = vcnl4000_ext_info,\n\t}\n};\n\nstatic const struct iio_chan_spec vcnl4010_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.scan_index = -1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t}, {\n\t\t.type = IIO_PROXIMITY,\n\t\t.scan_index = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.event_spec = vcnl4000_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(vcnl4000_event_spec),\n\t\t.ext_info = vcnl4000_ext_info,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_chan_spec vcnl4040_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_INT_TIME),\n\t\t.event_spec = vcnl4040_als_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(vcnl4040_als_event_spec),\n\t}, {\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.ext_info = vcnl4000_ext_info,\n\t\t.event_spec = vcnl4040_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(vcnl4040_event_spec),\n\t}\n};\n\nstatic const struct iio_info vcnl4000_info = {\n\t.read_raw = vcnl4000_read_raw,\n};\n\nstatic const struct iio_info vcnl4010_info = {\n\t.read_raw = vcnl4010_read_raw,\n\t.read_avail = vcnl4010_read_avail,\n\t.write_raw = vcnl4010_write_raw,\n\t.read_event_value = vcnl4010_read_event,\n\t.write_event_value = vcnl4010_write_event,\n\t.read_event_config = vcnl4010_read_event_config,\n\t.write_event_config = vcnl4010_write_event_config,\n};\n\nstatic const struct iio_info vcnl4040_info = {\n\t.read_raw = vcnl4000_read_raw,\n\t.write_raw = vcnl4040_write_raw,\n\t.read_event_value = vcnl4040_read_event,\n\t.write_event_value = vcnl4040_write_event,\n\t.read_event_config = vcnl4040_read_event_config,\n\t.write_event_config = vcnl4040_write_event_config,\n\t.read_avail = vcnl4040_read_avail,\n};\n\nstatic const struct vcnl4000_chip_spec vcnl4000_chip_spec_cfg[] = {\n\t[VCNL4000] = {\n\t\t.prod = \"VCNL4000\",\n\t\t.init = vcnl4000_init,\n\t\t.measure_light = vcnl4000_measure_light,\n\t\t.measure_proximity = vcnl4000_measure_proximity,\n\t\t.set_power_state = vcnl4000_set_power_state,\n\t\t.channels = vcnl4000_channels,\n\t\t.num_channels = ARRAY_SIZE(vcnl4000_channels),\n\t\t.info = &vcnl4000_info,\n\t},\n\t[VCNL4010] = {\n\t\t.prod = \"VCNL4010/4020\",\n\t\t.init = vcnl4000_init,\n\t\t.measure_light = vcnl4000_measure_light,\n\t\t.measure_proximity = vcnl4000_measure_proximity,\n\t\t.set_power_state = vcnl4000_set_power_state,\n\t\t.channels = vcnl4010_channels,\n\t\t.num_channels = ARRAY_SIZE(vcnl4010_channels),\n\t\t.info = &vcnl4010_info,\n\t\t.irq_thread = vcnl4010_irq_thread,\n\t\t.trig_buffer_func = vcnl4010_trigger_handler,\n\t\t.buffer_setup_ops = &vcnl4010_buffer_ops,\n\t},\n\t[VCNL4040] = {\n\t\t.prod = \"VCNL4040\",\n\t\t.init = vcnl4200_init,\n\t\t.measure_light = vcnl4200_measure_light,\n\t\t.measure_proximity = vcnl4200_measure_proximity,\n\t\t.set_power_state = vcnl4200_set_power_state,\n\t\t.channels = vcnl4040_channels,\n\t\t.num_channels = ARRAY_SIZE(vcnl4040_channels),\n\t\t.info = &vcnl4040_info,\n\t\t.irq_thread = vcnl4040_irq_thread,\n\t\t.int_reg = VCNL4040_INT_FLAGS,\n\t\t.ps_it_times = &vcnl4040_ps_it_times,\n\t\t.num_ps_it_times = ARRAY_SIZE(vcnl4040_ps_it_times),\n\t\t.als_it_times = &vcnl4040_als_it_times,\n\t\t.num_als_it_times = ARRAY_SIZE(vcnl4040_als_it_times),\n\t\t.ulux_step = 100000,\n\t},\n\t[VCNL4200] = {\n\t\t.prod = \"VCNL4200\",\n\t\t.init = vcnl4200_init,\n\t\t.measure_light = vcnl4200_measure_light,\n\t\t.measure_proximity = vcnl4200_measure_proximity,\n\t\t.set_power_state = vcnl4200_set_power_state,\n\t\t.channels = vcnl4040_channels,\n\t\t.num_channels = ARRAY_SIZE(vcnl4000_channels),\n\t\t.info = &vcnl4040_info,\n\t\t.irq_thread = vcnl4040_irq_thread,\n\t\t.int_reg = VCNL4200_INT_FLAGS,\n\t\t.ps_it_times = &vcnl4200_ps_it_times,\n\t\t.num_ps_it_times = ARRAY_SIZE(vcnl4200_ps_it_times),\n\t\t.als_it_times = &vcnl4200_als_it_times,\n\t\t.num_als_it_times = ARRAY_SIZE(vcnl4200_als_it_times),\n\t\t.ulux_step = 24000,\n\t},\n};\n\nstatic const struct iio_trigger_ops vcnl4010_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic int vcnl4010_probe_trigger(struct iio_dev *indio_dev)\n{\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\tstruct iio_trigger *trigger;\n\n\ttrigger = devm_iio_trigger_alloc(&client->dev, \"%s-dev%d\",\n\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t iio_device_id(indio_dev));\n\tif (!trigger)\n\t\treturn -ENOMEM;\n\n\ttrigger->ops = &vcnl4010_trigger_ops;\n\tiio_trigger_set_drvdata(trigger, indio_dev);\n\n\treturn devm_iio_trigger_register(&client->dev, trigger);\n}\n\nstatic int vcnl4000_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct vcnl4000_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->id = id->driver_data;\n\tdata->chip_spec = &vcnl4000_chip_spec_cfg[data->id];\n\n\tmutex_init(&data->vcnl4000_lock);\n\n\tret = data->chip_spec->init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&client->dev, \"%s Ambient light/proximity sensor, Rev: %02x\\n\",\n\t\tdata->chip_spec->prod, data->rev);\n\n\tif (device_property_read_u32(&client->dev, \"proximity-near-level\",\n\t\t\t\t     &data->near_level))\n\t\tdata->near_level = 0;\n\n\tindio_dev->info = data->chip_spec->info;\n\tindio_dev->channels = data->chip_spec->channels;\n\tindio_dev->num_channels = data->chip_spec->num_channels;\n\tindio_dev->name = VCNL4000_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (data->chip_spec->trig_buffer_func &&\n\t    data->chip_spec->buffer_setup_ops) {\n\t\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      data->chip_spec->trig_buffer_func,\n\t\t\t\t\t\t      data->chip_spec->buffer_setup_ops);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"unable to setup iio triggered buffer\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (client->irq && data->chip_spec->irq_thread) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, data->chip_spec->irq_thread,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"vcnl4000_irq\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"irq request failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = vcnl4010_probe_trigger(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto fail_poweroff;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto fail_poweroff;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, VCNL4000_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\treturn 0;\nfail_poweroff:\n\tdata->chip_spec->set_power_state(data, false);\n\treturn ret;\n}\n\nstatic const struct of_device_id vcnl_4000_of_match[] = {\n\t{\n\t\t.compatible = \"vishay,vcnl4000\",\n\t\t.data = (void *)VCNL4000,\n\t},\n\t{\n\t\t.compatible = \"vishay,vcnl4010\",\n\t\t.data = (void *)VCNL4010,\n\t},\n\t{\n\t\t.compatible = \"vishay,vcnl4020\",\n\t\t.data = (void *)VCNL4010,\n\t},\n\t{\n\t\t.compatible = \"vishay,vcnl4040\",\n\t\t.data = (void *)VCNL4040,\n\t},\n\t{\n\t\t.compatible = \"vishay,vcnl4200\",\n\t\t.data = (void *)VCNL4200,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, vcnl_4000_of_match);\n\nstatic void vcnl4000_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tpm_runtime_dont_use_autosuspend(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tret = data->chip_spec->set_power_state(data, false);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to power down (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic int vcnl4000_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\treturn data->chip_spec->set_power_state(data, false);\n}\n\nstatic int vcnl4000_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct vcnl4000_data *data = iio_priv(indio_dev);\n\n\treturn data->chip_spec->set_power_state(data, true);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(vcnl4000_pm_ops, vcnl4000_runtime_suspend,\n\t\t\t\t vcnl4000_runtime_resume, NULL);\n\nstatic struct i2c_driver vcnl4000_driver = {\n\t.driver = {\n\t\t.name   = VCNL4000_DRV_NAME,\n\t\t.pm\t= pm_ptr(&vcnl4000_pm_ops),\n\t\t.of_match_table = vcnl_4000_of_match,\n\t},\n\t.probe = vcnl4000_probe,\n\t.id_table = vcnl4000_id,\n\t.remove\t= vcnl4000_remove,\n};\n\nmodule_i2c_driver(vcnl4000_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_AUTHOR(\"Mathieu Othacehe <m.othacehe@gmail.com>\");\nMODULE_DESCRIPTION(\"Vishay VCNL4000 proximity/ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}