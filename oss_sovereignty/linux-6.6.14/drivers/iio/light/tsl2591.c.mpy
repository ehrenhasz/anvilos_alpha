{
  "module_name": "tsl2591.c",
  "hash_id": "7c3bcb4f9a83c37fe70ff73b0ef649ce4301dc7f293f1f342c15ea1719ffa042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tsl2591.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define TSL2591_FVAL_TO_MSEC(x) (((x) + 1) * 100)\n \n#define TSL2591_FVAL_TO_SEC(x) ((x) + 1)\n \n#define TSL2591_SEC_TO_FVAL(x) ((x) - 1)\n\n \n#define TSL2591_ENABLE      0x00\n#define TSL2591_CONTROL     0x01\n#define TSL2591_AILTL       0x04\n#define TSL2591_AILTH       0x05\n#define TSL2591_AIHTL       0x06\n#define TSL2591_AIHTH       0x07\n#define TSL2591_NP_AILTL    0x08\n#define TSL2591_NP_AILTH    0x09\n#define TSL2591_NP_AIHTL    0x0A\n#define TSL2591_NP_AIHTH    0x0B\n#define TSL2591_PERSIST     0x0C\n#define TSL2591_PACKAGE_ID  0x11\n#define TSL2591_DEVICE_ID   0x12\n#define TSL2591_STATUS      0x13\n#define TSL2591_C0_DATAL    0x14\n#define TSL2591_C0_DATAH    0x15\n#define TSL2591_C1_DATAL    0x16\n#define TSL2591_C1_DATAH    0x17\n\n \n#define TSL2591_CMD_NOP             0xA0\n#define TSL2591_CMD_SF_INTSET       0xE4\n#define TSL2591_CMD_SF_CALS_I       0xE5\n#define TSL2591_CMD_SF_CALS_NPI     0xE7\n#define TSL2591_CMD_SF_CNP_ALSI     0xEA\n\n \n#define TSL2591_PWR_ON              0x01\n#define TSL2591_PWR_OFF             0x00\n#define TSL2591_ENABLE_ALS          0x02\n#define TSL2591_ENABLE_ALS_INT      0x10\n#define TSL2591_ENABLE_SLEEP_INT    0x40\n#define TSL2591_ENABLE_NP_INT       0x80\n\n \n#define TSL2591_CTRL_ALS_INTEGRATION_100MS  0x00\n#define TSL2591_CTRL_ALS_INTEGRATION_200MS  0x01\n#define TSL2591_CTRL_ALS_INTEGRATION_300MS  0x02\n#define TSL2591_CTRL_ALS_INTEGRATION_400MS  0x03\n#define TSL2591_CTRL_ALS_INTEGRATION_500MS  0x04\n#define TSL2591_CTRL_ALS_INTEGRATION_600MS  0x05\n#define TSL2591_CTRL_ALS_LOW_GAIN           0x00\n#define TSL2591_CTRL_ALS_MED_GAIN           0x10\n#define TSL2591_CTRL_ALS_HIGH_GAIN          0x20\n#define TSL2591_CTRL_ALS_MAX_GAIN           0x30\n#define TSL2591_CTRL_SYS_RESET              0x80\n\n \n#define TSL2591_PRST_ALS_INT_CYCLE_0        0x00\n#define TSL2591_PRST_ALS_INT_CYCLE_ANY      0x01\n#define TSL2591_PRST_ALS_INT_CYCLE_2        0x02\n#define TSL2591_PRST_ALS_INT_CYCLE_3        0x03\n#define TSL2591_PRST_ALS_INT_CYCLE_5        0x04\n#define TSL2591_PRST_ALS_INT_CYCLE_10       0x05\n#define TSL2591_PRST_ALS_INT_CYCLE_15       0x06\n#define TSL2591_PRST_ALS_INT_CYCLE_20       0x07\n#define TSL2591_PRST_ALS_INT_CYCLE_25       0x08\n#define TSL2591_PRST_ALS_INT_CYCLE_30       0x09\n#define TSL2591_PRST_ALS_INT_CYCLE_35       0x0A\n#define TSL2591_PRST_ALS_INT_CYCLE_40       0x0B\n#define TSL2591_PRST_ALS_INT_CYCLE_45       0x0C\n#define TSL2591_PRST_ALS_INT_CYCLE_50       0x0D\n#define TSL2591_PRST_ALS_INT_CYCLE_55       0x0E\n#define TSL2591_PRST_ALS_INT_CYCLE_60       0x0F\n#define TSL2591_PRST_ALS_INT_CYCLE_MAX      (BIT(4) - 1)\n\n \n#define TSL2591_PACKAGE_ID_MASK  GENMASK(5, 4)\n\n \n#define TSL2591_DEVICE_ID_MASK   GENMASK(7, 0)\n\n \n#define TSL2591_STS_ALS_VALID_MASK   BIT(0)\n#define TSL2591_STS_ALS_INT_MASK     BIT(4)\n#define TSL2591_STS_NPERS_INT_MASK   BIT(5)\n#define TSL2591_STS_VAL_HIGH_MASK    BIT(0)\n\n \n#define TSL2591_PACKAGE_ID_VAL  0x00\n#define TSL2591_DEVICE_ID_VAL   0x50\n\n \n#define TSL2591_POWER_OFF_DELAY_MS   2000\n\n \n#define TSL2591_DEFAULT_ALS_INT_TIME          TSL2591_CTRL_ALS_INTEGRATION_300MS\n#define TSL2591_DEFAULT_ALS_GAIN              TSL2591_CTRL_ALS_MED_GAIN\n#define TSL2591_DEFAULT_ALS_PERSIST           TSL2591_PRST_ALS_INT_CYCLE_ANY\n#define TSL2591_DEFAULT_ALS_LOWER_THRESH      100\n#define TSL2591_DEFAULT_ALS_UPPER_THRESH      1500\n\n \n#define TSL2591_NUM_DATA_REGISTERS     4\n\n \n#define TSL2591_ALS_STS_VALID_COUNT    10\n\n \n#define TSL2591_DELAY_PERIOD_US        10000\n\n \n#define TSL2591_MAX_ALS_INT_TIME_MS    600\n#define TSL2591_ALS_MAX_VALUE\t       (BIT(16) - 1)\n\n \n#define TSL2591_CTRL_ALS_LOW_GAIN_MULTIPLIER   1\n#define TSL2591_CTRL_ALS_MED_GAIN_MULTIPLIER   25\n#define TSL2591_CTRL_ALS_HIGH_GAIN_MULTIPLIER  428\n#define TSL2591_CTRL_ALS_MAX_GAIN_MULTIPLIER   9876\n#define TSL2591_LUX_COEFFICIENT                408\n\nstruct tsl2591_als_settings {\n\tu16 als_lower_thresh;\n\tu16 als_upper_thresh;\n\tu8 als_int_time;\n\tu8 als_persist;\n\tu8 als_gain;\n};\n\nstruct tsl2591_chip {\n\tstruct tsl2591_als_settings als_settings;\n\tstruct i2c_client *client;\n\t \n\tstruct mutex als_mutex;\n\tbool events_enabled;\n};\n\n \nstatic const char * const tsl2591_als_period_list[] = {\n\t\"0.1 0.2 0.3 0.5 1.0 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0\",\n\t\"0.2 0.4 0.6 1.0 2.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0\",\n\t\"0.3 0.6 0.9 1.5 3.0 6.0 7.5 9.0 10.5 12.0 13.5 15.0 16.5 18.0\",\n\t\"0.4 0.8 1.2 2.0 4.0 8.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0\",\n\t\"0.5 1.0 1.5 2.5 5.0 10.0 12.5 15.0 17.5 20.0 22.5 25.0 27.5 30.0\",\n\t\"0.6 1.2 1.8 3.0 6.0 12.0 15.0 18.0 21.0 24.0 27.0 30.0 33.0 36.0\",\n};\n\nstatic const int tsl2591_int_time_available[] = {\n\t1, 2, 3, 4, 5, 6,\n};\n\nstatic const int tsl2591_calibscale_available[] = {\n\t1, 25, 428, 9876,\n};\n\nstatic int tsl2591_set_als_lower_threshold(struct tsl2591_chip *chip,\n\t\t\t\t\t   u16 als_lower_threshold);\nstatic int tsl2591_set_als_upper_threshold(struct tsl2591_chip *chip,\n\t\t\t\t\t   u16 als_upper_threshold);\n\nstatic int tsl2591_gain_to_multiplier(const u8 als_gain)\n{\n\tswitch (als_gain) {\n\tcase TSL2591_CTRL_ALS_LOW_GAIN:\n\t\treturn TSL2591_CTRL_ALS_LOW_GAIN_MULTIPLIER;\n\tcase TSL2591_CTRL_ALS_MED_GAIN:\n\t\treturn TSL2591_CTRL_ALS_MED_GAIN_MULTIPLIER;\n\tcase TSL2591_CTRL_ALS_HIGH_GAIN:\n\t\treturn TSL2591_CTRL_ALS_HIGH_GAIN_MULTIPLIER;\n\tcase TSL2591_CTRL_ALS_MAX_GAIN:\n\t\treturn TSL2591_CTRL_ALS_MAX_GAIN_MULTIPLIER;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_multiplier_to_gain(const u32 multiplier)\n{\n\tswitch (multiplier) {\n\tcase TSL2591_CTRL_ALS_LOW_GAIN_MULTIPLIER:\n\t\treturn TSL2591_CTRL_ALS_LOW_GAIN;\n\tcase TSL2591_CTRL_ALS_MED_GAIN_MULTIPLIER:\n\t\treturn TSL2591_CTRL_ALS_MED_GAIN;\n\tcase TSL2591_CTRL_ALS_HIGH_GAIN_MULTIPLIER:\n\t\treturn TSL2591_CTRL_ALS_HIGH_GAIN;\n\tcase TSL2591_CTRL_ALS_MAX_GAIN_MULTIPLIER:\n\t\treturn TSL2591_CTRL_ALS_MAX_GAIN;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_persist_cycle_to_lit(const u8 als_persist)\n{\n\tswitch (als_persist) {\n\tcase TSL2591_PRST_ALS_INT_CYCLE_ANY:\n\t\treturn 1;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_2:\n\t\treturn 2;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_3:\n\t\treturn 3;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_5:\n\t\treturn 5;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_10:\n\t\treturn 10;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_15:\n\t\treturn 15;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_20:\n\t\treturn 20;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_25:\n\t\treturn 25;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_30:\n\t\treturn 30;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_35:\n\t\treturn 35;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_40:\n\t\treturn 40;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_45:\n\t\treturn 45;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_50:\n\t\treturn 50;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_55:\n\t\treturn 55;\n\tcase TSL2591_PRST_ALS_INT_CYCLE_60:\n\t\treturn 60;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_persist_lit_to_cycle(const u8 als_persist)\n{\n\tswitch (als_persist) {\n\tcase 1:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_ANY;\n\tcase 2:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_2;\n\tcase 3:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_3;\n\tcase 5:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_5;\n\tcase 10:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_10;\n\tcase 15:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_15;\n\tcase 20:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_20;\n\tcase 25:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_25;\n\tcase 30:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_30;\n\tcase 35:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_35;\n\tcase 40:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_40;\n\tcase 45:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_45;\n\tcase 50:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_50;\n\tcase 55:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_55;\n\tcase 60:\n\t\treturn TSL2591_PRST_ALS_INT_CYCLE_60;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_compatible_int_time(struct tsl2591_chip *chip,\n\t\t\t\t       const u32 als_integration_time)\n{\n\tswitch (als_integration_time) {\n\tcase TSL2591_CTRL_ALS_INTEGRATION_100MS:\n\tcase TSL2591_CTRL_ALS_INTEGRATION_200MS:\n\tcase TSL2591_CTRL_ALS_INTEGRATION_300MS:\n\tcase TSL2591_CTRL_ALS_INTEGRATION_400MS:\n\tcase TSL2591_CTRL_ALS_INTEGRATION_500MS:\n\tcase TSL2591_CTRL_ALS_INTEGRATION_600MS:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_als_time_to_fval(const u32 als_integration_time)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tsl2591_int_time_available); i++) {\n\t\tif (als_integration_time == tsl2591_int_time_available[i])\n\t\t\treturn TSL2591_SEC_TO_FVAL(als_integration_time);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tsl2591_compatible_gain(struct tsl2591_chip *chip, const u8 als_gain)\n{\n\tswitch (als_gain) {\n\tcase TSL2591_CTRL_ALS_LOW_GAIN:\n\tcase TSL2591_CTRL_ALS_MED_GAIN:\n\tcase TSL2591_CTRL_ALS_HIGH_GAIN:\n\tcase TSL2591_CTRL_ALS_MAX_GAIN:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_compatible_als_persist_cycle(struct tsl2591_chip *chip,\n\t\t\t\t\t\tconst u32 als_persist)\n{\n\tswitch (als_persist) {\n\tcase TSL2591_PRST_ALS_INT_CYCLE_ANY:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_2:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_3:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_5:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_10:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_15:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_20:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_25:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_30:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_35:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_40:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_45:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_50:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_55:\n\tcase TSL2591_PRST_ALS_INT_CYCLE_60:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_check_als_valid(struct i2c_client *client)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, TSL2591_CMD_NOP | TSL2591_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read register\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn FIELD_GET(TSL2591_STS_ALS_VALID_MASK, ret);\n}\n\nstatic int tsl2591_wait_adc_complete(struct tsl2591_chip *chip)\n{\n\tstruct tsl2591_als_settings settings = chip->als_settings;\n\tstruct i2c_client *client = chip->client;\n\tint delay;\n\tint val;\n\tint ret;\n\n\tdelay = TSL2591_FVAL_TO_MSEC(settings.als_int_time);\n\tif (!delay)\n\t\treturn -EINVAL;\n\n\t \n\tmsleep(delay);\n\n\t \n\tret = readx_poll_timeout(tsl2591_check_als_valid, client,\n\t\t\t\t val, val == TSL2591_STS_VAL_HIGH_MASK,\n\t\t\t\t TSL2591_DELAY_PERIOD_US,\n\t\t\t\t TSL2591_DELAY_PERIOD_US * TSL2591_ALS_STS_VALID_COUNT);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Timed out waiting for valid ALS data\\n\");\n\n\treturn ret;\n}\n\n \nstatic int tsl2591_read_channel_data(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     int *val, int *val2)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tstruct tsl2591_als_settings *settings = &chip->als_settings;\n\tstruct i2c_client *client = chip->client;\n\tu8 als_data[TSL2591_NUM_DATA_REGISTERS];\n\tint counts_per_lux, int_time_fval, gain_multi, lux;\n\tu16 als_ch0, als_ch1;\n\tint ret;\n\n\tret = tsl2591_wait_adc_complete(chip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"No data available. Err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_i2c_block_data(client,\n\t\t\t\t\t    TSL2591_CMD_NOP | TSL2591_C0_DATAL,\n\t\t\t\t\t    sizeof(als_data), als_data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read data bytes\");\n\t\treturn ret;\n\t}\n\n\tals_ch0 = get_unaligned_le16(&als_data[0]);\n\tals_ch1 = get_unaligned_le16(&als_data[2]);\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\n\t\t\t*val = als_ch0;\n\t\telse if (chan->channel2 == IIO_MOD_LIGHT_IR)\n\t\t\t*val = als_ch1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IIO_LIGHT:\n\t\tgain_multi = tsl2591_gain_to_multiplier(settings->als_gain);\n\t\tif (gain_multi < 0) {\n\t\t\tdev_err(&client->dev, \"Invalid multiplier\");\n\t\t\treturn gain_multi;\n\t\t}\n\n\t\tint_time_fval = TSL2591_FVAL_TO_MSEC(settings->als_int_time);\n\t\t \n\t\tcounts_per_lux = (int_time_fval * gain_multi) / TSL2591_LUX_COEFFICIENT;\n\n\t\tdev_dbg(&client->dev, \"Counts Per Lux: %d\\n\", counts_per_lux);\n\n\t\t \n\t\tlux = ((als_ch0 - als_ch1) *\n\t\t       (1000 - ((als_ch1 * 1000) / als_ch0))) / counts_per_lux;\n\n\t\tdev_dbg(&client->dev, \"Raw lux calculation: %d\\n\", lux);\n\n\t\t \n\t\t*val = lux / 1000;\n\n\t\t \n\t\t*val2 = (lux - (*val * 1000)) * 1000;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tsl2591_set_als_gain_int_time(struct tsl2591_chip *chip)\n{\n\tstruct tsl2591_als_settings als_settings = chip->als_settings;\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_CONTROL,\n\t\t\t\t\tals_settings.als_int_time | als_settings.als_gain);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Failed to set als gain & int time\\n\");\n\n\treturn ret;\n}\n\nstatic int tsl2591_set_als_lower_threshold(struct tsl2591_chip *chip,\n\t\t\t\t\t   u16 als_lower_threshold)\n{\n\tstruct tsl2591_als_settings als_settings = chip->als_settings;\n\tstruct i2c_client *client = chip->client;\n\tu16 als_upper_threshold;\n\tu8 als_lower_l;\n\tu8 als_lower_h;\n\tint ret;\n\n\tchip->als_settings.als_lower_thresh = als_lower_threshold;\n\n\t \n\tif (als_lower_threshold >= als_settings.als_upper_thresh) {\n\t\tals_upper_threshold = als_lower_threshold + 1;\n\t\ttsl2591_set_als_upper_threshold(chip, als_upper_threshold);\n\t}\n\n\tals_lower_l = als_lower_threshold;\n\tals_lower_h = als_lower_threshold >> 8;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_AILTL,\n\t\t\t\t\tals_lower_l);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to set als lower threshold\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_AILTH,\n\t\t\t\t\tals_lower_h);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to set als lower threshold\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tsl2591_set_als_upper_threshold(struct tsl2591_chip *chip,\n\t\t\t\t\t   u16 als_upper_threshold)\n{\n\tstruct tsl2591_als_settings als_settings = chip->als_settings;\n\tstruct i2c_client *client = chip->client;\n\tu16 als_lower_threshold;\n\tu8 als_upper_l;\n\tu8 als_upper_h;\n\tint ret;\n\n\tif (als_upper_threshold > TSL2591_ALS_MAX_VALUE)\n\t\treturn -EINVAL;\n\n\tchip->als_settings.als_upper_thresh = als_upper_threshold;\n\n\t \n\tif (als_upper_threshold < als_settings.als_lower_thresh) {\n\t\tals_lower_threshold = als_upper_threshold - 1;\n\t\ttsl2591_set_als_lower_threshold(chip, als_lower_threshold);\n\t}\n\n\tals_upper_l = als_upper_threshold;\n\tals_upper_h = als_upper_threshold >> 8;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_AIHTL,\n\t\t\t\t\tals_upper_l);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to set als upper threshold\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_AIHTH,\n\t\t\t\t\tals_upper_h);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to set als upper threshold\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tsl2591_set_als_persist_cycle(struct tsl2591_chip *chip,\n\t\t\t\t\t u8 als_persist)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_PERSIST,\n\t\t\t\t\tals_persist);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Failed to set als persist cycle\\n\");\n\n\tchip->als_settings.als_persist = als_persist;\n\n\treturn ret;\n}\n\nstatic int tsl2591_set_power_state(struct tsl2591_chip *chip, u8 state)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tTSL2591_CMD_NOP | TSL2591_ENABLE,\n\t\t\t\t\tstate);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to set the power state to %#04x\\n\", state);\n\n\treturn ret;\n}\n\nstatic ssize_t tsl2591_in_illuminance_period_available_show(struct device *dev,\n\t\t\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t       tsl2591_als_period_list[chip->als_settings.als_int_time]);\n}\n\nstatic IIO_DEVICE_ATTR_RO(tsl2591_in_illuminance_period_available, 0);\n\nstatic struct attribute *tsl2591_event_attrs_ctrl[] = {\n\t&iio_dev_attr_tsl2591_in_illuminance_period_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tsl2591_event_attribute_group = {\n\t.attrs = tsl2591_event_attrs_ctrl,\n};\n\nstatic const struct iio_event_spec tsl2591_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec tsl2591_channels[] = {\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t\t     BIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_CALIBSCALE)\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.event_spec = tsl2591_events,\n\t\t.num_event_specs = ARRAY_SIZE(tsl2591_events),\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t\t     BIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_CALIBSCALE)\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t\t     BIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t\t   BIT(IIO_CHAN_INFO_CALIBSCALE)\n\t},\n};\n\nstatic int tsl2591_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tpm_runtime_get_sync(&client->dev);\n\n\tmutex_lock(&chip->als_mutex);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_INTENSITY) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tret = tsl2591_read_channel_data(indio_dev, chan, val, val2);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->type != IIO_LIGHT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tret = tsl2591_read_channel_data(indio_dev, chan, val, val2);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type != IIO_INTENSITY) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\t*val = TSL2591_FVAL_TO_SEC(chip->als_settings.als_int_time);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type != IIO_INTENSITY) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\t*val = tsl2591_gain_to_multiplier(chip->als_settings.als_gain);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&chip->als_mutex);\n\n\tpm_runtime_mark_last_busy(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn ret;\n}\n\nstatic int tsl2591_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tint int_time;\n\tint gain;\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tint_time = tsl2591_als_time_to_fval(val);\n\t\tif (int_time < 0) {\n\t\t\tret = int_time;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tret = tsl2591_compatible_int_time(chip, int_time);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\n\t\tchip->als_settings.als_int_time = int_time;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tgain = tsl2591_multiplier_to_gain(val);\n\t\tif (gain < 0) {\n\t\t\tret = gain;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tret = tsl2591_compatible_gain(chip, gain);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\n\t\tchip->als_settings.als_gain = gain;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tret = tsl2591_set_als_gain_int_time(chip);\n\nerr_unlock:\n\tmutex_unlock(&chip->als_mutex);\n\treturn ret;\n}\n\nstatic int tsl2591_read_available(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  const int **vals, int *type, int *length,\n\t\t\t\t  long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*length = ARRAY_SIZE(tsl2591_int_time_available);\n\t\t*vals = tsl2591_int_time_available;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*length = ARRAY_SIZE(tsl2591_calibscale_available);\n\t\t*vals = tsl2591_calibscale_available;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsl2591_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info, int *val,\n\t\t\t\t    int *val2)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\tint als_persist, int_time, period;\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t*val = chip->als_settings.als_upper_thresh;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*val = chip->als_settings.als_lower_thresh;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       TSL2591_CMD_NOP | TSL2591_PERSIST);\n\t\tif (ret <= 0 || ret > TSL2591_PRST_ALS_INT_CYCLE_MAX)\n\t\t\tgoto err_unlock;\n\n\t\tals_persist = tsl2591_persist_cycle_to_lit(ret);\n\t\tint_time = TSL2591_FVAL_TO_MSEC(chip->als_settings.als_int_time);\n\t\tperiod = als_persist * (int_time * MSEC_PER_SEC);\n\n\t\t*val = period / USEC_PER_SEC;\n\t\t*val2 = period % USEC_PER_SEC;\n\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&chip->als_mutex);\n\treturn ret;\n}\n\nstatic int tsl2591_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info, int val,\n\t\t\t\t     int val2)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tint period, int_time, als_persist;\n\tint ret;\n\n\tif (val < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val > TSL2591_ALS_MAX_VALUE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = tsl2591_set_als_upper_threshold(chip, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_unlock;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tret = tsl2591_set_als_lower_threshold(chip, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_unlock;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tint_time = TSL2591_FVAL_TO_MSEC(chip->als_settings.als_int_time);\n\n\t\tperiod = ((val * MSEC_PER_SEC) +\n\t\t\t (val2 / MSEC_PER_SEC)) / int_time;\n\n\t\tals_persist = tsl2591_persist_lit_to_cycle(period);\n\t\tif (als_persist < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tret = tsl2591_compatible_als_persist_cycle(chip, als_persist);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\n\t\tret = tsl2591_set_als_persist_cycle(chip, als_persist);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&chip->als_mutex);\n\treturn ret;\n}\n\nstatic int tsl2591_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\n\treturn chip->events_enabled;\n}\n\nstatic int tsl2591_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\n\tif (state && !chip->events_enabled) {\n\t\tchip->events_enabled = true;\n\t\tpm_runtime_get_sync(&client->dev);\n\t} else if (!state && chip->events_enabled) {\n\t\tchip->events_enabled = false;\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tpm_runtime_put_autosuspend(&client->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info tsl2591_info = {\n\t.event_attrs = &tsl2591_event_attribute_group,\n\t.read_raw = tsl2591_read_raw,\n\t.write_raw = tsl2591_write_raw,\n\t.read_avail = tsl2591_read_available,\n\t.read_event_value = tsl2591_read_event_value,\n\t.write_event_value = tsl2591_write_event_value,\n\t.read_event_config = tsl2591_read_event_config,\n\t.write_event_config = tsl2591_write_event_config,\n};\n\nstatic const struct iio_info tsl2591_info_no_irq = {\n\t.read_raw = tsl2591_read_raw,\n\t.write_raw = tsl2591_write_raw,\n\t.read_avail = tsl2591_read_available,\n};\n\nstatic int tsl2591_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\tret = tsl2591_set_power_state(chip, TSL2591_PWR_OFF);\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic int tsl2591_resume(struct device *dev)\n{\n\tint power_state = TSL2591_PWR_ON | TSL2591_ENABLE_ALS;\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tif (chip->events_enabled)\n\t\tpower_state |= TSL2591_ENABLE_ALS_INT;\n\n\tmutex_lock(&chip->als_mutex);\n\tret = tsl2591_set_power_state(chip, power_state);\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(tsl2591_pm_ops, tsl2591_suspend,\n\t\t\t\t tsl2591_resume, NULL);\n\nstatic irqreturn_t tsl2591_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *dev_info = private;\n\tstruct tsl2591_chip *chip = iio_priv(dev_info);\n\tstruct i2c_client *client = chip->client;\n\n\tif (!chip->events_enabled)\n\t\treturn IRQ_NONE;\n\n\tiio_push_event(dev_info,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t\t\t    iio_get_time_ns(dev_info));\n\n\t \n\ti2c_smbus_write_byte(client, TSL2591_CMD_SF_CALS_NPI);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tsl2591_load_defaults(struct tsl2591_chip *chip)\n{\n\tint ret;\n\n\tchip->als_settings.als_int_time = TSL2591_DEFAULT_ALS_INT_TIME;\n\tchip->als_settings.als_gain = TSL2591_DEFAULT_ALS_GAIN;\n\tchip->als_settings.als_lower_thresh = TSL2591_DEFAULT_ALS_LOWER_THRESH;\n\tchip->als_settings.als_upper_thresh = TSL2591_DEFAULT_ALS_UPPER_THRESH;\n\n\tret = tsl2591_set_als_gain_int_time(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2591_set_als_persist_cycle(chip, TSL2591_DEFAULT_ALS_PERSIST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2591_set_als_lower_threshold(chip, TSL2591_DEFAULT_ALS_LOWER_THRESH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2591_set_als_upper_threshold(chip, TSL2591_DEFAULT_ALS_UPPER_THRESH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void tsl2591_chip_off(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct tsl2591_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\n\ttsl2591_set_power_state(chip, TSL2591_PWR_OFF);\n}\n\nstatic int tsl2591_probe(struct i2c_client *client)\n{\n\tstruct tsl2591_chip *chip;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"I2C smbus byte data functionality is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tchip->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, tsl2591_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\t\"tsl2591_irq\", indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err_probe(&client->dev, ret, \"IRQ request error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tindio_dev->info = &tsl2591_info;\n\t} else {\n\t\tindio_dev->info = &tsl2591_info_no_irq;\n\t}\n\n\tmutex_init(&chip->als_mutex);\n\n\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t       TSL2591_CMD_NOP | TSL2591_DEVICE_ID);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read the device ID register\\n\");\n\t\treturn ret;\n\t}\n\tret = FIELD_GET(TSL2591_DEVICE_ID_MASK, ret);\n\tif (ret != TSL2591_DEVICE_ID_VAL) {\n\t\tdev_err(&client->dev, \"Device ID: %#04x unknown\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev->channels = tsl2591_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsl2591_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = chip->client->name;\n\tchip->events_enabled = false;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t TSL2591_POWER_OFF_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\t \n\tret = devm_add_action_or_reset(&client->dev, tsl2591_chip_off,\n\t\t\t\t       indio_dev);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tret = tsl2591_load_defaults(chip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to load sensor defaults\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_smbus_write_byte(client, TSL2591_CMD_SF_CALS_NPI);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to clear als irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id tsl2591_of_match[] = {\n\t{ .compatible = \"amstaos,tsl2591\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tsl2591_of_match);\n\nstatic struct i2c_driver tsl2591_driver = {\n\t.driver = {\n\t\t.name = \"tsl2591\",\n\t\t.pm = pm_ptr(&tsl2591_pm_ops),\n\t\t.of_match_table = tsl2591_of_match,\n\t},\n\t.probe = tsl2591_probe\n};\nmodule_i2c_driver(tsl2591_driver);\n\nMODULE_AUTHOR(\"Joe Sandom <joe.g.sandom@gmail.com>\");\nMODULE_DESCRIPTION(\"TAOS tsl2591 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}