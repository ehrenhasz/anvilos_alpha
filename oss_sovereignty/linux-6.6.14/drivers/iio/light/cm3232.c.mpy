{
  "module_name": "cm3232.c",
  "hash_id": "54d87ed7d9e43d010bd561dbcb6aea94d3d95e625f7670bdf686e9027ebdb0e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/cm3232.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/init.h>\n\n \n#define CM3232_REG_ADDR_CMD\t\t0x00\n#define CM3232_REG_ADDR_ALS\t\t0x50\n#define CM3232_REG_ADDR_ID\t\t0x53\n\n#define CM3232_CMD_ALS_DISABLE\t\tBIT(0)\n\n#define CM3232_CMD_ALS_IT_SHIFT\t\t2\n#define CM3232_CMD_ALS_IT_MASK\t\t(BIT(2) | BIT(3) | BIT(4))\n#define CM3232_CMD_ALS_IT_DEFAULT\t(0x01 << CM3232_CMD_ALS_IT_SHIFT)\n\n#define CM3232_CMD_ALS_RESET\t\tBIT(6)\n\n#define CM3232_CMD_DEFAULT\t\tCM3232_CMD_ALS_IT_DEFAULT\n\n#define CM3232_HW_ID\t\t\t0x32\n#define CM3232_CALIBSCALE_DEFAULT\t100000\n#define CM3232_CALIBSCALE_RESOLUTION\t100000\n#define CM3232_MLUX_PER_LUX\t\t1000\n\n#define CM3232_MLUX_PER_BIT_DEFAULT\t64\n#define CM3232_MLUX_PER_BIT_BASE_IT\t100000\n\nstatic const struct {\n\tint val;\n\tint val2;\n\tu8 it;\n} cm3232_als_it_scales[] = {\n\t{0, 100000, 0},\t \n\t{0, 200000, 1},\t \n\t{0, 400000, 2},\t \n\t{0, 800000, 3},\t \n\t{1, 600000, 4},\t \n\t{3, 200000, 5},\t \n};\n\nstruct cm3232_als_info {\n\tu8 regs_cmd_default;\n\tu8 hw_id;\n\tint calibscale;\n\tint mlux_per_bit;\n\tint mlux_per_bit_base_it;\n};\n\nstatic struct cm3232_als_info cm3232_als_info_default = {\n\t.regs_cmd_default = CM3232_CMD_DEFAULT,\n\t.hw_id = CM3232_HW_ID,\n\t.calibscale = CM3232_CALIBSCALE_DEFAULT,\n\t.mlux_per_bit = CM3232_MLUX_PER_BIT_DEFAULT,\n\t.mlux_per_bit_base_it = CM3232_MLUX_PER_BIT_BASE_IT,\n};\n\nstruct cm3232_chip {\n\tstruct i2c_client *client;\n\tstruct cm3232_als_info *als_info;\n\tu8 regs_cmd;\n\tu16 regs_als;\n};\n\n \nstatic int cm3232_reg_init(struct cm3232_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\ts32 ret;\n\n\tchip->als_info = &cm3232_als_info_default;\n\n\t \n\tret = i2c_smbus_read_word_data(client, CM3232_REG_ADDR_ID);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"Error reading addr_id\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((ret & 0xFF) != chip->als_info->hw_id)\n\t\treturn -ENODEV;\n\n\t \n\tchip->regs_cmd = CM3232_CMD_ALS_DISABLE | CM3232_CMD_ALS_RESET;\n\tret = i2c_smbus_write_byte_data(client, CM3232_REG_ADDR_CMD,\n\t\t\t\t\tchip->regs_cmd);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"Error writing reg_cmd\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tchip->regs_cmd = chip->als_info->regs_cmd_default;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, CM3232_REG_ADDR_CMD,\n\t\t\t\t\tchip->regs_cmd);\n\tif (ret < 0)\n\t\tdev_err(&chip->client->dev, \"Error writing reg_cmd\\n\");\n\n\treturn ret;\n}\n\n \nstatic int cm3232_read_als_it(struct cm3232_chip *chip, int *val, int *val2)\n{\n\tu16 als_it;\n\tint i;\n\n\tals_it = chip->regs_cmd;\n\tals_it &= CM3232_CMD_ALS_IT_MASK;\n\tals_it >>= CM3232_CMD_ALS_IT_SHIFT;\n\tfor (i = 0; i < ARRAY_SIZE(cm3232_als_it_scales); i++) {\n\t\tif (als_it == cm3232_als_it_scales[i].it) {\n\t\t\t*val = cm3232_als_it_scales[i].val;\n\t\t\t*val2 = cm3232_als_it_scales[i].val2;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int cm3232_write_als_it(struct cm3232_chip *chip, int val, int val2)\n{\n\tstruct i2c_client *client = chip->client;\n\tu16 als_it, cmd;\n\tint i;\n\ts32 ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(cm3232_als_it_scales); i++) {\n\t\tif (val == cm3232_als_it_scales[i].val &&\n\t\t\tval2 == cm3232_als_it_scales[i].val2) {\n\n\t\t\tals_it = cm3232_als_it_scales[i].it;\n\t\t\tals_it <<= CM3232_CMD_ALS_IT_SHIFT;\n\n\t\t\tcmd = chip->regs_cmd & ~CM3232_CMD_ALS_IT_MASK;\n\t\t\tcmd |= als_it;\n\t\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t\tCM3232_REG_ADDR_CMD,\n\t\t\t\t\t\t\tcmd);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tchip->regs_cmd = cmd;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int cm3232_get_lux(struct cm3232_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\tstruct cm3232_als_info *als_info = chip->als_info;\n\tint ret;\n\tint val, val2;\n\tint als_it;\n\tu64 lux;\n\n\t \n\tret = cm3232_read_als_it(chip, &val, &val2);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tals_it = val * 1000000 + val2;\n\tlux = (__force u64)als_info->mlux_per_bit;\n\tlux *= als_info->mlux_per_bit_base_it;\n\tlux = div_u64(lux, als_it);\n\n\tret = i2c_smbus_read_word_data(client, CM3232_REG_ADDR_ALS);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error reading reg_addr_als\\n\");\n\t\treturn ret;\n\t}\n\n\tchip->regs_als = (u16)ret;\n\tlux *= chip->regs_als;\n\tlux *= als_info->calibscale;\n\tlux = div_u64(lux, CM3232_CALIBSCALE_RESOLUTION);\n\tlux = div_u64(lux, CM3232_MLUX_PER_LUX);\n\n\tif (lux > 0xFFFF)\n\t\tlux = 0xFFFF;\n\n\treturn (int)lux;\n}\n\nstatic int cm3232_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct cm3232_chip *chip = iio_priv(indio_dev);\n\tstruct cm3232_als_info *als_info = chip->als_info;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = cm3232_get_lux(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = als_info->calibscale;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn cm3232_read_als_it(chip, val, val2);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cm3232_write_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint val, int val2, long mask)\n{\n\tstruct cm3232_chip *chip = iio_priv(indio_dev);\n\tstruct cm3232_als_info *als_info = chip->als_info;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tals_info->calibscale = val;\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn cm3232_write_als_it(chip, val, val2);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t cm3232_get_it_available(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint i, len;\n\n\tfor (i = 0, len = 0; i < ARRAY_SIZE(cm3232_als_it_scales); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%u.%06u \",\n\t\t\tcm3232_als_it_scales[i].val,\n\t\t\tcm3232_als_it_scales[i].val2);\n\treturn len + scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n}\n\nstatic const struct iio_chan_spec cm3232_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_INT_TIME),\n\t}\n};\n\nstatic IIO_DEVICE_ATTR(in_illuminance_integration_time_available,\n\t\t\tS_IRUGO, cm3232_get_it_available, NULL, 0);\n\nstatic struct attribute *cm3232_attributes[] = {\n\t&iio_dev_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cm3232_attribute_group = {\n\t.attrs = cm3232_attributes\n};\n\nstatic const struct iio_info cm3232_info = {\n\t.read_raw\t\t= &cm3232_read_raw,\n\t.write_raw\t\t= &cm3232_write_raw,\n\t.attrs\t\t\t= &cm3232_attribute_group,\n};\n\nstatic int cm3232_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct cm3232_chip *chip;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tchip->client = client;\n\n\tindio_dev->channels = cm3232_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cm3232_channels);\n\tindio_dev->info = &cm3232_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = cm3232_reg_init(chip);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: register init failed\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic void cm3232_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\ti2c_smbus_write_byte_data(client, CM3232_REG_ADDR_CMD,\n\t\tCM3232_CMD_ALS_DISABLE);\n\n\tiio_device_unregister(indio_dev);\n}\n\nstatic const struct i2c_device_id cm3232_id[] = {\n\t{\"cm3232\", 0},\n\t{}\n};\n\nstatic int cm3232_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct cm3232_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tchip->regs_cmd |= CM3232_CMD_ALS_DISABLE;\n\tret = i2c_smbus_write_byte_data(client, CM3232_REG_ADDR_CMD,\n\t\t\t\t\tchip->regs_cmd);\n\n\treturn ret;\n}\n\nstatic int cm3232_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct cm3232_chip *chip = iio_priv(indio_dev);\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tchip->regs_cmd &= ~CM3232_CMD_ALS_DISABLE;\n\tret = i2c_smbus_write_byte_data(client, CM3232_REG_ADDR_CMD,\n\t\t\t\t\tchip->regs_cmd | CM3232_CMD_ALS_RESET);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cm3232_pm_ops, cm3232_suspend, cm3232_resume);\n\nMODULE_DEVICE_TABLE(i2c, cm3232_id);\n\nstatic const struct of_device_id cm3232_of_match[] = {\n\t{.compatible = \"capella,cm3232\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cm3232_of_match);\n\nstatic struct i2c_driver cm3232_driver = {\n\t.driver = {\n\t\t.name\t= \"cm3232\",\n\t\t.of_match_table = cm3232_of_match,\n\t\t.pm\t= pm_sleep_ptr(&cm3232_pm_ops),\n\t},\n\t.id_table\t= cm3232_id,\n\t.probe\t\t= cm3232_probe,\n\t.remove\t\t= cm3232_remove,\n};\n\nmodule_i2c_driver(cm3232_driver);\n\nMODULE_AUTHOR(\"Kevin Tsai <ktsai@capellamicro.com>\");\nMODULE_DESCRIPTION(\"CM3232 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}