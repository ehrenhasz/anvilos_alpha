{
  "module_name": "lm3533-als.c",
  "hash_id": "ab891024713bd38d624fa1eda723d5491825140c58ae57e4087c2fb198a3acd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/lm3533-als.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mfd/core.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <linux/mfd/lm3533.h>\n\n\n#define LM3533_ALS_RESISTOR_MIN\t\t\t1\n#define LM3533_ALS_RESISTOR_MAX\t\t\t127\n#define LM3533_ALS_CHANNEL_CURRENT_MAX\t\t2\n#define LM3533_ALS_THRESH_MAX\t\t\t3\n#define LM3533_ALS_ZONE_MAX\t\t\t4\n\n#define LM3533_REG_ALS_RESISTOR_SELECT\t\t0x30\n#define LM3533_REG_ALS_CONF\t\t\t0x31\n#define LM3533_REG_ALS_ZONE_INFO\t\t0x34\n#define LM3533_REG_ALS_READ_ADC_RAW\t\t0x37\n#define LM3533_REG_ALS_READ_ADC_AVERAGE\t\t0x38\n#define LM3533_REG_ALS_BOUNDARY_BASE\t\t0x50\n#define LM3533_REG_ALS_TARGET_BASE\t\t0x60\n\n#define LM3533_ALS_ENABLE_MASK\t\t\t0x01\n#define LM3533_ALS_INPUT_MODE_MASK\t\t0x02\n#define LM3533_ALS_INT_ENABLE_MASK\t\t0x01\n\n#define LM3533_ALS_ZONE_SHIFT\t\t\t2\n#define LM3533_ALS_ZONE_MASK\t\t\t0x1c\n\n#define LM3533_ALS_FLAG_INT_ENABLED\t\t1\n\n\nstruct lm3533_als {\n\tstruct lm3533 *lm3533;\n\tstruct platform_device *pdev;\n\n\tunsigned long flags;\n\tint irq;\n\n\tatomic_t zone;\n\tstruct mutex thresh_mutex;\n};\n\n\nstatic int lm3533_als_get_adc(struct iio_dev *indio_dev, bool average,\n\t\t\t\t\t\t\t\tint *adc)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 reg;\n\tu8 val;\n\tint ret;\n\n\tif (average)\n\t\treg = LM3533_REG_ALS_READ_ADC_AVERAGE;\n\telse\n\t\treg = LM3533_REG_ALS_READ_ADC_RAW;\n\n\tret = lm3533_read(als->lm3533, reg, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to read adc\\n\");\n\t\treturn ret;\n\t}\n\n\t*adc = val;\n\n\treturn 0;\n}\n\nstatic int _lm3533_als_get_zone(struct iio_dev *indio_dev, u8 *zone)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_read(als->lm3533, LM3533_REG_ALS_ZONE_INFO, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to read zone\\n\");\n\t\treturn ret;\n\t}\n\n\tval = (val & LM3533_ALS_ZONE_MASK) >> LM3533_ALS_ZONE_SHIFT;\n\t*zone = min_t(u8, val, LM3533_ALS_ZONE_MAX);\n\n\treturn 0;\n}\n\nstatic int lm3533_als_get_zone(struct iio_dev *indio_dev, u8 *zone)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tint ret;\n\n\tif (test_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags)) {\n\t\t*zone = atomic_read(&als->zone);\n\t} else {\n\t\tret = _lm3533_als_get_zone(indio_dev, zone);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline u8 lm3533_als_get_target_reg(unsigned channel, unsigned zone)\n{\n\treturn LM3533_REG_ALS_TARGET_BASE + 5 * channel + zone;\n}\n\nstatic int lm3533_als_get_target(struct iio_dev *indio_dev, unsigned channel,\n\t\t\t\t\t\t\tunsigned zone, u8 *val)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 reg;\n\tint ret;\n\n\tif (channel > LM3533_ALS_CHANNEL_CURRENT_MAX)\n\t\treturn -EINVAL;\n\n\tif (zone > LM3533_ALS_ZONE_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_als_get_target_reg(channel, zone);\n\tret = lm3533_read(als->lm3533, reg, val);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev, \"failed to get target current\\n\");\n\n\treturn ret;\n}\n\nstatic int lm3533_als_set_target(struct iio_dev *indio_dev, unsigned channel,\n\t\t\t\t\t\t\tunsigned zone, u8 val)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 reg;\n\tint ret;\n\n\tif (channel > LM3533_ALS_CHANNEL_CURRENT_MAX)\n\t\treturn -EINVAL;\n\n\tif (zone > LM3533_ALS_ZONE_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_als_get_target_reg(channel, zone);\n\tret = lm3533_write(als->lm3533, reg, val);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev, \"failed to set target current\\n\");\n\n\treturn ret;\n}\n\nstatic int lm3533_als_get_current(struct iio_dev *indio_dev, unsigned channel,\n\t\t\t\t\t\t\t\tint *val)\n{\n\tu8 zone;\n\tu8 target;\n\tint ret;\n\n\tret = lm3533_als_get_zone(indio_dev, &zone);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lm3533_als_get_target(indio_dev, channel, zone, &target);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = target;\n\n\treturn 0;\n}\n\nstatic int lm3533_als_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_LIGHT:\n\t\t\tret = lm3533_als_get_adc(indio_dev, false, val);\n\t\t\tbreak;\n\t\tcase IIO_CURRENT:\n\t\t\tret = lm3533_als_get_current(indio_dev, chan->channel,\n\t\t\t\t\t\t\t\t\tval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_AVERAGE_RAW:\n\t\tret = lm3533_als_get_adc(indio_dev, true, val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\n#define CHANNEL_CURRENT(_channel)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type\t\t= IIO_CURRENT,\t\t\t\t\\\n\t\t.channel\t= _channel,\t\t\t\t\\\n\t\t.indexed\t= true,\t\t\t\t\t\\\n\t\t.output\t\t= true,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t}\n\nstatic const struct iio_chan_spec lm3533_als_channels[] = {\n\t{\n\t\t.type\t\t= IIO_LIGHT,\n\t\t.channel\t= 0,\n\t\t.indexed\t= true,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW) |\n\t\t\t\t   BIT(IIO_CHAN_INFO_RAW),\n\t},\n\tCHANNEL_CURRENT(0),\n\tCHANNEL_CURRENT(1),\n\tCHANNEL_CURRENT(2),\n};\n\nstatic irqreturn_t lm3533_als_isr(int irq, void *dev_id)\n{\n\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 zone;\n\tint ret;\n\n\t \n\tret = _lm3533_als_get_zone(indio_dev, &zone);\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_set(&als->zone, zone);\n\n\tiio_push_event(indio_dev,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT,\n\t\t\t\t\t    0,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t       iio_get_time_ns(indio_dev));\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int lm3533_als_set_int_mode(struct iio_dev *indio_dev, int enable)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 mask = LM3533_ALS_INT_ENABLE_MASK;\n\tu8 val;\n\tint ret;\n\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tret = lm3533_update(als->lm3533, LM3533_REG_ALS_ZONE_INFO, val, mask);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to set int mode %d\\n\",\n\t\t\t\t\t\t\t\tenable);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3533_als_get_int_mode(struct iio_dev *indio_dev, int *enable)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 mask = LM3533_ALS_INT_ENABLE_MASK;\n\tu8 val;\n\tint ret;\n\n\tret = lm3533_read(als->lm3533, LM3533_REG_ALS_ZONE_INFO, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to get int mode\\n\");\n\t\treturn ret;\n\t}\n\n\t*enable = !!(val & mask);\n\n\treturn 0;\n}\n\nstatic inline u8 lm3533_als_get_threshold_reg(unsigned nr, bool raising)\n{\n\tu8 offset = !raising;\n\n\treturn LM3533_REG_ALS_BOUNDARY_BASE + 2 * nr + offset;\n}\n\nstatic int lm3533_als_get_threshold(struct iio_dev *indio_dev, unsigned nr,\n\t\t\t\t\t\t\tbool raising, u8 *val)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 reg;\n\tint ret;\n\n\tif (nr > LM3533_ALS_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_als_get_threshold_reg(nr, raising);\n\tret = lm3533_read(als->lm3533, reg, val);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev, \"failed to get threshold\\n\");\n\n\treturn ret;\n}\n\nstatic int lm3533_als_set_threshold(struct iio_dev *indio_dev, unsigned nr,\n\t\t\t\t\t\t\tbool raising, u8 val)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 val2;\n\tu8 reg, reg2;\n\tint ret;\n\n\tif (nr > LM3533_ALS_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\treg = lm3533_als_get_threshold_reg(nr, raising);\n\treg2 = lm3533_als_get_threshold_reg(nr, !raising);\n\n\tmutex_lock(&als->thresh_mutex);\n\tret = lm3533_read(als->lm3533, reg2, &val2);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to get threshold\\n\");\n\t\tgoto out;\n\t}\n\t \n\tif ((raising && (val < val2)) || (!raising && (val > val2))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = lm3533_write(als->lm3533, reg, val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"failed to set threshold\\n\");\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&als->thresh_mutex);\n\n\treturn ret;\n}\n\nstatic int lm3533_als_get_hysteresis(struct iio_dev *indio_dev, unsigned nr,\n\t\t\t\t\t\t\t\tu8 *val)\n{\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tu8 falling;\n\tu8 raising;\n\tint ret;\n\n\tif (nr > LM3533_ALS_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&als->thresh_mutex);\n\tret = lm3533_als_get_threshold(indio_dev, nr, false, &falling);\n\tif (ret)\n\t\tgoto out;\n\tret = lm3533_als_get_threshold(indio_dev, nr, true, &raising);\n\tif (ret)\n\t\tgoto out;\n\n\t*val = raising - falling;\nout:\n\tmutex_unlock(&als->thresh_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t show_thresh_either_en(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tint enable;\n\tint ret;\n\n\tif (als->irq) {\n\t\tret = lm3533_als_get_int_mode(indio_dev, &enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tenable = 0;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", enable);\n}\n\nstatic ssize_t store_thresh_either_en(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\tunsigned long enable;\n\tbool int_enabled;\n\tu8 zone;\n\tint ret;\n\n\tif (!als->irq)\n\t\treturn -EBUSY;\n\n\tif (kstrtoul(buf, 0, &enable))\n\t\treturn -EINVAL;\n\n\tint_enabled = test_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\n\n\tif (enable && !int_enabled) {\n\t\tret = lm3533_als_get_zone(indio_dev, &zone);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tatomic_set(&als->zone, zone);\n\n\t\tset_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\n\t}\n\n\tret = lm3533_als_set_int_mode(indio_dev, enable);\n\tif (ret) {\n\t\tif (!int_enabled)\n\t\t\tclear_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\n\n\t\treturn ret;\n\t}\n\n\tif (!enable)\n\t\tclear_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\n\n\treturn len;\n}\n\nstatic ssize_t show_zone(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tu8 zone;\n\tint ret;\n\n\tret = lm3533_als_get_zone(indio_dev, &zone);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", zone);\n}\n\nenum lm3533_als_attribute_type {\n\tLM3533_ATTR_TYPE_HYSTERESIS,\n\tLM3533_ATTR_TYPE_TARGET,\n\tLM3533_ATTR_TYPE_THRESH_FALLING,\n\tLM3533_ATTR_TYPE_THRESH_RAISING,\n};\n\nstruct lm3533_als_attribute {\n\tstruct device_attribute dev_attr;\n\tenum lm3533_als_attribute_type type;\n\tu8 val1;\n\tu8 val2;\n};\n\nstatic inline struct lm3533_als_attribute *\nto_lm3533_als_attr(struct device_attribute *attr)\n{\n\treturn container_of(attr, struct lm3533_als_attribute, dev_attr);\n}\n\nstatic ssize_t show_als_attr(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct lm3533_als_attribute *als_attr = to_lm3533_als_attr(attr);\n\tu8 val;\n\tint ret;\n\n\tswitch (als_attr->type) {\n\tcase LM3533_ATTR_TYPE_HYSTERESIS:\n\t\tret = lm3533_als_get_hysteresis(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\t\t\t&val);\n\t\tbreak;\n\tcase LM3533_ATTR_TYPE_TARGET:\n\t\tret = lm3533_als_get_target(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\tals_attr->val2, &val);\n\t\tbreak;\n\tcase LM3533_ATTR_TYPE_THRESH_FALLING:\n\t\tret = lm3533_als_get_threshold(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\t\tfalse, &val);\n\t\tbreak;\n\tcase LM3533_ATTR_TYPE_THRESH_RAISING:\n\t\tret = lm3533_als_get_threshold(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\t\ttrue, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENXIO;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t store_als_attr(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct lm3533_als_attribute *als_attr = to_lm3533_als_attr(attr);\n\tu8 val;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tswitch (als_attr->type) {\n\tcase LM3533_ATTR_TYPE_TARGET:\n\t\tret = lm3533_als_set_target(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\tals_attr->val2, val);\n\t\tbreak;\n\tcase LM3533_ATTR_TYPE_THRESH_FALLING:\n\t\tret = lm3533_als_set_threshold(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\t\tfalse, val);\n\t\tbreak;\n\tcase LM3533_ATTR_TYPE_THRESH_RAISING:\n\t\tret = lm3533_als_set_threshold(indio_dev, als_attr->val1,\n\t\t\t\t\t\t\t\ttrue, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENXIO;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n#define ALS_ATTR(_name, _mode, _show, _store, _type, _val1, _val2)\t\\\n\t{ .dev_attr\t= __ATTR(_name, _mode, _show, _store),\t\t\\\n\t  .type\t\t= _type,\t\t\t\t\t\\\n\t  .val1\t\t= _val1,\t\t\t\t\t\\\n\t  .val2\t\t= _val2 }\n\n#define LM3533_ALS_ATTR(_name, _mode, _show, _store, _type, _val1, _val2) \\\n\tstruct lm3533_als_attribute lm3533_als_attr_##_name =\t\t  \\\n\t\tALS_ATTR(_name, _mode, _show, _store, _type, _val1, _val2)\n\n#define ALS_TARGET_ATTR_RW(_channel, _zone)\t\t\t\t\\\n\tLM3533_ALS_ATTR(out_current##_channel##_current##_zone##_raw,\t\\\n\t\t\t\tS_IRUGO | S_IWUSR,\t\t\t\\\n\t\t\t\tshow_als_attr, store_als_attr,\t\t\\\n\t\t\t\tLM3533_ATTR_TYPE_TARGET, _channel, _zone)\n \nstatic ALS_TARGET_ATTR_RW(0, 0);\nstatic ALS_TARGET_ATTR_RW(0, 1);\nstatic ALS_TARGET_ATTR_RW(0, 2);\nstatic ALS_TARGET_ATTR_RW(0, 3);\nstatic ALS_TARGET_ATTR_RW(0, 4);\n\nstatic ALS_TARGET_ATTR_RW(1, 0);\nstatic ALS_TARGET_ATTR_RW(1, 1);\nstatic ALS_TARGET_ATTR_RW(1, 2);\nstatic ALS_TARGET_ATTR_RW(1, 3);\nstatic ALS_TARGET_ATTR_RW(1, 4);\n\nstatic ALS_TARGET_ATTR_RW(2, 0);\nstatic ALS_TARGET_ATTR_RW(2, 1);\nstatic ALS_TARGET_ATTR_RW(2, 2);\nstatic ALS_TARGET_ATTR_RW(2, 3);\nstatic ALS_TARGET_ATTR_RW(2, 4);\n\n#define ALS_THRESH_FALLING_ATTR_RW(_nr)\t\t\t\t\t\\\n\tLM3533_ALS_ATTR(in_illuminance0_thresh##_nr##_falling_value,\t\\\n\t\t\tS_IRUGO | S_IWUSR,\t\t\t\t\\\n\t\t\tshow_als_attr, store_als_attr,\t\t\\\n\t\t\tLM3533_ATTR_TYPE_THRESH_FALLING, _nr, 0)\n\n#define ALS_THRESH_RAISING_ATTR_RW(_nr)\t\t\t\t\t\\\n\tLM3533_ALS_ATTR(in_illuminance0_thresh##_nr##_raising_value,\t\\\n\t\t\tS_IRUGO | S_IWUSR,\t\t\t\t\\\n\t\t\tshow_als_attr, store_als_attr,\t\t\t\\\n\t\t\tLM3533_ATTR_TYPE_THRESH_RAISING, _nr, 0)\n \nstatic ALS_THRESH_FALLING_ATTR_RW(0);\nstatic ALS_THRESH_FALLING_ATTR_RW(1);\nstatic ALS_THRESH_FALLING_ATTR_RW(2);\nstatic ALS_THRESH_FALLING_ATTR_RW(3);\n\nstatic ALS_THRESH_RAISING_ATTR_RW(0);\nstatic ALS_THRESH_RAISING_ATTR_RW(1);\nstatic ALS_THRESH_RAISING_ATTR_RW(2);\nstatic ALS_THRESH_RAISING_ATTR_RW(3);\n\n#define ALS_HYSTERESIS_ATTR_RO(_nr)\t\t\t\t\t\\\n\tLM3533_ALS_ATTR(in_illuminance0_thresh##_nr##_hysteresis,\t\\\n\t\t\tS_IRUGO, show_als_attr, NULL,\t\t\t\\\n\t\t\tLM3533_ATTR_TYPE_HYSTERESIS, _nr, 0)\n \nstatic ALS_HYSTERESIS_ATTR_RO(0);\nstatic ALS_HYSTERESIS_ATTR_RO(1);\nstatic ALS_HYSTERESIS_ATTR_RO(2);\nstatic ALS_HYSTERESIS_ATTR_RO(3);\n\n#define ILLUMINANCE_ATTR_RO(_name) \\\n\tDEVICE_ATTR(in_illuminance0_##_name, S_IRUGO, show_##_name, NULL)\n#define ILLUMINANCE_ATTR_RW(_name) \\\n\tDEVICE_ATTR(in_illuminance0_##_name, S_IRUGO | S_IWUSR, \\\n\t\t\t\t\t\tshow_##_name, store_##_name)\n \nstatic ILLUMINANCE_ATTR_RW(thresh_either_en);\n\n \nstatic ILLUMINANCE_ATTR_RO(zone);\n\nstatic struct attribute *lm3533_als_event_attributes[] = {\n\t&dev_attr_in_illuminance0_thresh_either_en.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh0_falling_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh0_hysteresis.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh0_raising_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh1_falling_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh1_hysteresis.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh1_raising_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh2_falling_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh2_hysteresis.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh2_raising_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh3_falling_value.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh3_hysteresis.dev_attr.attr,\n\t&lm3533_als_attr_in_illuminance0_thresh3_raising_value.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm3533_als_event_attribute_group = {\n\t.attrs = lm3533_als_event_attributes\n};\n\nstatic struct attribute *lm3533_als_attributes[] = {\n\t&dev_attr_in_illuminance0_zone.attr,\n\t&lm3533_als_attr_out_current0_current0_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current0_current1_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current0_current2_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current0_current3_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current0_current4_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current1_current0_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current1_current1_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current1_current2_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current1_current3_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current1_current4_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current2_current0_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current2_current1_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current2_current2_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current2_current3_raw.dev_attr.attr,\n\t&lm3533_als_attr_out_current2_current4_raw.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lm3533_als_attribute_group = {\n\t.attrs = lm3533_als_attributes\n};\n\nstatic int lm3533_als_set_input_mode(struct lm3533_als *als, bool pwm_mode)\n{\n\tu8 mask = LM3533_ALS_INPUT_MODE_MASK;\n\tu8 val;\n\tint ret;\n\n\tif (pwm_mode)\n\t\tval = mask;\t \n\telse\n\t\tval = 0;\t \n\n\tret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, val, mask);\n\tif (ret) {\n\t\tdev_err(&als->pdev->dev, \"failed to set input mode %d\\n\",\n\t\t\t\t\t\t\t\tpwm_mode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3533_als_set_resistor(struct lm3533_als *als, u8 val)\n{\n\tint ret;\n\n\tif (val < LM3533_ALS_RESISTOR_MIN || val > LM3533_ALS_RESISTOR_MAX) {\n\t\tdev_err(&als->pdev->dev, \"invalid resistor value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = lm3533_write(als->lm3533, LM3533_REG_ALS_RESISTOR_SELECT, val);\n\tif (ret) {\n\t\tdev_err(&als->pdev->dev, \"failed to set resistor\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3533_als_setup(struct lm3533_als *als,\n\t\t\t    struct lm3533_als_platform_data *pdata)\n{\n\tint ret;\n\n\tret = lm3533_als_set_input_mode(als, pdata->pwm_mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!pdata->pwm_mode) {\n\t\tret = lm3533_als_set_resistor(als, pdata->r_select);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3533_als_setup_irq(struct lm3533_als *als, void *dev)\n{\n\tu8 mask = LM3533_ALS_INT_ENABLE_MASK;\n\tint ret;\n\n\t \n\tret = lm3533_update(als->lm3533, LM3533_REG_ALS_ZONE_INFO, 0, mask);\n\tif (ret) {\n\t\tdev_err(&als->pdev->dev, \"failed to disable interrupts\\n\");\n\t\treturn ret;\n\t}\n\n\tret = request_threaded_irq(als->irq, NULL, lm3533_als_isr,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&als->pdev->dev), dev);\n\tif (ret) {\n\t\tdev_err(&als->pdev->dev, \"failed to request irq %d\\n\",\n\t\t\t\t\t\t\t\tals->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3533_als_enable(struct lm3533_als *als)\n{\n\tu8 mask = LM3533_ALS_ENABLE_MASK;\n\tint ret;\n\n\tret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, mask, mask);\n\tif (ret)\n\t\tdev_err(&als->pdev->dev, \"failed to enable ALS\\n\");\n\n\treturn ret;\n}\n\nstatic int lm3533_als_disable(struct lm3533_als *als)\n{\n\tu8 mask = LM3533_ALS_ENABLE_MASK;\n\tint ret;\n\n\tret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, 0, mask);\n\tif (ret)\n\t\tdev_err(&als->pdev->dev, \"failed to disable ALS\\n\");\n\n\treturn ret;\n}\n\nstatic const struct iio_info lm3533_als_info = {\n\t.attrs\t\t= &lm3533_als_attribute_group,\n\t.event_attrs\t= &lm3533_als_event_attribute_group,\n\t.read_raw\t= &lm3533_als_read_raw,\n};\n\nstatic int lm3533_als_probe(struct platform_device *pdev)\n{\n\tstruct lm3533 *lm3533;\n\tstruct lm3533_als_platform_data *pdata;\n\tstruct lm3533_als *als;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tlm3533 = dev_get_drvdata(pdev->dev.parent);\n\tif (!lm3533)\n\t\treturn -EINVAL;\n\n\tpdata = pdev->dev.platform_data;\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*als));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tindio_dev->info = &lm3533_als_info;\n\tindio_dev->channels = lm3533_als_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lm3533_als_channels);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tiio_device_set_parent(indio_dev, pdev->dev.parent);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tals = iio_priv(indio_dev);\n\tals->lm3533 = lm3533;\n\tals->pdev = pdev;\n\tals->irq = lm3533->irq;\n\tatomic_set(&als->zone, 0);\n\tmutex_init(&als->thresh_mutex);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tif (als->irq) {\n\t\tret = lm3533_als_setup_irq(als, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = lm3533_als_setup(als, pdata);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tret = lm3533_als_enable(als);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register ALS\\n\");\n\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tlm3533_als_disable(als);\nerr_free_irq:\n\tif (als->irq)\n\t\tfree_irq(als->irq, indio_dev);\n\n\treturn ret;\n}\n\nstatic int lm3533_als_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct lm3533_als *als = iio_priv(indio_dev);\n\n\tlm3533_als_set_int_mode(indio_dev, false);\n\tiio_device_unregister(indio_dev);\n\tlm3533_als_disable(als);\n\tif (als->irq)\n\t\tfree_irq(als->irq, indio_dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver lm3533_als_driver = {\n\t.driver\t= {\n\t\t.name\t= \"lm3533-als\",\n\t},\n\t.probe\t\t= lm3533_als_probe,\n\t.remove\t\t= lm3533_als_remove,\n};\nmodule_platform_driver(lm3533_als_driver);\n\nMODULE_AUTHOR(\"Johan Hovold <jhovold@gmail.com>\");\nMODULE_DESCRIPTION(\"LM3533 Ambient Light Sensor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lm3533-als\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}