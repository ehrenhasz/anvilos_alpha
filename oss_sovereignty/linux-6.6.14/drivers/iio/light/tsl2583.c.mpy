{
  "module_name": "tsl2583.c",
  "hash_id": "5cc07f32416e000fabdfde52bbe32d63b743ee247fa81e6d7e3e82bf77637db4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/tsl2583.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/unistd.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/pm_runtime.h>\n\n \n#define TSL2583_CNTRL\t\t\t0x00\n#define TSL2583_ALS_TIME\t\t0X01\n#define TSL2583_INTERRUPT\t\t0x02\n#define TSL2583_GAIN\t\t\t0x07\n#define TSL2583_REVID\t\t\t0x11\n#define TSL2583_CHIPID\t\t\t0x12\n#define TSL2583_ALS_CHAN0LO\t\t0x14\n#define TSL2583_ALS_CHAN0HI\t\t0x15\n#define TSL2583_ALS_CHAN1LO\t\t0x16\n#define TSL2583_ALS_CHAN1HI\t\t0x17\n#define TSL2583_TMR_LO\t\t\t0x18\n#define TSL2583_TMR_HI\t\t\t0x19\n\n \n#define TSL2583_CMD_REG\t\t\t0x80\n#define TSL2583_CMD_SPL_FN\t\t0x60\n#define TSL2583_CMD_ALS_INT_CLR\t\t0x01\n\n \n#define TSL2583_CNTL_ADC_ENBL\t\t0x02\n#define TSL2583_CNTL_PWR_OFF\t\t0x00\n#define TSL2583_CNTL_PWR_ON\t\t0x01\n\n \n#define TSL2583_STA_ADC_VALID\t\t0x01\n#define TSL2583_STA_ADC_INTR\t\t0x10\n\n \n#define TSL2583_LUX_CALC_OVER_FLOW\t65535\n\n#define TSL2583_INTERRUPT_DISABLED\t0x00\n\n#define TSL2583_CHIP_ID\t\t\t0x90\n#define TSL2583_CHIP_ID_MASK\t\t0xf0\n\n#define TSL2583_POWER_OFF_DELAY_MS\t2000\n\n \nstruct tsl2583_als_info {\n\tu16 als_ch0;\n\tu16 als_ch1;\n\tu16 lux;\n};\n\nstruct tsl2583_lux {\n\tunsigned int ratio;\n\tunsigned int ch0;\n\tunsigned int ch1;\n};\n\nstatic const struct tsl2583_lux tsl2583_default_lux[] = {\n\t{  9830,  8520, 15729 },\n\t{ 12452, 10807, 23344 },\n\t{ 14746,  6383, 11705 },\n\t{ 17695,  4063,  6554 },\n\t{     0,     0,     0 }   \n};\n\n#define TSL2583_MAX_LUX_TABLE_ENTRIES 11\n\nstruct tsl2583_settings {\n\tint als_time;\n\tint als_gain;\n\tint als_gain_trim;\n\tint als_cal_target;\n\n\t \n\tstruct tsl2583_lux als_device_lux[TSL2583_MAX_LUX_TABLE_ENTRIES];\n};\n\nstruct tsl2583_chip {\n\tstruct mutex als_mutex;\n\tstruct i2c_client *client;\n\tstruct tsl2583_als_info als_cur_info;\n\tstruct tsl2583_settings als_settings;\n\tint als_time_scale;\n\tint als_saturation;\n};\n\nstruct gainadj {\n\ts16 ch0;\n\ts16 ch1;\n\ts16 mean;\n};\n\n \nstatic const struct gainadj gainadj[] = {\n\t{ 1, 1, 1 },\n\t{ 8, 8, 8 },\n\t{ 16, 16, 16 },\n\t{ 107, 115, 111 }\n};\n\n \nstatic void tsl2583_defaults(struct tsl2583_chip *chip)\n{\n\t \n\tchip->als_settings.als_time = 100;\n\n\t \n\tchip->als_settings.als_gain = 0;\n\n\t \n\tchip->als_settings.als_gain_trim = 1000;\n\n\t \n\tchip->als_settings.als_cal_target = 130;\n\n\t \n\tmemcpy(chip->als_settings.als_device_lux, tsl2583_default_lux,\n\t       sizeof(tsl2583_default_lux));\n}\n\n \nstatic int tsl2583_get_lux(struct iio_dev *indio_dev)\n{\n\tu16 ch0, ch1;  \n\tu32 lux;  \n\tu64 lux64;\n\tu32 ratio;\n\tu8 buf[5];\n\tstruct tsl2583_lux *p;\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint i, ret;\n\n\tret = i2c_smbus_read_byte_data(chip->client, TSL2583_CMD_REG);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"%s: failed to read CMD_REG register\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\n\t \n\tif (!(ret & TSL2583_STA_ADC_INTR)) {\n\t\tdev_err(&chip->client->dev, \"%s: data not valid; returning last value\\n\",\n\t\t\t__func__);\n\t\tret = chip->als_cur_info.lux;  \n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint reg = TSL2583_CMD_REG | (TSL2583_ALS_CHAN0LO + i);\n\n\t\tret = i2c_smbus_read_byte_data(chip->client, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&chip->client->dev, \"%s: failed to read register %x\\n\",\n\t\t\t\t__func__, reg);\n\t\t\tgoto done;\n\t\t}\n\t\tbuf[i] = ret;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte(chip->client,\n\t\t\t\t   (TSL2583_CMD_REG | TSL2583_CMD_SPL_FN |\n\t\t\t\t    TSL2583_CMD_ALS_INT_CLR));\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"%s: failed to clear the interrupt bit\\n\",\n\t\t\t__func__);\n\t\tgoto done;  \n\t}\n\n\t \n\tch0 = le16_to_cpup((const __le16 *)&buf[0]);\n\tch1 = le16_to_cpup((const __le16 *)&buf[2]);\n\n\tchip->als_cur_info.als_ch0 = ch0;\n\tchip->als_cur_info.als_ch1 = ch1;\n\n\tif ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation))\n\t\tgoto return_max;\n\n\tif (!ch0) {\n\t\t \n\t\tret = 0;\n\t\tchip->als_cur_info.lux = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tratio = (ch1 << 15) / ch0;\n\n\t \n\tfor (p = (struct tsl2583_lux *)chip->als_settings.als_device_lux;\n\t     p->ratio != 0 && p->ratio < ratio; p++)\n\t\t;\n\n\tif (p->ratio == 0) {\n\t\tlux = 0;\n\t} else {\n\t\tu32 ch0lux, ch1lux;\n\n\t\tch0lux = ((ch0 * p->ch0) +\n\t\t\t  (gainadj[chip->als_settings.als_gain].ch0 >> 1))\n\t\t\t / gainadj[chip->als_settings.als_gain].ch0;\n\t\tch1lux = ((ch1 * p->ch1) +\n\t\t\t  (gainadj[chip->als_settings.als_gain].ch1 >> 1))\n\t\t\t / gainadj[chip->als_settings.als_gain].ch1;\n\n\t\t \n\t\tif (ch1lux > ch0lux) {\n\t\t\tdev_dbg(&chip->client->dev, \"%s: No Data - Returning 0\\n\",\n\t\t\t\t__func__);\n\t\t\tret = 0;\n\t\t\tchip->als_cur_info.lux = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlux = ch0lux - ch1lux;\n\t}\n\n\t \n\tif (chip->als_time_scale == 0)\n\t\tlux = 0;\n\telse\n\t\tlux = (lux + (chip->als_time_scale >> 1)) /\n\t\t\tchip->als_time_scale;\n\n\t \n\tlux64 = lux;\n\tlux64 = lux64 * chip->als_settings.als_gain_trim;\n\tlux64 >>= 13;\n\tlux = lux64;\n\tlux = DIV_ROUND_CLOSEST(lux, 1000);\n\n\tif (lux > TSL2583_LUX_CALC_OVER_FLOW) {  \nreturn_max:\n\t\tlux = TSL2583_LUX_CALC_OVER_FLOW;\n\t}\n\n\t \n\tchip->als_cur_info.lux = lux;\n\tret = lux;\n\ndone:\n\treturn ret;\n}\n\n \nstatic int tsl2583_als_calibrate(struct iio_dev *indio_dev)\n{\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tunsigned int gain_trim_val;\n\tint ret;\n\tint lux_val;\n\n\tret = i2c_smbus_read_byte_data(chip->client,\n\t\t\t\t       TSL2583_CMD_REG | TSL2583_CNTRL);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to read from the CNTRL register\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((ret & (TSL2583_CNTL_ADC_ENBL | TSL2583_CNTL_PWR_ON))\n\t\t\t!= (TSL2583_CNTL_ADC_ENBL | TSL2583_CNTL_PWR_ON)) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: Device is not powered on and/or ADC is not enabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t} else if ((ret & TSL2583_STA_ADC_VALID) != TSL2583_STA_ADC_VALID) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: The two ADC channels have not completed an integration cycle\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\n\tlux_val = tsl2583_get_lux(indio_dev);\n\tif (lux_val < 0) {\n\t\tdev_err(&chip->client->dev, \"%s: failed to get lux\\n\",\n\t\t\t__func__);\n\t\treturn lux_val;\n\t}\n\n\t \n\tif (lux_val == 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: lux_val of 0 will produce out of range trim_value\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\n\tgain_trim_val = (unsigned int)(((chip->als_settings.als_cal_target)\n\t\t\t* chip->als_settings.als_gain_trim) / lux_val);\n\tif ((gain_trim_val < 250) || (gain_trim_val > 4000)) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: trim_val of %d is not within the range [250, 4000]\\n\",\n\t\t\t__func__, gain_trim_val);\n\t\treturn -ENODATA;\n\t}\n\n\tchip->als_settings.als_gain_trim = (int)gain_trim_val;\n\n\treturn 0;\n}\n\nstatic int tsl2583_set_als_time(struct tsl2583_chip *chip)\n{\n\tint als_count, als_time, ret;\n\tu8 val;\n\n\t \n\tals_count = DIV_ROUND_CLOSEST(chip->als_settings.als_time * 100, 270);\n\tif (!als_count)\n\t\tals_count = 1;  \n\n\t \n\tals_time = DIV_ROUND_CLOSEST(als_count * 27, 10);\n\n\tval = 256 - als_count;\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2583_CMD_REG | TSL2583_ALS_TIME,\n\t\t\t\t\tval);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev, \"%s: failed to set the als time to %d\\n\",\n\t\t\t__func__, val);\n\t\treturn ret;\n\t}\n\n\t \n\tchip->als_saturation = als_count * 922;  \n\tchip->als_time_scale = DIV_ROUND_CLOSEST(als_time, 50);\n\n\treturn ret;\n}\n\nstatic int tsl2583_set_als_gain(struct tsl2583_chip *chip)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2583_CMD_REG | TSL2583_GAIN,\n\t\t\t\t\tchip->als_settings.als_gain);\n\tif (ret < 0)\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to set the gain to %d\\n\", __func__,\n\t\t\tchip->als_settings.als_gain);\n\n\treturn ret;\n}\n\nstatic int tsl2583_set_power_state(struct tsl2583_chip *chip, u8 state)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2583_CMD_REG | TSL2583_CNTRL, state);\n\tif (ret < 0)\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to set the power state to %d\\n\", __func__,\n\t\t\tstate);\n\n\treturn ret;\n}\n\n \nstatic int tsl2583_chip_init_and_power_on(struct iio_dev *indio_dev)\n{\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(chip->client,\n\t\t\t\t\tTSL2583_CMD_REG | TSL2583_INTERRUPT,\n\t\t\t\t\tTSL2583_INTERRUPT_DISABLED);\n\tif (ret < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s: failed to disable interrupts\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = tsl2583_set_als_time(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tsl2583_set_als_gain(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(3000, 3500);\n\n\tret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_ON |\n\t\t\t\t\t    TSL2583_CNTL_ADC_ENBL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n \n\nstatic ssize_t in_illuminance_input_target_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\tret = sprintf(buf, \"%d\\n\", chip->als_settings.als_cal_target);\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t in_illuminance_input_target_store(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint value;\n\n\tif (kstrtoint(buf, 0, &value) || !value)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->als_mutex);\n\tchip->als_settings.als_cal_target = value;\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn len;\n}\n\nstatic ssize_t in_illuminance_calibrate_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint value, ret;\n\n\tif (kstrtoint(buf, 0, &value) || value != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tret = tsl2583_als_calibrate(indio_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = len;\ndone:\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t in_illuminance_lux_table_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tunsigned int i;\n\tint offset = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(chip->als_settings.als_device_lux); i++) {\n\t\toffset += sprintf(buf + offset, \"%u,%u,%u,\",\n\t\t\t\t  chip->als_settings.als_device_lux[i].ratio,\n\t\t\t\t  chip->als_settings.als_device_lux[i].ch0,\n\t\t\t\t  chip->als_settings.als_device_lux[i].ch1);\n\t\tif (chip->als_settings.als_device_lux[i].ratio == 0) {\n\t\t\t \n\t\t\toffset--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset += sprintf(buf + offset, \"\\n\");\n\n\treturn offset;\n}\n\nstatic ssize_t in_illuminance_lux_table_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tconst unsigned int max_ints = TSL2583_MAX_LUX_TABLE_ENTRIES * 3;\n\tint value[TSL2583_MAX_LUX_TABLE_ENTRIES * 3 + 1];\n\tint ret = -EINVAL;\n\tunsigned int n;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tget_options(buf, ARRAY_SIZE(value), value);\n\n\t \n\tn = value[0];\n\tif ((n % 3) || n < 6 || n > max_ints) {\n\t\tdev_err(dev,\n\t\t\t\"%s: The number of entries in the lux table must be a multiple of 3 and within the range [6, %d]\\n\",\n\t\t\t__func__, max_ints);\n\t\tgoto done;\n\t}\n\tif ((value[n - 2] | value[n - 1] | value[n]) != 0) {\n\t\tdev_err(dev, \"%s: The last 3 entries in the lux table must be zeros.\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\n\tmemcpy(chip->als_settings.als_device_lux, &value[1],\n\t       value[0] * sizeof(value[1]));\n\n\tret = len;\n\ndone:\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR(in_illuminance_calibscale_available, \"1 8 16 111\");\nstatic IIO_CONST_ATTR(in_illuminance_integration_time_available,\n\t\t      \"0.050 0.100 0.150 0.200 0.250 0.300 0.350 0.400 0.450 0.500 0.550 0.600 0.650\");\nstatic IIO_DEVICE_ATTR_RW(in_illuminance_input_target, 0);\nstatic IIO_DEVICE_ATTR_WO(in_illuminance_calibrate, 0);\nstatic IIO_DEVICE_ATTR_RW(in_illuminance_lux_table, 0);\n\nstatic struct attribute *sysfs_attrs_ctrl[] = {\n\t&iio_const_attr_in_illuminance_calibscale_available.dev_attr.attr,\n\t&iio_const_attr_in_illuminance_integration_time_available.dev_attr.attr,\n\t&iio_dev_attr_in_illuminance_input_target.dev_attr.attr,\n\t&iio_dev_attr_in_illuminance_calibrate.dev_attr.attr,\n\t&iio_dev_attr_in_illuminance_lux_table.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tsl2583_attribute_group = {\n\t.attrs = sysfs_attrs_ctrl,\n};\n\nstatic const struct iio_chan_spec tsl2583_channels[] = {\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME),\n\t},\n};\n\nstatic int tsl2583_set_pm_runtime_busy(struct tsl2583_chip *chip, bool on)\n{\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&chip->client->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(&chip->client->dev);\n\t\tret = pm_runtime_put_autosuspend(&chip->client->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int tsl2583_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret, pm_ret;\n\n\tret = tsl2583_set_pm_runtime_busy(chip, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tret = -EINVAL;\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\tret = tsl2583_get_lux(indio_dev);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto read_done;\n\n\t\t\t \n\t\t\tif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\n\t\t\t\t*val = chip->als_cur_info.als_ch0;\n\t\t\telse\n\t\t\t\t*val = chip->als_cur_info.als_ch1;\n\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\tret = tsl2583_get_lux(indio_dev);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto read_done;\n\n\t\t\t*val = ret;\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = chip->als_settings.als_gain_trim;\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = gainadj[chip->als_settings.als_gain].mean;\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\t*val = 0;\n\t\t\t*val2 = chip->als_settings.als_time;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nread_done:\n\tmutex_unlock(&chip->als_mutex);\n\n\tif (ret < 0) {\n\t\ttsl2583_set_pm_runtime_busy(chip, false);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_ret = tsl2583_set_pm_runtime_busy(chip, false);\n\tif (pm_ret < 0)\n\t\treturn pm_ret;\n\n\treturn ret;\n}\n\nstatic int tsl2583_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tret = tsl2583_set_pm_runtime_busy(chip, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tret = -EINVAL;\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\tchip->als_settings.als_gain_trim = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (chan->type == IIO_LIGHT) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(gainadj); i++) {\n\t\t\t\tif (gainadj[i].mean == val) {\n\t\t\t\t\tchip->als_settings.als_gain = i;\n\t\t\t\t\tret = tsl2583_set_als_gain(chip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chan->type == IIO_LIGHT && !val && val2 >= 50 &&\n\t\t    val2 <= 650 && !(val2 % 50)) {\n\t\t\tchip->als_settings.als_time = val2;\n\t\t\tret = tsl2583_set_als_time(chip);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&chip->als_mutex);\n\n\tif (ret < 0) {\n\t\ttsl2583_set_pm_runtime_busy(chip, false);\n\t\treturn ret;\n\t}\n\n\tret = tsl2583_set_pm_runtime_busy(chip, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic const struct iio_info tsl2583_info = {\n\t.attrs = &tsl2583_attribute_group,\n\t.read_raw = tsl2583_read_raw,\n\t.write_raw = tsl2583_write_raw,\n};\n\nstatic int tsl2583_probe(struct i2c_client *clientp)\n{\n\tint ret;\n\tstruct tsl2583_chip *chip;\n\tstruct iio_dev *indio_dev;\n\n\tif (!i2c_check_functionality(clientp->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&clientp->dev, \"%s: i2c smbus byte data functionality is unsupported\\n\",\n\t\t\t__func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&clientp->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tchip->client = clientp;\n\ti2c_set_clientdata(clientp, indio_dev);\n\n\tmutex_init(&chip->als_mutex);\n\n\tret = i2c_smbus_read_byte_data(clientp,\n\t\t\t\t       TSL2583_CMD_REG | TSL2583_CHIPID);\n\tif (ret < 0) {\n\t\tdev_err(&clientp->dev,\n\t\t\t\"%s: failed to read the chip ID register\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif ((ret & TSL2583_CHIP_ID_MASK) != TSL2583_CHIP_ID) {\n\t\tdev_err(&clientp->dev, \"%s: received an unknown chip ID %x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev->info = &tsl2583_info;\n\tindio_dev->channels = tsl2583_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsl2583_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = chip->client->name;\n\n\tpm_runtime_enable(&clientp->dev);\n\tpm_runtime_set_autosuspend_delay(&clientp->dev,\n\t\t\t\t\t TSL2583_POWER_OFF_DELAY_MS);\n\tpm_runtime_use_autosuspend(&clientp->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&clientp->dev, \"%s: iio registration failed\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\ttsl2583_defaults(chip);\n\n\tdev_info(&clientp->dev, \"Light sensor found.\\n\");\n\n\treturn 0;\n}\n\nstatic void tsl2583_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\ttsl2583_set_power_state(chip, TSL2583_CNTL_PWR_OFF);\n}\n\nstatic int tsl2583_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_OFF);\n\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic int tsl2583_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct tsl2583_chip *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&chip->als_mutex);\n\n\tret = tsl2583_chip_init_and_power_on(indio_dev);\n\n\tmutex_unlock(&chip->als_mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(tsl2583_pm_ops, tsl2583_suspend,\n\t\t\t\t tsl2583_resume, NULL);\n\nstatic const struct i2c_device_id tsl2583_idtable[] = {\n\t{ \"tsl2580\", 0 },\n\t{ \"tsl2581\", 1 },\n\t{ \"tsl2583\", 2 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tsl2583_idtable);\n\nstatic const struct of_device_id tsl2583_of_match[] = {\n\t{ .compatible = \"amstaos,tsl2580\", },\n\t{ .compatible = \"amstaos,tsl2581\", },\n\t{ .compatible = \"amstaos,tsl2583\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tsl2583_of_match);\n\n \nstatic struct i2c_driver tsl2583_driver = {\n\t.driver = {\n\t\t.name = \"tsl2583\",\n\t\t.pm = pm_ptr(&tsl2583_pm_ops),\n\t\t.of_match_table = tsl2583_of_match,\n\t},\n\t.id_table = tsl2583_idtable,\n\t.probe = tsl2583_probe,\n\t.remove = tsl2583_remove,\n};\nmodule_i2c_driver(tsl2583_driver);\n\nMODULE_AUTHOR(\"J. August Brenner <jbrenner@taosinc.com>\");\nMODULE_AUTHOR(\"Brian Masney <masneyb@onstation.org>\");\nMODULE_DESCRIPTION(\"TAOS tsl2583 ambient light sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}