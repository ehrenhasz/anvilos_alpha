{
  "module_name": "iqs621-als.c",
  "hash_id": "a387339a9ebeabee2975f292de7da7f1cdeb2bba6cc1129b8ff48cb1ed84c105",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/light/iqs621-als.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/kernel.h>\n#include <linux/mfd/iqs62x.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define IQS621_ALS_FLAGS_LIGHT\t\t\tBIT(7)\n#define IQS621_ALS_FLAGS_RANGE\t\t\tGENMASK(3, 0)\n\n#define IQS621_ALS_UI_OUT\t\t\t0x17\n\n#define IQS621_ALS_THRESH_DARK\t\t\t0x80\n#define IQS621_ALS_THRESH_LIGHT\t\t\t0x81\n\n#define IQS622_IR_RANGE\t\t\t\t0x15\n#define IQS622_IR_FLAGS\t\t\t\t0x16\n#define IQS622_IR_FLAGS_TOUCH\t\t\tBIT(1)\n#define IQS622_IR_FLAGS_PROX\t\t\tBIT(0)\n\n#define IQS622_IR_UI_OUT\t\t\t0x17\n\n#define IQS622_IR_THRESH_PROX\t\t\t0x91\n#define IQS622_IR_THRESH_TOUCH\t\t\t0x92\n\nstruct iqs621_als_private {\n\tstruct iqs62x_core *iqs62x;\n\tstruct iio_dev *indio_dev;\n\tstruct notifier_block notifier;\n\tstruct mutex lock;\n\tbool light_en;\n\tbool range_en;\n\tbool prox_en;\n\tu8 als_flags;\n\tu8 ir_flags_mask;\n\tu8 ir_flags;\n\tu8 thresh_light;\n\tu8 thresh_dark;\n\tu8 thresh_prox;\n};\n\nstatic int iqs621_als_init(struct iqs621_als_private *iqs621_als)\n{\n\tstruct iqs62x_core *iqs62x = iqs621_als->iqs62x;\n\tunsigned int event_mask = 0;\n\tint ret;\n\n\tswitch (iqs621_als->ir_flags_mask) {\n\tcase IQS622_IR_FLAGS_TOUCH:\n\t\tret = regmap_write(iqs62x->regmap, IQS622_IR_THRESH_TOUCH,\n\t\t\t\t   iqs621_als->thresh_prox);\n\t\tbreak;\n\n\tcase IQS622_IR_FLAGS_PROX:\n\t\tret = regmap_write(iqs62x->regmap, IQS622_IR_THRESH_PROX,\n\t\t\t\t   iqs621_als->thresh_prox);\n\t\tbreak;\n\n\tdefault:\n\t\tret = regmap_write(iqs62x->regmap, IQS621_ALS_THRESH_LIGHT,\n\t\t\t\t   iqs621_als->thresh_light);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(iqs62x->regmap, IQS621_ALS_THRESH_DARK,\n\t\t\t\t   iqs621_als->thresh_dark);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (iqs621_als->light_en || iqs621_als->range_en)\n\t\tevent_mask |= iqs62x->dev_desc->als_mask;\n\n\tif (iqs621_als->prox_en)\n\t\tevent_mask |= iqs62x->dev_desc->ir_mask;\n\n\treturn regmap_update_bits(iqs62x->regmap, IQS620_GLBL_EVENT_MASK,\n\t\t\t\t  event_mask, 0);\n}\n\nstatic int iqs621_als_notifier(struct notifier_block *notifier,\n\t\t\t       unsigned long event_flags, void *context)\n{\n\tstruct iqs62x_event_data *event_data = context;\n\tstruct iqs621_als_private *iqs621_als;\n\tstruct iio_dev *indio_dev;\n\tbool light_new, light_old;\n\tbool prox_new, prox_old;\n\tu8 range_new, range_old;\n\ts64 timestamp;\n\tint ret;\n\n\tiqs621_als = container_of(notifier, struct iqs621_als_private,\n\t\t\t\t  notifier);\n\tindio_dev = iqs621_als->indio_dev;\n\ttimestamp = iio_get_time_ns(indio_dev);\n\n\tmutex_lock(&iqs621_als->lock);\n\n\tif (event_flags & BIT(IQS62X_EVENT_SYS_RESET)) {\n\t\tret = iqs621_als_init(iqs621_als);\n\t\tif (ret) {\n\t\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\t\"Failed to re-initialize device: %d\\n\", ret);\n\t\t\tret = NOTIFY_BAD;\n\t\t} else {\n\t\t\tret = NOTIFY_OK;\n\t\t}\n\n\t\tgoto err_mutex;\n\t}\n\n\tif (!iqs621_als->light_en && !iqs621_als->range_en &&\n\t    !iqs621_als->prox_en) {\n\t\tret = NOTIFY_DONE;\n\t\tgoto err_mutex;\n\t}\n\n\t \n\tlight_new = event_data->als_flags & IQS621_ALS_FLAGS_LIGHT;\n\tlight_old = iqs621_als->als_flags & IQS621_ALS_FLAGS_LIGHT;\n\n\tif (iqs621_als->light_en && light_new && !light_old)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       timestamp);\n\telse if (iqs621_als->light_en && !light_new && light_old)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       timestamp);\n\n\t \n\trange_new = event_data->als_flags & IQS621_ALS_FLAGS_RANGE;\n\trange_old = iqs621_als->als_flags & IQS621_ALS_FLAGS_RANGE;\n\n\tif (iqs621_als->range_en && (range_new > range_old))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_CHANGE,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       timestamp);\n\telse if (iqs621_als->range_en && (range_new < range_old))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_CHANGE,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       timestamp);\n\n\t \n\tprox_new = event_data->ir_flags & iqs621_als->ir_flags_mask;\n\tprox_old = iqs621_als->ir_flags & iqs621_als->ir_flags_mask;\n\n\tif (iqs621_als->prox_en && prox_new && !prox_old)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       timestamp);\n\telse if (iqs621_als->prox_en && !prox_new && prox_old)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       timestamp);\n\n\tiqs621_als->als_flags = event_data->als_flags;\n\tiqs621_als->ir_flags = event_data->ir_flags;\n\tret = NOTIFY_OK;\n\nerr_mutex:\n\tmutex_unlock(&iqs621_als->lock);\n\n\treturn ret;\n}\n\nstatic void iqs621_als_notifier_unregister(void *context)\n{\n\tstruct iqs621_als_private *iqs621_als = context;\n\tstruct iio_dev *indio_dev = iqs621_als->indio_dev;\n\tint ret;\n\n\tret = blocking_notifier_chain_unregister(&iqs621_als->iqs62x->nh,\n\t\t\t\t\t\t &iqs621_als->notifier);\n\tif (ret)\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"Failed to unregister notifier: %d\\n\", ret);\n}\n\nstatic int iqs621_als_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct iqs621_als_private *iqs621_als = iio_priv(indio_dev);\n\tstruct iqs62x_core *iqs62x = iqs621_als->iqs62x;\n\tint ret;\n\t__le16 val_buf;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tret = regmap_read(iqs62x->regmap, chan->address, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val &= IQS621_ALS_FLAGS_RANGE;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_PROXIMITY:\n\tcase IIO_LIGHT:\n\t\tret = regmap_raw_read(iqs62x->regmap, chan->address, &val_buf,\n\t\t\t\t      sizeof(val_buf));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = le16_to_cpu(val_buf);\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int iqs621_als_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir)\n{\n\tstruct iqs621_als_private *iqs621_als = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&iqs621_als->lock);\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tret = iqs621_als->light_en;\n\t\tbreak;\n\n\tcase IIO_INTENSITY:\n\t\tret = iqs621_als->range_en;\n\t\tbreak;\n\n\tcase IIO_PROXIMITY:\n\t\tret = iqs621_als->prox_en;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&iqs621_als->lock);\n\n\treturn ret;\n}\n\nstatic int iqs621_als_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_type type,\n\t\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t\t int state)\n{\n\tstruct iqs621_als_private *iqs621_als = iio_priv(indio_dev);\n\tstruct iqs62x_core *iqs62x = iqs621_als->iqs62x;\n\tunsigned int val;\n\tint ret;\n\n\tmutex_lock(&iqs621_als->lock);\n\n\tret = regmap_read(iqs62x->regmap, iqs62x->dev_desc->als_flags, &val);\n\tif (ret)\n\t\tgoto err_mutex;\n\tiqs621_als->als_flags = val;\n\n\tswitch (chan->type) {\n\tcase IIO_LIGHT:\n\t\tret = regmap_update_bits(iqs62x->regmap, IQS620_GLBL_EVENT_MASK,\n\t\t\t\t\t iqs62x->dev_desc->als_mask,\n\t\t\t\t\t iqs621_als->range_en || state ? 0 :\n\t\t\t\t\t\t\t\t\t 0xFF);\n\t\tif (!ret)\n\t\t\tiqs621_als->light_en = state;\n\t\tbreak;\n\n\tcase IIO_INTENSITY:\n\t\tret = regmap_update_bits(iqs62x->regmap, IQS620_GLBL_EVENT_MASK,\n\t\t\t\t\t iqs62x->dev_desc->als_mask,\n\t\t\t\t\t iqs621_als->light_en || state ? 0 :\n\t\t\t\t\t\t\t\t\t 0xFF);\n\t\tif (!ret)\n\t\t\tiqs621_als->range_en = state;\n\t\tbreak;\n\n\tcase IIO_PROXIMITY:\n\t\tret = regmap_read(iqs62x->regmap, IQS622_IR_FLAGS, &val);\n\t\tif (ret)\n\t\t\tgoto err_mutex;\n\t\tiqs621_als->ir_flags = val;\n\n\t\tret = regmap_update_bits(iqs62x->regmap, IQS620_GLBL_EVENT_MASK,\n\t\t\t\t\t iqs62x->dev_desc->ir_mask,\n\t\t\t\t\t state ? 0 : 0xFF);\n\t\tif (!ret)\n\t\t\tiqs621_als->prox_en = state;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nerr_mutex:\n\tmutex_unlock(&iqs621_als->lock);\n\n\treturn ret;\n}\n\nstatic int iqs621_als_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       enum iio_event_info info,\n\t\t\t\t       int *val, int *val2)\n{\n\tstruct iqs621_als_private *iqs621_als = iio_priv(indio_dev);\n\tint ret = IIO_VAL_INT;\n\n\tmutex_lock(&iqs621_als->lock);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\t*val = iqs621_als->thresh_light * 16;\n\t\tbreak;\n\n\tcase IIO_EV_DIR_FALLING:\n\t\t*val = iqs621_als->thresh_dark * 4;\n\t\tbreak;\n\n\tcase IIO_EV_DIR_EITHER:\n\t\tif (iqs621_als->ir_flags_mask == IQS622_IR_FLAGS_TOUCH)\n\t\t\t*val = iqs621_als->thresh_prox * 4;\n\t\telse\n\t\t\t*val = iqs621_als->thresh_prox;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&iqs621_als->lock);\n\n\treturn ret;\n}\n\nstatic int iqs621_als_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum iio_event_type type,\n\t\t\t\t\tenum iio_event_direction dir,\n\t\t\t\t\tenum iio_event_info info,\n\t\t\t\t\tint val, int val2)\n{\n\tstruct iqs621_als_private *iqs621_als = iio_priv(indio_dev);\n\tstruct iqs62x_core *iqs62x = iqs621_als->iqs62x;\n\tunsigned int thresh_reg, thresh_val;\n\tu8 ir_flags_mask, *thresh_cache;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&iqs621_als->lock);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tthresh_reg = IQS621_ALS_THRESH_LIGHT;\n\t\tthresh_val = val / 16;\n\n\t\tthresh_cache = &iqs621_als->thresh_light;\n\t\tir_flags_mask = 0;\n\t\tbreak;\n\n\tcase IIO_EV_DIR_FALLING:\n\t\tthresh_reg = IQS621_ALS_THRESH_DARK;\n\t\tthresh_val = val / 4;\n\n\t\tthresh_cache = &iqs621_als->thresh_dark;\n\t\tir_flags_mask = 0;\n\t\tbreak;\n\n\tcase IIO_EV_DIR_EITHER:\n\t\t \n\t\tswitch (val) {\n\t\tcase 0 ... 255:\n\t\t\tthresh_reg = IQS622_IR_THRESH_PROX;\n\t\t\tthresh_val = val;\n\n\t\t\tir_flags_mask = IQS622_IR_FLAGS_PROX;\n\t\t\tbreak;\n\n\t\tcase 256 ... 1020:\n\t\t\tthresh_reg = IQS622_IR_THRESH_TOUCH;\n\t\t\tthresh_val = val / 4;\n\n\t\t\tir_flags_mask = IQS622_IR_FLAGS_TOUCH;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto err_mutex;\n\t\t}\n\n\t\tthresh_cache = &iqs621_als->thresh_prox;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_mutex;\n\t}\n\n\tif (thresh_val > 0xFF)\n\t\tgoto err_mutex;\n\n\tret = regmap_write(iqs62x->regmap, thresh_reg, thresh_val);\n\tif (ret)\n\t\tgoto err_mutex;\n\n\t*thresh_cache = thresh_val;\n\tiqs621_als->ir_flags_mask = ir_flags_mask;\n\nerr_mutex:\n\tmutex_unlock(&iqs621_als->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info iqs621_als_info = {\n\t.read_raw = &iqs621_als_read_raw,\n\t.read_event_config = iqs621_als_read_event_config,\n\t.write_event_config = iqs621_als_write_event_config,\n\t.read_event_value = iqs621_als_read_event_value,\n\t.write_event_value = iqs621_als_write_event_value,\n};\n\nstatic const struct iio_event_spec iqs621_als_range_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_CHANGE,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_event_spec iqs621_als_light_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\nstatic const struct iio_chan_spec iqs621_als_channels[] = {\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.address = IQS621_ALS_FLAGS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = iqs621_als_range_events,\n\t\t.num_event_specs = ARRAY_SIZE(iqs621_als_range_events),\n\t},\n\t{\n\t\t.type = IIO_LIGHT,\n\t\t.address = IQS621_ALS_UI_OUT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.event_spec = iqs621_als_light_events,\n\t\t.num_event_specs = ARRAY_SIZE(iqs621_als_light_events),\n\t},\n};\n\nstatic const struct iio_event_spec iqs622_als_prox_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\nstatic const struct iio_chan_spec iqs622_als_channels[] = {\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.channel2 = IIO_MOD_LIGHT_BOTH,\n\t\t.address = IQS622_ALS_FLAGS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = iqs621_als_range_events,\n\t\t.num_event_specs = ARRAY_SIZE(iqs621_als_range_events),\n\t\t.modified = true,\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.channel2 = IIO_MOD_LIGHT_IR,\n\t\t.address = IQS622_IR_RANGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.modified = true,\n\t},\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.address = IQS622_IR_UI_OUT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = iqs622_als_prox_events,\n\t\t.num_event_specs = ARRAY_SIZE(iqs622_als_prox_events),\n\t},\n};\n\nstatic int iqs621_als_probe(struct platform_device *pdev)\n{\n\tstruct iqs62x_core *iqs62x = dev_get_drvdata(pdev->dev.parent);\n\tstruct iqs621_als_private *iqs621_als;\n\tstruct iio_dev *indio_dev;\n\tunsigned int val;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*iqs621_als));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tiqs621_als = iio_priv(indio_dev);\n\tiqs621_als->iqs62x = iqs62x;\n\tiqs621_als->indio_dev = indio_dev;\n\n\tif (iqs62x->dev_desc->prod_num == IQS622_PROD_NUM) {\n\t\tret = regmap_read(iqs62x->regmap, IQS622_IR_THRESH_TOUCH,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tiqs621_als->thresh_prox = val;\n\t\tiqs621_als->ir_flags_mask = IQS622_IR_FLAGS_TOUCH;\n\n\t\tindio_dev->channels = iqs622_als_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(iqs622_als_channels);\n\t} else {\n\t\tret = regmap_read(iqs62x->regmap, IQS621_ALS_THRESH_LIGHT,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tiqs621_als->thresh_light = val;\n\n\t\tret = regmap_read(iqs62x->regmap, IQS621_ALS_THRESH_DARK,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tiqs621_als->thresh_dark = val;\n\n\t\tindio_dev->channels = iqs621_als_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(iqs621_als_channels);\n\t}\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = iqs62x->dev_desc->dev_name;\n\tindio_dev->info = &iqs621_als_info;\n\n\tmutex_init(&iqs621_als->lock);\n\n\tiqs621_als->notifier.notifier_call = iqs621_als_notifier;\n\tret = blocking_notifier_chain_register(&iqs621_als->iqs62x->nh,\n\t\t\t\t\t       &iqs621_als->notifier);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register notifier: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       iqs621_als_notifier_unregister,\n\t\t\t\t       iqs621_als);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic struct platform_driver iqs621_als_platform_driver = {\n\t.driver = {\n\t\t.name = \"iqs621-als\",\n\t},\n\t.probe = iqs621_als_probe,\n};\nmodule_platform_driver(iqs621_als_platform_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS621/622 Ambient Light Sensors\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:iqs621-als\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}