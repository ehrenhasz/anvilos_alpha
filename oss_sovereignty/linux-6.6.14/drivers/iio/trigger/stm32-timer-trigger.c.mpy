{
  "module_name": "stm32-timer-trigger.c",
  "hash_id": "0ceafb9dc7987625a407060165307105c83bc5f869711986c13b045ba1911496",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/trigger/stm32-timer-trigger.c",
  "human_readable_source": "\n \n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/timer/stm32-timer-trigger.h>\n#include <linux/iio/trigger.h>\n#include <linux/mfd/stm32-timers.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define MAX_TRIGGERS 7\n#define MAX_VALIDS 5\n\n \nstatic const void *triggers_table[][MAX_TRIGGERS] = {\n\t{ TIM1_TRGO, TIM1_TRGO2, TIM1_CH1, TIM1_CH2, TIM1_CH3, TIM1_CH4,},\n\t{ TIM2_TRGO, TIM2_CH1, TIM2_CH2, TIM2_CH3, TIM2_CH4,},\n\t{ TIM3_TRGO, TIM3_CH1, TIM3_CH2, TIM3_CH3, TIM3_CH4,},\n\t{ TIM4_TRGO, TIM4_CH1, TIM4_CH2, TIM4_CH3, TIM4_CH4,},\n\t{ TIM5_TRGO, TIM5_CH1, TIM5_CH2, TIM5_CH3, TIM5_CH4,},\n\t{ TIM6_TRGO,},\n\t{ TIM7_TRGO,},\n\t{ TIM8_TRGO, TIM8_TRGO2, TIM8_CH1, TIM8_CH2, TIM8_CH3, TIM8_CH4,},\n\t{ TIM9_TRGO, TIM9_CH1, TIM9_CH2,},\n\t{ TIM10_OC1,},\n\t{ TIM11_OC1,},\n\t{ TIM12_TRGO, TIM12_CH1, TIM12_CH2,},\n\t{ TIM13_OC1,},\n\t{ TIM14_OC1,},\n\t{ TIM15_TRGO,},\n\t{ TIM16_OC1,},\n\t{ TIM17_OC1,},\n};\n\n \nstatic const void *valids_table[][MAX_VALIDS] = {\n\t{ TIM5_TRGO, TIM2_TRGO, TIM3_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM8_TRGO, TIM3_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM2_TRGO, TIM5_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM2_TRGO, TIM3_TRGO, TIM8_TRGO,},\n\t{ TIM2_TRGO, TIM3_TRGO, TIM4_TRGO, TIM8_TRGO,},\n\t{ },  \n\t{ },  \n\t{ TIM1_TRGO, TIM2_TRGO, TIM4_TRGO, TIM5_TRGO,},\n\t{ TIM2_TRGO, TIM3_TRGO, TIM10_OC1, TIM11_OC1,},\n\t{ },  \n\t{ },  \n\t{ TIM4_TRGO, TIM5_TRGO, TIM13_OC1, TIM14_OC1,},\n};\n\nstatic const void *stm32h7_valids_table[][MAX_VALIDS] = {\n\t{ TIM15_TRGO, TIM2_TRGO, TIM3_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM8_TRGO, TIM3_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM2_TRGO, TIM15_TRGO, TIM4_TRGO,},\n\t{ TIM1_TRGO, TIM2_TRGO, TIM3_TRGO, TIM8_TRGO,},\n\t{ TIM1_TRGO, TIM8_TRGO, TIM3_TRGO, TIM4_TRGO,},\n\t{ },  \n\t{ },  \n\t{ TIM1_TRGO, TIM2_TRGO, TIM4_TRGO, TIM5_TRGO,},\n\t{ },  \n\t{ },  \n\t{ },  \n\t{ TIM4_TRGO, TIM5_TRGO, TIM13_OC1, TIM14_OC1,},\n\t{ },  \n\t{ },  \n\t{ TIM1_TRGO, TIM3_TRGO, TIM16_OC1, TIM17_OC1,},\n\t{ },  \n\t{ },  \n};\n\nstruct stm32_timer_trigger_regs {\n\tu32 cr1;\n\tu32 cr2;\n\tu32 psc;\n\tu32 arr;\n\tu32 cnt;\n\tu32 smcr;\n};\n\nstruct stm32_timer_trigger {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tbool enabled;\n\tu32 max_arr;\n\tconst void *triggers;\n\tconst void *valids;\n\tbool has_trgo2;\n\tstruct mutex lock;  \n\tstruct list_head tr_list;\n\tstruct stm32_timer_trigger_regs bak;\n};\n\nstruct stm32_timer_trigger_cfg {\n\tconst void *(*valids_table)[MAX_VALIDS];\n\tconst unsigned int num_valids_table;\n};\n\nstatic bool stm32_timer_is_trgo2_name(const char *name)\n{\n\treturn !!strstr(name, \"trgo2\");\n}\n\nstatic bool stm32_timer_is_trgo_name(const char *name)\n{\n\treturn (!!strstr(name, \"trgo\") && !strstr(name, \"trgo2\"));\n}\n\nstatic int stm32_timer_start(struct stm32_timer_trigger *priv,\n\t\t\t     struct iio_trigger *trig,\n\t\t\t     unsigned int frequency)\n{\n\tunsigned long long prd, div;\n\tint prescaler = 0;\n\tu32 ccer;\n\n\t \n\tdiv = (unsigned long long)clk_get_rate(priv->clk);\n\n\tdo_div(div, frequency);\n\n\tprd = div;\n\n\t \n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, (prescaler + 1));\n\t}\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC) {\n\t\tdev_err(priv->dev, \"prescaler exceeds the maximum value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tif (ccer & TIM_CCER_CCXE)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&priv->lock);\n\tif (!priv->enabled) {\n\t\tpriv->enabled = true;\n\t\tclk_enable(priv->clk);\n\t}\n\n\tregmap_write(priv->regmap, TIM_PSC, prescaler);\n\tregmap_write(priv->regmap, TIM_ARR, prd - 1);\n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE, TIM_CR1_ARPE);\n\n\t \n\tif (stm32_timer_is_trgo2_name(trig->name))\n\t\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS2,\n\t\t\t\t   0x2 << TIM_CR2_MMS2_SHIFT);\n\telse\n\t\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS,\n\t\t\t\t   0x2 << TIM_CR2_MMS_SHIFT);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_EGR, TIM_EGR_UG, TIM_EGR_UG);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, TIM_CR1_CEN);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic void stm32_timer_stop(struct stm32_timer_trigger *priv,\n\t\t\t     struct iio_trigger *trig)\n{\n\tu32 ccer;\n\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tif (ccer & TIM_CCER_CCXE)\n\t\treturn;\n\n\tmutex_lock(&priv->lock);\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE, 0);\n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\tregmap_write(priv->regmap, TIM_PSC, 0);\n\tregmap_write(priv->regmap, TIM_ARR, 0);\n\n\t \n\tif (stm32_timer_is_trgo2_name(trig->name))\n\t\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS2, 0);\n\telse\n\t\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS, 0);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_EGR, TIM_EGR_UG, TIM_EGR_UG);\n\n\tif (priv->enabled) {\n\t\tpriv->enabled = false;\n\t\tclk_disable(priv->clk);\n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic ssize_t stm32_tt_store_frequency(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct stm32_timer_trigger *priv = iio_trigger_get_drvdata(trig);\n\tunsigned int freq;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &freq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freq == 0) {\n\t\tstm32_timer_stop(priv, trig);\n\t} else {\n\t\tret = stm32_timer_start(priv, trig, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t stm32_tt_read_frequency(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct stm32_timer_trigger *priv = iio_trigger_get_drvdata(trig);\n\tu32 psc, arr, cr1;\n\tunsigned long long freq = 0;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\tif (cr1 & TIM_CR1_CEN) {\n\t\tfreq = (unsigned long long)clk_get_rate(priv->clk);\n\t\tdo_div(freq, psc + 1);\n\t\tdo_div(freq, arr + 1);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", (unsigned int)freq);\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ(0660,\n\t\t\t      stm32_tt_read_frequency,\n\t\t\t      stm32_tt_store_frequency);\n\n#define MASTER_MODE_MAX\t\t7\n#define MASTER_MODE2_MAX\t15\n\nstatic char *master_mode_table[] = {\n\t\"reset\",\n\t\"enable\",\n\t\"update\",\n\t\"compare_pulse\",\n\t\"OC1REF\",\n\t\"OC2REF\",\n\t\"OC3REF\",\n\t\"OC4REF\",\n\t \n\t\"OC5REF\",\n\t\"OC6REF\",\n\t\"compare_pulse_OC4REF\",\n\t\"compare_pulse_OC6REF\",\n\t\"compare_pulse_OC4REF_r_or_OC6REF_r\",\n\t\"compare_pulse_OC4REF_r_or_OC6REF_f\",\n\t\"compare_pulse_OC5REF_r_or_OC6REF_r\",\n\t\"compare_pulse_OC5REF_r_or_OC6REF_f\",\n};\n\nstatic ssize_t stm32_tt_show_master_mode(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct stm32_timer_trigger *priv = dev_get_drvdata(dev);\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tu32 cr2;\n\n\tregmap_read(priv->regmap, TIM_CR2, &cr2);\n\n\tif (stm32_timer_is_trgo2_name(trig->name))\n\t\tcr2 = (cr2 & TIM_CR2_MMS2) >> TIM_CR2_MMS2_SHIFT;\n\telse\n\t\tcr2 = (cr2 & TIM_CR2_MMS) >> TIM_CR2_MMS_SHIFT;\n\n\treturn sysfs_emit(buf, \"%s\\n\", master_mode_table[cr2]);\n}\n\nstatic ssize_t stm32_tt_store_master_mode(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct stm32_timer_trigger *priv = dev_get_drvdata(dev);\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tu32 mask, shift, master_mode_max;\n\tint i;\n\n\tif (stm32_timer_is_trgo2_name(trig->name)) {\n\t\tmask = TIM_CR2_MMS2;\n\t\tshift = TIM_CR2_MMS2_SHIFT;\n\t\tmaster_mode_max = MASTER_MODE2_MAX;\n\t} else {\n\t\tmask = TIM_CR2_MMS;\n\t\tshift = TIM_CR2_MMS_SHIFT;\n\t\tmaster_mode_max = MASTER_MODE_MAX;\n\t}\n\n\tfor (i = 0; i <= master_mode_max; i++) {\n\t\tif (!strncmp(master_mode_table[i], buf,\n\t\t\t     strlen(master_mode_table[i]))) {\n\t\t\tmutex_lock(&priv->lock);\n\t\t\tif (!priv->enabled) {\n\t\t\t\t \n\t\t\t\tpriv->enabled = true;\n\t\t\t\tclk_enable(priv->clk);\n\t\t\t}\n\t\t\tregmap_update_bits(priv->regmap, TIM_CR2, mask,\n\t\t\t\t\t   i << shift);\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn len;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t stm32_tt_show_master_mode_avail(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tunsigned int i, master_mode_max;\n\tsize_t len = 0;\n\n\tif (stm32_timer_is_trgo2_name(trig->name))\n\t\tmaster_mode_max = MASTER_MODE2_MAX;\n\telse\n\t\tmaster_mode_max = MASTER_MODE_MAX;\n\n\tfor (i = 0; i <= master_mode_max; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%s \", master_mode_table[i]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(master_mode_available, 0444,\n\t\t       stm32_tt_show_master_mode_avail, NULL, 0);\n\nstatic IIO_DEVICE_ATTR(master_mode, 0660,\n\t\t       stm32_tt_show_master_mode,\n\t\t       stm32_tt_store_master_mode,\n\t\t       0);\n\nstatic struct attribute *stm32_trigger_attrs[] = {\n\t&iio_dev_attr_sampling_frequency.dev_attr.attr,\n\t&iio_dev_attr_master_mode.dev_attr.attr,\n\t&iio_dev_attr_master_mode_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group stm32_trigger_attr_group = {\n\t.attrs = stm32_trigger_attrs,\n};\n\nstatic const struct attribute_group *stm32_trigger_attr_groups[] = {\n\t&stm32_trigger_attr_group,\n\tNULL,\n};\n\nstatic const struct iio_trigger_ops timer_trigger_ops = {\n};\n\nstatic void stm32_unregister_iio_triggers(struct stm32_timer_trigger *priv)\n{\n\tstruct iio_trigger *tr;\n\n\tlist_for_each_entry(tr, &priv->tr_list, alloc_list)\n\t\tiio_trigger_unregister(tr);\n}\n\nstatic int stm32_register_iio_triggers(struct stm32_timer_trigger *priv)\n{\n\tint ret;\n\tconst char * const *cur = priv->triggers;\n\n\tINIT_LIST_HEAD(&priv->tr_list);\n\n\twhile (cur && *cur) {\n\t\tstruct iio_trigger *trig;\n\t\tbool cur_is_trgo = stm32_timer_is_trgo_name(*cur);\n\t\tbool cur_is_trgo2 = stm32_timer_is_trgo2_name(*cur);\n\n\t\tif (cur_is_trgo2 && !priv->has_trgo2) {\n\t\t\tcur++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrig = devm_iio_trigger_alloc(priv->dev, \"%s\", *cur);\n\t\tif  (!trig)\n\t\t\treturn -ENOMEM;\n\n\t\ttrig->dev.parent = priv->dev->parent;\n\t\ttrig->ops = &timer_trigger_ops;\n\n\t\t \n\t\tif (cur_is_trgo || cur_is_trgo2)\n\t\t\ttrig->dev.groups = stm32_trigger_attr_groups;\n\n\t\tiio_trigger_set_drvdata(trig, priv);\n\n\t\tret = iio_trigger_register(trig);\n\t\tif (ret) {\n\t\t\tstm32_unregister_iio_triggers(priv);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlist_add_tail(&trig->alloc_list, &priv->tr_list);\n\t\tcur++;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_counter_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 dat;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tregmap_read(priv->regmap, TIM_CNT, &dat);\n\t\t*val = dat;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tregmap_read(priv->regmap, TIM_CR1, &dat);\n\t\t*val = (dat & TIM_CR1_CEN) ? 1 : 0;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tregmap_read(priv->regmap, TIM_SMCR, &dat);\n\t\tdat &= TIM_SMCR_SMS;\n\n\t\t*val = 1;\n\t\t*val2 = 0;\n\n\t\t \n\t\tif (dat == 3)\n\t\t\t*val2 = 2;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_counter_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t   int val, int val2, long mask)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn regmap_write(priv->regmap, TIM_CNT, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\treturn -EINVAL;\n\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tmutex_lock(&priv->lock);\n\t\tif (val) {\n\t\t\tif (!priv->enabled) {\n\t\t\t\tpriv->enabled = true;\n\t\t\t\tclk_enable(priv->clk);\n\t\t\t}\n\t\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN,\n\t\t\t\t\t   TIM_CR1_CEN);\n\t\t} else {\n\t\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN,\n\t\t\t\t\t   0);\n\t\t\tif (priv->enabled) {\n\t\t\t\tpriv->enabled = false;\n\t\t\t\tclk_disable(priv->clk);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&priv->lock);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_counter_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t\t  struct iio_trigger *trig)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tconst char * const *cur = priv->valids;\n\tunsigned int i = 0;\n\n\tif (!is_stm32_timer_trigger(trig))\n\t\treturn -EINVAL;\n\n\twhile (cur && *cur) {\n\t\tif (!strncmp(trig->name, *cur, strlen(trig->name))) {\n\t\t\tregmap_update_bits(priv->regmap,\n\t\t\t\t\t   TIM_SMCR, TIM_SMCR_TS,\n\t\t\t\t\t   i << TIM_SMCR_TS_SHIFT);\n\t\t\treturn 0;\n\t\t}\n\t\tcur++;\n\t\ti++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info stm32_trigger_info = {\n\t.validate_trigger = stm32_counter_validate_trigger,\n\t.read_raw = stm32_counter_read_raw,\n\t.write_raw = stm32_counter_write_raw\n};\n\nstatic const char *const stm32_trigger_modes[] = {\n\t\"trigger\",\n};\n\nstatic int stm32_set_trigger_mode(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  unsigned int mode)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\n\tregmap_update_bits(priv->regmap, TIM_SMCR, TIM_SMCR_SMS, TIM_SMCR_SMS);\n\n\treturn 0;\n}\n\nstatic int stm32_get_trigger_mode(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 smcr;\n\n\tregmap_read(priv->regmap, TIM_SMCR, &smcr);\n\n\treturn (smcr & TIM_SMCR_SMS) == TIM_SMCR_SMS ? 0 : -EINVAL;\n}\n\nstatic const struct iio_enum stm32_trigger_mode_enum = {\n\t.items = stm32_trigger_modes,\n\t.num_items = ARRAY_SIZE(stm32_trigger_modes),\n\t.set = stm32_set_trigger_mode,\n\t.get = stm32_get_trigger_mode\n};\n\nstatic const char *const stm32_enable_modes[] = {\n\t\"always\",\n\t\"gated\",\n\t\"triggered\",\n};\n\nstatic int stm32_enable_mode2sms(int mode)\n{\n\tswitch (mode) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn 5;\n\tcase 2:\n\t\treturn 6;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_set_enable_mode(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t unsigned int mode)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tint sms = stm32_enable_mode2sms(mode);\n\n\tif (sms < 0)\n\t\treturn sms;\n\t \n\tmutex_lock(&priv->lock);\n\tif (sms == 6 && !priv->enabled) {\n\t\tclk_enable(priv->clk);\n\t\tpriv->enabled = true;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\tregmap_update_bits(priv->regmap, TIM_SMCR, TIM_SMCR_SMS, sms);\n\n\treturn 0;\n}\n\nstatic int stm32_sms2enable_mode(int mode)\n{\n\tswitch (mode) {\n\tcase 0:\n\t\treturn 0;\n\tcase 5:\n\t\treturn 1;\n\tcase 6:\n\t\treturn 2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_get_enable_mode(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 smcr;\n\n\tregmap_read(priv->regmap, TIM_SMCR, &smcr);\n\tsmcr &= TIM_SMCR_SMS;\n\n\treturn stm32_sms2enable_mode(smcr);\n}\n\nstatic const struct iio_enum stm32_enable_mode_enum = {\n\t.items = stm32_enable_modes,\n\t.num_items = ARRAY_SIZE(stm32_enable_modes),\n\t.set = stm32_set_enable_mode,\n\t.get = stm32_get_enable_mode\n};\n\nstatic ssize_t stm32_count_get_preset(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      char *buf)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tu32 arr;\n\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", arr);\n}\n\nstatic ssize_t stm32_count_set_preset(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct stm32_timer_trigger *priv = iio_priv(indio_dev);\n\tunsigned int preset;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &preset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE, 0);\n\tregmap_write(priv->regmap, TIM_ARR, preset);\n\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info stm32_trigger_count_info[] = {\n\t{\n\t\t.name = \"preset\",\n\t\t.shared = IIO_SEPARATE,\n\t\t.read = stm32_count_get_preset,\n\t\t.write = stm32_count_set_preset\n\t},\n\tIIO_ENUM(\"enable_mode\", IIO_SEPARATE, &stm32_enable_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"enable_mode\", IIO_SHARED_BY_TYPE, &stm32_enable_mode_enum),\n\tIIO_ENUM(\"trigger_mode\", IIO_SEPARATE, &stm32_trigger_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"trigger_mode\", IIO_SHARED_BY_TYPE, &stm32_trigger_mode_enum),\n\t{}\n};\n\nstatic const struct iio_chan_spec stm32_trigger_channel = {\n\t.type = IIO_COUNT,\n\t.channel = 0,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t      BIT(IIO_CHAN_INFO_ENABLE) |\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t.ext_info = stm32_trigger_count_info,\n\t.indexed = 1\n};\n\nstatic struct stm32_timer_trigger *stm32_setup_counter_device(struct device *dev)\n{\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev,\n\t\t\t\t\t  sizeof(struct stm32_timer_trigger));\n\tif (!indio_dev)\n\t\treturn NULL;\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &stm32_trigger_info;\n\tindio_dev->modes = INDIO_HARDWARE_TRIGGERED;\n\tindio_dev->num_channels = 1;\n\tindio_dev->channels = &stm32_trigger_channel;\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn iio_priv(indio_dev);\n}\n\n \nbool is_stm32_timer_trigger(struct iio_trigger *trig)\n{\n\treturn (trig->ops == &timer_trigger_ops);\n}\nEXPORT_SYMBOL(is_stm32_timer_trigger);\n\nstatic void stm32_timer_detect_trgo2(struct stm32_timer_trigger *priv)\n{\n\tu32 val;\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS2, TIM_CR2_MMS2);\n\tregmap_read(priv->regmap, TIM_CR2, &val);\n\tregmap_update_bits(priv->regmap, TIM_CR2, TIM_CR2_MMS2, 0);\n\tpriv->has_trgo2 = !!val;\n}\n\nstatic int stm32_timer_trigger_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_timer_trigger *priv;\n\tstruct stm32_timers *ddata = dev_get_drvdata(pdev->dev.parent);\n\tconst struct stm32_timer_trigger_cfg *cfg;\n\tunsigned int index;\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"reg\", &index);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = device_get_match_data(dev);\n\n\tif (index >= ARRAY_SIZE(triggers_table) ||\n\t    index >= cfg->num_valids_table)\n\t\treturn -EINVAL;\n\n\t \n\tif (*cfg->valids_table[index])\n\t\tpriv = stm32_setup_counter_device(dev);\n\telse\n\t\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->regmap = ddata->regmap;\n\tpriv->clk = ddata->clk;\n\tpriv->max_arr = ddata->max_arr;\n\tpriv->triggers = triggers_table[index];\n\tpriv->valids = cfg->valids_table[index];\n\tstm32_timer_detect_trgo2(priv);\n\tmutex_init(&priv->lock);\n\n\tret = stm32_register_iio_triggers(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int stm32_timer_trigger_remove(struct platform_device *pdev)\n{\n\tstruct stm32_timer_trigger *priv = platform_get_drvdata(pdev);\n\tu32 val;\n\n\t \n\tstm32_unregister_iio_triggers(priv);\n\n\t \n\tregmap_read(priv->regmap, TIM_CCER, &val);\n\tif (!(val & TIM_CCER_CCXE))\n\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\n\tif (priv->enabled)\n\t\tclk_disable(priv->clk);\n\n\treturn 0;\n}\n\nstatic int stm32_timer_trigger_suspend(struct device *dev)\n{\n\tstruct stm32_timer_trigger *priv = dev_get_drvdata(dev);\n\n\t \n\tif (priv->enabled) {\n\t\t \n\t\tregmap_read(priv->regmap, TIM_CR1, &priv->bak.cr1);\n\t\tregmap_read(priv->regmap, TIM_CR2, &priv->bak.cr2);\n\t\tregmap_read(priv->regmap, TIM_PSC, &priv->bak.psc);\n\t\tregmap_read(priv->regmap, TIM_ARR, &priv->bak.arr);\n\t\tregmap_read(priv->regmap, TIM_CNT, &priv->bak.cnt);\n\t\tregmap_read(priv->regmap, TIM_SMCR, &priv->bak.smcr);\n\n\t\t \n\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\t\tclk_disable(priv->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_timer_trigger_resume(struct device *dev)\n{\n\tstruct stm32_timer_trigger *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (priv->enabled) {\n\t\tret = clk_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tregmap_write(priv->regmap, TIM_SMCR, priv->bak.smcr);\n\t\tregmap_write(priv->regmap, TIM_CR2, priv->bak.cr2);\n\n\t\t \n\t\tregmap_write(priv->regmap, TIM_PSC, priv->bak.psc);\n\t\tregmap_write(priv->regmap, TIM_ARR, priv->bak.arr);\n\t\tregmap_write(priv->regmap, TIM_CNT, priv->bak.cnt);\n\n\t\t \n\t\tregmap_write(priv->regmap, TIM_CR1, priv->bak.cr1);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stm32_timer_trigger_pm_ops,\n\t\t\t\tstm32_timer_trigger_suspend,\n\t\t\t\tstm32_timer_trigger_resume);\n\nstatic const struct stm32_timer_trigger_cfg stm32_timer_trg_cfg = {\n\t.valids_table = valids_table,\n\t.num_valids_table = ARRAY_SIZE(valids_table),\n};\n\nstatic const struct stm32_timer_trigger_cfg stm32h7_timer_trg_cfg = {\n\t.valids_table = stm32h7_valids_table,\n\t.num_valids_table = ARRAY_SIZE(stm32h7_valids_table),\n};\n\nstatic const struct of_device_id stm32_trig_of_match[] = {\n\t{\n\t\t.compatible = \"st,stm32-timer-trigger\",\n\t\t.data = (void *)&stm32_timer_trg_cfg,\n\t}, {\n\t\t.compatible = \"st,stm32h7-timer-trigger\",\n\t\t.data = (void *)&stm32h7_timer_trg_cfg,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, stm32_trig_of_match);\n\nstatic struct platform_driver stm32_timer_trigger_driver = {\n\t.probe = stm32_timer_trigger_probe,\n\t.remove = stm32_timer_trigger_remove,\n\t.driver = {\n\t\t.name = \"stm32-timer-trigger\",\n\t\t.of_match_table = stm32_trig_of_match,\n\t\t.pm = pm_sleep_ptr(&stm32_timer_trigger_pm_ops),\n\t},\n};\nmodule_platform_driver(stm32_timer_trigger_driver);\n\nMODULE_ALIAS(\"platform:stm32-timer-trigger\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Timer Trigger driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}