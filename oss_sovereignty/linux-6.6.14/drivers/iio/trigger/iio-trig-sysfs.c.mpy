{
  "module_name": "iio-trig-sysfs.c",
  "hash_id": "97b7f54f3152858d09343db7c3c21683378cbe50e91368928e27bb8577b157a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/trigger/iio-trig-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/irq_work.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n\nstruct iio_sysfs_trig {\n\tstruct iio_trigger *trig;\n\tstruct irq_work work;\n\tint id;\n\tstruct list_head l;\n};\n\nstatic LIST_HEAD(iio_sysfs_trig_list);\nstatic DEFINE_MUTEX(iio_sysfs_trig_list_mut);\n\nstatic int iio_sysfs_trigger_probe(int id);\nstatic ssize_t iio_sysfs_trig_add(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf,\n\t\t\t\t  size_t len)\n{\n\tint ret;\n\tunsigned long input;\n\n\tret = kstrtoul(buf, 10, &input);\n\tif (ret)\n\t\treturn ret;\n\tret = iio_sysfs_trigger_probe(input);\n\tif (ret)\n\t\treturn ret;\n\treturn len;\n}\nstatic DEVICE_ATTR(add_trigger, S_IWUSR, NULL, &iio_sysfs_trig_add);\n\nstatic int iio_sysfs_trigger_remove(int id);\nstatic ssize_t iio_sysfs_trig_remove(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf,\n\t\t\t\t     size_t len)\n{\n\tint ret;\n\tunsigned long input;\n\n\tret = kstrtoul(buf, 10, &input);\n\tif (ret)\n\t\treturn ret;\n\tret = iio_sysfs_trigger_remove(input);\n\tif (ret)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic DEVICE_ATTR(remove_trigger, S_IWUSR, NULL, &iio_sysfs_trig_remove);\n\nstatic struct attribute *iio_sysfs_trig_attrs[] = {\n\t&dev_attr_add_trigger.attr,\n\t&dev_attr_remove_trigger.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group iio_sysfs_trig_group = {\n\t.attrs = iio_sysfs_trig_attrs,\n};\n\nstatic const struct attribute_group *iio_sysfs_trig_groups[] = {\n\t&iio_sysfs_trig_group,\n\tNULL\n};\n\n\n \nstatic void iio_trigger_sysfs_release(struct device *dev)\n{\n}\n\nstatic struct device iio_sysfs_trig_dev = {\n\t.bus = &iio_bus_type,\n\t.groups = iio_sysfs_trig_groups,\n\t.release = &iio_trigger_sysfs_release,\n};\n\nstatic void iio_sysfs_trigger_work(struct irq_work *work)\n{\n\tstruct iio_sysfs_trig *trig = container_of(work, struct iio_sysfs_trig,\n\t\t\t\t\t\t\twork);\n\n\tiio_trigger_poll(trig->trig);\n}\n\nstatic ssize_t iio_sysfs_trigger_poll(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct iio_sysfs_trig *sysfs_trig = iio_trigger_get_drvdata(trig);\n\n\tirq_work_queue(&sysfs_trig->work);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(trigger_now, S_IWUSR, NULL, iio_sysfs_trigger_poll);\n\nstatic struct attribute *iio_sysfs_trigger_attrs[] = {\n\t&dev_attr_trigger_now.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group iio_sysfs_trigger_attr_group = {\n\t.attrs = iio_sysfs_trigger_attrs,\n};\n\nstatic const struct attribute_group *iio_sysfs_trigger_attr_groups[] = {\n\t&iio_sysfs_trigger_attr_group,\n\tNULL\n};\n\nstatic int iio_sysfs_trigger_probe(int id)\n{\n\tstruct iio_sysfs_trig *t;\n\tint ret;\n\tbool foundit = false;\n\n\tmutex_lock(&iio_sysfs_trig_list_mut);\n\tlist_for_each_entry(t, &iio_sysfs_trig_list, l)\n\t\tif (id == t->id) {\n\t\t\tfoundit = true;\n\t\t\tbreak;\n\t\t}\n\tif (foundit) {\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\tt = kmalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\tt->id = id;\n\tt->trig = iio_trigger_alloc(&iio_sysfs_trig_dev, \"sysfstrig%d\", id);\n\tif (!t->trig) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_sys_trig;\n\t}\n\n\tt->trig->dev.groups = iio_sysfs_trigger_attr_groups;\n\tiio_trigger_set_drvdata(t->trig, t);\n\n\tt->work = IRQ_WORK_INIT_HARD(iio_sysfs_trigger_work);\n\n\tret = iio_trigger_register(t->trig);\n\tif (ret)\n\t\tgoto err_free_trig;\n\tlist_add(&t->l, &iio_sysfs_trig_list);\n\t__module_get(THIS_MODULE);\n\tmutex_unlock(&iio_sysfs_trig_list_mut);\n\treturn 0;\n\nerr_free_trig:\n\tiio_trigger_free(t->trig);\nerr_free_sys_trig:\n\tkfree(t);\nerr_unlock:\n\tmutex_unlock(&iio_sysfs_trig_list_mut);\n\treturn ret;\n}\n\nstatic int iio_sysfs_trigger_remove(int id)\n{\n\tstruct iio_sysfs_trig *t = NULL, *iter;\n\n\tmutex_lock(&iio_sysfs_trig_list_mut);\n\tlist_for_each_entry(iter, &iio_sysfs_trig_list, l)\n\t\tif (id == iter->id) {\n\t\t\tt = iter;\n\t\t\tbreak;\n\t\t}\n\tif (!t) {\n\t\tmutex_unlock(&iio_sysfs_trig_list_mut);\n\t\treturn -EINVAL;\n\t}\n\n\tiio_trigger_unregister(t->trig);\n\tirq_work_sync(&t->work);\n\tiio_trigger_free(t->trig);\n\n\tlist_del(&t->l);\n\tkfree(t);\n\tmodule_put(THIS_MODULE);\n\tmutex_unlock(&iio_sysfs_trig_list_mut);\n\treturn 0;\n}\n\n\nstatic int __init iio_sysfs_trig_init(void)\n{\n\tint ret;\n\tdevice_initialize(&iio_sysfs_trig_dev);\n\tdev_set_name(&iio_sysfs_trig_dev, \"iio_sysfs_trigger\");\n\tret = device_add(&iio_sysfs_trig_dev);\n\tif (ret)\n\t\tput_device(&iio_sysfs_trig_dev);\n\treturn ret;\n}\nmodule_init(iio_sysfs_trig_init);\n\nstatic void __exit iio_sysfs_trig_exit(void)\n{\n\tdevice_unregister(&iio_sysfs_trig_dev);\n}\nmodule_exit(iio_sysfs_trig_exit);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Sysfs based trigger for the iio subsystem\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:iio-trig-sysfs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}