{
  "module_name": "iio-trig-hrtimer.c",
  "hash_id": "5b6395646bc9fa3b2c40eb9ae21cb9e6a9f88356cf4bee35f6474d864becaa3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/trigger/iio-trig-hrtimer.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/hrtimer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/sw_trigger.h>\n\n \n#define PSEC_PER_SEC   1000000000000LL\n\n \n#define HRTIMER_DEFAULT_SAMPLING_FREQUENCY 100\n\nstruct iio_hrtimer_info {\n\tstruct iio_sw_trigger swt;\n\tstruct hrtimer timer;\n\tint sampling_frequency[2];\n\tktime_t period;\n};\n\nstatic const struct config_item_type iio_hrtimer_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic\nssize_t iio_hrtimer_show_sampling_frequency(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct iio_hrtimer_info *info = iio_trigger_get_drvdata(trig);\n\n\treturn iio_format_value(buf, IIO_VAL_INT_PLUS_MICRO,\n\t\t\tARRAY_SIZE(info->sampling_frequency),\n\t\t\tinfo->sampling_frequency);\n}\n\nstatic\nssize_t iio_hrtimer_store_sampling_frequency(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_trigger *trig = to_iio_trigger(dev);\n\tstruct iio_hrtimer_info *info = iio_trigger_get_drvdata(trig);\n\tunsigned long long val;\n\tu64 period;\n\tint integer, fract, ret;\n\n\tret = iio_str_to_fixpoint(buf, 100, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\tif (integer < 0 || fract < 0)\n\t\treturn -ERANGE;\n\n\tval = fract + 1000ULL * integer;   \n\n\tif (!val || val > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tinfo->sampling_frequency[0] = integer;   \n\tinfo->sampling_frequency[1] = fract * 1000;   \n\tperiod = PSEC_PER_SEC;\n\tdo_div(period, val);\n\tinfo->period = period;   \n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(sampling_frequency, S_IRUGO | S_IWUSR,\n\t\t   iio_hrtimer_show_sampling_frequency,\n\t\t   iio_hrtimer_store_sampling_frequency);\n\nstatic struct attribute *iio_hrtimer_attrs[] = {\n\t&dev_attr_sampling_frequency.attr,\n\tNULL\n};\n\nstatic const struct attribute_group iio_hrtimer_attr_group = {\n\t.attrs = iio_hrtimer_attrs,\n};\n\nstatic const struct attribute_group *iio_hrtimer_attr_groups[] = {\n\t&iio_hrtimer_attr_group,\n\tNULL\n};\n\nstatic enum hrtimer_restart iio_hrtimer_trig_handler(struct hrtimer *timer)\n{\n\tstruct iio_hrtimer_info *info;\n\n\tinfo = container_of(timer, struct iio_hrtimer_info, timer);\n\n\thrtimer_forward_now(timer, info->period);\n\tiio_trigger_poll(info->swt.trigger);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int iio_trig_hrtimer_set_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_hrtimer_info *trig_info;\n\n\ttrig_info = iio_trigger_get_drvdata(trig);\n\n\tif (state)\n\t\thrtimer_start(&trig_info->timer, trig_info->period,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\telse\n\t\thrtimer_cancel(&trig_info->timer);\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops iio_hrtimer_trigger_ops = {\n\t.set_trigger_state = iio_trig_hrtimer_set_state,\n};\n\nstatic struct iio_sw_trigger *iio_trig_hrtimer_probe(const char *name)\n{\n\tstruct iio_hrtimer_info *trig_info;\n\tint ret;\n\n\ttrig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);\n\tif (!trig_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrig_info->swt.trigger = iio_trigger_alloc(NULL, \"%s\", name);\n\tif (!trig_info->swt.trigger) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_trig_info;\n\t}\n\n\tiio_trigger_set_drvdata(trig_info->swt.trigger, trig_info);\n\ttrig_info->swt.trigger->ops = &iio_hrtimer_trigger_ops;\n\ttrig_info->swt.trigger->dev.groups = iio_hrtimer_attr_groups;\n\n\thrtimer_init(&trig_info->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttrig_info->timer.function = iio_hrtimer_trig_handler;\n\n\ttrig_info->sampling_frequency[0] = HRTIMER_DEFAULT_SAMPLING_FREQUENCY;\n\ttrig_info->period = NSEC_PER_SEC / trig_info->sampling_frequency[0];\n\n\tret = iio_trigger_register(trig_info->swt.trigger);\n\tif (ret)\n\t\tgoto err_free_trigger;\n\n\tiio_swt_group_init_type_name(&trig_info->swt, name, &iio_hrtimer_type);\n\treturn &trig_info->swt;\nerr_free_trigger:\n\tiio_trigger_free(trig_info->swt.trigger);\nerr_free_trig_info:\n\tkfree(trig_info);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int iio_trig_hrtimer_remove(struct iio_sw_trigger *swt)\n{\n\tstruct iio_hrtimer_info *trig_info;\n\n\ttrig_info = iio_trigger_get_drvdata(swt->trigger);\n\n\tiio_trigger_unregister(swt->trigger);\n\n\t \n\thrtimer_cancel(&trig_info->timer);\n\tiio_trigger_free(swt->trigger);\n\tkfree(trig_info);\n\n\treturn 0;\n}\n\nstatic const struct iio_sw_trigger_ops iio_trig_hrtimer_ops = {\n\t.probe\t\t= iio_trig_hrtimer_probe,\n\t.remove\t\t= iio_trig_hrtimer_remove,\n};\n\nstatic struct iio_sw_trigger_type iio_trig_hrtimer = {\n\t.name = \"hrtimer\",\n\t.owner = THIS_MODULE,\n\t.ops = &iio_trig_hrtimer_ops,\n};\n\nmodule_iio_sw_trigger_driver(iio_trig_hrtimer);\n\nMODULE_AUTHOR(\"Marten Svanfeldt <marten@intuitiveaerial.com>\");\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Periodic hrtimer trigger for the IIO subsystem\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}