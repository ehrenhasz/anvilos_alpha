{
  "module_name": "sun20i-gpadc-iio.c",
  "hash_id": "79a455c8cd1dc546d49025d848baedbecf9098f21a9d7389a76299d092bfa3ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/sun20i-gpadc-iio.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n\n#include <linux/iio/iio.h>\n\n#define SUN20I_GPADC_DRIVER_NAME\t\"sun20i-gpadc\"\n\n \n#define SUN20I_GPADC_SR\t\t\t0x00\n#define SUN20I_GPADC_CTRL\t\t0x04\n#define SUN20I_GPADC_CS_EN\t\t0x08\n#define SUN20I_GPADC_FIFO_INTC\t\t0x0c\n#define SUN20I_GPADC_FIFO_INTS\t\t0x10\n#define SUN20I_GPADC_FIFO_DATA\t\t0X14\n#define SUN20I_GPADC_CB_DATA\t\t0X18\n#define SUN20I_GPADC_DATAL_INTC\t\t0x20\n#define SUN20I_GPADC_DATAH_INTC\t\t0x24\n#define SUN20I_GPADC_DATA_INTC\t\t0x28\n#define SUN20I_GPADC_DATAL_INTS\t\t0x30\n#define SUN20I_GPADC_DATAH_INTS\t\t0x34\n#define SUN20I_GPADC_DATA_INTS\t\t0x38\n#define SUN20I_GPADC_CH_CMP_DATA(x)\t(0x40 + (x) * 4)\n#define SUN20I_GPADC_CH_DATA(x)\t\t(0x80 + (x) * 4)\n\n#define SUN20I_GPADC_CTRL_ADC_AUTOCALI_EN_MASK\t\tBIT(23)\n#define SUN20I_GPADC_CTRL_WORK_MODE_MASK\t\tGENMASK(19, 18)\n#define SUN20I_GPADC_CTRL_ADC_EN_MASK\t\t\tBIT(16)\n#define SUN20I_GPADC_CS_EN_ADC_CH(x)\t\t\tBIT(x)\n#define SUN20I_GPADC_DATA_INTC_CH_DATA_IRQ_EN(x)\tBIT(x)\n\n#define SUN20I_GPADC_WORK_MODE_SINGLE\t\t\t0\n\nstruct sun20i_gpadc_iio {\n\tvoid __iomem\t\t*regs;\n\tstruct completion\tcompletion;\n\tint\t\t\tlast_channel;\n\t \n\tstruct mutex\t\tlock;\n};\n\nstatic int sun20i_gpadc_adc_read(struct sun20i_gpadc_iio *info,\n\t\t\t\t struct iio_chan_spec const *chan, int *val)\n{\n\tu32 ctrl;\n\tint ret = IIO_VAL_INT;\n\n\tmutex_lock(&info->lock);\n\n\treinit_completion(&info->completion);\n\n\tif (info->last_channel != chan->channel) {\n\t\tinfo->last_channel = chan->channel;\n\n\t\t \n\t\twritel(SUN20I_GPADC_CS_EN_ADC_CH(chan->channel),\n\t\t       info->regs + SUN20I_GPADC_CS_EN);\n\n\t\t \n\t\twritel(SUN20I_GPADC_DATA_INTC_CH_DATA_IRQ_EN(chan->channel),\n\t\t       info->regs + SUN20I_GPADC_DATA_INTC);\n\t}\n\n\t \n\tctrl = readl(info->regs + SUN20I_GPADC_CTRL);\n\tctrl |= FIELD_PREP(SUN20I_GPADC_CTRL_ADC_EN_MASK, 1);\n\twritel(ctrl, info->regs + SUN20I_GPADC_CTRL);\n\n\t \n\tif (!wait_for_completion_timeout(&info->completion, msecs_to_jiffies(10))) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_unlock;\n\t}\n\n\t \n\t*val = readl(info->regs + SUN20I_GPADC_CH_DATA(chan->channel));\n\nerr_unlock:\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic int sun20i_gpadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan, int *val,\n\t\t\t\t int *val2, long mask)\n{\n\tstruct sun20i_gpadc_iio *info = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn sun20i_gpadc_adc_read(info, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 1800;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t sun20i_gpadc_irq_handler(int irq, void *data)\n{\n\tstruct sun20i_gpadc_iio *info = data;\n\n\t \n\twritel(GENMASK(31, 0), info->regs + SUN20I_GPADC_DATA_INTS);\n\n\tcomplete(&info->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info sun20i_gpadc_iio_info = {\n\t.read_raw = sun20i_gpadc_read_raw,\n};\n\nstatic void sun20i_gpadc_reset_assert(void *data)\n{\n\tstruct reset_control *rst = data;\n\n\treset_control_assert(rst);\n}\n\nstatic int sun20i_gpadc_alloc_channels(struct iio_dev *indio_dev,\n\t\t\t\t       struct device *dev)\n{\n\tunsigned int channel;\n\tint num_channels, i, ret;\n\tstruct iio_chan_spec *channels;\n\tstruct fwnode_handle *node;\n\n\tnum_channels = device_get_child_node_count(dev);\n\tif (num_channels == 0)\n\t\treturn dev_err_probe(dev, -ENODEV, \"no channel children\\n\");\n\n\tchannels = devm_kcalloc(dev, num_channels, sizeof(*channels),\n\t\t\t\tGFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(dev, node) {\n\t\tret = fwnode_property_read_u32(node, \"reg\", &channel);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(node);\n\t\t\treturn dev_err_probe(dev, ret, \"invalid channel number\\n\");\n\t\t}\n\n\t\tchannels[i].type = IIO_VOLTAGE;\n\t\tchannels[i].indexed = 1;\n\t\tchannels[i].channel = channel;\n\t\tchannels[i].info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tchannels[i].info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\n\t\ti++;\n\t}\n\n\tindio_dev->channels = channels;\n\tindio_dev->num_channels = num_channels;\n\n\treturn 0;\n}\n\nstatic int sun20i_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct sun20i_gpadc_iio *info;\n\tstruct reset_control *rst;\n\tstruct clk *clk;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->last_channel = -1;\n\n\tmutex_init(&info->lock);\n\tinit_completion(&info->completion);\n\n\tret = sun20i_gpadc_alloc_channels(indio_dev, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &sun20i_gpadc_iio_info;\n\tindio_dev->name = SUN20I_GPADC_DRIVER_NAME;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"failed to enable bus clock\\n\");\n\n\trst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(rst), \"failed to get reset control\\n\");\n\n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to deassert reset\\n\");\n\n\tret = devm_add_action_or_reset(dev, sun20i_gpadc_reset_assert, rst);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, sun20i_gpadc_irq_handler, 0,\n\t\t\t       dev_name(dev), info);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed requesting irq %d\\n\", irq);\n\n\twritel(FIELD_PREP(SUN20I_GPADC_CTRL_ADC_AUTOCALI_EN_MASK, 1) |\n\t       FIELD_PREP(SUN20I_GPADC_CTRL_WORK_MODE_MASK, SUN20I_GPADC_WORK_MODE_SINGLE),\n\t       info->regs + SUN20I_GPADC_CTRL);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not register the device\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun20i_gpadc_of_id[] = {\n\t{ .compatible = \"allwinner,sun20i-d1-gpadc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun20i_gpadc_of_id);\n\nstatic struct platform_driver sun20i_gpadc_driver = {\n\t.driver = {\n\t\t.name = SUN20I_GPADC_DRIVER_NAME,\n\t\t.of_match_table = sun20i_gpadc_of_id,\n\t},\n\t.probe = sun20i_gpadc_probe,\n};\nmodule_platform_driver(sun20i_gpadc_driver);\n\nMODULE_DESCRIPTION(\"ADC driver for sunxi platforms\");\nMODULE_AUTHOR(\"Maksim Kiselev <bigunclemax@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}