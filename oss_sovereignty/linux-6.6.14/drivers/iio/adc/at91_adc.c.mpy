{
  "module_name": "at91_adc.c",
  "hash_id": "e94e07d8aed882071bb47b94131e93c1c233280d81ad189864f2476d3d390173",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/at91_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/pinctrl/consumer.h>\n\n \n#define AT91_ADC_CR\t\t0x00\t\t \n#define\t\tAT91_ADC_SWRST\t\t(1 << 0)\t \n#define\t\tAT91_ADC_START\t\t(1 << 1)\t \n\n#define AT91_ADC_MR\t\t0x04\t\t \n#define\t\tAT91_ADC_TSAMOD\t\t(3 << 0)\t \n#define\t\tAT91_ADC_TSAMOD_ADC_ONLY_MODE\t\t(0 << 0)\t \n#define\t\tAT91_ADC_TSAMOD_TS_ONLY_MODE\t\t(1 << 0)\t \n#define\t\tAT91_ADC_TRGEN\t\t(1 << 0)\t \n#define\t\tAT91_ADC_TRGSEL\t\t(7 << 1)\t \n#define\t\t\tAT91_ADC_TRGSEL_TC0\t\t(0 << 1)\n#define\t\t\tAT91_ADC_TRGSEL_TC1\t\t(1 << 1)\n#define\t\t\tAT91_ADC_TRGSEL_TC2\t\t(2 << 1)\n#define\t\t\tAT91_ADC_TRGSEL_EXTERNAL\t(6 << 1)\n#define\t\tAT91_ADC_LOWRES\t\t(1 << 4)\t \n#define\t\tAT91_ADC_SLEEP\t\t(1 << 5)\t \n#define\t\tAT91_ADC_PENDET\t\t(1 << 6)\t \n#define\t\tAT91_ADC_PRESCAL_9260\t(0x3f << 8)\t \n#define\t\tAT91_ADC_PRESCAL_9G45\t(0xff << 8)\n#define\t\t\tAT91_ADC_PRESCAL_(x)\t((x) << 8)\n#define\t\tAT91_ADC_STARTUP_9260\t(0x1f << 16)\t \n#define\t\tAT91_ADC_STARTUP_9G45\t(0x7f << 16)\n#define\t\tAT91_ADC_STARTUP_9X5\t(0xf << 16)\n#define\t\t\tAT91_ADC_STARTUP_(x)\t((x) << 16)\n#define\t\tAT91_ADC_SHTIM\t\t(0xf  << 24)\t \n#define\t\t\tAT91_ADC_SHTIM_(x)\t((x) << 24)\n#define\t\tAT91_ADC_PENDBC\t\t(0x0f << 28)\t \n#define\t\t\tAT91_ADC_PENDBC_(x)\t((x) << 28)\n\n#define AT91_ADC_TSR\t\t0x0C\n#define\t\tAT91_ADC_TSR_SHTIM\t(0xf  << 24)\t \n#define\t\t\tAT91_ADC_TSR_SHTIM_(x)\t((x) << 24)\n\n#define AT91_ADC_CHER\t\t0x10\t\t \n#define AT91_ADC_CHDR\t\t0x14\t\t \n#define AT91_ADC_CHSR\t\t0x18\t\t \n#define\t\tAT91_ADC_CH(n)\t\t(1 << (n))\t \n\n#define AT91_ADC_SR\t\t0x1C\t\t \n#define\t\tAT91_ADC_EOC(n)\t\t(1 << (n))\t \n#define\t\tAT91_ADC_OVRE(n)\t(1 << ((n) + 8)) \n#define\t\tAT91_ADC_DRDY\t\t(1 << 16)\t \n#define\t\tAT91_ADC_GOVRE\t\t(1 << 17)\t \n#define\t\tAT91_ADC_ENDRX\t\t(1 << 18)\t \n#define\t\tAT91_ADC_RXFUFF\t\t(1 << 19)\t \n\n#define AT91_ADC_SR_9X5\t\t0x30\t\t \n#define\t\tAT91_ADC_SR_DRDY_9X5\t(1 << 24)\t \n\n#define AT91_ADC_LCDR\t\t0x20\t\t \n#define\t\tAT91_ADC_LDATA\t\t(0x3ff)\n\n#define AT91_ADC_IER\t\t0x24\t\t \n#define AT91_ADC_IDR\t\t0x28\t\t \n#define AT91_ADC_IMR\t\t0x2C\t\t \n#define\t\tAT91RL_ADC_IER_PEN\t(1 << 20)\n#define\t\tAT91RL_ADC_IER_NOPEN\t(1 << 21)\n#define\t\tAT91_ADC_IER_PEN\t(1 << 29)\n#define\t\tAT91_ADC_IER_NOPEN\t(1 << 30)\n#define\t\tAT91_ADC_IER_XRDY\t(1 << 20)\n#define\t\tAT91_ADC_IER_YRDY\t(1 << 21)\n#define\t\tAT91_ADC_IER_PRDY\t(1 << 22)\n#define\t\tAT91_ADC_ISR_PENS\t(1 << 31)\n\n#define AT91_ADC_CHR(n)\t\t(0x30 + ((n) * 4))\t \n#define\t\tAT91_ADC_DATA\t\t(0x3ff)\n\n#define AT91_ADC_CDR0_9X5\t(0x50)\t\t\t \n\n#define AT91_ADC_ACR\t\t0x94\t \n#define\t\tAT91_ADC_ACR_PENDETSENS\t(0x3 << 0)\t \n\n#define AT91_ADC_TSMR\t\t0xB0\n#define\t\tAT91_ADC_TSMR_TSMODE\t(3 << 0)\t \n#define\t\t\tAT91_ADC_TSMR_TSMODE_NONE\t\t(0 << 0)\n#define\t\t\tAT91_ADC_TSMR_TSMODE_4WIRE_NO_PRESS\t(1 << 0)\n#define\t\t\tAT91_ADC_TSMR_TSMODE_4WIRE_PRESS\t(2 << 0)\n#define\t\t\tAT91_ADC_TSMR_TSMODE_5WIRE\t\t(3 << 0)\n#define\t\tAT91_ADC_TSMR_TSAV\t(3 << 4)\t \n#define\t\t\tAT91_ADC_TSMR_TSAV_(x)\t\t((x) << 4)\n#define\t\tAT91_ADC_TSMR_SCTIM\t(0x0f << 16)\t \n#define\t\t\tAT91_ADC_TSMR_SCTIM_(x)\t\t((x) << 16)\n#define\t\tAT91_ADC_TSMR_PENDBC\t(0x0f << 28)\t \n#define\t\t\tAT91_ADC_TSMR_PENDBC_(x)\t((x) << 28)\n#define\t\tAT91_ADC_TSMR_NOTSDMA\t(1 << 22)\t \n#define\t\tAT91_ADC_TSMR_PENDET_DIS\t(0 << 24)\t \n#define\t\tAT91_ADC_TSMR_PENDET_ENA\t(1 << 24)\t \n\n#define AT91_ADC_TSXPOSR\t0xB4\n#define AT91_ADC_TSYPOSR\t0xB8\n#define AT91_ADC_TSPRESSR\t0xBC\n\n#define AT91_ADC_TRGR_9260\tAT91_ADC_MR\n#define AT91_ADC_TRGR_9G45\t0x08\n#define AT91_ADC_TRGR_9X5\t0xC0\n\n \n#define\t\tAT91_ADC_TRGR_TRGPER\t(0xffff << 16)\n#define\t\t\tAT91_ADC_TRGR_TRGPER_(x)\t((x) << 16)\n#define\t\tAT91_ADC_TRGR_TRGMOD\t(0x7 << 0)\n#define\t\t\tAT91_ADC_TRGR_NONE\t\t(0 << 0)\n#define\t\t\tAT91_ADC_TRGR_MOD_PERIOD_TRIG\t(5 << 0)\n\n#define AT91_ADC_CHAN(st, ch) \\\n\t(st->registers->channel_base + (ch * 4))\n#define at91_adc_readl(st, reg) \\\n\t(readl_relaxed(st->reg_base + reg))\n#define at91_adc_writel(st, reg, val) \\\n\t(writel_relaxed(val, st->reg_base + reg))\n\n#define DRIVER_NAME\t\t\"at91_adc\"\n#define MAX_POS_BITS\t\t12\n\n#define TOUCH_SAMPLE_PERIOD_US\t\t2000\t \n#define TOUCH_PEN_DETECT_DEBOUNCE_US\t200\n\n#define MAX_RLPOS_BITS         10\n#define TOUCH_SAMPLE_PERIOD_US_RL      10000    \n#define TOUCH_SHTIM                    0xa\n#define TOUCH_SCTIM_US\t\t10\t\t \n\nenum atmel_adc_ts_type {\n\tATMEL_ADC_TOUCHSCREEN_NONE = 0,\n\tATMEL_ADC_TOUCHSCREEN_4WIRE = 4,\n\tATMEL_ADC_TOUCHSCREEN_5WIRE = 5,\n};\n\n \nstruct at91_adc_trigger {\n\tconst char\t*name;\n\tu8\t\tvalue;\n\tbool\t\tis_external;\n};\n\n \nstruct at91_adc_reg_desc {\n\tu8\tchannel_base;\n\tu32\tdrdy_mask;\n\tu8\tstatus_register;\n\tu8\ttrigger_register;\n\tu32\tmr_prescal_mask;\n\tu32\tmr_startup_mask;\n};\n\nstruct at91_adc_caps {\n\tbool\thas_ts;\t\t \n\tbool\thas_tsmr;\t \n\t \n\tu8\tts_filter_average;\n\t \n\tu8\tts_pen_detect_sensitivity;\n\n\t \n\tu32 (*calc_startup_ticks)(u32 startup_time, u32 adc_clk_khz);\n\n\tu8\tnum_channels;\n\n\tu8\tlow_res_bits;\n\tu8\thigh_res_bits;\n\tu32\ttrigger_number;\n\tconst struct at91_adc_trigger *triggers;\n\tstruct at91_adc_reg_desc registers;\n};\n\nstruct at91_adc_state {\n\tstruct clk\t\t*adc_clk;\n\tu16\t\t\t*buffer;\n\tunsigned long\t\tchannels_mask;\n\tstruct clk\t\t*clk;\n\tbool\t\t\tdone;\n\tint\t\t\tirq;\n\tu16\t\t\tlast_value;\n\tint\t\t\tchnb;\n\tstruct mutex\t\tlock;\n\tu8\t\t\tnum_channels;\n\tvoid __iomem\t\t*reg_base;\n\tconst struct at91_adc_reg_desc *registers;\n\tu32\t\t\tstartup_time;\n\tu8\t\t\tsample_hold_time;\n\tbool\t\t\tsleep_mode;\n\tstruct iio_trigger\t**trig;\n\tbool\t\t\tuse_external;\n\tu32\t\t\tvref_mv;\n\tu32\t\t\tres;\t\t \n\twait_queue_head_t\twq_data_avail;\n\tconst struct at91_adc_caps\t*caps;\n\n\t \n#define CHAN_MASK_TOUCHSCREEN_4WIRE\t(0xf << 0)\n#define CHAN_MASK_TOUCHSCREEN_5WIRE\t(0x1f << 0)\n\tenum atmel_adc_ts_type\ttouchscreen_type;\n\tstruct input_dev\t*ts_input;\n\n\tu16\t\t\tts_sample_period_val;\n\tu32\t\t\tts_pressure_threshold;\n\tu16\t\t\tts_pendbc;\n\n\tbool\t\t\tts_bufferedmeasure;\n\tu32\t\t\tts_prev_absx;\n\tu32\t\t\tts_prev_absy;\n};\n\nstatic irqreturn_t at91_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *idev = pf->indio_dev;\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tstruct iio_chan_spec const *chan;\n\tint i, j = 0;\n\n\tfor (i = 0; i < idev->masklength; i++) {\n\t\tif (!test_bit(i, idev->active_scan_mask))\n\t\t\tcontinue;\n\t\tchan = idev->channels + i;\n\t\tst->buffer[j] = at91_adc_readl(st, AT91_ADC_CHAN(st, chan->channel));\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(idev, st->buffer, pf->timestamp);\n\n\tiio_trigger_notify_done(idev->trig);\n\n\t \n\tat91_adc_readl(st, AT91_ADC_LCDR);\n\n\tenable_irq(st->irq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void handle_adc_eoc_trigger(int irq, struct iio_dev *idev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\n\tif (iio_buffer_enabled(idev)) {\n\t\tdisable_irq_nosync(irq);\n\t\tiio_trigger_poll(idev->trig);\n\t} else {\n\t\tst->last_value = at91_adc_readl(st, AT91_ADC_CHAN(st, st->chnb));\n\t\t \n\t\tat91_adc_readl(st, AT91_ADC_LCDR);\n\t\tst->done = true;\n\t\twake_up_interruptible(&st->wq_data_avail);\n\t}\n}\n\nstatic int at91_ts_sample(struct iio_dev *idev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tunsigned int xscale, yscale, reg, z1, z2;\n\tunsigned int x, y, pres, xpos, ypos;\n\tunsigned int rxp = 1;\n\tunsigned int factor = 1000;\n\n\tunsigned int xyz_mask_bits = st->res;\n\tunsigned int xyz_mask = (1 << xyz_mask_bits) - 1;\n\n\t \n\t \n\treg = at91_adc_readl(st, AT91_ADC_TSXPOSR);\n\txpos = reg & xyz_mask;\n\tx = (xpos << MAX_POS_BITS) - xpos;\n\txscale = (reg >> 16) & xyz_mask;\n\tif (xscale == 0) {\n\t\tdev_err(&idev->dev, \"Error: xscale == 0!\\n\");\n\t\treturn -1;\n\t}\n\tx /= xscale;\n\n\t \n\treg = at91_adc_readl(st, AT91_ADC_TSYPOSR);\n\typos = reg & xyz_mask;\n\ty = (ypos << MAX_POS_BITS) - ypos;\n\tyscale = (reg >> 16) & xyz_mask;\n\tif (yscale == 0) {\n\t\tdev_err(&idev->dev, \"Error: yscale == 0!\\n\");\n\t\treturn -1;\n\t}\n\ty /= yscale;\n\n\t \n\treg = at91_adc_readl(st, AT91_ADC_TSPRESSR);\n\tz1 = reg & xyz_mask;\n\tz2 = (reg >> 16) & xyz_mask;\n\n\tif (z1 != 0)\n\t\tpres = rxp * (x * factor / 1024) * (z2 * factor / z1 - factor)\n\t\t\t/ factor;\n\telse\n\t\tpres = st->ts_pressure_threshold;\t \n\n\tdev_dbg(&idev->dev, \"xpos = %d, xscale = %d, ypos = %d, yscale = %d, z1 = %d, z2 = %d, press = %d\\n\",\n\t\t\t\txpos, xscale, ypos, yscale, z1, z2, pres);\n\n\tif (pres < st->ts_pressure_threshold) {\n\t\tdev_dbg(&idev->dev, \"x = %d, y = %d, pressure = %d\\n\",\n\t\t\t\t\tx, y, pres / factor);\n\t\tinput_report_abs(st->ts_input, ABS_X, x);\n\t\tinput_report_abs(st->ts_input, ABS_Y, y);\n\t\tinput_report_abs(st->ts_input, ABS_PRESSURE, pres);\n\t\tinput_report_key(st->ts_input, BTN_TOUCH, 1);\n\t\tinput_sync(st->ts_input);\n\t} else {\n\t\tdev_dbg(&idev->dev, \"pressure too low: not reporting\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t at91_adc_rl_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *idev = private;\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tu32 status = at91_adc_readl(st, st->registers->status_register);\n\tunsigned int reg;\n\n\tstatus &= at91_adc_readl(st, AT91_ADC_IMR);\n\tif (status & GENMASK(st->num_channels - 1, 0))\n\t\thandle_adc_eoc_trigger(irq, idev);\n\n\tif (status & AT91RL_ADC_IER_PEN) {\n\t\t \n\t\treg = at91_adc_readl(st, AT91_ADC_MR);\n\t\treg &= ~AT91_ADC_PENDBC;\n\t\tat91_adc_writel(st, AT91_ADC_MR, reg);\n\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_PEN);\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_NOPEN\n\t\t\t\t| AT91_ADC_EOC(3));\n\t\t \n\t\tat91_adc_writel(st, st->registers->trigger_register,\n\t\t\tAT91_ADC_TRGR_MOD_PERIOD_TRIG |\n\t\t\tAT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val));\n\t} else if (status & AT91RL_ADC_IER_NOPEN) {\n\t\treg = at91_adc_readl(st, AT91_ADC_MR);\n\t\treg |= AT91_ADC_PENDBC_(st->ts_pendbc) & AT91_ADC_PENDBC;\n\t\tat91_adc_writel(st, AT91_ADC_MR, reg);\n\t\tat91_adc_writel(st, st->registers->trigger_register,\n\t\t\tAT91_ADC_TRGR_NONE);\n\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_NOPEN\n\t\t\t\t| AT91_ADC_EOC(3));\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_PEN);\n\t\tst->ts_bufferedmeasure = false;\n\t\tinput_report_key(st->ts_input, BTN_TOUCH, 0);\n\t\tinput_sync(st->ts_input);\n\t} else if (status & AT91_ADC_EOC(3) && st->ts_input) {\n\t\t \n\t\tif (st->ts_bufferedmeasure) {\n\t\t\t \n\t\t\tinput_report_abs(st->ts_input, ABS_X, st->ts_prev_absx);\n\t\t\tinput_report_abs(st->ts_input, ABS_Y, st->ts_prev_absy);\n\t\t\tinput_report_key(st->ts_input, BTN_TOUCH, 1);\n\t\t\tinput_sync(st->ts_input);\n\t\t} else\n\t\t\tst->ts_bufferedmeasure = true;\n\n\t\t \n\t\tst->ts_prev_absx = at91_adc_readl(st, AT91_ADC_CHAN(st, 3))\n\t\t\t\t   << MAX_RLPOS_BITS;\n\t\tst->ts_prev_absx /= at91_adc_readl(st, AT91_ADC_CHAN(st, 2));\n\n\t\tst->ts_prev_absy = at91_adc_readl(st, AT91_ADC_CHAN(st, 1))\n\t\t\t\t   << MAX_RLPOS_BITS;\n\t\tst->ts_prev_absy /= at91_adc_readl(st, AT91_ADC_CHAN(st, 0));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t at91_adc_9x5_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *idev = private;\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tu32 status = at91_adc_readl(st, st->registers->status_register);\n\tconst uint32_t ts_data_irq_mask =\n\t\tAT91_ADC_IER_XRDY |\n\t\tAT91_ADC_IER_YRDY |\n\t\tAT91_ADC_IER_PRDY;\n\n\tif (status & GENMASK(st->num_channels - 1, 0))\n\t\thandle_adc_eoc_trigger(irq, idev);\n\n\tif (status & AT91_ADC_IER_PEN) {\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_PEN);\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_NOPEN |\n\t\t\tts_data_irq_mask);\n\t\t \n\t\tat91_adc_writel(st, st->registers->trigger_register,\n\t\t\tAT91_ADC_TRGR_MOD_PERIOD_TRIG |\n\t\t\tAT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val));\n\t} else if (status & AT91_ADC_IER_NOPEN) {\n\t\tat91_adc_writel(st, st->registers->trigger_register, 0);\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_NOPEN |\n\t\t\tts_data_irq_mask);\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);\n\n\t\tinput_report_key(st->ts_input, BTN_TOUCH, 0);\n\t\tinput_sync(st->ts_input);\n\t} else if ((status & ts_data_irq_mask) == ts_data_irq_mask) {\n\t\t \n\n\t\tif (status & AT91_ADC_ISR_PENS) {\n\t\t\t \n\t\t\tat91_ts_sample(idev);\n\t\t} else {\n\t\t\t \n\t\t\tat91_adc_readl(st, AT91_ADC_TSXPOSR);\n\t\t\tat91_adc_readl(st, AT91_ADC_TSYPOSR);\n\t\t\tat91_adc_readl(st, AT91_ADC_TSPRESSR);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int at91_adc_channel_init(struct iio_dev *idev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tstruct iio_chan_spec *chan_array, *timestamp;\n\tint bit, idx = 0;\n\tunsigned long rsvd_mask = 0;\n\n\t \n\tif (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_4WIRE)\n\t\trsvd_mask = CHAN_MASK_TOUCHSCREEN_4WIRE;\n\telse if (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_5WIRE)\n\t\trsvd_mask = CHAN_MASK_TOUCHSCREEN_5WIRE;\n\n\t \n\tst->channels_mask &= ~rsvd_mask;\n\n\tidev->num_channels = bitmap_weight(&st->channels_mask,\n\t\t\t\t\t   st->num_channels) + 1;\n\n\tchan_array = devm_kzalloc(&idev->dev,\n\t\t\t\t  ((idev->num_channels + 1) *\n\t\t\t\t\tsizeof(struct iio_chan_spec)),\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!chan_array)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(bit, &st->channels_mask, st->num_channels) {\n\t\tstruct iio_chan_spec *chan = chan_array + idx;\n\n\t\tchan->type = IIO_VOLTAGE;\n\t\tchan->indexed = 1;\n\t\tchan->channel = bit;\n\t\tchan->scan_index = idx;\n\t\tchan->scan_type.sign = 'u';\n\t\tchan->scan_type.realbits = st->res;\n\t\tchan->scan_type.storagebits = 16;\n\t\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tidx++;\n\t}\n\ttimestamp = chan_array + idx;\n\n\ttimestamp->type = IIO_TIMESTAMP;\n\ttimestamp->channel = -1;\n\ttimestamp->scan_index = idx;\n\ttimestamp->scan_type.sign = 's';\n\ttimestamp->scan_type.realbits = 64;\n\ttimestamp->scan_type.storagebits = 64;\n\n\tidev->channels = chan_array;\n\treturn idev->num_channels;\n}\n\nstatic int at91_adc_get_trigger_value_by_name(struct iio_dev *idev,\n\t\t\t\t\t     const struct at91_adc_trigger *triggers,\n\t\t\t\t\t     const char *trigger_name)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tint i;\n\n\tfor (i = 0; i < st->caps->trigger_number; i++) {\n\t\tchar *name = kasprintf(GFP_KERNEL,\n\t\t\t\t\"%s-dev%d-%s\",\n\t\t\t\tidev->name,\n\t\t\t\tiio_device_id(idev),\n\t\t\t\ttriggers[i].name);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (strcmp(trigger_name, name) == 0) {\n\t\t\tkfree(name);\n\t\t\tif (triggers[i].value == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn triggers[i].value;\n\t\t}\n\n\t\tkfree(name);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int at91_adc_configure_trigger(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *idev = iio_trigger_get_drvdata(trig);\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tconst struct at91_adc_reg_desc *reg = st->registers;\n\tu32 status = at91_adc_readl(st, reg->trigger_register);\n\tint value;\n\tu8 bit;\n\n\tvalue = at91_adc_get_trigger_value_by_name(idev,\n\t\t\t\t\t\t   st->caps->triggers,\n\t\t\t\t\t\t   idev->trig->name);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (state) {\n\t\tst->buffer = kmalloc(idev->scan_bytes, GFP_KERNEL);\n\t\tif (st->buffer == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tat91_adc_writel(st, reg->trigger_register,\n\t\t\t\tstatus | value);\n\n\t\tfor_each_set_bit(bit, idev->active_scan_mask,\n\t\t\t\t st->num_channels) {\n\t\t\tstruct iio_chan_spec const *chan = idev->channels + bit;\n\t\t\tat91_adc_writel(st, AT91_ADC_CHER,\n\t\t\t\t\tAT91_ADC_CH(chan->channel));\n\t\t}\n\n\t\tat91_adc_writel(st, AT91_ADC_IER, reg->drdy_mask);\n\n\t} else {\n\t\tat91_adc_writel(st, AT91_ADC_IDR, reg->drdy_mask);\n\n\t\tat91_adc_writel(st, reg->trigger_register,\n\t\t\t\tstatus & ~value);\n\n\t\tfor_each_set_bit(bit, idev->active_scan_mask,\n\t\t\t\t st->num_channels) {\n\t\t\tstruct iio_chan_spec const *chan = idev->channels + bit;\n\t\t\tat91_adc_writel(st, AT91_ADC_CHDR,\n\t\t\t\t\tAT91_ADC_CH(chan->channel));\n\t\t}\n\t\tkfree(st->buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops at91_adc_trigger_ops = {\n\t.set_trigger_state = &at91_adc_configure_trigger,\n};\n\nstatic struct iio_trigger *at91_adc_allocate_trigger(struct iio_dev *idev,\n\t\t\t\t\t\t     const struct at91_adc_trigger *trigger)\n{\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = iio_trigger_alloc(idev->dev.parent, \"%s-dev%d-%s\", idev->name,\n\t\t\t\t iio_device_id(idev), trigger->name);\n\tif (trig == NULL)\n\t\treturn NULL;\n\n\tiio_trigger_set_drvdata(trig, idev);\n\ttrig->ops = &at91_adc_trigger_ops;\n\n\tret = iio_trigger_register(trig);\n\tif (ret) {\n\t\tiio_trigger_free(trig);\n\t\treturn NULL;\n\t}\n\n\treturn trig;\n}\n\nstatic int at91_adc_trigger_init(struct iio_dev *idev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tint i, ret;\n\n\tst->trig = devm_kcalloc(&idev->dev,\n\t\t\t\tst->caps->trigger_number, sizeof(*st->trig),\n\t\t\t\tGFP_KERNEL);\n\n\tif (st->trig == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_ret;\n\t}\n\n\tfor (i = 0; i < st->caps->trigger_number; i++) {\n\t\tif (st->caps->triggers[i].is_external && !(st->use_external))\n\t\t\tcontinue;\n\n\t\tst->trig[i] = at91_adc_allocate_trigger(idev,\n\t\t\t\t\t\t\tst->caps->triggers + i);\n\t\tif (st->trig[i] == NULL) {\n\t\t\tdev_err(&idev->dev,\n\t\t\t\t\"Could not allocate trigger %d\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_trigger;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_trigger:\n\tfor (i--; i >= 0; i--) {\n\t\tiio_trigger_unregister(st->trig[i]);\n\t\tiio_trigger_free(st->trig[i]);\n\t}\nerror_ret:\n\treturn ret;\n}\n\nstatic void at91_adc_trigger_remove(struct iio_dev *idev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tint i;\n\n\tfor (i = 0; i < st->caps->trigger_number; i++) {\n\t\tiio_trigger_unregister(st->trig[i]);\n\t\tiio_trigger_free(st->trig[i]);\n\t}\n}\n\nstatic int at91_adc_buffer_init(struct iio_dev *idev)\n{\n\treturn iio_triggered_buffer_setup(idev, &iio_pollfunc_store_time,\n\t\t&at91_adc_trigger_handler, NULL);\n}\n\nstatic void at91_adc_buffer_remove(struct iio_dev *idev)\n{\n\tiio_triggered_buffer_cleanup(idev);\n}\n\nstatic int at91_adc_read_raw(struct iio_dev *idev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\n\t\tst->chnb = chan->channel;\n\t\tat91_adc_writel(st, AT91_ADC_CHER,\n\t\t\t\tAT91_ADC_CH(chan->channel));\n\t\tat91_adc_writel(st, AT91_ADC_IER, BIT(chan->channel));\n\t\tat91_adc_writel(st, AT91_ADC_CR, AT91_ADC_START);\n\n\t\tret = wait_event_interruptible_timeout(st->wq_data_avail,\n\t\t\t\t\t\t       st->done,\n\t\t\t\t\t\t       msecs_to_jiffies(1000));\n\n\t\t \n\t\tat91_adc_writel(st, AT91_ADC_CHDR,\n\t\t\t\tAT91_ADC_CH(chan->channel));\n\t\tat91_adc_writel(st, AT91_ADC_IDR, BIT(chan->channel));\n\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\t*val = st->last_value;\n\t\t\tst->last_value = 0;\n\t\t\tst->done = false;\n\t\t\tret = IIO_VAL_INT;\n\t\t} else if (ret == 0) {\n\t\t\t \n\t\t\tdev_err(&idev->dev, \"ADC Channel %d timeout.\\n\",\n\t\t\t\tchan->channel);\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic u32 calc_startup_ticks_9260(u32 startup_time, u32 adc_clk_khz)\n{\n\t \n\treturn round_up((startup_time * adc_clk_khz / 1000) - 1, 8) / 8;\n}\n\nstatic u32 calc_startup_ticks_9x5(u32 startup_time, u32 adc_clk_khz)\n{\n\t \n\tstatic const int startup_lookup[] = {\n\t\t0,   8,   16,  24,\n\t\t64,  80,  96,  112,\n\t\t512, 576, 640, 704,\n\t\t768, 832, 896, 960\n\t\t};\n\tint i, size = ARRAY_SIZE(startup_lookup);\n\tunsigned int ticks;\n\n\tticks = startup_time * adc_clk_khz / 1000;\n\tfor (i = 0; i < size; i++)\n\t\tif (ticks < startup_lookup[i])\n\t\t\tbreak;\n\n\tticks = i;\n\tif (ticks == size)\n\t\t \n\t\tticks = size - 1;\n\n\treturn ticks;\n}\n\nstatic int at91_adc_probe_dt_ts(struct device_node *node,\n\tstruct at91_adc_state *st, struct device *dev)\n{\n\tint ret;\n\tu32 prop;\n\n\tret = of_property_read_u32(node, \"atmel,adc-ts-wires\", &prop);\n\tif (ret) {\n\t\tdev_info(dev, \"ADC Touch screen is disabled.\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (prop) {\n\tcase 4:\n\tcase 5:\n\t\tst->touchscreen_type = prop;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported number of touchscreen wires (%d). Should be 4 or 5.\\n\", prop);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!st->caps->has_tsmr)\n\t\treturn 0;\n\tprop = 0;\n\tof_property_read_u32(node, \"atmel,adc-ts-pressure-threshold\", &prop);\n\tst->ts_pressure_threshold = prop;\n\tif (st->ts_pressure_threshold) {\n\t\treturn 0;\n\t} else {\n\t\tdev_err(dev, \"Invalid pressure threshold for the touchscreen\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info at91_adc_info = {\n\t.read_raw = &at91_adc_read_raw,\n};\n\n \nstatic int atmel_ts_open(struct input_dev *dev)\n{\n\tstruct at91_adc_state *st = input_get_drvdata(dev);\n\n\tif (st->caps->has_tsmr)\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);\n\telse\n\t\tat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_PEN);\n\treturn 0;\n}\n\nstatic void atmel_ts_close(struct input_dev *dev)\n{\n\tstruct at91_adc_state *st = input_get_drvdata(dev);\n\n\tif (st->caps->has_tsmr)\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_PEN);\n\telse\n\t\tat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_PEN);\n}\n\nstatic int at91_ts_hw_init(struct iio_dev *idev, u32 adc_clk_khz)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tu32 reg = 0;\n\tu32 tssctim = 0;\n\tint i = 0;\n\n\t \n\tst->ts_pendbc = round_up(TOUCH_PEN_DETECT_DEBOUNCE_US * adc_clk_khz /\n\t\t\t\t 1000, 1);\n\n\twhile (st->ts_pendbc >> ++i)\n\t\t;\t \n\tif (abs(st->ts_pendbc - (1 << i)) < abs(st->ts_pendbc - (1 << (i - 1))))\n\t\tst->ts_pendbc = i;\n\telse\n\t\tst->ts_pendbc = i - 1;\n\n\tif (!st->caps->has_tsmr) {\n\t\treg = at91_adc_readl(st, AT91_ADC_MR);\n\t\treg |= AT91_ADC_TSAMOD_TS_ONLY_MODE | AT91_ADC_PENDET;\n\n\t\treg |= AT91_ADC_PENDBC_(st->ts_pendbc) & AT91_ADC_PENDBC;\n\t\tat91_adc_writel(st, AT91_ADC_MR, reg);\n\n\t\treg = AT91_ADC_TSR_SHTIM_(TOUCH_SHTIM) & AT91_ADC_TSR_SHTIM;\n\t\tat91_adc_writel(st, AT91_ADC_TSR, reg);\n\n\t\tst->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US_RL *\n\t\t\t\t\t\t    adc_clk_khz / 1000) - 1, 1);\n\n\t\treturn 0;\n\t}\n\n\t \n\ttssctim = DIV_ROUND_UP(TOUCH_SCTIM_US * adc_clk_khz / 1000, 4);\n\tdev_dbg(&idev->dev, \"adc_clk at: %d KHz, tssctim at: %d\\n\",\n\t\tadc_clk_khz, tssctim);\n\n\tif (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_4WIRE)\n\t\treg = AT91_ADC_TSMR_TSMODE_4WIRE_PRESS;\n\telse\n\t\treg = AT91_ADC_TSMR_TSMODE_5WIRE;\n\n\treg |= AT91_ADC_TSMR_SCTIM_(tssctim) & AT91_ADC_TSMR_SCTIM;\n\treg |= AT91_ADC_TSMR_TSAV_(st->caps->ts_filter_average)\n\t       & AT91_ADC_TSMR_TSAV;\n\treg |= AT91_ADC_TSMR_PENDBC_(st->ts_pendbc) & AT91_ADC_TSMR_PENDBC;\n\treg |= AT91_ADC_TSMR_NOTSDMA;\n\treg |= AT91_ADC_TSMR_PENDET_ENA;\n\treg |= 0x03 << 8;\t \n\n\tat91_adc_writel(st, AT91_ADC_TSMR, reg);\n\n\t \n\tat91_adc_writel(st, AT91_ADC_ACR, st->caps->ts_pen_detect_sensitivity\n\t\t\t& AT91_ADC_ACR_PENDETSENS);\n\n\t \n\tst->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US *\n\t\t\tadc_clk_khz / 1000) - 1, 1);\n\n\treturn 0;\n}\n\nstatic int at91_ts_register(struct iio_dev *idev,\n\t\tstruct platform_device *pdev)\n{\n\tstruct at91_adc_state *st = iio_priv(idev);\n\tstruct input_dev *input;\n\tint ret;\n\n\tinput = input_allocate_device();\n\tif (!input) {\n\t\tdev_err(&idev->dev, \"Failed to allocate TS device!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = DRIVER_NAME;\n\tinput->id.bustype = BUS_HOST;\n\tinput->dev.parent = &pdev->dev;\n\tinput->open = atmel_ts_open;\n\tinput->close = atmel_ts_close;\n\n\t__set_bit(EV_ABS, input->evbit);\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(BTN_TOUCH, input->keybit);\n\tif (st->caps->has_tsmr) {\n\t\tinput_set_abs_params(input, ABS_X, 0, (1 << MAX_POS_BITS) - 1,\n\t\t\t\t     0, 0);\n\t\tinput_set_abs_params(input, ABS_Y, 0, (1 << MAX_POS_BITS) - 1,\n\t\t\t\t     0, 0);\n\t\tinput_set_abs_params(input, ABS_PRESSURE, 0, 0xffffff, 0, 0);\n\t} else {\n\t\tif (st->touchscreen_type != ATMEL_ADC_TOUCHSCREEN_4WIRE) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"This touchscreen controller only support 4 wires\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tinput_set_abs_params(input, ABS_X, 0, (1 << MAX_RLPOS_BITS) - 1,\n\t\t\t\t     0, 0);\n\t\tinput_set_abs_params(input, ABS_Y, 0, (1 << MAX_RLPOS_BITS) - 1,\n\t\t\t\t     0, 0);\n\t}\n\n\tst->ts_input = input;\n\tinput_set_drvdata(input, st);\n\n\tret = input_register_device(input);\n\tif (ret)\n\t\tgoto err;\n\n\treturn ret;\n\nerr:\n\tinput_free_device(st->ts_input);\n\treturn ret;\n}\n\nstatic void at91_ts_unregister(struct at91_adc_state *st)\n{\n\tinput_unregister_device(st->ts_input);\n}\n\nstatic int at91_adc_probe(struct platform_device *pdev)\n{\n\tunsigned int prsc, mstrclk, ticks, adc_clk, adc_clk_khz, shtim;\n\tstruct device_node *node = pdev->dev.of_node;\n\tint ret;\n\tstruct iio_dev *idev;\n\tstruct at91_adc_state *st;\n\tu32 reg, prop;\n\tchar *s;\n\n\tidev = devm_iio_device_alloc(&pdev->dev, sizeof(struct at91_adc_state));\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(idev);\n\n\tst->caps = of_device_get_match_data(&pdev->dev);\n\n\tst->use_external = of_property_read_bool(node, \"atmel,adc-use-external-triggers\");\n\n\tif (of_property_read_u32(node, \"atmel,adc-channels-used\", &prop)) {\n\t\tdev_err(&idev->dev, \"Missing adc-channels-used property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tst->channels_mask = prop;\n\n\tst->sleep_mode = of_property_read_bool(node, \"atmel,adc-sleep-mode\");\n\n\tif (of_property_read_u32(node, \"atmel,adc-startup-time\", &prop)) {\n\t\tdev_err(&idev->dev, \"Missing adc-startup-time property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tst->startup_time = prop;\n\n\tprop = 0;\n\tof_property_read_u32(node, \"atmel,adc-sample-hold-time\", &prop);\n\tst->sample_hold_time = prop;\n\n\tif (of_property_read_u32(node, \"atmel,adc-vref\", &prop)) {\n\t\tdev_err(&idev->dev, \"Missing adc-vref property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tst->vref_mv = prop;\n\n\tst->res = st->caps->high_res_bits;\n\tif (st->caps->low_res_bits &&\n\t    !of_property_read_string(node, \"atmel,adc-use-res\", (const char **)&s)\n\t    && !strcmp(s, \"lowres\"))\n\t\tst->res = st->caps->low_res_bits;\n\n\tdev_info(&idev->dev, \"Resolution used: %u bits\\n\", st->res);\n\n\tst->registers = &st->caps->registers;\n\tst->num_channels = st->caps->num_channels;\n\n\t \n\tif (st->caps->has_ts) {\n\t\tret = at91_adc_probe_dt_ts(node, st, &idev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, idev);\n\n\tidev->name = dev_name(&pdev->dev);\n\tidev->modes = INDIO_DIRECT_MODE;\n\tidev->info = &at91_adc_info;\n\n\tst->irq = platform_get_irq(pdev, 0);\n\tif (st->irq < 0)\n\t\treturn -ENODEV;\n\n\tst->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(st->reg_base))\n\t\treturn PTR_ERR(st->reg_base);\n\n\n\t \n\tat91_adc_writel(st, AT91_ADC_CR, AT91_ADC_SWRST);\n\tat91_adc_writel(st, AT91_ADC_IDR, 0xFFFFFFFF);\n\n\tif (st->caps->has_tsmr)\n\t\tret = request_irq(st->irq, at91_adc_9x5_interrupt, 0,\n\t\t\t\t  pdev->dev.driver->name, idev);\n\telse\n\t\tret = request_irq(st->irq, at91_adc_rl_interrupt, 0,\n\t\t\t\t  pdev->dev.driver->name, idev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate IRQ.\\n\");\n\t\treturn ret;\n\t}\n\n\tst->clk = devm_clk_get(&pdev->dev, \"adc_clk\");\n\tif (IS_ERR(st->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get the clock.\\n\");\n\t\tret = PTR_ERR(st->clk);\n\t\tgoto error_free_irq;\n\t}\n\n\tret = clk_prepare_enable(st->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not prepare or enable the clock.\\n\");\n\t\tgoto error_free_irq;\n\t}\n\n\tst->adc_clk = devm_clk_get(&pdev->dev, \"adc_op_clk\");\n\tif (IS_ERR(st->adc_clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get the ADC clock.\\n\");\n\t\tret = PTR_ERR(st->adc_clk);\n\t\tgoto error_disable_clk;\n\t}\n\n\tret = clk_prepare_enable(st->adc_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not prepare or enable the ADC clock.\\n\");\n\t\tgoto error_disable_clk;\n\t}\n\n\t \n\tmstrclk = clk_get_rate(st->clk);\n\tadc_clk = clk_get_rate(st->adc_clk);\n\tadc_clk_khz = adc_clk / 1000;\n\n\tdev_dbg(&pdev->dev, \"Master clock is set as: %d Hz, adc_clk should set as: %d Hz\\n\",\n\t\tmstrclk, adc_clk);\n\n\tprsc = (mstrclk / (2 * adc_clk)) - 1;\n\n\tif (!st->startup_time) {\n\t\tdev_err(&pdev->dev, \"No startup time available.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_disable_adc_clk;\n\t}\n\tticks = (*st->caps->calc_startup_ticks)(st->startup_time, adc_clk_khz);\n\n\t \n\tif (st->sample_hold_time > 0)\n\t\tshtim = round_up((st->sample_hold_time * adc_clk_khz / 1000)\n\t\t\t\t - 1, 1);\n\telse\n\t\tshtim = 0;\n\n\treg = AT91_ADC_PRESCAL_(prsc) & st->registers->mr_prescal_mask;\n\treg |= AT91_ADC_STARTUP_(ticks) & st->registers->mr_startup_mask;\n\tif (st->res == st->caps->low_res_bits)\n\t\treg |= AT91_ADC_LOWRES;\n\tif (st->sleep_mode)\n\t\treg |= AT91_ADC_SLEEP;\n\treg |= AT91_ADC_SHTIM_(shtim) & AT91_ADC_SHTIM;\n\tat91_adc_writel(st, AT91_ADC_MR, reg);\n\n\t \n\tret = at91_adc_channel_init(idev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't initialize the channels.\\n\");\n\t\tgoto error_disable_adc_clk;\n\t}\n\n\tinit_waitqueue_head(&st->wq_data_avail);\n\tmutex_init(&st->lock);\n\n\t \n\tif (!st->touchscreen_type) {\n\t\tret = at91_adc_buffer_init(idev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't initialize the buffer.\\n\");\n\t\t\tgoto error_disable_adc_clk;\n\t\t}\n\n\t\tret = at91_adc_trigger_init(idev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't setup the triggers.\\n\");\n\t\t\tat91_adc_buffer_remove(idev);\n\t\t\tgoto error_disable_adc_clk;\n\t\t}\n\t} else {\n\t\tret = at91_ts_register(idev, pdev);\n\t\tif (ret)\n\t\t\tgoto error_disable_adc_clk;\n\n\t\tat91_ts_hw_init(idev, adc_clk_khz);\n\t}\n\n\tret = iio_device_register(idev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't register the device.\\n\");\n\t\tgoto error_iio_device_register;\n\t}\n\n\treturn 0;\n\nerror_iio_device_register:\n\tif (!st->touchscreen_type) {\n\t\tat91_adc_trigger_remove(idev);\n\t\tat91_adc_buffer_remove(idev);\n\t} else {\n\t\tat91_ts_unregister(st);\n\t}\nerror_disable_adc_clk:\n\tclk_disable_unprepare(st->adc_clk);\nerror_disable_clk:\n\tclk_disable_unprepare(st->clk);\nerror_free_irq:\n\tfree_irq(st->irq, idev);\n\treturn ret;\n}\n\nstatic int at91_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *idev = platform_get_drvdata(pdev);\n\tstruct at91_adc_state *st = iio_priv(idev);\n\n\tiio_device_unregister(idev);\n\tif (!st->touchscreen_type) {\n\t\tat91_adc_trigger_remove(idev);\n\t\tat91_adc_buffer_remove(idev);\n\t} else {\n\t\tat91_ts_unregister(st);\n\t}\n\tclk_disable_unprepare(st->adc_clk);\n\tclk_disable_unprepare(st->clk);\n\tfree_irq(st->irq, idev);\n\n\treturn 0;\n}\n\nstatic int at91_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *idev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(idev);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\tclk_disable_unprepare(st->clk);\n\n\treturn 0;\n}\n\nstatic int at91_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *idev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(idev);\n\n\tclk_prepare_enable(st->clk);\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(at91_adc_pm_ops, at91_adc_suspend,\n\t\t\t\tat91_adc_resume);\n\nstatic const struct at91_adc_trigger at91sam9260_triggers[] = {\n\t{ .name = \"timer-counter-0\", .value = 0x1 },\n\t{ .name = \"timer-counter-1\", .value = 0x3 },\n\t{ .name = \"timer-counter-2\", .value = 0x5 },\n\t{ .name = \"external\", .value = 0xd, .is_external = true },\n};\n\nstatic struct at91_adc_caps at91sam9260_caps = {\n\t.calc_startup_ticks = calc_startup_ticks_9260,\n\t.num_channels = 4,\n\t.low_res_bits = 8,\n\t.high_res_bits = 10,\n\t.registers = {\n\t\t.channel_base = AT91_ADC_CHR(0),\n\t\t.drdy_mask = AT91_ADC_DRDY,\n\t\t.status_register = AT91_ADC_SR,\n\t\t.trigger_register = AT91_ADC_TRGR_9260,\n\t\t.mr_prescal_mask = AT91_ADC_PRESCAL_9260,\n\t\t.mr_startup_mask = AT91_ADC_STARTUP_9260,\n\t},\n\t.triggers = at91sam9260_triggers,\n\t.trigger_number = ARRAY_SIZE(at91sam9260_triggers),\n};\n\nstatic const struct at91_adc_trigger at91sam9x5_triggers[] = {\n\t{ .name = \"external-rising\", .value = 0x1, .is_external = true },\n\t{ .name = \"external-falling\", .value = 0x2, .is_external = true },\n\t{ .name = \"external-any\", .value = 0x3, .is_external = true },\n\t{ .name = \"continuous\", .value = 0x6 },\n};\n\nstatic struct at91_adc_caps at91sam9rl_caps = {\n\t.has_ts = true,\n\t.calc_startup_ticks = calc_startup_ticks_9260,\t \n\t.num_channels = 6,\n\t.low_res_bits = 8,\n\t.high_res_bits = 10,\n\t.registers = {\n\t\t.channel_base = AT91_ADC_CHR(0),\n\t\t.drdy_mask = AT91_ADC_DRDY,\n\t\t.status_register = AT91_ADC_SR,\n\t\t.trigger_register = AT91_ADC_TRGR_9G45,\n\t\t.mr_prescal_mask = AT91_ADC_PRESCAL_9260,\n\t\t.mr_startup_mask = AT91_ADC_STARTUP_9G45,\n\t},\n\t.triggers = at91sam9x5_triggers,\n\t.trigger_number = ARRAY_SIZE(at91sam9x5_triggers),\n};\n\nstatic struct at91_adc_caps at91sam9g45_caps = {\n\t.has_ts = true,\n\t.calc_startup_ticks = calc_startup_ticks_9260,\t \n\t.num_channels = 8,\n\t.low_res_bits = 8,\n\t.high_res_bits = 10,\n\t.registers = {\n\t\t.channel_base = AT91_ADC_CHR(0),\n\t\t.drdy_mask = AT91_ADC_DRDY,\n\t\t.status_register = AT91_ADC_SR,\n\t\t.trigger_register = AT91_ADC_TRGR_9G45,\n\t\t.mr_prescal_mask = AT91_ADC_PRESCAL_9G45,\n\t\t.mr_startup_mask = AT91_ADC_STARTUP_9G45,\n\t},\n\t.triggers = at91sam9x5_triggers,\n\t.trigger_number = ARRAY_SIZE(at91sam9x5_triggers),\n};\n\nstatic struct at91_adc_caps at91sam9x5_caps = {\n\t.has_ts = true,\n\t.has_tsmr = true,\n\t.ts_filter_average = 3,\n\t.ts_pen_detect_sensitivity = 2,\n\t.calc_startup_ticks = calc_startup_ticks_9x5,\n\t.num_channels = 12,\n\t.low_res_bits = 8,\n\t.high_res_bits = 10,\n\t.registers = {\n\t\t.channel_base = AT91_ADC_CDR0_9X5,\n\t\t.drdy_mask = AT91_ADC_SR_DRDY_9X5,\n\t\t.status_register = AT91_ADC_SR_9X5,\n\t\t.trigger_register = AT91_ADC_TRGR_9X5,\n\t\t \n\t\t.mr_prescal_mask = AT91_ADC_PRESCAL_9G45,\n\t\t.mr_startup_mask = AT91_ADC_STARTUP_9X5,\n\t},\n\t.triggers = at91sam9x5_triggers,\n\t.trigger_number = ARRAY_SIZE(at91sam9x5_triggers),\n};\n\nstatic struct at91_adc_caps sama5d3_caps = {\n\t.has_ts = true,\n\t.has_tsmr = true,\n\t.ts_filter_average = 3,\n\t.ts_pen_detect_sensitivity = 2,\n\t.calc_startup_ticks = calc_startup_ticks_9x5,\n\t.num_channels = 12,\n\t.low_res_bits = 0,\n\t.high_res_bits = 12,\n\t.registers = {\n\t\t.channel_base = AT91_ADC_CDR0_9X5,\n\t\t.drdy_mask = AT91_ADC_SR_DRDY_9X5,\n\t\t.status_register = AT91_ADC_SR_9X5,\n\t\t.trigger_register = AT91_ADC_TRGR_9X5,\n\t\t.mr_prescal_mask = AT91_ADC_PRESCAL_9G45,\n\t\t.mr_startup_mask = AT91_ADC_STARTUP_9X5,\n\t},\n\t.triggers = at91sam9x5_triggers,\n\t.trigger_number = ARRAY_SIZE(at91sam9x5_triggers),\n};\n\nstatic const struct of_device_id at91_adc_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9260-adc\", .data = &at91sam9260_caps },\n\t{ .compatible = \"atmel,at91sam9rl-adc\", .data = &at91sam9rl_caps },\n\t{ .compatible = \"atmel,at91sam9g45-adc\", .data = &at91sam9g45_caps },\n\t{ .compatible = \"atmel,at91sam9x5-adc\", .data = &at91sam9x5_caps },\n\t{ .compatible = \"atmel,sama5d3-adc\", .data = &sama5d3_caps },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, at91_adc_dt_ids);\n\nstatic struct platform_driver at91_adc_driver = {\n\t.probe = at91_adc_probe,\n\t.remove = at91_adc_remove,\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = at91_adc_dt_ids,\n\t\t   .pm = pm_sleep_ptr(&at91_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(at91_adc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Atmel AT91 ADC Driver\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}