{
  "module_name": "ad7887.c",
  "hash_id": "0fa096afe12e5f5c0cf11f58eadfb939de2b0262a996560ad3d92f52e4a15c7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7887.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <linux/platform_data/ad7887.h>\n\n#define AD7887_REF_DIS\t\tBIT(5)\t \n#define AD7887_DUAL\t\tBIT(4)\t \n#define AD7887_CH_AIN1\t\tBIT(3)\t \n#define AD7887_CH_AIN0\t\t0\t \n#define AD7887_PM_MODE1\t\t0\t \n#define AD7887_PM_MODE2\t\t1\t \n#define AD7887_PM_MODE3\t\t2\t \n#define AD7887_PM_MODE4\t\t3\t \n\nenum ad7887_channels {\n\tAD7887_CH0,\n\tAD7887_CH0_CH1,\n\tAD7887_CH1,\n};\n\n \nstruct ad7887_chip_info {\n\tu16\t\t\t\tint_vref_mv;\n\tconst struct iio_chan_spec\t*channels;\n\tunsigned int\t\t\tnum_channels;\n\tconst struct iio_chan_spec\t*dual_channels;\n\tunsigned int\t\t\tnum_dual_channels;\n};\n\nstruct ad7887_state {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad7887_chip_info\t*chip_info;\n\tstruct regulator\t\t*reg;\n\tstruct spi_transfer\t\txfer[4];\n\tstruct spi_message\t\tmsg[3];\n\tstruct spi_message\t\t*ring_msg;\n\tunsigned char\t\t\ttx_cmd_buf[4];\n\n\t \n\tunsigned char data[ALIGN(4, sizeof(s64)) + sizeof(s64)] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad7887_supported_device_ids {\n\tID_AD7887\n};\n\nstatic int ad7887_ring_preenable(struct iio_dev *indio_dev)\n{\n\tstruct ad7887_state *st = iio_priv(indio_dev);\n\n\t \n\tswitch (*indio_dev->active_scan_mask) {\n\tcase (1 << 0):\n\t\tst->ring_msg = &st->msg[AD7887_CH0];\n\t\tbreak;\n\tcase (1 << 1):\n\t\tst->ring_msg = &st->msg[AD7887_CH1];\n\t\t \n\t\tspi_sync(st->spi, st->ring_msg);\n\t\tbreak;\n\tcase ((1 << 1) | (1 << 0)):\n\t\tst->ring_msg = &st->msg[AD7887_CH0_CH1];\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7887_ring_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct ad7887_state *st = iio_priv(indio_dev);\n\n\t \n\treturn spi_sync(st->spi, &st->msg[AD7887_CH0]);\n}\n\nstatic irqreturn_t ad7887_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7887_state *st = iio_priv(indio_dev);\n\tint b_sent;\n\n\tb_sent = spi_sync(st->spi, st->ring_msg);\n\tif (b_sent)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->data,\n\t\tiio_get_time_ns(indio_dev));\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_buffer_setup_ops ad7887_ring_setup_ops = {\n\t.preenable = &ad7887_ring_preenable,\n\t.postdisable = &ad7887_ring_postdisable,\n};\n\nstatic int ad7887_scan_direct(struct ad7887_state *st, unsigned ch)\n{\n\tint ret = spi_sync(st->spi, &st->msg[ch]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (st->data[(ch * 2)] << 8) | st->data[(ch * 2) + 1];\n}\n\nstatic int ad7887_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tint ret;\n\tstruct ad7887_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ad7887_scan_direct(st, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret >> chan->scan_type.shift;\n\t\t*val &= GENMASK(chan->scan_type.realbits - 1, 0);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->reg) {\n\t\t\t*val = regulator_get_voltage(st->reg);\n\t\t\tif (*val < 0)\n\t\t\t\treturn *val;\n\t\t\t*val /= 1000;\n\t\t} else {\n\t\t\t*val = st->chip_info->int_vref_mv;\n\t\t}\n\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\n#define AD7887_CHANNEL(x) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.channel = (x), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.address = (x), \\\n\t.scan_index = (x), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 12, \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec ad7887_channels[] = {\n\tAD7887_CHANNEL(0),\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_chan_spec ad7887_dual_channels[] = {\n\tAD7887_CHANNEL(0),\n\tAD7887_CHANNEL(1),\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic const struct ad7887_chip_info ad7887_chip_info_tbl[] = {\n\t \n\t[ID_AD7887] = {\n\t\t.channels = ad7887_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7887_channels),\n\t\t.dual_channels = ad7887_dual_channels,\n\t\t.num_dual_channels = ARRAY_SIZE(ad7887_dual_channels),\n\t\t.int_vref_mv = 2500,\n\t},\n};\n\nstatic const struct iio_info ad7887_info = {\n\t.read_raw = &ad7887_read_raw,\n};\n\nstatic void ad7887_reg_disable(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic int ad7887_probe(struct spi_device *spi)\n{\n\tstruct ad7887_platform_data *pdata = spi->dev.platform_data;\n\tstruct ad7887_state *st;\n\tstruct iio_dev *indio_dev;\n\tuint8_t mode;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (IS_ERR(st->reg)) {\n\t\tif (PTR_ERR(st->reg) != -ENODEV)\n\t\t\treturn PTR_ERR(st->reg);\n\n\t\tst->reg = NULL;\n\t}\n\n\tif (st->reg) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7887_reg_disable, st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->chip_info =\n\t\t&ad7887_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad7887_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\n\tmode = AD7887_PM_MODE4;\n\tif (!st->reg)\n\t\tmode |= AD7887_REF_DIS;\n\tif (pdata && pdata->en_dual)\n\t\tmode |= AD7887_DUAL;\n\n\tst->tx_cmd_buf[0] = AD7887_CH_AIN0 | mode;\n\n\tst->xfer[0].rx_buf = &st->data[0];\n\tst->xfer[0].tx_buf = &st->tx_cmd_buf[0];\n\tst->xfer[0].len = 2;\n\n\tspi_message_init(&st->msg[AD7887_CH0]);\n\tspi_message_add_tail(&st->xfer[0], &st->msg[AD7887_CH0]);\n\n\tif (pdata && pdata->en_dual) {\n\t\tst->tx_cmd_buf[2] = AD7887_CH_AIN1 | mode;\n\n\t\tst->xfer[1].rx_buf = &st->data[0];\n\t\tst->xfer[1].tx_buf = &st->tx_cmd_buf[2];\n\t\tst->xfer[1].len = 2;\n\n\t\tst->xfer[2].rx_buf = &st->data[2];\n\t\tst->xfer[2].tx_buf = &st->tx_cmd_buf[0];\n\t\tst->xfer[2].len = 2;\n\n\t\tspi_message_init(&st->msg[AD7887_CH0_CH1]);\n\t\tspi_message_add_tail(&st->xfer[1], &st->msg[AD7887_CH0_CH1]);\n\t\tspi_message_add_tail(&st->xfer[2], &st->msg[AD7887_CH0_CH1]);\n\n\t\tst->xfer[3].rx_buf = &st->data[2];\n\t\tst->xfer[3].tx_buf = &st->tx_cmd_buf[2];\n\t\tst->xfer[3].len = 2;\n\n\t\tspi_message_init(&st->msg[AD7887_CH1]);\n\t\tspi_message_add_tail(&st->xfer[3], &st->msg[AD7887_CH1]);\n\n\t\tindio_dev->channels = st->chip_info->dual_channels;\n\t\tindio_dev->num_channels = st->chip_info->num_dual_channels;\n\t} else {\n\t\tindio_dev->channels = st->chip_info->channels;\n\t\tindio_dev->num_channels = st->chip_info->num_channels;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\t&iio_pollfunc_store_time,\n\t\t\t&ad7887_trigger_handler, &ad7887_ring_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7887_id[] = {\n\t{\"ad7887\", ID_AD7887},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7887_id);\n\nstatic struct spi_driver ad7887_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7887\",\n\t},\n\t.probe\t\t= ad7887_probe,\n\t.id_table\t= ad7887_id,\n};\nmodule_spi_driver(ad7887_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7887 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}