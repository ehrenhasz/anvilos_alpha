{
  "module_name": "ad7091r-base.c",
  "hash_id": "5dacf6c46ae2b8e79281928b3cac7c05879db8c7c5cdcd7b48cca9c2b4c847a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7091r-base.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"ad7091r-base.h\"\n\n#define AD7091R_REG_RESULT  0\n#define AD7091R_REG_CHANNEL 1\n#define AD7091R_REG_CONF    2\n#define AD7091R_REG_ALERT   3\n#define AD7091R_REG_CH_LOW_LIMIT(ch) ((ch) * 3 + 4)\n#define AD7091R_REG_CH_HIGH_LIMIT(ch) ((ch) * 3 + 5)\n#define AD7091R_REG_CH_HYSTERESIS(ch) ((ch) * 3 + 6)\n\n \n#define AD7091R_REG_RESULT_CH_ID(x)\t    (((x) >> 13) & 0x3)\n#define AD7091R_REG_RESULT_CONV_RESULT(x)   ((x) & 0xfff)\n\n \n#define AD7091R_REG_CONF_AUTO   BIT(8)\n#define AD7091R_REG_CONF_CMD    BIT(10)\n\n#define AD7091R_REG_CONF_MODE_MASK  \\\n\t(AD7091R_REG_CONF_AUTO | AD7091R_REG_CONF_CMD)\n\nenum ad7091r_mode {\n\tAD7091R_MODE_SAMPLE,\n\tAD7091R_MODE_COMMAND,\n\tAD7091R_MODE_AUTOCYCLE,\n};\n\nstruct ad7091r_state {\n\tstruct device *dev;\n\tstruct regmap *map;\n\tstruct regulator *vref;\n\tconst struct ad7091r_chip_info *chip_info;\n\tenum ad7091r_mode mode;\n\tstruct mutex lock;  \n};\n\nstatic int ad7091r_set_mode(struct ad7091r_state *st, enum ad7091r_mode mode)\n{\n\tint ret, conf;\n\n\tswitch (mode) {\n\tcase AD7091R_MODE_SAMPLE:\n\t\tconf = 0;\n\t\tbreak;\n\tcase AD7091R_MODE_COMMAND:\n\t\tconf = AD7091R_REG_CONF_CMD;\n\t\tbreak;\n\tcase AD7091R_MODE_AUTOCYCLE:\n\t\tconf = AD7091R_REG_CONF_AUTO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(st->map, AD7091R_REG_CONF,\n\t\t\t\t AD7091R_REG_CONF_MODE_MASK, conf);\n\tif (ret)\n\t\treturn ret;\n\n\tst->mode = mode;\n\n\treturn 0;\n}\n\nstatic int ad7091r_set_channel(struct ad7091r_state *st, unsigned int channel)\n{\n\tunsigned int dummy;\n\tint ret;\n\n\t \n\tret = regmap_write(st->map, AD7091R_REG_CHANNEL,\n\t\t\tBIT(channel) | (BIT(channel) << 8));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_read(st->map, AD7091R_REG_RESULT, &dummy);\n}\n\nstatic int ad7091r_read_one(struct iio_dev *iio_dev,\n\t\tunsigned int channel, unsigned int *read_val)\n{\n\tstruct ad7091r_state *st = iio_priv(iio_dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = ad7091r_set_channel(st, channel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(st->map, AD7091R_REG_RESULT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (AD7091R_REG_RESULT_CH_ID(val) != channel)\n\t\treturn -EIO;\n\n\t*read_val = AD7091R_REG_RESULT_CONV_RESULT(val);\n\n\treturn 0;\n}\n\nstatic int ad7091r_read_raw(struct iio_dev *iio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long m)\n{\n\tstruct ad7091r_state *st = iio_priv(iio_dev);\n\tunsigned int read_val;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (st->mode != AD7091R_MODE_COMMAND) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = ad7091r_read_one(iio_dev, chan->channel, &read_val);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\t*val = read_val;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->vref) {\n\t\t\tret = regulator_get_voltage(st->vref);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto unlock;\n\n\t\t\t*val = ret / 1000;\n\t\t} else {\n\t\t\t*val = st->chip_info->vref_mV;\n\t\t}\n\n\t\t*val2 = chan->scan_type.realbits;\n\t\tret = IIO_VAL_FRACTIONAL_LOG2;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info ad7091r_info = {\n\t.read_raw = ad7091r_read_raw,\n};\n\nstatic irqreturn_t ad7091r_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *iio_dev = private;\n\tstruct ad7091r_state *st = iio_priv(iio_dev);\n\tunsigned int i, read_val;\n\tint ret;\n\ts64 timestamp = iio_get_time_ns(iio_dev);\n\n\tret = regmap_read(st->map, AD7091R_REG_ALERT, &read_val);\n\tif (ret)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0; i < st->chip_info->num_channels; i++) {\n\t\tif (read_val & BIT(i * 2))\n\t\t\tiio_push_event(iio_dev,\n\t\t\t\t\tIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, i,\n\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\tIIO_EV_DIR_RISING), timestamp);\n\t\tif (read_val & BIT(i * 2 + 1))\n\t\t\tiio_push_event(iio_dev,\n\t\t\t\t\tIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, i,\n\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\tIIO_EV_DIR_FALLING), timestamp);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ad7091r_remove(void *data)\n{\n\tstruct ad7091r_state *st = data;\n\n\tregulator_disable(st->vref);\n}\n\nint ad7091r_probe(struct device *dev, const char *name,\n\t\tconst struct ad7091r_chip_info *chip_info,\n\t\tstruct regmap *map, int irq)\n{\n\tstruct iio_dev *iio_dev;\n\tstruct ad7091r_state *st;\n\tint ret;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(iio_dev);\n\tst->dev = dev;\n\tst->chip_info = chip_info;\n\tst->map = map;\n\n\tiio_dev->name = name;\n\tiio_dev->info = &ad7091r_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\n\tiio_dev->num_channels = chip_info->num_channels;\n\tiio_dev->channels = chip_info->channels;\n\n\tif (irq) {\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\tad7091r_event_handler,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT, name, iio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->vref = devm_regulator_get_optional(dev, \"vref\");\n\tif (IS_ERR(st->vref)) {\n\t\tif (PTR_ERR(st->vref) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tst->vref = NULL;\n\t} else {\n\t\tret = regulator_enable(st->vref);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, ad7091r_remove, st);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ad7091r_set_mode(st, AD7091R_MODE_COMMAND);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, iio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(ad7091r_probe, IIO_AD7091R);\n\nstatic bool ad7091r_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AD7091R_REG_RESULT:\n\tcase AD7091R_REG_ALERT:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool ad7091r_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AD7091R_REG_RESULT:\n\tcase AD7091R_REG_ALERT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct regmap_config ad7091r_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.writeable_reg = ad7091r_writeable_reg,\n\t.volatile_reg = ad7091r_volatile_reg,\n};\nEXPORT_SYMBOL_NS_GPL(ad7091r_regmap_config, IIO_AD7091R);\n\nMODULE_AUTHOR(\"Beniamin Bia <beniamin.bia@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7091Rx multi-channel converters\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}