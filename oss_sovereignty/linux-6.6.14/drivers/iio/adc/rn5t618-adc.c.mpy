{
  "module_name": "rn5t618-adc.c",
  "hash_id": "baabded375146211c19ebe726d929d9b42e711290f7a6828c70c7abfcc2082a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/rn5t618-adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mfd/rn5t618.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/slab.h>\n\n#define RN5T618_ADC_CONVERSION_TIMEOUT   (msecs_to_jiffies(500))\n#define RN5T618_REFERENCE_VOLT 2500\n\n \n#define RN5T618_ADCCNT3_CHANNEL_MASK 0x7\n \n#define RN5T618_ADCCNT3_AVG BIT(3)\n \n#define RN5T618_ADCCNT3_GODONE BIT(4)\n \n#define RN5T618_ADCCNT3_AUTO BIT(5)\n#define RN5T618_ADCEND_IRQ BIT(0)\n\nstruct rn5t618_adc_data {\n\tstruct device *dev;\n\tstruct rn5t618 *rn5t618;\n\tstruct completion conv_completion;\n\tint irq;\n};\n\nenum rn5t618_channels {\n\tLIMMON = 0,\n\tVBAT,\n\tVADP,\n\tVUSB,\n\tVSYS,\n\tVTHM,\n\tAIN1,\n\tAIN0\n};\n\nstatic const struct u16_fract rn5t618_ratios[8] = {\n\t[LIMMON] = {50, 32},  \n\t[VBAT] = {2, 1},\n\t[VADP] = {3, 1},\n\t[VUSB] = {3, 1},\n\t[VSYS] = {3, 1},\n\t[VTHM] = {1, 1},\n\t[AIN1] = {1, 1},\n\t[AIN0] = {1, 1},\n};\n\nstatic int rn5t618_read_adc_reg(struct rn5t618 *rn5t618, int reg, u16 *val)\n{\n\tu8 data[2];\n\tint ret;\n\n\tret = regmap_bulk_read(rn5t618->regmap, reg, data, sizeof(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = (data[0] << 4) | (data[1] & 0xF);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rn5t618_adc_irq(int irq, void *data)\n{\n\tstruct rn5t618_adc_data *adc = data;\n\tunsigned int r = 0;\n\tint ret;\n\n\t \n\tregmap_write(adc->rn5t618->regmap, RN5T618_IR_ADC1, 0);\n\tregmap_write(adc->rn5t618->regmap, RN5T618_IR_ADC2, 0);\n\n\tret = regmap_read(adc->rn5t618->regmap, RN5T618_IR_ADC3, &r);\n\tif (ret < 0)\n\t\tdev_err(adc->dev, \"failed to read IRQ status: %d\\n\", ret);\n\n\tregmap_write(adc->rn5t618->regmap, RN5T618_IR_ADC3, 0);\n\n\tif (r & RN5T618_ADCEND_IRQ)\n\t\tcomplete(&adc->conv_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rn5t618_adc_read(struct iio_dev *iio_dev,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct rn5t618_adc_data *adc = iio_priv(iio_dev);\n\tu16 raw;\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_SCALE) {\n\t\t*val = RN5T618_REFERENCE_VOLT *\n\t\t       rn5t618_ratios[chan->channel].numerator;\n\t\t*val2 = rn5t618_ratios[chan->channel].denominator * 4095;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\t \n\tret = regmap_update_bits(adc->rn5t618->regmap, RN5T618_ADCCNT3,\n\t\t\t\t RN5T618_ADCCNT3_CHANNEL_MASK,\n\t\t\t\t chan->channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(adc->rn5t618->regmap, RN5T618_EN_ADCIR3,\n\t\t\t   RN5T618_ADCEND_IRQ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(adc->rn5t618->regmap, RN5T618_ADCCNT3,\n\t\t\t\t RN5T618_ADCCNT3_AVG,\n\t\t\t\t mask == IIO_CHAN_INFO_AVERAGE_RAW ?\n\t\t\t\t RN5T618_ADCCNT3_AVG : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_completion(&adc->conv_completion);\n\t \n\tret = regmap_update_bits(adc->rn5t618->regmap, RN5T618_ADCCNT3,\n\t\t\t\t RN5T618_ADCCNT3_GODONE,\n\t\t\t\t RN5T618_ADCCNT3_GODONE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&adc->conv_completion,\n\t\t\t\t\t  RN5T618_ADC_CONVERSION_TIMEOUT);\n\tif (ret == 0) {\n\t\tdev_warn(adc->dev, \"timeout waiting for adc result\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = rn5t618_read_adc_reg(adc->rn5t618,\n\t\t\t\t   RN5T618_ILIMDATAH + 2 * chan->channel,\n\t\t\t\t   &raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = raw;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info rn5t618_adc_iio_info = {\n\t.read_raw = &rn5t618_adc_read,\n};\n\n#define RN5T618_ADC_CHANNEL(_channel, _type, _name) { \\\n\t.type = _type, \\\n\t.channel = _channel, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_AVERAGE_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.datasheet_name = _name, \\\n\t.indexed = 1. \\\n}\n\nstatic const struct iio_chan_spec rn5t618_adc_iio_channels[] = {\n\tRN5T618_ADC_CHANNEL(LIMMON, IIO_CURRENT, \"LIMMON\"),\n\tRN5T618_ADC_CHANNEL(VBAT, IIO_VOLTAGE, \"VBAT\"),\n\tRN5T618_ADC_CHANNEL(VADP, IIO_VOLTAGE, \"VADP\"),\n\tRN5T618_ADC_CHANNEL(VUSB, IIO_VOLTAGE, \"VUSB\"),\n\tRN5T618_ADC_CHANNEL(VSYS, IIO_VOLTAGE, \"VSYS\"),\n\tRN5T618_ADC_CHANNEL(VTHM, IIO_VOLTAGE, \"VTHM\"),\n\tRN5T618_ADC_CHANNEL(AIN1, IIO_VOLTAGE, \"AIN1\"),\n\tRN5T618_ADC_CHANNEL(AIN0, IIO_VOLTAGE, \"AIN0\")\n};\n\nstatic struct iio_map rn5t618_maps[] = {\n\tIIO_MAP(\"VADP\", \"rn5t618-power\", \"vadp\"),\n\tIIO_MAP(\"VUSB\", \"rn5t618-power\", \"vusb\"),\n\t{   }\n};\n\nstatic int rn5t618_adc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct iio_dev *iio_dev;\n\tstruct rn5t618_adc_data *adc;\n\tstruct rn5t618 *rn5t618 = dev_get_drvdata(pdev->dev.parent);\n\n\tiio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!iio_dev) {\n\t\tdev_err(&pdev->dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(iio_dev);\n\tadc->dev = &pdev->dev;\n\tadc->rn5t618 = rn5t618;\n\n\tif (rn5t618->irq_data)\n\t\tadc->irq = regmap_irq_get_virq(rn5t618->irq_data,\n\t\t\t\t\t       RN5T618_IRQ_ADC);\n\n\tif (adc->irq <= 0) {\n\t\tdev_err(&pdev->dev, \"get virq failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinit_completion(&adc->conv_completion);\n\n\tiio_dev->name = dev_name(&pdev->dev);\n\tiio_dev->info = &rn5t618_adc_iio_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->channels = rn5t618_adc_iio_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(rn5t618_adc_iio_channels);\n\n\t \n\tret = regmap_write(rn5t618->regmap, RN5T618_ADCCNT3, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, iio_dev);\n\n\tret = devm_request_threaded_irq(adc->dev, adc->irq, NULL,\n\t\t\t\t\trn5t618_adc_irq,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(adc->dev),\n\t\t\t\t\tadc);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"request irq %d failed: %d\\n\", adc->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_map_array_register(adc->dev, iio_dev, rn5t618_maps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(adc->dev, iio_dev);\n}\n\nstatic struct platform_driver rn5t618_adc_driver = {\n\t.driver = {\n\t\t.name   = \"rn5t618-adc\",\n\t},\n\t.probe = rn5t618_adc_probe,\n};\n\nmodule_platform_driver(rn5t618_adc_driver);\nMODULE_ALIAS(\"platform:rn5t618-adc\");\nMODULE_DESCRIPTION(\"RICOH RN5T618 ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}