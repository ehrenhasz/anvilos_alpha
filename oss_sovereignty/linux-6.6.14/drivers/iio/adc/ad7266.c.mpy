{
  "module_name": "ad7266.c",
  "hash_id": "d776025e317236c9bffac753b6fed9d6ad67b75041f5e2bf9e1a958ed9e88249",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7266.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n\n#include <linux/interrupt.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <linux/platform_data/ad7266.h>\n\nstruct ad7266_state {\n\tstruct spi_device\t*spi;\n\tstruct regulator\t*reg;\n\tunsigned long\t\tvref_mv;\n\n\tstruct spi_transfer\tsingle_xfer[3];\n\tstruct spi_message\tsingle_msg;\n\n\tenum ad7266_range\trange;\n\tenum ad7266_mode\tmode;\n\tbool\t\t\tfixed_addr;\n\tstruct gpio_desc\t*gpios[3];\n\n\t \n\tstruct {\n\t\t__be16 sample[2];\n\t\ts64 timestamp;\n\t} data __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ad7266_wakeup(struct ad7266_state *st)\n{\n\t \n\treturn spi_read(st->spi, &st->data.sample[0], 2);\n}\n\nstatic int ad7266_powerdown(struct ad7266_state *st)\n{\n\t \n\treturn spi_read(st->spi, &st->data.sample[0], 1);\n}\n\nstatic int ad7266_preenable(struct iio_dev *indio_dev)\n{\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\treturn ad7266_wakeup(st);\n}\n\nstatic int ad7266_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\treturn ad7266_powerdown(st);\n}\n\nstatic const struct iio_buffer_setup_ops iio_triggered_buffer_setup_ops = {\n\t.preenable = &ad7266_preenable,\n\t.postdisable = &ad7266_postdisable,\n};\n\nstatic irqreturn_t ad7266_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = spi_read(st->spi, st->data.sample, 4);\n\tif (ret == 0) {\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &st->data,\n\t\t\t    pf->timestamp);\n\t}\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ad7266_select_input(struct ad7266_state *st, unsigned int nr)\n{\n\tunsigned int i;\n\n\tif (st->fixed_addr)\n\t\treturn;\n\n\tswitch (st->mode) {\n\tcase AD7266_MODE_SINGLE_ENDED:\n\t\tnr >>= 1;\n\t\tbreak;\n\tcase AD7266_MODE_PSEUDO_DIFF:\n\t\tnr |= 1;\n\t\tbreak;\n\tcase AD7266_MODE_DIFF:\n\t\tnr &= ~1;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 3; ++i)\n\t\tgpiod_set_value(st->gpios[i], (bool)(nr & BIT(i)));\n}\n\nstatic int ad7266_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\tunsigned int nr = find_first_bit(scan_mask, indio_dev->masklength);\n\n\tad7266_select_input(st, nr);\n\n\treturn 0;\n}\n\nstatic int ad7266_read_single(struct ad7266_state *st, int *val,\n\tunsigned int address)\n{\n\tint ret;\n\n\tad7266_select_input(st, address);\n\n\tret = spi_sync(st->spi, &st->single_msg);\n\t*val = be16_to_cpu(st->data.sample[address % 2]);\n\n\treturn ret;\n}\n\nstatic int ad7266_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long m)\n{\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\tunsigned long scale_mv;\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ad7266_read_single(st, val, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\t*val = (*val >> 2) & 0xfff;\n\t\tif (chan->scan_type.sign == 's')\n\t\t\t*val = sign_extend32(*val,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale_mv = st->vref_mv;\n\t\tif (st->mode == AD7266_MODE_DIFF)\n\t\t\tscale_mv *= 2;\n\t\tif (st->range == AD7266_RANGE_2VREF)\n\t\t\tscale_mv *= 2;\n\n\t\t*val = scale_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (st->range == AD7266_RANGE_2VREF &&\n\t\t\tst->mode != AD7266_MODE_DIFF)\n\t\t\t*val = 2048;\n\t\telse\n\t\t\t*val = 0;\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\n#define AD7266_CHAN(_chan, _sign) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = (_chan),\t\t\t\t\\\n\t.address = (_chan),\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\\n\t\t| BIT(IIO_CHAN_INFO_OFFSET),\t\t\t\\\n\t.scan_index = (_chan),\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = (_sign),\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t\t.shift = 2,\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n}\n\n#define AD7266_DECLARE_SINGLE_ENDED_CHANNELS(_name, _sign) \\\nconst struct iio_chan_spec ad7266_channels_##_name[] = { \\\n\tAD7266_CHAN(0, (_sign)), \\\n\tAD7266_CHAN(1, (_sign)), \\\n\tAD7266_CHAN(2, (_sign)), \\\n\tAD7266_CHAN(3, (_sign)), \\\n\tAD7266_CHAN(4, (_sign)), \\\n\tAD7266_CHAN(5, (_sign)), \\\n\tAD7266_CHAN(6, (_sign)), \\\n\tAD7266_CHAN(7, (_sign)), \\\n\tAD7266_CHAN(8, (_sign)), \\\n\tAD7266_CHAN(9, (_sign)), \\\n\tAD7266_CHAN(10, (_sign)), \\\n\tAD7266_CHAN(11, (_sign)), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(13), \\\n}\n\n#define AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(_name, _sign) \\\nconst struct iio_chan_spec ad7266_channels_##_name##_fixed[] = { \\\n\tAD7266_CHAN(0, (_sign)), \\\n\tAD7266_CHAN(1, (_sign)), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(2), \\\n}\n\nstatic AD7266_DECLARE_SINGLE_ENDED_CHANNELS(u, 'u');\nstatic AD7266_DECLARE_SINGLE_ENDED_CHANNELS(s, 's');\nstatic AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(u, 'u');\nstatic AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(s, 's');\n\n#define AD7266_CHAN_DIFF(_chan, _sign) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = (_chan) * 2,\t\t\t\t\\\n\t.channel2 = (_chan) * 2 + 1,\t\t\t\\\n\t.address = (_chan),\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t| BIT(IIO_CHAN_INFO_OFFSET),\t\t\t\\\n\t.scan_index = (_chan),\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = _sign,\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t\t.shift = 2,\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.differential = 1,\t\t\t\t\\\n}\n\n#define AD7266_DECLARE_DIFF_CHANNELS(_name, _sign) \\\nconst struct iio_chan_spec ad7266_channels_diff_##_name[] = { \\\n\tAD7266_CHAN_DIFF(0, (_sign)), \\\n\tAD7266_CHAN_DIFF(1, (_sign)), \\\n\tAD7266_CHAN_DIFF(2, (_sign)), \\\n\tAD7266_CHAN_DIFF(3, (_sign)), \\\n\tAD7266_CHAN_DIFF(4, (_sign)), \\\n\tAD7266_CHAN_DIFF(5, (_sign)), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(6), \\\n}\n\nstatic AD7266_DECLARE_DIFF_CHANNELS(s, 's');\nstatic AD7266_DECLARE_DIFF_CHANNELS(u, 'u');\n\n#define AD7266_DECLARE_DIFF_CHANNELS_FIXED(_name, _sign) \\\nconst struct iio_chan_spec ad7266_channels_diff_fixed_##_name[] = { \\\n\tAD7266_CHAN_DIFF(0, (_sign)), \\\n\tAD7266_CHAN_DIFF(1, (_sign)), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(2), \\\n}\n\nstatic AD7266_DECLARE_DIFF_CHANNELS_FIXED(s, 's');\nstatic AD7266_DECLARE_DIFF_CHANNELS_FIXED(u, 'u');\n\nstatic const struct iio_info ad7266_info = {\n\t.read_raw = &ad7266_read_raw,\n\t.update_scan_mode = &ad7266_update_scan_mode,\n};\n\nstatic const unsigned long ad7266_available_scan_masks[] = {\n\t0x003,\n\t0x00c,\n\t0x030,\n\t0x0c0,\n\t0x300,\n\t0xc00,\n\t0x000,\n};\n\nstatic const unsigned long ad7266_available_scan_masks_diff[] = {\n\t0x003,\n\t0x00c,\n\t0x030,\n\t0x000,\n};\n\nstatic const unsigned long ad7266_available_scan_masks_fixed[] = {\n\t0x003,\n\t0x000,\n};\n\nstruct ad7266_chan_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tconst unsigned long *scan_masks;\n};\n\n#define AD7266_CHAN_INFO_INDEX(_differential, _signed, _fixed) \\\n\t(((_differential) << 2) | ((_signed) << 1) | ((_fixed) << 0))\n\nstatic const struct ad7266_chan_info ad7266_chan_infos[] = {\n\t[AD7266_CHAN_INFO_INDEX(0, 0, 0)] = {\n\t\t.channels = ad7266_channels_u,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_u),\n\t\t.scan_masks = ad7266_available_scan_masks,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(0, 0, 1)] = {\n\t\t.channels = ad7266_channels_u_fixed,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_u_fixed),\n\t\t.scan_masks = ad7266_available_scan_masks_fixed,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(0, 1, 0)] = {\n\t\t.channels = ad7266_channels_s,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_s),\n\t\t.scan_masks = ad7266_available_scan_masks,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(0, 1, 1)] = {\n\t\t.channels = ad7266_channels_s_fixed,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_s_fixed),\n\t\t.scan_masks = ad7266_available_scan_masks_fixed,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(1, 0, 0)] = {\n\t\t.channels = ad7266_channels_diff_u,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_diff_u),\n\t\t.scan_masks = ad7266_available_scan_masks_diff,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(1, 0, 1)] = {\n\t\t.channels = ad7266_channels_diff_fixed_u,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_diff_fixed_u),\n\t\t.scan_masks = ad7266_available_scan_masks_fixed,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(1, 1, 0)] = {\n\t\t.channels = ad7266_channels_diff_s,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_diff_s),\n\t\t.scan_masks = ad7266_available_scan_masks_diff,\n\t},\n\t[AD7266_CHAN_INFO_INDEX(1, 1, 1)] = {\n\t\t.channels = ad7266_channels_diff_fixed_s,\n\t\t.num_channels = ARRAY_SIZE(ad7266_channels_diff_fixed_s),\n\t\t.scan_masks = ad7266_available_scan_masks_fixed,\n\t},\n};\n\nstatic void ad7266_init_channels(struct iio_dev *indio_dev)\n{\n\tstruct ad7266_state *st = iio_priv(indio_dev);\n\tbool is_differential, is_signed;\n\tconst struct ad7266_chan_info *chan_info;\n\tint i;\n\n\tis_differential = st->mode != AD7266_MODE_SINGLE_ENDED;\n\tis_signed = (st->range == AD7266_RANGE_2VREF) |\n\t\t    (st->mode == AD7266_MODE_DIFF);\n\n\ti = AD7266_CHAN_INFO_INDEX(is_differential, is_signed, st->fixed_addr);\n\tchan_info = &ad7266_chan_infos[i];\n\n\tindio_dev->channels = chan_info->channels;\n\tindio_dev->num_channels = chan_info->num_channels;\n\tindio_dev->available_scan_masks = chan_info->scan_masks;\n\tindio_dev->masklength = chan_info->num_channels - 1;\n}\n\nstatic const char * const ad7266_gpio_labels[] = {\n\t\"ad0\", \"ad1\", \"ad2\",\n};\n\nstatic void ad7266_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7266_probe(struct spi_device *spi)\n{\n\tstruct ad7266_platform_data *pdata = spi->dev.platform_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad7266_state *st;\n\tunsigned int i;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->reg)) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7266_reg_disable, st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->vref_mv = ret / 1000;\n\t} else {\n\t\t \n\t\tif (PTR_ERR(st->reg) != -ENODEV)\n\t\t\treturn PTR_ERR(st->reg);\n\t\t \n\t\tst->vref_mv = 2500;\n\t}\n\n\tif (pdata) {\n\t\tst->fixed_addr = pdata->fixed_addr;\n\t\tst->mode = pdata->mode;\n\t\tst->range = pdata->range;\n\n\t\tif (!st->fixed_addr) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(st->gpios); ++i) {\n\t\t\t\tst->gpios[i] = devm_gpiod_get(&spi->dev,\n\t\t\t\t\t\t      ad7266_gpio_labels[i],\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\t\t\t\tif (IS_ERR(st->gpios[i])) {\n\t\t\t\t\tret = PTR_ERR(st->gpios[i]);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tst->fixed_addr = true;\n\t\tst->range = AD7266_RANGE_VREF;\n\t\tst->mode = AD7266_MODE_DIFF;\n\t}\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad7266_info;\n\n\tad7266_init_channels(indio_dev);\n\n\t \n\tst->single_xfer[0].rx_buf = &st->data.sample[0];\n\tst->single_xfer[0].len = 2;\n\tst->single_xfer[0].cs_change = 1;\n\t \n\tst->single_xfer[1].rx_buf = st->data.sample;\n\tst->single_xfer[1].len = 4;\n\tst->single_xfer[1].cs_change = 1;\n\t \n\tst->single_xfer[2].tx_buf = &st->data.sample[0];\n\tst->single_xfer[2].len = 1;\n\n\tspi_message_init(&st->single_msg);\n\tspi_message_add_tail(&st->single_xfer[0], &st->single_msg);\n\tspi_message_add_tail(&st->single_xfer[1], &st->single_msg);\n\tspi_message_add_tail(&st->single_xfer[2], &st->single_msg);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, &iio_pollfunc_store_time,\n\t\t&ad7266_trigger_handler, &iio_triggered_buffer_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7266_id[] = {\n\t{\"ad7265\", 0},\n\t{\"ad7266\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ad7266_id);\n\nstatic struct spi_driver ad7266_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7266\",\n\t},\n\t.probe\t\t= ad7266_probe,\n\t.id_table\t= ad7266_id,\n};\nmodule_spi_driver(ad7266_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7266/65 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}