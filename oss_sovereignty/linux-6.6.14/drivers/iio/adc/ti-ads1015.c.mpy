{
  "module_name": "ti-ads1015.c",
  "hash_id": "6e7370223d84bd81d8aa7ab888826ec09ea322ef0822afbc19301af2189e7a15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads1015.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/i2c.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/types.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define ADS1015_DRV_NAME \"ads1015\"\n\n#define ADS1015_CHANNELS 8\n\n#define ADS1015_CONV_REG\t0x00\n#define ADS1015_CFG_REG\t\t0x01\n#define ADS1015_LO_THRESH_REG\t0x02\n#define ADS1015_HI_THRESH_REG\t0x03\n\n#define ADS1015_CFG_COMP_QUE_SHIFT\t0\n#define ADS1015_CFG_COMP_LAT_SHIFT\t2\n#define ADS1015_CFG_COMP_POL_SHIFT\t3\n#define ADS1015_CFG_COMP_MODE_SHIFT\t4\n#define ADS1015_CFG_DR_SHIFT\t5\n#define ADS1015_CFG_MOD_SHIFT\t8\n#define ADS1015_CFG_PGA_SHIFT\t9\n#define ADS1015_CFG_MUX_SHIFT\t12\n\n#define ADS1015_CFG_COMP_QUE_MASK\tGENMASK(1, 0)\n#define ADS1015_CFG_COMP_LAT_MASK\tBIT(2)\n#define ADS1015_CFG_COMP_POL_MASK\tBIT(3)\n#define ADS1015_CFG_COMP_MODE_MASK\tBIT(4)\n#define ADS1015_CFG_DR_MASK\tGENMASK(7, 5)\n#define ADS1015_CFG_MOD_MASK\tBIT(8)\n#define ADS1015_CFG_PGA_MASK\tGENMASK(11, 9)\n#define ADS1015_CFG_MUX_MASK\tGENMASK(14, 12)\n\n \n#define ADS1015_CFG_COMP_DISABLE\t3\n\n \n#define ADS1015_CFG_COMP_POL_LOW\t0\n#define ADS1015_CFG_COMP_POL_HIGH\t1\n\n \n#define ADS1015_CFG_COMP_MODE_TRAD\t0\n#define ADS1015_CFG_COMP_MODE_WINDOW\t1\n\n \n#define ADS1015_CONTINUOUS\t0\n#define ADS1015_SINGLESHOT\t1\n\n#define ADS1015_SLEEP_DELAY_MS\t\t2000\n#define ADS1015_DEFAULT_PGA\t\t2\n#define ADS1015_DEFAULT_DATA_RATE\t4\n#define ADS1015_DEFAULT_CHAN\t\t0\n\nstruct ads1015_chip_data {\n\tstruct iio_chan_spec const\t*channels;\n\tint\t\t\t\tnum_channels;\n\tconst struct iio_info\t\t*info;\n\tconst int\t\t\t*data_rate;\n\tconst int\t\t\tdata_rate_len;\n\tconst int\t\t\t*scale;\n\tconst int\t\t\tscale_len;\n\tbool\t\t\t\thas_comparator;\n};\n\nenum ads1015_channels {\n\tADS1015_AIN0_AIN1 = 0,\n\tADS1015_AIN0_AIN3,\n\tADS1015_AIN1_AIN3,\n\tADS1015_AIN2_AIN3,\n\tADS1015_AIN0,\n\tADS1015_AIN1,\n\tADS1015_AIN2,\n\tADS1015_AIN3,\n\tADS1015_TIMESTAMP,\n};\n\nstatic const int ads1015_data_rate[] = {\n\t128, 250, 490, 920, 1600, 2400, 3300, 3300\n};\n\nstatic const int ads1115_data_rate[] = {\n\t8, 16, 32, 64, 128, 250, 475, 860\n};\n\n \nstatic const int ads1015_fullscale_range[] = {\n\t6144, 4096, 2048, 1024, 512, 256, 256, 256\n};\n\nstatic const int ads1015_scale[] = {\t \n\t256, 11,\n\t512, 11,\n\t1024, 11,\n\t2048, 11,\n\t4096, 11,\n\t6144, 11\n};\n\nstatic const int ads1115_scale[] = {\t \n\t256, 15,\n\t512, 15,\n\t1024, 15,\n\t2048, 15,\n\t4096, 15,\n\t6144, 15\n};\n\n \nstatic const int ads1015_comp_queue[] = { 1, 2, 4 };\n\nstatic const struct iio_event_spec ads1015_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\tBIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\n \n#define FIT_CHECK(_testbits, _fitbits)\t\t\t\t\t\\\n\t(\t\t\t\t\t\t\t\t\\\n\t\t(_fitbits) *\t\t\t\t\t\t\\\n\t\t!!sizeof(struct {\t\t\t\t\t\\\n\t\t\tstatic_assert((_testbits) <= (_fitbits));\t\\\n\t\t\tint pad;\t\t\t\t\t\\\n\t\t})\t\t\t\t\t\t\t\\\n\t)\n\n#define ADS1015_V_CHAN(_chan, _addr, _realbits, _shift, _event_spec, _num_event_specs) { \\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.address = _addr,\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.scan_index = _addr,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\\\n\t\t.realbits = (_realbits),\t\t\t\\\n\t\t.storagebits = FIT_CHECK((_realbits) + (_shift), 16),\t\\\n\t\t.shift = (_shift),\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.event_spec = (_event_spec),\t\t\t\t\\\n\t.num_event_specs = (_num_event_specs),\t\t\t\\\n\t.datasheet_name = \"AIN\"#_chan,\t\t\t\t\\\n}\n\n#define ADS1015_V_DIFF_CHAN(_chan, _chan2, _addr, _realbits, _shift, _event_spec, _num_event_specs) { \\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.differential = 1,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.address = _addr,\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\\\n\t.channel2 = _chan2,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.scan_index = _addr,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\\\n\t\t.realbits = (_realbits),\t\t\t\\\n\t\t.storagebits = FIT_CHECK((_realbits) + (_shift), 16),\t\\\n\t\t.shift = (_shift),\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.event_spec = (_event_spec),\t\t\t\t\\\n\t.num_event_specs = (_num_event_specs),\t\t\t\\\n\t.datasheet_name = \"AIN\"#_chan\"-AIN\"#_chan2,\t\t\\\n}\n\nstruct ads1015_channel_data {\n\tbool enabled;\n\tunsigned int pga;\n\tunsigned int data_rate;\n};\n\nstruct ads1015_thresh_data {\n\tunsigned int comp_queue;\n\tint high_thresh;\n\tint low_thresh;\n};\n\nstruct ads1015_data {\n\tstruct regmap *regmap;\n\t \n\tstruct mutex lock;\n\tstruct ads1015_channel_data channel_data[ADS1015_CHANNELS];\n\n\tunsigned int event_channel;\n\tunsigned int comp_mode;\n\tstruct ads1015_thresh_data thresh_data[ADS1015_CHANNELS];\n\n\tconst struct ads1015_chip_data *chip;\n\t \n\tbool conv_invalid;\n};\n\nstatic bool ads1015_event_channel_enabled(struct ads1015_data *data)\n{\n\treturn (data->event_channel != ADS1015_CHANNELS);\n}\n\nstatic void ads1015_event_channel_enable(struct ads1015_data *data, int chan,\n\t\t\t\t\t int comp_mode)\n{\n\tWARN_ON(ads1015_event_channel_enabled(data));\n\n\tdata->event_channel = chan;\n\tdata->comp_mode = comp_mode;\n}\n\nstatic void ads1015_event_channel_disable(struct ads1015_data *data, int chan)\n{\n\tdata->event_channel = ADS1015_CHANNELS;\n}\n\nstatic const struct regmap_range ads1015_writeable_ranges[] = {\n\tregmap_reg_range(ADS1015_CFG_REG, ADS1015_HI_THRESH_REG),\n};\n\nstatic const struct regmap_access_table ads1015_writeable_table = {\n\t.yes_ranges = ads1015_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ads1015_writeable_ranges),\n};\n\nstatic const struct regmap_config ads1015_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = ADS1015_HI_THRESH_REG,\n\t.wr_table = &ads1015_writeable_table,\n};\n\nstatic const struct regmap_range tla2024_writeable_ranges[] = {\n\tregmap_reg_range(ADS1015_CFG_REG, ADS1015_CFG_REG),\n};\n\nstatic const struct regmap_access_table tla2024_writeable_table = {\n\t.yes_ranges = tla2024_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tla2024_writeable_ranges),\n};\n\nstatic const struct regmap_config tla2024_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = ADS1015_CFG_REG,\n\t.wr_table = &tla2024_writeable_table,\n};\n\nstatic const struct iio_chan_spec ads1015_channels[] = {\n\tADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 12, 4,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 12, 4,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 12, 4,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 12, 4,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(0, ADS1015_AIN0, 12, 4,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(1, ADS1015_AIN1, 12, 4,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(2, ADS1015_AIN2, 12, 4,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(3, ADS1015_AIN3, 12, 4,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec ads1115_channels[] = {\n\tADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 16, 0,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 16, 0,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 16, 0,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 16, 0,\n\t\t\t    ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(0, ADS1015_AIN0, 16, 0,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(1, ADS1015_AIN1, 16, 0,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(2, ADS1015_AIN2, 16, 0,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tADS1015_V_CHAN(3, ADS1015_AIN3, 16, 0,\n\t\t       ads1015_events, ARRAY_SIZE(ads1015_events)),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec tla2024_channels[] = {\n\tADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 12, 4, NULL, 0),\n\tADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 12, 4, NULL, 0),\n\tADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 12, 4, NULL, 0),\n\tADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 12, 4, NULL, 0),\n\tADS1015_V_CHAN(0, ADS1015_AIN0, 12, 4, NULL, 0),\n\tADS1015_V_CHAN(1, ADS1015_AIN1, 12, 4, NULL, 0),\n\tADS1015_V_CHAN(2, ADS1015_AIN2, 12, 4, NULL, 0),\n\tADS1015_V_CHAN(3, ADS1015_AIN3, 12, 4, NULL, 0),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),\n};\n\n\n#ifdef CONFIG_PM\nstatic int ads1015_set_power_state(struct ads1015_data *data, bool on)\n{\n\tint ret;\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}\n\n#else  \n\nstatic int ads1015_set_power_state(struct ads1015_data *data, bool on)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic\nint ads1015_get_adc_result(struct ads1015_data *data, int chan, int *val)\n{\n\tconst int *data_rate = data->chip->data_rate;\n\tint ret, pga, dr, dr_old, conv_time;\n\tunsigned int old, mask, cfg;\n\n\tif (chan < 0 || chan >= ADS1015_CHANNELS)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(data->regmap, ADS1015_CFG_REG, &old);\n\tif (ret)\n\t\treturn ret;\n\n\tpga = data->channel_data[chan].pga;\n\tdr = data->channel_data[chan].data_rate;\n\tmask = ADS1015_CFG_MUX_MASK | ADS1015_CFG_PGA_MASK |\n\t\tADS1015_CFG_DR_MASK;\n\tcfg = chan << ADS1015_CFG_MUX_SHIFT | pga << ADS1015_CFG_PGA_SHIFT |\n\t\tdr << ADS1015_CFG_DR_SHIFT;\n\n\tif (ads1015_event_channel_enabled(data)) {\n\t\tmask |= ADS1015_CFG_COMP_QUE_MASK | ADS1015_CFG_COMP_MODE_MASK;\n\t\tcfg |= data->thresh_data[chan].comp_queue <<\n\t\t\t\tADS1015_CFG_COMP_QUE_SHIFT |\n\t\t\tdata->comp_mode <<\n\t\t\t\tADS1015_CFG_COMP_MODE_SHIFT;\n\t}\n\n\tcfg = (old & ~mask) | (cfg & mask);\n\tif (old != cfg) {\n\t\tret = regmap_write(data->regmap, ADS1015_CFG_REG, cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->conv_invalid = true;\n\t}\n\tif (data->conv_invalid) {\n\t\tdr_old = (old & ADS1015_CFG_DR_MASK) >> ADS1015_CFG_DR_SHIFT;\n\t\tconv_time = DIV_ROUND_UP(USEC_PER_SEC, data_rate[dr_old]);\n\t\tconv_time += DIV_ROUND_UP(USEC_PER_SEC, data_rate[dr]);\n\t\tconv_time += conv_time / 10;  \n\t\tusleep_range(conv_time, conv_time + 1);\n\t\tdata->conv_invalid = false;\n\t}\n\n\treturn regmap_read(data->regmap, ADS1015_CONV_REG, val);\n}\n\nstatic irqreturn_t ads1015_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\t \n\tstruct {\n\t\ts16 chan;\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tint chan, ret, res;\n\n\tmemset(&scan, 0, sizeof(scan));\n\n\tmutex_lock(&data->lock);\n\tchan = find_first_bit(indio_dev->active_scan_mask,\n\t\t\t      indio_dev->masklength);\n\tret = ads1015_get_adc_result(data, chan, &res);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\tgoto err;\n\t}\n\n\tscan.chan = res;\n\tmutex_unlock(&data->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ads1015_set_scale(struct ads1015_data *data,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int scale, int uscale)\n{\n\tint i;\n\tint fullscale = div_s64((scale * 1000000LL + uscale) <<\n\t\t\t\t(chan->scan_type.realbits - 1), 1000000);\n\n\tfor (i = 0; i < ARRAY_SIZE(ads1015_fullscale_range); i++) {\n\t\tif (ads1015_fullscale_range[i] == fullscale) {\n\t\t\tdata->channel_data[chan->address].pga = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ads1015_set_data_rate(struct ads1015_data *data, int chan, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < data->chip->data_rate_len; i++) {\n\t\tif (data->chip->data_rate[i] == rate) {\n\t\t\tdata->channel_data[chan].data_rate = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ads1015_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_VOLTAGE)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_FRACTIONAL_LOG2;\n\t\t*vals =  data->chip->scale;\n\t\t*length = data->chip->scale_len;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT;\n\t\t*vals = data->chip->data_rate;\n\t\t*length = data->chip->data_rate_len;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ads1015_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tint ret, idx;\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (ads1015_event_channel_enabled(data) &&\n\t\t\t\tdata->event_channel != chan->address) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto release_direct;\n\t\t}\n\n\t\tret = ads1015_set_power_state(data, true);\n\t\tif (ret < 0)\n\t\t\tgoto release_direct;\n\n\t\tret = ads1015_get_adc_result(data, chan->address, val);\n\t\tif (ret < 0) {\n\t\t\tads1015_set_power_state(data, false);\n\t\t\tgoto release_direct;\n\t\t}\n\n\t\t*val = sign_extend32(*val >> chan->scan_type.shift,\n\t\t\t\t     chan->scan_type.realbits - 1);\n\n\t\tret = ads1015_set_power_state(data, false);\n\t\tif (ret < 0)\n\t\t\tgoto release_direct;\n\n\t\tret = IIO_VAL_INT;\nrelease_direct:\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tidx = data->channel_data[chan->address].pga;\n\t\t*val = ads1015_fullscale_range[idx];\n\t\t*val2 = chan->scan_type.realbits - 1;\n\t\tret = IIO_VAL_FRACTIONAL_LOG2;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tidx = data->channel_data[chan->address].data_rate;\n\t\t*val = data->chip->data_rate[idx];\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1015_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ads1015_set_scale(data, chan, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = ads1015_set_data_rate(data, chan->address, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1015_read_event(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int *val,\n\tint *val2)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int comp_queue;\n\tint period;\n\tint dr;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = (dir == IIO_EV_DIR_RISING) ?\n\t\t\tdata->thresh_data[chan->address].high_thresh :\n\t\t\tdata->thresh_data[chan->address].low_thresh;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tdr = data->channel_data[chan->address].data_rate;\n\t\tcomp_queue = data->thresh_data[chan->address].comp_queue;\n\t\tperiod = ads1015_comp_queue[comp_queue] *\n\t\t\tUSEC_PER_SEC / data->chip->data_rate[dr];\n\n\t\t*val = period / USEC_PER_SEC;\n\t\t*val2 = period % USEC_PER_SEC;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1015_write_event(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info, int val,\n\tint val2)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tconst int *data_rate = data->chip->data_rate;\n\tint realbits = chan->scan_type.realbits;\n\tint ret = 0;\n\tlong long period;\n\tint i;\n\tint dr;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val >= 1 << (realbits - 1) || val < -1 << (realbits - 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tdata->thresh_data[chan->address].high_thresh = val;\n\t\telse\n\t\t\tdata->thresh_data[chan->address].low_thresh = val;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tdr = data->channel_data[chan->address].data_rate;\n\t\tperiod = val * USEC_PER_SEC + val2;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ads1015_comp_queue) - 1; i++) {\n\t\t\tif (period <= ads1015_comp_queue[i] *\n\t\t\t\t\tUSEC_PER_SEC / data_rate[dr])\n\t\t\t\tbreak;\n\t\t}\n\t\tdata->thresh_data[chan->address].comp_queue = i;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1015_read_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tmutex_lock(&data->lock);\n\tif (data->event_channel == chan->address) {\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_EITHER:\n\t\t\tret = (data->comp_mode == ADS1015_CFG_COMP_MODE_WINDOW);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1015_enable_event_config(struct ads1015_data *data,\n\tconst struct iio_chan_spec *chan, int comp_mode)\n{\n\tint low_thresh = data->thresh_data[chan->address].low_thresh;\n\tint high_thresh = data->thresh_data[chan->address].high_thresh;\n\tint ret;\n\tunsigned int val;\n\n\tif (ads1015_event_channel_enabled(data)) {\n\t\tif (data->event_channel != chan->address ||\n\t\t\t(data->comp_mode == ADS1015_CFG_COMP_MODE_TRAD &&\n\t\t\t\tcomp_mode == ADS1015_CFG_COMP_MODE_WINDOW))\n\t\t\treturn -EBUSY;\n\n\t\treturn 0;\n\t}\n\n\tif (comp_mode == ADS1015_CFG_COMP_MODE_TRAD) {\n\t\tlow_thresh = max(-1 << (chan->scan_type.realbits - 1),\n\t\t\t\thigh_thresh - 1);\n\t}\n\tret = regmap_write(data->regmap, ADS1015_LO_THRESH_REG,\n\t\t\tlow_thresh << chan->scan_type.shift);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, ADS1015_HI_THRESH_REG,\n\t\t\thigh_thresh << chan->scan_type.shift);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ads1015_set_power_state(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tads1015_event_channel_enable(data, chan->address, comp_mode);\n\n\tret = ads1015_get_adc_result(data, chan->address, &val);\n\tif (ret) {\n\t\tads1015_event_channel_disable(data, chan->address);\n\t\tads1015_set_power_state(data, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int ads1015_disable_event_config(struct ads1015_data *data,\n\tconst struct iio_chan_spec *chan, int comp_mode)\n{\n\tint ret;\n\n\tif (!ads1015_event_channel_enabled(data))\n\t\treturn 0;\n\n\tif (data->event_channel != chan->address)\n\t\treturn 0;\n\n\tif (data->comp_mode == ADS1015_CFG_COMP_MODE_TRAD &&\n\t\t\tcomp_mode == ADS1015_CFG_COMP_MODE_WINDOW)\n\t\treturn 0;\n\n\tret = regmap_update_bits(data->regmap, ADS1015_CFG_REG,\n\t\t\t\tADS1015_CFG_COMP_QUE_MASK,\n\t\t\t\tADS1015_CFG_COMP_DISABLE <<\n\t\t\t\t\tADS1015_CFG_COMP_QUE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\tads1015_event_channel_disable(data, chan->address);\n\n\treturn ads1015_set_power_state(data, false);\n}\n\nstatic int ads1015_write_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, int state)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint comp_mode = (dir == IIO_EV_DIR_EITHER) ?\n\t\tADS1015_CFG_COMP_MODE_WINDOW : ADS1015_CFG_COMP_MODE_TRAD;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tif (state)\n\t\tret = ads1015_enable_event_config(data, chan, comp_mode);\n\telse\n\t\tret = ads1015_disable_event_config(data, chan, comp_mode);\n\n\tiio_device_release_direct_mode(indio_dev);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t ads1015_event_handler(int irq, void *priv)\n{\n\tstruct iio_dev *indio_dev = priv;\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint val;\n\tint ret;\n\n\t \n\tret = regmap_read(data->regmap, ADS1015_CONV_REG, &val);\n\tif (ret)\n\t\treturn IRQ_HANDLED;\n\n\tif (ads1015_event_channel_enabled(data)) {\n\t\tenum iio_event_direction dir;\n\t\tu64 code;\n\n\t\tdir = data->comp_mode == ADS1015_CFG_COMP_MODE_TRAD ?\n\t\t\t\t\tIIO_EV_DIR_RISING : IIO_EV_DIR_EITHER;\n\t\tcode = IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, data->event_channel,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, dir);\n\t\tiio_push_event(indio_dev, code, iio_get_time_ns(indio_dev));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ads1015_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\n\t \n\tif (ads1015_event_channel_enabled(data))\n\t\treturn -EBUSY;\n\n\treturn ads1015_set_power_state(iio_priv(indio_dev), true);\n}\n\nstatic int ads1015_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\treturn ads1015_set_power_state(iio_priv(indio_dev), false);\n}\n\nstatic const struct iio_buffer_setup_ops ads1015_buffer_setup_ops = {\n\t.preenable\t= ads1015_buffer_preenable,\n\t.postdisable\t= ads1015_buffer_postdisable,\n\t.validate_scan_mask = &iio_validate_scan_mask_onehot,\n};\n\nstatic const struct iio_info ads1015_info = {\n\t.read_avail\t= ads1015_read_avail,\n\t.read_raw\t= ads1015_read_raw,\n\t.write_raw\t= ads1015_write_raw,\n\t.read_event_value = ads1015_read_event,\n\t.write_event_value = ads1015_write_event,\n\t.read_event_config = ads1015_read_event_config,\n\t.write_event_config = ads1015_write_event_config,\n};\n\nstatic const struct iio_info tla2024_info = {\n\t.read_avail\t= ads1015_read_avail,\n\t.read_raw\t= ads1015_read_raw,\n\t.write_raw\t= ads1015_write_raw,\n};\n\nstatic int ads1015_client_get_channels_config(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *node;\n\tint i = -1;\n\n\tdevice_for_each_child_node(dev, node) {\n\t\tu32 pval;\n\t\tunsigned int channel;\n\t\tunsigned int pga = ADS1015_DEFAULT_PGA;\n\t\tunsigned int data_rate = ADS1015_DEFAULT_DATA_RATE;\n\n\t\tif (fwnode_property_read_u32(node, \"reg\", &pval)) {\n\t\t\tdev_err(dev, \"invalid reg on %pfw\\n\", node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchannel = pval;\n\t\tif (channel >= ADS1015_CHANNELS) {\n\t\t\tdev_err(dev, \"invalid channel index %d on %pfw\\n\",\n\t\t\t\tchannel, node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(node, \"ti,gain\", &pval)) {\n\t\t\tpga = pval;\n\t\t\tif (pga > 6) {\n\t\t\t\tdev_err(dev, \"invalid gain on %pfw\\n\", node);\n\t\t\t\tfwnode_handle_put(node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(node, \"ti,datarate\", &pval)) {\n\t\t\tdata_rate = pval;\n\t\t\tif (data_rate > 7) {\n\t\t\t\tdev_err(dev, \"invalid data_rate on %pfw\\n\", node);\n\t\t\t\tfwnode_handle_put(node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdata->channel_data[channel].pga = pga;\n\t\tdata->channel_data[channel].data_rate = data_rate;\n\n\t\ti++;\n\t}\n\n\treturn i < 0 ? -EINVAL : 0;\n}\n\nstatic void ads1015_get_channels_config(struct i2c_client *client)\n{\n\tunsigned int k;\n\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\n\tif (!ads1015_client_get_channels_config(client))\n\t\treturn;\n\n\t \n\tfor (k = 0; k < ADS1015_CHANNELS; ++k) {\n\t\tdata->channel_data[k].pga = ADS1015_DEFAULT_PGA;\n\t\tdata->channel_data[k].data_rate = ADS1015_DEFAULT_DATA_RATE;\n\t}\n}\n\nstatic int ads1015_set_conv_mode(struct ads1015_data *data, int mode)\n{\n\treturn regmap_update_bits(data->regmap, ADS1015_CFG_REG,\n\t\t\t\t  ADS1015_CFG_MOD_MASK,\n\t\t\t\t  mode << ADS1015_CFG_MOD_SHIFT);\n}\n\nstatic int ads1015_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct ads1015_chip_data *chip;\n\tstruct iio_dev *indio_dev;\n\tstruct ads1015_data *data;\n\tint ret;\n\tint i;\n\n\tchip = device_get_match_data(&client->dev);\n\tif (!chip)\n\t\tchip = (const struct ads1015_chip_data *)id->driver_data;\n\tif (!chip)\n\t\treturn dev_err_probe(&client->dev, -EINVAL, \"Unknown chip\\n\");\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = ADS1015_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tindio_dev->channels = chip->channels;\n\tindio_dev->num_channels = chip->num_channels;\n\tindio_dev->info = chip->info;\n\tdata->chip = chip;\n\tdata->event_channel = ADS1015_CHANNELS;\n\n\t \n\tfor (i = 0; i < ADS1015_CHANNELS; i++) {\n\t\tint realbits = indio_dev->channels[i].scan_type.realbits;\n\n\t\tdata->thresh_data[i].low_thresh = -1 << (realbits - 1);\n\t\tdata->thresh_data[i].high_thresh = (1 << (realbits - 1)) - 1;\n\t}\n\n\t \n\tads1015_get_channels_config(client);\n\n\tdata->regmap = devm_regmap_init_i2c(client, chip->has_comparator ?\n\t\t\t\t\t    &ads1015_regmap_config :\n\t\t\t\t\t    &tla2024_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev, NULL,\n\t\t\t\t\t      ads1015_trigger_handler,\n\t\t\t\t\t      &ads1015_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (client->irq && chip->has_comparator) {\n\t\tunsigned long irq_trig =\n\t\t\tirqd_get_trigger_type(irq_get_irq_data(client->irq));\n\t\tunsigned int cfg_comp_mask = ADS1015_CFG_COMP_QUE_MASK |\n\t\t\tADS1015_CFG_COMP_LAT_MASK | ADS1015_CFG_COMP_POL_MASK;\n\t\tunsigned int cfg_comp =\n\t\t\tADS1015_CFG_COMP_DISABLE << ADS1015_CFG_COMP_QUE_SHIFT |\n\t\t\t1 << ADS1015_CFG_COMP_LAT_SHIFT;\n\n\t\tswitch (irq_trig) {\n\t\tcase IRQF_TRIGGER_LOW:\n\t\t\tcfg_comp |= ADS1015_CFG_COMP_POL_LOW <<\n\t\t\t\t\tADS1015_CFG_COMP_POL_SHIFT;\n\t\t\tbreak;\n\t\tcase IRQF_TRIGGER_HIGH:\n\t\t\tcfg_comp |= ADS1015_CFG_COMP_POL_HIGH <<\n\t\t\t\t\tADS1015_CFG_COMP_POL_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = regmap_update_bits(data->regmap, ADS1015_CFG_REG,\n\t\t\t\t\tcfg_comp_mask, cfg_comp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, ads1015_event_handler,\n\t\t\t\t\t\tirq_trig | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ads1015_set_conv_mode(data, ADS1015_CONTINUOUS);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->conv_invalid = true;\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret)\n\t\treturn ret;\n\tpm_runtime_set_autosuspend_delay(&client->dev, ADS1015_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to register IIO device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ads1015_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\t \n\tret = ads1015_set_conv_mode(data, ADS1015_SINGLESHOT);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to power down (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\n#ifdef CONFIG_PM\nstatic int ads1015_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\n\treturn ads1015_set_conv_mode(data, ADS1015_SINGLESHOT);\n}\n\nstatic int ads1015_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct ads1015_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = ads1015_set_conv_mode(data, ADS1015_CONTINUOUS);\n\tif (!ret)\n\t\tdata->conv_invalid = true;\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops ads1015_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ads1015_runtime_suspend,\n\t\t\t   ads1015_runtime_resume, NULL)\n};\n\nstatic const struct ads1015_chip_data ads1015_data = {\n\t.channels\t= ads1015_channels,\n\t.num_channels\t= ARRAY_SIZE(ads1015_channels),\n\t.info\t\t= &ads1015_info,\n\t.data_rate\t= ads1015_data_rate,\n\t.data_rate_len\t= ARRAY_SIZE(ads1015_data_rate),\n\t.scale\t\t= ads1015_scale,\n\t.scale_len\t= ARRAY_SIZE(ads1015_scale),\n\t.has_comparator\t= true,\n};\n\nstatic const struct ads1015_chip_data ads1115_data = {\n\t.channels\t= ads1115_channels,\n\t.num_channels\t= ARRAY_SIZE(ads1115_channels),\n\t.info\t\t= &ads1015_info,\n\t.data_rate\t= ads1115_data_rate,\n\t.data_rate_len\t= ARRAY_SIZE(ads1115_data_rate),\n\t.scale\t\t= ads1115_scale,\n\t.scale_len\t= ARRAY_SIZE(ads1115_scale),\n\t.has_comparator\t= true,\n};\n\nstatic const struct ads1015_chip_data tla2024_data = {\n\t.channels\t= tla2024_channels,\n\t.num_channels\t= ARRAY_SIZE(tla2024_channels),\n\t.info\t\t= &tla2024_info,\n\t.data_rate\t= ads1015_data_rate,\n\t.data_rate_len\t= ARRAY_SIZE(ads1015_data_rate),\n\t.scale\t\t= ads1015_scale,\n\t.scale_len\t= ARRAY_SIZE(ads1015_scale),\n\t.has_comparator\t= false,\n};\n\nstatic const struct i2c_device_id ads1015_id[] = {\n\t{ \"ads1015\", (kernel_ulong_t)&ads1015_data },\n\t{ \"ads1115\", (kernel_ulong_t)&ads1115_data },\n\t{ \"tla2024\", (kernel_ulong_t)&tla2024_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ads1015_id);\n\nstatic const struct of_device_id ads1015_of_match[] = {\n\t{ .compatible = \"ti,ads1015\", .data = &ads1015_data },\n\t{ .compatible = \"ti,ads1115\", .data = &ads1115_data },\n\t{ .compatible = \"ti,tla2024\", .data = &tla2024_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ads1015_of_match);\n\nstatic struct i2c_driver ads1015_driver = {\n\t.driver = {\n\t\t.name = ADS1015_DRV_NAME,\n\t\t.of_match_table = ads1015_of_match,\n\t\t.pm = &ads1015_pm_ops,\n\t},\n\t.probe\t\t= ads1015_probe,\n\t.remove\t\t= ads1015_remove,\n\t.id_table\t= ads1015_id,\n};\n\nmodule_i2c_driver(ads1015_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADS1015 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}