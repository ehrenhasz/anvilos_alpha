{
  "module_name": "sc27xx_adc.c",
  "hash_id": "eb0b44aea7f73b854f3980a1e6b89d2d66c6752eba76f40556f43f5bff8f1dbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/sc27xx_adc.c",
  "human_readable_source": "\n\n\n#include <linux/hwspinlock.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \n#define SC2730_MODULE_EN\t\t0x1808\n#define SC2731_MODULE_EN\t\t0xc08\n#define SC27XX_MODULE_ADC_EN\t\tBIT(5)\n#define SC2721_ARM_CLK_EN\t\t0xc0c\n#define SC2730_ARM_CLK_EN\t\t0x180c\n#define SC2731_ARM_CLK_EN\t\t0xc10\n#define SC27XX_CLK_ADC_EN\t\tBIT(5)\n#define SC27XX_CLK_ADC_CLK_EN\t\tBIT(6)\n\n \n#define SC27XX_ADC_CTL\t\t\t0x0\n#define SC27XX_ADC_CH_CFG\t\t0x4\n#define SC27XX_ADC_DATA\t\t\t0x4c\n#define SC27XX_ADC_INT_EN\t\t0x50\n#define SC27XX_ADC_INT_CLR\t\t0x54\n#define SC27XX_ADC_INT_STS\t\t0x58\n#define SC27XX_ADC_INT_RAW\t\t0x5c\n\n \n#define SC27XX_ADC_EN\t\t\tBIT(0)\n#define SC27XX_ADC_CHN_RUN\t\tBIT(1)\n#define SC27XX_ADC_12BIT_MODE\t\tBIT(2)\n#define SC27XX_ADC_RUN_NUM_MASK\t\tGENMASK(7, 4)\n#define SC27XX_ADC_RUN_NUM_SHIFT\t4\n\n \n#define SC27XX_ADC_CHN_ID_MASK\t\tGENMASK(4, 0)\n#define SC27XX_ADC_SCALE_MASK\t\tGENMASK(10, 9)\n#define SC2721_ADC_SCALE_MASK\t\tBIT(5)\n#define SC27XX_ADC_SCALE_SHIFT\t\t9\n#define SC2721_ADC_SCALE_SHIFT\t\t5\n\n \n#define SC27XX_ADC_IRQ_EN\t\tBIT(0)\n\n \n#define SC27XX_ADC_IRQ_CLR\t\tBIT(0)\n\n \n#define SC27XX_ADC_IRQ_RAW\t\tBIT(0)\n\n \n#define SC27XX_ADC_DATA_MASK\t\tGENMASK(11, 0)\n\n \n#define SC27XX_ADC_HWLOCK_TIMEOUT\t5000\n\n \n#define SC27XX_ADC_RDY_TIMEOUT\t\t1000000\n#define SC27XX_ADC_POLL_RAW_STATUS\t500\n\n \n#define SC27XX_ADC_CHANNEL_MAX\t\t32\n\n \n#define SC27XX_VOLT_RATIO(n, d)\t\t\\\n\t(((n) << SC27XX_RATIO_NUMERATOR_OFFSET) | (d))\n#define SC27XX_RATIO_NUMERATOR_OFFSET\t16\n#define SC27XX_RATIO_DENOMINATOR_MASK\tGENMASK(15, 0)\n\n \n#define SC27XX_ADC_REFVOL_VDD35\t\t3500000\n\n \n#define SC27XX_ADC_REFVOL_VDD28\t\t2800000\n\nstruct sc27xx_adc_data {\n\tstruct device *dev;\n\tstruct regulator *volref;\n\tstruct regmap *regmap;\n\t \n\tstruct mutex lock;\n\t \n\tstruct hwspinlock *hwlock;\n\tint channel_scale[SC27XX_ADC_CHANNEL_MAX];\n\tu32 base;\n\tint irq;\n\tconst struct sc27xx_adc_variant_data *var_data;\n};\n\n \nstruct sc27xx_adc_variant_data {\n\tu32 module_en;\n\tu32 clk_en;\n\tu32 scale_shift;\n\tu32 scale_mask;\n\tconst struct sc27xx_adc_linear_graph *bscale_cal;\n\tconst struct sc27xx_adc_linear_graph *sscale_cal;\n\tvoid (*init_scale)(struct sc27xx_adc_data *data);\n\tint (*get_ratio)(int channel, int scale);\n\tbool set_volref;\n};\n\nstruct sc27xx_adc_linear_graph {\n\tint volt0;\n\tint adc0;\n\tint volt1;\n\tint adc1;\n};\n\n \nstatic struct sc27xx_adc_linear_graph big_scale_graph = {\n\t4200, 3310,\n\t3600, 2832,\n};\n\nstatic struct sc27xx_adc_linear_graph small_scale_graph = {\n\t1000, 3413,\n\t100, 341,\n};\n\nstatic const struct sc27xx_adc_linear_graph sc2731_big_scale_graph_calib = {\n\t4200, 850,\n\t3600, 728,\n};\n\nstatic const struct sc27xx_adc_linear_graph sc2731_small_scale_graph_calib = {\n\t1000, 838,\n\t100, 84,\n};\n\nstatic const struct sc27xx_adc_linear_graph big_scale_graph_calib = {\n\t4200, 856,\n\t3600, 733,\n};\n\nstatic const struct sc27xx_adc_linear_graph small_scale_graph_calib = {\n\t1000, 833,\n\t100, 80,\n};\n\nstatic int sc27xx_adc_get_calib_data(u32 calib_data, int calib_adc)\n{\n\treturn ((calib_data & 0xff) + calib_adc - 128) * 4;\n}\n\n \nstatic int adc_nvmem_cell_calib_data(struct sc27xx_adc_data *data, const char *cell_name)\n{\n\tstruct nvmem_cell *cell;\n\tvoid *buf;\n\tu32 origin_calib_data = 0;\n\tsize_t len;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tcell = nvmem_cell_get(data->dev, cell_name);\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tif (IS_ERR(buf)) {\n\t\tnvmem_cell_put(cell);\n\t\treturn PTR_ERR(buf);\n\t}\n\n\tmemcpy(&origin_calib_data, buf, min(len, sizeof(u32)));\n\n\tkfree(buf);\n\tnvmem_cell_put(cell);\n\treturn origin_calib_data;\n}\n\nstatic int sc27xx_adc_scale_calibration(struct sc27xx_adc_data *data,\n\t\t\t\t\tbool big_scale)\n{\n\tconst struct sc27xx_adc_linear_graph *calib_graph;\n\tstruct sc27xx_adc_linear_graph *graph;\n\tconst char *cell_name;\n\tu32 calib_data = 0;\n\n\tif (big_scale) {\n\t\tcalib_graph = data->var_data->bscale_cal;\n\t\tgraph = &big_scale_graph;\n\t\tcell_name = \"big_scale_calib\";\n\t} else {\n\t\tcalib_graph = data->var_data->sscale_cal;\n\t\tgraph = &small_scale_graph;\n\t\tcell_name = \"small_scale_calib\";\n\t}\n\n\tcalib_data = adc_nvmem_cell_calib_data(data, cell_name);\n\n\t \n\tgraph->adc0 = sc27xx_adc_get_calib_data(calib_data, calib_graph->adc0);\n\tgraph->adc1 = sc27xx_adc_get_calib_data(calib_data >> 8,\n\t\t\t\t\t\tcalib_graph->adc1);\n\n\treturn 0;\n}\n\nstatic int sc2720_adc_get_ratio(int channel, int scale)\n{\n\tswitch (channel) {\n\tcase 14:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 900);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 1760);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 2327);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 3654);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tcase 16:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(48, 100);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(480, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(480, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(48, 406);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(3, 8);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(375, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(375, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(300, 3248);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tdefault:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(100, 406);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\t}\n\treturn SC27XX_VOLT_RATIO(1, 1);\n}\n\nstatic int sc2721_adc_get_ratio(int channel, int scale)\n{\n\tswitch (channel) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\treturn scale ? SC27XX_VOLT_RATIO(400, 1025) :\n\t\t\tSC27XX_VOLT_RATIO(1, 1);\n\tcase 5:\n\t\treturn SC27XX_VOLT_RATIO(7, 29);\n\tcase 7:\n\tcase 9:\n\t\treturn scale ? SC27XX_VOLT_RATIO(100, 125) :\n\t\t\tSC27XX_VOLT_RATIO(1, 1);\n\tcase 14:\n\t\treturn SC27XX_VOLT_RATIO(68, 900);\n\tcase 16:\n\t\treturn SC27XX_VOLT_RATIO(48, 100);\n\tcase 19:\n\t\treturn SC27XX_VOLT_RATIO(1, 3);\n\tdefault:\n\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t}\n\treturn SC27XX_VOLT_RATIO(1, 1);\n}\n\nstatic int sc2730_adc_get_ratio(int channel, int scale)\n{\n\tswitch (channel) {\n\tcase 14:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 900);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 1760);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 2327);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(68, 3654);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tcase 15:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 3);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 5865);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(500, 3879);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(500, 6090);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tcase 16:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(48, 100);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(480, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(480, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(48, 406);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(3, 8);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(375, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(375, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(300, 3248);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\tdefault:\n\t\tswitch (scale) {\n\t\tcase 0:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\tcase 1:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 1955);\n\t\tcase 2:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 2586);\n\t\tcase 3:\n\t\t\treturn SC27XX_VOLT_RATIO(1000, 4060);\n\t\tdefault:\n\t\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t\t}\n\t}\n\treturn SC27XX_VOLT_RATIO(1, 1);\n}\n\nstatic int sc2731_adc_get_ratio(int channel, int scale)\n{\n\tswitch (channel) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\treturn scale ? SC27XX_VOLT_RATIO(400, 1025) :\n\t\t\tSC27XX_VOLT_RATIO(1, 1);\n\tcase 5:\n\t\treturn SC27XX_VOLT_RATIO(7, 29);\n\tcase 6:\n\t\treturn SC27XX_VOLT_RATIO(375, 9000);\n\tcase 7:\n\tcase 8:\n\t\treturn scale ? SC27XX_VOLT_RATIO(100, 125) :\n\t\t\tSC27XX_VOLT_RATIO(1, 1);\n\tcase 19:\n\t\treturn SC27XX_VOLT_RATIO(1, 3);\n\tdefault:\n\t\treturn SC27XX_VOLT_RATIO(1, 1);\n\t}\n\treturn SC27XX_VOLT_RATIO(1, 1);\n}\n\n \nstatic void sc2720_adc_scale_init(struct sc27xx_adc_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < SC27XX_ADC_CHANNEL_MAX; i++) {\n\t\tswitch (i) {\n\t\tcase 5:\n\t\t\tdata->channel_scale[i] = 3;\n\t\t\tbreak;\n\t\tcase 7:\n\t\tcase 9:\n\t\t\tdata->channel_scale[i] = 2;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tdata->channel_scale[i] = 1;\n\t\t\tbreak;\n\t\tcase 19:\n\t\tcase 30:\n\t\tcase 31:\n\t\t\tdata->channel_scale[i] = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->channel_scale[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void sc2730_adc_scale_init(struct sc27xx_adc_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < SC27XX_ADC_CHANNEL_MAX; i++) {\n\t\tswitch (i) {\n\t\tcase 5:\n\t\tcase 10:\n\t\tcase 19:\n\t\tcase 30:\n\t\tcase 31:\n\t\t\tdata->channel_scale[i] = 3;\n\t\t\tbreak;\n\t\tcase 7:\n\t\tcase 9:\n\t\t\tdata->channel_scale[i] = 2;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tdata->channel_scale[i] = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->channel_scale[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void sc2731_adc_scale_init(struct sc27xx_adc_data *data)\n{\n\tint i;\n\t \n\tfor (i = 0; i < SC27XX_ADC_CHANNEL_MAX; i++) {\n\t\tswitch (i) {\n\t\tcase 5:\n\t\t\tdata->channel_scale[i] = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->channel_scale[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int sc27xx_adc_read(struct sc27xx_adc_data *data, int channel,\n\t\t\t   int scale, int *val)\n{\n\tint ret, ret_volref;\n\tu32 tmp, value, status;\n\n\tret = hwspin_lock_timeout_raw(data->hwlock, SC27XX_ADC_HWLOCK_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(data->dev, \"timeout to get the hwspinlock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((data->var_data->set_volref) && (channel == 30 || channel == 31)) {\n\t\tret = regulator_set_voltage(data->volref,\n\t\t\t\t\tSC27XX_ADC_REFVOL_VDD35,\n\t\t\t\t\tSC27XX_ADC_REFVOL_VDD35);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"failed to set the volref 3.5v\\n\");\n\t\t\tgoto unlock_adc;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_ADC_CTL,\n\t\t\t\t SC27XX_ADC_EN, SC27XX_ADC_EN);\n\tif (ret)\n\t\tgoto regulator_restore;\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_ADC_INT_CLR,\n\t\t\t\t SC27XX_ADC_IRQ_CLR, SC27XX_ADC_IRQ_CLR);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\t \n\ttmp = (scale << data->var_data->scale_shift) & data->var_data->scale_mask;\n\ttmp |= channel & SC27XX_ADC_CHN_ID_MASK;\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_ADC_CH_CFG,\n\t\t\t\t SC27XX_ADC_CHN_ID_MASK |\n\t\t\t\t data->var_data->scale_mask,\n\t\t\t\t tmp);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\t \n\ttmp = SC27XX_ADC_12BIT_MODE;\n\ttmp |= (0 << SC27XX_ADC_RUN_NUM_SHIFT) & SC27XX_ADC_RUN_NUM_MASK;\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_ADC_CTL,\n\t\t\t\t SC27XX_ADC_RUN_NUM_MASK | SC27XX_ADC_12BIT_MODE,\n\t\t\t\t tmp);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_ADC_CTL,\n\t\t\t\t SC27XX_ADC_CHN_RUN, SC27XX_ADC_CHN_RUN);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\tret = regmap_read_poll_timeout(data->regmap,\n\t\t\t\t       data->base + SC27XX_ADC_INT_RAW,\n\t\t\t\t       status, (status & SC27XX_ADC_IRQ_RAW),\n\t\t\t\t       SC27XX_ADC_POLL_RAW_STATUS,\n\t\t\t\t       SC27XX_ADC_RDY_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(data->dev, \"read adc timeout, status = 0x%x\\n\", status);\n\t\tgoto disable_adc;\n\t}\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_ADC_DATA, &value);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\tvalue &= SC27XX_ADC_DATA_MASK;\n\ndisable_adc:\n\tregmap_update_bits(data->regmap, data->base + SC27XX_ADC_CTL,\n\t\t\t   SC27XX_ADC_EN, 0);\nregulator_restore:\n\tif ((data->var_data->set_volref) && (channel == 30 || channel == 31)) {\n\t\tret_volref = regulator_set_voltage(data->volref,\n\t\t\t\t\t    SC27XX_ADC_REFVOL_VDD28,\n\t\t\t\t\t    SC27XX_ADC_REFVOL_VDD28);\n\t\tif (ret_volref) {\n\t\t\tdev_err(data->dev, \"failed to set the volref 2.8v,ret_volref = 0x%x\\n\",\n\t\t\t\t\t ret_volref);\n\t\t\tret = ret || ret_volref;\n\t\t}\n\t}\nunlock_adc:\n\thwspin_unlock_raw(data->hwlock);\n\n\tif (!ret)\n\t\t*val = value;\n\n\treturn ret;\n}\n\nstatic void sc27xx_adc_volt_ratio(struct sc27xx_adc_data *data, int channel, int scale,\n\t\t\t\t  struct u32_fract *fract)\n{\n\tu32 ratio;\n\n\tratio = data->var_data->get_ratio(channel, scale);\n\tfract->numerator = ratio >> SC27XX_RATIO_NUMERATOR_OFFSET;\n\tfract->denominator = ratio & SC27XX_RATIO_DENOMINATOR_MASK;\n}\n\nstatic int adc_to_volt(struct sc27xx_adc_linear_graph *graph,\n\t\t\t      int raw_adc)\n{\n\tint tmp;\n\n\ttmp = (graph->volt0 - graph->volt1) * (raw_adc - graph->adc1);\n\ttmp /= (graph->adc0 - graph->adc1);\n\ttmp += graph->volt1;\n\n\treturn tmp;\n}\n\nstatic int sc27xx_adc_to_volt(struct sc27xx_adc_linear_graph *graph,\n\t\t\t      int raw_adc)\n{\n\tint tmp;\n\n\ttmp = adc_to_volt(graph, raw_adc);\n\n\treturn tmp < 0 ? 0 : tmp;\n}\n\nstatic int sc27xx_adc_convert_volt(struct sc27xx_adc_data *data, int channel,\n\t\t\t\t   int scale, int raw_adc)\n{\n\tstruct u32_fract fract;\n\tu32 volt;\n\n\t \n\tswitch (channel) {\n\tcase 5:\n\t\treturn sc27xx_adc_to_volt(&big_scale_graph, raw_adc);\n\n\tcase 1:\n\t\treturn sc27xx_adc_to_volt(&small_scale_graph, raw_adc);\n\n\tdefault:\n\t\tvolt = sc27xx_adc_to_volt(&small_scale_graph, raw_adc);\n\t\tbreak;\n\t}\n\n\tsc27xx_adc_volt_ratio(data, channel, scale, &fract);\n\n\treturn DIV_ROUND_CLOSEST(volt * fract.denominator, fract.numerator);\n}\n\nstatic int sc27xx_adc_read_processed(struct sc27xx_adc_data *data,\n\t\t\t\t     int channel, int scale, int *val)\n{\n\tint ret, raw_adc;\n\n\tret = sc27xx_adc_read(data, channel, scale, &raw_adc);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sc27xx_adc_convert_volt(data, channel, scale, raw_adc);\n\treturn 0;\n}\n\nstatic int sc27xx_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct sc27xx_adc_data *data = iio_priv(indio_dev);\n\tint scale = data->channel_scale[chan->channel];\n\tint ret, tmp;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->lock);\n\t\tret = sc27xx_adc_read(data, chan->channel, scale, &tmp);\n\t\tmutex_unlock(&data->lock);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = tmp;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tmutex_lock(&data->lock);\n\t\tret = sc27xx_adc_read_processed(data, chan->channel, scale,\n\t\t\t\t\t\t&tmp);\n\t\tmutex_unlock(&data->lock);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = tmp;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = scale;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sc27xx_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tstruct sc27xx_adc_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tdata->channel_scale[chan->channel] = val;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info sc27xx_info = {\n\t.read_raw = &sc27xx_adc_read_raw,\n\t.write_raw = &sc27xx_adc_write_raw,\n};\n\n#define SC27XX_ADC_CHANNEL(index, mask) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.info_mask_separate = mask | BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.datasheet_name = \"CH##index\",\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec sc27xx_channels[] = {\n\tSC27XX_ADC_CHANNEL(0, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(1, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(2, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(3, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(4, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(5, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(6, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(7, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(8, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(9, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(10, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(11, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(12, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(13, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(14, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(15, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(16, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(17, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(18, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(19, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(20, BIT(IIO_CHAN_INFO_RAW)),\n\tSC27XX_ADC_CHANNEL(21, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(22, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(23, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(24, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(25, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(26, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(27, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(28, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(29, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(30, BIT(IIO_CHAN_INFO_PROCESSED)),\n\tSC27XX_ADC_CHANNEL(31, BIT(IIO_CHAN_INFO_PROCESSED)),\n};\n\nstatic int sc27xx_adc_enable(struct sc27xx_adc_data *data)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, data->var_data->module_en,\n\t\t\t\t SC27XX_MODULE_ADC_EN, SC27XX_MODULE_ADC_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, data->var_data->clk_en,\n\t\t\t\t SC27XX_CLK_ADC_EN | SC27XX_CLK_ADC_CLK_EN,\n\t\t\t\t SC27XX_CLK_ADC_EN | SC27XX_CLK_ADC_CLK_EN);\n\tif (ret)\n\t\tgoto disable_adc;\n\n\t \n\tret = sc27xx_adc_scale_calibration(data, true);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = sc27xx_adc_scale_calibration(data, false);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tregmap_update_bits(data->regmap, data->var_data->clk_en,\n\t\t\t   SC27XX_CLK_ADC_EN | SC27XX_CLK_ADC_CLK_EN, 0);\ndisable_adc:\n\tregmap_update_bits(data->regmap, data->var_data->module_en,\n\t\t\t   SC27XX_MODULE_ADC_EN, 0);\n\n\treturn ret;\n}\n\nstatic void sc27xx_adc_disable(void *_data)\n{\n\tstruct sc27xx_adc_data *data = _data;\n\n\t \n\tregmap_update_bits(data->regmap, data->var_data->clk_en,\n\t\t\t   SC27XX_CLK_ADC_EN | SC27XX_CLK_ADC_CLK_EN, 0);\n\n\tregmap_update_bits(data->regmap, data->var_data->module_en,\n\t\t\t   SC27XX_MODULE_ADC_EN, 0);\n}\n\nstatic const struct sc27xx_adc_variant_data sc2731_data = {\n\t.module_en = SC2731_MODULE_EN,\n\t.clk_en = SC2731_ARM_CLK_EN,\n\t.scale_shift = SC27XX_ADC_SCALE_SHIFT,\n\t.scale_mask = SC27XX_ADC_SCALE_MASK,\n\t.bscale_cal = &sc2731_big_scale_graph_calib,\n\t.sscale_cal = &sc2731_small_scale_graph_calib,\n\t.init_scale = sc2731_adc_scale_init,\n\t.get_ratio = sc2731_adc_get_ratio,\n\t.set_volref = false,\n};\n\nstatic const struct sc27xx_adc_variant_data sc2730_data = {\n\t.module_en = SC2730_MODULE_EN,\n\t.clk_en = SC2730_ARM_CLK_EN,\n\t.scale_shift = SC27XX_ADC_SCALE_SHIFT,\n\t.scale_mask = SC27XX_ADC_SCALE_MASK,\n\t.bscale_cal = &big_scale_graph_calib,\n\t.sscale_cal = &small_scale_graph_calib,\n\t.init_scale = sc2730_adc_scale_init,\n\t.get_ratio = sc2730_adc_get_ratio,\n\t.set_volref = false,\n};\n\nstatic const struct sc27xx_adc_variant_data sc2721_data = {\n\t.module_en = SC2731_MODULE_EN,\n\t.clk_en = SC2721_ARM_CLK_EN,\n\t.scale_shift = SC2721_ADC_SCALE_SHIFT,\n\t.scale_mask = SC2721_ADC_SCALE_MASK,\n\t.bscale_cal = &sc2731_big_scale_graph_calib,\n\t.sscale_cal = &sc2731_small_scale_graph_calib,\n\t.init_scale = sc2731_adc_scale_init,\n\t.get_ratio = sc2721_adc_get_ratio,\n\t.set_volref = true,\n};\n\nstatic const struct sc27xx_adc_variant_data sc2720_data = {\n\t.module_en = SC2731_MODULE_EN,\n\t.clk_en = SC2721_ARM_CLK_EN,\n\t.scale_shift = SC27XX_ADC_SCALE_SHIFT,\n\t.scale_mask = SC27XX_ADC_SCALE_MASK,\n\t.bscale_cal = &big_scale_graph_calib,\n\t.sscale_cal = &small_scale_graph_calib,\n\t.init_scale = sc2720_adc_scale_init,\n\t.get_ratio = sc2720_adc_get_ratio,\n\t.set_volref = false,\n};\n\nstatic int sc27xx_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sc27xx_adc_data *sc27xx_data;\n\tconst struct sc27xx_adc_variant_data *pdata;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tpdata = of_device_get_match_data(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"No matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*sc27xx_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tsc27xx_data = iio_priv(indio_dev);\n\n\tsc27xx_data->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!sc27xx_data->regmap) {\n\t\tdev_err(dev, \"failed to get ADC regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(np, \"reg\", &sc27xx_data->base);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get ADC base address\\n\");\n\t\treturn ret;\n\t}\n\n\tsc27xx_data->irq = platform_get_irq(pdev, 0);\n\tif (sc27xx_data->irq < 0)\n\t\treturn sc27xx_data->irq;\n\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get hwspinlock id\\n\");\n\t\treturn ret;\n\t}\n\n\tsc27xx_data->hwlock = devm_hwspin_lock_request_specific(dev, ret);\n\tif (!sc27xx_data->hwlock) {\n\t\tdev_err(dev, \"failed to request hwspinlock\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tsc27xx_data->dev = dev;\n\tif (pdata->set_volref) {\n\t\tsc27xx_data->volref = devm_regulator_get(dev, \"vref\");\n\t\tif (IS_ERR(sc27xx_data->volref)) {\n\t\t\tret = PTR_ERR(sc27xx_data->volref);\n\t\t\treturn dev_err_probe(dev, ret, \"failed to get ADC volref\\n\");\n\t\t}\n\t}\n\n\tsc27xx_data->var_data = pdata;\n\tsc27xx_data->var_data->init_scale(sc27xx_data);\n\n\tret = sc27xx_adc_enable(sc27xx_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ADC module\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, sc27xx_adc_disable, sc27xx_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add ADC disable action\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &sc27xx_info;\n\tindio_dev->channels = sc27xx_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(sc27xx_channels);\n\n\tmutex_init(&sc27xx_data->lock);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\tdev_err(dev, \"could not register iio (ADC)\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id sc27xx_adc_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-adc\", .data = &sc2731_data},\n\t{ .compatible = \"sprd,sc2730-adc\", .data = &sc2730_data},\n\t{ .compatible = \"sprd,sc2721-adc\", .data = &sc2721_data},\n\t{ .compatible = \"sprd,sc2720-adc\", .data = &sc2720_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sc27xx_adc_of_match);\n\nstatic struct platform_driver sc27xx_adc_driver = {\n\t.probe = sc27xx_adc_probe,\n\t.driver = {\n\t\t.name = \"sc27xx-adc\",\n\t\t.of_match_table = sc27xx_adc_of_match,\n\t},\n};\n\nmodule_platform_driver(sc27xx_adc_driver);\n\nMODULE_AUTHOR(\"Freeman Liu <freeman.liu@spreadtrum.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum SC27XX ADC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}