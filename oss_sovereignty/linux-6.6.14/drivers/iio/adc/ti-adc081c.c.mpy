{
  "module_name": "ti-adc081c.c",
  "hash_id": "20807e50cad7a91a404c722f3e514c1b31eb3974ea82e464f0a767b650bbf243",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc081c.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/regulator/consumer.h>\n\nstruct adc081c {\n\tstruct i2c_client *i2c;\n\tstruct regulator *ref;\n\n\t \n\tint bits;\n\n\t \n\tstruct {\n\t\tu16 channel;\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\n#define REG_CONV_RES 0x00\n\nstatic int adc081c_read_raw(struct iio_dev *iio,\n\t\t\t    struct iio_chan_spec const *channel, int *value,\n\t\t\t    int *shift, long mask)\n{\n\tstruct adc081c *adc = iio_priv(iio);\n\tint err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = i2c_smbus_read_word_swapped(adc->i2c, REG_CONV_RES);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = (err & 0xFFF) >> (12 - adc->bits);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\terr = regulator_get_voltage(adc->ref);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = err / 1000;\n\t\t*shift = adc->bits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\n#define ADCxx1C_CHAN(_bits) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 12 - (_bits),\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define DEFINE_ADCxx1C_CHANNELS(_name, _bits)\t\t\t\t\\\n\tstatic const struct iio_chan_spec _name ## _channels[] = {\t\\\n\t\tADCxx1C_CHAN((_bits)),\t\t\t\t\t\\\n\t\tIIO_CHAN_SOFT_TIMESTAMP(1),\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\n#define ADC081C_NUM_CHANNELS 2\n\nstruct adcxx1c_model {\n\tconst struct iio_chan_spec* channels;\n\tint bits;\n};\n\n#define ADCxx1C_MODEL(_name, _bits)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.channels = _name ## _channels,\t\t\t\t\\\n\t\t.bits = (_bits),\t\t\t\t\t\\\n\t}\n\nDEFINE_ADCxx1C_CHANNELS(adc081c,  8);\nDEFINE_ADCxx1C_CHANNELS(adc101c, 10);\nDEFINE_ADCxx1C_CHANNELS(adc121c, 12);\n\n \nenum adcxx1c_model_id {\n\tADC081C = 0,\n\tADC101C = 1,\n\tADC121C = 2,\n};\n\nstatic struct adcxx1c_model adcxx1c_models[] = {\n\tADCxx1C_MODEL(adc081c,  8),\n\tADCxx1C_MODEL(adc101c, 10),\n\tADCxx1C_MODEL(adc121c, 12),\n};\n\nstatic const struct iio_info adc081c_info = {\n\t.read_raw = adc081c_read_raw,\n};\n\nstatic irqreturn_t adc081c_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adc081c *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_word_swapped(data->i2c, REG_CONV_RES);\n\tif (ret < 0)\n\t\tgoto out;\n\tdata->scan.channel = ret;\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic void adc081c_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int adc081c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *iio;\n\tstruct adc081c *adc;\n\tconst struct adcxx1c_model *model;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev_fwnode(&client->dev))\n\t\tmodel = device_get_match_data(&client->dev);\n\telse\n\t\tmodel = &adcxx1c_models[id->driver_data];\n\n\tiio = devm_iio_device_alloc(&client->dev, sizeof(*adc));\n\tif (!iio)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(iio);\n\tadc->i2c = client;\n\tadc->bits = model->bits;\n\n\tadc->ref = devm_regulator_get(&client->dev, \"vref\");\n\tif (IS_ERR(adc->ref))\n\t\treturn PTR_ERR(adc->ref);\n\n\terr = regulator_enable(adc->ref);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&client->dev, adc081c_reg_disable,\n\t\t\t\t       adc->ref);\n\tif (err)\n\t\treturn err;\n\n\tiio->name = dev_name(&client->dev);\n\tiio->modes = INDIO_DIRECT_MODE;\n\tiio->info = &adc081c_info;\n\n\tiio->channels = model->channels;\n\tiio->num_channels = ADC081C_NUM_CHANNELS;\n\n\terr = devm_iio_triggered_buffer_setup(&client->dev, iio, NULL,\n\t\t\t\t\t      adc081c_trigger_handler, NULL);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, iio);\n}\n\nstatic const struct i2c_device_id adc081c_id[] = {\n\t{ \"adc081c\", ADC081C },\n\t{ \"adc101c\", ADC101C },\n\t{ \"adc121c\", ADC121C },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adc081c_id);\n\nstatic const struct acpi_device_id adc081c_acpi_match[] = {\n\t \n\t{ \"ADC081C\", (kernel_ulong_t)&adcxx1c_models[ADC081C] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, adc081c_acpi_match);\n\nstatic const struct of_device_id adc081c_of_match[] = {\n\t{ .compatible = \"ti,adc081c\", .data = &adcxx1c_models[ADC081C] },\n\t{ .compatible = \"ti,adc101c\", .data = &adcxx1c_models[ADC101C] },\n\t{ .compatible = \"ti,adc121c\", .data = &adcxx1c_models[ADC121C] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc081c_of_match);\n\nstatic struct i2c_driver adc081c_driver = {\n\t.driver = {\n\t\t.name = \"adc081c\",\n\t\t.of_match_table = adc081c_of_match,\n\t\t.acpi_match_table = adc081c_acpi_match,\n\t},\n\t.probe = adc081c_probe,\n\t.id_table = adc081c_id,\n};\nmodule_i2c_driver(adc081c_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <thierry.reding@avionic-design.de>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADC081C/ADC101C/ADC121C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}