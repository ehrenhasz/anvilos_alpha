{
  "module_name": "ad7124.c",
  "hash_id": "f4614b43c110a45f6d8c3e58a5910790e64ac483b079e08ec809940a9f07d850",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7124.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n#include <linux/iio/sysfs.h>\n\n \n#define AD7124_COMMS\t\t\t0x00\n#define AD7124_STATUS\t\t\t0x00\n#define AD7124_ADC_CONTROL\t\t0x01\n#define AD7124_DATA\t\t\t0x02\n#define AD7124_IO_CONTROL_1\t\t0x03\n#define AD7124_IO_CONTROL_2\t\t0x04\n#define AD7124_ID\t\t\t0x05\n#define AD7124_ERROR\t\t\t0x06\n#define AD7124_ERROR_EN\t\t0x07\n#define AD7124_MCLK_COUNT\t\t0x08\n#define AD7124_CHANNEL(x)\t\t(0x09 + (x))\n#define AD7124_CONFIG(x)\t\t(0x19 + (x))\n#define AD7124_FILTER(x)\t\t(0x21 + (x))\n#define AD7124_OFFSET(x)\t\t(0x29 + (x))\n#define AD7124_GAIN(x)\t\t\t(0x31 + (x))\n\n \n#define AD7124_STATUS_POR_FLAG_MSK\tBIT(4)\n\n \n#define AD7124_ADC_STATUS_EN_MSK\tBIT(10)\n#define AD7124_ADC_STATUS_EN(x)\t\tFIELD_PREP(AD7124_ADC_STATUS_EN_MSK, x)\n#define AD7124_ADC_CTRL_REF_EN_MSK\tBIT(8)\n#define AD7124_ADC_CTRL_REF_EN(x)\tFIELD_PREP(AD7124_ADC_CTRL_REF_EN_MSK, x)\n#define AD7124_ADC_CTRL_PWR_MSK\tGENMASK(7, 6)\n#define AD7124_ADC_CTRL_PWR(x)\t\tFIELD_PREP(AD7124_ADC_CTRL_PWR_MSK, x)\n#define AD7124_ADC_CTRL_MODE_MSK\tGENMASK(5, 2)\n#define AD7124_ADC_CTRL_MODE(x)\tFIELD_PREP(AD7124_ADC_CTRL_MODE_MSK, x)\n\n \n#define AD7124_DEVICE_ID_MSK\t\tGENMASK(7, 4)\n#define AD7124_DEVICE_ID_GET(x)\t\tFIELD_GET(AD7124_DEVICE_ID_MSK, x)\n#define AD7124_SILICON_REV_MSK\t\tGENMASK(3, 0)\n#define AD7124_SILICON_REV_GET(x)\tFIELD_GET(AD7124_SILICON_REV_MSK, x)\n\n#define CHIPID_AD7124_4\t\t\t0x0\n#define CHIPID_AD7124_8\t\t\t0x1\n\n \n#define AD7124_CHANNEL_EN_MSK\t\tBIT(15)\n#define AD7124_CHANNEL_EN(x)\t\tFIELD_PREP(AD7124_CHANNEL_EN_MSK, x)\n#define AD7124_CHANNEL_SETUP_MSK\tGENMASK(14, 12)\n#define AD7124_CHANNEL_SETUP(x)\tFIELD_PREP(AD7124_CHANNEL_SETUP_MSK, x)\n#define AD7124_CHANNEL_AINP_MSK\tGENMASK(9, 5)\n#define AD7124_CHANNEL_AINP(x)\t\tFIELD_PREP(AD7124_CHANNEL_AINP_MSK, x)\n#define AD7124_CHANNEL_AINM_MSK\tGENMASK(4, 0)\n#define AD7124_CHANNEL_AINM(x)\t\tFIELD_PREP(AD7124_CHANNEL_AINM_MSK, x)\n\n \n#define AD7124_CONFIG_BIPOLAR_MSK\tBIT(11)\n#define AD7124_CONFIG_BIPOLAR(x)\tFIELD_PREP(AD7124_CONFIG_BIPOLAR_MSK, x)\n#define AD7124_CONFIG_REF_SEL_MSK\tGENMASK(4, 3)\n#define AD7124_CONFIG_REF_SEL(x)\tFIELD_PREP(AD7124_CONFIG_REF_SEL_MSK, x)\n#define AD7124_CONFIG_PGA_MSK\t\tGENMASK(2, 0)\n#define AD7124_CONFIG_PGA(x)\t\tFIELD_PREP(AD7124_CONFIG_PGA_MSK, x)\n#define AD7124_CONFIG_IN_BUFF_MSK\tGENMASK(6, 5)\n#define AD7124_CONFIG_IN_BUFF(x)\tFIELD_PREP(AD7124_CONFIG_IN_BUFF_MSK, x)\n\n \n#define AD7124_FILTER_FS_MSK\t\tGENMASK(10, 0)\n#define AD7124_FILTER_FS(x)\t\tFIELD_PREP(AD7124_FILTER_FS_MSK, x)\n#define AD7124_FILTER_TYPE_MSK\t\tGENMASK(23, 21)\n#define AD7124_FILTER_TYPE_SEL(x)\tFIELD_PREP(AD7124_FILTER_TYPE_MSK, x)\n\n#define AD7124_SINC3_FILTER 2\n#define AD7124_SINC4_FILTER 0\n\n#define AD7124_CONF_ADDR_OFFSET\t20\n#define AD7124_MAX_CONFIGS\t8\n#define AD7124_MAX_CHANNELS\t16\n\nenum ad7124_ids {\n\tID_AD7124_4,\n\tID_AD7124_8,\n};\n\nenum ad7124_ref_sel {\n\tAD7124_REFIN1,\n\tAD7124_REFIN2,\n\tAD7124_INT_REF,\n\tAD7124_AVDD_REF,\n};\n\nenum ad7124_power_mode {\n\tAD7124_LOW_POWER,\n\tAD7124_MID_POWER,\n\tAD7124_FULL_POWER,\n};\n\nstatic const unsigned int ad7124_gain[8] = {\n\t1, 2, 4, 8, 16, 32, 64, 128\n};\n\nstatic const unsigned int ad7124_reg_size[] = {\n\t1, 2, 3, 3, 2, 1, 3, 3, 1, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3\n};\n\nstatic const int ad7124_master_clk_freq_hz[3] = {\n\t[AD7124_LOW_POWER] = 76800,\n\t[AD7124_MID_POWER] = 153600,\n\t[AD7124_FULL_POWER] = 614400,\n};\n\nstatic const char * const ad7124_ref_names[] = {\n\t[AD7124_REFIN1] = \"refin1\",\n\t[AD7124_REFIN2] = \"refin2\",\n\t[AD7124_INT_REF] = \"int\",\n\t[AD7124_AVDD_REF] = \"avdd\",\n};\n\nstruct ad7124_chip_info {\n\tconst char *name;\n\tunsigned int chip_id;\n\tunsigned int num_inputs;\n};\n\nstruct ad7124_channel_config {\n\tbool live;\n\tunsigned int cfg_slot;\n\tenum ad7124_ref_sel refsel;\n\tbool bipolar;\n\tbool buf_positive;\n\tbool buf_negative;\n\tunsigned int vref_mv;\n\tunsigned int pga_bits;\n\tunsigned int odr;\n\tunsigned int odr_sel_bits;\n\tunsigned int filter_type;\n};\n\nstruct ad7124_channel {\n\tunsigned int nr;\n\tstruct ad7124_channel_config cfg;\n\tunsigned int ain;\n\tunsigned int slot;\n};\n\nstruct ad7124_state {\n\tconst struct ad7124_chip_info *chip_info;\n\tstruct ad_sigma_delta sd;\n\tstruct ad7124_channel *channels;\n\tstruct regulator *vref[4];\n\tstruct clk *mclk;\n\tunsigned int adc_control;\n\tunsigned int num_channels;\n\tstruct mutex cfgs_lock;  \n\tunsigned long cfg_slots_status;  \n\tDECLARE_KFIFO(live_cfgs_fifo, struct ad7124_channel_config *, AD7124_MAX_CONFIGS);\n};\n\nstatic const struct iio_chan_spec ad7124_channel_template = {\n\t.type = IIO_VOLTAGE,\n\t.indexed = 1,\n\t.differential = 1,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t.scan_type = {\n\t\t.sign = 'u',\n\t\t.realbits = 24,\n\t\t.storagebits = 32,\n\t\t.endianness = IIO_BE,\n\t},\n};\n\nstatic struct ad7124_chip_info ad7124_chip_info_tbl[] = {\n\t[ID_AD7124_4] = {\n\t\t.name = \"ad7124-4\",\n\t\t.chip_id = CHIPID_AD7124_4,\n\t\t.num_inputs = 8,\n\t},\n\t[ID_AD7124_8] = {\n\t\t.name = \"ad7124-8\",\n\t\t.chip_id = CHIPID_AD7124_8,\n\t\t.num_inputs = 16,\n\t},\n};\n\nstatic int ad7124_find_closest_match(const int *array,\n\t\t\t\t     unsigned int size, int val)\n{\n\tint i, idx;\n\tunsigned int diff_new, diff_old;\n\n\tdiff_old = U32_MAX;\n\tidx = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tdiff_new = abs(val - array[i]);\n\t\tif (diff_new < diff_old) {\n\t\t\tdiff_old = diff_new;\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\treturn idx;\n}\n\nstatic int ad7124_spi_write_mask(struct ad7124_state *st,\n\t\t\t\t unsigned int addr,\n\t\t\t\t unsigned long mask,\n\t\t\t\t unsigned int val,\n\t\t\t\t unsigned int bytes)\n{\n\tunsigned int readval;\n\tint ret;\n\n\tret = ad_sd_read_reg(&st->sd, addr, bytes, &readval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treadval &= ~mask;\n\treadval |= val;\n\n\treturn ad_sd_write_reg(&st->sd, addr, bytes, readval);\n}\n\nstatic int ad7124_set_mode(struct ad_sigma_delta *sd,\n\t\t\t   enum ad_sigma_delta_mode mode)\n{\n\tstruct ad7124_state *st = container_of(sd, struct ad7124_state, sd);\n\n\tst->adc_control &= ~AD7124_ADC_CTRL_MODE_MSK;\n\tst->adc_control |= AD7124_ADC_CTRL_MODE(mode);\n\n\treturn ad_sd_write_reg(&st->sd, AD7124_ADC_CONTROL, 2, st->adc_control);\n}\n\nstatic void ad7124_set_channel_odr(struct ad7124_state *st, unsigned int channel, unsigned int odr)\n{\n\tunsigned int fclk, odr_sel_bits;\n\n\tfclk = clk_get_rate(st->mclk);\n\t \n\todr_sel_bits = DIV_ROUND_CLOSEST(fclk, odr * 32);\n\tif (odr_sel_bits < 1)\n\t\todr_sel_bits = 1;\n\telse if (odr_sel_bits > 2047)\n\t\todr_sel_bits = 2047;\n\n\tif (odr_sel_bits != st->channels[channel].cfg.odr_sel_bits)\n\t\tst->channels[channel].cfg.live = false;\n\n\t \n\tst->channels[channel].cfg.odr = DIV_ROUND_CLOSEST(fclk, odr_sel_bits * 32);\n\tst->channels[channel].cfg.odr_sel_bits = odr_sel_bits;\n}\n\nstatic int ad7124_get_3db_filter_freq(struct ad7124_state *st,\n\t\t\t\t      unsigned int channel)\n{\n\tunsigned int fadc;\n\n\tfadc = st->channels[channel].cfg.odr;\n\n\tswitch (st->channels[channel].cfg.filter_type) {\n\tcase AD7124_SINC3_FILTER:\n\t\treturn DIV_ROUND_CLOSEST(fadc * 230, 1000);\n\tcase AD7124_SINC4_FILTER:\n\t\treturn DIV_ROUND_CLOSEST(fadc * 262, 1000);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void ad7124_set_3db_filter_freq(struct ad7124_state *st, unsigned int channel,\n\t\t\t\t       unsigned int freq)\n{\n\tunsigned int sinc4_3db_odr;\n\tunsigned int sinc3_3db_odr;\n\tunsigned int new_filter;\n\tunsigned int new_odr;\n\n\tsinc4_3db_odr = DIV_ROUND_CLOSEST(freq * 1000, 230);\n\tsinc3_3db_odr = DIV_ROUND_CLOSEST(freq * 1000, 262);\n\n\tif (sinc4_3db_odr > sinc3_3db_odr) {\n\t\tnew_filter = AD7124_SINC3_FILTER;\n\t\tnew_odr = sinc4_3db_odr;\n\t} else {\n\t\tnew_filter = AD7124_SINC4_FILTER;\n\t\tnew_odr = sinc3_3db_odr;\n\t}\n\n\tif (new_odr != st->channels[channel].cfg.odr)\n\t\tst->channels[channel].cfg.live = false;\n\n\tst->channels[channel].cfg.filter_type = new_filter;\n\tst->channels[channel].cfg.odr = new_odr;\n}\n\nstatic struct ad7124_channel_config *ad7124_find_similar_live_cfg(struct ad7124_state *st,\n\t\t\t\t\t\t\t\t  struct ad7124_channel_config *cfg)\n{\n\tstruct ad7124_channel_config *cfg_aux;\n\tptrdiff_t cmp_size;\n\tint i;\n\n\tcmp_size = (u8 *)&cfg->live - (u8 *)cfg;\n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tcfg_aux = &st->channels[i].cfg;\n\n\t\tif (cfg_aux->live && !memcmp(cfg, cfg_aux, cmp_size))\n\t\t\treturn cfg_aux;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ad7124_find_free_config_slot(struct ad7124_state *st)\n{\n\tunsigned int free_cfg_slot;\n\n\tfree_cfg_slot = find_first_zero_bit(&st->cfg_slots_status, AD7124_MAX_CONFIGS);\n\tif (free_cfg_slot == AD7124_MAX_CONFIGS)\n\t\treturn -1;\n\n\treturn free_cfg_slot;\n}\n\nstatic int ad7124_init_config_vref(struct ad7124_state *st, struct ad7124_channel_config *cfg)\n{\n\tunsigned int refsel = cfg->refsel;\n\n\tswitch (refsel) {\n\tcase AD7124_REFIN1:\n\tcase AD7124_REFIN2:\n\tcase AD7124_AVDD_REF:\n\t\tif (IS_ERR(st->vref[refsel])) {\n\t\t\tdev_err(&st->sd.spi->dev,\n\t\t\t\t\"Error, trying to use external voltage reference without a %s regulator.\\n\",\n\t\t\t\tad7124_ref_names[refsel]);\n\t\t\treturn PTR_ERR(st->vref[refsel]);\n\t\t}\n\t\tcfg->vref_mv = regulator_get_voltage(st->vref[refsel]);\n\t\t \n\t\tcfg->vref_mv /= 1000;\n\t\treturn 0;\n\tcase AD7124_INT_REF:\n\t\tcfg->vref_mv = 2500;\n\t\tst->adc_control &= ~AD7124_ADC_CTRL_REF_EN_MSK;\n\t\tst->adc_control |= AD7124_ADC_CTRL_REF_EN(1);\n\t\treturn ad_sd_write_reg(&st->sd, AD7124_ADC_CONTROL,\n\t\t\t\t      2, st->adc_control);\n\tdefault:\n\t\tdev_err(&st->sd.spi->dev, \"Invalid reference %d\\n\", refsel);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7124_write_config(struct ad7124_state *st, struct ad7124_channel_config *cfg,\n\t\t\t       unsigned int cfg_slot)\n{\n\tunsigned int tmp;\n\tunsigned int val;\n\tint ret;\n\n\tcfg->cfg_slot = cfg_slot;\n\n\ttmp = (cfg->buf_positive << 1) + cfg->buf_negative;\n\tval = AD7124_CONFIG_BIPOLAR(cfg->bipolar) | AD7124_CONFIG_REF_SEL(cfg->refsel) |\n\t      AD7124_CONFIG_IN_BUFF(tmp);\n\tret = ad_sd_write_reg(&st->sd, AD7124_CONFIG(cfg->cfg_slot), 2, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = AD7124_FILTER_TYPE_SEL(cfg->filter_type);\n\tret = ad7124_spi_write_mask(st, AD7124_FILTER(cfg->cfg_slot), AD7124_FILTER_TYPE_MSK,\n\t\t\t\t    tmp, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad7124_spi_write_mask(st, AD7124_FILTER(cfg->cfg_slot), AD7124_FILTER_FS_MSK,\n\t\t\t\t    AD7124_FILTER_FS(cfg->odr_sel_bits), 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad7124_spi_write_mask(st, AD7124_CONFIG(cfg->cfg_slot), AD7124_CONFIG_PGA_MSK,\n\t\t\t\t     AD7124_CONFIG_PGA(cfg->pga_bits), 2);\n}\n\nstatic struct ad7124_channel_config *ad7124_pop_config(struct ad7124_state *st)\n{\n\tstruct ad7124_channel_config *lru_cfg;\n\tstruct ad7124_channel_config *cfg;\n\tint ret;\n\tint i;\n\n\t \n\tret = kfifo_get(&st->live_cfgs_fifo, &lru_cfg);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tlru_cfg->live = false;\n\n\t \n\tassign_bit(lru_cfg->cfg_slot, &st->cfg_slots_status, 0);\n\n\t \n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tcfg = &st->channels[i].cfg;\n\n\t\tif (cfg->cfg_slot == lru_cfg->cfg_slot)\n\t\t\tcfg->live = false;\n\t}\n\n\treturn lru_cfg;\n}\n\nstatic int ad7124_push_config(struct ad7124_state *st, struct ad7124_channel_config *cfg)\n{\n\tstruct ad7124_channel_config *lru_cfg;\n\tint free_cfg_slot;\n\n\tfree_cfg_slot = ad7124_find_free_config_slot(st);\n\tif (free_cfg_slot >= 0) {\n\t\t \n\t\tkfifo_put(&st->live_cfgs_fifo, cfg);\n\t} else {\n\t\t \n\t\tlru_cfg = ad7124_pop_config(st);\n\t\tif (!lru_cfg)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfree_cfg_slot = lru_cfg->cfg_slot;\n\t\tkfifo_put(&st->live_cfgs_fifo, cfg);\n\t}\n\n\t \n\tassign_bit(free_cfg_slot, &st->cfg_slots_status, 1);\n\n\treturn ad7124_write_config(st, cfg, free_cfg_slot);\n}\n\nstatic int ad7124_enable_channel(struct ad7124_state *st, struct ad7124_channel *ch)\n{\n\tch->cfg.live = true;\n\treturn ad_sd_write_reg(&st->sd, AD7124_CHANNEL(ch->nr), 2, ch->ain |\n\t\t\t      AD7124_CHANNEL_SETUP(ch->cfg.cfg_slot) | AD7124_CHANNEL_EN(1));\n}\n\nstatic int ad7124_prepare_read(struct ad7124_state *st, int address)\n{\n\tstruct ad7124_channel_config *cfg = &st->channels[address].cfg;\n\tstruct ad7124_channel_config *live_cfg;\n\n\t \n\tif (!cfg->live) {\n\t\t \n\t\tlive_cfg = ad7124_find_similar_live_cfg(st, cfg);\n\t\tif (!live_cfg)\n\t\t\tad7124_push_config(st, cfg);\n\t\telse\n\t\t\tcfg->cfg_slot = live_cfg->cfg_slot;\n\t}\n\n\t \n\treturn ad7124_enable_channel(st, &st->channels[address]);\n}\n\nstatic int __ad7124_set_channel(struct ad_sigma_delta *sd, unsigned int channel)\n{\n\tstruct ad7124_state *st = container_of(sd, struct ad7124_state, sd);\n\n\treturn ad7124_prepare_read(st, channel);\n}\n\nstatic int ad7124_set_channel(struct ad_sigma_delta *sd, unsigned int channel)\n{\n\tstruct ad7124_state *st = container_of(sd, struct ad7124_state, sd);\n\tint ret;\n\n\tmutex_lock(&st->cfgs_lock);\n\tret = __ad7124_set_channel(sd, channel);\n\tmutex_unlock(&st->cfgs_lock);\n\n\treturn ret;\n}\n\nstatic int ad7124_append_status(struct ad_sigma_delta *sd, bool append)\n{\n\tstruct ad7124_state *st = container_of(sd, struct ad7124_state, sd);\n\tunsigned int adc_control = st->adc_control;\n\tint ret;\n\n\tadc_control &= ~AD7124_ADC_STATUS_EN_MSK;\n\tadc_control |= AD7124_ADC_STATUS_EN(append);\n\n\tret = ad_sd_write_reg(&st->sd, AD7124_ADC_CONTROL, 2, adc_control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->adc_control = adc_control;\n\n\treturn 0;\n}\n\nstatic int ad7124_disable_all(struct ad_sigma_delta *sd)\n{\n\tstruct ad7124_state *st = container_of(sd, struct ad7124_state, sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tret = ad7124_spi_write_mask(st, AD7124_CHANNEL(i), AD7124_CHANNEL_EN_MSK, 0, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ad_sigma_delta_info ad7124_sigma_delta_info = {\n\t.set_channel = ad7124_set_channel,\n\t.append_status = ad7124_append_status,\n\t.disable_all = ad7124_disable_all,\n\t.set_mode = ad7124_set_mode,\n\t.has_registers = true,\n\t.addr_shift = 0,\n\t.read_mask = BIT(6),\n\t.status_ch_mask = GENMASK(3, 0),\n\t.data_reg = AD7124_DATA,\n\t.num_slots = 8,\n\t.irq_flags = IRQF_TRIGGER_FALLING,\n};\n\nstatic int ad7124_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad7124_state *st = iio_priv(indio_dev);\n\tint idx, ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ad_sd_write_reg(&st->sd, AD7124_CHANNEL(chan->address), 2,\n\t\t\t\t      st->channels[chan->address].ain | AD7124_CHANNEL_EN(0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&st->cfgs_lock);\n\n\t\tidx = st->channels[chan->address].cfg.pga_bits;\n\t\t*val = st->channels[chan->address].cfg.vref_mv;\n\t\tif (st->channels[chan->address].cfg.bipolar)\n\t\t\t*val2 = chan->scan_type.realbits - 1 + idx;\n\t\telse\n\t\t\t*val2 = chan->scan_type.realbits + idx;\n\n\t\tmutex_unlock(&st->cfgs_lock);\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tmutex_lock(&st->cfgs_lock);\n\t\tif (st->channels[chan->address].cfg.bipolar)\n\t\t\t*val = -(1 << (chan->scan_type.realbits - 1));\n\t\telse\n\t\t\t*val = 0;\n\n\t\tmutex_unlock(&st->cfgs_lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&st->cfgs_lock);\n\t\t*val = st->channels[chan->address].cfg.odr;\n\t\tmutex_unlock(&st->cfgs_lock);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tmutex_lock(&st->cfgs_lock);\n\t\t*val = ad7124_get_3db_filter_freq(st, chan->scan_index);\n\t\tmutex_unlock(&st->cfgs_lock);\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7124_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long info)\n{\n\tstruct ad7124_state *st = iio_priv(indio_dev);\n\tunsigned int res, gain, full_scale, vref;\n\tint ret = 0;\n\n\tmutex_lock(&st->cfgs_lock);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2 != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tad7124_set_channel_odr(st, chan->address, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (st->channels[chan->address].cfg.bipolar)\n\t\t\tfull_scale = 1 << (chan->scan_type.realbits - 1);\n\t\telse\n\t\t\tfull_scale = 1 << chan->scan_type.realbits;\n\n\t\tvref = st->channels[chan->address].cfg.vref_mv * 1000000LL;\n\t\tres = DIV_ROUND_CLOSEST(vref, full_scale);\n\t\tgain = DIV_ROUND_CLOSEST(res, val2);\n\t\tres = ad7124_find_closest_match(ad7124_gain, ARRAY_SIZE(ad7124_gain), gain);\n\n\t\tif (st->channels[chan->address].cfg.pga_bits != res)\n\t\t\tst->channels[chan->address].cfg.live = false;\n\n\t\tst->channels[chan->address].cfg.pga_bits = res;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (val2 != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tad7124_set_3db_filter_freq(st, chan->address, val);\n\t\tbreak;\n\tdefault:\n\t\tret =  -EINVAL;\n\t}\n\n\tmutex_unlock(&st->cfgs_lock);\n\treturn ret;\n}\n\nstatic int ad7124_reg_access(struct iio_dev *indio_dev,\n\t\t\t     unsigned int reg,\n\t\t\t     unsigned int writeval,\n\t\t\t     unsigned int *readval)\n{\n\tstruct ad7124_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (reg >= ARRAY_SIZE(ad7124_reg_size))\n\t\treturn -EINVAL;\n\n\tif (readval)\n\t\tret = ad_sd_read_reg(&st->sd, reg, ad7124_reg_size[reg],\n\t\t\t\t     readval);\n\telse\n\t\tret = ad_sd_write_reg(&st->sd, reg, ad7124_reg_size[reg],\n\t\t\t\t      writeval);\n\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR(in_voltage_scale_available,\n\t\"0.000001164 0.000002328 0.000004656 0.000009313 0.000018626 0.000037252 0.000074505 0.000149011 0.000298023\");\n\nstatic struct attribute *ad7124_attributes[] = {\n\t&iio_const_attr_in_voltage_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7124_attrs_group = {\n\t.attrs = ad7124_attributes,\n};\n\nstatic int ad7124_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t   const unsigned long *scan_mask)\n{\n\tstruct ad7124_state *st = iio_priv(indio_dev);\n\tbool bit_set;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&st->cfgs_lock);\n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tbit_set = test_bit(i, scan_mask);\n\t\tif (bit_set)\n\t\t\tret = __ad7124_set_channel(&st->sd, i);\n\t\telse\n\t\t\tret = ad7124_spi_write_mask(st, AD7124_CHANNEL(i), AD7124_CHANNEL_EN_MSK,\n\t\t\t\t\t\t    0, 2);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&st->cfgs_lock);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&st->cfgs_lock);\n\n\treturn 0;\n}\n\nstatic const struct iio_info ad7124_info = {\n\t.read_raw = ad7124_read_raw,\n\t.write_raw = ad7124_write_raw,\n\t.debugfs_reg_access = &ad7124_reg_access,\n\t.validate_trigger = ad_sd_validate_trigger,\n\t.update_scan_mode = ad7124_update_scan_mode,\n\t.attrs = &ad7124_attrs_group,\n};\n\nstatic int ad7124_soft_reset(struct ad7124_state *st)\n{\n\tunsigned int readval, timeout;\n\tint ret;\n\n\tret = ad_sd_reset(&st->sd, 64);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttimeout = 100;\n\tdo {\n\t\tret = ad_sd_read_reg(&st->sd, AD7124_STATUS, 1, &readval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(readval & AD7124_STATUS_POR_FLAG_MSK))\n\t\t\treturn 0;\n\n\t\t \n\t\tusleep_range(100, 2000);\n\t} while (--timeout);\n\n\tdev_err(&st->sd.spi->dev, \"Soft reset failed\\n\");\n\n\treturn -EIO;\n}\n\nstatic int ad7124_check_chip_id(struct ad7124_state *st)\n{\n\tunsigned int readval, chip_id, silicon_rev;\n\tint ret;\n\n\tret = ad_sd_read_reg(&st->sd, AD7124_ID, 1, &readval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip_id = AD7124_DEVICE_ID_GET(readval);\n\tsilicon_rev = AD7124_SILICON_REV_GET(readval);\n\n\tif (chip_id != st->chip_info->chip_id) {\n\t\tdev_err(&st->sd.spi->dev,\n\t\t\t\"Chip ID mismatch: expected %u, got %u\\n\",\n\t\t\tst->chip_info->chip_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tif (silicon_rev == 0) {\n\t\tdev_err(&st->sd.spi->dev,\n\t\t\t\"Silicon revision empty. Chip may not be present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7124_of_parse_channel_config(struct iio_dev *indio_dev,\n\t\t\t\t\t  struct device_node *np)\n{\n\tstruct ad7124_state *st = iio_priv(indio_dev);\n\tstruct ad7124_channel_config *cfg;\n\tstruct ad7124_channel *channels;\n\tstruct device_node *child;\n\tstruct iio_chan_spec *chan;\n\tunsigned int ain[2], channel = 0, tmp;\n\tint ret;\n\n\tst->num_channels = of_get_available_child_count(np);\n\tif (!st->num_channels) {\n\t\tdev_err(indio_dev->dev.parent, \"no channel children\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchan = devm_kcalloc(indio_dev->dev.parent, st->num_channels,\n\t\t\t    sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\tchannels = devm_kcalloc(indio_dev->dev.parent, st->num_channels, sizeof(*channels),\n\t\t\t\tGFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tindio_dev->channels = chan;\n\tindio_dev->num_channels = st->num_channels;\n\tst->channels = channels;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tcfg = &st->channels[channel].cfg;\n\n\t\tret = of_property_read_u32(child, \"reg\", &channel);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (channel >= indio_dev->num_channels) {\n\t\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\t\"Channel index >= number of channels\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = of_property_read_u32_array(child, \"diff-channels\",\n\t\t\t\t\t\t ain, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tst->channels[channel].nr = channel;\n\t\tst->channels[channel].ain = AD7124_CHANNEL_AINP(ain[0]) |\n\t\t\t\t\t\t  AD7124_CHANNEL_AINM(ain[1]);\n\n\t\tcfg->bipolar = of_property_read_bool(child, \"bipolar\");\n\n\t\tret = of_property_read_u32(child, \"adi,reference-select\", &tmp);\n\t\tif (ret)\n\t\t\tcfg->refsel = AD7124_INT_REF;\n\t\telse\n\t\t\tcfg->refsel = tmp;\n\n\t\tcfg->buf_positive = of_property_read_bool(child, \"adi,buffered-positive\");\n\t\tcfg->buf_negative = of_property_read_bool(child, \"adi,buffered-negative\");\n\n\t\tchan[channel] = ad7124_channel_template;\n\t\tchan[channel].address = channel;\n\t\tchan[channel].scan_index = channel;\n\t\tchan[channel].channel = ain[0];\n\t\tchan[channel].channel2 = ain[1];\n\t}\n\n\treturn 0;\nerr:\n\tof_node_put(child);\n\n\treturn ret;\n}\n\nstatic int ad7124_setup(struct ad7124_state *st)\n{\n\tunsigned int fclk, power_mode;\n\tint i, ret;\n\n\tfclk = clk_get_rate(st->mclk);\n\tif (!fclk)\n\t\treturn -EINVAL;\n\n\t \n\tpower_mode = ad7124_find_closest_match(ad7124_master_clk_freq_hz,\n\t\t\t\t\tARRAY_SIZE(ad7124_master_clk_freq_hz),\n\t\t\t\t\tfclk);\n\tif (fclk != ad7124_master_clk_freq_hz[power_mode]) {\n\t\tret = clk_set_rate(st->mclk, fclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tst->adc_control &= ~AD7124_ADC_CTRL_PWR_MSK;\n\tst->adc_control |= AD7124_ADC_CTRL_PWR(power_mode);\n\tret = ad_sd_write_reg(&st->sd, AD7124_ADC_CONTROL, 2, st->adc_control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&st->cfgs_lock);\n\tINIT_KFIFO(st->live_cfgs_fifo);\n\tfor (i = 0; i < st->num_channels; i++) {\n\n\t\tret = ad7124_init_config_vref(st, &st->channels[i].cfg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tad7124_set_channel_odr(st, i, 10);\n\t}\n\n\treturn ret;\n}\n\nstatic void ad7124_reg_disable(void *r)\n{\n\tregulator_disable(r);\n}\n\nstatic int ad7124_probe(struct spi_device *spi)\n{\n\tconst struct ad7124_chip_info *info;\n\tstruct ad7124_state *st;\n\tstruct iio_dev *indio_dev;\n\tint i, ret;\n\n\tinfo = of_device_get_match_data(&spi->dev);\n\tif (!info)\n\t\tinfo = (void *)spi_get_device_id(spi)->driver_data;\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->chip_info = info;\n\n\tindio_dev->name = st->chip_info->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad7124_info;\n\n\tret = ad_sd_init(&st->sd, indio_dev, spi, &ad7124_sigma_delta_info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad7124_of_parse_channel_config(indio_dev, spi->dev.of_node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(st->vref); i++) {\n\t\tif (i == AD7124_INT_REF)\n\t\t\tcontinue;\n\n\t\tst->vref[i] = devm_regulator_get_optional(&spi->dev,\n\t\t\t\t\t\tad7124_ref_names[i]);\n\t\tif (PTR_ERR(st->vref[i]) == -ENODEV)\n\t\t\tcontinue;\n\t\telse if (IS_ERR(st->vref[i]))\n\t\t\treturn PTR_ERR(st->vref[i]);\n\n\t\tret = regulator_enable(st->vref[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7124_reg_disable,\n\t\t\t\t\t       st->vref[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->mclk = devm_clk_get_enabled(&spi->dev, \"mclk\");\n\tif (IS_ERR(st->mclk))\n\t\treturn PTR_ERR(st->mclk);\n\n\tret = ad7124_soft_reset(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad7124_check_chip_id(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7124_setup(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n\n}\n\nstatic const struct of_device_id ad7124_of_match[] = {\n\t{ .compatible = \"adi,ad7124-4\",\n\t\t.data = &ad7124_chip_info_tbl[ID_AD7124_4], },\n\t{ .compatible = \"adi,ad7124-8\",\n\t\t.data = &ad7124_chip_info_tbl[ID_AD7124_8], },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7124_of_match);\n\nstatic const struct spi_device_id ad71124_ids[] = {\n\t{ \"ad7124-4\", (kernel_ulong_t)&ad7124_chip_info_tbl[ID_AD7124_4] },\n\t{ \"ad7124-8\", (kernel_ulong_t)&ad7124_chip_info_tbl[ID_AD7124_8] },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad71124_ids);\n\nstatic struct spi_driver ad71124_driver = {\n\t.driver = {\n\t\t.name = \"ad7124\",\n\t\t.of_match_table = ad7124_of_match,\n\t},\n\t.probe = ad7124_probe,\n\t.id_table = ad71124_ids,\n};\nmodule_spi_driver(ad71124_driver);\n\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7124 SPI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}