{
  "module_name": "imx8qxp-adc.c",
  "hash_id": "ec256294a9d5351cbbcf84aecd612b7ca0871e86f32672eaec885007c383a3b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/imx8qxp-adc.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n\n#define ADC_DRIVER_NAME\t\t\"imx8qxp-adc\"\n\n \n#define IMX8QXP_ADR_ADC_CTRL\t\t0x10\n#define IMX8QXP_ADR_ADC_STAT\t\t0x14\n#define IMX8QXP_ADR_ADC_IE\t\t0x18\n#define IMX8QXP_ADR_ADC_DE\t\t0x1c\n#define IMX8QXP_ADR_ADC_CFG\t\t0x20\n#define IMX8QXP_ADR_ADC_FCTRL\t\t0x30\n#define IMX8QXP_ADR_ADC_SWTRIG\t\t0x34\n#define IMX8QXP_ADR_ADC_TCTRL(tid)\t(0xc0 + (tid) * 4)\n#define IMX8QXP_ADR_ADC_CMDL(cid)\t(0x100 + (cid) * 8)\n#define IMX8QXP_ADR_ADC_CMDH(cid)\t(0x104 + (cid) * 8)\n#define IMX8QXP_ADR_ADC_RESFIFO\t\t0x300\n#define IMX8QXP_ADR_ADC_TST\t\t0xffc\n\n \n#define IMX8QXP_ADC_IE_FWMIE_MASK\t\tGENMASK(1, 0)\n#define IMX8QXP_ADC_CTRL_FIFO_RESET_MASK\tBIT(8)\n#define IMX8QXP_ADC_CTRL_SOFTWARE_RESET_MASK\tBIT(1)\n#define IMX8QXP_ADC_CTRL_ADC_EN_MASK\t\tBIT(0)\n#define IMX8QXP_ADC_TCTRL_TCMD_MASK\t\tGENMASK(31, 24)\n#define IMX8QXP_ADC_TCTRL_TDLY_MASK\t\tGENMASK(23, 16)\n#define IMX8QXP_ADC_TCTRL_TPRI_MASK\t\tGENMASK(15, 8)\n#define IMX8QXP_ADC_TCTRL_HTEN_MASK\t\tGENMASK(7, 0)\n#define IMX8QXP_ADC_CMDL_CSCALE_MASK\t\tGENMASK(13, 8)\n#define IMX8QXP_ADC_CMDL_MODE_MASK\t\tBIT(7)\n#define IMX8QXP_ADC_CMDL_DIFF_MASK\t\tBIT(6)\n#define IMX8QXP_ADC_CMDL_ABSEL_MASK\t\tBIT(5)\n#define IMX8QXP_ADC_CMDL_ADCH_MASK\t\tGENMASK(2, 0)\n#define IMX8QXP_ADC_CMDH_NEXT_MASK\t\tGENMASK(31, 24)\n#define IMX8QXP_ADC_CMDH_LOOP_MASK\t\tGENMASK(23, 16)\n#define IMX8QXP_ADC_CMDH_AVGS_MASK\t\tGENMASK(15, 12)\n#define IMX8QXP_ADC_CMDH_STS_MASK\t\tBIT(8)\n#define IMX8QXP_ADC_CMDH_LWI_MASK\t\tGENMASK(7, 7)\n#define IMX8QXP_ADC_CMDH_CMPEN_MASK\t\tGENMASK(0, 0)\n#define IMX8QXP_ADC_CFG_PWREN_MASK\t\tBIT(28)\n#define IMX8QXP_ADC_CFG_PUDLY_MASK\t\tGENMASK(23, 16)\n#define IMX8QXP_ADC_CFG_REFSEL_MASK\t\tGENMASK(7, 6)\n#define IMX8QXP_ADC_CFG_PWRSEL_MASK\t\tGENMASK(5, 4)\n#define IMX8QXP_ADC_CFG_TPRICTRL_MASK\t\tGENMASK(3, 0)\n#define IMX8QXP_ADC_FCTRL_FWMARK_MASK\t\tGENMASK(20, 16)\n#define IMX8QXP_ADC_FCTRL_FCOUNT_MASK\t\tGENMASK(4, 0)\n#define IMX8QXP_ADC_RESFIFO_VAL_MASK\t\tGENMASK(18, 3)\n\n \n#define IMX8QXP_ADC_CMDL_CHANNEL_SCALE_FULL\t\tGENMASK(5, 0)\n#define IMX8QXP_ADC_CMDL_SEL_A_A_B_CHANNEL\t\t0\n#define IMX8QXP_ADC_CMDL_STANDARD_RESOLUTION\t\t0\n#define IMX8QXP_ADC_CMDL_MODE_SINGLE\t\t\t0\n#define IMX8QXP_ADC_CMDH_LWI_INCREMENT_DIS\t\t0\n#define IMX8QXP_ADC_CMDH_CMPEN_DIS\t\t\t0\n#define IMX8QXP_ADC_PAUSE_EN\t\t\t\tBIT(31)\n#define IMX8QXP_ADC_TCTRL_TPRI_PRIORITY_HIGH\t\t0\n\n#define IMX8QXP_ADC_TCTRL_HTEN_HW_TIRG_DIS\t\t0\n\n#define IMX8QXP_ADC_TIMEOUT\t\tmsecs_to_jiffies(100)\n\n#define IMX8QXP_ADC_MAX_FIFO_SIZE\t\t16\n\nstruct imx8qxp_adc {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct clk *ipg_clk;\n\tstruct regulator *vref;\n\t \n\tstruct mutex lock;\n\tstruct completion completion;\n\tu32 fifo[IMX8QXP_ADC_MAX_FIFO_SIZE];\n};\n\n#define IMX8QXP_ADC_CHAN(_idx) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (_idx),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n}\n\nstatic const struct iio_chan_spec imx8qxp_adc_iio_channels[] = {\n\tIMX8QXP_ADC_CHAN(0),\n\tIMX8QXP_ADC_CHAN(1),\n\tIMX8QXP_ADC_CHAN(2),\n\tIMX8QXP_ADC_CHAN(3),\n\tIMX8QXP_ADC_CHAN(4),\n\tIMX8QXP_ADC_CHAN(5),\n\tIMX8QXP_ADC_CHAN(6),\n\tIMX8QXP_ADC_CHAN(7),\n};\n\nstatic void imx8qxp_adc_reset(struct imx8qxp_adc *adc)\n{\n\tu32 ctrl;\n\n\t \n\tctrl = readl(adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\tctrl |= FIELD_PREP(IMX8QXP_ADC_CTRL_SOFTWARE_RESET_MASK, 1);\n\twritel(ctrl, adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\tudelay(10);\n\tctrl &= ~FIELD_PREP(IMX8QXP_ADC_CTRL_SOFTWARE_RESET_MASK, 1);\n\twritel(ctrl, adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\n\t \n\tctrl |= FIELD_PREP(IMX8QXP_ADC_CTRL_FIFO_RESET_MASK, 1);\n\twritel(ctrl, adc->regs + IMX8QXP_ADR_ADC_CTRL);\n}\n\nstatic void imx8qxp_adc_reg_config(struct imx8qxp_adc *adc, int channel)\n{\n\tu32 adc_cfg, adc_tctrl, adc_cmdl, adc_cmdh;\n\n\t \n\tadc_cfg = FIELD_PREP(IMX8QXP_ADC_CFG_PWREN_MASK, 1) |\n\t\t  FIELD_PREP(IMX8QXP_ADC_CFG_PUDLY_MASK, 0x80)|\n\t\t  FIELD_PREP(IMX8QXP_ADC_CFG_REFSEL_MASK, 0) |\n\t\t  FIELD_PREP(IMX8QXP_ADC_CFG_PWRSEL_MASK, 3) |\n\t\t  FIELD_PREP(IMX8QXP_ADC_CFG_TPRICTRL_MASK, 0);\n\twritel(adc_cfg, adc->regs + IMX8QXP_ADR_ADC_CFG);\n\n\t \n\tadc_tctrl = FIELD_PREP(IMX8QXP_ADC_TCTRL_TCMD_MASK, 1) |\n\t\t    FIELD_PREP(IMX8QXP_ADC_TCTRL_TDLY_MASK, 0) |\n\t\t    FIELD_PREP(IMX8QXP_ADC_TCTRL_TPRI_MASK, IMX8QXP_ADC_TCTRL_TPRI_PRIORITY_HIGH) |\n\t\t    FIELD_PREP(IMX8QXP_ADC_TCTRL_HTEN_MASK, IMX8QXP_ADC_TCTRL_HTEN_HW_TIRG_DIS);\n\twritel(adc_tctrl, adc->regs + IMX8QXP_ADR_ADC_TCTRL(0));\n\n\t \n\tadc_cmdl = FIELD_PREP(IMX8QXP_ADC_CMDL_CSCALE_MASK, IMX8QXP_ADC_CMDL_CHANNEL_SCALE_FULL) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDL_MODE_MASK, IMX8QXP_ADC_CMDL_STANDARD_RESOLUTION) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDL_DIFF_MASK, IMX8QXP_ADC_CMDL_MODE_SINGLE) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDL_ABSEL_MASK, IMX8QXP_ADC_CMDL_SEL_A_A_B_CHANNEL) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDL_ADCH_MASK, channel);\n\twritel(adc_cmdl, adc->regs + IMX8QXP_ADR_ADC_CMDL(0));\n\n\tadc_cmdh = FIELD_PREP(IMX8QXP_ADC_CMDH_NEXT_MASK, 0) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDH_LOOP_MASK, 0) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDH_AVGS_MASK, 7) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDH_STS_MASK, 0) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDH_LWI_MASK, IMX8QXP_ADC_CMDH_LWI_INCREMENT_DIS) |\n\t\t   FIELD_PREP(IMX8QXP_ADC_CMDH_CMPEN_MASK, IMX8QXP_ADC_CMDH_CMPEN_DIS);\n\twritel(adc_cmdh, adc->regs + IMX8QXP_ADR_ADC_CMDH(0));\n}\n\nstatic void imx8qxp_adc_fifo_config(struct imx8qxp_adc *adc)\n{\n\tu32 fifo_ctrl, interrupt_en;\n\n\tfifo_ctrl = readl(adc->regs + IMX8QXP_ADR_ADC_FCTRL);\n\tfifo_ctrl &= ~IMX8QXP_ADC_FCTRL_FWMARK_MASK;\n\t \n\tfifo_ctrl |= FIELD_PREP(IMX8QXP_ADC_FCTRL_FWMARK_MASK, 0);\n\twritel(fifo_ctrl, adc->regs + IMX8QXP_ADR_ADC_FCTRL);\n\n\t \n\tinterrupt_en = readl(adc->regs + IMX8QXP_ADR_ADC_IE);\n\tinterrupt_en |= FIELD_PREP(IMX8QXP_ADC_IE_FWMIE_MASK, 1);\n\twritel(interrupt_en, adc->regs + IMX8QXP_ADR_ADC_IE);\n}\n\nstatic void imx8qxp_adc_disable(struct imx8qxp_adc *adc)\n{\n\tu32 ctrl;\n\n\tctrl = readl(adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\tctrl &= ~FIELD_PREP(IMX8QXP_ADC_CTRL_ADC_EN_MASK, 1);\n\twritel(ctrl, adc->regs + IMX8QXP_ADR_ADC_CTRL);\n}\n\nstatic int imx8qxp_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct imx8qxp_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = adc->dev;\n\n\tu32 ctrl;\n\tlong ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tpm_runtime_get_sync(dev);\n\n\t\tmutex_lock(&adc->lock);\n\t\treinit_completion(&adc->completion);\n\n\t\timx8qxp_adc_reg_config(adc, chan->channel);\n\n\t\timx8qxp_adc_fifo_config(adc);\n\n\t\t \n\t\tctrl = readl(adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\t\tctrl |= FIELD_PREP(IMX8QXP_ADC_CTRL_ADC_EN_MASK, 1);\n\t\twritel(ctrl, adc->regs + IMX8QXP_ADR_ADC_CTRL);\n\t\t \n\t\twritel(1, adc->regs + IMX8QXP_ADR_ADC_SWTRIG);\n\n\t\tret = wait_for_completion_interruptible_timeout(&adc->completion,\n\t\t\t\t\t\t\t\tIMX8QXP_ADC_TIMEOUT);\n\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_sync_autosuspend(dev);\n\n\t\tif (ret == 0) {\n\t\t\tmutex_unlock(&adc->lock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&adc->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = adc->fifo[0];\n\n\t\tmutex_unlock(&adc->lock);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(adc->vref);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret / 1000;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = clk_get_rate(adc->clk) / 3;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t imx8qxp_adc_isr(int irq, void *dev_id)\n{\n\tstruct imx8qxp_adc *adc = dev_id;\n\tu32 fifo_count;\n\tint i;\n\n\tfifo_count = FIELD_GET(IMX8QXP_ADC_FCTRL_FCOUNT_MASK,\n\t\t\t       readl(adc->regs + IMX8QXP_ADR_ADC_FCTRL));\n\n\tfor (i = 0; i < fifo_count; i++)\n\t\tadc->fifo[i] = FIELD_GET(IMX8QXP_ADC_RESFIFO_VAL_MASK,\n\t\t\t\treadl_relaxed(adc->regs + IMX8QXP_ADR_ADC_RESFIFO));\n\n\tif (fifo_count)\n\t\tcomplete(&adc->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx8qxp_adc_reg_access(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t\t  unsigned int writeval, unsigned int *readval)\n{\n\tstruct imx8qxp_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = adc->dev;\n\n\tif (!readval || reg % 4 || reg > IMX8QXP_ADR_ADC_TST)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(dev);\n\n\t*readval = readl(adc->regs + reg);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_sync_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_info imx8qxp_adc_iio_info = {\n\t.read_raw = &imx8qxp_adc_read_raw,\n\t.debugfs_reg_access = &imx8qxp_adc_reg_access,\n};\n\nstatic int imx8qxp_adc_probe(struct platform_device *pdev)\n{\n\tstruct imx8qxp_adc *adc;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"Failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(indio_dev);\n\tadc->dev = dev;\n\n\tmutex_init(&adc->lock);\n\tadc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc->regs))\n\t\treturn PTR_ERR(adc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tadc->clk = devm_clk_get(dev, \"per\");\n\tif (IS_ERR(adc->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->clk), \"Failed getting clock\\n\");\n\n\tadc->ipg_clk = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(adc->ipg_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->ipg_clk), \"Failed getting clock\\n\");\n\n\tadc->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(adc->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->vref), \"Failed getting reference voltage\\n\");\n\n\tret = regulator_enable(adc->vref);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't enable adc reference top voltage\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinit_completion(&adc->completion);\n\n\tindio_dev->name = ADC_DRIVER_NAME;\n\tindio_dev->info = &imx8qxp_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = imx8qxp_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(imx8qxp_adc_iio_channels);\n\n\tret = clk_prepare_enable(adc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not prepare or enable the clock.\\n\");\n\t\tgoto error_regulator_disable;\n\t}\n\n\tret = clk_prepare_enable(adc->ipg_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not prepare or enable the clock.\\n\");\n\t\tgoto error_adc_clk_disable;\n\t}\n\n\tret = devm_request_irq(dev, irq, imx8qxp_adc_isr, 0, ADC_DRIVER_NAME, adc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed requesting irq, irq = %d\\n\", irq);\n\t\tgoto error_ipg_clk_disable;\n\t}\n\n\timx8qxp_adc_reset(adc);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\timx8qxp_adc_disable(adc);\n\t\tdev_err(dev, \"Couldn't register the device.\\n\");\n\t\tgoto error_ipg_clk_disable;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 50);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerror_ipg_clk_disable:\n\tclk_disable_unprepare(adc->ipg_clk);\nerror_adc_clk_disable:\n\tclk_disable_unprepare(adc->clk);\nerror_regulator_disable:\n\tregulator_disable(adc->vref);\n\n\treturn ret;\n}\n\nstatic int imx8qxp_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct imx8qxp_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = adc->dev;\n\n\tpm_runtime_get_sync(dev);\n\n\tiio_device_unregister(indio_dev);\n\n\timx8qxp_adc_disable(adc);\n\n\tclk_disable_unprepare(adc->clk);\n\tclk_disable_unprepare(adc->ipg_clk);\n\tregulator_disable(adc->vref);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\n\treturn 0;\n}\n\nstatic int imx8qxp_adc_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx8qxp_adc *adc = iio_priv(indio_dev);\n\n\timx8qxp_adc_disable(adc);\n\n\tclk_disable_unprepare(adc->clk);\n\tclk_disable_unprepare(adc->ipg_clk);\n\tregulator_disable(adc->vref);\n\n\treturn 0;\n}\n\nstatic int imx8qxp_adc_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx8qxp_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(adc->vref);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't enable adc reference top voltage, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(adc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not prepare or enable clock.\\n\");\n\t\tgoto err_disable_reg;\n\t}\n\n\tret = clk_prepare_enable(adc->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not prepare or enable clock.\\n\");\n\t\tgoto err_unprepare_clk;\n\t}\n\n\timx8qxp_adc_reset(adc);\n\n\treturn 0;\n\nerr_unprepare_clk:\n\tclk_disable_unprepare(adc->clk);\n\nerr_disable_reg:\n\tregulator_disable(adc->vref);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(imx8qxp_adc_pm_ops,\n\t\t\t\t imx8qxp_adc_runtime_suspend,\n\t\t\t\t imx8qxp_adc_runtime_resume, NULL);\n\nstatic const struct of_device_id imx8qxp_adc_match[] = {\n\t{ .compatible = \"nxp,imx8qxp-adc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qxp_adc_match);\n\nstatic struct platform_driver imx8qxp_adc_driver = {\n\t.probe\t\t= imx8qxp_adc_probe,\n\t.remove\t\t= imx8qxp_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= ADC_DRIVER_NAME,\n\t\t.of_match_table = imx8qxp_adc_match,\n\t\t.pm\t= pm_ptr(&imx8qxp_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(imx8qxp_adc_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QuadXPlus ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}