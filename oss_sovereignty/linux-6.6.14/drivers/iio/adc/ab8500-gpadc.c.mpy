{
  "module_name": "ab8500-gpadc.c",
  "hash_id": "ebf54e80ce8e970d3dcd33f9ca9d8524e8bfd68cd8470d822d42d8f7416e200b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ab8500-gpadc.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/bits.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n#include <linux/regulator/consumer.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n\n \n\n#define AB8500_GPADC_CTRL1_REG\t\t0x00\n \n#define AB8500_GPADC_CTRL1_DISABLE\t\t0x00\n#define AB8500_GPADC_CTRL1_ENABLE\t\tBIT(0)\n#define AB8500_GPADC_CTRL1_TRIG_ENA\t\tBIT(1)\n#define AB8500_GPADC_CTRL1_START_SW_CONV\tBIT(2)\n#define AB8500_GPADC_CTRL1_BTEMP_PULL_UP\tBIT(3)\n \n#define AB8500_GPADC_CTRL1_TRIG_EDGE\t\tBIT(4)\n \n#define AB8500_GPADC_CTRL1_PUPSUPSEL\t\tBIT(5)\n#define AB8500_GPADC_CTRL1_BUF_ENA\t\tBIT(6)\n#define AB8500_GPADC_CTRL1_ICHAR_ENA\t\tBIT(7)\n\n#define AB8500_GPADC_CTRL2_REG\t\t0x01\n#define AB8500_GPADC_CTRL3_REG\t\t0x02\n \n#define AB8500_GPADC_CTRL2_AVG_1\t\t0x00\n#define AB8500_GPADC_CTRL2_AVG_4\t\tBIT(5)\n#define AB8500_GPADC_CTRL2_AVG_8\t\tBIT(6)\n#define AB8500_GPADC_CTRL2_AVG_16\t\t(BIT(5) | BIT(6))\n\nenum ab8500_gpadc_channel {\n\tAB8500_GPADC_CHAN_UNUSED = 0x00,\n\tAB8500_GPADC_CHAN_BAT_CTRL = 0x01,\n\tAB8500_GPADC_CHAN_BAT_TEMP = 0x02,\n\t \n\tAB8500_GPADC_CHAN_MAIN_CHARGER = 0x03,\n\tAB8500_GPADC_CHAN_ACC_DET_1 = 0x04,\n\tAB8500_GPADC_CHAN_ACC_DET_2 = 0x05,\n\tAB8500_GPADC_CHAN_ADC_AUX_1 = 0x06,\n\tAB8500_GPADC_CHAN_ADC_AUX_2 = 0x07,\n\tAB8500_GPADC_CHAN_VBAT_A = 0x08,\n\tAB8500_GPADC_CHAN_VBUS = 0x09,\n\tAB8500_GPADC_CHAN_MAIN_CHARGER_CURRENT = 0x0a,\n\tAB8500_GPADC_CHAN_USB_CHARGER_CURRENT = 0x0b,\n\tAB8500_GPADC_CHAN_BACKUP_BAT = 0x0c,\n\t \n\tAB8505_GPADC_CHAN_DIE_TEMP = 0x0d,\n\tAB8500_GPADC_CHAN_ID = 0x0e,\n\tAB8500_GPADC_CHAN_INTERNAL_TEST_1 = 0x0f,\n\tAB8500_GPADC_CHAN_INTERNAL_TEST_2 = 0x10,\n\tAB8500_GPADC_CHAN_INTERNAL_TEST_3 = 0x11,\n\t \n\tAB8500_GPADC_CHAN_XTAL_TEMP = 0x12,\n\tAB8500_GPADC_CHAN_VBAT_TRUE_MEAS = 0x13,\n\t \n\tAB8500_GPADC_CHAN_BAT_CTRL_AND_IBAT = 0x1c,\n\tAB8500_GPADC_CHAN_VBAT_MEAS_AND_IBAT = 0x1d,\n\tAB8500_GPADC_CHAN_VBAT_TRUE_MEAS_AND_IBAT = 0x1e,\n\tAB8500_GPADC_CHAN_BAT_TEMP_AND_IBAT = 0x1f,\n\t \n\tAB8500_GPADC_CHAN_IBAT_VIRTUAL = 0xFF,\n};\n\n#define AB8500_GPADC_AUTO_TIMER_REG\t0x03\n\n#define AB8500_GPADC_STAT_REG\t\t0x04\n#define AB8500_GPADC_STAT_BUSY\t\tBIT(0)\n\n#define AB8500_GPADC_MANDATAL_REG\t0x05\n#define AB8500_GPADC_MANDATAH_REG\t0x06\n#define AB8500_GPADC_AUTODATAL_REG\t0x07\n#define AB8500_GPADC_AUTODATAH_REG\t0x08\n#define AB8500_GPADC_MUX_CTRL_REG\t0x09\n#define AB8540_GPADC_MANDATA2L_REG\t0x09\n#define AB8540_GPADC_MANDATA2H_REG\t0x0A\n#define AB8540_GPADC_APEAAX_REG\t\t0x10\n#define AB8540_GPADC_APEAAT_REG\t\t0x11\n#define AB8540_GPADC_APEAAM_REG\t\t0x12\n#define AB8540_GPADC_APEAAH_REG\t\t0x13\n#define AB8540_GPADC_APEAAL_REG\t\t0x14\n\n \n#define AB8500_GPADC_CAL_1\t0x0F\n#define AB8500_GPADC_CAL_2\t0x10\n#define AB8500_GPADC_CAL_3\t0x11\n#define AB8500_GPADC_CAL_4\t0x12\n#define AB8500_GPADC_CAL_5\t0x13\n#define AB8500_GPADC_CAL_6\t0x14\n#define AB8500_GPADC_CAL_7\t0x15\n \n#define AB8540_GPADC_OTP4_REG_7\t0x38\n#define AB8540_GPADC_OTP4_REG_6\t0x39\n#define AB8540_GPADC_OTP4_REG_5\t0x3A\n\n#define AB8540_GPADC_DIS_ZERO\t0x00\n#define AB8540_GPADC_EN_VBIAS_XTAL_TEMP\t0x02\n\n \n#define AB8500_ADC_RESOLUTION\t\t1024\n#define AB8500_ADC_CH_BTEMP_MIN\t\t0\n#define AB8500_ADC_CH_BTEMP_MAX\t\t1350\n#define AB8500_ADC_CH_DIETEMP_MIN\t0\n#define AB8500_ADC_CH_DIETEMP_MAX\t1350\n#define AB8500_ADC_CH_CHG_V_MIN\t\t0\n#define AB8500_ADC_CH_CHG_V_MAX\t\t20030\n#define AB8500_ADC_CH_ACCDET2_MIN\t0\n#define AB8500_ADC_CH_ACCDET2_MAX\t2500\n#define AB8500_ADC_CH_VBAT_MIN\t\t2300\n#define AB8500_ADC_CH_VBAT_MAX\t\t4800\n#define AB8500_ADC_CH_CHG_I_MIN\t\t0\n#define AB8500_ADC_CH_CHG_I_MAX\t\t1500\n#define AB8500_ADC_CH_BKBAT_MIN\t\t0\n#define AB8500_ADC_CH_BKBAT_MAX\t\t3200\n\n \n#define AB8500_ADC_CH_IBAT_MIN\t\t(-6000)  \n#define AB8500_ADC_CH_IBAT_MAX\t\t6000\n#define AB8500_ADC_CH_IBAT_MIN_V\t(-60)\t \n#define AB8500_ADC_CH_IBAT_MAX_V\t60\n#define AB8500_GPADC_IBAT_VDROP_L\t(-56)   \n#define AB8500_GPADC_IBAT_VDROP_H\t56\n\n \n#define AB8500_GPADC_CALIB_SCALE\t1000\n \n#define AB8500_GPADC_CALIB_SHIFT_IBAT\t20\n\n \n#define AB8500_GPADC_AUTOSUSPEND_DELAY\t1\n\n#define AB8500_GPADC_CONVERSION_TIME\t500  \n\nenum ab8500_cal_channels {\n\tAB8500_CAL_VMAIN = 0,\n\tAB8500_CAL_BTEMP,\n\tAB8500_CAL_VBAT,\n\tAB8500_CAL_IBAT,\n\tAB8500_CAL_NR,\n};\n\n \nstruct ab8500_adc_cal_data {\n\ts64 gain;\n\ts64 offset;\n\tu16 otp_calib_hi;\n\tu16 otp_calib_lo;\n};\n\n \nstruct ab8500_gpadc_chan_info {\n\tconst char *name;\n\tu8 id;\n\tbool hardware_control;\n\tbool falling_edge;\n\tu8 avg_sample;\n\tu8 trig_timer;\n};\n\n \nstruct ab8500_gpadc {\n\tstruct device *dev;\n\tstruct ab8500 *ab8500;\n\tstruct ab8500_gpadc_chan_info *chans;\n\tunsigned int nchans;\n\tstruct completion complete;\n\tstruct regulator *vddadc;\n\tint irq_sw;\n\tint irq_hw;\n\tstruct ab8500_adc_cal_data cal_data[AB8500_CAL_NR];\n};\n\nstatic struct ab8500_gpadc_chan_info *\nab8500_gpadc_get_channel(struct ab8500_gpadc *gpadc, u8 chan)\n{\n\tstruct ab8500_gpadc_chan_info *ch;\n\tint i;\n\n\tfor (i = 0; i < gpadc->nchans; i++) {\n\t\tch = &gpadc->chans[i];\n\t\tif (ch->id == chan)\n\t\t\tbreak;\n\t}\n\tif (i == gpadc->nchans)\n\t\treturn NULL;\n\n\treturn ch;\n}\n\n \nstatic int ab8500_gpadc_ad_to_voltage(struct ab8500_gpadc *gpadc,\n\t\t\t\t      enum ab8500_gpadc_channel ch,\n\t\t\t\t      int ad_value)\n{\n\tint res;\n\n\tswitch (ch) {\n\tcase AB8500_GPADC_CHAN_MAIN_CHARGER:\n\t\t \n\t\tif (!gpadc->cal_data[AB8500_CAL_VMAIN].gain) {\n\t\t\tres = AB8500_ADC_CH_CHG_V_MIN + (AB8500_ADC_CH_CHG_V_MAX -\n\t\t\t\tAB8500_ADC_CH_CHG_V_MIN) * ad_value /\n\t\t\t\tAB8500_ADC_RESOLUTION;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tres = (int) (ad_value * gpadc->cal_data[AB8500_CAL_VMAIN].gain +\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].offset) / AB8500_GPADC_CALIB_SCALE;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_BAT_CTRL:\n\tcase AB8500_GPADC_CHAN_BAT_TEMP:\n\tcase AB8500_GPADC_CHAN_ACC_DET_1:\n\tcase AB8500_GPADC_CHAN_ADC_AUX_1:\n\tcase AB8500_GPADC_CHAN_ADC_AUX_2:\n\tcase AB8500_GPADC_CHAN_XTAL_TEMP:\n\t\t \n\t\tif (!gpadc->cal_data[AB8500_CAL_BTEMP].gain) {\n\t\t\tres = AB8500_ADC_CH_BTEMP_MIN + (AB8500_ADC_CH_BTEMP_MAX -\n\t\t\t\tAB8500_ADC_CH_BTEMP_MIN) * ad_value /\n\t\t\t\tAB8500_ADC_RESOLUTION;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tres = (int) (ad_value * gpadc->cal_data[AB8500_CAL_BTEMP].gain +\n\t\t\tgpadc->cal_data[AB8500_CAL_BTEMP].offset) / AB8500_GPADC_CALIB_SCALE;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_VBAT_A:\n\tcase AB8500_GPADC_CHAN_VBAT_TRUE_MEAS:\n\t\t \n\t\tif (!gpadc->cal_data[AB8500_CAL_VBAT].gain) {\n\t\t\tres = AB8500_ADC_CH_VBAT_MIN + (AB8500_ADC_CH_VBAT_MAX -\n\t\t\t\tAB8500_ADC_CH_VBAT_MIN) * ad_value /\n\t\t\t\tAB8500_ADC_RESOLUTION;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tres = (int) (ad_value * gpadc->cal_data[AB8500_CAL_VBAT].gain +\n\t\t\tgpadc->cal_data[AB8500_CAL_VBAT].offset) / AB8500_GPADC_CALIB_SCALE;\n\t\tbreak;\n\n\tcase AB8505_GPADC_CHAN_DIE_TEMP:\n\t\tres = AB8500_ADC_CH_DIETEMP_MIN +\n\t\t\t(AB8500_ADC_CH_DIETEMP_MAX - AB8500_ADC_CH_DIETEMP_MIN) * ad_value /\n\t\t\tAB8500_ADC_RESOLUTION;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_ACC_DET_2:\n\t\tres = AB8500_ADC_CH_ACCDET2_MIN +\n\t\t\t(AB8500_ADC_CH_ACCDET2_MAX - AB8500_ADC_CH_ACCDET2_MIN) * ad_value /\n\t\t\tAB8500_ADC_RESOLUTION;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_VBUS:\n\t\tres = AB8500_ADC_CH_CHG_V_MIN +\n\t\t\t(AB8500_ADC_CH_CHG_V_MAX - AB8500_ADC_CH_CHG_V_MIN) * ad_value /\n\t\t\tAB8500_ADC_RESOLUTION;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_MAIN_CHARGER_CURRENT:\n\tcase AB8500_GPADC_CHAN_USB_CHARGER_CURRENT:\n\t\tres = AB8500_ADC_CH_CHG_I_MIN +\n\t\t\t(AB8500_ADC_CH_CHG_I_MAX - AB8500_ADC_CH_CHG_I_MIN) * ad_value /\n\t\t\tAB8500_ADC_RESOLUTION;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_BACKUP_BAT:\n\t\tres = AB8500_ADC_CH_BKBAT_MIN +\n\t\t\t(AB8500_ADC_CH_BKBAT_MAX - AB8500_ADC_CH_BKBAT_MIN) * ad_value /\n\t\t\tAB8500_ADC_RESOLUTION;\n\t\tbreak;\n\n\tcase AB8500_GPADC_CHAN_IBAT_VIRTUAL:\n\t\t \n\t\tif (!gpadc->cal_data[AB8500_CAL_IBAT].gain) {\n\t\t\tres = AB8500_ADC_CH_IBAT_MIN + (AB8500_ADC_CH_IBAT_MAX -\n\t\t\t\tAB8500_ADC_CH_IBAT_MIN) * ad_value /\n\t\t\t\tAB8500_ADC_RESOLUTION;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tres = (int) (ad_value * gpadc->cal_data[AB8500_CAL_IBAT].gain +\n\t\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].offset)\n\t\t\t\t>> AB8500_GPADC_CALIB_SHIFT_IBAT;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(gpadc->dev,\n\t\t\t\"unknown channel ID: %d, not possible to convert\\n\",\n\t\t\tch);\n\t\tres = -EINVAL;\n\t\tbreak;\n\n\t}\n\n\treturn res;\n}\n\nstatic int ab8500_gpadc_read(struct ab8500_gpadc *gpadc,\n\t\t\t     const struct ab8500_gpadc_chan_info *ch,\n\t\t\t     int *ibat)\n{\n\tint ret;\n\tint looplimit = 0;\n\tunsigned long completion_timeout;\n\tu8 val;\n\tu8 low_data, high_data, low_data2, high_data2;\n\tu8 ctrl1;\n\tu8 ctrl23;\n\tunsigned int delay_min = 0;\n\tunsigned int delay_max = 0;\n\tu8 data_low_addr, data_high_addr;\n\n\tif (!gpadc)\n\t\treturn -ENODEV;\n\n\t \n\tif ((gpadc->irq_sw <= 0) && !ch->hardware_control)\n\t\treturn -ENOTSUPP;\n\tif ((gpadc->irq_hw <= 0) && ch->hardware_control)\n\t\treturn -ENOTSUPP;\n\n\t \n\tpm_runtime_get_sync(gpadc->dev);\n\n\t \n\tdo {\n\t\tret = abx500_get_register_interruptible(gpadc->dev,\n\t\t\tAB8500_GPADC, AB8500_GPADC_STAT_REG, &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!(val & AB8500_GPADC_STAT_BUSY))\n\t\t\tbreak;\n\t\tmsleep(20);\n\t} while (++looplimit < 10);\n\tif (looplimit >= 10 && (val & AB8500_GPADC_STAT_BUSY)) {\n\t\tdev_err(gpadc->dev, \"gpadc_conversion: GPADC busy\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tctrl1 = AB8500_GPADC_CTRL1_ENABLE;\n\n\t \n\tswitch (ch->avg_sample) {\n\tcase 1:\n\t\tctrl23 = ch->id | AB8500_GPADC_CTRL2_AVG_1;\n\t\tbreak;\n\tcase 4:\n\t\tctrl23 = ch->id | AB8500_GPADC_CTRL2_AVG_4;\n\t\tbreak;\n\tcase 8:\n\t\tctrl23 = ch->id | AB8500_GPADC_CTRL2_AVG_8;\n\t\tbreak;\n\tdefault:\n\t\tctrl23 = ch->id | AB8500_GPADC_CTRL2_AVG_16;\n\t\tbreak;\n\t}\n\n\tif (ch->hardware_control) {\n\t\tret = abx500_set_register_interruptible(gpadc->dev,\n\t\t\t\tAB8500_GPADC, AB8500_GPADC_CTRL3_REG, ctrl23);\n\t\tctrl1 |= AB8500_GPADC_CTRL1_TRIG_ENA;\n\t\tif (ch->falling_edge)\n\t\t\tctrl1 |= AB8500_GPADC_CTRL1_TRIG_EDGE;\n\t} else {\n\t\tret = abx500_set_register_interruptible(gpadc->dev,\n\t\t\t\tAB8500_GPADC, AB8500_GPADC_CTRL2_REG, ctrl23);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev,\n\t\t\t\"gpadc_conversion: set avg samples failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (ch->id) {\n\tcase AB8500_GPADC_CHAN_MAIN_CHARGER_CURRENT:\n\tcase AB8500_GPADC_CHAN_USB_CHARGER_CURRENT:\n\t\tctrl1 |= AB8500_GPADC_CTRL1_BUF_ENA |\n\t\t\tAB8500_GPADC_CTRL1_ICHAR_ENA;\n\t\tbreak;\n\tcase AB8500_GPADC_CHAN_BAT_TEMP:\n\t\tif (!is_ab8500_2p0_or_earlier(gpadc->ab8500)) {\n\t\t\tctrl1 |= AB8500_GPADC_CTRL1_BUF_ENA |\n\t\t\t\tAB8500_GPADC_CTRL1_BTEMP_PULL_UP;\n\t\t\t \n\t\t\tdelay_min = 1000;  \n\t\t\tdelay_max = 10000;  \n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tctrl1 |= AB8500_GPADC_CTRL1_BUF_ENA;\n\t\tbreak;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(gpadc->dev,\n\t\tAB8500_GPADC, AB8500_GPADC_CTRL1_REG, ctrl1);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev,\n\t\t\t\"gpadc_conversion: set Control register failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (delay_min != 0)\n\t\tusleep_range(delay_min, delay_max);\n\n\tif (ch->hardware_control) {\n\t\t \n\t\tret = abx500_set_register_interruptible(gpadc->dev,\n\t\t\tAB8500_GPADC, AB8500_GPADC_AUTO_TIMER_REG,\n\t\t\tch->trig_timer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\"gpadc_conversion: trig timer failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tcompletion_timeout = 2 * HZ;\n\t\tdata_low_addr = AB8500_GPADC_AUTODATAL_REG;\n\t\tdata_high_addr = AB8500_GPADC_AUTODATAH_REG;\n\t} else {\n\t\t \n\t\tret = abx500_mask_and_set_register_interruptible(gpadc->dev,\n\t\t\tAB8500_GPADC, AB8500_GPADC_CTRL1_REG,\n\t\t\tAB8500_GPADC_CTRL1_START_SW_CONV,\n\t\t\tAB8500_GPADC_CTRL1_START_SW_CONV);\n\t\tif (ret < 0) {\n\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\"gpadc_conversion: start s/w conv failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tcompletion_timeout = msecs_to_jiffies(AB8500_GPADC_CONVERSION_TIME);\n\t\tdata_low_addr = AB8500_GPADC_MANDATAL_REG;\n\t\tdata_high_addr = AB8500_GPADC_MANDATAH_REG;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&gpadc->complete,\n\t\t\tcompletion_timeout)) {\n\t\tdev_err(gpadc->dev,\n\t\t\t\"timeout didn't receive GPADC conv interrupt\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_get_register_interruptible(gpadc->dev,\n\t\t\tAB8500_GPADC, data_low_addr, &low_data);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev,\n\t\t\t\"gpadc_conversion: read low data failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = abx500_get_register_interruptible(gpadc->dev,\n\t\tAB8500_GPADC, data_high_addr, &high_data);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev,\n\t\t\t\"gpadc_conversion: read high data failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif ((ch->id == AB8500_GPADC_CHAN_BAT_CTRL_AND_IBAT) ||\n\t    (ch->id == AB8500_GPADC_CHAN_VBAT_MEAS_AND_IBAT) ||\n\t    (ch->id == AB8500_GPADC_CHAN_VBAT_TRUE_MEAS_AND_IBAT) ||\n\t    (ch->id == AB8500_GPADC_CHAN_BAT_TEMP_AND_IBAT)) {\n\n\t\tif (ch->hardware_control) {\n\t\t\t \n\t\t\tret = -ENOTSUPP;\n\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\"gpadc_conversion: only SW double conversion supported\\n\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tret = abx500_get_register_interruptible(gpadc->dev,\n\t\t\t\tAB8500_GPADC, AB8540_GPADC_MANDATA2L_REG,\n\t\t\t\t&low_data2);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\t\"gpadc_conversion: read sw low data 2 failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = abx500_get_register_interruptible(gpadc->dev,\n\t\t\t\tAB8500_GPADC, AB8540_GPADC_MANDATA2H_REG,\n\t\t\t\t&high_data2);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\t\"gpadc_conversion: read sw high data 2 failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ibat != NULL) {\n\t\t\t\t*ibat = (high_data2 << 8) | low_data2;\n\t\t\t} else {\n\t\t\t\tdev_warn(gpadc->dev,\n\t\t\t\t\t\"gpadc_conversion: ibat not stored\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\n\t\tAB8500_GPADC_CTRL1_REG, AB8500_GPADC_CTRL1_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev, \"gpadc_conversion: disable gpadc failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tpm_runtime_mark_last_busy(gpadc->dev);\n\tpm_runtime_put_autosuspend(gpadc->dev);\n\n\treturn (high_data << 8) | low_data;\n\nout:\n\t \n\t(void) abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\n\t\tAB8500_GPADC_CTRL1_REG, AB8500_GPADC_CTRL1_DISABLE);\n\tpm_runtime_put(gpadc->dev);\n\tdev_err(gpadc->dev,\n\t\t\"gpadc_conversion: Failed to AD convert channel %d\\n\", ch->id);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t ab8500_bm_gpadcconvend_handler(int irq, void *data)\n{\n\tstruct ab8500_gpadc *gpadc = data;\n\n\tcomplete(&gpadc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int otp_cal_regs[] = {\n\tAB8500_GPADC_CAL_1,\n\tAB8500_GPADC_CAL_2,\n\tAB8500_GPADC_CAL_3,\n\tAB8500_GPADC_CAL_4,\n\tAB8500_GPADC_CAL_5,\n\tAB8500_GPADC_CAL_6,\n\tAB8500_GPADC_CAL_7,\n};\n\nstatic int otp4_cal_regs[] = {\n\tAB8540_GPADC_OTP4_REG_7,\n\tAB8540_GPADC_OTP4_REG_6,\n\tAB8540_GPADC_OTP4_REG_5,\n};\n\nstatic void ab8500_gpadc_read_calibration_data(struct ab8500_gpadc *gpadc)\n{\n\tint i;\n\tint ret[ARRAY_SIZE(otp_cal_regs)];\n\tu8 gpadc_cal[ARRAY_SIZE(otp_cal_regs)];\n\tint ret_otp4[ARRAY_SIZE(otp4_cal_regs)];\n\tu8 gpadc_otp4[ARRAY_SIZE(otp4_cal_regs)];\n\tint vmain_high, vmain_low;\n\tint btemp_high, btemp_low;\n\tint vbat_high, vbat_low;\n\tint ibat_high, ibat_low;\n\ts64 V_gain, V_offset, V2A_gain, V2A_offset;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(otp_cal_regs); i++) {\n\t\tret[i] = abx500_get_register_interruptible(gpadc->dev,\n\t\t\tAB8500_OTP_EMUL, otp_cal_regs[i],  &gpadc_cal[i]);\n\t\tif (ret[i] < 0) {\n\t\t\t \n\t\t\tdev_err(gpadc->dev, \"%s: read otp reg 0x%02x failed\\n\",\n\t\t\t\t__func__, otp_cal_regs[i]);\n\t\t} else {\n\t\t\t \n\t\t\tadd_device_randomness(&ret[i], sizeof(ret[i]));\n\t\t}\n\t}\n\n\t \n\n\tif (is_ab8540(gpadc->ab8500)) {\n\t\t \n\t\tif (!(ret[1] < 0 || ret[2] < 0)) {\n\t\t\tvmain_high = (((gpadc_cal[1] & 0xFF) << 2) |\n\t\t\t\t((gpadc_cal[2] & 0xC0) >> 6));\n\t\t\tvmain_low = ((gpadc_cal[2] & 0x3E) >> 1);\n\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].otp_calib_hi =\n\t\t\t\t(u16)vmain_high;\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].otp_calib_lo =\n\t\t\t\t(u16)vmain_low;\n\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].gain = AB8500_GPADC_CALIB_SCALE *\n\t\t\t\t(19500 - 315) / (vmain_high - vmain_low);\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].offset = AB8500_GPADC_CALIB_SCALE *\n\t\t\t\t19500 - (AB8500_GPADC_CALIB_SCALE * (19500 - 315) /\n\t\t\t\t(vmain_high - vmain_low)) * vmain_high;\n\t\t} else {\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].gain = 0;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(otp4_cal_regs); i++) {\n\t\t\tret_otp4[i] = abx500_get_register_interruptible(\n\t\t\t\t\tgpadc->dev, AB8500_OTP_EMUL,\n\t\t\t\t\totp4_cal_regs[i],  &gpadc_otp4[i]);\n\t\t\tif (ret_otp4[i] < 0)\n\t\t\t\tdev_err(gpadc->dev,\n\t\t\t\t\t\"%s: read otp4 reg 0x%02x failed\\n\",\n\t\t\t\t\t__func__, otp4_cal_regs[i]);\n\t\t}\n\n\t\t \n\t\tif (!(ret_otp4[0] < 0 || ret_otp4[1] < 0 || ret_otp4[2] < 0)) {\n\t\t\tibat_high = (((gpadc_otp4[0] & 0x07) << 7) |\n\t\t\t\t((gpadc_otp4[1] & 0xFE) >> 1));\n\t\t\tibat_low = (((gpadc_otp4[1] & 0x01) << 5) |\n\t\t\t\t((gpadc_otp4[2] & 0xF8) >> 3));\n\n\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].otp_calib_hi =\n\t\t\t\t(u16)ibat_high;\n\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].otp_calib_lo =\n\t\t\t\t(u16)ibat_low;\n\n\t\t\tV_gain = ((AB8500_GPADC_IBAT_VDROP_H - AB8500_GPADC_IBAT_VDROP_L)\n\t\t\t\t<< AB8500_GPADC_CALIB_SHIFT_IBAT) / (ibat_high - ibat_low);\n\n\t\t\tV_offset = (AB8500_GPADC_IBAT_VDROP_H << AB8500_GPADC_CALIB_SHIFT_IBAT) -\n\t\t\t\t(((AB8500_GPADC_IBAT_VDROP_H - AB8500_GPADC_IBAT_VDROP_L) <<\n\t\t\t\tAB8500_GPADC_CALIB_SHIFT_IBAT) / (ibat_high - ibat_low))\n\t\t\t\t* ibat_high;\n\t\t\t \n\t\t\tV2A_gain = (AB8500_ADC_CH_IBAT_MAX - AB8500_ADC_CH_IBAT_MIN)/\n\t\t\t\t(AB8500_ADC_CH_IBAT_MAX_V - AB8500_ADC_CH_IBAT_MIN_V);\n\t\t\tV2A_offset = ((AB8500_ADC_CH_IBAT_MAX_V * AB8500_ADC_CH_IBAT_MIN -\n\t\t\t\tAB8500_ADC_CH_IBAT_MAX * AB8500_ADC_CH_IBAT_MIN_V)\n\t\t\t\t<< AB8500_GPADC_CALIB_SHIFT_IBAT)\n\t\t\t\t/ (AB8500_ADC_CH_IBAT_MAX_V - AB8500_ADC_CH_IBAT_MIN_V);\n\n\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].gain =\n\t\t\t\tV_gain * V2A_gain;\n\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].offset =\n\t\t\t\tV_offset * V2A_gain + V2A_offset;\n\t\t} else {\n\t\t\tgpadc->cal_data[AB8500_CAL_IBAT].gain = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(ret[0] < 0 || ret[1] < 0 || ret[2] < 0)) {\n\t\t\tvmain_high = (((gpadc_cal[0] & 0x03) << 8) |\n\t\t\t\t((gpadc_cal[1] & 0x3F) << 2) |\n\t\t\t\t((gpadc_cal[2] & 0xC0) >> 6));\n\t\t\tvmain_low = ((gpadc_cal[2] & 0x3E) >> 1);\n\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].otp_calib_hi =\n\t\t\t\t(u16)vmain_high;\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].otp_calib_lo =\n\t\t\t\t(u16)vmain_low;\n\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].gain = AB8500_GPADC_CALIB_SCALE *\n\t\t\t\t(19500 - 315) / (vmain_high - vmain_low);\n\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].offset = AB8500_GPADC_CALIB_SCALE *\n\t\t\t\t19500 - (AB8500_GPADC_CALIB_SCALE * (19500 - 315) /\n\t\t\t\t(vmain_high - vmain_low)) * vmain_high;\n\t\t} else {\n\t\t\tgpadc->cal_data[AB8500_CAL_VMAIN].gain = 0;\n\t\t}\n\t}\n\n\t \n\tif (!(ret[2] < 0 || ret[3] < 0 || ret[4] < 0)) {\n\t\tbtemp_high = (((gpadc_cal[2] & 0x01) << 9) |\n\t\t\t(gpadc_cal[3] << 1) | ((gpadc_cal[4] & 0x80) >> 7));\n\t\tbtemp_low = ((gpadc_cal[4] & 0x7C) >> 2);\n\n\t\tgpadc->cal_data[AB8500_CAL_BTEMP].otp_calib_hi = (u16)btemp_high;\n\t\tgpadc->cal_data[AB8500_CAL_BTEMP].otp_calib_lo = (u16)btemp_low;\n\n\t\tgpadc->cal_data[AB8500_CAL_BTEMP].gain =\n\t\t\tAB8500_GPADC_CALIB_SCALE * (1300 - 21) / (btemp_high - btemp_low);\n\t\tgpadc->cal_data[AB8500_CAL_BTEMP].offset = AB8500_GPADC_CALIB_SCALE * 1300 -\n\t\t\t(AB8500_GPADC_CALIB_SCALE * (1300 - 21) / (btemp_high - btemp_low))\n\t\t\t* btemp_high;\n\t} else {\n\t\tgpadc->cal_data[AB8500_CAL_BTEMP].gain = 0;\n\t}\n\n\t \n\tif (!(ret[4] < 0 || ret[5] < 0 || ret[6] < 0)) {\n\t\tvbat_high = (((gpadc_cal[4] & 0x03) << 8) | gpadc_cal[5]);\n\t\tvbat_low = ((gpadc_cal[6] & 0xFC) >> 2);\n\n\t\tgpadc->cal_data[AB8500_CAL_VBAT].otp_calib_hi = (u16)vbat_high;\n\t\tgpadc->cal_data[AB8500_CAL_VBAT].otp_calib_lo = (u16)vbat_low;\n\n\t\tgpadc->cal_data[AB8500_CAL_VBAT].gain = AB8500_GPADC_CALIB_SCALE *\n\t\t\t(4700 - 2380) /\t(vbat_high - vbat_low);\n\t\tgpadc->cal_data[AB8500_CAL_VBAT].offset = AB8500_GPADC_CALIB_SCALE * 4700 -\n\t\t\t(AB8500_GPADC_CALIB_SCALE * (4700 - 2380) /\n\t\t\t(vbat_high - vbat_low)) * vbat_high;\n\t} else {\n\t\tgpadc->cal_data[AB8500_CAL_VBAT].gain = 0;\n\t}\n}\n\nstatic int ab8500_gpadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct ab8500_gpadc *gpadc = iio_priv(indio_dev);\n\tconst struct ab8500_gpadc_chan_info *ch;\n\tint raw_val;\n\tint processed;\n\n\tch = ab8500_gpadc_get_channel(gpadc, chan->address);\n\tif (!ch) {\n\t\tdev_err(gpadc->dev, \"no such channel %lu\\n\",\n\t\t\tchan->address);\n\t\treturn -EINVAL;\n\t}\n\n\traw_val = ab8500_gpadc_read(gpadc, ch, NULL);\n\tif (raw_val < 0)\n\t\treturn raw_val;\n\n\tif (mask == IIO_CHAN_INFO_RAW) {\n\t\t*val = raw_val;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\tif (mask == IIO_CHAN_INFO_PROCESSED) {\n\t\tprocessed = ab8500_gpadc_ad_to_voltage(gpadc, ch->id, raw_val);\n\t\tif (processed < 0)\n\t\t\treturn processed;\n\n\t\t \n\t\t*val = processed;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ab8500_gpadc_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t\t     const struct fwnode_reference_args *iiospec)\n{\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tif (indio_dev->channels[i].channel == iiospec->args[0])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ab8500_gpadc_info = {\n\t.fwnode_xlate = ab8500_gpadc_fwnode_xlate,\n\t.read_raw = ab8500_gpadc_read_raw,\n};\n\nstatic int ab8500_gpadc_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct ab8500_gpadc *gpadc = iio_priv(indio_dev);\n\n\tregulator_disable(gpadc->vddadc);\n\n\treturn 0;\n}\n\nstatic int ab8500_gpadc_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct ab8500_gpadc *gpadc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(gpadc->vddadc);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to enable vddadc: %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_gpadc_parse_channel(struct device *dev,\n\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t      struct ab8500_gpadc_chan_info *ch,\n\t\t\t\t      struct iio_chan_spec *iio_chan)\n{\n\tconst char *name = fwnode_get_name(fwnode);\n\tu32 chan;\n\tint ret;\n\n\tret = fwnode_property_read_u32(fwnode, \"reg\", &chan);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid channel number %s\\n\", name);\n\t\treturn ret;\n\t}\n\tif (chan > AB8500_GPADC_CHAN_BAT_TEMP_AND_IBAT) {\n\t\tdev_err(dev, \"%s channel number out of range %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\n\tiio_chan->channel = chan;\n\tiio_chan->datasheet_name = name;\n\tiio_chan->indexed = 1;\n\tiio_chan->address = chan;\n\tiio_chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_PROCESSED);\n\t \n\tif ((chan == AB8500_GPADC_CHAN_MAIN_CHARGER_CURRENT) ||\n\t    (chan == AB8500_GPADC_CHAN_USB_CHARGER_CURRENT))\n\t\tiio_chan->type = IIO_CURRENT;\n\telse\n\t\tiio_chan->type = IIO_VOLTAGE;\n\n\tch->id = chan;\n\n\t \n\tch->avg_sample = 16;\n\tch->hardware_control = false;\n\tch->falling_edge = false;\n\tch->trig_timer = 0;\n\n\treturn 0;\n}\n\n \nstatic int ab8500_gpadc_parse_channels(struct ab8500_gpadc *gpadc,\n\t\t\t\t       struct iio_chan_spec **chans_parsed,\n\t\t\t\t       unsigned int *nchans_parsed)\n{\n\tstruct fwnode_handle *child;\n\tstruct ab8500_gpadc_chan_info *ch;\n\tstruct iio_chan_spec *iio_chans;\n\tunsigned int nchans;\n\tint i;\n\n\tnchans = device_get_child_node_count(gpadc->dev);\n\tif (!nchans) {\n\t\tdev_err(gpadc->dev, \"no channel children\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_info(gpadc->dev, \"found %d ADC channels\\n\", nchans);\n\n\tiio_chans = devm_kcalloc(gpadc->dev, nchans,\n\t\t\t\t sizeof(*iio_chans), GFP_KERNEL);\n\tif (!iio_chans)\n\t\treturn -ENOMEM;\n\n\tgpadc->chans = devm_kcalloc(gpadc->dev, nchans,\n\t\t\t\t    sizeof(*gpadc->chans), GFP_KERNEL);\n\tif (!gpadc->chans)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(gpadc->dev, child) {\n\t\tstruct iio_chan_spec *iio_chan;\n\t\tint ret;\n\n\t\tch = &gpadc->chans[i];\n\t\tiio_chan = &iio_chans[i];\n\n\t\tret = ab8500_gpadc_parse_channel(gpadc->dev, child, ch,\n\t\t\t\t\t\t iio_chan);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\tgpadc->nchans = nchans;\n\t*chans_parsed = iio_chans;\n\t*nchans_parsed = nchans;\n\n\treturn 0;\n}\n\nstatic int ab8500_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct ab8500_gpadc *gpadc;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_chan_spec *iio_chans;\n\tunsigned int n_iio_chans;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*gpadc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tgpadc = iio_priv(indio_dev);\n\n\tgpadc->dev = dev;\n\tgpadc->ab8500 = dev_get_drvdata(dev->parent);\n\n\tret = ab8500_gpadc_parse_channels(gpadc, &iio_chans, &n_iio_chans);\n\tif (ret)\n\t\treturn ret;\n\n\tgpadc->irq_sw = platform_get_irq_byname(pdev, \"SW_CONV_END\");\n\tif (gpadc->irq_sw < 0)\n\t\treturn gpadc->irq_sw;\n\n\tif (is_ab8500(gpadc->ab8500)) {\n\t\tgpadc->irq_hw = platform_get_irq_byname(pdev, \"HW_CONV_END\");\n\t\tif (gpadc->irq_hw < 0)\n\t\t\treturn gpadc->irq_hw;\n\t} else {\n\t\tgpadc->irq_hw = 0;\n\t}\n\n\t \n\tinit_completion(&gpadc->complete);\n\n\t \n\tret = devm_request_threaded_irq(dev, gpadc->irq_sw, NULL,\n\t\tab8500_bm_gpadcconvend_handler,\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\"ab8500-gpadc-sw\", gpadc);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"failed to request sw conversion irq %d\\n\",\n\t\t\tgpadc->irq_sw);\n\t\treturn ret;\n\t}\n\n\tif (gpadc->irq_hw) {\n\t\tret = devm_request_threaded_irq(dev, gpadc->irq_hw, NULL,\n\t\t\tab8500_bm_gpadcconvend_handler,\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\"ab8500-gpadc-hw\", gpadc);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to request hw conversion irq: %d\\n\",\n\t\t\t\tgpadc->irq_hw);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tgpadc->vddadc = devm_regulator_get(dev, \"vddadc\");\n\tif (IS_ERR(gpadc->vddadc))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpadc->vddadc),\n\t\t\t\t     \"failed to get vddadc\\n\");\n\n\tret = regulator_enable(gpadc->vddadc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable vddadc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, AB8500_GPADC_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\n\tab8500_gpadc_read_calibration_data(gpadc);\n\n\tpm_runtime_put(dev);\n\n\tindio_dev->name = \"ab8500-gpadc\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ab8500_gpadc_info;\n\tindio_dev->channels = iio_chans;\n\tindio_dev->num_channels = n_iio_chans;\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\tgoto out_dis_pm;\n\n\treturn 0;\n\nout_dis_pm:\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tregulator_disable(gpadc->vddadc);\n\n\treturn ret;\n}\n\nstatic int ab8500_gpadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct ab8500_gpadc *gpadc = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(gpadc->dev);\n\tpm_runtime_put_noidle(gpadc->dev);\n\tpm_runtime_disable(gpadc->dev);\n\tregulator_disable(gpadc->vddadc);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ab8500_gpadc_pm_ops,\n\t\t\t\t ab8500_gpadc_runtime_suspend,\n\t\t\t\t ab8500_gpadc_runtime_resume, NULL);\n\nstatic struct platform_driver ab8500_gpadc_driver = {\n\t.probe = ab8500_gpadc_probe,\n\t.remove = ab8500_gpadc_remove,\n\t.driver = {\n\t\t.name = \"ab8500-gpadc\",\n\t\t.pm = pm_ptr(&ab8500_gpadc_pm_ops),\n\t},\n};\nbuiltin_platform_driver(ab8500_gpadc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}