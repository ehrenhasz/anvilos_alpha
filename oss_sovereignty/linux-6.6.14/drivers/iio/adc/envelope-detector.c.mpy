{
  "module_name": "envelope-detector.c",
  "hash_id": "c3bd29efb2a15e0e53ed73f1a15c8fc6c70258dd8e89c9cad847b5bcbc5bb308",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/envelope-detector.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstruct envelope {\n\tspinlock_t comp_lock;  \n\tint comp;\n\n\tstruct mutex read_lock;  \n\n\tint comp_irq;\n\tu32 comp_irq_trigger;\n\tu32 comp_irq_trigger_inv;\n\n\tstruct iio_channel *dac;\n\tstruct delayed_work comp_timeout;\n\n\tunsigned int comp_interval;\n\tbool invert;\n\tu32 dac_max;\n\n\tint high;\n\tint level;\n\tint low;\n\n\tstruct completion done;\n};\n\n \nstatic int envelope_detector_comp_latch(struct envelope *env)\n{\n\tint comp;\n\n\tspin_lock_irq(&env->comp_lock);\n\tcomp = env->comp;\n\tenv->comp = 0;\n\tspin_unlock_irq(&env->comp_lock);\n\n\tif (!comp)\n\t\treturn 0;\n\n\t \n\tenable_irq(env->comp_irq);\n\n\t \n\tsynchronize_irq(env->comp_irq);\n\n\t \n\tspin_lock_irq(&env->comp_lock);\n\tcomp = env->comp;\n\tenv->comp = 0;\n\tspin_unlock_irq(&env->comp_lock);\n\n\tif (comp)\n\t\tenable_irq(env->comp_irq);\n\n\treturn 1;\n}\n\nstatic irqreturn_t envelope_detector_comp_isr(int irq, void *ctx)\n{\n\tstruct envelope *env = ctx;\n\n\tspin_lock(&env->comp_lock);\n\tenv->comp = 1;\n\tdisable_irq_nosync(env->comp_irq);\n\tspin_unlock(&env->comp_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void envelope_detector_setup_compare(struct envelope *env)\n{\n\tint ret;\n\n\t \n\tenv->level = (env->high + env->low + !env->invert) / 2;\n\n\tif (env->high == env->low + 1) {\n\t\tcomplete(&env->done);\n\t\treturn;\n\t}\n\n\t \n\tret = iio_write_channel_raw(env->dac, env->invert ? 0 : env->dac_max);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tenvelope_detector_comp_latch(env);\n\n\t \n\tret = iio_write_channel_raw(env->dac, env->level);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tschedule_delayed_work(&env->comp_timeout,\n\t\t\t      msecs_to_jiffies(env->comp_interval));\n\treturn;\n\nerr:\n\tenv->level = ret;\n\tcomplete(&env->done);\n}\n\nstatic void envelope_detector_timeout(struct work_struct *work)\n{\n\tstruct envelope *env = container_of(work, struct envelope,\n\t\t\t\t\t    comp_timeout.work);\n\n\t \n\tif (!envelope_detector_comp_latch(env) ^ !env->invert)\n\t\tenv->low = env->level;\n\telse\n\t\tenv->high = env->level;\n\n\t \n\tenvelope_detector_setup_compare(env);\n}\n\nstatic int envelope_detector_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct envelope *env = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tmutex_lock(&env->read_lock);\n\t\tenv->high = env->dac_max + env->invert;\n\t\tenv->low = -1 + env->invert;\n\t\tenvelope_detector_setup_compare(env);\n\t\twait_for_completion(&env->done);\n\t\tif (env->level < 0) {\n\t\t\tret = env->level;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\t*val = env->invert ? env->dac_max - env->level : env->level;\n\t\tmutex_unlock(&env->read_lock);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn iio_read_channel_scale(env->dac, val, val2);\n\t}\n\n\treturn -EINVAL;\n\nerr_unlock:\n\tmutex_unlock(&env->read_lock);\n\treturn ret;\n}\n\nstatic ssize_t envelope_show_invert(struct iio_dev *indio_dev,\n\t\t\t\t    uintptr_t private,\n\t\t\t\t    struct iio_chan_spec const *ch, char *buf)\n{\n\tstruct envelope *env = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%u\\n\", env->invert);\n}\n\nstatic ssize_t envelope_store_invert(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t private,\n\t\t\t\t     struct iio_chan_spec const *ch,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct envelope *env = iio_priv(indio_dev);\n\tunsigned long invert;\n\tint ret;\n\tu32 trigger;\n\n\tret = kstrtoul(buf, 0, &invert);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (invert > 1)\n\t\treturn -EINVAL;\n\n\ttrigger = invert ? env->comp_irq_trigger_inv : env->comp_irq_trigger;\n\n\tmutex_lock(&env->read_lock);\n\tif (invert != env->invert)\n\t\tret = irq_set_irq_type(env->comp_irq, trigger);\n\tif (!ret) {\n\t\tenv->invert = invert;\n\t\tret = len;\n\t}\n\tmutex_unlock(&env->read_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t envelope_show_comp_interval(struct iio_dev *indio_dev,\n\t\t\t\t\t   uintptr_t private,\n\t\t\t\t\t   struct iio_chan_spec const *ch,\n\t\t\t\t\t   char *buf)\n{\n\tstruct envelope *env = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%u\\n\", env->comp_interval);\n}\n\nstatic ssize_t envelope_store_comp_interval(struct iio_dev *indio_dev,\n\t\t\t\t\t    uintptr_t private,\n\t\t\t\t\t    struct iio_chan_spec const *ch,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct envelope *env = iio_priv(indio_dev);\n\tunsigned long interval;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &interval);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (interval > 1000)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&env->read_lock);\n\tenv->comp_interval = interval;\n\tmutex_unlock(&env->read_lock);\n\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info envelope_detector_ext_info[] = {\n\t{ .name = \"invert\",\n\t  .read = envelope_show_invert,\n\t  .write = envelope_store_invert, },\n\t{ .name = \"compare_interval\",\n\t  .read = envelope_show_comp_interval,\n\t  .write = envelope_store_comp_interval, },\n\t{   }\n};\n\nstatic const struct iio_chan_spec envelope_detector_iio_channel = {\n\t.type = IIO_ALTVOLTAGE,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\n\t\t\t    | BIT(IIO_CHAN_INFO_SCALE),\n\t.ext_info = envelope_detector_ext_info,\n\t.indexed = 1,\n};\n\nstatic const struct iio_info envelope_detector_info = {\n\t.read_raw = &envelope_detector_read_raw,\n};\n\nstatic int envelope_detector_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct envelope *env;\n\tenum iio_chan_type type;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*env));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tenv = iio_priv(indio_dev);\n\tenv->comp_interval = 50;  \n\n\tspin_lock_init(&env->comp_lock);\n\tmutex_init(&env->read_lock);\n\tinit_completion(&env->done);\n\tINIT_DELAYED_WORK(&env->comp_timeout, envelope_detector_timeout);\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &envelope_detector_info;\n\tindio_dev->channels = &envelope_detector_iio_channel;\n\tindio_dev->num_channels = 1;\n\n\tenv->dac = devm_iio_channel_get(dev, \"dac\");\n\tif (IS_ERR(env->dac))\n\t\treturn dev_err_probe(dev, PTR_ERR(env->dac),\n\t\t\t\t     \"failed to get dac input channel\\n\");\n\n\tenv->comp_irq = platform_get_irq_byname(pdev, \"comp\");\n\tif (env->comp_irq < 0)\n\t\treturn env->comp_irq;\n\n\tret = devm_request_irq(dev, env->comp_irq, envelope_detector_comp_isr,\n\t\t\t       0, \"envelope-detector\", env);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request interrupt\\n\");\n\n\tenv->comp_irq_trigger = irq_get_trigger_type(env->comp_irq);\n\tif (env->comp_irq_trigger & IRQF_TRIGGER_RISING)\n\t\tenv->comp_irq_trigger_inv |= IRQF_TRIGGER_FALLING;\n\tif (env->comp_irq_trigger & IRQF_TRIGGER_FALLING)\n\t\tenv->comp_irq_trigger_inv |= IRQF_TRIGGER_RISING;\n\tif (env->comp_irq_trigger & IRQF_TRIGGER_HIGH)\n\t\tenv->comp_irq_trigger_inv |= IRQF_TRIGGER_LOW;\n\tif (env->comp_irq_trigger & IRQF_TRIGGER_LOW)\n\t\tenv->comp_irq_trigger_inv |= IRQF_TRIGGER_HIGH;\n\n\tret = iio_get_channel_type(env->dac, &type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (type != IIO_VOLTAGE) {\n\t\tdev_err(dev, \"dac is of the wrong type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = iio_read_max_channel_raw(env->dac, &env->dac_max);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"dac does not indicate its raw maximum value\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id envelope_detector_match[] = {\n\t{ .compatible = \"axentia,tse850-envelope-detector\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, envelope_detector_match);\n\nstatic struct platform_driver envelope_detector_driver = {\n\t.probe = envelope_detector_probe,\n\t.driver = {\n\t\t.name = \"iio-envelope-detector\",\n\t\t.of_match_table = envelope_detector_match,\n\t},\n};\nmodule_platform_driver(envelope_detector_driver);\n\nMODULE_DESCRIPTION(\"Envelope detector using a DAC and a comparator\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}