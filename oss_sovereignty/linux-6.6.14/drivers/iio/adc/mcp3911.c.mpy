{
  "module_name": "mcp3911.c",
  "hash_id": "fa878617ad4ab1e2324ef728c195c94f1a81df08774de048b74819f554d3d967",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mcp3911.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/trigger.h>\n\n#include <asm/unaligned.h>\n\n#define MCP3911_REG_CHANNEL0\t\t0x00\n#define MCP3911_REG_CHANNEL1\t\t0x03\n#define MCP3911_REG_MOD\t\t\t0x06\n#define MCP3911_REG_PHASE\t\t0x07\n#define MCP3911_REG_GAIN\t\t0x09\n#define MCP3911_GAIN_MASK(ch)\t\t(GENMASK(2, 0) << 3 * ch)\n#define MCP3911_GAIN_VAL(ch, val)      ((val << 3 * ch) & MCP3911_GAIN_MASK(ch))\n\n#define MCP3911_REG_STATUSCOM\t\t0x0a\n#define MCP3911_STATUSCOM_DRHIZ         BIT(12)\n#define MCP3911_STATUSCOM_READ\t\tGENMASK(7, 6)\n#define MCP3911_STATUSCOM_CH1_24WIDTH\tBIT(4)\n#define MCP3911_STATUSCOM_CH0_24WIDTH\tBIT(3)\n#define MCP3911_STATUSCOM_EN_OFFCAL\tBIT(2)\n#define MCP3911_STATUSCOM_EN_GAINCAL\tBIT(1)\n\n#define MCP3911_REG_CONFIG\t\t0x0c\n#define MCP3911_CONFIG_CLKEXT\t\tBIT(1)\n#define MCP3911_CONFIG_VREFEXT\t\tBIT(2)\n#define MCP3911_CONFIG_OSR\t\tGENMASK(13, 11)\n\n#define MCP3911_REG_OFFCAL_CH0\t\t0x0e\n#define MCP3911_REG_GAINCAL_CH0\t\t0x11\n#define MCP3911_REG_OFFCAL_CH1\t\t0x14\n#define MCP3911_REG_GAINCAL_CH1\t\t0x17\n#define MCP3911_REG_VREFCAL\t\t0x1a\n\n#define MCP3911_CHANNEL(x)\t\t(MCP3911_REG_CHANNEL0 + x * 3)\n#define MCP3911_OFFCAL(x)\t\t(MCP3911_REG_OFFCAL_CH0 + x * 6)\n\n \n#define MCP3911_INT_VREF_MV\t\t1200\n\n#define MCP3911_REG_READ(reg, id)\t((((reg) << 1) | ((id) << 6) | (1 << 0)) & 0xff)\n#define MCP3911_REG_WRITE(reg, id)\t((((reg) << 1) | ((id) << 6) | (0 << 0)) & 0xff)\n#define MCP3911_REG_MASK\t\tGENMASK(4, 1)\n\n#define MCP3911_NUM_CHANNELS\t\t2\n#define MCP3911_NUM_SCALES\t\t6\n\nstatic const int mcp3911_osr_table[] = { 32, 64, 128, 256, 512, 1024, 2048, 4096 };\nstatic u32 mcp3911_scale_table[MCP3911_NUM_SCALES][2];\n\nstruct mcp3911 {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tstruct regulator *vref;\n\tstruct clk *clki;\n\tu32 dev_addr;\n\tstruct iio_trigger *trig;\n\tu32 gain[MCP3911_NUM_CHANNELS];\n\tstruct {\n\t\tu32 channels[MCP3911_NUM_CHANNELS];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\n\tu8 tx_buf __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_buf[MCP3911_NUM_CHANNELS * 3];\n};\n\nstatic int mcp3911_read(struct mcp3911 *adc, u8 reg, u32 *val, u8 len)\n{\n\tint ret;\n\n\treg = MCP3911_REG_READ(reg, adc->dev_addr);\n\tret = spi_write_then_read(adc->spi, &reg, 1, val, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbe32_to_cpus(val);\n\t*val >>= ((4 - len) * 8);\n\tdev_dbg(&adc->spi->dev, \"reading 0x%x from register 0x%lx\\n\", *val,\n\t\tFIELD_GET(MCP3911_REG_MASK, reg));\n\treturn ret;\n}\n\nstatic int mcp3911_write(struct mcp3911 *adc, u8 reg, u32 val, u8 len)\n{\n\tdev_dbg(&adc->spi->dev, \"writing 0x%x to register 0x%x\\n\", val, reg);\n\n\tval <<= (3 - len) * 8;\n\tcpu_to_be32s(&val);\n\tval |= MCP3911_REG_WRITE(reg, adc->dev_addr);\n\n\treturn spi_write(adc->spi, &val, len + 1);\n}\n\nstatic int mcp3911_update(struct mcp3911 *adc, u8 reg, u32 mask,\n\t\tu32 val, u8 len)\n{\n\tu32 tmp;\n\tint ret;\n\n\tret = mcp3911_read(adc, reg, &tmp, len);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= mask;\n\tval |= tmp & ~mask;\n\treturn mcp3911_write(adc, reg, val, len);\n}\n\nstatic int mcp3911_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tlong mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t}\n}\n\nstatic int mcp3911_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*type = IIO_VAL_INT;\n\t\t*vals = mcp3911_osr_table;\n\t\t*length = ARRAY_SIZE(mcp3911_osr_table);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t*vals = (int *)mcp3911_scale_table;\n\t\t*length = ARRAY_SIZE(mcp3911_scale_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mcp3911_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mcp3911 *adc = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = mcp3911_read(adc,\n\t\t\t\t   MCP3911_CHANNEL(channel->channel), val, 3);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t*val = sign_extend32(*val, 23);\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = mcp3911_read(adc,\n\t\t\t\t   MCP3911_OFFCAL(channel->channel), val, 3);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = mcp3911_read(adc, MCP3911_REG_CONFIG, val, 2);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t*val = FIELD_GET(MCP3911_CONFIG_OSR, *val);\n\t\t*val = 32 << *val;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = mcp3911_scale_table[ilog2(adc->gain[channel->channel])][0];\n\t\t*val2 = mcp3911_scale_table[ilog2(adc->gain[channel->channel])][1];\n\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&adc->lock);\n\treturn ret;\n}\n\nstatic int mcp3911_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int val,\n\t\t\t    int val2, long mask)\n{\n\tstruct mcp3911 *adc = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (int i = 0; i < MCP3911_NUM_SCALES; i++) {\n\t\t\tif (val == mcp3911_scale_table[i][0] &&\n\t\t\t\tval2 == mcp3911_scale_table[i][1]) {\n\n\t\t\t\tadc->gain[channel->channel] = BIT(i);\n\t\t\t\tret = mcp3911_update(adc, MCP3911_REG_GAIN,\n\t\t\t\t\t\tMCP3911_GAIN_MASK(channel->channel),\n\t\t\t\t\t\tMCP3911_GAIN_VAL(channel->channel, i), 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (val2 != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = mcp3911_write(adc, MCP3911_OFFCAL(channel->channel), val,\n\t\t\t\t    3);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = mcp3911_update(adc, MCP3911_REG_STATUSCOM,\n\t\t\t\tMCP3911_STATUSCOM_EN_OFFCAL,\n\t\t\t\tMCP3911_STATUSCOM_EN_OFFCAL, 2);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tfor (int i = 0; i < ARRAY_SIZE(mcp3911_osr_table); i++) {\n\t\t\tif (val == mcp3911_osr_table[i]) {\n\t\t\t\tval = FIELD_PREP(MCP3911_CONFIG_OSR, i);\n\t\t\t\tret = mcp3911_update(adc, MCP3911_REG_CONFIG, MCP3911_CONFIG_OSR,\n\t\t\t\t\t\tval, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&adc->lock);\n\treturn ret;\n}\n\nstatic int mcp3911_calc_scale_table(struct mcp3911 *adc)\n{\n\tu32 ref = MCP3911_INT_VREF_MV;\n\tu32 div;\n\tint ret;\n\tu64 tmp;\n\n\tif (adc->vref) {\n\t\tret = regulator_get_voltage(adc->vref);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&adc->spi->dev,\n\t\t\t\t\"failed to get vref voltage: %d\\n\",\n\t\t\t       ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tref = ret / 1000;\n\t}\n\n\t \n\tfor (int i = 0; i < MCP3911_NUM_SCALES; i++) {\n\t\tdiv = 12582912 * BIT(i);\n\t\ttmp = div_s64((s64)ref * 1000000000LL, div);\n\n\t\tmcp3911_scale_table[i][0] = 0;\n\t\tmcp3911_scale_table[i][1] = tmp;\n\t}\n\n\treturn 0;\n}\n\n#define MCP3911_CHAN(idx) {\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = idx,\t\t\t\t\t\\\n\t\t.scan_index = idx,\t\t\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t\t.info_mask_shared_by_type_available =           \\\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_separate_available =\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\\\n\t\t\t.realbits = 24,\t\t\t\t\\\n\t\t\t.storagebits = 32,\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mcp3911_channels[] = {\n\tMCP3911_CHAN(0),\n\tMCP3911_CHAN(1),\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic irqreturn_t mcp3911_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mcp3911 *adc = iio_priv(indio_dev);\n\tstruct spi_transfer xfer[] = {\n\t\t{\n\t\t\t.tx_buf = &adc->tx_buf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.rx_buf = adc->rx_buf,\n\t\t\t.len = sizeof(adc->rx_buf),\n\t\t},\n\t};\n\tint scan_index;\n\tint i = 0;\n\tint ret;\n\n\tmutex_lock(&adc->lock);\n\tadc->tx_buf = MCP3911_REG_READ(MCP3911_CHANNEL(0), adc->dev_addr);\n\tret = spi_sync_transfer(adc->spi, xfer, ARRAY_SIZE(xfer));\n\tif (ret < 0) {\n\t\tdev_warn(&adc->spi->dev,\n\t\t\t\t\"failed to get conversion data\\n\");\n\t\tgoto out;\n\t}\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\tconst struct iio_chan_spec *scan_chan = &indio_dev->channels[scan_index];\n\n\t\tadc->scan.channels[i] = get_unaligned_be24(&adc->rx_buf[scan_chan->channel * 3]);\n\t\ti++;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, &adc->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tmutex_unlock(&adc->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info mcp3911_info = {\n\t.read_raw = mcp3911_read_raw,\n\t.write_raw = mcp3911_write_raw,\n\t.read_avail = mcp3911_read_avail,\n\t.write_raw_get_fmt = mcp3911_write_raw_get_fmt,\n};\n\nstatic int mcp3911_config(struct mcp3911 *adc)\n{\n\tstruct device *dev = &adc->spi->dev;\n\tu32 regval;\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"microchip,device-addr\", &adc->dev_addr);\n\n\t \n\tif (ret)\n\t\tdevice_property_read_u32(dev, \"device-addr\", &adc->dev_addr);\n\tif (adc->dev_addr > 3) {\n\t\tdev_err(&adc->spi->dev,\n\t\t\t\"invalid device address (%i). Must be in range 0-3.\\n\",\n\t\t\tadc->dev_addr);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&adc->spi->dev, \"use device address %i\\n\", adc->dev_addr);\n\n\tret = mcp3911_read(adc, MCP3911_REG_CONFIG, &regval, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tregval &= ~MCP3911_CONFIG_VREFEXT;\n\tif (adc->vref) {\n\t\tdev_dbg(&adc->spi->dev, \"use external voltage reference\\n\");\n\t\tregval |= FIELD_PREP(MCP3911_CONFIG_VREFEXT, 1);\n\t} else {\n\t\tdev_dbg(&adc->spi->dev,\n\t\t\t\"use internal voltage reference (1.2V)\\n\");\n\t\tregval |= FIELD_PREP(MCP3911_CONFIG_VREFEXT, 0);\n\t}\n\n\tregval &= ~MCP3911_CONFIG_CLKEXT;\n\tif (adc->clki) {\n\t\tdev_dbg(&adc->spi->dev, \"use external clock as clocksource\\n\");\n\t\tregval |= FIELD_PREP(MCP3911_CONFIG_CLKEXT, 1);\n\t} else {\n\t\tdev_dbg(&adc->spi->dev,\n\t\t\t\"use crystal oscillator as clocksource\\n\");\n\t\tregval |= FIELD_PREP(MCP3911_CONFIG_CLKEXT, 0);\n\t}\n\n\tret = mcp3911_write(adc, MCP3911_REG_CONFIG, regval, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mcp3911_read(adc, MCP3911_REG_STATUSCOM, &regval, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregval &= ~MCP3911_STATUSCOM_READ;\n\tregval |= FIELD_PREP(MCP3911_STATUSCOM_READ, 0x02);\n\n\treturn  mcp3911_write(adc, MCP3911_REG_STATUSCOM, regval, 2);\n}\n\nstatic void mcp3911_cleanup_regulator(void *vref)\n{\n\tregulator_disable(vref);\n}\n\nstatic int mcp3911_set_trigger_state(struct iio_trigger *trig, bool enable)\n{\n\tstruct mcp3911 *adc = iio_trigger_get_drvdata(trig);\n\n\tif (enable)\n\t\tenable_irq(adc->spi->irq);\n\telse\n\t\tdisable_irq(adc->spi->irq);\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops mcp3911_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n\t.set_trigger_state = mcp3911_set_trigger_state,\n};\n\nstatic int mcp3911_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mcp3911 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\n\tadc->vref = devm_regulator_get_optional(&adc->spi->dev, \"vref\");\n\tif (IS_ERR(adc->vref)) {\n\t\tif (PTR_ERR(adc->vref) == -ENODEV) {\n\t\t\tadc->vref = NULL;\n\t\t} else {\n\t\t\tdev_err(&adc->spi->dev,\n\t\t\t\t\"failed to get regulator (%ld)\\n\",\n\t\t\t\tPTR_ERR(adc->vref));\n\t\t\treturn PTR_ERR(adc->vref);\n\t\t}\n\n\t} else {\n\t\tret = regulator_enable(adc->vref);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev,\n\t\t\t\tmcp3911_cleanup_regulator, adc->vref);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tadc->clki = devm_clk_get_enabled(&adc->spi->dev, NULL);\n\tif (IS_ERR(adc->clki)) {\n\t\tif (PTR_ERR(adc->clki) == -ENOENT) {\n\t\t\tadc->clki = NULL;\n\t\t} else {\n\t\t\tdev_err(&adc->spi->dev,\n\t\t\t\t\"failed to get adc clk (%ld)\\n\",\n\t\t\t\tPTR_ERR(adc->clki));\n\t\t\treturn PTR_ERR(adc->clki);\n\t\t}\n\t}\n\n\tret = mcp3911_config(adc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(&adc->spi->dev, \"microchip,data-ready-hiz\"))\n\t\tret = mcp3911_update(adc, MCP3911_REG_STATUSCOM, MCP3911_STATUSCOM_DRHIZ,\n\t\t\t\t0, 2);\n\telse\n\t\tret = mcp3911_update(adc, MCP3911_REG_STATUSCOM, MCP3911_STATUSCOM_DRHIZ,\n\t\t\t\tMCP3911_STATUSCOM_DRHIZ, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mcp3911_calc_scale_table(adc);\n\tif (ret)\n\t\treturn ret;\n\n        \n\tfor (int i = 0; i < MCP3911_NUM_CHANNELS; i++) {\n\t\tadc->gain[i] = 1;\n\t\tret = mcp3911_update(adc, MCP3911_REG_GAIN,\n\t\t\t\tMCP3911_GAIN_MASK(i),\n\t\t\t\tMCP3911_GAIN_VAL(i, 0), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mcp3911_info;\n\tspi_set_drvdata(spi, indio_dev);\n\n\tindio_dev->channels = mcp3911_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mcp3911_channels);\n\n\tmutex_init(&adc->lock);\n\n\tif (spi->irq > 0) {\n\t\tadc->trig = devm_iio_trigger_alloc(&spi->dev, \"%s-dev%d\",\n\t\t\t\tindio_dev->name,\n\t\t\t\tiio_device_id(indio_dev));\n\t\tif (!adc->trig)\n\t\t\treturn -ENOMEM;\n\n\t\tadc->trig->ops = &mcp3911_trigger_ops;\n\t\tiio_trigger_set_drvdata(adc->trig, adc);\n\t\tret = devm_iio_trigger_register(&spi->dev, adc->trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = devm_request_irq(&spi->dev, spi->irq,\n\t\t\t\t&iio_trigger_generic_data_rdy_poll, IRQF_NO_AUTOEN | IRQF_ONESHOT,\n\t\t\t\tindio_dev->name, adc->trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\tNULL,\n\t\t\tmcp3911_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&adc->spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id mcp3911_dt_ids[] = {\n\t{ .compatible = \"microchip,mcp3911\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp3911_dt_ids);\n\nstatic const struct spi_device_id mcp3911_id[] = {\n\t{ \"mcp3911\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mcp3911_id);\n\nstatic struct spi_driver mcp3911_driver = {\n\t.driver = {\n\t\t.name = \"mcp3911\",\n\t\t.of_match_table = mcp3911_dt_ids,\n\t},\n\t.probe = mcp3911_probe,\n\t.id_table = mcp3911_id,\n};\nmodule_spi_driver(mcp3911_driver);\n\nMODULE_AUTHOR(\"Marcus Folkesson <marcus.folkesson@gmail.com>\");\nMODULE_AUTHOR(\"Kent Gustavsson <kent@minoris.se>\");\nMODULE_DESCRIPTION(\"Microchip Technology MCP3911\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}