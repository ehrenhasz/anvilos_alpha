{
  "module_name": "max11410.c",
  "hash_id": "6af16deef175ef65bda7ca77bccb6d240e89e6c9c13b8ceef931908be629731b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/max11410.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define MAX11410_REG_CONV_START\t0x01\n#define\t\tMAX11410_CONV_TYPE_SINGLE\t0x00\n#define\t\tMAX11410_CONV_TYPE_CONTINUOUS\t0x01\n#define MAX11410_REG_CAL_START\t0x03\n#define\t\tMAX11410_CAL_START_SELF\t\t0x00\n#define\t\tMAX11410_CAL_START_PGA\t\t0x01\n#define MAX11410_REG_GPIO_CTRL(ch)\t\t((ch) ? 0x05 : 0x04)\n#define\t\tMAX11410_GPIO_INTRB\t\t0xC1\n#define MAX11410_REG_FILTER\t0x08\n#define\t\tMAX11410_FILTER_RATE_MASK\tGENMASK(3, 0)\n#define\t\tMAX11410_FILTER_RATE_MAX\t0x0F\n#define\t\tMAX11410_FILTER_LINEF_MASK\tGENMASK(5, 4)\n#define\t\tMAX11410_FILTER_50HZ\t\tBIT(5)\n#define\t\tMAX11410_FILTER_60HZ\t\tBIT(4)\n#define MAX11410_REG_CTRL\t0x09\n#define\t\tMAX11410_CTRL_REFSEL_MASK\tGENMASK(2, 0)\n#define\t\tMAX11410_CTRL_VREFN_BUF_BIT\tBIT(3)\n#define\t\tMAX11410_CTRL_VREFP_BUF_BIT\tBIT(4)\n#define\t\tMAX11410_CTRL_FORMAT_BIT\tBIT(5)\n#define\t\tMAX11410_CTRL_UNIPOLAR_BIT\tBIT(6)\n#define MAX11410_REG_MUX_CTRL0\t0x0B\n#define MAX11410_REG_PGA\t0x0E\n#define\t\tMAX11410_PGA_GAIN_MASK\t\tGENMASK(2, 0)\n#define\t\tMAX11410_PGA_SIG_PATH_MASK\tGENMASK(5, 4)\n#define\t\tMAX11410_PGA_SIG_PATH_BUFFERED\t0x00\n#define\t\tMAX11410_PGA_SIG_PATH_BYPASS\t0x01\n#define\t\tMAX11410_PGA_SIG_PATH_PGA\t0x02\n#define MAX11410_REG_DATA0\t0x30\n#define MAX11410_REG_STATUS\t0x38\n#define\t\tMAX11410_STATUS_CONV_READY_BIT\tBIT(0)\n#define\t\tMAX11410_STATUS_CAL_READY_BIT\tBIT(2)\n\n#define MAX11410_REFSEL_AVDD_AGND\t0x03\n#define MAX11410_REFSEL_MAX\t\t0x06\n#define MAX11410_SIG_PATH_MAX\t\t0x02\n#define MAX11410_CHANNEL_INDEX_MAX\t0x0A\n#define MAX11410_AINP_AVDD\t0x0A\n#define MAX11410_AINN_GND\t0x0A\n\n#define MAX11410_CONVERSION_TIMEOUT_MS\t2000\n#define MAX11410_CALIB_TIMEOUT_MS\t2000\n\n#define MAX11410_SCALE_AVAIL_SIZE\t8\n\nenum max11410_filter {\n\tMAX11410_FILTER_FIR5060,\n\tMAX11410_FILTER_FIR50,\n\tMAX11410_FILTER_FIR60,\n\tMAX11410_FILTER_SINC4,\n};\n\nstatic const u8 max11410_sampling_len[] = {\n\t[MAX11410_FILTER_FIR5060] = 5,\n\t[MAX11410_FILTER_FIR50] = 6,\n\t[MAX11410_FILTER_FIR60] = 6,\n\t[MAX11410_FILTER_SINC4] = 10,\n};\n\nstatic const int max11410_sampling_rates[4][10][2] = {\n\t[MAX11410_FILTER_FIR5060] = {\n\t\t{ 1, 100000 },\n\t\t{ 2, 100000 },\n\t\t{ 4, 200000 },\n\t\t{ 8, 400000 },\n\t\t{ 16, 800000 }\n\t},\n\t[MAX11410_FILTER_FIR50] = {\n\t\t{ 1, 300000 },\n\t\t{ 2, 700000 },\n\t\t{ 5, 300000 },\n\t\t{ 10, 700000 },\n\t\t{ 21, 300000 },\n\t\t{ 40 }\n\t},\n\t[MAX11410_FILTER_FIR60] = {\n\t\t{ 1, 300000 },\n\t\t{ 2, 700000 },\n\t\t{ 5, 300000 },\n\t\t{ 10, 700000 },\n\t\t{ 21, 300000 },\n\t\t{ 40 }\n\t},\n\t[MAX11410_FILTER_SINC4] = {\n\t\t{ 4 },\n\t\t{ 10 },\n\t\t{ 20 },\n\t\t{ 40 },\n\t\t{ 60 },\n\t\t{ 120 },\n\t\t{ 240 },\n\t\t{ 480 },\n\t\t{ 960 },\n\t\t{ 1920 }\n\t}\n};\n\nstruct max11410_channel_config {\n\tu32 settling_time_us;\n\tu32 *scale_avail;\n\tu8 refsel;\n\tu8 sig_path;\n\tu8 gain;\n\tbool bipolar;\n\tbool buffered_vrefp;\n\tbool buffered_vrefn;\n};\n\nstruct max11410_state {\n\tstruct spi_device *spi_dev;\n\tstruct iio_trigger *trig;\n\tstruct completion completion;\n\tstruct mutex lock;  \n\tstruct regmap *regmap;\n\tstruct regulator *avdd;\n\tstruct regulator *vrefp[3];\n\tstruct regulator *vrefn[3];\n\tstruct max11410_channel_config *channels;\n\tint irq;\n\tstruct {\n\t\tu32 data __aligned(IIO_DMA_MINALIGN);\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic const struct iio_chan_spec chanspec_template = {\n\t.type = IIO_VOLTAGE,\n\t.indexed = 1,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.scan_type = {\n\t\t.sign = 's',\n\t\t.realbits = 24,\n\t\t.storagebits = 32,\n\t\t.endianness = IIO_LE,\n\t},\n};\n\nstatic unsigned int max11410_reg_size(unsigned int reg)\n{\n\t \n\treturn reg <= 0x10 ? 1 : 3;\n}\n\nstatic int max11410_write_reg(struct max11410_state *st, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\t \n\tif (max11410_reg_size(reg) != 1)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(st->regmap, reg, val);\n}\n\nstatic int max11410_read_reg(struct max11410_state *st, unsigned int reg,\n\t\t\t     int *val)\n{\n\tint ret;\n\n\tif (max11410_reg_size(reg) == 3) {\n\t\tret = regmap_bulk_read(st->regmap, reg, &st->scan.data, 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = get_unaligned_be24(&st->scan.data);\n\t\treturn 0;\n\t}\n\n\treturn regmap_read(st->regmap, reg, val);\n}\n\nstatic struct regulator *max11410_get_vrefp(struct max11410_state *st,\n\t\t\t\t\t    u8 refsel)\n{\n\trefsel = refsel % 4;\n\tif (refsel == 3)\n\t\treturn st->avdd;\n\n\treturn st->vrefp[refsel];\n}\n\nstatic struct regulator *max11410_get_vrefn(struct max11410_state *st,\n\t\t\t\t\t    u8 refsel)\n{\n\tif (refsel > 2)\n\t\treturn NULL;\n\n\treturn st->vrefn[refsel];\n}\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x39,\n};\n\nstatic ssize_t max11410_notch_en_show(struct device *dev,\n\t\t\t\t      struct device_attribute *devattr,\n\t\t\t\t      char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct max11410_state *state = iio_priv(indio_dev);\n\tstruct iio_dev_attr *iio_attr = to_iio_dev_attr(devattr);\n\tunsigned int val;\n\tint ret;\n\n\tret = max11410_read_reg(state, MAX11410_REG_FILTER, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (iio_attr->address) {\n\tcase 0:\n\t\tval = !FIELD_GET(MAX11410_FILTER_50HZ, val);\n\t\tbreak;\n\tcase 1:\n\t\tval = !FIELD_GET(MAX11410_FILTER_60HZ, val);\n\t\tbreak;\n\tcase 2:\n\t\tval = FIELD_GET(MAX11410_FILTER_LINEF_MASK, val) == 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t max11410_notch_en_store(struct device *dev,\n\t\t\t\t       struct device_attribute *devattr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct iio_dev_attr *iio_attr = to_iio_dev_attr(devattr);\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct max11410_state *state = iio_priv(indio_dev);\n\tunsigned int filter_bits;\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool(buf, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (iio_attr->address) {\n\tcase 0:\n\t\tfilter_bits = MAX11410_FILTER_50HZ;\n\t\tbreak;\n\tcase 1:\n\t\tfilter_bits = MAX11410_FILTER_60HZ;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tfilter_bits = MAX11410_FILTER_50HZ | MAX11410_FILTER_60HZ;\n\t\tenable = !enable;\n\t\tbreak;\n\t}\n\n\tif (enable)\n\t\tret = regmap_clear_bits(state->regmap, MAX11410_REG_FILTER,\n\t\t\t\t\tfilter_bits);\n\telse\n\t\tret = regmap_set_bits(state->regmap, MAX11410_REG_FILTER,\n\t\t\t\t      filter_bits);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t in_voltage_filter2_notch_center_show(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *devattr,\n\t\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct max11410_state *state = iio_priv(indio_dev);\n\tint ret, reg, rate, filter;\n\n\tret = regmap_read(state->regmap, MAX11410_REG_FILTER, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\trate = FIELD_GET(MAX11410_FILTER_RATE_MASK, reg);\n\trate = clamp_val(rate, 0,\n\t\t\t max11410_sampling_len[MAX11410_FILTER_SINC4] - 1);\n\tfilter = max11410_sampling_rates[MAX11410_FILTER_SINC4][rate][0];\n\n\treturn sysfs_emit(buf, \"%d\\n\", filter);\n}\n\nstatic IIO_CONST_ATTR(in_voltage_filter0_notch_center, \"50\");\nstatic IIO_CONST_ATTR(in_voltage_filter1_notch_center, \"60\");\nstatic IIO_DEVICE_ATTR_RO(in_voltage_filter2_notch_center, 2);\n\nstatic IIO_DEVICE_ATTR(in_voltage_filter0_notch_en, 0644,\n\t\t       max11410_notch_en_show, max11410_notch_en_store, 0);\nstatic IIO_DEVICE_ATTR(in_voltage_filter1_notch_en, 0644,\n\t\t       max11410_notch_en_show, max11410_notch_en_store, 1);\nstatic IIO_DEVICE_ATTR(in_voltage_filter2_notch_en, 0644,\n\t\t       max11410_notch_en_show, max11410_notch_en_store, 2);\n\nstatic struct attribute *max11410_attributes[] = {\n\t&iio_const_attr_in_voltage_filter0_notch_center.dev_attr.attr,\n\t&iio_const_attr_in_voltage_filter1_notch_center.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_filter2_notch_center.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_filter0_notch_en.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_filter1_notch_en.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_filter2_notch_en.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group max11410_attribute_group = {\n\t.attrs = max11410_attributes,\n};\n\nstatic int max11410_set_input_mux(struct max11410_state *st, u8 ainp, u8 ainn)\n{\n\tif (ainp > MAX11410_CHANNEL_INDEX_MAX ||\n\t    ainn > MAX11410_CHANNEL_INDEX_MAX)\n\t\treturn -EINVAL;\n\n\treturn max11410_write_reg(st, MAX11410_REG_MUX_CTRL0,\n\t\t\t\t  (ainp << 4) | ainn);\n}\n\nstatic int max11410_configure_channel(struct max11410_state *st,\n\t\t\t\t      struct iio_chan_spec const *chan)\n{\n\tstruct max11410_channel_config cfg = st->channels[chan->address];\n\tunsigned int regval;\n\tint ret;\n\n\tif (chan->differential)\n\t\tret = max11410_set_input_mux(st, chan->channel, chan->channel2);\n\telse\n\t\tret = max11410_set_input_mux(st, chan->channel,\n\t\t\t\t\t     MAX11410_AINN_GND);\n\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_PREP(MAX11410_CTRL_VREFP_BUF_BIT, cfg.buffered_vrefp) |\n\t\t FIELD_PREP(MAX11410_CTRL_VREFN_BUF_BIT, cfg.buffered_vrefn) |\n\t\t FIELD_PREP(MAX11410_CTRL_REFSEL_MASK, cfg.refsel) |\n\t\t FIELD_PREP(MAX11410_CTRL_UNIPOLAR_BIT, cfg.bipolar ? 0 : 1);\n\tret = regmap_update_bits(st->regmap, MAX11410_REG_CTRL,\n\t\t\t\t MAX11410_CTRL_REFSEL_MASK |\n\t\t\t\t MAX11410_CTRL_VREFP_BUF_BIT |\n\t\t\t\t MAX11410_CTRL_VREFN_BUF_BIT |\n\t\t\t\t MAX11410_CTRL_UNIPOLAR_BIT, regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_PREP(MAX11410_PGA_SIG_PATH_MASK, cfg.sig_path) |\n\t\t FIELD_PREP(MAX11410_PGA_GAIN_MASK, cfg.gain);\n\tret = regmap_write(st->regmap, MAX11410_REG_PGA, regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cfg.settling_time_us)\n\t\tfsleep(cfg.settling_time_us);\n\n\treturn 0;\n}\n\nstatic int max11410_sample(struct max11410_state *st, int *sample_raw,\n\t\t\t   struct iio_chan_spec const *chan)\n{\n\tint val, ret;\n\n\tret = max11410_configure_channel(st, chan);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->irq > 0)\n\t\treinit_completion(&st->completion);\n\n\t \n\tret = max11410_write_reg(st, MAX11410_REG_CONV_START,\n\t\t\t\t MAX11410_CONV_TYPE_SINGLE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->irq > 0) {\n\t\t \n\t\tret = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t\t  msecs_to_jiffies(MAX11410_CONVERSION_TIMEOUT_MS));\n\t\tif (!ret)\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\tint ret2;\n\n\t\t \n\t\tret = read_poll_timeout(max11410_read_reg, ret2,\n\t\t\t\t\tret2 || (val & MAX11410_STATUS_CONV_READY_BIT),\n\t\t\t\t\t5000, MAX11410_CONVERSION_TIMEOUT_MS * 1000,\n\t\t\t\t\ttrue, st, MAX11410_REG_STATUS, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ret2)\n\t\t\treturn ret2;\n\t}\n\n\t \n\treturn max11410_read_reg(st, MAX11410_REG_DATA0, sample_raw);\n}\n\nstatic int max11410_get_scale(struct max11410_state *state,\n\t\t\t      struct max11410_channel_config cfg)\n{\n\tstruct regulator *vrefp, *vrefn;\n\tint scale;\n\n\tvrefp = max11410_get_vrefp(state, cfg.refsel);\n\n\tscale = regulator_get_voltage(vrefp) / 1000;\n\tvrefn = max11410_get_vrefn(state, cfg.refsel);\n\tif (vrefn)\n\t\tscale -= regulator_get_voltage(vrefn) / 1000;\n\n\tif (cfg.bipolar)\n\t\tscale *= 2;\n\n\treturn scale >> cfg.gain;\n}\n\nstatic int max11410_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct max11410_state *state = iio_priv(indio_dev);\n\tstruct max11410_channel_config cfg = state->channels[chan->address];\n\tint ret, reg_val, filter, rate;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = max11410_get_scale(state, cfg);\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (cfg.bipolar)\n\t\t\t*val = -BIT(chan->scan_type.realbits - 1);\n\t\telse\n\t\t\t*val = 0;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&state->lock);\n\n\t\tret = max11410_sample(state, &reg_val, chan);\n\n\t\tmutex_unlock(&state->lock);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = reg_val;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(state->regmap, MAX11410_REG_FILTER, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfilter = FIELD_GET(MAX11410_FILTER_LINEF_MASK, reg_val);\n\t\trate = reg_val & MAX11410_FILTER_RATE_MASK;\n\t\tif (rate >= max11410_sampling_len[filter])\n\t\t\trate = max11410_sampling_len[filter] - 1;\n\n\t\t*val = max11410_sampling_rates[filter][rate][0];\n\t\t*val2 = max11410_sampling_rates[filter][rate][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int max11410_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\tint i, ret, reg_val, filter, gain;\n\tu32 *scale_avail;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale_avail = st->channels[chan->address].scale_avail;\n\t\tif (!scale_avail)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (val != 0 || val2 == 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval2 = val2 * DIV_ROUND_CLOSEST(BIT(24), 1000000);\n\t\tval2 = DIV_ROUND_CLOSEST(scale_avail[0], val2);\n\t\tgain = order_base_2(val2);\n\n\t\tst->channels[chan->address].gain = clamp_val(gain, 0, 7);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&st->lock);\n\n\t\tret = regmap_read(st->regmap, MAX11410_REG_FILTER, &reg_val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tfilter = FIELD_GET(MAX11410_FILTER_LINEF_MASK, reg_val);\n\n\t\tfor (i = 0; i < max11410_sampling_len[filter]; ++i) {\n\t\t\tif (val == max11410_sampling_rates[filter][i][0] &&\n\t\t\t    val2 == max11410_sampling_rates[filter][i][1])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == max11410_sampling_len[filter]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_write_bits(st->regmap, MAX11410_REG_FILTER,\n\t\t\t\t\tMAX11410_FILTER_RATE_MASK, i);\n\nout:\n\t\tmutex_unlock(&st->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int max11410_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long info)\n{\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\tstruct max11410_channel_config cfg;\n\tint ret, reg_val, filter;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(st->regmap, MAX11410_REG_FILTER, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfilter = FIELD_GET(MAX11410_FILTER_LINEF_MASK, reg_val);\n\n\t\t*vals = (const int *)max11410_sampling_rates[filter];\n\t\t*length = max11410_sampling_len[filter] * 2;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tcfg = st->channels[chan->address];\n\n\t\tif (!cfg.scale_avail)\n\t\t\treturn -EINVAL;\n\n\t\t*vals = cfg.scale_avail;\n\t\t*length = MAX11410_SCALE_AVAIL_SIZE * 2;\n\t\t*type = IIO_VAL_FRACTIONAL_LOG2;\n\n\t\treturn IIO_AVAIL_LIST;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info max11410_info = {\n\t.read_raw = max11410_read_raw,\n\t.write_raw = max11410_write_raw,\n\t.read_avail = max11410_read_avail,\n\t.attrs = &max11410_attribute_group,\n};\n\nstatic irqreturn_t max11410_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = max11410_read_reg(st, MAX11410_REG_DATA0, &st->scan.data);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"cannot read data\\n\");\n\t\tgoto out;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max11410_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\tint scan_ch, ret;\n\n\tscan_ch = ffs(*indio_dev->active_scan_mask) - 1;\n\n\tret = max11410_configure_channel(st, &indio_dev->channels[scan_ch]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn max11410_write_reg(st, MAX11410_REG_CONV_START,\n\t\t\t\t  MAX11410_CONV_TYPE_CONTINUOUS);\n}\n\nstatic int max11410_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\n\t \n\treturn max11410_write_reg(st, MAX11410_REG_CONV_START,\n\t\t\t\t  MAX11410_CONV_TYPE_SINGLE);\n}\n\nstatic const struct iio_buffer_setup_ops max11410_buffer_ops = {\n\t.postenable = &max11410_buffer_postenable,\n\t.predisable = &max11410_buffer_predisable,\n\t.validate_scan_mask = &iio_validate_scan_mask_onehot,\n};\n\nstatic const struct iio_trigger_ops max11410_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic irqreturn_t max11410_interrupt(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct max11410_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tiio_trigger_poll_nested(st->trig);\n\telse\n\t\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n};\n\nstatic int max11410_parse_channels(struct max11410_state *st,\n\t\t\t\t   struct iio_dev *indio_dev)\n{\n\tstruct iio_chan_spec chanspec = chanspec_template;\n\tstruct device *dev = &st->spi_dev->dev;\n\tstruct max11410_channel_config *cfg;\n\tstruct iio_chan_spec *channels;\n\tstruct fwnode_handle *child;\n\tu32 reference, sig_path;\n\tconst char *node_name;\n\tu32 inputs[2], scale;\n\tunsigned int num_ch;\n\tint chan_idx = 0;\n\tint ret, i;\n\n\tnum_ch = device_get_child_node_count(dev);\n\tif (num_ch == 0)\n\t\treturn dev_err_probe(&indio_dev->dev, -ENODEV,\n\t\t\t\t     \"FW has no channels defined\\n\");\n\n\t \n\tnum_ch++;\n\tchannels = devm_kcalloc(dev, num_ch, sizeof(*channels), GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tst->channels = devm_kcalloc(dev, num_ch, sizeof(*st->channels),\n\t\t\t\t    GFP_KERNEL);\n\tif (!st->channels)\n\t\treturn -ENOMEM;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tnode_name = fwnode_get_name(child);\n\t\tif (fwnode_property_present(child, \"diff-channels\")) {\n\t\t\tret = fwnode_property_read_u32_array(child,\n\t\t\t\t\t\t\t     \"diff-channels\",\n\t\t\t\t\t\t\t     inputs,\n\t\t\t\t\t\t\t     ARRAY_SIZE(inputs));\n\n\t\t\tchanspec.differential = 1;\n\t\t} else {\n\t\t\tret = fwnode_property_read_u32(child, \"reg\", &inputs[0]);\n\n\t\t\tinputs[1] = 0;\n\t\t\tchanspec.differential = 0;\n\t\t}\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (inputs[0] > MAX11410_CHANNEL_INDEX_MAX ||\n\t\t    inputs[1] > MAX11410_CHANNEL_INDEX_MAX) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(&indio_dev->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid channel index for %s, should be less than %d\\n\",\n\t\t\t\t\t     node_name,\n\t\t\t\t\t     MAX11410_CHANNEL_INDEX_MAX + 1);\n\t\t}\n\n\t\tcfg = &st->channels[chan_idx];\n\n\t\treference = MAX11410_REFSEL_AVDD_AGND;\n\t\tfwnode_property_read_u32(child, \"adi,reference\", &reference);\n\t\tif (reference > MAX11410_REFSEL_MAX) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(&indio_dev->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid adi,reference value for %s, should be less than %d.\\n\",\n\t\t\t\t\t     node_name, MAX11410_REFSEL_MAX + 1);\n\t\t}\n\n\t\tif (!max11410_get_vrefp(st, reference) ||\n\t\t    (!max11410_get_vrefn(st, reference) && reference <= 2)) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(&indio_dev->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid VREF configuration for %s, either specify corresponding VREF regulators or change adi,reference property.\\n\",\n\t\t\t\t\t     node_name);\n\t\t}\n\n\t\tsig_path = MAX11410_PGA_SIG_PATH_BUFFERED;\n\t\tfwnode_property_read_u32(child, \"adi,input-mode\", &sig_path);\n\t\tif (sig_path > MAX11410_SIG_PATH_MAX) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(&indio_dev->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid adi,input-mode value for %s, should be less than %d.\\n\",\n\t\t\t\t\t     node_name, MAX11410_SIG_PATH_MAX + 1);\n\t\t}\n\n\t\tfwnode_property_read_u32(child, \"settling-time-us\",\n\t\t\t\t\t &cfg->settling_time_us);\n\t\tcfg->bipolar = fwnode_property_read_bool(child, \"bipolar\");\n\t\tcfg->buffered_vrefp = fwnode_property_read_bool(child, \"adi,buffered-vrefp\");\n\t\tcfg->buffered_vrefn = fwnode_property_read_bool(child, \"adi,buffered-vrefn\");\n\t\tcfg->refsel = reference;\n\t\tcfg->sig_path = sig_path;\n\t\tcfg->gain = 0;\n\n\t\t \n\t\tif (sig_path == MAX11410_PGA_SIG_PATH_PGA) {\n\t\t\t__set_bit(IIO_CHAN_INFO_SCALE,\n\t\t\t\t  &chanspec.info_mask_separate_available);\n\t\t\tcfg->scale_avail = devm_kcalloc(dev, MAX11410_SCALE_AVAIL_SIZE * 2,\n\t\t\t\t\t\t\tsizeof(*cfg->scale_avail),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!cfg->scale_avail) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tscale = max11410_get_scale(st, *cfg);\n\t\t\tfor (i = 0; i < MAX11410_SCALE_AVAIL_SIZE; i++) {\n\t\t\t\tcfg->scale_avail[2 * i] = scale >> i;\n\t\t\t\tcfg->scale_avail[2 * i + 1] = chanspec.scan_type.realbits;\n\t\t\t}\n\t\t} else {\n\t\t\t__clear_bit(IIO_CHAN_INFO_SCALE,\n\t\t\t\t    &chanspec.info_mask_separate_available);\n\t\t}\n\n\t\tchanspec.address = chan_idx;\n\t\tchanspec.scan_index = chan_idx;\n\t\tchanspec.channel = inputs[0];\n\t\tchanspec.channel2 = inputs[1];\n\n\t\tchannels[chan_idx] = chanspec;\n\t\tchan_idx++;\n\t}\n\n\tchannels[chan_idx] = (struct iio_chan_spec)IIO_CHAN_SOFT_TIMESTAMP(chan_idx);\n\n\tindio_dev->num_channels = chan_idx + 1;\n\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic void max11410_disable_reg(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int max11410_init_vref(struct device *dev,\n\t\t\t      struct regulator **vref,\n\t\t\t      const char *id)\n{\n\tstruct regulator *reg;\n\tint ret;\n\n\treg = devm_regulator_get_optional(dev, id);\n\tif (PTR_ERR(reg) == -ENODEV) {\n\t\t*vref = NULL;\n\t\treturn 0;\n\t} else if (IS_ERR(reg)) {\n\t\treturn PTR_ERR(reg);\n\t}\n\tret = regulator_enable(reg);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable regulator %s\\n\", id);\n\n\t*vref = reg;\n\treturn devm_add_action_or_reset(dev, max11410_disable_reg, reg);\n}\n\nstatic int max11410_calibrate(struct max11410_state *st, u32 cal_type)\n{\n\tint ret, ret2, val;\n\n\tret = max11410_write_reg(st, MAX11410_REG_CAL_START, cal_type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = read_poll_timeout(max11410_read_reg, ret2,\n\t\t\t\tret2 || (val & MAX11410_STATUS_CAL_READY_BIT),\n\t\t\t\t50000, MAX11410_CALIB_TIMEOUT_MS * 1000, true,\n\t\t\t\tst, MAX11410_REG_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret2;\n}\n\nstatic int max11410_self_calibrate(struct max11410_state *st)\n{\n\tint ret, i;\n\n\tret = regmap_write_bits(st->regmap, MAX11410_REG_FILTER,\n\t\t\t\tMAX11410_FILTER_RATE_MASK,\n\t\t\t\tFIELD_PREP(MAX11410_FILTER_RATE_MASK,\n\t\t\t\t\t   MAX11410_FILTER_RATE_MAX));\n\tif (ret)\n\t\treturn ret;\n\n\tret = max11410_calibrate(st, MAX11410_CAL_START_SELF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(st->regmap, MAX11410_REG_PGA,\n\t\t\t\tMAX11410_PGA_SIG_PATH_MASK,\n\t\t\t\tFIELD_PREP(MAX11410_PGA_SIG_PATH_MASK,\n\t\t\t\t\t   MAX11410_PGA_SIG_PATH_PGA));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 1; i < 8; ++i) {\n\t\tret = regmap_write_bits(st->regmap, MAX11410_REG_PGA,\n\t\t\t\t\tMAX11410_PGA_GAIN_MASK, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = max11410_calibrate(st, MAX11410_CAL_START_PGA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write_bits(st->regmap, MAX11410_REG_PGA,\n\t\t\t\tMAX11410_PGA_GAIN_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(st->regmap, MAX11410_REG_FILTER,\n\t\t\t\tMAX11410_FILTER_RATE_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write_bits(st->regmap, MAX11410_REG_PGA,\n\t\t\t\t MAX11410_PGA_SIG_PATH_MASK,\n\t\t\t\t FIELD_PREP(MAX11410_PGA_SIG_PATH_MASK,\n\t\t\t\t\t    MAX11410_PGA_SIG_PATH_BUFFERED));\n}\n\nstatic int max11410_probe(struct spi_device *spi)\n{\n\tconst char *vrefp_regs[] = { \"vref0p\", \"vref1p\", \"vref2p\" };\n\tconst char *vrefn_regs[] = { \"vref0n\", \"vref1n\", \"vref2n\" };\n\tstruct device *dev = &spi->dev;\n\tstruct max11410_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret, irqs[2];\n\tint i;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi_dev = spi;\n\tinit_completion(&st->completion);\n\tmutex_init(&st->lock);\n\n\tindio_dev->name = \"max11410\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &max11410_info;\n\n\tst->regmap = devm_regmap_init_spi(spi, &regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->regmap),\n\t\t\t\t     \"regmap initialization failed\\n\");\n\n\tret = max11410_init_vref(dev, &st->avdd, \"avdd\");\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(vrefp_regs); i++) {\n\t\tret = max11410_init_vref(dev, &st->vrefp[i], vrefp_regs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = max11410_init_vref(dev, &st->vrefn[i], vrefn_regs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = max11410_parse_channels(st, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tirqs[0] = fwnode_irq_get_byname(dev_fwnode(dev), \"gpio0\");\n\tirqs[1] = fwnode_irq_get_byname(dev_fwnode(dev), \"gpio1\");\n\n\tif (irqs[0] > 0) {\n\t\tst->irq = irqs[0];\n\t\tret = regmap_write(st->regmap, MAX11410_REG_GPIO_CTRL(0),\n\t\t\t\t   MAX11410_GPIO_INTRB);\n\t} else if (irqs[1] > 0) {\n\t\tst->irq = irqs[1];\n\t\tret = regmap_write(st->regmap, MAX11410_REG_GPIO_CTRL(1),\n\t\t\t\t   MAX11410_GPIO_INTRB);\n\t} else if (spi->irq > 0) {\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"no interrupt name specified\");\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(st->regmap, MAX11410_REG_CTRL,\n\t\t\t      MAX11410_CTRL_FORMAT_BIT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      &max11410_trigger_handler,\n\t\t\t\t\t      &max11410_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->irq > 0) {\n\t\tst->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t\t  indio_dev->name,\n\t\t\t\t\t\t  iio_device_id(indio_dev));\n\t\tif (!st->trig)\n\t\t\treturn -ENOMEM;\n\n\t\tst->trig->ops = &max11410_trigger_ops;\n\t\tret = devm_iio_trigger_register(dev, st->trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(dev, st->irq, NULL,\n\t\t\t\t\t\t&max11410_interrupt,\n\t\t\t\t\t\tIRQF_ONESHOT, \"max11410\",\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = max11410_self_calibrate(st);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"cannot perform device self calibration\\n\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id max11410_spi_of_id[] = {\n\t{ .compatible = \"adi,max11410\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max11410_spi_of_id);\n\nstatic const struct spi_device_id max11410_id[] = {\n\t{ \"max11410\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, max11410_id);\n\nstatic struct spi_driver max11410_driver = {\n\t.driver = {\n\t\t.name\t= \"max11410\",\n\t\t.of_match_table = max11410_spi_of_id,\n\t},\n\t.probe\t\t= max11410_probe,\n\t.id_table\t= max11410_id,\n};\nmodule_spi_driver(max11410_driver);\n\nMODULE_AUTHOR(\"David Jung <David.Jung@analog.com>\");\nMODULE_AUTHOR(\"Ibrahim Tilki <Ibrahim.Tilki@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices MAX11410 ADC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}