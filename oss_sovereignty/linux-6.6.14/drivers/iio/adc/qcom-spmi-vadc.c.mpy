{
  "module_name": "qcom-spmi-vadc.c",
  "hash_id": "a9f7ab74aaa001ea9085061e0db052ad04d683a1a33868b075bf725ee6d9c57c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/qcom-spmi-vadc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/adc/qcom-vadc-common.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n\n#include <dt-bindings/iio/qcom,spmi-vadc.h>\n\n \n#define VADC_REVISION2\t\t\t\t0x1\n#define VADC_REVISION2_SUPPORTED_VADC\t\t1\n\n#define VADC_PERPH_TYPE\t\t\t\t0x4\n#define VADC_PERPH_TYPE_ADC\t\t\t8\n\n#define VADC_PERPH_SUBTYPE\t\t\t0x5\n#define VADC_PERPH_SUBTYPE_VADC\t\t\t1\n\n#define VADC_STATUS1\t\t\t\t0x8\n#define VADC_STATUS1_OP_MODE\t\t\t4\n#define VADC_STATUS1_REQ_STS\t\t\tBIT(1)\n#define VADC_STATUS1_EOC\t\t\tBIT(0)\n#define VADC_STATUS1_REQ_STS_EOC_MASK\t\t0x3\n\n#define VADC_MODE_CTL\t\t\t\t0x40\n#define VADC_OP_MODE_SHIFT\t\t\t3\n#define VADC_OP_MODE_NORMAL\t\t\t0\n#define VADC_AMUX_TRIM_EN\t\t\tBIT(1)\n#define VADC_ADC_TRIM_EN\t\t\tBIT(0)\n\n#define VADC_EN_CTL1\t\t\t\t0x46\n#define VADC_EN_CTL1_SET\t\t\tBIT(7)\n\n#define VADC_ADC_CH_SEL_CTL\t\t\t0x48\n\n#define VADC_ADC_DIG_PARAM\t\t\t0x50\n#define VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT\t2\n\n#define VADC_HW_SETTLE_DELAY\t\t\t0x51\n\n#define VADC_CONV_REQ\t\t\t\t0x52\n#define VADC_CONV_REQ_SET\t\t\tBIT(7)\n\n#define VADC_FAST_AVG_CTL\t\t\t0x5a\n#define VADC_FAST_AVG_EN\t\t\t0x5b\n#define VADC_FAST_AVG_EN_SET\t\t\tBIT(7)\n\n#define VADC_ACCESS\t\t\t\t0xd0\n#define VADC_ACCESS_DATA\t\t\t0xa5\n\n#define VADC_PERH_RESET_CTL3\t\t\t0xda\n#define VADC_FOLLOW_WARM_RB\t\t\tBIT(2)\n\n#define VADC_DATA\t\t\t\t0x60\t \n\n#define VADC_CHAN_MIN\t\t\tVADC_USBIN\n#define VADC_CHAN_MAX\t\t\tVADC_LR_MUX3_BUF_PU1_PU2_XO_THERM\n\n \nstruct vadc_channel_prop {\n\tunsigned int channel;\n\tenum vadc_calibration calibration;\n\tunsigned int decimation;\n\tunsigned int prescale;\n\tunsigned int hw_settle_time;\n\tunsigned int avg_samples;\n\tenum vadc_scale_fn_type scale_fn_type;\n\tconst char *channel_name;\n};\n\n \nstruct vadc_priv {\n\tstruct regmap\t\t *regmap;\n\tstruct device\t\t *dev;\n\tu16\t\t\t base;\n\tunsigned int\t\t nchannels;\n\tstruct vadc_channel_prop *chan_props;\n\tstruct iio_chan_spec\t *iio_chans;\n\tbool\t\t\t are_ref_measured;\n\tbool\t\t\t poll_eoc;\n\tstruct completion\t complete;\n\tstruct vadc_linear_graph graph[2];\n\tstruct mutex\t\t lock;\n};\n\nstatic const struct u32_fract vadc_prescale_ratios[] = {\n\t{ .numerator =  1, .denominator =  1 },\n\t{ .numerator =  1, .denominator =  3 },\n\t{ .numerator =  1, .denominator =  4 },\n\t{ .numerator =  1, .denominator =  6 },\n\t{ .numerator =  1, .denominator = 20 },\n\t{ .numerator =  1, .denominator =  8 },\n\t{ .numerator = 10, .denominator = 81 },\n\t{ .numerator =  1, .denominator = 10 },\n};\n\nstatic int vadc_read(struct vadc_priv *vadc, u16 offset, u8 *data)\n{\n\treturn regmap_bulk_read(vadc->regmap, vadc->base + offset, data, 1);\n}\n\nstatic int vadc_write(struct vadc_priv *vadc, u16 offset, u8 data)\n{\n\treturn regmap_write(vadc->regmap, vadc->base + offset, data);\n}\n\nstatic int vadc_reset(struct vadc_priv *vadc)\n{\n\tu8 data;\n\tint ret;\n\n\tret = vadc_write(vadc, VADC_ACCESS, VADC_ACCESS_DATA);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vadc_read(vadc, VADC_PERH_RESET_CTL3, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vadc_write(vadc, VADC_ACCESS, VADC_ACCESS_DATA);\n\tif (ret)\n\t\treturn ret;\n\n\tdata |= VADC_FOLLOW_WARM_RB;\n\n\treturn vadc_write(vadc, VADC_PERH_RESET_CTL3, data);\n}\n\nstatic int vadc_set_state(struct vadc_priv *vadc, bool state)\n{\n\treturn vadc_write(vadc, VADC_EN_CTL1, state ? VADC_EN_CTL1_SET : 0);\n}\n\nstatic void vadc_show_status(struct vadc_priv *vadc)\n{\n\tu8 mode, sta1, chan, dig, en, req;\n\tint ret;\n\n\tret = vadc_read(vadc, VADC_MODE_CTL, &mode);\n\tif (ret)\n\t\treturn;\n\n\tret = vadc_read(vadc, VADC_ADC_DIG_PARAM, &dig);\n\tif (ret)\n\t\treturn;\n\n\tret = vadc_read(vadc, VADC_ADC_CH_SEL_CTL, &chan);\n\tif (ret)\n\t\treturn;\n\n\tret = vadc_read(vadc, VADC_CONV_REQ, &req);\n\tif (ret)\n\t\treturn;\n\n\tret = vadc_read(vadc, VADC_STATUS1, &sta1);\n\tif (ret)\n\t\treturn;\n\n\tret = vadc_read(vadc, VADC_EN_CTL1, &en);\n\tif (ret)\n\t\treturn;\n\n\tdev_err(vadc->dev,\n\t\t\"mode:%02x en:%02x chan:%02x dig:%02x req:%02x sta1:%02x\\n\",\n\t\tmode, en, chan, dig, req, sta1);\n}\n\nstatic int vadc_configure(struct vadc_priv *vadc,\n\t\t\t  struct vadc_channel_prop *prop)\n{\n\tu8 decimation, mode_ctrl;\n\tint ret;\n\n\t \n\tmode_ctrl = (VADC_OP_MODE_NORMAL << VADC_OP_MODE_SHIFT) |\n\t\t     VADC_ADC_TRIM_EN | VADC_AMUX_TRIM_EN;\n\tret = vadc_write(vadc, VADC_MODE_CTL, mode_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = vadc_write(vadc, VADC_ADC_CH_SEL_CTL, prop->channel);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdecimation = prop->decimation << VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT;\n\tret = vadc_write(vadc, VADC_ADC_DIG_PARAM, decimation);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = vadc_write(vadc, VADC_HW_SETTLE_DELAY, prop->hw_settle_time);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vadc_write(vadc, VADC_FAST_AVG_CTL, prop->avg_samples);\n\tif (ret)\n\t\treturn ret;\n\n\tif (prop->avg_samples)\n\t\tret = vadc_write(vadc, VADC_FAST_AVG_EN, VADC_FAST_AVG_EN_SET);\n\telse\n\t\tret = vadc_write(vadc, VADC_FAST_AVG_EN, 0);\n\n\treturn ret;\n}\n\nstatic int vadc_poll_wait_eoc(struct vadc_priv *vadc, unsigned int interval_us)\n{\n\tunsigned int count, retry;\n\tu8 sta1;\n\tint ret;\n\n\tretry = interval_us / VADC_CONV_TIME_MIN_US;\n\n\tfor (count = 0; count < retry; count++) {\n\t\tret = vadc_read(vadc, VADC_STATUS1, &sta1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsta1 &= VADC_STATUS1_REQ_STS_EOC_MASK;\n\t\tif (sta1 == VADC_STATUS1_EOC)\n\t\t\treturn 0;\n\n\t\tusleep_range(VADC_CONV_TIME_MIN_US, VADC_CONV_TIME_MAX_US);\n\t}\n\n\tvadc_show_status(vadc);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int vadc_read_result(struct vadc_priv *vadc, u16 *data)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(vadc->regmap, vadc->base + VADC_DATA, data, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*data = clamp_t(u16, *data, VADC_MIN_ADC_CODE, VADC_MAX_ADC_CODE);\n\n\treturn 0;\n}\n\nstatic struct vadc_channel_prop *vadc_get_channel(struct vadc_priv *vadc,\n\t\t\t\t\t\t  unsigned int num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vadc->nchannels; i++)\n\t\tif (vadc->chan_props[i].channel == num)\n\t\t\treturn &vadc->chan_props[i];\n\n\tdev_dbg(vadc->dev, \"no such channel %02x\\n\", num);\n\n\treturn NULL;\n}\n\nstatic int vadc_do_conversion(struct vadc_priv *vadc,\n\t\t\t      struct vadc_channel_prop *prop, u16 *data)\n{\n\tunsigned int timeout;\n\tint ret;\n\n\tmutex_lock(&vadc->lock);\n\n\tret = vadc_configure(vadc, prop);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (!vadc->poll_eoc)\n\t\treinit_completion(&vadc->complete);\n\n\tret = vadc_set_state(vadc, true);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = vadc_write(vadc, VADC_CONV_REQ, VADC_CONV_REQ_SET);\n\tif (ret)\n\t\tgoto err_disable;\n\n\ttimeout = BIT(prop->avg_samples) * VADC_CONV_TIME_MIN_US * 2;\n\n\tif (vadc->poll_eoc) {\n\t\tret = vadc_poll_wait_eoc(vadc, timeout);\n\t} else {\n\t\tret = wait_for_completion_timeout(&vadc->complete, timeout);\n\t\tif (!ret) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err_disable;\n\t\t}\n\n\t\t \n\t\tret = vadc_poll_wait_eoc(vadc, VADC_CONV_TIME_MIN_US);\n\t\tif (ret)\n\t\t\tgoto err_disable;\n\t}\n\n\tret = vadc_read_result(vadc, data);\n\nerr_disable:\n\tvadc_set_state(vadc, false);\n\tif (ret)\n\t\tdev_err(vadc->dev, \"conversion failed\\n\");\nunlock:\n\tmutex_unlock(&vadc->lock);\n\treturn ret;\n}\n\nstatic int vadc_measure_ref_points(struct vadc_priv *vadc)\n{\n\tstruct vadc_channel_prop *prop;\n\tu16 read_1, read_2;\n\tint ret;\n\n\tvadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE;\n\tvadc->graph[VADC_CALIB_ABSOLUTE].dx = VADC_ABSOLUTE_RANGE_UV;\n\n\tprop = vadc_get_channel(vadc, VADC_REF_1250MV);\n\tret = vadc_do_conversion(vadc, prop, &read_1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tprop = vadc_get_channel(vadc, VADC_SPARE1);\n\tif (!prop)\n\t\tprop = vadc_get_channel(vadc, VADC_REF_625MV);\n\n\tret = vadc_do_conversion(vadc, prop, &read_2);\n\tif (ret)\n\t\tgoto err;\n\n\tif (read_1 == read_2) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tvadc->graph[VADC_CALIB_ABSOLUTE].dy = read_1 - read_2;\n\tvadc->graph[VADC_CALIB_ABSOLUTE].gnd = read_2;\n\n\t \n\tprop = vadc_get_channel(vadc, VADC_VDD_VADC);\n\tret = vadc_do_conversion(vadc, prop, &read_1);\n\tif (ret)\n\t\tgoto err;\n\n\tprop = vadc_get_channel(vadc, VADC_GND_REF);\n\tret = vadc_do_conversion(vadc, prop, &read_2);\n\tif (ret)\n\t\tgoto err;\n\n\tif (read_1 == read_2) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tvadc->graph[VADC_CALIB_RATIOMETRIC].dy = read_1 - read_2;\n\tvadc->graph[VADC_CALIB_RATIOMETRIC].gnd = read_2;\nerr:\n\tif (ret)\n\t\tdev_err(vadc->dev, \"measure reference points failed\\n\");\n\n\treturn ret;\n}\n\nstatic int vadc_prescaling_from_dt(u32 numerator, u32 denominator)\n{\n\tunsigned int pre;\n\n\tfor (pre = 0; pre < ARRAY_SIZE(vadc_prescale_ratios); pre++)\n\t\tif (vadc_prescale_ratios[pre].numerator == numerator &&\n\t\t    vadc_prescale_ratios[pre].denominator == denominator)\n\t\t\tbreak;\n\n\tif (pre == ARRAY_SIZE(vadc_prescale_ratios))\n\t\treturn -EINVAL;\n\n\treturn pre;\n}\n\nstatic int vadc_hw_settle_time_from_dt(u32 value)\n{\n\tif ((value <= 1000 && value % 100) || (value > 1000 && value % 2000))\n\t\treturn -EINVAL;\n\n\tif (value <= 1000)\n\t\tvalue /= 100;\n\telse\n\t\tvalue = value / 2000 + 10;\n\n\treturn value;\n}\n\nstatic int vadc_avg_samples_from_dt(u32 value)\n{\n\tif (!is_power_of_2(value) || value > VADC_AVG_SAMPLES_MAX)\n\t\treturn -EINVAL;\n\n\treturn __ffs64(value);\n}\n\nstatic int vadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan, int *val, int *val2,\n\t\t\t long mask)\n{\n\tstruct vadc_priv *vadc = iio_priv(indio_dev);\n\tstruct vadc_channel_prop *prop;\n\tu16 adc_code;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tprop = &vadc->chan_props[chan->address];\n\t\tret = vadc_do_conversion(vadc, prop, &adc_code);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = qcom_vadc_scale(prop->scale_fn_type,\n\t\t\t\t&vadc->graph[prop->calibration],\n\t\t\t\t&vadc_prescale_ratios[prop->prescale],\n\t\t\t\t(prop->calibration == VADC_CALIB_ABSOLUTE),\n\t\t\t\tadc_code, val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tprop = &vadc->chan_props[chan->address];\n\t\tret = vadc_do_conversion(vadc, prop, &adc_code);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = (int)adc_code;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vadc_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t     const struct fwnode_reference_args *iiospec)\n{\n\tstruct vadc_priv *vadc = iio_priv(indio_dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < vadc->nchannels; i++)\n\t\tif (vadc->iio_chans[i].channel == iiospec->args[0])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int vadc_read_label(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, char *label)\n{\n\tstruct vadc_priv *vadc = iio_priv(indio_dev);\n\tconst char *name = vadc->chan_props[chan->address].channel_name;\n\n\treturn sysfs_emit(label, \"%s\\n\", name);\n}\n\nstatic const struct iio_info vadc_info = {\n\t.read_raw = vadc_read_raw,\n\t.read_label = vadc_read_label,\n\t.fwnode_xlate = vadc_fwnode_xlate,\n};\n\nstruct vadc_channels {\n\tconst char *datasheet_name;\n\tunsigned int prescale_index;\n\tenum iio_chan_type type;\n\tlong info_mask;\n\tenum vadc_scale_fn_type scale_fn_type;\n};\n\n#define VADC_CHAN(_dname, _type, _mask, _pre, _scale)\t\t\t\\\n\t[VADC_##_dname] = {\t\t\t\t\t\t\\\n\t\t.datasheet_name = __stringify(_dname),\t\t\t\\\n\t\t.prescale_index = _pre,\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.info_mask = _mask,\t\t\t\t\t\\\n\t\t.scale_fn_type = _scale\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\n#define VADC_NO_CHAN(_dname, _type, _mask, _pre)\t\t\t\\\n\t[VADC_##_dname] = {\t\t\t\t\t\t\\\n\t\t.datasheet_name = __stringify(_dname),\t\t\t\\\n\t\t.prescale_index = _pre,\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.info_mask = _mask\t\t\t\t\t\\\n\t},\n\n#define VADC_CHAN_TEMP(_dname, _pre, _scale)\t\t\t\t\\\n\tVADC_CHAN(_dname, IIO_TEMP,\t\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED),\t\\\n\t\t_pre, _scale)\t\t\t\t\t\t\\\n\n#define VADC_CHAN_VOLT(_dname, _pre, _scale)\t\t\t\t\\\n\tVADC_CHAN(_dname, IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t  BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED),\\\n\t\t  _pre, _scale)\t\t\t\t\t\t\\\n\n#define VADC_CHAN_NO_SCALE(_dname, _pre)\t\t\t\t\\\n\tVADC_NO_CHAN(_dname, IIO_VOLTAGE,\t\t\t\t\\\n\t\t  BIT(IIO_CHAN_INFO_RAW),\t\t\t\t\\\n\t\t  _pre)\t\t\t\t\t\t\t\\\n\n \nstatic const struct vadc_channels vadc_chans[] = {\n\tVADC_CHAN_VOLT(USBIN, 4, SCALE_DEFAULT)\n\tVADC_CHAN_VOLT(DCIN, 4, SCALE_DEFAULT)\n\tVADC_CHAN_NO_SCALE(VCHG_SNS, 3)\n\tVADC_CHAN_NO_SCALE(SPARE1_03, 1)\n\tVADC_CHAN_NO_SCALE(USB_ID_MV, 1)\n\tVADC_CHAN_VOLT(VCOIN, 1, SCALE_DEFAULT)\n\tVADC_CHAN_NO_SCALE(VBAT_SNS, 1)\n\tVADC_CHAN_VOLT(VSYS, 1, SCALE_DEFAULT)\n\tVADC_CHAN_TEMP(DIE_TEMP, 0, SCALE_PMIC_THERM)\n\tVADC_CHAN_VOLT(REF_625MV, 0, SCALE_DEFAULT)\n\tVADC_CHAN_VOLT(REF_1250MV, 0, SCALE_DEFAULT)\n\tVADC_CHAN_NO_SCALE(CHG_TEMP, 0)\n\tVADC_CHAN_NO_SCALE(SPARE1, 0)\n\tVADC_CHAN_TEMP(SPARE2, 0, SCALE_PMI_CHG_TEMP)\n\tVADC_CHAN_VOLT(GND_REF, 0, SCALE_DEFAULT)\n\tVADC_CHAN_VOLT(VDD_VADC, 0, SCALE_DEFAULT)\n\n\tVADC_CHAN_NO_SCALE(P_MUX1_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX2_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX3_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX4_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX5_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX6_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX7_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX8_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX9_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX10_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX11_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX12_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX13_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX14_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX15_1_1, 0)\n\tVADC_CHAN_NO_SCALE(P_MUX16_1_1, 0)\n\n\tVADC_CHAN_NO_SCALE(P_MUX1_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX2_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX3_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX4_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX5_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX6_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX7_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX8_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX9_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX10_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX11_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX12_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX13_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX14_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX15_1_3, 1)\n\tVADC_CHAN_NO_SCALE(P_MUX16_1_3, 1)\n\n\tVADC_CHAN_NO_SCALE(LR_MUX1_BAT_THERM, 0)\n\tVADC_CHAN_VOLT(LR_MUX2_BAT_ID, 0, SCALE_DEFAULT)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_XO_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX4_AMUX_THM1, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX5_AMUX_THM2, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX6_AMUX_THM3, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX7_HW_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX8_AMUX_THM4, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX9_AMUX_THM5, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX10_USB_ID, 0)\n\tVADC_CHAN_NO_SCALE(AMUX_PU1, 0)\n\tVADC_CHAN_NO_SCALE(AMUX_PU2, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_BUF_XO_THERM, 0)\n\n\tVADC_CHAN_NO_SCALE(LR_MUX1_PU1_BAT_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX2_PU1_BAT_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_PU1_XO_THERM, 0)\n\tVADC_CHAN_TEMP(LR_MUX4_PU1_AMUX_THM1, 0, SCALE_THERM_100K_PULLUP)\n\tVADC_CHAN_TEMP(LR_MUX5_PU1_AMUX_THM2, 0, SCALE_THERM_100K_PULLUP)\n\tVADC_CHAN_TEMP(LR_MUX6_PU1_AMUX_THM3, 0, SCALE_THERM_100K_PULLUP)\n\tVADC_CHAN_NO_SCALE(LR_MUX7_PU1_AMUX_HW_ID, 0)\n\tVADC_CHAN_TEMP(LR_MUX8_PU1_AMUX_THM4, 0, SCALE_THERM_100K_PULLUP)\n\tVADC_CHAN_TEMP(LR_MUX9_PU1_AMUX_THM5, 0, SCALE_THERM_100K_PULLUP)\n\tVADC_CHAN_NO_SCALE(LR_MUX10_PU1_AMUX_USB_ID, 0)\n\tVADC_CHAN_TEMP(LR_MUX3_BUF_PU1_XO_THERM, 0, SCALE_XOTHERM)\n\n\tVADC_CHAN_NO_SCALE(LR_MUX1_PU2_BAT_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX2_PU2_BAT_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_PU2_XO_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX4_PU2_AMUX_THM1, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX5_PU2_AMUX_THM2, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX6_PU2_AMUX_THM3, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX7_PU2_AMUX_HW_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX8_PU2_AMUX_THM4, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX9_PU2_AMUX_THM5, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX10_PU2_AMUX_USB_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_BUF_PU2_XO_THERM, 0)\n\n\tVADC_CHAN_NO_SCALE(LR_MUX1_PU1_PU2_BAT_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX2_PU1_PU2_BAT_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_PU1_PU2_XO_THERM, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX4_PU1_PU2_AMUX_THM1, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX5_PU1_PU2_AMUX_THM2, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX6_PU1_PU2_AMUX_THM3, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX7_PU1_PU2_AMUX_HW_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX8_PU1_PU2_AMUX_THM4, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX9_PU1_PU2_AMUX_THM5, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX10_PU1_PU2_AMUX_USB_ID, 0)\n\tVADC_CHAN_NO_SCALE(LR_MUX3_BUF_PU1_PU2_XO_THERM, 0)\n};\n\nstatic int vadc_get_fw_channel_data(struct device *dev,\n\t\t\t\t    struct vadc_channel_prop *prop,\n\t\t\t\t    struct fwnode_handle *fwnode)\n{\n\tconst char *name = fwnode_get_name(fwnode), *label;\n\tu32 chan, value, varr[2];\n\tint ret;\n\n\tret = fwnode_property_read_u32(fwnode, \"reg\", &chan);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid channel number %s\\n\", name);\n\t\treturn ret;\n\t}\n\n\tif (chan > VADC_CHAN_MAX || chan < VADC_CHAN_MIN) {\n\t\tdev_err(dev, \"%s invalid channel number %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\n\tret = fwnode_property_read_string(fwnode, \"label\", &label);\n\tif (ret)\n\t\tlabel = vadc_chans[chan].datasheet_name;\n\tprop->channel_name = label;\n\n\t \n\tprop->channel = chan;\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,decimation\", &value);\n\tif (!ret) {\n\t\tret = qcom_vadc_decimation_from_dt(value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid decimation %d\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->decimation = ret;\n\t} else {\n\t\tprop->decimation = VADC_DEF_DECIMATION;\n\t}\n\n\tret = fwnode_property_read_u32_array(fwnode, \"qcom,pre-scaling\", varr, 2);\n\tif (!ret) {\n\t\tret = vadc_prescaling_from_dt(varr[0], varr[1]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid pre-scaling <%d %d>\\n\",\n\t\t\t\tchan, varr[0], varr[1]);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->prescale = ret;\n\t} else {\n\t\tprop->prescale = vadc_chans[prop->channel].prescale_index;\n\t}\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,hw-settle-time\", &value);\n\tif (!ret) {\n\t\tret = vadc_hw_settle_time_from_dt(value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid hw-settle-time %d us\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->hw_settle_time = ret;\n\t} else {\n\t\tprop->hw_settle_time = VADC_DEF_HW_SETTLE_TIME;\n\t}\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,avg-samples\", &value);\n\tif (!ret) {\n\t\tret = vadc_avg_samples_from_dt(value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid avg-samples %d\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->avg_samples = ret;\n\t} else {\n\t\tprop->avg_samples = VADC_DEF_AVG_SAMPLES;\n\t}\n\n\tif (fwnode_property_read_bool(fwnode, \"qcom,ratiometric\"))\n\t\tprop->calibration = VADC_CALIB_RATIOMETRIC;\n\telse\n\t\tprop->calibration = VADC_CALIB_ABSOLUTE;\n\n\tdev_dbg(dev, \"%02x name %s\\n\", chan, name);\n\n\treturn 0;\n}\n\nstatic int vadc_get_fw_data(struct vadc_priv *vadc)\n{\n\tconst struct vadc_channels *vadc_chan;\n\tstruct iio_chan_spec *iio_chan;\n\tstruct vadc_channel_prop prop;\n\tstruct fwnode_handle *child;\n\tunsigned int index = 0;\n\tint ret;\n\n\tvadc->nchannels = device_get_child_node_count(vadc->dev);\n\tif (!vadc->nchannels)\n\t\treturn -EINVAL;\n\n\tvadc->iio_chans = devm_kcalloc(vadc->dev, vadc->nchannels,\n\t\t\t\t       sizeof(*vadc->iio_chans), GFP_KERNEL);\n\tif (!vadc->iio_chans)\n\t\treturn -ENOMEM;\n\n\tvadc->chan_props = devm_kcalloc(vadc->dev, vadc->nchannels,\n\t\t\t\t\tsizeof(*vadc->chan_props), GFP_KERNEL);\n\tif (!vadc->chan_props)\n\t\treturn -ENOMEM;\n\n\tiio_chan = vadc->iio_chans;\n\n\tdevice_for_each_child_node(vadc->dev, child) {\n\t\tret = vadc_get_fw_channel_data(vadc->dev, &prop, child);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tprop.scale_fn_type = vadc_chans[prop.channel].scale_fn_type;\n\t\tvadc->chan_props[index] = prop;\n\n\t\tvadc_chan = &vadc_chans[prop.channel];\n\n\t\tiio_chan->channel = prop.channel;\n\t\tiio_chan->datasheet_name = vadc_chan->datasheet_name;\n\t\tiio_chan->info_mask_separate = vadc_chan->info_mask;\n\t\tiio_chan->type = vadc_chan->type;\n\t\tiio_chan->indexed = 1;\n\t\tiio_chan->address = index++;\n\n\t\tiio_chan++;\n\t}\n\n\t \n\tif (!vadc_get_channel(vadc, VADC_REF_1250MV)) {\n\t\tdev_err(vadc->dev, \"Please define 1.25V channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!vadc_get_channel(vadc, VADC_REF_625MV)) {\n\t\tdev_err(vadc->dev, \"Please define 0.625V channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!vadc_get_channel(vadc, VADC_VDD_VADC)) {\n\t\tdev_err(vadc->dev, \"Please define VDD channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!vadc_get_channel(vadc, VADC_GND_REF)) {\n\t\tdev_err(vadc->dev, \"Please define GND channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t vadc_isr(int irq, void *dev_id)\n{\n\tstruct vadc_priv *vadc = dev_id;\n\n\tcomplete(&vadc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vadc_check_revision(struct vadc_priv *vadc)\n{\n\tu8 val;\n\tint ret;\n\n\tret = vadc_read(vadc, VADC_PERPH_TYPE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < VADC_PERPH_TYPE_ADC) {\n\t\tdev_err(vadc->dev, \"%d is not ADC\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = vadc_read(vadc, VADC_PERPH_SUBTYPE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < VADC_PERPH_SUBTYPE_VADC) {\n\t\tdev_err(vadc->dev, \"%d is not VADC\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = vadc_read(vadc, VADC_REVISION2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < VADC_REVISION2_SUPPORTED_VADC) {\n\t\tdev_err(vadc->dev, \"revision %d not supported\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int vadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct vadc_priv *vadc;\n\tstruct regmap *regmap;\n\tint ret, irq_eoc;\n\tu32 reg;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(dev, \"reg\", &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*vadc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tvadc = iio_priv(indio_dev);\n\tvadc->regmap = regmap;\n\tvadc->dev = dev;\n\tvadc->base = reg;\n\tvadc->are_ref_measured = false;\n\tinit_completion(&vadc->complete);\n\tmutex_init(&vadc->lock);\n\n\tret = vadc_check_revision(vadc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vadc_get_fw_data(vadc);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_eoc = platform_get_irq(pdev, 0);\n\tif (irq_eoc < 0) {\n\t\tif (irq_eoc == -EPROBE_DEFER || irq_eoc == -EINVAL)\n\t\t\treturn irq_eoc;\n\t\tvadc->poll_eoc = true;\n\t} else {\n\t\tret = devm_request_irq(dev, irq_eoc, vadc_isr, 0,\n\t\t\t\t       \"spmi-vadc\", vadc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = vadc_reset(vadc);\n\tif (ret) {\n\t\tdev_err(dev, \"reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = vadc_measure_ref_points(vadc);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = pdev->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &vadc_info;\n\tindio_dev->channels = vadc->iio_chans;\n\tindio_dev->num_channels = vadc->nchannels;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id vadc_match_table[] = {\n\t{ .compatible = \"qcom,spmi-vadc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vadc_match_table);\n\nstatic struct platform_driver vadc_driver = {\n\t.driver = {\n\t\t   .name = \"qcom-spmi-vadc\",\n\t\t   .of_match_table = vadc_match_table,\n\t},\n\t.probe = vadc_probe,\n};\nmodule_platform_driver(vadc_driver);\n\nMODULE_ALIAS(\"platform:qcom-spmi-vadc\");\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC voltage ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Stanimir Varbanov <svarbanov@mm-sol.com>\");\nMODULE_AUTHOR(\"Ivan T. Ivanov <iivanov@mm-sol.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}