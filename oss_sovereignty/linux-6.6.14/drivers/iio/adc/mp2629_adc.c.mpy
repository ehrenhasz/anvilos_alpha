{
  "module_name": "mp2629_adc.c",
  "hash_id": "67b9987de401ddd4995a43f360aac0c15d4e515becd31d24889a398d5bdc8bf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mp2629_adc.c",
  "human_readable_source": "\n \n\n#include <linux/iio/driver.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n#include <linux/mfd/mp2629.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define\tMP2629_REG_ADC_CTRL\t\t0x03\n#define\tMP2629_REG_BATT_VOLT\t\t0x0e\n#define\tMP2629_REG_SYSTEM_VOLT\t\t0x0f\n#define\tMP2629_REG_INPUT_VOLT\t\t0x11\n#define\tMP2629_REG_BATT_CURRENT\t\t0x12\n#define\tMP2629_REG_INPUT_CURRENT\t0x13\n\n#define\tMP2629_ADC_START\t\tBIT(7)\n#define\tMP2629_ADC_CONTINUOUS\t\tBIT(6)\n\n#define MP2629_MAP(_mp, _mpc) IIO_MAP(#_mp, \"mp2629_charger\", \"mp2629-\"_mpc)\n\n#define MP2629_ADC_CHAN(_ch, _type) {\t\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.datasheet_name = #_ch,\t\t\t\t\t\\\n\t.channel = MP2629_ ## _ch,\t\t\t\t\\\n\t.address = MP2629_REG_ ## _ch,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstruct mp2629_adc {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n};\n\nstatic struct iio_chan_spec mp2629_channels[] = {\n\tMP2629_ADC_CHAN(BATT_VOLT, IIO_VOLTAGE),\n\tMP2629_ADC_CHAN(SYSTEM_VOLT, IIO_VOLTAGE),\n\tMP2629_ADC_CHAN(INPUT_VOLT, IIO_VOLTAGE),\n\tMP2629_ADC_CHAN(BATT_CURRENT, IIO_CURRENT),\n\tMP2629_ADC_CHAN(INPUT_CURRENT, IIO_CURRENT)\n};\n\nstatic struct iio_map mp2629_adc_maps[] = {\n\tMP2629_MAP(BATT_VOLT, \"batt-volt\"),\n\tMP2629_MAP(SYSTEM_VOLT, \"system-volt\"),\n\tMP2629_MAP(INPUT_VOLT, \"input-volt\"),\n\tMP2629_MAP(BATT_CURRENT, \"batt-current\"),\n\tMP2629_MAP(INPUT_CURRENT, \"input-current\"),\n\t{ }\n};\n\nstatic int mp2629_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct mp2629_adc *info = iio_priv(indio_dev);\n\tunsigned int rval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = regmap_read(info->regmap, chan->address, &rval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chan->channel == MP2629_INPUT_VOLT)\n\t\t\trval &= GENMASK(6, 0);\n\t\t*val = rval;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->channel) {\n\t\tcase MP2629_BATT_VOLT:\n\t\tcase MP2629_SYSTEM_VOLT:\n\t\t\t*val = 20;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase MP2629_INPUT_VOLT:\n\t\t\t*val = 60;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase MP2629_BATT_CURRENT:\n\t\t\t*val = 175;\n\t\t\t*val2 = 10;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase MP2629_INPUT_CURRENT:\n\t\t\t*val = 133;\n\t\t\t*val2 = 10;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mp2629_adc_info = {\n\t.read_raw = &mp2629_read_raw,\n};\n\nstatic int mp2629_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mp2629_data *ddata = dev_get_drvdata(dev->parent);\n\tstruct mp2629_adc *info;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->regmap = ddata->regmap;\n\tinfo->dev = dev;\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = regmap_update_bits(info->regmap, MP2629_REG_ADC_CTRL,\n\t\t\t\tMP2629_ADC_START | MP2629_ADC_CONTINUOUS,\n\t\t\t\tMP2629_ADC_START | MP2629_ADC_CONTINUOUS);\n\tif (ret) {\n\t\tdev_err(dev, \"adc enable fail: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iio_map_array_register(indio_dev, mp2629_adc_maps);\n\tif (ret) {\n\t\tdev_err(dev, \"IIO maps register fail: %d\\n\", ret);\n\t\tgoto fail_disable;\n\t}\n\n\tindio_dev->name = \"mp2629-adc\";\n\tindio_dev->channels = mp2629_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mp2629_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mp2629_adc_info;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"IIO device register fail: %d\\n\", ret);\n\t\tgoto fail_map_unregister;\n\t}\n\n\treturn 0;\n\nfail_map_unregister:\n\tiio_map_array_unregister(indio_dev);\n\nfail_disable:\n\tregmap_update_bits(info->regmap, MP2629_REG_ADC_CTRL,\n\t\t\t\t\t MP2629_ADC_CONTINUOUS, 0);\n\tregmap_update_bits(info->regmap, MP2629_REG_ADC_CTRL,\n\t\t\t\t\t MP2629_ADC_START, 0);\n\n\treturn ret;\n}\n\nstatic int mp2629_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct mp2629_adc *info = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tiio_map_array_unregister(indio_dev);\n\n\tregmap_update_bits(info->regmap, MP2629_REG_ADC_CTRL,\n\t\t\t\t\t MP2629_ADC_CONTINUOUS, 0);\n\tregmap_update_bits(info->regmap, MP2629_REG_ADC_CTRL,\n\t\t\t\t\t MP2629_ADC_START, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mp2629_adc_of_match[] = {\n\t{ .compatible = \"mps,mp2629_adc\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mp2629_adc_of_match);\n\nstatic struct platform_driver mp2629_adc_driver = {\n\t.driver = {\n\t\t.name = \"mp2629_adc\",\n\t\t.of_match_table = mp2629_adc_of_match,\n\t},\n\t.probe\t\t= mp2629_adc_probe,\n\t.remove\t\t= mp2629_adc_remove,\n};\nmodule_platform_driver(mp2629_adc_driver);\n\nMODULE_AUTHOR(\"Saravanan Sekar <sravanhome@gmail.com>\");\nMODULE_DESCRIPTION(\"MP2629 ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}