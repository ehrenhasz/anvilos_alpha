{
  "module_name": "imx7d_adc.c",
  "hash_id": "e21a0d8f3fbc29a724c9540ceac464040f4c4950dcf6d92151a2564ee48c8947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/imx7d_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/sysfs.h>\n\n \n#define IMX7D_REG_ADC_CH_A_CFG1\t\t\t0x00\n#define IMX7D_REG_ADC_CH_A_CFG2\t\t\t0x10\n#define IMX7D_REG_ADC_CH_B_CFG1\t\t\t0x20\n#define IMX7D_REG_ADC_CH_B_CFG2\t\t\t0x30\n#define IMX7D_REG_ADC_CH_C_CFG1\t\t\t0x40\n#define IMX7D_REG_ADC_CH_C_CFG2\t\t\t0x50\n#define IMX7D_REG_ADC_CH_D_CFG1\t\t\t0x60\n#define IMX7D_REG_ADC_CH_D_CFG2\t\t\t0x70\n#define IMX7D_REG_ADC_CH_SW_CFG\t\t\t0x80\n#define IMX7D_REG_ADC_TIMER_UNIT\t\t0x90\n#define IMX7D_REG_ADC_DMA_FIFO\t\t\t0xa0\n#define IMX7D_REG_ADC_FIFO_STATUS\t\t0xb0\n#define IMX7D_REG_ADC_INT_SIG_EN\t\t0xc0\n#define IMX7D_REG_ADC_INT_EN\t\t\t0xd0\n#define IMX7D_REG_ADC_INT_STATUS\t\t0xe0\n#define IMX7D_REG_ADC_CHA_B_CNV_RSLT\t\t0xf0\n#define IMX7D_REG_ADC_CHC_D_CNV_RSLT\t\t0x100\n#define IMX7D_REG_ADC_CH_SW_CNV_RSLT\t\t0x110\n#define IMX7D_REG_ADC_DMA_FIFO_DAT\t\t0x120\n#define IMX7D_REG_ADC_ADC_CFG\t\t\t0x130\n\n#define IMX7D_REG_ADC_CHANNEL_CFG2_BASE\t\t0x10\n#define IMX7D_EACH_CHANNEL_REG_OFFSET\t\t0x20\n\n#define IMX7D_REG_ADC_CH_CFG1_CHANNEL_EN\t\t\t(0x1 << 31)\n#define IMX7D_REG_ADC_CH_CFG1_CHANNEL_SINGLE\t\t\tBIT(30)\n#define IMX7D_REG_ADC_CH_CFG1_CHANNEL_AVG_EN\t\t\tBIT(29)\n#define IMX7D_REG_ADC_CH_CFG1_CHANNEL_SEL(x)\t\t\t((x) << 24)\n\n#define IMX7D_REG_ADC_CH_CFG2_AVG_NUM_4\t\t\t\t(0x0 << 12)\n#define IMX7D_REG_ADC_CH_CFG2_AVG_NUM_8\t\t\t\t(0x1 << 12)\n#define IMX7D_REG_ADC_CH_CFG2_AVG_NUM_16\t\t\t(0x2 << 12)\n#define IMX7D_REG_ADC_CH_CFG2_AVG_NUM_32\t\t\t(0x3 << 12)\n\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_4\t\t\t(0x0 << 29)\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_8\t\t\t(0x1 << 29)\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_16\t\t\t(0x2 << 29)\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_32\t\t\t(0x3 << 29)\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_64\t\t\t(0x4 << 29)\n#define IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_128\t\t\t(0x5 << 29)\n\n#define IMX7D_REG_ADC_ADC_CFG_ADC_CLK_DOWN\t\t\tBIT(31)\n#define IMX7D_REG_ADC_ADC_CFG_ADC_POWER_DOWN\t\t\tBIT(1)\n#define IMX7D_REG_ADC_ADC_CFG_ADC_EN\t\t\t\tBIT(0)\n\n#define IMX7D_REG_ADC_INT_CHA_COV_INT_EN\t\t\tBIT(8)\n#define IMX7D_REG_ADC_INT_CHB_COV_INT_EN\t\t\tBIT(9)\n#define IMX7D_REG_ADC_INT_CHC_COV_INT_EN\t\t\tBIT(10)\n#define IMX7D_REG_ADC_INT_CHD_COV_INT_EN\t\t\tBIT(11)\n#define IMX7D_REG_ADC_INT_CHANNEL_INT_EN \\\n\t(IMX7D_REG_ADC_INT_CHA_COV_INT_EN | \\\n\t IMX7D_REG_ADC_INT_CHB_COV_INT_EN | \\\n\t IMX7D_REG_ADC_INT_CHC_COV_INT_EN | \\\n\t IMX7D_REG_ADC_INT_CHD_COV_INT_EN)\n#define IMX7D_REG_ADC_INT_STATUS_CHANNEL_INT_STATUS\t\t0xf00\n#define IMX7D_REG_ADC_INT_STATUS_CHANNEL_CONV_TIME_OUT\t\t0xf0000\n\n#define IMX7D_ADC_TIMEOUT\t\tmsecs_to_jiffies(100)\n#define IMX7D_ADC_INPUT_CLK\t\t24000000\n\nenum imx7d_adc_clk_pre_div {\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_4,\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_8,\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_16,\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_32,\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_64,\n\tIMX7D_ADC_ANALOG_CLK_PRE_DIV_128,\n};\n\nenum imx7d_adc_average_num {\n\tIMX7D_ADC_AVERAGE_NUM_4,\n\tIMX7D_ADC_AVERAGE_NUM_8,\n\tIMX7D_ADC_AVERAGE_NUM_16,\n\tIMX7D_ADC_AVERAGE_NUM_32,\n};\n\nstruct imx7d_adc_feature {\n\tenum imx7d_adc_clk_pre_div clk_pre_div;\n\tenum imx7d_adc_average_num avg_num;\n\n\tu32 core_time_unit;\t \n};\n\nstruct imx7d_adc {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\t \n\tstruct mutex lock;\n\tu32 vref_uv;\n\tu32 value;\n\tu32 channel;\n\tu32 pre_div_num;\n\n\tstruct regulator *vref;\n\tstruct imx7d_adc_feature adc_feature;\n\n\tstruct completion completion;\n};\n\nstruct imx7d_adc_analogue_core_clk {\n\tu32 pre_div;\n\tu32 reg_config;\n};\n\n#define IMX7D_ADC_ANALOGUE_CLK_CONFIG(_pre_div, _reg_conf) {\t\\\n\t.pre_div = (_pre_div),\t\t\t\t\t\\\n\t.reg_config = (_reg_conf),\t\t\t\t\\\n}\n\nstatic const struct imx7d_adc_analogue_core_clk imx7d_adc_analogue_clk[] = {\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(4, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_4),\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(8, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_8),\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(16, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_16),\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(32, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_32),\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(64, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_64),\n\tIMX7D_ADC_ANALOGUE_CLK_CONFIG(128, IMX7D_REG_ADC_TIMER_UNIT_PRE_DIV_128),\n};\n\n#define IMX7D_ADC_CHAN(_idx) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (_idx),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n}\n\nstatic const struct iio_chan_spec imx7d_adc_iio_channels[] = {\n\tIMX7D_ADC_CHAN(0),\n\tIMX7D_ADC_CHAN(1),\n\tIMX7D_ADC_CHAN(2),\n\tIMX7D_ADC_CHAN(3),\n\tIMX7D_ADC_CHAN(4),\n\tIMX7D_ADC_CHAN(5),\n\tIMX7D_ADC_CHAN(6),\n\tIMX7D_ADC_CHAN(7),\n\tIMX7D_ADC_CHAN(8),\n\tIMX7D_ADC_CHAN(9),\n\tIMX7D_ADC_CHAN(10),\n\tIMX7D_ADC_CHAN(11),\n\tIMX7D_ADC_CHAN(12),\n\tIMX7D_ADC_CHAN(13),\n\tIMX7D_ADC_CHAN(14),\n\tIMX7D_ADC_CHAN(15),\n};\n\nstatic const u32 imx7d_adc_average_num[] = {\n\tIMX7D_REG_ADC_CH_CFG2_AVG_NUM_4,\n\tIMX7D_REG_ADC_CH_CFG2_AVG_NUM_8,\n\tIMX7D_REG_ADC_CH_CFG2_AVG_NUM_16,\n\tIMX7D_REG_ADC_CH_CFG2_AVG_NUM_32,\n};\n\nstatic void imx7d_adc_feature_config(struct imx7d_adc *info)\n{\n\tinfo->adc_feature.clk_pre_div = IMX7D_ADC_ANALOG_CLK_PRE_DIV_4;\n\tinfo->adc_feature.avg_num = IMX7D_ADC_AVERAGE_NUM_32;\n\tinfo->adc_feature.core_time_unit = 1;\n}\n\nstatic void imx7d_adc_sample_rate_set(struct imx7d_adc *info)\n{\n\tstruct imx7d_adc_feature *adc_feature = &info->adc_feature;\n\tstruct imx7d_adc_analogue_core_clk adc_analogure_clk;\n\tu32 i;\n\tu32 tmp_cfg1;\n\tu32 sample_rate = 0;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\ttmp_cfg1 =\n\t\t\treadl(info->regs + i * IMX7D_EACH_CHANNEL_REG_OFFSET);\n\t\ttmp_cfg1 &= ~IMX7D_REG_ADC_CH_CFG1_CHANNEL_EN;\n\t\twritel(tmp_cfg1,\n\t\t       info->regs + i * IMX7D_EACH_CHANNEL_REG_OFFSET);\n\t}\n\n\tadc_analogure_clk = imx7d_adc_analogue_clk[adc_feature->clk_pre_div];\n\tsample_rate |= adc_analogure_clk.reg_config;\n\tinfo->pre_div_num = adc_analogure_clk.pre_div;\n\n\tsample_rate |= adc_feature->core_time_unit;\n\twritel(sample_rate, info->regs + IMX7D_REG_ADC_TIMER_UNIT);\n}\n\nstatic void imx7d_adc_hw_init(struct imx7d_adc *info)\n{\n\tu32 cfg;\n\n\t \n\tcfg = readl(info->regs + IMX7D_REG_ADC_ADC_CFG);\n\tcfg &= ~(IMX7D_REG_ADC_ADC_CFG_ADC_CLK_DOWN |\n\t\t IMX7D_REG_ADC_ADC_CFG_ADC_POWER_DOWN);\n\tcfg |= IMX7D_REG_ADC_ADC_CFG_ADC_EN;\n\twritel(cfg, info->regs + IMX7D_REG_ADC_ADC_CFG);\n\n\t \n\twritel(IMX7D_REG_ADC_INT_CHANNEL_INT_EN,\n\t       info->regs + IMX7D_REG_ADC_INT_SIG_EN);\n\twritel(IMX7D_REG_ADC_INT_CHANNEL_INT_EN,\n\t       info->regs + IMX7D_REG_ADC_INT_EN);\n\n\timx7d_adc_sample_rate_set(info);\n}\n\nstatic void imx7d_adc_channel_set(struct imx7d_adc *info)\n{\n\tu32 cfg1 = 0;\n\tu32 cfg2;\n\tu32 channel;\n\n\tchannel = info->channel;\n\n\t \n\tcfg1 |= (IMX7D_REG_ADC_CH_CFG1_CHANNEL_EN |\n\t\t IMX7D_REG_ADC_CH_CFG1_CHANNEL_SINGLE |\n\t\t IMX7D_REG_ADC_CH_CFG1_CHANNEL_AVG_EN);\n\n\t \n\tcfg1 |= IMX7D_REG_ADC_CH_CFG1_CHANNEL_SEL(channel);\n\n\t \n\tcfg2 = readl(info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel +\n\t\t     IMX7D_REG_ADC_CHANNEL_CFG2_BASE);\n\n\tcfg2 |= imx7d_adc_average_num[info->adc_feature.avg_num];\n\n\t \n\twritel(cfg2, info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel +\n\t       IMX7D_REG_ADC_CHANNEL_CFG2_BASE);\n\twritel(cfg1, info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel);\n}\n\nstatic u32 imx7d_adc_get_sample_rate(struct imx7d_adc *info)\n{\n\tu32 analogue_core_clk;\n\tu32 core_time_unit = info->adc_feature.core_time_unit;\n\tu32 tmp;\n\n\tanalogue_core_clk = IMX7D_ADC_INPUT_CLK / info->pre_div_num;\n\ttmp = (core_time_unit + 1) * 6;\n\n\treturn analogue_core_clk / tmp;\n}\n\nstatic int imx7d_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val,\n\t\t\tint *val2,\n\t\t\tlong mask)\n{\n\tstruct imx7d_adc *info = iio_priv(indio_dev);\n\n\tu32 channel;\n\tlong ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&info->lock);\n\t\treinit_completion(&info->completion);\n\n\t\tchannel = chan->channel & 0x03;\n\t\tinfo->channel = channel;\n\t\timx7d_adc_channel_set(info);\n\n\t\tret = wait_for_completion_interruptible_timeout\n\t\t\t\t(&info->completion, IMX7D_ADC_TIMEOUT);\n\t\tif (ret == 0) {\n\t\t\tmutex_unlock(&info->lock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&info->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = info->value;\n\t\tmutex_unlock(&info->lock);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tinfo->vref_uv = regulator_get_voltage(info->vref);\n\t\t*val = info->vref_uv / 1000;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = imx7d_adc_get_sample_rate(info);\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int imx7d_adc_read_data(struct imx7d_adc *info)\n{\n\tu32 channel;\n\tu32 value;\n\n\tchannel = info->channel & 0x03;\n\n\t \n\tif (channel < 2)\n\t\tvalue = readl(info->regs + IMX7D_REG_ADC_CHA_B_CNV_RSLT);\n\telse\n\t\tvalue = readl(info->regs + IMX7D_REG_ADC_CHC_D_CNV_RSLT);\n\tif (channel & 0x1)\t \n\t\tvalue = (value >> 16) & 0xFFF;\n\telse\t\t\t \n\t\tvalue &= 0xFFF;\n\n\treturn value;\n}\n\nstatic irqreturn_t imx7d_adc_isr(int irq, void *dev_id)\n{\n\tstruct imx7d_adc *info = dev_id;\n\tint status;\n\n\tstatus = readl(info->regs + IMX7D_REG_ADC_INT_STATUS);\n\tif (status & IMX7D_REG_ADC_INT_STATUS_CHANNEL_INT_STATUS) {\n\t\tinfo->value = imx7d_adc_read_data(info);\n\t\tcomplete(&info->completion);\n\n\t\t \n\t\tstatus &= ~IMX7D_REG_ADC_INT_STATUS_CHANNEL_INT_STATUS;\n\t\twritel(status, info->regs + IMX7D_REG_ADC_INT_STATUS);\n\t}\n\n\t \n\tif (status & IMX7D_REG_ADC_INT_STATUS_CHANNEL_CONV_TIME_OUT) {\n\t\tdev_err(info->dev,\n\t\t\t\"ADC got conversion time out interrupt: 0x%08x\\n\",\n\t\t\tstatus);\n\t\tstatus &= ~IMX7D_REG_ADC_INT_STATUS_CHANNEL_CONV_TIME_OUT;\n\t\twritel(status, info->regs + IMX7D_REG_ADC_INT_STATUS);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx7d_adc_reg_access(struct iio_dev *indio_dev,\n\t\t\tunsigned reg, unsigned writeval,\n\t\t\tunsigned *readval)\n{\n\tstruct imx7d_adc *info = iio_priv(indio_dev);\n\n\tif (!readval || reg % 4 || reg > IMX7D_REG_ADC_ADC_CFG)\n\t\treturn -EINVAL;\n\n\t*readval = readl(info->regs + reg);\n\n\treturn 0;\n}\n\nstatic const struct iio_info imx7d_adc_iio_info = {\n\t.read_raw = &imx7d_adc_read_raw,\n\t.debugfs_reg_access = &imx7d_adc_reg_access,\n};\n\nstatic const struct of_device_id imx7d_adc_match[] = {\n\t{ .compatible = \"fsl,imx7d-adc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx7d_adc_match);\n\nstatic void imx7d_adc_power_down(struct imx7d_adc *info)\n{\n\tu32 adc_cfg;\n\n\tadc_cfg = readl(info->regs + IMX7D_REG_ADC_ADC_CFG);\n\tadc_cfg |= IMX7D_REG_ADC_ADC_CFG_ADC_CLK_DOWN |\n\t\t   IMX7D_REG_ADC_ADC_CFG_ADC_POWER_DOWN;\n\tadc_cfg &= ~IMX7D_REG_ADC_ADC_CFG_ADC_EN;\n\twritel(adc_cfg, info->regs + IMX7D_REG_ADC_ADC_CFG);\n}\n\nstatic int imx7d_adc_enable(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx7d_adc *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(info->vref);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"Can't enable adc reference top voltage, err = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"Could not prepare or enable clock.\\n\");\n\t\tregulator_disable(info->vref);\n\t\treturn ret;\n\t}\n\n\timx7d_adc_hw_init(info);\n\n\treturn 0;\n}\n\nstatic int imx7d_adc_disable(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx7d_adc *info = iio_priv(indio_dev);\n\n\timx7d_adc_power_down(info);\n\n\tclk_disable_unprepare(info->clk);\n\tregulator_disable(info->vref);\n\n\treturn 0;\n}\n\nstatic void __imx7d_adc_disable(void *data)\n{\n\timx7d_adc_disable(data);\n}\n\nstatic int imx7d_adc_probe(struct platform_device *pdev)\n{\n\tstruct imx7d_adc *info;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*info));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"Failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->dev = dev;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinfo->clk = devm_clk_get(dev, \"adc\");\n\tif (IS_ERR(info->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->clk), \"Failed getting clock\\n\");\n\n\tinfo->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(info->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->vref),\n\t\t\t\t     \"Failed getting reference voltage\\n\");\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinit_completion(&info->completion);\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &imx7d_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = imx7d_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(imx7d_adc_iio_channels);\n\n\tret = devm_request_irq(dev, irq, imx7d_adc_isr, 0, dev_name(dev), info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed requesting irq, irq = %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\timx7d_adc_feature_config(info);\n\n\tret = imx7d_adc_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, __imx7d_adc_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&info->lock);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register the device.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(imx7d_adc_pm_ops, imx7d_adc_disable,\n\t\t\t\timx7d_adc_enable);\n\nstatic struct platform_driver imx7d_adc_driver = {\n\t.probe\t\t= imx7d_adc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"imx7d_adc\",\n\t\t.of_match_table = imx7d_adc_match,\n\t\t.pm\t= pm_sleep_ptr(&imx7d_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(imx7d_adc_driver);\n\nMODULE_AUTHOR(\"Haibo Chen <haibo.chen@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale IMX7D ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}