{
  "module_name": "spear_adc.c",
  "hash_id": "927476f2a1e1d683906a187430e893e89defe63df89ad1ba2759538c695db40c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/spear_adc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define SPEAR600_ADC_SCAN_RATE_LO(x)\t((x) & 0xFFFF)\n#define SPEAR600_ADC_SCAN_RATE_HI(x)\t(((x) >> 0x10) & 0xFFFF)\n#define SPEAR_ADC_CLK_LOW(x)\t\t(((x) & 0xf) << 0)\n#define SPEAR_ADC_CLK_HIGH(x)\t\t(((x) & 0xf) << 4)\n\n \n#define SPEAR_ADC_STATUS_START_CONVERSION\tBIT(0)\n#define SPEAR_ADC_STATUS_CHANNEL_NUM(x)\t\t((x) << 1)\n#define SPEAR_ADC_STATUS_ADC_ENABLE\t\tBIT(4)\n#define SPEAR_ADC_STATUS_AVG_SAMPLE(x)\t\t((x) << 5)\n#define SPEAR_ADC_STATUS_VREF_INTERNAL\t\tBIT(9)\n\n#define SPEAR_ADC_DATA_MASK\t\t0x03ff\n#define SPEAR_ADC_DATA_BITS\t\t10\n\n#define SPEAR_ADC_MOD_NAME \"spear-adc\"\n\n#define SPEAR_ADC_CHANNEL_NUM\t\t8\n\n#define SPEAR_ADC_CLK_MIN\t\t\t2500000\n#define SPEAR_ADC_CLK_MAX\t\t\t20000000\n\nstruct adc_regs_spear3xx {\n\tu32 status;\n\tu32 average;\n\tu32 scan_rate;\n\tu32 clk;\t \n\tu32 ch_ctrl[SPEAR_ADC_CHANNEL_NUM];\n\tu32 ch_data[SPEAR_ADC_CHANNEL_NUM];\n};\n\nstruct chan_data {\n\tu32 lsb;\n\tu32 msb;\n};\n\nstruct adc_regs_spear6xx {\n\tu32 status;\n\tu32 pad[2];\n\tu32 clk;\n\tu32 ch_ctrl[SPEAR_ADC_CHANNEL_NUM];\n\tstruct chan_data ch_data[SPEAR_ADC_CHANNEL_NUM];\n\tu32 scan_rate_lo;\n\tu32 scan_rate_hi;\n\tstruct chan_data average;\n};\n\nstruct spear_adc_state {\n\tstruct device_node *np;\n\tstruct adc_regs_spear3xx __iomem *adc_base_spear3xx;\n\tstruct adc_regs_spear6xx __iomem *adc_base_spear6xx;\n\tstruct clk *clk;\n\tstruct completion completion;\n\t \n\tstruct mutex lock;\n\tu32 current_clk;\n\tu32 sampling_freq;\n\tu32 avg_samples;\n\tu32 vref_external;\n\tu32 value;\n};\n\n \nstatic void spear_adc_set_status(struct spear_adc_state *st, u32 val)\n{\n\t__raw_writel(val, &st->adc_base_spear6xx->status);\n}\n\nstatic void spear_adc_set_clk(struct spear_adc_state *st, u32 val)\n{\n\tu32 clk_high, clk_low, count;\n\tu32 apb_clk = clk_get_rate(st->clk);\n\n\tcount = DIV_ROUND_UP(apb_clk, val);\n\tclk_low = count / 2;\n\tclk_high = count - clk_low;\n\tst->current_clk = apb_clk / count;\n\n\t__raw_writel(SPEAR_ADC_CLK_LOW(clk_low) | SPEAR_ADC_CLK_HIGH(clk_high),\n\t\t     &st->adc_base_spear6xx->clk);\n}\n\nstatic void spear_adc_set_ctrl(struct spear_adc_state *st, int n,\n\t\t\t       u32 val)\n{\n\t__raw_writel(val, &st->adc_base_spear6xx->ch_ctrl[n]);\n}\n\nstatic u32 spear_adc_get_average(struct spear_adc_state *st)\n{\n\tif (of_device_is_compatible(st->np, \"st,spear600-adc\")) {\n\t\treturn __raw_readl(&st->adc_base_spear6xx->average.msb) &\n\t\t\tSPEAR_ADC_DATA_MASK;\n\t} else {\n\t\treturn __raw_readl(&st->adc_base_spear3xx->average) &\n\t\t\tSPEAR_ADC_DATA_MASK;\n\t}\n}\n\nstatic void spear_adc_set_scanrate(struct spear_adc_state *st, u32 rate)\n{\n\tif (of_device_is_compatible(st->np, \"st,spear600-adc\")) {\n\t\t__raw_writel(SPEAR600_ADC_SCAN_RATE_LO(rate),\n\t\t\t     &st->adc_base_spear6xx->scan_rate_lo);\n\t\t__raw_writel(SPEAR600_ADC_SCAN_RATE_HI(rate),\n\t\t\t     &st->adc_base_spear6xx->scan_rate_hi);\n\t} else {\n\t\t__raw_writel(rate, &st->adc_base_spear3xx->scan_rate);\n\t}\n}\n\nstatic int spear_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val,\n\t\t\t      int *val2,\n\t\t\t      long mask)\n{\n\tstruct spear_adc_state *st = iio_priv(indio_dev);\n\tu32 status;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\n\t\tstatus = SPEAR_ADC_STATUS_CHANNEL_NUM(chan->channel) |\n\t\t\tSPEAR_ADC_STATUS_AVG_SAMPLE(st->avg_samples) |\n\t\t\tSPEAR_ADC_STATUS_START_CONVERSION |\n\t\t\tSPEAR_ADC_STATUS_ADC_ENABLE;\n\t\tif (st->vref_external == 0)\n\t\t\tstatus |= SPEAR_ADC_STATUS_VREF_INTERNAL;\n\n\t\tspear_adc_set_status(st, status);\n\t\twait_for_completion(&st->completion);  \n\t\t*val = st->value;\n\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_external;\n\t\t*val2 = SPEAR_ADC_DATA_BITS;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->current_clk;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int spear_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct spear_adc_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (mask != IIO_CHAN_INFO_SAMP_FREQ)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\n\tif ((val < SPEAR_ADC_CLK_MIN) ||\n\t    (val > SPEAR_ADC_CLK_MAX) ||\n\t    (val2 != 0)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tspear_adc_set_clk(st, val);\n\nout:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n#define SPEAR_ADC_CHAN(idx) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\\\n\t.channel = idx,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec spear_adc_iio_channels[] = {\n\tSPEAR_ADC_CHAN(0),\n\tSPEAR_ADC_CHAN(1),\n\tSPEAR_ADC_CHAN(2),\n\tSPEAR_ADC_CHAN(3),\n\tSPEAR_ADC_CHAN(4),\n\tSPEAR_ADC_CHAN(5),\n\tSPEAR_ADC_CHAN(6),\n\tSPEAR_ADC_CHAN(7),\n};\n\nstatic irqreturn_t spear_adc_isr(int irq, void *dev_id)\n{\n\tstruct spear_adc_state *st = dev_id;\n\n\t \n\tst->value = spear_adc_get_average(st);\n\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spear_adc_configure(struct spear_adc_state *st)\n{\n\tint i;\n\n\t \n\tspear_adc_set_status(st, 0);\n\t__raw_writel(0, &st->adc_base_spear6xx->clk);\n\tfor (i = 0; i < 8; i++)\n\t\tspear_adc_set_ctrl(st, i, 0);\n\tspear_adc_set_scanrate(st, 0);\n\n\tspear_adc_set_clk(st, st->sampling_freq);\n\n\treturn 0;\n}\n\nstatic const struct iio_info spear_adc_info = {\n\t.read_raw = &spear_adc_read_raw,\n\t.write_raw = &spear_adc_write_raw,\n};\n\nstatic int spear_adc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct spear_adc_state *st;\n\tstruct iio_dev *indio_dev = NULL;\n\tint ret = -ENODEV;\n\tint irq;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(struct spear_adc_state));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\tst->np = np;\n\n\t \n\tst->adc_base_spear6xx = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(st->adc_base_spear6xx))\n\t\treturn PTR_ERR(st->adc_base_spear6xx);\n\n\tst->adc_base_spear3xx =\n\t\t(struct adc_regs_spear3xx __iomem *)st->adc_base_spear6xx;\n\n\tst->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(st->clk)) {\n\t\tdev_err(dev, \"failed getting clock\\n\");\n\t\treturn PTR_ERR(st->clk);\n\t}\n\n\tret = clk_prepare_enable(st->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed enabling clock\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto errout2;\n\t}\n\n\tret = devm_request_irq(dev, irq, spear_adc_isr, 0, SPEAR_ADC_MOD_NAME,\n\t\t\t       st);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed requesting interrupt\\n\");\n\t\tgoto errout2;\n\t}\n\n\tif (of_property_read_u32(np, \"sampling-frequency\",\n\t\t\t\t &st->sampling_freq)) {\n\t\tdev_err(dev, \"sampling-frequency missing in DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto errout2;\n\t}\n\n\t \n\tof_property_read_u32(np, \"average-samples\", &st->avg_samples);\n\n\t \n\tof_property_read_u32(np, \"vref-external\", &st->vref_external);\n\n\tspear_adc_configure(st);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinit_completion(&st->completion);\n\n\tindio_dev->name = SPEAR_ADC_MOD_NAME;\n\tindio_dev->info = &spear_adc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = spear_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(spear_adc_iio_channels);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto errout2;\n\n\tdev_info(dev, \"SPEAR ADC driver loaded, IRQ %d\\n\", irq);\n\n\treturn 0;\n\nerrout2:\n\tclk_disable_unprepare(st->clk);\n\treturn ret;\n}\n\nstatic int spear_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct spear_adc_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tclk_disable_unprepare(st->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spear_adc_dt_ids[] = {\n\t{ .compatible = \"st,spear600-adc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, spear_adc_dt_ids);\n#endif\n\nstatic struct platform_driver spear_adc_driver = {\n\t.probe\t\t= spear_adc_probe,\n\t.remove\t\t= spear_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= SPEAR_ADC_MOD_NAME,\n\t\t.of_match_table = of_match_ptr(spear_adc_dt_ids),\n\t},\n};\n\nmodule_platform_driver(spear_adc_driver);\n\nMODULE_AUTHOR(\"Stefan Roese <sr@denx.de>\");\nMODULE_DESCRIPTION(\"SPEAr ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}