{
  "module_name": "stmpe-adc.c",
  "hash_id": "c184687dbbd53e3c94f5551aa9194145fe09d453b24bbf15319abf17baa6dd42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/stmpe-adc.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/stmpe.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/device.h>\n\n#define STMPE_REG_INT_STA\t\t0x0B\n#define STMPE_REG_ADC_INT_EN\t\t0x0E\n#define STMPE_REG_ADC_INT_STA\t\t0x0F\n\n#define STMPE_REG_ADC_CTRL1\t\t0x20\n#define STMPE_REG_ADC_CTRL2\t\t0x21\n#define STMPE_REG_ADC_CAPT\t\t0x22\n#define STMPE_REG_ADC_DATA_CH(channel)\t(0x30 + 2 * (channel))\n\n#define STMPE_REG_TEMP_CTRL\t\t0x60\n#define STMPE_TEMP_CTRL_ENABLE\t\tBIT(0)\n#define STMPE_TEMP_CTRL_ACQ\t\tBIT(1)\n#define STMPE_TEMP_CTRL_THRES_EN\tBIT(3)\n#define STMPE_START_ONE_TEMP_CONV\t(STMPE_TEMP_CTRL_ENABLE | \\\n\t\t\t\t\tSTMPE_TEMP_CTRL_ACQ | \\\n\t\t\t\t\tSTMPE_TEMP_CTRL_THRES_EN)\n#define STMPE_REG_TEMP_DATA\t\t0x61\n#define STMPE_REG_TEMP_TH\t\t0x63\n#define STMPE_ADC_LAST_NR\t\t7\n#define STMPE_TEMP_CHANNEL\t\t(STMPE_ADC_LAST_NR + 1)\n\n#define STMPE_ADC_CH(channel)\t\t((1 << (channel)) & 0xff)\n\n#define STMPE_ADC_TIMEOUT\t\tmsecs_to_jiffies(1000)\n\nstruct stmpe_adc {\n\tstruct stmpe *stmpe;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tstruct mutex lock;\n\n\t \n\tstruct iio_chan_spec stmpe_adc_iio_channels[STMPE_ADC_LAST_NR + 2];\n\n\tstruct completion completion;\n\n\tu8 channel;\n\tu32 value;\n};\n\nstatic int stmpe_read_voltage(struct stmpe_adc *info,\n\t\tstruct iio_chan_spec const *chan, int *val)\n{\n\tunsigned long ret;\n\n\tmutex_lock(&info->lock);\n\n\treinit_completion(&info->completion);\n\n\tinfo->channel = (u8)chan->channel;\n\n\tif (info->channel > STMPE_ADC_LAST_NR) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tstmpe_reg_write(info->stmpe, STMPE_REG_ADC_CAPT,\n\t\t\tSTMPE_ADC_CH(info->channel));\n\n\tret = wait_for_completion_timeout(&info->completion, STMPE_ADC_TIMEOUT);\n\n\tif (ret == 0) {\n\t\tstmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_STA,\n\t\t\t\tSTMPE_ADC_CH(info->channel));\n\t\tmutex_unlock(&info->lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*val = info->value;\n\n\tmutex_unlock(&info->lock);\n\n\treturn 0;\n}\n\nstatic int stmpe_read_temp(struct stmpe_adc *info,\n\t\tstruct iio_chan_spec const *chan, int *val)\n{\n\tunsigned long ret;\n\n\tmutex_lock(&info->lock);\n\n\treinit_completion(&info->completion);\n\n\tinfo->channel = (u8)chan->channel;\n\n\tif (info->channel != STMPE_TEMP_CHANNEL) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tstmpe_reg_write(info->stmpe, STMPE_REG_TEMP_CTRL,\n\t\t\tSTMPE_START_ONE_TEMP_CONV);\n\n\tret = wait_for_completion_timeout(&info->completion, STMPE_ADC_TIMEOUT);\n\n\tif (ret == 0) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\t*val = ((449960l * info->value) / 1024l) - 273150;\n\n\tmutex_unlock(&info->lock);\n\n\treturn 0;\n}\n\nstatic int stmpe_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val,\n\t\t\t  int *val2,\n\t\t\t  long mask)\n{\n\tstruct stmpe_adc *info = iio_priv(indio_dev);\n\tlong ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tret = stmpe_read_voltage(info, chan, val);\n\t\t\tbreak;\n\n\t\tcase IIO_TEMP:\n\t\t\tret = stmpe_read_temp(info, chan, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 3300;\n\t\t*val2 = info->stmpe->mod_12b ? 12 : 10;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t stmpe_adc_isr(int irq, void *dev_id)\n{\n\tstruct stmpe_adc *info = (struct stmpe_adc *)dev_id;\n\t__be16 data;\n\n\tif (info->channel <= STMPE_ADC_LAST_NR) {\n\t\tint int_sta;\n\n\t\tint_sta = stmpe_reg_read(info->stmpe, STMPE_REG_ADC_INT_STA);\n\n\t\t \n\t\tif (!(int_sta & STMPE_ADC_CH(info->channel)))\n\t\t\treturn IRQ_NONE;\n\n\t\t \n\t\tstmpe_block_read(info->stmpe,\n\t\t\tSTMPE_REG_ADC_DATA_CH(info->channel), 2, (u8 *) &data);\n\n\t\tstmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_STA, int_sta);\n\t} else if (info->channel == STMPE_TEMP_CHANNEL) {\n\t\t \n\t\tstmpe_block_read(info->stmpe, STMPE_REG_TEMP_DATA, 2,\n\t\t\t\t(u8 *) &data);\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n\n\tinfo->value = (u32) be16_to_cpu(data);\n\tcomplete(&info->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info stmpe_adc_iio_info = {\n\t.read_raw = &stmpe_read_raw,\n};\n\nstatic void stmpe_adc_voltage_chan(struct iio_chan_spec *ics, int chan)\n{\n\tics->type = IIO_VOLTAGE;\n\tics->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tics->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\tics->indexed = 1;\n\tics->channel = chan;\n}\n\nstatic void stmpe_adc_temp_chan(struct iio_chan_spec *ics, int chan)\n{\n\tics->type = IIO_TEMP;\n\tics->info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED);\n\tics->indexed = 1;\n\tics->channel = chan;\n}\n\nstatic int stmpe_adc_init_hw(struct stmpe_adc *adc)\n{\n\tint ret;\n\tstruct stmpe *stmpe = adc->stmpe;\n\n\tret = stmpe_enable(stmpe, STMPE_BLOCK_ADC);\n\tif (ret) {\n\t\tdev_err(stmpe->dev, \"Could not enable clock for ADC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe811_adc_common_init(stmpe);\n\tif (ret) {\n\t\tstmpe_disable(stmpe, STMPE_BLOCK_ADC);\n\t\treturn ret;\n\t}\n\n\t \n\tstmpe_reg_write(stmpe, STMPE_REG_TEMP_TH, 0);\n\tstmpe_reg_write(stmpe, STMPE_REG_TEMP_TH + 1, 0);\n\n\treturn 0;\n}\n\nstatic int stmpe_adc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct stmpe_adc *info;\n\tstruct device_node *np;\n\tu32 norequest_mask = 0;\n\tunsigned long bits;\n\tint irq_temp, irq_adc;\n\tint num_chan = 0;\n\tint i = 0;\n\tint ret;\n\n\tirq_adc = platform_get_irq_byname(pdev, \"STMPE_ADC\");\n\tif (irq_adc < 0)\n\t\treturn irq_adc;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct stmpe_adc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo = iio_priv(indio_dev);\n\tmutex_init(&info->lock);\n\n\tinit_completion(&info->completion);\n\tret = devm_request_threaded_irq(&pdev->dev, irq_adc, NULL,\n\t\t\t\t\tstmpe_adc_isr, IRQF_ONESHOT,\n\t\t\t\t\t\"stmpe-adc\", info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed requesting irq, irq = %d\\n\",\n\t\t\t\tirq_adc);\n\t\treturn ret;\n\t}\n\n\tirq_temp = platform_get_irq_byname(pdev, \"STMPE_TEMP_SENS\");\n\tif (irq_temp >= 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq_temp, NULL,\n\t\t\t\t\t\tstmpe_adc_isr, IRQF_ONESHOT,\n\t\t\t\t\t\t\"stmpe-adc\", info);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&pdev->dev, \"failed requesting irq for\"\n\t\t\t\t \" temp sensor, irq = %d\\n\", irq_temp);\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name\t\t= dev_name(&pdev->dev);\n\tindio_dev->info\t\t= &stmpe_adc_iio_info;\n\tindio_dev->modes\t= INDIO_DIRECT_MODE;\n\n\tinfo->stmpe = dev_get_drvdata(pdev->dev.parent);\n\n\tnp = pdev->dev.of_node;\n\n\tif (!np)\n\t\tdev_err(&pdev->dev, \"no device tree node found\\n\");\n\n\tof_property_read_u32(np, \"st,norequest-mask\", &norequest_mask);\n\n\tbits = norequest_mask;\n\tfor_each_clear_bit(i, &bits, (STMPE_ADC_LAST_NR + 1)) {\n\t\tstmpe_adc_voltage_chan(&info->stmpe_adc_iio_channels[num_chan], i);\n\t\tnum_chan++;\n\t}\n\tstmpe_adc_temp_chan(&info->stmpe_adc_iio_channels[num_chan], i);\n\tnum_chan++;\n\tindio_dev->channels = info->stmpe_adc_iio_channels;\n\tindio_dev->num_channels = num_chan;\n\n\tret = stmpe_adc_init_hw(info);\n\tif (ret)\n\t\treturn ret;\n\n\tstmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_EN,\n\t\t\t~(norequest_mask & 0xFF));\n\n\tstmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_STA,\n\t\t\t~(norequest_mask & 0xFF));\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic int stmpe_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct stmpe_adc *info = iio_priv(indio_dev);\n\n\tstmpe_adc_init_hw(info);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stmpe_adc_pm_ops, NULL, stmpe_adc_resume);\n\nstatic const struct of_device_id stmpe_adc_ids[] = {\n\t{ .compatible = \"st,stmpe-adc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stmpe_adc_ids);\n\nstatic struct platform_driver stmpe_adc_driver = {\n\t.probe\t\t= stmpe_adc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"stmpe-adc\",\n\t\t.pm\t= pm_sleep_ptr(&stmpe_adc_pm_ops),\n\t\t.of_match_table = stmpe_adc_ids,\n\t},\n};\nmodule_platform_driver(stmpe_adc_driver);\n\nMODULE_AUTHOR(\"Stefan Agner <stefan.agner@toradex.com>\");\nMODULE_DESCRIPTION(\"STMPEXXX ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:stmpe-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}