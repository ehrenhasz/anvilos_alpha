{
  "module_name": "ti-ads131e08.c",
  "hash_id": "458e07836236d19cb06249a588a616fab5574c6b376afec18f7c095b17c41921",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads131e08.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADS131E08_CMD_RESET\t\t0x06\n#define ADS131E08_CMD_START\t\t0x08\n#define ADS131E08_CMD_STOP\t\t0x0A\n#define ADS131E08_CMD_OFFSETCAL\t\t0x1A\n#define ADS131E08_CMD_SDATAC\t\t0x11\n#define ADS131E08_CMD_RDATA\t\t0x12\n#define ADS131E08_CMD_RREG(r)\t\t(BIT(5) | (r & GENMASK(4, 0)))\n#define ADS131E08_CMD_WREG(r)\t\t(BIT(6) | (r & GENMASK(4, 0)))\n\n \n#define ADS131E08_ADR_CFG1R\t\t0x01\n#define ADS131E08_ADR_CFG3R\t\t0x03\n#define ADS131E08_ADR_CH0R\t\t0x05\n\n \n#define ADS131E08_CFG1R_DR_MASK\t\tGENMASK(2, 0)\n\n \n#define ADS131E08_CFG3R_PDB_REFBUF_MASK\tBIT(7)\n#define ADS131E08_CFG3R_VREF_4V_MASK\tBIT(5)\n\n \n#define ADS131E08_CHR_GAIN_MASK\t\tGENMASK(6, 4)\n#define ADS131E08_CHR_MUX_MASK\t\tGENMASK(2, 0)\n#define ADS131E08_CHR_PWD_MASK\t\tBIT(7)\n\n \n#define ADS131E08_DEFAULT_DATA_RATE\t1\n#define ADS131E08_DEFAULT_PGA_GAIN\t1\n#define ADS131E08_DEFAULT_MUX\t\t0\n\n#define ADS131E08_VREF_2V4_mV\t\t2400\n#define ADS131E08_VREF_4V_mV\t\t4000\n\n#define ADS131E08_WAIT_RESET_CYCLES\t18\n#define ADS131E08_WAIT_SDECODE_CYCLES\t4\n#define ADS131E08_WAIT_OFFSETCAL_MS\t153\n#define ADS131E08_MAX_SETTLING_TIME_MS\t6\n\n#define ADS131E08_NUM_STATUS_BYTES\t3\n#define ADS131E08_NUM_DATA_BYTES_MAX\t24\n#define ADS131E08_NUM_DATA_BYTES(dr)\t(((dr) >= 32) ? 2 : 3)\n#define ADS131E08_NUM_DATA_BITS(dr)\t(ADS131E08_NUM_DATA_BYTES(dr) * 8)\n#define ADS131E08_NUM_STORAGE_BYTES\t4\n\nenum ads131e08_ids {\n\tads131e04,\n\tads131e06,\n\tads131e08,\n};\n\nstruct ads131e08_info {\n\tunsigned int max_channels;\n\tconst char *name;\n};\n\nstruct ads131e08_channel_config {\n\tunsigned int pga_gain;\n\tunsigned int mux;\n};\n\nstruct ads131e08_state {\n\tconst struct ads131e08_info *info;\n\tstruct spi_device *spi;\n\tstruct iio_trigger *trig;\n\tstruct clk *adc_clk;\n\tstruct regulator *vref_reg;\n\tstruct ads131e08_channel_config *channel_config;\n\tunsigned int data_rate;\n\tunsigned int vref_mv;\n\tunsigned int sdecode_delay_us;\n\tunsigned int reset_delay_us;\n\tunsigned int readback_len;\n\tstruct completion completion;\n\tstruct {\n\t\tu8 data[ADS131E08_NUM_DATA_BYTES_MAX];\n\t\ts64 ts __aligned(8);\n\t} tmp_buf;\n\n\tu8 tx_buf[3] __aligned(IIO_DMA_MINALIGN);\n\t \n\tu8 rx_buf[ADS131E08_NUM_STATUS_BYTES +\n\t\tADS131E08_NUM_DATA_BYTES_MAX + 1];\n};\n\nstatic const struct ads131e08_info ads131e08_info_tbl[] = {\n\t[ads131e04] = {\n\t\t.max_channels = 4,\n\t\t.name = \"ads131e04\",\n\t},\n\t[ads131e06] = {\n\t\t.max_channels = 6,\n\t\t.name = \"ads131e06\",\n\t},\n\t[ads131e08] = {\n\t\t.max_channels = 8,\n\t\t.name = \"ads131e08\",\n\t},\n};\n\nstruct ads131e08_data_rate_desc {\n\tunsigned int rate;   \n\tu8 reg;              \n};\n\nstatic const struct ads131e08_data_rate_desc ads131e08_data_rate_tbl[] = {\n\t{ .rate = 64,   .reg = 0x00 },\n\t{ .rate = 32,   .reg = 0x01 },\n\t{ .rate = 16,   .reg = 0x02 },\n\t{ .rate = 8,    .reg = 0x03 },\n\t{ .rate = 4,    .reg = 0x04 },\n\t{ .rate = 2,    .reg = 0x05 },\n\t{ .rate = 1,    .reg = 0x06 },\n};\n\nstruct ads131e08_pga_gain_desc {\n\tunsigned int gain;   \n\tu8 reg;              \n};\n\nstatic const struct ads131e08_pga_gain_desc ads131e08_pga_gain_tbl[] = {\n\t{ .gain = 1,   .reg = 0x01 },\n\t{ .gain = 2,   .reg = 0x02 },\n\t{ .gain = 4,   .reg = 0x04 },\n\t{ .gain = 8,   .reg = 0x05 },\n\t{ .gain = 12,  .reg = 0x06 },\n};\n\nstatic const u8 ads131e08_valid_channel_mux_values[] = { 0, 1, 3, 4 };\n\nstatic int ads131e08_exec_cmd(struct ads131e08_state *st, u8 cmd)\n{\n\tint ret;\n\n\tret = spi_write_then_read(st->spi, &cmd, 1, NULL, 0);\n\tif (ret)\n\t\tdev_err(&st->spi->dev, \"Exec cmd(%02x) failed\\n\", cmd);\n\n\treturn ret;\n}\n\nstatic int ads131e08_read_reg(struct ads131e08_state *st, u8 reg)\n{\n\tint ret;\n\tstruct spi_transfer transfer[] = {\n\t\t{\n\t\t\t.tx_buf = &st->tx_buf,\n\t\t\t.len = 2,\n\t\t\t.delay = {\n\t\t\t\t.value = st->sdecode_delay_us,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t},\n\t\t}, {\n\t\t\t.rx_buf = &st->rx_buf,\n\t\t\t.len = 1,\n\t\t},\n\t};\n\n\tst->tx_buf[0] = ADS131E08_CMD_RREG(reg);\n\tst->tx_buf[1] = 0;\n\n\tret = spi_sync_transfer(st->spi, transfer, ARRAY_SIZE(transfer));\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"Read register failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn st->rx_buf[0];\n}\n\nstatic int ads131e08_write_reg(struct ads131e08_state *st, u8 reg, u8 value)\n{\n\tint ret;\n\tstruct spi_transfer transfer[] = {\n\t\t{\n\t\t\t.tx_buf = &st->tx_buf,\n\t\t\t.len = 3,\n\t\t\t.delay = {\n\t\t\t\t.value = st->sdecode_delay_us,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t},\n\t\t}\n\t};\n\n\tst->tx_buf[0] = ADS131E08_CMD_WREG(reg);\n\tst->tx_buf[1] = 0;\n\tst->tx_buf[2] = value;\n\n\tret = spi_sync_transfer(st->spi, transfer, ARRAY_SIZE(transfer));\n\tif (ret)\n\t\tdev_err(&st->spi->dev, \"Write register failed\\n\");\n\n\treturn ret;\n}\n\nstatic int ads131e08_read_data(struct ads131e08_state *st, int rx_len)\n{\n\tint ret;\n\tstruct spi_transfer transfer[] = {\n\t\t{\n\t\t\t.tx_buf = &st->tx_buf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.rx_buf = &st->rx_buf,\n\t\t\t.len = rx_len,\n\t\t},\n\t};\n\n\tst->tx_buf[0] = ADS131E08_CMD_RDATA;\n\n\tret = spi_sync_transfer(st->spi, transfer, ARRAY_SIZE(transfer));\n\tif (ret)\n\t\tdev_err(&st->spi->dev, \"Read data failed\\n\");\n\n\treturn ret;\n}\n\nstatic int ads131e08_set_data_rate(struct ads131e08_state *st, int data_rate)\n{\n\tint i, reg, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ads131e08_data_rate_tbl); i++) {\n\t\tif (ads131e08_data_rate_tbl[i].rate == data_rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ads131e08_data_rate_tbl)) {\n\t\tdev_err(&st->spi->dev, \"invalid data rate value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = ads131e08_read_reg(st, ADS131E08_ADR_CFG1R);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~ADS131E08_CFG1R_DR_MASK;\n\treg |= FIELD_PREP(ADS131E08_CFG1R_DR_MASK,\n\t\tads131e08_data_rate_tbl[i].reg);\n\n\tret = ads131e08_write_reg(st, ADS131E08_ADR_CFG1R, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->data_rate = data_rate;\n\tst->readback_len = ADS131E08_NUM_STATUS_BYTES +\n\t\tADS131E08_NUM_DATA_BYTES(st->data_rate) *\n\t\tst->info->max_channels;\n\n\treturn 0;\n}\n\nstatic int ads131e08_pga_gain_to_field_value(struct ads131e08_state *st,\n\tunsigned int pga_gain)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ads131e08_pga_gain_tbl); i++) {\n\t\tif (ads131e08_pga_gain_tbl[i].gain == pga_gain)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ads131e08_pga_gain_tbl)) {\n\t\tdev_err(&st->spi->dev, \"invalid PGA gain value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ads131e08_pga_gain_tbl[i].reg;\n}\n\nstatic int ads131e08_set_pga_gain(struct ads131e08_state *st,\n\tunsigned int channel, unsigned int pga_gain)\n{\n\tint field_value, reg;\n\n\tfield_value = ads131e08_pga_gain_to_field_value(st, pga_gain);\n\tif (field_value < 0)\n\t\treturn field_value;\n\n\treg = ads131e08_read_reg(st, ADS131E08_ADR_CH0R + channel);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~ADS131E08_CHR_GAIN_MASK;\n\treg |= FIELD_PREP(ADS131E08_CHR_GAIN_MASK, field_value);\n\n\treturn ads131e08_write_reg(st, ADS131E08_ADR_CH0R + channel, reg);\n}\n\nstatic int ads131e08_validate_channel_mux(struct ads131e08_state *st,\n\tunsigned int mux)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ads131e08_valid_channel_mux_values); i++) {\n\t\tif (ads131e08_valid_channel_mux_values[i] == mux)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ads131e08_valid_channel_mux_values)) {\n\t\tdev_err(&st->spi->dev, \"invalid channel mux value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ads131e08_set_channel_mux(struct ads131e08_state *st,\n\tunsigned int channel, unsigned int mux)\n{\n\tint reg;\n\n\treg = ads131e08_read_reg(st, ADS131E08_ADR_CH0R + channel);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~ADS131E08_CHR_MUX_MASK;\n\treg |= FIELD_PREP(ADS131E08_CHR_MUX_MASK, mux);\n\n\treturn ads131e08_write_reg(st, ADS131E08_ADR_CH0R + channel, reg);\n}\n\nstatic int ads131e08_power_down_channel(struct ads131e08_state *st,\n\tunsigned int channel, bool value)\n{\n\tint reg;\n\n\treg = ads131e08_read_reg(st, ADS131E08_ADR_CH0R + channel);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~ADS131E08_CHR_PWD_MASK;\n\treg |= FIELD_PREP(ADS131E08_CHR_PWD_MASK, value);\n\n\treturn ads131e08_write_reg(st, ADS131E08_ADR_CH0R + channel, reg);\n}\n\nstatic int ads131e08_config_reference_voltage(struct ads131e08_state *st)\n{\n\tint reg;\n\n\treg = ads131e08_read_reg(st, ADS131E08_ADR_CFG3R);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~ADS131E08_CFG3R_PDB_REFBUF_MASK;\n\tif (!st->vref_reg) {\n\t\treg |= FIELD_PREP(ADS131E08_CFG3R_PDB_REFBUF_MASK, 1);\n\t\treg &= ~ADS131E08_CFG3R_VREF_4V_MASK;\n\t\treg |= FIELD_PREP(ADS131E08_CFG3R_VREF_4V_MASK,\n\t\t\tst->vref_mv == ADS131E08_VREF_4V_mV);\n\t}\n\n\treturn ads131e08_write_reg(st, ADS131E08_ADR_CFG3R, reg);\n}\n\nstatic int ads131e08_initial_config(struct iio_dev *indio_dev)\n{\n\tconst struct iio_chan_spec *channel = indio_dev->channels;\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tunsigned long active_channels = 0;\n\tint ret, i;\n\n\tret = ads131e08_exec_cmd(st, ADS131E08_CMD_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(st->reset_delay_us);\n\n\t \n\tret = ads131e08_exec_cmd(st, ADS131E08_CMD_SDATAC);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ads131e08_set_data_rate(st, ADS131E08_DEFAULT_DATA_RATE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ads131e08_config_reference_voltage(st);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0;  i < indio_dev->num_channels; i++) {\n\t\tret = ads131e08_set_pga_gain(st, channel->channel,\n\t\t\tst->channel_config[i].pga_gain);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ads131e08_set_channel_mux(st, channel->channel,\n\t\t\tst->channel_config[i].mux);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tactive_channels |= BIT(channel->channel);\n\t\tchannel++;\n\t}\n\n\t \n\tfor_each_clear_bit(i, &active_channels, st->info->max_channels) {\n\t\tret = ads131e08_power_down_channel(st, i, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ads131e08_exec_cmd(st, ADS131E08_CMD_OFFSETCAL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ads131e08_exec_cmd(st, ADS131E08_CMD_START);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(ADS131E08_WAIT_OFFSETCAL_MS);\n\n\treturn ads131e08_exec_cmd(st, ADS131E08_CMD_STOP);\n}\n\nstatic int ads131e08_pool_data(struct ads131e08_state *st)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\treinit_completion(&st->completion);\n\n\tret = ads131e08_exec_cmd(st, ADS131E08_CMD_START);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = msecs_to_jiffies(ADS131E08_MAX_SETTLING_TIME_MS);\n\tret = wait_for_completion_timeout(&st->completion, timeout);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tret = ads131e08_read_data(st, st->readback_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ads131e08_exec_cmd(st, ADS131E08_CMD_STOP);\n}\n\nstatic int ads131e08_read_direct(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *channel, int *value)\n{\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tu8 num_bits, *src;\n\tint ret;\n\n\tret = ads131e08_pool_data(st);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc = st->rx_buf + ADS131E08_NUM_STATUS_BYTES +\n\t\tchannel->channel * ADS131E08_NUM_DATA_BYTES(st->data_rate);\n\n\tnum_bits = ADS131E08_NUM_DATA_BITS(st->data_rate);\n\t*value = sign_extend32(get_unaligned_be32(src) >> (32 - num_bits), num_bits - 1);\n\n\treturn 0;\n}\n\nstatic int ads131e08_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *channel, int *value,\n\tint *value2, long mask)\n{\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ads131e08_read_direct(indio_dev, channel, value);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->vref_reg) {\n\t\t\tret = regulator_get_voltage(st->vref_reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*value = ret / 1000;\n\t\t} else {\n\t\t\t*value = st->vref_mv;\n\t\t}\n\n\t\t*value /= st->channel_config[channel->address].pga_gain;\n\t\t*value2 = ADS131E08_NUM_DATA_BITS(st->data_rate) - 1;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*value = st->data_rate;\n\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ads131e08_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *channel, int value,\n\tint value2, long mask)\n{\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ads131e08_set_data_rate(st, value);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"1 2 4 8 16 32 64\");\n\nstatic struct attribute *ads131e08_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ads131e08_attribute_group = {\n\t.attrs = ads131e08_attributes,\n};\n\nstatic int ads131e08_debugfs_reg_access(struct iio_dev *indio_dev,\n\tunsigned int reg, unsigned int writeval, unsigned int *readval)\n{\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\n\tif (readval) {\n\t\tint ret = ads131e08_read_reg(st, reg);\n\t\t*readval = ret;\n\t\treturn ret;\n\t}\n\n\treturn ads131e08_write_reg(st, reg, writeval);\n}\n\nstatic const struct iio_info ads131e08_iio_info = {\n\t.read_raw = ads131e08_read_raw,\n\t.write_raw = ads131e08_write_raw,\n\t.attrs = &ads131e08_attribute_group,\n\t.debugfs_reg_access = &ads131e08_debugfs_reg_access,\n};\n\nstatic int ads131e08_set_trigger_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tu8 cmd = state ? ADS131E08_CMD_START : ADS131E08_CMD_STOP;\n\n\treturn ads131e08_exec_cmd(st, cmd);\n}\n\nstatic const struct iio_trigger_ops ads131e08_trigger_ops = {\n\t.set_trigger_state = &ads131e08_set_trigger_state,\n\t.validate_device = &iio_trigger_validate_own_device,\n};\n\nstatic irqreturn_t ads131e08_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tunsigned int chn, i = 0;\n\tu8 *src, *dest;\n\tint ret;\n\n\t \n\tunsigned int num_bytes = ADS131E08_NUM_DATA_BYTES(st->data_rate);\n\tu8 tweek_offset = num_bytes == 2 ? 1 : 0;\n\n\tif (iio_trigger_using_own(indio_dev))\n\t\tret = ads131e08_read_data(st, st->readback_len);\n\telse\n\t\tret = ads131e08_pool_data(st);\n\n\tif (ret)\n\t\tgoto out;\n\n\tfor_each_set_bit(chn, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\tsrc = st->rx_buf + ADS131E08_NUM_STATUS_BYTES + chn * num_bytes;\n\t\tdest = st->tmp_buf.data + i * ADS131E08_NUM_STORAGE_BYTES;\n\n\t\t \n\t\tmemcpy(dest + tweek_offset, src, num_bytes);\n\n\t\t \n\t\tif (tweek_offset)\n\t\t\t*dest = *src & BIT(7) ? 0xff : 0x00;\n\n\t\ti++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->tmp_buf.data,\n\t\tiio_get_time_ns(indio_dev));\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ads131e08_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev) && iio_trigger_using_own(indio_dev))\n\t\tiio_trigger_poll(st->trig);\n\telse\n\t\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ads131e08_alloc_channels(struct iio_dev *indio_dev)\n{\n\tstruct ads131e08_state *st = iio_priv(indio_dev);\n\tstruct ads131e08_channel_config *channel_config;\n\tstruct device *dev = &st->spi->dev;\n\tstruct iio_chan_spec *channels;\n\tstruct fwnode_handle *node;\n\tunsigned int channel, tmp;\n\tint num_channels, i, ret;\n\n\tret = device_property_read_u32(dev, \"ti,vref-internal\", &tmp);\n\tif (ret)\n\t\ttmp = 0;\n\n\tswitch (tmp) {\n\tcase 0:\n\t\tst->vref_mv = ADS131E08_VREF_2V4_mV;\n\t\tbreak;\n\tcase 1:\n\t\tst->vref_mv = ADS131E08_VREF_4V_mV;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&st->spi->dev, \"invalid internal voltage reference\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_channels = device_get_child_node_count(dev);\n\tif (num_channels == 0) {\n\t\tdev_err(&st->spi->dev, \"no channel children\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (num_channels > st->info->max_channels) {\n\t\tdev_err(&st->spi->dev, \"num of channel children out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = devm_kcalloc(&st->spi->dev, num_channels,\n\t\tsizeof(*channels), GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tchannel_config = devm_kcalloc(&st->spi->dev, num_channels,\n\t\tsizeof(*channel_config), GFP_KERNEL);\n\tif (!channel_config)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(dev, node) {\n\t\tret = fwnode_property_read_u32(node, \"reg\", &channel);\n\t\tif (ret)\n\t\t\tgoto err_child_out;\n\n\t\tret = fwnode_property_read_u32(node, \"ti,gain\", &tmp);\n\t\tif (ret) {\n\t\t\tchannel_config[i].pga_gain = ADS131E08_DEFAULT_PGA_GAIN;\n\t\t} else {\n\t\t\tret = ads131e08_pga_gain_to_field_value(st, tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_child_out;\n\n\t\t\tchannel_config[i].pga_gain = tmp;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(node, \"ti,mux\", &tmp);\n\t\tif (ret) {\n\t\t\tchannel_config[i].mux = ADS131E08_DEFAULT_MUX;\n\t\t} else {\n\t\t\tret = ads131e08_validate_channel_mux(st, tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err_child_out;\n\n\t\t\tchannel_config[i].mux = tmp;\n\t\t}\n\n\t\tchannels[i].type = IIO_VOLTAGE;\n\t\tchannels[i].indexed = 1;\n\t\tchannels[i].channel = channel;\n\t\tchannels[i].address = i;\n\t\tchannels[i].info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE);\n\t\tchannels[i].info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ);\n\t\tchannels[i].scan_index = channel;\n\t\tchannels[i].scan_type.sign = 's';\n\t\tchannels[i].scan_type.realbits = 24;\n\t\tchannels[i].scan_type.storagebits = 32;\n\t\tchannels[i].scan_type.shift = 8;\n\t\tchannels[i].scan_type.endianness = IIO_BE;\n\t\ti++;\n\t}\n\n\tindio_dev->channels = channels;\n\tindio_dev->num_channels = num_channels;\n\tst->channel_config = channel_config;\n\n\treturn 0;\n\nerr_child_out:\n\tfwnode_handle_put(node);\n\treturn ret;\n}\n\nstatic void ads131e08_regulator_disable(void *data)\n{\n\tstruct ads131e08_state *st = data;\n\n\tregulator_disable(st->vref_reg);\n}\n\nstatic int ads131e08_probe(struct spi_device *spi)\n{\n\tconst struct ads131e08_info *info;\n\tstruct ads131e08_state *st;\n\tstruct iio_dev *indio_dev;\n\tunsigned long adc_clk_hz;\n\tunsigned long adc_clk_ns;\n\tint ret;\n\n\tinfo = device_get_match_data(&spi->dev);\n\tif (!info)\n\t\tinfo = (void *)spi_get_device_id(spi)->driver_data;\n\tif (!info) {\n\t\tdev_err(&spi->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev) {\n\t\tdev_err(&spi->dev, \"failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tst->info = info;\n\tst->spi = spi;\n\n\tret = ads131e08_alloc_channels(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = st->info->name;\n\tindio_dev->info = &ads131e08_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tinit_completion(&st->completion);\n\n\tif (spi->irq) {\n\t\tret = devm_request_irq(&spi->dev, spi->irq,\n\t\t\tads131e08_interrupt,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\tspi->dev.driver->name, indio_dev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&spi->dev, ret,\n\t\t\t\t\t     \"request irq failed\\n\");\n\t} else {\n\t\tdev_err(&spi->dev, \"data ready IRQ missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tst->trig = devm_iio_trigger_alloc(&spi->dev, \"%s-dev%d\",\n\t\tindio_dev->name, iio_device_id(indio_dev));\n\tif (!st->trig) {\n\t\tdev_err(&spi->dev, \"failed to allocate IIO trigger\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tst->trig->ops = &ads131e08_trigger_ops;\n\tst->trig->dev.parent = &spi->dev;\n\tiio_trigger_set_drvdata(st->trig, indio_dev);\n\tret = devm_iio_trigger_register(&spi->dev, st->trig);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to register IIO trigger\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\tNULL, &ads131e08_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to setup IIO buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tst->vref_reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->vref_reg)) {\n\t\tret = regulator_enable(st->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"failed to enable external vref supply\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ads131e08_regulator_disable, st);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (PTR_ERR(st->vref_reg) != -ENODEV)\n\t\t\treturn PTR_ERR(st->vref_reg);\n\n\t\tst->vref_reg = NULL;\n\t}\n\n\tst->adc_clk = devm_clk_get_enabled(&spi->dev, \"adc-clk\");\n\tif (IS_ERR(st->adc_clk))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->adc_clk),\n\t\t\t\t     \"failed to get the ADC clock\\n\");\n\n\tadc_clk_hz = clk_get_rate(st->adc_clk);\n\tif (!adc_clk_hz) {\n\t\tdev_err(&spi->dev, \"failed to get the ADC clock rate\\n\");\n\t\treturn  -EINVAL;\n\t}\n\n\tadc_clk_ns = NSEC_PER_SEC / adc_clk_hz;\n\tst->sdecode_delay_us = DIV_ROUND_UP(\n\t\tADS131E08_WAIT_SDECODE_CYCLES * adc_clk_ns, NSEC_PER_USEC);\n\tst->reset_delay_us = DIV_ROUND_UP(\n\t\tADS131E08_WAIT_RESET_CYCLES * adc_clk_ns, NSEC_PER_USEC);\n\n\tret = ads131e08_initial_config(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"initial configuration failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ads131e08_of_match[] = {\n\t{ .compatible = \"ti,ads131e04\",\n\t  .data = &ads131e08_info_tbl[ads131e04], },\n\t{ .compatible = \"ti,ads131e06\",\n\t  .data = &ads131e08_info_tbl[ads131e06], },\n\t{ .compatible = \"ti,ads131e08\",\n\t  .data = &ads131e08_info_tbl[ads131e08], },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ads131e08_of_match);\n\nstatic const struct spi_device_id ads131e08_ids[] = {\n\t{ \"ads131e04\", (kernel_ulong_t)&ads131e08_info_tbl[ads131e04] },\n\t{ \"ads131e06\", (kernel_ulong_t)&ads131e08_info_tbl[ads131e06] },\n\t{ \"ads131e08\", (kernel_ulong_t)&ads131e08_info_tbl[ads131e08] },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ads131e08_ids);\n\nstatic struct spi_driver ads131e08_driver = {\n\t.driver = {\n\t\t.name = \"ads131e08\",\n\t\t.of_match_table = ads131e08_of_match,\n\t},\n\t.probe = ads131e08_probe,\n\t.id_table = ads131e08_ids,\n};\nmodule_spi_driver(ads131e08_driver);\n\nMODULE_AUTHOR(\"Tomislav Denis <tomislav.denis@avl.com>\");\nMODULE_DESCRIPTION(\"Driver for ADS131E0x ADC family\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}