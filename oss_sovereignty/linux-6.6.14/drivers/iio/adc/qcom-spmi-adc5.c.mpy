{
  "module_name": "qcom-spmi-adc5.c",
  "hash_id": "7d637beb9ef87761cbbfdd3d08cd109665971a7e1c901147a93f7fd01006a492",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/qcom-spmi-adc5.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/adc/qcom-vadc-common.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/iio/qcom,spmi-vadc.h>\n\n#define ADC5_USR_REVISION1\t\t\t0x0\n#define ADC5_USR_STATUS1\t\t\t0x8\n#define ADC5_USR_STATUS1_CONV_FAULT\t\tBIT(7)\n#define ADC5_USR_STATUS1_REQ_STS\t\tBIT(1)\n#define ADC5_USR_STATUS1_EOC\t\t\tBIT(0)\n#define ADC5_USR_STATUS1_REQ_STS_EOC_MASK\t0x3\n\n#define ADC5_USR_STATUS2\t\t\t0x9\n#define ADC5_USR_STATUS2_CONV_SEQ_MASK\t\t0x70\n#define ADC5_USR_STATUS2_CONV_SEQ_MASK_SHIFT\t0x5\n\n#define ADC5_USR_IBAT_MEAS\t\t\t0xf\n#define ADC5_USR_IBAT_MEAS_SUPPORTED\t\tBIT(0)\n\n#define ADC5_USR_DIG_PARAM\t\t\t0x42\n#define ADC5_USR_DIG_PARAM_CAL_VAL\t\tBIT(6)\n#define ADC5_USR_DIG_PARAM_CAL_VAL_SHIFT\t6\n#define ADC5_USR_DIG_PARAM_CAL_SEL\t\t0x30\n#define ADC5_USR_DIG_PARAM_CAL_SEL_SHIFT\t4\n#define ADC5_USR_DIG_PARAM_DEC_RATIO_SEL\t0xc\n#define ADC5_USR_DIG_PARAM_DEC_RATIO_SEL_SHIFT\t2\n\n#define ADC5_USR_FAST_AVG_CTL\t\t\t0x43\n#define ADC5_USR_FAST_AVG_CTL_EN\t\tBIT(7)\n#define ADC5_USR_FAST_AVG_CTL_SAMPLES_MASK\t0x7\n\n#define ADC5_USR_CH_SEL_CTL\t\t\t0x44\n\n#define ADC5_USR_DELAY_CTL\t\t\t0x45\n#define ADC5_USR_HW_SETTLE_DELAY_MASK\t\t0xf\n\n#define ADC5_USR_EN_CTL1\t\t\t0x46\n#define ADC5_USR_EN_CTL1_ADC_EN\t\t\tBIT(7)\n\n#define ADC5_USR_CONV_REQ\t\t\t0x47\n#define ADC5_USR_CONV_REQ_REQ\t\t\tBIT(7)\n\n#define ADC5_USR_DATA0\t\t\t\t0x50\n\n#define ADC5_USR_DATA1\t\t\t\t0x51\n\n#define ADC5_USR_IBAT_DATA0\t\t\t0x52\n\n#define ADC5_USR_IBAT_DATA1\t\t\t0x53\n\n#define ADC_CHANNEL_OFFSET\t\t\t0x8\n#define ADC_CHANNEL_MASK\t\t\tGENMASK(7, 0)\n\n \n#define ADC5_CONV_TIME_MIN_US\t\t\t263\n#define ADC5_CONV_TIME_MAX_US\t\t\t264\n#define ADC5_CONV_TIME_RETRY\t\t\t400\n#define ADC5_CONV_TIMEOUT\t\t\tmsecs_to_jiffies(100)\n\n \n#define ADC5_HW_SETTLE_DIFF_MINOR\t\t3\n#define ADC5_HW_SETTLE_DIFF_MAJOR\t\t5\n\n \n#define ADC_APP_SID\t\t\t\t0x40\n#define ADC_APP_SID_MASK\t\t\tGENMASK(3, 0)\n#define ADC7_CONV_TIMEOUT\t\t\tmsecs_to_jiffies(10)\n\nenum adc5_cal_method {\n\tADC5_NO_CAL = 0,\n\tADC5_RATIOMETRIC_CAL,\n\tADC5_ABSOLUTE_CAL\n};\n\nenum adc5_cal_val {\n\tADC5_TIMER_CAL = 0,\n\tADC5_NEW_CAL\n};\n\n \nstruct adc5_channel_prop {\n\tunsigned int\t\tchannel;\n\tenum adc5_cal_method\tcal_method;\n\tenum adc5_cal_val\tcal_val;\n\tunsigned int\t\tdecimation;\n\tunsigned int\t\tsid;\n\tunsigned int\t\tprescale;\n\tunsigned int\t\thw_settle_time;\n\tunsigned int\t\tavg_samples;\n\tenum vadc_scale_fn_type\tscale_fn_type;\n\tconst char\t\t*channel_name;\n};\n\n \nstruct adc5_chip {\n\tstruct regmap\t\t*regmap;\n\tstruct device\t\t*dev;\n\tu16\t\t\tbase;\n\tunsigned int\t\tnchannels;\n\tstruct adc5_channel_prop\t*chan_props;\n\tstruct iio_chan_spec\t*iio_chans;\n\tbool\t\t\tpoll_eoc;\n\tstruct completion\tcomplete;\n\tstruct mutex\t\tlock;\n\tconst struct adc5_data\t*data;\n};\n\nstatic int adc5_read(struct adc5_chip *adc, u16 offset, u8 *data, int len)\n{\n\treturn regmap_bulk_read(adc->regmap, adc->base + offset, data, len);\n}\n\nstatic int adc5_write(struct adc5_chip *adc, u16 offset, u8 *data, int len)\n{\n\treturn regmap_bulk_write(adc->regmap, adc->base + offset, data, len);\n}\n\nstatic int adc5_masked_write(struct adc5_chip *adc, u16 offset, u8 mask, u8 val)\n{\n\treturn regmap_update_bits(adc->regmap, adc->base + offset, mask, val);\n}\n\nstatic int adc5_read_voltage_data(struct adc5_chip *adc, u16 *data)\n{\n\tint ret;\n\tu8 rslt_lsb, rslt_msb;\n\n\tret = adc5_read(adc, ADC5_USR_DATA0, &rslt_lsb, sizeof(rslt_lsb));\n\tif (ret)\n\t\treturn ret;\n\n\tret = adc5_read(adc, ADC5_USR_DATA1, &rslt_msb, sizeof(rslt_lsb));\n\tif (ret)\n\t\treturn ret;\n\n\t*data = (rslt_msb << 8) | rslt_lsb;\n\n\tif (*data == ADC5_USR_DATA_CHECK) {\n\t\tdev_err(adc->dev, \"Invalid data:0x%x\\n\", *data);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(adc->dev, \"voltage raw code:0x%x\\n\", *data);\n\n\treturn 0;\n}\n\nstatic int adc5_poll_wait_eoc(struct adc5_chip *adc)\n{\n\tunsigned int count, retry = ADC5_CONV_TIME_RETRY;\n\tu8 status1;\n\tint ret;\n\n\tfor (count = 0; count < retry; count++) {\n\t\tret = adc5_read(adc, ADC5_USR_STATUS1, &status1,\n\t\t\t\t\t\t\tsizeof(status1));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstatus1 &= ADC5_USR_STATUS1_REQ_STS_EOC_MASK;\n\t\tif (status1 == ADC5_USR_STATUS1_EOC)\n\t\t\treturn 0;\n\n\t\tusleep_range(ADC5_CONV_TIME_MIN_US, ADC5_CONV_TIME_MAX_US);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void adc5_update_dig_param(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop, u8 *data)\n{\n\t \n\t*data &= ~ADC5_USR_DIG_PARAM_CAL_VAL;\n\t*data |= (prop->cal_val << ADC5_USR_DIG_PARAM_CAL_VAL_SHIFT);\n\n\t \n\t*data &= ~ADC5_USR_DIG_PARAM_CAL_SEL;\n\t*data |= (prop->cal_method << ADC5_USR_DIG_PARAM_CAL_SEL_SHIFT);\n\n\t \n\t*data &= ~ADC5_USR_DIG_PARAM_DEC_RATIO_SEL;\n\t*data |= (prop->decimation << ADC5_USR_DIG_PARAM_DEC_RATIO_SEL_SHIFT);\n}\n\nstatic int adc5_configure(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop)\n{\n\tint ret;\n\tu8 buf[6];\n\n\t \n\tret = adc5_read(adc, ADC5_USR_DIG_PARAM, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadc5_update_dig_param(adc, prop, &buf[0]);\n\n\t \n\tbuf[1] &= (u8) ~ADC5_USR_FAST_AVG_CTL_SAMPLES_MASK;\n\tbuf[1] |= prop->avg_samples;\n\n\t \n\tbuf[2] = prop->channel;\n\n\t \n\tbuf[3] &= (u8) ~ADC5_USR_HW_SETTLE_DELAY_MASK;\n\tbuf[3] |= prop->hw_settle_time;\n\n\t \n\tbuf[4] |= ADC5_USR_EN_CTL1_ADC_EN;\n\n\t \n\tbuf[5] |= ADC5_USR_CONV_REQ_REQ;\n\n\tif (!adc->poll_eoc)\n\t\treinit_completion(&adc->complete);\n\n\treturn adc5_write(adc, ADC5_USR_DIG_PARAM, buf, sizeof(buf));\n}\n\nstatic int adc7_configure(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop)\n{\n\tint ret;\n\tu8 conv_req = 0, buf[4];\n\n\tret = adc5_masked_write(adc, ADC_APP_SID, ADC_APP_SID_MASK, prop->sid);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adc5_read(adc, ADC5_USR_DIG_PARAM, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadc5_update_dig_param(adc, prop, &buf[0]);\n\n\t \n\tbuf[1] &= ~ADC5_USR_FAST_AVG_CTL_SAMPLES_MASK;\n\tbuf[1] |= prop->avg_samples;\n\n\t \n\tbuf[2] = prop->channel;\n\n\t \n\tbuf[3] &= ~ADC5_USR_HW_SETTLE_DELAY_MASK;\n\tbuf[3] |= prop->hw_settle_time;\n\n\t \n\tconv_req = ADC5_USR_CONV_REQ_REQ;\n\n\tif (!adc->poll_eoc)\n\t\treinit_completion(&adc->complete);\n\n\tret = adc5_write(adc, ADC5_USR_DIG_PARAM, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn adc5_write(adc, ADC5_USR_CONV_REQ, &conv_req, 1);\n}\n\nstatic int adc5_do_conversion(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tu16 *data_volt, u16 *data_cur)\n{\n\tint ret;\n\n\tmutex_lock(&adc->lock);\n\n\tret = adc5_configure(adc, prop);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"ADC configure failed with %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tif (adc->poll_eoc) {\n\t\tret = adc5_poll_wait_eoc(adc);\n\t\tif (ret) {\n\t\t\tdev_err(adc->dev, \"EOC bit not set\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tret = wait_for_completion_timeout(&adc->complete,\n\t\t\t\t\t\t\tADC5_CONV_TIMEOUT);\n\t\tif (!ret) {\n\t\t\tdev_dbg(adc->dev, \"Did not get completion timeout.\\n\");\n\t\t\tret = adc5_poll_wait_eoc(adc);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(adc->dev, \"EOC bit not set\\n\");\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = adc5_read_voltage_data(adc, data_volt);\nunlock:\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int adc7_do_conversion(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tu16 *data_volt, u16 *data_cur)\n{\n\tint ret;\n\tu8 status;\n\n\tmutex_lock(&adc->lock);\n\n\tret = adc7_configure(adc, prop);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"ADC configure failed with %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\t \n\twait_for_completion_timeout(&adc->complete, ADC7_CONV_TIMEOUT);\n\n\tret = adc5_read(adc, ADC5_USR_STATUS1, &status, 1);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (status & ADC5_USR_STATUS1_CONV_FAULT) {\n\t\tdev_err(adc->dev, \"Unexpected conversion fault\\n\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tret = adc5_read_voltage_data(adc, data_volt);\n\nunlock:\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\ntypedef int (*adc_do_conversion)(struct adc5_chip *adc,\n\t\t\tstruct adc5_channel_prop *prop,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tu16 *data_volt, u16 *data_cur);\n\nstatic irqreturn_t adc5_isr(int irq, void *dev_id)\n{\n\tstruct adc5_chip *adc = dev_id;\n\n\tcomplete(&adc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc5_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t     const struct fwnode_reference_args *iiospec)\n{\n\tstruct adc5_chip *adc = iio_priv(indio_dev);\n\tint i;\n\n\tfor (i = 0; i < adc->nchannels; i++)\n\t\tif (adc->chan_props[i].channel == iiospec->args[0])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int adc7_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t     const struct fwnode_reference_args *iiospec)\n{\n\tstruct adc5_chip *adc = iio_priv(indio_dev);\n\tint i, v_channel;\n\n\tfor (i = 0; i < adc->nchannels; i++) {\n\t\tv_channel = (adc->chan_props[i].sid << ADC_CHANNEL_OFFSET) |\n\t\t\tadc->chan_props[i].channel;\n\t\tif (v_channel == iiospec->args[0])\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adc_read_raw_common(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan, int *val, int *val2,\n\t\t\t long mask, adc_do_conversion do_conv)\n{\n\tstruct adc5_chip *adc = iio_priv(indio_dev);\n\tstruct adc5_channel_prop *prop;\n\tu16 adc_code_volt, adc_code_cur;\n\tint ret;\n\n\tprop = &adc->chan_props[chan->address];\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = do_conv(adc, prop, chan,\n\t\t\t\t\t&adc_code_volt, &adc_code_cur);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = qcom_adc5_hw_scale(prop->scale_fn_type,\n\t\t\tprop->prescale,\n\t\t\tadc->data,\n\t\t\tadc_code_volt, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adc5_read_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan, int *val, int *val2,\n\t\t\t long mask)\n{\n\treturn adc_read_raw_common(indio_dev, chan, val, val2,\n\t\t\t\tmask, adc5_do_conversion);\n}\n\nstatic int adc7_read_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan, int *val, int *val2,\n\t\t\t long mask)\n{\n\treturn adc_read_raw_common(indio_dev, chan, val, val2,\n\t\t\t\tmask, adc7_do_conversion);\n}\n\nstatic const struct iio_info adc5_info = {\n\t.read_raw = adc5_read_raw,\n\t.fwnode_xlate = adc5_fwnode_xlate,\n};\n\nstatic const struct iio_info adc7_info = {\n\t.read_raw = adc7_read_raw,\n\t.fwnode_xlate = adc7_fwnode_xlate,\n};\n\nstruct adc5_channels {\n\tconst char *datasheet_name;\n\tunsigned int prescale_index;\n\tenum iio_chan_type type;\n\tlong info_mask;\n\tenum vadc_scale_fn_type scale_fn_type;\n};\n\n \n#define ADC5_CHAN(_dname, _type, _mask, _pre, _scale)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.datasheet_name = _dname,\t\t\t\t\\\n\t\t.prescale_index = _pre,\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.info_mask = _mask,\t\t\t\t\t\\\n\t\t.scale_fn_type = _scale,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\n#define ADC5_CHAN_TEMP(_dname, _pre, _scale)\t\t\t\t\\\n\tADC5_CHAN(_dname, IIO_TEMP,\t\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_PROCESSED),\t\t\t\t\\\n\t\t_pre, _scale)\t\t\t\t\t\t\\\n\n#define ADC5_CHAN_VOLT(_dname, _pre, _scale)\t\t\t\t\\\n\tADC5_CHAN(_dname, IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t  BIT(IIO_CHAN_INFO_PROCESSED),\t\t\t\t\\\n\t\t  _pre, _scale)\t\t\t\t\t\t\\\n\nstatic const struct adc5_channels adc5_chans_pmic[ADC5_MAX_CHANNEL] = {\n\t[ADC5_REF_GND]\t\t= ADC5_CHAN_VOLT(\"ref_gnd\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_1P25VREF]\t\t= ADC5_CHAN_VOLT(\"vref_1p25\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VPH_PWR]\t\t= ADC5_CHAN_VOLT(\"vph_pwr\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VBAT_SNS]\t\t= ADC5_CHAN_VOLT(\"vbat_sns\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VCOIN]\t\t= ADC5_CHAN_VOLT(\"vcoin\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_DIE_TEMP]\t\t= ADC5_CHAN_TEMP(\"die_temp\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_PMIC_THERM)\n\t[ADC5_USB_IN_I]\t\t= ADC5_CHAN_VOLT(\"usb_in_i_uv\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_USB_IN_V_16]\t= ADC5_CHAN_VOLT(\"usb_in_v_div_16\", 8,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_CHG_TEMP]\t\t= ADC5_CHAN_TEMP(\"chg_temp\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_PM5_CHG_TEMP)\n\t \n\t[ADC5_SBUx]\t\t= ADC5_CHAN_VOLT(\"chg_sbux\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_MID_CHG_DIV6]\t= ADC5_CHAN_VOLT(\"chg_mid_chg\", 3,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_XO_THERM_100K_PU]\t= ADC5_CHAN_TEMP(\"xo_therm\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_XOTHERM)\n\t[ADC5_BAT_ID_100K_PU]\t= ADC5_CHAN_TEMP(\"bat_id\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_AMUX_THM1_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm1_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM2_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm2_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM3_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm3_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM2]\t= ADC5_CHAN_TEMP(\"amux_thm2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_PM5_SMB_TEMP)\n\t[ADC5_GPIO1_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio1_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_GPIO2_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio2_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_GPIO3_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio3_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_GPIO4_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio4_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n};\n\nstatic const struct adc5_channels adc7_chans_pmic[ADC5_MAX_CHANNEL] = {\n\t[ADC7_REF_GND]\t\t= ADC5_CHAN_VOLT(\"ref_gnd\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC7_1P25VREF]\t\t= ADC5_CHAN_VOLT(\"vref_1p25\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC7_VPH_PWR]\t\t= ADC5_CHAN_VOLT(\"vph_pwr\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC7_VBAT_SNS]\t\t= ADC5_CHAN_VOLT(\"vbat_sns\", 3,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC7_DIE_TEMP]\t\t= ADC5_CHAN_TEMP(\"die_temp\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_PMIC_THERM_PM7)\n\t[ADC7_AMUX_THM1_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm1_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_AMUX_THM2_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm2_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_AMUX_THM3_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm3_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_AMUX_THM4_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm4_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_AMUX_THM5_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm5_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_AMUX_THM6_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm6_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_GPIO1_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio1_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_GPIO2_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio2_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_GPIO3_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio3_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n\t[ADC7_GPIO4_100K_PU]\t= ADC5_CHAN_TEMP(\"gpio4_pu2\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PU_PM7)\n};\n\nstatic const struct adc5_channels adc5_chans_rev2[ADC5_MAX_CHANNEL] = {\n\t[ADC5_REF_GND]\t\t= ADC5_CHAN_VOLT(\"ref_gnd\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_1P25VREF]\t\t= ADC5_CHAN_VOLT(\"vref_1p25\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VREF_VADC]\t= ADC5_CHAN_VOLT(\"vref_vadc\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VPH_PWR]\t\t= ADC5_CHAN_VOLT(\"vph_pwr\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VBAT_SNS]\t\t= ADC5_CHAN_VOLT(\"vbat_sns\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_VCOIN]\t\t= ADC5_CHAN_VOLT(\"vcoin\", 1,\n\t\t\t\t\tSCALE_HW_CALIB_DEFAULT)\n\t[ADC5_DIE_TEMP]\t\t= ADC5_CHAN_TEMP(\"die_temp\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_PMIC_THERM)\n\t[ADC5_AMUX_THM1_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm1_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM2_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm2_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM3_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm3_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM4_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm4_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_AMUX_THM5_100K_PU] = ADC5_CHAN_TEMP(\"amux_thm5_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n\t[ADC5_XO_THERM_100K_PU]\t= ADC5_CHAN_TEMP(\"xo_therm_100k_pu\", 0,\n\t\t\t\t\tSCALE_HW_CALIB_THERM_100K_PULLUP)\n};\n\nstatic int adc5_get_fw_channel_data(struct adc5_chip *adc,\n\t\t\t\t    struct adc5_channel_prop *prop,\n\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t    const struct adc5_data *data)\n{\n\tconst char *channel_name;\n\tchar *name;\n\tu32 chan, value, varr[2];\n\tu32 sid = 0;\n\tint ret;\n\tstruct device *dev = adc->dev;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%pfwP\", fwnode);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t \n\tname[strchrnul(name, '@') - name] = '\\0';\n\n\tret = fwnode_property_read_u32(fwnode, \"reg\", &chan);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid channel number %s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\n\tif (adc->data->info == &adc7_info) {\n\t\tsid = chan >> ADC_CHANNEL_OFFSET;\n\t\tchan = chan & ADC_CHANNEL_MASK;\n\t}\n\n\tif (chan > ADC5_PARALLEL_ISENSE_VBAT_IDATA) {\n\t\tdev_err(dev, \"%s invalid channel number %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tprop->channel = chan;\n\tprop->sid = sid;\n\n\tret = fwnode_property_read_string(fwnode, \"label\", &channel_name);\n\tif (ret)\n\t\tchannel_name = data->adc_chans[chan].datasheet_name;\n\n\tprop->channel_name = channel_name;\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,decimation\", &value);\n\tif (!ret) {\n\t\tret = qcom_adc5_decimation_from_dt(value, data->decimation);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid decimation %d\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->decimation = ret;\n\t} else {\n\t\tprop->decimation = ADC5_DECIMATION_DEFAULT;\n\t}\n\n\tret = fwnode_property_read_u32_array(fwnode, \"qcom,pre-scaling\", varr, 2);\n\tif (!ret) {\n\t\tret = qcom_adc5_prescaling_from_dt(varr[0], varr[1]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid pre-scaling <%d %d>\\n\",\n\t\t\t\tchan, varr[0], varr[1]);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->prescale = ret;\n\t} else {\n\t\tprop->prescale =\n\t\t\tadc->data->adc_chans[prop->channel].prescale_index;\n\t}\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,hw-settle-time\", &value);\n\tif (!ret) {\n\t\tu8 dig_version[2];\n\n\t\tret = adc5_read(adc, ADC5_USR_REVISION1, dig_version,\n\t\t\t\t\t\t\tsizeof(dig_version));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Invalid dig version read %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(dev, \"dig_ver:minor:%d, major:%d\\n\", dig_version[0],\n\t\t\t\t\t\tdig_version[1]);\n\t\t \n\t\tif ((dig_version[0] >= ADC5_HW_SETTLE_DIFF_MINOR &&\n\t\t\tdig_version[1] >= ADC5_HW_SETTLE_DIFF_MAJOR) ||\n\t\t\tadc->data->info == &adc7_info)\n\t\t\tret = qcom_adc5_hw_settle_time_from_dt(value, data->hw_settle_2);\n\t\telse\n\t\t\tret = qcom_adc5_hw_settle_time_from_dt(value, data->hw_settle_1);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid hw-settle-time %d us\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->hw_settle_time = ret;\n\t} else {\n\t\tprop->hw_settle_time = VADC_DEF_HW_SETTLE_TIME;\n\t}\n\n\tret = fwnode_property_read_u32(fwnode, \"qcom,avg-samples\", &value);\n\tif (!ret) {\n\t\tret = qcom_adc5_avg_samples_from_dt(value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%02x invalid avg-samples %d\\n\",\n\t\t\t\tchan, value);\n\t\t\treturn ret;\n\t\t}\n\t\tprop->avg_samples = ret;\n\t} else {\n\t\tprop->avg_samples = VADC_DEF_AVG_SAMPLES;\n\t}\n\n\tif (fwnode_property_read_bool(fwnode, \"qcom,ratiometric\"))\n\t\tprop->cal_method = ADC5_RATIOMETRIC_CAL;\n\telse\n\t\tprop->cal_method = ADC5_ABSOLUTE_CAL;\n\n\t \n\tprop->cal_val = ADC5_TIMER_CAL;\n\n\tdev_dbg(dev, \"%02x name %s\\n\", chan, name);\n\n\treturn 0;\n}\n\nstatic const struct adc5_data adc5_data_pmic = {\n\t.full_scale_code_volt = 0x70e4,\n\t.full_scale_code_cur = 0x2710,\n\t.adc_chans = adc5_chans_pmic,\n\t.info = &adc5_info,\n\t.decimation = (unsigned int [ADC5_DECIMATION_SAMPLES_MAX])\n\t\t\t\t{250, 420, 840},\n\t.hw_settle_1 = (unsigned int [VADC_HW_SETTLE_SAMPLES_MAX])\n\t\t\t\t{15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t800, 900, 1, 2, 4, 6, 8, 10},\n\t.hw_settle_2 = (unsigned int [VADC_HW_SETTLE_SAMPLES_MAX])\n\t\t\t\t{15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t1, 2, 4, 8, 16, 32, 64, 128},\n};\n\nstatic const struct adc5_data adc7_data_pmic = {\n\t.full_scale_code_volt = 0x70e4,\n\t.adc_chans = adc7_chans_pmic,\n\t.info = &adc7_info,\n\t.decimation = (unsigned int [ADC5_DECIMATION_SAMPLES_MAX])\n\t\t\t\t{85, 340, 1360},\n\t.hw_settle_2 = (unsigned int [VADC_HW_SETTLE_SAMPLES_MAX])\n\t\t\t\t{15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t1000, 2000, 4000, 8000, 16000, 32000,\n\t\t\t\t64000, 128000},\n};\n\nstatic const struct adc5_data adc5_data_pmic_rev2 = {\n\t.full_scale_code_volt = 0x4000,\n\t.full_scale_code_cur = 0x1800,\n\t.adc_chans = adc5_chans_rev2,\n\t.info = &adc5_info,\n\t.decimation = (unsigned int [ADC5_DECIMATION_SAMPLES_MAX])\n\t\t\t\t{256, 512, 1024},\n\t.hw_settle_1 = (unsigned int [VADC_HW_SETTLE_SAMPLES_MAX])\n\t\t\t\t{0, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t800, 900, 1, 2, 4, 6, 8, 10},\n\t.hw_settle_2 = (unsigned int [VADC_HW_SETTLE_SAMPLES_MAX])\n\t\t\t\t{15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t1, 2, 4, 8, 16, 32, 64, 128},\n};\n\nstatic const struct of_device_id adc5_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,spmi-adc5\",\n\t\t.data = &adc5_data_pmic,\n\t},\n\t{\n\t\t.compatible = \"qcom,spmi-adc7\",\n\t\t.data = &adc7_data_pmic,\n\t},\n\t{\n\t\t.compatible = \"qcom,spmi-adc-rev2\",\n\t\t.data = &adc5_data_pmic_rev2,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc5_match_table);\n\nstatic int adc5_get_fw_data(struct adc5_chip *adc)\n{\n\tconst struct adc5_channels *adc_chan;\n\tstruct iio_chan_spec *iio_chan;\n\tstruct adc5_channel_prop prop, *chan_props;\n\tstruct fwnode_handle *child;\n\tunsigned int index = 0;\n\tint ret;\n\n\tadc->nchannels = device_get_child_node_count(adc->dev);\n\tif (!adc->nchannels)\n\t\treturn -EINVAL;\n\n\tadc->iio_chans = devm_kcalloc(adc->dev, adc->nchannels,\n\t\t\t\t       sizeof(*adc->iio_chans), GFP_KERNEL);\n\tif (!adc->iio_chans)\n\t\treturn -ENOMEM;\n\n\tadc->chan_props = devm_kcalloc(adc->dev, adc->nchannels,\n\t\t\t\t\tsizeof(*adc->chan_props), GFP_KERNEL);\n\tif (!adc->chan_props)\n\t\treturn -ENOMEM;\n\n\tchan_props = adc->chan_props;\n\tiio_chan = adc->iio_chans;\n\tadc->data = device_get_match_data(adc->dev);\n\tif (!adc->data)\n\t\tadc->data = &adc5_data_pmic;\n\n\tdevice_for_each_child_node(adc->dev, child) {\n\t\tret = adc5_get_fw_channel_data(adc, &prop, child, adc->data);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tprop.scale_fn_type =\n\t\t\tadc->data->adc_chans[prop.channel].scale_fn_type;\n\t\t*chan_props = prop;\n\t\tadc_chan = &adc->data->adc_chans[prop.channel];\n\n\t\tiio_chan->channel = prop.channel;\n\t\tiio_chan->datasheet_name = adc_chan->datasheet_name;\n\t\tiio_chan->extend_name = prop.channel_name;\n\t\tiio_chan->info_mask_separate = adc_chan->info_mask;\n\t\tiio_chan->type = adc_chan->type;\n\t\tiio_chan->address = index;\n\t\tiio_chan++;\n\t\tchan_props++;\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\nstatic int adc5_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct adc5_chip *adc;\n\tstruct regmap *regmap;\n\tint ret, irq_eoc;\n\tu32 reg;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(dev, \"reg\", &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->regmap = regmap;\n\tadc->dev = dev;\n\tadc->base = reg;\n\n\tinit_completion(&adc->complete);\n\tmutex_init(&adc->lock);\n\n\tret = adc5_get_fw_data(adc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"adc get dt data failed\\n\");\n\n\tirq_eoc = platform_get_irq(pdev, 0);\n\tif (irq_eoc < 0) {\n\t\tif (irq_eoc == -EPROBE_DEFER || irq_eoc == -EINVAL)\n\t\t\treturn irq_eoc;\n\t\tadc->poll_eoc = true;\n\t} else {\n\t\tret = devm_request_irq(dev, irq_eoc, adc5_isr, 0,\n\t\t\t\t       \"pm-adc5\", adc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tindio_dev->name = pdev->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = adc->data->info;\n\tindio_dev->channels = adc->iio_chans;\n\tindio_dev->num_channels = adc->nchannels;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct platform_driver adc5_driver = {\n\t.driver = {\n\t\t.name = \"qcom-spmi-adc5\",\n\t\t.of_match_table = adc5_match_table,\n\t},\n\t.probe = adc5_probe,\n};\nmodule_platform_driver(adc5_driver);\n\nMODULE_ALIAS(\"platform:qcom-spmi-adc5\");\nMODULE_DESCRIPTION(\"Qualcomm Technologies Inc. PMIC5 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}