{
  "module_name": "mcp320x.c",
  "hash_id": "4e05f21538603aeb8f739a0ed236fc026cc6fbff01c7a97a5c8c4b20853d2bc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mcp320x.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/iio/iio.h>\n#include <linux/regulator/consumer.h>\n\nenum {\n\tmcp3001,\n\tmcp3002,\n\tmcp3004,\n\tmcp3008,\n\tmcp3201,\n\tmcp3202,\n\tmcp3204,\n\tmcp3208,\n\tmcp3301,\n\tmcp3550_50,\n\tmcp3550_60,\n\tmcp3551,\n\tmcp3553,\n};\n\nstruct mcp320x_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tunsigned int resolution;\n\tunsigned int conv_time;  \n};\n\n \nstruct mcp320x {\n\tstruct spi_device *spi;\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message start_conv_msg;\n\tstruct spi_transfer start_conv_transfer;\n\n\tstruct regulator *reg;\n\tstruct mutex lock;\n\tconst struct mcp320x_chip_info *chip_info;\n\n\tu8 tx_buf __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_buf[4];\n};\n\nstatic int mcp320x_channel_to_tx_data(int device_index,\n\t\t\tconst unsigned int channel, bool differential)\n{\n\tint start_bit = 1;\n\n\tswitch (device_index) {\n\tcase mcp3002:\n\tcase mcp3202:\n\t\treturn ((start_bit << 4) | (!differential << 3) |\n\t\t\t\t\t\t\t(channel << 2));\n\tcase mcp3004:\n\tcase mcp3204:\n\tcase mcp3008:\n\tcase mcp3208:\n\t\treturn ((start_bit << 6) | (!differential << 5) |\n\t\t\t\t\t\t\t(channel << 2));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mcp320x_adc_conversion(struct mcp320x *adc, u8 channel,\n\t\t\t\t  bool differential, int device_index, int *val)\n{\n\tint ret;\n\n\tif (adc->chip_info->conv_time) {\n\t\tret = spi_sync(adc->spi, &adc->start_conv_msg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tusleep_range(adc->chip_info->conv_time,\n\t\t\t     adc->chip_info->conv_time + 100);\n\t}\n\n\tmemset(&adc->rx_buf, 0, sizeof(adc->rx_buf));\n\tif (adc->chip_info->num_channels > 1)\n\t\tadc->tx_buf = mcp320x_channel_to_tx_data(device_index, channel,\n\t\t\t\t\t\t\t differential);\n\n\tret = spi_sync(adc->spi, &adc->msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (device_index) {\n\tcase mcp3001:\n\t\t*val = (adc->rx_buf[0] << 5 | adc->rx_buf[1] >> 3);\n\t\treturn 0;\n\tcase mcp3002:\n\tcase mcp3004:\n\tcase mcp3008:\n\t\t*val = (adc->rx_buf[0] << 2 | adc->rx_buf[1] >> 6);\n\t\treturn 0;\n\tcase mcp3201:\n\t\t*val = (adc->rx_buf[0] << 7 | adc->rx_buf[1] >> 1);\n\t\treturn 0;\n\tcase mcp3202:\n\tcase mcp3204:\n\tcase mcp3208:\n\t\t*val = (adc->rx_buf[0] << 4 | adc->rx_buf[1] >> 4);\n\t\treturn 0;\n\tcase mcp3301:\n\t\t*val = sign_extend32((adc->rx_buf[0] & 0x1f) << 8\n\t\t\t\t    | adc->rx_buf[1], 12);\n\t\treturn 0;\n\tcase mcp3550_50:\n\tcase mcp3550_60:\n\tcase mcp3551:\n\tcase mcp3553: {\n\t\tu32 raw = be32_to_cpup((__be32 *)adc->rx_buf);\n\n\t\tif (!(adc->spi->mode & SPI_CPOL))\n\t\t\traw <<= 1;  \n\n\t\t \n\t\traw >>= 8;\n\t\tif (raw & BIT(22) && raw & BIT(23))\n\t\t\treturn -EIO;  \n\t\telse if (raw & BIT(22))\n\t\t\traw &= ~BIT(22);  \n\t\telse if (raw & BIT(23) || raw & BIT(21))\n\t\t\traw |= GENMASK(31, 22);  \n\n\t\t*val = (s32)raw;\n\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mcp320x_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mcp320x *adc = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\tint device_index = 0;\n\n\tmutex_lock(&adc->lock);\n\n\tdevice_index = spi_get_device_id(adc->spi)->driver_data;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = mcp320x_adc_conversion(adc, channel->address,\n\t\t\tchannel->differential, device_index, val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(adc->reg);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\t*val = ret / 1000;\n\t\t*val2 = adc->chip_info->resolution;\n\t\tret = IIO_VAL_FRACTIONAL_LOG2;\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\n#define MCP320X_VOLTAGE_CHANNEL(num)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = (num),\t\t\t\t\\\n\t\t.address = (num),\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\\n\t}\n\n#define MCP320X_VOLTAGE_CHANNEL_DIFF(chan1, chan2)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = (chan1),\t\t\t\t\\\n\t\t.channel2 = (chan2),\t\t\t\t\\\n\t\t.address = (chan1),\t\t\t\t\\\n\t\t.differential = 1,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\\n\t}\n\nstatic const struct iio_chan_spec mcp3201_channels[] = {\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(0, 1),\n};\n\nstatic const struct iio_chan_spec mcp3202_channels[] = {\n\tMCP320X_VOLTAGE_CHANNEL(0),\n\tMCP320X_VOLTAGE_CHANNEL(1),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(0, 1),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(1, 0),\n};\n\nstatic const struct iio_chan_spec mcp3204_channels[] = {\n\tMCP320X_VOLTAGE_CHANNEL(0),\n\tMCP320X_VOLTAGE_CHANNEL(1),\n\tMCP320X_VOLTAGE_CHANNEL(2),\n\tMCP320X_VOLTAGE_CHANNEL(3),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(0, 1),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(1, 0),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(2, 3),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(3, 2),\n};\n\nstatic const struct iio_chan_spec mcp3208_channels[] = {\n\tMCP320X_VOLTAGE_CHANNEL(0),\n\tMCP320X_VOLTAGE_CHANNEL(1),\n\tMCP320X_VOLTAGE_CHANNEL(2),\n\tMCP320X_VOLTAGE_CHANNEL(3),\n\tMCP320X_VOLTAGE_CHANNEL(4),\n\tMCP320X_VOLTAGE_CHANNEL(5),\n\tMCP320X_VOLTAGE_CHANNEL(6),\n\tMCP320X_VOLTAGE_CHANNEL(7),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(0, 1),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(1, 0),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(2, 3),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(3, 2),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(4, 5),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(5, 4),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(6, 7),\n\tMCP320X_VOLTAGE_CHANNEL_DIFF(7, 6),\n};\n\nstatic const struct iio_info mcp320x_info = {\n\t.read_raw = mcp320x_read_raw,\n};\n\nstatic const struct mcp320x_chip_info mcp320x_chip_infos[] = {\n\t[mcp3001] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 10\n\t},\n\t[mcp3002] = {\n\t\t.channels = mcp3202_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3202_channels),\n\t\t.resolution = 10\n\t},\n\t[mcp3004] = {\n\t\t.channels = mcp3204_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3204_channels),\n\t\t.resolution = 10\n\t},\n\t[mcp3008] = {\n\t\t.channels = mcp3208_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3208_channels),\n\t\t.resolution = 10\n\t},\n\t[mcp3201] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 12\n\t},\n\t[mcp3202] = {\n\t\t.channels = mcp3202_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3202_channels),\n\t\t.resolution = 12\n\t},\n\t[mcp3204] = {\n\t\t.channels = mcp3204_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3204_channels),\n\t\t.resolution = 12\n\t},\n\t[mcp3208] = {\n\t\t.channels = mcp3208_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3208_channels),\n\t\t.resolution = 12\n\t},\n\t[mcp3301] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 13\n\t},\n\t[mcp3550_50] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 21,\n\t\t \n\t\t.conv_time = 80000 * 1.02 + 144000 / 102.4,\n\t},\n\t[mcp3550_60] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 21,\n\t\t.conv_time = 66670 * 1.02 + 144000 / 122.88,\n\t},\n\t[mcp3551] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 21,\n\t\t.conv_time = 73100 * 1.02 + 144000 / 112.64,\n\t},\n\t[mcp3553] = {\n\t\t.channels = mcp3201_channels,\n\t\t.num_channels = ARRAY_SIZE(mcp3201_channels),\n\t\t.resolution = 21,\n\t\t.conv_time = 16670 * 1.02 + 144000 / 122.88,\n\t},\n};\n\nstatic int mcp320x_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mcp320x *adc;\n\tconst struct mcp320x_chip_info *chip_info;\n\tint ret, device_index;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mcp320x_info;\n\tspi_set_drvdata(spi, indio_dev);\n\n\tdevice_index = spi_get_device_id(spi)->driver_data;\n\tchip_info = &mcp320x_chip_infos[device_index];\n\tindio_dev->channels = chip_info->channels;\n\tindio_dev->num_channels = chip_info->num_channels;\n\n\tadc->chip_info = chip_info;\n\n\tadc->transfer[0].tx_buf = &adc->tx_buf;\n\tadc->transfer[0].len = sizeof(adc->tx_buf);\n\tadc->transfer[1].rx_buf = adc->rx_buf;\n\tadc->transfer[1].len = DIV_ROUND_UP(chip_info->resolution, 8);\n\n\tif (chip_info->num_channels == 1)\n\t\t \n\t\tspi_message_init_with_transfers(&adc->msg,\n\t\t\t\t\t\t&adc->transfer[1], 1);\n\telse\n\t\tspi_message_init_with_transfers(&adc->msg, adc->transfer,\n\t\t\t\t\t\tARRAY_SIZE(adc->transfer));\n\n\tswitch (device_index) {\n\tcase mcp3550_50:\n\tcase mcp3550_60:\n\tcase mcp3551:\n\tcase mcp3553:\n\t\t \n\t\tif (!(spi->mode & SPI_CPOL))\n\t\t\tadc->transfer[1].len++;\n\n\t\t \n\t\tadc->start_conv_transfer.delay.value = 8;\n\t\tadc->start_conv_transfer.delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tspi_message_init_with_transfers(&adc->start_conv_msg,\n\t\t\t\t\t\t&adc->start_conv_transfer, 1);\n\n\t\t \n\t\tmcp320x_adc_conversion(adc, 0, 1, device_index, &ret);\n\t\tmcp320x_adc_conversion(adc, 0, 1, device_index, &ret);\n\t}\n\n\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(adc->reg))\n\t\treturn PTR_ERR(adc->reg);\n\n\tret = regulator_enable(adc->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&adc->lock);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto reg_disable;\n\n\treturn 0;\n\nreg_disable:\n\tregulator_disable(adc->reg);\n\n\treturn ret;\n}\n\nstatic void mcp320x_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct mcp320x *adc = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(adc->reg);\n}\n\nstatic const struct of_device_id mcp320x_dt_ids[] = {\n\t \n\t{ .compatible = \"mcp3001\" },\n\t{ .compatible = \"mcp3002\" },\n\t{ .compatible = \"mcp3004\" },\n\t{ .compatible = \"mcp3008\" },\n\t{ .compatible = \"mcp3201\" },\n\t{ .compatible = \"mcp3202\" },\n\t{ .compatible = \"mcp3204\" },\n\t{ .compatible = \"mcp3208\" },\n\t{ .compatible = \"mcp3301\" },\n\t{ .compatible = \"microchip,mcp3001\" },\n\t{ .compatible = \"microchip,mcp3002\" },\n\t{ .compatible = \"microchip,mcp3004\" },\n\t{ .compatible = \"microchip,mcp3008\" },\n\t{ .compatible = \"microchip,mcp3201\" },\n\t{ .compatible = \"microchip,mcp3202\" },\n\t{ .compatible = \"microchip,mcp3204\" },\n\t{ .compatible = \"microchip,mcp3208\" },\n\t{ .compatible = \"microchip,mcp3301\" },\n\t{ .compatible = \"microchip,mcp3550-50\" },\n\t{ .compatible = \"microchip,mcp3550-60\" },\n\t{ .compatible = \"microchip,mcp3551\" },\n\t{ .compatible = \"microchip,mcp3553\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp320x_dt_ids);\n\nstatic const struct spi_device_id mcp320x_id[] = {\n\t{ \"mcp3001\", mcp3001 },\n\t{ \"mcp3002\", mcp3002 },\n\t{ \"mcp3004\", mcp3004 },\n\t{ \"mcp3008\", mcp3008 },\n\t{ \"mcp3201\", mcp3201 },\n\t{ \"mcp3202\", mcp3202 },\n\t{ \"mcp3204\", mcp3204 },\n\t{ \"mcp3208\", mcp3208 },\n\t{ \"mcp3301\", mcp3301 },\n\t{ \"mcp3550-50\", mcp3550_50 },\n\t{ \"mcp3550-60\", mcp3550_60 },\n\t{ \"mcp3551\", mcp3551 },\n\t{ \"mcp3553\", mcp3553 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mcp320x_id);\n\nstatic struct spi_driver mcp320x_driver = {\n\t.driver = {\n\t\t.name = \"mcp320x\",\n\t\t.of_match_table = mcp320x_dt_ids,\n\t},\n\t.probe = mcp320x_probe,\n\t.remove = mcp320x_remove,\n\t.id_table = mcp320x_id,\n};\nmodule_spi_driver(mcp320x_driver);\n\nMODULE_AUTHOR(\"Oskar Andero <oskar.andero@gmail.com>\");\nMODULE_DESCRIPTION(\"Microchip Technology MCP3x01/02/04/08 and MCP3550/1/3\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}