{
  "module_name": "rzg2l_adc.c",
  "hash_id": "b5891122fcd8a3857d59aaeb0fc621bf185458af0bef590462d7a413a643be4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/rzg2l_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n\n#define DRIVER_NAME\t\t\"rzg2l-adc\"\n\n#define RZG2L_ADM(n)\t\t\t((n) * 0x4)\n#define RZG2L_ADM0_ADCE\t\t\tBIT(0)\n#define RZG2L_ADM0_ADBSY\t\tBIT(1)\n#define RZG2L_ADM0_PWDWNB\t\tBIT(2)\n#define RZG2L_ADM0_SRESB\t\tBIT(15)\n#define RZG2L_ADM1_TRG\t\t\tBIT(0)\n#define RZG2L_ADM1_MS\t\t\tBIT(2)\n#define RZG2L_ADM1_BS\t\t\tBIT(4)\n#define RZG2L_ADM1_EGA_MASK\t\tGENMASK(13, 12)\n#define RZG2L_ADM2_CHSEL_MASK\t\tGENMASK(7, 0)\n#define RZG2L_ADM3_ADIL_MASK\t\tGENMASK(31, 24)\n#define RZG2L_ADM3_ADCMP_MASK\t\tGENMASK(23, 16)\n#define RZG2L_ADM3_ADCMP_E\t\tFIELD_PREP(RZG2L_ADM3_ADCMP_MASK, 0xe)\n#define RZG2L_ADM3_ADSMP_MASK\t\tGENMASK(15, 0)\n\n#define RZG2L_ADINT\t\t\t0x20\n#define RZG2L_ADINT_INTEN_MASK\t\tGENMASK(7, 0)\n#define RZG2L_ADINT_CSEEN\t\tBIT(16)\n#define RZG2L_ADINT_INTS\t\tBIT(31)\n\n#define RZG2L_ADSTS\t\t\t0x24\n#define RZG2L_ADSTS_CSEST\t\tBIT(16)\n#define RZG2L_ADSTS_INTST_MASK\t\tGENMASK(7, 0)\n\n#define RZG2L_ADIVC\t\t\t0x28\n#define RZG2L_ADIVC_DIVADC_MASK\t\tGENMASK(8, 0)\n#define RZG2L_ADIVC_DIVADC_4\t\tFIELD_PREP(RZG2L_ADIVC_DIVADC_MASK, 0x4)\n\n#define RZG2L_ADFIL\t\t\t0x2c\n\n#define RZG2L_ADCR(n)\t\t\t(0x30 + ((n) * 0x4))\n#define RZG2L_ADCR_AD_MASK\t\tGENMASK(11, 0)\n\n#define RZG2L_ADSMP_DEFAULT_SAMPLING\t0x578\n\n#define RZG2L_ADC_MAX_CHANNELS\t\t8\n#define RZG2L_ADC_CHN_MASK\t\t0x7\n#define RZG2L_ADC_TIMEOUT\t\tusecs_to_jiffies(1 * 4)\n\nstruct rzg2l_adc_data {\n\tconst struct iio_chan_spec *channels;\n\tu8 num_channels;\n};\n\nstruct rzg2l_adc {\n\tvoid __iomem *base;\n\tstruct clk *pclk;\n\tstruct clk *adclk;\n\tstruct reset_control *presetn;\n\tstruct reset_control *adrstn;\n\tstruct completion completion;\n\tconst struct rzg2l_adc_data *data;\n\tstruct mutex lock;\n\tu16 last_val[RZG2L_ADC_MAX_CHANNELS];\n};\n\nstatic const char * const rzg2l_adc_channel_name[] = {\n\t\"adc0\",\n\t\"adc1\",\n\t\"adc2\",\n\t\"adc3\",\n\t\"adc4\",\n\t\"adc5\",\n\t\"adc6\",\n\t\"adc7\",\n};\n\nstatic unsigned int rzg2l_adc_readl(struct rzg2l_adc *adc, u32 reg)\n{\n\treturn readl(adc->base + reg);\n}\n\nstatic void rzg2l_adc_writel(struct rzg2l_adc *adc, unsigned int reg, u32 val)\n{\n\twritel(val, adc->base + reg);\n}\n\nstatic void rzg2l_adc_pwr(struct rzg2l_adc *adc, bool on)\n{\n\tu32 reg;\n\n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(0));\n\tif (on)\n\t\treg |= RZG2L_ADM0_PWDWNB;\n\telse\n\t\treg &= ~RZG2L_ADM0_PWDWNB;\n\trzg2l_adc_writel(adc, RZG2L_ADM(0), reg);\n\tudelay(2);\n}\n\nstatic void rzg2l_adc_start_stop(struct rzg2l_adc *adc, bool start)\n{\n\tint timeout = 5;\n\tu32 reg;\n\n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(0));\n\tif (start)\n\t\treg |= RZG2L_ADM0_ADCE;\n\telse\n\t\treg &= ~RZG2L_ADM0_ADCE;\n\trzg2l_adc_writel(adc, RZG2L_ADM(0), reg);\n\n\tif (start)\n\t\treturn;\n\n\tdo {\n\t\tusleep_range(100, 200);\n\t\treg = rzg2l_adc_readl(adc, RZG2L_ADM(0));\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\tpr_err(\"%s stopping ADC timed out\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t} while (((reg & RZG2L_ADM0_ADBSY) || (reg & RZG2L_ADM0_ADCE)));\n}\n\nstatic void rzg2l_set_trigger(struct rzg2l_adc *adc)\n{\n\tu32 reg;\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(1));\n\treg &= ~RZG2L_ADM1_EGA_MASK;\n\treg &= ~RZG2L_ADM1_BS;\n\treg &= ~RZG2L_ADM1_TRG;\n\treg |= RZG2L_ADM1_MS;\n\trzg2l_adc_writel(adc, RZG2L_ADM(1), reg);\n}\n\nstatic int rzg2l_adc_conversion_setup(struct rzg2l_adc *adc, u8 ch)\n{\n\tu32 reg;\n\n\tif (rzg2l_adc_readl(adc, RZG2L_ADM(0)) & RZG2L_ADM0_ADBSY)\n\t\treturn -EBUSY;\n\n\trzg2l_set_trigger(adc);\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(2));\n\treg &= ~RZG2L_ADM2_CHSEL_MASK;\n\treg |= BIT(ch);\n\trzg2l_adc_writel(adc, RZG2L_ADM(2), reg);\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADINT);\n\treg &= ~RZG2L_ADINT_INTS;\n\treg &= ~RZG2L_ADINT_INTEN_MASK;\n\treg |= (RZG2L_ADINT_CSEEN | BIT(ch));\n\trzg2l_adc_writel(adc, RZG2L_ADINT, reg);\n\n\treturn 0;\n}\n\nstatic int rzg2l_adc_set_power(struct iio_dev *indio_dev, bool on)\n{\n\tstruct device *dev = indio_dev->dev.parent;\n\n\tif (on)\n\t\treturn pm_runtime_resume_and_get(dev);\n\n\treturn pm_runtime_put_sync(dev);\n}\n\nstatic int rzg2l_adc_conversion(struct iio_dev *indio_dev, struct rzg2l_adc *adc, u8 ch)\n{\n\tint ret;\n\n\tret = rzg2l_adc_set_power(indio_dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rzg2l_adc_conversion_setup(adc, ch);\n\tif (ret) {\n\t\trzg2l_adc_set_power(indio_dev, false);\n\t\treturn ret;\n\t}\n\n\treinit_completion(&adc->completion);\n\n\trzg2l_adc_start_stop(adc, true);\n\n\tif (!wait_for_completion_timeout(&adc->completion, RZG2L_ADC_TIMEOUT)) {\n\t\trzg2l_adc_writel(adc, RZG2L_ADINT,\n\t\t\t\t rzg2l_adc_readl(adc, RZG2L_ADINT) & ~RZG2L_ADINT_INTEN_MASK);\n\t\trzg2l_adc_start_stop(adc, false);\n\t\trzg2l_adc_set_power(indio_dev, false);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn rzg2l_adc_set_power(indio_dev, false);\n}\n\nstatic int rzg2l_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct rzg2l_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu8 ch;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_VOLTAGE)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&adc->lock);\n\t\tch = chan->channel & RZG2L_ADC_CHN_MASK;\n\t\tret = rzg2l_adc_conversion(indio_dev, adc, ch);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&adc->lock);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = adc->last_val[ch];\n\t\tmutex_unlock(&adc->lock);\n\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rzg2l_adc_read_label(struct iio_dev *iio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tchar *label)\n{\n\treturn sysfs_emit(label, \"%s\\n\", rzg2l_adc_channel_name[chan->channel]);\n}\n\nstatic const struct iio_info rzg2l_adc_iio_info = {\n\t.read_raw = rzg2l_adc_read_raw,\n\t.read_label = rzg2l_adc_read_label,\n};\n\nstatic irqreturn_t rzg2l_adc_isr(int irq, void *dev_id)\n{\n\tstruct rzg2l_adc *adc = dev_id;\n\tunsigned long intst;\n\tu32 reg;\n\tint ch;\n\n\treg = rzg2l_adc_readl(adc, RZG2L_ADSTS);\n\n\t \n\tif (reg & RZG2L_ADSTS_CSEST) {\n\t\trzg2l_adc_writel(adc, RZG2L_ADSTS, reg);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tintst = reg & RZG2L_ADSTS_INTST_MASK;\n\tif (!intst)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(ch, &intst, RZG2L_ADC_MAX_CHANNELS)\n\t\tadc->last_val[ch] = rzg2l_adc_readl(adc, RZG2L_ADCR(ch)) & RZG2L_ADCR_AD_MASK;\n\n\t \n\trzg2l_adc_writel(adc, RZG2L_ADSTS, reg);\n\n\tcomplete(&adc->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rzg2l_adc_parse_properties(struct platform_device *pdev, struct rzg2l_adc *adc)\n{\n\tstruct iio_chan_spec *chan_array;\n\tstruct fwnode_handle *fwnode;\n\tstruct rzg2l_adc_data *data;\n\tunsigned int channel;\n\tint num_channels;\n\tint ret;\n\tu8 i;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tnum_channels = device_get_child_node_count(&pdev->dev);\n\tif (!num_channels) {\n\t\tdev_err(&pdev->dev, \"no channel children\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (num_channels > RZG2L_ADC_MAX_CHANNELS) {\n\t\tdev_err(&pdev->dev, \"num of channel children out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan_array = devm_kcalloc(&pdev->dev, num_channels, sizeof(*chan_array),\n\t\t\t\t  GFP_KERNEL);\n\tif (!chan_array)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(&pdev->dev, fwnode) {\n\t\tret = fwnode_property_read_u32(fwnode, \"reg\", &channel);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (channel >= RZG2L_ADC_MAX_CHANNELS) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchan_array[i].type = IIO_VOLTAGE;\n\t\tchan_array[i].indexed = 1;\n\t\tchan_array[i].channel = channel;\n\t\tchan_array[i].info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tchan_array[i].datasheet_name = rzg2l_adc_channel_name[channel];\n\t\ti++;\n\t}\n\n\tdata->num_channels = num_channels;\n\tdata->channels = chan_array;\n\tadc->data = data;\n\n\treturn 0;\n}\n\nstatic int rzg2l_adc_hw_init(struct rzg2l_adc *adc)\n{\n\tint timeout = 5;\n\tu32 reg;\n\tint ret;\n\n\tret = clk_prepare_enable(adc->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(0));\n\treg |= RZG2L_ADM0_SRESB;\n\trzg2l_adc_writel(adc, RZG2L_ADM(0), reg);\n\n\twhile (!(rzg2l_adc_readl(adc, RZG2L_ADM(0)) & RZG2L_ADM0_SRESB)) {\n\t\tif (!timeout) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto exit_hw_init;\n\t\t}\n\t\ttimeout--;\n\t\tusleep_range(100, 200);\n\t}\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADIVC);\n\treg &= ~RZG2L_ADIVC_DIVADC_MASK;\n\treg |= RZG2L_ADIVC_DIVADC_4;\n\trzg2l_adc_writel(adc, RZG2L_ADIVC, reg);\n\n\t \n\treg = rzg2l_adc_readl(adc, RZG2L_ADM(3));\n\treg &= ~RZG2L_ADM3_ADIL_MASK;\n\treg &= ~RZG2L_ADM3_ADCMP_MASK;\n\treg &= ~RZG2L_ADM3_ADSMP_MASK;\n\treg |= (RZG2L_ADM3_ADCMP_E | RZG2L_ADSMP_DEFAULT_SAMPLING);\n\trzg2l_adc_writel(adc, RZG2L_ADM(3), reg);\n\nexit_hw_init:\n\tclk_disable_unprepare(adc->pclk);\n\n\treturn ret;\n}\n\nstatic void rzg2l_adc_pm_runtime_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev->parent);\n}\n\nstatic void rzg2l_adc_pm_runtime_set_suspended(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_set_suspended(dev->parent);\n}\n\nstatic void rzg2l_adc_reset_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int rzg2l_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct rzg2l_adc *adc;\n\tint ret;\n\tint irq;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\n\tret = rzg2l_adc_parse_properties(pdev, adc);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&adc->lock);\n\n\tadc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc->base))\n\t\treturn PTR_ERR(adc->base);\n\n\tadc->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(adc->pclk)) {\n\t\tdev_err(dev, \"Failed to get pclk\");\n\t\treturn PTR_ERR(adc->pclk);\n\t}\n\n\tadc->adclk = devm_clk_get(dev, \"adclk\");\n\tif (IS_ERR(adc->adclk)) {\n\t\tdev_err(dev, \"Failed to get adclk\");\n\t\treturn PTR_ERR(adc->adclk);\n\t}\n\n\tadc->adrstn = devm_reset_control_get_exclusive(dev, \"adrst-n\");\n\tif (IS_ERR(adc->adrstn)) {\n\t\tdev_err(dev, \"failed to get adrstn\\n\");\n\t\treturn PTR_ERR(adc->adrstn);\n\t}\n\n\tadc->presetn = devm_reset_control_get_exclusive(dev, \"presetn\");\n\tif (IS_ERR(adc->presetn)) {\n\t\tdev_err(dev, \"failed to get presetn\\n\");\n\t\treturn PTR_ERR(adc->presetn);\n\t}\n\n\tret = reset_control_deassert(adc->adrstn);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert adrstn pin, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rzg2l_adc_reset_assert, adc->adrstn);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register adrstn assert devm action, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(adc->presetn);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert presetn pin, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rzg2l_adc_reset_assert, adc->presetn);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register presetn assert devm action, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = rzg2l_adc_hw_init(adc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to initialize ADC HW, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, rzg2l_adc_isr,\n\t\t\t       0, dev_name(dev), adc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_completion(&adc->completion);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = DRIVER_NAME;\n\tindio_dev->info = &rzg2l_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adc->data->channels;\n\tindio_dev->num_channels = adc->data->num_channels;\n\n\tpm_runtime_set_suspended(dev);\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rzg2l_adc_pm_runtime_set_suspended, &indio_dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rzg2l_adc_pm_runtime_disable, &indio_dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id rzg2l_adc_match[] = {\n\t{ .compatible = \"renesas,rzg2l-adc\",},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzg2l_adc_match);\n\nstatic int __maybe_unused rzg2l_adc_pm_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rzg2l_adc *adc = iio_priv(indio_dev);\n\n\trzg2l_adc_pwr(adc, false);\n\tclk_disable_unprepare(adc->adclk);\n\tclk_disable_unprepare(adc->pclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rzg2l_adc_pm_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rzg2l_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = clk_prepare_enable(adc->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adc->adclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(adc->pclk);\n\t\treturn ret;\n\t}\n\n\trzg2l_adc_pwr(adc, true);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rzg2l_adc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rzg2l_adc_pm_runtime_suspend,\n\t\t\t   rzg2l_adc_pm_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver rzg2l_adc_driver = {\n\t.probe\t\t= rzg2l_adc_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table = rzg2l_adc_match,\n\t\t.pm\t\t= &rzg2l_adc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rzg2l_adc_driver);\n\nMODULE_AUTHOR(\"Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}