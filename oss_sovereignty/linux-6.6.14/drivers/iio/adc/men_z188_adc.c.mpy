{
  "module_name": "men_z188_adc.c",
  "hash_id": "6f07964bbd28c6538583ee79f63477c423b62003020334b975ce9d17fc5e706a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/men_z188_adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mcb.h>\n#include <linux/io.h>\n#include <linux/iio/iio.h>\n\n#define Z188_ADC_MAX_CHAN\t8\n#define Z188_ADC_GAIN\t\t0x0700000\n#define Z188_MODE_VOLTAGE\tBIT(27)\n#define Z188_CFG_AUTO\t\t0x1\n#define Z188_CTRL_REG\t\t0x40\n\n#define ADC_DATA(x) (((x) >> 2) & 0x7ffffc)\n#define ADC_OVR(x) ((x) & 0x1)\n\nstruct z188_adc {\n\tstruct resource *mem;\n\tvoid __iomem *base;\n};\n\n#define Z188_ADC_CHANNEL(idx) {\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = (idx),\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),   \\\n}\n\nstatic const struct iio_chan_spec z188_adc_iio_channels[] = {\n\tZ188_ADC_CHANNEL(0),\n\tZ188_ADC_CHANNEL(1),\n\tZ188_ADC_CHANNEL(2),\n\tZ188_ADC_CHANNEL(3),\n\tZ188_ADC_CHANNEL(4),\n\tZ188_ADC_CHANNEL(5),\n\tZ188_ADC_CHANNEL(6),\n\tZ188_ADC_CHANNEL(7),\n};\n\nstatic int z188_iio_read_raw(struct iio_dev *iio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val,\n\t\t\tint *val2,\n\t\t\tlong info)\n{\n\tstruct z188_adc *adc = iio_priv(iio_dev);\n\tint ret;\n\tu16 tmp;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\ttmp = readw(adc->base + chan->channel * 4);\n\n\t\tif (ADC_OVR(tmp)) {\n\t\t\tdev_info(&iio_dev->dev,\n\t\t\t\t\"Oversampling error on ADC channel %d\\n\",\n\t\t\t\tchan->channel);\n\t\t\treturn -EIO;\n\t\t}\n\t\t*val = ADC_DATA(tmp);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info z188_adc_info = {\n\t.read_raw = &z188_iio_read_raw,\n};\n\nstatic void men_z188_config_channels(void __iomem *addr)\n{\n\tint i;\n\tu32 cfg;\n\tu32 ctl;\n\n\tctl = readl(addr + Z188_CTRL_REG);\n\tctl |= Z188_CFG_AUTO;\n\twritel(ctl, addr + Z188_CTRL_REG);\n\n\tfor (i = 0; i < Z188_ADC_MAX_CHAN; i++) {\n\t\tcfg = readl(addr + i);\n\t\tcfg &= ~Z188_ADC_GAIN;\n\t\tcfg |= Z188_MODE_VOLTAGE;\n\t\twritel(cfg, addr + i);\n\t}\n}\n\nstatic int men_z188_probe(struct mcb_device *dev,\n\t\t\tconst struct mcb_device_id *id)\n{\n\tstruct z188_adc *adc;\n\tstruct iio_dev *indio_dev;\n\tstruct resource *mem;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&dev->dev, sizeof(struct z188_adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tindio_dev->name = \"z188-adc\";\n\tindio_dev->info = &z188_adc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = z188_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(z188_adc_iio_channels);\n\n\tmem = mcb_request_mem(dev, \"z188-adc\");\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tadc->base = ioremap(mem->start, resource_size(mem));\n\tif (adc->base == NULL)\n\t\tgoto err;\n\n\tmen_z188_config_channels(adc->base);\n\n\tadc->mem = mem;\n\tmcb_set_drvdata(dev, indio_dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\n\nerr_unmap:\n\tiounmap(adc->base);\nerr:\n\tmcb_release_mem(mem);\n\treturn -ENXIO;\n}\n\nstatic void men_z188_remove(struct mcb_device *dev)\n{\n\tstruct iio_dev *indio_dev  = mcb_get_drvdata(dev);\n\tstruct z188_adc *adc = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiounmap(adc->base);\n\tmcb_release_mem(adc->mem);\n}\n\nstatic const struct mcb_device_id men_z188_ids[] = {\n\t{ .device = 0xbc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mcb, men_z188_ids);\n\nstatic struct mcb_driver men_z188_driver = {\n\t.driver = {\n\t\t.name = \"z188-adc\",\n\t},\n\t.probe = men_z188_probe,\n\t.remove = men_z188_remove,\n\t.id_table = men_z188_ids,\n};\nmodule_mcb_driver(men_z188_driver);\n\nMODULE_AUTHOR(\"Johannes Thumshirn <johannes.thumshirn@men.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IIO ADC driver for MEN 16z188 ADC Core\");\nMODULE_ALIAS(\"mcb:16z188\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}