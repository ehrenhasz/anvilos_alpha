{
  "module_name": "ti-adc108s102.c",
  "hash_id": "47643d595c4bbc6bdf0e689aa7a2f5090deae5379af9e79755062db192a22ab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc108s102.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/types.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n \n#define ADC108S102_VA_MV_ACPI_DEFAULT\t5000\n\n \n#define ADC108S102_BITS\t\t12\n#define ADC108S102_MAX_CHANNELS\t8\n\n \n#define ADC108S102_CMD(ch)\t\t((u16)(ch) << 11)\n\n \n#define ADC108S102_RES_DATA(res)\t((u16)res & GENMASK(11, 0))\n\nstruct adc108s102_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*reg;\n\tu32\t\t\t\tva_millivolt;\n\t \n\tstruct spi_transfer\t\tring_xfer;\n\t \n\tstruct spi_transfer\t\tscan_single_xfer;\n\t \n\tstruct spi_message\t\tring_msg;\n\t \n\tstruct spi_message\t\tscan_single_msg;\n\n\t \n\t__be16\t\t\t\trx_buf[9] __aligned(IIO_DMA_MINALIGN);\n\t__be16\t\t\t\ttx_buf[9] __aligned(IIO_DMA_MINALIGN);\n};\n\n#define ADC108S102_V_CHAN(index)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = index,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = ADC108S102_BITS,\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec adc108s102_channels[] = {\n\tADC108S102_V_CHAN(0),\n\tADC108S102_V_CHAN(1),\n\tADC108S102_V_CHAN(2),\n\tADC108S102_V_CHAN(3),\n\tADC108S102_V_CHAN(4),\n\tADC108S102_V_CHAN(5),\n\tADC108S102_V_CHAN(6),\n\tADC108S102_V_CHAN(7),\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n};\n\nstatic int adc108s102_update_scan_mode(struct iio_dev *indio_dev,\n\t\tunsigned long const *active_scan_mask)\n{\n\tstruct adc108s102_state *st = iio_priv(indio_dev);\n\tunsigned int bit, cmds;\n\n\t \n\tcmds = 0;\n\tfor_each_set_bit(bit, active_scan_mask, ADC108S102_MAX_CHANNELS)\n\t\tst->tx_buf[cmds++] = cpu_to_be16(ADC108S102_CMD(bit));\n\n\t \n\tst->tx_buf[cmds++] = 0x00;\n\n\t \n\tst->ring_xfer.tx_buf = &st->tx_buf[0];\n\tst->ring_xfer.rx_buf = &st->rx_buf[0];\n\tst->ring_xfer.len = cmds * sizeof(st->tx_buf[0]);\n\n\tspi_message_init_with_transfers(&st->ring_msg, &st->ring_xfer, 1);\n\n\treturn 0;\n}\n\nstatic irqreturn_t adc108s102_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adc108s102_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = spi_sync(st->spi, &st->ring_msg);\n\tif (ret < 0)\n\t\tgoto out_notify;\n\n\t \n\tiio_push_to_buffers_with_ts_unaligned(indio_dev,\n\t\t\t\t\t      &st->rx_buf[1],\n\t\t\t\t\t      st->ring_xfer.len - sizeof(st->rx_buf[1]),\n\t\t\t\t\t      iio_get_time_ns(indio_dev));\n\nout_notify:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc108s102_scan_direct(struct adc108s102_state *st, unsigned int ch)\n{\n\tint ret;\n\n\tst->tx_buf[0] = cpu_to_be16(ADC108S102_CMD(ch));\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn be16_to_cpu(st->rx_buf[1]);\n}\n\nstatic int adc108s102_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long m)\n{\n\tstruct adc108s102_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adc108s102_scan_direct(st, chan->address);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ADC108S102_RES_DATA(ret);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_VOLTAGE)\n\t\t\tbreak;\n\n\t\t*val = st->va_millivolt;\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info adc108s102_info = {\n\t.read_raw\t\t= &adc108s102_read_raw,\n\t.update_scan_mode\t= &adc108s102_update_scan_mode,\n};\n\nstatic void adc108s102_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int adc108s102_probe(struct spi_device *spi)\n{\n\tstruct adc108s102_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tif (ACPI_COMPANION(&spi->dev)) {\n\t\tst->va_millivolt = ADC108S102_VA_MV_ACPI_DEFAULT;\n\t} else {\n\t\tst->reg = devm_regulator_get(&spi->dev, \"vref\");\n\t\tif (IS_ERR(st->reg))\n\t\t\treturn PTR_ERR(st->reg);\n\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&spi->dev, \"Cannot enable vref regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = devm_add_action_or_reset(&spi->dev, adc108s102_reg_disable,\n\t\t\t\t\t       st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&spi->dev, \"vref get voltage failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tst->va_millivolt = ret / 1000;\n\t}\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi->modalias;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adc108s102_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adc108s102_channels);\n\tindio_dev->info = &adc108s102_info;\n\n\t \n\tst->scan_single_xfer.tx_buf = st->tx_buf;\n\tst->scan_single_xfer.rx_buf = st->rx_buf;\n\tst->scan_single_xfer.len = 2 * sizeof(st->tx_buf[0]);\n\n\tspi_message_init_with_transfers(&st->scan_single_msg,\n\t\t\t\t\t&st->scan_single_xfer, 1);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      &adc108s102_trigger_handler,\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"Failed to register IIO device\\n\");\n\treturn ret;\n}\n\nstatic const struct of_device_id adc108s102_of_match[] = {\n\t{ .compatible = \"ti,adc108s102\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc108s102_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id adc108s102_acpi_ids[] = {\n\t{ \"INT3495\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, adc108s102_acpi_ids);\n#endif\n\nstatic const struct spi_device_id adc108s102_id[] = {\n\t{ \"adc108s102\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adc108s102_id);\n\nstatic struct spi_driver adc108s102_driver = {\n\t.driver = {\n\t\t.name   = \"adc108s102\",\n\t\t.of_match_table = adc108s102_of_match,\n\t\t.acpi_match_table = ACPI_PTR(adc108s102_acpi_ids),\n\t},\n\t.probe\t\t= adc108s102_probe,\n\t.id_table\t= adc108s102_id,\n};\nmodule_spi_driver(adc108s102_driver);\n\nMODULE_AUTHOR(\"Bogdan Pricop <bogdan.pricop@emutex.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADC108S102 and ADC128S102 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}