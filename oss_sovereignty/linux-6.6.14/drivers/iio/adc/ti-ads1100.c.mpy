{
  "module_name": "ti-ads1100.c",
  "hash_id": "b7c38a6f8a9e85d5d4aa485656409caf1dc10e6f6489692dfacd9e321f13301b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads1100.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/units.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/types.h>\n\n \n\n \n#define ADS1100_CFG_ST_BSY\tBIT(7)\n \n#define ADS1100_CFG_SC\t\tBIT(4)\n \n#define ADS1100_DR_MASK\t\tGENMASK(3, 2)\n \n#define ADS1100_PGA_MASK\tGENMASK(1, 0)\n\n#define ADS1100_CONTINUOUS\t0\n#define\tADS1100_SINGLESHOT\tADS1100_CFG_SC\n\n#define ADS1100_SLEEP_DELAY_MS\t2000\n\nstatic const int ads1100_data_rate[] = { 128, 32, 16, 8 };\nstatic const int ads1100_data_rate_bits[] = { 12, 14, 15, 16 };\n\nstruct ads1100_data {\n\tstruct i2c_client *client;\n\tstruct regulator *reg_vdd;\n\tstruct mutex lock;\n\tint scale_avail[2 * 4];  \n\tu8 config;\n\tbool supports_data_rate;  \n};\n\nstatic const struct iio_chan_spec ads1100_channel = {\n\t.type = IIO_VOLTAGE,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t.info_mask_shared_by_all =\n\t    BIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.info_mask_shared_by_all_available =\n\t    BIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.scan_type = {\n\t\t      .sign = 's',\n\t\t      .realbits = 16,\n\t\t      .storagebits = 16,\n\t\t      .endianness = IIO_CPU,\n\t\t       },\n\t.datasheet_name = \"AIN\",\n};\n\nstatic int ads1100_set_config_bits(struct ads1100_data *data, u8 mask, u8 value)\n{\n\tint ret;\n\tu8 config = (data->config & ~mask) | (value & mask);\n\n\tif (data->config == config)\n\t\treturn 0;\t \n\n\tret = i2c_master_send(data->client, &config, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->config = config;\n\n\treturn 0;\n};\n\nstatic int ads1100_data_bits(struct ads1100_data *data)\n{\n\treturn ads1100_data_rate_bits[FIELD_GET(ADS1100_DR_MASK, data->config)];\n}\n\nstatic int ads1100_get_adc_result(struct ads1100_data *data, int chan, int *val)\n{\n\tint ret;\n\t__be16 buffer;\n\ts16 value;\n\n\tif (chan != 0)\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_resume_and_get(&data->client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_master_recv(data->client, (char *)&buffer, sizeof(buffer));\n\n\tpm_runtime_mark_last_busy(&data->client->dev);\n\tpm_runtime_put_autosuspend(&data->client->dev);\n\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"I2C read fail: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tvalue = be16_to_cpu(buffer);\n\n\t \n\tvalue <<= 16 - ads1100_data_bits(data);\n\n\t*val = sign_extend32(value, 15);\n\n\treturn 0;\n}\n\nstatic int ads1100_set_scale(struct ads1100_data *data, int val, int val2)\n{\n\tint microvolts;\n\tint gain;\n\n\t \n\tif (val)\n\t\treturn -EINVAL;\n\n\tif (!val2)\n\t\treturn -EINVAL;\n\n\tmicrovolts = regulator_get_voltage(data->reg_vdd);\n\t \n\tgain = DIV_ROUND_CLOSEST(microvolts, BIT(15)) * MILLI / val2;\n\tif (gain < BIT(0) || gain > BIT(3))\n\t\treturn -EINVAL;\n\n\tads1100_set_config_bits(data, ADS1100_PGA_MASK, ffs(gain) - 1);\n\n\treturn 0;\n}\n\nstatic int ads1100_set_data_rate(struct ads1100_data *data, int chan, int rate)\n{\n\tunsigned int i;\n\tunsigned int size;\n\n\tsize = data->supports_data_rate ? ARRAY_SIZE(ads1100_data_rate) : 1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (ads1100_data_rate[i] == rate)\n\t\t\treturn ads1100_set_config_bits(data, ADS1100_DR_MASK,\n\t\t\t\t\t\t       FIELD_PREP(ADS1100_DR_MASK, i));\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ads1100_get_vdd_millivolts(struct ads1100_data *data)\n{\n\treturn regulator_get_voltage(data->reg_vdd) / (MICRO / MILLI);\n}\n\nstatic void ads1100_calc_scale_avail(struct ads1100_data *data)\n{\n\tint millivolts = ads1100_get_vdd_millivolts(data);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->scale_avail) / 2; i++) {\n\t\tdata->scale_avail[i * 2 + 0] = millivolts;\n\t\tdata->scale_avail[i * 2 + 1] = 15 + i;\n\t}\n}\n\nstatic int ads1100_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct ads1100_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_VOLTAGE)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT;\n\t\t*vals = ads1100_data_rate;\n\t\tif (data->supports_data_rate)\n\t\t\t*length = ARRAY_SIZE(ads1100_data_rate);\n\t\telse\n\t\t\t*length = 1;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_FRACTIONAL_LOG2;\n\t\t*vals = data->scale_avail;\n\t\t*length = ARRAY_SIZE(data->scale_avail);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ads1100_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tint ret;\n\tstruct ads1100_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ads1100_get_adc_result(data, chan->address, val);\n\t\tif (ret >= 0)\n\t\t\tret = IIO_VAL_INT;\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = ads1100_get_vdd_millivolts(data);\n\t\t*val2 = 15 + FIELD_GET(ADS1100_PGA_MASK, data->config);\n\t\tret = IIO_VAL_FRACTIONAL_LOG2;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = ads1100_data_rate[FIELD_GET(ADS1100_DR_MASK,\n\t\t\t\t\t\t   data->config)];\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int ads1100_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct ads1100_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ads1100_set_scale(data, val, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = ads1100_set_data_rate(data, chan->address, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info ads1100_info = {\n\t.read_avail = ads1100_read_avail,\n\t.read_raw = ads1100_read_raw,\n\t.write_raw = ads1100_write_raw,\n};\n\nstatic int ads1100_setup(struct ads1100_data *data)\n{\n\tint ret;\n\tu8 buffer[3];\n\n\t \n\tbuffer[0] = ADS1100_DR_MASK | ADS1100_CONTINUOUS;\n\tret = i2c_master_send(data->client, buffer, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_master_recv(data->client, buffer, sizeof(buffer));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->config = buffer[2] & ~ADS1100_CFG_ST_BSY;\n\n\t \n\tdata->supports_data_rate = FIELD_GET(ADS1100_DR_MASK, buffer[2]) != 0;\n\n\treturn 0;\n}\n\nstatic void ads1100_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic void ads1100_disable_continuous(void *data)\n{\n\tads1100_set_config_bits(data, ADS1100_CFG_SC, ADS1100_SINGLESHOT);\n}\n\nstatic int ads1100_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ads1100_data *data;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, data);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = \"ads1100\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = &ads1100_channel;\n\tindio_dev->num_channels = 1;\n\tindio_dev->info = &ads1100_info;\n\n\tdata->reg_vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(data->reg_vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->reg_vdd),\n\t\t\t\t     \"Failed to get vdd regulator\\n\");\n\n\tret = regulator_enable(data->reg_vdd);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable vdd regulator\\n\");\n\n\tret = devm_add_action_or_reset(dev, ads1100_reg_disable, data->reg_vdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ads1100_setup(data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to communicate with device\\n\");\n\n\tret = devm_add_action_or_reset(dev, ads1100_disable_continuous, data);\n\tif (ret)\n\t\treturn ret;\n\n\tads1100_calc_scale_avail(data);\n\n\tpm_runtime_set_autosuspend_delay(dev, ADS1100_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable pm_runtime\\n\");\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to register IIO device\\n\");\n\n\treturn 0;\n}\n\nstatic int ads1100_runtime_suspend(struct device *dev)\n{\n\tstruct ads1100_data *data = dev_get_drvdata(dev);\n\n\tads1100_set_config_bits(data, ADS1100_CFG_SC, ADS1100_SINGLESHOT);\n\tregulator_disable(data->reg_vdd);\n\n\treturn 0;\n}\n\nstatic int ads1100_runtime_resume(struct device *dev)\n{\n\tstruct ads1100_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_enable(data->reg_vdd);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"Failed to enable Vdd\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treturn ads1100_set_config_bits(data, ADS1100_CFG_SC,\n\t\t\t\t       ADS1100_CONTINUOUS);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ads1100_pm_ops,\n\t\t\t\t ads1100_runtime_suspend,\n\t\t\t\t ads1100_runtime_resume,\n\t\t\t\t NULL);\n\nstatic const struct i2c_device_id ads1100_id[] = {\n\t{ \"ads1100\" },\n\t{ \"ads1000\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, ads1100_id);\n\nstatic const struct of_device_id ads1100_of_match[] = {\n\t{.compatible = \"ti,ads1100\" },\n\t{.compatible = \"ti,ads1000\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, ads1100_of_match);\n\nstatic struct i2c_driver ads1100_driver = {\n\t.driver = {\n\t\t   .name = \"ads1100\",\n\t\t   .of_match_table = ads1100_of_match,\n\t\t   .pm = pm_ptr(&ads1100_pm_ops),\n\t},\n\t.probe = ads1100_probe,\n\t.id_table = ads1100_id,\n};\n\nmodule_i2c_driver(ads1100_driver);\n\nMODULE_AUTHOR(\"Mike Looijmans <mike.looijmans@topic.nl>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADS1100 ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}