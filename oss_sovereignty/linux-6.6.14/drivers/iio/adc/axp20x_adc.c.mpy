{
  "module_name": "axp20x_adc.c",
  "hash_id": "78c983076623e66b739d7528e8989a19a1712d1239ab3fddfe64e8f3d2f59b2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/axp20x_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/mfd/axp20x.h>\n\n#define AXP20X_ADC_EN1_MASK\t\t\tGENMASK(7, 0)\n#define AXP20X_ADC_EN2_MASK\t\t\t(GENMASK(3, 2) | BIT(7))\n\n#define AXP22X_ADC_EN1_MASK\t\t\t(GENMASK(7, 5) | BIT(0))\n\n#define AXP20X_GPIO10_IN_RANGE_GPIO0\t\tBIT(0)\n#define AXP20X_GPIO10_IN_RANGE_GPIO1\t\tBIT(1)\n\n#define AXP20X_ADC_RATE_MASK\t\t\tGENMASK(7, 6)\n#define AXP20X_ADC_RATE_HZ(x)\t\t\t((ilog2((x) / 25) << 6) & AXP20X_ADC_RATE_MASK)\n\n#define AXP22X_ADC_RATE_HZ(x)\t\t\t((ilog2((x) / 100) << 6) & AXP20X_ADC_RATE_MASK)\n\n#define AXP813_V_I_ADC_RATE_MASK\t\tGENMASK(5, 4)\n#define AXP813_ADC_RATE_MASK\t\t\t(AXP20X_ADC_RATE_MASK | AXP813_V_I_ADC_RATE_MASK)\n#define AXP813_TS_GPIO0_ADC_RATE_HZ(x)\t\tAXP20X_ADC_RATE_HZ(x)\n#define AXP813_V_I_ADC_RATE_HZ(x)\t\t((ilog2((x) / 100) << 4) & AXP813_V_I_ADC_RATE_MASK)\n#define AXP813_ADC_RATE_HZ(x)\t\t\t(AXP20X_ADC_RATE_HZ(x) | AXP813_V_I_ADC_RATE_HZ(x))\n\n#define AXP20X_ADC_CHANNEL(_channel, _name, _type, _reg)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = _channel,\t\t\t\t\\\n\t\t.address = _reg,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.datasheet_name = _name,\t\t\t\\\n\t}\n\n#define AXP20X_ADC_CHANNEL_OFFSET(_channel, _name, _type, _reg) \\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = _channel,\t\t\t\t\\\n\t\t.address = _reg,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\\\n\t\t.datasheet_name = _name,\t\t\t\\\n\t}\n\nstruct axp_data;\n\nstruct axp20x_adc_iio {\n\tstruct regmap\t\t*regmap;\n\tconst struct axp_data\t*data;\n};\n\nenum axp20x_adc_channel_v {\n\tAXP20X_ACIN_V = 0,\n\tAXP20X_VBUS_V,\n\tAXP20X_TS_IN,\n\tAXP20X_GPIO0_V,\n\tAXP20X_GPIO1_V,\n\tAXP20X_IPSOUT_V,\n\tAXP20X_BATT_V,\n};\n\nenum axp20x_adc_channel_i {\n\tAXP20X_ACIN_I = 0,\n\tAXP20X_VBUS_I,\n\tAXP20X_BATT_CHRG_I,\n\tAXP20X_BATT_DISCHRG_I,\n};\n\nenum axp22x_adc_channel_v {\n\tAXP22X_TS_IN = 0,\n\tAXP22X_BATT_V,\n};\n\nenum axp22x_adc_channel_i {\n\tAXP22X_BATT_CHRG_I = 1,\n\tAXP22X_BATT_DISCHRG_I,\n};\n\nenum axp813_adc_channel_v {\n\tAXP813_TS_IN = 0,\n\tAXP813_GPIO0_V,\n\tAXP813_BATT_V,\n};\n\nstatic struct iio_map axp20x_maps[] = {\n\t{\n\t\t.consumer_dev_name = \"axp20x-usb-power-supply\",\n\t\t.consumer_channel = \"vbus_v\",\n\t\t.adc_channel_label = \"vbus_v\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-usb-power-supply\",\n\t\t.consumer_channel = \"vbus_i\",\n\t\t.adc_channel_label = \"vbus_i\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-ac-power-supply\",\n\t\t.consumer_channel = \"acin_v\",\n\t\t.adc_channel_label = \"acin_v\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-ac-power-supply\",\n\t\t.consumer_channel = \"acin_i\",\n\t\t.adc_channel_label = \"acin_i\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_v\",\n\t\t.adc_channel_label = \"batt_v\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_chrg_i\",\n\t\t.adc_channel_label = \"batt_chrg_i\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_dischrg_i\",\n\t\t.adc_channel_label = \"batt_dischrg_i\",\n\t}, {   }\n};\n\nstatic struct iio_map axp22x_maps[] = {\n\t{\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_v\",\n\t\t.adc_channel_label = \"batt_v\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_chrg_i\",\n\t\t.adc_channel_label = \"batt_chrg_i\",\n\t}, {\n\t\t.consumer_dev_name = \"axp20x-battery-power-supply\",\n\t\t.consumer_channel = \"batt_dischrg_i\",\n\t\t.adc_channel_label = \"batt_dischrg_i\",\n\t}, {   }\n};\n\n \nstatic const struct iio_chan_spec axp20x_adc_channels[] = {\n\tAXP20X_ADC_CHANNEL(AXP20X_ACIN_V, \"acin_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_ACIN_V_ADC_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_ACIN_I, \"acin_i\", IIO_CURRENT,\n\t\t\t   AXP20X_ACIN_I_ADC_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_VBUS_V, \"vbus_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_VBUS_V_ADC_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_VBUS_I, \"vbus_i\", IIO_CURRENT,\n\t\t\t   AXP20X_VBUS_I_ADC_H),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = AXP20X_TEMP_ADC_H,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.datasheet_name = \"pmic_temp\",\n\t},\n\tAXP20X_ADC_CHANNEL_OFFSET(AXP20X_GPIO0_V, \"gpio0_v\", IIO_VOLTAGE,\n\t\t\t\t  AXP20X_GPIO0_V_ADC_H),\n\tAXP20X_ADC_CHANNEL_OFFSET(AXP20X_GPIO1_V, \"gpio1_v\", IIO_VOLTAGE,\n\t\t\t\t  AXP20X_GPIO1_V_ADC_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_IPSOUT_V, \"ipsout_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_IPSOUT_V_HIGH_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_BATT_V, \"batt_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_BATT_V_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_BATT_CHRG_I, \"batt_chrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_CHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_BATT_DISCHRG_I, \"batt_dischrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_DISCHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP20X_TS_IN, \"ts_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_TS_IN_H),\n};\n\nstatic const struct iio_chan_spec axp22x_adc_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = AXP22X_PMIC_TEMP_H,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.datasheet_name = \"pmic_temp\",\n\t},\n\tAXP20X_ADC_CHANNEL(AXP22X_BATT_V, \"batt_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_BATT_V_H),\n\tAXP20X_ADC_CHANNEL(AXP22X_BATT_CHRG_I, \"batt_chrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_CHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP22X_BATT_DISCHRG_I, \"batt_dischrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_DISCHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP22X_TS_IN, \"ts_v\", IIO_VOLTAGE,\n\t\t\t   AXP22X_TS_ADC_H),\n};\n\nstatic const struct iio_chan_spec axp813_adc_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = AXP22X_PMIC_TEMP_H,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.datasheet_name = \"pmic_temp\",\n\t},\n\tAXP20X_ADC_CHANNEL(AXP813_GPIO0_V, \"gpio0_v\", IIO_VOLTAGE,\n\t\t\t   AXP288_GP_ADC_H),\n\tAXP20X_ADC_CHANNEL(AXP813_BATT_V, \"batt_v\", IIO_VOLTAGE,\n\t\t\t   AXP20X_BATT_V_H),\n\tAXP20X_ADC_CHANNEL(AXP22X_BATT_CHRG_I, \"batt_chrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_CHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP22X_BATT_DISCHRG_I, \"batt_dischrg_i\", IIO_CURRENT,\n\t\t\t   AXP20X_BATT_DISCHRG_I_H),\n\tAXP20X_ADC_CHANNEL(AXP813_TS_IN, \"ts_v\", IIO_VOLTAGE,\n\t\t\t   AXP288_TS_ADC_H),\n};\n\nstatic int axp20x_adc_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val)\n{\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\tint ret, size;\n\n\t \n\tif (chan->type == IIO_CURRENT && chan->channel == AXP20X_BATT_DISCHRG_I)\n\t\tsize = 13;\n\telse\n\t\tsize = 12;\n\n\tret = axp20x_read_variable_width(info->regmap, chan->address, size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn IIO_VAL_INT;\n}\n\nstatic int axp22x_adc_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val)\n{\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = axp20x_read_variable_width(info->regmap, chan->address, 12);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn IIO_VAL_INT;\n}\n\nstatic int axp813_adc_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val)\n{\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = axp20x_read_variable_width(info->regmap, chan->address, 12);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn IIO_VAL_INT;\n}\n\nstatic int axp20x_adc_scale_voltage(int channel, int *val, int *val2)\n{\n\tswitch (channel) {\n\tcase AXP20X_ACIN_V:\n\tcase AXP20X_VBUS_V:\n\t\t*val = 1;\n\t\t*val2 = 700000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_GPIO0_V:\n\tcase AXP20X_GPIO1_V:\n\t\t*val = 0;\n\t\t*val2 = 500000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_BATT_V:\n\t\t*val = 1;\n\t\t*val2 = 100000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_IPSOUT_V:\n\t\t*val = 1;\n\t\t*val2 = 400000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_TS_IN:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 800000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp22x_adc_scale_voltage(int channel, int *val, int *val2)\n{\n\tswitch (channel) {\n\tcase AXP22X_BATT_V:\n\t\t \n\t\t*val = 1;\n\t\t*val2 = 100000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP22X_TS_IN:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 800000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nstatic int axp813_adc_scale_voltage(int channel, int *val, int *val2)\n{\n\tswitch (channel) {\n\tcase AXP813_GPIO0_V:\n\t\t*val = 0;\n\t\t*val2 = 800000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP813_BATT_V:\n\t\t*val = 1;\n\t\t*val2 = 100000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP813_TS_IN:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 800000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp20x_adc_scale_current(int channel, int *val, int *val2)\n{\n\tswitch (channel) {\n\tcase AXP20X_ACIN_I:\n\t\t*val = 0;\n\t\t*val2 = 625000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_VBUS_I:\n\t\t*val = 0;\n\t\t*val2 = 375000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase AXP20X_BATT_DISCHRG_I:\n\tcase AXP20X_BATT_CHRG_I:\n\t\t*val = 0;\n\t\t*val2 = 500000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp20x_adc_scale(struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2)\n{\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\treturn axp20x_adc_scale_voltage(chan->channel, val, val2);\n\n\tcase IIO_CURRENT:\n\t\treturn axp20x_adc_scale_current(chan->channel, val, val2);\n\n\tcase IIO_TEMP:\n\t\t*val = 100;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp22x_adc_scale(struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2)\n{\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\treturn axp22x_adc_scale_voltage(chan->channel, val, val2);\n\n\tcase IIO_CURRENT:\n\t\t*val = 1;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_TEMP:\n\t\t*val = 100;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp813_adc_scale(struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2)\n{\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\treturn axp813_adc_scale_voltage(chan->channel, val, val2);\n\n\tcase IIO_CURRENT:\n\t\t*val = 1;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_TEMP:\n\t\t*val = 100;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp20x_adc_offset_voltage(struct iio_dev *indio_dev, int channel,\n\t\t\t\t     int *val)\n{\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(info->regmap, AXP20X_GPIO10_IN_RANGE, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (channel) {\n\tcase AXP20X_GPIO0_V:\n\t\tregval = FIELD_GET(AXP20X_GPIO10_IN_RANGE_GPIO0, regval);\n\t\tbreak;\n\n\tcase AXP20X_GPIO1_V:\n\t\tregval = FIELD_GET(AXP20X_GPIO10_IN_RANGE_GPIO1, regval);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val = regval ? 700000 : 0;\n\treturn IIO_VAL_INT;\n}\n\nstatic int axp20x_adc_offset(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val)\n{\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\treturn axp20x_adc_offset_voltage(indio_dev, chan->channel, val);\n\n\tcase IIO_TEMP:\n\t\t*val = -1447;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp20x_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn axp20x_adc_offset(indio_dev, chan, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn axp20x_adc_scale(chan, val, val2);\n\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn axp20x_adc_raw(indio_dev, chan, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp22x_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = -2677;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn axp22x_adc_scale(chan, val, val2);\n\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn axp22x_adc_raw(indio_dev, chan, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp813_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -2667;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn axp813_adc_scale(chan, val, val2);\n\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn axp813_adc_raw(indio_dev, chan, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axp20x_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int val, int val2,\n\t\t\t    long mask)\n{\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\tunsigned int regmask, regval;\n\n\t \n\tif (mask != IIO_CHAN_INFO_OFFSET)\n\t\treturn -EINVAL;\n\n\tif (val != 0 && val != 700000)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel) {\n\tcase AXP20X_GPIO0_V:\n\t\tregmask = AXP20X_GPIO10_IN_RANGE_GPIO0;\n\t\tregval = FIELD_PREP(AXP20X_GPIO10_IN_RANGE_GPIO0, !!val);\n\t\tbreak;\n\n\tcase AXP20X_GPIO1_V:\n\t\tregmask = AXP20X_GPIO10_IN_RANGE_GPIO1;\n\t\tregval = FIELD_PREP(AXP20X_GPIO10_IN_RANGE_GPIO1, !!val);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(info->regmap, AXP20X_GPIO10_IN_RANGE, regmask, regval);\n}\n\nstatic const struct iio_info axp20x_adc_iio_info = {\n\t.read_raw = axp20x_read_raw,\n\t.write_raw = axp20x_write_raw,\n};\n\nstatic const struct iio_info axp22x_adc_iio_info = {\n\t.read_raw = axp22x_read_raw,\n};\n\nstatic const struct iio_info axp813_adc_iio_info = {\n\t.read_raw = axp813_read_raw,\n};\n\nstatic int axp20x_adc_rate(struct axp20x_adc_iio *info, int rate)\n{\n\treturn regmap_update_bits(info->regmap, AXP20X_ADC_RATE,\n\t\t\t\t  AXP20X_ADC_RATE_MASK,\n\t\t\t\t  AXP20X_ADC_RATE_HZ(rate));\n}\n\nstatic int axp22x_adc_rate(struct axp20x_adc_iio *info, int rate)\n{\n\treturn regmap_update_bits(info->regmap, AXP20X_ADC_RATE,\n\t\t\t\t  AXP20X_ADC_RATE_MASK,\n\t\t\t\t  AXP22X_ADC_RATE_HZ(rate));\n}\n\nstatic int axp813_adc_rate(struct axp20x_adc_iio *info, int rate)\n{\n\treturn regmap_update_bits(info->regmap, AXP813_ADC_RATE,\n\t\t\t\t AXP813_ADC_RATE_MASK,\n\t\t\t\t AXP813_ADC_RATE_HZ(rate));\n}\n\nstruct axp_data {\n\tconst struct iio_info\t\t*iio_info;\n\tint\t\t\t\tnum_channels;\n\tstruct iio_chan_spec const\t*channels;\n\tunsigned long\t\t\tadc_en1_mask;\n\tunsigned long\t\t\tadc_en2_mask;\n\tint\t\t\t\t(*adc_rate)(struct axp20x_adc_iio *info,\n\t\t\t\t\t\t    int rate);\n\tstruct iio_map\t\t\t*maps;\n};\n\nstatic const struct axp_data axp20x_data = {\n\t.iio_info = &axp20x_adc_iio_info,\n\t.num_channels = ARRAY_SIZE(axp20x_adc_channels),\n\t.channels = axp20x_adc_channels,\n\t.adc_en1_mask = AXP20X_ADC_EN1_MASK,\n\t.adc_en2_mask = AXP20X_ADC_EN2_MASK,\n\t.adc_rate = axp20x_adc_rate,\n\t.maps = axp20x_maps,\n};\n\nstatic const struct axp_data axp22x_data = {\n\t.iio_info = &axp22x_adc_iio_info,\n\t.num_channels = ARRAY_SIZE(axp22x_adc_channels),\n\t.channels = axp22x_adc_channels,\n\t.adc_en1_mask = AXP22X_ADC_EN1_MASK,\n\t.adc_rate = axp22x_adc_rate,\n\t.maps = axp22x_maps,\n};\n\nstatic const struct axp_data axp813_data = {\n\t.iio_info = &axp813_adc_iio_info,\n\t.num_channels = ARRAY_SIZE(axp813_adc_channels),\n\t.channels = axp813_adc_channels,\n\t.adc_en1_mask = AXP22X_ADC_EN1_MASK,\n\t.adc_rate = axp813_adc_rate,\n\t.maps = axp22x_maps,\n};\n\nstatic const struct of_device_id axp20x_adc_of_match[] = {\n\t{ .compatible = \"x-powers,axp209-adc\", .data = (void *)&axp20x_data, },\n\t{ .compatible = \"x-powers,axp221-adc\", .data = (void *)&axp22x_data, },\n\t{ .compatible = \"x-powers,axp813-adc\", .data = (void *)&axp813_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, axp20x_adc_of_match);\n\nstatic const struct platform_device_id axp20x_adc_id_match[] = {\n\t{ .name = \"axp20x-adc\", .driver_data = (kernel_ulong_t)&axp20x_data, },\n\t{ .name = \"axp22x-adc\", .driver_data = (kernel_ulong_t)&axp22x_data, },\n\t{ .name = \"axp813-adc\", .driver_data = (kernel_ulong_t)&axp813_data, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, axp20x_adc_id_match);\n\nstatic int axp20x_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_adc_iio *info;\n\tstruct iio_dev *indio_dev;\n\tstruct axp20x_dev *axp20x_dev;\n\tint ret;\n\n\taxp20x_dev = dev_get_drvdata(pdev->dev.parent);\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tinfo = iio_priv(indio_dev);\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinfo->regmap = axp20x_dev->regmap;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (!dev_fwnode(&pdev->dev)) {\n\t\tconst struct platform_device_id *id;\n\n\t\tid = platform_get_device_id(pdev);\n\t\tinfo->data = (const struct axp_data *)id->driver_data;\n\t} else {\n\t\tstruct device *dev = &pdev->dev;\n\n\t\tinfo->data = device_get_match_data(dev);\n\t}\n\n\tindio_dev->name = platform_get_device_id(pdev)->name;\n\tindio_dev->info = info->data->iio_info;\n\tindio_dev->num_channels = info->data->num_channels;\n\tindio_dev->channels = info->data->channels;\n\n\t \n\tregmap_write(info->regmap, AXP20X_ADC_EN1, info->data->adc_en1_mask);\n\n\tif (info->data->adc_en2_mask)\n\t\tregmap_update_bits(info->regmap, AXP20X_ADC_EN2,\n\t\t\t\t   info->data->adc_en2_mask,\n\t\t\t\t   info->data->adc_en2_mask);\n\n\t \n\tinfo->data->adc_rate(info, 100);\n\n\tret = iio_map_array_register(indio_dev, info->data->maps);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register IIO maps: %d\\n\", ret);\n\t\tgoto fail_map;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not register the device\\n\");\n\t\tgoto fail_register;\n\t}\n\n\treturn 0;\n\nfail_register:\n\tiio_map_array_unregister(indio_dev);\n\nfail_map:\n\tregmap_write(info->regmap, AXP20X_ADC_EN1, 0);\n\n\tif (info->data->adc_en2_mask)\n\t\tregmap_write(info->regmap, AXP20X_ADC_EN2, 0);\n\n\treturn ret;\n}\n\nstatic int axp20x_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct axp20x_adc_iio *info = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_map_array_unregister(indio_dev);\n\n\tregmap_write(info->regmap, AXP20X_ADC_EN1, 0);\n\n\tif (info->data->adc_en2_mask)\n\t\tregmap_write(info->regmap, AXP20X_ADC_EN2, 0);\n\n\treturn 0;\n}\n\nstatic struct platform_driver axp20x_adc_driver = {\n\t.driver = {\n\t\t.name = \"axp20x-adc\",\n\t\t.of_match_table = axp20x_adc_of_match,\n\t},\n\t.id_table = axp20x_adc_id_match,\n\t.probe = axp20x_probe,\n\t.remove = axp20x_remove,\n};\n\nmodule_platform_driver(axp20x_adc_driver);\n\nMODULE_DESCRIPTION(\"ADC driver for AXP20X and AXP22X PMICs\");\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}