{
  "module_name": "palmas_gpadc.c",
  "hash_id": "aacaaac21d52ab54d09774395f329a3ae340a1727e1287762fbd972a60bf732b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/palmas_gpadc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/mfd/palmas.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n\n#define MOD_NAME \"palmas-gpadc\"\n#define PALMAS_ADC_CONVERSION_TIMEOUT\t(msecs_to_jiffies(5000))\n#define PALMAS_TO_BE_CALCULATED 0\n#define PALMAS_GPADC_TRIMINVALID\t-1\n\nstruct palmas_gpadc_info {\n \n\tint x1;\t \n\tint x2;\t \n\tint v1;\t \n\tint v2;\t \n\tu8 trim1_reg;\t \n\tu8 trim2_reg;\t \n\tint gain;\t \n\tint offset;\t \n\tint gain_error;\t \n\tbool is_uncalibrated;\t \n};\n\n#define PALMAS_ADC_INFO(_chan, _x1, _x2, _v1, _v2, _t1, _t2, _is_uncalibrated) \\\n\t[PALMAS_ADC_CH_##_chan] = { \\\n\t\t.x1 = _x1, \\\n\t\t.x2 = _x2, \\\n\t\t.v1 = _v1, \\\n\t\t.v2 = _v2, \\\n\t\t.gain = PALMAS_TO_BE_CALCULATED, \\\n\t\t.offset = PALMAS_TO_BE_CALCULATED, \\\n\t\t.gain_error = PALMAS_TO_BE_CALCULATED, \\\n\t\t.trim1_reg = PALMAS_GPADC_TRIM##_t1, \\\n\t\t.trim2_reg = PALMAS_GPADC_TRIM##_t2,  \\\n\t\t.is_uncalibrated = _is_uncalibrated \\\n\t}\n\nstatic struct palmas_gpadc_info palmas_gpadc_info[] = {\n\tPALMAS_ADC_INFO(IN0, 2064, 3112, 630, 950, 1, 2, false),\n\tPALMAS_ADC_INFO(IN1, 2064, 3112, 630, 950, 1, 2, false),\n\tPALMAS_ADC_INFO(IN2, 2064, 3112, 1260, 1900, 3, 4, false),\n\tPALMAS_ADC_INFO(IN3, 2064, 3112, 630, 950, 1, 2, false),\n\tPALMAS_ADC_INFO(IN4, 2064, 3112, 630, 950, 1, 2, false),\n\tPALMAS_ADC_INFO(IN5, 2064, 3112, 630, 950, 1, 2, false),\n\tPALMAS_ADC_INFO(IN6, 2064, 3112, 2520, 3800, 5, 6, false),\n\tPALMAS_ADC_INFO(IN7, 2064, 3112, 2520, 3800, 7, 8, false),\n\tPALMAS_ADC_INFO(IN8, 2064, 3112, 3150, 4750, 9, 10, false),\n\tPALMAS_ADC_INFO(IN9, 2064, 3112, 5670, 8550, 11, 12, false),\n\tPALMAS_ADC_INFO(IN10, 2064, 3112, 3465, 5225, 13, 14, false),\n\tPALMAS_ADC_INFO(IN11, 0, 0, 0, 0, INVALID, INVALID, true),\n\tPALMAS_ADC_INFO(IN12, 0, 0, 0, 0, INVALID, INVALID, true),\n\tPALMAS_ADC_INFO(IN13, 0, 0, 0, 0, INVALID, INVALID, true),\n\tPALMAS_ADC_INFO(IN14, 2064, 3112, 3645, 5225, 15, 16, false),\n\tPALMAS_ADC_INFO(IN15, 0, 0, 0, 0, INVALID, INVALID, true),\n};\n\nstruct palmas_adc_event {\n\tbool enabled;\n\tint channel;\n\tenum iio_event_direction direction;\n};\n\nstruct palmas_gpadc_thresholds {\n\tint high;\n\tint low;\n};\n\n \nstruct palmas_gpadc {\n\tstruct device\t\t\t*dev;\n\tstruct palmas\t\t\t*palmas;\n\tu8\t\t\t\tch0_current;\n\tu8\t\t\t\tch3_current;\n\tbool\t\t\t\textended_delay;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tirq_auto_0;\n\tint\t\t\t\tirq_auto_1;\n\tstruct palmas_gpadc_info\t*adc_info;\n\tstruct completion\t\tconv_completion;\n\tstruct palmas_adc_event\t\tevent0;\n\tstruct palmas_adc_event\t\tevent1;\n\tstruct palmas_gpadc_thresholds\tthresholds[PALMAS_ADC_CH_MAX];\n\tint\t\t\t\tauto_conversion_period;\n\tstruct mutex\t\t\tlock;\n};\n\nstatic struct palmas_adc_event *palmas_gpadc_get_event(struct palmas_gpadc *adc,\n\t\t\t\t\t\t       int adc_chan,\n\t\t\t\t\t\t       enum iio_event_direction dir)\n{\n\tif (adc_chan == adc->event0.channel && dir == adc->event0.direction)\n\t\treturn &adc->event0;\n\n\tif (adc_chan == adc->event1.channel && dir == adc->event1.direction)\n\t\treturn &adc->event1;\n\n\treturn NULL;\n}\n\nstatic bool palmas_gpadc_channel_is_freerunning(struct palmas_gpadc *adc,\n\t\t\t\t\t\tint adc_chan)\n{\n\treturn palmas_gpadc_get_event(adc, adc_chan, IIO_EV_DIR_RISING) ||\n\t\tpalmas_gpadc_get_event(adc, adc_chan, IIO_EV_DIR_FALLING);\n}\n\n \n\nstatic int palmas_disable_auto_conversion(struct palmas_gpadc *adc)\n{\n\tint ret;\n\n\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_CTRL1,\n\t\t\tPALMAS_GPADC_CTRL1_GPADC_FORCE,\n\t\t\tPALMAS_GPADC_CTRL1_GPADC_FORCE);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"GPADC_CTRL1 update failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_AUTO_CTRL,\n\t\t\tPALMAS_GPADC_AUTO_CTRL_SHUTDOWN_CONV1 |\n\t\t\tPALMAS_GPADC_AUTO_CTRL_SHUTDOWN_CONV0,\n\t\t\t0);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"AUTO_CTRL update failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tudelay(100);\n\n\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_CTRL1,\n\t\t\tPALMAS_GPADC_CTRL1_GPADC_FORCE, 0);\n\tif (ret < 0)\n\t\tdev_err(adc->dev, \"GPADC_CTRL1 update failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic irqreturn_t palmas_gpadc_irq(int irq, void *data)\n{\n\tstruct palmas_gpadc *adc = data;\n\n\tcomplete(&adc->conv_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t palmas_gpadc_irq_auto(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\tstruct palmas_adc_event *ev;\n\n\tdev_dbg(adc->dev, \"Threshold interrupt %d occurs\\n\", irq);\n\tpalmas_disable_auto_conversion(adc);\n\n\tev = (irq == adc->irq_auto_0) ? &adc->event0 : &adc->event1;\n\tif (ev->channel != -1) {\n\t\tenum iio_event_direction dir;\n\t\tu64 code;\n\n\t\tdir = ev->direction;\n\t\tcode = IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, ev->channel,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH, dir);\n\t\tiio_push_event(indio_dev, code, iio_get_time_ns(indio_dev));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int palmas_gpadc_start_mask_interrupt(struct palmas_gpadc *adc,\n\t\t\t\t\t\tbool mask)\n{\n\tint ret;\n\n\tif (!mask)\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_INTERRUPT_BASE,\n\t\t\t\t\tPALMAS_INT3_MASK,\n\t\t\t\t\tPALMAS_INT3_MASK_GPADC_EOC_SW, 0);\n\telse\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_INTERRUPT_BASE,\n\t\t\t\t\tPALMAS_INT3_MASK,\n\t\t\t\t\tPALMAS_INT3_MASK_GPADC_EOC_SW,\n\t\t\t\t\tPALMAS_INT3_MASK_GPADC_EOC_SW);\n\tif (ret < 0)\n\t\tdev_err(adc->dev, \"GPADC INT MASK update failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_enable(struct palmas_gpadc *adc, int adc_chan,\n\t\t\t       int enable)\n{\n\tunsigned int mask, val;\n\tint ret;\n\n\tif (enable) {\n\t\tval = (adc->extended_delay\n\t\t\t<< PALMAS_GPADC_RT_CTRL_EXTEND_DELAY_SHIFT);\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\t\tPALMAS_GPADC_RT_CTRL,\n\t\t\t\t\tPALMAS_GPADC_RT_CTRL_EXTEND_DELAY, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"RT_CTRL update failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmask = (PALMAS_GPADC_CTRL1_CURRENT_SRC_CH0_MASK |\n\t\t\tPALMAS_GPADC_CTRL1_CURRENT_SRC_CH3_MASK |\n\t\t\tPALMAS_GPADC_CTRL1_GPADC_FORCE);\n\t\tval = (adc->ch0_current\n\t\t\t<< PALMAS_GPADC_CTRL1_CURRENT_SRC_CH0_SHIFT);\n\t\tval |= (adc->ch3_current\n\t\t\t<< PALMAS_GPADC_CTRL1_CURRENT_SRC_CH3_SHIFT);\n\t\tval |= PALMAS_GPADC_CTRL1_GPADC_FORCE;\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_CTRL1, mask, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\t\"Failed to update current setting: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmask = (PALMAS_GPADC_SW_SELECT_SW_CONV0_SEL_MASK |\n\t\t\tPALMAS_GPADC_SW_SELECT_SW_CONV_EN);\n\t\tval = (adc_chan | PALMAS_GPADC_SW_SELECT_SW_CONV_EN);\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_SW_SELECT, mask, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"SW_SELECT update failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_SW_SELECT, 0);\n\t\tif (ret < 0)\n\t\t\tdev_err(adc->dev, \"SW_SELECT write failed: %d\\n\", ret);\n\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_CTRL1,\n\t\t\t\tPALMAS_GPADC_CTRL1_GPADC_FORCE, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"CTRL1 update failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_read_prepare(struct palmas_gpadc *adc, int adc_chan)\n{\n\tint ret;\n\n\tif (palmas_gpadc_channel_is_freerunning(adc, adc_chan))\n\t\treturn 0;  \n\n\tret = palmas_gpadc_enable(adc, adc_chan, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn palmas_gpadc_start_mask_interrupt(adc, 0);\n}\n\nstatic void palmas_gpadc_read_done(struct palmas_gpadc *adc, int adc_chan)\n{\n\tpalmas_gpadc_start_mask_interrupt(adc, 1);\n\tpalmas_gpadc_enable(adc, adc_chan, false);\n}\n\nstatic int palmas_gpadc_calibrate(struct palmas_gpadc *adc, int adc_chan)\n{\n\tint k;\n\tint d1;\n\tint d2;\n\tint ret;\n\tint gain;\n\tint x1 =  adc->adc_info[adc_chan].x1;\n\tint x2 =  adc->adc_info[adc_chan].x2;\n\tint v1 = adc->adc_info[adc_chan].v1;\n\tint v2 = adc->adc_info[adc_chan].v2;\n\n\tret = palmas_read(adc->palmas, PALMAS_TRIM_GPADC_BASE,\n\t\t\t\tadc->adc_info[adc_chan].trim1_reg, &d1);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"TRIM read failed: %d\\n\", ret);\n\t\tgoto scrub;\n\t}\n\n\tret = palmas_read(adc->palmas, PALMAS_TRIM_GPADC_BASE,\n\t\t\t\tadc->adc_info[adc_chan].trim2_reg, &d2);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"TRIM read failed: %d\\n\", ret);\n\t\tgoto scrub;\n\t}\n\n\t \n\tk = (1000 + (1000 * (d2 - d1)) / (x2 - x1));\n\n\t \n\tgain = ((v2 - v1) * 1000) / (x2 - x1);\n\n\tadc->adc_info[adc_chan].gain_error = k;\n\tadc->adc_info[adc_chan].gain = gain;\n\t \n\tadc->adc_info[adc_chan].offset = (d1 * 1000) - ((k - 1000) * x1);\n\nscrub:\n\treturn ret;\n}\n\nstatic int palmas_gpadc_start_conversion(struct palmas_gpadc *adc, int adc_chan)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (palmas_gpadc_channel_is_freerunning(adc, adc_chan)) {\n\t\tint event = (adc_chan == adc->event0.channel) ? 0 : 1;\n\t\tunsigned int reg = (event == 0) ?\n\t\t\tPALMAS_GPADC_AUTO_CONV0_LSB :\n\t\t\tPALMAS_GPADC_AUTO_CONV1_LSB;\n\n\t\tret = palmas_bulk_read(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\t\treg, &val, 2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"AUTO_CONV%x_LSB read failed: %d\\n\",\n\t\t\t\tevent, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tinit_completion(&adc->conv_completion);\n\t\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\t\tPALMAS_GPADC_SW_SELECT,\n\t\t\t\t\tPALMAS_GPADC_SW_SELECT_SW_START_CONV0,\n\t\t\t\t\tPALMAS_GPADC_SW_SELECT_SW_START_CONV0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"SELECT_SW_START write failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = wait_for_completion_timeout(&adc->conv_completion,\n\t\t\t\t\tPALMAS_ADC_CONVERSION_TIMEOUT);\n\t\tif (ret == 0) {\n\t\t\tdev_err(adc->dev, \"conversion not completed\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tret = palmas_bulk_read(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\t\tPALMAS_GPADC_SW_CONV0_LSB, &val, 2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev, \"SW_CONV0_LSB read failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = val & 0xFFF;\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_get_calibrated_code(struct palmas_gpadc *adc,\n\t\t\t\t\t\tint adc_chan, int val)\n{\n\tif (!adc->adc_info[adc_chan].is_uncalibrated)\n\t\tval  = (val*1000 - adc->adc_info[adc_chan].offset) /\n\t\t\t\t\tadc->adc_info[adc_chan].gain_error;\n\n\tif (val < 0) {\n\t\tif (val < -10)\n\t\t\tdev_err(adc->dev, \"Mismatch with calibration var = %d\\n\", val);\n\t\treturn 0;\n\t}\n\n\tval = (val * adc->adc_info[adc_chan].gain) / 1000;\n\n\treturn val;\n}\n\n \nstatic int palmas_gpadc_threshold_with_tolerance(int val, const int INL,\n\t\t\t\t\t\t const int gain_error,\n\t\t\t\t\t\t const int offset_error)\n{\n\tval = ((val + INL) * (1000 + gain_error)) / 1000 + offset_error;\n\n\treturn clamp(val, 0, 0xFFF);\n}\n\n \nstatic int palmas_gpadc_get_high_threshold_raw(struct palmas_gpadc *adc,\n\t\t\t\t\t       struct palmas_adc_event *ev)\n{\n\tconst int adc_chan = ev->channel;\n\tint val = adc->thresholds[adc_chan].high;\n\t \n\tconst int max_INL = 2;\n\t \n\tint max_offset_error;\n\t \n\tint max_gain_error = 2;\n\n\tval = (val * 1000) / adc->adc_info[adc_chan].gain;\n\n\tif (adc->adc_info[adc_chan].is_uncalibrated) {\n\t\t \n\t\tmax_gain_error += 20;\n\t\tmax_offset_error = 36;\n\t} else {\n\t\tval = (val * adc->adc_info[adc_chan].gain_error +\n\t\t       adc->adc_info[adc_chan].offset) /\n\t\t\t1000;\n\t\tmax_offset_error = 2;\n\t}\n\n\treturn palmas_gpadc_threshold_with_tolerance(val,\n\t\t\t\t\t\t     max_INL,\n\t\t\t\t\t\t     max_gain_error,\n\t\t\t\t\t\t     max_offset_error);\n}\n\n \nstatic int palmas_gpadc_get_low_threshold_raw(struct palmas_gpadc *adc,\n\t\t\t\t\t      struct palmas_adc_event *ev)\n{\n\tconst int adc_chan = ev->channel;\n\tint val = adc->thresholds[adc_chan].low;\n\t \n\tconst int min_INL = -2;\n\t \n\tint min_offset_error;\n\t \n\tint min_gain_error = -6;\n\n\tval = (val * 1000) / adc->adc_info[adc_chan].gain;\n\n        if (adc->adc_info[adc_chan].is_uncalibrated) {\n\t\t \n\t\tmin_gain_error -= 20;\n\t\tmin_offset_error = -36;\n        } else {\n\t\tval = (val * adc->adc_info[adc_chan].gain_error -\n\t\t       adc->adc_info[adc_chan].offset) /\n\t\t\t1000;\n\t\tmin_offset_error = -2;\n        }\n\n\treturn palmas_gpadc_threshold_with_tolerance(val,\n\t\t\t\t\t\t     min_INL,\n\t\t\t\t\t\t     min_gain_error,\n\t\t\t\t\t\t     min_offset_error);\n}\n\nstatic int palmas_gpadc_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long mask)\n{\n\tstruct  palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret = 0;\n\n\tif (adc_chan >= PALMAS_ADC_CH_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = palmas_gpadc_read_prepare(adc, adc_chan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = palmas_gpadc_start_conversion(adc, adc_chan);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\"ADC start conversion failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mask == IIO_CHAN_INFO_PROCESSED)\n\t\t\tret = palmas_gpadc_get_calibrated_code(\n\t\t\t\t\t\t\tadc, adc_chan, ret);\n\n\t\t*val = ret;\n\n\t\tret = IIO_VAL_INT;\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&adc->lock);\n\treturn ret;\n\nout:\n\tpalmas_gpadc_read_done(adc, adc_chan);\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir)\n{\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret = 0;\n\n\tif (adc_chan >= PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\n\tif (palmas_gpadc_get_event(adc, adc_chan, dir))\n\t\tret = 1;\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int palmas_adc_configure_events(struct palmas_gpadc *adc);\nstatic int palmas_adc_reset_events(struct palmas_gpadc *adc);\n\nstatic int palmas_gpadc_reconfigure_event_channels(struct palmas_gpadc *adc)\n{\n\treturn (adc->event0.enabled || adc->event1.enabled) ?\n\t\tpalmas_adc_configure_events(adc) :\n\t\tpalmas_adc_reset_events(adc);\n}\n\nstatic int palmas_gpadc_enable_event_config(struct palmas_gpadc *adc,\n\t\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct palmas_adc_event *ev;\n\tint adc_chan = chan->channel;\n\n\tif (palmas_gpadc_get_event(adc, adc_chan, dir))\n\t\t \n\t\treturn 0;\n\n\tif (adc->event0.channel == -1) {\n\t\tev = &adc->event0;\n\t} else if (adc->event1.channel == -1) {\n\t\t \n\t\tif (adc_chan < adc->event0.channel) {\n\t\t\tadc->event1 = adc->event0;\n\t\t\tev = &adc->event0;\n\t\t} else {\n\t\t\tev = &adc->event1;\n\t\t}\n\t} else {  \n\t\tdev_warn(adc->dev, \"event0 - %d, event1 - %d\\n\",\n\t\t\t adc->event0.channel, adc->event1.channel);\n\t\treturn -EBUSY;\n\t}\n\n\tev->enabled = true;\n\tev->channel = adc_chan;\n\tev->direction = dir;\n\n\treturn palmas_gpadc_reconfigure_event_channels(adc);\n}\n\nstatic int palmas_gpadc_disable_event_config(struct palmas_gpadc *adc,\n\t\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t\t     enum iio_event_direction dir)\n{\n\tint adc_chan = chan->channel;\n\tstruct palmas_adc_event *ev = palmas_gpadc_get_event(adc, adc_chan, dir);\n\n\tif (!ev)\n\t\treturn 0;\n\n\tif (ev == &adc->event0) {\n\t\tadc->event0 = adc->event1;\n\t\tev = &adc->event1;\n\t}\n\n\tev->enabled = false;\n\tev->channel = -1;\n\tev->direction = IIO_EV_DIR_NONE;\n\n\treturn palmas_gpadc_reconfigure_event_channels(adc);\n}\n\nstatic int palmas_gpadc_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   enum iio_event_type type,\n\t\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t\t   int state)\n{\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret;\n\n\tif (adc_chan >= PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\n\tif (state)\n\t\tret = palmas_gpadc_enable_event_config(adc, chan, dir);\n\telse\n\t\tret = palmas_gpadc_disable_event_config(adc, chan, dir);\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_type type,\n\t\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t\t enum iio_event_info info,\n\t\t\t\t\t int *val, int *val2)\n{\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret;\n\n\tif (adc_chan >= PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = (dir == IIO_EV_DIR_RISING) ?\n\t\t\tadc->thresholds[adc_chan].high :\n\t\t\tadc->thresholds[adc_chan].low;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t\t  enum iio_event_info info,\n\t\t\t\t\t  int val, int val2)\n{\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint old;\n\tint ret;\n\n\tif (adc_chan >= PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val < 0 || val > 0xFFF) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (dir == IIO_EV_DIR_RISING) {\n\t\t\told = adc->thresholds[adc_chan].high;\n\t\t\tadc->thresholds[adc_chan].high = val;\n\t\t} else {\n\t\t\told = adc->thresholds[adc_chan].low;\n\t\t\tadc->thresholds[adc_chan].low = val;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (val != old && palmas_gpadc_get_event(adc, adc_chan, dir))\n\t\tret = palmas_gpadc_reconfigure_event_channels(adc);\n\nout_unlock:\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info palmas_gpadc_iio_info = {\n\t.read_raw = palmas_gpadc_read_raw,\n\t.read_event_config = palmas_gpadc_read_event_config,\n\t.write_event_config = palmas_gpadc_write_event_config,\n\t.read_event_value = palmas_gpadc_read_event_value,\n\t.write_event_value = palmas_gpadc_write_event_value,\n};\n\nstatic const struct iio_event_spec palmas_gpadc_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n#define PALMAS_ADC_CHAN_IIO(chan, _type, chan_info)\t\\\n{\t\t\t\t\t\t\t\\\n\t.datasheet_name = PALMAS_DATASHEET_NAME(chan),\t\\\n\t.type = _type,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\tBIT(chan_info),\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = PALMAS_ADC_CH_##chan,\t\t\\\n\t.event_spec = palmas_gpadc_events,\t\t\\\n\t.num_event_specs = ARRAY_SIZE(palmas_gpadc_events)\t\\\n}\n\nstatic const struct iio_chan_spec palmas_gpadc_iio_channel[] = {\n\tPALMAS_ADC_CHAN_IIO(IN0, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN1, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tPALMAS_ADC_CHAN_IIO(IN2, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN3, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tPALMAS_ADC_CHAN_IIO(IN4, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN5, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN6, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN7, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN8, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN9, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN10, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN11, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN12, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tPALMAS_ADC_CHAN_IIO(IN13, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tPALMAS_ADC_CHAN_IIO(IN14, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tPALMAS_ADC_CHAN_IIO(IN15, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n};\n\nstatic int palmas_gpadc_get_adc_dt_data(struct platform_device *pdev,\n\tstruct palmas_gpadc_platform_data **gpadc_pdata)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct palmas_gpadc_platform_data *gp_data;\n\tint ret;\n\tu32 pval;\n\n\tgp_data = devm_kzalloc(&pdev->dev, sizeof(*gp_data), GFP_KERNEL);\n\tif (!gp_data)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"ti,channel0-current-microamp\", &pval);\n\tif (!ret)\n\t\tgp_data->ch0_current = pval;\n\n\tret = of_property_read_u32(np, \"ti,channel3-current-microamp\", &pval);\n\tif (!ret)\n\t\tgp_data->ch3_current = pval;\n\n\tgp_data->extended_delay = of_property_read_bool(np,\n\t\t\t\t\t\"ti,enable-extended-delay\");\n\n\t*gpadc_pdata = gp_data;\n\n\treturn 0;\n}\n\nstatic void palmas_gpadc_reset(void *data)\n{\n\tstruct palmas_gpadc *adc = data;\n\tif (adc->event0.enabled || adc->event1.enabled)\n\t\tpalmas_adc_reset_events(adc);\n}\n\nstatic int palmas_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct palmas_gpadc *adc;\n\tstruct palmas_platform_data *pdata;\n\tstruct palmas_gpadc_platform_data *gpadc_pdata = NULL;\n\tstruct iio_dev *indio_dev;\n\tint ret, i;\n\n\tpdata = dev_get_platdata(pdev->dev.parent);\n\n\tif (pdata && pdata->gpadc_pdata)\n\t\tgpadc_pdata = pdata->gpadc_pdata;\n\n\tif (!gpadc_pdata && pdev->dev.of_node) {\n\t\tret = palmas_gpadc_get_adc_dt_data(pdev, &gpadc_pdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (!gpadc_pdata)\n\t\treturn -EINVAL;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"iio_device_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(indio_dev);\n\tadc->dev = &pdev->dev;\n\tadc->palmas = dev_get_drvdata(pdev->dev.parent);\n\tadc->adc_info = palmas_gpadc_info;\n\n\tmutex_init(&adc->lock);\n\n\tinit_completion(&adc->conv_completion);\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tadc->auto_conversion_period = gpadc_pdata->auto_conversion_period_ms;\n\tadc->irq = palmas_irq_get_virq(adc->palmas, PALMAS_GPADC_EOC_SW_IRQ);\n\tif (adc->irq < 0)\n\t\treturn dev_err_probe(adc->dev, adc->irq, \"get virq failed\\n\");\n\n\tret = devm_request_threaded_irq(&pdev->dev, adc->irq, NULL,\n\t\t\t\t\tpalmas_gpadc_irq,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(adc->dev),\n\t\t\t\t\tadc);\n\tif (ret < 0)\n\t\treturn dev_err_probe(adc->dev, ret,\n\t\t\t\t     \"request irq %d failed\\n\", adc->irq);\n\n\tadc->irq_auto_0 = platform_get_irq(pdev, 1);\n\tif (adc->irq_auto_0 < 0)\n\t\treturn adc->irq_auto_0;\n\n\tret = devm_request_threaded_irq(&pdev->dev, adc->irq_auto_0, NULL,\n\t\t\t\t\tpalmas_gpadc_irq_auto, IRQF_ONESHOT,\n\t\t\t\t\t\"palmas-adc-auto-0\", indio_dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(adc->dev, ret,\n\t\t\t\t     \"request auto0 irq %d failed\\n\",\n\t\t\t\t     adc->irq_auto_0);\n\n\tadc->irq_auto_1 = platform_get_irq(pdev, 2);\n\tif (adc->irq_auto_1 < 0)\n\t\treturn adc->irq_auto_1;\n\n\tret = devm_request_threaded_irq(&pdev->dev, adc->irq_auto_1, NULL,\n\t\t\t\t\tpalmas_gpadc_irq_auto, IRQF_ONESHOT,\n\t\t\t\t\t\"palmas-adc-auto-1\", indio_dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(adc->dev, ret,\n\t\t\t\t     \"request auto1 irq %d failed\\n\",\n\t\t\t\t     adc->irq_auto_1);\n\n\tadc->event0.enabled = false;\n\tadc->event0.channel = -1;\n\tadc->event0.direction = IIO_EV_DIR_NONE;\n\tadc->event1.enabled = false;\n\tadc->event1.channel = -1;\n\tadc->event1.direction = IIO_EV_DIR_NONE;\n\n\t \n\tif (gpadc_pdata->ch0_current <= 1)\n\t\tadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_0;\n\telse if (gpadc_pdata->ch0_current <= 5)\n\t\tadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_5;\n\telse if (gpadc_pdata->ch0_current <= 15)\n\t\tadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_15;\n\telse\n\t\tadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_20;\n\n\t \n\tif (gpadc_pdata->ch3_current <= 1)\n\t\tadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_0;\n\telse if (gpadc_pdata->ch3_current <= 10)\n\t\tadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_10;\n\telse if (gpadc_pdata->ch3_current <= 400)\n\t\tadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_400;\n\telse\n\t\tadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_800;\n\n\tadc->extended_delay = gpadc_pdata->extended_delay;\n\n\tindio_dev->name = MOD_NAME;\n\tindio_dev->info = &palmas_gpadc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = palmas_gpadc_iio_channel;\n\tindio_dev->num_channels = ARRAY_SIZE(palmas_gpadc_iio_channel);\n\n\tret = devm_iio_device_register(&pdev->dev, indio_dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(adc->dev, ret,\n\t\t\t\t     \"iio_device_register() failed\\n\");\n\n\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\tfor (i = 0; i < PALMAS_ADC_CH_MAX; i++) {\n\t\tif (!(adc->adc_info[i].is_uncalibrated))\n\t\t\tpalmas_gpadc_calibrate(adc, i);\n\t}\n\n\tret = devm_add_action(&pdev->dev, palmas_gpadc_reset, adc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int palmas_adc_configure_events(struct palmas_gpadc *adc)\n{\n\tint adc_period, conv;\n\tint i;\n\tint ch0 = 0, ch1 = 0;\n\tint thres;\n\tint ret;\n\n\tadc_period = adc->auto_conversion_period;\n\tfor (i = 0; i < 16; ++i) {\n\t\tif (((1000 * (1 << i)) / 32) >= adc_period)\n\t\t\tbreak;\n\t}\n\tif (i > 0)\n\t\ti--;\n\tadc_period = i;\n\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_AUTO_CTRL,\n\t\t\tPALMAS_GPADC_AUTO_CTRL_COUNTER_CONV_MASK,\n\t\t\tadc_period);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"AUTO_CTRL write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tconv = 0;\n\tif (adc->event0.enabled) {\n\t\tstruct palmas_adc_event *ev = &adc->event0;\n\t\tint polarity;\n\n\t\tch0 = ev->channel;\n\t\tconv |= PALMAS_GPADC_AUTO_CTRL_AUTO_CONV0_EN;\n\t\tswitch (ev->direction) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tthres = palmas_gpadc_get_high_threshold_raw(adc, ev);\n\t\t\tpolarity = 0;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tthres = palmas_gpadc_get_low_threshold_raw(adc, ev);\n\t\t\tpolarity = PALMAS_GPADC_THRES_CONV0_MSB_THRES_CONV0_POL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_THRES_CONV0_LSB, thres & 0xFF);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\t\"THRES_CONV0_LSB write failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_THRES_CONV0_MSB,\n\t\t\t\t((thres >> 8) & 0xF) | polarity);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\t\"THRES_CONV0_MSB write failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (adc->event1.enabled) {\n\t\tstruct palmas_adc_event *ev = &adc->event1;\n\t\tint polarity;\n\n\t\tch1 = ev->channel;\n\t\tconv |= PALMAS_GPADC_AUTO_CTRL_AUTO_CONV1_EN;\n\t\tswitch (ev->direction) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tthres = palmas_gpadc_get_high_threshold_raw(adc, ev);\n\t\t\tpolarity = 0;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tthres = palmas_gpadc_get_low_threshold_raw(adc, ev);\n\t\t\tpolarity = PALMAS_GPADC_THRES_CONV1_MSB_THRES_CONV1_POL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_THRES_CONV1_LSB, thres & 0xFF);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\t\"THRES_CONV1_LSB write failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\t\tPALMAS_GPADC_THRES_CONV1_MSB,\n\t\t\t\t((thres >> 8) & 0xF) | polarity);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\t\"THRES_CONV1_MSB write failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_AUTO_SELECT, (ch1 << 4) | ch0);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"AUTO_SELECT write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_AUTO_CTRL,\n\t\t\tPALMAS_GPADC_AUTO_CTRL_AUTO_CONV1_EN |\n\t\t\tPALMAS_GPADC_AUTO_CTRL_AUTO_CONV0_EN, conv);\n\tif (ret < 0)\n\t\tdev_err(adc->dev, \"AUTO_CTRL write failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int palmas_adc_reset_events(struct palmas_gpadc *adc)\n{\n\tint ret;\n\n\tret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\n\t\t\tPALMAS_GPADC_AUTO_SELECT, 0);\n\tif (ret < 0) {\n\t\tdev_err(adc->dev, \"AUTO_SELECT write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_disable_auto_conversion(adc);\n\tif (ret < 0)\n\t\tdev_err(adc->dev, \"Disable auto conversion failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int palmas_gpadc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\n\tif (!device_may_wakeup(dev))\n\t\treturn 0;\n\n\tif (adc->event0.enabled)\n\t\tenable_irq_wake(adc->irq_auto_0);\n\n\tif (adc->event1.enabled)\n\t\tenable_irq_wake(adc->irq_auto_1);\n\n\treturn 0;\n}\n\nstatic int palmas_gpadc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\n\tif (!device_may_wakeup(dev))\n\t\treturn 0;\n\n\tif (adc->event0.enabled)\n\t\tdisable_irq_wake(adc->irq_auto_0);\n\n\tif (adc->event1.enabled)\n\t\tdisable_irq_wake(adc->irq_auto_1);\n\n\treturn 0;\n};\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(palmas_pm_ops, palmas_gpadc_suspend,\n\t\t\t\tpalmas_gpadc_resume);\n\nstatic const struct of_device_id of_palmas_gpadc_match_tbl[] = {\n\t{ .compatible = \"ti,palmas-gpadc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_palmas_gpadc_match_tbl);\n\nstatic struct platform_driver palmas_gpadc_driver = {\n\t.probe = palmas_gpadc_probe,\n\t.driver = {\n\t\t.name = MOD_NAME,\n\t\t.pm = pm_sleep_ptr(&palmas_pm_ops),\n\t\t.of_match_table = of_palmas_gpadc_match_tbl,\n\t},\n};\nmodule_platform_driver(palmas_gpadc_driver);\n\nMODULE_DESCRIPTION(\"palmas GPADC driver\");\nMODULE_AUTHOR(\"Pradeep Goudagunta<pgoudagunta@nvidia.com>\");\nMODULE_ALIAS(\"platform:palmas-gpadc\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}