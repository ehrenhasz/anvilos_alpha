{
  "module_name": "stm32-dfsdm-core.c",
  "hash_id": "c1bbc4ba72536fe64a827dae479399cbb6bbfb1950dcef578582fa93338e7c6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/stm32-dfsdm-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"stm32-dfsdm.h\"\n\n \nstruct stm32_dfsdm_dev_data {\n\tu32 ipid;\n\tunsigned int num_filters;\n\tunsigned int num_channels;\n\tconst struct regmap_config *regmap_cfg;\n};\n\n#define STM32H7_DFSDM_NUM_FILTERS\t4\n#define STM32H7_DFSDM_NUM_CHANNELS\t8\n\nstatic bool stm32_dfsdm_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg < DFSDM_FILTER_BASE_ADR)\n\t\treturn false;\n\n\t \n\tswitch (reg & DFSDM_FILTER_REG_MASK) {\n\tcase DFSDM_CR1(0) & DFSDM_FILTER_REG_MASK:\n\tcase DFSDM_ISR(0) & DFSDM_FILTER_REG_MASK:\n\tcase DFSDM_JDATAR(0) & DFSDM_FILTER_REG_MASK:\n\tcase DFSDM_RDATAR(0) & DFSDM_FILTER_REG_MASK:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config stm32h7_dfsdm_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = 0x2B8,\n\t.volatile_reg = stm32_dfsdm_volatile_reg,\n\t.fast_io = true,\n};\n\nstatic const struct stm32_dfsdm_dev_data stm32h7_dfsdm_data = {\n\t.num_filters = STM32H7_DFSDM_NUM_FILTERS,\n\t.num_channels = STM32H7_DFSDM_NUM_CHANNELS,\n\t.regmap_cfg = &stm32h7_dfsdm_regmap_cfg,\n};\n\nstatic const struct regmap_config stm32mp1_dfsdm_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = 0x7fc,\n\t.volatile_reg = stm32_dfsdm_volatile_reg,\n\t.fast_io = true,\n};\n\nstatic const struct stm32_dfsdm_dev_data stm32mp1_dfsdm_data = {\n\t.ipid = STM32MP15_IPIDR_NUMBER,\n\t.regmap_cfg = &stm32mp1_dfsdm_regmap_cfg,\n};\n\nstruct dfsdm_priv {\n\tstruct platform_device *pdev;  \n\n\tstruct stm32_dfsdm dfsdm;  \n\n\tunsigned int spi_clk_out_div;  \n\tatomic_t n_active_ch;\t \n\n\tstruct clk *clk;  \n\tstruct clk *aclk;  \n};\n\nstatic inline struct dfsdm_priv *to_stm32_dfsdm_priv(struct stm32_dfsdm *dfsdm)\n{\n\treturn container_of(dfsdm, struct dfsdm_priv, dfsdm);\n}\n\nstatic int stm32_dfsdm_clk_prepare_enable(struct stm32_dfsdm *dfsdm)\n{\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret || !priv->aclk)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->aclk);\n\tif (ret)\n\t\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_dfsdm_clk_disable_unprepare(struct stm32_dfsdm *dfsdm)\n{\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\n\tclk_disable_unprepare(priv->aclk);\n\tclk_disable_unprepare(priv->clk);\n}\n\n \nint stm32_dfsdm_start_dfsdm(struct stm32_dfsdm *dfsdm)\n{\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\tstruct device *dev = &priv->pdev->dev;\n\tunsigned int clk_div = priv->spi_clk_out_div, clk_src;\n\tint ret;\n\n\tif (atomic_inc_return(&priv->n_active_ch) == 1) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_ret;\n\n\t\t \n\t\tclk_src = priv->aclk ? 1 : 0;\n\t\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CHCFGR1(0),\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTSRC_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTSRC(clk_src));\n\t\tif (ret < 0)\n\t\t\tgoto pm_put;\n\n\t\t \n\t\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CHCFGR1(0),\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTDIV_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTDIV(clk_div));\n\t\tif (ret < 0)\n\t\t\tgoto pm_put;\n\n\t\t \n\t\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CHCFGR1(0),\n\t\t\t\t\t DFSDM_CHCFGR1_DFSDMEN_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_DFSDMEN(1));\n\t\tif (ret < 0)\n\t\t\tgoto pm_put;\n\t}\n\n\tdev_dbg(dev, \"%s: n_active_ch %d\\n\", __func__,\n\t\tatomic_read(&priv->n_active_ch));\n\n\treturn 0;\n\npm_put:\n\tpm_runtime_put_sync(dev);\nerror_ret:\n\tatomic_dec(&priv->n_active_ch);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stm32_dfsdm_start_dfsdm);\n\n \nint stm32_dfsdm_stop_dfsdm(struct stm32_dfsdm *dfsdm)\n{\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\tint ret;\n\n\tif (atomic_dec_and_test(&priv->n_active_ch)) {\n\t\t \n\t\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CHCFGR1(0),\n\t\t\t\t\t DFSDM_CHCFGR1_DFSDMEN_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_DFSDMEN(0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CHCFGR1(0),\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTDIV_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_CKOUTDIV(0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpm_runtime_put_sync(&priv->pdev->dev);\n\t}\n\tdev_dbg(&priv->pdev->dev, \"%s: n_active_ch %d\\n\", __func__,\n\t\tatomic_read(&priv->n_active_ch));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(stm32_dfsdm_stop_dfsdm);\n\nstatic int stm32_dfsdm_parse_of(struct platform_device *pdev,\n\t\t\t\tstruct dfsdm_priv *priv)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct resource *res;\n\tunsigned long clk_freq, divider;\n\tunsigned int spi_freq, rem;\n\tint ret;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tpriv->dfsdm.base = devm_platform_get_and_ioremap_resource(pdev, 0,\n\t\t\t\t\t\t\t&res);\n\tif (IS_ERR(priv->dfsdm.base))\n\t\treturn PTR_ERR(priv->dfsdm.base);\n\n\tpriv->dfsdm.phys_base = res->start;\n\n\t \n\tpriv->clk = devm_clk_get(&pdev->dev, \"dfsdm\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"Failed to get clock\\n\");\n\n\tpriv->aclk = devm_clk_get(&pdev->dev, \"audio\");\n\tif (IS_ERR(priv->aclk))\n\t\tpriv->aclk = NULL;\n\n\tif (priv->aclk)\n\t\tclk_freq = clk_get_rate(priv->aclk);\n\telse\n\t\tclk_freq = clk_get_rate(priv->clk);\n\n\t \n\tret = of_property_read_u32(pdev->dev.of_node, \"spi-max-frequency\",\n\t\t\t\t   &spi_freq);\n\tif (ret < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdivider = div_u64_rem(clk_freq, spi_freq, &rem);\n\t \n\tif (rem)\n\t\tdivider++;\n\n\t \n\tif (divider < 2 || divider > 256) {\n\t\tdev_err(&pdev->dev, \"spi-max-frequency not achievable\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->spi_clk_out_div = divider - 1;\n\tpriv->dfsdm.spi_master_freq = clk_freq / (priv->spi_clk_out_div + 1);\n\n\tif (rem) {\n\t\tdev_warn(&pdev->dev, \"SPI clock not accurate\\n\");\n\t\tdev_warn(&pdev->dev, \"%ld = %d * %d + %d\\n\",\n\t\t\t clk_freq, spi_freq, priv->spi_clk_out_div + 1, rem);\n\t}\n\n\treturn 0;\n};\n\nstatic const struct of_device_id stm32_dfsdm_of_match[] = {\n\t{\n\t\t.compatible = \"st,stm32h7-dfsdm\",\n\t\t.data = &stm32h7_dfsdm_data,\n\t},\n\t{\n\t\t.compatible = \"st,stm32mp1-dfsdm\",\n\t\t.data = &stm32mp1_dfsdm_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_dfsdm_of_match);\n\nstatic int stm32_dfsdm_probe_identification(struct platform_device *pdev,\n\t\t\t\t\t    struct dfsdm_priv *priv,\n\t\t\t\t\t    const struct stm32_dfsdm_dev_data *dev_data)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct stm32_dfsdm *dfsdm = &priv->dfsdm;\n\tconst char *compat;\n\tint ret, count = 0;\n\tu32 id, val;\n\n\tif (!dev_data->ipid) {\n\t\tdfsdm->num_fls = dev_data->num_filters;\n\t\tdfsdm->num_chs = dev_data->num_channels;\n\t\treturn 0;\n\t}\n\n\tret = regmap_read(dfsdm->regmap, DFSDM_IPIDR, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id != dev_data->ipid) {\n\t\tdev_err(&pdev->dev, \"Unexpected IP version: 0x%x\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = of_property_read_string(child, \"compatible\", &compat);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t \n\t\tif (strstr(compat, \"dfsdm\"))\n\t\t\tcount++;\n\t}\n\n\tret = regmap_read(dfsdm->regmap, DFSDM_HWCFGR, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdfsdm->num_fls = FIELD_GET(DFSDM_HWCFGR_NBF_MASK, val);\n\tdfsdm->num_chs = FIELD_GET(DFSDM_HWCFGR_NBT_MASK, val);\n\n\tif (count > dfsdm->num_fls) {\n\t\tdev_err(&pdev->dev, \"Unexpected child number: %d\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(dfsdm->regmap, DFSDM_VERR, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&pdev->dev, \"DFSDM version: %lu.%lu. %d channels/%d filters\\n\",\n\t\tFIELD_GET(DFSDM_VERR_MAJREV_MASK, val),\n\t\tFIELD_GET(DFSDM_VERR_MINREV_MASK, val),\n\t\tdfsdm->num_chs, dfsdm->num_fls);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_probe(struct platform_device *pdev)\n{\n\tstruct dfsdm_priv *priv;\n\tconst struct stm32_dfsdm_dev_data *dev_data;\n\tstruct stm32_dfsdm *dfsdm;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = pdev;\n\n\tdev_data = of_device_get_match_data(&pdev->dev);\n\n\tdfsdm = &priv->dfsdm;\n\n\tret = stm32_dfsdm_parse_of(pdev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdfsdm->regmap = devm_regmap_init_mmio_clk(&pdev->dev, \"dfsdm\",\n\t\t\t\t\t\t  dfsdm->base,\n\t\t\t\t\t\t  dev_data->regmap_cfg);\n\tif (IS_ERR(dfsdm->regmap)) {\n\t\tret = PTR_ERR(dfsdm->regmap);\n\t\tdev_err(&pdev->dev, \"%s: Failed to allocate regmap: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = stm32_dfsdm_probe_identification(pdev, priv, dev_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdfsdm->fl_list = devm_kcalloc(&pdev->dev, dfsdm->num_fls,\n\t\t\t\t      sizeof(*dfsdm->fl_list), GFP_KERNEL);\n\tif (!dfsdm->fl_list)\n\t\treturn -ENOMEM;\n\n\tdfsdm->ch_list = devm_kcalloc(&pdev->dev, dfsdm->num_chs,\n\t\t\t\t      sizeof(*dfsdm->ch_list), GFP_KERNEL);\n\tif (!dfsdm->ch_list)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dfsdm);\n\n\tret = stm32_dfsdm_clk_prepare_enable(dfsdm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to start clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\tif (ret)\n\t\tgoto pm_put;\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\npm_put:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tstm32_dfsdm_clk_disable_unprepare(dfsdm);\n\n\treturn ret;\n}\n\nstatic int stm32_dfsdm_core_remove(struct platform_device *pdev)\n{\n\tstruct stm32_dfsdm *dfsdm = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tof_platform_depopulate(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tstm32_dfsdm_clk_disable_unprepare(dfsdm);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_core_suspend(struct device *dev)\n{\n\tstruct stm32_dfsdm *dfsdm = dev_get_drvdata(dev);\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk_unprepare(priv->clk);\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int stm32_dfsdm_core_resume(struct device *dev)\n{\n\tstruct stm32_dfsdm *dfsdm = dev_get_drvdata(dev);\n\tstruct dfsdm_priv *priv = to_stm32_dfsdm_priv(dfsdm);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int stm32_dfsdm_core_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_dfsdm *dfsdm = dev_get_drvdata(dev);\n\n\tstm32_dfsdm_clk_disable_unprepare(dfsdm);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_core_runtime_resume(struct device *dev)\n{\n\tstruct stm32_dfsdm *dfsdm = dev_get_drvdata(dev);\n\n\treturn stm32_dfsdm_clk_prepare_enable(dfsdm);\n}\n\nstatic const struct dev_pm_ops stm32_dfsdm_core_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(stm32_dfsdm_core_suspend, stm32_dfsdm_core_resume)\n\tRUNTIME_PM_OPS(stm32_dfsdm_core_runtime_suspend,\n\t\t       stm32_dfsdm_core_runtime_resume,\n\t\t       NULL)\n};\n\nstatic struct platform_driver stm32_dfsdm_driver = {\n\t.probe = stm32_dfsdm_probe,\n\t.remove = stm32_dfsdm_core_remove,\n\t.driver = {\n\t\t.name = \"stm32-dfsdm\",\n\t\t.of_match_table = stm32_dfsdm_of_match,\n\t\t.pm = pm_ptr(&stm32_dfsdm_core_pm_ops),\n\t},\n};\n\nmodule_platform_driver(stm32_dfsdm_driver);\n\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 dfsdm driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}