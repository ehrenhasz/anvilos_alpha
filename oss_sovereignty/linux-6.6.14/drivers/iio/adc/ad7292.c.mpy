{
  "module_name": "ad7292.c",
  "hash_id": "aae86c924edb51b0c1bc9fb11089818f7fdb5d18d47cbc152300052293b1134b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7292.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n\n#define ADI_VENDOR_ID 0x0018\n\n \n#define AD7292_REG_VENDOR_ID\t\t0x00\n#define AD7292_REG_CONF_BANK\t\t0x05\n#define AD7292_REG_CONV_COMM\t\t0x0E\n#define AD7292_REG_ADC_CH(x)\t\t(0x10 + (x))\n\n \n#define AD7292_BANK_REG_VIN_RNG0\t0x10\n#define AD7292_BANK_REG_VIN_RNG1\t0x11\n#define AD7292_BANK_REG_SAMP_MODE\t0x12\n\n#define AD7292_RD_FLAG_MSK(x)\t\t(BIT(7) | ((x) & 0x3F))\n\n \n#define AD7292_ADC_DATA_MASK\t\tGENMASK(15, 6)\n#define AD7292_ADC_DATA(x)\t\tFIELD_GET(AD7292_ADC_DATA_MASK, x)\n\n \n#define AD7292_CH_SAMP_MODE(reg, ch)\t(((reg) >> 8) & BIT(ch))\n\n \n#define AD7292_CH_VIN_RANGE(reg, ch)\t((reg) & BIT(ch))\n\n#define AD7292_VOLTAGE_CHAN(_chan)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad7292_channels[] = {\n\tAD7292_VOLTAGE_CHAN(0),\n\tAD7292_VOLTAGE_CHAN(1),\n\tAD7292_VOLTAGE_CHAN(2),\n\tAD7292_VOLTAGE_CHAN(3),\n\tAD7292_VOLTAGE_CHAN(4),\n\tAD7292_VOLTAGE_CHAN(5),\n\tAD7292_VOLTAGE_CHAN(6),\n\tAD7292_VOLTAGE_CHAN(7)\n};\n\nstatic const struct iio_chan_spec ad7292_channels_diff[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.indexed = 1,\n\t\t.differential = 1,\n\t\t.channel = 0,\n\t\t.channel2 = 1,\n\t},\n\tAD7292_VOLTAGE_CHAN(2),\n\tAD7292_VOLTAGE_CHAN(3),\n\tAD7292_VOLTAGE_CHAN(4),\n\tAD7292_VOLTAGE_CHAN(5),\n\tAD7292_VOLTAGE_CHAN(6),\n\tAD7292_VOLTAGE_CHAN(7)\n};\n\nstruct ad7292_state {\n\tstruct spi_device *spi;\n\tstruct regulator *reg;\n\tunsigned short vref_mv;\n\n\t__be16 d16 __aligned(IIO_DMA_MINALIGN);\n\tu8 d8[2];\n};\n\nstatic int ad7292_spi_reg_read(struct ad7292_state *st, unsigned int addr)\n{\n\tint ret;\n\n\tst->d8[0] = AD7292_RD_FLAG_MSK(addr);\n\n\tret = spi_write_then_read(st->spi, st->d8, 1, &st->d16, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->d16);\n}\n\nstatic int ad7292_spi_subreg_read(struct ad7292_state *st, unsigned int addr,\n\t\t\t\t  unsigned int sub_addr, unsigned int len)\n{\n\tunsigned int shift = 16 - (8 * len);\n\tint ret;\n\n\tst->d8[0] = AD7292_RD_FLAG_MSK(addr);\n\tst->d8[1] = sub_addr;\n\n\tret = spi_write_then_read(st->spi, st->d8, 2, &st->d16, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (be16_to_cpu(st->d16) >> shift);\n}\n\nstatic int ad7292_single_conversion(struct ad7292_state *st,\n\t\t\t\t    unsigned int chan_addr)\n{\n\tint ret;\n\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->d8,\n\t\t\t.len = 4,\n\t\t\t.delay = {\n\t\t\t\t.value = 6,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t}, {\n\t\t\t.rx_buf = &st->d16,\n\t\t\t.len = 2,\n\t\t},\n\t};\n\n\tst->d8[0] = chan_addr;\n\tst->d8[1] = AD7292_RD_FLAG_MSK(AD7292_REG_CONV_COMM);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->d16);\n}\n\nstatic int ad7292_vin_range_multiplier(struct ad7292_state *st, int channel)\n{\n\tint samp_mode, range0, range1, factor = 1;\n\n\t \n\n\tsamp_mode = ad7292_spi_subreg_read(st, AD7292_REG_CONF_BANK,\n\t\t\t\t\t   AD7292_BANK_REG_SAMP_MODE, 2);\n\n\tif (samp_mode < 0)\n\t\treturn samp_mode;\n\n\trange0 = ad7292_spi_subreg_read(st, AD7292_REG_CONF_BANK,\n\t\t\t\t\tAD7292_BANK_REG_VIN_RNG0, 2);\n\n\tif (range0 < 0)\n\t\treturn range0;\n\n\trange1 = ad7292_spi_subreg_read(st, AD7292_REG_CONF_BANK,\n\t\t\t\t\tAD7292_BANK_REG_VIN_RNG1, 2);\n\n\tif (range1 < 0)\n\t\treturn range1;\n\n\tif (AD7292_CH_SAMP_MODE(samp_mode, channel)) {\n\t\t \n\t\tif (!AD7292_CH_VIN_RANGE(range0, channel))\n\t\t\tfactor *= 2;\n\n\t\tif (!AD7292_CH_VIN_RANGE(range1, channel))\n\t\t\tfactor *= 2;\n\n\t} else {\n\t\t \n\t\tif (AD7292_CH_VIN_RANGE(range0, channel) ||\n\t\t    AD7292_CH_VIN_RANGE(range1, channel))\n\t\t\treturn -EPERM;\n\n\t\tfactor = 4;\n\t}\n\n\treturn factor;\n}\n\nstatic int ad7292_read_raw(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad7292_state *st = iio_priv(indio_dev);\n\tunsigned int ch_addr;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tch_addr = AD7292_REG_ADC_CH(chan->channel);\n\t\tret = ad7292_single_conversion(st, ch_addr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = AD7292_ADC_DATA(ret);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\n\t\tret = ad7292_vin_range_multiplier(st, chan->channel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = st->vref_mv * ret;\n\t\t*val2 = 10;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad7292_info = {\n\t.read_raw = ad7292_read_raw,\n};\n\nstatic void ad7292_regulator_disable(void *data)\n{\n\tstruct ad7292_state *st = data;\n\n\tregulator_disable(st->reg);\n}\n\nstatic int ad7292_probe(struct spi_device *spi)\n{\n\tstruct ad7292_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct device_node *child;\n\tbool diff_channels = false;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\n\tret = ad7292_spi_reg_read(st, AD7292_REG_VENDOR_ID);\n\tif (ret != ADI_VENDOR_ID) {\n\t\tdev_err(&spi->dev, \"Wrong vendor id 0x%x\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->reg)) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed to enable external vref supply\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&spi->dev,\n\t\t\t\t\t       ad7292_regulator_disable, st);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->vref_mv = ret / 1000;\n\t} else {\n\t\t \n\t\tst->vref_mv = 1250;\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad7292_info;\n\n\tfor_each_available_child_of_node(spi->dev.of_node, child) {\n\t\tdiff_channels = of_property_read_bool(child, \"diff-channels\");\n\t\tif (diff_channels) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (diff_channels) {\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad7292_channels_diff);\n\t\tindio_dev->channels = ad7292_channels_diff;\n\t} else {\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad7292_channels);\n\t\tindio_dev->channels = ad7292_channels;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7292_id_table[] = {\n\t{ \"ad7292\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7292_id_table);\n\nstatic const struct of_device_id ad7292_of_match[] = {\n\t{ .compatible = \"adi,ad7292\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7292_of_match);\n\nstatic struct spi_driver ad7292_driver = {\n\t.driver = {\n\t\t.name = \"ad7292\",\n\t\t.of_match_table = ad7292_of_match,\n\t},\n\t.probe = ad7292_probe,\n\t.id_table = ad7292_id_table,\n};\nmodule_spi_driver(ad7292_driver);\n\nMODULE_AUTHOR(\"Marcelo Schmitt <marcelo.schmitt1@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7292 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}