{
  "module_name": "lpc18xx_adc.c",
  "hash_id": "000c576caa36f05e32c9279c39a970954ba05463d060b7234dd8c1abce521be6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/lpc18xx_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n \n#define LPC18XX_ADC_CR\t\t\t0x000\n#define  LPC18XX_ADC_CR_CLKDIV_SHIFT\t8\n#define  LPC18XX_ADC_CR_PDN\t\tBIT(21)\n#define  LPC18XX_ADC_CR_START_NOW\t(0x1 << 24)\n#define LPC18XX_ADC_GDR\t\t\t0x004\n\n \n#define LPC18XX_ADC_SAMPLE_SHIFT\t6\n#define LPC18XX_ADC_SAMPLE_MASK\t\t0x3ff\n#define LPC18XX_ADC_CONV_DONE\t\tBIT(31)\n\n \n#define LPC18XX_ADC_CLK_TARGET\t\t4500000\n\nstruct lpc18xx_adc {\n\tstruct regulator *vref;\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct mutex lock;\n\tstruct clk *clk;\n\tu32 cr_reg;\n};\n\n#define LPC18XX_ADC_CHAN(_idx) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _idx,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstatic const struct iio_chan_spec lpc18xx_adc_iio_channels[] = {\n\tLPC18XX_ADC_CHAN(0),\n\tLPC18XX_ADC_CHAN(1),\n\tLPC18XX_ADC_CHAN(2),\n\tLPC18XX_ADC_CHAN(3),\n\tLPC18XX_ADC_CHAN(4),\n\tLPC18XX_ADC_CHAN(5),\n\tLPC18XX_ADC_CHAN(6),\n\tLPC18XX_ADC_CHAN(7),\n};\n\nstatic int lpc18xx_adc_read_chan(struct lpc18xx_adc *adc, unsigned int ch)\n{\n\tint ret;\n\tu32 reg;\n\n\treg = adc->cr_reg | BIT(ch) | LPC18XX_ADC_CR_START_NOW;\n\twritel(reg, adc->base + LPC18XX_ADC_CR);\n\n\tret = readl_poll_timeout(adc->base + LPC18XX_ADC_GDR, reg,\n\t\t\t\t reg & LPC18XX_ADC_CONV_DONE, 3, 9);\n\tif (ret) {\n\t\tdev_warn(adc->dev, \"adc read timed out\\n\");\n\t\treturn ret;\n\t}\n\n\treturn (reg >> LPC18XX_ADC_SAMPLE_SHIFT) & LPC18XX_ADC_SAMPLE_MASK;\n}\n\nstatic int lpc18xx_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct lpc18xx_adc *adc = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\t*val = lpc18xx_adc_read_chan(adc, chan->channel);\n\t\tmutex_unlock(&adc->lock);\n\t\tif (*val < 0)\n\t\t\treturn *val;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = regulator_get_voltage(adc->vref) / 1000;\n\t\t*val2 = 10;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info lpc18xx_adc_info = {\n\t.read_raw = lpc18xx_adc_read_raw,\n};\n\nstatic void lpc18xx_clear_cr_reg(void *data)\n{\n\tstruct lpc18xx_adc *adc = data;\n\n\twritel(0, adc->base + LPC18XX_ADC_CR);\n}\n\nstatic void lpc18xx_regulator_disable(void *vref)\n{\n\tregulator_disable(vref);\n}\n\nstatic int lpc18xx_adc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct lpc18xx_adc *adc;\n\tunsigned int clkdiv;\n\tunsigned long rate;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->dev = &pdev->dev;\n\tmutex_init(&adc->lock);\n\n\tadc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc->base))\n\t\treturn PTR_ERR(adc->base);\n\n\tadc->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(adc->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(adc->clk),\n\t\t\t\t     \"error getting clock\\n\");\n\n\tadc->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(adc->vref))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(adc->vref),\n\t\t\t\t     \"error getting regulator\\n\");\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &lpc18xx_adc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = lpc18xx_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lpc18xx_adc_iio_channels);\n\n\tret = regulator_enable(adc->vref);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, lpc18xx_regulator_disable, adc->vref);\n\tif (ret)\n\t\treturn ret;\n\n\trate = clk_get_rate(adc->clk);\n\tclkdiv = DIV_ROUND_UP(rate, LPC18XX_ADC_CLK_TARGET);\n\n\tadc->cr_reg = (clkdiv << LPC18XX_ADC_CR_CLKDIV_SHIFT) |\n\t\t\tLPC18XX_ADC_CR_PDN;\n\twritel(adc->cr_reg, adc->base + LPC18XX_ADC_CR);\n\n\tret = devm_add_action_or_reset(&pdev->dev, lpc18xx_clear_cr_reg, adc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic const struct of_device_id lpc18xx_adc_match[] = {\n\t{ .compatible = \"nxp,lpc1850-adc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, lpc18xx_adc_match);\n\nstatic struct platform_driver lpc18xx_adc_driver = {\n\t.probe\t= lpc18xx_adc_probe,\n\t.driver\t= {\n\t\t.name = \"lpc18xx-adc\",\n\t\t.of_match_table = lpc18xx_adc_match,\n\t},\n};\nmodule_platform_driver(lpc18xx_adc_driver);\n\nMODULE_DESCRIPTION(\"LPC18xx ADC driver\");\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}