{
  "module_name": "ad7791.c",
  "hash_id": "e2bf0bb460c71dd3b3eb0525948609dced881d6769604ce5460db3eb8e2152c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7791.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n\n#include <linux/platform_data/ad7791.h>\n\n#define AD7791_REG_COMM\t\t\t0x0  \n#define AD7791_REG_STATUS\t\t0x0  \n#define AD7791_REG_MODE\t\t\t0x1\n#define AD7791_REG_FILTER\t\t0x2\n#define AD7791_REG_DATA\t\t\t0x3\n\n#define AD7791_MODE_CONTINUOUS\t\t0x00\n#define AD7791_MODE_SINGLE\t\t0x02\n#define AD7791_MODE_POWERDOWN\t\t0x03\n\n#define AD7791_CH_AIN1P_AIN1N\t\t0x00\n#define AD7791_CH_AIN2\t\t\t0x01\n#define AD7791_CH_AIN1N_AIN1N\t\t0x02\n#define AD7791_CH_AVDD_MONITOR\t\t0x03\n\n#define AD7791_FILTER_CLK_DIV_1\t\t(0x0 << 4)\n#define AD7791_FILTER_CLK_DIV_2\t\t(0x1 << 4)\n#define AD7791_FILTER_CLK_DIV_4\t\t(0x2 << 4)\n#define AD7791_FILTER_CLK_DIV_8\t\t(0x3 << 4)\n#define AD7791_FILTER_CLK_MASK\t\t(0x3 << 4)\n#define AD7791_FILTER_RATE_120\t\t0x0\n#define AD7791_FILTER_RATE_100\t\t0x1\n#define AD7791_FILTER_RATE_33_3\t\t0x2\n#define AD7791_FILTER_RATE_20\t\t0x3\n#define AD7791_FILTER_RATE_16_6\t\t0x4\n#define AD7791_FILTER_RATE_16_7\t\t0x5\n#define AD7791_FILTER_RATE_13_3\t\t0x6\n#define AD7791_FILTER_RATE_9_5\t\t0x7\n#define AD7791_FILTER_RATE_MASK\t\t0x7\n\n#define AD7791_MODE_BUFFER\t\tBIT(1)\n#define AD7791_MODE_UNIPOLAR\t\tBIT(2)\n#define AD7791_MODE_BURNOUT\t\tBIT(3)\n#define AD7791_MODE_SEL_MASK\t\t(0x3 << 6)\n#define AD7791_MODE_SEL(x)\t\t((x) << 6)\n\n#define __AD7991_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t_storagebits, _shift, _extend_name, _type, _mask_all) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.differential = (_channel2 == -1 ? 0 : 1), \\\n\t\t.indexed = 1, \\\n\t\t.channel = (_channel1), \\\n\t\t.channel2 = (_channel2), \\\n\t\t.address = (_address), \\\n\t\t.extend_name = (_extend_name), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = _mask_all, \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 'u', \\\n\t\t\t.realbits = (_bits), \\\n\t\t\t.storagebits = (_storagebits), \\\n\t\t\t.shift = (_shift), \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define AD7991_SHORTED_CHANNEL(_si, _channel, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7991_CHANNEL(_si, _channel, _channel, _address, _bits, \\\n\t\t_storagebits, _shift, \"shorted\", IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7991_CHANNEL(_si, _channel, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7991_CHANNEL(_si, _channel, -1, _address, _bits, \\\n\t\t_storagebits, _shift, NULL, IIO_VOLTAGE, \\\n\t\t BIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7991_DIFF_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7991_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t\t_storagebits, _shift, NULL, IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7991_SUPPLY_CHANNEL(_si, _channel, _address, _bits, _storagebits, \\\n\t_shift) \\\n\t__AD7991_CHANNEL(_si, _channel, -1, _address, _bits, \\\n\t\t_storagebits, _shift, \"supply\", IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define DECLARE_AD7787_CHANNELS(name, bits, storagebits) \\\nconst struct iio_chan_spec name[] = { \\\n\tAD7991_DIFF_CHANNEL(0, 0, 0, AD7791_CH_AIN1P_AIN1N, \\\n\t\t(bits), (storagebits), 0), \\\n\tAD7991_CHANNEL(1, 1, AD7791_CH_AIN2, (bits), (storagebits), 0), \\\n\tAD7991_SHORTED_CHANNEL(2, 0, AD7791_CH_AIN1N_AIN1N, \\\n\t\t(bits), (storagebits), 0), \\\n\tAD7991_SUPPLY_CHANNEL(3, 2, AD7791_CH_AVDD_MONITOR,  \\\n\t\t(bits), (storagebits), 0), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(4), \\\n}\n\n#define DECLARE_AD7791_CHANNELS(name, bits, storagebits) \\\nconst struct iio_chan_spec name[] = { \\\n\tAD7991_DIFF_CHANNEL(0, 0, 0, AD7791_CH_AIN1P_AIN1N, \\\n\t\t(bits), (storagebits), 0), \\\n\tAD7991_SHORTED_CHANNEL(1, 0, AD7791_CH_AIN1N_AIN1N, \\\n\t\t(bits), (storagebits), 0), \\\n\tAD7991_SUPPLY_CHANNEL(2, 1, AD7791_CH_AVDD_MONITOR, \\\n\t\t(bits), (storagebits), 0), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(3), \\\n}\n\nstatic DECLARE_AD7787_CHANNELS(ad7787_channels, 24, 32);\nstatic DECLARE_AD7791_CHANNELS(ad7790_channels, 16, 16);\nstatic DECLARE_AD7791_CHANNELS(ad7791_channels, 24, 32);\n\nenum {\n\tAD7787,\n\tAD7788,\n\tAD7789,\n\tAD7790,\n\tAD7791,\n};\n\nenum ad7791_chip_info_flags {\n\tAD7791_FLAG_HAS_FILTER\t\t= (1 << 0),\n\tAD7791_FLAG_HAS_BUFFER\t\t= (1 << 1),\n\tAD7791_FLAG_HAS_UNIPOLAR\t= (1 << 2),\n\tAD7791_FLAG_HAS_BURNOUT\t\t= (1 << 3),\n};\n\nstruct ad7791_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tenum ad7791_chip_info_flags flags;\n};\n\nstatic const struct ad7791_chip_info ad7791_chip_infos[] = {\n\t[AD7787] = {\n\t\t.channels = ad7787_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7787_channels),\n\t\t.flags = AD7791_FLAG_HAS_FILTER | AD7791_FLAG_HAS_BUFFER |\n\t\t\tAD7791_FLAG_HAS_UNIPOLAR | AD7791_FLAG_HAS_BURNOUT,\n\t},\n\t[AD7788] = {\n\t\t.channels = ad7790_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7790_channels),\n\t\t.flags = AD7791_FLAG_HAS_UNIPOLAR,\n\t},\n\t[AD7789] = {\n\t\t.channels = ad7791_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7791_channels),\n\t\t.flags = AD7791_FLAG_HAS_UNIPOLAR,\n\t},\n\t[AD7790] = {\n\t\t.channels = ad7790_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7790_channels),\n\t\t.flags = AD7791_FLAG_HAS_FILTER | AD7791_FLAG_HAS_BUFFER |\n\t\t\tAD7791_FLAG_HAS_BURNOUT,\n\t},\n\t[AD7791] = {\n\t\t.channels = ad7791_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7791_channels),\n\t\t.flags = AD7791_FLAG_HAS_FILTER | AD7791_FLAG_HAS_BUFFER |\n\t\t\tAD7791_FLAG_HAS_UNIPOLAR | AD7791_FLAG_HAS_BURNOUT,\n\t},\n};\n\nstruct ad7791_state {\n\tstruct ad_sigma_delta sd;\n\tuint8_t mode;\n\tuint8_t filter;\n\n\tstruct regulator *reg;\n\tconst struct ad7791_chip_info *info;\n};\n\nstatic const int ad7791_sample_freq_avail[8][2] = {\n\t[AD7791_FILTER_RATE_120] =  { 120, 0 },\n\t[AD7791_FILTER_RATE_100] =  { 100, 0 },\n\t[AD7791_FILTER_RATE_33_3] = { 33,  300000 },\n\t[AD7791_FILTER_RATE_20] =   { 20,  0 },\n\t[AD7791_FILTER_RATE_16_6] = { 16,  600000 },\n\t[AD7791_FILTER_RATE_16_7] = { 16,  700000 },\n\t[AD7791_FILTER_RATE_13_3] = { 13,  300000 },\n\t[AD7791_FILTER_RATE_9_5] =  { 9,   500000 },\n};\n\nstatic struct ad7791_state *ad_sigma_delta_to_ad7791(struct ad_sigma_delta *sd)\n{\n\treturn container_of(sd, struct ad7791_state, sd);\n}\n\nstatic int ad7791_set_channel(struct ad_sigma_delta *sd, unsigned int channel)\n{\n\tad_sd_set_comm(sd, channel);\n\n\treturn 0;\n}\n\nstatic int ad7791_set_mode(struct ad_sigma_delta *sd,\n\tenum ad_sigma_delta_mode mode)\n{\n\tstruct ad7791_state *st = ad_sigma_delta_to_ad7791(sd);\n\n\tswitch (mode) {\n\tcase AD_SD_MODE_CONTINUOUS:\n\t\tmode = AD7791_MODE_CONTINUOUS;\n\t\tbreak;\n\tcase AD_SD_MODE_SINGLE:\n\t\tmode = AD7791_MODE_SINGLE;\n\t\tbreak;\n\tcase AD_SD_MODE_IDLE:\n\tcase AD_SD_MODE_POWERDOWN:\n\t\tmode = AD7791_MODE_POWERDOWN;\n\t\tbreak;\n\t}\n\n\tst->mode &= ~AD7791_MODE_SEL_MASK;\n\tst->mode |= AD7791_MODE_SEL(mode);\n\n\treturn ad_sd_write_reg(sd, AD7791_REG_MODE, sizeof(st->mode), st->mode);\n}\n\nstatic const struct ad_sigma_delta_info ad7791_sigma_delta_info = {\n\t.set_channel = ad7791_set_channel,\n\t.set_mode = ad7791_set_mode,\n\t.has_registers = true,\n\t.addr_shift = 4,\n\t.read_mask = BIT(3),\n\t.irq_flags = IRQF_TRIGGER_FALLING,\n};\n\nstatic int ad7791_read_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val, int *val2, long info)\n{\n\tstruct ad7791_state *st = iio_priv(indio_dev);\n\tbool unipolar = !!(st->mode & AD7791_MODE_UNIPOLAR);\n\tunsigned int rate;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\tif (unipolar)\n\t\t\t*val = 0;\n\t\telse\n\t\t\t*val = -(1 << (chan->scan_type.realbits - 1));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tif (chan->address == AD7791_CH_AVDD_MONITOR) {\n\t\t\t \n\t\t\t*val = 1170 * 5;\n\t\t} else {\n\t\t\tint voltage_uv;\n\n\t\t\tvoltage_uv = regulator_get_voltage(st->reg);\n\t\t\tif (voltage_uv < 0)\n\t\t\t\treturn voltage_uv;\n\n\t\t\t*val = voltage_uv / 1000;\n\t\t}\n\t\tif (unipolar)\n\t\t\t*val2 = chan->scan_type.realbits;\n\t\telse\n\t\t\t*val2 = chan->scan_type.realbits - 1;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trate = st->filter & AD7791_FILTER_RATE_MASK;\n\t\t*val = ad7791_sample_freq_avail[rate][0];\n\t\t*val2 = ad7791_sample_freq_avail[rate][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad7791_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tstruct ad7791_state *st = iio_priv(indio_dev);\n\tint ret, i;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfor (i = 0; i < ARRAY_SIZE(ad7791_sample_freq_avail); i++) {\n\t\t\tif (ad7791_sample_freq_avail[i][0] == val &&\n\t\t\t    ad7791_sample_freq_avail[i][1] == val2)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ad7791_sample_freq_avail)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tst->filter &= ~AD7791_FILTER_RATE_MASK;\n\t\tst->filter |= i;\n\t\tad_sd_write_reg(&st->sd, AD7791_REG_FILTER,\n\t\t\t\tsizeof(st->filter),\n\t\t\t\tst->filter);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"120 100 33.3 20 16.7 16.6 13.3 9.5\");\n\nstatic struct attribute *ad7791_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7791_attribute_group = {\n\t.attrs = ad7791_attributes,\n};\n\nstatic const struct iio_info ad7791_info = {\n\t.read_raw = &ad7791_read_raw,\n\t.write_raw = &ad7791_write_raw,\n\t.attrs = &ad7791_attribute_group,\n\t.validate_trigger = ad_sd_validate_trigger,\n};\n\nstatic const struct iio_info ad7791_no_filter_info = {\n\t.read_raw = &ad7791_read_raw,\n\t.write_raw = &ad7791_write_raw,\n\t.validate_trigger = ad_sd_validate_trigger,\n};\n\nstatic int ad7791_setup(struct ad7791_state *st,\n\t\t\tstruct ad7791_platform_data *pdata)\n{\n\t \n\tst->mode = AD7791_MODE_BUFFER;\n\tst->filter = AD7791_FILTER_RATE_16_6;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tif ((st->info->flags & AD7791_FLAG_HAS_BUFFER) && !pdata->buffered)\n\t\tst->mode &= ~AD7791_MODE_BUFFER;\n\n\tif ((st->info->flags & AD7791_FLAG_HAS_BURNOUT) &&\n\t\tpdata->burnout_current)\n\t\tst->mode |= AD7791_MODE_BURNOUT;\n\n\tif ((st->info->flags & AD7791_FLAG_HAS_UNIPOLAR) && pdata->unipolar)\n\t\tst->mode |= AD7791_MODE_UNIPOLAR;\n\n\treturn ad_sd_write_reg(&st->sd, AD7791_REG_MODE, sizeof(st->mode),\n\t\tst->mode);\n}\n\nstatic void ad7791_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7791_probe(struct spi_device *spi)\n{\n\tstruct ad7791_platform_data *pdata = spi->dev.platform_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad7791_state *st;\n\tint ret;\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"Missing IRQ.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get(&spi->dev, \"refin\");\n\tif (IS_ERR(st->reg))\n\t\treturn PTR_ERR(st->reg);\n\n\tret = regulator_enable(st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7791_reg_disable, st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->info = &ad7791_chip_infos[spi_get_device_id(spi)->driver_data];\n\tad_sd_init(&st->sd, indio_dev, spi, &ad7791_sigma_delta_info);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->info->channels;\n\tindio_dev->num_channels = st->info->num_channels;\n\tif (st->info->flags & AD7791_FLAG_HAS_FILTER)\n\t\tindio_dev->info = &ad7791_info;\n\telse\n\t\tindio_dev->info = &ad7791_no_filter_info;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7791_setup(st, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7791_spi_ids[] = {\n\t{ \"ad7787\", AD7787 },\n\t{ \"ad7788\", AD7788 },\n\t{ \"ad7789\", AD7789 },\n\t{ \"ad7790\", AD7790 },\n\t{ \"ad7791\", AD7791 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7791_spi_ids);\n\nstatic struct spi_driver ad7791_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7791\",\n\t},\n\t.probe\t\t= ad7791_probe,\n\t.id_table\t= ad7791_spi_ids,\n};\nmodule_spi_driver(ad7791_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7787/AD7788/AD7789/AD7790/AD7791 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}