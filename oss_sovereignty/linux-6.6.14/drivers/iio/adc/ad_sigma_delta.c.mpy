{
  "module_name": "ad_sigma_delta.c",
  "hash_id": "fc5a3c26494d49a3ac16261a6e5b78c6522b6fec98fc12fc66ff8a27017ed6c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad_sigma_delta.c",
  "human_readable_source": "\n \n\n#include <linux/align.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/err.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n\n#include <asm/unaligned.h>\n\n\n#define AD_SD_COMM_CHAN_MASK\t0x3\n\n#define AD_SD_REG_COMM\t\t0x00\n#define AD_SD_REG_DATA\t\t0x03\n\n \nvoid ad_sd_set_comm(struct ad_sigma_delta *sigma_delta, uint8_t comm)\n{\n\t \n\tsigma_delta->comm = comm & AD_SD_COMM_CHAN_MASK;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_set_comm, IIO_AD_SIGMA_DELTA);\n\n \nint ad_sd_write_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,\n\tunsigned int size, unsigned int val)\n{\n\tuint8_t *data = sigma_delta->tx_buf;\n\tstruct spi_transfer t = {\n\t\t.tx_buf\t\t= data,\n\t\t.len\t\t= size + 1,\n\t\t.cs_change\t= sigma_delta->keep_cs_asserted,\n\t};\n\tstruct spi_message m;\n\tint ret;\n\n\tdata[0] = (reg << sigma_delta->info->addr_shift) | sigma_delta->comm;\n\n\tswitch (size) {\n\tcase 3:\n\t\tput_unaligned_be24(val, &data[1]);\n\t\tbreak;\n\tcase 2:\n\t\tput_unaligned_be16(val, &data[1]);\n\t\tbreak;\n\tcase 1:\n\t\tdata[1] = val;\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\tif (sigma_delta->bus_locked)\n\t\tret = spi_sync_locked(sigma_delta->spi, &m);\n\telse\n\t\tret = spi_sync(sigma_delta->spi, &m);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_write_reg, IIO_AD_SIGMA_DELTA);\n\nstatic int ad_sd_read_reg_raw(struct ad_sigma_delta *sigma_delta,\n\tunsigned int reg, unsigned int size, uint8_t *val)\n{\n\tuint8_t *data = sigma_delta->tx_buf;\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = data,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.rx_buf = val,\n\t\t\t.len = size,\n\t\t\t.cs_change = sigma_delta->bus_locked,\n\t\t},\n\t};\n\tstruct spi_message m;\n\n\tspi_message_init(&m);\n\n\tif (sigma_delta->info->has_registers) {\n\t\tdata[0] = reg << sigma_delta->info->addr_shift;\n\t\tdata[0] |= sigma_delta->info->read_mask;\n\t\tdata[0] |= sigma_delta->comm;\n\t\tspi_message_add_tail(&t[0], &m);\n\t}\n\tspi_message_add_tail(&t[1], &m);\n\n\tif (sigma_delta->bus_locked)\n\t\tret = spi_sync_locked(sigma_delta->spi, &m);\n\telse\n\t\tret = spi_sync(sigma_delta->spi, &m);\n\n\treturn ret;\n}\n\n \nint ad_sd_read_reg(struct ad_sigma_delta *sigma_delta,\n\tunsigned int reg, unsigned int size, unsigned int *val)\n{\n\tint ret;\n\n\tret = ad_sd_read_reg_raw(sigma_delta, reg, size, sigma_delta->rx_buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (size) {\n\tcase 4:\n\t\t*val = get_unaligned_be32(sigma_delta->rx_buf);\n\t\tbreak;\n\tcase 3:\n\t\t*val = get_unaligned_be24(sigma_delta->rx_buf);\n\t\tbreak;\n\tcase 2:\n\t\t*val = get_unaligned_be16(sigma_delta->rx_buf);\n\t\tbreak;\n\tcase 1:\n\t\t*val = sigma_delta->rx_buf[0];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_read_reg, IIO_AD_SIGMA_DELTA);\n\n \nint ad_sd_reset(struct ad_sigma_delta *sigma_delta,\n\tunsigned int reset_length)\n{\n\tuint8_t *buf;\n\tunsigned int size;\n\tint ret;\n\n\tsize = DIV_ROUND_UP(reset_length, 8);\n\tbuf = kcalloc(size, sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemset(buf, 0xff, size);\n\tret = spi_write(sigma_delta->spi, buf, size);\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_reset, IIO_AD_SIGMA_DELTA);\n\nint ad_sd_calibrate(struct ad_sigma_delta *sigma_delta,\n\tunsigned int mode, unsigned int channel)\n{\n\tint ret;\n\tunsigned long timeout;\n\n\tret = ad_sigma_delta_set_channel(sigma_delta, channel);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_bus_lock(sigma_delta->spi->master);\n\tsigma_delta->bus_locked = true;\n\tsigma_delta->keep_cs_asserted = true;\n\treinit_completion(&sigma_delta->completion);\n\n\tret = ad_sigma_delta_set_mode(sigma_delta, mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsigma_delta->irq_dis = false;\n\tenable_irq(sigma_delta->spi->irq);\n\ttimeout = wait_for_completion_timeout(&sigma_delta->completion, 2 * HZ);\n\tif (timeout == 0) {\n\t\tsigma_delta->irq_dis = true;\n\t\tdisable_irq_nosync(sigma_delta->spi->irq);\n\t\tret = -EIO;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\tsigma_delta->keep_cs_asserted = false;\n\tad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\n\tsigma_delta->bus_locked = false;\n\tspi_bus_unlock(sigma_delta->spi->master);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_calibrate, IIO_AD_SIGMA_DELTA);\n\n \nint ad_sd_calibrate_all(struct ad_sigma_delta *sigma_delta,\n\tconst struct ad_sd_calib_data *cb, unsigned int n)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < n; i++) {\n\t\tret = ad_sd_calibrate(sigma_delta, cb[i].mode, cb[i].channel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_calibrate_all, IIO_AD_SIGMA_DELTA);\n\n \nint ad_sigma_delta_single_conversion(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\tunsigned int sample, raw_sample;\n\tunsigned int data_reg;\n\tint ret = 0;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tad_sigma_delta_set_channel(sigma_delta, chan->address);\n\n\tspi_bus_lock(sigma_delta->spi->master);\n\tsigma_delta->bus_locked = true;\n\tsigma_delta->keep_cs_asserted = true;\n\treinit_completion(&sigma_delta->completion);\n\n\tad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_SINGLE);\n\n\tsigma_delta->irq_dis = false;\n\tenable_irq(sigma_delta->spi->irq);\n\tret = wait_for_completion_interruptible_timeout(\n\t\t\t&sigma_delta->completion, HZ);\n\n\tif (ret == 0)\n\t\tret = -EIO;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sigma_delta->info->data_reg != 0)\n\t\tdata_reg = sigma_delta->info->data_reg;\n\telse\n\t\tdata_reg = AD_SD_REG_DATA;\n\n\tret = ad_sd_read_reg(sigma_delta, data_reg,\n\t\tDIV_ROUND_UP(chan->scan_type.realbits + chan->scan_type.shift, 8),\n\t\t&raw_sample);\n\nout:\n\tif (!sigma_delta->irq_dis) {\n\t\tdisable_irq_nosync(sigma_delta->spi->irq);\n\t\tsigma_delta->irq_dis = true;\n\t}\n\n\tsigma_delta->keep_cs_asserted = false;\n\tad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\n\tsigma_delta->bus_locked = false;\n\tspi_bus_unlock(sigma_delta->spi->master);\n\tiio_device_release_direct_mode(indio_dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tsample = raw_sample >> chan->scan_type.shift;\n\tsample &= (1 << chan->scan_type.realbits) - 1;\n\t*val = sample;\n\n\tret = ad_sigma_delta_postprocess_sample(sigma_delta, raw_sample);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sigma_delta_single_conversion, IIO_AD_SIGMA_DELTA);\n\nstatic int ad_sd_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\tunsigned int i, slot, samples_buf_size;\n\tunsigned int channel;\n\tuint8_t *samples_buf;\n\tint ret;\n\n\tif (sigma_delta->num_slots == 1) {\n\t\tchannel = find_first_bit(indio_dev->active_scan_mask,\n\t\t\t\t\t indio_dev->masklength);\n\t\tret = ad_sigma_delta_set_channel(sigma_delta,\n\t\t\t\t\t\t indio_dev->channels[channel].address);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tslot = 1;\n\t} else {\n\t\t \n\t\tslot = 0;\n\t\tfor_each_set_bit(i, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\t\tsigma_delta->slots[slot] = indio_dev->channels[i].address;\n\t\t\tslot++;\n\t\t}\n\t}\n\n\tsigma_delta->active_slots = slot;\n\tsigma_delta->current_slot = 0;\n\n\tif (sigma_delta->active_slots > 1) {\n\t\tret = ad_sigma_delta_append_status(sigma_delta, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsamples_buf_size = ALIGN(slot * indio_dev->channels[0].scan_type.storagebits, 8);\n\tsamples_buf_size += sizeof(int64_t);\n\tsamples_buf = devm_krealloc(&sigma_delta->spi->dev, sigma_delta->samples_buf,\n\t\t\t\t    samples_buf_size, GFP_KERNEL);\n\tif (!samples_buf)\n\t\treturn -ENOMEM;\n\n\tsigma_delta->samples_buf = samples_buf;\n\n\tspi_bus_lock(sigma_delta->spi->master);\n\tsigma_delta->bus_locked = true;\n\tsigma_delta->keep_cs_asserted = true;\n\n\tret = ad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_CONTINUOUS);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tsigma_delta->irq_dis = false;\n\tenable_irq(sigma_delta->spi->irq);\n\n\treturn 0;\n\nerr_unlock:\n\tspi_bus_unlock(sigma_delta->spi->master);\n\n\treturn ret;\n}\n\nstatic int ad_sd_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\n\treinit_completion(&sigma_delta->completion);\n\twait_for_completion_timeout(&sigma_delta->completion, HZ);\n\n\tif (!sigma_delta->irq_dis) {\n\t\tdisable_irq_nosync(sigma_delta->spi->irq);\n\t\tsigma_delta->irq_dis = true;\n\t}\n\n\tsigma_delta->keep_cs_asserted = false;\n\tad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\n\n\tif (sigma_delta->status_appended)\n\t\tad_sigma_delta_append_status(sigma_delta, false);\n\n\tad_sigma_delta_disable_all(sigma_delta);\n\tsigma_delta->bus_locked = false;\n\treturn spi_bus_unlock(sigma_delta->spi->master);\n}\n\nstatic irqreturn_t ad_sd_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\tuint8_t *data = sigma_delta->rx_buf;\n\tunsigned int transfer_size;\n\tunsigned int sample_size;\n\tunsigned int sample_pos;\n\tunsigned int status_pos;\n\tunsigned int reg_size;\n\tunsigned int data_reg;\n\n\treg_size = indio_dev->channels[0].scan_type.realbits +\n\t\t\tindio_dev->channels[0].scan_type.shift;\n\treg_size = DIV_ROUND_UP(reg_size, 8);\n\n\tif (sigma_delta->info->data_reg != 0)\n\t\tdata_reg = sigma_delta->info->data_reg;\n\telse\n\t\tdata_reg = AD_SD_REG_DATA;\n\n\t \n\tif (sigma_delta->status_appended)\n\t\ttransfer_size = reg_size + 1;\n\telse\n\t\ttransfer_size = reg_size;\n\n\tswitch (reg_size) {\n\tcase 4:\n\tcase 2:\n\tcase 1:\n\t\tstatus_pos = reg_size;\n\t\tad_sd_read_reg_raw(sigma_delta, data_reg, transfer_size, &data[0]);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tstatus_pos = reg_size + 1;\n\n\t\t \n\t\tad_sd_read_reg_raw(sigma_delta, data_reg, transfer_size, &data[1]);\n\t\tbreak;\n\t}\n\n\t \n\tif (sigma_delta->active_slots == 1) {\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, data, pf->timestamp);\n\t\tgoto irq_handled;\n\t}\n\n\tif (sigma_delta->status_appended) {\n\t\tu8 converted_channel;\n\n\t\tconverted_channel = data[status_pos] & sigma_delta->info->status_ch_mask;\n\t\tif (converted_channel != sigma_delta->slots[sigma_delta->current_slot]) {\n\t\t\t \n\n\t\t\tsigma_delta->current_slot = 0;\n\t\t\tgoto irq_handled;\n\t\t}\n\t}\n\n\tsample_size = indio_dev->channels[0].scan_type.storagebits / 8;\n\tsample_pos = sample_size * sigma_delta->current_slot;\n\tmemcpy(&sigma_delta->samples_buf[sample_pos], data, sample_size);\n\tsigma_delta->current_slot++;\n\n\tif (sigma_delta->current_slot == sigma_delta->active_slots) {\n\t\tsigma_delta->current_slot = 0;\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, sigma_delta->samples_buf,\n\t\t\t\t\t\t   pf->timestamp);\n\t}\n\nirq_handled:\n\tiio_trigger_notify_done(indio_dev->trig);\n\tsigma_delta->irq_dis = false;\n\tenable_irq(sigma_delta->spi->irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool ad_sd_validate_scan_mask(struct iio_dev *indio_dev, const unsigned long *mask)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\n\treturn bitmap_weight(mask, indio_dev->masklength) <= sigma_delta->num_slots;\n}\n\nstatic const struct iio_buffer_setup_ops ad_sd_buffer_setup_ops = {\n\t.postenable = &ad_sd_buffer_postenable,\n\t.postdisable = &ad_sd_buffer_postdisable,\n\t.validate_scan_mask = &ad_sd_validate_scan_mask,\n};\n\nstatic irqreturn_t ad_sd_data_rdy_trig_poll(int irq, void *private)\n{\n\tstruct ad_sigma_delta *sigma_delta = private;\n\n\tcomplete(&sigma_delta->completion);\n\tdisable_irq_nosync(irq);\n\tsigma_delta->irq_dis = true;\n\tiio_trigger_poll(sigma_delta->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint ad_sd_validate_trigger(struct iio_dev *indio_dev, struct iio_trigger *trig)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\n\tif (sigma_delta->trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_validate_trigger, IIO_AD_SIGMA_DELTA);\n\nstatic int devm_ad_sd_probe_trigger(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (dev != &sigma_delta->spi->dev) {\n\t\tdev_err(dev, \"Trigger parent should be '%s', got '%s'\\n\",\n\t\t\tdev_name(dev), dev_name(&sigma_delta->spi->dev));\n\t\treturn -EFAULT;\n\t}\n\n\tsigma_delta->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\", indio_dev->name,\n\t\t\t\t\t\t   iio_device_id(indio_dev));\n\tif (sigma_delta->trig == NULL)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&sigma_delta->completion);\n\n\tsigma_delta->irq_dis = true;\n\n\t \n\tirq_set_status_flags(sigma_delta->spi->irq, IRQ_DISABLE_UNLAZY);\n\n\tret = devm_request_irq(dev, sigma_delta->spi->irq,\n\t\t\t       ad_sd_data_rdy_trig_poll,\n\t\t\t       sigma_delta->info->irq_flags | IRQF_NO_AUTOEN,\n\t\t\t       indio_dev->name,\n\t\t\t       sigma_delta);\n\tif (ret)\n\t\treturn ret;\n\n\tiio_trigger_set_drvdata(sigma_delta->trig, sigma_delta);\n\n\tret = devm_iio_trigger_register(dev, sigma_delta->trig);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tindio_dev->trig = iio_trigger_get(sigma_delta->trig);\n\n\treturn 0;\n}\n\n \nint devm_ad_sd_setup_buffer_and_trigger(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tsigma_delta->slots = devm_kcalloc(dev, sigma_delta->num_slots,\n\t\t\t\t\t  sizeof(*sigma_delta->slots), GFP_KERNEL);\n\tif (!sigma_delta->slots)\n\t\treturn -ENOMEM;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &ad_sd_trigger_handler,\n\t\t\t\t\t      &ad_sd_buffer_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_ad_sd_probe_trigger(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(devm_ad_sd_setup_buffer_and_trigger, IIO_AD_SIGMA_DELTA);\n\n \nint ad_sd_init(struct ad_sigma_delta *sigma_delta, struct iio_dev *indio_dev,\n\tstruct spi_device *spi, const struct ad_sigma_delta_info *info)\n{\n\tsigma_delta->spi = spi;\n\tsigma_delta->info = info;\n\n\t \n\tif (!info->num_slots)\n\t\tsigma_delta->num_slots = 1;\n\telse\n\t\tsigma_delta->num_slots = info->num_slots;\n\n\tif (sigma_delta->num_slots > 1) {\n\t\tif (!indio_dev->info->update_scan_mode) {\n\t\t\tdev_err(&spi->dev, \"iio_dev lacks update_scan_mode().\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!info->disable_all) {\n\t\t\tdev_err(&spi->dev, \"ad_sigma_delta_info lacks disable_all().\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tiio_device_set_drvdata(indio_dev, sigma_delta);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ad_sd_init, IIO_AD_SIGMA_DELTA);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices Sigma-Delta ADCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}