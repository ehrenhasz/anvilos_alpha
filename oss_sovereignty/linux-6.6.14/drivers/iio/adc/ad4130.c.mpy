{
  "module_name": "ad4130.c",
  "hash_id": "53bf565421d5b35251ecb6f86e1a068dbda825a1707344f95c09d99cd9c06b01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad4130.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/div64.h>\n#include <asm/unaligned.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n\n#define AD4130_NAME\t\t\t\t\"ad4130\"\n\n#define AD4130_COMMS_READ_MASK\t\t\tBIT(6)\n\n#define AD4130_STATUS_REG\t\t\t0x00\n\n#define AD4130_ADC_CONTROL_REG\t\t\t0x01\n#define AD4130_ADC_CONTROL_BIPOLAR_MASK\t\tBIT(14)\n#define AD4130_ADC_CONTROL_INT_REF_VAL_MASK\tBIT(13)\n#define AD4130_INT_REF_2_5V\t\t\t2500000\n#define AD4130_INT_REF_1_25V\t\t\t1250000\n#define AD4130_ADC_CONTROL_CSB_EN_MASK\t\tBIT(9)\n#define AD4130_ADC_CONTROL_INT_REF_EN_MASK\tBIT(8)\n#define AD4130_ADC_CONTROL_MODE_MASK\t\tGENMASK(5, 2)\n#define AD4130_ADC_CONTROL_MCLK_SEL_MASK\tGENMASK(1, 0)\n#define AD4130_MCLK_FREQ_76_8KHZ\t\t76800\n#define AD4130_MCLK_FREQ_153_6KHZ\t\t153600\n\n#define AD4130_DATA_REG\t\t\t\t0x02\n\n#define AD4130_IO_CONTROL_REG\t\t\t0x03\n#define AD4130_IO_CONTROL_INT_PIN_SEL_MASK\tGENMASK(9, 8)\n#define AD4130_IO_CONTROL_GPIO_DATA_MASK\tGENMASK(7, 4)\n#define AD4130_IO_CONTROL_GPIO_CTRL_MASK\tGENMASK(3, 0)\n\n#define AD4130_VBIAS_REG\t\t\t0x04\n\n#define AD4130_ID_REG\t\t\t\t0x05\n\n#define AD4130_ERROR_REG\t\t\t0x06\n\n#define AD4130_ERROR_EN_REG\t\t\t0x07\n\n#define AD4130_MCLK_COUNT_REG\t\t\t0x08\n\n#define AD4130_CHANNEL_X_REG(x)\t\t\t(0x09 + (x))\n#define AD4130_CHANNEL_EN_MASK\t\t\tBIT(23)\n#define AD4130_CHANNEL_SETUP_MASK\t\tGENMASK(22, 20)\n#define AD4130_CHANNEL_AINP_MASK\t\tGENMASK(17, 13)\n#define AD4130_CHANNEL_AINM_MASK\t\tGENMASK(12, 8)\n#define AD4130_CHANNEL_IOUT1_MASK\t\tGENMASK(7, 4)\n#define AD4130_CHANNEL_IOUT2_MASK\t\tGENMASK(3, 0)\n\n#define AD4130_CONFIG_X_REG(x)\t\t\t(0x19 + (x))\n#define AD4130_CONFIG_IOUT1_VAL_MASK\t\tGENMASK(15, 13)\n#define AD4130_CONFIG_IOUT2_VAL_MASK\t\tGENMASK(12, 10)\n#define AD4130_CONFIG_BURNOUT_MASK\t\tGENMASK(9, 8)\n#define AD4130_CONFIG_REF_BUFP_MASK\t\tBIT(7)\n#define AD4130_CONFIG_REF_BUFM_MASK\t\tBIT(6)\n#define AD4130_CONFIG_REF_SEL_MASK\t\tGENMASK(5, 4)\n#define AD4130_CONFIG_PGA_MASK\t\t\tGENMASK(3, 1)\n\n#define AD4130_FILTER_X_REG(x)\t\t\t(0x21 + (x))\n#define AD4130_FILTER_MODE_MASK\t\t\tGENMASK(15, 12)\n#define AD4130_FILTER_SELECT_MASK\t\tGENMASK(10, 0)\n#define AD4130_FILTER_SELECT_MIN\t\t1\n\n#define AD4130_OFFSET_X_REG(x)\t\t\t(0x29 + (x))\n\n#define AD4130_GAIN_X_REG(x)\t\t\t(0x31 + (x))\n\n#define AD4130_MISC_REG\t\t\t\t0x39\n\n#define AD4130_FIFO_CONTROL_REG\t\t\t0x3a\n#define AD4130_FIFO_CONTROL_HEADER_MASK\t\tBIT(18)\n#define AD4130_FIFO_CONTROL_MODE_MASK\t\tGENMASK(17, 16)\n#define AD4130_FIFO_CONTROL_WM_INT_EN_MASK\tBIT(9)\n#define AD4130_FIFO_CONTROL_WM_MASK\t\tGENMASK(7, 0)\n#define AD4130_WATERMARK_256\t\t\t0\n\n#define AD4130_FIFO_STATUS_REG\t\t\t0x3b\n\n#define AD4130_FIFO_THRESHOLD_REG\t\t0x3c\n\n#define AD4130_FIFO_DATA_REG\t\t\t0x3d\n#define AD4130_FIFO_SIZE\t\t\t256\n#define AD4130_FIFO_MAX_SAMPLE_SIZE\t\t3\n\n#define AD4130_MAX_ANALOG_PINS\t\t\t16\n#define AD4130_MAX_CHANNELS\t\t\t16\n#define AD4130_MAX_DIFF_INPUTS\t\t\t30\n#define AD4130_MAX_GPIOS\t\t\t4\n#define AD4130_MAX_ODR\t\t\t\t2400\n#define AD4130_MAX_PGA\t\t\t\t8\n#define AD4130_MAX_SETUPS\t\t\t8\n\n#define AD4130_AIN2_P1\t\t\t\t0x2\n#define AD4130_AIN3_P2\t\t\t\t0x3\n\n#define AD4130_RESET_BUF_SIZE\t\t\t8\n#define AD4130_RESET_SLEEP_US\t\t\t(160 * MICRO / AD4130_MCLK_FREQ_76_8KHZ)\n\n#define AD4130_INVALID_SLOT\t\t\t-1\n\nstatic const unsigned int ad4130_reg_size[] = {\n\t[AD4130_STATUS_REG] = 1,\n\t[AD4130_ADC_CONTROL_REG] = 2,\n\t[AD4130_DATA_REG] = 3,\n\t[AD4130_IO_CONTROL_REG] = 2,\n\t[AD4130_VBIAS_REG] = 2,\n\t[AD4130_ID_REG] = 1,\n\t[AD4130_ERROR_REG] = 2,\n\t[AD4130_ERROR_EN_REG] = 2,\n\t[AD4130_MCLK_COUNT_REG] = 1,\n\t[AD4130_CHANNEL_X_REG(0) ... AD4130_CHANNEL_X_REG(AD4130_MAX_CHANNELS - 1)] = 3,\n\t[AD4130_CONFIG_X_REG(0) ... AD4130_CONFIG_X_REG(AD4130_MAX_SETUPS - 1)] = 2,\n\t[AD4130_FILTER_X_REG(0) ... AD4130_FILTER_X_REG(AD4130_MAX_SETUPS - 1)] = 3,\n\t[AD4130_OFFSET_X_REG(0) ... AD4130_OFFSET_X_REG(AD4130_MAX_SETUPS - 1)] = 3,\n\t[AD4130_GAIN_X_REG(0) ... AD4130_GAIN_X_REG(AD4130_MAX_SETUPS - 1)] = 3,\n\t[AD4130_MISC_REG] = 2,\n\t[AD4130_FIFO_CONTROL_REG] = 3,\n\t[AD4130_FIFO_STATUS_REG] = 1,\n\t[AD4130_FIFO_THRESHOLD_REG] = 3,\n\t[AD4130_FIFO_DATA_REG] = 3,\n};\n\nenum ad4130_int_ref_val {\n\tAD4130_INT_REF_VAL_2_5V,\n\tAD4130_INT_REF_VAL_1_25V,\n};\n\nenum ad4130_mclk_sel {\n\tAD4130_MCLK_76_8KHZ,\n\tAD4130_MCLK_76_8KHZ_OUT,\n\tAD4130_MCLK_76_8KHZ_EXT,\n\tAD4130_MCLK_153_6KHZ_EXT,\n};\n\nenum ad4130_int_pin_sel {\n\tAD4130_INT_PIN_INT,\n\tAD4130_INT_PIN_CLK,\n\tAD4130_INT_PIN_P2,\n\tAD4130_INT_PIN_DOUT,\n};\n\nenum ad4130_iout {\n\tAD4130_IOUT_OFF,\n\tAD4130_IOUT_10000NA,\n\tAD4130_IOUT_20000NA,\n\tAD4130_IOUT_50000NA,\n\tAD4130_IOUT_100000NA,\n\tAD4130_IOUT_150000NA,\n\tAD4130_IOUT_200000NA,\n\tAD4130_IOUT_100NA,\n\tAD4130_IOUT_MAX\n};\n\nenum ad4130_burnout {\n\tAD4130_BURNOUT_OFF,\n\tAD4130_BURNOUT_500NA,\n\tAD4130_BURNOUT_2000NA,\n\tAD4130_BURNOUT_4000NA,\n\tAD4130_BURNOUT_MAX\n};\n\nenum ad4130_ref_sel {\n\tAD4130_REF_REFIN1,\n\tAD4130_REF_REFIN2,\n\tAD4130_REF_REFOUT_AVSS,\n\tAD4130_REF_AVDD_AVSS,\n\tAD4130_REF_SEL_MAX\n};\n\nenum ad4130_fifo_mode {\n\tAD4130_FIFO_MODE_DISABLED = 0b00,\n\tAD4130_FIFO_MODE_WM = 0b01,\n};\n\nenum ad4130_mode {\n\tAD4130_MODE_CONTINUOUS = 0b0000,\n\tAD4130_MODE_IDLE = 0b0100,\n};\n\nenum ad4130_filter_mode {\n\tAD4130_FILTER_SINC4,\n\tAD4130_FILTER_SINC4_SINC1,\n\tAD4130_FILTER_SINC3,\n\tAD4130_FILTER_SINC3_REJ60,\n\tAD4130_FILTER_SINC3_SINC1,\n\tAD4130_FILTER_SINC3_PF1,\n\tAD4130_FILTER_SINC3_PF2,\n\tAD4130_FILTER_SINC3_PF3,\n\tAD4130_FILTER_SINC3_PF4,\n};\n\nenum ad4130_pin_function {\n\tAD4130_PIN_FN_NONE,\n\tAD4130_PIN_FN_SPECIAL = BIT(0),\n\tAD4130_PIN_FN_DIFF = BIT(1),\n\tAD4130_PIN_FN_EXCITATION = BIT(2),\n\tAD4130_PIN_FN_VBIAS = BIT(3),\n};\n\nstruct ad4130_setup_info {\n\tunsigned int\t\t\tiout0_val;\n\tunsigned int\t\t\tiout1_val;\n\tunsigned int\t\t\tburnout;\n\tunsigned int\t\t\tpga;\n\tunsigned int\t\t\tfs;\n\tu32\t\t\t\tref_sel;\n\tenum ad4130_filter_mode\t\tfilter_mode;\n\tbool\t\t\t\tref_bufp;\n\tbool\t\t\t\tref_bufm;\n};\n\nstruct ad4130_slot_info {\n\tstruct ad4130_setup_info\tsetup;\n\tunsigned int\t\t\tenabled_channels;\n\tunsigned int\t\t\tchannels;\n};\n\nstruct ad4130_chan_info {\n\tstruct ad4130_setup_info\tsetup;\n\tu32\t\t\t\tiout0;\n\tu32\t\t\t\tiout1;\n\tint\t\t\t\tslot;\n\tbool\t\t\t\tenabled;\n\tbool\t\t\t\tinitialized;\n};\n\nstruct ad4130_filter_config {\n\tenum ad4130_filter_mode\t\tfilter_mode;\n\tunsigned int\t\t\todr_div;\n\tunsigned int\t\t\tfs_max;\n\tenum iio_available_type\t\tsamp_freq_avail_type;\n\tint\t\t\t\tsamp_freq_avail_len;\n\tint\t\t\t\tsamp_freq_avail[3][2];\n};\n\nstruct ad4130_state {\n\tstruct regmap\t\t\t*regmap;\n\tstruct spi_device\t\t*spi;\n\tstruct clk\t\t\t*mclk;\n\tstruct regulator_bulk_data\tregulators[4];\n\tu32\t\t\t\tirq_trigger;\n\tu32\t\t\t\tinv_irq_trigger;\n\n\t \n\tstruct mutex\t\t\tlock;\n\tstruct completion\t\tcompletion;\n\n\tstruct iio_chan_spec\t\tchans[AD4130_MAX_CHANNELS];\n\tstruct ad4130_chan_info\t\tchans_info[AD4130_MAX_CHANNELS];\n\tstruct ad4130_slot_info\t\tslots_info[AD4130_MAX_SETUPS];\n\tenum ad4130_pin_function\tpins_fn[AD4130_MAX_ANALOG_PINS];\n\tu32\t\t\t\tvbias_pins[AD4130_MAX_ANALOG_PINS];\n\tu32\t\t\t\tnum_vbias_pins;\n\tint\t\t\t\tscale_tbls[AD4130_REF_SEL_MAX][AD4130_MAX_PGA][2];\n\tstruct gpio_chip\t\tgc;\n\tstruct clk_hw\t\t\tint_clk_hw;\n\n\tu32\t\t\tint_pin_sel;\n\tu32\t\t\tint_ref_uv;\n\tu32\t\t\tmclk_sel;\n\tbool\t\t\tint_ref_en;\n\tbool\t\t\tbipolar;\n\n\tunsigned int\t\tnum_enabled_channels;\n\tunsigned int\t\teffective_watermark;\n\tunsigned int\t\twatermark;\n\n\tstruct spi_message\tfifo_msg;\n\tstruct spi_transfer\tfifo_xfer[2];\n\n\t \n\tu8\t\t\treset_buf[AD4130_RESET_BUF_SIZE] __aligned(IIO_DMA_MINALIGN);\n\tu8\t\t\treg_write_tx_buf[4];\n\tu8\t\t\treg_read_tx_buf[1];\n\tu8\t\t\treg_read_rx_buf[3];\n\tu8\t\t\tfifo_tx_buf[2];\n\tu8\t\t\tfifo_rx_buf[AD4130_FIFO_SIZE *\n\t\t\t\t\t    AD4130_FIFO_MAX_SAMPLE_SIZE];\n};\n\nstatic const char * const ad4130_int_pin_names[] = {\n\t[AD4130_INT_PIN_INT] = \"int\",\n\t[AD4130_INT_PIN_CLK] = \"clk\",\n\t[AD4130_INT_PIN_P2] = \"p2\",\n\t[AD4130_INT_PIN_DOUT] = \"dout\",\n};\n\nstatic const unsigned int ad4130_iout_current_na_tbl[AD4130_IOUT_MAX] = {\n\t[AD4130_IOUT_OFF] = 0,\n\t[AD4130_IOUT_100NA] = 100,\n\t[AD4130_IOUT_10000NA] = 10000,\n\t[AD4130_IOUT_20000NA] = 20000,\n\t[AD4130_IOUT_50000NA] = 50000,\n\t[AD4130_IOUT_100000NA] = 100000,\n\t[AD4130_IOUT_150000NA] = 150000,\n\t[AD4130_IOUT_200000NA] = 200000,\n};\n\nstatic const unsigned int ad4130_burnout_current_na_tbl[AD4130_BURNOUT_MAX] = {\n\t[AD4130_BURNOUT_OFF] = 0,\n\t[AD4130_BURNOUT_500NA] = 500,\n\t[AD4130_BURNOUT_2000NA] = 2000,\n\t[AD4130_BURNOUT_4000NA] = 4000,\n};\n\n#define AD4130_VARIABLE_ODR_CONFIG(_filter_mode, _odr_div, _fs_max)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\t.filter_mode = (_filter_mode),\t\t\t\t\\\n\t\t.odr_div = (_odr_div),\t\t\t\t\t\\\n\t\t.fs_max = (_fs_max),\t\t\t\t\t\\\n\t\t.samp_freq_avail_type = IIO_AVAIL_RANGE,\t\t\\\n\t\t.samp_freq_avail = {\t\t\t\t\t\\\n\t\t\t{ AD4130_MAX_ODR, (_odr_div) * (_fs_max) },\t\\\n\t\t\t{ AD4130_MAX_ODR, (_odr_div) * (_fs_max) },\t\\\n\t\t\t{ AD4130_MAX_ODR, (_odr_div) },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n}\n\n#define AD4130_FIXED_ODR_CONFIG(_filter_mode, _odr_div)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\t.filter_mode = (_filter_mode),\t\t\t\t\\\n\t\t.odr_div = (_odr_div),\t\t\t\t\t\\\n\t\t.fs_max = AD4130_FILTER_SELECT_MIN,\t\t\t\\\n\t\t.samp_freq_avail_type = IIO_AVAIL_LIST,\t\t\t\\\n\t\t.samp_freq_avail_len = 1,\t\t\t\t\\\n\t\t.samp_freq_avail = {\t\t\t\t\t\\\n\t\t\t{ AD4130_MAX_ODR, (_odr_div) },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct ad4130_filter_config ad4130_filter_configs[] = {\n\tAD4130_VARIABLE_ODR_CONFIG(AD4130_FILTER_SINC4,       1,  10),\n\tAD4130_VARIABLE_ODR_CONFIG(AD4130_FILTER_SINC4_SINC1, 11, 10),\n\tAD4130_VARIABLE_ODR_CONFIG(AD4130_FILTER_SINC3,       1,  2047),\n\tAD4130_VARIABLE_ODR_CONFIG(AD4130_FILTER_SINC3_REJ60, 1,  2047),\n\tAD4130_VARIABLE_ODR_CONFIG(AD4130_FILTER_SINC3_SINC1, 10, 2047),\n\tAD4130_FIXED_ODR_CONFIG(AD4130_FILTER_SINC3_PF1,      92),\n\tAD4130_FIXED_ODR_CONFIG(AD4130_FILTER_SINC3_PF2,      100),\n\tAD4130_FIXED_ODR_CONFIG(AD4130_FILTER_SINC3_PF3,      124),\n\tAD4130_FIXED_ODR_CONFIG(AD4130_FILTER_SINC3_PF4,      148),\n};\n\nstatic const char * const ad4130_filter_modes_str[] = {\n\t[AD4130_FILTER_SINC4] = \"sinc4\",\n\t[AD4130_FILTER_SINC4_SINC1] = \"sinc4+sinc1\",\n\t[AD4130_FILTER_SINC3] = \"sinc3\",\n\t[AD4130_FILTER_SINC3_REJ60] = \"sinc3+rej60\",\n\t[AD4130_FILTER_SINC3_SINC1] = \"sinc3+sinc1\",\n\t[AD4130_FILTER_SINC3_PF1] = \"sinc3+pf1\",\n\t[AD4130_FILTER_SINC3_PF2] = \"sinc3+pf2\",\n\t[AD4130_FILTER_SINC3_PF3] = \"sinc3+pf3\",\n\t[AD4130_FILTER_SINC3_PF4] = \"sinc3+pf4\",\n};\n\nstatic int ad4130_get_reg_size(struct ad4130_state *st, unsigned int reg,\n\t\t\t       unsigned int *size)\n{\n\tif (reg >= ARRAY_SIZE(ad4130_reg_size))\n\t\treturn -EINVAL;\n\n\t*size = ad4130_reg_size[reg];\n\n\treturn 0;\n}\n\nstatic unsigned int ad4130_data_reg_size(struct ad4130_state *st)\n{\n\tunsigned int data_reg_size;\n\tint ret;\n\n\tret = ad4130_get_reg_size(st, AD4130_DATA_REG, &data_reg_size);\n\tif (ret)\n\t\treturn 0;\n\n\treturn data_reg_size;\n}\n\nstatic unsigned int ad4130_resolution(struct ad4130_state *st)\n{\n\treturn ad4130_data_reg_size(st) * BITS_PER_BYTE;\n}\n\nstatic int ad4130_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct ad4130_state *st = context;\n\tunsigned int size;\n\tint ret;\n\n\tret = ad4130_get_reg_size(st, reg, &size);\n\tif (ret)\n\t\treturn ret;\n\n\tst->reg_write_tx_buf[0] = reg;\n\n\tswitch (size) {\n\tcase 3:\n\t\tput_unaligned_be24(val, &st->reg_write_tx_buf[1]);\n\t\tbreak;\n\tcase 2:\n\t\tput_unaligned_be16(val, &st->reg_write_tx_buf[1]);\n\t\tbreak;\n\tcase 1:\n\t\tst->reg_write_tx_buf[1] = val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn spi_write(st->spi, st->reg_write_tx_buf, size + 1);\n}\n\nstatic int ad4130_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct ad4130_state *st = context;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = st->reg_read_tx_buf,\n\t\t\t.len = sizeof(st->reg_read_tx_buf),\n\t\t},\n\t\t{\n\t\t\t.rx_buf = st->reg_read_rx_buf,\n\t\t},\n\t};\n\tunsigned int size;\n\tint ret;\n\n\tret = ad4130_get_reg_size(st, reg, &size);\n\tif (ret)\n\t\treturn ret;\n\n\tst->reg_read_tx_buf[0] = AD4130_COMMS_READ_MASK | reg;\n\tt[1].len = size;\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (size) {\n\tcase 3:\n\t\t*val = get_unaligned_be24(st->reg_read_rx_buf);\n\t\tbreak;\n\tcase 2:\n\t\t*val = get_unaligned_be16(st->reg_read_rx_buf);\n\t\tbreak;\n\tcase 1:\n\t\t*val = st->reg_read_rx_buf[0];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config ad4130_regmap_config = {\n\t.reg_read = ad4130_reg_read,\n\t.reg_write = ad4130_reg_write,\n};\n\nstatic int ad4130_gpio_init_valid_mask(struct gpio_chip *gc,\n\t\t\t\t       unsigned long *valid_mask,\n\t\t\t\t       unsigned int ngpios)\n{\n\tstruct ad4130_state *st = gpiochip_get_data(gc);\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ngpios; i++) {\n\t\tunsigned int pin = i + AD4130_AIN2_P1;\n\t\tbool valid = st->pins_fn[pin] == AD4130_PIN_FN_NONE;\n\n\t\t__assign_bit(i, valid_mask, valid);\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void ad4130_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct ad4130_state *st = gpiochip_get_data(gc);\n\tunsigned int mask = FIELD_PREP(AD4130_IO_CONTROL_GPIO_DATA_MASK,\n\t\t\t\t       BIT(offset));\n\n\tregmap_update_bits(st->regmap, AD4130_IO_CONTROL_REG, mask,\n\t\t\t   value ? mask : 0);\n}\n\nstatic int ad4130_set_mode(struct ad4130_state *st, enum ad4130_mode mode)\n{\n\treturn regmap_update_bits(st->regmap, AD4130_ADC_CONTROL_REG,\n\t\t\t\t  AD4130_ADC_CONTROL_MODE_MASK,\n\t\t\t\t  FIELD_PREP(AD4130_ADC_CONTROL_MODE_MASK, mode));\n}\n\nstatic int ad4130_set_watermark_interrupt_en(struct ad4130_state *st, bool en)\n{\n\treturn regmap_update_bits(st->regmap, AD4130_FIFO_CONTROL_REG,\n\t\t\t\t  AD4130_FIFO_CONTROL_WM_INT_EN_MASK,\n\t\t\t\t  FIELD_PREP(AD4130_FIFO_CONTROL_WM_INT_EN_MASK, en));\n}\n\nstatic unsigned int ad4130_watermark_reg_val(unsigned int val)\n{\n\tif (val == AD4130_FIFO_SIZE)\n\t\tval = AD4130_WATERMARK_256;\n\n\treturn val;\n}\n\nstatic int ad4130_set_fifo_mode(struct ad4130_state *st,\n\t\t\t\tenum ad4130_fifo_mode mode)\n{\n\treturn regmap_update_bits(st->regmap, AD4130_FIFO_CONTROL_REG,\n\t\t\t\t  AD4130_FIFO_CONTROL_MODE_MASK,\n\t\t\t\t  FIELD_PREP(AD4130_FIFO_CONTROL_MODE_MASK, mode));\n}\n\nstatic void ad4130_push_fifo_data(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int data_reg_size = ad4130_data_reg_size(st);\n\tunsigned int transfer_len = st->effective_watermark * data_reg_size;\n\tunsigned int set_size = st->num_enabled_channels * data_reg_size;\n\tunsigned int i;\n\tint ret;\n\n\tst->fifo_tx_buf[1] = ad4130_watermark_reg_val(st->effective_watermark);\n\tst->fifo_xfer[1].len = transfer_len;\n\n\tret = spi_sync(st->spi, &st->fifo_msg);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < transfer_len; i += set_size)\n\t\tiio_push_to_buffers(indio_dev, &st->fifo_rx_buf[i]);\n}\n\nstatic irqreturn_t ad4130_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tad4130_push_fifo_data(indio_dev);\n\telse\n\t\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad4130_find_slot(struct ad4130_state *st,\n\t\t\t    struct ad4130_setup_info *target_setup_info,\n\t\t\t    unsigned int *slot, bool *overwrite)\n{\n\tunsigned int i;\n\n\t*slot = AD4130_INVALID_SLOT;\n\t*overwrite = false;\n\n\tfor (i = 0; i < AD4130_MAX_SETUPS; i++) {\n\t\tstruct ad4130_slot_info *slot_info = &st->slots_info[i];\n\n\t\t \n\t\tif (!memcmp(target_setup_info, &slot_info->setup,\n\t\t\t    sizeof(*target_setup_info))) {\n\t\t\t*slot = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (slot_info->enabled_channels)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (*slot == AD4130_INVALID_SLOT ||\n\t\t    slot_info->channels < st->slots_info[*slot].channels)\n\t\t\t*slot = i;\n\t}\n\n\tif (*slot == AD4130_INVALID_SLOT)\n\t\treturn -EINVAL;\n\n\t*overwrite = true;\n\n\treturn 0;\n}\n\nstatic void ad4130_unlink_channel(struct ad4130_state *st, unsigned int channel)\n{\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_slot_info *slot_info = &st->slots_info[chan_info->slot];\n\n\tchan_info->slot = AD4130_INVALID_SLOT;\n\tslot_info->channels--;\n}\n\nstatic int ad4130_unlink_slot(struct ad4130_state *st, unsigned int slot)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < AD4130_MAX_CHANNELS; i++) {\n\t\tstruct ad4130_chan_info *chan_info = &st->chans_info[i];\n\n\t\tif (!chan_info->initialized || chan_info->slot != slot)\n\t\t\tcontinue;\n\n\t\tad4130_unlink_channel(st, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_link_channel_slot(struct ad4130_state *st,\n\t\t\t\t    unsigned int channel, unsigned int slot)\n{\n\tstruct ad4130_slot_info *slot_info = &st->slots_info[slot];\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, AD4130_CHANNEL_X_REG(channel),\n\t\t\t\t AD4130_CHANNEL_SETUP_MASK,\n\t\t\t\t FIELD_PREP(AD4130_CHANNEL_SETUP_MASK, slot));\n\tif (ret)\n\t\treturn ret;\n\n\tchan_info->slot = slot;\n\tslot_info->channels++;\n\n\treturn 0;\n}\n\nstatic int ad4130_write_slot_setup(struct ad4130_state *st,\n\t\t\t\t   unsigned int slot,\n\t\t\t\t   struct ad4130_setup_info *setup_info)\n{\n\tunsigned int val;\n\tint ret;\n\n\tval = FIELD_PREP(AD4130_CONFIG_IOUT1_VAL_MASK, setup_info->iout0_val) |\n\t      FIELD_PREP(AD4130_CONFIG_IOUT1_VAL_MASK, setup_info->iout1_val) |\n\t      FIELD_PREP(AD4130_CONFIG_BURNOUT_MASK, setup_info->burnout) |\n\t      FIELD_PREP(AD4130_CONFIG_REF_BUFP_MASK, setup_info->ref_bufp) |\n\t      FIELD_PREP(AD4130_CONFIG_REF_BUFM_MASK, setup_info->ref_bufm) |\n\t      FIELD_PREP(AD4130_CONFIG_REF_SEL_MASK, setup_info->ref_sel) |\n\t      FIELD_PREP(AD4130_CONFIG_PGA_MASK, setup_info->pga);\n\n\tret = regmap_write(st->regmap, AD4130_CONFIG_X_REG(slot), val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_PREP(AD4130_FILTER_MODE_MASK, setup_info->filter_mode) |\n\t      FIELD_PREP(AD4130_FILTER_SELECT_MASK, setup_info->fs);\n\n\tret = regmap_write(st->regmap, AD4130_FILTER_X_REG(slot), val);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&st->slots_info[slot].setup, setup_info, sizeof(*setup_info));\n\n\treturn 0;\n}\n\nstatic int ad4130_write_channel_setup(struct ad4130_state *st,\n\t\t\t\t      unsigned int channel, bool on_enable)\n{\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_setup_info *setup_info = &chan_info->setup;\n\tbool overwrite;\n\tint slot;\n\tint ret;\n\n\t \n\n\t \n\tif (on_enable && chan_info->slot != AD4130_INVALID_SLOT)\n\t\treturn 0;\n\n\tif (!on_enable && !chan_info->enabled) {\n\t\tif (chan_info->slot != AD4130_INVALID_SLOT)\n\t\t\t \n\t\t\tad4130_unlink_channel(st, channel);\n\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tret = ad4130_find_slot(st, setup_info, &slot, &overwrite);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan_info->slot != AD4130_INVALID_SLOT)\n\t\t \n\t\tad4130_unlink_channel(st, channel);\n\n\tif (overwrite) {\n\t\tret = ad4130_unlink_slot(st, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ad4130_write_slot_setup(st, slot, setup_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ad4130_link_channel_slot(st, channel, slot);\n}\n\nstatic int ad4130_set_channel_enable(struct ad4130_state *st,\n\t\t\t\t     unsigned int channel, bool status)\n{\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_slot_info *slot_info;\n\tint ret;\n\n\tif (chan_info->enabled == status)\n\t\treturn 0;\n\n\tif (status) {\n\t\tret = ad4130_write_channel_setup(st, channel, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tslot_info = &st->slots_info[chan_info->slot];\n\n\tret = regmap_update_bits(st->regmap, AD4130_CHANNEL_X_REG(channel),\n\t\t\t\t AD4130_CHANNEL_EN_MASK,\n\t\t\t\t FIELD_PREP(AD4130_CHANNEL_EN_MASK, status));\n\tif (ret)\n\t\treturn ret;\n\n\tslot_info->enabled_channels += status ? 1 : -1;\n\tchan_info->enabled = status;\n\n\treturn 0;\n}\n\n \n\nstatic void ad4130_freq_to_fs(enum ad4130_filter_mode filter_mode,\n\t\t\t      int val, int val2, unsigned int *fs)\n{\n\tconst struct ad4130_filter_config *filter_config =\n\t\t&ad4130_filter_configs[filter_mode];\n\tu64 dividend, divisor;\n\tint temp;\n\n\tdividend = filter_config->fs_max * filter_config->odr_div *\n\t\t   ((u64)val * NANO + val2);\n\tdivisor = (u64)AD4130_MAX_ODR * NANO;\n\n\ttemp = AD4130_FILTER_SELECT_MIN + filter_config->fs_max -\n\t       DIV64_U64_ROUND_CLOSEST(dividend, divisor);\n\n\tif (temp < AD4130_FILTER_SELECT_MIN)\n\t\ttemp = AD4130_FILTER_SELECT_MIN;\n\telse if (temp > filter_config->fs_max)\n\t\ttemp = filter_config->fs_max;\n\n\t*fs = temp;\n}\n\nstatic void ad4130_fs_to_freq(enum ad4130_filter_mode filter_mode,\n\t\t\t      unsigned int fs, int *val, int *val2)\n{\n\tconst struct ad4130_filter_config *filter_config =\n\t\t&ad4130_filter_configs[filter_mode];\n\tunsigned int dividend, divisor;\n\tu64 temp;\n\n\tdividend = (filter_config->fs_max - fs + AD4130_FILTER_SELECT_MIN) *\n\t\t   AD4130_MAX_ODR;\n\tdivisor = filter_config->fs_max * filter_config->odr_div;\n\n\ttemp = div_u64((u64)dividend * NANO, divisor);\n\t*val = div_u64_rem(temp, NANO, val2);\n}\n\nstatic int ad4130_set_filter_mode(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  unsigned int val)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel = chan->scan_index;\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_setup_info *setup_info = &chan_info->setup;\n\tenum ad4130_filter_mode old_filter_mode;\n\tint freq_val, freq_val2;\n\tunsigned int old_fs;\n\tint ret = 0;\n\n\tmutex_lock(&st->lock);\n\tif (setup_info->filter_mode == val)\n\t\tgoto out;\n\n\told_fs = setup_info->fs;\n\told_filter_mode = setup_info->filter_mode;\n\n\t \n\tad4130_fs_to_freq(setup_info->filter_mode, setup_info->fs,\n\t\t\t  &freq_val, &freq_val2);\n\n\tad4130_freq_to_fs(val, freq_val, freq_val2, &setup_info->fs);\n\n\tsetup_info->filter_mode = val;\n\n\tret = ad4130_write_channel_setup(st, channel, false);\n\tif (ret) {\n\t\tsetup_info->fs = old_fs;\n\t\tsetup_info->filter_mode = old_filter_mode;\n\t}\n\n out:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad4130_get_filter_mode(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel = chan->scan_index;\n\tstruct ad4130_setup_info *setup_info = &st->chans_info[channel].setup;\n\tenum ad4130_filter_mode filter_mode;\n\n\tmutex_lock(&st->lock);\n\tfilter_mode = setup_info->filter_mode;\n\tmutex_unlock(&st->lock);\n\n\treturn filter_mode;\n}\n\nstatic const struct iio_enum ad4130_filter_mode_enum = {\n\t.items = ad4130_filter_modes_str,\n\t.num_items = ARRAY_SIZE(ad4130_filter_modes_str),\n\t.set = ad4130_set_filter_mode,\n\t.get = ad4130_get_filter_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info ad4130_filter_mode_ext_info[] = {\n\tIIO_ENUM(\"filter_mode\", IIO_SEPARATE, &ad4130_filter_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"filter_mode\", IIO_SHARED_BY_TYPE,\n\t\t\t   &ad4130_filter_mode_enum),\n\t{ }\n};\n\nstatic const struct iio_chan_spec ad4130_channel_template = {\n\t.type = IIO_VOLTAGE,\n\t.indexed = 1,\n\t.differential = 1,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t.ext_info = ad4130_filter_mode_ext_info,\n\t.scan_type = {\n\t\t.sign = 'u',\n\t\t.endianness = IIO_BE,\n\t},\n};\n\nstatic int ad4130_set_channel_pga(struct ad4130_state *st, unsigned int channel,\n\t\t\t\t  int val, int val2)\n{\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_setup_info *setup_info = &chan_info->setup;\n\tunsigned int pga, old_pga;\n\tint ret = 0;\n\n\tfor (pga = 0; pga < AD4130_MAX_PGA; pga++)\n\t\tif (val == st->scale_tbls[setup_info->ref_sel][pga][0] &&\n\t\t    val2 == st->scale_tbls[setup_info->ref_sel][pga][1])\n\t\t\tbreak;\n\n\tif (pga == AD4130_MAX_PGA)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tif (pga == setup_info->pga)\n\t\tgoto out;\n\n\told_pga = setup_info->pga;\n\tsetup_info->pga = pga;\n\n\tret = ad4130_write_channel_setup(st, channel, false);\n\tif (ret)\n\t\tsetup_info->pga = old_pga;\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad4130_set_channel_freq(struct ad4130_state *st,\n\t\t\t\t   unsigned int channel, int val, int val2)\n{\n\tstruct ad4130_chan_info *chan_info = &st->chans_info[channel];\n\tstruct ad4130_setup_info *setup_info = &chan_info->setup;\n\tunsigned int fs, old_fs;\n\tint ret = 0;\n\n\tmutex_lock(&st->lock);\n\told_fs = setup_info->fs;\n\n\tad4130_freq_to_fs(setup_info->filter_mode, val, val2, &fs);\n\n\tif (fs == setup_info->fs)\n\t\tgoto out;\n\n\tsetup_info->fs = fs;\n\n\tret = ad4130_write_channel_setup(st, channel, false);\n\tif (ret)\n\t\tsetup_info->fs = old_fs;\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int _ad4130_read_sample(struct iio_dev *indio_dev, unsigned int channel,\n\t\t\t       int *val)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = ad4130_set_channel_enable(st, channel, true);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&st->completion);\n\n\tret = ad4130_set_mode(st, AD4130_MODE_CONTINUOUS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tret = ad4130_set_mode(st, AD4130_MODE_IDLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(st->regmap, AD4130_DATA_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad4130_set_channel_enable(st, channel, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad4130_read_sample(struct iio_dev *indio_dev, unsigned int channel,\n\t\t\t      int *val)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tret = _ad4130_read_sample(indio_dev, channel, val);\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int ad4130_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel = chan->scan_index;\n\tstruct ad4130_setup_info *setup_info = &st->chans_info[channel].setup;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ad4130_read_sample(indio_dev, channel, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&st->lock);\n\t\t*val = st->scale_tbls[setup_info->ref_sel][setup_info->pga][0];\n\t\t*val2 = st->scale_tbls[setup_info->ref_sel][setup_info->pga][1];\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = st->bipolar ? -BIT(chan->scan_type.realbits - 1) : 0;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&st->lock);\n\t\tad4130_fs_to_freq(setup_info->filter_mode, setup_info->fs,\n\t\t\t\t  val, val2);\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad4130_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long info)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel = chan->scan_index;\n\tstruct ad4130_setup_info *setup_info = &st->chans_info[channel].setup;\n\tconst struct ad4130_filter_config *filter_config;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (int *)st->scale_tbls[setup_info->ref_sel];\n\t\t*length = ARRAY_SIZE(st->scale_tbls[setup_info->ref_sel]) * 2;\n\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&st->lock);\n\t\tfilter_config = &ad4130_filter_configs[setup_info->filter_mode];\n\t\tmutex_unlock(&st->lock);\n\n\t\t*vals = (int *)filter_config->samp_freq_avail;\n\t\t*length = filter_config->samp_freq_avail_len * 2;\n\t\t*type = IIO_VAL_FRACTIONAL;\n\n\t\treturn filter_config->samp_freq_avail_type;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad4130_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad4130_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long info)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel = chan->scan_index;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn ad4130_set_channel_pga(st, channel, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn ad4130_set_channel_freq(st, channel, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad4130_reg_access(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t     unsigned int writeval, unsigned int *readval)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\n\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic int ad4130_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t   const unsigned long *scan_mask)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int channel;\n\tunsigned int val = 0;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tfor_each_set_bit(channel, scan_mask, indio_dev->num_channels) {\n\t\tret = ad4130_set_channel_enable(st, channel, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tval++;\n\t}\n\n\tst->num_enabled_channels = val;\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn 0;\n}\n\nstatic int ad4130_set_fifo_watermark(struct iio_dev *indio_dev, unsigned int val)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int eff;\n\tint ret;\n\n\tif (val > AD4130_FIFO_SIZE)\n\t\treturn -EINVAL;\n\n\teff = val * st->num_enabled_channels;\n\tif (eff > AD4130_FIFO_SIZE)\n\t\t \n\t\teff = rounddown(AD4130_FIFO_SIZE, st->num_enabled_channels);\n\n\tmutex_lock(&st->lock);\n\n\tret = regmap_update_bits(st->regmap, AD4130_FIFO_CONTROL_REG,\n\t\t\t\t AD4130_FIFO_CONTROL_WM_MASK,\n\t\t\t\t FIELD_PREP(AD4130_FIFO_CONTROL_WM_MASK,\n\t\t\t\t\t    ad4130_watermark_reg_val(eff)));\n\tif (ret)\n\t\tgoto out;\n\n\tst->effective_watermark = eff;\n\tst->watermark = val;\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info ad4130_info = {\n\t.read_raw = ad4130_read_raw,\n\t.read_avail = ad4130_read_avail,\n\t.write_raw_get_fmt = ad4130_write_raw_get_fmt,\n\t.write_raw = ad4130_write_raw,\n\t.update_scan_mode = ad4130_update_scan_mode,\n\t.hwfifo_set_watermark = ad4130_set_fifo_watermark,\n\t.debugfs_reg_access = ad4130_reg_access,\n};\n\nstatic int ad4130_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = ad4130_set_watermark_interrupt_en(st, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_set_irq_type(st->spi->irq, st->inv_irq_trigger);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ad4130_set_fifo_mode(st, AD4130_FIFO_MODE_WM);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ad4130_set_mode(st, AD4130_MODE_CONTINUOUS);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad4130_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int i;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = ad4130_set_mode(st, AD4130_MODE_IDLE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_set_irq_type(st->spi->irq, st->irq_trigger);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ad4130_set_fifo_mode(st, AD4130_FIFO_MODE_DISABLED);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ad4130_set_watermark_interrupt_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tret = ad4130_set_channel_enable(st, i, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops ad4130_buffer_ops = {\n\t.postenable = ad4130_buffer_postenable,\n\t.predisable = ad4130_buffer_predisable,\n};\n\nstatic ssize_t hwfifo_watermark_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad4130_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned int val;\n\n\tmutex_lock(&st->lock);\n\tval = st->watermark;\n\tmutex_unlock(&st->lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t hwfifo_enabled_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ad4130_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD4130_FIFO_CONTROL_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_GET(AD4130_FIFO_CONTROL_MODE_MASK, val);\n\n\treturn sysfs_emit(buf, \"%d\\n\", val != AD4130_FIFO_MODE_DISABLED);\n}\n\nstatic ssize_t hwfifo_watermark_min_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", \"1\");\n}\n\nstatic ssize_t hwfifo_watermark_max_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", __stringify(AD4130_FIFO_SIZE));\n}\n\nstatic IIO_DEVICE_ATTR_RO(hwfifo_watermark_min, 0);\nstatic IIO_DEVICE_ATTR_RO(hwfifo_watermark_max, 0);\nstatic IIO_DEVICE_ATTR_RO(hwfifo_watermark, 0);\nstatic IIO_DEVICE_ATTR_RO(hwfifo_enabled, 0);\n\nstatic const struct iio_dev_attr *ad4130_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark_min,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL\n};\n\nstatic int _ad4130_find_table_index(const unsigned int *tbl, size_t len,\n\t\t\t\t    unsigned int val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (tbl[i] == val)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n#define ad4130_find_table_index(table, val) \\\n\t_ad4130_find_table_index(table, ARRAY_SIZE(table), val)\n\nstatic int ad4130_get_ref_voltage(struct ad4130_state *st,\n\t\t\t\t  enum ad4130_ref_sel ref_sel)\n{\n\tswitch (ref_sel) {\n\tcase AD4130_REF_REFIN1:\n\t\treturn regulator_get_voltage(st->regulators[2].consumer);\n\tcase AD4130_REF_REFIN2:\n\t\treturn regulator_get_voltage(st->regulators[3].consumer);\n\tcase AD4130_REF_AVDD_AVSS:\n\t\treturn regulator_get_voltage(st->regulators[0].consumer);\n\tcase AD4130_REF_REFOUT_AVSS:\n\t\treturn st->int_ref_uv;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad4130_parse_fw_setup(struct ad4130_state *st,\n\t\t\t\t struct fwnode_handle *child,\n\t\t\t\t struct ad4130_setup_info *setup_info)\n{\n\tstruct device *dev = &st->spi->dev;\n\tu32 tmp;\n\tint ret;\n\n\ttmp = 0;\n\tfwnode_property_read_u32(child, \"adi,excitation-current-0-nanoamp\", &tmp);\n\tret = ad4130_find_table_index(ad4130_iout_current_na_tbl, tmp);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Invalid excitation current %unA\\n\", tmp);\n\tsetup_info->iout0_val = ret;\n\n\ttmp = 0;\n\tfwnode_property_read_u32(child, \"adi,excitation-current-1-nanoamp\", &tmp);\n\tret = ad4130_find_table_index(ad4130_iout_current_na_tbl, tmp);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Invalid excitation current %unA\\n\", tmp);\n\tsetup_info->iout1_val = ret;\n\n\ttmp = 0;\n\tfwnode_property_read_u32(child, \"adi,burnout-current-nanoamp\", &tmp);\n\tret = ad4130_find_table_index(ad4130_burnout_current_na_tbl, tmp);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Invalid burnout current %unA\\n\", tmp);\n\tsetup_info->burnout = ret;\n\n\tsetup_info->ref_bufp = fwnode_property_read_bool(child, \"adi,buffered-positive\");\n\tsetup_info->ref_bufm = fwnode_property_read_bool(child, \"adi,buffered-negative\");\n\n\tsetup_info->ref_sel = AD4130_REF_REFIN1;\n\tfwnode_property_read_u32(child, \"adi,reference-select\",\n\t\t\t\t &setup_info->ref_sel);\n\tif (setup_info->ref_sel >= AD4130_REF_SEL_MAX)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid reference selected %u\\n\",\n\t\t\t\t     setup_info->ref_sel);\n\n\tif (setup_info->ref_sel == AD4130_REF_REFOUT_AVSS)\n\t\tst->int_ref_en = true;\n\n\tret = ad4130_get_ref_voltage(st, setup_info->ref_sel);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot use reference %u\\n\",\n\t\t\t\t     setup_info->ref_sel);\n\n\treturn 0;\n}\n\nstatic int ad4130_validate_diff_channel(struct ad4130_state *st, u32 pin)\n{\n\tstruct device *dev = &st->spi->dev;\n\n\tif (pin >= AD4130_MAX_DIFF_INPUTS)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid differential channel %u\\n\", pin);\n\n\tif (pin >= AD4130_MAX_ANALOG_PINS)\n\t\treturn 0;\n\n\tif (st->pins_fn[pin] == AD4130_PIN_FN_SPECIAL)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Pin %u already used with fn %u\\n\", pin,\n\t\t\t\t     st->pins_fn[pin]);\n\n\tst->pins_fn[pin] |= AD4130_PIN_FN_DIFF;\n\n\treturn 0;\n}\n\nstatic int ad4130_validate_diff_channels(struct ad4130_state *st,\n\t\t\t\t\t u32 *pins, unsigned int len)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = ad4130_validate_diff_channel(st, pins[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_validate_excitation_pin(struct ad4130_state *st, u32 pin)\n{\n\tstruct device *dev = &st->spi->dev;\n\n\tif (pin >= AD4130_MAX_ANALOG_PINS)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid excitation pin %u\\n\", pin);\n\n\tif (st->pins_fn[pin] == AD4130_PIN_FN_SPECIAL)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Pin %u already used with fn %u\\n\", pin,\n\t\t\t\t     st->pins_fn[pin]);\n\n\tst->pins_fn[pin] |= AD4130_PIN_FN_EXCITATION;\n\n\treturn 0;\n}\n\nstatic int ad4130_validate_vbias_pin(struct ad4130_state *st, u32 pin)\n{\n\tstruct device *dev = &st->spi->dev;\n\n\tif (pin >= AD4130_MAX_ANALOG_PINS)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Invalid vbias pin %u\\n\",\n\t\t\t\t     pin);\n\n\tif (st->pins_fn[pin] == AD4130_PIN_FN_SPECIAL)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Pin %u already used with fn %u\\n\", pin,\n\t\t\t\t     st->pins_fn[pin]);\n\n\tst->pins_fn[pin] |= AD4130_PIN_FN_VBIAS;\n\n\treturn 0;\n}\n\nstatic int ad4130_validate_vbias_pins(struct ad4130_state *st,\n\t\t\t\t      u32 *pins, unsigned int len)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < st->num_vbias_pins; i++) {\n\t\tret = ad4130_validate_vbias_pin(st, pins[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_parse_fw_channel(struct iio_dev *indio_dev,\n\t\t\t\t   struct fwnode_handle *child)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tunsigned int resolution = ad4130_resolution(st);\n\tunsigned int index = indio_dev->num_channels++;\n\tstruct device *dev = &st->spi->dev;\n\tstruct ad4130_chan_info *chan_info;\n\tstruct iio_chan_spec *chan;\n\tu32 pins[2];\n\tint ret;\n\n\tif (index >= AD4130_MAX_CHANNELS)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Too many channels\\n\");\n\n\tchan = &st->chans[index];\n\tchan_info = &st->chans_info[index];\n\n\t*chan = ad4130_channel_template;\n\tchan->scan_type.realbits = resolution;\n\tchan->scan_type.storagebits = resolution;\n\tchan->scan_index = index;\n\n\tchan_info->slot = AD4130_INVALID_SLOT;\n\tchan_info->setup.fs = AD4130_FILTER_SELECT_MIN;\n\tchan_info->initialized = true;\n\n\tret = fwnode_property_read_u32_array(child, \"diff-channels\", pins,\n\t\t\t\t\t     ARRAY_SIZE(pins));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad4130_validate_diff_channels(st, pins, ARRAY_SIZE(pins));\n\tif (ret)\n\t\treturn ret;\n\n\tchan->channel = pins[0];\n\tchan->channel2 = pins[1];\n\n\tret = ad4130_parse_fw_setup(st, child, &chan_info->setup);\n\tif (ret)\n\t\treturn ret;\n\n\tfwnode_property_read_u32(child, \"adi,excitation-pin-0\",\n\t\t\t\t &chan_info->iout0);\n\tif (chan_info->setup.iout0_val != AD4130_IOUT_OFF) {\n\t\tret = ad4130_validate_excitation_pin(st, chan_info->iout0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfwnode_property_read_u32(child, \"adi,excitation-pin-1\",\n\t\t\t\t &chan_info->iout1);\n\tif (chan_info->setup.iout1_val != AD4130_IOUT_OFF) {\n\t\tret = ad4130_validate_excitation_pin(st, chan_info->iout1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_parse_fw_children(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tstruct fwnode_handle *child;\n\tint ret;\n\n\tindio_dev->channels = st->chans;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tret = ad4130_parse_fw_channel(indio_dev, child);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4310_parse_fw(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tu32 ext_clk_freq = AD4130_MCLK_FREQ_76_8KHZ;\n\tunsigned int i;\n\tint avdd_uv;\n\tint irq;\n\tint ret;\n\n\tst->mclk = devm_clk_get_optional(dev, \"mclk\");\n\tif (IS_ERR(st->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->mclk),\n\t\t\t\t     \"Failed to get mclk\\n\");\n\n\tst->int_pin_sel = AD4130_INT_PIN_INT;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad4130_int_pin_names); i++) {\n\t\tirq = fwnode_irq_get_byname(dev_fwnode(dev),\n\t\t\t\t\t    ad4130_int_pin_names[i]);\n\t\tif (irq > 0) {\n\t\t\tst->int_pin_sel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (st->int_pin_sel == AD4130_INT_PIN_DOUT)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Cannot use DOUT as interrupt pin\\n\");\n\n\tif (st->int_pin_sel == AD4130_INT_PIN_P2)\n\t\tst->pins_fn[AD4130_AIN3_P2] = AD4130_PIN_FN_SPECIAL;\n\n\tdevice_property_read_u32(dev, \"adi,ext-clk-freq-hz\", &ext_clk_freq);\n\tif (ext_clk_freq != AD4130_MCLK_FREQ_153_6KHZ &&\n\t    ext_clk_freq != AD4130_MCLK_FREQ_76_8KHZ)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid external clock frequency %u\\n\",\n\t\t\t\t     ext_clk_freq);\n\n\tif (st->mclk && ext_clk_freq == AD4130_MCLK_FREQ_153_6KHZ)\n\t\tst->mclk_sel = AD4130_MCLK_153_6KHZ_EXT;\n\telse if (st->mclk)\n\t\tst->mclk_sel = AD4130_MCLK_76_8KHZ_EXT;\n\telse\n\t\tst->mclk_sel = AD4130_MCLK_76_8KHZ;\n\n\tif (st->int_pin_sel == AD4130_INT_PIN_CLK &&\n\t    st->mclk_sel != AD4130_MCLK_76_8KHZ)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid clock %u for interrupt pin %u\\n\",\n\t\t\t\t     st->mclk_sel, st->int_pin_sel);\n\n\tst->int_ref_uv = AD4130_INT_REF_2_5V;\n\n\t \n\tavdd_uv = regulator_get_voltage(st->regulators[0].consumer);\n\tif (avdd_uv > 0 && avdd_uv < AD4130_INT_REF_2_5V)\n\t\tst->int_ref_uv = AD4130_INT_REF_1_25V;\n\n\tst->bipolar = device_property_read_bool(dev, \"adi,bipolar\");\n\n\tret = device_property_count_u32(dev, \"adi,vbias-pins\");\n\tif (ret > 0) {\n\t\tif (ret > AD4130_MAX_ANALOG_PINS)\n\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t     \"Too many vbias pins %u\\n\", ret);\n\n\t\tst->num_vbias_pins = ret;\n\n\t\tret = device_property_read_u32_array(dev, \"adi,vbias-pins\",\n\t\t\t\t\t\t     st->vbias_pins,\n\t\t\t\t\t\t     st->num_vbias_pins);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Failed to read vbias pins\\n\");\n\n\t\tret = ad4130_validate_vbias_pins(st, st->vbias_pins,\n\t\t\t\t\t\t st->num_vbias_pins);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad4130_parse_fw_children(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void ad4130_fill_scale_tbls(struct ad4130_state *st)\n{\n\tunsigned int pow = ad4130_resolution(st) - st->bipolar;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < AD4130_REF_SEL_MAX; i++) {\n\t\tint ret;\n\t\tu64 nv;\n\n\t\tret = ad4130_get_ref_voltage(st, i);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tnv = (u64)ret * NANO;\n\n\t\tfor (j = 0; j < AD4130_MAX_PGA; j++)\n\t\t\tst->scale_tbls[i][j][1] = div_u64(nv >> (pow + j), MILLI);\n\t}\n}\n\nstatic void ad4130_clk_disable_unprepare(void *clk)\n{\n\tclk_disable_unprepare(clk);\n}\n\nstatic int ad4130_set_mclk_sel(struct ad4130_state *st,\n\t\t\t       enum ad4130_mclk_sel mclk_sel)\n{\n\treturn regmap_update_bits(st->regmap, AD4130_ADC_CONTROL_REG,\n\t\t\t\t AD4130_ADC_CONTROL_MCLK_SEL_MASK,\n\t\t\t\t FIELD_PREP(AD4130_ADC_CONTROL_MCLK_SEL_MASK,\n\t\t\t\t\t    mclk_sel));\n}\n\nstatic unsigned long ad4130_int_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\treturn AD4130_MCLK_FREQ_76_8KHZ;\n}\n\nstatic int ad4130_int_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct ad4130_state *st = container_of(hw, struct ad4130_state, int_clk_hw);\n\n\treturn st->mclk_sel == AD4130_MCLK_76_8KHZ_OUT;\n}\n\nstatic int ad4130_int_clk_prepare(struct clk_hw *hw)\n{\n\tstruct ad4130_state *st = container_of(hw, struct ad4130_state, int_clk_hw);\n\tint ret;\n\n\tret = ad4130_set_mclk_sel(st, AD4130_MCLK_76_8KHZ_OUT);\n\tif (ret)\n\t\treturn ret;\n\n\tst->mclk_sel = AD4130_MCLK_76_8KHZ_OUT;\n\n\treturn 0;\n}\n\nstatic void ad4130_int_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct ad4130_state *st = container_of(hw, struct ad4130_state, int_clk_hw);\n\tint ret;\n\n\tret = ad4130_set_mclk_sel(st, AD4130_MCLK_76_8KHZ);\n\tif (ret)\n\t\treturn;\n\n\tst->mclk_sel = AD4130_MCLK_76_8KHZ;\n}\n\nstatic const struct clk_ops ad4130_int_clk_ops = {\n\t.recalc_rate = ad4130_int_clk_recalc_rate,\n\t.is_enabled = ad4130_int_clk_is_enabled,\n\t.prepare = ad4130_int_clk_prepare,\n\t.unprepare = ad4130_int_clk_unprepare,\n};\n\nstatic void ad4130_clk_del_provider(void *of_node)\n{\n\tof_clk_del_provider(of_node);\n}\n\nstatic int ad4130_setup_int_clk(struct ad4130_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tstruct device_node *of_node = dev_of_node(dev);\n\tstruct clk_init_data init;\n\tconst char *clk_name;\n\tstruct clk *clk;\n\tint ret;\n\n\tif (st->int_pin_sel == AD4130_INT_PIN_CLK ||\n\t    st->mclk_sel != AD4130_MCLK_76_8KHZ)\n\t\treturn 0;\n\n\tif (!of_node)\n\t\treturn 0;\n\n\tclk_name = of_node->name;\n\tof_property_read_string(of_node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = &ad4130_int_clk_ops;\n\n\tst->int_clk_hw.init = &init;\n\tclk = devm_clk_register(dev, &st->int_clk_hw);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = of_clk_add_provider(of_node, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, ad4130_clk_del_provider, of_node);\n}\n\nstatic int ad4130_setup(struct iio_dev *indio_dev)\n{\n\tstruct ad4130_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tunsigned int int_ref_val;\n\tunsigned long rate = AD4130_MCLK_FREQ_76_8KHZ;\n\tunsigned int val;\n\tunsigned int i;\n\tint ret;\n\n\tif (st->mclk_sel == AD4130_MCLK_153_6KHZ_EXT)\n\t\trate = AD4130_MCLK_FREQ_153_6KHZ;\n\n\tret = clk_set_rate(st->mclk, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(st->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, ad4130_clk_disable_unprepare,\n\t\t\t\t       st->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->int_ref_uv == AD4130_INT_REF_2_5V)\n\t\tint_ref_val = AD4130_INT_REF_VAL_2_5V;\n\telse\n\t\tint_ref_val = AD4130_INT_REF_VAL_1_25V;\n\n\t \n\tval =  FIELD_PREP(AD4130_ADC_CONTROL_CSB_EN_MASK, 1);\n\tval |= FIELD_PREP(AD4130_ADC_CONTROL_BIPOLAR_MASK, st->bipolar);\n\tval |= FIELD_PREP(AD4130_ADC_CONTROL_INT_REF_EN_MASK, st->int_ref_en);\n\tval |= FIELD_PREP(AD4130_ADC_CONTROL_MODE_MASK, AD4130_MODE_IDLE);\n\tval |= FIELD_PREP(AD4130_ADC_CONTROL_MCLK_SEL_MASK, st->mclk_sel);\n\tval |= FIELD_PREP(AD4130_ADC_CONTROL_INT_REF_VAL_MASK, int_ref_val);\n\n\tret = regmap_write(st->regmap, AD4130_ADC_CONTROL_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval =  AD4130_IO_CONTROL_GPIO_CTRL_MASK;\n\tval |= FIELD_PREP(AD4130_IO_CONTROL_INT_PIN_SEL_MASK, st->int_pin_sel);\n\n\tret = regmap_write(st->regmap, AD4130_IO_CONTROL_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = 0;\n\tfor (i = 0; i < st->num_vbias_pins; i++)\n\t\tval |= BIT(st->vbias_pins[i]);\n\n\tret = regmap_write(st->regmap, AD4130_VBIAS_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(st->regmap, AD4130_FIFO_CONTROL_REG,\n\t\t\t\t AD4130_FIFO_CONTROL_HEADER_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad4130_set_watermark_interrupt_en(st, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tstruct ad4130_chan_info *chan_info = &st->chans_info[i];\n\t\tstruct iio_chan_spec *chan = &st->chans[i];\n\t\tunsigned int val;\n\n\t\tval = FIELD_PREP(AD4130_CHANNEL_AINP_MASK, chan->channel) |\n\t\t      FIELD_PREP(AD4130_CHANNEL_AINM_MASK, chan->channel2) |\n\t\t      FIELD_PREP(AD4130_CHANNEL_IOUT1_MASK, chan_info->iout0) |\n\t\t      FIELD_PREP(AD4130_CHANNEL_IOUT2_MASK, chan_info->iout1);\n\n\t\tret = regmap_write(st->regmap, AD4130_CHANNEL_X_REG(i), val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad4130_soft_reset(struct ad4130_state *st)\n{\n\tint ret;\n\n\tret = spi_write(st->spi, st->reset_buf, sizeof(st->reset_buf));\n\tif (ret)\n\t\treturn ret;\n\n\tfsleep(AD4130_RESET_SLEEP_US);\n\n\treturn 0;\n}\n\nstatic void ad4130_disable_regulators(void *data)\n{\n\tstruct ad4130_state *st = data;\n\n\tregulator_bulk_disable(ARRAY_SIZE(st->regulators), st->regulators);\n}\n\nstatic int ad4130_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct ad4130_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tmemset(st->reset_buf, 0xff, sizeof(st->reset_buf));\n\tinit_completion(&st->completion);\n\tmutex_init(&st->lock);\n\tst->spi = spi;\n\n\t \n\tst->fifo_tx_buf[0] = AD4130_COMMS_READ_MASK | AD4130_FIFO_DATA_REG;\n\tst->fifo_xfer[0].tx_buf = st->fifo_tx_buf;\n\tst->fifo_xfer[0].len = sizeof(st->fifo_tx_buf);\n\tst->fifo_xfer[1].rx_buf = st->fifo_rx_buf;\n\tspi_message_init_with_transfers(&st->fifo_msg, st->fifo_xfer,\n\t\t\t\t\tARRAY_SIZE(st->fifo_xfer));\n\n\tindio_dev->name = AD4130_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad4130_info;\n\n\tst->regmap = devm_regmap_init(dev, NULL, st, &ad4130_regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn PTR_ERR(st->regmap);\n\n\tst->regulators[0].supply = \"avdd\";\n\tst->regulators[1].supply = \"iovdd\";\n\tst->regulators[2].supply = \"refin1\";\n\tst->regulators[3].supply = \"refin2\";\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(st->regulators),\n\t\t\t\t      st->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulators\\n\");\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(st->regulators), st->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable regulators\\n\");\n\n\tret = devm_add_action_or_reset(dev, ad4130_disable_regulators, st);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to add regulators disable action\\n\");\n\n\tret = ad4130_soft_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad4310_parse_fw(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad4130_setup(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad4130_setup_int_clk(st);\n\tif (ret)\n\t\treturn ret;\n\n\tad4130_fill_scale_tbls(st);\n\n\tst->gc.owner = THIS_MODULE;\n\tst->gc.label = AD4130_NAME;\n\tst->gc.base = -1;\n\tst->gc.ngpio = AD4130_MAX_GPIOS;\n\tst->gc.parent = dev;\n\tst->gc.can_sleep = true;\n\tst->gc.init_valid_mask = ad4130_gpio_init_valid_mask;\n\tst->gc.get_direction = ad4130_gpio_get_direction;\n\tst->gc.set = ad4130_gpio_set;\n\n\tret = devm_gpiochip_add_data(dev, &st->gc, st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_kfifo_buffer_setup_ext(dev, indio_dev,\n\t\t\t\t\t      &ad4130_buffer_ops,\n\t\t\t\t\t      ad4130_fifo_attributes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(dev, spi->irq, NULL,\n\t\t\t\t\tad4130_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tindio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request irq\\n\");\n\n\t \n\tst->irq_trigger = irq_get_trigger_type(spi->irq);\n\tif (st->irq_trigger & IRQF_TRIGGER_RISING)\n\t\tst->inv_irq_trigger = IRQF_TRIGGER_FALLING;\n\telse if (st->irq_trigger & IRQF_TRIGGER_FALLING)\n\t\tst->inv_irq_trigger = IRQF_TRIGGER_RISING;\n\telse\n\t\treturn dev_err_probe(dev, -EINVAL, \"Invalid irq flags: %u\\n\",\n\t\t\t\t     st->irq_trigger);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id ad4130_of_match[] = {\n\t{\n\t\t.compatible = \"adi,ad4130\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad4130_of_match);\n\nstatic struct spi_driver ad4130_driver = {\n\t.driver = {\n\t\t.name = AD4130_NAME,\n\t\t.of_match_table = ad4130_of_match,\n\t},\n\t.probe = ad4130_probe,\n};\nmodule_spi_driver(ad4130_driver);\n\nMODULE_AUTHOR(\"Cosmin Tanislav <cosmin.tanislav@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD4130 SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}