{
  "module_name": "twl4030-madc.c",
  "hash_id": "9b6ca4ffc26cfaabb196bad238667e156b6278048771fe570d1926543e752445",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/twl4030-madc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mfd/twl.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n#include <linux/types.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n\n#define TWL4030_MADC_MAX_CHANNELS 16\n\n#define TWL4030_MADC_CTRL1\t\t0x00\n#define TWL4030_MADC_CTRL2\t\t0x01\n\n#define TWL4030_MADC_RTSELECT_LSB\t0x02\n#define TWL4030_MADC_SW1SELECT_LSB\t0x06\n#define TWL4030_MADC_SW2SELECT_LSB\t0x0A\n\n#define TWL4030_MADC_RTAVERAGE_LSB\t0x04\n#define TWL4030_MADC_SW1AVERAGE_LSB\t0x08\n#define TWL4030_MADC_SW2AVERAGE_LSB\t0x0C\n\n#define TWL4030_MADC_CTRL_SW1\t\t0x12\n#define TWL4030_MADC_CTRL_SW2\t\t0x13\n\n#define TWL4030_MADC_RTCH0_LSB\t\t0x17\n#define TWL4030_MADC_GPCH0_LSB\t\t0x37\n\n#define TWL4030_MADC_MADCON\t(1 << 0)\t \n#define TWL4030_MADC_BUSY\t(1 << 0)\t \n \n#define TWL4030_MADC_EOC_SW\t(1 << 1)\n \n#define TWL4030_MADC_SW_START\t(1 << 5)\n#define TWL4030_MADC_ADCIN0\t(1 << 0)\n#define TWL4030_MADC_ADCIN1\t(1 << 1)\n#define TWL4030_MADC_ADCIN2\t(1 << 2)\n#define TWL4030_MADC_ADCIN3\t(1 << 3)\n#define TWL4030_MADC_ADCIN4\t(1 << 4)\n#define TWL4030_MADC_ADCIN5\t(1 << 5)\n#define TWL4030_MADC_ADCIN6\t(1 << 6)\n#define TWL4030_MADC_ADCIN7\t(1 << 7)\n#define TWL4030_MADC_ADCIN8\t(1 << 8)\n#define TWL4030_MADC_ADCIN9\t(1 << 9)\n#define TWL4030_MADC_ADCIN10\t(1 << 10)\n#define TWL4030_MADC_ADCIN11\t(1 << 11)\n#define TWL4030_MADC_ADCIN12\t(1 << 12)\n#define TWL4030_MADC_ADCIN13\t(1 << 13)\n#define TWL4030_MADC_ADCIN14\t(1 << 14)\n#define TWL4030_MADC_ADCIN15\t(1 << 15)\n\n \n#define TWL4030_MADC_BTEMP\tTWL4030_MADC_ADCIN1\n#define TWL4030_MADC_VBUS\tTWL4030_MADC_ADCIN8\n#define TWL4030_MADC_VBKB\tTWL4030_MADC_ADCIN9\n#define TWL4030_MADC_ICHG\tTWL4030_MADC_ADCIN10\n#define TWL4030_MADC_VCHG\tTWL4030_MADC_ADCIN11\n#define TWL4030_MADC_VBAT\tTWL4030_MADC_ADCIN12\n\n \n#define TEMP_STEP_SIZE          147\n#define TEMP_PSR_R              100\n#define CURR_STEP_SIZE\t\t147\n#define CURR_PSR_R1\t\t44\n#define CURR_PSR_R2\t\t88\n\n#define TWL4030_BCI_BCICTL1\t0x23\n#define TWL4030_BCI_CGAIN\t0x020\n#define TWL4030_BCI_MESBAT\t(1 << 1)\n#define TWL4030_BCI_TYPEN\t(1 << 4)\n#define TWL4030_BCI_ITHEN\t(1 << 3)\n\n#define REG_BCICTL2             0x024\n#define TWL4030_BCI_ITHSENS\t0x007\n\n \n#define TWL4030_REG_GPBR1\t\t0x0c\n#define TWL4030_GPBR1_MADC_HFCLK_EN\t(1 << 7)\n\n#define TWL4030_USB_SEL_MADC_MCPC\t(1<<3)\n#define TWL4030_USB_CARKIT_ANA_CTRL\t0xBB\n\nstruct twl4030_madc_conversion_method {\n\tu8 sel;\n\tu8 avg;\n\tu8 rbase;\n\tu8 ctrl;\n};\n\n \nstruct twl4030_madc_request {\n\tunsigned long channels;\n\tbool do_avg;\n\tu16 method;\n\tu16 type;\n\tbool active;\n\tbool result_pending;\n\tbool raw;\n\tint rbuf[TWL4030_MADC_MAX_CHANNELS];\n};\n\nenum conversion_methods {\n\tTWL4030_MADC_RT,\n\tTWL4030_MADC_SW1,\n\tTWL4030_MADC_SW2,\n\tTWL4030_MADC_NUM_METHODS\n};\n\nenum sample_type {\n\tTWL4030_MADC_WAIT,\n\tTWL4030_MADC_IRQ_ONESHOT,\n\tTWL4030_MADC_IRQ_REARM\n};\n\n \nstruct twl4030_madc_data {\n\tstruct device *dev;\n\tstruct mutex lock;\n\tstruct regulator *usb3v1;\n\tstruct twl4030_madc_request requests[TWL4030_MADC_NUM_METHODS];\n\tbool use_second_irq;\n\tu8 imr;\n\tu8 isr;\n};\n\nstatic int twl4030_madc_conversion(struct twl4030_madc_request *req);\n\nstatic int twl4030_madc_read(struct iio_dev *iio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct twl4030_madc_data *madc = iio_priv(iio_dev);\n\tstruct twl4030_madc_request req;\n\tint ret;\n\n\treq.method = madc->use_second_irq ? TWL4030_MADC_SW2 : TWL4030_MADC_SW1;\n\n\treq.channels = BIT(chan->channel);\n\treq.active = false;\n\treq.type = TWL4030_MADC_WAIT;\n\treq.raw = !(mask == IIO_CHAN_INFO_PROCESSED);\n\treq.do_avg = (mask == IIO_CHAN_INFO_AVERAGE_RAW);\n\n\tret = twl4030_madc_conversion(&req);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = req.rbuf[chan->channel];\n\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info twl4030_madc_iio_info = {\n\t.read_raw = &twl4030_madc_read,\n};\n\n#define TWL4030_ADC_CHANNEL(_channel, _type, _name) {\t\\\n\t.type = _type,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |  \\\n\t\t\t      BIT(IIO_CHAN_INFO_AVERAGE_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_PROCESSED), \\\n\t.datasheet_name = _name,\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec twl4030_madc_iio_channels[] = {\n\tTWL4030_ADC_CHANNEL(0, IIO_VOLTAGE, \"ADCIN0\"),\n\tTWL4030_ADC_CHANNEL(1, IIO_TEMP, \"ADCIN1\"),\n\tTWL4030_ADC_CHANNEL(2, IIO_VOLTAGE, \"ADCIN2\"),\n\tTWL4030_ADC_CHANNEL(3, IIO_VOLTAGE, \"ADCIN3\"),\n\tTWL4030_ADC_CHANNEL(4, IIO_VOLTAGE, \"ADCIN4\"),\n\tTWL4030_ADC_CHANNEL(5, IIO_VOLTAGE, \"ADCIN5\"),\n\tTWL4030_ADC_CHANNEL(6, IIO_VOLTAGE, \"ADCIN6\"),\n\tTWL4030_ADC_CHANNEL(7, IIO_VOLTAGE, \"ADCIN7\"),\n\tTWL4030_ADC_CHANNEL(8, IIO_VOLTAGE, \"ADCIN8\"),\n\tTWL4030_ADC_CHANNEL(9, IIO_VOLTAGE, \"ADCIN9\"),\n\tTWL4030_ADC_CHANNEL(10, IIO_CURRENT, \"ADCIN10\"),\n\tTWL4030_ADC_CHANNEL(11, IIO_VOLTAGE, \"ADCIN11\"),\n\tTWL4030_ADC_CHANNEL(12, IIO_VOLTAGE, \"ADCIN12\"),\n\tTWL4030_ADC_CHANNEL(13, IIO_VOLTAGE, \"ADCIN13\"),\n\tTWL4030_ADC_CHANNEL(14, IIO_VOLTAGE, \"ADCIN14\"),\n\tTWL4030_ADC_CHANNEL(15, IIO_VOLTAGE, \"ADCIN15\"),\n};\n\nstatic struct twl4030_madc_data *twl4030_madc;\n\nstatic const struct s16_fract twl4030_divider_ratios[16] = {\n\t{1, 1},\t\t \n\t{1, 1},\t\t \n\t{6, 10},\t \n\t{6, 10},\t \n\t{6, 10},\t \n\t{6, 10},\t \n\t{6, 10},\t \n\t{6, 10},\t \n\t{3, 14},\t \n\t{1, 3},\t\t \n\t{1, 1},\t\t \n\t{15, 100},\t \n\t{1, 4},\t\t \n\t{1, 1},\t\t \n\t{1, 1},\t\t \n\t{5, 11},\t \n};\n\n \nstatic int twl4030_therm_tbl[] = {\n\t30800,\t29500,\t28300,\t27100,\n\t26000,\t24900,\t23900,\t22900,\t22000,\t21100,\t20300,\t19400,\t18700,\n\t17900,\t17200,\t16500,\t15900,\t15300,\t14700,\t14100,\t13600,\t13100,\n\t12600,\t12100,\t11600,\t11200,\t10800,\t10400,\t10000,\t9630,\t9280,\n\t8950,\t8620,\t8310,\t8020,\t7730,\t7460,\t7200,\t6950,\t6710,\n\t6470,\t6250,\t6040,\t5830,\t5640,\t5450,\t5260,\t5090,\t4920,\n\t4760,\t4600,\t4450,\t4310,\t4170,\t4040,\t3910,\t3790,\t3670,\n\t3550\n};\n\n \nstatic\nconst struct twl4030_madc_conversion_method twl4030_conversion_methods[] = {\n\t[TWL4030_MADC_RT] = {\n\t\t\t     .sel = TWL4030_MADC_RTSELECT_LSB,\n\t\t\t     .avg = TWL4030_MADC_RTAVERAGE_LSB,\n\t\t\t     .rbase = TWL4030_MADC_RTCH0_LSB,\n\t\t\t     },\n\t[TWL4030_MADC_SW1] = {\n\t\t\t      .sel = TWL4030_MADC_SW1SELECT_LSB,\n\t\t\t      .avg = TWL4030_MADC_SW1AVERAGE_LSB,\n\t\t\t      .rbase = TWL4030_MADC_GPCH0_LSB,\n\t\t\t      .ctrl = TWL4030_MADC_CTRL_SW1,\n\t\t\t      },\n\t[TWL4030_MADC_SW2] = {\n\t\t\t      .sel = TWL4030_MADC_SW2SELECT_LSB,\n\t\t\t      .avg = TWL4030_MADC_SW2AVERAGE_LSB,\n\t\t\t      .rbase = TWL4030_MADC_GPCH0_LSB,\n\t\t\t      .ctrl = TWL4030_MADC_CTRL_SW2,\n\t\t\t      },\n};\n\n \nstatic int twl4030_madc_channel_raw_read(struct twl4030_madc_data *madc, u8 reg)\n{\n\tu16 val;\n\tint ret;\n\t \n\tret = twl_i2c_read_u16(TWL4030_MODULE_MADC, &val, reg);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read register 0x%X\\n\", reg);\n\t\treturn ret;\n\t}\n\n\treturn (int)(val >> 6);\n}\n\n \nstatic int twl4030battery_temperature(int raw_volt)\n{\n\tu8 val;\n\tint temp, curr, volt, res, ret;\n\n\tvolt = (raw_volt * TEMP_STEP_SIZE) / TEMP_PSR_R;\n\t \n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, &val,\n\t\tREG_BCICTL2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcurr = ((val & TWL4030_BCI_ITHSENS) + 1) * 10;\n\t \n\tres = volt * 1000 / curr;\n\t \n\tfor (temp = 58; temp >= 0; temp--) {\n\t\tint actual = twl4030_therm_tbl[temp];\n\t\tif ((actual - res) >= 0)\n\t\t\tbreak;\n\t}\n\n\treturn temp + 1;\n}\n\nstatic int twl4030battery_current(int raw_volt)\n{\n\tint ret;\n\tu8 val;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, &val,\n\t\tTWL4030_BCI_BCICTL1);\n\tif (ret)\n\t\treturn ret;\n\tif (val & TWL4030_BCI_CGAIN)  \n\t\treturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R1;\n\telse  \n\t\treturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R2;\n}\n\n \nstatic int twl4030_madc_read_channels(struct twl4030_madc_data *madc,\n\t\t\t\t      u8 reg_base, unsigned\n\t\t\t\t      long channels, int *buf,\n\t\t\t\t      bool raw)\n{\n\tint count = 0;\n\tint i;\n\tu8 reg;\n\n\tfor_each_set_bit(i, &channels, TWL4030_MADC_MAX_CHANNELS) {\n\t\treg = reg_base + (2 * i);\n\t\tbuf[i] = twl4030_madc_channel_raw_read(madc, reg);\n\t\tif (buf[i] < 0) {\n\t\t\tdev_err(madc->dev, \"Unable to read register 0x%X\\n\",\n\t\t\t\treg);\n\t\t\treturn buf[i];\n\t\t}\n\t\tif (raw) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (i) {\n\t\tcase 10:\n\t\t\tbuf[i] = twl4030battery_current(buf[i]);\n\t\t\tif (buf[i] < 0) {\n\t\t\t\tdev_err(madc->dev, \"err reading current\\n\");\n\t\t\t\treturn buf[i];\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t\tbuf[i] = buf[i] - 750;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbuf[i] = twl4030battery_temperature(buf[i]);\n\t\t\tif (buf[i] < 0) {\n\t\t\t\tdev_err(madc->dev, \"err reading temperature\\n\");\n\t\t\t\treturn buf[i];\n\t\t\t} else {\n\t\t\t\tbuf[i] -= 3;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcount++;\n\t\t\t \n\t\t\tbuf[i] = (buf[i] * 3 * 1000 *\n\t\t\t\t twl4030_divider_ratios[i].denominator)\n\t\t\t\t/ (2 * 1023 *\n\t\t\t\ttwl4030_divider_ratios[i].numerator);\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic int twl4030_madc_disable_irq(struct twl4030_madc_data *madc, u8 id)\n{\n\tu8 val;\n\tint ret;\n\n\tret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &val, madc->imr);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read imr register 0x%X\\n\",\n\t\t\tmadc->imr);\n\t\treturn ret;\n\t}\n\tval |= (1 << id);\n\tret = twl_i2c_write_u8(TWL4030_MODULE_MADC, val, madc->imr);\n\tif (ret) {\n\t\tdev_err(madc->dev,\n\t\t\t\"unable to write imr register 0x%X\\n\", madc->imr);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t twl4030_madc_threaded_irq_handler(int irq, void *_madc)\n{\n\tstruct twl4030_madc_data *madc = _madc;\n\tconst struct twl4030_madc_conversion_method *method;\n\tu8 isr_val, imr_val;\n\tint i, ret;\n\tstruct twl4030_madc_request *r;\n\n\tmutex_lock(&madc->lock);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &isr_val, madc->isr);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read isr register 0x%X\\n\",\n\t\t\tmadc->isr);\n\t\tgoto err_i2c;\n\t}\n\tret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &imr_val, madc->imr);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read imr register 0x%X\\n\",\n\t\t\tmadc->imr);\n\t\tgoto err_i2c;\n\t}\n\tisr_val &= ~imr_val;\n\tfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\n\t\tif (!(isr_val & (1 << i)))\n\t\t\tcontinue;\n\t\tret = twl4030_madc_disable_irq(madc, i);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(madc->dev, \"Disable interrupt failed %d\\n\", i);\n\t\tmadc->requests[i].result_pending = true;\n\t}\n\tfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\n\t\tr = &madc->requests[i];\n\t\t \n\t\tif (!r->result_pending)\n\t\t\tcontinue;\n\t\tmethod = &twl4030_conversion_methods[r->method];\n\t\t \n\t\ttwl4030_madc_read_channels(madc, method->rbase,\n\t\t\t\t\t   r->channels, r->rbuf, r->raw);\n\t\t \n\t\tr->result_pending = false;\n\t\tr->active = false;\n\t}\n\tmutex_unlock(&madc->lock);\n\n\treturn IRQ_HANDLED;\n\nerr_i2c:\n\t \n\tfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\n\t\tr = &madc->requests[i];\n\t\tif (!r->active)\n\t\t\tcontinue;\n\t\tmethod = &twl4030_conversion_methods[r->method];\n\t\t \n\t\ttwl4030_madc_read_channels(madc, method->rbase,\n\t\t\t\t\t   r->channels, r->rbuf, r->raw);\n\t\t \n\t\tr->result_pending = false;\n\t\tr->active = false;\n\t}\n\tmutex_unlock(&madc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int twl4030_madc_start_conversion(struct twl4030_madc_data *madc,\n\t\t\t\t\t int conv_method)\n{\n\tconst struct twl4030_madc_conversion_method *method;\n\tint ret = 0;\n\n\tif (conv_method != TWL4030_MADC_SW1 && conv_method != TWL4030_MADC_SW2)\n\t\treturn -ENOTSUPP;\n\n\tmethod = &twl4030_conversion_methods[conv_method];\n\tret = twl_i2c_write_u8(TWL4030_MODULE_MADC, TWL4030_MADC_SW_START,\n\t\t\t       method->ctrl);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to write ctrl register 0x%X\\n\",\n\t\t\tmethod->ctrl);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int twl4030_madc_wait_conversion_ready(struct twl4030_madc_data *madc,\n\t\t\t\t\t      unsigned int timeout_ms,\n\t\t\t\t\t      u8 status_reg)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout_ms);\n\tdo {\n\t\tu8 reg;\n\n\t\tret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &reg, status_reg);\n\t\tif (ret) {\n\t\t\tdev_err(madc->dev,\n\t\t\t\t\"unable to read status register 0x%X\\n\",\n\t\t\t\tstatus_reg);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(reg & TWL4030_MADC_BUSY) && (reg & TWL4030_MADC_EOC_SW))\n\t\t\treturn 0;\n\t\tusleep_range(500, 2000);\n\t} while (!time_after(jiffies, timeout));\n\tdev_err(madc->dev, \"conversion timeout!\\n\");\n\n\treturn -EAGAIN;\n}\n\n \nstatic int twl4030_madc_conversion(struct twl4030_madc_request *req)\n{\n\tconst struct twl4030_madc_conversion_method *method;\n\tint ret;\n\n\tif (!req || !twl4030_madc)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&twl4030_madc->lock);\n\tif (req->method < TWL4030_MADC_RT || req->method > TWL4030_MADC_SW2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tif (twl4030_madc->requests[req->method].active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tmethod = &twl4030_conversion_methods[req->method];\n\t \n\tret = twl_i2c_write_u16(TWL4030_MODULE_MADC, req->channels, method->sel);\n\tif (ret) {\n\t\tdev_err(twl4030_madc->dev,\n\t\t\t\"unable to write sel register 0x%X\\n\", method->sel);\n\t\tgoto out;\n\t}\n\t \n\tif (req->do_avg) {\n\t\tret = twl_i2c_write_u16(TWL4030_MODULE_MADC, req->channels,\n\t\t\t\t       method->avg);\n\t\tif (ret) {\n\t\t\tdev_err(twl4030_madc->dev,\n\t\t\t\t\"unable to write avg register 0x%X\\n\",\n\t\t\t\tmethod->avg);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tif (req->method == TWL4030_MADC_RT) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = twl4030_madc_start_conversion(twl4030_madc, req->method);\n\tif (ret < 0)\n\t\tgoto out;\n\ttwl4030_madc->requests[req->method].active = true;\n\t \n\tret = twl4030_madc_wait_conversion_ready(twl4030_madc, 5, method->ctrl);\n\tif (ret) {\n\t\ttwl4030_madc->requests[req->method].active = false;\n\t\tgoto out;\n\t}\n\tret = twl4030_madc_read_channels(twl4030_madc, method->rbase,\n\t\t\t\t\t req->channels, req->rbuf, req->raw);\n\ttwl4030_madc->requests[req->method].active = false;\n\nout:\n\tmutex_unlock(&twl4030_madc->lock);\n\n\treturn ret;\n}\n\n \nstatic int twl4030_madc_set_current_generator(struct twl4030_madc_data *madc,\n\t\t\t\t\t      int chan, int on)\n{\n\tint ret;\n\tint regmask;\n\tu8 regval;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t      &regval, TWL4030_BCI_BCICTL1);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read BCICTL1 reg 0x%X\",\n\t\t\tTWL4030_BCI_BCICTL1);\n\t\treturn ret;\n\t}\n\n\tregmask = chan ? TWL4030_BCI_ITHEN : TWL4030_BCI_TYPEN;\n\tif (on)\n\t\tregval |= regmask;\n\telse\n\t\tregval &= ~regmask;\n\n\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t       regval, TWL4030_BCI_BCICTL1);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to write BCICTL1 reg 0x%X\\n\",\n\t\t\tTWL4030_BCI_BCICTL1);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int twl4030_madc_set_power(struct twl4030_madc_data *madc, int on)\n{\n\tu8 regval;\n\tint ret;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t      &regval, TWL4030_MADC_CTRL1);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to read madc ctrl1 reg 0x%X\\n\",\n\t\t\tTWL4030_MADC_CTRL1);\n\t\treturn ret;\n\t}\n\tif (on)\n\t\tregval |= TWL4030_MADC_MADCON;\n\telse\n\t\tregval &= ~TWL4030_MADC_MADCON;\n\tret = twl_i2c_write_u8(TWL4030_MODULE_MADC, regval, TWL4030_MADC_CTRL1);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"unable to write madc ctrl1 reg 0x%X\\n\",\n\t\t\tTWL4030_MADC_CTRL1);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int twl4030_madc_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_madc_data *madc;\n\tstruct twl4030_madc_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tint irq, ret;\n\tu8 regval;\n\tstruct iio_dev *iio_dev = NULL;\n\n\tif (!pdata && !np) {\n\t\tdev_err(&pdev->dev, \"neither platform data nor Device Tree node available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*madc));\n\tif (!iio_dev) {\n\t\tdev_err(&pdev->dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmadc = iio_priv(iio_dev);\n\tmadc->dev = &pdev->dev;\n\n\tiio_dev->name = dev_name(&pdev->dev);\n\tiio_dev->info = &twl4030_madc_iio_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->channels = twl4030_madc_iio_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(twl4030_madc_iio_channels);\n\n\t \n\tif (pdata)\n\t\tmadc->use_second_irq = (pdata->irq_line != 1);\n\telse\n\t\tmadc->use_second_irq = of_property_read_bool(np,\n\t\t\t\t       \"ti,system-uses-second-madc-irq\");\n\n\tmadc->imr = madc->use_second_irq ? TWL4030_MADC_IMR2 :\n\t\t\t\t\t   TWL4030_MADC_IMR1;\n\tmadc->isr = madc->use_second_irq ? TWL4030_MADC_ISR2 :\n\t\t\t\t\t   TWL4030_MADC_ISR1;\n\n\tret = twl4030_madc_set_power(madc, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = twl4030_madc_set_current_generator(madc, 0, 1);\n\tif (ret < 0)\n\t\tgoto err_current_generator;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t      &regval, TWL4030_BCI_BCICTL1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to read reg BCI CTL1 0x%X\\n\",\n\t\t\tTWL4030_BCI_BCICTL1);\n\t\tgoto err_i2c;\n\t}\n\tregval |= TWL4030_BCI_MESBAT;\n\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t       regval, TWL4030_BCI_BCICTL1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to write reg BCI Ctl1 0x%X\\n\",\n\t\t\tTWL4030_BCI_BCICTL1);\n\t\tgoto err_i2c;\n\t}\n\n\t \n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &regval, TWL4030_REG_GPBR1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to read reg GPBR1 0x%X\\n\",\n\t\t\t\tTWL4030_REG_GPBR1);\n\t\tgoto err_i2c;\n\t}\n\n\t \n\tif (!(regval & TWL4030_GPBR1_MADC_HFCLK_EN)) {\n\t\tdev_info(&pdev->dev, \"clk disabled, enabling\\n\");\n\t\tregval |= TWL4030_GPBR1_MADC_HFCLK_EN;\n\t\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, regval,\n\t\t\t\t       TWL4030_REG_GPBR1);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"unable to write reg GPBR1 0x%X\\n\",\n\t\t\t\t\tTWL4030_REG_GPBR1);\n\t\t\tgoto err_i2c;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, iio_dev);\n\tmutex_init(&madc->lock);\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t   twl4030_madc_threaded_irq_handler,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t   \"twl4030_madc\", madc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not request irq\\n\");\n\t\tgoto err_i2c;\n\t}\n\ttwl4030_madc = madc;\n\n\t \n\tret = twl_i2c_read_u8(TWL_MODULE_USB, &regval,\n\t\t\tTWL4030_USB_CARKIT_ANA_CTRL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to read reg CARKIT_ANA_CTRL  0x%X\\n\",\n\t\t\t\tTWL4030_USB_CARKIT_ANA_CTRL);\n\t\tgoto err_i2c;\n\t}\n\tregval |= TWL4030_USB_SEL_MADC_MCPC;\n\tret = twl_i2c_write_u8(TWL_MODULE_USB, regval,\n\t\t\t\t TWL4030_USB_CARKIT_ANA_CTRL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to write reg CARKIT_ANA_CTRL 0x%X\\n\",\n\t\t\t\tTWL4030_USB_CARKIT_ANA_CTRL);\n\t\tgoto err_i2c;\n\t}\n\n\t \n\tmadc->usb3v1 = devm_regulator_get(madc->dev, \"vusb3v1\");\n\tif (IS_ERR(madc->usb3v1)) {\n\t\tret = -ENODEV;\n\t\tgoto err_i2c;\n\t}\n\n\tret = regulator_enable(madc->usb3v1);\n\tif (ret) {\n\t\tdev_err(madc->dev, \"could not enable 3v1 bias regulator\\n\");\n\t\tgoto err_i2c;\n\t}\n\n\tret = iio_device_register(iio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register iio device\\n\");\n\t\tgoto err_usb3v1;\n\t}\n\n\treturn 0;\n\nerr_usb3v1:\n\tregulator_disable(madc->usb3v1);\nerr_i2c:\n\ttwl4030_madc_set_current_generator(madc, 0, 0);\nerr_current_generator:\n\ttwl4030_madc_set_power(madc, 0);\n\treturn ret;\n}\n\nstatic int twl4030_madc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *iio_dev = platform_get_drvdata(pdev);\n\tstruct twl4030_madc_data *madc = iio_priv(iio_dev);\n\n\tiio_device_unregister(iio_dev);\n\n\ttwl4030_madc_set_current_generator(madc, 0, 0);\n\ttwl4030_madc_set_power(madc, 0);\n\n\tregulator_disable(madc->usb3v1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id twl_madc_of_match[] = {\n\t{ .compatible = \"ti,twl4030-madc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl_madc_of_match);\n#endif\n\nstatic struct platform_driver twl4030_madc_driver = {\n\t.probe = twl4030_madc_probe,\n\t.remove = twl4030_madc_remove,\n\t.driver = {\n\t\t   .name = \"twl4030_madc\",\n\t\t   .of_match_table = of_match_ptr(twl_madc_of_match),\n\t},\n};\n\nmodule_platform_driver(twl4030_madc_driver);\n\nMODULE_DESCRIPTION(\"TWL4030 ADC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"J Keerthy\");\nMODULE_ALIAS(\"platform:twl4030_madc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}