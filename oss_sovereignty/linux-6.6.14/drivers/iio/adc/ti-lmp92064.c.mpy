{
  "module_name": "ti-lmp92064.c",
  "hash_id": "a2b81448e2fff49018c5e74f3518e8a15fdcd05af657675d327b7f93199aa933",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-lmp92064.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define TI_LMP92064_REG_CONFIG_A 0x0000\n#define TI_LMP92064_REG_CONFIG_B 0x0001\n#define TI_LMP92064_REG_CHIP_REV 0x0006\n\n#define TI_LMP92064_REG_MFR_ID1 0x000C\n#define TI_LMP92064_REG_MFR_ID2 0x000D\n\n#define TI_LMP92064_REG_REG_UPDATE 0x000F\n#define TI_LMP92064_REG_CONFIG_REG 0x0100\n#define TI_LMP92064_REG_STATUS 0x0103\n\n#define TI_LMP92064_REG_DATA_VOUT_LSB 0x0200\n#define TI_LMP92064_REG_DATA_VOUT_MSB 0x0201\n#define TI_LMP92064_REG_DATA_COUT_LSB 0x0202\n#define TI_LMP92064_REG_DATA_COUT_MSB 0x0203\n\n#define TI_LMP92064_VAL_CONFIG_A 0x99\n#define TI_LMP92064_VAL_CONFIG_B 0x00\n#define TI_LMP92064_VAL_STATUS_OK 0x01\n\n \n#define TI_LMP92064_CHAN_INC 0\n#define TI_LMP92064_CHAN_INV 1\n\nstatic const struct regmap_range lmp92064_readable_reg_ranges[] = {\n\tregmap_reg_range(TI_LMP92064_REG_CONFIG_A, TI_LMP92064_REG_CHIP_REV),\n\tregmap_reg_range(TI_LMP92064_REG_MFR_ID1, TI_LMP92064_REG_MFR_ID2),\n\tregmap_reg_range(TI_LMP92064_REG_REG_UPDATE, TI_LMP92064_REG_REG_UPDATE),\n\tregmap_reg_range(TI_LMP92064_REG_CONFIG_REG, TI_LMP92064_REG_CONFIG_REG),\n\tregmap_reg_range(TI_LMP92064_REG_STATUS, TI_LMP92064_REG_STATUS),\n\tregmap_reg_range(TI_LMP92064_REG_DATA_VOUT_LSB, TI_LMP92064_REG_DATA_COUT_MSB),\n};\n\nstatic const struct regmap_access_table lmp92064_readable_regs = {\n\t.yes_ranges = lmp92064_readable_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(lmp92064_readable_reg_ranges),\n};\n\nstatic const struct regmap_range lmp92064_writable_reg_ranges[] = {\n\tregmap_reg_range(TI_LMP92064_REG_CONFIG_A, TI_LMP92064_REG_CONFIG_B),\n\tregmap_reg_range(TI_LMP92064_REG_REG_UPDATE, TI_LMP92064_REG_REG_UPDATE),\n\tregmap_reg_range(TI_LMP92064_REG_CONFIG_REG, TI_LMP92064_REG_CONFIG_REG),\n};\n\nstatic const struct regmap_access_table lmp92064_writable_regs = {\n\t.yes_ranges = lmp92064_writable_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(lmp92064_writable_reg_ranges),\n};\n\nstatic const struct regmap_config lmp92064_spi_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = TI_LMP92064_REG_DATA_COUT_MSB,\n\t.rd_table = &lmp92064_readable_regs,\n\t.wr_table = &lmp92064_writable_regs,\n};\n\nstruct lmp92064_adc_priv {\n\tint shunt_resistor_uohm;\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n};\n\nstatic const struct iio_chan_spec lmp92064_adc_channels[] = {\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.address = TI_LMP92064_CHAN_INC,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = TI_LMP92064_CHAN_INC,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t\t.datasheet_name = \"INC\",\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.address = TI_LMP92064_CHAN_INV,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = TI_LMP92064_CHAN_INV,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t\t.datasheet_name = \"INV\",\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic const unsigned long lmp92064_scan_masks[] = {\n\tBIT(TI_LMP92064_CHAN_INC) | BIT(TI_LMP92064_CHAN_INV),\n\t0\n};\n\nstatic int lmp92064_read_meas(struct lmp92064_adc_priv *priv, u16 *res)\n{\n\t__be16 raw[2];\n\tint ret;\n\n\t \n\n\tret = regmap_bulk_read(priv->regmap, TI_LMP92064_REG_DATA_COUT_MSB,\n\t\t\t &raw, sizeof(raw));\n\n\tif (ret) {\n\t\tdev_err(&priv->spi->dev, \"regmap_bulk_read failed: %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tres[0] = be16_to_cpu(raw[0]);\n\tres[1] = be16_to_cpu(raw[1]);\n\n\treturn 0;\n}\n\nstatic int lmp92064_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct lmp92064_adc_priv *priv = iio_priv(indio_dev);\n\tu16 raw[2];\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = lmp92064_read_meas(priv, raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = (chan->address == TI_LMP92064_CHAN_INC) ? raw[0] : raw[1];\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->address == TI_LMP92064_CHAN_INC) {\n\t\t\t \n\t\t\t*val = 20000;\n\t\t\t*val2 = priv->shunt_resistor_uohm;\n\t\t} else {\n\t\t\t \n\t\t\t*val = 2048;\n\t\t\t*val2 = 4096;\n\t\t}\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t lmp92064_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct lmp92064_adc_priv *priv = iio_priv(indio_dev);\n\tstruct {\n\t\tu16 values[2];\n\t\tint64_t timestamp __aligned(8);\n\t} data;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tret = lmp92064_read_meas(priv, data.values);\n\tif (ret)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lmp92064_reset(struct lmp92064_adc_priv *priv,\n\t\t\t  struct gpio_desc *gpio_reset)\n{\n\tunsigned int status;\n\tint ret, i;\n\n\tif (gpio_reset) {\n\t\t \n\t\tgpiod_set_value_cansleep(gpio_reset, 1);\n\t\tusleep_range(1, 10);\n\t\tgpiod_set_value_cansleep(gpio_reset, 0);\n\t\tusleep_range(500, 750);\n\t} else {\n\t\t \n\t\tret = regmap_write(priv->regmap, TI_LMP92064_REG_CONFIG_A,\n\t\t\t\t   TI_LMP92064_VAL_CONFIG_A);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(priv->regmap, TI_LMP92064_REG_CONFIG_B,\n\t\t\t\t   TI_LMP92064_VAL_CONFIG_B);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = regmap_read(priv->regmap, TI_LMP92064_REG_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (status == TI_LMP92064_VAL_STATUS_OK)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\treturn -ENXIO;\n}\n\nstatic const struct iio_info lmp92064_adc_info = {\n\t.read_raw = lmp92064_read_raw,\n};\n\nstatic int lmp92064_adc_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct lmp92064_adc_priv *priv;\n\tstruct gpio_desc *gpio_reset;\n\tstruct iio_dev *indio_dev;\n\tu32 shunt_resistor_uohm;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Error in SPI setup\\n\");\n\n\tregmap = devm_regmap_init_spi(spi, &lmp92064_spi_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to set up SPI regmap\\n\");\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\n\tpriv->spi = spi;\n\tpriv->regmap = regmap;\n\n\tret = device_property_read_u32(dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t       &shunt_resistor_uohm);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get shunt-resistor value\\n\");\n\n\t \n\tif (shunt_resistor_uohm == 0 || shunt_resistor_uohm > INT_MAX) {\n\t\tdev_err(dev, \"Shunt resistance is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->shunt_resistor_uohm = shunt_resistor_uohm;\n\n\tret = devm_regulator_get_enable(dev, \"vdd\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_regulator_get_enable(dev, \"vdig\");\n\tif (ret)\n\t\treturn ret;\n\n\tgpio_reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio_reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio_reset),\n\t\t\t\t     \"Failed to get GPIO reset pin\\n\");\n\n\tret = lmp92064_reset(priv, gpio_reset);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to reset device\\n\");\n\n\tindio_dev->name = \"lmp92064\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = lmp92064_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lmp92064_adc_channels);\n\tindio_dev->info = &lmp92064_adc_info;\n\tindio_dev->available_scan_masks = lmp92064_scan_masks;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      lmp92064_trigger_handler, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to setup buffered read\\n\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct spi_device_id lmp92064_id_table[] = {\n\t{ \"lmp92064\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, lmp92064_id_table);\n\nstatic const struct of_device_id lmp92064_of_table[] = {\n\t{ .compatible = \"ti,lmp92064\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lmp92064_of_table);\n\nstatic struct spi_driver lmp92064_adc_driver = {\n\t.driver = {\n\t\t.name = \"lmp92064\",\n\t\t.of_match_table = lmp92064_of_table,\n\t},\n\t.probe = lmp92064_adc_probe,\n\t.id_table = lmp92064_id_table,\n};\nmodule_spi_driver(lmp92064_adc_driver);\n\nMODULE_AUTHOR(\"Leonard G\u00f6hrs <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"TI LMP92064 ADC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}