{
  "module_name": "ad7923.c",
  "hash_id": "6e96a2817ca427debb3ee8ef4c96110272c565ac492ba5b3ce69adb64d866bfc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7923.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define AD7923_WRITE_CR\t\tBIT(11)\t\t \n#define AD7923_RANGE\t\tBIT(1)\t\t \n#define AD7923_CODING\t\tBIT(0)\t\t \n#define AD7923_PM_MODE_AS\t(1)\t\t \n#define AD7923_PM_MODE_FS\t(2)\t\t \n#define AD7923_PM_MODE_OPS\t(3)\t\t \n#define AD7923_SEQUENCE_OFF\t(0)\t\t \n#define AD7923_SEQUENCE_PROTECT\t(2)\t\t \n#define AD7923_SEQUENCE_ON\t(3)\t\t \n\n\n#define AD7923_PM_MODE_WRITE(mode)\t((mode) << 4)\t  \n#define AD7923_CHANNEL_WRITE(channel)\t((channel) << 6)  \n#define AD7923_SEQUENCE_WRITE(sequence)\t((((sequence) & 1) << 3) \\\n\t\t\t\t\t+ (((sequence) & 2) << 9))\n\t\t\t\t\t\t \n \n#define AD7923_SHIFT_REGISTER\t4\n\n \n#define EXTRACT(val, dec, bits)\t\t(((val) >> (dec)) & ((1 << (bits)) - 1))\n\nstruct ad7923_state {\n\tstruct spi_device\t\t*spi;\n\tstruct spi_transfer\t\tring_xfer[5];\n\tstruct spi_transfer\t\tscan_single_xfer[2];\n\tstruct spi_message\t\tring_msg;\n\tstruct spi_message\t\tscan_single_msg;\n\n\tstruct regulator\t\t*reg;\n\n\tunsigned int\t\t\tsettings;\n\n\t \n\t__be16\t\t\t\trx_buf[12] __aligned(IIO_DMA_MINALIGN);\n\t__be16\t\t\t\ttx_buf[4];\n};\n\nstruct ad7923_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nenum ad7923_id {\n\tAD7904,\n\tAD7914,\n\tAD7924,\n\tAD7908,\n\tAD7918,\n\tAD7928\n};\n\n#define AD7923_V_CHAN(index, bits)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = index,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = (bits),\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.shift = 12 - (bits),\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define DECLARE_AD7923_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tAD7923_V_CHAN(0, bits), \\\n\tAD7923_V_CHAN(1, bits), \\\n\tAD7923_V_CHAN(2, bits), \\\n\tAD7923_V_CHAN(3, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(4), \\\n}\n\n#define DECLARE_AD7908_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tAD7923_V_CHAN(0, bits), \\\n\tAD7923_V_CHAN(1, bits), \\\n\tAD7923_V_CHAN(2, bits), \\\n\tAD7923_V_CHAN(3, bits), \\\n\tAD7923_V_CHAN(4, bits), \\\n\tAD7923_V_CHAN(5, bits), \\\n\tAD7923_V_CHAN(6, bits), \\\n\tAD7923_V_CHAN(7, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(8), \\\n}\n\nstatic DECLARE_AD7923_CHANNELS(ad7904, 8);\nstatic DECLARE_AD7923_CHANNELS(ad7914, 10);\nstatic DECLARE_AD7923_CHANNELS(ad7924, 12);\nstatic DECLARE_AD7908_CHANNELS(ad7908, 8);\nstatic DECLARE_AD7908_CHANNELS(ad7918, 10);\nstatic DECLARE_AD7908_CHANNELS(ad7928, 12);\n\nstatic const struct ad7923_chip_info ad7923_chip_info[] = {\n\t[AD7904] = {\n\t\t.channels = ad7904_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7904_channels),\n\t},\n\t[AD7914] = {\n\t\t.channels = ad7914_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7914_channels),\n\t},\n\t[AD7924] = {\n\t\t.channels = ad7924_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7924_channels),\n\t},\n\t[AD7908] = {\n\t\t.channels = ad7908_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7908_channels),\n\t},\n\t[AD7918] = {\n\t\t.channels = ad7918_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7918_channels),\n\t},\n\t[AD7928] = {\n\t\t.channels = ad7928_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7928_channels),\n\t},\n};\n\n \nstatic int ad7923_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t   const unsigned long *active_scan_mask)\n{\n\tstruct ad7923_state *st = iio_priv(indio_dev);\n\tint i, cmd, len;\n\n\tlen = 0;\n\t \n\tfor_each_set_bit(i, active_scan_mask, indio_dev->num_channels - 1) {\n\t\tcmd = AD7923_WRITE_CR | AD7923_CHANNEL_WRITE(i) |\n\t\t\tAD7923_SEQUENCE_WRITE(AD7923_SEQUENCE_OFF) |\n\t\t\tst->settings;\n\t\tcmd <<= AD7923_SHIFT_REGISTER;\n\t\tst->tx_buf[len++] = cpu_to_be16(cmd);\n\t}\n\t \n\tst->ring_xfer[0].tx_buf = &st->tx_buf[0];\n\tst->ring_xfer[0].len = len;\n\tst->ring_xfer[0].cs_change = 1;\n\n\tspi_message_init(&st->ring_msg);\n\tspi_message_add_tail(&st->ring_xfer[0], &st->ring_msg);\n\n\tfor (i = 0; i < len; i++) {\n\t\tst->ring_xfer[i + 1].rx_buf = &st->rx_buf[i];\n\t\tst->ring_xfer[i + 1].len = 2;\n\t\tst->ring_xfer[i + 1].cs_change = 1;\n\t\tspi_message_add_tail(&st->ring_xfer[i + 1], &st->ring_msg);\n\t}\n\t \n\tst->ring_xfer[i + 1].cs_change = 0;\n\n\treturn 0;\n}\n\nstatic irqreturn_t ad7923_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7923_state *st = iio_priv(indio_dev);\n\tint b_sent;\n\n\tb_sent = spi_sync(st->spi, &st->ring_msg);\n\tif (b_sent)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->rx_buf,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad7923_scan_direct(struct ad7923_state *st, unsigned int ch)\n{\n\tint ret, cmd;\n\n\tcmd = AD7923_WRITE_CR | AD7923_CHANNEL_WRITE(ch) |\n\t\tAD7923_SEQUENCE_WRITE(AD7923_SEQUENCE_OFF) |\n\t\tst->settings;\n\tcmd <<= AD7923_SHIFT_REGISTER;\n\tst->tx_buf[0] = cpu_to_be16(cmd);\n\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->rx_buf[0]);\n}\n\nstatic int ad7923_get_range(struct ad7923_state *st)\n{\n\tint vref;\n\n\tvref = regulator_get_voltage(st->reg);\n\tif (vref < 0)\n\t\treturn vref;\n\n\tvref /= 1000;\n\n\tif (!(st->settings & AD7923_RANGE))\n\t\tvref *= 2;\n\n\treturn vref;\n}\n\nstatic int ad7923_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tint ret;\n\tstruct ad7923_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ad7923_scan_direct(st, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (chan->address == EXTRACT(ret, 12, 4))\n\t\t\t*val = EXTRACT(ret, chan->scan_type.shift,\n\t\t\t\t       chan->scan_type.realbits);\n\t\telse\n\t\t\treturn -EIO;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ad7923_get_range(st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad7923_info = {\n\t.read_raw = &ad7923_read_raw,\n\t.update_scan_mode = ad7923_update_scan_mode,\n};\n\nstatic void ad7923_regulator_disable(void *data)\n{\n\tstruct ad7923_state *st = data;\n\n\tregulator_disable(st->reg);\n}\n\nstatic int ad7923_probe(struct spi_device *spi)\n{\n\tu32 ad7923_range = AD7923_RANGE;\n\tstruct ad7923_state *st;\n\tstruct iio_dev *indio_dev;\n\tconst struct ad7923_chip_info *info;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tif (device_property_read_bool(&spi->dev, \"adi,range-double\"))\n\t\tad7923_range = 0;\n\n\tst->spi = spi;\n\tst->settings = AD7923_CODING | ad7923_range |\n\t\t\tAD7923_PM_MODE_WRITE(AD7923_PM_MODE_OPS);\n\n\tinfo = &ad7923_chip_info[spi_get_device_id(spi)->driver_data];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = info->channels;\n\tindio_dev->num_channels = info->num_channels;\n\tindio_dev->info = &ad7923_info;\n\n\t \n\n\tst->scan_single_xfer[0].tx_buf = &st->tx_buf[0];\n\tst->scan_single_xfer[0].len = 2;\n\tst->scan_single_xfer[0].cs_change = 1;\n\tst->scan_single_xfer[1].rx_buf = &st->rx_buf[0];\n\tst->scan_single_xfer[1].len = 2;\n\n\tspi_message_init(&st->scan_single_msg);\n\tspi_message_add_tail(&st->scan_single_xfer[0], &st->scan_single_msg);\n\tspi_message_add_tail(&st->scan_single_xfer[1], &st->scan_single_msg);\n\n\tst->reg = devm_regulator_get(&spi->dev, \"refin\");\n\tif (IS_ERR(st->reg))\n\t\treturn PTR_ERR(st->reg);\n\n\tret = regulator_enable(st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7923_regulator_disable, st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      &ad7923_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7923_id[] = {\n\t{\"ad7904\", AD7904},\n\t{\"ad7914\", AD7914},\n\t{\"ad7923\", AD7924},\n\t{\"ad7924\", AD7924},\n\t{\"ad7908\", AD7908},\n\t{\"ad7918\", AD7918},\n\t{\"ad7928\", AD7928},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7923_id);\n\nstatic const struct of_device_id ad7923_of_match[] = {\n\t{ .compatible = \"adi,ad7904\", },\n\t{ .compatible = \"adi,ad7914\", },\n\t{ .compatible = \"adi,ad7923\", },\n\t{ .compatible = \"adi,ad7924\", },\n\t{ .compatible = \"adi,ad7908\", },\n\t{ .compatible = \"adi,ad7918\", },\n\t{ .compatible = \"adi,ad7928\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7923_of_match);\n\nstatic struct spi_driver ad7923_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7923\",\n\t\t.of_match_table = ad7923_of_match,\n\t},\n\t.probe\t\t= ad7923_probe,\n\t.id_table\t= ad7923_id,\n};\nmodule_spi_driver(ad7923_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_AUTHOR(\"Patrick Vasseur <patrick.vasseur@c-s.fr>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7923 and similar ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}