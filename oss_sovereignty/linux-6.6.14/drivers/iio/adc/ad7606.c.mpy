{
  "module_name": "ad7606.c",
  "hash_id": "b3dccf8a1e7bf1dc0188d1f3a4cac3e5289662ec18e6c2b5ebf796e603d8ebaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7606.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/util_macros.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include \"ad7606.h\"\n\n \nstatic const unsigned int ad7606_scale_avail[2] = {\n\t152588, 305176\n};\n\n\nstatic const unsigned int ad7616_sw_scale_avail[3] = {\n\t76293, 152588, 305176\n};\n\nstatic const unsigned int ad7606_oversampling_avail[7] = {\n\t1, 2, 4, 8, 16, 32, 64,\n};\n\nstatic const unsigned int ad7616_oversampling_avail[8] = {\n\t1, 2, 4, 8, 16, 32, 64, 128,\n};\n\nstatic int ad7606_reset(struct ad7606_state *st)\n{\n\tif (st->gpio_reset) {\n\t\tgpiod_set_value(st->gpio_reset, 1);\n\t\tndelay(100);  \n\t\tgpiod_set_value(st->gpio_reset, 0);\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int ad7606_reg_access(struct iio_dev *indio_dev,\n\t\t\t     unsigned int reg,\n\t\t\t     unsigned int writeval,\n\t\t\t     unsigned int *readval)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tif (readval) {\n\t\tret = st->bops->reg_read(st, reg);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t\t*readval = ret;\n\t\tret = 0;\n\t} else {\n\t\tret = st->bops->reg_write(st, reg, writeval);\n\t}\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int ad7606_read_samples(struct ad7606_state *st)\n{\n\tunsigned int num = st->chip_info->num_channels - 1;\n\tu16 *data = st->data;\n\tint ret;\n\n\t \n\n\tif (st->gpio_frstdata) {\n\t\tret = st->bops->read_block(st->dev, 1, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!gpiod_get_value(st->gpio_frstdata)) {\n\t\t\tad7606_reset(st);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdata++;\n\t\tnum--;\n\t}\n\n\treturn st->bops->read_block(st->dev, num, data);\n}\n\nstatic irqreturn_t ad7606_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = ad7606_read_samples(st);\n\tif (ret == 0)\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, st->data,\n\t\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\t \n\tgpiod_set_value(st->gpio_convst, 1);\n\n\tmutex_unlock(&st->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned int ch)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tgpiod_set_value(st->gpio_convst, 1);\n\tret = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error_ret;\n\t}\n\n\tret = ad7606_read_samples(st);\n\tif (ret == 0)\n\t\tret = st->data[ch];\n\nerror_ret:\n\tgpiod_set_value(st->gpio_convst, 0);\n\n\treturn ret;\n}\n\nstatic int ad7606_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tint ret, ch = 0;\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ad7606_scan_direct(indio_dev, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (short)ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->sw_mode_en)\n\t\t\tch = chan->address;\n\t\t*val = 0;\n\t\t*val2 = st->scale_avail[st->range[ch]];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = st->oversampling;\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t ad7606_show_avail(char *buf, const unsigned int *vals,\n\t\t\t\t unsigned int n, bool micros)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\tmicros ? \"0.%06u \" : \"%u \", vals[i]);\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t in_voltage_scale_available_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\treturn ad7606_show_avail(buf, st->scale_avail, st->num_scales, true);\n}\n\nstatic IIO_DEVICE_ATTR_RO(in_voltage_scale_available, 0);\n\nstatic int ad7606_write_scale_hw(struct iio_dev *indio_dev, int ch, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tgpiod_set_value(st->gpio_range, val);\n\n\treturn 0;\n}\n\nstatic int ad7606_write_os_hw(struct iio_dev *indio_dev, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tDECLARE_BITMAP(values, 3);\n\n\tvalues[0] = val;\n\n\tgpiod_set_array_value(ARRAY_SIZE(values), st->gpio_os->desc,\n\t\t\t      st->gpio_os->info, values);\n\n\t \n\tif (st->chip_info->os_req_reset)\n\t\tad7606_reset(st);\n\n\treturn 0;\n}\n\nstatic int ad7606_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tint i, ret, ch = 0;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmutex_lock(&st->lock);\n\t\ti = find_closest(val2, st->scale_avail, st->num_scales);\n\t\tif (st->sw_mode_en)\n\t\t\tch = chan->address;\n\t\tret = st->write_scale(indio_dev, ch, i);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tst->range[ch] = i;\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\t\ti = find_closest(val, st->oversampling_avail,\n\t\t\t\t st->num_os_ratios);\n\t\tmutex_lock(&st->lock);\n\t\tret = st->write_os(indio_dev, i);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tst->oversampling = st->oversampling_avail[i];\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ad7606_oversampling_ratio_avail(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\treturn ad7606_show_avail(buf, st->oversampling_avail,\n\t\t\t\t st->num_os_ratios, false);\n}\n\nstatic IIO_DEVICE_ATTR(oversampling_ratio_available, 0444,\n\t\t       ad7606_oversampling_ratio_avail, NULL, 0);\n\nstatic struct attribute *ad7606_attributes_os_and_range[] = {\n\t&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,\n\t&iio_dev_attr_oversampling_ratio_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7606_attribute_group_os_and_range = {\n\t.attrs = ad7606_attributes_os_and_range,\n};\n\nstatic struct attribute *ad7606_attributes_os[] = {\n\t&iio_dev_attr_oversampling_ratio_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7606_attribute_group_os = {\n\t.attrs = ad7606_attributes_os,\n};\n\nstatic struct attribute *ad7606_attributes_range[] = {\n\t&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7606_attribute_group_range = {\n\t.attrs = ad7606_attributes_range,\n};\n\nstatic const struct iio_chan_spec ad7605_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n\tAD7605_CHANNEL(0),\n\tAD7605_CHANNEL(1),\n\tAD7605_CHANNEL(2),\n\tAD7605_CHANNEL(3),\n};\n\nstatic const struct iio_chan_spec ad7606_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n\tAD7606_CHANNEL(0),\n\tAD7606_CHANNEL(1),\n\tAD7606_CHANNEL(2),\n\tAD7606_CHANNEL(3),\n\tAD7606_CHANNEL(4),\n\tAD7606_CHANNEL(5),\n\tAD7606_CHANNEL(6),\n\tAD7606_CHANNEL(7),\n};\n\n \nstatic const struct iio_chan_spec ad7616_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(16),\n\tAD7606_CHANNEL(0),\n\tAD7606_CHANNEL(1),\n\tAD7606_CHANNEL(2),\n\tAD7606_CHANNEL(3),\n\tAD7606_CHANNEL(4),\n\tAD7606_CHANNEL(5),\n\tAD7606_CHANNEL(6),\n\tAD7606_CHANNEL(7),\n\tAD7606_CHANNEL(8),\n\tAD7606_CHANNEL(9),\n\tAD7606_CHANNEL(10),\n\tAD7606_CHANNEL(11),\n\tAD7606_CHANNEL(12),\n\tAD7606_CHANNEL(13),\n\tAD7606_CHANNEL(14),\n\tAD7606_CHANNEL(15),\n};\n\nstatic const struct ad7606_chip_info ad7606_chip_info_tbl[] = {\n\t \n\t[ID_AD7605_4] = {\n\t\t.channels = ad7605_channels,\n\t\t.num_channels = 5,\n\t},\n\t[ID_AD7606_8] = {\n\t\t.channels = ad7606_channels,\n\t\t.num_channels = 9,\n\t\t.oversampling_avail = ad7606_oversampling_avail,\n\t\t.oversampling_num = ARRAY_SIZE(ad7606_oversampling_avail),\n\t},\n\t[ID_AD7606_6] = {\n\t\t.channels = ad7606_channels,\n\t\t.num_channels = 7,\n\t\t.oversampling_avail = ad7606_oversampling_avail,\n\t\t.oversampling_num = ARRAY_SIZE(ad7606_oversampling_avail),\n\t},\n\t[ID_AD7606_4] = {\n\t\t.channels = ad7606_channels,\n\t\t.num_channels = 5,\n\t\t.oversampling_avail = ad7606_oversampling_avail,\n\t\t.oversampling_num = ARRAY_SIZE(ad7606_oversampling_avail),\n\t},\n\t[ID_AD7606B] = {\n\t\t.channels = ad7606_channels,\n\t\t.num_channels = 9,\n\t\t.oversampling_avail = ad7606_oversampling_avail,\n\t\t.oversampling_num = ARRAY_SIZE(ad7606_oversampling_avail),\n\t},\n\t[ID_AD7616] = {\n\t\t.channels = ad7616_channels,\n\t\t.num_channels = 17,\n\t\t.oversampling_avail = ad7616_oversampling_avail,\n\t\t.oversampling_num = ARRAY_SIZE(ad7616_oversampling_avail),\n\t\t.os_req_reset = true,\n\t\t.init_delay_ms = 15,\n\t},\n};\n\nstatic int ad7606_request_gpios(struct ad7606_state *st)\n{\n\tstruct device *dev = st->dev;\n\n\tst->gpio_convst = devm_gpiod_get(dev, \"adi,conversion-start\",\n\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpio_convst))\n\t\treturn PTR_ERR(st->gpio_convst);\n\n\tst->gpio_reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpio_reset))\n\t\treturn PTR_ERR(st->gpio_reset);\n\n\tst->gpio_range = devm_gpiod_get_optional(dev, \"adi,range\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpio_range))\n\t\treturn PTR_ERR(st->gpio_range);\n\n\tst->gpio_standby = devm_gpiod_get_optional(dev, \"standby\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(st->gpio_standby))\n\t\treturn PTR_ERR(st->gpio_standby);\n\n\tst->gpio_frstdata = devm_gpiod_get_optional(dev, \"adi,first-data\",\n\t\t\t\t\t\t    GPIOD_IN);\n\tif (IS_ERR(st->gpio_frstdata))\n\t\treturn PTR_ERR(st->gpio_frstdata);\n\n\tif (!st->chip_info->oversampling_num)\n\t\treturn 0;\n\n\tst->gpio_os = devm_gpiod_get_array_optional(dev,\n\t\t\t\t\t\t    \"adi,oversampling-ratio\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\treturn PTR_ERR_OR_ZERO(st->gpio_os);\n}\n\n \nstatic irqreturn_t ad7606_interrupt(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\tgpiod_set_value(st->gpio_convst, 0);\n\t\tiio_trigger_poll_nested(st->trig);\n\t} else {\n\t\tcomplete(&st->completion);\n\t}\n\n\treturn IRQ_HANDLED;\n};\n\nstatic int ad7606_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_trigger *trig)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tif (st->trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ad7606_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tgpiod_set_value(st->gpio_convst, 1);\n\n\treturn 0;\n}\n\nstatic int ad7606_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tgpiod_set_value(st->gpio_convst, 0);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops ad7606_buffer_ops = {\n\t.postenable = &ad7606_buffer_postenable,\n\t.predisable = &ad7606_buffer_predisable,\n};\n\nstatic const struct iio_info ad7606_info_no_os_or_range = {\n\t.read_raw = &ad7606_read_raw,\n\t.validate_trigger = &ad7606_validate_trigger,\n};\n\nstatic const struct iio_info ad7606_info_os_and_range = {\n\t.read_raw = &ad7606_read_raw,\n\t.write_raw = &ad7606_write_raw,\n\t.attrs = &ad7606_attribute_group_os_and_range,\n\t.validate_trigger = &ad7606_validate_trigger,\n};\n\nstatic const struct iio_info ad7606_info_os_range_and_debug = {\n\t.read_raw = &ad7606_read_raw,\n\t.write_raw = &ad7606_write_raw,\n\t.debugfs_reg_access = &ad7606_reg_access,\n\t.attrs = &ad7606_attribute_group_os_and_range,\n\t.validate_trigger = &ad7606_validate_trigger,\n};\n\nstatic const struct iio_info ad7606_info_os = {\n\t.read_raw = &ad7606_read_raw,\n\t.write_raw = &ad7606_write_raw,\n\t.attrs = &ad7606_attribute_group_os,\n\t.validate_trigger = &ad7606_validate_trigger,\n};\n\nstatic const struct iio_info ad7606_info_range = {\n\t.read_raw = &ad7606_read_raw,\n\t.write_raw = &ad7606_write_raw,\n\t.attrs = &ad7606_attribute_group_range,\n\t.validate_trigger = &ad7606_validate_trigger,\n};\n\nstatic const struct iio_trigger_ops ad7606_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nint ad7606_probe(struct device *dev, int irq, void __iomem *base_address,\n\t\t const char *name, unsigned int id,\n\t\t const struct ad7606_bus_ops *bops)\n{\n\tstruct ad7606_state *st;\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\n\tst->dev = dev;\n\tmutex_init(&st->lock);\n\tst->bops = bops;\n\tst->base_address = base_address;\n\t \n\tst->range[0] = 0;\n\tst->oversampling = 1;\n\tst->scale_avail = ad7606_scale_avail;\n\tst->num_scales = ARRAY_SIZE(ad7606_scale_avail);\n\n\tret = devm_regulator_get_enable(dev, \"avcc\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable specified AVcc supply\\n\");\n\n\tst->chip_info = &ad7606_chip_info_tbl[id];\n\n\tif (st->chip_info->oversampling_num) {\n\t\tst->oversampling_avail = st->chip_info->oversampling_avail;\n\t\tst->num_os_ratios = st->chip_info->oversampling_num;\n\t}\n\n\tret = ad7606_request_gpios(st);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->gpio_os) {\n\t\tif (st->gpio_range)\n\t\t\tindio_dev->info = &ad7606_info_os_and_range;\n\t\telse\n\t\t\tindio_dev->info = &ad7606_info_os;\n\t} else {\n\t\tif (st->gpio_range)\n\t\t\tindio_dev->info = &ad7606_info_range;\n\t\telse\n\t\t\tindio_dev->info = &ad7606_info_no_os_or_range;\n\t}\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = name;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\n\tinit_completion(&st->completion);\n\n\tret = ad7606_reset(st);\n\tif (ret)\n\t\tdev_warn(st->dev, \"failed to RESET: no RESET GPIO specified\\n\");\n\n\t \n\tif (st->chip_info->init_delay_ms) {\n\t\tif (msleep_interruptible(st->chip_info->init_delay_ms))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tst->write_scale = ad7606_write_scale_hw;\n\tst->write_os = ad7606_write_os_hw;\n\n\tif (st->bops->sw_mode_config)\n\t\tst->sw_mode_en = device_property_present(st->dev,\n\t\t\t\t\t\t\t \"adi,sw-mode\");\n\n\tif (st->sw_mode_en) {\n\t\t \n\t\tst->scale_avail = ad7616_sw_scale_avail;\n\t\tst->num_scales = ARRAY_SIZE(ad7616_sw_scale_avail);\n\n\t\t \n\t\tmemset32(st->range, 2, ARRAY_SIZE(st->range));\n\t\tindio_dev->info = &ad7606_info_os_range_and_debug;\n\n\t\tret = st->bops->sw_mode_config(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tst->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t  indio_dev->name,\n\t\t\t\t\t  iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tst->trig->ops = &ad7606_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, indio_dev);\n\tret = devm_iio_trigger_register(dev, st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\tret = devm_request_threaded_irq(dev, irq,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&ad7606_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tname, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &ad7606_trigger_handler,\n\t\t\t\t\t      &ad7606_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(ad7606_probe, IIO_AD7606);\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int ad7606_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tif (st->gpio_standby) {\n\t\tgpiod_set_value(st->gpio_range, 1);\n\t\tgpiod_set_value(st->gpio_standby, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7606_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\tif (st->gpio_standby) {\n\t\tgpiod_set_value(st->gpio_range, st->range[0]);\n\t\tgpiod_set_value(st->gpio_standby, 1);\n\t\tad7606_reset(st);\n\t}\n\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(ad7606_pm_ops, ad7606_suspend, ad7606_resume);\nEXPORT_SYMBOL_NS_GPL(ad7606_pm_ops, IIO_AD7606);\n\n#endif\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7606 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}