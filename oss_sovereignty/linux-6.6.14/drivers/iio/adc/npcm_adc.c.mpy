{
  "module_name": "npcm_adc.c",
  "hash_id": "fee10df0a2b5ae942b05516a62897023f4394bcfc89ded3535f9843d11b8da3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/npcm_adc.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/io.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/reset.h>\n\nstruct npcm_adc_info {\n\tu32 data_mask;\n\tu32 internal_vref;\n\tu32 res_bits;\n};\n\nstruct npcm_adc {\n\tbool int_status;\n\tu32 adc_sample_hz;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *adc_clk;\n\twait_queue_head_t wq;\n\tstruct regulator *vref;\n\tstruct reset_control *reset;\n\t \n\tstruct mutex lock;\n\tconst struct npcm_adc_info *data;\n};\n\n \n#define NPCM_ADCCON\t 0x00\n#define NPCM_ADCDATA\t 0x04\n\n \n#define NPCM_ADCCON_ADC_INT_EN\t\tBIT(21)\n#define NPCM_ADCCON_REFSEL\t\tBIT(19)\n#define NPCM_ADCCON_ADC_INT_ST\t\tBIT(18)\n#define NPCM_ADCCON_ADC_EN\t\tBIT(17)\n#define NPCM_ADCCON_ADC_RST\t\tBIT(16)\n#define NPCM_ADCCON_ADC_CONV\t\tBIT(13)\n\n#define NPCM_ADCCON_CH_MASK\t\tGENMASK(27, 24)\n#define NPCM_ADCCON_CH(x)\t\t((x) << 24)\n#define NPCM_ADCCON_DIV_SHIFT\t\t1\n#define NPCM_ADCCON_DIV_MASK\t\tGENMASK(8, 1)\n\n#define NPCM_ADC_ENABLE\t\t(NPCM_ADCCON_ADC_EN | NPCM_ADCCON_ADC_INT_EN)\n\n \nstatic const struct npcm_adc_info npxm7xx_adc_info = {\n\t.data_mask = GENMASK(9, 0),\n\t.internal_vref = 2048,\n\t.res_bits = 10,\n};\n\nstatic const struct npcm_adc_info npxm8xx_adc_info = {\n\t.data_mask = GENMASK(11, 0),\n\t.internal_vref = 1229,\n\t.res_bits = 12,\n};\n\n#define NPCM_ADC_CHAN(ch) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = ch,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n}\n\nstatic const struct iio_chan_spec npcm_adc_iio_channels[] = {\n\tNPCM_ADC_CHAN(0),\n\tNPCM_ADC_CHAN(1),\n\tNPCM_ADC_CHAN(2),\n\tNPCM_ADC_CHAN(3),\n\tNPCM_ADC_CHAN(4),\n\tNPCM_ADC_CHAN(5),\n\tNPCM_ADC_CHAN(6),\n\tNPCM_ADC_CHAN(7),\n};\n\nstatic irqreturn_t npcm_adc_isr(int irq, void *data)\n{\n\tu32 regtemp;\n\tstruct iio_dev *indio_dev = data;\n\tstruct npcm_adc *info = iio_priv(indio_dev);\n\n\tregtemp = ioread32(info->regs + NPCM_ADCCON);\n\tif (regtemp & NPCM_ADCCON_ADC_INT_ST) {\n\t\tiowrite32(regtemp, info->regs + NPCM_ADCCON);\n\t\twake_up_interruptible(&info->wq);\n\t\tinfo->int_status = true;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int npcm_adc_read(struct npcm_adc *info, int *val, u8 channel)\n{\n\tint ret;\n\tu32 regtemp;\n\n\t \n\tregtemp = ioread32(info->regs + NPCM_ADCCON);\n\tregtemp &= ~NPCM_ADCCON_CH_MASK;\n\tinfo->int_status = false;\n\tiowrite32(regtemp | NPCM_ADCCON_CH(channel) |\n\t\t  NPCM_ADCCON_ADC_CONV, info->regs + NPCM_ADCCON);\n\n\tret = wait_event_interruptible_timeout(info->wq, info->int_status,\n\t\t\t\t\t       msecs_to_jiffies(10));\n\tif (ret == 0) {\n\t\tregtemp = ioread32(info->regs + NPCM_ADCCON);\n\t\tif (regtemp & NPCM_ADCCON_ADC_CONV) {\n\t\t\t \n\t\t\treset_control_assert(info->reset);\n\t\t\tmsleep(100);\n\t\t\treset_control_deassert(info->reset);\n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\tiowrite32(NPCM_ADC_ENABLE | NPCM_ADCCON_ADC_CONV,\n\t\t\t\t  info->regs + NPCM_ADCCON);\n\t\t\tdev_err(info->dev, \"RESET ADC Complete\\n\");\n\t\t}\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ioread32(info->regs + NPCM_ADCDATA);\n\t*val &= info->data->data_mask;\n\n\treturn 0;\n}\n\nstatic int npcm_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tint ret;\n\tint vref_uv;\n\tstruct npcm_adc *info = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&info->lock);\n\t\tret = npcm_adc_read(info, val, chan->channel);\n\t\tmutex_unlock(&info->lock);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev, \"NPCM ADC read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (!IS_ERR(info->vref)) {\n\t\t\tvref_uv = regulator_get_voltage(info->vref);\n\t\t\t*val = vref_uv / 1000;\n\t\t} else {\n\t\t\t*val = info->data->internal_vref;\n\t\t}\n\t\t*val2 = info->data->res_bits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = info->adc_sample_hz;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info npcm_adc_iio_info = {\n\t.read_raw = &npcm_adc_read_raw,\n};\n\nstatic const struct of_device_id npcm_adc_match[] = {\n\t{ .compatible = \"nuvoton,npcm750-adc\", .data = &npxm7xx_adc_info},\n\t{ .compatible = \"nuvoton,npcm845-adc\", .data = &npxm8xx_adc_info},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, npcm_adc_match);\n\nstatic int npcm_adc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint irq;\n\tu32 div;\n\tu32 reg_con;\n\tstruct npcm_adc *info;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tinfo = iio_priv(indio_dev);\n\n\tinfo->data = device_get_match_data(dev);\n\tif (!info->data)\n\t\treturn -EINVAL;\n\n\tmutex_init(&info->lock);\n\n\tinfo->dev = &pdev->dev;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tinfo->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(info->reset))\n\t\treturn PTR_ERR(info->reset);\n\n\tinfo->adc_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(info->adc_clk)) {\n\t\tdev_warn(&pdev->dev, \"ADC clock failed: can't read clk\\n\");\n\t\treturn PTR_ERR(info->adc_clk);\n\t}\n\n\t \n\treg_con = ioread32(info->regs + NPCM_ADCCON);\n\tdiv = reg_con & NPCM_ADCCON_DIV_MASK;\n\tdiv = div >> NPCM_ADCCON_DIV_SHIFT;\n\tinfo->adc_sample_hz = clk_get_rate(info->adc_clk) / ((div + 1) * 2);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, npcm_adc_isr, 0,\n\t\t\t       \"NPCM_ADC\", indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed requesting interrupt\\n\");\n\t\tgoto err_disable_clk;\n\t}\n\n\treg_con = ioread32(info->regs + NPCM_ADCCON);\n\tinfo->vref = devm_regulator_get_optional(&pdev->dev, \"vref\");\n\tif (!IS_ERR(info->vref)) {\n\t\tret = regulator_enable(info->vref);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't enable ADC reference voltage\\n\");\n\t\t\tgoto err_disable_clk;\n\t\t}\n\n\t\tiowrite32(reg_con & ~NPCM_ADCCON_REFSEL,\n\t\t\t  info->regs + NPCM_ADCCON);\n\t} else {\n\t\t \n\t\tif (PTR_ERR(info->vref) != -ENODEV) {\n\t\t\tret = PTR_ERR(info->vref);\n\t\t\tgoto err_disable_clk;\n\t\t}\n\n\t\t \n\t\tiowrite32(reg_con | NPCM_ADCCON_REFSEL,\n\t\t\t  info->regs + NPCM_ADCCON);\n\t}\n\n\tinit_waitqueue_head(&info->wq);\n\n\treg_con = ioread32(info->regs + NPCM_ADCCON);\n\treg_con |= NPCM_ADC_ENABLE;\n\n\t \n\tiowrite32(reg_con, info->regs + NPCM_ADCCON);\n\n\t \n\tiowrite32(reg_con | NPCM_ADCCON_ADC_CONV, info->regs + NPCM_ADCCON);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &npcm_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = npcm_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(npcm_adc_iio_channels);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register the device.\\n\");\n\t\tgoto err_iio_register;\n\t}\n\n\tpr_info(\"NPCM ADC driver probed\\n\");\n\n\treturn 0;\n\nerr_iio_register:\n\tiowrite32(reg_con & ~NPCM_ADCCON_ADC_EN, info->regs + NPCM_ADCCON);\n\tif (!IS_ERR(info->vref))\n\t\tregulator_disable(info->vref);\nerr_disable_clk:\n\tclk_disable_unprepare(info->adc_clk);\n\n\treturn ret;\n}\n\nstatic int npcm_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct npcm_adc *info = iio_priv(indio_dev);\n\tu32 regtemp;\n\n\tiio_device_unregister(indio_dev);\n\n\tregtemp = ioread32(info->regs + NPCM_ADCCON);\n\tiowrite32(regtemp & ~NPCM_ADCCON_ADC_EN, info->regs + NPCM_ADCCON);\n\tif (!IS_ERR(info->vref))\n\t\tregulator_disable(info->vref);\n\tclk_disable_unprepare(info->adc_clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver npcm_adc_driver = {\n\t.probe\t\t= npcm_adc_probe,\n\t.remove\t\t= npcm_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"npcm_adc\",\n\t\t.of_match_table = npcm_adc_match,\n\t},\n};\n\nmodule_platform_driver(npcm_adc_driver);\n\nMODULE_DESCRIPTION(\"Nuvoton NPCM ADC Driver\");\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}