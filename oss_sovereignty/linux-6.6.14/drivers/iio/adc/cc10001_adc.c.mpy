{
  "module_name": "cc10001_adc.c",
  "hash_id": "add8f02d91983c160317c9169ce7471e131dbe6437770e638cec4909e936abc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/cc10001_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define CC10001_ADC_CONFIG\t\t0x00\n#define CC10001_ADC_START_CONV\t\tBIT(4)\n#define CC10001_ADC_MODE_SINGLE_CONV\tBIT(5)\n\n#define CC10001_ADC_DDATA_OUT\t\t0x04\n#define CC10001_ADC_EOC\t\t\t0x08\n#define CC10001_ADC_EOC_SET\t\tBIT(0)\n\n#define CC10001_ADC_CHSEL_SAMPLED\t0x0c\n#define CC10001_ADC_POWER_DOWN\t\t0x10\n#define CC10001_ADC_POWER_DOWN_SET\tBIT(0)\n\n#define CC10001_ADC_DEBUG\t\t0x14\n#define CC10001_ADC_DATA_COUNT\t\t0x20\n\n#define CC10001_ADC_DATA_MASK\t\tGENMASK(9, 0)\n#define CC10001_ADC_NUM_CHANNELS\t8\n#define CC10001_ADC_CH_MASK\t\tGENMASK(2, 0)\n\n#define CC10001_INVALID_SAMPLED\t\t0xffff\n#define CC10001_MAX_POLL_COUNT\t\t20\n\n \n#define\tCC10001_WAIT_CYCLES\t\t8\n\nstruct cc10001_adc_device {\n\tvoid __iomem *reg_base;\n\tstruct clk *adc_clk;\n\tstruct regulator *reg;\n\tu16 *buf;\n\n\tbool shared;\n\tstruct mutex lock;\n\tunsigned int start_delay_ns;\n\tunsigned int eoc_delay_ns;\n};\n\nstatic inline void cc10001_adc_write_reg(struct cc10001_adc_device *adc_dev,\n\t\t\t\t\t u32 reg, u32 val)\n{\n\twritel(val, adc_dev->reg_base + reg);\n}\n\nstatic inline u32 cc10001_adc_read_reg(struct cc10001_adc_device *adc_dev,\n\t\t\t\t       u32 reg)\n{\n\treturn readl(adc_dev->reg_base + reg);\n}\n\nstatic void cc10001_adc_power_up(struct cc10001_adc_device *adc_dev)\n{\n\tcc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN, 0);\n\tndelay(adc_dev->start_delay_ns);\n}\n\nstatic void cc10001_adc_power_down(struct cc10001_adc_device *adc_dev)\n{\n\tcc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN,\n\t\t\t      CC10001_ADC_POWER_DOWN_SET);\n}\n\nstatic void cc10001_adc_start(struct cc10001_adc_device *adc_dev,\n\t\t\t      unsigned int channel)\n{\n\tu32 val;\n\n\t \n\tval = (channel & CC10001_ADC_CH_MASK) | CC10001_ADC_MODE_SINGLE_CONV;\n\tcc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);\n\n\tudelay(1);\n\tval = cc10001_adc_read_reg(adc_dev, CC10001_ADC_CONFIG);\n\tval = val | CC10001_ADC_START_CONV;\n\tcc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);\n}\n\nstatic u16 cc10001_adc_poll_done(struct iio_dev *indio_dev,\n\t\t\t\t unsigned int channel,\n\t\t\t\t unsigned int delay)\n{\n\tstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int poll_count = 0;\n\n\twhile (!(cc10001_adc_read_reg(adc_dev, CC10001_ADC_EOC) &\n\t\t\tCC10001_ADC_EOC_SET)) {\n\n\t\tndelay(delay);\n\t\tif (poll_count++ == CC10001_MAX_POLL_COUNT)\n\t\t\treturn CC10001_INVALID_SAMPLED;\n\t}\n\n\tpoll_count = 0;\n\twhile ((cc10001_adc_read_reg(adc_dev, CC10001_ADC_CHSEL_SAMPLED) &\n\t\t\tCC10001_ADC_CH_MASK) != channel) {\n\n\t\tndelay(delay);\n\t\tif (poll_count++ == CC10001_MAX_POLL_COUNT)\n\t\t\treturn CC10001_INVALID_SAMPLED;\n\t}\n\n\t \n\treturn cc10001_adc_read_reg(adc_dev, CC10001_ADC_DDATA_OUT) &\n\t\t\t       CC10001_ADC_DATA_MASK;\n}\n\nstatic irqreturn_t cc10001_adc_trigger_h(int irq, void *p)\n{\n\tstruct cc10001_adc_device *adc_dev;\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev;\n\tunsigned int delay_ns;\n\tunsigned int channel;\n\tunsigned int scan_idx;\n\tbool sample_invalid;\n\tu16 *data;\n\tint i;\n\n\tindio_dev = pf->indio_dev;\n\tadc_dev = iio_priv(indio_dev);\n\tdata = adc_dev->buf;\n\n\tmutex_lock(&adc_dev->lock);\n\n\tif (!adc_dev->shared)\n\t\tcc10001_adc_power_up(adc_dev);\n\n\t \n\tdelay_ns = adc_dev->eoc_delay_ns / CC10001_MAX_POLL_COUNT;\n\n\ti = 0;\n\tsample_invalid = false;\n\tfor_each_set_bit(scan_idx, indio_dev->active_scan_mask,\n\t\t\t\t  indio_dev->masklength) {\n\n\t\tchannel = indio_dev->channels[scan_idx].channel;\n\t\tcc10001_adc_start(adc_dev, channel);\n\n\t\tdata[i] = cc10001_adc_poll_done(indio_dev, channel, delay_ns);\n\t\tif (data[i] == CC10001_INVALID_SAMPLED) {\n\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t \"invalid sample on channel %d\\n\", channel);\n\t\t\tsample_invalid = true;\n\t\t\tgoto done;\n\t\t}\n\t\ti++;\n\t}\n\ndone:\n\tif (!adc_dev->shared)\n\t\tcc10001_adc_power_down(adc_dev);\n\n\tmutex_unlock(&adc_dev->lock);\n\n\tif (!sample_invalid)\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, data,\n\t\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u16 cc10001_adc_read_raw_voltage(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan)\n{\n\tstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int delay_ns;\n\tu16 val;\n\n\tif (!adc_dev->shared)\n\t\tcc10001_adc_power_up(adc_dev);\n\n\t \n\tdelay_ns = adc_dev->eoc_delay_ns / CC10001_MAX_POLL_COUNT;\n\n\tcc10001_adc_start(adc_dev, chan->channel);\n\n\tval = cc10001_adc_poll_done(indio_dev, chan->channel, delay_ns);\n\n\tif (!adc_dev->shared)\n\t\tcc10001_adc_power_down(adc_dev);\n\n\treturn val;\n}\n\nstatic int cc10001_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\t\tmutex_lock(&adc_dev->lock);\n\t\t*val = cc10001_adc_read_raw_voltage(indio_dev, chan);\n\t\tmutex_unlock(&adc_dev->lock);\n\n\t\tif (*val == CC10001_INVALID_SAMPLED)\n\t\t\treturn -EIO;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(adc_dev->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cc10001_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t    const unsigned long *scan_mask)\n{\n\tstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\n\n\tkfree(adc_dev->buf);\n\tadc_dev->buf = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\n\tif (!adc_dev->buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct iio_info cc10001_adc_info = {\n\t.read_raw = &cc10001_adc_read_raw,\n\t.update_scan_mode = &cc10001_update_scan_mode,\n};\n\nstatic int cc10001_adc_channel_init(struct iio_dev *indio_dev,\n\t\t\t\t    unsigned long channel_map)\n{\n\tstruct iio_chan_spec *chan_array, *timestamp;\n\tunsigned int bit, idx = 0;\n\n\tindio_dev->num_channels = bitmap_weight(&channel_map,\n\t\t\t\t\t\tCC10001_ADC_NUM_CHANNELS) + 1;\n\n\tchan_array = devm_kcalloc(&indio_dev->dev, indio_dev->num_channels,\n\t\t\t\t  sizeof(struct iio_chan_spec),\n\t\t\t\t  GFP_KERNEL);\n\tif (!chan_array)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(bit, &channel_map, CC10001_ADC_NUM_CHANNELS) {\n\t\tstruct iio_chan_spec *chan = &chan_array[idx];\n\n\t\tchan->type = IIO_VOLTAGE;\n\t\tchan->indexed = 1;\n\t\tchan->channel = bit;\n\t\tchan->scan_index = idx;\n\t\tchan->scan_type.sign = 'u';\n\t\tchan->scan_type.realbits = 10;\n\t\tchan->scan_type.storagebits = 16;\n\t\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tidx++;\n\t}\n\n\ttimestamp = &chan_array[idx];\n\ttimestamp->type = IIO_TIMESTAMP;\n\ttimestamp->channel = -1;\n\ttimestamp->scan_index = idx;\n\ttimestamp->scan_type.sign = 's';\n\ttimestamp->scan_type.realbits = 64;\n\ttimestamp->scan_type.storagebits = 64;\n\n\tindio_dev->channels = chan_array;\n\n\treturn 0;\n}\n\nstatic void cc10001_reg_disable(void *priv)\n{\n\tregulator_disable(priv);\n}\n\nstatic void cc10001_pd_cb(void *priv)\n{\n\tcc10001_adc_power_down(priv);\n}\n\nstatic int cc10001_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct cc10001_adc_device *adc_dev;\n\tunsigned long adc_clk_rate;\n\tstruct iio_dev *indio_dev;\n\tunsigned long channel_map;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc_dev));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tadc_dev = iio_priv(indio_dev);\n\n\tchannel_map = GENMASK(CC10001_ADC_NUM_CHANNELS - 1, 0);\n\tif (!of_property_read_u32(node, \"adc-reserved-channels\", &ret)) {\n\t\tadc_dev->shared = true;\n\t\tchannel_map &= ~ret;\n\t}\n\n\tadc_dev->reg = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(adc_dev->reg))\n\t\treturn PTR_ERR(adc_dev->reg);\n\n\tret = regulator_enable(adc_dev->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, cc10001_reg_disable, adc_dev->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &cc10001_adc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tadc_dev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc_dev->reg_base))\n\t\treturn PTR_ERR(adc_dev->reg_base);\n\n\tadc_dev->adc_clk = devm_clk_get_enabled(dev, \"adc\");\n\tif (IS_ERR(adc_dev->adc_clk)) {\n\t\tdev_err(dev, \"failed to get/enable the clock\\n\");\n\t\treturn PTR_ERR(adc_dev->adc_clk);\n\t}\n\n\tadc_clk_rate = clk_get_rate(adc_dev->adc_clk);\n\tif (!adc_clk_rate) {\n\t\tdev_err(dev, \"null clock rate!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadc_dev->eoc_delay_ns = NSEC_PER_SEC / adc_clk_rate;\n\tadc_dev->start_delay_ns = adc_dev->eoc_delay_ns * CC10001_WAIT_CYCLES;\n\n\t \n\tif (adc_dev->shared)\n\t\tcc10001_adc_power_up(adc_dev);\n\n\tret = devm_add_action_or_reset(dev, cc10001_pd_cb, adc_dev);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = cc10001_adc_channel_init(indio_dev, channel_map);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&adc_dev->lock);\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      &cc10001_adc_trigger_h, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id cc10001_adc_dt_ids[] = {\n\t{ .compatible = \"cosmic,10001-adc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cc10001_adc_dt_ids);\n\nstatic struct platform_driver cc10001_adc_driver = {\n\t.driver = {\n\t\t.name   = \"cc10001-adc\",\n\t\t.of_match_table = cc10001_adc_dt_ids,\n\t},\n\t.probe\t= cc10001_adc_probe,\n};\nmodule_platform_driver(cc10001_adc_driver);\n\nMODULE_AUTHOR(\"Phani Movva <Phani.Movva@imgtec.com>\");\nMODULE_DESCRIPTION(\"Cosmic Circuits ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}