{
  "module_name": "qcom-pm8xxx-xoadc.c",
  "hash_id": "97dca990be010922519359472e7912084f5d80f901d1c5a7408ab8f40f9b1249",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/qcom-pm8xxx-xoadc.c",
  "human_readable_source": "\n \n\n#include <linux/iio/adc/qcom-vadc-common.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/regulator/consumer.h>\n\n \n\n \n#define ADC_ARB_BTM_CNTRL1\t\t\t0x17e\n#define ADC_ARB_BTM_CNTRL1_EN_BTM\t\tBIT(0)\n#define ADC_ARB_BTM_CNTRL1_SEL_OP_MODE\t\tBIT(1)\n#define ADC_ARB_BTM_CNTRL1_MEAS_INTERVAL1\tBIT(2)\n#define ADC_ARB_BTM_CNTRL1_MEAS_INTERVAL2\tBIT(3)\n#define ADC_ARB_BTM_CNTRL1_MEAS_INTERVAL3\tBIT(4)\n#define ADC_ARB_BTM_CNTRL1_MEAS_INTERVAL4\tBIT(5)\n#define ADC_ARB_BTM_CNTRL1_EOC\t\t\tBIT(6)\n#define ADC_ARB_BTM_CNTRL1_REQ\t\t\tBIT(7)\n\n#define ADC_ARB_BTM_AMUX_CNTRL\t\t\t0x17f\n#define ADC_ARB_BTM_ANA_PARAM\t\t\t0x180\n#define ADC_ARB_BTM_DIG_PARAM\t\t\t0x181\n#define ADC_ARB_BTM_RSV\t\t\t\t0x182\n#define ADC_ARB_BTM_DATA1\t\t\t0x183\n#define ADC_ARB_BTM_DATA0\t\t\t0x184\n#define ADC_ARB_BTM_BAT_COOL_THR1\t\t0x185\n#define ADC_ARB_BTM_BAT_COOL_THR0\t\t0x186\n#define ADC_ARB_BTM_BAT_WARM_THR1\t\t0x187\n#define ADC_ARB_BTM_BAT_WARM_THR0\t\t0x188\n#define ADC_ARB_BTM_CNTRL2\t\t\t0x18c\n\n \n\n#define ADC_ARB_USRP_CNTRL\t\t\t0x197\n#define ADC_ARB_USRP_CNTRL_EN_ARB\t\tBIT(0)\n#define ADC_ARB_USRP_CNTRL_RSV1\t\t\tBIT(1)\n#define ADC_ARB_USRP_CNTRL_RSV2\t\t\tBIT(2)\n#define ADC_ARB_USRP_CNTRL_RSV3\t\t\tBIT(3)\n#define ADC_ARB_USRP_CNTRL_RSV4\t\t\tBIT(4)\n#define ADC_ARB_USRP_CNTRL_RSV5\t\t\tBIT(5)\n#define ADC_ARB_USRP_CNTRL_EOC\t\t\tBIT(6)\n#define ADC_ARB_USRP_CNTRL_REQ\t\t\tBIT(7)\n\n#define ADC_ARB_USRP_AMUX_CNTRL\t\t\t0x198\n \n#define ADC_ARB_USRP_AMUX_CNTRL_CHAN_MASK\t0xfc\n#define ADC_ARB_USRP_AMUX_CNTRL_RSV0\t\tBIT(0)\n#define ADC_ARB_USRP_AMUX_CNTRL_RSV1\t\tBIT(1)\n \n#define ADC_ARB_USRP_AMUX_CNTRL_PRESCALEMUX0\tBIT(2)\n#define ADC_ARB_USRP_AMUX_CNTRL_PRESCALEMUX1\tBIT(3)\n#define ADC_ARB_USRP_AMUX_CNTRL_SEL0\t\tBIT(4)\n#define ADC_ARB_USRP_AMUX_CNTRL_SEL1\t\tBIT(5)\n#define ADC_ARB_USRP_AMUX_CNTRL_SEL2\t\tBIT(6)\n#define ADC_ARB_USRP_AMUX_CNTRL_SEL3\t\tBIT(7)\n#define ADC_AMUX_PREMUX_SHIFT\t\t\t2\n#define ADC_AMUX_SEL_SHIFT\t\t\t4\n\n \n#define ADC_ARB_USRP_ANA_PARAM\t\t\t0x199\n#define ADC_ARB_USRP_ANA_PARAM_DIS\t\t0xFE\n#define ADC_ARB_USRP_ANA_PARAM_EN\t\t0xFF\n\n#define ADC_ARB_USRP_DIG_PARAM\t\t\t0x19A\n#define ADC_ARB_USRP_DIG_PARAM_SEL_SHIFT0\tBIT(0)\n#define ADC_ARB_USRP_DIG_PARAM_SEL_SHIFT1\tBIT(1)\n#define ADC_ARB_USRP_DIG_PARAM_CLK_RATE0\tBIT(2)\n#define ADC_ARB_USRP_DIG_PARAM_CLK_RATE1\tBIT(3)\n#define ADC_ARB_USRP_DIG_PARAM_EOC\t\tBIT(4)\n \n#define ADC_ARB_USRP_DIG_PARAM_DEC_RATE0\tBIT(5)\n#define ADC_ARB_USRP_DIG_PARAM_DEC_RATE1\tBIT(6)\n#define ADC_ARB_USRP_DIG_PARAM_EN\t\tBIT(7)\n#define ADC_DIG_PARAM_DEC_SHIFT\t\t\t5\n\n#define ADC_ARB_USRP_RSV\t\t\t0x19B\n#define ADC_ARB_USRP_RSV_RST\t\t\tBIT(0)\n#define ADC_ARB_USRP_RSV_DTEST0\t\t\tBIT(1)\n#define ADC_ARB_USRP_RSV_DTEST1\t\t\tBIT(2)\n#define ADC_ARB_USRP_RSV_OP\t\t\tBIT(3)\n#define ADC_ARB_USRP_RSV_IP_SEL0\t\tBIT(4)\n#define ADC_ARB_USRP_RSV_IP_SEL1\t\tBIT(5)\n#define ADC_ARB_USRP_RSV_IP_SEL2\t\tBIT(6)\n#define ADC_ARB_USRP_RSV_TRM\t\t\tBIT(7)\n#define ADC_RSV_IP_SEL_SHIFT\t\t\t4\n\n#define ADC_ARB_USRP_DATA0\t\t\t0x19D\n#define ADC_ARB_USRP_DATA1\t\t\t0x19C\n\n \n#define PM8XXX_CHANNEL_INTERNAL\t\t0x0c\n#define PM8XXX_CHANNEL_125V\t\t0x0d\n#define PM8XXX_CHANNEL_INTERNAL_2\t0x0e\n#define PM8XXX_CHANNEL_MUXOFF\t\t0x0f\n\n \n#define PM8058_AMUX_PRESCALE_0 0x0  \n#define PM8058_AMUX_PRESCALE_1 0x1  \n#define PM8058_AMUX_PRESCALE_1_DIV3 0x2  \n\n \n#define AMUX_RSV0 0x0  \n#define AMUX_RSV1 0x1  \n#define AMUX_RSV2 0x2  \n#define AMUX_RSV3 0x3  \n#define AMUX_RSV4 0x4  \n#define AMUX_RSV5 0x5  \n#define XOADC_RSV_MAX 5  \n\n \nstruct xoadc_channel {\n\tconst char *datasheet_name;\n\tu8 pre_scale_mux:2;\n\tu8 amux_channel:4;\n\tconst struct u32_fract prescale;\n\tenum iio_chan_type type;\n\tenum vadc_scale_fn_type scale_fn_type;\n\tu8 amux_ip_rsv:3;\n};\n\n \nstruct xoadc_variant {\n\tconst char name[16];\n\tconst struct xoadc_channel *channels;\n\tbool broken_ratiometric;\n\tbool prescaling;\n\tbool second_level_mux;\n};\n\n \n#define XOADC_CHAN(_dname, _presmux, _amux, _type, _prenum, _preden, _scale, _amip) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.datasheet_name = __stringify(_dname),\t\t\t\\\n\t\t.pre_scale_mux = _presmux,\t\t\t\t\\\n\t\t.amux_channel = _amux,\t\t\t\t\t\\\n\t\t.prescale = {\t\t\t\t\t\t\\\n\t\t\t.numerator = _prenum, .denominator = _preden,\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.scale_fn_type = _scale,\t\t\t\t\\\n\t\t.amux_ip_rsv = _amip,\t\t\t\t\t\\\n\t}\n\n \nstatic const struct xoadc_channel pm8018_xoadc_channels[] = {\n\tXOADC_CHAN(VCOIN, 0x00, 0x00, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VBAT, 0x00, 0x01, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VPH_PWR, 0x00, 0x02, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DIE_TEMP, 0x00, 0x0b, IIO_TEMP, 1, 1, SCALE_PMIC_THERM, AMUX_RSV1),\n\t \n\tXOADC_CHAN(AMUX8, 0x00, 0x08, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV2),\n\tXOADC_CHAN(INTERNAL, 0x00, 0x0c, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(125V, 0x00, 0x0d, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(MUXOFF, 0x00, 0x0f, IIO_TEMP, 1, 1, SCALE_XOTHERM, AMUX_RSV0),\n\t{ },  \n};\n\n \nstatic const struct xoadc_channel pm8038_xoadc_channels[] = {\n\tXOADC_CHAN(VCOIN, 0x00, 0x00, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VBAT, 0x00, 0x01, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DCIN, 0x00, 0x02, IIO_VOLTAGE, 1, 6, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ICHG, 0x00, 0x03, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VPH_PWR, 0x00, 0x04, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX5, 0x00, 0x05, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX6, 0x00, 0x06, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX7, 0x00, 0x07, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(AMUX8, 0x00, 0x08, IIO_TEMP, 1, 1, SCALE_THERM_100K_PULLUP, AMUX_RSV2),\n\tXOADC_CHAN(AMUX9, 0x00, 0x09, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(USB_VBUS, 0x00, 0x0a, IIO_VOLTAGE, 1, 4, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DIE_TEMP, 0x00, 0x0b, IIO_TEMP, 1, 1, SCALE_PMIC_THERM, AMUX_RSV1),\n\tXOADC_CHAN(INTERNAL, 0x00, 0x0c, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(125V, 0x00, 0x0d, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(INTERNAL_2, 0x00, 0x0e, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(MUXOFF, 0x00, 0x0f, IIO_TEMP, 1, 1, SCALE_XOTHERM, AMUX_RSV0),\n\t{ },  \n};\n\n \nstatic const struct xoadc_channel pm8058_xoadc_channels[] = {\n\tXOADC_CHAN(VCOIN, 0x00, 0x00, IIO_VOLTAGE, 1, 2, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VBAT, 0x00, 0x01, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DCIN, 0x00, 0x02, IIO_VOLTAGE, 1, 10, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ICHG, 0x00, 0x03, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VPH_PWR, 0x00, 0x04, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(AMUX5, 0x00, 0x05, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX6, 0x00, 0x06, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX7, 0x00, 0x07, IIO_VOLTAGE, 1, 2, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX8, 0x00, 0x08, IIO_VOLTAGE, 1, 2, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX9, 0x00, 0x09, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(USB_VBUS, 0x00, 0x0a, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DIE_TEMP, 0x00, 0x0b, IIO_TEMP, 1, 1, SCALE_PMIC_THERM, AMUX_RSV1),\n\tXOADC_CHAN(INTERNAL, 0x00, 0x0c, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(125V, 0x00, 0x0d, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(INTERNAL_2, 0x00, 0x0e, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(MUXOFF, 0x00, 0x0f, IIO_TEMP, 1, 1, SCALE_XOTHERM, AMUX_RSV0),\n\t \n\t{ },  \n};\n\n \nstatic const struct xoadc_channel pm8921_xoadc_channels[] = {\n\tXOADC_CHAN(VCOIN, 0x00, 0x00, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(VBAT, 0x00, 0x01, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DCIN, 0x00, 0x02, IIO_VOLTAGE, 1, 6, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(VPH_PWR, 0x00, 0x04, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(IBAT, 0x00, 0x05, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(BATT_THERM, 0x00, 0x08, IIO_TEMP, 1, 1, SCALE_THERM_100K_PULLUP, AMUX_RSV1),\n\tXOADC_CHAN(BATT_ID, 0x00, 0x09, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(USB_VBUS, 0x00, 0x0a, IIO_VOLTAGE, 1, 4, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DIE_TEMP, 0x00, 0x0b, IIO_TEMP, 1, 1, SCALE_PMIC_THERM, AMUX_RSV1),\n\tXOADC_CHAN(INTERNAL, 0x00, 0x0c, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(125V, 0x00, 0x0d, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(CHG_TEMP, 0x00, 0x0e, IIO_TEMP, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(MUXOFF, 0x00, 0x0f, IIO_TEMP, 1, 1, SCALE_XOTHERM, AMUX_RSV0),\n\t \n\tXOADC_CHAN(ATEST_8, 0x01, 0x00, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(USB_SNS_DIV20, 0x01, 0x01, IIO_VOLTAGE, 1, 2, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DCIN_SNS_DIV20, 0x01, 0x02, IIO_VOLTAGE, 1, 2, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX3, 0x01, 0x03, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX4, 0x01, 0x04, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX5, 0x01, 0x05, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX6, 0x01, 0x06, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX7, 0x01, 0x07, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX8, 0x01, 0x08, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(ATEST_1, 0x01, 0x09, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_2, 0x01, 0x0a, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_3, 0x01, 0x0b, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_4, 0x01, 0x0c, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_5, 0x01, 0x0d, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_6, 0x01, 0x0e, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_7, 0x01, 0x0f, IIO_VOLTAGE, 1, 1, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\t \n\tXOADC_CHAN(ATEST_8, 0x02, 0x00, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\t \n\tXOADC_CHAN(USB_SNS_DIV20_DIV3, 0x02, 0x01, IIO_VOLTAGE, 1, 6, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(DCIN_SNS_DIV20_DIV3, 0x02, 0x02, IIO_VOLTAGE, 1, 6, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX3_DIV3, 0x02, 0x03, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX4_DIV3, 0x02, 0x04, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX5_DIV3, 0x02, 0x05, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX6_DIV3, 0x02, 0x06, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX7_DIV3, 0x02, 0x07, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(AMUX8_DIV3, 0x02, 0x08, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_1_DIV3, 0x02, 0x09, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_2_DIV3, 0x02, 0x0a, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_3_DIV3, 0x02, 0x0b, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_4_DIV3, 0x02, 0x0c, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_5_DIV3, 0x02, 0x0d, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_6_DIV3, 0x02, 0x0e, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\tXOADC_CHAN(ATEST_7_DIV3, 0x02, 0x0f, IIO_VOLTAGE, 1, 3, SCALE_DEFAULT, AMUX_RSV1),\n\t{ },  \n};\n\n \nstruct pm8xxx_chan_info {\n\tconst char *name;\n\tconst struct xoadc_channel *hwchan;\n\tenum vadc_calibration calibration;\n\tu8 decimation:2;\n\tu8 amux_ip_rsv:3;\n};\n\n \nstruct pm8xxx_xoadc {\n\tstruct device *dev;\n\tstruct regmap *map;\n\tconst struct xoadc_variant *variant;\n\tstruct regulator *vref;\n\tunsigned int nchans;\n\tstruct pm8xxx_chan_info *chans;\n\tstruct iio_chan_spec *iio_chans;\n\tstruct vadc_linear_graph graph[2];\n\tstruct completion complete;\n\tstruct mutex lock;\n};\n\nstatic irqreturn_t pm8xxx_eoc_irq(int irq, void *d)\n{\n\tstruct iio_dev *indio_dev = d;\n\tstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\n\n\tcomplete(&adc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct pm8xxx_chan_info *\npm8xxx_get_channel(struct pm8xxx_xoadc *adc, u8 chan)\n{\n\tint i;\n\n\tfor (i = 0; i < adc->nchans; i++) {\n\t\tstruct pm8xxx_chan_info *ch = &adc->chans[i];\n\t\tif (ch->hwchan->amux_channel == chan)\n\t\t\treturn ch;\n\t}\n\treturn NULL;\n}\n\nstatic int pm8xxx_read_channel_rsv(struct pm8xxx_xoadc *adc,\n\t\t\t\t   const struct pm8xxx_chan_info *ch,\n\t\t\t\t   u8 rsv, u16 *adc_code,\n\t\t\t\t   bool force_ratiometric)\n{\n\tint ret;\n\tunsigned int val;\n\tu8 rsvmask, rsvval;\n\tu8 lsb, msb;\n\n\tdev_dbg(adc->dev, \"read channel \\\"%s\\\", amux %d, prescale/mux: %d, rsv %d\\n\",\n\t\tch->name, ch->hwchan->amux_channel, ch->hwchan->pre_scale_mux, rsv);\n\n\tmutex_lock(&adc->lock);\n\n\t \n\tval = ch->hwchan->amux_channel << ADC_AMUX_SEL_SHIFT;\n\tval |= ch->hwchan->pre_scale_mux << ADC_AMUX_PREMUX_SHIFT;\n\tret = regmap_write(adc->map, ADC_ARB_USRP_AMUX_CNTRL, val);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\trsvmask = (ADC_ARB_USRP_RSV_RST | ADC_ARB_USRP_RSV_DTEST0 |\n\t\t   ADC_ARB_USRP_RSV_DTEST1 | ADC_ARB_USRP_RSV_OP);\n\tif (adc->variant->broken_ratiometric && !force_ratiometric) {\n\t\t \n\t\tif (ch->hwchan->amux_channel == PM8XXX_CHANNEL_MUXOFF)\n\t\t\trsvval = ADC_ARB_USRP_RSV_IP_SEL0;\n\t\telse\n\t\t\trsvval = ADC_ARB_USRP_RSV_IP_SEL1;\n\t} else {\n\t\tif (rsv == 0xff)\n\t\t\trsvval = (ch->amux_ip_rsv << ADC_RSV_IP_SEL_SHIFT) |\n\t\t\t\tADC_ARB_USRP_RSV_TRM;\n\t\telse\n\t\t\trsvval = (rsv << ADC_RSV_IP_SEL_SHIFT) |\n\t\t\t\tADC_ARB_USRP_RSV_TRM;\n\t}\n\n\tret = regmap_update_bits(adc->map,\n\t\t\t\t ADC_ARB_USRP_RSV,\n\t\t\t\t ~rsvmask,\n\t\t\t\t rsvval);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = regmap_write(adc->map, ADC_ARB_USRP_ANA_PARAM,\n\t\t\t   ADC_ARB_USRP_ANA_PARAM_DIS);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = regmap_write(adc->map, ADC_ARB_USRP_DIG_PARAM,\n\t\t\t   ADC_ARB_USRP_DIG_PARAM_SEL_SHIFT0 |\n\t\t\t   ADC_ARB_USRP_DIG_PARAM_SEL_SHIFT1 |\n\t\t\t   ch->decimation << ADC_DIG_PARAM_DEC_SHIFT);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = regmap_write(adc->map, ADC_ARB_USRP_ANA_PARAM,\n\t\t\t   ADC_ARB_USRP_ANA_PARAM_EN);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\n\t\t\t   ADC_ARB_USRP_CNTRL_EN_ARB);\n\tif (ret)\n\t\tgoto unlock;\n\tret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\n\t\t\t   ADC_ARB_USRP_CNTRL_EN_ARB);\n\tif (ret)\n\t\tgoto unlock;\n\n\n\t \n\treinit_completion(&adc->complete);\n\tret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\n\t\t\t   ADC_ARB_USRP_CNTRL_EN_ARB |\n\t\t\t   ADC_ARB_USRP_CNTRL_REQ);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = wait_for_completion_timeout(&adc->complete,\n\t\t\t\t\t  VADC_CONV_TIME_MAX_US);\n\tif (!ret) {\n\t\tdev_err(adc->dev, \"conversion timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto unlock;\n\t}\n\n\tret = regmap_read(adc->map, ADC_ARB_USRP_DATA0, &val);\n\tif (ret)\n\t\tgoto unlock;\n\tlsb = val;\n\tret = regmap_read(adc->map, ADC_ARB_USRP_DATA1, &val);\n\tif (ret)\n\t\tgoto unlock;\n\tmsb = val;\n\t*adc_code = (msb << 8) | lsb;\n\n\t \n\tret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL, 0);\n\tif (ret)\n\t\tgoto unlock;\n\tret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL, 0);\n\tif (ret)\n\t\tgoto unlock;\n\nunlock:\n\tmutex_unlock(&adc->lock);\n\treturn ret;\n}\n\nstatic int pm8xxx_read_channel(struct pm8xxx_xoadc *adc,\n\t\t\t       const struct pm8xxx_chan_info *ch,\n\t\t\t       u16 *adc_code)\n{\n\t \n\treturn pm8xxx_read_channel_rsv(adc, ch, 0xff, adc_code, false);\n}\n\nstatic int pm8xxx_calibrate_device(struct pm8xxx_xoadc *adc)\n{\n\tconst struct pm8xxx_chan_info *ch;\n\tu16 read_1250v;\n\tu16 read_0625v;\n\tu16 read_nomux_rsv5;\n\tu16 read_nomux_rsv4;\n\tint ret;\n\n\tadc->graph[VADC_CALIB_ABSOLUTE].dx = VADC_ABSOLUTE_RANGE_UV;\n\tadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE;\n\n\t \n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_125V);\n\tif (!ch)\n\t\treturn -ENODEV;\n\tret = pm8xxx_read_channel(adc, ch, &read_1250v);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"could not read 1.25V reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_INTERNAL);\n\tif (!ch)\n\t\treturn -ENODEV;\n\tret = pm8xxx_read_channel(adc, ch, &read_0625v);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"could not read 0.625V reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (read_1250v == read_0625v) {\n\t\tdev_err(adc->dev, \"read same ADC code for 1.25V and 0.625V\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadc->graph[VADC_CALIB_ABSOLUTE].dy = read_1250v - read_0625v;\n\tadc->graph[VADC_CALIB_ABSOLUTE].gnd = read_0625v;\n\n\tdev_info(adc->dev, \"absolute calibration dx = %d uV, dy = %d units\\n\",\n\t\t VADC_ABSOLUTE_RANGE_UV, adc->graph[VADC_CALIB_ABSOLUTE].dy);\n\n\t \n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_MUXOFF);\n\tif (!ch)\n\t\treturn -ENODEV;\n\tret = pm8xxx_read_channel_rsv(adc, ch, AMUX_RSV5,\n\t\t\t\t      &read_nomux_rsv5, true);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"could not read MUXOFF reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tret = pm8xxx_read_channel_rsv(adc, ch, AMUX_RSV4,\n\t\t\t\t      &read_nomux_rsv4, true);\n\tif (ret) {\n\t\tdev_err(adc->dev, \"could not read MUXOFF reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tadc->graph[VADC_CALIB_RATIOMETRIC].dy =\n\t\tread_nomux_rsv5 - read_nomux_rsv4;\n\tadc->graph[VADC_CALIB_RATIOMETRIC].gnd = read_nomux_rsv4;\n\n\tdev_info(adc->dev, \"ratiometric calibration dx = %d, dy = %d units\\n\",\n\t\t VADC_RATIOMETRIC_RANGE,\n\t\t adc->graph[VADC_CALIB_RATIOMETRIC].dy);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\n\tconst struct pm8xxx_chan_info *ch;\n\tu16 adc_code;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tch = pm8xxx_get_channel(adc, chan->address);\n\t\tif (!ch) {\n\t\t\tdev_err(adc->dev, \"no such channel %lu\\n\",\n\t\t\t\tchan->address);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = pm8xxx_read_channel(adc, ch, &adc_code);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = qcom_vadc_scale(ch->hwchan->scale_fn_type,\n\t\t\t\t      &adc->graph[ch->calibration],\n\t\t\t\t      &ch->hwchan->prescale,\n\t\t\t\t      (ch->calibration == VADC_CALIB_ABSOLUTE),\n\t\t\t\t      adc_code, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tch = pm8xxx_get_channel(adc, chan->address);\n\t\tif (!ch) {\n\t\t\tdev_err(adc->dev, \"no such channel %lu\\n\",\n\t\t\t\tchan->address);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = pm8xxx_read_channel(adc, ch, &adc_code);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = (int)adc_code;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int pm8xxx_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t       const struct fwnode_reference_args *iiospec)\n{\n\tstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\n\tu8 pre_scale_mux;\n\tu8 amux_channel;\n\tunsigned int i;\n\n\t \n\tif (iiospec->nargs != 2) {\n\t\tdev_err(&indio_dev->dev, \"wrong number of arguments for %pfwP need 2 got %d\\n\",\n\t\t\tiiospec->fwnode,\n\t\t\tiiospec->nargs);\n\t\treturn -EINVAL;\n\t}\n\tpre_scale_mux = (u8)iiospec->args[0];\n\tamux_channel = (u8)iiospec->args[1];\n\tdev_dbg(&indio_dev->dev, \"pre scale/mux: %02x, amux: %02x\\n\",\n\t\tpre_scale_mux, amux_channel);\n\n\t \n\tfor (i = 0; i < adc->nchans; i++)\n\t\tif (adc->chans[i].hwchan->pre_scale_mux == pre_scale_mux &&\n\t\t    adc->chans[i].hwchan->amux_channel == amux_channel)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info pm8xxx_xoadc_info = {\n\t.fwnode_xlate = pm8xxx_fwnode_xlate,\n\t.read_raw = pm8xxx_read_raw,\n};\n\nstatic int pm8xxx_xoadc_parse_channel(struct device *dev,\n\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t      const struct xoadc_channel *hw_channels,\n\t\t\t\t      struct iio_chan_spec *iio_chan,\n\t\t\t\t      struct pm8xxx_chan_info *ch)\n{\n\tconst char *name = fwnode_get_name(fwnode);\n\tconst struct xoadc_channel *hwchan;\n\tu32 pre_scale_mux, amux_channel, reg[2];\n\tu32 rsv, dec;\n\tint ret;\n\tint chid;\n\n\tret = fwnode_property_read_u32_array(fwnode, \"reg\", reg,\n\t\t\t\t\t     ARRAY_SIZE(reg));\n\tif (ret) {\n\t\tdev_err(dev, \"invalid pre scale/mux or amux channel number %s\\n\",\n\t\t\tname);\n\t\treturn ret;\n\t}\n\n\tpre_scale_mux = reg[0];\n\tamux_channel = reg[1];\n\n\t \n\tchid = 0;\n\thwchan = &hw_channels[0];\n\twhile (hwchan->datasheet_name) {\n\t\tif (hwchan->pre_scale_mux == pre_scale_mux &&\n\t\t    hwchan->amux_channel == amux_channel)\n\t\t\tbreak;\n\t\thwchan++;\n\t\tchid++;\n\t}\n\t \n\tif (!hwchan->datasheet_name) {\n\t\tdev_err(dev, \"could not locate channel %02x/%02x\\n\",\n\t\t\tpre_scale_mux, amux_channel);\n\t\treturn -EINVAL;\n\t}\n\tch->name = name;\n\tch->hwchan = hwchan;\n\t \n\tch->calibration = VADC_CALIB_ABSOLUTE;\n\t \n\tch->decimation = VADC_DEF_DECIMATION;\n\n\tif (!fwnode_property_read_u32(fwnode, \"qcom,ratiometric\", &rsv)) {\n\t\tch->calibration = VADC_CALIB_RATIOMETRIC;\n\t\tif (rsv > XOADC_RSV_MAX) {\n\t\t\tdev_err(dev, \"%s too large RSV value %d\\n\", name, rsv);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rsv == AMUX_RSV3) {\n\t\t\tdev_err(dev, \"%s invalid RSV value %d\\n\", name, rsv);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tret = fwnode_property_read_u32(fwnode, \"qcom,decimation\", &dec);\n\tif (!ret) {\n\t\tret = qcom_vadc_decimation_from_dt(dec);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s invalid decimation %d\\n\",\n\t\t\t\tname, dec);\n\t\t\treturn ret;\n\t\t}\n\t\tch->decimation = ret;\n\t}\n\n\tiio_chan->channel = chid;\n\tiio_chan->address = hwchan->amux_channel;\n\tiio_chan->datasheet_name = hwchan->datasheet_name;\n\tiio_chan->type = hwchan->type;\n\t \n\tiio_chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_PROCESSED);\n\tiio_chan->indexed = 1;\n\n\tdev_dbg(dev,\n\t\t\"channel [PRESCALE/MUX: %02x AMUX: %02x] \\\"%s\\\" ref voltage: %d, decimation %d prescale %d/%d, scale function %d\\n\",\n\t\thwchan->pre_scale_mux, hwchan->amux_channel, ch->name,\n\t\tch->amux_ip_rsv, ch->decimation, hwchan->prescale.numerator,\n\t\thwchan->prescale.denominator, hwchan->scale_fn_type);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_xoadc_parse_channels(struct pm8xxx_xoadc *adc)\n{\n\tstruct fwnode_handle *child;\n\tstruct pm8xxx_chan_info *ch;\n\tint ret;\n\tint i;\n\n\tadc->nchans = device_get_child_node_count(adc->dev);\n\tif (!adc->nchans) {\n\t\tdev_err(adc->dev, \"no channel children\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(adc->dev, \"found %d ADC channels\\n\", adc->nchans);\n\n\tadc->iio_chans = devm_kcalloc(adc->dev, adc->nchans,\n\t\t\t\t      sizeof(*adc->iio_chans), GFP_KERNEL);\n\tif (!adc->iio_chans)\n\t\treturn -ENOMEM;\n\n\tadc->chans = devm_kcalloc(adc->dev, adc->nchans,\n\t\t\t\t  sizeof(*adc->chans), GFP_KERNEL);\n\tif (!adc->chans)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(adc->dev, child) {\n\t\tch = &adc->chans[i];\n\t\tret = pm8xxx_xoadc_parse_channel(adc->dev, child,\n\t\t\t\t\t\t adc->variant->channels,\n\t\t\t\t\t\t &adc->iio_chans[i],\n\t\t\t\t\t\t ch);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\n\t \n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_125V);\n\tif (!ch) {\n\t\tdev_err(adc->dev, \"missing 1.25V reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_INTERNAL);\n\tif (!ch) {\n\t\tdev_err(adc->dev, \"missing 0.625V reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\tch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_MUXOFF);\n\tif (!ch) {\n\t\tdev_err(adc->dev, \"missing MUXOFF reference channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8xxx_xoadc_probe(struct platform_device *pdev)\n{\n\tconst struct xoadc_variant *variant;\n\tstruct pm8xxx_xoadc *adc;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *map;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tvariant = device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tadc = iio_priv(indio_dev);\n\tadc->dev = dev;\n\tadc->variant = variant;\n\tinit_completion(&adc->complete);\n\tmutex_init(&adc->lock);\n\n\tret = pm8xxx_xoadc_parse_channels(adc);\n\tif (ret)\n\t\treturn ret;\n\n\tmap = dev_get_regmap(dev->parent, NULL);\n\tif (!map) {\n\t\tdev_err(dev, \"parent regmap unavailable.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tadc->map = map;\n\n\t \n\tadc->vref = devm_regulator_get(dev, \"xoadc-ref\");\n\tif (IS_ERR(adc->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->vref),\n\t\t\t\t     \"failed to get XOADC VREF regulator\\n\");\n\tret = regulator_enable(adc->vref);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable XOADC VREF regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0),\n\t\t\tpm8xxx_eoc_irq, NULL, 0, variant->name, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\tgoto out_disable_vref;\n\t}\n\n\tindio_dev->name = variant->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &pm8xxx_xoadc_info;\n\tindio_dev->channels = adc->iio_chans;\n\tindio_dev->num_channels = adc->nchans;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto out_disable_vref;\n\n\tret = pm8xxx_calibrate_device(adc);\n\tif (ret)\n\t\tgoto out_unreg_device;\n\n\tdev_info(dev, \"%s XOADC driver enabled\\n\", variant->name);\n\n\treturn 0;\n\nout_unreg_device:\n\tiio_device_unregister(indio_dev);\nout_disable_vref:\n\tregulator_disable(adc->vref);\n\n\treturn ret;\n}\n\nstatic int pm8xxx_xoadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tregulator_disable(adc->vref);\n\n\treturn 0;\n}\n\nstatic const struct xoadc_variant pm8018_variant = {\n\t.name = \"PM8018-XOADC\",\n\t.channels = pm8018_xoadc_channels,\n};\n\nstatic const struct xoadc_variant pm8038_variant = {\n\t.name = \"PM8038-XOADC\",\n\t.channels = pm8038_xoadc_channels,\n};\n\nstatic const struct xoadc_variant pm8058_variant = {\n\t.name = \"PM8058-XOADC\",\n\t.channels = pm8058_xoadc_channels,\n\t.broken_ratiometric = true,\n\t.prescaling = true,\n};\n\nstatic const struct xoadc_variant pm8921_variant = {\n\t.name = \"PM8921-XOADC\",\n\t.channels = pm8921_xoadc_channels,\n\t.second_level_mux = true,\n};\n\nstatic const struct of_device_id pm8xxx_xoadc_id_table[] = {\n\t{\n\t\t.compatible = \"qcom,pm8018-adc\",\n\t\t.data = &pm8018_variant,\n\t},\n\t{\n\t\t.compatible = \"qcom,pm8038-adc\",\n\t\t.data = &pm8038_variant,\n\t},\n\t{\n\t\t.compatible = \"qcom,pm8058-adc\",\n\t\t.data = &pm8058_variant,\n\t},\n\t{\n\t\t.compatible = \"qcom,pm8921-adc\",\n\t\t.data = &pm8921_variant,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_xoadc_id_table);\n\nstatic struct platform_driver pm8xxx_xoadc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pm8xxx-adc\",\n\t\t.of_match_table = pm8xxx_xoadc_id_table,\n\t},\n\t.probe\t\t= pm8xxx_xoadc_probe,\n\t.remove\t\t= pm8xxx_xoadc_remove,\n};\nmodule_platform_driver(pm8xxx_xoadc_driver);\n\nMODULE_DESCRIPTION(\"PM8xxx XOADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:pm8xxx-xoadc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}