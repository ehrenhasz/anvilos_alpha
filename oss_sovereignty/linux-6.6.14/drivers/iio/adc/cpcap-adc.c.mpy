{
  "module_name": "cpcap-adc.c",
  "hash_id": "fd99ba7128a896802574f0fca0074ecf2b7ce4f1609feced4c01217a43a36ea1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/cpcap-adc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/mfd/motorola-cpcap.h>\n\n \n#define CPCAP_BIT_ADEN_AUTO_CLR\t\tBIT(15)\t \n#define CPCAP_BIT_CAL_MODE\t\tBIT(14)  \n#define CPCAP_BIT_ADC_CLK_SEL1\t\tBIT(13)\t \n#define CPCAP_BIT_ADC_CLK_SEL0\t\tBIT(12)\t \n#define CPCAP_BIT_ATOX\t\t\tBIT(11)\n#define CPCAP_BIT_ATO3\t\t\tBIT(10)\n#define CPCAP_BIT_ATO2\t\t\tBIT(9)\n#define CPCAP_BIT_ATO1\t\t\tBIT(8)\n#define CPCAP_BIT_ATO0\t\t\tBIT(7)\n#define CPCAP_BIT_ADA2\t\t\tBIT(6)\n#define CPCAP_BIT_ADA1\t\t\tBIT(5)\n#define CPCAP_BIT_ADA0\t\t\tBIT(4)\n#define CPCAP_BIT_AD_SEL1\t\tBIT(3)\t \n#define CPCAP_BIT_RAND1\t\t\tBIT(2)\t \n#define CPCAP_BIT_RAND0\t\t\tBIT(1)\t \n#define CPCAP_BIT_ADEN\t\t\tBIT(0)\t \n\n#define CPCAP_REG_ADCC1_DEFAULTS\t(CPCAP_BIT_ADEN_AUTO_CLR | \\\n\t\t\t\t\t CPCAP_BIT_ADC_CLK_SEL0 |  \\\n\t\t\t\t\t CPCAP_BIT_RAND1)\n\n \n#define CPCAP_BIT_CAL_FACTOR_ENABLE\tBIT(15)\t \n#define CPCAP_BIT_BATDETB_EN\t\tBIT(14)\t \n#define CPCAP_BIT_ADTRIG_ONESHOT\tBIT(13)\t \n#define CPCAP_BIT_ASC\t\t\tBIT(12)\t \n#define CPCAP_BIT_ATOX_PS_FACTOR\tBIT(11)\n#define CPCAP_BIT_ADC_PS_FACTOR1\tBIT(10)\n#define CPCAP_BIT_ADC_PS_FACTOR0\tBIT(9)\n#define CPCAP_BIT_AD4_SELECT\t\tBIT(8)\t \n#define CPCAP_BIT_ADC_BUSY\t\tBIT(7)\t \n#define CPCAP_BIT_THERMBIAS_EN\t\tBIT(6)\t \n#define CPCAP_BIT_ADTRIG_DIS\t\tBIT(5)\t \n#define CPCAP_BIT_LIADC\t\t\tBIT(4)\t \n#define CPCAP_BIT_TS_REFEN\t\tBIT(3)\t \n#define CPCAP_BIT_TS_M2\t\t\tBIT(2)\t \n#define CPCAP_BIT_TS_M1\t\t\tBIT(1)\t \n#define CPCAP_BIT_TS_M0\t\t\tBIT(0)\t \n\n#define CPCAP_REG_ADCC2_DEFAULTS\t(CPCAP_BIT_AD4_SELECT | \\\n\t\t\t\t\t CPCAP_BIT_ADTRIG_DIS | \\\n\t\t\t\t\t CPCAP_BIT_LIADC | \\\n\t\t\t\t\t CPCAP_BIT_TS_M2 | \\\n\t\t\t\t\t CPCAP_BIT_TS_M1)\n\n#define CPCAP_MAX_TEMP_LVL\t\t27\n#define CPCAP_FOUR_POINT_TWO_ADC\t801\n#define ST_ADC_CAL_CHRGI_HIGH_THRESHOLD\t530\n#define ST_ADC_CAL_CHRGI_LOW_THRESHOLD\t494\n#define ST_ADC_CAL_BATTI_HIGH_THRESHOLD\t530\n#define ST_ADC_CAL_BATTI_LOW_THRESHOLD\t494\n#define ST_ADC_CALIBRATE_DIFF_THRESHOLD\t3\n\n#define CPCAP_ADC_MAX_RETRIES\t\t5\t \n\n \nstruct cpcap_adc_ato {\n\tunsigned short ato_in;\n\tunsigned short atox_in;\n\tunsigned short adc_ps_factor_in;\n\tunsigned short atox_ps_factor_in;\n\tunsigned short ato_out;\n\tunsigned short atox_out;\n\tunsigned short adc_ps_factor_out;\n\tunsigned short atox_ps_factor_out;\n};\n\n \nstruct cpcap_adc {\n\tstruct regmap *reg;\n\tstruct device *dev;\n\tu16 vendor;\n\tint irq;\n\tstruct mutex lock;\t \n\tconst struct cpcap_adc_ato *ato;\n\twait_queue_head_t wq_data_avail;\n\tbool done;\n};\n\n \nenum cpcap_adc_channel {\n\t \n\tCPCAP_ADC_AD0,\t\t \n\tCPCAP_ADC_BATTP,\t \n\tCPCAP_ADC_VBUS,\t\t \n\tCPCAP_ADC_AD3,\t\t \n\tCPCAP_ADC_BPLUS_AD4,\t \n\tCPCAP_ADC_CHG_ISENSE,\t \n\tCPCAP_ADC_BATTI,\t \n\tCPCAP_ADC_USB_ID,\t \n\n\t \n\tCPCAP_ADC_AD8,\t\t \n\tCPCAP_ADC_AD9,\t\t \n\tCPCAP_ADC_LICELL,\t \n\tCPCAP_ADC_HV_BATTP,\t \n\tCPCAP_ADC_TSX1_AD12,\t \n\tCPCAP_ADC_TSX2_AD13,\t \n\tCPCAP_ADC_TSY1_AD14,\t \n\tCPCAP_ADC_TSY2_AD15,\t \n\n\t \n\tCPCAP_ADC_BATTP_PI16,\t \n\tCPCAP_ADC_BATTI_PI17,\t \n\n\tCPCAP_ADC_CHANNEL_NUM,\n};\n\n \nenum cpcap_adc_timing {\n\tCPCAP_ADC_TIMING_IMM,\n\tCPCAP_ADC_TIMING_IN,\n\tCPCAP_ADC_TIMING_OUT,\n};\n\n \nstruct cpcap_adc_phasing_tbl {\n\tshort offset;\n\tunsigned short multiplier;\n\tunsigned short divider;\n\tshort min;\n\tshort max;\n};\n\n \nstruct cpcap_adc_conversion_tbl {\n\tenum iio_chan_info_enum conv_type;\n\tint align_offset;\n\tint conv_offset;\n\tint cal_offset;\n\tint multiplier;\n\tint divider;\n};\n\n \nstruct cpcap_adc_request {\n\tint channel;\n\tconst struct cpcap_adc_phasing_tbl *phase_tbl;\n\tconst struct cpcap_adc_conversion_tbl *conv_tbl;\n\tint bank_index;\n\tenum cpcap_adc_timing timing;\n\tint result;\n};\n\n \nstatic const struct cpcap_adc_phasing_tbl bank_phasing[] = {\n\t \n\t[CPCAP_ADC_AD0] =          {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_BATTP] =        {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_VBUS] =         {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_AD3] =          {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_BPLUS_AD4] =    {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_CHG_ISENSE] =   {0, 0x80, 0x80, -512,  511},\n\t[CPCAP_ADC_BATTI] =        {0, 0x80, 0x80, -512,  511},\n\t[CPCAP_ADC_USB_ID] =       {0, 0x80, 0x80,    0, 1023},\n\n\t \n\t[CPCAP_ADC_AD8] =          {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_AD9] =          {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_LICELL] =       {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_HV_BATTP] =     {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_TSX1_AD12] =    {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_TSX2_AD13] =    {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_TSY1_AD14] =    {0, 0x80, 0x80,    0, 1023},\n\t[CPCAP_ADC_TSY2_AD15] =    {0, 0x80, 0x80,    0, 1023},\n};\n\n \nstatic struct cpcap_adc_conversion_tbl bank_conversion[] = {\n\t \n\t[CPCAP_ADC_AD0] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_BATTP] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0, 2400, 0,  2300, 1023,\n\t},\n\t[CPCAP_ADC_VBUS] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0,    0, 0, 10000, 1023,\n\t},\n\t[CPCAP_ADC_AD3] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0,    0, 0,     1,    1,\n\t\t},\n\t[CPCAP_ADC_BPLUS_AD4] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0, 2400, 0,  2300, 1023,\n\t},\n\t[CPCAP_ADC_CHG_ISENSE] = {\n\t\tIIO_CHAN_INFO_PROCESSED, -512,    2, 0,  5000, 1023,\n\t},\n\t[CPCAP_ADC_BATTI] = {\n\t\tIIO_CHAN_INFO_PROCESSED, -512,    2, 0,  5000, 1023,\n\t},\n\t[CPCAP_ADC_USB_ID] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\n\t \n\t[CPCAP_ADC_AD8] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_AD9] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_LICELL] = {\n\t\tIIO_CHAN_INFO_PROCESSED,    0,    0, 0,  3400, 1023,\n\t},\n\t[CPCAP_ADC_HV_BATTP] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_TSX1_AD12] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_TSX2_AD13] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_TSY1_AD14] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n\t[CPCAP_ADC_TSY2_AD15] = {\n\t\tIIO_CHAN_INFO_RAW,          0,    0, 0,     1,    1,\n\t},\n};\n\n \nstatic const int temp_map[CPCAP_MAX_TEMP_LVL][2] = {\n\t{ 0x03ff, -40000 },\n\t{ 0x03ff, -35000 },\n\t{ 0x03ef, -30000 },\n\t{ 0x03b2, -25000 },\n\t{ 0x036c, -20000 },\n\t{ 0x0320, -15000 },\n\t{ 0x02d0, -10000 },\n\t{ 0x027f, -5000 },\n\t{ 0x022f, 0 },\n\t{ 0x01e4, 5000 },\n\t{ 0x019f, 10000 },\n\t{ 0x0161, 15000 },\n\t{ 0x012b, 20000 },\n\t{ 0x00fc, 25000 },\n\t{ 0x00d4, 30000 },\n\t{ 0x00b2, 35000 },\n\t{ 0x0095, 40000 },\n\t{ 0x007d, 45000 },\n\t{ 0x0069, 50000 },\n\t{ 0x0059, 55000 },\n\t{ 0x004b, 60000 },\n\t{ 0x003f, 65000 },\n\t{ 0x0036, 70000 },\n\t{ 0x002e, 75000 },\n\t{ 0x0027, 80000 },\n\t{ 0x0022, 85000 },\n\t{ 0x001d, 90000 },\n};\n\n#define CPCAP_CHAN(_type, _index, _address, _datasheet_name) {\t\\\n\t.type = (_type), \\\n\t.address = (_address), \\\n\t.indexed = 1, \\\n\t.channel = (_index), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_PROCESSED), \\\n\t.scan_index = (_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 10, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n\t.datasheet_name = (_datasheet_name), \\\n}\n\n \nstatic const struct iio_chan_spec cpcap_adc_channels[] = {\n\t \n\tCPCAP_CHAN(IIO_TEMP,    0, CPCAP_REG_ADCD0,  \"battdetb\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 1, CPCAP_REG_ADCD1,  \"battp\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 2, CPCAP_REG_ADCD2,  \"vbus\"),\n\tCPCAP_CHAN(IIO_TEMP,    3, CPCAP_REG_ADCD3,  \"ad3\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 4, CPCAP_REG_ADCD4,  \"ad4\"),\n\tCPCAP_CHAN(IIO_CURRENT, 5, CPCAP_REG_ADCD5,  \"chg_isense\"),\n\tCPCAP_CHAN(IIO_CURRENT, 6, CPCAP_REG_ADCD6,  \"batti\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 7, CPCAP_REG_ADCD7,  \"usb_id\"),\n\n\t \n\tCPCAP_CHAN(IIO_CURRENT, 8, CPCAP_REG_ADCD0,  \"ad8\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 9, CPCAP_REG_ADCD1,  \"ad9\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 10, CPCAP_REG_ADCD2, \"licell\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 11, CPCAP_REG_ADCD3, \"hv_battp\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 12, CPCAP_REG_ADCD4, \"tsx1_ad12\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 13, CPCAP_REG_ADCD5, \"tsx2_ad13\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 14, CPCAP_REG_ADCD6, \"tsy1_ad14\"),\n\tCPCAP_CHAN(IIO_VOLTAGE, 15, CPCAP_REG_ADCD7, \"tsy2_ad15\"),\n\n\t \n\tCPCAP_CHAN(IIO_VOLTAGE, 16, CPCAP_REG_ADCD0, \"chg_vsense\"),\n\tCPCAP_CHAN(IIO_CURRENT, 17, CPCAP_REG_ADCD1, \"batti2\"),\n};\n\nstatic irqreturn_t cpcap_adc_irq_thread(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct cpcap_adc *ddata = iio_priv(indio_dev);\n\tint error;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t   CPCAP_BIT_ADTRIG_DIS,\n\t\t\t\t   CPCAP_BIT_ADTRIG_DIS);\n\tif (error)\n\t\treturn IRQ_NONE;\n\n\tddata->done = true;\n\twake_up_interruptible(&ddata->wq_data_avail);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void cpcap_adc_setup_calibrate(struct cpcap_adc *ddata,\n\t\t\t\t      enum cpcap_adc_channel chan)\n{\n\tunsigned int value = 0;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(3000);\n\tint error;\n\n\tif ((chan != CPCAP_ADC_CHG_ISENSE) &&\n\t    (chan != CPCAP_ADC_BATTI))\n\t\treturn;\n\n\tvalue |= CPCAP_BIT_CAL_MODE | CPCAP_BIT_RAND0;\n\tvalue |= ((chan << 4) &\n\t\t  (CPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 | CPCAP_BIT_ADA0));\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\n\t\t\t\t   CPCAP_BIT_CAL_MODE | CPCAP_BIT_ATOX |\n\t\t\t\t   CPCAP_BIT_ATO3 | CPCAP_BIT_ATO2 |\n\t\t\t\t   CPCAP_BIT_ATO1 | CPCAP_BIT_ATO0 |\n\t\t\t\t   CPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 |\n\t\t\t\t   CPCAP_BIT_ADA0 | CPCAP_BIT_AD_SEL1 |\n\t\t\t\t   CPCAP_BIT_RAND1 | CPCAP_BIT_RAND0,\n\t\t\t\t   value);\n\tif (error)\n\t\treturn;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t   CPCAP_BIT_ATOX_PS_FACTOR |\n\t\t\t\t   CPCAP_BIT_ADC_PS_FACTOR1 |\n\t\t\t\t   CPCAP_BIT_ADC_PS_FACTOR0,\n\t\t\t\t   0);\n\tif (error)\n\t\treturn;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t   CPCAP_BIT_ADTRIG_DIS,\n\t\t\t\t   CPCAP_BIT_ADTRIG_DIS);\n\tif (error)\n\t\treturn;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t   CPCAP_BIT_ASC,\n\t\t\t\t   CPCAP_BIT_ASC);\n\tif (error)\n\t\treturn;\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1);\n\t\terror = regmap_read(ddata->reg, CPCAP_REG_ADCC2, &value);\n\t\tif (error)\n\t\t\treturn;\n\t} while ((value & CPCAP_BIT_ASC) && time_before(jiffies, timeout));\n\n\tif (value & CPCAP_BIT_ASC)\n\t\tdev_err(ddata->dev,\n\t\t\t\"Timeout waiting for calibration to complete\\n\");\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\n\t\t\t\t   CPCAP_BIT_CAL_MODE, 0);\n\tif (error)\n\t\treturn;\n}\n\nstatic int cpcap_adc_calibrate_one(struct cpcap_adc *ddata,\n\t\t\t\t   int channel,\n\t\t\t\t   u16 calibration_register,\n\t\t\t\t   int lower_threshold,\n\t\t\t\t   int upper_threshold)\n{\n\tunsigned int calibration_data[2];\n\tunsigned short cal_data_diff;\n\tint i, error;\n\n\tfor (i = 0; i < CPCAP_ADC_MAX_RETRIES; i++) {\n\t\tcalibration_data[0]  = 0;\n\t\tcalibration_data[1]  = 0;\n\n\t\tcpcap_adc_setup_calibrate(ddata, channel);\n\t\terror = regmap_read(ddata->reg, calibration_register,\n\t\t\t\t    &calibration_data[0]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tcpcap_adc_setup_calibrate(ddata, channel);\n\t\terror = regmap_read(ddata->reg, calibration_register,\n\t\t\t\t    &calibration_data[1]);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (calibration_data[0] > calibration_data[1])\n\t\t\tcal_data_diff =\n\t\t\t\tcalibration_data[0] - calibration_data[1];\n\t\telse\n\t\t\tcal_data_diff =\n\t\t\t\tcalibration_data[1] - calibration_data[0];\n\n\t\tif (((calibration_data[1] >= lower_threshold) &&\n\t\t     (calibration_data[1] <= upper_threshold) &&\n\t\t     (cal_data_diff <= ST_ADC_CALIBRATE_DIFF_THRESHOLD)) ||\n\t\t    (ddata->vendor == CPCAP_VENDOR_TI)) {\n\t\t\tbank_conversion[channel].cal_offset =\n\t\t\t\t((short)calibration_data[1] * -1) + 512;\n\t\t\tdev_dbg(ddata->dev, \"ch%i calibration complete: %i\\n\",\n\t\t\t\tchannel, bank_conversion[channel].cal_offset);\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(5000, 10000);\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_adc_calibrate(struct cpcap_adc *ddata)\n{\n\tint error;\n\n\terror = cpcap_adc_calibrate_one(ddata, CPCAP_ADC_CHG_ISENSE,\n\t\t\t\t\tCPCAP_REG_ADCAL1,\n\t\t\t\t\tST_ADC_CAL_CHRGI_LOW_THRESHOLD,\n\t\t\t\t\tST_ADC_CAL_CHRGI_HIGH_THRESHOLD);\n\tif (error)\n\t\treturn error;\n\n\terror = cpcap_adc_calibrate_one(ddata, CPCAP_ADC_BATTI,\n\t\t\t\t\tCPCAP_REG_ADCAL2,\n\t\t\t\t\tST_ADC_CAL_BATTI_LOW_THRESHOLD,\n\t\t\t\t\tST_ADC_CAL_BATTI_HIGH_THRESHOLD);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nstatic void cpcap_adc_setup_bank(struct cpcap_adc *ddata,\n\t\t\t\t struct cpcap_adc_request *req)\n{\n\tconst struct cpcap_adc_ato *ato = ddata->ato;\n\tunsigned short value1 = 0;\n\tunsigned short value2 = 0;\n\tint error;\n\n\tif (!ato)\n\t\treturn;\n\n\tswitch (req->channel) {\n\tcase CPCAP_ADC_AD0:\n\t\tvalue2 |= CPCAP_BIT_THERMBIAS_EN;\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t\t   CPCAP_BIT_THERMBIAS_EN,\n\t\t\t\t\t   value2);\n\t\tif (error)\n\t\t\treturn;\n\t\tusleep_range(800, 1000);\n\t\tbreak;\n\tcase CPCAP_ADC_AD8 ... CPCAP_ADC_TSY2_AD15:\n\t\tvalue1 |= CPCAP_BIT_AD_SEL1;\n\t\tbreak;\n\tcase CPCAP_ADC_BATTP_PI16 ... CPCAP_ADC_BATTI_PI17:\n\t\tvalue1 |= CPCAP_BIT_RAND1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (req->timing) {\n\tcase CPCAP_ADC_TIMING_IN:\n\t\tvalue1 |= ato->ato_in;\n\t\tvalue1 |= ato->atox_in;\n\t\tvalue2 |= ato->adc_ps_factor_in;\n\t\tvalue2 |= ato->atox_ps_factor_in;\n\t\tbreak;\n\tcase CPCAP_ADC_TIMING_OUT:\n\t\tvalue1 |= ato->ato_out;\n\t\tvalue1 |= ato->atox_out;\n\t\tvalue2 |= ato->adc_ps_factor_out;\n\t\tvalue2 |= ato->atox_ps_factor_out;\n\t\tbreak;\n\n\tcase CPCAP_ADC_TIMING_IMM:\n\tdefault:\n\t\tbreak;\n\t}\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\n\t\t\t\t   CPCAP_BIT_CAL_MODE | CPCAP_BIT_ATOX |\n\t\t\t\t   CPCAP_BIT_ATO3 | CPCAP_BIT_ATO2 |\n\t\t\t\t   CPCAP_BIT_ATO1 | CPCAP_BIT_ATO0 |\n\t\t\t\t   CPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 |\n\t\t\t\t   CPCAP_BIT_ADA0 | CPCAP_BIT_AD_SEL1 |\n\t\t\t\t   CPCAP_BIT_RAND1 | CPCAP_BIT_RAND0,\n\t\t\t\t   value1);\n\tif (error)\n\t\treturn;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t   CPCAP_BIT_ATOX_PS_FACTOR |\n\t\t\t\t   CPCAP_BIT_ADC_PS_FACTOR1 |\n\t\t\t\t   CPCAP_BIT_ADC_PS_FACTOR0 |\n\t\t\t\t   CPCAP_BIT_THERMBIAS_EN,\n\t\t\t\t   value2);\n\tif (error)\n\t\treturn;\n\n\tif (req->timing == CPCAP_ADC_TIMING_IMM) {\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t\t   CPCAP_BIT_ADTRIG_DIS,\n\t\t\t\t\t   CPCAP_BIT_ADTRIG_DIS);\n\t\tif (error)\n\t\t\treturn;\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t\t   CPCAP_BIT_ASC,\n\t\t\t\t\t   CPCAP_BIT_ASC);\n\t\tif (error)\n\t\t\treturn;\n\t} else {\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t\t   CPCAP_BIT_ADTRIG_ONESHOT,\n\t\t\t\t\t   CPCAP_BIT_ADTRIG_ONESHOT);\n\t\tif (error)\n\t\t\treturn;\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t\t   CPCAP_BIT_ADTRIG_DIS, 0);\n\t\tif (error)\n\t\t\treturn;\n\t}\n}\n\nstatic int cpcap_adc_start_bank(struct cpcap_adc *ddata,\n\t\t\t\tstruct cpcap_adc_request *req)\n{\n\tint i, error;\n\n\treq->timing = CPCAP_ADC_TIMING_IMM;\n\tddata->done = false;\n\n\tfor (i = 0; i < CPCAP_ADC_MAX_RETRIES; i++) {\n\t\tcpcap_adc_setup_bank(ddata, req);\n\t\terror = wait_event_interruptible_timeout(ddata->wq_data_avail,\n\t\t\t\t\t\t\t ddata->done,\n\t\t\t\t\t\t\t msecs_to_jiffies(50));\n\t\tif (error > 0)\n\t\t\treturn 0;\n\n\t\tif (error == 0) {\n\t\t\terror = -ETIMEDOUT;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}\n\nstatic int cpcap_adc_stop_bank(struct cpcap_adc *ddata)\n{\n\tint error;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\n\t\t\t\t   0xffff,\n\t\t\t\t   CPCAP_REG_ADCC1_DEFAULTS);\n\tif (error)\n\t\treturn error;\n\n\treturn regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\n\t\t\t\t  0xffff,\n\t\t\t\t  CPCAP_REG_ADCC2_DEFAULTS);\n}\n\nstatic void cpcap_adc_phase(struct cpcap_adc_request *req)\n{\n\tconst struct cpcap_adc_conversion_tbl *conv_tbl = req->conv_tbl;\n\tconst struct cpcap_adc_phasing_tbl *phase_tbl = req->phase_tbl;\n\tint index = req->channel;\n\n\t \n\tswitch (req->channel) {\n\tcase CPCAP_ADC_BATTP:\n\tcase CPCAP_ADC_BATTP_PI16:\n\t\tindex = req->bank_index;\n\t\treq->result -= phase_tbl[index].offset;\n\t\treq->result -= CPCAP_FOUR_POINT_TWO_ADC;\n\t\treq->result *= phase_tbl[index].multiplier;\n\t\tif (phase_tbl[index].divider == 0)\n\t\t\treturn;\n\t\treq->result /= phase_tbl[index].divider;\n\t\treq->result += CPCAP_FOUR_POINT_TWO_ADC;\n\t\tbreak;\n\tcase CPCAP_ADC_BATTI_PI17:\n\t\tindex = req->bank_index;\n\t\tfallthrough;\n\tdefault:\n\t\treq->result += conv_tbl[index].cal_offset;\n\t\treq->result += conv_tbl[index].align_offset;\n\t\treq->result *= phase_tbl[index].multiplier;\n\t\tif (phase_tbl[index].divider == 0)\n\t\t\treturn;\n\t\treq->result /= phase_tbl[index].divider;\n\t\treq->result += phase_tbl[index].offset;\n\t\tbreak;\n\t}\n\n\tif (req->result < phase_tbl[index].min)\n\t\treq->result = phase_tbl[index].min;\n\telse if (req->result > phase_tbl[index].max)\n\t\treq->result = phase_tbl[index].max;\n}\n\n \nstatic int cpcap_adc_table_to_millicelcius(unsigned short value)\n{\n\tint i, result = 0, alpha;\n\n\tif (value <= temp_map[CPCAP_MAX_TEMP_LVL - 1][0])\n\t\treturn temp_map[CPCAP_MAX_TEMP_LVL - 1][1];\n\n\tif (value >= temp_map[0][0])\n\t\treturn temp_map[0][1];\n\n\tfor (i = 0; i < CPCAP_MAX_TEMP_LVL - 1; i++) {\n\t\tif ((value <= temp_map[i][0]) &&\n\t\t    (value >= temp_map[i + 1][0])) {\n\t\t\tif (value == temp_map[i][0]) {\n\t\t\t\tresult = temp_map[i][1];\n\t\t\t} else if (value == temp_map[i + 1][0]) {\n\t\t\t\tresult = temp_map[i + 1][1];\n\t\t\t} else {\n\t\t\t\talpha = ((value - temp_map[i][0]) * 1000) /\n\t\t\t\t\t(temp_map[i + 1][0] - temp_map[i][0]);\n\n\t\t\t\tresult = temp_map[i][1] +\n\t\t\t\t\t((alpha * (temp_map[i + 1][1] -\n\t\t\t\t\t\t temp_map[i][1])) / 1000);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void cpcap_adc_convert(struct cpcap_adc_request *req)\n{\n\tconst struct cpcap_adc_conversion_tbl *conv_tbl = req->conv_tbl;\n\tint index = req->channel;\n\n\t \n\tswitch (req->channel) {\n\tcase CPCAP_ADC_BATTP_PI16:\n\t\tindex = CPCAP_ADC_BATTP;\n\t\tbreak;\n\tcase CPCAP_ADC_BATTI_PI17:\n\t\tindex = CPCAP_ADC_BATTI;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (conv_tbl[index].conv_type == IIO_CHAN_INFO_RAW)\n\t\treturn;\n\n\t \n\tif ((req->channel == CPCAP_ADC_AD0) ||\n\t    (req->channel == CPCAP_ADC_AD3)) {\n\t\treq->result =\n\t\t\tcpcap_adc_table_to_millicelcius(req->result);\n\n\t\treturn;\n\t}\n\n\t \n\treq->result *= conv_tbl[index].multiplier;\n\tif (conv_tbl[index].divider == 0)\n\t\treturn;\n\treq->result /= conv_tbl[index].divider;\n\treq->result += conv_tbl[index].conv_offset;\n}\n\n \nstatic int cpcap_adc_read_bank_scaled(struct cpcap_adc *ddata,\n\t\t\t\t      struct cpcap_adc_request *req)\n{\n\tint calibration_data, error, addr;\n\n\tif (ddata->vendor == CPCAP_VENDOR_TI) {\n\t\terror = regmap_read(ddata->reg, CPCAP_REG_ADCAL1,\n\t\t\t\t    &calibration_data);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbank_conversion[CPCAP_ADC_CHG_ISENSE].cal_offset =\n\t\t\t((short)calibration_data * -1) + 512;\n\n\t\terror = regmap_read(ddata->reg, CPCAP_REG_ADCAL2,\n\t\t\t\t    &calibration_data);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbank_conversion[CPCAP_ADC_BATTI].cal_offset =\n\t\t\t((short)calibration_data * -1) + 512;\n\t}\n\n\taddr = CPCAP_REG_ADCD0 + req->bank_index * 4;\n\n\terror = regmap_read(ddata->reg, addr, &req->result);\n\tif (error)\n\t\treturn error;\n\n\treq->result &= 0x3ff;\n\tcpcap_adc_phase(req);\n\tcpcap_adc_convert(req);\n\n\treturn 0;\n}\n\nstatic int cpcap_adc_init_request(struct cpcap_adc_request *req,\n\t\t\t\t  int channel)\n{\n\treq->channel = channel;\n\treq->phase_tbl = bank_phasing;\n\treq->conv_tbl = bank_conversion;\n\n\tswitch (channel) {\n\tcase CPCAP_ADC_AD0 ... CPCAP_ADC_USB_ID:\n\t\treq->bank_index = channel;\n\t\tbreak;\n\tcase CPCAP_ADC_AD8 ... CPCAP_ADC_TSY2_AD15:\n\t\treq->bank_index = channel - 8;\n\t\tbreak;\n\tcase CPCAP_ADC_BATTP_PI16:\n\t\treq->bank_index = CPCAP_ADC_BATTP;\n\t\tbreak;\n\tcase CPCAP_ADC_BATTI_PI17:\n\t\treq->bank_index = CPCAP_ADC_BATTI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_adc_read_st_die_temp(struct cpcap_adc *ddata,\n\t\t\t\t      int addr, int *val)\n{\n\tint error;\n\n\terror = regmap_read(ddata->reg, addr, val);\n\tif (error)\n\t\treturn error;\n\n\t*val -= 282;\n\t*val *= 114;\n\t*val += 25000;\n\n\treturn 0;\n}\n\nstatic int cpcap_adc_read(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct cpcap_adc *ddata = iio_priv(indio_dev);\n\tstruct cpcap_adc_request req;\n\tint error;\n\n\terror = cpcap_adc_init_request(&req, chan->channel);\n\tif (error)\n\t\treturn error;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&ddata->lock);\n\t\terror = cpcap_adc_start_bank(ddata, &req);\n\t\tif (error)\n\t\t\tgoto err_unlock;\n\t\terror = regmap_read(ddata->reg, chan->address, val);\n\t\tif (error)\n\t\t\tgoto err_unlock;\n\t\terror = cpcap_adc_stop_bank(ddata);\n\t\tif (error)\n\t\t\tgoto err_unlock;\n\t\tmutex_unlock(&ddata->lock);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tmutex_lock(&ddata->lock);\n\t\terror = cpcap_adc_start_bank(ddata, &req);\n\t\tif (error)\n\t\t\tgoto err_unlock;\n\t\tif ((ddata->vendor == CPCAP_VENDOR_ST) &&\n\t\t    (chan->channel == CPCAP_ADC_AD3)) {\n\t\t\terror = cpcap_adc_read_st_die_temp(ddata,\n\t\t\t\t\t\t\t   chan->address,\n\t\t\t\t\t\t\t   &req.result);\n\t\t\tif (error)\n\t\t\t\tgoto err_unlock;\n\t\t} else {\n\t\t\terror = cpcap_adc_read_bank_scaled(ddata, &req);\n\t\t\tif (error)\n\t\t\t\tgoto err_unlock;\n\t\t}\n\t\terror = cpcap_adc_stop_bank(ddata);\n\t\tif (error)\n\t\t\tgoto err_unlock;\n\t\tmutex_unlock(&ddata->lock);\n\t\t*val = req.result;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n\nerr_unlock:\n\tmutex_unlock(&ddata->lock);\n\tdev_err(ddata->dev, \"error reading ADC: %i\\n\", error);\n\n\treturn error;\n}\n\nstatic const struct iio_info cpcap_adc_info = {\n\t.read_raw = &cpcap_adc_read,\n};\n\n \nstatic const struct cpcap_adc_ato mapphone_adc = {\n\t.ato_in = 0x0480,\n\t.atox_in = 0,\n\t.adc_ps_factor_in = 0x0200,\n\t.atox_ps_factor_in = 0,\n\t.ato_out = 0,\n\t.atox_out = 0,\n\t.adc_ps_factor_out = 0,\n\t.atox_ps_factor_out = 0,\n};\n\nstatic const struct of_device_id cpcap_adc_id_table[] = {\n\t{\n\t\t.compatible = \"motorola,cpcap-adc\",\n\t},\n\t{\n\t\t.compatible = \"motorola,mapphone-cpcap-adc\",\n\t\t.data = &mapphone_adc,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cpcap_adc_id_table);\n\nstatic int cpcap_adc_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_adc *ddata;\n\tstruct iio_dev *indio_dev;\n\tint error;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*ddata));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate iio device\\n\");\n\n\t\treturn -ENOMEM;\n\t}\n\tddata = iio_priv(indio_dev);\n\tddata->ato = device_get_match_data(&pdev->dev);\n\tif (!ddata->ato)\n\t\treturn -ENODEV;\n\tddata->dev = &pdev->dev;\n\n\tmutex_init(&ddata->lock);\n\tinit_waitqueue_head(&ddata->wq_data_avail);\n\n\tindio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\tindio_dev->channels = cpcap_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cpcap_adc_channels);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &cpcap_adc_info;\n\n\tddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\terror = cpcap_get_vendor(ddata->dev, ddata->reg, &ddata->vendor);\n\tif (error)\n\t\treturn error;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tddata->irq = platform_get_irq_byname(pdev, \"adcdone\");\n\tif (ddata->irq < 0)\n\t\treturn -ENODEV;\n\n\terror = devm_request_threaded_irq(&pdev->dev, ddata->irq, NULL,\n\t\t\t\t\t  cpcap_adc_irq_thread,\n\t\t\t\t\t  IRQF_TRIGGER_NONE | IRQF_ONESHOT,\n\t\t\t\t\t  \"cpcap-adc\", indio_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"could not get irq: %i\\n\",\n\t\t\terror);\n\n\t\treturn error;\n\t}\n\n\terror = cpcap_adc_calibrate(ddata);\n\tif (error)\n\t\treturn error;\n\n\tdev_info(&pdev->dev, \"CPCAP ADC device probed\\n\");\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic struct platform_driver cpcap_adc_driver = {\n\t.driver = {\n\t\t.name = \"cpcap_adc\",\n\t\t.of_match_table = cpcap_adc_id_table,\n\t},\n\t.probe = cpcap_adc_probe,\n};\n\nmodule_platform_driver(cpcap_adc_driver);\n\nMODULE_ALIAS(\"platform:cpcap_adc\");\nMODULE_DESCRIPTION(\"CPCAP ADC driver\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}