{
  "module_name": "exynos_adc.c",
  "hash_id": "f89e0df1dfea4e3f4aedf5b3620cb737892d632f58a6ef4e1742a8501e081dcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/exynos_adc.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of_platform.h>\n#include <linux/err.h>\n#include <linux/input.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include <linux/platform_data/touchscreen-s3c2410.h>\n\n \n#define ADC_V1_CON(x)\t\t((x) + 0x00)\n#define ADC_V1_TSC(x)\t\t((x) + 0x04)\n#define ADC_V1_DLY(x)\t\t((x) + 0x08)\n#define ADC_V1_DATX(x)\t\t((x) + 0x0C)\n#define ADC_V1_DATY(x)\t\t((x) + 0x10)\n#define ADC_V1_UPDN(x)\t\t((x) + 0x14)\n#define ADC_V1_INTCLR(x)\t((x) + 0x18)\n#define ADC_V1_MUX(x)\t\t((x) + 0x1c)\n#define ADC_V1_CLRINTPNDNUP(x)\t((x) + 0x20)\n\n \n#define ADC_S3C2410_MUX(x)\t((x) + 0x18)\n\n \n#define ADC_V2_CON1(x)\t\t((x) + 0x00)\n#define ADC_V2_CON2(x)\t\t((x) + 0x04)\n#define ADC_V2_STAT(x)\t\t((x) + 0x08)\n#define ADC_V2_INT_EN(x)\t((x) + 0x10)\n#define ADC_V2_INT_ST(x)\t((x) + 0x14)\n#define ADC_V2_VER(x)\t\t((x) + 0x20)\n\n \n#define ADC_V1_CON_RES\t\t(1u << 16)\n#define ADC_V1_CON_PRSCEN\t(1u << 14)\n#define ADC_V1_CON_PRSCLV(x)\t(((x) & 0xFF) << 6)\n#define ADC_V1_CON_STANDBY\t(1u << 2)\n\n \n#define ADC_S3C2410_CON_SELMUX(x) (((x) & 7) << 3)\n#define ADC_S3C2410_DATX_MASK\t0x3FF\n#define ADC_S3C2416_CON_RES_SEL\t(1u << 3)\n\n \n#define ADC_S3C2410_MUX_TS\t0\n\n \n#define ADC_S3C2443_TSC_UD_SEN\t\t(1u << 8)\n#define ADC_S3C2410_TSC_YM_SEN\t\t(1u << 7)\n#define ADC_S3C2410_TSC_YP_SEN\t\t(1u << 6)\n#define ADC_S3C2410_TSC_XM_SEN\t\t(1u << 5)\n#define ADC_S3C2410_TSC_XP_SEN\t\t(1u << 4)\n#define ADC_S3C2410_TSC_PULL_UP_DISABLE\t(1u << 3)\n#define ADC_S3C2410_TSC_AUTO_PST\t(1u << 2)\n#define ADC_S3C2410_TSC_XY_PST(x)\t(((x) & 0x3) << 0)\n\n#define ADC_TSC_WAIT4INT (ADC_S3C2410_TSC_YM_SEN | \\\n\t\t\t ADC_S3C2410_TSC_YP_SEN | \\\n\t\t\t ADC_S3C2410_TSC_XP_SEN | \\\n\t\t\t ADC_S3C2410_TSC_XY_PST(3))\n\n#define ADC_TSC_AUTOPST\t(ADC_S3C2410_TSC_YM_SEN | \\\n\t\t\t ADC_S3C2410_TSC_YP_SEN | \\\n\t\t\t ADC_S3C2410_TSC_XP_SEN | \\\n\t\t\t ADC_S3C2410_TSC_AUTO_PST | \\\n\t\t\t ADC_S3C2410_TSC_XY_PST(0))\n\n \n#define ADC_V2_CON1_SOFT_RESET\t(1u << 2)\n\n#define ADC_V2_CON2_OSEL\t(1u << 10)\n#define ADC_V2_CON2_ESEL\t(1u << 9)\n#define ADC_V2_CON2_HIGHF\t(1u << 8)\n#define ADC_V2_CON2_C_TIME(x)\t(((x) & 7) << 4)\n#define ADC_V2_CON2_ACH_SEL(x)\t(((x) & 0xF) << 0)\n#define ADC_V2_CON2_ACH_MASK\t0xF\n\n#define MAX_ADC_V2_CHANNELS\t\t10\n#define MAX_ADC_V1_CHANNELS\t\t8\n#define MAX_EXYNOS3250_ADC_CHANNELS\t2\n#define MAX_EXYNOS4212_ADC_CHANNELS\t4\n#define MAX_S5PV210_ADC_CHANNELS\t10\n\n \n#define ADC_CON_EN_START\t(1u << 0)\n#define ADC_CON_EN_START_MASK\t(0x3 << 0)\n#define ADC_DATX_PRESSED\t(1u << 15)\n#define ADC_DATX_MASK\t\t0xFFF\n#define ADC_DATY_MASK\t\t0xFFF\n\n#define EXYNOS_ADC_TIMEOUT\t(msecs_to_jiffies(100))\n\n#define EXYNOS_ADCV1_PHY_OFFSET\t0x0718\n#define EXYNOS_ADCV2_PHY_OFFSET\t0x0720\n\nstruct exynos_adc {\n\tstruct exynos_adc_data\t*data;\n\tstruct device\t\t*dev;\n\tstruct input_dev\t*input;\n\tvoid __iomem\t\t*regs;\n\tstruct regmap\t\t*pmu_map;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*sclk;\n\tunsigned int\t\tirq;\n\tunsigned int\t\ttsirq;\n\tunsigned int\t\tdelay;\n\tstruct regulator\t*vdd;\n\n\tstruct completion\tcompletion;\n\n\tu32\t\t\tvalue;\n\tunsigned int            version;\n\n\tbool\t\t\tts_enabled;\n\n\tbool\t\t\tread_ts;\n\tu32\t\t\tts_x;\n\tu32\t\t\tts_y;\n\n\t \n\tstruct mutex\t\tlock;\n};\n\nstruct exynos_adc_data {\n\tint num_channels;\n\tbool needs_sclk;\n\tbool needs_adc_phy;\n\tint phy_offset;\n\tu32 mask;\n\n\tvoid (*init_hw)(struct exynos_adc *info);\n\tvoid (*exit_hw)(struct exynos_adc *info);\n\tvoid (*clear_irq)(struct exynos_adc *info);\n\tvoid (*start_conv)(struct exynos_adc *info, unsigned long addr);\n};\n\nstatic void exynos_adc_unprepare_clk(struct exynos_adc *info)\n{\n\tif (info->data->needs_sclk)\n\t\tclk_unprepare(info->sclk);\n\tclk_unprepare(info->clk);\n}\n\nstatic int exynos_adc_prepare_clk(struct exynos_adc *info)\n{\n\tint ret;\n\n\tret = clk_prepare(info->clk);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed preparing adc clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (info->data->needs_sclk) {\n\t\tret = clk_prepare(info->sclk);\n\t\tif (ret) {\n\t\t\tclk_unprepare(info->clk);\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"failed preparing sclk_adc clock: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void exynos_adc_disable_clk(struct exynos_adc *info)\n{\n\tif (info->data->needs_sclk)\n\t\tclk_disable(info->sclk);\n\tclk_disable(info->clk);\n}\n\nstatic int exynos_adc_enable_clk(struct exynos_adc *info)\n{\n\tint ret;\n\n\tret = clk_enable(info->clk);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed enabling adc clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (info->data->needs_sclk) {\n\t\tret = clk_enable(info->sclk);\n\t\tif (ret) {\n\t\t\tclk_disable(info->clk);\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"failed enabling sclk_adc clock: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void exynos_adc_v1_init_hw(struct exynos_adc *info)\n{\n\tu32 con1;\n\n\tif (info->data->needs_adc_phy)\n\t\tregmap_write(info->pmu_map, info->data->phy_offset, 1);\n\n\t \n\tcon1 =  ADC_V1_CON_PRSCLV(49) | ADC_V1_CON_PRSCEN;\n\n\t \n\tcon1 |= ADC_V1_CON_RES;\n\twritel(con1, ADC_V1_CON(info->regs));\n\n\t \n\twritel(info->delay, ADC_V1_DLY(info->regs));\n}\n\nstatic void exynos_adc_v1_exit_hw(struct exynos_adc *info)\n{\n\tu32 con;\n\n\tif (info->data->needs_adc_phy)\n\t\tregmap_write(info->pmu_map, info->data->phy_offset, 0);\n\n\tcon = readl(ADC_V1_CON(info->regs));\n\tcon |= ADC_V1_CON_STANDBY;\n\twritel(con, ADC_V1_CON(info->regs));\n}\n\nstatic void exynos_adc_v1_clear_irq(struct exynos_adc *info)\n{\n\twritel(1, ADC_V1_INTCLR(info->regs));\n}\n\nstatic void exynos_adc_v1_start_conv(struct exynos_adc *info,\n\t\t\t\t     unsigned long addr)\n{\n\tu32 con1;\n\n\twritel(addr, ADC_V1_MUX(info->regs));\n\n\tcon1 = readl(ADC_V1_CON(info->regs));\n\twritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\n}\n\n \nstatic const struct exynos_adc_data exynos4212_adc_data = {\n\t.num_channels\t= MAX_EXYNOS4212_ADC_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,\t \n\t.needs_adc_phy\t= true,\n\t.phy_offset\t= EXYNOS_ADCV1_PHY_OFFSET,\n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.clear_irq\t= exynos_adc_v1_clear_irq,\n\t.start_conv\t= exynos_adc_v1_start_conv,\n};\n\nstatic const struct exynos_adc_data exynos_adc_v1_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,\t \n\t.needs_adc_phy\t= true,\n\t.phy_offset\t= EXYNOS_ADCV1_PHY_OFFSET,\n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.clear_irq\t= exynos_adc_v1_clear_irq,\n\t.start_conv\t= exynos_adc_v1_start_conv,\n};\n\nstatic const struct exynos_adc_data exynos_adc_s5pv210_data = {\n\t.num_channels\t= MAX_S5PV210_ADC_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,\t \n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.clear_irq\t= exynos_adc_v1_clear_irq,\n\t.start_conv\t= exynos_adc_v1_start_conv,\n};\n\nstatic void exynos_adc_s3c2416_start_conv(struct exynos_adc *info,\n\t\t\t\t\t  unsigned long addr)\n{\n\tu32 con1;\n\n\t \n\tcon1 = readl(ADC_V1_CON(info->regs));\n\tcon1 |= ADC_S3C2416_CON_RES_SEL;\n\twritel(con1, ADC_V1_CON(info->regs));\n\n\t \n\twritel(addr, ADC_S3C2410_MUX(info->regs));\n\n\tcon1 = readl(ADC_V1_CON(info->regs));\n\twritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\n}\n\nstatic struct exynos_adc_data const exynos_adc_s3c2416_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,\t \n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.start_conv\t= exynos_adc_s3c2416_start_conv,\n};\n\nstatic void exynos_adc_s3c2443_start_conv(struct exynos_adc *info,\n\t\t\t\t\t  unsigned long addr)\n{\n\tu32 con1;\n\n\t \n\twritel(addr, ADC_S3C2410_MUX(info->regs));\n\n\tcon1 = readl(ADC_V1_CON(info->regs));\n\twritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\n}\n\nstatic struct exynos_adc_data const exynos_adc_s3c2443_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_S3C2410_DATX_MASK,  \n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.start_conv\t= exynos_adc_s3c2443_start_conv,\n};\n\nstatic void exynos_adc_s3c64xx_start_conv(struct exynos_adc *info,\n\t\t\t\t\t  unsigned long addr)\n{\n\tu32 con1;\n\n\tcon1 = readl(ADC_V1_CON(info->regs));\n\tcon1 &= ~ADC_S3C2410_CON_SELMUX(0x7);\n\tcon1 |= ADC_S3C2410_CON_SELMUX(addr);\n\twritel(con1 | ADC_CON_EN_START, ADC_V1_CON(info->regs));\n}\n\nstatic struct exynos_adc_data const exynos_adc_s3c24xx_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_S3C2410_DATX_MASK,  \n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.start_conv\t= exynos_adc_s3c64xx_start_conv,\n};\n\nstatic struct exynos_adc_data const exynos_adc_s3c64xx_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,\t \n\n\t.init_hw\t= exynos_adc_v1_init_hw,\n\t.exit_hw\t= exynos_adc_v1_exit_hw,\n\t.clear_irq\t= exynos_adc_v1_clear_irq,\n\t.start_conv\t= exynos_adc_s3c64xx_start_conv,\n};\n\nstatic void exynos_adc_v2_init_hw(struct exynos_adc *info)\n{\n\tu32 con1, con2;\n\n\tif (info->data->needs_adc_phy)\n\t\tregmap_write(info->pmu_map, info->data->phy_offset, 1);\n\n\tcon1 = ADC_V2_CON1_SOFT_RESET;\n\twritel(con1, ADC_V2_CON1(info->regs));\n\n\tcon2 = ADC_V2_CON2_OSEL | ADC_V2_CON2_ESEL |\n\t\tADC_V2_CON2_HIGHF | ADC_V2_CON2_C_TIME(0);\n\twritel(con2, ADC_V2_CON2(info->regs));\n\n\t \n\twritel(1, ADC_V2_INT_EN(info->regs));\n}\n\nstatic void exynos_adc_v2_exit_hw(struct exynos_adc *info)\n{\n\tu32 con;\n\n\tif (info->data->needs_adc_phy)\n\t\tregmap_write(info->pmu_map, info->data->phy_offset, 0);\n\n\tcon = readl(ADC_V2_CON1(info->regs));\n\tcon &= ~ADC_CON_EN_START;\n\twritel(con, ADC_V2_CON1(info->regs));\n}\n\nstatic void exynos_adc_v2_clear_irq(struct exynos_adc *info)\n{\n\twritel(1, ADC_V2_INT_ST(info->regs));\n}\n\nstatic void exynos_adc_v2_start_conv(struct exynos_adc *info,\n\t\t\t\t     unsigned long addr)\n{\n\tu32 con1, con2;\n\n\tcon2 = readl(ADC_V2_CON2(info->regs));\n\tcon2 &= ~ADC_V2_CON2_ACH_MASK;\n\tcon2 |= ADC_V2_CON2_ACH_SEL(addr);\n\twritel(con2, ADC_V2_CON2(info->regs));\n\n\tcon1 = readl(ADC_V2_CON1(info->regs));\n\twritel(con1 | ADC_CON_EN_START, ADC_V2_CON1(info->regs));\n}\n\nstatic const struct exynos_adc_data exynos_adc_v2_data = {\n\t.num_channels\t= MAX_ADC_V2_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,  \n\t.needs_adc_phy\t= true,\n\t.phy_offset\t= EXYNOS_ADCV2_PHY_OFFSET,\n\n\t.init_hw\t= exynos_adc_v2_init_hw,\n\t.exit_hw\t= exynos_adc_v2_exit_hw,\n\t.clear_irq\t= exynos_adc_v2_clear_irq,\n\t.start_conv\t= exynos_adc_v2_start_conv,\n};\n\nstatic const struct exynos_adc_data exynos3250_adc_data = {\n\t.num_channels\t= MAX_EXYNOS3250_ADC_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,  \n\t.needs_sclk\t= true,\n\t.needs_adc_phy\t= true,\n\t.phy_offset\t= EXYNOS_ADCV1_PHY_OFFSET,\n\n\t.init_hw\t= exynos_adc_v2_init_hw,\n\t.exit_hw\t= exynos_adc_v2_exit_hw,\n\t.clear_irq\t= exynos_adc_v2_clear_irq,\n\t.start_conv\t= exynos_adc_v2_start_conv,\n};\n\nstatic void exynos_adc_exynos7_init_hw(struct exynos_adc *info)\n{\n\tu32 con1, con2;\n\n\tcon1 = ADC_V2_CON1_SOFT_RESET;\n\twritel(con1, ADC_V2_CON1(info->regs));\n\n\tcon2 = readl(ADC_V2_CON2(info->regs));\n\tcon2 &= ~ADC_V2_CON2_C_TIME(7);\n\tcon2 |= ADC_V2_CON2_C_TIME(0);\n\twritel(con2, ADC_V2_CON2(info->regs));\n\n\t \n\twritel(1, ADC_V2_INT_EN(info->regs));\n}\n\nstatic const struct exynos_adc_data exynos7_adc_data = {\n\t.num_channels\t= MAX_ADC_V1_CHANNELS,\n\t.mask\t\t= ADC_DATX_MASK,  \n\n\t.init_hw\t= exynos_adc_exynos7_init_hw,\n\t.exit_hw\t= exynos_adc_v2_exit_hw,\n\t.clear_irq\t= exynos_adc_v2_clear_irq,\n\t.start_conv\t= exynos_adc_v2_start_conv,\n};\n\nstatic const struct of_device_id exynos_adc_match[] = {\n\t{\n\t\t.compatible = \"samsung,s3c2410-adc\",\n\t\t.data = &exynos_adc_s3c24xx_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2416-adc\",\n\t\t.data = &exynos_adc_s3c2416_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2440-adc\",\n\t\t.data = &exynos_adc_s3c24xx_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2443-adc\",\n\t\t.data = &exynos_adc_s3c2443_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c6410-adc\",\n\t\t.data = &exynos_adc_s3c64xx_data,\n\t}, {\n\t\t.compatible = \"samsung,s5pv210-adc\",\n\t\t.data = &exynos_adc_s5pv210_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-adc\",\n\t\t.data = &exynos4212_adc_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos-adc-v1\",\n\t\t.data = &exynos_adc_v1_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos-adc-v2\",\n\t\t.data = &exynos_adc_v2_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos3250-adc\",\n\t\t.data = &exynos3250_adc_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos7-adc\",\n\t\t.data = &exynos7_adc_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_adc_match);\n\nstatic struct exynos_adc_data *exynos_adc_get_data(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_node(exynos_adc_match, pdev->dev.of_node);\n\treturn (struct exynos_adc_data *)match->data;\n}\n\nstatic int exynos_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val,\n\t\t\t\tint *val2,\n\t\t\t\tlong mask)\n{\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\tunsigned long timeout;\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_SCALE) {\n\t\tret = regulator_get_voltage(info->vdd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\t*val = ret / 1000;\n\t\t*val2 = info->data->mask;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\t} else if (mask != IIO_CHAN_INFO_RAW) {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&info->lock);\n\treinit_completion(&info->completion);\n\n\t \n\tif (info->data->start_conv)\n\t\tinfo->data->start_conv(info, chan->address);\n\n\ttimeout = wait_for_completion_timeout(&info->completion,\n\t\t\t\t\t      EXYNOS_ADC_TIMEOUT);\n\tif (timeout == 0) {\n\t\tdev_warn(&indio_dev->dev, \"Conversion timed out! Resetting\\n\");\n\t\tif (info->data->init_hw)\n\t\t\tinfo->data->init_hw(info);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t*val = info->value;\n\t\t*val2 = 0;\n\t\tret = IIO_VAL_INT;\n\t}\n\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic int exynos_read_s3c64xx_ts(struct iio_dev *indio_dev, int *x, int *y)\n{\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\tunsigned long timeout;\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tinfo->read_ts = true;\n\n\treinit_completion(&info->completion);\n\n\twritel(ADC_S3C2410_TSC_PULL_UP_DISABLE | ADC_TSC_AUTOPST,\n\t       ADC_V1_TSC(info->regs));\n\n\t \n\tinfo->data->start_conv(info, ADC_S3C2410_MUX_TS);\n\n\ttimeout = wait_for_completion_timeout(&info->completion,\n\t\t\t\t\t      EXYNOS_ADC_TIMEOUT);\n\tif (timeout == 0) {\n\t\tdev_warn(&indio_dev->dev, \"Conversion timed out! Resetting\\n\");\n\t\tif (info->data->init_hw)\n\t\t\tinfo->data->init_hw(info);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t*x = info->ts_x;\n\t\t*y = info->ts_y;\n\t\tret = 0;\n\t}\n\n\tinfo->read_ts = false;\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t exynos_adc_isr(int irq, void *dev_id)\n{\n\tstruct exynos_adc *info = dev_id;\n\tu32 mask = info->data->mask;\n\n\t \n\tif (info->read_ts) {\n\t\tinfo->ts_x = readl(ADC_V1_DATX(info->regs));\n\t\tinfo->ts_y = readl(ADC_V1_DATY(info->regs));\n\t\twritel(ADC_TSC_WAIT4INT | ADC_S3C2443_TSC_UD_SEN, ADC_V1_TSC(info->regs));\n\t} else {\n\t\tinfo->value = readl(ADC_V1_DATX(info->regs)) & mask;\n\t}\n\n\t \n\tif (info->data->clear_irq)\n\t\tinfo->data->clear_irq(info);\n\n\tcomplete(&info->completion);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t exynos_ts_isr(int irq, void *dev_id)\n{\n\tstruct exynos_adc *info = dev_id;\n\tstruct iio_dev *dev = dev_get_drvdata(info->dev);\n\tu32 x, y;\n\tbool pressed;\n\tint ret;\n\n\twhile (READ_ONCE(info->ts_enabled)) {\n\t\tret = exynos_read_s3c64xx_ts(dev, &x, &y);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tbreak;\n\n\t\tpressed = x & y & ADC_DATX_PRESSED;\n\t\tif (!pressed) {\n\t\t\tinput_report_key(info->input, BTN_TOUCH, 0);\n\t\t\tinput_sync(info->input);\n\t\t\tbreak;\n\t\t}\n\n\t\tinput_report_abs(info->input, ABS_X, x & ADC_DATX_MASK);\n\t\tinput_report_abs(info->input, ABS_Y, y & ADC_DATY_MASK);\n\t\tinput_report_key(info->input, BTN_TOUCH, 1);\n\t\tinput_sync(info->input);\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\twritel(0, ADC_V1_CLRINTPNDNUP(info->regs));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int exynos_adc_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned reg, unsigned writeval,\n\t\t\t      unsigned *readval)\n{\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\n\tif (readval == NULL)\n\t\treturn -EINVAL;\n\n\t*readval = readl(info->regs + reg);\n\n\treturn 0;\n}\n\nstatic const struct iio_info exynos_adc_iio_info = {\n\t.read_raw = &exynos_read_raw,\n\t.debugfs_reg_access = &exynos_adc_reg_access,\n};\n\n#define ADC_CHANNEL(_index, _id) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _index,\t\t\t\t\\\n\t.address = _index,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.datasheet_name = _id,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec exynos_adc_iio_channels[] = {\n\tADC_CHANNEL(0, \"adc0\"),\n\tADC_CHANNEL(1, \"adc1\"),\n\tADC_CHANNEL(2, \"adc2\"),\n\tADC_CHANNEL(3, \"adc3\"),\n\tADC_CHANNEL(4, \"adc4\"),\n\tADC_CHANNEL(5, \"adc5\"),\n\tADC_CHANNEL(6, \"adc6\"),\n\tADC_CHANNEL(7, \"adc7\"),\n\tADC_CHANNEL(8, \"adc8\"),\n\tADC_CHANNEL(9, \"adc9\"),\n};\n\nstatic int exynos_adc_remove_devices(struct device *dev, void *c)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tplatform_device_unregister(pdev);\n\n\treturn 0;\n}\n\nstatic int exynos_adc_ts_open(struct input_dev *dev)\n{\n\tstruct exynos_adc *info = input_get_drvdata(dev);\n\n\tWRITE_ONCE(info->ts_enabled, true);\n\tenable_irq(info->tsirq);\n\n\treturn 0;\n}\n\nstatic void exynos_adc_ts_close(struct input_dev *dev)\n{\n\tstruct exynos_adc *info = input_get_drvdata(dev);\n\n\tWRITE_ONCE(info->ts_enabled, false);\n\tdisable_irq(info->tsirq);\n}\n\nstatic int exynos_adc_ts_init(struct exynos_adc *info)\n{\n\tint ret;\n\n\tif (info->tsirq <= 0)\n\t\treturn -ENODEV;\n\n\tinfo->input = input_allocate_device();\n\tif (!info->input)\n\t\treturn -ENOMEM;\n\n\tinfo->input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinfo->input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_set_abs_params(info->input, ABS_X, 0, 0x3FF, 0, 0);\n\tinput_set_abs_params(info->input, ABS_Y, 0, 0x3FF, 0, 0);\n\n\tinfo->input->name = \"S3C24xx TouchScreen\";\n\tinfo->input->id.bustype = BUS_HOST;\n\tinfo->input->open = exynos_adc_ts_open;\n\tinfo->input->close = exynos_adc_ts_close;\n\n\tinput_set_drvdata(info->input, info);\n\n\tret = input_register_device(info->input);\n\tif (ret) {\n\t\tinput_free_device(info->input);\n\t\treturn ret;\n\t}\n\n\tret = request_threaded_irq(info->tsirq, NULL, exynos_ts_isr,\n\t\t\t\t   IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t   \"touchscreen\", info);\n\tif (ret)\n\t\tinput_unregister_device(info->input);\n\n\treturn ret;\n}\n\nstatic int exynos_adc_probe(struct platform_device *pdev)\n{\n\tstruct exynos_adc *info = NULL;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct s3c2410_ts_mach_info *pdata = dev_get_platdata(&pdev->dev);\n\tstruct iio_dev *indio_dev = NULL;\n\tbool has_ts = false;\n\tint ret;\n\tint irq;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct exynos_adc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo = iio_priv(indio_dev);\n\n\tinfo->data = exynos_adc_get_data(pdev);\n\tif (!info->data) {\n\t\tdev_err(&pdev->dev, \"failed getting exynos_adc_data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\n\tif (info->data->needs_adc_phy) {\n\t\tinfo->pmu_map = syscon_regmap_lookup_by_phandle(\n\t\t\t\t\tpdev->dev.of_node,\n\t\t\t\t\t\"samsung,syscon-phandle\");\n\t\tif (IS_ERR(info->pmu_map)) {\n\t\t\tdev_err(&pdev->dev, \"syscon regmap lookup failed.\\n\");\n\t\t\treturn PTR_ERR(info->pmu_map);\n\t\t}\n\t}\n\n\t \n\tif (IS_REACHABLE(CONFIG_INPUT)) {\n\t\thas_ts = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t       \"has-touchscreen\") || pdata;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tinfo->irq = irq;\n\n\tif (has_ts) {\n\t\tirq = platform_get_irq(pdev, 1);\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn irq;\n\n\t\tinfo->tsirq = irq;\n\t} else {\n\t\tinfo->tsirq = -1;\n\t}\n\n\tinfo->dev = &pdev->dev;\n\n\tinit_completion(&info->completion);\n\n\tinfo->clk = devm_clk_get(&pdev->dev, \"adc\");\n\tif (IS_ERR(info->clk)) {\n\t\tdev_err(&pdev->dev, \"failed getting clock, err = %ld\\n\",\n\t\t\t\t\t\t\tPTR_ERR(info->clk));\n\t\treturn PTR_ERR(info->clk);\n\t}\n\n\tif (info->data->needs_sclk) {\n\t\tinfo->sclk = devm_clk_get(&pdev->dev, \"sclk\");\n\t\tif (IS_ERR(info->sclk)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed getting sclk clock, err = %ld\\n\",\n\t\t\t\tPTR_ERR(info->sclk));\n\t\t\treturn PTR_ERR(info->sclk);\n\t\t}\n\t}\n\n\tinfo->vdd = devm_regulator_get(&pdev->dev, \"vdd\");\n\tif (IS_ERR(info->vdd))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->vdd),\n\t\t\t\t     \"failed getting regulator\");\n\n\tret = regulator_enable(info->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_adc_prepare_clk(info);\n\tif (ret)\n\t\tgoto err_disable_reg;\n\n\tret = exynos_adc_enable_clk(info);\n\tif (ret)\n\t\tgoto err_unprepare_clk;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &exynos_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = exynos_adc_iio_channels;\n\tindio_dev->num_channels = info->data->num_channels;\n\n\tmutex_init(&info->lock);\n\n\tret = request_irq(info->irq, exynos_adc_isr,\n\t\t\t\t\t0, dev_name(&pdev->dev), info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed requesting irq, irq = %d\\n\",\n\t\t\t\t\t\t\tinfo->irq);\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tif (info->data->init_hw)\n\t\tinfo->data->init_hw(info);\n\n\tif (pdata)\n\t\tinfo->delay = pdata->delay;\n\telse\n\t\tinfo->delay = 10000;\n\n\tif (has_ts)\n\t\tret = exynos_adc_ts_init(info);\n\tif (ret)\n\t\tgoto err_iio;\n\n\tret = of_platform_populate(np, exynos_adc_match, NULL, &indio_dev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed adding child nodes\\n\");\n\t\tgoto err_of_populate;\n\t}\n\n\treturn 0;\n\nerr_of_populate:\n\tdevice_for_each_child(&indio_dev->dev, NULL,\n\t\t\t\texynos_adc_remove_devices);\n\tif (has_ts) {\n\t\tinput_unregister_device(info->input);\n\t\tfree_irq(info->tsirq, info);\n\t}\nerr_iio:\n\tiio_device_unregister(indio_dev);\nerr_irq:\n\tfree_irq(info->irq, info);\nerr_disable_clk:\n\tif (info->data->exit_hw)\n\t\tinfo->data->exit_hw(info);\n\texynos_adc_disable_clk(info);\nerr_unprepare_clk:\n\texynos_adc_unprepare_clk(info);\nerr_disable_reg:\n\tregulator_disable(info->vdd);\n\treturn ret;\n}\n\nstatic int exynos_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\n\tif (IS_REACHABLE(CONFIG_INPUT) && info->input) {\n\t\tfree_irq(info->tsirq, info);\n\t\tinput_unregister_device(info->input);\n\t}\n\tdevice_for_each_child(&indio_dev->dev, NULL,\n\t\t\t\texynos_adc_remove_devices);\n\tiio_device_unregister(indio_dev);\n\tfree_irq(info->irq, info);\n\tif (info->data->exit_hw)\n\t\tinfo->data->exit_hw(info);\n\texynos_adc_disable_clk(info);\n\texynos_adc_unprepare_clk(info);\n\tregulator_disable(info->vdd);\n\n\treturn 0;\n}\n\nstatic int exynos_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\n\tif (info->data->exit_hw)\n\t\tinfo->data->exit_hw(info);\n\texynos_adc_disable_clk(info);\n\tregulator_disable(info->vdd);\n\n\treturn 0;\n}\n\nstatic int exynos_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct exynos_adc *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(info->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_adc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->data->init_hw)\n\t\tinfo->data->init_hw(info);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(exynos_adc_pm_ops, exynos_adc_suspend,\n\t\t\t\texynos_adc_resume);\n\nstatic struct platform_driver exynos_adc_driver = {\n\t.probe\t\t= exynos_adc_probe,\n\t.remove\t\t= exynos_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-adc\",\n\t\t.of_match_table = exynos_adc_match,\n\t\t.pm\t= pm_sleep_ptr(&exynos_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(exynos_adc_driver);\n\nMODULE_AUTHOR(\"Naveen Krishna Chatradhi <ch.naveen@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung EXYNOS5 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}