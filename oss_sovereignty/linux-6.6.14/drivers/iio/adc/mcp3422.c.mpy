{
  "module_name": "mcp3422.c",
  "hash_id": "4ea140d14a3caedf709676f3e6d141d05be13cd91498d7dca67c41944faee3cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mcp3422.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define MCP3422_CHANNEL_MASK\t0x60\n#define MCP3422_PGA_MASK\t0x03\n#define MCP3422_SRATE_MASK\t0x0C\n#define MCP3422_SRATE_240\t0x0\n#define MCP3422_SRATE_60\t0x1\n#define MCP3422_SRATE_15\t0x2\n#define MCP3422_SRATE_3\t0x3\n#define MCP3422_PGA_1\t0\n#define MCP3422_PGA_2\t1\n#define MCP3422_PGA_4\t2\n#define MCP3422_PGA_8\t3\n#define MCP3422_CONT_SAMPLING\t0x10\n\n#define MCP3422_CHANNEL(config)\t(((config) & MCP3422_CHANNEL_MASK) >> 5)\n#define MCP3422_PGA(config)\t((config) & MCP3422_PGA_MASK)\n#define MCP3422_SAMPLE_RATE(config)\t(((config) & MCP3422_SRATE_MASK) >> 2)\n\n#define MCP3422_CHANNEL_VALUE(value) (((value) << 5) & MCP3422_CHANNEL_MASK)\n#define MCP3422_PGA_VALUE(value) ((value) & MCP3422_PGA_MASK)\n#define MCP3422_SAMPLE_RATE_VALUE(value) ((value << 2) & MCP3422_SRATE_MASK)\n\n#define MCP3422_CHAN(_index) \\\n\t{ \\\n\t\t.type = IIO_VOLTAGE, \\\n\t\t.indexed = 1, \\\n\t\t.channel = _index, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) \\\n\t\t\t\t| BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t}\n\nstatic const int mcp3422_scales[4][4] = {\n\t{ 1000000, 500000, 250000, 125000 },\n\t{ 250000,  125000, 62500,  31250  },\n\t{ 62500,   31250,  15625,  7812   },\n\t{ 15625,   7812,   3906,   1953   } };\n\n \nstatic const int mcp3422_read_times[4] = {\n\t[MCP3422_SRATE_240] = 1000 / 240,\n\t[MCP3422_SRATE_60] = 1000 / 60,\n\t[MCP3422_SRATE_15] = 1000 / 15,\n\t[MCP3422_SRATE_3] = 1000 / 3 };\n\n \nstatic const int mcp3422_sample_rates[4] = {\n\t[MCP3422_SRATE_240] = 240,\n\t[MCP3422_SRATE_60] = 60,\n\t[MCP3422_SRATE_15] = 15,\n\t[MCP3422_SRATE_3] = 3 };\n\n \nstatic const int mcp3422_sign_extend[4] = {\n\t[MCP3422_SRATE_240] = 11,\n\t[MCP3422_SRATE_60] = 13,\n\t[MCP3422_SRATE_15] = 15,\n\t[MCP3422_SRATE_3] = 17 };\n\n \nstruct mcp3422 {\n\tstruct i2c_client *i2c;\n\tu8 id;\n\tu8 config;\n\tu8 pga[4];\n\tstruct mutex lock;\n};\n\nstatic int mcp3422_update_config(struct mcp3422 *adc, u8 newconfig)\n{\n\tint ret;\n\n\tret = i2c_master_send(adc->i2c, &newconfig, 1);\n\tif (ret > 0) {\n\t\tadc->config = newconfig;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int mcp3422_read(struct mcp3422 *adc, int *value, u8 *config)\n{\n\tint ret = 0;\n\tu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\n\tu8 buf[4] = {0, 0, 0, 0};\n\tu32 temp;\n\n\tif (sample_rate == MCP3422_SRATE_3) {\n\t\tret = i2c_master_recv(adc->i2c, buf, 4);\n\t\ttemp = get_unaligned_be24(&buf[0]);\n\t\t*config = buf[3];\n\t} else {\n\t\tret = i2c_master_recv(adc->i2c, buf, 3);\n\t\ttemp = get_unaligned_be16(&buf[0]);\n\t\t*config = buf[2];\n\t}\n\n\t*value = sign_extend32(temp, mcp3422_sign_extend[sample_rate]);\n\n\treturn ret;\n}\n\nstatic int mcp3422_read_channel(struct mcp3422 *adc,\n\t\t\t\tstruct iio_chan_spec const *channel, int *value)\n{\n\tint ret;\n\tu8 config;\n\tu8 req_channel = channel->channel;\n\n\tmutex_lock(&adc->lock);\n\n\tif (req_channel != MCP3422_CHANNEL(adc->config)) {\n\t\tconfig = adc->config;\n\t\tconfig &= ~MCP3422_CHANNEL_MASK;\n\t\tconfig |= MCP3422_CHANNEL_VALUE(req_channel);\n\t\tconfig &= ~MCP3422_PGA_MASK;\n\t\tconfig |= MCP3422_PGA_VALUE(adc->pga[req_channel]);\n\t\tret = mcp3422_update_config(adc, config);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&adc->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tmsleep(mcp3422_read_times[MCP3422_SAMPLE_RATE(adc->config)]);\n\t}\n\n\tret = mcp3422_read(adc, value, &config);\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int mcp3422_read_raw(struct iio_dev *iio,\n\t\t\tstruct iio_chan_spec const *channel, int *val1,\n\t\t\tint *val2, long mask)\n{\n\tstruct mcp3422 *adc = iio_priv(iio);\n\tint err;\n\n\tu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\n\tu8 pga\t\t = MCP3422_PGA(adc->config);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = mcp3422_read_channel(adc, channel, val1);\n\t\tif (err < 0)\n\t\t\treturn -EINVAL;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\n\t\t*val1 = 0;\n\t\t*val2 = mcp3422_scales[sample_rate][pga];\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val1 = mcp3422_sample_rates[MCP3422_SAMPLE_RATE(adc->config)];\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mcp3422_write_raw(struct iio_dev *iio,\n\t\t\tstruct iio_chan_spec const *channel, int val1,\n\t\t\tint val2, long mask)\n{\n\tstruct mcp3422 *adc = iio_priv(iio);\n\tu8 temp;\n\tu8 config = adc->config;\n\tu8 req_channel = channel->channel;\n\tu8 sample_rate = MCP3422_SAMPLE_RATE(config);\n\tu8 i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val1 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mcp3422_scales[0]); i++) {\n\t\t\tif (val2 == mcp3422_scales[sample_rate][i]) {\n\t\t\t\tadc->pga[req_channel] = i;\n\n\t\t\t\tconfig &= ~MCP3422_CHANNEL_MASK;\n\t\t\t\tconfig |= MCP3422_CHANNEL_VALUE(req_channel);\n\t\t\t\tconfig &= ~MCP3422_PGA_MASK;\n\t\t\t\tconfig |= MCP3422_PGA_VALUE(adc->pga[req_channel]);\n\n\t\t\t\treturn mcp3422_update_config(adc, config);\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (val1) {\n\t\tcase 240:\n\t\t\ttemp = MCP3422_SRATE_240;\n\t\t\tbreak;\n\t\tcase 60:\n\t\t\ttemp = MCP3422_SRATE_60;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\ttemp = MCP3422_SRATE_15;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (adc->id > 4)\n\t\t\t\treturn -EINVAL;\n\t\t\ttemp = MCP3422_SRATE_3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tconfig &= ~MCP3422_CHANNEL_MASK;\n\t\tconfig |= MCP3422_CHANNEL_VALUE(req_channel);\n\t\tconfig &= ~MCP3422_SRATE_MASK;\n\t\tconfig |= MCP3422_SAMPLE_RATE_VALUE(temp);\n\n\t\treturn mcp3422_update_config(adc, config);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mcp3422_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t mcp3422_show_samp_freqs(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mcp3422 *adc = iio_priv(dev_to_iio_dev(dev));\n\n\tif (adc->id > 4)\n\t\treturn sprintf(buf, \"240 60 15\\n\");\n\n\treturn sprintf(buf, \"240 60 15 3\\n\");\n}\n\nstatic ssize_t mcp3422_show_scales(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mcp3422 *adc = iio_priv(dev_to_iio_dev(dev));\n\tu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\n\n\treturn sprintf(buf, \"0.%09u 0.%09u 0.%09u 0.%09u\\n\",\n\t\tmcp3422_scales[sample_rate][0],\n\t\tmcp3422_scales[sample_rate][1],\n\t\tmcp3422_scales[sample_rate][2],\n\t\tmcp3422_scales[sample_rate][3]);\n}\n\nstatic IIO_DEVICE_ATTR(sampling_frequency_available, S_IRUGO,\n\t\tmcp3422_show_samp_freqs, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_voltage_scale_available, S_IRUGO,\n\t\tmcp3422_show_scales, NULL, 0);\n\nstatic struct attribute *mcp3422_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mcp3422_attribute_group = {\n\t.attrs = mcp3422_attributes,\n};\n\nstatic const struct iio_chan_spec mcp3421_channels[] = {\n\tMCP3422_CHAN(0),\n};\n\nstatic const struct iio_chan_spec mcp3422_channels[] = {\n\tMCP3422_CHAN(0),\n\tMCP3422_CHAN(1),\n};\n\nstatic const struct iio_chan_spec mcp3424_channels[] = {\n\tMCP3422_CHAN(0),\n\tMCP3422_CHAN(1),\n\tMCP3422_CHAN(2),\n\tMCP3422_CHAN(3),\n};\n\nstatic const struct iio_info mcp3422_info = {\n\t.read_raw = mcp3422_read_raw,\n\t.write_raw = mcp3422_write_raw,\n\t.write_raw_get_fmt = mcp3422_write_raw_get_fmt,\n\t.attrs = &mcp3422_attribute_group,\n};\n\nstatic int mcp3422_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct mcp3422 *adc;\n\tint err;\n\tu8 config;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->i2c = client;\n\tadc->id = (u8)(id->driver_data);\n\n\tmutex_init(&adc->lock);\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mcp3422_info;\n\n\tswitch (adc->id) {\n\tcase 1:\n\tcase 5:\n\t\tindio_dev->channels = mcp3421_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(mcp3421_channels);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 6:\n\tcase 7:\n\t\tindio_dev->channels = mcp3422_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(mcp3422_channels);\n\t\tbreak;\n\tcase 4:\n\tcase 8:\n\t\tindio_dev->channels = mcp3424_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(mcp3424_channels);\n\t\tbreak;\n\t}\n\n\t \n\tconfig = (MCP3422_CONT_SAMPLING\n\t\t| MCP3422_CHANNEL_VALUE(0)\n\t\t| MCP3422_PGA_VALUE(MCP3422_PGA_1)\n\t\t| MCP3422_SAMPLE_RATE_VALUE(MCP3422_SRATE_240));\n\terr = mcp3422_update_config(adc, config);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_iio_device_register(&client->dev, indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id mcp3422_id[] = {\n\t{ \"mcp3421\", 1 },\n\t{ \"mcp3422\", 2 },\n\t{ \"mcp3423\", 3 },\n\t{ \"mcp3424\", 4 },\n\t{ \"mcp3425\", 5 },\n\t{ \"mcp3426\", 6 },\n\t{ \"mcp3427\", 7 },\n\t{ \"mcp3428\", 8 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcp3422_id);\n\nstatic const struct of_device_id mcp3422_of_match[] = {\n\t{ .compatible = \"mcp3422\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp3422_of_match);\n\nstatic struct i2c_driver mcp3422_driver = {\n\t.driver = {\n\t\t.name = \"mcp3422\",\n\t\t.of_match_table = mcp3422_of_match,\n\t},\n\t.probe = mcp3422_probe,\n\t.id_table = mcp3422_id,\n};\nmodule_i2c_driver(mcp3422_driver);\n\nMODULE_AUTHOR(\"Angelo Compagnucci <angelo.compagnucci@gmail.com>\");\nMODULE_DESCRIPTION(\"Microchip mcp3421/2/3/4/5/6/7/8 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}