{
  "module_name": "ad7192.c",
  "hash_id": "c4f5542f85ccc755f0c5dace601212c34a699e8db4d52216a1370a440d7672d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7192.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n\n \n#define AD7192_REG_COMM\t\t0  \n#define AD7192_REG_STAT\t\t0  \n#define AD7192_REG_MODE\t\t1  \n#define AD7192_REG_CONF\t\t2  \n#define AD7192_REG_DATA\t\t3  \n#define AD7192_REG_ID\t\t4  \n#define AD7192_REG_GPOCON\t5  \n#define AD7192_REG_OFFSET\t6  \n\t\t\t\t   \n#define AD7192_REG_FULLSALE\t7  \n\t\t\t\t   \n\n \n#define AD7192_COMM_WEN\t\tBIT(7)  \n#define AD7192_COMM_WRITE\t0  \n#define AD7192_COMM_READ\tBIT(6)  \n#define AD7192_COMM_ADDR(x)\t(((x) & 0x7) << 3)  \n#define AD7192_COMM_CREAD\tBIT(2)  \n\n \n#define AD7192_STAT_RDY\t\tBIT(7)  \n#define AD7192_STAT_ERR\t\tBIT(6)  \n#define AD7192_STAT_NOREF\tBIT(5)  \n#define AD7192_STAT_PARITY\tBIT(4)  \n#define AD7192_STAT_CH3\t\tBIT(2)  \n#define AD7192_STAT_CH2\t\tBIT(1)  \n#define AD7192_STAT_CH1\t\tBIT(0)  \n\n \n#define AD7192_MODE_SEL(x)\t(((x) & 0x7) << 21)  \n#define AD7192_MODE_SEL_MASK\t(0x7 << 21)  \n#define AD7192_MODE_STA(x)\t(((x) & 0x1) << 20)  \n#define AD7192_MODE_STA_MASK\tBIT(20)  \n#define AD7192_MODE_CLKSRC(x)\t(((x) & 0x3) << 18)  \n#define AD7192_MODE_SINC3\tBIT(15)  \n#define AD7192_MODE_ENPAR\tBIT(13)  \n#define AD7192_MODE_CLKDIV\tBIT(12)  \n#define AD7192_MODE_SCYCLE\tBIT(11)  \n#define AD7192_MODE_REJ60\tBIT(10)  \n#define AD7192_MODE_RATE(x)\t((x) & 0x3FF)  \n\n \n#define AD7192_MODE_CONT\t\t0  \n#define AD7192_MODE_SINGLE\t\t1  \n#define AD7192_MODE_IDLE\t\t2  \n#define AD7192_MODE_PWRDN\t\t3  \n#define AD7192_MODE_CAL_INT_ZERO\t4  \n#define AD7192_MODE_CAL_INT_FULL\t5  \n#define AD7192_MODE_CAL_SYS_ZERO\t6  \n#define AD7192_MODE_CAL_SYS_FULL\t7  \n\n \n#define AD7192_CLK_EXT_MCLK1_2\t\t0  \n\t\t\t\t\t   \n#define AD7192_CLK_EXT_MCLK2\t\t1  \n#define AD7192_CLK_INT\t\t\t2  \n\t\t\t\t\t   \n#define AD7192_CLK_INT_CO\t\t3  \n\t\t\t\t\t   \n\n \n\n#define AD7192_CONF_CHOP\tBIT(23)  \n#define AD7192_CONF_ACX\t\tBIT(22)  \n#define AD7192_CONF_REFSEL\tBIT(20)  \n#define AD7192_CONF_CHAN(x)\t((x) << 8)  \n#define AD7192_CONF_CHAN_MASK\t(0x7FF << 8)  \n#define AD7192_CONF_BURN\tBIT(7)  \n#define AD7192_CONF_REFDET\tBIT(6)  \n#define AD7192_CONF_BUF\t\tBIT(4)  \n#define AD7192_CONF_UNIPOLAR\tBIT(3)  \n#define AD7192_CONF_GAIN(x)\t((x) & 0x7)  \n\n#define AD7192_CH_AIN1P_AIN2M\tBIT(0)  \n#define AD7192_CH_AIN3P_AIN4M\tBIT(1)  \n#define AD7192_CH_TEMP\t\tBIT(2)  \n#define AD7192_CH_AIN2P_AIN2M\tBIT(3)  \n#define AD7192_CH_AIN1\t\tBIT(4)  \n#define AD7192_CH_AIN2\t\tBIT(5)  \n#define AD7192_CH_AIN3\t\tBIT(6)  \n#define AD7192_CH_AIN4\t\tBIT(7)  \n\n#define AD7193_CH_AIN1P_AIN2M\t0x001   \n#define AD7193_CH_AIN3P_AIN4M\t0x002   \n#define AD7193_CH_AIN5P_AIN6M\t0x004   \n#define AD7193_CH_AIN7P_AIN8M\t0x008   \n#define AD7193_CH_TEMP\t\t0x100  \n#define AD7193_CH_AIN2P_AIN2M\t0x200  \n#define AD7193_CH_AIN1\t\t0x401  \n#define AD7193_CH_AIN2\t\t0x402  \n#define AD7193_CH_AIN3\t\t0x404  \n#define AD7193_CH_AIN4\t\t0x408  \n#define AD7193_CH_AIN5\t\t0x410  \n#define AD7193_CH_AIN6\t\t0x420  \n#define AD7193_CH_AIN7\t\t0x440  \n#define AD7193_CH_AIN8\t\t0x480  \n#define AD7193_CH_AINCOM\t0x600  \n\n \n#define CHIPID_AD7190\t\t0x4\n#define CHIPID_AD7192\t\t0x0\n#define CHIPID_AD7193\t\t0x2\n#define CHIPID_AD7195\t\t0x6\n#define AD7192_ID_MASK\t\t0x0F\n\n \n#define AD7192_GPOCON_BPDSW\tBIT(6)  \n#define AD7192_GPOCON_GP32EN\tBIT(5)  \n#define AD7192_GPOCON_GP10EN\tBIT(4)  \n#define AD7192_GPOCON_P3DAT\tBIT(3)  \n#define AD7192_GPOCON_P2DAT\tBIT(2)  \n#define AD7192_GPOCON_P1DAT\tBIT(1)  \n#define AD7192_GPOCON_P0DAT\tBIT(0)  \n\n#define AD7192_EXT_FREQ_MHZ_MIN\t2457600\n#define AD7192_EXT_FREQ_MHZ_MAX\t5120000\n#define AD7192_INT_FREQ_MHZ\t4915200\n\n#define AD7192_NO_SYNC_FILTER\t1\n#define AD7192_SYNC3_FILTER\t3\n#define AD7192_SYNC4_FILTER\t4\n\n \n\nenum {\n\tAD7192_SYSCALIB_ZERO_SCALE,\n\tAD7192_SYSCALIB_FULL_SCALE,\n};\n\nenum {\n\tID_AD7190,\n\tID_AD7192,\n\tID_AD7193,\n\tID_AD7195,\n};\n\nstruct ad7192_chip_info {\n\tunsigned int\t\t\tchip_id;\n\tconst char\t\t\t*name;\n};\n\nstruct ad7192_state {\n\tconst struct ad7192_chip_info\t*chip_info;\n\tstruct regulator\t\t*avdd;\n\tstruct regulator\t\t*vref;\n\tstruct clk\t\t\t*mclk;\n\tu16\t\t\t\tint_vref_mv;\n\tu32\t\t\t\tfclk;\n\tu32\t\t\t\tf_order;\n\tu32\t\t\t\tmode;\n\tu32\t\t\t\tconf;\n\tu32\t\t\t\tscale_avail[8][2];\n\tu8\t\t\t\tgpocon;\n\tu8\t\t\t\tclock_sel;\n\tstruct mutex\t\t\tlock;\t \n\tu8\t\t\t\tsyscalib_mode[8];\n\n\tstruct ad_sigma_delta\t\tsd;\n};\n\nstatic const char * const ad7192_syscalib_modes[] = {\n\t[AD7192_SYSCALIB_ZERO_SCALE] = \"zero_scale\",\n\t[AD7192_SYSCALIB_FULL_SCALE] = \"full_scale\",\n};\n\nstatic int ad7192_set_syscalib_mode(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    unsigned int mode)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\tst->syscalib_mode[chan->channel] = mode;\n\n\treturn 0;\n}\n\nstatic int ad7192_get_syscalib_mode(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\treturn st->syscalib_mode[chan->channel];\n}\n\nstatic ssize_t ad7192_write_syscalib(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t private,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tbool sys_calib;\n\tint ret, temp;\n\n\tret = kstrtobool(buf, &sys_calib);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = st->syscalib_mode[chan->channel];\n\tif (sys_calib) {\n\t\tif (temp == AD7192_SYSCALIB_ZERO_SCALE)\n\t\t\tret = ad_sd_calibrate(&st->sd, AD7192_MODE_CAL_SYS_ZERO,\n\t\t\t\t\t      chan->address);\n\t\telse\n\t\t\tret = ad_sd_calibrate(&st->sd, AD7192_MODE_CAL_SYS_FULL,\n\t\t\t\t\t      chan->address);\n\t}\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_enum ad7192_syscalib_mode_enum = {\n\t.items = ad7192_syscalib_modes,\n\t.num_items = ARRAY_SIZE(ad7192_syscalib_modes),\n\t.set = ad7192_set_syscalib_mode,\n\t.get = ad7192_get_syscalib_mode\n};\n\nstatic const struct iio_chan_spec_ext_info ad7192_calibsys_ext_info[] = {\n\t{\n\t\t.name = \"sys_calibration\",\n\t\t.write = ad7192_write_syscalib,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"sys_calibration_mode\", IIO_SEPARATE,\n\t\t &ad7192_syscalib_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"sys_calibration_mode\", IIO_SHARED_BY_TYPE,\n\t\t\t   &ad7192_syscalib_mode_enum),\n\t{}\n};\n\nstatic struct ad7192_state *ad_sigma_delta_to_ad7192(struct ad_sigma_delta *sd)\n{\n\treturn container_of(sd, struct ad7192_state, sd);\n}\n\nstatic int ad7192_set_channel(struct ad_sigma_delta *sd, unsigned int channel)\n{\n\tstruct ad7192_state *st = ad_sigma_delta_to_ad7192(sd);\n\n\tst->conf &= ~AD7192_CONF_CHAN_MASK;\n\tst->conf |= AD7192_CONF_CHAN(channel);\n\n\treturn ad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, st->conf);\n}\n\nstatic int ad7192_set_mode(struct ad_sigma_delta *sd,\n\t\t\t   enum ad_sigma_delta_mode mode)\n{\n\tstruct ad7192_state *st = ad_sigma_delta_to_ad7192(sd);\n\n\tst->mode &= ~AD7192_MODE_SEL_MASK;\n\tst->mode |= AD7192_MODE_SEL(mode);\n\n\treturn ad_sd_write_reg(&st->sd, AD7192_REG_MODE, 3, st->mode);\n}\n\nstatic int ad7192_append_status(struct ad_sigma_delta *sd, bool append)\n{\n\tstruct ad7192_state *st = ad_sigma_delta_to_ad7192(sd);\n\tunsigned int mode = st->mode;\n\tint ret;\n\n\tmode &= ~AD7192_MODE_STA_MASK;\n\tmode |= AD7192_MODE_STA(append);\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_MODE, 3, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->mode = mode;\n\n\treturn 0;\n}\n\nstatic int ad7192_disable_all(struct ad_sigma_delta *sd)\n{\n\tstruct ad7192_state *st = ad_sigma_delta_to_ad7192(sd);\n\tu32 conf = st->conf;\n\tint ret;\n\n\tconf &= ~AD7192_CONF_CHAN_MASK;\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, conf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->conf = conf;\n\n\treturn 0;\n}\n\nstatic const struct ad_sigma_delta_info ad7192_sigma_delta_info = {\n\t.set_channel = ad7192_set_channel,\n\t.append_status = ad7192_append_status,\n\t.disable_all = ad7192_disable_all,\n\t.set_mode = ad7192_set_mode,\n\t.has_registers = true,\n\t.addr_shift = 3,\n\t.read_mask = BIT(6),\n\t.status_ch_mask = GENMASK(3, 0),\n\t.num_slots = 4,\n\t.irq_flags = IRQF_TRIGGER_FALLING,\n};\n\nstatic const struct ad_sd_calib_data ad7192_calib_arr[8] = {\n\t{AD7192_MODE_CAL_INT_ZERO, AD7192_CH_AIN1},\n\t{AD7192_MODE_CAL_INT_FULL, AD7192_CH_AIN1},\n\t{AD7192_MODE_CAL_INT_ZERO, AD7192_CH_AIN2},\n\t{AD7192_MODE_CAL_INT_FULL, AD7192_CH_AIN2},\n\t{AD7192_MODE_CAL_INT_ZERO, AD7192_CH_AIN3},\n\t{AD7192_MODE_CAL_INT_FULL, AD7192_CH_AIN3},\n\t{AD7192_MODE_CAL_INT_ZERO, AD7192_CH_AIN4},\n\t{AD7192_MODE_CAL_INT_FULL, AD7192_CH_AIN4}\n};\n\nstatic int ad7192_calibrate_all(struct ad7192_state *st)\n{\n\treturn ad_sd_calibrate_all(&st->sd, ad7192_calib_arr,\n\t\t\t\t   ARRAY_SIZE(ad7192_calib_arr));\n}\n\nstatic inline bool ad7192_valid_external_frequency(u32 freq)\n{\n\treturn (freq >= AD7192_EXT_FREQ_MHZ_MIN &&\n\t\tfreq <= AD7192_EXT_FREQ_MHZ_MAX);\n}\n\nstatic int ad7192_of_clock_select(struct ad7192_state *st)\n{\n\tstruct device_node *np = st->sd.spi->dev.of_node;\n\tunsigned int clock_sel;\n\n\tclock_sel = AD7192_CLK_INT;\n\n\t \n\tif (!st->mclk) {\n\t\tif (of_property_read_bool(np, \"adi,int-clock-output-enable\"))\n\t\t\tclock_sel = AD7192_CLK_INT_CO;\n\t} else {\n\t\tif (of_property_read_bool(np, \"adi,clock-xtal\"))\n\t\t\tclock_sel = AD7192_CLK_EXT_MCLK1_2;\n\t\telse\n\t\t\tclock_sel = AD7192_CLK_EXT_MCLK2;\n\t}\n\n\treturn clock_sel;\n}\n\nstatic int ad7192_setup(struct iio_dev *indio_dev, struct device_node *np)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tbool rej60_en, refin2_en;\n\tbool buf_en, bipolar, burnout_curr_en;\n\tunsigned long long scale_uv;\n\tint i, ret, id;\n\n\t \n\tret = ad_sd_reset(&st->sd, 48);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(500, 1000);  \n\n\t \n\tret = ad_sd_read_reg(&st->sd, AD7192_REG_ID, 1, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tid &= AD7192_ID_MASK;\n\n\tif (id != st->chip_info->chip_id)\n\t\tdev_warn(&st->sd.spi->dev, \"device ID query failed (0x%X != 0x%X)\\n\",\n\t\t\t id, st->chip_info->chip_id);\n\n\tst->mode = AD7192_MODE_SEL(AD7192_MODE_IDLE) |\n\t\tAD7192_MODE_CLKSRC(st->clock_sel) |\n\t\tAD7192_MODE_RATE(480);\n\n\tst->conf = AD7192_CONF_GAIN(0);\n\n\trej60_en = of_property_read_bool(np, \"adi,rejection-60-Hz-enable\");\n\tif (rej60_en)\n\t\tst->mode |= AD7192_MODE_REJ60;\n\n\trefin2_en = of_property_read_bool(np, \"adi,refin2-pins-enable\");\n\tif (refin2_en && st->chip_info->chip_id != CHIPID_AD7195)\n\t\tst->conf |= AD7192_CONF_REFSEL;\n\n\tst->conf &= ~AD7192_CONF_CHOP;\n\tst->f_order = AD7192_NO_SYNC_FILTER;\n\n\tbuf_en = of_property_read_bool(np, \"adi,buffer-enable\");\n\tif (buf_en)\n\t\tst->conf |= AD7192_CONF_BUF;\n\n\tbipolar = of_property_read_bool(np, \"bipolar\");\n\tif (!bipolar)\n\t\tst->conf |= AD7192_CONF_UNIPOLAR;\n\n\tburnout_curr_en = of_property_read_bool(np,\n\t\t\t\t\t\t\"adi,burnout-currents-enable\");\n\tif (burnout_curr_en && buf_en) {\n\t\tst->conf |= AD7192_CONF_BURN;\n\t} else if (burnout_curr_en) {\n\t\tdev_warn(&st->sd.spi->dev,\n\t\t\t \"Can't enable burnout currents: see CHOP or buffer\\n\");\n\t}\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_MODE, 3, st->mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, st->conf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7192_calibrate_all(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++) {\n\t\tscale_uv = ((u64)st->int_vref_mv * 100000000)\n\t\t\t>> (indio_dev->channels[0].scan_type.realbits -\n\t\t\t((st->conf & AD7192_CONF_UNIPOLAR) ? 0 : 1));\n\t\tscale_uv >>= i;\n\n\t\tst->scale_avail[i][1] = do_div(scale_uv, 100000000) * 10;\n\t\tst->scale_avail[i][0] = scale_uv;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ad7192_show_ac_excitation(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!(st->conf & AD7192_CONF_ACX));\n}\n\nstatic ssize_t ad7192_show_bridge_switch(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!(st->gpocon & AD7192_GPOCON_BPDSW));\n}\n\nstatic ssize_t ad7192_set(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf,\n\t\t\t  size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch ((u32)this_attr->address) {\n\tcase AD7192_REG_GPOCON:\n\t\tif (val)\n\t\t\tst->gpocon |= AD7192_GPOCON_BPDSW;\n\t\telse\n\t\t\tst->gpocon &= ~AD7192_GPOCON_BPDSW;\n\n\t\tad_sd_write_reg(&st->sd, AD7192_REG_GPOCON, 1, st->gpocon);\n\t\tbreak;\n\tcase AD7192_REG_CONF:\n\t\tif (val)\n\t\t\tst->conf |= AD7192_CONF_ACX;\n\t\telse\n\t\t\tst->conf &= ~AD7192_CONF_ACX;\n\n\t\tad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, st->conf);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret ? ret : len;\n}\n\nstatic void ad7192_get_available_filter_freq(struct ad7192_state *st,\n\t\t\t\t\t\t    int *freq)\n{\n\tunsigned int fadc;\n\n\t \n\tfadc = DIV_ROUND_CLOSEST(st->fclk,\n\t\t\t\t AD7192_SYNC4_FILTER * AD7192_MODE_RATE(st->mode));\n\tfreq[0] = DIV_ROUND_CLOSEST(fadc * 240, 1024);\n\n\tfadc = DIV_ROUND_CLOSEST(st->fclk,\n\t\t\t\t AD7192_SYNC3_FILTER * AD7192_MODE_RATE(st->mode));\n\tfreq[1] = DIV_ROUND_CLOSEST(fadc * 240, 1024);\n\n\tfadc = DIV_ROUND_CLOSEST(st->fclk, AD7192_MODE_RATE(st->mode));\n\tfreq[2] = DIV_ROUND_CLOSEST(fadc * 230, 1024);\n\tfreq[3] = DIV_ROUND_CLOSEST(fadc * 272, 1024);\n}\n\nstatic ssize_t ad7192_show_filter_avail(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tunsigned int freq_avail[4], i;\n\tsize_t len = 0;\n\n\tad7192_get_available_filter_freq(st, freq_avail);\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_avail); i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%d.%03d \", freq_avail[i] / 1000,\n\t\t\t\t     freq_avail[i] % 1000);\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(filter_low_pass_3db_frequency_available,\n\t\t       0444, ad7192_show_filter_avail, NULL, 0);\n\nstatic IIO_DEVICE_ATTR(bridge_switch_en, 0644,\n\t\t       ad7192_show_bridge_switch, ad7192_set,\n\t\t       AD7192_REG_GPOCON);\n\nstatic IIO_DEVICE_ATTR(ac_excitation_en, 0644,\n\t\t       ad7192_show_ac_excitation, ad7192_set,\n\t\t       AD7192_REG_CONF);\n\nstatic struct attribute *ad7192_attributes[] = {\n\t&iio_dev_attr_filter_low_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_bridge_switch_en.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7192_attribute_group = {\n\t.attrs = ad7192_attributes,\n};\n\nstatic struct attribute *ad7195_attributes[] = {\n\t&iio_dev_attr_filter_low_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_bridge_switch_en.dev_attr.attr,\n\t&iio_dev_attr_ac_excitation_en.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7195_attribute_group = {\n\t.attrs = ad7195_attributes,\n};\n\nstatic unsigned int ad7192_get_temp_scale(bool unipolar)\n{\n\treturn unipolar ? 2815 * 2 : 2815;\n}\n\nstatic int ad7192_set_3db_filter_freq(struct ad7192_state *st,\n\t\t\t\t      int val, int val2)\n{\n\tint freq_avail[4], i, ret, freq;\n\tunsigned int diff_new, diff_old;\n\tint idx = 0;\n\n\tdiff_old = U32_MAX;\n\tfreq = val * 1000 + val2;\n\n\tad7192_get_available_filter_freq(st, freq_avail);\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_avail); i++) {\n\t\tdiff_new = abs(freq - freq_avail[i]);\n\t\tif (diff_new < diff_old) {\n\t\t\tdiff_old = diff_new;\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\tswitch (idx) {\n\tcase 0:\n\t\tst->f_order = AD7192_SYNC4_FILTER;\n\t\tst->mode &= ~AD7192_MODE_SINC3;\n\n\t\tst->conf |= AD7192_CONF_CHOP;\n\t\tbreak;\n\tcase 1:\n\t\tst->f_order = AD7192_SYNC3_FILTER;\n\t\tst->mode |= AD7192_MODE_SINC3;\n\n\t\tst->conf |= AD7192_CONF_CHOP;\n\t\tbreak;\n\tcase 2:\n\t\tst->f_order = AD7192_NO_SYNC_FILTER;\n\t\tst->mode &= ~AD7192_MODE_SINC3;\n\n\t\tst->conf &= ~AD7192_CONF_CHOP;\n\t\tbreak;\n\tcase 3:\n\t\tst->f_order = AD7192_NO_SYNC_FILTER;\n\t\tst->mode |= AD7192_MODE_SINC3;\n\n\t\tst->conf &= ~AD7192_CONF_CHOP;\n\t\tbreak;\n\t}\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_MODE, 3, st->mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, st->conf);\n}\n\nstatic int ad7192_get_3db_filter_freq(struct ad7192_state *st)\n{\n\tunsigned int fadc;\n\n\tfadc = DIV_ROUND_CLOSEST(st->fclk,\n\t\t\t\t st->f_order * AD7192_MODE_RATE(st->mode));\n\n\tif (st->conf & AD7192_CONF_CHOP)\n\t\treturn DIV_ROUND_CLOSEST(fadc * 240, 1024);\n\tif (st->mode & AD7192_MODE_SINC3)\n\t\treturn DIV_ROUND_CLOSEST(fadc * 272, 1024);\n\telse\n\t\treturn DIV_ROUND_CLOSEST(fadc * 230, 1024);\n}\n\nstatic int ad7192_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tbool unipolar = !!(st->conf & AD7192_CONF_UNIPOLAR);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = st->scale_avail[AD7192_CONF_GAIN(st->conf)][0];\n\t\t\t*val2 = st->scale_avail[AD7192_CONF_GAIN(st->conf)][1];\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000000000 / ad7192_get_temp_scale(unipolar);\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (!unipolar)\n\t\t\t*val = -(1 << (chan->scan_type.realbits - 1));\n\t\telse\n\t\t\t*val = 0;\n\t\t \n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val -= 273 * ad7192_get_temp_scale(unipolar);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->fclk /\n\t\t\t(st->f_order * 1024 * AD7192_MODE_RATE(st->mode));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*val = ad7192_get_3db_filter_freq(st);\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad7192_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tint ret, i, div;\n\tunsigned int tmp;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = -EINVAL;\n\t\tmutex_lock(&st->lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\n\t\t\tif (val2 == st->scale_avail[i][1]) {\n\t\t\t\tret = 0;\n\t\t\t\ttmp = st->conf;\n\t\t\t\tst->conf &= ~AD7192_CONF_GAIN(-1);\n\t\t\t\tst->conf |= AD7192_CONF_GAIN(i);\n\t\t\t\tif (tmp == st->conf)\n\t\t\t\t\tbreak;\n\t\t\t\tad_sd_write_reg(&st->sd, AD7192_REG_CONF,\n\t\t\t\t\t\t3, st->conf);\n\t\t\t\tad7192_calibrate_all(st);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmutex_unlock(&st->lock);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (!val) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdiv = st->fclk / (val * st->f_order * 1024);\n\t\tif (div < 1 || div > 1023) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tst->mode &= ~AD7192_MODE_RATE(-1);\n\t\tst->mode |= AD7192_MODE_RATE(div);\n\t\tad_sd_write_reg(&st->sd, AD7192_REG_MODE, 3, st->mode);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = ad7192_set_3db_filter_freq(st, val, val2 / 1000);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int ad7192_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7192_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (int *)st->scale_avail;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t \n\t\t*length = ARRAY_SIZE(st->scale_avail) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad7192_update_scan_mode(struct iio_dev *indio_dev, const unsigned long *scan_mask)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\tu32 conf = st->conf;\n\tint ret;\n\tint i;\n\n\tconf &= ~AD7192_CONF_CHAN_MASK;\n\tfor_each_set_bit(i, scan_mask, 8)\n\t\tconf |= AD7192_CONF_CHAN(i);\n\n\tret = ad_sd_write_reg(&st->sd, AD7192_REG_CONF, 3, conf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->conf = conf;\n\n\treturn 0;\n}\n\nstatic const struct iio_info ad7192_info = {\n\t.read_raw = ad7192_read_raw,\n\t.write_raw = ad7192_write_raw,\n\t.write_raw_get_fmt = ad7192_write_raw_get_fmt,\n\t.read_avail = ad7192_read_avail,\n\t.attrs = &ad7192_attribute_group,\n\t.validate_trigger = ad_sd_validate_trigger,\n\t.update_scan_mode = ad7192_update_scan_mode,\n};\n\nstatic const struct iio_info ad7195_info = {\n\t.read_raw = ad7192_read_raw,\n\t.write_raw = ad7192_write_raw,\n\t.write_raw_get_fmt = ad7192_write_raw_get_fmt,\n\t.read_avail = ad7192_read_avail,\n\t.attrs = &ad7195_attribute_group,\n\t.validate_trigger = ad_sd_validate_trigger,\n\t.update_scan_mode = ad7192_update_scan_mode,\n};\n\n#define __AD719x_CHANNEL(_si, _channel1, _channel2, _address, _extend_name, \\\n\t_type, _mask_type_av, _ext_info) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.differential = ((_channel2) == -1 ? 0 : 1), \\\n\t\t.indexed = 1, \\\n\t\t.channel = (_channel1), \\\n\t\t.channel2 = (_channel2), \\\n\t\t.address = (_address), \\\n\t\t.extend_name = (_extend_name), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t\t.info_mask_shared_by_type_available = (_mask_type_av), \\\n\t\t.ext_info = (_ext_info), \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 'u', \\\n\t\t\t.realbits = 24, \\\n\t\t\t.storagebits = 32, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define AD719x_DIFF_CHANNEL(_si, _channel1, _channel2, _address) \\\n\t__AD719x_CHANNEL(_si, _channel1, _channel2, _address, NULL, \\\n\t\tIIO_VOLTAGE, BIT(IIO_CHAN_INFO_SCALE), \\\n\t\tad7192_calibsys_ext_info)\n\n#define AD719x_CHANNEL(_si, _channel1, _address) \\\n\t__AD719x_CHANNEL(_si, _channel1, -1, _address, NULL, IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), ad7192_calibsys_ext_info)\n\n#define AD719x_TEMP_CHANNEL(_si, _address) \\\n\t__AD719x_CHANNEL(_si, 0, -1, _address, NULL, IIO_TEMP, 0, NULL)\n\nstatic const struct iio_chan_spec ad7192_channels[] = {\n\tAD719x_DIFF_CHANNEL(0, 1, 2, AD7192_CH_AIN1P_AIN2M),\n\tAD719x_DIFF_CHANNEL(1, 3, 4, AD7192_CH_AIN3P_AIN4M),\n\tAD719x_TEMP_CHANNEL(2, AD7192_CH_TEMP),\n\tAD719x_DIFF_CHANNEL(3, 2, 2, AD7192_CH_AIN2P_AIN2M),\n\tAD719x_CHANNEL(4, 1, AD7192_CH_AIN1),\n\tAD719x_CHANNEL(5, 2, AD7192_CH_AIN2),\n\tAD719x_CHANNEL(6, 3, AD7192_CH_AIN3),\n\tAD719x_CHANNEL(7, 4, AD7192_CH_AIN4),\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n};\n\nstatic const struct iio_chan_spec ad7193_channels[] = {\n\tAD719x_DIFF_CHANNEL(0, 1, 2, AD7193_CH_AIN1P_AIN2M),\n\tAD719x_DIFF_CHANNEL(1, 3, 4, AD7193_CH_AIN3P_AIN4M),\n\tAD719x_DIFF_CHANNEL(2, 5, 6, AD7193_CH_AIN5P_AIN6M),\n\tAD719x_DIFF_CHANNEL(3, 7, 8, AD7193_CH_AIN7P_AIN8M),\n\tAD719x_TEMP_CHANNEL(4, AD7193_CH_TEMP),\n\tAD719x_DIFF_CHANNEL(5, 2, 2, AD7193_CH_AIN2P_AIN2M),\n\tAD719x_CHANNEL(6, 1, AD7193_CH_AIN1),\n\tAD719x_CHANNEL(7, 2, AD7193_CH_AIN2),\n\tAD719x_CHANNEL(8, 3, AD7193_CH_AIN3),\n\tAD719x_CHANNEL(9, 4, AD7193_CH_AIN4),\n\tAD719x_CHANNEL(10, 5, AD7193_CH_AIN5),\n\tAD719x_CHANNEL(11, 6, AD7193_CH_AIN6),\n\tAD719x_CHANNEL(12, 7, AD7193_CH_AIN7),\n\tAD719x_CHANNEL(13, 8, AD7193_CH_AIN8),\n\tIIO_CHAN_SOFT_TIMESTAMP(14),\n};\n\nstatic const struct ad7192_chip_info ad7192_chip_info_tbl[] = {\n\t[ID_AD7190] = {\n\t\t.chip_id = CHIPID_AD7190,\n\t\t.name = \"ad7190\",\n\t},\n\t[ID_AD7192] = {\n\t\t.chip_id = CHIPID_AD7192,\n\t\t.name = \"ad7192\",\n\t},\n\t[ID_AD7193] = {\n\t\t.chip_id = CHIPID_AD7193,\n\t\t.name = \"ad7193\",\n\t},\n\t[ID_AD7195] = {\n\t\t.chip_id = CHIPID_AD7195,\n\t\t.name = \"ad7195\",\n\t},\n};\n\nstatic int ad7192_channels_config(struct iio_dev *indio_dev)\n{\n\tstruct ad7192_state *st = iio_priv(indio_dev);\n\n\tswitch (st->chip_info->chip_id) {\n\tcase CHIPID_AD7193:\n\t\tindio_dev->channels = ad7193_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad7193_channels);\n\t\tbreak;\n\tdefault:\n\t\tindio_dev->channels = ad7192_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ad7192_channels);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void ad7192_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7192_probe(struct spi_device *spi)\n{\n\tstruct ad7192_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"no IRQ?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\tst->avdd = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(st->avdd))\n\t\treturn PTR_ERR(st->avdd);\n\n\tret = regulator_enable(st->avdd);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified AVdd supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7192_reg_disable, st->avdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_regulator_get_enable(&spi->dev, \"dvdd\");\n\tif (ret)\n\t\treturn dev_err_probe(&spi->dev, ret, \"Failed to enable specified DVdd supply\\n\");\n\n\tst->vref = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (IS_ERR(st->vref)) {\n\t\tif (PTR_ERR(st->vref) != -ENODEV)\n\t\t\treturn PTR_ERR(st->vref);\n\n\t\tret = regulator_get_voltage(st->avdd);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&spi->dev, ret,\n\t\t\t\t\t     \"Device tree error, AVdd voltage undefined\\n\");\n\t} else {\n\t\tret = regulator_enable(st->vref);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"Failed to enable specified Vref supply\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7192_reg_disable, st->vref);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->vref);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&spi->dev, ret,\n\t\t\t\t\t     \"Device tree error, Vref voltage undefined\\n\");\n\t}\n\tst->int_vref_mv = ret / 1000;\n\n\tst->chip_info = of_device_get_match_data(&spi->dev);\n\tif (!st->chip_info)\n\t\tst->chip_info = (void *)spi_get_device_id(spi)->driver_data;\n\tindio_dev->name = st->chip_info->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ad7192_channels_config(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (st->chip_info->chip_id == CHIPID_AD7195)\n\t\tindio_dev->info = &ad7195_info;\n\telse\n\t\tindio_dev->info = &ad7192_info;\n\n\tret = ad_sd_init(&st->sd, indio_dev, spi, &ad7192_sigma_delta_info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fclk = AD7192_INT_FREQ_MHZ;\n\n\tst->mclk = devm_clk_get_optional_enabled(&spi->dev, \"mclk\");\n\tif (IS_ERR(st->mclk))\n\t\treturn PTR_ERR(st->mclk);\n\n\tst->clock_sel = ad7192_of_clock_select(st);\n\n\tif (st->clock_sel == AD7192_CLK_EXT_MCLK1_2 ||\n\t    st->clock_sel == AD7192_CLK_EXT_MCLK2) {\n\t\tst->fclk = clk_get_rate(st->mclk);\n\t\tif (!ad7192_valid_external_frequency(st->fclk)) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"External clock frequency out of bounds\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = ad7192_setup(indio_dev, spi->dev.of_node);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ad7192_of_match[] = {\n\t{ .compatible = \"adi,ad7190\", .data = &ad7192_chip_info_tbl[ID_AD7190] },\n\t{ .compatible = \"adi,ad7192\", .data = &ad7192_chip_info_tbl[ID_AD7192] },\n\t{ .compatible = \"adi,ad7193\", .data = &ad7192_chip_info_tbl[ID_AD7193] },\n\t{ .compatible = \"adi,ad7195\", .data = &ad7192_chip_info_tbl[ID_AD7195] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad7192_of_match);\n\nstatic const struct spi_device_id ad7192_ids[] = {\n\t{ \"ad7190\", (kernel_ulong_t)&ad7192_chip_info_tbl[ID_AD7190] },\n\t{ \"ad7192\", (kernel_ulong_t)&ad7192_chip_info_tbl[ID_AD7192] },\n\t{ \"ad7193\", (kernel_ulong_t)&ad7192_chip_info_tbl[ID_AD7193] },\n\t{ \"ad7195\", (kernel_ulong_t)&ad7192_chip_info_tbl[ID_AD7195] },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7192_ids);\n\nstatic struct spi_driver ad7192_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7192\",\n\t\t.of_match_table = ad7192_of_match,\n\t},\n\t.probe\t\t= ad7192_probe,\n\t.id_table\t= ad7192_ids,\n};\nmodule_spi_driver(ad7192_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7190, AD7192, AD7193, AD7195 ADC\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}