{
  "module_name": "ti-ads124s08.c",
  "hash_id": "d6261618dd41d088b5c0fea7317c975f026892682df5abda042e2adf1b640da4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads124s08.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/sysfs.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADS124S08_CMD_NOP\t0x00\n#define ADS124S08_CMD_WAKEUP\t0x02\n#define ADS124S08_CMD_PWRDWN\t0x04\n#define ADS124S08_CMD_RESET\t0x06\n#define ADS124S08_CMD_START\t0x08\n#define ADS124S08_CMD_STOP\t0x0a\n#define ADS124S08_CMD_SYOCAL\t0x16\n#define ADS124S08_CMD_SYGCAL\t0x17\n#define ADS124S08_CMD_SFOCAL\t0x19\n#define ADS124S08_CMD_RDATA\t0x12\n#define ADS124S08_CMD_RREG\t0x20\n#define ADS124S08_CMD_WREG\t0x40\n\n \n#define ADS124S08_ID_REG\t0x00\n#define ADS124S08_STATUS\t0x01\n#define ADS124S08_INPUT_MUX\t0x02\n#define ADS124S08_PGA\t\t0x03\n#define ADS124S08_DATA_RATE\t0x04\n#define ADS124S08_REF\t\t0x05\n#define ADS124S08_IDACMAG\t0x06\n#define ADS124S08_IDACMUX\t0x07\n#define ADS124S08_VBIAS\t\t0x08\n#define ADS124S08_SYS\t\t0x09\n#define ADS124S08_OFCAL0\t0x0a\n#define ADS124S08_OFCAL1\t0x0b\n#define ADS124S08_OFCAL2\t0x0c\n#define ADS124S08_FSCAL0\t0x0d\n#define ADS124S08_FSCAL1\t0x0e\n#define ADS124S08_FSCAL2\t0x0f\n#define ADS124S08_GPIODAT\t0x10\n#define ADS124S08_GPIOCON\t0x11\n\n \n#define ADS124S08_AIN0\t\t0x00\n#define ADS124S08_AIN1\t\t0x01\n#define ADS124S08_AIN2\t\t0x02\n#define ADS124S08_AIN3\t\t0x03\n#define ADS124S08_AIN4\t\t0x04\n#define ADS124S08_AIN5\t\t0x05\n#define ADS124S08_AINCOM\t0x0c\n \n#define ADS124S08_AIN6\t\t0x06\n#define ADS124S08_AIN7\t\t0x07\n#define ADS124S08_AIN8\t\t0x08\n#define ADS124S08_AIN9\t\t0x09\n#define ADS124S08_AIN10\t\t0x0a\n#define ADS124S08_AIN11\t\t0x0b\n#define ADS124S08_MAX_CHANNELS\t12\n\n#define ADS124S08_POS_MUX_SHIFT\t0x04\n#define ADS124S08_INT_REF\t\t0x09\n\n#define ADS124S08_START_REG_MASK\t0x1f\n#define ADS124S08_NUM_BYTES_MASK\t0x1f\n\n#define ADS124S08_START_CONV\t0x01\n#define ADS124S08_STOP_CONV\t0x00\n\nenum ads124s_id {\n\tADS124S08_ID,\n\tADS124S06_ID,\n};\n\nstruct ads124s_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nstruct ads124s_private {\n\tconst struct ads124s_chip_info\t*chip_info;\n\tstruct gpio_desc *reset_gpio;\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\t \n\tu32 buffer[ADS124S08_MAX_CHANNELS + sizeof(s64)/sizeof(u32)] __aligned(8);\n\tu8 data[5] __aligned(IIO_DMA_MINALIGN);\n};\n\n#define ADS124S08_CHAN(index)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.scan_index = index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 32,\t\t\t\t\t\\\n\t\t.storagebits = 32,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ads124s06_channels[] = {\n\tADS124S08_CHAN(0),\n\tADS124S08_CHAN(1),\n\tADS124S08_CHAN(2),\n\tADS124S08_CHAN(3),\n\tADS124S08_CHAN(4),\n\tADS124S08_CHAN(5),\n};\n\nstatic const struct iio_chan_spec ads124s08_channels[] = {\n\tADS124S08_CHAN(0),\n\tADS124S08_CHAN(1),\n\tADS124S08_CHAN(2),\n\tADS124S08_CHAN(3),\n\tADS124S08_CHAN(4),\n\tADS124S08_CHAN(5),\n\tADS124S08_CHAN(6),\n\tADS124S08_CHAN(7),\n\tADS124S08_CHAN(8),\n\tADS124S08_CHAN(9),\n\tADS124S08_CHAN(10),\n\tADS124S08_CHAN(11),\n};\n\nstatic const struct ads124s_chip_info ads124s_chip_info_tbl[] = {\n\t[ADS124S08_ID] = {\n\t\t.channels = ads124s08_channels,\n\t\t.num_channels = ARRAY_SIZE(ads124s08_channels),\n\t},\n\t[ADS124S06_ID] = {\n\t\t.channels = ads124s06_channels,\n\t\t.num_channels = ARRAY_SIZE(ads124s06_channels),\n\t},\n};\n\nstatic int ads124s_write_cmd(struct iio_dev *indio_dev, u8 command)\n{\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\n\tpriv->data[0] = command;\n\n\treturn spi_write(priv->spi, &priv->data[0], 1);\n}\n\nstatic int ads124s_write_reg(struct iio_dev *indio_dev, u8 reg, u8 data)\n{\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\n\tpriv->data[0] = ADS124S08_CMD_WREG | reg;\n\tpriv->data[1] = 0x0;\n\tpriv->data[2] = data;\n\n\treturn spi_write(priv->spi, &priv->data[0], 3);\n}\n\nstatic int ads124s_reset(struct iio_dev *indio_dev)\n{\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\n\tif (priv->reset_gpio) {\n\t\tgpiod_set_value(priv->reset_gpio, 0);\n\t\tudelay(200);\n\t\tgpiod_set_value(priv->reset_gpio, 1);\n\t} else {\n\t\treturn ads124s_write_cmd(indio_dev, ADS124S08_CMD_RESET);\n\t}\n\n\treturn 0;\n};\n\nstatic int ads124s_read(struct iio_dev *indio_dev)\n{\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &priv->data[0],\n\t\t\t.len = 4,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &priv->data[1],\n\t\t\t.rx_buf = &priv->data[1],\n\t\t\t.len = 4,\n\t\t},\n\t};\n\n\tpriv->data[0] = ADS124S08_CMD_RDATA;\n\tmemset(&priv->data[1], ADS124S08_CMD_NOP, sizeof(priv->data) - 1);\n\n\tret = spi_sync_transfer(priv->spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn get_unaligned_be24(&priv->data[2]);\n}\n\nstatic int ads124s_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long m)\n{\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ads124s_write_reg(indio_dev, ADS124S08_INPUT_MUX,\n\t\t\t\t\tchan->channel);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->spi->dev, \"Set ADC CH failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ads124s_write_cmd(indio_dev, ADS124S08_START_CONV);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->spi->dev, \"Start conversions failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ads124s_read(indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&priv->spi->dev, \"Read ADC failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t*val = ret;\n\n\t\tret = ads124s_write_cmd(indio_dev, ADS124S08_STOP_CONV);\n\t\tif (ret) {\n\t\t\tdev_err(&priv->spi->dev, \"Stop conversions failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info ads124s_info = {\n\t.read_raw = &ads124s_read_raw,\n};\n\nstatic irqreturn_t ads124s_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ads124s_private *priv = iio_priv(indio_dev);\n\tint scan_index, j = 0;\n\tint ret;\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = ads124s_write_reg(indio_dev, ADS124S08_INPUT_MUX,\n\t\t\t\t\tscan_index);\n\t\tif (ret)\n\t\t\tdev_err(&priv->spi->dev, \"Set ADC CH failed\\n\");\n\n\t\tret = ads124s_write_cmd(indio_dev, ADS124S08_START_CONV);\n\t\tif (ret)\n\t\t\tdev_err(&priv->spi->dev, \"Start ADC conversions failed\\n\");\n\n\t\tpriv->buffer[j] = ads124s_read(indio_dev);\n\t\tret = ads124s_write_cmd(indio_dev, ADS124S08_STOP_CONV);\n\t\tif (ret)\n\t\t\tdev_err(&priv->spi->dev, \"Stop ADC conversions failed\\n\");\n\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, priv->buffer,\n\t\t\tpf->timestamp);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ads124s_probe(struct spi_device *spi)\n{\n\tstruct ads124s_private *ads124s_priv;\n\tstruct iio_dev *indio_dev;\n\tconst struct spi_device_id *spi_id = spi_get_device_id(spi);\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*ads124s_priv));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tads124s_priv = iio_priv(indio_dev);\n\n\tads124s_priv->reset_gpio = devm_gpiod_get_optional(&spi->dev,\n\t\t\t\t\t\t   \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ads124s_priv->reset_gpio))\n\t\tdev_info(&spi->dev, \"Reset GPIO not defined\\n\");\n\n\tads124s_priv->chip_info = &ads124s_chip_info_tbl[spi_id->driver_data];\n\n\tads124s_priv->spi = spi;\n\n\tindio_dev->name = spi_id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ads124s_priv->chip_info->channels;\n\tindio_dev->num_channels = ads124s_priv->chip_info->num_channels;\n\tindio_dev->info = &ads124s_info;\n\n\tmutex_init(&ads124s_priv->lock);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      ads124s_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tads124s_reset(indio_dev);\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ads124s_id[] = {\n\t{ \"ads124s06\", ADS124S06_ID },\n\t{ \"ads124s08\", ADS124S08_ID },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ads124s_id);\n\nstatic const struct of_device_id ads124s_of_table[] = {\n\t{ .compatible = \"ti,ads124s06\" },\n\t{ .compatible = \"ti,ads124s08\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ads124s_of_table);\n\nstatic struct spi_driver ads124s_driver = {\n\t.driver = {\n\t\t.name\t= \"ads124s08\",\n\t\t.of_match_table = ads124s_of_table,\n\t},\n\t.probe\t\t= ads124s_probe,\n\t.id_table\t= ads124s_id,\n};\nmodule_spi_driver(ads124s_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmuprhy@ti.com>\");\nMODULE_DESCRIPTION(\"TI TI_ADS12S0X ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}