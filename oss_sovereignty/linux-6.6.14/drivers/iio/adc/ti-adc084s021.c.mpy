{
  "module_name": "ti-adc084s021.c",
  "hash_id": "bcf8a23529896e60185b9f0bfc8a365f013b9194f0e3049d54c58cc29261c3d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc084s021.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/regulator/consumer.h>\n\n#define ADC084S021_DRIVER_NAME \"adc084s021\"\n\nstruct adc084s021 {\n\tstruct spi_device *spi;\n\tstruct spi_message message;\n\tstruct spi_transfer spi_trans;\n\tstruct regulator *reg;\n\tstruct mutex lock;\n\t \n\tstruct {\n\t\t__be16 channels[4];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\t \n\tu16 tx_buf[4] __aligned(IIO_DMA_MINALIGN);\n\t__be16 rx_buf[5];  \n};\n\n#define ADC084S021_VOLTAGE_CHANNEL(num)                  \\\n\t{                                                      \\\n\t\t.type = IIO_VOLTAGE,                                 \\\n\t\t.channel = (num),                                    \\\n\t\t.indexed = 1,                                        \\\n\t\t.scan_index = (num),                                 \\\n\t\t.scan_type = {                                       \\\n\t\t\t.sign = 'u',                                       \\\n\t\t\t.realbits = 8,                                     \\\n\t\t\t.storagebits = 16,                                 \\\n\t\t\t.shift = 4,                                        \\\n\t\t\t.endianness = IIO_BE,                              \\\n\t\t},                                                   \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),        \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\\\n\t}\n\nstatic const struct iio_chan_spec adc084s021_channels[] = {\n\tADC084S021_VOLTAGE_CHANNEL(0),\n\tADC084S021_VOLTAGE_CHANNEL(1),\n\tADC084S021_VOLTAGE_CHANNEL(2),\n\tADC084S021_VOLTAGE_CHANNEL(3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\n \nstatic int adc084s021_adc_conversion(struct adc084s021 *adc, __be16 *data)\n{\n\tint n_words = (adc->spi_trans.len >> 1) - 1;  \n\tint ret, i = 0;\n\n\t \n\tret = spi_sync(adc->spi, &adc->message);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (; i < n_words; i++)\n\t\t*(data + i) = adc->rx_buf[i + 1];\n\n\treturn ret;\n}\n\nstatic int adc084s021_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *channel, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct adc084s021 *adc = iio_priv(indio_dev);\n\tint ret;\n\t__be16 be_val;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regulator_enable(adc->reg);\n\t\tif (ret) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tadc->tx_buf[0] = channel->channel << 3;\n\t\tret = adc084s021_adc_conversion(adc, &be_val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tregulator_disable(adc->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = be16_to_cpu(be_val);\n\t\t*val = (*val >> channel->scan_type.shift) & 0xff;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_enable(adc->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(adc->reg);\n\t\tregulator_disable(adc->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic irqreturn_t adc084s021_buffer_trigger_handler(int irq, void *pollfunc)\n{\n\tstruct iio_poll_func *pf = pollfunc;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adc084s021 *adc = iio_priv(indio_dev);\n\n\tmutex_lock(&adc->lock);\n\n\tif (adc084s021_adc_conversion(adc, adc->scan.channels) < 0)\n\t\tdev_err(&adc->spi->dev, \"Failed to read data\\n\");\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &adc->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\tmutex_unlock(&adc->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc084s021_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct adc084s021 *adc = iio_priv(indio_dev);\n\tint scan_index;\n\tint i = 0;\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tconst struct iio_chan_spec *channel =\n\t\t\t&indio_dev->channels[scan_index];\n\t\tadc->tx_buf[i++] = channel->channel << 3;\n\t}\n\tadc->spi_trans.len = 2 + (i * sizeof(__be16));  \n\n\treturn regulator_enable(adc->reg);\n}\n\nstatic int adc084s021_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct adc084s021 *adc = iio_priv(indio_dev);\n\n\tadc->spi_trans.len = 4;  \n\n\treturn regulator_disable(adc->reg);\n}\n\nstatic const struct iio_info adc084s021_info = {\n\t.read_raw = adc084s021_read_raw,\n};\n\nstatic const struct iio_buffer_setup_ops adc084s021_buffer_setup_ops = {\n\t.preenable = adc084s021_buffer_preenable,\n\t.postdisable = adc084s021_buffer_postdisable,\n};\n\nstatic int adc084s021_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adc084s021 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev) {\n\t\tdev_err(&spi->dev, \"Failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\n\t \n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &adc084s021_info;\n\tindio_dev->channels = adc084s021_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adc084s021_channels);\n\n\t \n\tadc->spi_trans.tx_buf = adc->tx_buf;\n\tadc->spi_trans.rx_buf = adc->rx_buf;\n\tadc->spi_trans.len = 4;  \n\tspi_message_init_with_transfers(&adc->message, &adc->spi_trans, 1);\n\n\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(adc->reg))\n\t\treturn PTR_ERR(adc->reg);\n\n\tmutex_init(&adc->lock);\n\n\t \n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t    adc084s021_buffer_trigger_handler,\n\t\t\t\t\t    &adc084s021_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to setup triggered buffer\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adc084s021_of_match[] = {\n\t{ .compatible = \"ti,adc084s021\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, adc084s021_of_match);\n\nstatic const struct spi_device_id adc084s021_id[] = {\n\t{ ADC084S021_DRIVER_NAME, 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adc084s021_id);\n\nstatic struct spi_driver adc084s021_driver = {\n\t.driver = {\n\t\t.name = ADC084S021_DRIVER_NAME,\n\t\t.of_match_table = adc084s021_of_match,\n\t},\n\t.probe = adc084s021_probe,\n\t.id_table = adc084s021_id,\n};\nmodule_spi_driver(adc084s021_driver);\n\nMODULE_AUTHOR(\"M\u00e5rten Lindahl <martenli@axis.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADC084S021\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}