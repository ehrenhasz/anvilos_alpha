{
  "module_name": "sun4i-gpadc-iio.c",
  "hash_id": "faaeabf00e4f32abaa92d528f6416fe4a6822259da1eea918f6af0c7a3c9372e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/sun4i-gpadc-iio.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/mfd/sun4i-gpadc.h>\n\nstatic unsigned int sun4i_gpadc_chan_select(unsigned int chan)\n{\n\treturn SUN4I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);\n}\n\nstatic unsigned int sun6i_gpadc_chan_select(unsigned int chan)\n{\n\treturn SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);\n}\n\nstruct gpadc_data {\n\tint\t\ttemp_offset;\n\tint\t\ttemp_scale;\n\tunsigned int\ttp_mode_en;\n\tunsigned int\ttp_adc_select;\n\tunsigned int\t(*adc_chan_select)(unsigned int chan);\n\tunsigned int\tadc_chan_mask;\n};\n\nstatic const struct gpadc_data sun4i_gpadc_data = {\n\t.temp_offset = -1932,\n\t.temp_scale = 133,\n\t.tp_mode_en = SUN4I_GPADC_CTRL1_TP_MODE_EN,\n\t.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,\n\t.adc_chan_select = &sun4i_gpadc_chan_select,\n\t.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,\n};\n\nstatic const struct gpadc_data sun5i_gpadc_data = {\n\t.temp_offset = -1447,\n\t.temp_scale = 100,\n\t.tp_mode_en = SUN4I_GPADC_CTRL1_TP_MODE_EN,\n\t.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,\n\t.adc_chan_select = &sun4i_gpadc_chan_select,\n\t.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,\n};\n\nstatic const struct gpadc_data sun6i_gpadc_data = {\n\t.temp_offset = -1623,\n\t.temp_scale = 167,\n\t.tp_mode_en = SUN6I_GPADC_CTRL1_TP_MODE_EN,\n\t.tp_adc_select = SUN6I_GPADC_CTRL1_TP_ADC_SELECT,\n\t.adc_chan_select = &sun6i_gpadc_chan_select,\n\t.adc_chan_mask = SUN6I_GPADC_CTRL1_ADC_CHAN_MASK,\n};\n\nstatic const struct gpadc_data sun8i_a33_gpadc_data = {\n\t.temp_offset = -1662,\n\t.temp_scale = 162,\n\t.tp_mode_en = SUN8I_GPADC_CTRL1_CHOP_TEMP_EN,\n};\n\nstruct sun4i_gpadc_iio {\n\tstruct iio_dev\t\t\t*indio_dev;\n\tstruct completion\t\tcompletion;\n\tint\t\t\t\ttemp_data;\n\tu32\t\t\t\tadc_data;\n\tstruct regmap\t\t\t*regmap;\n\tunsigned int\t\t\tfifo_data_irq;\n\tatomic_t\t\t\tignore_fifo_data_irq;\n\tunsigned int\t\t\ttemp_data_irq;\n\tatomic_t\t\t\tignore_temp_data_irq;\n\tconst struct gpadc_data\t\t*data;\n\tbool\t\t\t\tno_irq;\n\t \n\tstruct mutex\t\t\tmutex;\n\tstruct thermal_zone_device\t*tzd;\n\tstruct device\t\t\t*sensor_device;\n};\n\n#define SUN4I_GPADC_ADC_CHANNEL(_channel, _name) {\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.datasheet_name = _name,\t\t\t\t\\\n}\n\nstatic struct iio_map sun4i_gpadc_hwmon_maps[] = {\n\t{\n\t\t.adc_channel_label = \"temp_adc\",\n\t\t.consumer_dev_name = \"iio_hwmon.0\",\n\t},\n\t{   },\n};\n\nstatic const struct iio_chan_spec sun4i_gpadc_channels[] = {\n\tSUN4I_GPADC_ADC_CHANNEL(0, \"adc_chan0\"),\n\tSUN4I_GPADC_ADC_CHANNEL(1, \"adc_chan1\"),\n\tSUN4I_GPADC_ADC_CHANNEL(2, \"adc_chan2\"),\n\tSUN4I_GPADC_ADC_CHANNEL(3, \"adc_chan3\"),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.datasheet_name = \"temp_adc\",\n\t},\n};\n\nstatic const struct iio_chan_spec sun4i_gpadc_channels_no_temp[] = {\n\tSUN4I_GPADC_ADC_CHANNEL(0, \"adc_chan0\"),\n\tSUN4I_GPADC_ADC_CHANNEL(1, \"adc_chan1\"),\n\tSUN4I_GPADC_ADC_CHANNEL(2, \"adc_chan2\"),\n\tSUN4I_GPADC_ADC_CHANNEL(3, \"adc_chan3\"),\n};\n\nstatic const struct iio_chan_spec sun8i_a33_gpadc_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.datasheet_name = \"temp_adc\",\n\t},\n};\n\nstatic const struct regmap_config sun4i_gpadc_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n};\n\nstatic int sun4i_prepare_for_irq(struct iio_dev *indio_dev, int channel,\n\t\t\t\t unsigned int irq)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\tint ret;\n\tu32 reg;\n\n\tpm_runtime_get_sync(indio_dev->dev.parent);\n\n\treinit_completion(&info->completion);\n\n\tret = regmap_write(info->regmap, SUN4I_GPADC_INT_FIFOC,\n\t\t\t   SUN4I_GPADC_INT_FIFOC_TP_FIFO_TRIG_LEVEL(1) |\n\t\t\t   SUN4I_GPADC_INT_FIFOC_TP_FIFO_FLUSH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(info->regmap, SUN4I_GPADC_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (irq == info->fifo_data_irq) {\n\t\tret = regmap_write(info->regmap, SUN4I_GPADC_CTRL1,\n\t\t\t\t   info->data->tp_mode_en |\n\t\t\t\t   info->data->tp_adc_select |\n\t\t\t\t   info->data->adc_chan_select(channel));\n\t\t \n\t\tif ((reg & info->data->adc_chan_mask) !=\n\t\t\t info->data->adc_chan_select(channel))\n\t\t\tmdelay(10);\n\n\t} else {\n\t\t \n\t\tret = regmap_write(info->regmap, SUN4I_GPADC_CTRL1,\n\t\t\t\t   info->data->tp_mode_en);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((reg & info->data->tp_adc_select) != info->data->tp_adc_select)\n\t\tmdelay(100);\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_read(struct iio_dev *indio_dev, int channel, int *val,\n\t\t\t    unsigned int irq)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&info->mutex);\n\n\tret = sun4i_prepare_for_irq(indio_dev, channel, irq);\n\tif (ret)\n\t\tgoto err;\n\n\tenable_irq(irq);\n\n\t \n\tif (!wait_for_completion_timeout(&info->completion,\n\t\t\t\t\t msecs_to_jiffies(1000))) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tif (irq == info->fifo_data_irq)\n\t\t*val = info->adc_data;\n\telse\n\t\t*val = info->temp_data;\n\n\tret = 0;\n\tpm_runtime_mark_last_busy(indio_dev->dev.parent);\n\nerr:\n\tpm_runtime_put_autosuspend(indio_dev->dev.parent);\n\tdisable_irq(irq);\n\tmutex_unlock(&info->mutex);\n\n\treturn ret;\n}\n\nstatic int sun4i_gpadc_adc_read(struct iio_dev *indio_dev, int channel,\n\t\t\t\tint *val)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\n\treturn sun4i_gpadc_read(indio_dev, channel, val, info->fifo_data_irq);\n}\n\nstatic int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\n\tif (info->no_irq) {\n\t\tpm_runtime_get_sync(indio_dev->dev.parent);\n\n\t\tregmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, val);\n\n\t\tpm_runtime_mark_last_busy(indio_dev->dev.parent);\n\t\tpm_runtime_put_autosuspend(indio_dev->dev.parent);\n\n\t\treturn 0;\n\t}\n\n\treturn sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);\n}\n\nstatic int sun4i_gpadc_temp_offset(struct iio_dev *indio_dev, int *val)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\n\t*val = info->data->temp_offset;\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_temp_scale(struct iio_dev *indio_dev, int *val)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\n\t*val = info->data->temp_scale;\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\t\tint *val2, long mask)\n{\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = sun4i_gpadc_temp_offset(indio_dev, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type == IIO_VOLTAGE)\n\t\t\tret = sun4i_gpadc_adc_read(indio_dev, chan->channel,\n\t\t\t\t\t\t   val);\n\t\telse\n\t\t\tret = sun4i_gpadc_temp_read(indio_dev, val);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_VOLTAGE) {\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 732421875;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\t}\n\n\t\tret = sun4i_gpadc_temp_scale(indio_dev, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info sun4i_gpadc_iio_info = {\n\t.read_raw = sun4i_gpadc_read_raw,\n};\n\nstatic irqreturn_t sun4i_gpadc_temp_data_irq_handler(int irq, void *dev_id)\n{\n\tstruct sun4i_gpadc_iio *info = dev_id;\n\n\tif (atomic_read(&info->ignore_temp_data_irq))\n\t\tgoto out;\n\n\tif (!regmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, &info->temp_data))\n\t\tcomplete(&info->completion);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sun4i_gpadc_fifo_data_irq_handler(int irq, void *dev_id)\n{\n\tstruct sun4i_gpadc_iio *info = dev_id;\n\n\tif (atomic_read(&info->ignore_fifo_data_irq))\n\t\tgoto out;\n\n\tif (!regmap_read(info->regmap, SUN4I_GPADC_DATA, &info->adc_data))\n\t\tcomplete(&info->completion);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_gpadc_runtime_suspend(struct device *dev)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));\n\n\t \n\tregmap_write(info->regmap, SUN4I_GPADC_CTRL1, 0);\n\t \n\tregmap_write(info->regmap, SUN4I_GPADC_TPR, 0);\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_runtime_resume(struct device *dev)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));\n\n\t \n\tregmap_write(info->regmap, SUN4I_GPADC_CTRL0,\n\t\t     SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(2) |\n\t\t     SUN4I_GPADC_CTRL0_FS_DIV(7) |\n\t\t     SUN4I_GPADC_CTRL0_T_ACQ(63));\n\tregmap_write(info->regmap, SUN4I_GPADC_CTRL1, info->data->tp_mode_en);\n\tregmap_write(info->regmap, SUN4I_GPADC_CTRL3,\n\t\t     SUN4I_GPADC_CTRL3_FILTER_EN |\n\t\t     SUN4I_GPADC_CTRL3_FILTER_TYPE(1));\n\t \n\tregmap_write(info->regmap, SUN4I_GPADC_TPR,\n\t\t     SUN4I_GPADC_TPR_TEMP_ENABLE |\n\t\t     SUN4I_GPADC_TPR_TEMP_PERIOD(800));\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct sun4i_gpadc_iio *info = thermal_zone_device_priv(tz);\n\tint val, scale, offset;\n\n\tif (sun4i_gpadc_temp_read(info->indio_dev, &val))\n\t\treturn -ETIMEDOUT;\n\n\tsun4i_gpadc_temp_scale(info->indio_dev, &scale);\n\tsun4i_gpadc_temp_offset(info->indio_dev, &offset);\n\n\t*temp = (val + offset) * scale;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops sun4i_ts_tz_ops = {\n\t.get_temp = &sun4i_gpadc_get_temp,\n};\n\nstatic const struct dev_pm_ops sun4i_gpadc_pm_ops = {\n\t.runtime_suspend = &sun4i_gpadc_runtime_suspend,\n\t.runtime_resume = &sun4i_gpadc_runtime_resume,\n};\n\nstatic int sun4i_irq_init(struct platform_device *pdev, const char *name,\n\t\t\t  irq_handler_t handler, const char *devname,\n\t\t\t  unsigned int *irq, atomic_t *atomic)\n{\n\tint ret;\n\tstruct sun4i_gpadc_dev *mfd_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(&pdev->dev));\n\n\t \n\tatomic_set(atomic, 1);\n\n\tret = platform_get_irq_byname(pdev, name);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_irq_get_virq(mfd_dev->regmap_irqc, ret);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get virq for irq %s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t*irq = ret;\n\tret = devm_request_any_context_irq(&pdev->dev, *irq, handler,\n\t\t\t\t\t   IRQF_NO_AUTOEN,\n\t\t\t\t\t   devname, info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not request %s interrupt: %d\\n\",\n\t\t\tname, ret);\n\t\treturn ret;\n\t}\n\n\tatomic_set(atomic, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_gpadc_of_id[] = {\n\t{\n\t\t.compatible = \"allwinner,sun8i-a33-ths\",\n\t\t.data = &sun8i_a33_gpadc_data,\n\t},\n\t{   }\n};\n\nstatic int sun4i_gpadc_probe_dt(struct platform_device *pdev,\n\t\t\t\tstruct iio_dev *indio_dev)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\tvoid __iomem *base;\n\tint ret;\n\n\tinfo->data = of_device_get_match_data(&pdev->dev);\n\tif (!info->data)\n\t\treturn -ENODEV;\n\n\tinfo->no_irq = true;\n\tindio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);\n\tindio_dev->channels = sun8i_a33_gpadc_channels;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tinfo->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &sun4i_gpadc_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(&pdev->dev, \"failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_THERMAL_OF))\n\t\tinfo->sensor_device = &pdev->dev;\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_probe_mfd(struct platform_device *pdev,\n\t\t\t\t struct iio_dev *indio_dev)\n{\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\tstruct sun4i_gpadc_dev *sun4i_gpadc_dev =\n\t\tdev_get_drvdata(pdev->dev.parent);\n\tint ret;\n\n\tinfo->no_irq = false;\n\tinfo->regmap = sun4i_gpadc_dev->regmap;\n\n\tindio_dev->num_channels = ARRAY_SIZE(sun4i_gpadc_channels);\n\tindio_dev->channels = sun4i_gpadc_channels;\n\n\tinfo->data = (struct gpadc_data *)platform_get_device_id(pdev)->driver_data;\n\n\t \n\n\tif (IS_ENABLED(CONFIG_THERMAL_OF)) {\n\t\t \n\t\tinfo->sensor_device = pdev->dev.parent;\n\t} else {\n\t\tindio_dev->num_channels =\n\t\t\tARRAY_SIZE(sun4i_gpadc_channels_no_temp);\n\t\tindio_dev->channels = sun4i_gpadc_channels_no_temp;\n\t}\n\n\tif (IS_ENABLED(CONFIG_THERMAL_OF)) {\n\t\tret = sun4i_irq_init(pdev, \"TEMP_DATA_PENDING\",\n\t\t\t\t     sun4i_gpadc_temp_data_irq_handler,\n\t\t\t\t     \"temp_data\", &info->temp_data_irq,\n\t\t\t\t     &info->ignore_temp_data_irq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = sun4i_irq_init(pdev, \"FIFO_DATA_PENDING\",\n\t\t\t     sun4i_gpadc_fifo_data_irq_handler, \"fifo_data\",\n\t\t\t     &info->fifo_data_irq, &info->ignore_fifo_data_irq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_THERMAL_OF)) {\n\t\tret = iio_map_array_register(indio_dev, sun4i_gpadc_hwmon_maps);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to register iio map array\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_gpadc_iio *info;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tinfo = iio_priv(indio_dev);\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tmutex_init(&info->mutex);\n\tinfo->indio_dev = indio_dev;\n\tinit_completion(&info->completion);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &sun4i_gpadc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (pdev->dev.of_node)\n\t\tret = sun4i_gpadc_probe_dt(pdev, indio_dev);\n\telse\n\t\tret = sun4i_gpadc_probe_mfd(pdev, indio_dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t SUN4I_GPADC_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tif (IS_ENABLED(CONFIG_THERMAL_OF)) {\n\t\tinfo->tzd = devm_thermal_of_zone_register(info->sensor_device,\n\t\t\t\t\t\t\t  0, info,\n\t\t\t\t\t\t\t  &sun4i_ts_tz_ops);\n\t\t \n\t\tif (IS_ERR(info->tzd) && PTR_ERR(info->tzd) != -ENODEV) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"could not register thermal sensor: %ld\\n\",\n\t\t\t\tPTR_ERR(info->tzd));\n\t\t\treturn PTR_ERR(info->tzd);\n\t\t}\n\t}\n\n\tret = devm_iio_device_register(&pdev->dev, indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not register the device\\n\");\n\t\tgoto err_map;\n\t}\n\n\treturn 0;\n\nerr_map:\n\tif (!info->no_irq && IS_ENABLED(CONFIG_THERMAL_OF))\n\t\tiio_map_array_unregister(indio_dev);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int sun4i_gpadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (!IS_ENABLED(CONFIG_THERMAL_OF))\n\t\treturn 0;\n\n\tif (!info->no_irq)\n\t\tiio_map_array_unregister(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sun4i_gpadc_id[] = {\n\t{ \"sun4i-a10-gpadc-iio\", (kernel_ulong_t)&sun4i_gpadc_data },\n\t{ \"sun5i-a13-gpadc-iio\", (kernel_ulong_t)&sun5i_gpadc_data },\n\t{ \"sun6i-a31-gpadc-iio\", (kernel_ulong_t)&sun6i_gpadc_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, sun4i_gpadc_id);\n\nstatic struct platform_driver sun4i_gpadc_driver = {\n\t.driver = {\n\t\t.name = \"sun4i-gpadc-iio\",\n\t\t.of_match_table = sun4i_gpadc_of_id,\n\t\t.pm = &sun4i_gpadc_pm_ops,\n\t},\n\t.id_table = sun4i_gpadc_id,\n\t.probe = sun4i_gpadc_probe,\n\t.remove = sun4i_gpadc_remove,\n};\nMODULE_DEVICE_TABLE(of, sun4i_gpadc_of_id);\n\nmodule_platform_driver(sun4i_gpadc_driver);\n\nMODULE_DESCRIPTION(\"ADC driver for sunxi platforms\");\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}