{
  "module_name": "rcar-gyroadc.c",
  "hash_id": "3f77186b77ef9aa99500cb3ed7f9aef9ca7868c26f8b5f058c855260479d56be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/rcar-gyroadc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of_platform.h>\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n\n#define DRIVER_NAME\t\t\t\t\"rcar-gyroadc\"\n\n \n#define RCAR_GYROADC_MODE_SELECT\t\t0x00\n#define RCAR_GYROADC_MODE_SELECT_1_MB88101A\t0x0\n#define RCAR_GYROADC_MODE_SELECT_2_ADCS7476\t0x1\n#define RCAR_GYROADC_MODE_SELECT_3_MAX1162\t0x3\n\n#define RCAR_GYROADC_START_STOP\t\t\t0x04\n#define RCAR_GYROADC_START_STOP_START\t\tBIT(0)\n\n#define RCAR_GYROADC_CLOCK_LENGTH\t\t0x08\n#define RCAR_GYROADC_1_25MS_LENGTH\t\t0x0c\n\n#define RCAR_GYROADC_REALTIME_DATA(ch)\t\t(0x10 + ((ch) * 4))\n#define RCAR_GYROADC_100MS_ADDED_DATA(ch)\t(0x30 + ((ch) * 4))\n#define RCAR_GYROADC_10MS_AVG_DATA(ch)\t\t(0x50 + ((ch) * 4))\n\n#define RCAR_GYROADC_FIFO_STATUS\t\t0x70\n#define RCAR_GYROADC_FIFO_STATUS_EMPTY(ch)\tBIT(0 + (4 * (ch)))\n#define RCAR_GYROADC_FIFO_STATUS_FULL(ch)\tBIT(1 + (4 * (ch)))\n#define RCAR_GYROADC_FIFO_STATUS_ERROR(ch)\tBIT(2 + (4 * (ch)))\n\n#define RCAR_GYROADC_INTR\t\t\t0x74\n#define RCAR_GYROADC_INTR_INT\t\t\tBIT(0)\n\n#define RCAR_GYROADC_INTENR\t\t\t0x78\n#define RCAR_GYROADC_INTENR_INTEN\t\tBIT(0)\n\n#define RCAR_GYROADC_SAMPLE_RATE\t\t800\t \n\n#define RCAR_GYROADC_RUNTIME_PM_DELAY_MS\t2000\n\nenum rcar_gyroadc_model {\n\tRCAR_GYROADC_MODEL_DEFAULT,\n\tRCAR_GYROADC_MODEL_R8A7792,\n};\n\nstruct rcar_gyroadc {\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\tstruct clk\t\t\t*clk;\n\tstruct regulator\t\t*vref[8];\n\tunsigned int\t\t\tnum_channels;\n\tenum rcar_gyroadc_model\t\tmodel;\n\tunsigned int\t\t\tmode;\n\tunsigned int\t\t\tsample_width;\n};\n\nstatic void rcar_gyroadc_hw_init(struct rcar_gyroadc *priv)\n{\n\tconst unsigned long clk_mhz = clk_get_rate(priv->clk) / 1000000;\n\tconst unsigned long clk_mul =\n\t\t(priv->mode == RCAR_GYROADC_MODE_SELECT_1_MB88101A) ? 10 : 5;\n\tunsigned long clk_len = clk_mhz * clk_mul;\n\n\t \n\tif (clk_len & 1)\n\t\tclk_len++;\n\n\t \n\twritel(0, priv->regs + RCAR_GYROADC_START_STOP);\n\n\t \n\tif (priv->model == RCAR_GYROADC_MODEL_R8A7792)\n\t\twritel(0, priv->regs + RCAR_GYROADC_INTENR);\n\n\t \n\twritel(priv->mode, priv->regs + RCAR_GYROADC_MODE_SELECT);\n\twritel(clk_len, priv->regs + RCAR_GYROADC_CLOCK_LENGTH);\n\twritel(clk_mhz * 1250, priv->regs + RCAR_GYROADC_1_25MS_LENGTH);\n}\n\nstatic void rcar_gyroadc_hw_start(struct rcar_gyroadc *priv)\n{\n\t \n\twritel(RCAR_GYROADC_START_STOP_START,\n\t       priv->regs + RCAR_GYROADC_START_STOP);\n\n\t \n\tmdelay(3);\n}\n\nstatic void rcar_gyroadc_hw_stop(struct rcar_gyroadc *priv)\n{\n\t \n\twritel(0, priv->regs + RCAR_GYROADC_START_STOP);\n}\n\n#define RCAR_GYROADC_CHAN(_idx) {\t\t\t\t\\\n\t.type\t\t\t= IIO_VOLTAGE,\t\t\t\\\n\t.indexed\t\t= 1,\t\t\t\t\\\n\t.channel\t\t= (_idx),\t\t\t\\\n\t.info_mask_separate\t= BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\t\t  BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n}\n\nstatic const struct iio_chan_spec rcar_gyroadc_iio_channels_1[] = {\n\tRCAR_GYROADC_CHAN(0),\n\tRCAR_GYROADC_CHAN(1),\n\tRCAR_GYROADC_CHAN(2),\n\tRCAR_GYROADC_CHAN(3),\n};\n\nstatic const struct iio_chan_spec rcar_gyroadc_iio_channels_2[] = {\n\tRCAR_GYROADC_CHAN(0),\n\tRCAR_GYROADC_CHAN(1),\n\tRCAR_GYROADC_CHAN(2),\n\tRCAR_GYROADC_CHAN(3),\n\tRCAR_GYROADC_CHAN(4),\n\tRCAR_GYROADC_CHAN(5),\n\tRCAR_GYROADC_CHAN(6),\n\tRCAR_GYROADC_CHAN(7),\n};\n\nstatic const struct iio_chan_spec rcar_gyroadc_iio_channels_3[] = {\n\tRCAR_GYROADC_CHAN(0),\n\tRCAR_GYROADC_CHAN(1),\n\tRCAR_GYROADC_CHAN(2),\n\tRCAR_GYROADC_CHAN(3),\n\tRCAR_GYROADC_CHAN(4),\n\tRCAR_GYROADC_CHAN(5),\n\tRCAR_GYROADC_CHAN(6),\n\tRCAR_GYROADC_CHAN(7),\n};\n\nstatic int rcar_gyroadc_set_power(struct rcar_gyroadc *priv, bool on)\n{\n\tstruct device *dev = priv->dev;\n\n\tif (on) {\n\t\treturn pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\treturn pm_runtime_put_autosuspend(dev);\n\t}\n}\n\nstatic int rcar_gyroadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tstruct regulator *consumer;\n\tunsigned int datareg = RCAR_GYROADC_REALTIME_DATA(chan->channel);\n\tunsigned int vref;\n\tint ret;\n\n\t \n\tif (priv->mode == RCAR_GYROADC_MODE_SELECT_1_MB88101A)\n\t\tconsumer = priv->vref[0];\n\telse\n\t\tconsumer = priv->vref[chan->channel];\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_VOLTAGE)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!consumer)\n\t\t\treturn -EINVAL;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rcar_gyroadc_set_power(priv, true);\n\t\tif (ret < 0) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = readl(priv->regs + datareg);\n\t\t*val &= BIT(priv->sample_width) - 1;\n\n\t\tret = rcar_gyroadc_set_power(priv, false);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tif (!consumer)\n\t\t\treturn -EINVAL;\n\n\t\tvref = regulator_get_voltage(consumer);\n\t\t*val = vref / 1000;\n\t\t*val2 = 1 << priv->sample_width;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = RCAR_GYROADC_SAMPLE_RATE;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rcar_gyroadc_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t   unsigned int reg, unsigned int writeval,\n\t\t\t\t   unsigned int *readval)\n{\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tunsigned int maxreg = RCAR_GYROADC_FIFO_STATUS;\n\n\tif (readval == NULL)\n\t\treturn -EINVAL;\n\n\tif (reg % 4)\n\t\treturn -EINVAL;\n\n\t \n\tif (priv->model == RCAR_GYROADC_MODEL_R8A7792)\n\t\tmaxreg = RCAR_GYROADC_INTENR;\n\n\tif (reg > maxreg)\n\t\treturn -EINVAL;\n\n\t*readval = readl(priv->regs + reg);\n\n\treturn 0;\n}\n\nstatic const struct iio_info rcar_gyroadc_iio_info = {\n\t.read_raw\t\t= rcar_gyroadc_read_raw,\n\t.debugfs_reg_access\t= rcar_gyroadc_reg_access,\n};\n\nstatic const struct of_device_id rcar_gyroadc_match[] = {\n\t{\n\t\t \n\t\t.compatible\t= \"renesas,rcar-gyroadc\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODEL_DEFAULT,\n\t}, {\n\t\t \n\t\t.compatible\t= \"renesas,r8a7792-gyroadc\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODEL_R8A7792,\n\t}, {\n\t\t \n\t}\n};\n\nMODULE_DEVICE_TABLE(of, rcar_gyroadc_match);\n\nstatic const struct of_device_id rcar_gyroadc_child_match[] __maybe_unused = {\n\t \n\t{\n\t\t.compatible\t= \"fujitsu,mb88101a\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_1_MB88101A,\n\t},\n\t \n\t{\n\t\t.compatible\t= \"ti,adcs7476\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_2_ADCS7476,\n\t}, {\n\t\t.compatible\t= \"ti,adc121\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_2_ADCS7476,\n\t}, {\n\t\t.compatible\t= \"adi,ad7476\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_2_ADCS7476,\n\t},\n\t \n\t{\n\t\t.compatible\t= \"maxim,max1162\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_3_MAX1162,\n\t}, {\n\t\t.compatible\t= \"maxim,max11100\",\n\t\t.data\t\t= (void *)RCAR_GYROADC_MODE_SELECT_3_MAX1162,\n\t},\n\t{   }\n};\n\nstatic int rcar_gyroadc_parse_subdevs(struct iio_dev *indio_dev)\n{\n\tconst struct of_device_id *of_id;\n\tconst struct iio_chan_spec *channels;\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tstruct device *dev = priv->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tstruct regulator *vref;\n\tunsigned int reg;\n\tunsigned int adcmode = -1, childmode;\n\tunsigned int sample_width;\n\tunsigned int num_channels;\n\tint ret, first = 1;\n\n\tfor_each_child_of_node(np, child) {\n\t\tof_id = of_match_node(rcar_gyroadc_child_match, child);\n\t\tif (!of_id) {\n\t\t\tdev_err(dev, \"Ignoring unsupported ADC \\\"%pOFn\\\".\",\n\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildmode = (uintptr_t)of_id->data;\n\t\tswitch (childmode) {\n\t\tcase RCAR_GYROADC_MODE_SELECT_1_MB88101A:\n\t\t\tsample_width = 12;\n\t\t\tchannels = rcar_gyroadc_iio_channels_1;\n\t\t\tnum_channels = ARRAY_SIZE(rcar_gyroadc_iio_channels_1);\n\t\t\tbreak;\n\t\tcase RCAR_GYROADC_MODE_SELECT_2_ADCS7476:\n\t\t\tsample_width = 15;\n\t\t\tchannels = rcar_gyroadc_iio_channels_2;\n\t\t\tnum_channels = ARRAY_SIZE(rcar_gyroadc_iio_channels_2);\n\t\t\tbreak;\n\t\tcase RCAR_GYROADC_MODE_SELECT_3_MAX1162:\n\t\t\tsample_width = 16;\n\t\t\tchannels = rcar_gyroadc_iio_channels_3;\n\t\t\tnum_channels = ARRAY_SIZE(rcar_gyroadc_iio_channels_3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_e_inval;\n\t\t}\n\n\t\t \n\t\tif (childmode == RCAR_GYROADC_MODE_SELECT_1_MB88101A) {\n\t\t\treg = 0;\n\t\t} else {\n\t\t\tret = of_property_read_u32(child, \"reg\", &reg);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to get child reg property of ADC \\\"%pOFn\\\".\\n\",\n\t\t\t\t\tchild);\n\t\t\t\tgoto err_of_node_put;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reg >= num_channels) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Only %i channels supported with %pOFn, but reg = <%i>.\\n\",\n\t\t\t\t\tnum_channels, child, reg);\n\t\t\t\tgoto err_e_inval;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!first && (adcmode != childmode)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Channel %i uses different ADC mode than the rest.\\n\",\n\t\t\t\treg);\n\t\t\tgoto err_e_inval;\n\t\t}\n\n\t\t \n\t\tdev->of_node = child;\n\t\tvref = devm_regulator_get(dev, \"vref\");\n\t\tdev->of_node = np;\n\t\tif (IS_ERR(vref)) {\n\t\t\tdev_dbg(dev, \"Channel %i 'vref' supply not connected.\\n\",\n\t\t\t\treg);\n\t\t\tret = PTR_ERR(vref);\n\t\t\tgoto err_of_node_put;\n\t\t}\n\n\t\tpriv->vref[reg] = vref;\n\n\t\tif (!first)\n\t\t\tcontinue;\n\n\t\t \n\t\tadcmode = childmode;\n\t\tfirst = 0;\n\n\t\tpriv->num_channels = num_channels;\n\t\tpriv->mode = childmode;\n\t\tpriv->sample_width = sample_width;\n\n\t\tindio_dev->channels = channels;\n\t\tindio_dev->num_channels = num_channels;\n\n\t\t \n\t\tif (childmode == RCAR_GYROADC_MODE_SELECT_1_MB88101A) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first) {\n\t\tdev_err(dev, \"No valid ADC channels found, aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nerr_e_inval:\n\tret = -EINVAL;\nerr_of_node_put:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic void rcar_gyroadc_deinit_supplies(struct iio_dev *indio_dev)\n{\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->num_channels; i++) {\n\t\tif (!priv->vref[i])\n\t\t\tcontinue;\n\n\t\tregulator_disable(priv->vref[i]);\n\t}\n}\n\nstatic int rcar_gyroadc_init_supplies(struct iio_dev *indio_dev)\n{\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tstruct device *dev = priv->dev;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < priv->num_channels; i++) {\n\t\tif (!priv->vref[i])\n\t\t\tcontinue;\n\n\t\tret = regulator_enable(priv->vref[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator %i (ret=%i)\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\trcar_gyroadc_deinit_supplies(indio_dev);\n\treturn ret;\n}\n\nstatic int rcar_gyroadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_gyroadc *priv;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->dev = dev;\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tpriv->clk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"Failed to get IF clock\\n\");\n\n\tret = rcar_gyroadc_parse_subdevs(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rcar_gyroadc_init_supplies(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->model = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = DRIVER_NAME;\n\tindio_dev->info = &rcar_gyroadc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not prepare or enable the IF clock.\\n\");\n\t\tgoto err_clk_if_enable;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, RCAR_GYROADC_RUNTIME_PM_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\tgoto err_power_up;\n\n\trcar_gyroadc_hw_init(priv);\n\trcar_gyroadc_hw_start(priv);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register IIO device.\\n\");\n\t\tgoto err_iio_device_register;\n\t}\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n\nerr_iio_device_register:\n\trcar_gyroadc_hw_stop(priv);\n\tpm_runtime_put_sync(dev);\nerr_power_up:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tclk_disable_unprepare(priv->clk);\nerr_clk_if_enable:\n\trcar_gyroadc_deinit_supplies(indio_dev);\n\n\treturn ret;\n}\n\nstatic int rcar_gyroadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\tstruct device *dev = priv->dev;\n\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_get_sync(dev);\n\trcar_gyroadc_hw_stop(priv);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tclk_disable_unprepare(priv->clk);\n\trcar_gyroadc_deinit_supplies(indio_dev);\n\n\treturn 0;\n}\n\nstatic int rcar_gyroadc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\n\trcar_gyroadc_hw_stop(priv);\n\n\treturn 0;\n}\n\nstatic int rcar_gyroadc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rcar_gyroadc *priv = iio_priv(indio_dev);\n\n\trcar_gyroadc_hw_start(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rcar_gyroadc_pm_ops = {\n\tRUNTIME_PM_OPS(rcar_gyroadc_suspend, rcar_gyroadc_resume, NULL)\n};\n\nstatic struct platform_driver rcar_gyroadc_driver = {\n\t.probe          = rcar_gyroadc_probe,\n\t.remove         = rcar_gyroadc_remove,\n\t.driver         = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= rcar_gyroadc_match,\n\t\t.pm\t\t= pm_ptr(&rcar_gyroadc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(rcar_gyroadc_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_DESCRIPTION(\"Renesas R-Car GyroADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}