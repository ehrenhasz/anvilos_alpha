{
  "module_name": "rockchip_saradc.c",
  "hash_id": "b924cc08c4b30d90e4668a6d94aab4874eda3c88dddab17c27c2fb7b5dc1cbc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/rockchip_saradc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/reset.h>\n#include <linux/regulator/consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define SARADC_DATA\t\t\t0x00\n\n#define SARADC_STAS\t\t\t0x04\n#define SARADC_STAS_BUSY\t\tBIT(0)\n\n#define SARADC_CTRL\t\t\t0x08\n#define SARADC_CTRL_IRQ_STATUS\t\tBIT(6)\n#define SARADC_CTRL_IRQ_ENABLE\t\tBIT(5)\n#define SARADC_CTRL_POWER_CTRL\t\tBIT(3)\n#define SARADC_CTRL_CHN_MASK\t\t0x7\n\n#define SARADC_DLY_PU_SOC\t\t0x0c\n#define SARADC_DLY_PU_SOC_MASK\t\t0x3f\n\n#define SARADC_TIMEOUT\t\t\tmsecs_to_jiffies(100)\n#define SARADC_MAX_CHANNELS\t\t8\n\n \n#define SARADC2_CONV_CON\t\t0x000\n#define SARADC_T_PD_SOC\t\t\t0x004\n#define SARADC_T_DAS_SOC\t\t0x00c\n#define SARADC2_END_INT_EN\t\t0x104\n#define SARADC2_ST_CON\t\t\t0x108\n#define SARADC2_STATUS\t\t\t0x10c\n#define SARADC2_END_INT_ST\t\t0x110\n#define SARADC2_DATA_BASE\t\t0x120\n\n#define SARADC2_EN_END_INT\t\tBIT(0)\n#define SARADC2_START\t\t\tBIT(4)\n#define SARADC2_SINGLE_MODE\t\tBIT(5)\n\n#define SARADC2_CONV_CHANNELS GENMASK(15, 0)\n\nstruct rockchip_saradc;\n\nstruct rockchip_saradc_data {\n\tconst struct iio_chan_spec\t*channels;\n\tint\t\t\t\tnum_channels;\n\tunsigned long\t\t\tclk_rate;\n\tvoid (*start)(struct rockchip_saradc *info, int chn);\n\tint (*read)(struct rockchip_saradc *info);\n\tvoid (*power_down)(struct rockchip_saradc *info);\n};\n\nstruct rockchip_saradc {\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*pclk;\n\tstruct clk\t\t*clk;\n\tstruct completion\tcompletion;\n\tstruct regulator\t*vref;\n\t \n\tstruct mutex\t\tlock;\n\tint\t\t\tuv_vref;\n\tstruct reset_control\t*reset;\n\tconst struct rockchip_saradc_data *data;\n\tu16\t\t\tlast_val;\n\tconst struct iio_chan_spec *last_chan;\n\tstruct notifier_block nb;\n};\n\nstatic void rockchip_saradc_reset_controller(struct reset_control *reset);\n\nstatic void rockchip_saradc_start_v1(struct rockchip_saradc *info, int chn)\n{\n\t \n\twritel_relaxed(8, info->regs + SARADC_DLY_PU_SOC);\n\t \n\twritel(SARADC_CTRL_POWER_CTRL | (chn & SARADC_CTRL_CHN_MASK) |\n\t       SARADC_CTRL_IRQ_ENABLE, info->regs + SARADC_CTRL);\n}\n\nstatic void rockchip_saradc_start_v2(struct rockchip_saradc *info, int chn)\n{\n\tint val;\n\n\tif (info->reset)\n\t\trockchip_saradc_reset_controller(info->reset);\n\n\twritel_relaxed(0xc, info->regs + SARADC_T_DAS_SOC);\n\twritel_relaxed(0x20, info->regs + SARADC_T_PD_SOC);\n\tval = FIELD_PREP(SARADC2_EN_END_INT, 1);\n\tval |= val << 16;\n\twritel_relaxed(val, info->regs + SARADC2_END_INT_EN);\n\tval = FIELD_PREP(SARADC2_START, 1) |\n\t      FIELD_PREP(SARADC2_SINGLE_MODE, 1) |\n\t      FIELD_PREP(SARADC2_CONV_CHANNELS, chn);\n\tval |= val << 16;\n\twritel(val, info->regs + SARADC2_CONV_CON);\n}\n\nstatic void rockchip_saradc_start(struct rockchip_saradc *info, int chn)\n{\n\tinfo->data->start(info, chn);\n}\n\nstatic int rockchip_saradc_read_v1(struct rockchip_saradc *info)\n{\n\treturn readl_relaxed(info->regs + SARADC_DATA);\n}\n\nstatic int rockchip_saradc_read_v2(struct rockchip_saradc *info)\n{\n\tint offset;\n\n\t \n\twritel_relaxed(0x1, info->regs + SARADC2_END_INT_ST);\n\n\toffset = SARADC2_DATA_BASE + info->last_chan->channel * 0x4;\n\n\treturn readl_relaxed(info->regs + offset);\n}\n\nstatic int rockchip_saradc_read(struct rockchip_saradc *info)\n{\n\treturn info->data->read(info);\n}\n\nstatic void rockchip_saradc_power_down_v1(struct rockchip_saradc *info)\n{\n\twritel_relaxed(0, info->regs + SARADC_CTRL);\n}\n\nstatic void rockchip_saradc_power_down(struct rockchip_saradc *info)\n{\n\tif (info->data->power_down)\n\t\tinfo->data->power_down(info);\n}\n\nstatic int rockchip_saradc_conversion(struct rockchip_saradc *info,\n\t\t\t\t      struct iio_chan_spec const *chan)\n{\n\treinit_completion(&info->completion);\n\n\tinfo->last_chan = chan;\n\trockchip_saradc_start(info, chan->channel);\n\n\tif (!wait_for_completion_timeout(&info->completion, SARADC_TIMEOUT))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int rockchip_saradc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct rockchip_saradc *info = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&info->lock);\n\n\t\tret = rockchip_saradc_conversion(info, chan);\n\t\tif (ret) {\n\t\t\trockchip_saradc_power_down(info);\n\t\t\tmutex_unlock(&info->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = info->last_val;\n\t\tmutex_unlock(&info->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = info->uv_vref / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t rockchip_saradc_isr(int irq, void *dev_id)\n{\n\tstruct rockchip_saradc *info = dev_id;\n\n\t \n\tinfo->last_val = rockchip_saradc_read(info);\n\tinfo->last_val &= GENMASK(info->last_chan->scan_type.realbits - 1, 0);\n\n\trockchip_saradc_power_down(info);\n\n\tcomplete(&info->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info rockchip_saradc_iio_info = {\n\t.read_raw = rockchip_saradc_read_raw,\n};\n\n#define SARADC_CHANNEL(_index, _id, _res) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _index,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.datasheet_name = _id,\t\t\t\t\t\\\n\t.scan_index = _index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = _res,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec rockchip_saradc_iio_channels[] = {\n\tSARADC_CHANNEL(0, \"adc0\", 10),\n\tSARADC_CHANNEL(1, \"adc1\", 10),\n\tSARADC_CHANNEL(2, \"adc2\", 10),\n};\n\nstatic const struct rockchip_saradc_data saradc_data = {\n\t.channels = rockchip_saradc_iio_channels,\n\t.num_channels = ARRAY_SIZE(rockchip_saradc_iio_channels),\n\t.clk_rate = 1000000,\n\t.start = rockchip_saradc_start_v1,\n\t.read = rockchip_saradc_read_v1,\n\t.power_down = rockchip_saradc_power_down_v1,\n};\n\nstatic const struct iio_chan_spec rockchip_rk3066_tsadc_iio_channels[] = {\n\tSARADC_CHANNEL(0, \"adc0\", 12),\n\tSARADC_CHANNEL(1, \"adc1\", 12),\n};\n\nstatic const struct rockchip_saradc_data rk3066_tsadc_data = {\n\t.channels = rockchip_rk3066_tsadc_iio_channels,\n\t.num_channels = ARRAY_SIZE(rockchip_rk3066_tsadc_iio_channels),\n\t.clk_rate = 50000,\n\t.start = rockchip_saradc_start_v1,\n\t.read = rockchip_saradc_read_v1,\n\t.power_down = rockchip_saradc_power_down_v1,\n};\n\nstatic const struct iio_chan_spec rockchip_rk3399_saradc_iio_channels[] = {\n\tSARADC_CHANNEL(0, \"adc0\", 10),\n\tSARADC_CHANNEL(1, \"adc1\", 10),\n\tSARADC_CHANNEL(2, \"adc2\", 10),\n\tSARADC_CHANNEL(3, \"adc3\", 10),\n\tSARADC_CHANNEL(4, \"adc4\", 10),\n\tSARADC_CHANNEL(5, \"adc5\", 10),\n};\n\nstatic const struct rockchip_saradc_data rk3399_saradc_data = {\n\t.channels = rockchip_rk3399_saradc_iio_channels,\n\t.num_channels = ARRAY_SIZE(rockchip_rk3399_saradc_iio_channels),\n\t.clk_rate = 1000000,\n\t.start = rockchip_saradc_start_v1,\n\t.read = rockchip_saradc_read_v1,\n\t.power_down = rockchip_saradc_power_down_v1,\n};\n\nstatic const struct iio_chan_spec rockchip_rk3568_saradc_iio_channels[] = {\n\tSARADC_CHANNEL(0, \"adc0\", 10),\n\tSARADC_CHANNEL(1, \"adc1\", 10),\n\tSARADC_CHANNEL(2, \"adc2\", 10),\n\tSARADC_CHANNEL(3, \"adc3\", 10),\n\tSARADC_CHANNEL(4, \"adc4\", 10),\n\tSARADC_CHANNEL(5, \"adc5\", 10),\n\tSARADC_CHANNEL(6, \"adc6\", 10),\n\tSARADC_CHANNEL(7, \"adc7\", 10),\n};\n\nstatic const struct rockchip_saradc_data rk3568_saradc_data = {\n\t.channels = rockchip_rk3568_saradc_iio_channels,\n\t.num_channels = ARRAY_SIZE(rockchip_rk3568_saradc_iio_channels),\n\t.clk_rate = 1000000,\n\t.start = rockchip_saradc_start_v1,\n\t.read = rockchip_saradc_read_v1,\n\t.power_down = rockchip_saradc_power_down_v1,\n};\n\nstatic const struct iio_chan_spec rockchip_rk3588_saradc_iio_channels[] = {\n\tSARADC_CHANNEL(0, \"adc0\", 12),\n\tSARADC_CHANNEL(1, \"adc1\", 12),\n\tSARADC_CHANNEL(2, \"adc2\", 12),\n\tSARADC_CHANNEL(3, \"adc3\", 12),\n\tSARADC_CHANNEL(4, \"adc4\", 12),\n\tSARADC_CHANNEL(5, \"adc5\", 12),\n\tSARADC_CHANNEL(6, \"adc6\", 12),\n\tSARADC_CHANNEL(7, \"adc7\", 12),\n};\n\nstatic const struct rockchip_saradc_data rk3588_saradc_data = {\n\t.channels = rockchip_rk3588_saradc_iio_channels,\n\t.num_channels = ARRAY_SIZE(rockchip_rk3588_saradc_iio_channels),\n\t.clk_rate = 1000000,\n\t.start = rockchip_saradc_start_v2,\n\t.read = rockchip_saradc_read_v2,\n};\n\nstatic const struct of_device_id rockchip_saradc_match[] = {\n\t{\n\t\t.compatible = \"rockchip,saradc\",\n\t\t.data = &saradc_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3066-tsadc\",\n\t\t.data = &rk3066_tsadc_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3399-saradc\",\n\t\t.data = &rk3399_saradc_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3568-saradc\",\n\t\t.data = &rk3568_saradc_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3588-saradc\",\n\t\t.data = &rk3588_saradc_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rockchip_saradc_match);\n\n \nstatic void rockchip_saradc_reset_controller(struct reset_control *reset)\n{\n\treset_control_assert(reset);\n\tusleep_range(10, 20);\n\treset_control_deassert(reset);\n}\n\nstatic void rockchip_saradc_regulator_disable(void *data)\n{\n\tstruct rockchip_saradc *info = data;\n\n\tregulator_disable(info->vref);\n}\n\nstatic irqreturn_t rockchip_saradc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *i_dev = pf->indio_dev;\n\tstruct rockchip_saradc *info = iio_priv(i_dev);\n\t \n\tstruct {\n\t\tu16 values[SARADC_MAX_CHANNELS];\n\t\tint64_t timestamp;\n\t} data;\n\tint ret;\n\tint i, j = 0;\n\n\tmutex_lock(&info->lock);\n\n\tfor_each_set_bit(i, i_dev->active_scan_mask, i_dev->masklength) {\n\t\tconst struct iio_chan_spec *chan = &i_dev->channels[i];\n\n\t\tret = rockchip_saradc_conversion(info, chan);\n\t\tif (ret) {\n\t\t\trockchip_saradc_power_down(info);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata.values[j] = info->last_val;\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(i_dev, &data, iio_get_time_ns(i_dev));\nout:\n\tmutex_unlock(&info->lock);\n\n\tiio_trigger_notify_done(i_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rockchip_saradc_volt_notify(struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *data)\n{\n\tstruct rockchip_saradc *info =\n\t\t\tcontainer_of(nb, struct rockchip_saradc, nb);\n\n\tif (event & REGULATOR_EVENT_VOLTAGE_CHANGE)\n\t\tinfo->uv_vref = (unsigned long)data;\n\n\treturn NOTIFY_OK;\n}\n\nstatic void rockchip_saradc_regulator_unreg_notifier(void *data)\n{\n\tstruct rockchip_saradc *info = data;\n\n\tregulator_unregister_notifier(info->vref, &info->nb);\n}\n\nstatic int rockchip_saradc_probe(struct platform_device *pdev)\n{\n\tconst struct rockchip_saradc_data *match_data;\n\tstruct rockchip_saradc *info = NULL;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct iio_dev *indio_dev = NULL;\n\tint ret;\n\tint irq;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn dev_err_probe(&pdev->dev, -ENOMEM,\n\t\t\t\t     \"failed allocating iio device\\n\");\n\n\tinfo = iio_priv(indio_dev);\n\n\tmatch_data = of_device_get_match_data(&pdev->dev);\n\tif (!match_data)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV,\n\t\t\t\t     \"failed to match device\\n\");\n\n\tinfo->data = match_data;\n\n\t \n\tif (info->data->num_channels > SARADC_MAX_CHANNELS)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"max channels exceeded\");\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\t \n\tinfo->reset = devm_reset_control_get_exclusive(&pdev->dev,\n\t\t\t\t\t\t       \"saradc-apb\");\n\tif (IS_ERR(info->reset)) {\n\t\tret = PTR_ERR(info->reset);\n\t\tif (ret != -ENOENT)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"failed to get saradc-apb\\n\");\n\n\t\tdev_dbg(&pdev->dev, \"no reset control found\\n\");\n\t\tinfo->reset = NULL;\n\t}\n\n\tinit_completion(&info->completion);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, rockchip_saradc_isr,\n\t\t\t       0, dev_name(&pdev->dev), info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed requesting irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tinfo->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(info->vref))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->vref),\n\t\t\t\t     \"failed to get regulator\\n\");\n\n\tif (info->reset)\n\t\trockchip_saradc_reset_controller(info->reset);\n\n\t \n\tret = clk_set_rate(info->clk, info->data->clk_rate);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to set adc clk rate\\n\");\n\n\tret = regulator_enable(info->vref);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to enable vref regulator\\n\");\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rockchip_saradc_regulator_disable, info);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to register devm action\\n\");\n\n\tret = regulator_get_voltage(info->vref);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo->uv_vref = ret;\n\n\tinfo->pclk = devm_clk_get_enabled(&pdev->dev, \"apb_pclk\");\n\tif (IS_ERR(info->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->pclk),\n\t\t\t\t     \"failed to get pclk\\n\");\n\n\tinfo->clk = devm_clk_get_enabled(&pdev->dev, \"saradc\");\n\tif (IS_ERR(info->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->clk),\n\t\t\t\t     \"failed to get adc clock\\n\");\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &rockchip_saradc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tindio_dev->channels = info->data->channels;\n\tindio_dev->num_channels = info->data->num_channels;\n\tret = devm_iio_triggered_buffer_setup(&indio_dev->dev, indio_dev, NULL,\n\t\t\t\t\t      rockchip_saradc_trigger_handler,\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->nb.notifier_call = rockchip_saradc_volt_notify;\n\tret = regulator_register_notifier(info->vref, &info->nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rockchip_saradc_regulator_unreg_notifier,\n\t\t\t\t       info);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&info->lock);\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic int rockchip_saradc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rockchip_saradc *info = iio_priv(indio_dev);\n\n\tclk_disable_unprepare(info->clk);\n\tclk_disable_unprepare(info->pclk);\n\tregulator_disable(info->vref);\n\n\treturn 0;\n}\n\nstatic int rockchip_saradc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct rockchip_saradc *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(info->vref);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(info->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret)\n\t\tclk_disable_unprepare(info->pclk);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(rockchip_saradc_pm_ops,\n\t\t\t\trockchip_saradc_suspend,\n\t\t\t\trockchip_saradc_resume);\n\nstatic struct platform_driver rockchip_saradc_driver = {\n\t.probe\t\t= rockchip_saradc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-saradc\",\n\t\t.of_match_table = rockchip_saradc_match,\n\t\t.pm\t= pm_sleep_ptr(&rockchip_saradc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(rockchip_saradc_driver);\n\nMODULE_AUTHOR(\"Heiko Stuebner <heiko@sntech.de>\");\nMODULE_DESCRIPTION(\"Rockchip SARADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}