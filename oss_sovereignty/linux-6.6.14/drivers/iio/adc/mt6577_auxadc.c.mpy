{
  "module_name": "mt6577_auxadc.c",
  "hash_id": "a4813c8e20f622cb73687356bb60b39b271ad11b18b8e6598384d612cd46169b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mt6577_auxadc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/iopoll.h>\n#include <linux/io.h>\n#include <linux/iio/iio.h>\n\n \n#define MT6577_AUXADC_CON0                    0x00\n#define MT6577_AUXADC_CON1                    0x04\n#define MT6577_AUXADC_CON2                    0x10\n#define MT6577_AUXADC_STA                     BIT(0)\n\n#define MT6577_AUXADC_DAT0                    0x14\n#define MT6577_AUXADC_RDY0                    BIT(12)\n\n#define MT6577_AUXADC_MISC                    0x94\n#define MT6577_AUXADC_PDN_EN                  BIT(14)\n\n#define MT6577_AUXADC_DAT_MASK                0xfff\n#define MT6577_AUXADC_SLEEP_US                1000\n#define MT6577_AUXADC_TIMEOUT_US              10000\n#define MT6577_AUXADC_POWER_READY_MS          1\n#define MT6577_AUXADC_SAMPLE_READY_US         25\n\nstruct mtk_auxadc_compatible {\n\tbool sample_data_cali;\n\tbool check_global_idle;\n};\n\nstruct mt6577_auxadc_device {\n\tvoid __iomem *reg_base;\n\tstruct clk *adc_clk;\n\tstruct mutex lock;\n\tconst struct mtk_auxadc_compatible *dev_comp;\n};\n\nstatic const struct mtk_auxadc_compatible mt8186_compat = {\n\t.sample_data_cali = false,\n\t.check_global_idle = false,\n};\n\nstatic const struct mtk_auxadc_compatible mt8173_compat = {\n\t.sample_data_cali = false,\n\t.check_global_idle = true,\n};\n\nstatic const struct mtk_auxadc_compatible mt6765_compat = {\n\t.sample_data_cali = true,\n\t.check_global_idle = false,\n};\n\n#define MT6577_AUXADC_CHANNEL(idx) {\t\t\t\t    \\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t    \\\n\t\t.indexed = 1,\t\t\t\t\t    \\\n\t\t.channel = (idx),\t\t\t\t    \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \\\n}\n\nstatic const struct iio_chan_spec mt6577_auxadc_iio_channels[] = {\n\tMT6577_AUXADC_CHANNEL(0),\n\tMT6577_AUXADC_CHANNEL(1),\n\tMT6577_AUXADC_CHANNEL(2),\n\tMT6577_AUXADC_CHANNEL(3),\n\tMT6577_AUXADC_CHANNEL(4),\n\tMT6577_AUXADC_CHANNEL(5),\n\tMT6577_AUXADC_CHANNEL(6),\n\tMT6577_AUXADC_CHANNEL(7),\n\tMT6577_AUXADC_CHANNEL(8),\n\tMT6577_AUXADC_CHANNEL(9),\n\tMT6577_AUXADC_CHANNEL(10),\n\tMT6577_AUXADC_CHANNEL(11),\n\tMT6577_AUXADC_CHANNEL(12),\n\tMT6577_AUXADC_CHANNEL(13),\n\tMT6577_AUXADC_CHANNEL(14),\n\tMT6577_AUXADC_CHANNEL(15),\n};\n\n \n#define VOLTAGE_FULL_RANGE  1500\t \n#define AUXADC_PRECISE      4096\t \n\nstatic int mt_auxadc_get_cali_data(int rawdata, bool enable_cali)\n{\n\treturn rawdata;\n}\n\nstatic inline void mt6577_auxadc_mod_reg(void __iomem *reg,\n\t\t\t\t\t u32 or_mask, u32 and_mask)\n{\n\tu32 val;\n\n\tval = readl(reg);\n\tval |= or_mask;\n\tval &= ~and_mask;\n\twritel(val, reg);\n}\n\nstatic int mt6577_auxadc_read(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan)\n{\n\tu32 val;\n\tvoid __iomem *reg_channel;\n\tint ret;\n\tstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\n\n\treg_channel = adc_dev->reg_base + MT6577_AUXADC_DAT0 +\n\t\t      chan->channel * 0x04;\n\n\tmutex_lock(&adc_dev->lock);\n\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_CON1,\n\t\t\t      0, 1 << chan->channel);\n\n\t \n\tret = readl_poll_timeout(reg_channel, val,\n\t\t\t\t ((val & MT6577_AUXADC_RDY0) == 0),\n\t\t\t\t MT6577_AUXADC_SLEEP_US,\n\t\t\t\t MT6577_AUXADC_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"wait for channel[%d] ready bit clear time out\\n\",\n\t\t\tchan->channel);\n\t\tgoto err_timeout;\n\t}\n\n\t \n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_CON1,\n\t\t\t      1 << chan->channel, 0);\n\n\t \n\tudelay(MT6577_AUXADC_SAMPLE_READY_US);\n\n\tif (adc_dev->dev_comp->check_global_idle) {\n\t\t \n\t\tret = readl_poll_timeout(adc_dev->reg_base + MT6577_AUXADC_CON2,\n\t\t\t\t\t val, ((val & MT6577_AUXADC_STA) == 0),\n\t\t\t\t\t MT6577_AUXADC_SLEEP_US,\n\t\t\t\t\t MT6577_AUXADC_TIMEOUT_US);\n\t\tif (ret < 0) {\n\t\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\t\"wait for auxadc idle time out\\n\");\n\t\t\tgoto err_timeout;\n\t\t}\n\t}\n\n\t \n\tret = readl_poll_timeout(reg_channel, val,\n\t\t\t\t ((val & MT6577_AUXADC_RDY0) != 0),\n\t\t\t\t MT6577_AUXADC_SLEEP_US,\n\t\t\t\t MT6577_AUXADC_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"wait for channel[%d] data ready time out\\n\",\n\t\t\tchan->channel);\n\t\tgoto err_timeout;\n\t}\n\n\t \n\tval = readl(reg_channel) & MT6577_AUXADC_DAT_MASK;\n\n\tmutex_unlock(&adc_dev->lock);\n\n\treturn val;\n\nerr_timeout:\n\n\tmutex_unlock(&adc_dev->lock);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mt6577_auxadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int *val,\n\t\t\t\t  int *val2,\n\t\t\t\t  long info)\n{\n\tstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\t*val = mt6577_auxadc_read(indio_dev, chan);\n\t\tif (*val < 0) {\n\t\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\t\"failed to sample data on channel[%d]\\n\",\n\t\t\t\tchan->channel);\n\t\t\treturn *val;\n\t\t}\n\t\tif (adc_dev->dev_comp->sample_data_cali)\n\t\t\t*val = mt_auxadc_get_cali_data(*val, true);\n\n\t\t \n\t\t*val = *val * VOLTAGE_FULL_RANGE / AUXADC_PRECISE;\n\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mt6577_auxadc_info = {\n\t.read_raw = &mt6577_auxadc_read_raw,\n};\n\nstatic int mt6577_auxadc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\n\tint ret;\n\n\tret = clk_prepare_enable(adc_dev->adc_clk);\n\tif (ret) {\n\t\tpr_err(\"failed to enable auxadc clock\\n\");\n\t\treturn ret;\n\t}\n\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\n\t\t\t      MT6577_AUXADC_PDN_EN, 0);\n\tmdelay(MT6577_AUXADC_POWER_READY_MS);\n\n\treturn 0;\n}\n\nstatic int mt6577_auxadc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\n\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\n\t\t\t      0, MT6577_AUXADC_PDN_EN);\n\tclk_disable_unprepare(adc_dev->adc_clk);\n\n\treturn 0;\n}\n\nstatic int mt6577_auxadc_probe(struct platform_device *pdev)\n{\n\tstruct mt6577_auxadc_device *adc_dev;\n\tunsigned long adc_clk_rate;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc_dev));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc_dev = iio_priv(indio_dev);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &mt6577_auxadc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mt6577_auxadc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mt6577_auxadc_iio_channels);\n\n\tadc_dev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc_dev->reg_base)) {\n\t\tdev_err(&pdev->dev, \"failed to get auxadc base address\\n\");\n\t\treturn PTR_ERR(adc_dev->reg_base);\n\t}\n\n\tadc_dev->adc_clk = devm_clk_get(&pdev->dev, \"main\");\n\tif (IS_ERR(adc_dev->adc_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get auxadc clock\\n\");\n\t\treturn PTR_ERR(adc_dev->adc_clk);\n\t}\n\n\tret = clk_prepare_enable(adc_dev->adc_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable auxadc clock\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_clk_rate = clk_get_rate(adc_dev->adc_clk);\n\tif (!adc_clk_rate) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"null clock rate\\n\");\n\t\tgoto err_disable_clk;\n\t}\n\n\tadc_dev->dev_comp = device_get_match_data(&pdev->dev);\n\n\tmutex_init(&adc_dev->lock);\n\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\n\t\t\t      MT6577_AUXADC_PDN_EN, 0);\n\tmdelay(MT6577_AUXADC_POWER_READY_MS);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register iio device\\n\");\n\t\tgoto err_power_off;\n\t}\n\n\treturn 0;\n\nerr_power_off:\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\n\t\t\t      0, MT6577_AUXADC_PDN_EN);\nerr_disable_clk:\n\tclk_disable_unprepare(adc_dev->adc_clk);\n\treturn ret;\n}\n\nstatic int mt6577_auxadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\n\t\t\t      0, MT6577_AUXADC_PDN_EN);\n\n\tclk_disable_unprepare(adc_dev->adc_clk);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mt6577_auxadc_pm_ops,\n\t\t\t\tmt6577_auxadc_suspend,\n\t\t\t\tmt6577_auxadc_resume);\n\nstatic const struct of_device_id mt6577_auxadc_of_match[] = {\n\t{ .compatible = \"mediatek,mt2701-auxadc\", .data = &mt8173_compat },\n\t{ .compatible = \"mediatek,mt2712-auxadc\", .data = &mt8173_compat },\n\t{ .compatible = \"mediatek,mt7622-auxadc\", .data = &mt8173_compat },\n\t{ .compatible = \"mediatek,mt8173-auxadc\", .data = &mt8173_compat },\n\t{ .compatible = \"mediatek,mt8186-auxadc\", .data = &mt8186_compat },\n\t{ .compatible = \"mediatek,mt6765-auxadc\", .data = &mt6765_compat },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mt6577_auxadc_of_match);\n\nstatic struct platform_driver mt6577_auxadc_driver = {\n\t.driver = {\n\t\t.name   = \"mt6577-auxadc\",\n\t\t.of_match_table = mt6577_auxadc_of_match,\n\t\t.pm = pm_sleep_ptr(&mt6577_auxadc_pm_ops),\n\t},\n\t.probe\t= mt6577_auxadc_probe,\n\t.remove\t= mt6577_auxadc_remove,\n};\nmodule_platform_driver(mt6577_auxadc_driver);\n\nMODULE_AUTHOR(\"Zhiyong Tao <zhiyong.tao@mediatek.com>\");\nMODULE_DESCRIPTION(\"MTK AUXADC Device Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}