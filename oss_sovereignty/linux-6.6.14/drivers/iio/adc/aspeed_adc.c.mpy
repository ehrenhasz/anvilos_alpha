{
  "module_name": "aspeed_adc.c",
  "hash_id": "ba689065348a253299437bdb70a033b41218f9a082496bbdcf7455b4c0c79ff1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/aspeed_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iopoll.h>\n\n#define ASPEED_RESOLUTION_BITS\t\t10\n#define ASPEED_CLOCKS_PER_SAMPLE\t12\n\n#define ASPEED_REG_ENGINE_CONTROL\t0x00\n#define ASPEED_REG_INTERRUPT_CONTROL\t0x04\n#define ASPEED_REG_VGA_DETECT_CONTROL\t0x08\n#define ASPEED_REG_CLOCK_CONTROL\t0x0C\n#define ASPEED_REG_COMPENSATION_TRIM\t0xC4\n \n#define ASPEED_REG_MAX\t\t\t0xD0\n\n#define ASPEED_ADC_ENGINE_ENABLE\t\tBIT(0)\n#define ASPEED_ADC_OP_MODE\t\t\tGENMASK(3, 1)\n#define ASPEED_ADC_OP_MODE_PWR_DOWN\t\t0\n#define ASPEED_ADC_OP_MODE_STANDBY\t\t1\n#define ASPEED_ADC_OP_MODE_NORMAL\t\t7\n#define ASPEED_ADC_CTRL_COMPENSATION\t\tBIT(4)\n#define ASPEED_ADC_AUTO_COMPENSATION\t\tBIT(5)\n \n#define ASPEED_ADC_REF_VOLTAGE\t\t\tGENMASK(7, 6)\n#define ASPEED_ADC_REF_VOLTAGE_2500mV\t\t0\n#define ASPEED_ADC_REF_VOLTAGE_1200mV\t\t1\n#define ASPEED_ADC_REF_VOLTAGE_EXT_HIGH\t\t2\n#define ASPEED_ADC_REF_VOLTAGE_EXT_LOW\t\t3\n#define ASPEED_ADC_BAT_SENSING_DIV\t\tBIT(6)\n#define ASPEED_ADC_BAT_SENSING_DIV_2_3\t\t0\n#define ASPEED_ADC_BAT_SENSING_DIV_1_3\t\t1\n#define ASPEED_ADC_CTRL_INIT_RDY\t\tBIT(8)\n#define ASPEED_ADC_CH7_MODE\t\t\tBIT(12)\n#define ASPEED_ADC_CH7_NORMAL\t\t\t0\n#define ASPEED_ADC_CH7_BAT\t\t\t1\n#define ASPEED_ADC_BAT_SENSING_ENABLE\t\tBIT(13)\n#define ASPEED_ADC_CTRL_CHANNEL\t\t\tGENMASK(31, 16)\n#define ASPEED_ADC_CTRL_CHANNEL_ENABLE(ch)\tFIELD_PREP(ASPEED_ADC_CTRL_CHANNEL, BIT(ch))\n\n#define ASPEED_ADC_INIT_POLLING_TIME\t500\n#define ASPEED_ADC_INIT_TIMEOUT\t\t500000\n \n#define ASPEED_ADC_DEF_SAMPLING_RATE\t65000\n\nstruct aspeed_adc_trim_locate {\n\tconst unsigned int offset;\n\tconst unsigned int field;\n};\n\nstruct aspeed_adc_model_data {\n\tconst char *model_name;\n\tunsigned int min_sampling_rate;\t\n\tunsigned int max_sampling_rate;\t\n\tunsigned int vref_fixed_mv;\n\tbool wait_init_sequence;\n\tbool need_prescaler;\n\tbool bat_sense_sup;\n\tu8 scaler_bit_width;\n\tunsigned int num_channels;\n\tconst struct aspeed_adc_trim_locate *trim_locate;\n};\n\nstruct adc_gain {\n\tu8 mult;\n\tu8 div;\n};\n\nstruct aspeed_adc_data {\n\tstruct device\t\t*dev;\n\tconst struct aspeed_adc_model_data *model_data;\n\tstruct regulator\t*regulator;\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tclk_lock;\n\tstruct clk_hw\t\t*fixed_div_clk;\n\tstruct clk_hw\t\t*clk_prescaler;\n\tstruct clk_hw\t\t*clk_scaler;\n\tstruct reset_control\t*rst;\n\tint\t\t\tvref_mv;\n\tu32\t\t\tsample_period_ns;\n\tint\t\t\tcv;\n\tbool\t\t\tbattery_sensing;\n\tstruct adc_gain\t\tbattery_mode_gain;\n};\n\n#define ASPEED_CHAN(_idx, _data_reg_addr) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (_idx),\t\t\t\t\t\\\n\t.address = (_data_reg_addr),\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\\\n}\n\nstatic const struct iio_chan_spec aspeed_adc_iio_channels[] = {\n\tASPEED_CHAN(0, 0x10),\n\tASPEED_CHAN(1, 0x12),\n\tASPEED_CHAN(2, 0x14),\n\tASPEED_CHAN(3, 0x16),\n\tASPEED_CHAN(4, 0x18),\n\tASPEED_CHAN(5, 0x1A),\n\tASPEED_CHAN(6, 0x1C),\n\tASPEED_CHAN(7, 0x1E),\n\tASPEED_CHAN(8, 0x20),\n\tASPEED_CHAN(9, 0x22),\n\tASPEED_CHAN(10, 0x24),\n\tASPEED_CHAN(11, 0x26),\n\tASPEED_CHAN(12, 0x28),\n\tASPEED_CHAN(13, 0x2A),\n\tASPEED_CHAN(14, 0x2C),\n\tASPEED_CHAN(15, 0x2E),\n};\n\n#define ASPEED_BAT_CHAN(_idx, _data_reg_addr) {\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t\t.channel = (_idx),\t\t\t\t\t\t\\\n\t\t.address = (_data_reg_addr),\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n}\nstatic const struct iio_chan_spec aspeed_adc_iio_bat_channels[] = {\n\tASPEED_CHAN(0, 0x10),\n\tASPEED_CHAN(1, 0x12),\n\tASPEED_CHAN(2, 0x14),\n\tASPEED_CHAN(3, 0x16),\n\tASPEED_CHAN(4, 0x18),\n\tASPEED_CHAN(5, 0x1A),\n\tASPEED_CHAN(6, 0x1C),\n\tASPEED_BAT_CHAN(7, 0x1E),\n};\n\nstatic int aspeed_adc_set_trim_data(struct iio_dev *indio_dev)\n{\n\tstruct device_node *syscon;\n\tstruct regmap *scu;\n\tu32 scu_otp, trimming_val;\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\n\tsyscon = of_find_node_by_name(NULL, \"syscon\");\n\tif (syscon == NULL) {\n\t\tdev_warn(data->dev, \"Couldn't find syscon node\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tscu = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(scu)) {\n\t\tdev_warn(data->dev, \"Failed to get syscon regmap\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (data->model_data->trim_locate) {\n\t\tif (regmap_read(scu, data->model_data->trim_locate->offset,\n\t\t\t\t&scu_otp)) {\n\t\t\tdev_warn(data->dev,\n\t\t\t\t \"Failed to get adc trimming data\\n\");\n\t\t\ttrimming_val = 0x8;\n\t\t} else {\n\t\t\ttrimming_val =\n\t\t\t\t((scu_otp) &\n\t\t\t\t (data->model_data->trim_locate->field)) >>\n\t\t\t\t__ffs(data->model_data->trim_locate->field);\n\t\t\tif (!trimming_val)\n\t\t\t\ttrimming_val = 0x8;\n\t\t}\n\t\tdev_dbg(data->dev,\n\t\t\t\"trimming val = %d, offset = %08x, fields = %08x\\n\",\n\t\t\ttrimming_val, data->model_data->trim_locate->offset,\n\t\t\tdata->model_data->trim_locate->field);\n\t\twritel(trimming_val, data->base + ASPEED_REG_COMPENSATION_TRIM);\n\t}\n\treturn 0;\n}\n\nstatic int aspeed_adc_compensation(struct iio_dev *indio_dev)\n{\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\tu32 index, adc_raw = 0;\n\tu32 adc_engine_control_reg_val;\n\n\tadc_engine_control_reg_val =\n\t\treadl(data->base + ASPEED_REG_ENGINE_CONTROL);\n\tadc_engine_control_reg_val &= ~ASPEED_ADC_OP_MODE;\n\tadc_engine_control_reg_val |=\n\t\t(FIELD_PREP(ASPEED_ADC_OP_MODE, ASPEED_ADC_OP_MODE_NORMAL) |\n\t\t ASPEED_ADC_ENGINE_ENABLE);\n\t \n\twritel(adc_engine_control_reg_val | ASPEED_ADC_CTRL_COMPENSATION |\n\t\t       ASPEED_ADC_CTRL_CHANNEL_ENABLE(0),\n\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\t \n\tmdelay(1);\n\n\tfor (index = 0; index < 16; index++) {\n\t\t \n\t\tndelay(data->sample_period_ns);\n\t\tadc_raw += readw(data->base + aspeed_adc_iio_channels[0].address);\n\t}\n\tadc_raw >>= 4;\n\tdata->cv = BIT(ASPEED_RESOLUTION_BITS - 1) - adc_raw;\n\twritel(adc_engine_control_reg_val,\n\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\tdev_dbg(data->dev, \"Compensating value = %d\\n\", data->cv);\n\n\treturn 0;\n}\n\nstatic int aspeed_adc_set_sampling_rate(struct iio_dev *indio_dev, u32 rate)\n{\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\n\tif (rate < data->model_data->min_sampling_rate ||\n\t    rate > data->model_data->max_sampling_rate)\n\t\treturn -EINVAL;\n\t \n\tclk_set_rate(data->clk_scaler->clk, rate * ASPEED_CLOCKS_PER_SAMPLE);\n\trate = clk_get_rate(data->clk_scaler->clk);\n\tdata->sample_period_ns = DIV_ROUND_UP_ULL(\n\t\t(u64)NSEC_PER_SEC * ASPEED_CLOCKS_PER_SAMPLE, rate);\n\tdev_dbg(data->dev, \"Adc clock = %d sample period = %d ns\", rate,\n\t\tdata->sample_period_ns);\n\n\treturn 0;\n}\n\nstatic int aspeed_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\tu32 adc_engine_control_reg_val;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (data->battery_sensing && chan->channel == 7) {\n\t\t\tadc_engine_control_reg_val =\n\t\t\t\treadl(data->base + ASPEED_REG_ENGINE_CONTROL);\n\t\t\twritel(adc_engine_control_reg_val |\n\t\t\t\t       FIELD_PREP(ASPEED_ADC_CH7_MODE,\n\t\t\t\t\t\t  ASPEED_ADC_CH7_BAT) |\n\t\t\t\t       ASPEED_ADC_BAT_SENSING_ENABLE,\n\t\t\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\t\t\t \n\t\t\tmdelay(1);\n\t\t\t*val = readw(data->base + chan->address);\n\t\t\t*val = (*val * data->battery_mode_gain.mult) /\n\t\t\t       data->battery_mode_gain.div;\n\t\t\t \n\t\t\twritel(adc_engine_control_reg_val,\n\t\t\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\t\t} else\n\t\t\t*val = readw(data->base + chan->address);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (data->battery_sensing && chan->channel == 7)\n\t\t\t*val = (data->cv * data->battery_mode_gain.mult) /\n\t\t\t       data->battery_mode_gain.div;\n\t\telse\n\t\t\t*val = data->cv;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = data->vref_mv;\n\t\t*val2 = ASPEED_RESOLUTION_BITS;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = clk_get_rate(data->clk_scaler->clk) /\n\t\t\t\tASPEED_CLOCKS_PER_SAMPLE;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aspeed_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn aspeed_adc_set_sampling_rate(indio_dev, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\treturn -EPERM;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aspeed_adc_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t unsigned int reg, unsigned int writeval,\n\t\t\t\t unsigned int *readval)\n{\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\n\tif (!readval || reg % 4 || reg > ASPEED_REG_MAX)\n\t\treturn -EINVAL;\n\n\t*readval = readl(data->base + reg);\n\n\treturn 0;\n}\n\nstatic const struct iio_info aspeed_adc_iio_info = {\n\t.read_raw = aspeed_adc_read_raw,\n\t.write_raw = aspeed_adc_write_raw,\n\t.debugfs_reg_access = aspeed_adc_reg_access,\n};\n\nstatic void aspeed_adc_unregister_fixed_divider(void *data)\n{\n\tstruct clk_hw *clk = data;\n\n\tclk_hw_unregister_fixed_factor(clk);\n}\n\nstatic void aspeed_adc_reset_assert(void *data)\n{\n\tstruct reset_control *rst = data;\n\n\treset_control_assert(rst);\n}\n\nstatic void aspeed_adc_clk_disable_unprepare(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic void aspeed_adc_power_down(void *data)\n{\n\tstruct aspeed_adc_data *priv_data = data;\n\n\twritel(FIELD_PREP(ASPEED_ADC_OP_MODE, ASPEED_ADC_OP_MODE_PWR_DOWN),\n\t       priv_data->base + ASPEED_REG_ENGINE_CONTROL);\n}\n\nstatic void aspeed_adc_reg_disable(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic int aspeed_adc_vref_config(struct iio_dev *indio_dev)\n{\n\tstruct aspeed_adc_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu32 adc_engine_control_reg_val;\n\n\tif (data->model_data->vref_fixed_mv) {\n\t\tdata->vref_mv = data->model_data->vref_fixed_mv;\n\t\treturn 0;\n\t}\n\tadc_engine_control_reg_val =\n\t\treadl(data->base + ASPEED_REG_ENGINE_CONTROL);\n\tdata->regulator = devm_regulator_get_optional(data->dev, \"vref\");\n\tif (!IS_ERR(data->regulator)) {\n\t\tret = regulator_enable(data->regulator);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(\n\t\t\tdata->dev, aspeed_adc_reg_disable, data->regulator);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->vref_mv = regulator_get_voltage(data->regulator);\n\t\t \n\t\tdata->vref_mv /= 1000;\n\t\tif ((data->vref_mv >= 1550) && (data->vref_mv <= 2700))\n\t\t\twritel(adc_engine_control_reg_val |\n\t\t\t\tFIELD_PREP(\n\t\t\t\t\tASPEED_ADC_REF_VOLTAGE,\n\t\t\t\t\tASPEED_ADC_REF_VOLTAGE_EXT_HIGH),\n\t\t\tdata->base + ASPEED_REG_ENGINE_CONTROL);\n\t\telse if ((data->vref_mv >= 900) && (data->vref_mv <= 1650))\n\t\t\twritel(adc_engine_control_reg_val |\n\t\t\t\tFIELD_PREP(\n\t\t\t\t\tASPEED_ADC_REF_VOLTAGE,\n\t\t\t\t\tASPEED_ADC_REF_VOLTAGE_EXT_LOW),\n\t\t\tdata->base + ASPEED_REG_ENGINE_CONTROL);\n\t\telse {\n\t\t\tdev_err(data->dev, \"Regulator voltage %d not support\",\n\t\t\t\tdata->vref_mv);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tif (PTR_ERR(data->regulator) != -ENODEV)\n\t\t\treturn PTR_ERR(data->regulator);\n\t\tdata->vref_mv = 2500000;\n\t\tof_property_read_u32(data->dev->of_node,\n\t\t\t\t     \"aspeed,int-vref-microvolt\",\n\t\t\t\t     &data->vref_mv);\n\t\t \n\t\tdata->vref_mv /= 1000;\n\t\tif (data->vref_mv == 2500)\n\t\t\twritel(adc_engine_control_reg_val |\n\t\t\t\tFIELD_PREP(ASPEED_ADC_REF_VOLTAGE,\n\t\t\t\t\t\tASPEED_ADC_REF_VOLTAGE_2500mV),\n\t\t\tdata->base + ASPEED_REG_ENGINE_CONTROL);\n\t\telse if (data->vref_mv == 1200)\n\t\t\twritel(adc_engine_control_reg_val |\n\t\t\t\tFIELD_PREP(ASPEED_ADC_REF_VOLTAGE,\n\t\t\t\t\t\tASPEED_ADC_REF_VOLTAGE_1200mV),\n\t\t\tdata->base + ASPEED_REG_ENGINE_CONTROL);\n\t\telse {\n\t\t\tdev_err(data->dev, \"Voltage %d not support\", data->vref_mv);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aspeed_adc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct aspeed_adc_data *data;\n\tint ret;\n\tu32 adc_engine_control_reg_val;\n\tunsigned long scaler_flags = 0;\n\tchar clk_name[32], clk_parent_name[32];\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = &pdev->dev;\n\tdata->model_data = of_device_get_match_data(&pdev->dev);\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\t \n\tspin_lock_init(&data->clk_lock);\n\tsnprintf(clk_parent_name, ARRAY_SIZE(clk_parent_name), \"%s\",\n\t\t of_clk_get_parent_name(pdev->dev.of_node, 0));\n\tsnprintf(clk_name, ARRAY_SIZE(clk_name), \"%s-fixed-div\",\n\t\t data->model_data->model_name);\n\tdata->fixed_div_clk = clk_hw_register_fixed_factor(\n\t\t&pdev->dev, clk_name, clk_parent_name, 0, 1, 2);\n\tif (IS_ERR(data->fixed_div_clk))\n\t\treturn PTR_ERR(data->fixed_div_clk);\n\n\tret = devm_add_action_or_reset(data->dev,\n\t\t\t\t       aspeed_adc_unregister_fixed_divider,\n\t\t\t\t       data->fixed_div_clk);\n\tif (ret)\n\t\treturn ret;\n\tsnprintf(clk_parent_name, ARRAY_SIZE(clk_parent_name), clk_name);\n\n\tif (data->model_data->need_prescaler) {\n\t\tsnprintf(clk_name, ARRAY_SIZE(clk_name), \"%s-prescaler\",\n\t\t\t data->model_data->model_name);\n\t\tdata->clk_prescaler = devm_clk_hw_register_divider(\n\t\t\t&pdev->dev, clk_name, clk_parent_name, 0,\n\t\t\tdata->base + ASPEED_REG_CLOCK_CONTROL, 17, 15, 0,\n\t\t\t&data->clk_lock);\n\t\tif (IS_ERR(data->clk_prescaler))\n\t\t\treturn PTR_ERR(data->clk_prescaler);\n\t\tsnprintf(clk_parent_name, ARRAY_SIZE(clk_parent_name),\n\t\t\t clk_name);\n\t\tscaler_flags = CLK_SET_RATE_PARENT;\n\t}\n\t \n\tsnprintf(clk_name, ARRAY_SIZE(clk_name), \"%s-scaler\",\n\t\t data->model_data->model_name);\n\tdata->clk_scaler = devm_clk_hw_register_divider(\n\t\t&pdev->dev, clk_name, clk_parent_name, scaler_flags,\n\t\tdata->base + ASPEED_REG_CLOCK_CONTROL, 0,\n\t\tdata->model_data->scaler_bit_width,\n\t\tdata->model_data->need_prescaler ? CLK_DIVIDER_ONE_BASED : 0,\n\t\t&data->clk_lock);\n\tif (IS_ERR(data->clk_scaler))\n\t\treturn PTR_ERR(data->clk_scaler);\n\n\tdata->rst = devm_reset_control_get_shared(&pdev->dev, NULL);\n\tif (IS_ERR(data->rst)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid or missing reset controller device tree entry\");\n\t\treturn PTR_ERR(data->rst);\n\t}\n\treset_control_deassert(data->rst);\n\n\tret = devm_add_action_or_reset(data->dev, aspeed_adc_reset_assert,\n\t\t\t\t       data->rst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aspeed_adc_vref_config(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aspeed_adc_set_trim_data(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_find_property(data->dev->of_node, \"aspeed,battery-sensing\",\n\t\t\t     NULL)) {\n\t\tif (data->model_data->bat_sense_sup) {\n\t\t\tdata->battery_sensing = 1;\n\t\t\tif (readl(data->base + ASPEED_REG_ENGINE_CONTROL) &\n\t\t\t    ASPEED_ADC_BAT_SENSING_DIV) {\n\t\t\t\tdata->battery_mode_gain.mult = 3;\n\t\t\t\tdata->battery_mode_gain.div = 1;\n\t\t\t} else {\n\t\t\t\tdata->battery_mode_gain.mult = 3;\n\t\t\t\tdata->battery_mode_gain.div = 2;\n\t\t\t}\n\t\t} else\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Failed to enable battery-sensing mode\\n\");\n\t}\n\n\tret = clk_prepare_enable(data->clk_scaler->clk);\n\tif (ret)\n\t\treturn ret;\n\tret = devm_add_action_or_reset(data->dev,\n\t\t\t\t       aspeed_adc_clk_disable_unprepare,\n\t\t\t\t       data->clk_scaler->clk);\n\tif (ret)\n\t\treturn ret;\n\tret = aspeed_adc_set_sampling_rate(indio_dev,\n\t\t\t\t\t   ASPEED_ADC_DEF_SAMPLING_RATE);\n\tif (ret)\n\t\treturn ret;\n\n\tadc_engine_control_reg_val =\n\t\treadl(data->base + ASPEED_REG_ENGINE_CONTROL);\n\tadc_engine_control_reg_val |=\n\t\tFIELD_PREP(ASPEED_ADC_OP_MODE, ASPEED_ADC_OP_MODE_NORMAL) |\n\t\tASPEED_ADC_ENGINE_ENABLE;\n\t \n\twritel(adc_engine_control_reg_val,\n\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\n\tret = devm_add_action_or_reset(data->dev, aspeed_adc_power_down,\n\t\t\t\t\tdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->model_data->wait_init_sequence) {\n\t\t \n\t\tret = readl_poll_timeout(data->base + ASPEED_REG_ENGINE_CONTROL,\n\t\t\t\t\t adc_engine_control_reg_val,\n\t\t\t\t\t adc_engine_control_reg_val &\n\t\t\t\t\t ASPEED_ADC_CTRL_INIT_RDY,\n\t\t\t\t\t ASPEED_ADC_INIT_POLLING_TIME,\n\t\t\t\t\t ASPEED_ADC_INIT_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\taspeed_adc_compensation(indio_dev);\n\t \n\tadc_engine_control_reg_val =\n\t\treadl(data->base + ASPEED_REG_ENGINE_CONTROL);\n\tadc_engine_control_reg_val |= ASPEED_ADC_CTRL_CHANNEL;\n\twritel(adc_engine_control_reg_val,\n\t       data->base + ASPEED_REG_ENGINE_CONTROL);\n\n\tindio_dev->name = data->model_data->model_name;\n\tindio_dev->info = &aspeed_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = data->battery_sensing ?\n\t\t\t\t\t    aspeed_adc_iio_bat_channels :\n\t\t\t\t\t    aspeed_adc_iio_channels;\n\tindio_dev->num_channels = data->model_data->num_channels;\n\n\tret = devm_iio_device_register(data->dev, indio_dev);\n\treturn ret;\n}\n\nstatic const struct aspeed_adc_trim_locate ast2500_adc_trim = {\n\t.offset = 0x154,\n\t.field = GENMASK(31, 28),\n};\n\nstatic const struct aspeed_adc_trim_locate ast2600_adc0_trim = {\n\t.offset = 0x5d0,\n\t.field = GENMASK(3, 0),\n};\n\nstatic const struct aspeed_adc_trim_locate ast2600_adc1_trim = {\n\t.offset = 0x5d0,\n\t.field = GENMASK(7, 4),\n};\n\nstatic const struct aspeed_adc_model_data ast2400_model_data = {\n\t.model_name = \"ast2400-adc\",\n\t.vref_fixed_mv = 2500,\n\t.min_sampling_rate = 10000,\n\t.max_sampling_rate = 500000,\n\t.need_prescaler = true,\n\t.scaler_bit_width = 10,\n\t.num_channels = 16,\n};\n\nstatic const struct aspeed_adc_model_data ast2500_model_data = {\n\t.model_name = \"ast2500-adc\",\n\t.vref_fixed_mv = 1800,\n\t.min_sampling_rate = 1,\n\t.max_sampling_rate = 1000000,\n\t.wait_init_sequence = true,\n\t.need_prescaler = true,\n\t.scaler_bit_width = 10,\n\t.num_channels = 16,\n\t.trim_locate = &ast2500_adc_trim,\n};\n\nstatic const struct aspeed_adc_model_data ast2600_adc0_model_data = {\n\t.model_name = \"ast2600-adc0\",\n\t.min_sampling_rate = 10000,\n\t.max_sampling_rate = 500000,\n\t.wait_init_sequence = true,\n\t.bat_sense_sup = true,\n\t.scaler_bit_width = 16,\n\t.num_channels = 8,\n\t.trim_locate = &ast2600_adc0_trim,\n};\n\nstatic const struct aspeed_adc_model_data ast2600_adc1_model_data = {\n\t.model_name = \"ast2600-adc1\",\n\t.min_sampling_rate = 10000,\n\t.max_sampling_rate = 500000,\n\t.wait_init_sequence = true,\n\t.bat_sense_sup = true,\n\t.scaler_bit_width = 16,\n\t.num_channels = 8,\n\t.trim_locate = &ast2600_adc1_trim,\n};\n\nstatic const struct of_device_id aspeed_adc_matches[] = {\n\t{ .compatible = \"aspeed,ast2400-adc\", .data = &ast2400_model_data },\n\t{ .compatible = \"aspeed,ast2500-adc\", .data = &ast2500_model_data },\n\t{ .compatible = \"aspeed,ast2600-adc0\", .data = &ast2600_adc0_model_data },\n\t{ .compatible = \"aspeed,ast2600-adc1\", .data = &ast2600_adc1_model_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, aspeed_adc_matches);\n\nstatic struct platform_driver aspeed_adc_driver = {\n\t.probe = aspeed_adc_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = aspeed_adc_matches,\n\t}\n};\n\nmodule_platform_driver(aspeed_adc_driver);\n\nMODULE_AUTHOR(\"Rick Altherr <raltherr@google.com>\");\nMODULE_DESCRIPTION(\"Aspeed AST2400/2500/2600 ADC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}