{
  "module_name": "ad7291.c",
  "hash_id": "2e79e9a8cf6f6144a65f3c890db12318669d3765444e5eac5ccf74dbb1d12504",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7291.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n \n\n \n#define AD7291_COMMAND\t\t\t0x00\n#define AD7291_VOLTAGE\t\t\t0x01\n#define AD7291_T_SENSE\t\t\t0x02\n#define AD7291_T_AVERAGE\t\t0x03\n#define AD7291_DATA_HIGH(x)\t\t((x) * 3 + 0x4)\n#define AD7291_DATA_LOW(x)\t\t((x) * 3 + 0x5)\n#define AD7291_HYST(x)\t\t\t((x) * 3 + 0x6)\n#define AD7291_VOLTAGE_ALERT_STATUS\t0x1F\n#define AD7291_T_ALERT_STATUS\t\t0x20\n\n#define AD7291_BITS\t\t\t12\n#define AD7291_VOLTAGE_LIMIT_COUNT\t8\n\n\n \n#define AD7291_AUTOCYCLE\t\tBIT(0)\n#define AD7291_RESET\t\t\tBIT(1)\n#define AD7291_ALERT_CLEAR\t\tBIT(2)\n#define AD7291_ALERT_POLARITY\t\tBIT(3)\n#define AD7291_EXT_REF\t\t\tBIT(4)\n#define AD7291_NOISE_DELAY\t\tBIT(5)\n#define AD7291_T_SENSE_MASK\t\tBIT(7)\n#define AD7291_VOLTAGE_MASK\t\tGENMASK(15, 8)\n#define AD7291_VOLTAGE_OFFSET\t\t8\n\n \n#define AD7291_VALUE_MASK\t\tGENMASK(11, 0)\n\n \n#define AD7291_T_LOW\t\t\tBIT(0)\n#define AD7291_T_HIGH\t\t\tBIT(1)\n#define AD7291_T_AVG_LOW\t\tBIT(2)\n#define AD7291_T_AVG_HIGH\t\tBIT(3)\n#define AD7291_V_LOW(x)\t\t\tBIT((x) * 2)\n#define AD7291_V_HIGH(x)\t\tBIT((x) * 2 + 1)\n\n\nstruct ad7291_chip_info {\n\tstruct i2c_client\t*client;\n\tstruct regulator\t*reg;\n\tu16\t\t\tcommand;\n\tu16\t\t\tc_mask;\t \n\tstruct mutex\t\tstate_lock;\n};\n\nstatic int ad7291_i2c_read(struct ad7291_chip_info *chip, u8 reg, u16 *data)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret = 0;\n\n\tret = i2c_smbus_read_word_swapped(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"I2C read error\\n\");\n\t\treturn ret;\n\t}\n\n\t*data = ret;\n\n\treturn 0;\n}\n\nstatic int ad7291_i2c_write(struct ad7291_chip_info *chip, u8 reg, u16 data)\n{\n\treturn i2c_smbus_write_word_swapped(chip->client, reg, data);\n}\n\nstatic irqreturn_t ad7291_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ad7291_chip_info *chip = iio_priv(private);\n\tu16 t_status, v_status;\n\tu16 command;\n\tint i;\n\ts64 timestamp = iio_get_time_ns(indio_dev);\n\n\tif (ad7291_i2c_read(chip, AD7291_T_ALERT_STATUS, &t_status))\n\t\treturn IRQ_HANDLED;\n\n\tif (ad7291_i2c_read(chip, AD7291_VOLTAGE_ALERT_STATUS, &v_status))\n\t\treturn IRQ_HANDLED;\n\n\tif (!(t_status || v_status))\n\t\treturn IRQ_HANDLED;\n\n\tcommand = chip->command | AD7291_ALERT_CLEAR;\n\tad7291_i2c_write(chip, AD7291_COMMAND, command);\n\n\tcommand = chip->command & ~AD7291_ALERT_CLEAR;\n\tad7291_i2c_write(chip, AD7291_COMMAND, command);\n\n\t \n\tif ((t_status & AD7291_T_LOW) || (t_status & AD7291_T_AVG_LOW))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_TEMP,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t       timestamp);\n\tif ((t_status & AD7291_T_HIGH) || (t_status & AD7291_T_AVG_HIGH))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_TEMP,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       timestamp);\n\n\tfor (i = 0; i < AD7291_VOLTAGE_LIMIT_COUNT; i++) {\n\t\tif (v_status & AD7291_V_LOW(i))\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\n\t\t\t\t\t\t\t    i,\n\t\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\t    IIO_EV_DIR_FALLING),\n\t\t\t\t       timestamp);\n\t\tif (v_status & AD7291_V_HIGH(i))\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\n\t\t\t\t\t\t\t    i,\n\t\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t\t       timestamp);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int ad7291_threshold_reg(const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t\t enum iio_event_info info)\n{\n\tunsigned int offset;\n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\toffset = chan->channel;\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\toffset = AD7291_VOLTAGE_OFFSET;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (dir == IIO_EV_DIR_FALLING)\n\t\t\treturn AD7291_DATA_HIGH(offset);\n\t\telse\n\t\t\treturn AD7291_DATA_LOW(offset);\n\tcase IIO_EV_INFO_HYSTERESIS:\n\t\treturn AD7291_HYST(offset);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ad7291_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t   enum iio_event_info info,\n\t\t\t\t   int *val, int *val2)\n{\n\tstruct ad7291_chip_info *chip = iio_priv(indio_dev);\n\tint ret;\n\tu16 uval;\n\n\tret = ad7291_i2c_read(chip, ad7291_threshold_reg(chan, dir, info),\n\t\t\t      &uval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (info == IIO_EV_INFO_HYSTERESIS || chan->type == IIO_VOLTAGE)\n\t\t*val = uval & AD7291_VALUE_MASK;\n\n\telse\n\t\t*val = sign_extend32(uval, 11);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad7291_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int val, int val2)\n{\n\tstruct ad7291_chip_info *chip = iio_priv(indio_dev);\n\n\tif (info == IIO_EV_INFO_HYSTERESIS || chan->type == IIO_VOLTAGE) {\n\t\tif (val > AD7291_VALUE_MASK || val < 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (val > 2047 || val < -2048)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn ad7291_i2c_write(chip, ad7291_threshold_reg(chan, dir, info),\n\t\t\t\tval);\n}\n\nstatic int ad7291_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct ad7291_chip_info *chip = iio_priv(indio_dev);\n\t \n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\treturn !!(chip->c_mask & BIT(15 - chan->channel));\n\tcase IIO_TEMP:\n\t\t \n\t\treturn 1;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n}\n\nstatic int ad7291_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     int state)\n{\n\tint ret = 0;\n\tstruct ad7291_chip_info *chip = iio_priv(indio_dev);\n\tunsigned int mask;\n\tu16 regval;\n\n\tmutex_lock(&chip->state_lock);\n\tregval = chip->command;\n\t \n\n\tmask = BIT(15 - chan->channel);\n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\tif ((!state) && (chip->c_mask & mask))\n\t\t\tchip->c_mask &= ~mask;\n\t\telse if (state && (!(chip->c_mask & mask)))\n\t\t\tchip->c_mask |= mask;\n\t\telse\n\t\t\tbreak;\n\n\t\tregval &= ~AD7291_AUTOCYCLE;\n\t\tregval |= chip->c_mask;\n\t\tif (chip->c_mask)  \n\t\t\tregval |= AD7291_AUTOCYCLE;\n\n\t\tret = ad7291_i2c_write(chip, AD7291_COMMAND, regval);\n\t\tif (ret < 0)\n\t\t\tgoto error_ret;\n\n\t\tchip->command = regval;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nerror_ret:\n\tmutex_unlock(&chip->state_lock);\n\treturn ret;\n}\n\nstatic int ad7291_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long mask)\n{\n\tint ret;\n\tstruct ad7291_chip_info *chip = iio_priv(indio_dev);\n\tu16 regval;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tmutex_lock(&chip->state_lock);\n\t\t\t \n\t\t\tif (chip->command & AD7291_AUTOCYCLE) {\n\t\t\t\tmutex_unlock(&chip->state_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t \n\t\t\tregval = chip->command & (~AD7291_VOLTAGE_MASK);\n\t\t\tregval |= BIT(15 - chan->channel);\n\t\t\tret = ad7291_i2c_write(chip, AD7291_COMMAND, regval);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&chip->state_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t \n\t\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t\t  AD7291_VOLTAGE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&chip->state_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*val = ret & AD7291_VALUE_MASK;\n\t\t\tmutex_unlock(&chip->state_lock);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t\t  AD7291_T_SENSE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret, 11);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_AVERAGE_RAW:\n\t\tret = i2c_smbus_read_word_swapped(chip->client,\n\t\t\t\t\t\t  AD7291_T_AVERAGE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret, 11);\n\t\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chip->reg) {\n\t\t\t\tint vref;\n\n\t\t\t\tvref = regulator_get_voltage(chip->reg);\n\t\t\t\tif (vref < 0)\n\t\t\t\t\treturn vref;\n\t\t\t\t*val = vref / 1000;\n\t\t\t} else {\n\t\t\t\t*val = 2500;\n\t\t\t}\n\t\t\t*val2 = AD7291_BITS;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 250;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_event_spec ad7291_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_HYSTERESIS),\n\t},\n};\n\n#define AD7291_VOLTAGE_CHAN(_chan)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n\t.event_spec = ad7291_events,\t\t\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(ad7291_events),\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad7291_channels[] = {\n\tAD7291_VOLTAGE_CHAN(0),\n\tAD7291_VOLTAGE_CHAN(1),\n\tAD7291_VOLTAGE_CHAN(2),\n\tAD7291_VOLTAGE_CHAN(3),\n\tAD7291_VOLTAGE_CHAN(4),\n\tAD7291_VOLTAGE_CHAN(5),\n\tAD7291_VOLTAGE_CHAN(6),\n\tAD7291_VOLTAGE_CHAN(7),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.event_spec = ad7291_events,\n\t\t.num_event_specs = ARRAY_SIZE(ad7291_events),\n\t}\n};\n\nstatic const struct iio_info ad7291_info = {\n\t.read_raw = &ad7291_read_raw,\n\t.read_event_config = &ad7291_read_event_config,\n\t.write_event_config = &ad7291_write_event_config,\n\t.read_event_value = &ad7291_read_event_value,\n\t.write_event_value = &ad7291_write_event_value,\n};\n\nstatic void ad7291_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7291_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ad7291_chip_info *chip;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tchip = iio_priv(indio_dev);\n\n\tmutex_init(&chip->state_lock);\n\n\tchip->client = client;\n\n\tchip->command = AD7291_NOISE_DELAY |\n\t\t\tAD7291_T_SENSE_MASK |  \n\t\t\tAD7291_ALERT_POLARITY;  \n\n\tchip->reg = devm_regulator_get_optional(&client->dev, \"vref\");\n\tif (IS_ERR(chip->reg)) {\n\t\tif (PTR_ERR(chip->reg) != -ENODEV)\n\t\t\treturn PTR_ERR(chip->reg);\n\n\t\tchip->reg = NULL;\n\t}\n\n\tif (chip->reg) {\n\t\tret = regulator_enable(chip->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&client->dev, ad7291_reg_disable,\n\t\t\t\t\t       chip->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->command |= AD7291_EXT_REF;\n\t}\n\n\tindio_dev->name = id->name;\n\tindio_dev->channels = ad7291_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad7291_channels);\n\n\tindio_dev->info = &ad7291_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ad7291_i2c_write(chip, AD7291_COMMAND, AD7291_RESET);\n\tif (ret)\n\t\treturn -EIO;\n\n\tret = ad7291_i2c_write(chip, AD7291_COMMAND, chip->command);\n\tif (ret)\n\t\treturn -EIO;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&ad7291_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\tid->name,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id ad7291_id[] = {\n\t{ \"ad7291\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, ad7291_id);\n\nstatic const struct of_device_id ad7291_of_match[] = {\n\t{ .compatible = \"adi,ad7291\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad7291_of_match);\n\nstatic struct i2c_driver ad7291_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ad7291_of_match,\n\t},\n\t.probe = ad7291_probe,\n\t.id_table = ad7291_id,\n};\nmodule_i2c_driver(ad7291_driver);\n\nMODULE_AUTHOR(\"Sonic Zhang <sonic.zhang@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7291 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}