{
  "module_name": "da9150-gpadc.c",
  "hash_id": "304615522203bcd42236df02fe4db5aa03a3817280a7f365eaa6c520de70a2f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/da9150-gpadc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n#include <linux/mfd/da9150/core.h>\n#include <linux/mfd/da9150/registers.h>\n\n \nenum da9150_gpadc_hw_channel {\n\tDA9150_GPADC_HW_CHAN_GPIOA_2V = 0,\n\tDA9150_GPADC_HW_CHAN_GPIOA_2V_,\n\tDA9150_GPADC_HW_CHAN_GPIOB_2V,\n\tDA9150_GPADC_HW_CHAN_GPIOB_2V_,\n\tDA9150_GPADC_HW_CHAN_GPIOC_2V,\n\tDA9150_GPADC_HW_CHAN_GPIOC_2V_,\n\tDA9150_GPADC_HW_CHAN_GPIOD_2V,\n\tDA9150_GPADC_HW_CHAN_GPIOD_2V_,\n\tDA9150_GPADC_HW_CHAN_IBUS_SENSE,\n\tDA9150_GPADC_HW_CHAN_IBUS_SENSE_,\n\tDA9150_GPADC_HW_CHAN_VBUS_DIV,\n\tDA9150_GPADC_HW_CHAN_VBUS_DIV_,\n\tDA9150_GPADC_HW_CHAN_ID,\n\tDA9150_GPADC_HW_CHAN_ID_,\n\tDA9150_GPADC_HW_CHAN_VSYS,\n\tDA9150_GPADC_HW_CHAN_VSYS_,\n\tDA9150_GPADC_HW_CHAN_GPIOA_6V,\n\tDA9150_GPADC_HW_CHAN_GPIOA_6V_,\n\tDA9150_GPADC_HW_CHAN_GPIOB_6V,\n\tDA9150_GPADC_HW_CHAN_GPIOB_6V_,\n\tDA9150_GPADC_HW_CHAN_GPIOC_6V,\n\tDA9150_GPADC_HW_CHAN_GPIOC_6V_,\n\tDA9150_GPADC_HW_CHAN_GPIOD_6V,\n\tDA9150_GPADC_HW_CHAN_GPIOD_6V_,\n\tDA9150_GPADC_HW_CHAN_VBAT,\n\tDA9150_GPADC_HW_CHAN_VBAT_,\n\tDA9150_GPADC_HW_CHAN_TBAT,\n\tDA9150_GPADC_HW_CHAN_TBAT_,\n\tDA9150_GPADC_HW_CHAN_TJUNC_CORE,\n\tDA9150_GPADC_HW_CHAN_TJUNC_CORE_,\n\tDA9150_GPADC_HW_CHAN_TJUNC_OVP,\n\tDA9150_GPADC_HW_CHAN_TJUNC_OVP_,\n};\n\nenum da9150_gpadc_channel {\n\tDA9150_GPADC_CHAN_GPIOA = 0,\n\tDA9150_GPADC_CHAN_GPIOB,\n\tDA9150_GPADC_CHAN_GPIOC,\n\tDA9150_GPADC_CHAN_GPIOD,\n\tDA9150_GPADC_CHAN_IBUS,\n\tDA9150_GPADC_CHAN_VBUS,\n\tDA9150_GPADC_CHAN_VSYS,\n\tDA9150_GPADC_CHAN_VBAT,\n\tDA9150_GPADC_CHAN_TBAT,\n\tDA9150_GPADC_CHAN_TJUNC_CORE,\n\tDA9150_GPADC_CHAN_TJUNC_OVP,\n};\n\n \nstruct da9150_gpadc {\n\tstruct da9150 *da9150;\n\tstruct device *dev;\n\n\tstruct mutex lock;\n\tstruct completion complete;\n};\n\n\nstatic irqreturn_t da9150_gpadc_irq(int irq, void *data)\n{\n\n\tstruct da9150_gpadc *gpadc = data;\n\n\tcomplete(&gpadc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9150_gpadc_read_adc(struct da9150_gpadc *gpadc, int hw_chan)\n{\n\tu8 result_regs[2];\n\tint result;\n\n\tmutex_lock(&gpadc->lock);\n\n\t \n\tda9150_reg_write(gpadc->da9150, DA9150_GPADC_MAN,\n\t\t\t (DA9150_GPADC_EN_MASK |\n\t\t\t  hw_chan << DA9150_GPADC_MUX_SHIFT));\n\n\t \n\ttry_wait_for_completion(&gpadc->complete);\n\n\t \n\twait_for_completion_timeout(&gpadc->complete, msecs_to_jiffies(5));\n\n\t \n\tda9150_bulk_read(gpadc->da9150, DA9150_GPADC_RES_A, 2, result_regs);\n\n\tmutex_unlock(&gpadc->lock);\n\n\t \n\tif (result_regs[1] & DA9150_GPADC_RUN_MASK) {\n\t\tdev_err(gpadc->dev, \"Timeout on channel %d of GPADC\\n\",\n\t\t\thw_chan);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tresult = (result_regs[1] & DA9150_GPADC_RES_L_MASK) >>\n\t\t DA9150_GPADC_RES_L_SHIFT;\n\t \n\tresult |= result_regs[0] << DA9150_GPADC_RES_L_BITS;\n\n\treturn result;\n}\n\nstatic inline int da9150_gpadc_gpio_6v_voltage_now(int raw_val)\n{\n\t \n\treturn (6 * ((raw_val * 1000) + 500)) / 1024;\n}\n\nstatic inline int da9150_gpadc_ibus_current_avg(int raw_val)\n{\n\t \n\treturn (4 * ((raw_val * 1000) + 500)) / 2048;\n}\n\nstatic inline int da9150_gpadc_vbus_21v_voltage_now(int raw_val)\n{\n\t \n\treturn (21 * ((raw_val * 1000) + 500)) / 1024;\n}\n\nstatic inline int da9150_gpadc_vsys_6v_voltage_now(int raw_val)\n{\n\t \n\treturn (3 * ((raw_val * 1000) + 500)) / 512;\n}\n\nstatic int da9150_gpadc_read_processed(struct da9150_gpadc *gpadc, int channel,\n\t\t\t\t       int hw_chan, int *val)\n{\n\tint raw_val;\n\n\traw_val = da9150_gpadc_read_adc(gpadc, hw_chan);\n\tif (raw_val < 0)\n\t\treturn raw_val;\n\n\tswitch (channel) {\n\tcase DA9150_GPADC_CHAN_GPIOA:\n\tcase DA9150_GPADC_CHAN_GPIOB:\n\tcase DA9150_GPADC_CHAN_GPIOC:\n\tcase DA9150_GPADC_CHAN_GPIOD:\n\t\t*val = da9150_gpadc_gpio_6v_voltage_now(raw_val);\n\t\tbreak;\n\tcase DA9150_GPADC_CHAN_IBUS:\n\t\t*val = da9150_gpadc_ibus_current_avg(raw_val);\n\t\tbreak;\n\tcase DA9150_GPADC_CHAN_VBUS:\n\t\t*val = da9150_gpadc_vbus_21v_voltage_now(raw_val);\n\t\tbreak;\n\tcase DA9150_GPADC_CHAN_VSYS:\n\t\t*val = da9150_gpadc_vsys_6v_voltage_now(raw_val);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*val = raw_val;\n\t\tbreak;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int da9150_gpadc_read_scale(int channel, int *val, int *val2)\n{\n\tswitch (channel) {\n\tcase DA9150_GPADC_CHAN_VBAT:\n\t\t*val = 2932;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase DA9150_GPADC_CHAN_TJUNC_CORE:\n\tcase DA9150_GPADC_CHAN_TJUNC_OVP:\n\t\t*val = 1000000;\n\t\t*val2 = 4420;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int da9150_gpadc_read_offset(int channel, int *val)\n{\n\tswitch (channel) {\n\tcase DA9150_GPADC_CHAN_VBAT:\n\t\t*val = 1500000 / 2932;\n\t\treturn IIO_VAL_INT;\n\tcase DA9150_GPADC_CHAN_TJUNC_CORE:\n\tcase DA9150_GPADC_CHAN_TJUNC_OVP:\n\t\t*val = -144;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int da9150_gpadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct da9150_gpadc *gpadc = iio_priv(indio_dev);\n\n\tif ((chan->channel < DA9150_GPADC_CHAN_GPIOA) ||\n\t    (chan->channel > DA9150_GPADC_CHAN_TJUNC_OVP))\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\treturn da9150_gpadc_read_processed(gpadc, chan->channel,\n\t\t\t\t\t\t   chan->address, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn da9150_gpadc_read_scale(chan->channel, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn da9150_gpadc_read_offset(chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info da9150_gpadc_info = {\n\t.read_raw = &da9150_gpadc_read_raw,\n};\n\n#define DA9150_GPADC_CHANNEL(_id, _hw_id, _type, chan_info,\t\\\n\t\t\t     _ext_name) {\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = DA9150_GPADC_CHAN_##_id,\t\t\t\\\n\t.address = DA9150_GPADC_HW_CHAN_##_hw_id,\t\t\\\n\t.info_mask_separate = chan_info,\t\t\t\\\n\t.extend_name = _ext_name,\t\t\t\t\\\n\t.datasheet_name = #_id,\t\t\t\t\t\\\n}\n\n#define DA9150_GPADC_CHANNEL_RAW(_id, _hw_id, _type, _ext_name)\t\\\n\tDA9150_GPADC_CHANNEL(_id, _hw_id, _type,\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_RAW), _ext_name)\n\n#define DA9150_GPADC_CHANNEL_SCALED(_id, _hw_id, _type, _ext_name)\t\\\n\tDA9150_GPADC_CHANNEL(_id, _hw_id, _type,\t\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_OFFSET),\t\t\t\\\n\t\t\t     _ext_name)\n\n#define DA9150_GPADC_CHANNEL_PROCESSED(_id, _hw_id, _type, _ext_name)\t\\\n\tDA9150_GPADC_CHANNEL(_id, _hw_id, _type,\t\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_PROCESSED), _ext_name)\n\n \nstatic const struct iio_chan_spec da9150_gpadc_channels[] = {\n\tDA9150_GPADC_CHANNEL_PROCESSED(GPIOA, GPIOA_6V, IIO_VOLTAGE, NULL),\n\tDA9150_GPADC_CHANNEL_PROCESSED(GPIOB, GPIOB_6V, IIO_VOLTAGE, NULL),\n\tDA9150_GPADC_CHANNEL_PROCESSED(GPIOC, GPIOC_6V, IIO_VOLTAGE, NULL),\n\tDA9150_GPADC_CHANNEL_PROCESSED(GPIOD, GPIOD_6V, IIO_VOLTAGE, NULL),\n\tDA9150_GPADC_CHANNEL_PROCESSED(IBUS, IBUS_SENSE, IIO_CURRENT, \"ibus\"),\n\tDA9150_GPADC_CHANNEL_PROCESSED(VBUS, VBUS_DIV_, IIO_VOLTAGE, \"vbus\"),\n\tDA9150_GPADC_CHANNEL_PROCESSED(VSYS, VSYS, IIO_VOLTAGE, \"vsys\"),\n\tDA9150_GPADC_CHANNEL_SCALED(VBAT, VBAT, IIO_VOLTAGE, \"vbat\"),\n\tDA9150_GPADC_CHANNEL_RAW(TBAT, TBAT, IIO_VOLTAGE, \"tbat\"),\n\tDA9150_GPADC_CHANNEL_SCALED(TJUNC_CORE, TJUNC_CORE, IIO_TEMP,\n\t\t\t\t    \"tjunc_core\"),\n\tDA9150_GPADC_CHANNEL_SCALED(TJUNC_OVP, TJUNC_OVP, IIO_TEMP,\n\t\t\t\t    \"tjunc_ovp\"),\n};\n\n \nstatic struct iio_map da9150_gpadc_default_maps[] = {\n\t{\n\t\t.consumer_dev_name = \"da9150-charger\",\n\t\t.consumer_channel = \"CHAN_IBUS\",\n\t\t.adc_channel_label = \"IBUS\",\n\t},\n\t{\n\t\t.consumer_dev_name = \"da9150-charger\",\n\t\t.consumer_channel = \"CHAN_VBUS\",\n\t\t.adc_channel_label = \"VBUS\",\n\t},\n\t{\n\t\t.consumer_dev_name = \"da9150-charger\",\n\t\t.consumer_channel = \"CHAN_TJUNC\",\n\t\t.adc_channel_label = \"TJUNC_CORE\",\n\t},\n\t{\n\t\t.consumer_dev_name = \"da9150-charger\",\n\t\t.consumer_channel = \"CHAN_VBAT\",\n\t\t.adc_channel_label = \"VBAT\",\n\t},\n\t{},\n};\n\nstatic int da9150_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9150 *da9150 = dev_get_drvdata(dev->parent);\n\tstruct da9150_gpadc *gpadc;\n\tstruct iio_dev *indio_dev;\n\tint irq, ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*gpadc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tgpadc = iio_priv(indio_dev);\n\n\tgpadc->da9150 = da9150;\n\tgpadc->dev = dev;\n\tmutex_init(&gpadc->lock);\n\tinit_completion(&gpadc->complete);\n\n\tirq = platform_get_irq_byname(pdev, \"GPADC\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, da9150_gpadc_irq,\n\t\t\t\t\tIRQF_ONESHOT, \"GPADC\", gpadc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_map_array_register(&pdev->dev, indio_dev, da9150_gpadc_default_maps);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IIO maps: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &da9150_gpadc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = da9150_gpadc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(da9150_gpadc_channels);\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic struct platform_driver da9150_gpadc_driver = {\n\t.driver = {\n\t\t.name = \"da9150-gpadc\",\n\t},\n\t.probe = da9150_gpadc_probe,\n};\n\nmodule_platform_driver(da9150_gpadc_driver);\n\nMODULE_DESCRIPTION(\"GPADC Driver for DA9150\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}