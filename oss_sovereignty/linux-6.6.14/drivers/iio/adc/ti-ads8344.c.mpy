{
  "module_name": "ti-ads8344.c",
  "hash_id": "507d4a2c555daaa966945461c5ef8204e7fb9e3e87b69daf4d7430467fc29dda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads8344.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#define ADS8344_START BIT(7)\n#define ADS8344_SINGLE_END BIT(2)\n#define ADS8344_CHANNEL(channel) ((channel) << 4)\n#define ADS8344_CLOCK_INTERNAL 0x2  \n\nstruct ads8344 {\n\tstruct spi_device *spi;\n\tstruct regulator *reg;\n\t \n\tstruct mutex lock;\n\n\tu8 tx_buf __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_buf[3];\n};\n\n#define ADS8344_VOLTAGE_CHANNEL(chan, addr)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = chan,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.address = addr,\t\t\t\t\t\\\n\t}\n\n#define ADS8344_VOLTAGE_CHANNEL_DIFF(chan1, chan2, addr)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = (chan1),\t\t\t\t\t\\\n\t\t.channel2 = (chan2),\t\t\t\t\t\\\n\t\t.differential = 1,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.address = addr,\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec ads8344_channels[] = {\n\tADS8344_VOLTAGE_CHANNEL(0, 0),\n\tADS8344_VOLTAGE_CHANNEL(1, 4),\n\tADS8344_VOLTAGE_CHANNEL(2, 1),\n\tADS8344_VOLTAGE_CHANNEL(3, 5),\n\tADS8344_VOLTAGE_CHANNEL(4, 2),\n\tADS8344_VOLTAGE_CHANNEL(5, 6),\n\tADS8344_VOLTAGE_CHANNEL(6, 3),\n\tADS8344_VOLTAGE_CHANNEL(7, 7),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(0, 1, 8),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(2, 3, 9),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(4, 5, 10),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(6, 7, 11),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(1, 0, 12),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(3, 2, 13),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(5, 4, 14),\n\tADS8344_VOLTAGE_CHANNEL_DIFF(7, 6, 15),\n};\n\nstatic int ads8344_adc_conversion(struct ads8344 *adc, int channel,\n\t\t\t\t  bool differential)\n{\n\tstruct spi_device *spi = adc->spi;\n\tint ret;\n\n\tadc->tx_buf = ADS8344_START;\n\tif (!differential)\n\t\tadc->tx_buf |= ADS8344_SINGLE_END;\n\tadc->tx_buf |= ADS8344_CHANNEL(channel);\n\tadc->tx_buf |= ADS8344_CLOCK_INTERNAL;\n\n\tret = spi_write(spi, &adc->tx_buf, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(9);\n\n\tret = spi_read(spi, adc->rx_buf, sizeof(adc->rx_buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn adc->rx_buf[0] << 9 | adc->rx_buf[1] << 1 | adc->rx_buf[2] >> 7;\n}\n\nstatic int ads8344_read_raw(struct iio_dev *iio,\n\t\t\t    struct iio_chan_spec const *channel, int *value,\n\t\t\t    int *shift, long mask)\n{\n\tstruct ads8344 *adc = iio_priv(iio);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\t*value = ads8344_adc_conversion(adc, channel->address,\n\t\t\t\t\t\tchannel->differential);\n\t\tmutex_unlock(&adc->lock);\n\t\tif (*value < 0)\n\t\t\treturn *value;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*value = regulator_get_voltage(adc->reg);\n\t\tif (*value < 0)\n\t\t\treturn *value;\n\n\t\t \n\t\t*value /= 1000;\n\t\t*shift = 16;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ads8344_info = {\n\t.read_raw = ads8344_read_raw,\n};\n\nstatic void ads8344_reg_disable(void *data)\n{\n\tregulator_disable(data);\n}\n\nstatic int ads8344_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ads8344 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\tmutex_init(&adc->lock);\n\n\tindio_dev->name = dev_name(&spi->dev);\n\tindio_dev->info = &ads8344_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ads8344_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ads8344_channels);\n\n\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(adc->reg))\n\t\treturn PTR_ERR(adc->reg);\n\n\tret = regulator_enable(adc->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ads8344_reg_disable, adc->reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ads8344_of_match[] = {\n\t{ .compatible = \"ti,ads8344\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ads8344_of_match);\n\nstatic struct spi_driver ads8344_driver = {\n\t.driver = {\n\t\t.name = \"ads8344\",\n\t\t.of_match_table = ads8344_of_match,\n\t},\n\t.probe = ads8344_probe,\n};\nmodule_spi_driver(ads8344_driver);\n\nMODULE_AUTHOR(\"Gregory CLEMENT <gregory.clement@bootlin.com>\");\nMODULE_DESCRIPTION(\"ADS8344 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}